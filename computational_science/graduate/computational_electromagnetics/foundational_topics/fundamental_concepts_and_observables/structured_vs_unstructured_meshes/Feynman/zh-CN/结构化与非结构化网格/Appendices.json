{
    "hands_on_practices": [
        {
            "introduction": "在选择网格类型时，一个首要的考量是计算成本，它直接关系到未知量或自由度（Degrees of Freedom, DoFs）的数量。这个练习提供了一个具体的、定量的比较：对于相同的求解域，一个结构化六面体网格和一个可比的非结构化四面体网格，它们的自由度数量有何不同。通过这个练习，你将揭示两者在离散化电磁问题时重要的规模缩放差异。",
            "id": "3351211",
            "problem": "考虑边长为 $L$ 的立方腔域 $\\Omega = [0,L]^{3}$ 中的时谐麦克斯韦旋度-旋度公式。假设电场使用一阶旋度协调 Nédélec 边元（第一类）进行离散化，使得每条唯一的网格边都恰好承载一个标量自由度。忽略边界条件约束；也就是说，将每条网格边都视为一个独立的未知量。\n\n考虑 $\\Omega$ 的两种网格，两者都通过关系式 $h = L/n$ 由一个正整数 $n$ 参数化：\n\n- 一种结构化六面体网格：立方体沿每个坐标轴被划分为 $n$ 个均匀区间，从而产生 $n^{3}$ 个边长为 $h$ 的全等六面体单元。\n\n- 一种四面体网格，其平均边长为 $\\Theta(h)$，通过将结构化网格中的每个六面体单元使用一致的 Freudenthal 型对角化方法细分为 6 个四面体而获得：在每个六面体中，插入长的空间对角线，并为每个四边形面选择一条对角线，对角线的选择在相邻单元间保持一致，以便共享面具有相同的对角线。\n\n仅使用以下基本事实：(i) 一阶 Nédélec 边元为每条唯一的网格边关联一个自由度，以及 (ii) 六面体网格的节点、边、面和单元的数量可以作为 $n$ 的函数通过组合方法计算出来，完成以下任务：\n\n- 推导出结构化六面体网格上边未知量的精确总数 $N_{\\mathrm{hex}}(n)$（用 $n$ 表示）。\n\n- 推导出按上述方式构建的四面体网格上边未知量的精确总数 $N_{\\mathrm{tet}}(n)$（用 $n$ 表示）。\n\n- 根据这些表达式，确定每种网格关于 $h$ 的主阶缩放关系，然后计算渐近比率\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} \\, ,\n$$\n该比率纯粹表示为常数的函数（即，与 $h$ 和 $L$ 无关）。此处，$N_{\\mathrm{hex}}(h)$ 和 $N_{\\mathrm{tet}}(h)$ 表示通过 $n=L/h$ 用 $h$ 表示的数量。\n\n将最终的渐近比率报告为一个简化的有理数。无需四舍五入。答案是无量纲的；不要包含单位。",
            "solution": "该问题要求推导立方腔域 $\\Omega = [0,L]^3$ 的两种不同网格离散化方案下的自由度（DoFs）数量。由于使用了一阶 Nédélec 边元，自由度数量对应于唯一网格边的数量。必须对结构化六面体网格和派生的四面体网格进行分析。最后，必须计算当网格尺寸 $h$ 趋于零时，两种网格的边数之比的渐近值。\n\n首先，我们推导结构化六面体网格的边未知量精确数量 $N_{\\mathrm{hex}}(n)$。该网格是通过将立方体沿三个坐标轴各划分为 $n$ 个区间而形成的。这会产生一个 $(n+1) \\times (n+1) \\times (n+1)$ 个顶点的网格，这些顶点可以通过 $(i,j,k)$ 进行索引，其中 $i, j, k \\in \\{0, 1, \\dots, n\\}$。该网格的边是连接相邻顶点的线段。我们可以根据边的方向对其进行分类计数。\n\n1.  平行于 $x$ 轴的边：这些边连接形如 $(i, j, k)$ 和 $(i+1, j, k)$ 的顶点。索引 $i$ 的范围可以从 $0$ 到 $n-1$（共 $n$ 种选择），而索引 $j$ 和 $k$ 的范围都可以从 $0$ 到 $n$（各 $n+1$ 种选择）。因此，平行于 $x$ 轴的边数为 $n \\times (n+1) \\times (n+1)$。\n\n2.  平行于 $y$ 轴的边：类似地，这些边连接顶点 $(i, j, k)$ 和 $(i, j+1, k)$。索引 $j$ 的范围从 $0$ 到 $n-1$，而 $i$ 和 $k$ 的范围从 $0$ 到 $n$。这类边的数量为 $(n+1) \\times n \\times (n+1)$。\n\n3.  平行于 $z$ 轴的边：这些边连接顶点 $(i, j, k)$ 和 $(i, j, k+1)$。索引 $k$ 的范围从 $0$ 到 $n-1$，而 $i$ 和 $j$ 的范围从 $0$ 到 $n$。数量为 $(n+1) \\times (n+1) \\times n$。\n\n边的总数 $N_{\\mathrm{hex}}(n)$ 是这三项计数的总和。根据对称性，这三项计数是相同的。\n$$\nN_{\\mathrm{hex}}(n) = 3 \\times n \\times (n+1)^2\n$$\n展开此表达式可得到多项式形式：\n$$\nN_{\\mathrm{hex}}(n) = 3n(n^2 + 2n + 1) = 3n^3 + 6n^2 + 3n\n$$\n接下来，我们推导四面体网格的边未知量精确数量 $N_{\\mathrm{tet}}(n)$。该网格是通过将原始网格的 $n^3$ 个六面体单元中的每一个进行细分而构建的。问题指明，该细分过程会向网格中添加新的边：在每个六面体内插入一条长的空间对角线，并为每个四边形面选择一条对角线。面对角线的选择在共享面上是一致的。\n\n因此，四面体网格中的总边集是三个不相交的边集的并集：\n1.  六面体网格的原始边。这些边的数量为 $N_{\\mathrm{hex}}(n) = 3n(n+1)^2$。\n2.  新创建的空间对角线。$n^3$ 个六面体单元中的每一个都在其内部添加了一条空间对角线。由于这些对角线位于单元内部，它们不被共享。因此，这恰好增加了 $n^3$ 条新边。\n3.  新创建的面对角线。问题指出，为六面体网格的每个面引入一条对角线。这意味着新面对角线的数量等于六面体网格中的总面数。我们可以按方向对面进行计数：\n    -   平行于 $xy$ 平面的面：在 $n+1$ 个顶点的水平层中，每层有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    -   平行于 $yz$ 平面的面：在 $n+1$ 个矢状平面中，每个平面有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    -   平行于 $xz$ 平面的面：在 $n+1$ 个冠状平面中，每个平面有 $n \\times n$ 个这样的面。总计：$n^2(n+1)$。\n    总面数是这些数量之和，即 $3n^2(n+1)$。因此，由面对角线产生了 $3n^2(n+1)$ 条新边。\n\n四面体网格中的总边数 $N_{\\mathrm{tet}}(n)$ 是这三个来源的计数之和：\n$$\nN_{\\mathrm{tet}}(n) = N_{\\mathrm{hex}}(n) + (\\text{number of new space diagonals}) + (\\text{number of new face diagonals})\n$$\n$$\nN_{\\mathrm{tet}}(n) = [3n(n+1)^2] + [n^3] + [3n^2(n+1)]\n$$\n我们展开每一项并将它们相加：\n$$\nN_{\\mathrm{tet}}(n) = (3n^3 + 6n^2 + 3n) + n^3 + (3n^3 + 3n^2)\n$$\n$$\nN_{\\mathrm{tet}}(n) = (3+1+3)n^3 + (6+3)n^2 + 3n\n$$\n$$\nN_{\\mathrm{tet}}(n) = 7n^3 + 9n^2 + 3n\n$$\n最后，我们计算渐近比率 $\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)}$。网格参数 $n$ 与网格尺寸 $h$ 之间的关系由 $h = L/n$ 给出。当 $h \\to 0^+$ 时，对于固定的域大小 $L$，整数 $n$ 必须趋于无穷大 ($n \\to \\infty$)。因此，该极限可以关于 $n$ 进行计算：\n$$\n\\lim_{h \\to 0^{+}} \\frac{N_{\\mathrm{tet}}(h)}{N_{\\mathrm{hex}}(h)} = \\lim_{n \\to \\infty} \\frac{N_{\\mathrm{tet}}(n)}{N_{\\mathrm{hex}}(n)}\n$$\n我们将推导出的 $N_{\\mathrm{tet}}(n)$ 和 $N_{\\mathrm{hex}}(n)$ 的多项式表达式代入：\n$$\n\\lim_{n \\to \\infty} \\frac{7n^3 + 9n^2 + 3n}{3n^3 + 6n^2 + 3n}\n$$\n对于当变量趋于无穷大时多项式有理函数的极限，该极限等于分子和分母中最高次项系数之比。最高次幂是 $n^3$。\n$$\n\\lim_{n \\to \\infty} \\frac{n^3(7 + \\frac{9}{n} + \\frac{3}{n^2})}{n^3(3 + \\frac{6}{n} + \\frac{3}{n^2})} = \\lim_{n \\to \\infty} \\frac{7 + \\frac{9}{n} + \\frac{3}{n^2}}{3 + \\frac{6}{n} + \\frac{3}{n^2}}\n$$\n当 $n \\to \\infty$ 时，诸如 $\\frac{9}{n}$、$\\frac{3}{n^2}$ 和 $\\frac{6}{n}$ 的项趋于 $0$。\n$$\n\\frac{7 + 0 + 0}{3 + 0 + 0} = \\frac{7}{3}\n$$\n$N_{\\mathrm{hex}}$ 和 $N_{\\mathrm{tet}}$ 的主阶缩放均为 $O(n^3)$，这对应于 $O(h^{-3})$。渐近比率是主阶系数之比，即 $7/3$。",
            "answer": "$$\n\\boxed{\\frac{7}{3}}\n$$"
        },
        {
            "introduction": "除了计算成本，精度同样至关重要，尤其是在模拟复杂几何结构中的波物理现象时。本练习旨在探讨不同的网格划分策略如何近似弯曲几何，以及这种近似对数值色散和相位精度的影响。通过比较结构化曲线坐标网格、非结构化线性单元和二次单元，你将深入理解几何灵活性与物理保真度之间的权衡。",
            "id": "3351225",
            "problem": "考虑在自由空间中的电磁波传播，该过程由麦克斯韦方程组控制，并使用交错网格时域有限差分格式进行离散化，该格式将电场和磁场分量放置在交错的空间位置上，并通过显式更新在时间上进行推进。目标是研究在表示平滑弯曲路径时，几何拟合策略对数值色散和相位精度的影响。您将比较两种几何拟合策略：逻辑结构化网格上的曲线映射和弯曲的非结构化单元，并且您将明确量化雅可比行列式和度量尺度因子的近似如何影响离散色散关系。\n\n从基本出发点开始：自由空间中的麦克斯韦方程组，\n$$\n\\nabla \\times \\mathbf{E} = -\\mu_0 \\frac{\\partial \\mathbf{H}}{\\partial t}, \\quad \\nabla \\times \\mathbf{H} = \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t},\n$$\n波速为 $c = \\frac{1}{\\sqrt{\\mu_0 \\varepsilon_0}}$。考虑一个二维横电（TE）配置，其电场为平面外分量，磁场为平面内分量，其中传播方向与半径为R的圆弧（中心线）相切，并由角度坐标参数化。在结构化情况下，采用与圆对齐的正交曲线映射，使得切向坐标的度量尺度因子为 $h_\\xi$，法向坐标的度量尺度因子为 $h_\\eta$，且映射的雅可比行列式满足 $J = h_\\xi h_\\eta$。在非结构化情况下，考虑弯曲单元上的等参边：端点之间的线性边（一条直弦）和由二次拉格朗日形函数定义的二次边，该函数插值了放置在圆形边界上的三个节点；导出的雅可比和度量项由单元映射近似。您需要通过推导沿切向传播的离散色散关系来分析数值色散，同时考虑空间步长的度量缩放和显式时间步长，并计算由此产生的相位速度误差。\n\n您的程序必须实现以下步骤：\n\n1. 对中心线半径为 R、每个单元角范围为 $\\Delta\\theta$（以弧度为单位）的圆弧进行几何建模。定义沿切向的三个有效空间步长：\n   - 结构化曲线映射：使用与映射对齐的精确弧长 $s_{\\text{arc}} = R \\Delta \\theta$，其中中心线上的精确度量尺度因子为 $h_\\xi$。\n   - 非结构化线性边：使用弦长 $s_{\\text{chord}} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)$ 作为沿切向的有效单元尺寸，这反映了直边对雅可比和度量的近似。\n   - 非结构化二次曲线边：通过对角度为 $0$ 和 $\\Delta \\theta$ 的端点以及角度为 $\\frac{\\Delta \\theta}{2}$ 的边中点进行二次拉格朗日插值，构建一个二次等参边；计算有效边长\n     $$\n     s_{\\text{quad}} = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2}\\, dt,\n     $$\n     其中 $(x(t),y(t))$ 是使用标准二次拉格朗日形函数，在参数 $t \\in [-1,1]$ 上对节点坐标进行二次插值得到的。当雅可比行列式由二次等参映射近似时，该积分表示由度量导出的长度。\n\n2. 从自由空间平面波关系 $k = \\frac{2\\pi}{\\lambda}$（其中波长 $\\lambda$ 的单位为米）和角频率 $\\omega = c k$ 出发，使用沿切向的一维交错时域有限差分色散关系，为每个有效步长求出离散数值角频率 $\\omega_{\\text{num}}$，其中空间步长为 $\\Delta s$，时间步长为 $\\Delta t$。该关系必须从正交曲线坐标系下的麦克斯韦方程组推导得出；它应通过有效步长隐式地考虑度量尺度因子，并生成作为 $k$、$\\Delta s$ 和 $\\Delta t$ 函数的 $\\omega_{\\text{num}}$，而不使用简化公式。\n\n3. 对于每种情况，计算数值相速度 $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$ 和相对相速度误差\n   $$\n   e = \\frac{v_{\\text{num}} - c}{c},\n   $$\n   该误差是无量纲的，并且必须以十进制数（不带百分号）的形式报告。\n\n4. 使用由库朗因子 $\\sigma \\in (0,1)$ 决定的显式时间步长\n   $$\n   \\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c},\n   $$\n   这确保了在给定情况下三种策略的稳定性。\n\n角度单位必须是弧度。所有长度单位必须是米。光速必须为 $c = 299792458\\,\\mathrm{m/s}$。最终输出必须是表示相对相速度误差的无量纲十进制数。\n\n测试套件：\n实现您的程序以评估以下四个测试用例，每个用例提供 $(R, \\Delta \\theta, \\lambda, \\sigma)$:\n\n- 用例1 (正常路径): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.2$ (弧度), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$。\n- 用例2 (精细角分辨率): $R = 1.0\\,\\mathrm{m}$, $\\Delta \\theta = 0.01$ (弧度), $\\lambda = 0.5\\,\\mathrm{m}$, $\\sigma = 0.95$。\n- 用例3 (强曲率): $R = 0.3\\,\\mathrm{m}$, $\\Delta \\theta = 0.5$ (弧度), $\\lambda = 0.25\\,\\mathrm{m}$, $\\sigma = 0.90$。\n- 用例4 (接近稳定性极限): $R = 0.2\\,\\mathrm{m}$, $\\Delta \\theta = 0.3$ (弧度), $\\lambda = 0.10\\,\\mathrm{m}$, $\\sigma = 0.99$。\n\n对于每个测试用例，您的程序必须按照结构化曲线弧、非结构化线性弦和非结构化二次曲线边的顺序计算并返回三个数。因此，对于四个用例，您的程序必须生成一行输出，其中包含十二个用逗号分隔并用方括号括起来的十进制数，顺序如下：\n$$\n[e_{1,\\text{arc}}, e_{1,\\text{chord}}, e_{1,\\text{quad}}, e_{2,\\text{arc}}, e_{2,\\text{chord}}, e_{2,\\text{quad}}, e_{3,\\text{arc}}, e_{3,\\text{chord}}, e_{3,\\text{quad}}, e_{4,\\text{arc}}, e_{4,\\text{chord}}, e_{4,\\text{quad}}].\n$$\n不得打印任何额外文本。",
            "solution": "该问题被认为是有效的，因为它在科学上基于 Maxwell 理论和计算电磁学，是适定的，具有明确的目标和充分的数据，并且没有矛盾或含糊之处。\n\n解决方案首先确定三种不同几何建模策略的有效切向空间步长。其次，从麦克斯韦方程组推导出一维时域有限差分（FDTD）的数值色散关系。第三，使用此关系计算每种策略的数值相速度及其相对误差。最后，根据确保所有三种情况下都稳定的库朗条件确定时间步长。\n\n### 步骤 1：几何近似与有效步长\n\n我们考虑一个半径为 R 的圆弧，并计算对应于角跨度 $\\Delta\\theta$ 的单个离散段的长度。\n\n1.  **结构化曲线映射 ($s_{\\text{arc}}$)**：在一个与圆形几何完全对齐的结构化曲线网格中，沿切向的单元边遵循圆弧本身。该弧段的精确长度为：\n    $$\n    s_{\\text{arc}} = R \\Delta \\theta\n    $$\n\n2.  **非结构化，线性边 ($s_{\\text{chord}}$)**：当非结构化网格使用直边单元（例如，线性三角形）来近似曲线时，该分段是连接圆弧上两个端点的直线。这就是弦长。对于从角度 $0$ 开始到 $\\Delta \\theta$ 结束的弧段，端点可以放在 $(R, 0)$ 和 $(R \\cos \\Delta \\theta, R \\sin \\Delta \\theta)$。弦长是它们之间的距离，可简化为：\n    $$\n    s_{\\text{chord}} = \\sqrt{(R \\cos \\Delta \\theta - R)^2 + (R \\sin \\Delta \\theta - 0)^2} = R \\sqrt{\\cos^2 \\Delta \\theta - 2 \\cos \\Delta \\theta + 1 + \\sin^2 \\Delta \\theta} = R \\sqrt{2 - 2 \\cos \\Delta \\theta}\n    $$\n    使用半角恒等式 $1 - \\cos \\Delta \\theta = 2 \\sin^2(\\frac{\\Delta \\theta}{2})$，可得：\n    $$\n    s_{\\text{chord}} = R \\sqrt{4 \\sin^2\\left(\\frac{\\Delta \\theta}{2}\\right)} = 2 R \\sin\\left(\\frac{\\Delta \\theta}{2}\\right)\n    $$\n\n3.  **非结构化，二次曲线边 ($s_{\\text{quad}}$)**：更高阶的近似使用弯曲单元。我们使用二次等参映射对该分段进行建模。三个节点放置在圆弧上：分别在角度 $0$、$\\frac{\\Delta\\theta}{2}$ 和 $\\Delta\\theta$ 处。在局部坐标系 $t \\in [-1, 1]$ 中，这些节点的位置使用二次 Lagrange 形函数进行插值：\n    $$\n    N_{-1}(t) = \\frac{t(t-1)}{2}, \\quad N_{0}(t) = 1-t^2, \\quad N_{1}(t) = \\frac{t(t+1)}{2}\n    $$\n    $t=-1$ 处的节点对应角度 $0$，$t=0$ 对应角度 $\\frac{\\Delta\\theta}{2}$，$t=1$ 对应角度 $\\Delta\\theta$。物理坐标 $(x(t), y(t))$ 由下式给出：\n    $$\n    \\mathbf{r}(t) = \\mathbf{r}_{-1} N_{-1}(t) + \\mathbf{r}_{0} N_{0}(t) + \\mathbf{r}_{1} N_{1}(t)\n    $$\n    其中 $\\mathbf{r}_{-1}=(R,0)$，$\\mathbf{r}_{0}=(R\\cos(\\frac{\\Delta\\theta}{2}), R\\sin(\\frac{\\Delta\\theta}{2}))$，以及 $\\mathbf{r}_{1}=(R\\cos(\\Delta\\theta), R\\sin(\\Delta\\theta))$。这个弯曲边的有效长度是其微分弧长的积分：\n    $$\n    s_{\\text{quad}} = \\int_{-1}^{1} \\left\\| \\frac{d\\mathbf{r}}{dt} \\right\\| dt = \\int_{-1}^{1} \\sqrt{\\left(\\frac{dx}{dt}\\right)^2 + \\left(\\frac{dy}{dt}\\right)^2} dt\n    $$\n    导数是 t 的线性函数：$\\frac{dx}{dt} = A_x t + B_x$ 和 $\\frac{dy}{dt} = A_y t + B_y$，其中系数为：\n    $$\n    A_x = R\\left(1 + \\cos(\\Delta\\theta) - 2\\cos\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_x = \\frac{R}{2}(\\cos(\\Delta\\theta)-1)\n    $$\n    $$\n    A_y = R\\left(\\sin(\\Delta\\theta) - 2\\sin\\left(\\frac{\\Delta\\theta}{2}\\right)\\right), \\quad B_y = \\frac{R}{2}\\sin(\\Delta\\theta)\n    $$\n    该积分使用数值积分法计算。\n\n### 步骤 2：FDTD 色散关系\n\n对于一个沿正交曲线坐标 $\\xi$ 定义的路径纯切向传播的二维横电波（$E_z, H_x, H_y$），麦克斯韦方程组可简化为一个一维系统。假设在法向是均匀的（$\\frac{\\partial}{\\partial \\eta}=0$），相关方程为：\n$$\n\\frac{1}{h_\\xi} \\frac{\\partial E_z}{\\partial \\xi} = \\mu_0 \\frac{\\partial H_\\eta}{\\partial t}, \\quad \\frac{1}{h_\\xi} \\frac{\\partial H_\\eta}{\\partial \\xi} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\n其中 $h_\\xi$ 是度量尺度因子。通过定义物理路径长度变量 $s$（使得 $ds = h_\\xi d\\xi$）和一个有效空间步长 $\\Delta s$，这些方程可以写成标准的一维笛卡尔坐标系下的麦克斯韦方程组形式：\n$$\n\\frac{\\partial E_z}{\\partial s} = \\mu_0 \\frac{\\partial H_y}{\\partial t}, \\quad \\frac{\\partial H_y}{\\partial s} = \\varepsilon_0 \\frac{\\partial E_z}{\\partial t}\n$$\n使用交错蛙跳 FDTD 格式对这些方程进行离散化，可得：\n$$\n\\frac{E_z|_i^{n+1/2} - E_z|_i^{n-1/2}}{\\Delta t} = \\frac{1}{\\varepsilon_0} \\frac{H_y|_{i+1/2}^n - H_y|_{i-1/2}^n}{\\Delta s}\n$$\n$$\n\\frac{H_y|_{i+1/2}^{n+1} - H_y|_{i+1/2}^n}{\\Delta t} = \\frac{1}{\\mu_0} \\frac{E_z|_{i+1}^{n+1/2} - E_z|_i^{n+1/2}}{\\Delta s}\n$$\n假设一个形式为 $e^{j(k s - \\omega_{\\text{num}} t)}$ 的谐波平面波解，其中 $k$ 是解析波数，$\\omega_{\\text{num}}$ 是数值角频率，将其代入有限差分方程，得到数值色散关系：\n$$\n\\sin\\left(\\frac{\\omega_{\\text{num}} \\Delta t}{2}\\right) = \\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\n$$\n其中 $c = 1/\\sqrt{\\mu_0 \\varepsilon_0}$ 是真空中的光速。由此，我们解出 $\\omega_{\\text{num}}$：\n$$\n\\omega_{\\text{num}} = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right)\n$$\n对于给定的波长 $\\lambda$，解析波数为 $k = \\frac{2\\pi}{\\lambda}$。对于三种有效步长 $\\Delta s \\in \\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}$ 中的每一种，此关系都成立。\n\n### 步骤 3：相位速度误差\n\n数值相速度定义为 $v_{\\text{num}} = \\frac{\\omega_{\\text{num}}}{k}$。理想相速度为 $c$。因此，相对误差 $e$ 为：\n$$\ne = \\frac{v_{\\text{num}} - c}{c} = \\frac{v_{\\text{num}}}{c} - 1\n$$\n代入 $\\omega_{\\text{num}}$ 的表达式，得到误差的最终公式：\n$$\ne = \\frac{2}{c k \\Delta t} \\arcsin\\left(\\frac{c \\Delta t}{\\Delta s} \\sin\\left(\\frac{k \\Delta s}{2}\\right)\\right) - 1\n$$\n\n### 步骤 4：时间步长计算\n\n为了确保显式时间推进格式在所有三种几何近似下使用单一时间步长时保持数值稳定性，$\\Delta t$ 的选择基于给定库朗因子 $\\sigma$ 下最严格（最小）的空间步长：\n$$\n\\Delta t = \\sigma \\frac{\\min\\{s_{\\text{arc}}, s_{\\text{chord}}, s_{\\text{quad}}\\}}{c}\n$$\n在一维情况下，为保证稳定性，库朗因子 $\\sigma$ 必须小于 1。这样的 $\\Delta t$ 选择保证了色散关系中 $\\arcsin$ 函数的参数小于 1，从而防止不稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for three different FDTD\n    geometry-fitting strategies on a circular arc.\n    \"\"\"\n\n    # Speed of light in vacuum (m/s)\n    c_light = 299792458.0\n\n    # Test cases: (R, delta_theta, lambda, sigma)\n    test_cases = [\n        (1.0, 0.2, 0.5, 0.95),   # Case 1: happy path\n        (1.0, 0.01, 0.5, 0.95),  # Case 2: fine angular resolution\n        (0.3, 0.5, 0.25, 0.90),  # Case 3: strong curvature\n        (0.2, 0.3, 0.10, 0.99),  # Case 4: near stability limit\n    ]\n\n    results = []\n\n    def calculate_s_quad(R, dtheta):\n        \"\"\"\n        Calculates the length of a quadratic isoparametric edge.\n        \"\"\"\n        if dtheta == 0.0:\n            return 0.0\n\n        # Define node positions corresponding to angles 0, dtheta/2, dtheta\n        # Mapped to local coordinates t = -1, 0, 1\n        r_m1 = np.array([R, 0.0])\n        r_0 = np.array([R * np.cos(dtheta / 2.0), R * np.sin(dtheta / 2.0)])\n        r_1 = np.array([R * np.cos(dtheta), R * np.sin(dtheta)])\n        \n        # Coefficients for dr/dt = A*t + B\n        # from r(t) = r_m1*N_m1(t) + r_0*N_0(t) + r_1*N_1(t)\n        # where N_m1, N_0, N_1 are standard quadratic Lagrange shape functions.\n        # This gives dr/dt = ((r_1-r_m1)/2) + (r_m1+r_1-2*r_0)*t\n        A = r_m1 + r_1 - 2 * r_0\n        B = (r_1 - r_m1) / 2.0\n        \n        Ax, Ay = A\n        Bx, By = B\n\n        # Integrand for arc length: sqrt((dx/dt)^2 + (dy/dt)^2)\n        def integrand(t):\n            dxdt = Ax * t + Bx\n            dydt = Ay * t + By\n            return np.sqrt(dxdt**2 + dydt**2)\n\n        # Numerical integration over t in [-1, 1]\n        s_quad_val, _ = quad(integrand, -1.0, 1.0)\n        return s_quad_val\n\n    def calculate_error(ds, dt, k, c):\n        \"\"\"\n        Calculates the relative phase velocity error.\n        \"\"\"\n        if ds == 0.0:\n            return 0.0 # Avoid division by zero, error is zero for zero step size\n\n        # Argument for the arcsin in the dispersion relation\n        courant_local = c * dt / ds\n        arg = courant_local * np.sin(k * ds / 2.0)\n        \n        # The choice of dt ensures abs(arg) = sigma  1\n        # so no complex numbers should arise.\n        if abs(arg) > 1.0:\n            # This case should not be reached with the problem's setup\n            arg = np.sign(arg)\n\n        omega_num = (2.0 / dt) * np.arcsin(arg)\n        v_num = omega_num / k\n        error = v_num / c - 1.0\n        return error\n\n    for R, dtheta, lambda_w, sigma in test_cases:\n        # Analytical wavenumber\n        k = 2.0 * np.pi / lambda_w\n\n        # Step 1: Calculate effective step sizes\n        s_arc = R * dtheta\n        s_chord = 2.0 * R * np.sin(dtheta / 2.0)\n        s_quad = calculate_s_quad(R, dtheta)\n\n        # Step 2: Calculate time step based on Courant condition\n        s_min = min(s_arc, s_chord, s_quad)\n        dt = sigma * s_min / c_light\n\n        # Step 3: Calculate errors for each geometry\n        error_arc = calculate_error(s_arc, dt, k, c_light)\n        error_chord = calculate_error(s_chord, dt, k, c_light)\n        error_quad = calculate_error(s_quad, dt, k, c_light)\n        \n        results.extend([error_arc, error_chord, error_quad])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于使用显式时域方法的仿真，其稳定性所允许的最大时间步长通常由网格中最小的单元决定，这是非结构化网格中的一个常见挑战。本练习深入探讨了这一关键的性能瓶颈，并探索了如质量集中（mass lumping）和局部时间步进（local time-stepping）等实用的补救技术。掌握这些技术对于实现大规模非结构化网格仿真的计算可行性至关重要。",
            "id": "3351147",
            "problem": "考虑麦克斯韦方程组在横电极化下的一维简化形式，其中电场分量 $u(x,t)$ 在具有狄利克雷边界条件的有限区间上满足标量波动方程 $u_{tt} = c^2 u_{xx}$。使用有限元法 (FEM)，在长度为 $h_e$ 的网格段上采用分段线性基函数，得到半离散二阶系统 $M u_{tt} + K u = 0$，其中 $M$ 是质量矩阵，$K$ 是由单元贡献组装而成的刚度矩阵。对于此半离散系统的完全显式中心差分时间积分器，其稳定性由矩阵束 $(K, M)$ 的最大广义特征值控制：如果 $K v = \\omega^2 M v$ 的最大值为 $\\omega_{\\max}$，则为保持稳定，全局时间步长必须满足 $\\Delta t \\le \\dfrac{2}{\\omega_{\\max}}$。在非结构化网格上，最小单元尺寸 $h_{\\min}$ 通常通过 $M^{-1}K$ 的谱半径决定 $\\Delta t$。质量集中通过行和集中的方法将一致质量矩阵替换为对角矩阵，这改变了谱，并能在保持显式性的同时允许更大的稳定时间步长 $\\Delta t$。\n\n从标量波动方程 $u_{tt} = c^2 u_{xx}$、其弱形式以及 $M$ 和 $K$ 的有限元组装出发，设计一个算法，该算法能够：\n- 针对两端均为狄利克雷边界条件的一维网格，使用单元贡献 $K_e = \\dfrac{c^2}{h_e}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix}$ 和 $M_e = \\dfrac{h_e}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix}$，组装一致质量矩阵 $M$ 和刚度矩阵 $K$。\n- 通过对 $M$ 进行对角行和集中，构造一个集中质量矩阵 $M_{\\mathrm{lump}}$。\n- 计算稳定的全局时间步长 $\\Delta t_{\\mathrm{global,cons}} = \\dfrac{2}{\\omega_{\\max,\\mathrm{cons}}}$ 和 $\\Delta t_{\\mathrm{global,lump}} = \\dfrac{2}{\\omega_{\\max,\\mathrm{lump}}}$，其中 $\\omega_{\\max,\\mathrm{cons}}$ 和 $\\omega_{\\max,\\mathrm{lump}}$ 分别是满足 $K v = \\omega^2 M v$ 或 $K v = \\omega^2 M_{\\mathrm{lump}} v$ 的最大广义特征值。\n- 设计一种单元上的局部时间步进方案，该方案在保持最近邻耦合稳定性的同时，实现更大的局部时间步长。使用最小的稳定全局时间步长 $\\Delta t_{\\min}$（针对每种质量矩阵选择），并为每个单元分配一个目标时间步长 $\\Delta t_e^{\\mathrm{target}} = \\Delta t_{\\min}\\,\\dfrac{h_e}{h_{\\min}}$。然后将每个 $\\Delta t_e^{\\mathrm{target}}$ 量化为 $\\Delta t_{\\min}$ 的2的幂次方倍数，即选择一个整数 $k_e \\ge 0$，使得 $\\Delta t_e = \\Delta t_{\\min}\\,2^{k_e} \\le \\Delta t_e^{\\mathrm{target}}$，并在此约束下使 $\\Delta t_e$ 尽可能大。通过确保对于每个相邻单元对 $(e,e+1)$，时间步长的比率最多为2（等效于 $|k_e - k_{e+1}| \\le 1$）来强制执行最近邻稳定性约束；如果违反该约束，则减小较大的 $k$ 值，直到所有地方都满足约束。\n- 在一个简单的单位成本模型中衡量计算效率，其中成本与单位模拟时间内单元更新的次数成正比。对于总模拟时间 $T$，为 $N$ 个单元定义全局显式成本 $C_{\\mathrm{global}} = N \\,\\dfrac{T}{\\Delta t_{\\min}}$，以及局部时间步进成本 $C_{\\mathrm{LTS}} = \\sum_{e=1}^N \\dfrac{T}{\\Delta t_e}$。加速比为 $S = \\dfrac{C_{\\mathrm{global}}}{C_{\\mathrm{LTS}}}$。\n\n您的程序必须精确实现上述组装和计算，并为以下测试套件生成数值结果。在所有情况下，时间以秒为单位报告，$c$ 的单位为米/秒，$h_e$ 的单位为米，并取总模拟时间为 $T = 1$ 秒。\n\n测试套件：\n- 案例1（结构化网格，理想路径）：$h = [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01]$，$c = 3\\times 10^8$。\n- 案例2（非结构化网格，含一个极小单元，瓶颈）：$h = [0.01, 0.01, 0.0001, 0.01, 0.01]$，$c = 3\\times 10^8$。\n- 案例3（渐变非结构化网格，边缘条件覆盖）：$h = [0.0005, 0.001, 0.002, 0.004, 0.008]$，$c = 3\\times 10^8$。\n\n对每个案例，计算：\n- $\\Delta t_{\\mathrm{global,cons}}$ 和 $\\Delta t_{\\mathrm{global,lump}}$（以秒为单位）。\n- 对应各自局部时间步进方案的加速比 $S_{\\mathrm{cons}}$ 和 $S_{\\mathrm{lump}}$。\n- 在强制执行最近邻约束后，不同的局部时间步长组的总数 $G_{\\mathrm{cons}} = \\max_e k_e + 1$ 和 $G_{\\mathrm{lump}} = \\max_e k_e + 1$。\n- 一个布尔值，指示对于一致质量和集中质量设计，在强制执行后，最近邻约束 $|k_e - k_{e+1}| \\le 1$ 是否在所有地方都成立。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个子列表，顺序为 $[\\Delta t_{\\mathrm{global,cons}}, \\Delta t_{\\mathrm{global,lump}}, S_{\\mathrm{cons}}, S_{\\mathrm{lump}}, G_{\\mathrm{cons}}, G_{\\mathrm{lump}}, \\text{adj\\_cons}, \\text{adj\\_lump}]$。例如，总体输出格式为 $[[\\dots],[\\dots],[\\dots]]$，其中数值以秒为单位，布尔值以纯文本 true 或 false 表示。",
            "solution": "该问题要求为一维标量波动方程 $u_{tt} = c^2 u_{xx}$ 的有限元法 (FEM) 离散化设计和分析显式时间步进方案。分析比较了标准全局时间步进方法与局部时间步进 (LTS) 方法，并涵盖了一致质量矩阵和集中质量矩阵两种公式。关键性能指标包括最大稳定时间步长、LTS 带来的计算加速比以及最终LTS方案的复杂性。\n\n该方法的基础是常微分方程的半离散系统 $M \\ddot{\\mathbf{u}} + K \\mathbf{u} = \\mathbf{0}$，这是将有限元法应用于波动方程的弱形式所产生的结果。在这里，$\\mathbf{u}(t)$ 是网格节点处电场值的向量，$M$ 是质量矩阵，$K$ 是刚度矩阵。一个显式时间积分方案（如中心差分法）的稳定性受 Courant-Friedrichs-Lewy (CFL) 条件的制约。对于该系统，条件为 $\\Delta t \\le 2/\\omega_{\\max}$，其中 $\\omega_{\\max}$ 是离散系统的最高自然频率，通过求解广义特征值问题 $K \\mathbf{v} = \\omega^2 M \\mathbf{v}$ 得到。\n\n具体任务包括为给定的1D网格组装 $M$ 和 $K$，计算最大稳定全局时间步长，然后设计和评估LTS方案。\n\n**1. 矩阵组装与边界条件**\n\n区域被离散化为 $N$ 个线段单元，单元 $e$ 的长度为 $h_e$。该网格有 $N+1$ 个节点。我们首先通过累加每个单元的贡献来组装大小为 $(N+1) \\times (N+1)$ 的全局矩阵。对于连接节点 $i$ 和 $i+1$ 的单元 $e$，其单元刚度矩阵 $K_e$ 和一致质量矩阵 $M_e$ 如下所示：\n$$K_e = \\frac{c^2}{h_e}\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}, \\quad M_e = \\frac{h_e}{6}\\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix}$$\n这些矩阵被组装成全局矩阵 $K$ 和 $M$。问题指定了区间两端（节点0和N）的狄利克雷边界条件，即 $u_0(t) = 0$ 和 $u_N(t) = 0$。这些自由度是固定的，并从动态系统中移除。这是通过提取 $K$ 和 $M$ 中对应于内部节点（$1, 2, \\dots, N-1$）的子矩阵来完成的。最终得到的动态系统涉及大小为 $(N-1) \\times (N-1)$ 的矩阵。\n\n集中质量矩阵 $M_{\\mathrm{lump}}$ 是一个对角矩阵，它通过使逆矩阵 $M^{-1}$ 的计算变得微不足道来简化时间步进更新。它是通过对全局一致质量矩阵 $M$（施加边界条件前）的每一行条目求和，并将总和放在相应的对角线元素上构建的：\n$$ (M_{\\mathrm{lump}})_{ii} = \\sum_{j=0}^{N} M_{ij} $$\n然后，通过选择内部节点的子矩阵，将相同的狄利克雷边界条件应用于 $M_{\\mathrm{lump}}$。\n\n**2. 稳定性分析与全局时间步长计算**\n\n显式中心差分方案的稳定性受到离散系统所支持的最大频率 $\\omega_{\\max}$ 的限制。我们通过求解广义特征值问题 $K \\mathbf{v} = \\lambda M \\mathbf{v}$（其中 $\\lambda = \\omega^2$）来为一致质量 ($M_{\\mathrm{cons}}$) 和集中质量 ($M_{\\mathrm{lump}}$) 两种公式计算此值。设 $\\lambda_{\\max}$ 为最大特征值。那么 $\\omega_{\\max} = \\sqrt{\\lambda_{\\max}}$。最大稳定全局时间步长则为：\n$$ \\Delta t_{\\mathrm{global}} = \\frac{2}{\\omega_{\\max}} $$\n我们使用 $M=M_{\\mathrm{cons}}$ 计算 $\\Delta t_{\\mathrm{global,cons}}$，使用 $M=M_{\\mathrm{lump}}$ 计算 $\\Delta t_{\\mathrm{global,lump}}$。这些计算需要一个数值广义特征值求解器。\n\n**3. 局部时间步进 (LTS) 算法**\n\nLTS旨在提高在非结构化网格上的效率，在这些网格中，少数小单元决定了一个非常小的全局时间步长。取而代之的是，每个单元都以适合其自身大小的时间步长进行推进。算法如下：\n\n设 $\\Delta t_{\\min}$ 为给定质量矩阵公式的全局稳定时间步长（例如，$\\Delta t_{\\min} = \\Delta t_{\\mathrm{global,cons}}$）。设 $h_{\\min} = \\min_e h_e$。\n\na. **分配目标时间步长**：为每个单元 $e$ 设置一个与其大小成比例的目标时间步长：\n$$ \\Delta t_e^{\\mathrm{target}} = \\Delta t_{\\min} \\frac{h_e}{h_{\\min}} $$\n\nb. **量化时间步长**：为简化算法，将目标时间步长量化为 $\\Delta t_{\\min}$ 的2的幂次方倍数。我们找到最大的整数 $k_e \\ge 0$，使得实际单元时间步长 $\\Delta t_e = \\Delta t_{\\min} 2^{k_e}$ 不超过目标值。这给出：\n$$ 2^{k_e} \\le \\frac{h_e}{h_{\\min}} \\implies k_e = \\left\\lfloor \\log_2\\left(\\frac{h_e}{h_{\\min}}\\right) \\right\\rfloor $$\n\nc. **强制执行邻接约束**：为确保相邻单元之间简单而稳定的耦合，相邻单元的时间步长差异不能超过2倍。这转化为对所有相邻单元对 $(e, e+1)$ 的约束 $|k_e - k_{e+1}| \\le 1$。该约束被迭代地强制执行。在每次迭代中，我们扫描所有相邻对。如果违反了约束，则将两个 $k$ 值中较大的一个减小以满足约束，即 $k_{\\text{larger}} = k_{\\text{smaller}} + 1$。重复此过程直到没有更多变化发生。由于 $k_e$ 值是非负的并且只减不增，这个迭代过程保证收敛。\n\n**4. 效率评估**\n\n计算效率是通过比较总时间 $T$ 内全局时间步长模拟与LTS模拟的成本来衡量的。成本被假定为与单元更新的总次数成正比。\n\n- **全局成本**：所有 $N$ 个单元都在每个时间步长 $\\Delta t_{\\min}$ 进行更新。\n$$ C_{\\mathrm{global}} = N \\frac{T}{\\Delta t_{\\min}} $$\n- **LTS成本**：每个单元 $e$ 都用其自己的时间步长 $\\Delta t_e$ 进行更新。\n$$ C_{\\mathrm{LTS}} = \\sum_{e=1}^{N} \\frac{T}{\\Delta t_e} $$\n- **加速比**：加速比 $S$ 是这些成本的比率。\n$$ S = \\frac{C_{\\mathrm{global}}}{C_{\\mathrm{LTS}}} = \\frac{N \\frac{T}{\\Delta t_{\\min}}}{\\sum_{e=1}^N \\frac{T}{\\Delta t_e}} = \\frac{N}{\\sum_{e=1}^N \\frac{\\Delta t_{\\min}}{\\Delta t_e}} = \\frac{N}{\\sum_{e=1}^N 2^{-k_e}} $$\n不同的时间步长大小（或组）的数量为 $G = \\max_e k_e + 1$。该算法针对一致质量矩阵和集中质量矩阵分别实现，以计算 $S_{\\mathrm{cons}}, S_{\\mathrm{lump}}, G_{\\mathrm{cons}}$ 和 $G_{\\mathrm{lump}}$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {'h': [0.01] * 10, 'c': 3e8},\n        {'h': [0.01, 0.01, 0.0001, 0.01, 0.01], 'c': 3e8},\n        {'h': [0.0005, 0.001, 0.002, 0.004, 0.008], 'c': 3e8}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        h_elements = case['h']\n        c = case['c']\n        result = process_case(h_elements, c)\n        all_results.append(result)\n\n    # Format the final output string\n    case_strings = []\n    for res in all_results:\n        # Format: [dt_c, dt_l, S_c, S_l, G_c, G_l, adj_c, adj_l]\n        # Booleans must be lowercase 'true' or 'false'\n        s_res = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]},{str(res[6]).lower()},{str(res[7]).lower()}]\"\n        case_strings.append(s_res)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef process_case(h_elements, c):\n    \"\"\"\n    Processes a single test case: assembles matrices, solves eigenvalue problems,\n    and computes LTS metrics.\n    \"\"\"\n    N = len(h_elements)\n    num_nodes = N + 1\n\n    # 1. Assemble global matrices K and M_consistent\n    K_global = np.zeros((num_nodes, num_nodes))\n    M_consistent_global = np.zeros((num_nodes, num_nodes))\n\n    for i, h_e in enumerate(h_elements):\n        # Element matrices\n        K_e = (c**2 / h_e) * np.array([[1, -1], [-1, 1]])\n        M_e = (h_e / 6.0) * np.array([[2, 1], [1, 2]])\n        \n        # Assembly into global matrices\n        K_global[i:i+2, i:i+2] += K_e\n        M_consistent_global[i:i+2, i:i+2] += M_e\n\n    # 2. Construct mass-lumped matrix\n    M_lumped_global = np.diag(np.sum(M_consistent_global, axis=1))\n\n    # 3. Apply Dirichlet BCs by taking interior node submatrices\n    # Interior nodes are 1, ..., N-1 (0-indexed from 1 to N-1)\n    if N > 1:\n        K_int = K_global[1:N, 1:N]\n        Mc_int = M_consistent_global[1:N, 1:N]\n        Ml_int = M_lumped_global[1:N, 1:N]\n    else: # No interior nodes\n        K_int, Mc_int, Ml_int = np.array([]), np.array([]), np.array([])\n    \n    # 4. Solve eigenvalue problems and compute global time steps\n    if K_int.shape[0] > 0:\n        # Consistent mass\n        eigvals_c = eig(K_int, Mc_int, right=False)\n        omega_max_c = np.sqrt(np.max(np.real(eigvals_c)))\n        dt_global_c = 2.0 / omega_max_c\n\n        # Lumped mass\n        eigvals_l = eig(K_int, Ml_int, right=False)\n        omega_max_l = np.sqrt(np.max(np.real(eigvals_l)))\n        dt_global_l = 2.0 / omega_max_l\n    else:\n        dt_global_c = float('inf')\n        dt_global_l = float('inf')\n\n    # 5. Calculate LTS metrics\n    S_c, G_c, adj_c = calculate_lts_metrics(h_elements, dt_global_c)\n    S_l, G_l, adj_l = calculate_lts_metrics(h_elements, dt_global_l)\n\n    return [dt_global_c, dt_global_l, S_c, S_l, G_c, G_l, adj_c, adj_l]\n\ndef calculate_lts_metrics(h_elements, dt_min):\n    \"\"\"\n    Calculates the LTS speed-up (S), number of groups (G), and verifies\n    the adjacency constraint.\n    \"\"\"\n    N = len(h_elements)\n    if N == 0 or dt_min == float('inf'):\n        return 1.0, 0, True\n\n    h_arr = np.array(h_elements, dtype=float)\n    h_min = np.min(h_arr)\n\n    # Calculate initial k_e values\n    k = np.floor(np.log2(h_arr / h_min)).astype(int)\n    \n    # Iteratively enforce adjacency constraint |k_e - k_{e+1}| = 1\n    if N > 1:\n        while True:\n            changed = False\n            for e in range(N - 1):\n                if abs(k[e] - k[e + 1]) > 1:\n                    changed = True\n                    if k[e] > k[e + 1]:\n                        k[e] = k[e + 1] + 1\n                    else:\n                        k[e + 1] = k[e] + 1\n            if not changed:\n                break\n    \n    # Calculate speed-up S\n    speedup = N / np.sum(2.0**(-k))\n    \n    # Calculate number of groups G\n    num_groups = np.max(k) + 1 if k.size > 0 else 0\n    \n    # Verify final adjacency constraint\n    adj_ok = True\n    if N > 1:\n        for e in range(N - 1):\n            if abs(k[e] - k[e + 1]) > 1:\n                adj_ok = False\n                break\n                \n    return speedup, int(num_groups), adj_ok\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}