{
    "hands_on_practices": [
        {
            "introduction": "分析任何周期性结构的第一步是在真实空间和倒易空间中正确地定义其几何结构。本练习将为您提供为任意布拉维晶格计算倒易晶格矢量的基础实践，这对于建立模拟和解读衍射图样至关重要。您还将验证 Floquet 周期性边界条件本身的数值实现，以确保您的计算框架是稳健的。",
            "id": "3308741",
            "problem": "给定三维正格矢基矢和一个布洛赫波矢。你的任务是为由给定基矢定义的任意布拉菲晶胞构建倒格矢，并在单胞的离散网格采样上以机器精度验证弗洛凯周期性边界条件。程序必须对每个测试用例执行以下步骤，并返回量化的误差度量。\n\n从以下基本依据开始：\n- 在具有空间周期性材料参数的介质中，时谐麦克斯韦方程组意味着电磁场的解可以表示为布洛赫波。对于一个布洛赫波矢为 $\\mathbf{k}$ 的布洛赫波，弗洛凯周期性边界条件规定，对于每个正格矢原胞平移 $\\mathbf{a}_i$，场都遵循 $E(\\mathbf{r} + \\mathbf{a}_i) = E(\\mathbf{r}) \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i)$。\n- 倒格矢基矢 $\\mathbf{b}_i$ 由 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}$ 定义，其中 $\\delta_{ij}$ 是克罗内克δ函数。对于给定的一组张成 $\\mathbb{R}^3$ 空间的正格矢基矢，此定义唯一地确定了倒格子。\n\n您的程序必须为下面指定的每个测试用例执行以下操作：\n1. 给定正格矢基矢 $\\mathbf{a}_1$、$\\mathbf{a}_2$、$\\mathbf{a}_3$（单位为米），构建倒格矢基矢 $\\mathbf{b}_1$、$\\mathbf{b}_2$、$\\mathbf{b}_3$，使得 $\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}$ 成立。然后计算 $3\\times 3$ 矩阵 $\\mathbf{A}^\\top \\mathbf{B}$ 与 $2\\pi\\,\\mathbf{I}_3$ 之间的最大绝对偏差，其中 $\\mathbf{A} = [\\mathbf{a}_1\\,\\mathbf{a}_2\\,\\mathbf{a}_3]$，$\\mathbf{B} = [\\mathbf{b}_1\\,\\mathbf{b}_2\\,\\mathbf{b}_3]$，$\\mathbf{I}_3$ 是 $3\\times 3$ 单位矩阵。将此最大绝对偏差报告为无量纲浮点数。\n2. 在分数坐标中，沿 $\\mathbf{a}_1$、$\\mathbf{a}_2$、$\\mathbf{a}_3$ 方向分别使用 $N_x$、$N_y$、$N_z$ 个点，在均匀的直线网格上对单胞进行采样。网格点位于分数坐标 $(u_1,u_2,u_3)$ 处，其中 $u_1 \\in \\{0, 1/N_x, \\dots, (N_x - 1)/N_x\\}$，$u_2 \\in \\{0, 1/N_y, \\dots, (N_y - 1)/N_y\\}$，$u_3 \\in \\{0, 1/N_z, \\dots, (N_z - 1)/N_z\\}$，实空间位置为 $\\mathbf{r} = u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3$。定义标量平面波场 $E(\\mathbf{r}) = \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{r})$。\n3. 对于每个 $i \\in \\{1,2,3\\}$，计算由弗洛凯条件所蕴含的恒等式在所有网格点上的最大绝对不匹配度，\n$$\n\\exp(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)) \\stackrel{?}{=} \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{r})\\,\\exp(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i).\n$$\n换句话说，计算\n$$\n\\varepsilon_i = \\max_{\\mathbf{r}\\,\\text{on the mesh}} \\left| \\exp(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)) - \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{r})\\,\\exp(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i) \\right|,\n$$\n并将每个 $\\varepsilon_i$ 报告为无量纲浮点数。角度必须以弧度处理，布洛赫波矢 $\\mathbf{k}$ 的单位是米⁻¹。点积 $\\mathbf{k}\\cdot \\mathbf{a}_i$ 是无量纲的弧度值。\n\n物理单位：正格矢基矢 $\\mathbf{a}_i$ 必须解释为米，布洛赫波矢分量解释为米⁻¹。角度单位为弧度。所有报告的误差均为无量纲浮点数。\n\n测试套件：\n- 测试用例 1（正交晶胞，理想路径）：\n  - $\\mathbf{a}_1 = [\\,0.4,\\,0,\\,0\\,]$ m, $\\mathbf{a}_2 = [\\,0,\\,0.6,\\,0\\,]$ m, $\\mathbf{a}_3 = [\\,0,\\,0,\\,0.5\\,]$ m。\n  - $\\mathbf{k} = [\\,5.0,\\,8.0,\\,3.0\\,]$ m⁻¹。\n  - $N_x = 11$, $N_y = 13$, $N_z = 9$。\n- 测试用例 2（六方晶胞，偏斜和各向异性）：\n  - $a = 0.35$ m, $c = 0.9$ m。\n  - $\\mathbf{a}_1 = [\\,a,\\,0,\\,0\\,]$, $\\mathbf{a}_2 = [\\,a/2,\\,a\\sqrt{3}/2,\\,0\\,]$, $\\mathbf{a}_3 = [\\,0,\\,0,\\,c\\,]$。\n  - $\\mathbf{k} = [\\,4.0,\\,-1.5,\\,2.0\\,]$ m⁻¹。\n  - $N_x = 17$, $N_y = 19$, $N_z = 7$。\n- 测试用例 3（三斜晶胞，强偏斜）：\n  - $\\mathbf{a}_1 = [\\,0.3,\\,0.02,\\,0.01\\,]$ m, $\\mathbf{a}_2 = [\\,0.06,\\,0.25,\\,0.04\\,]$ m, $\\mathbf{a}_3 = [\\,0.03,\\,0.05,\\,0.4\\,]$ m。\n  - $\\mathbf{k} = [\\,1.0,\\,2.0,\\,-3.0\\,]$ m⁻¹。\n  - $N_x = 23$, $N_y = 17$, $N_z = 13$。\n\n最终输出格式：\n- 对每个测试用例，生成一个列表 $[\\,\\varepsilon_1,\\,\\varepsilon_2,\\,\\varepsilon_3,\\,\\varepsilon_{\\mathrm{RL}}\\,]$，其中 $\\varepsilon_{\\mathrm{RL}}$ 是 $\\mathbf{A}^\\top \\mathbf{B}$ 与 $2\\pi\\,\\mathbf{I}_3$ 的最大绝对偏差。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为由方括号括起来的逗号分隔列表，不含空格，例如，[[x11,x12,x13,x14],[x21,x22,x23,x24],[x31,x32,x33,x34]]，其中每个 xij 是按前述方式计算的浮点数。",
            "solution": "问题陈述已经过验证，并被认定为有效。它在科学上基于固态物理学和计算电磁学的原理，特别是关于周期性系统的弗洛凯定理。该问题是适定的，为得到唯一且有意义的解提供了所有必要的数据和定义。其语言是客观的，要求可以形式化为一种计算算法。因此，下面将给出一个合理的解决方案。\n\n解决方案分为三个主要的逻辑步骤：\n1.  构建倒格子并验证其定义关系。\n2.  生成单胞网格并高效计算相位项。\n3.  计算网格上弗洛凯周期性条件的数值误差。\n\n### 第1部分：倒格子构建与验证\n\n正格矢由一组三个线性无关的基矢 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ 定义，单位为米。这些矢量构成一个 $3 \\times 3$ 矩阵 $\\mathbf{A}$ 的列：\n$$\n\\mathbf{A} = \\begin{bmatrix} \\mathbf{a}_1  \\mathbf{a}_2  \\mathbf{a}_3 \\end{bmatrix}\n$$\n倒格矢由一组相应的基矢 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$ 定义，它们满足双正交条件：\n$$\n\\mathbf{a}_i \\cdot \\mathbf{b}_j = 2\\pi\\,\\delta_{ij}\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数，当 $i=j$ 时为 $1$，否则为 $0$。我们可以将倒格矢组装成另一个 $3 \\times 3$ 矩阵 $\\mathbf{B}$ 的列：\n$$\n\\mathbf{B} = \\begin{bmatrix} \\mathbf{b}_1  \\mathbf{b}_2  \\mathbf{b}_3 \\end{bmatrix}\n$$\n双正交条件可以用矩阵形式表示。点积 $\\mathbf{a}_i \\cdot \\mathbf{b}_j$ 是矩阵乘积 $\\mathbf{A}^\\top \\mathbf{B}$ 的第 $(i, j)$ 个元素。因此，该条件变为：\n$$\n\\mathbf{A}^\\top \\mathbf{B} = 2\\pi\\,\\mathbf{I}_3\n$$\n其中 $\\mathbf{I}_3$ 是 $3 \\times 3$ 单位矩阵。\n\n为了求出倒格矢矩阵 $\\mathbf{B}$，我们可以通过左乘 $\\mathbf{A}^\\top$ 的逆矩阵来求解：\n$$\n\\mathbf{B} = (\\mathbf{A}^\\top)^{-1} (2\\pi\\,\\mathbf{I}_3) = 2\\pi\\,(\\mathbf{A}^\\top)^{-1}\n$$\n利用转置的逆等于逆的转置这一性质，即对于任何可逆矩阵 $\\mathbf{M}$，都有 $(\\mathbf{M}^\\top)^{-1} = (\\mathbf{M}^{-1})^\\top$，我们得到 $\\mathbf{B}$ 的计算公式：\n$$\n\\mathbf{B} = 2\\pi\\,(\\mathbf{A}^{-1})^\\top\n$$\n这部分的算法如下：\n1.  从给定的矢量 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ 构建矩阵 $\\mathbf{A}$。\n2.  计算逆矩阵 $\\mathbf{A}^{-1}$。\n3.  计算逆矩阵的转置 $(\\mathbf{A}^{-1})^\\top$。\n4.  乘以标量 $2\\pi$ 得到矩阵 $\\mathbf{B}$。$\\mathbf{B}$ 的列就是所求的倒格矢 $\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3$。\n\n第一个要求的输出 $\\varepsilon_{\\mathrm{RL}}$ 是数值计算出的矩阵乘积 $\\mathbf{A}^\\top \\mathbf{B}$ 与理论理想值 $2\\pi\\,\\mathbf{I}_3$ 之间的最大绝对偏差。这量化了在矩阵求逆和乘法运算中由浮点运算产生的误差。\n$$\n\\varepsilon_{\\mathrm{RL}} = \\max_{i,j} \\left| (\\mathbf{A}^\\top \\mathbf{B})_{ij} - (2\\pi\\,\\mathbf{I}_3)_{ij} \\right|\n$$\n\n### 第2部分：单胞网格与相位计算\n\n该问题要求在由基矢 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ 定义的单胞内对一个标量场进行采样。单胞内的任何位置矢量 $\\mathbf{r}$ 都可以用分数坐标 $(u_1, u_2, u_3)$ 写成这些基矢的线性组合：\n$$\n\\mathbf{r} = u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3\n$$\n其中 $u_i \\in [0, 1)$。该问题在这些分数坐标上指定了一个离散网格：\n$$\nu_1 \\in \\{0, 1/N_x, \\dots, (N_x - 1)/N_x\\} \\\\\nu_2 \\in \\{0, 1/N_y, \\dots, (N_y - 1)/N_y\\} \\\\\nu_3 \\in \\{0, 1/N_z, \\dots, (N_z - 1)/N_z\\}\n$$\n场是一个平面波 $E(\\mathbf{r}) = \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r})$，其中 $\\mathbf{k}$ 是给定的布洛赫波矢。对所有网格点都需要相位项 $\\mathbf{k} \\cdot \\mathbf{r}$。对 $N_x N_y N_z$ 个点中的每一个进行直接计算将是低效的。我们可以利用点积的线性性质：\n$$\n\\mathbf{k} \\cdot \\mathbf{r} = \\mathbf{k} \\cdot (u_1 \\mathbf{a}_1 + u_2 \\mathbf{a}_2 + u_3 \\mathbf{a}_3) = u_1 (\\mathbf{k} \\cdot \\mathbf{a}_1) + u_2 (\\mathbf{k} \\cdot \\mathbf{a}_2) + u_3 (\\mathbf{k} \\cdot \\mathbf{a}_3)\n$$\n让我们预先计算恒定的相位因子 $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$，其中 $i \\in \\{1, 2, 3\\}$。这些是无量纲量（单位为弧度）。然后，对于网格上的任何点 $(u_1, u_2, u_3)$，相位就是：\n$$\n\\mathbf{k} \\cdot \\mathbf{r} = u_1 c_1 + u_2 c_2 + u_3 c_3\n$$\n这种表述对于矢量化计算非常高效，因为它允许通过一维坐标数组和常数 $c_1, c_2, c_3$ 的外积来构建网格上完整的3D相位值数组。\n\n### 第3部分：弗洛凯条件误差\n\n对于布洛赫波 $E(\\mathbf{r})$，弗洛凯周期性边界条件是 $E(\\mathbf{r} + \\mathbf{a}_i) = E(\\mathbf{r}) \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{a}_i)$。对于特定的平面波场 $E(\\mathbf{r}) = \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r})$，此条件变成一个涉及复指数的恒等式：\n$$\n\\exp(i\\,\\mathbf{k} \\cdot (\\mathbf{r} + \\mathbf{a}_i)) \\stackrel{?}{=} \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{r}) \\exp(i\\,\\mathbf{k} \\cdot \\mathbf{a}_i)\n$$\n左侧（LHS）是 $\\exp(i(\\mathbf{k} \\cdot \\mathbf{r} + \\mathbf{k} \\cdot \\mathbf{a}_i))$。由于指数函数的基本性质 $\\exp(z_1+z_2) = \\exp(z_1)\\exp(z_2)$，LHS和右侧（RHS）在数学上是恒等的。任务是计算在离散网格的每个点 $\\mathbf{r}$ 上，对该恒等式进行浮点计算所产生的数值差异。\n\n对于每个晶格方向 $i \\in \\{1, 2, 3\\}$，我们必须计算最大绝对误差 $\\varepsilon_i$：\n$$\n\\varepsilon_i = \\max_{\\mathbf{r}\\,\\text{on the mesh}} \\left| \\exp(i\\,\\mathbf{k}\\cdot(\\mathbf{r} + \\mathbf{a}_i)) - \\exp(i\\,\\mathbf{k}\\cdot \\mathbf{r})\\exp(i\\,\\mathbf{k}\\cdot \\mathbf{a}_i) \\right|\n$$\n使用第2部分中的高效表示，其中 $\\phi(\\mathbf{r}) = \\mathbf{k} \\cdot \\mathbf{r}$ 且 $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$：\n$$\n\\varepsilon_i = \\max_{\\phi} \\left| \\exp(i(\\phi + c_i)) - \\exp(i\\phi)\\exp(ic_i) \\right|\n$$\n其中最大值取自于对应网格点 $\\mathbf{r}$ 的所有相位值 $\\phi$。对每个 $i \\in \\{1, 2, 3\\}$ 执行此计算，以获得误差 $\\varepsilon_1, \\varepsilon_2, \\varepsilon_3$。\n\n总之，对于每个测试用例，算法按以下步骤进行：\n1.  从基矢 $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$ 构成矩阵 $\\mathbf{A}$。\n2.  计算矩阵 $\\mathbf{B} = 2\\pi\\,(\\mathbf{A}^{-1})^\\top$。\n3.  计算 $\\varepsilon_{\\mathrm{RL}} = \\max|\\mathbf{A}^\\top \\mathbf{B} - 2\\pi\\,\\mathbf{I}_3|$。\n4.  计算相位常数 $c_i = \\mathbf{k} \\cdot \\mathbf{a}_i$，其中 $i=1, 2, 3$。\n5.  生成分数坐标 $u_1, u_2, u_3$ 的一维数组。\n6.  在网格上构建相位值 $\\phi = \\mathbf{k} \\cdot \\mathbf{r}$ 的三维数组。\n7.  对每个 $i \\in \\{1, 2, 3\\}$，计算局部误差 $|\\exp(i(\\phi + c_i)) - \\exp(i\\phi)\\exp(ic_i)|$ 的三维数组，并找到其最大值 $\\varepsilon_i$。\n8.  收集并报告计算出的四个误差 $[\\varepsilon_1, \\varepsilon_2, \\varepsilon_3, \\varepsilon_{\\mathrm{RL}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases, calculating reciprocal\n    lattice vectors and verifying Floquet periodic boundary constraints.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: orthorhombic cell\n        {\n            \"a_vectors\": np.array([\n                [0.4, 0.0, 0.0],\n                [0.0, 0.6, 0.0],\n                [0.0, 0.0, 0.5]\n            ]),\n            \"k_vector\": np.array([5.0, 8.0, 3.0]),\n            \"N_points\": (11, 13, 9)\n        },\n        # Test Case 2: hexagonal cell\n        {\n            \"params\": {\"a\": 0.35, \"c\": 0.9},\n            \"k_vector\": np.array([4.0, -1.5, 2.0]),\n            \"N_points\": (17, 19, 7)\n        },\n        # Test Case 3: triclinic cell\n        {\n            \"a_vectors\": np.array([\n                [0.3, 0.02, 0.01],\n                [0.06, 0.25, 0.04],\n                [0.03, 0.05, 0.4]\n            ]),\n            \"k_vector\": np.array([1.0, 2.0, -3.0]),\n            \"N_points\": (23, 17, 13)\n        }\n    ]\n    \n    # Process hexagonal cell parameters\n    a_hex = test_cases[1][\"params\"][\"a\"]\n    c_hex = test_cases[1][\"params\"][\"c\"]\n    test_cases[1][\"a_vectors\"] = np.array([\n        [a_hex, 0.0, 0.0],\n        [a_hex / 2.0, a_hex * np.sqrt(3.0) / 2.0, 0.0],\n        [0.0, 0.0, c_hex]\n    ])\n\n    results = []\n    for case in test_cases:\n        a_vectors = case[\"a_vectors\"]\n        k = case[\"k_vector\"]\n        Nx, Ny, Nz = case[\"N_points\"]\n        \n        a1, a2, a3 = a_vectors[0, :], a_vectors[1, :], a_vectors[2, :]\n        \n        # The problem statement implies a_i are columns of A, but standard\n        # crystallography often has them as rows. Here we follow the problem's\n        # matrix relation A^T B = 2pi I, which implies a_i form rows of A^T,\n        # so they must form columns of A.\n        # A = [a1, a2, a3] as columns\n        A = np.array([a1, a2, a3]).T\n        \n        # 1. Construct reciprocal lattice vectors and compute deviation epsilon_RL\n        # From A^T B = 2pi I, we get B = 2pi * (A^T)^-1 = 2pi * (A^-1)^T\n        try:\n            A_inv = np.linalg.inv(A)\n            B = 2.0 * np.pi * A_inv.T\n        except np.linalg.LinAlgError:\n            results.append([\"Error: singular matrix A\"])\n            continue\n\n        # Verify the relation and compute the error\n        identity_check_matrix = A.T @ B\n        error_matrix = identity_check_matrix - 2.0 * np.pi * np.eye(3)\n        epsilon_rl = np.max(np.abs(error_matrix))\n\n        # 2. Sample unit cell and define field\n        # Phase constants c_i = k . a_i\n        c1 = np.dot(k, a1)\n        c2 = np.dot(k, a2)\n        c3 = np.dot(k, a3)\n\n        # Fractional coordinates\n        u1_vals = np.linspace(0.0, (Nx-1)/Nx, Nx)\n        u2_vals = np.linspace(0.0, (Ny-1)/Ny, Ny)\n        u3_vals = np.linspace(0.0, (Nz-1)/Nz, Nz)\n\n        # Meshgrid for vectorized computation of phases\n        # Use 'ij' indexing to match loop order (i for u1, j for u2, k for u3)\n        U1, U2, U3 = np.meshgrid(u1_vals, u2_vals, u3_vals, indexing='ij')\n\n        # Phase on the mesh: k.r = u1*c1 + u2*c2 + u3*c3\n        phi_mesh = c1 * U1 + c2 * U2 + c3 * U3\n        \n        # 3. Compute Floquet condition mismatch errors epsilon_i\n        epsilons = []\n        phase_constants = [c1, c2, c3]\n        for i in range(3):\n            ci = phase_constants[i]\n            \n            # LHS: exp(i*k.(r+a_i)) = exp(i*(phi + c_i))\n            lhs = np.exp(1j * (phi_mesh + ci))\n            \n            # RHS: exp(i*k.r) * exp(i*k.a_i) = exp(i*phi) * exp(i*c_i)\n            rhs = np.exp(1j * phi_mesh) * np.exp(1j * ci)\n            \n            # Mismatch error\n            mismatch = np.max(np.abs(lhs - rhs))\n            epsilons.append(mismatch)\n\n        case_result = epsilons + [epsilon_rl]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    case_results_str = []\n    for res in results:\n        case_results_str.append(f\"[{','.join(f'{x:.17g}' for x in res)}]\")\n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对缺陷等局域特征进行建模的一种常用技术是将其置于一个大的“超胞”中，并施加周期性边界条件，但这种方法会引入人为的周期性。本实践通过量化由此产生的伪布拉格散射来探究这种近似的后果，让您深入了解计算成本（超胞大小）与模拟精度之间的权衡。通过分析这种超胞混叠误差，您将更深刻地理解如何使用周期性方法来建立和解读非周期性系统的模拟。",
            "id": "3308775",
            "problem": "考虑在一均匀背景中存在一个弱局域缺陷的情况下，由标量亥姆霍兹方程所描述的一维时谐电磁波。电场 $E(x)$ 在无量纲单位下的控制方程为\n$$\n\\frac{d^2 E}{dx^2} + \\omega^2 \\,\\epsilon(x)\\, E = 0,\n$$\n其中背景介电常数 $\\epsilon_b = 1$，波速归一化为 $c = 1$，对于平面波 $\\exp(ikx)$，未受扰动的色散关系为 $\\omega = |k|$。该缺陷被建模为介电常数的一个弱微扰，\n$$\n\\epsilon(x) = 1 + \\eta\\, u(x),\n$$\n其中 $0  \\eta \\ll 1$，且 $u(x)$ 是一个有界、局域的形状函数。在采用弗洛凯定理和周期性边界条件（PBC）的数值超胞方法中，缺陷以超胞长度 $L = N a$ 进行周期性重复，其中 $a$ 是一个基胞长度，$N$ 是超胞中基胞的数量。由此产生的周期性微扰具有一个基本倒格矢 $G = \\frac{2\\pi}{L}$ 和傅里叶系数\n$$\nU_m = \\frac{1}{L}\\int_{0}^{L} u(x)\\, e^{-i m G x}\\, dx,\\quad m \\in \\mathbb{Z}.\n$$\n在近自由波近似中，当 $k \\approx G/2$ 时，在第一布里渊区边界附近会出现伪布拉格耦合，这导致了由缺陷周期性复制的 $m=1$ 次谐波所介导的 $\\exp(ikx)$ 和 $\\exp(i(k - G)x)$ 之间的耦合驱动的频带分裂。对于缺陷模式而言，这种效应构成了超胞混叠误差，因为一个真正孤立的缺陷不应引起这种周期性的布拉格散射。\n\n假设缺陷形状为高斯函数，\n$$\nu(x) = \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right),\n$$\n其中 $\\sigma$ 是缺陷的宽度，所有空间量都以 $a$ 为单位表示，因此不失一般性地可以设 $a = 1$。在适用于 $0  \\eta \\ll 1$ 的弱微扰极限下进行分析。您的任务是从第一性原理出发，推导出在第一布里渊区边界处归一化的伪布拉格诱导频率分裂的领头阶表达式，该分裂定义为带隙大小与 $k = G/2$ 处未受扰动频率之比。然后，实现一个程序，通过利用高斯函数的解析傅里叶变换和 $k = G/2$ 处的近自由波双模耦合，为给定的参数集评估此混叠误差度量。\n\n所有量均为无量纲，最终答案应为无量纲实数。您的程序应计算以下测试集的混叠误差：\n- 情况 1：$a = 1$, $N = 8$, $\\sigma = 0.15$, $\\eta = 0.02$。\n- 情况 2：$a = 1$, $N = 32$, $\\sigma = 0.15$, $\\eta = 0.02$。\n- 情况 3：$a = 1$, $N = 1$, $\\sigma = 0.15$, $\\eta = 0.02$。\n- 情况 4：$a = 1$, $N = 8$, $\\sigma = 0.50$, $\\eta = 0.02$。\n- 情况 5：$a = 1$, $N = 8$, $\\sigma = 0.15$, $\\eta = 0.00$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。每个结果必须四舍五入到 $8$ 位小数。例如，输出格式应为\n[result1,result2,result3,result4,result5].",
            "solution": "该问题陈述在科学上是合理的、自洽且适定的。它描述了计算物理学中的一个典型问题，具体是分析使用超胞方法模拟局域缺陷时的人为周期性效应。所引用的物理原理，如亥姆霍兹方程、弗洛凯定理、布拉格散射和近自由波近似，都是波物理学和固态理论的基石。所提供的参数是一致的，并且足以得到唯一解。因此，该问题被认为是有效的，我将继续进行严格的推导和随后的数值实现。\n\n任务是为一个具有周期性微扰的一维亥姆霍兹方程，推导在第一布里渊区边界处归一化频率分裂的领头阶表达式。控制方程为：\n$$ \\frac{d^2 E}{dx^2} + \\omega^2 \\epsilon(x) E = 0 $$\n在超胞模型中，介电常数 $\\epsilon(x) = 1 + \\eta\\, u_L(x)$ 是周期为 $L=Na$ 的函数，其中 $u_L(x)$ 是单个高斯缺陷 $u(x) = \\exp(-x^2/(2\\sigma^2))$ 的周期性复制。参数 $\\eta$ 是一个小值常数，$0  \\eta \\ll 1$。我们可以将控制方程重写为：\n$$ \\frac{d^2 E}{dx^2} + \\omega^2 E = -\\omega^2 \\eta\\, u_L(x) E $$\n右侧的项作为一个微扰。在没有这个微扰（$\\eta=0$）的情况下，解是平面波 $E(x) = \\exp(ikx)$，其色散关系为 $\\omega = |k|$，因为背景波速为 $c=1$。\n\n我们关心的是第一布里渊区边界附近的行为，此时波数 $k$ 接近 $G/2$，其中 $G = 2\\pi/L$ 是基本倒格矢。在恰好 $k=G/2$ 处，未受扰动的前向传播波 $\\exp(i(G/2)x)$ 和一阶布拉格散射波 $\\exp(i(k-G)x) = \\exp(i(G/2-G)x) = \\exp(-i(G/2)x)$ 是简并的。它们的未扰动频率为 $\\omega_0 = |k| = G/2$。\n\n周期性微扰 $u_L(x)$ 可以展开为傅里叶级数：\n$$ u_L(x) = \\sum_{m=-\\infty}^{\\infty} U_m e^{imGx} $$\n其中傅里叶系数 $U_m$ 由 $U_m = \\frac{1}{L}\\int_0^L u_L(x) e^{-imGx} dx$ 给出。\n微扰耦合了这些简并模式。根据近自由波近似，我们以这两个主导模式的叠加形式寻找解：\n$$ E(x) = c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x} $$\n将这个双模拟设代入控制方程：\n$$ -(G/2)^2 (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) + \\omega^2 (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) = -\\omega^2 \\eta \\left(\\sum_m U_m e^{imGx}\\right) (c_0 e^{i(G/2)x} + c_1 e^{-i(G/2)x}) $$\n令 $\\omega_0 = G/2$。方程变为：\n$$ (\\omega^2 - \\omega_0^2) (c_0 e^{i\\omega_0 x} + c_1 e^{-i\\omega_0 x}) = -\\omega^2 \\eta \\sum_m U_m (c_0 e^{i(m+1)\\omega_0 x} + c_1 e^{i(m-1)\\omega_0 x}) $$\n为了获得系数 $c_0$ 和 $c_1$ 的方程组，我们将方程投影到基函数 $e^{i\\omega_0 x}$ 和 $e^{-i\\omega_0 x}$ 上。这通过乘以 $e^{-i\\omega_0 x}$（对第一个方程）或 $e^{i\\omega_0 x}$（对第二个方程）并在一个周期 $L$ 上积分来完成。复指数函数的正交性 $\\frac{1}{L}\\int_0^L e^{ij\\omega_0 x} e^{-il\\omega_0 x} dx = \\delta_{jl}$ 简化了求和。\n\n对于第一个方程（投影到 $e^{i\\omega_0 x}$）：\n$$ (\\omega^2 - \\omega_0^2) c_0 = -\\omega^2 \\eta (U_0 c_0 + U_1 c_1) $$\n对于第二个方程（投影到 $e^{-i\\omega_0 x}$）：\n$$ (\\omega^2 - \\omega_0^2) c_1 = -\\omega^2 \\eta (U_{-1} c_0 + U_0 c_1) $$\n这可以写成关于 $(c_0, c_1)$ 的 $2 \\times 2$ 齐次线性系统：\n$$ \\begin{pmatrix} \\omega^2(1+\\eta U_0) - \\omega_0^2  \\omega^2 \\eta U_1 \\\\ \\omega^2 \\eta U_{-1}  \\omega^2(1+\\eta U_0) - \\omega_0^2 \\end{pmatrix} \\begin{pmatrix} c_0 \\\\ c_1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} $$\n为了得到非平凡解，矩阵的行列式必须为零。缺陷形状 $u(x)$ 是实且偶的，因此其傅里叶系数是实且偶的，即 $U_m = U_{-m} \\in \\mathbb{R}$。\n$$ (\\omega^2(1+\\eta U_0) - \\omega_0^2)^2 - (\\omega^2 \\eta U_1)^2 = 0 $$\n$$ \\omega^2(1+\\eta U_0) - \\omega_0^2 = \\pm \\omega^2 \\eta U_1 $$\n这产生了 $\\omega^2$ 的两个解：\n$$ \\omega^2(1 + \\eta U_0 \\mp \\eta U_1) = \\omega_0^2 \\implies \\omega^2_\\pm = \\frac{\\omega_0^2}{1 + \\eta(U_0 \\mp U_1)} $$\n因此，上 ($u$)、下 ($l$) 带边的频率为 $\\omega_u = \\omega_+$ 和 $\\omega_l = \\omega_-$。\n$$ \\omega_u = \\frac{\\omega_0}{\\sqrt{1 + \\eta(U_0 - U_1)}} \\quad , \\quad \\omega_l = \\frac{\\omega_0}{\\sqrt{1 + \\eta(U_0 + U_1)}} $$\n频率分裂为 $\\Delta\\omega = \\omega_u - \\omega_l$。归一化分裂为 $\\Delta\\omega / \\omega_0$：\n$$ \\frac{\\Delta\\omega}{\\omega_0} = \\frac{1}{\\sqrt{1 + \\eta(U_0 - U_1)}} - \\frac{1}{\\sqrt{1 + \\eta(U_0 + U_1)}} $$\n因为我们关心的是 $\\eta \\ll 1$ 时的领头阶表达式，我们使用泰勒展开 $(1+x)^{-1/2} \\approx 1-x/2$。\n$$ \\frac{\\Delta\\omega}{\\omega_0} \\approx \\left(1 - \\frac{\\eta}{2}(U_0 - U_1)\\right) - \\left(1 - \\frac{\\eta}{2}(U_0 + U_1)\\right) = -\\frac{\\eta}{2}U_0 + \\frac{\\eta}{2}U_1 + \\frac{\\eta}{2}U_0 + \\frac{\\eta}{2}U_1 = \\eta U_1 $$\n由于对于一般形状 $U_1$ 可能为负，分裂的大小由 $\\eta|U_1|$ 给出。对于指定的高斯函数，$U_1 > 0$。\n\n最后一步是计算傅里叶系数 $U_1$。对于周期性缺陷阵列 $u_L(x) = \\sum_j u(x-jL)$，其系数为：\n$$ U_m = \\frac{1}{L} \\int_{-L/2}^{L/2} \\left( \\sum_{j=-\\infty}^{\\infty} u(x-jL) \\right) e^{-imGx} dx $$\n这可以被证明等价于单个缺陷形状 $u(x)$ 的傅里叶变换在倒格点 $k_m=mG$ 处的值再乘以 $1/L$。当缺陷很好地局域在超胞内部时（$\\sigma \\ll L$），这个近似非常好。\n$$ U_m = \\frac{1}{L} \\int_{-\\infty}^{\\infty} u(x) e^{-imGx} dx = \\frac{1}{L} \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) e^{-imGx} dx $$\n该积分是高斯函数的标准傅里叶变换。$\\exp(-ax^2)$ 的变换是 $\\sqrt{\\pi/a} \\exp(-k^2/(4a))$。这里，$a = 1/(2\\sigma^2)$ 且 $k=mG$。\n$$ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) e^{-imGx} dx = \\sqrt{2\\pi\\sigma^2} \\exp\\left(-\\frac{(mG)^2 \\sigma^2}{2}\\right) $$\n因此，傅里叶系数为：\n$$ U_m = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{m^2 G^2 \\sigma^2}{2}\\right) $$\n代入 $m=1$ 和 $G=2\\pi/L$：\n$$ U_1 = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{(2\\pi/L)^2 \\sigma^2}{2}\\right) = \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{2\\pi^2\\sigma^2}{L^2}\\right) $$\n归一化的混叠误差的最终表达式是：\n$$ \\text{Error} = \\eta U_1 = \\eta \\frac{\\sqrt{2\\pi}\\sigma}{L} \\exp\\left(-\\frac{2\\pi^2\\sigma^2}{L^2}\\right) $$\n这就是需要实现的公式。我们设定基胞长度 $a=1$，所以超胞长度是 $L=N$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the normalized spurious Bragg-induced frequency splitting for a\n    1D Helmholtz equation with a periodic Gaussian permittivity defect.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, N, sigma, eta)\n        (1, 8, 0.15, 0.02),\n        (1, 32, 0.15, 0.02),\n        (1, 1, 0.15, 0.02),\n        (1, 8, 0.50, 0.02),\n        (1, 8, 0.15, 0.00),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, N, sigma, eta = case\n\n        # The normalized splitting is given by eta * U_1, where U_1 is the\n        # first Fourier coefficient of the periodic defect potential.\n        # If eta is 0, the perturbation is zero, so the splitting is zero.\n        if eta == 0:\n            results.append(f\"{0.0:.8f}\")\n            continue\n\n        # Supercell length L = N * a\n        L = N * a\n\n        # The Fourier coefficient U_1 is derived from the analytical\n        # Fourier transform of a single Gaussian function.\n        # U_1 = (sqrt(2*pi)*sigma / L) * exp(-2*pi^2*sigma^2 / L^2)\n        \n        prefactor = (np.sqrt(2 * np.pi) * sigma) / L\n        exponent_arg = -2 * np.pi**2 * sigma**2 / L**2\n        exp_term = np.exp(exponent_arg)\n        \n        U1 = prefactor * exp_term\n\n        # The aliasing error metric is the normalized frequency splitting\n        aliasing_error = eta * U1\n        \n        results.append(f\"{aliasing_error:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然能带结构通常通过求解大规模本征值问题来计算，但它们也可以从驱动系统的频率响应中提取出来，这是一种在模拟和实验中都广泛使用的技术。这项高级实践将指导您通过对合成的频域数据应用谐波反演来恢复能带结构，模拟分析驱动模拟结果的过程。本练习弥合了本征模式和驱动响应这两个概念之间的差距，并介绍了用于数据分析的强大信号处理技术。",
            "id": "3308797",
            "problem": "考虑在一维周期性电磁结构中，在布洛赫周期性边界条件下，单元平均电场的频域响应。该结构的晶胞长度为 $a$。对于给定的布洛赫波矢 $\\mathbf{k}$（在一维中，$\\mathbf{k}=k\\hat{x}$），在具有布洛赫相位的空间周期性源作用下的受迫频域解满足弗洛凯定理（Floquet's theorem）：任何场都可以表示为 $E_{k}(x)=u_{k}(x)\\mathrm{e}^{\\mathrm{i}kx}$，其中 $u_{k}(x)$ 是以晶胞为周期的周期函数。在频域中，单元平均场 $\\overline{E}(\\omega;k)$ 在布洛赫模式的本征频率 $\\omega_{n}(k)$ 处表现出共振，每个共振都因材料损耗或辐射（表示为一个小的阻尼率）而展宽。\n\n从频域中的麦克斯韦方程组出发，该结构由场 $\\mathbf{E}$ 在源 $\\mathbf{J}$ 作用下的线性算子方程 $\\nabla \\times (\\mu^{-1} \\nabla \\times \\mathbf{E}) - \\omega^2 \\varepsilon \\mathbf{E} = \\mathbf{J}$ 和弗洛凯条件 $E(x+a)=E(x)\\mathrm{e}^{\\mathrm{i}ka}$ 建模。根据弗洛凯定理，对于每个 $k$，算子的谱在算子预解式中产生一组离散的复极点 $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$，这意味着标量单元平均频率响应可以表示为关于 $\\omega$ 的有理函数，其极点为单极点，\n$$\n\\overline{E}(\\omega;k)=\\sum_{n}\\frac{C_{n}(k)}{\\omega-\\Omega_{n}(k)}.\n$$\n这里，$C_{n}(k)$ 编码了源与第 $n$ 个布洛赫模式的重叠，而 $\\gamma_{n}>0$ 是阻尼。通过对 $\\overline{E}(\\omega;k)$ 进行傅里叶逆变换得到的时域脉冲响应 $h(t;k)$，在 $t>0$ 时是衰减复指数的有限和，\n$$\nh(t;k)=\\sum_{n}A_{n}(k)\\,\\mathrm{e}^{\\mathrm{i}\\Omega_{n}(k)t},\n$$\n其中 $A_{n}(k)$ 是一个常数，通过复留数计算与 $C_{n}(k)$ 相关。诸如 Prony 方法之类的谐波反演方法可以从均匀采样的时域数据 $h(t_{m};k)$ 中恢复复频率 $\\Omega_{n}(k)$，从而得到能带结构 $\\omega_{n}(k)=\\mathrm{Re}\\,\\Omega_{n}(k)$。\n\n在本问题中，您将从遵循布洛赫周期性强迫的合成频域驱动仿真中恢复近似的能带结构。为便于数值处理和清晰起见，假设一个双能带模型（$n\\in\\{1,2\\}$），其色散关系模拟了一维周期性光子介质中的类紧束缚耦合：\n$$\n\\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^{2}\\left(\\frac{ka}{2}\\right)},\\qquad\n\\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^{2}\\left(\\frac{ka}{2}\\right)}.\n$$\n假设存在小的恒定阻尼率 $\\gamma_{1}>0$ 和 $\\gamma_{2}>0$，复极点位置为 $\\Omega_{1}(k)=\\omega_{1}(k)-\\mathrm{i}\\gamma_{1}$ 和 $\\Omega_{2}(k)=\\omega_{2}(k)-\\mathrm{i}\\gamma_{2}$。设单元平均场的频域驱动响应为\n$$\n\\overline{E}(\\omega;k)=\\frac{C_{1}(k)}{\\omega-\\Omega_{1}(k)}+\\frac{C_{2}(k)}{\\omega-\\Omega_{2}(k)},\n$$\n其中 $C_{1}(k)=1+0.4\\cos(ka)$ 和 $C_{2}(k)=0.7+0.3\\sin(ka)$。\n\n您的任务是：\n- 通过在均匀角频率网格 $\\omega\\in[-W,W]$ 上计算 $\\overline{E}(\\omega;k)$ 来构建合成频域数据，并通过离散傅里叶逆积分数值近似时域脉冲响应 $h(t;k)$\n$$\nh(t;k)\\approx\\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t}.\n$$\n这里 $\\omega_{m}$ 是均匀间隔的样本，$\\Delta\\omega$ 是网格间距，$M$ 是样本数量。使用 $t_{n}=n\\Delta t$（其中 $n=0,1,\\ldots,N-1$）形成均匀的时间样本。\n- 对时间样本 $h(t_{n};k)$ 应用阶数为 $P=2$ 的线性预测 (Prony) 方法进行谐波反演，以估计两个复频率 $\\Omega_{1}(k)$ 和 $\\Omega_{2}(k)$，然后报告 $\\omega_{1}(k)=\\mathrm{Re}\\,\\Omega_{1}(k)$ 和 $\\omega_{2}(k)=\\mathrm{Re}\\,\\Omega_{2}(k)$。\n- 对于每个 $k$，将恢复的两个值按升序排序并四舍五入到六位小数。\n\n使用以下参数值，在适用情况下均以角频率单位表示：\n- 晶胞长度 $a=1$。\n- 能带参数 $\\omega_{01}=10$，$\\omega_{02}=14$，$J_{1}=3$，$J_{2}=1.5$。\n- 阻尼率 $\\gamma_{1}=0.1$，$\\gamma_{2}=0.08$。\n- 频率网格半宽 $W=40$，在 $-W$ 到 $W$ 之间有 $M=4096$ 个均匀间隔的样本。\n- 时间采样步长 $\\Delta t=0.05$，$N=128$ 个样本（即 $t_{n}=n\\Delta t$）。\n- 线性预测阶数 $P=2$。\n\n测试套件：\n- 情况 1：$k=0$。\n- 情况 2：$k=\\pi/a$。\n- 情况 3：$k=(\\pi/2)/a$。\n\n答案规范：\n- 对于每个测试用例，您的程序必须返回一个包含两个恢复的角频率 $\\left[\\omega_{1}(k),\\omega_{2}(k)\\right]$ 的列表，单位为 $\\mathrm{rad/s}$，按升序排序并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，每个测试用例由其自己的方括号列表表示，不含空格，例如 [[ω1(k1),ω2(k1)],[ω1(k2),ω2(k2)],[ω1(k3),ω2(k3)]]。\n\n所有角频率必须以 $\\mathrm{rad/s}$ 为单位报告，并四舍五入到六位小数。诸如 $ka$ 之类的角度必须以弧度计算。请通过使用提供的参数并执行指定的数值近似和谐波反演来确保科学真实性。不允许使用外部数据；程序必须是自包含的，并且必须在执行反演之前计算合成的频域响应。",
            "solution": "### 问题验证\n\n在尝试解决方案之前，该问题经过了严格的验证过程。\n\n#### 步骤 1：提取给定信息\n\n以下数据和定义逐字从问题陈述中提取：\n- **物理模型**：一维周期性电磁结构。\n- **晶胞长度**：$a$。\n- **场表示**：应用弗洛凯定理，$E_{k}(x)=u_{k}(x)\\mathrm{e}^{\\mathrm{i}kx}$，其中 $u_{k}(x)$ 是以 $a$ 为周期的周期函数。\n- **频率响应模型**：单元平均频率响应 $\\overline{E}(\\omega;k)$ 是一个有理函数，其单极点为 $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$：\n$$\n\\overline{E}(\\omega;k)=\\sum_{n}\\frac{C_{n}(k)}{\\omega-\\Omega_{n}(k)}\n$$\n- **时间响应模型**：对于 $t>0$，时域脉冲响应 $h(t;k)$ 为：\n$$\nh(t;k)=\\sum_{n}A_{n}(k)\\,\\mathrm{e}^{\\mathrm{i}\\Omega_{n}(k)t}\n$$\n- **特定的双能带模型 ($n\\in\\{1,2\\}$)**：\n    - 色散关系：\n        $$\n        \\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^2\\left(\\frac{ka}{2}\\right)},\\qquad\n        \\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^2\\left(\\frac{ka}{2}\\right)}\n        $$\n    - 复极点：$\\Omega_{1}(k)=\\omega_{1}(k)-\\mathrm{i}\\gamma_{1}$ 和 $\\Omega_{2}(k)=\\omega_{2}(k)-\\mathrm{i}\\gamma_{2}$。\n    - 频域响应：\n        $$\n        \\overline{E}(\\omega;k)=\\frac{C_{1}(k)}{\\omega-\\Omega_{1}(k)}+\\frac{C_{2}(k)}{\\omega-\\Omega_{2}(k)}\n        $$\n    - 模式-源重叠系数：$C_{1}(k)=1+0.4\\cos(ka)$ 和 $C_{2}(k)=0.7+0.3\\sin(ka)$。\n- **数值脉冲响应计算**：\n    $$\n    h(t;k)\\approx\\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t}\n    $$\n- **数值参数**：\n    - 晶胞长度：$a=1$。\n    - 能带参数：$\\omega_{01}=10$, $\\omega_{02}=14$, $J_{1}=3$, $J_{2}=1.5$。\n    - 阻尼率：$\\gamma_{1}=0.1$, $\\gamma_{2}=0.08$。\n    - 频率网格：半宽 $W=40$，从 $-W$ 到 $W$ 有 $M=4096$ 个样本。\n    - 时间采样：步长 $\\Delta t=0.05$，$N=128$ 个样本。\n    - 线性预测阶数：$P=2$。\n- **测试用例**：\n    - 情况 1：$k=0$。\n    - 情况 2：$k=\\pi/a$。\n    - 情况 3：$k=(\\pi/2)/a$。\n- **输出规范**：对于每个情况，一个包含两个角频率 $[\\omega_{1}(k),\\omega_{2}(k)]$ 的排序列表，四舍五入到六位小数。最终输出是这些列表的列表。\n\n#### 步骤 2：使用提取的给定信息进行验证\n\n- **科学基础**：该问题在计算电磁学和信号处理的原理方面有很好的基础。弗洛凯-布洛赫理论、线性系统的频域分析和谐波反演（Prony 方法）都是标准且有效的概念。物理模型是一个简化但具有代表性的案例研究。\n- **适定性**：该问题是适定的。它提供了一套完整的参数和一条清晰的算法路径以获得唯一解。数值参数（$M$、$N$、$\\Delta t$、$W$）选择得当，以确保数值结果的稳定性和准确性。对于给定的测试用例，共振频率 $\\omega_1(k)$ 和 $\\omega_2(k)$ 的分离足以让谐波反演方法区分它们。\n- **客观性**：问题以精确、客观和数学的语言陈述。没有主观或含糊的术语。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效的**。它在科学上是合理的，自包含的，并且算法上是明确的。可以进行求解过程。\n\n### 基于原理的解决方案\n\n目标是从综合生成的频域数据中恢复能带结构，即共振角频率 $\\omega_1(k)$ 和 $\\omega_2(k)$。对于每个指定的波矢 $k$，求解方法遵循一个四步过程。\n\n#### 步骤 1：合成频域数据\n\n首先，我们根据提供的双能带模型构建合成的频域响应 $\\overline{E}(\\omega;k)$。对于给定的波矢 $k$，我们计算两个共振的参数。\n\n共振频率 $\\omega_{n}(k)$ 由以下公式给出：\n$$\n\\omega_{1}(k)=\\sqrt{\\omega_{01}^{2}+4J_{1}\\sin^2\\left(\\frac{ka}{2}\\right)} \\quad \\text{和} \\quad \\omega_{2}(k)=\\sqrt{\\omega_{02}^{2}+4J_{2}\\sin^2\\left(\\frac{ka}{2}\\right)}\n$$\n频域中包含阻尼的复极点为 $\\Omega_{n}(k)=\\omega_{n}(k)-\\mathrm{i}\\gamma_{n}$：\n$$\n\\Omega_{1}(k) = \\omega_{1}(k)-\\mathrm{i}\\gamma_{1} \\quad \\text{和} \\quad \\Omega_{2}(k) = \\omega_{2}(k)-\\mathrm{i}\\gamma_{2}\n$$\n源耦合系数 $C_{n}(k)$ 为：\n$$\nC_{1}(k)=1+0.4\\cos(ka) \\quad \\text{和} \\quad C_{2}(k)=0.7+0.3\\sin(ka)\n$$\n使用指定的参数（$a=1, \\omega_{01}=10, \\omega_{02}=14, J_{1}=3, J_{2}=1.5, \\gamma_{1}=0.1, \\gamma_{2}=0.08$），我们在一个跨越 $[ -W, W ] = [ -40, 40 ]$ 且有 $M=4096$ 个点的均匀角频率网格 $\\omega_m$ 上计算 $\\overline{E}(\\omega;k)$。频率步长为 $\\Delta\\omega = 2W / (M-1)$。\n\n#### 步骤 2：计算时域脉冲响应\n\n时域脉冲响应 $h(t;k)$ 是 $\\overline{E}(\\omega;k)$ 的傅里叶逆变换。我们使用离散和来数值近似这个积分，针对 $N=128$ 个时间点 $t_n = n\\Delta t$（其中 $\\Delta t=0.05$ 且 $n \\in \\{0, 1, \\dots, N-1\\}$）：\n$$\nh(t_n;k) \\approx \\frac{\\Delta\\omega}{2\\pi}\\sum_{m=0}^{M-1}\\overline{E}(\\omega_{m};k)\\,\\mathrm{e}^{\\mathrm{i}\\omega_{m}t_n}\n$$\n这个计算产生了一组 $N$ 个复数值的时间样本 $h_n \\equiv h(t_n; k)$。该操作实际上是一个指数矩阵与频率数据向量之间的矩阵-向量乘积。\n\n#### 步骤 3：应用谐波反演（线性预测）\n\n时域信号被建模为 $P=2$ 个阻尼复指数的和：\n$$\nh_n = \\sum_{j=1}^{P} A_j z_j^n\n$$\n其中 $z_j = \\mathrm{e}^{\\mathrm{i}\\Omega_j\\Delta t}$ 是 z 域中的“极点”。这样的信号满足一个 $P$ 阶的线性预测递推关系：\n$$\nh_n = -\\sum_{l=1}^{P} c_l h_{n-l} \\quad \\text{对于 } n \\ge P\n$$\n系数 $c_l$ 通过以最小二乘法求解一个超定线性方程组来找到。我们从时间样本 $h_n$ 构建一个矩阵 $\\mathbf{H}$ 和一个向量 $\\mathbf{h}'$：\n$$\n\\mathbf{H} = \\begin{pmatrix}\nh_{P-1}  h_{P-2}  \\dots  h_0 \\\\\nh_{P}  h_{P-1}  \\dots  h_1 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nh_{N-2}  h_{N-3}  \\dots  h_{N-1-P}\n\\end{pmatrix}, \\quad\n\\mathbf{h}' = \\begin{pmatrix}\nh_P \\\\\nh_{P+1} \\\\\n\\vdots \\\\\nh_{N-1}\n\\end{pmatrix}\n$$\n当 $P=2$ 时，这变成：\n$$\n\\begin{pmatrix}\nh_{1}  h_{0} \\\\\nh_{2}  h_{1} \\\\\n\\vdots  \\vdots \\\\\nh_{N-2}  h_{N-3}\n\\end{pmatrix}\n\\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix}\n= -\n\\begin{pmatrix} h_2 \\\\ h_3 \\\\ \\vdots \\\\ h_{N-1} \\end{pmatrix}\n$$\n我们使用标准的最小二乘解算器求解系统 $\\mathbf{H}\\mathbf{c}=-\\mathbf{h}'$ 以获得系数向量 $\\mathbf{c}=[c_1, c_2, \\dots, c_P]^T$。\n\n#### 步骤 4：恢复频率\n\n系数 $c_l$ 定义了一个特征多项式，其根是 z 域极点 $z_j$：\n$$\nz^P + c_1 z^{P-1} + \\dots + c_P = 0\n$$\n我们找到这个多项式的 $P=2$ 个根，$z_1$ 和 $z_2$。这些根通过定义 $z_j = \\mathrm{e}^{\\mathrm{i}\\Omega_j\\Delta t}$ 与复频率 $\\Omega_j$ 相关联。我们可以反转这个关系来找到 $\\Omega_j$：\n$$\n\\mathrm{i}\\Omega_j\\Delta t = \\ln(z_j) \\implies \\Omega_j = \\frac{-\\mathrm{i}\\ln(z_j)}{\\Delta t}\n$$\n其中 $\\ln$ 是复自然对数。$\\Omega_j$ 的实部就是我们想要的角频率 $\\omega_j = \\mathrm{Re}(\\Omega_j)$。\n\n最后，对于每个测试用例 $k$，我们得到两个频率，然后按升序排序并四舍五入到六位小数，如规范所述。对测试套件中的所有 $k$ 值重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used, as numpy is sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the harmonic inversion problem for a 1D photonic crystal.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # k (wavevector)\n        0.0,\n        np.pi,\n        np.pi / 2.0,\n    ]\n\n    # Define parameters from the problem statement\n    a = 1.0\n    omega_01 = 10.0\n    omega_02 = 14.0\n    J1 = 3.0\n    J2 = 1.5\n    gamma1 = 0.1\n    gamma2 = 0.08\n    \n    W = 40.0\n    M = 4096\n    \n    dt = 0.05\n    N = 128\n    P = 2\n    \n    # Create the frequency and time grids\n    omega_grid = np.linspace(-W, W, M, dtype=np.float64)\n    d_omega = (2 * W) / (M - 1)\n    t_grid = np.arange(N, dtype=np.float64) * dt\n\n    results = []\n    for k in test_cases:\n        # Step 1: Calculate model parameters for the given k\n        omega1_k = np.sqrt(omega_01**2 + 4 * J1 * np.sin(k * a / 2)**2)\n        omega2_k = np.sqrt(omega_02**2 + 4 * J2 * np.sin(k * a / 2)**2)\n        \n        Omega1_k = omega1_k - 1j * gamma1\n        Omega2_k = omega2_k - 1j * gamma2\n        \n        C1_k = 1.0 + 0.4 * np.cos(k * a)\n        C2_k = 0.7 + 0.3 * np.sin(k * a)\n        \n        # Step 2: Generate synthetic frequency-domain data\n        E_bar = C1_k / (omega_grid - Omega1_k) + C2_k / (omega_grid - Omega2_k)\n        \n        # Step 3: Compute time-domain impulse response via numerical inverse Fourier Transform\n        # Vectorized calculation for efficiency\n        exp_matrix = np.exp(1j * np.outer(t_grid, omega_grid))\n        h = (d_omega / (2 * np.pi)) * np.dot(exp_matrix, E_bar)\n\n        # Step 4: Apply harmonic inversion (Prony's Method / Linear Prediction)\n        # Set up the linear system Hc = -h' to find prediction coefficients c\n        \n        # Construct the matrix H of shape (N-P, P)\n        # The j-th column is h[P-1-j : N-1-j]\n        H = np.array([h[P - 1 - j : N - 1 - j] for j in range(P)], dtype=np.complex128).T\n\n        # Construct the vector h' to be predicted\n        h_prime = h[P:N]\n        \n        # Solve the least-squares problem Hc = -h'\n        c, _, _, _ = np.linalg.lstsq(H, -h_prime, rcond=None)\n        \n        # Step 5: Find the roots of the characteristic polynomial z^P + c_1*z^{P-1} + ... = 0\n        poly_coeffs = np.concatenate(([1.0], c))\n        z_roots = np.roots(poly_coeffs)\n        \n        # Step 6: Recover the complex frequencies Ω from the roots z\n        # Ω_j = -i * log(z_j) / Δt\n        Omega_recovered = -1j * np.log(z_roots) / dt\n        \n        # Step 7: Extract real parts (angular frequencies), sort, and round\n        omega_recovered = np.real(Omega_recovered)\n        omega_sorted = np.sort(omega_recovered)\n        omega_rounded = [np.round(val, 6) for val in omega_sorted]\n        \n        results.append(omega_rounded)\n\n    # Final print statement in the exact required format.\n    # e.g., [[val1,val2],[val3,val4]]\n    list_of_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(list_of_strings)}]\")\n\nsolve()\n```"
        }
    ]
}