{
    "hands_on_practices": [
        {
            "introduction": "本练习为数据驱动的降阶建模奠定了基础。您将首先通过时域有限差分 (FDTD) 方法模拟电磁波传播的物理过程，以生成一组数据“快照”。接着，您将对这些快照应用本征正交分解 (POD) 方法，以提取能量上最显著的空间模式，从而构成一个紧凑的基。通过该练习，您不仅能掌握生成训练数据和执行压缩的核心工作流程，更重要的是，它将奇异值分解 (SVD) 的抽象数学与由坡印亭定理描述的能量守恒物理原理紧密联系起来。",
            "id": "3345280",
            "problem": "考虑一个长度为 $L$、具有周期性边界条件的一维、无损、均匀真空域。电磁场在一个包含 $N$ 个单元的均匀Yee网格上进行离散化，空间步长为 $\\Delta x = L/N$。记横截面积为 $A=1$ 平方米，因此单元体积为 $\\Delta V = A \\Delta x = \\Delta x$。设电场分量为 $E(x,t)$，磁场分量为 $H(x,t)$，其中光速为 $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$，真空介电常数为 $\\varepsilon_0$，真空磁导率为 $\\mu_0$。时间步长 $\\Delta t$ 满足一维传播的Courant稳定性条件，即 $c_0 \\Delta t \\le \\Delta x$。时域有限差分 (FDTD) 离散化采用交错格式在时间上更新 $E$ 和 $H$：\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right),\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right),\n$$\n其中下标是周期性的，即 $E^n_{i+N} = E^n_i$ 和 $H^{n+\\frac{1}{2}}_{i+N} = H^{n+\\frac{1}{2}}_i$。在时间步长 $n$ 处的离散总电磁能为\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x,\n$$\n单位为焦耳 (Joules)。对于此周期性无源系统，离散Poynting定理意味着 $\\mathcal{W}^n$ 不随 $n$ 变化。\n\n设在离散时间 $t_k = k \\Delta t$（其中 $k \\in \\{0,1,\\ldots,m-1\\}$）收集电场的 $m$ 个快照，形成快照矩阵 $X \\in \\mathbb{R}^{N \\times m}$，其列向量为 $x_k \\in \\mathbb{R}^N$，其中 $x_k$ 是 $E^k_i$ 的向量。定义用于电场向量能量内积的对称正定权重矩阵为 $W_E = \\varepsilon_0 \\Delta x \\, I_N$，其中 $I_N$ 是大小为 $N$ 的单位矩阵。秩为 $r$ 的本征正交分解 (POD) 基是关于 $W_E$-内积构造的，通过对缩放后的快照矩阵 $Y = W_E^{1/2} X / \\sqrt{m}$ 进行奇异值分解 (SVD) 得到，其中 $W_E^{1/2}$ 是 $W_E$ 的对称平方根。设 $Y = U \\Sigma V^\\top$ 为SVD分解，其中奇异值 $\\sigma_i$ 位于 $\\Sigma$ 的对角线上，左奇异向量位于 $U$ 中。$W_E$-正交归一的POD基是矩阵 $\\Phi_r = W_E^{-1/2} U_r$，其中 $U_r$ 包含 $U$ 的前 $r$ 列。快照 $x_k$ 到 $\\mathrm{span}(\\Phi_r)$ 上的 $W_E$-正交投影为 $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$。\n\n定义能量范数均方投影误差\n$$\nJ_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\left\\| x_k - P_r x_k \\right\\|_{W_E}^2,\n$$\n其中 $\\|z\\|_{W_E}^2 = z^\\top W_E z$。使用离散Poynting定理，任意时刻的电能满足\n$$\n\\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\n其中 $\\mathcal{W}^0$ 是初始总电磁能。这给出了一个先验界\n$$\nJ_r \\le \\sum_{i=r+1}^{p} \\sigma_i^2 \\le \\frac{1}{m}\\sum_{k=0}^{m-1} \\|x_k\\|_{W_E}^2 \\le 2 \\mathcal{W}^0,\n$$\n其中 $p = \\mathrm{rank}(Y)$。\n\n您的任务是：\n1. 实现所述的一维FDTD方案，使用常数 $\\varepsilon_0 = 8.854187817 \\times 10^{-12}$ 法拉/米，$\\mu_0 = 4\\pi \\times 10^{-7}$ 亨利/米，以及 $c_0 = 1/\\sqrt{\\mu_0 \\varepsilon_0}$。在 $t=0$ 时，用两个高斯脉冲的叠加来初始化场 $E(x,0)$：\n$$\nE(x,0) = E_0 \\left(\\exp\\left(-\\frac{(x - 0.25L)^2}{w^2}\\right) - \\exp\\left(-\\frac{(x - 0.75L)^2}{w^2}\\right)\\right),\n$$\n以及 $H(x,0) = 0$。使用 $E_0 = 1$ 伏特/米 和 $w = 0.05 L$ 米。从模拟的 $E$ 场中收集 $m$ 个快照 $x_k$。\n2. 使用上述加权SVD构造POD基，并计算 $m$ 个快照的能量范数均方投影误差 $J_r$、POD尾部和 $\\sum_{i=r+1}^{p} \\sigma_i^2$、基于Poynting定理的先验界 $2 \\mathcal{W}^0$（单位为焦耳），以及在所有时间步 $n \\in \\{0,\\ldots,m-1\\}$ 上 $\\mathcal{W}^n$ 与 $\\mathcal{W}^0$ 的最大绝对偏差（单位为焦耳）。\n3. 所有能量单位均以焦耳表示。不使用角度。不涉及百分比；所有量均为实数。\n\n测试套件：\n- 情况A（一般情况）：$L = 1$ 米，$N = 128$，$m = 120$，$r = 10$，以及 $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n- 情况B（边界情况，投影误差接近零）：$L = 1$ 米，$N = 80$，$m = 60$，$r = 60$，以及 $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n- 情况C（边缘情况，零维降维空间）：$L = 1$ 米，$N = 100$，$m = 50$，$r = 0$，以及 $\\Delta t = 0.99 \\, \\Delta x / c_0$ 秒。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身就是一个形如 $[J_r, \\sum_{i=r+1}^{p} \\sigma_i^2, 2\\mathcal{W}^0, \\max_n |\\mathcal{W}^n - \\mathcal{W}^0|]$ 的列表。例如，输出必须如下所示：\n$$\n[[J_{r,A}, \\mathrm{tail}_A, \\mathrm{bound}_A, \\mathrm{dev}_A],[J_{r,B}, \\mathrm{tail}_B, \\mathrm{bound}_B, \\mathrm{dev}_B],[J_{r,C}, \\mathrm{tail}_C, \\mathrm{bound}_C, \\mathrm{dev}_C]].\n$$\n所有数字均以焦耳为单位，并且必须以不带单位的原始十进制浮点数形式打印。",
            "solution": "用户提供了一个计算电磁学问题，要求实现一维时域有限差分 (FDTD) 模拟，然后对得到的场快照进行本征正交分解 (POD)。任务是计算与系统能量和基于POD的投影误差相关的几个量。\n\n### 基于原理的设计与方法\n\n解决该问题的方法是首先实现物理模拟，然后进行数学分析（模型降阶）。\n\n**1. FDTD 模拟**\n\n该模拟对一维、周期性、无损真空域中的电磁波传播进行建模。其控制方程是麦克斯韦方程组，对于横电磁 (TEM) 波，在一维情况下简化为一个一阶偏微分方程的耦合系统：\n$$\n\\frac{\\partial H}{\\partial t} = \\pm \\frac{1}{\\mu_0} \\frac{\\partial E}{\\partial x}\n$$\n$$\n\\frac{\\partial E}{\\partial t} = \\pm \\frac{1}{\\varepsilon_0} \\frac{\\partial H}{\\partial x}\n$$\n问题提供了一组特定的离散更新方程，这些方程对应于一个有效的、能量守恒的波传播系统，尽管其符号约定不寻常（均为正号），这可以解释为对其中一个场分量的重新定义。我们将完全按照所述实现这些方程。\n\nFDTD方法对空间和时间进行离散化。问题指定了Yee网格，这是一种交错网格排列。电场 $E$ 分量位于整数网格点 $i\\Delta x$ 处，而磁场 $H$ 分量位于半整数点 $(i+\\frac{1}{2})\\Delta x$ 处。时间步进也是交错的（一种“蛙跳”格式）：$E$ 在整数时间步 $n\\Delta t$ 处求值，$H$ 在半整数时间步 $(n+\\frac{1}{2})\\Delta t$ 处求值。\n\n给出的更新方程是：\n$$\nH^{n+\\frac{1}{2}}_i = H^{n-\\frac{1}{2}}_i + \\frac{\\Delta t}{\\mu_0 \\Delta x}\\left(E^n_{i+1} - E^n_i\\right)\n$$\n$$\nE^{n+1}_i = E^n_i + \\frac{\\Delta t}{\\varepsilon_0 \\Delta x}\\left(H^{n+\\frac{1}{2}}_i - H^{n+\\frac{1}{2}}_{i-1}\\right)\n$$\n这些是使用数组操作实现的。周期性边界条件通过循环移位（`numpy.roll`）来处理。模拟从给定的初始电场 $E(x,0)$ 和零初始磁场开始。在蛙跳格式中，这被解释为 $H^{-1/2} = 0$。模拟运行 $m$ 个时间步，在每个步骤 $k$，电场向量 $E^k$ 被存储为快照矩阵 $X$ 的一列。\n\n**2. 能量计算**\n\n在模拟过程中，每一步 $n$ 都会计算总电磁能 $\\mathcal{W}^n$。问题提供了离散交错能量的公式：\n$$\n\\mathcal{W}^n = \\frac{1}{2}\\sum_{i=0}^{N-1}\\varepsilon_0 \\left(E^n_i\\right)^2 \\Delta x + \\frac{1}{2}\\sum_{i=0}^{N-1}\\mu_0 \\left(H^{n+\\frac{1}{2}}_i\\right)^2 \\Delta x\n$$\n这个量预计是近似守恒的。我们计算初始能量 $\\mathcal{W}^0$ 和整个模拟过程中的最大偏差 $|\\mathcal{W}^n - \\mathcal{W}^0|$。问题指定横截面积为 $A=1 \\, \\mathrm{m}^2$，这使得计算出的量（量纲上是能量密度，单位 $J/m^2$）在数值上可以被解释为总能量，单位为焦耳。分析的先验界取为 $2 \\mathcal{W}^0$。\n\n**3. 本征正交分解 (POD)**\n\nPOD 是一种为给定数据集（快照）寻找最优低秩基的技术。“最优”在这里指的是在选定的范数下最小化平均投影误差。问题指定了能量范数，其由内积 $\\langle u, v \\rangle_{W_E} = u^\\top W_E v$ 定义，其中权重矩阵为 $W_E = \\varepsilon_0 \\Delta x I_N$。\n\nPOD基是通过对一个特殊缩放的快照矩阵进行奇异值分解 (SVD) 来构造的。步骤如下：\n- 构造缩放后的快照矩阵 $Y = W_E^{1/2} X / \\sqrt{m}$。\n- 计算其 SVD：$Y = U \\Sigma V^\\top$。$U$ 的列是左奇异向量，$\\Sigma$ 的对角线元素是奇异值 $\\sigma_i$。\n- 秩为 $r$ 的 $W_E$-正交归一的POD基由 $\\Phi_r = W_E^{-1/2} U_r$ 给出，其中 $U_r$ 包含 $U$ 的前 $r$ 列。\n\n**4. 所需量的计算**\n\n利用 SVD 的结果，我们计算所需的量：\n- **POD尾部和**：这是被忽略的奇异值平方和，$\\sum_{i=r+1}^{p} \\sigma_i^2$，其中 $p$ 是 $Y$ 的秩。在我们基于0索引的数值实现中，这对应于 `sum(s[r:]**2)`。\n- **均方投影误差 ($J_r$)**：其定义为 $J_r = \\frac{1}{m} \\sum_{k=0}^{m-1} \\| x_k - P_r x_k \\|_{W_E}^2$，其中 $P_r x_k = \\Phi_r \\Phi_r^\\top W_E x_k$ 是快照 $x_k$ 到POD基上的投影。POD的一个关键定理指出，$J_r$ 精确等于POD尾部和。我们通过对每个快照显式执行投影并对误差求和来计算 $J_r$，以验证我们的实现。投影公式可简化为 $P_r x_k = W_E^{-1/2} U_r U_r^\\top W_E^{1/2} x_k$。\n- **先验界**：这由 $2 \\mathcal{W}^0$ 给出。\n- **能量偏差**：这是 $\\max_n |\\mathcal{W}^n - \\mathcal{W}^0|$。\n\n整个过程被封装在一个函数中，该函数接收给定测试用例的参数并返回四个所需的数值。主脚本遍历测试套件并按指定格式化输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define physical constants\n    EPSILON_0 = 8.854187817e-12\n    MU_0 = 4 * np.pi * 1e-7\n    C_0 = 1 / np.sqrt(EPSILON_0 * MU_0)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (L, N, m, r, dt_factor)\n        (1.0, 128, 120, 10, 0.99), # Case A\n        (1.0, 80, 60, 60, 0.99),   # Case B\n        (1.0, 100, 50, 0, 0.99),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, m, r, dt_factor = case\n        result = _solve_case(L, N, m, r, dt_factor, EPSILON_0, MU_0, C_0)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    # The format [...,[...],...] is achieved by creating strings for sub-lists\n    # and joining them.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_case(L, N, m, r, dt_factor, epsilon0, mu0, c0):\n    \"\"\"\n    Solves a single test case of the FDTD-POD problem.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = L / N\n    dt = dt_factor * dx / c0\n    x_grid = np.linspace(0, L, N, endpoint=False)\n\n    # 2. Initial Conditions\n    e_field_amp = 1.0\n    w = 0.05 * L\n    # E-field at time n=0\n    E = e_field_amp * (np.exp(-((x_grid - 0.25 * L) ** 2) / w**2) -\n                     np.exp(-((x_grid - 0.75 * L) ** 2) / w**2))\n    # H-field at time n=-1/2 is initialized to zero\n    H = np.zeros(N)\n\n    # Snapshot matrix and FDTD update coefficients\n    X = np.zeros((N, m))\n    ch = dt / (mu0 * dx)\n    ce = dt / (epsilon0 * dx)\n    \n    # Energy history\n    energy_history = np.zeros(m)\n    W0 = 0.0\n\n    # 3. FDTD Simulation\n    for n in range(m):\n        # Store snapshot E^n\n        X[:, n] = E\n        \n        # Update H to H^{n+1/2} from H^{n-1/2} and E^n\n        H = H + ch * (np.roll(E, -1) - E)\n        \n        # Calculate discrete energy W^n using E^n and H^{n+1/2}\n        electric_energy = 0.5 * epsilon0 * dx * np.sum(E**2)\n        magnetic_energy = 0.5 * mu0 * dx * np.sum(H**2)\n        current_energy = electric_energy + magnetic_energy\n        energy_history[n] = current_energy\n        \n        if n == 0:\n            W0 = current_energy\n            \n        # Update E to E^{n+1} from E^n and H^{n+1/2}\n        E = E + ce * (H - np.roll(H, 1))\n\n    # 4. Post-processing and POD Analysis\n    \n    # Maximum energy deviation and Poynting-based bound\n    max_energy_deviation = np.max(np.abs(energy_history - W0))\n    poynting_bound = 2.0 * W0\n    \n    # Perform POD\n    # The weight matrix is W_E = epsilon0 * dx * I_N\n    # Its square root is W_E^{1/2} = sqrt(epsilon0 * dx) * I_N\n    gamma = np.sqrt(epsilon0 * dx)\n    \n    # Scale snapshot matrix: Y = W_E^{1/2} * X / sqrt(m)\n    Y = (gamma / np.sqrt(m)) * X\n    \n    # SVD of Y: Y = U * Sigma * V^T\n    U, s, _ = np.linalg.svd(Y, full_matrices=False)\n    \n    # POD tail sum: sum_{i=r+1 to p} sigma_i^2\n    # This corresponds to sum(s[r:]**2) in 0-based numpy indexing\n    pod_tail_sum = np.sum(s[r:]**2)\n    \n    # Mean squared energy-norm projection error J_r\n    # This is calculated explicitly by projecting each snapshot.\n    # By POD theory, J_r should equal pod_tail_sum.\n    Jr = 0.0\n    if r >= min(N, m):\n        # If r is >= rank, projection is perfect, error is 0\n        Jr = 0.0\n    elif r == 0:\n        # Projection is onto zero space, error is the norm of the vector\n        # J_0 = (1/m) * sum ||x_k||^2_WE = sum(s**2)\n        Jr = np.sum(s**2)\n    else:\n        projection_errors_sq_sum = 0.0\n        U_r = U[:, :r]\n        for k in range(m):\n            x_k = X[:, k]\n            \n            # Project x_k onto the POD basis: P_r(x_k) = W_E^{-1/2} U_r U_r^T W_E^{1/2} x_k\n            y_k = gamma * x_k # y_k = W_E^{1/2} x_k\n            y_k_proj = U_r @ (U_r.T @ y_k) # Projection in the weighted space\n            P_r_x_k = (1.0 / gamma) * y_k_proj # Transform back to original space\n            \n            error_vec = x_k - P_r_x_k\n            # Squared energy norm of the error: ||error_vec||^2_WE = gamma^2 * sum(error_vec**2)\n            projection_errors_sq_sum += (gamma**2) * np.sum(error_vec**2)\n        \n        Jr = projection_errors_sq_sum / m\n\n    return [Jr, pod_tail_sum, poynting_bound, max_energy_deviation]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在上一个练习构建全局基的概念之上，本实践将探索一种更具适应性的瞬态问题策略。对于时域上局域化的现象（如传播的波包），单一的全局基可能效率低下，因为它必须同时捕捉所有时间实例的行为。在这里，您将实现一种时间窗格化方案，以构建一系列局部基，每个基都针对模拟的特定部分进行定制，从而让您能够研究基的时间范围与其在给定精度下所需复杂度（或秩）之间的关键权衡。",
            "id": "3345245",
            "problem": "考虑一个长度为 $L$ 的一维、无损、均匀介质线段，它被离散为 $N$ 个均匀空间节点，间距为 $dx = L/(N-1)$。令 $\\mathbf{E}(t) \\in \\mathbb{R}^{N}$ 表示在时间 $t$ 的空间离散电场，单位为伏特/米。瞬时电场能量密度为 $u_{E}(x,t) = \\frac{\\varepsilon}{2}\\lVert \\mathbf{E}(x,t)\\rVert^{2}$，其中 $\\varepsilon$ 是介质的介电常数。在离散空间设置中，时间 $t$ 的电场的 $L^{2}$ 范数的平方定义为\n$$\n\\lVert \\mathbf{E}(t) \\rVert_{L^{2}}^{2} \\approx \\sum_{i=1}^{N} \\mathbf{E}_{i}(t)^{2}\\,dx,\n$$\n该值与总存储电能成正比，比例常数为 $\\varepsilon/2$。\n\n一个合成瞬态数据集由两个移动高斯脉冲的叠加指定，以表示空间离散化下的 $\\mathbf{E}(x,t)$：\n$$\n\\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - \\left(x_{m0} + v_{m}(t - t_{m0})\\right)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right),\n$$\n对于 $i=1,\\dots,N$，其中 $x_{i}$ 是空间节点位置，$A_{m}$ 是振幅（单位：伏特/米），$x_{m0}$ 是初始空间中心（单位：米），$v_{m}$ 是速度（单位：米/秒），$t_{m0}$ 是中心时间（单位：秒），$\\sigma_{x,m}$ 和 $\\sigma_{t,m}$ 分别是空间和时间标准差（单位：米和秒）。\n\n数值网格和参数如下：\n- $L = 1\\,\\text{m}$，$N = 64$，$[0,L]$ 上的均匀节点，以及 $dx = L/(N-1)$。\n- 总仿真时间 $T = 0.02\\,\\text{s}$，均匀时间步长 $dt = 1\\times 10^{-4}\\,\\text{s}$，时间点 $t_{n} = n\\,dt$，其中 $n=0,1,\\dots,\\lfloor T/dt \\rfloor$。\n- 脉冲参数：\n  - 脉冲 $m=1$：$A_{1} = 1.0\\,\\text{V/m}$，$x_{10} = 0.30\\,\\text{m}$，$v_{1} = 0.10\\,\\text{m/s}$，$t_{10} = 0.006\\,\\text{s}$，$\\sigma_{x,1} = 0.08\\,\\text{m}$，$\\sigma_{t,1} = 0.002\\,\\text{s}$。\n  - 脉冲 $m=2$：$A_{2} = 0.60\\,\\text{V/m}$，$x_{20} = 0.70\\,\\text{m}$，$v_{2} = -0.15\\,\\text{m/s}$，$t_{20} = 0.012\\,\\text{s}$，$\\sigma_{x,2} = 0.12\\,\\text{m}$，$\\sigma_{t,2} = 0.003\\,\\text{s}$。\n\n定义一个时间局部化加窗方案，窗长为 $\\Delta t_{w}$，重叠分数为 $\\alpha \\in [0,1)$，其中连续窗口的起始时间相隔 $\\Delta t_{w}(1-\\alpha)$ 秒。对于每个窗口 $w$，收集时间索引位于该窗口内的 $\\mathbf{E}(t)$ 快照，形成一个加权快照矩阵\n$$\nX_{w} = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{M_{w}}}) \\right] \\in \\mathbb{R}^{N \\times M_{w}},\n$$\n该矩阵通过均匀求积诱导空间 $L^{2}$ 内积。对于每个 $X_{w}$，考虑在最小化投影残差平方和意义下对快照列的最佳秩-$r$ 线性子空间近似。令 $\\tau \\in (0,1)$ 为要求的捕获能量分数。窗口 $w$ 的最小维度 $r_{w}$ 定义为：所选降阶基捕获该窗口内总快照能量至少为 $\\tau$ 分数所需的最小整数 $r$。对于由 $\\Delta t_{w}$ 和 $\\alpha$ 诱导的整个窗口集合，将案例结果定义为\n$$\nr_{\\max} = \\max_{w} r_{w},\n$$\n即在所有窗口中保证至少捕获 $\\tau$ 分数能量所需的最坏情况下的最小维度。\n\n你的任务是实现一个完整的程序来：\n1.  根据上述规范生成 $\\mathbf{E}_{i}(t)$，单位为伏特/米，时间单位为秒。\n2.  对于给定的 $\\Delta t_{w}$ 和 $\\alpha$，将时间间隔划分为窗口。如有必要，通过调整最后一个窗口的起始索引来确保最后一个窗口包含最终时间。每个窗口使用整数个样本，通过将 $\\Delta t_{w}/dt$ 四舍五入到最近的整数计算，并强制至少有一个样本。\n3.  对于每个窗口 $w$，构建 $X_{w}$，计算使用最优秩-$r$ 子空间在该窗口中捕获至少 $\\tau$ 分数总快照能量所需的最小整数 $r_{w}$，然后计算该案例的 $r_{\\max}$。\n\n设计你的实现以产生以下测试套件结果，每个案例一个：\n- 案例 A：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.5$ (小数)，$\\tau = 0.99$ (小数)。\n- 案例 B：$\\Delta t_{w} = 0.012\\,\\text{s}$，$\\alpha = 0.5$ (小数)，$\\tau = 0.99$ (小数)。\n- 案例 C：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.0$ (小数)，$\\tau = 0.95$ (小数)。\n- 案例 D：$\\Delta t_{w} = 0.008\\,\\text{s}$，$\\alpha = 0.75$ (小数)，$\\tau = 0.999$ (小数)。\n- 案例 E：$\\Delta t_{w} = 0.020\\,\\text{s}$，$\\alpha = 0.5$ (小数)，$\\tau = 0.90$ (小数)。\n\n每个案例的答案必须是单个整数 $r_{\\max}$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_{A},r_{B},r_{C},r_{D},r_{E}]$）。所有时间必须以秒为单位处理，所有电场值必须以伏特/米为单位。不涉及角度。分数（如 $\\alpha$ 和 $\\tau$）必须作为小数提供和处理，而不是百分比。",
            "solution": "用户希望我解决一个与电磁学中降阶建模相关的计算问题。\n\n### 步骤 1：提取给定信息\n- **空间域：** 长度 $L = 1\\,\\text{m}$，$N = 64$ 个均匀节点，间距 $dx = L/(N-1)$。\n- **时域：** 总时间 $T = 0.02\\,\\text{s}$，时间步长 $dt = 1 \\times 10^{-4}\\,\\text{s}$。时间点 $t_n = n \\cdot dt$，其中 $n = 0, 1, \\dots, \\lfloor T/dt \\rfloor$。\n- **电场模型：** 一个空间离散场 $\\mathbf{E}(t) \\in \\mathbb{R}^{N}$，定义为两个移动高斯脉冲的叠加：\n$$ \\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - \\left(x_{m0} + v_{m}(t - t_{m0})\\right)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right) $$\n- **脉冲 1 参数：** $A_{1} = 1.0\\,\\text{V/m}$，$x_{10} = 0.30\\,\\text{m}$，$v_{1} = 0.10\\,\\text{m/s}$，$t_{10} = 0.006\\,\\text{s}$，$\\sigma_{x,1} = 0.08\\,\\text{m}$，$\\sigma_{t,1} = 0.002\\,\\text{s}$。\n- **脉冲 2 参数：** $A_{2} = 0.60\\,\\text{V/m}$，$x_{20} = 0.70\\,\\text{m}$，$v_{2} = -0.15\\,\\text{m/s}$，$t_{20} = 0.012\\,\\text{s}$，$\\sigma_{x,2} = 0.12\\,\\text{m}$，$\\sigma_{t,2} = 0.003\\,\\text{s}$。\n- **加窗：** 窗长 $\\Delta t_{w}$，重叠分数 $\\alpha \\in [0,1)$。连续窗口的起始时间相隔 $\\Delta t_{w}(1-\\alpha)$ 秒。每个窗口的样本数由 $\\Delta t_{w}/dt$ 四舍五入得到。调整最后一个窗口以包含最终时间样本。\n- **快照矩阵：** 对于每个窗口 $w$，收集快照 $\\mathbf{E}(t)$ 以形成 $\\mathbf{X}_{w} = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{M_{w}}}) \\right]$。\n- **秩确定：** 找到窗口 $w$ 的最小整数秩 $r_w$，使得最佳秩-$r_w$ 线性子空间捕获 $\\mathbf{X}_w$ 中至少为 $\\tau$ 分数的总能量。\n- **案例结果：** $r_{\\max} = \\max_{w} r_{w}$。\n- **测试案例：**\n  - 案例 A：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.5$，$\\tau = 0.99$。\n  - 案例 B：$\\Delta t_{w} = 0.012\\,\\text{s}$，$\\alpha = 0.5$，$\\tau = 0.99$。\n  - 案例 C：$\\Delta t_{w} = 0.004\\,\\text{s}$，$\\alpha = 0.0$，$\\tau = 0.95$。\n  - 案例 D：$\\Delta t_{w} = 0.008\\,\\text{s}$，$\\alpha = 0.75$，$\\tau = 0.999$。\n  - 案例 E：$\\Delta t_{w} = 0.020\\,\\text{s}$，$\\alpha = 0.5$，$\\tau = 0.90$。\n- **输出格式：** 一个整数列表，例如 $[r_{A},r_{B},r_{C},r_{D},r_{E}]$。\n\n### 步骤 2：使用提取的给定信息进行验证\n1.  **科学依据：** 该问题使用了一个合成但物理上合理的波现象表示。用于模型降阶的方法，即通过奇异值分解 (SVD) 实现的本征正交分解 (POD)，是计算科学与工程中的一种标准且强大的技术。奇异值与能量之间的联系是该方法的基础。该问题在科学上是合理的。\n2.  **适定性：** 所有参数、方程和程序都已明确定义。任务是为几组明确定义的输入计算一个唯一的数值 ($r_{\\max}$)。SVD 保证了一组唯一的奇异值，从而可以唯一确定 $r_w$ 以及随后的 $r_{\\max}$。\n3.  **客观性：** 问题陈述没有主观性语言，完全依赖于数学和数值定义。\n4.  **缺陷清单：**\n    - 科学或事实不合理：无。\n    - 非形式化或不相关：该问题与计算电磁学中的降阶建模直接相关，并且是完全可形式化的。\n    - 不完整或矛盾的设置：无。所有参数均已提供。处理最后一个窗口的规则虽然需要仔细解释，但并不矛盾。\n    - 不切实际或不可行：参数在物理上是合理的，计算在标准硬件上是可行的。\n    - 病态或结构不良：问题是适定的，解是唯一的。\n    - 故作高深、微不足道或同义反复：该问题需要一个非平凡的实现，涉及数据生成、加窗和数值线性代数 (SVD)，是对 POD 理解的有效测试。\n    - 超出科学可验证性：结果是可通过计算验证的。\n\n### 步骤 3：结论和行动\n问题有效。将提供一个合理的解决方案。\n\n该问题要求计算在一组时间局部化窗口上，对瞬态电场进行降阶建模所需的最大秩 $r_{\\max}$。该过程涉及生成一个合成数据集，对其进行分区，并对每个数据段应用奇异值分解 (SVD) 以确定给定能量捕获准则下必要的模型复杂度。\n\n首先，我们建立离散域。空间域是一条长度为 $L=1\\,\\text{m}$ 的线，被离散为 $N=64$ 个节点，因此空间坐标为 $x_i$，其中 $i=0, \\dots, N-1$，间距为 $dx=L/(N-1)$。时域从 $t=0$ 到 $T=0.02\\,\\text{s}$，时间步长为 $dt=1\\times 10^{-4}\\,\\text{s}$，产生 $N_t = \\lfloor T/dt \\rfloor + 1 = 201$ 个时间点 $t_n=n \\cdot dt$。\n\n在空间节点 $x_i$ 和时间 $t$ 的电场 $\\mathbf{E}_{i}(t)$ 由两个移动高斯脉冲的叠加给出：\n$$ \\mathbf{E}_{i}(t) = \\sum_{m=1}^{2} A_{m}\\,\\exp\\!\\left(-\\frac{\\left(x_{i} - c_m(t)\\right)^{2}}{2\\sigma_{x,m}^{2}}\\right)\\,\\exp\\!\\left(-\\frac{(t - t_{m0})^{2}}{2\\sigma_{t,m}^{2}}\\right) $$\n其中 $c_m(t) = x_{m0} + v_{m}(t - t_{m0})$ 是第 $m$ 个脉冲随时间变化的中心。使用为两个脉冲提供的参数，我们生成一个完整的数据矩阵 $\\mathbf{E} \\in \\mathbb{R}^{N \\times N_t}$，其中每一列是在特定时间 $t_n$ 的整个空间场 $\\mathbf{E}(t_n)$ 的一个“快照”。\n\n接下来，我们根据每个案例的参数 $\\Delta t_w$ 和 $\\alpha$，将 $N_t$ 个快照序列划分为窗口。以时间样本数表示的窗长为 $N_w = \\text{max}(1, \\text{round}(\\Delta t_w/dt))$。连续窗口起始点之间的步长为 $N_{\\text{step}} = \\text{max}(1, \\text{round}(N_w(1-\\alpha)))$。我们生成一系列全长窗口。为确保包含索引为 $N_t-1$ 的最终时间样本，我们如下定义窗口起始索引：我们生成一个初始列表，包含所有能在 $N_t$ 个样本内容纳的全长窗口的起始索引。如果这些窗口中的最后一个不覆盖最终样本，我们追加一个新的窗口起始索引 $N_t - N_w$，以保证覆盖。这确保了所有窗口都具有固定的 $N_w$ 个样本长度。\n\n对于每个窗口 $w$，我们构建一个快照矩阵 $\\mathbf{X}_w \\in \\mathbb{R}^{N \\times N_w}$。$\\mathbf{X}_w$ 的列是该窗口内的电场快照，并按 $\\sqrt{dx}$ 进行缩放：\n$$ \\mathbf{X}_w = \\left[ \\sqrt{dx}\\,\\mathbf{E}(t_{n_{1}}), \\sqrt{dx}\\,\\mathbf{E}(t_{n_{2}}), \\dots, \\sqrt{dx}\\,\\mathbf{E}(t_{n_{N_w}}) \\right] $$\n这种缩放确保了一列的平方范数对应于该时刻电场能量的离散 $L^2$ 范数近似（相差一个常数 $\\varepsilon/2$）。\n\n每个窗口分析的核心是找到最佳秩-$r$ 近似。这是通过奇异值分解 (SVD) 实现的，它是本征正交分解 (POD) 的数学基础。我们计算快照矩阵的 SVD：$\\mathbf{X}_w = \\mathbf{U}_w \\mathbf{\\Sigma}_w \\mathbf{V}_w^T$。奇异值 $\\sigma_{w,j}$（$\\mathbf{\\Sigma}_w$ 的对角线元素）至关重要。窗口中快照的总“能量”由 $\\mathbf{X}_w$ 的 Frobenius 范数的平方给出，即所有奇异值平方的和：\n$$ E_{\\text{total}, w} = \\lVert \\mathbf{X}_w \\rVert_F^2 = \\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2 $$\n一个最优秩-$r$ 近似（使用 $\\mathbf{U}_w$ 的前 $r$ 个左奇异向量作为基）所捕获的能量是前 $r$ 个奇异值的平方和：\n$$ E_r = \\sum_{j=1}^{r} \\sigma_{w,j}^2 $$\n对于每个窗口 $w$，我们必须找到捕获至少 $\\tau$ 分数总能量的最小整数秩 $r_w$。这是满足以下条件的最小 $r$：\n$$ \\frac{\\sum_{j=1}^{r} \\sigma_{w,j}^2}{\\sum_{j=1}^{\\min(N, N_w)} \\sigma_{w,j}^2} \\ge \\tau $$\n我们通过计算奇异值平方的累积和，并找到累积能量分数达到或超过 $\\tau$ 的第一个索引 $r$ 来计算这个值。如果一个窗口中的总能量几乎为零，我们定义 $r_w=0$。\n\n最后，对于每个测试案例（A-E），我们找到其所有窗口中的最大所需秩，$r_{\\max} = \\max_w r_w$。这个值代表在给定加窗方案下，为了满足整个时间演化过程中的能量捕获准则 $\\tau$ 所需的最坏情况下的维度。程序为五个案例中的每一个计算这个 $r_{\\max}$，并以列表形式输出结果。",
            "answer": "```python\nimport numpy as np\n\n# Define global constants based on the problem statement\nL = 1.0\nN = 64\nT = 0.02\nDT = 1e-4\n\nPULSE1_PARAMS = {\n    'A': 1.0, 'x0': 0.30, 'v': 0.10, 't0': 0.006,\n    'sigma_x': 0.08, 'sigma_t': 0.002\n}\nPULSE2_PARAMS = {\n    'A': 0.60, 'x0': 0.70, 'v': -0.15, 't0': 0.012,\n    'sigma_x': 0.12, 'sigma_t': 0.003\n}\n\ndef generate_e_field():\n    \"\"\"\n    Generates the full spatio-temporal electric field data matrix E.\n\n    Returns:\n        tuple: A tuple containing:\n            - E (np.ndarray): The (N, num_t) field data matrix.\n            - dx (float): The spatial step size.\n            - num_t (int): The total number of time points.\n    \"\"\"\n    dx = L / (N - 1)\n    x_nodes = np.linspace(0, L, N).reshape(-1, 1)\n    \n    num_t = int(T / DT) + 1\n    t_points = np.arange(num_t) * DT\n\n    # Generate field from pulse 1\n    p1 = PULSE1_PARAMS\n    center_x1 = p1['x0'] + p1['v'] * (t_points - p1['t0'])\n    spatial_term1 = np.exp(-((x_nodes - center_x1)**2) / (2 * p1['sigma_x']**2))\n    temporal_term1 = np.exp(-((t_points - p1['t0'])**2) / (2 * p1['sigma_t']**2))\n    E1 = p1['A'] * spatial_term1 * temporal_term1\n\n    # Generate field from pulse 2\n    p2 = PULSE2_PARAMS\n    center_x2 = p2['x0'] + p2['v'] * (t_points - p2['t0'])\n    spatial_term2 = np.exp(-((x_nodes - center_x2)**2) / (2 * p2['sigma_x']**2))\n    temporal_term2 = np.exp(-((t_points - p2['t0'])**2) / (2 * p2['sigma_t']**2))\n    E2 = p2['A'] * spatial_term2 * temporal_term2\n    \n    # Superposition of the two pulses\n    E = E1 + E2\n    return E, dx, num_t\n\ndef calculate_rmax(E_field, dx, num_t, delta_t_w, alpha, tau):\n    \"\"\"\n    Calculates r_max for a given set of windowing and energy capture parameters.\n\n    Args:\n        E_field (np.ndarray): The full (N, num_t) field data matrix.\n        dx (float): The spatial step size.\n        num_t (int): The total number of time points.\n        delta_t_w (float): The window length in seconds.\n        alpha (float): The overlap fraction.\n        tau (float): The energy capture threshold.\n\n    Returns:\n        int: The calculated r_max value for the case.\n    \"\"\"\n    win_len = max(1, int(round(delta_t_w / DT)))\n    step = max(1, int(round(win_len * (1 - alpha))))\n    \n    if win_len == 0:\n        return 0\n\n    # Generate start indices for all full-length windows that fit in the data\n    stop_idx = num_t - win_len + 1\n    if stop_idx = 0:\n        start_indices = [0]\n    else:\n        start_indices = list(range(0, stop_idx, step))\n    \n    # Ensure the last window includes the final time sample by adding a\n    # final window if necessary.\n    if start_indices:\n        last_reg_window_end = start_indices[-1] + win_len\n        if last_reg_window_end  num_t:\n            final_start_idx = num_t - win_len\n            # Append only if it's a new, later-starting window\n            if final_start_idx > start_indices[-1]:\n                 start_indices.append(final_start_idx)\n    elif num_t > 0:\n         start_indices = [0]\n\n    r_max = 0\n    for start_idx in start_indices:\n        end_idx = start_idx + win_len\n        \n        E_window = E_field[:, start_idx:end_idx]\n        \n        if E_window.shape[1] == 0:\n            continue\n            \n        X_w = np.sqrt(dx) * E_window\n        \n        s = np.linalg.svd(X_w, compute_uv=False)\n        \n        s_squared = s**2\n        total_energy = np.sum(s_squared)\n        \n        if total_energy  1e-20:\n            r_w = 0\n        else:\n            cumulative_energy_fraction = np.cumsum(s_squared) / total_energy\n            # Find the smallest rank r that captures at least fraction tau\n            r_w = np.searchsorted(cumulative_energy_fraction, tau, side='left') + 1\n\n        r_max = max(r_max, r_w)\n        \n    return r_max\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    test_cases = [\n        {'delta_t_w': 0.004, 'alpha': 0.5, 'tau': 0.99},   # Case A\n        {'delta_t_w': 0.012, 'alpha': 0.5, 'tau': 0.99},   # Case B\n        {'delta_t_w': 0.004, 'alpha': 0.0, 'tau': 0.95},   # Case C\n        {'delta_t_w': 0.008, 'alpha': 0.75, 'tau': 0.999}, # Case D\n        {'delta_t_w': 0.020, 'alpha': 0.5, 'tau': 0.90},   # Case E\n    ]\n\n    E_field, dx, num_t = generate_e_field()\n    \n    results = []\n    for case in test_cases:\n        r_max = calculate_rmax(E_field, dx, num_t, **case)\n        results.append(r_max)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个高级实践将带您从仅仅创建降阶模型，迈向将其部署在一个强大的工程应用中：设计优化。您将把一个降阶模型 (ROM) 集成到基于伴随方法的频域电磁设备拓扑优化工作流中。该练习展示了 ROM 在优化等“多查询”场景中的巨大实用价值，在这些场景中，物理模型必须被反复求解。您还将实现一种基于克雷洛夫子空间的目标导向基生成技术，并通过将其计算的设计梯度与全阶模型的基准进行比较，来量化 ROM 的有效性。",
            "id": "3345202",
            "problem": "考虑由麦克斯韦方程组在一个源驱动、非磁性、二维域中以狄利克雷边界条件控制的时间谐波电磁场。在横电 (TE) 假设和标准时域有限差分 (FDFD) 离散化下，内部网格节点上的标量电场振幅 $E$ 满足一个线性系统\n$$\nA(\\boldsymbol{\\rho})\\,\\mathbf{E} = \\mathbf{b},\n$$\n其中 $\\mathbf{E} \\in \\mathbb{R}^N$ 是 $N$ 个内部节点上的场向量，$\\mathbf{b} \\in \\mathbb{R}^N$ 是一个表示局部外加电流密度的固定源向量，而 $A(\\boldsymbol{\\rho}) \\in \\mathbb{R}^{N \\times N}$ 是对称正定系统矩阵，定义为\n$$\nA(\\boldsymbol{\\rho}) = K + k_0^2 \\,\\mathrm{diag}\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})\\right),\n$$\n其中 $K$ 是狄利克雷边界条件下的离散负拉普拉斯算子（按网格间距缩放），$k_0$ 是自由空间波数，$\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ 是相对介电常数分布，通过设计向量 $\\boldsymbol{\\rho} \\in [0,1]^N$ 参数化：\n$$\n\\varepsilon_i(\\rho_i) = \\varepsilon_{\\min} + (\\varepsilon_{\\max} - \\varepsilon_{\\min})\\,\\rho_i, \\quad i = 1,\\dots,N.\n$$\n定义目标泛函\n$$\nJ(\\mathbf{E}) = \\tfrac{1}{2}\\,\\mathbf{E}^\\top W\\,\\mathbf{E},\n$$\n其中 $W \\in \\mathbb{R}^{N \\times N}$ 是一个对角加权矩阵，用于选择网格的目标“探测器”子区域（目标节点上的条目为 1，其他为 0）。$J$ 对设计向量 $\\boldsymbol{\\rho}$ 的梯度可以通过伴随法推导，从拉格朗日函数开始\n$$\n\\mathcal{L}(\\mathbf{E},\\boldsymbol{\\lambda},\\boldsymbol{\\rho}) = J(\\mathbf{E}) + \\boldsymbol{\\lambda}^\\top\\left(A(\\boldsymbol{\\rho})\\,\\mathbf{E} - \\mathbf{b}\\right),\n$$\n其中 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^N$ 是伴随变量。全阶模型 (FOM) 的伴随条件是\n$$\nA(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{E}} = W\\,\\mathbf{E},\n$$\n而 FOM 对 $\\rho_i$ 的梯度分量是\n$$\n\\frac{\\partial J}{\\partial \\rho_i} = -\\boldsymbol{\\lambda}^\\top \\frac{\\partial A(\\boldsymbol{\\rho})}{\\partial \\rho_i} \\mathbf{E} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_i\\,E_i.\n$$\n为了在拓扑优化期间加速重复求解，考虑一个通过伽辽金投影到一个由 $V \\in \\mathbb{R}^{N \\times r}$（其中 $r \\ll N$）的列所张成的子空间上构建的降阶模型 (ROM)。给定一个选定的基 $V$，ROM 的状态和伴随通过求解以下方程组获得\n$$\nA_r\\,\\mathbf{E}_r = \\mathbf{b}_r, \\quad \\text{和} \\quad A_r\\,\\boldsymbol{\\lambda}_r = \\frac{\\partial J}{\\partial \\mathbf{E}}\\bigg|_{\\mathbf{E} = V\\mathbf{E}_r}^{\\!\\!\\!\\!\\!\\!\\!\\!\\!\\text{projected}} = V^\\top W\\,V\\,\\mathbf{E}_r,\n$$\n其中 $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ 和 $\\mathbf{b}_r = V^\\top \\mathbf{b}$，然后提升得到 $\\mathbf{E}_{\\mathrm{ROM}} = V\\,\\mathbf{E}_r$ 和 $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\,\\boldsymbol{\\lambda}_r$。ROM 的梯度分量类似地计算为\n$$\n\\left(\\frac{\\partial J}{\\partial \\rho_i}\\right)_{\\mathrm{ROM}} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_{\\mathrm{ROM},i}\\,E_{\\mathrm{ROM},i}.\n$$\n通过相对误差度量来量化 ROM 引起的梯度失配\n$$\n\\eta = \\frac{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}} - \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}.\n$$\n你的任务是实现一个完整的程序，该程序：\n- 在一个大小为 $N_x \\times N_y$ 的矩形内部网格上，使用标准五点模板、狄利克雷边界条件以及在 $x$ 和 $y$ 方向上的网格间距 $h = 1/(N_x+1)$ 来构建 $K$（为简单起见，假设为单位正方形域；两个方向使用相同的间距）。\n- 根据一个在内部节点上定义的确定性的非均匀设计场 $ \\rho(x,y) = \\left[0.5 + 0.5 \\sin(2\\pi x)\\cos(2\\pi y)\\right] $（裁剪到 $[0,1]$ 范围内）来构建 $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$，其中 $x$ 和 $y$ 是内部网格上的节点坐标。\n- 选择 $\\varepsilon_{\\min} = 1.0$ 和 $\\varepsilon_{\\max} = 12.0$。\n- 将 $\\mathbf{b}$ 设置为在最接近 $(x,y) = (0.25, 0.5)$ 的内部节点处的单位点源。\n- 将 $W$ 定义为选择 $x \\ge 0.8$ 的节点的对角选择器。\n- 通过以指定的基矩阵 $A_{\\text{basis}}$ 为中心的逆克雷洛夫过程来构建降阶模型基 $V$：\n  1. 从 $\\mathbf{v}_0 = \\mathbf{b} / \\|\\mathbf{b}\\|_2$ 开始。\n  2. 对于 $j = 1, \\dots, r-1$，计算 $\\mathbf{w} = A_{\\text{basis}}^{-1}\\,\\mathbf{v}_{j-1}$，使用 Gram-Schmidt 方法将 $\\mathbf{w}$ 与之前的 $\\{\\mathbf{v}_i\\}_{i=0}^{j-1}$ 标准正交化，然后归一化得到 $\\mathbf{v}_j$。\n  3. 形成 $V = [\\mathbf{v}_0, \\dots, \\mathbf{v}_{r-1}]$。如果 $r \\ge N$，则设置 $V = I_N$ 以表示全阶子空间。\n- 计算每个测试用例的 FOM 和 ROM 梯度以及相对失配 $\\eta$。\n\n使用以下测试套件，该套件改变了降阶基的大小以及 $A_{\\text{basis}}$ 和评估矩阵 $A(\\boldsymbol{\\rho})$ 之间的一致性：\n1. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,10,8.0)$：一个具有相当丰富基的典型案例。\n2. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,N,8.0)$ 其中 $N = N_x N_y$：一个 ROM 等于 FOM 的边界情况。\n3. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,8.0,3,8.0)$：一个基非常小的边缘案例。\n4. $(N_x,N_y,k_0,r,\\text{basis }k_0) = (12,12,5.0,10,8.0)$：一个 ROM 基的构建波数与评估波数不同，用以探测参数不一致性的案例。\n\n你的程序应该产生单行输出，其中包含四个测试用例的相对失配值 $\\eta$，格式为方括号内的逗号分隔列表，每个值四舍五入到六位小数（例如，\"[0.012345,0.000001,0.123456,0.056789]\"）。不需要物理单位，也不涉及角度。所有计算都是无量纲的。\n\n你的实现必须是在指定环境中的一个完整、可运行的程序，并且不得需要用户输入或外部文件。",
            "solution": "用户提供了一个问题，要求在电磁拓扑优化的背景下，量化降阶模型 (ROM) 引入的误差。这将通过比较使用高保真全阶模型 (FOM) 计算的设计梯度与使用 ROM 计算的梯度来完成。一个关键的先决条件是验证问题陈述。\n\n### 问题验证\n\n我将首先提取已知条件并验证问题的完整性。\n\n**步骤 1：提取已知条件**\n\n- **控制物理**：时谐二维 TE 麦克斯韦方程组，通过时域有限差分 (FDFD) 进行离散化。\n- **FOM 系统**：$A(\\boldsymbol{\\rho})\\,\\mathbf{E} = \\mathbf{b}$，其中 $\\mathbf{E}, \\mathbf{b} \\in \\mathbb{R}^N$。\n- **系统矩阵**：$A(\\boldsymbol{\\rho}) = K + k_0^2 \\,\\mathrm{diag}\\!\\left(\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})\\right)$，该矩阵是对称正定 (SPD) 的。$K$ 是离散负拉普拉斯算子，$k_0$ 是自由空间波数。\n- **介电常数模型**：$\\varepsilon_i(\\rho_i) = \\varepsilon_{\\min} + (\\varepsilon_{\\max} - \\varepsilon_{\\min})\\,\\rho_i$，对于设计向量 $\\boldsymbol{\\rho} \\in [0,1]^N$。\n- **目标函数**：$J(\\mathbf{E}) = \\tfrac{1}{2}\\,\\mathbf{E}^\\top W\\,\\mathbf{E}$，其中 $W$ 是一个对角选择矩阵。\n- **FOM 伴随系统**：$A(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda} = W\\,\\mathbf{E}$。\n- **FOM 梯度**：$\\frac{\\partial J}{\\partial \\rho_i} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_i\\,E_i$。\n- **ROM 基**：$V \\in \\mathbb{R}^{N \\times r}$，其中 $r \\ll N$。\n- **ROM 系统**：$A_r\\,\\mathbf{E}_r = \\mathbf{b}_r$ (状态) 和 $A_r\\,\\boldsymbol{\\lambda}_r = V^\\top W\\,V\\,\\mathbf{E}_r$ (伴随)，其中 $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ 和 $\\mathbf{b}_r = V^\\top \\mathbf{b}$。\n- **ROM 重建**：$\\mathbf{E}_{\\mathrm{ROM}} = V\\,\\mathbf{E}_r$ 和 $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\,\\boldsymbol{\\lambda}_r$。\n- **ROM 梯度**：$\\left(\\frac{\\partial J}{\\partial \\rho_i}\\right)_{\\mathrm{ROM}} = -k_0^2\\,(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\,\\lambda_{\\mathrm{ROM},i}\\,E_{\\mathrm{ROM},i}$。\n- **误差度量**：$\\eta = \\frac{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}} - \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}{\\left\\| \\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}} \\right\\|_2}$。\n- **实现细节**：\n    - 单位正方形上的网格大小为 $N_x \\times N_y$，间距为 $h = 1/(N_x+1)$。\n    - 设计场：$ \\rho(x,y) = \\left[0.5 + 0.5 \\sin(2\\pi x)\\cos(2\\pi y)\\right] $。\n    - 常数：$\\varepsilon_{\\min} = 1.0$，$\\varepsilon_{\\max} = 12.0$。\n    - 源 $\\mathbf{b}$：最接近 $(0.25, 0.5)$ 的节点处的单位点源。\n    - 权重 $W$：选择 $x \\ge 0.8$ 的节点的选择器。\n    - 基 $V$：通过使用基矩阵 $A_{\\text{basis}}$ 的逆克雷洛夫过程构建，从 $\\mathbf{b}$ 开始，并使用 Gram-Schmidt 标准正交化。对于 $r \\ge N$，$V=I_N$。\n- **测试用例**：四个用例，改变了 $(N_x,N_y,k_0,r,\\text{basis }k_0)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n1.  **科学依据**：该问题牢固地植根于计算电磁学和数值优化的既定原理。FDFD 方法、基于伴随的灵敏度分析和基于投影的模型降阶（特别是伽辽金投影到克雷洛夫子空间）都是标准的、经过充分验证的技术。系统矩阵、梯度和投影的数学公式是正确的，并与文献一致。关于 $A(\\boldsymbol{\\rho})$ 是 SPD 的断言是正确的，因为它是一个 SPD 矩阵 ($K$) 和一个正定对角矩阵 ($k_0^2 \\mathrm{diag}(\\boldsymbol{\\varepsilon})$) 的和。\n\n2.  **适定性**：问题是适定的。FOM 矩阵 $A(\\boldsymbol{\\rho})$ 及其产生的 ROM 矩阵 $A_r = V^\\top A(\\boldsymbol{\\rho}) V$ 的 SPD 属性确保了在全阶和降阶模型中状态和伴随变量都存在唯一解。\n\n3.  **完整性和一致性**：问题陈述异常详细且自成一体。所有必要的参数、常数和函数形式都已指定，没有留下任何模糊之处。提供的状态、伴随和梯度的方程在内部是一致的（假设拉格朗日公式为 $\\mathcal{L} = J - \\boldsymbol{\\lambda}^\\top(\\dots)$，这是一个标准约定）。对于 $r \\ge N$ 情况的特殊处理被明确定义，并构成了模型降阶的有效边界条件，其中 ROM 预期会精确复现 FOM。\n\n4.  **可行性**：所有指定的参数在物理上都是现实的，计算任务也是可行的。问题规模 ($N=144$) 足够小，可以在个人计算机上使用标准库处理，包括为 $V$ 形成密集单位矩阵的情况。\n\n**步骤 3：结论和行动**\n\n该问题是**有效的**。它是一个结构良好、科学合理且完整的问题，测试了计算物理中降阶建模的核心概念。我现在将着手解决。\n\n### 解决方案\n\n该解决方案需要实现一个计算工作流，以比较全阶模型 (FOM) 和降阶模型 (ROM) 的设计灵敏度梯度。核心步骤概述如下。\n\n**1. 离散化与系统构建**\n\n连续的问题域，一个单位正方形，被离散化为一个包含 $N_x \\times N_y$ 个内部节点的网格。总自由度为 $N = N_x N_y$。两个方向上的网格间距 $h=1/(N_x+1)$ 是均匀的。所有场量都表示为大小为 $N$ 的向量。\n\n离散负拉普拉斯算子 $K$ 被构建为一个 $N \\times N$ 的稀疏矩阵，表示该网格上的五点有限差分模板，并按 $1/h^2$ 缩放。这对应于 $-\\nabla^2$ 的矩阵形式。\n\n相对介电常数分布 $\\boldsymbol{\\varepsilon}(\\boldsymbol{\\rho})$ 在每个节点处使用给定的 $\\boldsymbol{\\rho}$ 空间函数和到 $[\\varepsilon_{\\min}, \\varepsilon_{\\max}]$ 的线性映射来定义。这形成了一个对角矩阵 $\\mathrm{diag}(\\boldsymbol{\\varepsilon})$。\n\n利用这些组件，为给定的波数 $k_0$ 组装完整的系统矩阵 $A(\\boldsymbol{\\rho}) = K + k_0^2 \\mathrm{diag}(\\boldsymbol{\\varepsilon})$。\n\n**2. 源和目标的定义**\n\n源向量 $\\mathbf{b}$ 被构建为一个零向量，仅在对应于最接近 $(x,y)=(0.25, 0.5)$ 坐标的节点索引处有一个值为 $1$ 的条目。\n\n目标函数加权矩阵 $W$ 是一个对角矩阵。其对角线元素对于位于 $x \\ge 0.8$ 区域的节点为 $1$，否则为 $0$。这有效地将目标定义为探测器区域上的场强积分。\n\n**3. 全阶模型 (FOM) 分析**\n\nFOM 分析涉及两个线性求解：\n- **状态解**：通过求解主线性系统 $A(\\boldsymbol{\\rho})\\,\\mathbf{E}_{\\mathrm{FOM}} = \\mathbf{b}$ 来找到电场 $\\mathbf{E}_{\\mathrm{FOM}}$。\n- **伴随解**：通过求解伴随系统 $A(\\boldsymbol{\\rho})\\,\\boldsymbol{\\lambda}_{\\mathrm{FOM}} = W\\,\\mathbf{E}_{\\mathrm{FOM}}$ 来找到伴随变量 $\\boldsymbol{\\lambda}_{\\mathrm{FOM}}$。\n\n然后，使用公式 $\\frac{\\partial J}{\\partial \\rho_i} = -k_0^2(\\varepsilon_{\\max}-\\varepsilon_{\\min})\\lambda_{\\mathrm{FOM},i}E_{\\mathrm{FOM},i}$ 逐元素计算 FOM 梯度向量 $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{FOM}}$。\n\n**4. 降阶模型 (ROM) 构建与分析**\n\nROM 的核心是基 $V \\in \\mathbb{R}^{N \\times r}$，它将问题从高维空间 $\\mathbb{R}^N$ 投影到低维子空间 $\\mathbb{R}^r$。\n\n- **基的生成**：对于 $r  N$，基 $V$ 使用逆克雷洛夫方法生成。从归一化的源向量 $\\mathbf{v}_0 = \\mathbf{b}/\\|\\mathbf{b}\\|_2$ 开始，后续的基向量通过迭代生成：$\\mathbf{w}_j = A_{\\text{basis}}^{-1} \\mathbf{v}_{j-1}$。每个新向量 $\\mathbf{w}_j$ 都通过修正的 Gram-Schmidt 过程与所有先前的基向量 $\\{\\mathbf{v}_0, \\ldots, \\mathbf{v}_{j-1}\\}$ 正交化，然后归一化以产生 $\\mathbf{v}_j$。矩阵 $A_{\\text{basis}}$ 是使用参考波数 `basis k0` 构建的。这个过程构建了一个特别能有效表示由源 $\\mathbf{b}$ 驱动的、对于“接近”$A_{\\text{basis}}$ 的系统解的基。对于 $r \\ge N$ 的特殊情况，基是单位矩阵 $V=I_N$，意味着没有发生降阶。\n\n- **ROM 投影**：FOM 系统通过伽辽金投影投影到基 $V$ 上：\n    $A_r = V^\\top A(\\boldsymbol{\\rho}) V$\n    $\\mathbf{b}_r = V^\\top \\mathbf{b}$\n\n- **ROM 求解**：通过求解小得多的 $r \\times r$ 线性系统来找到降阶的状态和伴随变量 $\\mathbf{E}_r$ 和 $\\boldsymbol{\\lambda}_r$：\n    $A_r \\mathbf{E}_r = \\mathbf{b}_r$\n    $A_r \\boldsymbol{\\lambda}_r = (V^\\top W V) \\mathbf{E}_r$\n\n- **重建**：通过将降阶解提升回全空间来重建全空间近似：$\\mathbf{E}_{\\mathrm{ROM}} = V\\mathbf{E}_r$ 和 $\\boldsymbol{\\lambda}_{\\mathrm{ROM}} = V\\boldsymbol{\\lambda}_r$。ROM 梯度 $\\nabla_{\\boldsymbol{\\rho}} J\\big|_{\\mathrm{ROM}}$ 使用这些重建的场来计算。\n\n**5. 误差量化**\n\n最后，使用指定的相对误差度量 $\\eta$ 来量化 FOM 和 ROM 梯度之间的失配，该度量测量了两个梯度向量之间的归一化欧几里得距离。该度量为设计灵敏度分析的 ROM 准确性提供了一个简洁的衡量标准。对四个测试用例中的每一个重复整个过程。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nimport scipy.sparse.linalg as spla\n\ndef solve():\n    \"\"\"\n    Solves the reduced-order modeling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, k0, r, basis_k0)\n        (12, 12, 8.0, 10, 8.0),\n        (12, 12, 8.0, 144, 8.0), # Note: r = N = 12*12 = 144\n        (12, 12, 8.0, 3, 8.0),\n        (12, 12, 5.0, 10, 8.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, k0, r, basis_k0 = case\n        N = Nx * Ny\n        h = 1.0 / (Nx + 1)\n        \n        # 1. Grid and Coordinates\n        x_coords = np.linspace(h, 1.0 - h, Nx)\n        y_coords = np.linspace(h, 1.0 - h, Ny)\n        xv, yv = np.meshgrid(x_coords, y_coords, indexing='xy')\n        # Use C-style (row-major) flattening\n        x_flat = xv.flatten()\n        y_flat = yv.flatten()\n        \n        # 2. Construct K matrix (discrete negative Laplacian)\n        # Standard 5-point stencil for -h^2 * nabla^2 results in a matrix with \n        # 2 on the main diagonal and -1 on the two adjacent diagonals for 1D.\n        # We scale the final K matrix by 1/h^2.\n        K1D_x = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csc')\n        K1D_y = sp.diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csc')\n        I_Nx = sp.eye(Nx, format='csc')\n        I_Ny = sp.eye(Ny, format='csc')\n        # Assemble 2D Laplacian using Kronecker products for C-style ordering\n        K = (sp.kron(I_Ny, K1D_x) + sp.kron(K1D_y, I_Nx)) / (h**2)\n        K = K.tocsc()\n        \n        # 3. Construct material and source properties\n        eps_min, eps_max = 1.0, 12.0\n        rho = 0.5 + 0.5 * np.sin(2 * np.pi * x_flat) * np.cos(2 * np.pi * y_flat)\n        rho = np.clip(rho, 0, 1)\n        eps_vec = eps_min + (eps_max - eps_min) * rho\n        eps_diag = sp.diags(eps_vec, format='csc')\n        \n        # Source vector b\n        ix_src = np.argmin(np.abs(x_coords - 0.25))\n        iy_src = np.argmin(np.abs(y_coords - 0.5))\n        src_idx = iy_src * Nx + ix_src # C-style indexing\n        b = np.zeros(N)\n        b[src_idx] = 1.0\n        \n        # Weighting matrix W\n        w_vec = (x_flat >= 0.8).astype(float)\n        W = sp.diags(w_vec, format='csc')\n        \n        # 4. Construct Basis V\n        if r >= N:\n            # Special case: ROM is the FOM, so V is the identity matrix\n            V = np.eye(N)\n        else:\n            # Inverse-Krylov process\n            A_basis = K + basis_k0**2 * eps_diag\n            A_basis = A_basis.tocsc()\n            \n            V_cols = []\n            v0 = b / np.linalg.norm(b)\n            V_cols.append(v0)\n            \n            for j in range(1, r):\n                v_prev = V_cols[-1]\n                w = spla.spsolve(A_basis, v_prev)\n                \n                # Modified Gram-Schmidt orthogonalization\n                for i in range(j):\n                    v_i = V_cols[i]\n                    w = w - (v_i.T @ w) * v_i\n                \n                w_norm = np.linalg.norm(w)\n                if w_norm  1e-12: # Avoid division by zero\n                    break\n                \n                v_next = w / w_norm\n                V_cols.append(v_next)\n                \n            V = np.array(V_cols).T\n\n        # 5. Full-Order Model (FOM) Calculation\n        A = K + k0**2 * eps_diag\n        A_csc = A.tocsc()\n        \n        E_fom = spla.spsolve(A_csc, b)\n        adj_rhs_fom = W @ E_fom\n        lambda_fom = spla.spsolve(A_csc, adj_rhs_fom)\n        grad_fom = -k0**2 * (eps_max - eps_min) * lambda_fom * E_fom\n        \n        # 6. Reduced-Order Model (ROM) Calculation\n        # Project system using the basis V\n        A_r = V.T @ A @ V\n        b_r = V.T @ b\n        \n        E_r = np.linalg.solve(A_r, b_r)\n        \n        # Project objective weighting and compute reduced adjoint\n        W_r = V.T @ W @ V\n        adj_rhs_rom = W_r @ E_r\n        lambda_r = np.linalg.solve(A_r, adj_rhs_rom)\n        \n        # Lift solutions back to full space\n        E_rom = V @ E_r\n        lambda_rom = V @ lambda_r\n        grad_rom = -k0**2 * (eps_max - eps_min) * lambda_rom * E_rom\n        \n        # 7. Compute Relative Error Metric\n        grad_fom_norm = np.linalg.norm(grad_fom)\n        if grad_fom_norm == 0:\n            eta = 0.0 if np.linalg.norm(grad_rom - grad_fom) == 0 else np.inf\n        else:\n            eta = np.linalg.norm(grad_rom - grad_fom) / grad_fom_norm\n            \n        results.append(eta)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}