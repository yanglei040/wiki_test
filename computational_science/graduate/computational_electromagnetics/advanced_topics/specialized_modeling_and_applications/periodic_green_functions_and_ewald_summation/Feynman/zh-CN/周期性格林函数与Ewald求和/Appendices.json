{
    "hands_on_practices": [
        {
            "introduction": "本节练习将理论付诸实践，首先解决使用埃瓦尔德求和法时最核心的问题之一：如何选择最优的分离参数 $\\eta$。$\\eta$ 的选择直接决定了计算的效率，一个好的选择能够在实空间和倒易空间求和之间取得计算量的平衡。我们将通过对计算工作量进行合理的近似，推导出一个解析表达式来估算最优的 $\\eta$，这为实际应用提供了重要的指导。",
            "id": "3340042",
            "problem": "考虑自由空间波数为 $k$ 的时谐场的标量三维亥姆霍兹方程，以及在晶格常数为 $a$ 的简立方布拉菲 (Bravais) 晶格上的相关周期格林函数。自由空间格林函数为 $G_{0}(\\mathbf{r})=\\exp(\\mathrm{i} k r)/(4\\pi r)$，其中 $r=|\\mathbf{r}|$。在埃瓦尔德 (Ewald) 方法中，引入一个分裂参数为 $\\eta0$ 的高斯屏蔽，将周期格林函数写成一个快速衰减的实空间晶格求和与一个快速衰减的倒易空间晶格求和之和。实空间求和在半径 $R_{c}$ 处截断，倒易空间求和在波数半径 $G_{c}$ 处截断。假设波长和晶格尺度满足 $ka  2\\pi$，从而在最低倒易壳层中，倒易空间的尾部被埃瓦尔德高斯函数指数级地抑制。\n\n对于大量项，互补误差函数和高斯屏蔽意味着主阶截断误差呈指数级主导，形式如下（忽略代数前因子）：实空间截断误差以 $\\exp\\!\\left(-(\\eta R_{c})^{2}\\right)$ 的形式衰减，倒易空间截断误差以 $\\exp\\!\\left(-\\left(G_{c}^{2}-k^{2}\\right)/(4\\eta^{2})\\right)$ 的形式衰减。给定埃瓦尔德求和的周期格林函数的总截断误差的目标绝对容差为 $\\varepsilon\\in(0,1)$。\n\n假设将误差预算均等地分配给两个求和，使得每个截断误差通过其主导的指数项被控制在约 $\\varepsilon/2$ 的水平。这意味着以下关系成立：\n$$\n(\\eta R_{c})^{2}=\\ln\\!\\left(\\frac{2}{\\varepsilon}\\right),\\qquad \\frac{G_{c}^{2}-k^{2}}{4\\eta^{2}}=\\ln\\!\\left(\\frac{2}{\\varepsilon}\\right).\n$$\n对于晶格常数为 $a$ 的简立方晶格，通过连续介质近似计数来估计保留的实空间项和倒易空间项的数量：\n$$\nN_{r}\\approx \\frac{4\\pi R_{c}^{3}}{3 a^{3}},\\qquad N_{k}\\approx \\frac{V}{(2\\pi)^{3}}\\cdot \\frac{4\\pi G_{c}^{3}}{3},\\quad V=a^{3}.\n$$\n选择埃瓦尔德分裂参数 $\\eta$，通过施加 $N_{r}\\approx N_{k}$ 的条件来平衡两个求和之间的计算量，同时通过上述指数控制满足目标容差。推导最优分裂参数 $\\eta$ 的解析近似，使其成为 $\\varepsilon$、$k$ 和 $a$ 的闭式函数。将您的最终答案表示为 $\\eta(\\varepsilon,k,a)$ 的单个解析表达式。不需要进行数值计算，最终表达式中不应包含任何单位。",
            "solution": "该问题要求推导出一个最优的埃瓦尔德分裂参数 $\\eta$，它能在满足指定误差容差 $\\varepsilon$ 的同时，平衡实空间求和与倒易空间求和之间的计算量。计算量由每个求和中的项数 $N_r$ 和 $N_k$ 分别估算。优化准则是设置 $N_r \\approx N_k$。\n\n首先，我们将给定的关系形式化。定义量 $L$ 为 $L = \\ln(2/\\varepsilon)$。控制误差容差的两个方程如下：\n$$\n(\\eta R_{c})^{2} = L \\quad (1)\n$$\n$$\n\\frac{G_{c}^{2}-k^{2}}{4\\eta^{2}} = L \\quad (2)\n$$\n其中 $R_c$ 和 $G_c$ 分别是实空间和倒易空间的截断半径，$k$ 是自由空间波数，$\\eta$ 是埃瓦尔德分裂参数。\n\n对于晶格常数为 $a$ 的简立方晶格，实空间求和中的项数 $N_r$ 和倒易空间求和中的项数 $N_k$ 通过连续介质近似计数来估算：\n$$\nN_{r} \\approx \\frac{4\\pi R_{c}^{3}}{3 a^{3}} \\quad (3)\n$$\n$$\nN_{k} \\approx \\frac{V}{(2\\pi)^{3}}\\cdot \\frac{4\\pi G_{c}^{3}}{3} = \\frac{a^{3}}{8\\pi^3} \\cdot \\frac{4\\pi G_{c}^{3}}{3} = \\frac{a^{3} G_{c}^{3}}{6\\pi^{2}} \\quad (4)\n$$\n其中 $V=a^3$ 是实空间晶胞的体积。\n\n平衡计算量的优化条件是 $N_r \\approx N_k$。令 $(3)$ 和 $(4)$ 中的表达式相等：\n$$\n\\frac{4\\pi R_{c}^{3}}{3 a^{3}} = \\frac{a^{3} G_{c}^{3}}{6\\pi^{2}}\n$$\n我们可以重新整理这个方程，以找到 $R_c$ 和 $G_c$ 之间的关系：\n$$\n\\frac{R_{c}^{3}}{G_{c}^{3}} = \\frac{a^3}{6\\pi^2} \\cdot \\frac{3a^3}{4\\pi} = \\frac{3a^6}{24\\pi^3} = \\frac{a^6}{8\\pi^3}\n$$\n对两边取立方根，得到一个简单的线性关系：\n$$\n\\frac{R_c}{G_c} = \\left(\\frac{a^6}{8\\pi^3}\\right)^{1/3} = \\frac{a^2}{2\\pi}\n$$\n这意味着 $G_c = \\frac{2\\pi}{a^2} R_c$。\n\n接下来，我们使用误差控制方程 $(1)$ 和 $(2)$ 将 $R_c$ 和 $G_c$ 表示为 $\\eta$ 的函数。由方程 $(1)$ 得：\n$$\nR_c = \\frac{\\sqrt{L}}{\\eta} \\quad (5)\n$$\n由方程 $(2)$ 得：\n$$\nG_c^2 = k^2 + 4\\eta^2 L \\implies G_c = \\sqrt{k^2 + 4\\eta^2 L} \\quad (6)\n$$\n现在，将表达式 $(5)$ 和 $(6)$ 代入关系式 $G_c = \\frac{2\\pi}{a^2} R_c$ 中：\n$$\n\\sqrt{k^2 + 4\\eta^2 L} = \\frac{2\\pi}{a^2} \\left(\\frac{\\sqrt{L}}{\\eta}\\right)\n$$\n为了求解 $\\eta$，我们将方程两边平方：\n$$\nk^2 + 4\\eta^2 L = \\left(\\frac{2\\pi}{a^2}\\right)^2 \\left(\\frac{\\sqrt{L}}{\\eta}\\right)^2 = \\frac{4\\pi^2}{a^4} \\frac{L}{\\eta^2}\n$$\n整个方程乘以 $\\eta^2$ 以消去分母：\n$$\nk^2 \\eta^2 + 4L \\eta^4 = \\frac{4\\pi^2 L}{a^4}\n$$\n这可以重新整理为关于变量 $\\eta^2$ 的标准二次方程。令 $x = \\eta^2$：\n$$\n(4L)x^2 + (k^2)x - \\frac{4\\pi^2 L}{a^4} = 0\n$$\n我们使用二次公式 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 求解这个关于 $x$ 的二次方程，其中系数为 $a_{quad} = 4L$，$b_{quad} = k^2$ 和 $c_{quad} = -\\frac{4\\pi^2 L}{a^4}$：\n$$\nx = \\eta^2 = \\frac{-k^2 \\pm \\sqrt{(k^2)^2 - 4(4L)\\left(-\\frac{4\\pi^2 L}{a^4}\\right)}}{2(4L)}\n$$\n$$\n\\eta^2 = \\frac{-k^2 \\pm \\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}}{8L}\n$$\n由于 $\\eta$ 是一个实值物理参数，$\\eta^2$ 必须是一个正实数。平方根下的项 $\\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}$ 严格大于 $\\sqrt{k^4} = k^2$。因此，为确保 $\\eta^2  0$，我们必须在分子中选择正号：\n$$\n\\eta^2 = \\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}}{8L}\n$$\n对两边取平方根得到 $\\eta$ 的表达式。我们代回 $L = \\ln(2/\\varepsilon)$：\n$$\n\\eta = \\sqrt{\\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 (\\ln(2/\\varepsilon))^2}{a^4}}}{8 \\ln(2/\\varepsilon)}}\n$$\n这就是最优分裂参数 $\\eta$ 作为容差 $\\varepsilon$、波数 $k$ 和晶格常数 $a$ 的函数的最终解析表达式。",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 \\left(\\ln\\left(\\frac{2}{\\varepsilon}\\right)\\right)^2}{a^4}}}{8 \\ln\\left(\\frac{2}{\\varepsilon}\\right)}}}\n$$"
        },
        {
            "introduction": "在掌握了参数选择的理论基础后，本练习将指导你从零开始完整地实现三维静电问题的埃瓦尔德方法。你不仅要编写代码，还将设计一系列诊断测试来验证其正确性，并探索常见的数值计算挑战，例如截断误差和奇点附近的近场正则化处理。通过这个过程，你将把理论知识转化为稳健、可靠的计算工具。",
            "id": "3340050",
            "problem": "考虑周期为 $L$ 的简单立方晶格在三重周期性边界条件下的三维标量静电格林函数，它代表一个嵌入在均匀中和背景中的单位点源，使得势满足包含周期性镜像的泊松方程，并且在一个晶胞内的空间平均值有限。从控制方程 $\\nabla^2 \\Phi(\\mathbf{r}) = -4\\pi \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3}\\delta\\!\\left(\\mathbf{r} - \\mathbf{n}L\\right) + \\frac{4\\pi}{L^3}$ 出发，其中最后一项通过均匀背景强制实现电荷中性，推导出一个 Ewald 分裂表示，该表示将势分解为一个快速收敛的实空间求和、一个快速收敛的倒易空间求和以及一个背景常数，并使用一个高斯屏蔽参数 $\\alpha  0$。您的推导必须从自由空间格林函数 $G(\\mathbf{r}) = \\frac{1}{4\\pi \\|\\mathbf{r}\\|}$ 的定义、卷积恒等式和泊松求和公式开始，并且必须证明移除零倒易模式和添加背景常数的合理性。不要假设任何 Ewald 求和的教科书公式；相反，应从这些基本原理出发进行推理。\n\n实现目标：设计并实现一个数值稳定的算法，用于在边长为 $L$ 的简单立方晶胞中评估周期性格林函数 $\\Phi(\\mathbf{r})$ 的 Ewald 表示，算法在实空间和倒易空间中均使用有限截断。该算法应：\n- 使用由整数 $N_r$ 指定的实空间截断，对所有整数格矢 $\\mathbf{n} = (n_x,n_y,n_z)$（其中 $n_i \\in \\{-N_r,\\ldots,N_r\\}$）进行求和，并在 $\\mathbf{r} + \\mathbf{n}L$ 处评估屏蔽后的直接项，同时避免在 $\\mathbf{r}=\\mathbf{0}$ 处的奇异自相互作用项。\n- 使用由整数 $N_g$ 指定的倒易空间截断，对所有倒易格矢 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{m}$（其中 $\\mathbf{m} = (m_x,m_y,m_z)$ 且 $m_i \\in \\{-N_g,\\ldots,N_g\\}$）进行求和，排除 $\\mathbf{G}=\\mathbf{0}$，并包含由 $\\alpha$ 决定的高斯衰减因子。\n- 包括由中和背景和排除 $\\mathbf{G}=\\mathbf{0}$ 模式所隐含的均匀背景常数。\n- 返回一个实值势 $\\Phi(\\mathbf{r})$，在大切断极限下，该势与 $\\alpha$ 的选择无关。\n\n关注数值稳定性及实际计算中出现的实现陷阱：\n- 解释 $\\alpha$ 的选择如何调节实空间和倒易空间求和之间的任务分配，以及为什么不当的选择会导致收敛缓慢或因截断或灾难性抵消而导致精度损失。\n- 描述如何处理 $\\|\\mathbf{r}\\|\\to 0$ 时的近场行为，包括减去奇异的自由空间项和解释正则化后的有限极限。\n- 证明移除零倒易模式的合理性，以及在周期性边界条件下为确保物理和数学一致性而必须引入均匀背景。\n- 识别 $\\Phi(\\mathbf{r})$ 的对称性，以及如何利用它们来设计用于实现错误的诊断方法。\n\n本问题中所有量均为无量纲量。如适用，角度以弧度为单位。\n\n测试套件和要求的输出：实现您的算法以计算以下四个诊断值，每个诊断值返回一个浮点数。\n\n情况 A（屏蔽参数无关性）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.31,0.2,0.1\\right)$，$N_r = 4$，$N_g = 4$，使用 $\\alpha_1 = 2.0$ 和 $\\alpha_2 = 4.0$ 计算绝对差 $\\left|\\Phi_{\\alpha_1}(\\mathbf{r}) - \\Phi_{\\alpha_2}(\\mathbf{r})\\right|$。\n\n情况 B（截断敏感性）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.33,0.27,0.41\\right)$，$\\alpha = 3.0$，计算松散截断和严格截断评估之间的绝对差：$\\left|\\Phi^{(N_r=1,N_g=1)}(\\mathbf{r}) - \\Phi^{(N_r=4,N_g=4)}(\\mathbf{r})\\right|$。\n\n情况 C（近场正则化）：设 $L = 1.0$，$\\mathbf{r}_\\varepsilon = \\left(10^{-4},0.0,0.0\\right)$，$\\alpha = 3.5$，$N_r=5$，$N_g=5$，计算正则化值 $\\Phi(\\mathbf{r}_\\varepsilon) - \\frac{1}{\\|\\mathbf{r}_\\varepsilon\\|}$。\n\n情况 D（对称性诊断）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.21,0.37,0.49\\right)$，$\\alpha = 3.0$，$N_r=4$，$N_g=4$，计算 $\\left|\\Phi(\\mathbf{r}) - \\Phi(-\\mathbf{r})\\right|$。\n\n最终程序输出格式：您的程序应生成一行输出，其中包含一个以逗号分隔的列表，用方括号括起来，顺序为 $\\left[\\text{情况 A}, \\text{情况 B}, \\text{情况 C}, \\text{情况 D}\\right]$。例如，一个有效的输出行格式为 $\\left[\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\right]$。",
            "solution": "用户希望推导并实现用于简单立方晶格的三重周期标量静电格林函数的 Ewald 求和方法。该问题定义明确且科学合理，代表了计算物理学中一种标准且基础的技术。\n\n### Ewald 求和公式的推导\n\n目标是计算由位于位置 $\\mathbf{n}L$（$\\mathbf{n} \\in \\mathbb{Z}^3$）的周期性单位点电荷晶格产生的势 $\\Phi(\\mathbf{r})$，该晶格嵌入在均匀中和背景中。其控制方程是泊松方程：\n$$\n\\nabla^2 \\Phi(\\mathbf{r}) = -4\\pi \\rho(\\mathbf{r})\n$$\n其中总电荷密度 $\\rho(\\mathbf{r})$ 包括点电荷和背景电荷：\n$$\n\\rho(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\delta(\\mathbf{r} - \\mathbf{n}L) - \\frac{1}{L^3}\n$$\n形式解是所有镜像电荷势的总和，$\\Phi(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\frac{1}{\\|\\mathbf{r} - \\mathbf{n}L\\|}$，再加上背景项。这个和是条件收敛的，计算上难以实现。Ewald 方法将这个和分解为两个快速收敛的级数：一个在实空间，一个在倒易空间。\n\n核心思想是在每个点电荷上加上和减去一个平滑的高斯电荷分布晶格。我们将点电荷密度 $\\delta(\\mathbf{r})$ 分解为一个短程部分（一个被周围负高斯分布屏蔽的点电荷）和一个长程部分（正高斯分布本身）：\n$$\n\\delta(\\mathbf{r}) = \\underbrace{\\left( \\delta(\\mathbf{r}) - \\rho_G(\\mathbf{r}, \\alpha) \\right)}_{\\text{短程}} + \\underbrace{\\rho_G(\\mathbf{r}, \\alpha)}_{\\text{长程}}\n$$\n其中 $\\rho_G(\\mathbf{r}, \\alpha) = \\frac{\\alpha^3}{\\pi^{3/2}} e^{-\\alpha^2 \\|\\mathbf{r}\\|^2}$ 是一个归一化的高斯电荷分布，其宽度参数 $\\alpha$ 可调。总势 $\\Phi$ 也同样被分解为 $\\Phi = \\Phi_{real} + \\Phi_{recip} + \\Phi_{const}$。\n\n**1. 实空间求和 ($\\Phi_{real}$)**\n\n实空间贡献来自短程电荷密度晶格。单个被高斯分布屏蔽的点电荷的势可以通过求解泊松方程得到，这会产生一个众所周知的结果：\n$$\n\\phi_{screened}(\\mathbf{r}) = \\frac{1}{\\|\\mathbf{r}\\|} - \\int_{\\mathbb{R}^3} \\frac{\\rho_G(\\mathbf{r'})}{\\|\\mathbf{r}-\\mathbf{r'}\\|} d^3\\mathbf{r'} = \\frac{1}{\\|\\mathbf{r}\\|} - \\frac{\\text{erf}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|} = \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|}\n$$\n其中 $\\text{erfc}$ 是互补误差函数。将这个势在整个晶格上求和，得到实空间求和：\n$$\n\\Phi_{real}(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r} - \\mathbf{n}L\\|)}{\\|\\mathbf{r} - \\mathbf{n}L\\|}\n$$\n这个和收敛很快，因为对于大的 $x$，$\\text{erfc}(x)$ 会指数衰减。在实践中，求和被截断到有限数量的格矢，由截断值 $N_r$ 控制。\n\n**2. 倒易空间求和 ($\\Phi_{recip}$)**\n\n倒易空间贡献来自平滑的周期性高斯电荷分布晶格 $\\rho_{long}(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\rho_G(\\mathbf{r} - \\mathbf{n}L, \\alpha)$，以及中和背景。这部分的总电荷密度 $\\rho_{recip}(\\mathbf{r}) = \\rho_{long}(\\mathbf{r}) - 1/L^3$ 是周期性的，且平均电荷为零。因此，我们可以将其展开为关于倒易格矢 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{m}$（$\\mathbf{m} \\in \\mathbb{Z}^3$）的傅里叶级数：\n$$\n\\rho_{recip}(\\mathbf{r}) = \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\hat{\\rho}_{\\mathbf{G}} e^{i\\mathbf{G}\\cdot\\mathbf{r}}\n$$\n傅里叶系数 $\\hat{\\rho}_{\\mathbf{G}}$ 通过在晶胞上积分得到。由于周期性，这等同于单个高斯分布的傅里叶变换，再乘以晶胞体积 $V=L^3$ 的倒数：\n$$\n\\hat{\\rho}_{\\mathbf{G}} = \\frac{1}{L^3} \\int_{\\mathbb{R}^3} \\rho_G(\\mathbf{r}, \\alpha) e^{-i\\mathbf{G}\\cdot\\mathbf{r}} d^3\\mathbf{r} = \\frac{1}{L^3} e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}\n$$\n$\\mathbf{G}=\\mathbf{0}$ 分量为零，因为总平均电荷密度为零。这正是从求和中排除 $\\mathbf{G}=\\mathbf{0}$ 项以及均匀中和背景物理必要性的理由；没有它，势将会发散。\n\n在傅里叶空间中求解泊松方程 $\\nabla^2 \\Phi_{recip} = -4\\pi \\rho_{recip}$ 会得到一个简单的代数关系：$-\\|\\mathbf{G}\\|^2 \\hat{\\Phi}_{\\mathbf{G}} = -4\\pi \\hat{\\rho}_{\\mathbf{G}}$。对于 $\\mathbf{G} \\ne \\mathbf{0}$，我们有：\n$$\n\\hat{\\Phi}_{\\mathbf{G}} = \\frac{4\\pi \\hat{\\rho}_{\\mathbf{G}}}{\\|\\mathbf{G}\\|^2} = \\frac{4\\pi}{L^3 \\|\\mathbf{G}\\|^2} e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}\n$$\n变换回实空间即可得到倒易空间势的和。由于 $\\Phi_{recip}$ 必须是实数且电荷密度是偶函数，使用 $\\cos(\\mathbf{G}\\cdot\\mathbf{r})$ 可以简化求和：\n$$\n\\Phi_{recip}(\\mathbf{r}) = \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\hat{\\Phi}_{\\mathbf{G}} e^{i\\mathbf{G}\\cdot\\mathbf{r}} = \\frac{4\\pi}{L^3} \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\frac{e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}}{\\|\\mathbf{G}\\|^2} \\cos(\\mathbf{G}\\cdot\\mathbf{r})\n$$\n由于高斯指数因子，这个和收敛很快。求和由一个截断值 $N_g$ 截断。\n\n**3. 背景常数 ($\\Phi_{const}$)**\n\n排除 $\\mathbf{G}=\\mathbf{0}$ 模式意味着势的平均值 $\\langle \\Phi \\rangle$ 不是由泊松方程决定的。必须选择一个约定。一个常见且有物理意义的约定是设置整个系统的平均势为零。实空间和倒易空间求和的平均值之和不为零。必须添加一个常数来强制 $\\langle \\Phi \\rangle=0$。根据构造，$\\Phi_{recip}$ 的平均值为零。$\\Phi_{real}$ 的平均值为：\n$$\n\\langle \\Phi_{real} \\rangle = \\frac{1}{L^3} \\int_{cell} \\sum_{\\mathbf{n}} \\frac{\\text{erfc}(\\alpha\\|\\mathbf{r}-\\mathbf{n}L\\|)}{\\|\\mathbf{r}-\\mathbf{n}L\\|} d^3\\mathbf{r} = \\frac{1}{L^3} \\int_{\\mathbb{R}^3} \\frac{\\text{erfc}(\\alpha r)}{r} d^3\\mathbf{r} = \\frac \\pi{\\alpha^2 L^3}\n$$\n为了使总平均势为零，我们必须减去这个值。因此，背景常数为：\n$$\n\\Phi_{const} = -\\frac{\\pi}{\\alpha^2 L^3}\n$$\n\n**最终 Ewald 公式：**\n完整的势是这三部分的总和：\n$$\n\\Phi(\\mathbf{r}) = \\sum_{\\mathbf{n}} \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r} - \\mathbf{n}L\\|)}{\\|\\mathbf{r} - \\mathbf{n}L\\|} + \\frac{4\\pi}{L^3} \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\frac{e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}}{\\|\\mathbf{G}\\|^2} \\cos(\\mathbf{G}\\cdot\\mathbf{r}) - \\frac{\\pi}{\\alpha^2 L^3}\n$$\n\n### 数值实现考量\n\n- **$\\alpha$ 的选择**：Ewald 参数 $\\alpha$ 平衡了实空间和倒易空间求和之间的工作量。大的 $\\alpha$ 使实空间求和收敛快，但倒易空间求和收敛慢。小的 $\\alpha$ 则效果相反。最优的 $\\alpha$ 通过大致均衡两个求和的截断误差来最小化总计算时间。不当的 $\\alpha$ 选择可能导致收敛缓慢，并需要大的截断值（$N_r, N_g$）才能达到给定精度。\n- **近场行为**：当评估点 $\\mathbf{r}$ 接近一个格点（例如原点）时，实空间求和中的 $\\mathbf{n}=\\mathbf{0}$ 项，$\\frac{\\text{erfc}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|}$，变得奇异。对于小的 $\\|\\mathbf{r}\\|$，此项的展开式为 $\\frac{1}{\\|\\mathbf{r}\\|} - \\frac{2\\alpha}{\\sqrt{\\pi}} + O(\\|\\mathbf{r}\\|^2)$。$\\frac{1}{\\|\\mathbf{r}\\|}$ 部分是格林函数预期的奇异性。“正则化”值，$\\lim_{\\|\\mathbf{r}\\|\\to 0} \\left(\\Phi(\\mathbf{r}) - \\frac{1}{\\|\\mathbf{r}\\|}\\right)$，是一个有限常数，代表了在电荷位置处由其所有周期性镜像和背景场产生的势。这个值在情况 C 中计算。\n- **对称性**：源电荷分布 $\\rho(\\mathbf{r})$ 是一个偶函数，$\\rho(\\mathbf{r}) = \\rho(-\\mathbf{r})$。由此产生的势 $\\Phi(\\mathbf{r})$ 也必须是一个偶函数，$\\Phi(\\mathbf{r}) = \\Phi(-\\mathbf{r})$。此属性可作为一个强大的诊断工具。计算出的 $|\\Phi(\\mathbf{r}) - \\Phi(-\\mathbf{r})|$ 值若显著偏离零，则表明可能存在编程错误，例如在处理矢量点积或实现倒易空间求和的三角函数部分时出错。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef compute_phi(r_vec, L, alpha, Nr, Ng):\n    \"\"\"\n    Computes the periodic electrostatic Green function using Ewald summation for a simple cubic lattice.\n\n    This function calculates the potential Phi(r) satisfying the periodic Poisson equation\n    ∇²Φ = -4π Σ_n δ(r - nL) + 4π/L³, which represents a lattice of unit point charges\n    in a uniform neutralizing background.\n\n    Args:\n        r_vec (np.array): Position vector (x, y, z) to evaluate the potential.\n        L (float): Side length of the simple cubic cell.\n        alpha (float): Ewald splitting parameter.\n        Nr (int): Real-space cutoff (sum over n_i in [-Nr, Nr]).\n        Ng (int): Reciprocal-space cutoff (sum over m_i in [-Ng, Ng]).\n\n    Returns:\n        float: The value of the potential Phi(r).\n    \"\"\"\n    r_vec = np.asarray(r_vec, dtype=np.float64)\n    V = L**3\n\n    # Part 1: Real-space sum\n    # This sum is over the short-range part of the potential, which decays rapidly.\n    phi_real = 0.0\n    n_range = range(-Nr, Nr + 1)\n    for nx in n_range:\n        for ny in n_range:\n            for nz in n_range:\n                n_vec = np.array([nx, ny, nz], dtype=np.float64)\n                # The distance between the evaluation point r and the lattice point nL.\n                r_minus_nL = r_vec - n_vec * L\n                d = np.linalg.norm(r_minus_nL)\n                \n                # Avoid division by zero if r is exactly on a lattice point.\n                if d > 1e-14:\n                    phi_real += erfc(alpha * d) / d\n\n    # Part 2: Reciprocal-space sum\n    # This sum is over the long-range, smooth part of the potential.\n    phi_recip = 0.0\n    m_range = range(-Ng, Ng + 1)\n    for mx in m_range:\n        for my in m_range:\n            for mz in m_range:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue  # Exclude the G=0 term, as required for charge neutrality.\n                \n                m_vec = np.array([mx, my, mz], dtype=np.float64)\n                G_vec = (2.0 * np.pi / L) * m_vec\n                G2 = np.dot(G_vec, G_vec)\n                \n                term = np.exp(-G2 / (4.0 * alpha**2)) / G2\n                term *= np.cos(np.dot(G_vec, r_vec))\n                \n                phi_recip += term\n\n    phi_recip *= (4.0 * np.pi / V)\n\n    # Part 3: Background constant term\n    # This constant is added to enforce the convention that the average potential is zero.\n    C_bkg = -np.pi / (alpha**2 * V)\n    \n    return phi_real + phi_recip + C_bkg\n\ndef solve():\n    \"\"\"\n    Calculates and prints the results for the four test cases specified in the problem.\n    \"\"\"\n    # Case A: Screening parameter independence check.\n    # For sufficiently large cutoffs, the result should be nearly independent of alpha.\n    L_A = 1.0\n    r_A = np.array([0.31, 0.2, 0.1])\n    Nr_A, Ng_A = 4, 4\n    alpha1_A, alpha2_A = 2.0, 4.0\n    phi1_A = compute_phi(r_A, L_A, alpha1_A, Nr_A, Ng_A)\n    phi2_A = compute_phi(r_A, L_A, alpha2_A, Nr_A, Ng_A)\n    result_A = np.abs(phi1_A - phi2_A)\n\n    # Case B: Truncation sensitivity check.\n    # Demonstrates that insufficient cutoffs lead to significant error.\n    L_B = 1.0\n    r_B = np.array([0.33, 0.27, 0.41])\n    alpha_B = 3.0\n    phi_loose_B = compute_phi(r_B, L_B, alpha_B, Nr=1, Ng=1)\n    phi_tight_B = compute_phi(r_B, L_B, alpha_B, Nr=4, Ng=4)\n    result_B = np.abs(phi_loose_B - phi_tight_B)\n\n    # Case C: Near-field regularization.\n    # Computes the finite, regularized potential at the location of a source charge.\n    L_C = 1.0\n    r_eps_C_val = 1e-4\n    r_eps_C = np.array([r_eps_C_val, 0.0, 0.0])\n    alpha_C = 3.5\n    Nr_C, Ng_C = 5, 5\n    phi_eps_C = compute_phi(r_eps_C, L_C, alpha_C, Nr_C, Ng_C)\n    result_C = phi_eps_C - 1.0 / r_eps_C_val\n\n    # Case D: Symmetry diagnostic.\n    # Checks if the computed potential satisfies the even symmetry Phi(r) = Phi(-r).\n    L_D = 1.0\n    r_D = np.array([0.21, 0.37, 0.49])\n    alpha_D = 3.0\n    Nr_D, Ng_D = 4, 4\n    phi_r_D = compute_phi(r_D, L_D, alpha_D, Nr_D, Ng_D)\n    phi_neg_r_D = compute_phi(-r_D, L_D, alpha_D, Nr_D, Ng_D)\n    result_D = np.abs(phi_r_D - phi_neg_r_D)\n    \n    results = [result_A, result_B, result_C, result_D]\n    \n    # Print the final output in the required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项练习让我们对倒易空间求和进行更深入的审视。我们将发现，埃瓦尔德方法引入的光滑衰减因子，其本质上是一种“窗函数”，它能有效抑制吉布斯现象——这种伪振荡在傅里叶级数的简单截断中普遍存在。通过将埃瓦尔德高斯锥削与其他标准窗函数进行比较，你将更深刻地理解该方法为何能如此有效地生成精确解。",
            "id": "3340025",
            "problem": "考虑边长为 $2\\pi$ 的二维方形环面上标量拉普拉斯方程的零均值周期格林函数。令 $\\mathbf{x}=(x,y)\\in[0,2\\pi)^2$，并令 $\\mathbf{m}=(m_x,m_y)\\in\\mathbb{Z}^2$。函数 $G(\\mathbf{x})$ 在分布意义上满足 $-\\Delta G(\\mathbf{x}) = 4\\pi^2\\left(\\delta(\\mathbf{x}) - \\frac{1}{(2\\pi)^2}\\right)$，并且其在环面上的平均值为零。通过傅里叶级数，$G(\\mathbf{x})$ 的一个标准表示由以下绝对收敛级数给出\n$$\nG(\\mathbf{x}) \\;=\\; \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} \\frac{e^{i\\mathbf{m}\\cdot \\mathbf{x}}}{\\lVert \\mathbf{m}\\rVert^2},\n$$\n其中 $\\mathbf{m}\\cdot \\mathbf{x} = m_x x + m_y y$ 且 $\\lVert \\mathbf{m}\\rVert^2 = m_x^2 + m_y^2$。该级数在通过限制到有限模式集进行朴素截断时，在奇点 $\\mathbf{x}=\\mathbf{0}$ 附近表现出类似吉布斯振铃的现象。\n\n从环面上的泊松方程和拉普拉斯算子的傅里叶特征对出发，并仅使用以下对正数 $a$ 成立的基本恒等式，\n$$\n\\frac{1}{a} \\;=\\; \\int_{0}^{\\infty} e^{-a t}\\,dt,\n$$\n推导并解释通过在 $t=t_00$ 处分割积分，如何产生倒易空间级数的 Ewald 型分裂。证明这将产生一个形式为 $e^{-t_0 \\lVert \\mathbf{m}\\rVert^2}$ 的因子，乘以截断的倒易和，其中 $t_0$ 通过 $t_0 = \\frac{1}{4\\eta^2}$ 与分裂参数 $\\eta$ 相关联。将其与不施加任何锥削的“矩形”截断进行对比。然后，受谱窗理论的启发，解释并定义至少两种应用于截断倒易和的替代锥削策略，例如 Kaiser–Bessel 窗和升余弦窗，并论证它们对类似吉布斯振铃现象的预期效果。\n\n为进行定量评估，将注意力限制在直线 $y=0$ 上，从而 $\\mathbf{m}\\cdot\\mathbf{x} = m_x x$，并令 $x=r$，其中 $r\\in(0,\\pi]$ 以弧度为单位。对于径向截断参数 $K\\in\\mathbb{N}$ 和支撑在 $\\{\\lVert\\mathbf{m}\\rVert\\le K\\}$ 上的窗/锥削函数 $w(\\lVert\\mathbf{m}\\rVert)$，定义截断和锥削的倒易近似\n$$\nG_{K,w}(r) \\;=\\; \\sum_{\\substack{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}\\\\ \\lVert \\mathbf{m}\\rVert\\le K}} \\frac{w(\\lVert \\mathbf{m}\\rVert)}{\\lVert \\mathbf{m}\\rVert^2} \\cos(m_x r),\n$$\n该式在 $r0$ 时有良好定义。为量化过冲，通过采用一个大得多的径向截止 $K_{\\mathrm{ref}}$ 和一个支撑在 $\\{\\rho\\le K_{\\mathrm{ref}}\\}$ 上的超高斯窗 $w_{\\mathrm{ref}}(\\rho) = \\exp\\!\\left(-(\\rho/K_{\\mathrm{ref}})^4\\right)$ 来定义一个高精度参考 $G_{\\mathrm{ref}}(r)$，并构建\n$$\nG_{\\mathrm{ref}}(r) \\;=\\; \\sum_{\\substack{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}\\\\ \\lVert \\mathbf{m}\\rVert\\le K_{\\mathrm{ref}}}} \\frac{w_{\\mathrm{ref}}(\\lVert \\mathbf{m}\\rVert)}{\\lVert \\mathbf{m}\\rVert^2} \\cos(m_x r).\n$$\n在近场区间 $r\\in[r_{\\min},r_{\\max}]$ 上（其中 $r_{\\min}0$ 较小，$r_{\\max}$ 适中），将一个近似的过冲定义为\n$$\n\\mathcal{O}[G_{K,w}] \\;=\\; \\max_{r\\in\\mathcal{R}} \\max\\!\\left\\{\\,G_{K,w}(r) - G_{\\mathrm{ref}}(r),\\, 0\\,\\right\\},\n$$\n其中 $\\mathcal{R}$ 是一个在 $[r_{\\min},r_{\\max}]$ 上均匀采样的包含 $N_r$ 个半径的离散集合。\n\n您的任务是：\n- 从所述基础出发，推导 Ewald-高斯倒易锥削 $w_{\\mathrm{Ewald}}(\\rho) = \\exp\\!\\left(-\\rho^2/(4\\eta^2)\\right)$（其中分裂参数 $\\eta0$），并解释其在减轻截断倒易和中的振铃现象方面的作用。\n- 定义并论证另外两个锥削函数：一个 Kaiser–Bessel 径向窗 $w_{\\mathrm{Kaiser}}(\\rho) = \\frac{I_0\\!\\left(\\beta \\sqrt{1 - (\\rho/K)^2}\\right)}{I_0(\\beta)}$（对于 $\\rho\\le K$ 成立，否则为 $0$），其中 $I_0$ 是零阶第一类修正贝塞尔函数，$\\beta0$ 是形状参数；以及一个升余弦窗 $w_{\\mathrm{RC}}(\\rho) = \\tfrac{1}{2}\\left(1+\\cos(\\pi \\rho/K)\\right)$（对于 $\\rho\\le K$ 成立，否则为 $0$）。\n- 实现一个程序，构建如上定义的 $G_{K,w}(r)$ 和 $G_{\\mathrm{ref}}(r)$，在离散集合 $\\mathcal{R}$ 上评估过冲 $\\mathcal{O}[G_{K,w}]$，并报告以下测试套件的过冲值。所有角度均以弧度为单位。\n\n测试套件（每个测试指定 $(K, w, \\text{参数})$）：\n1. $(K=\\;10,\\; w=\\;\\text{矩形},\\; \\text{无参数})$，其中 $w(\\rho)=1$ 对 $\\rho\\le K$ 成立，否则为 $0$。\n2. $(K=\\;10,\\; w=\\;\\text{Ewald-高斯},\\; \\eta=\\;2.5)$，其中 $w(\\rho)=\\exp\\!\\left(-\\rho^2/(4\\eta^2)\\right)$ 对 $\\rho\\le K$ 成立。\n3. $(K=\\;10,\\; w=\\;\\text{Kaiser–Bessel},\\; \\beta=\\;8.0)$。\n4. $(K=\\;20,\\; w=\\;\\text{矩形},\\; \\text{无参数})$。\n5. $(K=\\;20,\\; w=\\;\\text{Ewald-高斯},\\; \\eta=\\;3.5)$。\n6. $(K=\\;20,\\; w=\\;\\text{升余弦},\\; \\text{无参数})$。\n\n对参考和采样使用以下固定设置：\n- $K_{\\mathrm{ref}}=\\;70$，\n- $w_{\\mathrm{ref}}(\\rho) = \\exp\\!\\left(-(\\rho/K_{\\mathrm{ref}})^4\\right)$ 对 $\\rho\\le K_{\\mathrm{ref}}$ 成立，否则为 $0$，\n- $r_{\\min}=\\;0.02$， $r_{\\max}=\\;0.40$，以及 $N_r=\\;128$，因此 $\\mathcal{R}$ 是 $[r_{\\min},r_{\\max}]$ 上的包含 $N_r$ 个点的均匀网格。\n\n您的程序应生成单行输出，其中包含测试 1 到 6 的过冲值，格式为一个由方括号括起来、逗号分隔的 Python 浮点数列表。例如，必须打印形如 $[\\text{float}_1,\\text{float}_2,\\text{float}_3,\\text{float}_4,\\text{float}_5,\\text{float}_6]$ 的输出，不得有任何附加文本。所有角度必须始终以弧度处理。除弧度外，不涉及任何物理单位。数值答案必须以纯浮点数形式报告，不带任何百分比符号。",
            "solution": "该问题是有效的，因为它在科学上基于周期格林函数和傅里叶分析理论，问题设定良好，目标明确，且内部一致。\n\n问题的核心是理解并减轻在使用截断傅里叶级数近似奇异函数（拉普拉斯算子的周期格林函数）时出现的吉布斯现象。傅里叶系数的缓慢衰减，$\\mathcal{O}(1/\\lVert \\mathbf{m}\\rVert^2)$，导致在奇点 $\\mathbf{x}=\\mathbf{0}$ 附近产生振荡，即所谓的振铃。该问题探讨了对傅里叶系数进行锥削或加窗以加速收敛并抑制这些振荡的方法。\n\n**Ewald-高斯倒易锥削的推导**\n\n该问题从二维环面上（边长为 $2\\pi$）零均值周期格林函数的傅里叶级数表示开始：\n$$\nG(\\mathbf{x}) \\;=\\; \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} \\frac{e^{i\\mathbf{m}\\cdot \\mathbf{x}}}{\\lVert \\mathbf{m}\\rVert^2}\n$$\nEwald 方法的关键是将缓慢收敛的和式分解为两个快速收敛的部分。根据指令，我们使用对 $a0$ 成立的积分恒等式：\n$$\n\\frac{1}{a} \\;=\\; \\int_{0}^{\\infty} e^{-a t}\\,dt\n$$\n将此应用于级数中的每一项，并令 $a = \\lVert \\mathbf{m}\\rVert^2$，我们得到：\n$$\nG(\\mathbf{x}) \\;=\\; \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} e^{i\\mathbf{m}\\cdot \\mathbf{x}} \\int_{0}^{\\infty} e^{-\\lVert \\mathbf{m}\\rVert^2 t}\\,dt\n$$\n假设一致收敛允许交换求和与积分：\n$$\nG(\\mathbf{x}) \\;=\\; \\int_{0}^{\\infty} \\left( \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} e^{i\\mathbf{m}\\cdot \\mathbf{x}} e^{-\\lVert \\mathbf{m}\\rVert^2 t} \\right) dt\n$$\nEwald 分裂包括在任意分裂参数 $t_0  0$ 处划分积分域：\n$$\nG(\\mathbf{x}) \\;=\\; \\int_{t_0}^{\\infty} \\left(\\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} \\dots \\right) dt \\;+\\; \\int_{0}^{t_0} \\left( \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} \\dots \\right) dt\n$$\n我们来分析第一个积分，从 $t_0$ 到 $\\infty$。我们可以将求和与积分换回来：\n$$\nG_1(\\mathbf{x}) = \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} e^{i\\mathbf{m}\\cdot \\mathbf{x}} \\int_{t_0}^{\\infty} e^{-\\lVert \\mathbf{m}\\rVert^2 t}\\,dt\n$$\n计算该积分得到：\n$$\n\\int_{t_0}^{\\infty} e^{-\\lVert \\mathbf{m}\\rVert^2 t}\\,dt = \\left[ -\\frac{e^{-\\lVert \\mathbf{m}\\rVert^2 t}}{\\lVert \\mathbf{m}\\rVert^2} \\right]_{t_0}^{\\infty} = \\frac{e^{-\\lVert \\mathbf{m}\\rVert^2 t_0}}{\\lVert \\mathbf{m}\\rVert^2}\n$$\n这产生了一个带有高斯锥削的倒易空间求和：\n$$\nG_1(\\mathbf{x}) = \\sum_{\\mathbf{m}\\in\\mathbb{Z}^2\\setminus\\{\\mathbf{0}\\}} \\frac{e^{i\\mathbf{m}\\cdot \\mathbf{x}}}{\\lVert \\mathbf{m}\\rVert^2} e^{-\\lVert \\mathbf{m}\\rVert^2 t_0}\n$$\n因子 $e^{-\\lVert \\mathbf{m}\\rVert^2 t_0}$ 使得当 $\\lVert \\mathbf{m}\\rVert$ 很大时，项呈指数衰减，从而确保了快速收敛。积分的第二部分 $G_2(\\mathbf{x})$ 通常通过泊松求和公式转换为实空间中一个快速收敛的和。完整的 Ewald 方法计算这两个部分。\n\n然而，该问题使用此推导来启发一种针对原始和式的锥削策略。项 $G_1(\\mathbf{x})$ 可以看作是完整格林函数的一个平滑分量。它本身不是完整的解，但其结构表明，将原始傅里叶系数乘以一个高斯函数 $w(\\lVert\\mathbf{m}\\rVert) = e^{-\\lVert\\mathbf{m}\\rVert^2 t_0}$ 是一种有物理动机的方法，可以创建一个平滑且快速收敛的近似。通过标准的 Ewald 参数化，即通过 $t_0 = \\frac{1}{4\\eta^2}$ 将 $t_0$ 与实空间宽度参数 $\\eta$ 相关联，我们得到 Ewald-高斯锥削：\n$$\nw_{\\mathrm{Ewald}}(\\rho) = \\exp\\!\\left(-\\frac{\\rho^2}{4\\eta^2}\\right)\n$$\n其中 $\\rho = \\lVert \\mathbf{m} \\rVert$。这与矩形（或“boxcar”）截断形成鲜明对比，后者的窗函数为：当 $\\rho \\le K$ 时 $w(\\rho)=1$，当 $\\rho  K$ 时 $w(\\rho)=0$。矩形窗在频域中的急剧不连续性正是导致空间域中吉布斯现象（振铃）的原因。高斯锥削的平滑衰减避免了这种急剧的截止，从而抑制了振铃并提供了一个更平滑的近似，尽管中心峰会有些展宽。\n\n**源于谱窗理论的替代锥削策略**\n\n平滑傅里叶级数截断的思想是谱分析和数字信号处理理论的核心。许多窗函数就是为此目的而开发的。\n\n1.  **Kaiser–Bessel 窗**:\n    Kaiser–Bessel 窗定义为：\n    $$\n    w_{\\mathrm{Kaiser}}(\\rho) = \\frac{I_0\\!\\left(\\beta \\sqrt{1 - (\\rho/K)^2}\\right)}{I_0(\\beta)} \\quad \\text{对于 } \\rho \\le K, \\text{ 否则为 } 0。\n    $$\n    这里，$I_0$ 是零阶第一类修正贝塞尔函数，$K$ 是径向截断参数，$\\beta$ 是形状参数。该窗是对零阶离散扁长球体序列（DPSS）的近乎最优的近似，后者在给定频谱带宽内具有最大可能的能量集中度。参数 $\\beta$ 控制窗函数傅里叶变换中主瓣宽度和旁瓣衰减之间的权衡。更大的 $\\beta$ 会导致更低的旁瓣（更少的振铃），但代价是主瓣更宽（特征更模糊）。其合理性在于，对于给定的主瓣宽度，它能提供出色的旁瓣抑制，因此在减少吉布斯振铃伪影方面非常有效。\n\n2.  **升余弦窗**:\n    升余弦窗定义为：\n    $$\n    w_{\\mathrm{RC}}(\\rho) = \\frac{1}{2}\\left(1+\\cos\\left(\\frac{\\pi \\rho}{K}\\right)\\right) \\quad \\text{对于 } \\rho \\le K, \\text{ 否则为 } 0。\n    $$\n    该窗是汉宁窗在径向坐标上的推广形式，它提供了一个从中心（$\\rho=0$）的 $1$ 到截止边界（$\\rho=K$）的 $0$ 的平滑锥削。与矩形窗相比，它计算简单，在减少频谱泄漏方面非常有效。其傅里叶变换具有显著更低的旁瓣，这转化为吉布斯振铃的急剧减少。虽然它不像 Kaiser–Bessel 窗那样可调或最优，但其性能相比简单截断有显著提升，是一种稳健且常见的选择。\n\n这两种替代窗函数，与 Ewald-高斯锥削一样，都是通过在截断边界处将傅里叶系数平滑地降至零来起作用，从而防止了导致振铃的急剧截止。它们的合理性基于傅里叶分析的基本原理：一个域中的平滑性对应于变换域中的衰减性。\n\n**定量评估**\n\n该问题通过将锥削、截断的近似 $G_{K,w}(r)$ 与高精度参考解 $G_{\\mathrm{ref}}(r)$ 进行比较，定义了一个振铃的定量度量——过冲 $\\mathcal{O}[G_{K,w}]$。以下程序为指定的测试套件实现了此评估。它首先生成所有必要的整数模式 $(m_x, m_y)$，然后一次性计算高精度参考和，最后遍历所有测试用例，计算每个近似及其对应的过冲。使用向量化的 `NumPy` 操作对于高效计算格点和至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Derives and evaluates overshoot for different windowed approximations of a\n    periodic Green's function.\n    \"\"\"\n    # Fixed settings for reference calculation and sampling\n    K_ref = 70.0\n    r_min = 0.02\n    r_max = 0.40\n    N_r = 128\n    \n    # Test suite: (K, window_type, parameters_dict)\n    test_cases = [\n        (10.0, 'rectangular', {}),\n        (10.0, 'ewald_gaussian', {'eta': 2.5}),\n        (10.0, 'kaiser_bessel', {'beta': 8.0}),\n        (20.0, 'rectangular', {}),\n        (20.0, 'ewald_gaussian', {'eta': 3.5}),\n        (20.0, 'raised_cosine', {}),\n    ]\n\n    # Generate the grid of radii for evaluation\n    r_grid = np.linspace(r_min, r_max, N_r)\n\n    # Generate the master list of modes (mx, my, norm, norm^2) up to K_ref\n    # This is the most computationally intensive part if done naively.\n    # We iterate over a square and filter by radius.\n    K_max_int = int(np.floor(K_ref))\n    modes = []\n    for mx in range(-K_max_int, K_max_int + 1):\n        my_max_int = int(np.floor(np.sqrt(K_ref**2 - mx**2)))\n        for my in range(-my_max_int, my_max_int + 1):\n            if mx == 0 and my == 0:\n                continue\n            norm_sq = float(mx**2 + my**2)\n            # The loop bounds ensure norm = K_ref\n            modes.append((mx, my, np.sqrt(norm_sq), norm_sq))\n    \n    # Unpack modes into numpy arrays for vectorized operations\n    modes_arr = np.array(modes, dtype=np.float64)\n    all_mx = modes_arr[:, 0]\n    all_norm = modes_arr[:, 2]\n    all_norm2 = modes_arr[:, 3]\n\n    # --- Compute the high-accuracy reference function G_ref ---\n    \n    # Filter modes for the reference calculation\n    ref_indices = all_norm = K_ref\n    ref_mx = all_mx[ref_indices]\n    ref_norm = all_norm[ref_indices]\n    ref_norm2 = all_norm2[ref_indices]\n    \n    # Reference window function\n    w_ref = np.exp(-(ref_norm / K_ref)**4)\n    \n    # Calculate terms for the reference sum\n    terms_ref = w_ref / ref_norm2\n    \n    # Compute G_ref(r) for all r in r_grid using matrix multiplication\n    # cos_vals_ref is a (num_modes x N_r) matrix\n    cos_vals_ref = np.cos(np.outer(ref_mx, r_grid))\n    # G_ref is the dot product of terms with each column of cos_vals_ref\n    G_ref = terms_ref @ cos_vals_ref\n\n    # --- Process each test case ---\n    results = []\n    for K, window_type, params in test_cases:\n        \n        # Filter modes for the current approximation\n        approx_indices = all_norm = K\n        approx_mx = all_mx[approx_indices]\n        approx_norm = all_norm[approx_indices]\n        approx_norm2 = all_norm2[approx_indices]\n\n        # Define and apply the window function for the current case\n        if window_type == 'rectangular':\n            w_approx = np.ones_like(approx_norm)\n        elif window_type == 'ewald_gaussian':\n            eta = params['eta']\n            w_approx = np.exp(-approx_norm**2 / (4 * eta**2))\n        elif window_type == 'kaiser_bessel':\n            beta = params['beta']\n            # Avoid division by zero or sqrt of negative if rho > K (though filtered)\n            rho_over_K = approx_norm / K\n            arg = beta * np.sqrt(np.maximum(0, 1 - rho_over_K**2))\n            w_approx = i0(arg) / i0(beta)\n        elif window_type == 'raised_cosine':\n            w_approx = 0.5 * (1 + np.cos(np.pi * approx_norm / K))\n        else:\n            raise ValueError(f\"Unknown window type: {window_type}\")\n\n        # Calculate terms for the approximation sum\n        terms_approx = w_approx / approx_norm2\n        \n        # Compute G_approx(r) for all r in r_grid\n        cos_vals_approx = np.cos(np.outer(approx_mx, r_grid))\n        G_approx = terms_approx @ cos_vals_approx\n        \n        # Calculate the overshoot\n        difference = G_approx - G_ref\n        overshoot = np.max(np.maximum(difference, 0))\n        results.append(overshoot)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}