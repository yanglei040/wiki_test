{
    "hands_on_practices": [
        {
            "introduction": "掌握 Ewald 求和法的第一步是从基本原理出发，进行一次亲手实践。这项练习将指导您从头推导三维静电 Ewald 求和公式，并构建一个数值稳定的算法。通过这个过程，您将直面并解决一些关键的实际问题，例如如何处理源点的奇异性，以及如何确保计算结果与非物理的分割参数 $\\alpha$ 无关，从而为更复杂的应用打下坚实的基础 。",
            "id": "3340050",
            "problem": "考虑在周期为 $L$ 的简单立方晶格的三重周期性边界条件下，三维标量静电格林函数。该函数代表一个嵌入在均匀中和背景中的单位点源，因此电势满足包含周期性镜像的拉普拉斯方程，并且在单位晶胞上的空间平均值有限。从控制方程 $\\nabla^2 \\Phi(\\mathbf{r}) = -4\\pi \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3}\\delta\\!\\left(\\mathbf{r} - \\mathbf{n}L\\right) + \\frac{4\\pi}{L^3}$ 出发，其中最后一项通过均匀背景强制实现电荷中性，推导一个 Ewald 分裂表示，该表示将电势分解为一个快速收敛的实空间求和、一个快速收敛的倒易空间求和以及一个背景常数，其中高斯屏蔽参数为 $\\alpha  0$。您的推导必须从自由空间格林函数的定义 $G(\\mathbf{r}) = \\frac{1}{4\\pi \\|\\mathbf{r}\\|}$、卷积恒等式以及泊松求和公式开始，并且必须证明移除零倒易模态和添加背景常数的合理性。不要假设任何关于 Ewald 求和的教科书公式；相反，应从这些基本原理出发进行推导。\n\n实现目标：设计并实现一个数值稳定的算法，以评估在边长为 $L$ 的简单立方晶胞中周期性格林函数 $\\Phi(\\mathbf{r})$ 的 Ewald 表示，该算法在实空间和倒易空间中均使用有限截断。该算法应：\n- 使用由整数 $N_r$ 指定的实空间截断，对所有整数晶格矢量 $\\mathbf{n} = (n_x,n_y,n_z)$（其中 $n_i \\in \\{-N_r,\\ldots,N_r\\}$）进行求和，并在 $\\mathbf{r} + \\mathbf{n}L$ 处评估被屏蔽的直接项，同时避免在 $\\mathbf{r}=\\mathbf{0}$ 处的奇异自作用项。\n- 使用由整数 $N_g$ 指定的倒易空间截断，对所有倒易晶格矢量 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{m}$（其中 $\\mathbf{m} = (m_x,m_y,m_z)$ 且 $m_i \\in \\{-N_g,\\ldots,N_g\\}$）进行求和，排除 $\\mathbf{G}=\\mathbf{0}$，并包括由 $\\alpha$ 决定的高斯衰减因子。\n- 包括由中和背景和排除 $\\mathbf{G}=\\mathbf{0}$ 模态所隐含的均匀背景常数。\n- 返回一个实值电势 $\\Phi(\\mathbf{r})$，该电势在大切断极限下与 $\\alpha$ 的选择无关。\n\n关注数值稳定性和实际计算中出现的实现陷阱：\n- 解释 $\\alpha$ 的选择如何调节实空间和倒易空间求和之间的工作分配，以及为什么不佳的选择会导致收敛缓慢或因截断或灾难性抵消而导致精度损失。\n- 描述如何处理 $\\|\\mathbf{r}\\|\\to 0$ 时的近场行为，包括减去奇异的自由空间项和对有限正则化极限的解释。\n- 证明移除零倒易模态的合理性以及在周期性边界条件下为确保物理和数学一致性而必须引入均匀背景。\n- 识别 $\\Phi(\\mathbf{r})$ 的对称性质，以及如何利用它们来设计用于实现错误的诊断方法。\n\n此问题中的所有量均为无量纲。角度（如适用）以弧度为单位。\n\n测试套件和要求输出：实现您的算法以计算以下四个诊断值，每个诊断值返回一个浮点数值。\n\n案例 A（屏蔽参数无关性）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.31,0.2,0.1\\right)$，$N_r = 4$，$N_g = 4$，计算使用 $\\alpha_1 = 2.0$ 和 $\\alpha_2 = 4.0$ 时的绝对差 $\\left|\\Phi_{\\alpha_1}(\\mathbf{r}) - \\Phi_{\\alpha_2}(\\mathbf{r})\\right|$。\n\n案例 B（截断敏感性）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.33,0.27,0.41\\right)$，$\\alpha = 3.0$，计算松散截断和严格截断评估之间的绝对差：$\\left|\\Phi^{(N_r=1,N_g=1)}(\\mathbf{r}) - \\Phi^{(N_r=4,N_g=4)}(\\mathbf{r})\\right|$。\n\n案例 C（近场正则化）：设 $L = 1.0$，$\\mathbf{r}_\\varepsilon = \\left(10^{-4},0.0,0.0\\right)$，$\\alpha = 3.5$，$N_r=5$，$N_g=5$，计算正则化值 $\\Phi(\\mathbf{r}_\\varepsilon) - \\frac{1}{\\|\\mathbf{r}_\\varepsilon\\|}$。\n\n案例 D（对称性诊断）：设 $L = 1.0$，$\\mathbf{r} = \\left(0.21,0.37,0.49\\right)$，$\\alpha = 3.0$，$N_r=4$，$N_g=4$，计算 $\\left|\\Phi(\\mathbf{r}) - \\Phi(-\\mathbf{r})\\right|$。\n\n最终程序输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，按顺序为 $\\left[\\text{案例 A}, \\text{案例 B}, \\text{案例 C}, \\text{案例 D}\\right]$。例如，一个有效的输出行格式为 $\\left[\\text{resultA},\\text{resultB},\\text{resultC},\\text{resultD}\\right]$。",
            "solution": "用户希望为简单立方晶格的三重周期性标量静电格林函数推导并实现 Ewald 求和方法。该问题定义明确且科学合理，代表了计算物理学中一种标准且基础的技术。\n\n### Ewald 求和公式的推导\n\n目标是计算由位于位置 $\\mathbf{n}L$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）的单位点电荷周期性晶格在均匀中和背景下产生的电势 $\\Phi(\\mathbf{r})$。控制方程是泊松方程：\n$$\n\\nabla^2 \\Phi(\\mathbf{r}) = -4\\pi \\rho(\\mathbf{r})\n$$\n其中总电荷密度 $\\rho(\\mathbf{r})$ 包括点电荷和背景：\n$$\n\\rho(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\delta(\\mathbf{r} - \\mathbf{n}L) - \\frac{1}{L^3}\n$$\n形式解是所有镜像电荷电势的总和，$\\Phi(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\frac{1}{\\|\\mathbf{r} - \\mathbf{n}L\\|}$，再加上背景项。这个求和是条件收敛的，且计算量巨大。Ewald 方法将此求和分解为两个快速收敛的级数：一个在实空间，一个在倒易空间。\n\n核心思想是在每个点电荷上加上再减去一个光滑的高斯电荷分布晶格。我们将点电荷密度 $\\delta(\\mathbf{r})$ 分解为一个短程部分（一个被周围负高斯电荷屏蔽的点电荷）和一个长程部分（正高斯电荷本身）：\n$$\n\\delta(\\mathbf{r}) = \\underbrace{\\left( \\delta(\\mathbf{r}) - \\rho_G(\\mathbf{r}, \\alpha) \\right)}_{\\text{短程}} + \\underbrace{\\rho_G(\\mathbf{r}, \\alpha)}_{\\text{长程}}\n$$\n其中 $\\rho_G(\\mathbf{r}, \\alpha) = \\frac{\\alpha^3}{\\pi^{3/2}} e^{-\\alpha^2 \\|\\mathbf{r}\\|^2}$ 是一个归一化的高斯电荷分布，具有可调的宽度参数 $\\alpha$。总电势 $\\Phi$ 同样被分解为 $\\Phi = \\Phi_{real} + \\Phi_{recip} + \\Phi_{const}$。\n\n**1. 实空间求和 ($\\Phi_{real}$)**\n\n实空间贡献来自短程电荷密度的晶格。单个被高斯电荷屏蔽的点电荷的电势可以通过求解泊松方程得到，这会产生众所周知的结果：\n$$\n\\phi_{screened}(\\mathbf{r}) = \\frac{1}{\\|\\mathbf{r}\\|} - \\int_{\\mathbb{R}^3} \\frac{\\rho_G(\\mathbf{r'})}{\\|\\mathbf{r}-\\mathbf{r'}\\|} d^3\\mathbf{r'} = \\frac{1}{\\|\\mathbf{r}\\|} - \\frac{\\text{erf}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|} = \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|}\n$$\n其中 $\\text{erfc}$ 是互补误差函数。将这个电势在整个晶格上求和，得到实空间求和：\n$$\n\\Phi_{real}(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r} - \\mathbf{n}L\\|)}{\\|\\mathbf{r} - \\mathbf{n}L\\|}\n$$\n这个和收敛很快，因为 $\\text{erfc}(x)$ 在 $x$ 很大时呈指数衰减。在实践中，求和被截断为有限数量的晶格矢量，由截断半径 $N_r$ 控制。\n\n**2. 倒易空间求和 ($\\Phi_{recip}$)**\n\n倒易空间贡献来自光滑、周期性的高斯电荷分布晶格，$\\rho_{long}(\\mathbf{r}) = \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\rho_G(\\mathbf{r} - \\mathbf{n}L, \\alpha)$，以及中和背景。这部分的总电荷密度 $\\rho_{recip}(\\mathbf{r}) = \\rho_{long}(\\mathbf{r}) - 1/L^3$ 是周期性的，且平均电荷为零。因此，我们可以将其展开为关于倒易晶格矢量 $\\mathbf{G} = \\frac{2\\pi}{L}\\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^3$）的傅里叶级数：\n$$\n\\rho_{recip}(\\mathbf{r}) = \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\hat{\\rho}_{\\mathbf{G}} e^{i\\mathbf{G}\\cdot\\mathbf{r}}\n$$\n傅里叶系数 $\\hat{\\rho}_{\\mathbf{G}}$ 通过在单位晶胞上积分得到。由于周期性，这等效于单个高斯函数的傅里叶变换，并按晶胞体积 $V=L^3$ 进行缩放：\n$$\n\\hat{\\rho}_{\\mathbf{G}} = \\frac{1}{L^3} \\int_{\\mathbb{R}^3} \\rho_G(\\mathbf{r}, \\alpha) e^{-i\\mathbf{G}\\cdot\\mathbf{r}} d^3\\mathbf{r} = \\frac{1}{L^3} e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}\n$$\n$\\mathbf{G}=\\mathbf{0}$ 分量为零，因为总平均电荷密度为零。这正是从求和中排除 $\\mathbf{G}=\\mathbf{0}$ 项以及物理上需要中和背景的理由；没有它，电势将会发散。\n\n在傅里叶空间中求解泊松方程 $\\nabla^2 \\Phi_{recip} = -4\\pi \\rho_{recip}$ 会得到一个简单的代数关系：$-\\|\\mathbf{G}\\|^2 \\hat{\\Phi}_{\\mathbf{G}} = -4\\pi \\hat{\\rho}_{\\mathbf{G}}$。对于 $\\mathbf{G} \\ne \\mathbf{0}$，我们有：\n$$\n\\hat{\\Phi}_{\\mathbf{G}} = \\frac{4\\pi \\hat{\\rho}_{\\mathbf{G}}}{\\|\\mathbf{G}\\|^2} = \\frac{4\\pi}{L^3 \\|\\mathbf{G}\\|^2} e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}\n$$\n变换回实空间得到倒易空间电势求和。由于 $\\Phi_{recip}$ 必须是实数且电荷密度是偶函数，使用 $\\cos(\\mathbf{G}\\cdot\\mathbf{r})$ 可以简化求和：\n$$\n\\Phi_{recip}(\\mathbf{r}) = \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\hat{\\Phi}_{\\mathbf{G}} e^{i\\mathbf{G}\\cdot\\mathbf{r}} = \\frac{4\\pi}{L^3} \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\frac{e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}}{\\|\\mathbf{G}\\|^2} \\cos(\\mathbf{G}\\cdot\\mathbf{r})\n$$\n由于高斯指数因子，这个求和收敛很快。求和由截断半径 $N_g$ 截断。\n\n**3. 背景常数 ($\\Phi_{const}$)**\n\n排除 $\\mathbf{G}=\\mathbf{0}$ 模态意味着电势的平均值 $\\langle \\Phi \\rangle$ 并非由泊松方程确定。必须选择一个约定。一个常见且具有物理意义的约定是设置整个系统的平均电势为零。实空间和倒易空间求和的组合平均值不为零。必须添加一个常数以强制 $\\langle \\Phi \\rangle=0$。根据构造，$\\Phi_{recip}$ 的平均值为零。$\\Phi_{real}$ 的平均值为：\n$$\n\\langle \\Phi_{real} \\rangle = \\frac{1}{L^3} \\int_{cell} \\sum_{\\mathbf{n}} \\frac{\\text{erfc}(\\alpha\\|\\mathbf{r}-\\mathbf{n}L\\|)}{\\|\\mathbf{r}-\\mathbf{n}L\\|} d^3\\mathbf{r} = \\frac{1}{L^3} \\int_{\\mathbb{R}^3} \\frac{\\text{erfc}(\\alpha r)}{r} d^3\\mathbf{r} = \\frac \\pi{\\alpha^2 L^3}\n$$\n为了使总平均电势为零，我们必须减去这个值。因此，背景常数为：\n$$\n\\Phi_{const} = -\\frac{\\pi}{\\alpha^2 L^3}\n$$\n\n**最终 Ewald 公式：**\n完整的电势是这三部分的总和：\n$$\n\\Phi(\\mathbf{r}) = \\sum_{\\mathbf{n}} \\frac{\\text{erfc}(\\alpha \\|\\mathbf{r} - \\mathbf{n}L\\|)}{\\|\\mathbf{r} - \\mathbf{n}L\\|} + \\frac{4\\pi}{L^3} \\sum_{\\mathbf{G}\\neq\\mathbf{0}} \\frac{e^{-\\|\\mathbf{G}\\|^2/(4\\alpha^2)}}{\\|\\mathbf{G}\\|^2} \\cos(\\mathbf{G}\\cdot\\mathbf{r}) - \\frac{\\pi}{\\alpha^2 L^3}\n$$\n\n### 数值实现注意事项\n\n- **$\\alpha$ 的选择**：Ewald 参数 $\\alpha$ 平衡了实空间和倒易空间求和之间的计算工作量。大的 $\\alpha$ 使实空间求和收敛快，但倒易空间求和收敛慢。小的 $\\alpha$ 则效果相反。最优的 $\\alpha$ 通过大致均衡两个求和的截断误差来最小化总计算时间。不佳的 $\\alpha$ 选择会导致收敛缓慢，并需要大的截断半径 ($N_r, N_g$) 才能达到给定精度。\n- **近场行为**：当评估点 $\\mathbf{r}$ 接近晶格点（例如原点）时，实空间求和中的 $\\mathbf{n}=\\mathbf{0}$ 项 $\\frac{\\text{erfc}(\\alpha \\|\\mathbf{r}\\|)}{\\|\\mathbf{r}\\|}$ 变得奇异。对于小的 $\\|\\mathbf{r}\\|$，该项的展开式为 $\\frac{1}{\\|\\mathbf{r}\\|} - \\frac{2\\alpha}{\\sqrt{\\pi}} + O(\\|\\mathbf{r}\\|^2)$。$\\frac{1}{\\|\\mathbf{r}\\|}$ 部分是格林函数预期的奇异性。“正则化”值 $\\lim_{\\|\\mathbf{r}\\|\\to 0} \\left(\\Phi(\\mathbf{r}) - \\frac{1}{\\|\\mathbf{r}\\|}\\right)$ 是一个有限常数，表示位于一个电荷位置上由其所有周期性镜像和背景场产生的电势。这个值在案例 C 中计算。\n- **对称性**：源电荷分布 $\\rho(\\mathbf{r})$ 是一个偶函数，$\\rho(\\mathbf{r}) = \\rho(-\\mathbf{r})$。由此产生的电势 $\\Phi(\\mathbf{r})$也必须是一个偶函数，$\\Phi(\\mathbf{r}) = \\Phi(-\\mathbf{r})$。这个性质是一个强大的诊断工具。计算出的 $|\\Phi(\\mathbf{r}) - \\Phi(-\\mathbf{r})|$ 值若显著偏离零，则表明可能存在编程错误，例如在处理矢量点积或实现倒易空间求和的三角函数部分时出错。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef compute_phi(r_vec, L, alpha, Nr, Ng):\n    \"\"\"\n    Computes the periodic electrostatic Green function using Ewald summation for a simple cubic lattice.\n\n    This function calculates the potential Phi(r) satisfying the periodic Poisson equation\n    ∇²Φ = -4π Σ_n δ(r - nL) + 4π/L³, which represents a lattice of unit point charges\n    in a uniform neutralizing background.\n\n    Args:\n        r_vec (np.array): Position vector (x, y, z) to evaluate the potential.\n        L (float): Side length of the simple cubic cell.\n        alpha (float): Ewald splitting parameter.\n        Nr (int): Real-space cutoff (sum over n_i in [-Nr, Nr]).\n        Ng (int): Reciprocal-space cutoff (sum over m_i in [-Ng, Ng]).\n\n    Returns:\n        float: The value of the potential Phi(r).\n    \"\"\"\n    r_vec = np.asarray(r_vec, dtype=np.float64)\n    V = L**3\n\n    # Part 1: Real-space sum\n    # This sum is over the short-range part of the potential, which decays rapidly.\n    phi_real = 0.0\n    n_range = range(-Nr, Nr + 1)\n    for nx in n_range:\n        for ny in n_range:\n            for nz in n_range:\n                n_vec = np.array([nx, ny, nz], dtype=np.float64)\n                # The distance between the evaluation point r and the lattice point nL.\n                r_minus_nL = r_vec - n_vec * L\n                d = np.linalg.norm(r_minus_nL)\n                \n                # Avoid division by zero if r is exactly on a lattice point.\n                if d  1e-14:\n                    phi_real += erfc(alpha * d) / d\n\n    # Part 2: Reciprocal-space sum\n    # This sum is over the long-range, smooth part of the potential.\n    phi_recip = 0.0\n    m_range = range(-Ng, Ng + 1)\n    for mx in m_range:\n        for my in m_range:\n            for mz in m_range:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue  # Exclude the G=0 term, as required for charge neutrality.\n                \n                m_vec = np.array([mx, my, mz], dtype=np.float64)\n                G_vec = (2.0 * np.pi / L) * m_vec\n                G2 = np.dot(G_vec, G_vec)\n                \n                term = np.exp(-G2 / (4.0 * alpha**2)) / G2\n                term *= np.cos(np.dot(G_vec, r_vec))\n                \n                phi_recip += term\n\n    phi_recip *= (4.0 * np.pi / V)\n\n    # Part 3: Background constant term\n    # This constant is added to enforce the convention that the average potential is zero.\n    C_bkg = -np.pi / (alpha**2 * V)\n    \n    return phi_real + phi_recip + C_bkg\n\ndef solve():\n    \"\"\"\n    Calculates and prints the results for the four test cases specified in the problem.\n    \"\"\"\n    # Case A: Screening parameter independence check.\n    # For sufficiently large cutoffs, the result should be nearly independent of alpha.\n    L_A = 1.0\n    r_A = np.array([0.31, 0.2, 0.1])\n    Nr_A, Ng_A = 4, 4\n    alpha1_A, alpha2_A = 2.0, 4.0\n    phi1_A = compute_phi(r_A, L_A, alpha1_A, Nr_A, Ng_A)\n    phi2_A = compute_phi(r_A, L_A, alpha2_A, Nr_A, Ng_A)\n    result_A = np.abs(phi1_A - phi2_A)\n\n    # Case B: Truncation sensitivity check.\n    # Demonstrates that insufficient cutoffs lead to significant error.\n    L_B = 1.0\n    r_B = np.array([0.33, 0.27, 0.41])\n    alpha_B = 3.0\n    phi_loose_B = compute_phi(r_B, L_B, alpha_B, Nr=1, Ng=1)\n    phi_tight_B = compute_phi(r_B, L_B, alpha_B, Nr=4, Ng=4)\n    result_B = np.abs(phi_loose_B - phi_tight_B)\n\n    # Case C: Near-field regularization.\n    # Computes the finite, regularized potential at the location of a source charge.\n    L_C = 1.0\n    r_eps_C_val = 1e-4\n    r_eps_C = np.array([r_eps_C_val, 0.0, 0.0])\n    alpha_C = 3.5\n    Nr_C, Ng_C = 5, 5\n    phi_eps_C = compute_phi(r_eps_C, L_C, alpha_C, Nr_C, Ng_C)\n    result_C = phi_eps_C - 1.0 / r_eps_C_val\n\n    # Case D: Symmetry diagnostic.\n    # Checks if the computed potential satisfies the even symmetry Phi(r) = Phi(-r).\n    L_D = 1.0\n    r_D = np.array([0.21, 0.37, 0.49])\n    alpha_D = 3.0\n    Nr_D, Ng_D = 4, 4\n    phi_r_D = compute_phi(r_D, L_D, alpha_D, Nr_D, Ng_D)\n    phi_neg_r_D = compute_phi(-r_D, L_D, alpha_D, Nr_D, Ng_D)\n    result_D = np.abs(phi_r_D - phi_neg_r_D)\n    \n    results = [result_A, result_B, result_C, result_D]\n    \n    # Print the final output in the required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在成功构建 Ewald 求和的实现之后，下一个关键技能是优化其计算性能。Ewald 方法的效率很大程度上取决于分割参数 $\\eta$ 的选择，因为它直接决定了实空间和倒易空间两个级数的收敛速度。这项练习提供了一个理论框架，旨在通过平衡两个求和的计算成本来推导出最优的 $\\eta$ 值，这是在实际应用中高效使用 Ewald 方法的核心考量 。",
            "id": "3340042",
            "problem": "考虑一个标量三维亥姆霍兹方程，用于描述自由空间波数为 $k$ 的时谐场，以及在晶格常数为 $a$ 的简单立方布拉维晶格上的相关周期格林函数。自由空间格林函数为 $G_{0}(\\mathbf{r})=\\exp(\\mathrm{i} k r)/(4\\pi r)$，其中 $r=|\\mathbf{r}|$。在埃瓦尔德方法中，引入一个分裂参数为 $\\eta0$ 的高斯屏蔽，将周期格林函数写成一个快速衰减的实空间晶格求和与一个快速衰减的倒易空间晶格求和之和。实空间求和在半径 $R_{c}$ 处截断，倒易空间求和在波数半径 $G_{c}$ 处截断。假设波长和晶格尺度满足 $k a  2\\pi$，因此倒易空间尾部在最低倒易壳层中被埃瓦尔德高斯项指数级抑制。\n\n对于大自变量，互补误差函数和高斯屏蔽意味着主阶截断误差由指数项主导（忽略代数前因子）：实空间截断误差以 $\\exp\\!\\left(-(\\eta R_{c})^{2}\\right)$ 的形式衰减，而倒易空间截断误差以 $\\exp\\!\\left(-\\left(G_{c}^{2}-k^{2}\\right)/(4\\eta^{2})\\right)$ 的形式衰减。给定埃瓦尔德求和的周期格林函数的总截断误差的目标绝对容差为 $\\varepsilon\\in(0,1)$。\n\n假设将误差预算均等地分配给这两个求和，使得每个截断误差通过其主导指数项被控制在大约 $\\varepsilon/2$ 的水平。这导出了以下关系：\n$$\n(\\eta R_{c})^{2}=\\ln\\!\\left(\\frac{2}{\\varepsilon}\\right),\\qquad \\frac{G_{c}^{2}-k^{2}}{4\\eta^{2}}=\\ln\\!\\left(\\frac{2}{\\varepsilon}\\right).\n$$\n对于晶格常数为 $a$ 的简单立方晶格，通过连续介质计数来估计保留的实空间项和倒易空间项的数量：\n$$\nN_{r}\\approx \\frac{4\\pi R_{c}^{3}}{3 a^{3}},\\qquad N_{k}\\approx \\frac{V}{(2\\pi)^{3}}\\cdot \\frac{4\\pi G_{c}^{3}}{3},\\quad V=a^{3}.\n$$\n选择埃瓦尔德分裂参数 $\\eta$，通过施加条件 $N_{r}\\approx N_{k}$ 来平衡两个求和之间的计算工作量，同时通过上述指数控制满足目标容差。推导最优分裂参数 $\\eta$ 的解析近似，作为 $\\varepsilon$、$k$ 和 $a$ 的闭式函数。将最终答案表示为 $\\eta(\\varepsilon,k,a)$ 的单一解析表达式。无需进行数值计算，最终表达式中不应包含单位。",
            "solution": "该问题要求推导一个最优埃瓦尔德分裂参数 $\\eta$，该参数在达到指定的误差容差 $\\varepsilon$ 的同时，平衡实空间和倒易空间求和之间的计算工作量。计算工作量由每个求和中的项数 $N_r$ 和 $N_k$ 来估计。优化准则是设置 $N_r \\approx N_k$。\n\n首先，我们将给定的关系式化。定义量 $L$ 为 $L = \\ln(2/\\varepsilon)$。控制误差容差的两个方程如下：\n$$\n(\\eta R_{c})^{2} = L \\quad (1)\n$$\n$$\n\\frac{G_{c}^{2}-k^{2}}{4\\eta^{2}} = L \\quad (2)\n$$\n其中 $R_c$ 和 $G_c$ 分别是实空间和倒易空间的截断半径，$k$ 是自由空间波数，$\\eta$ 是埃瓦尔德分裂参数。\n\n对于晶格常数为 $a$ 的简单立方晶格，实空间求和中的项数 $N_r$ 和倒易空间求和中的项数 $N_k$ 通过连续介质计数近似为：\n$$\nN_{r} \\approx \\frac{4\\pi R_{c}^{3}}{3 a^{3}} \\quad (3)\n$$\n$$\nN_{k} \\approx \\frac{V}{(2\\pi)^{3}}\\cdot \\frac{4\\pi G_{c}^{3}}{3} = \\frac{a^{3}}{8\\pi^3} \\cdot \\frac{4\\pi G_{c}^{3}}{3} = \\frac{a^{3} G_{c}^{3}}{6\\pi^{2}} \\quad (4)\n$$\n其中 $V=a^3$ 是实空间单位晶胞的体积。\n\n平衡计算工作量的优化条件是 $N_r \\approx N_k$。令式 $(3)$ 和 $(4)$ 中的表达式相等：\n$$\n\\frac{4\\pi R_{c}^{3}}{3 a^{3}} = \\frac{a^{3} G_{c}^{3}}{6\\pi^{2}}\n$$\n我们可以重排该方程以找到 $R_c$ 和 $G_c$ 之间的关系：\n$$\n\\frac{R_{c}^{3}}{G_{c}^{3}} = \\frac{a^{3}}{6\\pi^{2}} \\cdot \\frac{3a^3}{4\\pi} = \\frac{3a^6}{24\\pi^3} = \\frac{a^6}{8\\pi^3}\n$$\n对两边取立方根，得到一个简单的线性关系：\n$$\n\\frac{R_c}{G_c} = \\left(\\frac{a^6}{8\\pi^3}\\right)^{1/3} = \\frac{a^2}{2\\pi}\n$$\n这意味着 $G_c = \\frac{2\\pi}{a^2} R_c$。\n\n接下来，我们使用误差控制方程 $(1)$ 和 $(2)$ 将 $R_c$ 和 $G_c$ 用 $\\eta$ 表示。由方程 $(1)$ 可得：\n$$\nR_c = \\frac{\\sqrt{L}}{\\eta} \\quad (5)\n$$\n由方程 $(2)$ 可得：\n$$\nG_c^2 = k^2 + 4\\eta^2 L \\implies G_c = \\sqrt{k^2 + 4\\eta^2 L} \\quad (6)\n$$\n现在，将表达式 $(5)$ 和 $(6)$ 代入关系式 $G_c = \\frac{2\\pi}{a^2} R_c$ 中：\n$$\n\\sqrt{k^2 + 4\\eta^2 L} = \\frac{2\\pi}{a^2} \\left(\\frac{\\sqrt{L}}{\\eta}\\right)\n$$\n为了解出 $\\eta$，我们对该方程两边进行平方：\n$$\nk^2 + 4\\eta^2 L = \\left(\\frac{2\\pi}{a^2}\\right)^2 \\left(\\frac{\\sqrt{L}}{\\eta}\\right)^2 = \\frac{4\\pi^2}{a^4} \\frac{L}{\\eta^2}\n$$\n整个方程乘以 $\\eta^2$ 以消去分母：\n$$\nk^2 \\eta^2 + 4L \\eta^4 = \\frac{4\\pi^2 L}{a^4}\n$$\n这可以重排成一个关于变量 $\\eta^2$ 的标准二次方程。令 $x = \\eta^2$：\n$$\n(4L)x^2 + (k^2)x - \\frac{4\\pi^2 L}{a^4} = 0\n$$\n我们使用二次公式 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解这个关于 $x$ 的二次方程，其中系数为 $a_{quad} = 4L$，$b_{quad} = k^2$ 和 $c_{quad} = -\\frac{4\\pi^2 L}{a^4}$：\n$$\nx = \\eta^2 = \\frac{-k^2 \\pm \\sqrt{(k^2)^2 - 4(4L)\\left(-\\frac{4\\pi^2 L}{a^4}\\right)}}{2(4L)}\n$$\n$$\n\\eta^2 = \\frac{-k^2 \\pm \\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}}{8L}\n$$\n由于 $\\eta$ 是一个实值物理参数，$\\eta^2$ 必须是一个正实数。平方根下的项 $\\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}$ 严格大于 $\\sqrt{k^4} = k^2$。因此，为确保 $\\eta^2  0$，我们必须在分子中选择正号：\n$$\n\\eta^2 = \\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 L^2}{a^4}}}{8L}\n$$\n对两边取平方根得到 $\\eta$ 的表达式。我们代回 $L = \\ln(2/\\varepsilon)$：\n$$\n\\eta = \\sqrt{\\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 (\\ln(2/\\varepsilon))^2}{a^4}}}{8 \\ln(2/\\varepsilon)}}\n$$\n这就是最优分裂参数 $\\eta$ 作为容差 $\\varepsilon$、波数 $k$ 和晶格常数 $a$ 的函数的最终解析表达式。",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{-k^2 + \\sqrt{k^4 + \\frac{64\\pi^2 \\left(\\ln\\left(\\frac{2}{\\varepsilon}\\right)\\right)^2}{a^4}}}{8 \\ln\\left(\\frac{2}{\\varepsilon}\\right)}}}\n$$"
        },
        {
            "introduction": "要成为一名真正的专家，了解一种技术的优势和局限性至关重要。这项练习是一项比较研究，它将 Ewald 求和与其他强大的序列加速方法（如 Shanks 变换和 Euler 加速）进行对比。通过在一个简化的模型上进行数值实验，您将发现不同类型级数的最佳求和策略，从而培养出为特定问题选择最合适数值工具的敏锐直觉 。",
            "id": "3340030",
            "problem": "考虑与标量亥姆霍兹问题相关的一维周期格点和，该和被限制在源位于格点线上的轴向切片上。对于一个无量纲谱参数 $t \\in (0, 2\\pi)$，定义格点和\n$$\nS(t) \\equiv \\sum_{n=1}^{\\infty} \\frac{2 \\cos(n t)}{n}.\n$$\n该和是条件收敛的，并且代表了在为具有一维周期性的三维亥姆霍兹方程计算周期格林函数时遇到的慢收敛行为。目标是设计、实现和比较三种不同方法对 $S(t)$ 的数值加速：Ewald求和、Shanks变换和欧拉加速，并确定Ewald求和优于或劣于其他加速方法的 $t$ 的区间。\n\n从以下基础出发：\n- 亥姆霍兹算子 $\\nabla^2 + k^2$ 及其自由空间格林函数是格点和与准周期格林函数计算的基础。\n- 泊松求和与高斯屏蔽是Ewald分解条件收敛格点和的标准工具。\n- 以下经过充分检验的目标和的恒等式为误差评估提供了参考（基准真值）：\n$$\nS(t) = - 2 \\log\\!\\left(2 \\sin\\!\\left(\\frac{t}{2}\\right)\\right), \\quad \\text{for } t \\in (0, 2\\pi).\n$$\n仅将此恒等式用作与数值近似进行比较的参考。\n\n你必须实现以下 $S(t)$ 的估计量：\n\n$1.$ 截断直接求和：\n$$\nS_N(t) = \\sum_{n=1}^{N} \\frac{2 \\cos(n t)}{n}.\n$$\n\n$2.$ Shanks变换（应用于部分和序列）。给定 $S_{N-1}(t)$、$S_{N}(t)$ 和 $S_{N+1}(t)$，定义\n$$\n\\mathcal{S}(S_N) = \\frac{S_{N+1}(t)\\, S_{N-1}(t) - \\left(S_{N}(t)\\right)^2}{S_{N+1}(t) + S_{N-1}(t) - 2 S_{N}(t)},\n$$\n前提是分母不为零；否则使用 $S_{N}(t)$。\n\n$3.$ 通过部分和的前向差分进行欧拉加速。令 $\\Delta^0 S_N = S_N$，并递归定义前向差分\n$$\n\\Delta^{m} S_N = \\Delta^{m-1} S_{N+1} - \\Delta^{m-1} S_{N}, \\quad \\text{for } m \\ge 1.\n$$\n定义 $K$ 项欧拉加速估计\n$$\nE_K(S_N) = \\Delta^0 S_N + \\sum_{m=1}^{K} \\frac{\\Delta^m S_N}{2^m}.\n$$\n\n$4.$ 一维亥姆霍兹格点和的Ewald求和。使用互补误差函数(erfc)和一阶指数积分($\\operatorname{E1}$)，实现Ewald分解近似\n$$\nS^{\\mathrm{E}}_{\\eta, N_{\\mathrm{r}}, M_{\\mathrm{g}}}(t) = \n\\underbrace{\\sum_{n=1}^{N_{\\mathrm{r}}} \\frac{2 \\cos(n t)}{n}\\, \\operatorname{erfc}(\\eta n)}_{\\text{实空间，短程}}\n\\;+\\;\n\\underbrace{\\sum_{m=-M_{\\mathrm{g}}}^{M_{\\mathrm{g}}} \\operatorname{E1}\\!\\left(\\frac{(t + 2\\pi m)^2}{4 \\eta^2}\\right)}_{\\text{倒易空间，长程}}.\n$$\n此处 $\\eta  0$ 是Ewald屏蔽参数，$N_{\\mathrm{r}}$ 是实空间截断，$M_{\\mathrm{g}}$ 是倒易空间截断。对于 $t \\in (0, 2\\pi)$，倒易空间和不排除任何项，因为 $(t + 2\\pi m)^2/(4 \\eta^2)  0$。上述表示是从 $1/|x|$ 的高斯积分恒等式和专门用于一维的泊松求和公式得出的。\n\n对于每个估计量，定义绝对误差\n$$\ne_{\\mathrm{method}}(t) = \\left|S_{\\mathrm{method}}(t) - S(t)\\right|,\n$$\n其中 $S(t)$ 是上面给出的精确参考值。角度必须以弧度处理。\n\n你的程序必须对以下测试套件进行数值实验，并为每个测试用例确定哪种方法实现的绝对误差最小。使用以下参数：\n- 测试用例 1：$t = 0.2$, $\\eta = 0.9$, $N = 200$, $N_{\\mathrm{r}} = 80$, $M_{\\mathrm{g}} = 80$, $K = 8$。\n- 测试用例 2：$t = 1.2$, $\\eta = 0.9$, $N = 200$, $N_{\\mathrm{r}} = 80$, $M_{\\mathrm{g}} = 80$, $K = 8$。\n- 测试用例 3：$t = 2.9$, $\\eta = 0.9$, $N = 200$, $N_{\\mathrm{r}} = 80$, $M_{\\mathrm{g}} = 80$, $K = 8$。\n- 测试用例 4：$t = \\pi$, $\\eta = 0.9$, $N = 200$, $N_{\\mathrm{r}} = 80$, $M_{\\mathrm{g}} = 80$, $K = 8$。\n- 测试用例 5：$t = 0.01$, $\\eta = 0.9$, $N = 200$, $N_{\\mathrm{r}} = 120$, $M_{\\mathrm{g}} = 120$, $K = 8$。\n\n解释指南：\n- 对于接近 $\\pi$ 的 $t$，项 $\\cos(n t)$ 强烈交错，这有利于Shanks和欧拉加速。\n- 对于接近 $0$ 的 $t$，级数由于弱振荡而表现出缓慢收敛，这有利于Ewald求和，因为其倒易空间校正能有效解决长程行为。\n- 对于中间的 $t$ 值，性能可能因参数选择而异。\n\n最终输出规范：\n- 用整数标记方法：截断直接求和 $= 0$，Shanks $= 1$，欧拉 $= 2$，Ewald $= 3$。\n- 对于每个测试用例，计算所有方法的 $e_{\\mathrm{method}}(t)$，并选择绝对误差最小的方法的标签。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$”[1,3,2,2,3]”$）。不应打印任何其他文本。\n\n所有角度必须是弧度。除了角度之外，不涉及任何物理单位，并且角度必须以弧度指定和处理。每个测试用例的答案是选择最佳方法的整数，如上定义。",
            "solution": "我们考虑三维中具有一维周期性的亥姆霍兹方程 $\\nabla^2 + k^2$ 的周期格林函数背景。标量格点和 $S(t)$，\n$$\nS(t) = \\sum_{n=1}^{\\infty} \\frac{2 \\cos(n t)}{n},\n$$\n捕捉了导致直接求和中严重收敛问题的慢衰减（$\\sim 1/n$）和振荡行为。这是计算电磁学中用于对求和加速技术（如Ewald分解、Shanks变换和欧拉加速）进行基准测试的典型设置。我们通过从第一性原理构建每种方法并为实现定义精确算法来继续。\n\n$1.$ 来自傅里叶级数恒等式的精确参考。一个著名的三角级数恒等式给出\n$$\n\\sum_{n=1}^{\\infty} \\frac{\\cos(n t)}{n} = -\\log\\!\\left(2 \\sin\\!\\left(\\frac{t}{2}\\right)\\right), \\quad t \\in (0, 2\\pi).\n$$\n因此，\n$$\nS(t) = \\sum_{n=1}^{\\infty} \\frac{2 \\cos(n t)}{n} = - 2 \\log\\!\\left(2 \\sin\\!\\left(\\frac{t}{2}\\right)\\right).\n$$\n我们使用这个闭合形式作为与数值方法比较的基准真值。这是一个源自傅里叶分析的、经过充分检验的公式，它不是我们推导的目标；相反，它用作误差评估的基准。\n\n$2.$ 截断直接求和。最简单的估计量是在 $n = N$ 处截断无穷级数：\n$$\nS_N(t) = \\sum_{n=1}^{N} \\frac{2 \\cos(n t)}{n}.\n$$\n由于弱振荡和 $1/n$ 的调和衰减，该估计量对于小的 $t$ 收敛缓慢。它为评估加速方法提供了一个基线。\n\n$3.$ Shanks变换。Shanks变换是一种非线性序列加速方法，它能消除序列中主要的渐近行为。应用于序列 $\\{S_N(t)\\}$，它从三个连续的部分和构建一个改进的估计：\n$$\n\\mathcal{S}(S_N) = \\frac{S_{N+1}(t) S_{N-1}(t) - \\left(S_{N}(t)\\right)^2}{S_{N+1}(t) + S_{N-1}(t) - 2 S_{N}(t)},\n$$\n前提是分母不为零。直观上，如果 $S_N$ 具有渐近形式 $S_N \\approx S + A/N + B/N^2 + \\cdots$，Shanks变换会消去主导项，从而加速收敛。在实践中，我们从直接求和中计算 $S_{N-1}(t)$、$S_{N}(t)$ 和 $S_{N+1}(t)$，然后应用该公式。\n\n$4.$ 通过前向差分进行欧拉加速。欧拉加速传统上是为交错级数推导的，它用加权的 $1/2$ 次幂的前向差分来表示和。对于一般的部分和序列，我们使用 $S_N$ 的前向差分：\n$$\n\\Delta^0 S_N = S_N, \\quad \\Delta^1 S_N = S_{N+1} - S_N, \\quad \\Delta^2 S_N = (S_{N+2} - S_{N+1}) - (S_{N+1} - S_N), \\quad \\text{等等}\n$$\n然后，具有 $K$ 项的欧拉加速估计为\n$$\nE_K(S_N) = \\Delta^0 S_N + \\sum_{m=1}^{K} \\frac{\\Delta^m S_N}{2^m}.\n$$\n虽然这种方法对交错级数最有效，但它仍然可以改善具有近交错或阻尼振荡的序列的收敛性。在我们的实验设计中，接近 $t = \\pi$ 的情况表现出强烈的交错性，因此适合欧拉加速。\n\n$5.$ 一维亥姆霍兹格点和的Ewald求和。Ewald求和使用高斯屏蔽和泊松求和将一个条件收敛的格点和分解为快速收敛的实空间和倒易空间部分。从积分恒等式开始\n$$\n\\frac{1}{|x|} = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{\\infty} e^{-x^2 u^2} \\, du,\n$$\n并将其应用于具有振荡因子 $e^{i t x}$ 的一维和，我们在Ewald屏蔽参数 $u = \\eta$ 处分解积分：\n$$\n\\frac{1}{|x|} = \\underbrace{\\frac{2}{\\sqrt{\\pi}} \\int_{\\eta}^{\\infty} e^{-x^2 u^2} \\, du}_{\\text{实空间}} + \\underbrace{\\frac{2}{\\sqrt{\\pi}} \\int_{0}^{\\eta} e^{-x^2 u^2} \\, du}_{\\text{倒易空间前驱}}.\n$$\n认识到\n$$\n\\frac{2}{\\sqrt{\\pi}} \\int_{\\eta}^{\\infty} e^{-x^2 u^2} \\, du = \\frac{\\operatorname{erfc}(\\eta |x|)}{|x|},\n$$\n我们构成了实空间项\n$$\n\\sum_{n=1}^{\\infty} \\frac{2 \\cos(n t)}{n} \\operatorname{erfc}(\\eta n).\n$$\n对于倒易空间项，我们对高斯和使用一维泊松求和公式\n$$\n\\sum_{n \\in \\mathbb{Z}} e^{-(n)^2 u^2} e^{i t n} = \\frac{\\sqrt{\\pi}}{u} \\sum_{m \\in \\mathbb{Z}} e^{- \\frac{(t + 2\\pi m)^2}{4 u^2}},\n$$\n并从 $0$ 积分到 $\\eta$：\n$$\n\\frac{2}{\\sqrt{\\pi}} \\int_{0}^{\\eta} \\frac{\\sqrt{\\pi}}{u} \\sum_{m \\in \\mathbb{Z}} e^{-\\frac{(t + 2\\pi m)^2}{4 u^2}} \\, du = 2 \\sum_{m \\in \\mathbb{Z}} \\int_{0}^{\\eta} \\frac{1}{u} e^{-\\frac{(t + 2\\pi m)^2}{4 u^2}} \\, du.\n$$\n通过换元 $s = \\frac{(t + 2\\pi m)^2}{4 u^2}$，$u = \\frac{|t + 2\\pi m|}{2 \\sqrt{s}}$，我们得到\n$$\n\\int_{0}^{\\eta} \\frac{1}{u} e^{-\\frac{(t + 2\\pi m)^2}{4 u^2}} \\, du = \\frac{1}{2} \\int_{\\frac{(t + 2\\pi m)^2}{4 \\eta^2}}^{\\infty} \\frac{e^{-s}}{s} \\, ds = \\frac{1}{2} \\operatorname{E1}\\!\\left(\\frac{(t + 2\\pi m)^2}{4 \\eta^2}\\right),\n$$\n其中 $\\operatorname{E1}(x) = \\int_{x}^{\\infty} \\frac{e^{-s}}{s} \\, ds$ 是一阶指数积分。因此，倒易空间和变为\n$$\n\\sum_{m \\in \\mathbb{Z}} \\operatorname{E1}\\!\\left(\\frac{(t + 2\\pi m)^2}{4 \\eta^2}\\right),\n$$\n完整的Ewald表示为\n$$\nS^{\\mathrm{E}}_{\\eta}(t) = \\sum_{n=1}^{\\infty} \\frac{2 \\cos(n t)}{n} \\operatorname{erfc}(\\eta n) + \\sum_{m \\in \\mathbb{Z}} \\operatorname{E1}\\!\\left(\\frac{(t + 2\\pi m)^2}{4 \\eta^2}\\right).\n$$\n在 $n = N_{\\mathrm{r}}$ 处截断实空间和，在 $m = -M_{\\mathrm{g}}, \\ldots, M_{\\mathrm{g}}$ 处截断倒易空间和，得到实际的估计量\n$$\nS^{\\mathrm{E}}_{\\eta, N_{\\mathrm{r}}, M_{\\mathrm{g}}}(t) = \\sum_{n=1}^{N_{\\mathrm{r}}} \\frac{2 \\cos(n t)}{n} \\operatorname{erfc}(\\eta n) + \\sum_{m=-M_{\\mathrm{g}}}^{M_{\\mathrm{g}}} \\operatorname{E1}\\!\\left(\\frac{(t + 2\\pi m)^2}{4 \\eta^2}\\right).\n$$\n这种分解通过互补误差函数（对大的 $n$ 快速衰减）在实空间中捕捉短程贡献，并通过指数积分（对大的 $|m|$ 衰减）在倒易空间中捕捉长程行为。\n\n$6.$ 算法设计。对于每个测试用例 $(t, \\eta, N, N_{\\mathrm{r}}, M_{\\mathrm{g}}, K)$（角度单位为弧度），我们计算：\n- $S(t)$ 精确值，通过 $- 2 \\log\\!\\left(2 \\sin\\!\\left(\\frac{t}{2}\\right)\\right)$。\n- $S_N(t)$，通过具有 $N$ 项的直接截断。\n- $\\mathcal{S}(S_N)$，使用 $S_{N-1}(t)$、$S_N(t)$、$S_{N+1}(t)$。\n- $E_K(S_N)$，通过序列 $S_N(t), S_{N+1}(t), \\ldots, S_{N+K}(t)$ 的 $K$ 个前向差分。\n- $S^{\\mathrm{E}}_{\\eta, N_{\\mathrm{r}}, M_{\\mathrm{g}}}(t)$，使用指定的 $(\\eta, N_{\\mathrm{r}}, M_{\\mathrm{g}})$。\n\n然后我们计算绝对误差\n$$\ne_{\\mathrm{direct}}(t) = \\left|S_N(t) - S(t)\\right|,\n\\quad\ne_{\\mathrm{shanks}}(t) = \\left|\\mathcal{S}(S_N) - S(t)\\right|,\n$$\n$$\ne_{\\mathrm{euler}}(t) = \\left|E_K(S_N) - S(t)\\right|,\n\\quad\ne_{\\mathrm{ewald}}(t) = \\left|S^{\\mathrm{E}}_{\\eta, N_{\\mathrm{r}}, M_{\\mathrm{g}}}(t) - S(t)\\right|.\n$$\n最后，我们选择绝对误差最小的方法标签：截断直接求和 $= 0$，Shanks $= 1$，欧拉 $= 2$，Ewald $= 3$。\n\n$7.$ 区间解释。数值实验的结构旨在揭示以下行为：\n- 对于接近 $\\pi$ 的 $t$，$\\cos(n t)$ 在 $+1$ 和 $-1$ 之间强烈交错，Shanks和欧拉加速都能有效抵消主导误差项，对于中等截断通常优于Ewald。\n- 对于小的 $t$（例如，$t = 0.01$），级数表现出弱振荡和慢收敛，这使得Ewald求和中的倒易空间校正特别有效；Ewald通常占主导地位。\n- 对于中间的 $t$ 值（例如，$t = 1.2$，$t = 2.9$），性能取决于参数选择；Ewald和Shanks/欧拉可能会相互竞争。\n\n通过计算和比较每个案例的绝对误差，并根据指定的整数标签选择最佳方法，程序生成了关于优越性区间的清晰摘要。输出是单行，包含测试套件的整数标签，采用所需的方括号括起的逗号分隔列表格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc, exp1\n\ndef exact_S(t):\n    # Exact reference: S(t) = -2 * log(2 * sin(t/2)), for t in (0, 2*pi)\n    return -2.0 * np.log(2.0 * np.sin(t / 2.0))\n\ndef direct_truncated(t, N):\n    n = np.arange(1, N + 1, dtype=float)\n    return np.sum(2.0 * np.cos(n * t) / n)\n\ndef shanks_transform(t, N):\n    # Compute S_{N-1}, S_N, S_{N+1}\n    SNm1 = direct_truncated(t, N - 1) if N - 1 = 1 else direct_truncated(t, 1)\n    SN = direct_truncated(t, N)\n    SNp1 = direct_truncated(t, N + 1)\n    denom = (SNp1 + SNm1 - 2.0 * SN)\n    if abs(denom)  1e-15:\n        return SN\n    num = SNp1 * SNm1 - SN * SN\n    return num / denom\n\ndef euler_acceleration(t, N, K):\n    # Build sequence of partial sums: S_N, S_{N+1}, ..., S_{N+K}\n    s_vals = [direct_truncated(t, N + j) for j in range(K + 1)]\n    # Forward differences\n    diffs = [s_vals]\n    for m in range(1, K + 1):\n        prev = diffs[m - 1]\n        diffs.append([prev[i + 1] - prev[i] for i in range(len(prev) - 1)])\n    # Euler accelerated estimate\n    est = diffs[0][0]\n    for m in range(1, K + 1):\n        est += diffs[m][0] / (2.0 ** m)\n    return est\n\ndef ewald_sum_1d_helmholtz(t, eta, N_real, M_recip):\n    # Real-space short-range sum with complementary error function\n    n = np.arange(1, N_real + 1, dtype=float)\n    real_sum = np.sum(2.0 * np.cos(n * t) / n * erfc(eta * n))\n    # Reciprocal-space long-range sum via exponential integral E1\n    m = np.arange(-M_recip, M_recip + 1, dtype=float)\n    tm = t + 2.0 * np.pi * m\n    recip_sum = np.sum(exp1((tm ** 2) / (4.0 * eta * eta)))\n    return real_sum + recip_sum\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case: (t, eta, N, N_real, M_recip, K)\n    test_cases = [\n        (0.2, 0.9, 200, 80, 80, 8),\n        (1.2, 0.9, 200, 80, 80, 8),\n        (2.9, 0.9, 200, 80, 80, 8),\n        (np.pi, 0.9, 200, 80, 80, 8),\n        (0.01, 0.9, 200, 120, 120, 8),\n    ]\n\n    # Method labels: 0 = direct truncated, 1 = Shanks, 2 = Euler, 3 = Ewald\n    results = []\n    for (t, eta, N, N_real, M_recip, K) in test_cases:\n        # Exact reference\n        S_exact = exact_S(t)\n        # Methods\n        S_direct = direct_truncated(t, N)\n        S_shanks = shanks_transform(t, N)\n        S_euler = euler_acceleration(t, N, K)\n        S_ewald = ewald_sum_1d_helmholtz(t, eta, N_real, M_recip)\n\n        # Errors\n        err_direct = abs(S_direct - S_exact)\n        err_shanks = abs(S_shanks - S_exact)\n        err_euler = abs(S_euler - S_exact)\n        err_ewald = abs(S_ewald - S_exact)\n\n        errors = [err_direct, err_shanks, err_euler, err_ewald]\n        best_method = int(np.argmin(errors))\n        results.append(best_method)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}