{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of computational multiphysics is translating continuous physical laws into a discrete form suitable for a computer. This first practice focuses on the fundamental mechanism of magnetostructural coupling: the Lorentz force, often expressed as $\\mathbf{J} \\times \\mathbf{B}$. By starting from Maxwell's equations and the principle of virtual work, you will derive the element-level coupling matrix that translates electromagnetic currents and fields into consistent nodal forces on a finite element mesh .",
            "id": "3304507",
            "problem": "A two-dimensional magnetoelastic body occupies a polygonal domain in the plane with unit thickness. Under the assumptions of small deformations, quasistatic magnetostatics, linear and isotropic magnetic materials, and negligible magnetostriction, the electromagnetic field and the structure are weakly coupled through the Lorentz body force density. Starting from Maxwell's equations for magnetostatics and the principle of virtual work in continuum mechanics, derive the element-level coupling that maps the electromagnetic degrees of freedom to the mechanical nodal force vector for a single linear triangular element. Then implement the derived expressions to compute either the element-level coupling matrix or the consistent mechanical nodal force vector as specified by the test suite below. All calculations must assume unit thickness and constant current density through the element. When a mechanical force is requested, express the final answer in Newtons, rounded to six decimal places.\n\nFundamental starting point and modeling assumptions:\n- Magnetostatics with the magnetic vector potential, where the magnetic flux density satisfies $\\nabla \\times \\mathbf{A} = \\mathbf{B}$ and the curl equation $\\nabla \\times \\mathbf{H} = \\mathbf{J}$, with $\\mathbf{B} = \\mu \\mathbf{H}$ and constant scalar $\\mu$.\n- Out-of-plane magnetic vector potential representation in two dimensions: $\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$, so that $\\mathbf{B} = \\nabla \\times \\left(A_z \\hat{\\mathbf{k}}\\right)$.\n- Electric current density is out-of-plane and constant per element: $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$, where $J_z$ is an element-wise constant.\n- Mechanical virtual work due to electromagnetic body force density given by $\\delta W = \\int_{\\Omega} \\delta \\mathbf{u} \\cdot \\left(\\mathbf{J} \\times \\mathbf{B}\\right)\\, \\mathrm{d}\\Omega$, neglecting Maxwell surface tractions on the element boundary.\n- Finite Element Method (FEM) with linear shape functions on a single triangle having nodes indexed by $i \\in \\{1,2,3\\}$ and coordinates $(x_i,y_i)$. The magnetic vector potential is approximated as $A_z(x,y) \\approx \\sum_{i=1}^3 N_i(x,y)\\, a_i$, where $a_i$ are nodal values and $N_i$ are scalar shape functions. The mechanical displacement interpolation uses the same shape functions $N_i$ with two displacement components per node.\n\nDerivation objectives:\n- From the above base, derive the explicit expression for the magnetic flux density components $\\left(B_x, B_y\\right)$ in terms of the gradients of the shape functions and the nodal magnetic potential values $\\{a_i\\}_{i=1}^3$ for a linear triangular element.\n- Using the Lorentz force density $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ with $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$, express $\\mathbf{f}$ in terms of the nodal magnetic potential values $\\{a_i\\}_{i=1}^3$.\n- Derive the consistent nodal mechanical force vector $\\mathbf{F}_e \\in \\mathbb{R}^{6}$ for the element by integrating the virtual work with the mechanical shape functions, and obtain the $6 \\times 3$ coupling matrix $C_e$ that maps the magnetic nodal vector $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ to $\\mathbf{F}_e$, i.e., $\\mathbf{F}_e = C_e \\mathbf{a}_e$. Assume unit thickness and that $J_z$ is constant over the element. Do not assume any special orientation for the triangle.\n\nComputational task:\n- Implement the derived expressions for a single linear triangular element with nodes at coordinates $\\left(x_i, y_i\\right)$ for $i \\in \\{1,2,3\\}$ and constant $J_z$ over the element.\n- If a test case requests the coupling matrix, output the matrix entries flattened in row-major order: rows correspond to mechanical degrees of freedom ordered as $\\left[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}\\right]$, and columns correspond to $\\left[a_1, a_2, a_3\\right]$.\n- If a test case requests the mechanical nodal force vector, compute $\\mathbf{F}_e = C_e \\mathbf{a}_e$ and output it as a length-$6$ list ordered as $\\left[F_{1x}, F_{1y}, F_{2x}, F_{2y}, F_{3x}, F_{3y}\\right]$.\n- Units and rounding:\n  - Coordinates $\\left(x_i,y_i\\right)$ are in meters.\n  - Current density $J_z$ is in amperes per square meter $\\left(\\mathrm{A}/\\mathrm{m}^2\\right)$.\n  - Magnetic vector potential nodal values $a_i$ are in weber per meter $\\left(\\mathrm{Wb}/\\mathrm{m}\\right)$.\n  - The element thickness is unity in meters, so the resulting nodal forces are in newtons $\\left(\\mathrm{N}\\right)$.\n  - All numerical outputs must be rounded to $6$ decimal places.\n- Angle units are not used in this problem.\n- The program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each result is itself a bracketed, comma-separated list. For coupling matrices, output the flattened entries in row-major order; for force vectors, output the six entries in order. For example, the output format is like $\\left[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,\\right]$ with no spaces, and all numbers rounded to $6$ decimal places.\n\nTest suite:\n- Test case $1$ (coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=2.0$.\n- Test case $2$ (force vector): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=1.0$, $\\left[a_1,a_2,a_3\\right]=[0.0,1.0,0.0]$.\n- Test case $3$ (zero coupling): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=0.0$.\n- Test case $4$ (scaled geometry, coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(2,1)$, $\\left(x_2,y_2\\right)=(5,1)$, $\\left(x_3,y_3\\right)=(2,4)$, $J_z=3.0$.\n- Test case $5$ (negative current, coupling matrix): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=-1.5$.\n- Test case $6$ (force vector on non-orthogonal triangle): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(2,0)$, $\\left(x_3,y_3\\right)=(1,1.7320508075688772)$, $J_z=0.5$, $\\left[a_1,a_2,a_3\\right]=[0.0,2.0,-0.7320508075688772]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself enclosed in square brackets, and with all floating-point numbers rounded to $6$ decimal places, for example: $\\left[\\,[r_{1,1},\\ldots,r_{1,n_1}],\\,[r_{2,1},\\ldots,r_{2,n_2}],\\ldots\\,\\right]$ where each $r_{k,j}$ is a float rounded to $6$ decimals.",
            "solution": "The task is to derive and implement the element-level coupling that maps electromagnetic degrees of freedom (nodal magnetic vector potentials) to mechanical nodal forces for a linear triangular element. The coupling arises from the Lorentz body force within a 2D quasistatic magneto-structural model.\n\n### Derivation of the Coupling Matrix\n\nThe derivation proceeds in three steps:\n1.  Express the magnetic flux density, $\\mathbf{B}$, in terms of the nodal magnetic vector potential values, $\\mathbf{a}_e$.\n2.  Derive the Lorentz body force density, $\\mathbf{f}$, using the previously found expression for $\\mathbf{B}$.\n3.  Use the principle of virtual work to find the consistent nodal force vector, $\\mathbf{F}_e$, and extract the coupling matrix, $C_e$.\n\n**1. Magnetic Flux Density $\\mathbf{B}$**\n\nThe problem assumes a 2D model where the magnetic vector potential $\\mathbf{A}$ has only an out-of-plane component, $\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$. The magnetic flux density $\\mathbf{B}$ is given by the curl of $\\mathbf{A}$:\n$$\n\\mathbf{B} = \\nabla \\times \\mathbf{A} = \\nabla \\times (A_z\\,\\hat{\\mathbf{k}}) = \\begin{vmatrix} \\hat{\\mathbf{i}}  \\hat{\\mathbf{j}}  \\hat{\\mathbf{k}} \\\\ \\frac{\\partial}{\\partial x}  \\frac{\\partial}{\\partial y}  \\frac{\\partial}{\\partial z} \\\\ 0  0  A_z \\end{vmatrix} = \\frac{\\partial A_z}{\\partial y} \\hat{\\mathbf{i}} - \\frac{\\partial A_z}{\\partial x} \\hat{\\mathbf{j}}\n$$\nThus, the in-plane components of the magnetic flux density are $B_x = \\frac{\\partial A_z}{\\partial y}$ and $B_y = -\\frac{\\partial A_z}{\\partial x}$.\n\nWithin a linear triangular finite element, the field $A_z(x,y)$ is interpolated from its nodal values $\\{a_1, a_2, a_3\\}$ using linear shape functions $N_i(x,y)$:\n$$\nA_z(x,y) \\approx \\sum_{i=1}^{3} N_i(x,y) a_i\n$$\nThe gradient of $A_z$ is then:\n$$\n\\nabla A_z = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\sum_{i=1}^{3} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} a_i\n$$\nFor a linear triangular element with nodes $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$, the gradients of the shape functions are constant over the element. They are given by:\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2 A_e}, \\quad \\frac{\\partial N_i}{\\partial y} = \\frac{d_i}{2 A_e}\n$$\nwhere $A_e$ is the area of the element, and the coefficients $b_i$ and $d_i$ are functions of the nodal coordinates:\n$$\n\\begin{array}{ll}\nb_1 = y_2 - y_3,  \\quad d_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1,  \\quad d_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2,  \\quad d_3 = x_2 - x_1\n\\end{array}\n$$\nThe gradient $\\nabla A_z$ can be written in matrix form as:\n$$\n\\nabla A_z = \\frac{1}{2 A_e} \\begin{bmatrix} b_1  b_2  b_3 \\\\ d_1  d_2  d_3 \\end{bmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} = \\mathbf{B}_{mat} \\mathbf{a}_e\n$$\nSince $\\mathbf{B}_{mat}$ and $\\mathbf{a}_e$ are constant with respect to $(x,y)$ within the element, $\\nabla A_z$ is constant. Consequently, the magnetic flux density $\\mathbf{B}$ is also constant over the element:\n$$\n\\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial y} \\\\ -\\frac{\\partial A_z}{\\partial x} \\end{pmatrix} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\mathbf{B}_{mat} \\mathbf{a}_e = \\frac{1}{2 A_e} \\begin{bmatrix} d_1  d_2  d_3 \\\\ -b_1  -b_2  -b_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n\n**2. Lorentz Force Density $\\mathbf{f}$**\n\nThe Lorentz body force density is given by $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$. The current density $\\mathbf{J}$ is assumed to be constant and out-of-plane, $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$.\n$$\n\\mathbf{f} = (J_z \\hat{\\mathbf{k}}) \\times (B_x \\hat{\\mathbf{i}} + B_y \\hat{\\mathbf{j}}) = J_z B_x (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{i}}) + J_z B_y (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{j}}) = J_z B_x \\hat{\\mathbf{j}} - J_z B_y \\hat{\\mathbf{i}}\n$$\nThe components of the force density are $f_x = -J_z B_y$ and $f_y = J_z B_x$. In vector form:\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{pmatrix} -B_y \\\\ B_x \\end{pmatrix} = J_z \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix} \\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix}\n$$\nSubstituting the expression for $\\mathbf{B}$ in terms of $\\nabla A_z$:\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix} \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\nabla A_z\n$$\nSo, the force density is directly proportional to the gradient of the magnetic vector potential, $\\mathbf{f} = J_z \\mathbf{B}_{mat} \\mathbf{a}_e$. Since $\\nabla A_z$ is constant over the element, so is $\\mathbf{f}$.\n\n**3. Nodal Force Vector $\\mathbf{F}_e$ and Coupling Matrix $C_e$**\n\nThe equivalent nodal forces are derived from the principle of virtual work. The virtual work done by the body force is:\n$$\n\\delta W = \\int_{V_e} \\delta \\mathbf{u} \\cdot \\mathbf{f} \\, dV\n$$\nwhere $\\delta\\mathbf{u}$ is the virtual displacement field. In the FEM framework, the displacement field $\\mathbf{u}$ is interpolated using the same shape functions as $A_z$:\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} N_1  0  N_2  0  N_3  0 \\\\ 0  N_1  0  N_2  0  N_3 \\end{bmatrix} \\mathbf{u}_e = \\mathbf{N}(x,y) \\mathbf{u}_e\n$$\nwhere $\\mathbf{u}_e \\in \\mathbb{R}^6$ is the vector of nodal displacements. The virtual work becomes:\n$$\n\\delta W = \\int_{V_e} (\\mathbf{N} \\delta\\mathbf{u}_e)^T \\mathbf{f} \\, dV = \\delta\\mathbf{u}_e^T \\left( \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV \\right)\n$$\nBy definition, $\\delta W = \\delta\\mathbf{u}_e^T \\mathbf{F}_e$, so the consistent nodal force vector is:\n$$\n\\mathbf{F}_e = \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV\n$$\nFor a 2D problem of unit thickness $t=1$, the volume integral becomes an area integral, $dV = t \\, dA = dA$. Since the force density $\\mathbf{f}$ is constant over the element, we can take it out of the integral:\n$$\n\\mathbf{F}_e = \\left( \\int_{A_e} \\mathbf{N}^T \\, dA \\right) \\mathbf{f}\n$$\nThe integral of the shape function matrix $\\mathbf{N}^T$ is:\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\int_{A_e} \\begin{bmatrix} N_1  0 \\\\ 0  N_1 \\\\ N_2  0 \\\\ 0  N_2 \\\\ N_3  0 \\\\ 0  N_3 \\end{bmatrix} dA = \\begin{bmatrix} \\int N_1 dA  0 \\\\ 0  \\int N_1 dA \\\\ \\vdots  \\vdots \\\\ \\int N_3 dA  0 \\\\ 0  \\int N_3 dA \\end{bmatrix}\n$$\nThe integral of a linear shape function over its triangular element is $\\int_{A_e} N_i \\, dA = A_e/3$. Therefore:\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\frac{A_e}{3} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  0 \\\\ 0  1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\nSubstituting this and the expression for $\\mathbf{f}$ into the equation for $\\mathbf{F}_e$:\n$$\n\\mathbf{F}_e = \\frac{A_e}{3} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ \\vdots  \\vdots \\\\ 1  0 \\\\ 0  1 \\end{bmatrix} \\left( J_z \\mathbf{B}_{mat} \\mathbf{a}_e \\right) = \\frac{A_e J_z}{3} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ \\vdots  \\vdots \\\\ 1  0 \\\\ 0  1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1  b_2  b_3 \\\\ d_1  d_2  d_3 \\end{bmatrix} \\right) \\mathbf{a}_e\n$$\nThe problem specifies unit thickness $t=1\\,\\text{m}$. The dimensional analysis requires including this thickness. The full expression for force is $\\mathbf{F}_e = t \\frac{A_e}{3} ...$.\n$$\n\\mathbf{F}_e = t \\frac{A_e J_z}{3} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ \\vdots  \\vdots \\\\ 1  0 \\\\ 0  1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1  b_2  b_3 \\\\ d_1  d_2  d_3 \\end{bmatrix} \\right) \\mathbf{a}_e = \\frac{t J_z}{6} \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ \\vdots  \\vdots \\\\ 1  0 \\\\ 0  1 \\end{bmatrix} \\begin{bmatrix} b_1  b_2  b_3 \\\\ d_1  d_2  d_3 \\end{bmatrix} \\mathbf{a}_e\n$$\nThe term $\\mathbf{F}_e = C_e \\mathbf{a}_e$ allows us to identify the $6 \\times 3$ coupling matrix $C_e$:\n$$\nC_e = \\frac{t J_z}{6} \\begin{bmatrix}\nb_1  b_2  b_3 \\\\\nd_1  d_2  d_3 \\\\\nb_1  b_2  b_3 \\\\\nd_1  d_2  d_3 \\\\\nb_1  b_2  b_3 \\\\\nd_1  d_2  d_3\n\\end{bmatrix}\n$$\nWith $t=1$, the final expression for the coupling matrix to be implemented is:\n$$\nC_e = \\frac{J_z}{6} \\begin{bmatrix}\ny_2 - y_3  y_3 - y_1  y_1 - y_2 \\\\\nx_3 - x_2  x_1 - x_3  x_2 - x_1 \\\\\ny_2 - y_3  y_3 - y_1  y_1 - y_2 \\\\\nx_3 - x_2  x_1 - x_3  x_2 - x_1 \\\\\ny_2 - y_3  y_3 - y_1  y_1 - y_2 \\\\\nx_3 - x_2  x_1 - x_3  x_2 - x_1\n\\end{bmatrix}\n$$\nThe force vector $\\mathbf{F}_e$ is computed by multiplying this matrix by the nodal vector potential values $\\mathbf{a}_e = [a_1, a_2, a_3]^T$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the magneto-structural coupling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 2.0},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 1.0, \"a\": [0.0, 1.0, 0.0]},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 0.0},\n        {\"mode\": \"matrix\", \"coords\": ((2, 1), (5, 1), (2, 4)), \"Jz\": 3.0},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": -1.5},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (2, 0), (1, 1.7320508075688772)), \"Jz\": 0.5, \"a\": [0.0, 2.0, -0.7320508075688772]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_coupling(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str = []\n    for res_list in results:\n        res_list_str = [f\"{x:.6f}\" for x in res_list]\n        results_str.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_coupling(case_data):\n    \"\"\"\n    Computes the coupling matrix or nodal force vector for a single linear triangular element.\n\n    Args:\n        case_data (dict): A dictionary containing the parameters for the test case.\n                          It must include 'mode', 'coords', and 'Jz'. If 'mode' is 'force',\n                          it must also include 'a'.\n\n    Returns:\n        list: A list of floats representing either the flattened coupling matrix\n              or the nodal force vector, rounded to 6 decimal places.\n    \"\"\"\n    mode = case_data[\"mode\"]\n    (x1, y1), (x2, y2), (x3, y3) = case_data[\"coords\"]\n    Jz = case_data[\"Jz\"]\n    \n    # As per the problem statement, element thickness t is 1 meter.\n    # The derived coupling matrix includes a factor t, so we set t=1.0.\n    t = 1.0\n    \n    # Calculate geometric coefficients b_i and d_i\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    \n    d1 = x3 - x2\n    d2 = x1 - x3\n    d3 = x2 - x1\n    \n    # The core 2x3 matrix relating force density to nodal potentials (scaled by Jz)\n    # This corresponds to [ [b1, b2, b3], [d1, d2, d3] ]\n    core_matrix = np.array([[b1, b2, b3], [d1, d2, d3]])\n    \n    # Construct the 6x3 coupling matrix Ce by tiling the core matrix and scaling\n    # Ce = (t * Jz / 6) * [ core_matrix_tiled_vertically ]\n    C_e = (t * Jz / 6.0) * np.tile(core_matrix, (3, 1))\n\n    if mode == \"matrix\":\n        # Flatten the matrix in row-major order (numpy's default)\n        return C_e.flatten().tolist()\n    elif mode == \"force\":\n        a_e = np.array(case_data[\"a\"]).reshape(3, 1)\n        # Compute the nodal force vector F_e = C_e * a_e\n        F_e = C_e @ a_e\n        return F_e.flatten().tolist()\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "While linear models are instructive, real-world engineering materials often exhibit complex nonlinear behavior where the mechanical stress $\\boldsymbol{\\sigma}$ and magnetic field $\\boldsymbol{H}$ are nonlinearly dependent on strain $\\boldsymbol{e}$ and magnetic induction $\\boldsymbol{B}$. This exercise delves into the heart of nonlinear constitutive modeling by deriving the tangent operator from a thermodynamic potential $\\psi(\\boldsymbol{e},\\boldsymbol{B})$ . Mastering the derivation and verification of this 'consistent tangent' is critical for implementing Newton-based solvers that converge rapidly and reliably in advanced simulations.",
            "id": "3304447",
            "problem": "Consider a quasi-static magnetoelastic body under the assumptions of small strain and magnetostatics. Adopt a potential-based formulation in which the total thermodynamic potential per unit reference volume is given by an energy density function $\\psi(\\boldsymbol{e},\\boldsymbol{B})$, where $\\boldsymbol{e}$ is the small-strain tensor and $\\boldsymbol{B}$ is the magnetic induction vector. Assume an isotropic, compressible linear elastic solid with a nonlinear magnetic response and a bilinear magnetoelastic coupling, with\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) \\;=\\; \\mu \\, \\boldsymbol{e}:\\boldsymbol{e} \\;+\\; \\dfrac{\\lambda}{2} \\left(\\operatorname{tr}\\boldsymbol{e}\\right)^2 \\;+\\; \\dfrac{1}{2\\mu_0}\\, \\boldsymbol{B}\\cdot \\boldsymbol{B} \\;+\\; m_s B_0 \\ln\\!\\left(\\cosh\\!\\left(\\dfrac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) \\;-\\; \\gamma \\, \\boldsymbol{B}^{\\mathsf{T}} \\,\\boldsymbol{e}\\, \\boldsymbol{B},\n$$\nwhere $\\mu$ and $\\lambda$ are LamÃ© parameters, $\\mu_0$ is the vacuum permeability, $m_s$ and $B_0$ set a smooth saturation response in the magnetic law, and $\\gamma$ is a magnetoelastic coupling coefficient. Here, $\\|\\boldsymbol{B}\\| = \\sqrt{\\boldsymbol{B}\\cdot\\boldsymbol{B}}$, $\\boldsymbol{e}:\\boldsymbol{e} = \\sum_{i,j} e_{ij} e_{ij}$, and $\\operatorname{tr}\\boldsymbol{e} = \\sum_i e_{ii}$. All inputs are to be understood in the International System of Units (SI): strains are dimensionless, the magnetic induction is in tesla, stresses and energy density are in pascal and joule per cubic meter, respectively. The program you will write will only output dimensionless boolean values, so no explicit unit conversion is required in the output.\n\nStarting from the principle of minimum potential energy and the constitutive definitions\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{e}}, \\quad \\boldsymbol{H} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{B}},\n$$\nderive the consistent tangent operator (the Hessian of $\\psi$) needed to ensure quadratic convergence of a Newton solver for the coupled problem. In particular, derive the four second-derivative blocks\n$$\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{B}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{B}},\n$$\nnoting that the mixed blocks must satisfy Maxwell symmetry $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$ when indices are appropriately arranged.\n\nYour tasks are:\n\n$1.$ From the given $\\psi(\\boldsymbol{e},\\boldsymbol{B})$, derive closed-form expressions for $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ and $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$.\n\n$2.$ Using only the fundamental definitions above, derive closed-form expressions for the algorithmic tangent blocks $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$, $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$, $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$, and $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$. Express your final formulas as index-wise components suitable for direct implementation in code.\n\n$3.$ Implement a program that:\n- Computes the analytic forms of the four tangent blocks at prescribed states $(\\boldsymbol{e},\\boldsymbol{B})$ and material parameters $(\\mu,\\lambda,\\mu_0,m_s,B_0,\\gamma)$.\n- Verifies the mixed-block symmetry $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$ by comparing components $\\left(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}\\right)_{ij k}$ and $\\left(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}\\right)_{k ij}$ for all indices $i,j,k$.\n- Validates each of the four blocks by comparing the analytic derivatives against central finite-difference approximations of the first derivatives $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ and $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$, using symmetric perturbations for off-diagonal strain components to preserve $\\boldsymbol{e}=\\boldsymbol{e}^{\\mathsf{T}}$. Use a perturbation magnitude of $h_{\\boldsymbol{B}} = 10^{-6}$ tesla for magnetic components and $h_{\\boldsymbol{e}} = 10^{-8}$ (dimensionless) for strain components. Use a relative tolerance $\\tau = 10^{-6}$ on Frobenius-norm relative errors.\n\n$4.$ Apply your program to the following test suite. For each test, use the same material parameters\n$$\n\\mu = 60\\times 10^{9},\\quad \\lambda = 90\\times 10^{9},\\quad \\mu_0 = 4\\pi \\times 10^{-7},\\quad m_s = 10^{5},\\quad B_0 = 1.2,\\quad \\gamma = 10^{6}.\n$$\nProvide the state $(\\boldsymbol{e},\\boldsymbol{B})$ for each test:\n- Test $1$ (general coupled state):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-3}  2\\times 10^{-4}  -10^{-4}\\\\\n2\\times 10^{-4}  -5\\times 10^{-4}  3\\times 10^{-4}\\\\\n-10^{-4}  3\\times 10^{-4}  2\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0.3\\\\ -0.1\\\\ 0.2\n\\end{bmatrix}.\n$$\n- Test $2$ (near-zero magnetic field and small strain):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-6}  0  0\\\\\n0  -2\\times 10^{-6}  0\\\\\n0  0  1.5\\times 10^{-6}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n10^{-12}\\\\ -2\\times 10^{-12}\\\\ 3\\times 10^{-12}\n\\end{bmatrix}.\n$$\n- Test $3$ (high magnetic field near saturation):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n5\\times 10^{-4}  -1\\times 10^{-4}  2\\times 10^{-4}\\\\\n-1\\times 10^{-4}  4\\times 10^{-4}  -2\\times 10^{-4}\\\\\n2\\times 10^{-4}  -2\\times 10^{-4}  -3\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n1.5\\\\ 0.5\\\\ -1.0\n\\end{bmatrix}.\n$$\n- Test $4$ (pure shear with orthogonal magnetic induction):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n0  5\\times 10^{-4}  0\\\\\n5\\times 10^{-4}  0  0\\\\\n0  0  0\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0\\\\ 0\\\\ 0.8\n\\end{bmatrix}.\n$$\n\nYour program should, for each test, return a boolean indicating whether all checks pass: the mixed-block symmetry check and the finite-difference validation for each of the four blocks under the specified tolerance $\\tau$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$).",
            "solution": "The user has provided a problem in the field of computational magnetoelasticity. The task is to derive the constitutive relations and the consistent tangent operators from a given thermodynamic potential, and then to implement a numerical verification of these derivations.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Energy Density Function**:\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) \\;=\\; \\mu \\, \\boldsymbol{e}:\\boldsymbol{e} \\;+\\; \\dfrac{\\lambda}{2} \\left(\\operatorname{tr}\\boldsymbol{e}\\right)^2 \\;+\\; \\dfrac{1}{2\\mu_0}\\, \\boldsymbol{B}\\cdot \\boldsymbol{B} \\;+\\; m_s B_0 \\ln\\!\\left(\\cosh\\!\\left(\\dfrac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) \\;-\\; \\gamma \\, \\boldsymbol{B}^{\\mathsf{T}} \\,\\boldsymbol{e}\\, \\boldsymbol{B}\n$$\n- **Constitutive Definitions**:\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{e}}, \\quad \\boldsymbol{H} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{B}}\n$$\n- **Tangent Operator Blocks (Hessian)**:\n$$\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{B}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{B}}\n$$\n- **Numerical Verification Parameters**:\n  - Perturbation for $\\boldsymbol{B}$: $h_{\\boldsymbol{B}} = 10^{-6}$\n  - Perturbation for $\\boldsymbol{e}$: $h_{\\boldsymbol{e}} = 10^{-8}$\n  - Relative tolerance for Frobenius norm error: $\\tau = 10^{-6}$\n- **Material Parameters**:\n  - $\\mu = 60\\times 10^{9}$ Pa\n  - $\\lambda = 90\\times 10^{9}$ Pa\n  - $\\mu_0 = 4\\pi \\times 10^{-7}$ H/m\n  - $m_s = 10^{5}$ A/m\n  - $B_0 = 1.2$ T\n  - $\\gamma = 10^{6}$ (units of $\\text{Pa}/\\text{T}^2$)\n- **Test Cases**: Four specific pairs of $(\\boldsymbol{e}, \\boldsymbol{B})$ are provided.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientifically Grounded**: The problem is set within the framework of continuum mechanics and electromagnetism. The energy function $\\psi$ is a sum of well-established terms: the Saint Venant-Kirchhoff model for linear isotropic elasticity, the magnetic energy in a medium, a Langevin-type function to model magnetic saturation, and a plausible bilinear magneto-structural coupling term. The constitutive laws are standard definitions derived from a thermodynamic potential. The entire setup is consistent with established principles of theoretical and computational physics.\n2.  **Well-Posed**: The tasks are specific mathematical derivations and their numerical verification. Given the explicit functional form of $\\psi$, the required derivatives can be uniquely determined. The verification procedure is deterministic.\n3.  **Objective**: The problem uses precise mathematical notation and provides objective, quantitative criteria for validation (symmetry check and finite-difference comparison against a tolerance).\n4.  **Complete and Consistent**: All necessary mathematical definitions, material parameters, state variables, and verification parameters are provided. There are no apparent contradictions.\n5.  **Feasible and Realistic**: The derivations involve standard tensor calculus. The required verification is a common practice in computational mechanics for validating code a process known as a 'patch test' for the material tangent. The provided parameter values are within realistic ranges for magnetostrictive materials like Terfenol-D or Galfenol, although simplified.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. It is a well-defined, scientifically sound, and complete problem in computational mechanics. I will now proceed with the solution.\n\n### **Task 1: Derivation of Constitutive Relations**\n\nThe energy potential $\\psi$ is given in index notation as:\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) = \\mu e_{ij}e_{ij} + \\frac{\\lambda}{2} (e_{kk})^2 + \\frac{1}{2\\mu_0} B_k B_k + m_s B_0 \\ln\\left(\\cosh\\left(\\frac{\\sqrt{B_k B_k}}{B_0}\\right)\\right) - \\gamma B_i e_{ij} B_j\n$$\nThe small strain tensor $\\boldsymbol{e}$ is symmetric, i.e., $e_{ij} = e_{ji}$. We use the definition for the derivative of a scalar function with respect to a symmetric tensor variable $\\boldsymbol{e}$:\n$$\n\\left(\\frac{\\partial f}{\\partial \\boldsymbol{e}}\\right)_{ij} = \\frac{1}{2} \\left( \\frac{\\partial f}{\\partial E_{ij}} + \\frac{\\partial f}{\\partial E_{ji}} \\right) \\bigg|_{\\boldsymbol{E}=\\boldsymbol{e}}\n$$\nwhere $\\boldsymbol{E}$ is a general, non-symmetric tensor.\n\n**Cauchy Stress Tensor, $\\boldsymbol{\\sigma}$**:\n$$\n\\sigma_{ij} = \\frac{\\partial \\psi}{\\partial e_{ij}}\n$$\nWe differentiate $\\psi$ term-by-term with respect to $e_{ij}$:\n1.  $\\dfrac{\\partial}{\\partial e_{ij}} (\\mu e_{kl}e_{kl}) = 2\\mu e_{ij}$\n2.  $\\dfrac{\\partial}{\\partial e_{ij}} \\left(\\dfrac{\\lambda}{2} (e_{kk})^2\\right) = \\lambda e_{kk} \\dfrac{\\partial e_{mm}}{\\partial e_{ij}} = \\lambda (\\operatorname{tr}\\boldsymbol{e}) \\delta_{ij}$\n3.  Magnetic terms are independent of $\\boldsymbol{e}$.\n4.  $\\dfrac{\\partial}{\\partial e_{ij}} (-\\gamma B_k e_{kl} B_l) = -\\gamma B_k \\left(\\dfrac{\\partial e_{kl}}{\\partial e_{ij}}\\right) B_l$. Since $\\boldsymbol{e}$ is symmetric, this derivative yields $-\\gamma B_i B_j$.\n\nCombining these terms gives the stress tensor:\n$$\n\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B}) = 2\\mu\\boldsymbol{e} + \\lambda(\\operatorname{tr}\\boldsymbol{e})\\boldsymbol{I} - \\gamma \\boldsymbol{B}\\otimes\\boldsymbol{B}\n$$\nIn component form:\n$$\n\\sigma_{ij} = 2\\mu e_{ij} + \\lambda e_{kk} \\delta_{ij} - \\gamma B_i B_j\n$$\n\n**Magnetic Field, $\\boldsymbol{H}$**:\n$$\nH_i = \\frac{\\partial \\psi}{\\partial B_i}\n$$\nWe differentiate $\\psi$ with respect to $B_i$:\n1.  $\\dfrac{\\partial}{\\partial B_i} \\left(\\dfrac{1}{2\\mu_0} B_k B_k \\right) = \\dfrac{1}{\\mu_0} B_i$\n2.  Let $\\|\\boldsymbol{B}\\| = \\sqrt{B_k B_k}$. $\\dfrac{\\partial \\|\\boldsymbol{B}\\|}{\\partial B_i} = \\dfrac{B_i}{\\|\\boldsymbol{B}\\|}$.\n    $\\dfrac{\\partial}{\\partial B_i} \\left( m_s B_0 \\ln\\cosh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\right) = m_s B_0 \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\dfrac{\\partial}{\\partial B_i}\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) = m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\dfrac{B_i}{\\|\\boldsymbol{B}\\|}$\n3.  $\\dfrac{\\partial}{\\partial B_i} (-\\gamma B_k e_{kl} B_l) = -\\gamma ( \\delta_{ik} e_{kl} B_l + B_k e_{kl} \\delta_{il} ) = -\\gamma (e_{il}B_l + B_k e_{ki})$. Since $\\boldsymbol{e}$ is symmetric, this is $-2\\gamma e_{ik}B_k$.\n\nCombining these terms gives the magnetic field:\n$$\n\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B}) = \\frac{1}{\\mu_0} \\boldsymbol{B} + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{\\boldsymbol{B}}{\\|\\boldsymbol{B}\\|} - 2\\gamma \\boldsymbol{e}\\boldsymbol{B}\n$$\nIn component form:\n$$\nH_i = \\frac{1}{\\mu_0} B_i + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|} - 2\\gamma e_{ik}B_k\n$$\nFor the case $\\|\\boldsymbol{B}\\| \\to 0$, we use the approximation $\\tanh(x) \\approx x$, so the second term becomes $m_s (\\|\\boldsymbol{B}\\|/B_0) (\\boldsymbol{B}/\\|\\boldsymbol{B}\\|) = (m_s/B_0)\\boldsymbol{B}$, ensuring numerical stability.\n\n### **Task 2: Derivation of Tangent Operators**\n\n**Elasticity Tensor, $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial e_{kl}}\n$$\nDifferentiating $\\sigma_{ij} = 2\\mu e_{ij} + \\lambda e_{mm}\\delta_{ij} - \\gamma B_i B_j$ with respect to $e_{kl}$:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = 2\\mu \\frac{\\partial e_{ij}}{\\partial e_{kl}} + \\lambda \\delta_{ij} \\frac{\\partial e_{mm}}{\\partial e_{kl}}\n$$\nUsing the standard derivative identity for symmetric tensors, $\\frac{\\partial e_{ij}}{\\partial e_{kl}} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$ and $\\frac{\\partial e_{mm}}{\\partial e_{kl}} = \\delta_{kl}$:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\mu(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\lambda\\delta_{ij}\\delta_{kl}\n$$\nThis is the standard fourth-order stiffness tensor for a linear isotropic material.\n\n**Piezo-type Coupling Tensor, $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = \\frac{\\partial \\sigma_{ij}}{\\partial B_k}\n$$\nDifferentiating $\\sigma_{ij}$ with respect to $B_k$:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = \\frac{\\partial}{\\partial B_k} (-\\gamma B_i B_j) = -\\gamma (\\delta_{ik}B_j + B_i\\delta_{jk})\n$$\n\n**Piezomagnetic-type Coupling Tensor, $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = \\frac{\\partial H_k}{\\partial e_{ij}}\n$$\nDifferentiating $H_k = \\frac{1}{\\mu_0} B_k + \\dots - 2\\gamma e_{km}B_m$ with respect to $e_{ij}$:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = \\frac{\\partial}{\\partial e_{ij}} (-2\\gamma e_{km}B_m) = -2\\gamma \\frac{\\partial e_{km}}{\\partial e_{ij}} B_m = -2\\gamma \\frac{1}{2}(\\delta_{ki}\\delta_{mj} + \\delta_{kj}\\delta_{mi}) B_m = -\\gamma(\\delta_{ki}B_j + \\delta_{kj}B_i)\n$$\nAs expected from Maxwell symmetry for a potential-based formulation, $(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = (\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij}$.\n\n**Inverse Magnetic Permeability Tensor, $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\frac{\\partial H_i}{\\partial B_j}\n$$\nDifferentiating $H_i$ with respect to $B_j$:\n1.  $\\dfrac{\\partial}{\\partial B_j} \\left(\\dfrac{1}{\\mu_0} B_i\\right) = \\dfrac{1}{\\mu_0}\\delta_{ij}$\n2.  $\\dfrac{\\partial}{\\partial B_j} (-2\\gamma e_{ik}B_k) = -2\\gamma e_{ik}\\delta_{kj} = -2\\gamma e_{ij}$\n3.  Let the saturation term be $\\boldsymbol{H}_{\\text{sat}} = m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{\\boldsymbol{B}}{\\|\\boldsymbol{B}\\|}$. Differentiating with the product rule:\n$$\n\\frac{\\partial (H_{\\text{sat}})_i}{\\partial B_j} = m_s \\left[ \\frac{\\partial}{\\partial B_j}\\left(\\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|} + \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{\\partial}{\\partial B_j}\\left(\\frac{B_i}{\\|\\boldsymbol{B}\\|}\\right) \\right]\n$$\nUsing derivatives from Task 1:\n$$\n= m_s \\left[ \\frac{\\text{sech}^2\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{B_0} \\frac{B_j}{\\|\\boldsymbol{B}\\|} \\frac{B_i}{\\|\\boldsymbol{B}\\|} + \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\left(\\frac{\\delta_{ij}}{\\|\\boldsymbol{B}\\|} - \\frac{B_i B_j}{\\|\\boldsymbol{B}\\|^3}\\right) \\right]\n$$\n$$\n= \\frac{m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|} \\delta_{ij} + m_s \\left[ \\frac{\\text{sech}^2\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{B_0 \\|\\boldsymbol{B}\\|^2} - \\frac{\\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|^3} \\right] B_i B_j\n$$\nCombining all terms, we get:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\left(\\frac{1}{\\mu_0} + \\frac{m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|}\\right) \\delta_{ij} - 2\\gamma e_{ij} + m_s \\left[ \\frac{\\text{sech}^2\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{B_0 \\|\\boldsymbol{B}\\|^2} - \\frac{\\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|^3} \\right] B_i B_j\n$$\nFor $\\|\\boldsymbol{B}\\| \\to 0$, we use Taylor series expansions to find the limit.\n-   $\\frac{\\tanh(x)}{x} \\approx 1 - \\frac{x^2}{3}$. So $\\frac{\\tanh(\\|\\boldsymbol{B}\\|/B_0)}{\\|\\boldsymbol{B}\\|} \\to \\frac{1}{B_0}$.\n-   The coefficient of $B_i B_j$ has a more complex limit, but since it is multiplied by $B_i B_j$, the entire term vanishes as $\\|\\boldsymbol{B}\\| \\to 0$.\nThe limiting expression is:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} \\to \\left(\\frac{1}{\\mu_0} + \\frac{m_s}{B_0}\\right)\\delta_{ij} - 2\\gamma e_{ij}\n$$\n\n### **Tasks 3  4: Implementation and Verification**\n\nThe implementation will translate these analytical expressions into Python code using NumPy. The verification will proceed as follows:\n-   **Symmetry**: The components $(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk}$ will be compared to $(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij}$ for all $i,j,k$.\n-   **Finite Difference (FD)**: Each block of the analytical Hessian will be compared against a central finite-difference approximation. Let $\\boldsymbol{y} \\in \\{\\boldsymbol{\\sigma}, \\boldsymbol{H}\\}$ and $\\boldsymbol{x} \\in \\{\\boldsymbol{e}, \\boldsymbol{B}\\}$. The derivative $\\partial \\boldsymbol{y} / \\partial \\boldsymbol{x}$ is approximated by perturbing each component of $\\boldsymbol{x}$. For the symmetric tensor $\\boldsymbol{e}$, a perturbation in the component $e_{kl}$ for $k \\neq l$ requires a symmetric perturbation matrix $\\Delta \\boldsymbol{e}$ with non-zero elements $\\Delta e_{kl} = \\Delta e_{lk} = h_{\\boldsymbol{e}}$. The FD formula for this case, $( \\boldsymbol{y}(\\boldsymbol{x} + \\Delta\\boldsymbol{x}) - \\boldsymbol{y}(\\boldsymbol{x} - \\Delta\\boldsymbol{x}) ) / (2 h)$, approximates $\\partial \\boldsymbol{y}/\\partial x_k$ for a vector component $x_k$ or a diagonal tensor component $e_{kk}$. For an off-diagonal component $e_{kl}$, it approximates $(\\partial \\boldsymbol{y}/\\partial e_{kl} + \\partial \\boldsymbol{y}/\\partial e_{lk})$, which is $2 \\partial \\boldsymbol{y}/\\partial e_{kl}$ due to symmetry. This factor of $2$ must be accounted for in the comparison. The error is measured using the Frobenius norm.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and verifies the tangent operators for a magnetoelastic constitutive model.\n    \"\"\"\n\n    # --- Material Parameters ---\n    params = {\n        \"mu\": 60e9,\n        \"lambda_\": 90e9,\n        \"mu0\": 4 * np.pi * 1e-7,\n        \"ms\": 1e5,\n        \"B0\": 1.2,\n        \"gamma\": 1e6,\n    }\n\n    # --- Numerical Parameters for Verification ---\n    h_e = 1e-8\n    h_B = 1e-6\n    tolerance = 1e-6\n    norm_B_eps = 1e-15 # Threshold for B-0 limit\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"e\": np.array([\n                [1e-3, 2e-4, -1e-4],\n                [2e-4, -5e-4, 3e-4],\n                [-1e-4, 3e-4, 2e-4]\n            ]),\n            \"B\": np.array([0.3, -0.1, 0.2]),\n        },\n        {\n            \"e\": np.array([\n                [1e-6, 0, 0],\n                [0, -2e-6, 0],\n                [0, 0, 1.5e-6]\n            ]),\n            \"B\": np.array([1e-12, -2e-12, 3e-12]),\n        },\n        {\n            \"e\": np.array([\n                [5e-4, -1e-4, 2e-4],\n                [-1e-4, 4e-4, -2e-4],\n                [2e-4, -2e-4, -3e-4]\n            ]),\n            \"B\": np.array([1.5, 0.5, -1.0]),\n        },\n        {\n            \"e\": np.array([\n                [0, 5e-4, 0],\n                [5e-4, 0, 0],\n                [0, 0, 0]\n            ]),\n            \"B\": np.array([0, 0, 0.8]),\n        },\n    ]\n\n    # --- Constitutive Model Implementation ---\n\n    def get_sigma(e, B, p):\n        \"\"\"Computes the Cauchy stress tensor sigma.\"\"\"\n        tr_e = np.trace(e)\n        I = np.identity(3)\n        B_outer_B = np.outer(B, B)\n        sigma = 2 * p[\"mu\"] * e + p[\"lambda_\"] * tr_e * I - p[\"gamma\"] * B_outer_B\n        return sigma\n\n    def get_H(e, B, p):\n        \"\"\"Computes the magnetic field H.\"\"\"\n        norm_B = np.linalg.norm(B)\n        \n        term1 = (1 / p[\"mu0\"]) * B\n        \n        if norm_B  norm_B_eps:\n            term2 = (p[\"ms\"] / p[\"B0\"]) * B\n        else:\n            term2 = p[\"ms\"] * np.tanh(norm_B / p[\"B0\"]) * (B / norm_B)\n\n        term3 = -2 * p[\"gamma\"] * e @ B\n        \n        return term1 + term2 + term3\n\n    def get_tangents(e, B, p):\n        \"\"\"Computes all four analytical tangent operator blocks.\"\"\"\n        I = np.identity(3)\n        \n        # C_ee (4th-order tensor)\n        C_ee = np.zeros((3, 3, 3, 3))\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    for l in range(3):\n                        term1 = p[\"mu\"] * (I[i, k] * I[j, l] + I[i, l] * I[j, k])\n                        term2 = p[\"lambda_\"] * I[i, j] * I[k, l]\n                        C_ee[i, j, k, l] = term1 + term2\n\n        # C_eB (3rd-order tensor)\n        C_eB = np.zeros((3, 3, 3))\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    C_eB[i, j, k] = -p[\"gamma\"] * (I[i, k] * B[j] + I[j, k] * B[i])\n\n        # C_Be (3rd-order tensor)\n        C_Be = np.zeros((3, 3, 3))\n        for k in range(3):\n            for i in range(3):\n                for j in range(3):\n                    C_Be[k, i, j] = -p[\"gamma\"] * (I[k, i] * B[j] + I[k, j] * B[i])\n        \n        # C_BB (2nd-order tensor)\n        norm_B = np.linalg.norm(B)\n        B_outer_B = np.outer(B, B)\n\n        if norm_B  norm_B_eps:\n            term_mag_diag = (1 / p[\"mu0\"] + p[\"ms\"] / p[\"B0\"]) * I\n            term_mag_off_diag = np.zeros((3, 3))\n        else:\n            u = norm_B / p[\"B0\"]\n            tanh_u = np.tanh(u)\n            sech_u_sq = 1 - tanh_u**2\n\n            coeff_diag = p[\"ms\"] * tanh_u / norm_B\n            term_mag_diag = (1 / p[\"mu0\"] + coeff_diag) * I\n            \n            coeff_off_diag = p[\"ms\"] * (sech_u_sq / (p[\"B0\"] * norm_B**2) - tanh_u / norm_B**3)\n            term_mag_off_diag = coeff_off_diag * B_outer_B\n        \n        C_BB = term_mag_diag + term_mag_off_diag - 2 * p[\"gamma\"] * e\n        \n        return C_ee, C_eB, C_Be, C_BB\n\n    def verify(e, B, p):\n        \"\"\"Performs all verification checks for a given state.\"\"\"\n        C_ee, C_eB, C_Be, C_BB = get_tangents(e, B, p)\n        \n        results = {}\n\n        # 1. Symmetry Check: C_eB_ijk == C_Be_kij\n        C_Be_transposed = np.transpose(C_Be, (1, 2, 0)) # from (k,i,j) to (i,j,k)\n        results['symm_check'] = np.allclose(C_eB, C_Be_transposed, rtol=tolerance, atol=1e-9)\n\n        # 2. FD check for C_ee\n        C_ee_fd = np.zeros((3,3,3,3))\n        for k in range(3):\n            for l in range(3):\n                dE = np.zeros((3,3))\n                dE[k,l] += h_e\n                if k != l:\n                    dE[l,k] += h_e\n                \n                sigma_p = get_sigma(e + dE, B, p)\n                sigma_m = get_sigma(e - dE, B, p)\n\n                # The FD approximates d(sigma)/d(E_kl) + d(sigma)/d(E_lk).\n                # For k=l, this is d(sigma)/d(e_kk).\n                # For k!=l, this is 2 * d(sigma)/d(e_kl).\n                # The FD formula is (f(x+h) - f(x-h)) / (2h)\n                # We perturb e_kl and e_lk by h_e.\n                # So the FD result approximates d(sigma_ij)/d(e_kl)\n                \n                fd_deriv = (sigma_p - sigma_m) / (2 * h_e)\n                if k != l:\n                    fd_deriv /= 2.0\n                C_ee_fd[:,:,k,l] = fd_deriv\n        \n        norm_C_ee = np.linalg.norm(C_ee)\n        err_ee = np.linalg.norm(C_ee_fd - C_ee) / norm_C_ee if norm_C_ee > 1e-12 else np.linalg.norm(C_ee_fd - C_ee)\n        results['C_ee_check'] = err_ee  tolerance\n        \n        # 3. FD check for C_eB\n        C_eB_fd = np.zeros((3,3,3))\n        for k in range(3):\n            dB = np.zeros(3)\n            dB[k] = h_B\n            sigma_p = get_sigma(e, B + dB, p)\n            sigma_m = get_sigma(e, B - dB, p)\n            C_eB_fd[:,:,k] = (sigma_p - sigma_m) / (2 * h_B)\n        \n        norm_C_eB = np.linalg.norm(C_eB)\n        err_eB = np.linalg.norm(C_eB_fd - C_eB) / norm_C_eB if norm_C_eB > 1e-12 else np.linalg.norm(C_eB_fd - C_eB)\n        results['C_eB_check'] = err_eB  tolerance\n        \n        # 4. FD check for C_Be\n        C_Be_fd = np.zeros((3,3,3))\n        for i in range(3):\n            for j in range(3):\n                dE = np.zeros((3,3))\n                dE[i,j] += h_e\n                if i != j:\n                    dE[j,i] += h_e\n                \n                H_p = get_H(e + dE, B, p)\n                H_m = get_H(e - dE, B, p)\n                \n                fd_deriv = (H_p - H_m) / (2 * h_e)\n                if i != j:\n                    fd_deriv /= 2.0\n                C_Be_fd[:,i,j] = fd_deriv\n        \n        norm_C_Be = np.linalg.norm(C_Be)\n        err_Be = np.linalg.norm(C_Be_fd - C_Be) / norm_C_Be if norm_C_Be > 1e-12 else np.linalg.norm(C_Be_fd - C_Be)\n        results['C_Be_check'] = err_Be  tolerance\n        \n        # 5. FD check for C_BB\n        C_BB_fd = np.zeros((3,3))\n        for j in range(3):\n            dB = np.zeros(3)\n            dB[j] = h_B\n            H_p = get_H(e, B + dB, p)\n            H_m = get_H(e, B - dB, p)\n            C_BB_fd[:,j] = (H_p - H_m) / (2 * h_B)\n        \n        norm_C_BB = np.linalg.norm(C_BB)\n        err_BB = np.linalg.norm(C_BB_fd - C_BB) / norm_C_BB if norm_C_BB > 1e-12 else np.linalg.norm(C_BB_fd - C_BB)\n        results['C_BB_check'] = err_BB  tolerance\n        \n        return all(results.values())\n\n    # --- Main Loop ---\n    final_results = []\n    for case in test_cases:\n        e_test = case[\"e\"]\n        e_test = 0.5 * (e_test + e_test.T)\n        all_checks_passed = verify(e_test, case[\"B\"], params)\n        final_results.append(all_checks_passed)\n\n    print(f\"[{','.join(str(r) for r in final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once forces and material responses are defined, the next challenge is to accurately simulate the system's dynamic evolution over time. This practice explores the crucial topic of numerical stability in time-dependent coupled simulations, contrasting a power-consistent scheme with a simpler, 'inconsistent' approach . By analyzing the numerical energy exchange in a discrete time-stepping algorithm, you will gain insight into why certain coupling strategies conserve energy and remain stable, while others can lead to unphysical energy growth and unreliable results.",
            "id": "3304517",
            "problem": "You are to analyze and simulate numerical energy exchange in a lumped electromagneticâstructural system composed of a single-turn coil coupled to a single-degree-of-freedom linear beam. The electric part is treated as a position-dependent inductor with no resistance and no source, updated by a Finite-Difference Time-Domain (FDTD)-consistent invariant, and the structural part is updated by the Newmark family of schemes. Your goal is to implement two time-integration couplings, quantify discrete energy behavior, and identify conditions that avoid artificial energy growth.\n\nThe continuous model is as follows. Let the beam displacement be $x(t)$ in meters and velocity $v(t)$ in meters per second, with mass $m$ in kilograms and stiffness $k$ in newtons per meter. The coil is modeled as an inductor whose inductance depends on the beam displacement, $L(x)$ in henries. Let the coil current be $I(t)$ in amperes and the flux linkage be $\\psi(t)$ in weber-turns. Assume zero electrical resistance and zero voltage source, so that the electric loop equation is the conservation of flux linkage,\n$$\n\\frac{d\\psi}{dt} = 0,\\quad \\text{with}\\quad \\psi(t) = L(x(t))\\,I(t).\n$$\nThe magnetic co-energy is\n$$\nW_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2,\n$$\nand the electromagnetic force acting on the beam is the negative gradient of magnetic co-energy with respect to $x$, which for a scalar state reduces to\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{1}{2} I^2 \\frac{dL}{dx}(x).\n$$\nThe beam equation of motion is\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t)).\n$$\nThe total continuous energy is\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2,\n$$\nwhich is exactly conserved for $d\\psi/dt=0$ and zero damping.\n\nYou will compare two discrete coupling schemes over a fixed time horizon $T$ in seconds:\n- Scheme A (Power-consistent, FDTDâNewmark): enforce the FDTD-consistent invariant by keeping the flux linkage constant, $\\psi^{n+1} = \\psi^{n}$, and use the Newmark trapezoidal rule with parameters $\\beta = 1/4$ and $\\gamma = 1/2$ for the beam. With $\\psi$ held constant, the current is $I(x) = \\psi / L(x)$. Define the acceleration as a function of displacement,\n$$\na(x) = \\frac{1}{m}\\left(\\frac{1}{2}\\,\\frac{\\psi^2}{L(x)^2}\\,\\frac{dL}{dx}(x) - k\\,x\\right).\n$$\nAdvance $x^n \\mapsto x^{n+1}$ by solving the Newmark trapezoidal implicit update\n$$\nx^{n+1} - \\frac{\\Delta t^2}{4}\\,a(x^{n+1}) = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n}),\n$$\nthen set\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right),\\quad I^{n+1} = \\frac{\\psi}{L(x^{n+1})}.\n$$\nUse a Newton iteration to solve for $x^{n+1}$ to numerical convergence at each step. This scheme is designed to be power-conjugate at the discrete level.\n\n- Scheme B (Inconsistent, frozen-current coupling): freeze the current over each step by setting $I^{n+1} = I^{n}$, and evaluate the electromagnetic force using the displacement and current at the beginning of the step,\n$$\nF_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n).\n$$\nAdvance the beam with the same Newmark parameters $\\beta = 1/4$ and $\\gamma = 1/2$, but treating $F_{\\mathrm{em}}^n$ as constant over the step, so that the implicit equation reduces to a linear solve for $x^{n+1}$,\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(\\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right)\\right) + \\frac{\\Delta t^2}{4m} F_{\\mathrm{em}}^{n}}{1 + \\frac{\\Delta t^2}{4}\\frac{k}{m}},\n$$\nfollowed by\n$$\na^{n} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right),\\quad a^{n+1} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n+1}\\right),\\quad v^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right).\n$$\nThis scheme is intentionally not power-conjugate because it freezes the current and evaluates the force at different time than the inductive co-energy.\n\nFor both schemes, compute the discrete total energy at each step $n$,\n$$\nE^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2.\n$$\n\nYour task is to write a program that, for the parameter sets below, simulates the system from $t=0$ to $t=T$ with uniform time step $\\Delta t$ and initial conditions, and returns for each test case the maximum fractional increase of the discrete total energy relative to the initial energy,\n$$\n\\max_{0 \\le n \\le N} \\left(\\frac{E^{n} - E^{0}}{E^{0}}\\right),\n$$\nreported as a dimensionless decimal (no unit), where $N = T/\\Delta t$ is the number of time steps. A value near $0$ indicates no artificial energy growth; a positive value indicates artificial energy growth.\n\nUse the following physically consistent modeling choices:\n- Inductance: $L(x) = L_{0} + \\alpha\\, x$ with $L_{0}  0$ and $\\alpha \\ge 0$, so that $\\frac{dL}{dx} = \\alpha$.\n- No electrical resistance and no external excitation, so $d\\psi/dt = 0$ for Scheme A.\n- No structural damping.\n\nUse the following numerical and physical parameters, with all quantities in the International System of Units (SI). Mass $m$ in kilograms, stiffness $k$ in newtons per meter, inductance $L$ in henries, current $I$ in amperes, time in seconds, displacement $x$ in meters:\n- Common physical parameters: $m = 0.05$, $k = 200$, $L_{0} = 0.001$, $\\alpha = 0.02$.\n- Initial conditions: $x(0) = 0$, $v(0) = 0$, $I(0) = 20$. For Scheme A, set $\\psi(0) = L(x(0))\\,I(0)$ and enforce $\\psi^{n+1} = \\psi^{n}$.\n- Time horizon: $T = 0.01$.\n\nImplement the four test cases:\n- Case $1$: Scheme A with $\\Delta t = 0.0001$.\n- Case $2$: Scheme A with $\\Delta t = 0.0005$.\n- Case $3$: Scheme B with $\\Delta t = 0.0001$.\n- Case $4$: Scheme B with $\\Delta t = 0.0005$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four cases above. Each result is the maximum fractional energy increase as a floating-point number. For example, a valid output format is \"[0.0,0.00123,0.045,0.12]\". Angles are not used in this task. The outputs are dimensionless decimals without units.\n\nConstraints and expectations:\n- Derive your discrete updates from the provided fundamental conservation law for flux linkage and the Newmark method definitions; do not use any other shortcut formulas.\n- Ensure the Newton iteration for Scheme A converges to a tight tolerance so that energy behavior is representative of the method and not numerical error.\n- The simulation must be self-contained and deterministic for the provided parameters.",
            "solution": "The problem requires the simulation of a lumped-parameter electromagneticâstructural system under two different time-integration schemes. The primary objective is to quantify the numerical energy conservation properties of each scheme. The analysis begins with the continuous model, which serves as the ground truth, and proceeds to the discrete implementation and comparison.\n\nThe system's state is described by the mechanical displacement $x(t)$ and velocity $v(t)$, and the electrical current $I(t)$. The core physical principles are the conservation of magnetic flux linkage and Newton's second law of motion.\n\nFor the electrical subsystem, with zero resistance and no voltage source, the governing equation is the conservation of flux linkage $\\psi(t)$:\n$$\n\\frac{d\\psi}{dt} = 0 \\implies \\psi(t) = L(x(t))\\,I(t) = \\text{constant}\n$$\nThe magnetic co-energy, which for a linear magnetic circuit equals the stored magnetic energy, is $W_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2$. The electromagnetic force exerted on the mechanical part is derived from this co-energy:\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{\\partial W_{\\mathrm{m}}}{\\partial x} = \\frac{1}{2} I^2 \\frac{dL}{dx}(x)\n$$\nFor the mechanical subsystem, a single-degree-of-freedom linear oscillator, the equation of motion is:\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t))\n$$\nThe total energy of the continuous system is the sum of the mechanical kinetic energy, mechanical potential (elastic) energy, and the magnetic energy:\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2\n$$\nIn the continuous domain, this total energy is exactly conserved. The rate of change of total energy is $\\frac{dE}{dt} = m\\,v\\,\\dot{v} + k\\,x\\,\\dot{x} + \\frac{1}{2}\\frac{dL}{dx}\\dot{x}\\,I^2 + L\\,I\\,\\frac{dI}{dt}$. Using $m\\ddot{x} + kx = F_{em}$, $\\dot{x}=v$, and $F_{em} = \\frac{1}{2}I^2\\frac{dL}{dx}$, this becomes $\\frac{dE}{dt} = v(F_{em}) + v(F_{em}) + LI\\frac{dI}{dt}$. From constant flux $\\psi=LI$, we have $L\\frac{dI}{dt} = -I\\frac{dL}{dt} = -Iv\\frac{dL}{dx}$, so $I(L\\frac{dI}{dt}) = -vI^2\\frac{dL}{dx} = -2vF_{em}$. Thus, $\\frac{dE}{dt} = vF_{em} + vF_{em} - 2vF_{em} = 0$, confirming conservation.\n\nThe task is to discretize this system using two schemes and compare their energy behavior. Both schemes use the Newmark family of integrators for the mechanical part with parameters $\\beta = 1/4$ and $\\gamma = 1/2$, which corresponds to the trapezoidal rule, known for its favorable energy conservation properties in linear systems. The distinction lies in how the electromagnetic and mechanical parts are coupled.\n\n**Scheme A: Power-Consistent FDTDâNewmark Coupling**\nThis scheme is designed to respect the power conjugacy between the two physical domains at the discrete level, which is a prerequisite for discrete energy conservation. The flux linkage is held constant, $\\psi^{n+1} = \\psi^n = \\psi$, mirroring the continuous invariant. This implies $I(x) = \\psi / L(x)$. The acceleration becomes a nonlinear function of displacement alone:\n$$\na(x) = \\frac{1}{m}\\left( F_{\\mathrm{em}}(x, I(x)) - k\\,x \\right) = \\frac{1}{m}\\left(\\frac{1}{2} \\left(\\frac{\\psi}{L(x)}\\right)^2 \\frac{dL}{dx}(x) - k\\,x\\right)\n$$\nWith the specified inductance $L(x) = L_0 + \\alpha x$ and its derivative $\\frac{dL}{dx} = \\alpha$, this is:\n$$\na(x) = \\frac{1}{m}\\left(\\frac{\\alpha \\psi^2}{2(L_0 + \\alpha x)^2} - k\\,x\\right)\n$$\nThe Newmark trapezoidal rule update for displacement $x^{n+1}$ is implicit and nonlinear:\n$$\nx^{n+1} = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\nThis can be written as a root-finding problem $g(x^{n+1}) = 0$, where:\n$$\ng(z) = z - \\frac{\\Delta t^2}{4}\\,a(z) - \\left(x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n})\\right) = 0\n$$\nThis nonlinear algebraic equation is solved at each time step using Newton's method. The iterative update for the root $z$ is $z_{k+1} = z_k - g(z_k)/g'(z_k)$, where $g'(z) = 1 - \\frac{\\Delta t^2}{4}a'(z)$ and $a'(z) = \\frac{1}{m}(-\\frac{\\alpha^2\\psi^2}{(L_0+\\alpha z)^3} - k)$. A tight convergence tolerance is used to ensure the numerical solution accurately reflects the properties of the scheme itself.\nOnce $x^{n+1}$ is found, the velocity and current are updated:\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n$$\nI^{n+1} = \\frac{\\psi}{L(x^{n+1})}\n$$\nThis monolithic approach, where the full coupled system is solved implicitly, is expected to yield excellent energy conservation.\n\n**Scheme B: Inconsistent, Frozen-Current Coupling**\nThis scheme represents a common but flawed simplification. Instead of enforcing the flux invariant, the current is \"frozen\" over the time step, $I^{n+1} = I^n$. The electromagnetic force is calculated at the beginning of the step, $F_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n)$, and treated as a constant external force throughout the interval $[t^n, t^{n+1}]$.\nThe equation of motion becomes linear within the step: $m a^{n+1} + k x^{n+1} = F_{\\mathrm{em}}^n$. The Newmark update for displacement is:\n$$\nx^{n+1} = x^{n} + \\Delta t v^{n} + \\frac{\\Delta t^2}{4}(a^n + a^{n+1})\n$$\nSubstituting $a^n = (F_{\\mathrm{em}}^n - kx^n)/m$ and $a^{n+1} = (F_{\\mathrm{em}}^n - kx^{n+1})/m$ and solving for $x^{n+1}$ yields the provided explicit update rule:\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4m}(2F_{\\mathrm{em}}^{n} - k\\, x^{n})}{1 + \\frac{k \\Delta t^2}{4m}}\n$$\nThe velocity is then updated using the trapezoidal rule:\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right)\n$$\nThis staggered or explicit coupling breaks the discrete power balance. The work done by the force $F_{\\mathrm{em}}^n$ on the mechanical system is not correctly sourced from the change in stored magnetic energy, leading to an artificial gain or loss of total system energy, which typically manifests as numerical instability or unphysical energy growth.\n\nThe implementation calculates the total discrete energy $E^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2$ at each step for both schemes. The metric for comparison is the maximum fractional energy increase over the simulation horizon, $\\max_{n} ((E^n - E^0)/E^0)$, where $E^0$ is the initial energy. This metric quantifies the degree of artificial energy growth introduced by the numerical scheme.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetic-structural coupling problem for four test cases\n    and prints the maximum fractional energy increase for each.\n    \"\"\"\n    # Common physical parameters (SI units)\n    M = 0.05  # mass (kg)\n    K = 200.0  # stiffness (N/m)\n    L0 = 0.001  # base inductance (H)\n    ALPHA = 0.02  # inductance gradient (H/m)\n    \n    # Initial conditions\n    X0 = 0.0  # initial displacement (m)\n    V0 = 0.0  # initial velocity (m/s)\n    I0 = 20.0  # initial current (A)\n    \n    # Time horizon\n    T_HORIZON = 0.01  # s\n\n    # Define inductance and its derivative\n    def L_func(x):\n        return L0 + ALPHA * x\n    \n    def dLdx_func(x):\n        return ALPHA\n\n    def calculate_energy(x, v, i):\n        return 0.5 * M * v**2 + 0.5 * K * x**2 + 0.5 * L_func(x) * i**2\n\n    def run_simulation(scheme, dt):\n        \"\"\"\n        Runs the time-domain simulation for a given scheme and time step.\n\n        Args:\n            scheme (str): 'A' or 'B' specifying the coupling scheme.\n            dt (float): The time step size.\n\n        Returns:\n            float: The maximum fractional energy increase.\n        \"\"\"\n        x_n, v_n, i_n = X0, V0, I0\n        \n        e0 = calculate_energy(x_n, v_n, i_n)\n        if e0 == 0:  # Avoid division by zero, though not expected here\n            return 0.0\n            \n        max_energy_frac_inc = 0.0\n        n_steps = int(round(T_HORIZON / dt))\n\n        if scheme == 'A':\n            psi = L_func(x_n) * i_n\n            newton_tol = 1e-14\n            max_newton_iter = 20\n            \n            def accel(x):\n                L_val = L_func(x)\n                if L_val = 0: return np.inf # To prevent division by zero in extreme cases\n                fem = 0.5 * (psi**2 / L_val**2) * dLdx_func(x)\n                return (fem - K * x) / M\n\n            def accel_deriv(x):\n                L_val = L_func(x)\n                if L_val = 0: return np.inf\n                fem_deriv = -1.0 * (psi**2 * ALPHA**2) / (L_val**3)\n                return (fem_deriv - K) / M\n\n            for _ in range(n_steps):\n                a_n = accel(x_n)\n                \n                # Newton-Raphson solver for x_{n+1}\n                c_const = x_n + dt * v_n + (dt**2 / 4.0) * a_n\n                x_np1_guess = x_n\n                \n                for _ in range(max_newton_iter):\n                    g = x_np1_guess - (dt**2 / 4.0) * accel(x_np1_guess) - c_const\n                    g_prime = 1.0 - (dt**2 / 4.0) * accel_deriv(x_np1_guess)\n                    if abs(g_prime)  1e-15: # Avoid division by zero\n                        break\n                    delta_x = -g / g_prime\n                    x_np1_guess += delta_x\n                    if abs(delta_x)  newton_tol:\n                        break\n                \n                x_np1 = x_np1_guess\n                a_np1 = accel(x_np1)\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = psi / L_func(x_np1)\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n                \n                x_n, v_n = x_np1, v_np1\n        \n        elif scheme == 'B':\n            for _ in range(n_steps):\n                fem_n = 0.5 * i_n**2 * dLdx_func(x_n)\n                \n                # Explicit update for x_{n+1}\n                numerator = x_n + dt * v_n + (dt**2 / (4.0 * M)) * (2 * fem_n - K * x_n)\n                denominator = 1.0 + (K * dt**2) / (4.0 * M)\n                x_np1 = numerator / denominator\n                \n                a_n = (fem_n - K * x_n) / M\n                a_np1 = (fem_n - K * x_np1) / M\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = i_n\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n\n                x_n, v_n, i_n = x_np1, v_np1, i_np1\n                \n        return max_energy_frac_inc\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('A', 0.0001),  # Case 1\n        ('A', 0.0005),  # Case 2\n        ('B', 0.0001),  # Case 3\n        ('B', 0.0005),  # Case 4\n    ]\n\n    results = []\n    for scheme, dt in test_cases:\n        result = run_simulation(scheme, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}