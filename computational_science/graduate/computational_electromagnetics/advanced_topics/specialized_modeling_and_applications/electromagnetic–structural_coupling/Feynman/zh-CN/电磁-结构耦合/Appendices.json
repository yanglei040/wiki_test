{
    "hands_on_practices": [
        {
            "introduction": "为了对电磁-结构相互作用进行计算建模，我们首先必须将连续的物理力转化为离散的数值格式。这项基础实践将指导您在有限元法 (FEM) 框架内推导洛伦兹力的单元级耦合矩阵，从而为连接仿真中的电磁域和机械域提供关键的构件。",
            "id": "3304507",
            "problem": "一个二维磁弹性体占据平面中的一个多边形域，厚度为单位1。在小变形、准静态静磁学、线性和各向同性磁性材料以及可忽略的磁致伸缩的假设下，电磁场和结构通过洛伦兹体力密度弱耦合。从静磁学的麦克斯韦方程组和连续介质力学中的虚功原理出发，推导将电磁自由度映射到单个线性三角形单元的机械节点力向量的单元级耦合。然后实现推导出的表达式，以计算下方测试套件指定的单元级耦合矩阵或一致性机械节点力向量。所有计算必须假设单元厚度为单位1，且单元内的电流密度恒定。当要求计算机械力时，最终答案以牛顿为单位表示，并四舍五入到六位小数。\n\n基本出发点和建模假设：\n- 使用磁矢量势的静磁学，其中磁通量密度满足 $\\nabla \\times \\mathbf{A} = \\mathbf{B}$ 和旋度方程 $\\nabla \\times \\mathbf{H} = \\mathbf{J}$，其中 $\\mathbf{B} = \\mu \\mathbf{H}$ 且 $\\mu$ 为恒定标量。\n- 二维中的平面外磁矢量势表示：$\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$，因此 $\\mathbf{B} = \\nabla \\times \\left(A_z \\hat{\\mathbf{k}}\\right)$。\n- 电流密度是平面外的，并且在每个单元上是恒定的：$\\mathbf{J} = J_z \\hat{\\mathbf{k}}$，其中 $J_z$ 是一个单元常数。\n- 由电磁体力密度引起的机械虚功由 $\\delta W = \\int_{\\Omega} \\delta \\mathbf{u} \\cdot \\left(\\mathbf{J} \\times \\mathbf{B}\\right)\\, \\mathrm{d}\\Omega$ 给出，忽略单元边界上的麦克斯韦表面牵引力。\n- 采用有限元法 (FEM)，在节点索引为 $i \\in \\{1,2,3\\}$、坐标为 $(x_i,y_i)$ 的单个三角形上使用线性形函数。磁矢量势近似为 $A_z(x,y) \\approx \\sum_{i=1}^3 N_i(x,y)\\, a_i$，其中 $a_i$ 是节点值，$N_i$ 是标量形函数。机械位移插值使用相同的形函数 $N_i$，每个节点有两个位移分量。\n\n推导目标：\n- 从上述基础出发，对于一个线性三角形单元，推导磁通量密度分量 $\\left(B_x, B_y\\right)$ 关于形函数梯度和节点磁势值 $\\{a_i\\}_{i=1}^3$ 的显式表达式。\n- 使用洛伦兹力密度 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 和 $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$，用节点磁势值 $\\{a_i\\}_{i=1}^3$ 表示 $\\mathbf{f}$。\n- 通过将虚功与机械形函数进行积分，推导单元的一致性节点机械力向量 $\\mathbf{F}_e \\in \\mathbb{R}^{6}$，并得到将磁节点向量 $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ 映射到 $\\mathbf{F}_e$ 的 $6 \\times 3$ 耦合矩阵 $C_e$，即 $\\mathbf{F}_e = C_e \\mathbf{a}_e$。假设单元厚度为单位1，且 $J_z$ 在单元上是常数。不要对三角形的任何特殊方向做假设。\n\n计算任务：\n- 为节点坐标为 $\\left(x_i, y_i\\right)$（$i \\in \\{1,2,3\\}$）且单元上 $J_z$ 为常数的单个线性三角形单元，实现推导出的表达式。\n- 如果测试用例要求计算耦合矩阵，则以行主序展开输出矩阵项：行对应于按 $\\left[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}\\right]$ 顺序排列的机械自由度，列对应于 $\\left[a_1, a_2, a_3\\right]$。\n- 如果测试用例要求计算机械节点力向量，则计算 $\\mathbf{F}_e = C_e \\mathbf{a}_e$ 并将其作为长度为6的列表输出，顺序为 $\\left[F_{1x}, F_{1y}, F_{2x}, F_{2y}, F_{3x}, F_{3y}\\right]$。\n- 单位和舍入：\n  - 坐标 $\\left(x_i,y_i\\right)$ 单位为米。\n  - 电流密度 $J_z$ 单位为安培每平方米 $\\left(\\mathrm{A}/\\mathrm{m}^2\\right)$。\n  - 磁矢量势节点值 $a_i$ 单位为韦伯每米 $\\left(\\mathrm{Wb}/\\mathrm{m}\\right)$。\n  - 单元厚度为单位1米，因此得到的节点力单位为牛顿 $\\left(\\mathrm{N}\\right)$。\n  - 所有数值输出必须四舍五入到 $6$ 位小数。\n- 本问题不使用角度单位。\n- 程序必须生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个结果本身也是一个由方括号括起来的逗号分隔列表。对于耦合矩阵，按行主序输出展开的条目；对于力向量，按顺序输出六个条目。例如，输出格式类似于 $\\left[\\,[\\ldots],\\,[\\ldots],\\,\\ldots\\,\\right]$，不含空格，所有数字四舍五入到 $6$ 位小数。\n\n测试套件：\n- 测试用例 1 (耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=2.0$。\n- 测试用例 2 (力向量): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=1.0$, $\\left[a_1,a_2,a_3\\right]=[0.0,1.0,0.0]$。\n- 测试用例 3 (零耦合): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=0.0$。\n- 测试用例 4 (缩放几何，耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(2,1)$, $\\left(x_2,y_2\\right)=(5,1)$, $\\left(x_3,y_3\\right)=(2,4)$, $J_z=3.0$。\n- 测试用例 5 (负电流，耦合矩阵): $\\mathrm{mode}=\\text{\"matrix\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(1,0)$, $\\left(x_3,y_3\\right)=(0,1)$, $J_z=-1.5$。\n- 测试用例 6 (非正交三角形上的力向量): $\\mathrm{mode}=\\text{\"force\"}$, $\\left(x_1,y_1\\right)=(0,0)$, $\\left(x_2,y_2\\right)=(2,0)$, $\\left(x_3,y_3\\right)=(1,1.7320508075688772)$, $J_z=0.5$, $\\left[a_1,a_2,a_3\\right]=[0.0,2.0,-0.7320508075688772]$。\n\n您的程序应生成单行输出，其中包含结果，格式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身也包含在方括号内，并且所有浮点数都四舍五入到 $6$ 位小数，例如：$\\left[\\,[r_{1,1},\\ldots,r_{1,n_1}],\\,[r_{2,1},\\ldots,r_{2,n_2}],\\ldots\\,\\right]$，其中每个 $r_{k,j}$ 是一个四舍五入到 $6$ 位小数的浮点数。",
            "solution": "本任务是推导并实现将电磁自由度（节点磁矢量势）映射到线性三角形单元的机械节点力的单元级耦合。该耦合源于二维准静态磁-结构模型中的洛伦兹体力。\n\n### 耦合矩阵的推导\n\n推导过程分三步进行：\n1.  用节点磁矢量势值 $\\mathbf{a}_e$ 表示磁通量密度 $\\mathbf{B}$。\n2.  使用先前得到的 $\\mathbf{B}$ 的表达式，推导洛伦兹体力密度 $\\mathbf{f}$。\n3.  使用虚功原理求出一致性节点力向量 $\\mathbf{F}_e$，并提取耦合矩阵 $C_e$。\n\n**1. 磁通量密度 $\\mathbf{B}$**\n\n问题假设在一个二维模型中，磁矢量势 $\\mathbf{A}$ 只有一个平面外分量，$\\mathbf{A} = A_z(x,y)\\,\\hat{\\mathbf{k}}$。磁通量密度 $\\mathbf{B}$ 由 $\\mathbf{A}$ 的旋度给出：\n$$\n\\mathbf{B} = \\nabla \\times \\mathbf{A} = \\nabla \\times (A_z\\,\\hat{\\mathbf{k}}) = \\begin{vmatrix} \\hat{\\mathbf{i}} & \\hat{\\mathbf{j}} & \\hat{\\mathbf{k}} \\\\ \\frac{\\partial}{\\partial x} & \\frac{\\partial}{\\partial y} & \\frac{\\partial}{\\partial z} \\\\ 0 & 0 & A_z \\end{vmatrix} = \\frac{\\partial A_z}{\\partial y} \\hat{\\mathbf{i}} - \\frac{\\partial A_z}{\\partial x} \\hat{\\mathbf{j}}\n$$\n因此，磁通量密度的平面内分量为 $B_x = \\frac{\\partial A_z}{\\partial y}$ 和 $B_y = -\\frac{\\partial A_z}{\\partial x}$。\n\n在一个线性三角形有限元内，场 $A_z(x,y)$ 是通过使用线性形函数 $N_i(x,y)$ 从其节点值 $\\{a_1, a_2, a_3\\}$ 插值得到的：\n$$\nA_z(x,y) \\approx \\sum_{i=1}^{3} N_i(x,y) a_i\n$$\n$A_z$ 的梯度则为：\n$$\n\\nabla A_z = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\sum_{i=1}^{3} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} a_i\n$$\n对于节点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的线性三角形单元，形函数的梯度在整个单元上是恒定的。它们由以下公式给出：\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2 A_e}, \\quad \\frac{\\partial N_i}{\\partial y} = \\frac{d_i}{2 A_e}\n$$\n其中 $A_e$ 是单元的面积，系数 $b_i$ 和 $d_i$ 是节点坐标的函数：\n$$\n\\begin{array}{ll}\nb_1 = y_2 - y_3, & d_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1, & d_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2, & d_3 = x_2 - x_1\n\\end{array}\n$$\n梯度 $\\nabla A_z$ 可以写成矩阵形式：\n$$\n\\nabla A_z = \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} = \\mathbf{B}_{mat} \\mathbf{a}_e\n$$\n由于 $\\mathbf{B}_{mat}$ 和 $\\mathbf{a}_e$ 在单元内相对于 $(x,y)$ 是常数，$\\nabla A_z$ 也是常数。因此，磁通量密度 $\\mathbf{B}$ 在整个单元上也是恒定的：\n$$\n\\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix} = \\begin{pmatrix} \\frac{\\partial A_z}{\\partial y} \\\\ -\\frac{\\partial A_z}{\\partial x} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\mathbf{B}_{mat} \\mathbf{a}_e = \\frac{1}{2 A_e} \\begin{bmatrix} d_1 & d_2 & d_3 \\\\ -b_1 & -b_2 & -b_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n\n**2. 洛伦兹力密度 $\\mathbf{f}$**\n\n洛伦兹体力密度由 $\\mathbf{f} = \\mathbf{J} \\times \\mathbf{B}$ 给出。电流密度 $\\mathbf{J}$ 假设为恒定且平面外的，即 $\\mathbf{J} = J_z \\hat{\\mathbf{k}}$。\n$$\n\\mathbf{f} = (J_z \\hat{\\mathbf{k}}) \\times (B_x \\hat{\\mathbf{i}} + B_y \\hat{\\mathbf{j}}) = J_z B_x (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{i}}) + J_z B_y (\\hat{\\mathbf{k}} \\times \\hat{\\mathbf{j}}) = J_z B_x \\hat{\\mathbf{j}} - J_z B_y \\hat{\\mathbf{i}}\n$$\n力密度的分量为 $f_x = -J_z B_y$ 和 $f_y = J_z B_x$。以向量形式表示：\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{pmatrix} -B_y \\\\ B_x \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{pmatrix} B_x \\\\ B_y \\end{pmatrix}\n$$\n将用 $\\nabla A_z$ 表示的 $\\mathbf{B}$ 的表达式代入：\n$$\n\\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = J_z \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{pmatrix} \\frac{\\partial A_z}{\\partial x} \\\\ \\frac{\\partial A_z}{\\partial y} \\end{pmatrix} = J_z \\nabla A_z\n$$\n所以，力密度与磁矢量势的梯度成正比，$\\mathbf{f} = J_z \\mathbf{B}_{mat} \\mathbf{a}_e$。由于 $\\nabla A_z$ 在单元上是常数，所以 $\\mathbf{f}$ 也是常数。\n\n**3. 节点力向量 $\\mathbf{F}_e$ 和耦合矩阵 $C_e$**\n\n等效节点力由虚功原理推导得出。体力所做的虚功为：\n$$\n\\delta W = \\int_{V_e} \\delta \\mathbf{u} \\cdot \\mathbf{f} \\, dV\n$$\n其中 $\\delta\\mathbf{u}$ 是虚位移场。在有限元法框架中，位移场 $\\mathbf{u}$ 使用与 $A_z$ 相同的形函数进行插值：\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} \\mathbf{u}_e = \\mathbf{N}(x,y) \\mathbf{u}_e\n$$\n其中 $\\mathbf{u}_e \\in \\mathbb{R}^6$ 是节点位移向量。虚功变为：\n$$\n\\delta W = \\int_{V_e} (\\mathbf{N} \\delta\\mathbf{u}_e)^T \\mathbf{f} \\, dV = \\delta\\mathbf{u}_e^T \\left( \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV \\right)\n$$\n根据定义，$\\delta W = \\delta\\mathbf{u}_e^T \\mathbf{F}_e$，所以一致性节点力向量为：\n$$\n\\mathbf{F}_e = \\int_{V_e} \\mathbf{N}^T \\mathbf{f} \\, dV\n$$\n对于厚度为单位1 ($t=1$) 的二维问题，体积分变为面积分，$dV = t \\, dA = dA$。由于力密度 $\\mathbf{f}$ 在单元上是常数，我们可以将其从积分中提出：\n$$\n\\mathbf{F}_e = \\left( \\int_{A_e} \\mathbf{N}^T \\, dA \\right) \\mathbf{f}\n$$\n形函数矩阵 $\\mathbf{N}^T$ 的积分为：\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\int_{A_e} \\begin{bmatrix} N_1 & 0 \\\\ 0 & N_1 \\\\ N_2 & 0 \\\\ 0 & N_2 \\\\ N_3 & 0 \\\\ 0 & N_3 \\end{bmatrix} dA = \\begin{bmatrix} \\int N_1 dA & 0 \\\\ 0 & \\int N_1 dA \\\\ \\vdots & \\vdots \\\\ \\int N_3 dA & 0 \\\\ 0 & \\int N_3 dA \\end{bmatrix}\n$$\n一个线性形函数在其三角形单元上的积分为 $\\int_{A_e} N_i \\, dA = A_e/3$。因此：\n$$\n\\int_{A_e} \\mathbf{N}^T dA = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n$$\n将此结果和 $\\mathbf{f}$ 的表达式代入 $\\mathbf{F}_e$ 的方程：\n$$\n\\mathbf{F}_e = \\frac{A_e}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( J_z \\mathbf{B}_{mat} \\mathbf{a}_e \\right) = \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e\n$$\n问题指定单位厚度为 $t=1\\,\\text{m}$。量纲分析要求包含这个厚度。力的完整表达式是 $\\mathbf{F}_e = t \\frac{A_e}{3} ...$。\n$$\n\\mathbf{F}_e = t \\frac{A_e J_z}{3} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\left( \\frac{1}{2 A_e} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\right) \\mathbf{a}_e = \\frac{t J_z}{6} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\vdots & \\vdots \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix} \\begin{bmatrix} b_1 & b_2 & b_3 \\\\ d_1 & d_2 & d_3 \\end{bmatrix} \\mathbf{a}_e\n$$\n表达式 $\\mathbf{F}_e = C_e \\mathbf{a}_e$ 允许我们确定 $6 \\times 3$ 的耦合矩阵 $C_e$：\n$$\nC_e = \\frac{t J_z}{6} \\begin{bmatrix}\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3 \\\\\nb_1 & b_2 & b_3 \\\\\nd_1 & d_2 & d_3\n\\end{bmatrix}\n$$\n当 $t=1$ 时，需要实现的耦合矩阵的最终表达式为：\n$$\nC_e = \\frac{J_z}{6} \\begin{bmatrix}\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1 \\\\\ny_2 - y_3 & y_3 - y_1 & y_1 - y_2 \\\\\nx_3 - x_2 & x_1 - x_3 & x_2 - x_1\n\\end{bmatrix}\n$$\n力向量 $\\mathbf{F}_e$ 是通过将该矩阵与节点矢量势值 $\\mathbf{a}_e = [a_1, a_2, a_3]^T$ 相乘计算得出的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the magneto-structural coupling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 2.0},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 1.0, \"a\": [0.0, 1.0, 0.0]},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": 0.0},\n        {\"mode\": \"matrix\", \"coords\": ((2, 1), (5, 1), (2, 4)), \"Jz\": 3.0},\n        {\"mode\": \"matrix\", \"coords\": ((0, 0), (1, 0), (0, 1)), \"Jz\": -1.5},\n        {\"mode\": \"force\", \"coords\": ((0, 0), (2, 0), (1, 1.7320508075688772)), \"Jz\": 0.5, \"a\": [0.0, 2.0, -0.7320508075688772]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_coupling(case)\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str = []\n    for res_list in results:\n        res_list_str = [f\"{x:.6f}\" for x in res_list]\n        results_str.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str)}]\")\n\ndef compute_coupling(case_data):\n    \"\"\"\n    Computes the coupling matrix or nodal force vector for a single linear triangular element.\n\n    Args:\n        case_data (dict): A dictionary containing the parameters for the test case.\n                          It must include 'mode', 'coords', and 'Jz'. If 'mode' is 'force',\n                          it must also include 'a'.\n\n    Returns:\n        list: A list of floats representing either the flattened coupling matrix\n              or the nodal force vector, rounded to 6 decimal places.\n    \"\"\"\n    mode = case_data[\"mode\"]\n    (x1, y1), (x2, y2), (x3, y3) = case_data[\"coords\"]\n    Jz = case_data[\"Jz\"]\n    \n    # As per the problem statement, element thickness t is 1 meter.\n    # The derived coupling matrix includes a factor t, so we set t=1.0.\n    t = 1.0\n    \n    # Calculate geometric coefficients b_i and d_i\n    b1 = y2 - y3\n    b2 = y3 - y1\n    b3 = y1 - y2\n    \n    d1 = x3 - x2\n    d2 = x1 - x3\n    d3 = x2 - x1\n    \n    # The core 2x3 matrix relating force density to nodal potentials (scaled by Jz)\n    # This corresponds to [ [b1, b2, b3], [d1, d2, d3] ]\n    core_matrix = np.array([[b1, b2, b3], [d1, d2, d3]])\n    \n    # Construct the 6x3 coupling matrix Ce by tiling the core matrix and scaling\n    # Ce = (t * Jz / 6) * [ core_matrix_tiled_vertically ]\n    C_e = (t * Jz / 6.0) * np.tile(core_matrix, (3, 1))\n\n    if mode == \"matrix\":\n        # Flatten the matrix in row-major order (numpy's default)\n        return C_e.flatten().tolist()\n    elif mode == \"force\":\n        a_e = np.array(case_data[\"a\"]).reshape(3, 1)\n        # Compute the nodal force vector F_e = C_e * a_e\n        F_e = C_e @ a_e\n        return F_e.flatten().tolist()\n\n# Run the solver\nsolve()\n```"
        },
        {
            "introduction": "一旦系统在空间上被离散化，接下来的挑战就是准确地模拟它随时间的演变。这项实践深入探讨了数值时间积分这一关键课题，通过比较一种功率守恒的方案和一种简化的、不一致的方案，揭示了耦合算法的选择如何通过能量的守恒或人为增长，从而极大地影响仿真的稳定性和物理真实性。",
            "id": "3304517",
            "problem": "您的任务是分析和模拟一个由单匝线圈和单自由度线性梁组成的集总电磁-结构系统中的数值能量交换。电气部分被视为一个无电阻、无电源且与位置相关的电感器，其状态通过一个与时域有限差分(FDTD)一致的不变量进行更新；结构部分则通过 Newmark 系列格式进行更新。您的目标是实现两种时间积分耦合方法，量化离散能量行为，并找出避免人为能量增长的条件。\n\n连续模型如下。设梁的位移为 $x(t)$（单位：米），速度为 $v(t)$（单位：米/秒），质量为 $m$（单位：千克），刚度为 $k$（单位：牛顿/米）。线圈被建模为一个电感，其电感值 $L(x)$（单位：亨利）取决于梁的位移。设线圈电流为 $I(t)$（单位：安培），磁链为 $\\psi(t)$（单位：韦伯匝）。假设电阻和电压源均为零，则电气回路方程为磁链守恒，\n$$\n\\frac{d\\psi}{dt} = 0,\\quad \\text{with}\\quad \\psi(t) = L(x(t))\\,I(t).\n$$\n磁共能为\n$$\nW_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2,\n$$\n作用在梁上的电磁力是磁共能关于 $x$ 的负梯度，对于标量状态，这简化为\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{1}{2} I^2 \\frac{dL}{dx}(x).\n$$\n梁的运动方程为\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t)).\n$$\n总连续能量为\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2,\n$$\n当 $d\\psi/dt=0$ 且阻尼为零时，该能量是精确守恒的。\n\n您将在固定的时间范围 $T$（单位：秒）内比较两种离散耦合格式：\n- 格式 A（功率一致的 FDTD–Newmark）：通过保持磁链恒定 $\\psi^{n+1} = \\psi^{n}$ 来强制执行与 FDTD 一致的不变量，并对梁使用参数为 $\\beta = 1/4$ 和 $\\gamma = 1/2$ 的 Newmark 梯形法则。在 $\\psi$ 保持恒定的情况下，电流为 $I(x) = \\psi / L(x)$。将加速度定义为位移的函数，\n$$\na(x) = \\frac{1}{m}\\left(\\frac{1}{2}\\,\\frac{\\psi^2}{L(x)^2}\\,\\frac{dL}{dx}(x) - k\\,x\\right).\n$$\n通过求解 Newmark 梯形法则的隐式更新方程来推进 $x^n \\mapsto x^{n+1}$\n$$\nx^{n+1} - \\frac{\\Delta t^2}{4}\\,a(x^{n+1}) = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n}),\n$$\n然后设置\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right),\\quad I^{n+1} = \\frac{\\psi}{L(x^{n+1})}.\n$$\n在每一步中使用 Newton 迭代求解 $x^{n+1}$ 直至数值收敛。此格式被设计为在离散层面上是功率共轭的。\n\n- 格式 B（不一致的冻结电流耦合）：通过设置 $I^{n+1} = I^{n}$ 在每个步长内冻结电流，并使用步长开始时的位移和电流来评估电磁力，\n$$\nF_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n).\n$$\n使用相同的 Newmark 参数 $\\beta = 1/4$ 和 $\\gamma = 1/2$ 来推进梁的运动，但将 $F_{\\mathrm{em}}^n$ 视为在步长内恒定，因此隐式方程简化为求解 $x^{n+1}$ 的线性问题，\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(\\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right)\\right) + \\frac{\\Delta t^2}{4m} F_{\\mathrm{em}}^{n}}{1 + \\frac{\\Delta t^2}{4}\\frac{k}{m}},\n$$\n随后是\n$$\na^{n} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n}\\right),\\quad a^{n+1} = \\frac{1}{m}\\left(F_{\\mathrm{em}}^{n} - k\\, x^{n+1}\\right),\\quad v^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right).\n$$\n该格式故意设计为非功率共轭的，因为它冻结了电流，并在与电感共能不同的时间点上评估力。\n\n对于两种格式，计算每一步 $n$ 的离散总能量，\n$$\nE^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2.\n$$\n\n您的任务是编写一个程序，针对下述参数集，在均匀时间步长 $\\Delta t$ 和给定初始条件下，模拟系统从 $t=0$ 到 $t=T$ 的行为，并为每个测试用例返回离散总能量相对于初始能量的最大分数增量，\n$$\n\\max_{0 \\le n \\le N} \\left(\\frac{E^{n} - E^{0}}{E^{0}}\\right),\n$$\n结果以无量纲小数形式报告（无单位），其中 $N = T/\\Delta t$ 是时间步数。接近 $0$ 的值表示没有人为能量增长；正值表示存在人为能量增长。\n\n使用以下物理上一致的建模选择：\n- 电感：$L(x) = L_{0} + \\alpha\\, x$，其中 $L_{0} > 0$ 且 $\\alpha \\ge 0$，因此 $\\frac{dL}{dx} = \\alpha$。\n- 无电阻和外部激励，因此对于格式 A，有 $d\\psi/dt = 0$。\n- 无结构阻尼。\n\n使用以下数值和物理参数，所有量均采用国际单位制 (SI)。质量 $m$ 单位为千克，刚度 $k$ 单位为牛顿/米，电感 $L$ 单位为亨利，电流 $I$ 单位为安培，时间单位为秒，位移 $x$ 单位为米：\n- 通用物理参数：$m = 0.05$，$k = 200$，$L_{0} = 0.001$，$\\alpha = 0.02$。\n- 初始条件：$x(0) = 0$，$v(0) = 0$，$I(0) = 20$。对于格式 A，设置 $\\psi(0) = L(x(0))\\,I(0)$ 并强制 $\\psi^{n+1} = \\psi^{n}$。\n- 时间范围：$T = 0.01$。\n\n实现四个测试用例：\n- 用例 1：格式 A，$\\Delta t = 0.0001$。\n- 用例 2：格式 A，$\\Delta t = 0.0005$。\n- 用例 3：格式 B，$\\Delta t = 0.0001$。\n- 用例 4：格式 B，$\\Delta t = 0.0005$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述四个用例的顺序排列结果。每个结果是表示最大分数能量增量的浮点数。例如，一个有效的输出格式是“[0.0,0.00123,0.045,0.12]”。本任务不使用角度。输出是无单位的无量纲小数。\n\n约束和要求：\n- 从所提供的磁链基本守恒定律和 Newmark 方法定义中推导您的离散更新；不要使用任何其他简化公式。\n- 确保格式 A 的 Newton 迭代收敛到严格的容差，以使能量行为能代表该方法的特性，而不是数值误差。\n- 对于所提供的参数，仿真必须是自包含和确定性的。",
            "solution": "该问题要求模拟一个集总参数电磁-结构系统在两种不同时间积分格式下的行为。主要目标是量化每种格式的数值能量守恒特性。分析从作为基准的连续模型开始，然后进行离散实现和比较。\n\n系统的状态由机械位移 $x(t)$ 和速度 $v(t)$ 以及电流 $I(t)$ 描述。核心物理原理是磁链守恒和牛顿第二运动定律。\n\n对于电气子系统，在零电阻和无电压源的情况下，其控制方程是磁链 $\\psi(t)$ 守恒：\n$$\n\\frac{d\\psi}{dt} = 0 \\implies \\psi(t) = L(x(t))\\,I(t) = \\text{constant}\n$$\n磁共能，对于线性磁路而言，它等于储存的磁能，其表达式为 $W_{\\mathrm{m}}(x,I) = \\frac{1}{2} L(x)\\, I^2$。作用在机械部分上的电磁力由该共能导出：\n$$\nF_{\\mathrm{em}}(x,I) = \\frac{\\partial W_{\\mathrm{m}}}{\\partial x} = \\frac{1}{2} I^2 \\frac{dL}{dx}(x)\n$$\n对于机械子系统，一个单自由度线性振子，其运动方程为：\n$$\nm\\,\\ddot{x}(t) + k\\,x(t) = F_{\\mathrm{em}}(x(t), I(t))\n$$\n连续系统的总能量是机械动能、机械势能（弹性势能）和磁能之和：\n$$\nE(t) = \\frac{1}{2} m\\, v(t)^2 + \\frac{1}{2} k\\, x(t)^2 + \\frac{1}{2} L(x(t))\\, I(t)^2\n$$\n在连续域中，此总能量是精确守恒的。总能量的变化率为 $\\frac{dE}{dt} = m\\,v\\,\\dot{v} + k\\,x\\,\\dot{x} + \\frac{1}{2}\\frac{dL}{dx}\\dot{x}\\,I^2 + L\\,I\\,\\frac{dI}{dt}$。当 $\\dot{x}=v$, $\\ddot{x}=\\dot{v}$ 且 $\\psi = L\\,I$ 为常数时，我们有 $\\frac{dI}{dt} = -\\frac{I}{L}\\frac{dL}{dt} = -\\frac{I}{L}\\frac{dL}{dx}\\dot{x}$。将这些代入能量导数，得到 $\\frac{dE}{dt} = v(m\\ddot{x} + kx) + \\frac{1}{2}v\\frac{dL}{dx}I^2 + L\\,I(-\\frac{I}{L}\\frac{dL}{dx}v) = v(F_{\\text{em}}) - \\frac{1}{2}v\\frac{dL}{dx}I^2 = vF_{\\text{em}} - vF_{\\text{em}} = 0$，从而证实了能量守恒。\n\n任务是使用两种格式离散化该系统，并比较它们的能量行为。两种格式都对机械部分使用 Newmark 积分器系列，参数为 $\\beta = 1/4$ 和 $\\gamma = 1/2$，这对应于梯形法则，该法则以其在线性系统中的良好能量守恒特性而闻名。区别在于电磁部分和机械部分是如何耦合的。\n\n**格式 A：功率一致的 FDTD–Newmark 耦合**\n此格式旨在离散层面上遵守两个物理域之间的功率共轭关系，这是离散能量守恒的先决条件。磁链保持恒定，$\\psi^{n+1} = \\psi^n = \\psi$，模拟了连续不变量。这意味着 $I(x) = \\psi / L(x)$。加速度成为仅与位移相关的非线性函数：\n$$\na(x) = \\frac{1}{m}\\left( F_{\\mathrm{em}}(x, I(x)) - k\\,x \\right) = \\frac{1}{m}\\left(\\frac{1}{2} \\left(\\frac{\\psi}{L(x)}\\right)^2 \\frac{dL}{dx}(x) - k\\,x\\right)\n$$\n对于给定的电感 $L(x) = L_0 + \\alpha x$ 及其导数 $\\frac{dL}{dx} = \\alpha$，其表达式为：\n$$\na(x) = \\frac{1}{m}\\left(\\frac{\\alpha \\psi^2}{2(L_0 + \\alpha x)^2} - k\\,x\\right)\n$$\n位移 $x^{n+1}$ 的 Newmark 梯形法则更新是隐式和非线性的：\n$$\nx^{n+1} = x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n这可以写成一个求根问题 $g(x^{n+1}) = 0$，其中：\n$$\ng(z) = z - \\frac{\\Delta t^2}{4}\\,a(z) - \\left(x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4}\\,a(x^{n})\\right) = 0\n$$\n这个非线性代数方程在每个时间步使用 Newton 方法求解。根 $z$ 的迭代更新公式为 $z_{k+1} = z_k - g(z_k)/g'(z_k)$，其中 $g'(z) = 1 - \\frac{\\Delta t^2}{4}a'(z)$ 且 $a'(z) = \\frac{1}{m}(-\\frac{\\alpha^2\\psi^2}{(L_0+\\alpha z)^3} - k)$。使用严格的收敛容差来确保数值解能准确反映格式本身的特性。\n一旦求得 $x^{n+1}$，就更新速度和电流：\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a(x^{n}) + a(x^{n+1})\\right)\n$$\n$$\nI^{n+1} = \\frac{\\psi}{L(x^{n+1})}\n$$\n这种隐式求解完整耦合系统的整体法，预计会产生出色的能量守恒效果。\n\n**格式 B：不一致的冻结电流耦合**\n这种格式代表了一种常见但有缺陷的简化方法。该方法不强制执行磁链不变量，而是在时间步内“冻结”电流，$I^{n+1} = I^n$。电磁力在步长开始时计算，$F_{\\mathrm{em}}^n = \\frac{1}{2} (I^n)^2 \\frac{dL}{dx}(x^n)$，并被视为在时间区间 $[t^n, t^{n+1}]$ 内的恒定外力。\n运动方程在步长内变为线性：$m a^{n+1} + k x^{n+1} = F_{\\mathrm{em}}^n$。位移的 Newmark 更新为：\n$$\nx^{n+1} = x^{n} + \\Delta t v^{n} + \\frac{\\Delta t^2}{4}(a^n + a^{n+1})\n$$\n代入 $a^n = (F_{\\mathrm{em}}^n - kx^n)/m$ 和 $a^{n+1} = (F_{\\mathrm{em}}^n - kx^{n+1})/m$ 并求解 $x^{n+1}$ 得到问题中提供的显式更新规则：\n$$\nx^{n+1} = \\frac{x^{n} + \\Delta t\\, v^{n} + \\frac{\\Delta t^2}{4m}(2F_{\\mathrm{em}}^{n} - k\\, x^{n})}{1 + \\frac{k \\Delta t^2}{4m}}\n$$\n然后使用梯形法则更新速度：\n$$\nv^{n+1} = v^{n} + \\frac{\\Delta t}{2}\\left(a^{n} + a^{n+1}\\right)\n$$\n这种交错或显式耦合破坏了离散功率平衡。力 $F_{\\mathrm{em}}^n$ 对机械系统所做的功，并未正确地源于储存磁能的变化，导致总系统能量出现人为增益或损失，这通常表现为数值不稳定性或非物理的能量增长。\n\n实现部分会为两种格式计算每一步的总离散能量 $E^{n} = \\frac{1}{2} m\\, (v^{n})^2 + \\frac{1}{2} k\\, (x^{n})^2 + \\frac{1}{2} L(x^{n})\\, (I^{n})^2$。比较的度量标准是仿真时间范围内的最大分数能量增量 $\\max_{n} ((E^n - E^0)/E^0)$，其中 $E^0$ 是初始能量。该度量标准量化了数值格式引入的人为能量增长程度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the electromagnetic-structural coupling problem for four test cases\n    and prints the maximum fractional energy increase for each.\n    \"\"\"\n    # Common physical parameters (SI units)\n    M = 0.05  # mass (kg)\n    K = 200.0  # stiffness (N/m)\n    L0 = 0.001  # base inductance (H)\n    ALPHA = 0.02  # inductance gradient (H/m)\n    \n    # Initial conditions\n    X0 = 0.0  # initial displacement (m)\n    V0 = 0.0  # initial velocity (m/s)\n    I0 = 20.0  # initial current (A)\n    \n    # Time horizon\n    T_HORIZON = 0.01  # s\n\n    # Define inductance and its derivative\n    def L_func(x):\n        return L0 + ALPHA * x\n    \n    def dLdx_func(x):\n        return ALPHA\n\n    def calculate_energy(x, v, i):\n        return 0.5 * M * v**2 + 0.5 * K * x**2 + 0.5 * L_func(x) * i**2\n\n    def run_simulation(scheme, dt):\n        \"\"\"\n        Runs the time-domain simulation for a given scheme and time step.\n\n        Args:\n            scheme (str): 'A' or 'B' specifying the coupling scheme.\n            dt (float): The time step size.\n\n        Returns:\n            float: The maximum fractional energy increase.\n        \"\"\"\n        x_n, v_n, i_n = X0, V0, I0\n        \n        e0 = calculate_energy(x_n, v_n, i_n)\n        if e0 == 0:  # Avoid division by zero, though not expected here\n            return 0.0\n            \n        max_energy_frac_inc = 0.0\n        n_steps = int(round(T_HORIZON / dt))\n\n        if scheme == 'A':\n            psi = L_func(x_n) * i_n\n            newton_tol = 1e-14\n            max_newton_iter = 20\n            \n            def accel(x):\n                L_val = L_func(x)\n                if L_val == 0: return np.inf # To prevent division by zero in extreme cases\n                fem = 0.5 * (psi**2 / L_val**2) * dLdx_func(x)\n                return (fem - K * x) / M\n\n            def accel_deriv(x):\n                L_val = L_func(x)\n                if L_val == 0: return np.inf\n                fem_deriv = -1.0 * (psi**2 * ALPHA**2) / (L_val**3)\n                return (fem_deriv - K) / M\n\n            for _ in range(n_steps):\n                a_n = accel(x_n)\n                \n                # Newton-Raphson solver for x_{n+1}\n                c_const = x_n + dt * v_n + (dt**2 / 4.0) * a_n\n                x_np1_guess = x_n\n                \n                for _ in range(max_newton_iter):\n                    g = x_np1_guess - (dt**2 / 4.0) * accel(x_np1_guess) - c_const\n                    g_prime = 1.0 - (dt**2 / 4.0) * accel_deriv(x_np1_guess)\n                    if abs(g_prime)  1e-15: # Avoid division by zero\n                        break\n                    delta_x = -g / g_prime\n                    x_np1_guess += delta_x\n                    if abs(delta_x)  newton_tol:\n                        break\n                \n                x_np1 = x_np1_guess\n                a_np1 = accel(x_np1)\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = psi / L_func(x_np1)\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n                \n                x_n, v_n = x_np1, v_np1\n        \n        elif scheme == 'B':\n            for _ in range(n_steps):\n                fem_n = 0.5 * i_n**2 * dLdx_func(x_n)\n                \n                # Explicit update for x_{n+1}\n                numerator = x_n + dt * v_n + (dt**2 / (4.0 * M)) * (2 * fem_n - K * x_n)\n                denominator = 1.0 + (K * dt**2) / (4.0 * M)\n                x_np1 = numerator / denominator\n                \n                a_n = (fem_n - K * x_n) / M\n                a_np1 = (fem_n - K * x_np1) / M\n                \n                v_np1 = v_n + (dt / 2.0) * (a_n + a_np1)\n                i_np1 = i_n\n                \n                e_np1 = calculate_energy(x_np1, v_np1, i_np1)\n                frac_inc = (e_np1 - e0) / e0\n                max_energy_frac_inc = max(max_energy_frac_inc, frac_inc)\n\n                x_n, v_n, i_n = x_np1, v_np1, i_np1\n                \n        return max_energy_frac_inc\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('A', 0.0001),  # Case 1\n        ('A', 0.0005),  # Case 2\n        ('B', 0.0001),  # Case 3\n        ('B', 0.0005),  # Case 4\n    ]\n\n    results = []\n    for scheme, dt in test_cases:\n        result = run_simulation(scheme, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "超越线性近似，许多高级应用涉及到具有复杂、非线性磁-机行为的材料。这项高级实践触及了非线性多物理场建模的核心：从热力学势中推导和验证一致切线算子。这是在基于牛顿法的求解器中为强耦合、非线性问题实现稳健和快速收敛的关键一步。",
            "id": "3304447",
            "problem": "考虑一个在小应变和静磁学假设下的准静态磁弹性体。采用基于势的公式，其中单位参考体积的总热力学势由能量密度函数 $\\psi(\\boldsymbol{e},\\boldsymbol{B})$ 给出，其中 $\\boldsymbol{e}$ 是小应变张量，$\\boldsymbol{B}$ 是磁感应强度矢量。假设一个具有非线性磁响应和双线性磁弹性耦合的各向同性、可压缩线性弹性固体，其能量密度函数为\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) \\;=\\; \\mu \\, \\boldsymbol{e}:\\boldsymbol{e} \\;+\\; \\dfrac{\\lambda}{2} \\left(\\operatorname{tr}\\boldsymbol{e}\\right)^2 \\;+\\; \\dfrac{1}{2\\mu_0}\\, \\boldsymbol{B}\\cdot \\boldsymbol{B} \\;+\\; m_s B_0 \\ln\\!\\left(\\cosh\\!\\left(\\dfrac{\\|\\boldsymbol{B}\\|}{B_0}\\right)\\right) \\;-\\; \\gamma \\, \\boldsymbol{B}^{\\mathsf{T}} \\,\\boldsymbol{e}\\, \\boldsymbol{B},\n$$\n其中 $\\mu$ 和 $\\lambda$ 是 Lamé 参数，$\\mu_0$ 是真空磁导率，$m_s$ 和 $B_0$ 在磁性定律中设定了平滑的饱和响应，$\\gamma$ 是磁弹性耦合系数。此处，$\\|\\boldsymbol{B}\\| = \\sqrt{\\boldsymbol{B}\\cdot\\boldsymbol{B}}$，$\\boldsymbol{e}:\\boldsymbol{e} = \\sum_{i,j} e_{ij} e_{ij}$，且 $\\operatorname{tr}\\boldsymbol{e} = \\sum_i e_{ii}$。所有输入都应在国际单位制（SI）下理解：应变为无量纲，磁感应强度单位为特斯拉，应力和能量密度单位分别为帕斯卡和焦耳每立方米。你将编写的程序只会输出无量纲的布尔值，因此输出中不需要显式单位转换。\n\n从最小势能原理和本构定义\n$$\n\\boldsymbol{\\sigma} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{e}}, \\quad \\boldsymbol{H} \\;=\\; \\dfrac{\\partial \\psi}{\\partial \\boldsymbol{B}},\n$$\n出发，推导为确保耦合问题的 Newton 求解器具有二次收敛性所需的一致性切线算子（$\\psi$ 的 Hessian 矩阵）。特别地，推导四个二阶导数块\n$$\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{e}\\,\\partial \\boldsymbol{B}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{e}}, \\quad\n\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}} \\;=\\; \\dfrac{\\partial^2 \\psi}{\\partial \\boldsymbol{B}\\,\\partial \\boldsymbol{B}},\n$$\n注意，当索引适当排列时，混合块必须满足 Maxwell 对称性 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$。\n\n你的任务是：\n\n$1.$ 从给定的 $\\psi(\\boldsymbol{e},\\boldsymbol{B})$ 推导 $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ 和 $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$ 的闭式表达式。\n\n$2.$ 仅使用上述基本定义，推导算法切线块 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$、$\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$、$\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$ 和 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$ 的闭式表达式。将你的最终公式表示为适合直接在代码中实现的索引分量形式。\n\n$3.$ 实现一个程序：\n- 计算在给定的状态 $(\\boldsymbol{e},\\boldsymbol{B})$ 和材料参数 $(\\mu,\\lambda,\\mu_0,m_s,B_0,\\gamma)$ 下四个切线块的解析形式。\n- 通过比较分量 $\\left(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}\\right)_{ij k}$ 和 $\\left(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}\\right)_{k ij}$ 来验证混合块对称性 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}} = \\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}^{\\mathsf{T}}$，其中索引 $i,j,k$ 遍历所有可能值。\n- 通过将解析导数与一阶导数 $\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B})$ 和 $\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B})$ 的中心有限差分近似进行比较，来验证四个块中的每一个，对非对角应变分量使用对称扰动以保持 $\\boldsymbol{e}=\\boldsymbol{e}^{\\mathsf{T}}$。磁分量使用扰动幅度 $h_{\\boldsymbol{B}} = 10^{-6}$ 特斯拉，应变分量使用扰动幅度 $h_{\\boldsymbol{e}} = 10^{-8}$（无量纲）。在 Frobenius 范数相对误差上使用相对容差 $\\tau = 10^{-6}$。\n\n$4.$ 将你的程序应用于以下测试套件。对于每个测试，使用相同的材料参数\n$$\n\\mu = 60\\times 10^{9},\\quad \\lambda = 90\\times 10^{9},\\quad \\mu_0 = 4\\pi \\times 10^{-7},\\quad m_s = 10^{5},\\quad B_0 = 1.2,\\quad \\gamma = 10^{6}.\n$$\n为每个测试提供状态 $(\\boldsymbol{e},\\boldsymbol{B})$：\n- 测试 $1$ (一般耦合状态):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-3}  2\\times 10^{-4}  -10^{-4}\\\\\n2\\times 10^{-4}  -5\\times 10^{-4}  3\\times 10^{-4}\\\\\n-10^{-4}  3\\times 10^{-4}  2\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0.3\\\\ -0.1\\\\ 0.2\n\\end{bmatrix}.\n$$\n- 测试 $2$ (近零磁场和小应变):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n10^{-6}  0  0\\\\\n0  -2\\times 10^{-6}  0\\\\\n0  0  1.5\\times 10^{-6}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n10^{-12}\\\\ -2\\times 10^{-12}\\\\ 3\\times 10^{-12}\n\\end{bmatrix}.\n$$\n- 测试 $3$ (接近饱和的高磁场):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n5\\times 10^{-4}  -1\\times 10^{-4}  2\\times 10^{-4}\\\\\n-1\\times 10^{-4}  4\\times 10^{-4}  -2\\times 10^{-4}\\\\\n2\\times 10^{-4}  -2\\times 10^{-4}  -3\\times 10^{-4}\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n1.5\\\\ 0.5\\\\ -1.0\n\\end{bmatrix}.\n$$\n- 测试 $4$ (纯剪切与正交磁感应强度):\n$$\n\\boldsymbol{e} =\n\\begin{bmatrix}\n0  5\\times 10^{-4}  0\\\\\n5\\times 10^{-4}  0  0\\\\\n0  0  0\n\\end{bmatrix},\\quad\n\\boldsymbol{B} =\n\\begin{bmatrix}\n0\\\\ 0\\\\ 0.8\n\\end{bmatrix}.\n$$\n\n对于每个测试，你的程序应返回一个布尔值，指示是否所有检查都通过：混合块对称性检查和在指定容差 $\\tau$ 下对四个块中每一个的有限差分验证。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如， $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$）。",
            "solution": "该问题要求从给定的热力学势中推导本构关系和一致性切线算子，然后实现对这些推导的数值验证。\n\n### **推导**\n\n**第1步：本构关系**\n\n能量势 $\\psi$ 的索引表示法如下：\n$$\n\\psi(\\boldsymbol{e},\\boldsymbol{B}) = \\mu e_{ij}e_{ij} + \\frac{\\lambda}{2} (e_{kk})^2 + \\frac{1}{2\\mu_0} B_k B_k + m_s B_0 \\ln\\left(\\cosh\\left(\\frac{\\sqrt{B_k B_k}}{B_0}\\right)\\right) - \\gamma B_i e_{ij} B_j\n$$\n\n**柯西应力张量, $\\boldsymbol{\\sigma}$**:\n使用标准张量微积分，并考虑到应变张量 $\\boldsymbol{e}$ 的对称性，我们对 $\\psi$ 关于 $e_{ij}$ 求导得到：\n$$\n\\sigma_{ij} = \\frac{\\partial \\psi}{\\partial e_{ij}} = 2\\mu e_{ij} + \\lambda e_{kk} \\delta_{ij} - \\gamma B_i B_j\n$$\n$$\n\\boldsymbol{\\sigma}(\\boldsymbol{e},\\boldsymbol{B}) = 2\\mu\\boldsymbol{e} + \\lambda(\\operatorname{tr}\\boldsymbol{e})\\boldsymbol{I} - \\gamma \\boldsymbol{B}\\otimes\\boldsymbol{B}\n$$\n\n**磁场强度, $\\boldsymbol{H}$**:\n对 $\\psi$ 关于 $B_i$ 求导得到：\n$$\nH_i = \\frac{\\partial \\psi}{\\partial B_i} = \\frac{1}{\\mu_0} B_i + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{B_i}{\\|\\boldsymbol{B}\\|} - 2\\gamma e_{ik}B_k\n$$\n$$\n\\boldsymbol{H}(\\boldsymbol{e},\\boldsymbol{B}) = \\frac{1}{\\mu_0} \\boldsymbol{B} + m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right) \\frac{\\boldsymbol{B}}{\\|\\boldsymbol{B}\\|} - 2\\gamma \\boldsymbol{e}\\boldsymbol{B}\n$$\n对于 $\\|\\boldsymbol{B}\\| \\to 0$ 的情况，为避免除以零，饱和项可近似为 $(m_s/B_0)\\boldsymbol{B}$。\n\n**第2步：切线算子 (Hessian 矩阵)**\n\n**弹性张量, $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\frac{\\partial \\sigma_{ij}}{\\partial e_{kl}} = 2\\mu \\frac{\\partial e_{ij}}{\\partial e_{kl}} + \\lambda \\delta_{ij} \\frac{\\partial e_{mm}}{\\partial e_{kl}}\n$$\n使用对称张量的标准求导恒等式，这给出了线性各向同性材料的标准四阶刚度张量：\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{e}})_{ijkl} = \\mu(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) + \\lambda\\delta_{ij}\\delta_{kl}\n$$\n\n**压磁型/压电型耦合张量, $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$ 和 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij} = \\frac{\\partial H_k}{\\partial e_{ij}} = -2\\gamma \\frac{\\partial e_{km}}{\\partial e_{ij}} B_m = -\\gamma(\\delta_{ki}B_j + \\delta_{kj}B_i)\n$$\n$$\n(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = \\frac{\\partial \\sigma_{ij}}{\\partial B_k} = -\\gamma (\\delta_{ik}B_j + B_i\\delta_{jk})\n$$\n正如 Maxwell 对称性所预期的，$(\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}})_{ijk} = (\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}})_{kij}$。\n\n**逆磁导率张量, $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}}$**:\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\frac{\\partial H_i}{\\partial B_j}\n$$\n对 $H_i$ 的各项关于 $B_j$ 求导，我们得到：\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} = \\left(\\frac{1}{\\mu_0} + \\frac{m_s \\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|}\\right) \\delta_{ij} - 2\\gamma e_{ij} + m_s \\left[ \\frac{\\text{sech}^2\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{B_0 \\|\\boldsymbol{B}\\|^2} - \\frac{\\tanh\\left(\\frac{\\|\\boldsymbol{B}\\|}{B_0}\\right)}{\\|\\boldsymbol{B}\\|^3} \\right] B_i B_j\n$$\n对于 $\\|\\boldsymbol{B}\\| \\to 0$ 的极限情况，该表达式简化为：\n$$\n(\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{B}})_{ij} \\to \\left(\\frac{1}{\\mu_0} + \\frac{m_s}{B_0}\\right)\\delta_{ij} - 2\\gamma e_{ij}\n$$\n\n### **验证**\n实现将把这些解析表达式转化为 Python 代码。验证将通过以下方式进行：\n1.  **对称性检查**：直接比较 $\\mathbb{C}_{\\boldsymbol{e}\\boldsymbol{B}}$ 和 $\\mathbb{C}_{\\boldsymbol{B}\\boldsymbol{e}}$ 的转置分量。\n2.  **有限差分 (FD) 检查**：每个解析切线块都将与通过中心差分计算的数值导数进行比较。一个关键的细节是如何处理对应变张量（一个对称的二阶张量）的导数。当使用对称扰动 $d\\boldsymbol{e}$ 来扰动非对角分量 $e_{kl}$ 时（即 $de_{kl}=de_{lk}=h$），中心差分公式 $(f(\\boldsymbol{e}+d\\boldsymbol{e}) - f(\\boldsymbol{e}-d\\boldsymbol{e}))/(2h)$ 计算的是 $\\frac{\\partial f}{\\partial e_{kl}} + \\frac{\\partial f}{\\partial e_{lk}}$。由于解析导数是关于单个分量 $e_{kl}$ 的，数值结果必须除以2才能与解析导数进行比较。对于对角分量的扰动，则不需要这个因子2。实现代码必须正确处理这一点。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and verifies the tangent operators for a magnetoelastic constitutive model\n    across a suite of test cases.\n    \"\"\"\n\n    # --- Material Parameters (SI units) ---\n    params = {\n        \"mu\": 60e9,\n        \"lambda_\": 90e9,\n        \"mu0\": 4 * np.pi * 1e-7,\n        \"ms\": 1e5,\n        \"B0\": 1.2,\n        \"gamma\": 1e6,\n    }\n\n    # --- Numerical Parameters for Verification ---\n    h_e = 1e-8\n    h_B = 1e-6\n    tolerance = 1e-6\n    norm_B_eps = 1e-15  # Threshold for B->0 limit\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"e\": np.array([[1e-3, 2e-4, -1e-4], [2e-4, -5e-4, 3e-4], [-1e-4, 3e-4, 2e-4]]),\n            \"B\": np.array([0.3, -0.1, 0.2]),\n        },\n        {\n            \"e\": np.array([[1e-6, 0, 0], [0, -2e-6, 0], [0, 0, 1.5e-6]]),\n            \"B\": np.array([1e-12, -2e-12, 3e-12]),\n        },\n        {\n            \"e\": np.array([[5e-4, -1e-4, 2e-4], [-1e-4, 4e-4, -2e-4], [2e-4, -2e-4, -3e-4]]),\n            \"B\": np.array([1.5, 0.5, -1.0]),\n        },\n        {\n            \"e\": np.array([[0, 5e-4, 0], [5e-4, 0, 0], [0, 0, 0]]),\n            \"B\": np.array([0, 0, 0.8]),\n        },\n    ]\n\n    final_results = []\n    for case in test_cases:\n        e_test = 0.5 * (case[\"e\"] + case[\"e\"].T)  # Ensure strain is symmetric\n        b_test = case[\"B\"]\n        all_checks_passed = verify_all_tangents(\n            e_test, b_test, params, h_e, h_B, tolerance, norm_B_eps\n        )\n        final_results.append(all_checks_passed)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\n# --- Constitutive Model and Tangent Implementations ---\n\ndef get_sigma(e, B, p):\n    \"\"\"Computes the Cauchy stress tensor sigma.\"\"\"\n    tr_e = np.trace(e)\n    I = np.identity(3)\n    B_outer_B = np.outer(B, B)\n    return 2 * p[\"mu\"] * e + p[\"lambda_\"] * tr_e * I - p[\"gamma\"] * B_outer_B\n\ndef get_H(e, B, p, norm_B_eps):\n    \"\"\"Computes the magnetic field H.\"\"\"\n    norm_B = np.linalg.norm(B)\n    term1 = (1 / p[\"mu0\"]) * B\n    if norm_B  norm_B_eps:\n        term2 = (p[\"ms\"] / p[\"B0\"]) * B\n    else:\n        term2 = p[\"ms\"] * np.tanh(norm_B / p[\"B0\"]) * (B / norm_B)\n    term3 = -2 * p[\"gamma\"] * e @ B\n    return term1 + term2 + term3\n\ndef get_tangents(e, B, p, norm_B_eps):\n    \"\"\"Computes all four analytical tangent operator blocks.\"\"\"\n    I = np.identity(3)\n    \n    C_ee = np.zeros((3, 3, 3, 3))\n    for i, j, k, l in np.ndindex(3, 3, 3, 3):\n        C_ee[i, j, k, l] = p[\"mu\"] * (I[i, k] * I[j, l] + I[i, l] * I[j, k]) + p[\"lambda_\"] * I[i, j] * I[k, l]\n\n    C_eB = np.zeros((3, 3, 3))\n    for i, j, k in np.ndindex(3, 3, 3):\n        C_eB[i, j, k] = -p[\"gamma\"] * (I[i, k] * B[j] + I[j, k] * B[i])\n\n    C_Be = -p[\"gamma\"] * (np.einsum('ki,j->kij', I, B) + np.einsum('kj,i->kij', I, B))\n    \n    norm_B = np.linalg.norm(B)\n    if norm_B  norm_B_eps:\n        term_mag_diag = (1 / p[\"mu0\"] + p[\"ms\"] / p[\"B0\"]) * I\n        term_mag_off_diag = np.zeros((3, 3))\n    else:\n        u = norm_B / p[\"B0\"]\n        tanh_u_over_norm_B = np.tanh(u) / norm_B\n        term_mag_diag = (1 / p[\"mu0\"] + p[\"ms\"] * tanh_u_over_norm_B) * I\n        \n        sech_u_sq = 1 - np.tanh(u)**2\n        coeff_off_diag = p[\"ms\"] * (sech_u_sq / (p[\"B0\"] * norm_B**2) - tanh_u_over_norm_B / norm_B**2)\n        term_mag_off_diag = coeff_off_diag * np.outer(B, B)\n        \n    C_BB = term_mag_diag + term_mag_off_diag - 2 * p[\"gamma\"] * e\n    \n    return C_ee, C_eB, C_Be, C_BB\n\ndef verify_all_tangents(e, B, p, h_e, h_B, tolerance, norm_B_eps):\n    \"\"\"Performs all verification checks for a given state.\"\"\"\n    C_ee_an, C_eB_an, C_Be_an, C_BB_an = get_tangents(e, B, p, norm_B_eps)\n    \n    # 1. Maxwell Symmetry Check\n    C_Be_transposed = np.transpose(C_Be_an, (1, 2, 0))\n    symm_ok = np.allclose(C_eB_an, C_Be_transposed, rtol=tolerance, atol=1e-12)\n\n    # 2. FD check for C_ee\n    C_ee_fd = np.zeros_like(C_ee_an)\n    for k, l in np.ndindex(3, 3):\n        dE = np.zeros((3, 3))\n        dE[k, l] += h_e\n        if k != l:\n            dE[l, k] += h_e\n        \n        sigma_p = get_sigma(e + dE, B, p)\n        sigma_m = get_sigma(e - dE, B, p)\n        fd_deriv = (sigma_p - sigma_m) / (2 * h_e)\n        \n        C_ee_fd[:, :, k, l] = fd_deriv / (1.0 + (k != l)) # Divide by 2 for off-diagonal\n    \n    err_ee = np.linalg.norm(C_ee_fd - C_ee_an) / (np.linalg.norm(C_ee_an) + 1e-12)\n    C_ee_ok = err_ee  tolerance\n\n    # 3. FD check for C_eB\n    C_eB_fd = np.zeros_like(C_eB_an)\n    for k in range(3):\n        dB = np.zeros(3); dB[k] = h_B\n        sigma_p = get_sigma(e, B + dB, p)\n        sigma_m = get_sigma(e, B - dB, p)\n        C_eB_fd[:, :, k] = (sigma_p - sigma_m) / (2 * h_B)\n    \n    err_eB = np.linalg.norm(C_eB_fd - C_eB_an) / (np.linalg.norm(C_eB_an) + 1e-12)\n    C_eB_ok = err_eB  tolerance\n\n    # 4. FD check for C_Be\n    C_Be_fd = np.zeros_like(C_Be_an)\n    for i, j in np.ndindex(3, 3):\n        dE = np.zeros((3, 3)); dE[i, j] += h_e; dE[j, i] += h_e\n        H_p = get_H(e + dE, B, p, norm_B_eps)\n        H_m = get_H(e - dE, B, p, norm_B_eps)\n        fd_deriv = (H_p - H_m) / (2 * h_e)\n        C_Be_fd[:, i, j] = fd_deriv / (1.0 + (i != j)) # Divide by 2 for off-diagonal\n    \n    err_Be = np.linalg.norm(C_Be_fd - C_Be_an) / (np.linalg.norm(C_Be_an) + 1e-12)\n    C_Be_ok = err_Be  tolerance\n\n    # 5. FD check for C_BB\n    C_BB_fd = np.zeros_like(C_BB_an)\n    for j in range(3):\n        dB = np.zeros(3); dB[j] = h_B\n        H_p = get_H(e, B + dB, p, norm_B_eps)\n        H_m = get_H(e, B - dB, p, norm_B_eps)\n        C_BB_fd[:, j] = (H_p - H_m) / (2 * h_B)\n    \n    err_BB = np.linalg.norm(C_BB_fd - C_BB_an) / (np.linalg.norm(C_BB_an) + 1e-12)\n    C_BB_ok = err_BB  tolerance\n    \n    return all([symm_ok, C_ee_ok, C_eB_ok, C_Be_ok, C_BB_ok])\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}