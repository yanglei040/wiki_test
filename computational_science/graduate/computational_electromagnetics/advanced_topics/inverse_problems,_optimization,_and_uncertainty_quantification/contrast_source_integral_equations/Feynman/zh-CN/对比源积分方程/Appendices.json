{
    "hands_on_practices": [
        {
            "introduction": "直接评估对比源积分方程 (Contrast Source Integral Equation, CSIE) 中的积分算子在计算上是昂贵的，尤其是对于大规模问题。本实践将介绍一种强大的加速技术，利用快速傅里叶变换 (FFT) 来高效计算在均匀网格下CSIE固有的卷积运算。通过亲手实现并对比直接求和法与FFT加速法，你将深刻理解卷积定理在计算电磁学中的实际应用价值 ()。",
            "id": "3295446",
            "problem": "给定均匀背景中标量时谐场的对比度源积分方程，该方程可写成如下的 Lippmann–Schwinger 形式。设 $E(\\mathbf{r})$ 表示电场的一个标量分量，$E_{\\text{inc}}(\\mathbf{r})$ 为入射场，$\\chi(\\mathbf{r})$ 为对比度，$G_k(\\mathbf{r})$ 为波数为 $k$ 的标量亥姆霍兹算子的自由空间格林函数。定义对比度源 $w(\\mathbf{r}) = \\chi(\\mathbf{r}) E(\\mathbf{r})$。总场满足 $E(\\mathbf{r}) = E_{\\text{inc}}(\\mathbf{r}) + \\mathcal{T}[w](\\mathbf{r})$，其中体积积分算子为\n$$\n\\mathcal{T}[w](\\mathbf{r}) = \\int_{\\mathbb{R}^3} G_k(\\mathbf{r} - \\mathbf{r}')\\,w(\\mathbf{r}')\\,\\mathrm{d}\\mathbf{r}'.\n$$\n考虑在一个具有 $N_x \\times N_y \\times N_z$ 个体素、体素边长为 $a$（所有量均为无量纲）的有限矩形网格上进行均匀的基于体素的离散化，采样点位于体素中心。将 $w(\\mathbf{r})$ 近似为每个体素内的分段常数。为了数值计算的目的，采用一个正则化的离散核。对于非零偏移向量 $\\mathbf{d} = (d_x,d_y,d_z)$，其中 $d_\\ell \\in \\mathbb{Z}$，离散核为\n$$\nh[\\mathbf{d}] = a^3 \\, G_k\\!\\left(a\\sqrt{d_x^2 + d_y^2 + d_z^2}\\right),\n$$\n而对于 $\\mathbf{d} = \\mathbf{0}$，使用一个有限的正则化值\n$$\nh[\\mathbf{0}] = a^3 \\, G_k(r_c),\n$$\n其中正则化半径 $r_c = \\alpha a$ 为一个固定值，标量 $\\alpha = 0.5$。使用三维标量自由空间亥姆霍兹格林函数，\n$$\nG_k(r) = \\frac{e^{\\mathrm{i} k r}}{4\\pi r} \\quad \\text{for} \\quad r > 0,\n$$\n并在 $r=0$ 处使用上述正则化值。用 $\\Omega = \\{0,\\dots,N_x-1\\}\\times\\{0,\\dots,N_y-1\\}\\times\\{0,\\dots,N_z-1\\}$ 表示体素的索引集。在该网格上，对应于 $\\mathcal{T}$ 的离散算子（在域外进行均匀零扩展）为\n$$\n(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}], \\quad \\mathbf{i}\\in\\Omega,\n$$\n这是一个限制在有限域上的多维线性卷积。\n\n任务 A 部分（推导要求）：从以上定义出发，推导对于均匀体素和仅依赖于索引差的离散核 $h$，算子 $\\mathbf{T}$ 是一个在有限域上的三维线性卷积。解释零填充和周期性嵌入如何将线性卷积转换为可通过快速傅里叶变换 (FFT) 计算而无混叠的循环卷积。特别地，证明如果 $h$ 的支撑集大小为 $(2N_x-1)\\times(2N_y-1)\\times(2N_z-1)$，那么选择填充尺寸\n$$\nL_x = 3N_x - 2,\\quad L_y = 3N_y - 2,\\quad L_z = 3N_z - 2,\n$$\n并通过模数索引映射将 $h$ 嵌入到一个 $L_x\\times L_y\\times L_z$ 网格上的循环核 $\\tilde{h}$ 中，\n$$\n\\tilde{h}[p,q,r] = h\\big[\\big((p \\bmod L_x)- (N_x-1),\\, (q \\bmod L_y)- (N_y-1),\\, (r \\bmod L_z)- (N_z-1)\\big)\\big],\n$$\n将导致\n$$\n\\mathcal{F}^{-1}\\Big(\\mathcal{F}(\\tilde{h}) \\odot \\mathcal{F}(\\tilde{w})\\Big)\n$$\n是一个循环卷积，其中心子块可恢复在 $\\Omega$ 上的线性卷积 $\\mathbf{T}\\mathbf{w}$，其中 $\\odot$ 表示逐元素乘法，$\\mathcal{F}$ 是在填充网格上的离散傅里叶变换，$\\tilde{w}$ 是将 $w$ 零填充到相同尺寸的结果。精确指定必须提取哪个中心子块的索引才能获得 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}]$。\n\n任务 B 部分（算法设计）：为矩阵向量积 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$ 实现两种程序：\n- 一种直接方法，通过对每个 $\\mathbf{i}\\in\\Omega$ 进行字面上的三重求和 $\\sum_{\\mathbf{j}\\in\\Omega}$ 来计算线性卷积，使用核 $h[\\mathbf{i}-\\mathbf{j}]$。\n- 一种 FFT 加速方法，该方法：\n  1. 在其差分索引支撑集上构建离散核 $h$，\n  2. 通过模数索引映射，将其嵌入到上述定义的填充网格尺寸 $(L_x,L_y,L_z)$ 上的循环核 $\\tilde{h}$ 中，\n  3. 将 $\\mathbf{w}$ 零填充到尺寸 $(L_x,L_y,L_z)$，\n  4. 使用三维 FFT 计算循环卷积，以及\n  5. 提取正确的中心子块以恢复在 $\\Omega$ 上的 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$。\n\n任务 C 部分（迭代 CSIE 背景）：考虑与对比度源积分方程更新相关的不动点迭代\n$$\n\\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big),\n$$\n其中 $\\boldsymbol{\\chi}$ 和 $\\mathbf{E}_{\\text{inc}}$ 是在 $\\Omega$ 上的数组，$\\odot$ 表示逐元素乘法。分别使用直接和 FFT 加速的矩阵向量积方法计算 $\\mathbf{T}$，从 $\\mathbf{w}^{(0)}=\\mathbf{0}$ 开始运行固定次数 $J$ 的迭代，并比较结果。\n\n测试套件与输出要求：使用以下三个测试用例。所有量均为无量纲。对于每个测试用例：\n- 使用体素尺寸 $a$ 和波数 $k$（如上所述，$\\alpha=0.5$）构建核。\n- 为了可复现性，使用固定的随机种子 $s$ 生成用于单个矩阵向量积测试的复数值 $\\mathbf{w}$；生成实数值 $\\boldsymbol{\\chi}$；生成复数值 $\\mathbf{E}_{\\text{inc}}$。每个测试用例使用相同的种子 $s$ 以确定性地生成这些数组。\n- 计算两个标量：\n  1. 直接法和 FFT 加速法得到的 $\\mathbf{T}\\mathbf{w}$ 结果之间的最大逐项绝对差，即 $\\max_{\\mathbf{i}\\in\\Omega} \\left| (\\mathbf{T}\\mathbf{w})_{\\text{direct}}[\\mathbf{i}] - (\\mathbf{T}\\mathbf{w})_{\\text{FFT}}[\\mathbf{i}] \\right|$。\n  2. 经过 $J$ 次不动点迭代后，直接法和 FFT 加速法结果之间的最大逐项绝对差，即 $\\max_{\\mathbf{i}\\in\\Omega} \\left| \\mathbf{w}^{(J)}_{\\text{direct}}[\\mathbf{i}] - \\mathbf{w}^{(J)}_{\\text{FFT}}[\\mathbf{i}] \\right|$。\n\n测试用例：\n- 用例 1：$(N_x,N_y,N_z)=(1,1,1)$，$a=1.0$，$k=1.0$，$J=5$，种子 $s=123$。\n- 用例 2：$(N_x,N_y,N_z)=(3,3,3)$，$a=0.5$，$k=2.0$，$J=5$，种子 $s=456$。\n- 用例 3：$(N_x,N_y,N_z)=(4,3,2)$，$a=0.4$，$k=1.3$，$J=7$，种子 $s=789$。\n\n最终输出格式：您的程序应生成一行输出，包含一个结果列表，每个测试用例一个结果，其中每个结果是一个双元素列表 $[\\varepsilon_{\\text{mv}},\\varepsilon_{\\text{it}}]$，包含上述定义的两个标量，采用以下确切的 Python 列表字面量格式：\n$$\n[\\,[\\varepsilon_{\\text{mv},1},\\varepsilon_{\\text{it},1}],\\,[\\varepsilon_{\\text{mv},2},\\varepsilon_{\\text{it},2}],\\,[\\varepsilon_{\\text{mv},3},\\varepsilon_{\\text{it},3}]\\,].\n$$\n不需要单位，所有角度（如果有）均理解为弧度。输出必须按规定格式打印在单行上。",
            "solution": "该问题要求验证并随后解决一个关于对比度源积分方程 (CSIE) 的计算电磁学数值任务。该任务涉及推导离散线性卷积与其快速傅里叶变换 (FFT) 加速的对应关系，实现这两种方法，并在不动点迭代方案中比较它们的结果。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **控制方程**：标量 Lippmann-Schwinger 方程为 $E(\\mathbf{r}) = E_{\\text{inc}}(\\mathbf{r}) + \\mathcal{T}[w](\\mathbf{r})$，其中对比度源 $w(\\mathbf{r}) = \\chi(\\mathbf{r}) E(\\mathbf{r})$。\n- **积分算子**：$\\mathcal{T}[w](\\mathbf{r}) = \\int_{\\mathbb{R}^3} G_k(\\mathbf{r} - \\mathbf{r}')\\,w(\\mathbf{r}')\\,\\mathrm{d}\\mathbf{r}'$。\n- **格林函数**：$G_k(r) = \\frac{e^{\\mathrm{i} k r}}{4\\pi r}$，对于 $r > 0$。\n- **离散化**：一个具有 $N_x \\times N_y \\times N_z$ 个体素的均匀网格，边长为 $a$。\n- **离散核**：对于非零整数索引偏移 $\\mathbf{d}=(d_x,d_y,d_z)$，$h[\\mathbf{d}] = a^3 \\, G_k\\!\\left(a\\sqrt{d_x^2 + d_y^2 + d_z^2}\\right)$。\n- **正则化自作用项**：对于 $\\mathbf{d}=\\mathbf{0}$，$h[\\mathbf{0}] = a^3 \\, G_k(r_c)$，其中正则化半径 $r_c = \\alpha a$，$\\alpha = 0.5$。\n- **离散卷积算子**：$(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}]$，其中 $\\Omega = \\{0,\\dots,N_x-1\\}\\times\\{0,\\dots,N_y-1\\}\\times\\{0,\\dots,N_z-1\\}$。\n- **FFT 填充网格尺寸**：$L_\\ell = 3N_\\ell - 2$，对于 $\\ell \\in \\{x,y,z\\}$。\n- **循环核嵌入**：$\\tilde{h}[p,q,r] = h\\big[\\big((p \\bmod L_x)- (N_x-1),\\, (q \\bmod L_y)- (N_y-1),\\, (r \\bmod L_z)- (N_z-1)\\big)\\big]$。\n- **不动点迭代**：$\\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big)$，从 $\\mathbf{w}^{(0)}=\\mathbf{0}$ 开始进行 $J$ 次迭代。\n- **测试用例**：\n    - 用例 1：$(N_x,N_y,N_z)=(1,1,1)$，$a=1.0$，$k=1.0$，$J=5$，种子 $s=123$。\n    - 用例 2：$(N_x,N_y,N_z)=(3,3,3)$，$a=0.5$，$k=2.0$，$J=5$，种子 $s=456$。\n    - 用例 3：$(N_x,N_y,N_z)=(4,3,2)$，$a=0.4$，$k=1.3$，$J=7$，种子 $s=789$。\n- **输出**：对每个用例，计算 $\\varepsilon_{\\text{mv}} = \\max_{\\mathbf{i}\\in\\Omega} | (\\mathbf{T}\\mathbf{w})_{\\text{direct}}[\\mathbf{i}] - (\\mathbf{T}\\mathbf{w})_{\\text{FFT}}[\\mathbf{i}] |$ 和 $\\varepsilon_{\\text{it}} = \\max_{\\mathbf{i}\\in\\Omega} | \\mathbf{w}^{(J)}_{\\text{direct}}[\\mathbf{i}] - \\mathbf{w}^{(J)}_{\\text{FFT}}[\\mathbf{i}] |$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于波散射和积分方程数值方法的原理，这些是计算物理和工程领域的标准内容。该公式是适定的，为获得唯一的数值解提供了所有必要的定义和参数。语言客观而精确。该问题是可形式化的，并与其所述主题直接相关。问题设定是自洽且一致的；所选的填充尺寸对于避免基于 FFT 的卷积中的混叠是正确的。对于给定的参数，数值任务是可行的。结构逻辑清晰，从理论推导引导到实现和比较。在验证清单中未发现任何缺陷。\n\n**步骤 3：结论与行动**\n该问题有效。将提供完整解答。\n\n### 解答\n\n解答按规定分为三部分：推导、算法设计和迭代背景描述。\n\n**A 部分：基于 FFT 的卷积推导**\n\n离散算子 $\\mathbf{T}$ 定义为 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}]$，其中 $\\mathbf{i} \\in \\Omega$。这是核 $h$ 与离散源 $\\mathbf{w}$ 的三维线性卷积的定义，其输出限制在域 $\\Omega$ 内。核 $h[\\mathbf{d}]$ 仅依赖于索引差 $\\mathbf{d} = \\mathbf{i} - \\mathbf{j}$。当 $\\mathbf{i}$ 和 $\\mathbf{j}$ 在 $\\Omega=\\{0,\\dots,N_x-1\\}\\times\\dots$ 范围内变化时，差分向量 $\\mathbf{d}$ 的分量范围对于第一维是 $-(N_x-1)$ 到 $N_x-1$，其他维度类似。因此，核 $h$ 的支撑集大小为 $(2N_x-1) \\times (2N_y-1) \\times (2N_z-1)$。\n\n卷积定理指出，循环卷积可以在傅里叶域中使用逐元素乘法高效计算。要使用 FFT 计算线性卷积，我们必须将问题嵌入一个更大的周期域中，使得线性卷积和循环卷积在此域中等效。这需要将信号和核都进行零填充，填充到一个足够大的尺寸以防止回卷误差（混叠）。一个尺寸为 $N_x$ 的信号和一个尺寸为 $M_x = 2N_x-1$ 的核的完整线性卷积结果的尺寸为 $N_x+M_x-1 = N_x+(2N_x-1)-1 = 3N_x-2$。问题正确地指定了每个维度的填充尺寸为 $L_\\ell = 3N_\\ell - 2$。\n\n让我们分析将核 $h$ 嵌入到尺寸为 $L_x \\times L_y \\times L_z$ 的填充网格上的循环核 $\\tilde{h}$ 的具体过程。为清晰起见，我们考虑一维情况。$\\tilde{h}$ 的索引 $p$ 的范围是从 $0$ 到 $L_x-1$。在此范围内，$p \\bmod L_x = p$。公式变为 $\\tilde{h}[p] = h[p - (N_x-1)]$。$h$ 的参数，我们称之为 $d_x = p - (N_x-1)$，其范围从 $-(N_x-1)$ 到 $L_x-1-(N_x-1) = (3N_x-2)-1-(N_x-1) = 2N_x-2$。然而，核 $h[d_x]$ 仅在 $d_x \\in [-(N_x-1), N_x-1]$ 时非零。这对应于 $p \\in [0, 2N_x-2]$。\n基于 FFT 的计算产生循环卷积 $C[\\mathbf{i}] = (\\tilde{h} \\circledast \\tilde{w})[\\mathbf{i}]$，其中 $\\tilde{w}$ 是源数组 $\\mathbf{w}$ 零填充到尺寸 $L_x \\times L_y \\times L_z$ 的结果。让我们分析一维情况下的结果：\n$$ C[i] = \\sum_{j=0}^{L_x-1} \\tilde{h}[(i-j)\\pmod{L_x}] \\tilde{w}[j] $$\n由于 $\\tilde{w}[j]$ 仅在 $j \\in [0, N_x-1]$ 时非零，求和简化为：\n$$ C[i] = \\sum_{j=0}^{N_x-1} \\tilde{h}[(i-j)\\pmod{L_x}] w[j] $$\n代入 $\\tilde{h}$ 的定义：\n$$ C[i] = \\sum_{j=0}^{N_x-1} h\\left[\\left((i-j)\\pmod{L_x}\\right) - (N_x-1)\\right] w[j] $$\n定义一个移位的索引 $i' = i - (N_x-1)$。表达式变为：\n$$ C[i] = \\sum_{j=0}^{N_x-1} h\\left[\\left((i' + N_x - 1 - j)\\pmod{L_x}\\right) - (N_x-1)\\right] w[j] $$\n这种形式不是很直观。我们换个角度，考虑核的构造效果。\n所指定的核 $\\tilde{h}$ 是线性卷积核的重新排列版本。让我们定义一个临时核 $h_s$，其索引从 $0$ 到 $2N_x-2$，使得 $h_s[p] = h[p-(N_x-1)]$。卷积 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}]$ 等效于线性卷积 $(h_s * \\mathbf{w})[\\mathbf{i} + (N_{\\cdot}-1, \\dots)]$。也就是说，与 $h_s$ 卷积的结果是所需结果的一个移位版本。\n设 $(\\mathbf{T}_s\\mathbf{w})$ 为 $h_s$ 和 $\\mathbf{w}$ 的完整线性卷积。\n$$ (\\mathbf{T}_s\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j} \\in \\Omega} h_s[\\mathbf{i}-\\mathbf{j}] \\mathbf{w}[\\mathbf{j}] = \\sum_{\\mathbf{j} \\in \\Omega} h[(\\mathbf{i}-(N_{\\cdot}-1))-\\mathbf{j}] \\mathbf{w}[\\mathbf{j}] = (\\mathbf{T}\\mathbf{w})[\\mathbf{i}-(N_{\\cdot}-1)] $$\n其中 $(N_{\\cdot}-1)$ 是 $(N_x-1, N_y-1, N_z-1)$ 的简写。\n使用核 $\\tilde{h}$（它是 $h_s$ 的零填充版本）的 FFT 过程计算的是 $(\\mathbf{T}_s\\mathbf{w})$。\n我们希望恢复 $\\mathbf{i}' \\in \\Omega$ 时的 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}']$。这由 $(\\mathbf{T}_s\\mathbf{w})[\\mathbf{i}' + (N_{\\cdot}-1)]$ 给出。\n这意味着对于索引 $\\mathbf{i}' \\in \\{0, \\dots, N_x-1\\} \\times \\dots$，所需输出位于基于 FFT 的卷积输出数组中索引为 $\\mathbf{i} = \\mathbf{i}' + (N_x-1, N_y-1, N_z-1)$ 的位置。这对应的索引范围是：\n$$ i_x \\in [N_x-1, 2N_x-2] \\\\ i_y \\in [N_y-1, 2N_y-2] \\\\ i_z \\in [N_z-1, 2N_z-2] $$\n问题将此称为“中心子块”。其尺寸确实是 $(2N_x-2) - (N_x-1) + 1 = N_x$，其他维度也一样，与 $\\Omega$ 的尺寸匹配。因此，要获得 $\\mathbf{i} \\in \\Omega$ 时的 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}]$，必须提取 IFFT 结果中从索引 $(N_x-1, N_y-1, N_z-1)$ 到 $(2N_x-2, 2N_y-2, 2N_z-2)$（包含边界）的子数组。\n\n**B 部分：算法设计**\n\n为矩阵向量积 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$ 设计了两种算法。\n\n1.  **直接法**：该方法字面地实现离散卷积和。对于域 $\\Omega$ 中的每个输出点 $\\mathbf{i}=(i_x, i_y, i_z)$，通过对域 $\\Omega$ 中所有源点 $\\mathbf{j}=(j_x, j_y, j_z)$ 的贡献求和来计算值 $\\mathbf{y}[\\mathbf{i}]$。\n    $$ \\mathbf{y}[i_x, i_y, i_z] = \\sum_{j_x=0}^{N_x-1} \\sum_{j_y=0}^{N_y-1} \\sum_{j_z=0}^{N_z-1} h[i_x-j_x, i_y-j_y, i_z-j_z]\\, \\mathbf{w}[j_x, j_y, j_z] $$\n    核函数值 $h[\\mathbf{d}]$ 可以即时计算，或为所有可能的差分向量 $\\mathbf{d}$ 预先计算。这涉及一个六重嵌套循环，导致计算复杂度为 $O((N_x N_y N_z)^2)$，对于大网格而言计算量过大。\n\n2.  **FFT 加速法**：该方法利用了卷积定理，包含五个步骤：\n    1.  **构建离散核**：为所有差分索引 $d_\\ell \\in [-(N_\\ell-1), N_\\ell-1]$ 预计算核函数值 $h[\\mathbf{d}]$。这些值可以存储在一个尺寸为 $(2N_x-1) \\times (2N_y-1) \\times (2N_z-1)$ 的三维数组中，以便高效查找。\n    2.  **嵌入循环核**：创建一个尺寸为 $(L_x, L_y, L_z)$ 的复值数组 $\\tilde{\\mathbf{h}}$。根据规则 $\\tilde{h}[p,q,r] = h[p-(N_x-1), q-(N_y-1), r-(N_z-1)]$ 填充该数组，其中 $(p,q,r)$ 使得参数在 $h$ 的支撑集内；否则 $\\tilde{h}[p,q,r] = 0$。\n    3.  **零填充源**：创建一个尺寸为 $(L_x, L_y, L_z)$ 的复值数组 $\\tilde{\\mathbf{w}}$。将源数组 $\\mathbf{w}$ 复制到对应于索引 $[0, N_x-1]\\times[0, N_y-1]\\times[0, N_z-1]$ 的子块中，$\\tilde{\\mathbf{w}}$ 的其余元素设为零。\n    4.  **通过 FFT 计算循环卷积**：执行以下傅里叶域操作：\n        -   使用 3D FFT 计算 $\\tilde{\\mathbf{H}} = \\mathcal{F}(\\tilde{\\mathbf{h}})$。\n        -   使用 3D FFT 计算 $\\tilde{\\mathbf{W}} = \\mathcal{F}(\\tilde{\\mathbf{w}})$。\n        -   $\\tilde{\\mathbf{Y}} = \\tilde{\\mathbf{H}} \\odot \\tilde{\\mathbf{W}}$ (逐元素乘积)。\n        -   使用 3D 逆 FFT 计算 $\\tilde{\\mathbf{y}} = \\mathcal{F}^{-1}(\\tilde{\\mathbf{Y}})$。\n    5.  **提取结果**：通过提取 $\\tilde{\\mathbf{y}}$ 中对应于索引范围 $[N_x-1:2N_x-1]$、$ [N_y-1:2N_y-1]$ 和 $[N_z-1:2N_z-1]$ 的子数组，获得最终结果 $\\mathbf{y} = \\mathbf{T}\\mathbf{w}$。该方法的复杂度主要由 FFT 决定，为 $O(L_x L_y L_z \\log(L_x L_y L_z))$。\n\n**C 部分：迭代 CSIE 背景**\n\n不动点迭代根据以下规则更新对比度源 $\\mathbf{w}$：\n$$ \\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big) $$\n从初始猜测 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 开始，此更新规则被应用 $J$ 次。每次迭代的核心是矩阵向量积 $\\mathbf{T}\\mathbf{w}^{(n)}$。我们实现了这个迭代求解器的两个版本：一个使用直接卷积计算 $\\mathbf{T}$，另一个使用 FFT 加速方法。经过 $J$ 次迭代后，比较最终数组 $\\mathbf{w}^{(J)}_{\\text{direct}}$ 和 $\\mathbf{w}^{(J)}_{\\text{FFT}}$。由有限精度算术引起的直接法和 FFT 矩阵向量积之间的任何差异，都可能在迭代过程中被放大或减小，这取决于算子的性质。比较最终迭代结果可以洞察在这种迭代背景下使用基于 FFT 的求解器的数值稳定性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fftn, ifftn\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # ((Nx, Ny, Nz), a, k, J, seed)\n        ((1, 1, 1), 1.0, 1.0, 5, 123),\n        ((3, 3, 3), 0.5, 2.0, 5, 456),\n        ((4, 3, 2), 0.4, 1.3, 7, 789),\n    ]\n\n    results = []\n    for case in test_cases:\n        dims, a, k, J, seed = case\n        Nx, Ny, Nz = dims\n\n        # Generate problem data using the specified seed\n        rng = np.random.default_rng(seed)\n        shape = (Nx, Ny, Nz)\n        w_test = rng.random(shape, dtype=np.float64) + 1j * rng.random(shape, dtype=np.float64)\n        chi = rng.random(shape, dtype=np.float64)\n        E_inc = rng.random(shape, dtype=np.float64) + 1j * rng.random(shape, dtype=np.float64)\n\n        # 1. Compare direct and FFT-based matrix-vector products\n        h_kernel = build_h_kernel(Nx, Ny, Nz, a, k, alpha=0.5)\n        \n        y_direct = matvec_direct(w_test, h_kernel, Nx, Ny, Nz)\n        y_fft = matvec_fft(w_test, h_kernel, Nx, Ny, Nz)\n        \n        eps_mv = np.max(np.abs(y_direct - y_fft))\n\n        # 2. Compare direct and FFT-based iterative solvers\n        def matvec_direct_func(w_in):\n            return matvec_direct(w_in, h_kernel, Nx, Ny, Nz)\n        \n        def matvec_fft_func(w_in):\n            return matvec_fft(w_in, h_kernel, Nx, Ny, Nz)\n\n        w_final_direct = csie_iterate(E_inc, chi, J, matvec_direct_func)\n        w_final_fft = csie_iterate(E_inc, chi, J, matvec_fft_func)\n\n        eps_it = np.max(np.abs(w_final_direct - w_final_fft))\n        \n        results.append([eps_mv, eps_it])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef green_function(r, k):\n    \"\"\"Computes the 3D scalar Helmholtz Green's function.\"\"\"\n    if r == 0:\n        # This case should be handled by the regularized self-term, but as a fallback.\n        return np.inf\n    return np.exp(1j * k * r) / (4 * np.pi * r)\n\ndef build_h_kernel(Nx, Ny, Nz, a, k, alpha=0.5):\n    \"\"\"\n    Pre-computes and stores the discrete convolution kernel h[d].\n    Returns a dictionary mapping index difference (dx,dy,dz) to kernel value.\n    \"\"\"\n    h = {}\n    rc = alpha * a\n    \n    for dx in range(-(Nx - 1), Nx):\n        for dy in range(-(Ny - 1), Ny):\n            for dz in range(-(Nz - 1), Nz):\n                d = (dx, dy, dz)\n                if d == (0, 0, 0):\n                    # Regularized self-term\n                    val = a**3 * green_function(rc, k)\n                else:\n                    dist = a * np.sqrt(dx**2 + dy**2 + dz**2)\n                    val = a**3 * green_function(dist, k)\n                h[d] = val\n    return h\n\ndef matvec_direct(w, h_kernel, Nx, Ny, Nz):\n    \"\"\"Computes y = T*w using direct summation.\"\"\"\n    y = np.zeros((Nx, Ny, Nz), dtype=np.complex128)\n    for ix in range(Nx):\n        for iy in range(Ny):\n            for iz in range(Nz):\n                acc = 0.0j\n                for jx in range(Nx):\n                    for jy in range(Ny):\n                        for jz in range(Nz):\n                            dx, dy, dz = ix - jx, iy - jy, iz - jz\n                            acc += h_kernel[(dx, dy, dz)] * w[jx, jy, jz]\n                y[ix, iy, iz] = acc\n    return y\n\ndef matvec_fft(w, h_kernel, Nx, Ny, Nz):\n    \"\"\"Computes y = T*w using FFT-based convolution.\"\"\"\n    Lx, Ly, Lz = 3 * Nx - 2, 3 * Ny - 2, 3 * Nz - 2\n    padded_shape = (Lx, Ly, Lz)\n\n    # Embed kernel h into the circulant kernel h_tilde on the padded grid\n    h_tilde = np.zeros(padded_shape, dtype=np.complex128)\n    for p in range(Lx):\n        for q in range(Ly):\n            for r in range(Lz):\n                # Calculate difference indices according to the problem's formula\n                dx = p - (Nx - 1)\n                dy = q - (Ny - 1)\n                dz = r - (Nz - 1)\n                \n                # Check if the difference index is in the pre-computed kernel's support\n                if (dx, dy, dz) in h_kernel:\n                    h_tilde[p, q, r] = h_kernel[(dx, dy, dz)]\n\n    # Zero-pad the source array w\n    w_tilde = np.zeros(padded_shape, dtype=np.complex128)\n    w_tilde[0:Nx, 0:Ny, 0:Nz] = w\n\n    # Compute convolution in the Fourier domain\n    H_tilde = fftn(h_tilde)\n    W_tilde = fftn(w_tilde)\n    Y_tilde = H_tilde * W_tilde\n    y_tilde = ifftn(Y_tilde)\n\n    # Extract the correct central sub-block\n    y = y_tilde[Nx-1 : 2*Nx-1, Ny-1 : 2*Ny-1, Nz-1 : 2*Nz-1]\n\n    return y\n\ndef csie_iterate(E_inc, chi, J, matvec_func):\n    \"\"\"Performs J fixed-point iterations for the CSIE.\"\"\"\n    shape = E_inc.shape\n    w = np.zeros(shape, dtype=np.complex128)\n    for _ in range(J):\n        T_w = matvec_func(w)\n        w = chi * (E_inc + T_w)\n    return w\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了如何高效计算算子之后，下一步是提升迭代求解器的收敛性能。CSIE离散后形成的线性系统矩阵的条件数直接影响迭代求解的速度和稳定性。本实践将引导你探索一种简单而有效的对角预条件技术，通过构建并应用基于算子自作用项 (self-term) 的预条件子，你将亲身体验并量化分析其对算子谱和条件数的改善效果 ()。",
            "id": "3295386",
            "problem": "考虑一个有限区间上的一维标量亥姆霍兹散射问题，其中总场 $u(x)$ 满足 Lippmann–Schwinger 体积分方程\n$$\nu(x) = u^{\\mathrm{inc}}(x) + \\int_{D} G_k\\!\\left(\\lvert x - x' \\rvert\\right) \\, w(x') \\, \\mathrm{d}x',\n$$\n对于 $x \\in D$，衬度源为 $w(x) = \\chi(x) u(x)$，一维亥姆霍兹算子的自由空间格林函数由下式给出：\n$$\nG_k(r) = \\frac{i}{2k} e^{ik r},\n$$\n其中 $k$ 是波数。假设衬度 $\\chi(x)$ 在 $D$ 上是分段常数。\n\n定义衬度源积分方程算子 $\\mathcal{T}$ 如下：\n$$\n(\\mathcal{T} w)(x) = \\int_{D} G_k\\!\\left(\\lvert x - x' \\rvert\\right) \\, w(x') \\, \\mathrm{d}x'.\n$$\n在采用配置点 $\\{x_j\\}_{j=0}^{N-1}$ 和求积权重 $\\{w_j\\}_{j=0}^{N-1}$ 的配置离散化下，算子 $\\mathcal{T}$ 可由矩阵 $T \\in \\mathbb{C}^{N \\times N}$ 近似，其元素为\n$$\nT_{ij} = G_k\\!\\left(\\lvert x_i - x_j \\rvert\\right) \\, w_j.\n$$\n$w$ 的离散衬度源方程可以写成如下形式\n$$\nA \\, \\mathbf{w} = \\mathbf{b}, \\quad \\text{其中} \\quad A = I - \\chi \\, T,\n$$\n其中 $I$ 是单位矩阵，$\\chi$ 是常数衬度，$\\mathbf{b}$ 从入射场导出。$T$ 的对角线（自相互作用项）为 $T_{ii} = G_k(0)\\, w_i$。\n\n任务：\n1. 从 $T$ 的自相互作用项（对角线）构造一个对角左预条件子 $M$，并形成左预处理算子 $M^{-1} A$。\n2. 通过计算两个定量指标：谱半径和 2-范数条件数，来分析此预条件子对离散化算子谱的影响。具体来说，计算以下比率：\n$$\n\\rho_{\\mathrm{ratio}} = \\frac{\\rho(M^{-1} A)}{\\rho(A)}, \\qquad \\kappa_{\\mathrm{ratio}} = \\frac{\\kappa_2(M^{-1} A)}{\\kappa_2(A)},\n$$\n其中 $\\rho(\\cdot)$ 表示谱半径，$\\kappa_2(\\cdot)$ 表示 2-范数条件数。这些比率是无量纲的实值浮点数。\n\n离散化细节：\n- 设域为 $D = [0, L]$，长度 $L$ 以米为单位。\n- 使用一个由 $x_j = L \\, s_j^p$（对于 $j = 0, 1, \\dots, N-1$）定义的非均匀配置网格，其中 $s_j = j/(N-1)$ 且 $p \\ge 1$ 是一个网格分级参数。较大的 $p$ 会增加非均匀性。\n- 求积权重定义如下\n$$\nw_0 = \\frac{1}{2}(x_1 - x_0), \\quad w_{N-1} = \\frac{1}{2}(x_{N-1} - x_{N-2}), \\quad w_j = \\frac{1}{2}(x_{j+1} - x_{j-1}) \\text{ for } j = 1, \\dots, N-2.\n$$\n\n预条件子：\n- 构造对角矩阵 $M \\in \\mathbb{C}^{N \\times N}$，其元素为 $M_{ii} = T_{ii} = G_k(0)\\, w_i$，并形成 $M^{-1} A$。\n\n你的程序必须：\n- 实现上述的离散化和算子构造。\n- 计算特征值以获得谱半径，并使用奇异值分解来获得 2-范数条件数。\n- 对每个测试用例，输出数对 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$ 作为两个浮点数。\n\n单位和输出：\n- 使用以米为单位的 $L$ 和以弧度/米为单位的 $k$。输出 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$ 是无量纲的，并且必须以浮点数形式打印。\n- 任何三角函数量的角度单位都是弧度。\n\n测试套件：\n为以下四个测试用例 $(N, L, k, \\chi, p)$ 提供计算：\n1. $(64, 1.0, 20.0, 0.5, 1.0)$: 均匀网格基准。\n2. $(64, 1.0, 20.0, 0.5, 2.5)$: 具有相同波数和衬度的强非均匀网格。\n3. $(32, 1.0, 5.0, 2.0, 3.0)$: 在中度非均匀网格上的中等波数和较高衬度。\n4. $(16, 1.0, 0.5, 0.2, 4.0)$: 低波数、低衬度、小型强分级网格。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按照测试用例的顺序展平，每个测试用例贡献恰好两个浮点数 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$。例如，输出应如下所示：\n$$\n[\\kappa_{\\mathrm{ratio},1}, \\rho_{\\mathrm{ratio},1}, \\kappa_{\\mathrm{ratio},2}, \\rho_{\\mathrm{ratio},2}, \\kappa_{\\mathrm{ratio},3}, \\rho_{\\mathrm{ratio},3}, \\kappa_{\\mathrm{ratio},4}, \\rho_{\\mathrm{ratio},4}].\n$$",
            "solution": "该问题要求分析一个针对一维标量亥姆霍兹散射问题产生的离散化衬度源积分方程的特定对角预条件子。分析过程涉及计算系统矩阵在预处理前后的谱半径和 2-范数条件数，然后求出它们的比率。\n\n对于每个测试用例 $(N, L, k, \\chi, p)$，求解过程按以下步骤进行：\n\n1.  **域的离散化和求积法则**\n    域 $D = [0, L]$ 通过一组 $N$ 个配置点 $\\{x_j\\}_{j=0}^{N-1}$ 进行离散化。这些点根据非均匀网格公式 $x_j = L s_j^p$ 生成，其中 $s_j = j/(N-1)$（对于 $j \\in \\{0, 1, \\dots, N-1\\}$），$p \\ge 1$ 是网格分级参数。$p=1$ 对应于均匀网格。\n\n    Lippmann-Schwinger 方程中的积分使用带有权重 $\\{w_j\\}_{j=0}^{N-1}$ 的数值求积法则进行近似。对于一般网格，权重基于类似梯形的法则定义：\n    $$\n    w_0 = \\frac{1}{2}(x_1 - x_0)\n    $$\n    $$\n    w_j = \\frac{1}{2}(x_{j+1} - x_{j-1}) \\quad \\text{for } j \\in \\{1, \\dots, N-2\\}\n    $$\n    $$\n    w_{N-1} = \\frac{1}{2}(x_{N-1} - x_{N-2})\n    $$\n    这些权重代表与每个配置点 $x_j$ 相关联的区间的有效长度。\n\n2.  **系统矩阵 $A$ 的构造**\n    连续积分算子 $\\mathcal{T}$ 被离散化为一个矩阵 $T \\in \\mathbb{C}^{N \\times N}$。$T$ 的元素由 $T_{ij} = G_k(\\lvert x_i - x_j \\rvert) w_j$ 给出，其中 $x_i$ 是观测点，$x_j$ 是源点。亥姆霍兹方程的一维自由空间格林函数是 $G_k(r) = \\frac{i}{2k} e^{ikr}$。\n    \n    离散衬度源方程为 $A \\mathbf{w} = \\mathbf{b}$，其中 $\\mathbf{w}$ 是配置点处未知衬度源值 $w(x_j)$ 的向量。系统矩阵 $A \\in \\mathbb{C}^{N \\times N}$ 定义为：\n    $$\n    A = I - \\chi T\n    $$\n    其中 $I$ 是 $N \\times N$ 的单位矩阵，$\\chi$ 是常数衬度。\n\n3.  **预条件子 $M$ 和预处理系统的构造**\n    问题指定了一个从算子 $T$ 的“自相互作用项”构造的对角左预条件子 $M$。自相互作用项对应于矩阵 $T$ 的对角线元素。矩阵 $M$ 是一个对角矩阵，其对角线元素与 $T$ 的相同：\n    $$\n    M_{ii} = T_{ii} = G_k(\\lvert x_i - x_i \\rvert) w_i = G_k(0) w_i = \\left(\\frac{i}{2k}\\right) w_i\n    $$\n    且当 $i \\neq j$ 时 $M_{ij} = 0$。由于对于指定的网格 $k>0$ 且所有 $w_i > 0$，所有对角线元素 $M_{ii}$ 都是非零的。因此，逆矩阵 $M^{-1}$ 存在，并且是一个对角矩阵，其元素为 $(M^{-1})_{ii} = 1/M_{ii}$。\n\n    然后，通过在左侧用 $M^{-1}$ 乘以 $A$ 来形成左预处理系统矩阵：\n    $$\n    A_{\\mathrm{prec}} = M^{-1} A = M^{-1}(I - \\chi T)\n    $$\n\n4.  **谱度量和比率的计算**\n    为了分析预条件子的效果，对原始矩阵 $A$ 和预处理矩阵 $A_{\\mathrm{prec}}$ 计算了两个定量指标：\n\n    a.  **谱半径 $\\rho(\\cdot)$**：矩阵的谱半径是其特征值的最大绝对值。我们计算矩阵的特征值 $\\lambda_j$ 并求得 $\\rho = \\max_j |\\lambda_j|$。\n    b.  **2-范数条件数 $\\kappa_2(\\cdot)$**：矩阵在 2-范数下的条件数是其最大奇异值与最小奇异值之比，即 $\\kappa_2 = \\sigma_{\\max} / \\sigma_{\\min}$。奇异值通过奇异值分解（SVD）计算。\n\n    最后，计算这些度量的比率以量化预条件子的有效性：\n    $$\n    \\rho_{\\mathrm{ratio}} = \\frac{\\rho(M^{-1} A)}{\\rho(A)}\n    $$\n    $$\n    \\kappa_{\\mathrm{ratio}} = \\frac{\\kappa_2(M^{-1} A)}{\\kappa_2(A)}\n    $$\n    $\\kappa_{\\mathrm{ratio}}  1$ 的值表明预条件子改善了线性系统的条件，这对于迭代求解器通常是理想的。\n\n该实现将对每个提供的测试用例执行这些步骤，使用数值库进行矩阵构造以及特征值和奇异值分解。最终输出是每个测试用例的数对 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$ 的展平列表。",
            "answer": "```python\nimport numpy as np\n\ndef compute_ratios(params):\n    \"\"\"\n    Computes spectral radius and condition number ratios for a given parameter set.\n    \"\"\"\n    N, L, k, chi, p = params\n    \n    # 1. Discretization: Grid points and quadrature weights\n    s = np.linspace(0.0, 1.0, N)\n    x = L * s**p\n    \n    w = np.zeros(N, dtype=float)\n    if N > 1:\n        # First point weight\n        w[0] = 0.5 * (x[1] - x[0])\n        # Last point weight\n        w[-1] = 0.5 * (x[-1] - x[-2])\n        # Interior point weights\n        if N > 2:\n            w[1:-1] = 0.5 * (x[2:] - x[:-2])\n\n    # 2. Green's function\n    def Gk(r):\n        return (1j / (2.0 * k)) * np.exp(1j * k * r)\n\n    # 3. Construct the operator matrix T\n    # Create a matrix of distances |x_i - x_j|\n    x_col = x.reshape(-1, 1)\n    dist_matrix = np.abs(x_col - x)\n    \n    # Evaluate Green's function for all distances\n    Gk_matrix = Gk(dist_matrix)\n    \n    # Construct T by scaling columns by quadrature weights\n    # w is broadcasted to each row of Gk_matrix\n    T = Gk_matrix * w\n\n    # 4. Construct the system matrix A\n    I = np.eye(N, dtype=np.complex128)\n    A = I - chi * T\n\n    # 5. Construct the preconditioner M and preconditioned matrix A_prec\n    # M is a diagonal matrix with M_ii = T_ii\n    T_diag_entries = np.diag(T)\n    # The inverse M_inv is a diagonal matrix with 1/T_ii on its diagonal.\n    # Since k>0 and w_i>0, T_diag_entries are non-zero.\n    M_inv = np.diag(1.0 / T_diag_entries)\n    A_prec = M_inv @ A\n\n    # 6. Compute spectral metrics for A\n    eigvals_A = np.linalg.eigvals(A)\n    rho_A = np.max(np.abs(eigvals_A))\n    s_A = np.linalg.svd(A, compute_uv=False)\n    # Handle potentially singular matrices, though not expected here\n    kappa_A = np.max(s_A) / np.min(s_A) if np.min(s_A) > 1e-15 else np.inf\n\n    # 7. Compute spectral metrics for A_prec\n    eigvals_A_prec = np.linalg.eigvals(A_prec)\n    rho_A_prec = np.max(np.abs(eigvals_A_prec))\n    s_A_prec = np.linalg.svd(A_prec, compute_uv=False)\n    kappa_A_prec = np.max(s_A_prec) / np.min(s_A_prec) if np.min(s_A_prec) > 1e-15 else np.inf\n\n    # 8. Compute the final ratios\n    rho_ratio = rho_A_prec / rho_A\n    kappa_ratio = kappa_A_prec / kappa_A\n    \n    return kappa_ratio, rho_ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, k, chi, p)\n        (64, 1.0, 20.0, 0.5, 1.0),\n        (64, 1.0, 20.0, 0.5, 2.5),\n        (32, 1.0, 5.0, 2.0, 3.0),\n        (16, 1.0, 0.5, 0.2, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case.\n        kappa_ratio, rho_ratio = compute_ratios(case)\n        results.extend([kappa_ratio, rho_ratio])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "对比源积分方程不仅是正演模拟的工具，更是反演成像算法的基石，能够从外部测量数据中重构散射体的未知属性。本节高级实践将带你进入对比源反演 (Contrast Source Inversion, CSI) 领域。你将实现一个交替最小化迭代步骤，以同时求解未知的对比源和材料属性，并学习如何应用正则化技术（如总变分正则化）来处理不适定的反演问题 ()。",
            "id": "3295387",
            "problem": "考虑一个由标量亥姆霍兹方程控制的一维时谐散射问题。设一维自由空间格林函数为 $G(x,x') = -\\mathrm{i}/(2k_0)\\exp(\\mathrm{i}k_0|x-x'|)$，其中角波数为 $k_0$。未知对比源 $\\mathbf{w}$ 和电纳对比度 $\\chi_e$ 通过总场 $\\mathbf{E} = \\mathbf{E}^{\\mathrm{inc}} + \\mathcal{G}\\mathbf{w}$ 相关联，其中 $\\mathbf{E}^{\\mathrm{inc}}$ 是入射场，$\\mathcal{G}$ 是由格林函数定义的体积积分算子。对比源反演 (CSI) 方法通过交替最小化关于 $\\mathbf{w}$ 和 $\\chi_e$ 的复合目标函数来求解。该目标函数由一个数据失配项和一个状态一致性项组成，并辅以正则化。在均匀网格上的离散形式中，使用前向差分计算空间梯度，并对 $\\chi_e$ 使用平滑总变分 (TV) 惩罚项。\n\n从标量亥姆霍兹模型和场的积分表示出发，推导在每个交替步骤中分别求解 $\\mathbf{w}$ 和 $\\chi_e$ 的正规方程，此时目标泛函是数据失配的平方和与状态一致性失配的平方和之和，并辅以对 $\\mathbf{w}$ 的吉洪诺夫 (Tikhonov) 惩罚项和对 $\\chi_e$ 的平滑总变分惩罚项。然后，实现一个 CSI 单次迭代，该迭代使用这些正规方程执行一次 $\\mathbf{w}$ 更新，随后执行一次 $\\chi_e$ 更新。\n\n在长度为 $L$ 的线段上使用一个包含 $N$ 个点的均匀网格，单元中心位于 $x_j = -L/2 + (j+1/2)\\Delta x$，其中 $j = 0,1,\\dots,N-1$ 且 $\\Delta x = L/N$。通过中点法则离散化积分算子，使得矩阵 $\\mathbf{G}\\in\\mathbb{C}^{N\\times N}$ 的元素为 $G_{ij} = G(x_i,x_j)\\Delta x$。通过选择网格点索引的一个子集来模拟测量，这由一个投影 $\\mathbf{P}\\in\\mathbb{R}^{M\\times N}$ 表示，它选取单位矩阵的 $M$ 行。预测的测量值为 $\\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w})$。\n\n定义以下离散目标泛函，并针对 $\\mathbf{w}\\in\\mathbb{C}^N$ 和 $\\chi_e\\in\\mathbb{R}^N$ 交替最小化：\n$$\nJ(\\mathbf{w},\\chi_e) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2},\n$$\n其中 $D\\in\\mathbb{R}^{(N-1)\\times N}$ 是前向差分矩阵，满足 $(D\\chi_e)_j = \\chi_{e,j+1} - \\chi_{e,j}$，并且 $\\eta0$、$\\lambda_w\\ge 0$、$\\lambda_{\\mathrm{TV}}\\ge 0$、$\\epsilon_{\\mathrm{TV}}0$ 是给定的权重。\n\n程序必须：\n- 使用一维格林函数和中点法则构建 $\\mathbf{G}$。\n- 对于每个测试用例，从一个已知的真实对比度 $\\chi_e^{\\mathrm{true}}$ 生成合成测量数据 $\\mathbf{d}$。具体方法是求解 $(\\mathbf{I} - \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{G})\\mathbf{w}^{\\mathrm{true}} = \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{E}^{\\mathrm{inc}}$，然后设置 $\\mathbf{d} = \\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{\\mathrm{true}})$，除非被明确覆盖。\n- 从 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 和 $\\chi_e^{(0)} = \\mathbf{0}$ 开始，执行一次交替最小化迭代：\n  1. 通过求解最小化 $J(\\mathbf{w},\\chi_e^{(0)})$ 关于 $\\mathbf{w}$ 所产生的正规方程来更新 $\\mathbf{w}^{(1)}$。\n  2. 通过求解最小化 $J(\\mathbf{w}^{(1)},\\chi_e)$ 关于 $\\chi_e$ 所产生的正规方程（使用单个迭代重加权最小二乘步骤，权重由 $\\chi_e^{(0)}$ 计算）来更新 $\\chi_e^{(1)}$。\n- 为每个测试用例计算两个标量：数据失配范数 $r_{\\mathrm{data}} = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right) - \\mathbf{d}\\right\\|_2$ 和状态一致性失配范数 $r_{\\mathrm{state}} = \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e^{(1)})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2$。\n\n使用以下参数值的测试套件，这些参数共同涵盖了典型、边界和边缘情况：\n- 测试用例 1（一般情况）：$N=32$，$L=1.0$，$k_0=40.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=10^{-2}$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。入射场为 $\\mathbf{E}^{\\mathrm{inc}}$，其元素为 $E^{\\mathrm{inc}}_j = \\exp(\\mathrm{i}k_0 x_j)$。测量投影 $\\mathbf{P}$ 选择偶数索引的网格点（$j=0,2,4,\\dots$）。真实对比度是一个中心化的顶帽函数：当 $|x_j|\\le 0.15$ 时 $\\chi_{e,j}^{\\mathrm{true}} = 0.5$，否则 $\\chi_{e,j}^{\\mathrm{true}} = 0.0$。\n- 测试用例 2（边界正则化情况）：$N=16$，$L=1.0$，$k_0=20.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=0.0$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。$\\mathbf{P}$ 选择偶数索引的网格点。真实对比度是一个线性斜坡：$\\chi_{e,j}^{\\mathrm{true}} = 0.4\\left(1 + x_j/L\\right)$。\n- 测试用例 3（数据为零的边缘情况）：$N=16$，$L=1.0$，$k_0=20.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=10^{-2}$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。$\\mathbf{P}$ 选择偶数索引的网格点。无论真实对比度如何，都将测量值覆盖为 $\\mathbf{d} = \\mathbf{0}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表。该列表必须按顺序包含三个测试用例中每一个的 $r_{\\mathrm{data}}$ 和 $r_{\\mathrm{state}}$，两者均为十进制数。例如，输出格式必须为 $[r_{\\mathrm{data},1},r_{\\mathrm{state},1},r_{\\mathrm{data},2},r_{\\mathrm{state},2},r_{\\mathrm{data},3},r_{\\mathrm{state},3}]$。输出中不需要物理单位。",
            "solution": "用户希望为一个一维标量亥姆霍兹散射问题实现对比源反演（CSI）方法的单次迭代。这需要推导交替最小化步骤的正规方程，然后加以实现。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n- **控制方程**：标量亥姆霍兹方程。\n- **格林函数**：$G(x,x') = -\\mathrm{i}/(2k_0)\\exp(\\mathrm{i}k_0|x-x'|)$。\n- **场关系**：$\\mathbf{E} = \\mathbf{E}^{\\mathrm{inc}} + \\mathcal{G}\\mathbf{w}$。\n- **离散化**：在长度为 $L$ 的区域上使用包含 $N$ 个点的均匀网格。单元中心 $x_j = -L/2 + (j+1/2)\\Delta x$，其中 $j = 0,\\dots,N-1$ 且 $\\Delta x = L/N$。\n- **积分算子离散化**：矩阵 $\\mathbf{G}\\in\\mathbb{C}^{N\\times N}$，其元素为 $G_{ij} = G(x_i,x_j)\\Delta x$。\n- **测量算子**：投影 $\\mathbf{P}\\in\\mathbb{R}^{M\\times N}$，用于选择 $M$ 个网格点。\n- **目标泛函**：\n$$\nJ(\\mathbf{w},\\chi_e) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n- **前向差分算子**：$D\\in\\mathbb{R}^{(N-1)\\times N}$，其中 $(D\\chi_e)_j = \\chi_{e,j+1} - \\chi_{e,j}$。\n- **参数**：$\\eta0$, $\\lambda_w\\ge 0$, $\\lambda_{\\mathrm{TV}}\\ge 0$, $\\epsilon_{\\mathrm{TV}}0$。\n- **初始条件**：$\\mathbf{w}^{(0)} = \\mathbf{0}$，$\\chi_e^{(0)} = \\mathbf{0}$。\n- **合成数据生成**：求解 $(\\mathbf{I} - \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{G})\\mathbf{w}^{\\mathrm{true}} = \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{E}^{\\mathrm{inc}}$ 得到 $\\mathbf{w}^{\\mathrm{true}}$，然后设置 $\\mathbf{d} = \\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{\\mathrm{true}})$。\n- **迭代步骤**：一次 $\\mathbf{w}$ 更新，一次 $\\chi_e$ 更新（使用单个 IRLS 步骤）。\n- **输出**：数据失配 $r_{\\mathrm{data}} = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right) - \\mathbf{d}\\right\\|_2$ 和状态一致性失配 $r_{\\mathrm{state}} = \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e^{(1)})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2$。\n- **测试用例**：提供了三组参数。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题是对比源反演的标准表述，这是一种在计算逆散射理论中成熟的方法。其基础物理受标量亥姆霍兹方程控制，其优化数学（交替最小化、吉洪诺夫正则化、总变分正则化）是可靠的。\n- **适定性**：该问题是适定的。目标泛函已定义，最小化过程已指定（带一次迭代的交替最小化），并且使用正则化项（$\\lambda_w$、$\\lambda_{\\mathrm{TV}}$）确保了子问题是可解且稳定的。\n- **客观性**：问题使用精确的数学和算法语言陈述，没有歧义或主观论断。\n\n**第 3 步：结论与行动**\n\n问题有效。这是一个在计算物理学中定义明确的任务，具有科学合理性和内部一致性。我将继续进行推导和求解。\n\n### 正规方程的推导\n\n任务的核心是推导在交替最小化的每个步骤中求解的线性方程组（正规方程）。我们从初始估计 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 和 $\\chi_e^{(0)} = \\mathbf{0}$ 开始。\n\n**1. 对比源 $\\mathbf{w}^{(1)}$ 的更新**\n\n我们固定 $\\chi_e = \\chi_e^{(0)} = \\mathbf{0}$，并通过最小化关于复向量 $\\mathbf{w}$ 的 $J(\\mathbf{w}, \\mathbf{0})$ 来找到 $\\mathbf{w}^{(1)}$。此步骤的目标泛函 $J_{\\mathbf{w}}(\\mathbf{w})$ 得到显著简化。总变分 (TV) 项与 $\\mathbf{w}$ 无关，状态一致性项变得更简单：\n$$\nJ_{\\mathbf{w}}(\\mathbf{w}) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\mathbf{0})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2\n$$\n$$\nJ_{\\mathbf{w}}(\\mathbf{w}) = \\left\\|\\mathbf{P}\\mathbf{G}\\mathbf{w} - (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 = \\left\\|\\mathbf{P}\\mathbf{G}\\mathbf{w} - (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\\right\\|_2^2 + (\\eta + \\lambda_w)\\left\\|\\mathbf{w}\\right\\|_2^2\n$$\n这是一个吉洪诺夫正则化的线性最小二乘问题。其最小化解 $\\mathbf{w}^{(1)}$ 是正规方程 $(\\mathbf{A}^H\\mathbf{A} + \\alpha^2\\mathbf{I})\\mathbf{x} = \\mathbf{A}^H\\mathbf{b}$ 的解，其中 $\\mathbf{A} = \\mathbf{P}\\mathbf{G}$，$\\mathbf{x} = \\mathbf{w}$，$\\mathbf{b} = \\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}}$，正则化参数为 $\\alpha^2 = \\eta + \\lambda_w$。求解 $\\mathbf{w}^{(1)}$ 的线性系统为：\n$$\n\\left((\\mathbf{P}\\mathbf{G})^H (\\mathbf{P}\\mathbf{G}) + (\\eta + \\lambda_w)\\mathbf{I}\\right) \\mathbf{w}^{(1)} = (\\mathbf{P}\\mathbf{G})^H (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\n$$\n使用 $(\\mathbf{AB})^H = \\mathbf{B}^H\\mathbf{A}^H$，其中 $H$ 表示共轭转置，我们得到最终形式：\n$$\n\\left(\\mathbf{G}^H \\mathbf{P}^H \\mathbf{P} \\mathbf{G} + (\\eta + \\lambda_w)\\mathbf{I}\\right) \\mathbf{w}^{(1)} = \\mathbf{G}^H \\mathbf{P}^H (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\n$$\n\n**2. 电纳对比度 $\\chi_e^{(1)}$ 的更新**\n\n接下来，我们固定 $\\mathbf{w} = \\mathbf{w}^{(1)}$，并针对实向量 $\\chi_e$ 最小化 $J(\\mathbf{w}^{(1)}, \\chi_e)$。此步骤的目标泛函 $J_{\\chi_e}(\\chi_e)$ 为：\n$$\nJ_{\\chi_e}(\\chi_e) = \\eta \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n令总场为 $\\mathbf{E}_{\\text{tot}}^{(1)} = \\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}$。令 $\\mathbf{E}_{\\text{diag}}^{(1)} = \\operatorname{diag}(\\mathbf{E}_{\\text{tot}}^{(1)})$。目标函数可以重写为：\n$$\nJ_{\\chi_e}(\\chi_e) = \\eta \\left\\| \\mathbf{E}_{\\text{diag}}^{(1)} \\chi_e - \\mathbf{w}^{(1)} \\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n问题指定使用单个迭代重加权最小二乘 (IRLS) 步骤。这将 TV 惩罚项通过一个二次形式来近似，从而实现线性化，其中的权重由上一个迭代值 $\\chi_e^{(0)} = \\mathbf{0}$ 计算。TV 项的梯度是非线性的。在 IRLS 框架中，我们将 TV 项近似为 $\\frac{1}{2} \\lambda_{\\mathrm{TV}} \\chi_e^T \\mathbf{R} \\chi_e$，其中 $\\mathbf{R} = D^T \\mathbf{W} D$ 且 $\\mathbf{W}$ 是一个对角权重矩阵。权重为 $(\\mathbf{W})_{jj} = 1/\\sqrt{((D\\chi_e)_j)^2 + \\epsilon_{\\mathrm{TV}}^2}$。\n对于从 $\\chi_e^{(0)} = \\mathbf{0}$ 开始的单个 IRLS 步骤，我们有 $D\\chi_e^{(0)} = \\mathbf{0}$，因此权重变为常数：$(\\mathbf{W})_{jj} = 1/\\epsilon_{\\mathrm{TV}}$。于是，$\\mathbf{W} = (1/\\epsilon_{\\mathrm{TV}})\\mathbf{I}$。\n得到的目标函数是关于 $\\chi_e$ 的二次函数。将其关于 $\\chi_e$ 的梯度设为零，即可得到正规方程。第一项关于实数 $\\chi_e$ 的梯度是 $2\\eta \\operatorname{Re}((\\mathbf{E}_{\\text{diag}}^{(1)})^H(\\mathbf{E}_{\\text{diag}}^{(1)} \\chi_e - \\mathbf{w}^{(1)}))$。二次 TV 近似项的梯度是 $\\lambda_{\\mathrm{TV}} (1/\\epsilon_{\\mathrm{TV}}) D^T D \\chi_e$。\n将总梯度设为零可得：\n$$\n2\\eta \\left( \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)} \\right) \\chi_e - \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{w}^{(1)} \\right) \\right) + 2 \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\chi_e = \\mathbf{0}\n$$\n重新整理以求解 $\\chi_e^{(1)}$：\n$$\n\\left( \\eta \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)} \\right) + \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\right) \\chi_e^{(1)} = \\eta \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{w}^{(1)} \\right)\n$$\n由于 $\\mathbf{E}_{\\text{diag}}^{(1)}$ 是对角矩阵，$(\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)}$ 是一个实对角矩阵，其元素为 $|\\mathbf{E}_{\\text{tot}, j}^{(1)}|^2$。最终的线性系统是：\n$$\n\\left( \\eta \\operatorname{diag}\\left(|\\mathbf{E}_{\\text{tot}, j}^{(1)}|^2\\right) + \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\right) \\chi_e^{(1)} = \\eta \\operatorname{Re}\\left( \\overline{\\mathbf{E}_{\\text{tot}}^{(1)}} \\odot \\mathbf{w}^{(1)} \\right)\n$$\n其中 $\\odot$ 表示逐元素乘法。求解此系统即可得到实向量 $\\chi_e^{(1)}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs one iteration of Contrast Source Inversion for a 1D scalar Helmholtz problem,\n    evaluating three test cases and printing the resulting data and state misfits.\n    \"\"\"\n    test_cases = [\n        # Test case 1: General case with all regularizers active.\n        {\n            \"N\": 32, \"L\": 1.0, \"k0\": 40.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 1e-2, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: 0.5 * (np.abs(x) = 0.15),\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": None\n        },\n        # Test case 2: Boundary case with no TV regularization.\n        {\n            \"N\": 16, \"L\": 1.0, \"k0\": 20.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 0.0, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: 0.4 * (1 + x / 1.0),\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": None\n        },\n        # Test case 3: Edge case with zero measurement data.\n        {\n            \"N\": 16, \"L\": 1.0, \"k0\": 20.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 1e-2, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: np.zeros_like(x), # Not used since d is overridden\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": lambda M: np.zeros(M, dtype=np.complex128)\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        L = case[\"L\"]\n        k0 = case[\"k0\"]\n        eta = case[\"eta\"]\n        lambda_w = case[\"lambda_w\"]\n        lambda_TV = case[\"lambda_TV\"]\n        epsilon_TV = case[\"epsilon_TV\"]\n\n        # 1. Setup grid and operators\n        dx = L / N\n        x = -L / 2 + (np.arange(N) + 0.5) * dx\n        \n        # Green's function matrix G (discretized integral operator)\n        x_i, x_j = np.meshgrid(x, x, indexing='ij')\n        G = (-1j / (2 * k0)) * np.exp(1j * k0 * np.abs(x_i - x_j)) * dx\n        \n        # Forward difference matrix D\n        D = np.zeros((N - 1, N))\n        D[np.arange(N - 1), np.arange(N - 1)] = -1.0\n        D[np.arange(N - 1), np.arange(N - 1) + 1] = 1.0\n\n        # Incident field\n        E_inc = case[\"E_inc_func\"](x, k0)\n        \n        # Measurement projector indices and data size\n        P_idx = case[\"P_func\"](N)\n        M = len(P_idx)\n\n        # 2. Generate synthetic measurement data d\n        if case[\"d_override\"] is not None:\n            d = case[\"d_override\"](M)\n        else:\n            chi_e_true = case[\"chi_true_func\"](x)\n            D_chi_true = np.diag(chi_e_true)\n            \n            # Solve Lippmann-Schwinger equation for the true contrast source\n            A_w_true = np.eye(N) - D_chi_true @ G\n            b_w_true = D_chi_true @ E_inc\n            w_true = np.linalg.solve(A_w_true, b_w_true)\n            \n            # Compute the scattered field at measurement points\n            E_tot_true = E_inc + G @ w_true\n            d = E_tot_true[P_idx]\n\n        # 3. Perform one CSI iteration\n        # Initial estimates are implicitly zero as per the derived normal equations.\n        # w_0 = np.zeros(N, dtype=np.complex128)\n        # chi_e_0 = np.zeros(N, dtype=np.float64)\n\n        # 3.1. w-update: solve for w^(1) using normal equations for chi_e^(0) = 0.\n        E_inc_meas = E_inc[P_idx]\n        G_meas = G[P_idx, :]\n        G_H_meas = G_meas.conj().T\n\n        A_w1_sys = G_H_meas @ G_meas + (eta + lambda_w) * np.eye(N)\n        b_w1 = G_H_meas @ (d - E_inc_meas)\n        \n        w_1 = np.linalg.solve(A_w1_sys, b_w1)\n\n        # 3.2. chi_e-update: solve for chi_e^(1) using one IRLS step.\n        E_tot_1 = E_inc + G @ w_1\n        \n        # Construct the system matrix for chi_e\n        A_chi1_term1_diag = eta * np.abs(E_tot_1)**2\n        A_chi1_term2 = (lambda_TV / epsilon_TV) * (D.T @ D)\n        A_chi1_sys = np.diag(A_chi1_term1_diag) + A_chi1_term2\n        \n        # Construct the right-hand side vector for chi_e\n        b_chi1_rhs = eta * np.real(np.conj(E_tot_1) * w_1)\n        \n        chi_e_1 = np.linalg.solve(A_chi1_sys, b_chi1_rhs)\n\n        # 4. Compute output quantities: data and state misfit norms\n        r_data_vec = (E_inc + G @ w_1)[P_idx] - d\n        r_data = np.linalg.norm(r_data_vec)\n        \n        r_state_vec = w_1 - np.diag(chi_e_1) @ (E_inc + G @ w_1)\n        r_state = np.linalg.norm(r_state_vec)\n        \n        results.extend([r_data, r_state])\n\n    # 5. Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}