{
    "hands_on_practices": [
        {
            "introduction": "本实践聚焦于频域电磁学中伴随方法的数学基础。我们将从麦克斯韦方程组和复内积的定义出发，通过第一性原理推导伴随灵敏度表达式。这项练习对于深刻理解伴随方程为何具有其特定形式，以及在针对实值目标函数的灵敏度分析中实部算子如何自然出现至关重要。",
            "id": "3312413",
            "problem": "考虑在源驱动的非磁性介质中，关于电场 $\\mathbf{E}(\\mathbf{r};\\alpha)$ 的频域麦克斯韦旋度-旋度方程，\n$$\n\\nabla \\times \\mu_0^{-1} \\nabla \\times \\mathbf{E} - \\omega^2 \\epsilon(\\mathbf{r};\\alpha)\\,\\mathbf{E} = i \\omega \\mathbf{J},\n$$\n其中 $\\mu_0$ 是自由空间磁导率，$\\omega$ 是角频率，$\\epsilon(\\mathbf{r};\\alpha) = \\epsilon_0(\\mathbf{r}) + \\alpha\\,p(\\mathbf{r})$ 是一个由实标量设计变量 $\\alpha$ 参数化的标量介电常数分布，而 $\\mathbf{J}$ 是给定的外加电流密度。设场上的复内积定义为 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\int \\mathbf{u}^*(\\mathbf{r}) \\cdot \\mathbf{v}(\\mathbf{r})\\, d\\mathbf{r}$，它在其第一个参数上是共轭线性的。假设在计算边界上采用理想电导体边界条件，从而使得边界项在分部积分后消失。\n\n标准的边元伽辽金有限元法（FEM）离散化产生了一个关于复数自由度 $\\mathbf{x}(\\alpha) \\in \\mathbb{C}^n$ 的线性系统，\n$$\n\\mathbf{A}(\\alpha)\\,\\mathbf{x}(\\alpha) = \\mathbf{b},\n$$\n其中 $\\mathbf{A}(\\alpha) = \\mathbf{K} - \\omega^2 \\operatorname{diag}(\\boldsymbol{\\epsilon}_0 + \\alpha \\mathbf{p})\\,\\mathbf{M}$，$\\mathbf{K} \\in \\mathbb{C}^{n \\times n}$ 为刚度矩阵，$\\mathbf{M} \\in \\mathbb{C}^{n \\times n}$ 为质量矩阵，向量 $\\boldsymbol{\\epsilon}_0, \\mathbf{p} \\in \\mathbb{R}^n$。设 $\\mathbb{C}^n$ 上的复内积为 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\mathbf{u}^* \\mathbf{v}$。考虑实值目标泛函\n$$\nJ(\\alpha) = \\frac{1}{2}\\,\\| \\mathbf{C}\\,\\mathbf{x}(\\alpha) - \\mathbf{d} \\|_2^2,\n$$\n其中给定了 $\\mathbf{C} \\in \\mathbb{C}^{m \\times n}$ 和 $\\mathbf{d} \\in \\mathbb{C}^m$，且范数由复内积导出。\n\n1) 从频域麦克斯韦方程和上述复内积的定义出发，并仅使用复向量空间中变分法的基本原理（例如，使用内積在其第一个位置上是共轭线性约定的拉格朗日方法，或等效的 Wirtinger 微积分），推导出一阶灵敏度表达式 $\\frac{dJ}{d\\alpha}$，用状态向量 $\\mathbf{x}(\\alpha)$、一个为强制场约束而适当定义的伴随向量 $\\mathbf{y}(\\alpha)$ 以及导数 $\\frac{\\partial \\mathbf{A}}{\\partial \\alpha}$ 来表示。您的推导必须明确显示实部算子是如何从复内积中产生的，以及为什么伴随线性系统具有其特定的形式。\n\n2) 对于 $n=2$ 的具体实例，使用以下参数评估您推导出的表达式：\n$$\n\\omega = 1,\\quad\n\\mathbf{K} = \\begin{pmatrix} 3   1 + i \\\\ 1 - i   4 \\end{pmatrix},\\quad\n\\mathbf{M} = \\begin{pmatrix} 2   0 \\\\ 0   1 \\end{pmatrix},\n$$\n$$\n\\boldsymbol{\\epsilon}_0 = \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix},\\quad\n\\mathbf{p} = \\begin{pmatrix} \\tfrac{1}{2} \\\\ -\\tfrac{1}{4} \\end{pmatrix},\\quad\n\\mathbf{b} = \\begin{pmatrix} 1 \\\\ i \\end{pmatrix},\\quad\n\\mathbf{C} = \\begin{pmatrix} 1   0 \\end{pmatrix},\\quad\n\\mathbf{d} = 0,\n$$\n使得 $\\mathbf{A}(\\alpha) = \\mathbf{K} - \\operatorname{diag}(\\boldsymbol{\\epsilon}_0 + \\alpha \\mathbf{p})\\,\\mathbf{M}$。通过以下步骤计算在 $\\alpha = 0.2$ 时 $\\frac{dJ}{d\\alpha}$ 的数值：\n- 求解正演系统以获得 $\\mathbf{x}(\\alpha)$，\n- 求解您推导出的伴随系统以获得 $\\mathbf{y}(\\alpha)$，\n- 根据 $\\mathbf{x}(\\alpha)$、$\\mathbf{y}(\\alpha)$ 和 $\\frac{\\partial \\mathbf{A}}{\\partial \\alpha}$ 评估灵敏度。\n\n将您在 $\\alpha = 0.2$ 时得到的 $\\frac{dJ}{d\\alpha}$ 的最终数值答案四舍五入到四位有效数字。将最终答案表示为无单位的纯数。",
            "solution": "该问题经评估有效，因为它具有科学依据、良态、客观且内部一致。它提出了一个计算电磁学灵敏度分析中的标准问题。我们开始进行求解。\n\n问题分为两部分：首先，使用伴随方法推导灵敏度 $\\frac{dJ}{d\\alpha}$ 的通用表达式；其次，将此表达式应用于一个具体的数值示例。\n\n**第一部分：伴随灵敏度表达式的推导**\n\n给定目标泛函 $J(\\alpha)$，它是设计参数 $\\alpha$ 的一个实值函数：\n$$\nJ(\\alpha) = \\frac{1}{2}\\,\\| \\mathbf{C}\\,\\mathbf{x}(\\alpha) - \\mathbf{d} \\|_2^2\n$$\n这里，$\\mathbf{x}(\\alpha) \\in \\mathbb{C}^n$ 是状态向量，它通过线性系统（状态方程）隐式地依赖于 $\\alpha$：\n$$\n\\mathbf{A}(\\alpha)\\,\\mathbf{x}(\\alpha) = \\mathbf{b}\n$$\n范数由复内积 $\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\mathbf{u}^* \\mathbf{v} = \\mathbf{u}^H \\mathbf{v}$ 导出，其中 $\\mathbf{u}^H$ 是 $\\mathbf{u}$ 的共轭转置。我们可以使用这个内积来写出目标函数：\n$$\nJ(\\alpha) = \\frac{1}{2} \\langle \\mathbf{C}\\mathbf{x}(\\alpha) - \\mathbf{d}, \\mathbf{C}\\mathbf{x}(\\alpha) - \\mathbf{d} \\rangle\n$$\n为了求出灵敏度 $\\frac{dJ}{d\\alpha}$，我们使用链式法则对 $J$ 关于 $\\alpha$ 求导。令 $\\mathbf{x}'(\\alpha)$ 表示 $\\frac{d\\mathbf{x}}{d\\alpha}$。\n$$\n\\frac{dJ}{d\\alpha} = \\frac{d}{d\\alpha} \\left[ \\frac{1}{2} (\\mathbf{C}\\mathbf{x} - \\mathbf{d})^H (\\mathbf{C}\\mathbf{x} - \\mathbf{d}) \\right]\n$$\n使用微分的乘法法则，我们得到：\n$$\n\\frac{dJ}{d\\alpha} = \\frac{1}{2} \\left[ (\\mathbf{C}\\mathbf{x}')^H (\\mathbf{C}\\mathbf{x} - \\mathbf{d}) + (\\mathbf{C}\\mathbf{x} - \\mathbf{d})^H (\\mathbf{C}\\mathbf{x}') \\right]\n$$\n方括号中的两项互为复共轭。一个复数 $z$ 与其共轭 $z^*$ 的和是 $2 \\operatorname{Re}(z)$。这就是实部算子的来源。令 $z = (\\mathbf{C}\\mathbf{x} - \\mathbf{d})^H (\\mathbf{C}\\mathbf{x}')$，我们有：\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ (\\mathbf{C}\\mathbf{x} - \\mathbf{d})^H (\\mathbf{C}\\mathbf{x}') \\right]\n$$\n使用复内积的定义，这可以写成：\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ \\langle \\mathbf{C}\\mathbf{x} - \\mathbf{d}, \\mathbf{C}\\mathbf{x}' \\rangle \\right]\n$$\n我们使用伴随算子（在此情况下为共轭转置 $\\mathbf{C}^H$）相对于内积的性质：$\\langle \\mathbf{u}, \\mathbf{T}\\mathbf{v} \\rangle = \\langle \\mathbf{T}^H\\mathbf{u}, \\mathbf{v} \\rangle$。\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ \\langle \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d}), \\mathbf{x}' \\rangle \\right]\n$$\n这个梯度的表达式依赖于 $\\mathbf{x}' = \\frac{d\\mathbf{x}}{d\\alpha}$，直接计算它的成本很高。伴随方法可以规避这个问题。我们通过对状态方程 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 关于 $\\alpha$ 求导来找到 $\\mathbf{x}'$ 的表达式：\n$$\n\\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} + \\mathbf{A} \\frac{d\\mathbf{x}}{d\\alpha} = 0 \\implies \\mathbf{x}' = -\\mathbf{A}^{-1} \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x}\n$$\n将此代入 $\\frac{dJ}{d\\alpha}$ 的表达式中：\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ \\langle \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d}), -\\mathbf{A}^{-1} \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} \\rangle \\right]\n$$\n我们再次使用内积的伴随性质，这次是针对算子 $T = -\\mathbf{A}^{-1}$：\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ \\langle -(\\mathbf{A}^{-1})^H \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d}), \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} \\rangle \\right]\n$$\n我们引入一个伴随向量 $\\mathbf{y}(\\alpha) \\in \\mathbb{C}^n$，定义为伴随线性系统的解，该系统被选择用来消除 $\\mathbf{A}$ 的逆：\n$$\n\\mathbf{A}^H \\mathbf{y} = \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d})\n$$\n这就是伴随方程。右侧是目标函数 $J$ 关于 $\\mathbf{x}^*$ 的导数（或与其成比例，具体取决于复梯度的约定）。求解这个系统得到 $\\mathbf{y} = (\\mathbf{A}^H)^{-1} \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d})$。然后我们可以将 $\\mathbf{y}$ 代入灵敏度表达式：\n$$\n\\frac{dJ}{d\\alpha} = \\operatorname{Re}\\left[ \\langle -\\mathbf{y}, \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} \\rangle \\right]\n$$\n由于内积在第一个参数上是共轭线性的，$\\langle - \\mathbf{y}, \\mathbf{v} \\rangle = -\\langle \\mathbf{y}, \\mathbf{v} \\rangle$。因此：\n$$\n\\frac{dJ}{d\\alpha} = -\\operatorname{Re}\\left[ \\langle \\mathbf{y}, \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} \\rangle \\right] = -\\operatorname{Re}\\left[ \\mathbf{y}^H \\left(\\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x}\\right) \\right]\n$$\n这就是最终的一阶灵敏度表达式。它需要求解一个用于 $\\mathbf{x}$ 的正演线性系统和一个用于 $\\mathbf{y}$ 的伴随线性系统。\n\n**第二部分：数值计算**\n\n我们现在将此公式应用于给定的 $\\alpha=0.2$ 的数值实例。\n\n1. **在 $\\alpha=0.2$ 处组装矩阵 $\\mathbf{A}(\\alpha)$：**\n参数化的介电常数向量为 $\\boldsymbol{\\epsilon}(\\alpha) = \\boldsymbol{\\epsilon}_0 + \\alpha \\mathbf{p}$：\n$$\n\\boldsymbol{\\epsilon}(0.2) = \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix} + 0.2 \\begin{pmatrix} 0.5 \\\\ -0.25 \\end{pmatrix} = \\begin{pmatrix} 2.1 \\\\ 2.95 \\end{pmatrix}\n$$\n当 $\\omega = 1$ 时，矩阵 $\\mathbf{A}(\\alpha)$ 为 $\\mathbf{A}(\\alpha) = \\mathbf{K} - \\operatorname{diag}(\\boldsymbol{\\epsilon}(\\alpha))\\,\\mathbf{M}$：\n$$\n\\mathbf{A}(0.2) = \\begin{pmatrix} 3   1 + i \\\\ 1 - i   4 \\end{pmatrix} - \\begin{pmatrix} 2.1   0 \\\\ 0   2.95 \\end{pmatrix} \\begin{pmatrix} 2   0 \\\\ 0   1 \\end{pmatrix} = \\begin{pmatrix} 3   1 + i \\\\ 1 - i   4 \\end{pmatrix} - \\begin{pmatrix} 4.2   0 \\\\ 0   2.95 \\end{pmatrix}\n$$\n$$\n\\mathbf{A}(0.2) = \\begin{pmatrix} -1.2   1 + i \\\\ 1 - i   1.05 \\end{pmatrix}\n$$\n\n2. **求解正演系统以获得 $\\mathbf{x}(0.2)$：**\n我们求解 $\\mathbf{A}(0.2)\\mathbf{x} = \\mathbf{b}$：\n$$\n\\begin{pmatrix} -1.2   1 + i \\\\ 1 - i   1.05 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ i \\end{pmatrix}\n$$\n行列式为 $\\det(\\mathbf{A}) = (-1.2)(1.05) - (1+i)(1-i) = -1.26 - 2 = -3.26$。\n逆矩阵为 $\\mathbf{A}^{-1} = \\frac{1}{-3.26}\\begin{pmatrix} 1.05   -1-i \\\\ -1+i   -1.2 \\end{pmatrix}$。\n解为 $\\mathbf{x} = \\mathbf{A}^{-1}\\mathbf{b}$：\n$$\n\\mathbf{x} = \\frac{1}{-3.26} \\begin{pmatrix} 1.05 - i(1+i) \\\\ -1+i - 1.2i \\end{pmatrix} = \\frac{1}{-3.26} \\begin{pmatrix} 1.05 - i + 1 \\\\ -1 - 0.2i \\end{pmatrix} = \\frac{1}{-3.26} \\begin{pmatrix} 2.05 - i \\\\ -1 - 0.2i \\end{pmatrix}\n$$\n\n3. **求解伴随系统以获得 $\\mathbf{y}(0.2)$：**\n矩阵 $\\mathbf{K}$ 是厄米特矩阵，而 $\\operatorname{diag}(\\boldsymbol{\\epsilon}) \\mathbf{M}$ 是实对称的（因此也是厄米特矩阵）。因此，$\\mathbf{A}(\\alpha)$ 是厄米特矩阵，所以 $\\mathbf{A}^H = \\mathbf{A}$。伴随系统是 $\\mathbf{A} \\mathbf{y} = \\mathbf{C}^H(\\mathbf{C}\\mathbf{x} - \\mathbf{d})$。\n给定 $\\mathbf{C} = \\begin{pmatrix} 1   0 \\end{pmatrix}$ 和 $\\mathbf{d} = 0$，右侧为：\n$$\n\\mathbf{C}^H(\\mathbf{C}\\mathbf{x}) = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\left( \\begin{pmatrix} 1   0 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} \\right) = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} x_1 = \\begin{pmatrix} x_1 \\\\ 0 \\end{pmatrix}\n$$\n所以我们求解 $\\mathbf{A}\\mathbf{y} = \\begin{pmatrix} x_1 \\\\ 0 \\end{pmatrix}$。解为 $\\mathbf{y} = \\mathbf{A}^{-1} \\begin{pmatrix} x_1 \\\\ 0 \\end{pmatrix}$：\n$$\n\\mathbf{y} = \\frac{1}{-3.26} \\begin{pmatrix} 1.05   -1-i \\\\ -1+i   -1.2 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ 0 \\end{pmatrix} = \\frac{x_1}{-3.26} \\begin{pmatrix} 1.05 \\\\ -1+i \\end{pmatrix}\n$$\n代入 $x_1 = \\frac{2.05-i}{-3.26}$：\n$$\n\\mathbf{y} = \\frac{2.05-i}{(-3.26)^2} \\begin{pmatrix} 1.05 \\\\ -1+i \\end{pmatrix} = \\frac{2.05-i}{10.6276} \\begin{pmatrix} 1.05 \\\\ -1+i \\end{pmatrix}\n$$\n\n4. **计算灵敏度 $\\frac{dJ}{d\\alpha}$：**\n首先，我们求矩阵 $\\mathbf{A}$ 关于 $\\alpha$ 的导数：\n$$\n\\frac{\\partial \\mathbf{A}}{\\partial \\alpha} = \\frac{\\partial}{\\partial \\alpha} \\left( \\mathbf{K} - \\omega^2 \\operatorname{diag}(\\boldsymbol{\\epsilon}_0 + \\alpha \\mathbf{p})\\,\\mathbf{M} \\right) = -\\omega^2 \\operatorname{diag}(\\mathbf{p})\\,\\mathbf{M}\n$$\n代入 $\\omega=1$ 的值：\n$$\n\\frac{\\partial \\mathbf{A}}{\\partial \\alpha} = -1^2 \\begin{pmatrix} 0.5   0 \\\\ 0   -0.25 \\end{pmatrix} \\begin{pmatrix} 2   0 \\\\ 0   1 \\end{pmatrix} = -\\begin{pmatrix} 1   0 \\\\ 0   -0.25 \\end{pmatrix} = \\begin{pmatrix} -1   0 \\\\ 0   0.25 \\end{pmatrix}\n$$\n灵敏度为 $\\frac{dJ}{d\\alpha} = -\\operatorname{Re}\\left[ \\mathbf{y}^H \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} \\right]$。让我们计算方括号中的项：\n$$\n\\mathbf{y}^H = \\frac{2.05+i}{10.6276} \\begin{pmatrix} 1.05   -1-i \\end{pmatrix}\n$$\n$$\n\\frac{\\partial \\mathbf{A}}{\\partial \\alpha}\\mathbf{x} = \\begin{pmatrix} -1   0 \\\\ 0   0.25 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ x_2 \\end{pmatrix} = \\begin{pmatrix} -x_1 \\\\ 0.25 x_2 \\end{pmatrix}\n$$\n$$\n\\mathbf{y}^H \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} = \\frac{2.05+i}{10.6276} \\left( 1.05(-x_1) + (-1-i)(0.25 x_2) \\right) = \\frac{- (2.05+i)}{10.6276} \\left( 1.05 x_1 + 0.25(1+i)x_2 \\right)\n$$\n令 $c=-3.26$。我们有 $x_1 = \\frac{2.05-i}{c}$ 和 $x_2 = \\frac{-1-0.2i}{c}$。\n括号中的项为：\n$$\n1.05 \\frac{2.05-i}{c} + 0.25(1+i) \\frac{-1-0.2i}{c} = \\frac{1}{c} \\left[ (2.1525 - 1.05i) + (0.25)(-1-0.2i-i+0.2) \\right]\n$$\n$$\n= \\frac{1}{c} \\left[ 2.1525 - 1.05i - 0.2 - 0.3i \\right] = \\frac{1.9525 - 1.35i}{c}\n$$\n所以，我们有：\n$$\n\\mathbf{y}^H \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} = \\frac{- (2.05+i)}{10.6276} \\frac{1.9525 - 1.35i}{-3.26} = \\frac{- (2.05+i)(1.9525 - 1.35i)}{-34.645976}\n$$\n分子乘积： $(2.05+i)(1.9525 - 1.35i) = 4.002625 - 2.7675i + 1.9525i + 1.35 = 5.352625 - 0.815i$。\n$$\n\\mathbf{y}^H \\frac{\\partial \\mathbf{A}}{\\partial \\alpha} \\mathbf{x} = \\frac{-(5.352625 - 0.815i)}{-34.645976} = \\frac{5.352625 - 0.815i}{34.645976} \\approx 0.154497 - 0.023523i\n$$\n最后，灵敏度为：\n$$\n\\frac{dJ}{d\\alpha} = -\\operatorname{Re}\\left[ 0.154497 - 0.023523i \\right] = -0.154497\n$$\n四舍五入到四位有效数字，我们得到 $-0.1545$。",
            "answer": "$$ \\boxed{-0.1545} $$"
        },
        {
            "introduction": "在推导出解析梯度之后，任何实际应用中的关键下一步是验证其正确性。本动手编程实践将指导您完成使用有限差分进行梯度验证的全过程，这是调试并确保任何基于梯度的优化算法可靠性的基本技能。您将实现解析伴随梯度及与之对应的数值近似，从而定量地评估它们在不同场景下的一致性。",
            "id": "3312449",
            "problem": "构建一个完整、可运行的程序，通过与有限差分检验进行比较，来验证一个频域标量电磁学模型的伴随法梯度。该程序必须实现一个二维离散标量亥姆霍兹问题，该问题具有零狄利克雷边界条件，一个测量选定探针位置处失配的目标函数（可选对材料参数进行二次正则化），以及解析伴随梯度和有限差分梯度近似。最终输出必须是单行，包含一个浮点数列表，用以量化给定测试套件的梯度验证误差。\n\n其起点是在单极化、均匀磁导率假设下从麦克斯韦方程组推导出的频域标量亥姆霍兹方程。在一个矩形网格上，使用无量纲单位，离散正问题为\n$$\nA(\\varepsilon) \\, u = b,\n$$\n其中 $u \\in \\mathbb{C}^{N}$ 是内部节点上场值的向量，$\\varepsilon \\in \\mathbb{R}^{N}$ 是相对介电常数值的向量（每个内部节点一个值），$b \\in \\mathbb{C}^{N}$ 是一个固定源。算子为\n$$\nA(\\varepsilon) = L - c \\,\\mathrm{diag}(\\varepsilon),\n$$\n其中 $L \\in \\mathbb{R}^{N \\times N}$ 是具有零狄利克雷边界和单位网格间距的标准的5点有限差分拉普拉斯算子，而 $c = \\omega^{2} + \\mathrm{i}\\,\\eta$ 中的角频率为 $\\omega$ 且损耗参数 $\\eta \\ge 0$。内部未知数是除边界外的节点；对于一个包含边界层在内总共有 $N_{x}$ 和 $N_{y}$ 个节点的网格，未知数的数量为 $N = (N_{x}-2)(N_{y}-2)$。\n\n要最小化的目标函数是\n$$\nJ(\\varepsilon) = \\tfrac{1}{2}\\,\\lVert S u(\\varepsilon) - u_{\\mathrm{t}}\\rVert_{2}^{2} + \\tfrac{\\alpha}{2}\\,\\lVert \\varepsilon - \\varepsilon_{\\mathrm{ref}} \\rVert_{2}^{2},\n$$\n其中 $S$ 是一个线性选择算子，用于提取指定测量节点（探针）处 $u$ 的分量，$u_{\\mathrm{t}}$ 是这些探针处的目标场，$\\alpha \\ge 0$ 是一个实数正则化权重，$\\varepsilon_{\\mathrm{ref}}$ 是一个参考介电常数向量。所有量都是无量纲的；不需要物理单位。\n\n您的程序必须：\n- 为每个测试用例，使用5点模板、单位网格间距和零狄利克雷边界条件，组装内部网格的拉普拉斯算子 $L$。\n- 求解正问题 $A(\\varepsilon) u = b$ 以获得 $u$。\n- 计算目标函数 $J(\\varepsilon)$。\n- 基于离散方程和适用于频域电磁学的复值内积，使用严格的首次变分和伴随方法，推导并实现解析伴随梯度 $\\nabla_{\\varepsilon} J$。\n- 独立计算 $\\nabla_{\\varepsilon} J$ 的中心有限差分近似，步长 $h$ 如下文规定。\n- 通过将 $\\nabla_{\\varepsilon} J \\cdot p$ 与 $\\tfrac{\\mathrm{d}}{\\mathrm{d}t} J(\\varepsilon + t p)$ 在指定随机方向 $p$ 上使用小标量步长 $t$ 的中心差分近似进行比较，来执行方向导数检验。\n- 为每个测试用例报告一个浮点数，该数等于两个相对误差中的最大值：解析梯度向量和有限差分梯度向量之间的相对 $\\ell_{2}$ 误差，以及解析方向导数和有限差分方向导数之间的相对误差。\n\n定义和实现细节：\n- 网格和索引：设总网格有 $N_{x}$ 和 $N_{y}$ 个节点（包括边界层）。内部索引集为 $\\{(i,j)\\,|\\, i=0,\\dots,N_{x}-3;\\, j=0,\\dots,N_{y}-3\\}$，采用行主序扁平化 $k = i + (N_{x}-2)\\,j$，得到 $N=(N_{x}-2)(N_{y}-2)$。\n- 拉普拉斯算子 $L$：对于每个扁平化索引为 $k$ 的内部节点 $(i,j)$，设置\n  $$\n  L_{k,k} = -4,\\quad\n  L_{k,k\\pm 1} = 1 \\text{ for valid horizontal neighbors},\\quad\n  L_{k,k\\pm (N_{x}-2)} = 1 \\text{ for valid vertical neighbors}.\n  $$\n- 选择算子 $S$：通过索引 $u$ 中适当的条目来隐式实现 $S$；其厄米转置 $S^{H}$ 对应于将测量残差在选定索引处散布回完整的内部大小的向量中。\n- 目标函数 $J$：使用标准的复数最小二乘形式，其中残差采用厄米内积，即 $\\tfrac{1}{2}\\,\\lVert r \\rVert_{2}^{2}$，其中 $r = S u - u_{\\mathrm{t}}$，这等于 $\\tfrac{1}{2}\\, r^{H} r$。\n- 有限差分梯度：使用中心差分，\n  $$\n  \\left[\\nabla_{\\varepsilon} J\\right]_{i} \\approx \\frac{J(\\varepsilon + h e_{i}) - J(\\varepsilon - h e_{i})}{2h},\n  $$\n  步长 $h = 10^{-6}$，其中 $e_{i}$ 是第 $i$ 个标准基向量。\n- 方向导数检验：对于给定的方向 $p \\in \\mathbb{R}^{N}$ 和步长 $t = 10^{-6}$，将 $\\nabla_{\\varepsilon} J(\\varepsilon)^{\\top} p$ 与下式进行比较\n  $$\n  \\frac{J(\\varepsilon + t p) - J(\\varepsilon - t p)}{2 t}.\n  $$\n\n测试套件：\n- 情况 A（一般情况）：\n  - 网格：$N_{x} = 10$, $N_{y} = 12$。\n  - 频率和损耗：$\\omega = 5.0$, $\\eta = 0.2$，因此 $c = \\omega^{2} + \\mathrm{i}\\,\\eta$。\n  - 正则化：$\\alpha = 0.01$，$\\varepsilon_{\\mathrm{ref}}$ 是所有条目均为 $1.5$ 的常数向量。\n  - 源：在内部索引 $(i_{s}, j_{s})$ 处有一个单位幅度的单点源，其中 $i_{s} = \\lfloor (N_{x}-2)/3 \\rfloor$, $j_{s} = \\lfloor (N_{y}-2)/2 \\rfloor$。\n  - 初始介电常数：对于内部坐标 $(i,j)$，设置\n    $$\n    \\varepsilon_{0}(i,j) = 2.0 + 0.1 \\sin\\!\\left( \\frac{2\\pi i}{N_{x}-2} \\right) \\sin\\!\\left( \\frac{3\\pi j}{N_{y}-2} \\right).\n    $$\n  - 测量：所有满足 $i \\bmod 3 = 1$ 和 $j \\bmod 4 = 2$ 的内部节点。\n  - 目标场：$u_{\\mathrm{t}}$ 是适当长度的零向量。\n- 情况 B（边界正则化情况）：\n  - 网格：$N_{x} = 8$, $N_{y} = 8$。\n  - 频率和损耗：$\\omega = 3.0$, $\\eta = 0.05$，因此 $c = \\omega^{2} + \\mathrm{i}\\,\\eta$。\n  - 正则化：$\\alpha = 0$，$\\varepsilon_{\\mathrm{ref}}$ 是所有条目均为 $1.0$ 的常数向量。\n  - 源：在内部中心 $(i_{c}, j_{c})$ 处有一个单位幅度的单点源，其中 $i_{c} = \\lfloor (N_{x}-2)/2 \\rfloor$, $j_{c} = \\lfloor (N_{y}-2)/2 \\rfloor$。\n  - 初始介电常数：高斯凸起，\n    $$\n    \\varepsilon_{0}(i,j) = 1.0 + 0.2 \\exp\\!\\left( -\\frac{(i-i_{c})^{2} + (j-j_{c})^{2}}{2 \\sigma^{2}} \\right), \\quad \\sigma = 2.0.\n    $$\n  - 测量：在 $(i_{c}, j_{c})$ 处的单个内部探针。\n  - 目标场：$u_{\\mathrm{t}}$ 是一个标量，在单个探针处的值为 $0.1$。\n- 情况 C（更接近共振但由损耗稳定）：\n  - 网格：$N_{x} = 12$, $N_{y} = 12$。\n  - 频率和损耗：$\\omega = 10.0$, $\\eta = 0.8$，因此 $c = \\omega^{2} + \\mathrm{i}\\,\\eta$。\n  - 正则化：$\\alpha = 0.001$，$\\varepsilon_{\\mathrm{ref}}$ 是所有条目均为 $1.0$ 的常数向量。\n  - 源：在内部索引 $(i_{c}, j_{c})$ 和 $(i_{c}-2, j_{c}+1)$ 处有两个单位幅度的点源，其中 $i_{c} = \\lfloor (N_{x}-2)/2 \\rfloor$, $j_{c} = \\lfloor (N_{y}-2)/2 \\rfloor$。\n  - 初始介电常数：均匀，\n    $$\n    \\varepsilon_{0}(i,j) = 1.5.\n    $$\n  - 测量：穿过内部中心的十字形，即所有 $i = i_{c}$ 且 $j$ 为偶数的内部节点，以及所有 $j = j_{c}$ 且 $i$ 为偶数的内部节点；重复项只包含一次。\n  - 目标场：$u_{\\mathrm{t}}$ 是适当长度的零向量。\n\n验证指标和输出：\n- 对于每个情况，计算：\n  - 解析梯度与中心有限差分梯度之间的相对 $\\ell_{2}$ 误差，\n    $$\n    E_{\\mathrm{grad}} = \\frac{\\lVert \\nabla_{\\varepsilon} J - \\nabla_{\\varepsilon}^{\\mathrm{FD}} J \\rVert_{2}}{\\max\\{\\lVert \\nabla_{\\varepsilon}^{\\mathrm{FD}} J \\rVert_{2},\\, 10^{-12}\\}}.\n    $$\n  - 沿确定性随机方向 $p$ 的方向导数的相对误差，\n    $$\n    E_{\\mathrm{dir}} = \\frac{\\left| \\nabla_{\\varepsilon} J^{\\top} p - \\frac{J(\\varepsilon + t p) - J(\\varepsilon - t p)}{2 t} \\right|}{\\max\\left\\{\\left|\\frac{J(\\varepsilon + t p) - J(\\varepsilon - t p)}{2 t}\\right|,\\, 10^{-12}\\right\\}},\n    $$\n    使用 $t = 10^{-6}$ 和每个情况唯一的随机数生成器固定种子。\n- 对于每个情况，报告一个浮点数\n  $$\n  E = \\max\\{E_{\\mathrm{grad}},\\, E_{\\mathrm{dir}}\\}.\n  $$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[e_A,e_B,e_C]\"），其中 $e_{\\mathrm{A}}$、$e_{\\mathrm{B}}$ 和 $e_{\\mathrm{C}}$ 分别是情况 A、情况 B 和情况 C 的 $E$ 值。\n\n不允许用户输入或外部文件。所有计算都必须使用指定的测试套件和参数进行。不涉及角度；没有角度单位要求。所有量都是无量纲的；没有物理单位要求。",
            "solution": "用户要求提供一个 Python 程序，用于将一个二维标量亥姆霍兹问题的伴随法梯度与有限差分近似进行验证。该问题定义明确，科学上合理，并为完整实现提供了所有必要的参数和方程。其物理基础是标准的标量亥姆霍兹方程，而验证方法（通过有限差分和方向导数进行梯度检验）是基于梯度的优化的基石。该问题是有效的。\n\n对于每个测试用例，解决方案按以下几个步骤进行：\n1.  **离散化设置**：将连续的二维域离散化到一个网格上。场为未知的内部节点被扁平化为一个大小为 $N = (N_x-2)(N_y-2)$ 的一维向量。为零狄利克雷边界条件构建的5点有限差分拉普拉斯算子 $L$ 被构造为一个稀疏矩阵。\n\n2.  **正问题**：离散亥姆霍兹方程是一个线性系统 $A(\\varepsilon)u = b$，其中 $A(\\varepsilon) = L - c \\cdot \\mathrm{diag}(\\varepsilon)$ 且 $c = \\omega^2 + i\\eta$。该系统通过稀疏线性求解器求解，以获得复值场向量 $u$。\n\n3.  **目标函数**：目标函数 $J(\\varepsilon)$ 定义为一个场失配项和一个正则化项的和：\n    $$\n    J(\\varepsilon) = \\tfrac{1}{2}\\,\\lVert S u(\\varepsilon) - u_{\\mathrm{t}}\\rVert_{2}^{2} + \\tfrac{\\alpha}{2}\\,\\lVert \\varepsilon - \\varepsilon_{\\mathrm{ref}} \\rVert_{2}^{2}\n    $$\n    这里，$S$ 是一个选择算子，用于提取探针位置处的场值。第一项涉及复向量，计算为 $\\tfrac{1}{2} r^H r$，其中 $r = S u(\\varepsilon) - u_{\\mathrm{t}}$ 是残差。\n\n4.  **伴随梯度推导**：为了高效地计算梯度 $\\nabla_{\\varepsilon} J$，使用伴随法。我们从 $J$ 的首次变分开始：\n    $$\n    \\delta J = \\mathrm{Re}\\left[ (Su - u_{\\mathrm{t}})^H S (\\delta u) \\right] + \\alpha (\\varepsilon - \\varepsilon_{\\mathrm{ref}})^{\\top} \\delta\\varepsilon\n    $$\n    场的变分 $\\delta u$ 通过正问题方程与介电常数的变分 $\\delta\\varepsilon$ 相关联：\n    $$\n    \\delta(A u) = 0 \\implies (\\delta A) u + A (\\delta u) = 0 \\implies \\delta u = -A^{-1} (\\delta A) u\n    $$\n    由于 $A = L - c \\cdot \\mathrm{diag}(\\varepsilon)$，其变分为 $\\delta A = -c \\cdot \\mathrm{diag}(\\delta\\varepsilon)$。这得到：\n    $$\n    \\delta u = c A^{-1} \\mathrm{diag}(u) \\delta\\varepsilon\n    $$\n    将此代入 $\\delta J$ 的表达式中：\n    $$\n    \\delta J = \\mathrm{Re}\\left[ c \\, (Su - u_{\\mathrm{t}})^H S A^{-1} \\mathrm{diag}(u) \\delta\\varepsilon \\right] + \\alpha (\\varepsilon - \\varepsilon_{\\mathrm{ref}})^{\\top} \\delta\\varepsilon\n    $$\n    为避免计算成本高的矩阵求逆 $A^{-1}$，我们引入一个伴随问题。令伴随源为 $r_{\\text{adj}} = S^H(Su - u_{\\mathrm{t}})$。该表达式可以使用属性 $(X A^{-1} Y) = ((A^{-1})^H X)^H Y = ((A^H)^{-1} X)^H Y$ 进行重写。令伴随场 $\\lambda$ 为伴随方程的解：\n    $$\n    A^H \\lambda = r_{\\text{adj}}\n    $$\n    其中 $A^H = (L - c \\cdot \\mathrm{diag}(\\varepsilon))^H = L^T - c^* \\cdot \\mathrm{diag}(\\varepsilon)^T$。由于 $L$ 是实对称的（$L^T=L$）且 $\\varepsilon$ 是实数，所以 $A^H = L - c^* \\cdot \\mathrm{diag}(\\varepsilon)$。\n    有了 $\\lambda = (A^H)^{-1} r_{\\text{adj}}$，变分变为：\n    $$\n    \\delta J = \\mathrm{Re}\\left[ c \\, \\lambda^H \\mathrm{diag}(u) \\delta\\varepsilon \\right] + \\alpha (\\varepsilon - \\varepsilon_{\\mathrm{ref}})^{\\top} \\delta\\varepsilon\n    $$\n    项 $\\lambda^H \\mathrm{diag}(u) \\delta\\varepsilon$ 等价于逐元素乘积 $(\\overline{\\lambda} \\odot u)$ 与 $\\delta\\varepsilon$ 的内积，其中 $\\overline{\\lambda}$ 是 $\\lambda$ 的复共轭。因此，我们可以确定梯度：\n    $$\n    \\nabla_{\\varepsilon} J = \\mathrm{Re}[c \\cdot (\\overline{\\lambda} \\odot u)] + \\alpha (\\varepsilon - \\varepsilon_{\\mathrm{ref}})\n    $$\n    其中 `Re[...]` 和逐元素乘积 `$\\odot$` 是按分量应用的。这个表达式计算效率很高，因为它只需要一次正向求解（求 $u$）和一次伴随求解（求 $\\lambda$）。\n\n5.  **有限差分梯度**：为进行验证，梯度也使用中心有限差分公式对每个分量 $i$ 进行近似：\n    $$\n    \\left[\\nabla_{\\varepsilon}^{\\mathrm{FD}} J\\right]_{i} = \\frac{J(\\varepsilon + h e_{i}) - J(\\varepsilon - h e_{i})}{2h}\n    $$\n    这需要 $2N$ 次目标函数求值，使其比伴随法慢得多，但对于验证很有用。\n\n6.  **方向导数检验**：通过将解析方向导数 $\\nabla_{\\varepsilon} J^{\\top} p$ 与沿随机方向 $p$ 的有限差分近似进行比较，来执行进一步的检验：\n    $$\n    \\frac{\\mathrm{d}J(\\varepsilon + t p)}{\\mathrm{d}t}\\bigg|_{t=0} \\approx \\frac{J(\\varepsilon + t p) - J(\\varepsilon - t p)}{2 t}\n    $$\n    此测试计算成本低（两次目标函数求值），并为整个梯度实现提供了一个稳健的检验。\n\n7.  **误差计算**：验证通过两个相对误差来量化：$E_{\\text{grad}}$，即伴随梯度和有限差分梯度之间的归一化 $\\ell_2$ 距离；以及 $E_{\\text{dir}}$，即解析方向导数和有限差分方向导数之间的相对误差。每个测试用例最终报告的误差是 $E = \\max\\{E_{\\text{grad}}, E_{\\text{dir}}\\}$。\n\n实现将封装此逻辑，处理提供的套件中的每个测试用例，并生成指定的误差值列表。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the gradient validation program for a set of test cases.\n    \"\"\"\n\n    def run_case(params):\n        \"\"\"\n        Processes a single test case for gradient validation.\n        \"\"\"\n        # Unpack parameters\n        Nx, Ny = params['grid']\n        omega, eta = params['freq_loss']\n        alpha, eps_ref_val = params['reg']\n        source_locs = params['source_locs']\n        eps0_func = params['eps0_func']\n        probe_cond = params['probe_cond']\n        ut_def = params['ut_def']\n        seed = params['seed']\n\n        # h for full gradient FD, t for directional derivative FD\n        h = 1e-6\n        t = 1e-6\n\n        # Grid and indexing setup\n        nx_int, ny_int = Nx - 2, Ny - 2\n        N = nx_int * ny_int\n        \n        # Create 1D grid coord arrays for vectorized eps0 calculation\n        i_coords = np.arange(nx_int)\n        j_coords = np.arange(ny_int)\n        i_grid, j_grid = np.meshgrid(i_coords, j_coords, indexing='ij')\n\n        # Build sparse 5-point Laplacian L with zero Dirichlet BCs\n        def build_laplacian(ni, nj):\n            num_nodes = ni * nj\n            diagonals = [\n                np.ones(num_nodes),    # Main diagonal fill\n                np.ones(num_nodes-1),  # Off-diagonal for i neighbors\n                np.ones(num_nodes-1),  # Off-diagonal for i neighbors\n                np.ones(num_nodes-ni), # Off-diagonal for j neighbors\n                np.ones(num_nodes-ni)  # Off-diagonal for j neighbors\n            ]\n            diagonals[0] = -4.0 * diagonals[0]\n            offsets = [0, -1, 1, -ni, ni]\n            L = sp.diags(diagonals, offsets, shape=(num_nodes, num_nodes), format='csr')\n\n            # Remove connections between rows for the +/- 1 diagonals\n            for j in range(1, nj):\n                k = j * ni - 1\n                if k  num_nodes - 1:\n                    L[k, k + 1] = 0\n                    L[k + 1, k] = 0\n            return L\n\n        L = build_laplacian(nx_int, ny_int)\n\n        # Setup problem constants and vectors\n        c = omega**2 + 1j * eta\n        eps0 = eps0_func(i_grid, j_grid).flatten('F')\n        eps_ref = np.full(N, eps_ref_val)\n\n        b = np.zeros(N, dtype=complex)\n        for isrc, jsrc in source_locs:\n            k_src = isrc + nx_int * jsrc\n            b[k_src] = 1.0\n\n        probe_indices = [i + nx_int * j for j in j_coords for i in i_coords if probe_cond(i, j)]\n        u_t = ut_def(len(probe_indices))\n\n        # Helper function to compute the objective J(eps)\n        def compute_objective(epsilon_vec):\n            A = L - c * sp.diags(epsilon_vec)\n            u = spsolve(A, b)\n            \n            residual = u[probe_indices] - u_t\n            J_field = 0.5 * np.real(np.vdot(residual, residual))\n            J_reg = 0.5 * alpha * np.linalg.norm(epsilon_vec - eps_ref)**2\n            return J_field + J_reg\n\n        # 1. Analytical Adjoint Gradient\n        A0 = L - c * sp.diags(eps0)\n        u0 = spsolve(A0, b)\n        \n        residual = u0[probe_indices] - u_t\n        adj_source = np.zeros(N, dtype=complex)\n        adj_source[probe_indices] = residual\n        \n        AH = L - np.conj(c) * sp.diags(eps0) # L is real-symmetric, eps0 is real\n        lambda_vec = spsolve(AH, adj_source)\n        \n        grad_adj_field = np.real(c * np.conj(lambda_vec) * u0)\n        grad_adj_reg = alpha * (eps0 - eps_ref)\n        grad_adj = grad_adj_field + grad_adj_reg\n\n        # 2. Finite-Difference Gradient\n        grad_fd = np.zeros(N)\n        for i in range(N):\n            eps_plus = eps0.copy()\n            eps_minus = eps0.copy()\n            eps_plus[i] += h\n            eps_minus[i] -= h\n            J_plus = compute_objective(eps_plus)\n            J_minus = compute_objective(eps_minus)\n            grad_fd[i] = (J_plus - J_minus) / (2.0 * h)\n\n        # 3. Directional Derivative Check\n        rng = np.random.default_rng(seed)\n        p = rng.random(N)\n        \n        dir_deriv_adj = np.dot(grad_adj, p)\n        \n        J_plus_p = compute_objective(eps0 + t * p)\n        J_minus_p = compute_objective(eps0 - t * p)\n        dir_deriv_fd = (J_plus_p - J_minus_p) / (2.0 * t)\n\n        # 4. Compute Errors\n        E_grad_num = np.linalg.norm(grad_adj - grad_fd)\n        E_grad_den = max(np.linalg.norm(grad_fd), 1e-12)\n        E_grad = E_grad_num / E_grad_den\n\n        E_dir_num = np.abs(dir_deriv_adj - dir_deriv_fd)\n        E_dir_den = max(np.abs(dir_deriv_fd), 1e-12)\n        E_dir = E_dir_num / E_dir_den\n        \n        return max(E_grad, E_dir)\n\n    # Test Suite Definition\n    test_cases = [\n        # Case A\n        {\n            'grid': (10, 12), 'freq_loss': (5.0, 0.2), 'reg': (0.01, 1.5),\n            'source_locs': [(int((10-2)/3), int((12-2)/2))],\n            'eps0_func': lambda i, j: 2.0 + 0.1 * np.sin(2*np.pi*i/(10-2)) * np.sin(3*np.pi*j/(12-2)),\n            'probe_cond': lambda i, j: i % 3 == 1 and j % 4 == 2,\n            'ut_def': lambda n_probes: np.zeros(n_probes),\n            'seed': 1\n        },\n        # Case B\n        {\n            'grid': (8, 8), 'freq_loss': (3.0, 0.05), 'reg': (0.0, 1.0),\n            'source_locs': [(int((8-2)/2), int((8-2)/2))],\n            'eps0_func': lambda i, j: (lambda ic, jc, s: 1.0 + 0.2 * np.exp(-((i-ic)**2 + (j-jc)**2) / (2*s**2)))(int((8-2)/2), int((8-2)/2), 2.0),\n            'probe_cond': lambda i, j: i == int((8-2)/2) and j == int((8-2)/2),\n            'ut_def': lambda n_probes: np.array([0.1]),\n            'seed': 2\n        },\n        # Case C\n        {\n            'grid': (12, 12), 'freq_loss': (10.0, 0.8), 'reg': (0.001, 1.0),\n            'source_locs': [(int((12-2)/2), int((12-2)/2)), (int((12-2)/2)-2, int((12-2)/2)+1)],\n            'eps0_func': lambda i, j: np.full_like(i, 1.5, dtype=float),\n            'probe_cond': lambda i, j: (i == int((12-2)/2) and j % 2 == 0) or (j == int((12-2)/2) and i % 2 == 0),\n            'ut_def': lambda n_probes: np.zeros(n_probes),\n            'seed': 3\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_case(case)\n        results.append(error)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本实践将伴随方法应用于一个具体的工程问题：最小化介电物体的雷达散射截面（RCS）。我们将从有限元法的稀疏矩阵背景转换到积分方程中矩量法（MoM）特有的稠密矩阵形式。这项练习提供了一个处理完整设计周期的经验，包括求解正向和伴随系统，并对一个实际的电磁设计执行带约束的梯度下降更新。",
            "id": "3312420",
            "problem": "给定一个二维横磁（TM）散射问题，该问题通过体积分方程建立，并使用矩量法（MoM）进行离散化。在角频率为$\\omega$的自由空间中，总电场$E_z(\\mathbf{r})$满足非均匀介电分布$\\epsilon(\\mathbf{r})$的Lippmann–Schwinger方程：\n$$\nE_z(\\mathbf{r}) = E_z^{\\text{inc}}(\\mathbf{r}) + k_0^2 \\int_{\\Omega} G(\\mathbf{r},\\mathbf{r}') \\chi(\\mathbf{r}') E_z(\\mathbf{r}') \\, dA',\n$$\n其中$k_0 = \\omega \\sqrt{\\mu_0 \\epsilon_0}$是自由空间波数，$\\chi(\\mathbf{r}) = \\epsilon(\\mathbf{r})/\\epsilon_0 - 1$是介电对比度，$\\Omega$是散射体的支撑域，$G(\\mathbf{r},\\mathbf{r}') = \\frac{j}{4} H_0^{(1)}(k_0 \\lvert \\mathbf{r} - \\mathbf{r}' \\rvert)$是二维标量格林函数，其中$H_0^{(1)}$是零阶第一类Hankel函数。入射场$E_z^{\\text{inc}}(\\mathbf{r})$是一个单位振幅的平面波。\n\n使用脉冲（常数）基函数和在$N$个点单元上的点配置测试法，这些点单元的面积为$\\{A_i\\}_{i=1}^N$，中心为$\\{\\mathbf{r}_i\\}_{i=1}^N$，该积分方程被离散化为稠密的线性系统\n$$\nZ(\\boldsymbol{\\epsilon}) \\, \\mathbf{x} = \\mathbf{b}, \\quad \\text{with} \\quad Z(\\boldsymbol{\\epsilon}) = I - k_0^2 G \\, D(\\boldsymbol{\\epsilon}),\n$$\n其中$I$是$N \\times N$的单位矩阵，$G \\in \\mathbb{C}^{N \\times N}$的元素为$G_{ij} = \\frac{j}{4} H_0^{(1)}(k_0 \\lvert \\mathbf{r}_i - \\mathbf{r}_j \\rvert)$（当$i \\neq j$时），并且在低对比度配置近似下$G_{ii} = 0$，$D(\\boldsymbol{\\epsilon}) = \\operatorname{diag}(\\chi_1 A_1, \\dots, \\chi_N A_N)$，$\\chi_i = \\epsilon_i/\\epsilon_0 - 1$，$\\mathbf{x} \\in \\mathbb{C}^N$是$\\Omega$内部总场样本$E_z(\\mathbf{r}_i)$的向量，$\\mathbf{b} \\in \\mathbb{C}^N$的元素为$b_i = E_z^{\\text{inc}}(\\mathbf{r}_i)$。由于$G$的长程性质，阻抗矩阵$Z(\\boldsymbol{\\epsilon})$是稠密的。\n\n定义方向$\\hat{\\mathbf{s}}$上的远场散射幅度为离散近似\n$$\nq(\\boldsymbol{\\epsilon}) = \\sum_{i=1}^N \\left( \\chi_i A_i \\, E_z(\\mathbf{r}_i) \\, e^{-j k_0 \\hat{\\mathbf{s}} \\cdot \\mathbf{r}_i} \\right) = \\mathbf{s}^T D(\\boldsymbol{\\epsilon}) \\mathbf{x},\n$$\n其中$\\mathbf{s} \\in \\mathbb{C}^N$的元素为$s_i = e^{-j k_0 \\hat{\\mathbf{s}} \\cdot \\mathbf{r}_i}$。使用其幅度的平方作为标量目标函数\n$$\nJ(\\boldsymbol{\\epsilon}) = \\lvert q(\\boldsymbol{\\epsilon}) \\rvert^2,\n$$\n该值与二维雷达散射宽度（雷达散射截面（RCS）的二维模拟）成正比。优化变量是分段常数介电常数向量$\\boldsymbol{\\epsilon} = (\\epsilon_1, \\dots, \\epsilon_N)$。\n\n您的任务是实现一个基于离散伴随法的$J(\\boldsymbol{\\epsilon})$关于$\\boldsymbol{\\epsilon}$的梯度计算，并对指定的测试用例执行单次梯度下降更新。从第一性原理出发，基于电磁积分方程和线性代数伴随灵敏度推导梯度表达式。在离散伴随法中，令$\\mathbf{x}$解$Z(\\boldsymbol{\\epsilon}) \\mathbf{x} = \\mathbf{b}$。$Z(\\boldsymbol{\\epsilon})$关于$\\epsilon_i$的导数为\n$$\n\\frac{\\partial Z}{\\partial \\epsilon_i} = - k_0^2 \\, \\mathbf{g}_i \\, V_i \\, \\mathbf{e}_i^T, \\quad \\text{with } \\mathbf{g}_i = G \\mathbf{e}_i, \\; V_i = A_i, \\; \\mathbf{e}_i \\text{ the } i\\text{-th standard basis vector},\n$$\n因为$D(\\boldsymbol{\\epsilon}) = \\operatorname{diag}((\\epsilon_i/\\epsilon_0 - 1) A_i)$。离散伴随向量$\\boldsymbol{\\lambda}$由共轭转置系统定义\n$$\nZ(\\boldsymbol{\\epsilon})^H \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{x}^*},\n$$\n其中$^H$表示共轭转置，$\\frac{\\partial J}{\\partial \\mathbf{x}^*}$是关于$\\mathbf{x}$的共轭的Wirtinger导数。对于目标函数$J(\\boldsymbol{\\epsilon}) = \\lvert \\mathbf{s}^T D(\\boldsymbol{\\epsilon}) \\mathbf{x} \\rvert^2$，此右侧项等于\n$$\n\\frac{\\partial J}{\\partial \\mathbf{x}^*} = D(\\boldsymbol{\\epsilon})^H \\mathbf{s} \\, q(\\boldsymbol{\\epsilon}).\n$$\n$\\epsilon_i$的总梯度分量为\n$$\n\\frac{\\partial J}{\\partial \\epsilon_i} = -2 \\operatorname{Re} \\left\\{ \\boldsymbol{\\lambda}^H \\left( \\frac{\\partial Z}{\\partial \\epsilon_i} \\right) \\mathbf{x} \\right\\} + 2 \\operatorname{Re} \\left\\{ q(\\boldsymbol{\\epsilon})^* \\left( s_i \\, V_i \\, x_i \\right) \\right\\}.\n$$\n假设入射和观测方向相同（单站，后向散射），$\\hat{\\mathbf{p}} = \\hat{\\mathbf{s}} = (1,0)$，且$E_z^{\\text{inc}}(\\mathbf{r}) = e^{j k_0 \\hat{\\mathbf{p}} \\cdot \\mathbf{r}}$。使用以下具有物理意义的国际单位制（SI）参数：\n- 自由空间光速$c = 3.0 \\times 10^8$米/秒，自由空间介电常数$\\epsilon_0 = 8.854187817 \\times 10^{-12}$法拉/米，绝对磁导率$\\mu_0 = 4\\pi \\times 10^{-7}$亨利/米。\n- 频率$f = 1.0 \\times 10^9$赫兹（因此$k_0 = \\frac{2\\pi f}{c}$弧度/米）。\n- 四个点单元位于位置$\\mathbf{r}_1 = (-d/2,-d/2)$, $\\mathbf{r}_2 = (d/2,-d/2)$, $\\mathbf{r}_3 = (-d/2,d/2)$, $\\mathbf{r}_4 = (d/2,d/2)$，其中$d = 0.05$米，面积$A_i = d^2$平方米（对于$i = 1,\\dots,4$）。\n\n执行单次梯度下降更新\n$$\n\\epsilon_i^{\\text{new}} = \\max\\{ 1.0, \\, \\epsilon_i - \\alpha \\, \\frac{\\partial J}{\\partial \\epsilon_i} \\},\n$$\n步长$\\alpha = 0.2$（无量纲），并通过$\\max$函数约束更新以保持$\\epsilon_i^{\\text{new}} \\ge 1.0$，从而确保非负的介电对比度。对于任何索引$i$，如果其“冻结”掩码指示一个在阻抗边界理想化下的理想电导体（PEC）类片段，则通过设置$\\epsilon_i^{\\text{new}} = \\epsilon_i$来禁用更新，但如果其$\\epsilon_i$对$D(\\boldsymbol{\\epsilon})$有贡献，则仍将其包含在散射计算中。\n\n您的程序应实现：\n- 构建稠密阻抗矩阵$Z(\\boldsymbol{\\epsilon})$和入射向量$\\mathbf{b}$。\n- 求解正演系统以获得$\\mathbf{x}$，计算$q(\\boldsymbol{\\epsilon})$和$J(\\boldsymbol{\\epsilon})$。\n- 求解伴随系统以获得$\\boldsymbol{\\lambda}$，并使用上述公式计算梯度向量$\\nabla_{\\boldsymbol{\\epsilon}} J$。\n- 对$\\boldsymbol{\\epsilon}$使用步长$\\alpha$执行一次带掩码和钳位的梯度下降更新。\n- 更新后重新计算$J(\\boldsymbol{\\epsilon}^{\\text{new}})$。\n\n测试套件：\n- 情况1：仅介电质，初始介电常数向量$\\boldsymbol{\\epsilon} = [2.5, 1.8, 2.2, 1.5]$（以$\\epsilon_0$为单位的法拉/米，即代码中为无量纲的$\\epsilon/\\epsilon_0$项），掩码$\\mathbf{m} = [1, 1, 1, 1]$（所有项均可更新）。\n- 情况2：边界条件边缘情况，初始$\\boldsymbol{\\epsilon} = [1.0, 1.0, 1.0, 1.0]$，掩码$\\mathbf{m} = [1, 1, 1, 1]$。\n- 情况3：含PEC类冻结片段的复合材料，初始$\\boldsymbol{\\epsilon} = [10.0, 2.0, 10.0, 2.0]$，掩码$\\mathbf{m} = [0, 1, 0, 1]$（仅更新第2项和第4项）。\n\n答案规格：\n- 所有几何变量以米为单位，角度量以弧度为单位，频率以赫兹为单位。目标函数$J(\\boldsymbol{\\epsilon})$是无量纲的，应报告为浮点数。\n- 您的程序应生成一行输出，其中包含所有测试用例的更新后目标值，形式为逗号分隔的列表并用方括号括起来，顺序与指定的用例顺序一致，例如$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$。",
            "solution": "该问题要求为电磁逆散射问题实现单步梯度下降更新。目标是优化散射体的介电常数分布，以操控其远场散射模式。指定的方法是离散伴随法，这是一种用于计算目标函数相对于大量设计参数的梯度的计算高效技术。\n\n首先，我们必须验证问题陈述。所有物理常数、参数、材料属性和几何配置都已提供。控制方程——Lippmann-Schwinger积分方程、其矩量法（MoM）离散化、远场散射幅度的定义以及目标函数的形式——在计算电磁学中都是标准的。问题的核心在于为伴随法提供的公式。\n\n问题陈述中关于优化变量存在一个关键的模糊之处。文本指定变量为绝对介电常数向量$\\boldsymbol{\\epsilon} = (\\epsilon_1, \\dots, \\epsilon_N)$，单位为法拉/米。然而，所提供的导数公式，例如$\\frac{\\partial Z}{\\partial \\epsilon_i} = - k_0^2 \\, \\mathbf{g}_i \\, V_i \\, \\mathbf{e}_i^T$（其中$V_i=A_i$），仅当优化变量是无量纲的相对介电常数向量$\\boldsymbol{\\epsilon}_r = (\\epsilon_{r,1}, \\dots, \\epsilon_{r,N})$（其中$\\epsilon_{r,i} = \\epsilon_i/\\epsilon_0$）时，在数学上才是一致的。这是因为介电对比度是$\\chi_i = \\epsilon_{r,i} - 1$，其相对于$\\epsilon_{r,i}$的导数就是$1$，而其相对于$\\epsilon_i$的导数是$1/\\epsilon_0$。所提供的公式省略了$1/\\epsilon_0$这个因子。此外，测试用例提供的介电常数值是无量纲数，被描述为“以$\\epsilon_0$缩放”，并且梯度更新的钳位值是无量纲值$1.0$，这对应于真空的相对介电常数。基于这些压倒性的证据，我们必须得出结论，预期的优化变量是相对介电常数$\\boldsymbol{\\epsilon}_r$。解决方案将在此必要解释下进行。\n\n另一个小点是伴随源的公式，$\\frac{\\partial J}{\\partial \\mathbf{x}^*} = D(\\boldsymbol{\\epsilon})^H \\mathbf{s} \\, q(\\boldsymbol{\\epsilon})$。标准推导通常会在向量$\\mathbf{s}$上产生一个复共轭。然而，由于问题陈述在$\\boldsymbol{\\epsilon}_r$的解释下在其他方面是自洽的，我们将严格遵守所给出的公式。因此，在该解释下，该问题被认为是有效且可解的。\n\n解决方案按以下步骤进行：\n\n**1. 系统设置和常数定义**\n我们首先定义物理常数和问题参数。\n- 自由空间常数：光速$c = 3.0 \\times 10^8 \\, \\text{m/s}$，介电常数$\\epsilon_0 = 8.854187817 \\times 10^{-12} \\, \\text{F/m}$。\n- 工作频率$f = 1.0 \\times 10^9 \\, \\text{Hz}$。\n- 由此，我们计算角频率$\\omega = 2\\pi f$和自由空间波数$k_0 = \\omega/c$。\n- 几何结构由$N=4$个边长为$d = 0.05 \\, \\text{m}$、面积为$A_i = d^2 = 0.0025 \\, \\text{m}^2$的方形单元组成。单元中心$\\{\\mathbf{r}_i\\}_{i=1}^4$位于$(\\pm d/2, \\pm d/2)$。\n- 入射平面波沿$\\hat{\\mathbf{p}} = (1,0)$传播，后向散射在同一方向$\\hat{\\mathbf{s}} = (1,0)$观测。\n- 梯度下降步长为$\\alpha = 0.2$。\n\n对于每个测试用例，我们都给定一个初始相对介电常数向量$\\boldsymbol{\\epsilon}_r$和一个更新掩码$\\mathbf{m}$。\n\n**2. 正演问题求解**\n分析的核心是求解离散化的Lippmann-Schwinger方程$Z(\\boldsymbol{\\epsilon}_r) \\mathbf{x} = \\mathbf{b}$以获得总电场向量$\\mathbf{x}$。\n\n- **格林函数矩阵$G$**：构建一个$N \\times N$的矩阵$G$。其元素由$G_{ij} = \\frac{j}{4} H_0^{(1)}(k_0 |\\mathbf{r}_i - \\mathbf{r}_j|)$（当$i \\neq j$时）和$G_{ii} = 0$给出。$H_0^{(1)}$是零阶第一类Hankel函数。\n- **对比度矩阵$D(\\boldsymbol{\\epsilon}_r)$**：介电对比度向量为$\\boldsymbol{\\chi} = \\boldsymbol{\\epsilon}_r - 1$。矩阵$D$是一个对角矩阵，其元素为$D_{ii} = \\chi_i A_i$。\n- **阻抗矩阵$Z(\\boldsymbol{\\epsilon}_r)$**：系统矩阵为$Z = I - k_0^2 G D$，其中$I$是$N \\times N$的单位矩阵。\n- **入射场向量$\\mathbf{b}$**：右侧向量$\\mathbf{b}$包含在单元中心的入射场值，$b_i = E_z^{\\text{inc}}(\\mathbf{r}_i) = e^{j k_0 \\hat{\\mathbf{p}} \\cdot \\mathbf{r}_i}$。\n- **场解$\\mathbf{x}$**：构建好$Z$和$\\mathbf{b}$后，求解稠密复线性系统以获得$\\mathbf{x} = Z^{-1} \\mathbf{b}$。\n\n**3. 目标函数计算**\n目标函数是远场散射幅度的平方模，$J(\\boldsymbol{\\epsilon}_r) = |q(\\boldsymbol{\\epsilon}_r)|^2$。\n\n- **观测向量$\\mathbf{s}$**：此向量由远场计算的相位因子定义，$s_i = e^{-j k_0 \\hat{\\mathbf{s}} \\cdot \\mathbf{r}_i}$。\n- **散射幅度$q(\\boldsymbol{\\epsilon}_r)$**：此标量值计算为$q = \\mathbf{s}^T D(\\boldsymbol{\\epsilon}_r) \\mathbf{x}$。\n- **目标$J(\\boldsymbol{\\epsilon}_r)$**：目标则简单地是$J = |q|^2 = q^*q$。\n\n**4. 伴随问题求解**\n离散伴随法通过引入一个伴随状态向量$\\boldsymbol{\\lambda}$，避免了计算成本高昂的$\\frac{\\partial \\mathbf{x}}{\\partial \\epsilon_{r,i}}$。\n\n- **伴随源**：伴随方程的右侧由$\\frac{\\partial J}{\\partial \\mathbf{x}^*} = D^H \\mathbf{s} q$给出。由于$D$是实对角矩阵，所以$D^H = D$。\n- **伴随方程**：通过求解线性系统$Z^H \\boldsymbol{\\lambda} = \\frac{\\partial J}{\\partial \\mathbf{x}^*}$找到伴随向量$\\boldsymbol{\\lambda} \\in \\mathbb{C}^N$，其中$Z^H$是$Z$的共轭转置。\n\n**5. 梯度计算**\n目标函数相对于相对介电常数向量的每个分量的梯度$\\frac{\\partial J}{\\partial \\epsilon_{r,i}}$，是使用正演场$\\mathbf{x}$和伴随场$\\boldsymbol{\\lambda}$计算的。提供的公式是：\n$$\n\\frac{\\partial J}{\\partial \\epsilon_{r,i}} = -2 \\operatorname{Re} \\left\\{ \\boldsymbol{\\lambda}^H \\left( \\frac{\\partial Z}{\\partial \\epsilon_{r,i}} \\right) \\mathbf{x} \\right\\} + 2 \\operatorname{Re} \\left\\{ q^* \\left( s_i A_i x_i \\right) \\right\\}\n$$\n阻抗矩阵的导数为$\\frac{\\partial Z}{\\partial \\epsilon_{r,i}} = -k_0^2 G \\frac{\\partial D}{\\partial \\epsilon_{r,i}} = -k_0^2 G (A_i \\mathbf{e}_i \\mathbf{e}_i^T) = -k_0^2 A_i \\mathbf{g}_i \\mathbf{e}_i^T$，其中$\\mathbf{g}_i = G \\mathbf{e}_i$是$G$的第$i$列。\n将此代入梯度公式得到：\n$$\n\\frac{\\partial J}{\\partial \\epsilon_{r,i}} = -2 \\operatorname{Re} \\left\\{ \\boldsymbol{\\lambda}^H (-k_0^2 A_i x_i \\mathbf{g}_i) \\right\\} + 2 \\operatorname{Re} \\left\\{ q^* s_i A_i x_i \\right\\}\n= 2 A_i \\operatorname{Re} \\left\\{ x_i \\left( k_0^2 (\\boldsymbol{\\lambda}^H \\mathbf{g}_i) + q^* s_i \\right) \\right\\}\n$$\n对每个$i=1, \\dots, N$计算此表达式，以形成梯度向量$\\nabla_{\\boldsymbol{\\epsilon}_r} J$。\n\n**6. 梯度下降更新**\n执行单步梯度下降。\n\n- **掩码操作**：将计算出的梯度向量与掩码向量$\\mathbf{m}$进行逐元素相乘，以冻结指定的介电常数值。\n- **更新**：新的介电常数向量计算为$\\boldsymbol{\\epsilon}_r^{\\text{new}} = \\boldsymbol{\\epsilon}_r - \\alpha \\, (\\mathbf{m} \\odot \\nabla_{\\boldsymbol{\\epsilon}_r} J)$，其中$\\odot$表示逐元素乘法。\n- **钳位**：为确保物理上的合理性（非负对比度），更新后的介电常数受到约束：$\\epsilon_{r,i}^{\\text{new}} = \\max\\{1.0, \\epsilon_{r,i}^{\\text{new}}\\}$。\n\n最后，通过重复步骤2和3，使用更新后的介电常数向量$\\boldsymbol{\\epsilon}_r^{\\text{new}}$重新计算目标函数$J(\\boldsymbol{\\epsilon}_r^{\\text{new}})$。收集并打印每个测试用例的结果值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\n# from scipy import ...\n\ndef solve():\n    # Define physical constants\n    C0 = 3.0e8  # Speed of light in vacuum (m/s)\n    EPS0 = 8.854187817e-12  # Permittivity of free space (F/m)\n    MU0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n\n    # Problem parameters\n    FREQ = 1.0e9  # Frequency (Hz)\n    D_GEOM = 0.05  # Side length of the square geometry (m)\n    ALPHA = 0.2  # Gradient descent step size\n\n    # Derived constants\n    OMEGA = 2 * np.pi * FREQ\n    K0 = OMEGA / C0\n\n    # Geometry setup\n    N = 4 # Number of cells\n    r_coords = (D_GEOM / 2.0) * np.array([\n        [-1.0, -1.0],\n        [1.0, -1.0],\n        [-1.0, 1.0],\n        [1.0, 1.0]\n    ])\n    A_cell = D_GEOM**2 # Area of each cell\n\n    # Incident and observation directions\n    p_hat = np.array([1.0, 0.0])\n    s_hat = np.array([1.0, 0.0])\n\n    # Pre-compute distance matrix and Green's function matrix structure\n    dist_matrix = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            dist_matrix[i, j] = np.linalg.norm(r_coords[i, :] - r_coords[j, :])\n\n    G = np.zeros((N, N), dtype=complex)\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                G[i, j] = 1j / 4 * hankel1(0, K0 * dist_matrix[i, j])\n    \n    # Pre-compute incident field vector b and observation vector s\n    b = np.exp(1j * K0 * (r_coords @ p_hat))\n    s_vec = np.exp(-1j * K0 * (r_coords @ s_hat))\n\n    def compute_objective_and_gradient(eps_r):\n        \"\"\"\n        Computes the objective function J and its gradient wrt eps_r.\n        \"\"\"\n        chi = eps_r - 1.0\n        D = np.diag(chi * A_cell)\n        \n        Z = np.eye(N) - K0**2 * G @ D\n        \n        # Forward solve\n        try:\n            x = np.linalg.solve(Z, b)\n        except np.linalg.LinAlgError:\n            return np.inf, np.zeros_like(eps_r)\n        \n        # Objective calculation\n        q = s_vec.T @ D @ x\n        J = np.abs(q)**2\n        \n        # Adjoint solve\n        # problem statement gives D^H s q, D is real so D^H = D\n        adj_rhs = D @ s_vec * q\n        \n        try:\n            lambda_ = np.linalg.solve(Z.conj().T, adj_rhs)\n        except np.linalg.LinAlgError:\n             return J, np.zeros_like(eps_r)\n        \n        # Gradient calculation\n        grad_J = np.zeros(N)\n        # Vectorized calculation for efficiency\n        # term1_vec = k0^2 * (lambda_H * G)\n        # problem: term is lambda_H * g_i = lambda_.conj().T @ G[:, i]\n        # This is the i-th element of lambda_.conj().T @ G\n        w_row = K0**2 * (lambda_.conj().T @ G)\n        \n        grad_terms = x * (w_row.T + np.conj(q) * s_vec)\n        grad_J = 2 * A_cell * np.real(grad_terms)\n        \n        return J, grad_J\n\n    def compute_objective(eps_r):\n        \"\"\"\n        Computes only the objective function value J.\n        \"\"\"\n        chi = eps_r - 1.0\n        D = np.diag(chi * A_cell)\n        \n        Z = np.eye(N) - K0**2 * G @ D\n        \n        try:\n            x = np.linalg.solve(Z, b)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        q = s_vec.T @ D @ x\n        J = np.abs(q)**2\n        return J\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Dielectric-only\n        {'eps_r_initial': np.array([2.5, 1.8, 2.2, 1.5]), 'mask': np.array([1, 1, 1, 1])},\n        # Case 2: Boundary condition edge case\n        {'eps_r_initial': np.array([1.0, 1.0, 1.0, 1.0]), 'mask': np.array([1, 1, 1, 1])},\n        # Case 3: Composite with frozen segments\n        {'eps_r_initial': np.array([10.0, 2.0, 10.0, 2.0]), 'mask': np.array([0, 1, 0, 1])},\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_r = case['eps_r_initial'].copy()\n        mask = case['mask']\n\n        # 1. Compute gradient at initial point\n        J_initial, grad_J = compute_objective_and_gradient(eps_r)\n\n        # 2. Apply mask to gradient\n        masked_grad = grad_J * mask\n        \n        # 3. Perform a single gradient descent update\n        eps_r_new = eps_r - ALPHA * masked_grad\n        \n        # 4. Apply clamp to ensure eps_r >= 1.0\n        eps_r_new = np.maximum(1.0, eps_r_new)\n        \n        # 5. Recompute the objective function at the new point\n        J_new = compute_objective(eps_r_new)\n        \n        results.append(J_new)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}