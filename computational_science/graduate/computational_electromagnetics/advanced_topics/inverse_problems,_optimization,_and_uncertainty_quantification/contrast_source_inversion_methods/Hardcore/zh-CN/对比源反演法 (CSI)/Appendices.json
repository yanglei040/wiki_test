{
    "hands_on_practices": [
        {
            "introduction": "在基于优化的反演方法中，伴随状态法 (adjoint-state method) 是计算大规模问题目标函数梯度的核心工具。然而，其推导和代码实现过程复杂，极易引入错误，而一个错误的梯度将导致任何优化算法失效。因此，通过“泰勒检验” (Taylor test)  将伴随法计算的解析梯度与有限差分计算的数值梯度进行比对，是开发反演代码时不可或缺的关键验证步骤。",
            "id": "3295894",
            "problem": "考虑一个均匀背景下的一维频域散射问题，该问题被离散化为对比源反演 (CSI) 的设置。令总场 $E(x)$ 在有界区间 $\\Omega = [0,L]$ 上满足 Lippmann–Schwinger 积分方程，\n$$\nE(x) \\;=\\; E_{\\mathrm{inc}}(x) \\;+\\; \\int_{\\Omega} G(x,x')\\, k_0^2\\, \\chi(x')\\, E(x')\\, dx',\n$$\n其中 $E_{\\mathrm{inc}}(x)$ 是给定的入射场，$\\chi(x)$ 是未知的（实值）对比度，$k_0$ 是背景波数，$G(x,x')$ 是标量亥姆霍茲方程的一维自由空间格林函数，\n$$\nG(x,x') \\;=\\; \\frac{i}{2 k_0}\\, e^{i k_0 |x - x'|}.\n$$\n我们在整个过程中均使用无量纲单位。\n\n用 $N$ 个等距节点 $x_n$ 对 $\\Omega$ 进行离散化，节点间距为 $\\Delta x = L/(N-1)$。将总场向量记为 $E \\in \\mathbb{C}^N$，其元素为 $E_n \\approx E(x_n)$；将对比度样本向量记为 $\\chi \\in \\mathbb{R}^N$，其元素为 $\\chi_n \\approx \\chi(x_n)$。定义稠密矩阵 $G \\in \\mathbb{C}^{N \\times N}$，其元素为\n$$\nG_{mn} \\;=\\; \\Delta x \\,\\frac{i}{2 k_0}\\, e^{i k_0 |x_m - x_n|},\n$$\n以及对角矩阵 $V(\\chi) = k_0^2 \\,\\mathrm{diag}(\\chi) \\in \\mathbb{R}^{N \\times N}$。离散总场 $E(\\chi)$ 是以下线性系统的解\n$$\nA(\\chi)\\, E(\\chi) \\;=\\; E_{\\mathrm{inc}}, \n\\qquad A(\\chi) \\;=\\; I \\;-\\; G\\,V(\\chi),\n$$\n其中 $I$ 是单位矩阵，$E_{\\mathrm{inc}} \\in \\mathbb{C}^N$ 是在 $\\{x_n\\}$ 处采样的入射场。\n\n令 $P \\in \\{0,1\\}^{M \\times N}$ 为一个选择算子，用于提取总场的 $M$ 个内部样本。给定由选定的真实对比度 $\\chi_{\\mathrm{true}}$ 生成的合成数据 $d \\in \\mathbb{C}^M$，定义数据失配目标函数\n$$\nJ(\\chi) \\;=\\; \\frac{1}{2}\\, \\| P\\,E(\\chi) \\;-\\; d \\|_2^2.\n$$\n通过伴随状态法，引入求解伴随线性系统的 $\\lambda \\in \\mathbb{C}^N$\n$$\nA(\\chi)^{H}\\, \\lambda \\;=\\; P^{H}\\,\\big(P\\,E(\\chi) \\;-\\; d\\big),\n$$\n其中 ${}^{H}$ 表示共轭转置。$J$ 关于 $\\chi$ 的梯度是一个实向量 $g(\\chi) \\in \\mathbb{R}^N$，其分量为\n$$\ng_n(\\chi) \\;=\\; k_0^2\\, \\mathrm{Re}\\!\\left\\{ \\overline{\\left(G^{H}\\lambda\\right)_n}\\; E_n(\\chi) \\right\\}, \n\\qquad n = 1,\\dots,N,\n$$\n其中上划线表示复共轭。该梯度通过以下方式提供了 $J$ 相对于实值扰动 $\\delta\\chi$ 的一阶方向导数\n$$\n\\delta J \\;=\\; \\sum_{n=1}^{N} g_n(\\chi)\\, \\delta\\chi_n \\;+\\; \\mathcal{O}(\\|\\delta\\chi\\|^2).\n$$\n\n您的任务是编写一个完整的程序，该程序：\n- 根据上述描述为一个特定的测试配置构建正演模型。\n- 计算基于伴随状态法的梯度 $g(\\chi)$。\n- 数值验证这个基于伴随状态法的梯度与 $J$ 的有限差分近似在 $\\delta\\chi$ 上达到一阶匹配。\n\n使用以下测试配置和测试套件，所有单位均为无量纲：\n- 域长度: $L = 1$。\n- 网格点数: $N = 80$。\n- 波数: $k_0 = 20\\pi$。\n- 入射场: 在 $\\{x_n\\}$ 处采样的 $E_{\\mathrm{inc}}(x) = e^{i k_0 x}$。\n- 真实对比度: 一个以 $x=L/2$ 为中心的高斯凸起，\n  $$\n  \\chi_{\\mathrm{true}}(x) \\;=\\; 0.5 \\,\\exp\\!\\left( -\\frac{(x - L/2)^2}{2\\sigma^2} \\right),\n  \\quad \\text{with } \\sigma = 0.15\\,L.\n  $$\n- 数据: $d = P\\,E(\\chi_{\\mathrm{true}})$，使用相同的正演模型和选择算子 $P$。\n- 选择算子 $P$: 选择 $M = 16$ 个等距的内部网格索引（为避免边缘效应，排除每个边界的前四个和后四个节点），并让 $P$ 提取 $E$ 的这些样本。\n- 测试背景对比度:\n  - 对于测试 $1$ 和 $3$，使用\n    $$\n    \\chi_0(x) \\;=\\; 0.1\\, \\sin\\!\\left( \\frac{2\\pi x}{L} \\right).\n    $$\n  - 对于测试 $2$，使用 $\\chi_0(x) \\equiv 0$。\n- 方向向量:\n  - 对于测试 $1$，使用单像素扰动，即 $\\delta\\chi = \\mathbf{e}_p$，其中 $p = \\lfloor N/3 \\rfloor$。\n  - 对于测试 $2$ 和测试 $3$，使用一个固定的伪随机实向量 $\\delta\\chi$，其具有单位 $\\ell_2$ 范数（为保证可复现性设置种子），并在所有 $N$ 个条目上都有支撑。\n- 有限差分步长: $\\varepsilon_1 = 1 \\times 10^{-3}$ 和 $\\varepsilon_2 = 5 \\times 10^{-4}$。\n\n定义以下三个测试，并返回布尔值以指示预期的一阶一致性是否成立：\n- 测试 $1$ (前向差分一阶缩放): 使用如上的 $\\chi_0$ 和 $\\delta\\chi = \\mathbf{e}_p$，定义\n  $$\n  \\mathrm{FD}(\\varepsilon) \\;=\\; \\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) \\;-\\; J(\\chi_0)}{\\varepsilon}, \n  \\qquad \\mathrm{AD} \\;=\\; g(\\chi_0)^{T} \\delta\\chi,\n  $$\n  以及失配 $R(\\varepsilon) = \\big| \\mathrm{FD}(\\varepsilon) - \\mathrm{AD} \\big|$。验证 $R(\\varepsilon_2)/R(\\varepsilon_1)$ 位于 $[0.3,\\,0.7]$ 区间内。\n- 测试 $2$ (零对比度下的中心差分一致性): 使用 $\\chi_0 \\equiv 0$ 和一个单位范数的随机 $\\delta\\chi$，定义\n  $$\n  \\mathrm{CD}(\\varepsilon) \\;=\\; \\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) \\;-\\; J(\\chi_0 - \\varepsilon\\,\\delta\\chi)}{2\\varepsilon},\n  \\qquad \\mathrm{AD} \\;=\\; g(\\chi_0)^{T} \\delta\\chi,\n  $$\n  以及失配 $C(\\varepsilon) = \\big| \\mathrm{CD}(\\varepsilon) - \\mathrm{AD} \\big|$。验证 $C(10^{-4}) \\le 10^{-6}$。\n- 测试 $3$ (中心差分二阶缩放): 使用与测试 $1$ 中相同的 $\\chi_0$ 和一个单位范数的随机 $\\delta\\chi$，验证比率 $C(\\varepsilon_2)/C(\\varepsilon_1)$ 位于 $[0.2,\\,0.3]$ 区间内。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。每个结果都必须是一个布尔值。不允许有其他输出。",
            "solution": "用户要求对一维对比源反演问题的伴随状态梯度进行数值验证。该问题是适定的、有科学依据的，并为提供完整解法提供了所有必要信息。该验证过程通常称为泰勒检验或梯度检验，是开发基于优化的反演算法中一个标准且至关重要的步骤。它确保了通过解析推导出的梯度能够正确表示目标函数的局部一阶行为。\n\n问题的核心在于 Lippmann-Schwinger 积分方程，该方程将总电场 $E(x)$ 描述为入射场 $E_{\\mathrm{inc}}(x)$ 与由对比度物体 $\\chi(x)$产生的散射场之和：\n$$\nE(x) \\;=\\; E_{\\mathrm{inc}}(x) \\;+\\; k_0^2 \\int_{\\Omega} G(x,x')\\, \\chi(x')\\, E(x')\\, dx'\n$$\n在 $N$ 个点 $\\{x_n\\}$ 的网格上进行离散化后，该方程转换为关于场样本向量 $E \\in \\mathbb{C}^N$ 的线性系统：\n$$\nA(\\chi)\\, E(\\chi) \\;=\\; E_{\\mathrm{inc}}\n$$\n其中 $A(\\chi) = I - G V(\\chi)$。此处，$I \\in \\mathbb{R}^{N \\times N}$ 是单位矩阵，$G \\in \\mathbb{C}^{N \\times N}$ 是离散化的格林函数算子，$V(\\chi) \\in \\mathbb{R}^{N \\times N}$ 是一个对角矩阵，其对角线元素为对比度值 $\\chi_n \\approx \\chi(x_n)$ 乘以 $k_0^2$。求解该系统以获得 $E(\\chi)$ 的过程构成了正演模型。\n\n反演的目标是找到一个对比度 $\\chi$ 来最小化数据失配目标函数 $J(\\chi)$。该函数量化了测量数据 $d \\in \\mathbb{C}^M$ 与计算出的场 $E(\\chi)$ 的相应样本之间的 $\\ell_2$ 范数平方差：\n$$\nJ(\\chi) \\;=\\; \\frac{1}{2}\\, \\| P\\,E(\\chi) \\;-\\; d \\|_2^2\n$$\n矩阵 $P \\in \\{0,1\\}^{M \\times N}$ 是一个选择算子，用于在测量位置提取场值。\n\n为了使用基于梯度的优化方法，我们需要计算 $J$ 相对于 $\\chi$ 的梯度。直接计算的成本会非常高，因为它需要对 $\\chi$ 的每个分量都求解一次正演问题。伴随状态法提供了一种高效的替代方案。通过引入伴随场 $\\lambda \\in \\mathbb{C}^N$——它是伴随线性系统的解\n$$\nA(\\chi)^{H}\\, \\lambda \\;=\\; P^{H}\\,\\big(P\\,E(\\chi) \\;-\\; d\\big),\n$$\n梯度向量 $g(\\chi) \\in \\mathbb{R}^N$ 只需额外求解一个线性系统即可计算得出。梯度的分量由下式给出：\n$$\ng_n(\\chi) \\;=\\; k_0^2\\, \\mathrm{Re}\\!\\left\\{ \\overline{\\left(G^{H}\\lambda\\right)_n}\\; E_n(\\chi) \\right\\}\n$$\n该梯度给出了 $J$ 在任意方向 $\\delta\\chi$ 上的方向导数，即 $g(\\chi)^T \\delta\\chi$。\n\n为了验证这个基于伴随状态法的梯度 $g(\\chi)$ 的正确性，我们将其对 $J$ 变化的预测与有限差分近似进行比较。目标函数在点 $\\chi_0$ 沿方向 $\\delta\\chi$ 的泰勒级数展开为：\n$$\nJ(\\chi_0 + \\varepsilon\\,\\delta\\chi) = J(\\chi_0) + \\varepsilon\\, g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon^2)\n$$\n由此，我们可以推导出方向导数的前向差分近似：\n$$\n\\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) - J(\\chi_0)}{\\varepsilon} = g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon)\n$$\n该近似的误差是关于 $\\varepsilon$ 的一阶。测试 $1$ 通过检查将步长 $\\varepsilon$ 减半是否会使误差近似减半来验证这一点，即误差比接近 $0.5$。\n\n一个更精确的近似是中心差分：\n$$\n\\frac{J(\\chi_0 + \\varepsilon\\,\\delta\\chi) - J(\\chi_0 - \\varepsilon\\,\\delta\\chi)}{2\\varepsilon} = g(\\chi_0)^T \\delta\\chi + \\mathcal{O}(\\varepsilon^2)\n$$\n中心差分近似的误差是关于 $\\varepsilon$ 的二阶。测试 $2$ 通过检查对于一个小的 $\\varepsilon$，中心差分近似值是否非常接近基于伴随状态法的方向导数，来验证梯度计算的准确性。测试 $3$ 通过检查将 $\\varepsilon$ 减半是否会使误差减少约 $(\\frac{1}{2})^2 = 0.25$ 的因子，来验证二阶收敛性。\n\n实现将按以下步骤进行：\n1. 设置计算网格并定义物理常数（$L$, $N$, $k_0$）。\n2. 构建离散格林矩阵 $G$ 和入射场向量 $E_{\\mathrm{inc}}$。\n3. 定义真实对比度剖面 $\\chi_{\\mathrm{true}}$，并通过求解 $\\chi_{\\mathrm{true}}$ 的正演问题并选择所需样本来生成合成数据 $d$。\n4. 实现以下函数： a. 求解正演问题 $A(\\chi)E=E_{\\mathrm{inc}}$ 以获得 $E(\\chi)$。 b. 计算目标函数 $J(\\chi)$。 c. 求解伴随问题 $A(\\chi)^H \\lambda = \\text{rhs}$ 并随后计算梯度 $g(\\chi)$。\n5. 通过将有限差分近似与给定的测试对比度 $\\chi_0$ 和扰动方向 $\\delta\\chi$ 的伴随方向导数 $g(\\chi_0)^T \\delta\\chi$ 进行比较，执行三个指定的测试。\n6. 返回三个测试的布尔结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the contrast source inversion gradient verification problem.\n    \"\"\"\n    # 1. Define problem parameters and discretize the domain\n    L = 1.0\n    N = 80\n    k0 = 20.0 * np.pi\n    M = 16\n    \n    # Grid\n    x = np.linspace(0, L, N)\n    dx = L / (N - 1)\n    \n    # Incident field\n    E_inc = np.exp(1j * k0 * x)\n    \n    # Green's function matrix\n    x_m, x_n = np.meshgrid(x, x, indexing='ij')\n    G_mat = dx * (1j / (2 * k0)) * np.exp(1j * k0 * np.abs(x_m - x_n))\n\n    # Selection operator (indices)\n    # Exclude first and last 4 nodes. Select from indices 4 to N-5=75.\n    P_indices = np.round(np.linspace(4, N - 5, M)).astype(int)\n\n    # 2. Generate synthetic data from ground-truth contrast\n    sigma = 0.15 * L\n    chi_true = 0.5 * np.exp(-(x - L/2)**2 / (2 * sigma**2))\n\n    # Helper functions that capture the simulation context (G_mat, k0, E_inc, etc.)\n    def get_total_field(chi: np.ndarray) -> np.ndarray:\n        \"\"\"Solves the forward problem for the total field E(chi).\"\"\"\n        I = np.eye(N, dtype=np.complex128)\n        # V(chi) is diagonal, so G*V(chi) is G_mn * k0^2 * chi_n\n        # This is equivalent to scaling columns of G\n        A_chi = I - G_mat * (k0**2 * chi[None, :])\n        E = np.linalg.solve(A_chi, E_inc)\n        return E\n\n    E_true = get_total_field(chi_true)\n    d = E_true[P_indices]\n\n    # 3. Implement core computational functions\n    def get_objective(chi: np.ndarray) -> float:\n        \"\"\"Computes the data misfit objective J(chi).\"\"\"\n        E_chi = get_total_field(chi)\n        residual = E_chi[P_indices] - d\n        return 0.5 * np.linalg.norm(residual)**2\n\n    def get_gradient(chi: np.ndarray) -> np.ndarray:\n        \"\"\"Computes the adjoint-based gradient g(chi).\"\"\"\n        E_chi = get_total_field(chi)\n        \n        # Adjoint RHS: P^H * (P*E(chi) - d)\n        adj_rhs = np.zeros(N, dtype=np.complex128)\n        residual = E_chi[P_indices] - d\n        adj_rhs[P_indices] = residual\n        \n        # Adjoint matrix: A^H = I - V(chi) * G^H\n        # V is real diagonal, so V^H = V\n        # Product V*G^H corresponds to scaling rows of G^H\n        A_chi_H = np.eye(N, dtype=np.complex128) - (k0**2 * chi[:, None]) * G_mat.conj().T\n        \n        lambda_vec = np.linalg.solve(A_chi_H, adj_rhs)\n        \n        # Gradient formula\n        GH_lambda = G_mat.conj().T @ lambda_vec\n        g = k0**2 * np.real(np.conj(GH_lambda) * E_chi)\n        return g\n\n    results = []\n    \n    # 4. Define test configurations\n    chi0_test1_3 = 0.1 * np.sin(2 * np.pi * x / L)\n    chi0_test2 = np.zeros(N)\n\n    p = N // 3\n    delta_chi_test1 = np.zeros(N)\n    delta_chi_test1[p] = 1.0\n\n    np.random.seed(0)\n    delta_chi_test2_3 = np.random.randn(N)\n    delta_chi_test2_3 /= np.linalg.norm(delta_chi_test2_3)\n\n    eps1 = 1e-3\n    eps2 = 5e-4\n\n    # 5. Execute tests\n    # --- Test 1: Forward-difference first-order scaling ---\n    g0_t1 = get_gradient(chi0_test1_3)\n    AD_t1 = g0_t1 @ delta_chi_test1\n    J0_t1 = get_objective(chi0_test1_3)\n    \n    J_p_eps1 = get_objective(chi0_test1_3 + eps1 * delta_chi_test1)\n    FD1 = (J_p_eps1 - J0_t1) / eps1\n    R1 = np.abs(FD1 - AD_t1)\n\n    J_p_eps2 = get_objective(chi0_test1_3 + eps2 * delta_chi_test1)\n    FD2 = (J_p_eps2 - J0_t1) / eps2\n    R2 = np.abs(FD2 - AD_t1)\n\n    ratio1 = R2 / R1 if R1 != 0 else 0\n    results.append(0.3 = ratio1 = 0.7)\n\n    # --- Test 2: Central-difference consistency at zero contrast ---\n    g0_t2 = get_gradient(chi0_test2)\n    AD_t2 = g0_t2 @ delta_chi_test2_3\n    eps_t2 = 1e-4\n    \n    J_p = get_objective(chi0_test2 + eps_t2 * delta_chi_test2_3)\n    J_m = get_objective(chi0_test2 - eps_t2 * delta_chi_test2_3)\n    CD_t2 = (J_p - J_m) / (2 * eps_t2)\n    C_eps = np.abs(CD_t2 - AD_t2)\n    \n    results.append(C_eps = 1e-6)\n    \n    # --- Test 3: Central-difference second-order scaling ---\n    g0_t3 = get_gradient(chi0_test1_3) # Same chi0 as Test 1\n    AD_t3 = g0_t3 @ delta_chi_test2_3 # Same random delta_chi as Test 2\n    \n    Jp1 = get_objective(chi0_test1_3 + eps1 * delta_chi_test2_3)\n    Jm1 = get_objective(chi0_test1_3 - eps1 * delta_chi_test2_3)\n    CD1 = (Jp1 - Jm1) / (2 * eps1)\n    C1 = np.abs(CD1 - AD_t3)\n    \n    Jp2 = get_objective(chi0_test1_3 + eps2 * delta_chi_test2_3)\n    Jm2 = get_objective(chi0_test1_3 - eps2 * delta_chi_test2_3)\n    CD2 = (Jp2 - Jm2) / (2 * eps2)\n    C2 = np.abs(CD2 - AD_t3)\n\n    ratio3 = C2 / C1 if C1 != 0 else 0\n    results.append(0.2 = ratio3 = 0.3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了前向与伴随模型之后，一个关键的实践问题是如何选择合适的空间离散化网格。这个选择不仅影响计算的精度，也直接关系到求解过程中线性系统的数值稳定性。本练习  旨在通过分析系统矩阵的条件数 $\\kappa$，来研究离散化步长（通常用每个波长内的采样点数来衡量）对问题适定性的影响，从而为设置稳定高效的数值模拟提供理论指导。",
            "id": "3295893",
            "problem": "考虑计算电磁学中 Contrast Source Inversion (CSI) 方法所基于的频域散射问题。在 CSI 中，对比源定义为 $w = \\chi E$，其中 $E$ 是总电场，$\\chi$ 是对比度函数。CSI 中的 $w$-更新源于最小化一个数据失配项，该项与一个状态约束耦合，此状态约束由频域中的 Maxwell 方程出发，通过标量 Helmholtz 模型的 Lippmann–Schwinger 积分方程导出。对于背景波数 $k_0$ 和自由空间 Helmholtz Green 函数 $G$，状态算子涉及 $(I - k_0^2 G)$ 作用于 $w$。\n\n为了分离并分析空间离散化步长对 $w$-更新线性系统条件数的影响，考虑一个一维、周期性的标量 Helmholtz 设置，其定义域长度为 $L$ (单位为米)。假设 $L = N_w \\lambda$，其中 $\\lambda$ 是自由空间波长， $N_w$ 是定义域中包含的波长数量。设离散化步长为 $\\Delta$，则网格点数为 $N = L / \\Delta$。设一维离散化自由空间 Helmholtz Green 函数为循环矩阵 $G \\in \\mathbb{C}^{N \\times N}$，由第一列 $g_j = \\frac{i}{2 k_0} e^{i k_0 r_j}$ 生成，其中 $r_j$ 是沿网格测量的参考点与第 $j$ 个网格点之间的周期性距离， $k_0 = \\frac{2 \\pi}{\\lambda}$， $i$ 是虚数单位。定义 $w$-更新系统矩阵为\n$$\nA = S^\\ast S + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G),\n$$\n其中 $S$ 是数据算子。为了分离状态算子离散化所引入的内在条件数，将 $S$ 取为单位算子，系统简化为\n$$\nA = I + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G).\n$$\n\n从标量 Helmholtz 模型和 Green 函数的定义出发，使用均匀网格上的周期性距离构建 $G$，网格间距为 $\\Delta$ (单位为米)。使用如上定义的算子 $A$，固定一个正常数权重 $\\alpha$ (无量纲)，并计算谱条件数\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别表示 $A$ 的最大和最小奇异值。该条件数是无量纲的。\n\n您的任务是实现一个程序，对于固定的波长 $\\lambda$ (单位为米)、固定的波长数量 $N_w$ 和固定的 $\\alpha$，评估 $\\kappa_2(A)$ 如何随离散化步长 $\\Delta = \\lambda / \\text{Nppw}$ 变化，其中 $\\text{Nppw}$ 表示每波长网格点数。根据计算结果，确定一个关于网格分辨率相对于波长的经验法则（例如，每波长 $\\ge 10$ 个点），该法则能产生一个条件良好的 $w$-更新系统。\n\n您必须使用的基本依据包括：\n- 频域 Maxwell 方程在标准假设下可推导出标量 Helmholtz 方程，进而得到 Lippmann–Schwinger 积分公式。\n- 自由空间一维 Helmholtz Green 函数为 $g(x) = \\frac{i}{2 k_0} e^{i k_0 |x|}$。\n- 在周期性定义域上与 $g$ 进行卷积的均匀网格离散化会产生一个循环矩阵 $G$。\n\n在纯数学和算法层面进行分析，除上述核心定义外，不使用任何经验性简化公式。以数值精确的方式计算 $A$ 的奇异值。所有物理量必须以指定的单位表示。\n\n测试套件使用以下参数：\n- 波长 $\\lambda = 1.0$ 米。\n- 定义域中的波长数量 $N_w = 2$ (无量纲)。\n- 权重 $\\alpha = 1.0$ (无量纲)。\n- 每波长点数值 (无量纲)：$\\text{Nppw} \\in \\{2, 4, 6, 8, 10, 12, 16, 25\\}$。\n\n对于上述集合中的每个 $\\text{Nppw}$ 值，按规定构建 $A$ 并计算 $\\kappa_2(A)$ (无量纲)。您的程序必须输出一行结果，该结果为方括号内以逗号分隔的列表，其中每个条件数四舍五入到六位小数，并与上面列出的 $\\text{Nppw}$ 值顺序对应。例如，输出格式必须与下面完全一样\n$$\n[\\kappa_2(A_{\\text{Nppw}=2}),\\kappa_2(A_{\\text{Nppw}=4}),\\dots,\\kappa_2(A_{\\text{Nppw}=25})],\n$$\n其中每个条目是四舍五入到六位小数的浮点数。",
            "solution": "该问题定义明确，在计算电磁学领域有坚实的科学基础，特别涉及逆散射方法的数值分析。任务是分析在 Contrast Source Inversion (CSI) 方法中出现的系统矩阵的条件数。我们将进行完整的求解。\n\n问题的核心是计算矩阵 $A \\in \\mathbb{C}^{N \\times N}$ 的谱条件数 $\\kappa_2(A)$，该矩阵定义为：\n$$\nA = I + \\alpha (I - k_0^2 G)^\\ast (I - k_0^2 G)\n$$\n其中 $I$ 是 $N \\times N$ 单位矩阵，$\\alpha$ 是一个正常数无量纲权重，$k_0$ 是背景波数，$G$ 是离散化的 Green 函数矩阵，$(\\cdot)^\\ast$ 表示共轭转置。条件数定义为最大奇异值与最小奇异值之比，即 $\\kappa_2(A) = \\sigma_{\\max}(A) / \\sigma_{\\min}(A)$。\n\n首先，我们分析矩阵 $A$ 的性质。令 $B = I - k_0^2 G$。矩阵 $A$ 可以写为 $A = I + \\alpha B^\\ast B$。矩阵 $B^\\ast B$ 是 Hermitian 矩阵且是半正定的。它的特征值是实数且非负。$A$ 的特征值因此具有 $1 + \\alpha \\lambda_i(B^\\ast B)$ 的形式，其中 $\\lambda_i(B^\\ast B)$ 是 $B^\\ast B$ 的特征值。由于 $\\alpha  0$ 且 $\\lambda_i(B^\\ast B) \\ge 0$， $A$ 的所有特征值都是实数且大于等于 1。这意味着 $A$ 是一个 Hermitian 正定矩阵。对于 Hermitian 矩阵，奇异值是其特征值的绝对值。由于 $A$ 的特征值是正数，它的奇异值与特征值相同。因此，条件数是最大特征值与最小特征值之比：\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\n$$\n这将问题简化为求解 $A$ 的特征值。虽然我们可以显式地构造矩阵 $A$ 并数值计算其特征值，但利用 Green 函数矩阵 $G$ 的结构，存在一种更高效、更简洁的解法。\n\n问题陈述了定义域是一维且周期性的，离散化网格是均匀的。数值分析的一个关键原则是，在均匀周期性网格上对卷积算子进行离散化会得到一个循环矩阵。矩阵 $G$ 就代表了这样一个算子。一个循环矩阵完全由其第一列决定，设为 $c = (c_0, c_1, \\dots, c_{N-1})^T$，其形式如下：\n$$\nC = \\begin{pmatrix}\nc_0  c_{N-1}  \\dots  c_1 \\\\\nc_1  c_0  \\dots  c_2 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nc_{N-1}  c_{N-2}  \\dots  c_0\n\\end{pmatrix}\n$$\n循环矩阵有一个基本性质：它们可以被离散傅里叶变换 (Discrete Fourier Transform, DFT) 矩阵对角化。循环矩阵 $C$ 的特征值由其第一列 $c$ 的 DFT 给出。也就是说，如果 $\\hat{c} = \\text{DFT}(c)$，那么 $C$ 的特征值就是向量 $\\hat{c}$ 的分量。\n\n我们可以应用这个性质来求解 $A$ 的特征值，而无需组装完整的矩阵。\n1. Green 函数矩阵 $G$ 是循环矩阵。其特征值记为 $\\lambda_k(G)$，是其第一列 $g$ 的 DFT。设 $\\hat{g} = \\text{DFT}(g)$。那么，对于 $k = 0, \\dots, N-1$，有 $\\lambda_k(G) = \\hat{g}_k$。\n\n2. 矩阵 $B = I - k_0^2 G$ 是两个循环矩阵的线性组合（$I$ 是循环矩阵，其第一列为 $(1, 0, \\dots, 0)^T$）。结果也是一个循环矩阵。因此，其特征值为 $\\lambda_k(B) = 1 - k_0^2 \\lambda_k(G) = 1 - k_0^2 \\hat{g}_k$。\n\n3. 循环矩阵的共轭转置 $B^\\ast$ 也是循环矩阵。两个循环矩阵的乘积 $B^\\ast B$ 是可交换的，并且结果也是一个循环矩阵。可被同时对角化的矩阵（如此处的情况）乘积的特征值是它们各自特征值的乘积。$B^\\ast$ 的特征值是 $B$ 的特征值的复共轭，即 $\\overline{\\lambda_k(B)}$。因此，$B^\\ast B$ 的特征值为 $\\lambda_k(B^\\ast B) = \\lambda_k(B^\\ast) \\lambda_k(B) = \\overline{\\lambda_k(B)} \\lambda_k(B) = |\\lambda_k(B)|^2$。\n\n4. 最后，矩阵 $A = I + \\alpha B^\\ast B$ 也是循环矩阵。其特征值为 $\\lambda_k(A) = 1 + \\alpha \\lambda_k(B^\\ast B) = 1 + \\alpha |\\lambda_k(B)|^2$。\n\n综合这些结果，我们得到计算 $A$ 的特征值的直接公式：\n$$\n\\lambda_k(A) = 1 + \\alpha |1 - k_0^2 \\hat{g}_k|^2, \\quad k = 0, \\dots, N-1\n$$\n其中 $\\hat{g}_k$ 是 $G$ 的第一列的 DFT 的分量。\n\n对于每个指定的 $\\text{Nppw}$ 值，计算算法如下：\n1. 根据问题给定的条件定义物理和数值参数：\n    - 波长：$\\lambda = 1.0$ 米。\n    - 定义域中的波长数量：$N_w = 2$。\n    - 权重：$\\alpha = 1.0$。\n    - 波数：$k_0 = 2\\pi / \\lambda = 2\\pi$ rad/m。\n    - 离散化步长：$\\Delta = \\lambda / \\text{Nppw}$。\n    - 定义域长度：$L = N_w \\lambda = 2.0$ 米。\n    - 网格点数：$N = L / \\Delta = N_w \\times \\text{Nppw}$。\n\n2. 构建 Green 函数矩阵 $G$ 的第一列 $g$。第 $j$ 个元素由 $g_j = \\frac{i}{2 k_0} e^{i k_0 r_j}$ 给出，其中 $r_j$ 是网格上从原点到点 $j$ 的周期性距离。对于一个长度为 $L=N\\Delta$、包含 $N$ 个点、间距为 $\\Delta$ 的网格，这个距离对于 $j = 0, 1, \\dots, N-1$ 是 $r_j = \\min(j\\Delta, L - j\\Delta)$。\n\n3. 计算向量 $g$ 的 DFT 以求得 $G$ 的特征值：$\\hat{g} = \\text{DFT}(g)$。\n\n4. 使用推导出的公式计算 $A$ 的特征值：$\\lambda_k(A) = 1.0 + 1.0 \\times |1.0 - (2\\pi)^2 \\hat{g}_k|^2$。\n\n5. 在特征值集合 $\\{\\lambda_k(A)\\}$ 中找到最大值和最小值。\n\n6. 计算条件数 $\\kappa_2(A) = \\lambda_{\\max}(A) / \\lambda_{\\min}(A)$。\n\n这个过程在数值上是高效且准确的，因为它避免了构建大型 $N \\times N$ 矩阵，并利用了快速傅里叶变换 (Fast Fourier Transform, FFT) 算法。\n\n根据计算结果，可以推断出一个经验法则。每波长点数较少（例如 $\\text{Nppw}=2$）会违反波动现象的奈奎斯特采样定理，预计会导致非常高的条件数，表明系统是病态的。随着 $\\text{Nppw}$ 的增加，离散化变得更精细，能更准确地表示连续算子，这通常会改善矩阵 $A$ 的条件数。计算电磁学中一个常见的指导准则是，为获得可接受的精度，每波长至少使用 10 个点。对 $\\kappa_2(A)$ 的分析将表明这个准则对于此 CSI 公式是否也能得到一个条件良好的系统矩阵。我们预计随着 $\\text{Nppw}$ 的增长，$\\kappa_2(A)$ 会减小并趋于稳定。",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Computes the spectral condition number of the CSI w-update matrix\n    for a 1D periodic scalar Helmholtz problem.\n    \"\"\"\n\n    # --- Test Suite Parameters ---\n    lambda_ = 1.0  # Wavelength in meters\n    n_w = 2.0      # Number of wavelengths in domain\n    alpha = 1.0    # Regularization weight\n    nppw_values = [2, 4, 6, 8, 10, 12, 16, 25]\n\n    results = []\n\n    for nppw in nppw_values:\n        # --- 1. Calculate physical and numerical parameters ---\n        # Background wavenumber (rad/m)\n        k0 = 2.0 * np.pi / lambda_\n        \n        # Discretization step (m)\n        delta = lambda_ / nppw\n        \n        # Domain length (m)\n        L = n_w * lambda_\n        \n        # Number of grid points (N = n_w * nppw, an integer)\n        N = int(n_w * nppw)\n\n        # --- 2. Construct the first column of the Green's function matrix G ---\n        # The first column g corresponds to the Green's function evaluated\n        # at distances from the source at the origin (j=0) to all other points j.\n        \n        # Create an array of grid indices\n        j_indices = np.arange(N)\n        \n        # Calculate the periodic distance r_j = min(j*delta, L - j*delta) for each grid point\n        r_distances = np.minimum(j_indices * delta, L - j_indices * delta)\n        \n        # The problem defines the discrete Green's function generating vector as:\n        # g_j = (i / 2*k0) * exp(i*k0*r_j).\n        # This formula is used directly.\n        g_col = (1j / (2.0 * k0)) * np.exp(1j * k0 * r_distances)\n\n        # --- 3. Compute eigenvalues of G using FFT ---\n        # The eigenvalues of a circulant matrix are the DFT of its first column.\n        eig_G = scipy.fft.fft(g_col)\n\n        # --- 4. Compute eigenvalues of A using the derived formula ---\n        # The eigenvalues of A = I + alpha * (I - k0^2*G)' * (I - k0^2*G) can be\n        # calculated directly from the eigenvalues of G.\n        # Let B = I - k0^2*G. eig(B) = 1 - k0^2 * eig(G).\n        # Since A is HPD and circulant, its eigenvalues are:\n        # eig(A) = 1 + alpha * |eig(B)|^2\n        eig_A = 1.0 + alpha * np.abs(1.0 - k0**2 * eig_G)**2\n\n        # --- 5. Compute the spectral condition number ---\n        # For a Hermitian Positive Definite matrix, the condition number is the\n        # ratio of the largest to the smallest eigenvalue.\n        kappa = np.max(eig_A) / np.min(eig_A)\n        \n        results.append(kappa)\n\n    # Format the results for output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Print the final result in the exact specified format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}