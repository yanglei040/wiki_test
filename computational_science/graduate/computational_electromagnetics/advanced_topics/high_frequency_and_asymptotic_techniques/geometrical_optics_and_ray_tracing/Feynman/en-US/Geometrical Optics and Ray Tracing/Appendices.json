{
    "hands_on_practices": [
        {
            "introduction": "The ray-transfer matrix method, often called the ABCD matrix formalism, is a cornerstone for analyzing optical systems within the paraxial approximation. This first exercise  grounds this powerful computational tool in first principles, guiding you to construct the fundamental matrices for refraction and translation directly from Snell's law. By cascading these matrices to model a realistic multi-element system, you will gain practical skills in analyzing compound lenses and determining key system properties such as the back focal distance.",
            "id": "3311406",
            "problem": "A rotationally symmetric imaging system consists of a thick biconvex singlet lens in air followed by an air gap and then a plane-parallel window, all coaxial. Let the optical axis be the $z$-axis pointing to the right, and let the ray height $y$ be measured transverse to the axis with the paraxial angle $u$ defined by $u \\equiv dy/dz$ (in radians). Adopt the sign convention that a spherical surface has positive radius $R$ if its center of curvature lies to the right of the surface vertex.\n\nThe lens has refractive index $n_{\\ell} = 1.5168$ and central thickness $t = 8\\,\\mathrm{mm}$. Its first surface (air to glass) has radius $R_1 = +50\\,\\mathrm{mm}$ and its second surface (glass to air) has radius $R_2 = -50\\,\\mathrm{mm}$. Immediately after the lens there is an air gap of length $g = 20\\,\\mathrm{mm}$. After the air gap, there is a plane-parallel window of thickness $w = 2\\,\\mathrm{mm}$ and refractive index $n_{w} = 1.5$, surrounded by air on both sides. All media not otherwise specified are air of refractive index $n_0 = 1$.\n\nUsing the paraxial approximation as it arises from first principles, construct the appropriate $2\\times 2$ ray-transfer matrices for translation and refraction at spherical and planar interfaces starting from Snell’s law and the small-angle geometry of a spherical surface. Cascade these matrices in the order of propagation to obtain the overall first-order system matrix from a reference input plane just before the first lens surface to an output plane just after the exit face of the window.\n\nAssuming a collimated input beam (object at infinity) incident on the system, determine the back focal distance $L$ measured from the exit face of the window (i.e., the axial distance in air from the exit face of the window to the paraxial focal point). Round your final numerical result to four significant figures. Express your answer in $\\mathrm{mm}$.",
            "solution": "The user-provided problem is evaluated for validity.\n\n**Step 1: Extract Givens**\n- **System Configuration**: A rotationally symmetric imaging system comprising a thick biconvex singlet lens, an air gap, and a plane-parallel window, all coaxial.\n- **Coordinate System**: The optical axis is the $z$-axis, pointing to the right. Ray height is $y$. Paraxial angle is $u \\equiv dy/dz$.\n- **Sign Convention**: A spherical surface has a positive radius $R$ if its center of curvature is to the right of its vertex.\n- **Lens Parameters**:\n  - Refractive index: $n_{\\ell} = 1.5168$\n  - Central thickness: $t = 8\\,\\mathrm{mm}$\n  - First surface radius (air to glass): $R_1 = +50\\,\\mathrm{mm}$\n  - Second surface radius (glass to air): $R_2 = -50\\,\\mathrm{mm}$\n- **Air Gap**: Length $g = 20\\,\\mathrm{mm}$\n- **Window Parameters**:\n  - Thickness: $w = 2\\,\\mathrm{mm}$\n  - Refractive index: $n_{w} = 1.5$\n  - Geometry: Plane-parallel\n- **Ambient Medium**: Air, with refractive index $n_0 = 1$.\n- **Task**:\n  1.  Derive the $2\\times 2$ ray-transfer matrices for translation and refraction from first principles.\n  2.  Form the overall system matrix from a plane just before the first lens surface to a plane just after the exit face of the window.\n  3.  For a collimated input beam, determine the back focal distance $L$, measured from the window's exit face.\n  4.  Provide a final numerical answer in $\\mathrm{mm}$, rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is a standard exercise in paraxial geometrical optics using the ray-transfer matrix method. The underlying principles (Snell's law in the small-angle approximation) are fundamental and well-established. The provided physical parameters (refractive indices, dimensions) are realistic for common optical components.\n- **Well-Posed**: The problem is well-posed. All necessary parameters are specified, the objective is clearly defined, and the system allows for a unique, stable solution.\n- **Objective**: The problem statement is quantitative and free from subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a complete, consistent, and scientifically sound problem in computational electromagnetics, specifically within the domain of geometrical optics and ray tracing. The solution process may proceed.\n\n**Solution Derivation**\n\nThe problem will be solved using the standard ray-transfer matrix method, which relates the position $y$ and the optical direction cosine $\\nu = n u$ of a ray at two different planes. The state of a paraxial ray is described by the vector $\\begin{pmatrix} y \\\\ \\nu \\end{pmatrix}$. The transformation of this vector as it propagates through an optical system is described by a $2\\times 2$ matrix, commonly called an ABCD matrix.\n\nFirst, we derive the matrices for refraction and translation from first principles as requested.\n\n**1. Refraction Matrix**\nConsider a spherical interface with radius of curvature $R$ separating two media with refractive indices $n_1$ and $n_2$. A ray with height $y_1$ and angle $u_1$ is incident from the left. After refraction, its height is $y_2$ and angle is $u_2$.\nAt the point of incidence, the height is unchanged: $y_2 = y_1$.\nThe paraxial form of Snell's law is $n_1 i_1 = n_2 i_2$, where $i_1$ and $i_2$ are the angles of incidence and refraction with respect to the surface normal. Let $\\phi$ be the angle the surface normal makes with the optical axis. For a ray at height $y$ on a sphere of radius $R$, $\\phi \\approx y/R$. From the geometry of the angles, we have $i_1 = u_1 + \\phi$ and $i_2 = u_2 + \\phi$.\nSubstituting these into Snell's law:\n$n_1(u_1 + \\phi) = n_2(u_2 + \\phi)$\n$n_1 u_1 + n_1 (y_1/R) = n_2 u_2 + n_2 (y_1/R)$\nRearranging for $n_2 u_2$:\n$n_2 u_2 = n_1 u_1 + \\frac{n_1 - n_2}{R} y_1$\nThis is the second equation for our transformation. We define the optical direction cosines $\\nu_1 = n_1 u_1$ and $\\nu_2 = n_2 u_2$. The two equations are:\n$y_2 = y_1$\n$\\nu_2 = \\nu_1 + \\frac{n_1 - n_2}{R} y_1$\nThis can be written in matrix form:\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ \\frac{n_1 - n_2}{R}  1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\nThe quantity $P = \\frac{n_2 - n_1}{R}$ is the optical power of the surface. The refraction matrix is $\\mathcal{R} = \\begin{pmatrix} 1  0 \\\\ -P  1 \\end{pmatrix}$.\n\n**2. Translation Matrix**\nConsider a ray translating a distance $d$ along the optical axis within a homogeneous medium of refractive index $n$. The initial state is $(y_1, u_1)$ and the final state is $(y_2, u_2)$.\nThe angle of the ray does not change, so $u_2 = u_1$. Consequently, $\\nu_2 = n u_2 = n u_1 = \\nu_1$.\nThe height changes according to $y_2 = y_1 + d \\tan(u_1)$. In the paraxial approximation, $\\tan(u_1) \\approx u_1$.\nSo, $y_2 = y_1 + d u_1$. Since $u_1 = \\nu_1/n$, we have $y_2 = y_1 + \\frac{d}{n} \\nu_1$.\nThe two equations are:\n$y_2 = y_1 + \\frac{d}{n} \\nu_1$\n$\\nu_2 = \\nu_1$\nIn matrix form:\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1  d/n \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\nThe translation matrix is $\\mathcal{T}(d, n) = \\begin{pmatrix} 1  d/n \\\\ 0  1 \\end{pmatrix}$.\n\n**3. System Matrix Construction**\nThe total system matrix $M_{sys}$ is the product of the individual matrices for each optical element, multiplied in reverse order of propagation. The system consists of the lens, an air gap, and a window.\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\n$M_{sys} = (\\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1}) \\cdot \\mathcal{T}_g \\cdot (\\mathcal{R}_2\\mathcal{T}_{\\ell}\\mathcal{R}_1)$\n\nThe parameters are: $n_0=1$, $n_{\\ell}=1.5168$, $n_w=1.5$, $R_1=50\\,\\mathrm{mm}$, $R_2=-50\\,\\mathrm{mm}$, $t=8\\,\\mathrm{mm}$, $g=20\\,\\mathrm{mm}$, $w=2\\,\\mathrm{mm}$.\n\n**Lens Matrix ($M_{lens}$):**\n- Refraction $\\mathcal{R}_1$ (air to lens): $n_1=n_0=1$, $n_2=n_{\\ell}$, $R=R_1$. Power $P_1 = \\frac{n_{\\ell} - n_0}{R_1} = \\frac{1.5168 - 1}{50} = 0.010336\\,\\mathrm{mm}^{-1}$.\n  $\\mathcal{R}_1 = \\begin{pmatrix} 1  0 \\\\ -P_1  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ -0.010336  1 \\end{pmatrix}$.\n- Translation $\\mathcal{T}_{\\ell}$ (through lens): $d=t=8\\,\\mathrm{mm}$, $n=n_{\\ell}$.\n  $\\mathcal{T}_{\\ell} = \\begin{pmatrix} 1  t/n_{\\ell} \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  8/1.5168 \\\\ 0  1 \\end{pmatrix}$.\n- Refraction $\\mathcal{R}_2$ (lens to air): $n_1=n_{\\ell}$, $n_2=n_0=1$, $R=R_2$. Power $P_2 = \\frac{n_0 - n_{\\ell}}{R_2} = \\frac{1 - 1.5168}{-50} = 0.010336\\,\\mathrm{mm}^{-1}$.\n  $\\mathcal{R}_2 = \\begin{pmatrix} 1  0 \\\\ -P_2  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ -0.010336  1 \\end{pmatrix}$.\n\n$M_{lens} = \\mathcal{R}_2 \\mathcal{T}_{\\ell} \\mathcal{R}_1 = \\begin{pmatrix} 1  0 \\\\ -P_2  1 \\end{pmatrix} \\begin{pmatrix} 1  t/n_{\\ell} \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ -P_1  1 \\end{pmatrix}$\n$M_{lens} = \\begin{pmatrix} 1 - P_1(t/n_{\\ell})  t/n_{\\ell} \\\\ -(P_1+P_2) + P_1 P_2 (t/n_{\\ell})  1 - P_2(t/n_{\\ell}) \\end{pmatrix}$\nLet $P_1=P_2=P=0.010336\\,\\mathrm{mm}^{-1}$ and $t/n_{\\ell} \\approx 5.27426\\,\\mathrm{mm}$.\n$A_L = D_L = 1 - (0.010336)(5.27426) = 1 - 0.054512 = 0.945488$\n$B_L = 5.27426\\,\\mathrm{mm}$\n$C_L = -2P + P^2(t/n_{\\ell}) = -2(0.010336) + (0.010336)^2(5.27426) = -0.020672 + 0.000563 = -0.020109\\,\\mathrm{mm}^{-1}$\n$M_{lens} = \\begin{pmatrix} 0.945488  5.27426 \\\\ -0.020109  0.945488 \\end{pmatrix}$\n\n**Air Gap Matrix ($M_{gap}$):**\n- Translation $\\mathcal{T}_g$ through air: $d=g=20\\,\\mathrm{mm}$, $n=n_0=1$.\n$M_{gap} = \\mathcal{T}_g = \\begin{pmatrix} 1  g/n_0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix}$.\n\n**Window Matrix ($M_{window}$):**\n- For a plane-parallel plate ($R_1, R_2 \\to \\infty$) of thickness $w$ and index $n_w$ in air, the powers of the surfaces are zero. The matrix is:\n$M_{window} = \\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  w/n_w \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  w/n_w \\\\ 0  1 \\end{pmatrix}$\n$w/n_w = 2/1.5 = 4/3\\,\\mathrm{mm}$.\n$M_{window} = \\begin{pmatrix} 1  4/3 \\\\ 0  1 \\end{pmatrix}$.\n\n**Total System Matrix ($M_{sys}$):**\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\nFirst, we compute $M' = M_{gap} \\cdot M_{lens}$:\n$M' = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 0.945488  5.27426 \\\\ -0.020109  0.945488 \\end{pmatrix} = \\begin{pmatrix} A_L+g C_L  B_L+g D_L \\\\ C_L  D_L \\end{pmatrix}$\n$A' = 0.945488 + 20(-0.020109) = 0.945488 - 0.40218 = 0.543308$\n$B' = 5.27426 + 20(0.945488) = 5.27426 + 18.90976 = 24.18402$\n$C' = -0.020109$\n$D' = 0.945488$\n$M' = \\begin{pmatrix} 0.543308  24.18402 \\\\ -0.020109  0.945488 \\end{pmatrix}$\n\nNow, we compute $M_{sys} = M_{window} \\cdot M'$:\n$M_{sys} = \\begin{pmatrix} 1  4/3 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 0.543308  24.18402 \\\\ -0.020109  0.945488 \\end{pmatrix} = \\begin{pmatrix} A' + (4/3)C'  B' + (4/3)D' \\\\ C'  D' \\end{pmatrix}$\n$A_{sys} = 0.543308 + (4/3)(-0.020109) = 0.543308 - 0.026812 = 0.516496$\n$B_{sys} = 24.18402 + (4/3)(0.945488) = 24.18402 + 1.260651 = 25.444671$\n$C_{sys} = -0.020109$\n$D_{sys} = 0.945488$\n\nThe final system matrix is $M_{sys} = \\begin{pmatrix} 0.516496  25.444671 \\\\ -0.020109  0.945488 \\end{pmatrix} = \\begin{pmatrix} A  B \\\\ C  D \\end{pmatrix}$.\n\n**4. Back Focal Distance Calculation**\nA collimated input beam consists of rays parallel to the optical axis, so $u_{in} = 0$, which means $\\nu_{in} = n_0 u_{in} = 0$. The input ray vector at the front of the lens is $\\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix}$.\nThe output ray vector at the back of the window is given by:\n$$ \\begin{pmatrix} y_{out} \\\\ \\nu_{out} \\end{pmatrix} = M_{sys} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A  B \\\\ C  D \\end{pmatrix} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A y_{in} \\\\ C y_{in} \\end{pmatrix} $$\nSo, at the exit plane of the window, the ray has height $y_{out} = A y_{in}$ and optical direction cosine $\\nu_{out} = C y_{in}$.\nThe medium after the window is air ($n_{out}=1$), so the ray angle is $u_{out} = \\nu_{out}/n_{out} = \\nu_{out} = C y_{in}$.\nThe back focal point is the point where this ray intersects the optical axis ($y=0$). Let $L$ be the distance from the exit face of the window to this point. The equation for the ray path after the window is $y(z) = y_{out} + z u_{out}$. The focal point is at $z=L$ where $y(L)=0$.\n$0 = y_{out} + L u_{out}$\n$L = - \\frac{y_{out}}{u_{out}} = - \\frac{A y_{in}}{C y_{in}} = - \\frac{A}{C}$\nUsing the calculated values for $A$ and $C$ of the system matrix:\n$L = - \\frac{0.516496}{-0.020109} \\approx 25.6865\\,\\mathrm{mm}$\n\nThe problem asks for the result rounded to four significant figures.\n$L \\approx 25.69\\,\\mathrm{mm}$.",
            "answer": "$$\n\\boxed{25.69}\n$$"
        },
        {
            "introduction": "While ABCD matrices are invaluable for paraxial systems, many modern applications in areas like fiber optics and medical imaging involve continuously varying refractive indices where rays follow curved paths. The most elegant and robust framework for these general scenarios is Hamiltonian mechanics. This practice  delves into the numerical solution of Hamilton's equations for rays in a graded-index (GRIN) lens, challenging you to compare a standard numerical integrator against a symplectic method specifically designed to conserve the system's geometric structure and energy—a crucial aspect for ensuring long-term simulation fidelity.",
            "id": "3311401",
            "problem": "You are to implement and compare two numerical integrators for geometrical-optics ray propagation in an inhomogeneous, isotropic medium with a rapidly varying refractive index, focusing on both energy conservation and travel-time accuracy. The comparison is to be performed on a graded-index (GRIN) lens model with strong gradients. The task is framed in purely mathematical terms based on Hamiltonian ray dynamics derived from Fermat’s principle and the eikonal approximation, and the final answer must be a complete, runnable program as specified.\n\nBegin from the following fundamentals:\n\n- Rays in an inhomogeneous, isotropic, stationary medium of refractive index $n(\\mathbf{x})$ follow from Fermat’s principle and the eikonal approximation, which admit a Hamiltonian formulation with canonical position $\\mathbf{x} \\in \\mathbb{R}^2$, canonical momentum $\\mathbf{p} \\in \\mathbb{R}^2$, and Hamiltonian\n$$\nH(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2}\\left(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x})\\right).\n$$\n- The corresponding canonical equations are\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\tfrac{1}{2}\\nabla n^2(\\mathbf{x}),\n$$\nwhere $\\tau$ is a path parameter with units of meters such that the optical travel time $T$ satisfies\n$$\nT = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) \\, d\\tau,\n$$\nwith $c_0$ being the vacuum speed of light.\n\nConsider a two-dimensional GRIN lens with profile\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2,\n$$\nwhere $n_0 \\gt 0$ is constant and $\\alpha \\gt 0$ has units of inverse square meters. This medium is strongly inhomogeneous for large $\\alpha$, leading to stiff ray dynamics. The canonical equations become\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\, \\mathbf{x}.\n$$\n\nTasks:\n\n1. Implement two time-stepping schemes for the Hamiltonian system above:\n   - A classical explicit Runge–Kutta method of order 4 applied to the first-order system for $(\\mathbf{x}, \\mathbf{p})$.\n   - A second-order symplectic splitting (Störmer–Verlet) method applied to the separable Hamiltonian $H(\\mathbf{x},\\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$ with $T(\\mathbf{p}) = \\tfrac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ and $V(\\mathbf{x}) = -\\tfrac{1}{2} n^2(\\mathbf{x})$.\n\n2. For each integrator and each test case below, propagate a ray over exactly one full oscillation period in $\\tau$ (i.e., for a total parameter length $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$), using a fixed nominal step size $h$ but shortening the final step to land exactly at $\\tau_{\\text{end}}$.\n\n3. Use initial conditions constructed to satisfy the geometric-optics constraint $H=0$ at $\\tau = 0$:\n   - Let $r_c = \\tfrac{n_0}{\\sqrt{\\alpha}}$.\n   - Let $A = \\rho \\, r_c$ with $\\rho = 0.6$, and choose $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$.\n   - Choose $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$, which ensures $H(\\mathbf{x}(0),\\mathbf{p}(0)) = 0$.\n\n4. For each integrator and test case, evaluate:\n   - The maximum absolute Hamiltonian drift over the trajectory,\n     $$\n     \\Delta H_{\\max} = \\max_{k}\\left|H(\\mathbf{x}_k,\\mathbf{p}_k) - H(\\mathbf{x}_0,\\mathbf{p}_0)\\right|.\n     $$\n     Report this as a dimensionless float.\n   - The absolute travel-time error,\n     $$\n     \\left|T_{\\text{num}} - T_{\\text{exact}}\\right|,\n     $$\n     where $T_{\\text{num}}$ is computed by the trapezoidal rule applied to $\\tfrac{1}{c_0}\\int_0^{\\tau_{\\text{end}}} n^2(\\mathbf{x}(\\tau)) \\, d\\tau$, and $T_{\\text{exact}}$ is the analytic value for one full period in this GRIN medium derived from the fundamentals above. Express this error in seconds as a float.\n\n5. Use the constants $n_0 = 1.6$ (dimensionless) and $c_0 = 299792458$ (in meters per second). All positions are in meters, $\\alpha$ is in inverse square meters, and $\\tau$ is in meters.\n\n6. Test Suite. For each pair $(\\alpha, h)$ below, run both integrators and compute the two metrics described. The period is $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$ in meters.\n   - Case 1: $\\alpha = 400$, $h = 0.05$.\n   - Case 2: $\\alpha = 2500$, $h = 0.039$.\n   - Case 3: $\\alpha = 25$, $h = 0.3$.\n   - Case 4: $\\alpha = 10000$, $h = 0.015$.\n\n7. Output format. Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets. Each test case should contribute a list of four floats in the order\n   $[\\Delta H_{\\max}^{\\mathrm{RK4}}, \\, \\left|T_{\\text{num}}^{\\mathrm{RK4}} - T_{\\text{exact}}\\right|, \\, \\Delta H_{\\max}^{\\mathrm{SV}}, \\, \\left|T_{\\text{num}}^{\\mathrm{SV}} - T_{\\text{exact}}\\right|]$,\n   where superscripts indicate the integrator used. The travel-time error must be in seconds, and the Hamiltonian drift is dimensionless. The final output should look like\n   $[\\,[a_1, b_1, c_1, d_1],[a_2, b_2, c_2, d_2],[a_3, b_3, c_3, d_3],[a_4, b_4, c_4, d_4]\\,]$,\n   with each $a_i$, $b_i$, $c_i$, $d_i$ being Python-format floats.\n\nAll angles, if any arise in your derivations, must be in radians. All travel-time values and errors must be expressed in seconds. No percentage signs are permitted; use decimals for any fractional quantities.",
            "solution": "The problem is valid as it is scientifically grounded in Hamiltonian mechanics and geometrical optics, well-posed as a standard initial value problem, and self-contained with all necessary constants, initial conditions, and procedures fully specified.\n\nThe problem requires the implementation and comparison of two numerical integrators for simulating ray propagation in a two-dimensional graded-index (GRIN) medium. The comparison focuses on the conservation of a system invariant (the Hamiltonian) and the accuracy of a path-integrated quantity (the optical travel time).\n\nThe governing physics is described by Hamiltonian ray dynamics. For a medium with refractive index $n(\\mathbf{x})$, the canonical equations for the ray position $\\mathbf{x}(\\tau) \\in \\mathbb{R}^2$ and momentum $\\mathbf{p}(\\tau) \\in \\mathbb{R}^2$ are derived from the Hamiltonian $H(\\mathbf{x},\\mathbf{p}) = \\frac{1}{2}(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x}))$. The equations of motion are:\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}\n$$\n$$\n\\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\frac{1}{2}\\nabla n^2(\\mathbf{x})\n$$\nHere, $\\tau$ is a path parameter. For physical rays, the Hamiltonian is a constant of motion, and its value is constrained to be zero, i.e., $H(\\mathbf{x}(\\tau), \\mathbf{p}(\\tau)) = 0$ for all $\\tau$. This implies that along the ray path, the magnitude of the ray momentum vector equals the local refractive index: $\\lVert\\mathbf{p}(\\tau)\\rVert = n(\\mathbf{x}(\\tau))$.\n\nThe specific medium is a GRIN lens with a parabolic profile:\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2\n$$\nwhere $n_0$ and $\\alpha$ are positive constants. For this profile, the gradient term is $\\frac{1}{2}\\nabla n^2(\\mathbf{x}) = \\frac{1}{2}\\nabla(n_0^2 - \\alpha(x^2+y^2)) = -\\alpha\\mathbf{x}$. The system of ordinary differential equations (ODEs) becomes:\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\mathbf{x}\n$$\nThis is equivalent to the second-order system $\\frac{d^2\\mathbf{x}}{d\\tau^2} + \\alpha\\mathbf{x} = 0$, which describes a simple harmonic oscillator with angular frequency $\\omega = \\sqrt{\\alpha}$.\n\nBefore implementing numerical solvers, we derive the exact analytical solution and the exact travel time $T_{\\text{exact}}$, which serves as the benchmark for accuracy. The initial conditions are specified as $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$ and $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$, with $A = \\rho r_c = \\rho n_0 / \\sqrt{\\alpha}$ and $\\rho = 0.6$. Substituting these values simplifies the initial momentum to $\\mathbf{p}(0)=[0, 0.8 n_0]^{\\mathsf{T}}$. The general solution to the harmonic oscillator equation is $\\mathbf{x}(\\tau) = \\mathbf{C}_1 \\cos(\\sqrt{\\alpha}\\tau) + \\mathbf{C}_2 \\sin(\\sqrt{\\alpha}\\tau)$. Applying the initial conditions yields the exact trajectory:\n$$\n\\mathbf{x}(\\tau) = \\begin{bmatrix} A \\cos(\\sqrt{\\alpha}\\tau) \\\\ \\frac{\\sqrt{n_0^2 - \\alpha A^2}}{\\sqrt{\\alpha}} \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix} = \\begin{bmatrix} (0.6 n_0 / \\sqrt{\\alpha}) \\cos(\\sqrt{\\alpha}\\tau) \\\\ (0.8 n_0 / \\sqrt{\\alpha}) \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix}\n$$\nThe period of oscillation in the parameter $\\tau$ is $\\tau_p = 2\\pi/\\sqrt{\\alpha}$. The problem requires integration over exactly this period, so $\\tau_{\\text{end}} = 2\\pi/\\sqrt{\\alpha}$.\n\nThe optical travel time $T$ is given by $T = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) d\\tau$. Since $H=0$ along the true path, we have $n^2(\\mathbf{x}(\\tau)) = \\lVert\\mathbf{p}(\\tau)\\rVert^2$. We can compute $\\mathbf{p}(\\tau) = \\frac{d\\mathbf{x}}{d\\tau}$ and integrate its squared norm, but a more elegant derivation for the exact travel time $T_{\\text{exact}}$ over one period is as follows:\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\int_{0}^{\\tau_{\\text{end}}} \\left( n_0^2 - \\alpha \\lVert \\mathbf{x}(\\tau) \\rVert^2 \\right) d\\tau\n$$\nWe need to evaluate the integral of $\\lVert \\mathbf{x}(\\tau) \\rVert^2$:\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\int_{0}^{2\\pi/\\sqrt{\\alpha}} \\left( A^2 \\cos^2(\\sqrt{\\alpha}\\tau) + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\sin^2(\\sqrt{\\alpha}\\tau) \\right) d\\tau\n$$\nUsing the definite integrals $\\int_0^{2\\pi} \\cos^2\\theta d\\theta = \\pi$ and $\\int_0^{2\\pi} \\sin^2\\theta d\\theta = \\pi$, with the substitution $\\theta = \\sqrt{\\alpha}\\tau$, we find:\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\frac{1}{\\sqrt{\\alpha}} \\left( A^2 \\pi + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\pi \\right) = \\frac{\\pi}{\\alpha\\sqrt{\\alpha}} \\left( \\alpha A^2 + n_0^2 - \\alpha A^2 \\right) = \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}}\n$$\nSubstituting this back into the expression for $T_{\\text{exact}}$:\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\left( n_0^2 \\tau_{\\text{end}} - \\alpha \\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau \\right) = \\frac{1}{c_0} \\left( n_0^2 \\frac{2\\pi}{\\sqrt{\\alpha}} - \\alpha \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}} \\right) = \\frac{n_0^2 \\pi}{c_0 \\sqrt{\\alpha}}\n$$\nThis simple formula provides the exact travel time for comparison.\n\nNext, we specify the numerical integrators. The state of the system is the $4$-dimensional vector $\\mathbf{y} = [\\mathbf{x}^{\\mathsf{T}}, \\mathbf{p}^{\\mathsf{T}}]^{\\mathsf{T}} = [x, y, p_x, p_y]^{\\mathsf{T}}$. The ODE system is $\\frac{d\\mathbf{y}}{d\\tau} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{f}(\\mathbf{y}) = [p_x, p_y, -\\alpha x, -\\alpha y]^{\\mathsf{T}}$.\n\nThe first integrator is the classical fourth-order Runge-Kutta method (RK4). For a step size $h$, one step from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is:\n$$\n\\mathbf{k}_1 = h \\, \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_1/2)\n$$\n$$\n\\mathbf{k}_3 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_2/2)\n$$\n$$\n\\mathbf{k}_4 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nRK4 is a general-purpose integrator and is not designed to preserve the geometric structures of Hamiltonian systems, such as symplecticity.\n\nThe second integrator is the second-order Störmer-Verlet (SV) method, a symplectic integrator well-suited for separable Hamiltonians of the form $H(\\mathbf{x}, \\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$. In our case, $T(\\mathbf{p}) = \\frac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ and $V(\\mathbf{x}) = -\\frac{1}{2}n^2(\\mathbf{x}) = -\\frac{1}{2}(n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2)$. The force is $\\mathbf{F}(\\mathbf{x}) = -\\nabla V(\\mathbf{x}) = -\\alpha\\mathbf{x}$. The position-Verlet update scheme for one step of size $h$ is:\n$$\n\\mathbf{p}_{n+1/2} = \\mathbf{p}_n + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_n) = \\mathbf{p}_n - \\frac{h}{2} \\alpha \\mathbf{x}_n\n$$\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + h \\mathbf{p}_{n+1/2}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+1/2} + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_{n+1}) = \\mathbf{p}_{n+1/2} - \\frac{h}{2} \\alpha \\mathbf{x}_{n+1}\n$$\nThis method is time-reversible and preserves the symplectic two-form, which leads to excellent long-term stability and bounded energy error for Hamiltonian systems.\n\nFor each integrator and test case, we perform a simulation from $\\tau=0$ to $\\tau_{\\text{end}}$. The number of full steps of size $h$ is $N = \\lfloor\\tau_{\\text{end}}/h\\rfloor$. The final step has a smaller size $h_{\\text{last}} = \\tau_{\\text{end}} - N h$ to land exactly at the target time. The trajectory $(\\mathbf{x}_k, \\mathbf{p}_k)$ is stored at each time point $\\tau_k$.\n\nThe evaluation metrics are computed from the stored trajectory.\nThe maximum Hamiltonian drift is calculated as:\n$$\n\\Delta H_{\\max} = \\max_{k} \\left| H(\\mathbf{x}_k, \\mathbf{p}_k) - H(\\mathbf{x}_0, \\mathbf{p}_0) \\right|\n$$\nSince the initial condition is constructed such that $H(\\mathbf{x}_0, \\mathbf{p}_0) = 0$, this simplifies to $\\Delta H_{\\max} = \\max_{k} | \\frac{1}{2}(\\lVert\\mathbf{p}_k\\rVert^2 - (n_0^2 - \\alpha\\lVert\\mathbf{x}_k\\rVert^2)) |$.\n\nThe numerical travel time, $T_{\\text{num}}$, is computed using the trapezoidal rule on the stored values of $n^2(\\mathbf{x}_k)$ at times $\\tau_k$:\n$$\nT_{\\text{num}} = \\frac{1}{c_0} \\sum_{k=0}^{M-1} \\frac{n^2(\\mathbf{x}_k) + n^2(\\mathbf{x}_{k+1})}{2} (\\tau_{k+1}-\\tau_k)\n$$\nwhere $M$ is the total number of steps. The absolute error is then $|T_{\\text{num}} - T_{\\text{exact}}|$.\n\nThe implementation will consist of functions for each integrator step, a main simulation loop that applies the chosen integrator and collects trajectory data, and a top-level script to iterate through the test cases and format the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Global constants\n    n0 = 1.6  # Dimensionless\n    c0 = 299792458.0  # m/s\n    rho = 0.6  # Dimensionless\n\n    # Test suite: (alpha [m^-2], h [m])\n    test_cases = [\n        (400.0, 0.05),\n        (2500.0, 0.039),\n        (25.0, 0.3),\n        (10000.0, 0.015),\n    ]\n\n    results = []\n    for alpha, h in test_cases:\n        # Calculate case-specific parameters\n        sqrt_alpha = np.sqrt(alpha)\n        tau_end = 2.0 * np.pi / sqrt_alpha\n\n        # Initial conditions\n        A = rho * n0 / sqrt_alpha\n        x0 = np.array([A, 0.0])\n        p0 = np.array([0.0, 0.8 * n0])\n\n        # Exact travel time\n        t_exact = (n0**2 * np.pi) / (c0 * sqrt_alpha)\n\n        # Run RK4 simulation\n        h_drift_rk4, t_err_rk4 = run_simulation(\n            \"rk4\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        # Run Störmer-Verlet simulation\n        h_drift_sv, t_err_sv = run_simulation(\n            \"sv\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        results.append([h_drift_rk4, t_err_rk4, h_drift_sv, t_err_sv])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(integrator_name, alpha, h, tau_end, x0, p0, n0, c0, t_exact):\n    \"\"\"\n    Runs a single simulation for a given integrator and returns the metrics.\n    \"\"\"\n    # Initialize trajectory storage\n    tau = 0.0\n    x, p = x0.copy(), p0.copy()\n    \n    tau_vals = [tau]\n    x_traj = [x]\n    p_traj = [p]\n\n    # Integration loop\n    while tau  tau_end:\n        step_h = min(h, tau_end - tau)\n        if step_h  1e-12: # Avoid tiny final steps\n            break\n\n        if integrator_name == \"rk4\":\n            y = np.concatenate((x, p))\n            k1 = step_h * f_ode(y, alpha)\n            k2 = step_h * f_ode(y + 0.5 * k1, alpha)\n            k3 = step_h * f_ode(y + 0.5 * k2, alpha)\n            k4 = step_h * f_ode(y + k3, alpha)\n            y_next = y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x, p = y_next[:2], y_next[2:]\n        elif integrator_name == \"sv\":\n            p_half = p - (step_h / 2.0) * alpha * x\n            x_next = x + step_h * p_half\n            p = p_half - (step_h / 2.0) * alpha * x_next\n            x = x_next\n        \n        tau += step_h\n        \n        tau_vals.append(tau)\n        x_traj.append(x)\n        p_traj.append(p)\n    \n    # Calculate metrics\n    x_traj_arr = np.array(x_traj)\n    p_traj_arr = np.array(p_traj)\n    tau_vals_arr = np.array(tau_vals)\n\n    # Hamiltonian drift\n    n_sq_vals = n0**2 - alpha * np.sum(x_traj_arr**2, axis=1)\n    p_sq_vals = np.sum(p_traj_arr**2, axis=1)\n    hamiltonian_vals = 0.5 * (p_sq_vals - n_sq_vals)\n    h_drift_max = np.max(np.abs(hamiltonian_vals)) # H(0)=0\n\n    # Travel time error\n    t_num = np.trapz(n_sq_vals, tau_vals_arr) / c0\n    t_error = np.abs(t_num - t_exact)\n\n    return h_drift_max, t_error\n\ndef f_ode(y, alpha):\n    \"\"\"\n    Derivative function for the 4D state vector y = [x, y, px, py].\n    \"\"\"\n    x, y_coord, px, py = y\n    return np.array([px, py, -alpha * x, -alpha * y_coord])\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "The pinnacle of computational optics lies not just in analyzing a given system, but in designing a new one to meet specific performance targets. This process, known as inverse design, often relies on gradient-based optimization, where the main challenge is the efficient computation of design sensitivities. This exercise  introduces the highly efficient adjoint state method for calculating the shape gradient of a refractive surface, allowing you to optimize a surface for a prescribed irradiance distribution and verify your results, a technique central to modern optical engineering.",
            "id": "3311421",
            "problem": "Consider a two-dimensional refractive interface described by a scalar height function $s(x;p)$ where $x$ is the lateral coordinate and $p$ denotes the vector of shape parameters. A collimated bundle of rays enters from a homogeneous medium of refractive index $n_1$ and propagates along the negative $y$-axis, strikes the refractive interface at $y=s(x;p)$, and refracts into a second homogeneous medium of refractive index $n_2$. The refracted rays then propagate to a planar target located at $y=Y_t$, producing an irradiance distribution on the target. The task is to compute the shape gradient of an energy-matching objective using adjoint ray tracing and verify the gradient accuracy via finite differences.\n\nFundamental base:\n- Use Snell's law of refraction derived from Fermat's principle: for a unit incident direction $\\mathbf{I}$ and a unit normal $\\mathbf{N}$ at the interface, the unit refracted direction $\\mathbf{T}$ obeys the vector form $\\mathbf{T}=\\eta\\,\\mathbf{I}+(\\eta\\,\\cos\\theta_i-\\cos\\theta_t)\\,\\mathbf{N}$, where $\\eta=n_1/n_2$, $\\cos\\theta_i=-\\mathbf{N}\\cdot\\mathbf{I}$, and $\\cos\\theta_t=\\sqrt{1-\\eta^2(1-\\cos^2\\theta_i)}$ under no total internal reflection.\n- Use local energy conservation in geometrical optics: the irradiance on the target can be represented by transporting input ray energy to the target via an approximation of the Dirac delta distribution through a smooth kernel.\n\nModel and discretization:\n- The interface is a rotationally symmetric curve parameterized as $s(x;p)=p_0+p_2 x^2$, where $p_0$ is an axial offset in $\\mathrm{m}$ and $p_2$ is a quadratic curvature coefficient in $\\mathrm{m}^{-1}$.\n- The incident rays are distributed uniformly across an aperture $x\\in[-W,W]$ with ray positions $\\{x_i\\}_{i=1}^{N}$ and constant input irradiance density $I_0$ in $\\mathrm{W/m}$. Each ray carries energy $w_i=I_0\\,\\Delta x$, where $\\Delta x=\\frac{2W}{N-1}$ is the ray sampling interval in $\\mathrm{m}$.\n- At point $x_i$ on the interface, the unit normal is constructed from the surface slope $s'(x_i;p)$ as $\\mathbf{N}=\\frac{1}{\\sqrt{1+(s')^2}}(-s',1)$, and the unit incident direction is $\\mathbf{I}=(0,-1)$. The refracted direction $\\mathbf{T}=(T_x,T_y)$ is obtained from Snell's law.\n- The refracted ray starting at $(x_i,s(x_i;p))$ intersects the target plane at $y=Y_t$ at the lateral position $x_t(x_i;p)$ given by $x_t(x_i;p)=x_i+T_x\\,t_i$, where $t_i=\\frac{Y_t-s(x_i;p)}{T_y}$ is the travel parameter.\n- The target irradiance is computed on a uniform grid $\\{x_k\\}_{k=1}^{M}$ over a specified range using a normalized Gaussian kernel $\\varphi_\\sigma(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$ in $\\mathrm{m}^{-1}$ to approximate the Dirac delta that transports each ray’s energy to the target. The numerical irradiance is $I_{\\text{num}}(x_k;p)=\\sum_{i=1}^{N}w_i\\,\\varphi_\\sigma(x_k-x_t(x_i;p))$ in $\\mathrm{W/m}$.\n- The target prescription is a normalized Gaussian $I_{\\text{tgt}}(x_k)=\\frac{P}{\\sqrt{2\\pi}\\sigma_t}\\exp\\!\\left(-\\frac{x_k^2}{2\\sigma_t^2}\\right)$ in $\\mathrm{W/m}$, where $P=I_0\\cdot 2W$ is the total input power in $\\mathrm{W}$ and $\\sigma_t$ is the target width in $\\mathrm{m}$.\n\nObjective:\n- Define the least-squares mismatch $J(p)=\\frac{1}{2}\\sum_{k=1}^{M}\\left(I_{\\text{num}}(x_k;p)-I_{\\text{tgt}}(x_k)\\right)^2\\,\\Delta x_{\\text{tgt}}$, where $\\Delta x_{\\text{tgt}}$ is the target grid spacing in $\\mathrm{m}$.\n\nAdjoint ray tracing gradient:\n- Derive the adjoint-based shape gradient $\\nabla_p J$ by reverse accumulation from the target plane to the interface. Use the chain rule with the kernel derivative $\\varphi'_\\sigma(x)=-\\frac{x}{\\sigma^2}\\varphi_\\sigma(x)$ and the geometric derivatives of $x_t$ with respect to $(p_0,p_2)$ via $(s,s')$.\n- The required geometric derivatives at each ray are $\\frac{\\partial x_t}{\\partial s}$ and $\\frac{\\partial x_t}{\\partial s'}$ obtained from the refraction kinematics and the intersection with the target plane, and then combine them via $\\frac{\\partial x_t}{\\partial p_0}=\\frac{\\partial x_t}{\\partial s}$ and $\\frac{\\partial x_t}{\\partial p_2}=x_i^2\\frac{\\partial x_t}{\\partial s}+2x_i\\frac{\\partial x_t}{\\partial s'}$.\n\nVerification by finite differences:\n- Verify the adjoint gradient by comparing it to a central finite-difference approximation with small perturbations $\\delta_{p_0}$ in $\\mathrm{m}$ and $\\delta_{p_2}$ in $\\mathrm{m}^{-1}$.\n\nUnits and output:\n- All distances must be treated in $\\mathrm{m}$, refractive indices are unitless, and irradiance in $\\mathrm{W/m}$. Angles are not used directly; directions are represented as unit vectors.\n- Your program must compute, for each specified test case, the relative error between the adjoint gradient and the finite-difference gradient for both parameters $p_0$ and $p_2$, defined as $\\frac{\\left|\\text{grad}_{\\text{adj}}-\\text{grad}_{\\text{fd}}\\right|}{\\max\\left(\\left|\\text{grad}_{\\text{fd}}\\right|,10^{-12}\\right)}$, yielding two floats per test case.\n- The final output must be a single line containing a Python list of lists, where each inner list corresponds to a test case and contains the two floats for the relative gradient errors in the order $[e_{p_0},e_{p_2}]$.\n\nTest suite:\n- Use the following three cases that collectively examine typical behavior, a near-boundary flat-surface condition, and a stronger curvature with higher index contrast. For each, specify ($n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2}$):\n    - Case $1$ (general focusing): $(1.0,1.5,0.02,201,0.20,0.002,0.010,1.0,0.0,50.0,0.04,801,10^{-6},10^{-6})$.\n    - Case $2$ (flat interface edge case): $(1.0,1.2,0.02,201,0.20,0.002,0.010,1.0,0.0,0.0,0.04,801,10^{-6},10^{-6})$.\n    - Case $3$ (strong curvature, higher contrast): $(1.0,1.7,0.015,301,0.15,0.001,0.008,1.0,0.0,300.0,0.03,601,10^{-6},10^{-6})$.\n- Your program should produce a single line of output containing the results as a comma-separated Python list of lists, for example, $[\\,[e_{p_0}^{(1)},e_{p_2}^{(1)}],\\,[e_{p_0}^{(2)},e_{p_2}^{(2)}],\\,[e_{p_0}^{(3)},e_{p_2}^{(3)}]\\,]$ where superscripts denote the test case index.\n\nRequirements:\n- Implement the forward ray tracing using Snell’s law from first principles.\n- Implement the adjoint gradient accumulation from the target mismatch to the surface parameters.\n- Implement central finite differences for verification.\n- Ensure numerical stability by avoiding total internal reflection, and by using the specified small perturbations for finite differences.",
            "solution": "The user has provided a valid, well-posed problem in the field of computational optics. The task is to calculate the shape gradient of a least-squares objective function using the adjoint method and verify its accuracy against a finite-difference approximation. The optical system consists of a single refractive interface defined by a quadratic profile, separating two homogeneous media.\n\nThe solution will be presented in three main parts:\n1.  **Forward Model**: This section describes the process of tracing rays from the source to the target plane and calculating the resulting irradiance distribution and objective function.\n2.  **Adjoint Model**: This section details the derivation of the gradient of the objective function with respect to the shape parameters using the adjoint state method. This involves back-propagating sensitivities from the target plane to the refractive interface.\n3.  **Verification**: This section outlines the central finite-difference method used to obtain a numerical approximation of the gradient, which serves as a benchmark for verifying the analytical adjoint gradient.\n\n### 1. Forward Model: Ray Tracing and Objective Function\n\nThe forward model simulates the physical process of light propagation and interaction.\n\n**1.1. Ray Generation and Interface Interaction**\nA set of $N$ rays is initialized on a uniform grid $\\{x_i\\}$ over the input aperture $x \\in [-W, W]$. Each ray propagates along the negative $y$-axis with an initial direction vector $\\mathbf{I} = (0, -1)$ and carries an energy $w = I_0 \\Delta x$, where $\\Delta x = \\frac{2W}{N-1}$.\n\nFor each ray $i$ incident at lateral position $x_i$, it strikes the refractive interface $s(x; p) = p_0 + p_2 x^2$ at the point $(x_i, s_i = s(x_i; p))$. At this point, the surface slope is $s'_i = \\frac{\\partial s}{\\partial x}(x_i; p) = 2p_2 x_i$. The unit normal vector to the interface, pointing into the first medium (upwards), is given by:\n$$\n\\mathbf{N}_i = \\frac{1}{\\sqrt{1 + (s'_i)^2}}(-s'_i, 1)\n$$\nThe incident direction is $\\mathbf{I}=(0,-1)$. The cosine of the angle of incidence $\\theta_i$ is computed as $\\cos\\theta_i = -\\mathbf{N}_i \\cdot \\mathbf{I} = N_{iy} = (1+(s'_i)^2)^{-1/2}$.\n\n**1.2. Refraction via Snell's Law**\nThe refracted ray direction $\\mathbf{T}_i = (T_{ix}, T_{iy})$ is determined by the vector form of Snell's law:\n$$\n\\mathbf{T}_i = \\eta \\mathbf{I} + (\\eta \\cos\\theta_i - \\cos\\theta_t) \\mathbf{N}_i\n$$\nwhere $\\eta = n_1/n_2$ is the relative refractive index, and $\\cos\\theta_t = \\sqrt{1 - \\eta^2(1 - \\cos^2\\theta_i)}$. Since all test cases have $n_1  n_2$, $\\eta  1$, and total internal reflection does not occur.\nBy expanding the vector equation, we can derive an explicit expression for the $x$-component of the refracted direction, $T_{ix}$, as a function of the slope $s'_i$:\n$$\nT_{ix} = \\frac{-s'_i}{1+(s'_i)^2} \\left(\\eta - \\sqrt{1+(s'_i)^2(1-\\eta^2)}\\right)\n$$\nSince $\\mathbf{T}_i$ is a unit vector, $T_{ix}^2 + T_{iy}^2 = 1$. The physical situation dictates that rays propagate towards the target plane, so we must have $T_{iy}  0$. Thus, $T_{iy} = -\\sqrt{1 - T_{ix}^2}$.\n\n**1.3. Propagation to Target and Irradiance Calculation**\nThe refracted ray from $(x_i, s_i)$ propagates to the target plane at $y=Y_t$. The travel parameter $t_i$ is found from the $y$-component of the ray path: $Y_t = s_i + T_{iy} t_i$, which gives $t_i = (Y_t - s_i) / T_{iy}$. The lateral position of the ray on the target is then:\n$$\nx_{t,i} = x_i + T_{ix} t_i\n$$\nThe irradiance on the target is calculated on a uniform grid $\\{x_k\\}$ of $M$ points. Each ray's energy is distributed onto this grid using a normalized Gaussian kernel $\\varphi_\\sigma(z)$ to approximate a Dirac delta function. The numerical irradiance at each grid point $x_k$ is the sum of contributions from all $N$ rays:\n$$\nI_{\\text{num}}(x_k; p) = \\sum_{i=1}^{N} w \\, \\varphi_\\sigma(x_k - x_{t,i}(p))\n$$\n\n**1.4. Objective Function**\nThe objective is to match the computed irradiance $I_{\\text{num}}$ to a prescribed target irradiance $I_{\\text{tgt}}$. The misfit is quantified by a least-squares objective function $J(p)$:\n$$\nJ(p) = \\frac{1}{2} \\sum_{k=1}^{M} (I_{\\text{num}}(x_k; p) - I_{\\text{tgt}}(x_k))^2 \\Delta x_{\\text{tgt}}\n$$\nwhere $\\Delta x_{\\text{tgt}}$ is the spacing of the target grid points.\n\n### 2. Adjoint Model: Gradient Calculation\n\nThe adjoint method provides an efficient way to compute the gradient $\\nabla_p J$ by avoiding repeated forward simulations. It relies on the chain rule to back-propagate sensitivities from the objective function to the design parameters.\n\n**2.1. Gradient of the Objective Function**\nThe gradient of $J$ with respect to a parameter $p_j$ (where $j \\in \\{0, 2\\}$) is:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{k=1}^{M} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} \\Delta x_{\\text{tgt}}\n$$\nThe derivative of the numerical irradiance is:\n$$\n\\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} = \\sum_{i=1}^{N} w \\, \\varphi'_\\sigma(x_k - x_{t,i}) \\left( -\\frac{\\partial x_{t,i}}{\\partial p_j} \\right)\n$$\nwhere $\\varphi'_\\sigma$ is the derivative of the Gaussian kernel. Substituting and rearranging the sums, we get:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\left( -w \\sum_{k=1}^{M} \\Delta x_{\\text{tgt}} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\varphi'_\\sigma(x_k-x_{t,i}) \\right) \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\nThe term in the parenthesis is the adjoint variable, or sensitivity, $\\bar{x}_{t,i}$, which represents the contribution of a small change in the ray's target position $x_{t,i}$ to the total change in the objective function $J$.\n$$\n\\bar{x}_{t,i} = \\frac{\\partial J}{\\partial x_{t,i}}\n$$\nSo, the total gradient is an accumulation over all rays:\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\bar{x}_{t,i} \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n\n**2.2. Geometric Sensitivities**\nThe final step is to find the geometric sensitivities $\\frac{\\partial x_{t,i}}{\\partial p_j}$. We use the local surface height $s_i$ and slope $s'_i$ as intermediate variables. By the chain rule:\n$$\n\\frac{\\partial x_{t,i}}{\\partial p_j} = \\frac{\\partial x_{t,i}}{\\partial s_i}\\frac{\\partial s_i}{\\partial p_j} + \\frac{\\partial x_{t,i}}{\\partial s'_i}\\frac{\\partial s'_i}{\\partial p_j}\n$$\nFrom $s_i = p_0 + p_2 x_i^2$ and $s'_i = 2p_2 x_i$, we have:\n*   $\\frac{\\partial s_i}{\\partial p_0} = 1$, $\\frac{\\partial s'_i}{\\partial p_0} = 0 \\implies \\frac{\\partial x_{t,i}}{\\partial p_0} = \\frac{\\partial x_{t,i}}{\\partial s_i}$\n*   $\\frac{\\partial s_i}{\\partial p_2} = x_i^2$, $\\frac{\\partial s'_i}{\\partial p_2} = 2x_i \\implies \\frac{\\partial x_{t,i}}{\\partial p_2} = x_i^2 \\frac{\\partial x_{t,i}}{\\partial s_i} + 2x_i \\frac{\\partial x_{t,i}}{\\partial s'_i}$\n\nThe derivatives of the target position $x_t$ with respect to $s$ and $s'$ can be derived from $x_t = x + T_x(s') \\frac{Y_t - s}{T_y(s')}$:\n$$\n\\frac{\\partial x_t}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = -\\frac{T_x}{T_y}\n$$\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{\\partial}{\\partial s'}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = (Y_t-s)\\frac{\\partial}{\\partial s'}\\left(\\frac{T_x}{T_y}\\right) = t \\left( \\frac{\\partial T_x}{\\partial s'} - \\frac{T_x}{T_y}\\frac{\\partial T_y}{\\partial s'}\\right)\n$$\nUsing the property $T_x^2+T_y^2=1$, which implies $T_x \\frac{\\partial T_x}{\\partial s'} + T_y \\frac{\\partial T_y}{\\partial s'} = 0$, the expression simplifies to:\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{t}{T_y^2} \\frac{\\partial T_x}{\\partial s'}\n$$\nThe derivative $\\frac{\\partial T_x}{\\partial s'}$ is found by differentiating the explicit expression for $T_x(s')$.\n\nWith these components, the full adjoint gradient can be assembled and computed.\n\n### 3. Verification via Finite Differences\n\nTo verify the correctness of the derived adjoint gradient, we compare it to a numerical approximation obtained using the central finite-difference formula. For each parameter $p_j$, the gradient is approximated as:\n$$\n\\frac{\\partial J}{\\partial p_j} \\approx \\frac{J(p + \\delta_j \\mathbf{e}_j) - J(p - \\delta_j \\mathbf{e}_j)}{2\\delta_j}\n$$\nwhere $\\mathbf{e}_j$ is a standard basis vector and $\\delta_j$ is a small perturbation (e.g., $10^{-6}$). This requires two additional evaluations of the objective function $J$ for each parameter. The relative error between the adjoint gradient $(\\text{grad}_{\\text{adj}})$ and the finite-difference gradient $(\\text{grad}_{\\text{fd}})$ is then computed as:\n$$\n\\text{Error} = \\frac{|\\text{grad}_{\\text{adj}} - \\text{grad}_{\\text{fd}}|}{\\max(|\\text{grad}_{\\text{fd}}|, 10^{-12})}\n$$\nA small relative error (typically close to machine precision or the precision of the finite-difference approximation) confirms the correctness of the complex adjoint implementation.",
            "answer": "```python\nimport numpy as np\n\nclass SimulationParameters:\n    \"\"\"A helper class to hold all simulation parameters for a given case.\"\"\"\n    def __init__(self, n1, n2, W, N, Yt, sigma, sigma_t, I0, p0, p2, Xmax, M, delta_p0, delta_p2):\n        self.n1 = n1\n        self.n2 = n2\n        self.eta = n1 / n2\n        self.W = W\n        self.N = N\n        self.Yt = Yt\n        self.sigma = sigma\n        self.sigma_t = sigma_t\n        self.I0 = I0\n        self.p_vec = np.array([p0, p2], dtype=float)\n        self.Xmax = Xmax\n        self.M = M\n        self.delta_p = np.array([delta_p0, delta_p2], dtype=float)\n\n        # Derived parameters\n        self.x_in = np.linspace(-self.W, self.W, self.N)\n        self.dx_in = (2.0 * self.W) / (self.N - 1) if self.N  1 else 0\n        self.ray_energy = self.I0 * self.dx_in\n        self.P_total = self.I0 * 2.0 * self.W\n        \n        self.x_target_grid = np.linspace(-self.Xmax, self.Xmax, self.M)\n        self.dx_target = (2.0 * self.Xmax) / (self.M - 1) if self.M  1 else 0\n\ndef gaussian_kernel(x, sigma):\n    \"\"\"Computes the value of a Gaussian kernel.\"\"\"\n    return (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-x**2 / (2.0 * sigma**2))\n\ndef gaussian_kernel_deriv(x, sigma):\n    \"\"\"Computes the derivative of a Gaussian kernel.\"\"\"\n    return -x / sigma**2 * gaussian_kernel(x, sigma)\n\ndef compute_objective_and_intermediates(p_vec, params):\n    \"\"\"Performs forward ray tracing and computes the objective function J and intermediate values.\"\"\"\n    p0, p2 = p_vec\n    \n    x_i = params.x_in\n    s_i = p0 + p2 * x_i**2\n    s_prime_i = 2.0 * p2 * x_i\n\n    s_prime_sq = s_prime_i**2\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - params.eta**2)\n    # This check is formally not needed since eta  1, but is good practice.\n    if np.any(term_in_sqrt  0):\n        raise ValueError(\"Total Internal Reflection encountered, problem is ill-defined for these parameters.\")\n    \n    sqrt_term = np.sqrt(term_in_sqrt)\n    Tx = (-s_prime_i * (params.eta - sqrt_term)) / (1.0 + s_prime_sq)\n    \n    Ty_sq = 1.0 - Tx**2\n    Ty_sq[Ty_sq  0] = 0.0\n    Ty = -np.sqrt(Ty_sq)\n\n    t_i = (params.Yt - s_i) / Ty\n    x_t = x_i + Tx * t_i\n\n    delta_x = params.x_target_grid[:, np.newaxis] - x_t[np.newaxis, :]\n    I_num = params.ray_energy * np.sum(gaussian_kernel(delta_x, params.sigma), axis=1)\n\n    I_tgt = (params.P_total / (np.sqrt(2.0 * np.pi) * params.sigma_t)) * \\\n            np.exp(-params.x_target_grid**2 / (2.0 * params.sigma_t**2))\n\n    J = 0.5 * np.sum((I_num - I_tgt)**2) * params.dx_target\n    \n    intermediates = {\n        'x_i': x_i, 's_prime_i': s_prime_i, 'Tx': Tx, 'Ty': Ty, 't_i': t_i,\n        'I_num': I_num, 'I_tgt': I_tgt, 'delta_x': delta_x\n    }\n    \n    return J, intermediates\n\ndef compute_adjoint_gradient(p_vec, params):\n    \"\"\"Computes the gradient of the objective function using the adjoint method.\"\"\"\n    _, intermediates = compute_objective_and_intermediates(p_vec, params)\n    \n    x_i = intermediates['x_i']\n    s_prime_i = intermediates['s_prime_i']\n    Tx, Ty, t_i = intermediates['Tx'], intermediates['Ty'], intermediates['t_i']\n    I_num, I_tgt, delta_x = intermediates['I_num'], intermediates['I_tgt'], intermediates['delta_x']\n    \n    mismatch = (I_num - I_tgt)[:, np.newaxis]\n    kernel_deriv = gaussian_kernel_deriv(delta_x, params.sigma)\n    x_t_bar = -params.ray_energy * params.dx_target * np.sum(mismatch * kernel_deriv, axis=0)\n    \n    dxt_ds = -Tx / Ty\n    \n    s_prime_sq = s_prime_i**2\n    eta_sq = params.eta**2\n    \n    f = -s_prime_i / (1.0 + s_prime_sq)\n    f_prime = (s_prime_sq - 1.0) / (1.0 + s_prime_sq)**2\n\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - eta_sq)\n    sqrt_term = np.sqrt(term_in_sqrt)\n    g = params.eta - sqrt_term\n    \n    g_prime = np.zeros_like(s_prime_i)\n    # Avoid division by zero when s_prime_i is 0\n    # Also handle sqrt_term being zero, though unlikely\n    valid_deriv = (s_prime_i != 0)  (sqrt_term > 1e-15)\n    g_prime[valid_deriv] = -s_prime_i[valid_deriv] * (1.0 - eta_sq) / sqrt_term[valid_deriv]\n\n    dTx_ds_prime = f_prime * g + f * g_prime\n    dxt_ds_prime = (t_i / Ty**2) * dTx_ds_prime\n    \n    grad_p0 = np.sum(x_t_bar * dxt_ds)\n    grad_p2 = np.sum(x_t_bar * (dxt_ds * x_i**2 + dxt_ds_prime * 2.0 * x_i))\n    \n    return np.array([grad_p0, grad_p2])\n\ndef compute_fd_gradient(p_vec, params):\n    \"\"\"Computes the gradient using central finite differences for verification.\"\"\"\n    grad_fd = np.zeros_like(p_vec, dtype=float)\n    for i in range(len(p_vec)):\n        p_plus = p_vec.copy()\n        p_minus = p_vec.copy()\n        p_plus[i] += params.delta_p[i]\n        p_minus[i] -= params.delta_p[i]\n        \n        J_plus, _ = compute_objective_and_intermediates(p_plus, params)\n        J_minus, _ = compute_objective_and_intermediates(p_minus, params)\n        \n        grad_fd[i] = (J_plus - J_minus) / (2.0 * params.delta_p[i])\n        \n    return grad_fd\n    \ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (1.0, 1.5, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 50.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.2, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 0.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.7, 0.015, 301, 0.15, 0.001, 0.008, 1.0, 0.0, 300.0, 0.03, 601, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        params = SimulationParameters(*case)\n        \n        grad_adj = compute_adjoint_gradient(params.p_vec, params)\n        grad_fd = compute_fd_gradient(params.p_vec, params)\n        \n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_errors = np.abs(grad_adj - grad_fd) / denominator\n        \n        results.append(rel_errors.tolist())\n\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}