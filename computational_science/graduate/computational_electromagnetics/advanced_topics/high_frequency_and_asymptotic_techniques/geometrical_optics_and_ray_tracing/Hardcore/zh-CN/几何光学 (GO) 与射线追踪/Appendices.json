{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将回顾作为透镜设计基石的近轴光学基础。你将直接从斯涅耳定律的小角度近似出发，为一个复合透镜系统构建光线追迹矩阵（$ABCD$ 矩阵）。这项练习旨在加强基本物理原理与用于分析和设计众多光学系统的强大矩阵形式化方法之间的联系。",
            "id": "3311406",
            "problem": "一个旋转对称的成像系统由一个空气中的厚双凸单透镜、一个空气间隙和一个平面平行窗口组成，所有元件共轴。设光轴为指向右侧的 $z$ 轴，光线高度 $y$ 为垂直于光轴的量度，近轴角 $u$ 定义为 $u \\equiv dy/dz$（以弧度为单位）。采用球面曲率中心位于其表面顶点右侧时，曲率半径 $R$ 为正的符号约定。\n\n该透镜的折射率为 $n_{\\ell} = 1.5168$，中心厚度为 $t = 8\\,\\mathrm{mm}$。其第一个表面（空气到玻璃）的半径为 $R_1 = +50\\,\\mathrm{mm}$，其第二个表面（玻璃到空气）的半径为 $R_2 = -50\\,\\mathrm{mm}$。紧随透镜之后是一个长度为 $g = 20\\,\\mathrm{mm}$ 的空气间隙。空气间隙之后是一个厚度为 $w = 2\\,\\mathrm{mm}$、折射率为 $n_{w} = 1.5$ 的平面平行窗口，其两侧均为空气。所有未另外指明的介质均为折射率为 $n_0 = 1$ 的空气。\n\n从第一性原理出发，使用近轴近似，从斯涅尔定律和球面的小角度几何结构开始，构建用于球面和平面界面上平移和折射的相应 $2\\times 2$ 光线传输矩阵。按照传播顺序级联这些矩阵，以获得从第一个透镜表面正前方的参考输入平面到窗口出射面正后方的输出平面的总体一阶系统矩阵。\n\n假设一束准直输入光束（物在无穷远处）入射到系统上，确定后焦距 $L$，该距离从窗口的出射面开始测量（即从窗口出射面到近轴焦点的空气中轴向距离）。将您的最终数值结果四舍五入到四位有效数字。用 $\\mathrm{mm}$ 表示您的答案。",
            "solution": "对用户提供的问题进行有效性评估。\n\n**步骤1：提取已知条件**\n- **系统配置**：一个旋转对称的成像系统，由一个厚双凸单透镜、一个空气间隙和一个平面平行窗口组成，所有元件共轴。\n- **坐标系**：光轴为 $z$ 轴，指向右侧。光线高度为 $y$。近轴角为 $u \\equiv dy/dz$。\n- **符号约定**：若球面曲率中心位于其顶点右侧，则曲率半径 $R$ 为正。\n- **透镜参数**：\n  - 折射率：$n_{\\ell} = 1.5168$\n  - 中心厚度：$t = 8\\,\\mathrm{mm}$\n  - 第一表面半径（空气到玻璃）：$R_1 = +50\\,\\mathrm{mm}$\n  - 第二表面半径（玻璃到空气）：$R_2 = -50\\,\\mathrm{mm}$\n- **空气间隙**：长度 $g = 20\\,\\mathrm{mm}$\n- **窗口参数**：\n  - 厚度：$w = 2\\,\\mathrm{mm}$\n  - 折射率：$n_{w} = 1.5$\n  - 几何形状：平面平行\n- **环境介质**：空气，折射率 $n_0 = 1$。\n- **任务**：\n  1.  从第一性原理推导用于平移和折射的 $2\\times 2$ 光线传输矩阵。\n  2.  构建从第一个透镜表面正前方的平面到窗口出射面正后方的平面的总体系统矩阵。\n  3.  对于准直输入光束，确定从窗口出射面测量的后焦距 $L$。\n  4.  提供最终数值答案，以 $\\mathrm{mm}$ 为单位，并四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是使用光线传输矩阵法的近轴几何光学中的一个标准练习。其基本原理（小角度近似下的斯涅尔定律）是基础且公认的。所提供的物理参数（折射率、尺寸）对于常见的光学元件是现实的。\n- **适定性**：该问题是适定的。所有必要的参数都已指定，目标明确定义，且系统允许一个唯一的、稳定的解。\n- **客观性**：问题陈述是定量的，没有主观或模糊的语言。\n\n**步骤3：结论与行动**\n该问题是**有效的**。它是一个在计算电磁学领域，特别是在几何光学和光线追迹范畴内，完整、一致且科学合理的问题。可以继续求解过程。\n\n**求解推导**\n\n该问题将使用标准光线传输矩阵法求解，该方法关联了光线在两个不同平面上的位置 $y$ 和光学方向余弦 $\\nu = n u$。一条近轴光线的状态由向量 $\\begin{pmatrix} y \\\\ \\nu \\end{pmatrix}$ 描述。该向量在通过光学系统传播时的变换由一个 $2\\times 2$ 矩阵描述，通常称为ABCD矩阵。\n\n首先，我们按照要求从第一性原理推导折射矩阵和平移矩阵。\n\n**1. 折射矩阵**\n考虑一个曲率半径为 $R$ 的球面界面，它分隔了两种折射率分别为 $n_1$ 和 $n_2$ 的介质。一条高度为 $y_1$、角度为 $u_1$ 的光线从左侧入射。折射后，其高度为 $y_2$，角度为 $u_2$。\n在入射点，高度不变：$y_2 = y_1$。\n斯涅尔定律的近轴形式为 $n_1 i_1 = n_2 i_2$，其中 $i_1$ 和 $i_2$ 分别是相对于表面法线的入射角和折射角。设 $\\phi$ 为表面法线与光轴的夹角。对于半径为 $R$ 的球面上高度为 $y$ 的光线，$\\phi \\approx y/R$。从角度的几何关系可知，$i_1 = u_1 + \\phi$ 且 $i_2 = u_2 + \\phi$。\n将这些代入斯涅尔定律：\n$n_1(u_1 + \\phi) = n_2(u_2 + \\phi)$\n$n_1 u_1 + n_1 (y_1/R) = n_2 u_2 + n_2 (y_1/R)$\n整理得到 $n_2 u_2$：\n$n_2 u_2 = n_1 u_1 + \\frac{n_1 - n_2}{R} y_1$\n这是我们变换的第二个方程。我们定义光学方向余弦 $\\nu_1 = n_1 u_1$ 和 $\\nu_2 = n_2 u_2$。这两个方程是：\n$y_2 = y_1$\n$\\nu_2 = \\nu_1 + \\frac{n_1 - n_2}{R} y_1$\n这可以写成矩阵形式：\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ \\frac{n_1 - n_2}{R} & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\n量 $P = \\frac{n_2 - n_1}{R}$ 是该表面的光焦度。折射矩阵为 $\\mathcal{R} = \\begin{pmatrix} 1 & 0 \\\\ -P & 1 \\end{pmatrix}$。\n\n**2. 平移矩阵**\n考虑一条光线在折射率为 $n$ 的均匀介质中沿光轴平移距离 $d$。初始状态为 $(y_1, u_1)$，最终状态为 $(y_2, u_2)$。\n光线的角度不变，所以 $u_2 = u_1$。因此，$\\nu_2 = n u_2 = n u_1 = \\nu_1$。\n高度根据 $y_2 = y_1 + d \\tan(u_1)$ 变化。在近轴近似下，$\\tan(u_1) \\approx u_1$。\n所以，$y_2 = y_1 + d u_1$。由于 $u_1 = \\nu_1/n$，我们有 $y_2 = y_1 + \\frac{d}{n} \\nu_1$。\n这两个方程是：\n$y_2 = y_1 + \\frac{d}{n} \\nu_1$\n$\\nu_2 = \\nu_1$\n以矩阵形式表示：\n$$ \\begin{pmatrix} y_2 \\\\ \\nu_2 \\end{pmatrix} = \\begin{pmatrix} 1 & d/n \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} y_1 \\\\ \\nu_1 \\end{pmatrix} $$\n平移矩阵为 $\\mathcal{T}(d, n) = \\begin{pmatrix} 1 & d/n \\\\ 0 & 1 \\end{pmatrix}$。\n\n**3. 系统矩阵构建**\n总系统矩阵 $M_{sys}$ 是每个光学元件的单独矩阵的乘积，按传播顺序的逆序相乘。该系统由透镜、空气间隙和窗口组成。\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\n$M_{sys} = (\\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1}) \\cdot \\mathcal{T}_g \\cdot (\\mathcal{R}_2\\mathcal{T}_{\\ell}\\mathcal{R}_1)$\n\n参数为：$n_0=1$，$n_{\\ell}=1.5168$，$n_w=1.5$，$R_1=50\\,\\mathrm{mm}$，$R_2=-50\\,\\mathrm{mm}$，$t=8\\,\\mathrm{mm}$，$g=20\\,\\mathrm{mm}$，$w=2\\,\\mathrm{mm}$。\n\n**透镜矩阵 ($M_{lens}$):**\n- 折射 $\\mathcal{R}_1$ (空气到透镜): $n_1=n_0=1$, $n_2=n_{\\ell}$, $R=R_1$。光焦度 $P_1 = \\frac{n_{\\ell} - n_0}{R_1} = \\frac{1.5168 - 1}{50} = 0.010336\\,\\mathrm{mm}^{-1}$。\n  $\\mathcal{R}_1 = \\begin{pmatrix} 1 & 0 \\\\ -P_1 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -0.010336 & 1 \\end{pmatrix}$。\n- 平移 $\\mathcal{T}_{\\ell}$ (穿过透镜): $d=t=8\\,\\mathrm{mm}$, $n=n_{\\ell}$。\n  $\\mathcal{T}_{\\ell} = \\begin{pmatrix} 1 & t/n_{\\ell} \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 8/1.5168 \\\\ 0 & 1 \\end{pmatrix}$。\n- 折射 $\\mathcal{R}_2$ (透镜到空气): $n_1=n_{\\ell}$, $n_2=n_0=1$, $R=R_2$。光焦度 $P_2 = \\frac{n_0 - n_{\\ell}}{R_2} = \\frac{1 - 1.5168}{-50} = 0.010336\\,\\mathrm{mm}^{-1}$。\n  $\\mathcal{R}_2 = \\begin{pmatrix} 1 & 0 \\\\ -P_2 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ -0.010336 & 1 \\end{pmatrix}$。\n\n$M_{lens} = \\mathcal{R}_2 \\mathcal{T}_{\\ell} \\mathcal{R}_1 = \\begin{pmatrix} 1 & 0 \\\\ -P_2 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & t/n_{\\ell} \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ -P_1 & 1 \\end{pmatrix}$\n$M_{lens} = \\begin{pmatrix} 1 - P_1(t/n_{\\ell}) & t/n_{\\ell} \\\\ -(P_1+P_2) + P_1 P_2 (t/n_{\\ell}) & 1 - P_2(t/n_{\\ell}) \\end{pmatrix}$\n令 $P_1=P_2=P=0.010336\\,\\mathrm{mm}^{-1}$ 且 $t/n_{\\ell} \\approx 5.27426\\,\\mathrm{mm}$。\n$A_L = D_L = 1 - (0.010336)(5.27426) = 1 - 0.054512 = 0.945488$\n$B_L = 5.27426\\,\\mathrm{mm}$\n$C_L = -2P + P^2(t/n_{\\ell}) = -2(0.010336) + (0.010336)^2(5.27426) = -0.020672 + 0.000563 = -0.020109\\,\\mathrm{mm}^{-1}$\n$M_{lens} = \\begin{pmatrix} 0.945488 & 5.27426 \\\\ -0.020109 & 0.945488 \\end{pmatrix}$\n\n**空气间隙矩阵 ($M_{gap}$):**\n- 在空气中平移 $\\mathcal{T}_g$: $d=g=20\\,\\mathrm{mm}$, $n=n_0=1$。\n$M_{gap} = \\mathcal{T}_g = \\begin{pmatrix} 1 & g/n_0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 20 \\\\ 0 & 1 \\end{pmatrix}$。\n\n**窗口矩阵 ($M_{window}$):**\n- 对于空气中厚度为 $w$、折射率为 $n_w$ 的平面平行板（$R_1, R_2 \\to \\infty$），其表面的光焦度为零。矩阵为：\n$M_{window} = \\mathcal{R}_{w2}\\mathcal{T}_w\\mathcal{R}_{w1} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & w/n_w \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & w/n_w \\\\ 0 & 1 \\end{pmatrix}$\n$w/n_w = 2/1.5 = 4/3\\,\\mathrm{mm}$。\n$M_{window} = \\begin{pmatrix} 1 & 4/3 \\\\ 0 & 1 \\end{pmatrix}$。\n\n**总系统矩阵 ($M_{sys}$):**\n$M_{sys} = M_{window} \\cdot M_{gap} \\cdot M_{lens}$\n首先，我们计算 $M' = M_{gap} \\cdot M_{lens}$：\n$M' = \\begin{pmatrix} 1 & 20 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0.945488 & 5.27426 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A_L+g C_L & B_L+g D_L \\\\ C_L & D_L \\end{pmatrix}$\n$A' = 0.945488 + 20(-0.020109) = 0.945488 - 0.40218 = 0.543308$\n$B' = 5.27426 + 20(0.945488) = 5.27426 + 18.90976 = 24.18402$\n$C' = -0.020109$\n$D' = 0.945488$\n$M' = \\begin{pmatrix} 0.543308 & 24.18402 \\\\ -0.020109 & 0.945488 \\end{pmatrix}$\n\n现在，我们计算 $M_{sys} = M_{window} \\cdot M'$：\n$M_{sys} = \\begin{pmatrix} 1 & 4/3 \\\\ 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0.543308 & 24.18402 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A' + (4/3)C' & B' + (4/3)D' \\\\ C' & D' \\end{pmatrix}$\n$A_{sys} = 0.543308 + (4/3)(-0.020109) = 0.543308 - 0.026812 = 0.516496$\n$B_{sys} = 24.18402 + (4/3)(0.945488) = 24.18402 + 1.260651 = 25.444671$\n$C_{sys} = -0.020109$\n$D_{sys} = 0.945488$\n\n最终的系统矩阵是 $M_{sys} = \\begin{pmatrix} 0.516496 & 25.444671 \\\\ -0.020109 & 0.945488 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix}$。\n\n**4. 后焦距计算**\n准直输入光束由平行于光轴的光线组成，因此 $u_{in} = 0$，这意味着 $\\nu_{in} = n_0 u_{in} = 0$。在透镜前方的输入光线向量是 $\\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix}$。\n在窗口后方的输出光线向量由下式给出：\n$$ \\begin{pmatrix} y_{out} \\\\ \\nu_{out} \\end{pmatrix} = M_{sys} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A & B \\\\ C & D \\end{pmatrix} \\begin{pmatrix} y_{in} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} A y_{in} \\\\ C y_{in} \\end{pmatrix} $$\n因此，在窗口的出射平面上，光线的高度为 $y_{out} = A y_{in}$，光学方向余弦为 $\\nu_{out} = C y_{in}$。\n窗口后的介质是空气（$n_{out}=1$），所以光线角度为 $u_{out} = \\nu_{out}/n_{out} = \\nu_{out} = C y_{in}$。\n后焦点是该光线与光轴相交的点（$y=0$）。设 $L$ 是从窗口出射面到该点的距离。窗口后的光线路径方程为 $y(z) = y_{out} + z u_{out}$。焦点位于 $z=L$ 处，此时 $y(L)=0$。\n$0 = y_{out} + L u_{out}$\n$L = - \\frac{y_{out}}{u_{out}} = - \\frac{A y_{in}}{C y_{in}} = - \\frac{A}{C}$\n使用系统矩阵计算出的 $A$ 和 $C$ 的值：\n$L = - \\frac{0.516496}{-0.020109} \\approx 25.6865\\,\\mathrm{mm}$\n\n问题要求将结果四舍五入到四位有效数字。\n$L \\approx 25.69\\,\\mathrm{mm}$。",
            "answer": "$$\n\\boxed{25.69}\n$$"
        },
        {
            "introduction": "超越近轴近似，本练习深入探讨了几何光学的完整哈密顿形式，它控制着光线在一般非均匀介质中的传播。你将实现并比较两种数值积分器，以追踪光线在梯度折射率（GRIN）透镜中的路径，从而突显结构保持（辛）算法在保证长期精度和能量守恒方面的关键重要性。这是高级计算光线追踪的核心技能。",
            "id": "3311401",
            "problem": "你的任务是实现并比较两种数值积分器，用于在具有快速变化的折射率的非均匀、各向同性介质中进行几何光学光线传播的模拟，重点关注能量守恒和走时精度。该比较将在一个具有强梯度的梯度折射率 (GRIN) 透镜模型上进行。该任务是基于从费马原理和程函近似推导出的哈密顿光线动力学，以纯数学术语来表述的，最终答案必须是按规定格式给出的一个完整、可运行的程序。\n\n从以下基本原理开始：\n\n- 在折射率为 $n(\\mathbf{x})$ 的非均匀、各向同性、静态介质中，光线遵循费马原理和程函近似，这使其具有一个哈密顿表述，其中正则位置为 $\\mathbf{x} \\in \\mathbb{R}^2$，正则动量为 $\\mathbf{p} \\in \\mathbb{R}^2$，哈密顿量为\n$$\nH(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2}\\left(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x})\\right).\n$$\n- 相应的正则方程为\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\tfrac{1}{2}\\nabla n^2(\\mathbf{x}),\n$$\n其中 $\\tau$ 是一个路径参数，单位为米，使得光学走时 $T$ 满足\n$$\nT = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) \\, d\\tau,\n$$\n其中 $c_0$ 是真空中的光速。\n\n考虑一个二维GRIN透镜，其折射率剖面为\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2,\n$$\n其中 $n_0 \\gt 0$ 为常数，$\\alpha \\gt 0$ 的单位为米^-2。当 $\\alpha$ 很大时，该介质是强非均匀的，导致刚性光线动力学。正则方程变为\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\, \\mathbf{x}.\n$$\n\n任务：\n\n1. 为上述哈密顿系统实现两种时间步进方案：\n   - 一个经典的4阶显式 Runge–Kutta 方法，应用于 $(\\mathbf{x}, \\mathbf{p})$ 的一阶系统。\n   - 一个二阶辛分裂 (Störmer–Verlet) 方法，应用于可分离的哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$，其中 $T(\\mathbf{p}) = \\tfrac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ 且 $V(\\mathbf{x}) = -\\tfrac{1}{2} n^2(\\mathbf{x})$。\n\n2. 对于每种积分器和下面的每个测试用例，将一条光线在 $\\tau$ 中传播一个完整的振荡周期（即，总参数长度为 $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$），使用一个固定的标称步长 $h$，但缩短最后一步以精确到达 $\\tau_{\\text{end}}$。\n\n3. 使用构造的初始条件，以满足在 $\\tau = 0$ 时的几何光学约束 $H=0$：\n   - 设 $r_c = \\tfrac{n_0}{\\sqrt{\\alpha}}$。\n   - 设 $A = \\rho \\, r_c$，其中 $\\rho = 0.6$，并选择 $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$。\n   - 选择 $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$，这确保了 $H(\\mathbf{x}(0),\\mathbf{p}(0)) = 0$。\n\n4. 对于每种积分器和测试用例，评估：\n   - 轨迹上的最大哈密顿量绝对漂移，\n     $$\n     \\Delta H_{\\max} = \\max_{k}\\left|H(\\mathbf{x}_k,\\mathbf{p}_k) - H(\\mathbf{x}_0,\\mathbf{p}_0)\\right|.\n     $$\n     将此值报告为无量纲浮点数。\n   - 绝对走时误差，\n     $$\n     \\left|T_{\\text{num}} - T_{\\text{exact}}\\right|,\n     $$\n     其中 $T_{\\text{num}}$ 是通过对 $\\tfrac{1}{c_0}\\int_0^{\\tau_{\\text{end}}} n^2(\\mathbf{x}(\\tau)) \\, d\\tau$ 应用梯形法则计算得出的，而 $T_{\\text{exact}}$ 是从上述基本原理推导出的该 GRIN 介质中一个完整周期的解析值。将此误差以秒为单位表示为浮点数。\n\n5. 使用常数 $n_0 = 1.6$ (无量纲) 和 $c_0 = 299792458$ (单位为米/秒)。所有位置单位为米，$\\alpha$ 的单位为米^-2，$\\tau$ 的单位为米。\n\n6. 测试套件。对于下面的每一对 $(\\alpha, h)$，运行两种积分器并计算所描述的两个指标。周期为 $\\tau_{\\text{end}} = \\tfrac{2\\pi}{\\sqrt{\\alpha}}$ 米。\n   - 情况 1：$\\alpha = 400$，$h = 0.05$。\n   - 情况 2：$\\alpha = 2500$，$h = 0.039$。\n   - 情况 3：$\\alpha = 25$，$h = 0.3$。\n   - 情况 4：$\\alpha = 10000$，$h = 0.015$。\n\n7. 输出格式。你的程序应该生成单行输出，其中包含测试套件的结果，格式为用方括号括起来的逗号分隔列表。每个测试用例应按以下顺序贡献一个包含四个浮点数的列表\n   $$\n   \\left[\\Delta H_{\\max}^{\\mathrm{RK4}}, \\, \\left|T_{\\text{num}}^{\\mathrm{RK4}} - T_{\\text{exact}}\\right|, \\, \\Delta H_{\\max}^{\\mathrm{SV}}, \\, \\left|T_{\\text{num}}^{\\mathrm{SV}} - T_{\\text{exact}}\\right|\\right],\n   $$\n   其中上标表示所使用的积分器。走时误差必须以秒为单位，哈密顿量漂移是无量纲的。最终输出应如下所示\n   $$\n   \\left[\\,[a_1, b_1, c_1, d_1],[a_2, b_2, c_2, d_2],[a_3, b_3, c_3, d_3],[a_4, b_4, c_4, d_4]\\,\\right],\n   $$\n   其中每个 $a_i$、$b_i$、$c_i$、$d_i$ 都是 Python 格式的浮点数。\n\n如果在您的推导中出现任何角度，都必须以弧度为单位。所有走时值和误差都必须以秒表示。不允许使用百分号；任何分数量都请使用小数表示。",
            "solution": "该问题是有效的，因为它在科学上基于哈密顿力学和几何光学，作为一个标准的初值问题是适定的，并且是自洽的，所有必需的常数、初始条件和程序都已完全指定。\n\n该问题要求实现并比较两种数值积分器，以模拟二维梯度折射率 (GRIN) 介质中的光线传播。比较的重点是系统不变量（哈密顿量）的守恒性以及路径积分量（光学走时）的准确性。\n\n其基本物理原理由哈密顿光线动力学描述。对于折射率为 $n(\\mathbf{x})$ 的介质，光线位置 $\\mathbf{x}(\\tau) \\in \\mathbb{R}^2$ 和动量 $\\mathbf{p}(\\tau) \\in \\mathbb{R}^2$ 的正则方程由哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = \\frac{1}{2}(\\lVert \\mathbf{p} \\rVert^2 - n^2(\\mathbf{x}))$ 导出。运动方程为：\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}\n$$\n$$\n\\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = \\frac{1}{2}\\nabla n^2(\\mathbf{x})\n$$\n此处，$\\tau$ 是一个路径参数。对于物理光线，哈密顿量是一个运动常数，其值被约束为零，即对于所有 $\\tau$ 都有 $H(\\mathbf{x}(\\tau), \\mathbf{p}(\\tau)) = 0$。这意味着沿着光线路径，光线动量矢量的模等于局部折射率：$\\lVert\\mathbf{p}(\\tau)\\rVert = n(\\mathbf{x}(\\tau))$。\n\n特定的介质是具有抛物线剖面的 GRIN 透镜：\n$$\nn^2(\\mathbf{x}) = n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2\n$$\n其中 $n_0$ 和 $\\alpha$ 是正常数。对于此剖面，梯度项为 $\\frac{1}{2}\\nabla n^2(\\mathbf{x}) = \\frac{1}{2}\\nabla(n_0^2 - \\alpha(x^2+y^2)) = -\\alpha\\mathbf{x}$。常微分方程组 (ODEs) 变为：\n$$\n\\frac{d\\mathbf{x}}{d\\tau} = \\mathbf{p}, \\qquad \\frac{d\\mathbf{p}}{d\\tau} = -\\alpha \\mathbf{x}\n$$\n这等价于二阶系统 $\\frac{d^2\\mathbf{x}}{d\\tau^2} + \\alpha\\mathbf{x} = 0$，它描述了一个角频率为 $\\omega = \\sqrt{\\alpha}$ 的简谐振子。\n\n在实现数值求解器之前，我们先推导精确的解析解和精确走时 $T_{\\text{exact}}$，它将作为精度的基准。初始条件指定为 $\\mathbf{x}(0) = [A, 0]^{\\mathsf{T}}$ 和 $\\mathbf{p}(0) = [0, \\sqrt{n_0^2 - \\alpha A^2}]^{\\mathsf{T}}$，其中 $A = \\rho r_c = \\rho n_0 / \\sqrt{\\alpha}$ 且 $\\rho = 0.6$。代入这些值可将初始动量简化为 $\\mathbf{p}(0)=[0, 0.8 n_0]^{\\mathsf{T}}$。谐振子方程的通解是 $\\mathbf{x}(\\tau) = \\mathbf{C}_1 \\cos(\\sqrt{\\alpha}\\tau) + \\mathbf{C}_2 \\sin(\\sqrt{\\alpha}\\tau)$。应用初始条件可得出精确轨迹：\n$$\n\\mathbf{x}(\\tau) = \\begin{bmatrix} A \\cos(\\sqrt{\\alpha}\\tau) \\\\ \\frac{\\sqrt{n_0^2 - \\alpha A^2}}{\\sqrt{\\alpha}} \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix} = \\begin{bmatrix} (0.6 n_0 / \\sqrt{\\alpha}) \\cos(\\sqrt{\\alpha}\\tau) \\\\ (0.8 n_0 / \\sqrt{\\alpha}) \\sin(\\sqrt{\\alpha}\\tau) \\end{bmatrix}\n$$\n参数 $\\tau$ 的振荡周期为 $\\tau_p = 2\\pi/\\sqrt{\\alpha}$。问题要求正好在此周期上进行积分，因此 $\\tau_{\\text{end}} = 2\\pi/\\sqrt{\\alpha}$。\n\n光学走时 $T$ 由 $T = \\frac{1}{c_0} \\int n^2(\\mathbf{x}(\\tau)) d\\tau$ 给出。由于沿真实路径 $H=0$，我们有 $n^2(\\mathbf{x}(\\tau)) = \\lVert\\mathbf{p}(\\tau)\\rVert^2$。我们可以计算 $\\mathbf{p}(\\tau) = \\frac{d\\mathbf{x}}{d\\tau}$ 并对其模的平方进行积分，但一个更简洁的推导精确走时 $T_{\\text{exact}}$ 的方法如下：\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\int_{0}^{\\tau_{\\text{end}}} \\left( n_0^2 - \\alpha \\lVert \\mathbf{x}(\\tau) \\rVert^2 \\right) d\\tau\n$$\n我们需要计算 $\\lVert \\mathbf{x}(\\tau) \\rVert^2$ 的积分：\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\int_{0}^{2\\pi/\\sqrt{\\alpha}} \\left( A^2 \\cos^2(\\sqrt{\\alpha}\\tau) + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\sin^2(\\sqrt{\\alpha}\\tau) \\right) d\\tau\n$$\n使用定积分 $\\int_0^{2\\pi} \\cos^2\\theta d\\theta = \\pi$ 和 $\\int_0^{2\\pi} \\sin^2\\theta d\\theta = \\pi$，并通过换元 $\\theta = \\sqrt{\\alpha}\\tau$，我们得到：\n$$\n\\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau = \\frac{1}{\\sqrt{\\alpha}} \\left( A^2 \\pi + \\frac{n_0^2 - \\alpha A^2}{\\alpha} \\pi \\right) = \\frac{\\pi}{\\alpha\\sqrt{\\alpha}} \\left( \\alpha A^2 + n_0^2 - \\alpha A^2 \\right) = \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}}\n$$\n将此结果代回 $T_{\\text{exact}}$ 的表达式中：\n$$\nT_{\\text{exact}} = \\frac{1}{c_0} \\left( n_0^2 \\tau_{\\text{end}} - \\alpha \\int_{0}^{\\tau_{\\text{end}}} \\lVert \\mathbf{x}(\\tau) \\rVert^2 d\\tau \\right) = \\frac{1}{c_0} \\left( n_0^2 \\frac{2\\pi}{\\sqrt{\\alpha}} - \\alpha \\frac{\\pi n_0^2}{\\alpha\\sqrt{\\alpha}} \\right) = \\frac{n_0^2 \\pi}{c_0 \\sqrt{\\alpha}}\n$$\n这个简单的公式为我们提供了用于比较的精确走时。\n\n接下来，我们详细说明数值积分器。系统状态是一个四维向量 $\\mathbf{y} = [\\mathbf{x}^{\\mathsf{T}}, \\mathbf{p}^{\\mathsf{T}}]^{\\mathsf{T}} = [x, y, p_x, p_y]^{\\mathsf{T}}$。该 ODE 系统为 $\\frac{d\\mathbf{y}}{d\\tau} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{f}(\\mathbf{y}) = [p_x, p_y, -\\alpha x, -\\alpha y]^{\\mathsf{T}}$。\n\n第一个积分器是经典的四阶 Runge-Kutta 方法 (RK4)。对于步长 $h$，从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的一个步长计算如下：\n$$\n\\mathbf{k}_1 = h \\, \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_1/2)\n$$\n$$\n\\mathbf{k}_3 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_2/2)\n$$\n$$\n\\mathbf{k}_4 = h \\, \\mathbf{f}(\\mathbf{y}_n + \\mathbf{k}_3)\n$$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nRK4 是一种通用积分器，并非为保持哈密顿系统的几何结构（如辛性）而设计。\n\n第二个积分器是二阶 Störmer-Verlet (SV) 方法，这是一种辛积分器，非常适用于形式为 $H(\\mathbf{x}, \\mathbf{p}) = T(\\mathbf{p}) + V(\\mathbf{x})$ 的可分离哈密顿量。在我们的例子中，$T(\\mathbf{p}) = \\frac{1}{2}\\lVert \\mathbf{p} \\rVert^2$ 且 $V(\\mathbf{x}) = -\\frac{1}{2}n^2(\\mathbf{x}) = -\\frac{1}{2}(n_0^2 - \\alpha \\lVert \\mathbf{x} \\rVert^2)$。力为 $\\mathbf{F}(\\mathbf{x}) = -\\nabla V(\\mathbf{x}) = -\\alpha\\mathbf{x}$。对于步长 $h$，位置-Verlet 更新格式的一个步长计算如下：\n$$\n\\mathbf{p}_{n+1/2} = \\mathbf{p}_n + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_n) = \\mathbf{p}_n - \\frac{h}{2} \\alpha \\mathbf{x}_n\n$$\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + h \\mathbf{p}_{n+1/2}\n$$\n$$\n\\mathbf{p}_{n+1} = \\mathbf{p}_{n+1/2} + \\frac{h}{2} \\mathbf{F}(\\mathbf{x}_{n+1}) = \\mathbf{p}_{n+1/2} - \\frac{h}{2} \\alpha \\mathbf{x}_{n+1}\n$$\n该方法是时间可逆的，并能保持辛二形式，这使得它对于哈密顿系统具有出色的长期稳定性和有界的能量误差。\n\n对于每种积分器和每个测试用例，我们都进行一次从 $\\tau=0$ 到 $\\tau_{\\text{end}}$ 的模拟。大小为 $h$ 的完整步数为 $N = \\lfloor\\tau_{\\text{end}}/h\\rfloor$。最后一步的步长较小，为 $h_{\\text{last}} = \\tau_{\\text{end}} - N h$，以精确到达目标时间。在每个时间点 $\\tau_k$ 的轨迹 $(\\mathbf{x}_k, \\mathbf{p}_k)$ 都会被存储。\n\n评估指标从存储的轨迹计算得出。\n最大哈密顿量漂移计算如下：\n$$\n\\Delta H_{\\max} = \\max_{k} \\left| H(\\mathbf{x}_k, \\mathbf{p}_k) - H(\\mathbf{x}_0, \\mathbf{p}_0) \\right|\n$$\n由于初始条件的构造使得 $H(\\mathbf{x}_0, \\mathbf{p}_0) = 0$，这可简化为 $\\Delta H_{\\max} = \\max_{k} | \\frac{1}{2}(\\lVert\\mathbf{p}_k\\rVert^2 - (n_0^2 - \\alpha\\lVert\\mathbf{x}_k\\rVert^2)) |$。\n\n数值走时 $T_{\\text{num}}$ 是使用梯形法则对存储在时间点 $\\tau_k$ 的 $n^2(\\mathbf{x}_k)$ 值进行计算的：\n$$\nT_{\\text{num}} = \\frac{1}{c_0} \\sum_{k=0}^{M-1} \\frac{n^2(\\mathbf{x}_k) + n^2(\\mathbf{x}_{k+1})}{2} (\\tau_{k+1}-\\tau_k)\n$$\n其中 $M$ 是总步数。绝对误差则为 $|T_{\\text{num}} - T_{\\text{exact}}|$。\n\n实现将包括每个积分器步长的函数、一个应用所选积分器并收集轨迹数据的主模拟循环，以及一个用于遍历所有测试用例并按指定格式格式化结果的顶层脚本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Global constants\n    n0 = 1.6  # Dimensionless\n    c0 = 299792458.0  # m/s\n    rho = 0.6  # Dimensionless\n\n    # Test suite: (alpha [m^-2], h [m])\n    test_cases = [\n        (400.0, 0.05),\n        (2500.0, 0.039),\n        (25.0, 0.3),\n        (10000.0, 0.015),\n    ]\n\n    results = []\n    for alpha, h in test_cases:\n        # Calculate case-specific parameters\n        sqrt_alpha = np.sqrt(alpha)\n        tau_end = 2.0 * np.pi / sqrt_alpha\n\n        # Initial conditions\n        A = rho * n0 / sqrt_alpha\n        x0 = np.array([A, 0.0])\n        p0 = np.array([0.0, 0.8 * n0])\n\n        # Exact travel time\n        t_exact = (n0**2 * np.pi) / (c0 * sqrt_alpha)\n\n        # Run RK4 simulation\n        h_drift_rk4, t_err_rk4 = run_simulation(\n            \"rk4\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        # Run Störmer-Verlet simulation\n        h_drift_sv, t_err_sv = run_simulation(\n            \"sv\", alpha, h, tau_end, x0, p0, n0, c0, t_exact\n        )\n\n        results.append([h_drift_rk4, t_err_rk4, h_drift_sv, t_err_sv])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(integrator_name, alpha, h, tau_end, x0, p0, n0, c0, t_exact):\n    \"\"\"\n    Runs a single simulation for a given integrator and returns the metrics.\n    \"\"\"\n    # Initialize trajectory storage\n    tau = 0.0\n    x, p = x0.copy(), p0.copy()\n    \n    tau_vals = [tau]\n    x_traj = [x]\n    p_traj = [p]\n\n    # Integration loop\n    while tau  tau_end:\n        step_h = min(h, tau_end - tau)\n        if step_h  1e-12: # Avoid tiny final steps\n            break\n\n        if integrator_name == \"rk4\":\n            y = np.concatenate((x, p))\n            k1 = step_h * f_ode(y, alpha)\n            k2 = step_h * f_ode(y + 0.5 * k1, alpha)\n            k3 = step_h * f_ode(y + 0.5 * k2, alpha)\n            k4 = step_h * f_ode(y + k3, alpha)\n            y_next = y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            x, p = y_next[:2], y_next[2:]\n        elif integrator_name == \"sv\":\n            p_half = p - (step_h / 2.0) * alpha * x\n            x_next = x + step_h * p_half\n            p = p_half - (step_h / 2.0) * alpha * x_next\n            x = x_next\n        \n        tau += step_h\n        \n        tau_vals.append(tau)\n        x_traj.append(x)\n        p_traj.append(p)\n    \n    # Calculate metrics\n    x_traj_arr = np.array(x_traj)\n    p_traj_arr = np.array(p_traj)\n    tau_vals_arr = np.array(tau_vals)\n\n    # Hamiltonian drift\n    n_sq_vals = n0**2 - alpha * np.sum(x_traj_arr**2, axis=1)\n    p_sq_vals = np.sum(p_traj_arr**2, axis=1)\n    hamiltonian_vals = 0.5 * (p_sq_vals - n_sq_vals)\n    h_drift_max = np.max(np.abs(hamiltonian_vals)) # H(0)=0\n\n    # Travel time error\n    t_num = np.trapz(n_sq_vals, tau_vals_arr) / c0\n    t_error = np.abs(t_num - t_exact)\n\n    return h_drift_max, t_error\n\ndef f_ode(y, alpha):\n    \"\"\"\n    Derivative function for the 4D state vector y = [x, y, px, py].\n    \"\"\"\n    x, y_coord, px, py = y\n    return np.array([px, py, -alpha * x, -alpha * y_coord])\n\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在前向光线追迹的基础上，这最后一个练习将挑战逆问题：设计一个光学元件以实现预期的效果。你将使用强大的伴随方法，高效地计算一个折射面的形状梯度，目标是在靶面上塑造出特定的辐照度分布。这项练习介绍了一种在计算光学领域广泛用于优化和自动化设计的先进技术。",
            "id": "3311421",
            "problem": "考虑一个由标量高度函数 $s(x;p)$ 描述的二维折射界面，其中 $x$ 是横向坐标，$p$ 表示形状参数矢量。一束准直光线从折射率为 $n_1$ 的均匀介质中入射，并沿 $y$ 轴负方向传播，在 $y=s(x;p)$ 处与折射界面相交，然后折射进入折射率为 $n_2$ 的第二种均匀介质中。折射后的光线随后传播到位于 $y=Y_t$ 的平面目标上，在目标上产生一个辐照度分布。任务是使用伴随射线追踪计算能量匹配目标函数的形状梯度，并通过有限差分验证梯度的准确性。\n\n基本原理：\n- 使用源自 Fermat 原理的 Snell 折射定律：对于单位入射方向 $\\mathbf{I}$ 和界面处的单位法向量 $\\mathbf{N}$，单位折射方向 $\\mathbf{T}$ 遵循矢量形式 $\\mathbf{T}=\\eta\\,\\mathbf{I}+(\\eta\\,\\cos\\theta_i-\\cos\\theta_t)\\,\\mathbf{N}$，其中 $\\eta=n_1/n_2$，$\\cos\\theta_i=-\\mathbf{N}\\cdot\\mathbf{I}$，且在不发生全内反射的情况下 $\\cos\\theta_t=\\sqrt{1-\\eta^2(1-\\cos^2\\theta_i)}$。\n- 使用几何光学中的局部能量守恒：目标上的辐照度可以通过一个平滑核函数对 Dirac delta 分布进行近似，将输入光线的能量传输到目标上表示。\n\n模型与离散化：\n- 界面是一条旋转对称曲线，参数化为 $s(x;p)=p_0+p_2 x^2$，其中 $p_0$ 是轴向偏移量（单位为 $\\mathrm{m}$），$p_2$ 是二次曲率系数（单位为 $\\mathrm{m}^{-1}$）。\n- 入射光线在孔径 $x\\in[-W,W]$ 上均匀分布，光线位置为 $\\{x_i\\}_{i=1}^{N}$，具有恒定的输入辐照度密度 $I_0$（单位为 $\\mathrm{W/m}$）。每条光线携带的能量为 $w_i=I_0\\,\\Delta x$，其中 $\\Delta x=\\frac{2W}{N-1}$ 是光线采样间隔（单位为 $\\mathrm{m}$）。\n- 在界面上的点 $x_i$ 处，单位法向量由表面斜率 $s'(x_i;p)$ 构建，为 $\\mathbf{N}=\\frac{1}{\\sqrt{1+(s')^2}}(-s',1)$，单位入射方向为 $\\mathbf{I}=(0,-1)$。折射方向 $\\mathbf{T}=(T_x,T_y)$ 由 Snell 定律得到。\n- 从 $(x_i,s(x_i;p))$ 出发的折射光线与位于 $y=Y_t$ 的目标平面相交，交点的横向位置 $x_t(x_i;p)$ 由 $x_t(x_i;p)=x_i+T_x\\,t_i$ 给出，其中 $t_i=\\frac{Y_t-s(x_i;p)}{T_y}$ 是传播参数。\n- 目标辐照度在一个指定范围内的均匀网格 $\\{x_k\\}_{k=1}^{M}$ 上计算，使用归一化高斯核函数 $\\varphi_\\sigma(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right)$（单位为 $\\mathrm{m}^{-1}$）来近似将每条光线能量传输到目标的 Dirac delta 函数。数值计算的辐照度为 $I_{\\text{num}}(x_k;p)=\\sum_{i=1}^{N}w_i\\,\\varphi_\\sigma(x_k-x_t(x_i;p))$（单位为 $\\mathrm{W/m}$）。\n- 目标规定分布是一个归一化高斯函数 $I_{\\text{tgt}}(x_k)=\\frac{P}{\\sqrt{2\\pi}\\sigma_t}\\exp\\!\\left(-\\frac{x_k^2}{2\\sigma_t^2}\\right)$（单位为 $\\mathrm{W/m}$），其中 $P=I_0\\cdot 2W$ 是总输入功率（单位为 $\\mathrm{W}$），$\\sigma_t$ 是目标宽度（单位为 $\\mathrm{m}$）。\n\n目标函数：\n- 定义最小二乘失配函数 $J(p)=\\frac{1}{2}\\sum_{k=1}^{M}\\left(I_{\\text{num}}(x_k;p)-I_{\\text{tgt}}(x_k)\\right)^2\\,\\Delta x_{\\text{tgt}}$，其中 $\\Delta x_{\\text{tgt}}$ 是目标网格间距（单位为 $\\mathrm{m}$）。\n\n伴随射线追踪梯度：\n- 通过从目标平面到界面的反向累积，推导基于伴随的形状梯度 $\\nabla_p J$。使用链式法则，结合核函数导数 $\\varphi'_\\sigma(x)=-\\frac{x}{\\sigma^2}\\varphi_\\sigma(x)$ 以及 $x_t$ 关于 $(p_0,p_2)$ 且通过 $(s,s')$ 的几何导数。\n- 每条光线所需的几何导数是 $\\frac{\\partial x_t}{\\partial s}$ 和 $\\frac{\\partial x_t}{\\partial s'}$，它们从折射运动学和与目标平面的交点推导得出，然后通过 $\\frac{\\partial x_t}{\\partial p_0}=\\frac{\\partial x_t}{\\partial s}$ 和 $\\frac{\\partial x_t}{\\partial p_2}=x_i^2\\frac{\\partial x_t}{\\partial s}+2x_i\\frac{\\partial x_t}{\\partial s'}$ 将它们组合起来。\n\n通过有限差分进行验证：\n- 通过与中心有限差分近似进行比较来验证伴随梯度，其中使用小的微扰量 $\\delta_{p_0}$（单位为 $\\mathrm{m}$）和 $\\delta_{p_2}$（单位为 $\\mathrm{m}^{-1}$）。\n\n单位与输出：\n- 所有距离都必须以 $\\mathrm{m}$ 为单位，折射率为无量纲，辐照度单位为 $\\mathrm{W/m}$。角度不直接使用；方向由单位矢量表示。\n- 对于每个指定的测试用例，您的程序必须计算伴随梯度和有限差分梯度之间关于两个参数 $p_0$ 和 $p_2$ 的相对误差，定义为 $\\frac{\\left|\\text{grad}_{\\text{adj}}-\\text{grad}_{\\text{fd}}\\right|}{\\max\\left(\\left|\\text{grad}_{\\text{fd}}\\right|,10^{-12}\\right)}$，每个测试用例产生两个浮点数。\n- 最终输出必须是包含一个 Python 列表的列表的单行文本，其中每个内部列表对应一个测试用例，并按 $[e_{p_0},e_{p_2}]$ 的顺序包含两个相对梯度误差的浮点数。\n\n测试套件：\n- 使用以下三个案例，它们共同考察了典型行为、近边界的平坦表面条件以及具有更高折射率对比度的更强曲率。对于每个案例，指定 $(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})$：\n    - 案例 $1$（通用聚焦）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.5,0.02,201,0.20,0.002,0.010,1.0,0.0,50.0,0.04,801,10^{-6},10^{-6})$。\n    - 案例 $2$（平坦界面边界情况）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.2,0.02,201,0.20,0.002,0.010,1.0,0.0,0.0,0.04,801,10^{-6},10^{-6})$。\n    - 案例 $3$（强曲率，高对比度）：$(n_1,n_2,W,N,Y_t,\\sigma,\\sigma_t,I_0,p_0,p_2,X_{\\max},M,\\delta_{p_0},\\delta_{p_2})=(1.0,1.7,0.015,301,0.15,0.001,0.008,1.0,0.0,300.0,0.03,601,10^{-6},10^{-6})$。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的 Python 列表的列表形式的结果，例如 $[\\,[e_{p_0}^{(1)},e_{p_2}^{(1)}],\\,[e_{p_0}^{(2)},e_{p_2}^{(2)}],\\,[e_{p_0}^{(3)},e_{p_2}^{(3)}]\\,]$，其中上标表示测试用例的索引。\n\n要求：\n- 从第一性原理出发，使用 Snell 定律实现前向射线追踪。\n- 实现从目标失配到表面参数的伴随梯度累积。\n- 实现用于验证的中心有限差分。\n- 通过避免全内反射并使用指定的有限差分小微扰量来确保数值稳定性。",
            "solution": "用户提供了一个计算光学领域中有效且适定的问题。任务是使用伴随方法计算最小二乘目标函数的形状梯度，并对照有限差分近似来验证其准确性。该光学系统由一个由二次曲线定义的单一折射界面组成，该界面分隔了两种均匀介质。\n\n解决方案将分为三个主要部分呈现：\n1.  **前向模型**：本节描述了从光源到目标平面追踪光线并计算最终的辐照度分布和目标函数的过程。\n2.  **伴随模型**：本节详细介绍了使用伴随状态法推导目标函数相对于形状参数的梯度。这涉及到从目标平面向折射界面反向传播灵敏度。\n3.  **验证**：本节概述了用于获得梯度数值近似的中心有限差分法，该方法可作为验证解析伴随梯度的基准。\n\n### 1. 前向模型：射线追踪与目标函数\n\n前向模型模拟了光传播和相互作用的物理过程。\n\n**1.1. 射线生成与界面相互作用**\n在输入孔径 $x \\in [-W, W]$ 上的均匀网格 $\\{x_i\\}$ 上初始化一组 $N$ 条光线。每条光线沿 $y$ 轴负方向传播，初始方向矢量为 $\\mathbf{I} = (0, -1)$，携带能量 $w = I_0 \\Delta x$，其中 $\\Delta x = \\frac{2W}{N-1}$。\n\n对于在横向位置 $x_i$ 入射的每条光线 $i$，它在点 $(x_i, s_i = s(x_i; p))$ 处与折射界面 $s(x; p) = p_0 + p_2 x^2$ 相交。在此点，表面斜率为 $s'_i = \\frac{\\partial s}{\\partial x}(x_i; p) = 2p_2 x_i$。指向第一介质（向上）的界面单位法向量由下式给出：\n$$\n\\mathbf{N}_i = \\frac{1}{\\sqrt{1 + (s'_i)^2}}(-s'_i, 1)\n$$\n入射方向为 $\\mathbf{I}=(0,-1)$。入射角 $\\theta_i$ 的余弦计算为 $\\cos\\theta_i = -\\mathbf{N}_i \\cdot \\mathbf{I} = N_{iy} = (1+(s'_i)^2)^{-1/2}$。\n\n**1.2. 通过 Snell 定律折射**\n折射光线方向 $\\mathbf{T}_i = (T_{ix}, T_{iy})$ 由 Snell 定律的矢量形式确定：\n$$\n\\mathbf{T}_i = \\eta \\mathbf{I} + (\\eta \\cos\\theta_i - \\cos\\theta_t) \\mathbf{N}_i\n$$\n其中 $\\eta = n_1/n_2$ 是相对折射率，$\\cos\\theta_t = \\sqrt{1 - \\eta^2(1 - \\cos^2\\theta_i)}$。由于所有测试案例都满足 $n_1  n_2$，即 $\\eta  1$，因此不会发生全内反射。\n通过展开矢量方程，我们可以推导出折射方向的 $x$ 分量 $T_{ix}$ 作为斜率 $s'_i$ 的显式表达式：\n$$\nT_{ix} = \\frac{-s'_i}{1+(s'_i)^2} \\left(\\eta - \\sqrt{1+(s'_i)^2(1-\\eta^2)}\\right)\n$$\n由于 $\\mathbf{T}_i$ 是单位矢量，因此 $T_{ix}^2 + T_{iy}^2 = 1$。物理情景决定了光线向目标平面传播，所以必须有 $T_{iy}  0$。因此，$T_{iy} = -\\sqrt{1 - T_{ix}^2}$。\n\n**1.3. 向目标传播与辐照度计算**\n从 $(x_i, s_i)$ 出发的折射光线传播到位于 $y=Y_t$ 的目标平面。传播参数 $t_i$ 由光线路径的 $y$ 分量确定：$Y_t = s_i + T_{iy} t_i$，这给出 $t_i = (Y_t - s_i) / T_{iy}$。光线在目标上的横向位置为：\n$$\nx_{t,i} = x_i + T_{ix} t_i\n$$\n目标上的辐照度在一个包含 $M$ 个点的均匀网格 $\\{x_k\\}$ 上计算。每条光线的能量使用归一化高斯核函数 $\\varphi_\\sigma(z)$ 分布到此网格上，以近似一个 Dirac delta 函数。每个网格点 $x_k$ 的数值辐照度是所有 $N$ 条光线贡献的总和：\n$$\nI_{\\text{num}}(x_k; p) = \\sum_{i=1}^{N} w \\, \\varphi_\\sigma(x_k - x_{t,i}(p))\n$$\n\n**1.4. 目标函数**\n目标是将计算出的辐照度 $I_{\\text{num}}$ 与规定的目标辐照度 $I_{\\text{tgt}}$ 相匹配。失配程度由最小二乘目标函数 $J(p)$ 量化：\n$$\nJ(p) = \\frac{1}{2} \\sum_{k=1}^{M} (I_{\\text{num}}(x_k; p) - I_{\\text{tgt}}(x_k))^2 \\Delta x_{\\text{tgt}}\n$$\n其中 $\\Delta x_{\\text{tgt}}$ 是目标网格点的间距。\n\n### 2. 伴随模型：梯度计算\n\n伴随方法通过避免重复的前向模拟，提供了一种计算梯度 $\\nabla_p J$ 的高效方式。它依赖于链式法则将灵敏度从目标函数反向传播到设计参数。\n\n**2.1. 目标函数的梯度**\n$J$ 相对于参数 $p_j$（其中 $j \\in \\{0, 2\\}$）的梯度为：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{k=1}^{M} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} \\Delta x_{\\text{tgt}}\n$$\n数值辐照度的导数为：\n$$\n\\frac{\\partial I_{\\text{num}}(x_k)}{\\partial p_j} = \\sum_{i=1}^{N} w \\, \\varphi'_\\sigma(x_k - x_{t,i}) \\left( -\\frac{\\partial x_{t,i}}{\\partial p_j} \\right)\n$$\n其中 $\\varphi'_\\sigma$ 是高斯核的导数。代入并重新整理求和项，我们得到：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\left( -w \\sum_{k=1}^{M} \\Delta x_{\\text{tgt}} (I_{\\text{num}}(x_k) - I_{\\text{tgt}}(x_k)) \\varphi'_\\sigma(x_k-x_{t,i}) \\right) \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n括号中的项是伴随变量或灵敏度 $\\bar{x}_{t,i}$，它表示光线目标位置 $x_{t,i}$ 的微小变化对目标函数 $J$ 总变化的贡献。\n$$\n\\bar{x}_{t,i} = \\frac{\\partial J}{\\partial x_{t,i}}\n$$\n因此，总梯度是所有光线的累加：\n$$\n\\frac{\\partial J}{\\partial p_j} = \\sum_{i=1}^{N} \\bar{x}_{t,i} \\frac{\\partial x_{t,i}}{\\partial p_j}\n$$\n\n**2.2. 几何灵敏度**\n最后一步是求几何灵敏度 $\\frac{\\partial x_{t,i}}{\\partial p_j}$。我们使用局部表面高度 $s_i$ 和斜率 $s'_i$ 作为中间变量。根据链式法则：\n$$\n\\frac{\\partial x_{t,i}}{\\partial p_j} = \\frac{\\partial x_{t,i}}{\\partial s_i}\\frac{\\partial s_i}{\\partial p_j} + \\frac{\\partial x_{t,i}}{\\partial s'_i}\\frac{\\partial s'_i}{\\partial p_j}\n$$\n根据 $s_i = p_0 + p_2 x_i^2$ 和 $s'_i = 2p_2 x_i$，我们有：\n*   $\\frac{\\partial s_i}{\\partial p_0} = 1$, $\\frac{\\partial s'_i}{\\partial p_0} = 0 \\implies \\frac{\\partial x_{t,i}}{\\partial p_0} = \\frac{\\partial x_{t,i}}{\\partial s_i}$\n*   $\\frac{\\partial s_i}{\\partial p_2} = x_i^2$, $\\frac{\\partial s'_i}{\\partial p_2} = 2x_i \\implies \\frac{\\partial x_{t,i}}{\\partial p_2} = x_i^2 \\frac{\\partial x_{t,i}}{\\partial s_i} + 2x_i \\frac{\\partial x_{t,i}}{\\partial s'_i}$\n\n目标位置 $x_t$ 相对于 $s$ 和 $s'$ 的导数可以从 $x_t = x + T_x(s') \\frac{Y_t - s}{T_y(s')}$ 推导得出：\n$$\n\\frac{\\partial x_t}{\\partial s} = \\frac{\\partial}{\\partial s}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = -\\frac{T_x}{T_y}\n$$\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{\\partial}{\\partial s'}\\left(x + T_x \\frac{Y_t-s}{T_y}\\right) = (Y_t-s)\\frac{\\partial}{\\partial s'}\\left(\\frac{T_x}{T_y}\\right) = t \\left( \\frac{\\partial T_x}{\\partial s'} - \\frac{T_x}{T_y}\\frac{\\partial T_y}{\\partial s'}\\right)\n$$\n利用属性 $T_x^2+T_y^2=1$（这意味着 $T_x \\frac{\\partial T_x}{\\partial s'} + T_y \\frac{\\partial T_y}{\\partial s'} = 0$），表达式简化为：\n$$\n\\frac{\\partial x_t}{\\partial s'} = \\frac{t}{T_y^2} \\frac{\\partial T_x}{\\partial s'}\n$$\n导数 $\\frac{\\partial T_x}{\\partial s'}$ 通过对 $T_x(s')$ 的显式表达式求导得到。\n\n有了这些分量，就可以组装并计算完整的伴随梯度。\n\n### 3. 通过有限差分进行验证\n\n为了验证所推导的伴随梯度的正确性，我们将其与使用中心有限差分公式获得的数值近似进行比较。对于每个参数 $p_j$，梯度近似为：\n$$\n\\frac{\\partial J}{\\partial p_j} \\approx \\frac{J(p + \\delta_j \\mathbf{e}_j) - J(p - \\delta_j \\mathbf{e}_j)}{2\\delta_j}\n$$\n其中 $\\mathbf{e}_j$ 是标准基向量，$\\delta_j$ 是一个小的微扰量（例如 $10^{-6}$）。这需要对每个参数额外计算两次目标函数 $J$。伴随梯度 $(\\text{grad}_{\\text{adj}})$ 和有限差分梯度 $(\\text{grad}_{\\text{fd}})$ 之间的相对误差计算如下：\n$$\n\\text{Error} = \\frac{|\\text{grad}_{\\text{adj}} - \\text{grad}_{\\text{fd}}|}{\\max(|\\text{grad}_{\\text{fd}}|, 10^{-12})}\n$$\n一个小的相对误差（通常接近机器精度或有限差分近似的精度）证实了复杂伴随方法实现的正确性。",
            "answer": "```python\nimport numpy as np\n\nclass SimulationParameters:\n    \"\"\"A helper class to hold all simulation parameters for a given case.\"\"\"\n    def __init__(self, n1, n2, W, N, Yt, sigma, sigma_t, I0, p0, p2, Xmax, M, delta_p0, delta_p2):\n        self.n1 = n1\n        self.n2 = n2\n        self.eta = n1 / n2\n        self.W = W\n        self.N = N\n        self.Yt = Yt\n        self.sigma = sigma\n        self.sigma_t = sigma_t\n        self.I0 = I0\n        self.p_vec = np.array([p0, p2], dtype=float)\n        self.Xmax = Xmax\n        self.M = M\n        self.delta_p = np.array([delta_p0, delta_p2], dtype=float)\n\n        # Derived parameters\n        self.x_in = np.linspace(-self.W, self.W, self.N)\n        self.dx_in = (2.0 * self.W) / (self.N - 1) if self.N > 1 else 0\n        self.ray_energy = self.I0 * self.dx_in\n        self.P_total = self.I0 * 2.0 * self.W\n        \n        self.x_target_grid = np.linspace(-self.Xmax, self.Xmax, self.M)\n        self.dx_target = (2.0 * self.Xmax) / (self.M - 1) if self.M > 1 else 0\n\ndef gaussian_kernel(x, sigma):\n    \"\"\"Computes the value of a Gaussian kernel.\"\"\"\n    return (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-x**2 / (2.0 * sigma**2))\n\ndef gaussian_kernel_deriv(x, sigma):\n    \"\"\"Computes the derivative of a Gaussian kernel.\"\"\"\n    return -x / sigma**2 * gaussian_kernel(x, sigma)\n\ndef compute_objective_and_intermediates(p_vec, params):\n    \"\"\"Performs forward ray tracing and computes the objective function J and intermediate values.\"\"\"\n    p0, p2 = p_vec\n    \n    x_i = params.x_in\n    s_i = p0 + p2 * x_i**2\n    s_prime_i = 2.0 * p2 * x_i\n\n    s_prime_sq = s_prime_i**2\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - params.eta**2)\n    # This check is formally not needed since eta  1, but is good practice.\n    if np.any(term_in_sqrt  0):\n        raise ValueError(\"Total Internal Reflection encountered, problem is ill-defined for these parameters.\")\n    \n    sqrt_term = np.sqrt(term_in_sqrt)\n    Tx = (-s_prime_i * (params.eta - sqrt_term)) / (1.0 + s_prime_sq)\n    \n    Ty_sq = 1.0 - Tx**2\n    Ty_sq[Ty_sq  0] = 0.0\n    Ty = -np.sqrt(Ty_sq)\n\n    t_i = (params.Yt - s_i) / Ty\n    x_t = x_i + Tx * t_i\n\n    delta_x = params.x_target_grid[:, np.newaxis] - x_t[np.newaxis, :]\n    I_num = params.ray_energy * np.sum(gaussian_kernel(delta_x, params.sigma), axis=1)\n\n    I_tgt = (params.P_total / (np.sqrt(2.0 * np.pi) * params.sigma_t)) * \\\n            np.exp(-params.x_target_grid**2 / (2.0 * params.sigma_t**2))\n\n    J = 0.5 * np.sum((I_num - I_tgt)**2) * params.dx_target\n    \n    intermediates = {\n        'x_i': x_i, 's_prime_i': s_prime_i, 'Tx': Tx, 'Ty': Ty, 't_i': t_i,\n        'I_num': I_num, 'I_tgt': I_tgt, 'delta_x': delta_x\n    }\n    \n    return J, intermediates\n\ndef compute_adjoint_gradient(p_vec, params):\n    \"\"\"Computes the gradient of the objective function using the adjoint method.\"\"\"\n    _, intermediates = compute_objective_and_intermediates(p_vec, params)\n    \n    x_i = intermediates['x_i']\n    s_prime_i = intermediates['s_prime_i']\n    Tx, Ty, t_i = intermediates['Tx'], intermediates['Ty'], intermediates['t_i']\n    I_num, I_tgt, delta_x = intermediates['I_num'], intermediates['I_tgt'], intermediates['delta_x']\n    \n    mismatch = (I_num - I_tgt)[:, np.newaxis]\n    kernel_deriv = gaussian_kernel_deriv(delta_x, params.sigma)\n    x_t_bar = -params.ray_energy * params.dx_target * np.sum(mismatch * kernel_deriv, axis=0)\n    \n    dxt_ds = -Tx / Ty\n    \n    s_prime_sq = s_prime_i**2\n    eta_sq = params.eta**2\n    \n    f = -s_prime_i / (1.0 + s_prime_sq)\n    f_prime = (s_prime_sq - 1.0) / (1.0 + s_prime_sq)**2\n\n    term_in_sqrt = 1.0 + s_prime_sq * (1.0 - eta_sq)\n    sqrt_term = np.sqrt(term_in_sqrt)\n    g = params.eta - sqrt_term\n    \n    g_prime = np.zeros_like(s_prime_i)\n    # Avoid division by zero when s_prime_i is 0\n    # The derivative at s_prime=0 is 0, so this is correct.\n    nonzero_s_prime = np.abs(s_prime_i) > 1e-12\n    g_prime[nonzero_s_prime] = -s_prime_i[nonzero_s_prime] * (1.0 - eta_sq) / sqrt_term[nonzero_s_prime]\n\n    dTx_ds_prime = f_prime * g + f * g_prime\n    dxt_ds_prime = (t_i / Ty**2) * dTx_ds_prime\n    \n    grad_p0 = np.sum(x_t_bar * dxt_ds)\n    grad_p2 = np.sum(x_t_bar * (dxt_ds * x_i**2 + dxt_ds_prime * 2.0 * x_i))\n    \n    return np.array([grad_p0, grad_p2])\n\ndef compute_fd_gradient(p_vec, params):\n    \"\"\"Computes the gradient using central finite differences for verification.\"\"\"\n    grad_fd = np.zeros_like(p_vec, dtype=float)\n    for i in range(len(p_vec)):\n        p_plus = p_vec.copy()\n        p_minus = p_vec.copy()\n        p_plus[i] += params.delta_p[i]\n        p_minus[i] -= params.delta_p[i]\n        \n        J_plus, _ = compute_objective_and_intermediates(p_plus, params)\n        J_minus, _ = compute_objective_and_intermediates(p_minus, params)\n        \n        grad_fd[i] = (J_plus - J_minus) / (2.0 * params.delta_p[i])\n        \n    return grad_fd\n    \ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        (1.0, 1.5, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 50.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.2, 0.02, 201, 0.20, 0.002, 0.010, 1.0, 0.0, 0.0, 0.04, 801, 1e-6, 1e-6),\n        (1.0, 1.7, 0.015, 301, 0.15, 0.001, 0.008, 1.0, 0.0, 300.0, 0.03, 601, 1e-6, 1e-6)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        params = SimulationParameters(*case)\n        \n        grad_adj = compute_adjoint_gradient(params.p_vec, params)\n        grad_fd = compute_fd_gradient(params.p_vec, params)\n        \n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_errors = np.abs(grad_adj - grad_fd) / denominator\n        \n        results.append(rel_errors.tolist())\n\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}