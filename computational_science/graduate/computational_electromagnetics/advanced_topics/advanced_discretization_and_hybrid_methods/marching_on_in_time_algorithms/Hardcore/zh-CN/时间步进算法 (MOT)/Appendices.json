{
    "hands_on_practices": [
        {
            "introduction": "因果性是物理学的一块基石，它规定了任何效应都不能先于其原因发生。在电磁学中，这意味着信号的传播速度不能超过光速 $c$。这个练习  提供了一种实用的方法，用于以编程方式检验数值时间步进（MOT）仿真是否违背了这一基本物理原理，这对于确保仿真结果的物理真实性至关重要。",
            "id": "3328621",
            "problem": "您的任务是为在计算电磁学中使用时间步进法（Marching-on-in-Time, MOT）更新的时域边界积分方程求解器，形式化并实现一个因果性测试。目标是设计一个程序化检测器，该检测器在给定离散时间表面电流对脉冲激励的响应时，能确定是否有任何非零电流出现在物理上规定的、由有限传播速度决定的推迟影响时间之前。\n\n请从以下基本原理和定义开始。\n\n- 在自由空间中，麦克斯韦方程组（Maxwell’s equations）意味着电磁扰动以光速 $c$ 传播。对于位于位置 $\\mathbf{r}_{s}$ 的源面元和位于位置 $\\mathbf{r}_{o}$ 的观测面元，欧几里得距离为 $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$。首次影响的推迟时间为 $t_{\\star} = R / c$。对于 $t < t_{\\star}$，在理想的连续时间、连续空间模型中，场以及感应表面电流密度恒为零。\n\n- 在用于时域电场积分方程（Electric Field Integral Equation, EFIE）的时间步进法（MOT）方案中，时间在采样时刻 $t_{n} = n \\Delta t$ 被离散化，其中 $n$ 为非负整数，$\\Delta t$ 是固定的时间步长。在 $n = 0$ 时，于源面元施加一个离散时间的脉冲激励。如果求解器是因果的，那么在远处的面元上观测到的离散表面电流样本 $J_{o}[n]$ 必须满足，对于所有使得 $t_{n} < t_{\\star}$ 的 $n$，都有 $J_{o}[n] = 0$。对于 $t_{n} \\ge t_{\\star}$，$J_{o}[n]$ 可能为非零。\n\n- 我们将通过一个合成的、完全指定的、分段的函数来模拟观测到的离散电流响应 $J_{o}[n]$，该函数捕捉了理想的因果响应，并可选地包含一个前因果“回波”以模拟因果性违背。这使得在没有完整MOT代码的情况下也能测试检测器。\n\n定义在时间 $t_{n} = n \\Delta t$（其中 $n = 0,1,\\ldots,N-1$）的合成观测电流序列为\n$$\nJ_{o}[n] =\n\\begin{cases}\nA \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big),  t_{n} \\ge t_{\\star}, \\\\\n0,  t_{n}  t_{\\star},\n\\end{cases}\n\\quad\\text{(因果部分)}\n$$\n并由一个可选的、为 $t_{n}  t_{\\star}$ 定义的前因果高斯“回波”增强：\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right),\n$$\n其中 $A$ 是因果指数尾部的正幅值，$\\alpha$ 是单位为 $\\mathrm{s}^{-1}$ 的正衰减率，$A_{\\text{pre}} \\ge 0$ 是前回波的峰值幅值，$\\tau_{\\text{pre}}  0$ 将前回波中心置于 $t_{\\star}$ 之前 $\\tau_{\\text{pre}}$ 处，$\\sigma_{\\text{pre}}  0$ 控制其宽度。完整的合成观测序列是\n$$\nJ_{o}[n] \\leftarrow J_{o}[n] + \\begin{cases}\nJ_{\\text{pre}}[n],  t_{n}  t_{\\star}, \\\\\n0,  t_{n} \\ge t_{\\star}.\n\\end{cases}\n$$\n\n定义一个因果性违背检测器如下。给定参数 $(R, c, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$，使用上述规则合成 $J_{o}[n]$（其中 $t_{\\star} = R/c$），并测试是否存在任何索引 $n$ 满足 $t_{n}  t_{\\star}$ 且 $\\lvert J_{o}[n] \\rvert  \\varepsilon$。如果存在这样的 $n$，则声明发生违背（布尔值 $\\mathrm{True}$）；否则，声明无违背（布尔值 $\\mathrm{False}$）。容差 $\\varepsilon$ 是用户指定的非负阈值，用于避免标记不重要的数值噪声。请注意，等式 $\\lvert J_{o}[n] \\rvert = \\varepsilon$ 不应被标记为违背。\n\n实现一个程序，将此检测器应用于以下测试套件。所有距离必须以米为单位处理，所有时间以秒为单位，衰减率以秒的倒数为单位，电流幅值参数在此合成模型中是无量纲的。使用真空中的光速 $c = 299\\,792\\,458\\ \\mathrm{m/s}$。\n\n您的程序必须完全按照规定合成序列，并为每个案例生成一个布尔值，指示是否检测到违背。\n\n测试套件（每个案例提供 $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$；$c$ 固定为 $299\\,792\\,458\\ \\mathrm{m/s}$）：\n- 案例1（理想路径，严格因果）：\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 0.0$，\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-6}$。\n\n- 案例2（边界相等，$t_{\\star}$ 在网格点上）：\n  - $R = 5.99584916\\ \\mathrm{m}$，等于 $c \\times 20.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 40$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 0.0$，\n  - $\\tau_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 5.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-6}$。\n\n- 案例3（近因果前回波低于阈值）：\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-5}$，\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-4}$。\n\n- 案例4（显式因果性违背高于阈值）：\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 1.0 \\times 10^{-2}$，\n  - $\\tau_{\\text{pre}} = 3.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $\\varepsilon = 1.0 \\times 10^{-4}$。\n\n- 案例5（阈值相等的边界情况）：\n  - $R = 5.0\\ \\mathrm{m}$，\n  - $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，\n  - $N = 64$，\n  - $A = 1.0$，\n  - $\\alpha = 5.0 \\times 10^{7}\\ \\mathrm{s}^{-1}$，\n  - $A_{\\text{pre}} = 5.0 \\times 10^{-3}$，\n  - $\\tau_{\\text{pre}} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\sigma_{\\text{pre}} = 2.0 \\times 10^{-10}\\ \\mathrm{s}$，\n  - $\\varepsilon = 5.0 \\times 10^{-3}$。\n  对于 $R = 5.0\\ \\mathrm{m}$ 和 $\\Delta t = 1.0 \\times 10^{-9}\\ \\mathrm{s}$，这个 $\\tau_{\\text{pre}}$ 的选择将前回波的中心置于最后一个严格前因果的采样点上，因为 $t_{\\star} = R / c \\approx 1.66782047599076 \\times 10^{-8}\\ \\mathrm{s}$ 且 $t_{16} = 1.6 \\times 10^{-8}\\ \\mathrm{s}$，因此 $\\tau_{\\text{pre}} \\approx t_{\\star} - t_{16} = 6.782047599076 \\times 10^{-10}\\ \\mathrm{s}$。通过此配置，前回波的峰值幅度在严格前因果的索引处等于 $\\varepsilon$，因此不得被标记。\n\n您的程序应该：\n- 实现定义的合成规则和检测器。\n- 按所列顺序将检测器应用于五个案例。\n- 生成一行输出，包含五个布尔值结果，以逗号分隔，并用方括号括起来，不含空格。例如，输出可能看起来像 $[\\mathrm{False},\\mathrm{True},\\ldots]$，但应包含指定案例的实际布尔值。\n\n没有用户输入。所有常量和参数均如上所述。最终输出是布尔值，因此没有物理单位适用于输出。确保所有表示时间的内部量纲都以秒为单位，所有距离都以米为单位，并使用 $c = 299\\,792\\,458\\ \\mathrm{m/s}$。",
            "solution": "该问题是有效的，因为它在科学上基于计算电磁学的原理，问题陈述清晰，具有明确且客观的一套定义和约束，并要求实现一个特定的、可验证的算法。\n\n问题的核心在于麦克斯韦方程组所规定的因果性原理。在真空中，效应的传播速度不能超过光速 $c$。对于位于位置 $\\mathbf{r}_s$ 的源和位于 $\\mathbf{r}_o$ 的观测者，能感受到影响的最早时间是推迟时间 $t_{\\star} = R/c$，其中 $R = \\lVert \\mathbf{r}_{o} - \\mathbf{r}_{s} \\rVert$ 是欧几里得距离。在此时间之前，即对于所有 $t  t_{\\star}$，观测者位置处的任何场或感应电流必须恒为零。\n\n在数值化的时间步进法（MOT）算法背景下，时间被离散化为步长 $t_n = n \\Delta t$，其中 $n$ 为非负整数。一个因果的MOT求解器必须在计算上强制执行这一物理原理，确保离散表面电流 $J_o[n]$ 对于所有满足 $t_n  t_{\\star}$ 的时间索引 $n$ 均为零。\n\n任务是设计一个检测器，用于发现对这种离散因果性条件的违背。该方法基于一个合成电流信号 $J_o[n]$，它模拟了一个理想响应与一个潜在的非因果伪影的组合。完整的合成信号由因果部分和前因果部分之和给出。因果部分仅在 $t_n \\ge t_{\\star}$ 时非零，定义为\n$$\nJ_{o}[n] = A \\exp\\!\\big(-\\alpha \\left(t_{n} - t_{\\star}\\right)\\big), \\quad t_{n} \\ge t_{\\star}.\n$$\n前因果部分或“回波”，仅在 $t_n  t_{\\star}$ 时存在，并被建模为一个高斯脉冲：\n$$\nJ_{\\text{pre}}[n] = A_{\\text{pre}} \\exp\\!\\left(-\\dfrac{\\left(t_{n} - \\left(t_{\\star} - \\tau_{\\text{pre}}\\right)\\right)^{2}}{\\sigma_{\\text{pre}}^{2}}\\right), \\quad t_n  t_{\\star}.\n$$\n完整信号是这两个分量的和，每个分量都限制在其各自的时间域内。\n\n因果性检测器必须确定是否存在任何时间索引 $n$ 在前因果域（$t_n  t_{\\star}$）中，使得信号的幅度 $|J_o[n]|$ 严格大于一个指定的数值容差 $\\varepsilon$。\n\n一个关键的简化来自于定义。对于任何时间 $t_n  t_{\\star}$，根据定义，$J_o[n]$ 的因果分量为零。因此，在前因果时期，总信号 $J_o[n]$ 等于前因果回波 $J_{\\text{pre}}[n]$。因此，因果性违背的测试简化为检查对于任何满足 $t_n  t_{\\star}$ 的 $n$，是否有 $|J_{\\text{pre}}[n]| > \\varepsilon$。\n\n实现的算法如下：\n$1$. 对于给定的一组参数 $(R, \\Delta t, N, A, \\alpha, A_{\\text{pre}}, \\tau_{\\text{pre}}, \\sigma_{\\text{pre}}, \\varepsilon)$，使用 $c = 299\\,792\\,458\\ \\mathrm{m/s}$ 计算推迟时间 $t_{\\star} = R/c$。\n$2$. 首先进行一个关键的逻辑优化。高斯函数 $J_{\\text{pre}}[n]$ 的最大值是其幅值 $A_{\\text{pre}}$。如果 $A_{\\text{pre}} \\le \\varepsilon$，那么条件 $J_{\\text{pre}}[n] > \\varepsilon$ 对任何 $n$ 都不可能满足。因此，如果 $A_{\\text{pre}} = 0$（无前因果信号）或者其最大可能值不严格大于阈值，我们可以立即断定没有违背（`False`）。这正确地处理了问题中规定的前因果信号峰值恰好等于阈值的情况（$|J_o[n]| = \\varepsilon$ 不是违背）。\n$3$. 如果 $A_{\\text{pre}} > \\varepsilon$，则可能存在违背。算法从 $0$ 到 $N-1$ 遍历时间索引 $n$。\n$4$. 对于每个 $n$，计算时间 $t_n = n \\Delta t$。如果 $t_n \\ge t_{\\star}$，我们已进入因果域，因此可以终止对前因果违背的搜索。\n$5$. 对于前因果域（$t_n  t_{\\star}$）中的每个时间步，计算 $J_{\\text{pre}}[n]$ 的值。由于 $A_{\\text{pre}} \\ge 0$，指数项总是正的，所以 $|J_{\\text{pre}}[n]| = J_{\\text{pre}}[n]$。\n$6$. 将此值与阈值 $\\varepsilon$ 进行比较。如果 $J_{\\text{pre}}[n] > \\varepsilon$，则已找到因果性违背，函数返回 `True`。\n$7$. 如果遍历所有相关的前因果索引 $n$ 后循环完成而未满足该条件，则不存在违背，函数返回 `False`。\n将此过程应用于五个测试案例中的每一个，以生成最终的布尔结果列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a causality test for synthetic MOT signals.\n    \"\"\"\n\n    def causality_detector(params):\n        \"\"\"\n        Detects causality violations for a single test case.\n\n        A violation occurs if |J_o[n]| > epsilon for any t_n  t_star.\n        For t_n  t_star, J_o[n] is identical to the pre-causal component J_pre[n].\n        \"\"\"\n        R, dt, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon = params\n        C = 299792458.0  # Speed of light in m/s\n\n        t_star = R / C\n\n        # Optimization: If the peak amplitude of the pre-causal echo is not strictly\n        # greater than the threshold, no violation is possible, as the exponential\n        # term is at most 1. This also correctly handles A_pre = 0 and the\n        # equality case |J_o[n]| = epsilon.\n        if A_pre = epsilon:\n            return False\n\n        # Iterate through discrete time steps up to the retarded time\n        for n in range(N):\n            t_n = n * dt\n\n            # We are only interested in the pre-causal time domain\n            if t_n >= t_star:\n                break  # Exit loop once we reach or pass the retarded time\n\n            # Calculate the pre-causal echo signal value at time t_n\n            t_center = t_star - tau_pre\n            exponent_numerator = (t_n - t_center)**2\n            exponent_denominator = sigma_pre**2\n            \n            # Avoid division by zero, although sigma_pre  0 is a given\n            if exponent_denominator == 0:\n                # This case should not be reached given problem constraints\n                j_pre_n = 0.0 if exponent_numerator > 0 else A_pre\n            else:\n                exponent = -exponent_numerator / exponent_denominator\n                j_pre_n = A_pre * np.exp(exponent)\n\n            # Check for violation. The signal is non-negative, so abs() is not needed.\n            # The condition is strictly greater than epsilon.\n            if j_pre_n > epsilon:\n                return True  # Violation detected\n\n        # If the loop completes without finding any violation\n        return False\n\n    # Test Suite (R, delta_t, N, A, alpha, A_pre, tau_pre, sigma_pre, epsilon)\n    test_cases = [\n        # Case 1: happy path, strictly causal (A_pre = 0)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 2: t_star on-grid, causal (A_pre = 0)\n        (5.99584916, 1.0e-9, 40, 1.0, 5.0e7, 0.0, 1.0e-9, 5.0e-10, 1.0e-6),\n        # Case 3: pre-echo below threshold (A_pre  epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-5, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 4: explicit causality violation (A_pre  epsilon and echo is significant)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 1.0e-2, 3.0e-9, 1.0e-9, 1.0e-4),\n        # Case 5: edge case at threshold equality (A_pre = epsilon)\n        (5.0, 1.0e-9, 64, 1.0, 5.0e7, 5.0e-3, 6.782047599076e-10, 2.0e-10, 5.0e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = causality_detector(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of booleans in brackets.\n    # Python's str() of a boolean is 'True' or 'False', which matches the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确保了物理正确性之后，我们关注的下一个核心问题是仿真的精度。数值方法可能会引入非物理的色散效应，导致波的不同频率分量以不同的速度传播，从而扭曲波形。这个练习  旨在通过一个具体的动手任务，展示如何通过采用高阶时间基函数来显著减少这种数值色散误差，从而实现对波传播过程更忠实的模拟。",
            "id": "3328595",
            "problem": "考虑一个时域推迟势模型，该模型捕捉了电磁表面积分方程的瞬时推进法（MOT）公式中遇到的基本时间结构。设入射场为已知标量激励 $E_{\\text{inc}}(t)$，感应电流密度建模为标量函数 $J(t)$，两者通过推迟卷积相关联\n$$\nJ(t) = \\int_{-\\infty}^{\\infty} g(t-\\tau) E_{\\text{inc}}(\\tau)\\, d\\tau,\n$$\n其中标量核是具有固定传播延迟 $\\tau_0  0$ 的因果点延迟 $g(t) = \\delta(t-\\tau_0)$。根据狄拉克δ函数的筛选特性，精确电流为\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0).\n$$\n在瞬时推进法中，电流在时间步长为 $\\Delta t$ 的均匀时间网格上，使用有限支撑时间基（也称为时间形状函数）表示为\n$$\nJ_r(t) \\approx \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right),\n$$\n其中 $r$ 是基的多项式阶数，$B_r$ 是一个 $r$ 阶基数插值基，具有跨越 $r+1$ 个时间步的紧支撑，$I_n$ 是通过在时间网格上进行配置得到的系数，此处取为精确解的样本 $I_n = J_{\\text{exact}}(n\\Delta t)$。对于插值基，在其支撑域内，对于整数 $k \\neq 0$ 有 $B_r(0)=1$ 和 $B_r(k)=0$。\n\n您将实现并比较以下插值时间基：\n- 分段线性（$r=1$ 阶），也称为帽函数。\n- 分段三次（$r=3$ 阶），通过在整数模板上进行4点基数拉格朗日插值实现。\n- 分段四次（$r=4$ 阶），通过在整数模板上进行5点基数拉格朗日插值实现。\n\n输入信号是一个带有平滑窗以强制实现有限支撑的线性调频激励：\n$$\nE_{\\text{inc}}(t) = A(t)\\cos\\!\\left(2\\pi\\left(f_0 t + \\tfrac{1}{2}\\alpha t^2\\right)\\right),\n\\quad \\text{for } 0 \\le t \\le T,\\quad \\text{and } E_{\\text{inc}}(t)=0 \\text{ otherwise},\n$$\n其中扫频率为 $\\alpha = \\frac{f_1 - f_0}{T}$，汉宁窗为 $A(t) = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\frac{2\\pi t}{T}\\right)\\right)$。精确电流为 $J_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)$。\n\n您的任务是：\n1. 构建粗时间网格 $t_n = n\\Delta t$（$n=0,1,\\dots,N-1$）并定义系数 $I_n = J_{\\text{exact}}(n\\Delta t)$。\n2. 使用 $r$ 阶插值基，通过在每个局部模板上进行基数拉格朗日插值，在细网格 $t_m^{\\text{fine}} = m\\Delta t/L$（$m=0,1,\\dots,LN-1$）上重构连续时间电流 $J_r(t)$。\n3. 使用快速傅里叶变换（FFT）在细网格上计算 $J_{\\text{exact}}(t_m^{\\text{fine}})$ 和 $J_r(t_m^{\\text{fine}})$ 的离散傅里叶变换（DFT）。设单边DFT为 $\\hat{J}_{\\text{exact}}(\\omega_k)$ 和 $\\hat{J}_r(\\omega_k)$，对应频率为 $\\omega_k = 2\\pi f_k$，其中 $f_k$是由细采样间隔 $\\Delta t/L$ 决定的非负DFT频率。\n4. 在精确频谱幅度显著的调频带 $[f_0,f_1]$ 内的频率点上，将基阶数为 $r$ 的相位误差定义为\n$$\n\\phi_r(\\omega_k,\\Delta t) = \\operatorname{unwrap}\\left(\\arg\\left(\\hat{J}_r(\\omega_k)\\right) - \\arg\\left(\\hat{J}_{\\text{exact}}(\\omega_k)\\right)\\right),\n$$\n相位单位为弧度。使用一个幅度掩码，仅保留那些满足 $\\left|\\hat{J}_{\\text{exact}}(\\omega_k)\\right| \\ge \\eta \\max_{f_0 \\le f \\le f_1} \\left|\\hat{J}_{\\text{exact}}(2\\pi f)\\right|$ 的 $k$ 值，其中固定显著性阈值为 $\\eta = 0.2$。\n5. 报告在保留的频率点上的均方根（RMS）相位误差（单位：弧度）：\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k,\\Delta t)^2},\n$$\n其中 $\\mathcal{K}$ 是保留的频率点集合，$K = |\\mathcal{K}|$。\n\n物理单位要求：\n- 所有时间单位必须是秒。\n- 所有频率单位必须是赫兹。\n- 所有角度单位必须是弧度。\n- 最终的相位误差必须以实值浮点数形式报告，单位为弧度。\n\n实现上述过程，并使用以下测试套件评估三种时间基 $r\\in\\{1,3,4\\}$。在每个测试中，使用指定的 $\\Delta t$、整数长度 $N$、调频带 $[f_0,f_1]$、延迟 $\\tau_0$ 和过采样因子 $L$ 来如上定义网格和信号。总时长为 $T = N\\Delta t$。\n\n测试套件：\n- 测试1（正常情况，频带内的小数延迟）：\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 8.0\\times 10^{8}\\ \\text{Hz}$，$\\tau_0 = 2.3\\,\\Delta t$，$L=8$。\n- 测试2（边界情况，接近奈奎斯特的频带边缘和整数延迟）：\n    - $\\Delta t = 5.0\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 9.0\\times 10^{8}\\ \\text{Hz}$，$\\tau_0 = 8\\,\\Delta t$，$L=8$。\n- 测试3（更小的时间步长，更高的频带，小数延迟）：\n    - $\\Delta t = 2.5\\times 10^{-10}\\ \\text{s}$，$N=4096$，$f_0 = 5.0\\times 10^{7}\\ \\text{Hz}$，$f_1 = 1.5\\times 10^{9}\\ \\text{Hz}$，$\\tau_0 = 2.7\\,\\Delta t$，$L=8$。\n\n您的程序必须：\n- 实现阶数为 $r=1,3,4$ 的基数拉格朗日插值，该插值作用于长度为 $r+1$ 的局部整数模板上，并在采样区间外进行零填充。\n- 在细网格上构建 $J_{\\text{exact}}(t)$ 和 $J_r(t)$，并计算所定义的基于DFT的相位误差。\n- 对于每个测试，计算并收集三个RMS相位误差 $\\mathrm{RMS}_1$、$\\mathrm{RMS}_3$ 和 $\\mathrm{RMS}_4$（单位：弧度）。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个列表的列表形式的结果，每个内部列表对应一个测试，顺序与上述相同。每个内部列表必须为 $[\\mathrm{RMS}_1,\\mathrm{RMS}_3,\\mathrm{RMS}_4]$ 的形式，其中每个条目都是一个以弧度为单位的浮点数。例如：[[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]]。",
            "solution": "该问题经评估有效。它在科学上基于计算电磁学和数值分析的原理，具体地解决了在瞬时推进法（MOT）算法中使用时间基函数表示时域信号的问题。该问题定义明确，具有一套完整且一致的定义、参数和目标，能够导出一个唯一且可验证的解。所有术语都得到了正式定义，所要求的物理参数和数值程序在该领域内均为标准。\n\n求解过程首先构建指定的输入信号和精确的推迟响应。然后，对于每个指定的时间基阶数 $r \\in \\{1, 3, 4\\}$，从粗网格上的样本重构连续时间电流。最后，在频域中对每种重构的相位精度与精确解进行量化比较。\n\n**1. 信号与网格生成**\n\n对于每个测试案例，我们给定时间步长 $\\Delta t$、时间步数 $N$、频率调频带 $[f_0, f_1]$、传播延迟 $\\tau_0$ 以及细网格过采样因子 $L$。\n\n入射信号的总时长为 $T = N \\Delta t$。\n粗时间网格定义为 $t_n = n \\Delta t$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n用于分析的细时间网格为 $t_m^{\\text{fine}} = m \\frac{\\Delta t}{L}$，其中 $m \\in \\{0, 1, \\dots, LN-1\\}$。令 $N_{\\text{fine}} = LN$。\n\n入射场 $E_{\\text{inc}}(t)$ 是一个带有汉宁窗以实现平滑开始和结束的线性调频余弦脉冲：\n$$\nE_{\\text{inc}}(t) = \n\\begin{cases} \n\\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi t}{T}\\right)\\right) \\cos\\left(2\\pi\\left(f_0 t + \\frac{1}{2}\\alpha t^2\\right)\\right)  \\text{for } 0 \\le t \\le T \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n其中调频率为 $\\alpha = \\frac{f_1 - f_0}{T}$。\n\n精确电流 $J_{\\text{exact}}(t)$ 是入射场的时间延迟版本，由狄拉克δ核的筛选特性给出：\n$$\nJ_{\\text{exact}}(t) = E_{\\text{inc}}(t - \\tau_0)\n$$\nMOT表示的系数 $I_n$ 是该精确电流在粗网格上的样本：\n$$\nI_n = J_{\\text{exact}}(t_n) = J_{\\text{exact}}(n \\Delta t), \\quad n \\in \\{0, 1, \\dots, N-1\\}\n$$\n\n**2. 通过插值进行电流重构**\n\n近似电流 $J_r(t)$ 是使用阶数为 $r$ 的基函数从粗网格样本 $\\{I_n\\}$ 重构的。问题将此重构描述为移位基函数的和，$J_r(t) = \\sum_{n=0}^{N-1} I_n \\, B_r\\!\\left(\\frac{t - n \\Delta t}{\\Delta t}\\right)$，但也称这些基为“分段的”并通过“在局部模板上进行拉格朗日插值”来实现。这最一致地被解释为一种分段多项式插值方案。对于每个粗时间区间 $[t_n, t_{n+1}]$，使用一个包含 $r+1$ 个邻近样本 $\\{I_k\\}$ 的模板构建一个 $r$ 阶多项式，并使用该多项式计算 $t \\in [t_n, t_{n+1}]$ 的 $J_r(t)$ 值。这种方法等效于卷积和，其中 $B_r(\\tau)$ 是一个具有紧支撑的分段多项式函数，被称为拉格朗日类型的基本样条。\n\n实现方面：\n- **$r=1$ 阶（分段线性）**：这对应于标准的“帽”基。对于任何 $t \\in [t_n, t_{n+1}]$，值 $J_1(t)$ 是通过在点 $(t_n, I_n)$ 和 $(t_{n+1}, I_{n+1})$ 之间进行线性插值计算得出的。这可以在整个细网格上高效实现。\n- **$r=3$ 阶（分段三次）**：对于每个区间 $[t_n, t_{n+1}]$，我们使用一个4点模板来构建一个三次拉格朗日多项式。一个标准的选择是样本 $\\{I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$ 的模板。然后，在 $[t_n, t_{n+1}]$ 内的细网格点上对该多项式进行求值。\n- **$r=4$ 阶（分段四次）**：类似地，对于每个区间 $[t_n, t_{n+1}]$，我们使用一个5点模板。相对于区间点的一个中心化选择是 $\\{I_{n-2}, I_{n-1}, I_n, I_{n+1}, I_{n+2}\\}$。该模板涉及对应于粗时间 $\\{t_{n-2}, \\dots, t_{n+2}\\}$ 的样本。从这些样本构建一个四次拉格朗日多项式，并在 $[t_n, t_{n+1}]$ 的细网格上进行求值。\n\n在定义域 $[0, T]$ 的边界处，模板可能需要索引 $n0$ 或 $n \\ge N$ 的样本 $I_n$。根据问题中“零填充”的规范，我们假设这些索引对应的 $I_n=0$。\n\n**3. 谱分析与相位误差计算**\n\n重构的精度在频域中进行评估。\n1.  **傅里叶变换**：使用快速傅里叶变换（FFT）算法，在精细采样的信号 $J_{\\text{exact}}(t_m^{\\text{fine}})$ 和 $J_r(t_m^{\\text{fine}})$ 上，计算精确电流的单边离散傅里叶变换（DFT）$\\hat{J}_{\\text{exact}}(\\omega_k)$ 和重构电流的单边DFT $\\hat{J}_r(\\omega_k)$。对应的离散频率为 $f_k = k / (N_{\\text{fine}} \\cdot (\\Delta t/L))$。\n\n2.  **幅度掩码**：相位误差仅在信号具有显著能量的地方才有意义。我们首先识别出落在调频带 $[f_0, f_1]$ 内的频率点 $k$。在该频带内，我们找到精确信号的最大谱幅度，$M_{\\text{max}} = \\max_{f_k \\in [f_0, f_1]} \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right|$。分析被限制在幅度超过该最大值的一个分数 $\\eta=0.2$ 的频率点集合 $\\mathcal{K}$ 上：\n$$\n\\mathcal{K} = \\left\\{ k \\;\\middle|\\; f_k \\in [f_0, f_1] \\text{ and } \\left|\\hat{J}_{\\text{exact}}(2\\pi f_k)\\right| \\ge \\eta M_{\\text{max}} \\right\\}\n$$\n\n3.  **相位误差**：对于每个对应于索引 $k \\in \\mathcal{K}$ 的频率 $\\omega_k$，计算原始相位差：$\\Delta\\phi(\\omega_k) = \\arg(\\hat{J}_r(\\omega_k)) - \\arg(\\hat{J}_{\\text{exact}}(\\omega_k))$。然后对该差值进行解缠绕以解决 $2\\pi$ 模糊性，从而得到连续相位误差 $\\phi_r(\\omega_k, \\Delta t)$。\n\n4.  **RMS度量**：最终的误差度量是在所有保留频率点上解缠绕相位误差的均方根（RMS）：\n$$\n\\mathrm{RMS}_r = \\sqrt{\\frac{1}{K}\\sum_{k \\in \\mathcal{K}} \\phi_r(\\omega_k, \\Delta t)^2}\n$$\n其中 $K=|\\mathcal{K}|$ 是掩码集合中的频率点数量。对每个阶数 $r$ 和每个测试案例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import interp1d, barycentric_interpolate\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test 1: Happy path\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 8.0e8, 'tau0_factor': 2.3, 'L': 8},\n        # Test 2: Near-Nyquist\n        {'dt': 5.0e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 9.0e8, 'tau0_factor': 8.0, 'L': 8},\n        # Test 3: Smaller time step, higher band\n        {'dt': 2.5e-10, 'N': 4096, 'f0': 5.0e7, 'f1': 1.5e9, 'tau0_factor': 2.7, 'L': 8}\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results_per_case = run_test_case(**params)\n        all_results.append(results_per_case)\n\n    # Format the final output string as a list of lists.\n    # e.g., [[x11,x13,x14],[x21,x23,x24],[x31,x33,x34]]\n    output_str = '[' + ','.join(['[' + ','.join([f\"{val:.8f}\" for val in res]) + ']' for res in all_results]) + ']'\n    print(output_str)\n\ndef run_test_case(dt, N, f0, f1, tau0_factor, L):\n    \"\"\"\n    Executes a single test case for the given parameters.\n    \"\"\"\n    T = N * dt\n    tau0 = tau0_factor * dt\n    alpha = (f1 - f0) / T\n\n    # Define the incident field E_inc(t)\n    def e_inc(t):\n        # Ensure t is a numpy array for vectorized operations\n        t = np.asarray(t)\n        # Signal is defined on [0, T], zero otherwise\n        active_mask = (t >= 0)  (t = T)\n        result = np.zeros_like(t, dtype=float)\n        \n        t_active = t[active_mask]\n        \n        # Hann window\n        amplitude = 0.5 * (1 - np.cos(2 * np.pi * t_active / T))\n        # Chirp signal\n        phase = 2 * np.pi * (f0 * t_active + 0.5 * alpha * t_active**2)\n        \n        result[active_mask] = amplitude * np.cos(phase)\n        return result\n\n    # Define the exact current J_exact(t)\n    def j_exact(t):\n        return e_inc(t - tau0)\n\n    # --- Grids and Coefficients ---\n    t_coarse = np.arange(N) * dt\n    I_coeffs = j_exact(t_coarse)\n\n    N_fine = N * L\n    dt_fine = dt / L\n    t_fine = np.arange(N_fine) * dt_fine\n\n    J_exact_fine = j_exact(t_fine)\n\n    rms_errors = []\n    for r in [1, 3, 4]:\n        J_recon_fine = reconstruct_current(I_coeffs, r, L, dt)\n        rms_error = calculate_rms_phase_error(J_recon_fine, J_exact_fine, dt_fine, f0, f1)\n        rms_errors.append(rms_error)\n        \n    return rms_errors\n\ndef reconstruct_current(I_coeffs, r, L, dt):\n    \"\"\"\n    Reconstructs the continuous-time current on a fine grid using piecewise\n    Lagrange interpolation of degree r.\n    \"\"\"\n    N = len(I_coeffs)\n    N_fine = N * L\n    t_fine = np.arange(N_fine) * (dt / L)\n    J_recon = np.zeros(N_fine)\n\n    if r == 1:\n        # Degree 1 (linear interpolation) is efficiently handled by interp1d\n        t_coarse_nodes = np.arange(N + 1) * dt\n        I_extended = np.pad(I_coeffs, (0, 1), 'constant')\n        interp_func = interp1d(t_coarse_nodes, I_extended, kind='linear', bounds_error=False, fill_value=0.0)\n        return interp_func(t_fine)\n\n    # For r  1, use piecewise barycentric interpolation\n    # Determine padding needed based on stencil choice\n    if r == 3: # Stencil: [n-1, n, n+1, n+2]\n        pad_before, pad_after = 1, 2\n    elif r == 4: # Stencil: [n-2, n-1, n, n+1, n+2]\n        pad_before, pad_after = 2, 2\n    else:\n        raise ValueError(f\"Unsupported degree r={r}\")\n\n    I_padded = np.pad(I_coeffs, (pad_before, pad_after), 'constant')\n\n    for n in range(N):\n        m_start = n * L\n        m_end = (n + 1) * L\n        t_interval_fine = t_fine[m_start:m_end]\n\n        if r == 3:\n            stencil_n_indices = np.array([n - 1, n, n + 1, n + 2])\n        elif r == 4:\n            stencil_n_indices = np.array([n - 2, n - 1, n, n + 1, n + 2])\n        \n        t_stencil_nodes = stencil_n_indices * dt\n        I_stencil_values = I_padded[stencil_n_indices + pad_before]\n\n        J_recon[m_start:m_end] = barycentric_interpolate(t_stencil_nodes, I_stencil_values, t_interval_fine)\n        \n    return J_recon\n\ndef calculate_rms_phase_error(j_recon, j_exact, dt_fine, f0, f1, eta=0.2):\n    \"\"\"\n    Calculates the RMS phase error in the frequency domain.\n    \"\"\"\n    N_fine = len(j_exact)\n    \n    # Compute one-sided FFTs\n    J_hat_recon = np.fft.rfft(j_recon)\n    J_hat_exact = np.fft.rfft(j_exact)\n    \n    # Get corresponding frequencies\n    freqs = np.fft.rfftfreq(N_fine, d=dt_fine)\n    \n    # Identify frequency bins in the chirp band [f0, f1]\n    band_indices = np.where((freqs >= f0)  (freqs = f1))[0]\n    \n    if len(band_indices) == 0:\n        return 0.0\n\n    # Apply amplitude mask\n    J_hat_exact_band = J_hat_exact[band_indices]\n    max_mag_in_band = np.max(np.abs(J_hat_exact_band))\n    \n    threshold = eta * max_mag_in_band\n    \n    mask = np.abs(J_hat_exact_band) >= threshold\n    \n    masked_indices = band_indices[mask]\n    \n    if len(masked_indices) == 0:\n        return 0.0\n\n    # Calculate phase error\n    phase_recon = np.angle(J_hat_recon[masked_indices])\n    phase_exact = np.angle(J_hat_exact[masked_indices])\n    \n    phase_error = phase_recon - phase_exact\n    unwrapped_phase_error = np.unwrap(phase_error)\n    \n    # Compute RMS error\n    rms_error = np.sqrt(np.mean(unwrapped_phase_error**2))\n    \n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "时间步进算法，特别是时域电场积分方程（TD-EFIE），面临的一个主要挑战是晚期时间不稳定性，即数值误差会随时间推移而失控增长。这个练习  介绍了时域组合场积分方程（TD-CFIE）这一强大的解决方案。通过构建一个能够捕捉核心物理特性的代理模型，我们可以探索如何通过组合 EFIE 和 MFIE 来抑制这种不稳定性，并找到一个最佳的混合参数。",
            "id": "3328585",
            "problem": "您的任务是构建一个用于理想电导体（PEC）球体表面电流密度的时间域组合场积分方程（TD-CFIE）时间步进算法。该算法通过一个标量混合参数，结合了时间域电场积分方程（TD-EFIE）和时间域磁场积分方程（TD-MFIE）的核。请从麦克斯韦方程组和标准PEC边界条件等第一性原理出发。目标是选择一个混合参数，以在高频区最小化离散表面电流随时间的增长。\n\n从自由空间中电场$\\mathbf{E}(\\mathbf{r},t)$和磁场$\\mathbf{H}(\\mathbf{r},t)$的时间域麦克斯韦方程组出发，其中包含电通量密度$\\mathbf{D}(\\mathbf{r},t)$、磁通量密度$\\mathbf{B}(\\mathbf{r},t)$以及线性本构关系，并对切向电场强制施加PEC边界条件。考虑通过推迟势将球体上未知的表面电流密度$\\mathbf{J}(\\mathbf{r},t)$映射到散射场的时间域积分方程公式。TD-EFIE和TD-MFIE定义了作用于表面上$\\mathbf{J}(\\mathbf{r},t)$的卷积算子，其核函数分别为$K_E(t)$和$K_M(t)$。TD-CFIE算子定义为核函数的凸组合，\n$$\nK_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t),\n$$\n其中$0 \\le \\eta \\le 1$是混合参数。\n\n在空间上，使用单一主导的矢量球谐函数模式进行离散化，以便将算子简化为针对一个模式系数$J(t)$的标量代理；在时间上，使用步长为$\\Delta t$的均匀网格和分段常数时间基函数进行离散化。在空间和时间上进行伽辽金测试后，TD-CFIE产生一个关于模式系数的线性因果离散卷积方程，\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n,\n$$\n其中$J^n$近似于$J(n\\Delta t)$，$M$是有限的记忆深度，$Z_C[m]$是离散的TD-CFIE权重，$V^n$是测试后的激励。对于零后续激励（$V^n = 0$ for $n \\ge 1$），时间步进更新公式为\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1,\n$$\n并给定初始条件$J^0$和对于$n0$时$J^n=0$。\n\n为了给半径为$a$的PEC球体在由波数$k$表征且$ka \\gg 1$的高频区定义一个科学上一致的降阶代理模型，假设离散的TD-EFIE和TD-MFIE权重具有以下参数形式，以捕捉辐射的因果性、阻尼和振荡行为：\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0},\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1,\n$$\n其中$z_{M0} = 0.5$对应于光滑闭合曲面上MFIE的经典主值项，而一个小的非零$z_{E0}$则捕捉了TD-EFIE的自作用项。振幅$A_E$和$A_M$随$ka$缩放，以表示高频下更强的EFIE耦合，其中$A_E = \\min(1.0, 0.02\\,ka)$，$A_M = 0.5\\,A_E$。阻尼因子为$\\alpha = 0.05$，短因果延迟由整数$m_d = 3$编码。角频率为$\\omega = c\\,k$，其中$c$是真空中的光速。混合后得到\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\n\n使用时间步进更新来传播$n=1,2,\\dots,N$的$J^n$，初始条件为$J^0 = 1$且$n  0$时$J^n = 0$，并设$n\\ge 1$时测试激励$V^n=0$。对于给定的$\\eta$，定义增长度量\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|,\n$$\n并选择最优混合参数\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta).\n$$\n\n请在一个完整的、可运行的程序中实现上述模型和过程。使用光速$c = 299792458\\,\\mathrm{m/s}$，半径以米为单位，时间步长以秒为单位，所有角度均使用弧度。通过周期$T = 2\\pi/\\omega$定义时间步长$\\Delta t = T/p$，其中$p$为整数。对于每个测试用例，根据$k = (ka)/a$计算$\\omega$，设置$z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$，并使用上述指定的参数$M$、$m_d$和$\\alpha$的$Z_E[m]$和$Z_M[m]$。\n\n测试套件：\n- 案例1（正常路径）：$a = 0.1\\,\\mathrm{m}$，$ka = 50$，$p = 20$，$N = 200$，$M = 12$。\n- 案例2（边界，更粗的时间步长）：$a = 0.05\\,\\mathrm{m}$，$ka = 50$，$p = 10$，$N = 200$，$M = 12$。\n- 案例3（边缘，更低的$ka$和更长的记忆）：$a = 0.1\\,\\mathrm{m}$，$ka = 30$，$p = 20$，$N = 400$，$M = 20$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的三个最优混合参数，以方括号括起来的逗号分隔列表形式，例如$\\left[\\eta^\\star_1,\\eta^\\star_2,\\eta^\\star_3\\right]$，其中每个条目都是四舍五入到三位小数的浮点数。",
            "solution": "目标是确定时间域组合场积分方程（TD-CFIE）公式的最优标量混合参数$\\eta^\\star$，该公式用于模拟理想电导体（PEC）球体上的表面电流。优化准则是最小化离散模式电流系数的时间增长，这是时间步进（MOT）算法中一个已知的挑战，尤其对于时间域电场积分方程（TD-EFIE）而言。\n\n该问题的基础是麦克斯韦方程组，它控制着电场$\\mathbf{E}(\\mathbf{r},t)$和磁场$\\mathbf{H}(\\mathbf{r},t)$的行为。对于PEC物体，其表面上的总切向电场必须为零。这一边界条件，结合使用由未知表面电流密度$\\mathbf{J}(\\mathbf{r},t)$源生的推迟势来表示散射场的方法，引出了积分方程。TD-EFIE源于对电场施加边界条件，而时间域磁场积分方程（TD-MFIE）源于对磁场施加边界条件。\n\nTD-CFIE是这两种公式的线性组合，旨在利用TD-MFIE的稳定性来减轻TD-EFIE MOT方案中常见的晚期不稳定性。组合算子核为$K_C(t) = \\eta\\, K_E(t) + (1-\\eta)\\, K_M(t)$，其中$\\eta \\in [0, 1]$是混合参数。\n\n经过空间和时间离散化后，连续积分方程被转换为针对单个电流模式系数的离散线性卷积，记作$J^n \\approx J(n\\Delta t)$:\n$$\n\\sum_{m=0}^{M} Z_C[m]\\, J^{n-m} = V^n\n$$\n此处，$Z_C[m]$是TD-CFIE的离散阻抗矩阵元素，$V^n$表示采样激励，$M$是相互作用的有限记忆深度。\n\n问题为半径为$a$的PEC球体在高频区（$ka \\gg 1$）中，指定了对应于TD-EFIE（$Z_E[m]$）和TD-MFIE（$Z_M[m]$）的离散阻抗权重的代理模型。TD-CFIE权重是其凸组合：\n$$\nZ_C[m] = \\eta\\, Z_E[m] + (1-\\eta)\\, Z_M[m], \\quad m=0,1,\\dots,M.\n$$\n给定的EFIE和MFIE权重的具体参数形式为：\n$$\nZ_E[0] = z_{E0}, \\quad Z_M[0] = z_{M0} = 0.5\n$$\n$$\nZ_E[m] = A_E\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad Z_M[m] = A_M\\, \\frac{e^{-\\alpha m} \\sin(\\omega m \\Delta t)}{m+m_d}, \\quad m\\ge 1\n$$\n参数根据物理设置定义：\n- 波数：$k=(ka)/a$\n- 角频率：$\\omega = c\\,k$，其中$c = 299792458\\,\\mathrm{m/s}$\n- 时间步长：$\\Delta t = T/p = (2\\pi/\\omega)/p$\n- EFIE自作用项：$z_{E0} = 0.1 + 0.02\\cdot\\pi/(10\\,ka)$\n- 振幅：$A_E = \\min(1.0, 0.02\\,ka)$ 和 $A_M = 0.5\\,A_E$\n- 阻尼因子：$\\alpha = 0.05$\n- 因果延迟：$m_d = 3$\n\n算法的核心是MOT更新方案。通过分离当前时刻的电流系数$J^n$（对应于求和中的$m=0$），我们得到一个递推关系。假设后续时间步的激励为零（$V^n = 0$ for $n \\ge 1$），更新规则为：\n$$\nJ^n = -\\frac{1}{Z_C[0]} \\sum_{m=1}^{\\min(M,n)} Z_C[m]\\, J^{n-m},\\quad n\\ge 1\n$$\n此过程以条件$J^0 = 1$和$n  0$时$J^n = 0$启动。项$Z_C[0] = \\eta z_{E0} + (1-\\eta) z_{M0}$保证为正，因为$z_{E0}  0$，$z_{M0}  0$，且$\\eta \\in [0, 1]$，从而确保更新总是良定义的。\n\n为了找到最优混合参数$\\eta^\\star$，我们遵循一个数值优化过程。我们定义一个增长度量$G(\\eta)$为模拟时间内电流系数绝对值的最大值：\n$$\nG(\\eta) = \\max_{0 \\le n \\le N} \\left|J^n\\right|\n$$\n最优参数$\\eta^\\star$是在可能的离散值网格上最小化此度量的那个值：\n$$\n\\eta^\\star = \\arg\\min_{\\eta \\in \\{0.00,0.01,\\dots,1.00\\}} G(\\eta)\n$$\n每个测试用例的计算过程如下：\n1.  根据给定的输入（$a, ka, p$）计算派生的物理和模型参数（$k, \\omega, \\Delta t, z_{E0}, A_E, A_M$）。\n2.  预计算$m \\in [0, M]$的阻抗权重数组$Z_E[m]$和$Z_M[m]$。\n3.  以$0.01$为步长，遍历从$0.00$到$1.00$的每个候选值$\\eta$。\n4.  对于每个$\\eta$，计算相应的CFIE权重$Z_C[m]$。\n5.  使用MOT递推关系和初始条件$J^0=1$，模拟从$n=1$到$N$的电流$J^n$的时间演化。\n6.  根据得到的序列$J^n$计算增长度量$G(\\eta)$。\n7.  记录迄今为止产生$G(\\eta)$最小值的$\\eta$。\n8.  最终导致$G(\\eta)$全局最小值的$\\eta$即为该测试用例的最优参数$\\eta^\\star$。对所有指定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the optimal TD-CFIE mixing parameter for several test cases.\n    \"\"\"\n    \n    # Define physical constants and test cases from the problem statement.\n    c = 299792458.0  # Speed of light in m/s\n    \n    test_cases = [\n        # Case 1 (happy path): a=0.1, ka=50, p=20, N=200, M=12\n        {'a': 0.1, 'ka': 50, 'p': 20, 'N': 200, 'M': 12},\n        # Case 2 (boundary coarser time step): a=0.05, ka=50, p=10, N=200, M=12\n        {'a': 0.05, 'ka': 50, 'p': 10, 'N': 200, 'M': 12},\n        # Case 3 (edge lower ka and longer memory): a=0.1, ka=30, p=20, N=400, M=20\n        {'a': 0.1, 'ka': 30, 'p': 20, 'N': 400, 'M': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        optimal_eta = find_optimal_eta(case, c)\n        results.append(optimal_eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\ndef find_optimal_eta(params, c):\n    \"\"\"\n    Finds the optimal mixing parameter eta for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the test case\n                       (a, ka, p, N, M).\n        c (float): The speed of light.\n\n    Returns:\n        float: The optimal mixing parameter eta_star.\n    \"\"\"\n    a = params['a']\n    ka = params['ka']\n    p = params['p']\n    N = params['N']\n    M = params['M']\n    \n    # Given model parameters\n    alpha = 0.05\n    m_d = 3\n    z_M0 = 0.5\n    \n    # Step 1: Calculate derived physical and model parameters\n    k = ka / a\n    omega = c * k\n    T = 2 * np.pi / omega\n    dt = T / p\n    \n    z_E0 = 0.1 + 0.02 * np.pi / (10 * ka)\n    A_E = min(1.0, 0.02 * ka)\n    A_M = 0.5 * A_E\n    \n    # Step 2: Pre-compute the impedance weight arrays Z_E and Z_M\n    m_vals = np.arange(1, M + 1)\n    common_term = np.exp(-alpha * m_vals) * np.sin(omega * m_vals * dt) / (m_vals + m_d)\n    \n    Z_E = np.zeros(M + 1)\n    Z_M = np.zeros(M + 1)\n    \n    Z_E[0] = z_E0\n    Z_M[0] = z_M0\n    \n    Z_E[1:] = A_E * common_term\n    Z_M[1:] = A_M * common_term\n    \n    # Step 3: Optimization loop to find eta_star\n    eta_grid = np.linspace(0.00, 1.00, 101)\n    min_growth = float('inf')\n    optimal_eta = -1.0\n    \n    for eta in eta_grid:\n        # Step 4: Compute CFIE weights Z_C\n        Z_C = eta * Z_E + (1 - eta) * Z_M\n        \n        # Step 5: Run MOT simulation\n        J = np.zeros(N + 1)\n        J[0] = 1.0\n        \n        Z_C0_inv = 1.0 / Z_C[0]\n        \n        for n in range(1, N + 1):\n            # Calculate the summation part of the recurrence\n            sum_term = 0.0\n            limit = min(M, n)\n            for m in range(1, limit + 1):\n                sum_term += Z_C[m] * J[n - m]\n            \n            J[n] = -Z_C0_inv * sum_term\n            \n        # Step 6: Calculate the growth metric G(eta)\n        growth = np.max(np.abs(J))\n        \n        # Step 7: Update the optimal eta\n        if growth  min_growth:\n            min_growth = growth\n            optimal_eta = eta\n            \n    return optimal_eta\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}