{
    "hands_on_practices": [
        {
            "introduction": "掌握了高阶基函数的理论之后，最有效的学习方法莫过于亲手构造一个。本练习将指导您从基本定义出发，在一个标准四面体上具体地构建一个二阶Nédélec基函数。通过这个过程，您将深化对重心坐标、惠特尼1-形式（Whitney 1-forms）以及旋度算子在有限元背景下应用的理解，将抽象的数学概念转化为具体的矢量场表示。",
            "id": "3313865",
            "problem": "考虑在计算电磁学有限元公式中使用的参考四面体 $T$，其顶点为 $v_{0}=(0,0,0)$、$v_{1}=(1,0,0)$、$v_{2}=(0,1,0)$ 和 $v_{3}=(0,0,1)$，以及从 $v_{0}$ 到 $v_{1}$ 的定向边 $[v_{0},v_{1}]$。令 $\\lambda_{0}$、$\\lambda_{1}$、$\\lambda_{2}$ 和 $\\lambda_{3}$ 表示 $T$ 上的重心坐标，并令 $\\nabla\\lambda_{a}$ 表示它们的梯度。\n\n在用于求解麦克斯韦方程组的高阶旋度协调有限元中，Nedelec第一类（边）形函数由与定向边相关的Whitney 1-形式和标量多项式构造而成。使用重心坐标和Whitney 1-形式的基本定义，并遵守给定的边方向，执行以下操作：\n\n1.  通过将 $[v_{0},v_{1}]$ 的Whitney 1-形式分别乘以标量线性多项式 $\\lambda_{0}$ 和 $\\lambda_{1}$，在 $T$ 上构造两个与定向边 $[v_{0},v_{1}]$ 相关的显式 $p=2$ Nedelec第一类边形函数。将每个形函数显式地写成 $(x,y,z)$ 坐标下的向量场。\n\n2.  显式计算第1部分中两个形函数的旋度。\n\n3.  计算在 $T$ 上由标量因子 $\\lambda_{1}$ 构造的形函数的旋度的模的平方的积分，即\n$$\n\\int_{T} \\left\\| \\nabla \\times \\big(\\lambda_{1} \\, \\mathbf{w}_{01}\\big) \\right\\|^{2} \\, \\mathrm{d}V,\n$$\n并将最终结果表示为精确值（无四舍五入）。\n\n你的最终答案应该是第3部分中积分的单个值，以精确形式表示，无单位。",
            "solution": "此问题需要进行验证。\n\n### 步骤1：提取已知条件\n-   **几何**：参考四面体 $T$，顶点为 $v_{0}=(0,0,0)$、$v_{1}=(1,0,0)$、$v_{2}=(0,1,0)$ 和 $v_{3}=(0,0,1)$。\n-   **边**：定向边 $[v_{0},v_{1}]$。\n-   **坐标**：重心坐标 $\\lambda_{0}$、$\\lambda_{1}$、$\\lambda_{2}$、$\\lambda_{3}$。\n-   **背景**：高阶（$p=2$）Nedelec第一类（边）旋度协调有限元。\n-   **任务1**：通过将 $[v_{0},v_{1}]$ 的Whitney 1-形式（表示为 $\\mathbf{w}_{01}$）乘以标量线性多项式 $\\lambda_{0}$ 和 $\\lambda_{1}$ 来构造两个形函数。\n-   **任务2**：计算所构造的两个形函数各自的旋度。\n-   **任务3**：计算积分 $\\int_{T} \\left\\| \\nabla \\times \\big(\\lambda_{1} \\, \\mathbf{w}_{01}\\big) \\right\\|^{2} \\, \\mathrm{d}V$。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在应用数学和工程的一个标准领域，即计算电磁学的有限元方法中，有充分的依据。重心坐标、Whitney形式（最低阶Nedelec元）和高阶元构造的概念是基础且陈述正确的。\n-   **良定性**：该问题是良定的。几何形状已明确定义，要构造的函数由标准程序指定，最终要计算的量是一个明确定义的定积分。唯一解所需的所有信息都已给出。\n-   **客观性**：该问题以客观的数学语言陈述，没有歧义或主观论断。\n\n### 步骤3：结论与行动\n该问题被视为有效。将提供完整解答。\n\n***\n\n解答过程首先定义指定参考四面体的重心坐标及其梯度。然后，构造边 $[v_{0},v_{1}]$ 的Whitney 1-形式。随后，推导出所要求的两个高阶形函数及其旋度。最后，计算指定的积分。\n\n四面体 $T$ 内的一点 $\\mathbf{r} = (x,y,z)$ 可以使用重心坐标 $\\lambda_i$ 表示为 $\\mathbf{r} = \\sum_{i=0}^{3} \\lambda_i v_i$，其中 $\\sum_{i=0}^{3} \\lambda_i = 1$。给定顶点 $v_{0}=(0,0,0)$、$v_{1}=(1,0,0)$、$v_{2}=(0,1,0)$ 和 $v_3=(0,0,1)$，这变为：\n$$\n(x,y,z) = \\lambda_0(0,0,0) + \\lambda_1(1,0,0) + \\lambda_2(0,1,0) + \\lambda_3(0,0,1) = (\\lambda_1, \\lambda_2, \\lambda_3).\n$$\n因此，我们有 $\\lambda_1 = x$，$\\lambda_2 = y$ 和 $\\lambda_3 = z$。第四个坐标由求和约束确定：$\\lambda_0 = 1 - \\lambda_1 - \\lambda_2 - \\lambda_3 = 1-x-y-z$。\n\n重心坐标的梯度是常向量：\n$$\n\\nabla \\lambda_0 = (-1, -1, -1) \\\\\n\\nabla \\lambda_1 = (1, 0, 0) \\\\\n\\nabla \\lambda_2 = (0, 1, 0) \\\\\n\\nabla \\lambda_3 = (0, 0, 1)\n$$\n\n与定向边 $[v_i, v_j]$ 相关的Whitney 1-形式，或最低阶Nedelec边函数，由 $\\mathbf{w}_{ij} = \\lambda_i \\nabla \\lambda_j - \\lambda_j \\nabla \\lambda_i$ 给出。对于边 $[v_{0}, v_{1}]$，这是：\n$$\n\\mathbf{w}_{01} = \\lambda_0 \\nabla \\lambda_1 - \\lambda_1 \\nabla \\lambda_0 = (1-x-y-z)(1,0,0) - x(-1,-1,-1) = (1-x-y-z+x, x, x) = (1-y-z, x, x).\n$$\n\n**1. 高阶形函数的构造**\n\n与边 $[v_{0},v_{1}]$ 相关的两个 $p=2$ Nedelec形函数是通过将 $\\mathbf{w}_{01}$ 乘以 $\\lambda_{0}$ 和 $\\lambda_{1}$ 形成的。我们将其表示为 $\\mathbf{N}_A$ 和 $\\mathbf{N}_B$。\n\n函数 A (使用 $\\lambda_0$)：\n$$\n\\mathbf{N}_A = \\lambda_0 \\mathbf{w}_{01} = (1-x-y-z)(1-y-z, x, x) = \\big( (1-y-z)^2 - x(1-y-z), x(1-x-y-z), x(1-x-y-z) \\big).\n$$\n\n函数 B (使用 $\\lambda_1$)：\n$$\n\\mathbf{N}_B = \\lambda_1 \\mathbf{w}_{01} = x(1-y-z, x, x) = (x-xy-xz, x^2, x^2).\n$$\n\n**2. 旋度的计算**\n\n我们使用向量恒等式 $\\nabla \\times (f \\mathbf{F}) = (\\nabla f) \\times \\mathbf{F} + f(\\nabla \\times \\mathbf{F})$。\n首先，我们计算Whitney形式 $\\mathbf{w}_{01}$ 的旋度。\n$$\n\\nabla \\times \\mathbf{w}_{01} = \\nabla \\times (\\lambda_0 \\nabla \\lambda_1 - \\lambda_1 \\nabla \\lambda_0) = (\\nabla \\lambda_0 \\times \\nabla \\lambda_1) - (\\nabla \\lambda_1 \\times \\nabla \\lambda_0) = 2(\\nabla \\lambda_0 \\times \\nabla \\lambda_1).\n$$\n梯度的叉积为：\n$$\n\\nabla \\lambda_0 \\times \\nabla \\lambda_1 = (-1, -1, -1) \\times (1, 0, 0) = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ -1  -1  -1 \\\\ 1  0  0 \\end{vmatrix} = (0, -1, 1).\n$$\n因此，Whitney形式的旋度是一个常向量：\n$$\n\\nabla \\times \\mathbf{w}_{01} = 2(0, -1, 1) = (0, -2, 2).\n$$\n现在我们计算 $\\mathbf{N}_A$ 和 $\\mathbf{N}_B$ 的旋度。\n\n$\\mathbf{N}_A$ 的旋度：\n$$\n\\nabla \\times \\mathbf{N}_A = \\nabla \\times (\\lambda_0 \\mathbf{w}_{01}) = (\\nabla \\lambda_0) \\times \\mathbf{w}_{01} + \\lambda_0 (\\nabla \\times \\mathbf{w}_{01}).\n$$\n第一项是：\n$$\n(\\nabla \\lambda_0) \\times \\mathbf{w}_{01} = (-1, -1, -1) \\times (1-y-z, x, x) = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ -1  -1  -1 \\\\ 1-y-z  x  x \\end{vmatrix} = (0, -x - (-1)(1-y-z), -x - (-1)(1-y-z)) = (0, 1-x-y-z, -(1-x-y-z))\n$$\n等等，重新计算j分量：$-[(-1)(x) - (-1)(1-y-z)] = -[-x+1-y-z] = x-1+y+z = -\\lambda_0$。k分量是$(-1)(x) - (-1)(1-y-z) = -x + 1 - y - z = \\lambda_0$。\n所以，$(\\nabla \\lambda_0) \\times \\mathbf{w}_{01} = (0, -\\lambda_0, \\lambda_0)$。\n合并各项：\n$$\n\\nabla \\times \\mathbf{N}_A = (0, -\\lambda_0, \\lambda_0) + \\lambda_0(0, -2, 2) = (0, -3\\lambda_0, 3\\lambda_0) = (0, 3x+3y+3z-3, 3-3x-3y-3z).\n$$\n\n$\\mathbf{N}_B$ 的旋度：\n$$\n\\nabla \\times \\mathbf{N}_B = \\nabla \\times (\\lambda_1 \\mathbf{w}_{01}) = (\\nabla \\lambda_1) \\times \\mathbf{w}_{01} + \\lambda_1 (\\nabla \\times \\mathbf{w}_{01}).\n$$\n第一项是：\n$$\n(\\nabla \\lambda_1) \\times \\mathbf{w}_{01} = (1, 0, 0) \\times (1-y-z, x, x) = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ 1  0  0 \\\\ 1-y-z  x  x \\end{vmatrix} = (0, -x, x).\n$$\n用重心坐标表示，这是 $(0, -\\lambda_1, \\lambda_1)$。\n合并各项：\n$$\n\\nabla \\times \\mathbf{N}_B = (0, -\\lambda_1, \\lambda_1) + \\lambda_1(0, -2, 2) = (0, -3\\lambda_1, 3\\lambda_1) = (0, -3x, 3x).\n$$\n\n**3. 积分的计算**\n\n问题要求计算 $I = \\int_{T} \\left\\| \\nabla \\times \\big(\\lambda_{1} \\, \\mathbf{w}_{01}\\big) \\right\\|^{2} \\, \\mathrm{d}V$。\n从上一步可知，$\\nabla \\times (\\lambda_{1} \\, \\mathbf{w}_{01}) = (0, -3x, 3x)$。\n其模的平方为：\n$$\n\\left\\| (0, -3x, 3x) \\right\\|^2 = (0)^2 + (-3x)^2 + (3x)^2 = 9x^2 + 9x^2 = 18x^2.\n$$\n积分变为：\n$$\nI = \\int_T 18x^2 \\, \\mathrm{d}V.\n$$\n我们可以使用在单纯形上对多项式积分的标准公式来计算这个积分，该公式用重心坐标表示。被积函数用重心坐标表示为 $18\\lambda_1^2$。公式为：\n$$\n\\int_T \\lambda_0^{a_0} \\lambda_1^{a_1} \\lambda_2^{a_2} \\lambda_3^{a_3} \\, \\mathrm{d}V = n! V_T \\frac{a_0! a_1! a_2! a_3!}{(a_0+a_1+a_2+a_3+n)!}\n$$\n其中 $n=3$ 是空间维度，$V_T$ 是四面体的体积。对于给定的顶点，体积是 $V_T = \\frac{1}{6} \\left| \\det \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\right| = \\frac{1}{6}$。\n我们的积分是 $18 \\int_T \\lambda_1^2 \\, \\mathrm{d}V$，这对应于 $a_1=2$ 和 $a_0=a_2=a_3=0$。\n$$\nI = 18 \\left( 3! \\cdot V_T \\cdot \\frac{0! \\, 2! \\, 0! \\, 0!}{(0+2+0+0+3)!} \\right) = 18 \\left( 6 \\cdot \\frac{1}{6} \\cdot \\frac{1 \\cdot 2 \\cdot 1 \\cdot 1}{5!} \\right) = 18 \\left( 1 \\cdot \\frac{2}{120} \\right) = 18 \\left( \\frac{1}{60} \\right).\n$$\n$$\nI = \\frac{18}{60} = \\frac{3}{10}.\n$$\n\n为了完整性，我们可以使用笛卡尔坐标下的直接积分来验证此结果。积分区域是 $x \\in [0,1]$，$y \\in [0, 1-x]$，$z \\in [0, 1-x-y]$。\n$$\nI = \\int_0^1 \\int_0^{1-x} \\int_0^{1-x-y} 18x^2 \\, \\mathrm{d}z \\, \\mathrm{d}y \\, \\mathrm{d}x\n$$\n$$\nI = 18 \\int_0^1 x^2 \\int_0^{1-x} [z]_0^{1-x-y} \\, \\mathrm{d}y \\, \\mathrm{d}x = 18 \\int_0^1 x^2 \\int_0^{1-x} (1-x-y) \\, \\mathrm{d}y \\, \\mathrm{d}x\n$$\n$$\nI = 18 \\int_0^1 x^2 \\left[ (1-x)y - \\frac{y^2}{2} \\right]_0^{1-x} \\, \\mathrm{d}x = 18 \\int_0^1 x^2 \\left( (1-x)^2 - \\frac{(1-x)^2}{2} \\right) \\, \\mathrm{d}x\n$$\n$$\nI = 18 \\int_0^1 x^2 \\frac{(1-x)^2}{2} \\, \\mathrm{d}x = 9 \\int_0^1 x^2(1 - 2x + x^2) \\, \\mathrm{d}x = 9 \\int_0^1 (x^2 - 2x^3 + x^4) \\, \\mathrm{d}x\n$$\n$$\nI = 9 \\left[ \\frac{x^3}{3} - \\frac{2x^4}{4} + \\frac{x^5}{5} \\right]_0^1 = 9 \\left( \\frac{1}{3} - \\frac{1}{2} + \\frac{1}{5} \\right) = 9 \\left( \\frac{10 - 15 + 6}{30} \\right) = 9 \\left( \\frac{1}{30} \\right) = \\frac{9}{30} = \\frac{3}{10}.\n$$\n两种方法得到相同的结果，证实了计算的正确性。",
            "answer": "$$\\boxed{\\frac{3}{10}}$$"
        },
        {
            "introduction": "在有限元方法的实际编程中，精确且高效地计算单元矩阵至关重要，这直接依赖于数值积分（quadrature）的正确选择。本练习将引导您推导在使用仿射映射的单元上，$\\mathbf{H}(\\mathrm{curl})$元质量矩阵和刚度矩阵被积函数的精确多项式阶数。这项实践将理论与实现连接起来，揭示了为保证计算精度所需的最简积分阶数，这是编写任何有限元代码都必须考虑的核心问题。",
            "id": "3313862",
            "problem": "考虑在单个三维四面体单元上的频域计算电磁学公式。设材料系数在单元上为常数，其中介电常数表示为 $\\varepsilon$，磁导率表示为 $\\mu$。弱形式使用来自旋度平方可积的平方可积向量场的索伯列夫空间 $\\mathbf{H}(\\mathrm{curl})$ 中的试探函数和检验函数，该空间由多项式阶数为 $p \\in \\mathbb{N}$ 的第一类 Nédélec $\\mathbf{H}(\\mathrm{curl})$ 有限元进行离散。假设存在一个从参考四面体 $\\hat{T}$ 到物理四面体 $T$ 的仿射映射 $\\mathbf{x} = F(\\hat{\\mathbf{x}})$，其雅可比矩阵 $\\mathbf{J} = \\frac{\\partial \\mathbf{x}}{\\partial \\hat{\\mathbf{x}}}$ 为常数，且行列式 $\\det(\\mathbf{J}) \\neq 0$。在参考单元上，基函数的分量是总阶数至多为 $p$ 的多项式，并且微分会使多项式阶数减一。\n\n单元质量双线性形式为\n$$\nm(\\mathbf{E}, \\mathbf{F}) = \\int_{T} \\varepsilon \\, \\mathbf{E} \\cdot \\mathbf{F} \\, \\mathrm{d}\\mathbf{x},\n$$\n以及旋度-旋度双线性形式为\n$$\na(\\mathbf{E}, \\mathbf{F}) = \\int_{T} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{F}) \\, \\mathrm{d}\\mathbf{x}.\n$$\n\n在协变 $\\mathbf{H}(\\mathrm{curl})$ Piola 变换下，物理场满足 $\\mathbf{E}(\\mathbf{x}) = \\mathbf{J}^{-T} \\hat{\\mathbf{E}}(\\hat{\\mathbf{x}})$，其旋度的变换形式为\n$$\n\\nabla \\times \\mathbf{E}(\\mathbf{x}) = \\det(\\mathbf{J})^{-1} \\, \\mathbf{J} \\, (\\hat{\\nabla} \\times \\hat{\\mathbf{E}})(\\hat{\\mathbf{x}}),\n$$\n其中 $\\hat{\\nabla}$ 表示对参考坐标的微分。\n\n在参考单元 $\\hat{T}$ 上，推导应用仿射映射后 $m(\\mathbf{E}, \\mathbf{F})$ 和 $a(\\mathbf{E}, \\mathbf{F})$ 的被积函数的最大总多项式阶数。利用这些阶数，确定在 $\\hat{T}$ 上精确积分每个双线性形式所需的最小精确求积阶数。请用 $p$ 表示你的最终答案，形式为一个双元素行矩阵 $\\big[m\\text{ 的求积阶数}, a\\text{ 的求积阶数}\\big]$。最终答案中无需数值取整，也无需报告物理单位。",
            "solution": "推导从基函数的多项式结构及其在仿射映射下的变换开始。在参考四面体 $\\hat{T}$ 上，阶数为 $p$ 的第一类 Nédélec $\\mathbf{H}(\\mathrm{curl})$ 基函数是向量值多项式，其分量的总阶数至多为 $p$。微分会使总阶数减一，因此对于任何此类参考场 $\\hat{\\mathbf{E}}$，其参考旋度 $\\hat{\\nabla} \\times \\hat{\\mathbf{E}}$ 的分量总阶数至多为 $p-1$。\n\n对于仿射映射 $F$，在协变 $\\mathbf{H}(\\mathrm{curl})$ Piola 映射下，物理场及其旋度与参考场的关系如下\n$$\n\\mathbf{E}(\\mathbf{x}) = \\mathbf{J}^{-T} \\hat{\\mathbf{E}}(\\hat{\\mathbf{x}}), \\quad \\nabla \\times \\mathbf{E}(\\mathbf{x}) = \\det(\\mathbf{J})^{-1} \\, \\mathbf{J} \\, (\\hat{\\nabla} \\times \\hat{\\mathbf{E}})(\\hat{\\mathbf{x}}),\n$$\n其中 $\\mathbf{J}$ 和 $\\det(\\mathbf{J})$ 是常数。单元积分通过 $\\mathrm{d}\\mathbf{x} = \\det(\\mathbf{J}) \\, \\mathrm{d}\\hat{\\mathbf{x}}$ 进行变换。\n\n我们现在分别考虑每种双线性形式。\n\n对于质量双线性形式，\n$$\nm(\\mathbf{E}, \\mathbf{F}) = \\int_{T} \\varepsilon \\, \\mathbf{E} \\cdot \\mathbf{F} \\, \\mathrm{d}\\mathbf{x} = \\int_{\\hat{T}} \\varepsilon \\, \\big(\\mathbf{J}^{-T} \\hat{\\mathbf{E}}(\\hat{\\mathbf{x}})\\big) \\cdot \\big(\\mathbf{J}^{-T} \\hat{\\mathbf{F}}(\\hat{\\mathbf{x}})\\big) \\, \\det(\\mathbf{J}) \\, \\mathrm{d}\\hat{\\mathbf{x}}.\n$$\n由于 $\\mathbf{J}^{-T}$ 和 $\\det(\\mathbf{J})$ 是常数，它们不改变多项式的阶数。两个分量阶数至多为 $p$ 的向量多项式的点积，产生一个阶数至多为 $2p$ 的标量多项式。因此，在 $\\hat{T}$ 上，质量形式的被积函数的最大总多项式阶数为\n$$\n\\deg_{\\mathrm{mass}} = 2p.\n$$\n在四面体上，一个阶数为 $q$ 的求积法则可以精确积分所有总阶数不超过 $q$ 的多项式。因此，质量双线性形式所需的最小精确求积阶数为\n$$\nq_{\\mathrm{mass}}^{\\min} = 2p.\n$$\n\n对于旋度-旋度双线性形式，\n$$\na(\\mathbf{E}, \\mathbf{F}) = \\int_{T} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{F}) \\, \\mathrm{d}\\mathbf{x} = \\int_{\\hat{T}} \\mu^{-1} \\, \\Big(\\det(\\mathbf{J})^{-1} \\mathbf{J} (\\hat{\\nabla} \\times \\hat{\\mathbf{E}})\\Big) \\cdot \\Big(\\det(\\mathbf{J})^{-1} \\mathbf{J} (\\hat{\\nabla} \\times \\hat{\\mathbf{F}})\\Big) \\, \\det(\\mathbf{J}) \\, \\mathrm{d}\\hat{\\mathbf{x}}.\n$$\n合并常数项，\n$$\na(\\mathbf{E}, \\mathbf{F}) = \\int_{\\hat{T}} \\mu^{-1} \\, \\det(\\mathbf{J})^{-1} \\, \\big(\\mathbf{J} (\\hat{\\nabla} \\times \\hat{\\mathbf{E}})\\big) \\cdot \\big(\\mathbf{J} (\\hat{\\nabla} \\times \\hat{\\mathbf{F}})\\big) \\, \\mathrm{d}\\hat{\\mathbf{x}}.\n$$\n同样，常数因子 $\\mu^{-1}$、$\\det(\\mathbf{J})^{-1}$ 和 $\\mathbf{J}$ 不影响多项式的阶数。每个参考旋度 $\\hat{\\nabla} \\times \\hat{\\mathbf{E}}$ 和 $\\hat{\\nabla} \\times \\hat{\\mathbf{F}}$ 的分量阶数至多为 $p-1$，因此它们的点积是一个最大阶数为...的标量多项式。\n$$\n\\deg_{\\text{curl-curl}} = 2(p-1) = 2p - 2.\n$$\n因此，在四面体上，旋度-旋度双线性形式所需的最小精确求积阶数为\n$$\nq_{\\mathrm{curl\\text{-}curl}}^{\\min} = 2p - 2.\n$$\n\n总之，在参考四面体 $\\hat{T}$ 上，质量双线性形式的最小精确求积阶数为 $2p$，旋度-旋度双线性形式的最小精确求积阶数为 $2p - 2$。这些结果是直接从仿射映射和协变 $\\mathbf{H}(\\mathrm{curl})$ Piola 变换下被积函数的最大多项式阶数，以及在单形上求积阶数由能被精确积分的最大总阶数定义这一事实得出的。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2p  2p - 2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "将理论知识转化为可执行的代码是计算科学的核心技能。这个综合性练习将指导您在参考四边形上，实现一个三阶模态Nédélec基函数集，并用其计算单元质量矩阵的相关矩阵块。通过这个编码实践，您将处理基函数的正交性、使用张量积高斯积分，并验证实现的正确性，从而全面掌握高阶有限元方法的实现细节。",
            "id": "3313866",
            "problem": "考虑无源区域中的时谐麦克斯韦方程组，其中电场在平方可积且旋度平方可积的场构成的索博列夫空间（表示为 $H(\\mathrm{curl})$）中表示。有限元方法（FEM）使用 $H(\\mathrm{curl})$-协调的基函数，特别是 Jean-Claude Nédélec 引入的、通常称为 Nédélec 单元的函数族。在参考四边形单元上，阶数为 $p$ 的第二类 Nédélec 函数族提供了分层、旋度协调的矢量多项式基函数，其切向迹沿着每条边是次数最高为 $p$ 的多项式，从而确保了单元间边界的切向连续性。\n\n您的任务是在参考四边形 $[-1,1]\\times[-1,1]$ 上，为多项式阶数 $p=3$ 实现一个仅限于边函数的模态第二类 Nédélec 基，通过适当的模态多项式确保这些模式的边正交性，并使用足够阶数的张量积 Gauss–Legendre 求积法计算单元质量矩阵对应的边-边块。\n\n请基于以下基本原理进行操作：\n- 对于 $H(\\mathrm{curl})$ 场，切向连续性要求意味着，对于每条边，矢量基函数沿该边的切向分量必须是边坐标中次数最多为 $p$ 的多项式，并且其在所有其他边上的切向迹必须为零。\n- 模态边函数的正交性可以通过为边坐标选择沿 $[-1,1]$ 的一组标准正交多项式族来施加，使得沿该边的 $L^{2}$ 内积产生克罗内克 δ。\n- 两个基函数 $\\mathbf{v}_{i}$ 和 $\\mathbf{v}_{j}$ 之间的单元质量矩阵项定义为\n$$\nM_{ij} \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{v}_{i}(x,y)\\cdot \\mathbf{v}_{j}(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n这要求求积法对被积函数的多项式次数具有精确性。\n\n为确保任务可测试且自成体系，请实现以下具体选择：\n- 对 $k\\in\\{0,1,2,3\\}$，使用 $[-1,1]$ 上的标准正交勒让德多项式，记为 $P_{k}(s)$，定义为 $P_{k}(s)=\\sqrt{\\frac{2k+1}{2}}\\,L_{k}(s)$，其中 $L_{k}(s)$ 是 $k$ 次标准勒让德多项式。\n- 定义边混合函数，其在指定边上等于 $1$，在对边上等于 $0$，并且在单元内呈线性变化：\n  - 上边（$y=1$，切线方向沿 $x$）：$E_{\\mathrm{top}}(y)=\\frac{1+y}{2}$ 和单位切向量 $\\mathbf{t}_{\\mathrm{top}}=(1,0)$。\n  - 下边（$y=-1$，切线方向沿 $x$）：$E_{\\mathrm{bot}}(y)=\\frac{1-y}{2}$ 和单位切向量 $\\mathbf{t}_{\\mathrm{bot}}=(1,0)$。\n  - 右边（$x=1$，切线方向沿 $y$）：$E_{\\mathrm{right}}(x)=\\frac{1+x}{2}$ 和单位切向量 $\\mathbf{t}_{\\mathrm{right}}=(0,1)$。\n  - 左边（$x=-1$，切线方向沿 $y$）：$E_{\\mathrm{left}}(x)=\\frac{1-x}{2}$ 和单位切向量 $\\mathbf{t}_{\\mathrm{left}}=(0,1)$。\n- 为 $k\\in\\{0,1,2,3\\}$ 构造边基函数如下：\n  - 上边模式：$\\mathbf{v}^{\\mathrm{top}}_{k}(x,y)=P_{k}(x)\\,E_{\\mathrm{top}}(y)\\,\\mathbf{t}_{\\mathrm{top}}$。\n  - 下边模式：$\\mathbf{v}^{\\mathrm{bot}}_{k}(x,y)=P_{k}(x)\\,E_{\\mathrm{bot}}(y)\\,\\mathbf{t}_{\\mathrm{bot}}$。\n  - 右边模式：$\\mathbf{v}^{\\mathrm{right}}_{k}(x,y)=P_{k}(y)\\,E_{\\mathrm{right}}(x)\\,\\mathbf{t}_{\\mathrm{right}}$。\n  - 左边模式：$\\mathbf{v}^{\\mathrm{left}}_{k}(x,y)=P_{k}(y)\\,E_{\\mathrm{left}}(x)\\,\\mathbf{t}_{\\mathrm{left}}$。\n\n在您的实现中确保以下几点：\n- 边正交性：在指定边上，$\\mathbf{v}_{k}$ 和 $\\mathbf{v}_{m}$ 之间的切向 $L^{2}$ 内积必须满足\n$$\n\\int_{-1}^{1} \\left(\\mathbf{v}_{k}\\cdot \\mathbf{t}\\right)\\left(\\mathbf{v}_{m}\\cdot \\mathbf{t}\\right)\\,\\mathrm{d}\\ell \\;=\\; \\delta_{km},\n$$\n其中 $\\mathbf{t}$ 是边切向单位向量，$\\mathrm{d}\\ell$ 是沿边的线元，使用对最高 $2p$ 次多项式足够精确的数值求积法。\n- 单元质量矩阵块：在 $[-1,1]\\times[-1,1]$ 上使用张量积 Gauss–Legendre 求积法，计算上边模式 $\\{\\mathbf{v}^{\\mathrm{top}}_{k}\\}_{k=0}^{3}$ 的单元质量矩阵的边-边块，选择的求积阶数应能精确积分 $x$ 方向最高 6 次、$y$ 方向最高 2 次的多项式。\n\n设计一个测试套件，用可量化的结果来验证实现：\n- 测试 1（上边的边正交性）：验证对于所有 $(k,m)\\in\\{0,1,2,3\\}\\times\\{0,1,2,3\\}$，切向内积 $\\int_{-1}^{1}P_{k}(x)P_{m}(x)\\,\\mathrm{d}x$ 的数值计算结果在 $10^{-12}$ 的容差内，当 $k=m$ 时为 $1$，当 $k\\neq m$ 时为 $0$。输出一个布尔值，表示整个集合是否通过测试。\n- 测试 2（上边模式的质量矩阵对角线）：对于 $k\\in\\{0,1,2,3\\}$，使用在 $x$ 方向有 $n_{x}=4$ 个点、在 $y$ 方向有 $n_{y}=2$ 个点的张量积 Gauss–Legendre 求积法，计算 $M_{kk}=\\int_{-1}^{1}\\int_{-1}^{1}\\mathbf{v}^{\\mathrm{top}}_{k}\\cdot \\mathbf{v}^{\\mathrm{top}}_{k}\\,\\mathrm{d}x\\,\\mathrm{d}y$。以浮点数列表形式输出四个对角线值。\n- 测试 3（相同模式指数的上-下边耦合）：对于 $k\\in\\{0,1,2,3\\}$，使用与测试 2 相同的求积法，计算 $C_{k}=\\int_{-1}^{1}\\int_{-1}^{1}\\mathbf{v}^{\\mathrm{top}}_{k}\\cdot \\mathbf{v}^{\\mathrm{bot}}_{k}\\,\\mathrm{d}x\\,\\mathrm{d}y$。以浮点数列表形式输出四个耦合值。\n- 测试 4（水平-垂直解耦）：使用 $n_{x}=4$、$n_{y}=2$ 计算一个代表性的交叉方向质量项 $\\int_{-1}^{1}\\int_{-1}^{1}\\mathbf{v}^{\\mathrm{top}}_{2}\\cdot \\mathbf{v}^{\\mathrm{left}}_{1}\\,\\mathrm{d}x\\,\\mathrm{d}y$。输出这个单一浮点数，其数值上应为 $0$。\n- 测试 5（求积不充分的边界情况）：使用不充分的求积法（$n_{x}=1$，$n_{y}=1$）计算上边的 $M_{33}$，并报告其与测试 2 中为 $k=3$ 计算出的值的绝对差。输出这个单一浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$[\\text{测试 1布尔值}, \\text{测试 2列表}, \\text{测试 3列表}, \\text{测试 4浮点数}, \\text{测试 5浮点数}]$。本问题不涉及物理单位，也不需要角度。正交性检查中的数值比较容差为 $10^{-12}$。",
            "solution": "用户提供了一个有效且适定的问题。该问题是一项基于有限元方法（FEM）的计算任务，应用于计算电磁学。它自成体系，科学上合理，且所有术语都有正式定义。\n\n该问题要求在参考四边形单元上实现并验证阶数为 $p=3$ 的模态第二类 Nédélec 边基函数。这包括使用标准正交勒让德多项式定义基函数，然后使用张量积 Gauss-Legendre 求积法计算单元质量矩阵的特定项。\n\n首先，我们建立数学组件。基函数建立在区间 $[-1, 1]$ 上的标准正交勒让德多项式族之上。$k$ 次标准勒让德多项式 $L_k(s)$ 被归一化以得到 $P_k(s)$：\n$$\nP_k(s) = \\sqrt{\\frac{2k+1}{2}} L_k(s)\n$$\n根据定义，这些多项式在 $[-1, 1]$ 上关于 $L^2$ 内积构成一个标准正交集，满足：\n$$\n\\int_{-1}^{1} P_k(s) P_m(s) \\, \\mathrm{d}s = \\delta_{km}\n$$\n其中 $\\delta_{km}$ 是克罗内克 δ。\n\n矢量基函数是通过将这些多项式与线性混合函数和恒定切向量组合而成的。混合函数，例如 $E_{\\mathrm{top}}(y) = \\frac{1+y}{2}$，确保基函数的切向分量在其关联边上（例如，上边为 $y=1$）非零，而在对边上（例如，$y=-1$）为零。对于 $k \\in \\{0, 1, 2, 3\\}$ 的四族边基函数是：\n\\begin{itemize}\n    \\item 上边: $\\mathbf{v}^{\\mathrm{top}}_{k}(x,y) = P_{k}(x) \\left(\\frac{1+y}{2}\\right) (1, 0)$\n    \\item 下边: $\\mathbf{v}^{\\mathrm{bot}}_{k}(x,y) = P_{k}(x) \\left(\\frac{1-y}{2}\\right) (1, 0)$\n    \\item 右边: $\\mathbf{v}^{\\mathrm{right}}_{k}(x,y) = P_{k}(y) \\left(\\frac{1+x}{2}\\right) (0, 1)$\n    \\item 左边: $\\mathbf{v}^{\\mathrm{left}}_{k}(x,y) = P_{k}(y) \\left(\\frac{1-x}{2}\\right) (0, 1)$\n\\end{itemize}\n\n核心任务是计算单元质量矩阵的各项，其定义为积分 $M_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{v}_{i}(x,y) \\cdot \\mathbf{v}_{j}(x,y) \\, \\mathrm{d}x\\,\\mathrm{d}y$。这些积分使用张量积 Gauss-Legendre 求积法进行数值计算。该方法将二维积分近似为求积点网格上的和：\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} g(x,y) \\, \\mathrm{d}x\\,\\mathrm{d}y \\approx \\sum_{i=1}^{n_x} \\sum_{j=1}^{n_y} w_{x,i} w_{y,j} g(x_i, y_j)\n$$\n其中 $(x_i, w_{x,i})$ 和 $(y_j, w_{y,j})$ 分别是 $x$ 和 $y$ 方向的 Gauss-Legendre 求积点和权重。具有 $n$ 个点的一维 Gauss-Legendre 法则可以精确积分最高 $2n-1$ 次的多项式。\n\n该问题定义了五个测试来验证实现。\n\n**测试 1：边正交性**\n此测试验证基函数沿其对应边的切向迹的标准正交性。对于上边，切向分量为 $\\mathbf{v}^{\\mathrm{top}}_{k} \\cdot \\mathbf{t}_{\\mathrm{top}} = P_k(x)$。测试对 $k, m \\in \\{0, 1, 2, 3\\}$ 数值计算 $\\int_{-1}^{1} P_k(x) P_m(x) \\, \\mathrm{d}x$。被积函数的最大多项式次数为 $3+3=6$（当 $k=m=3$ 时）。要精确积分此式，具有 $n$ 个点的 Gauss-Legendre 法则必须满足 $2n-1 \\ge 6$，即 $n \\ge 3.5$。因此，$n=4$ 个点就足够了。在小容差范围内，当 $k=m$ 时结果应为 $1$，当 $k \\neq m$ 时结果应为 $0$。\n\n**测试 2：上边模式的质量矩阵对角线**\n此测试计算 $M_{kk} = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{v}^{\\mathrm{top}}_{k} \\cdot \\mathbf{v}^{\\mathrm{top}}_{k} \\, \\mathrm{d}x\\,\\mathrm{d}y$。被积函数为：\n$$\n\\mathbf{v}^{\\mathrm{top}}_{k} \\cdot \\mathbf{v}^{\\mathrm{top}}_{k} = \\left( P_k(x) \\frac{1+y}{2} \\right)^2 = P_k(x)^2 \\left( \\frac{1+y}{2} \\right)^2\n$$\n积分为可分离的：\n$$\nM_{kk} = \\left( \\int_{-1}^{1} P_k(x)^2 \\, \\mathrm{d}x \\right) \\left( \\int_{-1}^{1} \\left( \\frac{1+y}{2} \\right)^2 \\, \\mathrm{d}y \\right) = (1) \\cdot \\left( \\frac{1}{4} \\int_{-1}^{1} (1+2y+y^2) \\, \\mathrm{d}y \\right) = \\frac{1}{4} \\left[ y + y^2 + \\frac{y^3}{3} \\right]_{-1}^{1} = \\frac{2}{3}\n$$\n被积函数在 $x$ 方向的次数为 $2k$（最高为 6），在 $y$ 方向的次数为 2。指定的求积法（$n_x=4$, $n_y=2$）对于 $x$ 方向最高 $2(4)-1=7$ 次、$y$ 方向最高 $2(2)-1=3$ 次的多项式是精确的。这已足够，因此每个 $k$ 的数值结果应为 $\\frac{2}{3}$。\n\n**测试 3：上-下边耦合**\n此测试计算 $C_k = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{v}^{\\mathrm{top}}_{k} \\cdot \\mathbf{v}^{\\mathrm{bot}}_{k} \\, \\mathrm{d}x\\,\\mathrm{d}y$。被积函数为：\n$$\n\\mathbf{v}^{\\mathrm{top}}_{k} \\cdot \\mathbf{v}^{\\mathrm{bot}}_{k} = \\left( P_k(x) \\frac{1+y}{2} \\right) \\left( P_k(x) \\frac{1-y}{2} \\right) = P_k(x)^2 \\left( \\frac{1-y^2}{4} \\right)\n$$\n该积分也是可分离的：\n$$\nC_k = \\left( \\int_{-1}^{1} P_k(x)^2 \\, \\mathrm{d}x \\right) \\left( \\int_{-1}^{1} \\frac{1-y^2}{4} \\, \\mathrm{d}y \\right) = (1) \\cdot \\left( \\frac{1}{4} \\left[ y - \\frac{y^3}{3} \\right]_{-1}^{1} \\right) = \\frac{1}{3}\n$$\n被积函数在 $x$ 方向的次数为 $2k$（最高为 6），在 $y$ 方向的次数为 2。求积法（$n_x=4$, $n_y=2$）是精确的，因此每个 $k$ 的数值结果应为 $\\frac{1}{3}$。\n\n**测试 4：水平-垂直解耦**\n此测试计算一个交叉方向质量项 $\\int_{-1}^{1}\\int_{-1}^{1}\\mathbf{v}^{\\mathrm{top}}_{2} \\cdot \\mathbf{v}^{\\mathrm{left}}_{1}\\,\\mathrm{d}x\\,\\mathrm{d}y$。被积函数涉及基向量的点积：\n$$\n\\mathbf{v}^{\\mathrm{top}}_{2} \\cdot \\mathbf{v}^{\\mathrm{left}}_{1} = \\left( P_2(x) E_{\\mathrm{top}}(y) \\mathbf{t}_{\\mathrm{top}} \\right) \\cdot \\left( P_1(y) E_{\\mathrm{left}}(x) \\mathbf{t}_{\\mathrm{left}} \\right)\n$$\n由于 $\\mathbf{t}_{\\mathrm{top}} = (1, 0)$ 且 $\\mathbf{t}_{\\mathrm{left}} = (0, 1)$，它们的点积 $\\mathbf{t}_{\\mathrm{top}} \\cdot \\mathbf{t}_{\\mathrm{left}} = 0$。被积函数恒为零，因此积分解析上为 $0$。任何有效的求积法则都将得出精确的 $0$。\n\n**测试 5：求积不充分**\n此测试使用不充分的求积法则（$n_x=1$ 和 $n_y=1$）重新计算 $M_{33}$。这对应于在 $(x,y)=(0,0)$ 处的单个求积点，权重为 $w_x=2$ 和 $w_y=2$。其近似值为：\n$$\nM_{33} \\approx (2)(2) \\cdot \\left( \\mathbf{v}^{\\mathrm{top}}_{3}(0,0) \\cdot \\mathbf{v}^{\\mathrm{top}}_{3}(0,0) \\right) = 4 \\left( P_3(0) \\frac{1+0}{2} \\right)^2\n$$\n标准勒让德多项式 $L_3(s) = \\frac{1}{2}(5s^3-3s)$ 是一个奇函数，所以 $L_3(0)=0$。因此，$P_3(0)=0$，数值积分结果为 $0$。与正确值（来自测试 2 的 $2/3$）的绝对差为 $|0 - 2/3| = 2/3$。此测试展示了选择足够阶数求积法则的重要性。\n\n实现将遵循这些原则，使用 `numpy` 进行数值数组操作，并使用其多项式子包来处理勒让德多项式和求积法则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre, leggauss\n\ndef solve():\n    \"\"\"\n    Implements and tests modal Nédélec second-kind edge basis functions\n    of order p=3 on a reference quadrilateral.\n    \"\"\"\n\n    # --- Part 1: Helper Functions (Polynomials and Quadrature) ---\n\n    def orthonormal_legendre_poly(k, s):\n        \"\"\"\n        Evaluates the orthonormal Legendre polynomial P_k(s) on [-1, 1].\n        P_k(s) = sqrt((2k+1)/2) * L_k(s), where L_k is the standard Legendre polynomial.\n        \"\"\"\n        if k  0:\n            raise ValueError(\"Polynomial degree k must be non-negative.\")\n        s = np.asarray(s)\n        # Using numpy's Legendre class to represent L_k(s)\n        Lk = Legendre.basis(k)\n        normalization_factor = np.sqrt((2 * k + 1) / 2.0)\n        return normalization_factor * Lk(s)\n\n    def integrate_1d(func, n_quad):\n        \"\"\"\n        Computes 1D integral of func over [-1, 1] using n_quad-point Gauss-Legendre quadrature.\n        \"\"\"\n        points, weights = leggauss(n_quad)\n        return np.sum(weights * func(points))\n\n    def integrate_2d(func, nx_quad, ny_quad):\n        \"\"\"\n        Computes 2D integral of func over [-1, 1] x [-1, 1] using tensor product\n        Gauss-Legendre quadrature.\n        \"\"\"\n        x_points, x_weights = leggauss(nx_quad)\n        y_points, y_weights = leggauss(ny_quad)\n        integral_val = 0.0\n        for i in range(nx_quad):\n            for j in range(ny_quad):\n                integral_val += x_weights[i] * y_weights[j] * func(x_points[i], y_points[j])\n        return integral_val\n\n    # --- Part 2: Basis Function Definitions ---\n\n    def v_top_k(x, y, k):\n        val = orthonormal_legendre_poly(k, x) * ((1 + y) / 2.0)\n        return np.array([val, 0.0])\n\n    def v_bot_k(x, y, k):\n        val = orthonormal_legendre_poly(k, x) * ((1 - y) / 2.0)\n        return np.array([val, 0.0])\n        \n    def v_left_k(x, y, k):\n        val = orthonormal_legendre_poly(k, y) * ((1 - x) / 2.0)\n        return np.array([0.0, val])\n\n    # --- Part 3: Test Suite Execution ---\n\n    results = []\n    \n    # Test 1: Edge Orthogonality on the Top Edge\n    is_orthogonal = True\n    tolerance = 1e-12\n    n_quad_ortho = 4  # Sufficient for degree 2*3=6\n    for k in range(4):\n        for m in range(4):\n            integrand = lambda x: orthonormal_legendre_poly(k, x) * orthonormal_legendre_poly(m, x)\n            integral_val = integrate_1d(integrand, n_quad_ortho)\n            expected = 1.0 if k == m else 0.0\n            if abs(integral_val - expected)  tolerance:\n                is_orthogonal = False\n                break\n        if not is_orthogonal:\n            break\n    results.append(is_orthogonal)\n\n    # Test 2: Mass Matrix Diagonal for Top Edge Modes\n    m_kk_list = []\n    nx, ny = 4, 2\n    for k in range(4):\n        integrand = lambda x, y: np.dot(v_top_k(x, y, k), v_top_k(x, y, k))\n        m_kk = integrate_2d(integrand, nx, ny)\n        m_kk_list.append(m_kk)\n    results.append(m_kk_list)\n    \n    # Test 3: Top-Bottom Coupling for Same Mode Index\n    c_k_list = []\n    for k in range(4):\n        integrand = lambda x, y: np.dot(v_top_k(x, y, k), v_bot_k(x, y, k))\n        c_k = integrate_2d(integrand, nx, ny)\n        c_k_list.append(c_k)\n    results.append(c_k_list)\n\n    # Test 4: Horizontal-Vertical Decoupling\n    # Integrand is v_top_2 . v_left_1\n    integrand_t4 = lambda x, y: np.dot(v_top_k(x, y, 2), v_left_k(x, y, 1))\n    cross_coupling = integrate_2d(integrand_t4, nx, ny)\n    results.append(cross_coupling)\n\n    # Test 5: Quadrature Insufficiency Edge Case\n    # M_33 for top edge with insufficient quadrature\n    m33_accurate = m_kk_list[3]\n    nx_ins, ny_ins = 1, 1\n    integrand_t5 = lambda x, y: np.dot(v_top_k(x, y, 3), v_top_k(x, y, 3))\n    m33_insufficient = integrate_2d(integrand_t5, nx_ins, ny_ins)\n    abs_diff = abs(m33_accurate - m33_insufficient)\n    results.append(abs_diff)\n    \n    # --- Part 4: Final Output Formatting ---\n\n    # Flatten the list of lists for printing\n    final_output_str = f\"[{results[0]},[{','.join(f'{v:.15f}' for v in results[1])}],[{','.join(f'{v:.15f}' for v in results[2])}],{results[3]:.15f},{results[4]:.15f}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}