{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of the *hp*-FEM is the promise of exponential convergence rates for problems with smooth, analytic solutions. While standard *h*-refinement offers predictable algebraic convergence, *p*-refinement can achieve far superior accuracy by increasing the local polynomial degree. This practice  provides a direct, analytical confirmation of this phenomenon by guiding you through the core mathematical machinery. By applying classical approximation theory and the concept of the Bernstein ellipse to a simple analytic wave function, you will derive the explicit constants that govern this exponential error decay, solidifying the theoretical justification for using high-order methods in electromagnetics.",
            "id": "3314615",
            "problem": "Consider a one-dimensional proxy of a time-harmonic electromagnetic field in a homogeneous, lossless medium, where the exact complex electric field component is given by the analytic function $u(x) = \\exp(\\mathrm{i}\\kappa x)$ on the closed interval $\\Omega = [-1,1]$, with real wavenumber $\\kappa  0$. The field is to be approximated by a single-element *hp*-finite element method (Finite Element Method (FEM)) on $\\Omega$ using a trial space of polynomials of degree at most $p$ defined on the reference element, i.e., a fixed $h$ and variable *p* refinement strategy (a limiting case of *hp*-refinement). Assume the error is measured in the uniform norm $\\|\\cdot\\|_{L^{\\infty}(\\Omega)}$.\n\nUse as foundational facts the analyticity of $u$ together with standard approximation theory of analytic functions on the interval $[-1,1]$ via polynomial spaces and the Bernstein ellipse technique. In particular, recall that for a function analytic in and on a Bernstein ellipse $\\mathcal{E}_{\\rho}$ with parameter $\\rho  1$ (the image of the circle $|w|=\\rho$ under the Joukowski map $z=\\frac{1}{2}(w+w^{-1})$), with maximum modulus $M_{\\rho} = \\max_{z\\in \\mathcal{E}_{\\rho}}|u(z)|$, the best degree-$p$ polynomial approximation error on $[-1,1]$ admits an upper bound of the form $\\frac{2M_{\\rho}}{\\rho - 1}\\rho^{-p}$ in the $L^{\\infty}$ norm.\n\nFor the specified analytic field $u(x) = \\exp(\\mathrm{i}\\kappa x)$ and the single-element discretization (which is a trivial mesh grading scheme with a single element of length $2$), set the Bernstein ellipse parameter to the explicit value $\\rho = 2$. Treat the discrete solution $u_{hp}$ as the best approximation in the polynomial trial space (which provides a rigorous upper bound for any Galerkin solution due to quasi-optimality in norms equivalent to $L^{\\infty}$ under analyticity).\n\nCompute explicit constants $C$ and $\\alpha$ such that the following bound holds for all polynomial degrees $p \\in \\mathbb{N}$:\n$$\n\\|u - u_{hp}\\|_{L^{\\infty}(\\Omega)} \\le C \\exp(-\\alpha p).\n$$\nExpress the final answer as a closed-form analytic expression in terms of $\\kappa$ only. No numerical rounding is required and no physical units are to be reported. The angle unit is radians.",
            "solution": "The objective is to determine the constants $C$ and $\\alpha$ in the error bound $\\|u - u_{hp}\\|_{L^{\\infty}(\\Omega)} \\le C \\exp(-\\alpha p)$. The problem states that the discrete solution $u_{hp}$ can be treated as the best polynomial approximation of degree $p$, denoted $u_p$. We use the theoretical bound for the error of the best approximation:\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le \\frac{2M_{\\rho}}{\\rho - 1}\\rho^{-p} $$\nGiven $\\rho = 2$, this simplifies to:\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le 2 M_2 2^{-p} $$\nThe next step is to calculate $M_2$, the maximum modulus of the analytic continuation of $u(x) = \\exp(\\mathrm{i}\\kappa x)$ on the Bernstein ellipse $\\mathcal{E}_2$. The analytic continuation into the complex plane is $u(z) = \\exp(\\mathrm{i}\\kappa z)$.\n\nThe modulus of $u(z)$ is $|u(z)| = |\\exp(\\mathrm{i}\\kappa(x + \\mathrm{i}y))| = \\exp(-\\kappa y)$. Since $\\kappa > 0$, this maximum value occurs where the imaginary part $y$ is at its minimum on the ellipse $\\mathcal{E}_2$.\n\nA Bernstein ellipse $\\mathcal{E}_{\\rho}$ is the image of the circle $|w| = \\rho$ under the Joukowski map $z = \\frac{1}{2}(w + w^{-1})$. For $w = \\rho \\exp(\\mathrm{i}\\theta)$, the imaginary part of $z$ is $y(\\theta) = \\frac{1}{2}(\\rho - \\frac{1}{\\rho})\\sin\\theta$. Its minimum value is $y_{\\min} = -\\frac{1}{2}(\\rho - \\frac{1}{\\rho})$.\n          \nThe maximum modulus $M_{\\rho}$ is then:\n$$ M_{\\rho} = \\exp(-\\kappa y_{\\min}) = \\exp\\left(\\kappa \\frac{1}{2}\\left(\\rho - \\frac{1}{\\rho}\\right)\\right) $$\nFor $\\rho = 2$, we have $y_{\\min} = -\\frac{1}{2}(2 - \\frac{1}{2}) = -\\frac{3}{4}$. The maximum modulus is:\n$$ M_2 = \\exp\\left(-\\kappa \\left(-\\frac{3}{4}\\right)\\right) = \\exp\\left(\\frac{3\\kappa}{4}\\right) $$\nSubstituting this into the error bound:\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) 2^{-p} $$\nTo match the target form $C \\exp(-\\alpha p)$, we rewrite $2^{-p}$ as $\\exp(-p \\ln 2)$. The bound becomes:\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) \\exp(-(\\ln 2)p) $$\nBy comparison, we identify the constants:\n$$ C = 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) $$\n$$ \\alpha = \\ln 2 $$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 \\exp\\left(\\frac{3\\kappa}{4}\\right)  \\ln(2)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "When simulating wave propagation, one of the most critical challenges is controlling numerical dispersion, a phenomenon where the computed wave speed varies with frequency and mesh size, leading to phase errors that can accumulate and pollute the solution. Increasing the polynomial degree, $p$, is a highly effective way to combat this. This exercise  moves from abstract error bounds to a concrete and practical metric by focusing on the phase accuracy of the finite element solution. Through a dispersion analysis, you will quantify how the phase error depends on the polynomial degree and the normalized wavenumber $kh$, enabling you to determine the minimum polynomial order required to achieve a specific accuracy target for a given mesh resolution.",
            "id": "3314679",
            "problem": "Consider a one-dimensional time-harmonic electromagnetic field propagating in a homogeneous, lossless medium, so that the relevant field component satisfies the scalar Helmholtz equation $u''(x) + k^2 u(x) = 0$ with real wavenumber $k0$. Discretize this equation on a uniform mesh of spacing $h0$ using the continuous Galerkin finite element method (FEM) of polynomial degree $p \\in \\mathbb{N}$ on each element. For a periodic Bloch wave ansatz $u_j = \\exp(i j t)$ at grid nodes indexed by $j \\in \\mathbb{Z}$, the discretization admits a discrete Bloch wavenumber $k_h = t/h$, which in general differs from the exact $k$. Define the phase error as the relative wavenumber error $\\eta_p(kh) := |k_h - k|/k$.\n\nStarting from the standard variational formulation and the associated assembled nodal equations on a uniform mesh, perform a dispersion (Bloch/Fourier) analysis to determine the leading-order small-$kh$ dependence of $\\eta_p(kh)$. Use first principles to establish the power of $kh$ in the leading term and identify an explicit, $p$-independent constant $C0$ that provides a conservative upper bound for the family of continuous Galerkin methods across all $p \\ge 1$ on a fixed small-$kh$ interval. Then, using that bound, determine the minimal polynomial degree $p$ that guarantees the target phase error threshold\n$\\eta_p(kh) \\le \\varepsilon$\nfor the specific values $kh = 0.5$ and $\\varepsilon = 1.0 \\times 10^{-3}$. Report the minimal integer $p$ that satisfies this guarantee. The final answer must be a single integer with no units.",
            "solution": "The problem requires a dispersion analysis of the continuous Galerkin FEM for the 1D Helmholtz equation, $u'' + k^2 u = 0$, to determine the phase error and find the minimum polynomial degree $p$ to meet an accuracy target.\n\n**1. Variational Formulation and Dispersion Relation**\nThe weak form of the Helmholtz equation, discretized with continuous, piecewise polynomials of degree $p$ on a uniform mesh of size $h$, leads to a stencil equation for the nodal values. For a Bloch wave ansatz $U_j=\\exp(i j k_h h)$, the numerical dispersion relation for linear elements ($p=1$) can be derived from the element stiffness and mass matrices. This yields:\n$$ \\cos(k_h h) = \\frac{1 - (kh)^2/3}{1 + (kh)^2/6} $$\n\n**2. Asymptotic Error Analysis**\nTo find the phase error for small $kh$, we perform a Taylor expansion of both sides of the dispersion relation. Let $t = k_h h$.\n$$ 1 - \\frac{t^2}{2} + \\frac{t^4}{24} - \\dots = \\left(1 - \\frac{(kh)^2}{3}\\right) \\left(1 - \\frac{(kh)^2}{6} + \\dots\\right) = 1 - \\frac{(kh)^2}{2} + \\frac{(kh)^4}{12} - \\dots $$\nSolving for $t = k_h h$ in terms of $kh$ gives the leading-order relationship:\n$$ k_h h \\approx kh \\left(1 - \\frac{(kh)^2}{24}\\right) $$\nThe relative phase error for $p=1$ is therefore:\n$$ \\eta_1(kh) = \\frac{|k_h - k|}{k} \\approx \\frac{(kh)^2}{24} $$\nFor a general polynomial degree $p$, a similar analysis shows that the error scales as $\\eta_p(kh) \\approx |C_p|(kh)^{2p}$. The constants $|C_p|$ decrease rapidly with $p$. To establish a conservative bound valid for all $p \\ge 1$, we use the coefficient for the worst case ($p=1$), giving the inequality:\n$$ \\eta_p(kh) \\le \\frac{1}{24}(kh)^{2p} $$\n\n**3. Minimal Polynomial Degree Calculation**\nWe need to find the minimal integer $p \\ge 1$ that satisfies $\\eta_p(kh) \\le \\varepsilon$ for the given values $kh = 0.5$ and $\\varepsilon = 1.0 \\times 10^{-3}$. Using the conservative bound:\n$$ \\frac{1}{24}(0.5)^{2p} \\le 1.0 \\times 10^{-3} $$\n$$ (0.25)^p \\le 24 \\times 10^{-3} = 0.024 $$\nTaking the natural logarithm of both sides and solving for $p$:\n$$ p \\ln(0.25) \\le \\ln(0.024) $$\nSince $\\ln(0.25)$ is negative, we reverse the inequality:\n$$ p \\ge \\frac{\\ln(0.024)}{\\ln(0.25)} \\approx \\frac{-3.73}{-1.386} \\approx 2.69 $$\nThe smallest integer $p$ that satisfies this condition is $p=3$. A check confirms that $p=2$ fails the tolerance while $p=3$ passes.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "The ultimate goal of *hp*-refinement is to create adaptive algorithms that automatically select the most efficient strategy—mesh refinement (*h*) or polynomial enrichment (*p*)—for each part of the domain. The key to such intelligence lies in a posteriori indicators that can diagnose the local character of the numerical error. This hands-on coding practice  delves into a sophisticated, physics-informed approach based on the Helmholtz decomposition. You will implement an algorithm that numerically separates a synthetic error field into its curl-free (gradient) and divergence-free (solenoidal) parts, using this physical insight to decide whether the error is best resolved by subdividing the mesh or increasing the approximation order.",
            "id": "3314622",
            "problem": "Design and implement a program that constructs an *hp*-refinement indicator for a two-dimensional Finite Element Method (FEM) problem in computational electromagnetics by performing a discrete Helmholtz decomposition of a synthetic element-wise error field into curl-free (gradient) and divergence-free (rotated gradient) components. Starting from fundamental electromagnetic principles, your design must derive what the indicator is, why its decision rule is scientifically sound, and how to implement it algorithmically using polynomial bases and least squares.\n\nThe base is Maxwell's equations for time-harmonic fields, which imply the curl-curl operator acting on an electric field and the importance of the function spaces $\\mathbf{H}(\\mathrm{curl})$ and $\\mathbf{H}(\\mathrm{div})$. In two spatial dimensions, any sufficiently smooth vector field $\\mathbf{v}$ can be decomposed as $$\\mathbf{v} = \\nabla \\phi + \\mathbf{R}\\nabla \\psi,$$ where $\\phi$ and $\\psi$ are scalar potentials and $\\mathbf{R}$ is the $90^\\circ$ rotation operator defined by $$\\mathbf{R} \\nabla \\psi = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix} \\begin{bmatrix} \\partial_x \\psi \\\\ \\partial_y \\psi \\end{bmatrix} = \\begin{bmatrix} -\\partial_y \\psi \\\\ \\partial_x \\psi \\end{bmatrix}.$$ The curl-free component $\\nabla \\phi$ corresponds to gradient-dominated error modes, while the divergence-free component $\\mathbf{R}\\nabla \\psi$ corresponds to solenoidal error modes. In the presence of material discontinuities across elements, oscillatory or singular behaviors are more likely, and mesh-based (*h*) refinement is typically more effective; for smooth error modes, increasing local polynomial degree (*p*) is beneficial.\n\nYou must implement the following discrete strategy:\n1. Represent a synthetic error field $\\mathbf{e}(\\mathbf{x})$ on each element as a combination of gradient and rotated gradient of scalar polynomial potentials with total degree at most $p$, sampled at interior points. The error field is defined for each test case by polynomial coefficient vectors for $\\phi$ and $\\psi$ applied to a monomial basis $\\{x^i y^j \\mid i+j \\le p\\}$.\n2. Build a least-squares system for the discrete Helmholtz decomposition by projecting the sampled error vectors onto the span of $\\{\\nabla m_{ij}\\}$ and $\\{\\mathbf{R}\\nabla m_{ij}\\}$, where $m_{ij}(x,y) = x^i y^j$.\n3. Solve for coefficients of $\\phi$ and $\\psi$ in the polynomial basis using linear least squares. Reconstruct $\\nabla \\phi$ and $\\mathbf{R}\\nabla \\psi$ at the sample points.\n4. Compute approximate element-wise energies $$E_{\\mathrm{grad}} = \\int_{K} \\|\\nabla \\phi\\|^2 \\, dA \\quad \\text{and} \\quad E_{\\mathrm{sol}} = \\int_{K} \\|\\mathbf{R}\\nabla \\psi\\|^2 \\, dA,$$ using quadrature by averaging $|\\cdot|^2$ samples and scaling by the element area.\n5. Decide refinement type per element by the rule:\n   - If the element touches a material discontinuity (at least one neighbor has a different material parameter), select *h*-refinement regardless of energy ratio if the total energy is above a small tolerance.\n   - Otherwise, if the gradient component is dominant, i.e., $$\\frac{E_{\\mathrm{grad}}}{E_{\\mathrm{grad}} + E_{\\mathrm{sol}} + \\varepsilon} \\ge \\tau,$$ choose *p*-refinement; else choose *h*-refinement.\n   - If $E_{\\mathrm{grad}} + E_{\\mathrm{sol}}  \\text{tol}$, choose *p*-refinement (interpreting negligible error as favoring increased approximation order rather than mesh subdivision).\n6. Encode decisions as integers: output $0$ for *p*-refinement and $1$ for *h*-refinement.\n\nMesh and sampling specification:\n- Use the unit square $[0,1]\\times[0,1]$ partitioned into four rectangles by halving each coordinate, producing four elements $$K_0 = [0, \\tfrac{1}{2}] \\times [0, \\tfrac{1}{2}], \\quad K_1 = [\\tfrac{1}{2}, 1] \\times [0, \\tfrac{1}{2}], \\quad K_2 = [0, \\tfrac{1}{2}] \\times [\\tfrac{1}{2}, 1], \\quad K_3 = [\\tfrac{1}{2}, 1] \\times [\\tfrac{1}{2}, 1],$$ in the index order $[K_0,K_1,K_2,K_3]$. Each element has area $\\tfrac{1}{4}$. For sampling, use $N\\times N$ interior points per element at uniform spacing; $N$ will be specified per test case.\n\nMaterial discontinuity detection:\n- For the fixed $2\\times 2$ mesh, the adjacency is given by neighbor pairs: $K_0$ neighbors $K_1$ and $K_2$, $K_1$ neighbors $K_0$ and $K_3$, $K_2$ neighbors $K_3$ and $K_0$, $K_3$ neighbors $K_2$ and $K_1$. An element touches a discontinuity if any neighbor has a different material identifier.\n\nImplement the above and produce refinement decisions for the following test suite. In all cases, use polynomial degree $p=2$, monomials ordered as $[1, x, y, x^2, xy, y^2]$, and define the synthetic error as $$\\mathbf{e}(x,y) = \\sum_{k} c^{\\phi}_k \\nabla m_k(x,y) + \\sum_{k} c^{\\psi}_k \\mathbf{R}\\nabla m_k(x,y),$$ with coefficients given below.\n\nTest suite:\n- Case A (gradient-dominated, uniform material):\n  - $\\mathbf{c}^{\\phi} = [0.0, 1.2, 0.8, 0.5, 0.3, 0.2]$,\n  - $\\mathbf{c}^{\\psi} = [0.0, 0.03, -0.015, 0.0, 0.0, 0.0]$,\n  - materials $[1, 1, 1, 1]$,\n  - $N = 5$,\n  - threshold $\\tau = 0.6$,\n  - tolerance $\\text{tol} = 10^{-10}$.\n- Case B (divergence-free dominated, uniform material):\n  - $\\mathbf{c}^{\\phi} = [0.0, 0.02, -0.02, 0.01, 0.0, 0.0]$,\n  - $\\mathbf{c}^{\\psi} = [0.0, 1.5, 1.0, 0.7, 0.4, 0.2]$,\n  - materials $[1, 1, 1, 1]$,\n  - $N = 5$,\n  - threshold $\\tau = 0.6$,\n  - tolerance $\\text{tol} = 10^{-10}$.\n- Case C (gradient-dominated, with a material jump at $K_3$):\n  - $\\mathbf{c}^{\\phi} = [0.0, 1.2, 0.8, 0.5, 0.3, 0.2]$,\n  - $\\mathbf{c}^{\\psi} = [0.0, 0.03, -0.015, 0.0, 0.0, 0.0]$,\n  - materials $[1, 1, 1, 5]$,\n  - $N = 5$,\n  - threshold $\\tau = 0.6$,\n  - tolerance $\\text{tol} = 10^{-10}$.\n- Case D (near-zero error):\n  - $\\mathbf{c}^{\\phi} = 10^{-8}\\cdot [0.0, 1.0, 0.0, 0.0, 0.0, 0.0]$,\n  - $\\mathbf{c}^{\\psi} = 10^{-8}\\cdot [0.0, 0.0, 1.0, 0.0, 0.0, 0.0]$,\n  - materials $[1, 1, 1, 1]$,\n  - $N = 5$,\n  - threshold $\\tau = 0.6$,\n  - tolerance $\\text{tol} = 10^{-10}$.\n\nFinal output specification:\n- For each test case, compute the list of four decisions, one per element in index order $[K_0,K_1,K_2,K_3]$, where $0$ means *p*-refinement and $1$ means *h*-refinement.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the decisions for all test cases in order, and insert the integer $-1$ as a separator between consecutive test cases. For example, an output with two test cases would look like $[d_{0}, d_{1}, d_{2}, d_{3}, -1, d'_{0}, d'_{1}, d'_{2}, d'_{3}]$.",
            "solution": "The problem asks for the design and implementation of an *hp*-refinement indicator for a two-dimensional Finite Element Method (FEM) simulation in computational electromagnetics. The indicator is based on a discrete Helmholtz decomposition of a synthetic, element-wise error field.\n\n### Scientific Principles and Justification\n\nThe foundation of computational electromagnetics lies in Maxwell's equations. For time-harmonic fields, varying as $e^{j\\omega t}$, these equations can be combined to form the vector wave equation, often expressed as a \"curl-curl\" equation for the electric field $\\mathbf{E}$:\n$$ \\nabla \\times \\left( \\mu_r^{-1} \\nabla \\times \\mathbf{E} \\right) - k_0^2 \\varepsilon_r \\mathbf{E} = -j\\omega\\mu_0\\mathbf{J} $$\nwhere $\\mu_r$ and $\\varepsilon_r$ are the relative permeability and permittivity, $k_0$ is the free-space wavenumber, and $\\mathbf{J}$ is the source current density. When solving this equation with FEM, the error $\\mathbf{e} = \\mathbf{E} - \\mathbf{E}_h$ (where $\\mathbf{E}_h$ is the finite element approximation) needs to be controlled. An effective adaptive mesh refinement strategy must decide whether to refine the mesh locally (*h*-refinement) or increase the polynomial order of the basis functions (*p*-refinement).\n\nThe choice between *h*- and *p*-refinement is guided by the local character of the error. The Helmholtz decomposition theorem provides a rigorous way to characterize a vector field. In two dimensions, any sufficiently smooth vector field, such as the error field $\\mathbf{e}$, can be uniquely decomposed into a curl-free component and a divergence-free component:\n$$ \\mathbf{e} = \\nabla\\phi + \\mathbf{R}\\nabla\\psi $$\nHere, $\\phi$ and $\\psi$ are scalar potentials, and $\\mathbf{R}$ is the $90^\\circ$ rotation operator matrix $\\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$.\n\n-   The **curl-free (irrotational) component** is the gradient of a scalar potential, $\\nabla\\phi$. This component satisfies $\\nabla \\times (\\nabla\\phi) = \\mathbf{0}$. Smooth, slowly-varying errors are typically dominated by this component. Such errors are most efficiently approximated by increasing the polynomial order of the basis functions, which corresponds to ***p*-refinement**.\n\n-   The **divergence-free (solenoidal) component** is the rotated gradient of a scalar potential, $\\mathbf{R}\\nabla\\psi$. This component satisfies $\\nabla \\cdot (\\mathbf{R}\\nabla\\psi) = 0$. This part of the error often captures oscillatory behavior or singularities, which can arise from wave phenomena or sharp corners in the geometry. These highly localized or rapidly changing features are better resolved by subdividing the mesh elements, which corresponds to ***h*-refinement**.\n\nFurthermore, boundaries between different materials (discontinuities in $\\varepsilon_r$ or $\\mu_r$) often introduce singularities in the electromagnetic fields. The error near such discontinuities tends to be non-smooth and is best reduced by *h*-refinement.\n\nThe indicator's decision rule is thus scientifically sound:\n1.  Near material discontinuities, the error is likely singular, so *h*-refinement is preferred if the error is significant.\n2.  Where the error is smooth and dominated by its gradient part ($\\nabla\\phi$), *p*-refinement is more efficient.\n3.  Where the error is oscillatory or dominated by its solenoidal part ($\\mathbf{R}\\nabla\\psi$), *h*-refinement is more effective.\n4.  If the error is negligible, further refinement is unnecessary, but for the purpose of this problem, we choose *p*-refinement, as this increases the approximation capacity without changing the mesh topology.\n\n### Algorithmic Design and Implementation\n\nThe problem specifies a discrete, numerical implementation of this principle on a $2\\times2$ mesh of the unit square. For each of the four elements $K_i$, we perform the following steps:\n\n**1. Element Setup and Sampling:**\nThe domain $[0,1]\\times[0,1]$ is divided into four elements: $K_0=[0,0.5]\\times[0,0.5], K_1=[0.5,1]\\times[0,0.5], K_2=[0,0.5]\\times[0.5,1], K_3=[0.5,1]\\times[0.5,1]$. Each element has an area $A_K=0.25$. Inside each element, we generate a grid of $N \\times N$ uniformly spaced interior sample points $\\{\\mathbf{x}_j\\}_{j=1}^{N^2}$.\n\n**2. Synthetic Error Field Generation:**\nA known, synthetic error field $\\mathbf{e}(\\mathbf{x})$ is provided for each test case. This field is constructed using specified coefficients $\\mathbf{c}^{\\phi}$ and $\\mathbf{c}^{\\psi}$ for a polynomial basis of degree $p=2$. The monomial basis is ordered as $\\{m_k\\}_{k=0}^5 = \\{1, x, y, x^2, xy, y^2\\}$. The error at any point $\\mathbf{x}=(x,y)$ is:\n$$ \\mathbf{e}(\\mathbf{x}) = \\sum_{k=0}^{5} c^{\\phi}_k \\nabla m_k(x,y) + \\sum_{k=0}^{5} c^{\\psi}_k \\mathbf{R}\\nabla m_k(x,y) $$\nThis synthetic error is evaluated at each of the $N^2$ sample points to generate the observation data.\n\n**3. Discrete Helmholtz Decomposition via Least Squares:**\nThe core of the algorithm is to decompose the sampled error field back into its constituent parts. We seek approximation coefficients $\\mathbf{a}^{\\phi}$ and $\\mathbf{a}^{\\psi}$ for the potentials $\\phi_{\\text{approx}} = \\sum_k a^{\\phi}_k m_k$ and $\\psi_{\\text{approx}} = \\sum_k a^{\\psi}_k m_k$. This is formulated as a linear least-squares problem, $\\mathbf{A}\\mathbf{z} \\approx \\mathbf{b}$, where:\n-   $\\mathbf{b}$ is a vector of size $2N^2$ containing the stacked $x$ and $y$ components of the error field $\\mathbf{e}$ at all $N^2$ sample points.\n-   $\\mathbf{z}$ is a vector of size $12$ containing the unknown coefficients to be found: $\\mathbf{z} = [a^{\\phi}_0, \\dots, a^{\\phi}_5, a^{\\psi}_0, \\dots, a^{\\psi}_5]^T$.\n-   $\\mathbf{A}$ is the regression matrix of size $(2N^2 \\times 12)$. Each column corresponds to a basis vector field evaluated at the sample points. For $k \\in \\{0, \\dots, 5\\}$, column $k$ is formed by stacking the vectors $\\nabla m_k(\\mathbf{x}_j)$, and column $k+6$ is formed by stacking $\\mathbf{R}\\nabla m_k(\\mathbf{x}_j)$.\n\nThe system is solved for $\\mathbf{z}$ using `numpy.linalg.lstsq`. The basis function $m_0=1$ has a zero gradient, leading to a rank-deficient matrix $\\mathbf{A}$. This is expected, as the potentials $\\phi$ and $\\psi$ are only determined up to an additive constant. The least-squares solver finds a minimum-norm solution, which suffices for reconstructing the unique gradient and rotated-gradient fields.\n\n**4. Energy Calculation:**\nUsing the computed coefficients $\\mathbf{a}^{\\phi}$ and $\\mathbf{a}^{\\psi}$, we reconstruct the discrete gradient and solenoidal fields at the sample points:\n$$ \\mathbf{v}_{\\mathrm{grad}}(\\mathbf{x}_j) = \\sum_{k=0}^{5} a^{\\phi}_k \\nabla m_k(\\mathbf{x}_j), \\quad \\mathbf{v}_{\\mathrm{sol}}(\\mathbf{x}_j) = \\sum_{k=0}^{5} a^{\\psi}_k \\mathbf{R}\\nabla m_k(\\mathbf{x}_j) $$\nThe energies are then approximated using a simple quadrature rule, averaging the squared norms of these vectors over the sample points and scaling by the element area $A_K$:\n$$ E_{\\mathrm{grad}} = A_K \\cdot \\frac{1}{N^2} \\sum_{j=1}^{N^2} \\| \\mathbf{v}_{\\mathrm{grad}}(\\mathbf{x}_j) \\|^2, \\quad E_{\\mathrm{sol}} = A_K \\cdot \\frac{1}{N^2} \\sum_{j=1}^{N^2} \\| \\mathbf{v}_{\\mathrm{sol}}(\\mathbf{x}_j) \\|^2 $$\n\n**5. Refinement Decision:**\nThe decision logic is applied sequentially for each element:\n1.  Calculate total energy $E_{\\text{total}} = E_{\\mathrm{grad}} + E_{\\mathrm{sol}}$.\n2.  If $E_{\\text{total}}  \\text{tol}$ (where $\\text{tol}=10^{-10}$), the error is negligible. Choose ***p*-refinement (0)**.\n3.  Otherwise, check for material discontinuity. An element has a discontinuity if any of its adjacent neighbors has a different material identifier. If a discontinuity exists, choose ***h*-refinement (1)**.\n4.  Otherwise (i.e., significant error and no discontinuity), compute the ratio $\\rho = \\frac{E_{\\mathrm{grad}}}{E_{\\mathrm{grad}} + E_{\\mathrm{sol}}}$. The regularization term $\\varepsilon$ from the problem description is unnecessary as we have already established $E_{\\text{total}} \\ge \\text{tol}  0$.\n5.  If $\\rho \\ge \\tau$ (where $\\tau=0.6$), the error is gradient-dominated. Choose ***p*-refinement (0)**.\n6.  Otherwise, the error is solenoidal-dominated. Choose ***h*-refinement (1)**.\n\nThe final output is a list of these integer decisions ($0$ or $1$) for all elements of all test cases, concatenated and separated by $-1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs an hp-refinement indicator based on a discrete Helmholtz decomposition\n    of a synthetic element-wise error field in 2D.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # Case A: Gradient-dominated, uniform material\n        {\n            \"c_phi\": np.array([0.0, 1.2, 0.8, 0.5, 0.3, 0.2]),\n            \"c_psi\": np.array([0.0, 0.03, -0.015, 0.0, 0.0, 0.0]),\n            \"materials\": [1, 1, 1, 1],\n            \"N\": 5, \"tau\": 0.6, \"tol\": 1e-10,\n        },\n        # Case B: Divergence-free dominated, uniform material\n        {\n            \"c_phi\": np.array([0.0, 0.02, -0.02, 0.01, 0.0, 0.0]),\n            \"c_psi\": np.array([0.0, 1.5, 1.0, 0.7, 0.4, 0.2]),\n            \"materials\": [1, 1, 1, 1],\n            \"N\": 5, \"tau\": 0.6, \"tol\": 1e-10,\n        },\n        # Case C: Gradient-dominated, with a material jump\n        {\n            \"c_phi\": np.array([0.0, 1.2, 0.8, 0.5, 0.3, 0.2]),\n            \"c_psi\": np.array([0.0, 0.03, -0.015, 0.0, 0.0, 0.0]),\n            \"materials\": [1, 1, 1, 5],\n            \"N\": 5, \"tau\": 0.6, \"tol\": 1e-10,\n        },\n        # Case D: Near-zero error\n        {\n            \"c_phi\": 1e-8 * np.array([0.0, 1.0, 0.0, 0.0, 0.0, 0.0]),\n            \"c_psi\": 1e-8 * np.array([0.0, 0.0, 1.0, 0.0, 0.0, 0.0]),\n            \"materials\": [1, 1, 1, 1],\n            \"N\": 5, \"tau\": 0.6, \"tol\": 1e-10,\n        },\n    ]\n\n    # Fixed mesh geometry and topology\n    element_extents = [\n        (0.0, 0.5, 0.0, 0.5),  # K0\n        (0.5, 1.0, 0.0, 0.5),  # K1\n        (0.0, 0.5, 0.5, 1.0),  # K2\n        (0.5, 1.0, 0.5, 1.0),  # K3\n    ]\n    \n    # Adjacency list for material discontinuity check\n    neighbors = {\n        0: [1, 2],\n        1: [0, 3],\n        2: [0, 3],\n        3: [1, 2],\n    }\n\n    # Polynomial basis definition (p=2) corresponds to 6 monomials\n    # m_k(x,y) = x^i y^j for i+j = 2, ordered as 1, x, y, x^2, xy, y^2.\n    num_basis_funcs = 6\n    \n    # Rotation matrix R\n    R = np.array([[0, -1], [1, 0]])\n\n    def get_grad_monomials(x, y):\n        # Gradients of the monomial basis {1, x, y, x^2, xy, y^2}\n        return [\n            np.array([0.0, 0.0]),     # grad(1)\n            np.array([1.0, 0.0]),     # grad(x)\n            np.array([0.0, 1.0]),     # grad(y)\n            np.array([2.0 * x, 0.0]), # grad(x^2)\n            np.array([y, x]),         # grad(xy)\n            np.array([0.0, 2.0 * y]), # grad(y^2)\n        ]\n\n    final_results = []\n    num_cases = len(test_cases)\n    for i, case in enumerate(test_cases):\n        c_phi = case[\"c_phi\"]\n        c_psi = case[\"c_psi\"]\n        materials = case[\"materials\"]\n        N = case[\"N\"]\n        tau = case[\"tau\"]\n        tol = case[\"tol\"]\n\n        case_decisions = []\n        for elem_idx in range(4):\n            xmin, xmax, ymin, ymax = element_extents[elem_idx]\n            area = (xmax - xmin) * (ymax - ymin)\n\n            # 1. Generate sample points\n            x_coords = np.linspace(xmin, xmax, N + 2)[1:-1]\n            y_coords = np.linspace(ymin, ymax, N + 2)[1:-1]\n            sample_points = np.array(np.meshgrid(x_coords, y_coords)).T.reshape(-1, 2)\n            num_samples = len(sample_points)\n\n            # 2. Build least-squares system A*z = b\n            A = np.zeros((num_samples * 2, num_basis_funcs * 2))\n            b = np.zeros(num_samples * 2)\n\n            for j, p in enumerate(sample_points):\n                x, y = p\n                grads_mk = get_grad_monomials(x, y)\n                \n                error_vec = np.zeros(2)\n                for k in range(num_basis_funcs):\n                    grad_mk = grads_mk[k]\n                    rot_grad_mk = R @ grad_mk\n                    \n                    A[2 * j : 2 * j + 2, k] = grad_mk\n                    A[2 * j : 2 * j + 2, k + num_basis_funcs] = rot_grad_mk\n                    \n                    error_vec += c_phi[k] * grad_mk + c_psi[k] * rot_grad_mk\n\n                b[2 * j : 2 * j + 2] = error_vec\n\n            # 3. Solve for coefficients a_phi and a_psi\n            coeffs, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n            a_phi = coeffs[:num_basis_funcs]\n            a_psi = coeffs[num_basis_funcs:]\n\n            # 4. Compute Energies\n            sum_sq_norms_grad = 0.0\n            sum_sq_norms_sol = 0.0\n            for p in sample_points:\n                x, y = p\n                grads_mk = get_grad_monomials(x, y)\n                \n                v_grad = np.zeros(2)\n                v_sol = np.zeros(2)\n                for k in range(num_basis_funcs):\n                    grad_mk = grads_mk[k]\n                    rot_grad_mk = R @ grad_mk\n                    v_grad += a_phi[k] * grad_mk\n                    v_sol += a_psi[k] * rot_grad_mk\n                \n                sum_sq_norms_grad += np.dot(v_grad, v_grad)\n                sum_sq_norms_sol += np.dot(v_sol, v_sol)\n            \n            E_grad = area * (sum_sq_norms_grad / num_samples)\n            E_sol = area * (sum_sq_norms_sol / num_samples)\n\n            # 5. Apply decision logic\n            E_total = E_grad + E_sol\n            \n            decision = -1 # Should always be overwritten\n            if E_total  tol:\n                decision = 0  # p-refinement\n            else:\n                has_discontinuity = any(materials[neighbor_idx] != materials[elem_idx] \n                                        for neighbor_idx in neighbors[elem_idx])\n                \n                if has_discontinuity:\n                    decision = 1 # h-refinement\n                else:\n                    # Denominator is safe because E_total = tol  0\n                    ratio = E_grad / E_total\n                    if ratio = tau:\n                        decision = 0 # p-refinement\n                    else:\n                        decision = 1 # h-refinement\n            \n            case_decisions.append(decision)\n        \n        final_results.extend(case_decisions)\n        if i  num_cases - 1:\n            final_results.append(-1)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}