{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of any wave simulation hinges on its ability to correctly represent wave propagation. This exercise delves into the theoretical heart of the Adaptive Integral Method's far-field solver to quantify its numerical dispersion and resulting phase error. By analyzing a simplified model, you will derive how choices like grid spacing and oversampling directly impact the physical fidelity of the simulation, a foundational skill for developing robust numerical methods.",
            "id": "3288282",
            "problem": "Consider the scalar time-harmonic Helmholtz equation in one spatial dimension for a wavenumber $k_{0}  0$,\n$$\n\\frac{d^{2}u}{dx^{2}} + k_{0}^{2} u = f,\n$$\nwith the radiating solution selected by the usual limiting absorption principle. In the Adaptive Integral Method (AIM), the long-range convolution with the free-space Green function is accelerated by embedding sources on a uniform grid of spacing $h$ and performing the convolution in the spectral domain using the Fast Fourier Transform. In this gridded representation, the continuous Laplacian symbol $k^{2}$ is replaced by the discrete Laplacian symbol\n$$\nD_{h}(k) = \\frac{4}{h^{2}} \\sin^{2}\\!\\left(\\frac{k h}{2}\\right).\n$$\nTo suppress wrap-around and control aliasing, two numerical modifications are used simultaneously:\n- Grid oversampling by a factor $s \\geq 1$, which effectively replaces $h$ by $h/s$ in the spectral stencil for the long-range operator, and\n- Application of a spectral window to the Green function, which in the long-range operator can be modeled as multiplying the continuous spectral factor by a smooth, even, nonnegative window $W(k)$ with $W(0)=1$ and $W(k_{0}) \\approx 1$.\n\nIn this simplified one-dimensional model, assume that the propagating discrete wave supported by the AIM long-range operator satisfies the homogeneous dispersion relation obtained by equating the discrete Laplacian to the windowed continuous wavenumber factor:\n$$\n\\frac{4 s^{2}}{h^{2}} \\sin^{2}\\!\\left( \\frac{k_{\\mathrm{num}} h}{2 s} \\right) \\;=\\; k_{0}^{2}\\, W(k_{0}),\n$$\nwhere $k_{\\mathrm{num}}$ is the numerical wavenumber predicted by the AIM long-range operator with oversampling factor $s$ and spectral window $W(\\cdot)$. Define the dispersion error (and hence the far-field phase error per unit propagation distance) by\n$$\n\\delta k(s, h, k_{0}, W) \\;=\\; k_{\\mathrm{num}} - k_{0}.\n$$\n\nStarting only from the Fourier representation of the Helmholtz operator, the discrete Laplacian symbol $D_{h}(k)$, and the above modeling of oversampling and spectral windowing, derive a closed-form asymptotic expression for $\\delta k(s, h, k_{0}, W)$ that is uniformly valid for small nondimensional grid parameter $h k_{0} \\ll 1$ and arbitrary fixed oversampling factor $s \\geq 1$, retaining all terms up to and including order $(h k_{0})^{2}$. Express your final result explicitly in terms of $h$, $s$, $k_{0}$, and $W(k_{0})$ only. Your final answer must be a single closed-form analytic expression. If you introduce intermediate series, ensure that the final expression has no series remainder symbol and is truncated consistently at order $(h k_{0})^{2}$. Do not include physical units in your answer.",
            "solution": "The starting point for this derivation is the provided numerical dispersion relation for the one-dimensional Adaptive Integral Method (AIM) long-range operator:\n$$\n\\frac{4 s^{2}}{h^{2}} \\sin^{2}\\!\\left( \\frac{k_{\\mathrm{num}} h}{2 s} \\right) \\;=\\; k_{0}^{2}\\, W(k_{0})\n$$\nThe goal is to find an asymptotic expression for the dispersion error, $\\delta k = k_{\\mathrm{num}} - k_{0}$, valid for $h k_{0} \\ll 1$ and retaining terms up to order $(h k_{0})^{2}$.\n\nFirst, we solve the dispersion relation for $k_{\\mathrm{num}}$. We begin by isolating the sine term:\n$$\n\\sin^{2}\\!\\left( \\frac{k_{\\mathrm{num}} h}{2 s} \\right) = \\frac{h^{2} k_{0}^{2}}{4 s^{2}} W(k_{0})\n$$\nTaking the square root of both sides gives:\n$$\n\\sin\\!\\left( \\frac{k_{\\mathrm{num}} h}{2 s} \\right) = \\pm \\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\n$$\nFor a propagating wave, we expect the numerical wavenumber $k_{\\mathrm{num}}$ to be a positive real number close to the physical wavenumber $k_{0}$. Given that $h$, $s$, and $k_{0}$ are positive, the argument of the sine function, $\\frac{k_{\\mathrm{num}} h}{2 s}$, is positive. In the limit $h k_0 \\to 0$, this argument approaches zero. In this regime, the sine of the argument is also positive. Therefore, we select the positive root:\n$$\n\\sin\\!\\left( \\frac{k_{\\mathrm{num}} h}{2 s} \\right) = \\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\n$$\nNext, we solve for $k_{\\mathrm{num}}$ by applying the inverse sine function:\n$$\n\\frac{k_{\\mathrm{num}} h}{2 s} = \\arcsin\\left( \\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})} \\right)\n$$\n$$\nk_{\\mathrm{num}} = \\frac{2 s}{h} \\arcsin\\left( \\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})} \\right)\n$$\nTo find the asymptotic behavior for small $h k_{0}$, we use the Taylor series expansion of the $\\arcsin(x)$ function around $x=0$:\n$$\n\\arcsin(x) = x + \\frac{1}{6}x^{3} + O(x^{5})\n$$\nLet the argument of the arcsine function be denoted by $x$:\n$$\nx = \\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\n$$\nSince the expansion is valid for $h k_{0} \\ll 1$ and for a fixed oversampling factor $s \\geq 1$, the parameter $x$ is small. We substitute the Taylor series into the expression for $k_{\\mathrm{num}}$:\n$$\nk_{\\mathrm{num}} = \\frac{2 s}{h} \\left[ \\left(\\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\\right) + \\frac{1}{6}\\left(\\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\\right)^{3} + O\\left( \\left(h k_{0}\\right)^{5} \\right) \\right]\n$$\nDistributing the leading factor $\\frac{2s}{h}$ yields:\n$$\nk_{\\mathrm{num}} = \\frac{2 s}{h} \\left(\\frac{h k_{0}}{2 s} \\sqrt{W(k_{0})}\\right) + \\frac{2 s}{h} \\frac{1}{6} \\left(\\frac{h^{3} k_{0}^{3}}{8 s^{3}} \\left(W(k_{0})\\right)^{3/2}\\right) + O\\left(h^{4}k_{0}^{5}\\right)\n$$\nSimplifying the terms, we obtain the asymptotic expression for $k_{\\mathrm{num}}$:\n$$\nk_{\\mathrm{num}} = k_{0} \\sqrt{W(k_{0})} + \\frac{h^{2} k_{0}^{3} \\left(W(k_{0})\\right)^{3/2}}{24 s^{2}} + O\\left(h^{4}k_{0}^{5}\\right)\n$$\nThe problem requires an expression for the dispersion error, $\\delta k = k_{\\mathrm{num}} - k_{0}$. Subtracting $k_{0}$ from the expression for $k_{\\mathrm{num}}$ gives:\n$$\n\\delta k = \\left( k_{0} \\sqrt{W(k_{0})} + \\frac{h^{2} k_{0}^{3} \\left(W(k_{0})\\right)^{3/2}}{24 s^{2}} + O\\left(h^{4}k_{0}^{5}\\right) \\right) - k_{0}\n$$\n$$\n\\delta k = k_{0} \\left(\\sqrt{W(k_{0})} - 1\\right) + \\frac{h^{2} k_{0}^{3} \\left(W(k_{0})\\right)^{3/2}}{24 s^{2}} + O\\left(h^{4}k_{0}^{5}\\right)\n$$\nThe problem asks to retain all terms up to and including order $(h k_{0})^{2}$. The first term, $k_{0} \\left(\\sqrt{W(k_{0})} - 1\\right)$, is of order $(h k_0)^0$, as $W(k_0)$ is treated as a given constant in this model. The second term, which can be written as $\\frac{k_{0} (W(k_0))^{3/2}}{24 s^2} (h k_0)^2$, is of order $(h k_{0})^{2}$. The remainder term is of order $(h k_{0})^{4}$ (since the next term in the arcsin expansion is $O(x^5)$, leading to an $O(h^4)$ term in $k_{num}$). Therefore, truncating the series to include terms up to order $(h k_{0})^{2}$ yields the final expression for the dispersion error:\n$$\n\\delta k(s, h, k_{0}, W) = k_{0} \\left(\\sqrt{W(k_{0})} - 1\\right) + \\frac{h^{2} k_{0}^{3} \\left(W(k_{0})\\right)^{3/2}}{24 s^{2}}\n$$\nThis is the required closed-form asymptotic expression for the dispersion error in terms of the specified parameters.",
            "answer": "$$\\boxed{k_{0} \\left(\\sqrt{W(k_{0})} - 1\\right) + \\frac{h^{2} k_{0}^{3} \\left(W(k_{0})\\right)^{3/2}}{24 s^{2}}}$$"
        },
        {
            "introduction": "While the far-field approximation accelerates computation, accuracy demands that singular near-field interactions are treated directly. This practice challenges you to move from theory to implementation by developing a sophisticated, adaptive criterion for the near-zone boundary. You will derive a rule from first principles, calibrate it with empirical data, and apply it to new scenarios, mirroring the workflow of creating practical, high-fidelity computational tools. ",
            "id": "3288301",
            "problem": "Consider the Adaptive Integral Method (AIM) for accelerating the discretized Electric Field Integral Equation (EFIE) in a homogeneous vacuum medium with permittivity $\\epsilon_0$ and permeability $\\mu_0$. AIM decomposes interactions into a near-zone, treated by direct quadrature, and a far-zone, treated via interpolation to a regular grid and Fast Fourier Transform-based convolution with the free-space scalar Green's function. The scalar Green's function is $G(\\mathbf{r}) = \\frac{e^{-j k r}}{4 \\pi r}$, where $r = \\|\\mathbf{r}\\|$, $j$ is the imaginary unit, and $k = \\frac{2 \\pi f}{c}$ is the free-space wavenumber for frequency $f$ and speed of light $c = \\frac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$. The far-zone approximation is accurate when the kernel is sufficiently smooth over the grid step $h$, and interactions over distances below a near-zone thickness $t_{\\mathrm{nz}}$ are treated exactly to control singularity and rapid variation.\n\nTask 1 (derivation from first principles): Starting from $G(r) = \\frac{e^{-j k r}}{4 \\pi r}$, require that the local relative variation of $G$ over one grid step $h$ satisfies $\\left|\\frac{G'(r)}{G(r)}\\right| h \\le \\varepsilon$, where $\\varepsilon \\in (0,1)$ is a dimensionless tolerance and $G'(r) = \\frac{d G}{d r}$. Derive an explicit expression for a threshold distance $r_\\varepsilon$ at which the bound becomes tight. Then, specify a robust fallback for the case in which the inequality cannot be satisfied because $\\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2$.\n\nTask 2 (composite adaptive rule): Incorporate the local electrical size $ka$, where $a$ is a characteristic local mesh element size, to account for phase variation across an element footprint. Further incorporate a sharp-edge correction based on a dihedral angle $\\phi$ (in degrees) between adjacent mesh panels, with $\\phi = 180^\\circ$ denoting locally planar and smaller $\\phi$ denoting sharper edges. Define the edge sharpness factor $s(\\phi) = \\sin\\left(\\frac{\\pi - \\phi_{\\mathrm{rad}}}{2}\\right)$, where $\\phi_{\\mathrm{rad}}$ is the angle in radians. Propose the following composite adaptive near-zone thickness rule:\n$$\nt_{\\mathrm{nz}}(k, a, h, \\varepsilon, \\phi; \\alpha, \\beta) \\;=\\; \\min\\!\\Bigg(3 a,\\; r_\\varepsilon + \\alpha\\, a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right) + \\beta\\, a\\, s(\\phi)\\Bigg),\n$$\nwhere $\\alpha$ and $\\beta$ are dimensionless calibration parameters, $r_\\varepsilon$ is the threshold distance from Task 1, and the cap $3 a$ prevents unbounded growth of the near zone when the grid step is too coarse.\n\nTask 3 (calibration using sharp-edge test problems): Calibrate $\\alpha$ and $\\beta$ by least squares using three calibration problems with provided ground-truth near-zone thicknesses $t_{\\mathrm{gt}}$ in meters. Use $k = \\frac{2 \\pi f}{c}$ with $c = \\frac{1}{\\sqrt{\\mu_0 \\epsilon_0}}$, $\\mu_0 = 4 \\pi \\times 10^{-7}\\ \\mathrm{H/m}$, and $\\epsilon_0 \\approx 8.854187817 \\times 10^{-12}\\ \\mathrm{F/m}$.\n\nCalibration problems (angles in degrees, distances in meters, frequencies in Hertz, answer units in meters):\n- Problem C1: $f = 1\\ \\mathrm{GHz}$, $a = 0.05\\ \\mathrm{m}$, $h = 0.01\\ \\mathrm{m}$, $\\phi = 60^\\circ$, $\\varepsilon = 0.3$, $t_{\\mathrm{gt}} = 0.102438\\ \\mathrm{m}$.\n- Problem C2: $f = 0.5\\ \\mathrm{GHz}$, $a = 0.02\\ \\mathrm{m}$, $h = 0.005\\ \\mathrm{m}$, $\\phi = 120^\\circ$, $\\varepsilon = 0.2$, $t_{\\mathrm{gt}} = 0.031904\\ \\mathrm{m}$.\n- Problem C3: $f = 2\\ \\mathrm{GHz}$, $a = 0.02\\ \\mathrm{m}$, $h = 0.01\\ \\mathrm{m}$, $\\phi = 45^\\circ$, $\\varepsilon = 0.2$, $t_{\\mathrm{gt}} = 0.048660\\ \\mathrm{m}$.\n\nIn all calibration problems, compute $k$ from the given $f$. For $r_\\varepsilon$, use the derivation from Task 1, and if $\\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2$, use the fallback $r_\\varepsilon = a$. Form the linear system by subtracting $r_\\varepsilon$ from $t_{\\mathrm{gt}}$ and regressing against the two features $a \\max\\left(0, \\frac{k a}{2 \\varepsilon} - 1\\right)$ and $a s(\\phi)$ to estimate $\\alpha$ and $\\beta$.\n\nTask 4 (prediction on a test suite): Using the calibrated $(\\alpha, \\beta)$, compute the near-zone integer layer count $L = \\lceil \\frac{t_{\\mathrm{nz}}}{h} \\rceil$ for each of the following three test problems. Angles are in degrees, distances in meters, frequencies in Hertz, and the required output unit for $t_{\\mathrm{nz}}$ is meters, but the program must output the integer layer counts.\n\nTest suite:\n- Test T1 (far-zone bound violated, smooth face): $f = 3\\ \\mathrm{GHz}$, $a = 0.04\\ \\mathrm{m}$, $h = 0.008\\ \\mathrm{m}$, $\\phi = 180^\\circ$, $\\varepsilon = 0.25$.\n- Test T2 (small electrical size, moderately sharp edge): $f = 0.3\\ \\mathrm{GHz}$, $a = 0.005\\ \\mathrm{m}$, $h = 0.002\\ \\mathrm{m}$, $\\phi = 150^\\circ$, $\\varepsilon = 0.3$.\n- Test T3 (mid-range electrical size, right angle edge): $f = 1.5\\ \\mathrm{GHz}$, $a = 0.03\\ \\mathrm{m}$, $h = 0.006\\ \\mathrm{m}$, $\\phi = 90^\\circ$, $\\varepsilon = 0.25$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order `[L_T1,L_T2,L_T3]` corresponding to Tests T1, T2, and T3. For example, an output of the form `[15,4,12]` is acceptable.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It contains a complete and consistent set of data and instructions for deriving, calibrating, and applying a model for the near-zone thickness in the Adaptive Integral Method (AIM). We will proceed with the solution by addressing each task sequentially.\n\n### Task 1: Derivation of the Threshold Distance $r_\\varepsilon$\n\nThe analysis begins with the free-space scalar Green's function, given by:\n$$\nG(r) = \\frac{e^{-j k r}}{4 \\pi r}\n$$\nwhere $r = \\|\\mathbf{r}\\|$ is the distance, $j$ is the imaginary unit, and $k$ is the wavenumber. We are tasked with finding a threshold distance $r_\\varepsilon$ based on the local relative variation of $G(r)$. The first step is to compute the derivative of $G(r)$ with respect to $r$:\n$$\nG'(r) = \\frac{d}{dr} G(r) = \\frac{d}{dr} \\left( \\frac{e^{-jkr}}{4\\pi r} \\right) = \\frac{1}{4\\pi} \\left( \\frac{-jke^{-jkr} \\cdot r - e^{-jkr} \\cdot 1}{r^2} \\right) = \\frac{e^{-jkr}}{4\\pi r^2}(-jkr - 1)\n$$\nThe relative rate of change is the ratio $\\frac{G'(r)}{G(r)}$:\n$$\n\\frac{G'(r)}{G(r)} = \\frac{\\frac{e^{-jkr}}{4\\pi r^2}(-jkr - 1)}{\\frac{e^{-jkr}}{4\\pi r}} = \\frac{-jkr - 1}{r} = -jk - \\frac{1}{r}\n$$\nThe magnitude of this complex quantity is:\n$$\n\\left| \\frac{G'(r)}{G(r)} \\right| = \\left| -jk - \\frac{1}{r} \\right| = \\sqrt{(-k)^2 + \\left(-\\frac{1}{r}\\right)^2} = \\sqrt{k^2 + \\frac{1}{r^2}}\n$$\nThe condition for the far-zone approximation is that the relative variation over a grid step $h$ is bounded by a tolerance $\\varepsilon$:\n$$\n\\left| \\frac{G'(r)}{G(r)} \\right| h \\le \\varepsilon\n$$\nThe threshold distance $r_\\varepsilon$ is defined where this bound is tight, i.e., equality holds:\n$$\nh \\sqrt{k^2 + \\frac{1}{r_\\varepsilon^2}} = \\varepsilon\n$$\nWe solve this equation for $r_\\varepsilon$:\n$$\n\\sqrt{k^2 + \\frac{1}{r_\\varepsilon^2}} = \\frac{\\varepsilon}{h}\n$$\n$$\nk^2 + \\frac{1}{r_\\varepsilon^2} = \\left(\\frac{\\varepsilon}{h}\\right)^2\n$$\n$$\n\\frac{1}{r_\\varepsilon^2} = \\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2\n$$\n$$\nr_\\varepsilon^2 = \\frac{1}{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}\n$$\nTaking the positive square root for distance yields the explicit expression for $r_\\varepsilon$:\n$$\nr_\\varepsilon = \\frac{1}{\\sqrt{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}}\n$$\nFor $r_\\varepsilon$ to be a real, positive number, the quantity under the square root in the denominator must be positive, which implies the condition $\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2 > 0$, or $\\left(\\frac{\\varepsilon}{h}\\right)^2 > k^2$. The problem specifies a robust fallback for the case where this inequality is not satisfied, i.e., when $\\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2$. In this scenario, where the Green's function varies too rapidly for the grid to resolve even asymptotically, the threshold distance is set to a characteristic element size $a$. So, the complete rule for $r_\\varepsilon$ is:\n$$\nr_\\varepsilon = \\begin{cases} \\dfrac{1}{\\sqrt{\\left(\\frac{\\varepsilon}{h}\\right)^2 - k^2}}  \\text{if } \\left(\\frac{\\varepsilon}{h}\\right)^2  k^2 \\\\ a  \\text{if } \\left(\\frac{\\varepsilon}{h}\\right)^2 \\le k^2 \\end{cases}\n$$\n\n### Tasks 2  3: Model Calibration\n\nThe composite adaptive near-zone thickness rule is given as:\n$$\nt_{\\mathrm{nz}}(k, a, h, \\varepsilon, \\phi; \\alpha, \\beta) \\;=\\; \\min\\!\\Bigg(3 a,\\; r_\\varepsilon + \\alpha\\, a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right) + \\beta\\, a\\, s(\\phi)\\Bigg)\n$$\nwhere $s(\\phi) = \\sin\\!\\left(\\frac{\\pi - \\phi_{\\mathrm{rad}}}{2}\\right)$. The parameters $\\alpha$ and $\\beta$ are to be calibrated using a least squares fit on three provided ground-truth problems (C1, C2, C3). The regression model is formulated by isolating the terms containing $\\alpha$ and $\\beta$:\n$$\nt_{\\mathrm{gt}} - r_\\varepsilon \\approx \\alpha\\, \\underbrace{a\\, \\max\\!\\left(0,\\, \\frac{k a}{2 \\varepsilon} - 1\\right)}_{x_1} + \\beta\\, \\underbrace{a\\, s(\\phi)}_{x_2}\n$$\nThis defines a linear system $\\mathbf{y} = \\mathbf{Xp}$, where $\\mathbf{p} = [\\alpha, \\beta]^T$. We compute the vectors $\\mathbf{y}$ and matrix $\\mathbf{X}$ for the three calibration problems. The constants used are $\\mu_0 = 4 \\pi \\times 10^{-7}\\ \\mathrm{H/m}$ and $\\epsilon_0 = 8.854187817 \\times 10^{-12}\\ \\mathrm{F/m}$, from which the speed of light is $c = (\\mu_0\\epsilon_0)^{-1/2} \\approx 299792458.02\\ \\mathrm{m/s}$.\n\n**Calibration Problem C1:**\nGiven: $f = 1\\ \\mathrm{GHz}$, $a = 0.05\\ \\mathrm{m}$, $h = 0.01\\ \\mathrm{m}$, $\\phi = 60^\\circ$, $\\varepsilon = 0.3$, $t_{\\mathrm{gt}} = 0.102438\\ \\mathrm{m}$.\nCalculations:\n$k = \\frac{2\\pi f}{c} \\approx 20.958\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 = (\\frac{0.3}{0.01})^2 = 900$; $k^2 \\approx 439.257$. Since $900  439.257$, we use the derived formula: $r_{\\varepsilon,1} \\approx 0.046588\\ \\mathrm{m}$.\nFeature $x_{1,1} = 0.05 \\cdot \\max(0, \\frac{20.958 \\cdot 0.05}{2 \\cdot 0.3} - 1) \\approx 0.037327\\ \\mathrm{m}$.\nFeature $x_{2,1} = 0.05 \\cdot \\sin(\\frac{\\pi - \\pi/3}{2}) \\approx 0.043301\\ \\mathrm{m}$.\nTarget $y_1 = t_{\\mathrm{gt},1} - r_{\\varepsilon,1} = 0.102438 - 0.046588 = 0.055850\\ \\mathrm{m}$.\n\n**Calibration Problem C2:**\nGiven: $f = 0.5\\ \\mathrm{GHz}$, $a = 0.02\\ \\mathrm{m}$, $h = 0.005\\ \\mathrm{m}$, $\\phi = 120^\\circ$, $\\varepsilon = 0.2$, $t_{\\mathrm{gt}} = 0.031904\\ \\mathrm{m}$.\nCalculations:\n$k = \\frac{2\\pi f}{c} \\approx 10.479\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 = (\\frac{0.2}{0.005})^2 = 1600$; $k^2 \\approx 109.814$. Since $1600  109.814$, we use the formula: $r_{\\varepsilon,2} \\approx 0.025905\\ \\mathrm{m}$.\nFeature $x_{1,2} = 0.02 \\cdot \\max(0, \\frac{10.479 \\cdot 0.02}{2 \\cdot 0.2} - 1) = 0\\ \\mathrm{m}$.\nFeature $x_{2,2} = 0.02 \\cdot \\sin(\\frac{\\pi - 2\\pi/3}{2}) = 0.01\\ \\mathrm{m}$.\nTarget $y_2 = t_{\\mathrm{gt},2} - r_{\\varepsilon,2} = 0.031904 - 0.025905 = 0.005999\\ \\mathrm{m}$.\n\n**Calibration Problem C3:**\nGiven: $f = 2\\ \\mathrm{GHz}$, $a = 0.02\\ \\mathrm{m}$, $h = 0.01\\ \\mathrm{m}$, $\\phi = 45^\\circ$, $\\varepsilon = 0.2$, $t_{\\mathrm{gt}} = 0.048660\\ \\mathrm{m}$.\nCalculations:\n$k = \\frac{2\\pi f}{c} \\approx 41.917\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 = (\\frac{0.2}{0.01})^2 = 400$; $k^2 \\approx 1757.027$. Since $400 \\le 1757.027$, we use the fallback: $r_{\\varepsilon,3} = a = 0.02\\ \\mathrm{m}$.\nFeature $x_{1,3} = 0.02 \\cdot \\max(0, \\frac{41.917 \\cdot 0.02}{2 \\cdot 0.2} - 1) \\approx 0.021917\\ \\mathrm{m}$.\nFeature $x_{2,3} = 0.02 \\cdot \\sin(\\frac{\\pi - \\pi/4}{2}) \\approx 0.018478\\ \\mathrm{m}$.\nTarget $y_3 = t_{\\mathrm{gt},3} - r_{\\varepsilon,3} = 0.048660 - 0.02 = 0.028660\\ \\mathrm{m}$.\n\nThe linear system is:\n$$\n\\begin{pmatrix} 0.055850 \\\\ 0.005999 \\\\ 0.028660 \\end{pmatrix} = \\begin{pmatrix} 0.037327  0.043301 \\\\ 0.0  0.01 \\\\ 0.021917  0.018478 \\end{pmatrix} \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}\n$$\nSolving this overdetermined system using linear least squares yields the calibrated parameters:\n$$\n\\alpha \\approx 1.20002 \\quad \\text{and} \\quad \\beta \\approx 0.24997\n$$\nFor subsequent calculations, we will use these fitted values.\n\n### Task 4: Prediction on the Test Suite\n\nWe now apply the calibrated model to compute the near-zone integer layer count $L = \\lceil \\frac{t_{\\mathrm{nz}}}{h} \\rceil$ for three test problems.\n\n**Test T1:**\nGiven: $f = 3\\ \\mathrm{GHz}$, $a = 0.04\\ \\mathrm{m}$, $h = 0.008\\ \\mathrm{m}$, $\\phi = 180^\\circ$, $\\varepsilon = 0.25$.\nCalculations:\n$k \\approx 62.875\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 \\approx 976.56$; $k^2 \\approx 3953.30$. Since $(\\frac{\\varepsilon}{h})^2 \\le k^2$, we use the fallback $r_\\varepsilon = a = 0.04\\ \\mathrm{m}$.\nTerm for $\\alpha$: $1.20002 \\cdot 0.04 \\cdot \\max(0, \\frac{62.875 \\cdot 0.04}{2 \\cdot 0.25} - 1) \\approx 0.19345\\ \\mathrm{m}$.\nTerm for $\\beta$: $0.24997 \\cdot 0.04 \\cdot \\sin(\\frac{\\pi - \\pi}{2}) = 0\\ \\mathrm{m}$.\nUncapped thickness: $t'_{\\mathrm{nz}} = 0.04 + 0.19345 + 0 = 0.23345\\ \\mathrm{m}$.\nCapped thickness: $t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.12, 0.23345) = 0.12\\ \\mathrm{m}$.\nLayer count: $L_{\\mathrm{T1}} = \\lceil \\frac{0.12}{0.008} \\rceil = \\lceil 15 \\rceil = 15$.\n\n**Test T2:**\nGiven: $f = 0.3\\ \\mathrm{GHz}$, $a = 0.005\\ \\mathrm{m}$, $h = 0.002\\ \\mathrm{m}$, $\\phi = 150^\\circ$, $\\varepsilon = 0.3$.\nCalculations:\n$k \\approx 6.288\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 = 22500$; $k^2 \\approx 39.53$. Since $(\\frac{\\varepsilon}{h})^2  k^2$, we use the formula $r_\\varepsilon \\approx 0.006673\\ \\mathrm{m}$.\nTerm for $\\alpha$: $1.20002 \\cdot 0.005 \\cdot \\max(0, \\frac{6.288 \\cdot 0.005}{2 \\cdot 0.3} - 1) = 0\\ \\mathrm{m}$.\nTerm for $\\beta$: $0.24997 \\cdot 0.005 \\cdot \\sin(\\frac{\\pi - 5\\pi/6}{2}) \\approx 0.000323\\ \\mathrm{m}$.\nUncapped thickness: $t'_{\\mathrm{nz}} = 0.006673 + 0 + 0.000323 = 0.006996\\ \\mathrm{m}$.\nCapped thickness: $t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.015, 0.006996) = 0.006996\\ \\mathrm{m}$.\nLayer count: $L_{\\mathrm{T2}} = \\lceil \\frac{0.006996}{0.002} \\rceil = \\lceil 3.498 \\rceil = 4$.\n\n**Test T3:**\nGiven: $f = 1.5\\ \\mathrm{GHz}$, $a = 0.03\\ \\mathrm{m}$, $h = 0.006\\ \\mathrm{m}$, $\\phi = 90^\\circ$, $\\varepsilon = 0.25$.\nCalculations:\n$k \\approx 31.438\\ \\mathrm{rad/m}$.\nCheck for $r_\\varepsilon$: $(\\frac{\\varepsilon}{h})^2 \\approx 1736.11$; $k^2 \\approx 988.27$. Since $(\\frac{\\varepsilon}{h})^2  k^2$, we use the formula $r_\\varepsilon \\approx 0.036567\\ \\mathrm{m}$.\nTerm for $\\alpha$: $1.20002 \\cdot 0.03 \\cdot \\max(0, \\frac{31.438 \\cdot 0.03}{2 \\cdot 0.25} - 1) \\approx 0.031906\\ \\mathrm{m}$.\nTerm for $\\beta$: $0.24997 \\cdot 0.03 \\cdot \\sin(\\frac{\\pi - \\pi/2}{2}) \\approx 0.005303\\ \\mathrm{m}$.\nUncapped thickness: $t'_{\\mathrm{nz}} = 0.036567 + 0.031906 + 0.005303 = 0.073776\\ \\mathrm{m}$.\nCapped thickness: $t_{\\mathrm{nz}} = \\min(3a, t'_{\\mathrm{nz}}) = \\min(0.09, 0.073776) = 0.073776\\ \\mathrm{m}$.\nLayer count: $L_{\\mathrm{T3}} = \\lceil \\frac{0.073776}{0.006} \\rceil = \\lceil 12.296 \\rceil = 13$.\n\nThe final results for the integer layer counts are $L_{\\mathrm{T1}} = 15$, $L_{\\mathrm{T2}} = 4$, and $L_{\\mathrm{T3}} = 13$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-part problem related to the Adaptive Integral Method (AIM).\n    1. Defines physical constants and helper functions.\n    2. Calibrates parameters alpha and beta using least squares on calibration data.\n    3. Applies the calibrated model to a test suite to compute near-zone layer counts.\n    \"\"\"\n    \n    # Constants\n    MU_0 = 4 * np.pi * 1e-7  # Permeability of free space (H/m)\n    EPSILON_0 = 8.854187817e-12  # Permittivity of free space (F/m)\n    C = 1 / np.sqrt(MU_0 * EPSILON_0)  # Speed of light in vacuum (m/s)\n\n    def calculate_k(f):\n        \"\"\"Calculates the wavenumber k.\"\"\"\n        return 2 * np.pi * f / C\n\n    def calculate_r_epsilon(k, h, a, epsilon):\n        \"\"\"Calculates the threshold distance r_epsilon with its fallback rule.\"\"\"\n        eps_h_sq = (epsilon / h)**2\n        k_sq = k**2\n        if eps_h_sq > k_sq:\n            return 1 / np.sqrt(eps_h_sq - k_sq)\n        else:\n            return a\n\n    def calculate_s_phi(phi_deg):\n        \"\"\"Calculates the edge sharpness factor s(phi).\"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        return np.sin((np.pi - phi_rad) / 2)\n\n    # --- Task 3: Calibration ---\n    calibration_problems = [\n        # (f, a, h, phi, epsilon, t_gt)\n        (1e9, 0.05, 0.01, 60, 0.3, 0.102438),  # C1\n        (0.5e9, 0.02, 0.005, 120, 0.2, 0.031904), # C2\n        (2e9, 0.02, 0.01, 45, 0.2, 0.048660),   # C3\n    ]\n\n    X_cal = []\n    y_cal = []\n\n    for f, a, h, phi_deg, epsilon, t_gt in calibration_problems:\n        k = calculate_k(f)\n        r_eps = calculate_r_epsilon(k, h, a, epsilon)\n        \n        # Feature 1 for alpha\n        x1_term = a * max(0, (k * a) / (2 * epsilon) - 1)\n        \n        # Feature 2 for beta\n        s_phi = calculate_s_phi(phi_deg)\n        x2_term = a * s_phi\n        \n        X_cal.append([x1_term, x2_term])\n        y_cal.append(t_gt - r_eps)\n\n    X_matrix = np.array(X_cal)\n    y_vector = np.array(y_cal)\n\n    # Perform least squares to find alpha and beta\n    params, _, _, _ = np.linalg.lstsq(X_matrix, y_vector, rcond=None)\n    alpha_cal, beta_cal = params\n\n    # --- Task 4: Prediction on Test Suite ---\n    test_suite = [\n        # (f, a, h, phi, epsilon)\n        (3e9, 0.04, 0.008, 180, 0.25),  # T1\n        (0.3e9, 0.005, 0.002, 150, 0.3),  # T2\n        (1.5e9, 0.03, 0.006, 90, 0.25), # T3\n    ]\n\n    results = []\n    \n    def calculate_t_nz(k, a, h, phi_deg, epsilon, alpha, beta):\n        \"\"\"Calculates the composite near-zone thickness t_nz.\"\"\"\n        r_eps = calculate_r_epsilon(k, h, a, epsilon)\n        \n        term_alpha = alpha * a * max(0, (k * a) / (2 * epsilon) - 1)\n        \n        s_phi = calculate_s_phi(phi_deg)\n        term_beta = beta * a * s_phi\n        \n        uncapped_t_nz = r_eps + term_alpha + term_beta\n        \n        return min(3 * a, uncapped_t_nz)\n\n    for f, a, h, phi_deg, epsilon in test_suite:\n        k = calculate_k(f)\n        t_nz = calculate_t_nz(k, a, h, phi_deg, epsilon, alpha_cal, beta_cal)\n        \n        # Calculate integer layer count L\n        L = int(np.ceil(t_nz / h))\n        results.append(L)\n\n    # Final output format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An accurate algorithm must also be computationally efficient to tackle large-scale problems. This final practice bridges the gap between algorithmic design and high-performance computing. You will construct a roofline-based performance model to predict the throughput of an AIM implementation on modern CPU and GPU architectures, learning to identify bottlenecks and evaluate optimization strategies like concurrent execution. ",
            "id": "3288252",
            "problem": "You are asked to design and implement a quantitative performance model for the Adaptive Integral Method (AIM) used in computational electromagnetics to accelerate boundary integral equation solvers. In AIM, the impedance matrix is decomposed into a near-zone component and a far-zone component. The near-zone component, denoted by $\\mathbf{Z}_{\\text{near}}$, is applied as a sparse matrix-vector product, and the far-zone component is computed via convolution on a regular grid using the Fast Fourier Transform (FFT). Your task is to derive, implement, and evaluate a model that couples FFT arithmetic intensity and Central Processing Unit (CPU) or Graphics Processing Unit (GPU) memory bandwidth to predict end-to-end AIM throughput. You must also propose and model overlap strategies for $\\mathbf{Z}_{\\text{near}}$ application and FFT processing in heterogeneous settings (CPU plus GPU) and quantify the resulting throughput improvement.\n\nBegin from the following foundational definitions and widely-accepted facts:\n- A $3$-dimensional complex-to-complex FFT of size $n_x \\times n_y \\times n_z$ can be implemented as sequences of one-dimensional FFTs; the total number of real floating-point operations for one forward transform is approximately $5 n_g \\log_2 n_g$, where $n_g = n_x n_y n_z$. The same count applies to the inverse transform. A pointwise complex multiplication on the spectral grid costs $6$ real floating-point operations per grid point.\n- Arithmetic intensity is defined as $I = F/T_b$, where $F$ is the number of floating-point operations and $T_b$ is the number of bytes moved to or from main memory.\n- The roofline model states that the achieved floating-point rate $R$ for a kernel on a device with peak floating-point rate $P$ and sustainable memory bandwidth $B$ is $R = \\min(P, I B)$.\n- A complex double-precision number occupies $s_c = 16$ bytes.\n- For the sparse near-zone application with $N$ unknowns and average near neighbors $\\nu$, model the floating-point operations as $F_{\\text{near}} = 10 \\nu N$ (accounting for complex multiply-adds), and model the memory traffic as $T_{b,\\text{near}} = s_c N (2 \\nu + 1)$ (reading $\\nu$ complex matrix entries and $\\nu$ complex vector entries per unknown, and writing one complex result per unknown).\n- For the far-zone FFT step consisting of one forward FFT, one pointwise spectral-domain multiplication, and one inverse FFT, model the floating-point operations as $F_{\\text{fft}} = 10 n_g \\log_2 n_g + 6 n_g$ and the memory traffic as $T_{b,\\text{fft}} = 14 s_c n_g$, assuming each of the two FFTs performs three streamed passes (one per axis) with read and write per pass, and the spectral multiply performs one read and one write in-place.\n\nYou must compute the following per test case:\n- The non-overlapped iteration time $t_{\\text{no}}$ in seconds, defined as the sum of component times for the near-zone, the far-zone FFT, and any host-device transfer time if the near-zone and far-zone are executed on different devices.\n- The overlapped iteration time $t_{\\text{ov}}$ in seconds, under an idealized double-buffering strategy in which CPU-side $\\mathbf{Z}_{\\text{near}}$ application, GPU-side FFT, and host-device transfer proceed concurrently when they reside on different devices, modeled as $t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$. If both near and far tasks execute on the same device, assume no overlap so that $t_{\\text{ov}} = t_{\\text{no}}$.\n- The non-overlapped throughput $\\theta_{\\text{no}}$ in iterations per second, defined as $\\theta_{\\text{no}} = 1/t_{\\text{no}}$.\n- The overlapped throughput $\\theta_{\\text{ov}}$ in iterations per second, defined as $\\theta_{\\text{ov}} = 1/t_{\\text{ov}}$.\n- For the FFT kernel in each test case, report the arithmetic intensity $I_{\\text{fft}}$.\n\nModel details:\n- For a computation on a given device, compute arithmetic intensity $I$ and achieved rate $R = \\min(P, I B)$, then time $t = F / R$.\n- Use $t_{\\text{hd}} = T_{b,\\text{transfer}}/B_{\\text{pcie}}$ when near and far execute on different devices, with $T_{b,\\text{transfer}} = 2 s_c N$ per iteration to account for transferring the complex vector of length $N$ to and from the accelerator. If both stages execute on the same device, set $t_{\\text{hd}} = 0$.\n\nUnits and output requirements:\n- Express all times in seconds and throughput in iterations per second. When printing the results, round each floating-point number to $6$ decimal places.\n- Angles are not involved; do not use angle units.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sublist of four floats and one additional float for $I_{\\text{fft}}$, ordered as `[t_no,t_ov,theta_no,theta_ov,I_fft]`. The final line must be a list of these sublists, for all test cases, with no spaces.\n\nTest suite:\n- Case $1$ (CPU-only baseline):\n  - Grid: $n_x = 128$, $n_y = 128$, $n_z = 128$.\n  - Unknowns: $N = 2{,}097{,}152$.\n  - Near neighbors: $\\nu = 12$.\n  - Complex size: $s_c = 16$ bytes.\n  - CPU peak: $P_{\\text{cpu}} = 5 \\times 10^{11}$ flops/s.\n  - CPU bandwidth: $B_{\\text{cpu}} = 1 \\times 10^{11}$ bytes/s.\n  - Execution: far-zone on CPU, near-zone on CPU, so $t_{\\text{hd}} = 0$.\n- Case $2$ (heterogeneous overlap: GPU far, CPU near with host-device transfer):\n  - Grid: $n_x = 256$, $n_y = 256$, $n_z = 256$.\n  - Unknowns: $N = 8{,}000{,}000$.\n  - Near neighbors: $\\nu = 8$.\n  - Complex size: $s_c = 16$ bytes.\n  - GPU peak: $P_{\\text{gpu}} = 1.5 \\times 10^{13}$ flops/s.\n  - GPU bandwidth: $B_{\\text{gpu}} = 8.0 \\times 10^{11}$ bytes/s.\n  - CPU peak: $P_{\\text{cpu}} = 5 \\times 10^{11}$ flops/s.\n  - CPU bandwidth: $B_{\\text{cpu}} = 1 \\times 10^{11}$ bytes/s.\n  - Host-device bandwidth: $B_{\\text{pcie}} = 1.6 \\times 10^{10}$ bytes/s.\n  - Execution: far-zone on GPU, near-zone on CPU, so include $t_{\\text{hd}}$ and model overlap $t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$.\n- Case $3$ (GPU-only, near heavier than far):\n  - Grid: $n_x = 512$, $n_y = 512$, $n_z = 512$.\n  - Unknowns: $N = 30{,}000{,}000$.\n  - Near neighbors: $\\nu = 30$.\n  - Complex size: $s_c = 16$ bytes.\n  - GPU peak: $P_{\\text{gpu}} = 1.5 \\times 10^{13}$ flops/s.\n  - GPU bandwidth: $B_{\\text{gpu}} = 8.0 \\times 10^{11}$ bytes/s.\n  - Execution: far-zone on GPU, near-zone on GPU, so $t_{\\text{hd}} = 0$ and no overlap.\n- Case $4$ (small-grid boundary case, CPU-only):\n  - Grid: $n_x = 16$, $n_y = 16$, $n_z = 16$.\n  - Unknowns: $N = 10{,}000$.\n  - Near neighbors: $\\nu = 4$.\n  - Complex size: $s_c = 16$ bytes.\n  - CPU peak: $P_{\\text{cpu}} = 2 \\times 10^{11}$ flops/s.\n  - CPU bandwidth: $B_{\\text{cpu}} = 5.0 \\times 10^{10}$ bytes/s.\n  - Execution: far-zone on CPU, near-zone on CPU, so $t_{\\text{hd}} = 0$.\n\nYour program must implement the above model and produce a single line of output of the form `[[t_no,1,t_ov,1,theta_no,1,theta_ov,1,I_fft,1],...,[t_no,4,t_ov,4,theta_no,4,theta_ov,4,I_fft,4]]`, with each float rounded to $6$ decimal places and no spaces anywhere in the line.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and complete. All necessary parameters, models, and definitions are provided to construct a quantitative performance model for the Adaptive Integral Method (AIM).\n\nThe solution involves synthesizing several established models: the algorithmic structure of AIM, cost models for its computational kernels (sparse matrix-vector multiplication and Fast Fourier Transform), and the roofline performance model for predicting execution time on a specific hardware architecture. The problem requires the analysis of four distinct test cases, covering CPU-only, GPU-only, and heterogeneous CPU-GPU execution scenarios.\n\nThe core of the AIM performance model is the decomposition of the total iteration time. An iteration consists of a near-zone calculation and a far-zone calculation.\n\nFirst, we define the parameters provided in the problem statement:\n- The size of the FFT grid is $n_x \\times n_y \\times n_z$, with the total number of grid points being $n_g = n_x n_y n_z$.\n- The number of unknowns in the boundary element method is $N$.\n- The average number of near-neighbors for each unknown is $\\nu$.\n- The size of a complex double-precision number is $s_c = 16$ bytes.\n- The peak floating-point rate of a device is $P$ (in flops/s).\n- The sustainable memory bandwidth of a device is $B$ (in bytes/s).\n- The host-to-device interconnect bandwidth is $B_{\\text{pcie}}$.\n\nThe performance of each computational component is determined using the roofline model. The achieved floating-point rate, $R$, is given by $R = \\min(P, I \\times B)$, where $I$ is the arithmetic intensity of the kernel. The arithmetic intensity is the ratio of floating-point operations performed ($F$) to the number of bytes moved from/to main memory ($T_b$), i.e., $I = F/T_b$. The execution time $t$ of a kernel is then $t = F/R$.\n\n**Near-Zone Component ($t_{\\text{near}}$)**\nThe near-zone calculation is modeled as a sparse matrix-vector product.\n1.  The number of floating-point operations, $F_{\\text{near}}$, is modeled as $F_{\\text{near}} = 10 \\nu N$. This accounts for a complex multiply-add operation (e.g., $4$ multiplications and $2$ additions for complex multiplication, plus $2$ additions for complex addition, totaling $8$ real operations, but the model specifies $10$ as a reasonable approximation).\n2.  The memory traffic, $T_{b,\\text{near}}$, is modeled as $T_{b,\\text{near}} = s_c N (2 \\nu + 1)$. This assumes reading $\\nu$ complex matrix entries, $\\nu$ complex vector entries, and writing one complex result entry for each of the $N$ unknowns.\n3.  The arithmetic intensity is $I_{\\text{near}} = \\frac{F_{\\text{near}}}{T_{b,\\text{near}}} = \\frac{10 \\nu N}{s_c N (2 \\nu + 1)} = \\frac{10 \\nu}{s_c (2 \\nu + 1)}$.\n4.  Given the device parameters ($P_{\\text{near_dev}}$, $B_{\\text{near_dev}}$), the achieved rate is $R_{\\text{near}} = \\min(P_{\\text{near_dev}}, I_{\\text{near}} \\times B_{\\text{near_dev}})$.\n5.  The execution time for the near-zone component is $t_{\\text{near}} = F_{\\text{near}} / R_{\\text{near}}$.\n\n**Far-Zone Component ($t_{\\text{fft}}$)**\nThe far-zone calculation is dominated by three steps: a forward $3$D FFT, a pointwise multiplication in the spectral domain, and an inverse $3$D FFT.\n1.  The total floating-point operations, $F_{\\text{fft}}$, are given by the sum of operations for two FFTs and the pointwise multiplication: $F_{\\text{fft}} = 2 \\times (5 n_g \\log_2 n_g) + 6 n_g = 10 n_g \\log_2 n_g + 6 n_g$.\n2.  The memory traffic, $T_{b,\\text{fft}}$, is specified as $T_{b,\\text{fft}} = 14 s_c n_g$. This is based on a specific implementation model where each FFT involves three passes (one per dimension) each requiring a read and a write of the entire grid ($2 \\times 3 \\times s_c n_g$ per FFT), and the spectral multiplication involves one read and one write pass ($2 s_c n_g$), totaling $(2 \\times 6 + 2)s_c n_g = 14 s_c n_g$ bytes.\n3.  The arithmetic intensity, $I_{\\text{fft}}$, which is one of the required outputs, is $I_{\\text{fft}} = \\frac{F_{\\text{fft}}}{T_{b,\\text{fft}}} = \\frac{10 n_g \\log_2 n_g + 6 n_g}{14 s_c n_g} = \\frac{10 \\log_2 n_g + 6}{14 s_c}$.\n4.  Given the device parameters ($P_{\\text{fft_dev}}$, $B_{\\text{fft_dev}}$), the achieved rate is $R_{\\text{fft}} = \\min(P_{\\text{fft_dev}}, I_{\\text{fft}} \\times B_{\\text{fft_dev}})$.\n5.  The execution time for the far-zone component is $t_{\\text{fft}} = F_{\\text{fft}} / R_{\\text{fft}}$.\n\n**Host-Device Transfer ($t_{\\text{hd}}$)**\nData transfer between CPU and GPU is necessary only in heterogeneous execution scenarios.\n1.  The transfer time $t_{\\text{hd}}$ is zero if both near-zone and far-zone computations are performed on the same device.\n2.  If they are on different devices, a complex vector of length $N$ must be transferred to the accelerator and the result transferred back. The total data moved is $T_{b,\\text{transfer}} = 2 s_c N$.\n3.  The time taken is $t_{\\text{hd}} = T_{b,\\text{transfer}} / B_{\\text{pcie}}$.\n\n**Total Time and Throughput**\nThe total iteration time and throughput are calculated for two scenarios: non-overlapped and overlapped.\n1.  **Non-Overlapped**: The total time, $t_{\\text{no}}$, is the sum of the individual component times: $t_{\\text{no}} = t_{\\text{near}} + t_{\\text{fft}} + t_{\\text{hd}}$. The corresponding throughput is $\\theta_{\\text{no}} = 1/t_{\\text{no}}$.\n2.  **Overlapped**: Overlap is only possible in the heterogeneous case, where the near-zone (on CPU), far-zone (on GPU), and data transfers can be pipelined. The iteration time is limited by the slowest stage: $t_{\\text{ov}} = \\max(t_{\\text{near}}, t_{\\text{fft}}, t_{\\text{hd}})$. If both components execute on the same device, no overlap is possible, so $t_{\\text{ov}} = t_{\\text{no}}$. The corresponding throughput is $\\theta_{\\text{ov}} = 1/t_{\\text{ov}}$.\n\nThese principles are implemented for each of the four test cases specified in the problem statement to compute the five required output values: $[t_{\\text{no}}, t_{\\text{ov}}, \\theta_{\\text{no}}, \\theta_{\\text{ov}}, I_{\\text{fft}}]$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AIM performance modeling problem for all test cases.\n    \"\"\"\n\n    def calculate_performance(case):\n        \"\"\"\n        Calculates the performance metrics for a single test case.\n        \"\"\"\n        nx, ny, nz = case[\"grid\"]\n        N = case[\"N\"]\n        nu = case[\"nu\"]\n        s_c = case[\"s_c\"]\n        \n        P_cpu = case.get(\"P_cpu\")\n        B_cpu = case.get(\"B_cpu\")\n        P_gpu = case.get(\"P_gpu\")\n        B_gpu = case.get(\"B_gpu\")\n        B_pcie = case.get(\"B_pcie\")\n\n        near_exec_dev = case[\"near_exec\"]\n        far_exec_dev = case[\"far_exec\"]\n\n        # Determine device parameters for each part\n        if near_exec_dev == 'CPU':\n            P_near, B_near = P_cpu, B_cpu\n        else:\n            P_near, B_near = P_gpu, B_gpu\n\n        if far_exec_dev == 'CPU':\n            P_far, B_far = P_cpu, B_cpu\n        else:\n            P_far, B_far = P_gpu, B_gpu\n\n        is_heterogeneous = near_exec_dev != far_exec_dev\n\n        # Grid size\n        ng = nx * ny * nz\n\n        # ---- Near-zone calculations ----\n        F_near = 10 * nu * N\n        Tb_near = s_c * N * (2 * nu + 1)\n        if Tb_near > 0:\n            I_near = F_near / Tb_near\n        else: # Avoid division by zero\n            I_near = 0\n        \n        R_near = min(P_near, I_near * B_near)\n        if R_near > 0:\n            t_near = F_near / R_near\n        else: # Avoid division by zero\n            t_near = 0\n\n        # ---- Far-zone calculations ----\n        log2_ng = np.log2(ng)\n        F_far = 10 * ng * log2_ng + 6 * ng\n        \n        # This is one of the required outputs\n        I_fft = (10 * log2_ng + 6) / (14 * s_c)\n        \n        R_far = min(P_far, I_fft * B_far)\n        if R_far > 0:\n            t_far = F_far / R_far\n        else: # Avoid division by zero\n            t_far = 0\n\n\n        # ---- Host-device transfer time ----\n        if is_heterogeneous:\n            Tb_transfer = 2 * s_c * N\n            t_hd = Tb_transfer / B_pcie\n        else:\n            t_hd = 0\n\n        # ---- Total time and throughputs ----\n        t_no = t_near + t_far + t_hd\n        \n        if is_heterogeneous:\n            t_ov = max(t_near, t_far, t_hd)\n        else:\n            t_ov = t_no\n\n        if t_no > 0:\n            theta_no = 1 / t_no\n        else:\n            theta_no = 0\n\n        if t_ov > 0:\n            theta_ov = 1 / t_ov\n        else:\n            theta_ov = 0\n\n        return [t_no, t_ov, theta_no, theta_ov, I_fft]\n\n    test_cases = [\n        # Case 1 (CPU-only baseline)\n        {\n            \"grid\": (128, 128, 128), \"N\": 2097152, \"nu\": 12, \"s_c\": 16,\n            \"P_cpu\": 5e11, \"B_cpu\": 1e11,\n            \"near_exec\": \"CPU\", \"far_exec\": \"CPU\"\n        },\n        # Case 2 (heterogeneous overlap: GPU far, CPU near)\n        {\n            \"grid\": (256, 256, 256), \"N\": 8000000, \"nu\": 8, \"s_c\": 16,\n            \"P_gpu\": 1.5e13, \"B_gpu\": 8.0e11,\n            \"P_cpu\": 5e11, \"B_cpu\": 1e11,\n            \"B_pcie\": 1.6e10,\n            \"near_exec\": \"CPU\", \"far_exec\": \"GPU\"\n        },\n        # Case 3 (GPU-only, near heavier than far)\n        {\n            \"grid\": (512, 512, 512), \"N\": 30000000, \"nu\": 30, \"s_c\": 16,\n            \"P_gpu\": 1.5e13, \"B_gpu\": 8.0e11,\n            \"near_exec\": \"GPU\", \"far_exec\": \"GPU\"\n        },\n        # Case 4 (small-grid boundary case, CPU-only)\n        {\n            \"grid\": (16, 16, 16), \"N\": 10000, \"nu\": 4, \"s_c\": 16,\n            \"P_cpu\": 2e11, \"B_cpu\": 5.0e10,\n            \"near_exec\": \"CPU\", \"far_exec\": \"CPU\"\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        results = calculate_performance(case)\n        # Format each number to 6 decimal places and create the sublist string\n        case_str_list = [f\"{val:.6f}\" for val in results]\n        sublist_str = f\"[{','.join(case_str_list)}]\"\n        all_results_str.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(all_results_str)}]]\")\n\nsolve()\n\n```"
        }
    ]
}