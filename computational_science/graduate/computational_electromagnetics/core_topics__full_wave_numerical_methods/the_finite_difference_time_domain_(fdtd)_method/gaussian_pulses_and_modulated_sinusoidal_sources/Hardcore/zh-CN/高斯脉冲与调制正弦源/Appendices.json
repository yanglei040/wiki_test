{
    "hands_on_practices": [
        {
            "introduction": "在计算电磁学中，高斯调制的正弦波（或称Gabor脉冲）是宽带时域仿真的常用激励源。在将任何源函数应用于数值求解器之前，理解其基本特性至关重要。本练习通过推导波峰因数（峰值与均方根值的比率），来量化脉冲的动态范围，该指标关联了信号峰值与总能量，对于确保仿真的数值稳定性和信噪比至关重要。",
            "id": "3310757",
            "problem": "在计算电磁学中用作宽带激励的高斯调制正弦源（Gabor脉冲）由以下实值波形定义：\n$$\ns(t) = \\exp\\!\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\!\\left(2\\pi f_{0} t\\right),\n$$\n其中 $f_{0}$ 是载波频率，$\\sigma$ 是高斯包络的时间标准差。考虑波峰因数（峰均方根比），其定义为峰值振幅与通过适用于有限能量脉冲的高斯窗时间平均计算出的均方根值之比：\n$$\nC = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}, \\quad s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}.\n$$\n仅从给定的定义和高斯函数的标准积分恒等式出发，推导波峰因数 $C$ 作为无量纲参数 $f_{0}\\sigma$ 的函数的精确闭式表达式。你的推导必须是自洽的，并且不得假设任何未经证明的中间公式。然后，利用你的结果，解释在时域求解器（如时域有限差分法，FDTD）中激励和记录场时，$C$ 对 $f_{0}\\sigma$ 的依赖关系如何影响所需的动态范围，包括对数值精度和稳定性的任何影响。\n\n你的最终答案应表示为仅含 $f_{0}\\sigma$ 的单个解析表达式。最终答案中不要包含单位。不需要进行数值近似。",
            "solution": "该问题是有效的，因为它在科学上基于信号处理和计算电磁学的原理，是适定的，提供了所有必要的定义，并以客观、正式的语言陈述。我们可以开始求解。\n\n该问题要求推导Gabor脉冲的波峰因数 $C$，并讨论其影响。Gabor脉冲由下式给出：\n$$s(t) = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right)$$\n波峰因数定义为\n$$C = \\frac{\\max_{t\\in\\mathbb{R}} |s(t)|}{s_{\\mathrm{rms}}}$$\n其中均方根值 $s_{\\mathrm{rms}}$ 由高斯窗平均定义：\n$$s_{\\mathrm{rms}} \\triangleq \\sqrt{\\frac{\\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t}}$$\n我们的推导将分两个主要步骤进行：计算峰值振幅 $\\max|s(t)|$ 和计算均方根值 $s_{\\mathrm{rms}}$。\n\n**第1步：计算峰值振幅**\n\n峰值振幅是 $|s(t)|$ 在所有 $t \\in \\mathbb{R}$ 上的最大值。\n$$|s(t)| = \\left| \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right| = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right) \\left|\\cos\\left(2\\pi f_{0} t\\right)\\right|$$\n项 $\\exp(-t^{2}/(2\\sigma^{2}))$ 是一个高斯函数，它在 $t=0$ 处有其唯一的最大值 $1$。对于任何 $t \\neq 0$，其值都严格小于 $1$。项 $|\\cos(2\\pi f_{0} t)|$ 是一个周期函数，最大值为 $1$。其中一个最大值出现在 $t=0$ 处。\n由于两项都在同一点 $t=0$ 处达到其最大值 $1$，它们的乘积也在此点达到其全局最大值。\n因此，峰值振幅为：\n$$\\max_{t\\in\\mathbb{R}} |s(t)| = |s(0)| = \\exp(0) \\cdot |\\cos(0)| = 1 \\cdot 1 = 1$$\n\n**第2步：计算均方根值**\n\n$s_{\\mathrm{rms}}$ 的计算需要求解两个积分。我们把分子中的积分记为 $I_{N}$，分母中的积分记为 $I_{D}$。\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{I_{N}}{I_{D}}}$$\n\n首先，我们计算分母积分 $I_{D}$：\n$$I_{D} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-at^{2}) \\mathrm{d}t = \\sqrt{\\pi/a}$。此处，$a=1/\\sigma^2$。\n$$I_{D} = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} = \\sqrt{\\pi\\sigma^{2}} = \\sigma\\sqrt{\\pi}$$\n\n接下来，我们计算分子积分 $I_{N}$：\n$$I_{N} = \\int_{-\\infty}^{\\infty} s^{2}(t)\\,\\mathrm{d}t = \\int_{-\\infty}^{\\infty} \\left[ \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right)\\cos\\left(2\\pi f_{0} t\\right) \\right]^{2} \\mathrm{d}t$$\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos^{2}\\left(2\\pi f_{0} t\\right)\\mathrm{d}t$$\n我们使用三角恒等式 $\\cos^{2}(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$。令 $\\theta = 2\\pi f_{0} t$。\n$$I_{N} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right) \\frac{1}{2}\\left[1 + \\cos\\left(4\\pi f_{0} t\\right)\\right]\\mathrm{d}t$$\n我们可以将其分成两个积分：\n$$I_{N} = \\frac{1}{2} \\left[ \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\mathrm{d}t + \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t \\right]$$\n第一个积分就是 $I_{D} = \\sigma\\sqrt{\\pi}$。第二个积分是高斯函数的傅里叶余弦变换。我们使用标准恒等式 $\\int_{-\\infty}^{\\infty} \\exp(-at^{2})\\cos(bt)\\mathrm{d}t = \\sqrt{\\pi/a} \\exp(-b^{2}/(4a))$。\n对于这个积分，我们有 $a=1/\\sigma^2$ 和 $b=4\\pi f_{0}$。\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{t^{2}}{\\sigma^{2}}\\right)\\cos\\left(4\\pi f_{0} t\\right)\\mathrm{d}t = \\sqrt{\\frac{\\pi}{1/\\sigma^{2}}} \\exp\\left(-\\frac{(4\\pi f_{0})^{2}}{4(1/\\sigma^{2})}\\right) = \\sigma\\sqrt{\\pi} \\exp\\left(-\\frac{16\\pi^{2}f_{0}^{2}\\sigma^{2}}{4}\\right)$$\n$$= \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right)$$\n将此结果代回 $I_{N}$ 的表达式中：\n$$I_{N} = \\frac{1}{2} \\left[ \\sigma\\sqrt{\\pi} + \\sigma\\sqrt{\\pi} \\exp\\left(-4\\pi^{2}f_{0}^{2}\\sigma^{2}\\right) \\right] = \\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n\n现在我们可以计算 $s_{\\mathrm{rms}}^{2}$：\n$$s_{\\mathrm{rms}}^{2} = \\frac{I_{N}}{I_{D}} = \\frac{\\frac{\\sigma\\sqrt{\\pi}}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]}{\\sigma\\sqrt{\\pi}} = \\frac{1}{2} \\left[ 1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right) \\right]$$\n取平方根得到 $s_{\\mathrm{rms}}$：\n$$s_{\\mathrm{rms}} = \\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}$$\n\n**第3步：推导波峰因数 C**\n\n最后，我们将峰值振幅和均方根值代入其定义中，求出波峰因数 $C$：\n$$C = \\frac{\\max|s(t)|}{s_{\\mathrm{rms}}} = \\frac{1}{\\sqrt{\\frac{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}{2}}} = \\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}$$\n这就是所要求的波峰因数 $C$ 作为无量纲参数 $f_{0}\\sigma$ 的函数的闭式表达式。\n\n**对时域求解器（例如，FDTD）影响的讨论**\n\n推导出的波峰因数表达式 $C(f_{0}\\sigma)$ 揭示了波形形状如何影响其作为计算求解器中源的数值特性。让我们分析参数 $f_{0}\\sigma$ 在两种极限情况下 $C$ 的行为，该参数表示高斯包络的有效持续时间内的载波周期数。\n\n1.  **低频或脉冲极限 ($f_{0}\\sigma \\to 0$)：**\n    当 $f_{0}\\sigma \\to 0$ 时，指数项 $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to \\exp(0) = 1$。\n    $$C \\to \\sqrt{\\frac{2}{1+1}} = \\sqrt{1} = 1$$\n    这对应于基带高斯脉冲（其中 $f_{0}=0$）。波峰因数为 $1$ 意味着峰值等于均方根值，这是直流（DC）信号的特征。对于给定的脉冲定义，$f_0=0$ 得到 $s(t) = \\exp(-t^2/(2\\sigma^2))$ 和 $s_{\\mathrm{rms}}=1$，从而 $C=1$。\n\n2.  **高频或窄带极限 ($f_{0}\\sigma \\gg 1$)：**\n    当 $f_{0}\\sigma \\to \\infty$ 时，指数项 $\\exp(-4\\pi^{2}(f_{0}\\sigma)^{2}) \\to 0$。\n    $$C \\to \\sqrt{\\frac{2}{1+0}} = \\sqrt{2}$$\n    这对应于一个由缓慢变化的高斯包络调制的正弦载波，包含许多周期。波峰因数接近 $\\sqrt{2}$，这正是一个理想的、未加窗的正弦波形（$\\cos(\\omega t)$）的波峰因数。\n\n关键的见解是，Gabor脉冲的波峰因数是有界的：$1 \\le C \\le \\sqrt{2}$。这对像FDTD这样的数值方法具有重要影响。\n\n在数值模拟中，**动态范围**指的是可表示的最大（非溢出）值与数值噪声基底（由舍入误差引起）之上的最小可辨别值之间的比率。源波形的选择必须适合此范围。\n- **峰值振幅**（$\\max|s(t)|$）决定了模拟中产生的最大场值。该峰值必须足够低以防止浮点溢出，否则会导致灾难性的不稳定性。\n- **均方根值**（$s_{\\mathrm{rms}}$）是有效振幅的度量，与脉冲的总能量有关。该值相对于机器精度必须足够大，以确保记录的场数据具有良好的信噪比（SNR），这些数据稍后将用于后处理（例如，通过傅里叶变换求S参数）。\n\n$C \\le \\sqrt{2}$ 这一事实非常理想。这意味着峰值振幅绝不会超过有效均方根振幅的约 $1.414$ 倍。这与其他可能具有非常高波峰因数的信号（例如，一串尖锐的脉冲）形成对比，后者与其总能量含量相比会有非常大的峰值。\n\n对于Gabor脉冲，可以将峰值振幅设置为一个安全的高值（例如，归一化为 $1$）以最大化注入的能量。由此产生的均方根值最差也为 $1/\\sqrt{2} \\approx 0.707$，这仍然是峰值的一个相当大的比例。这同时确保了高信噪比和低溢出风险。其波峰因数的良性和有界特性使Gabor脉冲成为FDTD和其他时域方法中用于宽带激励的一种数值上鲁棒且“友好”的源，有助于提高模拟的准确性和稳定性。",
            "answer": "$$\n\\boxed{\\sqrt{\\frac{2}{1 + \\exp\\left(-4\\pi^{2}(f_{0}\\sigma)^{2}\\right)}}}\n$$"
        },
        {
            "introduction": "从理想的数学表达式过渡到实际的数字系统实现，源信号的生成面临着离散时间和有限精度的挑战。本练习模拟了一个采用定点运算的直接数字频率合成器（DDS）来生成高斯脉冲的过程，旨在深入探讨相位截断和幅度量化所引入的误差。通过计算载噪比（CNR）、无杂散动态范围（SFDR）等频谱度量，您将能定量分析这些数字效应如何影响信号的频谱纯度。",
            "id": "3310693",
            "problem": "考虑一个在一维计算电磁学仿真中驱动电场振幅 $E(t)$ 的源。激励是一个高斯包络正弦波，在连续时间下由以下函数建模\n$$\nE_{\\mathrm{ideal}}(t) = E_0 \\exp\\!\\left(-\\frac{(t - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t\\right),\n$$\n其中 $E_0$ 是峰值电场振幅（单位为 $\\mathrm{V/m}$），$t_0$ 是脉冲中心时间（单位为 $\\mathrm{s}$），$\\sigma$ 是高斯标准差（单位为 $\\mathrm{s}$），$f_0$ 是载波频率（单位为 $\\mathrm{Hz}$）。角度单位为弧度。\n\n在实践中，$E(t)$ 由一个采样系统生成，该系统具有均匀的时间量化步长 $\\Delta t$（采样频率 $f_s = 1/\\Delta t$）和一个定点的直接数字频率合成 (DDS) 相位发生器。该 DDS 有一个 $M$ 位的相位累加器，并使用一个在 $[-1,1]$ 范围内具有 $B_{\\cos}$ 位均匀幅度量化的余弦查找表。高斯包络在 $[0,E_0]$ 范围内以 $B_{\\mathrm{env}}$ 位的均匀幅度量化实现。定义采样时间 $t_n = n \\Delta t$，其中整数 $n \\in \\{0,1,\\dots,N-1\\}$，并设置 $t_0 = \\frac{(N-1)\\Delta t}{2}$ 以将脉冲置于记录的中心。\n\nDDS 相位累加器使用一个整数频率控制字 $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$，产生离散相位序列\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}.\n$$\n令 $\\mathrm{Q}_{B_{\\cos}}(\\cdot)$ 表示在 $[-1,1]$ 范围内的 $B_{\\cos}$ 位均匀量化，令 $\\mathrm{Q}_{B_{\\mathrm{env}}}(\\cdot)$ 表示在 $[0,E_0]$ 范围内的 $B_{\\mathrm{env}}$ 位均匀量化。实现的离散时间源为\n$$\nE_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\\cdot \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right).\n$$\n\n您的任务是评估时间量化和有限精度对调制正弦波源的影响，并分析由定点运算引入的相位噪声及其对 $E(t)$ 频谱的影响。仅使用定义和第一性原理来构建您的算法。具体来说：\n\n1. 通过对连续时间表达式进行采样，构建理想的离散时间参考：\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right),\n$$\n使用浮点运算计算，除了在 $t_n$ 处的固有采样外，不进行任何量化。\n\n2. 构建误差序列\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n].\n$$\n\n3. 使用标准的复指数定义，计算 $E_{\\mathrm{float}}[n]$ 和 $e[n]$ 的单边离散傅里叶变换。将载波频点索引 $k_0$ 识别为非负频率点中其对应频率最接近 $f_0$ 的索引。定义载波频带为索引 $k \\in \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$，并裁剪至有效索引范围。\n\n4. 定义以下度量指标：\n   - 载噪比 (CNR)，单位为分贝：\n     $$\n     \\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right),\n     $$\n     其中 $X_{\\mathrm{float}}[k]$ 是 $E_{\\mathrm{float}}[n]$ 的单边离散傅里叶变换，$X_{e}[k]$ 是 $e[n]$ 的单边离散傅里叶变换，$\\mathcal{B}$ 是载波频带。分母中不包括直流 (DC) 频点 ($k=0$) 。\n   - 无杂散动态范围 (SFDR)，单位为分贝，计算公式为\n     $$\n     \\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right).\n     $$\n   - 均方根 (RMS) 相位误差，单位为弧度，在理想包络足够大的索引上计算（使用阈值标准 $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\ge 0.2 E_0$）：\n     使用希尔伯特变换获得 $E_{\\mathrm{quant}}[n]$ 的解析信号 $z_{\\mathrm{quant}}[n]$，并定义瞬时相位 $\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$。计算\n     $$\n     \\epsilon_\\phi[n] = \\hat{\\phi}[n] - \\left(2\\pi f_0 t_n + b\\right),\n     $$\n     其中 $b$ 是在阈值化索引上使均方误差最小化的常数，然后报告\n     $$\n     \\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_\\mathrm{thr}} \\sum_{n \\in \\mathcal{I}_\\mathrm{thr}} \\epsilon_\\phi[n]^2},\n     $$\n     其中 $\\mathcal{I}_\\mathrm{thr}$ 是满足阈值条件的索引集合，$N_\\mathrm{thr}$ 是其基数。\n\n所有角度必须以弧度为单位。所有时间必须以秒为单位。所有频率必须以赫兹为单位。电场振幅必须以伏特/米为单位。\n\n实现一个完整的、可运行的程序，对于下面测试套件中的每个测试用例，计算并按顺序 $\\left[\\mathrm{CNR}, \\mathrm{SFDR}, \\phi_{\\mathrm{rms}}\\right]$ 以浮点数形式返回上述度量指标。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按给定顺序连接所有测试用例的三元组结果。\n\n测试套件参数集 $(f_s, f_0, N, \\sigma, E_0, M, B_{\\cos}, B_{\\mathrm{env}})$：\n- 案例 A (理想情况)：$(10^9, 1.25\\times 10^8, 16384, 1.0\\times 10^{-7}, 1.0, 28, 14, 14)$。\n- 案例 B (在较高分数带宽附近的粗量化)：$(2.0\\times 10^8, 8.0\\times 10^7, 8192, 2.5\\times 10^{-7}, 1.0, 16, 10, 10)$。\n- 案例 C (DDS 无法精确表示的频率)：$(5.0\\times 10^8, 1.93333333333\\times 10^8, 8192, 1.2\\times 10^{-7}, 1.0, 12, 8, 8)$。\n- 案例 D (近似于稳态振幅的极宽广高斯包络)：$(10^9, 3.0\\times 10^8, 16384, 3.0\\times 10^{-6}, 1.0, 20, 12, 12)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\mathrm{CNR}_A,\\mathrm{SFDR}_A,\\phi_{\\mathrm{rms},A},\\mathrm{CNR}_B,\\mathrm{SFDR}_B,\\phi_{\\mathrm{rms},B},\\mathrm{CNR}_C,\\mathrm{SFDR}_C,\\phi_{\\mathrm{rms},C},\\mathrm{CNR}_D,\\mathrm{SFDR}_D,\\phi_{\\mathrm{rms},D}]$）。这些值必须是浮点数。$\\mathrm{CNR}$ 和 $\\mathrm{SFDR}$ 以分贝表示，$\\phi_{\\mathrm{rms}}$ 以弧度表示。",
            "solution": "用户提供了一个问题，要求对有限精度数字合成调制正弦波源所引入的误差进行定量分析。该问题具有科学依据，定义明确，并包含了唯一解所需的所有信息。我们将通过实现一个直接遵循指定步骤的算法来解决它。\n\n问题的核心是将高斯包络正弦波的理想浮点表示与实际的定点实现进行比较，并使用既定的信号处理度量指标来量化差异。该算法设计为四个主要阶段：信号生成、误差计算、频谱分析和度量评估。\n\n**1. 信号生成**\n\n首先，我们通过构建理想的离散时间参考信号 $E_{\\mathrm{float}}[n]$ 来建立一个基准。该信号是通过在离散时间点 $t_n = n \\Delta t$（其中 $\\Delta t = 1/f_s$ 是采样周期）对连续时间理想函数进行采样得到的。\n$$\nE_{\\mathrm{float}}[n] = E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right) \\cos\\!\\left(2 \\pi f_0 t_n\\right)\n$$\n通过设置 $t_0 = \\frac{(N-1)\\Delta t}{2}$，将脉冲置于 $N$ 个采样点的时间窗口中心。此参考信号的所有计算均使用标准的双精度浮点运算执行。\n\n接下来，我们对实际的量化信号 $E_{\\mathrm{quant}}[n]$ 进行建模。该模型包含了数字硬件中固有的两个主要误差来源：相位截断和幅度量化。\n\n相位由直接数字频率合成器 (DDS) 模型生成。DDS 使用一个 $M$ 位的相位累加器和一个频率控制字 $K$。$K$ 是所需归一化频率的最接近整数表示，由 $K = \\mathrm{round}\\!\\left(\\frac{f_0}{f_s} 2^M\\right)$ 给出。在每个时间步 $n$，相位累加器的值增加 $K$，并对结果取模 $2^M$。得到的离散相位序列是：\n$$\n\\phi[n] = \\left( (n K) \\bmod 2^M \\right)\\cdot \\frac{2\\pi}{2^M}\n$$\n这里的“取模”运算是相位截断误差的来源，表现为相位噪声。该相位的余弦值 $\\cos(\\phi[n])$ 随后在 $[-1, 1]$ 范围内被量化为 $B_{\\cos}$ 位。\n\n高斯包络 $E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)$ 在 $[0, E_0]$ 范围内被独立量化为 $B_{\\mathrm{env}}$ 位。\n\n我们定义一个通用的均匀量化函数 $\\mathrm{Q}_B(x; x_{\\min}, x_{\\max})$，它将一个值 $x$ 映射到在 $[x_{\\min}, x_{\\max}]$ 范围内均匀分布的 $2^B$ 个离散电平之一。步长为 $\\Delta = (x_{\\max} - x_{\\min}) / (2^B - 1)$。该函数实现为：\n$$\n\\mathrm{Q}_B(x) = x_{\\min} + \\mathrm{round}\\left(\\frac{x - x_{\\min}}{\\Delta}\\right) \\Delta\n$$\n使用此函数，量化后的分量为：\n$$\n\\text{envelope}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\mathrm{env}}}\\!\\left(E_0 \\exp\\!\\left(-\\frac{(t_n - t_0)^2}{2 \\sigma^2}\\right)\\right)\n$$\n$$\n\\text{carrier}_{\\mathrm{quant}}[n] = \\mathrm{Q}_{B_{\\cos}}\\!\\left(\\cos(\\phi[n])\\right)\n$$\n最终的量化信号是这两个分量的乘积：\n$$\nE_{\\mathrm{quant}}[n] = \\text{envelope}_{\\mathrm{quant}}[n] \\cdot \\text{carrier}_{\\mathrm{quant}}[n]\n$$\n\n**2. 误差信号与频谱分析**\n\n由数字合成过程引入的总误差由误差序列 $e[n]$ 捕获，其定义为量化信号与理想信号之间的逐样本差值：\n$$\ne[n] = E_{\\mathrm{quant}}[n] - E_{\\mathrm{float}}[n]\n$$\n为了分析信号和误差的特性，我们计算它们的离散傅里叶变换 (DFT)，分别表示为 $X_{\\mathrm{float}}[k]$ 和 $X_{e}[k]$。我们使用标准的未缩放 DFT 定义：$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp(-j 2\\pi nk/N)$。分析在单边频谱上进行，仅考虑非负频率点，对应于索引 $k \\in \\{0, 1, \\dots, N/2\\}$。\n\n定义一个载波频带 $\\mathcal{B}$ 来隔离所需信号的功率。它包括最接近载波频率 $f_0$ 的频率点 $k_0$，以及其四个最近的邻居：$\\mathcal{B} = \\{k_0-2, k_0-1, k_0, k_0+1, k_0+2\\}$，并裁剪到有效的非负频率索引范围内。这里，$k_0 = \\mathrm{round}(f_0 N / f_s)$。\n\n**3. 性能度量指标**\n\n计算出频谱后，我们评估三个指定的性能度量指标。\n\n**载噪比 (CNR):** 该指标衡量所需信号频带内的总功率与该频带外误差信号总功率之比。它提供了信号质量的全局度量。我们在噪声计算中排除了直流分量 ($k=0$) 。\n$$\n\\mathrm{CNR} = 10 \\log_{10}\\!\\left(\\frac{\\sum_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\sum_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right)\n$$\n\n**无杂散动态范围 (SFDR):** 该指标给出了载波频带中最强分量的功率与误差频谱中最强非期望分量（杂散）功率之比。对于关注杂散音调干扰的系统来说，这是一个关键的度量。\n$$\n\\mathrm{SFDR} = 10 \\log_{10}\\!\\left(\\frac{\\max_{k \\in \\mathcal{B}} |X_{\\mathrm{float}}[k]|^2}{\\max_{k \\notin \\mathcal{B},\\, k>0} |X_{e}[k]|^2}\\right)\n$$\n对于 CNR 和 SFDR，在分母中加入一个小的 epsilon 值，以防止在高精度情况下因数值误差可忽略而导致的除零错误。\n\n**均方根 (RMS) 相位误差:** 该指标专门量化相位噪声。它仅在脉冲中信号较强的部分进行计算，该部分由理想包络振幅超过其峰值 $20\\%$ 的条件定义，即 $E_0 \\exp(-\\frac{(t_n-t_0)^2}{2\\sigma^2}) \\ge 0.2 E_0$。令满足此条件的索引集合为 $\\mathcal{I}_{\\mathrm{thr}}$。\n\n首先，我们使用希尔伯特变换计算 $E_{\\mathrm{quant}}[n]$ 的解析信号，$z_{\\mathrm{quant}}[n] = E_{\\mathrm{quant}}[n] + j\\mathcal{H}\\{E_{\\mathrm{quant}}[n]\\}$。然后提取瞬时相位并进行解卷绕以使其连续：$\\hat{\\phi}[n] = \\mathrm{unwrap}(\\arg(z_{\\mathrm{quant}}[n]))$。\n\n相位误差 $\\epsilon_\\phi[n]$ 是测得的相位与理想线性相位斜坡 $2\\pi f_0 t_n$ 之间的差值，在移除了任何恒定相位偏移 $b$ 之后。选择偏移量 $b$ 以最小化阈值化索引上的均方误差，这对应于该区域相位差的均值：$b = \\frac{1}{N_{\\mathrm{thr}}}\\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} (\\hat{\\phi}[n] - 2\\pi f_0 t_n)$。相位误差则为 $\\epsilon_\\phi[n] = (\\hat{\\phi}[n] - 2\\pi f_0 t_n) - b$。\n\n最后，RMS 相位误差是阈值化区域内相位误差平方的均值的平方根：\n$$\n\\phi_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N_{\\mathrm{thr}}} \\sum_{n \\in \\mathcal{I}_{\\mathrm{thr}}} \\epsilon_\\phi[n]^2}\n$$\n其中 $N_{\\mathrm{thr}}$ 是 $\\mathcal{I}_{\\mathrm{thr}}$ 中的索引数量。此过程稳健地量化了由 DDS 和量化引入的相位抖动，且与任何固定的相位偏移无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem solution.\n    It iterates through test cases, computes metrics, and prints the final result.\n    \"\"\"\n\n    def quantize(x, min_val, max_val, num_bits):\n        \"\"\"\n        Performs uniform amplitude quantization.\n        \n        Args:\n            x (np.ndarray): The input signal to be quantized.\n            min_val (float): The minimum value of the quantization range.\n            max_val (float): The maximum value of the quantization range.\n            num_bits (int): The number of bits for quantization.\n\n        Returns:\n            np.ndarray: The quantized signal.\n        \"\"\"\n        num_levels = 2**num_bits\n        if num_levels == 1:\n            return np.full_like(x, (min_val + max_val) / 2.0)\n        \n        delta = (max_val - min_val) / (num_levels - 1)\n        if delta == 0:\n            return np.full_like(x, min_val)\n            \n        quantized_indices = np.round((x - min_val) / delta)\n        quantized_values = min_val + quantized_indices * delta\n        \n        return np.clip(quantized_values, min_val, max_val)\n\n    def compute_metrics(fs, f0, N, sigma, E0, M, B_cos, B_env):\n        \"\"\"\n        Computes CNR, SFDR, and RMS phase error for a given parameter set.\n        \"\"\"\n        # 1. Setup time vector and pulse center\n        dt = 1.0 / fs\n        t = np.arange(N, dtype=np.float64) * dt\n        t0 = (N - 1) * dt / 2.0\n\n        # 2. Generate E_float (ideal discrete-time reference)\n        time_exp_term = (t - t0)**2\n        gaussian_envelope_ideal = E0 * np.exp(-time_exp_term / (2.0 * sigma**2))\n        carrier_ideal = np.cos(2.0 * np.pi * f0 * t)\n        E_float = gaussian_envelope_ideal * carrier_ideal\n\n        # 3. Generate E_quant (realized discrete-time source)\n        # DDS phase generation\n        K = np.round((f0 / fs) * (2**M))\n        n_indices = np.arange(N, dtype=np.int64)\n        phase_accumulator = (n_indices * K) % (2**M)\n        phi_dds = phase_accumulator * (2.0 * np.pi / (2**M))\n        \n        # Quantized carrier from cosine lookup\n        carrier_unquantized = np.cos(phi_dds)\n        carrier_quantized = quantize(carrier_unquantized, -1.0, 1.0, B_cos)\n\n        # Quantized envelope\n        envelope_quantized = quantize(gaussian_envelope_ideal, 0.0, E0, B_env)\n        \n        E_quant = envelope_quantized * carrier_quantized\n\n        # 4. Form error sequence\n        e = E_quant - E_float\n\n        # 5. Perform spectral analysis\n        X_float = np.fft.fft(E_float)\n        X_e = np.fft.fft(e)\n        \n        # Use one-sided spectrum for analysis (non-negative frequencies)\n        num_freq_bins = N // 2 + 1\n        X_float_one_sided = X_float[:num_freq_bins]\n        X_e_one_sided = X_e[:num_freq_bins]\n\n        # Define carrier band\n        freq_res = fs / N\n        k0 = int(np.round(f0 / freq_res))\n        carrier_band_indices = np.arange(max(0, k0 - 2), min(num_freq_bins, k0 + 3))\n\n        # 6. Calculate performance metrics\n        epsilon = 1e-30  # Small value to prevent log(0) or division by zero\n\n        # CNR calculation\n        signal_power = np.sum(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        all_positive_indices = np.arange(1, num_freq_bins)\n        noise_indices = np.setdiff1d(all_positive_indices, carrier_band_indices, assume_unique=True)\n        noise_power = np.sum(np.abs(X_e_one_sided[noise_indices])**2)\n        cnr = 10.0 * np.log10(signal_power / (noise_power + epsilon))\n\n        # SFDR calculation\n        peak_signal_power = np.max(np.abs(X_float_one_sided[carrier_band_indices])**2)\n        if noise_indices.size == 0:\n            peak_spur_power = 0.0\n        else:\n            peak_spur_power = np.max(np.abs(X_e_one_sided[noise_indices])**2)\n        sfdr = 10.0 * np.log10(peak_signal_power / (peak_spur_power + epsilon))\n\n        # RMS phase error calculation\n        threshold = 0.2 * E0\n        thr_indices = np.where(gaussian_envelope_ideal >= threshold)[0]\n        \n        phi_rms = 0.0\n        if thr_indices.size > 0:\n            z_quant = signal.hilbert(E_quant)\n            inst_phase_quant = np.unwrap(np.angle(z_quant))\n            ideal_phase_ramp = 2.0 * np.pi * f0 * t\n            phase_diff = inst_phase_quant - ideal_phase_ramp\n            \n            # Remove constant phase offset by subtracting the mean\n            b = np.mean(phase_diff[thr_indices])\n            phase_error = phase_diff - b\n\n            phi_rms = np.sqrt(np.mean(phase_error[thr_indices]**2))\n\n        return cnr, sfdr, phi_rms\n\n    test_cases = [\n        # (fs, f0, N, sigma, E0, M, B_cos, B_env)\n        (1e9, 1.25e8, 16384, 1.0e-7, 1.0, 28, 14, 14),\n        (2.0e8, 8.0e7, 8192, 2.5e-7, 1.0, 16, 10, 10),\n        (5.0e8, 1.93333333333e8, 8192, 1.2e-7, 1.0, 12, 8, 8),\n        (1.0e9, 3.0e8, 16384, 3.0e-6, 1.0, 20, 12, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters: all are floats except N, M, B_cos, B_env\n        fs, f0, N_int, sigma, E0, M_int, B_cos_int, B_env_int = case\n        cnr, sfdr, phi_rms = compute_metrics(\n            fs, f0, int(N_int), sigma, E0, int(M_int), int(B_cos_int), int(B_env_int)\n        )\n        results.extend([cnr, sfdr, phi_rms])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "源的选择，特别是其带宽，对整个仿真算法的计算成本有着深远的影响。本练习将指导您建立理论模型，分析源带宽如何决定两种主流时域算法——伪谱时域（PSTD）法和包含辅助微分方程的有限差分时域（ADE-FDTD）法的计算工作量。通过这项实践，您将揭示支配不同算法性能的基本缩放定律，从而为特定问题选择最高效的仿真策略提供依据。",
            "id": "3310734",
            "problem": "必须设计一个高斯调制正弦源的一维时域电磁仿真，以生成宽带激励，并为两类求解器的算法工作负载进行基准测试：使用快速傅里叶变换 (FFT) 的伪谱时域 (PSTD) 方法，以及针对单极点德拜色散并使用辅助微分方程 (ADE) 的时域有限差分 (FDTD) 方法。其目标是，在选择离散化以解析脉冲的最高有效频率分量的情况下，量化总计算工作负载如何随源带宽扩展。该问题必须从波传播和采样约束的第一性原理出发进行求解，并且算法工作负载必须根据基本运算计数来定义，而不依赖于经验计时。\n\n假设一个长度为 $L$、光速为 $c$ 的一维真空域，以及一个形式为 $s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$ 的时域源，其中心频率为 $f_{0}$，时间标准差为 $\\sigma_{t}$。根据傅里叶分析，该高斯调制正弦波的正频率谱是以 $f_{0}$ 为中心、标准差为 $\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}$ 的高斯分布。为确保频谱截断可忽略不计，将最大设计频率定义为 $f_{\\max} = f_{0} + m\\,\\sigma_{f}$，其中 $m$ 为一固定值。离散化必须满足时域电磁学中两个标准约束：每个最小波长的最小空间点数，以及对时间步长的库朗稳定性限制。具体来说，设最小可分辨波长为 $\\lambda_{\\min} = \\frac{c}{f_{\\max}}$，强制每个 $\\lambda_{\\min}$ 有 $p$ 个点，因此 $\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}$，并选择时间步长 $\\Delta t = S \\frac{\\Delta x}{c}$，其中库朗数 $S \\in (0,1)$。考虑总仿真时间窗口 $T_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}$，其中 $q$ 是时间标准差的一个固定倍数，其选择旨在基本上捕获所有脉冲能量以及脉冲穿过整个域的传播时间。设空间采样点数为 $N = \\lceil \\frac{L}{\\Delta x} \\rceil$，时间步数为 $N_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil$，FFT 网格大小为 $N_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}$（不小于 $N$ 的最小2的幂），以增加 FFT 工作负载。\n\n定义一个运算计数模型，其中一个运算单元等于一次浮点加法或乘法。对于 PSTD 求解器，将每个时间步建模为完成固定数量的长度为 $N_{\\text{fft}}$ 的复数 FFT；假设每个时间步有 $n_{\\text{fft}}$ 次此类变换，并且一次长度为 $N_{\\text{fft}}$ 的复数 FFT 耗费 $k_{\\text{fft}}\\,N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$ 个运算单元。因此，PSTD 的总工作负载是每步 FFT 成本与总步数的乘积。对于具有单极点德拜极化的 ADE-FDTD 求解器，将每个单元、每个时间步的工作负载建模为常数 $k_{\\text{cell}}$ 个运算单元，这包括一次磁场更新、一次极化更新和一次电场更新。因此，ADE-FDTD 的总工作负载是每个单元的成本乘以 $N$ 和 $N_{t}$。\n\n所有物理常数和建模参数均被视为给定常数：\n- 光速：$c = 299792458$（单位 $\\text{m/s}$）。\n- 域长度：$L = 1.0$（单位 $\\text{m}$）。\n- 每个最小波长的点数：$p = 12$。\n- 频谱截断倍数：$m = 4$。\n- 库朗数：$S = 0.99$。\n- 时间窗口倍数：$q = 6$。\n- FFT 成本系数：$k_{\\text{fft}} = 5$。\n- PSTD 中每个时间步的复数 FFT 数量：$n_{\\text{fft}} = 4$。\n- ADE-FDTD 每个单元的成本：$k_{\\text{cell}} = 12$。\n\n使用这些常数和上述定义，为测试套件中的每个测试用例计算以下内容：\n- PSTD 的总工作负载 $W_{\\text{PSTD}}$（以运算单元为单位）。\n- ADE-FDTD 的总工作负载 $W_{\\text{ADE}}$（以运算单元为单位）。\n\n此外，在整个测试套件上，通过在对数-对数尺度上进行最小二乘拟合来计算两个缩放指数：\n- $\\log W_{\\text{PSTD}}$ 相对于 $\\log f_{\\max}$ 的斜率 $s_{\\text{PSTD}}$。\n- $\\log W_{\\text{ADE}}$ 相对于 $\\log f_{\\max}$ 的斜率 $s_{\\text{ADE}}$。\n\n测试套件包含四个用例，所有单位都已明确指定：\n1. 用例 A（中等宽带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.0000000005$ (单位 $\\text{s}$)。\n2. 用例 B（强宽带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.00000000005$ (单位 $\\text{s}$)。\n3. 用例 C（超宽带，基带高斯）：$f_{0} = 0$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.00000000002$ (单位 $\\text{s}$)。\n4. 用例 D（窄带，调制）：$f_{0} = 3000000000$ (单位 $\\text{Hz}$)，$\\sigma_{t} = 0.000000005$ (单位 $\\text{s}$)。\n\n您的程序必须按照 A、B、C、D 的顺序，使用上述定义和常数计算每个用例的工作负载对 $\\left(W_{\\text{PSTD}}, W_{\\text{ADE}}\\right)$。然后使用所有四个用例计算两个斜率 $s_{\\text{PSTD}}$ 和 $s_{\\text{ADE}}$。将工作负载报告为整数（运算单元），斜率报告为四舍五入到三位小数的十进制数。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，结果按以下顺序排列：\n$\\left[W_{\\text{PSTD}}^{(A)}, W_{\\text{ADE}}^{(A)}, W_{\\text{PSTD}}^{(B)}, W_{\\text{ADE}}^{(B)}, W_{\\text{PSTD}}^{(C)}, W_{\\text{ADE}}^{(C)}, W_{\\text{PSTD}}^{(D)}, W_{\\text{ADE}}^{(D)}, s_{\\text{PSTD}}, s_{\\text{ADE}}\\right]$。\n所有工作负载都是无单位的运算计数；输出不需要物理单位，也不出现角度。斜率必须表示为小数（而非百分比）。",
            "solution": "该问题要求计算电磁学中两种数值方法——伪谱时域 (PSTD) 和带辅助微分方程的时域有限差分 (ADE-FDTD)——在不同源条件下的计算工作负载。此外，它还要求分析这些工作负载如何随源的最大频率分量扩展。解决方案是根据指定的波理论、数值离散化和算法复杂度分析的第一性原理推导出来的。\n\n该过程首先根据每个测试用例给定的物理源参数计算必要的仿真参数。\n源是一个高斯调制正弦波，$s(t) = \\exp\\!\\left(-\\frac{(t-t_{0})^{2}}{2\\sigma_{t}^{2}}\\right)\\cos(2\\pi f_{0} t)$，其中心频率为 $f_{0}$，时间标准差为 $\\sigma_{t}$。其频谱特性决定了仿真要求。脉冲在频域中频谱的标准差 $\\sigma_{f}$ 与其时间标准差成反比：\n$$\n\\sigma_{f} = \\frac{1}{2\\pi\\sigma_{t}}\n$$\n为准确捕获脉冲的能量，仿真必须解析高达最大设计频率 $f_{\\max}$ 的频率。该频率通过从中心频率扩展频谱标准差的 $m$ 倍来定义：\n$$\nf_{\\max} = f_{0} + m\\,\\sigma_{f}\n$$\n确定 $f_{\\max}$ 后，我们可以确定所需的空间和时间离散化。为使数值方法稳定且准确，其网格必须能解析存在的最小波长 $\\lambda_{\\min} = c/f_{\\max}$。空间步长 $\\Delta x$ 被设为该最小波长的一小部分，由参数 $p$（每波长点数）控制：\n$$\n\\Delta x = \\frac{\\lambda_{\\min}}{p} = \\frac{c}{p\\,f_{\\max}}\n$$\n然后，通过将域长度 $L$ 除以 $\\Delta x$ 并取上整来找到总空间网格点数 $N$，以确保覆盖整个域：\n$$\nN = \\left\\lceil \\frac{L}{\\Delta x} \\right\\rceil = \\left\\lceil \\frac{L\\,p\\,f_{\\max}}{c} \\right\\rceil\n$$\n时间步长 $\\Delta t$ 受到 Courant-Friedrichs-Lewy (CFL) 稳定性条件的约束。它通过库朗数 $S$ 与 $\\Delta x$ 相关：\n$$\n\\Delta t = S \\frac{\\Delta x}{c} = S \\frac{1}{p\\,f_{\\max}}\n$$\n总仿真时长 $T_{\\text{tot}}$ 必须足够长，以使波能够传播穿过整个域（时间为 $L/c$），并让脉冲时间包络的重要部分通过，这部分时间被估计为 $\\sigma_{t}$ 的 $q$ 倍：\n$$\nT_{\\text{tot}} = \\frac{L}{c} + q\\,\\sigma_{t}\n$$\n总时间步数 $N_{t}$ 则是总时长除以时间步长，同样取上整：\n$$\nN_{t} = \\left\\lceil \\frac{T_{\\text{tot}}}{\\Delta t} \\right\\rceil = \\left\\lceil \\left(\\frac{L}{c} + q\\,\\sigma_{t}\\right) \\frac{p\\,f_{\\max}}{S} \\right\\rceil\n$$\n对于依赖快速傅里叶变换 (FFT) 的 PSTD 方法，当网格大小是2的幂时，性能最佳。因此，用于 FFT 的计算网格大小 $N_{\\text{fft}}$ 被定义为不小于 $N$ 的最小2的幂：\n$$\nN_{\\text{fft}} = 2^{\\lceil \\log_{2} N \\rceil}\n$$\n推导出这些数值参数（$N, N_{t}, N_{\\text{fft}}$）后，我们可以应用给定的运算计数模型来计算工作负载。\nPSTD 工作负载 $W_{\\text{PSTD}}$ 被建模为总时间步数 $N_t$ 乘以每个时间步的成本。每步的成本由 FFT 的数量 $n_{\\text{fft}}$、成本系数 $k_{\\text{fft}}$ 以及大小为 $N_{\\text{fft}}$ 的单次 FFT 的复杂度（即 $N_{\\text{fft}} \\log_{2} N_{\\text{fft}}$）决定：\n$$\nW_{\\text{PSTD}} = N_{t} \\cdot n_{\\text{fft}} \\cdot k_{\\text{fft}} \\cdot N_{\\text{fft}} \\log_{2} N_{\\text{fft}}\n$$\nADE-FDTD 工作负载 $W_{\\text{ADE}}$ 是一个更简单的计算量模型。它是每个单元更新成本 $k_{\\text{cell}}$、空间单元数 $N$ 和时间步数 $N_t$ 的乘积：\n$$\nW_{\\text{ADE}} = k_{\\text{cell}} \\cdot N \\cdot N_{t}\n$$\n最后，为分析这些工作负载相对于最大频率的缩放特性，我们假设存在一个幂律关系 $W \\propto (f_{\\max})^s$。对两边取对数得到 $\\log W = s \\log f_{\\max} + \\log(\\text{constant})$，这是一个线性方程。缩放指数 $s$ 是对每个测试用例 $i$ 的数据点 $(\\log f_{\\max}^{(i)}, \\log W^{(i)})$ 进行最佳拟合直线的斜率。该斜率使用标准的线性最小二乘回归计算。对于一组点 $(x_i, y_i)$，斜率 $s$ 的公式为：\n$$\ns = \\frac{\\sum (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum (x_i - \\bar{x})^2}\n$$\n其中 $x_i = \\log f_{\\max}^{(i)}$ 且 $y_i = \\log W^{(i)}$。此过程分别应用于 $W_{\\text{PSTD}}$ 和 $W_{\\text{ADE}}$ 的数据集，以求得指数 $s_{\\text{PSTD}}$ 和 $s_{\\text{ADE}}$。\n\n提供的常数为：$c = 299792458$，$L=1.0$，$p=12$，$m=4$，$S=0.99$，$q=6$，$k_{\\text{fft}}=5$，$n_{\\text{fft}}=4$ 和 $k_{\\text{cell}}=12$。将这些值以及每个测试用例的参数代入上述公式中，以计算最终结果。所有工作负载结果都将转换为整数，斜率按要求四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics workload problem.\n\n    This function calculates the computational workloads for PSTD and ADE-FDTD methods\n    for a set of test cases involving Gaussian-modulated sinusoidal sources. It then\n    computes the scaling exponents of these workloads with respect to the maximum\n    simulation frequency using a log-log linear least-squares fit.\n    \"\"\"\n\n    # Define physical constants and modeling parameters.\n    c = 299792458       # Speed of light in m/s\n    L = 1.0             # Domain length in m\n    p = 12              # Points per minimum wavelength\n    m = 4               # Spectral truncation multiple\n    S = 0.99            # Courant number\n    q = 6               # Time-window multiple\n    k_fft = 5           # FFT cost coefficient\n    n_fft = 4           # Number of complex FFTs per time step in PSTD\n    k_cell = 12         # ADE-FDTD per-cell cost\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f0 in Hz, sigma_t in s)\n        (3.0e9, 5.0e-10),  # Case A\n        (3.0e9, 5.0e-11),  # Case B\n        (0.0,   2.0e-11),  # Case C\n        (3.0e9, 5.0e-9),   # Case D\n    ]\n\n    results = []\n    log_fmax_list = []\n    log_w_pstd_list = []\n    log_w_ade_list = []\n\n    for f0, sigma_t in test_cases:\n        # Step 1: Calculate maximum frequency\n        sigma_f = 1 / (2 * np.pi * sigma_t)\n        f_max = f0 + m * sigma_f\n\n        # Step 2: Calculate discretization parameters\n        delta_x = c / (p * f_max)\n        delta_t = S / (p * f_max) # This is equivalent to S * delta_x / c\n\n        # Step 3: Calculate grid and time dimensions\n        N = int(np.ceil(L / delta_x))\n        T_tot = L / c + q * sigma_t\n        N_t = int(np.ceil(T_tot / delta_t))\n\n        # Step 4: Calculate FFT grid size\n        if N == 0:\n            log2_N_ceil = 0\n        elif N == 1:\n            log2_N_ceil = 0\n        else:\n            log2_N_ceil = int(np.ceil(np.log2(N)))\n        N_fft = 1  log2_N_ceil # Efficient way to compute 2^log2_N_ceil\n\n        # Step 5: Calculate workloads\n        W_pstd = N_t * n_fft * k_fft * N_fft * log2_N_ceil\n        W_ade = k_cell * N * N_t\n        \n        results.extend([int(W_pstd), int(W_ade)])\n\n        # Step 6: Store log values for regression\n        log_fmax_list.append(np.log(f_max))\n        # Add a small epsilon to workloads that could be zero to avoid log(0)\n        # In this problem, workloads are guaranteed to be positive.\n        log_w_pstd_list.append(np.log(W_pstd))\n        log_w_ade_list.append(np.log(W_ade))\n\n    # Step 7: Compute scaling exponents using least-squares fit on log-log data\n    # np.polyfit(x, y, 1) returns [slope, intercept] for the best-fit line.\n    slope_pstd, _ = np.polyfit(log_fmax_list, log_w_pstd_list, 1)\n    slope_ade, _ = np.polyfit(log_fmax_list, log_w_ade_list, 1)\n\n    results.extend([round(slope_pstd, 3), round(slope_ade, 3)])\n    \n    # Final print statement in the exact required format.\n    # Convert all numbers to string before joining\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}