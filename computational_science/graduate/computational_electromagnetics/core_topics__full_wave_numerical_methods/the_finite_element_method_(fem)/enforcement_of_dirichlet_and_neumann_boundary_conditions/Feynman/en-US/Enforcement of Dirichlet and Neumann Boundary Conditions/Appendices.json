{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of boundary condition enforcement, we begin with a foundational technique in the simplest context: the method of ghost cells applied to a one-dimensional problem. This practice guides you through the analytical derivation of a second-order accurate Neumann boundary condition from Taylor series expansions. By implementing a finite difference solver for both the Helmholtz and diffusion equations, you will gain direct, hands-on experience in how these theoretical constructs are translated into code and how their accuracy can be verified against a known solution .",
            "id": "3305488",
            "problem": "Consider the one-dimensional scalar boundary-value problems on the interval $[0,L]$ with a uniform grid of $N$ intervals and grid spacing $h = L/N$, with grid nodes $x_i = ih$ for $i = 0,1,\\dots,N$. The primary goal is to implement the enforcement of a Neumann boundary condition at the left boundary $x=0$ using ghost cells, and to derive an equivalent second-order accurate one-sided boundary stencil that enforces the normal derivative condition $\\partial_n u = g$ at the boundary $\\partial \\Omega$. All angles in trigonometric functions must be interpreted in radians.\n\nYou will start from the following foundational facts:\n- The scalar Helmholtz equation in one dimension is $u''(x) + k^2 u(x) = s(x)$, where $k$ is a given wavenumber and $s(x)$ is a known source.\n- The scalar steady diffusion (Poisson) equation in one dimension (with unit conductivity) is $-u''(x) = f(x)$, where $f(x)$ is a known source.\n- A second-order accurate central difference approximation to the second derivative is $u''(x_i) \\approx \\left(u_{i-1} - 2 u_i + u_{i+1}\\right)/h^2$ for interior points.\n- A Neumann boundary condition at the left boundary is $u'(0) = g$, i.e., $\\partial_n u = g$ with outward normal along $-x$ at $x=0$ for a one-dimensional interval, which here is equivalent to $u'(0) = g$.\n\nTasks:\n- Derive, from Taylor expansions about $x=0$, a second-order accurate ghost cell relation that enforces $u'(0) = g$ when combined with the standard three-point second-order interior stencil for either the Helmholtz or diffusion operator. Introduce a ghost node $u_{-1}$ located at $x=-h$ and derive a relation for $u_{-1}$ in terms of $u_1$, $g$, and $h$ suitable for second-order accurate enforcement of $u'(0)=g$.\n- Derive, independently from Taylor expansions, a second-order accurate one-sided boundary stencil for $u'(0)$ expressed in terms of $u_0$, $u_1$, and $u_2$ and $h$, that enforces $u'(0)=g$ at $x=0$.\n- Show how the ghost-cell relation modifies the leftmost discrete equation for each operator:\n  - For the Helmholtz operator, using $u_{-1}$ in the discrete equation at $i=0$ yields a modified equation of the form $a_{00} u_0 + a_{01} u_1 = b_0$ where $a_{00}$, $a_{01}$, and $b_0$ must be expressed in terms of $h$, $k$, $s(0)$, and $g$.\n  - For the diffusion operator, using $u_{-1}$ in the discrete equation at $i=0$ yields a modified equation of the form $a_{00} u_0 + a_{01} u_1 = b_0$ where $a_{00}$, $a_{01}$, and $b_0$ must be expressed in terms of $h$, $f(0)$, and $g$.\n- Implement a solver that assembles and solves the linear system with:\n  - The Helmholtz or diffusion interior operator discretized with second-order central differences for $i=1,2,\\dots,N-1$.\n  - The Neumann boundary at $i=0$ enforced via the ghost-cell relation derived above and substituted into the discrete equation at $i=0$.\n  - A Dirichlet boundary condition at $x=L$ enforced by setting $u_N = u(L)$, using a known exact solution $u(x)$ to define this boundary value. This avoids singularity for the diffusion problem and ensures a unique discrete solution.\n\nUse the following test suite of parameter sets. For each test case you must compute the solution vector $\\{u_i\\}_{i=0}^N$ and report a scalar quantity as specified.\n\n- Test case $1$ (Helmholtz, happy path): $L=1$, $N=64$, $k=3$, exact solution $u(x) = \\cos(2 x) + 0.1 x$, source defined by $s(x) = u''(x) + k^2 u(x)$, Neumann data $g = u'(0)$, Dirichlet data $u(L)$ from the exact solution. Report the discrete $L^2$ error norm $\\left(\\,h\\sum_{i=0}^N \\left(u_i - u(x_i)\\right)^2\\,\\right)^{1/2}$ as a floating-point number.\n- Test case $2$ (Helmholtz, coarse grid to probe discretization): $L=1$, $N=8$, $k=3$, same exact solution and source as in test case $1$, same boundary data. Report the discrete $L^2$ error norm.\n- Test case $3$ (Diffusion, mixed boundary conditions): $L=1$, $N=64$, exact solution $u(x) = \\sin(\\pi x) + x$, source defined by $f(x) = -u''(x)$, Neumann data $g = u'(0)$, Dirichlet data $u(L)$ from the exact solution. Report the discrete $L^2$ error norm.\n- Test case $4$ (Helmholtz, homogeneous source and homogeneous Neumann at $x=0$): $L=1$, $N=32$, $k=2$, exact solution $u(x) = \\cos(2 x)$ so that $s(x) \\equiv 0$, $g = u'(0) = 0$, Dirichlet data $u(L)$ from the exact solution. Report the absolute boundary derivative enforcement error $\\left|\\,(-3 u_0 + 4 u_1 - u_2)/(2 h) - g\\,\\right|$ computed from the numerical solution, using the derived second-order one-sided stencil.\n\nImplementation details and requirements:\n- Use a single uniform grid with nodes $x_i = ih$ for $i=0,1,\\dots,N$.\n- For interior points $i=1,2,\\dots,N-1$:\n  - Helmholtz: discretize $u''(x_i) + k^2 u(x_i) = s(x_i)$ by $\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)/h^2 + k^2 u_i = s(x_i)$.\n  - Diffusion: discretize $-u''(x_i) = f(x_i)$ by $\\left(-u_{i-1} + 2 u_i - u_{i+1}\\right)/h^2 = f(x_i)$.\n- At the left boundary $i=0$, enforce $u'(0)=g$ by eliminating the ghost $u_{-1}$ via your derived ghost-cell relation and substituting into the discrete operator equation at $i=0$.\n- At the right boundary $i=N$, enforce $u_N = u(L)$ exactly as a Dirichlet condition.\n- Compute and report the scalar outputs precisely as specified for each test.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\").\n\nAll outputs are non-dimensional numbers. Angles in trigonometric functions must be interpreted in radians. The final outputs must be floating-point numbers. The program must not require any inputs and must run as-is to produce the required single-line output.",
            "solution": "The user has provided a well-defined computational problem that is scientifically sound, self-contained, and objective. The problem is valid and can be solved as stated.\n\nThe problem requires the derivation of numerical stencils and the implementation of a finite difference solver for one-dimensional scalar boundary-value problems. The core tasks are to handle a Neumann boundary condition using the method of ghost cells and to verify the implementation against known exact solutions.\n\n### Part 1: Derivation of the Ghost Cell Relation\n\nWe are tasked to derive a second-order accurate relation for a ghost node $u_{-1}$ at $x = -h$ to enforce the Neumann condition $u'(0) = g$. We use Taylor series expansions for $u(x)$ around $x=0$.\n\nThe expansion for $u(x)$ at $x=h$ (node $x_1$) is:\n$$u(h) = u(0) + h u'(0) + \\frac{h^2}{2} u''(0) + \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\nDiscretely, this is $u_1 = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$.\n\nThe expansion for $u(x)$ at $x=-h$ (the ghost node $x_{-1}$) is:\n$$u(-h) = u(0) - h u'(0) + \\frac{h^2}{2} u''(0) - \\frac{h^3}{6} u'''(0) + \\mathcal{O}(h^4)$$\nDiscretely, this is $u_{-1} = u_0 - h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$.\n\nTo obtain a second-order accurate approximation for $u'(0)$, we can construct a central difference. Subtracting the second expansion from the first yields:\n$$u(h) - u(-h) = 2h u'(0) + \\frac{h^3}{3} u'''(0) + \\mathcal{O}(h^5)$$\nRearranging for $u'(0)$:\n$$\\frac{u(h) - u(-h)}{2h} = u'(0) + \\frac{h^2}{6} u'''(0) + \\mathcal{O}(h^4)$$\nTruncating the higher-order terms gives the second-order accurate central difference approximation for the first derivative at $x=0$:\n$$u'(0) \\approx \\frac{u_1 - u_{-1}}{2h}$$\nTo enforce the Neumann condition $u'(0) = g$, we set:\n$$\\frac{u_1 - u_{-1}}{2h} = g$$\nSolving for the ghost node value $u_{-1}$ gives the required relation:\n$$u_{-1} = u_1 - 2hg$$\nThis relation expresses the ghost value $u_{-1}$ in terms of the interior value $u_1$ and the specified derivative $g$, with second-order accuracy.\n\n### Part 2: Derivation of the One-Sided Boundary Stencil\n\nAs an independent check and for use in verification, we derive a second-order accurate one-sided stencil for $u'(0)$ using grid values $u_0$, $u_1$, and $u_2$. We seek coefficients $a, b, c$ such that:\n$$u'(0) \\approx a u_0 + b u_1 + c u_2$$\nWe use Taylor expansions for $u_1 = u(h)$ and $u_2 = u(2h)$ around $x=0$:\n$$u_1 = u(h) = u_0 + h u'(0) + \\frac{h^2}{2} u''(0) + \\mathcal{O}(h^3)$$\n$$u_2 = u(2h) = u_0 + 2h u'(0) + \\frac{(2h)^2}{2} u''(0) + \\mathcal{O}(h^3) = u_0 + 2h u'(0) + 2h^2 u''(0) + \\mathcal{O}(h^3)$$\nSubstituting these into the stencil form:\n$$a u_0 + b \\left(u_0 + h u'(0) + \\frac{h^2}{2} u''(0)\\right) + c \\left(u_0 + 2h u'(0) + 2h^2 u''(0)\\right) + \\mathcal{O}(h^3)$$\n$$= (a+b+c)u_0 + (bh + 2ch)u'(0) + \\left(b\\frac{h^2}{2} + c(2h^2)\\right)u''(0) + \\mathcal{O}(h^3)$$\nFor this expression to be a second-order accurate approximation of $u'(0)$, the coefficients must satisfy:\n1.  Coefficient of $u_0$: $a+b+c = 0$\n2.  Coefficient of $u'(0)$: $h(b+2c) = 1$\n3.  Coefficient of $u''(0)$: $b\\frac{h^2}{2} + 2ch^2 = 0 \\implies b+4c=0$\n\nFrom (3), $b = -4c$. Substituting into (2): $h(-4c+2c)=1 \\implies -2ch=1 \\implies c = -\\frac{1}{2h}$.\nThen, $b = -4c = -4(-\\frac{1}{2h}) = \\frac{2}{h}$.\nFrom (1), $a = -b-c = -\\frac{2}{h} - (-\\frac{1}{2h}) = -\\frac{4}{2h} + \\frac{1}{2h} = -\\frac{3}{2h}$.\nThe resulting stencil is:\n$$u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}$$\nThis is the second-order accurate forward difference formula for the first derivative.\n\n### Part 3: Modification of the Leftmost Discrete Equation\n\nWe now substitute the ghost cell relation $u_{-1} = u_1 - 2hg$ into the standard central difference equation at the first node, $i=0$.\n\n**For the Helmholtz Operator:**\nThe discrete equation at $x_0=0$ is:\n$$\\frac{u_{-1} - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\nSubstitute for $u_{-1}$:\n$$\\frac{(u_1 - 2hg) - 2u_0 + u_1}{h^2} + k^2 u_0 = s_0$$\nCombine terms:\n$$\\frac{-2u_0 + 2u_1 - 2hg}{h^2} + k^2 u_0 = s_0$$\nRearrange to match the form $a_{00} u_0 + a_{01} u_1 = b_0$:\n$$\\left(k^2 - \\frac{2}{h^2}\\right) u_0 + \\frac{2}{h^2} u_1 = s_0 + \\frac{2g}{h}$$\nThe coefficients are:\n$a_{00} = k^2 - \\frac{2}{h^2}$\n$a_{01} = \\frac{2}{h^2}$\n$b_0 = s(0) + \\frac{2g}{h}$\n\n**For the Diffusion Operator:**\nThe standard discretized form is $(-u_{i-1} + 2u_i - u_{i+1})/h^2 = f_i$. At $x_0=0$:\n$$\\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f_0$$\nSubstitute for $u_{-1}$:\n$$\\frac{-(u_1 - 2hg) + 2u_0 - u_1}{h^2} = f_0$$\nCombine terms:\n$$\\frac{2u_0 - 2u_1 + 2hg}{h^2} = f_0$$\nRearrange to match the form $a_{00} u_0 + a_{01} u_1 = b_0$:\n$$\\frac{2}{h^2} u_0 - \\frac{2}{h^2} u_1 = f_0 - \\frac{2g}{h}$$\nThe coefficients are:\n$a_{00} = \\frac{2}{h^2}$\n$a_{01} = -\\frac{2}{h^2}$\n$b_0 = f(0) - \\frac{2g}{h}$\n\n### Part 4: System Assembly and Solution\n\nThe problem is discretized on $N+1$ nodes $x_0, \\dots, x_N$. The unknowns are $u_0, \\dots, u_{N-1}$, forming a vector of size $N$. $u_N$ is given by a Dirichlet condition. This results in an $N \\times N$ linear system $A \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$.\n\nThe matrix $A$ and vector $\\mathbf{b}$ are constructed as follows:\n\n**Equation for $i=0$ (Neumann BC):** As derived above.\n\n**Equations for $i=1, \\dots, N-2$ (Interior):**\n-   Helmholtz: $\\frac{1}{h^2} u_{i-1} + \\left(k^2 - \\frac{2}{h^2}\\right) u_i + \\frac{1}{h^2} u_{i+1} = s_i$.\n-   Diffusion: $-\\frac{1}{h^2} u_{i-1} + \\frac{2}{h^2} u_i - \\frac{1}{h^2} u_{i+1} = f_i$.\nThese form the tridiagonal part of the matrix $A$.\n\n**Equation for $i=N-1$ (adjacent to Dirichlet BC):**\nThe stencil involves $u_{N-2}, u_{N-1}, u_N$. Since $u_N$ is known, its term is moved to the right-hand side.\n-   Helmholtz: $\\frac{1}{h^2} u_{N-2} + \\left(k^2 - \\frac{2}{h^2}\\right) u_{N-1} = s_{N-1} - \\frac{u_N}{h^2}$.\n-   Diffusion: $-\\frac{1}{h^2} u_{N-2} + \\frac{2}{h^2} u_{N-1} = f_{N-1} + \\frac{u_N}{h^2}$.\n\nThe resulting $N \\times N$ system is then solved for $\\mathbf{u}$. The complete numerical solution is the vector $[u_0, \\dots, u_{N-1}, u_N]$. The following Python implementation assembles and solves this system for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef build_and_solve_system(params):\n    \"\"\"\n    Builds and solves the finite difference system for 1D BVP.\n    \"\"\"\n    problem_type = params[\"type\"]\n    L = params[\"L\"]\n    N = params[\"N\"]\n    k = params.get(\"k\", 0)\n    u_ex = params[\"u_ex\"]\n    u_prime = params[\"u_prime\"]\n    u_dprime = params[\"u_dprime\"]\n\n    # 1. Grid and parameters\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    # 2. Source term and boundary conditions from exact solution\n    if problem_type == \"helmholtz\":\n        s = u_dprime(x) + k**2 * u_ex(x)\n    elif problem_type == \"diffusion\":\n        f = -u_dprime(x)\n    else:\n        raise ValueError(\"Unknown problem type\")\n\n    g = u_prime(x[0])\n    u_N_val = u_ex(x[N])\n\n    # 3. Assemble the N x N linear system A*u = b\n    # The unknowns are u_0, u_1, ..., u_{N-1}\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Pre-calculate common coefficients\n    h2_inv = 1 / h**2\n    \n    # Equation for i=0 (Neumann BC at x=0)\n    if problem_type == \"helmholtz\":\n        A[0, 0] = k**2 - 2 * h2_inv\n        A[0, 1] = 2 * h2_inv\n        b[0] = s[0] + 2 * g / h\n    elif problem_type == \"diffusion\":\n        A[0, 0] = 2 * h2_inv\n        A[0, 1] = -2 * h2_inv\n        b[0] = f[0] - 2 * g / h\n\n    # Equations for i = 1 to N-2 (Interior points)\n    for i in range(1, N - 1):\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            A[i, i + 1] = h2_inv\n            b[i] = s[i]\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            A[i, i + 1] = -h2_inv\n            b[i] = f[i]\n\n    # Equation for i = N-1 (adjacent to Dirichlet BC)\n    if N > 1:\n        i = N - 1\n        if problem_type == \"helmholtz\":\n            A[i, i - 1] = h2_inv\n            A[i, i]     = k**2 - 2 * h2_inv\n            b[i] = s[i] - u_N_val * h2_inv\n        elif problem_type == \"diffusion\":\n            A[i, i - 1] = -h2_inv\n            A[i, i]     = 2 * h2_inv\n            b[i] = f[i] + u_N_val * h2_inv\n\n    # 4. Solve the system and construct the full solution vector\n    u_sol_part = np.linalg.solve(A, b)\n    u_sol = np.zeros(N + 1)\n    u_sol[0:N] = u_sol_part\n    u_sol[N] = u_N_val\n\n    # 5. Compute the required metric\n    report_metric = params[\"report\"]\n    if report_metric == \"l2_error\":\n        u_exact_nodes = u_ex(x)\n        error = u_sol - u_exact_nodes\n        l2_norm = np.sqrt(h * np.sum(error**2))\n        return l2_norm\n    elif report_metric == \"bdy_deriv_error\":\n        u0, u1, u2 = u_sol[0], u_sol[1], u_sol[2]\n        g_numerical = (-3 * u0 + 4 * u1 - u2) / (2 * h)\n        # The specified g is the exact derivative at 0\n        g_exact = g\n        return np.abs(g_numerical - g_exact)\n    else:\n        raise ValueError(\"Unknown report metric\")\n\ndef solve():\n    # Define test case parameters\n    test_cases = [\n        {\n            \"case\": 1, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 64, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 2, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 8, \"k\": 3.0,\n            \"u_ex\": lambda x: np.cos(2 * x) + 0.1 * x,\n            \"u_prime\": lambda x: -2 * np.sin(2 * x) + 0.1,\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 3, \"type\": \"diffusion\", \"L\": 1.0, \"N\": 64,\n            \"u_ex\": lambda x: np.sin(np.pi * x) + x,\n            \"u_prime\": lambda x: np.pi * np.cos(np.pi * x) + 1,\n            \"u_dprime\": lambda x: -np.pi**2 * np.sin(np.pi * x),\n            \"report\": \"l2_error\"\n        },\n        {\n            \"case\": 4, \"type\": \"helmholtz\", \"L\": 1.0, \"N\": 32, \"k\": 2.0,\n            \"u_ex\": lambda x: np.cos(2 * x),\n            \"u_prime\": lambda x: -2 * np.sin(2 * x),\n            \"u_dprime\": lambda x: -4 * np.cos(2 * x),\n            \"report\": \"bdy_deriv_error\"\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = build_and_solve_system(params)\n        results.append(f\"{result:.16g}\") # Format to avoid scientific notation if small\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Next, we shift our focus from finite differences to the finite volume method (FVM), a powerful technique renowned for its local and global conservation properties, which are critical in electromagnetics. This exercise explores the implementation of mixed Dirichlet and Neumann boundary conditions in a two-dimensional electrostatic problem, simulating a system with electrodes and insulating boundaries . You will implement a conservative FVM scheme and use it to numerically verify the principle of charge neutrality, demonstrating that a well-posed numerical method respects the underlying physical conservation laws to within the limits of numerical precision.",
            "id": "3305444",
            "problem": "Consider two-dimensional electrostatics in the absence of free charge, governed by the divergence form of Maxwell’s equations: a scalar electric potential field $u(x,y)$ on a rectangle $\\Omega = [0,L_x]\\times[0,L_y]$ satisfies the partial differential equation $\\nabla\\cdot(\\epsilon(x,y)\\nabla u) = 0$ in $\\Omega$, where $\\epsilon(x,y)$ is the spatially varying permittivity. Dirichlet boundary conditions are imposed on disjoint electrode patches $\\Gamma_D \\subset \\partial\\Omega$ (prescribed potential values), while Neumann boundary conditions are imposed elsewhere $\\Gamma_N = \\partial\\Omega \\setminus \\Gamma_D$ (prescribed normal flux values expressed as $\\epsilon\\,\\partial_n u$). The aim is to verify numerically, to within discretization and solver tolerance, the charge-neutrality identity that the sum of boundary fluxes vanishes, i.e., that the integral identity\n$$\n\\sum_{\\text{Neumann sides}} \\int_{\\Gamma_N} \\epsilon\\,\\partial_n u\\,ds \\;=\\; -\\sum_{\\text{Dirichlet sides}} \\int_{\\Gamma_D} \\epsilon\\,\\partial_n u\\,ds\n$$\nholds when $u$ is computed on a grid using a conservative discretization. All physical quantities in this problem must be expressed in International System of Units (SI units). The electric potential $u$ is in volts, the permittivity $\\epsilon$ is in farads per meter, lengths are in meters, and the boundary integrals $\\int \\epsilon\\,\\partial_n u\\,ds$ are in coulombs per meter.\n\nYour task is to write a complete program that, for each test case defined below, constructs a uniform cell-centered finite volume discretization on a rectangular grid, enforces mixed boundary conditions (Dirichlet on given electrode segments and Neumann elsewhere), solves the resulting linear system for $u$, and then evaluates the boundary integrals on $\\Gamma_D$ and $\\Gamma_N$ to compute the residual\n$$\nR \\;=\\; \\left|\\;\\sum_{\\Gamma_N}\\int_{\\Gamma_N}\\epsilon\\,\\partial_n u\\,ds \\;+\\; \\sum_{\\Gamma_D}\\int_{\\Gamma_D}\\epsilon\\,\\partial_n u\\,ds\\;\\right|\n$$\nin coulombs per meter. Your program must report, for each test, the single float $R$.\n\nFundamental base and numerical enforcement requirements:\n- Use $\\nabla\\cdot\\mathbf{D} = 0$ with $\\mathbf{D} = -\\epsilon\\nabla u$ and the absence of free charge in the domain as the physical starting point. In this setting, the potential $u$ satisfies $\\nabla\\cdot(\\epsilon\\nabla u)=0$.\n- Discretize the operator in conservative form by integrating over each control volume and approximating face-normal derivatives. Use a cell-centered finite volume method on a uniform grid with $N_x\\times N_y$ rectangular cells of sizes $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$.\n- On interior faces, use a consistent face permittivity that preserves normal flux continuity across material jumps. A standard choice is the harmonic average of neighboring cell permittivities at each face. On a boundary face adjacent to a cell, use the permittivity of that adjacent interior cell.\n- Enforce Dirichlet boundary conditions on a boundary face by eliminating the ghost value and expressing the face-normal potential derivative in terms of the interior cell-center potential and the prescribed boundary value. Enforce Neumann boundary conditions by prescribing $\\epsilon\\,\\partial_n u=g(s)$ as a boundary flux term in the finite volume residual, where $s$ is the arclength coordinate along that side. Assume unit thickness in the out-of-plane direction.\n- After solving for $u$, evaluate the boundary integrals as follows:\n  - For each Dirichlet boundary face, approximate $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ by $\\epsilon \\, (u_B - u_C)/d \\times \\ell$, where $u_B$ is the prescribed boundary potential on that face segment, $u_C$ is the adjacent interior cell-center potential, $d$ is the distance from that cell center to the boundary along the outward normal, and $\\ell$ is the length of that face segment.\n  - For each Neumann boundary face with prescribed data $g(s)=\\epsilon\\,\\partial_n u$, approximate $\\int_{\\text{face}} \\epsilon\\,\\partial_n u\\,ds$ by $g(s_f)\\times \\ell$, where $s_f$ is the arclength coordinate at the face center and $\\ell$ is the face length. Use $g(s)=0$ wherever Neumann is homogeneous.\nYour implementation must ensure numerical consistency between the discrete operator and the integral evaluation so that any residual $R$ reflects only numerical error.\n\nTest suite:\nImplement the following three test cases. For each case, you must use the specified geometry, material, grid, and boundary data. All angles are to be treated in radians.\n\n- Test 1 (happy path, homogeneous medium, insulated sides except electrodes):\n  - Domain: $L_x = 0.01\\,\\text{m}$, $L_y = 0.01\\,\\text{m}$.\n  - Grid: $N_x = 64$, $N_y = 64$.\n  - Permittivity: $\\epsilon(x,y) = \\epsilon_r \\epsilon_0$ with $\\epsilon_r = 3.2$ and $\\epsilon_0 = 8.854187817\\times 10^{-12}\\,\\text{F/m}$.\n  - Dirichlet electrodes:\n    - Top side, for $x\\in[0.3L_x,\\,0.7L_x]$: $u=1.0\\,\\text{V}$.\n    - Bottom side, for $x\\in[0.1L_x,\\,0.2L_x]$: $u=0.0\\,\\text{V}$.\n  - Neumann elsewhere: homogeneous, i.e., $g(s)=0$ on all other boundary segments.\n\n- Test 2 (heterogeneous medium with nonzero Neumann on one side):\n  - Domain: $L_x = 0.02\\,\\text{m}$, $L_y = 0.02\\,\\text{m}$.\n  - Grid: $N_x = 60$, $N_y = 60$.\n  - Permittivity: piecewise, $\\epsilon(x,y) = \\epsilon_0$ if $x  L_x/2$, and $\\epsilon(x,y) = 4\\epsilon_0$ if $x \\ge L_x/2$.\n  - Dirichlet electrodes:\n    - Left side, for $y\\in[0.4L_y,\\,0.7L_y]$: $u=0.0\\,\\text{V}$.\n    - Top side, for $x\\in[0.5L_x,\\,0.9L_x]$: $u=5.0\\,\\text{V}$.\n  - Neumann boundary condition on right side: $g(y) = 1.0\\times 10^{-7}\\,\\big(0.5 + 0.5\\sin(2\\pi y/L_y)\\big)\\,\\text{C/m}^2$.\n  - Neumann elsewhere: homogeneous, i.e., $g(s)=0$.\n\n- Test 3 (small electrodes near a corner with constant Neumann on the top side):\n  - Domain: $L_x = 0.03\\,\\text{m}$, $L_y = 0.015\\,\\text{m}$.\n  - Grid: $N_x = 80$, $N_y = 40$.\n  - Permittivity: $\\epsilon(x,y)=2\\epsilon_0$.\n  - Dirichlet electrodes:\n    - Bottom side, for $x\\in[0.0,\\,0.005]$: $u=0.0\\,\\text{V}$.\n    - Right side, for $y\\in[0.0,\\,0.004]$: $u=1.0\\,\\text{V}$.\n  - Neumann boundary condition on top side: $g(x) = -5.0\\times 10^{-8}\\,\\text{C/m}^2$ (constant).\n  - Neumann elsewhere: homogeneous, i.e., $g(s)=0$.\n\nOutput specification:\n- For each test case, compute the residual $R$ in coulombs per meter as defined above.\n- Your program should produce a single line of output containing the three residuals as a comma-separated list enclosed in square brackets, in the order of Test 1, Test 2, Test 3. For example: \"[r1,r2,r3]\".\n- Each $r_i$ must be a floating-point number. No additional text should be printed.\n\nAll numerical steps and enforcement choices must be implemented within your submitted program. No user input is required. The correctness criterion is that each residual $r_i$ should be small (close to zero) if boundary conditions are enforced correctly and the discretization is conservative, with deviations attributable only to numerical approximation and solver tolerance. Express all computed residuals in coulombs per meter.",
            "solution": "The problem requires the numerical verification of charge neutrality, $\\oint_{\\partial\\Omega} \\epsilon \\partial_n u \\, ds = 0$, for a 2D electrostatic system governed by $\\nabla \\cdot (\\epsilon \\nabla u) = 0$. This is achieved using a cell-centered finite volume method. The core of the method lies in integrating the governing equation over each grid cell (control volume) and applying the divergence theorem.\n\nFor a cell $V_{i,j}$ with center $(x_i, y_j)$, this yields:\n$$\n\\int_{V_{i,j}} \\nabla \\cdot (\\epsilon \\nabla u) \\, dV = \\oint_{\\partial V_{i,j}} (\\epsilon \\nabla u) \\cdot \\mathbf{n}_{\\text{cell}} \\, dS = 0\n$$\nwhere $\\mathbf{n}_{\\text{cell}}$ is the outward normal from the cell's boundary $\\partial V_{i,j}$. The boundary integral is a sum of fluxes over the four faces of the cell (East, West, North, South):\n$$\nF_E + F_W + F_N + F_S = 0\n$$\nEach flux term $F$ represents the integral of the normal component of $\\epsilon \\nabla u$ over a cell face. For example, the flux out of the east face is $F_E = \\int_{\\text{east face}} \\epsilon \\frac{\\partial u}{\\partial x} \\, dy$.\n\n**Discretization of Fluxes**\n\nThe fluxes are approximated using finite differences between cell-center potentials.\nFor an **interior face** between cell $(i,j)$ and its eastern neighbor $(i+1,j)$, the flux is approximated as:\n$$\nF_E \\approx \\left(\\epsilon_{i+1/2,j} \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x}\\right) \\Delta y\n$$\nHere, $u_{i,j}$ is the potential at the center of cell $(i,j)$, and $\\epsilon_{i+1/2,j}$ is the permittivity at the interface. As specified, we use the harmonic mean: $\\epsilon_{i+1/2,j} = \\frac{2\\epsilon_{i,j}\\epsilon_{i+1,j}}{\\epsilon_{i,j}+\\epsilon_{i+1,j}}$. This ensures continuity of the normal component of the electric displacement field $\\mathbf{D}$ across material interfaces.\n\nFor a **boundary face**, the flux approximation depends on the boundary condition.\n1.  **Neumann Boundary Condition**: The value of the normal flux, $g(s) = \\epsilon \\partial_n u$, is prescribed. On a boundary face of length $\\ell$, the flux out of the cell is simply $F_{\\text{bnd}} \\approx g(s_f)\\ell$, where $s_f$ is the coordinate of the face center. This value is a known constant and is moved to the right-hand side of the linear system.\n\n2.  **Dirichlet Boundary Condition**: The potential $u_B$ is prescribed on the boundary. The flux is approximated using the potential of the adjacent interior cell, $u_C$, and the boundary potential $u_B$. For a face at a distance $d$ from the cell center, the normal derivative is $\\partial_n u \\approx (u_B - u_C)/d$ (taking care with the sign of the normal). The problem provides the formula for the flux integral out of the domain: $\\int \\epsilon\\,\\partial_n u\\,ds \\approx \\epsilon_C (u_B-u_C)/d \\times \\ell$. The flux out of the cell is consistent with this expression. For example, for the west face of cell $(0,j)$, the outward normal from the cell is $-\\hat{\\mathbf{x}}$, which is also the outward normal from the domain. The flux out of the cell is $F_W = \\int -\\epsilon \\frac{\\partial u}{\\partial x} dy$. Using $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{0,j}-u_B}{\\Delta x/2}$, the flux becomes $F_W \\approx -\\epsilon_{0,j} \\frac{u_{0,j}-u_B}{\\Delta x/2} \\Delta y = \\epsilon_{0,j}\\frac{u_B-u_{0,j}}{\\Delta x/2}\\Delta y$. This term depends on the unknown $u_{0,j}$ and also contributes a constant term involving $u_B$ to the right-hand side.\n\n**Linear System and Conservation**\n\nAssembling the flux balance equation for every cell $(i,j)$ in the $N_x \\times N_y$ grid results in a system of $N_x N_y$ linear equations, which can be written in matrix form as $A\\mathbf{u} = \\mathbf{b}$. Here $\\mathbf{u}$ is the vector of unknown cell-center potentials, $A$ is a sparse matrix of coefficients, and $\\mathbf{b}$ is the right-hand-side vector containing contributions from the boundary conditions.\n\nA key property of this conservative finite volume formulation is that if we sum all the discrete flux balance equations over all cells in the domain, the fluxes across interior faces cancel out perfectly. This is because the flux leaving one cell is identical in magnitude but opposite in sign to the flux entering the adjacent cell. The sum reduces to:\n$$\n\\sum_{\\text{all boundary faces}} F_{\\text{bnd, out of cell}} = 0\n$$\nwhere $F_{\\text{bnd, out of cell}}$ is the discrete flux expression used to build the matrix system. The problem asks for the residual $R$, which is the absolute value of the total flux out of the domain boundary, calculated using approximations consistent with those used to derive the matrix $A$ and vector $\\mathbf{b}$. Due to the conservation property, this sum must be zero for the exact solution of the discrete system. Any non-zero result is attributable only to the solver's numerical tolerance and floating-point arithmetic errors.\n\n**Implementation Details**\n\nThe solution involves the following steps for each test case:\n1.  **Grid and Material Setup**: Define the domain size, grid resolution, and the permittivity $\\epsilon(x,y)$ for each cell.\n2.  **Matrix Assembly**: Create a sparse matrix $A$ and a vector $\\mathbf{b}$. Iterate through each cell $(i,j)$, and for each of its four faces, calculate the corresponding coefficient and update $A$ and/or $\\mathbf{b}$ based on whether the face is interior or on the boundary. For Neumann boundaries, the flux $g(s)\\ell$ is subtracted from the corresponding entry in $\\mathbf{b}$. For Dirichlet boundaries, the terms are split between $A$ and $\\mathbf{b}$.\n3.  **Solve**: Solve the linear system $A\\mathbf{u}=\\mathbf{b}$ for the potential vector $\\mathbf{u}$ using `scipy.sparse.linalg.spsolve`.\n4.  **Residual Calculation**: Initialize a total flux accumulator to zero. Iterate over all boundary faces (left, right, bottom, top). For each face, calculate the flux leaving the domain using the prescribed numerical approximations and the newly computed potentials $u_{i,j}$. Add this flux to the accumulator. The final residual $R$ is the absolute value of this sum.\nThis procedure is repeated for all three test cases to generate the required output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Physical constant\n    EPS0 = 8.854187817e-12  # Permittivity of free space in F/m\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"name\": \"Test 1\",\n            \"Lx\": 0.01, \"Ly\": 0.01, \"Nx\": 64, \"Ny\": 64,\n            \"eps_func\": lambda x, y: 3.2 * EPS0,\n            \"bcs\": [\n                {'side': 'N', 'type': 'D', 'value': 1.0, 'range': (0.3, 0.7)},\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0.1, 0.2)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 2\",\n            \"Lx\": 0.02, \"Ly\": 0.02, \"Nx\": 60, \"Ny\": 60,\n            \"eps_func\": lambda x, y: EPS0 if x  0.01 else 4 * EPS0,\n            \"bcs\": [\n                {'side': 'W', 'type': 'D', 'value': 0.0, 'range': (0.4, 0.7)},\n                {'side': 'N', 'type': 'D', 'value': 5.0, 'range': (0.5, 0.9)},\n                {'side': 'E', 'type': 'N', 'value': lambda y, Ly: 1.0e-7 * (0.5 + 0.5 * np.sin(2 * np.pi * y / Ly)), 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        },\n        {\n            \"name\": \"Test 3\",\n            \"Lx\": 0.03, \"Ly\": 0.015, \"Nx\": 80, \"Ny\": 40,\n            \"eps_func\": lambda x, y: 2.0 * EPS0,\n            \"bcs\": [\n                {'side': 'S', 'type': 'D', 'value': 0.0, 'range': (0, 0.005)},\n                {'side': 'E', 'type': 'D', 'value': 1.0, 'range': (0, 0.004)},\n                {'side': 'N', 'type': 'N', 'value': -5.0e-8, 'range': (0.0, 1.0)},\n            ],\n            \"default_bc\": {'type': 'N', 'value': 0.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = solve_one_case(case)\n        results.append(res)\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef solve_one_case(case_params):\n    \"\"\"\n    Solves a single electrostatic problem using a finite volume method.\n    \"\"\"\n    Lx, Ly = case_params[\"Lx\"], case_params[\"Ly\"]\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    eps_func = case_params[\"eps_func\"]\n    \n    dx, dy = Lx / Nx, Ly / Ny\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    \n    eps_grid = np.zeros((Ny, Nx))\n    for j in range(Ny):\n        for i in range(Nx):\n            eps_grid[j, i] = eps_func(x_centers[i], y_centers[j])\n\n    def get_bc_for_face(side, index):\n        coord = 0.0\n        domain_len = 0.0\n        if side in ['N', 'S']:\n            coord = x_centers[index]\n            domain_len = Lx\n        else:  # 'W', 'E'\n            coord = y_centers[index]\n            domain_len = Ly\n\n        for bc in case_params['bcs']:\n            if bc['side'] == side:\n                is_relative_range = all(0.0 = val = 1.0 for val in bc['range'])\n                start, end = bc['range']\n                \n                if is_relative_range:\n                    start *= domain_len\n                    end   *= domain_len\n\n                if start = coord  end:\n                    return bc['type'], bc['value']\n\n        return case_params['default_bc']['type'], case_params['default_bc']['value']\n\n    N_total = Nx * Ny\n    A = lil_matrix((N_total, N_total))\n    b = np.zeros(N_total)\n\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx\n            \n            # West Face\n            if i  0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i-1] / (eps_grid[j, i] + eps_grid[j, i-1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k-1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('W', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, 0] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n\n            # East Face\n            if i  Nx - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j, i+1] / (eps_grid[j, i] + eps_grid[j, i+1])\n                c = eps_face * dy / dx\n                A[k, k] -= c\n                A[k, k+1] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('E', j)\n                if bc_type == 'D':\n                    c = eps_grid[j, -1] * dy / (dx / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n                    b[k] -= g * dy\n            \n            # South Face\n            if j  0:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j-1, i] / (eps_grid[j, i] + eps_grid[j-1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k - Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('S', i)\n                if bc_type == 'D':\n                    c = eps_grid[0, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n            \n            # North Face\n            if j  Ny - 1:\n                eps_face = 2 * eps_grid[j, i] * eps_grid[j+1, i] / (eps_grid[j, i] + eps_grid[j+1, i])\n                c = eps_face * dx / dy\n                A[k, k] -= c\n                A[k, k + Nx] += c\n            else:\n                bc_type, bc_val = get_bc_for_face('N', i)\n                if bc_type == 'D':\n                    c = eps_grid[-1, i] * dx / (dy / 2)\n                    A[k, k] -= c\n                    b[k] -= c * bc_val\n                else: # Neumann\n                    g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n                    b[k] -= g * dx\n    \n    u_vec = spsolve(A.tocsr(), b)\n    u_grid = u_vec.reshape((Ny, Nx))\n\n    total_flux = 0.0\n\n    # West (i=0): n_out = -x_hat, d_n u = -du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('W', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, 0] * (bc_val - u_grid[j, 0]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # East (i=Nx-1): n_out = +x_hat, d_n u = +du/dx\n    for j in range(Ny):\n        bc_type, bc_val = get_bc_for_face('E', j)\n        if bc_type == 'D':\n            flux = eps_grid[j, -1] * (bc_val - u_grid[j, -1]) / (dx / 2) * dy\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(y_centers[j], Ly)\n            flux = g * dy\n        total_flux += flux\n\n    # South (j=0): n_out = -y_hat, d_n u = -du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('S', i)\n        if bc_type == 'D':\n            flux = eps_grid[0, i] * (bc_val - u_grid[0, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n\n    # North (j=Ny-1): n_out = +y_hat, d_n u = +du/dy\n    for i in range(Nx):\n        bc_type, bc_val = get_bc_for_face('N', i)\n        if bc_type == 'D':\n            flux = eps_grid[-1, i] * (bc_val - u_grid[-1, i]) / (dy / 2) * dx\n        else:\n            g = bc_val if isinstance(bc_val, (int, float)) else bc_val(x_centers[i], Lx)\n            flux = g * dx\n        total_flux += flux\n        \n    return abs(total_flux)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Finally, we advance to a more complex and practical challenge: imposing boundary conditions on a curved interface that is not aligned with the computational grid. This practice extends the ghost-cell method to two dimensions, requiring a more sophisticated quadratic extrapolation scheme to maintain accuracy on a subcell-resolved boundary . By quantifying the non-physical \"spurious charge\" that arises at the interface due to discretization, this exercise provides insight into the subtle errors inherent in embedded boundary methods and the importance of high-order enforcement schemes in advanced simulations.",
            "id": "3305487",
            "problem": "You are asked to design and implement a ghost-cell method on a two-dimensional Yee grid for electrostatics that enforces a Neumann boundary condition on a subcell-resolved curved interface using quadratic extrapolation along the local interface normal, and to quantify the induced spurious charge via a discrete divergence of the electric flux density. The derivation must start from electrostatic first principles.\n\nThe electrostatic starting point is the following. Let $u(x,y)$ denote the scalar electric potential, let $\\epsilon(x,y)$ denote the permittivity, let $\\mathbf{E} = -\\nabla u$ denote the electric field, and let $\\mathbf{D} = \\epsilon \\mathbf{E}$ denote the electric flux density. Gauss’s law in electrostatics states $\\nabla \\cdot \\mathbf{D} = \\rho$, and therefore, in charge-free regions, $\\nabla \\cdot (\\epsilon \\nabla u) = 0$. A Neumann boundary condition specifies the normal derivative of the potential on a boundary: $\\partial_n u = g$, where $\\partial_n u = \\nabla u \\cdot \\mathbf{n}$ and $\\mathbf{n}$ is the outward unit normal to the boundary.\n\nYou must work on a uniform rectangular grid covering the unit square $[0,1] \\times [0,1]$, with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction, cell sizes $\\Delta x = 1/N_x$, $\\Delta y = 1/N_y$, and cell centers at $(x_i, y_j) = \\big((i+1/2)\\Delta x,(j+1/2)\\Delta y\\big)$ for integers $i \\in \\{0,\\dots,N_x-1\\}$, $j \\in \\{0,\\dots,N_y-1\\}$. You will employ a Yee-type staggering for the discrete field operators: store the scalar potential $u_{i,j}$ at cell centers, compute $E_x$ at $x$-faces $(i+1/2,j)$ from centered differences of $u$, and compute $E_y$ at $y$-faces $(i,j+1/2)$ similarly. Then compute the discrete divergence of $\\mathbf{D} = \\epsilon \\mathbf{E}$ by a flux-difference at cell centers.\n\nThe curved interface is the zero level set of a signed-distance-type function $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$, which represents a circle of radius $R$ centered at $(x_c,y_c)$. Define the computational region as $\\Omega = \\{(x,y)\\,:\\,\\phi(x,y) \\ge 0\\}$, i.e., the exterior of the circle. Assume the permittivity is constant and equal to a given positive scalar $\\epsilon$ in $\\Omega$. On the interface $\\Gamma = \\{(x,y)\\,:\\,\\phi(x,y) = 0\\}$, enforce a Neumann condition $\\partial_n u = g$, where $g$ is the known normal derivative taken from a smooth manufactured solution (specified below). The outward unit normal into $\\Omega$ is $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$ on $\\Gamma$.\n\nYour task is to implement a ghost-cell construction to provide values of $u$ at hypothetical neighbor cell centers that lie across the interface, which allows you to compute the Yee-face electric fields adjacent to interface-cut cells using central differences of $u$. For any face adjacent to a cell in $\\Omega$ whose neighbor lies in $\\{ \\phi  0 \\}$, compute a ghost value $u_g$ at the neighbor cell center by fitting a quadratic profile along the local interface normal. Parameterize the line along the normal by $s$, with $s=0$ at the interface, $s>0$ pointing into $\\Omega$. Denote by $s_0$ the signed distance from the interface point to the interior cell center along the normal, and define two additional interior sample points at $s_1 = s_0 + h_n$ and $s_2 = s_0 + 2 h_n$, where $h_n = \\min(\\Delta x,\\Delta y)$. Fit a quadratic $p(s) = a s^2 + b s + c$ satisfying:\n- $p'(0) = b = g$ (the Neumann condition at the interface),\n- $p(s_1) = u(s_1)$,\n- $p(s_2) = u(s_2)$,\nand then define the ghost value by quadratic extrapolation to the mirrored position across the interface, $u_g = p(-s_0)$. The values $u(s_1)$ and $u(s_2)$ should be taken from the smooth manufactured solution specified below, evaluated at the physical coordinates $(x,y) = (x_I,y_I) + s\\,\\mathbf{n}$, where $(x_I,y_I)$ is the interface point on the segment connecting the interior cell center and its across-interface neighbor, and $\\mathbf{n}$ is the interface normal at $(x_I,y_I)$.\n\nTo make the problem fully specified and testable without solving a global linear system, use the manufactured harmonic potential\n$$u_{\\mathrm{ex}}(x,y) = x^2 - y^2,$$\nfor which the exact electric field is $\\mathbf{E}_{\\mathrm{ex}} = -\\nabla u_{\\mathrm{ex}} = (-2x, 2y)$, the exact normal derivative is $g = \\partial_n u_{\\mathrm{ex}} = \\nabla u_{\\mathrm{ex}} \\cdot \\mathbf{n} = (2x,-2y)\\cdot \\mathbf{n}$ on the interface, and the continuum charge-free condition holds as $\\nabla\\cdot(\\epsilon \\nabla u_{\\mathrm{ex}}) = \\epsilon \\nabla^2 u_{\\mathrm{ex}} = 0$. Set the interior cell values to $u_{i,j} = u_{\\mathrm{ex}}(x_i,y_j)$ for all cell centers in $\\Omega$ (i.e., with $\\phi(x_i,y_j) \\ge 0$). Then, for each interior cell face needed to compute the discrete divergence in a band near the interface, construct ghost values at across-interface neighbor cell centers by the quadratic-normal procedure above, compute Yee-face fields by central differences using either true neighbor values (if both cell centers are in $\\Omega$) or the ghost values (if the neighbor lies across the interface), form $\\mathbf{D}$ on faces as $\\epsilon \\mathbf{E}$, and compute the discrete divergence at a cell center $(i,j)$ as\n$$\n(\\nabla\\cdot \\mathbf{D})_{i,j}\n=\n\\frac{D_x|_{i+1/2,j} - D_x|_{i-1/2,j}}{\\Delta x}\n+\n\\frac{D_y|_{i,j+1/2} - D_y|_{i,j-1/2}}{\\Delta y}.\n$$\nDefine the spurious charge density as\n$$\n\\rho_{\\mathrm{sp}} = -\\nabla\\cdot(\\epsilon \\nabla u),\n$$\ncomputed discretely as above. Because $u_{\\mathrm{ex}}$ is harmonic and $\\epsilon$ is constant, the exact continuum charge density is zero, so nonzero values arise purely from discretization and boundary enforcement. Quantify the spurious charge in a one-cell-thick band near the interface, given by the set of cell centers with $0 \\le \\phi(x_i,y_j) \\le 3\\min(\\Delta x,\\Delta y)$. For this band, report:\n- The root-mean-square value $\\sqrt{\\frac{1}{N_b}\\sum \\rho_{\\mathrm{sp}}^2}$ over the band cells, where $N_b$ is the number of band cells.\n- The maximum absolute value $\\max |\\rho_{\\mathrm{sp}}|$ over the band cells.\n\nUnits: the problem is nondimensionalized; all quantities are unitless.\n\nYour program must implement the scheme above and produce the requested metrics for the following four test cases (each case defines the grid, circle center and radius, and permittivity):\n\n- Case A (general case): $N_x=64$, $N_y=64$, $(x_c,y_c) = (0.5,0.5)$, $R=0.30$, $\\epsilon=2.0$.\n- Case B (small-radius interface): $N_x=64$, $N_y=64$, $(x_c,y_c) = (0.5,0.5)$, $R=0.12$, $\\epsilon=5.0$.\n- Case C (coarser grid): $N_x=32$, $N_y=40$, $(x_c,y_c) = (0.5,0.5)$, $R=0.30$, $\\epsilon=3.0$.\n- Case D (offset interface): $N_x=80$, $N_y=60$, $(x_c,y_c) = (0.42,0.47)$, $R=0.35$, $\\epsilon=1.0$.\n\nYour program should produce a single line of output containing the eight results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\mathrm{RMS}_A,\\mathrm{MAX}_A,\\mathrm{RMS}_B,\\mathrm{MAX}_B,\\mathrm{RMS}_C,\\mathrm{MAX}_C,\\mathrm{RMS}_D,\\mathrm{MAX}_D],\n$$\nwith each floating-point number printed in fixed-point notation rounded to $8$ decimal places. No additional text should be printed.",
            "solution": "The user has requested the design and implementation of a numerical method to quantify spurious charges arising from the enforcement of a Neumann boundary condition on a curved interface. The method is based on a ghost-cell approach with quadratic extrapolation on a two-dimensional Yee grid for an electrostatic problem. The problem is well-defined, scientifically sound, and provides all necessary information, including a manufactured solution for testing, specific boundary treatment algorithms, and clear metrics for evaluation. Therefore, the problem is deemed valid.\n\nHere is a step-by-step derivation and explanation of the implemented solution.\n\n### 1. Problem Formulation and Discretization\n\nThe governing equation is Gauss's law for electrostatics in a charge-free region, $\\nabla \\cdot \\mathbf{D} = 0$, where $\\mathbf{D} = \\epsilon \\mathbf{E}$ is the electric flux density, and $\\mathbf{E} = -\\nabla u$ is the electric field derived from a scalar potential $u$. This results in the partial differential equation $\\nabla \\cdot (\\epsilon \\nabla u) = 0$.\n\nThe computational domain is the unit square $[0,1] \\times [0,1]$, discretized by a uniform grid of $N_x \\times N_y$ cells with dimensions $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. A standard finite-volume-like discretization on a Yee grid is employed:\n- The scalar potential $u_{i,j}$ is located at cell centers $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$.\n- The electric field components are located at face centers. The $x$-component $E_x$ at the face between cells $(i,j)$ and $(i+1,j)$ is computed as:\n  $$ E_x|_{i+1/2,j} = - \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x} $$\n- Similarly, the $y$-component $E_y$ at the face between cells $(i,j)$ and $(i,j+1)$ is:\n  $$ E_y|_{i,j+1/2} = - \\frac{u_{i,j+1} - u_{i,j}}{\\Delta y} $$\nThe electric flux density components are $D_x = \\epsilon E_x$ and $D_y = \\epsilon E_y$. The divergence is computed at cell centers $(i,j)$ using a central difference of fluxes:\n$$ (\\nabla \\cdot \\mathbf{D})_{i,j} = \\frac{D_x|_{i+1/2,j} - D_x|_{i-1/2,j}}{\\Delta x} + \\frac{D_y|_{i,j+1/2} - D_y|_{i,j-1/2}}{\\Delta y} $$\nThe spurious charge density is defined as $\\rho_{\\mathrm{sp}} = -\\nabla \\cdot (\\epsilon\\nabla u)$. Since $\\mathbf{D} = \\epsilon \\mathbf{E} = -\\epsilon\\nabla u$, we have $\\nabla \\cdot \\mathbf{D} = -\\nabla \\cdot (\\epsilon\\nabla u)$. Thus, the discrete spurious charge density at a cell center is equal to the discrete divergence of $\\mathbf{D}$:\n$$ \\rho_{\\mathrm{sp}}|_{i,j} = (\\nabla \\cdot \\mathbf{D})_{i,j} $$\n\n### 2. Interface and Boundary Conditions\n\nA circular interface is defined by the zero level set of $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$. The computational domain $\\Omega$ is outside the circle, where $\\phi(x,y) \\ge 0$. On the interface, a Neumann condition $\\partial_n u = g$ is enforced, where $\\mathbf{n}$ is the outward normal from the circle. The problem is tested using a manufactured solution $u_{\\mathrm{ex}}(x,y) = x^2 - y^2$. The potential at any interior cell center $(x_i,y_j)$ is simply set to $u_{\\mathrm{ex}}(x_i,y_j)$. The function $g$ is derived from this exact solution as $g = \\nabla u_{\\mathrm{ex}} \\cdot \\mathbf{n}$.\n\n### 3. Ghost-Cell Method with Quadratic Extrapolation\n\nWhen computing a flux across a face separating an interior cell (in $\\Omega$) and an exterior or \"ghost\" cell (outside $\\Omega$), the potential at the ghost cell center is required. This value, $u_g$, is constructed using a ghost-cell method. The procedure is as follows for a face separating an interior cell at $\\mathbf{x}_{\\text{int}}$ and a ghost cell at $\\mathbf{x}_{\\text{ghost}}$:\n\n1.  **Find Interface Point**: The point $\\mathbf{x}_I$ where the line segment $[\\mathbf{x}_{\\text{int}}, \\mathbf{x}_{\\text{ghost}}]$ intersects the interface $\\phi=0$ is determined. This involves solving a quadratic equation for the intersection parameter.\n2.  **Determine Local Geometry**: At $\\mathbf{x}_I$, the interface normal $\\mathbf{n} = (\\mathbf{x}_I - \\mathbf{x}_c)/R$ is computed. The distance from $\\mathbf{x}_I$ to $\\mathbf{x}_{\\text{int}}$ along this normal is calculated as $s_0 = (\\mathbf{x}_{\\text{int}} - \\mathbf{x}_I) \\cdot \\mathbf{n}$.\n3.  **Construct Quadratic Profile**: A 1D quadratic polynomial $p(s) = as^2+bs+c$ is constructed along the normal line, where $s$ is the distance from the interface. The coefficients are determined by three conditions:\n    a. The derivative at the interface matches the Neumann condition: $p'(0) = b = g = \\nabla u_{\\mathrm{ex}}(\\mathbf{x}_I) \\cdot \\mathbf{n}$.\n    b. The profile matches the known solution at two interior sample points. These points are located at distances $s_1 = s_0 + h_n$ and $s_2 = s_0 + 2h_n$ from the interface along the normal, where $h_n = \\min(\\Delta x, \\Delta y)$. The conditions are $p(s_1) = u_{\\mathrm{ex}}(\\mathbf{x}_I+s_1\\mathbf{n})$ and $p(s_2) = u_{\\mathrm{ex}}(\\mathbf{x}_I+s_2\\mathbf{n})$.\n    These three conditions form a linear system for the coefficients $(a, b, c)$, which is solved uniquely.\n4.  **Extrapolate Ghost Value**: The ghost potential $u_g$ is obtained by evaluating the quadratic profile at the mirrored distance $s = -s_0$:\n    $$ u_g = p(-s_0) = a(-s_0)^2 + b(-s_0) + c = as_0^2 - bs_0 + c $$\nThis value $u_g$ is then used in the finite-difference formula for the electric field at the face.\n\n### 4. Spurious Charge Calculation\n\nThe algorithm proceeds by identifying a band of cells near the interface, specifically those with centers $(x_i,y_j)$ satisfying $0 \\le \\phi(x_i,y_j) \\le 3\\min(\\Delta x, \\Delta y)$. For each cell in this band, the four fluxes ($D_x$ at $x_{i\\pm1/2}$ and $D_y$ at $y_{j\\pm1/2}$) are computed. If a face is between two interior cells, the standard finite difference is used. If it is an interface-cutting face, the ghost-cell procedure provides the necessary potential value. Finally, the discrete divergence of $\\mathbf{D}$ is computed at the cell center, yielding the spurious charge density $\\rho_{\\mathrm{sp}}$. The root-mean-square and maximum absolute values of $\\rho_{\\mathrm{sp}}$ are then calculated over all cells in the band. This process is repeated for each of the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ElectrostaticsSolver:\n    \"\"\"\n    Implements a ghost-cell method on a 2D Yee grid for electrostatics\n    to enforce a Neumann boundary condition on a subcell-resolved curved interface.\n    \"\"\"\n\n    def __init__(self, Nx, Ny, xc, yc, R, eps):\n        # Store parameters\n        self.Nx, self.Ny = Nx, Ny\n        self.xc, self.yc, self.R, self.eps = float(xc), float(yc), float(R), float(eps)\n\n        # Grid setup\n        self.dx, self.dy = 1.0 / Nx, 1.0 / Ny\n        self.hn = min(self.dx, self.dy)\n        \n        # Cell center coordinates\n        i_coords = np.arange(Nx)\n        j_coords = np.arange(Ny)\n        self.x_centers = (i_coords + 0.5) * self.dx\n        self.y_centers = (j_coords + 0.5) * self.dy\n        \n        # Grid of cell-centered coordinates\n        self.xx, self.yy = np.meshgrid(self.x_centers, self.y_centers, indexing='ij')\n\n        # Identify interior/exterior cells based on phi at cell centers\n        self.phi_vals = self._phi(self.xx, self.yy)\n        self.is_interior = self.phi_vals = 0\n\n    def _u_ex(self, x, y):\n        \"\"\"Manufactured potential solution.\"\"\"\n        return x**2 - y**2\n\n    def _grad_u_ex(self, x, y):\n        \"\"\"Gradient of the manufactured potential.\"\"\"\n        return np.array([2 * x, -2 * y])\n\n    def _phi(self, x, y):\n        \"\"\"Signed distance function for the circular interface.\"\"\"\n        return np.sqrt((x - self.xc)**2 + (y - self.yc)**2) - self.R\n\n    def _compute_ghost_value(self, p_int, p_ghost):\n        \"\"\"\n        Computes the ghost potential value using quadratic extrapolation along the normal.\n        p_int: Coordinates of the interior cell center.\n        p_ghost: Coordinates of the ghost cell center.\n        \"\"\"\n        v = p_ghost - p_int\n        p1c = p_int - np.array([self.xc, self.yc])\n        \n        A = np.dot(v, v)\n        B = 2 * np.dot(p1c, v)\n        C = np.dot(p1c, p1c) - self.R**2\n        \n        discriminant = B**2 - 4 * A * C\n        if discriminant  0:\n            discriminant = 0\n            \n        t = (-B - np.sqrt(discriminant)) / (2 * A)\n        \n        p_I = p_int + t * v\n        \n        n_vec = p_I - np.array([self.xc, self.yc])\n        norm_n = np.linalg.norm(n_vec)\n        n = n_vec / norm_n if norm_n  0 else np.array([1.0, 0.0])\n\n        s0 = np.dot(p_int - p_I, n)\n        if s0  0:\n            s0 = 0\n            \n        g = np.dot(self._grad_u_ex(p_I[0], p_I[1]), n)\n        \n        s1 = s0 + self.hn\n        s2 = s0 + 2 * self.hn\n        \n        p1_sample = p_I + s1 * n\n        p2_sample = p_I + s2 * n\n        \n        u1_sample = self._u_ex(p1_sample[0], p1_sample[1])\n        u2_sample = self._u_ex(p2_sample[0], p2_sample[1])\n        \n        b = g\n        denom = self.hn * (2 * s0 + 3 * self.hn)\n        a = (u2_sample - u1_sample - b * self.hn) / denom\n        c = u1_sample - a * s1**2 - b * s1\n        \n        u_g = a * (-s0)**2 + b * (-s0) + c\n        return u_g\n\n    def _get_Dx(self, i, j):\n        \"\"\"Computes D_x at the face between cells (i,j) and (i+1,j).\"\"\"\n        if not (0 = i  self.Nx - 1 and 0 = j  self.Ny):\n            return 0.0\n\n        is_p1_int = self.is_interior[i, j]\n        is_p2_int = self.is_interior[i + 1, j]\n        \n        Ex = 0.0\n        if is_p1_int and is_p2_int:\n            u1 = self._u_ex(self.x_centers[i], self.y_centers[j])\n            u2 = self._u_ex(self.x_centers[i+1], self.y_centers[j])\n            Ex = -(u2 - u1) / self.dx\n        elif is_p1_int and not is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i+1], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u1 = self._u_ex(p_int[0], p_int[1])\n            Ex = -(u_g - u1) / self.dx\n        elif not is_p1_int and is_p2_int:\n            p_int = np.array([self.x_centers[i+1], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u2 = self._u_ex(p_int[0], p_int[1])\n            Ex = -(u2 - u_g) / self.dx\n        \n        return self.eps * Ex\n\n    def _get_Dy(self, i, j):\n        \"\"\"Computes D_y at the face between cells (i,j) and (i,j+1).\"\"\"\n        if not (0 = i  self.Nx and 0 = j  self.Ny - 1):\n            return 0.0\n\n        is_p1_int = self.is_interior[i, j]\n        is_p2_int = self.is_interior[i, j + 1]\n\n        Ey = 0.0\n        if is_p1_int and is_p2_int:\n            u1 = self._u_ex(self.x_centers[i], self.y_centers[j])\n            u2 = self._u_ex(self.x_centers[i], self.y_centers[j+1])\n            Ey = -(u2 - u1) / self.dy\n        elif is_p1_int and not is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j+1]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u1 = self._u_ex(p_int[0], p_int[1])\n            Ey = -(u_g - u1) / self.dy\n        elif not is_p1_int and is_p2_int:\n            p_int = np.array([self.x_centers[i], self.y_centers[j+1]])\n            p_ghost = np.array([self.x_centers[i], self.y_centers[j]])\n            u_g = self._compute_ghost_value(p_int, p_ghost)\n            u2 = self._u_ex(p_int[0], p_int[1])\n            Ey = -(u2 - u_g) / self.dy\n\n        return self.eps * Ey\n\n    def compute_metrics(self):\n        \"\"\"\n        Computes the spurious charge density and its RMS and MAX metrics\n        in the specified band near the interface.\n        \"\"\"\n        band_mask = (self.phi_vals = 0)  (self.phi_vals = 3 * self.hn)\n        band_indices = np.where(band_mask)\n        \n        if band_indices[0].size == 0:\n            return 0.0, 0.0\n            \n        spurious_charges = []\n        for i, j in zip(*band_indices):\n            Dx_plus = self._get_Dx(i, j)\n            Dx_minus = self._get_Dx(i - 1, j)\n            Dy_plus = self._get_Dy(i, j)\n            Dy_minus = self._get_Dy(i, j - 1)\n            \n            # rho_sp = -div(eps grad u) = div(-eps grad u) = div(eps E) = div(D)\n            div_D = (Dx_plus - Dx_minus) / self.dx + (Dy_plus - Dy_minus) / self.dy\n            spurious_charges.append(div_D)\n        \n        charges_arr = np.array(spurious_charges)\n        \n        rms = np.sqrt(np.mean(charges_arr**2))\n        max_abs = np.max(np.abs(charges_arr))\n        \n        return rms, max_abs\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, xc, yc, R, eps)\n        (64, 64, 0.5, 0.5, 0.30, 2.0),  # Case A\n        (64, 64, 0.5, 0.5, 0.12, 5.0),  # Case B\n        (32, 40, 0.5, 0.5, 0.30, 3.0),  # Case C\n        (80, 60, 0.42, 0.47, 0.35, 1.0), # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        solver = ElectrostaticsSolver(*params)\n        rms, max_abs = solver.compute_metrics()\n        results.append(f\"{rms:.8f}\")\n        results.append(f\"{max_abs:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}