{
    "hands_on_practices": [
        {
            "introduction": "理解复杂现象往往始于简化的模型。本练习将通过一个一维“玩具模型”，清晰地揭示为何对矢量场使用不恰当的节点基函数会导致伪模式的产生。通过这个实践，您将为理解更复杂的二维和三维情况下的伪模式问题建立起关键的直觉。",
            "id": "3350389",
            "problem": "考虑一个理想电导体（PEC）腔中的时谐、无源麦克斯韦本征问题，其变分形式写作：寻找电场 $\\mathbf{E} \\in H(\\mathrm{curl},\\Omega)$ 和波数 $\\kappa^{2} \\in \\mathbb{R}$，使得\n$$\n\\int_{\\Omega} \\mu^{-1} \\, (\\nabla \\times \\mathbf{E}) \\cdot (\\nabla \\times \\mathbf{v}) \\, \\mathrm{d}\\mathbf{x} \\;=\\; \\kappa^{2} \\int_{\\Omega} \\epsilon \\, \\mathbf{E}\\cdot \\mathbf{v} \\, \\mathrm{d}\\mathbf{x}\n\\quad \\text{对所有 } \\mathbf{v} \\in H(\\mathrm{curl},\\Omega),\n$$\n并在 $\\partial \\Omega$ 上满足PEC边界条件 $\\,\\mathbf{n}\\times \\mathbf{E} = \\mathbf{0}$。一个基本事实是，旋度算子的核包含所有梯度 $\\,\\nabla \\phi\\,$，其中 $\\phi \\in H^{1}_{0}(\\Omega)$，因为 $\\,\\nabla \\times \\nabla \\phi = \\mathbf{0}$。当使用不恰当的有限元空间时，这个零空间是产生伪模式的根本原因。\n\n为了在最简单的设定下揭示这一机制，请在区间 $(0,L)$ 上构建一个一维（$1$D）玩具模型，该模型模仿横电（TE）和横磁（TM）模式族的分离。用标量场 $u \\in H^{1}_{0}(0,L)$ 和以下本征问题来模拟TE模式\n$$\n\\int_{0}^{L} u'(x) \\, v'(x) \\, \\mathrm{d}x \\;=\\; \\lambda \\int_{0}^{L} u(x) \\, v(x) \\, \\mathrm{d}x \\quad \\text{对所有 } v \\in H^{1}_{0}(0,L),\n$$\n并用一个代理标量场 $w \\in H^{1}(0,L)$ 来模拟TM梯度子空间，该场旨在表示 $H(\\mathrm{curl},\\Omega)$ 中某个场的（不合规的）节点近似，同时使用双线性形式\n$$\na(w,v) \\;=\\; \\int_{0}^{L} \\big(\\mathrm{curl}\\, w\\big)\\,\\big(\\mathrm{curl}\\, v\\big)\\,\\mathrm{d}x,\n$$\n其中，在 $1$D 中，我们设定 $\\mathrm{curl}\\, w \\equiv 0$，以模仿在更高维度中标量势 $\\phi$ 的 $\\nabla \\times \\nabla \\phi$ 精确为零的情况。设 $V_{h}$ 是在 $(0,L)$ 的一个均匀剖分（$n$ 个子区间）上的连续分片线性（线性拉格朗日）函数空间，不施加本质边界条件，因此 $\\dim V_{h} = n+1$。\n\n您需要：\n- 从上述变分基础和麦克斯韦方程组出发，推导为何离散的TM代理双线性形式在 $V_{h}$ 上恒为零，从而将广义本征问题转变为一个纯质量矩阵束。\n- 证明增加一个零均值规范约束 $\\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0$ 会从 $V_{h}$ 中精确地移除一个维度，但这并不会改变所有剩余离散本征对都满足 $\\lambda = 0$ 的事实，从而明确地刻画伪本征空间。\n- 从概念层面解释，在更高维度中，使用边元（例如，第一类Nédélec单元）如何满足一个离散紧性性质，从而防止梯度场污染正谱，而节点单元则不满足。\n- 提出至少两种简单、科学上合理的测试方案，从业者可以实施这些方案来检测和量化使用有限元法（FEM）进行计算电磁学分析时出现的伪模式。您的提议应与上述推导一致，并应能分离出伪模式生成或抑制的机制。\n\n最后，取 $n = 5$，计算在施加单个零均值规范约束后，由错误的TM代理模型在 $V_h$ 上离散化所产生的伪零本征值模式的精确数量。请将您的最终答案以单个整数形式给出。无需四舍五入，也无需物理单位。",
            "solution": "该问题陈述是计算电磁学领域中一个有效练习，具体涉及有限元本征值分析中伪模式的数值病态问题。它在科学上是合理的、适定的、客观的且内部一致。它使用一个标准的教学用一维（$1$D）模型来说明在更高维度中发生的复杂现象。所有术语都得到了充分定义，足以成功完成任务。因此，我们可以着手提供完整解答。\n\n根据要求，分析分为四个部分，最后进行数值计算。\n\n### 第一部分：消失的双线性形式及随之而来的本征问题\n\n该问题使用标量场 $w$ 和双线性形式 $a(w,v)$ 定义了一个横磁（TM）模式的代理模型。该模型的有限元空间是 $V_{h}$，即在区间 $(0,L)$ 的一个包含 $n$ 个子区间的剖分上的连续分片线性拉格朗日函数空间，不施加本质边界条件。该空间的维度，对应于节点数量，为 $\\dim V_{h} = n+1$。\n\n这个 $1$D 玩具模型的关键定义是 `curl` 算子对标量场 $w$ 的作用，给定为：\n$$\n\\mathrm{curl}\\, w \\equiv 0\n$$\n这个定义是矢量微积分恒等式 $\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$ 的直接类比，其中 $1$D 模型中的标量场 $w$ 扮演了三维中标量势 $\\phi$ 的角色。$V_h$ 中的节点基函数意在模仿为 $H(\\mathrm{curl},\\Omega)$ 中的矢量场选择无效的节点单元，这种选择会无意中包含这个梯度子空间。\n\nTM代理模型的双线性形式是：\n$$\na(w,v) = \\int_{0}^{L} \\big(\\mathrm{curl}\\, w\\big)\\,\\big(\\mathrm{curl}\\, v\\big)\\,\\mathrm{d}x\n$$\n对于任意两个函数 $w_h, v_h \\in V_h$，根据给定的定义，我们有 $\\mathrm{curl}\\, w_h = 0$ 和 $\\mathrm{curl}\\, v_h = 0$。因此，被积函数恒为零：\n$$\n\\big(\\mathrm{curl}\\, w_h(x)\\big)\\,\\big(\\mathrm{curl}\\, v_h(x)\\big) = 0 \\cdot 0 = 0 \\quad \\text{对所有 } x \\in (0,L)\n$$\n因此，对于所选离散空间中的所有函数，该双线性形式均为零：\n$$\na(w_h, v_h) = \\int_{0}^{L} 0 \\,\\mathrm{d}x = 0 \\quad \\text{对所有 } w_h, v_h \\in V_h\n$$\n相应的广义本征问题是找到 $(\\lambda, w_h) \\in (\\mathbb{R}, V_h)$，使得对所有 $v_h \\in V_h$：\n$$\na(w_h, v_h) = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\n代入 $a(w_h, v_h)=0$ 的结果，方程变为：\n$$\n0 = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\n在有限元背景下，这被写成矩阵本征问题 $\\mathbf{K}\\mathbf{c} = \\lambda \\mathbf{M}\\mathbf{c}$。刚度矩阵 $\\mathbf{K}$ 的元素为 $K_{ij} = a(\\phi_i, \\phi_j)$，其中 $\\{\\phi_i\\}$ 是 $V_h$ 的基。根据我们的推导，$\\mathbf{K}$ 是零矩阵。质量矩阵 $\\mathbf{M}$ 的元素为 $M_{ij} = \\int_{0}^{L} \\phi_i \\phi_j \\,\\mathrm{d}x$。由于基函数 $\\{\\phi_i\\}$ 是线性无关的，质量矩阵 $\\mathbf{M}$ 是对称正定的。\n\n本征问题 $0 = \\lambda \\mathbf{M}\\mathbf{c}$ 意味着对于任何非零本征向量 $\\mathbf{c}$，我们必须有 $\\lambda = 0$。由于这对 $(n+1)$ 维空间中的任何向量都成立，整个空间 $V_h$ 是对应于本征值 $\\lambda=0$ 的一个本征空间。这意味着离散化产生了 $\\dim(V_h) = n+1$ 个伪模式，它们的本征值都为零。\n\n### 第二部分：零均值规范约束的效果\n\n引入一个规范约束：\n$$\n\\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0\n$$\n我们定义一个新空间 $V_h^0 = \\{w_h \\in V_h \\mid \\int_{0}^{L} w_{h}(x)\\,\\mathrm{d}x = 0\\}$。$V_h$ 中的任何函数 $w_h$ 都可以表示为基函数 $\\phi_i$（$i=0, 1, \\dots, n$）的线性组合：$w_h(x) = \\sum_{i=0}^{n} c_i \\phi_i(x)$。该约束变为对系数 $c_i$ 的一个线性方程：\n$$\n\\sum_{i=0}^{n} c_i \\left( \\int_{0}^{L} \\phi_i(x)\\,\\mathrm{d}x \\right) = 0\n$$\n由于标准的拉格朗日“帽子”基函数是非负的且不恒为零，它们的积分是正的。这是一个作用于 $(n+1)$ 维系数空间上的非平凡线性约束。单个线性约束会使向量空间的维度精确地减少一。因此，约束空间的维度是：\n$$\n\\dim(V_h^0) = \\dim(V_h) - 1 = (n+1) - 1 = n\n$$\n本征问题现在是在这个更小的空间上提出的：找到 $(\\lambda, w_h) \\in (\\mathbb{R}, V_h^0)$，使得对所有 $v_h \\in V_h^0$，有 $a(w_h, v_h) = \\lambda \\int_0^L w_h v_h \\,dx$。\n$a(w_h, v_h) = 0$ 这个基本性质不受函数积分约束的影响。它对 $V_h^0 \\subset V_h$ 中的所有函数仍然成立。因此，约束空间上的本征问题仍然是\n$$\n0 = \\lambda \\int_{0}^{L} w_h(x) v_h(x) \\,\\mathrm{d}x\n$$\n对所有 $v_h \\in V_h^0$ 成立。对于任何非零本征函数 $w_h \\in V_h^0$，本征值 $\\lambda$ 必须为零。整个 $n$ 维空间 $V_h^0$ 是 $\\lambda=0$ 的本征空间。该约束移除了一个伪模式，但仍剩下 $n$ 个伪模式。这明确地将伪本征空间刻画为零均值、连续、分片线性函数的空间，其维度为 $n$。\n\n### 第三部分：通过边元抑制伪模式\n\n在更高维度（$2$D和$3$D）中，问题的根源在于某些有限元空间无法正确表示旋度算子的零空间。具有平方可积旋度的平方可积矢量场空间记为 $H(\\mathrm{curl},\\Omega)$。在连续设定下，旋度算子的零空间恰好是梯度场集合：$\\{\\mathbf{u} \\in L^2(\\Omega) \\mid \\nabla \\times \\mathbf{u} = \\mathbf{0}\\} = \\{\\nabla \\phi \\mid \\phi \\in H^1(\\Omega)\\}$。\n\n当使用**节点单元**离散化矢量场 $\\mathbf{E}$ 时，通常会将矢量值自由度分配给网格的节点。得到的有限元空间，我们称之为 $\\mathbf{V}_h^{\\text{nodal}}$，包含一个大的离散梯度子空间，即形如 $\\nabla \\phi_h$ 的场，其中 $\\phi_h$ 是一个标准的标量（例如，拉格朗日）有限元函数。然而，对于 $\\mathbf{V}_h^{\\text{nodal}}$ 中的一个一般函数 $\\mathbf{v}_h$，性质 $\\nabla \\times (\\nabla \\phi_h) = \\mathbf{0}$ 在离散层面上不被保持，意味着离散梯度的离散旋度不一定为零。刚度矩阵 $\\mathbf{K}$ 的元素为 $K_{ij} = \\int_{\\Omega} (\\nabla \\times \\mathbf{v}_i) \\cdot (\\nabla \\times \\mathbf{v}_j) \\,d\\mathbf{x}$，它会获得一个大的、数值上近似的零空间，这个零空间与真实的解析零空间不准确对应。这种不匹配会用非物理的伪模式污染计算出的谱。\n\n**边元**（例如，第一类Nédélec单元）是专门为避免此问题而设计的。它们的自由度不是节点值，而是矢量场沿网格单元边的切向分量。这种构造确保了场的切向分量在单元界面上是连续的，这正是 $H(\\mathrm{curl},\\Omega)$ 中场需要满足的连续性要求。由此产生的有限元空间，我们称之为 $\\mathbf{V}_h^{\\text{edge}}$，拥有一个关键性质，通常用一个交换图来表示。这个性质是有限元外微分（FEEC）的基础，它确保了离散梯度的离散旋度精确为零。也就是说，如果取一个标量拉格朗日空间 $S_h$ 和Nédélec边元空间 $\\mathbf{V}_h^{\\text{edge}}$，那么：\n$$\n\\nabla \\times (\\nabla \\phi_h) = \\mathbf{0} \\quad \\text{对所有 } \\phi_h \\in S_h\n$$\n这意味着 $\\mathbf{V}_h^{\\text{edge}}$ 内的离散旋度零空间恰好是离散梯度空间 $\\{\\nabla\\phi_h \\mid \\phi_h \\in S_h\\}$。这个性质，通常被称为构造了一个稳定且协调的上链复形，确保了离散刚度算子的核与其谱的其余部分被清晰地分离开来。与这些单元相关的“离散紧性性质”保证了谱的非零部分的近似是收敛的且没有伪模式。对应于梯度场的零本征值模式被正确捕获，并且不会污染具有物理意义的正本征值。\n\n### 第四部分：建议的测试方案\n\n以下是两种科学上合理的测试方案，用于检测和量化计算电磁学有限元代码中的伪模式。\n\n**1. 规范腔谐振测试**\n- **原理**：此测试将数值结果与已知的解析解进行比较。具有理想电导体（PEC）壁的矩形（或长方体）腔是理想的候选者，因为其谐振频率和模式结构（TE和TM）是精确已知的。\n- **实施**：\n    1.  对一个尺寸为 $a \\times b$ 的二维矩形腔或尺寸为 $a \\times b \\times c$ 的三维长方体腔进行建模。在所有壁上施加PEC边界条件（$\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$）。\n    2.  使用有限元代码计算最低的，例如，$20-50$ 个本征对 $(\\kappa_i^2, \\mathbf{E}_i)$。\n    3.  解析上，本征值由 $\\kappa^2_{mnp} = (\\frac{m\\pi}{a})^2 + (\\frac{n\\pi}{b})^2 + (\\frac{p\\pi}{c})^2$ 给出，其中 $m,n,p$ 是定义模式阶数的整数（对TE/TM族有适当的限制）。\n- **检测与量化**：通过两种方式识别伪模式：\n    a. **谱污染**：计算出的本征值列表中将包含与任何解析 $\\kappa^2_{mnp}$ 值不匹配的值。这些就是伪模式。\n    b. **零空间维度**：一个行为良好的离散化（如使用边元）将产生一簇对应于梯度场的零本征值，与正的物理本征值清晰分离。不恰当的离散化（如使用节点单元）将产生大量零或接近零的本征值。可以计算这些模式的数量，并与离散梯度空间的理论维度进行比较，对于节点单元，该维度约等于内部网格节点的数量。\n\n**2. 散度检查测试**\n- **原理**：此测试利用了本征模式的一个物理性质。在无源区域（$\\rho=0$）中，麦克斯韦方程要求物理电场模式是无散的：$\\nabla \\cdot (\\epsilon \\mathbf{E}) = 0$。由不正确处理梯度零空间而产生的伪模式通常会显著违反此条件。\n- **实施**：\n    1.  对任何合理的腔体几何（测试1中的规范腔是合适的）求解本征问题。\n    2.  对每个计算出的本征模式 $\\mathbf{E}_i$，计算其散度的 $L^2$-范数：$D_i = ||\\nabla \\cdot \\mathbf{E}_i||_{L^2} = (\\int_{\\Omega} |\\nabla \\cdot \\mathbf{E}_i|^2 \\,d\\mathbf{x})^{1/2}$。请注意，散度应逐单元计算，因为 $H(\\mathrm{curl})$ 中的场不一定具有全局定义的、平方可积的散度。\n    3.  绘制计算出的本征值 $\\kappa_i^2$ 与其对应的散度范数 $D_i$ 的关系图。\n- **检测与量化**：得到的散点图通常会显示两个不同的群体：\n    a. **物理模式**：这些点将表现为具有正本征值（$\\kappa_i^2 > 0$）和非常小的散度范数（$D_i \\approx 0$）。\n    b. **伪模式**：这些点将表现为具有大散度范数（$D_i \\gg 0$）。它们对应的本征值可能是零或非零，污染了整个谱。\n    从业者可以设置一个散度阈值来以编程方式识别和计数伪模式，从而量化求解器和离散化选择的质量。\n\n### 最终计算\n\n问题要求在施加单个零均值规范约束后，对于网格由 $n=5$ 个子区间组成的特定情况，由错误的TM代理模型在空间 $V_h$ 上离散化所产生的伪零本征值模式的数量。\n\n正如在第二部分中所确立的：\n1.  在包含 $n$ 个单元的网格上，无边界条件的连续分片线性函数初始空间 $V_h$ 的维度为 $n+1$。\n2.  双线性形式 $a(w_h, v_h)$ 在此空间中的所有函数上恒为零，这意味着每个非零函数都是本征值为 $\\lambda=0$ 的本征向量。伪模式的初始数量为 $n+1$。\n3.  单个规范约束 $\\int_0^L w_h(x) dx = 0$ 是一个非平凡的线性约束，它将空间的维度减少了 $1$。\n4.  剩余伪模式的数量是约束空间的维度，即 $(n+1) - 1 = n$。\n\n给定参数 $n = 5$：\n伪零本征值模式的数量为 $n=5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "在理解了伪模式的成因之后，我们将探讨如何在实践中处理它们。本练习将对比两种不同的有限元离散化方法：一种是“无伪模式”的相容性边缘元方法，另一种是灵活但可能引入伪模式的非相容间断伽辽金(DG)方法。您将通过代数模型实现这两种方法，并亲眼见证DG方法中的稳定化参数对于抑制伪模式的关键作用。",
            "id": "3350338",
            "problem": "考虑在单位正方形域上，带有理想电导体 (PEC) 边界条件的二维无源时谐 Maxwell 旋度-旋度特征问题。该偏微分方程是一个广义特征问题\n$$\n\\nabla \\times \\left( \\nabla \\times \\mathbf{E} \\right) = \\lambda \\, \\mathbf{E}\n$$\n边界条件为\n$$\n\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0} \\quad \\text{在边界上},\n$$\n其中 $\\mathbf{n}$ 是单位外法向量。未知量 $\\mathbf{E}$ 位于 Sobolev 空间 $H(\\mathrm{curl})$ 中。在一个具有 $x$ 方向 $N_x$ 个单元和 $y$ 方向 $N_y$ 个单元的结构化四边形网格的离散设置中，我们通过比较两种离散化方法来研究有限元特征问题中的伪模式抑制：\n\n- 一种协调的 $H(\\mathrm{curl})$ 边离散化方法，它强制场在网格边上切向连续，并有效地代表了一种标准的边元公式。\n- 一种非协调的 $H(\\mathrm{curl})$ 间断 Galerkin (DG) 离散化方法，使用迎风型数值通量和一个稳定化参数 $\\tau$ 来惩罚单元间的切向跳跃。\n\n目标是调整稳定化参数 $\\tau$ 以抑制非物理梯度模式（伪模式），并将得到的近零特征谱与同一网格上的协调边离散化结果进行比较。\n\n从 Stokes 定理和旋度-旋度算子的弱形式出发，考虑在结构化网格上进行以下纯代数模拟构造：\n\n1. 协调边离散化。为每条唯一的网格边引入一个自由度，代表 $\\mathbf{E}$ 的切向分量对一个合适的检验函数积分的结果。对于每个由 $(i,j)$ 索引的单元（其中 $i \\in \\{0,\\dots,N_x-1\\}$ 且 $j \\in \\{0,\\dots,N_y-1\\}$），将离散标量旋度定义为一个定向边求和：\n$$\nc_{i,j} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i+1,j} - e^{\\mathrm{top}}_{i,j+1} - e^{\\mathrm{left}}_{i,j},\n$$\n其中 $e^{\\mathrm{bot}}_{i,j}$、$e^{\\mathrm{right}}_{i+1,j}$、$e^{\\mathrm{top}}_{i,j+1}$ 和 $e^{\\mathrm{left}}_{i,j}$ 分别表示单元 $(i,j)$ 的底、右、顶、左边上的切向自由度，并具有一致的方向。设 $B$ 是将边未知量向量映射到单元旋度向量的矩阵，即 $c = B \\, e$。则协调刚度矩阵和质量矩阵为\n$$\nK_{\\mathrm{conf}} = B^\\top B, \\quad M_{\\mathrm{conf}} = I,\n$$\n并通过移除边界边未知量（即在强制施加 $\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$ 的地方消除 Dirichlet 自由度）来施加 PEC 边界条件。\n\n2. 非协调 DG $H(\\mathrm{curl})$ 离散化。为每个单元引入四个自由度，每个定向的局部边（底、右、顶、左）各一个。对于每个单元 $(i,j)$，将局部离散旋度定义为\n$$\nc_{i,j}^{\\mathrm{loc}} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i,j} - e^{\\mathrm{top}}_{i,j} - e^{\\mathrm{left}}_{i,j}.\n$$\n设 $B_{i,j}$ 是将单元局部边未知量映射到局部旋度的 $1 \\times 4$ 行向量 $[+1, +1, -1, -1]$。块对角的局部刚度为\n$$\nK_{\\mathrm{loc}} = \\bigoplus_{i,j} B_{i,j}^\\top B_{i,j}.\n$$\n为了弱强制单元间的一致性并抑制伪梯度模式，在内部边上引入关于切向跳跃的迎风型稳定化。对于下部单元 $(i,j-1)$ 和上部单元 $(i,j)$ 之间的每个内部水平共享边，惩罚上部单元底边和下部单元顶边之间的跳跃；对于左侧单元 $(i-1,j)$ 和右侧单元 $(i,j)$ 之间的每个内部垂直共享边，惩罚左侧单元右边和右侧单元左边之间的跳跃。产生的稳定化算子为\n$$\nS(\\tau) = \\tau \\sum_{e \\in \\Gamma_{\\mathrm{int}}} \\left( u^+_e - u^-_e \\right)^2,\n$$\n它在每条内部边上的成对自由度上离散地贡献形如\n$$\n\\begin{bmatrix} \\tau & -\\tau \\\\ -\\tau & \\tau \\end{bmatrix}\n$$\n的 $2 \\times 2$ 块，其中 $\\Gamma_{\\mathrm{int}}$ 表示内部边的集合，$u^\\pm_e$ 是来自相邻单元的切向迹。DG 刚度矩阵和质量矩阵为\n$$\nK_{\\mathrm{DG}}(\\tau) = K_{\\mathrm{loc}} + S(\\tau), \\quad M_{\\mathrm{DG}} = I.\n$$\nPEC 边界条件通过在每个单元的层面上移除边界边未知量来施加。\n\n对于两种离散化，考虑离散广义特征值问题\n$$\nK \\, x = \\lambda \\, M \\, x,\n$$\n当 $M = I$ 时，该问题简化为标准对称特征值问题。将伪模式或类梯度模式的数值诊断定义为小于小阈值 $\\varepsilon$ 的特征值的数量：\n$$\nN_{\\mathrm{near0}} = \\# \\{ \\lambda \\mid \\lambda < \\varepsilon \\}.\n$$\n\n在同一网格上为两种离散化实现上述代数算子，并对以下测试套件（$\\varepsilon = 10^{-8}$）计算 $N_{\\mathrm{near0}}$：\n\n- 测试用例 1：非协调 DG，其中 $N_x = 2$, $N_y = 2$, $\\tau = 0$。\n- 测试用例 2：非协调 DG，其中 $N_x = 2$, $N_y = 2$, $\\tau = 5$。\n- 测试用例 3：非协调 DG，其中 $N_x = 3$, $N_y = 2$, $\\tau = 100$。\n- 测试用例 4：协调边离散化，其中 $N_x = 2$, $N_y = 2$。\n\n你的程序必须生成一行输出，其中包含测试套件的结果，形式为方括号内的逗号分隔整数列表，并严格按照上面给出的顺序（例如 $[n_1,n_2,n_3,n_4]$）。不涉及物理单位；所有量都是无量纲的。不出现角度。不使用百分比。最终输出是整数。",
            "solution": "出发点是旋度-旋度形式的无源时谐 Maxwell 方程。在二维域上，带有理想电导体 (PEC) 边界条件时，该特征问题寻找非平凡的 $\\mathbf{E} \\in H(\\mathrm{curl})$ 和 $\\lambda \\in \\mathbb{R}$，使得\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{E}) = \\lambda \\, \\mathbf{E}, \\quad \\mathbf{n} \\times \\mathbf{E} = \\mathbf{0} \\text{ 在 } \\partial \\Omega \\text{ 上}.\n$$\n关键的数值挑战在于，梯度场（即 $\\mathbf{E} = \\nabla \\phi$）的旋度为零，并且可能作为非物理模式出现。在协调的 $H(\\mathrm{curl})$ 边空间中，这些梯度场位于旋度-旋度算子的核空间内，不会污染非零特征值。在没有足够稳定化的非协调间断 Galerkin (DG) 公式中，由于允许切向分量存在跳跃，可能会出现额外的逐单元类梯度零空间，从而扩大了离散核。通过耦合单元并将零空间缩减到物理上一致的梯度子空间，惩罚切向跳跃可以抑制这些伪模式。\n\n原理与构造：\n\n1. 根据平面上的 Stokes 定理，旋度在一个单元上的积分等于 $\\mathbf{E}$ 的切向分量沿该单元边界的环路积分：\n$$\n\\int_{\\kappa_{i,j}} (\\nabla \\times \\mathbf{E}) \\, \\mathrm{d}A = \\oint_{\\partial \\kappa_{i,j}} \\mathbf{E} \\cdot \\mathrm{d}\\boldsymbol{\\ell}.\n$$\n一个一致的模拟离散版本是通过边未知量（切向自由度）的定向和来表示旋度，对于协调离散化，这产生了映射 $c = B \\, e$，其中 $B$ 的每一行包含对应于一个单元四条边的定向贡献的系数 $+1$ 或 $-1$。\n\n2. 协调刚度 $K_{\\mathrm{conf}} = B^\\top B$ 是旋度 $L^2$ 范数（即 $\\sum_{\\kappa} c_{\\kappa}^2$）的离散模拟，而 $M_{\\mathrm{conf}} = I$ 是一个简单的集中质量矩阵。通过消除边界边自由度（Dirichlet 消除），将算子限制在内部边未知量上，来施加边界上的 $\\mathbf{n} \\times \\mathbf{E} = \\mathbf{0}$。在这种设置下，任何与边界条件一致的离散梯度场在每个单元上产生的环量都为零，因此位于 $K_{\\mathrm{conf}}$ 的核中，但这些不会导致伪非零特征值。\n\n3. 非协调 DG $H(\\mathrm{curl})$ 公式引入了逐单元边未知量 $(e^{\\mathrm{bot}}, e^{\\mathrm{right}}, e^{\\mathrm{top}}, e^{\\mathrm{left}})$，局部离散旋度为\n$$\nc_{i,j}^{\\mathrm{loc}} = e^{\\mathrm{bot}}_{i,j} + e^{\\mathrm{right}}_{i,j} - e^{\\mathrm{top}}_{i,j} - e^{\\mathrm{left}}_{i,j}.\n$$\n局部刚度 $K_{\\mathrm{loc}}$ 是块对角的，其 $4 \\times 4$ 块等于 $B_{i,j}^\\top B_{i,j}$，其中 $B_{i,j} = [1, 1, -1, -1]$。在没有稳定化（$\\tau = 0$）的情况下，每个局部块的秩为 1，产生一个维度为 3 的大的逐单元零空间，这在全局组装时会导致大量近零特征值。\n\n4. 用于旋度算子的 DG 中的迎风型数值通量贡献了惩罚内部边上切向跳跃的项。在代数原型中，我们通过添加稳定化算子来对此建模\n$$\nS(\\tau) = \\tau \\sum_{e \\in \\Gamma_{\\mathrm{int}}} \\left( u^+_e - u^-_e \\right)^2,\n$$\n该算子以矩阵形式，在每个内部共享边上的自由度对上添加\n$$\n\\begin{bmatrix} \\tau & -\\tau \\\\ -\\tau & \\tau \\end{bmatrix}\n$$\n的 $2 \\times 2$ 块。这耦合了相邻的单元并抑制了逐单元的类梯度模式，将离散核缩小到物理上一致的梯度子空间。通过消除每个单元的边界边未知量（$j=0$ 时的底边，$j=N_y-1$ 时的顶边，$i=0$ 时的左边，以及 $i=N_x-1$ 时的右边）来施加 PEC 边界条件。\n\n算法设计与计算：\n\n- 网格索引。对于协调离散化，用 $(i,j)$（其中 $i \\in \\{0,\\dots,N_x-1\\}$ 且 $j \\in \\{0,\\dots,N_y\\}$）索引唯一的水平边，用 $(i,j)$（其中 $i \\in \\{0,\\dots,N_x\\}$ 且 $j \\in \\{0,\\dots,N_y-1\\}$）索引唯一的垂直边。通过为每个单元的底边和右边分配系数 $+1$、为顶边和左边分配系数 $-1$ 来构建映射矩阵 $B$，并与方向保持一致。通过只选择内部边来施加 PEC：水平边 $j \\in \\{1,\\dots,N_y-1\\}$ 和垂直边 $i \\in \\{1,\\dots,N_x-1\\}$。在简化的内部边集合上形成 $K_{\\mathrm{conf}} = B^\\top B$。\n\n- 对于 DG 离散化，每个单元用 4 个未知量索引其逐单元局部边。通过在每个单元的局部边块上为 $b = [1, 1, -1, -1]$ 添加 $\\mathrm{outer}(b,b)$ 来组装 $K_{\\mathrm{loc}}$。通过遍历内部共享边（水平和垂直）并在成对的自由度上添加 $\\tau [[1,-1],[-1,1]]$ 来组装稳定化项 $S(\\tau)$。通过移除逐单元边界边未知量来施加 PEC。在简化的未知量集合上形成 $K_{\\mathrm{DG}}(\\tau)$。\n\n- 特征值分析。当 $M = I$ 时，求解对称特征值问题 $K x = \\lambda x$ 并计算小于 $\\varepsilon = 10^{-8}$ 的特征值数量：\n$$\nN_{\\mathrm{near0}} = \\# \\{ \\lambda \\mid \\lambda < \\varepsilon \\}.\n$$\n较大的 $N_{\\mathrm{near0}}$ 表示存在更多的伪模式或类梯度模式。随着 $\\tau$ 的增加，DG 离散化的 $N_{\\mathrm{near0}}$ 应该减小并接近协调基线，这表明逐单元伪梯度模式被抑制。\n\n测试套件与输出。对以下情况计算 $N_{\\mathrm{near0}}$：\n\n- 测试用例 1：DG，其中 $(N_x, N_y, \\tau) = (2, 2, 0)$。\n- 测试用例 2：DG，其中 $(N_x, N_y, \\tau) = (2, 2, 5)$。\n- 测试用例 3：DG，其中 $(N_x, N_y, \\tau) = (3, 2, 100)$。\n- 测试用例 4：协调离散化，其中 $(N_x, N_y) = (2, 2)$。\n\n生成单行输出：$[n_1,n_2,n_3,n_4]$，其中 $n_k$ 是第 k 个测试用例的近零特征值的整数计数。\n\n这种设计是基于原理的：它从弱形式和 Stokes 定理出发，通过定向边积分构造离散旋度算子，并结合 DG 通量稳定化来抑制非协调梯度模式。代数模拟算子捕捉了 $H(\\mathrm{curl})$ 离散化的基本行为，并允许进行一个清晰、可测试的、专注于伪模式抑制的比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_conforming_K(Nx: int, Ny: int) -> np.ndarray:\n    \"\"\"\n    Assemble the conforming mimetic curl-curl stiffness K = B^T B for a structured grid.\n    PEC boundary conditions are enforced by eliminating boundary edge DOFs.\n    \"\"\"\n    # Index unique horizontal edges: i=0..Nx-1, j=0..Ny\n    h_idx = -np.ones((Nx, Ny + 1), dtype=int)\n    # Index unique vertical edges: i=0..Nx, j=0..Ny-1\n    v_idx = -np.ones((Nx + 1, Ny), dtype=int)\n\n    idx = 0\n    for j in range(Ny + 1):\n        for i in range(Nx):\n            h_idx[i, j] = idx\n            idx += 1\n    for j in range(Ny):\n        for i in range(Nx + 1):\n            v_idx[i, j] = idx\n            idx += 1\n    n_edges = idx\n\n    # Build B mapping edge DOFs to cell curls\n    n_cells = Nx * Ny\n    B = np.zeros((n_cells, n_edges), dtype=float)\n    r = 0\n    for j in range(Ny):\n        for i in range(Nx):\n            bottom = h_idx[i, j]\n            right = v_idx[i + 1, j]\n            top = h_idx[i, j + 1]\n            left = v_idx[i, j]\n            # Oriented sum: bottom + right - top - left\n            B[r, bottom] += 1.0\n            B[r, right] += 1.0\n            B[r, top]   -= 1.0\n            B[r, left]  -= 1.0\n            r += 1\n\n    # Interior edge DOFs (PEC: remove boundary edges)\n    interior = []\n    # Horizontal interior edges: j = 1..Ny-1\n    for j in range(1, Ny):\n        for i in range(Nx):\n            interior.append(h_idx[i, j])\n    # Vertical interior edges: i = 1..Nx-1\n    for j in range(Ny):\n        for i in range(1, Nx):\n            interior.append(v_idx[i, j])\n    interior = np.array(interior, dtype=int)\n\n    # Reduced operator\n    B_red = B[:, interior]\n    K_conf = B_red.T @ B_red\n    return K_conf\n\ndef assemble_DG_K(Nx: int, Ny: int, tau: float) -> np.ndarray:\n    \"\"\"\n    Assemble the nonconforming DG H(curl) mimetic curl-curl stiffness:\n    K_DG(tau) = K_loc + S(tau), with PEC enforced by eliminating per-cell boundary edge DOFs.\n    Local edge ordering per cell: [bottom, right, top, left].\n    \"\"\"\n    n_cells = Nx * Ny\n    n_dofs = 4 * n_cells\n    K = np.zeros((n_dofs, n_dofs), dtype=float)\n\n    # Local cell contributions: B_cell = [1, 1, -1, -1], K_loc += B^T B\n    for j in range(Ny):\n        for i in range(Nx):\n            cell_id = j * Nx + i\n            edofs = [4 * cell_id + s for s in range(4)]\n            b = np.array([1.0, 1.0, -1.0, -1.0])\n            K[np.ix_(edofs, edofs)] += np.outer(b, b)\n\n    # Stabilization across interior shared edges: tau * [[1,-1],[-1,1]]\n    # Horizontal shared edges: lower cell (j-1) top vs upper cell (j) bottom\n    for j in range(1, Ny):\n        for i in range(Nx):\n            lower = (j - 1) * Nx + i\n            upper = j * Nx + i\n            dof_lower_top = 4 * lower + 2  # top of lower cell\n            dof_upper_bottom = 4 * upper + 0  # bottom of upper cell\n            K[dof_lower_top, dof_lower_top] += tau\n            K[dof_upper_bottom, dof_upper_bottom] += tau\n            K[dof_lower_top, dof_upper_bottom] -= tau\n            K[dof_upper_bottom, dof_lower_top] -= tau\n    # Vertical shared edges: left cell (i-1) right vs right cell (i) left\n    for j in range(Ny):\n        for i in range(1, Nx):\n            left = j * Nx + (i - 1)\n            right = j * Nx + i\n            dof_left_right = 4 * left + 1   # right of left cell\n            dof_right_left = 4 * right + 3  # left of right cell\n            K[dof_left_right, dof_left_right] += tau\n            K[dof_right_left, dof_right_left] += tau\n            K[dof_left_right, dof_right_left] -= tau\n            K[dof_right_left, dof_left_right] -= tau\n\n    # Enforce PEC by removing boundary edge DOFs per cell\n    keep = np.ones(n_dofs, dtype=bool)\n    for j in range(Ny):\n        for i in range(Nx):\n            cell_id = j * Nx + i\n            # Bottom boundary (j == 0): remove bottom\n            if j == 0:\n                keep[4 * cell_id + 0] = False\n            # Top boundary (j == Ny-1): remove top\n            if j == Ny - 1:\n                keep[4 * cell_id + 2] = False\n            # Left boundary (i == 0): remove left\n            if i == 0:\n                keep[4 * cell_id + 3] = False\n            # Right boundary (i == Nx-1): remove right\n            if i == Nx - 1:\n                keep[4 * cell_id + 1] = False\n\n    K_red = K[np.ix_(keep, keep)]\n    return K_red\n\ndef count_near_zero_eigs(K: np.ndarray, eps: float = 1e-8) -> int:\n    \"\"\"\n    Compute symmetric eigenvalues of K and count those below eps.\n    \"\"\"\n    if K.size == 0:\n        return 0\n    w = np.linalg.eigvalsh(K)\n    return int(np.sum(w < eps))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (\"DG\" or \"CONF\", Nx, Ny, tau)\n    test_cases = [\n        (\"DG\",   2, 2, 0.0),    # Test case 1\n        (\"DG\",   2, 2, 5.0),    # Test case 2\n        (\"DG\",   3, 2, 100.0),  # Test case 3\n        (\"CONF\", 2, 2, None),   # Test case 4\n    ]\n\n    eps = 1e-8\n    results = []\n    for method, Nx, Ny, tau in test_cases:\n        if method == \"CONF\":\n            K = assemble_conforming_K(Nx, Ny)\n            count = count_near_zero_eigs(K, eps=eps)\n        elif method == \"DG\":\n            K = assemble_DG_K(Nx, Ny, tau=float(tau))\n            count = count_near_zero_eigs(K, eps=eps)\n        else:\n            raise ValueError(\"Unknown method.\")\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "罚函数法是抑制伪模式、强制满足无散度条件的一种常用且强大的技术。本练习利用一个简化的分块矩阵模型，来定量分析选择罚参数 $\\alpha$ 时所涉及的权衡。您将研究 $\\alpha$ 如何影响物理特征值的准确性，并探索其最优的缩放关系，从而深入理解该方法的实际应用。",
            "id": "3350403",
            "problem": "考虑在有界域内具有理想导体边界条件的无源频域麦克斯韦特征问题，以电场形式表述如下：找到非平凡场 $\\mathbf{E}$ 和频率 $\\omega$，使得\n$$\n\\nabla \\times \\left(\\mu^{-1} \\nabla \\times \\mathbf{E}\\right) = \\omega^2 \\, \\epsilon \\, \\mathbf{E}, \\quad \\text{其中} \\quad \\nabla \\cdot (\\epsilon \\mathbf{E}) = 0,\n$$\n其中 $\\epsilon$ 是介电常数，$\\mu$ 是磁导率。在那些不精确强制执行无散度约束 $\\nabla \\cdot (\\epsilon \\mathbf{E})=0$ 的有限元离散化中，伪模会污染谱，除非该约束被精确执行（例如，通过拉格朗日乘子或投影到无散度子空间）或通过添加到双线性形式中的罚项来弱执行：\n$$\na_{\\alpha}(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} \\mu^{-1} \\left(\\nabla \\times \\mathbf{E}_h\\right)\\cdot\\left(\\nabla \\times \\mathbf{v}_h\\right) \\, d\\Omega + \\alpha \\int_{\\Omega} \\left(\\nabla \\cdot (\\epsilon \\mathbf{E}_h)\\right)\\left(\\nabla \\cdot (\\epsilon \\mathbf{v}_h)\\right) \\, d\\Omega,\n$$\n其中 $\\alpha>0$ 是罚参数强度，$\\mathbf{E}_h, \\mathbf{v}_h$ 是有限元试探场和检验场。罚项会修改离散算子并扰动真实特征值。一个核心的高阶问题是，量化真实特征值的扰动作为 $\\alpha$、网格尺寸 $h$ 和多项式次数 $p$ 的函数，并提出和检验一个关于 $\\alpha$ 的 $h$–$p$ 标度律，该标度律能在渐近抑制伪模的同时，最小化对物理特征值的扰动。\n\n为使此问题在计算上具体且可普遍实现，考虑以下捕捉物理（无散度）子空间与伪（梯度）子空间之间相互作用的、有原则的分块结构离散模型。设离散场空间分解为维度为 $n_{\\mathrm{phys}}$ 的物理子空间和维度为 $n_{\\mathrm{grad}}$ 的梯度子空间的直和。定义对称分块算子\n$$\n\\mathbf{A}_{\\alpha}(h,p) = \n\\begin{bmatrix}\n\\mathbf{\\Lambda} & \\beta(h,p)\\,\\mathbf{C} \\\\\n\\beta(h,p)\\,\\mathbf{C}^{\\top} & \\alpha \\mathbf{I}_{n_{\\mathrm{grad}}}\n\\end{bmatrix},\n$$\n其中：\n- $\\mathbf{\\Lambda} \\in \\mathbb{R}^{n_{\\mathrm{phys}} \\times n_{\\mathrm{phys}}}$ 是对角矩阵，其对角线元素为真实的物理特征值 $\\lambda_1, \\ldots, \\lambda_{n_{\\mathrm{phys}}}$，\n- $\\mathbf{C} \\in \\mathbb{R}^{n_{\\mathrm{phys}} \\times n_{\\mathrm{grad}}}$ 模拟由离散化引起的物理分量与伪分量之间的耦合，\n- $\\beta(h,p)$ 编码了物理-伪耦合的幅度，是网格尺寸 $h$ 和多项式次数 $p$ 的函数，\n- $\\alpha>0$ 是罚参数强度，$\\mathbf{I}_{n_{\\mathrm{grad}}}$ 是梯度子空间中的单位矩阵。\n\n在精确执行约束的情况下，算子简化为在物理子空间上的限制，\n$$\n\\mathbf{A}_{\\mathrm{exact}} = \\mathbf{\\Lambda},\n$$\n此时特征值恰好为 $\\lambda_1,\\ldots,\\lambda_{n_{\\mathrm{phys}}}$。在使用有限 $\\alpha$ 的罚方法执行时，物理特征值会受到非对角耦合 $\\beta(h,p)\\,\\mathbf{C}$ 的扰动。\n\n为解决此问题，取：\n- $n_{\\mathrm{phys}}=6$ 和 $n_{\\mathrm{grad}}=4$，\n- $\\mathbf{\\Lambda} = \\mathrm{diag}\\left(\\lambda_1,\\ldots,\\lambda_6\\right)$，其中 $\\lambda_k = \\pi^2 \\cdot s_k$ 且 $(s_1,\\ldots,s_6) = (2,5,8,10,13,17)$，\n- $\\mathbf{C}$ 等于一个 $6\\times 4$ 矩阵，其前四个对角线元素为1，其余元素为0（即，对于 $i=1,2,3,4$，$C_{ii}=1$，否则为0），\n- $\\beta(h,p) = \\dfrac{h^p}{p}$。\n\n令 $\\lambda_k^{\\alpha}(h,p)$ 表示 $\\mathbf{A}_{\\alpha}(h,p)$ 按非降序排列的前 $n_{\\mathrm{phys}}$ 个特征值，并定义由罚方法执行引起的真实物理特征值的相对扰动为\n$$\n\\delta(h,p,\\alpha) = \\max_{1\\le k\\le n_{\\mathrm{phys}}} \\left| \\frac{\\lambda_k^{\\alpha}(h,p) - \\lambda_k}{\\lambda_k} \\right|.\n$$\n\n任务：\n1. 实现上述分块结构模型算子，并为给定的 $(h,p,\\alpha)$ 计算受扰动的特征值。\n2. 对下面的测试套件中的每种情况，量化最大相对扰动 $\\delta(h,p,\\alpha)$。\n3. 提出一个最优标度律 $\\alpha_{\\mathrm{opt}}(h,p)$，该标度律在抑制伪耦合的同时控制特征值扰动。使用涉及逼近性质和反不等式的第一性原理推导来证明你的提议。将你提出的定律实现为 $\\alpha_{\\mathrm{opt}}(h,p) = c \\, \\dfrac{p^2}{h^2}$，其中 $c=1$，并对每个测试用例，也计算 $\\delta\\big(h,p,\\alpha_{\\mathrm{opt}}(h,p)\\big)$。\n\n使用以下参数值测试套件，它涵盖了代表性、边界和极端场景：\n- 情况1（理想路径，中等网格，低阶，弱罚）：$(h,p,\\alpha) = (0.5,\\,1,\\,0.1)$，\n- 情况2（中度加密网格，中等阶数，未遵循建议标度律的中等罚）：$(h,p,\\alpha) = (0.25,\\,2,\\,1.0)$，\n- 情况3（加密网格，高阶，强罚）：$(h,p,\\alpha) = (0.125,\\,3,\\,100.0)$。\n\n你的程序应该对每种情况计算两个浮点数：\n- 给定 $\\alpha$ 下的最大相对扰动 $\\delta(h,p,\\alpha)$，\n- 建议标度律下的最大相对扰动 $\\delta\\big(h,p,\\alpha_{\\mathrm{opt}}(h,p)\\big)$，\n\n并生成单行输出，包含这六个结果，按以下顺序聚合在一个逗号分隔的列表中，并用方括号括起来\n$$\n\\big[\\delta(h_1,p_1,\\alpha_1), \\delta(h_1,p_1,\\alpha_{\\mathrm{opt},1}), \\delta(h_2,p_2,\\alpha_2), \\delta(h_2,p_2,\\alpha_{\\mathrm{opt},2}), \\delta(h_3,p_3,\\alpha_3), \\delta(h_3,p_3,\\alpha_{\\mathrm{opt},3})\\big],\n$$\n其中 $\\alpha_{\\mathrm{opt},i} = \\alpha_{\\mathrm{opt}}(h_i,p_i)$。最终的数值输出是无量纲的浮点数。不需要物理单位，也不涉及角度或百分比。程序必须是完整且可直接运行的，无需任何外部输入或文件，并且必须严格遵循指定的输出格式。",
            "solution": "所提出的问题是对计算电磁学中有限元分析所用的一项基本技术的适定且科学上合理的探究。它关注的是在麦克斯韦特征问题的离散化中，当电场的无散度约束未被严格执行时产生的非物理（或称“伪”）解的抑制问题。所提议的罚方法通过增加一个与场散度平方成正比的项，是缓解此问题的标准方法。问题提供了一个简化但概念上正确的分块矩阵模型 $\\mathbf{A}_{\\alpha}(h,p)$，它捕捉了物理（无散度）子空间与伪（梯度）子空间之间的本质相互作用。该模型使得可以集中分析罚参数 $\\alpha$ 对计算出的特征值的影响。所有用于唯一数值解所需的参数和定义都已提供，问题没有矛盾或含糊之处。它代表了一项有效且富有洞察力的计算练习。\n\n问题的核心在于理解选择罚参数 $\\alpha$ 时的权衡。如果 $\\alpha$ 太小，伪模未被充分惩罚，其对应的特征值可能出现在物理谱的范围内，从而污染解。如果 $\\alpha$ 太大，罚项可能会过度扰动物理模式，导致物理特征值不准确。目标是找到一个关于离散化参数——网格尺寸 $h$ 和多项式次数 $p$——的 $\\alpha$ 的标度律，以最优地平衡这些相互竞争的影响。\n\n问题要求提出并论证 $\\alpha$ 的标度律。一个有原则的选择可以从有限元离散化的性质中推导出来。带罚的弱形式为：\n$$\na_{\\alpha}(\\mathbf{E}_h, \\mathbf{v}_h) = \\int_{\\Omega} \\mu^{-1} \\left(\\nabla \\times \\mathbf{E}_h\\right)\\cdot\\left(\\nabla \\times \\mathbf{v}_h\\right) \\, d\\Omega + \\alpha \\int_{\\Omega} \\left(\\nabla \\cdot (\\epsilon \\mathbf{E}_h)\\right)\\left(\\nabla \\cdot (\\epsilon \\mathbf{v}_h)\\right) \\, d\\Omega\n$$\n第一项，即旋度-旋度项，对应于一个二阶微分算子。在离散设置中，相应矩阵的特征值大致按 $(p/h)^2$ 的比例缩放。罚项 $\\alpha \\int_{\\Omega} (\\nabla\\cdot\\mathbf{E}_h)^2 \\, d\\Omega$ 旨在强制执行 $\\nabla\\cdot\\mathbf{E}_h \\approx 0$。设置罚参数的一个常见启发式方法是平衡算子范数。有限元理论中的一条“反不等式”指出，对于离散空间中的函数 $\\mathbf{v}_h$，其导数的范数受函数自身范数乘以一个依赖于 $h$ 和 $p$ 的因子所界定，例如 $\\|\\nabla \\cdot \\mathbf{v}_h\\|_{L^2} \\le C \\frac{p}{h} \\|\\mathbf{v}_h\\|_{L^2}$。罚项对刚度矩阵的贡献涉及此导数，为确保其相对于（来自特征问题右侧的）质量矩阵是有效的，需要一个强的罚。选择 $\\alpha$ 按 $(p/h)^2$ 缩放是一种特别积极的标度策略。这个选择 $\\alpha_{\\mathrm{opt}}(h,p) = c \\, (p/h)^2$ 旨在使罚项的离散算子范数与旋度-旋度算子的范数相当。这确保了对于 $h$ 和 $p$ 的任何组合，罚都足够强，以将伪特征值推到远大于我们关心的物理特征值的值。一个物理特征值 $\\lambda_k$ 受到一个特征值为 $\\lambda_s \\approx \\alpha$ 的伪模的扰动，其大小近似正比于 $\\beta^2 / |\\lambda_k - \\alpha|$。通过所提出的标度律使 $\\alpha$ 非常大，分母会增大，从而最小化扰动。待测试的具体定律是 $\\alpha_{\\mathrm{opt}}(h,p) = p^2/h^2$（即 $c=1$）。\n\n计算流程如下。对于由元组 $(h, p, \\alpha)$ 定义的每个测试用例，我们执行两次计算。\n\n首先，使用给定的 $\\alpha$：\n1.  设置模型参数：$n_{\\mathrm{phys}}=6$, $n_{\\mathrm{grad}}=4$。真实物理特征值为 $\\lambda_k = \\pi^2 s_k$，其中 $k=1,\\ldots,6$，且 $\\mathbf{s}=(2,5,8,10,13,17)$。\n2.  构造 $10 \\times 10$ 的对称分块矩阵 $\\mathbf{A}_{\\alpha}(h,p)$。其分块为：\n    -   左上角 ($6 \\times 6$): $\\mathbf{\\Lambda} = \\mathrm{diag}(\\lambda_1, \\ldots, \\lambda_6)$。\n    -   右上角 ($6 \\times 4$) 和左下角 ($4 \\times 6$): 耦合由 $\\beta(h,p)\\mathbf{C}$ 及其转置给出，其中 $\\beta(h,p) = h^p/p$，$\\mathbf{C}$ 是一个矩阵，其 $C_{ii}=1$ (对 $i=1,2,3,4$)，其余为零。\n    -   右下角 ($4 \\times 4$): 罚项为 $\\alpha \\mathbf{I}_{4}$。\n3.  计算 $\\mathbf{A}_{\\alpha}$ 的特征值。由于矩阵是实对称的，所有特征值均为实数。将它们按非降序排序。\n4.  这些排序后的特征值中的前 $n_{\\mathrm{phys}}=6$ 个，即 $\\lambda_k^{\\alpha}$，是受扰动的物理特征值。\n5.  最大相对扰动计算为 $\\delta(h,p,\\alpha) = \\max_{1\\le k\\le 6} |\\lambda_k^{\\alpha} - \\lambda_k|/\\lambda_k$。\n\n其次，使用建议的最优罚参数 $\\alpha_{\\mathrm{opt}}(h,p) = p^2/h^2$ 重复整个过程，以计算 $\\delta(h,p,\\alpha_{\\mathrm{opt}})$。\n\n将此过程应用于所有三个测试用例，并将得到的六个 $\\delta$ 值收集起来用于最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the eigenvalue perturbation problem for the given test cases.\n    \n    This function implements the block-structured model for a penalized finite\n    element eigenproblem, computes the perturbed eigenvalues for different\n    parameter sets, and quantifies the maximum relative perturbation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, p, alpha_given)\n        (0.5, 1, 0.1),\n        (0.25, 2, 1.0),\n        (0.125, 3, 100.0),\n    ]\n\n    # --- Fixed parameters of the model ---\n    n_phys = 6\n    n_grad = 4\n    \n    # True physical eigenvalues\n    s_k = np.array([2.0, 5.0, 8.0, 10.0, 13.0, 17.0])\n    lambda_true = np.pi**2 * s_k\n    \n    # Coupling matrix C\n    # C is a 6x4 matrix with C_ii=1 for i=1,2,3,4, and 0 otherwise.\n    C = np.zeros((n_phys, n_grad))\n    np.fill_diagonal(C, 1.0)\n    \n    # Diagonal block Lambda\n    Lambda = np.diag(lambda_true)\n\n    results = []\n\n    for h, p, alpha_given in test_cases:\n        # --- Common calculation for both alpha values ---\n        # Coupling magnitude beta\n        beta = (h**p) / p\n        \n        # Off-diagonal blocks\n        coupling_block = beta * C\n        \n        # Upper part of the matrix A is the same for both calculations\n        A_upper = np.hstack([Lambda, coupling_block])\n\n        # --- 1. Calculation for the given alpha ---\n        \n        # Assemble the full matrix A_alpha\n        A_lower_given = np.hstack([coupling_block.T, alpha_given * np.identity(n_grad)])\n        A_alpha_given = np.vstack([A_upper, A_lower_given])\n        \n        # Compute eigenvalues. eigvalsh is for symmetric matrices and is efficient.\n        # The eigenvalues are not guaranteed to be sorted.\n        eigenvalues_given = np.sort(np.linalg.eigvalsh(A_alpha_given))\n        \n        # The first n_phys eigenvalues are the perturbed physical ones.\n        lambda_perturbed_given = eigenvalues_given[:n_phys]\n        \n        # Calculate maximum relative perturbation\n        delta_given = np.max(np.abs((lambda_perturbed_given - lambda_true) / lambda_true))\n        results.append(delta_given)\n\n        # --- 2. Calculation for the proposed optimal alpha ---\n        \n        # Proposed optimal penalty strength\n        alpha_opt = (p**2) / (h**2)\n        \n        # Assemble the full matrix A_alpha_opt\n        A_lower_opt = np.hstack([coupling_block.T, alpha_opt * np.identity(n_grad)])\n        A_alpha_opt = np.vstack([A_upper, A_lower_opt])\n        \n        # Compute eigenvalues\n        eigenvalues_opt = np.sort(np.linalg.eigvalsh(A_alpha_opt))\n        \n        # The first n_phys eigenvalues are the perturbed physical ones.\n        lambda_perturbed_opt = eigenvalues_opt[:n_phys]\n        \n        # Calculate maximum relative perturbation\n        delta_opt = np.max(np.abs((lambda_perturbed_opt - lambda_true) / lambda_true))\n        results.append(delta_opt)\n\n    # Final print statement in the exact required format.\n    # The use of map(str, ...) allows for default float formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}