{
    "hands_on_practices": [
        {
            "introduction": "To build a strong foundation, our first practice involves implementing a Method of Moments (MoM) solver for the classic problem of electromagnetic scattering from a circular cylinder. By using Fourier harmonics as entire-domain basis functions, the underlying integral operator becomes diagonal, leading to a highly efficient solution . This exercise provides essential hands-on experience in validating a numerical model against a known analytical solution, a critical skill in computational methods development.",
            "id": "3305813",
            "problem": "You are asked to validate an entire-domain Method of Moments solution for a canonical two-dimensional scattering problem in computational electromagnetics using analytical results. Consider time-harmonic Transverse Magnetic with electric field along the $z$-axis (TM$_z$) scattering by a perfectly electrically conducting (PEC) circular cylinder of radius $a$ in free space. The incident field is a unit-amplitude plane wave $E_z^{\\text{inc}}(r,\\phi) = e^{ikr \\cos(\\phi)}$ propagating along the $x$-axis. The speed of light is $c = 299\\,792\\,458$ meters per second. All angles must be treated in radians, all lengths in meters, all frequencies in Hertz, and the final numerical outputs are dimensionless.\n\nStart from the scalar Helmholtz equation for TM$_z$ in two dimensions,\n$$\n\\nabla^2 E_z + k^2 E_z = 0,\n$$\nwith the free-space wavenumber $k = \\frac{2\\pi f}{c}$ and the total field boundary condition on the PEC,\n$$\nE_z^{\\text{tot}}(r=a,\\phi) = 0.\n$$\nRepresent the scattered field outside the cylinder as a single-layer potential over the circular boundary using the two-dimensional free-space Green's function $G(\\mathbf{r},\\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k|\\mathbf{r}-\\mathbf{r}'|)$, where $H_\\nu^{(1)}(\\cdot)$ is the Hankel function of the first kind,\n$$\nE_z^{\\text{scat}}(r,\\phi) = \\frac{i}{4} \\int_0^{2\\pi} q(\\phi') H_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) a\\, d\\phi',\n$$\nwith $\\mathbf{r}'$ constrained to the circle $r'=a$, and $q(\\phi')$ an unknown equivalent source density. Enforce the boundary condition $E_z^{\\text{inc}}(a,\\phi) + E_z^{\\text{scat}}(a,\\phi) = 0$ on $r = a$ in a Galerkin sense using the entire-domain Fourier basis functions $b_n(\\phi) = e^{i n \\phi}$ indexed by all integers $n \\in \\mathbb{Z}$. Use Graf's addition theorem to diagonalize the integral operator on the circle,\n$$\nH_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) = \\sum_{m=-\\infty}^{\\infty} H_m^{(1)}(k r_>) J_m(k r_<) e^{i m (\\phi - \\phi')},\n$$\nwith $r_> = \\max(r,r')$ and $r_< = \\min(r,r')$, and $J_\\nu(\\cdot)$ the Bessel function of the first kind. Show that the single-layer operator acting on $b_n(\\phi')$ yields\n$$\n\\mathcal{S}[b_n](\\phi) = \\frac{i}{4} \\int_0^{2\\pi} H_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) a\\, b_n(\\phi') d\\phi' = \\lambda_n b_n(\\phi),\n$$\nwith diagonal eigenvalues\n$$\n\\lambda_n = \\frac{i \\pi a}{2} J_n(k a) H_n^{(1)}(k a).\n$$\nUse the Jacobi–Anger expansion of the incident field on the boundary,\n$$\nE_z^{\\text{inc}}(a,\\phi) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(k a) e^{i n \\phi},\n$$\nto derive the Galerkin solution for the source density coefficients $q_n$,\n$$\n\\lambda_n q_n + i^n J_n(k a) = 0 \\quad \\Rightarrow \\quad q_n = - \\frac{i^n J_n(k a)}{\\lambda_n}.\n$$\nShow that the scattered field expansion outside the cylinder takes the form\n$$\nE_z^{\\text{scat}}(r,\\phi) = \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(k r) e^{i n \\phi},\n$$\nwhere projection of the single-layer potential yields\n$$\nA_n = \\frac{i}{4} (2\\pi a) q_n J_n(k a) = - \\frac{i^n J_n(k a)}{H_n^{(1)}(k a)}.\n$$\nThe last equality provides the analytical scattering coefficients by enforcing the Dirichlet boundary condition $E_z^{\\text{inc}}(a,\\phi) + E_z^{\\text{scat}}(a,\\phi) = 0$ mode-by-mode, and simultaneously validates the entire-domain Fourier–Galerkin Method of Moments solution via the single-layer potential.\n\nImplement a program that computes and compares the numerical entire-domain Method of Moments coefficients to the analytical coefficients, and validates the scattered field against the analytical field. Use Bessel functions $J_n(\\cdot)$ and Hankel functions $H_n^{(1)}(\\cdot)$, and take $n$ from $-N$ to $N$ for a given truncation order $N$. For evaluating scattered fields, use\n$$\nE_z^{\\text{scat}}(r,\\phi) \\approx \\sum_{n=-N}^{N} A_n H_n^{(1)}(k r) e^{i n \\phi},\n$$\nwith the above analytical $A_n$ and the Method of Moments-derived $A_n$ via $q_n$ and the single-layer projection.\n\nYour program must compute the following three test cases, each producing one floating-point result that will be aggregated and printed as a single line:\n\n1. Coefficient validation (happy path). Parameters: $a = 0.5$ meters, $f = 3.0 \\times 10^8$ Hertz, truncation $N = 40$. Compute the maximum relative error across all modes $n \\in \\{-N,\\dots,N\\}$ between numerical entire-domain $A_n$ and analytical $A_n$, defined as\n$$\n\\max_{-N \\le n \\le N} \\frac{\\left|A_n^{\\text{MoM}} - A_n^{\\text{analytical}}\\right|}{\\max\\left(\\left|A_n^{\\text{analytical}}\\right|, \\varepsilon\\right)},\n$$\nwith $\\varepsilon = 10^{-15}$.\n\n2. Field validation at a finite observation radius (coverage beyond coefficients). Parameters: $a = 0.35$ meters, $f = 1.2 \\times 10^9$ Hertz, truncation $N = 60$, observation radius $r_{\\text{obs}} = 10 a$, angles $\\phi_m = \\frac{2\\pi m}{16}$ for $m = 0,1,\\dots,15$ (in radians). Compute the maximum relative error across all angles between $E_z^{\\text{scat}}(r_{\\text{obs}},\\phi)$ built from numerical entire-domain $A_n$ and the analytical $A_n$,\n$$\n\\max_m \\frac{\\left|E_z^{\\text{scat,MoM}}(r_{\\text{obs}},\\phi_m) - E_z^{\\text{scat,analytical}}(r_{\\text{obs}},\\phi_m)\\right|}{\\max\\left(\\left|E_z^{\\text{scat,analytical}}(r_{\\text{obs}},\\phi_m)\\right|, \\varepsilon\\right)}.\n$$\n\n3. Boundary-condition residual under truncation (edge case). Parameters: $a = 0.02$ meters, choose $f$ such that $k a = 0.5$ (i.e., $f = \\frac{0.5\\, c}{2\\pi a}$ Hertz), truncation $N = 5$. Using the analytical coefficients truncated to $n \\in \\{-N,\\dots,N\\}$, compute the normalized maximum residual of the boundary condition over angles $\\phi_m = \\frac{2\\pi m}{64}$ for $m = 0,1,\\dots,63$,\n$$\n\\max_m \\frac{\\left|E_z^{\\text{inc}}(a,\\phi_m) + \\sum_{n=-N}^{N} A_n^{\\text{analytical}} H_n^{(1)}(k a) e^{i n \\phi_m}\\right|}{\\max_m \\left|E_z^{\\text{inc}}(a,\\phi_m)\\right|}.\n$$\n\nYour program should produce a single line of output containing the three numerical results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"). Each result must be a floating-point number. Use the specified physical units (meters for $a$, Hertz for $f$), and use radians for all angles.",
            "solution": "We begin from the two-dimensional scalar Helmholtz equation for the $z$-directed electric field in Transverse Magnetic polarization, $E_z$, given by $\\nabla^2 E_z + k^2 E_z = 0$ outside the scatterer. For a perfectly electrically conducting (PEC) boundary at $r=a$, the Dirichlet boundary condition enforces that the total tangential electric field vanish at the surface, $E_z^{\\text{tot}}(r=a,\\phi) = 0$. The total field equals the sum of the incident field and the scattered field, $E_z^{\\text{tot}} = E_z^{\\text{inc}} + E_z^{\\text{scat}}$.\n\nWe represent the scattered field using a single-layer potential over the boundary curve $\\Gamma$ (the circle of radius $a$), with density $q(\\phi')$ and the two-dimensional free-space Green's function,\n$$\nE_z^{\\text{scat}}(r,\\phi) = \\frac{i}{4} \\int_{\\Gamma} q(\\phi') H_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) ds' = \\frac{i}{4} \\int_0^{2\\pi} q(\\phi') H_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) a\\, d\\phi',\n$$\nwhere $H_0^{(1)}(\\cdot)$ is the zeroth-order Hankel function of the first kind and $ds' = a\\, d\\phi'$ is the differential arc length on the circle.\n\nOn the boundary $r=a$, enforcing $E_z^{\\text{inc}}(a,\\phi) + E_z^{\\text{scat}}(a,\\phi) = 0$ yields the Electric Field Integral Equation (EFIE) for TM$_z$ under the single-layer representation. To solve this equation using entire-domain basis functions, we expand the unknown $q(\\phi')$ in Fourier series,\n$$\nq(\\phi') = \\sum_{n=-\\infty}^{\\infty} q_n e^{i n \\phi'},\n$$\nand test the EFIE with the same family $b_n(\\phi) = e^{i n \\phi}$ (Galerkin approach). The integral operator on the circle is diagonalized by Fourier harmonics due to the circular symmetry. Using Graf's addition theorem,\n$$\nH_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right) = \\sum_{m=-\\infty}^{\\infty} H_m^{(1)}(k r_>) J_m(k r_<) e^{i m (\\phi - \\phi')},\n$$\nsetting $r=r'=a$ yields\n$$\nH_0^{(1)}\\!\\left(k\\left|\\mathbf{r} - \\mathbf{r}'\\right|\\right)\\bigg|_{r=r'=a} = \\sum_{m=-\\infty}^{\\infty} H_m^{(1)}(k a) J_m(k a) e^{i m (\\phi - \\phi')}.\n$$\nApplying the single-layer operator to $b_n(\\phi')$ and integrating over $\\phi'$ gives\n$$\n\\mathcal{S}[b_n](\\phi) = \\frac{i}{4} \\int_0^{2\\pi} \\left[\\sum_{m=-\\infty}^{\\infty} H_m^{(1)}(k a) J_m(k a) e^{i m (\\phi - \\phi')}\\right] a\\, e^{i n \\phi'} d\\phi'.\n$$\nInterchanging sum and integral and using orthogonality,\n$$\n\\int_0^{2\\pi} e^{i (n - m) \\phi'} d\\phi' = 2\\pi \\delta_{n m},\n$$\nwe find\n$$\n\\mathcal{S}[b_n](\\phi) = \\frac{i}{4} a \\left[2\\pi H_n^{(1)}(k a) J_n(k a)\\right] e^{i n \\phi} = \\lambda_n b_n(\\phi),\n$$\nwith eigenvalues\n$$\n\\lambda_n = \\frac{i \\pi a}{2} J_n(k a) H_n^{(1)}(k a).\n$$\nThus, the EFIE projected onto $b_n$ becomes\n$$\n\\lambda_n q_n + \\langle b_n, E_z^{\\text{inc}}(a,\\cdot) \\rangle = 0,\n$$\nwhere the bracket denotes Fourier coefficient extraction. Using the Jacobi–Anger expansion for the incident plane wave on the boundary,\n$$\nE_z^{\\text{inc}}(a,\\phi) = e^{i k a \\cos \\phi} = \\sum_{n=-\\infty}^{\\infty} i^n J_n(k a) e^{i n \\phi},\n$$\nwe identify the incident Fourier coefficients as $E_{n}^{\\text{inc}} = i^n J_n(k a)$. Therefore, the source density coefficients are\n$$\nq_n = - \\frac{i^n J_n(k a)}{\\lambda_n} = - \\frac{i^n J_n(k a)}{\\frac{i \\pi a}{2} J_n(k a) H_n^{(1)}(k a)} = - \\frac{2}{i \\pi a} \\frac{i^n}{H_n^{(1)}(k a)}.\n$$\n\nTo obtain the scattered field away from the boundary $(r>a)$ in the same harmonic basis, we expand the single-layer potential using Graf's addition theorem for $r>a$ ($r_>=r$, $r_<=a$), yielding\n$$\nE_z^{\\text{scat}}(r,\\phi) = \\frac{i}{4} \\int_0^{2\\pi} q(\\phi') \\left[\\sum_{m=-\\infty}^{\\infty} H_m^{(1)}(k r) J_m(k a) e^{i m (\\phi - \\phi')}\\right] a\\, d\\phi' = \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(k r) e^{i n \\phi},\n$$\nwhere the scattered-field modal amplitudes are\n$$\nA_n = \\frac{i}{4} \\left(2\\pi a\\right) q_n J_n(k a).\n$$\nSubstituting $q_n$,\n$$\nA_n = \\frac{i}{4} \\left(2\\pi a\\right) \\left(- \\frac{i^n J_n(k a)}{\\lambda_n}\\right) = - \\frac{i^n J_n(k a)}{H_n^{(1)}(k a)}.\n$$\nThis last expression is precisely the analytical coefficient obtained by enforcing the boundary condition $E_z^{\\text{inc}}(a,\\phi) + \\sum_n A_n H_n^{(1)}(k a) e^{i n \\phi} = 0$ mode-by-mode, since the orthogonality ensures\n$$\ni^n J_n(k a) + A_n H_n^{(1)}(k a) = 0 \\quad \\Rightarrow \\quad A_n = - \\frac{i^n J_n(k a)}{H_n^{(1)}(k a)}.\n$$\nConsequently, the entire-domain Fourier–Galerkin Method of Moments solution using the single-layer potential is validated against the exact analytical solution for a PEC circular cylinder.\n\nAlgorithmic design:\n1. For given $a$ and $f$, compute $k = \\frac{2\\pi f}{c}$ and $k a$.\n2. For truncation $N$, enumerate $n \\in \\{-N, -N+1, \\dots, N\\}$.\n3. Compute $J_n(k a)$ and $H_n^{(1)}(k a)$ for each $n$ using reliable special function libraries.\n4. Compute the Galerkin single-layer eigenvalues $\\lambda_n = \\frac{i \\pi a}{2} J_n(k a) H_n^{(1)}(k a)$.\n5. Compute the source density coefficients $q_n = - \\frac{i^n J_n(k a)}{\\lambda_n}$.\n6. Compute Method of Moments scattered-field coefficients $A_n^{\\text{MoM}} = \\frac{i}{4} (2\\pi a) q_n J_n(k a)$.\n7. Compute analytical coefficients $A_n^{\\text{analytical}} = - \\frac{i^n J_n(k a)}{H_n^{(1)}(k a)}$.\n8. Validate:\n   a. Coefficient validation: compute $\\max_n$ of the relative difference between $A_n^{\\text{MoM}}$ and $A_n^{\\text{analytical}}$ using a small $\\varepsilon$ to guard against division by zero.\n   b. Field validation: for prescribed angles and $r_{\\text{obs}}$, compute $E_z^{\\text{scat}}(r_{\\text{obs}},\\phi)$ from both sets of $A_n$ and take the maximum relative difference across angles.\n   c. Boundary-condition residual: for angles on the boundary, compute the residual $E_z^{\\text{inc}}(a,\\phi) + \\sum_{n=-N}^{N} A_n^{\\text{analytical}} H_n^{(1)}(k a) e^{i n \\phi}$ and normalize by the maximum incident magnitude across angles.\n\nNumerical considerations:\n- Use complex arithmetic for $A_n$, $H_n^{(1)}$, and $E_z^{\\text{scat}}$.\n- Exploit the symmetry $J_{-n}(x) = (-1)^n J_n(x)$ and $H_{-n}^{(1)}(x) = (-1)^n H_n^{(1)}(x)$; however, direct evaluation for negative integer orders is acceptable.\n- Choose $\\varepsilon = 10^{-15}$ to stabilize relative error divisions in the presence of near-zero denominators.\n\nThe program will compute three floating-point results for the specified test cases and print them in a single line as a comma-separated list in square brackets, for example, \"[1.0e-15,2.0e-15,0.0123]\". All angles are treated in radians, lengths in meters, frequencies in Hertz, and outputs are dimensionless.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\nc = 299_792_458.0  # speed of light in m/s\n\ndef compute_coefficients(a, f, N):\n    \"\"\"\n    Compute MoM and analytical scattered-field coefficients A_n for n in [-N, N].\n    Returns arrays of n, A_mom, A_analytic, and ka.\n    \"\"\"\n    k = 2.0 * np.pi * f / c\n    ka = k * a\n    ns = np.arange(-N, N+1, dtype=int)\n    # Precompute Bessel and Hankel at ka for all n\n    J = np.array([jv(n, ka) for n in ns], dtype=np.complex128)\n    H = np.array([hankel1(n, ka) for n in ns], dtype=np.complex128)\n    # Eigenvalues of single-layer operator on the circle\n    lam = 1j * np.pi * a / 2.0 * J * H\n    # Incident coefficients: i^n J_n(ka)\n    i_pow_n = np.array([(1j)**n for n in ns], dtype=np.complex128)\n    Einc_n = i_pow_n * J\n    # Source density coefficients q_n from Galerkin EFIE\n    # Guard against division by zero in pathological cases\n    q = -Einc_n / lam\n    # MoM scattered-field coefficients via single-layer projection\n    A_mom = (1j / 4.0) * (2.0 * np.pi * a) * q * J\n    # Analytical coefficients from boundary condition\n    # A_n = - i^n J_n(ka) / H_n^{(1)}(ka)\n    A_analytic = -Einc_n / H\n    return ns, A_mom, A_analytic, ka, k\n\ndef coeff_validation_case(a, f, N, eps=1e-15):\n    ns, A_mom, A_analytic, ka, k = compute_coefficients(a, f, N)\n    denom = np.maximum(np.abs(A_analytic), eps)\n    rel_err = np.abs(A_mom - A_analytic) / denom\n    return float(np.max(rel_err))\n\ndef field_validation_case(a, f, N, r_obs, angles, eps=1e-15):\n    ns, A_mom, A_analytic, ka, k = compute_coefficients(a, f, N)\n    # Compute Hankel at observation radius\n    kr = k * r_obs\n    H_obs = np.array([hankel1(n, kr) for n in ns], dtype=np.complex128)\n    # Evaluate scattered fields for both methods\n    errs = []\n    for phi in angles:\n        exp_nphi = np.array([np.exp(1j * n * phi) for n in ns], dtype=np.complex128)\n        Es_mom = np.sum(A_mom * H_obs * exp_nphi)\n        Es_ana = np.sum(A_analytic * H_obs * exp_nphi)\n        denom = max(np.abs(Es_ana), eps)\n        errs.append(np.abs(Es_mom - Es_ana) / denom)\n    return float(np.max(errs))\n\ndef boundary_residual_case(a, f, N, angles):\n    ns, A_mom, A_analytic, ka, k = compute_coefficients(a, f, N)\n    # Residual using analytical coefficients truncated to N at the boundary\n    # Residual(phi) = E_inc(a,phi) + sum_{n=-N}^N A_n H_n(ka) e^{i n phi}\n    H_boundary = np.array([hankel1(n, ka) for n in ns], dtype=np.complex128)\n    max_inc_mag = 0.0\n    max_resid = 0.0\n    for phi in angles:\n        E_inc = np.exp(1j * ka * np.cos(phi))\n        # Compute truncated field sum at boundary\n        exp_nphi = np.array([np.exp(1j * n * phi) for n in ns], dtype=np.complex128)\n        sum_trunc = np.sum(A_analytic * H_boundary * exp_nphi)\n        resid = E_inc + sum_trunc\n        max_inc_mag = max(max_inc_mag, np.abs(E_inc))\n        max_resid = max(max_resid, np.abs(resid))\n    # Normalize residual by max incident magnitude\n    if max_inc_mag == 0.0:\n        return float(max_resid)\n    return float(max_resid / max_inc_mag)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Coefficient validation (happy path)\n        {\n            \"type\": \"coeff\",\n            \"a\": 0.5,          # meters\n            \"f\": 3.0e8,        # Hz\n            \"N\": 40\n        },\n        # Case 2: Field validation at finite observation radius\n        {\n            \"type\": \"farfield\",\n            \"a\": 0.35,         # meters\n            \"f\": 1.2e9,        # Hz\n            \"N\": 60,\n            \"r_obs_multiplier\": 10.0,\n            \"angles\": [2.0*np.pi*m/16.0 for m in range(16)]\n        },\n        # Case 3: Boundary-condition residual under truncation (edge case)\n        {\n            \"type\": \"boundary\",\n            \"a\": 0.02,         # meters\n            \"ka_target\": 0.5,  # choose f so that k*a = 0.5\n            \"N\": 5,\n            \"angles\": [2.0*np.pi*m/64.0 for m in range(64)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"coeff\":\n            a = case[\"a\"]\n            f = case[\"f\"]\n            N = case[\"N\"]\n            result = coeff_validation_case(a, f, N)\n            results.append(result)\n        elif case[\"type\"] == \"farfield\":\n            a = case[\"a\"]\n            f = case[\"f\"]\n            N = case[\"N\"]\n            r_obs = case[\"r_obs_multiplier\"] * a\n            angles = case[\"angles\"]\n            result = field_validation_case(a, f, N, r_obs, angles)\n            results.append(result)\n        elif case[\"type\"] == \"boundary\":\n            a = case[\"a\"]\n            ka_target = case[\"ka_target\"]\n            # f = (ka_target * c) / (2*pi*a)\n            f = (ka_target * c) / (2.0 * np.pi * a)\n            N = case[\"N\"]\n            angles = case[\"angles\"]\n            result = boundary_residual_case(a, f, N, angles)\n            results.append(result)\n        else:\n            results.append(float(\"nan\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having built a working solver, we now explore the crucial concept of numerical stability by mixing different types of basis functions. This practice investigates a Petrov-Galerkin scheme that pairs entire-domain plane waves with local hat functions, using a simplified model to isolate the interaction between the trial and test spaces . You will compute the discrete inf–sup constant, a key metric for stability, gaining practical insight into why a compatible choice of basis functions is essential for a robust numerical method.",
            "id": "3305810",
            "problem": "Consider weak enforcement of the perfect electric conductor boundary condition for time-harmonic waves, which requires the tangential component of the total electric field to vanish on the boundary of a conductor. From Maxwell’s equations, the perfect electric conductor boundary condition states that the tangential component of the electric field satisfies $E_{\\mathrm{tan}} = 0$ on the boundary $\\partial \\Omega$ of the conductor. In a boundary-only formulation, enforcement of this condition can be posed as seeking a boundary quantity $u$ such that the residual $r = \\mathcal{T}u + E_{\\mathrm{inc},\\mathrm{tan}}$ is minimized in a weak sense over $\\partial \\Omega$, where $\\mathcal{T}$ is an operator mapping the boundary unknown to the tangential field induced on $\\partial \\Omega$, and $E_{\\mathrm{inc},\\mathrm{tan}}$ is the tangential component of the incident field restricted to $\\partial \\Omega$. In this problem, to isolate the effect of test–trial mismatch, approximate $\\mathcal{T}$ by the identity operator and focus on the stability and approximation characteristics of Petrov–Galerkin discretizations that mix entire-domain trial functions and local test functions, and vice versa.\n\nLet the boundary $\\partial \\Omega$ be the unit circle of radius $R = 1$ meters, parameterized by $s \\in [0, 2\\pi)$ with position vector $\\mathbf{r}(s) = (\\cos s, \\sin s)$. Let $\\langle f, g \\rangle = \\int_{0}^{2\\pi} f(s)\\, \\overline{g(s)}\\, ds$ denote the $L^{2}$ inner product on $\\partial \\Omega$, where the integration variable is the angular parameter $s$ in radians. Consider two families of functions on $\\partial \\Omega$:\n\n1. Entire-domain plane-wave functions: for a given wavenumber $k$ in $\\mathrm{rad/m}$ and a unit direction vector $\\hat{d} = (\\cos \\theta, \\sin \\theta)$ with direction angle $\\theta$ in radians, define the scalar function on the boundary\n$$\n\\phi_{\\theta}(s) = e^{ik \\hat{d} \\cdot \\mathbf{r}(s)} \\quad \\text{for } s \\in [0, 2\\pi).\n$$\n\n2. Local hat functions (the one-dimensional analog of Rao–Wilton–Glisson functions): for an integer $N \\geq 3$ and nodes $s_{n} = 2\\pi n/N$ for $n = 0, 1, \\dots, N-1$, define the periodic piecewise-linear functions $\\chi_{n}(s)$ supported on $[s_{n-1}, s_{n+1}]$ with $\\chi_{n}(s_{n}) = 1$, $\\chi_{n}(s_{n-1}) = \\chi_{n}(s_{n+1}) = 0$, and linear variation on each interval, where indices are taken modulo $N$. Explicitly, for $s \\in [0,2\\pi)$ and with $\\Delta = 2\\pi/N$, \n$$\n\\chi_{n}(s) = \n\\begin{cases}\n\\dfrac{s - s_{n-1}}{\\Delta}, & s \\in [s_{n-1}, s_{n}], \\\\\n\\dfrac{s_{n+1} - s}{\\Delta}, & s \\in [s_{n}, s_{n+1}], \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n\nDefine a Petrov–Galerkin pairing of tests and trials by forming the rectangular Gram matrix $B$ with entries\n$$\nB_{pq} = \\langle \\psi_{p}, \\varphi_{q} \\rangle,\n$$\nwhere $\\{\\psi_{p}\\}$ is the chosen set of test functions and $\\{\\varphi_{q}\\}$ is the chosen set of trial functions, each drawn from either the set of plane waves or the set of local hat functions. To assess stability independent of scaling, define the normalized Gram matrix $\\widetilde{B}$ by\n$$\n\\widetilde{B}_{pq} = \\frac{B_{pq}}{\\|\\psi_{p}\\|_{L^{2}(\\partial\\Omega)}\\, \\|\\varphi_{q}\\|_{L^{2}(\\partial\\Omega)}},\n$$\nand define the discrete inf–sup constant estimate as the smallest singular value of $\\widetilde{B}$.\n\nTo measure approximation under weak enforcement, let the incident field boundary data be the scalar function \n$$\nf(s) = e^{ik \\hat{d}_{0} \\cdot \\mathbf{r}(s)},\n$$\nwith incident direction $\\hat{d}_{0} = (\\cos \\theta_{0}, \\sin \\theta_{0})$. Define the testing of residual against the test space via the vector $g$ with components $g_{p} = \\langle \\psi_{p}, f \\rangle$. The Petrov–Galerkin weak enforcement seeks trial coefficients $c$ that minimize the residual $\\|D_{\\psi}^{-1}(B c + g)\\|_{2}$, where $D_{\\psi} = \\mathrm{diag}(\\|\\psi_{p}\\|_{L^{2}(\\partial\\Omega)})$. Use the least-squares solution $c^{\\star}$ minimizing $\\|D_{\\psi}^{-1}(B c + g)\\|_{2}$. Define the normalized residual ratio \n$$\n\\rho = \\frac{\\|D_{\\psi}^{-1}(B c^{\\star} + g)\\|_{2}}{\\|D_{\\psi}^{-1} g\\|_{2}}.\n$$\n\nYour task is to implement a program that:\n- Constructs the test and trial sets for four prescribed cases on the unit circle $\\partial \\Omega$, evaluates all needed inner products using numerical quadrature over $s \\in [0, 2\\pi)$, computes the discrete inf–sup constant estimate as the minimum singular value of $\\widetilde{B}$, and computes the normalized residual ratio $\\rho$ for incident data $f(s)$.\n\nThe numerical quadrature must use uniform sampling in $s$ with at least $L = 4096$ points, and all angles must be interpreted in radians. The wavenumber $k$ must be treated in $\\mathrm{rad/m}$, and the boundary radius is $R = 1$ meters, so the differential arc-length is $ds$ in meters. All outputs must be floats.\n\nTest Suite:\n- Case 1 (Balanced Petrov–Galerkin with matching families): Tests are plane waves and trials are plane waves with $M = 9$ directions $\\theta_{m} = 2\\pi m / 9$ for $m = 0,1,\\dots,8$, wavenumber $k = 10.0$ $\\mathrm{rad/m}$, and incident direction angle $\\theta_{0} = 1.0$ radians. Compute the minimum singular value of $\\widetilde{B}$ and $\\rho$.\n- Case 2 (Entire-domain trials, local tests): Trials are plane waves with $M = 7$ directions $\\theta_{m} = 2\\pi m / 7$ for $m = 0,1,\\dots,6$, tests are local hat functions with $N = 16$ nodes, wavenumber $k = 10.0$ $\\mathrm{rad/m}$, and incident direction angle $\\theta_{0} = 0.7$ radians. Compute the minimum singular value of $\\widetilde{B}$ and $\\rho$.\n- Case 3 (Local trials, entire-domain tests): Trials are local hat functions with $N = 16$ nodes, tests are plane waves with $M = 7$ directions $\\theta_{m} = 2\\pi m / 7$, wavenumber $k = 10.0$ $\\mathrm{rad/m}$, and incident direction angle $\\theta_{0} = 0.7$ radians. Compute the minimum singular value of $\\widetilde{B}$ and $\\rho$.\n- Case 4 (Severely clustered entire-domain trials, local tests): Trials are plane waves with $M = 7$ directions $\\theta_{m} = 0.02\\, m$ for $m = 0,1,\\dots,6$, tests are local hat functions with $N = 16$ nodes, wavenumber $k = 10.0$ $\\mathrm{rad/m}$, and incident direction angle $\\theta_{0} = 0.3$ radians. Compute the minimum singular value of $\\widetilde{B}$ and $\\rho$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the eight results for the four cases as a comma-separated list enclosed in square brackets, in the order \n$$\n[\\sigma_{\\min}^{(1)}, \\rho^{(1)}, \\sigma_{\\min}^{(2)}, \\rho^{(2)}, \\sigma_{\\min}^{(3)}, \\rho^{(3)}, \\sigma_{\\min}^{(4)}, \\rho^{(4)}],\n$$\nwhere $\\sigma_{\\min}^{(i)}$ and $\\rho^{(i)}$ are the minimum singular value of $\\widetilde{B}$ and the normalized residual ratio for Case $i$, respectively. All angles must be in radians, and wavenumber in $\\mathrm{rad/m}$; the eight outputs must be floats.",
            "solution": "The user has provided a valid, well-posed problem in computational electromagnetics. The task is to analyze the stability and approximation properties of several Petrov–Galerkin schemes for a model boundary value problem on a unit circle. This will be accomplished by computing two key metrics: the discrete inf–sup constant estimate ($\\sigma_{\\min}$) and the normalized residual ratio ($\\rho$).\n\nThe logical procedure to solve this problem is as follows:\n\n1.  **Discretization of the Domain and Functions**: The continuous boundary $\\partial\\Omega$, which is a unit circle of radius $R=1$, is parameterized by the angle $s \\in [0, 2\\pi)$. For numerical integration, this continuous domain is discretized into a fine grid of $L=4096$ equally spaced points $s_j = 2\\pi j / L$ for $j=0, \\dots, L-1$. The differential element for integration becomes $\\Delta s_{quad} = 2\\pi/L$. The two families of functions, plane waves and local hats, are evaluated at these discrete points to produce vectors of a-priori known values.\n    *   **Plane-wave functions**: $\\phi_{\\theta}(s) = e^{\\mathrm{i}\\, k\\, \\hat{d} \\cdot \\mathbf{r}(s)}$. With $R=1$, $\\mathbf{r}(s) = (\\cos s, \\sin s)$, and $\\hat{d} = (\\cos\\theta, \\sin\\theta)$, this simplifies to $\\phi_{\\theta}(s) = e^{\\mathrm{i}\\, k\\, \\cos(s - \\theta)}$.\n    *   **Local hat functions**: $\\chi_{n}(s)$ are non-zero only over two adjacent nodal intervals. For any point $s$ lying between nodes $s_k$ and $s_{k+1}$, only $\\chi_k(s)$ and $\\chi_{k+1}(s)$ are non-zero, varying linearly. Their values are computed based on the provided piecewise-linear definition, respecting the periodicity on the circle.\n\n2.  **Numerical Computation of Inner Products**: The $L^2$ inner product $\\langle f, g \\rangle = \\int_{0}^{2\\pi} f(s)\\, \\overline{g(s)}\\, ds$ is approximated numerically using the trapezoidal rule on the uniform grid of $L$ points. This quadrature is expressed as a sum:\n    $$\n    \\langle f, g \\rangle \\approx \\sum_{j=0}^{L-1} f(s_j) \\overline{g(s_j)} \\Delta s_{quad} = \\frac{2\\pi}{L} \\sum_{j=0}^{L-1} f(s_j) \\overline{g(s_j)}.\n    $$\n    This numerical integration is used to compute all necessary quantities:\n    *   The entries of the Petrov–Galerkin matrix: $B_{pq} = \\langle \\psi_{p}, \\varphi_{q} \\rangle$.\n    *   The components of the right-hand-side vector: $g_{p} = \\langle \\psi_{p}, f \\rangle$.\n    *   The $L^2$ norms of the basis functions: $\\|\\psi_{p}\\|_{L^2} = \\sqrt{\\langle \\psi_p, \\psi_p \\rangle}$ and $\\|\\varphi_{q}\\|_{L^2} = \\sqrt{\\langle \\varphi_q, \\varphi_q \\rangle}$.\n\n3.  **Calculation of the Inf-Sup Constant Estimate ($\\sigma_{\\min}$)**: The stability of the Petrov–Galerkin system is assessed via the discrete inf–sup (or LBB) condition, estimated here by the smallest singular value of the normalized Gram matrix $\\widetilde{B}$. The matrix $\\widetilde{B}$ is constructed by normalizing each element of $B$:\n    $$\n    \\widetilde{B}_{pq} = \\frac{B_{pq}}{\\|\\psi_{p}\\|_{L^2}\\, \\|\\varphi_{q}\\|_{L^2}}.\n    $$\n    The singular value decomposition (SVD) of $\\widetilde{B}$ is computed. The smallest singular value from this decomposition, $\\sigma_{\\min}$, serves as the estimate for the discrete inf–sup constant. A small value of $\\sigma_{\\min}$ indicates potential instability.\n\n4.  **Calculation of the Normalized Residual Ratio ($\\rho$)**: The approximation quality is measured by how well the trial function expansion can cancel the incident field's projection onto the test space. This is quantified by solving a weighted least-squares problem to find the optimal trial coefficients $c^\\star$ that minimize $\\|D_{\\psi}^{-1}(B c + g)\\|_{2}$. Here, $D_{\\psi}$ is a diagonal matrix with entries $\\|\\psi_{p}\\|_{L^2}$. Let $A = D_{\\psi}^{-1}B$ and $b = D_{\\psi}^{-1}g$. The problem is equivalent to finding $c^\\star$ that minimizes $\\|Ac+b\\|_{2}$. This is a standard linear least-squares problem, solvable via routines such as `numpy.linalg.lstsq`. The solution $c^\\star$ yields the minimal residual norm, $\\|D_{\\psi}^{-1}(B c^{\\star} + g)\\|_{2}$. The normalized residual ratio $\\rho$ is then calculated as:\n    $$\n    \\rho = \\frac{\\|D_{\\psi}^{-1}(B c^{\\star} + g)\\|_{2}}{\\|D_{\\psi}^{-1} g\\|_{2}}.\n    $$\n    The denominator represents the initial weighted residual norm (with $c=0$), so $\\rho$ measures the relative reduction of the residual. A value of $\\rho$ close to $0$ indicates excellent approximation capability, while a value close to $1$ indicates poor approximation.\n\nThis procedure is applied to each of the four test cases specified in the problem, yielding the eight required output values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_plane_wave_vals(k, thetas, s_grid):\n    \"\"\"\n    Evaluates plane-wave functions on a grid.\n\n    Args:\n        k (float): Wavenumber in rad/m.\n        thetas (np.ndarray): Array of direction angles in radians.\n        s_grid (np.ndarray): Array of boundary parameter values in radians.\n\n    Returns:\n        np.ndarray: A (len(thetas), len(s_grid)) array of complex function values.\n    \"\"\"\n    # The radius R=1 is implicit in the formula k * cos(...).\n    cos_diff = np.cos(s_grid[np.newaxis, :] - thetas[:, np.newaxis])\n    return np.exp(1j * k * cos_diff)\n\ndef get_hat_function_vals(N, s_grid):\n    \"\"\"\n    Evaluates periodic hat functions on a grid.\n\n    Args:\n        N (int): Number of nodes/functions.\n        s_grid (np.ndarray): Array of boundary parameter values in radians.\n\n    Returns:\n        np.ndarray: A (N, len(s_grid)) array of float function values.\n    \"\"\"\n    L = len(s_grid)\n    vals = np.zeros((N, L), dtype=float)\n    delta = 2 * np.pi / N\n    \n    s_norm = s_grid / delta\n    \n    k_indices = np.floor(s_norm).astype(int)\n    frac_part = s_norm - k_indices\n    \n    # Handle periodicity of nodes using modulo operator\n    k_indices %= N\n    k1_indices = (k_indices + 1) % N\n\n    # Vectorized assignment of function values.\n    # For each grid point s_j, at most two hat functions are non-zero.\n    col_indices = np.arange(L)\n    vals[k_indices, col_indices] = 1.0 - frac_part\n    vals[k1_indices, col_indices] = frac_part\n    \n    return vals\n\ndef calculate_metrics(k, test_spec, trial_spec, theta0):\n    \"\"\"\n    Computes sigma_min and rho for a given Petrov-Galerkin setup.\n    \"\"\"\n    L = 4096\n    s_grid = np.linspace(0, 2 * np.pi, L, endpoint=False)\n    ds_quad = 2 * np.pi / L\n\n    # 1. Generate function values at quadrature points\n    test_type, test_n, test_params = test_spec\n    if test_type == 'plane_wave':\n        psi_vals = get_plane_wave_vals(k, test_params, s_grid)\n    else: # 'hat'\n        psi_vals = get_hat_function_vals(test_n, s_grid)\n    \n    trial_type, trial_n, trial_params = trial_spec\n    if trial_type == 'plane_wave':\n        phi_vals = get_plane_wave_vals(k, trial_params, s_grid)\n    else: # 'hat'\n        phi_vals = get_hat_function_vals(trial_n, s_grid)\n\n    f_vals = get_plane_wave_vals(k, np.array([theta0]), s_grid).flatten()\n\n    # 2. Compute inner products via numerical quadrature\n    B = ds_quad * (psi_vals @ np.conj(phi_vals).T)\n    g = ds_quad * (psi_vals @ np.conj(f_vals))\n\n    norm_psi = np.sqrt(ds_quad * np.sum(np.abs(psi_vals)**2, axis=1))\n    norm_phi = np.sqrt(ds_quad * np.sum(np.abs(phi_vals)**2, axis=1))\n\n    # 3. Calculate sigma_min (smallest singular value of normalized matrix)\n    B_tilde = B / np.outer(norm_psi, norm_phi)\n    singular_values = np.linalg.svd(B_tilde, compute_uv=False)\n    sigma_min = np.min(singular_values) if singular_values.size > 0 else 0.0\n\n    # 4. Calculate rho (normalized residual ratio)\n    inv_norm_psi = 1.0 / norm_psi\n    \n    D_psi_inv_g = inv_norm_psi * g\n    D_psi_inv_B = inv_norm_psi[:, np.newaxis] * B\n    \n    # Solve the weighted least-squares problem: min || (D_psi_inv_B)c + (D_psi_inv_g) ||_2\n    _, residuals, _, _ = np.linalg.lstsq(D_psi_inv_B, -D_psi_inv_g, rcond=None)\n    \n    if residuals.size > 0:\n        min_residual_norm_sq = residuals[0]\n    else:\n        min_residual_norm_sq = 0.0\n    \n    min_residual_norm = np.sqrt(min_residual_norm_sq)\n    initial_residual_norm = np.linalg.norm(D_psi_inv_g)\n    \n    if initial_residual_norm  1e-15:\n        rho = 0.0\n    else:\n        rho = min_residual_norm / initial_residual_norm\n        \n    return sigma_min, rho\n\ndef solve():\n    \"\"\" Main function to run all test cases and print results. \"\"\"\n    test_cases = [\n        # Case 1: Balanced Petrov-Galerkin (PW/PW)\n        {'k': 10.0, 'theta0': 1.0,\n         'test_spec': ('plane_wave', 9, 2 * np.pi * np.arange(9) / 9),\n         'trial_spec': ('plane_wave', 9, 2 * np.pi * np.arange(9) / 9)},\n        # Case 2: Entire-domain trials, local tests (PW/Hat)\n        {'k': 10.0, 'theta0': 0.7,\n         'test_spec': ('hat', 16, None),\n         'trial_spec': ('plane_wave', 7, 2 * np.pi * np.arange(7) / 7)},\n        # Case 3: Local trials, entire-domain tests (Hat/PW)\n        {'k': 10.0, 'theta0': 0.7,\n         'test_spec': ('plane_wave', 7, 2 * np.pi * np.arange(7) / 7),\n         'trial_spec': ('hat', 16, None)},\n        # Case 4: Clustered entire-domain trials, local tests (PW-clustered/Hat)\n        {'k': 10.0, 'theta0': 0.3,\n         'test_spec': ('hat', 16, None),\n         'trial_spec': ('plane_wave', 7, 0.02 * np.arange(7))},\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_min, rho = calculate_metrics(\n            k=case['k'],\n            test_spec=case['test_spec'],\n            trial_spec=case['trial_spec'],\n            theta0=case['theta0']\n        )\n        results.extend([sigma_min, rho])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice addresses a critical issue in practical solvers: the severe ill-conditioning inherent in many integral equation formulations. Focusing on a 3D problem on a sphere, you will use vector spherical harmonics to analyze the spectral properties of the single-layer boundary operator . By applying the theoretical framework of Calderón identities, you will construct and analyze a preconditioned system, demonstrating a powerful technique to dramatically improve the numerical stability and performance of the solver.",
            "id": "3305837",
            "problem": "Consider time-harmonic scalar wave scattering in three dimensions governed by the Helmholtz equation. Let $\\Gamma$ be the surface of a sphere of radius $a  0$, and let $k  0$ be the free-space wavenumber. Define the following boundary integral operators on $\\Gamma$ built from the Helmholtz Green’s function $G_k(\\mathbf{x},\\mathbf{y}) = \\exp(ik \\lVert \\mathbf{x}-\\mathbf{y} \\rVert)/(4\\pi \\lVert \\mathbf{x}-\\mathbf{y} \\rVert)$:\n\n- The single-layer operator $S_k$ acting on a surface density $\\varphi$ via $(S_k \\varphi)(\\mathbf{x}) = \\int_{\\Gamma} G_k(\\mathbf{x},\\mathbf{y}) \\,\\varphi(\\mathbf{y}) \\, dS_{\\mathbf{y}}$.\n- The adjoint double-layer operator $K_k'$ acting through the averaged normal derivative of the single-layer potential.\n- The hypersingular operator $W_k$ acting on boundary traces of potentials.\n\nOn a sphere, the spherical harmonics $Y_{\\ell}^m(\\theta,\\phi)$ for $\\ell \\in \\{0,1,2,\\dots\\}$ and $m \\in \\{-\\ell,\\dots,\\ell\\}$ form an orthonormal entire-domain basis that diagonalizes the operators $S_k$, $K_k'$, and $W_k$. Let $L$ be a nonnegative integer truncation index. Denote by $v_{\\ell}$ the eigenvalues of $S_k$ and by $\\kappa_{\\ell}'$ the eigenvalues of $K_k'$ corresponding to the subspace spanned by all $Y_{\\ell}^m$ with a fixed $\\ell$ (the eigenvalues do not depend on $m$). The Calderón identities state that these operators satisfy composition relations on smooth closed surfaces, in particular that $W_k S_k = K_k'^2 - \\tfrac{1}{4} I$ in the appropriate functional setting.\n\nStarting only from the fundamental laws and core definitions listed below, you must derive from first principles the spectral forms of the operators on the sphere $\\Gamma$ and design a numerically stable algorithm to evaluate:\n- the condition number of the truncated single-layer operator,\n- the condition number of the Calderón-regularized operator built from the composition $W_k S_k + \\tfrac{1}{4} I$.\n\nBase set of fundamental laws and definitions to use:\n- The Helmholtz equation $\\Delta u + k^2 u = 0$ for radiating solutions and its representation via boundary layer potentials constructed from $G_k$.\n- The addition theorem for spherical harmonics and separation of variables for spherical geometry.\n- The jump relations for the normal derivatives of layer potentials across $\\Gamma$.\n- The spherical Bessel and Hankel functions as the radial parts of separable solutions in spherical coordinates, and their basic Wronskian identity.\n\nYour program must implement the following, using the entire-domain basis $\\{Y_{\\ell}^m\\}$ truncated at degree $L$:\n1. Compute the eigenvalues $\\{v_{\\ell}\\}_{\\ell=0}^L$ of the single-layer operator $S_k$ on the sphere of radius $a$.\n2. Compute the eigenvalues $\\{\\kappa_{\\ell}'\\}_{\\ell=0}^L$ of the adjoint double-layer operator $K_k'$ on the same sphere.\n3. Form the Calderón-regularized operator whose eigenvalues are $\\{\\kappa_{\\ell}'^{\\,2}\\}_{\\ell=0}^L$, using the identity $W_k S_k = K_k'^2 - \\tfrac{1}{4} I$ to eliminate $W_k$.\n4. For each test case below, report:\n   - the condition number of $S_k$ on the truncated basis, defined as $\\max_{\\ell \\in \\{0,\\dots,L\\}} |v_{\\ell}| \\big/ \\min_{\\ell \\in \\{0,\\dots,L\\}} |v_{\\ell}|$,\n   - the condition number of the Calderón-regularized operator $W_k S_k + \\tfrac{1}{4} I = K_k'^2$, defined as $\\max_{\\ell \\in \\{0,\\dots,L\\}} |\\kappa_{\\ell}'|^2 \\big/ \\min_{\\ell \\in \\{0,\\dots,L\\}} |\\kappa_{\\ell}'|^2$,\n   - the improvement factor, defined as the ratio of the two condition numbers.\n\nAll quantities in this problem are dimensionless or combinations of $a$ and $k$ appearing in the dimensionless product $k a$, so no physical unit is required in the output. Angles, where needed internally, are understood to be in radians.\n\nTest suite to implement, where each test case is a triple $(a,k,L)$:\n- Test 1 (happy path): $(1.0,\\,0.3,\\,8)$\n- Test 2 (moderate frequency, larger truncation): $(1.0,\\,2.0,\\,20)$\n- Test 3 (high frequency, higher truncation): $(1.0,\\,10.0,\\,35)$\n- Test 4 (boundary truncation case): $(1.0,\\,0.5,\\,0)$\n\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list of lists enclosed in square brackets, where each inner list contains three floating-point numbers in the order [condition_number_S, condition_number_regularized, improvement_factor]. For example, the output format must be like:\n[[cS1,cR1,imp1],[cS2,cR2,imp2],[cS3,cR3,imp3],[cS4,cR4,imp4]]",
            "solution": "The problem statement is a well-posed and scientifically sound exercise in the spectral theory of boundary integral operators for the Helmholtz equation in a spherical geometry. It requires the derivation of eigenvalues for the single-layer and adjoint double-layer operators using an entire-domain basis of spherical harmonics. The problem is valid and we may proceed with the solution.\n\nThe core of the problem is to determine the eigenvalues of the operators $S_k$ and $K_k'$ on a sphere $\\Gamma$ of radius $a$. These operators are diagonalized by the basis of spherical harmonics, $\\{Y_{\\ell}^m\\}$. We derive the corresponding eigenvalues, denoted $v_{\\ell}$ and $\\kappa_{\\ell}'$, from first principles.\n\n**1. Eigenvalues of the Single-Layer Operator ($S_k$)**\n\nThe single-layer operator $S_k$ acts on a surface density $\\varphi$ as:\n$$ (S_k \\varphi)(\\mathbf{x}) = \\int_{\\Gamma} G_k(\\mathbf{x},\\mathbf{y}) \\,\\varphi(\\mathbf{y}) \\, dS_{\\mathbf{y}} $$\nwhere $G_k(\\mathbf{x},\\mathbf{y}) = \\frac{\\exp(ik \\lVert \\mathbf{x}-\\mathbf{y} \\rVert)}{4\\pi \\lVert \\mathbf{x}-\\mathbf{y} \\rVert}$ is the free-space Green's function for the Helmholtz equation. To find the eigenvalues $v_{\\ell}$, we let $\\varphi$ be a spherical harmonic, $\\varphi(\\mathbf{y}) = Y_{\\ell}^m(\\hat{\\mathbf{y}})$, where $\\hat{\\mathbf{y}}$ is the direction vector for the point $\\mathbf{y}$ on the sphere.\n\nFor both $\\mathbf{x}$ and $\\mathbf{y}$ on the sphere $\\Gamma$ ($|\\mathbf{x}| = |\\mathbf{y}| = a$), the Green's function can be expanded using the addition theorem for spherical waves:\n$$ G_k(\\mathbf{x},\\mathbf{y}) = ik \\sum_{n=0}^{\\infty} \\sum_{p=-n}^{n} j_n(ka) h_n^{(1)}(ka) Y_n^p(\\hat{\\mathbf{x}}) \\overline{Y_n^p(\\hat{\\mathbf{y}})} $$\nwhere $j_n$ and $h_n^{(1)}$ are the spherical Bessel and Hankel functions of the first kind, respectively.\n\nSubstituting this expansion into the operator definition, with $\\varphi(\\mathbf{y}) = Y_{\\ell}^m(\\hat{\\mathbf{y}})$ and the surface element $dS_{\\mathbf{y}} = a^2 d\\Omega_{\\mathbf{y}}$:\n$$ (S_k Y_{\\ell}^m)(\\mathbf{x}) = \\int_{\\Omega} \\left( ik \\sum_{n=0}^{\\infty} \\sum_{p=-n}^{n} j_n(ka) h_n^{(1)}(ka) Y_n^p(\\hat{\\mathbf{x}}) \\overline{Y_n^p(\\hat{\\mathbf{y}})} \\right) Y_{\\ell}^m(\\hat{\\mathbf{y}}) \\, a^2 d\\Omega_{\\mathbf{y}} $$\nwhere the integral is over the unit sphere's solid angle $\\Omega$. Interchanging summation and integration:\n$$ (S_k Y_{\\ell}^m)(\\mathbf{x}) = ik a^2 \\sum_{n=0}^{\\infty} \\sum_{p=-n}^{n} j_n(ka) h_n^{(1)}(ka) Y_n^p(\\hat{\\mathbf{x}}) \\int_{\\Omega} \\overline{Y_n^p(\\hat{\\mathbf{y}})} Y_{\\ell}^m(\\hat{\\mathbf{y}}) d\\Omega_{\\mathbf{y}} $$\nBy the orthonormality of spherical harmonics, $\\int_{\\Omega} \\overline{Y_n^p} Y_{\\ell}^m d\\Omega = \\delta_{n\\ell} \\delta_{pm}$. The double summation collapses to a single term where $n=\\ell$ and $p=m$:\n$$ (S_k Y_{\\ell}^m)(\\mathbf{x}) = \\left( ik a^2 j_{\\ell}(ka) h_{\\ell}^{(1)}(ka) \\right) Y_{\\ell}^m(\\hat{\\mathbf{x}}) $$\nThus, the eigenvalues $v_{\\ell}$ of the single-layer operator $S_k$, which are independent of the index $m$, are:\n$$ v_{\\ell} = ik a^2 j_{\\ell}(ka) h_{\\ell}^{(1)}(ka) $$\n\n**2. Eigenvalues of the Adjoint Double-Layer Operator ($K_k'$)**\n\nThe operator $K_k'$ is defined via the averaged normal derivative of the single-layer potential $u = S_k \\varphi$. Let $\\varphi = Y_{\\ell}^m$. The potential $u(\\mathbf{x}) = (S_k Y_{\\ell}^m)(\\mathbf{x})$ is a radiating solution to the Helmholtz equation for $|\\mathbf{x}|  a$ and a regular solution for $|\\mathbf{x}|  a$. Using separation of variables, the potential can be expressed as:\n$$ u(\\mathbf{x}) = ik a^2 Y_{\\ell}^m(\\hat{\\mathbf{x}}) \\begin{cases} j_{\\ell}(ka) h_{\\ell}^{(1)}(kr)  r  a \\\\ h_{\\ell}^{(1)}(ka) j_{\\ell}(kr)  r  a \\end{cases} $$\nwhere $r=|\\mathbf{x}|$. The outward unit normal is $\\mathbf{n} = \\hat{\\mathbf{r}}$, so the normal derivative is $\\frac{\\partial}{\\partial n} = \\frac{\\partial}{\\partial r}$. The exterior (+) and interior (-) limits of the normal derivative on $\\Gamma$ are:\n$$ \\frac{\\partial u}{\\partial n}\\bigg|_{+} = \\frac{\\partial u}{\\partial r}\\bigg|_{r=a^+} = ik a^2 Y_{\\ell}^m(\\hat{\\mathbf{x}}) j_{\\ell}(ka) \\left[k \\frac{d}{d(kr)} h_{\\ell}^{(1)}(kr)\\right]_{r=a} = ik^2 a^2 j_{\\ell}(ka) h_{\\ell}^{(1)\\prime}(ka) Y_{\\ell}^m(\\hat{\\mathbf{x}}) $$\n$$ \\frac{\\partial u}{\\partial n}\\bigg|_{-} = \\frac{\\partial u}{\\partial r}\\bigg|_{r=a^-} = ik a^2 Y_{\\ell}^m(\\hat{\\mathbf{x}}) h_{\\ell}^{(1)}(ka) \\left[k \\frac{d}{d(kr)} j_{\\ell}(kr)\\right]_{r=a} = ik^2 a^2 h_{\\ell}^{(1)}(ka) j_{\\ell}^{\\prime}(ka) Y_{\\ell}^m(\\hat{\\mathbf{x}}) $$\nwhere the prime denotes differentiation with respect to the argument. The operator $K_k'$ is the average of these two limits:\n$$ (K_k' Y_{\\ell}^m)(\\mathbf{x}) = \\frac{1}{2} \\left(\\frac{\\partial u}{\\partial n}\\bigg|_{+} + \\frac{\\partial u}{\\partial n}\\bigg|_{-}\\right) $$\nSubstituting the derivative expressions yields:\n$$ (K_k' Y_{\\ell}^m)(\\mathbf{x}) = \\left( \\frac{1}{2} ik^2 a^2 \\left[ j_{\\ell}(ka) h_{\\ell}^{(1)\\prime}(ka) + h_{\\ell}^{(1)}(ka) j_{\\ell}^{\\prime}(ka) \\right] \\right) Y_{\\ell}^m(\\hat{\\mathbf{x}}) $$\nThe eigenvalues $\\kappa_{\\ell}'$ of the adjoint double-layer operator $K_k'$ are therefore:\n$$ \\kappa_{\\ell}' = \\frac{1}{2} i (ka)^2 \\left[ j_{\\ell}'(ka) h_{\\ell}^{(1)}(ka) + j_{\\ell}(ka) h_{\\ell}^{(1)\\prime}(ka) \\right] $$\n\n**3. Calderón Regularization and Condition Numbers**\n\nThe problem requires analyzing the operator $W_k S_k + \\frac{1}{4}I$. The provided Calderón identity states $W_k S_k = K_k'^2 - \\frac{1}{4}I$. Therefore, the regularized operator is simply $K_k'^2$. Since $Y_{\\ell}^m$ are eigenfunctions of $K_k'$ with eigenvalues $\\kappa_{\\ell}'$, they are also eigenfunctions of $K_k'^2$ with eigenvalues $(\\kappa_{\\ell}')^2$.\n\nThe condition number of a linear operator represented as a matrix is the ratio of its largest to smallest singular values. In the basis $\\{Y_{\\ell}^m\\}_{\\ell=0,..,L}$, the operators $S_k$ and $K_k'^2$ are represented by diagonal matrices with entries $\\{v_{\\ell}\\}$ and $\\{(\\kappa_{\\ell}')^2\\}$, respectively (with multiplicities $2\\ell+1$). The singular values are the magnitudes of these eigenvalues.\n\nThe condition number of the truncated single-layer operator $S_k$ is:\n$$ \\text{cond}(S_k) = \\frac{\\max_{\\ell \\in \\{0, \\dots, L\\}} |v_{\\ell}|}{\\min_{\\ell \\in \\{0, \\dots, L\\}} |v_{\\ell}|} $$\n\nThe condition number of the Calderón-regularized operator $K_k'^2$ is:\n$$ \\text{cond}(K_k'^2) = \\frac{\\max_{\\ell \\in \\{0, \\dots, L\\}} |(\\kappa_{\\ell}')^2|}{\\min_{\\ell \\in \\{0, \\dots, L\\}} |(\\kappa_{\\ell}')^2|} = \\frac{\\left(\\max_{\\ell \\in \\{0, \\dots, L\\}} |\\kappa_{\\ell}'|\\right)^2}{\\left(\\min_{\\ell \\in \\{0, \\dots, L\\}} |\\kappa_{\\ell}'|\\right)^2} $$\n\nThe improvement factor is the ratio of these two condition numbers, $\\text{cond}(S_k) / \\text{cond}(K_k'^2)$.\n\n**4. Algorithmic Implementation**\n\nThe numerical evaluation proceeds as follows:\nFor each test case $(a, k, L)$:\n1.  Define the argument $z = ka$.\n2.  For each integer order $\\ell$ from $0$ to $L$:\n    a. Compute the spherical Bessel functions $j_{\\ell}(z)$, $j_{\\ell}'(z)$ and the spherical Neumann functions $y_{\\ell}(z)$, $y_{\\ell}'(z)$ using a robust library such as `scipy.special`.\n    b. Construct the spherical Hankel functions $h_{\\ell}^{(1)}(z) = j_{\\ell}(z) + i y_{\\ell}(z)$ and their derivatives $h_{\\ell}^{(1)\\prime}(z) = j_{\\ell}'(z) + i y_{\\ell}'(z)$.\n    c. Evaluate the eigenvalues $v_{\\ell}$ and $\\kappa_{\\ell}'$ using the derived formulas.\n3.  Form the arrays of absolute values $|v_0|, \\dots, |v_L|$ and $|\\kappa'_0|^2, \\dots, |\\kappa'_L|^2$.\n4.  Compute the condition numbers by finding the maximum and minimum values in these arrays and taking their ratios.\n5.  Compute the improvement factor.\n\nFor the special case $L=0$, the basis consists of a single function. The resulting operator matrices are $1 \\times 1$, and their condition numbers are trivially $1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing condition numbers for boundary integral operators on a sphere.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, k, L).\n    test_cases = [\n        (1.0, 0.3, 8),\n        (1.0, 2.0, 20),\n        (1.0, 10.0, 35),\n        (1.0, 0.5, 0),\n    ]\n\n    results = []\n    for a, k, L in test_cases:\n        # For L=0, the basis contains a single function space. The condition\n        # number of any operator represented in this basis is trivially 1.\n        if L == 0:\n            results.append([1.0, 1.0, 1.0])\n            continue\n\n        # Wavenumber-radius product\n        z = k * a\n        # Array of spherical harmonic degrees\n        ells = np.arange(L + 1)\n\n        # Compute spherical Bessel and Neumann functions of orders 0 to L\n        # The sph_jn(L, z) call returns an array of values for n=0..L\n        j_l = spherical_jn(ells, z)\n        y_l = spherical_yn(ells, z)\n\n        # Compute derivatives of spherical Bessel and Neumann functions\n        # The derivative call in scipy requires a loop over orders.\n        j_l_prime = np.array([spherical_jn(l, z, derivative=True) for l in ells])\n        y_l_prime = np.array([spherical_yn(l, z, derivative=True) for l in ells])\n\n        # Construct spherical Hankel functions and their derivatives\n        # h_l^(1)(z) = j_l(z) + i * y_l(z)\n        h1_l = j_l + 1j * y_l\n        h1_l_prime = j_l_prime + 1j * y_l_prime\n\n        # 1. Compute eigenvalues {v_l} of the single-layer operator S_k\n        # v_l = i * k * a^2 * j_l(ka) * h_l^(1)(ka)\n        v_l_vals = 1j * k * a**2 * j_l * h1_l\n\n        # 2. Compute eigenvalues {kappa'_l} of the adjoint double-layer operator K'_k\n        # kappa'_l = 0.5 * i * (ka)^2 * (j_l'(ka)h_l^(1)(ka) + j_l(ka)h_l^(1)'(ka))\n        k_prime_l_vals = 0.5 * 1j * z**2 * (j_l_prime * h1_l + j_l * h1_l_prime)\n        \n        # 3. Form eigenvalues of Calderon-regularized operator, { (kappa'_l)^2 }\n        # These are simply the square of the eigenvalues of K'_k.\n\n        # 4. Compute condition numbers and improvement factor\n        \n        # Magnitudes of eigenvalues of S_k\n        abs_v = np.abs(v_l_vals)\n        # Magnitudes of eigenvalues of K'_k^2, which is |kappa'_l|^2\n        abs_k_sq = np.abs(k_prime_l_vals)**2\n\n        # Condition number of S_k\n        cond_S = np.max(abs_v) / np.min(abs_v)\n        \n        # Condition number of K'_k^2\n        cond_R = np.max(abs_k_sq) / np.min(abs_k_sq)\n        \n        # Improvement factor\n        improvement = cond_S / cond_R\n\n        results.append([cond_S, cond_R, improvement])\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}