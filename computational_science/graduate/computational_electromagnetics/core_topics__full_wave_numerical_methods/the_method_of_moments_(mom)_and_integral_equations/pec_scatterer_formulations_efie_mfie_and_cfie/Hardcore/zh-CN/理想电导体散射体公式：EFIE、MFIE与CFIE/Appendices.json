{
    "hands_on_practices": [
        {
            "introduction": "直接应用电场积分方程（EFIE）会遇到一个在数值上难以处理的强奇异积分。本练习将引导您完成一个关键的数学变换，将有问题的“超奇异”项转化为一组更易于处理的正则化项。掌握这项推导是构建一个可用的基于EFIE求解器的基础技能。",
            "id": "3338424",
            "problem": "考虑自由空间中一个光滑、闭合的理想电导体 (PEC) 表面 $S$，被角频率为 $\\omega$、自由空间波数为 $k$ 的时谐波照射。记观测点为 $\\mathbf{r}$，源点为 $\\mathbf{r}'$，两者间距为 $R = |\\mathbf{r} - \\mathbf{r}'|$。令 $G(\\mathbf{r}, \\mathbf{r}') = \\exp(-ik R)/(4\\pi R)$ 为自由空间标量格林函数，它在广义函数意义下求解亥姆霍兹方程。在电场积分方程 (EFIE) 中，标量势的贡献通常以算子 $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$ 的形式出现，其中 $\\mathbf{J}(\\mathbf{r}')$ 是 $S$ 上的感应表面电流密度。\n\n从旋度的旋度的矢量微积分恒等式、关于 $G(\\mathbf{r}, \\mathbf{r}')$ 的广义亥姆霍兹方程以及 $\\mathbf{J}(\\mathbf{r}')$ 独立于观测变量 $\\mathbf{r}$ 这一事实出发，推导数量 $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$ 的一个公式，该公式能分离出至多是弱奇异且在标准意义下可在 $S$ 上积分的核函数。您的推导必须仔细追踪哪些导数作用于 $\\mathbf{r}$ 与 $\\mathbf{r}'$，并对出现的任何广义函数项的处理给出合理解释。将最终结果表示为单个闭合形式的解析表达式，该表达式在关于 $\\mathbf{r}'$ 的 $S$ 曲面积分下有效。\n\n明确地用算子 $\\nabla$、$\\nabla \\times$、标量格林函数 $G(\\mathbf{r}, \\mathbf{r}')$、波数 $k$ 和电流密度 $\\mathbf{J}(\\mathbf{r}')$ 来陈述您的最终表达式。不需要数值计算，也无需取整。最终答案必须是单个闭合形式的解析表达式。",
            "solution": "该问题是有效的，因为它是计算电磁学中的一个标准推导，基于矢量微积分和广义函数理论。所有术语都有明确定义，问题本身是自洽和客观的。\n\n目标是为数量 $\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$ 寻找一个替代表达式。符号 $\\nabla \\nabla \\cdot$ 代表算子序列 $\\nabla(\\nabla \\cdot)$。以 $\\nabla$ 表示的导数是关于观测点坐标 $\\mathbf{r}$ 的。电流密度 $\\mathbf{J}(\\mathbf{r}')$ 是源点坐标 $\\mathbf{r}'$ 的函数，因此相对于 $\\nabla$ 算子被视为一个常矢量。\n\n出发点是定义矢量拉普拉斯算子的标准矢量微积分恒等式，该恒等式在广义函数意义下成立：\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}\n$$\n在此恒等式中，$\\mathbf{A}$ 是一个任意矢量场。我们感兴趣的是 $\\nabla(\\nabla \\cdot \\mathbf{A})$ 这一项。通过重新排列该恒等式，我们可以将其表示为：\n$$\n\\nabla(\\nabla \\cdot \\mathbf{A}) = \\nabla \\times (\\nabla \\times \\mathbf{A}) + \\nabla^2 \\mathbf{A}\n$$\n我们将此恒等式应用于矢量场 $\\mathbf{A}(\\mathbf{r}) = \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')$。我们希望重构的项是左手边的 $\\nabla(\\nabla \\cdot (\\mathbf{J}G))$。\n\n我们来分析 $\\nabla^2 \\mathbf{A} = \\nabla^2 (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))$ 这一项。由于 $\\mathbf{J}(\\mathbf{r}')$ 相对于 $\\nabla$ 中的导数是一个常矢量，我们可以将其从微分中提出来：\n$$\n\\nabla^2 (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')) = \\mathbf{J}(\\mathbf{r}') \\nabla^2 G(\\mathbf{r}, \\mathbf{r}')\n$$\n问题给出了标量格林函数 $G$ 所满足的广义亥姆霍兹方程：\n$$\n(\\nabla^2 + k^2)G(\\mathbf{r}, \\mathbf{r}') = -\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n其中 $k$ 是波数，$\\delta(\\mathbf{r} - \\mathbf{r}')$ 是三维狄拉克 $\\delta$ 广义函数。我们可以解出 $\\nabla^2 G$：\n$$\n\\nabla^2 G(\\mathbf{r}, \\mathbf{r}') = -k^2 G(\\mathbf{r}, \\mathbf{r}') - \\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n将 $\\nabla^2 G$ 的这个表达式代入我们关于 $\\nabla^2 \\mathbf{A}$ 的方程中，得到：\n$$\n\\nabla^2 (\\mathbf{J}G) = \\mathbf{J}(-k^2 G - \\delta(\\mathbf{r} - \\mathbf{r}')) = -k^2 \\mathbf{J}G - \\mathbf{J}\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n现在，我们将此结果代回重新排列过的关于 $\\nabla(\\nabla \\cdot (\\mathbf{J}G))$ 的矢量恒等式中：\n$$\n\\nabla(\\nabla \\cdot (\\mathbf{J}G)) = \\nabla \\times (\\nabla \\times (\\mathbf{J}G)) + (-k^2 \\mathbf{J}G - \\mathbf{J}\\delta(\\mathbf{r} - \\mathbf{r}'))\n$$\n这就给出了目标量的最终公式：\n$$\n\\nabla \\nabla \\cdot (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}')) = \\nabla \\times (\\nabla \\times (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))) - k^2 \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') - \\mathbf{J}(\\mathbf{r}')\\delta(\\mathbf{r} - \\mathbf{r}')\n$$\n该恒等式将超奇异算子 $\\nabla\\nabla\\cdot$（当 $R=|\\mathbf{r}-\\mathbf{r}'|\\to 0$ 时，其行为如同 $R^{-3}$）替换为三项之和。在数值求解积分方程（例如，通过矩量法）的背景下，这种新形式是有利的。核函数为 $G$ 的项是弱奇异的（$O(R^{-1})$），狄拉克 $\\delta$ 项通过奇异性提取来处理，而旋度的旋度项，尽管仍包含一个强奇异核，但可以通过分部积分将一个微分算子转移到测试函数上进行正则化。这个过程使得最终的积分在计算上是可行的。所推导的表达式是此正则化过程的解析基础。",
            "answer": "$$\\boxed{\\nabla \\times (\\nabla \\times (\\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}'))) - k^2 \\mathbf{J}(\\mathbf{r}') G(\\mathbf{r}, \\mathbf{r}') - \\mathbf{J}(\\mathbf{r}')\\delta(\\mathbf{r} - \\mathbf{r}')}$$"
        },
        {
            "introduction": "在解决了理论上的挑战之后，本实践将转向一个计算基准测试，以观察EFIE和CFIE在实际应用中的表现。通过分析圆柱体的散射问题——一个有精确解析解的问题——我们可以精确地量化数值误差，并观察到组合场积分方程（CFIE）的卓越稳定性，尤其是在具有挑战性的近场激励条件下。这个练习旨在建立关于不同积分方程公式之间实际权衡的直观理解。",
            "id": "3338441",
            "problem": "考虑一个半径为 $a$ 的理想电导体 (PEC) 圆柱体置于自由空间中，其二维横磁极化 ($TM_z$) 散射问题。总电场 $u(\\mathbf{r})$ 满足波数为 $k$ 的标量 Helmholtz 方程，且理想电导体边界条件要求在边界 $\\Gamma = \\{ \\mathbf{r} : |\\mathbf{r}| = a \\}$ 上 $u(\\mathbf{r}) = 0$。入射场由位于极坐标 $\\mathbf{r}_s = (\\rho_s, \\theta_s)$（其中 $\\rho_s > a$）处的元电线源产生，其格林函数为 $G(\\mathbf{r}, \\mathbf{r}_s) = \\dfrac{i}{4} H_0^{(1)}(k|\\mathbf{r} - \\mathbf{r}_s|)$，其中 $H_0^{(1)}$ 是零阶第一类 Hankel 函数。不失一般性，我们设 $\\theta_s = 0$。\n\n您将构建一个模式基准，用以比较当源靠近理想电导体边界（强近场激励）时，电场积分方程 (EFIE) 和组合场积分方程 (CFIE) 的远场误差。目的是研究 CFIE 是否通过第二类方程的形式来平衡近场算子的奇异性，从而提高精度。\n\n请从电磁散射的基本定律和核心定义出发，将其简化为二维 $TM_z$ 情况下的标量 Helmholtz 方程，并利用圆上的柱面波加法定理，在傅里叶基中实现算子的对角化。请勿使用任何未从这些基础推导出的简化公式。\n\n在圆形边界上采用以下规范模式框架：\n\n- 用角度 $\\theta \\in [0, 2\\pi)$ 对边界进行参数化，并将边界函数展开为傅里叶模式 $e^{i n \\theta}$，其中 $n$ 为整数。\n- 令 $u^{\\text{inc}}(a,\\theta)$ 表示限制在边界上的入射场。其傅里叶系数 $b_n$ 满足\n$$\nu^{\\text{inc}}(a,\\theta) = \\sum_{n=-\\infty}^{\\infty} b_n e^{i n \\theta}.\n$$\n- 圆柱体外的散射场允许进行模式展开\n$$\nu^{\\text{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(k r) e^{i n \\theta}, \\quad r \\ge a,\n$$\n其中 $H_n^{(1)}$ 是整数阶 $n$ 的第一类 Hankel 函数。\n- EFIE（单层）表示法使用边界密度 $\\mu(\\theta)$，使得\n$$\nu^{\\text{scat}}(\\mathbf{r}) = \\int_{\\Gamma} G(\\mathbf{r}, \\mathbf{r}') \\mu(\\theta') \\, d\\ell',\n$$\n并通过在 $\\Gamma$ 上施加 $u^{\\text{inc}} + u^{\\text{scat}} = 0$ 来求解 $\\mu(\\theta) = \\sum \\mu_n e^{i n \\theta}$ 的傅里叶系数 $\\mu_n$。\n- CFIE 使用组合表示法\n$$\nu^{\\text{scat}}(\\mathbf{r}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{r}, \\mathbf{r}')}{\\partial n'} \\mu(\\theta') \\, d\\ell' + i \\eta \\int_{\\Gamma} G(\\mathbf{r}, \\mathbf{r}') \\mu(\\theta') \\, d\\ell',\n$$\n其中 $\\eta > 0$ 为实数耦合参数，并通过在 $\\Gamma$ 上施加理想电导体边界条件来求解傅里叶系数 $\\mu_n$。\n\n利用圆上的加法定理，单层和双层边界积分算子在傅里叶基中均可对角化，其特征值仅依赖于 $n$ 和 $k a$。记 $J_n$ 为第一类 Bessel 函数，记 $J_n'$ 为其关于宗量的导数。对于 $\\Gamma$ 上的单层算子 $S$ 和双层算子 $K$（源的法向导数），其傅里叶特征值 $s_n$ 和 $\\kappa_n$ 满足\n$$\ns_n = \\frac{i \\pi a}{2} H_n^{(1)}(k a) J_n(k a), \\qquad \\kappa_n = \\frac{i \\pi a k}{2} H_n^{(1)}(k a) J_n'(k a).\n$$\n根据 $\\Gamma$ 上的理想电导体边界条件 $u^{\\text{inc}} + u^{\\text{scat}} = 0$，模式方程变为：\n- EFIE：$s_n \\mu_n = - b_n$，因此 $\\mu_n = - b_n / s_n$。\n- CFIE：$\\left( \\frac{1}{2} + \\kappa_n + i \\eta s_n \\right) \\mu_n = - b_n$，因此 $\\mu_n = - b_n / \\left( \\frac{1}{2} + \\kappa_n + i \\eta s_n \\right)$。\n\n观测点 $(r_{\\text{obs}}, \\theta_{\\text{obs}})$ 处的远场由模式和组装而成：\n- 通过单层表示的 EFIE 散射场：\n$$\nu^{\\text{scat}}_{\\text{EFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\frac{i}{4} a (2\\pi) \\sum_{n=-N}^{N} H_n^{(1)}(k r_{\\text{obs}}) J_n(k a) \\mu_n e^{i n \\theta_{\\text{obs}}}.\n$$\n- 通过组合表示的 CFIE 散射场：\n$$\nu^{\\text{scat}}_{\\text{CFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\frac{i}{4} a (2\\pi) \\sum_{n=-N}^{N} H_n^{(1)}(k r_{\\text{obs}}) \\left[ k J_n'(k a) + i \\eta J_n(k a) \\right] \\mu_n e^{i n \\theta_{\\text{obs}}}.\n$$\n\n对于位于 $(\\rho_s, \\theta_s)$（其中 $\\rho_s > a$）的点源，加法定理给出边界系数\n$$\nb_n = \\frac{i}{4} H_n^{(1)}(k \\rho_s) J_n(k a) e^{- i n \\theta_s}.\n$$\n通过施加 $u^{\\text{inc}}(a,\\theta) + u^{\\text{scat}}(a,\\theta) = 0$ 和正交性得到的精确散射场模式系数满足\n$$\nA_n = - \\frac{b_n}{H_n^{(1)}(k a)}.\n$$\n精确远场则为\n$$\nu^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\approx \\sum_{n=-N_{\\text{ref}}}^{N_{\\text{ref}}} A_n H_n^{(1)}(k r_{\\text{obs}}) e^{i n \\theta_{\\text{obs}}}.\n$$\n\n您的程序必须：\n- 实现上述模式框架，使用从 $n=-N$到 $n=+N$ 的截断模式和来计算 EFIE 和 CFIE 的近似解，并将每个结果与使用更大参考截断数 $N_{\\text{ref}}$ 计算的精确远场进行比较。\n- 使用以下固定的物理参数：$a = 0.5$ 米，$k = 20.0$ 弧度/米，$\\theta_s = 0.0$ 弧度，$\\theta_{\\text{obs}} = 0.0$ 弧度，$r_{\\text{obs}} = 5.0$ 米，$\\eta = 1.0$ (无量纲)。\n- 通过 $\\rho_s = a + d$ 来改变源距离，其中 $d$ 为小偏移量，以模拟强近场激励。\n- 按如下方式计算每种公式的相对复数场误差\n$$\n\\varepsilon_{\\star} = \\frac{\\left| u^{\\text{scat}}_{\\star}(r_{\\text{obs}}, \\theta_{\\text{obs}}) - u^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\right|}{\\left| u^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) \\right|},\n$$\n其中 $\\star \\in \\{ \\text{EFIE}, \\text{CFIE} \\}$，结果表示为十进制数（无单位）。\n\n角度必须以弧度为单位。距离必须以米为单位。波数必须以弧度/米为单位。\n\n测试套件：\n- 情况 1：$d = 0.05$，$N = 20$。\n- 情况 2：$d = 0.01$，$N = 20$。\n- 情况 3：$d = 0.005$，$N = 20$。\n- 情况 4 (边界条件检查)：$d = 0.01$，$N = N_{\\text{ref}}$。\n- 情况 5 (增加截断数)：$d = 0.005$，$N = 40$。\n\n在所有情况下，精确解均使用 $N_{\\text{ref}} = 120$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下\n$$\n\\left[ \\varepsilon_{\\text{EFIE},1}, \\varepsilon_{\\text{CFIE},1}, \\varepsilon_{\\text{EFIE},2}, \\varepsilon_{\\text{CFIE},2}, \\varepsilon_{\\text{EFIE},3}, \\varepsilon_{\\text{CFIE},3}, \\varepsilon_{\\text{EFIE},4}, \\varepsilon_{\\text{CFIE},4}, \\varepsilon_{\\text{EFIE},5}, \\varepsilon_{\\text{CFIE},5} \\right].\n$$\n所有数值输出必须是十进制数（不带百分号）。确保整个过程的科学真实性和自洽性。",
            "solution": "所提出的问题是计算电磁学中的一个典型练习，具体涉及二维横磁 ($TM_z$) 波从理想电导体 (PEC) 圆柱体散射的数值解。该问题要求通过模式分析来比较电场积分方程 (EFIE) 和组合场积分方程 (CFIE)，对于此特定几何结构，模式分析是一种精确的半解析技术。\n\n验证过程确认了该问题具有科学依据、是适定的且自洽的。所有提供的物理参数、数学公式和定义都是标准的，并且与电磁散射理论和边界积分方程的既有文献一致。问题的核心在于圆形几何的边界积分算子在傅里叶基中的对角化，这是旋转对称性和柱函数加法定理应用的结果。我将继续进行完整求解。\n\n求解框架建立在总电场 $z$ 分量 $u(\\mathbf{r})$ 的标量 Helmholtz 方程之上：\n$$ (\\nabla^2 + k^2) u(\\mathbf{r}) = 0 $$\n其中 $k$ 是波数。总场是已知的入射场 $u^{\\text{inc}}$ 和未知的散射场 $u^{\\text{scat}}$ 的和。圆柱表面 $\\Gamma$ 上的理想电导体边界条件规定总电场的切向分量必须为零。对于 $TM_z$ 极化，这简化为一个标量 Dirichlet 条件：\n$$ u^{\\text{total}}(\\mathbf{r}) = u^{\\text{inc}}(\\mathbf{r}) + u^{\\text{scat}}(\\mathbf{r}) = 0, \\quad \\text{对于 } \\mathbf{r} \\in \\Gamma $$\n\n入射场由位于 $\\mathbf{r}_s = (\\rho_s, \\theta_s)$ 的线源产生，在自由空间中，它辐射的场由格林函数 $G(\\mathbf{r}, \\mathbf{r}_s) = \\frac{i}{4} H_0^{(1)}(k|\\mathbf{r} - \\mathbf{r}_s|)$ 给出。散射场必须满足 Sommerfeld 辐射条件，通过使用出射柱面波（第一类 Hankel 函数）的展开式来表示散射场，可以自动确保该条件得到满足：\n$$ u^{\\text{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(k r) e^{i n \\theta} $$\n系数 $A_n$ 是待求的未知量。\n\n该问题要求通过边界积分方程求解，这种方法将问题重新表述为求解边界 $\\Gamma$ 上的未知源密度。\n\n**1. 模式分析与算子对角化**\n\n对于半径为 $a$ 的圆形边界，我们用角度 $\\theta$ 对点进行参数化。此边界上的函数可以自然地展开为傅里叶级数，$f(\\theta) = \\sum_n f_n e^{in\\theta}$。关键的洞察在于，对于这种几何结构，边界积分算子在角度上是卷积的，因此它们可以被傅里叶基 $\\{e^{in\\theta}\\}$ 对角化。\n\n边界上的入射场 $u^{\\text{inc}}(a, \\theta)$ 是通过计算格林函数得到的，其中 $\\mathbf{r}$ 在 $\\Gamma$ 上，$\\mathbf{r}_s$ 在外部。利用柱函数的加法定理，我们有：\n$$ u^{\\text{inc}}(a, \\theta) = G(\\mathbf{r}(\\theta), \\mathbf{r}_s) = \\frac{i}{4} \\sum_{n=-\\infty}^{\\infty} J_n(ka) H_n^{(1)}(k\\rho_s) e^{in(\\theta - \\theta_s)} $$\n由此，我们确定入射场的傅里叶系数 $b_n$：\n$$ b_n = \\frac{i}{4} J_n(ka) H_n^{(1)}(k\\rho_s) e^{-in\\theta_s} $$\n\n**2. 精确解（参考）**\n\n求解散射场系数 $A_n$ 最直接的方法是在模式展开式上施加边界条件：\n$$ u^{\\text{inc}}(a, \\theta) + u^{\\text{scat}}(a, \\theta) = \\sum_{n=-\\infty}^{\\infty} b_n e^{in\\theta} + \\sum_{n=-\\infty}^{\\infty} A_n H_n^{(1)}(ka) e^{in\\theta} = 0 $$\n根据傅里叶基的正交性，我们可以对每个模式 $n$ 的系数建立等式：\n$$ b_n + A_n H_n^{(1)}(ka) = 0 \\implies A_n = -\\frac{b_n}{H_n^{(1)}(ka)} $$\n代入 $b_n$ 的表达式：\n$$ A_n = - \\frac{\\frac{i}{4} J_n(ka) H_n^{(1)}(k\\rho_s) e^{-in\\theta_s}}{H_n^{(1)}(ka)} $$\n然后，通过对模式求和来组装精确的散射场，求和在足够大的参考数 $N_{\\text{ref}}$ 处截断：\n$$ u^{\\text{scat}}_{\\text{exact}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) = \\sum_{n=-N_{\\text{ref}}}^{N_{\\text{ref}}} A_n H_n^{(1)}(kr_{\\text{obs}}) e^{in\\theta_{\\text{obs}}} $$\n\n**3. 电场积分方程 (EFIE)**\n\nEFIE 将散射场表示为由边界上的一个虚拟单层源密度 $\\mu(\\theta)$ 辐射产生：\n$$ u^{\\text{scat}}(\\mathbf{r}) = (S\\mu)(\\mathbf{r}) = \\int_{\\Gamma} G(\\mathbf{r}, \\mathbf{r}') \\mu(\\theta') d\\ell' $$\n在 $\\Gamma$ 上的边界条件 $u^{\\text{inc}} + u^{\\text{scat}} = 0$ 导出了算子方程 $S\\mu = -u^{\\text{inc}}$。在傅里叶域中，这变成了针对每个模式的简单代数方程：\n$$ s_n \\mu_n = -b_n $$\n其中 $s_n = \\frac{i\\pi a}{2} J_n(ka) H_n^{(1)}(ka)$ 是单层算子 $S$ 的特征值。因此，所求的密度系数为：\n$$ \\mu_n^{\\text{EFIE}} = -\\frac{b_n}{s_n} $$\n一旦求得 $\\mu_n$，就可以通过计算辐射积分来得到任意观测点 $\\mathbf{r}_{\\text{obs}}$ 处的散射场，这在模式域中变为：\n$$ u^{\\text{scat}}_{\\text{EFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) = \\sum_{n=-N}^{N} \\left( \\frac{i\\pi a}{2} J_n(ka) H_n^{(1)}(kr_{\\text{obs}}) \\right) \\mu_n^{\\text{EFIE}} e^{in\\theta_{\\text{obs}}} $$\n一个关键的观察是，如果我们代入 $\\mu_n^{\\text{EFIE}}$、$b_n$ 和 $s_n$ 的表达式，EFIE 散射场的模式振幅会简化为与精确解 $A_n H_n^{(1)}(kr_{\\text{obs}})$ 完全相同。因此，与参考解相比，EFIE 解的任何误差都纯粹来自于级数在 $N  N_{\\text{ref}}$ 处的截断。对于情况 4，其中 $N = N_{\\text{ref}}$，EFIE 误差应为零（在浮点精度范围内）。\n\n**4. 组合场积分方程 (CFIE)**\n\n该问题指定了一种特定的基于表示的 CFIE。散射场由单层 ($S$) 和双层 ($K$) 位势的组合表示，使用相同的虚拟密度 $\\mu$：\n$$ u^{\\text{scat}}(\\mathbf{r}) = (K\\mu + i\\eta S\\mu)(\\mathbf{r}) $$\n在 $\\Gamma$ 上应用边界条件 $u^{\\text{inc}} + u^{\\text{scat}} = 0$ 需要小心处理双层位势的跳跃性质，这导致了算子方程 $(\\frac{1}{2}I + K + i\\eta S)\\mu = -u^{\\text{inc}}$。在模式域中，这变为：\n$$ \\left(\\frac{1}{2} + \\kappa_n + i\\eta s_n\\right) \\mu_n = -b_n $$\n其中 $\\kappa_n = \\frac{i\\pi a k}{2} J_n'(ka) H_n^{(1)}(ka)$ 是双层算子 $K$ 的特征值。密度系数为：\n$$ \\mu_n^{\\text{CFIE}} = -\\frac{b_n}{\\frac{1}{2} + \\kappa_n + i\\eta s_n} $$\n然后，通过在观测点位置计算组合表示来得到散射场：\n$$ u^{\\text{scat}}_{\\text{CFIE}}(r_{\\text{obs}}, \\theta_{\\text{obs}}) = \\sum_{n=-N}^{N} \\left( \\frac{i\\pi a}{2} \\left[k J_n'(ka) + i\\eta J_n(ka) \\right] H_n^{(1)}(kr_{\\text{obs}})\\right) \\mu_n^{\\text{CFIE}} e^{in\\theta_{\\text{obs}}}$$\n与 EFIE 不同，对于给定的模式 $n$，CFIE 散射场的表达式不会简化为精确解。这种公式引入了固有的差异，因为用于求解密度 $\\mu_n$ 的方程和用于求散射场的表示法是为了确保适定性而构建的，不一定与每个模式的精确物理过程相一致。因此，误差 $\\varepsilon_{\\text{CFIE}}$ 将是截断误差（$N  N_{\\text{ref}}$）和这种固有公式误差的组合。因此，我们预期即使在 $N = N_{\\text{ref}}$ 时，$\\varepsilon_{\\text{CFIE}}$ 也不会为零。\n\n研究的核心是评估这些误差，特别是当源靠近边界（$d$ 很小）时。近场激励倾向于产生具有丰富高频分量的密度 $\\mu$，这使得精确求解更具挑战性，并加剧了 EFIE 中的任何病态问题，而 CFIE 正是为了缓解这些问题而设计的。\n\n**5. 实现**\n程序将为每个测试用例实现这些步骤。\n- 定义物理和数值参数。\n- 对于每个用例 $(d, N)$，计算 $\\rho_s = a+d$。\n- 使用高模式数 $N_{\\text{ref}}$ 计算参考解 $u^{\\text{scat}}_{\\text{exact}}$。\n- 使用模式数 $N$ 计算 EFIE 解 $u^{\\text{scat}}_{\\text{EFIE}}$。\n- 使用模式数 $N$ 计算 CFIE 解 $u^{\\text{scat}}_{\\text{CFIE}}$。\n- 计算相对误差 $\\varepsilon_{\\text{EFIE}}$ 和 $\\varepsilon_{\\text{CFIE}}$ 并存储它们。\n- 最后，以指定格式打印收集到的结果。计算将依赖于 `numpy` 库进行矢量化计算，以及 `scipy.special` 库来获取所需的 Bessel 和 Hankel 函数及其导数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jn, hankel1, jvp\n\ndef solve():\n    \"\"\"\n    Solves the TM_z scattering problem for a PEC cylinder using modal analysis\n    for EFIE and CFIE formulations and computes the far-field error.\n    \"\"\"\n    # Fixed physical parameters\n    a = 0.5  # meters\n    k = 20.0  # radians per meter\n    theta_s = 0.0  # radians\n    r_obs = 5.0  # meters\n    theta_obs = 0.0  # radians\n    eta = 1.0  # dimensionless\n    N_ref = 120 # Reference truncation order\n\n    # Derived constants\n    ka = k * a\n    kr_obs = k * r_obs\n    i = 1j\n\n    test_cases = [\n        # (d, N)\n        (0.05, 20),\n        (0.01, 20),\n        (0.005, 20),\n        (0.01, N_ref), # Boundary condition check with N = N_ref\n        (0.005, 40),\n    ]\n\n    results = []\n\n    for d, N in test_cases:\n        rho_s = a + d\n        k_rho_s = k * rho_s\n\n        # Use complex128 for high precision\n        ka = np.complex128(ka)\n        kr_obs = np.complex128(kr_obs)\n        k_rho_s = np.complex128(k_rho_s)\n\n        # --- 1. Compute Exact Solution (Reference) ---\n        n_ref_vals = np.arange(-N_ref, N_ref + 1)\n        \n        # Incident field coefficients b_n\n        # b_n = (i/4) * H_n^(1)(k*rho_s) * J_n(k*a) * exp(-i*n*theta_s)\n        # Since theta_s = 0, exp term is 1\n        b_n_ref = (i / 4.0) * hankel1(n_ref_vals, k_rho_s) * jn(n_ref_vals, ka)\n\n        # Exact scattered field coefficients A_n\n        # A_n = -b_n / H_n^(1)(k*a)\n        A_n_exact = -b_n_ref / hankel1(n_ref_vals, ka)\n        \n        # Exact scattered field u_scat\n        # u_scat = sum(A_n * H_n^(1)(k*r_obs) * exp(i*n*theta_obs))\n        # Since theta_obs = 0, exp term is 1\n        u_scat_exact = np.sum(A_n_exact * hankel1(n_ref_vals, kr_obs))\n\n        # --- 2. Compute EFIE and CFIE solutions ---\n        n_vals = np.arange(-N, N + 1)\n        \n        # Incident field coefficients b_n for the truncated series\n        b_n = (i / 4.0) * hankel1(n_vals, k_rho_s) * jn(n_vals, ka)\n        \n        # Operator eigenvalues\n        h1_ka = hankel1(n_vals, ka)\n        jn_ka = jn(n_vals, ka)\n        jnp_ka = jvp(n_vals, ka, 1) # Derivative of J_n at ka\n\n        s_n = (i * np.pi * a / 2.0) * h1_ka * jn_ka\n        kappa_n = (i * np.pi * a * k / 2.0) * h1_ka * jnp_ka\n\n        # --- EFIE ---\n        # Solve for density mu_n: s_n * mu_n = -b_n\n        mu_n_efie = -b_n / s_n\n\n        # Compute scattered field from mu_n\n        h1_krobs = hankel1(n_vals, kr_obs)\n        u_scat_efie_modes = (i * np.pi * a / 2.0) * h1_krobs * jn_ka * mu_n_efie\n        u_scat_efie = np.sum(u_scat_efie_modes)\n        \n        # --- CFIE ---\n        # Solve for density mu_n: (1/2 + kappa_n + i*eta*s_n) * mu_n = -b_n\n        D_n_cfie = 0.5 + kappa_n + i * eta * s_n\n        mu_n_cfie = -b_n / D_n_cfie\n\n        # Compute scattered field from mu_n (using combined representation)\n        field_kernel_cfie = (k * jnp_ka + i * eta * jn_ka)\n        u_scat_cfie_modes = (i * np.pi * a / 2.0) * h1_krobs * field_kernel_cfie * mu_n_cfie\n        u_scat_cfie = np.sum(u_scat_cfie_modes)\n\n        # --- 3. Compute Relative Errors ---\n        # Avoid division by zero if exact field is zero (unlikely here)\n        norm_exact = np.abs(u_scat_exact)\n        if norm_exact  1e-30:\n            norm_exact = 1.0\n\n        err_efie = np.abs(u_scat_efie - u_scat_exact) / norm_exact\n        err_cfie = np.abs(u_scat_cfie - u_scat_exact) / norm_exact\n\n        results.extend([err_efie, err_cfie])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这项高级实践解决了一个在标准EFIE和CFIE公式中存在的关键缺陷：非物理的“虚假”电荷累积，尤其是在低频情况下。我们将构建一个“拓扑感知”的求解器，它通过在求解过程中强制施加物理约束，来保证散射体每个连通分量上的电荷守恒。本练习介绍了使用约束线性代数（KKT系统）这一强大技术来构建更稳健、更符合物理规律的数值模型的方法。",
            "id": "3338421",
            "problem": "考虑一个在角频率为 $\\omega$ 的时谐激励下的理想电导体 (PEC) 散射体。未知的表面电流密度通过一组有限的基函数进行离散化，其系数向量为 $\\mathbf{x} \\in \\mathbb{R}^N$。相应的表面电荷密度通过电磁学中的连续性方程 $ \\nabla_t \\cdot \\mathbf{J}_s = - i \\omega \\rho_s$ 与表面电流密度相关联，其中 $\\nabla_t$ 表示切向（表面）散度，$\\mathbf{J}_s$ 是表面电流密度，$i$ 是虚数单位，$\\omega$ 是角频率，$\\rho_s$ 是表面电荷密度。对于一个在无源时谐激励下发生散射的闭合PEC，其每个连通分量上的总净电荷必须恒等于零。\n\nPEC散射的边界积分方程的分析和数值求解通常使用电场积分方程 (EFIE) 和磁场积分方程 (MFIE)。它们由麦克斯韦方程组和边界条件（电场为 $\\hat{\\mathbf{n}} \\times \\mathbf{E}_{\\text{tot}} = \\mathbf{0}$，以及涉及磁场算子主值的相应磁场边界条件）推导得出。组合场积分方程 (CFIE) 混合了EFIE和MFIE，以增强在不同频率下的鲁棒性并消除伪谐振。然而，如果散度-电荷耦合没有被完美地强制执行，离散近似可能会在每个连通分量的净电荷上表现出数值漂移，尤其是在存在离散化噪声和算子病态的情况下。\n\n您必须设计一种拓扑感知的组合场积分方程 (CFIE) 离散化方法，通过嵌入精确的线性约束，在每个连通分量上强制实现零净电荷。约束的构造必须使得对于每个连通分量 $c$，代表净散度引起的电荷代理的离散泛函 $g_c^\\top \\mathbf{x}$ 恒等于零。这些约束应通过一个能保证可解性和正确性的数学上合理的方法附加到CFIE系统中。\n\n为了使问题完全自洽且无需特定几何积分即可测试，请考虑以下抽象离散模型，该模型反映了EFIE、MFIE和CFIE的基本代数结构：\n\n- 离散EFIE算子由一个对称正定矩阵 $\\mathbf{A}_E \\in \\mathbb{R}^{N \\times N}$ 建模，该矩阵对于每个连通分量的“电荷模式”方向 $g_c \\in \\mathbb{R}^{N_c}$ 接近奇异。全局 $\\mathbf{A}_E$ 在各分量间是块对角的，并加入了微小的对称跨分量耦合噪声。这模拟了允许电荷漂移的数值敏感性。\n- 离散MFIE算子由一个对称正定矩阵 $\\mathbf{A}_M \\in \\mathbb{R}^{N \\times N}$ 建模，该矩阵在每个电荷模式方向上是良态的，从而减少电荷漂移。\n- CFIE算子 $\\mathbf{A}_C$ 是 $\\mathbf{A}_E$ 和 $\\mathbf{A}_M$ 的加权混合，然后通过正确的代数构造嵌入拓扑感知约束 $g_c^\\top \\mathbf{x} = 0$。该约束直接强制每个连通分量上的净电荷为零。\n- 右端向量 $\\mathbf{b} \\in \\mathbb{R}^N$ 编码了入射场激励。它包含每个 $g_c$ 方向上的一个受控分量，外加微小的随机扰动，以模拟离散化和建模不确定性。\n\n分量 $c$ 的“净电荷”代理通过 $Q_c = \\left|g_c^\\top \\mathbf{x}\\right| / \\omega$ 来衡量，当 $\\mathbf{x}$ 被解释为电流系数向量且 $g_c$ 被缩放以产生与连续性方程一致的电流-散度泛函时，其单位为库仑。在此抽象测试中，$\\omega$ 已指定，$g_c$ 作为无量纲方向提供；将 $\\mathbf{x}$ 的单位视为安培/米，并假设 $g_c$ 已经过缩放，使得 $Q_c$ 的单位正确地为库仑。您必须以库仑为单位报告 $Q_c$，并将每个值四舍五入到 $6$ 位小数。\n\n您的程序必须：\n- 根据上述描述，为每个测试用例构造 $\\mathbf{A}_E$ 和 $\\mathbf{A}_M$，使用每个分量的电荷模式向量 $\\{g_c\\}$ 和指定的条件数修正因子。\n- 使用物理上合理的凸加权参数 $\\alpha \\in (0,1)$ 混合 $\\mathbf{A}_E$ 和 $\\mathbf{A}_M$ 来形成CFIE算子 $\\mathbf{A}_C$。\n- 求解无约束的EFIE、MFIE和CFIE线性系统，以获得 $\\mathbf{x}_E$、$\\mathbf{x}_M$ 和 $\\mathbf{x}_C^{\\text{unc}}$。\n- 通过使用稳健的代数方法，为CFIE增补精确的线性约束 $g_c^\\top \\mathbf{x} = 0$，以强制执行拓扑感知约束，从而获得约束解 $\\mathbf{x}_C^{\\text{con}}$。\n- 对于四种解中的每一种，计算每个连通分量 $c$ 的净电荷代理 $Q_c = \\left|g_c^\\top \\mathbf{x}\\right| / \\omega$，并将每个 $Q_c$ 值四舍五入到 $6$ 位小数，单位为库仑。\n\n使用以下测试套件。每个测试用例提供连通分量的数量、每个分量的系数数量、角频率、CFIE权重、EFIE和MFIE的电荷模式条件数修正因子、分量间噪声水平以及用于可复现性的随机种子。用 $N_c$ 表示分量 $c$ 的大小，$N = \\sum_c N_c$。\n\n- 测试用例 1（理想路径，两个分量，EFIE轻度病态且噪声较小）：\n  - 分量：$2$ 个，大小为 $N_1 = 6, N_2 = 4$。\n  - 角频率：$\\omega = 2 \\pi \\cdot 10^6$ 弧度/秒。\n  - CFIE权重：$\\alpha = 0.7$。\n  - EFIE条件数修正因子：$\\mu_E = 0.9$。\n  - MFIE条件数修正因子：$\\mu_M = 0.2$。\n  - 分量间对称噪声水平：$\\varepsilon = 0.05$。\n  - 随机种子：$42$。\n\n- 测试用例 2（边界情况，单个分量，EFIE沿电荷模式方向精确中性且噪声极小）：\n  - 分量：$1$ 个，大小为 $N_1 = 5$。\n  - 角频率：$\\omega = 2 \\pi \\cdot 10^6$ 弧度/秒。\n  - CFIE权重：$\\alpha = 0.5$。\n  - EFIE条件数修正因子：$\\mu_E = 0.0$。\n  - MFIE条件数修正因子：$\\mu_M = 0.3$。\n  - 分量间对称噪声水平：$\\varepsilon = 0.01$。\n  - 随机种子：$7$。\n\n- 测试用例 3（边缘情况，三个分量，EFIE病态更强且噪声中等）：\n  - 分量：$3$ 个，大小为 $N_1 = 3, N_2 = 4, N_3 = 5$。\n  - 角频率：$\\omega = 2 \\pi \\cdot 10^5$ 弧度/秒。\n  - CFIE权重：$\\alpha = 0.6$。\n  - EFIE条件数修正因子：$\\mu_E = 0.95$。\n  - MFIE条件数修正因子：$\\mu_M = 0.1$。\n  - 分量间对称噪声水平：$\\varepsilon = 0.03$。\n  - 随机种子：$123$。\n\n每个测试用例的算子和右端项构造细节必须遵循以下规则：\n- 对于每个连通分量 $c$，从独立标准正态分布中抽取一个随机向量 $\\tilde{g}_c \\in \\mathbb{R}^{N_c}$，并将其归一化为单位范数以获得 $g_c$。\n- 构建分量 $c$ 的块对角EFIE算子块为 $\\mathbf{A}_{E,c} = \\mathbf{I}_{N_c} - \\mu_E \\, g_c g_c^\\top$，在 $\\mu_E \\in [0,1)$ 的条件下，该矩阵为对称正定矩阵。\n- 构建分量 $c$ 的块对角MFIE算子块为 $\\mathbf{A}_{M,c} = \\mathbf{I}_{N_c} + \\mu_M \\, g_c g_c^\\top$，对于任何 $\\mu_M \\ge 0$，该矩阵均为对称正定矩阵。\n- 通过将所有分量的 $\\mathbf{A}_{E,c}$ 和 $\\mathbf{A}_{M,c}$ 沿块对角线放置来组装 $\\mathbf{A}_E$ 和 $\\mathbf{A}_M$。然后添加一个小的对称跨分量噪声矩阵 $\\varepsilon \\, \\mathbf{N}$，其中 $\\mathbf{N}$ 是一个随机对称矩阵，其块对角线元素为零，其他元素从独立标准正态分布中抽取，并进行缩放以使 $\\|\\varepsilon \\mathbf{N}\\|_2$ 相对于块对角部分的最小特征值较小。\n- 设置 $\\mathbf{b} = \\sum_{c} \\beta \\, \\hat{\\mathbf{g}}_c + \\sigma \\, \\mathbf{n}$，其中 $\\hat{\\mathbf{g}}_c$ 表示将 $g_c$ 补零嵌入到全局向量空间中，$\\beta = 0.3$ 且 $\\sigma = 0.1$，$\\mathbf{n}$ 是一个具有独立标准正态分布项的全局随机向量。\n\n将CFIE算子构造成 $\\mathbf{A}_C = \\alpha \\mathbf{A}_E + (1-\\alpha) \\mathbf{A}_M$。为了对每个分量 $c$ 强制执行约束 $g_c^\\top \\mathbf{x} = 0$，组装一个约束矩阵 $\\mathbf{G} \\in \\mathbb{R}^{C \\times N}$，其第 $c$ 行为分量 $c$ 的补零 $g_c^\\top$，其中 $C$ 是连通分量的数量。使用鞍点（Karush–Kuhn–Tucker）系统求解带约束的CFIE：\n$$\n\\begin{bmatrix}\n\\mathbf{A}_C  \\mathbf{G}^\\top \\\\\n\\mathbf{G}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n\\mathbf{0}\n\\end{bmatrix},\n$$\n其中 $\\boldsymbol{\\lambda} \\in \\mathbb{R}^{C}$ 是拉格朗日乘子。\n\n为每个测试用例计算并报告四个列表，其中包含每个连通分量的净电荷代理 $Q_c = \\left|g_c^\\top \\mathbf{x}\\right| / \\omega$（单位为库仑，四舍五入到 $6$ 位小数）：\n- EFIE: $\\{ Q_c(\\mathbf{x}_E) \\}_c$。\n- MFIE: $\\{ Q_c(\\mathbf{x}_M) \\}_c$。\n- CFIE (无约束): $\\{ Q_c(\\mathbf{x}_C^{\\text{unc}}) \\}_c$。\n- CFIE (有约束): $\\{ Q_c(\\mathbf{x}_C^{\\text{con}}) \\}_c$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中不含任何空格。每个测试用例贡献一项，每一项是上述四个列表的列表。例如，输出必须看起来像 $\\big[ [ [\\dots],[\\dots],[\\dots],[\\dots] ], [ [\\dots],[\\dots],[\\dots],[\\dots] ], [ [\\dots],[\\dots],[\\dots],[\\dots] ] \\big]$，但打印时没有任何空格。\n- 所有报告的数字必须以库仑为单位，并四舍五入到 $6$ 位小数。\n\n此问题不涉及角度，唯一需要的物理单位是电荷单位库仑。确保所有计算都使用为每个测试用例提供的随机种子是可复现的。您的实现必须遵守上述模型和约束，并为提供的测试套件生成数值一致的解。",
            "solution": "该问题要求设计并实现一种用于理想电导体 (PEC) 散射体的拓扑感知组合场积分方程 (CFIE) 公式，该公式明确强制每个连通分量上的净电荷为零。这个问题被设定为一个抽象的代数问题，以测试核心数值原理，而无需进行几何离散化和积分的开销。\n\n解决方案分几个阶段进行：首先，我们形式化电场积分方程 (EFIE)、磁场积分方程 (MFIE) 和组合场积分方程 (CFIE) 算子的代数模型。其次，我们定义无约束和有约束的线性系统。最后，我们对给定的测试用例求解这些系统，并计算指定的电荷代理度量，以评估每种方法的性能。\n\n**1. 积分算子的代数建模**\n\n积分方程算子的物理行为通过抽象的对称正定矩阵来捕捉。需要建模的关键特征是EFIE相对于产生电荷的（无旋）电流模式的病态性，这是一个被称为低频灾难的现象。\n\n对于散射体的每个连通分量 $c$（具有 $N_c$ 个离散基函数），我们定义一个“电荷模式”向量 $g_c \\in \\mathbb{R}^{N_c}$。根据连续性方程 $\\nabla_t \\cdot \\mathbf{J}_s = - i \\omega \\rho_s$，该向量表示其表面散度非零从而产生净电荷的基函数的线性组合。分量 $c$ 上净电荷的离散模拟与 $g_c^\\top \\mathbf{x}_c$ 成正比，其中 $\\mathbf{x}_c$ 是该分量的基函数系数向量。\n\n分量 $c$ 的EFIE算子 $\\mathbf{A}_{E,c}$ 被建模为对于电荷模式 $g_c$ 是近奇异的。我们将其构造为：\n$$\n\\mathbf{A}_{E,c} = \\mathbf{I}_{N_c} - \\mu_E \\, g_c g_c^\\top\n$$\n其中 $\\mathbf{I}_{N_c}$ 是大小为 $N_c \\times N_c$ 的单位矩阵，$\\mu_E \\in [0, 1)$ 是一个条件数修正因子。向量 $g_c$ 是 $\\mathbf{A}_{E,c}$ 的一个特征向量，其特征值为 $1 - \\mu_E$。当 $\\mu_E \\to 1$ 时，该特征值趋近于零，模拟了EFIE对无旋电流的严重病态性。\n\n相反，MFIE对于此类模式表现良好。其算子 $\\mathbf{A}_{M,c}$ 被建模为：\n$$\n\\mathbf{A}_{M,c} = \\mathbf{I}_{N_c} + \\mu_M \\, g_c g_c^\\top\n$$\n其中 $\\mu_M \\ge 0$。电荷模式 $g_c$ 是 $\\mathbf{A}_{M,c}$ 的一个特征向量，特征值为 $1 + \\mu_M  1$，这表明MFIE算子对于此模式是良态的。\n\n整个结构（总大小为 $N = \\sum_c N_c$）的全局算子 $\\mathbf{A}_E$ 和 $\\mathbf{A}_M$ 被组装为块对角矩阵，其块 $\\mathbf{A}_{E,c}$ 和 $\\mathbf{A}_{M,c}$ 对应于每个分量。一个小的、对称的、随机的、块对角线元素为零的噪声矩阵 $\\varepsilon \\mathbf{N}$ 被添加进来，以模拟分量之间微弱的数值交叉耦合。\n\n**2. 右端激励向量**\n\n代表入射场的右端向量 $\\mathbf{b}$ 被构造成专门激励有问题的电荷模式：\n$$\n\\mathbf{b} = \\sum_{c} \\beta \\, \\hat{\\mathbf{g}}_c + \\sigma \\, \\mathbf{n}\n$$\n这里，$\\hat{\\mathbf{g}}_c$ 是将向量 $g_c$ 补零扩展到全局维度 $N$ 的向量，$\\beta$ 是一个系数，$\\mathbf{n}$ 是一个全局随机噪声向量，$\\sigma$ 是其缩放比例。这种构造确保激励在 $\\mathbf{A}_E$ 的近零空间上有显著的投影，从而加剧了无约束EFIE解中的电荷累积问题。\n\n**3. 无约束和有约束的求解器**\n\n我们使用四种不同的方法求解未知系数向量 $\\mathbf{x}$。\n\n- **EFIE 解, $\\mathbf{x}_E$**：我们求解线性系统 $\\mathbf{A}_E \\mathbf{x}_E = \\mathbf{b}$。\n- **MFIE 解, $\\mathbf{x}_M$**：我们求解线性系统 $\\mathbf{A}_M \\mathbf{x}_M = \\mathbf{b}$。\n- **无约束 CFIE 解, $\\mathbf{x}_C^{\\text{unc}}$**：CFIE算子是EFIE和MFIE算子的凸组合，$\\mathbf{A}_C = \\alpha \\mathbf{A}_E + (1-\\alpha) \\mathbf{A}_M$，其中 $\\alpha \\in (0,1)$ 是一个混合参数。通过求解 $\\mathbf{A}_C \\mathbf{x}_C^{\\text{unc}} = \\mathbf{b}$ 获得解。\n\n- **有约束 CFIE 解, $\\mathbf{x}_C^{\\text{con}}$**：为在每个分量上强制净电荷为零，我们施加一组线性约束 $g_c^\\top \\mathbf{x} = 0$（对每个分量 $c$）。这可以写成矩阵形式 $\\mathbf{G}\\mathbf{x} = \\mathbf{0}$，其中约束矩阵 $\\mathbf{G}$ 的行是全局电荷模式向量 $\\hat{g}_c^\\top$。在约束 $\\mathbf{G}\\mathbf{x} = \\mathbf{0}$ 下求解 $\\mathbf{A}_C \\mathbf{x} = \\mathbf{b}$ 是一个约束优化问题。其标准且稳健的求解方法是使用拉格朗日乘子，这导出了Karush-Kuhn-Tucker (KKT) 鞍点系统：\n$$\n\\begin{bmatrix}\n\\mathbf{A}_C  \\mathbf{G}^\\top \\\\\n\\mathbf{G}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\n如果 $\\mathbf{A}_C$ 是正定的且 $\\mathbf{G}$ 行满秩，则KKT矩阵是可逆的。我们的构造确保了这些性质。求解这个更大的增广系统可以得到约束解 $\\mathbf{x}_C^{\\text{con}}$ 和拉格朗日乘子 $\\boldsymbol{\\lambda}$。\n\n**4. 电荷代理计算**\n\n每种方法的性能通过计算每个分量 $c$ 的净电荷代理来量化：\n$$\nQ_c = \\frac{\\left|g_c^\\top \\mathbf{x}\\right|}{\\omega}\n$$\n为四种解（$\\mathbf{x}_E$、$\\mathbf{x}_M$、$\\mathbf{x}_C^{\\text{unc}}$ 和 $\\mathbf{x}_C^{\\text{con}}$）中的每一种计算此值。根据构造，$g_c^\\top \\mathbf{x}_C^{\\text{con}}$ 应为零（或在浮点容差范围内），这表明在离散层面完美地执行了电荷守恒原理。其他方法将表现出非零电荷，其中EFIE预计会显示最大的误差，反映其固有的病态性。\n\n实现过程按算法为每个测试用例执行这些步骤，使用指定的随机种子以保证可复现性。所有矩阵和向量均使用 NumPy 构建，线性系统使用 `numpy.linalg.solve` 求解。最终结果按要求格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves a single test case for the PEC scatterer problem.\n\n        This function constructs the abstract EFIE, MFIE, and CFIE operators,\n        solves the unconstrained systems, formulates and solves the topologically\n        constrained CFIE system, and computes the charge proxy for each solution.\n        \"\"\"\n        # Unpack parameters\n        component_sizes = case_params[\"component_sizes\"]\n        omega = case_params[\"omega\"]\n        alpha = case_params[\"alpha\"]\n        mu_E = case_params[\"mu_E\"]\n        mu_M = case_params[\"mu_M\"]\n        epsilon = case_params[\"epsilon\"]\n        seed = case_params[\"seed\"]\n        \n        num_components = len(component_sizes)\n        N_total = sum(component_sizes)\n        \n        # Initialize RNG for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Constants for RHS\n        beta = 0.3\n        sigma = 0.1\n        \n        # --- Stage 1: Construct g vectors and global block structure ---\n        g_vectors = []\n        component_indices = []\n        current_pos = 0\n        for size in component_sizes:\n            g_tilde = rng.standard_normal(size)\n            g = g_tilde / np.linalg.norm(g_tilde)\n            g_vectors.append(g)\n            component_indices.append((current_pos, current_pos + size))\n            current_pos += size\n\n        # --- Stage 2: Construct operator matrices A_E, A_M, and b ---\n        A_E = np.zeros((N_total, N_total))\n        A_M = np.zeros((N_total, N_total))\n        \n        for i, size in enumerate(component_sizes):\n            start, end = component_indices[i]\n            g_c = g_vectors[i]\n            ggT = np.outer(g_c, g_c)\n            \n            A_E[start:end, start:end] = np.eye(size) - mu_E * ggT\n            A_M[start:end, start:end] = np.eye(size) + mu_M * ggT\n            \n        if num_components > 1:\n            noise_matrix = rng.standard_normal((N_total, N_total))\n            noise_matrix = (noise_matrix + noise_matrix.T) / 2.0\n            for start, end in component_indices:\n                noise_matrix[start:end, start:end] = 0.0\n            A_E += epsilon * noise_matrix\n            A_M += epsilon * noise_matrix\n            \n        b = np.zeros(N_total)\n        for i, (start, end) in enumerate(component_indices):\n            g_global = np.zeros(N_total)\n            g_global[start:end] = g_vectors[i]\n            b += beta * g_global\n        n_global = rng.standard_normal(N_total)\n        b += sigma * n_global\n        \n        # --- Stage 3: Solve the four linear systems ---\n        \n        # 1. EFIE\n        x_E = np.linalg.solve(A_E, b)\n        \n        # 2. MFIE\n        x_M = np.linalg.solve(A_M, b)\n        \n        # 3. Unconstrained CFIE\n        A_C = alpha * A_E + (1 - alpha) * A_M\n        x_C_unc = np.linalg.solve(A_C, b)\n        \n        # 4. Constrained CFIE\n        if num_components > 0:\n            G = np.zeros((num_components, N_total))\n            for i, (start, end) in enumerate(component_indices):\n                G[i, start:end] = g_vectors[i]\n            \n            K = np.zeros((N_total + num_components, N_total + num_components))\n            K[:N_total, :N_total] = A_C\n            K[:N_total, N_total:] = G.T\n            K[N_total:, :N_total] = G\n            \n            b_aug = np.zeros(N_total + num_components)\n            b_aug[:N_total] = b\n            \n            z = np.linalg.solve(K, b_aug)\n            x_C_con = z[:N_total]\n        else: # Should not happen with given tests, but for robustness\n            x_C_con = x_C_unc\n\n        # --- Stage 4: Calculate and store charge proxies ---\n        solutions = [x_E, x_M, x_C_unc, x_C_con]\n        case_results = []\n        \n        for x in solutions:\n            charges = []\n            for i, (start, end) in enumerate(component_indices):\n                g_c = g_vectors[i]\n                x_c = x[start:end]\n                charge_val = np.abs(np.dot(g_c, x_c)) / omega\n                charges.append(charge_val)\n            case_results.append(charges)\n            \n        return case_results\n\n    def format_results(all_results):\n        \"\"\"Formats the nested list of results into the specified compact string.\"\"\"\n        case_strs = []\n        for case_result in all_results:\n            method_strs = []\n            for method_result in case_result:\n                charge_strs = [format(q, '.6f') for q in method_result]\n                method_strs.append('[' + ','.join(charge_strs) + ']')\n            case_strs.append('[' + ','.join(method_strs) + ']')\n        return '[' + ','.join(case_strs) + ']'\n    \n    test_cases = [\n        # Test Case 1\n        {\n            \"component_sizes\": [6, 4],\n            \"omega\": 2 * np.pi * 1e6,\n            \"alpha\": 0.7,\n            \"mu_E\": 0.9,\n            \"mu_M\": 0.2,\n            \"epsilon\": 0.05,\n            \"seed\": 42\n        },\n        # Test Case 2\n        {\n            \"component_sizes\": [5],\n            \"omega\": 2 * np.pi * 1e6,\n            \"alpha\": 0.5,\n            \"mu_E\": 0.0,\n            \"mu_M\": 0.3,\n            \"epsilon\": 0.01,\n            \"seed\": 7\n        },\n        # Test Case 3\n        {\n            \"component_sizes\": [3, 4, 5],\n            \"omega\": 2 * np.pi * 1e5,\n            \"alpha\": 0.6,\n            \"mu_E\": 0.95,\n            \"mu_M\": 0.1,\n            \"epsilon\": 0.03,\n            \"seed\": 123\n        }\n    ]\n    \n    all_results = [solve_case(params) for params in test_cases]\n    \n    print(format_results(all_results))\n\nsolve()\n```"
        }
    ]
}