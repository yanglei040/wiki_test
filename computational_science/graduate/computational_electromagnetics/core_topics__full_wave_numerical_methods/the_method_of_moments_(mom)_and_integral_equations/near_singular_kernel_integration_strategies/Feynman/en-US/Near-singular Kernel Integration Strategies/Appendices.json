{
    "hands_on_practices": [
        {
            "introduction": "Many two-dimensional problems in electromagnetics and fluid dynamics, as well as three-dimensional problems with axial symmetry, involve boundary integrals over closed, smooth curves. For targets on or near the boundary, the Green's function for the Laplace equation introduces a logarithmic singularity. This exercise, , provides an opportunity to implement and test the Kress quadrature, a highly effective numerical scheme tailored for periodic logarithmic kernels. By comparing your numerical results against a derived analytic solution, you will gain firsthand experience with the spectral accuracy that specialized quadratures can achieve for this important class of singular integrals.",
            "id": "3333363",
            "problem": "Given the two-dimensional Laplace equation, the single-layer potential associated with a closed smooth curve and a scalar density is defined by the convolution of the density with the free-space Green’s function of the Laplace operator. In two dimensions, the free-space Green’s function is the fundamental solution of the Laplace equation and is given by the logarithmic kernel. Consider the unit circle parametrized by $x(\\theta) = (\\cos\\theta, \\sin\\theta)$ for $\\theta \\in [0, 2\\pi)$ and the single-layer potential\n$$\nS\\sigma(r_0) = \\int_{0}^{2\\pi} G(r_0, x(\\theta)) \\, \\sigma(\\theta) \\, d\\theta,\n$$\nwhere $G(r_0, x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|r_0 - x(\\theta)\\right|$ and the density is $\\sigma(\\theta) = \\cos(m\\theta)$ with integer $m \\ge 1$. The target point is specified in polar coordinates by a radius $\\rho$ and polar angle $\\theta_0$, i.e., $r_0 = (\\rho\\cos\\theta_0, \\rho\\sin\\theta_0)$. Define the offset from the unit circle as $d$, and let the side flag indicate whether the target is outside the circle ($\\rho = 1 + d$ with $d \\ge 0$), inside the circle ($\\rho = 1 - d$ with $0 \\le d < 1$), or on the boundary ($\\rho = 1$ corresponding to $d = 0$).\n\nStarting only from the following fundamental base:\n- The definition of the two-dimensional Laplace single-layer potential with the free-space Green’s function $G(r, r') = -\\frac{1}{2\\pi}\\log|r - r'|$.\n- The parametrization of the unit circle $x(\\theta) = (\\cos\\theta, \\sin\\theta)$ and the fact that $|x'(\\theta)| = 1$ so that the line element is $d s = d\\theta$.\n- The standard orthogonality relations of trigonometric functions over one period and basic Fourier series facts.\n\nTask:\n1) Derive the analytic value of $S\\sigma(r_0)$ for $\\sigma(\\theta) = \\cos(m\\theta)$ at an off-surface target $r_0$ lying on the ray of angle $\\theta_0$ at radius $\\rho \\neq 1$. Express your result explicitly in terms of $\\rho$, $m$, and $\\theta_0$. Angles must be in radians. Your final expression must be valid for both $\\rho > 1$ and $\\rho < 1$.\n2) Specialize your derivation to the on-surface limit $\\rho \\to 1$ (i.e., $d \\to 0$) to obtain the boundary value of the single-layer potential at $x(\\theta_0)$.\n3) Design and implement a numerical quadrature to approximate $S\\sigma(r_0)$ on $[0,2\\pi)$ using equispaced nodes $\\theta_j = \\frac{2\\pi j}{N}$ for even $N$. For off-surface targets ($\\rho \\ne 1$), the integrand is smooth; apply the periodic trapezoidal rule to approximate the integral. For on-surface targets ($\\rho = 1$), the kernel has a logarithmic singularity of the form $\\log\\left(4\\sin^2\\frac{\\theta-\\theta_0}{2}\\right)$; apply the Kress quadrature (i.e., use specialized periodic weights that exactly integrate the logarithmic kernel against trigonometric polynomials up to the Nyquist frequency on the chosen grid). In the on-surface case, restrict to the case where $\\theta_0$ is exactly one of the quadrature nodes.\n4) Compare the numerical approximation with the analytic result for the following test suite. For each case, compute the absolute error as a floating-point number.\n\nUse the following test suite with parameters as tuples $(m,\\theta_0,d,\\text{side},N)$:\n- Case A (outside, smooth): $(3, 1.1, 0.3, \\text{\"outside\"}, 256)$.\n- Case B (inside, smooth): $(4, 2.2, 0.25, \\text{\"inside\"}, 256)$.\n- Case C (outside, near-singular): $(7, 1.7, 10^{-6}, \\text{\"outside\"}, 4096)$.\n- Case D (on-surface, singular, Kress required; ensure $\\theta_0$ is a node): $(5, 0.0, 0.0, \\text{\"boundary\"}, 256)$.\n\nDefinitions and conventions:\n- For side \"outside\", use $\\rho = 1 + d$ with $d \\ge 0$.\n- For side \"inside\", use $\\rho = 1 - d$ with $0 \\le d < 1$.\n- For side \"boundary\", use $\\rho = 1$ (thus $d = 0$), and ensure $\\theta_0 = \\frac{2\\pi j}{N}$ for some integer $j$ so that it is exactly a grid node.\n- All angles are in radians.\n\nYour program must:\n- Implement the analytic formula derived in step 1–2.\n- Implement the periodic trapezoidal rule for off-surface evaluation and the Kress quadrature for the on-surface evaluation at a grid node. The Kress quadrature must use weights derived from the Fourier series representation of the logarithmic kernel and must be valid for even $N$.\n- Produce a single line of output containing the absolute errors for Cases A–D as a comma-separated Python list, e.g., \"[eA,eB,eC,eD]\". No other text should be printed.\n\nAll outputs are dimensionless and should be printed as standard floating-point numbers in Python’s default formatting. The answer must be entirely self-contained and runnable without any user input. The final output format is a single line with a Python list literal as specified above.",
            "solution": "The problem requires the derivation of an analytic formula for the two-dimensional Laplace single-layer potential on a unit circle, its specialization to the boundary, and the implementation of numerical quadratures for comparison.\n\nThe single-layer potential $S\\sigma(r_0)$ is given by\n$$S\\sigma(r_0) = \\int_{0}^{2\\pi} G(r_0, x(\\theta)) \\, \\sigma(\\theta) \\, d\\theta$$\nwhere the domain is the unit circle parametrized by $x(\\theta) = (\\cos\\theta, \\sin\\theta)$, the density is $\\sigma(\\theta) = \\cos(m\\theta)$ for an integer $m \\ge 1$, and the Green's function is $G(r_0, x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|r_0 - x(\\theta)\\right|$. The target point is $r_0 = (\\rho\\cos\\theta_0, \\rho\\sin\\theta_0)$. The line element is $ds = |x'(\\theta)|d\\theta = d\\theta$.\n\n**1. Analytic Derivation (Off-Surface, $\\rho \\neq 1$)**\n\nFirst, we determine the distance $|r_0 - x(\\theta)|$.\n\\begin{align*} |r_0 - x(\\theta)|^2 &= \\|(\\rho\\cos\\theta_0 - \\cos\\theta, \\rho\\sin\\theta_0 - \\sin\\theta)\\|^2 \\\\ &= (\\rho\\cos\\theta_0 - \\cos\\theta)^2 + (\\rho\\sin\\theta_0 - \\sin\\theta)^2 \\\\ &= \\rho^2\\cos^2\\theta_0 - 2\\rho\\cos\\theta_0\\cos\\theta + \\cos^2\\theta + \\rho^2\\sin^2\\theta_0 - 2\\rho\\sin\\theta_0\\sin\\theta + \\sin^2\\theta \\\\ &= \\rho^2(\\cos^2\\theta_0 + \\sin^2\\theta_0) + (\\cos^2\\theta + \\sin^2\\theta) - 2\\rho(\\cos\\theta_0\\cos\\theta + \\sin\\theta_0\\sin\\theta) \\\\ &= \\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)\\end{align*}\nThe single-layer potential integral becomes:\n$$ S\\sigma(r_0) = -\\frac{1}{2\\pi} \\int_0^{2\\pi} \\log\\left(\\sqrt{\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)}\\right) \\cos(m\\theta) \\, d\\theta $$\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\log\\left(\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)\\right) \\cos(m\\theta) \\, d\\theta $$\nTo evaluate this integral, we use the Fourier series expansion of the logarithmic term. The relevant identity is:\n$$ \\log(1 - 2z\\cos\\phi + z^2) = -2 \\sum_{k=1}^{\\infty} \\frac{z^k}{k} \\cos(k\\phi), \\quad |z|<1 $$\nWe must consider two cases for the target point radius $\\rho$.\n\nCase 1: $\\rho < 1$ (inside the circle).\nLet $z = \\rho$ and $\\phi = \\theta - \\theta_0$. Since $\\rho < 1$, the expansion is valid.\n$$ \\log(1 - 2\\rho\\cos(\\theta-\\theta_0) + \\rho^2) = -2 \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\cos(k(\\theta-\\theta_0)) $$\nSubstituting this into the integral for $S\\sigma(r_0)$:\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\left( -2 \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\cos(k(\\theta-\\theta_0)) \\right) \\cos(m\\theta) \\, d\\theta $$\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\sum_{k=1}^{\\infty} \\frac{\\rho^k}{k} \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta $$\nThe integral is evaluated using trigonometric identities and orthogonality:\n$$ \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta = \\int_0^{2\\pi} (\\cos(k\\theta)\\cos(k\\theta_0) + \\sin(k\\theta)\\sin(k\\theta_0)) \\cos(m\\theta) \\, d\\theta $$\nSince $m \\ge 1$ and $k \\ge 1$, orthogonality relations give $\\int_0^{2\\pi} \\sin(k\\theta)\\cos(m\\theta)d\\theta = 0$ and $\\int_0^{2\\pi} \\cos(k\\theta)\\cos(m\\theta)d\\theta = \\pi \\delta_{km}$.\nThe integral is non-zero only when $k=m$, yielding $\\pi \\cos(m\\theta_0)$. The series collapses to a single term:\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\frac{\\rho^m}{m} (\\pi \\cos(m\\theta_0)) = \\frac{\\rho^m}{2m} \\cos(m\\theta_0) $$\n\nCase 2: $\\rho > 1$ (outside the circle).\nWe factor out $\\rho^2$ from the logarithm's argument:\n$$ \\log(\\rho^2 + 1 - 2\\rho\\cos(\\theta - \\theta_0)) = \\log\\left(\\rho^2\\left(1 - \\frac{2}{\\rho}\\cos(\\theta - \\theta_0) + \\frac{1}{\\rho^2}\\right)\\right) = 2\\log\\rho + \\log\\left(1 - 2\\frac{1}{\\rho}\\cos(\\theta - \\theta_0) + \\left(\\frac{1}{\\rho}\\right)^2\\right) $$\nLet $z = 1/\\rho$. Since $\\rho > 1$, we have $|z| < 1$, and the expansion is valid:\n$$ \\log(\\dots) = 2\\log\\rho - 2 \\sum_{k=1}^{\\infty} \\frac{(1/\\rho)^k}{k} \\cos(k(\\theta-\\theta_0)) $$\nSubstituting this into the integral for $S\\sigma(r_0)$:\n$$ S\\sigma(r_0) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\left( 2\\log\\rho - 2 \\sum_{k=1}^{\\infty} \\frac{\\rho^{-k}}{k} \\cos(k(\\theta-\\theta_0)) \\right) \\cos(m\\theta) \\, d\\theta $$\nThe integral of the first term vanishes: $-\\frac{2\\log\\rho}{4\\pi}\\int_0^{2\\pi}\\cos(m\\theta)d\\theta = 0$ as $m \\ge 1$.\nThe second part is identical to Case 1, with $\\rho$ replaced by $\\rho^{-1}$:\n$$ S\\sigma(r_0) = \\frac{1}{2\\pi} \\sum_{k=1}^{\\infty} \\frac{\\rho^{-k}}{k} \\int_0^{2\\pi} \\cos(k(\\theta-\\theta_0)) \\cos(m\\theta) \\, d\\theta = \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0) $$\n\nCombining both cases, the analytic solution for $\\rho \\neq 1$ is:\n$$ S\\sigma(r_0) = \\begin{cases} \\displaystyle \\frac{\\rho^m}{2m} \\cos(m\\theta_0), & \\rho < 1 \\\\ \\displaystyle \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0), & \\rho > 1 \\end{cases} $$\n\n**2. Analytic Derivation (On-Surface, $\\rho \\to 1$)**\n\nTo find the value of the potential on the boundary, we take the limit as $\\rho \\to 1$ from both inside and outside:\n$$ \\lim_{\\rho \\to 1^-} S\\sigma(r_0) = \\lim_{\\rho \\to 1^-} \\frac{\\rho^m}{2m} \\cos(m\\theta_0) = \\frac{1}{2m} \\cos(m\\theta_0) $$\n$$ \\lim_{\\rho \\to 1^+} S\\sigma(r_0) = \\lim_{\\rho \\to 1^+} \\frac{\\rho^{-m}}{2m} \\cos(m\\theta_0) = \\frac{1}{2m} \\cos(m\\theta_0) $$\nThe limit exists and is unique, so for a point $x(\\theta_0)$ on the boundary ($\\rho=1$):\n$$ S\\sigma(x(\\theta_0)) = \\frac{1}{2m} \\cos(m\\theta_0) $$\n\n**3. Numerical Quadrature Design**\n\nThe integral is approximated on a grid of $N$ equispaced nodes $\\theta_j = 2\\pi j/N$ for $j=0, 1, \\dots, N-1$.\n\nOff-Surface ($\\rho \\neq 1$):\nThe integrand is a smooth, $2\\pi$-periodic function of $\\theta$. For such functions, the periodic trapezoidal rule exhibits spectral accuracy. The rule approximates the integral as:\n$$ S_N(r_0) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} G(r_0, x(\\theta_j)) \\sigma(\\theta_j) $$\nSubstituting the expressions for $G$ and $\\sigma$:\n$$ S_N(r_0) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left(-\\frac{1}{4\\pi}\\log(\\rho^2+1-2\\rho\\cos(\\theta_j-\\theta_0))\\right) \\cos(m\\theta_j) $$\n$$ S_N(r_0) = -\\frac{1}{2N} \\sum_{j=0}^{N-1} \\log(\\rho^2+1-2\\rho\\cos(\\theta_j-\\theta_0)) \\cos(m\\theta_j) $$\n\nOn-Surface ($\\rho = 1$):\nWhen $\\rho=1$, the target point $r_0 = x(\\theta_0)$ is on the integration path. The kernel $G(x(\\theta_0), x(\\theta))$ becomes singular as $\\theta \\to \\theta_0$.\n$$ |x(\\theta_0) - x(\\theta)|^2 = 1+1-2\\cos(\\theta-\\theta_0) = 2(1-\\cos(\\theta-\\theta_0)) = 4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right) $$\nThe kernel has a logarithmic singularity:\n$$ G(x(\\theta_0), x(\\theta)) = -\\frac{1}{2\\pi}\\log\\left|2\\sin\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right| = -\\frac{1}{4\\pi}\\log\\left(4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right) $$\nThe standard trapezoidal rule fails. Kress quadrature is designed for such singular integrals. For an integral of the form $I = \\int_0^{2\\pi} \\log(4\\sin^2(t/2)) f(t) dt$, the Kress quadrature approximation is $Q_N[f] = \\sum_{j=0}^{N-1} T_j f(t_j)$, where $t_j = 2\\pi j/N$. The weights $T_j$ for an even number of points $N$ are given by:\n$$ T_j = -\\frac{4\\pi}{N} \\sum_{k=1}^{N/2-1} \\frac{1}{k} \\cos\\left(\\frac{2\\pi j k}{N}\\right) - \\frac{2\\pi}{N^2}(-1)^j $$\nOur integral is $S\\sigma(x(\\theta_0)) = -\\frac{1}{4\\pi} \\int_0^{2\\pi} \\log\\left(4\\sin^2\\left(\\frac{\\theta-\\theta_0}{2}\\right)\\right) \\cos(m\\theta) d\\theta$.\nThe problem states that the target point $\\theta_0$ is a grid node, $\\theta_0 = \\theta_l = 2\\pi l/N$ for some integer $l$. By shifting the integration variable, the integral can be approximated by a circular convolution:\n$$ S_N(x(\\theta_l)) = -\\frac{1}{4\\pi} \\sum_{j=0}^{N-1} T_{j-l} \\cos(m\\theta_j) $$\nwhere the indices on $T$ are taken modulo $N$.",
            "answer": "```python\nimport numpy as np\nfrom math import pi\n\ndef solve():\n    \"\"\"\n    Solves the Laplace single-layer potential problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # (m, theta_0, d, side, N)\n        (3, 1.1, 0.3, \"outside\", 256),   # Case A\n        (4, 2.2, 0.25, \"inside\", 256),    # Case B\n        (7, 1.7, 1e-6, \"outside\", 4096),  # Case C\n        (5, 0.0, 0.0, \"boundary\", 256)   # Case D\n    ]\n\n    def analytic_solution(m: int, rho: float, theta0: float) -> float:\n        \"\"\"\n        Computes the analytic solution for the single-layer potential.\n        \"\"\"\n        if abs(rho - 1.0) < 1e-15:  # On-surface case\n            val = 1.0 / (2.0 * m) * np.cos(m * theta0)\n        elif rho < 1.0:  # Inside\n            val = (rho**m) / (2.0 * m) * np.cos(m * theta0)\n        else:  # Outside\n            val = (rho**-m) / (2.0 * m) * np.cos(m * theta0)\n        return val\n\n    def compute_kress_weights(N: int) -> np.ndarray:\n        \"\"\"\n        Computes the Kress quadrature weights for the logarithmic kernel.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"N must be even for this Kress weight formula.\")\n        \n        j_vals = np.arange(N)\n        k_vals = np.arange(1, N // 2)\n        \n        # Vectorized computation of the sum term\n        sum_term = np.sum( (1.0 / k_vals[:, np.newaxis]) * \n                           np.cos(2 * pi * k_vals[:, np.newaxis] * j_vals[np.newaxis, :] / N), axis=0)\n                           \n        T = -(4.0 * pi / N) * sum_term - (2.0 * pi / N**2) * ((-1)**j_vals)\n        return T\n\n    def numerical_solution(m, theta0, d, side, N):\n        \"\"\"\n        Computes the numerical solution using appropriate quadrature.\n        \"\"\"\n        theta = 2.0 * pi * np.arange(N) / N\n        sigma_vals = np.cos(m * theta)\n        \n        if side == \"boundary\":\n            # On-surface, Kress quadrature\n            if not np.isclose(d, 0.0):\n                 raise ValueError(\"For boundary case, d must be 0.\")\n\n            # Find the index l of the node corresponding to theta0\n            l = int(round(theta0 * N / (2.0 * pi)))\n            if not np.isclose(theta0, l * 2.0 * pi / N):\n                raise ValueError(\"For boundary case, theta0 must be a grid node.\")\n\n            kress_weights = compute_kress_weights(N)\n            # The sum is a circular convolution Sum_j T_{j-l}*sigma_j\n            # which is implemented by rolling the weights array.\n            kress_weights_shifted = np.roll(kress_weights, l)\n            \n            integral_approx = np.dot(kress_weights_shifted, sigma_vals)\n            \n            # The potential is (-1/4pi) * integral_approx\n            num_val = -1.0 / (4.0 * pi) * integral_approx\n            \n        else:\n            # Off-surface, periodic trapezoidal rule\n            if side == \"outside\":\n                rho = 1.0 + d\n            elif side == \"inside\":\n                rho = 1.0 - d\n            else:\n                raise ValueError(\"Invalid side specified.\")\n\n            log_arg = rho**2 + 1.0 - 2.0 * rho * np.cos(theta - theta0)\n            integrand = np.log(log_arg) * sigma_vals\n            \n            # The potential is (-1/2N) * Sum(integrand)\n            num_val = -1.0 / (2.0 * N) * np.sum(integrand)\n\n        return num_val\n\n    results = []\n    for m, theta0, d, side, N in test_cases:\n        if side == \"outside\":\n            rho = 1.0 + d\n        elif side == \"inside\":\n            rho = 1.0 - d\n        else: # boundary\n            rho = 1.0\n\n        ana_val = analytic_solution(m, rho, theta0)\n        num_val = numerical_solution(m, theta0, d, side, N)\n        \n        error = abs(ana_val - num_val)\n        results.append(error)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While specialized rules like Kress quadrature are powerful, many practical scenarios in 3D require a more flexible approach. After projecting a 3D kernel onto the local coordinates of a surface patch, the resulting radial integral often exhibits an algebraic endpoint singularity of the form $\\rho^{\\alpha}$, which may not be logarithmic. This exercise, , guides you through the construction of a robust composite quadrature to handle such cases. You will combine the power of graded meshes, which concentrate computational effort near the singularity, with the precision of Gauss-Jacobi quadrature, which is designed to exactly handle the algebraic weight function, demonstrating a powerful and adaptable integration strategy.",
            "id": "3333281",
            "problem": "Consider the evaluation of surface-patch contributions in boundary integral formulations of electromagnetics using local polar coordinates. After projecting a three-dimensional kernel onto local coordinates, a common situation is that the surface integral over the patch reduces to a radial integral over the mapped interval with an endpoint singularity at the origin. Specifically, let the local coordinates be $(u,v)$ with $\\rho=\\sqrt{u^2+v^2}$ and $\\theta=\\operatorname{atan2}(v,u)$, so that the area element is $\\rho\\,d\\rho\\,d\\theta$. For near-singular targets at small separation distance from the patch, the resulting radial integrals often exhibit algebraic endpoint singularities of the form $\\rho^\\alpha$ with $\\alpha\\in(-1,0]$, possibly multiplied by smooth factors and by additional endpoint factors $(1-\\rho)^\\beta$ with $\\beta>-1$ if the patch boundary maps to $\\rho=1$. Your task is to derive and implement a composite Gauss–Jacobi quadrature on a graded mesh that resolves the endpoint singularity at $\\rho=0$ (and optionally at $\\rho=1$) by factoring out the expected algebraic behavior and using a linear map on each subinterval to apply a Gauss–Jacobi rule with parameters chosen to match the local endpoint singularity.\n\nStarting from the fundamental base comprising: (i) the free-space scalar kernel’s dependence on the separation distance, (ii) the polar change of variables with Jacobian $\\rho$, (iii) the definition of Gauss–Jacobi quadrature that exactly integrates polynomials under the weight $(1-x)^\\beta(1+x)^\\alpha$ for $\\alpha>-1$ and $\\beta>-1$, and (iv) standard properties of algebraic endpoint singularities, do the following.\n\n- Derive a composite quadrature for integrals on $[0,1]$ of the form\n  $$\n  I=\\int_0^1 f(\\rho)\\,d\\rho,\n  $$\n  where $f(\\rho)$ exhibits an algebraic endpoint singularity that can be factored as $f(\\rho)=\\rho^{\\alpha_\\star}h(\\rho)$ with $\\alpha_\\star\\in(-1,0]$ and $h(\\rho)$ sufficiently smooth on $[0,1]$, and may optionally include a right-endpoint factor $(1-\\rho)^{\\beta_\\star}$ with $\\beta_\\star>-1$. Use a graded partition $\\{0=\\rho_0<\\rho_1<\\dots<\\rho_M=1\\}$ defined by\n  $$\n  \\rho_j=\\left(\\frac{j}{M}\\right)^q,\\quad j\\in\\{0,1,\\dots,M\\},\n  $$\n  with integer $M\\ge 2$ and grading exponent $q\\ge 1$ to concentrate subintervals near $\\rho=0$.\n- On each subinterval $[\\rho_{j-1},\\rho_j]$, use the linear map $x\\in[-1,1]\\mapsto \\rho(x)=\\rho_{j-1}+\\frac{(x+1)}{2}(\\rho_j-\\rho_{j-1})$ with Jacobian $\\frac{d\\rho}{dx}=\\frac{\\rho_j-\\rho_{j-1}}{2}$. Let $\\alpha_{\\mathrm{eff}}=\\alpha_\\star$ on the first subinterval and $\\alpha_{\\mathrm{eff}}=0$ otherwise; let $\\beta_{\\mathrm{eff}}=\\beta_\\star$ on the last subinterval and $\\beta_{\\mathrm{eff}}=0$ otherwise. Show how to evaluate\n  $$\n  \\int_{\\rho_{j-1}}^{\\rho_j} f(\\rho)\\,d\\rho=\\int_{-1}^{1}(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}\\,g_j(x)\\,dx\n  $$\n  where $g_j(x)$ is smooth, and then approximate the integral on each subinterval using an $n$-point Gauss–Jacobi rule with parameters $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})$. Provide the explicit expression for $g_j(x)$ in terms of $f$, $\\rho(x)$, and $\\frac{d\\rho}{dx}$.\n- Provide a complete algorithm that aggregates the subinterval contributions and yields a high-accuracy approximation to $I$ for functions $f$ with the stated behavior. The algorithm must only use the chosen $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})$ pairs on the first and last subintervals respectively, with $(0,0)$ used on interior subintervals.\n\nTest suite. Implement your composite Gauss–Jacobi quadrature and apply it to the following three integrals on $[0,1]$, which model distinct near-singular behaviors arising after projection of three-dimensional kernels onto local coordinates:\n- Test $1$ (left-endpoint algebraic singularity only): $I_1=\\int_0^1 \\rho^{-1/2}\\,d\\rho$.\n- Test $2$ (both endpoints algebraic factors): $I_2=\\int_0^1 \\rho^{-1/2}(1-\\rho)^{1/2}\\,(\\rho+0.1)\\,d\\rho$.\n- Test $3$ (near-singular factor displaced by a small parameter $\\delta$): $I_3(\\delta)=\\int_0^1 \\rho^{-1/2}\\,(\\rho+\\delta)^{-1/2}\\,d\\rho$ with $\\delta=10^{-6}$.\n\nFor each test, compute the relative error defined by\n$$\n\\varepsilon=\\frac{|I_{\\mathrm{num}}-I_{\\mathrm{ref}}|}{|I_{\\mathrm{ref}}|},\n$$\nwhere $I_{\\mathrm{num}}$ is your composite Gauss–Jacobi approximation and $I_{\\mathrm{ref}}$ is the exact value obtained by analytic evaluation from first principles. Use the following parameters for all three tests: number of subintervals $M=64$, grading exponent $q=4$, and $n=10$ Gauss–Jacobi points per subinterval. For the effective parameters, use $\\alpha_\\star=-\\tfrac{1}{2}$ for the left endpoint in all tests; for the right endpoint, use $\\beta_\\star=0$ in tests $1$ and $3$, and $\\beta_\\star=\\tfrac{1}{2}$ in test $2$.\n\nYour program should produce a single line of output containing the three relative errors as a comma-separated list of floating-point numbers enclosed in square brackets (e.g., $[e_1,e_2,e_3]$). No other output is permitted. No physical units or angles are required; report all numeric results as dimensionless floats.",
            "solution": "We start from the polar change of variables in a local parameterization $(u,v)$ of a surface patch, with $\\rho=\\sqrt{u^2+v^2}$ and $\\theta=\\operatorname{atan2}(v,u)$. The area element is $\\rho\\,d\\rho\\,d\\theta$. The three-dimensional free-space kernel for static or time-harmonic problems depends on the separation distance $R=\\sqrt{\\rho^2+h^2}$, where $h$ is the normal offset of the target from the patch. After integrating with respect to $\\theta$ and possibly regularizing smooth factors, the surface integral often reduces to a radial integral with algebraic behavior at $\\rho=0$, typically of the form $\\rho^{\\alpha_\\star}$, where $\\alpha_\\star\\in(-1,0]$ ensures integrability of the radial contribution. In some geometries, the patch boundary at $\\rho=1$ introduces an additional factor $(1-\\rho)^{\\beta_\\star}$ with $\\beta_\\star>-1$.\n\nWe aim to construct a high-order composite Gauss–Jacobi quadrature that resolves these endpoint structures. Gauss–Jacobi rules integrate exactly polynomials under the weight $(1-x)^\\beta(1+x)^\\alpha$ on $[-1,1]$ for $\\alpha>-1$, $\\beta>-1$. To adapt to a subinterval $[\\rho_{j-1},\\rho_j]\\subset[0,1]$, we use the standard linear map $x\\in[-1,1]\\mapsto \\rho(x)=\\rho_{j-1}+\\frac{(x+1)}{2}(\\rho_j-\\rho_{j-1})$, with Jacobian $\\frac{d\\rho}{dx}=\\frac{\\rho_j-\\rho_{j-1}}{2}$. On the first subinterval, the left endpoint maps to $x=-1$, and if $f(\\rho)$ behaves like $\\rho^{\\alpha_\\star}$ near $\\rho=0$, we factor this as $(1+x)^{\\alpha_\\star}$ after the linear map, because $\\rho(x)\\approx C\\,(1+x)$ for some constant $C>0$ near $x=-1$. Similarly, on the last subinterval, if there is a right-endpoint factor $(1-\\rho)^{\\beta_\\star}$, it maps to $(1-x)^{\\beta_\\star}$ near $x=+1$.\n\nTo make this precise, we write the subinterval contribution as\n$$\n\\int_{\\rho_{j-1}}^{\\rho_j} f(\\rho)\\,d\\rho=\\int_{-1}^{1} f(\\rho(x))\\,\\frac{d\\rho}{dx}\\,dx.\n$$\nLet $\\alpha_{\\mathrm{eff}}=\\alpha_\\star$ if $j=1$ and $\\alpha_{\\mathrm{eff}}=0$ otherwise; let $\\beta_{\\mathrm{eff}}=\\beta_\\star$ if $j=M$ and $\\beta_{\\mathrm{eff}}=0$ otherwise. We then factor the integrand as\n$$\nf(\\rho(x))\\,\\frac{d\\rho}{dx}=(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}\\,g_j(x),\n$$\nwhere, by construction,\n$$\ng_j(x)=\\frac{f(\\rho(x))\\,\\frac{d\\rho}{dx}}{(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}}.\n$$\nThis choice ensures that $g_j(x)$ is smooth on $[-1,1]$ even at the endpoints: any algebraic factor predicted from the mapping is captured by $(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}$, leaving a regular $g_j(x)$. Therefore, the integral on $[\\rho_{j-1},\\rho_j]$ can be accurately approximated by the $n$-point Gauss–Jacobi quadrature with parameters $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})$ as\n$$\n\\int_{\\rho_{j-1}}^{\\rho_j} f(\\rho)\\,d\\rho\\approx \\sum_{i=1}^{n} w_i\\,g_j(x_i),\n$$\nwhere $\\{x_i,w_i\\}_{i=1}^{n}$ are the Gauss–Jacobi nodes and weights for weight $(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}$ on $[-1,1]$.\n\nTo resolve the localized variation near $\\rho=0$, we use a graded mesh with nodes\n$$\n\\rho_j=\\left(\\frac{j}{M}\\right)^q,\\quad j\\in\\{0,1,\\dots,M\\},\n$$\nwhere $M\\ge 2$ is the number of subintervals and $q\\ge 1$ is the grading exponent; larger $q$ concentrates subintervals near $\\rho=0$. With this mesh and with $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})$ selected as above (only the first subinterval uses $\\alpha_{\\mathrm{eff}}=\\alpha_\\star$, only the last subinterval uses $\\beta_{\\mathrm{eff}}=\\beta_\\star$, and interior subintervals use $(0,0)$), we sum the subinterval contributions to obtain the composite Gauss–Jacobi approximation.\n\nWe now derive exact expressions for the three test integrals to quantify error.\n\n- Test $1$: $I_1=\\int_0^1 \\rho^{-1/2}\\,d\\rho$. This is a textbook integral with antiderivative $2\\,\\rho^{1/2}$ on $(0,1]$, hence\n  $$\n  I_1=2.\n  $$\n\n- Test $2$: $I_2=\\int_0^1 \\rho^{-1/2}(1-\\rho)^{1/2}\\,(\\rho+0.1)\\,d\\rho$. Split the integral as\n  $$\n  I_2=\\int_0^1 \\rho^{1/2}(1-\\rho)^{1/2}\\,d\\rho+0.1\\int_0^1 \\rho^{-1/2}(1-\\rho)^{1/2}\\,d\\rho.\n  $$\n  Using the Euler Beta function $B(a,b)=\\int_0^1 t^{a-1}(1-t)^{b-1}\\,dt=\\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)}$ for $a>0$, $b>0$, we recognize\n  $$\n  \\int_0^1 \\rho^{1/2}(1-\\rho)^{1/2}\\,d\\rho=B\\!\\left(\\tfrac{3}{2},\\tfrac{3}{2}\\right),\\quad \\int_0^1 \\rho^{-1/2}(1-\\rho)^{1/2}\\,d\\rho=B\\!\\left(\\tfrac{1}{2},\\tfrac{3}{2}\\right).\n  $$\n  Using $\\Gamma\\!\\left(\\tfrac{1}{2}\\right)=\\sqrt{\\pi}$, $\\Gamma\\!\\left(\\tfrac{3}{2}\\right)=\\tfrac{1}{2}\\sqrt{\\pi}$, and $\\Gamma(2)=1$, we obtain\n  $$\n  B\\!\\left(\\tfrac{3}{2},\\tfrac{3}{2}\\right)=\\frac{\\Gamma\\!\\left(\\tfrac{3}{2}\\right)\\Gamma\\!\\left(\\tfrac{3}{2}\\right)}{\\Gamma(3)}=\\frac{\\left(\\tfrac{1}{2}\\sqrt{\\pi}\\right)^2}{2}=\\frac{\\pi}{8},\\quad B\\!\\left(\\tfrac{1}{2},\\tfrac{3}{2}\\right)=\\frac{\\sqrt{\\pi}\\cdot\\tfrac{1}{2}\\sqrt{\\pi}}{1}=\\frac{\\pi}{2}.\n  $$\n  Therefore,\n  $$\n  I_2=\\frac{\\pi}{8}+0.1\\,\\frac{\\pi}{2}=\\pi\\left(\\frac{1}{8}+0.05\\right)=0.175\\,\\pi.\n  $$\n\n- Test $3$: $I_3(\\delta)=\\int_0^1 \\rho^{-1/2}\\,(\\rho+\\delta)^{-1/2}\\,d\\rho=\\int_0^1 \\frac{d\\rho}{\\sqrt{\\rho(\\rho+\\delta)}},\\quad \\delta>0$. Use the substitution $\\rho=\\delta\\,\\sinh^2 t$, which yields $d\\rho=2\\delta\\,\\sinh t\\,\\cosh t\\,dt$ and\n  $$\n  \\sqrt{\\rho(\\rho+\\delta)}=\\sqrt{\\delta\\,\\sinh^2 t\\cdot\\delta(1+\\sinh^2 t)}=\\delta\\,\\sinh t\\,\\cosh t.\n  $$\n  Hence $d\\rho/\\sqrt{\\rho(\\rho+\\delta)}=2\\,dt$, and the limits $t=0$ at $\\rho=0$ and $t=\\operatorname{arsinh}\\!\\left(\\sqrt{\\tfrac{1}{\\delta}}\\right)$ at $\\rho=1$. Therefore,\n  $$\n  I_3(\\delta)=2\\,\\operatorname{arsinh}\\!\\left(\\sqrt{\\tfrac{1}{\\delta}}\\right).\n  $$\n\nAlgorithmic design. We select $M=64$, $q=4$, and $n=10$ for all three tests. On the first subinterval we set $\\alpha_{\\mathrm{eff}}=\\alpha_\\star=-\\tfrac{1}{2}$; on the last subinterval we set $\\beta_{\\mathrm{eff}}=\\beta_\\star$ with $\\beta_\\star=0$ for tests $1$ and $3$, and $\\beta_\\star=\\tfrac{1}{2}$ for test $2$. On interior subintervals, we set $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})=(0,0)$. For each subinterval, we compute Gauss–Jacobi nodes and weights for the chosen $(\\alpha_{\\mathrm{eff}},\\beta_{\\mathrm{eff}})$, evaluate $g_j(x)=\\dfrac{f(\\rho(x))\\,\\dfrac{d\\rho}{dx}}{(1-x)^{\\beta_{\\mathrm{eff}}}(1+x)^{\\alpha_{\\mathrm{eff}}}}$ at the nodes, and sum $\\sum_i w_i\\,g_j(x_i)$. The global approximation is the sum over subintervals.\n\nFinally, we compute $\\varepsilon=\\dfrac{|I_{\\mathrm{num}}-I_{\\mathrm{ref}}|}{|I_{\\mathrm{ref}}|}$ for each test using the exact $I_{\\mathrm{ref}}$ derived above. The program prints the list $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]$ in the required format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi\n\ndef composite_gauss_jacobi(f, M, q, n, alpha_left, beta_right):\n    # Build graded mesh on [0,1]\n    j = np.arange(M + 1, dtype=float)\n    rho_nodes = (j / M) ** q\n    total = 0.0\n\n    for seg in range(1, M + 1):\n        a = rho_nodes[seg - 1]\n        b = rho_nodes[seg]\n        drdx = 0.5 * (b - a)\n\n        # Effective Jacobi parameters for this subinterval\n        alpha_eff = alpha_left if seg == 1 else 0.0\n        beta_eff = beta_right if seg == M else 0.0\n\n        # Get Gauss-Jacobi nodes and weights on [-1,1] with weight (1-x)^beta_eff (1+x)^alpha_eff\n        x, w = roots_jacobi(n, alpha_eff, beta_eff)\n\n        # Map nodes to rho\n        rho = a + (x + 1.0) * drdx\n\n        # Compute the smooth factor g_j(x)\n        weight_factor = (1.0 - x) ** beta_eff * (1.0 + x) ** alpha_eff\n        g = (drdx * f(rho)) / weight_factor\n\n        # Accumulate subinterval contribution\n        total += np.dot(w, g)\n\n    return float(total)\n\ndef main():\n    # Parameters\n    M = 64\n    q = 4\n    n = 10\n\n    # Test 1: I1 = ∫_0^1 rho^(-1/2) d rho = 2\n    def f1(rho):\n        return rho**(-0.5)\n\n    I1_num = composite_gauss_jacobi(f1, M=M, q=q, n=n, alpha_left=-0.5, beta_right=0.0)\n    I1_ref = 2.0\n    e1 = abs(I1_num - I1_ref) / abs(I1_ref)\n\n    # Test 2: I2 = ∫_0^1 rho^(-1/2) (1-rho)^(1/2) (rho + 0.1) d rho = pi*(1/8 + 0.05) = 0.175*pi\n    def f2(rho):\n        return rho**(-0.5) * (1.0 - rho)**0.5 * (rho + 0.1)\n\n    I2_num = composite_gauss_jacobi(f2, M=M, q=q, n=n, alpha_left=-0.5, beta_right=0.5)\n    I2_ref = np.pi * 0.175\n    e2 = abs(I2_num - I2_ref) / abs(I2_ref)\n\n    # Test 3: I3(delta) = ∫_0^1 rho^(-1/2) (rho + delta)^(-1/2) d rho = 2*asinh(sqrt(1/delta))\n    delta = 1e-6\n    def f3(rho):\n        return rho**(-0.5) * (rho + delta)**(-0.5)\n\n    I3_num = composite_gauss_jacobi(f3, M=M, q=q, n=n, alpha_left=-0.5, beta_right=0.0)\n    I3_ref = 2.0 * np.arcsinh(np.sqrt(1.0 / delta))\n    e3 = abs(I3_num - I3_ref) / abs(I3_ref)\n\n    results = [e1, e2, e3]\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    main()\n```"
        },
        {
            "introduction": "The most efficient numerical methods are often adaptive, concentrating computational effort only where it is most needed. This final practice, , shifts the focus from fixed quadrature rules to the design of an intelligent, adaptive algorithm. By performing an asymptotic analysis of the near-singular integral, you will derive an *a priori* error estimator that predicts the quadrature error based on the target distance $d$, panel size $h$, and local surface properties like curvature $\\kappa$ and density variation. This estimator provides the core logic for deciding whether a panel is \"resolved\" or requires further subdivision, linking the numerical algorithm directly to the underlying geometry and physics of the problem.",
            "id": "3333358",
            "problem": "Consider a smooth surface patch arising in boundary integral formulations of Computational Electromagnetics, over which a near-singular integral of a kernel must be evaluated. Let the target point be placed at a closest point on the surface and offset along the local unit normal by a small distance. The integral of interest is the Laplace single-layer potential, which is an accepted proxy for near-singular behavior of kernels encountered in Computational Electromagnetics, defined by the integral $$I = \\int_{\\Gamma} \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\, \\mathrm{d}S_{\\mathbf{y}},$$ where $\\Gamma$ is a small panel of a smooth surface, $\\mathbf{x}$ is a point displaced from the closest point $\\mathbf{y}_0 \\in \\Gamma$ by a distance $d$ along the unit normal $\\mathbf{n}_0$, and $\\phi$ is a smooth surface density.\n\nWork in local principal directions at $\\mathbf{y}_0$ and model the patch by a local Monge parametrization with principal curvatures $\\kappa_1$ and $\\kappa_2$, so that $$\\mathbf{y}(u,v) \\approx \\mathbf{y}_0 + u\\,\\mathbf{t}_1 + v\\,\\mathbf{t}_2 + \\frac{1}{2}\\left(\\kappa_1 u^2 + \\kappa_2 v^2\\right)\\mathbf{n}_0,$$ and the area element satisfies $$\\mathrm{d}S \\approx \\left( 1 + \\frac{1}{2}\\left(\\kappa_1^2 u^2 + \\kappa_2^2 v^2\\right) \\right) \\,\\mathrm{d}u\\,\\mathrm{d}v.$$ Assume the density admits a smooth surface Taylor expansion around $\\mathbf{y}_0$ given by $$\\phi(\\mathbf{y}(u,v)) \\approx \\phi_0 + g_1 u + g_2 v + \\frac{1}{2}\\left(h_{11} u^2 + 2 h_{12} u v + h_{22} v^2\\right),$$ where $\\phi_0 = \\phi(\\mathbf{y}_0)$, $(g_1,g_2)$ are the local surface gradient components, and $(h_{11},h_{12},h_{22})$ are components of the local surface Hessian. Consider a square panel in these coordinates with side length $h$ centered at the origin $(u,v)=(0,0)$, and approximate its contribution by a single-point (centroid) rule that evaluates the integrand at the panel center and multiplies by the panel area.\n\nStarting from these definitions and approximations and using first-principles asymptotic expansions for $\\lVert\\mathbf{x}-\\mathbf{y}\\rVert$ and $\\mathrm{d}S$, derive an error estimator $E_{\\mathrm{est}}$ for the one-point centroid quadrature of $I$ that captures the leading corrections from the kernel variation, the local curvature $(\\kappa_1,\\kappa_2)$, and the local surface Hessian trace $H_{\\mathrm{tr}} = h_{11}+h_{22}$. You may assume the panel is sufficiently small that the leading-order terms dominate. To obtain closed-form coefficients, replace the square panel by an equal-area disk of radius $a$ such that $$\\pi a^2 = h^2,$$ and express the required radial integrals in terms of $a$ and the offset distance $d$. Your estimator must be a scalar and should be designed to compare against a user-specified tolerance $\\tau$ to decide whether the panel should be refined.\n\nYour program must implement the derived estimator and produce an adaptive refinement decision for each of the following test cases. In each case, the input parameters are the offset distance $d$, the panel size $h$, the local density value $\\phi_0$, the principal curvatures $(\\kappa_1,\\kappa_2)$, the local Hessian trace $H_{\\mathrm{tr}}$, and the tolerance $\\tau$.\n\nTest suite:\n- Case $1$: $d = 0.5$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 0.0$, $\\kappa_2 = 0.0$, $H_{\\mathrm{tr}} = 0.1$, $\\tau = 10^{-3}$.\n- Case $2$: $d = 0.01$, $h = 0.2$, $\\phi_0 = 1.0$, $\\kappa_1 = 0.2$, $\\kappa_2 = 0.2$, $H_{\\mathrm{tr}} = 0.5$, $\\tau = 10^{-3}$.\n- Case $3$: $d = 2.5$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 1.0$, $\\kappa_2 = 1.0$, $H_{\\mathrm{tr}} = 0.2$, $\\tau = 10^{-3}$.\n- Case $4$: $d = 0.25$, $h = 0.5$, $\\phi_0 = 1.0$, $\\kappa_1 = 2.0$, $\\kappa_2 = -1.0$, $H_{\\mathrm{tr}} = 1.0$, $\\tau = 10^{-2}$.\n- Case $5$: $d = 0.05$, $h = 0.5$, $\\phi_0 = 0.1$, $\\kappa_1 = 0.0$, $\\kappa_2 = 0.0$, $H_{\\mathrm{tr}} = 0.0$, $\\tau = 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item is a boolean indicating whether the panel should be refined for the corresponding case, i.e., the format must be exactly $$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].$$",
            "solution": "The objective is to derive an error estimator for a one-point centroid quadrature of a near-singular boundary integral and use it to decide on panel refinement. The integral is the Laplace single-layer potential:\n$$I = \\int_{\\Gamma} \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\, \\mathrm{d}S_{\\mathbf{y}}$$\nThe one-point centroid quadrature rule approximates the integral by evaluating the integrand at the panel center $\\mathbf{y}_0$ and multiplying by the panel's planar area $h^2$. The point $\\mathbf{y}_0$ is the origin $(u,v)=(0,0)$ in the local coordinate system.\n$$I_{\\mathrm{approx}} = \\left. \\frac{\\phi(\\mathbf{y})}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\right|_{\\mathbf{y}=\\mathbf{y}_0} \\times (\\text{Area}) = \\frac{\\phi(\\mathbf{y}_0)}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}_0\\rVert} h^2$$\nGiven $\\mathbf{x} = \\mathbf{y}_0 + d\\,\\mathbf{n}_0$ and $\\phi_0 = \\phi(\\mathbf{y}_0)$, we have $\\lVert \\mathbf{x}-\\mathbf{y}_0\\rVert = d$. The approximation is:\n$$I_{\\mathrm{approx}} = \\frac{\\phi_0 h^2}{4\\pi d}$$\nThe error is $E = I - I_{\\mathrm{approx}}$. To estimate this error, we must compute a more accurate version of $I$ by incorporating the specified higher-order effects: kernel variation, surface curvature, and density variation.\n\nTo make the integration tractable, we replace the square panel of side $h$ with a circular disk of equal area, with radius $a$ such that $\\pi a^2 = h^2$. We then work in polar coordinates $(r, \\theta)$ in the local tangent plane, where $u=r\\cos\\theta$ and $v=r\\sin\\theta$.\n\nFirst, we expand the components of the integrand.\nThe position vector to a point on the surface is $\\mathbf{y}(u,v) \\approx u\\,\\mathbf{t}_1 + v\\,\\mathbf{t}_2 + \\frac{1}{2}(\\kappa_1 u^2 + \\kappa_2 v^2)\\mathbf{n}_0$. The target point is $\\mathbf{x} = d\\,\\mathbf{n}_0$. The squared distance is:\n$$\\lVert \\mathbf{x}-\\mathbf{y} \\rVert^2 = u^2 + v^2 + \\left(d - \\frac{1}{2}(\\kappa_1 u^2 + \\kappa_2 v^2)\\right)^2 \\approx r^2 + d^2 - d(\\kappa_1 u^2 + \\kappa_2 v^2)$$\nwhere $r^2 = u^2+v^2$. We use a binomial expansion for the kernel $1/\\lVert \\mathbf{x}-\\mathbf{y} \\rVert$:\n$$\\frac{1}{\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} \\approx \\frac{1}{\\sqrt{d^2+r^2}} \\left(1 - \\frac{d(\\kappa_1 u^2 + \\kappa_2 v^2)}{d^2+r^2}\\right)^{-1/2} \\approx \\frac{1}{\\sqrt{d^2+r^2}} \\left(1 + \\frac{d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)}\\right)$$\nThe surface density is expanded as:\n$$\\phi(\\mathbf{y}(u,v)) \\approx \\phi_0 + g_1 u + g_2 v + \\frac{1}{2}(h_{11} u^2 + 2 h_{12} u v + h_{22} v^2)$$\nThe area element is given as $\\mathrm{d}S \\approx (1 + \\frac{1}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2))\\,\\mathrm{d}u\\,\\mathrm{d}v$.\n\nThe integral is $I = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\phi(\\mathbf{y}) \\frac{1}{\\lVert \\mathbf{x}-\\mathbf{y}\\rVert} (1 + \\frac{1}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2))\\,\\mathrm{d}u\\,\\mathrm{d}v$.\nWe assemble the integrand, keeping terms that are even in $u$ and $v$ as odd terms will integrate to zero over the symmetric disk.\n$$I(u,v) \\approx \\frac{1}{4\\pi\\sqrt{d^2+r^2}} \\left[ \\phi_0 + \\frac{\\phi_0 d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)} + \\frac{1}{2}(h_{11}u^2+h_{22}v^2) + \\frac{\\phi_0}{2}(\\kappa_1^2 u^2 + \\kappa_2^2 v^2) \\right]$$\nWe integrate this over the disk of radius $a$. In polar coordinates, $\\mathrm{d}u \\mathrm{d}v = r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$. We use the identities $\\int_0^{2\\pi}\\cos^2\\theta\\,\\mathrm{d}\\theta=\\pi$ and $\\int_0^{2\\pi}\\sin^2\\theta\\,\\mathrm{d}\\theta=\\pi$. This implies that for a function $f(r)$, terms like $\\int_{\\text{disk}} f(r) u^2 \\,\\mathrm{d}u\\mathrm{d}v = \\pi \\int_0^a f(r) r^3 \\,\\mathrm{d}r$.\nThe integral separates into four parts:\n$I \\approx I_{\\text{base}} + I_\\kappa + I_H + I_{\\kappa^2}$\n$1$. The base integral from the constant term $\\phi_0$:\n$$I_{\\text{base}} = \\frac{1}{4\\pi} \\int_0^{2\\pi}\\int_0^a \\frac{\\phi_0}{\\sqrt{d^2+r^2}} r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta = \\frac{\\phi_0}{2} \\int_0^a \\frac{r}{\\sqrt{d^2+r^2}} \\mathrm{d}r = \\frac{\\phi_0}{2} [\\sqrt{d^2+r^2}]_0^a = \\frac{\\phi_0}{2}(\\sqrt{d^2+a^2}-d)$$\n$2$. The correction from the kernel dependence on surface curvature $(\\kappa_1, \\kappa_2)$:\n$$I_\\kappa = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{\\phi_0 d(\\kappa_1 u^2 + \\kappa_2 v^2)}{2(d^2+r^2)^{3/2}} \\mathrm{d}u\\mathrm{d}v = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} \\int_0^a \\frac{r^3}{(d^2+r^2)^{3/2}}\\mathrm{d}r$$\n$3$. The correction from the density variation (Hessian trace $H_{\\mathrm{tr}}=h_{11}+h_{22}$):\n$$I_H = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{h_{11}u^2+h_{22}v^2}{2\\sqrt{d^2+r^2}} \\mathrm{d}u\\mathrm{d}v = \\frac{H_{\\mathrm{tr}}}{8} \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r$$\n$4$. The correction from the area element variation:\n$$I_{\\kappa^2} = \\frac{1}{4\\pi} \\int_{\\text{disk}} \\frac{\\phi_0}{\\sqrt{d^2+r^2}}\\frac{1}{2}(\\kappa_1^2 u^2+\\kappa_2^2 v^2) \\mathrm{d}u\\mathrm{d}v = \\frac{\\phi_0(\\kappa_1^2+\\kappa_2^2)}{8} \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r$$\nThe total error is $E = I - I_{\\mathrm{approx}} = (I_{\\text{base}} - I_{\\mathrm{approx}}) + I_H + I_\\kappa + I_{\\kappa^2}$. Let $E_1 = I_{\\text{base}} - I_{\\mathrm{approx}}$, $E_2 = I_H+I_{\\kappa^2}$, and $E_3 = I_\\kappa$. The estimator is $E_{\\mathrm{est}} = |E_1 + E_2 + E_3|$.\n\nThe required radial integrals evaluate to:\n$$J_1(a,d) = \\int_0^a \\frac{r^3}{\\sqrt{d^2+r^2}}\\mathrm{d}r = \\frac{(a^2-2d^2)\\sqrt{d^2+a^2} + 2d^3}{3}$$\n$$J_2(a,d) = \\int_0^a \\frac{r^3}{(d^2+r^2)^{3/2}}\\mathrm{d}r = \\sqrt{d^2+a^2} + \\frac{d^2}{\\sqrt{d^2+a^2}} - 2d = \\frac{(\\sqrt{d^2+a^2}-d)^2}{\\sqrt{d^2+a^2}}$$\nUsing these, the error contributions are:\n$$E_1 = \\frac{\\phi_0}{2}(\\sqrt{d^2+a^2}-d) - \\frac{\\phi_0 a^2}{4d}$$\n$$E_2 = (I_H + I_{\\kappa^2}) = \\frac{1}{8}(H_{\\mathrm{tr}} + \\phi_0(\\kappa_1^2+\\kappa_2^2)) J_1(a,d)$$\n$$E_3 = I_\\kappa = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} J_2(a,d)$$\nTo ensure numerical stability for small $d$, $E_1$ can be reformulated. Let $S=\\sqrt{d^2+a^2}$.\n$$E_1 = \\frac{\\phi_0}{2}\\left(\\frac{a^2}{S+d} - \\frac{a^2}{2d}\\right) = \\frac{\\phi_0 a^2}{2}\\frac{2d - (S+d)}{2d(S+d)} = \\frac{\\phi_0 a^2 (d-S)}{4d(S+d)}$$\nThe final error estimator is the magnitude of the sum of these corrections:\n$$E_{\\mathrm{est}} = \\left| E_1 + E_2 + E_3 \\right|$$\nThe refinement criterion is $E_{\\mathrm{est}} > \\tau$.\nThe final formulas for implementation, with $a^2 = h^2/\\pi$:\nLet $S = \\sqrt{d^2+h^2/\\pi}$.\n$$E_1 = \\frac{\\phi_0 (h^2/\\pi)}{4} \\frac{d-S}{d(S+d)}$$\n$$E_2 = \\frac{1}{8}\\left(H_{\\mathrm{tr}} + \\phi_0(\\kappa_1^2+\\kappa_2^2)\\right) \\frac{(h^2/\\pi-2d^2)S + 2d^3}{3}$$\n$$E_3 = \\frac{\\phi_0 d(\\kappa_1+\\kappa_2)}{8} \\frac{(S-d)^2}{S}$$\n$$E_{\\mathrm{est}} = |E_1 + E_2 + E_3|$$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates an error estimator for a one-point quadrature rule for a\n    near-singular integral and decides whether panel refinement is needed.\n    \"\"\"\n    test_cases = [\n        # d, h, phi_0, k1, k2, H_tr, tau\n        (0.5, 0.5, 1.0, 0.0, 0.0, 0.1, 1e-3),\n        (0.01, 0.2, 1.0, 0.2, 0.2, 0.5, 1e-3),\n        (2.5, 0.5, 1.0, 1.0, 1.0, 0.2, 1e-3),\n        (0.25, 0.5, 1.0, 2.0, -1.0, 1.0, 1e-2),\n        (0.05, 0.5, 0.1, 0.0, 0.0, 0.0, 1e-3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        d, h, phi_0, k1, k2, H_tr, tau = case\n        \n        # Area of the equivalent disk, a^2 = h^2 / pi\n        a_sq = h**2 / np.pi\n        \n        # Auxiliary variable S = sqrt(d^2 + a^2)\n        S = np.sqrt(d**2 + a_sq)\n\n        # Contribution 1: Error from approximating the kernel 1/R\n        # This is (I_base - I_approx)\n        # Numerically stable form: E1 = phi_0/2 * (a^2/(S+d) - a^2/(2d))\n        E1_numerator = phi_0 * a_sq * (d - S)\n        E1_denominator = 4 * d * (S + d)\n        E1 = E1_numerator / E1_denominator\n        \n        # Contribution 2: Error from density variation (Hessian) and area element curvature (k^2)\n        # Both terms involve the same radial integral J1.\n        # J1 = integral(r^3 / sqrt(d^2+r^2)) dr from 0 to a\n        J1_integrand = (a_sq - 2*d**2) * S + 2*d**3\n        J1 = J1_integrand / 3.0\n        E2_prefactor = (H_tr + phi_0 * (k1**2 + k2**2)) / 8.0\n        E2 = E2_prefactor * J1\n        \n        # Contribution 3: Error from kernel dependence on surface curvature (k)\n        # This term involves a radial integral J2.\n        # J2 = integral(r^3 / (d^2+r^2)^(3/2)) dr from 0 to a\n        # Numerically stable form: J2 = (S-d)^2 / S\n        J2 = (S - d)**2 / S\n        E3_prefactor = (phi_0 * d * (k1 + k2)) / 8.0\n        E3 = E3_prefactor * J2\n        \n        # Total error estimator is the absolute value of the sum of corrections\n        E_est = np.abs(E1 + E2 + E3)\n        \n        # Decision: refine if the estimated error exceeds the tolerance\n        should_refine = E_est > tau\n        results.append(should_refine)\n\n    # Format the output as a comma-separated list of booleans\n    # The map(str,...) and .lower() is to match the required output format, e.g., [True,False] -> [true,false]\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}