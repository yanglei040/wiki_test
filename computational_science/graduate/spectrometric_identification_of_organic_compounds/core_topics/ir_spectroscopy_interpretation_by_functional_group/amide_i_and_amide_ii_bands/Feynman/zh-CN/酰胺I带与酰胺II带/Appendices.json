{
    "hands_on_practices": [
        {
            "introduction": "同位素标记是光谱学中用于指认谱峰和探测分子结构的一种强有力工具。本练习将通过一个基于谐振子模型的计算，来加深您对分子振动频率与原子质量之间基本关系的理解。您将亲自计算酰胺I带和酰胺II带在进行同位素取代（例如，用氘取代氢）后预期的频率位移，这对于准确解析复杂的红外光谱至关重要。",
            "id": "3692261",
            "problem": "一种多肽在红外光谱中显示出酰胺 I 带和酰胺 II 带。酰胺 I 带主要由肽键的羰基伸缩坐标决定，可被建模为包含碳原子和氧原子的单个双原子谐振子。酰胺 II 带主要由氮-氢键的平面内弯曲决定，对于小角度位移，可被建模为一个角谐振子，其动能由围绕氮原子的有效转动惯量表征。假设对于含氢的天然丰度样品，有以下条件：\n- 观测到的酰胺 I 带波数值为 $1650\\,\\mathrm{cm}^{-1}$。\n- 观测到的酰胺 II 带波数值为 $1550\\,\\mathrm{cm}^{-1}$。\n\n你进行两种独立的同位素修饰：\n1. 仅对酰胺 I 模式，你用同位素 $^{13}\\text{C}$ 和 $^{18}\\text{O}$ 取代羰基。\n2. 仅对酰胺 II 模式，你将肽完全氘代，使氮-氢键变为氮-氘键。\n\n使用以下物理上合理的建模假设和常数：\n- 对于羰基伸缩模式，将振动视为角频率为 $\\omega = \\sqrt{k/\\mu}$ 的双原子谐振子，其中 $k$ 是一个同位素不变的力常数，$\\mu$ 是折合质量 $\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}}$。波数为 $\\tilde{\\nu} = \\omega/(2\\pi c)$，因此在固定的 $k$ 值下，波数按 $\\tilde{\\nu} \\propto \\mu^{-1/2}$ 的比例缩放。\n- 对于酰胺 II 弯曲模式，将小角度平面内弯曲建模为角频率为 $\\omega = \\sqrt{k_{\\mathrm{b}}/I}$ 的角谐振子，其中 $k_{\\mathrm{b}}$ 是一个同位素不变的弯曲力常数，$I$ 是围绕氮原子的有效转动惯量。假设氮原子被肽骨架有效固定，因此 $I \\approx m_{X} r^{2}$，其中 $X \\in \\{\\mathrm{H},\\mathrm{D}\\}$ 且键长 $r$ 固定，从而在用 D 取代 H 时，得出比例关系 $\\tilde{\\nu} \\propto I^{-1/2} \\propto m_{X}^{-1/2}$。\n- 原子质量（以统一原子质量单位计）为：$m(^{12}\\mathrm{C}) = 12.000000$， $m(^{13}\\mathrm{C}) = 13.003355$， $m(^{16}\\mathrm{O}) = 15.994915$， $m(^{18}\\mathrm{O}) = 17.999160$， $m(\\mathrm{H}) = 1.007825$， $m(\\mathrm{D}) = 2.014102$。\n- 光速 $c$ 和键长 $r$ 是常数，在所需的比率计算中会被消掉；不要代入它们的数值。\n\n从这些基本原理和比例关系出发，计算 $^{13}\\text{C}$/$^{18}\\text{O}$ 标记后预测的酰胺 I 带波数和氘代后预测的酰胺 II 带波数。然后，计算这两个新波数的差值。以 $\\mathrm{cm}^{-1}$ 为单位表示你的最终答案，并将最终结果四舍五入到四位有效数字。不要在中间的数学表达式中携带单位；仅在陈述给定值或最终值时包含单位。",
            "solution": "首先根据所需标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **酰胺 I 带模型（羰基伸缩）**：双原子谐振子。\n  - 角频率：$\\omega = \\sqrt{k/\\mu}$\n  - 力常数 $k$ 是同位素不变的。\n  - 折合质量：$\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}}$\n  - 波数比例关系：$\\tilde{\\nu} \\propto \\mu^{-1/2}$\n- **酰胺 II 带模型（N-H 弯曲）**：角谐振子。\n  - 角频率：$\\omega = \\sqrt{k_{\\mathrm{b}}/I}$\n  - 弯曲力常数 $k_{\\mathrm{b}}$ 是同位素不变的。\n  - 有效转动惯量：$I \\approx m_{X} r^{2}$，对于 $X \\in \\{\\mathrm{H},\\mathrm{D}\\}$，键长 $r$ 固定。\n  - 波数比例关系：$\\tilde{\\nu} \\propto m_{X}^{-1/2}$\n- **观测波数（含氢样品）**：\n  - 酰胺 I 带：$\\tilde{\\nu}_{\\text{I, unlab}} = 1650\\,\\mathrm{cm}^{-1}$\n  - 酰胺 II 带：$\\tilde{\\nu}_{\\text{II, unlab}} = 1550\\,\\mathrm{cm}^{-1}$\n- **同位素修饰**：\n  1. 对于酰胺 I：$^{12}\\text{C}=^{16}\\text{O}$ 被 $^{13}\\text{C}=^{18}\\text{O}$ 取代。\n  2. 对于酰胺 II：N-H 被 N-D 取代。\n- **原子质量（单位 u）**：\n  - $m(^{12}\\mathrm{C}) = 12.000000$\n  - $m(^{13}\\mathrm{C}) = 13.003355$\n  - $m(^{16}\\mathrm{O}) = 15.994915$\n  - $m(^{18}\\mathrm{O}) = 17.999160$\n  - $m(\\mathrm{H}) = 1.007825$\n  - $m(\\mathrm{D}) = 2.014102$\n- **任务**：计算 $^{13}\\text{C}$/$^{18}\\text{O}$ 标记后预测的酰胺 I 带波数和氘代后预测的酰胺 II 带波数。然后，计算这两个新波数的差值，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n- **科学基础**：该问题在振动光谱学原理方面有坚实的科学基础。使用谐振子模型描述分子振动，以及振动频率随折合质量（用于伸缩振动）或有效质量/转动惯量（用于弯曲振动）的比例关系，是标准的、教科书式的近似（玻恩-奥本海默近似意味着力常数与同位素取代无关）。\n- **适定性**：该问题提供了所有必要的数据和一套清晰、明确的指令，以计算出唯一的数值答案。\n- **客观性**：问题以精确、定量的术语陈述，不含任何主观或基于意见的内容。假设被明确给出。\n- 该问题未违反任何无效性标准。它在科学上是合理的、可形式化的、完整的且结构良好。\n\n### 步骤 3：结论与行动\n该问题被判定为 **有效**。将提供完整解答。\n\n### 解答推导\n\n该问题要求计算酰胺 I 带和酰胺 II 带的同位素位移波数，然后计算它们的差值。我们将分别处理每个谱带。\n\n#### 酰胺 I 带计算\n酰胺 I 带被建模为双原子谐振子。振动波数 $\\tilde{\\nu}$ 与角频率 $\\omega$ 的关系为 $\\tilde{\\nu} = \\frac{\\omega}{2\\pi c}$，其中 $c$ 是光速。角频率由 $\\omega = \\sqrt{\\frac{k}{\\mu}}$ 给出，其中 $k$ 是力常数，$\\mu$ 是折合质量。由于假设 $k$ 在同位素取代中保持不变，波数 $\\tilde{\\nu}$ 与折合质量的比例关系为 $\\tilde{\\nu} \\propto \\mu^{-1/2}$。\n\n设 $\\tilde{\\nu}_{\\text{I, unlab}}$ 和 $\\mu_{\\text{unlab}}$ 分别为未标记的 $^{\\text{12}}\\text{C}=^{\\text{16}}\\text{O}$ 物种的波数和折合质量，设 $\\tilde{\\nu}_{\\text{I, lab}}$ 和 $\\mu_{\\text{lab}}$ 为同位素标记的 $^{\\text{13}}\\text{C}=^{\\text{18}}\\text{O}$ 物种的相应量。比例关系为：\n$$ \\frac{\\tilde{\\nu}_{\\text{I, lab}}}{\\tilde{\\nu}_{\\text{I, unlab}}} = \\sqrt{\\frac{\\mu_{\\text{unlab}}}{\\mu_{\\text{lab}}}} $$\n因此，标记后的酰胺 I 带的预测波数为：\n$$ \\tilde{\\nu}_{\\text{I, lab}} = \\tilde{\\nu}_{\\text{I, unlab}} \\times \\sqrt{\\frac{\\mu_{\\text{unlab}}}{\\mu_{\\text{lab}}}} $$\n\n首先，我们计算折合质量。\n对于未标记的物种 ($^{\\text{12}}\\text{C}=^{\\text{16}}\\text{O}$):\n$$ \\mu_{\\text{unlab}} = \\frac{m(^{12}\\mathrm{C}) m(^{16}\\mathrm{O})}{m(^{12}\\mathrm{C}) + m(^{16}\\mathrm{O})} = \\frac{(12.000000)(15.994915)}{12.000000 + 15.994915} = \\frac{191.93898}{27.994915} \\approx 6.856353\\,\\text{u} $$\n对于标记的物种 ($^{\\text{13}}\\text{C}=^{\\text{18}}\\text{O}$):\n$$ \\mu_{\\text{lab}} = \\frac{m(^{13}\\mathrm{C}) m(^{18}\\mathrm{O})}{m(^{13}\\mathrm{C}) + m(^{18}\\mathrm{O})} = \\frac{(13.003355)(17.999160)}{13.003355 + 17.999160} = \\frac{234.051493}{31.002515} \\approx 7.549429\\,\\text{u} $$\n\n现在，我们可以计算预测的酰胺 I 带波数：\n$$ \\tilde{\\nu}_{\\text{I, lab}} = 1650\\,\\mathrm{cm}^{-1} \\times \\sqrt{\\frac{6.856353}{7.549429}} \\approx 1650 \\times \\sqrt{0.908194} \\approx 1650 \\times 0.95300 = 1572.45\\,\\mathrm{cm}^{-1} $$\n在中间步骤使用更高的精度：\n$$ \\tilde{\\nu}_{\\text{I, lab}} = 1650 \\times \\sqrt{\\frac{6.85635338}{7.54942935}} \\approx 1572.4498\\,\\mathrm{cm}^{-1} $$\n\n#### 酰胺 II 带计算\n酰胺 II 带的建模使其波数按 $\\tilde{\\nu} \\propto m_{X}^{-1/2}$ 比例变化，其中 $m_X$ 是处于弯曲运动外围的原子的质量，对于未标记的肽是 H，对于氘代的肽是 D。\n\n设 $\\tilde{\\nu}_{\\text{II, unlab}}$ 为含氢（N-H）物种的波数，$\\tilde{\\nu}_{\\text{II, lab}}$ 为氘代（N-D）物种的波数。比例关系为：\n$$ \\frac{\\tilde{\\nu}_{\\text{II, lab}}}{\\tilde{\\nu}_{\\text{II, unlab}}} = \\sqrt{\\frac{m(\\mathrm{H})}{m(\\mathrm{D})}} $$\n因此，标记后的酰胺 II 带的预测波数为：\n$$ \\tilde{\\nu}_{\\text{II, lab}} = \\tilde{\\nu}_{\\text{II, unlab}} \\times \\sqrt{\\frac{m(\\mathrm{H})}{m(\\mathrm{D})}} $$\n\n使用给定的质量 $m(\\mathrm{H}) = 1.007825\\,\\text{u}$ 和 $m(\\mathrm{D}) = 2.014102\\,\\text{u}$，以及给定的初始波数 $\\tilde{\\nu}_{\\text{II, unlab}} = 1550\\,\\mathrm{cm}^{-1}$：\n$$ \\tilde{\\nu}_{\\text{II, lab}} = 1550\\,\\mathrm{cm}^{-1} \\times \\sqrt{\\frac{1.007825}{2.014102}} \\approx 1550 \\times \\sqrt{0.500384} \\approx 1550 \\times 0.707378 = 1096.44\\,\\mathrm{cm}^{-1} $$\n在中间步骤使用更高的精度：\n$$ \\tilde{\\nu}_{\\text{II, lab}} = 1550 \\times \\sqrt{\\frac{1.007825}{2.014102}} \\approx 1096.4365\\,\\mathrm{cm}^{-1} $$\n\n#### 最终计算\n问题要求计算两个预测波数之间的差值，$\\Delta\\tilde{\\nu} = \\tilde{\\nu}_{\\text{I, lab}} - \\tilde{\\nu}_{\\text{II, lab}}$。\n$$ \\Delta\\tilde{\\nu} = 1572.4498\\,\\mathrm{cm}^{-1} - 1096.4365\\,\\mathrm{cm}^{-1} = 476.0133\\,\\mathrm{cm}^{-1} $$\n最终结果必须四舍五入到四位有效数字。\n数值 $476.0133$ 四舍五入到四位有效数字是 $476.0$。\n因此，差值为 $476.0\\,\\mathrm{cm}^{-1}$。",
            "answer": "$$\\boxed{476.0}$$"
        },
        {
            "introduction": "尽管量子化学计算能够预测振动光谱，但其结果往往与实验值存在系统性偏差。本练习将指导您通过编程实践，学习如何使用经验线性标度方法来校准理论计算数据，使其与实验测量结果更好地吻合。掌握这种连接理论计算与实验数据的校准技术，对于任何希望利用计算光谱学来辅助解释实验现象的研究者来说，都是一项至关重要的技能。",
            "id": "3692255",
            "problem": "您的任务是设计一个完整、可运行的程序，对有机化合物光谱鉴定中使用的酰胺 I (Amide I) 和酰胺 II (Amide II) 谱带的振动波数进行计算预测和经验标度。从量子谐振子的基本原理和波数的定义开始，然后构建一个线性经验校正模型，并通过有原则的优化准则确定其参数。最后，评估预测准确性，并将校准后的模型应用于新的计算预测。所有涉及波数的物理答案必须以 $\\mathrm{cm^{-1}}$ 表示，并遵循下面指定的舍入规则。\n\n请使用以下科学基础作为您的出发点：\n- 量子谐振子的频率由 $\\omega = \\sqrt{k / \\mu}$ 给出，其中 $\\omega$ 是角频率，$k$ 是力常数，$\\mu$ 是约化质量。\n- 红外 (IR) 振动波数定义为 $\\tilde{\\nu} = \\omega / (2\\pi c)$，其中 $c$ 是光速。\n- 在实际的计算光谱学中，来自密度泛函理论 (DFT) 的谐波预测会系统性地偏离实测基频（例如，由于非谐性和方法/基组误差）。我们寻求一种经验线性映射，将计算出的谐波波数映射到实测基频波数，以校正每个谱带的这些偏差。\n\n在您的程序中完全构建以下模型和估计任务，不使用任何外部输入：\n- 设计算出的谐波波数为 $x_i$，傅里叶变换红外 (FTIR) 实测基频为 $y_i$，对于一个谱带（酰胺 I 或酰胺 II）的校准数据集中的 $i = 1,\\dots,n$。假设实测值与计算值之间的经验关系模型为 $y_i \\approx s x_i + b$，其中 $s$ 是一个无量纲标度因子，$b$ 是一个以 $\\mathrm{cm^{-1}}$ 为单位的偏移量。\n- 通过在校准数据集上最小化残差平方和 $\\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2$ 来确定 $s$ 和 $b$。您的实现必须能稳健地处理简并边界情况 $\\mathrm{Var}(x_i) = 0$：当 $x_i$ 的方差为零（或在数值上有效为零）时，设置 $s = 0$，$b$ 等于 $y_i$ 的平均值。\n- 校准后，计算校准集上的均方根偏差 (RMSD)，公式为 $\\mathrm{RMSD} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2}$，单位为 $\\mathrm{cm^{-1}}$。\n- 应用校准后的映射 $\\hat{y} = s x + b$ 到新的计算预测值 $x$，以获得以 $\\mathrm{cm^{-1}}$ 为单位的标度化预测值。\n\n舍入和输出要求：\n- 将 $s$ 舍入到 $6$ 位小数（无量纲）。\n- 将 $b$ 舍入到 $2$ 位小数，单位为 $\\mathrm{cm^{-1}}$。\n- 将 $\\mathrm{RMSD}$ 舍入到 $2$ 位小数，单位为 $\\mathrm{cm^{-1}}$。\n- 将每个标度化预测值舍入到 $1$ 位小数，单位为 $\\mathrm{cm^{-1}}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$）。每个测试用例的结果本身必须是 $[s, b, \\mathrm{RMSD}, [\\text{标度化预测值}]]$ 形式的列表，其中最后的嵌套列表包含该用例的标度化预测值。\n\n需要在您的程序中逐字实现的测试套件。对于每个用例，独立处理它，并如上所述执行校准和预测。\n\n- 用例 1（酰胺 I，正常路径）：校准数据 $x = [1710,1695,1660,1650]\\,\\mathrm{cm^{-1}}$，$y = [1665,1650,1610,1605]\\,\\mathrm{cm^{-1}}$。对 $x_{\\text{new}} = [1700,1655]\\,\\mathrm{cm^{-1}}$ 进行预测。\n- 用例 2（酰胺 II，正常路径）：校准数据 $x = [1570,1555,1530,1515]\\,\\mathrm{cm^{-1}}$，$y = [1540,1528,1502,1490]\\,\\mathrm{cm^{-1}}$。对 $x_{\\text{new}} = [1560,1520]\\,\\mathrm{cm^{-1}}$ 进行预测。\n- 用例 3（边界条件，$x$ 的方差为零）：校准数据 $x = [1700,1700,1700]\\,\\mathrm{cm^{-1}}$，$y = [1660,1665,1655]\\,\\mathrm{cm^{-1}}$。对 $x_{\\text{new}} = [1700,1690]\\,\\mathrm{cm^{-1}}$ 进行预测。\n- 用例 4（边缘情况，小数据集）：校准数据 $x = [1565,1525]\\,\\mathrm{cm^{-1}}$，$y = [1535,1495]\\,\\mathrm{cm^{-1}}$。对 $x_{\\text{new}} = [1545]\\,\\mathrm{cm^{-1}}$ 进行预测。\n\n科学真实性与解释：\n- 酰胺 I 谱带基频通常出现在 $1600-1700\\,\\mathrm{cm^{-1}}$ 附近，酰胺 II 谱带在 $1480-1575\\,\\mathrm{cm^{-1}}$ 附近。上述校准数据集在设计上是科学合理的，反映了谐波 DFT 计算出的 $x_i$ 值通常会高估 $y_i$ 基频的事实。\n\n您的程序必须实现上述测试套件，并以确切指定的格式生成单行输出。所有波数相关的量必须以 $\\mathrm{cm^{-1}}$ 为单位，并遵循上述舍入规则。",
            "solution": "问题陈述经过严格验证，被认为是有效的。它在科学上基于振动光谱学和计算化学的原理，在数学上是适定的、客观且自包含的。该任务是实现计算光谱学中使用的标准经验校正程序，特别是线性回归，以标度计算出的谐波振动波数，使其与实验基频波数相匹配。\n\n问题的核心是确定线性模型 $y_i \\approx s x_i + b$ 的参数，其中 $x_i$ 代表计算出的谐波波数，$y_i$ 代表相应的实测基频波数。参数，即无量纲标度因子 $s$ 和偏移量 $b$（单位为 $\\mathrm{cm^{-1}}$），通过最小二乘法原理找到，该原理涉及最小化残差平方和 (SSR)：\n\n$$\n\\mathrm{SSR} = \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2\n$$\n\n为了找到最小化此量的 $s$ 和 $b$ 的值，我们对 SSR 分别求关于 $s$ 和 $b$ 的偏导数，并令其为零。这会得到正规方程组，其解为斜率 $s$ 和截距 $b$ 的估计量：\n\n$$\ns = \\frac{\\sum_{i=1}^{n}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{n}(x_i - \\bar{x})^2} = \\frac{\\mathrm{Cov}(x, y)}{\\mathrm{Var}(x)}\n$$\n\n$$\nb = \\bar{y} - s\\bar{x}\n$$\n\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $x_i$ 和 $y_i$ 数据的算术平均值。$s$ 表达式的分子是偏差乘积之和，与协方差成正比；分母是 $x$ 的偏差平方和，与方差成正比。\n\n实现的一个关键方面是处理自变量 $\\mathrm{Var}(x)$ 的方差为零的简并情况。当校准集中的所有 $x_i$ 值都相同时，就会发生这种情况。在这种情况下，斜率 $s$ 是未定义的。问题为此场景提供了一个科学上合理的规定：设置 $s=0$，并将 $b$ 估计为观测值的平均值，即 $b = \\bar{y}$。这意味着如果计算值不提供任何信息（方差为零），那么对测量值的最佳预测就是测量值的平均值。\n\n一旦根据校准数据确定了参数 $s$ 和 $b$，模型在该数据集上的拟合优度将使用均方根偏差 (RMSD) 进行量化：\n\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} \\left(y_i - (s x_i + b)\\right)^2} = \\sqrt{\\frac{\\mathrm{SSR}}{n}}\n$$\n\n最后，使用校准后的线性模型 $\\hat{y} = s x + b$ 为一组新的计算波数 $x$ 预测标度化波数 $\\hat{y}$。\n\n该程序将被结构化为独立处理每个测试用例。对于每个用例，它接收一个校准数据集 ($x$, $y$) 和一组用于预测的新点 ($x_{\\text{new}}$)。实现将使用 `numpy` 库进行高效的向量化数值运算。它将首先计算校准 $x$ 数据的方差。如果该方差在数值上与零无法区分，则应用边界条件逻辑。否则，使用标准的普通最小二乘法公式计算 $s$ 和 $b$。随后，计算 RMSD 和对 $x_{\\text{new}}$ 的标度化预测。所有计算都使用全浮点精度执行，最终结果仅在输出阶段格式化到指定的小数位数，以确保数值准确性。最终输出是一个单行字符串，由所有测试用例的格式化结果组成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs computational prediction and empirical scaling of vibrational\n    wavenumbers for Amide I and Amide II bands based on a linear regression model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1 (Amide I, happy path)\",\n            \"x_calib\": [1710, 1695, 1660, 1650],\n            \"y_calib\": [1665, 1650, 1610, 1605],\n            \"x_new\": [1700, 1655]\n        },\n        {\n            \"name\": \"Case 2 (Amide II, happy path)\",\n            \"x_calib\": [1570, 1555, 1530, 1515],\n            \"y_calib\": [1540, 1528, 1502, 1490],\n            \"x_new\": [1560, 1520]\n        },\n        {\n            \"name\": \"Case 3 (boundary condition, zero variance in x)\",\n            \"x_calib\": [1700, 1700, 1700],\n            \"y_calib\": [1660, 1665, 1655],\n            \"x_new\": [1700, 1690]\n        },\n        {\n            \"name\": \"Case 4 (edge case, small dataset)\",\n            \"x_calib\": [1565, 1525],\n            \"y_calib\": [1535, 1495],\n            \"x_new\": [1545]\n        }\n    ]\n\n    results_str_list = []\n    \n    for case in test_cases:\n        x_calib = np.array(case[\"x_calib\"], dtype=np.float64)\n        y_calib = np.array(case[\"y_calib\"], dtype=np.float64)\n        x_new = np.array(case[\"x_new\"], dtype=np.float64)\n        \n        n = len(x_calib)\n        \n        # Using a small tolerance for floating point comparison to zero\n        var_x = np.var(x_calib, ddof=0)\n        \n        if n < 2 or var_x < 1e-9:\n            # Handle degenerate case: variance of x is zero (or n2)\n            s = 0.0\n            b = np.mean(y_calib) if n  0 else 0.0\n        else:\n            # Standard Ordinary Least Squares (OLS) calculation\n            # Use population variance/covariance (ddof=0) as it aligns with OLS formulas\n            # s = Cov(x,y) / Var(x)\n            cov_xy = np.cov(x_calib, y_calib, ddof=0)[0, 1]\n            s = cov_xy / var_x\n            \n            # b = mean(y) - s * mean(x)\n            b = np.mean(y_calib) - s * np.mean(x_calib)\n            \n        # Calculate predicted y for calibration set to find RMSD\n        y_pred_calib = s * x_calib + b\n        \n        # Calculate Root-Mean-Square Deviation (RMSD)\n        if n  0:\n            rmsd = np.sqrt(np.mean((y_calib - y_pred_calib)**2))\n        else:\n            rmsd = 0.0\n\n        # Apply the calibrated model to new predictions\n        scaled_predictions = s * x_new + b\n        \n        # Format results according to specifications\n        s_fmt = f\"{s:.6f}\"\n        b_fmt = f\"{b:.2f}\"\n        rmsd_fmt = f\"{rmsd:.2f}\"\n        \n        # Format each scaled prediction to 1 decimal place\n        scaled_preds_fmt = \",\".join([f\"{p:.1f}\" for p in scaled_predictions])\n        scaled_preds_str = f\"[{scaled_preds_fmt}]\"\n        \n        # Assemble the final string for the current case\n        case_result_str = f\"[{s_fmt},{b_fmt},{rmsd_fmt},{scaled_preds_str}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "蛋白质红外光谱中的酰胺I带谱形蕴含着其二级结构的丰富信息。通过将复杂的实验光谱分解为代表不同结构基元（如α-螺旋和β-折叠）的特征谱带的线性叠加，我们可以定量地估计各种二级结构的组分含量。本练习将引导您通过编程实现非负最小二乘法（NNLS），完成对酰胺I带的解卷积，从而将一个复杂的光谱轮廓转化为对蛋白质二级结构含量的量化评估。",
            "id": "3692260",
            "problem": "给定一个来自傅里叶变换红外（FTIR）光谱学的基于模型、有物理基础的任务，用于有机化合物的光谱鉴定，重点关注酰胺I带。酰胺I带主要源于肽键中的羰基伸缩振动，并对二级结构（例如，α-螺旋、β-折叠和无规卷曲）敏感。计算目标是在一个物理上合理的模型下，从酰胺I吸收光谱中估计定量的二级结构组分。\n\n使用的基本原理：\n- 比尔-朗伯定律：$A(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{N} \\varepsilon_{i}(\\tilde{\\nu}) c_{i}$，其中 $A(\\tilde{\\nu})$ 是在波数 $\\tilde{\\nu}$（单位为 $\\mathrm{cm}^{-1}$）处的无量纲吸光度，$\\ell$ 是光程长度（单位为 $\\mathrm{cm}$），$\\varepsilon_{i}(\\tilde{\\nu})$ 是组分 $i$ 的十进摩尔吸光系数（单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$），$c_{i}$ 是摩尔浓度（单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$）。\n- 线型表示：每个二级结构组分 $i$ 贡献一个由高斯函数 $g_{i}(\\tilde{\\nu}) = \\exp\\!\\left[-\\dfrac{(\\tilde{\\nu}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right]$ 表示的线型，其中心为 $\\tilde{\\nu}_{i}$（单位为 $\\mathrm{cm}^{-1}$），宽度参数为 $\\sigma_{i}$（单位为 $\\mathrm{cm}^{-1}$）。摩尔吸光系数建模为 $\\varepsilon_{i}(\\tilde{\\nu}) = \\varepsilon_{i}^{\\max}\\,g_{i}(\\tilde{\\nu})$，其中 $\\varepsilon_{i}^{\\max}$（单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$）是组分 $i$ 的峰值十进摩尔吸光系数。\n\n您必须将未知浓度 $c_{i}$ 视为非负值。每个二级结构组分的比例定义为 $f_{i} = \\dfrac{c_{i}}{\\sum_{j=1}^{N} c_{j}}$。\n\n给定三个组分来表示酰胺I带：\n- 组分 1 (α-螺旋): $\\tilde{\\nu}_{1} = 1654\\,\\mathrm{cm}^{-1}$, $\\sigma_{1} = 8\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{1}^{\\max} = 800\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$。\n- 组分 2 (β-折叠): $\\tilde{\\nu}_{2} = 1630\\,\\mathrm{cm}^{-1}$, $\\sigma_{2} = 10\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{2}^{\\max} = 1100\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$。\n- 组分 3 (无规卷曲): $\\tilde{\\nu}_{3} = 1645\\,\\mathrm{cm}^{-1}$, $\\sigma_{3} = 12\\,\\mathrm{cm}^{-1}$, $\\varepsilon_{3}^{\\max} = 700\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$。\n\n测量网格：\n- 波数 $\\tilde{\\nu}_{k}$（对于 $k = 0,1,\\dots,100$）由 $\\tilde{\\nu}_{k} = 1600 + k$ 定义，单位为 $\\mathrm{cm}^{-1}$，即从 $1600\\,\\mathrm{cm}^{-1}$ 到 $1700\\,\\mathrm{cm}^{-1}$（含），步长为 $1\\,\\mathrm{cm}^{-1}$。\n\n给定一个具有已知光程长度 $\\ell$ 和总浓度 $c_{\\mathrm{tot}}$ 以及真实组分分数 $(f_{1},f_{2},f_{3})$ 的测试用例，合成吸光度通过以下方式确定性地构建：\n$$\nA(\\tilde{\\nu}_{k}) = \\ell \\sum_{i=1}^{3} \\left( \\varepsilon_{i}^{\\max}\\,g_{i}(\\tilde{\\nu}_{k}) \\right)\\, c_{i}, \\quad \\text{with } c_{i} = f_{i}\\,c_{\\mathrm{tot}}, \\quad c_{i} \\ge 0.\n$$\n\n算法任务：\n- 对于每个测试用例，通过最小化残差平方和来估计非负浓度 $c_{i}$\n$$\n\\sum_{k=0}^{100} \\left[ A(\\tilde{\\nu}_{k}) - \\ell \\sum_{i=1}^{3} \\varepsilon_{i}^{\\max} g_{i}(\\tilde{\\nu}_{k}) c_{i} \\right]^{2},\n$$\n约束条件为对所有 $i$ 都有 $c_{i} \\ge 0$。然后计算组分分数 $f_{i} = \\dfrac{c_{i}}{\\sum_{j=1}^{3} c_{j}}$。将组分分数表示为四舍五入到四位小数的小数。\n\n单位：\n- 吸光度 $A$ 是无量纲的。\n- 波数 $\\tilde{\\nu}$ 的单位是 $\\mathrm{cm}^{-1}$。\n- 光程长度 $\\ell$ 的单位是 $\\mathrm{cm}$。\n- 浓度 $c_{i}$ 和 $c_{\\mathrm{tot}}$ 的单位是 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$。\n- 十进摩尔吸光系数 $\\varepsilon_{i}^{\\max}$ 的单位是 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$。\n\n测试套件：\n- 用例 1：$\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.010\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (1.0, 0.0, 0.0)$。\n- 用例 2：$\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.012\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.6, 0.3, 0.1)$。\n- 用例 3：$\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.008\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.0, 1.0, 0.0)$。\n- 用例 4：$\\ell = 0.005\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.020\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.4, 0.4, 0.2)$。\n- 用例 5：$\\ell = 0.010\\,\\mathrm{cm}$, $c_{\\mathrm{tot}} = 0.015\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $(f_{1},f_{2},f_{3}) = (0.45, 0.0, 0.55)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的估计组分分数，格式为逗号分隔的Python风格的列表的列表，每个内部列表按 $[f_{1},f_{2},f_{3}]$ 排序，值四舍五入到四位小数，例如 $[[0.1234,0.5678,0.3088],[\\dots],\\dots]$。\n\n角度单位规范：\n- 不涉及角度。\n\n百分比：\n- 组分分数必须以小数形式报告，不带百分号。\n\n您的程序必须实现非负最小二乘估计，并以指定的精确格式和四舍五入要求生成最终输出。",
            "solution": "我们从比尔-朗伯定律开始，该定律指出，在波数 $\\tilde{\\nu}$ 处的无量纲吸光度 $A(\\tilde{\\nu})$ 与光程长度 $\\ell$ 以及各吸收物质贡献的总和成正比。对于由索引 $i = 1,2,3$ 标记的多个组分，该定律为：\n$$\nA(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{3} \\varepsilon_{i}(\\tilde{\\nu})\\, c_{i},\n$$\n其中 $\\varepsilon_{i}(\\tilde{\\nu})$ 是组分 $i$ 在 $\\tilde{\\nu}$ 处的十进摩尔吸光系数（单位为 $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{cm}^{-1}$），$c_{i}$ 是该组分的摩尔浓度（单位为 $\\mathrm{mol}\\,\\mathrm{L}^{-1}$）。在酰胺I区，二级结构基序的摩尔吸光系数谱可以用高斯线型表示，其中心位于特征波数，捕捉了由环境异质性引起的展宽，其中\n$$\ng_{i}(\\tilde{\\nu}) = \\exp\\!\\left[-\\frac{(\\tilde{\\nu}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right], \\quad \\varepsilon_{i}(\\tilde{\\nu}) = \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}).\n$$\n因此，\n$$\nA(\\tilde{\\nu}) = \\ell \\sum_{i=1}^{3} \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu})\\, c_{i}.\n$$\n我们在 $\\tilde{\\nu}_{k} = 1600 + k$（单位 $\\mathrm{cm}^{-1}$）处对 $k = 0,1,\\dots,100$ 进行离散化测量。将模型写成矩阵-向量形式，定义一个设计矩阵 $X \\in \\mathbb{R}^{101 \\times 3}$，其元素为\n$$\nX_{k,i} = \\ell \\, \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}_{k}),\n$$\n以及未知向量 $\\mathbf{c} = [c_{1},c_{2},c_{3}]^{\\top}$。测得的吸光度向量 $\\mathbf{A} \\in \\mathbb{R}^{101}$ 满足\n$$\n\\mathbf{A} = X \\mathbf{c}.\n$$\n在每个合成测试用例中，我们使用真实参数确定性地构建 $\\mathbf{A}$：\n$$\nc_{i} = f_{i}\\, c_{\\mathrm{tot}}, \\quad \\mathbf{A}_{k} = \\sum_{i=1}^{3} X_{k,i} c_{i}.\n$$\n估计问题是在给定 $X$ 的情况下从 $\\mathbf{A}$ 中恢复 $\\mathbf{c}$，并满足约束条件 $c_{i} \\ge 0$。这是一个凸二次优化问题，具体来说是一个非负最小二乘（NNLS）问题：\n$$\n\\min_{\\mathbf{c} \\in \\mathbb{R}^{3}} \\left\\| \\mathbf{A} - X\\mathbf{c} \\right\\|_{2}^{2} \\quad \\text{subject to } c_{i} \\ge 0 \\text{ for } i=1,2,3.\n$$\n由于比尔-朗伯定律在浓度上是线性的，且线型是固定的，因此NNLS方法是合理的，它既是高斯测量噪声下的最大似然估计，也是无噪声合成情况下的最小二乘解。\n\n一旦估计出 $\\mathbf{c}$，我们计算组分分数：\n$$\nf_{i} = \\frac{c_{i}}{\\sum_{j=1}^{3} c_{j}}, \\quad i = 1,2,3.\n$$\n如果 $\\sum_{j=1}^{3} c_{j} = 0$（这将对应于零吸光度的边缘情况），我们定义所有 $i$ 的 $f_{i} = 0$ 以避免除以零；然而，在提供的测试套件中，这种情况不会发生。\n\n算法步骤：\n1. 构建波数网格 $\\tilde{\\nu}_{k} = 1600 + k$ (for $k = 0,\\dots,100$)。\n2. 对于每个组分 $i$，计算 $g_{i}(\\tilde{\\nu}_{k}) = \\exp\\!\\left[-\\dfrac{(\\tilde{\\nu}_{k}-\\tilde{\\nu}_{i})^{2}}{2\\sigma_{i}^{2}}\\right]$，然后计算 $\\varepsilon_{i}(\\tilde{\\nu}_{k}) = \\varepsilon_{i}^{\\max}\\, g_{i}(\\tilde{\\nu}_{k})$。\n3. 对于每个测试用例，给定 $\\ell$、$c_{\\mathrm{tot}}$ 和组分分数 $(f_{1},f_{2},f_{3})$，构建 $X_{k,i} = \\ell\\, \\varepsilon_{i}(\\tilde{\\nu}_{k})$ 并计算合成吸光度 $\\mathbf{A} = X \\mathbf{c}$，其中 $\\mathbf{c} = c_{\\mathrm{tot}}\\,[f_{1},f_{2},f_{3}]^{\\top}$。\n4. 求解NNLS问题以获得在非负性约束下最小化 $\\|\\mathbf{A}-X\\mathbf{\\hat{c}}\\|_{2}^{2}$ 的 $\\hat{\\mathbf{c}}$。\n5. 计算 $\\hat{f}_{i} = \\dfrac{\\hat{c}_{i}}{\\sum_{j=1}^{3} \\hat{c}_{j}}$。\n6. 将每个 $\\hat{f}_{i}$ 四舍五入到四位小数。\n7. 汇总所有测试用例的结果，并以单行Python风格的列表的列表形式打印。\n\n科学真实性和边缘情况覆盖：\n- 所选的中心 $\\tilde{\\nu}_{i}$ 和宽度 $\\sigma_{i}$ 与已知的α-螺旋、β-折叠和无规卷曲基序的酰胺I子带的位置和展宽一致。\n- 摩尔吸光系数峰值 $\\varepsilon_{i}^{\\max}$ 的排序与β-折叠通常表现出更强吸收的现象一致。\n- 测试套件包括纯组分情况（$f_{i}$ 在边界值 $0$ 或 $1$）、谱带重叠的混合情况，以及一个光程较短以挑战灵敏度的情况。这些测试旨在探测可识别性、非负性约束和重叠分辨能力。\n\n最后，程序实现了NNLS求解器以强制执行 $c_{i} \\ge 0$，并以指定的格式输出四舍五入到四位小数的组分分数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef gaussian(nu, nu0, sigma):\n    \"\"\"Gaussian line shape g(nu) centered at nu0 with width sigma.\"\"\"\n    return np.exp(-((nu - nu0) ** 2) / (2.0 * (sigma ** 2)))\n\ndef build_epsilon(nu_grid, centers, sigmas, eps_peaks):\n    \"\"\"\n    Build epsilon_i(nu) arrays for each component i:\n    epsilon_i(nu) = eps_peak_i * gaussian(nu; center_i, sigma_i)\n    \"\"\"\n    eps_list = []\n    for nu0, sigma, eps_peak in zip(centers, sigmas, eps_peaks):\n        g = gaussian(nu_grid, nu0, sigma)\n        eps_list.append(eps_peak * g)\n    return np.column_stack(eps_list)  # shape: (len(nu_grid), n_components)\n\ndef synth_absorbance(X, fractions, c_tot):\n    \"\"\"Construct synthetic absorbance A = X * c with c_i = fractions_i * c_tot.\"\"\"\n    c = np.array(fractions, dtype=float) * float(c_tot)\n    return X @ c\n\ndef estimate_fractions(X, A):\n    \"\"\"\n    Solve non-negative least squares to estimate c = 0 from A ~ X c,\n    then compute fractions f_i = c_i / sum(c_j).\n    \"\"\"\n    c_hat, _ = nnls(X, A)\n    total = c_hat.sum()\n    if total == 0.0:\n        f_hat = np.zeros_like(c_hat)\n    else:\n        f_hat = c_hat / total\n    # Round to 4 decimal places\n    f_hat = np.round(f_hat, 4)\n    return f_hat.tolist()\n\ndef solve():\n    # Wavenumber grid: 1600 to 1700 cm^-1 inclusive, step 1 cm^-1\n    nu_grid = np.arange(1600.0, 1700.0 + 1.0, 1.0)\n\n    # Component definitions (amide I sub-bands)\n    # Alpha-helix\n    nu1 = 1654.0\n    sigma1 = 8.0\n    eps1 = 800.0  # L mol^-1 cm^-1\n    # Beta-sheet\n    nu2 = 1630.0\n    sigma2 = 10.0\n    eps2 = 1100.0  # L mol^-1 cm^-1\n    # Random coil\n    nu3 = 1645.0\n    sigma3 = 12.0\n    eps3 = 700.0  # L mol^-1 cm^-1\n\n    centers = [nu1, nu2, nu3]\n    sigmas = [sigma1, sigma2, sigmas]\n    eps_peaks = [eps1, eps2, eps3]\n\n    # Build epsilon(nu) for each component\n    epsilon_matrix = build_epsilon(nu_grid, centers, sigmas, eps_peaks)\n\n    # Define the test cases: (ell, c_tot, fractions)\n    test_cases = [\n        (0.010, 0.010, [1.0, 0.0, 0.0]),           # Case 1\n        (0.010, 0.012, [0.6, 0.3, 0.1]),           # Case 2\n        (0.010, 0.008, [0.0, 1.0, 0.0]),           # Case 3\n        (0.005, 0.020, [0.4, 0.4, 0.2]),           # Case 4\n        (0.010, 0.015, [0.45, 0.0, 0.55]),         # Case 5\n    ]\n\n    results = []\n    for ell, c_tot, fractions in test_cases:\n        # Build design matrix X = ell * epsilon(nu)\n        X = ell * epsilon_matrix  # shape (101, 3)\n        # Synthesize absorbance A from ground-truth fractions\n        A = synth_absorbance(X, fractions, c_tot)\n        # Estimate fractions via non-negative least squares\n        f_hat = estimate_fractions(X, A)\n        results.append(f_hat)\n\n    # Final print statement in the exact required format.\n    # Single-line output: list of lists, with inner lists [f1,f2,f3]\n    def format_inner(lst):\n        return \"[\" + \",\".join(f\"{x:.4f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_inner(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}