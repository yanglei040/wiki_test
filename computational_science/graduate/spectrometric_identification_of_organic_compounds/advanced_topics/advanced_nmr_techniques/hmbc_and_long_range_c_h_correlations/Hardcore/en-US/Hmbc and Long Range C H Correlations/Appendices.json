{
    "hands_on_practices": [
        {
            "introduction": "The intensity of a cross-peak in an HMBC spectrum is not arbitrary; it is the result of a delicate balance between two competing physical processes. This exercise  challenges you to mathematically model this balance to find the optimal experimental delay for magnetization transfer. By deriving the ideal evolution time, you will gain a deeper appreciation for how pulse sequence parameters are chosen to maximize sensitivity for specific long-range couplings based on fundamental principles of spin dynamics and relaxation.",
            "id": "3707084",
            "problem": "In Heteronuclear Multiple Bond Correlation (HMBC) experiments, efficient transfer of magnetization between a proton and a carbon nucleus via long-range carbon–hydrogen scalar couplings is governed by coherent evolution under the scalar coupling Hamiltonian and attenuated by transverse relaxation. Consider a single dominant long-range carbon–hydrogen scalar coupling of magnitude $J_{LR}$ and a transverse relaxation time constant $T_2$ for the evolving heteronuclear coherence. Assume that one-bond carbon–hydrogen couplings are suppressed by appropriate filter elements so that the transfer is limited by the long-range coupling and relaxation.\n\nStarting from well-tested facts in nuclear magnetic resonance: (i) under a scalar coupling of magnitude $J$, antiphase coherence builds with a sinusoidal dependence on the evolution delay $\\tau$; and (ii) transverse relaxation attenuates transverse magnetization exponentially with time constant $T_2$, derive an analytic expression for the evolution delay $\\tau^{\\star}$ that maximizes the long-range transfer efficiency. Then, for $J_{LR} = 8.0 \\ \\mathrm{Hz}$ and $T_2 = 0.180 \\ \\mathrm{s}$, compute the optimal delay. Express your final numerical answer in milliseconds and round your answer to $4$ significant figures.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of Nuclear Magnetic Resonance (NMR) spectroscopy, specifically concerning the dynamics of heteronuclear coherences in a Heteronuclear Multiple Bond Correlation (HMBC) experiment. The problem is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution.\n\nThe goal is to find the optimal evolution delay, $\\tau^{\\star}$, that maximizes the efficiency of magnetization transfer. This efficiency, which we denote as $\\eta(\\tau)$, is determined by two competing processes: the coherent evolution of antiphase magnetization under scalar coupling and the incoherent decay due to transverse relaxation.\n\nAccording to fact (i) from the problem statement, the creation of antiphase coherence from in-phase coherence under a scalar coupling $J_{LR}$ for a duration $\\tau$ follows a sinusoidal dependence. In the context of the product operator formalism, this dependence is accurately described by a term proportional to $\\sin(\\pi J_{LR} \\tau)$. The maximum value of this term occurs when the argument is an odd multiple of $\\frac{\\pi}{2}$, but this ideal case is modified by relaxation.\n\nAccording to fact (ii), the signal is simultaneously attenuated by transverse relaxation, which is an exponential decay process with a time constant $T_2$. This introduces a factor of $\\exp(-\\frac{\\tau}{T_2})$ into the expression for the transfer efficiency.\n\nCombining these two effects, the transfer efficiency $\\eta(\\tau)$ at a given evolution time $\\tau$ can be modeled as being proportional to the product of the build-up and decay functions. We can write this relationship as:\n$$\n\\eta(\\tau) = C \\sin(\\pi J_{LR} \\tau) \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\nwhere $C$ is a positive proportionality constant that depends on factors such as gyromagnetic ratios and initial polarization, but is independent of $\\tau$. We are interested in the value of $\\tau$ for $\\tau  0$ that maximizes $\\eta(\\tau)$.\n\nTo find the maximum of the function $\\eta(\\tau)$, we must calculate its first derivative with respect to $\\tau$ and set it to zero.\n$$\n\\frac{d\\eta}{d\\tau} = 0\n$$\nUsing the product rule for differentiation, $(uv)' = u'v + uv'$, where $u(\\tau) = \\sin(\\pi J_{LR} \\tau)$ and $v(\\tau) = \\exp(-\\frac{\\tau}{T_2})$, we have:\n$$\n\\frac{du}{d\\tau} = \\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\n$$\n$$\n\\frac{dv}{d\\tau} = -\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\nThe derivative of $\\eta(\\tau)$ is then:\n$$\n\\frac{d\\eta}{d\\tau} = C \\left[ \\left(\\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\\right) \\exp\\left(-\\frac{\\tau}{T_2}\\right) + \\sin(\\pi J_{LR} \\tau) \\left(-\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\\right) \\right]\n$$\nSetting the derivative to zero:\n$$\nC \\exp\\left(-\\frac{\\tau}{T_2}\\right) \\left[ \\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) \\right] = 0\n$$\nSince $C  0$ and $\\exp(-\\frac{\\tau}{T_2})$ is never zero for finite $\\tau$, the term in the square brackets must be zero for an extremum to occur.\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) = 0\n$$\nRearranging this equation gives:\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) = \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau)\n$$\nDividing both sides by $\\cos(\\pi J_{LR} \\tau)$ (assuming it is non-zero, which is valid as if it were zero, the right-hand side would be non-zero, leading to a contradiction) yields:\n$$\n\\tan(\\pi J_{LR} \\tau) = \\pi J_{LR} T_2\n$$\nThe value of $\\tau$ that satisfies this equation is the optimal delay, $\\tau^{\\star}$. We can solve for $\\tau^{\\star}$ by taking the arctangent of both sides.\n$$\n\\pi J_{LR} \\tau^{\\star} = \\arctan(\\pi J_{LR} T_2)\n$$\nThe arctangent function is multi-valued; its general solution is $\\arctan(x) + n\\pi$ for any integer $n$. However, we are seeking the first positive value of $\\tau$ that maximizes the function, which corresponds to the principal value of the arctangent (i.e., for $n=0$), as this will correspond to the first peak of the damped sine wave.\nThe analytic expression for the optimal delay is therefore:\n$$\n\\tau^{\\star} = \\frac{1}{\\pi J_{LR}} \\arctan(\\pi J_{LR} T_2)\n$$\nNow, we substitute the given numerical values: $J_{LR} = 8.0 \\ \\mathrm{Hz}$ and $T_2 = 0.180 \\ \\mathrm{s}$. The units of $J_{LR}$ are $\\mathrm{s}^{-1}$.\nFirst, we compute the dimensionless argument of the arctangent function:\n$$\n\\pi J_{LR} T_2 = \\pi \\times (8.0 \\ \\mathrm{s}^{-1}) \\times (0.180 \\ \\mathrm{s}) \\approx 4.52389\n$$\nNow we compute the optimal delay $\\tau^{\\star}$ in seconds:\n$$\n\\tau^{\\star} = \\frac{1}{\\pi \\times 8.0 \\ \\mathrm{s}^{-1}} \\arctan(4.52389)\n$$\nThe value of the arctangent must be in radians:\n$$\n\\arctan(4.52389) \\approx 1.35306 \\ \\mathrm{rad}\n$$\nSubstituting this value back into the expression for $\\tau^{\\star}$:\n$$\n\\tau^{\\star} \\approx \\frac{1.35306}{25.13274 \\ \\mathrm{s}^{-1}} \\approx 0.053835 \\ \\mathrm{s}\n$$\nThe problem requires the answer in milliseconds, rounded to $4$ significant figures.\n$$\n\\tau^{\\star} \\approx 0.053835 \\ \\mathrm{s} \\times \\frac{1000 \\ \\mathrm{ms}}{1 \\ \\mathrm{s}} = 53.835 \\ \\mathrm{ms}\n$$\nRounding to $4$ significant figures, we get:\n$$\n\\tau^{\\star} = 53.84 \\ \\mathrm{ms}\n$$",
            "answer": "$$\n\\boxed{53.84}\n$$"
        },
        {
            "introduction": "Interpreting an HMBC spectrum is akin to solving a complex puzzle, where each cross-peak is a clue connecting distant parts of a molecule. This practice  elevates this interpretive art into a computational science, asking you to formalize the rules of HMBC connectivity into a graph-theoretic algorithm. By translating chemical heuristics into a precise and testable decision model, you will develop skills at the intersection of spectroscopy and cheminformatics, which are essential for automated and computer-assisted structure elucidation.",
            "id": "3707090",
            "problem": "You are given the task of formalizing Heteronuclear Multiple Bond Correlation (HMBC) connectivity as a graph-theoretic decision process suitable for algorithmic implementation. HMBC detects long-range couplings between hydrogen and carbon nuclei via through-bond pathways. In the graph-theoretic formalization, a molecule is represented as an undirected labeled graph with nodes for atoms and edges for chemical bonds.\n\nStart from the following fundamental base:\n- HMBC detects proton–carbon connectivities predominantly over paths of $2$ or $3$ bonds, with significantly reduced detectability for $4$-bond paths that may be enhanced by conjugation. Direct one-bond proton–carbon connectivities ($d=1$) are excluded by the HMBC pulse sequence design.\n- Long-range scalar spin–spin coupling magnitudes empirically decrease with the number of intervening bonds, and can be modulated by bond order and conjugation along the path.\n\nDefine the following graph model:\n- Let $G=(V,E)$ be an undirected graph. Each node $v \\in V$ is labeled by an atom type in the set $\\{\\mathrm{C},\\mathrm{H}\\}$. Define subsets $C \\subset V$ and $H \\subset V$ for carbon and hydrogen nodes, respectively.\n- Let $B$ be the weighted adjacency matrix of dimension $|V| \\times |V|$ whose element $b_{ij} \\in \\{0,1,2\\}$ equals the bond order between nodes $i$ and $j$, with $b_{ij}=0$ if no bond is present. The corresponding unweighted adjacency matrix $A$ has $a_{ij}=1$ if $b_{ij}0$, and $a_{ij}=0$ otherwise.\n- A simple path $P$ from a hydrogen node $h \\in H$ to a carbon node $c \\in C$ is an ordered sequence of distinct nodes $(v_0=h,v_1,\\dots,v_d=c)$ such that $a_{v_{k}v_{k+1}}=1$ for $k=0,\\dots,d-1$. The path length in bonds is $d$, and the bond-order sum along the path is $s(P)=\\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$.\n\nTo construct a decision rule consistent with the base facts, adopt the following detectability model for a given path $P$ of length $d$ and bond-order sum $s(P)$:\n- The apparent cross-peak amplitude is modeled as $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$ where $\\alpha0$ and $\\gamma \\ge 0$ are parameters that encode attenuation per bond and conjugation enhancement, respectively, and $s$ is the path bond-order sum. This captures decreasing detectability with increasing $d$, and enhanced detectability for paths with higher total bond order relative to the number of steps.\n- An HMBC decision threshold $\\tau0$ is applied to $A(d,s)$.\n\nA hydrogen–carbon pair $(h,c)$ is accepted as HMBC-correlated if and only if there exists a simple path $P$ from $h$ to $c$ satisfying all of the following:\n1. $d \\in \\{2,3\\}$ and $A(d,s(P)) \\ge \\tau$, or $d=4$, $s(P) \\ge d+1$, and $A(d,s(P)) \\ge \\tau$.\n2. The direct one-bond case $d=1$ is excluded regardless of $A(d,s)$.\n\nYou must implement a program that, for each test case, evaluates all observed hydrogen–carbon pairs against the above rule. For each pair, consider all simple paths of lengths $d \\in \\{2,3,4\\}$; for acceptance, it suffices that at least one path satisfies the conditions. If the pair is directly bonded ($d=1$), it must be rejected. The per-test-case result is a boolean: `True` if all observed pairs are accepted, and `False` otherwise.\n\nRepresent inputs as follows for each test case:\n- A node list of length $n$ giving atom types as strings `\"C\"` or `\"H\"` for indices $0$ to $n-1$.\n- A bond-order adjacency matrix $B$ of shape $n \\times n$ with integer entries in $\\{0,1,2\\}$, symmetric, and zeros on the diagonal.\n- A list of observed pairs as ordered tuples $(c\\_\\mathrm{index}, h\\_\\mathrm{index})$ with $c\\_\\mathrm{index} \\in C$, $h\\_\\mathrm{index} \\in H$.\n- Scalars $\\alpha$, $\\gamma$, and $\\tau$.\n\nYour program must implement the decision rule and evaluate the following test suite. Indices are zero-based, and all bonds are undirected:\n\nTest case $1$ (happy path, boundary at equality of threshold):\n- Nodes: $[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{H}\\,]$ for indices $[\\,0,1,2,3,4\\,]$.\n- Bonds ($b_{ij}=1$ where listed): $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$; all other $b_{ij}=0$.\n- Observed pairs: $[(2,0),(3,0)]$.\n- Parameters: $\\alpha=1$, $\\gamma=0$, $\\tau=0.049787$ (approximately equal to $\\exp(-3)$).\n- Expectation: $(2,0)$ has a path of length $d=2$ with $A(2,s)\\approx \\exp(-2)$; $(3,0)$ has $d=3$ with $A(3,s)\\approx \\exp(-3)$; acceptance at equality applies.\n\nTest case $2$ (explicit HMBC exclusion of one-bond):\n- Nodes: $[\\,\\mathrm{H},\\mathrm{C}\\,]$ for indices $[\\,0,1\\,]$.\n- Bonds: $(0,1)$ with $b_{01}=1$.\n- Observed pairs: $[(1,0)]$.\n- Parameters: $\\alpha=1$, $\\gamma=0$, $\\tau=0.2$.\n- Expectation: Only a direct path with $d=1$ exists; reject.\n\nTest case $3$ (four-bond conjugated path accepted):\n- Nodes: $[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$ for indices $[\\,0,1,2,3,4\\,]$ corresponding to $(\\mathrm{H}_4,\\mathrm{C}_4,\\mathrm{C}_3,\\mathrm{C}_2,\\mathrm{C}_1)$.\n- Bonds: $(0,1)$ with $b=1$, $(1,2)$ with $b=2$, $(2,3)$ with $b=1$, $(3,4)$ with $b=2$; all other $b_{ij}=0$.\n- Observed pairs: $[(4,0)]$.\n- Parameters: $\\alpha=1$, $\\gamma=0.5$, $\\tau=0.03$.\n- Expectation: A path exists with $d=4$ and $s=6$, giving $A(4,6)=\\exp(-4)\\,\\bigl(1+0.5\\,(6-4)\\bigr)=\\exp(-4)\\cdot 2$ above threshold; $s\\ge d+1$ holds, so accept.\n\nTest case $4$ (four-bond non-conjugated path rejected):\n- Nodes: $[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$ for indices $[\\,0,1,2,3,4\\,]$.\n- Bonds: $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$ each with $b=1$; all other $b_{ij}=0$.\n- Observed pairs: $[(4,0)]$.\n- Parameters: $\\alpha=1$, $\\gamma=0$, $\\tau=0.02$.\n- Expectation: The only path has $d=4$ and $s=4$; $A(4,4)=\\exp(-4)$ is below threshold, and $sd+1$, so reject.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., `[True,False,True,False]`, where each entry is the boolean result for the corresponding test case in the order listed above.\n- No other text should be printed.\n\nAngles are not applicable. There are no physical units in the outputs. All numeric values are dimensionless scalars. The only allowed outputs are booleans aggregated as specified. Implement your solution in any modern programming language; the final answer must be runnable code.",
            "solution": "The problem of formalizing Heteronuclear Multiple Bond Correlation (HMBC) connectivity as a graph-theoretic decision process is a valid task. It is scientifically grounded in the principles of NMR spectroscopy, well-posed with a clear objective and sufficient data, and structured as a solvable computational problem. All provided information is self-contained and consistent, enabling a direct implementation.\n\nThe solution involves translating the chemical principles of HMBC spectroscopy into a computational model based on graph theory. A molecule is represented as an undirected graph $G=(V,E)$, where the set of nodes $V$ represents the atoms and the set of edges $E$ represents the chemical bonds. Each node $v \\in V$ is typed as either carbon ($\\mathrm{C}$) or hydrogen ($\\mathrm{H}$). The bonds are weighted by their order (single, double), which is captured in a weighted adjacency matrix $B$, where an element $b_{ij}$ can be $0$, $1$, or $2$.\n\nThe core of the problem is to determine, for a set of \"observed\" proton-carbon pairs $(h, c)$, whether their observation is consistent with the provided HMBC detectability model. The result for a given molecular structure and set of observed pairs is $\\mathrm{True}$ if and only if every pair in the set is validated by the model.\n\nA pair $(h, c)$ is deemed \"accepted\" if there exists at least one simple path $P$ between the corresponding nodes in the graph that satisfies a set of conditions based on its length $d$ (number of bonds) and its total bond-order sum $s(P) = \\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$. A simple path is one that does not repeat any nodes.\n\nThe algorithm for validating a single pair $(h,c)$ is as follows:\n1.  Search for all simple paths between the node for proton $h$ and the node for carbon $c$ in the molecular graph.\n2.  Given the constraints on HMBC, we are only interested in paths of length $d \\in \\{2, 3, 4\\}$. Paths with $d=1$ correspond to direct one-bond connectivities, which are explicitly suppressed by the HMBC experiment and are therefore excluded from causing an acceptance.\n3.  A recursive Depth-First Search (DFS) algorithm is an effective method for finding these paths. The search starts at node $h$ and explores neighbors, building up a path. To ensure paths are simple, a set of visited nodes is maintained. The search is pruned for paths exceeding a length of $d=4$.\n4.  For each simple path $P$ found from $h$ to $c$, we evaluate it against the decision rule:\n    -   Calculate the path length $d$ and the bond-order sum $s(P)$.\n    -   Compute the modeled cross-peak amplitude $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$, where $\\alpha$, $\\gamma$ are given parameters.\n    -   Apply the acceptance criteria:\n        -   If $d \\in \\{2,3\\}$ and $A(d,s(P)) \\ge \\tau$, the path is valid, and the pair $(h,c)$ is accepted.\n        -   If $d=4$, the path is valid only if it is part of a conjugated system (proxied by $s(P) \\ge d+1$) and its amplitude is above the threshold ($A(d,s(P)) \\ge \\tau$).\n5.  If any path from $h$ to $c$ meets these criteria, the pair is accepted. The search for that pair can be terminated. If the search completes and no such path is found, the pair is rejected.\n\nThe overall program structure involves iterating through each test case. For each case, it iterates through all specified `observed_pairs`. If any pair is rejected, the result for the test case is $\\mathrm{False}$. If all pairs are accepted, the result is $\\mathrm{True}$. The final output is a list of these boolean results. This entire procedure is deterministic and directly implements the formalized model described in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the HMBC decision rule problem.\n    \"\"\"\n\n    def check_paths_recursive(\n        current_node, target_node, bond_order_matrix, alpha, gamma, tau, \n        path, visited, current_bond_sum\n    ):\n        \"\"\"\n        Recursively explores simple paths from current_node to target_node using DFS,\n        and checks if any path satisfies the HMBC acceptance criteria.\n        \"\"\"\n        # Base case: Path reaches the target node\n        if current_node == target_node:\n            d = len(path) - 1\n            s = current_bond_sum\n\n            # Rule exclusion: d=1 paths are not considered for acceptance.\n            # Only paths with d in {2, 3, 4} are evaluated.\n            if d not in [2, 3, 4]:\n                return False\n\n            # Calculate amplitude\n            amplitude = np.exp(-alpha * d) * (1 + gamma * (s - d))\n\n            # Apply acceptance rules based on path length d\n            if d in [2, 3]:\n                if amplitude = tau:\n                    return True  # Accepted\n            elif d == 4:\n                # 4-bond paths have an extra condition on bond-order sum\n                if s = d + 1 and amplitude = tau:\n                    return True  # Accepted\n            \n            return False # This path did not lead to acceptance\n\n        # Pruning: Stop if path length exceeds maximum relevant distance (d=4)\n        if len(path) - 1 = 4:\n            return False\n\n        # Recursive step: Explore neighbors\n        num_nodes = bond_order_matrix.shape[0]\n        for neighbor in range(num_nodes):\n            # Check for a bond and ensure the path remains simple (no cycles)\n            if bond_order_matrix[current_node, neighbor]  0 and neighbor not in visited:\n                path.append(neighbor)\n                visited.add(neighbor)\n                new_bond_sum = current_bond_sum + bond_order_matrix[current_node, neighbor]\n\n                if check_paths_recursive(\n                    neighbor, target_node, bond_order_matrix, alpha, gamma, tau,\n                    path, visited, new_bond_sum\n                ):\n                    return True  # An acceptable path was found down this branch\n\n                # Backtrack\n                visited.remove(neighbor)\n                path.pop()\n        \n        return False # No acceptable path found from this node\n\n    def is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n        \"\"\"\n        Checks if an observed (h, c) pair is accepted by finding at least one valid path.\n        \"\"\"\n        path = [h_idx]\n        visited = {h_idx}\n        return check_paths_recursive(\n            h_idx, c_idx, B, alpha, gamma, tau, \n            path, visited, 0\n        )\n\n    def evaluate_test_case(nodes, B, observed_pairs, alpha, gamma, tau):\n        \"\"\"\n        Evaluates a full test case. Returns True if all observed pairs are accepted.\n        \"\"\"\n        for c_idx, h_idx in observed_pairs:\n            if not is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n                return False  # If any pair is rejected, the whole case fails\n        return True # All pairs were accepted\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'H'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(2, 0), (3, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.049787\n        },\n        {\n            \"nodes\": ['H', 'C'],\n            \"B\": np.array([\n                [0, 1],\n                [1, 0]\n            ]),\n            \"observed_pairs\": [(1, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.2\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 2, 0, 0],\n                [0, 2, 0, 1, 0],\n                [0, 0, 1, 0, 2],\n                [0, 0, 0, 2, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.5,\n            \"tau\": 0.03\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = evaluate_test_case(\n            case[\"nodes\"], case[\"B\"], case[\"observed_pairs\"],\n            case[\"alpha\"], case[\"gamma\"], case[\"tau\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}