{
    "hands_on_practices": [
        {
            "introduction": "HMBC 实验的核心在于观测经由多键产生的相关信号，这些信号由微弱的远程耦合常数 ($J_{LR}$) 介导。为了最大化信号，我们需要让磁化演化一段时间。然而，在此期间信号也会因横向弛豫 ($T_2$) 而衰减。\n\n本练习旨在探究信号生成（其强度随演化时间 $\\tau$ 呈正弦函数变化）与信号衰减（随 $\\tau$ 呈指数函数衰减）之间的根本性权衡。通过推导最佳演化延迟 $\\tau^{\\star}$，您将对如何选择 HMBC 实验参数以及这些参数如何影响数据质量获得更深刻的定量理解。此练习  填合了抽象的核磁共振理论与实际实验设置之间的鸿沟。",
            "id": "3707084",
            "problem": "在异核多键相关（HMBC）实验中，通过远程碳-氢标量耦合，在质子和碳核之间实现磁化的有效转移，该过程由标量耦合哈密顿量下的相干演化所主导，并受到横向弛豫的衰减。考虑一个大小为 $J_{LR}$ 的单一主导远程碳-氢标量耦合，以及演化中的异核相干的横向弛豫时间常数 $T_2$。假设单键碳-氢耦合已被适当的滤波器元件抑制，因此转移仅受限于远程耦合和弛豫。\n\n从核磁共振中经过充分验证的事实出发：(i) 在大小为 $J$ 的标量耦合下，反相相干的建立与演化延迟 $\\tau$ 呈正弦依赖关系；(ii) 横向弛豫使横向磁化强度随时间呈指数衰减，时间常数为 $T_2$，推导出一个解析表达式，用于计算使远程转移效率最大化的演化延迟 $\\tau^{\\star}$。然后，对于 $J_{LR} = 8.0 \\ \\mathrm{Hz}$ 和 $T_2 = 0.180 \\ \\mathrm{s}$，计算最佳延迟。请以毫秒为单位表示您的最终数值答案，并四舍五入到 $4$ 位有效数字。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于核磁共振（NMR）谱学的原理，特别是关于异核多键相关（HMBC）实验中异核相干的动力学。该问题提法恰当、客观，并包含推导唯一且有意义的解所需的所有信息。\n\n目标是找到使磁化转移效率最大化的最佳演化延迟 $\\tau^{\\star}$。这个效率，我们记为 $\\eta(\\tau)$，由两个相互竞争的过程决定：标量耦合下反相磁化的相干演化和由横向弛豫引起的非相干衰减。\n\n根据问题陈述中的事实（i），在标量耦合 $J_{LR}$ 下，同相相干在持续时间 $\\tau$ 内产生反相相干遵循正弦依赖关系。在乘积算符形式体系的背景下，这种依赖关系可以精确地由一个与 $\\sin(\\pi J_{LR} \\tau)$ 成正比的项来描述。该项的最大值出现在其参数为 $\\frac{\\pi}{2}$ 的奇数倍时，但这种理想情况会因弛豫而改变。\n\n根据事实（ii），信号同时被横向弛豫衰减，这是一个时间常数为 $T_2$ 的指数衰减过程。这在转移效率的表达式中引入了一个因子 $\\exp(-\\frac{\\tau}{T_2})$。\n\n结合这两种效应，在给定的演化时间 $\\tau$ 下的转移效率 $\\eta(\\tau)$ 可以被建模为与建立函数和衰减函数的乘积成正比。我们可以将此关系写为：\n$$\n\\eta(\\tau) = C \\sin(\\pi J_{LR} \\tau) \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\n其中 $C$ 是一个正常数比例常数，它取决于旋磁比和初始极化等因素，但与 $\\tau$ 无关。我们感兴趣的是在 $\\tau > 0$ 时使 $\\eta(\\tau)$ 最大化的 $\\tau$ 值。\n\n为了找到函数 $\\eta(\\tau)$ 的最大值，我们必须计算它关于 $\\tau$ 的一阶导数并将其设为零。\n$$\n\\frac{d\\eta}{d\\tau} = 0\n$$\n使用乘积求导法则，$(uv)' = u'v + uv'$，其中 $u(\\tau) = \\sin(\\pi J_{LR} \\tau)$ 和 $v(\\tau) = \\exp(-\\frac{\\tau}{T_2})$，我们有：\n$$\n\\frac{du}{d\\tau} = \\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\n$$\n$$\n\\frac{dv}{d\\tau} = -\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\n那么 $\\eta(\\tau)$ 的导数是：\n$$\n\\frac{d\\eta}{d\\tau} = C \\left[ \\left(\\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\\right) \\exp\\left(-\\frac{\\tau}{T_2}\\right) + \\sin(\\pi J_{LR} \\tau) \\left(-\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\\right) \\right]\n$$\n将导数设为零：\n$$\nC \\exp\\left(-\\frac{\\tau}{T_2}\\right) \\left[ \\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) \\right] = 0\n$$\n由于 $C > 0$ 且对于有限的 $\\tau$ 值 $\\exp(-\\frac{\\tau}{T_2})$ 永远不为零，因此方括号中的项必须为零才能出现极值。\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) = 0\n$$\n重新整理这个方程得到：\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) = \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau)\n$$\n两边同除以 $\\cos(\\pi J_{LR} \\tau)$（假设它不为零，这是有效的，因为如果它为零，右边将不为零，导致矛盾）得到：\n$$\n\\tan(\\pi J_{LR} \\tau) = \\pi J_{LR} T_2\n$$\n满足此方程的 $\\tau$ 值即为最佳延迟 $\\tau^{\\star}$。我们可以通过对两边取反正切来求解 $\\tau^{\\star}$。\n$$\n\\pi J_{LR} \\tau^{\\star} = \\arctan(\\pi J_{LR} T_2)\n$$\n反正切函数是多值的；其通解是 $\\arctan(x) + n\\pi$，其中 $n$ 为任意整数。然而，我们寻求的是使函数最大化的第一个正 $\\tau$ 值，这对应于反正切的主值（即 $n=0$ 时），因为这将对应于阻尼正弦波的第一个峰值。\n因此，最佳延迟的解析表达式为：\n$$\n\\tau^{\\star} = \\frac{1}{\\pi J_{LR}} \\arctan(\\pi J_{LR} T_2)\n$$\n现在，我们代入给定的数值：$J_{LR} = 8.0 \\ \\mathrm{Hz}$ 和 $T_2 = 0.180 \\ \\mathrm{s}$。$J_{LR}$ 的单位是 $\\mathrm{s}^{-1}$。\n首先，我们计算反正切函数的无量纲参数：\n$$\n\\pi J_{LR} T_2 = \\pi \\times (8.0 \\ \\mathrm{s}^{-1}) \\times (0.180 \\ \\mathrm{s}) \\approx 4.52389\n$$\n现在我们计算以秒为单位的最佳延迟 $\\tau^{\\star}$：\n$$\n\\tau^{\\star} = \\frac{1}{\\pi \\times 8.0 \\ \\mathrm{s}^{-1}} \\arctan(4.52389)\n$$\n反正切的值必须以弧度为单位：\n$$\n\\arctan(4.52389) \\approx 1.35306 \\ \\mathrm{rad}\n$$\n将此值代回 $\\tau^{\\star}$ 的表达式中：\n$$\n\\tau^{\\star} \\approx \\frac{1.35306}{25.13274 \\ \\mathrm{s}^{-1}} \\approx 0.053835 \\ \\mathrm{s}\n$$\n问题要求答案以毫秒为单位，并四舍五入到4位有效数字。\n$$\n\\tau^{\\star} \\approx 0.053835 \\ \\mathrm{s} \\times \\frac{1000 \\ \\mathrm{ms}}{1 \\ \\mathrm{s}} = 53.835 \\ \\mathrm{ms}\n$$\n四舍五入到4位有效数字，我们得到：\n$$\n\\tau^{\\star} = 53.84 \\ \\mathrm{ms}\n$$",
            "answer": "$$\n\\boxed{53.84}\n$$"
        },
        {
            "introduction": "采集 HMBC 谱图后，下一个关键步骤是解析相关峰，以推断分子骨架。虽然经验丰富的化学家通常凭直觉完成此任务，但对于复杂分子或自动化分析而言，系统性的方法至关重要。\n\n本练习要求您将 HMBC 的解析规则形式化为一个图论模型。您需要将分子表示为图，并定义一个精确的计算规则来判断观测到的相关信号在化学上是否合理。此练习  超越了简单的模式识别，旨在训练您将谱图解析视为一个逻辑化、算法化的过程，这项技能对于解决复杂的结构问题至关重要，也是现代化学信息学的基石。",
            "id": "3707090",
            "problem": "您的任务是将异核多键相关（HMBC）连接性形式化为一个适合算法实现的图论决策过程。HMBC 通过化学键通路检测氢核与碳核之间的远程耦合。在图论形式化中，一个分子被表示为一个无向标记图，其中节点代表原子，边代表化学键。\n\n从以下基本依据开始：\n- HMBC 主要检测通过 $2$ 或 $3$ 个化学键路径的质子-碳连接，对于 $4$-键路径，其可检测性显著降低，但可能因共轭效应而增强。直接的单键质子-碳连接（$d=1$）被 HMBC 脉冲序列设计所排除。\n- 根据经验，远程标量自旋-自旋耦合的强度会随着中间化学键数量的增加而减小，并且会受到路径上键级和共轭效应的调制。\n\n定义图模型如下：\n- 令 $G=(V,E)$ 为一个无向图。每个节点 $v \\in V$ 都由集合 $\\{\\mathrm{C},\\mathrm{H}\\}$ 中的一种原子类型标记。分别定义碳节点和氢节点的子集 $C \\subset V$ 和 $H \\subset V$。\n- 令 $B$ 为一个维度为 $|V| \\times |V|$ 的加权邻接矩阵，其元素 $b_{ij} \\in \\{0,1,2\\}$ 等于节点 $i$ 和 $j$ 之间的键级，若无化学键则 $b_{ij}=0$。相应的无权邻接矩阵 $A$ 在 $b_{ij}>0$ 时有 $a_{ij}=1$，否则 $a_{ij}=0$。\n- 从氢节点 $h \\in H$ 到碳节点 $c \\in C$ 的一条简单路径 $P$ 是一个由不同节点组成的有序序列 $(v_0=h,v_1,\\dots,v_d=c)$，满足对于 $k=0,\\dots,d-1$ 有 $a_{v_{k}v_{k+1}}=1$。路径的键长为 $d$，沿路径的键级和为 $s(P)=\\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$。\n\n为了构建与基本事实一致的决策规则，对给定长度为 $d$、键级和为 $s(P)$ 的路径 $P$ 采用以下可检测性模型：\n- 表观交叉峰幅度建模为 $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$，其中 $\\alpha>0$ 和 $\\gamma \\ge 0$ 分别是编码每键衰减和共轭增强的参数， $s$ 是路径键级和。该模型捕捉了可检测性随 $d$ 增加而降低，以及对于总键级相对于步数更高的路径，其可检测性增强的特点。\n- 将一个 HMBC 决策阈值 $\\tau>0$ 应用于 $A(d,s)$。\n\n当且仅当存在一条从 $h$到 $c$ 的简单路径 $P$ 满足以下所有条件时，氢-碳对 $(h,c)$ 被接受为 HMBC 相关：\n1. $d \\in \\{2,3\\}$ 且 $A(d,s(P)) \\ge \\tau$，或 $d=4$，$s(P) \\ge d+1$ 且 $A(d,s(P)) \\ge \\tau$。\n2. 无论 $A(d,s)$ 为何值，直接的单键情况 $d=1$ 都被排除。\n\n您必须实现一个程序，对每个测试用例，根据上述规则评估所有观测到的氢-碳对。对于每一对，考虑所有长度为 $d \\in \\{2,3,4\\}$ 的简单路径；若要接受，只要至少有一条路径满足条件即可。如果该对是直接成键的（$d=1$），则必须拒绝。每个测试用例的结果是一个布尔值：如果所有观测对都被接受，则为 $\\,\\mathrm{True}\\,$，否则为 $\\,\\mathrm{False}\\,$。\n\n每个测试用例的输入表示如下：\n- 一个长度为 $n$ 的节点列表，以字符串 $\\mathrm{\"C\"}$ 或 $\\mathrm{\"H\"}$ 给出索引 $0$到 $n-1$ 的原子类型。\n- 一个形状为 $n \\times n$ 的键级邻接矩阵 $B$，其整数元素在 $\\{0,1,2\\}$ 中，对称且对角线元素为零。\n- 一个观测对列表，形式为有序元组 $(c\\_\\mathrm{index}, h\\_\\mathrm{index})$，其中 $c\\_\\mathrm{index} \\in C$，$h\\_\\mathrm{index} \\in H$。\n- 标量 $\\alpha$，$\\gamma$ 和 $\\tau$。\n\n您的程序必须实现决策规则并评估以下测试套件。索引是基于零的，所有化学键都是无向的：\n\n测试用例 1（正常路径，边界为阈值相等）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{H}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$。\n- 键（列出的位置 $b_{ij}=1$）：$(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$；所有其他 $b_{ij}=0$。\n- 观测对：$[(2,0),(3,0)]$。\n- 参数：$\\alpha=1$, $\\gamma=0$, $\\tau=0.049787$（约等于 $\\exp(-3)$）。\n- 预期：$(2,0)$ 有一条长度为 $d=2$ 的路径，其 $A(2,s)\\approx \\exp(-2)$；$(3,0)$ 有一条长度为 $d=3$ 的路径，其 $A(3,s)\\approx \\exp(-3)$；在相等时接受的规则适用。\n\n测试用例 2（明确排除 HMBC 的单键连接）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C}\\,]$，对应索引 $[\\,0,1\\,]$。\n- 键：$(0,1)$，其 $b_{01}=1$。\n- 观测对：$[(1,0)]$。\n- 参数：$\\alpha=1$, $\\gamma=0$, $\\tau=0.2$。\n- 预期：只存在一条 $d=1$ 的直接路径；拒绝。\n\n测试用例 3（四键共轭路径被接受）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$，即 $(\\mathrm{H}_4,\\mathrm{C}_4,\\mathrm{C}_3,\\mathrm{C}_2,\\mathrm{C}_1)$。\n- 键：$(0,1)$ 键级为 $b=1$，$(1,2)$ 键级为 $b=2$，$(2,3)$ 键级为 $b=1$，$(3,4)$ 键级为 $b=2$；所有其他 $b_{ij}=0$。\n- 观测对：$[(4,0)]$。\n- 参数：$\\alpha=1$, $\\gamma=0.5$, $\\tau=0.03$。\n- 预期：存在一条路径，其 $d=4$ 且 $s=6$，得出 $A(4,6)=\\exp(-4)\\,\\bigl(1+0.5\\,(6-4)\\bigr)=\\exp(-4)\\cdot 2$，高于阈值；$s\\ge d+1$ 成立，因此接受。\n\n测试用例 4（四键非共轭路径被拒绝）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$。\n- 键：$(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$ 键级均为 $b=1$；所有其他 $b_{ij}=0$。\n- 观测对：$[(4,0)]$。\n- 参数：$\\alpha=1$, $\\gamma=0$, $\\tau=0.02$。\n- 预期：唯一的路径有 $d=4$ 和 $s=4$；$A(4,4)=\\exp(-4)$ 低于阈值，且 $s<d+1$。因此被拒绝。",
            "solution": "将异核多键相关（HMBC）连接性形式化为图论决策过程是一个有效任务。它在科学上基于核磁共振波谱学（NMR）的原理，问题陈述清晰，目标明确，数据充分，并且被构建为一个可解的计算问题。所有提供的信息都是自洽和一致的，可以直接实现。\n\n解决方案涉及将 HMBC 波谱学的化学原理转化为基于图论的计算模型。一个分子被表示为一个无向图 $G=(V,E)$，其中节点集 $V$ 代表原子，边集 $E$ 代表化学键。每个节点 $v \\in V$ 的类型为碳（$\\mathrm{C}$）或氢（$\\mathrm{H}$）。化学键按其键级（单键、双键）加权，这被记录在一个加权邻接矩阵 $B$ 中，其中元素 $b_{ij}$ 可以是 $0$、$1$ 或 $2$。\n\n问题的核心是，对于一组“观测到”的质子-碳对 $(h, c)$，判断它们的观测结果是否与所提供的 HMBC 可检测性模型一致。对于给定的分子结构和观测对集合，当且仅当集合中的每一对都通过模型验证时，结果为 $\\mathrm{True}$。\n\n如果图中对应节点之间存在至少一条简单路径 $P$，该路径满足一组基于其长度 $d$（键数）和总键级和 $s(P) = \\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$ 的条件，则该对 $(h, c)$ 被视为“接受”。简单路径是指不重复任何节点的路径。\n\n验证单个对 $(h,c)$ 的算法如下：\n1. 在分子图中搜索质子 $h$ 节点和碳 $c$ 节点之间的所有简单路径。\n2. 考虑到 HMBC 的限制，我们只对长度 $d \\in \\{2, 3, 4\\}$ 的路径感兴趣。长度为 $d=1$ 的路径对应于直接的单键连接，这种连接被 HMBC 实验明确抑制，因此被排除在导致接受的原因之外。\n3. 递归的深度优先搜索（DFS）算法是寻找这些路径的有效方法。搜索从节点 $h$ 开始，探索邻居节点以构建路径。为确保路径是简单的，需要维护一个已访问节点的集合。当路径长度超过 $d=4$ 时，搜索将被剪枝。\n4. 对于从 $h$到 $c$ 找到的每条简单路径 $P$，我们根据决策规则对其进行评估：\n    - 计算路径长度 $d$ 和键级和 $s(P)$。\n    - 计算模型化的交叉峰幅度 $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$，其中 $\\alpha$、$\\gamma$ 是给定参数。\n    - 应用接受标准：\n        - 如果 $d \\in \\{2,3\\}$ 且 $A(d,s(P)) \\ge \\tau$，则路径有效，对 $(h,c)$ 被接受。\n        - 如果 $d=4$，则路径仅在它是共轭体系的一部分（由 $s(P) \\ge d+1$ 代表）且其幅度高于阈值（$A(d,s(P)) \\ge \\tau$）时才有效。\n5. 如果从 $h$ 到 $c$ 的任何路径满足这些标准，则该对被接受。对该对的搜索可以终止。如果搜索完成且未找到此类路径，则该对被拒绝。\n\n整体程序结构涉及遍历每个测试用例。对于每个用例，它遍历所有指定的 `observed_pairs`。如果任何一对被拒绝，该测试用例的结果为 $\\mathrm{False}$。如果所有对都被接受，结果为 $\\mathrm{True}$。最终输出是这些布尔结果的列表。整个过程是确定性的，并直接实现了问题陈述中形式化的模型。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the HMBC decision rule problem.\n    \"\"\"\n\n    def check_paths_recursive(\n        current_node, target_node, bond_order_matrix, alpha, gamma, tau, \n        path, visited, current_bond_sum\n    ):\n        \"\"\"\n        Recursively explores simple paths from current_node to target_node using DFS,\n        and checks if any path satisfies the HMBC acceptance criteria.\n        \"\"\"\n        # Base case: Path reaches the target node\n        if current_node == target_node:\n            d = len(path) - 1\n            s = current_bond_sum\n\n            # Rule exclusion: d=1 paths are not considered for acceptance.\n            # Only paths with d in {2, 3, 4} are evaluated.\n            if d not in [2, 3, 4]:\n                return False\n\n            # Calculate amplitude\n            amplitude = np.exp(-alpha * d) * (1 + gamma * (s - d))\n\n            # Apply acceptance rules based on path length d\n            if d in [2, 3]:\n                if amplitude >= tau:\n                    return True  # Accepted\n            elif d == 4:\n                # 4-bond paths have an extra condition on bond-order sum\n                if s >= d + 1 and amplitude >= tau:\n                    return True  # Accepted\n            \n            return False # This path did not lead to acceptance\n\n        # Pruning: Stop if path length exceeds maximum relevant distance (d=4)\n        if len(path) - 1 >= 4:\n            return False\n\n        # Recursive step: Explore neighbors\n        num_nodes = bond_order_matrix.shape[0]\n        for neighbor in range(num_nodes):\n            # Check for a bond and ensure the path remains simple (no cycles)\n            if bond_order_matrix[current_node, neighbor] > 0 and neighbor not in visited:\n                path.append(neighbor)\n                visited.add(neighbor)\n                new_bond_sum = current_bond_sum + bond_order_matrix[current_node, neighbor]\n\n                if check_paths_recursive(\n                    neighbor, target_node, bond_order_matrix, alpha, gamma, tau,\n                    path, visited, new_bond_sum\n                ):\n                    return True  # An acceptable path was found down this branch\n\n                # Backtrack\n                visited.remove(neighbor)\n                path.pop()\n        \n        return False # No acceptable path found from this node\n\n    def is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n        \"\"\"\n        Checks if an observed (h, c) pair is accepted by finding at least one valid path.\n        \"\"\"\n        path = [h_idx]\n        visited = {h_idx}\n        return check_paths_recursive(\n            h_idx, c_idx, B, alpha, gamma, tau, \n            path, visited, 0\n        )\n\n    def evaluate_test_case(nodes, B, observed_pairs, alpha, gamma, tau):\n        \"\"\"\n        Evaluates a full test case. Returns True if all observed pairs are accepted.\n        \"\"\"\n        for c_idx, h_idx in observed_pairs:\n            if not is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n                return False  # If any pair is rejected, the whole case fails\n        return True # All pairs were accepted\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'H'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(2, 0), (3, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.049787\n        },\n        {\n            \"nodes\": ['H', 'C'],\n            \"B\": np.array([\n                [0, 1],\n                [1, 0]\n            ]),\n            \"observed_pairs\": [(1, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.2\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 2, 0, 0],\n                [0, 2, 0, 1, 0],\n                [0, 0, 1, 0, 2],\n                [0, 0, 0, 2, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.5,\n            \"tau\": 0.03\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = evaluate_test_case(\n            case[\"nodes\"], case[\"B\"], case[\"observed_pairs\"],\n            case[\"alpha\"], case[\"gamma\"], case[\"tau\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}