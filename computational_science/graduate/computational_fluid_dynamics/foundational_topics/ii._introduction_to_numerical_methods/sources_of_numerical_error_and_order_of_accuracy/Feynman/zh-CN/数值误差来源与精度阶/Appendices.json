{
    "hands_on_practices": [
        {
            "introduction": "分析数值误差的基础是理解离散公式如何逼近连续导数。本练习将引导你回归第一性原理，使用泰勒级数展开来构建一个高阶单边差分格式，并精确计算其截断误差。通过这个过程，你将为理解和量化截断误差奠定坚实的理论基础。",
            "id": "3364228",
            "problem": "考虑一个光滑标量场 $u(x)$，它表示在左边界 $x=x_{0}$ 处实体壁附近的一维不可压缩流中的一个速度分量。空间网格是均匀的，间距为 $h>0$，网格点为 $x_{j}=x_{0}+j h$，其中 $j=0,1,2,3$。从第一性原理出发，使用关于 $x=x_{0}$ 的带余项的 Taylor 定理，推导一个仅使用节点值 $u(x_{0}),u(x_{1}),u(x_{2}),u(x_{3})$ 的三阶单侧线性有限差分近似来逼近一阶导数 $u^{\\prime}(x_{0})$。建立并求解保证展开式对最高3次多项式精确的阶数条件，并明确说明为证明你的截断误差分析所需的关于 $u$ 的边界正则性假设。\n\n然后，使用你推导的差分格式和 Taylor 展开，计算该近似的主阶截断误差项，表示为 $h^{3} u^{(4)}(x_{0})$ 的倍数。你的最终答案必须是等于主阶截断误差项的单个闭式解析表达式。不需要进行数值四舍五入，最终答案中不应包含任何单位。",
            "solution": "该问题要求使用四个点 $u(x_{0})$, $u(x_{1})$, $u(x_{2})$, 和 $u(x_{3})$ 的函数值，推导一阶导数 $u'(x_{0})$ 的一个单侧三阶精度有限差分近似。网格是均匀的，间距为 $h$，因此 $x_{j} = x_{0} + j h$，其中 $j=0, 1, 2, 3$。根据要求，推导将通过使用 Taylor 定理的待定系数法进行。之后将进行截断误差分析。\n\n首先，我们提出一个如下形式的线性近似：\n$$\nu'(x_{0}) \\approx D_{h}[u](x_0) = c_{0} u(x_{0}) + c_{1} u(x_{1}) + c_{2} u(x_{2}) + c_{3} u(x_{3})\n$$\n其中 $c_{0}$、$c_{1}$、$c_{2}$ 和 $c_{3}$ 是待定系数。\n\n该方法的核心是将每个函数值 $u(x_{j})$ 在点 $x_{0}$ 处展开为 Taylor 级数。为了进行此分析，我们必须假设函数 $u(x)$ 足够光滑。所需的光滑性或正则性，将由近似的阶数决定。为了推导一个截断误差为 $O(h^{3})$ 阶的格式，我们必须将 Taylor 展开进行到 $h^{4}$ 阶项，以捕捉主误差项。这要求 $u(x)$ 在区间 $[x_{0}, x_{3}]$ 上至少是四次连续可微的。我们将其表述为边界正则性假设：$u \\in C^{4}([x_{0}, x_{3}])$。\n\n$u(x_{j})$ 关于 $x_{0}$ 的 Taylor 展开式为：\n$$\nu(x_{1}) = u(x_{0}+h) = u(x_{0}) + h u'(x_{0}) + \\frac{h^{2}}{2} u''(x_{0}) + \\frac{h^{3}}{6} u'''(x_{0}) + \\frac{h^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n$$\nu(x_{2}) = u(x_{0}+2h) = u(x_{0}) + (2h) u'(x_{0}) + \\frac{(2h)^{2}}{2} u''(x_{0}) + \\frac{(2h)^{3}}{6} u'''(x_{0}) + \\frac{(2h)^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n$$\nu(x_{3}) = u(x_{0}+3h) = u(x_{0}) + (3h) u'(x_{0}) + \\frac{(3h)^{2}}{2} u''(x_{0}) + \\frac{(3h)^{3}}{6} u'''(x_{0}) + \\frac{(3h)^{4}}{24} u^{(4)}(x_{0}) + O(h^{5})\n$$\n\n将这些展开式代入 $D_{h}[u](x_0)$ 的公式，并按 $u$ 在 $x_{0}$ 处的导数项进行分组：\n\\begin{align*}\nD_{h}[u](x_0) = c_{0} u(x_{0}) + c_{1} \\left( u(x_{0}) + h u'(x_{0}) + \\dots \\right) + c_{2} \\left( u(x_{0}) + 2h u'(x_{0}) + \\dots \\right) + c_{3} \\left( u(x_{0}) + 3h u'(x_{0}) + \\dots \\right) \\\\\n= (c_{0} + c_{1} + c_{2} + c_{3}) u(x_{0}) \\\\\n\\quad + h (c_{1} + 2c_{2} + 3c_{3}) u'(x_{0}) \\\\\n\\quad + \\frac{h^{2}}{2} (c_{1} + 4c_{2} + 9c_{3}) u''(x_{0}) \\\\\n\\quad + \\frac{h^{3}}{6} (c_{1} + 8c_{2} + 27c_{3}) u'''(x_{0}) \\\\\n\\quad + \\frac{h^{4}}{24} (c_{1} + 16c_{2} + 81c_{3}) u^{(4)}(x_{0}) + O(h^{5})\n\\end{align*}\n\n为了使该表达式成为 $u'(x_{0})$ 的一个误差为 $O(h^{3})$ 阶的近似，我们必须使右侧导数项的系数与 $u'(x_{0})$ 本身的系数相匹配。这意味着 $u'(x_{0})$ 的系数必须为 $1$，而 $u(x_{0})$、$u''(x_{0})$ 和 $u'''(x_{0})$ 的系数必须为 $0$。这确保了该格式对于最高3次的多项式是精确的，正如所要求的那样。这些是阶数条件：\n\\begin{enumerate}\n    \\item $u(x_{0})$ 的系数：$c_{0} + c_{1} + c_{2} + c_{3} = 0$\n    \\item $u'(x_{0})$ 的系数：$h(c_{1} + 2c_{2} + 3c_{3}) = 1 \\implies c_{1} + 2c_{2} + 3c_{3} = \\frac{1}{h}$\n    \\item $u''(x_{0})$ 的系数：$\\frac{h^{2}}{2}(c_{1} + 4c_{2} + 9c_{3}) = 0 \\implies c_{1} + 4c_{2} + 9c_{3} = 0$\n    \\item $u'''(x_{0})$ 的系数：$\\frac{h^{3}}{6}(c_{1} + 8c_{2} + 27c_{3}) = 0 \\implies c_{1} + 8c_{2} + 27c_{3} = 0$\n\\end{enumerate}\n\n我们现在求解这个关于四个系数的四元线性方程组。让我们首先求解关于 $c_{1}, c_{2}, c_{3}$ 的子系统（方程2, 3, 4）。\n方程(4)减去方程(3)得到：\n$(c_{1} + 8c_{2} + 27c_{3}) - (c_{1} + 4c_{2} + 9c_{3}) = 0 - 0 \\implies 4c_{2} + 18c_{3} = 0$，化简为 $2c_{2} + 9c_{3} = 0$。\n\n方程(3)减去方程(2)得到：\n$(c_{1} + 4c_{2} + 9c_{3}) - (c_{1} + 2c_{2} + 3c_{3}) = 0 - \\frac{1}{h} \\implies 2c_{2} + 6c_{3} = -\\frac{1}{h}$。\n\n我们现在得到一个关于 $c_{2}$ 和 $c_{3}$ 的二元方程组：\n$$\n\\begin{cases}\n2c_{2} + 9c_{3} = 0 \\\\\n2c_{2} + 6c_{3} = -\\frac{1}{h}\n\\end{cases}\n$$\n这个新方程组中的第一个方程减去第二个方程得到：\n$(2c_{2} + 9c_{3}) - (2c_{2} + 6c_{3}) = 0 - (-\\frac{1}{h}) \\implies 3c_{3} = \\frac{1}{h} \\implies c_{3} = \\frac{1}{3h}$。\n\n将 $c_{3}$ 代回 $2c_{2} + 9c_{3} = 0$：\n$2c_{2} + 9(\\frac{1}{3h}) = 0 \\implies 2c_{2} + \\frac{3}{h} = 0 \\implies c_{2} = -\\frac{3}{2h}$。\n\n将 $c_{2}$ 和 $c_{3}$ 代入方程(3)：\n$c_{1} + 4(-\\frac{3}{2h}) + 9(\\frac{1}{3h}) = 0 \\implies c_{1} - \\frac{6}{h} + \\frac{3}{h} = 0 \\implies c_{1} = \\frac{3}{h}$。\n\n最后，使用方程(1)求 $c_{0}$：\n$c_{0} + \\frac{3}{h} - \\frac{3}{2h} + \\frac{1}{3h} = 0 \\implies c_{0} = -\\frac{3}{h} + \\frac{3}{2h} - \\frac{1}{3h} = \\frac{-18+9-2}{6h} = -\\frac{11}{6h}$。\n\n有限差分近似的系数为：\n$c_{0} = -\\frac{11}{6h}$, $c_{1} = \\frac{3}{h} = \\frac{18}{6h}$, $c_{2} = -\\frac{3}{2h} = -\\frac{9}{6h}$, $c_{3} = \\frac{1}{3h} = \\frac{2}{6h}$。\n\n得到的三阶单侧有限差分公式为：\n$$\nD_{h}[u](x_0) = \\frac{-11 u(x_{0}) + 18 u(x_{1}) - 9 u(x_{2}) + 2 u(x_{3})}{6h}\n$$\n\n截断误差 $T$ 定义为近似值与真实导数之差，即 $T = D_{h}[u](x_0) - u'(x_{0})$。该误差的主阶项来自于 $D_{h}[u](x_0)$ 的 Taylor 展开式中 $u'(x_{0})$ 项之后的第一个非零项。这就是包含 $u^{(4)}(x_{0})$ 的项。\n$$\nT = \\frac{h^{4}}{24} (c_{1} + 16c_{2} + 81c_{3}) u^{(4)}(x_{0}) + O(h^{5})\n$$\n我们将系数的值代入表达式 $c_{1} + 16c_{2} + 81c_{3}$ 中：\n$$\nc_{1} + 16c_{2} + 81c_{3} = \\frac{3}{h} + 16\\left(-\\frac{3}{2h}\\right) + 81\\left(\\frac{1}{3h}\\right) = \\frac{3}{h} - \\frac{48}{2h} + \\frac{81}{3h} = \\frac{3}{h} - \\frac{24}{h} + \\frac{27}{h} = \\frac{3-24+27}{h} = \\frac{6}{h}\n$$\n现在，将此结果代回截断误差的表达式中：\n$$\nT = \\frac{h^{4}}{24} \\left(\\frac{6}{h}\\right) u^{(4)}(x_{0}) + O(h^{4}) = \\frac{6h^{3}}{24} u^{(4)}(x_{0}) + O(h^{4}) = \\frac{1}{4}h^{3} u^{(4)}(x_{0}) + O(h^{4})\n$$\n因此，主阶截断误差项为 $\\frac{1}{4}h^{3} u^{(4)}(x_{0})$。\n这证实了该格式的精度阶数为 $3$，因为误差与 $h^3$ 成正比。",
            "answer": "$$\\boxed{\\frac{1}{4} h^{3} u^{(4)}(x_{0})}$$"
        },
        {
            "introduction": "在掌握了截断误差的理论之后，我们必须面对计算机算术的现实。本练习将展示，在代数上完全等价的公式，在浮点数环境下可能由于灾难性对消（catastrophic cancellation）而产生截然不同的精度。这为编写稳健的数值代码提供了至关重要的实践教训。",
            "id": "3364188",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，其空间坐标 $x \\in [0,L)$ 以弧度为单位，以及一个光滑标量场 $u(x)$。在守恒型双曲定律的背景下，通量 $F(u)$ 的空间导数表现为 $dF(u)/dx$。本题的目标是研究，当同一个离散通量梯度算子通过解析上恒等但代数上不同的重排方式进行计算时，浮点舍入误差如何与截断误差相互作用，并量化在网格加密过程中每种重排方式所观测到的精度阶。\n\n从以下基本概念出发：\n- 守恒定律的形式为 $\\partial u/\\partial t + \\partial F(u)/\\partial x = 0$，其中 $F(u)$ 是一个光滑通量函数。\n- 对于光滑场 $u(x)$，通量 $F(u)$ 的空间导数为 $dF(u)/dx$。当 $F(u)=u^2/2$ 时，有 $dF(u)/dx = u \\, du/dx$。\n- 在一个有 $N$ 个点、间距为 $\\Delta x = L/N$ 的周期性网格上，中心差分算子使用 $x_{i-1}$ 和 $x_{i+1}$ 处的相邻值来近似 $x_i$ 处的空间导数。\n\n您必须在周期性边界条件下，为网格点 $x_i$ 上的通量 $F(u) = u^2/2$ 实现同一个中心离散通量梯度算子的三种计算重排。其中两种重排在精确算术中必须与通量值的中心差分代数恒等，但它们的运算顺序不同。第三种重排仍计算相同的离散算子，但使用一种数值补偿方法来构建所需的成对求和与求差。您的程序必须：\n1. 对指定的 $(U_0,\\varepsilon,k)$ 值，使用测试函数 $u(x) = U_0 + \\varepsilon \\sin(k x)$，其中角度 $x$ 以弧度为单位。\n2. 对于加密序列中的每个网格尺寸 $N$，构建网格，计算 $u(x)$ 的值，计算同一个离散中心通量梯度算子的三种重排形式，并使用对 $u(x)$ 的解析微分来计算精确导数 $dF(u)/dx = u \\cdot du/dx$。\n3. 对于每种重排和每个网格尺寸 $N$，计算由下式定义的离散 $L^2$ 误差\n$$\nE(N) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( D_i - \\frac{dF(u)}{dx}(x_i) \\right)^2 \\right)^{1/2},\n$$\n其中 $D_i$ 是在索引 $i$ 处由重排计算出的近似值，且 $\\Delta x = L/N$。\n4. 使用测试套件中的所有加密级别，通过对 $\\log(E(N))$ 与 $\\log(\\Delta x)$ 进行最小二乘拟合，来估计每种重排的测量精度阶 $\\alpha$；也就是说，拟合 $\\log(E) \\approx \\alpha \\log(\\Delta x) + C$ 并报告 $\\alpha$。\n5. 将所有测试用例的结果汇总到单行输出中，该行包含每个测试用例中三种重排的测量精度阶。\n\n测试套件：\n- 域长度：$L = 2\\pi$ (弧度)。\n- 加密序列：$N \\in \\{64,128,256,512,1024,2048,4096,8192,16384,32768\\}$。\n- 四个 $(U_0,\\varepsilon,k)$ 的测试用例：\n  - 用例 1 (理想情况): $(0.0, 1.0, 3)$。\n  - 用例 2 (中度相消): $(1.0, 10^{-2}, 3)$。\n  - 用例 3 (严重相消): $(1.0, 10^{-12}, 3)$。\n  - 用例 4 (高频): $(1.0, 10^{-2}, 500)$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起的逗号分隔列表。\n- 外层列表必须每个测试用例包含一个元素，每个元素必须是一个包含三个浮点数的列表，对应于您所实现的固定计算顺序下三种重排的测量精度阶。\n- 例如，输出格式应类似于\n$$\n[\\,[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3]\\,],\n$$\n打印为无空格的单行。\n\n所有角度量必须以弧度处理。本问题中除弧度外不出现其他物理单位，无需进行单位转换。最终输出必须是浮点数。程序必须是完整的，无需用户输入即可运行，并且必须遵守指定的执行环境。",
            "solution": "用户提供的问题已经过分析和验证。这是一个在计算流体动力学和数值分析领域中适定且科学合理的问题。任务是研究浮点运算对一个有限差分算子的不同但代数等价的公式的精度的影响。\n\n问题围绕着在一维周期性域上计算通量函数 $F(u)=\\frac{u^2}{2}$ 的空间导数 $\\frac{dF(u)}{dx}$。其解析导数由链式法则给出：$\\frac{dF}{dx} = \\frac{dF}{du}\\frac{du}{dx} = u \\frac{du}{dx}$。我们需要使用应用于间距为 $\\Delta x$ 的网格上的离散场 $u_i = u(x_i)$ 的二阶中心差分格式来近似这个导数。在网格点 $x_i$ 处，通量 $F_i = F(u_i)$ 的标准中心差分为：\n$$\nD_i = \\frac{F_{i+1} - F_{i-1}}{2\\Delta x}\n$$\n其中索引 $i-1$ 和 $i+1$ 指的是相邻的网格点，通过周期性边界条件处理。代入 $F(u) = u^2/2$，我们得到离散算子：\n$$\nD_i = \\frac{u_{i+1}^2/2 - u_{i-1}^2/2}{2\\Delta x} = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}\n$$\n这个问题要求实现并比较这个单一离散算子的三种不同计算重排。在精确算术中，这三者必须完全相同。然而，由于浮点运算的特性，它们的数值行为会有所不同，尤其是在处理相近数相减（灾难性相消）时。\n\n所选择的三种重排是：\n1.  **直接通量差分 (R1)**: 这是对公式最直接的计算方式，计算为 $D_i = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}$。当 $u$ 包含一个大的常数分量 $U_0$ 和一个小的扰动 $\\varepsilon$，使得 $u \\approx U_0$ 时，$u_{i+1}^2$ 和 $u_{i-1}^2$ 都是接近 $U_0^2$ 的大数。它们的相减可能导致相对精度的显著损失，这种效应被称为灾难性相消。\n\n2.  **乘积形式 (R2)**: 这种形式利用了代数恒等式 $a^2-b^2 = (a+b)(a-b)$。算子计算为 $D_i = \\frac{(u_{i+1} - u_{i-1})(u_{i+1} + u_{i-1})}{4\\Delta x}$。在存在大的平均值时，这种重排在数值上优于 R1。首先计算小的差值 $u_{i+1} - u_{i-1}$，这保留了 $u$ 的小尺度变化的精度。然后将这个小差值乘以良态的和 $u_{i+1} + u_{i-1}$。\n\n3.  **补偿形式 (R3)**: 该方法利用了测试函数 $u(x) = U_0 + \\varepsilon\\sin(kx)$ 中已知的常数部分 $U_0$。我们定义一个扰动场 $v(x) = u(x) - U_0$。通量差 $F_{i+1} - F_{i-1}$ 被解析展开然后计算：\n    $$\n    F_{i+1} - F_{i-1} = \\frac{(U_0+v_{i+1})^2}{2} - \\frac{(U_0+v_{i-1})^2}{2} = U_0(v_{i+1}-v_{i-1}) + \\frac{v_{i+1}^2 - v_{i-1}^2}{2}\n    $$\n    这个表达式与原始形式代数等价，但其计算方式是首先从 $u_i$ 中剥离大的常数部分 $U_0$ 得到 $v_i$。然后所有的算术运算都在这些更小、条件数更好的数上执行。项 $\\frac{v_{i+1}^2 - v_{i-1}^2}{2}$ 也使用其乘积形式 $\\frac{(v_{i+1}-v_{i-1})(v_{i+1}+v_{i-1})}{2}$ 进行计算，以获得最大的鲁棒性。这种重排预计是最准确的，尤其是在那些旨在引起严重相消误差的情况下。\n\n数值实验按以下步骤进行。对于四个测试用例 $(U_0, \\varepsilon, k)$ 中的每一个，以及指定加密序列中的每个网格分辨率 $N$，我们执行以下步骤：\n1.  为 $i=0, \\dots, N-1$ 构建周期性网格 $x_i$。\n2.  计算测试函数 $u(x_i) = U_0 + \\varepsilon\\sin(kx_i)$ 及其精确通量导数 $\\frac{dF}{dx}(x_i) = u(x_i) \\cdot (\\varepsilon k \\cos(kx_i))$。\n3.  为所有 $i$ 计算三种离散导数近似值 $D_{1,i}, D_{2,i}, D_{3,i}$。\n4.  计算每种重排相对于精确导数的离散 $L^2$ 误差 $E(N)$。\n5.  在收集所有加密级别的误差后，估计每种重排的精度阶 $\\alpha$。这是通过对误差的对数与网格间距的对数进行线性最小二乘拟合来完成的：$\\log(E) = \\alpha \\log(\\Delta x) + C$。此拟合的斜率即为测量的精度阶 $\\alpha$。\n\n二阶中心差分格式的理论精度阶为 $2$，意味着误差 $E$ 应按 $E \\propto (\\Delta x)^2$ 的比例变化。我们预计当截断误差占主导时，测量的精度阶 $\\alpha$ 会接近 $2$。然而，随着 $\\Delta x$ 减小，截断误差会缩小，最终，量级上恒定的舍入误差将变得占主导地位。这个“误差平台”会导致总误差停止减小甚至增加，从而破坏对数-对数线性关系并降低测量的精度阶 $\\alpha$。\n\n- **用例 1 ($U_0=0$)**: 所有重排在计算上是相似的。我们预计三者的 $\\alpha \\approx 2$。\n- **用例 2  3 ($U_0=1.0$，小 $\\varepsilon$)**: 由于灾难性相消，R1 预计表现不佳，产生一个很小甚至为零的 $\\alpha$。R2 和 R3 应该是鲁棒的，显示出 $\\alpha \\approx 2$。由于用例 3 中 $\\varepsilon$ 的值极小，这种效应会更加显著。\n- **用例 4 (高频 $k$)**: 截断误差与解的导数（因此也与 $k$）成比例，它将变得大得多。在 $\\Delta x$ 的整个范围内，它将主导舍入误差。因此，预计所有三种方法都将显示 $\\alpha \\approx 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 3),         # Case 1 (happy path)\n        (1.0, 1e-2, 3),        # Case 2 (moderate cancellation)\n        (1.0, 1e-12, 3),       # Case 3 (severe cancellation)\n        (1.0, 1e-2, 500),      # Case 4 (high frequency)\n    ]\n    \n    # Domain and refinement settings\n    L = 2.0 * np.pi\n    N_vals = np.array([64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768])\n\n    all_results = []\n    \n    for U0, eps, k in test_cases:\n        delta_x_vals = []\n        errors1, errors2, errors3 = [], [], []\n\n        for N in N_vals:\n            dx = L / N\n            x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n            delta_x_vals.append(dx)\n\n            # 1. Evaluate analytical fields\n            u = U0 + eps * np.sin(k * x)\n            dudx_exact = eps * k * np.cos(k * x)\n            dFdx_exact = u * dudx_exact\n\n            # Get neighbor values for central difference using periodic boundaries\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n\n            # 2. Compute the three numerical derivative rearrangements\n            # Rearrangement 1: Direct flux difference (prone to cancellation)\n            D1 = (u_p1**2 - u_m1**2) / (4.0 * dx)\n\n            # Rearrangement 2: Product of sum and difference (more robust)\n            D2 = (u_p1 - u_m1) * (u_p1 + u_m1) / (4.0 * dx)\n\n            # Rearrangement 3: Compensated form using known mean U0\n            # F(U0+v) = F(U0) + F'(U0)v + F''(U0)v^2/2 = F(U0) + U0*v + v^2/2\n            # F(i+1)-F(i-1) = U0*(v_p1-v_m1) + (v_p1^2-v_m1^2)/2\n            v_p1 = u_p1 - U0\n            v_m1 = u_m1 - U0\n            term1 = U0 * (v_p1 - v_m1)\n            term2 = (v_p1 - v_m1) * (v_p1 + v_m1) / 2.0\n            D3 = (term1 + term2) / (2.0 * dx)\n            \n            # 3. Compute L2 errors\n            err1 = np.sqrt(dx * np.sum((D1 - dFdx_exact)**2))\n            err2 = np.sqrt(dx * np.sum((D2 - dFdx_exact)**2))\n            err3 = np.sqrt(dx * np.sum((D3 - dFdx_exact)**2))\n            \n            errors1.append(err1)\n            errors2.append(err2)\n            errors3.append(err3)\n\n        # 4. Estimate order of accuracy via least-squares on log-log data\n        log_dx = np.log(np.array(delta_x_vals))\n        \n        alphas = []\n        for errors in [errors1, errors2, errors3]:\n            # Use only finite error values for the log-log fit, in case any error is zero.\n            errors_arr = np.array(errors, dtype=np.float64)\n            valid_indices = np.isfinite(errors_arr)  (errors_arr  0)\n            \n            if np.sum(valid_indices)  1:\n                log_err = np.log(errors_arr[valid_indices])\n                log_dx_fit = log_dx[valid_indices]\n                # polyfit returns [slope, intercept] for degree 1\n                alpha = np.polyfit(log_dx_fit, log_err, 1)[0]\n                alphas.append(alpha)\n            else:\n                # If fit is not possible (e.g., all errors are zero), alpha is ill-defined.\n                # A constant error results in alpha = 0.\n                alphas.append(0.0)\n                \n        all_results.append(alphas)\n\n    # Final print statement in the exact required format.\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "前面的练习分别探讨了截断误差和舍入误差。这个最终的实践将综合这两个概念，通过一个简化的模型将总误差表示为两者之和。通过最小化这个组合误差模型，我们将回答数值模拟中的一个基本问题：能够得到最精确结果的最优网格间距 $h^*$ 是什么？",
            "id": "3364197",
            "problem": "考虑以下由计算流体力学 (CFD) 中使用的经典离散化方法启发的抽象误差模型。其背景是在均匀或各向异性网格上对空间导数和椭圆算子进行数值逼近，其中总误差被建模为截断分量和舍入分量之和。您将推导并实现用于计算使这些模型的总误差最小化的网格间距的公式，然后在一个定义的测试套件上对它们进行评估。\n\nA部分（一维二阶导数算子）。令总误差作为网格间距 $h$ 的函数，其模型为\n$$\nE_{1\\mathrm{D}}(h) = C_T h^{p} + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h},\n$$\n其中 $C_T$ 和 $C_R$ 是正常数，$p$ 是截断误差的形式精度阶数，$\\epsilon_{\\mathrm{mach}}$ 是机器ε。假设浮点运算符合电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 的双精度标准，因此 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$。您必须从基本原理出发，推导使 $E_{1\\mathrm{D}}(h)$ 最小化的最优网格间距 $h^\\star$ 以及相应的最小总误差 $E_{1\\mathrm{D}}^\\star$。\n\nB部分（各向异性网格上的二维泊松算子）。考虑在具有$x$和$y$方向间距分别为 $h_x$ 和 $h_y$ 的矩形网格上，使用五点有限差分格式对二维泊松算子进行离散化。假设截断误差在每个坐标方向上以相同的形式精度阶数 $p$ 累加，得出模型\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = C_x h_x^{p} + C_y h_y^{p} + C_R \\epsilon_{\\mathrm{mach}} \\left(\\frac{1}{h_x} + \\frac{1}{h_y}\\right),\n$$\n其中 $C_x$ 和 $C_y$ 是编码各向异性截断贡献的正常数。从基本原理出发，通过机械化的微积分计算，推导使 $E_{2\\mathrm{D}}(h_x,h_y)$ 最小化的最优间距 $h_x^\\star$ 和 $h_y^\\star$ 以及相应的最小总误差 $E_{2\\mathrm{D}}^\\star$。\n\n您可以假设的基本原理。您可以假设通过有限差分的泰勒展开来定义截断误差，对于一致的离散化存在形式精度阶数 $p$，以及机器ε的定义是浮点运算中从1到下一个可表示数之间的距离。您也可以假设可微函数在导数为零处达到驻点，且驻点处的二阶导数为正意味着该点为局部最小值。\n\n交付成果。您的程序必须实现您推导出的闭式最优网格间距和最小误差，并对以下测试套件进行评估。所有量均为无量纲，不需要物理单位。\n\n测试套件。精确使用 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$。\n- 一维测试（每个案例返回一个列表 $[h^\\star, E_{1\\mathrm{D}}^\\star]$）：\n  - 案例 $\\mathrm{A1}$：$p = 2$，$C_T = 5 \\times 10^{-1}$，$C_R = 1$。\n  - 案例 $\\mathrm{A2}$：$p = 4$，$C_T = 10^{-3}$，$C_R = 5 \\times 10^{-1}$。\n- 二维测试（每个案例返回一个列表 $[h_x^\\star, h_y^\\star, E_{2\\mathrm{D}}^\\star]$）：\n  - 案例 $\\mathrm{B1}$：$p = 2$，$C_x = 1/4$，$C_y = 1/2$，$C_R = 1$。\n  - 案例 $\\mathrm{B2}$：$p = 2$，$C_x = 10^{-2}$，$C_y = 10^{2}$，$C_R = 3$。\n  - 案例 $\\mathrm{B3}$：$p = 4$，$C_x = 10^{-1}$，$C_y = 10^{-1}$，$C_R = 4/5$。\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中按上述顺序列出了所有测试案例的结果。每个测试案例的结果本身应该是一个浮点数列表，采用科学记数法，并精确到12位有效数字。例如，一个有效的整体输出形式如下\n$$\n\\big[ [\\cdots,\\cdots], [\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots] \\big]\n$$\n其中不含任何空格。五个内部列表分别对应于案例 $\\mathrm{A1}, \\mathrm{A2}, \\mathrm{B1}, \\mathrm{B2}, \\mathrm{B3}$。\n\n您的程序不得读取任何输入，也不得写入任何额外文本。它必须在内部将 $\\epsilon_{\\mathrm{mach}}$ 计算为 $2^{-52}$ 并在所有案例中一致地使用它。所有答案必须是科学记数法表示的浮点数，具有12位有效数字，并且必须完全按照规定放置。最终的单行输出必须是唯一的输出。",
            "solution": "该问题要求为两个抽象误差模型推导最优网格间距和最小误差，然后针对给定的测试套件进行数值实现。每个部分的推导都将基于使用微分学最小化总误差函数。\n\n### A部分：一维误差模型\n\n一维情况下的总误差由以下函数给出：\n$$\nE_{1\\mathrm{D}}(h) = C_T h^{p} + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h}\n$$\n其中 $h  0$ 是网格间距，$C_T$ 和 $C_R$ 是正常数，$p$ 是精度阶数，$\\epsilon_{\\mathrm{mach}}$ 是机器ε。\n\n为了找到使该误差最小化的网格间距 $h^\\star$，我们必须通过对 $h$ 求一阶导数并将其设为零来找到 $E_{1\\mathrm{D}}(h)$ 的临界点。\n$$\n\\frac{dE_{1\\mathrm{D}}}{dh} = \\frac{d}{dh} \\left( C_T h^{p} + C_R \\epsilon_{\\mathrm{mach}} h^{-1} \\right) = p C_T h^{p-1} - C_R \\epsilon_{\\mathrm{mach}} h^{-2}\n$$\n将导数设为零，得出最优间距 $h^\\star$ 的条件：\n$$\np C_T (h^\\star)^{p-1} - C_R \\frac{\\epsilon_{\\mathrm{mach}}}{(h^\\star)^2} = 0\n$$\n$$\np C_T (h^\\star)^{p-1} = \\frac{C_R \\epsilon_{\\mathrm{mach}}}{(h^\\star)^2}\n$$\n两边乘以 $(h^\\star)^2$ 并重新整理以求解 $h^\\star$：\n$$\np C_T (h^\\star)^{p+1} = C_R \\epsilon_{\\mathrm{mach}}\n$$\n$$\n(h^\\star)^{p+1} = \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T}\n$$\n这给出了最优网格间距：\n$$\nh^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T} \\right)^{\\frac{1}{p+1}}\n$$\n为确认此临界点对应于一个最小值，我们考察二阶导数：\n$$\n\\frac{d^2 E_{1\\mathrm{D}}}{dh^2} = p(p-1) C_T h^{p-2} + 2 C_R \\epsilon_{\\mathrm{mach}} h^{-3}\n$$\n鉴于 $h  0$，$C_T  0$，$C_R  0$，$\\epsilon_{\\mathrm{mach}}  0$，且精度阶数 $p \\ge 1$，两项均为非负，且第二项严格为正。因此，对于所有 $ h  0$，都有 $\\frac{d^2 E_{1\\mathrm{D}}}{dh^2}  0$，这证实了 $h^\\star$ 对应于一个局部和全局最小值。\n\n通过将 $h^\\star$ 代入原始误差函数 $E_{1\\mathrm{D}}(h)$，可以找到最小总误差 $E_{1\\mathrm{D}}^\\star$。从一阶条件 $p C_T (h^\\star)^{p+1} = C_R \\epsilon_{\\mathrm{mach}}$ 可以推导出一个更简单的表达式，这意味着 $C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h^\\star} = p C_T (h^\\star)^{p}$。将此代入 $E_{1\\mathrm{D}}(h^\\star)$ 的表达式中：\n$$\nE_{1\\mathrm{D}}^\\star = E_{1\\mathrm{D}}(h^\\star) = C_T (h^\\star)^p + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h^\\star} = C_T (h^\\star)^p + p C_T (h^\\star)^p\n$$\n$$\nE_{1\\mathrm{D}}^\\star = (p+1) C_T (h^\\star)^p\n$$\n\n### B部分：二维误差模型\n\n二维各向异性情况下的总误差为：\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = C_x h_x^{p} + C_y h_y^{p} + C_R \\epsilon_{\\mathrm{mach}} \\left(\\frac{1}{h_x} + \\frac{1}{h_y}\\right)\n$$\n其中 $h_x  0$ 且 $h_y  0$。该函数在 $h_x$ 和 $h_y$ 上是可分的。我们可以将其重写为：\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = \\left(C_x h_x^{p} + \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_x}\\right) + \\left(C_y h_y^{p} + \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_y}\\right)\n$$\n为了最小化 $E_{2\\mathrm{D}}(h_x, h_y)$，我们可以独立地最小化括号中的两项。每一项都具有与一维误差模型 $E_{1\\mathrm{D}}(h)$ 相同的函数形式。\n\n对于 $h_x$ 分量，我们将关于 $h_x$ 的偏导数设为零：\n$$\n\\frac{\\partial E_{2\\mathrm{D}}}{\\partial h_x} = p C_x h_x^{p-1} - \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_x^2} = 0\n$$\n这与一维情况类似，只是将 $C_T$ 替换为 $C_x$。最优间距 $h_x^\\star$ 的解是：\n$$\nh_x^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_x} \\right)^{\\frac{1}{p+1}}\n$$\n类似地，对于 $h_y$ 分量：\n$$\n\\frac{\\partial E_{2\\mathrm{D}}}{\\partial h_y} = p C_y h_y^{p-1} - \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_y^2} = 0\n$$\n将 $C_T$ 替换为 $C_y$ 得到最优间距 $h_y^\\star$：\n$$\nh_y^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_y} \\right)^{\\frac{1}{p+1}}\n$$\n$E_{2\\mathrm{D}}$ 的海森矩阵是对角矩阵，因为混合偏导数 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_x \\partial h_y} = 0$。对角线元素是 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_x^2}$ 和 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_y^2}$，出于与A部分相同的原因，它们都是正的。因此，海森矩阵是正定的，点 $(h_x^\\star, h_y^\\star)$ 是一个最小值点。\n\n最小总误差 $E_{2\\mathrm{D}}^\\star$ 是每个分量最小误差之和。使用从A部分得到的最小误差简化公式：\n$$\nE_{2\\mathrm{D}}^\\star = E_{2\\mathrm{D}}(h_x^\\star, h_y^\\star) = (p+1) C_x (h_x^\\star)^p + (p+1) C_y (h_y^\\star)^p\n$$\n$$\nE_{2\\mathrm{D}}^\\star = (p+1) \\left( C_x (h_x^\\star)^p + C_y (h_y^\\star)^p \\right)\n$$\n\n### 用于实现的公式总结\n使用推导出的公式来求解测试套件，其中 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$。\n\n- **A部分：**\n  - $h^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T} \\right)^{\\frac{1}{p+1}}$\n  - $E_{1\\mathrm{D}}^\\star = (p+1) C_T (h^\\star)^p$\n\n- **B部分：**\n  - $h_x^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_x} \\right)^{\\frac{1}{p+1}}$\n  - $h_y^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_y} \\right)^{\\frac{1}{p+1}}$\n  - $E_{2\\mathrm{D}}^\\star = (p+1) \\left( C_x (h_x^\\star)^p + C_y (h_y^\\star)^p \\right)$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes optimal grid spacings and minimum errors for the given test suite\n    based on the derived analytical formulas.\n    \"\"\"\n    \n    # IEEE double-precision machine epsilon\n    epsilon_mach = 2**-52\n\n    # Define the test cases from the problem statement.\n    # Format: (type, p, C_T/C_x, C_R/C_y, C_R_2D)\n    test_cases = [\n        # Case A1: 1D, p=2, C_T=0.5, C_R=1\n        ('1d', 2, 5e-1, 1, None),\n        # Case A2: 1D, p=4, C_T=1e-3, C_R=0.5\n        ('1d', 4, 1e-3, 5e-1, None),\n        # Case B1: 2D, p=2, C_x=1/4, C_y=1/2, C_R=1\n        ('2d', 2, 1/4, 1/2, 1),\n        # Case B2: 2D, p=2, C_x=1e-2, C_y=1e2, C_R=3\n        ('2d', 2, 1e-2, 1e2, 3),\n        # Case B3: 2D, p=4, C_x=1e-1, C_y=1e-1, C_R=4/5\n        ('2d', 4, 1e-1, 1e-1, 4/5),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        case_type, p, param1, param2, param3 = case\n        \n        if case_type == '1d':\n            # Unpack parameters for 1D case\n            C_T = param1\n            C_R = param2\n            \n            # Calculate optimal spacing h_star\n            h_star = (C_R * epsilon_mach / (p * C_T))**(1 / (p + 1))\n            \n            # Calculate minimum error E_star\n            E_star = (p + 1) * C_T * (h_star**p)\n            \n            all_results.append([h_star, E_star])\n            \n        elif case_type == '2d':\n            # Unpack parameters for 2D case\n            C_x = param1\n            C_y = param2\n            C_R = param3\n            \n            # Calculate optimal spacings hx_star and hy_star\n            hx_star = (C_R * epsilon_mach / (p * C_x))**(1 / (p + 1))\n            hy_star = (C_R * epsilon_mach / (p * C_y))**(1 / (p + 1))\n            \n            # Calculate minimum error E_star\n            E_star = (p + 1) * (C_x * (hx_star**p) + C_y * (hy_star**p))\n            \n            all_results.append([hx_star, hy_star, E_star])\n\n    # Format the final output string according to the specified format.\n    # Each number is in scientific notation with 12 significant digits.\n    # The output is a single line, a list of lists, with no spaces.\n    inner_strings = []\n    for res in all_results:\n        formatted_numbers = [f\"{x:.11e}\" for x in res]\n        inner_strings.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}