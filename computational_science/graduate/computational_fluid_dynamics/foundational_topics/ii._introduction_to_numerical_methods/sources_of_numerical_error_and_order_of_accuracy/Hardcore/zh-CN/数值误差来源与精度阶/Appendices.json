{
    "hands_on_practices": [
        {
            "introduction": "在理想的数学世界之外，计算机的浮点运算精度是实际计算中不可忽视的误差来源。本编码练习将理论与实践相结合，揭示了代数上等价的公式在计算机中可能产生显著不同的数值结果。通过实现和比较几种计算通量导数的方法，你将直观地观察到灾难性抵消（catastrophic cancellation）等舍入误差现象如何影响计算的稳定性和最终的精度阶数 。",
            "id": "3364188",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，其空间坐标 $x \\in [0,L)$ 以弧度为单位，以及一个光滑标量场 $u(x)$。在守恒型双曲定律的背景下，通量 $F(u)$ 的空间导数表现为 $dF(u)/dx$。本问题的目标是研究当同一个离散通量梯度算子通过解析上等价但代数重排方式不同来计算时，浮点舍入误差如何与截断误差相互作用，并量化每种重排方式在网格加密过程中的观测精度阶。\n\n从基本原理出发：\n- 守恒定律的形式为 $\\partial u/\\partial t + \\partial F(u)/\\partial x = 0$，其中 $F(u)$ 是一个光滑的通量函数。\n- 对于一个光滑场 $u(x)$，通量 $F(u)$ 的空间导数为 $dF(u)/dx$，当 $F(u)=u^2/2$ 时，有 $dF(u)/dx = u \\, du/dx$。\n- 在一个有 $N$ 个点、间距为 $\\Delta x = L/N$ 的周期性网格上，中心差分算子使用 $x_{i-1}$ 和 $x_{i+1}$ 处的相邻值来近似 $x_i$ 处的空间导数。\n\n您必须在周期性边界条件下，为网格点 $x_i$ 处的通量 $F(u) = u^2/2$ 实现同一个中心离散通量梯度算子的三种计算重排方式。其中两种重排方式在精确算术中必须与通量值的中心差分在代数上等价，但其运算顺序不同。第三种重排方式必须仍然计算同一个离散算子，但使用一种数值补偿的方式来构建所需的成对求和与求差。您的程序必须：\n1. 对于指定的 $(U_0,\\varepsilon,k)$ 值，使用测试函数 $u(x) = U_0 + \\varepsilon \\sin(k x)$，其中角度 $x$ 以弧度为单位。\n2. 对于加密序列中的每个网格尺寸 $N$，构建网格，计算 $u(x)$，计算同一个离散中心通量梯度算子的三种重排方式，并使用 $u(x)$ 的解析微分计算精确导数 $dF(u)/dx = u \\cdot du/dx$。\n3. 对于每种重排方式和每个网格尺寸 $N$，计算由下式定义的离散 $L^2$ 误差：\n$$\nE(N) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left( D_i - \\frac{dF(u)}{dx}(x_i) \\right)^2 \\right)^{1/2},\n$$\n其中 $D_i$ 是在索引 $i$ 处由重排方式得到的近似值，且 $\\Delta x = L/N$。\n4. 使用测试套件中的所有加密级别，通过对 $\\log(E(N))$ 与 $\\log(\\Delta x)$ 进行最小二乘拟合来估计每种重排方式的实测精度阶 $\\alpha$；即，拟合 $\\log(E) \\approx \\alpha \\log(\\Delta x) + C$ 并报告 $\\alpha$。\n5. 将所有测试用例的结果汇总到单行输出中，其中包含每个测试用例的三种重排方式的实测精度阶。\n\n测试套件：\n- 域长度：$L = 2\\pi$ (弧度)。\n- 加密序列：$N \\in \\{64,128,256,512,1024,2048,4096,8192,16384,32768\\}$。\n- 四个 $(U_0,\\varepsilon,k)$ 测试用例：\n  - 情况 1 (理想路径): $(0.0, 1.0, 3)$。\n  - 情况 2 (中度抵消): $(1.0, 10^{-2}, 3)$。\n  - 情况 3 (严重抵消): $(1.0, 10^{-12}, 3)$。\n  - 情况 4 (高频): $(1.0, 10^{-2}, 500)$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 外层列表必须为每个测试用例包含一个元素，每个元素必须是一个包含三个浮点数的列表，对应于您实现的三种重排方式的实测精度阶，并按固定的计算顺序排列。\n- 例如，输出格式应类似于\n$$\n[\\,[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3],[\\alpha_1,\\alpha_2,\\alpha_3]\\,],\n$$\n打印为无空格的单行。\n\n所有角度量必须以弧度处理。此问题中不出现除弧度外的其他物理单位，也不需要单位转换。最终输出必须是浮点数。程序必须是完整的，无需用户输入即可运行，并且必须遵守指定的执行环境。",
            "solution": "用户提供的问题已经过分析和验证。这是一个在计算流体动力学和数值分析领域中提法恰当且科学合理的问题。任务是研究浮点运算对有限差分算子的不同但代数上等价的公式的精度的影响。\n\n问题的核心是在一维周期域上计算通量函数 $F(u)=\\frac{u^2}{2}$ 的空间导数 $\\frac{dF(u)}{dx}$。其解析导数由链式法则给出：$\\frac{dF}{dx} = \\frac{dF}{du}\\frac{du}{dx} = u \\frac{du}{dx}$。我们需要使用应用于间距为 $\\Delta x$ 的网格上的离散场 $u_i = u(x_i)$ 的二阶中心差分格式来近似该导数。在网格点 $x_i$ 处通量 $F_i = F(u_i)$ 的标准中心差分由下式给出：\n$$\nD_i = \\frac{F_{i+1} - F_{i-1}}{2\\Delta x}\n$$\n其中索引 $i-1$ 和 $i+1$ 指的是相邻的网格点，并采用周期性边界条件处理。代入 $F(u) = u^2/2$，我们得到离散算子：\n$$\nD_i = \\frac{u_{i+1}^2/2 - u_{i-1}^2/2}{2\\Delta x} = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}\n$$\n此问题要求实现并比较此单一离散算子的三种不同计算重排方式。在精确算术中，这三者必须是等价的。然而，由于浮点运算的特性，它们的数值行为会有所不同，特别是在处理两个几乎相等的数的减法时（灾难性抵消）。\n\n选择的三种重排方式是：\n1.  **直接通量差分 (R1)**：这是对公式最直接的求值，计算方式为 $D_i = \\frac{u_{i+1}^2 - u_{i-1}^2}{4\\Delta x}$。当 $u$ 包含一个大的常数分量 $U_0$ 和一个小的扰动 $\\varepsilon$，使得 $u \\approx U_0$ 时，$u_{i+1}^2$ 和 $u_{i-1}^2$ 都是接近 $U_0^2$ 的大数。它们的相减会导致相对精度的显著损失，这种效应被称为灾难性抵消。\n\n2.  **乘积形式 (R2)**：此形式利用了代数恒等式 $a^2-b^2 = (a+b)(a-b)$。算子计算为 $D_i = \\frac{(u_{i+1} - u_{i-1})(u_{i+1} + u_{i-1})}{4\\Delta x}$。在存在较大平均值的情况下，这种重排在数值上优于 R1。它首先计算微小的差值 $u_{i+1} - u_{i-1}$，从而保留了 $u$ 的小尺度变化的精度。然后将这个小差值乘以行为良好的和 $u_{i+1} + u_{i-1}$。\n\n3.  **补偿形式 (R3)**：此方法利用了测试函数 $u(x) = U_0 + \\varepsilon\\sin(kx)$ 中已知的常数部分 $U_0$。我们定义一个扰动场 $v(x) = u(x) - U_0$。通量差 $F_{i+1} - F_{i-1}$ 经过解析展开后进行计算：\n    $$\n    F_{i+1} - F_{i-1} = \\frac{(U_0+v_{i+1})^2}{2} - \\frac{(U_0+v_{i-1})^2}{2} = U_0(v_{i+1}-v_{i-1}) + \\frac{v_{i+1}^2 - v_{i-1}^2}{2}\n    $$\n    这个表达式与原始表达式代数等价，但其计算方式是首先从 $u_i$ 中剥离大的常数部分 $U_0$ 得到 $v_i$。然后所有的算术运算都在这些更小、条件更好的数上进行。项 $\\frac{v_{i+1}^2 - v_{i-1}^2}{2}$ 也使用其乘积形式 $\\frac{(v_{i+1}-v_{i-1})(v_{i+1}+v_{i-1})}{2}$ 进行计算，以获得最大的鲁棒性。预计这种重排方式将是最准确的，尤其是在旨在引发严重抵消误差的情况下。\n\n数值实验按以下步骤进行。对于四个测试用例 $(U_0, \\varepsilon, k)$ 中的每一个和指定的加密序列中的每个网格分辨率 $N$，我们执行以下步骤：\n1.  构建周期性网格 $x_i$，其中 $i=0, \\dots, N-1$。\n2.  计算测试函数 $u(x_i) = U_0 + \\varepsilon\\sin(kx_i)$ 及其精确通量导数 $\\frac{dF}{dx}(x_i) = u(x_i) \\cdot (\\varepsilon k \\cos(kx_i))$。\n3.  对所有 $i$ 计算三种离散导数近似值 $D_{1,i}, D_{2,i}, D_{3,i}$。\n4.  计算每种重排方式相对于精确导数的离散 $L^2$ 误差 $E(N)$。\n5.  在收集所有加密级别的误差后，估计每种重排方式的精度阶 $\\alpha$。这是通过对误差的对数与网格间距的对数进行线性最小二乘拟合来完成的：$\\log(E) = \\alpha \\log(\\Delta x) + C$。此拟合的斜率即为实测精度阶 $\\alpha$。\n\n二阶中心差分格式的理论精度阶为 $2$，这意味着误差 $E$ 应按 $E \\propto (\\Delta x)^2$ 的比例缩放。当截断误差占主导地位时，我们预期实测阶数 $\\alpha$ 将接近 $2$。然而，随着 $\\Delta x$ 的减小，截断误差会缩小，最终，量级上恒定的舍入误差将占主导地位。这个“误差平台”导致总误差停止减小甚至增加，从而破坏了对数-对数线性关系，并降低了实测精度阶 $\\alpha$。\n\n- **情况 1 ($U_0=0$)**：所有重排方式在计算上相似。我们预计三种方式的 $\\alpha$ 都约等于 $2$。\n- **情况 2 和 3 ($U_0=1.0$，小 $\\varepsilon$)**：由于灾难性抵消，预计 R1 的表现会很差，导致 $\\alpha$ 很小甚至为零。R2 和 R3 应该具有鲁棒性，显示出 $\\alpha \\approx 2$。由于 $\\varepsilon$ 的值极小，这种效应在情况 3 中会更加明显。\n- **情况 4 (高频 $k$)**：截断误差与解的导数（因此与 $k$）成比例，将会大得多。它将在整个 $\\Delta x$ 范围内主导舍入误差。因此，预计所有三种方法都将显示出 $\\alpha \\approx 2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 3),         # Case 1 (happy path)\n        (1.0, 1e-2, 3),        # Case 2 (moderate cancellation)\n        (1.0, 1e-12, 3),       # Case 3 (severe cancellation)\n        (1.0, 1e-2, 500),      # Case 4 (high frequency)\n    ]\n    \n    # Domain and refinement settings\n    L = 2.0 * np.pi\n    N_vals = np.array([64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768])\n\n    all_results = []\n    \n    for U0, eps, k in test_cases:\n        delta_x_vals = []\n        errors1, errors2, errors3 = [], [], []\n\n        for N in N_vals:\n            dx = L / N\n            x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n            delta_x_vals.append(dx)\n\n            # 1. Evaluate analytical fields\n            u = U0 + eps * np.sin(k * x)\n            dudx_exact = eps * k * np.cos(k * x)\n            dFdx_exact = u * dudx_exact\n\n            # Get neighbor values for central difference using periodic boundaries\n            u_p1 = np.roll(u, -1)\n            u_m1 = np.roll(u, 1)\n\n            # 2. Compute the three numerical derivative rearrangements\n            # Rearrangement 1: Direct flux difference (prone to cancellation)\n            D1 = (u_p1**2 - u_m1**2) / (4.0 * dx)\n\n            # Rearrangement 2: Product of sum and difference (more robust)\n            D2 = (u_p1 - u_m1) * (u_p1 + u_m1) / (4.0 * dx)\n\n            # Rearrangement 3: Compensated form using known mean U0\n            # F(U0+v) = F(U0) + F'(U0)v + F''(U0)v^2/2 = F(U0) + U0*v + v^2/2\n            # F(i+1)-F(i-1) = U0*(v_p1-v_m1) + (v_p1^2-v_m1^2)/2\n            v_p1 = u_p1 - U0\n            v_m1 = u_m1 - U0\n            term1 = U0 * (v_p1 - v_m1)\n            term2 = (v_p1 - v_m1) * (v_p1 + v_m1) / 2.0\n            D3 = (term1 + term2) / (2.0 * dx)\n            \n            # 3. Compute L2 errors\n            err1 = np.sqrt(dx * np.sum((D1 - dFdx_exact)**2))\n            err2 = np.sqrt(dx * np.sum((D2 - dFdx_exact)**2))\n            err3 = np.sqrt(dx * np.sum((D3 - dFdx_exact)**2))\n            \n            errors1.append(err1)\n            errors2.append(err2)\n            errors3.append(err3)\n\n        # 4. Estimate order of accuracy via least-squares on log-log data\n        log_dx = np.log(np.array(delta_x_vals))\n        \n        alphas = []\n        for errors in [errors1, errors2, errors3]:\n            # Use only finite error values for the log-log fit, in case any error is zero.\n            errors_arr = np.array(errors, dtype=np.float64)\n            valid_indices = np.isfinite(errors_arr)  (errors_arr > 0)\n            \n            if np.sum(valid_indices) > 1:\n                log_err = np.log(errors_arr[valid_indices])\n                log_dx_fit = log_dx[valid_indices]\n                # polyfit returns [slope, intercept] for degree 1\n                alpha = np.polyfit(log_dx_fit, log_err, 1)[0]\n                alphas.append(alpha)\n            else:\n                # If fit is not possible (e.g., all errors are zero), alpha is ill-defined.\n                # A constant error results in alpha = 0.\n                alphas.append(0.0)\n                \n        all_results.append(alphas)\n\n    # Final print statement in the exact required format.\n    sublist_strs = [f\"[{','.join(map(str, sub))}]\" for sub in all_results]\n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在数值模拟中，我们追求的最优解往往是在截断误差与舍入误差之间取得的平衡。本练习将这两种误差源整合进一个统一的解析模型中，让你能够系统地分析它们之间的权衡关系。你将运用微积分知识，推导能够最小化总误差的最优网格间距 $h^\\star$，从而从理论上解释和预测在误差分析中常见的“V”形曲线现象，深化对数值误差本质的理解 。",
            "id": "3364197",
            "problem": "请考虑以下受计算流体动力学 (CFD) 中使用的经典离散化启发的抽象误差模型。其背景是在均匀或各向异性网格上对空间导数和椭圆算子进行数值近似，其中总误差被建模为截断分量和舍入分量之和。您将推导并实现用于计算使这些模型的总误差最小化的网格间距的公式，然后在一组定义的测试套件上对它们进行评估。\n\nA 部分（一维二阶导数算子）。设总误差作为网格间距 $h$ 的函数，模型为\n$$\nE_{1\\mathrm{D}}(h) = C_T h^{p} + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h},\n$$\n其中 $C_T$ 和 $C_R$ 是正常数，$p$ 是截断误差的形式精度阶数，$\\epsilon_{\\mathrm{mach}}$ 是机器 epsilon。假设浮点运算符合电气与电子工程师协会 (IEEE) 的双精度标准，因此 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$。您必须从第一性原理出发，推导使 $E_{1\\mathrm{D}}(h)$ 最小化的最优网格间距 $h^\\star$ 和相应的最小总误差 $E_{1\\mathrm{D}}^\\star$。\n\nB 部分（各向异性网格上的二维泊松算子）。考虑在间距分别为 $h_x$ 和 $h_y$ 的矩形网格上，使用五点有限差分模板对二维泊松算子进行离散化。假设截断误差在每个坐标方向上以相同的形式精度阶数 $p$ 可加地缩放，得到模型\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = C_x h_x^{p} + C_y h_y^{p} + C_R \\epsilon_{\\mathrm{mach}} \\left(\\frac{1}{h_x} + \\frac{1}{h_y}\\right),\n$$\n其中 $C_x$ 和 $C_y$ 是编码各向异性截断贡献的正常数。请从第一性原理和机械演算出发，推导使 $E_{2\\mathrm{D}}(h_x,h_y)$ 最小化的最优间距 $h_x^\\star$ 和 $h_y^\\star$ 以及相应的最小总误差 $E_{2\\mathrm{D}}^\\star$。\n\n您可以假设的基础知识。您可以假设通过泰勒展开定义的有限差分截断误差、对于一个相容的离散化存在形式精度阶数 $p$，以及机器 epsilon 定义为 1 与下一个可表示的浮点数之间的距离。您也可以假设可微函数在一阶导数为零处达到驻点，并且驻点处的二阶导数为正意味着该点为局部最小值。\n\n交付成果。您的程序必须实现您推导出的闭式最优网格间距和最小误差，并针对以下测试套件进行评估。所有量都是无量纲的，不需要物理单位。\n\n测试套件。精确使用 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$。\n- 一维测试（每种情况返回一个列表 $[h^\\star, E_{1\\mathrm{D}}^\\star]$）：\n  - 情况 $\\mathrm{A1}$：$p = 2$，$C_T = 5 \\times 10^{-1}$，$C_R = 1$。\n  - 情况 $\\mathrm{A2}$：$p = 4$，$C_T = 10^{-3}$，$C_R = 5 \\times 10^{-1}$。\n- 二维测试（每种情况返回一个列表 $[h_x^\\star, h_y^\\star, E_{2\\mathrm{D}}^\\star]$）：\n  - 情况 $\\mathrm{B1}$：$p = 2$，$C_x = 1/4$，$C_y = 1/2$，$C_R = 1$。\n  - 情况 $\\mathrm{B2}$：$p = 2$，$C_x = 10^{-2}$，$C_y = 10^{2}$，$C_R = 3$。\n  - 情况 $\\mathrm{B3}$：$p = 4$，$C_x = 10^{-1}$，$C_y = 10^{-1}$，$C_R = 4/5$。\n\n最终输出格式。您的程序应生成一行输出，其中包含结果，形式为一个用方括号括起来的逗号分隔列表，按上述顺序列出所有测试用例。每个测试用例的结果本身应该是一个使用科学记数法表示且恰好有 $12$ 位有效数字的浮点数列表。例如，一个有效的整体输出形式为\n$$\n\\big[ [\\cdots,\\cdots], [\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots], [\\cdots,\\cdots,\\cdots] \\big]\n$$\n其中没有任何空格。五个内部列表分别对应情况 $\\mathrm{A1}, \\mathrm{A2}, \\mathrm{B1}, \\mathrm{B2}, \\mathrm{B3}$。\n\n您的程序不得读取任何输入，也不得写入任何额外文本。它必须在内部计算 $\\epsilon_{\\mathrm{mach}}$ 为 $2^{-52}$，并在所有情况下一致地使用它。所有答案必须是具有 12 位有效数字的科学记数法浮点数，并且必须完全按照规定放置。最终的单行必须是唯一的输出。",
            "solution": "该问题要求推导两种抽象误差模型的最优网格间距和最小误差，然后对给定的测试套件进行数值实现。每个部分的推导都将基于使用微分学最小化总误差函数。\n\n### A 部分：一维误差模型\n\n一维情况下的总误差由以下函数给出：\n$$\nE_{1\\mathrm{D}}(h) = C_T h^{p} + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h}\n$$\n其中 $h  0$ 是网格间距，$C_T$ 和 $C_R$ 是正常数，$p$ 是精度阶数，$\\epsilon_{\\mathrm{mach}}$ 是机器 epsilon。\n\n为找到使该误差最小化的网格间距 $h^\\star$，我们必须通过对 $h$ 求一阶导数并将其设为零来找到 $E_{1\\mathrm{D}}(h)$ 的临界点。\n$$\n\\frac{dE_{1\\mathrm{D}}}{dh} = \\frac{d}{dh} \\left( C_T h^{p} + C_R \\epsilon_{\\mathrm{mach}} h^{-1} \\right) = p C_T h^{p-1} - C_R \\epsilon_{\\mathrm{mach}} h^{-2}\n$$\n将导数设为零，得到最优间距 $h^\\star$ 的条件：\n$$\np C_T (h^\\star)^{p-1} - C_R \\frac{\\epsilon_{\\mathrm{mach}}}{(h^\\star)^2} = 0\n$$\n$$\np C_T (h^\\star)^{p-1} = \\frac{C_R \\epsilon_{\\mathrm{mach}}}{(h^\\star)^2}\n$$\n两边乘以 $(h^\\star)^2$ 并整理以解出 $h^\\star$：\n$$\np C_T (h^\\star)^{p+1} = C_R \\epsilon_{\\mathrm{mach}}\n$$\n$$\n(h^\\star)^{p+1} = \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T}\n$$\n这给出了最优网格间距：\n$$\nh^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T} \\right)^{\\frac{1}{p+1}}\n$$\n为确认该临界点对应于一个最小值，我们检查其二阶导数：\n$$\n\\frac{d^2 E_{1\\mathrm{D}}}{dh^2} = p(p-1) C_T h^{p-2} + 2 C_R \\epsilon_{\\mathrm{mach}} h^{-3}\n$$\n鉴于 $h  0$，$C_T  0$，$C_R  0$，$\\epsilon_{\\mathrm{mach}}  0$，且精度阶数 $p \\ge 1$，两项都是非负的，且第二项是严格为正的。因此，对于所有 $ h  0$，都有 $\\frac{d^2 E_{1\\mathrm{D}}}{dh^2}  0$，这证实了 $h^\\star$ 对应一个局部和全局最小值。\n\n最小总误差 $E_{1\\mathrm{D}}^\\star$ 是通过将 $h^\\star$ 代回原始误差函数 $E_{1\\mathrm{D}}(h)$ 求得的。可以从一阶条件 $p C_T (h^\\star)^{p+1} = C_R \\epsilon_{\\mathrm{mach}}$ 推导出一个更简洁的表达式，该条件意味着 $C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h^\\star} = p C_T (h^\\star)^{p}$。将此代入 $E_{1\\mathrm{D}}(h^\\star)$ 的表达式中：\n$$\nE_{1\\mathrm{D}}^\\star = E_{1\\mathrm{D}}(h^\\star) = C_T (h^\\star)^p + C_R \\frac{\\epsilon_{\\mathrm{mach}}}{h^\\star} = C_T (h^\\star)^p + p C_T (h^\\star)^p\n$$\n$$\nE_{1\\mathrm{D}}^\\star = (p+1) C_T (h^\\star)^p\n$$\n\n### B 部分：二维误差模型\n\n二维各向异性情况下的总误差为：\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = C_x h_x^{p} + C_y h_y^{p} + C_R \\epsilon_{\\mathrm{mach}} \\left(\\frac{1}{h_x} + \\frac{1}{h_y}\\right)\n$$\n其中 $h_x  0$ 和 $h_y  0$。该函数在 $h_x$ 和 $h_y$ 上是可分的。我们可以将其重写为：\n$$\nE_{2\\mathrm{D}}(h_x, h_y) = \\left(C_x h_x^{p} + \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_x}\\right) + \\left(C_y h_y^{p} + \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_y}\\right)\n$$\n为最小化 $E_{2\\mathrm{D}}(h_x, h_y)$，我们可以独立地最小化括号内的两项。每一项都具有与一维误差模型 $E_{1\\mathrm{D}}(h)$ 相同的函数形式。\n\n对于 $h_x$ 分量，我们将关于 $h_x$ 的偏导数设为零：\n$$\n\\frac{\\partial E_{2\\mathrm{D}}}{\\partial h_x} = p C_x h_x^{p-1} - \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_x^2} = 0\n$$\n这与一维情况类似，只是用 $C_x$ 替换了 $C_T$。最优间距 $h_x^\\star$ 的解是：\n$$\nh_x^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_x} \\right)^{\\frac{1}{p+1}}\n$$\n类似地，对于 $h_y$ 分量：\n$$\n\\frac{\\partial E_{2\\mathrm{D}}}{\\partial h_y} = p C_y h_y^{p-1} - \\frac{C_R \\epsilon_{\\mathrm{mach}}}{h_y^2} = 0\n$$\n用 $C_y$ 替换 $C_T$ 得到最优间距 $h_y^\\star$：\n$$\nh_y^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_y} \\right)^{\\frac{1}{p+1}}\n$$\n$E_{2\\mathrm{D}}$ 的海森矩阵是对角的，因为混合偏导数 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_x \\partial h_y} = 0$。对角线元素是 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_x^2}$ 和 $\\frac{\\partial^2 E_{2\\mathrm{D}}}{\\partial h_y^2}$，由于与 A 部分相同的原因，它们是正的。因此，海森矩阵是正定的，点 $(h_x^\\star, h_y^\\star)$ 是一个最小值点。\n\n最小总误差 $E_{2\\mathrm{D}}^\\star$ 是每个分量的最小误差之和。使用 A 部分中最小误差的简化公式：\n$$\nE_{2\\mathrm{D}}^\\star = E_{2\\mathrm{D}}(h_x^\\star, h_y^\\star) = (p+1) C_x (h_x^\\star)^p + (p+1) C_y (h_y^\\star)^p\n$$\n$$\nE_{2\\mathrm{D}}^\\star = (p+1) \\left( C_x (h_x^\\star)^p + C_y (h_y^\\star)^p \\right)\n$$\n\n### 用于实现的公式总结\n推导出的公式被用于实现，以解决使用 $\\epsilon_{\\mathrm{mach}} = 2^{-52}$ 的测试套件。\n\n- **A 部分：**\n  - $h^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_T} \\right)^{\\frac{1}{p+1}}$\n  - $E_{1\\mathrm{D}}^\\star = (p+1) C_T (h^\\star)^p$\n\n- **B 部分：**\n  - $h_x^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_x} \\right)^{\\frac{1}{p+1}}$\n  - $h_y^\\star = \\left( \\frac{C_R \\epsilon_{\\mathrm{mach}}}{p C_y} \\right)^{\\frac{1}{p+1}}$\n  - $E_{2\\mathrm{D}}^\\star = (p+1) \\left( C_x (h_x^\\star)^p + C_y (h_y^\\star)^p \\right)$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes optimal grid spacings and minimum errors for the given test suite\n    based on the derived analytical formulas.\n    \"\"\"\n    \n    # IEEE double-precision machine epsilon\n    epsilon_mach = 2**-52\n\n    # Define the test cases from the problem statement.\n    # Format: (type, p, C_T/C_x, C_R/C_y, C_R_2D)\n    test_cases = [\n        # Case A1: 1D, p=2, C_T=0.5, C_R=1\n        ('1d', 2, 5e-1, 1, None),\n        # Case A2: 1D, p=4, C_T=1e-3, C_R=0.5\n        ('1d', 4, 1e-3, 5e-1, None),\n        # Case B1: 2D, p=2, C_x=1/4, C_y=1/2, C_R=1\n        ('2d', 2, 1/4, 1/2, 1),\n        # Case B2: 2D, p=2, C_x=1e-2, C_y=1e2, C_R=3\n        ('2d', 2, 1e-2, 1e2, 3),\n        # Case B3: 2D, p=4, C_x=1e-1, C_y=1e-1, C_R=4/5\n        ('2d', 4, 1e-1, 1e-1, 4/5),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        case_type, p, param1, param2, param3 = case\n        \n        if case_type == '1d':\n            # Unpack parameters for 1D case\n            C_T = param1\n            C_R = param2\n            \n            # Calculate optimal spacing h_star\n            h_star = (C_R * epsilon_mach / (p * C_T))**(1 / (p + 1))\n            \n            # Calculate minimum error E_star\n            E_star = (p + 1) * C_T * (h_star**p)\n            \n            all_results.append([h_star, E_star])\n            \n        elif case_type == '2d':\n            # Unpack parameters for 2D case\n            C_x = param1\n            C_y = param2\n            C_R = param3\n            \n            # Calculate optimal spacings hx_star and hy_star\n            hx_star = (C_R * epsilon_mach / (p * C_x))**(1 / (p + 1))\n            hy_star = (C_R * epsilon_mach / (p * C_y))**(1 / (p + 1))\n            \n            # Calculate minimum error E_star\n            E_star = (p + 1) * (C_x * (hx_star**p) + C_y * (hy_star**p))\n            \n            all_results.append([hx_star, hy_star, E_star])\n\n    # Format the final output string according to the specified format.\n    # Each number is in scientific notation with 12 significant digits.\n    # The output is a single line, a list of lists, with no spaces.\n    inner_strings = []\n    for res in all_results:\n        formatted_numbers = [f\"{x:.11e}\" for x in res]\n        inner_strings.append(f\"[{','.join(formatted_numbers)}]\")\n        \n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}