{
    "hands_on_practices": [
        {
            "introduction": "大涡模拟（LES）是研究湍流的有力工具，但直接解析固体边界附近的剧烈梯度通常计算成本过高。因此，基于动量守恒原理建立的壁面模型变得不可或缺。本练习将引导你从第一性原理出发，推导一个经典的平衡壁面模型。你将从应用于近壁控制体的动量方程积分形式入手，将壁面切应力与远离壁面的解析流场联系起来。通过这项动手分析练习，你将深化对基本守恒定律如何应用于构建实用湍流模型的理解。",
            "id": "3336014",
            "problem": "考虑在 $y=0$ 处的无限大平坦壁面上方的一个统计定常、不可压缩的湍流边界层，该边界层通过壁面模化大涡模拟（LES）进行仿真。解析的平均流平行于壁面，并且在流向和展向上是均匀的，其解析的平均流向速度为 $\\overline{U}(y)$，流体密度 $\\rho$ 为常数。假设在近壁匹配层 $0  y  \\Delta$ 内，总的平面平均切应力近似恒定，且平均压力梯度与流向加速度均可忽略不计。此外，位于匹配高度 $y=\\Delta$ 处的解析平均速度由以下对数剖面给出：$\\overline{U}(\\Delta)=\\dfrac{u_{\\ast}}{\\kappa}\\ln\\!\\left(\\dfrac{\\Delta}{y_{0}}\\right)$，其中 $u_{\\ast}=\\sqrt{\\tau_{w}/\\rho}$ 是摩擦速度，$\\tau_w$ 是壁面切应力，$\\kappa$ 是冯·卡门常数，$y_0$ 是粗糙度长度。您的任务是基于动量守恒的积分形式推导壁面切应力 $\\tau_w$ 的表达式，然后用微分形式验证您的结果。",
            "solution": "问题要求基于动量方程的积分形式推导壁面切应力 $\\tau_w$ 的壁面模型表达式，然后用微分形式验证此结果。$\\tau_w$ 的最终表达式必须用匹配高度处的平均解析速度 $\\overline{U}(\\Delta)$、流体密度 $\\rho$、冯·卡门常数 $\\kappa$、匹配高度 $\\Delta$ 和粗糙度长度 $y_0$ 来表示。\n\n首先，我们验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n-   在 $y=0$ 处的无限大平坦壁面上方的统计定常、不可压缩湍流边界层。\n-   该仿真是壁面模化大涡模拟（LES）。\n-   解析的平均流平行于壁面，平均流向速度为 $\\overline{U}(y)$。\n-   平均流在流向（$x$）和展向（$z$）上是均匀的。\n-   流体密度 $\\rho$ 是常数。\n-   存在一个近壁匹配层 $0  y  \\Delta$。\n-   在此层内，平面平均流处于统计平衡状态，平均压力梯度和平均流向加速度可忽略不计。\n-   平面平均总切应力在 $0  y  \\Delta$ 范围内近似恒定。\n-   在 $y=\\Delta$ 处的解析平均速度由对数剖面给出：$\\overline{U}(\\Delta)=\\dfrac{u_{\\ast}}{\\kappa}\\ln\\!\\left(\\dfrac{\\Delta}{y_{0}}\\right)$。\n-   定义：$u_{\\ast}=\\sqrt{\\tau_{w}/\\rho}$（摩擦速度），$\\tau_w$（壁面切应力），$\\kappa$（冯·卡门常数），$y_0$（粗糙度长度）。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于流体力学和湍流模型的原理，特别是关于壁面束缚流和CFD中的壁面模化。所提供的假设（平衡、均匀性、恒定应力层）是推导壁面律对数律和平衡壁面模型的标准假设。问题提法得当，信息充分，术语清晰客观。不存在科学或逻辑上的矛盾。该设置描述了计算流体力学中一个经典且有效的问题。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。我们继续进行求解。\n\n**第一部分：从动量守恒的积分形式推导**\n\n我们考虑一个控制体（CV）的流向（$x$方向）动量守恒的积分形式。该控制体是一个矩形盒子，其壁面平行面积为 $A=L_x L_z$，高度为 $\\Delta$，从 $y=0$ 处的壁面延伸到 $y=\\Delta$ 的匹配高度。\n\n积分动量方程为：\n$$\n\\frac{d}{dt} \\int_{CV} \\rho \\overline{U} \\, dV + \\oint_{CS} \\rho \\overline{U} (\\mathbf{\\overline{u}} \\cdot \\mathbf{n}) \\, dS = \\sum F_x\n$$\n其中 $\\overline{U}$ 是平均流向速度，$\\mathbf{\\overline{u}} = (\\overline{U}(y), 0, 0)$ 是平均速度矢量，$dV$ 是微元体积，$dS$ 是控制面（CS）的微元面积，$\\mathbf{n}$ 是控制面上的外指单位法向矢量，$\\sum F_x$ 是作用在控制体内流体上所有$x$方向外力的总和。\n\n我们分析每一项：\n1.  **非定常项**：$\\frac{d}{dt} \\int_{CV} \\rho \\overline{U} \\, dV$。问题陈述流是统计定常的，意味着平均量不随时间变化。因此，该项为零。\n\n2.  **动量通量项**：$\\oint_{CS} \\rho \\overline{U} (\\mathbf{\\overline{u}} \\cdot \\mathbf{n}) \\, dS$。平均流纯粹在 $x$ 方向，$\\mathbf{\\overline{u}} = (\\overline{U}(y), 0, 0)$。因此，通过控制体的顶面（$y=\\Delta$）、底面（$y=0$）或展向面（$z=0$，$z=L_z$）没有平均动量通量，因为在这些面上 $\\mathbf{\\overline{u}} \\cdot \\mathbf{n} = 0$。通量项仅在入口（$x=0$）和出口（$x=L_x$）面非零。然而，问题指明平均流在流向上是均匀的，意味着 $\\frac{\\partial \\overline{U}}{\\partial x} = 0$。因此，在入口面进入控制体的动量通量与在出口面流出的动量通量相同。因此净动量通量为零。这也与给定的“可忽略的平均流向加速度”相符。\n\n3.  **力项**：$\\sum F_x$。外力来自于控制面上的压力和切应力。\n    -   **压力**：问题陈述平均压力梯度可忽略不计，$\\frac{\\partial \\overline{p}}{\\partial x} = 0$。因此，入口面上的压力与出口面上的压力相平衡，导致净压力为零。\n    -   **切向力**：唯一对 $x$ 方向净力有贡献的表面是顶面和底面。\n        -   在底面（$y=0$，即壁面），壁面对流体施加一个阻力。该力作用于负 $x$ 方向，大小为 $-\\tau_w A$，其中 $\\tau_w$ 是壁面切应力的大小。\n        -   在顶面（$y=\\Delta$），控制体上方的流体对控制体内的流体施加一个切向力。该力作用于正 $x$ 方向，大小为 $\\overline{\\tau}(\\Delta) A$，其中 $\\overline{\\tau}(\\Delta)$ 是匹配高度处的总平均切应力（解析的粘性应力和亚格子尺度应力之和）。\n    净力为 $\\sum F_x = \\overline{\\tau}(\\Delta) A - \\tau_w A$。\n\n综合动量平衡的所有项，得到：\n$$\n0 + 0 = \\overline{\\tau}(\\Delta) A - \\tau_w A\n$$\n简化为：\n$$\n\\tau_w = \\overline{\\tau}(\\Delta)\n$$\n这个结果证实了总切应力在该层内是恒定的初始假设；壁面处的应力与匹配高度处的总应力相平衡。这是平衡壁面模型的基本原理。\n\n现在，我们使用给定的对数速度剖面来构建 $\\tau_w$ 的表达式。问题提供：\n$$\n\\overline{U}(\\Delta) = \\frac{u_{\\ast}}{\\kappa}\\ln\\!\\left(\\frac{\\Delta}{y_{0}}\\right)\n$$\n以及摩擦速度的定义：\n$$\nu_{\\ast} = \\sqrt{\\frac{\\tau_w}{\\rho}} \\quad \\implies \\quad \\tau_w = \\rho u_{\\ast}^2\n$$\n从速度剖面方程，我们解出 $u_{\\ast}$：\n$$\nu_{\\ast} = \\frac{\\kappa \\overline{U}(\\Delta)}{\\ln(\\Delta/y_0)}\n$$\n将 $u_{\\ast}$ 的这个表达式代入 $\\tau_w$ 的方程中：\n$$\n\\tau_w = \\rho \\left( \\frac{\\kappa \\overline{U}(\\Delta)}{\\ln(\\Delta/y_0)} \\right)^2\n$$\n这就是所求的壁面切应力的壁面模型表达式。\n\n**第二部分：用微分形式进行验证**\n\n在给定假设（统计定常、平行平均流、零压力梯度）下，平面平均流向动量方程的微分形式简化为：\n$$\n\\frac{d\\overline{\\tau}}{dy} = 0\n$$\n其中 $\\overline{\\tau}(y)$ 是总平均切应力。该方程正式地表明总切应力不随高度变化，即 $\\overline{\\tau}(y) = \\text{常数}$。对于边界层，这个常数必须是壁面切应力，因此 $\\overline{\\tau}(y) = \\tau_w$。\n\n对数速度剖面 $\\overline{U}(y) = \\frac{u_{\\ast}}{\\kappa}\\ln(y/y_0)$ 的存在是基于湍流切应力的混合长度模型 $\\tau_t = \\rho (\\kappa y)^2 (\\frac{d\\overline{U}}{dy})^2$，以及在对数层中总应力主要由湍流应力主导的假设，即 $\\overline{\\tau} \\approx \\tau_t$。\n\n让我们验证这是自洽的。我们从对数律计算速度梯度：\n$$\n\\frac{d\\overline{U}}{dy} = \\frac{d}{dy}\\left[\\frac{u_{\\ast}}{\\kappa}\\ln\\left(\\frac{y}{y_0}\\right)\\right] = \\frac{u_{\\ast}}{\\kappa} \\frac{1}{(y/y_0)} \\frac{1}{y_0} = \\frac{u_{\\ast}}{\\kappa y}\n$$\n现在我们使用混合长度模型计算 $y=\\Delta$ 处的切应力：\n$$\n\\overline{\\tau}(\\Delta) = \\rho (\\kappa \\Delta)^2 \\left(\\left.\\frac{d\\overline{U}}{dy}\\right|_{y=\\Delta}\\right)^2 = \\rho (\\kappa \\Delta)^2 \\left(\\frac{u_{\\ast}}{\\kappa \\Delta}\\right)^2\n$$\n$$\n\\overline{\\tau}(\\Delta) = \\rho (\\kappa^2 \\Delta^2) \\left(\\frac{u_{\\ast}^2}{\\kappa^2 \\Delta^2}\\right) = \\rho u_{\\ast}^2\n$$\n根据定义，$\\tau_w = \\rho u_{\\ast}^2$。因此，我们证明了 $\\overline{\\tau}(\\Delta) = \\tau_w$。这个来自微分分析的结果与积分平衡的结论相同，证实了该框架的一致性。对数剖面本身就意味着切应力为 $\\rho u_{\\ast}^2$，这在一个平衡层中必须等于壁面切应力。\n\n最终的表达式是在第一部分中推导出的那个。",
            "answer": "$$\\boxed{\\rho \\left( \\frac{\\kappa \\overline{U}(\\Delta)}{\\ln\\left(\\frac{\\Delta}{y_{0}}\\right)} \\right)^{2}}$$"
        },
        {
            "introduction": "一个稳健的数值格式应当能够在离散层面精确地维持基本的物理平衡状态，例如流体静力平衡。然而，对动量方程中的压力梯度项和重力源项进行朴素的离散化，可能会导致不平衡，从而在原本静止的流体中产生虚假的、非物理的速度。在这个编程练习中，你将实现一个基准测试来揭示这种常见的数值谬误，然后通过确保离散力的一致性来构建一个“良好平衡”的修正方案。这项实践将让你深刻体会到设计尊重物理守恒律的数值方法时，那些细微但至关重要的技术要点。",
            "id": "3335974",
            "problem": "考虑一个一维垂直流体柱，其高度为 $H$，横截面积为 $A$，并与向上的垂直坐标 $z$ 对齐。设重力由体力密度 $\\rho \\mathbf{g}$ 表示，其中 $\\mathbf{g} = -g(z)\\,\\hat{\\mathbf{z}}$，且 $g(z) \\ge 0$ 是重力加速度的大小，可能依赖于 $z$。假设没有运动（$\\mathbf{u} = \\mathbf{0}$）并考虑静水力条件。对于一个静止的控制体，动量守恒的积分形式表明，表面力和体力之和为零。在这种情况下，唯一的表面力是压力，唯一的体力是重力。\n\n从牛顿第二定律和动量守恒的积分形式出发，推导整个流体柱的垂直动量平衡的离散残差，用顶部和底部面上的压力以及重力体力的全柱积分来表示。然后，设计并实现一个有限体积基准测试，证明在静水力平衡中对重力 $\\rho \\mathbf{g}$ 的不一致离散处理如何在积分意义上导致非零的净残差（伪动量），并提出一种基于压力的修正方法，以恢复精确的离散静水力平衡。\n\n您的基准测试必须遵循以下规范：\n\n- 基本基础：\n  - 使用牛顿第二定律和动量守恒的积分形式来分析静止的静水力柱。\n  - 在顶部和底部面上定义 $z$ 方向的向外单位法向量，并用它们写出压力的 $z$ 分量贡献。\n  - 在静水力平衡中使用物理上一致的 $\\rho(z)$、$p(z)$ 和 $g(z)$ 定义。\n- 几何与离散化：\n  - 使用具有 $N$ 个等厚度 $\\Delta z = H/N$ 的控制体的均匀网格，单元中心位于 $z_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta z$，其中 $i = 0,1,\\dots,N-1$。\n  - 使用横截面积 $A = 1$ 以牛顿（$\\mathrm{N}$）为单位报告力，无需额外缩放。\n- 两种待比较的离散处理方法：\n  1. 一种“朴素”的离散处理，其中净表面压力使用在 $z=H$ 和 $z=0$ 处由连续静水力解计算得到的连续静水力边界压力 $p_{\\mathrm{top}}$ 和 $p_{\\mathrm{bot}}$，而体力则通过中点法则 $\\sum_{i=0}^{N-1} \\rho_i\\,g_i\\,\\Delta z$ 近似，其中 $\\rho_i$ 和 $g_i$ 在单元中心处求值。这会产生一个离散残差，因为静水力平衡的两侧是使用不同的求积方法计算的。\n  2. 一种“基于压力的修正”，它构造一个离散的静水力面压力场 $\\{p_{i+\\tfrac{1}{2}}\\}$，使得每个单元上的离散压力差精确平衡该单元内的离散重力体力，从而确保对于静水力数据，在离散意义上整个柱的净积分动量残差恒为零。使用给定的顶部边界压力 $p_{\\mathrm{top}}$ 和与重力源项一致的离散递归来计算 $p_{\\mathrm{bot}}$；然后使用这些离散的静水力面压力评估整个柱的净残差。\n- 测试案例的物理规范：\n  - 等温理想气体：对于恒定的温度 $T$、理想气体常数 $R$ 和恒定的 $g$，使用 $\\rho(z) = \\rho_0 \\exp\\!\\left(-\\frac{z}{H_s}\\right)$ 和 $p(z) = p_0 \\exp\\!\\left(-\\frac{z}{H_s}\\right)$，其中 $H_s = \\frac{R T}{g}$，$p_0$ 是 $z=0$ 处的底部压力，且 $\\rho_0 = \\frac{p_0}{R T}$。\n  - 具有垂直变化重力的等温理想气体：$g(z) = g_0\\left(1 - \\alpha z\\right)$，对于较小的 $\\alpha$；则必须使用 $\\ln\\!\\left(\\frac{p(H)}{p(0)}\\right) = -\\frac{1}{R T}\\int_0^H g(z)\\,\\mathrm{d}z$ 来从 $p_0$ 提供物理上一致的顶部边界压力 $p_{\\mathrm{top}}$。\n- 单位：\n  - 所有输入的物理量必须采用国际单位制（SI）：$H$ 单位为米（$\\mathrm{m}$），$g$ 单位为米每二次方秒（$\\mathrm{m/s^2}$），$R$ 单位为焦耳每千克开尔文（$\\mathrm{J/(kg\\,K)}$），$T$ 单位为开尔文（$\\mathrm{K}$），$p$ 单位为帕斯卡（$\\mathrm{Pa}$），$\\rho$ 单位为千克每立方米（$\\mathrm{kg/m^3}$），力单位为牛顿（$\\mathrm{N}$）。\n- 要实现的数值任务：\n  - 对于每个测试案例，构建适用于该案例的静水力 $\\rho_i$ 和 $p_{\\mathrm{top}}$。\n  - 对于“朴素”处理，计算净积分动量残差 $R_{\\mathrm{naive}}$，即净表面压力与离散重力体力之差。\n  - 构建与体力求积一致的离散静水力面压力，并计算净残差 $R_{\\mathrm{fix}}$。\n  - 以牛顿（$\\mathrm{N}$）为单位报告两个残差。\n- 测试套件：\n  - 案例 1（顺利路径）：恒定重力下的等温理想气体，中等分辨率。\n    - 参数：$H = 1000\\,\\mathrm{m}$，$N = 10$，$g = 9.81\\,\\mathrm{m/s^2}$，$T = 300\\,\\mathrm{K}$，$R = 287\\,\\mathrm{J/(kg\\,K)}$，$p_0 = 101325\\,\\mathrm{Pa}$。\n  - 案例 2（粗分辨率）：与案例 1 物理模型相同，但网格非常粗糙。\n    - 参数：$H = 1000\\,\\mathrm{m}$，$N = 2$，$g = 9.81\\,\\mathrm{m/s^2}$，$T = 300\\,\\mathrm{K}$，$R = 287\\,\\mathrm{J/(kg\\,K)}$，$p_0 = 101325\\,\\mathrm{Pa}$。\n  - 案例 3（极端粗糙边缘案例）：与案例 1 物理模型相同，但 $N = 1$ 个单元。\n    - 参数：$H = 1000\\,\\mathrm{m}$，$N = 1$，$g = 9.81\\,\\mathrm{m/s^2}$，$T = 300\\,\\mathrm{K}$，$R = 287\\,\\mathrm{J/(kg\\,K)}$，$p_0 = 101325\\,\\mathrm{Pa}$。\n  - 案例 4（可变重力）：重力随高度线性减小的等温理想气体。\n    - 参数：$H = 2000\\,\\mathrm{m}$，$N = 20$，$g_0 = 9.81\\,\\mathrm{m/s^2}$，$\\alpha = 10^{-5}\\,\\mathrm{m^{-1}}$，$T = 300\\,\\mathrm{K}$，$R = 287\\,\\mathrm{J/(kg\\,K)}$，$p_0 = 101325\\,\\mathrm{Pa}$。\n- 最终输出格式：\n  - 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。对于每个测试案例，输出一个二元列表 $[R_{\\mathrm{naive}}, R_{\\mathrm{fix}}]$，单位为牛顿（$\\mathrm{N}$）。将这些每个案例的列表聚合到一个总列表中。例如，输出应类似于 $[[r_1^{\\mathrm{naive}}, r_1^{\\mathrm{fix}}],[r_2^{\\mathrm{naive}}, r_2^{\\mathrm{fix}}],\\dots]$，其中每个 $r$ 是表示牛顿（$\\mathrm{N}$）的浮点数。",
            "solution": "该问题要求推导并实现一个数值基准测试，以展示“良态平衡”离散化对于计算流体动力学中静水力问题的重要性。我们必须比较一种“朴素”的有限体积离散化方法（由于不一致的数值近似而产生伪净力）和一种保证离散静水力平衡的“基于压力的修正”方法。\n\n### 1. 连续积分动量平衡\n\n我们从具有表面 $S$ 的控制体 $V$ 的动量守恒定律的积分形式开始。对于密度为 $\\rho$、速度为 $\\mathbf{u}$、压力为 $p$ 的流体，在体力密度 $\\mathbf{f}_b$ 作用下，牛顿第二定律为：\n$$\n\\frac{d}{dt}\\int_V \\rho \\mathbf{u} \\, dV = \\oint_S (-p \\mathbf{n}) \\, dS + \\int_V \\mathbf{f}_b \\, dV\n$$\n其中 $\\mathbf{n}$ 是表面 $S$ 上的向外单位法向量。\n\n对于指定的在重力作用下静止（$\\mathbf{u} = \\mathbf{0}$）的一维垂直流体柱，问题是静水力平衡问题。时间导数项消失。体力为 $\\mathbf{f}_b = \\rho \\mathbf{g}$，其中 $\\mathbf{g} = -g(z) \\hat{\\mathbf{z}}$。我们考虑动量方程的垂直（$\\hat{\\mathbf{z}}$）分量。控制体是整个流体柱，从 $z=0$ 到 $z=H$，具有恒定的横截面积 $A$。\n\n表面积分仅在顶面（$S_{\\text{top}}$，位于 $z=H$）和底面（$S_{\\text{bot}}$，位于 $z=0$）上有贡献，因为来自侧壁的贡献由于对称性而抵消，或者其法线与 $\\hat{\\mathbf{z}}$ 正交。\n- 在 $S_{\\text{top}}$ 上：$\\mathbf{n} = \\hat{\\mathbf{z}}$，所以压力分量为 $\\int_{S_{\\text{top}}} (-p \\hat{\\mathbf{z}}) \\cdot \\hat{\\mathbf{z}} \\, dS = -p(H) A$。\n- 在 $S_{\\text{bot}}$ 上：$\\mathbf{n} = -\\hat{\\mathbf{z}}$，所以压力分量为 $\\int_{S_{\\text{bot}}} (-p (-\\hat{\\mathbf{z}})) \\cdot \\hat{\\mathbf{z}} \\, dS = p(0) A$。\n\n$z$ 方向上的净表面力为 $F_{S,z} = A(p(0) - p(H))$。\n\n$z$ 方向上的总体积力是 $\\rho \\mathbf{g}$ 的 $z$ 分量的体积积分：\n$$\nF_{B,z} = \\int_V (\\rho \\mathbf{g}) \\cdot \\hat{\\mathbf{z}} \\, dV = \\int_0^H \\int_A \\rho(z)(-g(z)) \\, dA \\, dz = -A \\int_0^H \\rho(z) g(z) \\, dz\n$$\n积分动量平衡方程是力的总和，对于平衡状态必须为零：\n$$\nF_{S,z} + F_{B,z} = 0 \\implies A(p(0) - p(H)) - A \\int_0^H \\rho(z) g(z) \\, dz = 0\n$$\n两边除以 $A$ 并重新整理，得到熟悉的静水力关系：$p(0) - p(H) = \\int_0^H \\rho(z) g(z) \\, dz$。连续系统上的净力或残差恒为零。\n\n### 2. 有限体积离散化\n\n高度为 $H$ 的柱体被离散化为 $N$ 个均匀的控制体（单元），索引为 $i = 0, 1, \\dots, N-1$。每个单元的厚度为 $\\Delta z = H/N$。第 $i$ 个单元占据空间域 $[i\\Delta z, (i+1)\\Delta z]$，其中心位于 $z_i = (i + \\frac{1}{2})\\Delta z$。为简化起见，问题将横截面积设为 $A=1$，因此力的数值等于压力差或积分源项。\n\n整个柱的动量平衡的离散形式是连续积分形式的近似。净残差 $R_{\\text{discrete}}$ 是离散化的表面力和体力之和。\n$$\nR_{\\text{discrete}} = F_{S,z}^{\\text{discrete}} + F_{B,z}^{\\text{discrete}}\n$$\n\n### 3. “朴素”的离散处理\n\n“朴素”方法不一致地混合了连续和离散的表示。\n- **表面力：** 净表面力使用在区域边界处的精确、连续的静水力压力进行评估：$p_{\\text{bot}} = p(0)$ 和 $p_{\\text{top}} = p(H)$。\n  $$\n  F_{S,z}^{\\text{naive}} = p(0) - p(H) = \\int_0^H \\rho(z) g(z) \\, dz\n  $$\n- **体积力：** 总体积力通过对每个单元的贡献求和来近似。每个单元上的积分使用中点法则近似，密度和重力在单元中心 $z_i$ 处求值。\n  $$\n  F_{B,z}^{\\text{naive}} = \\sum_{i=0}^{N-1} \\left( -\\int_{i\\Delta z}^{(i+1)\\Delta z} \\rho(z) g(z) \\, dz \\right) \\approx \\sum_{i=0}^{N-1} \\left( - \\rho(z_i)g(z_i) \\Delta z \\right) = - \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z\n  $$\n朴素残差 $R_{\\text{naive}}$ 是这两项之和：\n$$\nR_{\\text{naive}} = \\left( p(0) - p(H) \\right) - \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z = \\int_0^H \\rho(z) g(z) \\, dz - \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z\n$$\n这个残差正是中点法则对积分 $\\int_0^H \\rho(z) g(z) \\, dz$ 的全局求积误差。除非 $\\rho(z)g(z)$ 是 $z$ 的线性函数（对于引力场中的理想气体而言并非如此），否则此误差不为零。这种非零的净力是一种数值赝像，或“伪动量”，它会破坏动态模拟。\n\n### 4. “基于压力的修正”（良态平衡方法）\n\n这种方法在单个控制体的层面上强制实现离散静水力平衡。对于单元 $i$，其面上的压力必须精确平衡其内部的离散体力。设 $p_{f,i}$ 是位于 $z = i\\Delta z$ 处面上的压力。单元 $i$ 的平衡方程为：\n$$\n(p_{f,i} - p_{f,i+1}) - \\rho_i g_i \\Delta z = 0\n$$\n这在离散压力梯度和离散源项之间建立了关系，确保它们被一致地建模。这个方程可以写成面压力的递归形式：\n$$\np_{f,i} = p_{f,i+1} + \\rho_i g_i \\Delta z\n$$\n为了构建完整的面压力场 $\\{p_{f,j}\\}_{j=0}^N$，我们从一个边界条件开始。根据题意，我们将顶部面压力 $p_{f,N}$ 设置为连续值 $p(H)$。然后我们从 $i=N-1$ 向下递归到 $i=0$，以找到所有的面压力，最终得到离散的底部压力 $p_{f,0}$。\n\n对于这个“修正”方案，净残差 $R_{\\text{fix}}$ 是使用由此方法推导出的边界压力 $p_{f,0}$ 和 $p_{f,N}$ 计算的。\n$$\nR_{\\text{fix}} = (p_{f,0} - p_{f,N}) - \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z\n$$\n通过将每个单元的平衡方程从 $i=0$ 到 $N-1$ 求和，我们得到压力项的伸缩求和：\n$$\n\\sum_{i=0}^{N-1} (p_{f,i} - p_{f,i+1}) = p_{f,0} - p_{f,N}\n$$\n从每个单元的平衡中，我们也有 $\\sum_{i=0}^{N-1} (p_{f,i} - p_{f,i+1}) = \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z$。\n将此代入 $R_{\\text{fix}}$ 的表达式中：\n$$\nR_{\\text{fix}} = \\left( \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z \\right) - \\sum_{i=0}^{N-1} \\rho_i g_i \\Delta z = 0\n$$\n因此，通过构造，基于压力的修正的残差恒为零（在机器精度范围内），这展示了一种在静水力状态下没有伪动量的良态平衡方案。\n\n### 5. 测试案例的实现\n\n通过为每个案例定义连续物理场来实现该解决方案，并由此推导出离散量。\n\n- **恒定重力：** 对于恒定的 $g$、温度 $T$ 和气体常数 $R$，标高为 $H_s = RT/g$。等温理想气体的静水力解为 $p(z) = p_0 e^{-z/H_s}$ 和 $\\rho(z) = p(z)/(RT)$。\n- **可变重力：** 对于 $g(z) = g_0(1 - \\alpha z)$，静水力关系 $dp/p = -g(z)/(RT) \\, dz$ 积分得到 $p(z) = p_0 \\exp\\left(-\\frac{g_0}{RT}(z - \\frac{\\alpha z^2}{2})\\right)$。\n\n对于每个测试案例，我们按照上述方法计算 $R_{\\text{naive}}$ 和 $R_{\\text{fix}}$。结果，特别是在粗网格（$N=1, 2$）上，将鲜明地说明朴素方法的失败和良态平衡方法的鲁棒性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_residuals(params):\n    \"\"\"\n    Calculates the naive and fixed momentum residuals for a given test case.\n    \"\"\"\n    # Extract parameters\n    H = params['H']\n    N = params['N']\n    T = params['T']\n    R = params['R']\n    p0 = params['p0']\n    \n    A = 1.0  # Cross-sectional area is 1 m^2\n    dz = H / N\n\n    # Define cell centers\n    # z_i corresponds to the center of cell i, for i in 0..N-1\n    z_i = (np.arange(N) + 0.5) * dz\n    \n    # Define continuous physics functions based on the case type\n    if params['type'] == 'const_g':\n        g_const = params['g']\n        g_func = lambda z: np.full_like(np.atleast_1d(z), g_const)\n        \n        # Scale height for isothermal atmosphere with constant g\n        Hs = R * T / g_const\n        \n        # Continuous pressure and density profiles\n        p_func = lambda z: p0 * np.exp(-z / Hs)\n        rho_func = lambda z: p_func(z) / (R * T)\n    \n    elif params['type'] == 'var_g':\n        g0 = params['g0']\n        alpha = params['alpha']\n        g_func = lambda z: g0 * (1.0 - alpha * z)\n        \n        # Continuous pressure and density for variable g\n        # Derived from integrating dp/p = -g(z)/(RT) dz\n        exponent_func = lambda z: -(g0 / (R * T)) * (z - 0.5 * alpha * z**2)\n        p_func = lambda z: p0 * np.exp(exponent_func(z))\n        rho_func = lambda z: p_func(z) / (R * T)\n\n    # Evaluate density and gravity at cell centers\n    rho_i = rho_func(z_i)\n    g_i = g_func(z_i)\n\n    # --- 1. Naive Residual Calculation ---\n    \n    # Net surface force from continuous pressure profile at domain boundaries\n    p_top_cont = p_func(H)\n    p_bot_cont = p_func(0.0) # This is p0\n    net_surface_force_naive = A * (p_bot_cont - p_top_cont)\n\n    # Total body force from midpoint rule sum over cells\n    total_body_force_discrete = A * np.sum(rho_i * g_i) * dz\n    \n    # Residual is the sum of forces (surface + body). Body force is negative.\n    # In the problem's terms: difference of surface force and magnitude of body force.\n    R_naive = net_surface_force_naive - total_body_force_discrete\n\n    # --- 2. Pressure-Based Fix Residual Calculation ---\n    \n    # Create an array for face pressures. N+1 faces for N cells.\n    # Face j is at z = j * dz.\n    p_face = np.zeros(N + 1)\n    \n    # Set the top boundary face pressure as the starting point for recursion\n    p_face[N] = p_top_cont\n\n    # Recurse downwards from top to bottom to find all face pressures\n    # p_face[i] = p_face[i+1] + rho_i[i] * g_i[i] * dz\n    for i in range(N - 1, -1, -1):\n        p_face[i] = p_face[i+1] + rho_i[i] * g_i[i] * dz\n        \n    p_bot_fix = p_face[0]\n    p_top_fix = p_face[N]\n\n    # Net surface force using the newly computed consistent boundary pressures\n    net_surface_force_fix = A * (p_bot_fix - p_top_fix)\n    \n    # The discrete body force sum is the same as before\n    # The residual for the fix should be zero by construction\n    R_fix = net_surface_force_fix - total_body_force_discrete\n    \n    return [R_naive, R_fix]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path): Isothermal ideal gas with constant gravity\n        {'H': 1000.0, 'N': 10, 'g': 9.81, 'T': 300.0, 'R': 287.0, 'p0': 101325.0, \n         'g0': None, 'alpha': None, 'type': 'const_g'},\n        # Case 2 (coarse resolution): Same as Case 1, coarser grid\n        {'H': 1000.0, 'N': 2, 'g': 9.81, 'T': 300.0, 'R': 287.0, 'p0': 101325.0, \n         'g0': None, 'alpha': None, 'type': 'const_g'},\n        # Case 3 (extreme coarse edge case): N=1 cell\n        {'H': 1000.0, 'N': 1, 'g': 9.81, 'T': 300.0, 'R': 287.0, 'p0': 101325.0, \n         'g0': None, 'alpha': None, 'type': 'const_g'},\n        # Case 4 (variable gravity): Isothermal ideal gas with linearly varying g\n        {'H': 2000.0, 'N': 20, 'g': None, 'T': 300.0, 'R': 287.0, 'p0': 101325.0, \n         'g0': 9.81, 'alpha': 1e-5, 'type': 'var_g'}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_residuals(case)\n        results.append(result)\n\n    # Format the output string exactly as specified\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代模拟越来越依赖自适应网格加密（AMR）技术来高效地解析复杂的流动特征。AMR面临的一个关键挑战是，必须确保像动量这样的守恒量在粗细网格之间的交界面上能够被正确传递。本编程练习聚焦于守恒型有限体积方法的核心：验证在一个粗网格单元表面上积分的动量通量，精确等于其加密后的所有细网格单元表面上的通量之和。通过实现并测试守恒与非守恒的插值策略，你将对如何在复杂的多层级网格上维持严格的全局动量守恒获得实践性的理解。",
            "id": "3335976",
            "problem": "考虑在没有体力且光滑界面上粘性应力可忽略不计的牛顿流体中动量守恒的积分形式。在一个具有边界面的控制体上，积分动量平衡指的是动量通量张量的净表面通量等于控制体内动量的时间变化率。在稳态、无体力、界面无粘性应力的情况下，无粘动量通量张量在闭合曲面上的面积分等于零。无粘动量通量张量由二阶张量 $T = \\rho \\mathbf{u} \\otimes \\mathbf{u} + p \\mathbf{I}$ 定义，其中 $\\rho$ 是质量密度，$\\mathbf{u}$ 是速度矢量， $p$ 是压力，$\\otimes$ 表示外积，$\\mathbf{I}$ 是单位张量。对于一个给定的、单位法向量为 $\\mathbf{n}$ 的定向面元，动量通量矢量为 $T \\cdot \\mathbf{n}$，其在开放面上的积分是穿过该面的力，单位为牛顿（N）。在自适应网格加密（AMR）的背景下，要求保守的延拓和限制，以使得在粗细网格界面上，粗网格面上的面积分通量等于其加密后的各个子面上的面积分通量之和。形式上，如果一个长度为 $H$ 的粗网格面被细分为 $r$ 个相等的细网格面，守恒性要求\n$$\n\\int_{0}^{H} \\left(T \\cdot \\mathbf{n}\\right)\\, \\mathrm{d}A \\;=\\; \\sum_{i=1}^{r} \\int_{A_i} \\left(T \\cdot \\mathbf{n}\\right)\\, \\mathrm{d}A,\n$$\n其中 $A_i$ 是覆盖粗网格面的不重叠的细分子面。\n\n您的任务是编写一个完整、可运行的程序，在两种延拓/限制策略下，对指定的解析场进行数值验证此守恒性质：一种是保守策略，通过精确求积计算细分子面通量；另一种是非保守策略，通过中点采样近似计算细分子面通量。该界面是垂直的，位于 $x = x_0$ 处，在平面外方向上具有单位深度，因此面面积等于面长度。该面横跨 $y \\in [0, H]$，其单位法向量为 $\\mathbf{n} = (1, 0)$。通过该面的无粘通量矢量为\n$$\n\\left(T \\cdot \\mathbf{n}\\right)(x_0,y) \\;=\\; \\begin{bmatrix} \\rho(x_0,y)\\, u_x(x_0,y)^2 + p(x_0,y) \\\\ \\rho(x_0,y)\\, u_x(x_0,y)\\, u_y(x_0,y) \\end{bmatrix},\n$$\n单位为牛顿每平方米（帕斯卡）乘以面积，从而得到面积分通量的单位为牛顿。您必须计算粗网格面上的面积分通量矢量，并将其与通过保守或非保守策略获得的细网格面上的面积分通量矢量之和进行比较。保守策略必须使用足够精确的高斯求积，以便在每个子面上精确计算 $y$ 的总次数最高为 $5$ 的任何多项式被积函数的积分。非保守策略必须通过中点法则（在子面中心进行一次采样乘以子面长度）来近似每个细分子面通量。所有场必须使用国际单位制（SI）：$\\rho$ 的单位是千克每立方米 (kg/m$^3$)，速度单位是米每秒 (m/s)，压力单位是帕斯卡 (Pa)，面长度单位是米 (m)，积分通量单位是牛顿 (N)。程序不应输出通量值；它应输出布尔值，指示是否在指定的绝对容差内满足保守平衡准则。\n\n实现以下解析场，它们是 $x$ 和 $y$ 的多项式：\n- 密度: $\\rho(x,y) = \\rho_0 + a_x x + a_y y$。\n- 速度分量: $u_x(x,y) = \\alpha_0 + \\alpha_1 y + \\alpha_2 y^2$ 和 $u_y(x,y) = \\beta_0 + \\beta_x x + \\beta_y y$。\n- 压力: $p(x,y) = p_0 + p_x x + p_y y$。\n\n将粗网格面定义为 $x = x_0$ 上 $y \\in [0,H]$ 的垂直线，并将其细分为 $r$ 个相等的细网格面，子面区间为 $[y_{i-1}, y_i]$，其中 $y_i = i H / r$，$i \\in \\{0,1,\\ldots,r\\}$。对于粗网格面，使用至少 $n_q = 5$ 个点的高斯求积在整个区间 $[0,H]$ 上计算积分通量矢量。对于细网格面上的保守策略，使用相同的 $n_q = 5$ 个高斯求积点计算每个细分子面积分，并将结果矢量相加。对于非保守策略，在子区间上使用中点法则（一次求值乘以子区间长度）来近似每个细分子面积分。定义绝对容差 $\\varepsilon = 10^{-10}$ 牛顿。对于每个测试用例，返回一个布尔值，当且仅当粗网格积分与细网格积分之和的差值的两个分量（x方向动量通量分量和y方向动量通量分量）的绝对值都小于或等于 $\\varepsilon$ 时，该值为真。\n\n测试套件。您的程序必须运行以下测试用例并汇总布尔结果：\n- 测试 1（理想情况，保守，存在三次被积函数）：参数 $H = 1$, $x_0 = 0.5$, $r = 2$, $\\rho_0 = 1$, $a_x = 0.2$, $a_y = 0.1$, $\\alpha_0 = 2$, $\\alpha_1 = 0.5$, $\\alpha_2 = 0$, $\\beta_0 = -1$, $\\beta_x = 0.3$, $\\beta_y = 0$, $p_0 = 100000$, $p_x = 1000$, $p_y = -500$，使用保守的细网格面积分。此测试应返回真。\n- 测试 2（边界情况，非保守中点法，加密比不是2的幂）：与测试 1 相同的参数，但 $r = 3$ 并使用中点法进行细网格面积分。此测试应返回假，因为复合中点法则无法精确积分三次被积函数，导致一个可检测到的、高于 $\\varepsilon$ 的不平衡。\n- 测试 3（覆盖高阶变化，保守）：参数 $H = 1$, $x_0 = 0.25$, $r = 4$, $\\rho_0 = 1$, $a_x = 0.1$, $a_y = -0.2$, $\\alpha_0 = 1.5$, $\\alpha_1 = 0.4$, $\\alpha_2 = 0.2$, $\\beta_0 = 0.2$, $\\beta_x = -0.1$, $\\beta_y = 0.05$, $p_0 = 101325$, $p_x = 800$, $p_y = 400$，使用保守的细网格面积分。此测试应返回真。\n\n您的程序应针对每个测试，使用指定的策略计算粗网格面上的面积分动量通量是否在容差 $\\varepsilon$ 内等于细网格面上的面积分动量通量之和。最终输出格式必须是一行，包含测试 1、2 和 3 的布尔结果列表，格式为用方括号括起来的逗号分隔列表（例如，“[True,False,True]”）。不允许有其他输出。",
            "solution": "该问题要求对无粘动量通量的守恒性质进行数值验证，这是计算流体力学中有限体积法的核心原理，尤其是在自适应网格加密（AMR）的背景下。核心任务是比较粗网格面上的积分动量通量与其子细网格面上的积分通量之和。\n\n无粘动量通量张量由 $T = \\rho \\mathbf{u} \\otimes \\mathbf{u} + p \\mathbf{I}$ 给出。对于位于 $x=x_0$ 且单位法向量为 $\\mathbf{n} = [1, 0]^T$ 的垂直面，动量通量矢量为 $F(y) = T \\cdot \\mathbf{n}$。其分量为：\n$$\nF(y) = \\begin{bmatrix} F_x(y) \\\\ F_y(y) \\end{bmatrix} = \\begin{bmatrix} \\rho(x_0,y)\\, u_x(x_0,y)^2 + p(x_0,y) \\\\ \\rho(x_0,y)\\, u_x(x_0,y)\\, u_y(x_0,y) \\end{bmatrix}\n$$\n问题将流体性质指定为空间坐标 $x$ 和 $y$ 的多项式函数。在固定的面位置 $x=x_0$ 处，它们变为\n- 密度：$\\rho(x_0,y) = (\\rho_0 + a_x x_0) + a_y y$，是关于y的1次多项式。\n- x方向速度：$u_x(x_0,y) = \\alpha_0 + \\alpha_1 y + \\alpha_2 y^2$，是关于y的2次多项式。\n- y方向速度：$u_y(x_0,y) = (\\beta_0 + \\beta_x x_0) + \\beta_y y$，是关于y的1次多项式。\n- 压力：$p(x_0,y) = (p_0 + p_x x_0) + p_y y$，是关于y的1次多项式。\n\n在粗网格面上（横跨 $y \\in [0, H]$）的总积分通量是一个矢量 $\\Phi_{\\text{coarse}} = \\int_0^H F(y) dy$。在 $r$ 个子面上的通量之和为 $\\Phi_{\\text{fine}} = \\sum_{i=1}^{r} \\int_{(i-1)H/r}^{iH/r} F(y) dy$。守恒性质表明 $\\Phi_{\\text{coarse}} = \\Phi_{\\text{fine}}$。我们必须验证每个分量是否满足 $|\\Phi_{\\text{coarse}} - \\Phi_{\\text{fine}}| \\le \\varepsilon$，其中 $\\varepsilon = 10^{-10}$。\n\n多项式被积函数的次数决定了数值求积的精度。\n- x方向动量通量 $F_x(y) = \\rho(y) u_x(y)^2 + p(y)$ 是一个次数最高为 $\\text{deg}(\\rho) + 2 \\times \\text{deg}(u_x) = 1 + 2 \\times 2 = 5$ 的多项式。\n- y方向动量通量 $F_y(y) = \\rho(y) u_x(y) u_y(y)$ 是一个次数最高为 $\\text{deg}(\\rho) + \\text{deg}(u_x) + \\text{deg}(u_y) = 1 + 2 + 1 = 4$ 的多项式。\n\n测试了两种数值策略。\n\n1.  **保守策略：** 此策略采用高斯-勒让德求积。一个具有 $n_q$ 个点的高斯求积法则可以精确地积分次数最高为 $2n_q - 1$ 的任何多项式。问题指定使用至少 $n_q=5$ 个点。对于 $n_q=5$，该法则对次数最高为 $2 \\times 5 - 1 = 9$ 的多项式是精确的。由于我们被积函数的最高次数是 5，所以 5 点高斯求积将精确计算积分（在机器精度范围内）。根据积分的线性性质，$\\int_0^H F(y) dy = \\sum_{i=1}^{r} \\int_{y_{i-1}}^{y_i} F(y) dy$。由于数值方法对所涉及的所有积分都是精确的，计算出的粗网格通量将等于计算出的细网格通量之和。这就是为什么使用此策略的测试 1 和 3 预期会通过。\n\n2.  **非保守策略：** 此策略使用中点法则，该法则通过被积函数在区间中点的值乘以区间长度来近似积分：$\\int_a^b f(y) dy \\approx f((a+b)/2) \\times (b-a)$。中点法则是 1 点牛顿-柯特斯公式，仅对次数最高为 1 的多项式是精确的。在测试 2 中，x方向动量通量的被积函数 $F_x(y)$ 是一个 3 次多项式（因为 $\\alpha_2=0$，所以 $\\text{deg}(u_x)=1$，因此 $\\text{deg}(F_x) = 1 + 2\\times 1 = 3$），而y方向动量通量的被积函数 $F_y(y)$ 是一个 2 次多项式。在对这些更高次多项式进行积分时，中点法则将产生显著误差。因此，细网格面上的近似通量之和将不等于粗网格面上的“精确”通量（用高阶求积计算），其差值将超过容差 $\\varepsilon$。因此，测试 2 预期会失败。\n\n实现遵循这些原则。构建一个 Python 程序来：\n- 根据提供的多项式形式定义场函数和通量函数。\n- 使用来自 `numpy.polynomial.legendre.leggauss` 的点和权重，为给定点数 $n_q=5$ 实现一个高斯求积例程。该例程将标准 $[-1, 1]$ 区间正确映射到任意积分域 $[a,b]$。\n- 遍历每个测试用例，设置特定参数。\n- 对于每个测试用例，使用高斯求积例程计算粗网格面通量。\n- 根据指定，使用保守（在每个子面上进行高斯求积）或非保守（在每个子面上使用中点法则）策略计算细网格面通量之和。\n- 计算粗网格通量矢量与细网格通量总和矢量之间的绝对差，并检查两个分量是否都在容差 $\\varepsilon$ 之内。\n- 存储得到的布尔值，并按要求格式化最终输出。\n这种方法系统地验证了问题中关于数值守恒的论断。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the AMR momentum flux conservation property for given analytic fields.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1, \"strategy\": \"conservative\", \"H\": 1.0, \"x0\": 0.5, \"r\": 2,\n            \"rho0\": 1.0, \"ax\": 0.2, \"ay\": 0.1,\n            \"alpha0\": 2.0, \"alpha1\": 0.5, \"alpha2\": 0.0,\n            \"beta0\": -1.0, \"beta_x\": 0.3, \"beta_y\": 0.0,\n            \"p0\": 100000.0, \"px\": 1000.0, \"py\": -500.0\n        },\n        {\n            \"id\": 2, \"strategy\": \"midpoint\", \"H\": 1.0, \"x0\": 0.5, \"r\": 3,\n            \"rho0\": 1.0, \"ax\": 0.2, \"ay\": 0.1,\n            \"alpha0\": 2.0, \"alpha1\": 0.5, \"alpha2\": 0.0,\n            \"beta0\": -1.0, \"beta_x\": 0.3, \"beta_y\": 0.0,\n            \"p0\": 100000.0, \"px\": 1000.0, \"py\": -500.0\n        },\n        {\n            \"id\": 3, \"strategy\": \"conservative\", \"H\": 1.0, \"x0\": 0.25, \"r\": 4,\n            \"rho0\": 1.0, \"ax\": 0.1, \"ay\": -0.2,\n            \"alpha0\": 1.5, \"alpha1\": 0.4, \"alpha2\": 0.2,\n            \"beta0\": 0.2, \"beta_x\": -0.1, \"beta_y\": 0.05,\n            \"p0\": 101325.0, \"px\": 800.0, \"py\": 400.0\n        }\n    ]\n\n    epsilon = 1.0e-10\n    n_q = 5\n\n    def flux_vector(y, params, x0):\n        \"\"\"\n        Calculates the inviscid momentum flux vector at a given y-coordinate (or array of y-coords).\n        \"\"\"\n        # Evaluate primitive variables at (x0, y)\n        rho_val = params['rho0'] + params['ax'] * x0 + params['ay'] * y\n        ux_val = params['alpha0'] + params['alpha1'] * y + params['alpha2'] * y**2\n        uy_val = params['beta0'] + params['beta_x'] * x0 + params['beta_y'] * y\n        p_val = params['p0'] + params['px'] * x0 + params['py'] * y\n\n        # Calculate flux components\n        flux_x = rho_val * ux_val**2 + p_val\n        flux_y = rho_val * ux_val * uy_val\n\n        return np.array([flux_x, flux_y])\n\n    # Pre-compute\n    xi_gauss, w_gauss = np.polynomial.legendre.leggauss(n_q)\n\n    def integrate_gauss(func, a, b):\n        \"\"\"\n        Performs Gaussian quadrature of a vector-valued function over the interval [a, b].\n        \"\"\"\n        # Transform quadrature points from [-1, 1] to [a, b]\n        y_points = 0.5 * (b - a) * xi_gauss + 0.5 * (a + b)\n        \n        # Evaluate the function at the quadrature points\n        f_values = func(y_points)  # Expected shape (2, n_q)\n        \n        # Compute the integral using matrix-vector product\n        integral = 0.5 * (b - a) * (f_values @ w_gauss)\n        return integral\n\n    results = []\n    for case in test_cases:\n        H = case['H']\n        x0 = case['x0']\n        r = case['r']\n        strategy = case['strategy']\n\n        # Create a closure for the flux function with the current case's parameters\n        def F_y(y):\n            return flux_vector(y, case, x0)\n\n        # 1. Compute coarse face integral\n        coarse_flux = integrate_gauss(F_y, 0.0, H)\n\n        # 2. Compute sum of fine face integrals\n        sum_fine_fluxes = np.zeros(2)\n        dy = H / r\n        if strategy == 'conservative':\n            for i in range(r):\n                y_start = i * dy\n                y_end = (i + 1) * dy\n                sum_fine_fluxes += integrate_gauss(F_y, y_start, y_end)\n        elif strategy == 'midpoint':\n            for i in range(r):\n                y_mid = (i + 0.5) * dy\n                sum_fine_fluxes += F_y(y_mid) * dy\n        \n        # 3. Compare results and check against tolerance\n        diff = coarse_flux - sum_fine_fluxes\n        is_conserved = np.all(np.abs(diff) = epsilon)\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}