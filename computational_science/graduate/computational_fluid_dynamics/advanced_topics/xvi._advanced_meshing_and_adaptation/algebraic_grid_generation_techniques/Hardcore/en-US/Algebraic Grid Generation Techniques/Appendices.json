{
    "hands_on_practices": [
        {
            "introduction": "Resolving the steep gradients within boundary layers is a critical challenge in computational fluid dynamics. This often requires a grid that is highly refined near solid walls and gradually coarsens away from them. This first practice focuses on the fundamental technique for achieving such a distribution: constructing a one-dimensional stretched grid using a geometric progression. By implementing this method, you will gain hands-on experience with core concepts like growth factors and smoothness criteria, and develop a practical, numerically robust tool for wall-normal grid generation. ",
            "id": "3290607",
            "problem": "Construct a one-dimensional, wall-normal algebraic grid appropriate for Computational Fluid Dynamics (CFD) using a geometric progression of layer thicknesses. Work in a fully non-dimensionalized setting so that all quantities are dimensionless. Begin from the following fundamental base: the definition of a geometric sequence and the definition of cumulative sums. Let the first layer thickness be denoted by $\\Delta y_{1}  0$, the growth factor by $r  0$, and the total number of nodes by $N \\in \\mathbb{N}$ with $N \\geq 1$. Define the sequence of layer thicknesses $\\{s_{k}\\}_{k=1}^{N-1}$ by $s_{1} = \\Delta y_{1}$ and $s_{k} = s_{1}\\, r^{k-1}$ for $k \\geq 2$. Define the node indices $k \\in \\{0,1,\\dots,N-1\\}$, set $y_{0} = 0$, and define the node positions recursively by $y_{k} = \\sum_{j=1}^{k} s_{j}$ for $k \\geq 1$. Also define the adjacent-spacing ratios $q_{k} = s_{k}/s_{k-1}$ for $k \\geq 2$. The grid is said to satisfy a smoothness criterion if all defined ratios $q_{k}$ lie within prescribed inclusive bounds $[\\underline{q},\\overline{q}]$, where $\\underline{q}  0$ and $\\overline{q}  0$ are given.\n\nTasks:\n- Starting strictly from the definitions above and the well-tested formula for the partial sum of a geometric series, derive a closed-form expression for $y_{k}$ for $r \\neq 1$ and its limiting expression for $r \\to 1$. Implement a numerically robust computation that is accurate when $r$ is close to $1$.\n- Compute the vector of node positions $\\{y_{k}\\}_{k=0}^{N-1}$ and the final height $H = y_{N-1}$.\n- Assess smoothness by evaluating whether all applicable ratios $q_{k}$ for $k \\in \\{2,\\dots,N-1\\}$ satisfy $\\underline{q} \\le q_{k} \\le \\overline{q}$. If there are no such $q_{k}$ (for example, if $N \\le 2$), treat the smoothness criterion as satisfied. Additionally, ensure that the sequence $\\{y_{k}\\}$ is strictly increasing, consistent with $\\Delta y_{1}  0$ and $r  0$.\n\nYour program must implement the above and, for each test case, produce a two-element list $[H,\\text{is\\_smooth}]$, where $H$ is a float equal to $y_{N-1}$ and $\\text{is\\_smooth}$ is a boolean indicating whether the smoothness criterion holds and the nodes are strictly increasing. Aggregate the results for all test cases into a single list and print a single line containing this aggregate list in standard Python list syntax.\n\nUse the following test suite of parameter values, each specified as $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q})$:\n- Test A: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.02,\\, 1.2,\\, 6,\\, 1.1,\\, 1.3\\,)$.\n- Test B: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.015,\\, 1.0,\\, 5,\\, 0.98,\\, 1.02\\,)$.\n- Test C: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.01,\\, 0.8,\\, 8,\\, 0.75,\\, 0.85\\,)$.\n- Test D: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.02,\\, 1.5,\\, 7,\\, 1.1,\\, 1.4\\,)$.\n- Test E: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.01,\\, 1.3,\\, 1,\\, 1.0,\\, 1.5\\,)$.\n- Test F: $(\\Delta y_{1}, r, N, \\underline{q}, \\overline{q}) = (\\,0.02,\\, 1.0000000001,\\, 4,\\, 0.999999,\\, 1.000001\\,)$.\n\nFinal output format: Your program should produce a single line of output containing a Python list of per-test results, where each per-test result is itself a two-element list $[H,\\text{is\\_smooth}]$. For example, a syntactic template is $[[H_{A},\\text{is\\_smooth}_{A}], [H_{B},\\text{is\\_smooth}_{B}], \\dots]$. All outputs are unitless real numbers and booleans. Angles are not involved, and no percentages are used. The output must be printed on a single line with no additional text.",
            "solution": "The problem requires the construction and validation of a one-dimensional algebraic grid. The solution proceeds by first deriving the necessary analytical expressions from the provided definitions and then establishing the procedure for validation.\n\nThe positions of the grid nodes $\\{y_{k}\\}_{k=0}^{N-1}$ are defined relative to a wall at $y_{0} = 0$. For $k \\geq 1$, the position $y_{k}$ is the cumulative sum of the thicknesses of the preceding layers. The thickness of the $j$-th layer, $s_{j}$, is given by a geometric progression:\n$$s_{j} = \\Delta y_{1} r^{j-1} \\quad \\text{for } j \\in \\{1, 2, \\dots, N-1\\}$$\nwhere $\\Delta y_{1}  0$ is the first layer thickness and $r  0$ is the growth factor.\n\nThe position $y_{k}$ for $k \\geq 1$ is thus the sum of the first $k$ terms of this geometric sequence:\n$$y_{k} = \\sum_{j=1}^{k} s_{j} = \\sum_{j=1}^{k} \\Delta y_{1} r^{j-1} = \\Delta y_{1} \\sum_{j=0}^{k-1} r^{j}$$\nThis is the partial sum of a geometric series.\n\nFor the case where the growth factor $r \\neq 1$, the sum has a well-known closed-form expression:\n$$\\sum_{j=0}^{k-1} r^{j} = \\frac{1-r^{k}}{1-r}$$\nSubstituting this into the expression for $y_{k}$ yields:\n$$y_{k} = \\Delta y_{1} \\frac{1-r^{k}}{1-r} \\quad (r \\neq 1)$$\n\nFor the case where $r = 1$, the layer thicknesses are all equal, $s_{j} = \\Delta y_{1}$. The sum becomes:\n$$y_{k} = \\sum_{j=1}^{k} \\Delta y_{1} = k \\Delta y_{1} \\quad (r=1)$$\nThis result can also be obtained by taking the limit of the general expression for $y_{k}$ as $r \\to 1$. Using L'Hôpital's rule for the indeterminate form $0/0$:\n$$\\lim_{r \\to 1} y_{k} = \\Delta y_{1} \\lim_{r \\to 1} \\frac{1-r^{k}}{1-r} = \\Delta y_{1} \\lim_{r \\to 1} \\frac{\\frac{d}{dr}(1-r^{k})}{\\frac{d}{dr}(1-r)} = \\Delta y_{1} \\lim_{r \\to 1} \\frac{-k r^{k-1}}{-1} = k \\Delta y_{1}$$\n\nFor numerical implementation, the formula for $r \\neq 1$ suffers from catastrophic cancellation when $r$ is close to $1$, as both the numerator and denominator approach zero. To create a numerically robust computation, we can rewrite the expression in terms of exponential and logarithmic functions:\n$$\\frac{1-r^{k}}{1-r} = \\frac{r^{k}-1}{r-1} = \\frac{\\exp(k \\ln r) - 1}{\\exp(\\ln r) - 1}$$\nThis form can be computed accurately using specialized library functions such as `expm1(x)`, which calculates $\\exp(x)-1$ with high precision for small $x$. This avoids the loss of significance. The implementation will use this robust formula for all $r \\neq 1$.\n\nThe total height of the grid is $H = y_{N-1}$, which is the position of the last node.\n\nThe validation of the grid involves two criteria: smoothness and monotonicity.\n\nFirst, the smoothness criterion requires the adjacent-spacing ratio $q_{k}$ to be within the inclusive bounds $[\\underline{q}, \\overline{q}]$ for all applicable indices. The ratio is defined as $q_{k} = s_{k}/s_{k-1}$ for $k \\in \\{2, \\dots, N-1\\}$. Substituting the definition of $s_{k}$:\n$$q_{k} = \\frac{s_{k}}{s_{k-1}} = \\frac{\\Delta y_{1} r^{k-1}}{\\Delta y_{1} r^{(k-1)-1}} = \\frac{r^{k-1}}{r^{k-2}} = r$$\nThe ratio $q_{k}$ is constant and equal to the growth factor $r$. Thus, the smoothness check simplifies to verifying if $\\underline{q} \\le r \\le \\overline{q}$. This check is only performed if the set of indices $\\{2, \\dots, N-1\\}$ is non-empty, which occurs when $N  2$. If $N \\le 2$, the smoothness criterion is vacuously satisfied as specified in the problem.\n\nSecond, the node positions $\\{y_{k}\\}$ must form a strictly increasing sequence. This requires $y_{k}  y_{k-1}$ for all $k \\in \\{1, \\dots, N-1\\}$. The difference between adjacent node positions is:\n$$y_{k} - y_{k-1} = \\left(\\sum_{j=1}^{k} s_{j}\\right) - \\left(\\sum_{j=1}^{k-1} s_{j}\\right) = s_{k}$$\nThe condition for strict monotonicity is therefore $s_{k}  0$ for $k \\in \\{1, \\dots, N-1\\}$. Since $s_{k} = \\Delta y_{1} r^{k-1}$, and the problem states that $\\Delta y_{1}  0$ and $r  0$, it follows that $r^{k-1}  0$ for any integer $k \\geq 1$. Consequently, $s_{k}$ is always positive. The monotonicity condition is therefore inherently satisfied by the problem's constraints. Nevertheless, the implementation will explicitly check this property for full rigor.\n\nThe final boolean result for each test case is the logical conjunction of the outcomes of the smoothness and monotonicity checks.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the algebraic grid generation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (delta_y1, r, N, q_min, q_max)\n        (0.02, 1.2, 6, 1.1, 1.3),\n        (0.015, 1.0, 5, 0.98, 1.02),\n        (0.01, 0.8, 8, 0.75, 0.85),\n        (0.02, 1.5, 7, 1.1, 1.4),\n        (0.01, 1.3, 1, 1.0, 1.5),\n        (0.02, 1.0000000001, 4, 0.999999, 1.000001),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_y1, r, N, q_min, q_max = case\n\n        # --- Node Position Calculation ---\n        y_nodes = np.zeros(N, dtype=np.float64)\n        \n        if N  1:\n            if r == 1.0:\n                # Linear spacing for r = 1\n                for k in range(1, N):\n                    y_nodes[k] = k * delta_y1\n            else:\n                # Geometric spacing for r != 1, using a numerically robust formula\n                log_r = np.log(r)\n                expm1_log_r = np.expm1(log_r)\n                \n                for k in range(1, N):\n                    # Robust calculation of (r^k - 1) / (r - 1)\n                    factor = np.expm1(k * log_r) / expm1_log_r\n                    y_nodes[k] = delta_y1 * factor\n        \n        # The final height H is the position of the last node, y_{N-1}.\n        # For N=1, y_nodes is [0.], so y_nodes[-1] correctly yields 0.\n        H = y_nodes[-1]\n\n        # --- Validation ---\n        \n        # 1. Smoothness check\n        # The adjacent spacing ratio q_k is constant and equals r.\n        # The check only applies if N  2, otherwise it's vacuously true.\n        is_smoothness_ok = True\n        if N  2:\n            if not (q_min = r = q_max):\n                is_smoothness_ok = False\n        \n        # 2. Strict monotonicity check\n        # The constraint delta_y1  0 and r  0 ensures this mathematically.\n        # This check is included for computational rigor.\n        is_monotonic = True\n        if N  1:\n            for k in range(1, N):\n                if y_nodes[k] = y_nodes[k-1]:\n                    is_monotonic = False\n                    break\n        \n        # Combine both conditions for the final boolean result\n        is_valid_grid = is_smoothness_ok and is_monotonic\n\n        results.append([H, is_valid_grid])\n\n    # Format the final list of results into the specified string format.\n    # The default str() for a list is '[item1, item2, ...]'\n    # The default str() for a float and bool match Python syntax.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having mastered a 1D stretched grid, we now advance to two dimensions. This practice introduces Transfinite Interpolation (TFI), a powerful algebraic technique for generating a structured grid that precisely matches a set of four arbitrary boundary curves. You will derive the TFI mapping from first principles, combining one-dimensional interpolations and applying the inclusion-exclusion principle to handle corner data correctly. This exercise is essential for understanding the theoretical foundation of many algebraic grid generators and for developing the skill to create body-fitted coordinate systems for complex geometries. ",
            "id": "3290639",
            "problem": "In algebraic grid generation for computational fluid dynamics, an interior mapping is constructed over the unit square parameter domain $[0,1] \\times [0,1]$ from four analytic edge curves, two given as functions of the horizontal parameter $\\xi$ and two as functions of the vertical parameter $\\eta$. Consider the following four boundary curves in the physical plane $\\mathbb{R}^{2}$:\n- Bottom edge (parametrized by $\\xi$): $\\mathbf{c}_{1}(\\xi) = \\big(\\,\\xi + \\xi^{2}, \\tfrac{1}{2}\\,\\xi\\,\\big)$.\n- Top edge (parametrized by $\\xi$): $\\mathbf{c}_{2}(\\xi) = \\big(\\,1 + \\tfrac{1}{2}\\cos(\\pi \\xi),\\, 1 + \\tfrac{1}{2}\\sin(\\pi \\xi)\\,\\big)$.\n- Left edge (parametrized by $\\eta$): $\\mathbf{d}_{1}(\\eta) = \\big(\\,\\tfrac{3}{2}\\,\\eta^{2},\\, \\eta\\,\\big)$.\n- Right edge (parametrized by $\\eta$): $\\mathbf{d}_{2}(\\eta) = \\big(\\,2 - \\tfrac{3}{2}\\,\\eta,\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\,\\eta\\,\\big)$.\n\nThese curves are consistent at the four corners in the sense that $\\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0)$, $\\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0)$, $\\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1)$, and $\\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1)$.\n\nUsing only the following fundamental base: (i) one-dimensional linear interpolation along a parameter line, and (ii) inclusion–exclusion to correct for double-counted corner contributions, construct from first principles a two-dimensional algebraic mapping $\\mathbf{x}(\\xi,\\eta)$ over $[0,1] \\times [0,1]$ that blends these edges and reproduces them exactly on the boundary. Prove that your construction satisfies the boundary reproduction properties $\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi)$, $\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi)$, $\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta)$, and $\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta)$.\n\nFinally, evaluate the resulting transfinite interpolation (TFI) mapping at the interior point $(\\xi_{0},\\eta_{0}) = \\big(\\tfrac{1}{3}, \\tfrac{2}{5}\\big)$, and give $\\mathbf{x}(\\tfrac{1}{3}, \\tfrac{2}{5})$ as an exact analytic expression. Express your final answer as a two-component row vector. No rounding is required.",
            "solution": "The goal is to derive a two-dimensional algebraic mapping that interpolates the four boundary curves and reproduces them on the boundary. The derivation proceeds from the following foundational ideas:\n\n1. One-dimensional linear interpolation along a coordinate line in the parameter domain. Given two vector-valued functions $\\mathbf{a}(\\xi)$ and $\\mathbf{b}(\\xi)$ associated with $\\eta=0$ and $\\eta=1$, a linear blend along $\\eta$ is\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{a}(\\xi) + \\eta\\,\\mathbf{b}(\\xi).\n$$\nSimilarly, along $\\xi$ with two vector-valued functions $\\mathbf{p}(\\eta)$ and $\\mathbf{q}(\\eta)$ associated with $\\xi=0$ and $\\xi=1$, a linear blend is\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{p}(\\eta) + \\xi\\,\\mathbf{q}(\\eta).\n$$\n\n2. Inclusion–exclusion (or boolean sum) to correct for double counting. If we simply add the two one-dimensional blends $\\mathbf{L}_{\\eta}$ and $\\mathbf{L}_{\\xi}$, the corner points become counted twice. To remove the overcount, we subtract a bilinear interpolation of the four corner points with the standard bilinear shape functions $N_{00}=(1-\\xi)(1-\\eta)$, $N_{10}=\\xi(1-\\eta)$, $N_{01}=(1-\\xi)\\eta$, $N_{11}=\\xi\\eta$.\n\nWe first identify the corner points, which must be mutually consistent:\n$$\n\\mathbf{x}_{00} = \\mathbf{c}_{1}(0) = \\mathbf{d}_{1}(0),\\quad\n\\mathbf{x}_{10} = \\mathbf{c}_{1}(1) = \\mathbf{d}_{2}(0),\\quad\n\\mathbf{x}_{01} = \\mathbf{c}_{2}(0) = \\mathbf{d}_{1}(1),\\quad\n\\mathbf{x}_{11} = \\mathbf{c}_{2}(1) = \\mathbf{d}_{2}(1).\n$$\nFrom the data,\n$$\n\\mathbf{x}_{00} = (0,0),\\quad\n\\mathbf{x}_{10} = (2,\\tfrac{1}{2}),\\quad\n\\mathbf{x}_{01} = (\\tfrac{3}{2},1),\\quad\n\\mathbf{x}_{11} = (\\tfrac{1}{2},1).\n$$\n\nConstruct the one-dimensional blends using the given edges:\n- Along $\\eta$ between $\\mathbf{c}_{1}(\\xi)$ and $\\mathbf{c}_{2}(\\xi)$:\n$$\n\\mathbf{L}_{\\eta}(\\xi,\\eta) = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi).\n$$\n- Along $\\xi$ between $\\mathbf{d}_{1}(\\eta)$ and $\\mathbf{d}_{2}(\\eta)$:\n$$\n\\mathbf{L}_{\\xi}(\\xi,\\eta) = (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta).\n$$\n\nTo correct double counting of corners, subtract the bilinear corner interpolation\n$$\n\\mathbf{B}(\\xi,\\eta) = (1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}.\n$$\n\nThus, the transfinite interpolation (TFI) mapping constructed from first principles is\n$$\n\\mathbf{x}(\\xi,\\eta) \\;=\\; \\mathbf{L}_{\\eta}(\\xi,\\eta) \\;+\\; \\mathbf{L}_{\\xi}(\\xi,\\eta) \\;-\\; \\mathbf{B}(\\xi,\\eta).\n$$\n\nWe now verify boundary reproduction:\n\n1. Bottom edge $\\eta=0$:\nSubstitute $\\eta=0$:\n$$\n\\mathbf{x}(\\xi,0) = (1-0)\\mathbf{c}_{1}(\\xi) + 0\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(0) + \\xi \\mathbf{d}_{2}(0) - \\big[(1-\\xi)(1-0)\\mathbf{x}_{00} + \\xi(1-0)\\mathbf{x}_{10} + (1-\\xi)0\\,\\mathbf{x}_{01} + \\xi 0\\,\\mathbf{x}_{11}\\big].\n$$\nSince $\\mathbf{d}_{1}(0)=\\mathbf{x}_{00}$ and $\\mathbf{d}_{2}(0)=\\mathbf{x}_{10}$, the latter two terms cancel exactly with the bilinear corner terms, leaving\n$$\n\\mathbf{x}(\\xi,0) = \\mathbf{c}_{1}(\\xi).\n$$\n\n2. Top edge $\\eta=1$:\nSimilarly,\n$$\n\\mathbf{x}(\\xi,1) = (1-1)\\mathbf{c}_{1}(\\xi) + 1\\cdot \\mathbf{c}_{2}(\\xi) + (1-\\xi)\\mathbf{d}_{1}(1) + \\xi \\mathbf{d}_{2}(1) - \\big[(1-\\xi)0\\,\\mathbf{x}_{00} + \\xi 0\\,\\mathbf{x}_{10} + (1-\\xi)1\\,\\mathbf{x}_{01} + \\xi 1\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{d}_{1}(1)=\\mathbf{x}_{01}$ and $\\mathbf{d}_{2}(1)=\\mathbf{x}_{11}$, the last two terms cancel with the subtracted corner terms, giving\n$$\n\\mathbf{x}(\\xi,1) = \\mathbf{c}_{2}(\\xi).\n$$\n\n3. Left edge $\\xi=0$:\n$$\n\\mathbf{x}(0,\\eta) = (1-\\eta)\\mathbf{c}_{1}(0) + \\eta \\mathbf{c}_{2}(0) + (1-0)\\mathbf{d}_{1}(\\eta) + 0\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-0)(1-\\eta)\\mathbf{x}_{00} + 0(1-\\eta)\\mathbf{x}_{10} + (1-0)\\eta\\,\\mathbf{x}_{01} + 0\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{c}_{1}(0)=\\mathbf{x}_{00}$ and $\\mathbf{c}_{2}(0)=\\mathbf{x}_{01}$, the added terms cancel with the subtracted bilinear corner terms, yielding\n$$\n\\mathbf{x}(0,\\eta) = \\mathbf{d}_{1}(\\eta).\n$$\n\n4. Right edge $\\xi=1$:\n$$\n\\mathbf{x}(1,\\eta) = (1-\\eta)\\mathbf{c}_{1}(1) + \\eta \\mathbf{c}_{2}(1) + (1-1)\\mathbf{d}_{1}(\\eta) + 1\\cdot \\mathbf{d}_{2}(\\eta) - \\big[(1-1)(1-\\eta)\\mathbf{x}_{00} + 1(1-\\eta)\\mathbf{x}_{10} + (1-1)\\eta\\,\\mathbf{x}_{01} + 1\\cdot \\eta\\,\\mathbf{x}_{11}\\big].\n$$\nUsing $\\mathbf{c}_{1}(1)=\\mathbf{x}_{10}$ and $\\mathbf{c}_{2}(1)=\\mathbf{x}_{11}$, again the terms cancel, giving\n$$\n\\mathbf{x}(1,\\eta) = \\mathbf{d}_{2}(\\eta).\n$$\nTherefore, the mapping reproduces all four boundaries exactly.\n\nWe now evaluate $\\mathbf{x}(\\xi,\\eta)$ at $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$ using the explicit data.\n\nCompute the edge values at the specified parameters:\n$$\n\\mathbf{c}_{1}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(\\tfrac{1}{3} + \\tfrac{1}{9},\\, \\tfrac{1}{2}\\cdot \\tfrac{1}{3}\\Big) = \\Big(\\tfrac{4}{9},\\, \\tfrac{1}{6}\\Big),\n$$\n$$\n\\mathbf{c}_{2}\\!\\big(\\tfrac{1}{3}\\big) = \\Big(1 + \\tfrac{1}{2}\\cos\\tfrac{\\pi}{3},\\, 1 + \\tfrac{1}{2}\\sin\\tfrac{\\pi}{3}\\Big) = \\Big(1 + \\tfrac{1}{2}\\cdot \\tfrac{1}{2},\\, 1 + \\tfrac{1}{2}\\cdot \\tfrac{\\sqrt{3}}{2}\\Big) = \\Big(\\tfrac{5}{4},\\, 1 + \\tfrac{\\sqrt{3}}{4}\\Big),\n$$\n$$\n\\mathbf{d}_{1}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(\\tfrac{3}{2}\\cdot \\big(\\tfrac{2}{5}\\big)^{2},\\, \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{6}{25},\\, \\tfrac{2}{5}\\Big),\n$$\n$$\n\\mathbf{d}_{2}\\!\\big(\\tfrac{2}{5}\\big) = \\Big(2 - \\tfrac{3}{2}\\cdot \\tfrac{2}{5},\\, \\tfrac{1}{2} + \\tfrac{1}{2}\\cdot \\tfrac{2}{5}\\Big) = \\Big(\\tfrac{7}{5},\\, \\tfrac{7}{10}\\Big).\n$$\nThe corner points are\n$$\n\\mathbf{x}_{00}=(0,0),\\quad \\mathbf{x}_{10}=(2,\\tfrac{1}{2}),\\quad \\mathbf{x}_{01}=(\\tfrac{3}{2},1),\\quad \\mathbf{x}_{11}=(\\tfrac{1}{2},1).\n$$\n\nWith $(\\xi,\\eta)=\\big(\\tfrac{1}{3},\\tfrac{2}{5}\\big)$, the mapping evaluates to\n$$\n\\mathbf{x} = (1-\\eta)\\,\\mathbf{c}_{1}(\\xi) + \\eta\\,\\mathbf{c}_{2}(\\xi) + (1-\\xi)\\,\\mathbf{d}_{1}(\\eta) + \\xi\\,\\mathbf{d}_{2}(\\eta) \\;-\\; \\Big[(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} + \\xi(1-\\eta)\\,\\mathbf{x}_{10} + (1-\\xi)\\eta\\,\\mathbf{x}_{01} + \\xi\\eta\\,\\mathbf{x}_{11}\\Big].\n$$\nCompute the scalar weights:\n$$\n1-\\eta = \\tfrac{3}{5},\\quad 1-\\xi = \\tfrac{2}{3},\\quad \\xi = \\tfrac{1}{3},\\quad \\eta = \\tfrac{2}{5}.\n$$\nFirst, the four blended terms:\n$$\n(1-\\eta)\\,\\mathbf{c}_{1}(\\xi) = \\tfrac{3}{5}\\,\\Big(\\tfrac{4}{9},\\,\\tfrac{1}{6}\\Big) = \\Big(\\tfrac{4}{15},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n\\eta\\,\\mathbf{c}_{2}(\\xi) = \\tfrac{2}{5}\\,\\Big(\\tfrac{5}{4},\\,1 + \\tfrac{\\sqrt{3}}{4}\\Big) = \\Big(\\tfrac{1}{2},\\, \\tfrac{2}{5} + \\tfrac{\\sqrt{3}}{10}\\Big),\n$$\n$$\n(1-\\xi)\\,\\mathbf{d}_{1}(\\eta) = \\tfrac{2}{3}\\,\\Big(\\tfrac{6}{25},\\,\\tfrac{2}{5}\\Big) = \\Big(\\tfrac{4}{25},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\,\\mathbf{d}_{2}(\\eta) = \\tfrac{1}{3}\\,\\Big(\\tfrac{7}{5},\\,\\tfrac{7}{10}\\Big) = \\Big(\\tfrac{7}{15},\\,\\tfrac{7}{30}\\Big).\n$$\nSumming these four terms gives\n$$\n\\mathbf{S}_{1} = \\Big(\\tfrac{209}{150},\\, 1 + \\tfrac{\\sqrt{3}}{10}\\Big).\n$$\n\nNext, the bilinear corner subtraction:\n$$\n(1-\\xi)(1-\\eta)\\,\\mathbf{x}_{00} = \\tfrac{2}{5}\\,(0,0) = (0,0),\n$$\n$$\n\\xi(1-\\eta)\\,\\mathbf{x}_{10} = \\tfrac{1}{5}\\,(2,\\tfrac{1}{2}) = \\Big(\\tfrac{2}{5},\\,\\tfrac{1}{10}\\Big),\n$$\n$$\n(1-\\xi)\\eta\\,\\mathbf{x}_{01} = \\tfrac{4}{15}\\,(\\tfrac{3}{2},1) = \\Big(\\tfrac{2}{5},\\,\\tfrac{4}{15}\\Big),\n$$\n$$\n\\xi\\eta\\,\\mathbf{x}_{11} = \\tfrac{2}{15}\\,(\\tfrac{1}{2},1) = \\Big(\\tfrac{1}{15},\\,\\tfrac{2}{15}\\Big).\n$$\nSumming these four terms yields\n$$\n\\mathbf{S}_{2} = \\Big(\\tfrac{13}{15},\\, \\tfrac{1}{2}\\Big).\n$$\n\nTherefore,\n$$\n\\mathbf{x}\\!\\Big(\\tfrac{1}{3},\\tfrac{2}{5}\\Big) \\;=\\; \\mathbf{S}_{1} - \\mathbf{S}_{2} \\;=\\; \\Big(\\tfrac{209}{150} - \\tfrac{13}{15},\\, 1 + \\tfrac{\\sqrt{3}}{10} - \\tfrac{1}{2}\\Big) \\;=\\; \\Big(\\tfrac{79}{150},\\, \\tfrac{5+\\sqrt{3}}{10}\\Big).\n$$\nThis is an exact analytic expression for the interior point produced by the constructed transfinite interpolation mapping, and the boundary reproduction properties have been established from first principles via one-dimensional blending and inclusion–exclusion.",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{79}{150}  \\frac{5+\\sqrt{3}}{10}\\end{pmatrix}}$$"
        },
        {
            "introduction": "The Transfinite Interpolation framework is not a single, rigid method; its power lies in its flexibility, particularly in the choice of blending functions. This final practice explores that flexibility by comparing two different TFI schemes: a standard bilinear interpolation and a Coons patch constructed with cubic blending functions. By implementing both and evaluating their results using quantitative metrics for grid skewness and smoothness, you will gain insight into how mathematical choices directly influence grid quality. This comparative analysis develops a more nuanced understanding of grid generation, moving from simply creating a grid to engineering one that is optimized for numerical accuracy and efficiency. ",
            "id": "3290621",
            "problem": "You are tasked with constructing and comparing two algebraic structured grids in the plane generated from the same four boundary curves using two different transfinite interpolation strategies. Your program must implement both strategies from first principles, compute two quantitative grid quality metrics for each grid, and then aggregate results across a specified test suite.\n\nThe setting is as follows. Let there be a mapping from a computational rectangle to a physical domain given by a vector-valued function $\\mathbf{X}(\\xi,\\eta) \\in \\mathbb{R}^2$ with $(\\xi,\\eta) \\in [0,1]\\times[0,1]$. The mapping must interpolate the four boundary curves $\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$, $\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$, $\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$, and $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$, and be consistent at corners, meaning $\\mathbf{B}_0(0) = \\mathbf{C}_0(0)$, $\\mathbf{B}_0(1) = \\mathbf{C}_1(0)$, $\\mathbf{B}_1(0) = \\mathbf{C}_0(1)$, and $\\mathbf{B}_1(1) = \\mathbf{C}_1(1)$.\n\nYour grid generator must be built by transfinite interpolation from the four boundary curves using blending functions that satisfy the partition-of-unity and endpoint conditions. Specifically, let $g_0(\\xi)$ and $g_1(\\xi)$ be blending functions in the $\\xi$-direction and $h_0(\\eta)$ and $h_1(\\eta)$ be blending functions in the $\\eta$-direction such that $g_0(\\xi) + g_1(\\xi) = 1$, $h_0(\\eta) + h_1(\\eta) = 1$, $g_0(0) = 1$, $g_0(1) = 0$, $g_1(0) = 0$, $g_1(1) = 1$, and similarly $h_0(0) = 1$, $h_0(1) = 0$, $h_1(0) = 0$, $h_1(1) = 1$. Starting from these definitions and the requirement that the mapping interpolates the boundary curves, derive the transfinite interpolation formula for $\\mathbf{X}(\\xi,\\eta)$ consistent with inclusion-exclusion to avoid double counting of corner data.\n\nYou must construct and compare two grids on the same boundary curves:\n- Grid A (bilinear transfinite interpolation): choose linear blending functions $g_1(\\xi) = \\xi$, $g_0(\\xi) = 1 - \\xi$, $h_1(\\eta) = \\eta$, $h_0(\\eta) = 1 - \\eta$.\n- Grid B (Coons patch with cubic parametric stretching): choose the monotone cubic ramp $\\sigma(\\xi) = 3\\xi^2 - 2\\xi^3$ and $\\rho(\\eta) = 3\\eta^2 - 2\\eta^3$, and set $g_1(\\xi) = \\sigma(\\xi)$, $g_0(\\xi) = 1 - \\sigma(\\xi)$, $h_1(\\eta) = \\rho(\\eta)$, $h_0(\\eta) = 1 - \\rho(\\eta)$.\n\nUse the following family of corner-consistent boundary curves parameterized by real scalars $a$, $b$, $c$, and $d$:\n- Bottom edge $\\mathbf{B}_0(\\xi) = \\big(\\xi + a \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 0\\big)$,\n- Top edge $\\mathbf{B}_1(\\xi) = \\big(\\xi + b \\sin(2\\pi \\xi)\\,\\xi(1-\\xi),\\; 1\\big)$,\n- Left edge $\\mathbf{C}_0(\\eta) = \\big(0,\\; \\eta + c \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$,\n- Right edge $\\mathbf{C}_1(\\eta) = \\big(1,\\; \\eta + d \\sin(2\\pi \\eta)\\,\\eta(1-\\eta)\\big)$.\n\nFor each grid, you must quantify:\n1. A skewness metric based on orthogonality deviation of the grid lines. Let the covariant base vectors at a grid node be approximated by centered finite differences as $\\mathbf{g}_\\xi \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ and $\\mathbf{g}_\\eta \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$. Define the local orthogonality deviation $\\delta(\\xi,\\eta) = \\left| \\frac{\\pi}{2} - \\arccos\\left( \\frac{\\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta}{\\|\\mathbf{g}_\\xi\\| \\,\\|\\mathbf{g}_\\eta\\|} \\right) \\right|$. The skewness metric is the mean of $\\delta(\\xi,\\eta)$ over all interior nodes. All angles must be expressed in radians.\n\n2. A smoothness metric based on second differences. Using centered second differences, define $\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}(\\xi+\\Delta\\xi,\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi-\\Delta\\xi,\\eta)$ and $\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}(\\xi,\\eta+\\Delta\\eta) - 2\\mathbf{X}(\\xi,\\eta) + \\mathbf{X}(\\xi,\\eta-\\Delta\\eta)$. At each interior node, compute $s(\\xi,\\eta) = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$. The smoothness metric is the mean of $s(\\xi,\\eta)$ over all interior nodes.\n\nYour program must:\n- Implement both grid A and grid B using the derived transfinite interpolation construction.\n- Compute the two metrics for each grid.\n- For each test case, return a list of six floating-point numbers: $[\\text{skew}_A,\\text{skew}_B,\\text{smooth}_A,\\text{smooth}_B,\\text{skew}_A-\\text{skew}_B,\\text{smooth}_A-\\text{smooth}_B]$.\n\nTest suite:\n- Case 1 (balanced mild curvature): $N_\\xi = 21$, $N_\\eta = 21$, $(a,b,c,d) = (0.2, 0.2, 0.2, 0.2)$.\n- Case 2 (asymmetric stronger curvature, higher resolution): $N_\\xi = 41$, $N_\\eta = 31$, $(a,b,c,d) = (0.3, -0.1, 0.25, 0.0)$.\n- Case 3 (rectangular domain): $N_\\xi = 17$, $N_\\eta = 19$, $(a,b,c,d) = (0.0, 0.0, 0.0, 0.0)$.\n\nAngle unit: all angles must be in radians. There are no other physical units.\n\nFinal output format:\nYour program should produce a single line of output containing a Python-style list of three elements (one per test case), where each element is itself a list of six floating-point results in the order specified above, for example, [[...case1...],[...case2...],[...case3...]].",
            "solution": "The user has provided a problem on algebraic grid generation. A validation of the problem statement against the specified criteria confirms that it is scientifically grounded, well-posed, objective, complete, and verifiable. The problem is valid.\n\n### 1. Derivation of the Transfinite Interpolation Formula\n\nThe objective is to find a mapping $\\mathbf{X}(\\xi, \\eta) : [0,1]^2 \\to \\mathbb{R}^2$ that matches four given boundary curves: $\\mathbf{B}_0(\\xi) = \\mathbf{X}(\\xi,0)$, $\\mathbf{B}_1(\\xi) = \\mathbf{X}(\\xi,1)$, $\\mathbf{C}_0(\\eta) = \\mathbf{X}(0,\\eta)$, and $\\mathbf{C}_1(\\eta) = \\mathbf{X}(1,\\eta)$. The construction uses transfinite interpolation (TFI), which extends standard polynomial interpolation to functions, i.e., it interpolates over a continuum of points.\n\nWe define two projection operators, $P_\\xi$ and $P_\\eta$, which interpolate data from the boundaries.\nThe projector $P_\\xi$ constructs a ruled surface between the boundaries $\\mathbf{C}_0(\\eta)$ and $\\mathbf{C}_1(\\eta)$ using blending functions $g_0(\\xi)$ and $g_1(\\xi)$:\n$$P_\\xi[\\mathbf{F}](\\xi,\\eta) = g_0(\\xi) \\mathbf{F}(0,\\eta) + g_1(\\xi) \\mathbf{F}(1,\\eta)$$\nThe projector $P_\\eta$ constructs a ruled surface between the boundaries $\\mathbf{B}_0(\\xi)$ and $\\mathbf{B}_1(\\xi)$ using blending functions $h_0(\\eta)$ and $h_1(\\eta)$:\n$$P_\\eta[\\mathbf{F}](\\xi,\\eta) = h_0(\\eta) \\mathbf{F}(\\xi,0) + h_1(\\eta) \\mathbf{F}(\\xi,1)$$\nThe blending functions must satisfy endpoint and partition-of-unity properties: $g_0(0)=1, g_0(1)=0, g_1(0)=0, g_1(1)=1$, and $g_0(\\xi)+g_1(\\xi)=1$. The same applies to $h_0, h_1$.\n\nA simple sum of these two projectors, $(P_\\xi + P_\\eta)[\\mathbf{X}]$, would double-count the information at the corners. The principle of inclusion-exclusion dictates that we must subtract the common part, which is the information interpolated by both operators. This leads to the Boolean sum of the projectors: $P_{TFI} = P_\\xi \\oplus P_\\eta = P_\\xi + P_\\eta - P_\\xi P_\\eta$.\n\nApplying this to our mapping function $\\mathbf{X}$ gives the interpolation formula:\n$$\\mathbf{X}(\\xi,\\eta) = (P_\\xi + P_\\eta - P_\\xi P_\\eta)[\\mathbf{X}]$$\nLet's expand the terms:\n1. $P_\\xi[\\mathbf{X}](\\xi,\\eta) = g_0(\\xi) \\mathbf{X}(0,\\eta) + g_1(\\xi) \\mathbf{X}(1,\\eta) = g_0(\\xi) \\mathbf{C}_0(\\eta) + g_1(\\xi) \\mathbf{C}_1(\\eta)$.\n2. $P_\\eta[\\mathbf{X}](\\xi,\\eta) = h_0(\\eta) \\mathbf{X}(\\xi,0) + h_1(\\eta) \\mathbf{X}(\\xi,1) = h_0(\\eta) \\mathbf{B}_0(\\xi) + h_1(\\eta) \\mathbf{B}_1(\\xi)$.\n3. The product term $P_\\xi P_\\eta[\\mathbf{X}]$ is $P_\\xi (P_\\eta[\\mathbf{X}])$. We apply $P_\\xi$ to the result of $P_\\eta$:\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=0} + g_1(\\xi) [P_\\eta[\\mathbf{X}]]_{\\xi=1}$$\n$$= g_0(\\xi) [h_0(\\eta) \\mathbf{B}_0(0) + h_1(\\eta) \\mathbf{B}_1(0)] + g_1(\\xi) [h_0(\\eta) \\mathbf{B}_0(1) + h_1(\\eta) \\mathbf{B}_1(1)]$$\nUsing the corner consistency conditions, e.g., $\\mathbf{B}_0(0) = \\mathbf{X}(0,0)$, $\\mathbf{B}_1(0) = \\mathbf{X}(0,1)$, etc., this simplifies to:\n$$P_\\xi P_\\eta[\\mathbf{X}] = g_0(\\xi)h_0(\\eta)\\mathbf{X}(0,0) + g_0(\\xi)h_1(\\eta)\\mathbf{X}(0,1) + g_1(\\xi)h_0(\\eta)\\mathbf{X}(1,0) + g_1(\\xi)h_1(\\eta)\\mathbf{X}(1,1)$$\nThis is a tensor product interpolation of the four corner points.\n\nCombining these terms yields the final TFI formula, often called a Coons patch:\n$$\\mathbf{X}(\\xi,\\eta) = \\sum_{i=0}^{1} g_i(\\xi) \\mathbf{C}_i(\\eta) + \\sum_{j=0}^{1} h_j(\\eta) \\mathbf{B}_j(\\xi) - \\sum_{i=0}^{1}\\sum_{j=0}^{1} g_i(\\xi) h_j(\\eta) \\mathbf{X}(i,j)$$\nwhere $\\mathbf{C}_i(\\eta)$, $\\mathbf{B}_j(\\xi)$, and $\\mathbf{X}(i,j)$ represent boundary and corner data.\n\n### 2. Grid Generation and Blending Functions\n\nThe continuous mapping $\\mathbf{X}(\\xi,\\eta)$ is discretized on a uniform computational grid of size $N_\\xi \\times N_\\eta$. The computational coordinates are $\\xi_i = i/(N_\\xi-1)$ for $i \\in \\{0, \\dots, N_\\xi-1\\}$ and $\\eta_j = j/(N_\\eta-1)$ for $j \\in \\{0, \\dots, N_\\eta-1\\}$. The physical grid nodes are then computed as $\\mathbf{X}_{i,j} = \\mathbf{X}(\\xi_i, \\eta_j)$.\n\nTwo types of grids are generated based on different choices of blending functions:\n- **Grid A (Bilinear TFI):** Uses linear blending functions.\n  $$g_1(\\xi) = \\xi, \\quad g_0(\\xi) = 1-\\xi$$\n  $$h_1(\\eta) = \\eta, \\quad h_0(\\eta) = 1-\\eta$$\n- **Grid B (Cubic TFI):** Uses cubic Hermite blending functions for parametric stretching, which provide zero derivative at the endpoints, leading to boundary-orthogonal grid lines if the boundary curves are aligned with Cartesian axes.\n  $$\\sigma(t) = 3t^2 - 2t^3$$\n  $$g_1(\\xi) = \\sigma(\\xi), \\quad g_0(\\xi) = 1 - \\sigma(\\xi)$$\n  $$h_1(\\eta) = \\sigma(\\eta), \\quad h_0(\\eta) = 1 - \\sigma(\\eta)$$\n\n### 3. Grid Quality Metrics\n\nThe quality of the generated grids is assessed using two metrics evaluated on the interior nodes of the grid (i.e., for $i \\in \\{1, \\dots, N_\\xi-2\\}$ and $j \\in \\{1, \\dots, N_\\eta-2\\}$).\n\n**Skewness Metric:** This metric quantifies the deviation from orthogonality. The tangent (covariant base) vectors $\\mathbf{g}_\\xi = \\partial\\mathbf{X}/\\partial\\xi$ and $\\mathbf{g}_\\eta = \\partial\\mathbf{X}/\\partial\\eta$ are approximated using second-order centered finite differences:\n$$\\mathbf{g}_\\xi(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}}{2\\Delta\\xi}, \\quad \\mathbf{g}_\\eta(\\xi_i, \\eta_j) \\approx \\frac{\\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}}{2\\Delta\\eta}$$\nSince the scaling factor $2\\Delta\\xi$ does not affect the angle, the problem defines the vectors for angle calculation as $\\mathbf{g}_\\xi \\approx \\mathbf{X}_{i+1,j} - \\mathbf{X}_{i-1,j}$ and $\\mathbf{g}_\\eta \\approx \\mathbf{X}_{i,j+1} - \\mathbf{X}_{i,j-1}$. The angle $\\theta$ between them is found via the dot product. The local orthogonality deviation is $\\delta_{i,j} = |\\frac{\\pi}{2} - \\theta_{i,j}|$. The skewness metric is the average of $\\delta_{i,j}$ over all interior nodes.\n\n**Smoothness Metric:** This metric quantifies the variation in grid spacing. It is based on the magnitude of the second derivatives of the mapping function, approximated by centered second differences:\n$$\\Delta^2_\\xi \\mathbf{X} \\approx \\mathbf{X}_{i+1,j} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i-1,j}$$\n$$\\Delta^2_\\eta \\mathbf{X} \\approx \\mathbf{X}_{i,j+1} - 2\\mathbf{X}_{i,j} + \\mathbf{X}_{i,j-1}$$\nThe local smoothness value is $s_{i,j} = \\sqrt{\\|\\Delta^2_\\xi \\mathbf{X}\\|^2 + \\|\\Delta^2_\\eta \\mathbf{X}\\|^2}$. The smoothness metric is the average of $s_{i,j}$ over all interior nodes.\n\n### 4. Algorithmic Implementation\n\nFor each test case specified by $(N_\\xi, N_\\eta, a, b, c, d)$:\n1.  Define the blending functions $\\{g_0, g_1, h_0, h_1\\}$ for Grid A (linear) and Grid B (cubic).\n2.  Create uniform computational coordinate arrays `xi_v` and `eta_v` of sizes $N_\\xi$ and $N_\\eta$.\n3.  For each grid type (A and B):\n    a.  Evaluate the four boundary curves $\\mathbf{B}_0(\\xi), \\mathbf{B}_1(\\xi), \\mathbf{C}_0(\\eta), \\mathbf{C}_1(\\eta)$ at the discrete points in `xi_v` and `eta_v`.\n    b.  Apply the derived TFI formula to compute the physical grid coordinates $\\mathbf{X}_{i,j}$ for all $(i,j)$. This involves careful use of array broadcasting for an efficient implementation.\n    c.  Compute the skewness and smoothness metrics by applying the finite difference formulas to the interior of the grid $\\mathbf{X}$.\n4.  Consolidate the four computed metrics ($\\text{skew}_A, \\text{skew}_B, \\text{smooth}_A, \\text{smooth}_B$) and their differences into a single list of six values.\n5.  Collect the results for all test cases and format the final output as specified.\n\nThe case where $a=b=c=d=0$ serves as a validation check. Here, the boundaries form a unit square. The TFI formula should reproduce the identity mapping $\\mathbf{X}(\\xi,\\eta) = (\\xi,\\eta)$, resulting in a perfect Cartesian grid for which both skewness and smoothness metrics are identically zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and compares two algebraic structured grids using different\n    transfinite interpolation (TFI) strategies and computes grid quality metrics.\n    \"\"\"\n\n    # --- Blending Functions ---\n    # Grid A: Linear blending functions\n    def g1_A(xi): return xi\n    def g0_A(xi): return 1.0 - xi\n    def h1_A(eta): return eta\n    def h0_A(eta): return 1.0 - eta\n\n    # Grid B: Cubic (Hermite) blending functions\n    def sigma(t): return 3.0 * t**2 - 2.0 * t**3\n    def g1_B(xi): return sigma(xi)\n    def g0_B(xi): return 1.0 - sigma(xi)\n    def h1_B(eta): return sigma(eta)\n    def h0_B(eta): return 1.0 - sigma(eta)\n\n    # --- Boundary Curve Definitions ---\n    def B0(xi, a, b, c, d):\n        x = xi + a * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.zeros_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def B1(xi, a, b, c, d):\n        x = xi + b * np.sin(2.0 * np.pi * xi) * xi * (1.0 - xi)\n        y = np.ones_like(xi)\n        return np.stack((x, y), axis=-1)\n\n    def C0(eta, a, b, c, d):\n        x = np.zeros_like(eta)\n        y = eta + c * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def C1(eta, a, b, c, d):\n        x = np.ones_like(eta)\n        y = eta + d * np.sin(2.0 * np.pi * eta) * eta * (1.0 - eta)\n        return np.stack((x, y), axis=-1)\n\n    def generate_grid(N_xi, N_eta, params, g_funcs, h_funcs):\n        \"\"\"\n        Generates a 2D structured grid using transfinite interpolation.\n        \"\"\"\n        a, b, c, d = params\n        g0, g1 = g_funcs\n        h0, h1 = h_funcs\n        \n        xi_v = np.linspace(0.0, 1.0, N_xi)\n        eta_v = np.linspace(0.0, 1.0, N_eta)\n        \n        # 'ij' indexing ensures shape is (N_xi, N_eta)\n        XI, ETA = np.meshgrid(xi_v, eta_v, indexing='ij')\n\n        # Evaluate boundary curves on the discrete points\n        B0_vals = B0(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        B1_vals = B1(xi_v, a, b, c, d)  # Shape (N_xi, 2)\n        C0_vals = C0(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n        C1_vals = C1(eta_v, a, b, c, d)  # Shape (N_eta, 2)\n\n        # Evaluate blending functions on the computational grid\n        G0 = g0(XI)\n        G1 = g1(XI)\n        H0 = h0(ETA)\n        H1 = h1(ETA)\n\n        # Apply TFI formula using numpy broadcasting\n        # Term 1: Interpolation from xi-boundaries\n        term1 = G0[..., None] * C0_vals[None, :, :] + G1[..., None] * C1_vals[None, :, :]\n        # Term 2: Interpolation from eta-boundaries\n        term2 = H0[..., None] * B0_vals[:, None, :] + H1[..., None] * B1_vals[:, None, :]\n        \n        # Term 3: Corner correction term\n        X00, X10 = B0_vals[0], B0_vals[-1]\n        X01, X11 = B1_vals[0], B1_vals[-1]\n        \n        term3 = (G0[..., None] * H0[..., None] * X00[None, None, :] +\n                 G1[..., None] * H0[..., None] * X10[None, None, :] +\n                 G0[..., None] * H1[..., None] * X01[None, None, :] +\n                 G1[..., None] * H1[..., None] * X11[None, None, :])\n\n        X = term1 + term2 - term3\n        return X\n\n    def calculate_metrics(X):\n        \"\"\"\n        Computes skewness and smoothness metrics for a given grid.\n        \"\"\"\n        N_xi, N_eta, _ = X.shape\n        if N_xi  3 or N_eta  3:\n            return 0.0, 0.0\n\n        # --- Skewness Metric ---\n        # Approximate tangent vectors using centered differences on interior nodes\n        g_xi = X[2:, 1:-1, :] - X[:-2, 1:-1, :]\n        g_eta = X[1:-1, 2:, :] - X[1:-1, :-2, :]\n\n        # Calculate angle between tangent vectors\n        dot_product = np.sum(g_xi * g_eta, axis=2)\n        norm_g_xi = np.linalg.norm(g_xi, axis=2)\n        norm_g_eta = np.linalg.norm(g_eta, axis=2)\n        \n        denominator = norm_g_xi * norm_g_eta\n        # Avoid division by zero for robustness\n        cos_theta = np.divide(dot_product, denominator, \n                              out=np.zeros_like(dot_product), \n                              where=denominator != 0)\n        \n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        theta = np.arccos(cos_theta)\n        \n        # Orthogonality deviation in radians\n        ortho_dev = np.abs(np.pi / 2.0 - theta)\n        skewness = np.mean(ortho_dev)\n        \n        # --- Smoothness Metric ---\n        # Approximate second derivatives using centered differences\n        d2X_dxi2 = X[2:, 1:-1, :] - 2 * X[1:-1, 1:-1, :] + X[:-2, 1:-1, :]\n        d2X_deta2 = X[1:-1, 2:, :] - 2 * X[1:-1, 1:-1, :] + X[1:-1, :-2, :]\n\n        # Compute magnitude of second derivatives\n        norm_sq_d2xi = np.sum(d2X_dxi2**2, axis=2)\n        norm_sq_d2eta = np.sum(d2X_deta2**2, axis=2)\n        \n        s = np.sqrt(norm_sq_d2xi + norm_sq_d2eta)\n        smoothness = np.mean(s)\n        \n        return skewness, smoothness\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"N_xi\": 21, \"N_eta\": 21, \"params\": (0.2, 0.2, 0.2, 0.2)},\n        {\"N_xi\": 41, \"N_eta\": 31, \"params\": (0.3, -0.1, 0.25, 0.0)},\n        {\"N_xi\": 17, \"N_eta\": 19, \"params\": (0.0, 0.0, 0.0, 0.0)},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N_xi, N_eta, params = case[\"N_xi\"], case[\"N_eta\"], case[\"params\"]\n\n        # Generate Grid A and calculate metrics\n        grid_A = generate_grid(N_xi, N_eta, params, (g0_A, g1_A), (h0_A, h1_A))\n        skew_A, smooth_A = calculate_metrics(grid_A)\n\n        # Generate Grid B and calculate metrics\n        grid_B = generate_grid(N_xi, N_eta, params, (g0_B, g1_B), (h0_B, h1_B))\n        skew_B, smooth_B = calculate_metrics(grid_B)\n        \n        skew_diff = skew_A - skew_B\n        smooth_diff = smooth_A - smooth_B\n\n        case_results = [skew_A, skew_B, smooth_A, smooth_B, skew_diff, smooth_diff]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}