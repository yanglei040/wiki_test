{
    "hands_on_practices": [
        {
            "introduction": "双曲网格生成的基本思想是沿着法向推进。然而，在实际应用的几何体中，尖角或尖点处法向量的定义可能是不明确的或不连续的。本练习将引导你通过一个编码实践，研究当使用基于水平集（level-set）的方法在方形域的角点处生成法线时，朴素推进算法如何失效，并实现一个稳健的回退（fallback）策略来解决这一关键问题。这个实践对于构建一个在复杂几何中可靠工作的网格生成器至关重要。",
            "id": "3332127",
            "problem": "考虑在二维空间中进行双曲网格生成，其中网格通过从一条闭合边界曲线沿一系列法线向域内部推进生成。此公式的基础是，从计算推进坐标 $s$ 和边界参数 $\\xi$ 到物理空间 $\\mathbf{x}(s,\\xi)\\in\\mathbb{R}^2$ 的映射满足一个双曲型一阶偏微分方程 (PDE)，即 $\\,\\partial_s \\mathbf{x} = a(\\mathbf{x})\\,\\mathbf{n}(\\mathbf{x})\\,$，其中 $a(\\mathbf{x})$ 是一个正速率函数，$\\mathbf{n}(\\mathbf{x})$ 是一个单位法线场。在计算流体力学 (CFD) 中，一种广泛使用的构造方法是通过水平集 $\\,\\phi(\\mathbf{x})\\,$ 定义单位法线，取 $\\,\\mathbf{n}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x})/\\lVert \\nabla \\phi(\\mathbf{x})\\rVert\\,$，其中 $\\nabla$ 表示空间梯度。众所周知，当水平集 $\\,\\phi\\,$ 在边界 $\\,\\Gamma\\,$ 的角点附近存在扭折或不可微特征时，梯度模长 $\\,\\lVert \\nabla \\phi(\\mathbf{x})\\rVert\\,$ 可能接近于零，这可能会损害推进格式的鲁棒性。在本问题中，您将离散化此双曲推进过程，并研究在此类扭折存在时的鲁棒性。\n\n您必须仅从上述基本原理和标准数值离散化原则出发，实现以下内容。\n\n- 在常速率 $\\,a(\\mathbf{x})\\equiv 1\\,$ 的情况下，使用推进步长为 $\\,\\Delta s  0\\,$ 的显式前向欧拉更新，离散化推进 PDE $\\,\\partial_s \\mathbf{x} = \\mathbf{n}(\\mathbf{x})\\,$。设 $\\,\\Gamma(\\xi)\\,$ 是边界的一个给定逆时针参数化，参数为 $\\,\\xi\\in[0,1)\\,$，在 $\\,N\\,$ 个均匀间隔点 $\\,\\{\\xi_j\\}_{j=0}^{N-1}\\,$ 上采样，并采用周期性索引。设 $\\,\\mathbf{x}^{(0)}_j = \\Gamma(\\xi_j)\\,$ 并通过下式推进 $\\,M\\,$ 层：\n$$\n\\mathbf{x}^{(k+1)}_j \\;=\\; \\mathbf{x}^{(k)}_j \\;+\\; \\Delta s \\,\\mathbf{n}_{\\mathrm{reg}}\\!\\left(\\mathbf{x}^{(k)}_j;\\,\\xi_j\\right), \\quad \\text{for } j\\in\\{0,\\dots,N-1\\},\\; k\\in\\{0,\\dots,M-1\\}.\n$$\n场 $\\,\\mathbf{n}_{\\mathrm{reg}}\\,$ 是一个鲁棒的单位内法线，定义如下：计算 $\\,\\nabla \\phi(\\mathbf{x})\\,$ 及其模长 $\\,g=\\lVert \\nabla \\phi(\\mathbf{x})\\rVert\\,$。如果对于指定的阈值 $\\,\\tau\\ge 0\\,$，有 $\\,g \\tau\\,$，则设 $\\,\\mathbf{n}_{\\mathrm{reg}}(\\mathbf{x};\\xi) = \\nabla \\phi(\\mathbf{x})/g\\,$。否则，将由水平集导出的方向替换为与边界参数 $\\,\\xi\\,$ 相关的单位内几何法线 $\\,\\mathbf{n}_{\\mathrm{geo}}(\\xi)\\,$，该法线通过将 $\\,\\Gamma(\\xi)\\,$ 的单位切线 $\\,\\mathbf{t}(\\xi)$ 旋转 $\\,{+}\\,\\pi/2\\,$ 弧度使其指向内部来定义。对于禁用回退机制的测试，将 $\\tau  0$ 理解为不允许回退，如果出现 $\\,g=0\\,$ 的情况，您必须在该点取 $\\,\\mathbf{n}_{\\mathrm{reg}}(\\mathbf{x};\\xi)=\\mathbf{0}\\,$。\n\n- 为评估鲁棒性，近似计算推进层与沿边界相邻点之间的局部面积缩放（离散雅可比行列式的模长）。对于每一层 $\\,k\\in\\{0,\\dots,M-1\\}\\,$ 和每个 $\\,j\\in\\{0,\\dots,N-1\\}\\,$，定义向量\n$$\n\\Delta_s \\mathbf{x}^{(k)}_j = \\mathbf{x}^{(k+1)}_j - \\mathbf{x}^{(k)}_j,\\qquad\n\\Delta_\\xi \\mathbf{x}^{(k)}_j = \\mathbf{x}^{(k)}_{j+1\\,\\mathrm{mod}\\,N} - \\mathbf{x}^{(k)}_j,\n$$\n并通过叉积的z分量定义有向单元面积（在二维中为标量）\n$$\nA^{(k)}_j \\;=\\; \\big(\\Delta_s \\mathbf{x}^{(k)}_j\\big)_x \\,\\big(\\Delta_\\xi \\mathbf{x}^{(k)}_j\\big)_y \\;-\\; \\big(\\Delta_s \\mathbf{x}^{(k)}_j\\big)_y \\,\\big(\\Delta_\\xi \\mathbf{x}^{(k)}_j\\big)_x,\n$$\n并使用其模长 $\\,|A^{(k)}_j|\\,$ 作为雅可比行列式绝对值的离散替代。将整个网格上的最小绝对面积定义为\n$$\nA_{\\min} \\;=\\; \\min_{\\,0\\le k\\le M-1}\\;\\min_{\\,0\\le j\\le N-1} \\, |A^{(k)}_j|.\n$$\n\n- 实现两个水平集 $\\,\\phi(\\mathbf{x})\\,$ 及其梯度 $\\,\\nabla\\phi(\\mathbf{x})\\,$：\n  1. 光滑圆形：$\\,\\phi_{\\mathrm{circ}}(x,y) = 1 - \\sqrt{x^2 + y^2}\\,$，使得 $\\,\\nabla \\phi_{\\mathrm{circ}}(x,y) = -\\big(x,y\\big)/\\sqrt{x^2+y^2}\\,$ 指向内部。\n  2. 在正方形角点处有扭折的乘积形式：$\\,\\phi_{\\square}(x,y) = \\big(|x|-1\\big)\\,\\big(|y|-1\\big)\\,$，其梯度为 $\\,\\nabla \\phi_{\\square}(x,y) = \\big(\\mathrm{sgn}(x)\\,(|y|-1),\\;\\mathrm{sgn}(y)\\,(|x|-1)\\big)\\,$，其中 $\\,\\mathrm{sgn}(\\cdot)\\,$ 是符号函数，且 $\\,\\mathrm{sgn}(0)=0\\,$。注意 $\\,\\nabla \\phi_{\\square}\\,$ 在正方形的四个角点处为零，模拟了水平集的扭折。\n\n- 按如下方式参数化边界 $\\,\\Gamma(\\xi)\\,$ 及其单位切线 $\\,\\mathbf{t}(\\xi)\\,$：\n  1. 对于半径为 $\\,1\\,$ 的圆形：$\\,\\Gamma_{\\mathrm{circ}}(\\xi) = \\big(\\cos(2\\pi \\xi),\\;\\sin(2\\pi \\xi)\\big)\\,$，其中 $\\,\\xi\\in[0,1)\\,$，在 $\\,N\\,$ 个等距值上采样，每个测试指定 $\\,N$。\n  2. 对于正方形 $\\,[-1,1]\\times[-1,1]\\,$：逆时针采样边界，使四个角点恰好各包含一次，方法是在右边缘上取 $\\,N_{\\mathrm{edge}}\\,$ 个点（包括两个端点），然后在上边缘上取 $\\,N_{\\mathrm{edge}}-1\\,$ 个点（不包括共享的角点），然后在左边缘上取 $\\,N_{\\mathrm{edge}}-1\\,$ 个点（不包括共享的角点），最后在下边缘上取 $\\,N_{\\mathrm{edge}}-2\\,$ 个点（不包括两个共享的角点），总共得到 $\\,N = 4\\,N_{\\mathrm{edge}} - 4\\,$ 个点。沿此闭合多边形链使用周期性中心差分来近似 $\\,\\mathbf{t}(\\xi)\\,$，并旋转 $\\,{+}\\,\\pi/2\\,$ 弧度以获得单位内几何法线 $\\,\\mathbf{n}_{\\mathrm{geo}}(\\xi)\\,$。\n\n- 对于下面的每个测试用例，计算 $\\,A_{\\min}\\,$ 并验证所有模拟位置保持有限（没有非数值(NaN)或无穷大值）。当且仅当 $\\,A_{\\min} \\ge A_{\\mathrm{thr}}\\,$ 且所有值都为有限时，测试用例才被声明为鲁棒的。您的程序必须评估以下测试套件，并为每个用例输出一个布尔值：\n  1. 测试A（光滑基准）：圆形，$\\,N=256\\,$，$\\,\\Delta s = 0.01\\,$，$\\,M=20\\,$，禁用回退（设置 $\\,\\tau=-1\\,$），阈值 $\\,A_{\\mathrm{thr}} = 10^{-4}\\,$。\n  2. 测试B（角点扭折，朴素法线）：正方形，$\\,N_{\\mathrm{edge}}=65\\,$，因此 $\\,N=256\\,$，$\\,\\Delta s = 0.01\\,$，$\\,M=20\\,$，禁用回退（设置 $\\,\\tau=-1\\,$），阈值 $\\,A_{\\mathrm{thr}} = 10^{-4}\\,$。\n  3. 测试C（角点扭折，带回退的鲁棒法线）：与测试B相同的正方形和离散化，但启用回退，使用 $\\,\\tau = 0.05\\,$，阈值 $\\,A_{\\mathrm{thr}} = 10^{-4}\\,$。\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[True,False,True]”），顺序为 [测试 A, 测试 B, 测试 C]。不应打印任何其他文本。\n\n所有角度均以弧度为单位。不涉及物理单位。所有输出必须是指定的布尔值。",
            "solution": "该问题要求实现并验证一个二维双曲网格生成算法。该方法的核心是将网格点从初始边界曲线迭代推进到域的内部。这个过程由一个一阶双曲偏微分方程（PDE）控制，我们将对其进行离散化和数值求解。主要目标是通过比较朴素实现与包含法向量计算回退机制的实现，来分析该方法的鲁棒性，特别是它如何处理像尖角这样的几何奇异点。\n\n控制网格点位置 $\\mathbf{x}$ 随推进坐标 $s$ 变化的控制性PDE为 $\\partial_s \\mathbf{x} = a(\\mathbf{x})\\,\\mathbf{n}(\\mathbf{x})$。在本问题中，速率函数 $a(\\mathbf{x})$ 取为常数 $a(\\mathbf{x}) \\equiv 1$，方程简化为：\n$$\n\\partial_s \\mathbf{x} = \\mathbf{n}(\\mathbf{x})\n$$\n单位法线场 $\\mathbf{n}(\\mathbf{x})$ 由水平集函数 $\\phi(\\mathbf{x})$ 的梯度导出，即 $\\mathbf{n}(\\mathbf{x}) = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$。\n\n我们将此PDE在空间和推进方向上都进行离散化。边界曲线 $\\Gamma(\\xi)$ 在 $N$ 个离散点 $\\{\\xi_j\\}_{j=0}^{N-1}$ 上采样，形成初始网格层 $\\mathbf{x}^{(0)}_j = \\Gamma(\\xi_j)$。后续的网格层是通过使用步长为 $\\Delta s  0$ 的显式前向欧拉格式在 $s$ 方向上向前推进生成的。对于第 $k$ 层和边界索引为 $j$ 的网格点 $\\mathbf{x}^{(k)}_j$ 的更新规则是：\n$$\n\\mathbf{x}^{(k+1)}_j = \\mathbf{x}^{(k)}_j + \\Delta s \\,\\mathbf{n}_{\\mathrm{reg}}\\!\\left(\\mathbf{x}^{(k)}_j;\\,\\xi_j\\right)\n$$\n这个过程重复 $M$ 步，生成 $M$ 个新的网格层。\n\n一个关键部分是正则化法向量 $\\mathbf{n}_{\\mathrm{reg}}$ 的定义。使用水平集梯度的朴素方法在梯度消失的地方可能会失败，例如在由水平集函数中的扭折表示的尖角处。为了解决这个问题，引入了一种鲁棒的方法。设 $g = \\lVert \\nabla \\phi(\\mathbf{x}) \\rVert$ 为水平集梯度的模长。\n- 如果 $g$ 大于一个指定的阈值 $\\tau \\ge 0$，则法线由水平集计算：$\\mathbf{n}_{\\mathrm{reg}} = \\nabla \\phi / g$。\n- 如果 $g \\le \\tau$，算法将回退到预先计算的几何法线 $\\mathbf{n}_{\\mathrm{geo}}(\\xi_j)$，该法线直接从初始边界曲线 $\\Gamma$ 的几何形状导出。这个几何法线是通过将边界的单位切向量 $\\mathbf{t}(\\xi_j)$ 旋转 $+\\pi/2$ 弧度得到的，确保对于逆时针参数化的边界它指向内部。\n- 为禁用回退机制的情况定义了一个特殊情况，由 $\\tau  0$ 表示。在这种情况下，不允许回退。如果梯度模长 $g$ 变为零，法向量必须设置为零，$\\mathbf{n}_{\\mathrm{reg}} = \\mathbf{0}$，这将停止该特定网格点的运动。\n\n为了评估生成网格的质量和鲁棒性，我们计算局部单元面积的离散度量。对于由点 $(\\mathbf{x}^{(k)}_j, \\mathbf{x}^{(k)}_{j+1}, \\mathbf{x}^{(k+1)}_{j+1}, \\mathbf{x}^{(k+1)}_j)$ 定义的每个单元，我们定义了对应于四边形边的两个向量：\n$$\n\\Delta_s \\mathbf{x}^{(k)}_j = \\mathbf{x}^{(k+1)}_j - \\mathbf{x}^{(k)}_j \\quad (\\text{推进方向})\n$$\n$$\n\\Delta_\\xi \\mathbf{x}^{(k)}_j = \\mathbf{x}^{(k)}_{j+1\\,\\mathrm{mod}\\,N} - \\mathbf{x}^{(k)}_j \\quad (\\text{沿边界方向})\n$$\n这个单元的有向面积 $A^{(k)}_j$ 由这两个向量在 $xy$ 平面中叉积的 $z$ 分量给出：\n$$\nA^{(k)}_j = \\big(\\Delta_s \\mathbf{x}^{(k)}_j\\big)_x \\,\\big(\\Delta_\\xi \\mathbf{x}^{(k)}_j\\big)_y - \\big(\\Delta_s \\mathbf{x}^{(k)}_j\\big)_y \\,\\big(\\Delta_\\xi \\mathbf{x}^{(k)}_j\\big)_x\n$$\n如果网格单元塌陷或翻转，即该面积的模长接近于零，则认为网格质量差。整体网格鲁棒性的度量是整个网格中所有单元的最小绝对面积：\n$$\nA_{\\min} = \\min_{k,j} |A^{(k)}_j|\n$$\n当且仅当 $A_{\\min}$ 大于或等于给定的阈值 $A_{\\mathrm{thr}}$，并且所有计算出的网格点坐标都是有限数时，测试用例才被认为是鲁棒的。\n\n该实现将涵盖两种几何形状：\n1.  **圆形**：边界是一个单位圆 $\\Gamma_{\\mathrm{circ}}(\\xi) = (\\cos(2\\pi\\xi), \\sin(2\\pi\\xi))$ 且水平集为 $\\phi_{\\mathrm{circ}}(x,y) = 1 - \\sqrt{x^2+y^2}$。其梯度 $\\nabla\\phi_{\\mathrm{circ}} = \\frac{-1}{\\sqrt{x^2+y^2}}(x,y)$ 在远离原点处是良态的（非零且光滑）。\n2.  **正方形**：边界是正方形 $[-1,1]\\times[-1,1]$ 的周长。水平集为 $\\phi_{\\square}(x,y) = (|x|-1)(|y|-1)$，其梯度为 $\\nabla\\phi_{\\square} = (\\mathrm{sgn}(x)(|y|-1), \\mathrm{sgn}(y)(|x|-1))$。这个梯度在四个角点 $(\\pm 1, \\pm 1)$ 处为零，模拟了病态情况。对于正方形的几何法线，边界切向量是使用离散边界点上的周期性中心差分来近似的。\n\n我们将执行三个测试用例：\n- **测试 A**：使用圆形边界的光滑基准，禁用回退机制（$\\tau = -1$）。我们预计这将是鲁棒的，因为没有固有的几何或水平集奇异点。\n- **测试 B**：具有奇异水平集的正方形边界，同样禁用回退机制（$\\tau = -1$）。我们预计会失败，因为角点处消失的梯度将导致 $\\mathbf{n}_{\\mathrm{reg}}=\\mathbf{0}$，从而导致网格单元塌陷且 $A_{\\min}  A_{\\mathrm{thr}}$。\n- **测试 C**：与测试 B 相同的正方形配置，但启用了鲁棒的回退机制（$\\tau = 0.05$）。现在算法应在角点附近使用良定义的几何法线，防止单元塌陷，并得到一个鲁棒的网格，其 $A_{\\min} \\ge A_{\\mathrm{thr}}$。",
            "answer": "```python\nimport numpy as np\n\ndef grad_phi_circ(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the gradient of the circle level-set function.\n    phi(x,y) = 1 - sqrt(x^2 + y^2)\n    grad_phi = -(x,y) / sqrt(x^2 + y^2)\n    \"\"\"\n    norm = np.linalg.norm(x, axis=1, keepdims=True)\n    # Avoid division by zero at the origin, though it's not on the boundary.\n    norm[norm == 0] = 1e-16\n    return -x / norm\n\ndef grad_phi_square(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the gradient of the square level-set function.\n    phi(x,y) = (|x|-1)(|y|-1)\n    grad_phi = (sgn(x)(|y|-1), sgn(y)(|x|-1))\n    \"\"\"\n    sx = np.sign(x[:, 0])\n    sy = np.sign(x[:, 1])\n    abs_x = np.abs(x[:, 0])\n    abs_y = np.abs(x[:, 1])\n    return np.column_stack([sx * (abs_y - 1), sy * (abs_x - 1)])\n\ndef run_test(shape: str, N_param: int, ds: float, M: int, tau: float, A_thr: float) - bool:\n    \"\"\"\n    Runs a single hyperbolic grid generation test case.\n    \"\"\"\n    if shape == 'circle':\n        N = N_param\n        xi = np.linspace(0, 1, N, endpoint=False)\n        x0 = np.column_stack([np.cos(2 * np.pi * xi), np.sin(2 * np.pi * xi)])\n        grad_phi_func = grad_phi_circ\n        n_geo = None\n    elif shape == 'square':\n        N_edge = N_param\n        N = 4 * N_edge - 4\n        \n        y_right = np.linspace(1, -1, N_edge)\n        x_top = np.linspace(1, -1, N_edge)[1:]\n        y_left = np.linspace(-1, 1, N_edge)[1:]\n        x_bottom = np.linspace(-1, 1, N_edge)[1:-1]\n        \n        pts_right = np.column_stack([np.ones_like(y_right), y_right])\n        pts_top = np.column_stack([x_top, np.ones_like(x_top)])\n        pts_left = np.column_stack([-np.ones_like(y_left), y_left])\n        pts_bottom = np.column_stack([x_bottom, -np.ones_like(x_bottom)])\n        \n        x0 = np.concatenate([pts_right, pts_top, pts_left, pts_bottom], axis=0)\n        grad_phi_func = grad_phi_square\n        \n        # Pre-compute geometric normals for fallback\n        t = np.roll(x0, -1, axis=0) - np.roll(x0, 1, axis=0)\n        norm_t = np.linalg.norm(t, axis=1, keepdims=True)\n        # Avoid division by zero, though unlikely for a non-degenerate polygon\n        norm_t[norm_t == 0] = 1.0\n        unit_t = t / norm_t\n        # Rotate tangent by +pi/2 to get inward normal: (tx, ty) - (-ty, tx)\n        n_geo = np.column_stack([-unit_t[:, 1], unit_t[:, 0]])\n    else:\n        raise ValueError(\"Invalid shape specified\")\n\n    x_k = x0.copy()\n    all_points = [x0]\n    all_areas = []\n\n    for _ in range(M):\n        grad = grad_phi_func(x_k)\n        g = np.linalg.norm(grad, axis=1)\n        \n        n_reg = np.zeros_like(x_k)\n\n        # Fallback disabled case (tau  0)\n        if tau  0:\n            mask_g_pos = g > 0\n            # Use level-set normal where g > 0, otherwise remains 0\n            n_reg[mask_g_pos] = grad[mask_g_pos] / g[mask_g_pos, np.newaxis]\n        # Fallback enabled case (tau >= 0)\n        else:\n            mask_phi = g > tau\n            mask_geo = ~mask_phi\n            \n            # Use level-set normal where g > tau\n            if np.any(mask_phi):\n                n_reg[mask_phi] = grad[mask_phi] / g[mask_phi, np.newaxis]\n            \n            # Use geometric normal where g = tau (fallback)\n            if np.any(mask_geo):\n                n_reg[mask_geo] = n_geo[mask_geo]\n\n        # Forward Euler step\n        x_kplus1 = x_k + ds * n_reg\n        \n        # Calculate cell areas using current layer and next\n        delta_s_x = x_kplus1 - x_k\n        delta_xi_x = np.roll(x_k, -1, axis=0) - x_k\n        \n        # 2D cross product: a_x * b_y - a_y * b_x\n        areas_k = delta_s_x[:, 0] * delta_xi_x[:, 1] - delta_s_x[:, 1] * delta_xi_x[:, 0]\n        all_areas.append(np.abs(areas_k))\n        \n        x_k = x_kplus1\n        all_points.append(x_k)\n        \n    all_points = np.array(all_points)\n    all_areas = np.concatenate(all_areas)\n    \n    A_min = np.min(all_areas)\n    all_finite = np.all(np.isfinite(all_points))\n    \n    is_robust = all_finite and (A_min >= A_thr)\n    return is_robust\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite.\n    \"\"\"\n    test_cases = [\n        # Test A: Circle, smooth, no fallback\n        {'shape': 'circle', 'N_param': 256, 'ds': 0.01, 'M': 20, 'tau': -1.0, 'A_thr': 1e-4},\n        # Test B: Square, kinks, no fallback\n        {'shape': 'square', 'N_param': 65, 'ds': 0.01, 'M': 20, 'tau': -1.0, 'A_thr': 1e-4},\n        # Test C: Square, kinks, fallback enabled\n        {'shape': 'square', 'N_param': 65, 'ds': 0.01, 'M': 20, 'tau': 0.05, 'A_thr': 1e-4},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test(**case)\n        results.append(result)\n\n    # Format output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在成功地建立了一个稳健的推进方案之后，下一步是学习如何精确地控制网格单元的属性。为了高效地解析边界层或其他流动特征，CFD网格通常需要各向异性的单元（即在一个方向上被拉伸）。本练习介绍了一种先进的控制方法，它利用背景标量场的Hessian矩阵来引导网格线的生成，从而实现对单元各向异性的精确控制。通过将基于Hessian的方法与简单的法向推进进行比较，你将深入理解如何生成高质量的自适应网格。",
            "id": "3332135",
            "problem": "考虑一个计算流体动力学 (CFD) 中的二维双曲网格生成过程，其中，一个贴体网格片通过将内部网格点从初始边界曲线沿指定的方向场向前推进来构建。设映射为 $\\mathbf{x}(u,s) \\in \\mathbb{R}^2$，其参数为 $u \\in [0,1]$（边界曲线参数）和伪时间 $s \\ge 0$（推进参数）。该推进过程由一阶偏微分方程 (PDE) $\\partial_s \\mathbf{x}(u,s) = \\alpha\\,\\mathbf{d}(\\mathbf{x}(u,s),u)$ 控制，其中 $\\alpha  0$ 是一个恒定的步长（单位伪时间内的长度单位）。需要比较两种推进方向模型：(i) 基于Hessian矩阵的各向异性和 (ii) 仅边界法向推进。\n\n本问题的基本定义：\n- 边界曲线由 $\\boldsymbol{\\Gamma}(u) = (x(u),y(u))$ 给出，其中 $x(u) = u$ 且 $y(u) = y_0 + A\\sin(2\\pi u)$。单位切向量为 $\\mathbf{t}(u) = \\frac{\\partial \\boldsymbol{\\Gamma}/\\partial u}{\\|\\partial \\boldsymbol{\\Gamma}/\\partial u\\|}$，选择的向外单位法向量为 $\\mathbf{n}(u) = (-t_y(u),\\,t_x(u))$，如有必要则翻转方向以使 $n_y(u) \\ge 0$。\n- 给定一个二阶可微的标量场 $\\phi(x,y)$，其Hessian矩阵为 $H = \\nabla\\nabla\\phi \\in \\mathbb{R}^{2\\times 2}$。对于基于Hessian矩阵的各向异性，推进方向是对应于最大特征值的主特征向量：$\\mathbf{d}_\\text{aniso}(\\mathbf{x},u) = \\mathbf{v}_{\\max}(H(\\mathbf{x}))$，其方向经过定向以满足 $\\mathbf{d}_\\text{aniso}\\cdot\\mathbf{n}(u) \\ge 0$。在各向同性情况下，即 $H$ 的特征值在很小的容差范围内相等时，设置 $\\mathbf{d}_\\text{aniso}(\\mathbf{x},u) = \\mathbf{n}(u)$。\n- 对于仅边界法向推进，对于与参数 $u$ 相关联的流线上的所有 $\\mathbf{x}$，均使用 $\\mathbf{d}_\\text{normal}(\\mathbf{x},u) = \\mathbf{n}(u)$。\n\n设离散网格定义在 $(u_i,s_j)$上，其中 $u_i = \\frac{i}{M-1}$（对于 $i=0,1,\\ldots,M-1$），以及 $s_j = j\\,\\Delta s$，步长 $\\Delta s = \\alpha$ 恒定（对于 $j=0,1,\\ldots,N$）。初始条件为 $\\mathbf{x}(u_i,0) = \\boldsymbol{\\Gamma}(u_i)$。推进更新采用显式格式 $\\mathbf{x}(u_i,s_{j+1}) = \\mathbf{x}(u_i,s_j) + \\alpha\\,\\mathbf{d}(\\mathbf{x}(u_i,s_j),u_i)$，其中 $\\mathbf{d}$ 分别为 $\\mathbf{d}_\\text{aniso}$ 或 $\\mathbf{d}_\\text{normal}$。\n\n网格质量通过映射的雅可比行列式 (J) 进行评估，其离散近似为由前向差分 $\\Delta_u \\mathbf{x}$ 和 $\\Delta_s \\mathbf{x}$ 张成的平行四边形的单元面积：\n$$\nJ_{i,j} \\approx \\left| \\det\\begin{pmatrix}\nx_{i+1,j}-x_{i,j}  x_{i,j+1}-x_{i,j} \\\\\ny_{i+1,j}-y_{i,j}  y_{i,j+1}-y_{i,j}\n\\end{pmatrix} \\right| = \\left| (x_{i+1,j}-x_{i,j})(y_{i,j+1}-y_{i,j}) - (y_{i+1,j}-y_{i,j})(x_{i,j+1}-x_{i,j}) \\right|.\n$$\n均匀性通过变异系数 (CoV) 进行量化，其定义为 $\\mathrm{CoV} = \\frac{\\sigma(J)}{\\mu(J)}$，其中 $\\sigma(J)$ 和 $\\mu(J)$ 分别是所有有效单元 $(i,j)$ 的集合 $\\{J_{i,j}\\}$ 的标准差和平均值。\n\n您的任务是为以下测试套件实现此网格生成和质量评估，并通过报告每个案例的比率 $R = \\frac{\\mathrm{CoV}_\\text{normal}}{\\mathrm{CoV}_\\text{aniso}}$ 来比较基于Hessian矩阵的各向异性推进与仅法向推进两种方法下雅可比行列式的均匀性。\n\n所有案例共用：\n- 域边界通过构造隐式地强制执行，无需显式边界反射；选择的参数可使轨迹保持在单位正方形内。\n- 参数：$M=51$，$N=30$，$\\alpha=0.015$，$y_0=0.2$，$A=0.05$。\n\n测试套件（三个案例）：\n1. 案例1（常数、各向异性Hessian矩阵）：$\\phi(x,y) = a\\,x^2 + b\\,y^2 + c\\,x\\,y$，其中 $a=0.5$，$b=4.0$，$c=0.2$，因此 $H = \\begin{pmatrix}2a  c\\\\ c  2b\\end{pmatrix}$ 是常数且正定的。\n2. 案例2（空间变化的各向异性Hessian矩阵）：$\\phi(x,y) = x^2 + y^2 + \\frac{1}{2} x\\,y^2$，因此 $H(x,y) = \\begin{pmatrix}2  y\\\\ y  2 + x\\end{pmatrix}$，对于 $(x,y) \\in [0,1]^2$ 是对称且正定的。\n3. 案例3（各向同性Hessian矩阵）：$\\phi(x,y) = x^2 + y^2$，因此 $H = \\begin{pmatrix}2  0\\\\ 0  2\\end{pmatrix}$ 在任何地方都成立，意味着特征值相等，各向异性规则回退到使用 $\\mathbf{n}(u)$。\n\n对于每个案例，计算两种推进策略下的网格，组合在 $i=0,\\ldots,M-2$ 和 $j=0,\\ldots,N-1$ 上的集合 $\\{J_{i,j}\\}$，计算 $\\mathrm{CoV}_\\text{aniso}$ 和 $\\mathrm{CoV}_\\text{normal}$，并以浮点数形式返回 $R$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个案例的结果，格式为方括号内以逗号分隔的列表（例如，“[r1,r2,r3]”），其中每个 $r_k$ 是为案例 $k$ 计算的浮点数 $R$，采用任意浮点表示。不需要单位，也不出现角度。",
            "solution": "该问题定义明确，科学上合理，并提供了进行求解所需的所有必要信息。任务是在二维空间中实现并比较两种双曲网og生成方法。比较基于所得网格单元的均匀性，该均匀性通过单元雅可比行列式的变异系数 (CoV) 进行量化。\n\n解决此问题的算法步骤如下：\n\n1.  **初始边界的离散化**\n    该过程始于为参数 $u \\in [0,1]$ 定义的初始边界曲线 $\\boldsymbol{\\Gamma}(u) \\in \\mathbb{R}^2$。该曲线由 $\\boldsymbol{\\Gamma}(u) = (x(u), y(u))$ 给出，其中 $x(u) = u$ 且 $y(u) = y_0 + A\\sin(2\\pi u)$。这条连续曲线被离散化为 $M$ 个点 $\\mathbf{x}_{i,0}$，对应于 $u_i = i/(M-1)$，其中 $i=0, 1, \\ldots, M-1$。\n    $$\n    \\mathbf{x}_{i,0} = \\boldsymbol{\\Gamma}(u_i) = \\left( u_i, y_0 + A\\sin(2\\pi u_i) \\right)\n    $$\n    对于初始曲线上的每个点，我们必须计算其向外单位法向量 $\\mathbf{n}(u_i)$。这对于两种推进策略都是至关重要的。首先，通过微分求出曲线的切向量：\n    $$\n    \\frac{\\partial\\boldsymbol{\\Gamma}}{\\partial u} = \\left( \\frac{dx}{du}, \\frac{dy}{du} \\right) = (1, 2\\pi A \\cos(2\\pi u))\n    $$\n    单位切向量 $\\mathbf{t}(u)$ 是将此向量归一化到单位长度得到的：\n    $$\n    \\mathbf{t}(u) = \\frac{\\partial\\boldsymbol{\\Gamma}/\\partial u}{\\|\\partial\\boldsymbol{\\Gamma}/\\partial u\\|} = \\frac{(1, 2\\pi A \\cos(2\\pi u))}{\\sqrt{1^2 + (2\\pi A \\cos(2\\pi u))^2}} = (t_x(u), t_y(u))\n    $$\n    单位法向量 $\\mathbf{n}(u)$ 是通过将单位切向量旋转 $90^\\circ$ 得到的。问题指定选择 $\\mathbf{n}(u) = (-t_y(u), t_x(u))$，其方向必须定向，使其 $y$ 分量为非负。该法向量的 $y$ 分量是 $t_x(u)$，即 $1 / \\|\\partial\\boldsymbol{\\Gamma}/\\partial u\\|$。由于范数始终为正，所以 $t_x(u)  0$，因此这种法向量的选择天生就满足方向约束。计算并存储这 $M$ 个法向量 $\\mathbf{n}_i = \\mathbf{n}(u_i)$。\n\n2.  **通过显式欧拉格式进行网格推进**\n    网格是通过从初始边界向外推进生成的。网格点 $\\mathbf{x}(u,s)$ 是边界参数 $u$ 和推进参数 $s$ 的函数。网格的演化由双曲偏微分方程 (PDE) $\\partial_s \\mathbf{x} = \\alpha \\mathbf{d}$ 控制，其中 $\\mathbf{d}$ 是局部推进方向。\n    我们使用具有恒定步长 $\\Delta s = \\alpha$ 的简单前向欧拉格式在 $s$ 方向上对此PDE进行离散化。第 $j+1$ 步的网格由第 $j$ 步的网格计算得出：\n    $$\n    \\mathbf{x}(u_i, s_{j+1}) = \\mathbf{x}(u_i, s_j) + \\alpha\\,\\mathbf{d}(\\mathbf{x}(u_i,s_j), u_i)\n    $$\n    此更新对 $j=0, \\ldots, N-1$ 执行，生成一个大小为 $M \\times (N+1)$ 个点的网格。\n\n3.  **推进方向模型**\n    实现并比较了两种方向场 $\\mathbf{d}$ 的模型。\n\n    -   **仅边界法向推进 ($\\mathbf{d}_\\text{normal}$)**：这是一种较简单的模型。从 $\\boldsymbol{\\Gamma}(u_i)$ 出发的流线上任意点的推进方向是恒定的，等于该边界点的初始法向量。\n        $$\n        \\mathbf{d}_\\text{normal}(\\mathbf{x}, u_i) = \\mathbf{n}(u_i)\n        $$\n        由于流线由恒定的 $u_i$ 定义，因此沿着该流线的所有推进步骤 $j$ 的方向 $\\mathbf{d}$ 都是恒定的。\n\n    -   **基于Hessian矩阵的各向异性推进 ($\\mathbf{d}_\\text{aniso}$)**：该模型使推进方向适应背景标量场 $\\phi(x,y)$，以控制网格属性，如单元拉伸和方向。方向由该场的Hessian矩阵 $H = \\nabla\\nabla\\phi$ 决定。\n        $$\n        H(\\mathbf{x}) = \\begin{pmatrix} \\partial_{xx}\\phi  \\partial_{xy}\\phi \\\\ \\partial_{yx}\\phi  \\partial_{yy}\\phi \\end{pmatrix}\n        $$\n        对于每个推进步骤 $j$ 的每个点 $\\mathbf{x}_{i,j}$，推进方向 $\\mathbf{d}_\\text{aniso}$ 被选为Hessian矩阵 $H(\\mathbf{x}_{i,j})$ 对应其最大特征值 $\\lambda_{\\max}$ 的主特征向量 $\\mathbf{v}_{\\max}$。该特征向量指示了场 $\\phi$ 的最大曲率方向。然后，通过确保计算出的特征向量与初始法向量 $\\mathbf{n}(u_i)$ 的点积为非负来将其定向为“向外”：如果 $\\mathbf{v}_{\\max} \\cdot \\mathbf{n}(u_i)  0$，则将方向翻转为 $-\\mathbf{v}_{\\max}$。\n        一个特殊条件处理各向同性情况。如果 $H$ 的特征值在很小的数值容差范围内相等（即 $|\\lambda_{\\max} - \\lambda_{\\min}|  \\epsilon$），则该点处的场被认为是各向同性的，推进方向默认使用边界法向，即 $\\mathbf{d}_\\text{aniso} = \\mathbf{n}(u_i)$。\n\n4.  **网格质量评估**\n    网格生成后，将对其质量进行评估。网格单元的均匀性是一个关键指标。这通过坐标变换 $(u,s) \\to (x,y)$ 的雅可比行列式 $J$ 进行评估。我们对每个单元 $(i,j)$ 上的 $J$ 使用有限差分近似，它对应于由向量 $\\Delta_u \\mathbf{x} = \\mathbf{x}_{i+1,j} - \\mathbf{x}_{i,j}$ 和 $\\Delta_s \\mathbf{x} = \\mathbf{x}_{i,j+1} - \\mathbf{x}_{i,j}$ 构成的平行四边形的面积。\n    $$\n    J_{i,j} \\approx \\left| \\det(\\Delta_u \\mathbf{x}, \\Delta_s \\mathbf{x}) \\right| = \\left| (x_{i+1,j}-x_{i,j})(y_{i,j+1}-y_{i,j}) - (y_{i+1,j}-y_{i,j})(x_{i,j+1}-x_{i,j}) \\right|\n    $$\n    将所有这些单元面积 $\\{J_{i,j}\\}$（对于 $i \\in [0, M-2]$ 和 $j \\in [0, N-1]$）组合成一个集合。\n    为量化这些面积的均匀性，计算了变异系数 (CoV)。它是雅可比行列式集合的标准差 $\\sigma(J)$ 与平均值 $\\mu(J)$ 的比率。\n    $$\n    \\mathrm{CoV} = \\frac{\\sigma(J)}{\\mu(J)}\n    $$\n    较低的 CoV 表示网格更均匀，其中单元面积更一致。\n\n5.  **比较与最终输出**\n    对于三个测试案例中的每一个，我们生成两个网格：一个使用 $\\mathbf{d}_\\text{normal}$，另一个使用 $\\mathbf{d}_\\text{aniso}$。然后我们计算它们各自的均匀性指标，$\\mathrm{CoV}_\\text{normal}$ 和 $\\mathrm{CoV}_\\text{aniso}$。每个案例的最终结果是比率：\n    $$\n    R = \\frac{\\mathrm{CoV}_\\text{normal}}{\\mathrm{CoV}_\\text{aniso}}\n    $$\n    该比率量化了基于Hessian矩阵的方法所提供的网格均匀性的相对改善。值 $R  1.0$ 表示各向异性方法生成的网格比简单的法向推进方法具有更低的 CoV（即更好的均匀性）。对于案例3，Hessian矩阵在任何地方都是各向同性的，因此各向异性方法被设计为默认回退到仅法向推进方法。因此，我们期望 $\\mathrm{CoV}_\\text{normal} = \\mathrm{CoV}_\\text{aniso}$，从而得到 $R=1.0$，这可作为对实现方案的验证。然后报告这三个案例的计算比率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hyperbolic grid generation problem for three test cases.\n    \"\"\"\n    # Shared parameters\n    M = 51\n    N = 30\n    alpha = 0.015\n    y0 = 0.2\n    A = 0.05\n    \n    # Isotropic check tolerance\n    EIG_TOL = 1e-9\n\n    def get_hessian_case1(x, y):\n        a, b, c = 0.5, 4.0, 0.2\n        return np.array([[2.0 * a, c], [c, 2.0 * b]])\n\n    def get_hessian_case2(x, y):\n        return np.array([[2.0, y], [y, 2.0 + x]])\n\n    def get_hessian_case3(x, y):\n        return np.array([[2.0, 0.0], [0.0, 2.0]])\n\n    def compute_cov(grid):\n        \"\"\"\n        Computes the Coefficient of Variation (CoV) of the Jacobian for a given grid.\n        \"\"\"\n        # Vectorized computation of Jacobians (cell areas)\n        # delta_u_x: x_{i+1,j} - x_{i,j}\n        # delta_u_y: y_{i+1,j} - y_{i,j}\n        delta_u_x = grid[1:, :-1, 0] - grid[:-1, :-1, 0]\n        delta_u_y = grid[1:, :-1, 1] - grid[:-1, :-1, 1]\n        \n        # delta_s_x: x_{i,j+1} - x_{i,j}\n        # delta_s_y: y_{i,j+1} - y_{i,j}\n        delta_s_x = grid[:-1, 1:, 0] - grid[:-1, :-1, 0]\n        delta_s_y = grid[:-1, 1:, 1] - grid[:-1, :-1, 1]\n\n        jacobians = np.abs(delta_u_x * delta_s_y - delta_u_y * delta_s_x)\n        \n        if jacobians.size == 0:\n            return 0.0\n            \n        mean_j = np.mean(jacobians)\n        std_j = np.std(jacobians)\n\n        if mean_j == 0:\n            return 0.0 \n\n        return std_j / mean_j\n\n    def generate_grid(u_points, initial_normals, hessian_func=None):\n        \"\"\"\n        Generates a grid using either normal-only or Hessian-based marching.\n        \"\"\"\n        grid = np.zeros((M, N + 1, 2))\n        \n        # Initial condition: set grid at s=0 to the boundary curve\n        grid[:, 0, 0] = u_points\n        grid[:, 0, 1] = y0 + A * np.sin(2 * np.pi * u_points)\n\n        # Marching loop\n        for j in range(N):\n            if hessian_func is None:  # Normal-only marching\n                directions = initial_normals\n                grid[:, j + 1, :] = grid[:, j, :] + alpha * directions\n            else:  # Hessian-based anisotropic marching\n                for i in range(M):\n                    pt = grid[i, j, :]\n                    x, y = pt[0], pt[1]\n                    \n                    H = hessian_func(x, y)\n                    eigvals, eigvecs = np.linalg.eigh(H)\n                    \n                    # Check for isotropy\n                    if np.abs(eigvals[1] - eigvals[0])  EIG_TOL:\n                        direction = initial_normals[i]\n                    else:\n                        # Principal eigenvector (for largest eigenvalue)\n                        direction = eigvecs[:, 1]\n                        \n                        # Orient the direction vector\n                        if np.dot(direction, initial_normals[i])  0:\n                            direction = -direction\n                    \n                    grid[i, j + 1, :] = grid[i, j, :] + alpha * direction\n        \n        return grid\n\n    # Initial boundary discretization\n    u_i = np.linspace(0, 1, M)\n    \n    # Calculate initial tangent vectors\n    dx_du = np.ones_like(u_i)\n    dy_du = 2 * np.pi * A * np.cos(2 * np.pi * u_i)\n    \n    # Calculate initial unit normal vectors\n    tangent_norms = np.sqrt(dx_du**2 + dy_du**2)\n    t_x = dx_du / tangent_norms\n    t_y = dy_du / tangent_norms\n    \n    # n = (-t_y, t_x). n_y = t_x = 1/norm > 0, so orientation is correct.\n    normals = np.vstack((-t_y, t_x)).T\n\n    test_cases = [get_hessian_case1, get_hessian_case2, get_hessian_case3]\n    results = []\n\n    for hessian_func in test_cases:\n        # Generate grid with normal-only marching\n        grid_normal = generate_grid(u_i, normals, hessian_func=None)\n        cov_normal = compute_cov(grid_normal)\n\n        # Generate grid with Hessian-based marching\n        grid_aniso = generate_grid(u_i, normals, hessian_func=hessian_func)\n        cov_aniso = compute_cov(grid_aniso)\n\n        if cov_aniso == 0:\n             # Should not happen in these test cases, but robust for division\n            ratio = 1.0 if cov_normal == 0 else float('inf')\n        else:\n            ratio = cov_normal / cov_aniso\n        \n        results.append(ratio)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.15f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了基于Hessian矩阵的各向异性控制外，还存在其他灵活的网格控制策略。在复杂的几何环境中，我们常常希望同时满足多个相互竞争的几何目标，例如在保持壁面正交性的同时，将网格线向某个特定特征区域集中。本练习将演示一种实现这种多目标引导的直观方法：通过将来自不同几何特征（如壁面和吸引点）的影响向量进行加权平均，来构造一个复合的推进方向。这种技术展示了一种强大的设计哲学，即通过组合简单的规则来应对复杂的网格生成任务。",
            "id": "3332115",
            "problem": "考虑一个在计算流体力学（CFD）背景下的二维双曲网格生成过程。令物理域为一个宽度为 $L$、高度为 $H$ 的矩形（单位为米），计算映射为 $\\mathbf{x}(\\xi,s) \\in \\mathbb{R}^2$，其中 $\\xi \\in [0,1]$ 为初始曲线上点的索引，$s \\ge 0$ 是一个单位为米的前进坐标。双曲前进过程由以下常微分方程（ODE）定义\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial s}(\\xi,s) = \\mathbf{d}(\\mathbf{x}(\\xi,s)),\n$$\n其中前进方向 $\\mathbf{d}$ 在每个点上构造为特征方向的凸组合：\n$$\n\\mathbf{d}(\\mathbf{x}) = \\sum_{i=1}^{3} w_i \\mathbf{n}_i(\\mathbf{x}), \\quad w_i \\ge 0,\\quad \\sum_{i=1}^{3} w_i = 1,\n$$\n并且 $\\mathbf{n}_i(\\mathbf{x})$ 是与多个几何特征相关的单位方向场。具体定义三个特征：\n- 位于 $y=0$ 的底壁，其向外单位法向量为 $\\mathbf{n}_1(\\mathbf{x}) = [0,1]^\\top$，\n- 位于 $y=H$ 的顶壁，其向外单位法向量为 $\\mathbf{n}_2(\\mathbf{x}) = [0,-1]^\\top$，\n- 一个位于 $\\mathbf{c} = [L,H/2]^\\top$ 的点吸引子，其方向为 $\\mathbf{n}_3(\\mathbf{x}) = \\dfrac{\\mathbf{c} - \\mathbf{x}}{\\lVert \\mathbf{c} - \\mathbf{x} \\rVert}$。\n\n初始曲线规定为左边界段，\n$$\n\\mathbf{x}(\\xi,0) = [0, H\\xi]^\\top,\\quad \\xi \\in [0,1].\n$$\n\n您必须在一个具有 $M$ 个 $\\xi$ 方向点和 $N+1$ 个 $s$ 方向前进层的均匀网格上离散化映射 $\\mathbf{x}(\\xi,s)$，使用步长均匀（单位为米）的一阶显式更新方法：\n$$\n\\mathbf{x}(\\xi_j, s_{k+1}) = \\mathbf{x}(\\xi_j, s_k) + \\Delta s \\,\\widehat{\\mathbf{d}}(\\mathbf{x}(\\xi_j, s_k)),\n$$\n其中 $\\widehat{\\mathbf{d}}(\\mathbf{x})$ 是 $\\mathbf{d}(\\mathbf{x})$ 方向上的单位向量。如果 $\\lVert \\mathbf{d}(\\mathbf{x}) \\rVert$ 小于一个小的容差 $\\varepsilon$，则必须回退到 $\\widehat{\\mathbf{n}}_3(\\mathbf{x})$；如果 $\\lVert \\mathbf{c} - \\mathbf{x} \\rVert$ 也小于 $\\varepsilon$，则必须改用单位向量 $[1,0]^\\top$。在每次更新时，应用反射边界处理，将任何越界的坐标反射回域内，以保持映射在矩形 $[0,L] \\times [0,H]$ 内。\n\n将从计算坐标 $(\\xi,s)$ 到物理坐标 $\\mathbf{x}=(x,y)$ 的映射的雅可比行列式定义为\n$$\nJ(\\xi,s) = \\det \\left[\\frac{\\partial \\mathbf{x}}{\\partial \\xi}(\\xi,s),\\, \\frac{\\partial \\mathbf{x}}{\\partial s}(\\xi,s)\\right].\n$$\n在离散网格上使用有限差分来近似 $J(\\xi,s)$：对于由 $(\\xi_j,s_k)$、$(\\xi_{j+1},s_k)$ 和 $(\\xi_j,s_{k+1})$ 张成的每个单元，使用\n$$\nJ_{j,k} \\approx \\det\\left[\\mathbf{x}(\\xi_{j+1},s_k) - \\mathbf{x}(\\xi_j,s_k),\\, \\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k)\\right].\n$$\n\n此外，对于每个固定的 $\\xi_j$，特征曲线 $s \\mapsto \\mathbf{x}(\\xi_j,s)$ 的曲率 $\\kappa$ 由 Frenet 公式定义，\n$$\n\\kappa = \\frac{\\left\\lVert \\mathbf{t}'(s) \\right\\rVert}{\\left\\lVert \\mathbf{x}'(s) \\right\\rVert},\\qquad \\mathbf{t}(s) = \\frac{\\mathbf{x}'(s)}{\\left\\lVert \\mathbf{x}'(s) \\right\\rVert},\n$$\n您必须沿 $s$ 方向将其离散近似为\n$$\n\\kappa_{j,k} \\approx \\frac{\\left\\lVert \\mathbf{t}_{j,k+1} - \\mathbf{t}_{j,k} \\right\\rVert}{\\Delta s},\\quad \\mathbf{t}_{j,k} = \\frac{\\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k)}{\\left\\lVert \\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k) \\right\\rVert}.\n$$\n\n您的程序必须：\n- 实现上述前进过程，使用给定的特征和方向的凸组合。\n- 计算整个网格上的最小雅可比值，\n$$\n\\min J = \\min_{j,k} J_{j,k},\n$$\n以 $\\mathrm{m}^2$ 为单位表示。\n- 计算所有特征曲线和前进步骤中的最大曲率，\n$$\n\\max \\kappa = \\max_{j,k} \\kappa_{j,k},\n$$\n以 $\\mathrm{m}^{-1}$ 为单位表示。\n\n使用以下数值和几何参数：\n- $L = 1\\,\\mathrm{m}$,\n- $H = 1\\,\\mathrm{m}$,\n- $M = 51$,\n- $N = 50$,\n- $\\Delta s = 0.02\\,\\mathrm{m}$,\n- $\\varepsilon = 10^{-12}$。\n\n测试套件：对以下满足 $w_i \\ge 0$ 和 $\\sum_i w_i = 1$ 的权重三元组 $(w_1,w_2,w_3)$ 运行算法：\n- 情况1：$(0, 0, 1)$,\n- 情况2：$\\left(\\frac{1}{2}, \\frac{1}{2}, 0\\right)$,\n- 情况3：$(0.8, 0.1, 0.1)$,\n- 情况4：$(0.1, 0.8, 0.1)$。\n\n对于每种情况，计算并报告两个值 $[\\min J, \\max \\kappa]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身格式化为不带空格的二元列表。例如：\n$$\n\\text{[}[J_1,\\kappa_1],[J_2,\\kappa_2],\\dots\\text{]}\n$$\n报告 $J_i$（单位为 $\\mathrm{m}^2$）和 $\\kappa_i$（单位为 $\\mathrm{m}^{-1}$）。如果存在角度，必须以弧度为单位，任何分数都必须表示为小数。",
            "solution": "用户提供了一个计算流体力学（CFD）领域的问题陈述，具体涉及双曲网格生成。该问题要求实现一个数值算法来生成一个二维网格，然后使用雅可比行列式和路径曲率来分析其质量。首先对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取的已知条件**\n- **域**：由 $x \\in [0, L]$ 和 $y \\in [0, H]$ 定义的二维矩形，其中 $L=1\\,\\mathrm{m}$ 且 $H=1\\,\\mathrm{m}$。\n- **映射**：从计算坐标 $(\\xi, s)$到物理坐标 $(x,y)$ 的映射 $\\mathbf{x}(\\xi, s)$，其中 $\\xi \\in [0,1]$ 且 $s \\ge 0$。\n- **初始条件**：网格从初始曲线 $\\mathbf{x}(\\xi,0) = [0, H\\xi]^\\top$（对于 $\\xi \\in [0,1]$）开始。\n- **控制方程**：网格根据常微分方程（ODE）$\\frac{\\partial \\mathbf{x}}{\\partial s} = \\mathbf{d}(\\mathbf{x})$ 在 $s$ 方向上前进。\n- **前进方向**：方向场 $\\mathbf{d}(\\mathbf{x})$ 是三个特征方向的凸组合：$\\mathbf{d}(\\mathbf{x}) = \\sum_{i=1}^{3} w_i \\mathbf{n}_i(\\mathbf{x})$，其中 $w_i \\ge 0$ 且 $\\sum w_i = 1$。\n- **特征方向 $\\mathbf{n}_i$**：\n    - $\\mathbf{n}_1(\\mathbf{x}) = [0,1]^\\top$：来自底壁（$y=0$）的向外法线。\n    - $\\mathbf{n}_2(\\mathbf{x}) = [0,-1]^\\top$：来自顶壁（$y=H$）的向外法线。\n    - $\\mathbf{n}_3(\\mathbf{x}) = \\frac{\\mathbf{c} - \\mathbf{x}}{\\lVert \\mathbf{c} - \\mathbf{x} \\rVert}$：朝向点吸引子 $\\mathbf{c} = [L,H/2]^\\top$ 的方向。\n- **数值离散化**：\n    - 网格点：$\\xi$ 方向 $M=51$ 个点，$s$ 方向 $N+1=51$ 个层级。\n    - 前进步骤：显式一阶更新 $\\mathbf{x}(\\xi_j, s_{k+1}) = \\mathbf{x}(\\xi_j, s_k) + \\Delta s \\,\\widehat{\\mathbf{d}}(\\mathbf{x}(\\xi_j, s_k))$，步长 $\\Delta s = 0.02\\,\\mathrm{m}$。\n- **$\\widehat{\\mathbf{d}}$ 的回退逻辑**：$\\widehat{\\mathbf{d}}(\\mathbf{x})$ 是单位向量 $\\mathbf{d}/\\lVert\\mathbf{d}\\rVert$。如果 $\\lVert\\mathbf{d}\\rVert  \\varepsilon = 10^{-12}$，$\\widehat{\\mathbf{d}}$ 被设置为 $\\mathbf{n}_3(\\mathbf{x})$。如果此外 $\\lVert\\mathbf{c}-\\mathbf{x}\\rVert  \\varepsilon$，$\\widehat{\\mathbf{d}}$ 被设置为 $[1,0]^\\top$。\n- **边界处理**：在每一步应用反射边界条件，以将点保持在矩形 $[0,L] \\times [0,H]$ 内。\n- **分析指标**：\n    - **雅可比行列式**：$J_{j,k} \\approx \\det\\left[\\mathbf{x}(\\xi_{j+1},s_k) - \\mathbf{x}(\\xi_j,s_k),\\, \\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k)\\right]$。要报告的量是 $\\min J = \\min_{j,k} J_{j,k}$。\n    - **曲率**：$\\kappa_{j,k} \\approx \\frac{\\left\\lVert \\mathbf{t}_{j,k+1} - \\mathbf{t}_{j,k} \\right\\rVert}{\\Delta s}$，其中切线 $\\mathbf{t}_{j,k} = \\frac{\\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k)}{\\left\\lVert \\mathbf{x}(\\xi_j,s_{k+1}) - \\mathbf{x}(\\xi_j,s_k) \\right\\rVert}$。要报告的量是 $\\max \\kappa = \\max_{j,k} \\kappa_{j,k}$。\n- **测试用例**：四组权重 $(w_1, w_2, w_3)$：$(0, 0, 1)$, $(1/2, 1/2, 0)$, $(0.8, 0.1, 0.1)$ 和 $(0.1, 0.8, 0.1)$。\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估：\n- **科学基础**：该问题描述了一种在CFD中使用的标准双曲网格生成方法。控制方程、数值方案（显式欧拉法）和分析指标（雅可比行列式、曲率）在数值分析和微分几何中都是标准且有充分根据的。\n- **适定性**：该问题是一个具有明确初始条件（一条点线）的常微分方程组的初值问题。前进方向场在各处都有定义，并有明确的回退规则来处理潜在的奇点（在吸引子 $\\mathbf{c}$ 处）或退化情况（其中 $\\mathbf{d}=\\mathbf{0}$）。这确保了可以生成唯一的离散解。\n- **客观性**：问题陈述使用精确的数学语言，没有主观或含糊的术语。\n- **完整性和一致性**：提供了所有必需的数值参数（$L, H, M, N, \\Delta s, \\varepsilon$）、边界条件和公式。定义在内部是一致的。\n- **现实性和可行性**：所选参数对于数值模拟是合理的。物理设置是网格生成算法的标准测试用例。\n- **结构性和非平凡性**：该问题非同小可，需要实现一个完整的数值工作流程，包括迭代、向量场计算、边界处理和后处理。它结构良好，构成了一个实质性的计算挑战。\n\n**步骤3：结论和行动**\n该问题被判定为**有效**。这是一个清晰、自洽且科学上合理的计算科学练习。将开发一个解决方案。\n\n### 解决方案\n\n该问题要求实现一个二维双曲网格生成算法。该方法的核心是将网格生成过程视为求解一个双曲型偏微分方程组，这些方程在类时间坐标 $s$ 上向前推进。\n\n**1. 离散化与初始化**\n连续映射 $\\mathbf{x}(\\xi, s)$被离散化到一个网格上。坐标 $\\xi \\in [0,1]$ 被离散为 $M=51$ 个点，$\\xi_j = j/(M-1)$，其中 $j=0, \\dots, M-1$。前进坐标 $s$ 被离散为 $N+1=51$ 个层级，$s_k = k \\cdot \\Delta s$，其中 $k=0, \\dots, N$。解存储在一个三维数组 $\\mathbf{x}_{k,j}$ 中，表示节点 $(\\xi_j, s_k)$ 的物理坐标。\n\n该过程从 $s=s_0=0$ 处的初始网格线开始。问题中给出的初始坐标为 $\\mathbf{x}(\\xi,0) = [0, H\\xi]^\\top$。对于我们的离散网格，这转换为：\n$$\n\\mathbf{x}_{0,j} = \\begin{pmatrix} 0 \\\\ H \\cdot \\frac{j}{M-1} \\end{pmatrix}, \\quad j = 0, \\dots, M-1.\n$$\n\n**2. 前进算法**\n对于每个点 $j=0, \\dots, M-1$，使用显式一阶（欧拉）方法将网格从层级 $s_k$ 推进到 $s_{k+1}$。更新规则为：\n$$\n\\mathbf{x}_{k+1,j} = \\mathbf{x}_{k,j} + \\Delta s \\, \\widehat{\\mathbf{d}}(\\mathbf{x}_{k,j})\n$$\n关键在于计算归一化的前进方向向量 $\\widehat{\\mathbf{d}}$。这在每个点 $\\mathbf{x}_{k,j}$ 都是一个多步骤的过程：\n- **计算特征方向**：计算三个方向向量：\n  - $\\mathbf{n}_1 = [0, 1]^\\top$（从底壁推出）。\n  - $\\mathbf{n}_2 = [0, -1]^\\top$（从顶壁推出）。\n  - $\\mathbf{n}_3 = (\\mathbf{c} - \\mathbf{x}_{k,j}) / \\lVert \\mathbf{c} - \\mathbf{x}_{k,j} \\rVert$（拉向吸引子 $\\mathbf{c}=[L, H/2]^\\top$）。\n- **组合方向**：形成加权方向向量 $\\mathbf{d}$：\n  $$\n  \\mathbf{d}(\\mathbf{x}_{k,j}) = w_1 \\mathbf{n}_1 + w_2 \\mathbf{n}_2 + w_3 \\mathbf{n}_3(\\mathbf{x}_{k,j})\n  $$\n- **归一化并应用回退逻辑**：将向量 $\\mathbf{d}$ 归一化以获得单位方向 $\\widehat{\\mathbf{d}}$。必须遵循特定的回退逻辑：\n  1. 计算范数 $\\lVert \\mathbf{d} \\rVert$。\n  2. 如果 $\\lVert \\mathbf{d} \\rVert \\ge \\varepsilon$，则 $\\widehat{\\mathbf{d}} = \\mathbf{d} / \\lVert \\mathbf{d} \\rVert$。\n  3. 如果 $\\lVert \\mathbf{d} \\rVert  \\varepsilon$，则检查到吸引子的距离 $\\lVert \\mathbf{c} - \\mathbf{x}_{k,j} \\rVert$。\n     - 如果 $\\lVert \\mathbf{c} - \\mathbf{x}_{k,j} \\rVert \\ge \\varepsilon$，使用吸引子方向：$\\widehat{\\mathbf{d}} = \\mathbf{n}_3$。\n     - 如果 $\\lVert \\mathbf{c} - \\mathbf{x}_{k,j} \\rVert  \\varepsilon$，使用水平方向：$\\widehat{\\mathbf{d}} = [1, 0]^\\top$。\n\n- **应用反射边界条件**：计算出原始的下一个位置 $\\mathbf{x}_{k+1,j}^{\\text{raw}}$ 后，必须强制其保持在域 $[0, L] \\times [0, H]$ 内。一个移动到区间 $[c_{\\min}, c_{\\max}]$ 外的坐标 $c$ 会被反射回来。对于一个通用坐标 $p$ 和长度为 $S = p_{\\max} - p_{\\min}$ 的区间 $[p_{min}, p_{max}]$，可以这样实现：\n  $$\n  p_{\\text{norm}} = (p - p_{\\min}) \\pmod{2S}\n  $$\n  $$\n  p_{\\text{final}} = \\begin{cases} p_{\\text{norm}} + p_{\\min}  \\text{if } p_{\\text{norm}} \\le S \\\\ (2S - p_{\\text{norm}}) + p_{\\min}  \\text{if } p_{\\text{norm}}  S \\end{cases}\n  $$\n对 $k=0, \\dots, N-1$ 重复此过程，以生成完整的网格。\n\n**3. 网格质量分析**\n一旦网格 $\\mathbf{x}_{k,j}$ 完全生成，就使用两个指标评估其质量。\n\n- **最小雅可比值**：变换 $(\\xi, s) \\to (x, y)$ 的雅可比行列式衡量了局部单元的面积。雅可比值为零或负表示网格缠结或翻转，这是不希望看到的。源于 $(\\xi_j, s_k)$ 的单元的离散近似为：\n  $$\n  J_{j,k} = \\det\\left[ \\mathbf{x}_{k, j+1} - \\mathbf{x}_{k, j}, \\quad \\mathbf{x}_{k+1, j} - \\mathbf{x}_{k, j} \\right]\n  $$\n  这对所有有效索引（$j=0, \\dots, M-2$ 和 $k=0, \\dots, N-1$）进行计算，并找出整个网格的最小值。\n\n- **最大曲率**：特征曲线 $s \\mapsto \\mathbf{x}(\\xi_j, s)$ 的曲率表示网格线的弯曲剧烈程度。高曲率会对数值求解器的精度产生负面影响。曲率按规定进行离散近似：\n  $$\n  \\kappa_{j,k} \\approx \\frac{\\lVert \\mathbf{t}_{j,k+1} - \\mathbf{t}_{j,k} \\rVert}{\\Delta s}\n  $$\n  其中切向量 $\\mathbf{t}_{j,k}$ 是根据最终的网格点（经过边界反射后）计算的：\n  $$\n  \\mathbf{t}_{j,k} = \\frac{\\mathbf{x}_{k+1,j} - \\mathbf{x}_{k,j}}{\\lVert \\mathbf{x}_{k+1,j} - \\mathbf{x}_{k,j} \\rVert}\n  $$\n  此计算需要用到第 $k+2$ 步的点，因此对 $j=0, \\dots, M-1$ 和 $k=0, \\dots, N-2$ 执行。报告该范围内的最大值。\n\n从初始化到分析的整个过程，对四个指定的权重三元组 $(w_1, w_2, w_3)$ 中的每一个都重复进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reflect(coords, c_min, c_max):\n    \"\"\"\n    Apply reflective boundary conditions to an array of coordinates.\n    \n    Args:\n        coords (np.ndarray): Array of coordinates to be reflected.\n        c_min (float): The minimum boundary.\n        c_max (float): The maximum boundary.\n    \n    Returns:\n        np.ndarray: Coordinates reflected back into the [c_min, c_max] domain.\n    \"\"\"\n    span = c_max - c_min\n    if span = 0:\n        return coords\n\n    # Normalize coordinates to the [0, span] interval's geometry\n    # The Python % operator handles negative numbers in a way that works for this \"unfolding\"\n    norm_coords = (coords - c_min) % (2 * span)\n    \n    # Reflect coordinates that are in the \"mirrored\" part of the 2*span interval\n    reflected_coords = np.where(norm_coords > span, 2 * span - norm_coords, norm_coords)\n    \n    return reflected_coords + c_min\n\ndef run_simulation(L, H, M, N, delta_s, epsilon, weights):\n    \"\"\"\n    Runs a single hyperbolic grid generation simulation for a given set of weights.\n    \"\"\"\n    w1, w2, w3 = weights\n    \n    # 1. Grid Initialization\n    # X stores grid points (x, y) for each marching step k and initial curve point j\n    # Shape: (N+1, M, 2) which corresponds to (s_k, xi_j, coord)\n    X = np.zeros((N + 1, M, 2))\n    \n    # Initial curve: x(xi, 0) = [0, H*xi]\n    xi = np.linspace(0.0, 1.0, M)\n    X[0, :, 0] = 0.0\n    X[0, :, 1] = H * xi\n    \n    # Attractor point\n    c = np.array([L, H / 2.0])\n    \n    # 2. Marching Algorithm\n    for k in range(N):\n        x_current = X[k, :, :] # Shape (M, 2)\n        \n        # Calculate feature directions\n        n1 = np.array([0.0, 1.0]) # Will be broadcast to (M, 2) during addition\n        n2 = np.array([0.0, -1.0]) # Will be broadcast to (M, 2) during addition\n        \n        vec_to_c = c - x_current\n        dist_to_c = np.linalg.norm(vec_to_c, axis=1, keepdims=True)\n        # Use epsilon to prevent division by zero for points at c\n        n3 = vec_to_c / np.maximum(dist_to_c, epsilon)\n        \n        # Calculate marching direction d as a convex combination\n        d = w1 * n1 + w2 * n2 + w3 * n3\n        d_norm = np.linalg.norm(d, axis=1, keepdims=True)\n        \n        # Calculate unit marching direction d_hat with fallback logic\n        d_hat = np.zeros_like(d)\n        \n        # General case: norm of d is not negligible\n        valid_d_mask = (d_norm > epsilon).flatten()\n        if np.any(valid_d_mask):\n            d_hat[valid_d_mask] = (d / d_norm)[valid_d_mask]\n\n        # Fallback 1: norm of d is negligible, so use n3\n        fallback1_mask = ~valid_d_mask\n        if np.any(fallback1_mask):\n            d_hat[fallback1_mask] = n3[fallback1_mask]\n        \n            # Fallback 2: point is also at the attractor, use [1,0]\n            dist_to_c_flat = dist_to_c.flatten()\n            fallback2_mask = fallback1_mask  (dist_to_c_flat  epsilon)\n            if np.any(fallback2_mask):\n                d_hat[fallback2_mask] = np.array([1.0, 0.0])\n\n        # Explicit first-order update\n        x_next_raw = x_current + delta_s * d_hat\n        \n        # Apply reflective boundary conditions\n        x_next = np.zeros_like(x_next_raw)\n        x_next[:, 0] = reflect(x_next_raw[:, 0], 0.0, L)\n        x_next[:, 1] = reflect(x_next_raw[:, 1], 0.0, H)\n        \n        X[k + 1, :, :] = x_next\n        \n    # 3. Post-processing and Analysis\n    \n    # Jacobian Calculation (for cells j=0..M-2, k=0..N-1)\n    # Vector along xi: x(j+1, k) - x(j, k)\n    v_xi = X[:N, 1:, :] - X[:N, :-1, :]\n    # Vector along s: x(j, k+1) - x(j, k)\n    v_s = X[1:, :-1, :] - X[:N, :-1, :]\n    \n    # Jacobian J = det([v_xi, v_s]) = v_xi_x * v_s_y - v_xi_y * v_s_x\n    jacobians = v_xi[:, :, 0] * v_s[:, :, 1] - v_xi[:, :, 1] * v_s[:, :, 0]\n    min_J = np.min(jacobians)\n    \n    # Curvature Calculation (for curves j=0..M-1, steps k=0..N-2)\n    if N  2:\n        max_kappa = 0.0\n    else:\n        # Tangent vectors t_k = (x_{k+1} - x_k) / ||x_{k+1} - x_k||\n        # for k=0..N-1\n        diff_x = X[1:, :, :] - X[:-1, :, :]\n        norm_diff_x = np.linalg.norm(diff_x, axis=2, keepdims=True)\n        t = diff_x / np.maximum(norm_diff_x, epsilon) # Shape (N, M, 2)\n        \n        # Difference in tangents: t_{k+1} - t_k for k=0..N-2\n        diff_t = t[1:, :, :] - t[:-1, :, :] # Shape (N-1, M, 2)\n        norm_diff_t = np.linalg.norm(diff_t, axis=2)\n        \n        curvatures = norm_diff_t / delta_s\n        max_kappa = np.max(curvatures) if curvatures.size > 0 else 0.0\n        \n    return min_J, max_kappa\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.0, 1.0),\n        (0.5, 0.5, 0.0),\n        (0.8, 0.1, 0.1),\n        (0.1, 0.8, 0.1),\n    ]\n\n    # Define numerical and geometric parameters\n    L = 1.0\n    H = 1.0\n    M = 51\n    N = 50\n    delta_s = 0.02\n    epsilon = 1e-12\n\n    results = []\n    for weights in test_cases:\n        min_J, max_kappa = run_simulation(L, H, M, N, delta_s, epsilon, weights)\n        results.append(f\"[{min_J},{max_kappa}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}