{
    "hands_on_practices": [
        {
            "introduction": "高效的边界层网格必须足够精细，以解析近壁区域的陡峭速度梯度。本练习将演示如何利用经典的流体力学理论，将这一物理要求转化为具体的网格尺寸规范。通过利用Falkner-Skan相似性解这一解析工具，您将推导出精确捕捉流动物理所需的近壁第一层法向间距，从而将理论与实践直接联系起来。",
            "id": "3297059",
            "problem": "在计算流体动力学（CFD）的背景下，考虑一个二维、稳态、层流的楔形流流经一个平壁，其外部速度由 $U_{e}(x) = U_{0} \\left( \\frac{x}{L} \\right)^{m}$ 给出，其中 $m=1$。流体的运动粘度为 $\\nu$，壁面法向坐标为 $y$。为了构建一个优先解析流向速度的壁面法向梯度的各向异性棱柱边界层网格，采用 Falkner–Skan 相似性框架，其相似性变量为 $\\eta = y \\alpha(x)$，速度表示为 $u(x,y) = U_{e}(x) f'(\\eta)$，以及相似性常微分方程\n$$\nf'''(\\eta) + f(\\eta) f''(\\eta) + \\beta \\left( 1 - f'(\\eta)^{2} \\right) = 0,\n$$\n满足边界条件 $f(0) = 0$, $f'(0) = 0$ 和当 $\\eta \\to \\infty$ 时 $f'(\\eta) \\to 1$，其中 $\\beta = \\frac{2m}{m+1}$ 且 $\\alpha(x)$ 由边界层标度定义。对于 $m=1$，该情况对应于驻点楔形流，此时 $\\beta = 1$ 且 $\\alpha(x) = \\sqrt{\\frac{U_{e}(x)}{\\nu x}}$。\n\n一个与壁面切向和壁面法向对齐的各向异性网格度量张量 $M(x)$ 定义为\n$$\nM(x) = R(x)^{\\top} \\, \\mathrm{diag}\\!\\left( \\frac{1}{h_{t}(x)^{2}}, \\, \\frac{1}{h_{n}(x)^{2}} \\right) R(x),\n$$\n其中 $R(x)$ 是一个标准正交旋转，其列为单位壁面切向和法向向量，$h_{t}(x)$ 和 $h_{n}(x)$ 分别是切向和法向的目标网格间距。网格受到的约束是，$u$ 的壁面法向梯度在一个长度为 $h_{n}$ 的壁面法向边上的相对变化不超过一个指定的界限 $\\varepsilon_{g}$，即，\n$$\n\\frac{\\left| \\left( \\frac{\\partial^{2} u}{\\partial y^{2}} \\right)_{w} \\right| h_{n}}{\\left| \\left( \\frac{\\partial u}{\\partial y} \\right)_{w} \\right|} \\leq \\varepsilon_{g},\n$$\n并且连续的棱柱层间距在壁面法向上遵循一个最大增长因子 $g_{\\max}$，使得 $h_{n,k+1} \\leq g_{\\max} \\, h_{n,k}$。\n\n从 Falkner–Skan 相似性公式及其壁面条件出发，推导壁面处法向间距约束 $h_{n}$ 的表达式，该表达式用 $U_{e}(x)$、$x$、$\\nu$、$\\varepsilon_{g}$ 以及近壁值 $f''(0)$ 和 $f'''(0)$ 表示。利用此表达式符号化地构建 $M(x)$（用 $h_{t}(x)$ 和 $h_{n}(x)$ 表示），然后计算驻点情况（$m=1$）下，当 $U_{0} = 30 \\,\\mathrm{m/s}$，$L = 1 \\,\\mathrm{m}$，$\\nu = 1.5 \\times 10^{-5} \\,\\mathrm{m^{2}/s}$ 且 $\\varepsilon_{g} = 0.05$ 时，在 $x=L$ 处的第一层壁面法向间距 $h_{1}$。假设在 $\\eta=0$ 处已知的 Falkner–Skan 壁面值为 $f''(0) = 1$ 和 $f'''(0) = -\\beta$。将 $h_{1}$ 的答案四舍五入到四位有效数字，并以米为单位表示。",
            "solution": "在进行求解之前，根据指定标准对问题陈述进行严格评估。\n\n### 步骤1：提取给定条件\n-   **流动背景**: 二维、稳态、层流的楔形流流经一个平壁。\n-   **外部速度**: $U_{e}(x) = U_{0} \\left( \\frac{x}{L} \\right)^{m}$，其中 $m=1$。\n-   **流体性质**: 运动粘度 $\\nu$。\n-   **坐标**: 壁面切向坐标 $x$，壁面法向坐标 $y$。\n-   **相似解**: Falkner–Skan 框架，相似性变量为 $\\eta = y \\alpha(x)$，速度表示为 $u(x,y) = U_{e}(x) f'(\\eta)$。\n-   **控制常微分方程**: $f'''(\\eta) + f(\\eta) f''(\\eta) + \\beta \\left( 1 - f'(\\eta)^{2} \\right) = 0$。\n-   **边界条件**: $f(0) = 0$，$f'(0) = 0$，以及当 $\\eta \\to \\infty$ 时 $f'(\\eta) \\to 1$。\n-   **参数**: $\\beta = \\frac{2m}{m+1}$ 和 $\\alpha(x) = \\sqrt{\\frac{U_{e}(x)}{\\nu x}}$。\n-   **特定情况**: 对于 $m=1$，流动为驻点楔形流，此时 $\\beta = 1$。\n-   **假定的壁面值**: 对于 $m=1$ 的情况，$f''(0) = 1$ 和 $f'''(0) = -\\beta$。\n-   **网格度量张量**: $M(x) = R(x)^{\\top} \\, \\mathrm{diag}\\!\\left( \\frac{1}{h_{t}(x)^{2}}, \\, \\frac{1}{h_{n}(x)^{2}} \\right) R(x)$，其中 $R(x)$ 是用于壁面对齐的旋转矩阵，$h_t(x)$ 和 $h_n(x)$ 是目标网格间距。\n-   **网格间距约束**: $\\frac{\\left| \\left( \\frac{\\partial^{2} u}{\\partial y^{2}} \\right)_{w} \\right| h_{n}}{\\left| \\left( \\frac{\\partial u}{\\partial y} \\right)_{w} \\right|} \\leq \\varepsilon_{g}$。\n-   **数值**: $U_{0} = 30 \\,\\mathrm{m/s}$，$L = 1 \\,\\mathrm{m}$，$\\nu = 1.5 \\times 10^{-5} \\,\\mathrm{m^{2}/s}$，$\\varepsilon_{g} = 0.05$。\n-   **计算目标**: 计算在 $x=L$ 处的第一层壁面法向间距 $h_{1}$ 并四舍五入到四位有效数字。\n\n### 步骤2：使用提取的给定条件进行验证\n该问题是适定的，并且其科学基础在于已建立的层流边界层理论（特别是 Falkner-Skan 相似解）及其在计算流体动力学网格生成中的应用。所有方程、定义和约束在该领域都是标准的。所提供的参数和条件是自洽且一致的。\n\n对于驻点情况（$m=1, \\beta=1$），假设 $f''(0)=1$ 的指令是一种简化，因为数值计算值为 $f''(0) \\approx 1.232588$。然而，提供一个特定的假定值是一种常见的教学工具，它使问题能够被解析处理，并用于测试推导过程本身，而无需外部数值数据。这不构成科学缺陷，而是这个自洽问题的一个定义前提。关系式 $f'''(0) = -\\beta$ 可以通过在 $\\eta=0$ 处对 Falkner-Skan 常微分方程使用给定的边界条件 $f(0)=0$ 和 $f'(0)=0$ 直接推导出来，这证实了其一致性。\n\n所有其他数据在物理上都是现实的，并且在量纲上是一致的。该问题是客观、无歧义的，并存在一个唯一、可验证的解。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将按要求推导解答。\n\n### 解答推导\n目标有三个方面：首先，基于给定的约束推导壁面法向网格间距 $h_{n}$ 的表达式；其次，构建符号化的网格度量张量 $M(x)$；第三，计算在 $x=L$ 处第一层间距 $h_{1}$ 的数值。\n\n网格间距约束由下式给出：\n$$\n\\frac{\\left| \\left( \\frac{\\partial^{2} u}{\\partial y^{2}} \\right)_{w} \\right| h_{n}}{\\left| \\left( \\frac{\\partial u}{\\partial y} \\right)_{w} \\right|} \\leq \\varepsilon_{g}\n$$\n其中下标 `$w$` 表示在壁面处（即 $y=0$ 处）取值。对于邻近壁面的第一层单元，我们取等式来确定最大允许间距，我们将其表示为 $h_n$（对于第一层则为 $h_1$）。\n$$\nh_{n} = \\varepsilon_{g} \\frac{\\left| \\left( \\frac{\\partial u}{\\partial y} \\right)_{w} \\right|}{\\left| \\left( \\frac{\\partial^{2} u}{\\partial y^{2}} \\right)_{w} \\right|}\n$$\n为了计算该表达式，我们必须求出流向速度 $u(x,y)$ 的壁面法向导数。速度由相似解 $u(x,y) = U_{e}(x) f'(\\eta)$ 给出，其中相似性变量为 $\\eta = y \\alpha(x)$。项 $\\alpha(x)$ 与 $y$ 无关。\n\n我们使用链式法则计算关于 $y$ 的导数：\n$$\n\\frac{\\partial}{\\partial y} = \\frac{d\\eta}{dy} \\frac{d}{d\\eta} = \\alpha(x) \\frac{d}{d\\eta}\n$$\n$u$ 的一阶壁面法向导数是：\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( U_{e}(x) f'(\\eta) \\right) = U_{e}(x) \\frac{\\partial}{\\partial y} f'(\\eta) = U_{e}(x) \\left( \\alpha(x) \\frac{d}{d \\eta} f'(\\eta) \\right) = U_{e}(x) \\alpha(x) f''(\\eta)\n$$\n二阶壁面法向导数是：\n$$\n\\frac{\\partial^{2} u}{\\partial y^{2}} = \\frac{\\partial}{\\partial y} \\left( U_{e}(x) \\alpha(x) f''(\\eta) \\right) = U_{e}(x) \\alpha(x) \\frac{\\partial}{\\partial y} f''(\\eta) = U_{e}(x) \\alpha(x) \\left( \\alpha(x) \\frac{d}{d\\eta} f''(\\eta) \\right) = U_{e}(x) \\alpha(x)^{2} f'''(\\eta)\n$$\n现在，我们在壁面处（$y=0$，对应于 $\\eta = 0$）计算这些导数：\n$$\n\\left( \\frac{\\partial u}{\\partial y} \\right)_{w} = U_{e}(x) \\alpha(x) f''(0)\n$$\n$$\n\\left( \\frac{\\partial^{2} u}{\\partial y^{2}} \\right)_{w} = U_{e}(x) \\alpha(x)^{2} f'''(0)\n$$\n将这些表达式代回 $h_n$ 的公式中：\n$$\nh_{n} = \\varepsilon_{g} \\frac{\\left| U_{e}(x) \\alpha(x) f''(0) \\right|}{\\left| U_{e}(x) \\alpha(x)^{2} f'''(0) \\right|}\n$$\n因为当 $x>0$ 时，$U_e(x)$ 和 $\\alpha(x)$ 均为正，我们可以将其简化为：\n$$\nh_{n} = \\varepsilon_{g} \\frac{|f''(0)|}{\\alpha(x) |f'''(0)|}\n$$\n最后，我们代入 $\\alpha(x) = \\sqrt{\\frac{U_{e}(x)}{\\nu x}}$ 的定义：\n$$\nh_{n}(x) = \\varepsilon_{g} \\frac{|f''(0)|}{|f'''(0)|} \\left( \\frac{U_{e}(x)}{\\nu x} \\right)^{-\\frac{1}{2}} = \\varepsilon_{g} \\frac{|f''(0)|}{|f'''(0)|} \\sqrt{\\frac{\\nu x}{U_{e}(x)}}\n$$\n这就是所求的壁面处法向单元间距作为 $x$ 的函数的表达式。\n\n接下来，我们构建网格度量张量 $M(x)$。问题陈述中说明流动是流经一个平壁。我们可以对齐坐标系，使得 $x$ 轴与壁面相切，$y$ 轴与壁面垂直。在这种情况下，单位切向向量是 $[1, 0]^T$，单位法向向量是 $[0, 1]^T$。因此，旋转矩阵 $R(x)$ 是单位矩阵 $I$。\n$$\nR(x) = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n度量张量变为：\n$$\nM(x) = I^{\\top} \\mathrm{diag}\\!\\left( \\frac{1}{h_{t}(x)^{2}}, \\, \\frac{1}{h_{n}(x)^{2}} \\right) I = \\begin{pmatrix} \\frac{1}{h_{t}(x)^{2}}  0 \\\\ 0  \\frac{1}{h_{n}(x)^{2}} \\end{pmatrix}\n$$\n代入我们推导出的 $h_n(x)$ 表达式：\n$$\nM(x) = \\begin{pmatrix} \\frac{1}{h_{t}(x)^{2}}  0 \\\\ 0  \\left( \\frac{|f'''(0)|}{\\varepsilon_{g} |f''(0)|} \\right)^{2} \\frac{U_{e}(x)}{\\nu x} \\end{pmatrix}\n$$\n\n最后，我们计算指定驻点流在 $x=L$ 处的第一层壁面法向间距 $h_1 = h_n(x=L)$。\n-   给定 $m=1$，压力梯度参数为 $\\beta = \\frac{2(1)}{1+1} = 1$。\n-   外部速度为 $U_e(x) = U_0 \\frac{x}{L}$。在 $x=L$ 处，这得到 $U_e(L) = U_0 \\frac{L}{L} = U_0$。\n-   壁面值由 $f''(0) = 1$ 和 $f'''(0) = -\\beta = -1$ 给出。\n-   $x=L$ 处第一层高度 $h_1$ 的表达式为：\n$$\nh_{1} = h_{n}(L) = \\varepsilon_{g} \\frac{|f''(0)|}{|f'''(0)|} \\sqrt{\\frac{\\nu L}{U_{e}(L)}} = \\varepsilon_{g} \\frac{|1|}{|-1|} \\sqrt{\\frac{\\nu L}{U_{0}}}\n$$\n现在，我们代入数值：\n-   $U_{0} = 30 \\,\\mathrm{m/s}$\n-   $L = 1 \\,\\mathrm{m}$\n-   $\\nu = 1.5 \\times 10^{-5} \\,\\mathrm{m^{2}/s}$\n-   $\\varepsilon_{g} = 0.05$\n$$\nh_{1} = 0.05 \\times \\frac{1}{1} \\times \\sqrt{\\frac{(1.5 \\times 10^{-5} \\,\\mathrm{m^{2}/s}) \\times (1 \\,\\mathrm{m})}{30 \\,\\mathrm{m/s}}}\n$$\n$$\nh_{1} = 0.05 \\sqrt{\\frac{1.5 \\times 10^{-5}}{30} \\,\\mathrm{m^2}} = 0.05 \\sqrt{5 \\times 10^{-7} \\,\\mathrm{m^2}}\n$$\n$$\nh_{1} = 0.05 \\times \\sqrt{5} \\times 10^{-3.5} \\,\\mathrm{m} = 0.05 \\times \\sqrt{50 \\times 10^{-8}} \\,\\mathrm{m} = 0.05 \\times \\sqrt{50} \\times 10^{-4} \\,\\mathrm{m}\n$$\n$$\nh_{1} = 0.05 \\times (7.0710678...) \\times 10^{-4} \\,\\mathrm{m}\n$$\n$$\nh_{1} = 0.35355339... \\times 10^{-4} \\,\\mathrm{m} = 3.5355339... \\times 10^{-5} \\,\\mathrm{m}\n$$\n四舍五入到四位有效数字，我们得到：\n$$\nh_{1} \\approx 3.536 \\times 10^{-5} \\,\\mathrm{m}\n$$",
            "answer": "$$ \\boxed{3.536 \\times 10^{-5}} $$"
        },
        {
            "introduction": "在确定了所需的网格层间距后，下一个挑战是如何在空间中实际放置网格节点。本练习在一个曲面壁上比较了两种常见的拉伸方法——法向投影和简化的跨限插值——从而揭示了网格生成中的一个基本权衡。您将实现这两种技术，并定量评估它们对几何精度、单元质量以及壁面剪切应力数值估算的影响，深入理解网格划分选择如何影响最终的模拟结果。",
            "id": "3297008",
            "problem": "要求您在二维空间中比较两种在波浪形壁面上生成结构化边界层网格的策略：与固定垂直方向对齐的超限插值拉伸，以及与物理壁面法线对齐的法向投影拉伸。壁面由单值函数 $z = a \\sin(k x)$ 给出，其中 $x$ 的单位为米，$z$ 的单位也为米。您的任务是量化几何误差以及其对雅可比行列式和壁面剪切应力估算模型问题所产生的影响。您必须实现一个完整、可运行的程序，为指定的测试套件执行这些计算。\n\n从以下基本依据和核心定义开始：\n- 壁面是参数曲线 $\\boldsymbol{r}_w(x) = (x, a \\sin(k x))$，其中 $x \\in [0, L]$，$L = 2\\pi/k$。\n- （未归一化的）切向向量为 $\\boldsymbol{t} = \\partial \\boldsymbol{r}_w/\\partial x = (1, a k \\cos(k x))$，外向单位法向量为 $\\hat{\\boldsymbol{n}} = \\boldsymbol{n}/\\|\\boldsymbol{n}\\|$，其中 $\\boldsymbol{n} = (-a k \\cos(k x), 1)$ 且 $\\|\\boldsymbol{n}\\| = \\sqrt{1 + (a k \\cos(k x))^2}$。\n- 结构化边界层网格是通过从壁面向流体中拉伸层来构建的。设离散层数为 $N \\in \\mathbb{N}$，期望的法向距离序列为一个等比数列，其第一层间距为 $y_1$，增长率为 $r > 0$，即未缩放的层增量为 $\\Delta n_j^{\\text{raw}} = y_1 r^{j-1}$，其中 $j \\in \\{1,\\dots,N\\}$。到第 $j$ 层的累积未缩放距离为 $S_j = \\sum_{m=1}^j \\Delta n_m^{\\text{raw}}$。为了强制达到指定的外边界层高度 $H$（单位为米），通过一个因子 $c = H/S_N$ 缩放这些距离，使得目标累积法向距离为 $n_j = c S_j$，其中 $n_0 = 0$ 且 $n_N = H$。\n- 此处定义的超限插值对齐拉伸是一种垂直方向拉伸：在给定的壁面点 $(x, z_w)$，第 $j$ 层的网格节点为 $\\boldsymbol{r}^{\\mathrm{TFI}}(x,j) = (x, z_w) + n_j \\,\\hat{\\boldsymbol{e}}_z$，其中 $\\hat{\\boldsymbol{e}}_z = (0,1)$。\n- 法向投影拉伸由 $\\boldsymbol{r}^{\\mathrm{NP}}(x,j) = \\boldsymbol{r}_w(x) + n_j \\,\\hat{\\boldsymbol{n}}(x)$ 定义。\n- 计算坐标为 $(\\xi,\\eta)$，其中 $\\xi \\in [0,1]$ 被均匀离散为 $N_x$ 个节点，映射到 $x \\in [0,L]$，而 $\\eta$ 隐式地索引各层 $j \\in \\{0,\\dots,N\\}$。\n- 局部映射单元（在索引空间中位于 $(i,j-1)$ 和 $(i+1,j)$ 之间）的物理边向量为 $\\boldsymbol{E}_\\xi = \\boldsymbol{r}(i+1,j-1) - \\boldsymbol{r}(i,j-1)$ 和 $\\boldsymbol{E}_\\eta = \\boldsymbol{r}(i,j) - \\boldsymbol{r}(i,j-1)$。该单元的离散雅可比行列式的大小为 $J_{\\text{cell}} = |\\boldsymbol{E}_\\xi \\times \\boldsymbol{E}_\\eta|$，其中二维标量叉积为 $\\boldsymbol{a} \\times \\boldsymbol{b} = a_x b_z - a_z b_x$。\n- 在理想化的正交映射中，一个计算单元的真实参考面积缩放是 $\\Delta x \\,\\Delta n_j$ 的乘积，其中 $\\Delta x = L/(N_x-1)$ 且 $\\Delta n_j = n_j - n_{j-1}$。\n\n定义并计算以下量化指标：\n1) 节点处的几何法向距离误差：对于一个网格节点 $\\boldsymbol{r}(x,j)$，将其真实法向距离定义为 $d_{\\perp}(x,j) = (\\boldsymbol{r}(x,j) - \\boldsymbol{r}_w(x)) \\cdot \\hat{\\boldsymbol{n}}(x)$。逐点几何误差为 $e_n(x,j) = d_{\\perp}(x,j) - n_j$。对每个网格，计算在所有流向位置和所有离壁层上的均方根（RMS）值，\n$$\nE_{n,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x \\, N}\\sum_{i=1}^{N_x}\\sum_{j=1}^N e_n(x_i,j)^2}.\n$$\n\n2) 通过归一化最小雅可比行列式衡量的雅可比质量：对每个网格，计算比率\n$$\n\\rho_{i,j} = \\frac{J_{\\text{cell}}(i,j)}{\\Delta x \\,\\Delta n_j}\n$$\n该计算针对所有内部单元，其索引为 $i \\in \\{1,\\dots,N_x-1\\}$ 和 $j \\in \\{1,\\dots,N\\}$。报告整个网格上的最小值，\n$$\n\\rho_{\\min} = \\min_{i,j} \\rho_{i,j}.\n$$\n\n3) 对使用模型近壁切向速度剖面进行壁面剪切应力估算的影响。设壁面法向坐标系下的解析切向速度为 $u_t(n) = U_\\infty\\left(1 - e^{-n/\\ell}\\right)$，其中 $U_\\infty$ 的单位为米/秒，$\\ell$ 的单位为米。真实壁面剪切应力为 $\\tau_w^{\\mathrm{true}} = \\mu \\,\\partial u_t/\\partial n|_{n=0} = \\mu\\, U_\\infty/\\ell$，其中动力粘度 $\\mu$ 的单位为帕斯卡-秒，剪切应力的单位为帕斯卡。一种常见的单边离散估计量使用第一个离壁节点。对于每个 $x_i$，令 $\\boldsymbol{v}_1 = \\boldsymbol{r}(x_i,1) - \\boldsymbol{r}_w(x_i)$，$n_1(x_i) = \\boldsymbol{v}_1 \\cdot \\hat{\\boldsymbol{n}}(x_i)$，以及 $d_1(x_i) = \\|\\boldsymbol{v}_1\\|$。定义\n$$\n\\tau_w^{\\mathrm{est}}(x_i) = \\mu \\,\\frac{u_t(n_1(x_i)) - u_t(0)}{d_1(x_i)} = \\mu \\, \\frac{U_\\infty \\left(1 - e^{-n_1(x_i)/\\ell}\\right)}{d_1(x_i)}.\n$$\n计算沿壁面的均方根相对误差，\n$$\n\\varepsilon_{\\tau,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\left(\\frac{\\tau_w^{\\mathrm{est}}(x_i) - \\tau_w^{\\mathrm{true}}}{\\tau_w^{\\mathrm{true}}}\\right)^2}.\n$$\n\n实现要求：\n- 在同一个流向网格上构建两种网格，该网格包含 $N_x$ 个点，均匀地跨越一个波长 $L = 2\\pi/k$。\n- 对两种网格使用相同的层分布 $\\{n_j\\}_{j=0}^N$，该分布由等比数列计算并缩放以使 $n_N = H$。\n- 对于雅可比比率，两种网格使用相同的 $\\Delta n_j$ 作为归一化因子。\n- 对于壁面剪切应力模型，所有测试用例使用相同的 $U_\\infty$、$\\mu$ 和 $\\ell$。通过构建无量纲相对误差来隐式地用帕斯卡回答与剪切相关的指标；最终报告的指标必须是无量纲的。\n\n测试套件：\n使用以下三组参数。所有有量纲的量均采用国际单位制（SI）。\n- 情况 1：$a = 0$，$k = 2\\pi$，$H = 2.0\\times 10^{-2}$，$N = 40$，$N_x = 401$，$y_1 = 1.0\\times 10^{-5}$，$r = 1.2$，$U_\\infty = 1.0\\times 10^{1}$，$\\mu = 1.0\\times 10^{-3}$，$\\ell = 2.0\\times 10^{-4}$。\n- 情况 2：$a = 1.0\\times 10^{-2}$，$k = 1.0\\times 10^{1}$，$H = 2.0\\times 10^{-2}$，$N = 40$，$N_x = 401$，$y_1 = 1.0\\times 10^{-5}$，$r = 1.2$，$U_\\infty = 1.0\\times 10^{1}$，$\\mu = 1.0\\times 10^{-3}$，$\\ell = 2.0\\times 10^{-4}$。\n- 情况 3：$a = 2.0\\times 10^{-2}$，$k = 4.0\\times 10^{1}$，$H = 2.0\\times 10^{-2}$，$N = 40$，$N_x = 401$，$y_1 = 1.0\\times 10^{-5}$，$r = 1.2$，$U_\\infty = 1.0\\times 10^{1}$，$\\mu = 1.0\\times 10^{-3}$，$\\ell = 2.0\\times 10^{-4}$。\n\n对于每种情况，按此确切顺序计算并报告以下六个浮点数：\n- 超限插值对齐拉伸的 $E_{n,\\mathrm{RMS}}$。\n- 法向投影拉伸的 $E_{n,\\mathrm{RMS}}$。\n- 超限插值对齐拉伸的 $\\rho_{\\min}$。\n- 法向投影拉伸的 $\\rho_{\\min}$。\n- 超限插值对齐拉伸的 $\\varepsilon_{\\tau,\\mathrm{RMS}}$。\n- 法向投影拉伸的 $\\varepsilon_{\\tau,\\mathrm{RMS}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按情况（1 到 3）的顺序排列，每个情况贡献其按上述顺序列出的六个浮点数。例如，输出必须看起来像 $[\\dots]$，其中包含恰好 $6 \\times 3 = 18$ 个逗号分隔的浮点数。所有报告的指标都是无量纲实数，除了带有米单位的几何误差；尽管如此，在输出中报告数值时，应为不带单位的普通浮点数。",
            "solution": "本问题要求对两种在正弦壁面上生成结构化边界层网格的策略——垂直超限插值（TFI）拉伸和法向投影（NP）拉伸——进行比较分析。该比较将通过实现一个算法来完成，该算法用于计算三个特定的量化指标：几何法向距离误差、基于雅可比行列式的单元质量指标，以及模型壁面剪切应力估算的误差指标。\n\n求解过程首先建立共用的几何和离散化参数。然后，为两种网格生成策略中的每一种计算节点坐标。最后，为两种网格计算指定的指标，并报告一组已定义测试用例的结果。\n\n**1. 通用框架：壁面几何和层分布**\n\n物理域定义在一个由函数 $z_w(x) = a \\sin(k x)$ 给出的二维波浪形壁面上。分析仅限于单个波长 $x \\in [0, L]$，其中 $L = 2\\pi/k$。离散的流向坐标是均匀分布的：\n$$\nx_i = i \\cdot \\Delta x, \\quad \\text{for } i \\in \\{0, 1, \\dots, N_x-1\\}\n$$\n其中 $\\Delta x = L/(N_x-1)$。对于壁面上的每个点 $\\boldsymbol{r}_w(x_i) = (x_i, z_w(x_i))$，我们需要其外向单位法向量 $\\hat{\\boldsymbol{n}}(x_i)$。未归一化的法向量是 $\\boldsymbol{n} = (-z_w'(x), 1) = (-a k \\cos(k x), 1)$，其模为 $\\|\\boldsymbol{n}\\| = \\sqrt{1 + (a k \\cos(k x))^2}$。因此，单位法向量为：\n$$\n\\hat{\\boldsymbol{n}}(x) = \\frac{1}{\\sqrt{1 + (a k \\cos(k x))^2}} \\begin{pmatrix} -a k \\cos(k x) \\\\ 1 \\end{pmatrix}\n$$\n\n边界层网格由从壁面拉伸至总高度 $H$ 的 $N$ 个层组成。从壁面到第 $j$ 层的期望法向距离 $n_j$ 由一个等比数列定义。第 $j$ 层的未缩放厚度为 $\\Delta n_j^{\\text{raw}} = y_1 r^{j-1}$。累积未缩放距离是一个等比级数的和：\n$$\nS_j = \\sum_{m=1}^{j} \\Delta n_m^{\\text{raw}} = y_1 \\frac{r^j - 1}{r-1} \\quad (\\text{for } r \\neq 1)\n$$\n为确保总高度恰好为 $H$，这些距离通过一个因子 $c = H/S_N$ 进行缩放。最终的目标法向距离为 $n_j = c S_j$，其中 $j \\in \\{0, \\dots, N\\}$ 且 $n_0 = 0$。这得出了显式公式：\n$$\nn_j = H \\frac{r^j - 1}{r^N - 1}\n$$\n第 $j$ 层的厚度为 $\\Delta n_j = n_j - n_{j-1}$。\n\n**2. 网格生成策略**\n\n给定壁面点 $\\boldsymbol{r}_w(x_i)$ 和层距离分布 $\\{n_j\\}$，两种网格的构建如下：\n\n- **垂直 TFI 对齐拉伸（TFI）：** 此方法沿固定的垂直方向 $\\hat{\\boldsymbol{e}}_z = (0,1)$ 拉伸节点。在流向位置 $x_i$ 和层 $j$ 处的节点位置为：\n$$\n\\boldsymbol{r}^{\\mathrm{TFI}}(x_i, j) = \\boldsymbol{r}_w(x_i) + n_j \\hat{\\boldsymbol{e}}_z = (x_i, a \\sin(k x_i) + n_j)\n$$\n这种方法很简单，但生成的网格与壁面不垂直，除非壁面是平的（$a=0$）。\n\n- **法向投影拉伸（NP）：** 此方法在每个流向位置沿局部壁面法向量 $\\hat{\\boldsymbol{n}}(x_i)$ 拉伸节点。节点位置为：\n$$\n\\boldsymbol{r}^{\\mathrm{NP}}(x_i, j) = \\boldsymbol{r}_w(x_i) + n_j \\hat{\\boldsymbol{n}}(x_i)\n$$\n这种方法旨在创建在壁面处完全正交的网格，从而精确地达到期望的法向距离。\n\n**3. 量化指标**\n\n对于每个生成的网格，计算三个指标以量化其质量。\n\n**3.1. 几何法向距离误差，$E_{n,\\mathrm{RMS}}$**\n该指标量化了网格节点对目标法向距离 $\\{n_j\\}$ 的遵守程度。对于一个节点 $\\boldsymbol{r}(x_i, j)$，其从壁面出发的实际法向距离是从相应壁面点出发的向量在壁面法线上的投影：\n$$\nd_{\\perp}(x_i, j) = (\\boldsymbol{r}(x_i, j) - \\boldsymbol{r}_w(x_i)) \\cdot \\hat{\\boldsymbol{n}}(x_i)\n$$\n逐点误差为 $e_n(x_i, j) = d_{\\perp}(x_i, j) - n_j$。该误差在所有离壁节点上的均方根（RMS）值提供了一个全局的几何精度度量：\n$$\nE_{n,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x N}\\sum_{i=0}^{N_x-1}\\sum_{j=1}^N e_n(x_i, j)^2}\n$$\n根据构造，NP 网格应产生 $E_{n,\\mathrm{RMS}} = 0$（在机器精度范围内），因为 $d_{\\perp} = (n_j \\hat{\\boldsymbol{n}}) \\cdot \\hat{\\boldsymbol{n}} = n_j$。对于波浪形壁面，TFI 网格将有非零误差，因为 $d_{\\perp} = (n_j \\hat{\\boldsymbol{e}}_z) \\cdot \\hat{\\boldsymbol{n}} = n_j (\\hat{\\boldsymbol{n}})_z$，而单位法向量的 $z$ 分量 $(\\hat{\\boldsymbol{n}})_z = 1/\\|\\boldsymbol{n}\\|$ 小于或等于 $1$。\n\n**3.2. 雅可比质量，$\\rho_{\\min}$**\n从计算空间到物理空间的映射的雅可比行列式衡量了局部单元的面积和方向。质量差的网格可能包含高度扭曲甚至翻转的单元（$J \\le 0$）。质量通过归一化的离散雅可比行列式进行评估。对于从节点 $(i, j-1)$ 开始的单元，边向量定义为 $\\boldsymbol{E}_\\xi = \\boldsymbol{r}(x_{i+1}, j-1) - \\boldsymbol{r}(x_i, j-1)$ 和 $\\boldsymbol{E}_\\eta = \\boldsymbol{r}(x_i, j) - \\boldsymbol{r}(x_i, j-1)$。二维标量叉积给出了由这些向量构成的平行四边形的面积：$J_{\\text{cell}} = |E_{\\xi,x} E_{\\eta,z} - E_{\\xi,z} E_{\\eta,x}|$。该面积通过理想正交单元的面积 $\\Delta x \\Delta n_j$ 进行归一化。质量指标是该比率在整个网格上的最小值：\n$$\n\\rho_{\\min} = \\min_{i,j} \\left( \\frac{J_{\\text{cell}}(i,j)}{\\Delta x \\Delta n_j} \\right)\n$$\n对于理想的正交网格，处处有 $\\rho_{i,j} = 1$。对于 TFI 网格，向量 $\\boldsymbol{E}_\\eta$ 是纯垂直的，为 $(0, \\Delta n_j)$，而 $\\boldsymbol{E}_\\xi = (\\Delta x, \\Delta z_w)$。这导致 $J_{\\text{cell}} = |\\Delta x \\cdot \\Delta n_j - \\Delta z_w \\cdot 0| = \\Delta x \\Delta n_j$，因此处处有 $\\rho_{i,j}=1$。对于 NP 网格，如果壁面是弯曲的，拉伸方向 $\\hat{\\boldsymbol{n}}(x_i)$ 和 $\\hat{\\boldsymbol{n}}(x_{i+1})$ 就不平行，导致离壁处单元扭曲，$\\rho_{i,j} \\neq 1$。\n\n**3.3. 壁面剪切应力估算误差，$\\varepsilon_{\\tau,\\mathrm{RMS}}$**\n该指标评估网格几何对物理量的有限差分近似的影响。模型速度剖面 $u_t(n) = U_\\infty(1 - e^{-n/\\ell})$ 下的真实壁面剪切应力为 $\\tau_w^{\\mathrm{true}} = \\mu \\frac{\\partial u_t}{\\partial n}\\big|_{n=0} = \\mu U_\\infty/\\ell$。一阶单边离散估计为：\n$$\n\\tau_w^{\\mathrm{est}}(x_i) = \\mu \\frac{u_t(n_1(x_i)) - u_t(0)}{d_1(x_i)}\n$$\n其中 $\\boldsymbol{v}_1 = \\boldsymbol{r}(x_i, 1) - \\boldsymbol{r}_w(x_i)$ 是指向第一个离壁节点的向量，$d_1(x_i) = \\|\\boldsymbol{v}_1\\|$ 是几何距离，$n_1(x_i) = \\boldsymbol{v}_1 \\cdot \\hat{\\boldsymbol{n}}(x_i)$ 是实际法向距离。项 $u_t(n_1(x_i))$ 使用实际法向距离来评估模型速度。均方根相对误差为：\n$$\n\\varepsilon_{\\tau,\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}\\left(\\frac{\\tau_w^{\\mathrm{est}}(x_i) - \\tau_w^{\\mathrm{true}}}{\\tau_w^{\\mathrm{true}}}\\right)^2}\n$$\n对于 TFI 网格，$d_1 = n_1$ 且 $n_1(x_i) = n_1 (\\hat{\\boldsymbol{n}}(x_i))_z$，该值随 $x$ 变化。对于 NP 网格，$d_1=n_1$ 且 $n_1(x_i)=n_1$，使得估计值不依赖于 $x$ 并且与平板情况相同。这突显了几何误差（$d_1 \\neq n_1$ 或变化的 $n_1(x_i)$）如何传播到数值格式的模板中。\n\n该实现对每种情况和方法，使用向量化的 `numpy` 操作来高效地计算这些量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(mesh_coords, params, wall_data, layer_data):\n    \"\"\"\n    Computes the three specified quality metrics for a given mesh.\n    \"\"\"\n    # Unpack parameters and pre-computed data\n    a, k, H, N, Nx = params['a'], params['k'], params['H'], params['N'], params['Nx']\n    U_inf, mu, l_scale = params['U_inf'], params['mu'], params['l']\n    \n    wall_nodes = wall_data['wall_nodes']\n    unit_normals = wall_data['unit_normals']\n    n_dist = layer_data['n_dist']\n    delta_n_layers = layer_data['delta_n']\n    L = 2 * np.pi / k\n\n    # Metric 1: Geometric normal-distance error (E_n_RMS)\n    # The sum is over i=1..Nx and j=1..N. In 0-based index: i=0..Nx-1, j=1..N\n    # We use all off-wall nodes: mesh_coords[:, 1:, :] which has shape (Nx, N, 2)\n    diff_vec = mesh_coords[:, 1:, :] - wall_nodes[:, np.newaxis, :]\n    unit_normals_bcast = unit_normals[:, np.newaxis, :]\n    d_perp = np.sum(diff_vec * unit_normals_bcast, axis=2)  # Dot product\n\n    n_dist_offwall = n_dist[1:]\n    e_n = d_perp - n_dist_offwall[np.newaxis, :]\n    e_n_rms = np.sqrt(np.mean(e_n**2))\n\n    # Metric 2: Jacobian quality (rho_min)\n    # The min is over i=1..Nx-1 and j=1..N. In 0-based: i=0..Nx-2, j=1..N\n    # These correspond to cells defined from nodes (i, j-1)\n    E_xi = mesh_coords[1:, :-1, :] - mesh_coords[:-1, :-1, :]\n    E_eta = mesh_coords[:-1, 1:, :] - mesh_coords[:-1, :-1, :]\n    \n    # 2D scalar cross product\n    j_cell = np.abs(E_xi[..., 0] * E_eta[..., 1] - E_xi[..., 1] * E_eta[..., 0])\n    \n    delta_x = L / (Nx-1)\n    ref_area = delta_x * delta_n_layers[np.newaxis, :] # delta_n_layers has length N\n    \n    # Avoid division by zero if ref_area is zero (e.g., H=0)\n    # Although not the case here, it's good practice.\n    rho = np.divide(j_cell, ref_area, out=np.ones_like(j_cell), where=ref_area!=0)\n    rho_min = np.min(rho)\n\n    # Metric 3: Wall shear stress estimation error (eps_tau_RMS)\n    # The sum is over i=1..Nx. In 0-based: i=0..Nx-1\n    tau_true = mu * U_inf / l_scale\n    \n    # Get vector to first off-wall node\n    v1 = mesh_coords[:, 1, :] - mesh_coords[:, 0, :]\n    d1 = np.linalg.norm(v1, axis=1)\n    \n    # Actual normal distance of first off-wall node\n    n1_actual = np.sum(v1 * unit_normals, axis=1) # Dot product\n\n    # Avoid division by zero. If d1 is zero, the estimate is ill-defined.\n    # In this problem, d1 = n_dist[1] > 0 always.\n    tau_est = mu * U_inf * (1 - np.exp(-n1_actual / l_scale)) / d1\n    \n    rel_error = (tau_est - tau_true) / tau_true\n    eps_tau_rms = np.sqrt(np.mean(rel_error**2))\n\n    return e_n_rms, rho_min, eps_tau_rms\n\ndef solve_case(params):\n    \"\"\"\n    Solves one test case, generating both meshes and computing all metrics.\n    \"\"\"\n    # Unpack parameters\n    a, k, H, N, Nx = params['a'], params['k'], params['H'], params['N'], params['Nx']\n    y1, r = params['y1'], params['r']\n\n    # Setup common grid and layer properties\n    L = 2.0 * np.pi / k\n    x_grid = np.linspace(0, L, Nx)\n\n    # Layer distribution\n    j_vals = np.arange(N + 1)\n    if r == 1.0:\n        n_dist = H * j_vals / N\n    else:\n        # This formula prevents potential overflow/underflow with large N\n        # by using log-exp properties, but direct computation is fine for N=40.\n        # It simplifies to: n_j = H * (r^j - 1) / (r^N - 1)\n        S_N = (np.power(r, N) - 1.0) / (r - 1.0)\n        c = H / (y1 * S_N) if (y1 * S_N) > 0 else 0\n        S_j = y1 * (np.power(r, j_vals) - 1.0) / (r-1.0)\n        n_dist = c * S_j\n\n    n_dist[0] = 0.0 # Ensure starts at zero\n    n_dist[-1] = H # Ensure ends at H\n    \n    delta_n_layers = n_dist[1:] - n_dist[:-1]\n    layer_data = {'n_dist': n_dist, 'delta_n': delta_n_layers}\n\n    # Wall properties\n    z_w = a * np.sin(k * x_grid)\n    wall_nodes = np.stack([x_grid, z_w], axis=-1)\n    \n    nx_unnormalized = -a * k * np.cos(k * x_grid)\n    nz_unnormalized = np.ones_like(x_grid)\n    norm_mag = np.sqrt(nx_unnormalized**2 + nz_unnormalized**2)\n    unit_normals = np.stack([nx_unnormalized / norm_mag, nz_unnormalized / norm_mag], axis=-1)\n    \n    wall_data = {'wall_nodes': wall_nodes, 'unit_normals': unit_normals}\n\n    # TFI Mesh Generation (Vertical Extrusion)\n    mesh_tfi = np.zeros((Nx, N + 1, 2))\n    mesh_tfi[:, :, 0] = x_grid[:, np.newaxis]\n    mesh_tfi[:, :, 1] = z_w[:, np.newaxis] + n_dist[np.newaxis, :]\n\n    # NP Mesh Generation (Normal Projection)\n    mesh_np = wall_nodes[:, np.newaxis, :] + n_dist[np.newaxis, :, np.newaxis] * unit_normals[:, np.newaxis, :]\n    \n    # Calculate metrics for both meshes\n    tfi_metrics = calculate_metrics(mesh_tfi, params, wall_data, layer_data)\n    np_metrics = calculate_metrics(mesh_np, params, wall_data, layer_data)\n    \n    return [tfi_metrics[0], np_metrics[0], tfi_metrics[1], np_metrics[1], tfi_metrics[2], np_metrics[2]]\n\ndef solve():\n    \"\"\"\n    Main entry point to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'a': 0.0, 'k': 2.0 * np.pi, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n        {\n            'a': 1.0e-2, 'k': 1.0e1, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n        {\n            'a': 2.0e-2, 'k': 4.0e1, 'H': 2.0e-2, 'N': 40, 'Nx': 401,\n            'y1': 1.0e-5, 'r': 1.2, 'U_inf': 1.0e1, 'mu': 1.0e-3, 'l': 2.0e-4\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的工程问题很少只涉及简单表面，而是充满了复杂的交界、拐角和交叉点。这个综合性练习将指导您开发一个稳健的算法，用于在此类几何复杂区域生成边界层网格。您将推导并实现一种有原则的策略，用于确定多曲面交界处的拉伸方向并计算网格层高，从而将多个核心概念融合成一个实用的、基于代码的解决方案。",
            "id": "3297048",
            "problem": "您必须推导、实现并测试一种适用于计算流体动力学 (CFD) 的、在连接处、角点和多曲面相交处稳健的边界层拉伸策略。其目标是构建一个棱柱形边界层网格拉伸方向和一个层厚度分布，该分布在高雷诺数和复杂几何连接处的情况下是科学合理的。您编写的程序必须为几个指定的测试用例计算拉伸方向和近壁面层高，以满足以壁面单位表示的第一层单元壁面距离目标，并且必须验证相交处的局部角度约束。\n\n从以下基础出发。\n\n1. 粘性流中的边界层有一个特征性的近壁面粘性长度尺度，定义为 $y^{+} = y \\, u_{\\tau} / \\nu$，其中 $y$ 是距壁面的物理距离（单位：米），$u_{\\tau}$ 是摩擦速度（单位：米/秒），$\\nu$ 是运动粘度（单位：平方米/秒）。摩擦速度为 $u_{\\tau} = \\sqrt{\\tau_{w} / \\rho}$，其中 $\\tau_{w}$ 是壁面剪切应力（单位：帕斯卡），$\\rho$ 是流体密度（单位：千克/立方米）。壁面剪切应力可以参数化为 $\\tau_{w} = \\tfrac{1}{2} \\rho U^{2} C_{f}$，其中 $U$ 是特征流速（单位：米/秒），$C_{f}$ 是壁面摩擦系数。壁面摩擦系数 $C_{f}$ 可以通过经过充分检验的光滑平板关联式来建模：对于层流，$C_{f,\\text{lam}} = 0.664 / \\sqrt{Re}$；对于湍流，$C_{f,\\text{turb}} = 0.0592 \\, Re^{-1/5}$，其中 $Re = U L / \\nu$ 是基于特征长度 $L$（单位：米）和运动粘度 $\\nu$ 的雷诺数。这些关联式在工程实践中广泛用于初步设计和网格尺寸划分。\n\n2. 对于多曲面连接处，考虑 $m$ 个光滑曲面沿一条曲线或一个点相交，其外向单位法向量为 $\\{\\mathbf{n}_{i}\\}_{i=1}^{m}$，正权重为 $\\{a_{i}\\}_{i=1}^{m}$，代表局部几何或物理加权（例如，局部表面积贡献或目标通量权重）。连接处的边界层拉伸方向 $\\mathbf{d}$ 必须与近壁面正交性以及跨越相交处的连续性保持一致。一种有原则的选择 $\\mathbf{d}$ 的方法是同时最小化与每个表面正交性的偏差的最小二乘度量。将问题描述为在 $\\lVert \\mathbf{d} \\rVert = 1$ 的约束下最小化 $\\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{d} - \\mathbf{n}_{i} \\rVert^{2}$，其中权重 $w_{i} = a_{i}^{\\gamma}$，$\\gamma > 0$ 是一个混合指数。假设加权和非零，此约束优化问题在由法向量张成的凸锥中产生一个唯一方向，并且在欧几里得几何中是适定的。\n\n3. 对于边界层厚度分布，层高 $\\{y_{k}\\}_{k=1}^{N}$ 采用等比数列，其中 $N$ 是整数层数，对于增长因子 $r \\ge 1$，$y_{k} = y_{1} r^{k-1}$。边界层总厚度为 $T = \\sum_{k=1}^{N} y_{k}$，第一层高度 $y_{1}$ 由目标壁面单位 $y^{+}_{\\text{target}}$ 通过 $y_{1} = y^{+}_{\\text{target}} \\, \\nu / u_{\\tau}$ 设定。必须确定 $r$ 的值，以使等比级数之和达到指定的总厚度 $T$（如果可行），即当 $r \\ne 1$ 时 $T = y_{1} \\, \\tfrac{1 - r^{N}}{1 - r}$，或当 $r = 1$ 时 $T = N y_{1}$。如果 $T < N y_{1}$，则目标第一层单元高度在非递减等比数列下是不可行的；应报告该测试用例不可行，并设置后备方案，令 $r = 1$ 且对所有 $k$ 有 $y_{k} = T/N$。\n\n4. 在连接处和角点，通过角度阈值约束拉伸方向，以保持近壁面正交性质量：计算所有 $i$ 的角度 $\\theta_{i} = \\arccos(\\mathbf{d} \\cdot \\mathbf{n}_{i})$（单位：弧度），并强制执行 $\\theta_{i} \\le \\theta_{\\max}$。报告每个测试用例是否满足此约束。\n\n您的任务是：\n\nA. 根据第 2 项中的最小二乘准则，在单位范数约束下，推导拉伸方向 $\\mathbf{d}$ 的表达式。\n\nB. 利用第 1 项中的分段壁面摩擦关联式，根据给定的 $U$、$\\rho$、$L$ 和 $\\nu$ 推导摩擦速度 $u_{\\tau}$，然后为目标 $y^{+}_{\\text{target}}$ 推导第一层高度 $y_{1}$。\n\nC. 推导一个计算增长因子 $r \\ge 1$ 的过程，使其在可行时能够达到指定的总厚度 $T$，并指定一个稳健的数值方法来求解 $r$。\n\nD. 实现一个程序，对于下面定义的每个测试用例，计算：\n- 拉伸方向分量 $(d_{x}, d_{y}, d_{z})$。\n- 一个布尔值，指示角度约束是否满足。\n- 第一层高度 $y_{1}$（单位：米）。\n- 增长因子 $r$（如果不可行，则为一个哨兵值）。\n- $\\sum_{k=1}^{N} y_{k}$ 与 $T$ 之间的绝对差值（单位：米）。\n- 一个布尔值，指示可行性 ($T \\ge N y_{1}$)。\n- 层高列表 $[y_{1}, y_{2}, \\dots, y_{N}]$（单位：米）。\n\n角度必须以弧度计算和报告。所有物理量必须采用国际单位制（SI）：米、秒、千克和帕斯卡。\n\n测试套件：\n使用以下测试用例。对于每个用例，请完全按照所列参数提供。\n\n用例 1（双曲面正交角点，空气）：\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0, 1, 0)$, $a_{1} = 1$, $a_{2} = 1$, $\\gamma = 1$, $\\theta_{\\max} = \\pi/3$。\n- $U = 30$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 1$, $y^{+}_{\\text{target}} = 1$, $N = 10$, $T = 0.02$。\n\n用例 2（双曲面锐角角点，夹角 $\\phi = \\pi/6$，空气）：\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (\\cos(\\pi/6), \\sin(\\pi/6), 0)$, $a_{1} = 1$, $a_{2} = 1$, $\\gamma = 1$, $\\theta_{\\max} = 0.4$。\n- $U = 30$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 1$, $y^{+}_{\\text{target}} = 5$, $N = 20$, $T = 0.03$。\n\n用例 3（三曲面相交，水）：\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0, 1, 0)$, $\\mathbf{n}_{3} = (0, 0, 1)$, $a_{1} = 1$, $a_{2} = 1$, $a_{3} = 1$, $\\gamma = 1$, $\\theta_{\\max} = 1.0$。\n- $U = 2$, $\\mu = 10^{-3}$, $\\rho = 1000$, $L = 0.5$, $y^{+}_{\\text{target}} = 1$, $N = 8$, $T = 0.005$。\n\n用例 4（带加权混合的近平行曲面，空气，不可行的 $T$）：\n- $\\mathbf{n}_{1} = (1, 0, 0)$, $\\mathbf{n}_{2} = (0.999, 0.0447, 0)$, $a_{1} = 1$, $a_{2} = 0.2$, $\\gamma = 2$, $\\theta_{\\max} = 0.05$。\n- $U = 10$, $\\mu = 1.8 \\times 10^{-5}$, $\\rho = 1.225$, $L = 0.2$, $y^{+}_{\\text{target}} = 30$, $N = 5$, $T = 0.001$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。外层列表的每个元素对应一个测试用例，并且其本身必须是一个形如：\n$[d_{x}, d_{y}, d_{z}, \\text{pass\\_angle}, y_{1}, r, \\text{thickness\\_error}, \\text{pass\\_thickness}, [y_{1}, y_{2}, \\dots, y_{N}]]$ 的列表。\n布尔值必须以其语言原生的布尔形式表示。单位必须与上述规范一致。角度以弧度为单位，距离以米为单位。",
            "solution": "我们从基本原理出发，推导拉伸方向和边界层厚度分布。\n\nA. 拉伸方向推导。设 $\\{\\mathbf{n}_{i}\\}_{i=1}^{m}$ 为单位法向量，$\\{w_{i}\\}_{i=1}^{m}$ 为正权重，其中 $w_{i} = a_{i}^{\\gamma}$ 且 $\\gamma > 0$。我们寻求 $\\mathbf{d} \\in \\mathbb{R}^{3}$，满足 $\\lVert \\mathbf{d} \\rVert = 1$ 且最小化目标函数\n$$\nJ(\\mathbf{d}) = \\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{d} - \\mathbf{n}_{i} \\rVert^{2}.\n$$\n展开平方范数，\n$$\nJ(\\mathbf{d}) = \\sum_{i=1}^{m} w_{i} \\left( \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\mathbf{n}_{i} + \\lVert \\mathbf{n}_{i} \\rVert^{2} \\right)\n= \\left( \\sum_{i=1}^{m} w_{i} \\right) \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + \\sum_{i=1}^{m} w_{i} \\lVert \\mathbf{n}_{i} \\rVert^{2}.\n$$\n由于每个 $\\mathbf{n}_{i}$ 都是单位向量，$\\lVert \\mathbf{n}_{i} \\rVert^{2} = 1$，最后一项相对于 $\\mathbf{d}$ 是常数。带有 $\\lVert \\mathbf{d} \\rVert = 1$ 的约束最小化问题可以通过拉格朗日乘子 $\\lambda$ 来处理：\n$$\n\\mathcal{L}(\\mathbf{d}, \\lambda) = \\left( \\sum_{i=1}^{m} w_{i} \\right) \\lVert \\mathbf{d} \\rVert^{2} - 2 \\mathbf{d} \\cdot \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + \\lambda \\left( \\lVert \\mathbf{d} \\rVert^{2} - 1 \\right).\n$$\n对 $\\mathbf{d}$ 求梯度并设为零，\n$$\n\\nabla_{\\mathbf{d}} \\mathcal{L} = 2 \\left( \\sum_{i=1}^{m} w_{i} \\right) \\mathbf{d} - 2 \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} + 2 \\lambda \\mathbf{d} = \\mathbf{0}.\n$$\n因此，\n$$\n\\left( \\sum_{i=1}^{m} w_{i} + \\lambda \\right) \\mathbf{d} = \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}.\n$$\n对于某个标量 $\\alpha = 1 / \\left( \\sum_{i=1}^{m} w_{i} + \\lambda \\right)$，我们有\n$$\n\\mathbf{d} = \\alpha \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}.\n$$\n施加 $\\lVert \\mathbf{d} \\rVert = 1$ 的约束，可确定 $\\alpha$ 为加权和范数的倒数：\n$$\n\\mathbf{d} = \\frac{\\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i}}{\\left\\lVert \\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} \\right\\rVert}.\n$$\n该表达式是适定的，前提是 $\\sum_{i=1}^{m} w_{i} \\mathbf{n}_{i} \\ne \\mathbf{0}$，对于没有精确抵消的外向法向量的正常连接处，这通常是成立的。在加权和为零的退化情况下，后备方案选择权重最大的法向量。\n\n为评估近壁面正交性质量，计算角度\n$$\n\\theta_{i} = \\arccos\\!\\left( \\mathbf{d} \\cdot \\mathbf{n}_{i} \\right),\n$$\n并对所有 $i$ 强制执行 $\\theta_{i} \\le \\theta_{\\max}$ 的界限。\n\nB. 摩擦速度和第一层单元高度推导。雷诺数为\n$$\nRe = \\frac{U L}{\\nu}, \\quad \\nu = \\frac{\\mu}{\\rho}.\n$$\n使用平板关联式，\n$$\nC_{f} = \n\\begin{cases}\n0.664 \\, Re^{-1/2},  & \\text{若 } Re \\le 5 \\times 10^{5}, \\\\\n0.0592 \\, Re^{-1/5},  & \\text{若 } Re > 5 \\times 10^{5}.\n\\end{cases}\n$$\n壁面剪切应力为 $\\tau_{w} = \\tfrac{1}{2} \\rho U^{2} C_{f}$，摩擦速度为\n$$\nu_{\\tau} = \\sqrt{\\frac{\\tau_{w}}{\\rho}} = U \\sqrt{\\frac{C_{f}}{2}}.\n$$\n对于目标壁面单位 $y^{+}_{\\text{target}}$，第一层单元高度为\n$$\ny_{1} = y^{+}_{\\text{target}} \\, \\frac{\\nu}{u_{\\tau}}.\n$$\n\nC. 增长因子计算。当 $r \\ne 1$ 时，等比数列的总厚度为\n$$\nT = y_{1} \\frac{1 - r^{N}}{1 - r}, \\quad r \\ge 1.\n$$\n如果 $r = 1$，则 $T = N y_{1}$。$r \\ge 1$ 的可行解要求 $T \\ge N y_{1}$，因为对于 $r \\ge 1$，$T(r)$ 是 $r$ 的单调递增函数。当可行时，通过单调求根方法求解 $r$。定义\n$$\nf(r) = y_{1} \\frac{1 - r^{N}}{1 - r} - T,\n$$\n定义域为 $r \\in [1, r_{\\max}]$，其中 $r_{\\max}$ 通过指数扩展区间的方式选取，直到 $f(r_{\\max}) \\ge 0$（即，总和达到或超过 $T$）。使用二分法寻找唯一根，因为对于 $N \\ge 1$ 和 $y_{1} > 0$，$f(r)$ 在 $[1, \\infty)$ 上是连续且严格递增的。如果 $T < N y_{1}$，则宣布不可行，并设置后备方案，令 $r = 1$ 且对所有 $k$ 有 $y_{k} = T / N$。\n\nD. 实现细节。对于每个测试用例，计算：\n- 权重 $w_{i} = a_{i}^{\\gamma}$，然后是加权和 $\\mathbf{s} = \\sum_{i} w_{i} \\mathbf{n}_{i}$。如果 $\\lVert \\mathbf{s} \\rVert > 0$，则设 $\\mathbf{d} = \\mathbf{s} / \\lVert \\mathbf{s} \\rVert$；否则，将 $\\mathbf{d}$ 设为对应 $\\max w_{i}$ 的 $\\mathbf{n}_{i}$。\n- 角度 $\\theta_{i} = \\arccos(\\mathbf{d} \\cdot \\mathbf{n}_{i})$ 和 $\\text{pass\\_angle}$（如果 $\\max_{i} \\theta_{i} \\le \\theta_{\\max}$）。\n- 运动粘度 $\\nu = \\mu / \\rho$，雷诺数 $Re = U L / \\nu$，壁面摩擦系数 $C_{f}$（通过分段关联式），摩擦速度 $u_{\\tau} = U \\sqrt{C_{f} / 2}$，以及 $y_{1} = y^{+}_{\\text{target}} \\nu / u_{\\tau}$。\n- 可行性检查 $\\text{pass\\_thickness} \\leftrightarrow T \\ge N y_{1}$。如果可行，对 $f(r)$ 使用二分法来框定并求解 $r \\ge 1$。如果不可行，则设 $r = 1$ 且 $y_{k} = T/N$。\n- 高度列表 $[y_{1}, y_{2}, \\dots, y_{N}]$，在可行情况下 $y_{k} = y_{1} r^{k-1}$，否则 $y_{k} = T/N$。\n- 绝对厚度误差 $\\lvert \\sum_{k=1}^{N} y_{k} - T \\rvert$。\n\n所有角度以弧度为单位；所有距离以米为单位。该设计确保了科学真实性：拉伸方向源自曲面法向量的凸组合，在单位范数约束下最小化二次目标函数；层尺寸划分基于壁面单位和已建立的平板摩擦关联式，并对增长因子在可行性约束下进行了稳健的数值处理。\n\n最终程序将每个用例的结果汇总为单行，即一个用方括号括起来的逗号分隔列表，其中每个元素是一个包含拉伸方向、布尔标志、第一层高度、增长因子、厚度误差、可行性标志和层高列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to a standard environment.\nimport numpy as np\n\ndef weighted_direction(normals, areas, gamma):\n    \"\"\"\n    Compute extrusion direction by normalized weighted sum of unit normals.\n    If the weighted sum is (near) zero, fall back to the normal with largest weight.\n    \"\"\"\n    weights = np.power(np.asarray(areas, dtype=float), float(gamma))\n    normals = np.asarray(normals, dtype=float)\n    # Normalize normals defensively in case of slight deviations\n    norms = np.linalg.norm(normals, axis=1)\n    norms[norms == 0.0] = 1.0\n    unit_normals = normals / norms[:, None]\n    s = (weights[:, None] * unit_normals).sum(axis=0)\n    s_norm = np.linalg.norm(s)\n    if s_norm  1e-14:\n        # Fallback: pick the normal with the largest weight\n        idx = int(np.argmax(weights))\n        d = unit_normals[idx]\n    else:\n        d = s / s_norm\n    return d\n\ndef angles_to_normals(direction, normals):\n    \"\"\"Compute angles between direction and each normal, in radians.\"\"\"\n    direction = np.asarray(direction, dtype=float)\n    direction_norm = np.linalg.norm(direction)\n    if direction_norm == 0.0:\n        raise ValueError(\"Direction vector has zero norm.\")\n    d = direction / direction_norm\n    normals = np.asarray(normals, dtype=float)\n    # normalize normals just in case\n    norms = np.linalg.norm(normals, axis=1)\n    norms[norms == 0.0] = 1.0\n    unit_normals = normals / norms[:, None]\n    dots = np.clip(unit_normals @ d, -1.0, 1.0)\n    thetas = np.arccos(dots)\n    return thetas\n\ndef friction_velocity(U, mu, rho, L):\n    \"\"\"Compute friction velocity using piecewise Cf correlations.\"\"\"\n    nu = mu / rho\n    if U == 0.0: # Handle zero velocity case to avoid division by zero\n        return 0.0, nu, 0.0, 0.0\n    Re = U * L / nu\n    if Re = 5.0e5:\n        Cf = 0.664 / np.sqrt(Re) if Re > 0 else 0.0\n    else:\n        Cf = 0.0592 * (Re ** (-0.2))\n    u_tau = U * np.sqrt(0.5 * Cf)\n    return u_tau, nu, Re, Cf\n\ndef first_cell_height(yplus_target, nu, u_tau):\n    \"\"\"Compute first layer height y1 from target y+.\"\"\"\n    if u_tau == 0.0: return float('inf')\n    return yplus_target * nu / u_tau\n\ndef geometric_sum(y1, r, N):\n    \"\"\"Sum of geometric progression y1, y1*r, ..., y1*r^(N-1).\"\"\"\n    if abs(r - 1.0)  1e-14:\n        return N * y1\n    return y1 * (1.0 - r**N) / (1.0 - r)\n\ndef solve_growth_factor(y1, T, N, tol=1e-12, max_iter=200):\n    \"\"\"\n    Solve for growth factor r >= 1 such that geometric_sum(y1, r, N) == T.\n    Returns (r, heights, thickness_error, pass_thickness).\n    If infeasible (T  N*y1), returns r=1, equal heights T/N, error=0, pass_thickness=False.\n    \"\"\"\n    min_sum = N * y1\n    if T  min_sum - 1e-14:\n        # Infeasible: fallback equal heights\n        heights = [T / N] * N\n        thickness_error = abs(sum(heights) - T)\n        return 1.0, heights, thickness_error, False\n    # Feasible: find r >= 1\n    # If T == N*y1 within tolerance, r == 1\n    if abs(T - min_sum) = 1e-14:\n        heights = [y1] * N\n        thickness_error = abs(sum(heights) - T)\n        return 1.0, heights, thickness_error, True\n    # Bracket r\n    r_lo = 1.0\n    r_hi = 2.0\n    # Increase r_hi until sum >= T\n    for _ in range(1000):\n        S = geometric_sum(y1, r_hi, N)\n        if S >= T:\n            break\n        r_hi *= 2.0\n        if r_hi > 1e12:\n            # Avoid runaway; treat as failure, though should not happen\n            break\n    # Bisection\n    r = r_lo\n    for _ in range(max_iter):\n        r_mid = 0.5 * (r_lo + r_hi)\n        S_mid = geometric_sum(y1, r_mid, N)\n        if abs(S_mid - T) = tol:\n            r = r_mid\n            break\n        if S_mid  T:\n            r_lo = r_mid\n        else:\n            r_hi = r_mid\n    else:\n        r = r_mid\n    # Build heights\n    heights = [y1 * (r ** k) for k in range(N)]\n    thickness_error = abs(sum(heights) - T)\n    return r, heights, thickness_error, True\n\ndef case_result(normals, areas, gamma, theta_max,\n                U, mu, rho, L, yplus_target, N, T):\n    # Direction\n    d = weighted_direction(normals, areas, gamma)\n    thetas = angles_to_normals(d, normals)\n    pass_angle = bool(np.max(thetas) = theta_max + 1e-14)\n    # Friction velocity and y1\n    u_tau, nu, Re, Cf = friction_velocity(U, mu, rho, L)\n    y1 = first_cell_height(yplus_target, nu, u_tau)\n    # Growth factor\n    r, heights, thickness_error, pass_thickness = solve_growth_factor(y1, T, N)\n    # Compose result list\n    result = [float(d[0]), float(d[1]), float(d[2]),\n              bool(pass_angle),\n              float(y1),\n              float(r),\n              float(thickness_error),\n              bool(pass_thickness),\n              [float(h) for h in heights]]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0)],\n            \"areas\": [1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": np.pi / 3.0,\n            \"U\": 30.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 1.0,\n            \"yplus_target\": 1.0,\n            \"N\": 10,\n            \"T\": 0.02\n        },\n        # Case 2\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (np.cos(np.pi/6.0), np.sin(np.pi/6.0), 0.0)],\n            \"areas\": [1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": 0.4,\n            \"U\": 30.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 1.0,\n            \"yplus_target\": 5.0,\n            \"N\": 20,\n            \"T\": 0.03\n        },\n        # Case 3\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)],\n            \"areas\": [1.0, 1.0, 1.0],\n            \"gamma\": 1.0,\n            \"theta_max\": 1.0,\n            \"U\": 2.0,\n            \"mu\": 1.0e-3,\n            \"rho\": 1000.0,\n            \"L\": 0.5,\n            \"yplus_target\": 1.0,\n            \"N\": 8,\n            \"T\": 0.005\n        },\n        # Case 4\n        {\n            \"normals\": [(1.0, 0.0, 0.0), (0.999, 0.0447, 0.0)],\n            \"areas\": [1.0, 0.2],\n            \"gamma\": 2.0,\n            \"theta_max\": 0.05,\n            \"U\": 10.0,\n            \"mu\": 1.8e-5,\n            \"rho\": 1.225,\n            \"L\": 0.2,\n            \"yplus_target\": 30.0,\n            \"N\": 5,\n            \"T\": 0.001\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case_result(\n            normals=case[\"normals\"],\n            areas=case[\"areas\"],\n            gamma=case[\"gamma\"],\n            theta_max=case[\"theta_max\"],\n            U=case[\"U\"],\n            mu=case[\"mu\"],\n            rho=case[\"rho\"],\n            L=case[\"L\"],\n            yplus_target=case[\"yplus_target\"],\n            N=case[\"N\"],\n            T=case[\"T\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Print single-line, comma-separated list enclosed in square brackets.\n    def format_element(elem):\n        if isinstance(elem, list):\n            return \"[\" + \",\".join(format_element(e) for e in elem) + \"]\"\n        elif isinstance(elem, bool):\n            return \"True\" if elem else \"False\"\n        else:\n            return f\"{elem:.8e}\" if isinstance(elem, float) else str(elem)\n\n    # Custom formatter to handle nested lists and booleans correctly\n    # while representing floats in scientific notation for consistency.\n    def custom_format(data_list):\n        formatted_items = []\n        for item in data_list:\n            if isinstance(item, list):\n                formatted_items.append(custom_format(item))\n            elif isinstance(item, bool):\n                formatted_items.append(\"True\" if item else \"False\")\n            elif isinstance(item, float):\n                # Use a specific format for floats\n                formatted_items.append(f'{item:.15g}')\n            else:\n                formatted_items.append(str(item))\n        return \"[\" + \",\".join(formatted_items) + \"]\"\n\n    # Simplified formatter for the final output string\n    final_output_list = []\n    for res in results:\n        res_str_list = []\n        # dx, dy, dz\n        res_str_list.extend([f'{res[0]:.15g}', f'{res[1]:.15g}', f'{res[2]:.15g}'])\n        # pass_angle\n        res_str_list.append(\"True\" if res[3] else \"False\")\n        # y1, r, thickness_error\n        res_str_list.extend([f'{res[4]:.15g}', f'{res[5]:.15g}', f'{res[6]:.15g}'])\n        # pass_thickness\n        res_str_list.append(\"True\" if res[7] else \"False\")\n        # heights list\n        heights_str = \"[\" + \",\".join(f'{h:.15g}' for h in res[8]) + \"]\"\n        res_str_list.append(heights_str)\n        final_output_list.append(\"[\" + \",\".join(res_str_list) + \"]\")\n\n    print(\"[\" + \",\".join(final_output_list) + \"]\")\n\n\nsolve()\n```"
        }
    ]
}