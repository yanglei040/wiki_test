{
    "hands_on_practices": [
        {
            "introduction": "在任何基于梯度的优化工作流程中，首要且最关键的步骤是验证所计算梯度的正确性。本练习（通常称为泰勒测试）为此提供了一种基础的数值验证方法 。通过采用一个非光滑的目标函数，本练习还使我们能够深入探究在实际问题中常见的非光滑特性（如激波传感器或限幅器）如何影响梯度计算的收敛阶，从而增强我们对离散伴随方法在复杂应用中行为的理解。",
            "id": "3289227",
            "problem": "你的任务是为一个模拟计算流体动力学中激波传感器行为的不可微后处理泛函，实现并验证一个一阶伴随线性化检验。目标是测试反向模式离散伴随（自动微分）梯度与状态的有限差分方向扰动的一致性，并量化该检验在不连续等不可微扭折点附近是如何失效的。\n\n从以下基本原理开始：\n- 标量泛函 $J(\\mathbf{w})$ 在状态向量 $\\mathbf{w} \\in \\mathbb{R}^N$ 沿方向 $\\delta \\mathbf{w} \\in \\mathbb{R}^N$ 的方向导数通过一阶泰勒展开定义，\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) = J(\\mathbf{w}) + \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w} + r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}),\n$$\n其中当 $J$ 在 $\\mathbf{w}$ 处沿方向 $\\delta \\mathbf{w}$ 可微时，余项 $r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w})$ 满足 $r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}) = o(\\epsilon)$ as $\\epsilon \\to 0$；当 $J$ 在 $\\mathbf{w}$ 的邻域内沿方向 $\\delta \\mathbf{w}$ 具有 Lipschitz 连续梯度时，满足 $r(\\epsilon;\\mathbf{w},\\delta \\mathbf{w}) = \\mathcal{O}(\\epsilon^2)$。\n- 链式法则为复合函数中导数的伴随（反向模式自动微分）累积提供了基础。\n\n你将考虑以下离散泛函，它表示激波传感器项和平滑项的凸组合：\n$$\nJ(\\mathbf{w}) \\;=\\; \\sum_{i=0}^{N-2} \\phi\\!\\left(d_i\\right), \\quad d_i \\;=\\; w_{i+1}-w_i, \\quad \\phi(x) \\;=\\; |x| \\;+\\; \\tfrac{1}{2}\\kappa x^2,\n$$\n其中给定常数 $\\kappa > 0$。绝对值模拟了不连续传感器典型的不可微部分；二次项对泛函进行正则化，并确保在绝对值局部线性的地方有平滑的曲率贡献。使用以下绝对值导数规则：对于 $x \\neq 0$，$\\frac{d}{dx}|x|=\\operatorname{sign}(x)$，在 $x=0$ 处使用特定的次梯度选择 $\\frac{d}{dx}|x|\\big|_{x=0}=0$。\n\n你的程序必须：\n1. 基于应用于将 $\\mathbf{w} \\mapsto \\{d_i\\} \\mapsto \\{\\phi(d_i)\\} \\mapsto J$ 映射的计算图的链式法则，实现梯度 $\\nabla J(\\mathbf{w})$ 的反向模式伴随（自动微分）求值。梯度累积必须明确地从第一性原理构建，不使用任何外部自动微分工具。\n2. 使用指定的种子生成随机扰动 $\\delta \\mathbf{w}$，并对递减的 $\\epsilon$ 值序列验证伴随线性化\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) \\;\\approx\\; \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\n$$\n对于每种情况，通过对所有测试 $\\epsilon$ 值的 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 进行最小二乘拟合，量化从余项大小 $E(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|$ 获得的经验收敛阶 $p$。$p \\approx 2$ 的值表示局部二阶可微行为和成功的伴随一致性检验，而 $p \\approx 1$ 则表示由于靠近扭折点或不连续点的不可微性导致的失效。\n3. 跟踪经验阶 $p$ 在光滑和非光滑状态场 $\\mathbf{w}$ 之间如何变化。\n\n不涉及角度。不需要物理单位。\n\n实现下面的测试套件。使用 $N=200$ 个网格点和 $\\kappa = 0.1$。使用以下三个状态场 $\\mathbf{w}$ 和扰动种子，并对所有情况使用相同的扰动大小集合：\n- 案例 1 (光滑场，“理想路径”)：$w_i = \\sin(2\\pi x_i) + 0.2\\cos(3\\pi x_i) + 0.3$，其中 $x_i = i/(N-1)$，此处 $i=0,\\dots,N-1$。随机方向种子为 $13$。\n- 案例 2 (近扭折点场，可微性边界)：对所有 $i$，$w_i = 0$。随机方向种子为 $17$。\n- 案例 3 (间断场，类激波阶跃)：对于格点 $x_i = i/(N-1)$，当 $x_i < 0.5$ 时 $w_i = 1$，否则 $w_i = -1$。随机方向种子为 $19$。\n\n对于每种情况，生成一个具有独立标准正态分布项的随机扰动 $\\delta \\mathbf{w}$，然后将其归一化为单位欧几里得范数。使用扰动大小\n$$\n\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}.\n$$\n\n对于每种情况，使用提供的 $\\epsilon$ 值通过线性最小二乘法计算 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 的最佳拟合线的斜率，作为经验收斂阶 $p$。报告三个 $p$ 值（每个案例一个），为四舍五入到三位小数的浮点数。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[p1,p2,p3]”）。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **泛函：** $J(\\mathbf{w}) = \\sum_{i=0}^{N-2} \\phi(d_i)$，其中 $d_i = w_{i+1}-w_i$。\n- **分量函数：** $\\phi(x) = |x| + \\frac{1}{2}\\kappa x^2$，其中常数 $\\kappa > 0$。\n- **次梯度规则：** 在 $x=0$ 处，绝对值的导数取为 $\\frac{d}{dx}|x|\\big|_{x=0}=0$。对于 $x \\neq 0$，使用标准导数 $\\frac{d}{dx}|x|=\\operatorname{sign}(x)$。\n- **伴随线性化与余项：** 检验基于 $J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) \\approx \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$。余项为 $E(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|$。\n- **收敛阶：** 经验收敛阶 $p$ 通过对 $\\log_{10}E(\\epsilon)$ 与 $\\log_{10}\\epsilon$ 进行最小二乘拟合得到。\n- **常数：** 网格点数 $N=200$，正则化参数 $\\kappa = 0.1$。\n- **扰动大小：** $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$。\n- **测试案例：**\n  1. **光滑场：** $w_i = \\sin(2\\pi x_i) + 0.2\\cos(3\\pi x_i) + 0.3$，其中 $x_i = i/(N-1)$。$\\delta\\mathbf{w}$ 的随机种子为 $13$。\n  2. **近扭折点场：** 对所有 $i$，$w_i = 0$。$\\delta\\mathbf{w}$ 的随机种子为 $17$。\n  3. **间断场：** 当 $x_i < 0.5$ 时 $w_i = 1$，否则 $w_i = -1$。$\\delta\\mathbf{w}$ 的随机种子为 $19$。\n- **扰动向量：** $\\delta\\mathbf{w}$ 由独立标准正态分布项生成，并归一化为单位欧几里得范数。\n- **输出格式：** 三个 $p$ 值，每个案例一个，四舍五入到三位小数，格式为 `[p1,p2,p3]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n基于验证标准对问题进行评估：\n- **科学依据充分：** 该问题是一种标准的数值验证技术，称为泰勒检验或伴随一致性检验，这在伴随优化和灵敏度分析代码的开发中是基础性的，尤其是在计算流体动力学（CFD）领域。该泛函是非光滑惩罰项的典型示例。所有数学概念（泰勒级数、链式法则、次梯度、最小二乘拟合）都是成熟的。\n- **良定的：** 问题是良定的。所有参数、状态向量、函数和数值过程都得到了精确定义。对 $|x|$ 在 $x=0$ 处的次梯度的规定消除了歧义，确保了对于任何状态 $\\mathbf{w}$ 都能计算出唯一的梯度向量。所描述的过程会导出一组唯一的可计算的三个值。\n- **客观的：** 问题以精确、客观的数学语言陈述。没有主观或基于意见的元素。\n\n该问题没有表现出任何指定的无效性缺陷。它科学上合理、完全指定、计算上可行，并与所述的伴随方法主题直接相关。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供一个完整的解决方案。\n\n### 解决方案的原理设计\n\n#### 1. 泛函及其伴随梯度\n标量泛函 $J$ 是状态向量 $\\mathbf{w} \\in \\mathbb{R}^N$ 的函数，定义为：\n$$\nJ(\\mathbf{w}) = \\sum_{i=0}^{N-2} \\phi(d_i), \\quad \\text{其中 } d_i = w_{i+1} - w_i \\text{ 且 } \\phi(x) = |x| + \\frac{1}{2}\\kappa x^2.\n$$\n为计算梯度 $\\nabla J(\\mathbf{w})$（其分量为 $\\frac{\\partial J}{\\partial w_j}$），我们应用链式法则：\n$$\n\\frac{\\partial J}{\\partial w_j} = \\sum_{i=0}^{N-2} \\frac{\\partial \\phi(d_i)}{\\partial w_j} = \\sum_{i=0}^{N-2} \\frac{d\\phi}{dx}(d_i) \\frac{\\partial d_i}{\\partial w_j}.\n$$\n$\\phi(x)$ 对其参数 $x$ 的导数为：\n$$\n\\frac{d\\phi}{dx}(x) = \\frac{d|x|}{dx} + \\kappa x.\n$$\n根据问题指定的绝对值函数的次梯度选择，即 $\\frac{d|x|}{dx}\\big|_{x=0}=0$，我们有：\n$$\n\\frac{d\\phi}{dx}(x) = \\operatorname{sign}(x) + \\kappa x,\n$$\n这里约定 $\\operatorname{sign}(0) = 0$。\n\n项 $\\frac{\\partial d_i}{\\partial w_j}$ 仅在 $j$ 为 $i$ 或 $i+1$ 时非零。具体来说，$\\frac{\\partial d_i}{\\partial w_{i+1}} = 1$ 和 $\\frac{\\partial d_i}{\\partial w_i} = -1$。这种稀疏的依赖结构使我们能够构建梯度。对于任何分量 $w_j$，它只影响 $d_j$（如果 $j  N-1$）和 $d_{j-1}$（如果 $j > 0$）。\n通过累积贡献，梯度分量为：\n- 对于 $j=0$：$\\frac{\\partial J}{\\partial w_0} = \\frac{d\\phi}{dx}(d_0) \\frac{\\partial d_0}{\\partial w_0} = -\\frac{d\\phi}{dx}(d_0)$。\n- 对于 $0  j  N-1$：$\\frac{\\partial J}{\\partial w_j} = \\frac{d\\phi}{dx}(d_{j-1})\\frac{\\partial d_{j-1}}{\\partial w_j} + \\frac{d\\phi}{dx}(d_j)\\frac{\\partial d_j}{\\partial w_j} = \\frac{d\\phi}{dx}(d_{j-1}) - \\frac{d\\phi}{dx}(d_j)$。\n- 对于 $j=N-1$：$\\frac{\\partial J}{\\partial w_{N-1}} = \\frac{d\\phi}{dx}(d_{N-2})\\frac{\\partial d_{N-2}}{\\partial w_{N-1}} = \\frac{d\\phi}{dx}(d_{N-2})$。\n\n这构成了 $\\nabla J(\\mathbf{w})$ 的反向模式自动微分（伴随）计算。\n\n#### 2. 伴随线性化检验\n$J(\\mathbf{w})$ 在点 $\\mathbf{w}$ 沿任意方向 $\\delta\\mathbf{w}$ 的一阶泰勒展开为：\n$$\nJ(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) = J(\\mathbf{w}) + \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w} + \\mathcal{O}(\\epsilon^2).\n$$\n如果 $J$ 在 $\\mathbf{w}$ 的邻域内是二次连续可微的，则此式成立。项 $\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$ 是方向导数，可以使用伴随推导的梯度 $\\nabla J(\\mathbf{w})$ 高效计算。伴随线性化检验验证了泛函的变化量 $J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w})$ 是否被线性项 $\\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}$ 精确逼近。\n\n此逼近的绝对误差或余项为：\n$$\nE(\\epsilon) = \\big|J(\\mathbf{w}+\\epsilon \\,\\delta \\mathbf{w}) - J(\\mathbf{w}) - \\epsilon \\,\\nabla J(\\mathbf{w})^\\top \\delta \\mathbf{w}\\big|.\n$$\n如果 $J$ 是局部光滑的，$E(\\epsilon)$ 应按 $\\mathcal{O}(\\epsilon^2)$ 比例缩放。但是，如果扰动 $\\epsilon\\,\\delta\\mathbf{w}$ 导致绝对值函数的参数穿过 $x=0$，则会激活一个导数不连续的“扭折点”。在这种情况下，一阶泰勒展开不再能完全描述局部行为，余项 $E(\\epsilon)$ 将由 $\\mathcal{O}(\\epsilon)$ 阶的项主导，反映了不可微性。\n\n#### 3. 经验收敛阶\n为了量化这种行为，我们将误差建模为 $E(\\epsilon) \\approx C \\epsilon^p$，其中 $C$ 是某个常数，$p$ 是收敛阶。取以 10 为底的对数，得到一个线性关系：\n$$\n\\log_{10} E(\\epsilon) \\approx \\log_{10} C + p \\log_{10} \\epsilon.\n$$\n通过为递减的 $\\epsilon$ 值序列计算 $E(\\epsilon)$，我们得到一组数据点 $(\\log_{10}\\epsilon, \\log_{10}E(\\epsilon))$。然后，经验收敛阶 $p$ 被确定为通过这些点的最佳拟合线的斜率，使用线性最小二乘法计算。\n\n#### 4. 实现与案例分析\n实现将遵循这些原则。为提高效率，将使用向量化的 `NumPy` 操作。对于每个测试案例，我们将：\n1. 构建状态向量 $\\mathbf{w}$。\n2. 生成并归一化随机扰动向量 $\\delta\\mathbf{w}$。\n3. 计算基准泛函值 $J(\\mathbf{w})$ 和伴随梯度 $\\nabla J(\\mathbf{w})$。\n4. 对于每个 $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$，计算余项 $E(\\epsilon)$。\n5. 对 $(\\log_{10}\\epsilon, \\log_{10}E(\\epsilon))$ 进行线性回归以找到斜率 $p$。\n\n- **案例 1 (光滑场)：** 状态向量 $\\mathbf{w}$ 是一个光滑函数。差值 $d_i = w_{i+1}-w_i$ 将很小但通常非零。泛函的求值远离不可微的扭折点。预计行为是光滑的，得到收敛阶 $p \\approx 2$。\n- **案例 2 (近扭折点场)：** 状态向量是 $\\mathbf{w}=\\mathbf{0}$，意味着所有差值都是 $d_i=0$。泛函完全在扭折点上求值。选择的次梯度为 $\\nabla J(\\mathbf{0}) = \\mathbf{0}$。任何扰动 $\\delta\\mathbf{w}$ 都会使参数 $d_i$ 偏离 $0$，从而激活不可微性。误差将由线性项主导，因此我们预期 $p \\approx 1$。\n- **案例 3 (间断场)：** 状态向量表示一个离散阶跃。大多数差值是 $d_i=0$，在阶跃位置有一个大的非零差值。与案例 2 一样，扰动将在许多 $d_i=0$ 的位置激活扭折点。这种不可微行为预计将占主导地位，导致收敛阶 $p \\approx 1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a first-order adjoint linearization check\n    for a nondifferentiable functional.\n    \"\"\"\n\n    # Define problem constants\n    N = 200\n    KAPPA = 0.1\n    EPSILONS = np.array([1e-1, 1e-2, 1e-3, 1e-4])\n\n    def compute_J(w, kappa):\n        \"\"\"Computes the functional J(w).\"\"\"\n        d = w[1:] - w[:-1]\n        phi_d = np.abs(d) + 0.5 * kappa * d**2\n        return np.sum(phi_d)\n\n    def compute_grad_J(w, kappa):\n        \"\"\"Computes the adjoint gradient of J(w).\"\"\"\n        d = w[1:] - w[:-1]\n        \n        # Derivative of phi(x) = |x| + 0.5*kappa*x^2\n        # d(phi)/dx = sign(x) + kappa*x, with sign(0)=0 as per problem spec.\n        # np.sign(0) is 0, so this works directly.\n        phi_prime_d = np.sign(d) + kappa * d\n        \n        grad_w = np.zeros_like(w)\n        \n        # Reverse-mode accumulation\n        grad_w[1:] += phi_prime_d\n        grad_w[:-1] -= phi_prime_d\n        \n        return grad_w\n\n    def calculate_convergence_order(w, seed, n, kappa, epsilons):\n        \"\"\"\n        Calculates the empirical convergence order p for a given state w.\n        \"\"\"\n        # Generate and normalize the random perturbation\n        rng = np.random.default_rng(seed)\n        dw_raw = rng.standard_normal(n)\n        dw = dw_raw / np.linalg.norm(dw_raw)\n        \n        # Compute baseline values\n        J0 = compute_J(w, kappa)\n        grad_J = compute_grad_J(w, kappa)\n        adj_dot_dw = np.dot(grad_J, dw)\n        \n        errors = []\n        for eps in epsilons:\n            w_eps = w + eps * dw\n            J_eps = compute_J(w_eps, kappa)\n            error = np.abs(J_eps - J0 - eps * adj_dot_dw)\n            errors.append(error)\n            \n        log_eps = np.log10(epsilons)\n        log_E = np.log10(np.array(errors))\n        \n        # Fit a line log(E) = p * log(eps) + c to find the slope p\n        # using numpy's polyfit for linear regression.\n        p = np.polyfit(log_eps, log_E, 1)[0]\n        \n        return p\n\n    # Define test cases\n    x_grid = np.linspace(0, 1, N)\n    \n    # Case 1: Smooth field\n    w1 = np.sin(2 * np.pi * x_grid) + 0.2 * np.cos(3 * np.pi * x_grid) + 0.3\n    seed1 = 13\n    \n    # Case 2: Near-kink field\n    w2 = np.zeros(N)\n    seed2 = 17\n    \n    # Case 3: Discontinuous field\n    w3 = np.ones(N)\n    w3[x_grid = 0.5] = -1.0\n    seed3 = 19\n    \n    test_cases = [\n        (w1, seed1),\n        (w2, seed2),\n        (w3, seed3),\n    ]\n\n    results = []\n    for w, seed in test_cases:\n        p = calculate_convergence_order(w, seed, N, KAPPA, EPSILONS)\n        results.append(f\"{p:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了梯度计算的准确性之后，我们便可以将伴随方法应用于解决实际的工程问题，其中最典型的应用之一便是形状优化。本练习将指导我们如何计算形状敏感性，即目标函数如何随边界变形而变化 。通过将伴随方法计算得到的形状梯度与通过直接扰动网格获得的有限差分结果进行比较，我们可以验证形状导数公式的数值实现，这是空气动力学设计优化流程中的一个核心环节。",
            "id": "3289239",
            "problem": "考虑一个一维模型问题，该问题捕捉了扩散型偏微分方程 (PDE) 形状敏感性的本质，这是计算流体力学中常用的替代模型。设域为区间 $\\Omega = (0,L)$，在 $x=L$ 处的外单位法向量为 $+1$，在 $x=0$ 处为 $-1$。状态变量 $u(x)$ 求解以下边值问题\n$$\n-\\,u''(x) = f(x) \\quad \\text{for } x \\in (0,L), \\qquad u(0)=0, \\quad u(L)=0,\n$$\n其中源项为常数 $f(x) \\equiv 1$。定义目标泛函\n$$\nJ(\\Omega) = \\int_0^L u(x)\\,dx.\n$$\n在 $x=L$ 处的一个小的法向边界扰动由 $L \\mapsto L_\\epsilon = L + \\epsilon\\,V_n(L)$ 给出，其中 $\\epsilon$ 是一个小标量，$V_n(L)$ 是边界在 $x=L$ 处速度的法向分量。Hadamard 形式表明，形状导数可以表示为一个边界积分\n$$\n\\mathrm{d}J(\\Omega; \\boldsymbol{V}) \\;=\\; \\int_{\\partial \\Omega} g \\, \\boldsymbol{V} \\cdot \\boldsymbol{n} \\, ds,\n$$\n其中 $g$ 是形状梯度密度，$\\boldsymbol{n}$ 是 $\\partial \\Omega$ 上的外单位法向量。在一维情况下，这简化为在端点上的带符号求和。\n\n使用伴随方法，定义伴随变量 $p(x)$ 以强制拉格朗日量的平稳性，并满足以下伴随偏微分方程\n$$\np''(x) = w(x) \\quad \\text{for } x \\in (0,L), \\qquad p(0)=0, \\quad p(L)=0,\n$$\n其中 $w(x) \\equiv 1$ 对应于 $J(\\Omega)$ 对 $u$ 的线性敏感度。该问题的 Hadamard 形式简化为一个涉及状态和伴随法向导数的边界表达式。具体而言，对于所选的拉格朗日量和约束条件，在 $x=L$ 处的形状梯度为\n$$\ng(L) \\;=\\; -\\,u'(L)\\,p'(L).\n$$\n你的任务是实现一个网格扰动测试，通过比较以下两项来数值验证 Hadamard 形式：\n1. 伴随形状梯度预测 $-\\,u'(L)\\,p'(L)\\,V_n(L)$，以及\n2. 通过求解在 $(0,L_\\epsilon)$ 上的扰动问题计算出的有限差分估计 $\\displaystyle \\frac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n\n为每个测试用例实现以下步骤：\n- 在 $(0,L)$ 上的具有 $N$ 个区间的均匀网格上，使用二阶中心差分对内部点离散化 $u(x)$ 的正演 PDE，并强制执行狄利克雷边界条件 $u(0)=u(L)=0$。\n- 使用复合梯形法则在同一网格上计算 $J(\\Omega)$。\n- 使用相同的网格和边界条件离散化并求解 $p(x)$ 的伴随 PDE。使用 $w(x)\\equiv 1$。\n- 使用右边界处的二阶单边有限差分公式来近似 $u'(L)$ 和 $p'(L)$：\n$$\n\\phi'(L) \\approx \\frac{3\\,\\phi(L) - 4\\,\\phi(L-h) + \\phi(L-2h)}{2h},\n$$\n其中 $\\phi(L)=0$ 且 $h=L/N$。\n- 构造伴随预测 $G_{\\text{adj}} = -\\,u'(L)\\,p'(L)\\,V_n(L)$，其中 $V_n(L)=1$。\n- 通过在 $(0,L_\\epsilon)$ 上使用相同数量的区间 $N$ 重新求解正演问题，并用梯形法则计算 $J(\\Omega_\\epsilon)$，来构造有限差分估计 $G_{\\text{fd}} = \\dfrac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n- 对每个测试用例，将相对误差 $E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$ 作为浮点数报告。\n\n此问题无需物理单位，也不涉及角度。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如，“[result1,result2,...]”。\n\n对所有情况使用以下参数值 $(L,N,\\epsilon)$ 测试套件，其中 $V_n(L)=1$：\n- 测试 1 (正常路径)：$(1.0, 200, 1.0\\times 10^{-4})$。\n- 测试 2 (小域边缘情况)：$(0.2, 200, 1.0\\times 10^{-5})$。\n- 测试 3 (较大域)：$(3.0, 300, 1.0\\times 10^{-4})$。\n- 测试 4 (较粗网格压力测试)：$(1.0, 50, 1.0\\times 10^{-4})$。\n\n您的程序必须实现上述数值方案，并在一行中以指定的精确格式将四个相对误差 $E$ 作为浮点数列表输出。",
            "solution": "在尝试解决方案之前，对问题陈述的有效性进行了严格评估。\n\n### 步骤 1：提取已知条件\n\n所提供的信息如下：\n- **状态方程（正演问题）**：域 $\\Omega = (0,L)$ 上状态变量 $u(x)$ 的一维边值问题。\n$$-\\,u''(x) = f(x) \\quad \\text{for } x \\in (0,L)$$\n具有常数源项 $f(x) \\equiv 1$ 和狄利克雷边界条件 $u(0)=0, u(L)=0$。\n- **目标泛函**：\n$$J(\\Omega) = \\int_0^L u(x)\\,dx$$\n- **边界扰动**：域长度 $L$ 被扰动为 $L_\\epsilon = L + \\epsilon\\,V_n(L)$，其中 $V_n(L)$ 是在 $x=L$ 处的法向速度。\n- **伴随方程**：伴随变量 $p(x)$ 满足边值问题：\n$$p''(x) = w(x) \\quad \\text{for } x \\in (0,L)$$\n具有常数源项 $w(x) \\equiv 1$ 和狄利克雷边界条件 $p(0)=0, p(L)=0$。\n- **形状梯度**：在 $x=L$ 处的形状梯度密度由以下公式给出：\n$$g(L) = -\\,u'(L)\\,p'(L)$$\n- **数值方法**：\n    - **PDE 离散化**：在具有 $N$ 个区间（$h=L/N$）的均匀网格上使用二阶中心差分。\n    - **积分近似**：复合梯形法则。\n    - **边界导数近似**：二阶单边有限差分公式：$\\phi'(L) \\approx \\frac{3\\,\\phi(L) - 4\\,\\phi(L-h) + \\phi(L-2h)}{2h}$。\n- **任务**：\n    1.  计算基于伴随的梯度预测：$G_{\\text{adj}} = g(L)\\,V_n(L) = -\\,u'(L)\\,p'(L)\\,V_n(L)$。\n    2.  计算有限差分梯度估计：$G_{\\text{fd}} = \\dfrac{J(\\Omega_\\epsilon)-J(\\Omega)}{\\epsilon}$。\n    3.  计算相对误差：$E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$。\n- **常数和参数**：对所有情况，$V_n(L)=1$。\n- **测试用例**：四个元组 $(L, N, \\epsilon)$ 的列表：\n    1.  $(1.0, 200, 1.0\\times 10^{-4})$\n    2.  $(0.2, 200, 1.0\\times 10^{-5})$\n    3.  $(3.0, 300, 1.0\\times 10^{-4})$\n    4.  $(1.0, 50, 1.0\\times 10^{-4})$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据**：该问题是将数值分析和优化理论中的标准技术应用于一个典型的微分方程。状态和伴随方程都是一维泊松方程的形式，这是物理学和工程学中的一个基本模型。形状导数的概念、Hadamard 形式以及使用伴随方法进行计算，都是偏微分方程敏感性分析和形状优化中公认的核心原则。所有提供的数值近似公式（中心差分、梯形法则、单边导数）都是标准且正确的。\n- **适定性**：状态变量 $u(x)$ 和伴随变量 $p(x)$ 的边值问题都是适定的，允许唯一解。整个任务是一个数值验证程序，它定义良好，并且对于每个测试用例都会产生唯一的数值结果。\n- **客观性**：问题以精确、形式化的数学语言陈述。它没有歧义、主观性或非科学主张。\n- **完整性与一致性**：问题陈述是自包含的。它提供了执行计算所需的所有必要方程、边界条件、数值方案和参数值。没有内部矛盾。例如，伴随方程 $p''=w$（其中 $w=1$）与推导泛函 $J=\\int u\\,dx$ 的敏感性是一致的。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。这是一个基于计算数学既定原则的适定、科学合理且清晰表述的数值任务。将提供完整的解决方案。\n\n### 解决方案\n\n任务是执行网格扰动测试，以数值方式验证由微分方程约束的目标泛函的形状梯度的伴随公式。我们将通过伴随方法计算的梯度 $G_{\\text{adj}}$ 与通过有限差分近似获得的估计值 $G_{\\text{fd}}$ 进行比较。\n\n**1. 解析框架**\n\n为了提供背景和进行验证，我们首先建立解析解。\n状态方程为 $-\\,u''(x) = 1$，且 $u(0)=u(L)=0$。积分两次并应用边界条件，得到状态变量的精确解：\n$$u(x) = \\frac{1}{2} x(L-x)$$\n伴随方程为 $p''(x) = 1$，且 $p(0)=p(L)=0$。这可以写成 $-\\,p''(x) = -1$。其解为：\n$$p(x) = -\\frac{1}{2} x(L-x) = -u(x)$$\n目标泛函 $J$ 可以解析计算：\n$$J(\\Omega) = \\int_0^L \\frac{1}{2} x(L-x) \\,dx = \\frac{1}{2} \\left[ \\frac{Lx^2}{2} - \\frac{x^3}{3} \\right]_0^L = \\frac{L^3}{12}$$\n状态和伴随变量在 $x=L$ 处的导数为：\n$$u'(x) = \\frac{L}{2} - x \\implies u'(L) = -\\frac{L}{2}$$\n$$p'(x) = x - \\frac{L}{2} \\implies p'(L) = \\frac{L}{2}$$\n在 $x=L$ 处的精确形状梯度密度为：\n$$g(L) = -u'(L)p'(L) = -\\left(-\\frac{L}{2}\\right)\\left(\\frac{L}{2}\\right) = \\frac{L^2}{4}$$\n对于 $V_n(L)=1$，精确的形状导数为 $\\frac{L^2}{4}$。这为我们的数值结果提供了一个基准。\n\n**2. 数值实现策略**\n\n实现的核心是求解在 $(0, \\ell)$ 上带有 $y(0)=y(\\ell)=0$ 的泛型一维泊松问题 $-y''(x) = f(x)$ 的求解器。\n- **PDE 求解器**：我们将域 $(0, \\ell)$ 离散化为 $N$ 个宽度为 $h = \\ell/N$ 的均匀区间。网格点为 $x_i = i h$，其中 $i=0, \\dots, N$。内部点 $x_i$ ($i=1, \\dots, N-1$) 处的二阶导数通过二阶中心差分近似：\n$$ -y''(x_i) \\approx \\frac{-y_{i-1} + 2y_i - y_{i+1}}{h^2} = f_i $$\n这导致一个关于内部节点值 $\\mathbf{y}_{int} = [y_1, \\dots, y_{N-1}]^T$ 的 $N-1$ 个线性方程组。该系统形式为 $A \\mathbf{y}_{int} = \\mathbf{b}$，其中 $A$ 是一个对称正定三对角矩阵，主对角线上为 $2$，次对角线和超对角线上为 $-1$，并按 $1/h^2$ 缩放。右侧是 $\\mathbf{b} = [f_1, \\dots, f_{N-1}]^T$。我们将使用 `scipy.linalg.solve_banded` 进行高效求解。完整的解向量则为 $\\mathbf{y} = [0, y_1, \\dots, y_{N-1}, 0]^T$。\n\n有了这个求解器，每个测试用例 $(L, N, \\epsilon)$ 的过程如下：\n\n- **步骤 A：基准和伴随计算（在域 $\\Omega = (0,L)$ 上）**\n    1.  通过调用泊松求解器，使用 $\\ell=L$、$N$ 和源函数 $f(x)=1$ 来求解状态 $u(x)$。设解为 $\\mathbf{u}$。\n    2.  在 $\\mathbf{u}$ 和步长 $h=L/N$ 上使用复合梯形法则计算基准目标泛函 $J(\\Omega)$：$J(\\Omega) \\approx h \\sum_{i=1}^{N-1} u_i$。\n    3.  通过调用泊松求解器求解 $-p''=-1$，使用 $\\ell=L$、$N$ 和等效于 $f(x)=-1$ 的源函数来求解伴随变量 $p(x)$。设解为 $\\mathbf{p}$。\n    4.  分别在数值解 $\\mathbf{u}$ 和 $\\mathbf{p}$ 上使用提供的二阶单边公式近似导数 $u'(L)$ 和 $p'(L)$。对于一个通用解 $\\phi$ 且 $\\phi_N=0$，公式为 $\\phi'(L) \\approx \\frac{-4\\phi_{N-1} + \\phi_{N-2}}{2h}$。\n    5.  计算伴随梯度预测：$G_{\\text{adj}} = -u'(L)_{num} \\, p'(L)_{num} \\, V_n(L)$，其中 $V_n(L) = 1$。\n\n- **步骤 B：有限差分计算（在扰动域 $\\Omega_\\epsilon = (0,L_\\epsilon)$ 上）**\n    1.  定义扰动域长度 $L_\\epsilon = L + \\epsilon V_n(L)$。\n    2.  通过调用泊松求解器，使用 $\\ell=L_\\epsilon$、$N$ 和源 $f(x)=1$ 来求解扰动状态 $u_\\epsilon(x)$。设解为 $\\mathbf{u}_\\epsilon$。\n    3.  在 $\\mathbf{u}_\\epsilon$ 和新步长 $h_\\epsilon = L_\\epsilon/N$ 上使用梯形法则计算扰动目标泛函 $J(\\Omega_\\epsilon)$：$J(\\Omega_\\epsilon) \\approx h_\\epsilon \\sum_{i=1}^{N-1} u_{\\epsilon,i}$。\n    4.  计算有限差分梯度估计：$G_{\\text{fd}} = \\frac{J(\\Omega_\\epsilon) - J(\\Omega)}{\\epsilon}$。\n\n- **步骤 C：误差计算**\n    1.  计算两个梯度近似之间的相对误差 $E$：$E = \\dfrac{\\left|G_{\\text{adj}} - G_{\\text{fd}}\\right|}{\\max\\left(10^{-12}, \\left|G_{\\text{fd}}\\right|\\right)}$。\n\n将对问题陈述中指定的每个测试用例执行此程序。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_poisson_1d(length, n_intervals, source_val):\n    \"\"\"\n    Solves the 1D Poisson equation -y'' = f on (0, length) with y(0)=y(length)=0.\n\n    Args:\n        length (float): The length of the domain.\n        n_intervals (int): The number of intervals for the uniform mesh.\n        source_val (float): The constant value of the source term f.\n\n    Returns:\n        numpy.ndarray: The numerical solution vector y, including boundary points.\n    \"\"\"\n    h = length / n_intervals\n    num_interior_pts = n_intervals - 1\n\n    if num_interior_pts  1:\n        return np.zeros(n_intervals + 1)\n\n    # Set up the tridiagonal system Ay_int = b for interior points\n    # The equation is (-y_{i-1} + 2y_i - y_{i+1})/h^2 = f_i\n    # This leads to a matrix with main diagonal 2, and sub/super diagonals -1.\n    diagonals = np.zeros((3, num_interior_pts))\n    diagonals[0, 1:] = -1.0  # Super-diagonal\n    diagonals[1, :] = 2.0    # Main diagonal\n    diagonals[2, :-1] = -1.0 # Sub-diagonal\n\n    # Right-hand side vector\n    b = np.full(num_interior_pts, h**2 * source_val)\n\n    # Solve the banded system\n    y_interior = solve_banded((1, 1), diagonals, b)\n\n    # Construct the full solution vector including boundaries\n    y = np.zeros(n_intervals + 1)\n    y[1:-1] = y_interior\n    return y\n\ndef compute_integral_J(y, h):\n    \"\"\"\n    Computes the integral of y using the composite trapezoidal rule.\n    Assumes boundary values y[0] and y[-1] are zero.\n\n    Args:\n        y (numpy.ndarray): The function values on the grid.\n        h (float): The grid spacing.\n\n    Returns:\n        float: The approximate value of the integral.\n    \"\"\"\n    # For trapezoidal rule: h * ( (y_0 + y_N)/2 + sum(y_i for i=1 to N-1) )\n    # Since y_0 = y_N = 0, this simplifies.\n    return h * np.sum(y[1:-1])\n\ndef compute_boundary_derivative(phi, h):\n    \"\"\"\n    Computes the derivative at the right boundary phi'(L) using a \n    second-order one-sided finite difference formula.\n    phi'(L) approx (3*phi(L) - 4*phi(L-h) + phi(L-2h))/(2h).\n    Given phi(L) = 0.\n    \n    Args:\n        phi (numpy.ndarray): The function values, where phi[-1] is phi(L).\n        h (float): The grid spacing.\n\n    Returns:\n        float: The approximate derivative at the boundary.\n    \"\"\"\n    # phi[-1] is phi(L), phi[-2] is phi(L-h), phi[-3] is phi(L-2h)\n    # The formula given is (3*phi[-1] - 4*phi[-2] + phi[-3]) / (2*h).\n    # Since boundary condition enforces phi[-1] = 0.\n    if len(phi)  3:\n        return np.nan # Not enough points for the stencil\n    return (-4.0 * phi[-2] + phi[-3]) / (2.0 * h)\n\ndef solve():\n    \"\"\"\n    Main function to run the mesh-perturbation test for the given cases.\n    \"\"\"\n    test_cases = [\n        (1.0, 200, 1.0e-4),\n        (0.2, 200, 1.0e-5),\n        (3.0, 300, 1.0e-4),\n        (1.0, 50, 1.0e-4),\n    ]\n\n    results = []\n\n    for L, N, epsilon in test_cases:\n        Vn_L = 1.0\n\n        # --- Base problem and Adjoint Method ---\n        h = L / N\n        \n        # Solve forward problem for u(x) on (0,L)\n        # -u'' = 1\n        u_sol = solve_poisson_1d(L, N, source_val=1.0)\n        \n        # Compute baseline objective functional J(Omega)\n        J_base = compute_integral_J(u_sol, h)\n        \n        # Solve adjoint problem for p(x) on (0,L)\n        # p'' = 1, so -p'' = -1\n        p_sol = solve_poisson_1d(L, N, source_val=-1.0)\n        \n        # Compute derivatives at the right boundary\n        u_prime_L = compute_boundary_derivative(u_sol, h)\n        p_prime_L = compute_boundary_derivative(p_sol, h)\n        \n        # Calculate the adjoint gradient prediction\n        G_adj = -u_prime_L * p_prime_L * Vn_L\n\n        # --- Perturbed problem and Finite Difference Method ---\n        L_eps = L + epsilon * Vn_L\n        h_eps = L_eps / N\n\n        # Solve forward problem for u_eps(x) on (0, L_eps)\n        u_eps_sol = solve_poisson_1d(L_eps, N, source_val=1.0)\n        \n        # Compute objective functional on perturbed domain J(Omega_eps)\n        J_eps = compute_integral_J(u_eps_sol, h_eps)\n\n        # Calculate the finite difference gradient estimate\n        G_fd = (J_eps - J_base) / epsilon\n        \n        # --- Compute Relative Error ---\n        denominator = max(1.0e-12, abs(G_fd))\n        error = abs(G_adj - G_fd) / denominator\n        results.append(error)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多现实世界中的流动问题本质上是瞬态的，这给伴随方法的应用带来了独特的挑战。值得注意的是，对于具有非正规（non-normal）动力学特性的系统（如湍流或混沌流），伴随方程的逆时积分过程可能会变得不稳定，导致计算出的伴随变量出现爆炸性增长 。本练习通过一个简化的模型系统，清晰地揭示了这种不稳定性，并让我们动手实现并测试一种滤波技术来稳定伴随解，从而确保为瞬态问题获取可靠的梯度信息。",
            "id": "3289215",
            "problem": "考虑一个线性时变半离散动力学系统，该系统模拟了在非正规算子作用下一个双分量状态 $u \\in \\mathbb{R}^{2}$ 的演化。该系统定义在一个均匀时间网格 $t_{n} = n \\Delta t$ 上，其中 $n \\in \\{0,1,\\dots,N\\}$，时间步长 $\\Delta t$ 为常数。其正向动力学由应用于线性常微分方程的显式欧拉格式给出\n$$\n\\frac{d u}{d t} = A(t)\\, u + \\theta\\, b(t)\\, s,\n$$\n其中 $A(t) \\in \\mathbb{R}^{2 \\times 2}$ 是一个时变上三角矩阵\n$$\nA(t) = \\begin{bmatrix} -\\alpha  \\beta(t) \\\\ 0  -\\alpha \\end{bmatrix},\n$$\n$\\theta \\in \\mathbb{R}$ 是一个标量参数，$b(t) \\in \\mathbb{R}$ 是一个已知的标量时间函数，$s \\in \\mathbb{R}^{2}$ 是一个固定源向量。离散正向更新为\n$$\nu_{n+1} = u_{n} + \\Delta t \\left(A_{n}\\, u_{n} + \\theta\\, b_{n}\\, s\\right),\n$$\n其中 $A_{n} \\equiv A(t_{n})$ 且 $b_{n} \\equiv b(t_{n})$。初始条件为 $u_{0} = 0$。定义性能度量\n$$\nJ(\\theta) = \\frac{1}{2}\\,\\|u_{N}\\|_{2}^{2},\n$$\n其中 $\\|\\cdot\\|_{2}$ 表示欧几里得范数。\n\n您将实现一个离散伴随方法来计算灵敏度 $\\frac{dJ}{d\\theta}$，并研究一种基于伴随变量逆时低通滤波的伴随稳定化技术。显式欧拉格式的离散伴随由终端条件定义\n$$\np_{N} = \\frac{\\partial J}{\\partial u_{N}} = u_{N},\n$$\n以及反向递推关系\n$$\np_{n} = \\left(I + \\Delta t\\, A_{n}\\right)^{\\top} p_{n+1}, \\quad n = N-1, N-2, \\dots, 0.\n$$\n相应的离散伴随梯度为\n$$\ng_{\\text{adj}} = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} p_{n+1}.\n$$\n为了在时间反向积分时，稳定由非正规放大引起的伴随方程中潜在的爆发现象，定义一个应用于伴随序列 $\\{p_{n}\\}$ 的逆时一阶低通滤波器：\n$$\nq_{N} = p_{N}, \\quad q_{n} = r\\, p_{n} + (1-r)\\, q_{n+1}, \\quad r \\in (0,1], \\quad n = N-1, \\dots, 0.\n$$\n滤波后的伴随梯度使用滤波后的序列 $\\{q_{n}\\}$ 来代替 $\\{p_{n}\\}$：\n$$\ng_{\\text{filt}}(r) = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} q_{n+1}.\n$$\n\n您的任务是编写一个程序，对于一组给定的滤波器强度和非正规性水平的测试集，评估逆时低通滤波是否能减轻伴随方程的爆发现象，同时保持相对于有限差分基准的梯度的正确性。具体而言：\n\n- 使用以下固定的数值规格：\n  - 时间范围 $T = 20.0$，均匀步长 $\\Delta t = 0.005$，步数 $N = 4000$。\n  - 阻尼参数 $\\alpha = 0.01$。\n  - 时变非正规耦合\n    $$\n    \\beta(t) = \\text{scale} \\cdot \\beta_{0}\\, \\left(1 + 0.5 \\sin(\\omega t)\\right),\n    $$\n    其中基础振幅 $\\beta_{0} = 120.0$，频率 $\\omega = 0.7$。\n  - 源项 $s = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$ 和输入调制 $b(t) = \\cos\\!\\left(2\\pi t / T\\right)$。\n  - 参数值 $\\theta = 0.3$。\n  - 用于中心差分基准的有限差分步长 $\\varepsilon = 10^{-6}$\n    $$\n    g_{\\text{fd}} = \\frac{J(\\theta + \\varepsilon) - J(\\theta - \\varepsilon)}{2\\varepsilon}.\n    $$\n  - 爆破阈值 $M = 10^{8}$，通过以下准则，对实际用于计算梯度的序列（如果 $r = 1$ 则为未滤波序列，如果 $r \\in (0,1)$ 则为滤波序列）进行评估\n    $$\n    \\max_{0 \\le n \\le N} \\|z_{n}\\|_{2}  M \\quad \\Rightarrow \\quad \\text{blow-up} = 1,\n    $$\n    其中，如果 $r=1$，则 $z_{n} = p_{n}$；否则 $z_{n} = q_{n}$。\n\n- 实现正向模拟，对于给定的 $\\theta$ 和 $\\text{scale}$，通过显式欧拉格式计算 $J(\\theta)$。然后实现离散伴随和带有系数 $r$ 的逆时滤波器，以计算 $g_{\\text{filt}}(r)$。\n\n- 对于每个测试用例，计算：\n  - 爆破指示符，为一个整数：如果根据上述准则检测到爆破，则为 $1$；否则为 $0$。\n  - 相对梯度误差\n    $$\n    E = \\frac{|g_{\\text{filt}}(r) - g_{\\text{fd}}|}{\\max\\{1, |g_{\\text{fd}}|\\}}.\n    $$\n\n测试集：\n针对以下四对参数 $(r,\\text{scale})$ 评估程序：\n- 用例 1：$(r, \\text{scale}) = (1.0, 1.5)$。\n- 用例 2：$(r, \\text{scale}) = (0.8, 1.0)$。\n- 用例 3：$(r, \\text{scale}) = (0.2, 1.5)$。\n- 用例 4：$(r, \\text{scale}) = (1.0, 0.5)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，条目按以下顺序排列\n$$\n[\\text{blow}_{1}, E_{1}, \\text{blow}_{2}, E_{2}, \\text{blow}_{3}, E_{3}, \\text{blow}_{4}, E_{4}],\n$$\n其中 $\\text{blow}_{k} \\in \\{0,1\\}$，而 $E_{k}$ 是对应测试用例 $k \\in \\{1,2,3,4\\}$ 的一个浮点数。不应打印任何额外文本。",
            "solution": "问题陈述已经过分析并确定为有效。它在计算科学领域内提出了一个适定、有科学依据的数值任务，特别关注用于非正规动力学系统灵敏度分析的离散伴随方法。所有参数、方程和评估标准都得到了明确且一致的定义，从而可以得到一个唯一且可验证的解。\n\n目标是计算性能度量 $J(\\theta)$ 关于参数 $\\theta$ 的灵敏度 $\\frac{dJ}{d\\theta}$。该灵敏度，或称梯度，使用离散伴随方法计算。该问题研究了在伴随方程的时间反向积分过程中，由于系统算子的非正规性可能出现的数值不稳定性（爆发现象）。引入了一种逆时低通滤波器作为一种潜在的稳定化技术，通过将得到的滤波后伴随梯度 $g_{\\text{filt}}(r)$ 与通过有限差分计算的基准梯度 $g_{\\text{fd}}$ 进行比较来评估其有效性。\n\n问题的核心是为每个指定的测试用例实现一系列数值算法。方法论分解如下：\n\n1.  **正向模拟与性能评估**\n\n    系统的状态 $u \\in \\mathbb{R}^{2}$ 根据从显式欧拉离散化导出的离散正向更新规则演化：\n    $$\n    u_{n+1} = u_{n} + \\Delta t \\left(A_{n}\\, u_{n} + \\theta\\, b_{n}\\, s\\right)\n    $$\n    其中 $u_{0} = 0$。时变矩阵为 $A_{n} = A(t_{n}) = \\begin{bmatrix} -\\alpha  \\beta(t_{n}) \\\\ 0  -\\alpha \\end{bmatrix}$。该方程在时间上从 $n=0$ 向前步进到 $n=N-1$ 以找到最终状态 $u_{N}$。然后计算性能度量：\n    $$\n    J(\\theta) = \\frac{1}{2}\\,\\|u_{N}\\|_{2}^{2} = \\frac{1}{2} u_{N}^{\\top} u_{N}\n    $$\n    必须对参数 $\\theta$ 的三个值执行此正向模拟：标称值 $\\theta_{\\text{nom}}$、$\\theta_{\\text{nom}} + \\varepsilon$ 和 $\\theta_{\\text{nom}} - \\varepsilon$。\n\n2.  **有限差分基准梯度**\n\n    中心差分近似为梯度提供了一个基准值。使用上一步计算的性能度量，有限差分梯度为：\n    $$\n    g_{\\text{fd}} = \\frac{J(\\theta_{\\text{nom}} + \\varepsilon) - J(\\theta_{\\text{nom}} - \\varepsilon)}{2\\varepsilon}\n    $$\n    其中 $\\varepsilon$ 是一个小扰动。该值作为“真实值”，用于与基于伴随方法的梯度进行比较。\n\n3.  **离散伴随模拟**\n\n    离散伴随方法提供了一种计算梯度的有效方式。伴随变量 $p \\in \\mathbb{R}^{2}$ 由一个反向递推关系控制。模拟从性能度量 J 相对于最终状态 u_N 的梯度导出的终端条件开始：\n    $$\n    p_{N} = \\frac{\\partial J}{\\partial u_{N}} = u_{N}\n    $$\n    其中 $u_N$ 是使用标称参数 $\\theta_{\\text{nom}}$ 的正向模拟得到的最终状态。然后，伴随变量在时间上从 $n=N-1$ 反向积分到 $n=0$：\n    $$\n    p_{n} = \\left(I + \\Delta t\\, A_{n}\\right)^{\\top} p_{n+1}\n    $$\n    $A_n$ 中的大非对角线项可能导致非正规放大，从而导致模 $\\|p_n\\|$ 的快速增长，这种现象被称为“伴随爆破”。\n\n4.  **逆时低通滤波**\n\n    为了减轻潜在的爆发现象，将一个递归的一阶低通滤波器应用于伴随序列 $\\{p_n\\}$ 的反向积分过程中。这将生成一个滤波后的伴随序列 $\\{q_n\\}$。该滤波器由以下递推关系定义：\n    $$\n    q_{N} = p_{N}\n    $$\n    $$\n    q_{n} = r\\, p_{n} + (1-r)\\, q_{n+1}, \\quad \\text{for } n = N-1, \\dots, 0\n    $$\n    滤波器强度由参数 $r \\in (0,1]$ 控制。$r=1$ 的值对应于无滤波，此时对所有 $n$ 都有 $q_n = p_n$。较小的 $r$ 值对应于更强的滤波，它将当前伴随状态 $p_n$ 与先前计算的滤波状态 $q_{n+1}$ 进行平均。\n\n5.  **伴随梯度与误差计算**\n\n    梯度是通过将每个时间步的贡献（由伴随变量加权）求和来计算的。滤波后的伴随梯度 $g_{\\text{filt}}(r)$ 由下式给出：\n    $$\n    g_{\\text{filt}}(r) = \\sum_{n=0}^{N-1} \\Delta t\\, b_{n}\\, s^{\\top} q_{n+1}\n    $$\n    此求和与伴随和滤波器方程的反向积分同时执行。\n\n6.  **评估指标**\n\n    对于由一对 $(r, \\text{scale})$ 定义的每个测试用例，计算两个指标：\n    - **爆破指示符：** 对反向积分的稳定性进行评估。令用于计算梯度的序列表示为 $\\{z_n\\}$，其中如果 $r=1$ 则 $z_n = p_n$，如果 $r \\in (0,1)$ 则 $z_n = q_n$。如果该序列的最大范数超过阈值 $M$，则检测到爆破：\n      $$\n      \\text{blow-up} = \\begin{cases} 1  \\text{if } \\max_{0 \\le n \\le N} \\|z_{n}\\|_{2}  M \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n    - **相对梯度误差：** 滤波后伴随梯度的准确性通过其相对于有限差分基准的相对误差来衡量：\n      $$\n      E = \\frac{|g_{\\text{filt}}(r) - g_{\\text{fd}}|}{\\max\\{1, |g_{\\text{fd}}|\\}}\n      $$\n    分母 $\\max\\{1, |g_{\\text{fd}}|\\}$ 确保了即使基准梯度接近于零，误差也是良定义的。\n\n每个测试用例的计算过程是：首先运行必要的前向模拟以计算 $g_{\\text{fd}}$，然后运行结合了指定滤波器强度 $r$ 的后向伴随模拟以计算 $g_{\\text{filt}}(r)$ 并检查是否爆破，最后计算相对误差 $E$。对所有四个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the computation for all test cases.\n    \"\"\"\n    \n    # Fixed numerical specifications from the problem statement\n    T = 20.0\n    dt = 0.005\n    N = int(T / dt)  # 4000 steps\n    alpha = 0.01\n    beta0 = 120.0\n    omega = 0.7\n    s = np.array([1.0, 0.0])\n    theta_nom = 0.3\n    eps = 1e-6\n    M = 1e8\n\n    # Test suite: pairs of (r, scale)\n    test_cases = [\n        (1.0, 1.5),  # Case 1\n        (0.8, 1.0),  # Case 2\n        (0.2, 1.5),  # Case 3\n        (1.0, 0.5),  # Case 4\n    ]\n\n    # Pre-compute time-dependent arrays\n    time_pts = np.linspace(0, T, N + 1)\n    b_vals = np.cos(2 * np.pi * time_pts / T)\n\n    def forward_sim(theta_val, scale_val, beta_vals_scaled):\n        \"\"\"\n        Runs the forward simulation to compute the objective J and final state u_N.\n        \"\"\"\n        u = np.zeros(2)\n        for n in range(N):\n            A_n = np.array([[-alpha, beta_vals_scaled[n]], [0, -alpha]])\n            u = u + dt * (A_n @ u + theta_val * b_vals[n] * s)\n        \n        J = 0.5 * (u @ u)\n        return J, u\n\n    def compute_metrics(r, scale):\n        \"\"\"\n        Computes the blow-up indicator and relative error for a given (r, scale) case.\n        \"\"\"\n        # --- Step 1: Compute time-dependent coupling for this scale ---\n        beta_vals_scaled = scale * beta0 * (1 + 0.5 * np.sin(omega * time_pts))\n\n        # --- Step 2: Compute finite-difference gradient benchmark ---\n        J_p, _ = forward_sim(theta_nom + eps, scale, beta_vals_scaled)\n        J_m, _ = forward_sim(theta_nom - eps, scale, beta_vals_scaled)\n        g_fd = (J_p - J_m) / (2 * eps)\n\n        # --- Step 3: Run forward simulation for nominal theta to get u_N ---\n        _, u_N_nom = forward_sim(theta_nom, scale, beta_vals_scaled)\n\n        # --- Step 4: Run backward adjoint simulation with filtering ---\n        p = u_N_nom.copy()\n        q = u_N_nom.copy()\n        \n        # Initialize gradient and max norm for blow-up check\n        g_filt = 0.0\n        \n        z_n = q if r  1.0 else p\n        max_norm_sq = z_n @ z_n\n        \n        for n in range(N - 1, -1, -1):\n            # p_next and q_next correspond to p_{n+1} and q_{n+1}\n            p_next = p.copy()\n            q_next = q.copy()\n\n            # Add contribution to gradient sum\n            # Note: s is a 1D array, so s @ q_next is s^T q_{n+1}\n            g_filt += dt * b_vals[n] * (s @ q_next)\n\n            # Compute p_n\n            A_n = np.array([[-alpha, beta_vals_scaled[n]], [0, -alpha]])\n            prop_T = (np.eye(2) + dt * A_n).T\n            p = prop_T @ p_next\n            \n            # Compute q_n\n            q = r * p + (1 - r) * q_next\n\n            # Update max norm for blow-up check\n            z_n = q if r  1.0 else p\n            current_norm_sq = z_n @ z_n\n            if current_norm_sq  max_norm_sq:\n                max_norm_sq = current_norm_sq\n        \n        # --- Step 5: Finalize metrics ---\n        blowup = 1 if np.sqrt(max_norm_sq)  M else 0\n        \n        error = np.abs(g_filt - g_fd) / max(1.0, np.abs(g_fd))\n        \n        return blowup, error\n\n    results = []\n    for r_case, scale_case in test_cases:\n        blowup_val, error_val = compute_metrics(r_case, scale_case)\n        results.append(blowup_val)\n        results.append(error_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}