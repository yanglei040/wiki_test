{
    "hands_on_practices": [
        {
            "introduction": "斜压涡量生成是可压缩流体动力学中的一个基本机制，它描述了当压力和密度梯度不重合时如何产生旋转。本练习提供了一个关键的动手实践，通过从完整的涡量输运方程中分离出斜压源项，来验证这一过程——这是验证计算流体动力学（CFD）代码时一个常见且必要的步骤。通过在受控条件下对该方程进行数值积分，并与解析解进行比较，您将更深入地理解这一关键物理原理以及用于模拟它的数值方法。",
            "id": "3361565",
            "problem": "要求您使用一个简化的二维周期性域和受控的初始谱，对激波-湍流相互作用中的斜压涡度生成项进行自洽的数值验证。出发点必须是可压缩的Navier–Stokes方程及其旋度（涡度输运方程）。在二维空间中，涡度沿平面外方向，记涡度为$\\omega$，速度为$\\boldsymbol{u}$，密度为$\\rho$，压力为$p$，运动粘度为$\\nu$。物质输运涡度方程可写作 $D\\boldsymbol{\\omega}/Dt = (\\boldsymbol{\\omega}\\cdot\\nabla)\\boldsymbol{u} - \\boldsymbol{\\omega}(\\nabla\\cdot \\boldsymbol{u}) + \\nabla \\rho \\times \\nabla p / \\rho^2 + \\nu \\nabla^2 \\boldsymbol{\\omega}$。在运动学验证设置中，强制所有时间下$\\boldsymbol{u}=\\boldsymbol{0}$，因此 $D\\boldsymbol{\\omega}/Dt=\\partial \\boldsymbol{\\omega}/\\partial t$，演化方程简化为 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$，其中 $S_b = (\\partial_x \\rho \\, \\partial_y p - \\partial_y \\rho \\, \\partial_x p)/\\rho^2$ 是斜压源项。目的是在不求解$\\boldsymbol{u}$的情况下，通过控制$\\rho$的谱内容和类激波压力场，来分离并验证斜压源计算的正确性，并在$S_b$不随时间变化时，将直接数值积分与精确谱解进行定量比较。\n\n域和场：使用边长为 $L_x=L_y=2\\pi$ 的双周期正方形域，由 $N_x \\times N_y$ 个均匀间距的网格点离散化。密度场 $\\rho(x,y)$ 必须构造成具有受控的谱内容，压力场 $p(x,y)$ 必须表示一对稳态、周期性的平滑激波，其大梯度主要沿 $x$ 方向。设涡度初始条件为 $\\omega(x,y,0)=0$。所有量均为无量纲。\n\n使用的基本依据：可压缩Navier–Stokes方程，涡度的定义 $\\boldsymbol{\\omega}=\\nabla\\times\\boldsymbol{u}$，物质输运形式 $D/Dt=\\partial/\\partial t+\\boldsymbol{u}\\cdot\\nabla$，以及提供斜压源项 $\\nabla \\rho \\times \\nabla p / \\rho^2$ 且经过充分检验的涡度输运方程。必须使用周期域上的傅里叶谱微分恒等式，通过快速傅里叶变换计算空间梯度和拉普拉斯算子，角波数为 $k_x=2\\pi n_x/L_x$ 和 $k_y=2\\pi n_y/L_y$，其中 $n_x$ 和 $n_y$ 是整数模态指数。\n\n您的程序必须在三个精心选择的测试用例上实现以下验证任务，使用稳定的显式格式对 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ 进行时间积分，并与预期结果进行比较：\n\n1. 梯度对齐（斜压源被抑制）：选择仅依赖于 $x$ 的 $\\rho(x,y)$ 和通过周期性激波对仅依赖于 $x$ 的 $p(x,y)$，从而使得 $\\partial_y \\rho=0$ 和 $\\partial_y p=0$，意味着 $S_b=0$。在粘度 $\\nu=0$ 的条件下积分至最终时间 $T$，并报告 $\\omega(x,y,T)$ 的 $\\ell_2$ 范数，在精确算术中该值应为 $0$。\n\n2. 梯度最大程度错位（无扩散的纯斜压生成）：选择仅依赖于 $y$ 的 $\\rho(x,y)$，以及与激波对中一样仅依赖于 $x$ 的 $p(x,y)$。当 $\\nu=0$ 时，$S_b$ 不随时间变化，精确解为 $\\omega(x,y,T)=T\\,S_b(x,y)$。数值积分至 $T$，并报告数值解 $\\omega$ 与解析解 $T\\,S_b$ 之间的相对 $\\ell_2$ 误差。\n\n3. 具有可控谱的湍流密度和扩散演化：通过谱合成方法构造 $\\rho(x,y)$，其随机相位被约束在目标波数 $k_0$ 周围的各向同性环内，并进行缩放以确保处处 $\\rho(x,y)0$，$p(x,y)$ 仍为激波对。在粘度 $\\nu0$ 且 $S_b$ 不随时间变化的情况下，每个非零模态的精确谱解为 $\\hat{\\omega}(\\boldsymbol{k},T)=\\hat{S}_b(\\boldsymbol{k})\\,(1-e^{-\\nu |\\boldsymbol{k}|^2 T})/(\\nu |\\boldsymbol{k}|^2)$，其中帽子符号表示傅里叶系数，且 $|\\boldsymbol{k}|^2=k_x^2+k_y^2$，零模态遵循 $\\hat{\\omega}(\\boldsymbol{0},T)=T\\,\\hat{S}_b(\\boldsymbol{0})$。数值积分至 $T$，并报告数值解 $\\omega$ 与精确谱解的傅里叶逆变换之间的相对 $\\ell_2$ 误差。\n\n必须执行的数值细节：使用快速傅里叶变换进行谱微分，以计算 $\\partial_x$、$\\partial_y$ 和 $\\nabla^2$。使用四阶显式龙格-库塔方法进行时间积分。通过使用基准值加上小幅度脉动来确保 $\\rho(x,y)$ 保持严格为正。对谱合成使用可复现的随机种子。所有计算都是无量纲的；不需要物理单位。角度以弧度为单位。\n\n测试套件参数值：\n- 用例 1：$N_x=N_y=64$，$L_x=L_y=2\\pi$，$\\nu=0$，$T=0.20$，激波厚度 $\\delta=0.05\\,L_x$，压差幅值 $\\Delta p=1.0$，密度幅值 $A_\\rho=0.1$，密度波数 $k_\\rho=4$（沿 $x$ 方向）。\n- 用例 2：$N_x=N_y=64$，$L_x=L_y=2\\pi$，$\\nu=0$，$T=0.15$，$\\delta=0.05\\,L_x$，$\\Delta p=1.0$，$A_\\rho=0.1$，密度波数 $k_\\rho=5$（沿 $y$ 方向）。\n- 用例 3：$N_x=N_y=64$，$L_x=L_y=2\\pi$，$\\nu=0.01$，$T=0.20$，$\\delta=0.05\\,L_x$，$\\Delta p=1.0$，谱环中心 $k_0=8$，环半宽 $\\Delta k=1$，密度脉动幅值 $A_\\rho=0.1$。\n\n程序要求：您的程序必须按照规定构造 $\\rho$ 和 $p$，计算 $S_b$，使用为确保数值稳定性和准确性而选择的固定时间步长 $\\Delta t$ 将 $\\partial \\omega / \\partial t = S_b + \\nu \\nabla^2 \\omega$ 从 $t=0$ 积分到 $t=T$，然后为每个用例计算所要求的定量指标：用例1的一个浮点数，用例2的一个浮点数，以及用例3的一个浮点数。最终输出格式必须是单行文本，包含由方括号括起来的三个结果的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个浮点数。\n\n您的程序必须只产生这一行输出，不得有任何其他内容。所有计算必须在没有用户输入的情况下完成。",
            "solution": "该问题提出了一个关于斜压涡度生成项的数值验证任务。斜压涡度生成项是可压缩流体动力学中的一个基本机制，尤其与激波-湍流相互作用相关。验证在一个简化的运动学设置中进行，其中速度场 $\\boldsymbol{u}$ 被设为零，这样可以分离出斜压效应和粘性效应对涡度演化的影响。在二维 $(x,y)$ 中，涡度的平面外分量 $\\omega$ 的控制方程为：\n$$\n\\frac{\\partial \\omega}{\\partial t} = S_b + \\nu \\nabla^2 \\omega\n$$\n其中 $\\nu$ 是运动粘度，$S_b$ 是斜压源项，由密度和压力梯度的叉积定义：\n$$\nS_b = \\frac{\\nabla \\rho \\times \\nabla p}{\\rho^2} = \\frac{1}{\\rho^2} \\left( \\frac{\\partial \\rho}{\\partial x} \\frac{\\partial p}{\\partial y} - \\frac{\\partial \\rho}{\\partial y} \\frac{\\partial p}{\\partial x} \\right)\n$$\n该问题要求在一个边长为 $L=2\\pi$、在均匀 $N_x \\times N_y$ 网格上离散的双周期正方形域上，从零涡度初始条件 $\\omega(x,y,0)=0$ 开始积分此方程。对于三个不同的测试用例，必须将解与解析结果或预期的零结果进行比较。\n\n数值实现遵循以下原则：\n\n**1. 空间离散化：傅里叶伪谱法**\n在周期域上，傅里叶谱方法是计算空间导数最精确的方法。函数 $f(x,y)$ 由其离散傅里叶级数系数 $\\hat{f}(k_x, k_y)$ 表示。物理空间中的空间导数对应于傅里叶空间中与虚数单位 $i$ 和相应波数的代数乘法。对于一个场 $f$ 及其傅里叶变换 $\\hat{f}$，其导数和拉普拉斯算子通过以下方式计算：\n$$\n\\frac{\\partial f}{\\partial x} = \\mathcal{F}^{-1}\\{i k_x \\hat{f}\\} \\quad , \\quad \\frac{\\partial f}{\\partial y} = \\mathcal{F}^{-1}\\{i k_y \\hat{f}\\}\n$$\n$$\n\\nabla^2 f = \\mathcal{F}^{-1}\\{-(k_x^2 + k_y^2) \\hat{f}\\}\n$$\n其中 $\\mathcal{F}^{-1}$ 表示傅里叶逆变换，$k_x$ 和 $k_y$ 是离散波数。该方法使用快速傅里叶变换（FFT）算法高效实现。\n\n**2. 时间积分：四阶龙格-库塔（RK4）方法**\n时间演化使用经典的四阶显式龙格-库塔格式进行，对于给定的时间步长 $\\Delta t$，该格式在精度（四阶）和稳定性之间提供了良好的平衡。对于形式为 $d\\omega/dt = \\mathcal{R}(\\omega)$ 的常微分方程，从 $\\omega_n$ 到 $\\omega_{n+1}$ 的单个时间步长计算如下：\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot \\mathcal{R}(\\omega_n) \\\\\nk_2 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_1/2) \\\\\nk_3 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_2/2) \\\\\nk_4 = \\Delta t \\cdot \\mathcal{R}(\\omega_n + k_3) \\\\\n\\omega_{n+1} = \\omega_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n其中 $\\mathcal{R}(\\omega) = S_b + \\nu \\nabla^2 \\omega$。时间步长 $\\Delta t$ 的选择要足够小，以确保数值稳定性（尤其受高波数下粘性项 $\\nu \\nabla^2 \\omega$ 的限制）和时间精度。\n\n**3. 场的构造**\n静态压力场和密度场构造如下：\n-   **压力场：** 需要一对周期性的平滑激波，其梯度主要在 $x$ 方向。一个在 $[0, 2\\pi]$ 上周期性且具备这些特征的合适函数是 $p(x,y) = \\frac{\\Delta p}{2} \\tanh(\\frac{\\cos(x)}{\\epsilon})$，其中 $\\epsilon = 2\\delta/L_x$ 是一个控制激波厚度的参数。这会在 $x=\\pi/2$ 和 $x=3\\pi/2$ 附近产生陡峭的压力梯度。\n-   **密度场：**\n    -   **用例1（梯度对齐）：** 一个简单的正弦场，$\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho x)$，其梯度仅在 $x$ 方向。由于 $\\nabla p$ 也仅在 $x$ 方向，它们的叉积为零，从而得到 $S_b=0$。\n    -   **用例2（梯度错位）：** 一个类似的正弦场，但沿 $y$ 方向定向，$\\rho(x,y) = 1 + A_\\rho \\sin(k_\\rho y)$。这里，$\\nabla\\rho$ 与 $\\nabla p$ 垂直，使得斜压源项 $S_b$ 最大化。\n    -   **用例3（湍流密度）：** 通过谱合成方法构造一个具有受控谱内容的场。在物理空间中生成一个随机实数场，使用FFT变换到傅里叶空间，然后进行滤波，仅保留由 $k_0 - \\Delta k \\le |\\boldsymbol{k}| \\le k_0 + \\Delta k$ 定义的各向同性波数环内的能量。将得到的滤波后的谱变换回物理空间，以获得类湍流的密度脉动场。该场按指定的幅值 $A_\\rho$ 进行缩放，并加上平均值 $1$ 以确保 $\\rho > 0$。\n\n**4. 验证与度量**\n-   **用例1：** 由于 $S_b=0$ 且 $\\nu=0$，方程变为 $\\partial \\omega/\\partial t=0$。在 $\\omega(0)=0$ 的条件下，精确解为 $\\omega(T)=0$。度量标准是最终数值涡度的 $\\ell_2$-范数 $||\\omega(T)||_2$，其值应接近机器精度。\n-   **用例2：** 在场不随时间变化且 $\\nu=0$ 的情况下，方程为 $\\partial \\omega/\\partial t = S_b(\\text{常数})$。精确解为 $\\omega(T) = T \\cdot S_b$。度量标准是数值解与精确解之间的相对 $\\ell_2$-误差 $||\\omega_{\\text{num}} - \\omega_{\\text{exact}}||_2 / ||\\omega_{\\text{exact}}||_2$。\n-   **用例3：** 对于 $\\nu0$ 的情况，控制方程是一个带有常数源项的线性偏微分方程。其在傅里叶空间中的精确解已给出。对于每个波数 $\\boldsymbol{k}$：\n    $$\n    \\hat{\\omega}(\\boldsymbol{k}, T) = \\begin{cases} \\hat{S}_b(\\boldsymbol{k}) \\frac{1 - e^{-\\nu |\\boldsymbol{k}|^2 T}}{\\nu |\\boldsymbol{k}|^2}  \\text{if } |\\boldsymbol{k}| \\neq 0 \\\\ T \\cdot \\hat{S}_b(\\boldsymbol{k})  \\text{if } |\\boldsymbol{k}| = 0 \\end{cases}\n    $$\n    物理空间中的精确解 $\\omega_{\\text{exact}}(T)$ 通过对 $\\hat{\\omega}(\\boldsymbol{k}, T)$ 进行傅里叶逆变换得到。度量标准同样是数值解与精确解之间的相对 $\\ell_2$-误差。\n\n提供的Python程序实现了这些步骤，处理每个测试用例以计算并报告指定的定量度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the baroclinic vorticity verification problem for three test cases.\n    \"\"\"\n    test_cases_params = [\n        {'case_id': 1, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 4},\n        {'case_id': 2, 'N': 64, 'L': 2 * np.pi, 'nu': 0.0, 'T': 0.15, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k_rho': 5},\n        {'case_id': 3, 'N': 64, 'L': 2 * np.pi, 'nu': 0.01, 'T': 0.20, 'delta_rel': 0.05, 'dp': 1.0, 'a_rho': 0.1, 'k0': 8, 'dk': 1},\n    ]\n\n    results = []\n    n_steps = 1000  # Fixed number of time steps for stability and accuracy\n\n    for params in test_cases_params:\n        # 1. Setup Grid and Wavenumbers\n        N = params['N']\n        L = params['L']\n        dx = L / N\n        x_1d = np.arange(N) * dx\n        x, y = np.meshgrid(x_1d, x_1d, indexing='ij')\n\n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n        k_sq = kx**2 + ky**2\n\n        # 2. Define Spectral Derivative Utilities\n        def grad(f_field):\n            f_hat = np.fft.fft2(f_field)\n            dfdx = np.fft.ifft2(1j * kx * f_hat).real\n            dfdy = np.fft.ifft2(1j * ky * f_hat).real\n            return dfdx, dfdy\n\n        def laplacian(f_field):\n            f_hat = np.fft.fft2(f_field)\n            return np.fft.ifft2(-k_sq * f_hat).real\n\n        # 3. Construct Initial Density and Pressure Fields\n        dp = params['dp']\n        delta_param = 2 * params['delta_rel']\n        p = (dp / 2.0) * np.tanh(np.cos(x) / delta_param)\n\n        if params['case_id'] == 1:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * x)\n        elif params['case_id'] == 2:\n            rho = 1.0 + params['a_rho'] * np.sin(params['k_rho'] * y)\n        else:  # Case 3\n            k0, dk, a_rho = params['k0'], params['dk'], params['a_rho']\n            np.random.seed(42)  # For reproducibility\n\n            k_mag = np.sqrt(k_sq)\n            filter_mask = (k_mag >= k0 - dk)  (k_mag = k0 + dk)\n            \n            # Generate a random real field, FFT, filter, then IFFT\n            rand_field = np.random.randn(N, N)\n            rand_hat = np.fft.fft2(rand_field)\n            \n            rho_hat_filtered = rand_hat * filter_mask\n            delta_rho = np.fft.ifft2(rho_hat_filtered).real\n            delta_rho -= np.mean(delta_rho) # Ensure zero mean fluctuation\n            \n            # Scale to specified peak amplitude\n            max_abs_val = np.max(np.abs(delta_rho))\n            if max_abs_val > 1e-9:\n                delta_rho *= a_rho / max_abs_val\n            \n            rho = 1.0 + delta_rho\n\n        # 4. Compute Baroclinic Source Term\n        rho_dx, rho_dy = grad(rho)\n        p_dx, p_dy = grad(p)\n        S_b = (rho_dx * p_dy - rho_dy * p_dx) / rho**2\n\n        # 5. Time Integration (RK4)\n        omega = np.zeros((N, N))\n        T, nu = params['T'], params['nu']\n        dt = T / n_steps\n\n        def rhs(w):\n            return S_b + nu * laplacian(w)\n\n        for _ in range(n_steps):\n            k1 = dt * rhs(omega)\n            k2 = dt * rhs(omega + 0.5 * k1)\n            k3 = dt * rhs(omega + 0.5 * k2)\n            k4 = dt * rhs(omega + k3)\n            omega += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n        # 6. Calculate and Store Result Metric\n        if params['case_id'] == 1:\n            result = np.linalg.norm(omega)\n        elif params['case_id'] == 2:\n            omega_analytic = T * S_b\n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n        else: # Case 3\n            S_b_hat = np.fft.fft2(S_b)\n            omega_hat_analytic = np.zeros_like(S_b_hat)\n            \n            # Non-zero k modes\n            non_zero_k_mask = k_sq > 1e-12\n            k_sq_nz = k_sq[non_zero_k_mask]\n            \n            term = nu * k_sq_nz\n            factor = (1.0 - np.exp(-term * T)) / term\n            \n            omega_hat_analytic[non_zero_k_mask] = S_b_hat[non_zero_k_mask] * factor\n            \n            # Zero k mode (k=0)\n            omega_hat_analytic[0, 0] = S_b_hat[0, 0] * T\n            \n            omega_analytic = np.fft.ifft2(omega_hat_analytic).real\n            \n            error_norm = np.linalg.norm(omega - omega_analytic)\n            analytic_norm = np.linalg.norm(omega_analytic)\n            result = error_norm / analytic_norm if analytic_norm > 1e-12 else error_norm\n\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "瑞利-泰勒不稳定性是界面不稳定性的一个经典例子，但在低马赫数条件下对其进行模拟会给可压缩流求解器带来数值刚度问题。本练习通过一个简化但物理上富有洞察力的模型来深入探讨这个问题，该模型模拟了可压缩求解器的行为。通过分析此模型，您将探索低马赫数预处理技术如何通过加速声波来恢复正确的不稳定性增长率，从而清晰地揭示数值方法与物理准确性之间的联系。",
            "id": "3361543",
            "problem": "您的任务是构建一个数学上一致且成本低廉的模型问题，该模型能够捕捉低马赫数下瑞利-泰勒界面不稳定性的初始增长，并用其检验可压缩求解器预处理策略的有效性范围。重点在于线性的、单模态的设定，这种设定具有普适性，因为它仅需要基本定律和明确的假设，并且可以用任何编程语言实现。\n\n考虑在均匀引力场中，两种不互溶的无粘性流体，重流体位于轻流体之上，引力加速度为恒定值 $g$（单位：$\\mathrm{m/s^2}$）。设密度分别为 $\\rho_h$ 和 $\\rho_\\ell$ 且 $\\rho_h  \\rho_\\ell$，并定义阿特伍德数 $A = (\\rho_h - \\rho_\\ell)/(\\rho_h + \\rho_\\ell)$（无量纲）。假设初始平坦界面上存在小振幅、单傅里葉模态的扰动，其波数为 $k$（单位：$\\mathrm{m^{-1}}$），并在水平方向上采用周期性，以及与线性阶段一致的势流运动学。马赫数 $M$（无量纲）是根据下述的参考速度标度和声速定义的。\n\n出发点和建模假设：\n- 从带重力的可压缩欧拉方程（质量和动量守恒）以及扰动的等熵关系 $p' = c^2 \\rho'$ 出发，其中 $c$ 是声速。采用低振幅、单模态线性化，其中所有场在水平方向上都以 $\\exp(i k x)$ 的形式变化并随时间演化。\n- 在不可压缩极限下，当惯性项中的密度变化可忽略不计时（布辛涅斯克近似），界面位移振幅 $\\eta(t)$ 满足一个形如 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$ 的二阶常微分方程，其中算子 $\\mathcal{L}_I$ 由 $A$、$g$ 和 $k$ 决定，并导致以某个增长率 $\\sigma_I$（单位：$\\mathrm{s^{-1}}$）的指数增长。\n- 为了在与低马赫数区域和快速声学尺度的存在相一致的方式下模拟有限可压缩性，引入一个针对界面振幅 $\\eta(t)$、界面垂直速度振幅 $w(t)$ 和一个模态压力梯度类振幅 $q(t)$（该振幅会弛豫到浮力驱动项）的最小线性三变量系统。在此模型中，可压缩求解器由以下线性系统表示：\n  1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$，\n  2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$，\n  3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$，\n  其中 $\\tau_a$ 是一个弛豫时间尺度，代表声学信号传播一个波长 $2\\pi/k$ 所需的时间。这个 $\\tau_a$ 必须如下文所述，使用声速和预处理因子从第一性原理出发来选择。\n\n参考标度和马赫数的定义：\n- 令不可压缩线性增长率（将由您从上述不可压缩模型中推导得出）为 $\\sigma_I = \\sqrt{A g k}$（单位：$\\mathrm{s^{-1}}$）。定义参考速度标度为 $U_{\\mathrm{ref}} = \\sigma_I / k$（单位：$\\mathrm{m/s}$），这是单位振幅增长下的自然界面垂直速度标度。\n- 给定一个无量纲马赫数 $M$，通过 $c = U_{\\mathrm{ref}} / M$（单位：$\\mathrm{m/s}$）定义声速。这使得 $M$ 成为比值 $U_{\\mathrm{ref}}/c$。\n- 定义一个预处理因子 $\\theta$，用于缩放有效声速 $c_{\\mathrm{eff}} = \\theta\\, c$。考虑两种情况：\n  - 无预处理的可压缩模型（物理声学）：$\\theta = 1$。\n  - 有预处理的可压缩模型（旨在加速声学传播的低马赫数预处理）：当 $M \\le 1$ 时 $\\theta = 1/M$，当 $M  1$ 时 $\\theta = 1$。当 $M \\ll 1$ 时，此选择将声学弛豫时间缩短 $M$ 倍。\n- 定义了 $c_{\\mathrm{eff}}$ 后，将声学弛豫时间设为 $\\tau_a = 1/(k\\, c_{\\mathrm{eff}})$（单位：$\\mathrm{s}$）。\n\n任务：\n1) 从不可压缩模型中，推导由 $\\eta(t)$ 的二阶微分方程产生的增长率 $\\sigma_I$。用 $A$、$g$ 和 $k$ 表示 $\\sigma_I$，单位为 $\\mathrm{s^{-1}}$。\n2) 从可压缩三变量线性系统中，推导形式为 $\\eta(t) \\sim \\exp(\\sigma t)$ 的指数解的色散关系，并计算不稳定增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$），其为 $A$、$g$、$k$、$M$ 以及通过 $\\tau_a$ 体现的预处理因子 $\\theta$ 的函数。当存在多个根时，您的求解器必须能稳健地选择具有最大正实部的实根。\n3) 使用以上推导实现一个程序，为每个测试用例计算并报告：\n   - 不可压缩增长率 $\\sigma_I$（单位：$\\mathrm{s^{-1}}$），\n   - 使用指定 $\\theta$ 的有预处理的可压缩增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$），\n   - 使用 $\\theta = 1$ 的无预处理的可压缩增长率 $\\sigma_C$（单位：$\\mathrm{s^{-1}}$）。\n   所有报告值必须以 $\\mathrm{s^{-1}}$ 为单位，并四舍五入到六位小数。\n\n测试套件：\n使用以下四个测试用例，每个用例指定为一个元组 $(A, g, k, M)$，单位如上所述。\n- 用例 1（正常路径，低马赫数）：$(0.5,\\; 9.81,\\; 10.0,\\; 0.05)$\n- 用例 2（极低马赫数）：$(0.5,\\; 9.81,\\; 10.0,\\; 0.001)$\n- 用例 3（近稳定小阿特伍德数）：$(1.0\\times 10^{-6},\\; 9.81,\\; 10.0,\\; 0.1)$\n- 用例 4（中等马赫数，长波）：$(0.5,\\; 9.81,\\; 1.0,\\; 0.3)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔并用方括号括起来的结果列表。该列表必须包含对应于四个用例的十二个数字，顺序完全如下：对于每个用例，输出三个数 $[\\sigma_I,\\; \\sigma_{C,\\mathrm{pre}},\\; \\sigma_{C,\\mathrm{unpre}}]$，单位为 $\\mathrm{s^{-1}}$，每个数都四舍五入到六位小数，然后将这四个三元组展平为一个单一列表。例如，一个有效的输出形式如下：\n\"[sigmaI_case1,sigmaCpre_case1,sigmaCun_case1,sigmaI_case2,sigmaCpre_case2,sigmaCun_case2,sigmaI_case3,sigmaCpre_case3,sigmaCun_case3,sigmaI_case4,sigmaCpre_case4,sigmaCun_case4]\"。",
            "solution": "该问题要求构建并分析一个简化的瑞利-泰勒不稳定性模型，以研究低马赫数预处理方案的效果。该分析涉及为不可压缩参考情况和可压缩模型（包括有预处理和无预处理两种情况）推导不稳定性增长率。\n\n**第一部分：不可压缩增长率 ($\\sigma_I$)**\n\n问题陈述指出，在不可压缩布辛涅斯克极限下，界面位移振幅 $\\eta(t)$ 由一个形如 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$ 的二阶常微分方程 (ODE) 控制，其中 $\\mathcal{L}_I$ 是一个依赖于阿特伍德数 $A$、引力加速度 $g$ 和扰动波数 $k$ 的线性算子。\n\n为了确定算子 $\\mathcal{L}_I$，我们可以考察在声学传播无限快的极限下所给出的三变量可压缩模型。该模型为：\n1) $\\mathrm{d}\\eta/\\mathrm{d}t = w$\n2) $\\mathrm{d}w/\\mathrm{d}t = k\\, q$\n3) $\\mathrm{d}q/\\mathrm{d}t = -\\left(q - g A \\eta\\right)/\\tau_a$\n\n不可压缩极限对应于压力场的无限快调整，这在模型中通过弛豫时间 $\\tau_a \\to 0$ 来体现。在此极限下，第三个方程意味着为了使 $\\mathrm{d}q/\\mathrm{d}t$ 保持有限，括号中的项必须为零。因此，我们得到平衡条件：\n$$ q(t) = g A \\eta(t) $$\n将此代入第二个方程，得到：\n$$ \\frac{\\mathrm{d}w}{\\mathrm{d}t} = k (g A \\eta) = A g k \\eta $$\n由第一个方程可知 $w = \\mathrm{d}\\eta/\\mathrm{d}t$。将其对时间求导，得到 $\\mathrm{d}w/\\mathrm{d}t = \\mathrm{d}^2\\eta/\\mathrm{d}t^2$。结合这些结果，我们得到 $\\eta(t)$ 的二阶常微分方程：\n$$ \\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} = A g k \\eta $$\n与通用形式 $\\mathrm{d}^2 \\eta/\\mathrm{d} t^2 = \\mathcal{L}_I \\eta$ 相比，我们确定算子 $\\mathcal{L}_I$ 是乘以常数 $A g k$。为了求增长率，我们假设一个形如 $\\eta(t) \\propto \\exp(\\sigma_I t)$ 的解。将其代入常微分方程，得到特征方程：\n$$ \\sigma_I^2 = A g k $$\n瑞利-泰勒不稳定性对应于指数增长解，因此我们取正根。这得出了经典的不可压缩增长率：\n$$ \\sigma_I = \\sqrt{A g k} $$\n这完成了任务1的推导，并验证了问题描述中给出的公式。\n\n**第二部分：可压缩增长率 ($\\sigma_C$)**\n\n对于有限的声学弛豫时间 $\\tau_a$，我们必须求解完整的三变量线性系统。我们对所有三个变量假设指数解：\n$$ \\eta(t) = \\eta_0 e^{\\sigma t}, \\quad w(t) = w_0 e^{\\sigma t}, \\quad q(t) = q_0 e^{\\sigma t} $$\n其中 $\\sigma$ 是待求的复增长率。将这些代入常微分方程组，得到关于振幅 $(\\eta_0, w_0, q_0)$ 的代数系统：\n1) $\\sigma \\eta_0 = w_0$\n2) $\\sigma w_0 = k q_0$\n3) $\\sigma q_0 = -\\left(q_0 - g A \\eta_0\\right)/\\tau_a$\n\n这可以写成一个齐次线性系统。一个更直接的方法是推导一个关于 $\\eta(t)$ 的三阶常微分方程。从 $\\eta(t)$ 出发，我们可以用 $\\eta(t)$ 及其导数表示 $w(t)$ 和 $q(t)$ 及其导数：\n$$ w = \\frac{\\mathrm{d}\\eta}{\\mathrm{d}t} $$\n$$ q = \\frac{1}{k}\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} $$\n$$ \\frac{\\mathrm{d}q}{\\mathrm{d}t} = \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} $$\n将这些表达式代入第三个常微分方程：\n$$ \\frac{1}{k}\\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} = -\\frac{1}{\\tau_a}\\left(\\frac{1}{k}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - g A \\eta \\right) $$\n两边乘以 $k$ 并重新整理各项，我们得到：\n$$ \\frac{\\mathrm{d}^3\\eta}{\\mathrm{d}t^3} + \\frac{1}{\\tau_a}\\frac{\\mathrm{d}^2\\eta}{\\mathrm{d}t^2} - \\frac{A g k}{\\tau_a} \\eta = 0 $$\n假设解的形式为 $\\eta(t) \\propto \\exp(\\sigma t)$，我们得到可压缩增长率 $\\sigma$ 的特征方程（或色散关系）：\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{A g k}{\\tau_a} = 0 $$\n利用 $\\sigma_I^2 = A g k$，上式简化为：\n$$ \\sigma^3 + \\frac{1}{\\tau_a}\\sigma^2 - \\frac{\\sigma_I^2}{\\tau_a} = 0 $$\n对此三次多项式的分析表明，它恰好有一个正实根，该根对应于物理上的瑞利-泰勒不稳定性增长率 $\\sigma_C$。\n\n弛豫时间 $\\tau_a$ 定义为 $\\tau_a = 1/(k c_{\\mathrm{eff}})$，其中 $c_{\\mathrm{eff}} = \\theta c$，$c = U_{\\mathrm{ref}} / M$，以及 $U_{\\mathrm{ref}} = \\sigma_I/k$。代入这些定义，得到：\n$$ \\frac{1}{\\tau_a} = k c_{\\mathrm{eff}} = k (\\theta c) = k \\theta \\frac{U_{\\mathrm{ref}}}{M} = k \\theta \\frac{\\sigma_I/k}{M} = \\frac{\\theta \\sigma_I}{M} $$\n将此代入特征方程，得到：\n$$ \\sigma^3 + \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma^2 - \\left(\\frac{\\theta \\sigma_I}{M}\\right)\\sigma_I^2 = 0 $$\n为简化起见，我们通过定义 $\\hat{\\sigma} = \\sigma / \\sigma_I$ 来对增长率进行无量纲化。我们还定义一个无量纲参数 $\\alpha = \\theta/M$。方程变为：\n$$ (\\hat{\\sigma}\\sigma_I)^3 + \\alpha \\sigma_I (\\hat{\\sigma}\\sigma_I)^2 - \\alpha \\sigma_I \\sigma_I^2 = 0 $$\n两边除以 $\\sigma_I^3$：\n$$ \\hat{\\sigma}^3 + \\alpha \\hat{\\sigma}^2 - \\alpha = 0 $$\n这就是缩放后增长率 $\\hat{\\sigma}$ 的最终无量纲方程。对于任何给定的测试用例，我们计算参数 $\\alpha$ 并求解这个三次方程，得到其唯一的正实根 $\\hat{\\sigma}_C$。物理上的可压缩增长率则为 $\\sigma_C = \\hat{\\sigma}_C \\sigma_I$。\n\n**第三部分：实现策略**\n\n程序将为每个测试用例 $(A, g, k, M)$ 实现以下步骤：\n1.  计算不可压缩增长率 $\\sigma_I = \\sqrt{A g k}$。\n2.  对于**有预处理的**情况：\n    a. 确定预处理因子 $\\theta_{pre} = 1/M$（因为所有测试用例的 $M \\le 1$）。\n    b. 计算参数 $\\alpha_{pre} = \\theta_{pre}/M = 1/M^2$。\n    c. 求解三次方程 $\\hat{\\sigma}^3 + \\alpha_{pre} \\hat{\\sigma}^2 - \\alpha_{pre} = 0$，得到正实根 $\\hat{\\sigma}_{C,pre}$。\n    d. 计算增长率 $\\sigma_{C,pre} = \\hat{\\sigma}_{C,pre} \\sigma_I$。\n3.  对于**无预处理的**情况：\n    a. 因子为 $\\theta_{unpre} = 1$。\n    b. 计算参数 $\\alpha_{unpre} = \\theta_{unpre}/M = 1/M$。\n    c. 求解三次方程 $\\hat{\\sigma}^3 + \\alpha_{unpre} \\hat{\\sigma}^2 - \\alpha_{unpre} = 0$，得到正实根 $\\hat{\\sigma}_{C,unpre}$。\n    d. 计算增长率 $\\sigma_{C,unpre} = \\hat{\\sigma}_{C,unpre} \\sigma_I$。\n4.  然后将三个值 $(\\sigma_I, \\sigma_{C,pre}, \\sigma_{C,unpre})$ 进行格式化并收集。\n\n该三次多项式的根通过数值方法找到。一个标准的数值库例程可以找到所有三个复数根。所需的根通过其属性来识别：是实的（在很小的数值容差范围内）且为正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Rayleigh-Taylor instability growth rate problem for the specified test cases.\n    \"\"\"\n    \n    # Test cases: tuples of (A, g, k, M)\n    test_cases = [\n        (0.5, 9.81, 10.0, 0.05),     # Case 1\n        (0.5, 9.81, 10.0, 0.001),    # Case 2\n        (1.0e-6, 9.81, 10.0, 0.1),    # Case 3\n        (0.5, 9.81, 1.0, 0.3)       # Case 4\n    ]\n\n    results = []\n\n    def get_compressible_rate(alpha, sigma_I):\n        \"\"\"\n        Solves the non-dimensional cubic equation for the growth rate.\n        \n        The equation is: hat_sigma^3 + alpha * hat_sigma^2 - alpha = 0.\n        \n        Args:\n            alpha (float): The dimensionless parameter alpha = theta/M.\n            sigma_I (float): The incompressible growth rate.\n        \n        Returns:\n            float: The compressible growth rate sigma_C.\n        \"\"\"\n        # Coefficients of the polynomial p(x) = x^3 + alpha*x^2 + 0*x - alpha\n        coeffs = [1, alpha, 0, -alpha]\n        roots = np.roots(coeffs)\n        \n        # We need the unique positive real root.\n        # It's guaranteed to exist and be unique.\n        # We filter for it by checking for a positive real part and negligible imaginary part.\n        positive_real_root = None\n        for r in roots:\n            if r.real > 0 and np.abs(r.imag)  1e-9:\n                positive_real_root = r.real\n                break\n        \n        if positive_real_root is None:\n            # This case should not be reached based on the analysis.\n            # Handle as an error if it occurs.\n            raise ValueError(\"Could not find a positive real root.\")\n            \n        hat_sigma_C = positive_real_root\n        sigma_C = hat_sigma_C * sigma_I\n        return sigma_C\n\n    for case in test_cases:\n        A, g, k, M = case\n        \n        # 1. Calculate the incompressible growth rate sigma_I\n        sigma_I = np.sqrt(A * g * k)\n        \n        # --- Preconditioned Case ---\n        # Determine preconditioning factor theta\n        theta_pre = 1.0 / M if M = 1.0 else 1.0\n        # Calculate alpha parameter\n        alpha_pre = theta_pre / M\n        # Calculate compressible growth rate\n        sigma_C_pre = get_compressible_rate(alpha_pre, sigma_I)\n        \n        # --- Unpreconditioned Case ---\n        # Theta is 1\n        theta_unpre = 1.0\n        # Calculate alpha parameter\n        alpha_unpre = theta_unpre / M\n        # Calculate compressible growth rate\n        sigma_C_unpre = get_compressible_rate(alpha_unpre, sigma_I)\n        \n        # Append results for the current case\n        results.append(sigma_I)\n        results.append(sigma_C_pre)\n        results.append(sigma_C_unpre)\n\n    # Format the results to exactly six decimal places for the final output string.\n    results_str = [\"{:.6f}\".format(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "准确预测湍流穿过激波时如何被放大和扭曲，是许多工程应用（从超燃冲压发动机到超新星爆发）中的核心挑战。这个高级实践将指导您实现一个降阶模型——这是大涡模拟（LES）中的常用技术——来捕捉湍动能和各向异性的变化。您将学习如何根据快速畸变理论的理论跳跃关系来校准此类模型，并研究不同激波传感器在激活模型中的作用，从而为了解现代激波-湍流相互作用的湍流建模提供一个窗口。",
            "id": "3361602",
            "problem": "你的任务是实现一个自洽、降阶、可压缩大涡模拟 (LES) 响应模型，用于模拟均匀各向同性湍流以马赫数 $M_s$ 撞击平面、静止、正激波。目标是使用三种不同的激波传感器，计算穿越激波的湍动能 $k$ 的放大率和各向异性张量 $a_{ij}$，并将其表示为上游马赫数 $M_s$ 的函数。模型常数需通过匹配从线性（快速畸变）极限下跨激波守恒律推导出的雷诺应力跳跃条件进行校准。所有输出必须是无量纲浮点数。\n\n从以下基本基础开始：\n\n- 可压缩纳维-斯托克斯方程、理想气体定律以及跨越静止平面正激波的朗肯-雨贡纽跳跃条件。对于比热比为 $\\gamma$ 的理想气体，密度比的精确平均跳跃为\n$$\n\\eta \\equiv \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2},\n$$\n静压比的精确平均跳跃为\n$$\n\\Pi \\equiv \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n假设 $\\gamma = 1.4$。\n\n- 对平均量使用 Favre（密度加权）平均，对脉动量使用标准雷诺分解。设上游湍流为均匀各向同性，其上游湍动能为 $k_1$，上游雷诺应力为\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij},\n$$\n其中 $u_i'$ 是速度脉动，$\\delta_{ij}$ 是克罗内克δ函数。为进行归一化，设 $k_1 = 1$，因此所有输出均为无量纲。\n\n- 通过带有法向和切向乘子的分量式跳跃模型来定义下游雷诺应力 $R_{ij,2}$：\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = C_t \\, R_{22,1}, \\quad R_{33,2} = C_t \\, R_{33,1}.\n$$\n定义下游湍动能 $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$、其放大率 $A_k \\equiv k_2/k_1$ 以及下游各向异性张量\n$$\na_{ij} = \\frac{R_{ij,2}}{2 k_2} - \\frac{1}{3}\\delta_{ij}.\n$$\n\n- 使用一个带有两个未知常数 $C_1$ 和 $C_2$ 的激波传感器加权的代数响应模型来模拟 $C_n$ 和 $C_t$：\n$$\ns \\equiv g_s \\, (\\eta - 1), \\quad C_n = 1 + C_1 s + C_2 s^2, \\quad C_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2,\n$$\n其中 $g_s \\in [0,1]$ 是所选激波传感器（定义如下）的输出。$C_n$ 和 $C_t$ 之间的因式分解编码了围绕激波法向的轴对称畸变。\n\n- 通过强制施加从快速畸变极限下平面正激波的线性化守恒推导出的雷诺应力跳跃条件来校准 $(C_1, C_2)$。使用以下目标分量比作为校准目标：\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}, \\qquad C_t^{\\text{target}}(\\eta) = \\eta,\n$$\n它们分别代表了由质量通量连续性引起的法向分量减小，以及由穿过激波的平均压缩快速畸变积分引起的切向分量放大。通过最小化残差平方和来确定 $(C_1, C_2)$：\n$$\nJ(C_1,C_2) = \\sum_{M_s \\in \\mathcal{S}_{\\text{cal}}} \\left[ \\left(C_n(M_s) - C_n^{\\text{target}}(\\eta(M_s))\\right)^2 + \\left(C_t(M_s) - C_t^{\\text{target}}(\\eta(M_s))\\right)^2 \\right],\n$$\n在校准集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 上进行，并固定校准时的滤波与激波厚度之比为 $\\Delta/\\delta = 1$。由于 $C_n$ 和 $C_t$ 在减 1 后是 $C_1$ 和 $C_2$ 的线性函数，因此这是一个关于 $(C_1, C_2)$ 的线性最小二乘问题。\n\n- 实现三个激波传感器来计算 $g_s$：\n  1. 密度梯度传感器 $g_\\rho$：将激波建模为厚度为 $\\delta$ 的 $\\tanh$ 剖面，网格滤波宽度为 $\\Delta$。令\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_\\rho = 0.75$。\n  2. 基于压力的传感器 $g_p$：使用压力跳跃，\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1)\\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_p = 0.50$。\n  3. Ducros 型传感器 $g_D$：使用与 $M_s^2$ 成正比的压缩指示器，\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\, \\frac{\\Delta}{\\delta} \\right),\n  $$\n  其中 $\\alpha_D = 0.35$。\n\n实现工作流：\n\n- 对于给定的 $(M_s, \\delta/\\Delta, \\text{sensor})$，根据朗肯-雨贡纽公式（使用 $\\gamma = 1.4$）计算 $\\eta(M_s)$ 和 $\\Pi(M_s)$。计算 $\\Delta/\\delta = 1/(\\delta/\\Delta)$。\n\n- 对于每个传感器，首先使用校准集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 和 $\\Delta/\\delta = 1$（因此 $\\delta/\\Delta = 1$）求解上述定义的线性最小二乘问题来校准 $(C_1, C_2)$。在每个校准马赫数 $M_s$ 下，在 $s$ 的定义中使用特定于传感器的 $g_s$。\n\n- 使用为所选传感器校准的 $(C_1, C_2)$，在请求的 $(M_s, \\delta/\\Delta, \\text{sensor})$ 下计算 $C_n$ 和 $C_t$，然后针对 $k_1 = 1$ 和 $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$ 计算 $A_k$ 和 $a_{11}$。\n\n数值与实现细节：\n\n- 使用 $\\gamma = 1.4$ 和 $k_1 = 1$。所有量均为无量纲。\n\n- 测试套件包含以下三个案例，你必须按顺序评估：\n  - 案例 1：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$，使用密度梯度传感器 $g_\\rho$。\n  - 案例 2：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$，使用基于压力的传感器 $g_p$。\n  - 案例 3：$(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$，使用 Ducros 型传感器 $g_D$。\n\n- 对于每个案例，产生两个输出：湍动能放大率 $A_k$ 和法向分量各向异性 $a_{11}$，两者均为无量纲浮点数，并四舍五入到小数点后六位。\n\n最终输出格式：\n\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}].\n$$\n不应打印任何其他文本。所有输出必须是无量纲浮点数，并四舍五入到小数点后六位。",
            "solution": "我们构建了一个基于物理原理的降阶模型，该模型捕获了小尺度快速畸变极限下，均匀各向同性湍流的激波-湍流相互作用的核心物理。我们从守恒律和标准分解出发，然后制定一个针对雷诺应力跳跃关系的校准方法，最后定义一个可通过简短的数值程序实现的算法。\n\n基本方程和定义：\n\n- 对于比热比为 $\\gamma$ 的理想气体中的静止平面正激波，平均场的朗肯-雨贡纽跳跃条件给出了精确的密度比和压力比：\n$$\n\\eta(M_s) = \\frac{\\rho_2}{\\rho_1} = \\frac{(\\gamma+1) M_s^2}{(\\gamma-1) M_s^2 + 2}, \\quad\n\\Pi(M_s) = \\frac{p_2}{p_1} = 1 + \\frac{2\\gamma}{\\gamma+1}\\left(M_s^2 - 1\\right).\n$$\n\n- 上游流动是均匀各向同性的，其上游湍动能为 $k_1$，雷诺应力为\n$$\nR_{ij,1} = \\overline{u_i' u_j'} = \\frac{2}{3} k_1 \\delta_{ij}.\n$$\n我们设 $k_1 = 1$，因此 $R_{ij,1} = \\frac{2}{3} \\delta_{ij}$。下游应力通过分量乘子 $C_n$（法向）和 $C_t$（切向）进行建模：\n$$\nR_{11,2} = C_n \\, R_{11,1}, \\quad R_{22,2} = R_{33,2} = C_t \\, R_{22,1}.\n$$\n那么，下游湍动能为 $k_2 = \\frac{1}{2}(R_{11,2} + R_{22,2} + R_{33,2})$，放大率为 $A_k \\equiv k_2/k_1$。各向异性张量为 $a_{ij} = \\frac{R_{ij,2}}{2k_2} - \\frac{1}{3}\\delta_{ij}$，我们将从中提取 $a_{11}$。\n\n基于快速畸变的跳跃目标：\n\n- 对于与 $x$ 轴对齐的平面激波（$x$ 是激波法向），我们考虑一个跨越激波的小控制体，并对质量和动量守恒进行脉动线性化。质量通量连续性表明，法向速度脉动与跨越间断面的密度增加成反比，即 $u_n' \\to u_n'/\\eta$，前提是假设激波厚度与湍流尺度相比可以忽略不计，并且忽略了极薄间断面内部的密度脉动。对振幅求平方意味着法向分量的方差按 $1/\\eta^2$ 比例缩放。因此，对于法向分量，我们的目标是\n$$\nC_n^{\\text{target}}(\\eta) = \\eta^{-2}.\n$$\n\n- 切向分量受到平均压缩快速畸变的影响。在平面压缩的快速畸变理论中，切向分量经历的放大与穿过激波积分的压缩因子成正比。对于围绕法向的轴对称畸变，切向方差的增长与密度增加成正比（反映了物质面的收缩以及随之而来的切向梯度的放大），从而得到\n$$\nC_t^{\\text{target}}(\\eta) = \\eta.\n$$\n这对目标在线性极限下与质量守恒（对于法向分量）和压缩快速畸变（对于切向分量）是一致的，并已在激波-湍流相互作用模型中被广泛用作一阶近似。\n\n代数响应模型：\n\n- 我们引入一个带有两个未知常数 $C_1$ 和 $C_2$ 的传感器加权代数模型来表示分量乘子：\n$$\ns \\equiv g_s (\\eta - 1), \\quad\nC_n = 1 + C_1 s + C_2 s^2, \\quad\nC_t = 1 + \\frac{1}{2} C_1 s + \\frac{1}{4} C_2 s^2.\n$$\n此处 $g_s \\in [0,1]$ 是一个激波传感器。$C_n$ 和 $C_t$ 的特定形式强制了围绕激波法向的轴对称畸变，并确保当 $s \\to 0$ 时（无激波或激波完全未解析），$C_n, C_t \\to 1$。\n\n激波传感器：\n\n- 我们需要三个传感器 $g_s$，它们随激波强度和解析度（$\\Delta/\\delta$）单调增加，其中 $\\Delta$ 是网格滤波宽度，$\\delta$ 是激波厚度。注意到 $\\tanh$ 剖面的最大梯度与 $1/\\delta$ 成比例，我们定义：\n  1. 密度梯度传感器：\n  $$\n  g_\\rho = \\tanh\\!\\left( \\alpha_\\rho \\, (\\eta - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_\\rho = 0.75.\n  $$\n  2. 基于压力的传感器：\n  $$\n  g_p = \\tanh\\!\\left( \\alpha_p \\, (\\Pi - 1) \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_p = 0.50.\n  $$\n  3. Ducros 型压缩传感器：\n  $$\n  g_D = \\tanh\\!\\left( \\alpha_D \\, M_s^2 \\frac{\\Delta}{\\delta} \\right), \\quad \\alpha_D = 0.35.\n  $$\n\n校准流程：\n\n- 我们通过在校准集 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 上使用 $\\Delta/\\delta = 1$ 来最小化模型分量 $(C_n, C_t)$ 与目标 $(\\eta^{-2}, \\eta)$ 之间的残差平方和，从而确定 $C_1$ 和 $C_2$。由于减 1 后对 $(C_1, C_2)$ 的依赖性是线性的，我们构建一个最小二乘形式的线性系统。对于每个 $M_s \\in \\mathcal{S}_{\\text{cal}}$，令 $s = g_s (\\eta - 1)$，然后我们强制\n$$\nC_n - 1 = C_1 s + C_2 s^2 \\approx \\eta^{-2} - 1, \\quad\nC_t - 1 = C_1 \\frac{s}{2} + C_2 \\frac{s^2}{4} \\approx \\eta - 1.\n$$\n将这两个 $M_s$ 值的结果堆叠起来，得到关于 $(C_1, C_2)$ 的四个方程，我们以最小二乘法求解。\n\n输出计算：\n\n- 给定 $(M_s, \\delta/\\Delta, \\text{sensor})$，计算 $\\eta(M_s)$ 和 $\\Pi(M_s)$，评估 $\\Delta/\\delta = 1/(\\delta/\\Delta)$，并根据传感器定义计算 $g_s$。计算 $s = g_s(\\eta-1)$，然后计算 $C_n$ 和 $C_t$。对于 $R_{ij,1} = \\frac{2}{3}\\delta_{ij}$，可得\n$$\nR_{11,2} = \\frac{2}{3} C_n, \\quad R_{22,2} = R_{33,2} = \\frac{2}{3} C_t,\n$$\n所以\n$$\nk_2 = \\frac{1}{2}\\left( \\frac{2}{3} C_n + 2 \\cdot \\frac{2}{3} C_t \\right) = \\frac{1}{3} \\left( C_n + 2 C_t \\right)\n$$\n以及\n$$\nA_k = \\frac{k_2}{k_1} = \\frac{1}{3} \\left( C_n + 2 C_t \\right).\n$$\n最后，\n$$\na_{11} = \\frac{R_{11,2}}{2k_2} - \\frac{1}{3} = \\frac{\\frac{2}{3} C_n}{\\frac{2}{3} (C_n + 2 C_t)} - \\frac{1}{3} = \\frac{C_n}{C_n + 2 C_t} - \\frac{1}{3}.\n$$\n\n测试套件与输出：\n\n- 对每个传感器，使用 $\\mathcal{S}_{\\text{cal}} = \\{1.5, 3.0\\}$ 和 $\\Delta/\\delta = 1$ 单独校准 $(C_1, C_2)$。\n\n- 按顺序评估以下案例：\n  - 案例 1：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.05, 2.0, \\text{density})$，使用 $g_\\rho$。\n  - 案例 2：$(M_s, \\delta/\\Delta, \\text{sensor}) = (1.5, 1.0, \\text{pressure})$，使用 $g_p$。\n  - 案例 3：$(M_s, \\delta/\\Delta, \\text{sensor}) = (3.0, 0.25, \\text{ducros})$，使用 $g_D$。\n\n- 对于每个案例，计算 $A_k$ 和 $a_{11}$ 并打印\n$$\n[A_k^{(1)}, a_{11}^{(1)}, A_k^{(2)}, a_{11}^{(2)}, A_k^{(3)}, a_{11}^{(3)}]\n$$\n在单行上以逗号分隔的浮点数形式输出，四舍五入到小数点后六位。所有输出均为无量纲。\n\n算法摘要：\n\n- 实现给定 $\\gamma$ 的 $\\eta(M_s)$ 和 $\\Pi(M_s)$ 函数。\n\n- 实现传感器函数 $g_\\rho$，$g_p$，$g_D$。\n\n- 对于每个传感器，使用校准集求解一个 $4 \\times 2$ 的线性最小二乘问题以确定 $(C_1, C_2)$。\n\n- 对于每个测试案例，使用上述公式计算 $C_n$、$C_t$，然后计算 $A_k$ 和 $a_{11}$。\n\n这种方法是基于物理原理的：它从激波处的守恒律（朗肯-雨贡纽）出发，使用线性快速畸变论证来定义目标雷诺应力跳跃关系，并构建了一个与激波传感相关联、通过匹配这些目标进行校准的最小代数模型。该算法是确定性的，并由上述方程完全指定，确保了可复现性和单行数值输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nGAMMA = 1.4\n\ndef density_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot density ratio across a normal shock\n    num = (gamma + 1.0) * Ms**2\n    den = (gamma - 1.0) * Ms**2 + 2.0\n    return num / den\n\ndef pressure_ratio(Ms, gamma=GAMMA):\n    # Rankine–Hugoniot pressure ratio across a normal shock\n    return 1.0 + (2.0 * gamma / (gamma + 1.0)) * (Ms**2 - 1.0)\n\ndef sensor_value(sensor, Ms, delta_over_Delta, gamma=GAMMA):\n    # Compute g_s based on the specified sensor and parameters.\n    # delta_over_Delta = delta/Delta, so inv_ratio = Delta/delta\n    inv_ratio = 1.0 / delta_over_Delta\n    eta = density_ratio(Ms, gamma)\n    Pi = pressure_ratio(Ms, gamma)\n    if sensor == 'density':\n        alpha_rho = 0.75\n        arg = alpha_rho * (eta - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'pressure':\n        alpha_p = 0.50\n        arg = alpha_p * (Pi - 1.0) * inv_ratio\n        return np.tanh(arg)\n    elif sensor == 'ducros':\n        alpha_d = 0.35\n        arg = alpha_d * (Ms**2) * inv_ratio\n        return np.tanh(arg)\n    else:\n        raise ValueError(\"Unknown sensor type\")\n\ndef calibrate_constants(sensor, gamma=GAMMA):\n    # Calibrate C1, C2 for the given sensor using Ms in {1.5, 3.0} and Delta/delta = 1 (i.e., delta/Delta=1)\n    Ms_list = [1.5, 3.0]\n    delta_over_Delta_cal = 1.0  # so inv_ratio = 1\n    rows = []\n    rhs = []\n    for Ms in Ms_list:\n        eta = density_ratio(Ms, gamma)\n        # Targets from rapid-distortion-based jump conditions\n        Cn_target = eta**(-2.0)\n        Ct_target = eta\n        # Sensor\n        gs = sensor_value(sensor, Ms, delta_over_Delta_cal, gamma)\n        s = gs * (eta - 1.0)\n        # Equations: Cn - 1 = C1*s + C2*s^2  -> row [s, s^2], rhs (Cn_target - 1)\n        rows.append([s, s**2])\n        rhs.append(Cn_target - 1.0)\n        # Ct - 1 = C1*(s/2) + C2*(s^2/4)\n        rows.append([0.5 * s, 0.25 * s**2])\n        rhs.append(Ct_target - 1.0)\n    A = np.array(rows, dtype=float)\n    b = np.array(rhs, dtype=float)\n    # Least-squares solution\n    theta, *_ = np.linalg.lstsq(A, b, rcond=None)\n    C1, C2 = theta[0], theta[1]\n    return C1, C2\n\ndef compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, gamma=GAMMA):\n    # Compute Ak and a11 for given case and calibrated constants.\n    eta = density_ratio(Ms, gamma)\n    gs = sensor_value(sensor, Ms, delta_over_Delta, gamma)\n    s = gs * (eta - 1.0)\n    Cn = 1.0 + C1 * s + C2 * s**2\n    Ct = 1.0 + 0.5 * C1 * s + 0.25 * C2 * s**2\n    # Upstream R_ii,1 = 2/3\n    R11_2 = (2.0 / 3.0) * Cn\n    R22_2 = (2.0 / 3.0) * Ct\n    R33_2 = (2.0 / 3.0) * Ct\n    k2 = 0.5 * (R11_2 + R22_2 + R33_2)\n    Ak = k2 / 1.0  # since k1 = 1\n    # a11 = R11/(2 k2) - 1/3\n    a11 = (R11_2 / (2.0 * k2)) - (1.0 / 3.0)\n    return Ak, a11\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (Ms, delta_over_Delta, sensor_key)\n    test_cases = [\n        (1.05, 2.0, 'density'),  # Case 1: density-gradient sensor\n        (1.5,  1.0, 'pressure'), # Case 2: pressure-based sensor\n        (3.0,  0.25, 'ducros'),  # Case 3: Ducros-type sensor\n    ]\n\n    # Calibrate constants for each sensor independently.\n    sensors = ['density', 'pressure', 'ducros']\n    calib = {}\n    for s in sensors:\n        C1, C2 = calibrate_constants(s, GAMMA)\n        calib[s] = (C1, C2)\n\n    results = []\n    for Ms, delta_over_Delta, sensor in test_cases:\n        C1, C2 = calib[sensor]\n        Ak, a11 = compute_Ak_a11(Ms, delta_over_Delta, sensor, C1, C2, GAMMA)\n        # Round to six decimals as specified\n        results.append(f\"{Ak:.6f}\")\n        results.append(f\"{a11:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}