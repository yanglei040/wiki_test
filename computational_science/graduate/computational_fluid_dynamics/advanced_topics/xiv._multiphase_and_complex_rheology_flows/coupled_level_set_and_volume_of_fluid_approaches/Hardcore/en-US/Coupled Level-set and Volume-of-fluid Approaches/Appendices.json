{
    "hands_on_practices": [
        {
            "introduction": "In computational physics, verifying the correctness of our numerical schemes is a crucial first step. This practice guides you through designing a \"patch test,\" a standard procedure where a known analytical solution is used to benchmark the accuracy of your code . By computing interface normals and curvature for a simple circle, you will not only verify your implementation of finite-difference operators but also directly observe how the loss of the signed-distance property—a common issue in advected level-set fields—degrades curvature accuracy, underscoring a primary motivation for CLSVOF methods.",
            "id": "3305511",
            "problem": "Design and implement a numerical interface-normal patch test for a coupled Level-Set and Volume-of-Fluid (CLSVOF) methodology. Start from first principles and core definitions, and avoid using any pre-packaged interface reconstruction shortcuts. You will prescribe exact fields for a known geometry and then compute numerical interface normals and curvature. You will verify convergence orders under grid refinement and identify the bias introduced when the Eikonal condition is violated after advection. All computations are in two spatial dimensions and dimensionless.\n\nFundamental base:\n- A Level-Set (LS) function is a scalar field $ \\phi(\\mathbf{x}) $ whose zero isocontour represents the interface. For a signed-distance LS, $ |\\nabla \\phi| = 1 $.\n- A Volume-of-Fluid (VOF) color function is a scalar field $ C(\\mathbf{x}) \\in [0,1] $ denoting the phase indicator. We use a regularized Heaviside map from $ \\phi $ to $ C $ to obtain a smooth proxy for discrete volume fractions: for a smoothing half-width $ \\varepsilon  0 $,\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon, \\\\\n\\frac{1}{2} + \\frac{\\phi}{2\\varepsilon} + \\frac{1}{2\\pi}\\sin\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right),  |\\phi|  \\varepsilon, \\\\\n1,  \\phi \\ge \\varepsilon.\n\\end{cases}\n$$\nThen define $ C = H_\\varepsilon(\\phi) $.\n- The unit normal from a scalar field $ f $ is $ \\mathbf{n}_f = \\nabla f / \\lVert \\nabla f \\rVert $ where $ \\lVert \\cdot \\rVert $ denotes the Euclidean norm.\n- The curvature is defined by $ \\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\lVert \\nabla \\phi \\rVert \\right) $. For a circle of radius $ R $ with outward normal, the exact curvature is $ \\kappa_{\\text{exact}} = 1/R $.\n\nGeometry and exact fields:\n- Consider the unit square domain $ [0,1] \\times [0,1] $ discretized on a uniform Cartesian grid with $ N \\times N $ cell centers at coordinates $ x_i = (i + \\tfrac{1}{2}) \\Delta x $, $ y_j = (j + \\tfrac{1}{2}) \\Delta x $, where $ \\Delta x = 1/N $ and $ i,j \\in \\{0,1,\\dots,N-1\\} $.\n- Let the exact geometry be a circle centered at $ (x_0,y_0) = (0.5,0.5) $ of radius $ R = 0.3 $. The exact signed-distance Level-Set is\n$$\n\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R.\n$$\n- Define an advected (non-Eikonal) Level-Set by a smooth reparameterization that preserves the zero isocontour:\n$$\n\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)\\bigl(1 + \\beta x\\bigr) + \\gamma \\, \\phi_{\\text{sd}}(x,y)^2,\n$$\nwith $ \\beta = 0.5 $ and $ \\gamma = 0.25 \\beta $. This satisfies $ \\phi_{\\text{adv}} = 0 $ on the same circle, but $ |\\nabla \\phi_{\\text{adv}}| \\ne 1 $ in general.\n- Define the regularization half-width as $ \\varepsilon = \\alpha \\Delta x $ with $ \\alpha = 1.5 $, and set $ C = H_\\varepsilon(\\phi) $ for the chosen $ \\phi $.\n\nDiscretizations:\n- Use second-order centered finite differences to approximate spatial gradients and divergences on the uniform grid. For any sufficiently smooth scalar field $ f $ sampled at cell centers, approximate $ \\nabla f $ by centered differences in each direction. Similarly, approximate $ \\nabla \\cdot \\mathbf{g} $ for a vector field $ \\mathbf{g} $ by centered differences applied componentwise.\n- Compute the LS-based unit normal $ \\mathbf{n}_\\phi $ from $ \\phi $ and the VOF-based unit normal $ \\mathbf{n}_C $ from the smoothed $ C $, in both cases by normalizing the numerically computed gradient.\n- Compute the LS-based curvature $ \\kappa_\\phi = \\nabla \\cdot \\mathbf{n}_\\phi $.\n\nError measures and interface band:\n- Define the exact unit normal for the circle as\n$$\n\\mathbf{n}_{\\text{exact}}(x,y) = \\frac{1}{\\sqrt{(x-x_0)^2 + (y-y_0)^2}}\\begin{pmatrix} x-x_0 \\\\ y-y_0 \\end{pmatrix},\n$$\nevaluated at grid points, and the exact curvature as $ \\kappa_{\\text{exact}} = 1/R $.\n- Define an interface band (narrow band) using the exact signed-distance field: include grid points such that $ |\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon $. All error norms are computed only over this band.\n- For a vector error $ \\mathbf{e} = \\mathbf{a} - \\mathbf{b} $, use the pointwise magnitude $ \\lVert \\mathbf{e} \\rVert $. For a scalar error $ e = a - b $, use the absolute value $ |e| $. Define the discrete $ L^2 $ error over the band as the square root of the arithmetic mean of squared pointwise errors on the band.\n\nTasks:\n- For each resolution $ N \\in \\{32, 64, 128\\} $, compute the following three $ L^2 $ errors over the band for both $ \\phi_{\\text{sd}} $ and $ \\phi_{\\text{adv}} $:\n  1. LS-normal error $ E_{n,\\phi}(N) $ between $ \\mathbf{n}_\\phi $ and $ \\mathbf{n}_{\\text{exact}} $.\n  2. VOF-normal error $ E_{n,C}(N) $ between $ \\mathbf{n}_C $ and $ \\mathbf{n}_{\\text{exact}} $.\n  3. LS-curvature error $ E_{\\kappa,\\phi}(N) $ between $ \\kappa_\\phi $ and $ \\kappa_{\\text{exact}} $.\n- For each quantity, compute observed convergence orders between successive refinements using the standard definition\n$$\np = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(\\Delta x_{N_1}/\\Delta x_{N_2}\\bigr)} = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(N_2/N_1\\bigr)}.\n$$\nSpecifically compute the orders for pairs $ (N_1,N_2) \\in \\{(32,64), (64,128)\\} $.\n- Quantify the Eikonal bias in the band by computing, at the finest grid $ N = 128 $, the band-averaged deviation of the gradient magnitude from unity, namely\n$$\nB(\\phi) = \\text{mean over band}\\bigl(|\\,\\lVert \\nabla \\phi \\rVert - 1\\,|\\bigr),\n$$\nfor both $ \\phi_{\\text{sd}} $ and $ \\phi_{\\text{adv}} $.\n\nTest suite:\n- Geometry parameters: $ (x_0,y_0) = (0.5,0.5) $, $ R = 0.3 $.\n- Regularization: $ \\alpha = 1.5 $ so $ \\varepsilon = \\alpha \\Delta x $.\n- Advected parameters: $ \\beta = 0.5 $, $ \\gamma = 0.25 \\beta $.\n- Resolutions: $ N \\in \\{32, 64, 128\\} $.\n\nRequired outputs:\n- Compute and report, in the order listed below, the following $ 14 $ floating-point values:\n  1. For $ \\phi_{\\text{sd}} $: the two observed orders for LS-normal errors $ \\bigl(p_{n,\\phi}^{32\\to64}, p_{n,\\phi}^{64\\to128}\\bigr) $.\n  2. For $ \\phi_{\\text{sd}} $: the two observed orders for VOF-normal errors $ \\bigl(p_{n,C}^{32\\to64}, p_{n,C}^{64\\to128}\\bigr) $.\n  3. For $ \\phi_{\\text{sd}} $: the two observed orders for LS-curvature errors $ \\bigl(p_{\\kappa,\\phi}^{32\\to64}, p_{\\kappa,\\phi}^{64\\to128}\\bigr) $.\n  4. For $ \\phi_{\\text{adv}} $: the two observed orders for LS-normal errors $ \\bigl(\\tilde{p}_{n,\\phi}^{32\\to64}, \\tilde{p}_{n,\\phi}^{64\\to128}\\bigr) $.\n  5. For $ \\phi_{\\text{adv}} $: the two observed orders for VOF-normal errors $ \\bigl(\\tilde{p}_{n,C}^{32\\to64}, \\tilde{p}_{n,C}^{64\\to128}\\bigr) $.\n  6. For $ \\phi_{\\text{adv}} $: the two observed orders for LS-curvature errors $ \\bigl(\\tilde{p}_{\\kappa,\\phi}^{32\\to64}, \\tilde{p}_{\\kappa,\\phi}^{64\\to128}\\bigr) $.\n  7. The two bias metrics at $ N = 128 $: $ B(\\phi_{\\text{sd}}) $ and $ B(\\phi_{\\text{adv}}) $.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,...]\"). Do not include whitespace. All reported values are dimensionless real numbers.\n\nConstraints and realism:\n- Restrict all finite-difference operations to the uniform grid, and use only the numerical differentiation implied by centered differences; do not invoke any analytic derivatives of $ \\phi $ or $ C $ when computing normals or curvature.\n- The implementation must be self-contained, require no user input, and use only the specified computational libraries.",
            "solution": "The user has provided a well-posed problem statement for a numerical patch test in computational fluid dynamics. The problem is scientifically grounded, self-contained, and calls for a specific set of computations and error analyses related to the Coupled Level-Set and Volume-of-Fluid (CLSVOF) method. All definitions, parameters, and required outputs are clearly specified. The problem is therefore deemed valid and a full solution is provided below.\n\nThe problem requires the implementation and analysis of a numerical patch test to evaluate the accuracy of interface normal and curvature computations derived from Level-Set (LS) and Volume-of-Fluid (VOF) scalar fields. The analysis is performed on a static, circular interface for which exact analytical solutions are known. This allows for a precise quantification of numerical errors and a study of convergence rates under grid refinement. A key aspect of the investigation is to contrast the results obtained from a signed-distance level-set function, which satisfies the Eikonal condition $|\\nabla \\phi| = 1$, with those from a non-Eikonal field, which represents a level-set function distorted by numerical advection.\n\nThe fundamental steps of the solution are as follows:\n1.  Discretize the domain and evaluate the analytical LS and VOF fields at cell centers for each grid resolution.\n2.  Numerically compute the gradients of the LS and VOF fields using second-order centered finite differences.\n3.  Compute the interface normal vectors by normalizing the computed gradients.\n4.  Compute the interface curvature by taking the divergence of the LS-based normal vector field.\n5.  Calculate the $L^2$ errors of the numerical normals and curvature by comparing them against the exact analytical values within a specified narrow band around the interface.\n6.  Determine the observed order of convergence for each computed quantity based on the errors at three successive grid resolutions.\n7.  Quantify the Eikonal bias, i.e., the deviation of the LS gradient magnitude from unity, for both the signed-distance and the distorted LS fields.\n\nLet us formalize the numerical procedures. The domain is the unit square $[0,1] \\times [0,1]$, which is discretized into an $N \\times N$ grid. The cell centers are located at $(x_i, y_j) = ((i + 0.5)\\Delta x, (j + 0.5)\\Delta x)$ for $i,j \\in \\{0, \\dots, N-1\\}$, with grid spacing $\\Delta x = 1/N$.\n\nFor a scalar field $f$ defined on the grid, its gradient $\\nabla f = (\\partial_x f, \\partial_y f)$ is approximated using second-order centered differences. If $f_{i,j}$ denotes the value of $f$ at grid node $(i,j)$, the components of the gradient are approximated as:\n$$\n(\\partial_x f)_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta x}, \\quad\n(\\partial_y f)_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta x}\n$$\nFor a vector field $\\mathbf{g} = (g_x, g_y)$, its divergence $\\nabla \\cdot \\mathbf{g}$ is similarly approximated:\n$$\n(\\nabla \\cdot \\mathbf{g})_{i,j} \\approx \\frac{(g_x)_{i+1,j} - (g_x)_{i-1,j}}{2\\Delta x} + \\frac{(g_y)_{i,j+1} - (g_y)_{i,j-1}}{2\\Delta y}\n$$\nThese centered difference schemes are implemented for the interior grid points, with first-order schemes typically used at the boundaries.\n\nThe numerical unit normal vector $\\mathbf{n}_f$ from a field $f$ (either $\\phi$ or $C$) is computed by first approximating $\\nabla f$ and then normalizing the result at each grid point:\n$$\n\\mathbf{n}_f = \\frac{\\nabla_{\\text{num}} f}{\\lVert \\nabla_{\\text{num}} f \\rVert_2}\n$$\nwhere $\\nabla_{\\text{num}}$ denotes the finite difference gradient operator and $\\lVert \\cdot \\rVert_2$ is the Euclidean norm.\n\nThe LS-based curvature $\\kappa_\\phi$ is computed as the numerical divergence of the numerical LS unit normal field $\\mathbf{n}_\\phi$:\n$$\n\\kappa_\\phi = \\nabla_{\\text{num}} \\cdot \\mathbf{n}_\\phi\n$$\n\nThe VOF field, $C$, is derived from a given level-set field, $\\phi$, via the regularized Heaviside function $H_\\varepsilon(\\phi)$, where the smoothing width $\\varepsilon = \\alpha \\Delta x = 1.5 \\Delta x$ is proportional to the grid spacing. This construction provides a smooth transition of $C$ from $0$ to $1$ across the interface, which is necessary for computing a meaningful gradient $\\nabla C$.\n\nThe analysis distinguishes between two level-set fields:\n1.  The exact signed-distance function $\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R$, which satisfies $|\\nabla \\phi_{\\text{sd}}| = 1$ everywhere.\n2.  The \"advected\" non-Eikonal function $\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)(1 + \\beta x) + \\gamma \\phi_{\\text{sd}}(x,y)^2$. This function shares the same zero-isocontour as $\\phi_{\\text{sd}}$ but violates the Eikonal condition, i.e., $|\\nabla \\phi_{\\text{adv}}| \\neq 1$ in general. This models the distortion of a signed-distance field after being advected in a flow field without a reinitialization step.\n\nThe errors are computed in the discrete $L^2$ norm, defined as the square root of the mean of squared pointwise errors over the grid points residing in the interface band $\\{ (x,y) \\mid |\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon \\}$. For instance, the LS-normal error is:\n$$\nE_{n,\\phi}(N) = \\sqrt{ \\frac{1}{N_{\\text{band}}} \\sum_{(i,j) \\in \\text{band}} \\lVert \\mathbf{n}_\\phi(x_i, y_j) - \\mathbf{n}_{\\text{exact}}(x_i, y_j) \\rVert_2^2 }\n$$\nwhere $N_{\\text{band}}$ is the number of grid points in the band.\n\nThe observed convergence order $p$ between two resolutions $N_1$ and $N_2$ is calculated as:\n$$\np = \\frac{\\log(E(N_1)/E(N_2))}{\\log(N_2/N_1)}\n$$\nA value of $p \\approx 2$ is expected for quantities computed with second-order accurate schemes. However, for quantities like the curvature computed from $\\phi_{\\text{adv}}$, the theoretical definition $\\kappa = \\nabla \\cdot (\\nabla \\phi/|\\nabla \\phi|)$ is only valid for a signed-distance field. When $|\\nabla \\phi| \\neq 1$, this formula introduces a modeling error that does not diminish with grid refinement, leading to a zeroth-order convergence ($p \\approx 0$).\n\nFinally, the Eikonal bias $B(\\phi)$ is the band-averaged deviation of the numerical gradient magnitude from unity. This metric directly quantifies the failure to satisfy the signed-distance property, which is a primary cause of inaccuracies in curvature calculation.\n\nWe proceed with the implementation, which will systematically compute these quantities for resolutions $N \\in \\{32, 64, 128\\}$ and report the convergence orders and biases as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef H_eps(phi, eps):\n    \"\"\"\n    Computes the regularized Heaviside function H_epsilon(phi).\n    \"\"\"\n    C = np.zeros_like(phi)\n    \n    # Case 1: phi = -eps\n    # C is already 0.\n    \n    # Case 2: phi = eps\n    C[phi = eps] = 1.0\n    \n    # Case 3: |phi|  eps\n    mid_mask = np.abs(phi)  eps\n    phi_mid = phi[mid_mask]\n    \n    C[mid_mask] = 0.5 + phi_mid / (2 * eps) + (1.0 / (2.0 * np.pi)) * np.sin(np.pi * phi_mid / eps)\n    \n    return C\n\ndef get_order(err1, err2, N1, N2):\n    \"\"\"\n    Computes the convergence order p.\n    Handles potential division by zero if errors are extremely small.\n    \"\"\"\n    if err1 = 0.0 or err2 = 0.0:\n        return 0.0\n    return np.log(err1 / err2) / np.log(N2 / N1)\n\ndef analyze_field(phi, phi_sd_for_band, N, dx, grid_x, grid_y, x0, y0, alpha, kappa_exact):\n    \"\"\"\n    Performs the analysis for a given level-set field: calculates normals,\n    curvature, and errors.\n    \"\"\"\n    eps = alpha * dx\n    band_mask = np.abs(phi_sd_for_band) = 2 * eps\n    \n    # Avoid division by zero if the band is empty, though unlikely.\n    if not np.any(band_mask):\n        return 0.0, 0.0, 0.0, 0.0\n\n    # Exact normals on the grid for error calculation\n    r_dist = np.sqrt((grid_x - x0)**2 + (grid_y - y0)**2)\n    # Avoid division by zero at the circle center\n    safe_r = np.where(r_dist == 0, 1.0, r_dist)\n    n_exact_x = (grid_x - x0) / safe_r\n    n_exact_y = (grid_y - y0) / safe_r\n    \n    safety_factor = 1e-15\n\n    # VOF field from the given LS field\n    C = H_eps(phi, eps)\n    \n    # --- LS-based calculations ---\n    # Gradient of phi. np.gradient returns (dy, dx) for a (y, x) indexed grid.\n    grad_phi_y, grad_phi_x = np.gradient(phi, dx)\n    \n    # Normals from phi\n    norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n    n_phi_x = grad_phi_x / (norm_grad_phi + safety_factor)\n    n_phi_y = grad_phi_y / (norm_grad_phi + safety_factor)\n    \n    # Curvature from phi\n    # div(n) = d(nx)/dx + d(ny)/dy\n    grad_nx_y, grad_nx_x = np.gradient(n_phi_x, dx)\n    grad_ny_y, grad_ny_x = np.gradient(n_phi_y, dx)\n    kappa_phi = grad_nx_x + grad_ny_y\n    \n    # --- VOF-based calculations ---\n    # Gradient and normals from C\n    grad_C_y, grad_C_x = np.gradient(C, dx)\n    norm_grad_C = np.sqrt(grad_C_x**2 + grad_C_y**2)\n    n_C_x = grad_C_x / (norm_grad_C + safety_factor)\n    n_C_y = grad_C_y / (norm_grad_C + safety_factor)\n    \n    # --- Error Calculations ---\n    # L2 error of LS-normal\n    err_n_phi = np.sqrt(np.mean(((n_phi_x - n_exact_x)**2 + (n_phi_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of VOF-normal\n    err_n_C = np.sqrt(np.mean(((n_C_x - n_exact_x)**2 + (n_C_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of LS-curvature\n    err_k_phi = np.sqrt(np.mean(((kappa_phi - kappa_exact)**2)[band_mask]))\n    \n    # --- Eikonal Bias Calculation ---\n    # Bias is mean(| |grad(phi)| - 1 |) over the band\n    bias = np.mean(np.abs(norm_grad_phi - 1.0)[band_mask])\n    \n    return err_n_phi, err_n_C, err_k_phi, bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'params': {\n            'x0': 0.5, 'y0': 0.5, 'R': 0.3,\n            'alpha': 1.5, 'beta': 0.5,\n        },\n        'resolutions': [32, 64, 128]\n    }\n    \n    params = test_cases['params']\n    resolutions = test_cases['resolutions']\n    \n    # Derived parameters\n    params['gamma'] = 0.25 * params['beta']\n    params['kappa_exact'] = 1.0 / params['R']\n\n    errors_sd = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    errors_adv = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    \n    bias_sd_128, bias_adv_128 = 0.0, 0.0\n\n    for N in resolutions:\n        dx = 1.0 / N\n        grid_pts = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)\n        # grid_x varies along axis 1, grid_y along axis 0\n        grid_x, grid_y = np.meshgrid(grid_pts, grid_pts)\n\n        # Define analytical fields on the grid\n        phi_sd = np.sqrt((grid_x - params['x0'])**2 + (grid_y - params['y0'])**2) - params['R']\n        phi_adv = phi_sd * (1 + params['beta'] * grid_x) + params['gamma'] * phi_sd**2\n\n        # --- Analyze phi_sd ---\n        err_n_phi_sd, err_n_C_sd, err_k_phi_sd, bias_sd = analyze_field(\n            phi_sd, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_sd['n_phi'].append(err_n_phi_sd)\n        errors_sd['n_C'].append(err_n_C_sd)\n        errors_sd['k_phi'].append(err_k_phi_sd)\n\n        # --- Analyze phi_adv ---\n        err_n_phi_adv, err_n_C_adv, err_k_phi_adv, bias_adv = analyze_field(\n            phi_adv, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_adv['n_phi'].append(err_n_phi_adv)\n        errors_adv['n_C'].append(err_n_C_adv)\n        errors_adv['k_phi'].append(err_k_phi_adv)\n\n        # Store bias values for the finest grid\n        if N == 128:\n            bias_sd_128 = bias_sd\n            bias_adv_128 = bias_adv\n\n    # Post-process to calculate convergence orders\n    results = []\n    \n    # 1. phi_sd: LS-normal orders\n    results.append(get_order(errors_sd['n_phi'][0], errors_sd['n_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['n_phi'][1], errors_sd['n_phi'][2], 64, 128))\n\n    # 2. phi_sd: VOF-normal orders\n    results.append(get_order(errors_sd['n_C'][0], errors_sd['n_C'][1], 32, 64))\n    results.append(get_order(errors_sd['n_C'][1], errors_sd['n_C'][2], 64, 128))\n    \n    # 3. phi_sd: LS-curvature orders\n    results.append(get_order(errors_sd['k_phi'][0], errors_sd['k_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['k_phi'][1], errors_sd['k_phi'][2], 64, 128))\n\n    # 4. phi_adv: LS-normal orders\n    results.append(get_order(errors_adv['n_phi'][0], errors_adv['n_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['n_phi'][1], errors_adv['n_phi'][2], 64, 128))\n\n    # 5. phi_adv: VOF-normal orders\n    results.append(get_order(errors_adv['n_C'][0], errors_adv['n_C'][1], 32, 64))\n    results.append(get_order(errors_adv['n_C'][1], errors_adv['n_C'][2], 64, 128))\n\n    # 6. phi_adv: LS-curvature orders\n    results.append(get_order(errors_adv['k_phi'][0], errors_adv['k_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['k_phi'][1], errors_adv['k_phi'][2], 64, 128))\n\n    # 7. Bias metrics at N = 128\n    results.append(bias_sd_128)\n    results.append(bias_adv_128)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The accurate computation of interface curvature is paramount for simulations involving surface tension, a dominant force at small scales. Various algorithms exist, each with its own trade-offs in accuracy, robustness, and computational cost. This exercise challenges you to implement and compare two popular methods: a level-set based approach and a height-function method derived from volume-of-fluid data . Through a convergence study, you will gain practical insight into their relative performance and develop the skills to evaluate and select appropriate numerical schemes for your own research.",
            "id": "3305550",
            "problem": "You are asked to implement and compare two numerical curvature estimators for a smooth two-dimensional interface represented on a Cartesian grid: a height-function curvature based on column-wise integrals of a volume-of-fluid fraction and a level-set curvature based on the divergence of the normalized gradient of a scalar field. The interface is prescribed as a perturbed sinusoidal graph over a periodic domain, and all angles are to be treated in radians. No physical units are involved; all quantities are dimensionless.\n\nStarting point definitions and laws:\n- The interface is a graph given by $y=\\eta(x)$ over the interval $x\\in[0,L]$ with $y\\in[0,H]$. Assume $L0$ and $H0$ and periodicity in $x$.\n- A Volume-of-Fluid (VOF) fraction $F(x,y)$ is defined as the indicator of phase occupancy averaged over a control volume: specifically, $F=1$ if the cell volume is fully below the interface, $F=0$ if fully above, and intermediate values proportional to the area of the cell below the interface.\n- The height function $h(x)$ associated with column-wise integrals of $F$ is the column average of the fluid height beneath the interface and is defined by the discrete sum over rows in each column, $h_i=\\sum_j F_{i,j}\\,\\Delta y$, where $\\Delta y$ is the uniform grid spacing in $y$ and $F_{i,j}$ is the VOF fraction in cell $(i,j)$.\n- The geometric curvature of a graph $y=\\eta(x)$ is given by the formula $\\kappa(x)=-\\eta''(x)\\,\\big(1+(\\eta'(x))^2\\big)^{-3/2}$, derived from the Frenet–Serret formalism for plane curves.\n- A level-set field $\\phi(x,y)$ can be defined as $\\phi(x,y)=y-\\eta(x)$, which yields a unit normal $\\mathbf{n}=\\nabla\\phi/|\\nabla\\phi|$ and curvature $\\kappa_\\phi=\\nabla\\cdot\\mathbf{n}$.\n\nYour program must:\n1. Construct a two-dimensional uniform Cartesian grid with $N_x$ columns and $N_y$ rows over $[0,L]\\times[0,H]$ and impose periodic boundary conditions in the $x$-direction for all discrete derivatives used.\n2. Define a perturbed sinusoidal interface height\n   $$\\eta(x)=y_0+A\\sin(kx)+\\varepsilon\\sin(3kx),$$\n   where $k=2\\pi m/L$, $m\\in\\mathbb{Z}^+$, $A0$, $\\varepsilon\\ge 0$, and $y_0\\in(0,H)$ is a constant offset. The arguments of the sine functions are in radians.\n3. Compute the VOF fraction $F_{i,j}$ by integrating the indicator of being below the interface across the horizontal extent of each cell using a $4$-point Gauss–Legendre quadrature in $x$. For a cell with horizontal bounds $[x_i-\\Delta x/2,x_i+\\Delta x/2]$ and vertical bounds $[y_j-\\Delta y/2,y_j+\\Delta y/2]$, define for each quadrature point $x_q$ the vertical occupancy fraction $L(x_q)$ as\n   - $L(x_q)=0$ if $\\eta(x_q)\\le y_j-\\Delta y/2$,\n   - $L(x_q)=1$ if $\\eta(x_q)\\ge y_j+\\Delta y/2$,\n   - $L(x_q)=\\big(\\eta(x_q)-(y_j-\\Delta y/2)\\big)/\\Delta y$ otherwise.\n   Then approximate $F_{i,j}$ by the average of $L(x)$ across the cell width using the quadrature rule, yielding a value in $[0,1]$.\n4. Assemble the height function $h_i=\\sum_j F_{i,j}\\,\\Delta y$ for each column $i$, and compute the height-function curvature\n   $$\\kappa_{HF,i}=-\\frac{h''_i}{\\big(1+(h'_i)^2\\big)^{3/2}},$$\n   where discrete central differences with periodic boundary conditions are used for $h'_i$ and $h''_i$ in $x$.\n5. Define the level-set field $\\phi_{i,j}=y_j-\\eta(x_i)$, where $x_i$ and $y_j$ are cell-center coordinates. Compute $\\kappa_{\\phi}$ on the grid by\n   - computing discrete central differences $\\phi_x$ and $\\phi_y$,\n   - forming $\\mathbf{n}=\\nabla\\phi/|\\nabla\\phi|$ pointwise,\n   - and computing the discrete divergence $\\kappa_\\phi=\\partial n_x/\\partial x+\\partial n_y/\\partial y$ with central differences and periodic boundary conditions in $x$.\n   Then, for each column $i$, sample $\\kappa_\\phi$ at the interface height by linearly interpolating in the $y$-direction between the two nearest rows to $y=\\eta(x_i)$ to obtain an interface value $\\kappa_{\\phi,i}$.\n6. Compute the analytical curvature $\\kappa_{true,i}$ at each column center $x_i$ using\n   $$\\eta'(x)=Ak\\cos(kx)+3\\varepsilon k\\cos(3kx),\\quad \\eta''(x)=-Ak^2\\sin(kx)-9\\varepsilon k^2\\sin(3kx),$$\n   and\n   $$\\kappa_{true}(x)=-\\frac{\\eta''(x)}{\\big(1+(\\eta'(x))^2\\big)^{3/2}}.$$\n7. For each method, compute the root-mean-square error across all columns,\n   $$E_{HF}=\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\big(\\kappa_{HF,i}-\\kappa_{true,i}\\big)^2},\\quad E_{\\phi}=\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\big(\\kappa_{\\phi,i}-\\kappa_{true,i}\\big)^2}.$$\n8. Perform a convergence study by computing the errors on two grids: a base resolution $(N_x^{(0)},N_y^{(0)})$ and a refined resolution $(2N_x^{(0)},2N_y^{(0)})$. Estimate an observed order of accuracy $p$ for each method by\n   $$p_{HF}=\\frac{\\log\\big(E_{HF}(N_x^{(0)})/E_{HF}(2N_x^{(0)})\\big)}{\\log(2)},\\quad p_{\\phi}=\\frac{\\log\\big(E_{\\phi}(N_x^{(0)})/E_{\\phi}(2N_x^{(0)})\\big)}{\\log(2)}.$$\n\nTest suite:\nUse the following three parameter sets:\n- Test $1$: $(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.1,0.01,1,32,64)$.\n- Test $2$: $(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.02,0.0,1,24,48)$.\n- Test $3$: $(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.3,0.05,1,40,80)$.\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test, output the six floats in the following order:\n$[E_{HF}(N_x^{(0)}),E_{HF}(2N_x^{(0)}),p_{HF},E_{\\phi}(N_x^{(0)}),E_{\\phi}(2N_x^{(0)}),p_{\\phi}]$,\nand concatenate the three tests in sequence. Therefore, the final output line must have $18$ comma-separated floats inside a single pair of square brackets.",
            "solution": "The problem presents a well-posed and scientifically sound task in computational fluid dynamics, requiring the implementation and comparison of two distinct numerical methods for estimating the curvature of a two-dimensional interface. The problem provides all necessary definitions, equations, and parameters to proceed with a rigorous numerical solution. Thus, the problem is deemed valid. The solution is executed by following the enumerated steps in the problem description.\n\nThe core of the problem is to compute the curvature of a specified interface, $y = \\eta(x)$, using three approaches: an analytical formula, a height-function (HF) method based on a Volume-of-Fluid (VOF) field, and a level-set ($\\phi$) method.\n\nThe interface is given by the function $\\eta(x)=y_0+A\\sin(kx)+\\varepsilon\\sin(3kx)$ over a periodic domain $x\\in[0,L]$, where $k=2\\pi m/L$. The analytical curvature, serving as the ground truth, is derived from the standard formula for a plane curve $y=\\eta(x)$:\n$$ \\kappa_{true}(x) = -\\frac{\\eta''(x)}{\\left(1 + (\\eta'(x))^2\\right)^{3/2}} $$\nThe first and second derivatives of $\\eta(x)$ are:\n$$ \\eta'(x) = Ak\\cos(kx)+3\\varepsilon k\\cos(3kx) $$\n$$ \\eta''(x) = -Ak^2\\sin(kx)-9\\varepsilon k^2\\sin(3kx) $$\n\nThe numerical domain is a uniform Cartesian grid defined over $[0,L]\\times[0,H]$ with $N_x \\times N_y$ cells. The cell dimensions are $\\Delta x = L/N_x$ and $\\Delta y = H/N_y$. Cell centers are located at coordinates $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$ for $i=0, \\dots, N_x-1$ and $j=0, \\dots, N_y-1$.\n\n**1. Height-Function (HF) Curvature Estimation**\n\nThis method first reconstructs a a one-dimensional height function $h(x)$ from the two-dimensional VOF field $F(x,y)$ and then computes its curvature.\n\n**1a. VOF Field Calculation**\nThe VOF fraction $F_{i,j}$ in cell $(i,j)$ represents the fraction of the cell's volume occupied by the fluid (defined as the region $y  \\eta(x)$). Since the interface is smooth, a more accurate $F_{i,j}$ can be obtained by averaging the vertical fluid fraction over the cell's width. For a given horizontal position $x$, the vertical occupancy fraction $L(x)$ within a cell centered at $y_j$ is defined as:\n$$\nL(x) = \\begin{cases} \n0  \\text{if } \\eta(x) \\le y_j - \\Delta y/2 \\\\\n1  \\text{if } \\eta(x) \\ge y_j + \\Delta y/2 \\\\\n(\\eta(x) - (y_j - \\Delta y/2))/\\Delta y  \\text{otherwise}\n\\end{cases}\n$$\nThe VOF fraction $F_{i,j}$ is the average of $L(x)$ over the cell width $[x_i-\\Delta x/2, x_i+\\Delta x/2]$:\n$$ F_{i,j} = \\frac{1}{\\Delta x} \\int_{x_i-\\Delta x/2}^{x_i+\\Delta x/2} L(x) \\,dx $$\nThis integral is approximated using a $4$-point Gauss-Legendre quadrature. The quadrature rule approximates the integral on $[-1,1]$. After a change of variables $x = x_i + u \\cdot (\\Delta x/2)$, the integral becomes:\n$$ F_{i,j} \\approx \\frac{1}{\\Delta x} \\left( \\frac{\\Delta x}{2} \\sum_{q=1}^{4} w_q L(x_q) \\right) = \\frac{1}{2}\\sum_{q=1}^{4} w_q L(x_q) $$\nwhere $u_q$ and $w_q$ are the quadrature nodes and weights on $[-1,1]$, and $x_q = x_i + u_q \\cdot (\\Delta x/2)$ are the corresponding points in the cell.\n\n**1b. Height Function and Curvature**\nThe one-dimensional height function $h_i$ at each column $i$ is computed by summing the VOF contributions vertically:\n$$ h_i = \\sum_{j=0}^{N_y-1} F_{i,j} \\Delta y $$\nThe curvature of this discrete height function, $\\kappa_{HF,i}$, is then computed using the same formula as the analytical curvature, but with numerical derivatives. Second-order periodic central differences are used for the first and second derivatives, $h'_i$ and $h''_i$:\n$$ h'_i = \\frac{h_{i+1} - h_{i-1}}{2\\Delta x} $$\n$$ h''_i = \\frac{h_{i+1} - 2h_i + h_{i-1}}{(\\Delta x)^2} $$\nwhere indices are taken modulo $N_x$ to enforce periodicity. The final curvature is:\n$$ \\kappa_{HF,i} = -\\frac{h''_i}{\\left(1 + (h'_i)^2\\right)^{3/2}} $$\n\n**2. Level-Set ($\\phi$) Curvature Estimation**\n\nThis method uses a scalar field $\\phi$, whose zero-contour represents the interface. The curvature is computed from derivatives of this field.\n\n**2a. Level-Set Field and Derivatives**\nThe level-set field is defined at the cell centers as a signed distance function, $\\phi_{i,j} = y_j - \\eta(x_i)$. The gradient of this field, $\\nabla\\phi = (\\phi_x, \\phi_y)$, is required. These components are computed numerically. Since the domain is periodic in $x$, a periodic central difference is used for $\\phi_x$. For $\\phi_y$, standard central differences are used in the interior, with one-sided differences at the $y$-boundaries.\n$$ \\phi_{x,i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta x} \\quad (\\text{periodic in } i) $$\n$$ \\phi_{y,i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta y} \\quad (\\text{central for interior } j) $$\n\n**2b. Normal Vector and Curvature**\nThe unit normal vector to the interface is given by $\\mathbf{n} = \\nabla\\phi / |\\nabla\\phi|$. This is computed pointwise on the grid:\n$$ \\mathbf{n}_{i,j} = \\frac{(\\phi_{x,i,j}, \\phi_{y,i,j})}{\\sqrt{\\phi_{x,i,j}^2 + \\phi_{y,i,j}^2}} $$\nThe curvature is the divergence of the normal vector field, $\\kappa_\\phi = \\nabla \\cdot \\mathbf{n} = \\partial n_x/\\partial x + \\partial n_y/\\partial y$. The divergence is also computed using numerical differences, respecting the periodicity in $x$:\n$$ \\kappa_{\\phi,i,j} = \\frac{n_{x,i+1,j} - n_{x,i-1,j}}{2\\Delta x} + \\frac{n_{y,i,j+1} - n_{y,i,j-1}}{2\\Delta y} $$\n\n**2c. Interface Curvature Sampling**\nThe curvature $\\kappa_{\\phi,i,j}$ is defined on the entire grid. To obtain the curvature at the interface for each column $i$, we sample $\\kappa_{\\phi,i,j}$ at the interface height $y = \\eta(x_i)$. This is done via linear interpolation in the $y$-direction. For each column $i$, we find the grid row index $j$ such that $y_j \\le \\eta(x_i)  y_{j+1}$. The interpolated curvature $\\kappa_{\\phi,i}$ is then:\n$$ \\kappa_{\\phi,i} = (1-\\alpha)\\kappa_{\\phi,i,j} + \\alpha\\kappa_{\\phi,i,j+1}, \\quad \\text{where} \\quad \\alpha = \\frac{\\eta(x_i) - y_j}{\\Delta y} $$\n\n**3. Error Analysis and Convergence**\n\nFor each method, the root-mean-square (RMS) error is calculated against the analytical curvature $\\kappa_{true,i}$ computed at the column centers $x_i$:\n$$ E_{HF} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}(\\kappa_{HF,i} - \\kappa_{true,i})^2}, \\quad E_{\\phi} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}(\\kappa_{\\phi,i} - \\kappa_{true,i})^2} $$\nA convergence study is performed by computing these errors on a base grid with resolution $(N_x^{(0)}, N_y^{(0)})$ and a refined grid with resolution $(2N_x^{(0)}, 2N_y^{(0)})$. The observed order of accuracy, $p$, is estimated using the formula:\n$$ p = \\frac{\\log(E(N^{(0)}) / E(2N^{(0)}))}{\\log(2)} $$\nThis provides $p_{HF}$ and $p_{\\phi}$, which indicate how quickly the numerical error decreases with grid refinement. As the numerical schemes employed are predominantly second-order accurate, the expected value for $p$ is approximately $2$.\n\nThe implementation follows these steps for each test case provided in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n# No scipy needed.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # (L, H, y0, A, eps, m, Nx0, Ny0)\n    test_cases = [\n        (1.0, 1.0, 0.5, 0.1, 0.01, 1, 32, 64),\n        (1.0, 1.0, 0.5, 0.02, 0.0, 1, 24, 48),\n        (1.0, 1.0, 0.5, 0.3, 0.05, 1, 40, 80),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = solve_for_case(case)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in all_results)}]\")\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves for a single test case, performing the convergence study.\n    \"\"\"\n    L, H, y0, A, eps, m, Nx0, Ny0 = case_params\n\n    # Coarse grid computation\n    e_hf_0, e_phi_0 = run_simulation(L, H, y0, A, eps, m, Nx0, Ny0)\n\n    # Refined grid computation\n    Nx1, Ny1 = 2 * Nx0, 2 * Ny0\n    e_hf_1, e_phi_1 = run_simulation(L, H, y0, A, eps, m, Nx1, Ny1)\n\n    # Order of accuracy calculation\n    # A small epsilon is added to the denominator to avoid division by zero\n    # if an error happens to be exactly zero.\n    p_hf = np.log((e_hf_0 + 1e-30) / (e_hf_1 + 1e-30)) / np.log(2)\n    p_phi = np.log((e_phi_0 + 1e-30) / (e_phi_1 + 1e-30)) / np.log(2)\n\n    return [e_hf_0, e_hf_1, p_hf, e_phi_0, e_phi_1, p_phi]\n\ndef run_simulation(L, H, y0, A, eps, m, Nx, Ny):\n    \"\"\"\n    Performs the full numerical simulation for a given set of parameters and grid resolution.\n    \"\"\"\n    # 1. Grid and Analytical Interface Setup\n    dx, dy = L / Nx, H / Ny\n    x = np.linspace(dx / 2.0, L - dx / 2.0, Nx)\n    y = np.linspace(dy / 2.0, H - dy / 2.0, Ny)\n    xg, yg = np.meshgrid(x, y)\n\n    k = 2.0 * np.pi * m / L\n    eta = lambda t: y0 + A * np.sin(k * t) + eps * np.sin(3.0 * k * t)\n    eta_p = lambda t: A * k * np.cos(k * t) + 3.0 * eps * k * np.cos(3.0 * k * t)\n    eta_pp = lambda t: -A * k**2 * np.sin(k * t) - 9.0 * eps * k**2 * np.sin(3.0 * k * t)\n\n    eta_vals_at_x = eta(x)\n    kappa_true = -eta_pp(x) / (1.0 + eta_p(x)**2)**1.5\n\n    # 2. VOF Method\n    # 2a. VOF field F_ij calculation using 4-point Gauss-Legendre quadrature\n    gauss_nodes, gauss_weights = np.polynomial.legendre.leggauss(4)\n    x_quad_offsets = gauss_nodes * dx / 2.0\n    F = np.zeros((Ny, Nx))\n\n    for i in range(Nx):\n        y_lower_bounds = y - dy / 2.0\n        x_quad_points = x[i] + x_quad_offsets\n        eta_at_quad = eta(x_quad_points)\n        \n        for j in range(Ny):\n            L_vals = (eta_at_quad - y_lower_bounds[j]) / dy\n            L_vals = np.clip(L_vals, 0.0, 1.0)\n            F[j, i] = np.sum(gauss_weights * L_vals) / 2.0\n\n    # 2b. Height-function curvature\n    h = np.sum(F, axis=0) * dy\n    h_p = (np.roll(h, -1) - np.roll(h, 1)) / (2.0 * dx)\n    h_pp = (np.roll(h, -1) - 2.0 * h + np.roll(h, 1)) / (dx**2)\n    kappa_hf = -h_pp / (1.0 + h_p**2)**1.5\n\n    # 3. Level-Set Method\n    # 3a. Level-set field and its gradient\n    phi = yg - eta(xg)\n    \n    # Gradient in y (non-periodic) using numpy.gradient's standard handling\n    phi_y = np.gradient(phi, dy, axis=0, edge_order=2)\n    # Gradient in x (periodic) using central differences via numpy.roll\n    phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n\n    # 3b. Normal vector and its divergence (curvature)\n    grad_phi_norm = np.sqrt(phi_x**2 + phi_y**2)\n    grad_phi_norm = np.maximum(grad_phi_norm, 1e-12) # Avoid division by zero\n    nx = phi_x / grad_phi_norm\n    ny = phi_y / grad_phi_norm\n\n    # Divergence of n: d(nx)/dx (periodic) + d(ny)/dy (non-periodic)\n    dnx_dx = (np.roll(nx, -1, axis=1) - np.roll(nx, 1, axis=1)) / (2.0 * dx)\n    dny_dy = np.gradient(ny, dy, axis=0, edge_order=2)\n    kappa_phi_grid = dnx_dx + dny_dy\n    \n    # 3c. Interpolate grid-based curvature to the interface\n    kappa_phi = np.zeros(Nx)\n    for i in range(Nx):\n        eta_val = eta_vals_at_x[i]\n        # Find index of cell center just below the interface\n        # y_j = (j + 0.5) * dy  = j = eta_val/dy - 0.5\n        j_below_float = (eta_val / dy) - 0.5\n        j_below = int(np.floor(j_below_float))\n        \n        # Clamp index to be in a valid range for interpolation [0, Ny-2]\n        j_below = np.clip(j_below, 0, Ny - 2)\n        j_above = j_below + 1\n\n        # Linear interpolation weight alpha\n        alpha = (eta_val - y[j_below]) / dy\n        \n        # Interpolate curvature value\n        kappa_phi[i] = (1.0 - alpha) * kappa_phi_grid[j_below, i] + alpha * kappa_phi_grid[j_above, i]\n\n    # 4. Compute RMS errors\n    e_hf = np.sqrt(np.mean((kappa_hf - kappa_true)**2))\n    e_phi = np.sqrt(np.mean((kappa_phi - kappa_true)**2))\n\n    return e_hf, e_phi\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Resolving the sharp interface between two fluids requires high grid resolution, but maintaining this resolution throughout the domain is often computationally prohibitive. Adaptive Mesh Refinement (AMR) offers a powerful solution by concentrating grid cells only where they are needed most. In this advanced practice, you will design an AMR strategy that uses information from both the level-set and VOF fields to trigger refinement . The core challenge lies in implementing the prolongation and restriction operators that transfer data between grid levels while strictly conserving the fluid volume, a critical property for physically realistic simulations.",
            "id": "3305549",
            "problem": "You are given a two-dimensional, uniform, cell-centered finite-volume mesh on the square domain $[0,1]\\times[0,1]$ with $N\\times N$ cells of width $h=1/N$. Two phase indicators are defined: a level set function $\\phi(\\mathbf{x})$ that represents a signed distance to an interface (so ideally satisfies the Eikonal property $\\lvert \\nabla \\phi \\rvert = 1$) and a volume fraction function $F(\\mathbf{x})$ that represents the cell-averaged indicator of one of the phases. Consider a circular interface of radius $R$ centered at $(0.5,0.5)$, where the exact signed-distance field is $\\phi(x,y) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - R$. Define a regularized Heaviside function $H_\\varepsilon(\\zeta)$ with a smoothing half-thickness $\\varepsilon  0$ by\n$$\nH_\\varepsilon(\\zeta) = \n\\begin{cases}\n0,  \\zeta \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 + \\frac{\\zeta}{\\varepsilon} + \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\zeta}{\\varepsilon} \\right) \\right],  \\lvert \\zeta \\rvert  \\varepsilon,\\\\\n1,  \\zeta \\ge \\varepsilon.\n\\end{cases}\n$$\nLet the fluid be the region where $\\phi \\le 0$. Then define the coarse-grid volume fraction at each cell center as $F = H_\\varepsilon(-\\phi)$.\n\nAdaptive mesh refinement (AMR) is to be applied such that refinement is triggered near the interface and where the jump in volume fraction is steep. Specifically, a coarse cell at index $(i,j)$ is tagged for refinement if either $\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$ or $\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$, where $\\epsilon_\\phi  0$ and $\\tau_F  0$ are thresholds and $\\nabla F$ is approximated by centered finite differences on the coarse grid with appropriate one-sided differences at boundaries. A refinement ratio $r \\in \\mathbb{N}$ subdivides a tagged coarse cell into $r\\times r$ fine children.\n\nYou must:\n- Design and implement a tagging criterion that flags each coarse cell for refinement if and only if $\\lvert \\phi \\rvert \\le \\epsilon_\\phi$ or $\\lVert \\nabla F \\rVert \\ge \\tau_F$.\n- Specify and implement conservative restriction and prolongation operators for $F$:\n  - Restriction must be conservative in the finite-volume sense: the coarse cell average $F^{c}$ must equal the area-weighted average of its fine children $F^{f}$, so that the total “fluid volume” $\\sum F\\,h^2$ is preserved by transfer between levels.\n  - Prolongation must be conservative and bounded: reconstruct $F$ as a piecewise-linear function within each coarse cell using slope limiting to enforce monotonicity, compute provisional fine cell averages, and then apply a redistribution step that enforces exact conservation of the parent cell average while ensuring $0 \\le F \\le 1$ in all children.\n- Specify and implement a consistent interpolation for $\\phi$ when prolongating to the fine grid: use a piecewise-linear reconstruction with gradients estimated by centered differences and scaled so that the reconstructed $\\phi$ approximates a signed distance, i.e., $\\lvert \\nabla \\phi \\rvert \\approx 1$ in the refined region. Use arithmetic averaging for restriction of $\\phi$ back to the coarse grid.\n\nStart from the following fundamental base:\n- The definition of the level set function $\\phi$ as a signed distance implies the Eikonal property $\\lvert \\nabla \\phi \\rvert = 1$ almost everywhere away from kinks.\n- The definition of the volume fraction $F$ as a cell average of an indicator function implies that finite-volume conservation must hold under discretization and transfer between levels.\n- Slope limiting, such as the minmod limiter, is a well-tested mechanism to ensure monotonicity in piecewise-linear reconstructions and prevent new extrema.\n\nYour program must:\n- Construct coarse grid fields $\\phi$ and $F$ for the given circular interface and regularized Heaviside $H_\\varepsilon$ with smoothing half-thickness $\\varepsilon = \\eta_{\\mathrm{fac}}\\,h$, where $\\eta_{\\mathrm{fac}}$ is a given dimensionless factor.\n- Tag coarse cells for refinement using thresholds $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}\\,h$ and $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$, where $\\epsilon_{\\phi,\\mathrm{fac}}$ and $\\tau_{F,\\mathrm{fac}}$ are given dimensionless factors.\n- For each tagged cell, prolongate $F$ and $\\phi$ to an $r\\times r$ patch using the specified operators. Then restrict $F$ back to the coarse grid and compute the total fluid volume before and after this refine–restrict cycle to assess conservation.\n- Diagnose the consistency of the $\\phi$ interpolation by computing, on each refined patch, the discrete gradient $\\nabla \\phi$ on the fine grid using finite differences and measuring the maximum deviation of $\\lvert \\nabla \\phi \\rvert$ from $1$ over fine cells satisfying $\\lvert \\phi \\rvert \\le \\kappa$, where $\\kappa = 2\\,\\epsilon_\\phi$.\n\nTest Suite:\nUse the following three test cases, each given as a tuple $(N, R, \\eta_{\\mathrm{fac}}, \\epsilon_{\\phi,\\mathrm{fac}}, \\tau_{F,\\mathrm{fac}}, r)$:\n- Case $1$: $(32, 0.3, 2.0, 1.0, 0.6, 2)$.\n- Case $2$: $(16, 0.25, 1.0, 0.5, 0.8, 2)$.\n- Case $3$: $(24, 0.2, 3.0, 0.2, 0.2, 2)$.\n\nFor each case, your program must output three quantities:\n- The integer number of refined coarse cells $n_{\\mathrm{ref}}$.\n- The relative total fluid volume error $e_V = \\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert / \\max(V_{\\mathrm{before}}, 10^{-16})$ after a conservative prolongation–restriction cycle on $F$ across all refined cells.\n- The maximum fine-grid Eikonal deviation $e_\\phi = \\max_{\\lvert \\phi \\rvert \\le \\kappa} \\lvert \\lVert \\nabla \\phi \\rVert - 1 \\rvert$ over all fine children within refined patches, where $\\kappa = 2\\,\\epsilon_\\phi$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the three quantities for each test case in order, yielding a flat list of length $9$:\n$[n_{\\mathrm{ref},1}, e_{V,1}, e_{\\phi,1}, n_{\\mathrm{ref},2}, e_{V,2}, e_{\\phi,2}, n_{\\mathrm{ref},3}, e_{V,3}, e_{\\phi,3}]$.\nAll three $e_V$ and $e_\\phi$ values must be printed as floating-point numbers. No physical units are involved in this problem.",
            "solution": "The user-provided problem is a well-defined exercise in computational fluid dynamics, specifically concerning the implementation and verification of data transfer operators for adaptive mesh refinement (AMR) in a coupled level-set/volume-of-fluid context. The problem is scientifically grounded, self-contained, and algorithmically specified. I will proceed with a solution.\n\nThe solution requires designing and implementing algorithms for:\n1.  Initializing the coarse-grid level-set function, $\\phi$, and volume fraction function, $F$.\n2.  Tagging coarse cells for refinement based on specified criteria.\n3.  Prolongating $\\phi$ and $F$ from a coarse cell to a patch of fine cells.\n4.  Restricting $F$ from a fine patch back to a single coarse cell value.\n5.  Diagnosing the conservation of the $F$ operators and the consistency of the $\\phi$ operator.\n\nI will detail the implementation of each major component.\n\n### 1. Grid and Field Initialization\nThe computational domain is $[0,1] \\times [0,1]$. A uniform, cell-centered grid of $N \\times N$ cells is used. The cell width is $h=1/N$. The coordinates of the cell centers $(x_i, y_j)$ are given by:\n$$ x_i = (i + 1/2)h, \\quad y_j = (j + 1/2)h \\quad \\text{for } i,j = 0, \\dots, N-1 $$\nThe level-set field, $\\phi$, representing the signed distance to a circle of radius $R$ centered at $(0.5, 0.5)$, is computed at each cell center:\n$$ \\phi_{i,j} = \\sqrt{(x_i - 0.5)^2 + (y_j - 0.5)^2} - R $$\nThe volume fraction field, $F$, is derived from $\\phi$ using the provided regularized Heaviside function, $H_\\varepsilon(\\zeta)$, with a smoothing half-thickness $\\varepsilon = \\eta_{\\mathrm{fac}}h$. The relation is $F = H_\\varepsilon(-\\phi)$:\n$$\nF_{i,j} = H_\\varepsilon(-\\phi_{i,j}) = \n\\begin{cases}\n0,  -\\phi_{i,j} \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 - \\frac{\\phi_{i,j}}{\\varepsilon} - \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\phi_{i,j}}{\\varepsilon} \\right) \\right],  \\lvert \\phi_{i,j} \\rvert  \\varepsilon,\\\\\n1,  -\\phi_{i,j} \\ge \\varepsilon.\n\\end{cases}\n$$\n\n### 2. Cell Tagging for Refinement\nA coarse cell at index $(i,j)$ is flagged for refinement if it satisfies either of two conditions:\n1.  **Interface Proximity**: The cell center is close to the interface, $\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$, where the threshold is $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}h$.\n2.  **Steep Volume Fraction**: The volume fraction gradient is large, $\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$, where the threshold is $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$.\n\nThe gradient of the volume fraction, $\\nabla F = (\\partial_x F, \\partial_y F)$, is approximated using second-order centered finite differences for interior cells and first-order one-sided differences at the domain boundaries. The norm $\\lVert \\nabla F \\rVert_{i,j}$ is the standard Euclidean norm $\\sqrt{(\\partial_x F)_{i,j}^2 + (\\partial_y F)_{i,j}^2}$.\n\n### 3. Prolongation and Restriction Operators\n\n#### 3.1. Volume Fraction, $F$\nThe data transfer operators for $F$ must be conservative to preserve the total fluid volume.\n\n**Prolongation (Coarse-to-Fine)**:\nThe goal is to generate $r \\times r$ fine-cell values $F^f_k$ from a single coarse-cell value $F^c$ such that conservation ($\\sum_k F^f_k = r^2 F^c$) and boundedness ($0 \\le F^f_k \\le 1$) are achieved. This is done via a piecewise-linear reconstruction with slope limiting, followed by a redistribution step.\n\n1.  **Slope Limiting**: For each coarse cell $(i,j)$, we compute limited slopes $(\\partial_x F)_{lim}$, $(\\partial_y F)_{lim}$. We use the minmod limiter, which is a standard choice for enforcing monotonicity. For the x-direction:\n    $$ (\\partial_x F)_{lim} = \\text{minmod}\\left( \\frac{F_{i+1,j} - F_{i,j}}{h}, \\frac{F_{i,j} - F_{i-1,j}}{h} \\right) $$\n    where $\\text{minmod}(a,b) = \\frac{1}{2}(\\text{sgn}(a)+\\text{sgn}(b))\\min(\\lvert a \\rvert, \\lvert b \\rvert)$. A similar expression holds for the y-direction. At boundaries, slopes are set to zero.\n\n2.  **Reconstruction**: Provisional fine-cell values $\\tilde{F}^f_k$ are computed by evaluating the linear reconstruction at the fine-cell centers $(\\mathbf{x}^f_k - \\mathbf{x}^c)$:\n    $$ \\tilde{F}^f_k = F^c + (\\nabla F)_{lim} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\n\n3.  **Redistribution**: The provisional values $\\tilde{F}^f_k$ are adjusted to satisfy conservation and bounds. An iterative procedure is employed:\n    a. First, enforce conservation: $\\tilde{F}^f_k \\leftarrow \\tilde{F}^f_k + (F^c - \\text{mean}(\\tilde{F}^f))$.\n    b. Iteratively correct for bound violations. In each iteration, values are clipped to $[0,1]$. The total mass change due to clipping is calculated and redistributed uniformly among non-saturated cells (those with values strictly between $0$ and $1$). This process is repeated for a fixed number of iterations or until convergence. This ensures the final fine-cell values $F^f_k$ are bounded while their mean is very close to $F^c$.\n\n**Restriction (Fine-to-Coarse)**:\nThis operation is simple averaging, which is consistent with the finite-volume definition of conservation:\n$$ F^c = \\frac{1}{r^2} \\sum_{k=1}^{r^2} F^f_k $$\n\n#### 3.2. Level Set, $\\phi$\nThe operators for $\\phi$ must be consistent, aiming to preserve the signed-distance property $|\\nabla\\phi|=1$.\n\n**Prolongation (Coarse-to-Fine)**:\nSimilar to $F$, we use a piecewise-linear reconstruction.\n1.  **Gradient Estimation**: The coarse-grid gradient $\\nabla \\phi^c$ is computed using centered differences.\n2.  **Normalization**: To enforce the Eikonal property, the gradient is normalized: $\\mathbf{g} = \\nabla \\phi^c / \\lvert \\nabla \\phi^c \\rvert$. If $\\lvert \\nabla \\phi^c \\rvert = 0$, $\\mathbf{g}$ is set to zero.\n3.  **Reconstruction**: Fine-cell values are computed as:\n    $$ \\phi^f_k = \\phi^c + \\mathbf{g} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\nNo redistribution is needed for $\\phi$.\n\n**Restriction (Fine-to-Coarse)**:\nThis is simple arithmetic averaging, as specified: $\\phi^c = \\frac{1}{r^2} \\sum_k \\phi^f_k$.\n\n### 4. Diagnostic Calculations\n\n**Volume Conservation Error, $e_V$**:\nThe total fluid volume is $V = \\sum_{i,j} F_{i,j} h^2$. We compute the volume $V_{\\mathrm{before}}$ using the initial coarse-grid $F$. Then, a new grid $F_{\\mathrm{after}}$ is created where each tagged cell's value is replaced by the result of a prolongation-restriction cycle: $F_{\\mathrm{after}, i,j} = \\text{restrict}(\\text{prolongate}(F_{i,j}))$. The volume $V_{\\mathrm{after}}$ is computed from this new grid. The relative error is:\n$$ e_V = \\frac{\\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert}{\\max(V_{\\mathrm{before}}, 10^{-16})} $$\nDue to the careful implementation of the conservative operators, this error is expected to be close to machine precision.\n\n**Eikonal Deviation, $e_\\phi$**:\nFor each fine patch generated from a tagged cell, we compute the gradient of the prolongated field, $\\nabla \\phi^f$, using centered differences on the fine grid. We then find the maximum deviation of its magnitude from $1$ over all fine cells that are near the interface ($\\lvert \\phi^f_k \\rvert \\le \\kappa = 2\\epsilon_\\phi$):\n$$ e_\\phi = \\max_{\\text{all fine patches}} \\left( \\max_{k \\text{ s.t. } \\lvert\\phi^f_k\\rvert \\le \\kappa} \\lvert \\lvert \\nabla \\phi^f_k \\rvert - 1 \\rvert \\right) $$\n\nThese procedures form a complete plan for solving the problem and generating the required outputs for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is available but not used in this solution.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n\n    def H_eps(zeta, eps):\n        \"\"\"Regularized Heaviside function.\"\"\"\n        val = np.zeros_like(zeta, dtype=float)\n        # To avoid division by zero if eps is zero, though problem constraints prevent this.\n        if eps == 0:\n            val[zeta  0] = 1.0\n            return val\n            \n        mask_mid = np.abs(zeta)  eps\n        zeta_mid = zeta[mask_mid]\n        val[mask_mid] = 0.5 * (1.0 + zeta_mid / eps + (1.0 / np.pi) * np.sin(np.pi * zeta_mid / eps))\n        val[zeta = eps] = 1.0\n        return val\n\n    def minmod(a, b):\n        \"\"\"Minmod limiter function.\"\"\"\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    def compute_limited_slopes(F, h):\n        \"\"\"Computes minmod-limited slopes for a 2D field F.\"\"\"\n        # X-direction slopes\n        dF_fwd_x = (np.roll(F, -1, axis=1) - F) / h\n        dF_bwd_x = (F - np.roll(F, 1, axis=1)) / h\n        sx = minmod(dF_fwd_x, dF_bwd_x)\n        sx[:, 0] = 0.0\n        sx[:, -1] = 0.0\n\n        # Y-direction slopes\n        dF_fwd_y = (np.roll(F, -1, axis=0) - F) / h\n        dF_bwd_y = (F - np.roll(F, 1, axis=0)) / h\n        sy = minmod(dF_fwd_y, dF_bwd_y)\n        sy[0, :] = 0.0\n        sy[-1, :] = 0.0\n        \n        return sx, sy\n\n    def prolongate_F(F_c, sx, sy, h, r):\n        \"\"\"Prolongates F to a fine patch with conservation and bounds.\"\"\"\n        h_f = h / r\n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n        \n        F_prov = F_c + sx * rel_x + sy * rel_y\n        \n        F_f = F_prov\n        # Enforce conservation initially\n        F_f += F_c - np.mean(F_f)\n        \n        for _ in range(20): # Iterative redistribution\n            if np.all((F_f = 0)  (F_f = 1)):\n                break\n            \n            F_clipped = np.clip(F_f, 0, 1)\n            error_sum = F_c * (r**2) - np.sum(F_clipped)\n            \n            receivers_mask = (F_clipped  1e-12)  (F_clipped  1 - 1e-12)\n            num_receivers = np.sum(receivers_mask)\n\n            if num_receivers == 0:\n                F_f = F_clipped\n                break\n            \n            delta = error_sum / num_receivers\n            F_f = F_clipped\n            F_f[receivers_mask] += delta\n        \n        # Final clip to strictly enforce bounds after iterations\n        return np.clip(F_f, 0, 1)\n\n\n    def prolongate_phi(phi_c, gx, gy, h, r):\n        \"\"\"Prolongates phi with normalized gradients.\"\"\"\n        h_f = h / r\n        norm = np.sqrt(gx**2 + gy**2)\n        if norm  1e-15:\n            gx_norm, gy_norm = gx / norm, gy / norm\n        else:\n            gx_norm, gy_norm = 0.0, 0.0\n            \n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n\n        return phi_c + gx_norm * rel_x + gy_norm * rel_y\n\n    test_cases = [\n        (32, 0.3, 2.0, 1.0, 0.6, 2),\n        (16, 0.25, 1.0, 0.5, 0.8, 2),\n        (24, 0.2, 3.0, 0.2, 0.2, 2)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, eta_fac, eps_phi_fac, tau_F_fac, r = case\n\n        # 1. Setup coarse grid and fields\n        h = 1.0 / N\n        eps = eta_fac * h\n        grid_coords = np.linspace(h / 2.0, 1.0 - h / 2.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords)\n        \n        phi_coarse = np.sqrt((xx - 0.5)**2 + (yy - 0.5)**2) - R\n        F_coarse = H_eps(-phi_coarse, eps)\n        \n        # 2. Tag cells for refinement\n        eps_phi = eps_phi_fac * h\n        tau_F = tau_F_fac / eps if eps  0 else float('inf')\n        \n        grad_F_y, grad_F_x = np.gradient(F_coarse, h)\n        grad_F_norm = np.sqrt(grad_F_x**2 + grad_F_y**2)\n        \n        tags = (np.abs(phi_coarse) = eps_phi) | (grad_F_norm = tau_F)\n        n_ref = np.sum(tags)\n        \n        # 3. Prepare for prolongation/restriction cycle\n        V_before = np.sum(F_coarse) * h**2\n        F_after = F_coarse.copy()\n        all_eikonal_errors = []\n        \n        # Pre-compute gradients for all cells\n        sx_F, sy_F = compute_limited_slopes(F_coarse, h)\n        grad_phi_y, grad_phi_x = np.gradient(phi_coarse, h)\n        \n        tagged_indices = np.argwhere(tags)\n        for i, j in tagged_indices:\n            # 4. Prolongation-Restriction for F\n            F_cell = F_coarse[i, j]\n            sx, sy = sx_F[i, j], sy_F[i, j]\n            F_fine_patch = prolongate_F(F_cell, sx, sy, h, r)\n            \n            # Conservative restriction is simple averaging\n            F_restricted = np.mean(F_fine_patch)\n            F_after[i, j] = F_restricted\n\n            # 5. Prolongation and Diagnosis for phi\n            phi_cell = phi_coarse[i, j]\n            gx, gy = grad_phi_x[i, j], grad_phi_y[i, j]\n            phi_fine_patch = prolongate_phi(phi_cell, gx, gy, h, r)\n\n            h_fine = h / r\n            grad_phi_fine_y, grad_phi_fine_x = np.gradient(phi_fine_patch, h_fine)\n            grad_norm_fine = np.sqrt(grad_phi_fine_x**2 + grad_phi_fine_y**2)\n            \n            kappa = 2.0 * eps_phi\n            mask = np.abs(phi_fine_patch) = kappa\n            if np.any(mask):\n                errors = np.abs(grad_norm_fine[mask] - 1.0)\n                all_eikonal_errors.append(np.max(errors))\n\n        # 6. Finalize diagnostics\n        V_after = np.sum(F_after) * h**2\n        e_V = np.abs(V_after - V_before) / max(V_before, 1e-16)\n\n        if not all_eikonal_errors:\n            e_phi = 0.0\n        else:\n            e_phi = np.max(all_eikonal_errors)\n\n        results.extend([n_ref, e_V, e_phi])\n    \n    # Format and print the final flat list of results\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}