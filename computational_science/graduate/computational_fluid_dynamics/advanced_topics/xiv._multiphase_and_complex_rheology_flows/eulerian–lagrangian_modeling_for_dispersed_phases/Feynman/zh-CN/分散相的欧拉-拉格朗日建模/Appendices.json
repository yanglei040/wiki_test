{
    "hands_on_practices": [
        {
            "introduction": "掌握单个颗粒在流体中的运动是欧拉-拉格朗日建模的第一步。这个练习将引导您从牛顿第二定律出发，推导在重力作用下一个重颗粒的瞬态速度，这是一个用于验证更复杂模拟代码的基本解析解。通过这个过程 ，您将加深对颗粒弛豫时间等基本物理概念的理解。",
            "id": "3315838",
            "problem": "在拉格朗日框架下，追踪一个直径为 $d$、密度为 $\\rho_p$ 的单个刚性球形颗粒在重力作用下沉降的过程。该颗粒位于密度为 $\\rho_f$、动力粘度为 $\\mu$ 的静止、无限牛顿流体中。颗粒在时间 $t=0$ 时从静止状态释放，沿垂直轴的速度 $v_p(0)=0$，并规定向下为正方向。假设颗粒足够重且足够小，使其周围的流动保持在斯托克斯流态（Stokes regime），并且唯一的流体动力是线性斯托克斯阻力。忽略附加质量、历史力（Basset力）、升力和 Faxén 修正。重力和浮力以常规方式作用。使用以下内容作为基本依据：颗粒的牛顿第二定律和斯托克斯阻力定律 $F_D=3\\pi\\mu d\\,(v_p-u)$，其中 $u$ 是局部流体速度，此处 $u=0$。\n\n从第一性原理出发，推导当 $t\\ge 0$ 时瞬态颗粒速度 $v_p(t)$ 的一个显式闭合形式表达式。然后，确定最小时间 $t_{0.05}$，使得颗粒速度与其终端速度的差值在 $5\\%$ 以内，即 $|v_t - v_p(t_{0.05})| = 0.05\\,v_t$，其中 $v_t$ 是从您的推导中得出的终端速度。您的结果应完全用 $\\rho_p$、$\\rho_f$、$\\mu$、$d$、$g$ 和 $t$ 来表示。将时间尺度以秒表示。\n\n请以包含两个闭合形式表达式 $\\big[v_p(t),\\,t_{0.05}\\big]$ 的单行矩阵形式提供您的最终答案。无需进行数值计算。",
            "solution": "在进行求解之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取已知条件\n-   **颗粒性质**：单个、刚性、球形，直径 $d$，密度 $\\rho_p$。\n-   **流体性质**：静止、无限、牛顿流体，密度 $\\rho_f$，动力粘度 $\\mu$。\n-   **初始条件**：在 $t=0$ 时，$v_p(0) = 0$。\n-   **坐标系**：沿垂直轴向下为正方向。\n-   **物理模型**：\n    -   框架：颗粒的拉格朗日追踪。\n    -   控制定律：牛顿第二定律。\n    -   包含的力：重力、浮力、斯托克斯阻力。\n    -   斯托克斯阻力定律：$F_D=3\\pi\\mu d\\,(v_p-u)$。\n    -   流体速度：$u=0$。\n    -   忽略的效应：附加质量、历史力（Basset力）、升力、Faxén修正。\n-   **目标**：\n    1.  推导当 $t \\ge 0$ 时的瞬态颗粒速度 $v_p(t)$。\n    2.  确定时间 $t_{0.05}$，使得 $|v_t - v_p(t_{0.05})| = 0.05\\,v_t$，其中 $v_t$ 是终端速度。\n-   **输出要求**：结果用 $\\rho_p$、$\\rho_f$、$\\mu$、$d$、$g$ 和 $t$ 表示。最终答案以单行矩阵 $\\begin{pmatrix} v_p(t)  t_{0.05} \\end{pmatrix}$ 形式提供。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n-   **科学上成立**：是。该问题描述了低雷诺数下颗粒沉降的经典设置，基于牛顿第二定律和斯托克斯阻力模型。这是流体力学中一个基本且成熟的课题。\n-   **适定的**：是。该问题描述了一个具有指定初始条件的一阶线性常微分方程。这种结构保证了唯一且稳定解的存在。\n-   **客观的**：是。问题使用精确、定量且无歧义的科学语言陈述。\n-   **缺陷分析**：\n    1.  **科学上不健全**：无。该物理模型是针对特定流态的标准、有效简化。\n    2.  **不可形式化/不相关**：该问题可直接形式化为一个可解的微分方程，并且与计算流体力学中的欧拉-拉格朗日建模高度相关。\n    3.  **设置不完整/矛盾**：否。所有必要的参数（$\\rho_p$、$\\rho_f$、$\\mu$、$d$、$g$）和条件（$v_p(0)=0$）都已提供。\n    4.  **不切实际/不可行**：否。这些条件对于广泛的现实世界场景（如细颗粒物的沉降）是物理上合理的。\n    5.  **不适定的**：否。如前所述，该问题是适定的。\n    6.  **平凡/同义反复**：否。虽然是教科书式的问题，但它要求从第一性原理进行完整推导，展示了力学和微分方程方面的核心能力。\n    7.  **超出科学可验证性范围**：否。该解在数学上是可推导的，在物理上是可验证的。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n### 求解推导\n颗粒的运动由牛顿第二定律决定，该定律指出，作用在颗粒上的合力等于其质量乘以其加速度。\n$$m_p \\frac{dv_p}{dt} = \\sum F$$\n颗粒是球形的，直径为 $d$。其体积为 $V_p = \\frac{1}{6}\\pi d^3$，其质量为 $m_p = \\rho_p V_p = \\frac{1}{6}\\pi d^3 \\rho_p$。作用在颗粒上沿垂直方向（向下为正）的力有重力、浮力和阻力。\n\n1.  **重力 ($F_g$)**：向下作用（正）。\n    $$F_g = m_p g = \\frac{1}{6}\\pi d^3 \\rho_p g$$\n\n2.  **浮力 ($F_b$)**：向上作用（负），等于排开流体的重量。\n    $$F_b = -V_p \\rho_f g = -\\frac{1}{6}\\pi d^3 \\rho_f g$$\n\n3.  **斯托克斯阻力 ($F_D$)**：向上作用（负），因为它与颗粒的向下运动相反。问题指定了 $F_D = 3\\pi\\mu d (v_p-u)$ 的形式。由于流体是静止的（$u=0$），与速度 $v_p$ 相反的阻力为：\n    $$F_D = -3\\pi\\mu d v_p$$\n\n将所有力相加，得到运动方程：\n$$m_p \\frac{dv_p}{dt} = F_g + F_b + F_D$$\n$$\\frac{1}{6}\\pi d^3 \\rho_p \\frac{dv_p}{dt} = \\frac{1}{6}\\pi d^3 \\rho_p g - \\frac{1}{6}\\pi d^3 \\rho_f g - 3\\pi\\mu d v_p$$\n合并项：\n$$\\frac{1}{6}\\pi d^3 \\rho_p \\frac{dv_p}{dt} = \\frac{1}{6}\\pi d^3 (\\rho_p - \\rho_f)g - 3\\pi\\mu d v_p$$\n为简化起见，我们分离出导数项 $\\frac{dv_p}{dt}$：\n$$\\frac{dv_p}{dt} = \\frac{\\frac{1}{6}\\pi d^3 (\\rho_p - \\rho_f)g}{\\frac{1}{6}\\pi d^3 \\rho_p} - \\frac{3\\pi\\mu d}{\\frac{1}{6}\\pi d^3 \\rho_p} v_p$$\n$$\\frac{dv_p}{dt} = \\frac{(\\rho_p - \\rho_f)g}{\\rho_p} - \\frac{18\\mu}{d^2 \\rho_p} v_p$$\n这是一个一阶线性常微分方程。我们可以定义两个重要参数。首先，当加速度为零（$\\frac{dv_p}{dt}=0$）时，达到终端速度 $v_t$。\n$$0 = \\frac{(\\rho_p - \\rho_f)g}{\\rho_p} - \\frac{18\\mu}{d^2 \\rho_p} v_t$$\n求解 $v_t$：\n$$v_t = \\frac{(\\rho_p - \\rho_f)g}{\\rho_p} \\cdot \\frac{d^2 \\rho_p}{18\\mu} = \\frac{g d^2 (\\rho_p - \\rho_f)}{18\\mu}$$\n这是斯托克斯沉降速度。我们假设 $\\rho_p > \\rho_f$ 以便发生沉降，使得 $v_t>0$。\n\n其次，我们定义颗粒动量弛豫时间 $\\tau_p$，它是 $v_p$ 系数的倒数：\n$$\\tau_p = \\frac{d^2 \\rho_p}{18\\mu}$$\n运动方程现在可以简洁地用 $v_t$ 和 $\\tau_p$ 重写：\n$$\\frac{dv_p}{dt} = \\frac{v_t}{\\tau_p} - \\frac{1}{\\tau_p}v_p = \\frac{1}{\\tau_p}(v_t - v_p)$$\n这是一个可分离的微分方程：\n$$\\frac{dv_p}{v_t - v_p} = \\frac{dt}{\\tau_p}$$\n我们对两边从初始状态（$t=0, v_p=0$）到一般状态（$t, v_p(t)$）进行积分：\n$$\\int_0^{v_p(t)} \\frac{dv'}{v_t - v'} = \\int_0^t \\frac{dt'}{\\tau_p}$$\n$$\\left[-\\ln(v_t - v')\\right]_0^{v_p(t)} = \\frac{t}{\\tau_p}$$\n$$-\\ln(v_t - v_p(t)) + \\ln(v_t - 0) = \\frac{t}{\\tau_p}$$\n$$\\ln\\left(\\frac{v_t}{v_t - v_p(t)}\\right) = \\frac{t}{\\tau_p}$$\n对两边取指数：\n$$\\frac{v_t}{v_t - v_p(t)} = \\exp\\left(\\frac{t}{\\tau_p}\\right)$$\n重新整理以求解 $v_p(t)$：\n$$v_t - v_p(t) = v_t \\exp\\left(-\\frac{t}{\\tau_p}\\right)$$\n$$v_p(t) = v_t \\left(1 - \\exp\\left(-\\frac{t}{\\tau_p}\\right)\\right)$$\n代入 $v_t$ 和 $\\tau_p$ 的完整表达式，得到答案的第一部分：\n$$v_p(t) = \\frac{g d^2 (\\rho_p - \\rho_f)}{18\\mu} \\left(1 - \\exp\\left(-\\frac{18\\mu t}{d^2 \\rho_p}\\right)\\right)$$\n接下来，我们求出颗粒速度与其终端速度相差在 $5\\%$ 以内的时间 $t_{0.05}$。条件是 $|v_t - v_p(t_{0.05})| = 0.05 v_t$。由于 $v_p(t)$ 从下方趋近于 $v_t$（$v_p(t) \\le v_t$），我们可以去掉绝对值：\n$$v_t - v_p(t_{0.05}) = 0.05 v_t$$\n这可以简化为 $v_p(t_{0.05}) = 0.95 v_t$。使用我们的瞬态解 $v_p(t)$：\n$$v_t \\left(1 - \\exp\\left(-\\frac{t_{0.05}}{\\tau_p}\\right)\\right) = 0.95 v_t$$\n假设 $v_t \\neq 0$，我们除以 $v_t$：\n$$1 - \\exp\\left(-\\frac{t_{0.05}}{\\tau_p}\\right) = 0.95$$\n$$\\exp\\left(-\\frac{t_{0.05}}{\\tau_p}\\right) = 1 - 0.95 = 0.05$$\n对两边取自然对数：\n$$-\\frac{t_{0.05}}{\\tau_p} = \\ln(0.05)$$\n$$t_{0.05} = -\\tau_p \\ln(0.05) = \\tau_p \\ln\\left(\\frac{1}{0.05}\\right) = \\tau_p \\ln(20)$$\n代入 $\\tau_p = \\frac{d^2 \\rho_p}{18\\mu}$ 的表达式：\n$$t_{0.05} = \\frac{d^2 \\rho_p \\ln(20)}{18\\mu}$$\n该表达式的单位是时间，这与提示一致。\n\n最终答案要求一个包含两个推导表达式的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{g d^2 (\\rho_p - \\rho_f)}{18\\mu} \\left(1 - \\exp\\left(-\\frac{18\\mu t}{d^2 \\rho_p}\\right)\\right)  \\frac{d^2 \\rho_p \\ln(20)}{18\\mu}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了单个颗粒的行为之后，下一个挑战是如何在欧拉网格上表示大量颗粒组成的“颗粒云”。这个实践  要求您实现并比较不同的映射方案，用于将拉格朗日框架下的颗粒信息“投放”到欧拉网格上。您将通过量化守恒误差和数值扩散，深入理解这些方案的优缺点，这是粒子-网格方法中的核心问题。",
            "id": "3315881",
            "problem": "考虑一个长度为 $L$ 的一维周期性区域，其中包含 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀欧拉网格单元，其中心位于 $x_i = (i + \\tfrac{1}{2})\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。一个离散相通过拉格朗日方法表示为 $M$ 个粒子，它们位于位置 $x_p \\in [0,L)$，并具有代表粒子数量的权重 $w_p \\ge 0$。目标是将拉格朗日粒子映射到一个欧拉网格单元平均数密度场 $\\rho_i$，该映射方式应是守恒的，并能最小化粒子数密度的数值扩散。粒子数守恒意味着沉积密度的离散积分等于总粒子数，即 $\\sum_{i=0}^{N-1} \\rho_i \\Delta x = \\sum_{p=1}^{M} w_p$。数值扩散可以通过沉积后场的二阶中心矩（方差）相对于粒子分布的增加量来量化。\n\n从以下基本出发点开始：\n- 粒子位置的牛顿运动学，$v = dx/dt$，此处我们关注静态沉积（映射期间无粒子运动）。\n- 粒子数守恒表示为 $\\int_0^L \\rho(x)\\,dx = \\sum_{p=1}^M w_p$。\n- 粒子数密度表示为 Dirac δ 分布之和，$\\rho(x) = \\sum_{p=1}^M w_p \\delta(x - x_p)$，及其基于网格的近似，即用一个归一化的分配核函数替换 $\\delta$。\n\n定义一系列粒子到网格的沉积算子，通过下式将粒子映射到离散场：\n$$\n\\rho_i = \\frac{1}{\\Delta x} \\sum_{p=1}^M w_p\\, \\mathcal{W}(x_p - x_i),\n$$\n其中 $\\mathcal{W}$ 是一个紧支集、归一化的分配核函数，它在网格上满足离散单位分解：\n$$\n\\sum_{i=0}^{N-1} \\mathcal{W}(x_p - x_i) = 1 \\quad \\text{对于所有粒子位置 } x_p,\n$$\n并采用周期性边界条件。\n\n实现并比较以下三种分配方案：\n1. 最近网格点 (Nearest-Grid-Point, NGP)：将每个粒子完全分配给其最近的网格单元中心。这对应于一个单位质量、支撑集为一个网格单元的零阶 B 样条核函数。\n2. 网格内云 (Cloud-In-Cell, CIC)：使用一维的一阶帽函数，将每个粒子分配到两个最近的网格单元中心之间。这对应于一个单位质量、支撑集为两个网格单元的一阶 B 样条核函数。\n3. 三次 B 样条 (Cubic B-spline)：使用三阶 B 样条核函数，其支撑集为四个网格单元，分段定义如下：\n$$\n\\phi(u) =\n\\begin{cases}\n\\frac{4 - 6u^2 + 3u^3}{6},  0 \\le u  1, \\\\\n\\frac{(2 - u)^3}{6},  1 \\le u  2, \\\\\n0,  u \\ge 2,\n\\end{cases}\n$$\n其中 $u$ 是粒子到网格单元中心的距离（以 $\\Delta x$ 为单位），通过对四个最近的中心求和来强制实现周期性离散单位分解。\n\n为量化数值扩散，使用周期性区域上的二阶中心矩（方差）。设粒子总数为 $N_{\\text{tot}} = \\sum_{p=1}^{M} w_p$。通过将位置映射到角度 $\\theta_p = 2\\pi x_p / L$，计算复数均值 $z = \\left(\\sum_p w_p e^{i \\theta_p}\\right)/N_{\\text{tot}}$，取 $\\bar{\\theta} = \\arg(z)$，并设置 $\\mu = (\\bar{\\theta} \\bmod 2\\pi)\\,L/(2\\pi)$，来定义环形平均位置 $\\mu \\in [0,L)$。定义最小周期性差值 $\\mathrm{wrap}_L(d) = d - L \\,\\mathrm{round}(d/L)$，使得 $\\mathrm{wrap}_L(d) \\in [-L/2,L/2)$。然后计算粒子二阶矩\n$$\n\\sigma^2_{\\text{part}} = \\frac{1}{N_{\\text{tot}}}\\sum_{p=1}^{M} w_p\\, \\mathrm{wrap}_L(x_p - \\mu)^2,\n$$\n以及使用相同 $\\mu$ 计算沉积场 $\\rho_i$ 的网格二阶矩\n$$\n\\sigma^2_{\\text{grid}} = \\frac{1}{N_{\\text{tot}}}\\sum_{i=0}^{N-1} \\rho_i\\, \\mathrm{wrap}_L(x_i - \\mu)^2 \\, \\Delta x.\n$$\n将一个方案的数值扩散定义为方差的增量，$\\Delta \\sigma^2 = \\sigma^2_{\\text{grid}} - \\sigma^2_{\\text{part}}$。\n\n任务：\n- 在一维周期性区域中实现上述三种沉积方案。\n- 确保守恒性，即 $\\sum_i \\rho_i \\Delta x = \\sum_p w_p$，在数值舍入误差范围内成立。\n- 对下述每个测试用例，计算每种方案的数值扩散 $\\Delta \\sigma^2$。\n- 对每个测试用例，按顺序输出一个包含六个浮点数的列表 $[\\varepsilon_{\\text{NGP}}, \\varepsilon_{\\text{CIC}}, \\varepsilon_{\\text{B3}}, \\Delta \\sigma^2_{\\text{NGP}}, \\Delta \\sigma^2_{\\text{CIC}}, \\Delta \\sigma^2_{\\text{B3}}]$，其中 $\\varepsilon$ 是由 $\\varepsilon = \\left|\\sum_i \\rho_i \\Delta x - \\sum_p w_p\\right|$ 定义的绝对守恒误差，$\\Delta \\sigma^2$ 是如上定义的方差增量。所有数字必须表示为无量纲浮点数，并四舍五入到十位小数。\n\n物理和数值参数：\n- 区域长度 $L = 1$ (无量纲)。\n- 网格尺寸和粒子集如下。\n\n测试套件（为保证可复现性，请使用这些精确的参数和相同的随机种子）：\n1. 远离边界的高斯粒子簇（理想情况）：$N=64$， $M=20000$，粒子位置 $x_p$ 从均值为 $0.35$、标准差为 $0.03$ 的正态分布中独立采样，然后通过模 $L$ 运算映射到 $[0,1)$ 内；权重相等 $w_p=1$。使用随机种子 $12345$。\n2. 靠近周期性边界的窄高斯粒子簇（边界压力测试）：$N=64$， $M=20000$，粒子位置从均值为 $0.98$、标准差为 $0.01$ 的正态分布中采样，并包裹到 $[0,1)$ 内；权重相等 $w_p=1$。使用随机种子 $23456$。\n3. 位于边界的单个粒子（边缘情况）：$N=64$，$M=1$，$x_1 = 0.0$，$w_1 = 1$。\n4. 均匀分布（混叠效应健全性检查）：$N=64$，$M=20000$，粒子位置在 $[0,1)$ 上均匀采样；权重相等 $w_p=1$。使用随机种子 $34567$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表组成的列表。具体来说，打印 $[[t_1],[t_2],[t_3],[t_4]]$，其中 $[t_k]$是测试用例 $k$ 的六个浮点数列表，顺序如上所述，每个浮点数四舍五入到十位小数。不应打印任何额外文本。",
            "solution": "我们从粒子数守恒和离散相的数学表示开始。在一维空间中，一个由位于位置 $x_p$、权重为 $w_p$ 的 $M$ 个粒子组成的集合，其连续数密度形式上由下式给出：\n$$\n\\rho(x) = \\sum_{p=1}^{M} w_p \\delta(x - x_p),\n$$\n其中 $\\delta$ 是 Dirac delta 分布。总粒子数是守恒的：\n$$\n\\int_{0}^{L} \\rho(x)\\, dx = \\sum_{p=1}^{M} w_p = N_{\\text{tot}}.\n$$\n欧拉表示法在具有网格单元中心 $x_i$ 和宽度 $\\Delta x$ 的均匀网格上使用单元平均密度 $\\rho_i$。为了获得一个保持守恒性的离散映射，我们用一个在离散意义上归一化的分配核函数 $\\mathcal{W}$ 来替代 $\\delta$。具体来说，沉积算子为：\n$$\n\\rho_i = \\frac{1}{\\Delta x} \\sum_{p=1}^{M} w_p\\, \\mathcal{W}(x_p - x_i),\n$$\n并且我们要求对于每个粒子位置 $x_p$，核函数在离散网格上满足单位分解：\n$$\n\\sum_{i=0}^{N-1} \\mathcal{W}(x_p - x_i) = 1,\n$$\n在周期性边界条件下。于是，守恒性可以直接推导得出：\n$$\n\\sum_{i=0}^{N-1} \\rho_i \\Delta x = \\sum_{i=0}^{N-1} \\sum_{p=1}^{M} w_p \\mathcal{W}(x_p - x_i) = \\sum_{p=1}^{M} w_p \\left(\\sum_{i=0}^{N-1} \\mathcal{W}(x_p - x_i)\\right) = \\sum_{p=1}^{M} w_p = N_{\\text{tot}}.\n$$\n\n我们现在定义三个具体的核函数 $\\mathcal{W}$，每个都是一维 B 样条分配函数族的一员：\n1. 最近网格点 (NGP) 对应于零阶 B 样条。对于位于 $x_p$ 的粒子，其贡献完全归于最近的中心 $x_j$，即当 $i=j$ 时 $\\mathcal{W}(x_p - x_i) = 1$，否则为 $0$。这自然满足单位分解并保证质量守恒。\n2. 网格内云 (CIC) 对应于一阶 B 样条，这是一个分段线性的帽函数，它在两个最近的中心之间线性分配权重。如果 $s = x_p/\\Delta x - 1/2$ 是粒子相对于网格中心、以网格单元为单位的坐标，且 $j = \\lfloor s \\rfloor$，那么对于 $f = s - j \\in [0,1)$，$\\mathcal{W}$ 将权重 $(1-f)$ 和 $f$ 分配给中心 $j$ 和 $j+1$（周期性地包裹）。离散权重之和为 $(1-f)+f=1$。\n3. 三次（三阶）B 样条在四个相邻中心上具有紧支集。设 $u$ 表示 $x_p$ 与中心 $x_i$ 之间的距离，单位为网格单元：$u = |x_p - x_i|/\\Delta x$。核函数值为\n$$\n\\phi(u) =\n\\begin{cases}\n\\frac{4 - 6u^2 + 3u^3}{6},  0 \\le u  1, \\\\\n\\frac{(2 - u)^3}{6},  1 \\le u  2, \\\\\n0,  u \\ge 2.\n\\end{cases}\n$$\n对于小数坐标为 $s$ 的粒子，其贡献仅对索引为 $j + k$（其中 $j = \\lfloor s \\rfloor$，$k \\in \\{-1,0,1,2\\}$）的四个相邻中心非零，距离为 $u_k = |s - (j+k)|$。单位分解性质成立，即对于任何 $s$，都有 $\\sum_{k=-1}^{2} \\phi(u_k) = 1$，从而确保了守恒性。\n\n为了评估数值扩散，我们将粒子分布的二阶中心矩（方差）与沉积的网格场的二阶中心矩进行比较。在周期性区域中，通常的欧几里得均值在边界附近不适用。因此，我们使用角度来定义环形均值 $\\theta_p = 2\\pi x_p/L$，计算\n$$\nz = \\frac{1}{N_{\\text{tot}}} \\sum_{p=1}^{M} w_p e^{i \\theta_p}, \\quad \\bar{\\theta} = \\arg(z), \\quad \\mu = \\frac{L}{2\\pi} (\\bar{\\theta} \\bmod 2\\pi).\n$$\n我们使用最小周期性差值来测量距离的平方\n$$\n\\mathrm{wrap}_L(d) = d - L \\,\\mathrm{round}\\!\\left(\\frac{d}{L}\\right) \\in \\left[-\\frac{L}{2}, \\frac{L}{2}\\right).\n$$\n那么，粒子方差为\n$$\n\\sigma^2_{\\text{part}} = \\frac{1}{N_{\\text{tot}}} \\sum_{p=1}^{M} w_p \\, \\mathrm{wrap}_L(x_p - \\mu)^2,\n$$\n网格方差为\n$$\n\\sigma^2_{\\text{grid}} = \\frac{1}{N_{\\text{tot}}} \\sum_{i=0}^{N-1} \\rho_i \\, \\mathrm{wrap}_L(x_i - \\mu)^2 \\, \\Delta x.\n$$\n由沉积过程引入的数值扩散是方差的增量\n$$\n\\Delta \\sigma^2 = \\sigma^2_{\\text{grid}} - \\sigma^2_{\\text{part}}.\n$$\n一个守恒的沉积方案具有 $\\varepsilon = \\left|\\sum_i \\rho_i \\Delta x - \\sum_p w_p\\right| \\approx 0$。对于平滑分布，扩散较小的方案会产生更小的 $\\Delta \\sigma^2$。对于单个粒子（一个离散的 delta 函数），高阶核函数会将质量更广泛地散布，因此可能产生更大的 $\\Delta \\sigma^2$；而对于平滑的聚集分布，高阶核函数通常能更好地抑制混叠效应并减少有效扩散。\n\n算法设计：\n- 从 $L$ 和 $N$ 预计算网格中心 $x_i$ 和 $\\Delta x$。\n- 对每种方案：\n  - 初始化 $\\rho_i = 0$。\n  - 对每个粒子，计算其相对坐标 $s = x_p/\\Delta x - 1/2$，并应用周期性索引来根据核函数确定受影响的网格单元和权重，通过对 $\\rho$ 加上 $w_p$ 乘以核函数权重再除以 $\\Delta x$ 来更新 $\\rho$。周期性通过对索引进行模运算来处理。\n  - 沉积后，计算守恒误差 $\\varepsilon = \\left|\\sum_i \\rho_i \\Delta x - N_{\\text{tot}}\\right|$。\n- 对每个测试用例：\n  - 生成指定分布的粒子位置 $x_p$ 和权重 $w_p$。\n  - 计算环形均值 $\\mu$ 和粒子方差 $\\sigma^2_{\\text{part}}$。\n  - 使用 NGP、CIC 和三次 B 样条进行沉积，得到 $\\rho^{\\text{NGP}}$、$\\rho^{\\text{CIC}}$ 和 $\\rho^{\\text{B3}}$。\n  - 对每个沉积场使用相同的 $\\mu$ 计算 $\\sigma^2_{\\text{grid}}$ 以分离出扩散效应，然后计算 $\\Delta \\sigma^2$。\n  - 记录六元组 $[\\varepsilon_{\\text{NGP}}, \\varepsilon_{\\text{CIC}}, \\varepsilon_{\\text{B3}}, \\Delta \\sigma^2_{\\text{NGP}}, \\Delta \\sigma^2_{\\text{CIC}}, \\Delta \\sigma^2_{\\text{B3}}]$。\n- 将四个测试用例的结果列表（每个用例一个列表）打印为单行，每个浮点数四舍五入到十位小数。\n\n数值细节和鲁棒性：\n- 使用核函数的单位分解性质和周期性模运算索引可以保证在浮点舍入误差范围内的守恒性。\n- 即使分布横跨周期性边界，环形均值和包裹后的距离平方也能确保统计量的一致性。\n- 将输出值四舍五入到十位小数，可以在不同环境中提供确定性且可比较的结果。\n\n此方法遵循欧拉-拉格朗日耦合的核心原则：通过适当归一化的核函数沉积实现守恒，并通过周期性区域上具有物理意义的二阶矩来量化数值扩散。对 NGP、CIC 和三次 B 样条的比较揭示了粒子-网格方法中典型的局部性与平滑性之间的权衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef wrap_L(d, L):\n    # Minimal periodic difference in [-L/2, L/2)\n    return d - L * np.round(d / L)\n\ndef circular_mean(xs, ws, L):\n    # Compute weighted circular mean in [0, L)\n    theta = (2.0 * np.pi / L) * xs\n    z = np.sum(ws * (np.cos(theta) + 1j * np.sin(theta))) / np.sum(ws)\n    # If z is numerically 0, arg is undefined; np.angle returns 0.0 for z=0+0j\n    mean_angle = np.angle(z)\n    if mean_angle  0:\n        mean_angle += 2.0 * np.pi\n    mu = (L / (2.0 * np.pi)) * mean_angle\n    return mu\n\ndef particle_second_moment(xs, ws, L, mu=None):\n    if mu is None:\n        mu = circular_mean(xs, ws, L)\n    diffs = wrap_L(xs - mu, L)\n    return np.sum(ws * diffs * diffs) / np.sum(ws), mu\n\ndef grid_second_moment(rho, centers, L, mu):\n    dx = L / len(centers)\n    diffs = wrap_L(centers - mu, L)\n    Ntot = np.sum(rho) * dx\n    if Ntot == 0.0:\n        return 0.0\n    return np.sum(rho * diffs * diffs) * dx / Ntot\n\ndef deposit_ngp(xs, ws, N, L):\n    dx = L / N\n    rho = np.zeros(N, dtype=np.float64)\n    s = xs / dx - 0.5\n    j = np.floor(s + 0.5).astype(int) % N\n    # Accumulate mass; density is mass per length: w/dx\n    np.add.at(rho, j, ws / dx)\n    return rho\n\ndef deposit_cic(xs, ws, N, L):\n    dx = L / N\n    rho = np.zeros(N, dtype=np.float64)\n    s = xs / dx - 0.5\n    j0 = np.floor(s).astype(int)\n    f = s - j0  # in [0,1)\n    j0 = j0 % N\n    j1 = (j0 + 1) % N\n    contrib0 = ws * (1.0 - f) / dx\n    contrib1 = ws * f / dx\n    np.add.at(rho, j0, contrib0)\n    np.add.at(rho, j1, contrib1)\n    return rho\n\ndef bspline3_phi(u):\n    # Cubic B-spline kernel as a function of nonnegative distance u (in cell units)\n    phi = np.zeros_like(u, dtype=np.float64)\n    u = np.asarray(u, dtype=np.float64)\n    mask1 = (u = 0.0)  (u  1.0)\n    mask2 = (u = 1.0)  (u  2.0)\n    phi[mask1] = (4.0 - 6.0 * u[mask1]**2 + 3.0 * u[mask1]**3) / 6.0\n    phi[mask2] = ((2.0 - u[mask2])**3) / 6.0\n    # outside support phi=0\n    return phi\n\ndef deposit_bspline3(xs, ws, N, L):\n    dx = L / N\n    rho = np.zeros(N, dtype=np.float64)\n    s = xs / dx - 0.5\n    j0 = np.floor(s).astype(int)  # base index (left center)\n    # For each particle, distribute to neighbors j0 + k, k in {-1,0,1,2}\n    for p in range(xs.shape[0]):\n        base = j0[p]\n        sp = s[p]\n        w = ws[p] / dx\n        for k in (-1, 0, 1, 2):\n            idx = (base + k) % N\n            u = abs(sp - (base + k))\n            phi = bspline3_phi(np.array([u]))[0]\n            if phi != 0.0:\n                rho[idx] += w * phi\n    return rho\n\ndef centers(N, L):\n    dx = L / N\n    return (np.arange(N, dtype=np.float64) + 0.5) * dx\n\ndef conservation_error(rho, L, total_weight):\n    dx = L / len(rho)\n    return abs(np.sum(rho) * dx - total_weight)\n\ndef variance_increase(xs, ws, rho, centers_arr, L):\n    sigma_p2, mu = particle_second_moment(xs, ws, L)\n    sigma_g2 = grid_second_moment(rho, centers_arr, L, mu)\n    return sigma_g2 - sigma_p2\n\ndef run_test_case(seed, N, L, positions_generator, weights_generator):\n    np.random.seed(seed)\n    xs = positions_generator()\n    ws = weights_generator(xs)\n    cent = centers(N, L)\n    rho_ngp = deposit_ngp(xs, ws, N, L)\n    rho_cic = deposit_cic(xs, ws, N, L)\n    rho_b3 = deposit_bspline3(xs, ws, N, L)\n    Ntot = np.sum(ws)\n    eps_ngp = conservation_error(rho_ngp, L, Ntot)\n    eps_cic = conservation_error(rho_cic, L, Ntot)\n    eps_b3 = conservation_error(rho_b3, L, Ntot)\n    dv_ngp = variance_increase(xs, ws, rho_ngp, cent, L)\n    dv_cic = variance_increase(xs, ws, rho_cic, cent, L)\n    dv_b3 = variance_increase(xs, ws, rho_b3, cent, L)\n    return [eps_ngp, eps_cic, eps_b3, dv_ngp, dv_cic, dv_b3]\n\ndef format_results(results):\n    # Round to 10 decimal places and format as required\n    def fmt(x):\n        return f\"{x:.10f}\"\n    out = []\n    for res in results:\n        out.append(\"[\" + \",\".join(fmt(v) for v in res) + \"]\")\n    return \"[\" + \",\".join(out) + \"]\"\n\ndef solve():\n    L = 1.0\n\n    # Test case 1: Gaussian cluster away from boundaries\n    N1 = 64\n    M1 = 20000\n    mu1 = 0.35\n    sigma1 = 0.03\n    def pos_gen1():\n        xs = np.random.normal(loc=mu1, scale=sigma1, size=M1)\n        xs = np.mod(xs, L)\n        return xs\n    def w_gen_equal(xs):\n        return np.ones_like(xs, dtype=np.float64)\n    res1 = run_test_case(seed=12345, N=N1, L=L, positions_generator=pos_gen1, weights_generator=w_gen_equal)\n\n    # Test case 2: Narrow Gaussian near boundary\n    N2 = 64\n    M2 = 20000\n    mu2 = 0.98\n    sigma2 = 0.01\n    def pos_gen2():\n        xs = np.random.normal(loc=mu2, scale=sigma2, size=M2)\n        xs = np.mod(xs, L)\n        return xs\n    res2 = run_test_case(seed=23456, N=N2, L=L, positions_generator=pos_gen2, weights_generator=w_gen_equal)\n\n    # Test case 3: Single particle at boundary\n    N3 = 64\n    def pos_gen3():\n        return np.array([0.0], dtype=np.float64)\n    def w_gen_single(xs):\n        return np.array([1.0], dtype=np.float64)\n    res3 = run_test_case(seed=0, N=N3, L=L, positions_generator=pos_gen3, weights_generator=w_gen_single)\n\n    # Test case 4: Uniform distribution\n    N4 = 64\n    M4 = 20000\n    def pos_gen4():\n        return np.random.rand(M4).astype(np.float64) * L\n    res4 = run_test_case(seed=34567, N=N4, L=L, positions_generator=pos_gen4, weights_generator=w_gen_equal)\n\n    results = [res1, res2, res3, res4]\n    print(format_results(results))\n\nsolve()\n```"
        },
        {
            "introduction": "建模的最终目标通常是模拟颗粒与流体之间的双向耦合，即它们如何动态地交换动量和能量。这个高级练习  旨在解决一个核心挑战：如何设计一种能够精确保持系统总动量和总能量守恒的数值格式。掌握这种结构保持算法是进行高保真度、长期物理模拟的关键。",
            "id": "3315872",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，该域通过一个均匀交错网格进行离散化，网格上有 $N$ 个速度节点，位置为 $x_i = i h$（其中 $i = 0,1,\\dots,N-1$），$h = L/N$。欧拉速度自由度是网格节点速度 $v_i(t)$，其集总质量为 $M_i = \\rho h$，代表每个节点的流体质量，其中 $\\rho$ 是质量密度（单位长度的质量）。拉格朗日自由度是 $P$ 个点粒子，其位置为 $x_p$，速度为 $u_p(t)$，质量为 $m_p$。欧拉描述与拉格朗日描述之间的耦合是通过使用满足单位分解性质的云中单元（Cloud-In-Cell, CIC）权重进行插值（网格到粒子）和沉积（粒子到网格）来实现的。\n\n使用的基本依据：\n1. 牛顿第二定律指出，动量的变化率等于所施加的力。对于每个粒子 $p$，有 $m_p \\, \\frac{d u_p}{dt} = F_p$；对于每个网格节点 $i$，有 $M_i \\, \\frac{d v_i}{dt} = f_i$。\n2. 封闭系统中的总动量守恒要求内部作用-反作用力之和为零。离散的作用-反作用交换必须使得粒子力 $F_p$ 和网格节点力 $f_i$ 在通过相同的插值/沉积权重映射时大小相等、方向相反。\n3. 内部交换下的能量守恒要求耦合的净功率（做功速率）为零，这在连续时间极限下意味着约束和力映射在适当意义上必须是斜对称的。\n\n定义周期性交错网格上位置为 $x_p$ 的粒子的云中单元权重如下。令 $i_0 = \\lfloor x_p / h \\rfloor$ 且 $i_1 = (i_0 + 1) \\bmod N$。定义局部坐标 $\\alpha = (x_p - i_0 h)/h \\in [0,1)$。唯一的非零权重是 $w_{i_0,p} = 1 - \\alpha$ 和 $w_{i_1,p} = \\alpha$，对于所有其他节点 $i$，$w_{i,p} = 0$。这些权重对每个粒子 $p$ 均满足 $\\sum_{i=0}^{N-1} w_{i,p} = 1$。\n\n使用中点法则构建一个在时长为 $\\Delta t$ 的单个时间步上的离散作用-反作用交换算子，以在中点处施加无滑移约束，该约束使每个粒子的速度等于其所在位置插值得到的欧拉速度。具体来说，在中间点时刻 $t^{n+\\frac{1}{2}}$ 施加约束\n$$\nu_p^{n+\\frac{1}{2}} = \\sum_{i=0}^{N-1} w_{i,p} \\, v_i^{n+\\frac{1}{2}},\n$$\n其中 $u_p^{n+\\frac{1}{2}} = \\frac{u_p^n + u_p^{n+1}}{2}$ 且 $v_i^{n+\\frac{1}{2}} = \\frac{v_i^n + v_i^{n+1}}{2}$。让粒子和网格节点的动量通过由内力 $F_p$ 和 $f_i$ 决定的冲量，在时间步内通过中点更新进行演化\n$$\nu_p^{n+1} = u_p^{n} + \\frac{\\Delta t}{m_p} \\, F_p, \\quad v_i^{n+1} = v_i^{n} + \\frac{\\Delta t}{M_i} \\, f_i,\n$$\n其中离散作用-反作用映射为 $f_i = -\\sum_{q=1}^{P} w_{i,q} \\, F_q$。利用这些关系和中点约束，推导出一个关于未知力 $F_p$ 的对称线性系统，该系统应保持总动量和总动能守恒。为 $P=2$ 个粒子，实现所得算法，以在单个耦合步长内推进耦合的粒子-网格速度 $(u_p, v_i)$。\n\n将总动量定义为\n$$\n\\mathcal{P} = \\sum_{p=1}^{P} m_p \\, u_p + \\sum_{i=0}^{N-1} M_i \\, v_i,\n$$\n并将总动能定义为\n$$\n\\mathcal{K} = \\frac{1}{2} \\sum_{p=1}^{P} m_p \\, u_p^2 + \\frac{1}{2} \\sum_{i=0}^{N-1} M_i \\, v_i^2.\n$$\n对于每个测试用例，计算总动量的绝对误差 $\\varepsilon_{\\mathcal{P}} = \\left| \\mathcal{P}^{n+1} - \\mathcal{P}^{n} \\right|$（以 $\\mathrm{kg \\cdot m/s}$ 为单位），以及总动能的绝对误差 $\\varepsilon_{\\mathcal{K}} = \\left| \\mathcal{K}^{n+1} - \\mathcal{K}^{n} \\right|$（以 $\\mathrm{J}$ 为单位）。同时，执行时间可逆性检验：方法是从前向更新后的状态开始，先用时间步长 $\\Delta t$ 应用耦合步骤，然后再用时间步长 $-\\Delta t$ 向后应用耦合步骤，并计算恢复后的速度与原始速度在所有粒子和网格自由度上的最大绝对差，\n$$\n\\varepsilon_{\\mathrm{rev}} = \\max\\Big(\\max_{p} \\left| \\tilde{u}_p - u_p^{n} \\right|,\\; \\max_{i} \\left| \\tilde{v}_i - v_i^{n} \\right| \\Big),\n$$\n以 $\\mathrm{m/s}$ 为单位，其中 $(\\tilde{u}_p, \\tilde{v}_i)$ 表示向后步骤之后的速度。\n\n您的程序必须在一维周期性交错网格上实现上述交换，计算 $w_{i,p}$，构建并求解关于 $F_p$ 的 $P \\times P$ 线性系统，更新 $u_p$ 和 $v_i$，并报告每个测试用例的三个误差 $\\varepsilon_{\\mathcal{P}}$、$\\varepsilon_{\\mathcal{K}}$ 和 $\\varepsilon_{\\mathrm{rev}}$。\n\n使用以下测试套件。在所有情况下，均使用 $P=2$ 个粒子，网格初始速度对所有 $i$ 均为 $v_i^n = 0$，并采用标准国际单位制（SI），其中 $L$ 的单位是 $\\mathrm{m}$，$m_p$ 和 $M_i$ 的单位是 $\\mathrm{kg}$，$u_p$ 和 $v_i$ 的单位是 $\\mathrm{m/s}$，$\\Delta t$ 的单位是 $\\mathrm{s}$。\n\n测试用例 1（一般情况）：$L = 1.0$, $N = 16$, $\\rho = 1.0$, $\\Delta t = 0.01$, 粒子质量 $m_1 = 0.5$, $m_2 = 1.0$, 位置 $x_1 = 0.30$, $x_2 = 0.70$, 速度 $u_1 = 1.2$, $u_2 = -0.8$。\n\n测试用例 2（边界附近的周期性）：$L = 1.0$, $N = 16$, $\\rho = 1.0$, $\\Delta t = 0.02$, 粒子质量 $m_1 = 0.8$, $m_2 = 1.2$, 位置 $x_1 = 0.99$, $x_2 = 0.01$, 速度 $u_1 = 0.5$, $u_2 = -0.5$。\n\n测试用例 3（节点附近的重合支撑）：$L = 1.0$, $N = 32$, $\\rho = 1.0$, $\\Delta t = 0.005$, 粒子质量 $m_1 = 1.0$, $m_2 = 1.0$, 位置 $x_1 = 0.500001$, $x_2 = 0.500002$, 速度 $u_1 = 2.0$, $u_2 = -3.0$。\n\n测试用例 4（极端质量比）：$L = 1.0$, $N = 32$, $\\rho = 1.0$, $\\Delta t = 0.001$, 粒子质量 $m_1 = 0.001$, $m_2 = 1000.0$, 位置 $x_1 = 0.25$, $x_2 = 0.75$, 速度 $u_1 = 10.0$, $u_2 = -0.01$。\n\n测试用例 5（可逆性压力测试）：$L = 1.0$, $N = 8$, $\\rho = 1.0$, $\\Delta t = 0.1$, 粒子质量 $m_1 = 1.0$, $m_2 = 1.0$, 位置 $x_1 = 0.20$, $x_2 = 0.80$, 速度 $u_1 = 1.0$, $u_2 = -1.0$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的三元组列表，列表用方括号括起来，每个三元组对应一个测试用例，并包含以 $\\mathrm{kg \\cdot m/s}$ 为单位的 $\\varepsilon_{\\mathcal{P}}$、以 $\\mathrm{J}$ 为单位的 $\\varepsilon_{\\mathcal{K}}$ 和以 $\\mathrm{m/s}$ 为单位的 $\\varepsilon_{\\mathrm{rev}}$，例如：$\\big[ [\\varepsilon_{\\mathcal{P},1}, \\varepsilon_{\\mathcal{K},1}, \\varepsilon_{\\mathrm{rev},1}], [\\varepsilon_{\\mathcal{P},2}, \\varepsilon_{\\mathcal{K},2}, \\varepsilon_{\\mathrm{rev},2}], \\dots \\big]$。",
            "solution": "用户提供的问题是计算物理学中一个有效、适定的问题。它要求实现并验证一种在拉格朗日粒子和欧拉网格之间特定的动量和能量守恒耦合方案，这是欧拉-拉格朗日模拟中的一项常见任务。\n\n### 步骤 1：提取已知条件\n- **域**：一维、周期性、长度为 $L$。\n- **网格**：均匀交错网格，有 $N$ 个速度节点，位于 $x_i = i h$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n- **网格间距**：$h = L/N$。\n- **欧拉自由度**：网格节点速度 $v_i(t)$。\n- **欧拉质量**：每个节点的集总质量 $M_i = \\rho h$，其中 $\\rho$ 是恒定的质量密度。\n- **拉格朗日自由度**：$P$ 个点粒子，其位置为 $x_p$，速度为 $u_p(t)$，质量为 $m_p$。\n- **CIC 权重**：对于位置为 $x_p$ 的粒子，令 $i_0 = \\lfloor x_p / h \\rfloor$ 且 $\\alpha = (x_p - i_0 h)/h$。非零权重为 $w_{i_0,p} = 1 - \\alpha$ 和 $w_{i_1,p} = \\alpha$，其中 $i_1 = (i_0 + 1) \\bmod N$。\n- **基本定律**：粒子 ($m_p \\frac{d u_p}{dt} = F_p$) 和网格节点 ($M_i \\frac{d v_i}{dt} = f_i$) 的牛顿第二定律。由内力产生的总动量和能量守恒。\n- **离散化**：在时长为 $\\Delta t$ 的时间步上使用中点法则。\n- **动量更新**：$u_p^{n+1} = u_p^{n} + \\frac{\\Delta t}{m_p} \\, F_p$ 和 $v_i^{n+1} = v_i^{n} + \\frac{\\Delta t}{M_i} \\, f_i$。\n- **中点速度**：$u_p^{n+\\frac{1}{2}} = \\frac{u_p^n + u_p^{n+1}}{2}$ 和 $v_i^{n+\\frac{1}{2}} = \\frac{v_i^n + v_i^{n+1}}{2}$。\n- **无滑移约束**：对每个粒子 $p$，$u_p^{n+\\frac{1}{2}} = \\sum_{i=0}^{N-1} w_{i,p} \\, v_i^{n+\\frac{1}{2}}$。\n- **作用-反作用原理**：$f_i = -\\sum_{q=1}^{P} w_{i,q} \\, F_q$。\n- **待计算量**：\n    1. 总动量绝对误差：$\\varepsilon_{\\mathcal{P}} = \\left| \\mathcal{P}^{n+1} - \\mathcal{P}^{n} \\right|$，其中 $\\mathcal{P} = \\sum_{p=1}^{P} m_p u_p + \\sum_{i=0}^{N-1} M_i v_i$。\n    2. 总动能绝对误差：$\\varepsilon_{\\mathcal{K}} = \\left| \\mathcal{K}^{n+1} - \\mathcal{K}^{n} \\right|$，其中 $\\mathcal{K} = \\frac{1}{2} \\sum_{p=1}^{P} m_p u_p^2 + \\frac{1}{2} \\sum_{i=0}^{N-1} M_i v_i^2$。\n    3. 时间可逆性误差：$\\varepsilon_{\\mathrm{rev}} = \\max\\Big(\\max_{p} \\left| \\tilde{u}_p - u_p^{n} \\right|,\\; \\max_{i} \\left| \\tilde{v}_i - v_i^{n} \\right| \\Big)$，其中 $(\\tilde{u}_p, \\tilde{v}_i)$ 是经过一个 $\\Delta t$ 的前向步和一个 $-\\Delta t$ 的后向步之后的速度。\n- **测试用例**：提供了五个不同的测试用例，包含 $L, N, \\rho, \\Delta t, m_p, x_p, u_p^n$ 的具体值。初始网格速度为 $v_i^n=0$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据、适定且客观。\n- **科学依据**：该问题基于经典力学基本原理（牛顿定律、动量和能量守恒）以及计算流体动力学中用于多相流的标准数值方法（粒子-网格法、中点法则）。其物理和数学表述是合理的。\n- **适定性**：该问题要求推导并求解一个线性方程组。如下文推导所示，所得的系统矩阵是对称正定的，保证了存在唯一且稳定的解。所有必要的参数和初始条件都已提供。\n- **客观性**：该问题使用精确的数学语言表述，没有歧义或主观论断。任务是明确定义的定量计算。\n\n该问题不违反任何无效性标准。它是构建结构保持数值格式的一个教科书式示例。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供完整的解决方案。\n\n### 基于原理的设计与推导\n\n目标是推导由时间步中点处的无滑移约束产生的未知粒子相互作用力 $F_p$ 的线性系统。\n\n首先，我们将中点速度用 $t^n$ 时刻的速度和未知力 $F_p$ 表示。\n将动量更新代入中点速度的定义中：\n对于粒子 p：\n$$ u_p^{n+\\frac{1}{2}} = \\frac{u_p^n + u_p^{n+1}}{2} = \\frac{u_p^n + (u_p^n + \\frac{\\Delta t}{m_p} F_p)}{2} = u_p^n + \\frac{\\Delta t}{2 m_p} F_p $$\n对于网格节点 i：\n$$ v_i^{n+\\frac{1}{2}} = \\frac{v_i^n + v_i^{n+1}}{2} = \\frac{v_i^n + (v_i^n + \\frac{\\Delta t}{M_i} f_i)}{2} = v_i^n + \\frac{\\Delta t}{2 M_i} f_i $$\n利用作用-反作用原理 $f_i = -\\sum_{q=1}^{P} w_{i,q} F_q$，我们可以将中点网格速度用粒子力表示：\n$$ v_i^{n+\\frac{1}{2}} = v_i^n - \\frac{\\Delta t}{2 M_i} \\sum_{q=1}^{P} w_{i,q} F_q $$\n\n现在，将这些表达式代入无滑移约束 $u_p^{n+\\frac{1}{2}} = \\sum_{i=0}^{N-1} w_{i,p} v_i^{n+\\frac{1}{2}}$：\n$$ u_p^n + \\frac{\\Delta t}{2 m_p} F_p = \\sum_{i=0}^{N-1} w_{i,p} \\left( v_i^n - \\frac{\\Delta t}{2 M_i} \\sum_{q=1}^{P} w_{i,q} F_q \\right) $$\n这个方程对每个粒子 $p=1, \\dots, P$ 都成立。我们必须将其重排为关于未知力 $F_1, \\dots, F_P$ 的线性系统。\n$$ u_p^n + \\frac{\\Delta t}{2 m_p} F_p = \\sum_{i=0}^{N-1} w_{i,p} v_i^n - \\frac{\\Delta t}{2} \\sum_{i=0}^{N-1} \\frac{w_{i,p}}{M_i} \\sum_{q=1}^{P} w_{i,q} F_q $$\n将包含力 $F_q$ 的项分组到左侧，将已知量（在 $t^n$ 时刻）分组到右侧。\n$$ \\frac{\\Delta t}{2 m_p} F_p + \\frac{\\Delta t}{2} \\sum_{q=1}^{P} \\left( \\sum_{i=0}^{N-1} \\frac{w_{i,p} w_{i,q}}{M_i} \\right) F_q = \\sum_{i=0}^{N-1} w_{i,p} v_i^n - u_p^n $$\n将整个方程乘以 $2/\\Delta t$ 以简化：\n$$ \\frac{1}{m_p} F_p + \\sum_{q=1}^{P} \\left( \\sum_{i=0}^{N-1} \\frac{w_{i,p} w_{i,q}}{M_i} \\right) F_q = \\frac{2}{\\Delta t} \\left( \\sum_{i=0}^{N-1} w_{i,p} v_i^n - u_p^n \\right) $$\n这可以写成一个 $P \\times P$ 的线性系统 $\\mathbf{A} \\mathbf{F} = \\mathbf{b}$，其中 $\\mathbf{F} = [F_1, \\dots, F_P]^T$ 是未知力向量。矩阵元素 $A_{pq}$ 和向量元素 $b_p$ 为：\n$$ A_{pq} = \\frac{\\delta_{pq}}{m_p} + \\sum_{i=0}^{N-1} \\frac{w_{i,p} w_{i,q}}{M_i} $$\n$$ b_p = \\frac{2}{\\Delta t} \\left( \\left(\\sum_{i=0}^{N-1} w_{i,p} v_i^n \\right) - u_p^n \\right) $$\n其中 $\\delta_{pq}$ 是克罗内克 δ。矩阵 $\\mathbf{A}$ 是对称的，因为 $A_{pq} = A_{qp}$。它也是正定的，这保证了 $\\mathbf{F}$ 存在唯一解。\n\n单个耦合步骤的算法如下：\n1. 给定状态 $(u_p^n, v_i^n)$ 和系统参数，计算所有粒子的 CIC 权重 $w_{i,p}$。\n2. 构建 $P \\times P$ 矩阵 $\\mathbf{A}$ 和 $P \\times 1$ 向量 $\\mathbf{b}$。由于 $M_i = \\rho h$ 是常数，求和得以简化。令 $W$ 为 $P \\times N$ 的权重矩阵，因此 $W_{pi} = w_{i,p}$。则 $\\mathbf{A} = \\mathrm{diag}(1/m_p) + \\frac{1}{\\rho h} \\mathbf{W} \\mathbf{W}^T$。\n3. 求解线性系统 $\\mathbf{A}\\mathbf{F} = \\mathbf{b}$ 以得到力向量 $\\mathbf{F}$。\n4. 更新粒子速度：$u_p^{n+1} = u_p^n + \\frac{\\Delta t}{m_p} F_p$，对 $p = 1, \\dots, P$。\n5. 计算网格节点上的反作用力：$f_i = -\\sum_{p=1}^{P} w_{i,p} F_p$。矩阵形式为 $\\mathbf{f} = -\\mathbf{W}^T \\mathbf{F}$。\n6. 更新网格速度：$v_i^{n+1} = v_i^n + \\frac{\\Delta t}{M_i} f_i$，对 $i = 0, \\dots, N-1$。\n\n这种构造保证了总动量和总动能的精确守恒（在机器浮点精度范围内），因为约束力定律源于一个与能量守恒一致的原理（中点无滑移），并且力的作用-反作用形式确保了动量守恒。中点法则的时间对称性确保了时间可逆性。这些理论性质为该实现提供了一种强有力的验证方法。下面的实现遵循此推导出的算法，以计算每个测试用例所要求的误差度量。",
            "answer": "```python\nimport numpy as np\n\ndef run_test_case(L, N, rho, dt, m_p, x_p, u_p_n):\n    \"\"\"\n    Runs a single test case for the Eulerian-Lagrangian coupling problem.\n\n    Args:\n        L (float): Length of the periodic domain.\n        N (int): Number of grid nodes.\n        rho (float): Fluid mass density (mass per unit length).\n        dt (float): Time step duration.\n        m_p (list): List of particle masses.\n        x_p (list): List of particle positions.\n        u_p_n (list): List of initial particle velocities.\n\n    Returns:\n        tuple: A triplet containing the absolute errors in momentum (e_p),\n               kinetic energy (e_k), and the reversibility error (e_rev).\n    \"\"\"\n\n    h = L / N\n    M_val = rho * h\n    v_i_n = np.zeros(N)\n    \n    m_p = np.array(m_p, dtype=float)\n    x_p = np.array(x_p, dtype=float)\n    u_p_n = np.array(u_p_n, dtype=float)\n\n    def coupling_step(u_in, v_in, m_p, M_val, x_p, L, N, dt_step):\n        \"\"\"\n        Performs one coupling step.\n        \"\"\"\n        P = len(m_p)\n        h_local = L / N\n\n        # 1. Compute CIC weights\n        W = np.zeros((P, N))\n        i0_arr = np.floor(x_p / h_local).astype(int)\n        alpha_arr = (x_p - i0_arr * h_local) / h_local\n        for p in range(P):\n            i0 = i0_arr[p]\n            i1 = (i0 + 1) % N\n            alpha = alpha_arr[p]\n            W[p, i0] = 1.0 - alpha\n            W[p, i1] = alpha\n        \n        # 2. Assemble and solve the linear system for forces F\n        A = np.diag(1.0 / m_p) + (W @ W.T) / M_val\n        \n        # Interpolate grid velocity to particle positions\n        v_interp = W @ v_in\n        \n        b = (2.0 / dt_step) * (v_interp - u_in)\n        \n        F = np.linalg.solve(A, b)\n\n        # 3. Update particle velocities\n        u_out = u_in + dt_step * F / m_p\n\n        # 4. Compute grid forces and update grid velocities\n        f = -W.T @ F\n        v_out = v_in + dt_step * f / M_val\n\n        return u_out, v_out\n\n    # Calculate initial total momentum and kinetic energy\n    p_n_total = np.sum(m_p * u_p_n) + np.sum(M_val * v_i_n)\n    k_n_total = 0.5 * np.sum(m_p * u_p_n**2) + 0.5 * np.sum(M_val * v_i_n**2)\n\n    # Perform forward coupling step\n    u_p_n1, v_i_n1 = coupling_step(u_p_n, v_i_n, m_p, M_val, x_p, L, N, dt)\n\n    # Calculate final total momentum and kinetic energy\n    p_n1_total = np.sum(m_p * u_p_n1) + np.sum(M_val * v_i_n1)\n    k_n1_total = 0.5 * np.sum(m_p * u_p_n1**2) + 0.5 * np.sum(M_val * v_i_n1**2)\n\n    # Calculate conservative property errors\n    err_p = np.abs(p_n1_total - p_n_total)\n    err_k = np.abs(k_n1_total - k_n_total)\n\n    # Perform backward coupling step for time-reversibility check\n    u_tilde, v_tilde = coupling_step(u_p_n1, v_i_n1, m_p, M_val, x_p, L, N, -dt)\n\n    # Calculate reversibility error\n    err_rev_u = np.max(np.abs(u_tilde - u_p_n))\n    err_rev_v = np.max(np.abs(v_tilde - v_i_n))\n    err_rev = max(err_rev_u, err_rev_v) if N  0 else err_rev_u\n\n    return [err_p, err_k, err_rev]\n\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general case)\n        {'L': 1.0, 'N': 16, 'rho': 1.0, 'dt': 0.01,\n         'm_p': [0.5, 1.0], 'x_p': [0.30, 0.70], 'u_p_n': [1.2, -0.8]},\n        # Test case 2 (periodicity near boundaries)\n        {'L': 1.0, 'N': 16, 'rho': 1.0, 'dt': 0.02,\n         'm_p': [0.8, 1.2], 'x_p': [0.99, 0.01], 'u_p_n': [0.5, -0.5]},\n        # Test case 3 (coincident support near a node)\n        {'L': 1.0, 'N': 32, 'rho': 1.0, 'dt': 0.005,\n         'm_p': [1.0, 1.0], 'x_p': [0.500001, 0.500002], 'u_p_n': [2.0, -3.0]},\n        # Test case 4 (extreme mass ratio)\n        {'L': 1.0, 'N': 32, 'rho': 1.0, 'dt': 0.001,\n         'm_p': [0.001, 1000.0], 'x_p': [0.25, 0.75], 'u_p_n': [10.0, -0.01]},\n        # Test case 5 (reversibility stress)\n        {'L': 1.0, 'N': 8, 'rho': 1.0, 'dt': 0.1,\n         'm_p': [1.0, 1.0], 'x_p': [0.20, 0.80], 'u_p_n': [1.0, -1.0]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_test_case(**case)\n        results.append(result)\n\n    formatted_results = []\n    for res_list in results:\n        # Format each sublist to a string like \"[val1,val2,val3]\"\n        sublist_str = f\"[{','.join(f'{val:.17g}' for val in res_list)}]\"\n        formatted_results.append(sublist_str)\n\n    # Join the formatted sublists and wrap in the final brackets\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}