{
    "hands_on_practices": [
        {
            "introduction": "Before implementing any finite element method, one must understand its fundamental building blocks. This practice guides you through the essential first steps: constructing a set of basis functions on a reference element and understanding how they translate to a physical mesh element through the mass matrix . Mastering the concepts of reference-to-physical element mapping and the role of numerical quadrature is a cornerstone for building a robust and accurate DG solver.",
            "id": "3372733",
            "problem": "Consider the Discontinuous Galerkin finite element method (DG FEM) for Computational Fluid Dynamics (CFD) on a two-dimensional quadrilateral mesh. Let the reference element be the square $\\hat{K} = [-1,1] \\times [-1,1]$. Let $P^{k}(\\hat{K})$ denote the space of all polynomials in two variables whose total degree is at most $k$, and equip $P^{k}(\\hat{K})$ with the $L^{2}$ inner product on $\\hat{K}$ defined by $\\langle f, g \\rangle_{L^{2}(\\hat{K})} = \\int_{\\hat{K}} f(\\hat{\\boldsymbol{x}}) g(\\hat{\\boldsymbol{x}}) \\,\\mathrm{d}\\hat{\\boldsymbol{x}}$. \n\nStarting from the definition of the $L^{2}$ inner product and the integral transformation under an affine map, construct an explicit orthonormal basis for $P^{1}(\\hat{K})$ with respect to $\\langle \\cdot, \\cdot \\rangle_{L^{2}(\\hat{K})}$, and explain how the mass matrix on a physical element arises from the pullback and quadrature. Define the physical element $K$ via the affine map $F_{K} : \\hat{K} \\to K$ given by $F_{K}(\\hat{\\boldsymbol{x}}) = A \\hat{\\boldsymbol{x}} + \\boldsymbol{b}$ for a constant matrix $A \\in \\mathbb{R}^{2 \\times 2}$ and vector $\\boldsymbol{b} \\in \\mathbb{R}^{2}$. The local mass matrix $M^{K}$ has entries $M^{K}_{ij} = \\int_{K} \\phi_{i}^{K}(\\boldsymbol{x}) \\,\\phi_{j}^{K}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$, where $\\{\\phi_{i}^{K}\\}$ are the basis functions on $K$ obtained by pullback from the reference basis $\\{\\hat{\\phi}_{i}\\}$ on $\\hat{K}$.\n\nUse tensor-product Gauss quadrature in each coordinate direction on $\\hat{K}$ to approximate the integrals defining $M^{K}$, and justify the required quadrature order for exactness when $k=1$. Finally, for the specific affine map with\n$$\nA = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}, \\qquad \\boldsymbol{b} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix},\n$$\ndetermine the determinant of the physical-element mass matrix $M^{K}$ when $k=1$. Express your final answer as an exact value with no rounding and without units.",
            "solution": "The problem is well-posed and self-contained, presenting a standard exercise in the formulation of the discontinuous Galerkin finite element method. All terms are defined conventionally, and the requested calculations are mathematically sound and relevant to the field. We may therefore proceed with a solution.\n\nThe problem asks for four main components:\n1.  Construction of an orthonormal basis for the polynomial space $P^{1}(\\hat{K})$.\n2.  An explanation of how the physical element mass matrix $M^K$ is derived.\n3.  Justification of the quadrature order for exact computation of the mass matrix entries for $k=1$.\n4.  Calculation of the determinant of a specific mass matrix $M^K$.\n\nWe shall address these in sequence.\n\nFirst, we construct an orthonormal basis for the space $P^{1}(\\hat{K})$. This is the space of polynomials in two variables, $\\hat{x}$ and $\\hat{y}$, of total degree at most $1$. A canonical monomial basis for $P^{1}(\\hat{K})$ is $\\{\\hat{\\psi}_{1}, \\hat{\\psi}_{2}, \\hat{\\psi}_{3}\\} = \\{1, \\hat{x}, \\hat{y}\\}$. The dimension of this space is $3$. We seek an orthonormal basis $\\{\\hat{\\phi}_{1}, \\hat{\\phi}_{2}, \\hat{\\phi}_{3}\\}$ with respect to the $L^{2}$ inner product on the reference element $\\hat{K} = [-1,1] \\times [-1,1]$:\n$$ \\langle f, g \\rangle_{L^{2}(\\hat{K})} = \\int_{-1}^{1} \\int_{-1}^{1} f(\\hat{x}, \\hat{y}) g(\\hat{x}, \\hat{y}) \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} $$\nWe apply the Gram-Schmidt orthonormalization process to the monomial basis.\n\nLet $\\hat{\\phi}_{1}$ be the normalization of $\\hat{\\psi}_{1} = 1$:\n$$ \\|\\hat{\\psi}_{1}\\|^2_{L^{2}(\\hat{K})} = \\langle 1, 1 \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} 1 \\cdot 1 \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = \\left(\\int_{-1}^{1} \\mathrm{d}\\hat{x}\\right) \\left(\\int_{-1}^{1} \\mathrm{d}\\hat{y}\\right) = (2)(2) = 4 $$\nSo, $\\|\\hat{\\psi}_{1}\\|_{L^{2}(\\hat{K})} = 2$. The first orthonormal basis function is:\n$$ \\hat{\\phi}_{1}(\\hat{x}, \\hat{y}) = \\frac{\\hat{\\psi}_{1}}{\\|\\hat{\\psi}_{1}\\|} = \\frac{1}{2} $$\n\nNext, we orthogonalize $\\hat{\\psi}_{2} = \\hat{x}$ against $\\hat{\\phi}_{1}$:\n$$ \\langle \\hat{\\psi}_{2}, \\hat{\\phi}_{1} \\rangle = \\left\\langle \\hat{x}, \\frac{1}{2} \\right\\rangle = \\frac{1}{2} \\int_{-1}^{1} \\int_{-1}^{1} \\hat{x} \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = \\frac{1}{2} \\left(\\int_{-1}^{1} \\hat{x} \\,\\mathrm{d}\\hat{x}\\right) \\left(\\int_{-1}^{1} \\mathrm{d}\\hat{y}\\right) = \\frac{1}{2} \\cdot 0 \\cdot 2 = 0 $$\nSince $\\hat{\\psi}_{2}$ is already orthogonal to $\\hat{\\phi}_{1}$, we only need to normalize it:\n$$ \\|\\hat{\\psi}_{2}\\|^2_{L^{2}(\\hat{K})} = \\langle \\hat{x}, \\hat{x} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\hat{x}^{2} \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = \\left(\\int_{-1}^{1} \\hat{x}^{2} \\,\\mathrm{d}\\hat{x}\\right) \\left(\\int_{-1}^{1} \\mathrm{d}\\hat{y}\\right) = \\left[\\frac{\\hat{x}^{3}}{3}\\right]_{-1}^{1} \\cdot 2 = \\left(\\frac{1}{3} - \\frac{-1}{3}\\right) \\cdot 2 = \\frac{2}{3} \\cdot 2 = \\frac{4}{3} $$\nSo, $\\|\\hat{\\psi}_{2}\\|_{L^{2}(\\hat{K})} = \\frac{2}{\\sqrt{3}}$. The second orthonormal basis function is:\n$$ \\hat{\\phi}_{2}(\\hat{x}, \\hat{y}) = \\frac{\\hat{\\psi}_{2}}{\\|\\hat{\\psi}_{2}\\|} = \\frac{\\sqrt{3}}{2}\\hat{x} $$\n\nFinally, we orthogonalize $\\hat{\\psi}_{3} = \\hat{y}$ against $\\hat{\\phi}_{1}$ and $\\hat{\\phi}_{2}$. By symmetry, the integrals are zero:\n$$ \\langle \\hat{\\psi}_{3}, \\hat{\\phi}_{1} \\rangle = \\left\\langle \\hat{y}, \\frac{1}{2} \\right\\rangle = \\frac{1}{2} \\int_{-1}^{1} \\int_{-1}^{1} \\hat{y} \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = 0 $$\n$$ \\langle \\hat{\\psi}_{3}, \\hat{\\phi}_{2} \\rangle = \\left\\langle \\hat{y}, \\frac{\\sqrt{3}}{2}\\hat{x} \\right\\rangle = \\frac{\\sqrt{3}}{2} \\int_{-1}^{1} \\int_{-1}^{1} \\hat{x}\\hat{y} \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = \\frac{\\sqrt{3}}{2} \\left(\\int_{-1}^{1} \\hat{x}\\,\\mathrm{d}\\hat{x}\\right) \\left(\\int_{-1}^{1} \\hat{y}\\,\\mathrm{d}\\hat{y}\\right) = 0 $$\nThus, we only need to normalize $\\hat{\\psi}_{3}$. The calculation is symmetric to that for $\\hat{\\psi}_{2}$:\n$$ \\|\\hat{\\psi}_{3}\\|^2_{L^{2}(\\hat{K})} = \\langle \\hat{y}, \\hat{y} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\hat{y}^{2} \\,\\mathrm{d}\\hat{x} \\,\\mathrm{d}\\hat{y} = \\frac{4}{3} $$\nSo, $\\|\\hat{\\psi}_{3}\\|_{L^{2}(\\hat{K})} = \\frac{2}{\\sqrt{3}}$. The third orthonormal basis function is:\n$$ \\hat{\\phi}_{3}(\\hat{x}, \\hat{y}) = \\frac{\\hat{\\psi}_{3}}{\\|\\hat{\\psi}_{3}\\|} = \\frac{\\sqrt{3}}{2}\\hat{y} $$\nThe orthonormal basis for $P^{1}(\\hat{K})$ is $\\{\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\hat{x}, \\frac{\\sqrt{3}}{2}\\hat{y}\\}$.\n\nSecond, we explain the derivation of the physical element mass matrix $M^K$. The entries are defined as $M^{K}_{ij} = \\int_{K} \\phi_{i}^{K}(\\boldsymbol{x}) \\,\\phi_{j}^{K}(\\boldsymbol{x}) \\,\\mathrm{d}\\boldsymbol{x}$. The basis functions $\\phi_{i}^{K}$ on the physical element $K$ are obtained via pullback from the reference basis functions $\\hat{\\phi}_{i}$ using the inverse of the affine map $F_K$. That is, $\\phi_{i}^{K} = \\hat{\\phi}_{i} \\circ F_{K}^{-1}$. To evaluate the integral over $K$, we perform a change of variables to the reference element $\\hat{K}$ using $\\boldsymbol{x} = F_{K}(\\hat{\\boldsymbol{x}})$. The differential element transforms as $\\mathrm{d}\\boldsymbol{x} = |\\det(J_{F_K})|\\,\\mathrm{d}\\hat{\\boldsymbol{x}}$, where $J_{F_K}$ is the Jacobian matrix of the map $F_K$. For the affine map $F_{K}(\\hat{\\boldsymbol{x}}) = A \\hat{\\boldsymbol{x}} + \\boldsymbol{b}$, the Jacobian is the constant matrix $A$. Thus, $\\mathrm{d}\\boldsymbol{x} = |\\det(A)|\\,\\mathrm{d}\\hat{\\boldsymbol{x}}$.\n\nSubstituting these into the integral for $M^{K}_{ij}$:\n$$ M^{K}_{ij} = \\int_{\\hat{K}} \\phi_{i}^{K}(F_{K}(\\hat{\\boldsymbol{x}})) \\phi_{j}^{K}(F_{K}(\\hat{\\boldsymbol{x}})) \\,|\\det(A)|\\,\\mathrm{d}\\hat{\\boldsymbol{x}} $$\nBy the definition of the pullback, $\\phi_{i}^{K}(F_{K}(\\hat{\\boldsymbol{x}})) = (\\hat{\\phi}_{i} \\circ F_{K}^{-1})(F_{K}(\\hat{\\boldsymbol{x}})) = \\hat{\\phi}_{i}(\\hat{\\boldsymbol{x}})$. The expression simplifies to:\n$$ M^{K}_{ij} = |\\det(A)| \\int_{\\hat{K}} \\hat{\\phi}_{i}(\\hat{\\boldsymbol{x}}) \\hat{\\phi}_{j}(\\hat{\\boldsymbol{x}}) \\,\\mathrm{d}\\hat{\\boldsymbol{x}} = |\\det(A)| \\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_{L^{2}(\\hat{K})} $$\nSince the basis $\\{\\hat{\\phi}_{i}\\}$ is orthonormal, we have $\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_{L^{2}(\\hat{K})} = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. Therefore, the mass matrix entries are given by $M^{K}_{ij} = |\\det(A)| \\delta_{ij}$. This reveals that the physical mass matrix is a scalar multiple of the identity matrix: $M^K = |\\det(A)| I$. The calculation of these integrals is performed using numerical quadrature.\n\nThird, we justify the quadrature order. The integrals to be computed are $\\int_{\\hat{K}} \\hat{\\phi}_{i} \\hat{\\phi}_{j} \\,\\mathrm{d}\\hat{\\boldsymbol{x}}$. For $k=1$, the basis functions $\\hat{\\phi}_i$ are polynomials of total degree at most $1$. The integrand, $\\hat{\\phi}_{i}(\\hat{\\boldsymbol{x}}) \\hat{\\phi}_{j}(\\hat{\\boldsymbol{x}})$, is therefore a polynomial of total degree at most $1+1=2$. For example, $\\hat{\\phi}_{2}\\hat{\\phi}_{2} = (\\frac{\\sqrt{3}}{2}\\hat{x})^{2} = \\frac{3}{4}\\hat{x}^{2}$, which has degree $2$. A tensor-product Gauss quadrature rule employing $N_p$ points in each coordinate direction can exactly integrate polynomials of degree up to $2N_p - 1$ in each variable separately. To exactly integrate any polynomial of total degree $2$ on the square, we need to ensure the rule is exact for all monomials $\\hat{x}^a \\hat{y}^b$ where $a+b \\le 2$. The highest degree in a single variable is $2$ (from terms like $\\hat{x}^2$ and $\\hat{y}^2$). Therefore, we require the one-dimensional Gauss rule to be exact for polynomials of degree up to $2$. This necessitates $2N_p - 1 \\ge 2$, leading to $2N_p \\ge 3$, or $N_p \\ge 1.5$. Since the number of points $N_p$ must be an integer, we must choose $N_p=2$. A $2$-point Gauss rule in each direction (a $2 \\times 2$ tensor-product rule) is exact for polynomials of degree up to $3$ in each variable, which is sufficient to compute the mass matrix exactly.\n\nFourth, we calculate the determinant of $M^K$ for the specific affine map given by $A = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$. The determinant of $A$ is:\n$$ \\det(A) = (2)(2) - (1)(1) = 4 - 1 = 3 $$\nThe absolute value is $|\\det(A)| = 3$. The dimension of the polynomial space $P^{1}(\\hat{K})$ is $3$, so the mass matrix $M^K$ is a $3 \\times 3$ matrix. As derived above, $M^K = |\\det(A)| I_3$, where $I_3$ is the $3 \\times 3$ identity matrix.\n$$ M^K = 3 \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 3  0  0 \\\\ 0  3  0 \\\\ 0  0  3 \\end{pmatrix} $$\nThe determinant of this matrix is:\n$$ \\det(M^K) = \\det(3 I_3) = 3^3 \\det(I_3) = 27 \\cdot 1 = 27 $$\nThe determinant of the physical-element mass matrix is $27$.",
            "answer": "$$\\boxed{27}$$"
        },
        {
            "introduction": "A key advantage of the DG method is its ability to capture sharp features like shock waves, but this requires special care to avoid non-physical oscillations. This exercise introduces the concept of slope limiting, a crucial technique for ensuring the stability and physical relevance of DG simulations for hyperbolic conservation laws . You will derive and apply a Total Variation Boundedness (TVB) limiter, gaining practical insight into how to \"tame\" the high-order polynomial reconstructions near steep gradients.",
            "id": "3372706",
            "problem": "Consider the scalar one-dimensional hyperbolic conservation law $u_{t} + f(u)_{x} = 0$ on a uniform mesh with cell width $h$, discretized by the Discontinuous Galerkin (DG) finite element method with piecewise polynomials of degree $k$ in each cell. Let each cell $I_{i}$ be mapped affinely to the reference interval $\\xi \\in [-1,1]$ via $\\xi = \\frac{2}{h}(x-x_{i})$, and represent the solution in $I_{i}$ by a modal expansion in Legendre polynomials, $u_{h}\\big|_{I_{i}}(\\xi) = \\sum_{m=0}^{k} \\hat{u}_{i,m} P_{m}(\\xi)$, where $\\hat{u}_{i,0} = \\bar{u}_{i}$ is the cell average. Limiting is required to enforce physically relevant boundedness of oscillations and to control total variation growth near discontinuities while maintaining high-order accuracy in smooth regions.\n\nStarting from the concepts of Total Variation Boundedness (TVB) and the structure of DG reconstructions, derive a one-dimensional TVB slope limiter that modifies the linear content of the polynomial in cell $I_{i}$ by comparing the reconstructed slope against neighbor-based secant slopes and employing a TVB-modified minmod operator. Explicitly:\n- Derive a TVB minmod operator that protects smooth extrema by introducing a tolerance governed by a TVB parameter $M$, and explain the scaling of this tolerance with the mesh size $h$ arising from Taylor expansions of smooth functions.\n- Formulate a smoothness indicator built from second differences of cell averages, scaled by $h^{2}$, that activates limiting only in the presence of steep gradients.\n- Show how to map the limited slope back to the linear modal coefficient $\\hat{u}_{i,1}$ in the Legendre basis on $[-1,1]$.\n\nThen, for the concrete case of degree $k=2$ with Legendre basis in cell $I_{i}$, take the numerical data\n$\\bar{u}_{i-1} = 1.0$, $\\bar{u}_{i} = 1.2$, $\\bar{u}_{i+1} = 1.5$, $h = 0.2$, $\\hat{u}_{i,1} = 0.25$, $\\hat{u}_{i,2} = -0.05$, and TVB parameter $M = 0.5$. Using your derived limiter and smoothness indicator, compute the limited linear modal coefficient $\\hat{u}_{i,1}^{\\text{new}}$. Express the final answer as a pure number with no units, and do not round unless necessary.",
            "solution": "The problem requires the derivation of a one-dimensional Total Variation Boundedness (TVB) slope limiter for a Discontinuous Galerkin (DG) method and its application to a concrete numerical case. The validation process confirms that the problem is scientifically grounded, well-posed, and objective. We may proceed with the solution.\n\nThe solution is structured as follows:\n1.  Derivation of the TVB slope limiter, including the TVB-modified minmod operator and its scaling.\n2.  Formulation of a smoothness indicator to selectively apply the limiter.\n3.  Explanation of the relationship between the physical slope and the modal Legendre coefficient.\n4.  Application of the derived limiter and indicator to the provided numerical data.\n\n### Part 1: Derivation of the TVB Slope Limiter\n\nA slope limiter for a DG method aims to control the slope of the polynomial reconstruction within each cell $I_i = [x_i - h/2, x_i + h/2]$ to prevent spurious oscillations near discontinuities. This is achieved by modifying the modal coefficients of the polynomial representation, $u_h\\big|_{I_i}(\\xi) = \\sum_{m=0}^{k} \\hat{u}_{i,m} P_{m}(\\xi)$, where $\\xi = \\frac{2}{h}(x-x_i)$ is the coordinate on the reference element $[-1, 1]$.\n\nThe \"slope\" of the solution is primarily determined by the linear content of the polynomial. The Legendre basis polynomials are $P_0(\\xi)=1$ and $P_1(\\xi)=\\xi$. The linear part of the reconstruction in cell $I_i$ is $u_h^{lin}(x) = \\hat{u}_{i,0}P_0(\\xi) + \\hat{u}_{i,1}P_1(\\xi) = \\bar{u}_i + \\hat{u}_{i,1}\\xi$.\n\nThe physical slope of this linear part is constant throughout the cell:\n$$ s_i = \\frac{d}{dx} u_h^{lin}(x) = \\frac{d}{d\\xi}(\\bar{u}_i + \\hat{u}_{i,1}\\xi) \\frac{d\\xi}{dx} = \\hat{u}_{i,1} \\cdot \\frac{2}{h} $$\nThis shows a direct relationship between the physical slope $s_i$ and the linear modal coefficient $\\hat{u}_{i,1}$. A limiter acting on the slope $s_i$ is equivalent to one acting on the coefficient $\\hat{u}_{i,1}$. We will formulate the limiter in terms of $\\hat{u}_{i,1}$ for consistency with standard literature, which simplifies comparisons.\n\nThe limiter compares the internal \"slope\" information, represented by $\\hat{u}_{i,1}$, against \"slope\" information from neighboring cell averages. The term $\\hat{u}_{i,1}$ represents the change in the solution from the cell center to the cell boundary on the reference element, i.e., $u_h^{lin}(\\xi=1) - u_h^{lin}(\\xi=0) = \\hat{u}_{i,1}$. For comparison, we use half the difference of neighboring cell averages, which corresponds to an average change over a distance of $h/2$:\n-   Forward difference comparator: $\\frac{1}{2}(\\bar{u}_{i+1} - \\bar{u}_i)$\n-   Backward difference comparator: $\\frac{1}{2}(\\bar{u}_i - \\bar{u}_{i-1})$\n\nThe limited coefficient, $\\hat{u}_{i,1}^{\\text{new}}$, is obtained using a TVB-modified minmod operator:\n$$ \\hat{u}_{i,1}^{\\text{new}} = \\text{minmod}_{TVB} \\left( \\hat{u}_{i,1}, \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{2}, \\frac{\\bar{u}_i - \\bar{u}_{i-1}}{2} \\right) $$\n\nThe TVB-modified minmod operator, $\\text{minmod}_{TVB}$, is defined as:\n$$ \\text{minmod}_{TVB}(a, b, c) = \\begin{cases} a,  \\text{if } |a| \\le M h^2 \\\\ \\text{minmod}(a, b, c),  \\text{otherwise} \\end{cases} $$\nwhere $\\text{minmod}(a,b,c)$ is the standard minmod function, which returns the argument with the smallest magnitude if all arguments have the same sign, and zero otherwise.\n\nThe tolerance $M h^2$ is crucial for protecting smooth extrema from being flattened. For a smooth function $u(x)$, consider a Taylor expansion around a local extremum $x_c$. For a cell $I_i$ near this extremum, the deviation of the function value from the cell average, $u(x)-\\bar{u}_i$, can be shown to be of order $O(h^2)$. For instance, for $u(x) = c(x-x_c)^2$, the deviation at the cell boundaries $x_i \\pm h/2$ is $O(h^2)$. The DG modal coefficient $\\hat{u}_{i,1}$ is a high-order approximation to the projection of the solution's linear content; at a symmetric extremum ($x_c=x_i$), $\\hat{u}_{i,1}$ would be zero. More generally, near an extremum, $\\hat{u}_{i,1}$ is of order $O(h^2)$ or smaller. By setting a tolerance of $Mh^2$, we specify that if the \"slope\" coefficient $\\hat{u}_{i,1}$ is already small enough to be consistent with a smooth extremum, it should not be modified. The TVB parameter $M$ is a user-defined constant, often chosen proportional to an estimate of the maximum expected second derivative of the solution, $\\max|u_{xx}|$.\n\n### Part 2: Smoothness Indicator\n\nApplying the limiter everywhere can degrade accuracy in smooth regions. A smoothness indicator is used to activate limiting only in \"troubled\" cells, i.e., those near steep gradients or discontinuities.\n\nA robust indicator can be built from the second difference of cell averages: $\\Delta^2_i \\bar{u} = \\bar{u}_{i+1} - 2\\bar{u}_i + \\bar{u}_{i-1}$.\nFor a smooth function, a Taylor series expansion shows that $\\Delta^2_i \\bar{u} \\approx u''(x_i) h^2$. Thus, this quantity is of order $O(h^2)$ in smooth regions. Near a discontinuity, however, the second difference is much larger, typically of order $O(h)$.\n\nThis difference in scaling allows us to formulate a simple and effective indicator. We can compare $|\\Delta^2_i \\bar{u}|$ to the same TVB tolerance, $Mh^2$, that is used to protect extrema. A cell $I_i$ is flagged as troubled, and limiting is applied, if the local curvature estimated from cell averages exceeds this threshold:\n$$ \\text{Activate Limiter if: } |\\bar{u}_{i+1} - 2\\bar{u}_i + \\bar{u}_{i-1}|  M h^2 $$\nThis condition links the limiter's activation to its operating principle: limiting is applied when the local behavior of the cell averages is inconsistent with the assumption of a smooth extremum characterized by the parameter $M$.\n\n### Part 3: Mapping Between Slope and Coefficient\n\nAs established in Part 1, the physical slope of the linear reconstruction, $s_i$, is directly proportional to the modal coefficient $\\hat{u}_{i,1}$:\n$$ s_i = \\frac{2 \\hat{u}_{i,1}}{h} $$\nIf we compute a limited slope $s_i^{\\text{new}}$, the corresponding new modal coefficient is found by inverting this relationship:\n$$ \\hat{u}_{i,1}^{\\text{new}} = \\frac{h}{2} s_i^{\\text{new}} $$\nOur chosen formulation, which limits $\\hat{u}_{i,1}$ directly, incorporates this mapping implicitly. The comparison quantities $(\\bar{u}_{i+1} - \\bar{u}_i)/2$ and $(\\bar{u}_i - \\bar{u}_{i-1})/2$ are equivalent to scaling the secant slopes $\\sigma_F = (\\bar{u}_{i+1} - \\bar{u}_i)/h$ and $\\sigma_B = (\\bar{u}_i - \\bar{u}_{i-1})/h$ by $h/2$.\n\n### Part 4: Numerical Calculation\n\nWe apply the derived procedure to the given data:\n- Cell averages: $\\bar{u}_{i-1} = 1.0$, $\\bar{u}_{i} = 1.2$, $\\bar{u}_{i+1} = 1.5$.\n- Cell width: $h = 0.2$.\n- Initial modal coefficients: $\\hat{u}_{i,1} = 0.25$, $\\hat{u}_{i,2} = -0.05$.\n- TVB parameter: $M = 0.5$.\n\n**Step 1: Check the smoothness indicator.**\nFirst, we compute the second difference of cell averages:\n$$ \\Delta^2_i \\bar{u} = \\bar{u}_{i+1} - 2\\bar{u}_i + \\bar{u}_{i-1} = 1.5 - 2(1.2) + 1.0 = 1.5 - 2.4 + 1.0 = 0.1 $$\nNext, we compute the threshold for the indicator:\n$$ M h^2 = 0.5 \\times (0.2)^2 = 0.5 \\times 0.04 = 0.02 $$\nWe compare the absolute value of the second difference to this threshold:\n$$ |\\Delta^2_i \\bar{u}| = |0.1| = 0.1 $$\nSince $0.1  0.02$, the condition $|\\Delta^2_i \\bar{u}|  M h^2$ is met. Therefore, the limiter must be activated for cell $I_i$.\n\n**Step 2: Apply the TVB slope limiter.**\nWe compute the arguments for the $\\text{minmod}_{TVB}$ function:\n$$ \\hat{u}_{i,1}^{\\text{new}} = \\text{minmod}_{TVB}(a, b, c) $$\n- The coefficient to be limited: $a = \\hat{u}_{i,1} = 0.25$.\n- The forward difference comparator: $b = \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{2} = \\frac{1.5 - 1.2}{2} = \\frac{0.3}{2} = 0.15$.\n- The backward difference comparator: $c = \\frac{\\bar{u}_i - \\bar{u}_{i-1}}{2} = \\frac{1.2 - 1.0}{2} = \\frac{0.2}{2} = 0.1$.\n\nNow, we evaluate the $\\text{minmod}_{TVB}$ operator. First, check the tolerance condition: Is $|a| \\le M h^2$?\n$$ |0.25| \\le 0.02 $$\nThis is false. The coefficient is too large to be considered part of a smooth extremum under the given tolerance. Thus, we proceed to apply the standard `minmod` function:\n$$ \\hat{u}_{i,1}^{\\text{new}} = \\text{minmod}(0.25, 0.15, 0.1) $$\nAll arguments are positive. The standard minmod function for positive arguments returns the minimum value:\n$$ \\hat{u}_{i,1}^{\\text{new}} = \\min(0.25, 0.15, 0.1) = 0.1 $$\n\nThe limited linear modal coefficient is $0.1$. The problem only asks for the new linear coefficient $\\hat{u}_{i,1}^{\\text{new}}$. Depending on the specific limiter implementation, the quadratic coefficient $\\hat{u}_{i,2}$ might be set to zero or left unchanged. Following the prompt, we only provide the result for $\\hat{u}_{i,1}$.",
            "answer": "$$\\boxed{0.1}$$"
        },
        {
            "introduction": "For nonlinear conservation laws, stability is a subtle issue that goes beyond just controlling shocks. This hands-on coding practice explores the concept of aliasing error, which arises from the inexact quadrature of nonlinear flux terms and can lead to non-physical entropy production and instability . By comparing a standard collocation scheme with a de-aliased version, you will directly measure this effect and develop a deeper appreciation for the importance of entropy stability in numerical methods for CFD.",
            "id": "3372750",
            "problem": "Consider the scalar conservation law in one spatial dimension on the reference element with coordinate $x \\in [-1,1]$,\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\n$$\nwith nonlinear flux $f(u) = u^3$. Use the Discontinuous Galerkin (DG) finite element method in a nodal formulation on a single periodic element with polynomial degree $p$ and Legendre-Gauss-Lobatto (LGL) nodes. Assume periodic boundary conditions so that interface flux contributions vanish for central numerical fluxes on this single element.\n\nDefine the mathematical entropy $\\eta(u) = \\tfrac{1}{2} u^2$ with corresponding continuous entropy flux $\\psi(u)$ satisfying $\\psi'(u) = \\eta'(u) f'(u)$; for $f(u)=u^3$ this gives $\\psi(u) = \\tfrac{3}{4} u^4$. In the continuous, smooth setting with periodic boundaries, one has\n$$\n\\frac{d}{dt} \\int_{-1}^1 \\eta(u(x,t))\\,dx = -\\int_{-1}^1 \\partial_x \\psi(u(x,t))\\,dx = 0,\n$$\nwhich expresses entropy conservation.\n\nIn the nodal DG discretization on LGL nodes $x_i$ with corresponding quadrature weights $w_i$, let $u_i$ denote the nodal values of $u$. The collocation strong-form discretization of the volume term uses the LGL differentiation matrix $D$, yielding a semi-discrete right-hand side\n$$\n\\left(\\frac{d u}{dt}\\right)_i^{\\text{collocation}} = -\\sum_{j} D_{ij}\\, f(u_j).\n$$\nDefine the discrete entropy rate (with periodic boundaries and central flux so that only volume terms contribute)\n$$\n\\mathcal{R}^{\\text{collocation}} = \\sum_i w_i\\, \\eta'(u_i)\\, \\left(\\frac{d u}{dt}\\right)_i^{\\text{collocation}}.\n$$\nPerform a single forward Euler time increment of size $\\Delta t$ to define the entropy change\n$$\n\\Delta \\eta^{\\text{collocation}} = \\Delta t \\, \\mathcal{R}^{\\text{collocation}}.\n$$\n\nTo mitigate aliasing error, consider an alternative where the nonlinear flux $f(u)$ is first projected onto the degree-$p$ polynomial subspace by an $L^2$ projection:\n$$\nf_p(x) = \\sum_{n=0}^{p} a_n \\, P_n(x), \\quad a_n = \\frac{2n+1}{2} \\int_{-1}^{1} f(u(x))\\, P_n(x)\\, dx,\n$$\nwhere $P_n(x)$ are the Legendre polynomials. Approximate the integrals for $a_n$ using Gauss-Legendre quadrature with $Q$ points. For the purpose of this problem, interpret “exact integration” in the DG volume discretization as using a quadrature order $Q$ that is sufficiently high to exactly integrate all polynomial products arising after projection, and set $Q=2p+1$. Evaluate the projected flux at the LGL nodes to obtain nodal values $f_p(x_i)$, and then compute the semi-discrete right-hand side\n$$\n\\left(\\frac{d u}{dt}\\right)_i^{\\text{exact}} = -\\sum_{j} D_{ij}\\, f_p(x_j).\n$$\nDefine the discrete entropy rate and entropy change analogously,\n$$\n\\mathcal{R}^{\\text{exact}} = \\sum_i w_i\\, \\eta'(u_i)\\, \\left(\\frac{d u}{dt}\\right)_i^{\\text{exact}}, \\qquad \\Delta \\eta^{\\text{exact}} = \\Delta t \\, \\mathcal{R}^{\\text{exact}}.\n$$\n\nThe aliasing-induced entropy change is measured as\n$$\n\\Delta \\eta^{\\text{alias}} = \\Delta \\eta^{\\text{collocation}} - \\Delta \\eta^{\\text{exact}}.\n$$\n\nInitialize $u(x)$ by interpolating the function $u(x) = A \\sin(k x)$ onto the LGL nodes, where $A$ is the amplitude and $k$ is the wavenumber. Take $k = \\pi$ and interpret angles in radians.\n\nYour task is to implement the above nodal DG operators and compute $\\Delta \\eta^{\\text{collocation}}$, $\\Delta \\eta^{\\text{exact}}$, and $\\Delta \\eta^{\\text{alias}}$ for the following test suite of parameters $(p, A, \\Delta t)$:\n- Test case $1$: $(p, A, \\Delta t) = (3, 0.8, 10^{-3})$.\n- Test case $2$: $(p, A, \\Delta t) = (6, 0.8, 10^{-3})$.\n- Test case $3$: $(p, A, \\Delta t) = (2, 0.2, 10^{-3})$.\n- Test case $4$: $(p, A, \\Delta t) = (4, 0.0, 10^{-3})$.\n\nYour program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case contributes its triple as a list in the form $[\\Delta \\eta^{\\text{collocation}}, \\Delta \\eta^{\\text{exact}}, \\Delta \\eta^{\\text{alias}}]$. For example, the final output must have the format\n$$\n[[\\Delta \\eta^{\\text{collocation}}_1,\\Delta \\eta^{\\text{exact}}_1,\\Delta \\eta^{\\text{alias}}_1],[\\Delta \\eta^{\\text{collocation}}_2,\\Delta \\eta^{\\text{exact}}_2,\\Delta \\eta^{\\text{alias}}_2],\\ldots]\n$$\nAngles must be in radians. No physical units are involved. Each numerical answer must be a float. The output must adhere exactly to the specified single-line format.",
            "solution": "The user has requested the implementation of a nodal Discontinuous Galerkin (DG) method to study aliasing-induced entropy changes for a scalar nonlinear conservation law. I will first validate the problem statement and then, if valid, provide a complete solution.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0$ on the reference element $x \\in [-1,1]$.\n- **Nonlinear Flux**: $f(u) = u^3$.\n- **Discretization**: Nodal DG on a single periodic element with polynomial degree $p$ and Legendre-Gauss-Lobatto (LGL) nodes.\n- **Boundary Conditions**: Periodic, implying interface flux contributions with a central flux vanish.\n- **Entropy Pair**: Mathematical entropy $\\eta(u) = \\tfrac{1}{2} u^2$ and continuous entropy flux $\\psi(u) = \\tfrac{3}{4} u^4$.\n- **Initial Condition**: $u(x)$ is the interpolant of $A \\sin(k x)$ on the LGL nodes, with $k = \\pi$.\n- **Collocation Scheme**:\n    - Semi-discrete form: $\\left(\\frac{d u}{dt}\\right)_i^{\\text{collocation}} = -\\sum_{j} D_{ij}\\, f(u_j)$, where $D$ is the LGL differentiation matrix.\n    - Discrete entropy rate: $\\mathcal{R}^{\\text{collocation}} = \\sum_i w_i\\, \\eta'(u_i)\\, \\left(\\frac{d u}{dt}\\right)_i^{\\text{collocation}}$.\n    - Entropy change (Forward Euler): $\\Delta \\eta^{\\text{collocation}} = \\Delta t \\, \\mathcal{R}^{\\text{collocation}}$.\n- **\"Exact\" (De-aliased) Scheme**:\n    - Projected flux: $f_p(x) = \\sum_{n=0}^{p} a_n \\, P_n(x)$, with $P_n(x)$ being Legendre polynomials.\n    - Projection coefficients: $a_n = \\frac{2n+1}{2} \\int_{-1}^{1} f(u(x))\\, P_n(x)\\, dx$.\n    - Quadrature for projection: Gauss-Legendre quadrature with $Q=2p+1$ points.\n    - Semi-discrete form: $\\left(\\frac{d u}{dt}\\right)_i^{\\text{exact}} = -\\sum_{j} D_{ij}\\, f_p(x_j)$.\n    - Discrete entropy rate: $\\mathcal{R}^{\\text{exact}} = \\sum_i w_i\\, \\eta'(u_i)\\, \\left(\\frac{d u}{dt}\\right)_i^{\\text{exact}}$.\n    - Entropy change (Forward Euler): $\\Delta \\eta^{\\text{exact}} = \\Delta t \\, \\mathcal{R}^{\\text{exact}}$.\n- **Quantity to Measure**: Aliasing-induced entropy change, $\\Delta \\eta^{\\text{alias}} = \\Delta \\eta^{\\text{collocation}} - \\Delta \\eta^{\\text{exact}}$.\n- **Test Cases**:\n    1. $(p, A, \\Delta t) = (3, 0.8, 10^{-3})$\n    2. $(p, A, \\Delta t) = (6, 0.8, 10^{-3})$\n    3. $(p, A, \\Delta t) = (2, 0.2, 10^{-3})$\n    4. $(p, A, \\Delta t) = (4, 0.0, 10^{-3})$\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is scientifically sound. It addresses a fundamental topic in the numerical analysis of DG methods for conservation laws: the impact of aliasing from nonlinear terms on discrete entropy stability. The conservation law, flux function, and entropy pair are standard examples. The comparison between a standard collocation approach and a de-aliasing approach via $L^2$ projection is a classic technique. The derived entropy flux $\\psi(u)$ is correct for the given $\\eta(u)$ and $f(u)$.\n- **Well-Posedness**: The problem is well-posed. It provides a complete and unambiguous algorithm for computing the desired quantities. All variables, constants, and procedures are explicitly defined, leading to a unique numerical solution for each test case.\n- **Objectivity**: The problem is stated in precise, objective mathematical language, free from any subjective or ambiguous terminology.\n- **Flaw Analysis**:\n    1. **Scientific Unsoundness**: None. The mathematical and computational framework is standard in the field.\n    2. **Non-Formalizable**: None. The problem is explicitly formal and quantitative.\n    3. **Incomplete/Contradictory**: None. All required information is present. The use of a single periodic element is a valid simplification for isolating the behavior of the volume integral term.\n    4. **Unrealistic/Infeasible**: None. The specified parameters are well within the range of typical numerical experiments.\n    5. **Ill-Posed**: None. A unique solution exists for each test case.\n    6. **Trivial/Tautological**: No. While the case with $A=0$ is trivial, it serves as a valid sanity check within a larger, non-trivial test suite. The core problem requires substantive computation and addresses a meaningful concept.\n    7. **Unverifiable**: None. The results are fully reproducible through computation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Design\nThe solution requires implementing several components of a nodal Discontinuous Galerkin framework. The process for each test case $(p, A, \\Delta t)$ is as follows:\n\n1.  **Basis and Quadrature Setup**: For a given polynomial degree $p$, we first compute the $N = p+1$ Legendre-Gauss-Lobatto (LGL) nodes $x_i$ and corresponding quadrature weights $w_i$. The nodes are the roots of $(1-x^2)P'_p(x)$, and the weights are given by a standard formula involving the value of the Legendre polynomial $P_p(x)$ at these nodes. These can be computed using functionalities from `scipy.special`.\n\n2.  **Differentiation Matrix**: A differentiation matrix $D$ for the LGL nodes is constructed. The entry $D_{ij}$ represents the derivative of the $j$-th Lagrange basis polynomial evaluated at the $i$-th node.\n\n3.  **Initial State**: The initial state of the solution $u$ is defined by interpolating the function $u(x) = A \\sin(\\pi x)$ at the LGL nodes, yielding a vector of nodal values $u_i = u(x_i)$.\n\n4.  **Collocation Scheme Analysis**:\n    a. The nodal values of the flux, $f(u_i) = u_i^3$, are computed directly.\n    b. The semi-discrete time derivative is calculated using the differentiation matrix: $(\\frac{du}{dt})^{\\text{collocation}} = -D \\cdot f(u)$.\n    c. The corresponding entropy production rate is calculated via the discrete inner product $\\mathcal{R}^{\\text{collocation}} = \\sum_i w_i \\eta'(u_i) (\\frac{du}{dt})_i^{\\text{collocation}}$, where $\\eta'(u) = u$.\n    d. The total entropy change over a single time step $\\Delta t$ is $\\Delta \\eta^{\\text{collocation}} = \\Delta t \\cdot \\mathcal{R}^{\\text{collocation}}$.\n\n5.  **De-aliased (\"Exact\") Scheme Analysis**:\n    a. This scheme requires performing an $L^2$ projection of the nonlinear flux term $f(u_h(x)) = (u_h(x))^3$ onto the polynomial space $\\mathbb{P}_p$. Here, $u_h(x)$ is the degree-$p$ polynomial that interpolates the nodal values $u_i$.\n    b. The projection involves computing the Legendre spectral coefficients $a_n$ for $n=0, \\dots, p$. The integrals are evaluated numerically using a high-order Gauss-Legendre quadrature rule with $Q=2p+1$ points. This order is sufficient to exactly integrate the polynomial products that arise.\n    c. To perform the integration, the polynomial $u_h(x)$ must be evaluated at the $Q$ Gauss-Legendre points. This is achieved by using Lagrange interpolation from the LGL nodes to the Gauss-Legendre nodes.\n    d. Once the coefficients $a_n$ are known, the projected flux polynomial $f_p(x) = \\sum_{n=0}^p a_n P_n(x)$ is evaluated at the LGL nodes $x_i$ to obtain nodal values $f_p(x_i)$.\n    e. The semi-discrete time derivative is then computed as $(\\frac{du}{dt})^{\\text{exact}} = -D \\cdot f_p$.\n    f. The entropy production rate $\\mathcal{R}^{\\text{exact}}$ and total change $\\Delta \\eta^{\\text{exact}}$ are calculated analogously to the collocation scheme.\n\n6.  **Aliasing Error Calculation**: The aliasing-induced entropy change is the difference between the results of the two schemes: $\\Delta \\eta^{\\text{alias}} = \\Delta \\eta^{\\text{collocation}} - \\Delta \\eta^{\\text{exact}}$. This quantity isolates the effect of aliasing error inherent in the simple collocation approach.\n\nThis procedure will be executed for each test case specified in the problem statement. The case $A=0$ serves as a null test, where all computed entropy changes are expected to be zero, confirming the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, roots_legendre, eval_legendre\n\ndef lgl_nodes_weights(p):\n    \"\"\"\n    Computes the p+1 Legendre-Gauss-Lobatto (LGL) nodes and quadrature weights.\n    The nodes are the roots of (1-x^2)P'_p(x).\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x)\n    nodes_interior, _ = roots_jacobi(p - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], nodes_interior, [1.0]))\n    \n    # Weights using the formula w_i = 2 / (p(p+1) [P_p(x_i)]^2)\n    weights = 2.0 / (p * (p + 1) * eval_legendre(p, nodes)**2)\n    return nodes, weights\n\ndef lgl_diff_matrix(p, nodes):\n    \"\"\"\n    Computes the (p+1)x(p+1) LGL differentiation matrix.\n    \"\"\"\n    N = p + 1\n    D = np.zeros((N, N))\n    Lp_nodes = eval_legendre(p, nodes)\n    \n    # Off-diagonal entries\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                D[i, j] = (Lp_nodes[i] / Lp_nodes[j]) / (nodes[i] - nodes[j])\n    \n    # Diagonal entries\n    D[0, 0] = -p * (p + 1) / 4.0\n    D[N - 1, N - 1] = p * (p + 1) / 4.0\n    \n    return D\n\ndef lagrange_basis_val(nodes, j, x_eval):\n    \"\"\"\n    Evaluates the j-th Lagrange basis polynomial for a given set of nodes at a point x_eval.\n    \"\"\"\n    val = 1.0\n    for k in range(len(nodes)):\n        if k != j:\n            val *= (x_eval - nodes[k]) / (nodes[j] - nodes[k])\n    return val\n\ndef solve_case(p, A, dt):\n    \"\"\"\n    Solves the problem for a single parameter set (p, A, dt).\n    \"\"\"\n    if A == 0.0:\n        return [0.0, 0.0, 0.0]\n\n    k = np.pi\n    N = p + 1\n\n    # 1. Setup: LGL nodes, weights, differentiation matrix\n    x_lgl, w_lgl = lgl_nodes_weights(p)\n    D = lgl_diff_matrix(p, x_lgl)\n    \n    # Initialize solution u at LGL nodes\n    u_nodes = A * np.sin(k * x_lgl)\n    eta_prime = u_nodes  # For eta(u) = 1/2 u^2, eta'(u) = u\n\n    # 2. Collocation Scheme\n    f_u_coll = u_nodes**3\n    dudt_coll = -D @ f_u_coll\n    \n    R_coll = np.sum(w_lgl * eta_prime * dudt_coll)\n    delta_eta_coll = dt * R_coll\n\n    # 3. \"Exact\" (De-aliased) Scheme\n    # L2 projection of f(u_h) onto P^p using Q=2p+1 point Gauss-Legendre quadrature\n    Q = 2 * p + 1\n    x_gl, w_gl = roots_legendre(Q)\n\n    # Interpolate u_h from LGL nodes to GL quadrature nodes\n    u_at_gl = np.zeros(Q)\n    for q in range(Q):\n        for j in range(N):\n            u_at_gl[q] += u_nodes[j] * lagrange_basis_val(x_lgl, j, x_gl[q])\n\n    # Evaluate f(u_h) at GL nodes\n    f_at_gl = u_at_gl**3\n\n    # Compute Legendre coefficients 'a_n' of the projection\n    a_coeffs = np.zeros(p + 1)\n    for n in range(p + 1):\n        P_n_at_gl = eval_legendre(n, x_gl)\n        integral = np.sum(w_gl * f_at_gl * P_n_at_gl)\n        a_coeffs[n] = (2 * n + 1) / 2.0 * integral\n    \n    # Evaluate the projected polynomial f_p at LGL nodes\n    f_p_nodes = np.zeros(N)\n    for i in range(N):\n        for n in range(p + 1):\n            f_p_nodes[i] += a_coeffs[n] * eval_legendre(n, x_lgl[i])\n\n    dudt_exact = -D @ f_p_nodes\n    R_exact = np.sum(w_lgl * eta_prime * dudt_exact)\n    delta_eta_exact = dt * R_exact\n\n    # 4. Aliasing-induced entropy change\n    delta_eta_alias = delta_eta_coll - delta_eta_exact\n    \n    return [delta_eta_coll, delta_eta_exact, delta_eta_alias]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0.8, 1e-3), # Test case 1\n        (6, 0.8, 1e-3), # Test case 2\n        (2, 0.2, 1e-3), # Test case 3\n        (4, 0.0, 1e-3), # Test case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        p, A, dt = case\n        result_triple = solve_case(p, A, dt)\n        results.append(result_triple)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list is '[item1, item2, ...]'\n    # which matches the required sub-format for each triple.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}