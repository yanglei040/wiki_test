{
    "hands_on_practices": [
        {
            "introduction": "The power of Fourier-spectral methods lies in their ability to transform complex calculus operations, like differentiation, into simple algebraic multiplication in frequency space. This exercise guides you through the fundamental process of computing a spatial derivative by multiplying Fourier coefficients by the wavenumber, a cornerstone of the entire method . By implementing this with the Fast Fourier Transform (FFT) and comparing the numerical result to the exact derivative, you will directly observe and quantify the famed \"spectral accuracy\" in action.",
            "id": "3396179",
            "problem": "You are given a smooth $2\\pi$-periodic function $f$ sampled at $N$ equispaced grid points on the interval $[0,2\\pi)$. Let the grid be $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$, and denote the samples by $f_j = f(x_j)$. The goal is to compute the spectral approximation to the derivative $f'(x)$ at the grid points via the Fast Fourier Transform (FFT), and then to quantify the accuracy using both the $L^2$ error and the pointwise (infinity) error.\n\nStart from the following fundamental base:\n- The complex Fourier series for a smooth $2\\pi$-periodic function $f$ is $f(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_k e^{ikx}$, where $\\hat{f}_k$ are the Fourier coefficients. Differentiation in physical space corresponds to multiplication by $ik$ in Fourier space: $f'(x) = \\sum_{k\\in\\mathbb{Z}} (ik)\\hat{f}_k e^{ikx}$.\n- The Discrete Fourier Transform (DFT) maps $N$ equispaced samples $\\{f_j\\}_{j=0}^{N-1}$ to a set of discrete Fourier modes that represent integer wavenumbers consistent with the sampling grid and periodicity. The inverse DFT reconstructs the function values at the grid points from these modes.\n- The discrete trapezoidal rule on an equispaced periodic grid approximates the continuous $L^2$ norm with spectral accuracy for smooth periodic functions.\n\nFrom these principles, derive the algorithm to compute the spectral derivative at the grid points by:\n1. Applying the DFT to $\\{f_j\\}$ to obtain discrete Fourier modes associated with integer wavenumbers $k$.\n2. Multiplying each mode by $ik$ to represent differentiation in Fourier space.\n3. Applying the inverse DFT (IDFT) to return to physical space, yielding the spectral approximation to $\\{f'(x_j)\\}$.\n\nImplement this algorithm using the Fast Fourier Transform (FFT) and its inverse to ensure computational efficiency. Explicitly construct the integer wavenumber vector $k$ that is consistent with the DFT ordering induced by the FFT on the interval $[0,2\\pi)$, and ensure your implementation correctly handles both even and odd values of $N$. Use angles in radians.\n\nFor each test case, compute:\n- The $L^2$ error, defined as $\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N-1} |e_j|^2 \\,\\Delta x\\right)^{1/2}$, where $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$ is the pointwise error at $x_j$ and $\\Delta x = \\frac{2\\pi}{N}$.\n- The pointwise (infinity) error, defined as $\\|e\\|_{\\infty} = \\max_{0\\le j\\le N-1} |e_j|$.\n\nYour program must compute these two error metrics for each test case specified below. Round each floating-point error to $8$ decimal places before producing the final output.\n\nTest suite (use exactly these functions and resolutions):\n- Case $1$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=16$.\n- Case $2$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=64$.\n- Case $3$: $f_2(x) = \\exp(\\sin x)$ with $N=32$.\n- Case $4$: $f_2(x) = \\exp(\\sin x)$ with $N=128$.\n- Case $5$: $f_3(x) = \\sin(20x)$ with $N=32$.\n- Case $6$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=8$.\n\nFor each case, use the exact derivatives:\n- $f_1'(x) = 3\\cos(3x) - 5\\sin(5x)$.\n- $f_2'(x) = \\cos(x)\\exp(\\sin x)$.\n- $f_3'(x) = 20\\cos(20x)$.\n\nAll trigonometric arguments are in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list containing the $L^2$ error and the infinity error, in that order, both rounded to $8$ decimal places. For example, the output should look like: \"[[e21,einf1],[e22,einf2],...]\" with no spaces. Ensure the results appear in the exact order of Cases $1$ through $6$ as listed above.",
            "solution": "The problem requires the computation of the derivative of a smooth $2\\pi$-periodic function using a Fourier spectral method, and the quantification of the method's accuracy. The solution is derived from the fundamental principles of Fourier analysis.\n\nThe core principle of spectral methods is that operations in physical space, such as differentiation, correspond to simpler algebraic operations in frequency (or Fourier) space. For a smooth $2\\pi$-periodic function $f(x)$ with a continuous Fourier series representation:\n$$\nf(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx}\n$$\nwhere $\\hat{f}_k$ are the continuous Fourier coefficients and $k$ are the integer wavenumbers. Differentiating with respect to $x$ yields:\n$$\nf'(x) = \\frac{d}{dx} \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx} = \\sum_{k \\in \\mathbb{Z}} (ik) \\hat{f}_k e^{ikx}\n$$\nThis shows that differentiation in physical space is equivalent to multiplying each Fourier coefficient $\\hat{f}_k$ by the factor $ik$.\n\nIn a computational setting, we work with a discrete representation of the function. The function $f(x)$ is sampled on a uniform grid of $N$ points in the interval $[0, 2\\pi)$:\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1\n$$\nThe function values on this grid are $f_j = f(x_j)$. The discrete analogue of the Fourier series is the Discrete Fourier Transform (DFT). The DFT of the sequence $\\{f_j\\}_{j=0}^{N-1}$ is a set of $N$ complex coefficients, which we denote as $\\hat{f}^N$, computed via the Fast Fourier Transform (FFT) algorithm:\n$$\n\\hat{f}^N_k = \\sum_{j=0}^{N-1} f_j e^{-i \\frac{2\\pi kj}{N}}, \\quad k = 0, 1, \\dots, N-1\n$$\nThe original function values can be reconstructed perfectly from these coefficients using the inverse DFT (IDFT), typically computed via the Inverse FFT (IFFT):\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{i \\frac{2\\pi kj}{N}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{ik_{\\text{phys}}(k) x_j}\n$$\nThe indices $k$ of the DFT output must be mapped to their corresponding physical integer wavenumbers, denoted $k_{\\text{phys}}(k)$. For a sequence of length $N$, the DFT coefficients correspond to wavenumbers that are aliased into the range that can be resolved by the grid. Standard FFT libraries, such as NumPy's, order the corresponding integer wavenumbers as follows:\n- For $k = 0, \\dots, \\lfloor (N-1)/2 \\rfloor$: wavenumbers are $0, 1, \\dots, \\lfloor (N-1)/2 \\rfloor$.\n- For $k = \\lfloor (N-1)/2 \\rfloor + 1, \\dots, N-1$: wavenumbers are $\\lfloor -N/2 \\rfloor, \\dots, -1$.\nA robust way to generate this vector of wavenumbers, let's call it $k_{\\text{phys}}$, is provided by standard libraries.\n\nTo compute the derivative, we apply the differentiation-multiplication principle to the discrete coefficients:\n$$\n\\widehat{(f')}^N_k = (i k_{\\text{phys}}(k)) \\hat{f}^N_k\n$$\nA crucial subtlety arises for an even number of points $N$. The grid can represent a frequency component corresponding to the Nyquist wavenumber, $k = N/2$. On the grid points $x_j$, the function $\\cos((N/2)x_j) = \\cos(\\pi j) = (-1)^j$. Its analytical derivative is $-(N/2)\\sin((N/2)x)$, which evaluates to $-(N/2)\\sin(\\pi j) = 0$ at all grid points. To ensure that the numerical derivative of a real-valued function is also real-valued, and to be consistent with the behavior of functions on the grid, the derivative of the Nyquist mode is conventionally set to zero. This is achieved by setting the component of the wavenumber vector $k_{\\text{phys}}$ corresponding to the Nyquist frequency to $0$. For an odd number of points $N$, no such special handling is required as there is no single Nyquist frequency.\n\nThe algorithm for computing the spectral derivative $\\{f'_{\\text{spec}}(x_j)\\}$ is as follows:\n1.  Compute the discrete function samples $\\{f_j\\}$ on the grid $\\{x_j\\}$.\n2.  Apply the FFT to $\\{f_j\\}$ to obtain the discrete Fourier coefficients $\\{\\hat{f}^N_k\\}$.\n3.  Construct the vector of physical integer wavenumbers $\\{k_{\\text{phys}}\\}$. For even $N$, set the element corresponding to the Nyquist frequency to $0$.\n4.  Multiply the Fourier coefficients by $ik_{\\text{phys}}$ to obtain the coefficients of the derivative, $\\{\\widehat{(f')}^N_k\\} = \\{i k_{\\text{phys}}(k) \\hat{f}^N_k\\}$.\n5.  Apply the IFFT to $\\{\\widehat{(f')}^N_k\\}$ to obtain the spectral derivative values $\\{f'_{\\text{spec}}(x_j)\\}$ in physical space. The result should be real up to machine precision; taking the real part discards any small imaginary component due to floating-point error.\n\nFinally, to assess the accuracy, we compute the error vector $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$. The accuracy is quantified using two norms:\n- The discrete $L^2$ error, which approximates the continuous $L^2$ norm:\n$$\n\\|e\\|_{L^2} \\approx \\left( \\sum_{j=0}^{N-1} |e_j|^2 \\Delta x \\right)^{1/2}\n$$\nwhere the grid spacing is $\\Delta x = 2\\pi/N$.\n- The pointwise infinity error, which measures the maximum absolute error on the grid:\n$$\n\\|e\\|_{\\infty} = \\max_{0 \\le j \\le N-1} |e_j|\n$$\nThe implementation will apply this complete procedure to each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spectral derivatives and errors for a suite of test cases.\n    \"\"\"\n\n    # Define the functions and their exact derivatives for the test cases.\n    def f1(x):\n        return np.sin(3 * x) + np.cos(5 * x)\n\n    def f1_prime(x):\n        return 3 * np.cos(3 * x) - 5 * np.sin(5 * x)\n\n    def f2(x):\n        return np.exp(np.sin(x))\n\n    def f2_prime(x):\n        return np.cos(x) * np.exp(np.sin(x))\n\n    def f3(x):\n        return np.sin(20 * x)\n\n    def f3_prime(x):\n        return 20 * np.cos(20 * x)\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        {'N': 16, 'func': f1, 'deriv': f1_prime},\n        {'N': 64, 'func': f1, 'deriv': f1_prime},\n        {'N': 32, 'func': f2, 'deriv': f2_prime},\n        {'N': 128, 'func': f2, 'deriv': f2_prime},\n        {'N': 32, 'func': f3, 'deriv': f3_prime},\n        {'N': 8, 'func': f1, 'deriv': f1_prime},\n    ]\n\n    results_str = []\n    \n    for case in test_cases:\n        N = case['N']\n        f = case['func']\n        f_prime_exact_func = case['deriv']\n\n        # 1. Create the grid an sample the function.\n        # The domain is [0, 2*pi), so the grid is x_j = 2*pi*j / N.\n        x = np.arange(N) * (2 * np.pi / N)\n        f_values = f(x)\n        \n        # 2. Compute the FFT of the signal.\n        f_hat = np.fft.fft(f_values)\n\n        # 3. Construct the wavenumber vector for differentiation.\n        # numpy.fft.fftfreq(N) returns the unique sampling frequencies.\n        # We multiply by N to get the integer wavenumbers.\n        k = np.fft.fftfreq(N) * N\n        \n        # 4. Handle the Nyquist frequency for even N.\n        # For a real signal, the derivative of the Nyquist mode must be zero\n        # to ensure the derivative is real-valued.\n        if N % 2 == 0:\n            k[N // 2] = 0\n\n        # 5. Differentiate in Fourier space.\n        f_prime_hat = 1j * k * f_hat\n        \n        # 6. Apply inverse FFT to get the derivative in physical space.\n        f_prime_spec = np.fft.ifft(f_prime_hat)\n        \n        # The result must be real for a real input function. Take the real part\n        # to discard any small imaginary noise from floating-point inaccuracies.\n        f_prime_spec = np.real(f_prime_spec)\n        \n        # 7. Compute the exact derivative at the grid points.\n        f_prime_exact = f_prime_exact_func(x)\n        \n        # 8. Calculate the error vector.\n        error_vec = f_prime_spec - f_prime_exact\n        \n        # 9. Compute the L2 and infinity error norms.\n        delta_x = 2 * np.pi / N\n        l2_error = np.sqrt(np.sum(error_vec**2) * delta_x)\n        inf_error = np.max(np.abs(error_vec))\n\n        # 10. Format and store the results.\n        l2_error_str = f\"{l2_error:.8f}\"\n        inf_error_str = f\"{inf_error:.8f}\"\n        results_str.append(f\"[{l2_error_str},{inf_error_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from a single operation to solving a full partial differential equation (PDE), this practice tackles the linear advection-diffusion equation. Because the equation is linear, each Fourier mode evolves independently, allowing us to derive an exact analytical solution in time for the coefficients. This provides a perfect testbed to validate a numerical scheme and precisely quantify spectral truncation error by comparing a finite-mode simulation to a high-resolution reference .",
            "id": "3321599",
            "problem": "Consider the one-dimensional, periodic initial-value problem on the spatial domain $[0, 2\\pi)$ governed by the linear advection-diffusion equation. Let $u(x,t)$ denote a sufficiently smooth scalar field with $x \\in [0, 2\\pi)$ and $t \\ge 0$. The fundamental base for the analysis is the definition of the Fourier series on a periodic domain, the definition of the spatial derivatives of periodic functions in terms of their Fourier series, and the linearity and time-invariance of the constant-coefficient advection-diffusion operator. Assume $u(x,t)$ admits a Fourier series representation with coefficients that depend on time, and that evolving each Fourier mode under the linear operator is well-defined.\n\nDefine the initial condition in Fourier space by the coefficients $a_k$, for all integers $k \\in \\mathbb{Z}$, where\n$$\na_0 = 0, \\quad a_k = \\exp\\left(-\\beta k^2\\right)\\ \\text{for}\\ k \\ne 0,\n$$\nwith a given positive parameter $\\beta  0$. The spatial field is the inverse Fourier series of the coefficients. The partial differential equation is driven by constant advection speed $c$ and diffusion coefficient $\\nu$, both real parameters, and the solution stays $2\\pi$-periodic for all time. All angle quantities (spatial arguments within trigonometric or complex exponential functions) must be treated in radians.\n\nYour task is to design and implement a computation that validates spectral accuracy in space by comparing a truncated Fourier-spectral numerical solution against an exact modal evolution reference solution. You must proceed as follows, starting only from the fundamental base described above:\n\n- Represent the periodic solution $u(x,t)$ in terms of its Fourier series and use the properties of spatial derivatives acting on Fourier modes to derive the evolution law for the modal amplitudes $a_k(t)$ under the given linear operator. Do not assume any shortcut formulas; derive the modal evolution from first principles and core definitions.\n\n- Construct a numerical solution at a given time $t$ by truncating the Fourier series to the largest integer wavenumber magnitude permitted by a uniform collocation grid of $N$ points over $[0, 2\\pi)$ and evolving those truncated modes exactly in time according to the derived modal evolution law. Then, synthesize the truncated field on the collocation grid by summing the truncated set of evolved modes.\n\n- Construct a reference solution at the same time $t$ by using a significantly larger cutoff $K_{\\text{ref}}$ to approximate the true infinite Fourier series. Use the same derived modal evolution law for the reference modes and synthesize the reference field on the same grid by summation. For this problem, take $K_{\\text{ref}} = 4N$.\n\n- Quantify the spatial spectral error by the relative discrete $L^2$ norm on the collocation grid, defined as the ratio of the discrete $L^2$ norm of the difference between the numerical and reference fields to the discrete $L^2$ norm of the reference field. All norms are computed using the grid-weighted Euclidean norm over $[0, 2\\pi)$; no physical units are involved, and all outputs are dimensionless.\n\nImplement the computation for the following test suite of parameter values, with the initial condition parameter set to $\\beta = 0.3$ in all cases:\n\n$1.$ $(N, c, \\nu, t) = (64, 1.0, 0.1, 0.5)$\n\n$2.$ $(N, c, \\nu, t) = (16, 1.0, 0.1, 0.5)$\n\n$3.$ $(N, c, \\nu, t) = (64, 0.7, 0.0, 1.0)$\n\n$4.$ $(N, c, \\nu, t) = (64, 0.0, 0.2, 2.0)$\n\n$5.$ $(N, c, \\nu, t) = (64, 1.0, 0.1, 0.0)$\n\nYour program must produce the relative discrete $L^2$ error for each case as floating-point numbers. The final output format must be a single line containing the list of the five errors as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3,e_4,e_5]$. No other text should be printed. All computations must use radians for any angular quantities. No physical units are involved, so no additional unit specifications are required.",
            "solution": "The problem requires the derivation of the modal evolution law for the linear advection-diffusion equation on a periodic domain and its use in a numerical validation study. The validation compares a truncated Fourier-spectral solution against a high-resolution reference solution.\n\nThe governing partial differential equation (PDE) for the scalar field $u(x,t)$ on the domain $x \\in [0, 2\\pi)$ is the one-dimensional advection-diffusion equation with constant advection speed $c$ and diffusion coefficient $\\nu$:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n\nThe solution $u(x,t)$ is assumed to be $2\\pi$-periodic in space, which allows for a representation as a complex Fourier series:\n$$\nu(x, t) = \\sum_{k=-\\infty}^{\\infty} a_k(t) e^{ikx}\n$$\nwhere $k$ are the integer wavenumbers, $e^{ikx}$ are the Fourier basis functions, and $a_k(t)$ are the time-dependent complex Fourier coefficients (modal amplitudes).\n\nTo derive the evolution law for the coefficients $a_k(t)$, we substitute the Fourier series representation into the PDE. This requires computing the derivatives of $u(x,t)$ term-by-term, which is permissible for a sufficiently smooth field:\nThe time derivative is:\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\sum_{k=-\\infty}^{\\infty} a_k(t) e^{ikx} = \\sum_{k=-\\infty}^{\\infty} \\frac{d a_k(t)}{dt} e^{ikx}\n$$\nThe first spatial derivative is:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\sum_{k=-\\infty}^{\\infty} a_k(t) e^{ikx} = \\sum_{k=-\\infty}^{\\infty} a_k(t) (ik) e^{ikx}\n$$\nThe second spatial derivative is:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\sum_{k=-\\infty}^{\\infty} a_k(t) e^{ikx} = \\sum_{k=-\\infty}^{\\infty} a_k(t) (ik)^2 e^{ikx} = \\sum_{k=-\\infty}^{\\infty} a_k(t) (-k^2) e^{ikx}\n$$\nSubstituting these expressions into the PDE yields:\n$$\n\\sum_{k=-\\infty}^{\\infty} \\frac{d a_k(t)}{dt} e^{ikx} + c \\left( \\sum_{k=-\\infty}^{\\infty} (ik) a_k(t) e^{ikx} \\right) = \\nu \\left( \\sum_{k=-\\infty}^{\\infty} (-k^2) a_k(t) e^{ikx} \\right)\n$$\nBy the linearity of the summation, we can combine the terms:\n$$\n\\sum_{k=-\\infty}^{\\infty} \\left[ \\frac{d a_k(t)}{dt} + c(ik)a_k(t) - \\nu(-k^2)a_k(t) \\right] e^{ikx} = 0\n$$\n$$\n\\sum_{k=-\\infty}^{\\infty} \\left[ \\frac{d a_k(t)}{dt} + (ick + \\nu k^2)a_k(t) \\right] e^{ikx} = 0\n$$\nDue to the orthogonality of the Fourier basis functions $\\{e^{ikx}\\}_{k \\in \\mathbb{Z}}$, the expression in the brackets must be zero for each individual wavenumber $k$. This transforms the PDE into an infinite set of independent ordinary differential equations (ODEs), one for each mode $a_k(t)$:\n$$\n\\frac{d a_k(t)}{dt} = -(ick + \\nu k^2) a_k(t)\n$$\nThis is a first-order linear homogeneous ODE for $a_k(t)$ with a constant coefficient. Given the initial condition $a_k(0)$, the solution is found by direct integration:\n$$\na_k(t) = a_k(0) \\exp\\left(-(ick + \\nu k^2) t\\right)\n$$\nThis is the exact evolution law for each Fourier mode. The advection term, $-ick t$, contributes a phase rotation, while the diffusion term, $-\\nu k^2 t$, contributes an exponential decay.\n\nThe computational procedure is as follows:\n\n1.  **Define the Grid and Initial Conditions**: A uniform grid of $N$ points is defined as $x_j = j \\frac{2\\pi}{N}$ for $j=0, 1, \\dots, N-1$. The initial condition is specified in Fourier space by coefficients $a_k(0) = \\exp(-\\beta k^2)$ for $k \\ne 0$ and $a_0(0) = 0$, with $\\beta  0$.\n\n2.  **Construct the Numerical Solution**: The numerical solution $u_{\\text{num}}(x_j, t)$ is based on a truncated Fourier series. The set of wavenumbers is determined by the grid size $N$. For a grid of $N$ points, there are $N$ unique wavenumbers, which can be represented as $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ (for even $N$).\n    - We calculate the initial coefficients $a_k(0)$ for this truncated set of wavenumbers.\n    - We evolve each coefficient $a_k(0)$ to time $t$ using the derived evolution law: $a_k(t) = a_k(0) e^{-(ick + \\nu k^2) t}$.\n    - Finally, we synthesize the field $u_{\\text{num}}(x_j, t)$ on the grid by summing the evolved modes: $u_{\\text{num}}(x_j, t) = \\sum_{k} a_k(t) e^{ikx_j}$. This summation can be efficiently performed using an Inverse Fast Fourier Transform (IFFT).\n\n3.  **Construct the Reference Solution**: The reference solution $u_{\\text{ref}}(x_j, t)$ is an approximation of the true infinite series solution, constructed using a much larger set of Fourier modes. The cutoff wavenumber is set to $K_{\\text{ref}} = 4N$.\n    - The wavenumbers for the reference solution are $k \\in \\{-K_{\\text{ref}}, -K_{\\text{ref}}+1, \\dots, K_{\\text{ref}}\\}$.\n    - Initial coefficients $a_k(0)$ are computed for this extended set of wavenumbers.\n    - These coefficients are evolved to time $t$ using the same evolution law.\n    - The reference field is synthesized on the same $N$-point grid $x_j$ by performing a direct summation over all $2K_{\\text{ref}}+1$ modes: $u_{\\text{ref}}(x_j, t) = \\sum_{k=-K_{\\text{ref}}}^{K_{\\text{ref}}} a_k(t) e^{ikx_j}$.\n\n4.  **Quantify the Error**: The spectral error is measured by the relative discrete $L^2$ norm of the difference between the numerical and reference solutions on the grid:\n    $$\n    E = \\frac{\\| \\boldsymbol{u}_{\\text{num}} - \\boldsymbol{u}_{\\text{ref}} \\|_2}{\\| \\boldsymbol{u}_{\\text{ref}} \\|_2} = \\frac{\\sqrt{\\sum_{j=0}^{N-1} |u_{\\text{num}}(x_j, t) - u_{\\text{ref}}(x_j, t)|^2}}{\\sqrt{\\sum_{j=0}^{N-1} |u_{\\text{ref}}(x_j, t)|^2}}\n    $$\n    Since the initial condition is real and symmetric ($a_{-k}(0)=a_k(0)$), and the evolution preserves the property $a_{-k}(t) = a_k(t)^*$, the resulting field $u(x,t)$ is real. We take the real part of the numerically synthesized fields before computing the norm to discard any floating-point imaginary noise.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the advection-diffusion problem using a Fourier-spectral method\n    and computes the spectral error against a high-resolution reference solution.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1.0, 0.1, 0.5),\n        (16, 1.0, 0.1, 0.5),\n        (64, 0.7, 0.0, 1.0),\n        (64, 0.0, 0.2, 2.0),\n        (64, 1.0, 0.1, 0.0),\n    ]\n\n    # Shared parameter for all test cases.\n    beta = 0.3\n\n    results = []\n    for N, c, nu, t in test_cases:\n        # 1. Define the spatial grid\n        # Grid of N points on [0, 2*pi)\n        x_grid = np.linspace(0.0, 2.0 * np.pi, N, endpoint=False)\n\n        # 2. Construct the numerical solution (truncated series)\n        # Get the set of integer wavenumbers corresponding to the N-point grid\n        k_num = np.fft.fftfreq(N, d=1.0/N)\n\n        # Calculate initial coefficients a_k(0)\n        a_k0_num = np.exp(-beta * k_num**2)\n        # Set a_0(0) = 0 as per problem description\n        mask_k0_num = (k_num == 0)\n        a_k0_num[mask_k0_num] = 0.0\n\n        # Evolve coefficients to time t\n        exponent_num = (-1j * k_num * c - nu * k_num**2) * t\n        a_kt_num = a_k0_num * np.exp(exponent_num)\n\n        # Synthesize the numerical solution field on the grid using IFFT\n        # The sum definition u = sum(a_k * exp(ikx)) corresponds to ifft(a_k) * N\n        u_num_complex = np.fft.ifft(a_kt_num) * N\n        # The solution should be real; take the real part to discard numerical noise\n        u_num = np.real(u_num_complex)\n        \n        # 3. Construct the reference solution (high-resolution series)\n        # Set the high-resolution cutoff wavenumber\n        K_ref = 4 * N\n        \n        # Define the extended set of wavenumbers for the reference solution\n        k_ref = np.arange(-K_ref, K_ref + 1)\n        \n        # Calculate initial coefficients a_k(0) for the reference set\n        a_k0_ref = np.exp(-beta * k_ref**2)\n        # Set a_0(0) = 0\n        mask_k0_ref = (k_ref == 0)\n        a_k0_ref[mask_k0_ref] = 0.0\n        \n        # Evolve reference coefficients to time t\n        exponent_ref = (-1j * k_ref * c - nu * k_ref**2) * t\n        a_kt_ref = a_k0_ref * np.exp(exponent_ref)\n        \n        # Synthesize the reference field on the N-point grid via direct summation\n        # This is u_ref(x) = sum_{k=-K_ref}^{K_ref} a_k(t) * exp(ikx)\n        # Vectorized implementation:\n        # outer(k, x) creates a matrix of k*x products\n        # exp(1j * ...) creates the Fourier basis matrix\n        fourier_basis = np.exp(1j * np.outer(k_ref, x_grid))\n        # Dot product sums the coefficients against the basis functions for each x_j\n        u_ref_complex = np.dot(a_kt_ref, fourier_basis)\n        # The solution should be real\n        u_ref = np.real(u_ref_complex)\n\n        # 4. Quantify the relative L2 error\n        # Avoid division by zero if the reference solution is identically zero\n        norm_u_ref = np.linalg.norm(u_ref)\n        if norm_u_ref == 0.0:\n            # If ref is zero, error is zero only if num is also zero\n            error = np.linalg.norm(u_num)\n        else:\n            error = np.linalg.norm(u_num - u_ref) / norm_u_ref\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world fluid dynamics simulations are dominated by nonlinear phenomena, which introduce unique challenges not present in linear systems. This exercise explores the critical concept of aliasing, a numerical artifact from nonlinear interactions in pseudo-spectral methods that can violate fundamental physical conservation laws . Simulating the inviscid Burgers' equation, you will witness this error firsthand and learn to implement the standard two-thirds dealiasing rule to restore the simulation's physical fidelity.",
            "id": "3396162",
            "problem": "Consider the periodic initial-value problem for the inviscid Burgers equation on the interval $[0,2\\pi]$,\n$$\nu_t(x,t) + u(x,t)\\,u_x(x,t) = 0, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\nwith periodic boundary conditions and a smooth initial condition $u(x,0) = \\sin(x)$. The continuous $L^2$ energy\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx\n$$\nis conserved for sufficiently smooth solutions prior to shock formation.\n\nIn a Fourier pseudo-spectral discretization, the nonlinear term $u\\,u_x$ is computed by transforming to physical space, multiplying pointwise, and transforming back to Fourier space. However, the discrete convolution is truncated to the available modes, and this can introduce aliasing errors that break discrete conservation. A common remedy is dealiasing using the two-thirds rule, which sets to zero all Fourier modes with wavenumber magnitude greater than $N/3$ for a grid with $N$ points when evaluating quadratic nonlinearities.\n\nYour task is to write a complete, runnable program that:\n- Discretizes the spatial domain $[0,2\\pi]$ with $N$ equispaced points and represents $u$ by its discrete Fourier transform.\n- Uses a Fourier pseudo-spectral method to compute spatial derivatives, with two variants for the nonlinear term $u\\,u_x$:\n  1. An aliasing variant (no dealiasing): compute $u\\,u_x$ via pointwise multiplication in physical space and transform back without truncation.\n  2. A dealiased variant using the two-thirds rule: before forming the nonlinear product, project the field onto Fourier modes with $|k|\\le N/3$, compute the product in physical space, and project the resulting Fourier transform back onto $|k|\\le N/3$.\n- Advances the solution in time using the explicit fourth-order Rungeâ€“Kutta method with a fixed time step $\\Delta t$ up to a specified final time $T$.\n- Computes the discrete $L^2$ energy at times $t=0$ and $t=T$ using the trapezoidal rule (which is exact for equispaced samples of periodic functions), namely\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2,\n$$\nwhere $\\Delta x = 2\\pi/N$ and $x_j = j\\,\\Delta x$.\n- Returns, for each test case, the energy drift $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$ as a float in dimensionless units.\n\nBase your derivation and implementation on the following foundational facts:\n- The inviscid Burgers equation $u_t + u u_x = 0$ has a continuous energy conservation law $dE/dt = 0$ prior to shock formation.\n- The Fourier transform turns derivatives into multipliers: if $\\widehat{u}(k)$ denotes the discrete Fourier coefficients at wavenumber $k$, then $u_x$ corresponds to multiplication by $\\mathrm{i}k$ in Fourier space.\n- The pseudo-spectral product of two fields corresponds to a discrete convolution in Fourier space that is truncated to the resolved modes, potentially causing aliasing if nonlinear interactions generate unresolved modes.\n- The two-thirds dealiasing rule for quadratic nonlinearities ensures that the convolution of two truncated spectra does not alias into the resolved band: modes with $|k|  N/3$ are set to zero during nonlinear product evaluation.\n\nEnsure scientific realism by keeping the final times strictly below the shock time. For $u(x,0) = \\sin(x)$, the shock time is $t_s = 1$ because $\\min_x u_x(x,0) = -1$.\n\nTest Suite:\nUse the following parameter sets, where each test case is a tuple $(N,T,\\text{dealias})$ with $N$ the number of grid points, $T$ the final time, and $\\text{dealias}$ a string equal to \"none\" or \"2/3\" indicating the nonlinear evaluation variant.\n- Test 1 (happy path, moderate resolution, aliasing present): $(64,\\,0.5,\\,\\text{\"none\"})$.\n- Test 2 (happy path, moderate resolution, dealiasing applied): $(64,\\,0.5,\\,\\text{\"2/3\"})$.\n- Test 3 (edge case, coarse resolution, aliasing present): $(16,\\,0.5,\\,\\text{\"none\"})$.\n- Test 4 (boundary case near shock time, dealiasing applied): $(64,\\,0.95,\\,\\text{\"2/3\"})$.\n\nAll computations are dimensionless. Angles are measured in radians. Your program should produce a single line of output containing the energy drifts for the test suite as a comma-separated list enclosed in square brackets, for example,\n$$\n[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4],\n$$\nwhere each $\\delta E_i$ equals $E_{\\text{disc}}(T)-E_{\\text{disc}}(0)$ for the corresponding test case. The values should be output as decimal floats.\n\nThe program must be self-contained, use the Fast Fourier Transform (FFT), and follow the constraints specified for the execution environment. No external input is allowed, and no physical units are involved beyond the dimensionless specification above.",
            "solution": "The problem requires the numerical solution of the inviscid Burgers' equation, $u_t + u u_x = 0$, on a periodic domain $x \\in [0, 2\\pi]$ with the initial condition $u(x,0) = \\sin(x)$. The solution is to be obtained using a Fourier pseudo-spectral method, with time integration performed by the fourth-order Runge-Kutta (RK4) scheme. A key aspect is to compare the effect of aliasing errors on the discrete energy conservation by implementing two variants for the nonlinear term $u u_x$: one with no aliasing control and another employing the two-thirds dealiasing rule.\n\nThe core of the method is the semi-discretization of the partial differential equation (PDE). We represent the solution $u(x,t)$ at any time $t$ by its values on a grid of $N$ equispaced points, $x_j = j \\Delta x$ where $\\Delta x = 2\\pi/N$ for $j=0, 1, \\dots, N-1$. For a periodic function, this spatial representation is efficiently handled in Fourier space. Let $\\widehat{u}_k(t)$ be the discrete Fourier coefficient of $u(x,t)$ corresponding to wavenumber $k$. The set of all coefficients, $\\{\\widehat{u}_k(t)\\}$, constitutes the state of the system. The PDE is thus transformed into a system of ordinary differential equations (ODEs) for these coefficients:\n$$\n\\frac{d\\widehat{u}_k}{dt} = -\\mathcal{F}(u \\cdot u_x)_k\n$$\nwhere $\\mathcal{F}$ denotes the discrete Fourier transform and the subscript $k$ indicates the $k$-th Fourier coefficient of the term in parentheses.\n\nThe spatial derivative $u_x$ is computed exactly in Fourier space. The differentiation property of the Fourier transform states that a derivative $\\partial/\\partial x$ in real space corresponds to multiplication by $ik$ in Fourier space, where $i = \\sqrt{-1}$ and $k$ is the integer wavenumber. The wavenumbers for an $N$-point grid on $[0, 2\\pi]$ are given by the set $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$ (for $N$ even). Thus, the Fourier coefficients of the derivative, $\\widehat{(u_x)}_k$, are computed as:\n$$\n\\widehat{(u_x)}_k = i k \\widehat{u}_k\n$$\n\nThe primary challenge lies in computing the nonlinear term $u u_x$. In the pseudo-spectral (or collocation) method, this product is computed pointwise in physical space. The procedure is as follows:\n1.  Transform $\\widehat{u}_k$ and $\\widehat{(u_x)}_k$ to physical space using the inverse Fast Fourier Transform (IFFT) to obtain grid-point values $u(x_j)$ and $u_x(x_j)$.\n2.  Compute the pointwise product $p(x_j) = u(x_j) u_x(x_j)$.\n3.  Transform the product back to Fourier space using the Fast Fourier Transform (FFT) to get $\\widehat{p}_k = \\mathcal{F}(p)_k$.\n\nThis process introduces aliasing errors. The product of two functions with spectra limited to wavenumbers $|k| \\le K_{max}$ produces a result with a spectrum extending up to $|k| \\le 2K_{max}$. The discrete grid can only represent wavenumbers up to the Nyquist limit, $|k| \\le N/2$. Any spectral content generated beyond this limit is \"folded back\" onto the resolved wavenumbers, contaminating the Fourier coefficients. This phenomenon, known as aliasing, violates the properties of the continuous convolution and leads to inaccuracies, including the breakdown of discrete energy conservation. The aliased variant of the algorithm implements this procedure directly without any correction.\n\nTo mitigate aliasing, the two-thirds dealiasing rule is applied. For a quadratic nonlinearity like $u u_x$, this rule ensures that the spectral convolution does not cause wrap-around errors. This is achieved by truncating the Fourier series of the factors before multiplication. Specifically, all modes with wavenumber magnitudes $|k|  K_{cut} = \\lfloor N/3 \\rfloor$ are set to zero. The dealiased procedure is:\n1.  Given the coefficients $\\widehat{u}_k$, create a filtered set $\\widehat{u}_{k, \\text{trunc}}$ by setting to zero all coefficients where $|k|  N/3$.\n2.  Compute the filtered derivative coefficients: $\\widehat{(u_x)}_{k, \\text{trunc}} = i k \\widehat{u}_{k, \\text{trunc}}$.\n3.  Transform both $\\widehat{u}_{k, \\text{trunc}}$ and $\\widehat{(u_x)}_{k, \\text{trunc}}$ to physical space to obtain $u_{\\text{trunc}}(x_j)$ and $(u_x)_{\\text{trunc}}(x_j)$.\n4.  Compute the product $p_{\\text{trunc}}(x_j) = u_{\\text{trunc}}(x_j) (u_x)_{\\text{trunc}}(x_j)$.\n5.  Transform this product back to Fourier space to obtain $\\widehat{p}_{\\text{trunc}, k}$.\n6.  As a final projection, set to zero all coefficients of $\\widehat{p}_{\\text{trunc}, k}$ for which $|k|  N/3$. The result is the dealiased Fourier representation of the nonlinear term, $-\\mathcal{F}(u u_x)_k$.\n\nThe resulting ODE system, $\\frac{d}{dt}\\widehat{U} = F(\\widehat{U})$, where $\\widehat{U}$ is the vector of all $\\widehat{u}_k$ and $F$ is the right-hand side function (computed either with or without dealiasing), is advanced in time using the classical fourth-order Runge-Kutta (RK4) method. For a time step $\\Delta t$, the state at time $t_{n+1} = t_n + \\Delta t$ is found from the state $\\widehat{U}_n$ at time $t_n$ by:\n$$\n\\begin{aligned}\n    k_1 = F(\\widehat{U}_n) \\\\\n    k_2 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 = F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 = F(\\widehat{U}_n + \\Delta t k_3) \\\\\n    \\widehat{U}_{n+1} = \\widehat{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nA small, fixed time step $\\Delta t=0.001$ is chosen to ensure that temporal errors are negligible compared to the spatial errors under investigation.\n\nFinally, the discrete $L^2$ energy is computed at the initial time $t=0$ and the final time $t=T$. As specified, this is done using the trapezoidal rule on the physical grid values, which is spectrally accurate for periodic functions:\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2\n$$\nThe energy drift, $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$, serves as the metric to quantify the performance of the aliased and dealiased schemes. The continuous equation conserves energy, so in a perfect numerical scheme, this drift would be zero. We expect the dealiased scheme to exhibit a significantly smaller energy drift. For the initial condition $u(x,0)=\\sin(x)$, the discrete initial energy is exactly $E_{\\text{disc}}(0) = \\pi/2$ for $N2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T, dealias_mode, dt):\n    \"\"\"\n    Solves the inviscid Burgers' equation using a Fourier pseudo-spectral method.\n\n    Args:\n        N (int): Number of grid points.\n        T (float): Final time.\n        dealias_mode (str): \"none\" for aliased, \"2/3\" for dealiased.\n        dt (float): Time step.\n\n    Returns:\n        float: The energy drift E(T) - E(0).\n    \"\"\"\n    # 1. Setup grid and initial conditions\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.arange(N) * dx\n    u0 = np.sin(x)\n    u_hat = np.fft.fft(u0)\n\n    # 2. Wavenumbers for spatial differentiation\n    # The factor N scales frequencies from cycles/sample to integer wavenumbers\n    k_vector = np.fft.fftfreq(N) * N\n\n    # 3. Calculate initial energy\n    E0 = 0.5 * dx * np.sum(u0**2)\n\n    # Pre-compute dealiasing mask if needed\n    high_freq_indices = None\n    if dealias_mode == \"2/3\":\n        k_cutoff = int(N / 3)\n        high_freq_indices = np.abs(k_vector)  k_cutoff\n\n    # 4. Define the RHS function for the ODE d(u_hat)/dt = F(u_hat)\n    def rhs(current_u_hat):\n        if dealias_mode == \"2/3\":\n            # Project field onto resolved modes\n            u_hat_trunc = current_u_hat.copy()\n            u_hat_trunc[high_freq_indices] = 0\n            \n            # Differentiate the truncated field\n            u_x_hat_trunc = 1j * k_vector * u_hat_trunc\n            \n            # Transform to physical space\n            u_trunc = np.fft.ifft(u_hat_trunc)\n            u_x_trunc = np.fft.ifft(u_x_hat_trunc)\n            \n            # Pointwise product of truncated fields\n            nonlinear_term = u_trunc * u_x_trunc\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            # Project the result back onto resolved modes\n            nonlinear_term_hat[high_freq_indices] = 0\n            \n            return -nonlinear_term_hat\n        \n        else:  # \"none\" case (aliased)\n            # Differentiate in Fourier space\n            u_x_hat = 1j * k_vector * current_u_hat\n            \n            # Transform to physical space\n            u = np.fft.ifft(current_u_hat)\n            u_x = np.fft.ifft(u_x_hat)\n            \n            # Pointwise product\n            nonlinear_term = u * u_x\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            return -nonlinear_term_hat\n\n    # 5. Time integration loop (RK4)\n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        k1 = rhs(u_hat)\n        k2 = rhs(u_hat + 0.5 * dt * k1)\n        k3 = rhs(u_hat + 0.5 * dt * k2)\n        k4 = rhs(u_hat + dt * k3)\n        u_hat += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n    \n    # 6. Calculate final energy\n    u_final = np.fft.ifft(u_hat)\n    # The physical solution must be real; numerical errors introduce a small imaginary part.\n    E_final = 0.5 * dx * np.sum(np.real(u_final)**2)\n    \n    # 7. Compute and return drift\n    energy_drift = E_final - E0\n    return energy_drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, dealias_mode)\n        (64, 0.5, \"none\"),\n        (64, 0.5, \"2/3\"),\n        (16, 0.5, \"none\"),\n        (64, 0.95, \"2/3\"),\n    ]\n\n    # Fixed time step for all simulations to ensure stability and\n    # make temporal errors subdominant to spatial ones.\n    dt = 0.001\n\n    results = []\n    for case in test_cases:\n        N, T, dealias_mode = case\n        drift = run_simulation(N, T, dealias_mode, dt)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}