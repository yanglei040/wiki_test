{
    "hands_on_practices": [
        {
            "introduction": "Before applying Fourier methods to solve complex equations, it's essential to master the fundamentals of the Fourier series itself. This first exercise provides hands-on practice in converting a simple periodic function from its physical-space representation to its spectral-space representation by finding its complex Fourier coefficients. By then verifying Parseval's theorem, you will confirm the fundamental energy-preserving nature of the Fourier transform, a property that is critical for the stability and analysis of numerical simulations. ",
            "id": "3396156",
            "problem": "Consider the use of complex Fourier series in Fourier spectral methods for solving Partial Differential Equations (PDE) on periodic domains. On the interval $[0,2\\pi)$, represent a square-integrable function $u(x)$ by the series $u(x)=\\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$, where $\\{\\exp(\\mathrm{i}kx)\\}_{k\\in\\mathbb{Z}}$ is an orthogonal basis in the $L^{2}([0,2\\pi))$ inner-product space with inner product $\\langle f,g\\rangle=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}f(x)\\overline{g(x)}\\,\\mathrm{d}x$ and norm $\\|f\\|_{L^{2}([0,2\\pi))}^{2}=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|f(x)|^{2}\\,\\mathrm{d}x$. Let $u(x)=\\sin x+\\frac{1}{2}\\cos(3x)$ on $[0,2\\pi)$.\n\nUsing only the orthogonality of $\\exp(\\mathrm{i}kx)$ and the definition of the $L^{2}([0,2\\pi))$ inner product, determine all nonzero complex Fourier coefficients $\\hat{u}_{k}$ for this $u(x)$, and verify the energy balance by evaluating the quantity\n$$D=\\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x-\\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}.$$\nProvide your final answer as the row vector containing the four nonzero coefficients and $D$ in the order $(\\hat{u}_{-3},\\hat{u}_{-1},\\hat{u}_{1},\\hat{u}_{3},D)$. Use exact values; do not round.",
            "solution": "The problem requires the determination of the non-zero complex Fourier coefficients $\\hat{u}_{k}$ for the function $u(x) = \\sin(x) + \\frac{1}{2}\\cos(3x)$ on the domain $[0, 2\\pi)$, and the verification of the energy balance described by the quantity $D$.\n\nThe function $u(x)$ is represented by the complex Fourier series $u(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{u}_{k} \\exp(\\mathrm{i}kx)$. The basis functions $\\{\\exp(\\mathrm{i}kx)\\}_{k \\in \\mathbb{Z}}$ are orthonormal with respect to the given inner product $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(x)\\overline{g(x)}\\,\\mathrm{d}x$. The orthonormality implies that $\\langle \\exp(\\mathrm{i}kx), \\exp(\\mathrm{i}mx) \\rangle = \\delta_{km}$, where $\\delta_{km}$ is the Kronecker delta.\n\nThe instruction to use only orthogonality to determine the coefficients $\\hat{u}_{k}$ means we can either use the projection formula $\\hat{u}_k = \\langle u(x), \\exp(\\mathrm{i}kx) \\rangle$, or, more directly, we can express $u(x)$ in the basis of complex exponentials and identify the coefficients by inspection, relying on the uniqueness of the representation in an orthogonal basis. We shall use the latter, more efficient method.\n\nFirst, we express the trigonometric functions $\\sin(x)$ and $\\cos(3x)$ in terms of complex exponentials using Euler's formulas:\n$$ \\sin(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) - \\exp(-\\mathrm{i}\\theta)}{2\\mathrm{i}} $$\n$$ \\cos(\\theta) = \\frac{\\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)}{2} $$\n\nApplying these to the given function $u(x)$:\n$$ u(x) = \\left( \\frac{\\exp(\\mathrm{i}x) - \\exp(-\\mathrm{i}x)}{2\\mathrm{i}} \\right) + \\frac{1}{2} \\left( \\frac{\\exp(\\mathrm{i}3x) + \\exp(-\\mathrm{i}3x)}{2} \\right) $$\nSimplifying the terms, and using the identity $\\frac{1}{\\mathrm{i}} = -\\mathrm{i}$:\n$$ u(x) = \\frac{1}{2\\mathrm{i}}\\exp(\\mathrm{i}x) - \\frac{1}{2\\mathrm{i}}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\n$$ u(x) = -\\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}x) + \\frac{\\mathrm{i}}{2}\\exp(-\\mathrm{i}x) + \\frac{1}{4}\\exp(\\mathrm{i}3x) + \\frac{1}{4}\\exp(-\\mathrm{i}3x) $$\nTo match this with the series form $u(x) = \\sum_{k\\in\\mathbb{Z}}\\hat{u}_{k}\\exp(\\mathrm{i}kx)$, we order the terms by the index $k$:\n$$ u(x) = \\frac{1}{4}\\exp(\\mathrm{i}(-3)x) + \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(-1)x) - \\frac{\\mathrm{i}}{2}\\exp(\\mathrm{i}(1)x) + \\frac{1}{4}\\exp(\\mathrm{i}(3)x) $$\nBy comparing this expression with the general Fourier series, we identify the non-zero coefficients $\\hat{u}_k$:\n- For $k=-3$, the coefficient is $\\hat{u}_{-3} = \\frac{1}{4}$.\n- For $k=-1$, the coefficient is $\\hat{u}_{-1} = \\frac{\\mathrm{i}}{2}$.\n- For $k=1$, the coefficient is $\\hat{u}_{1} = -\\frac{\\mathrm{i}}{2}$.\n- For $k=3$, the coefficient is $\\hat{u}_{3} = \\frac{1}{4}$.\nAll other coefficients $\\hat{u}_k$ for $k \\notin \\{-3, -1, 1, 3\\}$ are zero.\n\nNext, we evaluate the quantity $D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$. This expression compares the norm of the function in the physical space to the norm of its coefficients in the frequency space. Parseval's theorem for this orthonormal system states that these two quantities are equal, i.e., $\\|u\\|_{L^{2}([0,2\\pi))}^{2} = \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2}$. Therefore, we expect $D=0$. We must verify this by explicit calculation.\n\nFirst, we calculate the integral term:\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}\\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2}\\,\\mathrm{d}x $$\nExpanding the square:\n$$ \\left(\\sin(x) + \\frac{1}{2}\\cos(3x)\\right)^{2} = \\sin^{2}(x) + \\sin(x)\\cos(3x) + \\frac{1}{4}\\cos^{2}(3x) $$\nWe integrate term by term over $[0, 2\\pi]$:\nUsing the identities $\\int_{0}^{2\\pi}\\sin^{2}(nx)\\,\\mathrm{d}x = \\pi$ and $\\int_{0}^{2\\pi}\\cos^{2}(nx)\\,\\mathrm{d}x = \\pi$ for any non-zero integer $n$, and the orthogonality relation $\\int_{0}^{2\\pi}\\sin(mx)\\cos(nx)\\,\\mathrm{d}x = 0$ for integers $m, n$:\n$$ \\int_{0}^{2\\pi} \\sin^{2}(x)\\,\\mathrm{d}x = \\pi $$\n$$ \\int_{0}^{2\\pi} \\sin(x)\\cos(3x)\\,\\mathrm{d}x = 0 $$\n$$ \\int_{0}^{2\\pi} \\frac{1}{4}\\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{1}{4}\\int_{0}^{2\\pi} \\cos^{2}(3x)\\,\\mathrm{d}x = \\frac{\\pi}{4} $$\nSumming these results, we get:\n$$ \\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\pi + 0 + \\frac{\\pi}{4} = \\frac{5\\pi}{4} $$\nThus, the first term in the expression for $D$ is:\n$$ \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x = \\frac{1}{2\\pi} \\left( \\frac{5\\pi}{4} \\right) = \\frac{5}{8} $$\n\nSecond, we calculate the sum of the squared magnitudes of the coefficients:\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = |\\hat{u}_{-3}|^{2} + |\\hat{u}_{-1}|^{2} + |\\hat{u}_{1}|^{2} + |\\hat{u}_{3}|^{2} $$\nThe magnitudes are:\n$$ |\\hat{u}_{-3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{-3}|^{2} = \\frac{1}{16} $$\n$$ |\\hat{u}_{-1}| = \\left|\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{-1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{1}| = \\left|-\\frac{\\mathrm{i}}{2}\\right| = \\frac{1}{2} \\implies |\\hat{u}_{1}|^{2} = \\frac{1}{4} $$\n$$ |\\hat{u}_{3}| = \\left|\\frac{1}{4}\\right| = \\frac{1}{4} \\implies |\\hat{u}_{3}|^{2} = \\frac{1}{16} $$\nSumming these values:\n$$ \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{1}{16} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{16} = \\frac{2}{16} + \\frac{2}{4} = \\frac{1}{8} + \\frac{1}{2} = \\frac{1+4}{8} = \\frac{5}{8} $$\n\nFinally, we compute $D$:\n$$ D = \\frac{1}{2\\pi}\\int_{0}^{2\\pi}|u(x)|^{2}\\,\\mathrm{d}x - \\sum_{k\\in\\mathbb{Z}}|\\hat{u}_{k}|^{2} = \\frac{5}{8} - \\frac{5}{8} = 0 $$\nThis verifies the energy balance as stated by Parseval's theorem.\n\nThe required final answer is the row vector $(\\hat{u}_{-3}, \\hat{u}_{-1}, \\hat{u}_{1}, \\hat{u}_{3}, D)$.\n$$ \\left(\\frac{1}{4}, \\frac{\\mathrm{i}}{2}, -\\frac{\\mathrm{i}}{2}, \\frac{1}{4}, 0\\right) $$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{4} & \\frac{\\mathrm{i}}{2} & -\\frac{\\mathrm{i}}{2} & \\frac{1}{4} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The primary advantage of Fourier-spectral methods is the elegant and highly accurate way they handle spatial derivatives. This practice moves from representation to computation, guiding you through the implementation of a spectral derivative for any smooth periodic function. You will use the Fast Fourier Transform (FFT) to implement the core principle that differentiation in physical space corresponds to simple multiplication by the wavenumber in Fourier space, and in doing so, you will directly observe the \"spectral accuracy\" of the method. ",
            "id": "3396179",
            "problem": "You are given a smooth $2\\pi$-periodic function $f$ sampled at $N$ equispaced grid points on the interval $[0,2\\pi)$. Let the grid be $x_j = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$, and denote the samples by $f_j = f(x_j)$. The goal is to compute the spectral approximation to the derivative $f'(x)$ at the grid points via the Fast Fourier Transform (FFT), and then to quantify the accuracy using both the $L^2$ error and the pointwise (infinity) error.\n\nStart from the following fundamental base:\n- The complex Fourier series for a smooth $2\\pi$-periodic function $f$ is $f(x) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_k e^{ikx}$, where $\\hat{f}_k$ are the Fourier coefficients. Differentiation in physical space corresponds to multiplication by $ik$ in Fourier space: $f'(x) = \\sum_{k\\in\\mathbb{Z}} (ik)\\hat{f}_k e^{ikx}$.\n- The Discrete Fourier Transform (DFT) maps $N$ equispaced samples $\\{f_j\\}_{j=0}^{N-1}$ to a set of discrete Fourier modes that represent integer wavenumbers consistent with the sampling grid and periodicity. The inverse DFT reconstructs the function values at the grid points from these modes.\n- The discrete trapezoidal rule on an equispaced periodic grid approximates the continuous $L^2$ norm with spectral accuracy for smooth periodic functions.\n\nFrom these principles, derive the algorithm to compute the spectral derivative at the grid points by:\n1. Applying the DFT to $\\{f_j\\}$ to obtain discrete Fourier modes associated with integer wavenumbers $k$.\n2. Multiplying each mode by $ik$ to represent differentiation in Fourier space.\n3. Applying the inverse DFT (IDFT) to return to physical space, yielding the spectral approximation to $\\{f'(x_j)\\}$.\n\nImplement this algorithm using the Fast Fourier Transform (FFT) and its inverse to ensure computational efficiency. Explicitly construct the integer wavenumber vector $k$ that is consistent with the DFT ordering induced by the FFT on the interval $[0,2\\pi)$, and ensure your implementation correctly handles both even and odd values of $N$. Use angles in radians.\n\nFor each test case, compute:\n- The $L^2$ error, defined as $\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N-1} |e_j|^2 \\,\\Delta x\\right)^{1/2}$, where $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$ is the pointwise error at $x_j$ and $\\Delta x = \\frac{2\\pi}{N}$.\n- The pointwise (infinity) error, defined as $\\|e\\|_{\\infty} = \\max_{0\\le j\\le N-1} |e_j|$.\n\nYour program must compute these two error metrics for each test case specified below. Round each floating-point error to $8$ decimal places before producing the final output.\n\nTest suite (use exactly these functions and resolutions):\n- Case $1$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=16$.\n- Case $2$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=64$.\n- Case $3$: $f_2(x) = \\exp(\\sin x)$ with $N=32$.\n- Case $4$: $f_2(x) = \\exp(\\sin x)$ with $N=128$.\n- Case $5$: $f_3(x) = \\sin(20x)$ with $N=32$.\n- Case $6$: $f_1(x) = \\sin(3x) + \\cos(5x)$ with $N=8$.\n\nFor each case, use the exact derivatives:\n- $f_1'(x) = 3\\cos(3x) - 5\\sin(5x)$.\n- $f_2'(x) = \\cos(x)\\exp(\\sin x)$.\n- $f_3'(x) = 20\\cos(20x)$.\n\nAll trigonometric arguments are in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list containing the $L^2$ error and the infinity error, in that order, both rounded to $8$ decimal places. For example, the output should look like: \"[[e21,einf1],[e22,einf2],...]\" with no spaces. Ensure the results appear in the exact order of Cases $1$ through $6$ as listed above.",
            "solution": "The problem requires the computation of the derivative of a smooth $2\\pi$-periodic function using a Fourier spectral method, and the quantification of the method's accuracy. The solution is derived from the fundamental principles of Fourier analysis.\n\nThe core principle of spectral methods is that operations in physical space, such as differentiation, correspond to simpler algebraic operations in frequency (or Fourier) space. For a smooth $2\\pi$-periodic function $f(x)$ with a continuous Fourier series representation:\n$$\nf(x) = \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx}\n$$\nwhere $\\hat{f}_k$ are the continuous Fourier coefficients and $k$ are the integer wavenumbers. Differentiating with respect to $x$ yields:\n$$\nf'(x) = \\frac{d}{dx} \\sum_{k \\in \\mathbb{Z}} \\hat{f}_k e^{ikx} = \\sum_{k \\in \\mathbb{Z}} (ik) \\hat{f}_k e^{ikx}\n$$\nThis shows that differentiation in physical space is equivalent to multiplying each Fourier coefficient $\\hat{f}_k$ by the factor $ik$.\n\nIn a computational setting, we work with a discrete representation of the function. The function $f(x)$ is sampled on a uniform grid of $N$ points in the interval $[0, 2\\pi)$:\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1\n$$\nThe function values on this grid are $f_j = f(x_j)$. The discrete analogue of the Fourier series is the Discrete Fourier Transform (DFT). The DFT of the sequence $\\{f_j\\}_{j=0}^{N-1}$ is a set of $N$ complex coefficients, which we denote as $\\hat{f}^N$, computed via the Fast Fourier Transform (FFT) algorithm:\n$$\n\\hat{f}^N_k = \\sum_{j=0}^{N-1} f_j e^{-i \\frac{2\\pi kj}{N}}, \\quad k = 0, 1, \\dots, N-1\n$$\nThe original function values can be reconstructed perfectly from these coefficients using the inverse DFT (IDFT), typically computed via the Inverse FFT (IFFT):\n$$\nf_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{i \\frac{2\\pi kj}{N}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}^N_k e^{ik_{\\text{phys}}(k) x_j}\n$$\nThe indices $k$ of the DFT output must be mapped to their corresponding physical integer wavenumbers, denoted $k_{\\text{phys}}(k)$. For a sequence of length $N$, the DFT coefficients correspond to wavenumbers that are aliased into the range that can be resolved by the grid. Standard FFT libraries, such as NumPy's, order the corresponding integer wavenumbers as follows:\n- For $k = 0, \\dots, \\lfloor (N-1)/2 \\rfloor$: wavenumbers are $0, 1, \\dots, \\lfloor (N-1)/2 \\rfloor$.\n- For $k = \\lfloor (N-1)/2 \\rfloor + 1, \\dots, N-1$: wavenumbers are $\\lfloor -N/2 \\rfloor, \\dots, -1$.\nA robust way to generate this vector of wavenumbers, let's call it $k_{\\text{phys}}$, is provided by standard libraries.\n\nTo compute the derivative, we apply the differentiation-multiplication principle to the discrete coefficients:\n$$\n\\widehat{(f')}^N_k = (i k_{\\text{phys}}(k)) \\hat{f}^N_k\n$$\nA crucial subtlety arises for an even number of points $N$. The grid can represent a frequency component corresponding to the Nyquist wavenumber, $k = N/2$. On the grid points $x_j$, the function $\\cos((N/2)x_j) = \\cos(\\pi j) = (-1)^j$. Its analytical derivative is $-(N/2)\\sin((N/2)x)$, which evaluates to $-(N/2)\\sin(\\pi j) = 0$ at all grid points. To ensure that the numerical derivative of a real-valued function is also real-valued, and to be consistent with the behavior of functions on the grid, the derivative of the Nyquist mode is conventionally set to zero. This is achieved by setting the component of the wavenumber vector $k_{\\text{phys}}$ corresponding to the Nyquist frequency to $0$. For an odd number of points $N$, no such special handling is required as there is no single Nyquist frequency.\n\nThe algorithm for computing the spectral derivative $\\{f'_{\\text{spec}}(x_j)\\}$ is as follows:\n1.  Compute the discrete function samples $\\{f_j\\}$ on the grid $\\{x_j\\}$.\n2.  Apply the FFT to $\\{f_j\\}$ to obtain the discrete Fourier coefficients $\\{\\hat{f}^N_k\\}$.\n3.  Construct the vector of physical integer wavenumbers $\\{k_{\\text{phys}}\\}$. For even $N$, set the element corresponding to the Nyquist frequency to $0$.\n4.  Multiply the Fourier coefficients by $ik_{\\text{phys}}$ to obtain the coefficients of the derivative, $\\{\\widehat{(f')}^N_k\\} = \\{i k_{\\text{phys}}(k) \\hat{f}^N_k\\}$.\n5.  Apply the IFFT to $\\{\\widehat{(f')}^N_k\\}$ to obtain the spectral derivative values $\\{f'_{\\text{spec}}(x_j)\\}$ in physical space. The result should be real up to machine precision; taking the real part discards any small imaginary component due to floating-point error.\n\nFinally, to assess the accuracy, we compute the error vector $e_j = f'_{\\text{spec}}(x_j) - f'_{\\text{exact}}(x_j)$. The accuracy is quantified using two norms:\n- The discrete $L^2$ error, which approximates the continuous $L^2$ norm:\n$$\n\\|e\\|_{L^2} \\approx \\left( \\sum_{j=0}^{N-1} |e_j|^2 \\Delta x \\right)^{1/2}\n$$\nwhere the grid spacing is $\\Delta x = 2\\pi/N$.\n- The pointwise infinity error, which measures the maximum absolute error on the grid:\n$$\n\\|e\\|_{\\infty} = \\max_{0 \\le j \\le N-1} |e_j|\n$$\nThe implementation will apply this complete procedure to each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spectral derivatives and errors for a suite of test cases.\n    \"\"\"\n\n    # Define the functions and their exact derivatives for the test cases.\n    def f1(x):\n        return np.sin(3 * x) + np.cos(5 * x)\n\n    def f1_prime(x):\n        return 3 * np.cos(3 * x) - 5 * np.sin(5 * x)\n\n    def f2(x):\n        return np.exp(np.sin(x))\n\n    def f2_prime(x):\n        return np.cos(x) * np.exp(np.sin(x))\n\n    def f3(x):\n        return np.sin(20 * x)\n\n    def f3_prime(x):\n        return 20 * np.cos(20 * x)\n\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        {'N': 16, 'func': f1, 'deriv': f1_prime},\n        {'N': 64, 'func': f1, 'deriv': f1_prime},\n        {'N': 32, 'func': f2, 'deriv': f2_prime},\n        {'N': 128, 'func': f2, 'deriv': f2_prime},\n        {'N': 32, 'func': f3, 'deriv': f3_prime},\n        {'N': 8, 'func': f1, 'deriv': f1_prime},\n    ]\n\n    results_str = []\n    \n    for case in test_cases:\n        N = case['N']\n        f = case['func']\n        f_prime_exact_func = case['deriv']\n\n        # 1. Create the grid an sample the function.\n        # The domain is [0, 2*pi), so the grid is x_j = 2*pi*j / N.\n        x = np.arange(N) * (2 * np.pi / N)\n        f_values = f(x)\n        \n        # 2. Compute the FFT of the signal.\n        f_hat = np.fft.fft(f_values)\n\n        # 3. Construct the wavenumber vector for differentiation.\n        # numpy.fft.fftfreq(N) returns the unique sampling frequencies.\n        # We multiply by N to get the integer wavenumbers.\n        k = np.fft.fftfreq(N) * N\n        \n        # 4. Handle the Nyquist frequency for even N.\n        # For a real signal, the derivative of the Nyquist mode must be zero\n        # to ensure the derivative is real-valued.\n        if N % 2 == 0:\n            k[N // 2] = 0\n\n        # 5. Differentiate in Fourier space.\n        f_prime_hat = 1j * k * f_hat\n        \n        # 6. Apply inverse FFT to get the derivative in physical space.\n        f_prime_spec = np.fft.ifft(f_prime_hat)\n        \n        # The result must be real for a real input function. Take the real part\n        # to discard any small imaginary noise from floating-point inaccuracies.\n        f_prime_spec = np.real(f_prime_spec)\n        \n        # 7. Compute the exact derivative at the grid points.\n        f_prime_exact = f_prime_exact_func(x)\n        \n        # 8. Calculate the error vector.\n        error_vec = f_prime_spec - f_prime_exact\n        \n        # 9. Compute the L2 and infinity error norms.\n        delta_x = 2 * np.pi / N\n        l2_error = np.sqrt(np.sum(error_vec**2) * delta_x)\n        inf_error = np.max(np.abs(error_vec))\n\n        # 10. Format and store the results.\n        l2_error_str = f\"{l2_error:.8f}\"\n        inf_error_str = f\"{inf_error:.8f}\"\n        results_str.append(f\"[{l2_error_str},{inf_error_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While linear problems are straightforward in Fourier space, nonlinear dynamics introduce significant challenges, most notably aliasing errors that can violate physical conservation laws. This exercise tackles this advanced topic by having you build a solver for the inviscid Burgers' equation, a classic model for nonlinear wave steepening and shock formation. By comparing a standard pseudo-spectral implementation with a 'dealiased' version, you will gain a crucial, practical understanding of why aliasing occurs and how to control it to ensure your simulation remains physically meaningful. ",
            "id": "3396162",
            "problem": "Consider the periodic initial-value problem for the inviscid Burgers equation on the interval $[0,2\\pi]$,\n$$\nu_t(x,t) + u(x,t)\\,u_x(x,t) = 0, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\nwith periodic boundary conditions and a smooth initial condition $u(x,0) = \\sin(x)$. The continuous $L^2$ energy\n$$\nE(t) = \\frac{1}{2}\\int_{0}^{2\\pi} u(x,t)^2 \\, dx\n$$\nis conserved for sufficiently smooth solutions prior to shock formation.\n\nIn a Fourier pseudo-spectral discretization, the nonlinear term $u\\,u_x$ is computed by transforming to physical space, multiplying pointwise, and transforming back to Fourier space. However, the discrete convolution is truncated to the available modes, and this can introduce aliasing errors that break discrete conservation. A common remedy is dealiasing using the two-thirds rule, which sets to zero all Fourier modes with wavenumber magnitude greater than $N/3$ for a grid with $N$ points when evaluating quadratic nonlinearities.\n\nYour task is to write a complete, runnable program that:\n- Discretizes the spatial domain $[0,2\\pi]$ with $N$ equispaced points and represents $u$ by its discrete Fourier transform.\n- Uses a Fourier pseudo-spectral method to compute spatial derivatives, with two variants for the nonlinear term $u\\,u_x$:\n  1. An aliasing variant (no dealiasing): compute $u\\,u_x$ via pointwise multiplication in physical space and transform back without truncation.\n  2. A dealiased variant using the two-thirds rule: before forming the nonlinear product, project the field onto Fourier modes with $|k|\\le N/3$, compute the product in physical space, and project the resulting Fourier transform back onto $|k|\\le N/3$.\n- Advances the solution in time using the explicit fourth-order Rungeâ€“Kutta method with a fixed time step $\\Delta t$ up to a specified final time $T$.\n- Computes the discrete $L^2$ energy at times $t=0$ and $t=T$ using the trapezoidal rule (which is exact for equispaced samples of periodic functions), namely\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2,\n$$\nwhere $\\Delta x = 2\\pi/N$ and $x_j = j\\,\\Delta x$.\n- Returns, for each test case, the energy drift $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$ as a float in dimensionless units.\n\nBase your derivation and implementation on the following foundational facts:\n- The inviscid Burgers equation $u_t + u u_x = 0$ has a continuous energy conservation law $dE/dt = 0$ prior to shock formation.\n- The Fourier transform turns derivatives into multipliers: if $\\widehat{u}(k)$ denotes the discrete Fourier coefficients at wavenumber $k$, then $u_x$ corresponds to multiplication by $\\mathrm{i}k$ in Fourier space.\n- The pseudo-spectral product of two fields corresponds to a discrete convolution in Fourier space that is truncated to the resolved modes, potentially causing aliasing if nonlinear interactions generate unresolved modes.\n- The two-thirds dealiasing rule for quadratic nonlinearities ensures that the convolution of two truncated spectra does not alias into the resolved band: modes with $|k| > N/3$ are set to zero during nonlinear product evaluation.\n\nEnsure scientific realism by keeping the final times strictly below the shock time. For $u(x,0) = \\sin(x)$, the shock time is $t_s = 1$ because $\\min_x u_x(x,0) = -1$.\n\nTest Suite:\nUse the following parameter sets, where each test case is a tuple $(N, T, \\text{dealias})$ with $N$ the number of grid points, $T$ the final time, and $\\text{dealias}$ a string equal to \"none\" or \"2/3\" indicating the nonlinear evaluation variant.\n- Test 1 (happy path, moderate resolution, aliasing present): (64, 0.5, \"none\").\n- Test 2 (happy path, moderate resolution, dealiasing applied): (64, 0.5, \"2/3\").\n- Test 3 (edge case, coarse resolution, aliasing present): (16, 0.5, \"none\").\n- Test 4 (boundary case near shock time, dealiasing applied): (64, 0.95, \"2/3\").\n\nAll computations are dimensionless. Angles are measured in radians. Your program should produce a single line of output containing the energy drifts for the test suite as a comma-separated list enclosed in square brackets, for example,\n$$\n[\\delta E_1,\\delta E_2,\\delta E_3,\\delta E_4],\n$$\nwhere each $\\delta E_i$ equals $E_{\\text{disc}}(T)-E_{\\text{disc}}(0)$ for the corresponding test case. The values should be output as decimal floats.\n\nThe program must be self-contained, use the Fast Fourier Transform (FFT), and follow the constraints specified for the execution environment. No external input is allowed, and no physical units are involved beyond the dimensionless specification above.",
            "solution": "The problem requires the numerical solution of the inviscid Burgers' equation, $u_t + u u_x = 0$, on a periodic domain $x \\in [0, 2\\pi]$ with the initial condition $u(x,0) = \\sin(x)$. The solution is to be obtained using a Fourier pseudo-spectral method, with time integration performed by the fourth-order Runge-Kutta (RK4) scheme. A key aspect is to compare the effect of aliasing errors on the discrete energy conservation by implementing two variants for the nonlinear term $u u_x$: one with no aliasing control and another employing the two-thirds dealiasing rule.\n\nThe core of the method is the semi-discretization of the partial differential equation (PDE). We represent the solution $u(x,t)$ at any time $t$ by its values on a grid of $N$ equispaced points, $x_j = j \\Delta x$ where $\\Delta x = 2\\pi/N$ for $j=0, 1, \\dots, N-1$. For a periodic function, this spatial representation is efficiently handled in Fourier space. Let $\\widehat{u}_k(t)$ be the discrete Fourier coefficient of $u(x,t)$ corresponding to wavenumber $k$. The set of all coefficients, $\\{\\widehat{u}_k(t)\\}$, constitutes the state of the system. The PDE is thus transformed into a system of ordinary differential equations (ODEs) for these coefficients:\n$$\n\\frac{d\\widehat{u}_k}{dt} = -\\mathcal{F}(u \\cdot u_x)_k\n$$\nwhere $\\mathcal{F}$ denotes the discrete Fourier transform and the subscript $k$ indicates the $k$-th Fourier coefficient of the term in parentheses.\n\nThe spatial derivative $u_x$ is computed exactly in Fourier space. The differentiation property of the Fourier transform states that a derivative $\\partial/\\partial x$ in real space corresponds to multiplication by $ik$ in Fourier space, where $i = \\sqrt{-1}$ and $k$ is the integer wavenumber. The wavenumbers for an $N$-point grid on $[0, 2\\pi]$ are given by the set $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), -N/2\\}$ (for $N$ even). Thus, the Fourier coefficients of the derivative, $\\widehat{(u_x)}_k$, are computed as:\n$$\n\\widehat{(u_x)}_k = i k \\widehat{u}_k\n$$\n\nThe primary challenge lies in computing the nonlinear term $u u_x$. In the pseudo-spectral (or collocation) method, this product is computed pointwise in physical space. The procedure is as follows:\n1.  Transform $\\widehat{u}_k$ and $\\widehat{(u_x)}_k$ to physical space using the inverse Fast Fourier Transform (IFFT) to obtain grid-point values $u(x_j)$ and $u_x(x_j)$.\n2.  Compute the pointwise product $p(x_j) = u(x_j) u_x(x_j)$.\n3.  Transform the product back to Fourier space using the Fast Fourier Transform (FFT) to get $\\widehat{p}_k = \\mathcal{F}(p)_k$.\n\nThis process introduces aliasing errors. The product of two functions with spectra limited to wavenumbers $|k| \\le K_{max}$ produces a result with a spectrum extending up to $|k| \\le 2K_{max}$. The discrete grid can only represent wavenumbers up to the Nyquist limit, $|k| \\le N/2$. Any spectral content generated beyond this limit is \"folded back\" onto the resolved wavenumbers, contaminating the Fourier coefficients. This phenomenon, known as aliasing, violates the properties of the continuous convolution and leads to inaccuracies, including the breakdown of discrete energy conservation. The aliased variant of the algorithm implements this procedure directly without any correction.\n\nTo mitigate aliasing, the two-thirds dealiasing rule is applied. For a quadratic nonlinearity like $u u_x$, this rule ensures that the spectral convolution does not cause wrap-around errors. This is achieved by truncating the Fourier series of the factors before multiplication. Specifically, all modes with wavenumber magnitudes $|k| > K_{cut} = \\lfloor N/3 \\rfloor$ are set to zero. The dealiased procedure is:\n1.  Given the coefficients $\\widehat{u}_k$, create a filtered set $\\widehat{u}_{k, \\text{trunc}}$ by setting to zero all coefficients where $|k| > N/3$.\n2.  Compute the filtered derivative coefficients: $\\widehat{(u_x)}_{k, \\text{trunc}} = i k \\widehat{u}_{k, \\text{trunc}}$.\n3.  Transform both $\\widehat{u}_{k, \\text{trunc}}$ and $\\widehat{(u_x)}_{k, \\text{trunc}}$ to physical space to obtain $u_{\\text{trunc}}(x_j)$ and $(u_x)_{\\text{trunc}}(x_j)$.\n4.  Compute the product $p_{\\text{trunc}}(x_j) = u_{\\text{trunc}}(x_j) (u_x)_{\\text{trunc}}(x_j)$.\n5.  Transform this product back to Fourier space to obtain $\\widehat{p}_{\\text{trunc}, k}$.\n6.  As a final projection, set to zero all coefficients of $\\widehat{p}_{\\text{trunc}, k}$ for which $|k| > N/3$. The result is the dealiased Fourier representation of the nonlinear term, $-\\mathcal{F}(u u_x)_k$.\n\nThe resulting ODE system, $\\frac{d}{dt}\\widehat{U} = F(\\widehat{U})$, where $\\widehat{U}$ is the vector of all $\\widehat{u}_k$ and $F$ is the right-hand side function (computed either with or without dealiasing), is advanced in time using the classical fourth-order Runge-Kutta (RK4) method. For a time step $\\Delta t$, the state at time $t_{n+1} = t_n + \\Delta t$ is found from the state $\\widehat{U}_n$ at time $t_n$ by:\n$$\n\\begin{aligned}\n    k_1 &= F(\\widehat{U}_n) \\\\\n    k_2 &= F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 &= F(\\widehat{U}_n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 &= F(\\widehat{U}_n + \\Delta t k_3) \\\\\n    \\widehat{U}_{n+1} &= \\widehat{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\nA small, fixed time step $\\Delta t=0.001$ is chosen to ensure that temporal errors are negligible compared to the spatial errors under investigation.\n\nFinally, the discrete $L^2$ energy is computed at the initial time $t=0$ and the final time $t=T$. As specified, this is done using the trapezoidal rule on the physical grid values, which is spectrally accurate for periodic functions:\n$$\nE_{\\text{disc}}(t) = \\frac{1}{2}\\,\\Delta x \\sum_{j=0}^{N-1} u(x_j,t)^2\n$$\nThe energy drift, $E_{\\text{disc}}(T) - E_{\\text{disc}}(0)$, serves as the metric to quantify the performance of the aliased and dealiased schemes. The continuous equation conserves energy, so in a perfect numerical scheme, this drift would be zero. We expect the dealiased scheme to exhibit a significantly smaller energy drift. For the initial condition $u(x,0)=\\sin(x)$, the discrete initial energy is exactly $E_{\\text{disc}}(0) = \\pi/2$ for $N>2$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T, dealias_mode, dt):\n    \"\"\"\n    Solves the inviscid Burgers' equation using a Fourier pseudo-spectral method.\n\n    Args:\n        N (int): Number of grid points.\n        T (float): Final time.\n        dealias_mode (str): \"none\" for aliased, \"2/3\" for dealiased.\n        dt (float): Time step.\n\n    Returns:\n        float: The energy drift E(T) - E(0).\n    \"\"\"\n    # 1. Setup grid and initial conditions\n    L = 2.0 * np.pi\n    dx = L / N\n    x = np.arange(N) * dx\n    u0 = np.sin(x)\n    u_hat = np.fft.fft(u0)\n\n    # 2. Wavenumbers for spatial differentiation\n    # The factor N scales frequencies from cycles/sample to integer wavenumbers\n    k_vector = np.fft.fftfreq(N) * N\n\n    # 3. Calculate initial energy\n    E0 = 0.5 * dx * np.sum(u0**2)\n\n    # Pre-compute dealiasing mask if needed\n    high_freq_indices = None\n    if dealias_mode == \"2/3\":\n        k_cutoff = int(N / 3)\n        high_freq_indices = np.abs(k_vector) > k_cutoff\n\n    # 4. Define the RHS function for the ODE d(u_hat)/dt = F(u_hat)\n    def rhs(current_u_hat):\n        if dealias_mode == \"2/3\":\n            # Project field onto resolved modes\n            u_hat_trunc = current_u_hat.copy()\n            u_hat_trunc[high_freq_indices] = 0\n            \n            # Differentiate the truncated field\n            u_x_hat_trunc = 1j * k_vector * u_hat_trunc\n            \n            # Transform to physical space\n            u_trunc = np.fft.ifft(u_hat_trunc)\n            u_x_trunc = np.fft.ifft(u_x_hat_trunc)\n            \n            # Pointwise product of truncated fields\n            nonlinear_term = u_trunc * u_x_trunc\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            # Project the result back onto resolved modes\n            nonlinear_term_hat[high_freq_indices] = 0\n            \n            return -nonlinear_term_hat\n        \n        else:  # \"none\" case (aliased)\n            # Differentiate in Fourier space\n            u_x_hat = 1j * k_vector * current_u_hat\n            \n            # Transform to physical space\n            u = np.fft.ifft(current_u_hat)\n            u_x = np.fft.ifft(u_x_hat)\n            \n            # Pointwise product\n            nonlinear_term = u * u_x\n            \n            # Transform product back to Fourier space\n            nonlinear_term_hat = np.fft.fft(nonlinear_term)\n            \n            return -nonlinear_term_hat\n\n    # 5. Time integration loop (RK4)\n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        k1 = rhs(u_hat)\n        k2 = rhs(u_hat + 0.5 * dt * k1)\n        k3 = rhs(u_hat + 0.5 * dt * k2)\n        k4 = rhs(u_hat + dt * k3)\n        u_hat += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n    \n    # 6. Calculate final energy\n    u_final = np.fft.ifft(u_hat)\n    # The physical solution must be real; numerical errors introduce a small imaginary part.\n    E_final = 0.5 * dx * np.sum(np.real(u_final)**2)\n    \n    # 7. Compute and return drift\n    energy_drift = E_final - E0\n    return energy_drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, T, dealias_mode)\n        (64, 0.5, \"none\"),\n        (64, 0.5, \"2/3\"),\n        (16, 0.5, \"none\"),\n        (64, 0.95, \"2/3\"),\n    ]\n\n    # Fixed time step for all simulations to ensure stability and\n    # make temporal errors subdominant to spatial ones.\n    dt = 0.001\n\n    results = []\n    for case in test_cases:\n        N, T, dealias_mode = case\n        drift = run_simulation(N, T, dealias_mode, dt)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}