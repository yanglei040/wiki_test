{
    "hands_on_practices": [
        {
            "introduction": "本练习是生成合成湍流的基石。我们将学习如何将不相关的随机数转化为具有真实湍流统计特性的速度脉动，这些特性由雷诺应力张量 $R_{ij}$ 描述。通过本次实践，你将亲手实现基于 Cholesky 分解的方法，这是一种在任何随机场中施加期望相关性的强大工具。",
            "id": "3369516",
            "problem": "给定一个从雷诺平均纳维-斯托克斯 (RANS) 解中获得的雷诺应力张量的法向剖面，记为 $R_{ij}(y)$，其中 $y$ 是法向坐标。目标是使用基于 Cholesky 分解的协方差映射方法，合成与 $R_{ij}(y)$ 一致的湍流入口波动，然后应用一个简化的弛豫模型来评估大涡模拟 (LES) 的入口流是否能快速恢复正确的近壁各向异性，而无需很长的流向发展长度。该问题必须以无量纲形式处理。\n\n定义与基本原理：\n- 雷诺平均纳维-斯托克斯 (RANS) 是一个统计框架，其中脉动速度 $u'_i$ 的均值为零，协方差 $R_{ij}(y) = \\langle u'_i u'_j \\rangle$ 对于物理上可实现的湍流状态是半正定的。\n- 大涡模拟 (LES) 是一种数值方法，它解析大尺度的湍流运动，同时对亚格子尺度进行建模。\n- 对称正定矩阵 $R(y)$ 的 Cholesky 分解是一个下三角矩阵 $L(y)$，满足 $R(y) = L(y) L(y)^{\\top}$。如果 $\\boldsymbol{\\xi}$ 是一个协方差为单位矩阵的标准正态随机向量，那么根据期望的线性性质和高斯随机变量的特性，$\\mathbf{u}'(y) = L(y)\\boldsymbol{\\xi}$ 的协方差为 $R(y)$。\n- 湍动能为 $k(y) = \\tfrac{1}{2} \\operatorname{tr}(R(y))$。\n- 各向异性张量为 $b_{ij}(y) = \\dfrac{R_{ij}(y)}{2 k(y)} - \\dfrac{1}{3} \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克符号，并且 $b_{ij}$ 根据其构造是无迹的。\n\n您必须设计一个程序，纯粹以数学术语执行以下步骤：\n1. 对每个测试用例，定义一个无量纲的域高 $H$，一个均匀的平流速度 $U$，一个近壁区域 $\\{ y/H \\leq \\alpha \\}$（其中 $\\alpha$ 在下面指定），一个弛豫时间尺度 $T(y)$，以及用于合成采样的实现样本数 $M$。\n2. 使用提供的类 RANS 剖面，在一组离散的 $y$ 位置上构造 $R_{ij}(y)$。确保协方差矩阵在数值上是可分解的。如果给定的 $R(y)$ 不是严格正定的，则应用最小对角正则化 $R(y) \\leftarrow R(y) + \\varepsilon I$，其中 $\\varepsilon > 0$ 选择得足够小以允许进行 Cholesky 分解，$I$ 是单位矩阵。\n3. 通过抽取 $M$ 个 $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\mathbf{0}, I)$ 的独立实现，并进行映射 $\\mathbf{u}'(y) = L(y)\\boldsymbol{\\xi}$，在每个 $y$ 处生成合成入口样本。根据合成的实现估计样本协方差 $S(y)$，并从 $S(y)$ 计算合成的各向异性 $b^{\\text{init}}(y)$。\n4. 假设近壁区域中每个 $y$ 处的各向异性误差遵循一个局部线性弛豫模型：\n   $$ \\frac{d}{dt}\\left( b_{ij}(y,t) - b^{\\text{target}}_{ij}(y) \\right) = -\\frac{1}{T(y)} \\left( b_{ij}(y,t) - b^{\\text{target}}_{ij}(y) \\right), $$\n   初始条件为 $b_{ij}(y,0) = b^{\\text{init}}_{ij}(y)$，目标各向异性为从 $R_{ij}(y)$ 计算得到的 $b^{\\text{target}}_{ij}(y)$。根据 Taylor 的冻结湍流假设，流向发展长度为 $x = U t$。\n5. 将位置 $y$ 处的近壁各向异性误差范数定义为差值 $e(y,t) = \\left\\| b(y,t) - b^{\\text{target}}(y) \\right\\|_{F}$ 的 Frobenius 范数，并将近壁阈值设为 $\\epsilon_{b}$。对于上述弛豫模型，解为 $b(y,t) - b^{\\text{target}}(y) = \\left( b^{\\text{init}}(y) - b^{\\text{target}}(y) \\right) \\exp\\left( -\\dfrac{t}{T(y)} \\right)$，因此\n   $$ e(y,t) = e(y,0) \\exp\\left( -\\frac{t}{T(y)} \\right), \\quad e(y,0) = \\left\\| b^{\\text{init}}(y) - b^{\\text{target}}(y) \\right\\|_{F}. $$\n   令 $t_{\\text{rec}}$ 为满足对于近壁区域中所有 $y$ 都有 $e(y,t_{\\text{rec}}) \\leq \\epsilon_{b}$ 的最小时间。那么\n   $$ t_{\\text{rec}} = \\max_{y \\in \\text{near-wall}} \\left\\{ T(y) \\max\\left( 0, \\ln\\left( \\frac{e(y,0)}{\\epsilon_{b}} \\right) \\right) \\right\\}. $$\n   相应的无量纲流向发展长度为 $\\dfrac{x_{\\text{rec}}}{H} = \\dfrac{U \\, t_{\\text{rec}}}{H}$。\n6. 如果 $\\dfrac{x_{\\text{rec}}}{H} \\leq L_{\\text{thr}}$，则认为测试“快速恢复”了正确的近壁各向异性，其中 $L_{\\text{thr}}$ 是一个指定的无量纲阈值。\n\n您的程序必须实现上述规范，并生成单行输出，其中包含一个用方括号括起来的逗号分隔的布尔值列表，精确地以 $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$ 的格式，指示每个测试用例是否满足“快速恢复”标准。\n\n请使用以下测试套件。在所有情况下，将 $y$ 在 $[0,H]$ 上离散为 $N=41$ 个均匀间隔的点，并通过 $y/H \\leq \\alpha$（其中 $\\alpha = 0.1$）定义近壁区域。所有量均为无量纲，且不出现角度。任何地方均不使用百分比。\n\n测试用例 1（近壁各向异性，中等恢复）：\n- $H = 1.0$, $U = 1.0$, $M = 200$, $\\epsilon_{b} = 0.03$, $L_{\\text{thr}} = 0.5$。\n- 湍动能：$k(y) = k_{\\min} + 0.25\\left(1 - e^{-7 y}\\right)$，其中 $k_{\\min} = 10^{-4}$。\n- 定义 $R(y)$ 的对角分数：$f_{x}(y) = \\tfrac{1}{3} + 0.18 e^{-y/0.05}$，$f_{y}(y) = \\tfrac{1}{3} - 0.04 e^{-y/0.05}$，$f_{z}(y) = 1 - f_{x}(y) - f_{y}(y)$。\n- 雷诺应力张量：$R(y) = \\operatorname{diag}\\left( 2 k(y) f_{x}(y), 2 k(y) f_{y}(y), 2 k(y) f_{z}(y) \\right)$。\n- 弛豫时间尺度：$T(y) = 0.05 + 0.15 \\sqrt{y}$。\n\n测试用例 2（各向同性目标，快速恢复）：\n- $H = 1.0$, $U = 1.0$, $M = 200$, $\\epsilon_{b} = 0.03$, $L_{\\text{thr}} = 0.5$。\n- 湍动能：$k(y) = k_{\\min} + 0.25\\left(1 - e^{-3 y}\\right)$，其中 $k_{\\min} = 10^{-4}$。\n- 各向同性分数：$f_{x}(y) = f_{y}(y) = f_{z}(y) = \\tfrac{1}{3}$。\n- 雷诺应力张量：$R(y) = \\operatorname{diag}\\left( 2 k(y) f_{x}(y), 2 k(y) f_{y}(y), 2 k(y) f_{z}(y) \\right)$。\n- 弛豫时间尺度：$T(y) = 0.02 + 0.05 y$。\n\n测试用例 3（近壁处能量接近奇异，慢速恢复）：\n- $H = 1.0$, $U = 2.0$, $M = 200$, $\\epsilon_{b} = 0.03$, $L_{\\text{thr}} = 0.5$。\n- 湍动能：$k(y) = 10^{-6} + 0.02 y$。\n- 近壁强各向异性：$f_{x}(y) = \\tfrac{1}{3} + 0.32 e^{-y/0.02}$，$f_{y}(y) = \\tfrac{1}{3} - 0.23 e^{-y/0.02}$，$f_{z}(y) = 1 - f_{x}(y) - f_{y}(y)$。\n- 雷诺应力张量：$R(y) = \\operatorname{diag}\\left( 2 k(y) f_{x}(y), 2 k(y) f_{y}(y), 2 k(y) f_{z}(y) \\right)$。\n- 弛豫时间尺度：$T(y) = 2.0 + y$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[ \\text{result}_{1}, \\text{result}_{2}, \\text{result}_{3} ]$），其中每个 $\\text{result}_{i}$ 根据相应测试用例的 $\\dfrac{x_{\\text{rec}}}{H} \\leq L_{\\text{thr}}$ 是否成立而为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "该问题被认为是有效的，因为它在科学上基于计算流体动力学和湍流模型的原理，其定义和参数清晰完整，问题提法适定，且其表述是客观的。\n\n所指定的方法是一种标准的（尽管是简化的）数值程序，用于评估用于大涡模拟 (LES) 的合成湍流入口条件的质量。\n\n解决方案通过实现指定的多步骤算法来执行。对于每个测试用例，我们将：\n1. 定义物理和数值参数，并离散化空间域。\n2. 在每个离散的法向位置 $y$ 处，构造目标雷诺应力张量 $R_{ij}(y)$。\n3. 生成一个有限的合成速度脉动系综，并计算样本协方差矩阵 $S(y)$。\n4. 计算目标各向异性张量 $b^{\\text{target}}(y)$ 和合成场的初始各向异性张量 $b^{\\text{init}}(y)$。\n5. 确定各向异性张量的初始误差 $e(y,0)$，并使用提供的弛豫模型计算恢复时间 $t_{\\text{rec}}$ 和相应的流向发展长度 $x_{\\text{rec}}$。\n6. 将恢复长度与阈值进行比较，以确定恢复是否足够迅速。\n\n高度为 $H$ 的法向域被离散为 $N=41$ 个均匀间隔的点，$y_j = j \\cdot H / (N-1)$，其中 $j=0, 1, \\dots, N-1$。\n\n对于每个测试用例和每个点 $y_j$，都会构造一个目标雷诺应力张量 $R(y_j)$。问题指定 $R(y_j)$ 为一个对角矩阵，\n$$\nR(y_j) = \\operatorname{diag}\\left( 2 k(y_j) f_{x}(y_j), 2 k(y_j) f_{y}(y_j), 2 k(y_j) f_{z}(y_j) \\right)\n$$\n其中 $k(y)$ 是湍动能，$f_x(y), f_y(y), f_z(y)$ 是总和为 1 的分数分量。这种构造确保了与湍动能定义 $k(y) = \\frac{1}{2}\\operatorname{tr}(R(y))$ 的一致性。分量 $R_{ii}(y)$ 是方差，必须为非负。所提供的 $k(y)$ 和 $f_i(y)$ 函数确保了这一点，使得 $R(y)$ 成为一个正定矩阵。\n\n为了生成合成的湍流脉动，我们使用基于 Cholesky 分解的协方差映射方法。对于每个目标协方差矩阵 $R(y_j)$，我们找到其 Cholesky 分解，即一个下三角矩阵 $L(y_j)$，使得 $R(y_j) = L(y_j) L(y_j)^{\\top}$。由于 $R(y_j)$ 是对角的， $L(y_j)$ 也是对角的，其元素是 $R(y_j)$ 对角元素的平方根。然后我们生成一个 3 维随机向量 $\\boldsymbol{\\xi}_k \\sim \\mathcal{N}(\\mathbf{0}, I)$ 的 $M$ 个样本，其中 $I$ 是 $3 \\times 3$ 的单位矩阵。合成的速度脉动则由下式给出\n$$\n\\mathbf{u}'_k(y_j) = L(y_j) \\boldsymbol{\\xi}_k, \\quad k=1, \\dots, M.\n$$\n根据构造，这些样本协方差的期望为 $E[\\mathbf{u}' (\\mathbf{u}')^\\top] = L E[\\boldsymbol{\\xi} \\boldsymbol{\\xi}^\\top] L^\\top = L I L^\\top = R(y_j)$。\n\n由于有限的样本量 $M$，从 $M$ 个实现中计算出的样本协方差矩阵 $S(y_j)$ 将与目标 $R(y_j)$ 不同。样本协方差估计为\n$$\nS(y_j) = \\frac{1}{M} \\sum_{k=1}^{M} \\mathbf{u}'_k(y_j) \\left(\\mathbf{u}'_k(y_j)\\right)^{\\top}.\n$$\n$S(y_j)$ 和 $R(y_j)$ 之间的这种统计差异是入口条件中初始误差的来源。\n\n各向异性的状态由各向异性张量 $b_{ij} = \\frac{R_{ij}}{2k} - \\frac{1}{3}\\delta_{ij}$ 来量化。我们从 $R(y_j)$ 计算目标各向异性 $b^{\\text{target}}(y_j)$，并从 $S(y_j)$ 计算合成场的初始各向异性 $b^{\\text{init}}(y_j)$。每个位置 $y_j$ 的初始误差是它们差值的 Frobenius 范数：\n$$\ne(y_j, 0) = \\left\\| b^{\\text{init}}(y_j) - b^{\\text{target}}(y_j) \\right\\|_{F}.\n$$\n由于采样效应，这个误差是非零的。为了使该误差有良好定义，样本湍动能 $k_{\\text{sample}}(y_j) = \\frac{1}{2}\\operatorname{tr}(S(y_j))$ 必须为非零，这在实践中是有保证的。\n\n该问题假定了一个线性弛豫模型来描述此误差在下游的演化。在点 $y_j$ 处，误差衰减到容差 $\\epsilon_b$ 所需的时间是 $T(y_j) \\ln(e(y_j,0)/\\epsilon_b)$，前提是 $e(y_j,0) > \\epsilon_b$。总恢复时间 $t_{\\text{rec}}$ 是在近壁区域（由 $y_j/H \\le \\alpha$ 定义）内所有点 $y_j$ 中所需的最大时间。这表示为：\n$$\nt_{\\text{rec}} = \\max_{y_j/H \\le \\alpha} \\left\\{ T(y_j) \\max\\left( 0, \\ln\\left( \\frac{e(y_j,0)}{\\epsilon_{b}} \\right) \\right) \\right\\}.\n$$\n使用 $\\max(0, \\cdot)$ 可以正确地将初始误差已经低于阈值的点的恢复时间设置为 0。\n\n最后，援引 Taylor 的冻结湍流假设，恢复所需的流向发展长度为 $x_{\\text{rec}} = U t_{\\text{rec}}$。无量纲长度为 $\\frac{x_{\\text{rec}}}{H}$。如果此长度不大于指定的阈值 $L_{\\text{thr}}$，则一个测试用例被分类为“快速恢复”：\n$$\n\\frac{U t_{\\text{rec}}}{H} \\le L_{\\text{thr}}.\n$$\n此程序应用于三个测试用例中的每一个，以产生一个布尔结果。为了保证可复现性，对随机数生成器使用了固定的种子。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    \n    # Define test cases as a list of dictionaries.\n    test_cases = [\n        {\n            \"name\": \"Test case 1\",\n            \"H\": 1.0, \"U\": 1.0, \"M\": 200, \"epsilon_b\": 0.03, \"L_thr\": 0.5,\n            \"k_func\": lambda y: 1e-4 + 0.25 * (1 - np.exp(-7 * y)),\n            \"fx_func\": lambda y: 1/3 + 0.18 * np.exp(-y / 0.05),\n            \"fy_func\": lambda y: 1/3 - 0.04 * np.exp(-y / 0.05),\n            \"T_func\": lambda y: 0.05 + 0.15 * np.sqrt(y)\n        },\n        {\n            \"name\": \"Test case 2\",\n            \"H\": 1.0, \"U\": 1.0, \"M\": 200, \"epsilon_b\": 0.03, \"L_thr\": 0.5,\n            \"k_func\": lambda y: 1e-4 + 0.25 * (1 - np.exp(-3 * y)),\n            \"fx_func\": lambda y: 1/3,\n            \"fy_func\": lambda y: 1/3,\n            \"T_func\": lambda y: 0.02 + 0.05 * y\n        },\n        {\n            \"name\": \"Test case 3\",\n            \"H\": 1.0, \"U\": 2.0, \"M\": 200, \"epsilon_b\": 0.03, \"L_thr\": 0.5,\n            \"k_func\": lambda y: 1e-6 + 0.02 * y,\n            \"fx_func\": lambda y: 1/3 + 0.32 * np.exp(-y / 0.02),\n            \"fy_func\": lambda y: 1/3 - 0.23 * np.exp(-y / 0.02),\n            \"T_func\": lambda y: 2.0 + y\n        }\n    ]\n\n    # Common parameters\n    N = 41\n    alpha = 0.1\n    # Regularization epsilon, as suggested by the problem, though not strictly needed for these cases.\n    reg_eps = 1e-12 \n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    results = []\n\n    for case in test_cases:\n        H = case[\"H\"]\n        U = case[\"U\"]\n        M = case[\"M\"]\n        epsilon_b = case[\"epsilon_b\"]\n        L_thr = case[\"L_thr\"]\n        k_func = case[\"k_func\"]\n        fx_func = case[\"fx_func\"]\n        fy_func = case[\"fy_func\"]\n        T_func = case[\"T_func\"]\n        \n        # 1. Discretize domain\n        y = np.linspace(0, H, N)\n        \n        # Identify near-wall indices\n        near_wall_indices = np.where(y / H = alpha)[0]\n        \n        initial_errors = np.zeros(N)\n        \n        for j, y_j in enumerate(y):\n            # 2. Construct target Reynolds stress tensor R(y)\n            k_j = k_func(y_j)\n            fx_j = fx_func(y_j)\n            fy_j = fy_func(y_j)\n            fz_j = 1 - fx_j - fy_j\n\n            R_target_diag = 2 * k_j * np.array([fx_j, fy_j, fz_j])\n            R_target = np.diag(R_target_diag)\n            \n            # Apply regularization\n            R_target += reg_eps * np.identity(3)\n            \n            # 3. Generate synthetic fluctuations\n            L = np.linalg.cholesky(R_target)\n            xi_samples = rng.standard_normal(size=(M, 3))\n            u_prime_samples = (L @ xi_samples.T).T\n            \n            # Estimate sample covariance S(y)\n            S = (u_prime_samples.T @ u_prime_samples) / M\n            \n            # 4. Compute anisotropy tensors and initial error\n            k_target = 0.5 * np.trace(R_target)\n            b_target = R_target / (2 * k_target) - (1/3) * np.identity(3)\n            \n            k_sample = 0.5 * np.trace(S)\n            if k_sample  1e-12: # Avoid division by zero\n                b_init = np.zeros((3, 3))\n            else:\n                b_init = S / (2 * k_sample) - (1/3) * np.identity(3)\n            \n            # Calculate initial error norm\n            e0 = np.linalg.norm(b_init - b_target, 'fro')\n            initial_errors[j] = e0\n            \n        # 5. Compute recovery time and length\n        e0_nw = initial_errors[near_wall_indices]\n        y_nw = y[near_wall_indices]\n        T_nw = T_func(y_nw)\n        \n        # Calculate recovery time for each point in the near-wall region\n        # Use np.divide to handle e0_nw/epsilon_b without log(0) warnings\n        ratio = np.divide(e0_nw, epsilon_b, out=np.zeros_like(e0_nw, dtype=float), where=epsilon_b!=0)\n        # Suppress invalid value warning for log(0) which becomes -inf\n        with np.errstate(divide='ignore'):\n            log_term = np.log(ratio)\n        \n        # max(0, log_term) handles e0 = epsilon_b case\n        recovery_times_at_points = T_nw * np.maximum(0, log_term)\n        \n        t_rec = np.max(recovery_times_at_points)\n        x_rec_over_H = (U * t_rec) / H\n        \n        # 6. Check recovery criterion\n        is_quick_recovery = x_rec_over_H = L_thr\n        results.append(is_quick_recovery)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在掌握了如何生成匹配特定目标的湍流之后，一个关键问题随之而来：我们应该瞄准什么样的目标？本练习深入探讨了湍流平衡的物理原理，即湍动能的生成（$P$）与其耗散（$\\epsilon$）相等。你将探索一个遵循此 $P=\\epsilon$ 平衡的入口条件如何引出稳定且物理真实的下游流场，而一个不匹配的条件则会引发非物理的调整过程，从而强调了入口的物理一致性对高保真模拟的至关重要性。",
            "id": "3369520",
            "problem": "您将设计并实现一个自包含程序，用于为对流平面剪切流构建合成入流湍流，并评估不匹配的入流生成相对于耗散对下游平均剪切的影响。该框架基于雷诺平均纳维-斯托克斯 (RANS) 模型，以及在一个由特征位置表示的固定横流位置上，对一个代表性单点状态进行一维流向对流的建模。所有变量、常数和方程都必须使用国际单位制 (SI单位) 处理。程序必须按照最终输出格式中指定的方式生成结果。\n\n从基本原理出发：\n- 雷诺平均纳维-斯托克斯 (RANS) 分解定义了平均速度 $U$、湍流脉动 $u'$ 和 $v'$，以及雷诺剪切应力 $-\\langle u' v' \\rangle$。\n- 在忽略扩散和平均压力功的情况下，湍动能 $k$ 以对流形式满足生成与耗散的平衡，对于稳定、均匀的对流速度 $U_c$，其公式为\n$$\nU_c \\frac{d k}{d x} = P - \\epsilon,\n$$\n其中 $P$ 是生成项，$\\epsilon$ 是耗散项。\n- 在入流平面上的生成项定义为\n$$\nP = -\\langle u' v' \\rangle \\, \\frac{\\partial U}{\\partial y},\n$$\n其中 $\\frac{\\partial U}{\\partial y}$ 是平均剪切 $S$。\n\n使用 Boussinesq 涡粘性闭合、标准湍动能-耗散模型和恒定对流速度：\n- Boussinesq 假设给出\n$$\n-\\langle u' v' \\rangle = \\nu_t \\, S,\n$$\n其中 $\\nu_t$ 是湍流（涡）粘度， $S = \\frac{\\partial U}{\\partial y}$ 是平均剪切率。\n- 将涡粘度建模为\n$$\n\\nu_t = \\frac{C_\\mu k^2}{\\epsilon},\n$$\n或者，等效地，当耗散表示为\n$$\n\\epsilon = C_\\epsilon \\frac{k^{3/2}}{\\ell},\n$$\n涡粘度简化为\n$$\n\\nu_t = \\frac{C_\\mu}{C_\\epsilon} \\, \\ell \\, k^{1/2}.\n$$\n此处 $C_\\mu$ 和 $C_\\epsilon$ 是无量纲闭合常数，$\\ell$ 是一个预设的湍流长度尺度。\n- 总剪切应力（平均加湍流）通过以下方式与平均剪切相关联：\n$$\n\\tau_0 = \\rho \\, (\\nu + \\nu_t) \\, S,\n$$\n其中 $\\rho$ 是密度，$\\nu$ 是分子运动粘度。对于此问题，将 $\\tau_0$ 视为一个外部施加的常数，该常数根据匹配的入流条件计算，并在下游保持不变。\n\n入流合成湍流的生成：\n- 指定一个名义入流平均剪切 $S_0$。匹配的入流条件要求在入流平面上生成等于耗散，即在 $x=0$ 处 $P = \\epsilon$。从上述关系式出发，推导出与 $x=0$ 处 $P = \\epsilon$ 一致的入流动能 $k_0$ 和雷诺剪切应力 $-\\langle u' v' \\rangle_0$。\n- 然后对入流雷诺剪切应力施加一个不匹配因子 $f$，以创建与匹配条件之间的受控偏差，即：\n$$\n-\\langle u' v' \\rangle_{0,\\text{mismatch}} = f \\, \\big(-\\langle u' v' \\rangle_{0,\\text{matched}}\\big).\n$$\n给定这个不匹配的 $-\\langle u' v' \\rangle_{0,\\text{mismatch}}$ 和指定的 $S_0$，推导出与上述涡粘性闭合一致的相应初始 $k_0$。将此 $k_0$ 用作 $k(x)$ 下游演化的初始条件。\n\n下游演化模型：\n- 使用以下公式沿 $x$ 方向演化 $k(x)$：\n$$\nU_c \\frac{d k}{d x} = \\nu_t(k) \\, S(k)^2 - \\epsilon(k),\n$$\n其中 $\\nu_t(k) = \\frac{C_\\mu}{C_\\epsilon} \\, \\ell \\, k^{1/2}$，$\\epsilon(k) = C_\\epsilon \\frac{k^{3/2}}{\\ell}$，以及\n$$\nS(k) = \\frac{\\tau_0}{\\rho \\, (\\nu + \\nu_t(k))}.\n$$\n- 最终得到的 $S(k(x))$ 必须在指定的下游位置 $x=L$ 处计算，单位为 $\\mathrm{s}^{-1}$。您必须报告保留六位小数的 $S(L)$。\n\n测试套件：\n使用以下固定的物理和模型参数 (SI单位)：\n- 密度: $\\rho = 1.2 \\, \\mathrm{kg/m^3}$\n- 分子运动粘度: $\\nu = 1.5 \\times 10^{-5} \\, \\mathrm{m^2/s}$\n- 对流速度: $U_c = 10.0 \\, \\mathrm{m/s}$\n- 湍流闭合常数: $C_\\mu = 0.09$, $C_\\epsilon = 1.0$\n- 湍流长度尺度: $\\ell = 0.01 \\, \\mathrm{m}$\n- 入流名义平均剪切: $S_0 = 100.0 \\, \\mathrm{s^{-1}}$\n- 下游距离: $L = 5.0 \\, \\mathrm{m}$\n\n通过推导出的匹配条件 $P=\\epsilon$ 来计算匹配的入流雷诺剪切应力 $-\\langle u' v' \\rangle_{0,\\text{matched}}$，并用它来构建不匹配的初始条件。根据匹配的入流状态构建恒定剪切应力 $\\tau_0$：\n$$\n\\tau_0 = \\rho \\, (\\nu + \\nu_{t,0}) \\, S_0,\n$$\n其中 $\\nu_{t,0}$ 是匹配的入流涡粘度。对所有测试用例都使用此 $\\tau_0$。\n\n针对以下不匹配因子 $f$ 评估 $S(L)$：\n- 情况 1 (理想情况): $f = 1.0$\n- 情况 2 (湍流指定不足): $f = 0.5$\n- 情况 3 (湍流指定过度): $f = 2.0$\n- 情况 4 (边缘情况，严重指定不足): $f = 0.1$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含下游平均剪切值，格式为方括号内以逗号分隔的列表，单位为 $\\mathrm{s}^{-1}$，每个值都四舍五入到六位小数，并按照测试套件用例的顺序排列，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$，不含空格。这些值必须是浮点数。\n\n不允许用户输入。所提供的程序必须是完整的且可运行的。",
            "solution": "该问题要求设计并实现一个程序，以模拟对流剪切流中湍流的下游演化。任务的核心是求解关于湍动能 $k$ 的常微分方程 (ODE)，并利用结果确定指定下游位置的平均剪切 $S$。分析过程分为几个明确的步骤。\n\n### 步骤 1：匹配入流条件的分析\n\n问题指定了一个“匹配”的入流条件，即在入流平面 $x=0$ 处，湍流生成项 $P$ 与其耗散率 $\\epsilon$ 相等。我们利用此条件来确定基准湍流状态。\n\n相关方程如下：\n- 生成项：$P = -\\langle u' v' \\rangle S = \\nu_t S^2$，其中 $S$ 是平均剪切，$\\nu_t$ 是涡粘度。\n- 耗散项：$\\epsilon = C_\\epsilon \\frac{k^{3/2}}{\\ell}$，其中 $k$ 是湍动能，$\\ell$ 是湍流长度尺度，$C_\\epsilon$ 是一个模型常数。\n- 涡粘度：$\\nu_t = \\frac{C_\\mu k^2}{\\epsilon}$，在代入 $\\epsilon$ 的表达式后，变为 $\\nu_t = \\frac{C_\\mu}{C_\\epsilon} \\ell k^{1/2}$，其中 $C_\\mu$ 是另一个模型常数。\n\n在入流平面 ($x=0$)，剪切为名义剪切 $S_0$。匹配条件是 $P_0 = \\epsilon_0$，其中下标 $0$ 表示该平面上的量。\n$$\n\\nu_{t,0} S_0^2 = \\epsilon_0\n$$\n将 $\\nu_{t,0}$ 和 $\\epsilon_0$ 的模型表达式用匹配的入流动能 $k_{0,\\text{matched}}$ 表示并代入：\n$$\n\\left( \\frac{C_\\mu}{C_\\epsilon} \\ell k_{0,\\text{matched}}^{1/2} \\right) S_0^2 = C_\\epsilon \\frac{k_{0,\\text{matched}}^{3/2}}{\\ell}\n$$\n假设是湍流流入 ($k_{0,\\text{matched}}  0$)，我们可以除以 $k_{0,\\text{matched}}^{1/2}$ 并求解 $k_{0,\\text{matched}}$：\n$$\n\\left( \\frac{C_\\mu}{C_\\epsilon} \\ell \\right) S_0^2 = \\frac{C_\\epsilon}{\\ell} k_{0,\\text{matched}}\n$$\n$$\nk_{0,\\text{matched}} = \\frac{C_\\mu}{C_\\epsilon^2} \\ell^2 S_0^2\n$$\n此方程根据指定的模型常数和名义剪切，给出了匹配入流情况下的湍动能。\n\n### 步骤 2：恒定总剪切应力的确定\n\n总剪切应力 $\\tau_0$ 在整个计算域中被视为常数。其值由匹配的入流状态确定：\n$$\n\\tau_0 = \\rho (\\nu + \\nu_{t,0,\\text{matched}}) S_0\n$$\n其中 $\\rho$ 是流体密度，$\\nu$ 是分子运动粘度，$\\nu_{t,0,\\text{matched}}$ 是对应于 $k_{0,\\text{matched}}$ 的涡粘度：\n$$\n\\nu_{t,0,\\text{matched}} = \\frac{C_\\mu}{C_\\epsilon} \\ell k_{0,\\text{matched}}^{1/2}\n$$\n\n### 步骤 3：不匹配入流的初始条件\n\n对于一般情况，入流雷诺剪切应力通过一个因子 $f$ 进行有意的不匹配：\n$$\n-\\langle u' v' \\rangle_{0,\\text{mismatch}} = f \\cdot \\left(-\\langle u' v' \\rangle_{0,\\text{matched}}\\right)\n$$\n使用 Boussinesq 假设 $-\\langle u' v' \\rangle = \\nu_t S$，并注意到入流处的平均剪切始终为 $S_0$，我们可以关联涡粘度：\n$$\n\\nu_{t,0,\\text{mismatch}} S_0 = f \\cdot (\\nu_{t,0,\\text{matched}} S_0) \\implies \\nu_{t,0,\\text{mismatch}} = f \\cdot \\nu_{t,0,\\text{matched}}\n$$\n现在，我们使用 $\\nu_t = \\frac{C_\\mu}{C_\\epsilon} \\ell k^{1/2}$ 来关联涡粘度与动能：\n$$\n\\frac{C_\\mu}{C_\\epsilon} \\ell k_{0,\\text{mismatch}}^{1/2} = f \\cdot \\left(\\frac{C_\\mu}{C_\\epsilon} \\ell k_{0,\\text{matched}}^{1/2}\\right)\n$$\n这简化为初始动能之间的直接关系：\n$$\nk_{0,\\text{mismatch}}^{1/2} = f \\cdot k_{0,\\text{matched}}^{1/2} \\implies k_{0,\\text{mismatch}} = f^2 \\cdot k_{0,\\text{matched}}\n$$\n对于由 $f$ 定义的每个测试用例，该值 $k_{0,\\text{mismatch}}$ 作为下游演化的初始条件 $k(0)$。\n\n### 步骤 4：演化方程的构建\n\n$k$ 的下游演化由对流-生成-耗散平衡控制：\n$$\nU_c \\frac{d k}{d x} = P(k) - \\epsilon(k)\n$$\n其中 $U_c$ 是恒定的对流速度。生成项和耗散项是演化中的 $k(x)$ 的函数。平均剪切 $S$ 不再是常数，而是会调整以维持恒定的总应力 $\\tau_0$：\n$$\nS(k) = \\frac{\\tau_0}{\\rho (\\nu + \\nu_t(k))}\n$$\n因此，$k(x)$ 的完整常微分方程为：\n$$\n\\frac{d k}{d x} = \\frac{1}{U_c} \\left[ \\nu_t(k) S(k)^2 - \\epsilon(k) \\right]\n$$\n代入所有模型依赖关系，我们得到需要数值求解的最终形式：\n$$\n\\frac{d k}{d x} = \\frac{1}{U_c} \\left[ \\left(\\frac{C_\\mu}{C_\\epsilon} \\ell k^{1/2}\\right) \\left(\\frac{\\tau_0}{\\rho\\left(\\nu + \\frac{C_\\mu}{C_\\epsilon}\\ell k^{1/2}\\right)}\\right)^2 - C_\\epsilon \\frac{k^{3/2}}{\\ell} \\right]\n$$\n这是一个关于 $k(x)$ 的一阶非线性自治常微分方程。\n\n### 步骤 5：数值解与最终计算\n\n对于每个不匹配因子 $f$，程序如下：\n1.  计算初始条件 $k(0) = k_{0,\\text{mismatch}} = f^2 k_{0,\\text{matched}}$。\n2.  对于特殊情况 $f=1$， $k(0) = k_{0,\\text{matched}}$。初始状态是 $P=\\epsilon$ 的平衡状态，因此 $\\frac{dk}{dx}=0$。所以，对于所有 $x$，$k(x)$ 保持常数 $k_{0,\\text{matched}}$，且 $S(L) = S_0$。\n3.  对于 $f \\neq 1$，求解 $k(x)$ 从 $x=0$ 到下游距离 $x=L$ 的常微分方程。这是一个初值问题 (IVP)，可以使用标准的数值积分器（如龙格-库塔法）来求解。\n4.  一旦找到 $k(L)$ 的值，相应的下游平均剪切 $S(L)$ 计算如下：\n$$\nS(L) = S(k(L)) = \\frac{\\tau_0}{\\rho \\left(\\nu + \\frac{C_\\mu}{C_\\epsilon} \\ell k(L)^{1/2}\\right)}\n$$\n5.  按要求将每个用例的最终结果四舍五入到六位小数。程序将对所有指定的 $f$ 值执行此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Constructs synthetic inflow turbulence and computes the downstream mean shear.\n    \"\"\"\n    # Fixed physical and model parameters (SI units)\n    rho = 1.2  # Density (kg/m^3)\n    nu = 1.5e-5  # Molecular kinematic viscosity (m^2/s)\n    Uc = 10.0  # Convective speed (m/s)\n    C_mu = 0.09  # Turbulence closure constant\n    C_eps = 1.0  # Turbulence closure constant\n    ell = 0.01  # Turbulent length scale (m)\n    S0 = 100.0  # Inflow nominal mean shear (s^-1)\n    L = 5.0  # Downstream distance (m)\n\n    # Test suite of mismatch factors\n    test_cases = [1.0, 0.5, 2.0, 0.1]\n\n    # --- Step 1: Matched Inflow Condition ---\n    # Calculate the turbulence kinetic energy for the matched case (P=epsilon)\n    # k_0_matched = (C_mu / C_eps^2) * l^2 * S_0^2\n    k0_matched = (C_mu / C_eps**2) * ell**2 * S0**2\n\n    # Calculate the corresponding matched eddy viscosity\n    # nu_t = (C_mu / C_eps) * l * k^(1/2)\n    nu_t0_matched = (C_mu / C_eps) * ell * np.sqrt(k0_matched)\n\n    # --- Step 2: Constant Total Shear Stress ---\n    # Calculate tau_0 from the matched inflow state; it remains constant downstream.\n    # tau_0 = rho * (nu + nu_t) * S\n    tau0 = rho * (nu + nu_t0_matched) * S0\n\n    # --- Helper functions for the ODE ---\n    def get_nu_t(k):\n        # Eddy viscosity as a function of k\n        # Ensure k is non-negative to avoid domain errors with sqrt\n        k_safe = np.maximum(k, 0)\n        return (C_mu / C_eps) * ell * np.sqrt(k_safe)\n\n    def get_S(k):\n        # Mean shear S as a function of k, maintaining constant tau_0\n        return tau0 / (rho * (nu + get_nu_t(k)))\n\n    def get_epsilon(k):\n        # Dissipation epsilon as a function of k\n        k_safe = np.maximum(k, 0)\n        return C_eps * k_safe**(1.5) / ell\n\n    def dk_dx(x, y):\n        \"\"\"\n        ODE function for dk/dx. `y` is a 1-element array containing k.\n        dk/dx = (1/Uc) * (Production - Dissipation)\n        \"\"\"\n        k = y[0]\n        \n        # Production P = nu_t * S^2\n        production = get_nu_t(k) * get_S(k)**2\n        \n        # Dissipation\n        dissipation = get_epsilon(k)\n        \n        return [(1.0 / Uc) * (production - dissipation)]\n\n    results = []\n    # --- Loop through test cases ---\n    for f in test_cases:\n        # For f=1.0, the system is in equilibrium. k is constant, so S(L) = S0.\n        if f == 1.0:\n            S_L = S0\n        else:\n            # --- Step 3: Mismatched Initial Condition ---\n            # k_0_mismatch = f^2 * k_0_matched\n            k0_mismatch = f**2 * k0_matched\n\n            # --- Step 4: Downstream Evolution ---\n            # Solve the initial value problem for k(x) from x=0 to x=L\n            sol = solve_ivp(\n                dk_dx,\n                [0, L],\n                [k0_mismatch],\n                method='RK45',\n                rtol=1e-9,  # Relative tolerance for accuracy\n                atol=1e-12, # Absolute tolerance for accuracy\n            )\n\n            # Extract the solution k at the final location x=L\n            k_L = sol.y[0, -1]\n\n            # --- Step 5: Final Calculation ---\n            # Compute the final mean shear S(L) from k(L)\n            S_L = get_S(k_L)\n\n        # Append the rounded result to the list\n        results.append(f\"{S_L:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个实践将我们的知识整合到一个复杂的实际应用中：模拟流经粗糙度变化表面的流动。在这里，你不会直接得到目标统计量；相反，你必须首先运用基本的边界层理论来推导相应的平均速度和湍流强度剖面。本练习将挑战你如何平滑地混合这些剖面以跨越粗糙度过渡区，并生成一个空间相关的湍流场，从而完整地再现了在高级计算流体力学模拟（如大气或工程流动问题）中所必需的工作流程。",
            "id": "3369497",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序为一个具有空间变化的空气动力学粗糙度长度 $z_0(x)$ 的壁面有界流生成合成湍流入口，在一个粗糙度过渡区平滑地混合平均速度 $U(y)$ 和湍流强度 $I(y)$ 的剖面，并验证粗糙度机制之间的过渡是一致的。该程序必须是自包含的，并且不得需要任何用户输入。其科学和计算背景是研究生高级水平的计算流体力学（CFD）。\n\n您必须从基本且广为接受的基础出发，而不是从此处提供的任何简化公式。允许使用以下基础：\n- 通过壁面剪切应力和适用于粗糙壁面边界层的中性层结壁面律对数定律来定义摩擦速度 $u_\\ast$，该定律关联了参考平均速度和粗糙度长度。\n- 雷诺分解 $u(x,y,z,t) = U(y) + u'(x,y,z,t)$ 以及湍流强度的定义，即由当地平均值缩放的无量纲均方根脉动。\n- 假设在中性层结、平衡条件下，外层统计量以 $u_\\ast$ 和壁面法向距离 $y$ 为主要外部变量，并承认相似性。\n- 通过对白噪声进行滤波以施加与指定相关长度一致的空间相关性，从而生成高斯随机场。\n\n您的任务：\n1) 平均速度和摩擦速度的构建。考虑在具有空间变化的粗糙度长度 $z_0(x)$ 的均匀、平坦地形上的中性层结条件。给定参考高度 $H_{\\mathrm{ref}}$ 处的地球物理参考平均速度 $U_{\\mathrm{ref}}$。从基本边界层理论出发，推导在中性条件下摩擦速度 $u_\\ast$ 与对 $(U_{\\mathrm{ref}}, z_0)$ 之间的关系，然后推导在对数区域内对满足平衡相似性假设的壁面法向距离 $y$ 有效的平均流向速度剖面 $U(y)$。您的程序必须使用固定的 von Kármán 常数和给定参数来实现这些推导。所有速度必须以 $\\mathrm{m/s}$ 表示，所有长度必须以 $\\mathrm{m}$ 表示。\n\n2) 湍流强度模型。使用无量纲和相似性论证（本说明中未提供简化目标公式），构建一个壁面法向湍流强度剖面 $I(y; z_0)$，该剖面关于 $y$ 单调递减，与摩擦速度 $u_\\ast$ 适当地缩放，并对于非常光滑的表面和粗糙得多的表面，都能产生物理上合理的近壁区和外层量级。您必须确保对于测试套件中使用的两个锚定粗糙度机制，以下定性约束成立：\n- 对于光滑情况，对数区下部的近壁流向湍流强度 $I(y)$ 在 $[0.06, 0.10]$ 范围内，并向上减小到一个小的有限值。\n- 对于粗糙情况，近壁的 $I(y)$ 在 $[0.14, 0.20]$ 范围内，同样向上减小到一个小的有限值。\n您的程序必须实现一个与这些约束以及从平衡相似性证明的 $u_\\ast$ 缩放相一致的特定函数形式，但不得导入任何外部数据。\n\n3) 跨越粗糙度过渡区的平滑混合。定义两个锚定粗糙度长度（一个非常光滑的表面和一个粗糙的表面），并构建它们对应的锚定剖面 $U_{\\mathrm{s}}(y)$、$I_{\\mathrm{s}}(y)$ 和 $U_{\\mathrm{r}}(y)$、$I_{\\mathrm{r}}(y)$。构建一个严格单调的、$C^1$ 光滑的混合权重 $w(x)$，该权重满足在过渡区远上游 $w(x)=0$，远下游 $w(x)=1$，在过渡中心 $w(x)=0.5$。使用它通过以下方式混合平均速度和湍流强度：\n$$\nU(y;x) = \\bigl(1 - w(x)\\bigr)\\, U_{\\mathrm{s}}(y) + w(x)\\, U_{\\mathrm{r}}(y), \\quad\nI(y;x) = \\bigl(1 - w(x)\\bigr)\\, I_{\\mathrm{s}}(y) + w(x)\\, I_{\\mathrm{r}}(y).\n$$\n您还必须构建一个在同一过渡区平滑变化的 $z_0(x)$。每个具有物理单位的量必须酌情以 $\\mathrm{m}$ 或 $\\mathrm{m/s}$ 表示。\n\n4) 合成湍流入口的生成。在给定的一组流向位置 $x$ 处，为每个壁面法向位置 $y$ 使用在展向坐标 $z$ 上的空间相关的零均值高斯随机场，生成一个合成脉动场 $u'(y,z;x)$。施加一个随 $y$ 增大的目标相关长度，遵循平衡相似性论证，并相应地对白噪声进行滤波以施加这种相关性。对于每个 $(y,x)$，强制使 $u'(y,\\cdot;x)$ 在 $z$ 上的标准差等于目标 $\\sigma_u(y;x) = I(y;x)\\, U(y;x)$，并使每个 $y$ 处的展向平均值精确为零，从而使 $z$ 平均入口恢复为 $U(y;x)$。\n\n5) 验证指标。对于下面提供的测试套件中的每个 $x$，计算：\n- 平均剖面中的相对 $\\ell_2$ 误差，比较合成场的展向平均值与目标 $U(y;x)$ 在所有 $y$ 网格点上的差异。\n- 标准差剖面中的相对 $\\ell_2$ 误差，比较合成场的展向标准差与目标 $\\sigma_u(y;x)$ 在所有 $y$ 网格点上的差异。\n对于每个 $x$，将这两个相对误差中的最大值报告为单个浮点数。\n\n测试套件和参数：\n- 参考速度与高度：$U_{\\mathrm{ref}} = 10.0\\,\\mathrm{m/s}$ 在 $H_{\\mathrm{ref}} = 50.0\\,\\mathrm{m}$。\n- von Kármán 常数：使用 $\\kappa = 0.41$。\n- 锚定粗糙度：光滑 $z_{0,\\mathrm{s}} = 0.0002\\,\\mathrm{m}$ 和粗糙 $z_{0,\\mathrm{r}} = 0.0500\\,\\mathrm{m}$。\n- 粗糙度过渡：中心在 $x_0 = 0.0\\,\\mathrm{m}$，半宽为 $W/2 = 10.0\\,\\mathrm{m}$，因此混合区间为 $[x_0 - W/2, x_0 + W/2] = [-10.0\\,\\mathrm{m}, 10.0\\,\\mathrm{m}]$。\n- 壁面法向网格：在 $[y_{\\min}, y_{\\max}] = [1.0\\,\\mathrm{m}, 50.0\\,\\mathrm{m}]$ 上均匀分布，有 $N_y = 128$ 个点。\n- 展向网格：在 $z \\in [0.0\\,\\mathrm{m}, 200.0\\,\\mathrm{m}]$ 上均匀分布，有 $N_z = 128$ 个点。\n- 合成场的可复现性：将伪随机种子设置为 $42$。\n- 测试流向位置：$x \\in \\{-200.0\\,\\mathrm{m}, -10.0\\,\\mathrm{m}, 0.0\\,\\mathrm{m}, 10.0\\,\\mathrm{m}, 200.0\\,\\mathrm{m}\\}$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表的第 $k$ 个条目是对应第 $k$ 个测试 $x$ 的单个浮点数，定义为上述第 5 项中描述的两个相对 $\\ell_2$ 误差的最大值（无量纲）。例如，输出必须看起来像 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是一个浮点数。\n\n所有物理单位必须如上所述明确处理，如有任何角度，必须以弧度表示。百分比必须表示为小数。您的设计必须基于上述基本原理，必须避免任何不符合物理的假设，并且在整个规范中必须在数值上保持自洽。程序必须能够按原样运行，无需外部输入或文件。",
            "solution": "我们从粗糙壁面上方的平衡、中性层结的壁面有界边界层开始，其中对数区域内的平均流向速度剖面和摩擦速度由一个经过充分检验的定律联系起来。壁面剪切应力为 $\\tau_w = \\rho u_\\ast^2$，在中性层结下，给定粗糙度长度 $z_0$ 和在高度 $H_{\\mathrm{ref}}$ 处的参考平均速度 $U_{\\mathrm{ref}}$，粗糙壁面的对数律产生一个函数关系，通过重新排列可以计算出摩擦速度 $u_\\ast$。一旦对于给定的 $z_0$ 知道了 $u_\\ast$，对数区域内的平均剖面就可以作为函数 $U(y; z_0, u_\\ast, \\kappa)$ 得到，该函数在 $y$ 既远离粘性子层又远离外缘的区域内有效。\n\n对于两个锚定粗糙度机制，一个是非常光滑的表面（粗糙度为 $z_{0,\\mathrm{s}}$）和一个粗糙表面（粗糙度为 $z_{0,\\mathrm{r}}$），我们通过在 $(H_{\\mathrm{ref}},U_{\\mathrm{ref}})$ 处应用对数律并求解 $u_\\ast$ 来计算 $u_{\\ast,\\mathrm{s}}$ 和 $u_{\\ast,\\mathrm{r}}$：\n$$\nU_{\\mathrm{ref}} = \\frac{u_\\ast}{\\kappa}\\,\\ln\\!\\left(\\frac{H_{\\mathrm{ref}}}{z_0}\\right)\n\\quad\\Rightarrow\\quad\nu_\\ast(z_0) = \\kappa\\, U_{\\mathrm{ref}} \\,\\Big/ \\ln\\!\\left(\\frac{H_{\\mathrm{ref}}}{z_0}\\right).\n$$\n该表达式是写成粗糙度长度形式的中性对数律的直接推论，这是一个标准的、经过充分检验的事实。利用这一点，对于 $y \\in [y_{\\min},y_{\\max}]$ 的锚定平均剖面为：\n$$\nU_{\\mathrm{s}}(y) = \\frac{u_{\\ast,\\mathrm{s}}}{\\kappa}\\,\\ln\\!\\left(\\frac{y}{z_{0,\\mathrm{s}}}\\right),\n\\quad\nU_{\\mathrm{r}}(y) = \\frac{u_{\\ast,\\mathrm{r}}}{\\kappa}\\,\\ln\\!\\left(\\frac{y}{z_{0,\\mathrm{r}}}\\right).\n$$\n这些剖面在对数区域内有效，我们确保 $y_{\\min} \\gg z_0$ 以维持对数律的适用性。使用 $H_{\\mathrm{ref}} = 50.0\\,\\mathrm{m}$，$U_{\\mathrm{ref}} = 10.0\\,\\mathrm{m/s}$，$\\kappa = 0.41$，$z_{0,\\mathrm{s}} = 0.0002\\,\\mathrm{m}$ 和 $z_{0,\\mathrm{r}} = 0.0500\\,\\mathrm{m}$，我们计算：\n$$\nu_{\\ast,\\mathrm{s}} = \\frac{0.41 \\cdot 10.0}{\\ln(50.0 / 0.0002)} \\approx \\frac{4.10}{\\ln(250000)} \\approx \\frac{4.10}{12.429} \\approx 0.3299\\,\\mathrm{m/s},\n$$\n$$\nu_{\\ast,\\mathrm{r}} = \\frac{0.41 \\cdot 10.0}{\\ln(50.0 / 0.0500)} \\approx \\frac{4.10}{\\ln(1000)} \\approx \\frac{4.10}{6.9078} \\approx 0.5934\\,\\mathrm{m/s}.\n$$\n这些值在物理上是合理的：在 $H_{\\mathrm{ref}}$ 处给定相同的 $U_{\\mathrm{ref}}$，更粗糙的表面会产生更大的 $u_\\ast$。\n\n对于湍流强度，我们依赖于平衡相似性和量纲分析。在平衡壁面有界湍流中，流向脉动速度尺度由 $u_\\ast$ 设定，壁面法向的变化由无量纲比率如 $y/H_{\\mathrm{ref}}$（对于大气型边界层）或 $y/\\delta$（对于厚度为 $\\delta$ 的典型边界层）控制。一个与这些思想一致的简单单调模型是，令流向湍流强度剖面 $I(y; z_0)$ 可分离为一个依赖于 $z_0$ 的近壁振幅和一个随 $y$ 衰减的函数：\n$$\nI(y; z_0) = I_0(z_0)\\, \\frac{1}{1 + y / L_I},\n$$\n其中 $L_I$ 是一个外层长度尺度，$I_0(z_0)$ 是一个随粗糙度增加而增加的近壁振幅，从而在更粗糙的表面上产生更大的近壁强度。我们选择 $L_I = 0.3\\,H_{\\mathrm{ref}} = 15.0\\,\\mathrm{m}$ 作为一个合理的外层尺度，以便强度在 $[y_{\\min}, y_{\\max}]$ 内从其近壁值衰减到一个更小但有限的高处值。为了设定 $I_0(z_0)$，我们要求其在两个锚定点处的值落在物理上合理的范围内。我们选择：\n$$\nI_0(z_{0,\\mathrm{s}}) = 0.08, \\qquad I_0(z_{0,\\mathrm{r}}) = 0.18,\n$$\n这满足了光滑表面近壁强度在 $[0.06,0.10]$ 和粗糙表面在 $[0.14,0.20]$ 的约束。对于中间的 $z_0$，一个与粗糙度单调性一致的平滑函数是在 $\\ln z_0$ 上对两个锚定点进行线性插值：\n$$\ns(z_0) = \\frac{\\ln z_0 - \\ln z_{0,\\mathrm{s}}}{\\ln z_{0,\\mathrm{r}} - \\ln z_{0,\\mathrm{s}}}, \\quad s \\in [0,1],\n\\quad\nI_0(z_0) = (1 - s) \\cdot 0.08 + s \\cdot 0.18.\n$$\n这种构建方法是合理的，因为对数粗糙度度量在边界层气象学中普遍使用，并且该方法保持了单调性。\n\n接下来，我们构建一个跨越粗糙度过渡区的平滑混合。令 $w(x)$ 为一个 $C^1$ 光滑阶跃权重，当 $x \\le x_0 - W/2$ 时为 $0$，当 $x \\ge x_0 + W/2$ 时为 $1$，并在其间平滑单调变化。定义混合区间内的无量纲横坐标：\n$$\n\\xi(x) = \\frac{x - (x_0 - W/2)}{W} \\in [0,1],\n$$\n并使用标准的三次 $C^1$ 光滑阶跃函数：\n$$\nw(x) = \\begin{cases}\n0,   x \\le x_0 - W/2,\\\\\n3 \\xi(x)^2 - 2 \\xi(x)^3,   x_0 - W/2  x  x_0 + W/2,\\\\\n1,   x \\ge x_0 + W/2.\n\\end{cases}\n$$\n我们还定义一个平滑变化的粗糙度 $z_0(x)$，它在对数空间中在 $z_{0,\\mathrm{s}}$ 和 $z_{0,\\mathrm{r}}$ 之间单调过渡：\n$$\n\\ln z_0(x) = (1 - w(x)) \\ln z_{0,\\mathrm{s}} + w(x) \\ln z_{0,\\mathrm{r}},\n\\quad\\text{所以}\\quad\nz_0(x) = \\exp\\!\\bigl((1 - w)\\ln z_{0,\\mathrm{s}} + w \\ln z_{0,\\mathrm{r}}\\bigr).\n$$\n目标混合平均值和强度则定义为两个锚定剖面的凸组合：\n$$\nU(y;x) = (1 - w(x)) U_{\\mathrm{s}}(y) + w(x) U_{\\mathrm{r}}(y), \\quad\nI(y;x) = (1 - w(x)) I_{\\mathrm{s}}(y) + w(x) I_{\\mathrm{r}}(y),\n$$\n其中 $I_{\\mathrm{s}}(y) = I(y; z_{0,\\mathrm{s}})$ 且 $I_{\\mathrm{r}}(y) = I(y; z_{0,\\mathrm{r}})$。\n\n对于合成脉动，我们在每个 $(y,x)$ 处生成一个展向随机场 $u'(y,z;x)$，它是一个零均值、高斯、空间相关的过程，其指定的相关长度随 $y$ 增加，这与平衡壁面湍流中积分长度尺度随壁面距离增加而增加的规律一致。利用混合长度概念 $l_m \\sim \\kappa y$，我们设定一个展向相关长度 $L_z(y) = \\max(L_{z,\\min}, a_y y + L_{z,0})$，其中常数 $L_{z,\\min}$、$a_y$ 和 $L_{z,0}$ 的选择使得相关长度为正且随 $y$ 增加。为实现相关场，我们：\n- 在 $z$ 方向上抽取白噪声，\n- 通过离散傅里叶变换转换到波数空间，\n- 乘以一个高斯谱滤波器 $\\exp\\!\\bigl(-\\tfrac{1}{2}(k L_z(y))^2\\bigr)$，\n- 变换回物理空间以获得相关场，\n- 移除展向平均值以在每个 $y$ 处强制零均值，\n- 在每个 $y$ 处重新缩放标准差以匹配 $\\sigma_u(y;x) = I(y;x)\\,U(y;x)$。\n\n最后，在每个测试 $x$ 处，我们计算验证指标：\n- 令 $\\overline{u}(y;x)$ 为 $U(y;x) + u'(y,\\cdot;x)$ 在每个 $y$ 处的展向平均值。相对 $\\ell_2$ 平均误差为：\n$$\nE_U(x) = \\frac{\\left\\| \\overline{u}(\\cdot;x) - U(\\cdot;x) \\right\\|_2}{\\left\\| U(\\cdot;x) \\right\\|_2}.\n$$\n- 令 $\\hat{\\sigma}_u(y;x)$ 为 $u'(y,\\cdot;x)$ 在每个 $y$ 处的展向标准差。相对 $\\ell_2$ 强度误差为：\n$$\nE_\\sigma(x) = \\frac{\\left\\| \\hat{\\sigma}_u(\\cdot;x) - \\sigma_u(\\cdot;x) \\right\\|_2}{\\left\\| \\sigma_u(\\cdot;x) \\right\\|_2}.\n$$\n然后我们为每个 $x$ 报告一个等于 $\\max\\{E_U(x), E_\\sigma(x)\\}$ 的浮点数。\n\n实现中使用的数值选择和参数：\n- 我们取 $U_{\\mathrm{ref}} = 10.0\\,\\mathrm{m/s}$，$H_{\\mathrm{ref}} = 50.0\\,\\mathrm{m}$，$\\kappa = 0.41$ 如给定。\n- 锚定值 $z_{0,\\mathrm{s}} = 0.0002\\,\\mathrm{m}$ 和 $z_{0,\\mathrm{r}} = 0.0500\\,\\mathrm{m}$。\n- 混合中心和宽度：$x_0 = 0.0\\,\\mathrm{m}$，半宽 $W/2 = 10.0\\,\\mathrm{m}$。\n- 壁面法向网格 $y \\in [1.0\\,\\mathrm{m}, 50.0\\,\\mathrm{m}]$，有 $N_y = 128$ 个点。\n- 展向网格 $z \\in [0.0\\,\\mathrm{m}, 200.0\\,\\mathrm{m}]$，有 $N_z = 128$ 个点，用于滤波的周期性。\n- 强度模型 $I(y; z_0) = I_0(z_0)/(1 + y/L_I)$，其中 $L_I = 15.0\\,\\mathrm{m}$，$I_0(z_0)$ 在光滑和粗糙锚定值的 $0.08$ 和 $0.18$ 之间进行 $\\ln z_0$ 插值。\n- 相关长度 $L_z(y) = \\max(1.0\\,\\mathrm{m}, 0.1\\,y + 1.0\\,\\mathrm{m})$；谱滤波器 $\\exp\\!\\bigl(-\\tfrac{1}{2}(k L_z(y))^2\\bigr)$。\n- 随机种子设置为 $42$ 以保证可复现性。\n\n通过这些选择，算法强制使每个 $y$ 处的展向平均值精确匹配 $U(y;x)$，且每个 $y$ 处的展向标准差精确匹配 $\\sigma_u(y;x)$（在浮点舍入误差范围内），这会产生非常小的 $E_U(x)$ 和 $E_\\sigma(x)$。光滑阶跃混合确保了剖面在光滑和粗糙锚定条件之间平滑过渡，而在五个指定 $x$ 值处的验证分别检验了上游、边缘、中心、边缘和下游的条件。\n\n最终程序将这些步骤组合起来，并打印一行，其中包含一个 Python 列表，内有五个浮点数，每个浮点数对应一个测试 $x$，其值等于指定的两个相对 $\\ell_2$ 误差中的最大值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef smoothstep_weight(x, x0, half_width):\n    \"\"\"C1 smoothstep weight: 0 for x=x0-half_width, 1 for x>=x0+half_width, cubic in between.\"\"\"\n    left = x0 - half_width\n    right = x0 + half_width\n    if x = left:\n        return 0.0\n    if x >= right:\n        return 1.0\n    xi = (x - left) / (right - left)  # in (0,1)\n    return 3.0 * xi**2 - 2.0 * xi**3\n\ndef friction_velocity_kappa_loglaw(U_ref, H_ref, z0, kappa=0.41):\n    \"\"\"Compute u_* from neutral log-law with roughness length, given U_ref at H_ref.\"\"\"\n    return kappa * U_ref / np.log(H_ref / z0)\n\ndef mean_log_profile(y, z0, u_star, kappa=0.41):\n    \"\"\"Log-law mean profile U(y) for rough-wall using roughness length (neutral).\"\"\"\n    return (u_star / kappa) * np.log(y / z0)\n\ndef intensity_profile(y, z0, z0_s, z0_r, I0_s=0.08, I0_r=0.18, L_I=15.0):\n    \"\"\"\n    Monotone decreasing turbulence intensity I(y; z0) = I0(z0) / (1 + y/L_I),\n    with I0(z0) interpolated in ln(z0) between anchors.\n    \"\"\"\n    # Interpolate in log space between anchors to get near-wall amplitude\n    s = (np.log(z0) - np.log(z0_s)) / (np.log(z0_r) - np.log(z0_s))\n    s = float(np.clip(s, 0.0, 1.0))\n    I0 = (1.0 - s) * I0_s + s * I0_r\n    return I0 / (1.0 + y / L_I)\n\ndef spanwise_correlated_noise(Nz, Lz_domain, Lcorr):\n    \"\"\"\n    Generate a single 1D spanwise correlated Gaussian sample by filtering white noise\n    with a Gaussian spectral filter having correlation length Lcorr.\n    \"\"\"\n    # White noise\n    w = np.random.normal(0.0, 1.0, size=Nz)\n    # rFFT and wavenumbers\n    fhat = np.fft.rfft(w)\n    k = 2.0 * np.pi * np.fft.rfftfreq(Nz, d=Lz_domain / Nz)  # radians per meter\n    # Spectral Gaussian filter\n    filt = np.exp(-0.5 * (k * Lcorr) ** 2)\n    fhat_filtered = fhat * filt\n    # Back to physical space\n    sample = np.fft.irfft(fhat_filtered, n=Nz)\n    return sample\n\ndef synthesize_inflow_for_x(x, params):\n    \"\"\"\n    For a given streamwise location x, construct U(y;x), I(y;x), and a synthetic fluctuation field u'(y,z;x)\n    with spanwise correlation, zero mean per y, and prescribed std per y. Compute verification errors.\n    \"\"\"\n    # Unpack parameters\n    U_ref = params[\"U_ref\"]\n    H_ref = params[\"H_ref\"]\n    kappa = params[\"kappa\"]\n    z0_s = params[\"z0_s\"]\n    z0_r = params[\"z0_r\"]\n    x0 = params[\"x0\"]\n    halfw = params[\"halfw\"]\n    y = params[\"y\"]\n    z = params[\"z\"]\n    Lz_domain = params[\"Lz_domain\"]\n    # Blending weight\n    w = smoothstep_weight(x, x0, halfw)\n    # Anchors: friction velocity\n    ustar_s = friction_velocity_kappa_loglaw(U_ref, H_ref, z0_s, kappa=kappa)\n    ustar_r = friction_velocity_kappa_loglaw(U_ref, H_ref, z0_r, kappa=kappa)\n    # Anchor mean profiles\n    U_s = mean_log_profile(y, z0_s, ustar_s, kappa=kappa)\n    U_r = mean_log_profile(y, z0_r, ustar_r, kappa=kappa)\n    # Blended target mean\n    U_target = (1.0 - w) * U_s + w * U_r\n    # Anchor intensity profiles\n    I_s = intensity_profile(y, z0_s, z0_s, z0_r)\n    I_r = intensity_profile(y, z0_r, z0_s, z0_r)\n    # Blended intensity\n    I_target = (1.0 - w) * I_s + w * I_r\n    # Target std\n    sigma_target = I_target * U_target\n    # Synthesize spanwise correlated zero-mean fluctuations with prescribed std per y\n    Ny = y.size\n    Nz = z.size\n    u_fluct = np.zeros((Ny, Nz), dtype=float)\n    for j in range(Ny):\n        # Correlation length increasing with y: Lz(y) = max(1.0, 0.1*y + 1.0)\n        Lcorr = max(1.0, 0.1 * float(y[j]) + 1.0)\n        sample = spanwise_correlated_noise(Nz, Lz_domain, Lcorr)\n        # Enforce zero mean and unit std (before scaling)\n        sample = sample - np.mean(sample)\n        std = np.std(sample)\n        if std  1e-12:\n            # Degenerate; fall back to zeros\n            scaled = np.zeros_like(sample)\n        else:\n            scaled = sample / std\n        # Scale to target std at this y\n        u_fluct[j, :] = scaled * sigma_target[j]\n    # Construct the full field U(y,z;x) = U_target(y) + u'(y,z;x)\n    # The problem implies U(y;x) is the target mean, which we name U_target\n    # The synthetic field is U_field = U_target + u'\n    U_field = U_target[:, None] + u_fluct\n    # Verification metrics: mean in z vs target, std in z vs target\n    U_mean_est = np.mean(U_field, axis=1)  # length Ny\n    sigma_est = np.std(u_fluct, axis=1)\n    # Relative L2 errors across wall-normal grid\n    def rel_l2(a, b):\n        denom = np.linalg.norm(b)\n        if denom  1e-16:\n            return 0.0\n        return float(np.linalg.norm(a - b) / denom)\n    E_U = rel_l2(U_mean_est, U_target)\n    E_sigma = rel_l2(sigma_est, sigma_target)\n    return max(E_U, E_sigma)\n\ndef solve():\n    # Parameters from the problem statement\n    U_ref = 10.0  # m/s\n    H_ref = 50.0  # m\n    kappa = 0.41\n    z0_s = 0.0002  # m\n    z0_r = 0.0500  # m\n    x0 = 0.0       # m\n    halfw = 10.0   # m (transition half-width)\n    # Grids\n    Ny = 128\n    Nz = 128\n    y_min, y_max = 1.0, 50.0  # m\n    z0, zL = 0.0, 200.0       # m\n    y = np.linspace(y_min, y_max, Ny)\n    z = np.linspace(z0, zL, Nz, endpoint=False)\n    # Test streamwise locations\n    test_x = [-200.0, -10.0, 0.0, 10.0, 200.0]\n    # Seed for reproducibility\n    np.random.seed(42)\n    params = {\n        \"U_ref\": U_ref,\n        \"H_ref\": H_ref,\n        \"kappa\": kappa,\n        \"z0_s\": z0_s,\n        \"z0_r\": z0_r,\n        \"x0\": x0,\n        \"halfw\": halfw,\n        \"y\": y,\n        \"z\": z,\n        \"Lz_domain\": zL - z0,\n    }\n    results = []\n    for x in test_x:\n        err = synthesize_inflow_for_x(x, params)\n        # Format to a reasonable number of decimals to avoid long floats\n        results.append(f\"{err:.6e}\")\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}