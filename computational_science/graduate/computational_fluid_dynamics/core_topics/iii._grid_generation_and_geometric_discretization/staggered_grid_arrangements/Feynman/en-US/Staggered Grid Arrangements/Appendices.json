{
    "hands_on_practices": [
        {
            "introduction": "A foundational challenge in simulating incompressible flows is preventing non-physical pressure oscillations. This practice directly confronts this issue by demonstrating how a naive colocated grid can suffer from pressure-velocity decoupling, leading to spurious \"checkerboard\" modes. By implementing a manufactured forcing term, you will numerically show why the Marker-and-Cell (MAC) staggered grid arrangement is inherently stable and robust against this critical failure mode. ",
            "id": "3365597",
            "problem": "Consider the steady, incompressible Stokes equations on a two-dimensional periodic domain of length $L=1$ in each direction, with spatial coordinates $(x,y)$ and velocity field $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$:\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\nwhere $p(x,y)$ is the pressure, $\\nu$ is the kinematic viscosity, and $\\mathbf{f}(x,y)$ is a given body force. In a fractional-step projection approach, the pressure field $p$ is recovered from the following Poisson equation for pressure associated with enforcing discrete incompressibility:\n$$\n\\nabla^2 p = s,\n$$\nwhere $s$ is a discrete source constructed from the divergence of an intermediate velocity field. On a uniform Cartesian grid with spacing $\\Delta x = \\Delta y$, different grid arrangements lead to different discrete gradient and divergence operators. In particular:\n- The colocated (cell-centered) arrangement places $u$, $v$, and $p$ all at cell centers. A common naive central-difference implementation computes the discrete pressure gradient at centers using nearest neighbors in each coordinate direction:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i,j+1} - p_{i,j-1}}{2 \\Delta x}.\n$$\n- The Marker-and-Cell (MAC) staggered arrangement places $u$ on vertical faces at $(i+\\tfrac{1}{2}, j)$, $v$ on horizontal faces at $(i, j+\\tfrac{1}{2})$, and $p$ at cell centers $(i,j)$. The discrete pressure gradient naturally appears at faces:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}} = \\frac{p_{i,j+1} - p_{i,j}}{\\Delta x}.\n$$\n\nIt is known that colocated central differences admit a spurious pressure mode, often called a checkerboard mode, which is defined on an $N_x \\times N_y$ uniform periodic grid by\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j}, \\quad i = 0,1,\\dots,N_x-1, \\quad j = 0,1,\\dots,N_y-1,\n$$\nand corresponds to the highest resolvable spatial frequency (the Nyquist mode). This mode can be excited by certain discrete forcings and, on colocated grids, can decouple from the momentum equations under naive interpolation from centers to faces, leading to nonphysical oscillations in $p$ that do not drive momentum. In contrast, the MAC staggering suppresses this decoupling because the face-centered discrete gradient directly samples adjacent cell-center pressures, and the checkerboard difference does not vanish at faces.\n\nYour task is to:\n1. Use a manufactured source $s_{i,j} = (-1)^{i+j}$ to excite the checkerboard mode in the discrete pressure Poisson equation with periodic boundary conditions, discretized by the standard five-point Laplacian. The discrete Fourier symbol of the five-point Laplacian on a uniform grid of spacing $\\Delta x$ is\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\nfor discrete wavenumbers $k_x = \\frac{2\\pi m}{L}$, $k_y = \\frac{2\\pi n}{L}$, where $m = 0,1,\\dots,N_x-1$ and $n = 0,1,\\dots,N_y-1$. The checkerboard mode corresponds to $(m,n) = (N_x/2, N_y/2)$ when $N_x$ and $N_y$ are even, giving $\\cos(\\pi) = -1$ and thus\n$$\n\\lambda_{\\text{chk}} = -\\frac{4}{\\Delta x^2} - \\frac{4}{\\Delta x^2} = -\\frac{8}{\\Delta x^2}.\n$$\nFrom this, the pressure amplitude associated with the checkerboard forcing scales as\n$$\nA_p(\\Delta x) = \\frac{1}{|\\lambda_{\\text{chk}}|} = \\frac{\\Delta x^2}{8}.\n$$\n2. Numerically solve the discrete periodic Poisson equation $\\nabla^2 p = s$ using the discrete Laplacian symbol above in the Fourier domain for a sequence of uniform grids, and extract the numerical amplitude $A_p(\\Delta x)$ of the checkerboard component by projecting the computed $p$ onto $p^{\\text{chk}}$.\n3. Compute and compare the root-mean-square (RMS) magnitude of the face-centered pressure gradient that would enter the momentum equations under:\n   - A colocated naive face-gradient obtained by averaging cell-centered gradients at adjacent cells to faces:\n   $$\n   \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1,j}^{\\text{col}}\\right], \\quad\n   \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+1}^{\\text{col}}\\right].\n   $$\n   - The MAC face-gradient, as defined above. The RMS magnitude is defined as\n   $$\n   G_{\\text{RMS}} = \\sqrt{\\frac{1}{N_f}\\sum_{f} g_f^2},\n   $$\n   where $g_f$ ranges over all face gradient components in both directions and $N_f$ is the number of faces.\n4. Demonstrate numerically that:\n   - The colocated naive face-gradient is blind to the checkerboard component so that its RMS magnitude is numerically zero for the manufactured forcing, explaining the decoupling.\n   - The MAC face-gradient couples to the checkerboard mode, and its RMS magnitude scales like $\\mathcal{O}(\\Delta x)$ for the manufactured forcing because $A_p(\\Delta x) \\sim \\Delta x^2$ and the face gradient scales like $A_p(\\Delta x)/\\Delta x$.\n\nImplement a program that:\n- Builds the manufactured source $s_{i,j} = (-1)^{i+j}$ on a periodic domain of length $L=1$.\n- Solves the discrete Poisson equation in Fourier space using the discrete Laplacian symbol to obtain $p_{i,j}$.\n- Computes the numerical checkerboard amplitude $A_p(\\Delta x)$ via projection onto $(-1)^{i+j}$.\n- Computes $G_{\\text{RMS}}^{\\text{col-face}}$ and $G_{\\text{RMS}}^{\\text{MAC}}$ for the resulting $p_{i,j}$.\n- Reports the tuple $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ for each grid.\n\nTest Suite:\n- Use square grids with $N_x=N_y$ and $L=1$ for the following cases:\n  1. $N_x=N_y=8$ (coarse grid, $\\Delta x = 1/8$).\n  2. $N_x=N_y=16$ (moderate grid, $\\Delta x = 1/16$).\n  3. $N_x=N_y=32$ (fine grid, $\\Delta x = 1/32$).\n  4. $N_x=N_y=64$ (very fine grid, $\\Delta x = 1/64$).\nAll reported quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of four bracketed tuples, each tuple ordered as $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ in the same order as the test cases, for example:\n\"[(a1,b1,c1),(a2,b2,c2),(a3,b3,c3),(a4,b4,c4)]\".",
            "solution": "We begin from the steady incompressible Stokes equations\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\nwhich, under a fractional-step approach, leads to enforcing discrete incompressibility via a pressure Poisson equation\n$$\n\\nabla^2 p = s,\n$$\nwhere the source $s$ is obtained from the divergence of an intermediate velocity. On a uniform periodic grid, solving this Poisson equation in the discrete Fourier space is natural and reveals how certain spatial modes propagate into pressure. We focus on the checkerboard (Nyquist) mode,\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j},\n$$\nwhich alternates in sign between neighboring cell centers.\n\nFor a uniform grid with spacing $\\Delta x$ and periodic boundary conditions, the standard five-point discrete Laplacian has Fourier symbol\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\nwith discrete wavenumbers $k_x = \\frac{2\\pi m}{L}$ and $k_y = \\frac{2\\pi n}{L}$, $m=0,\\dots,N_x-1$, $n=0,\\dots,N_y-1$, and $L=1$. For the checkerboard mode, $(m,n)=(N_x/2, N_y/2)$ and $k_x \\Delta x = \\pi$, $k_y \\Delta x = \\pi$, giving\n$$\n\\lambda_{\\text{chk}} = \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) = \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) + \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) = -\\frac{8}{\\Delta x^2}.\n$$\nForcing the Poisson equation with $s_{i,j}=(-1)^{i+j}$ means the right-hand side has only this mode. Therefore the solution is proportional to the same mode:\n$$\np_{i,j} = A_p(\\Delta x)\\, (-1)^{i+j}.\n$$\nPlugging into the discrete Poisson equation in Fourier space yields\n$$\n\\lambda_{\\text{chk}} A_p(\\Delta x) = 1 \\quad \\Rightarrow \\quad A_p(\\Delta x) = -\\frac{1}{\\lambda_{\\text{chk}}} = \\frac{\\Delta x^2}{8}.\n$$\nThus the amplitude of the checkerboard component in the computed pressure scales as $\\Delta x^2$.\n\nThe distinction between colocated and Marker-and-Cell (MAC) staggering enters through how the pressure gradient is represented in the momentum equations:\n- In a colocated (cell-centered) scheme, a common naive implementation uses central differences to estimate $\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}}$ and $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}$ at cell centers. For the checkerboard pressure $p_{i,j} = A_p(\\Delta x)\\,(-1)^{i+j}$,\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i-1+j}\\right]}{2\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}\\left[-1 - (-1)\\right]}{2\\Delta x} = 0,\n$$\nand a similar calculation shows $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}=0$. If one then naively forms face gradients by averaging adjacent center gradients, the resulting face pressure gradient that would drive the momentum equations is still zero. This demonstrates the decoupling: the checkerboard pressure produces no face-centered pressure force in the colocated naive scheme.\n- In the MAC staggered arrangement, the face-centered discrete gradient directly takes differences of adjacent center pressures:\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i+j}\\right]}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}(-1 - 1)}{\\Delta x}\n= -\\frac{2\\,A_p(\\Delta x)}{\\Delta x}\\,(-1)^{i+j}.\n$$\nAn analogous expression holds for $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}}$. Consequently, the MAC face-gradient couples strongly to the checkerboard and drives momentum corrections that suppress such oscillations. The magnitude of the MAC face-gradient scales like $\\frac{A_p(\\Delta x)}{\\Delta x} \\sim \\frac{\\Delta x^2}{\\Delta x} = \\mathcal{O}(\\Delta x)$ for the manufactured forcing.\n\nAlgorithmic design for the program:\n1. For each test grid with $N_x=N_y$ and $\\Delta x = 1/N_x$, construct the manufactured source $s_{i,j} = (-1)^{i+j}$.\n2. Compute the two-dimensional discrete Fourier transform of $s$ to obtain $\\hat{s}(m,n)$.\n3. For each Fourier mode $(m,n)$, compute the discrete Laplacian symbol $\\lambda(m,n)$ using\n$$\n\\lambda(m,n) = \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi m}{N_x}\\right)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi n}{N_y}\\right)-1\\right).\n$$\n4. Compute $\\hat{p}(m,n) = \\hat{s}(m,n) / \\lambda(m,n)$ for all $(m,n)$ such that $\\lambda(m,n) \\neq 0$. The zero mode $(m,n)=(0,0)$ is absent in $\\hat{s}$ due to the alternating pattern, so division by zero does not occur.\n5. Inverse transform to obtain $p_{i,j}$ in physical space.\n6. Project $p$ onto the checkerboard pattern to extract the amplitude,\n$$\nA_p(\\Delta x) = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}(-1)^{i+j}.\n$$\n7. Compute colocated center gradients using central differences and then obtain colocated face-gradients by averaging adjacent center gradients to faces. Compute the root-mean-square magnitude over all faces:\n$$\nG_{\\text{RMS}}^{\\text{col-face}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{col-face}}\\right)^2}.\n$$\n8. Compute MAC face-gradients from adjacent center pressures and the corresponding root-mean-square magnitude:\n$$\nG_{\\text{RMS}}^{\\text{MAC}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{MAC}}\\right)^2}.\n$$\n9. Output $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ for each grid in the test suite, aggregated into a single line as specified.\n\nExpected behavior:\n- The numerical $A_p(\\Delta x)$ should scale closely with $\\Delta x^2/8$ (up to floating-point and discrete transform normalization).\n- $G_{\\text{RMS}}^{\\text{col-face}}$ should be numerically zero (to machine precision), demonstrating that the colocated naive gradient is blind to checkerboard pressure.\n- $G_{\\text{RMS}}^{\\text{MAC}}$ should scale linearly with $\\Delta x$ for this manufactured forcing because the face gradient magnitude behaves like $2 A_p(\\Delta x)/\\Delta x$.\n\nThis directly exhibits the mechanism by which the Marker-and-Cell (MAC) staggered grid suppresses checkerboard pressure modes: by placing velocities at faces, the discrete pressure gradient is evaluated as a difference of neighboring pressures, which does not vanish for alternating patterns, and thereby couples the spurious mode into momentum where it is damped. In contrast, a colocated naive central difference for the pressure gradient at centers annihilates the alternating component, allowing the spurious pressure mode to persist without influencing the velocity field.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_symbol(nx, ny, dx):\n    \"\"\"\n    Build the discrete Laplacian symbol lambda(m,n) for a periodic grid\n    using the five-point stencil central differences on a uniform grid.\n    \"\"\"\n    # Wavenumber indices m, n\n    m = np.arange(nx)\n    n = np.arange(ny)\n    # Cosine terms for each axis\n    cos_m = np.cos(2.0 * np.pi * m / nx)\n    cos_n = np.cos(2.0 * np.pi * n / ny)\n    # Broadcast to 2D grid of (m,n)\n    lam = (2.0 / dx**2) * (cos_m[:, None] - 1.0) + (2.0 / dx**2) * (cos_n[None, :] - 1.0)\n    return lam\n\ndef solve_poisson_checkerboard(nx, ny, L=1.0):\n    \"\"\"\n    Solve the discrete periodic Poisson equation for s_{i,j} = (-1)^{i+j}\n    using the discrete Laplacian symbol in Fourier space.\n\n    Returns:\n        p: computed pressure field (nx x ny)\n        Ap: numerical checkerboard amplitude via projection onto (-1)^{i+j}\n    \"\"\"\n    dx = L / nx\n    # Manufactured source s = (-1)^{i+j}\n    i = np.arange(nx)[:, None]\n    j = np.arange(ny)[None, :]\n    s = ((-1.0) ** (i + j)).astype(np.float64)\n\n    # FFT of source\n    s_hat = np.fft.fft2(s)\n\n    # Discrete Laplacian symbol\n    lam = discrete_laplacian_symbol(nx, ny, dx)\n\n    # Avoid division by zero: source has zero mean, so lam[0,0] won't be used\n    # Construct p_hat = s_hat / lam\n    # Use where to handle potential zeros robustly (though s_hat[0,0]==0)\n    p_hat = np.zeros_like(s_hat, dtype=np.complex128)\n    mask = lam != 0.0\n    p_hat[mask] = s_hat[mask] / lam[mask]\n\n    # Inverse FFT to get p\n    p = np.real(np.fft.ifft2(p_hat))\n\n    # Compute checkerboard amplitude Ap = mean(p * (-1)^{i+j})\n    pattern = ((-1.0) ** (i + j)).astype(np.float64)\n    Ap = np.sum(p * pattern) / (nx * ny)\n\n    return p, Ap, dx\n\ndef colocated_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute colocated center gradients via central differences and then\n    naive face gradients by averaging adjacent center gradients.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # Periodic shifts\n    p_ip = np.roll(p, -1, axis=0)\n    p_im = np.roll(p,  1, axis=0)\n    p_jp = np.roll(p, -1, axis=1)\n    p_jm = np.roll(p,  1, axis=1)\n\n    # Center gradients (central difference)\n    gx_c = (p_ip - p_im) / (2.0 * dx)\n    gy_c = (p_jp - p_jm) / (2.0 * dx)  # dx == dy\n\n    # Face gradients: average adjacent center gradients to faces\n    # x-faces at (i+1/2, j): average gx_c[i,j] and gx_c[i+1,j]\n    gx_face = 0.5 * (gx_c + np.roll(gx_c, -1, axis=0))\n    # y-faces at (i, j+1/2): average gy_c[i,j] and gy_c[i,j+1]\n    gy_face = 0.5 * (gy_c + np.roll(gy_c, -1, axis=1))\n\n    # RMS over all faces (both directions)\n    # Number of faces: 2 * nx * ny\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef mac_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute MAC face gradients directly from adjacent center pressures.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # x-face gradient: (p_{i+1,j} - p_{i,j}) / dx\n    p_ip = np.roll(p, -1, axis=0)\n    gx_face = (p_ip - p) / dx\n\n    # y-face gradient: (p_{i,j+1} - p_{i,j}) / dx\n    p_jp = np.roll(p, -1, axis=1)\n    gy_face = (p_jp - p) / dx\n\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef run_test_case(nx):\n    ny = nx\n    p, Ap, dx = solve_poisson_checkerboard(nx, ny, L=1.0)\n    rms_col = colocated_face_gradient_rms(p, dx)\n    rms_mac = mac_face_gradient_rms(p, dx)\n    return (Ap, rms_col, rms_mac)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 32, 64]\n\n    results = []\n    for nx in test_cases:\n        Ap, rms_col, rms_mac = run_test_case(nx)\n        # Format each tuple with reasonable precision\n        results.append(f\"({Ap:.10f},{rms_col:.10e},{rms_mac:.10e})\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The stability of the staggered grid is not an accident; it arises from a deep mathematical structure where the discrete operators mimic fundamental properties of continuous vector calculus. This exercise explores this \"mimetic\" quality by verifying two crucial vector identities, $\\nabla \\times (\\nabla \\phi) = \\mathbf{0}$ and $\\nabla \\cdot (\\nabla \\times \\mathbf{A}) = 0$, in their discrete forms on a MAC grid. You will also investigate how this exactness can be broken by naive boundary condition treatments, highlighting the importance of compatible closures. ",
            "id": "3447644",
            "problem": "Consider the Marker-and-Cell (MAC) arrangement for a uniform orthogonal grid in three spatial dimensions. Let the computational domain be $\\Omega = [0,L_x]\\times[0,L_y]\\times[0,L_z]$ with $L_x=L_y=L_z=1$. Discretize $\\Omega$ into $N_x \\times N_y \\times N_z$ cells with spacings $h_x = L_x/N_x$, $h_y = L_y/N_y$, $h_z = L_z/N_z$. Use the canonical discrete de Rham sequence placements:\n- Node-centered (corners) values for $0$-forms: a scalar field $\\phi$ defined at all nodes $(i,j,k)$ with $i\\in\\{0,\\dots,N_x\\}$, $j\\in\\{0,\\dots,N_y\\}$, $k\\in\\{0,\\dots,N_z\\}$.\n- Edge-centered values for $1$-forms: vectors aligned with edges. Let $\\mathbf{e}_x$ be defined on edges parallel to the $x$-direction with shape $(N_x, N_y+1, N_z+1)$, $\\mathbf{e}_y$ on edges parallel to the $y$-direction with shape $(N_x+1, N_y, N_z+1)$, and $\\mathbf{e}_z$ on edges parallel to the $z$-direction with shape $(N_x+1, N_y+1, N_z)$.\n- Face-centered values for $2$-forms: vectors normal to faces. Let $f_x$ be defined on faces normal to the $x$-axis with shape $(N_x+1, N_y, N_z)$, $f_y$ on faces normal to the $y$-axis with shape $(N_x, N_y+1, N_z)$, and $f_z$ on faces normal to the $z$-axis with shape $(N_x, N_y, N_z+1)$.\n- Cell-centered values for $3$-forms: scalars defined per cell with shape $(N_x, N_y, N_z)$.\n\nStarting from fundamental definitions of line, surface, and volume integrals and their discrete counterparts, define the following compatible discrete operators that map between these placements:\n1. Discrete gradient of the scalar $\\phi$ from nodes to edges, denoted $\\nabla \\phi$ on edges via forward differences along the edge directions,\n$$\ne_x[i,j,k] = \\frac{\\phi[i+1,j,k] - \\phi[i,j,k]}{h_x},\\quad\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y},\\quad\ne_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}.\n$$\n2. Discrete curl from edges to faces, denoted $\\nabla\\times\\mathbf{E}$ on faces (where $\\mathbf{E}$ collects $(e_x,e_y,e_z)$), defined as oriented circulation per unit area around each face,\n$$\n\\begin{aligned}\n(\\nabla\\times\\mathbf{E})_x[i,j,k] &= \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z},\\\\\n(\\nabla\\times\\mathbf{E})_y[i,j,k] &= \\frac{e_x[i,j,k+1]-e_x[i,j,k]}{h_z} - \\frac{e_z[i+1,j,k]-e_z[i,j,k]}{h_x},\\\\\n(\\nabla\\times\\mathbf{E})_z[i,j,k] &= \\frac{e_y[i+1,j,k]-e_y[i,j,k]}{h_x} - \\frac{e_x[i,j+1,k]-e_x[i,j,k]}{h_y}.\n\\end{aligned}\n$$\n3. Discrete divergence from faces to cells, denoted $\\nabla\\cdot\\mathbf{F}$ at cell centers (where $\\mathbf{F}$ collects face-normal components $(f_x,f_y,f_z)$), defined as oriented face flux per unit volume,\n$$\n(\\nabla\\cdot\\mathbf{F})[i,j,k] = \\frac{f_x[i+1,j,k]-f_x[i,j,k]}{h_x} + \\frac{f_y[i,j+1,k]-f_y[i,j,k]}{h_y} + \\frac{f_z[i,j,k+1]-f_z[i,j,k]}{h_z}.\n$$\n\nYour tasks:\n- Implement the discrete operators as specified above, exactly respecting the placements and index ranges.\n- Verify analytically that for the interior, on a uniform grid with these forward-difference and circulation definitions, the composite operator $\\nabla\\times(\\nabla \\phi)$ yields the zero vector on faces and the composite operator $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$ yields the zero scalar at cells, for arbitrary sufficiently smooth fields $\\phi$ at nodes and $\\mathbf{A}$ on edges. Explain why these discrete identities hold under periodic-like interior indexing (no ghost access).\n- Construct a numerical test harness to quantify the maximum absolute violation of:\n  - $\\nabla\\times(\\nabla \\phi)=\\mathbf{0}$ on faces,\n  - $\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$ at cells.\n  Use smooth deterministic fields:\n  - Node scalar $\\phi(i,j,k) = \\sin(2\\pi x_i)\\sin(3\\pi y_j)\\sin(5\\pi z_k)$ with $x_i = i h_x$, $y_j = j h_y$, $z_k = k h_z$.\n  - Edge vector potential components evaluated at edge midpoints:\n    $$\n    \\begin{aligned}\n    A_x(i+\\tfrac{1}{2},j,k) &= \\sin(2\\pi y_j)\\sin(3\\pi z_k),\\\\\n    A_y(i,j+\\tfrac{1}{2},k) &= \\sin(2\\pi z_k)\\sin(3\\pi x_i),\\\\\n    A_z(i,j,k+\\tfrac{1}{2}) &= \\sin(2\\pi x_i)\\sin(3\\pi y_j).\n    \\end{aligned}\n    $$\n- Implement three boundary-closure modes to stress the identities:\n  - \"periodic\": do nothing beyond the interior-indexed operators defined above.\n  - \"dirichlet\": after computing $\\nabla \\phi$ on edges, set all edge values that lie on a physical boundary (any index equal to $0$ or at its maximal value along any transverse index) to zero; and, independently, after computing $\\nabla\\times \\mathbf{A}$ on faces, set all boundary faces (any face index equal to $0$ or maximal along its axis) to zero. This models naive clamped closures that generally break the exactness of the complex.\n  - \"neumann\": after computing $\\nabla \\phi$, set to zero all edge components whose orientation is normal to a boundary and whose positional index along that orientation is at the boundary (e.g., for $e_x$, zero slices at $i=0$ and $i=N_x-1$; analogously for $e_y$ and $e_z$); and, independently, after computing $\\nabla\\times \\mathbf{A}$, zero the face-normal component at boundary-aligned indices for each orientation. This models naive flux closures that also typically break exactness.\n\nFor each test case, compute two floats:\n- $v_{\\mathrm{curlgrad}}$: the maximum over all faces of the absolute value of the components of $\\nabla\\times(\\nabla \\phi)$,\n- $v_{\\mathrm{divcurl}}$: the maximum over all cells of the absolute value of $\\nabla\\cdot(\\nabla\\times \\mathbf{A})$.\n\nDesign the following test suite (all with $L_x=L_y=L_z=1$):\n- Case $1$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"periodic\".\n- Case $2$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"dirichlet\".\n- Case $3$: $N_x=16$, $N_y=12$, $N_z=8$, boundary mode \"neumann\".\n- Case $4$: $N_x=2$, $N_y=2$, $N_z=2$, boundary mode \"periodic\" (boundary-dominated coarse grid).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[v_{\\mathrm{curlgrad}}^{(1)},v_{\\mathrm{divcurl}}^{(1)},v_{\\mathrm{curlgrad}}^{(2)},v_{\\mathrm{divcurl}}^{(2)},v_{\\mathrm{curlgrad}}^{(3)},v_{\\mathrm{divcurl}}^{(3)},v_{\\mathrm{curlgrad}}^{(4)},v_{\\mathrm{divcurl}}^{(4)}]$.\nAll quantities are dimensionless floats. Round nothing; print raw floating-point values as computed.",
            "solution": "The problem asks to verify fundamental vector identities for a set of discrete differential operators defined on a staggered grid, a structure known as a discrete de Rham complex. A key property of such complexes is that the composition of any two consecutive operators yields zero, which we verify analytically and test numerically.\n\n### Analytical Verification of Discrete Identities\n\n**1. Identity: $\\nabla\\times(\\nabla \\phi) = \\mathbf{0}$**\n\nThis identity is the discrete analogue of \"the curl of a gradient is zero\". We verify the $x$-component of this vector identity; the proofs for the $y$- and $z$-components are analogous by cyclic permutation of indices.\n\nThe $x$-component of the discrete curl of a vector field $\\mathbf{E}$ is defined as:\n$$\n(\\nabla\\times\\mathbf{E})_x[i,j,k] = \\frac{e_z[i,j+1,k]-e_z[i,j,k]}{h_y} - \\frac{e_y[i,j,k+1]-e_y[i,j,k]}{h_z}\n$$\nWe substitute $\\mathbf{E} = \\nabla\\phi$, where the components of the discrete gradient are:\n$$\ne_y[i,j,k] = \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\quad \\text{and} \\quad e_z[i,j,k] = \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z}\n$$\nSubstituting these into the curl formula:\n$$\n(\\nabla\\times(\\nabla \\phi))_x[i,j,k] = \\frac{1}{h_y} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j+1,k]}{h_z} - \\frac{\\phi[i,j,k+1] - \\phi[i,j,k]}{h_z} \\right) - \\frac{1}{h_z} \\left( \\frac{\\phi[i,j+1,k+1] - \\phi[i,j,k+1]}{h_y} - \\frac{\\phi[i,j+1,k] - \\phi[i,j,k]}{h_y} \\right)\n$$\nCombining terms with the common denominator $h_y h_z$:\n$$\n= \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j+1,k] - \\phi[i,j,k+1] + \\phi[i,j,k] \\right) - \\frac{1}{h_y h_z} \\left( \\phi[i,j+1,k+1] - \\phi[i,j,k+1] - \\phi[i,j+1,k] + \\phi[i,j,k] \\right)\n$$\nThe expressions inside the two parentheses are identical. Their difference is therefore identically zero for any scalar field $\\phi$, provided all necessary node values are accessible. This algebraic cancellation is the discrete equivalent of the equality of mixed partial derivatives ($\\partial^2\\phi/\\partial y\\partial z = \\partial^2\\phi/\\partial z\\partial y$). This holds exactly for interior faces where the stencil does not cross a boundary.\n\n**2. Identity: $\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = 0$**\n\nThis identity is the discrete analogue of \"the divergence of a curl is zero\". Let us define the forward finite difference operators:\n$$\n\\delta_x f[i] = \\frac{f[i+1]-f[i]}{h_x}, \\quad \\delta_y f[j] = \\frac{f[j+1]-f[j]}{h_y}, \\quad \\delta_z f[k] = \\frac{f[k+1]-f[k]}{h_z}\n$$\nThe discrete curl and divergence operators can be written compactly:\n$$\n(\\nabla\\times\\mathbf{A})_x = \\delta_y A_z - \\delta_z A_y, \\quad (\\nabla\\times\\mathbf{A})_y = \\delta_z A_x - \\delta_x A_z, \\quad (\\nabla\\times\\mathbf{A})_z = \\delta_x A_y - \\delta_y A_x\n$$\n$$\n\\nabla\\cdot\\mathbf{F} = \\delta_x F_x + \\delta_y F_y + \\delta_z F_z\n$$\nSubstituting the curl expression into the divergence:\n$$\n\\nabla\\cdot(\\nabla\\times \\mathbf{A}) = \\delta_x (\\delta_y A_z - \\delta_z A_y) + \\delta_y (\\delta_z A_x - \\delta_x A_z) + \\delta_z (\\delta_x A_y - \\delta_y A_x)\n$$\nRearranging the terms:\n$$\n= (\\delta_x \\delta_y A_z - \\delta_y \\delta_x A_z) + (\\delta_y \\delta_z A_x - \\delta_z \\delta_y A_x) + (\\delta_z \\delta_x A_y - \\delta_x \\delta_z A_y)\n$$\nOn a uniform orthogonal grid, the finite difference operators commute, i.e., $\\delta_i \\delta_j f = \\delta_j \\delta_i f$ for any field $f$ and directions $i,j \\in \\{x,y,z\\}$. This can be verified by direct expansion. Each term in parentheses is therefore identically zero. Consequently, the entire expression is zero. This cancellation holds exactly for interior cells where all necessary edge values are defined by the interior stencil.\n\n### Numerical Implementation Strategy\n\nThe numerical verification will be performed by implementing the discrete operators and applying them to smooth, deterministic test fields.\n\n**1. Operator Implementation:** The discrete gradient, curl, and divergence operators are implemented as functions that take NumPy arrays representing the fields on the grid and return the resulting fields on the appropriate staggered locations. These implementations use vectorized NumPy slicing to efficiently compute the finite differences, directly translating the given formulas.\n\n**2. Test Field Generation:** For the two tests, the respective fields ($\\phi$ and $\\mathbf{A}$) are generated on their specified grids by evaluating the given analytic functions at the correct physical coordinates.\n\n**3. Boundary Conditions:**\n- **\"periodic\" mode:** This mode applies the discrete operators as defined, without any modification. This corresponds to computing the identities on the interior stencils where they are expected to hold exactly (to within machine floating-point precision).\n- **\"dirichlet\" and \"neumann\" modes:** These modes probe the sensitivity of the identities to boundary closures that break the exact sequence property. After an intermediate field is computed (e.g., $\\mathbf{E} = \\nabla\\phi$), certain values at or near the physical boundary of the domain are explicitly set to zero as per the problem's specific instructions. Such modifications disrupt the delicate algebraic cancellations shown in the analytical verification, leading to non-zero results for the composite operators, particularly near the boundaries.\n\n**4. Error Quantification:** For each test case, after computing the final field ($\\nabla\\times(\\nabla\\phi)$ on faces or $\\nabla\\cdot(\\nabla\\times\\mathbf{A})$ on cells), the maximum absolute value over all components and all grid points of the resulting field is calculated. This provides a single scalar measure of the violation of the identity. For the \"periodic\" cases, these values are expected to be on the order of machine epsilon. For the other cases, they will be significantly larger, demonstrating the breakdown of the discrete identity due to the boundary treatment.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gradient(phi, hx, hy, hz):\n    \"\"\"Computes the discrete gradient of a node-centered scalar field phi.\"\"\"\n    # phi: (Nx+1, Ny+1, Nz+1)\n    # Output ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    ex = (phi[1:, :, :] - phi[:-1, :, :]) / hx\n    ey = (phi[:, 1:, :] - phi[:, :-1, :]) / hy\n    ez = (phi[:, :, 1:] - phi[:, :, :-1]) / hz\n    return ex, ey, ez\n\ndef curl(ex, ey, ez, hx, hy, hz):\n    \"\"\"Computes the discrete curl of an edge-centered vector field e.\"\"\"\n    # ex: (Nx, Ny+1, Nz+1), ey: (Nx+1, Ny, Nz+1), ez: (Nx+1, Ny+1, Nz)\n    # Output fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n\n    # (curl E)_x [i,j,k] needs e_z at j, j+1 and e_y at k, k+1\n    d_y_ez = (ez[:, 1:, :] - ez[:, :-1, :]) / hy  # Shape (Nx+1, Ny, Nz)\n    d_z_ey = (ey[:, :, 1:] - ey[:, :, :-1]) / hz  # Shape (Nx+1, Ny, Nz)\n    fx = d_y_ez - d_z_ey\n\n    # (curl E)_y [i,j,k] needs e_x at k, k+1 and e_z at i, i+1\n    d_z_ex = (ex[:, :, 1:] - ex[:, :, :-1]) / hz  # Shape (Nx, Ny+1, Nz)\n    d_x_ez = (ez[1:, :, :] - ez[:-1, :, :]) / hx  # Shape (Nx, Ny+1, Nz)\n    fy = d_z_ex - d_x_ez\n    \n    # (curl E)_z [i,j,k] needs e_y at i, i+1 and e_x at j, j+1\n    d_x_ey = (ey[1:, :, :] - ey[:-1, :, :]) / hx  # Shape (Nx, Ny, Nz+1)\n    d_y_ex = (ex[:, 1:, :] - ex[:, :-1, :]) / hy  # Shape (Nx, Ny, Nz+1)\n    fz = d_x_ey - d_y_ex\n    \n    return fx, fy, fz\n\ndef divergence(fx, fy, fz, hx, hy, hz):\n    \"\"\"Computes the discrete divergence of a face-centered vector field f.\"\"\"\n    # fx: (Nx+1, Ny, Nz), fy: (Nx, Ny+1, Nz), fz: (Nx, Ny, Nz+1)\n    # Output s: (Nx, Ny, Nz)\n    d_x_fx = (fx[1:, :, :] - fx[:-1, :, :]) / hx\n    d_y_fy = (fy[:, 1:, :] - fy[:, :-1, :]) / hy\n    d_z_fz = (fz[:, :, 1:] - fz[:, :, :-1]) / hz\n    \n    s = d_x_fx + d_y_fy + d_z_fz\n    return s\n\ndef compute_errors(Nx, Ny, Nz, mode):\n    \"\"\"\n    Computes curl-grad and div-curl errors for a given grid and boundary mode.\n    \"\"\"\n    Lx, Ly, Lz = 1.0, 1.0, 1.0\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n\n    # --- Task 1: Verify curl(grad(phi)) = 0 ---\n    \n    # 1.1: Construct node-centered scalar field phi\n    x_nodes = np.linspace(0, Lx, Nx + 1)\n    y_nodes = np.linspace(0, Ly, Ny + 1)\n    z_nodes = np.linspace(0, Lz, Nz + 1)\n    xx, yy, zz = np.meshgrid(x_nodes, y_nodes, z_nodes, indexing='ij')\n    phi = np.sin(2 * np.pi * xx) * np.sin(3 * np.pi * yy) * np.sin(5 * np.pi * zz)\n    \n    # 1.2: Compute gradient\n    ex, ey, ez = gradient(phi, hx, hy, hz)\n    \n    # 1.3: Apply boundary closure to the edge field\n    if mode == \"dirichlet\":\n        # Zero all edge values on a physical boundary\n        ex[:, 0, :] = 0; ex[:, -1, :] = 0  # j=0, j=Ny\n        ex[:, :, 0] = 0; ex[:, :, -1] = 0  # k=0, k=Nz\n        ey[0, :, :] = 0; ey[-1, :, :] = 0  # i=0, i=Nx\n        ey[:, :, 0] = 0; ey[:, :, -1] = 0  # k=0, k=Nz\n        ez[0, :, :] = 0; ez[-1, :, :] = 0  # i=0, i=Nx\n        ez[:, 0, :] = 0; ez[:, -1, :] = 0  # j=0, j=Ny\n    elif mode == \"neumann\":\n        # Zero edge components normal to a boundary at the boundary\n        # Note: edge arrays are smaller than phi array, so max index is e.g. Nx-1 for x-edges.\n        ex[0, :, :] = 0; ex[Nx-1, :, :] = 0\n        ey[:, 0, :] = 0; ey[:, Ny-1, :] = 0\n        ez[:, :, 0] = 0; ez[:, :, Nz-1] = 0\n\n    # 1.4: Compute curl of the (potentially modified) gradient\n    cg_fx, cg_fy, cg_fz = curl(ex, ey, ez, hx, hy, hz)\n\n    # 1.5: Compute max violation\n    v_curlgrad = np.max([\n        np.max(np.abs(cg_fx)), \n        np.max(np.abs(cg_fy)), \n        np.max(np.abs(cg_fz))\n    ])\n\n    # --- Task 2: Verify div(curl(A)) = 0 ---\n    \n    # 2.1: Construct edge-centered vector potential A\n    # A_x on x-edges: (Nx, Ny+1, Nz+1)\n    y_on_ax = np.linspace(0, Ly, Ny + 1)\n    z_on_ax = np.linspace(0, Lz, Nz + 1)\n    YY_ax, ZZ_ax = np.meshgrid(y_on_ax, z_on_ax, indexing='ij')\n    Ax_slice = np.sin(2 * np.pi * YY_ax) * np.sin(3 * np.pi * ZZ_ax)\n    Ax = np.tile(Ax_slice[np.newaxis, :, :], (Nx, 1, 1))\n\n    # A_y on y-edges: (Nx+1, Ny, Nz+1)\n    x_on_ay = np.linspace(0, Lx, Nx + 1)\n    z_on_ay = np.linspace(0, Lz, Nz + 1)\n    XX_ay, ZZ_ay = np.meshgrid(x_on_ay, z_on_ay, indexing='ij')\n    Ay_slice = np.sin(2 * np.pi * ZZ_ay) * np.sin(3 * np.pi * XX_ay)\n    Ay = np.tile(Ay_slice[:, np.newaxis, :], (1, Ny, 1))\n\n    # A_z on z-edges: (Nx+1, Ny+1, Nz)\n    x_on_az = np.linspace(0, Lx, Nx + 1)\n    y_on_az = np.linspace(0, Ly, Ny + 1)\n    XX_az, YY_az = np.meshgrid(x_on_az, y_on_az, indexing='ij')\n    Az_slice = np.sin(2 * np.pi * XX_az) * np.sin(3 * np.pi * YY_az)\n    Az = np.tile(Az_slice[:, :, np.newaxis], (1, 1, Nz))\n    \n    # 2.2: Compute curl of A\n    dc_fx, dc_fy, dc_fz = curl(Ax, Ay, Az, hx, hy, hz)\n    \n    # 2.3: Apply boundary closure to the face field\n    if mode == \"dirichlet\" or mode == \"neumann\":\n        # For faces, the problem description for dirichlet and neumann modes is identical\n        # Zero all boundary faces\n        dc_fx[0, :, :] = 0; dc_fx[-1, :, :] = 0  # i=0, i=Nx\n        dc_fy[:, 0, :] = 0; dc_fy[:, -1, :] = 0  # j=0, j=Ny\n        dc_fz[:, :, 0] = 0; dc_fz[:, :, -1] = 0  # k=0, k=Nz\n\n    # 2.4: Compute divergence of the (potentially modified) curl field\n    s = divergence(dc_fx, dc_fy, dc_fz, hx, hy, hz)\n\n    # 2.5: Compute max violation\n    v_divcurl = np.max(np.abs(s))\n\n    return v_curlgrad, v_divcurl\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (16, 12, 8, \"periodic\"),\n        (16, 12, 8, \"dirichlet\"),\n        (16, 12, 8, \"neumann\"),\n        (2, 2, 2, \"periodic\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_cg, v_dc = compute_errors(*case)\n        results.append(v_cg)\n        results.append(v_dc)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Moving from theoretical properties to practical application, this exercise focuses on implementing and verifying boundary conditions on a MAC grid within a dynamic simulation. You will simulate a vortex being advected out of a computational domain, a common scenario requiring robust outflow boundary conditions. By tracking the integral of the velocity divergence, you will assess the global mass conservation of the scheme, connecting the choice of boundary treatment directly to a fundamental physical principle. ",
            "id": "3365595",
            "problem": "Consider a two-dimensional incompressible flow discretized on a Marker-And-Cell (MAC) grid. The MAC grid stores the $x$-velocity component $u$ at vertical cell faces (indices $i+\\tfrac{1}{2}, j$), the $y$-velocity component $v$ at horizontal cell faces (indices $i, j+\\tfrac{1}{2}$), and the pressure $p$ at cell centers (indices $i, j$). Let the computational domain be $\\Omega = [0,L_x]\\times[0,L_y]$ with $N_x$ cells along $x$ and $N_y$ cells along $y$. The face-centered arrays therefore have shapes $u\\in\\mathbb{R}^{(N_x+1)\\times N_y}$ and $v\\in\\mathbb{R}^{N_x\\times (N_y+1)}$, while the cell-centered grid has shape $\\mathbb{R}^{N_x\\times N_y}$. The uniform grid spacings are $ \\Delta x = L_x/N_x $ and $ \\Delta y = L_y/N_y$.\n\nYou are asked to implement a first-order explicit convective outflow boundary condition for a vortex exiting the domain at the right boundary ($x=L_x$), and to verify global mass conservation numerically by tracking the domain integral of the discrete divergence. The flow field contains a uniform background advection and a localized vortex defined by a streamfunction.\n\nFoundational base:\n- The incompressible continuity equation for constant density is $ \\nabla\\cdot \\mathbf{u} = 0 $, where $\\mathbf{u}=(u,v)$.\n- The vortex is specified by a streamfunction $\\psi$ such that $ u = \\partial \\psi/\\partial y $ and $ v = -\\partial \\psi/\\partial x $, which ensures $ \\nabla\\cdot \\mathbf{u}=0 $ in the continuous setting.\n- We consider transport of the velocity components by a uniform background speed $U_0$ in the $+x$ direction. Each velocity component obeys a linear advection equation $ \\partial \\phi / \\partial t + U_0 \\, \\partial \\phi / \\partial x = 0 $, where $\\phi$ stands for either $u$ or $v$. Although this decoupled transport does not enforce incompressibility at the discrete level, the continuous divergence remains zero and the numerical integral of divergence can be used to measure mass conservation errors introduced by discretization and boundary treatment.\n\nInitial condition:\n- Let the streamfunction at time $t=0$ be\n$$\n\\psi(x,y,0) = A \\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right),\n$$\nwith amplitude $A>0$ and core radius $R>0$. The corresponding vortex velocities are\n$$\nu_{\\text{vtx}}(x,y,0) = \\frac{2A}{R^2}\\,(y-y_0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right),\n\\qquad\nv_{\\text{vtx}}(x,y,0) = -\\frac{2A}{R^2}\\,(x-x_0)\\,\\exp\\!\\left( -\\frac{(x-x_0)^2 + (y-y_0)^2}{R^2}\\right).\n$$\nSuperimpose a uniform background $x$-velocity $U_0$, so that the initial total velocities are $ u(x,y,0) = U_0 + u_{\\text{vtx}}(x,y,0) $ and $ v(x,y,0) = v_{\\text{vtx}}(x,y,0) $.\n\nTime advancement and boundary conditions:\n- Each velocity component is advanced in time by the explicit upwind discretization of the linear advection equation in $x$ with Courant number $\\text{CFL}= U_0 \\Delta t / \\Delta x$:\n  - Interior $x$-faces for $u$:\n    $$\n    u_{i,j}^{n+1} = u_{i,j}^{n} - \\text{CFL}\\,\\left(u_{i,j}^{n} - u_{i-1,j}^{n}\\right), \\quad i=1,\\dots,N_x,\n    $$\n    where $u_{i,j}$ denotes the value at face index $i$ (corresponding to physical location $x=i\\Delta x$, $y=(j+\\tfrac{1}{2})\\Delta y$).\n  - Interior $x$-indices for $v$:\n    $$\n    v_{i,j}^{n+1} = v_{i,j}^{n} - \\text{CFL}\\,\\left(v_{i,j}^{n} - v_{i-1,j}^{n}\\right), \\quad i=1,\\dots,N_x-1,\n    $$\n    where $v_{i,j}$ denotes the value at face index $i$ (location $x=(i+\\tfrac{1}{2})\\Delta x$, $y=j\\Delta y$).\n- West inflow boundary ($x=0$) is set by the analytically convected vortex and background flow. The vortex center advects as $x_c(t)=x_0+U_0 t$, $y_c(t)=y_0$. For $u$ at $x=0$, use the face location $x=0$, $y=(j+\\tfrac{1}{2})\\Delta y$; for $v$ at the first face index $i=0$, use $x=\\tfrac{1}{2}\\Delta x$, $y=j\\Delta y$. Inflow values are given by\n  $$\n  u_{\\text{in}}(y,t)=U_0 + \\frac{2A}{R^2}\\,(y-y_0)\\,\\exp\\!\\left( -\\frac{(0-x_c(t))^2 + (y-y_0)^2}{R^2}\\right),\n  $$\n  $$\n  v_{\\text{in}}(y,t)=-\\frac{2A}{R^2}\\,\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)\\,\\exp\\!\\left( -\\frac{\\left(\\tfrac{1}{2}\\Delta x - x_c(t)\\right)^2 + (y-y_0)^2}{R^2}\\right).\n  $$\n  The first-order boundary update for the west boundary indices is\n  $$\n  u_{0,j}^{n+1} = u_{0,j}^{n} - \\text{CFL}\\,\\left(u_{0,j}^{n} - u_{\\text{in}}(y_{j+\\frac{1}{2}},t^n)\\right),\n  \\qquad\n  v_{0,j}^{n+1} = v_{0,j}^{n} - \\text{CFL}\\,\\left(v_{0,j}^{n} - v_{\\text{in}}(y_{j},t^n)\\right).\n  $$\n- East convective outflow boundary ($x=L_x$) applies the one-sided convective update consistent with the interior upwind scheme:\n  $$\n  u_{N_x,j}^{n+1} = u_{N_x,j}^{n} - \\text{CFL}\\,\\left(u_{N_x,j}^{n} - u_{N_x-1,j}^{n}\\right),\n  \\qquad\n  v_{N_x-1,j}^{n+1} = v_{N_x-1,j}^{n} - \\text{CFL}\\,\\left(v_{N_x-1,j}^{n} - v_{N_x-2,j}^{n}\\right).\n  $$\n- Top and bottom boundaries are periodic in $y$ for $v$:\n  $$\n  v_{i,N_y}^{n} \\equiv v_{i,0}^{n} \\quad \\text{for all } i \\text{ and } n.\n  $$\n  The $u$ array is already defined at $y=(j+\\tfrac{1}{2})\\Delta y$, $j=0,\\dots,N_y-1$, so no explicit $y$ boundary update is required for $u$.\n\nDiscrete divergence and its integral:\n- Define the cell-centered discrete divergence at time $t^n$ as\n  $$\n  (\\nabla\\cdot \\mathbf{u})_{i,j}^{n} = \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y},\n  \\quad i=0,\\dots,N_x-1,\\quad j=0,\\dots,N_y-1.\n  $$\n- The domain integral is\n  $$\n  I^n = \\int_{\\Omega} \\nabla\\cdot\\mathbf{u}\\,d\\Omega \\approx \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y} \\right)\\,\\Delta x\\,\\Delta y.\n  $$\n- In the continuous incompressible case, the integral is identically zero for all $t$. Numerically, $I^n$ diagnoses mass conservation error attributable to discretization and boundary treatment. You must track $I^n$ for all $n$ until the vortex exits the domain and report the maximum absolute magnitude $\\max_n |I^n|$.\n\nUnits:\n- Use $L_x$ and $L_y$ in meters ($\\mathrm{m}$), $U_0$ in meters per second ($\\mathrm{m/s}$), $A$ in square meters per second ($\\mathrm{m}^2/\\mathrm{s}$), $R$, $x_0$, $y_0$ in meters ($\\mathrm{m}$), time in seconds ($\\mathrm{s}$). Report the final outputs in units of $\\mathrm{m}^2/\\mathrm{s}$.\n\nTest suite:\n- For each test case, compute with time step $\\Delta t = \\text{CFL}\\cdot \\Delta x / U_0$ and advance until final time $T$ sufficient for the vortex center to pass beyond the right boundary by an extra margin $m R$ with $m=1.5$:\n  $$\n  T = \\frac{L_x - x_0 + m R}{U_0}.\n  $$\n- Test cases:\n  1. $N_x=64$, $N_y=64$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.05$, $R=0.10$, $x_0=0.20$, $y_0=0.50$, $\\text{CFL}=0.60$.\n  2. $N_x=32$, $N_y=32$, $L_x=1.0$, $L_y=1.0$, $U_0=1.0$, $A=0.08$, $R=0.08$, $x_0=0.20$, $y_0=0.30$, $\\text{CFL}=0.95$.\n  3. $N_x=48$, $N_y=48$, $L_x=1.0$, $L_y=1.0$, $U_0=0.50$, $A=0.04$, $R=0.06$, $x_0=0.40$, $y_0=0.90$, $\\text{CFL}=0.70$.\n\nYour task:\n- Implement the explicit upwind advection updates for $u$ and $v$ on the MAC grid with the specified inflow and convective outflow boundary conditions and $y$-periodicity for $v$.\n- Initialize the fields using the streamfunction vortex and background as specified.\n- At each time step, compute $I^n$ and track $\\max_n |I^n|$.\n- For each test case, return the single float $\\max_n |I^n|$ in $\\mathrm{m}^2/\\mathrm{s}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$, where each $r_k$ is a float in $\\mathrm{m}^2/\\mathrm{s}$.",
            "solution": "The problem asks us to simulate the advection of a vortex out of a domain and track the global mass conservation, which is measured by the domain integral of the discrete divergence, $I^n$.\n\n**1. Numerical Discretization**\n\nThe velocity components $u$ and $v$ are transported by a uniform velocity $U_0$ in the $x$-direction. The governing equation for each component, $\\partial \\phi / \\partial t + U_0 \\partial \\phi / \\partial x = 0$, is discretized using the first-order explicit upwind scheme. Given $U_0 > 0$, the update rule for an interior point $\\phi_i$ is:\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{U_0 \\Delta t}{\\Delta x}(\\phi_i^n - \\phi_{i-1}^n) = \\phi_i^{n} - \\text{CFL}(\\phi_i^n - \\phi_{i-1}^n).\n$$\nThis scheme is applied to all interior velocity components on the MAC grid. The arrays are updated in a vectorized manner for efficiency.\n\n**2. Boundary Conditions**\n\n- **Inflow (West):** The west boundary at $x=0$ has prescribed inflow values. The problem specifies a relaxation-type boundary condition update, which mixes the previous boundary value with the analytical inflow value at the current time. This is implemented directly as given.\n- **Outflow (East):** The east boundary at $x=L_x$ must allow the vortex to exit smoothly. A simple and robust choice is a convective outflow condition, which assumes the flow properties are advected out of the domain. For the first-order upwind scheme, this is naturally implemented by applying the same upwind stencil at the boundary nodes as in the interior. For example, for $u$ at the last face index $i=N_x$:\n$$\nu_{N_x,j}^{n+1} = u_{N_x,j}^{n} - \\text{CFL}\\,(u_{N_x,j}^{n} - u_{N_x-1,j}^{n}),\n$$\nwhich is consistent with the problem statement.\n- **Periodic (Top/Bottom):** The $v$-velocity array has nodes on the $y=0$ and $y=L_y$ boundaries. The periodic condition $v_{i,N_y} = v_{i,0}$ is enforced after each time step.\n\n**3. Global Mass Conservation Metric**\n\nThe core of the analysis is to track the integral of the discrete divergence, $I^n$. A highly efficient method to compute this integral exists due to the properties of the MAC grid. The integral is defined as the sum over all cells:\n$$\nI^n = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} (\\nabla\\cdot \\mathbf{u})_{i,j}^{n}\\,\\Delta x\\,\\Delta y = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} \\left( \\frac{u_{i+1,j}^{n} - u_{i,j}^{n}}{\\Delta x} + \\frac{v_{i,j+1}^{n} - v_{i,j}^{n}}{\\Delta y} \\right)\\,\\Delta x\\,\\Delta y.\n$$\nWe can split the summation and rearrange:\n$$\nI^n = \\Delta y \\sum_{j=0}^{N_y-1} \\left[ \\sum_{i=0}^{N_x-1} (u_{i+1,j}^{n} - u_{i,j}^{n}) \\right] + \\Delta x \\sum_{i=0}^{N_x-1} \\left[ \\sum_{j=0}^{N_y-1} (v_{i,j+1}^{n} - v_{i,j}^{n}) \\right].\n$$\nBoth inner sums are telescoping sums.\n- The sum over $i$ becomes: $\\sum_{i=0}^{N_x-1} (u_{i+1,j}^{n} - u_{i,j}^{n}) = u_{N_x,j}^n - u_{0,j}^n$.\n- The sum over $j$ becomes: $\\sum_{j=0}^{N_y-1} (v_{i,j+1}^{n} - v_{i,j}^{n}) = v_{i,N_y}^n - v_{i,0}^n$.\nDue to the periodic boundary condition for $v$ ($v_{i,N_y}^n = v_{i,0}^n$), the second term is identically zero. This is a direct consequence of the compatible discretization on the MAC grid.\nTherefore, the integral simplifies to the net mass flux across the domain's east and west boundaries:\n$$\nI^n = \\Delta y \\sum_{j=0}^{N_y-1} (u_{N_x,j}^n - u_{0,j}^n).\n$$\nThis is the quantity computed at each time step. The algorithm tracks the maximum absolute value of $I^n$ over the entire simulation. A non-zero value indicates the degree to which the numerical scheme (discretization and boundary conditions) fails to preserve the global mass conservation of the initial divergence-free field.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, Lx, Ly, U0, A, R, x0, y0, CFL)\n        (64, 64, 1.0, 1.0, 1.0, 0.05, 0.10, 0.20, 0.50, 0.60),\n        (32, 32, 1.0, 1.0, 1.0, 0.08, 0.08, 0.20, 0.30, 0.95),\n        (48, 48, 1.0, 1.0, 0.50, 0.04, 0.06, 0.40, 0.90, 0.70),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(Nx, Ny, Lx, Ly, U0, A, R, x0, y0, CFL):\n    \"\"\"\n    Executes a single simulation case for the vortex advection problem.\n    \"\"\"\n    # Grid and time parameters\n    dx = Lx / Nx\n    dy = Ly / Ny\n    dt = CFL * dx / U0\n    m = 1.5\n    T_final = (Lx - x0 + m * R) / U0\n    num_steps = int(np.ceil(T_final / dt))\n\n    # --- Grid coordinates ---\n    # U-velocity component grid\n    # u is at (i*dx, (j+0.5)*dy) for i in [0,Nx], j in [0,Ny-1]\n    # Array shape: (Nx+1, Ny) -> u[i, j]\n    x_u_pts = np.arange(Nx + 1) * dx\n    y_u_pts = (np.arange(Ny) + 0.5) * dy\n    X_u, Y_u = np.meshgrid(x_u_pts, y_u_pts, indexing='ij')\n\n    # V-velocity component grid\n    # v is at ((i+0.5)*dx, j*dy) for i in [0,Nx-1], j in [0,Ny]\n    # Array shape: (Nx, Ny+1) -> v[i, j]\n    x_v_pts = (np.arange(Nx) + 0.5) * dx\n    y_v_pts = np.arange(Ny + 1) * dy\n    X_v, Y_v = np.meshgrid(x_v_pts, y_v_pts, indexing='ij')\n\n    # --- Initial Conditions ---\n    # u(x,y,0) = U0 + u_vtx(x,y,0)\n    u_vortex_term = (2 * A / R**2) * (Y_u - y0) * np.exp(-((X_u - x0)**2 + (Y_u - y0)**2) / R**2)\n    u = U0 + u_vortex_term\n\n    # v(x,y,0) = v_vtx(x,y,0)\n    v_vortex_term = -(2 * A / R**2) * (X_v - x0) * np.exp(-((X_v - x0)**2 + (Y_v - y0)**2) / R**2)\n    v = v_vortex_term\n    \n    # Enforce periodic boundary condition for v at t=0\n    v[:, Ny] = v[:, 0]\n\n    max_abs_I = 0.0\n\n    # --- Time-stepping loop ---\n    for n in range(num_steps):\n        # 1. Calculate integral of divergence at time t^n\n        # I^n = Integral(div(u)) dOmega = Sum_j (u_{Nx,j} - u_{0,j}) dy\n        # This uses the discrete divergence theorem and y-periodicity of v.\n        I_n = dy * np.sum(u[Nx, :] - u[0, :])\n        max_abs_I = max(max_abs_I, abs(I_n))\n\n        # 2. Store fields at time t^n for update calculation\n        u_n = u.copy()\n        v_n = v.copy()\n        \n        # 3. Time at current step for analytic BC evaluation\n        current_time = n * dt\n        \n        # 4. Update interior and east boundary (i > 0)\n        # u update for i=1..Nx. Includes east outflow BC at i=Nx.\n        u[1:Nx+1, :] = u_n[1:Nx+1, :] - CFL * (u_n[1:Nx+1, :] - u_n[0:Nx, :])\n        # v update for i=1..Nx-1. Includes east outflow BC at i=Nx-1.\n        v[1:Nx, :]   = v_n[1:Nx, :]   - CFL * (v_n[1:Nx, :]   - v_n[0:Nx-1, :])\n        \n        # 5. Update west inflow boundary (i = 0)\n        x_c_n = x0 + U0 * current_time\n\n        # Calculate u_in at x=0\n        # y_u_pts are the y-coordinates for the u-grid\n        u_in_val = U0 + (2 * A / R**2) * (y_u_pts - y0) * np.exp(-((0.0 - x_c_n)**2 + (y_u_pts - y0)**2) / R**2)\n        u[0, :] = u_n[0, :] - CFL * (u_n[0, :] - u_in_val)\n        \n        # Calculate v_in for v[0,:] at x = 0.5*dx\n        # y_v_pts are the y-coordinates for the v-grid\n        v_in_x_coord = 0.5 * dx\n        v_in_val = -(2 * A / R**2) * (v_in_x_coord - x_c_n) * np.exp(-((v_in_x_coord - x_c_n)**2 + (y_v_pts - y0)**2) / R**2)\n        v[0, :] = v_n[0, :] - CFL * (v_n[0, :] - v_in_val)\n\n        # 6. Enforce y-periodicity for v\n        v[:, Ny] = v[:, 0]\n        \n    return max_abs_I\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}