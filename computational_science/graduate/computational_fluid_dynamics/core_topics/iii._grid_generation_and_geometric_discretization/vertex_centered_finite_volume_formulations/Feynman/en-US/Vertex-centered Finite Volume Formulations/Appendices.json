{
    "hands_on_practices": [
        {
            "introduction": "The heart of a vertex-centered finite volume method is the dual mesh, which defines the control volumes around each vertex of the primary mesh. This exercise focuses on the geometric construction of a circumcentric dual, where the faces separating control volumes are perpendicular to the edges of the primary mesh. By calculating the length and orientation of a dual face for a simple pair of triangles, you will gain a concrete understanding of how these geometric properties directly influence the formulation of numerical fluxes .",
            "id": "3387918",
            "problem": "Consider two adjacent triangles in the plane that share the edge $e$ with endpoints $\\boldsymbol{A}=(0,0)$ and $\\boldsymbol{B}=(3,1)$. The first triangle is $T_1=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_1)$ with $\\boldsymbol{V}_1=(1,-2)$ and the second triangle is $T_2=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_2)$ with $\\boldsymbol{V}_2=(2,3)$. In a vertex-centered finite volume method built from the circumcentric dual (Voronoi dual) of a simplicial mesh, the control-volume interface associated with the primal edge $e$ is the straight segment connecting the circumcenters of $T_1$ and $T_2$, and this interface is orthogonal to $e$. In two spatial dimensions, the flux of any vector field across this interface is evaluated by projecting the flux onto a chosen unit normal to $e$ and multiplying by the interface measure.\n\nUsing only fundamental geometric constructions and definitions consistent with conservation laws and flux projection, do the following:\n- Compute the length of the dual segment (the distance between the circumcenters of $T_1$ and $T_2$), which is orthogonal to $e$.\n- Define the unit normal to $e$ by first forming the unit tangent $\\hat{\\boldsymbol{t}}$ in the direction from $\\boldsymbol{A}$ to $\\boldsymbol{B}$ and then rotating it by $+90^\\circ$ in the plane to obtain $\\boldsymbol{n}_e$. With this convention, compute the scalar projected area used to evaluate the flux across the vertex-centered interface, defined as the scalar projection of the dual segment onto $\\boldsymbol{n}_e$.\n\nProvide both quantities as exact simplified expressions. Express lengths in meters. Report your final answer as a row matrix containing first the dual-segment length and then the scalar projected area, in that order. No rounding is required, and no units should be included in the final boxed answer.",
            "solution": "The problem asks for two quantities related to the vertex-centered finite volume dual mesh construction for two adjacent triangles, $T_1$ and $T_2$. The first quantity is the length of the dual edge connecting the circumcenters of $T_1$ and $T_2$. The second is the scalar projection of this dual edge vector onto a specific normal vector associated with the shared primal edge $e$.\n\nThe vertices of the triangles are given as $\\boldsymbol{A}=(0,0)$, $\\boldsymbol{B}=(3,1)$, $\\boldsymbol{V}_1=(1,-2)$, and $\\boldsymbol{V}_2=(2,3)$. The triangles are $T_1=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_1)$ and $T_2=\\triangle(\\boldsymbol{A},\\boldsymbol{B},\\boldsymbol{V}_2)$.\n\nFirst, we compute the circumcenters of $T_1$ and $T_2$. The circumcenter of a triangle is the intersection of the perpendicular bisectors of its sides.\n\nLet $\\boldsymbol{C}_1=(x,y)$ be the circumcenter of $T_1$. $\\boldsymbol{C}_1$ must be equidistant from $\\boldsymbol{A}$, $\\boldsymbol{B}$, and $\\boldsymbol{V}_1$.\nThe equation of the perpendicular bisector of the segment $\\boldsymbol{AB}$ is derived from the condition that any point on it is equidistant from $\\boldsymbol{A}$ and $\\boldsymbol{B}$.\n$|\\boldsymbol{C}_1 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_1 - \\boldsymbol{B}|^2$\n$x^2 + y^2 = (x-3)^2 + (y-1)^2$\n$x^2 + y^2 = x^2 - 6x + 9 + y^2 - 2y + 1$\n$0 = -6x - 2y + 10$, which simplifies to $3x + y = 5$.\n\nThe equation of the perpendicular bisector of the segment $\\boldsymbol{AV}_1$ is derived similarly.\n$|\\boldsymbol{C}_1 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_1 - \\boldsymbol{V}_1|^2$\n$x^2 + y^2 = (x-1)^2 + (y-(-2))^2$\n$x^2 + y^2 = x^2 - 2x + 1 + y^2 + 4y + 4$\n$0 = -2x + 4y + 5$, which can be written as $2x - 4y = 5$.\n\nNow we solve the system of linear equations for $(x,y)$:\n1. $y = 5 - 3x$\n2. $2x - 4y = 5$\n\nSubstituting the first equation into the second:\n$2x - 4(5 - 3x) = 5$\n$2x - 20 + 12x = 5$\n$14x = 25 \\implies x = \\frac{25}{14}$\nThen, $y = 5 - 3\\left(\\frac{25}{14}\\right) = \\frac{70}{14} - \\frac{75}{14} = -\\frac{5}{14}$.\nSo, the circumcenter of $T_1$ is $\\boldsymbol{C}_1 = \\left(\\frac{25}{14}, -\\frac{5}{14}\\right)$.\n\nNext, let $\\boldsymbol{C}_2=(x,y)$ be the circumcenter of $T_2$. It lies on the perpendicular bisector of $\\boldsymbol{AB}$, which is $3x+y=5$. We also need the perpendicular bisector of $\\boldsymbol{AV}_2$.\n$|\\boldsymbol{C}_2 - \\boldsymbol{A}|^2 = |\\boldsymbol{C}_2 - \\boldsymbol{V}_2|^2$\n$x^2 + y^2 = (x-2)^2 + (y-3)^2$\n$x^2 + y^2 = x^2 - 4x + 4 + y^2 - 6y + 9$\n$0 = -4x - 6y + 13$, which gives $4x + 6y = 13$.\n\nNow we solve the system for $\\boldsymbol{C}_2$:\n1. $y = 5 - 3x$\n2. $4x + 6y = 13$\n\nSubstituting the first equation into the second:\n$4x + 6(5 - 3x) = 13$\n$4x + 30 - 18x = 13$\n$-14x = -17 \\implies x = \\frac{17}{14}$\nThen, $y = 5 - 3\\left(\\frac{17}{14}\\right) = \\frac{70}{14} - \\frac{51}{14} = \\frac{19}{14}$.\nSo, the circumcenter of $T_2$ is $\\boldsymbol{C}_2 = \\left(\\frac{17}{14}, \\frac{19}{14}\\right)$.\n\nThe first quantity to compute is the length of the dual segment connecting $\\boldsymbol{C}_1$ and $\\boldsymbol{C}_2$. First, we find the vector for this segment:\n$\\vec{\\boldsymbol{S}}_{dual} = \\boldsymbol{C}_2 - \\boldsymbol{C}_1 = \\left(\\frac{17}{14} - \\frac{25}{14}, \\frac{19}{14} - \\left(-\\frac{5}{14}\\right)\\right) = \\left(-\\frac{8}{14}, \\frac{24}{14}\\right) = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right)$.\n\nThe length of this dual segment is its magnitude:\n$L_{dual} = |\\vec{\\boldsymbol{S}}_{dual}| = \\sqrt{\\left(-\\frac{4}{7}\\right)^2 + \\left(\\frac{12}{7}\\right)^2} = \\sqrt{\\frac{16}{49} + \\frac{144}{49}} = \\sqrt{\\frac{160}{49}} = \\frac{\\sqrt{16 \\times 10}}{\\sqrt{49}} = \\frac{4\\sqrt{10}}{7}$.\nThe problem states lengths are in meters, so the length is $\\frac{4\\sqrt{10}}{7}$ meters.\n\nThe second quantity is the scalar projected area, defined as the scalar projection of the dual segment vector $\\vec{\\boldsymbol{S}}_{dual}$ onto the unit normal $\\boldsymbol{n}_e$. We must first construct $\\boldsymbol{n}_e$.\nThe primal edge vector is $\\vec{\\boldsymbol{e}} = \\boldsymbol{B} - \\boldsymbol{A} = (3,1) - (0,0) = (3,1)$.\nThe unit tangent vector $\\hat{\\boldsymbol{t}}$ in the direction from $\\boldsymbol{A}$ to $\\boldsymbol{B}$ is:\n$\\hat{\\boldsymbol{t}} = \\frac{\\vec{\\boldsymbol{e}}}{|\\vec{\\boldsymbol{e}}|} = \\frac{(3,1)}{\\sqrt{3^2 + 1^2}} = \\frac{(3,1)}{\\sqrt{10}} = \\left(\\frac{3}{\\sqrt{10}}, \\frac{1}{\\sqrt{10}}\\right)$.\n\nThe unit normal $\\boldsymbol{n}_e$ is obtained by rotating $\\hat{\\boldsymbol{t}}$ by $+90^\\circ$. A point $(x,y)$ rotated by $+90^\\circ$ becomes $(-y,x)$.\n$\\boldsymbol{n}_e = \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right)$.\n\nThe scalar projected area is the dot product of $\\vec{\\boldsymbol{S}}_{dual}$ and $\\boldsymbol{n}_e$:\n$A_{proj} = \\vec{\\boldsymbol{S}}_{dual} \\cdot \\boldsymbol{n}_e = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right) \\cdot \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right)$\n$A_{proj} = \\left(-\\frac{4}{7}\\right)\\left(-\\frac{1}{\\sqrt{10}}\\right) + \\left(\\frac{12}{7}\\right)\\left(\\frac{3}{\\sqrt{10}}\\right) = \\frac{4}{7\\sqrt{10}} + \\frac{36}{7\\sqrt{10}} = \\frac{40}{7\\sqrt{10}}$.\n\nTo simplify, we rationalize the denominator:\n$A_{proj} = \\frac{40\\sqrt{10}}{7(\\sqrt{10})^2} = \\frac{40\\sqrt{10}}{70} = \\frac{4\\sqrt{10}}{7}$.\nThe scalar projected area is $\\frac{4\\sqrt{10}}{7}$ square meters.\n\nThis result is identical to the dual segment length. This is expected because the dual segment connecting circumcenters is orthogonal to the shared primal edge $e$, and the vector $\\boldsymbol{n}_e$ is also constructed to be orthogonal to $e$. In a 2D plane, two vectors orthogonal to the same line must be parallel (or anti-parallel). In this case, $\\vec{\\boldsymbol{S}}_{dual} = \\left(-\\frac{4}{7}, \\frac{12}{7}\\right) = \\frac{4\\sqrt{10}}{7} \\left(-\\frac{1}{\\sqrt{10}}, \\frac{3}{\\sqrt{10}}\\right) = \\frac{4\\sqrt{10}}{7} \\boldsymbol{n}_e$. Since $\\vec{\\boldsymbol{S}}_{dual}$ is parallel to the unit vector $\\boldsymbol{n}_e$, its scalar projection onto $\\boldsymbol{n}_e$ is simply its own length.\n\nThe two requested quantities are the dual-segment length and the scalar projected area.\nLength = $\\frac{4\\sqrt{10}}{7}$.\nScalar projected area = $\\frac{4\\sqrt{10}}{7}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{4\\sqrt{10}}{7}  \\frac{4\\sqrt{10}}{7} \\end{pmatrix}}$$"
        },
        {
            "introduction": "After understanding the static geometry, the next step is to apply it to discretize a partial differential equation. This practice involves implementing a simple yet fundamental numerical scheme—first-order upwinding—for the linear advection equation, $\\partial_t u + \\nabla \\cdot (\\boldsymbol{a}u) = 0$, on a vertex-centered grid. You will write code to perform a time step, reinforcing the connection between the discrete conservation law, the numerical flux, and the crucial concept of stability governed by the Courant-Friedrichs-Lewy (CFL) condition .",
            "id": "3387973",
            "problem": "Consider the linear advection equation in conservation form for a scalar field $u$,\n$$\n\\partial_t u + \\nabla \\cdot (\\boldsymbol{a}\\,u) = 0,\n$$\nwith constant advection velocity $\\boldsymbol{a} = (1,0)$ on a two-dimensional periodic domain $\\Omega = [0,L_x)\\times[0,L_y)$. Use a vertex-centered Finite Volume Method (FVM) on a uniform Cartesian mesh with $N_x$ vertices in the $x$-direction and $N_y$ vertices in the $y$-direction. The vertex-centered dual control volume around each interior vertex is the rectangle whose corners are the centers of the four surrounding primal cells. Denote the uniform spacings by $h_x = L_x/N_x$ and $h_y = L_y/N_y$, so that the dual volume area is $V_P = h_x h_y$ and the dual face lengths are $h_y$ for east and west faces, and $h_x$ for north and south faces. Because $\\boldsymbol{a}=(1,0)$, only the east and west faces contribute to fluxes.\n\nStarting from the integral conservation law over a dual control volume and using explicit forward Euler time integration with first-order upwind numerical fluxes, implement one explicit time step for $u$ from time level $t^n$ to $t^{n+1} = t^n + \\Delta t$ on the vertex-centered dual mesh. Use periodic boundary conditions in both directions. The initial profile is\n$$\nu_0(x,y) = \\exp\\!\\Bigg(-\\frac{(x - x_c)^2 + (y - y_c)^2}{\\sigma^2}\\Bigg) + \\beta\\,\\sin(2\\pi x)\\,\\cos(2\\pi y),\n$$\nwith parameters $x_c = 0.25$, $y_c = 0.5$, $\\sigma = 0.15$, and $\\beta = 0.25$. Angles in trigonometric functions must be interpreted in radians. All quantities are dimensionless.\n\nYour program must:\n- Construct the uniform vertex grid with coordinates $x_i = i\\,h_x$ for $i = 0,1,\\dots,N_x-1$ and $y_j = j\\,h_y$ for $j = 0,1,\\dots,N_y-1$.\n- Initialize $u^n_{i,j} = u_0(x_i,y_j)$.\n- Perform one explicit time step using the vertex-centered FVM and first-order upwind fluxes with $\\boldsymbol{a}=(1,0)$:\n  - For each vertex $(i,j)$, define its west neighbor index $i_W = (i-1) \\bmod N_x$ and compute\n    $$\n    u^{n+1}_{i,j} = u^n_{i,j} - \\frac{\\Delta t}{h_x}\\big(u^n_{i,j} - u^n_{i_W,j}\\big).\n    $$\n- Determine the Courant–Friedrichs–Lewy (CFL) stability condition for this scheme and velocity. Derive the requirement on $\\Delta t$ in terms of $h_x$ that ensures stability and return whether the given $\\Delta t$ satisfies it.\n\nFor each test case, after advancing one time step, report the updated value at the vertex closest to the evaluation point $(x^\\star,y^\\star)$ and a boolean indicating whether the CFL constraint is satisfied. Given $(x^\\star,y^\\star)$, choose the closest vertex indices by rounding: $i^\\star = \\operatorname{round}(x^\\star/h_x)$ and $j^\\star = \\operatorname{round}(y^\\star/h_y)$, both taken modulo $N_x$ and $N_y$ respectively, and then use $(x_{i^\\star}, y_{j^\\star})$.\n\nTest suite:\n- Case $1$: $N_x=20$, $N_y=20$, $L_x=1$, $L_y=1$, $\\Delta t=0.02$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $2$: $N_x=50$, $N_y=10$, $L_x=1$, $L_y=1$, $\\Delta t=0.02$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $3$: $N_x=30$, $N_y=30$, $L_x=1$, $L_y=1$, $\\Delta t=0.06$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n- Case $4$: $N_x=16$, $N_y=16$, $L_x=1$, $L_y=1$, $\\Delta t=0.0$, $(x^\\star,y^\\star)=(0.6,0.3)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a two-element list $[u^{n+1}(x_{i^\\star},y_{j^\\star}), \\text{cfl\\_ok}]$, where $u^{n+1}(x_{i^\\star},y_{j^\\star})$ is a floating-point number rounded to $8$ decimal places and $\\text{cfl\\_ok}$ is a boolean. For example, the overall output format should look like\n$$\n\\big[ [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}], [\\text{float},\\text{boolean}] \\big].\n$$",
            "solution": "The problem statement has been validated and is deemed sound, well-posed, and objective. It presents a clear task in computational fluid dynamics based on established scientific and mathematical principles.\n\nThe-problem requires the implementation of a single time step for the linear advection equation using a vertex-centered finite volume method (FVM). The derivation of the numerical scheme, the stability analysis, and the implementation details are outlined below.\n\nThe governing equation is the linear advection equation in two dimensions, given in conservative form as:\n$$\n\\partial_t u + \\nabla \\cdot (\\boldsymbol{a}\\,u) = 0\n$$\nwhere $u(x,y,t)$ is a scalar field and $\\boldsymbol{a}$ is the constant advection velocity. For this problem, the velocity is specified as $\\boldsymbol{a} = (1,0)$, which simplifies the equation to:\n$$\n\\partial_t u + \\partial_x u = 0\n$$\nThis equation describes the transport of the quantity $u$ in the positive $x$-direction with unit speed.\n\nThe FVM relies on the integral form of the conservation law. We integrate the equation over a control volume $V_P$ fixed in space:\n$$\n\\int_{V_P} \\partial_t u \\, dV + \\int_{V_P} \\nabla \\cdot (\\boldsymbol{a}\\,u) \\, dV = 0\n$$\nApplying the divergence theorem (also known as Gauss's theorem) to the second term transforms the volume integral of the divergence into a surface integral of the flux over the boundary $\\partial V_P$:\n$$\n\\frac{d}{dt} \\int_{V_P} u \\, dV + \\oint_{\\partial V_P} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = 0\n$$\nwhere $\\boldsymbol{n}$ is the outward-pointing unit normal vector on the surface element $dS$.\n\nIn a vertex-centered FVM, the domain is first discretized into a grid of vertices, and a dual mesh of control volumes is constructed around each vertex. For the specified uniform Cartesian mesh with vertices $(x_i, y_j)$, where $x_i = i h_x$ and $y_j = j h_y$, the dual control volume $V_{i,j}$ around vertex $(i,j)$ is a rectangle. Its corners are at the centers of the four surrounding primal cells, meaning it extends from $x_i - h_x/2$ to $x_i + h_x/2$ in the $x$-direction and from $y_j - h_y/2$ to $y_j + h_y/2$ in the $y$-direction. The volume (area in 2D) of this control volume is $V_{i,j} = h_x h_y$.\n\nWe define the cell-averaged quantity $\\bar{u}_{i,j}(t) = \\frac{1}{V_{i,j}} \\int_{V_{i,j}} u(x,y,t) \\, dV$. The integral conservation law becomes:\n$$\nV_{i,j} \\frac{d\\bar{u}_{i,j}}{dt} + \\oint_{\\partial V_{i,j}} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = 0\n$$\nIn a vertex-centered scheme, the cell average $\\bar{u}_{i,j}$ is approximated by the value at the vertex itself, $\\bar{u}_{i,j} \\approx u_{i,j}$.\n\nThe flux integral is evaluated by summing the fluxes over the four faces of the rectangular control volume: East (e), West (w), North (n), and South (s). The velocity vector is $\\boldsymbol{a} = (1, 0)$. The outward normal vectors are $\\boldsymbol{n}_e = (1,0)$, $\\boldsymbol{n}_w = (-1,0)$, $\\boldsymbol{n}_n = (0,1)$, and $\\boldsymbol{n}_s = (0,-1)$. The dot products are:\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_e = 1$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_w = -1$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_n = 0$\n- $\\boldsymbol{a} \\cdot \\boldsymbol{n}_s = 0$\n\nThus, fluxes through the north and south faces are zero. The flux integral simplifies to the sum of fluxes through the east and west faces:\n$$\n\\oint_{\\partial V_{i,j}} (\\boldsymbol{a}\\,u) \\cdot \\boldsymbol{n} \\, dS = \\int_e u \\, dS - \\int_w u \\, dS\n$$\nThe lengths of the east and west faces are both $h_y$. Approximating the integral over each face using the midpoint rule gives a numerical flux:\n$$\n\\int_e u \\, dS - \\int_w u \\, dS \\approx (F_e - F_w)\n$$\nwhere $F_e = u_e h_y$ and $F_w = u_w h_y$. Here, $u_e$ and $u_w$ are the values of $u$ at the center of the east and west faces, respectively.\n\nThe problem specifies a first-order upwind scheme. Since the advection velocity in the $x$-direction is positive ($a_x = 1  0$), the \"upwind\" direction is from the left (from smaller $x$). Therefore, the value of $u$ at a face is taken from the vertex on the upwind side of that face.\n- For the east face of $V_{i,j}$ (at $x=x_i+h_x/2$), the upwind vertex is $(i,j)$. Thus, $u_e = u_{i,j}$. The flux leaving the east face is $u_{i,j} h_y$.\n- For the west face of $V_{i,j}$ (at $x=x_i-h_x/2$), the upwind vertex is the western neighbor, $(i_W, j)$, where $i_W = (i-1) \\pmod{N_x}$ to handle periodic boundary conditions. Thus, $u_w = u_{i_W,j}$. The flux entering the west face is $u_{i_W,j} h_y$.\n\nThe net flux out of the control volume $V_{i,j}$ is the flux out from the east face minus the flux in from the west face:\n$$\n\\text{Net Flux} = (u_{i,j} h_y) - (u_{i_W,j} h_y) = (u_{i,j} - u_{i_W,j})h_y\n$$\nSubstituting this into the semi-discretized conservation law gives:\n$$\nh_x h_y \\frac{d u_{i,j}}{dt} + (u_{i,j} - u_{i_W,j})h_y = 0\n$$\nDividing by the volume $h_x h_y$ yields the semi-discrete system of ODEs:\n$$\n\\frac{d u_{i,j}}{dt} = - \\frac{1}{h_x} (u_{i,j} - u_{i_W,j})\n$$\nThe problem specifies explicit forward Euler for time integration. Approximating the time derivative as $\\frac{d u_{i,j}}{dt} \\approx \\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t}$, where $u_{i,j}^n = u(x_i, y_j, t^n)$, we get the fully discrete scheme:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^{n}}{\\Delta t} = - \\frac{1}{h_x} (u_{i,j}^n - u_{i_W,j}^n)\n$$\nRearranging for $u_{i,j}^{n+1}$ yields the update formula provided in the problem statement:\n$$\nu^{n+1}_{i,j} = u^n_{i,j} - \\frac{\\Delta t}{h_x}\\big(u^n_{i,j} - u^n_{i_W,j}\\big)\n$$\n\nThe stability of this explicit scheme is governed by the Courant–Friedrichs–Lewy (CFL) condition. For the 1D advection equation $u_t + a_x u_x = 0$, the first-order upwind scheme (which is a Forward-Time, Backward-Space scheme for $a_x  0$) is stable if the Courant number $C = |a_x| \\frac{\\Delta t}{h_x}$ satisfies $C \\le 1$. In our case, $a_x = 1$, so the condition becomes:\n$$\n\\frac{\\Delta t}{h_x} \\le 1 \\quad \\text{or} \\quad \\Delta t \\le h_x\n$$\nThe implementation will verify if this condition is met for the given parameters in each test case.\n\nThe implementation will proceed as follows:\n1. For each test case, define grid parameters $N_x, N_y, L_x, L_y, h_x, h_y$ and the time step $\\Delta t$.\n2. Construct a 2D grid of vertex coordinates $(x_i, y_j)$ for $i \\in [0, N_x-1]$ and $j \\in [0, N_y-1]$.\n3. Initialize the solution field $u^n$ on this grid using the provided initial condition function $u_0(x,y)$.\n4. Compute the updated field $u^{n+1}$ using the vectorized form of the update equation. The periodic shift $u_{i_W,j}$ will be implemented efficiently using `numpy.roll`.\n5. Determine the boolean flag for CFL stability by checking if $\\Delta t \\le h_x$.\n6. Identify the grid indices $(i^\\star, j^\\star)$ closest to the evaluation point $(x^\\star, y^\\star)$ using the specified rounding and modulo arithmetic.\n7. Extract the value of $u^{n+1}$ at $(i^\\star, j^\\star)$, round it to $8$ decimal places, and package it with the CFL boolean flag into the final result list.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear advection problem for one time step using a\n    vertex-centered FVM with first-order upwind fluxes.\n    \"\"\"\n    # Parameters for the initial condition\n    x_c = 0.25\n    y_c = 0.5\n    sigma = 0.15\n    beta = 0.25\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'Nx': 20, 'Ny': 20, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.02, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 50, 'Ny': 10, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.02, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 30, 'Ny': 30, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.06, 'x_star': 0.6, 'y_star': 0.3},\n        {'Nx': 16, 'Ny': 16, 'Lx': 1.0, 'Ly': 1.0, 'dt': 0.0, 'x_star': 0.6, 'y_star': 0.3},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters for the current case\n        Nx, Ny = case['Nx'], case['Ny']\n        Lx, Ly = case['Lx'], case['Ly']\n        dt = case['dt']\n        x_star, y_star = case['x_star'], case['y_star']\n\n        # Calculate grid spacings\n        hx = Lx / Nx\n        hy = Ly / Ny\n\n        # Create grid coordinates\n        x_coords = np.arange(Nx) * hx\n        y_coords = np.arange(Ny) * hy\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # Initialize the scalar field u at time t^n\n        # u_n(x,y) = exp(-((x-xc)^2 + (y-yc)^2)/sigma^2) + beta*sin(2*pi*x)*cos(2*pi*y)\n        u_n = np.exp(-((X - x_c)**2 + (Y - y_c)**2) / sigma**2) + \\\n              beta * np.sin(2 * np.pi * X) * np.cos(2 * np.pi * Y)\n\n        # Perform one explicit time step using first-order upwind scheme\n        # u^{n+1}_{i,j} = u^n_{i,j} - dt/hx * (u^n_{i,j} - u^n_{i_W,j})\n        # i_W corresponds to a circular shift in the i-direction (axis 0)\n        u_W = np.roll(u_n, shift=1, axis=0)\n        u_np1 = u_n - (dt / hx) * (u_n - u_W)\n\n        # Determine if the CFL stability condition is satisfied\n        # For a=1, the condition is dt = hx.\n        cfl_ok = (dt = hx)\n\n        # Find the indices of the vertex closest to the evaluation point (x_star, y_star)\n        # i_star = round(x_star / hx) mod Nx\n        # j_star = round(y_star / hy) mod Ny\n        i_star = int(np.round(x_star / hx)) % Nx\n        j_star = int(np.round(y_star / hy)) % Ny\n        \n        # Get the updated value at the evaluation vertex\n        u_eval = u_np1[i_star, j_star]\n        \n        # Append the result for this case\n        results.append([round(u_eval, 8), cfl_ok])\n\n    # Format the final output as a string representing a list of lists\n    # e.g., [[0.12345678, True], [0.98765432, False]]\n    # Python's str() on a boolean gives 'True' or 'False', which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world applications require a deeper analysis of a scheme's performance beyond basic implementation. This advanced exercise challenges you to simulate a classic CFD test case—the solid-body rotation of a Gaussian vortex—using both vertex-centered and the alternative cell-centered formulations. By comparing the numerical error and measuring its sensitivity to mesh orientation, known as anisotropy, you will develop critical skills in evaluating and contrasting numerical methods, appreciating the subtle trade-offs that guide the choice of discretization in practice .",
            "id": "3387913",
            "problem": "Consider the advection of a smooth scalar field by a divergence-free, solid-body rotational flow in two spatial dimensions. Let the scalar field be denoted by $\\phi(x,y,t)$ and the velocity field be denoted by $\\boldsymbol{u}(x,y)$. The governing equation is the conservation law for a passive scalar,\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u}\\,\\phi) = 0,\n$$\nwith $\\nabla \\cdot \\boldsymbol{u} = 0$. The domain is the unit square with periodic boundaries. The velocity field represents rigid rotation about the geometric center $(x_c,y_c) = (\\,0.5,\\,0.5\\,)$ with angular speed $\\Omega$, namely\n$$\n\\boldsymbol{u}(x,y) = \\begin{bmatrix} -\\Omega \\,(y - y_c) \\\\ \\Omega \\,(x - x_c) \\end{bmatrix}.\n$$\nThe initial scalar field is a Gaussian hump centered at $(x_c,y_c)$ with standard deviation $\\sigma$,\n$$\n\\phi(x,y,0) = \\exp\\!\\left(-\\frac{(x-x_c)^2 + (y-y_c)^2}{2\\,\\sigma^2}\\right).\n$$\nBecause the flow is a rigid rotation, the exact solution after one full rotation period $T = \\frac{2\\pi}{\\Omega}$ equals the initial condition everywhere.\n\nYour task is to implement and compare two spatially discrete formulations of the Finite Volume Method (FVM): a cell-centered FVM and a vertex-centered FVM, on a family of uniformly structured, orthogonal meshes that are rigidly rotated by an angle $\\theta$ about $(x_c,y_c)$. The meshes are periodic in both directions. The time integration must be explicit and second-order accurate, using a two-stage Strong-Stability-Preserving Runge-Kutta (SSPRK) method.\n\nThe discretization requirements are as follows, each stemming directly from the integral form of conservation on a control volume:\n- For any control volume $\\mathcal{C}$ with boundary $\\partial \\mathcal{C}$ and outward unit normal $\\boldsymbol{n}$, the integral form is\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{\\mathcal{C}} \\phi \\,\\mathrm{d}A \\;=\\; - \\oint_{\\partial \\mathcal{C}} (\\boldsymbol{u}\\cdot \\boldsymbol{n})\\,\\phi \\,\\mathrm{d}s.\n$$\n- The space discretization must approximate the boundary integral by a sum of edge fluxes. For each straight edge with endpoints $\\boldsymbol{x}_a$ and $\\boldsymbol{x}_b$, use a midpoint quadrature and an upwind value of $\\phi$ based on the sign of $(\\boldsymbol{u}\\cdot \\boldsymbol{n})$ at the edge midpoint.\n- In the cell-centered FVM, the control volumes are the physical quadrilateral cells themselves, and the unknowns are located at cell centers.\n- In the vertex-centered FVM, the control volumes are the dual polygons around vertices constructed by connecting the centers of the four primary cells that meet at a given vertex (periodic topology ensures each vertex has four surrounding cells). The unknowns are located at the vertices.\n- The explicit time integrator is the two-stage Strong-Stability-Preserving Runge-Kutta method:\n  1. $\\phi^{(1)} = \\phi^{n} + \\Delta t\\,\\mathcal{L}(\\phi^{n})$,\n  2. $\\phi^{n+1} = \\tfrac{1}{2}\\,\\phi^{n} + \\tfrac{1}{2}\\,\\left(\\phi^{(1)} + \\Delta t\\,\\mathcal{L}(\\phi^{(1)})\\right)$,\n  where $\\mathcal{L}$ denotes the semi-discrete flux-divergence operator on the chosen control volumes.\n\nUse periodic boundary conditions in both directions. Construct each rotated mesh by rigidly rotating the underlying uniform, orthogonal mesh by angle $\\theta$ about $(x_c,y_c)$ while preserving all connectivities.\n\nDefine the square-integrable norm (Lebesgue $L_2$ norm) of the error after one full rotation as\n$$\n\\|\\mathrm{err}\\|_{L_2} \\;=\\; \\left(\\sum_{k} |\\mathcal{C}_k|\\,\\big(\\phi_k^{\\text{num}}(T) - \\phi_k^{\\text{ref}}(0)\\big)^2\\right)^{1/2},\n$$\nwhere $|\\mathcal{C}_k|$ is the area of control volume $k$, and $\\phi^{\\text{ref}}(0)$ is the exact solution at $t=0$ evaluated at the representative point of the control volume (cell center for cell-centered, vertex for vertex-centered). For practical evaluation, approximate the exact mean value on a control volume by the value at its representative point.\n\nQuantify directional sensitivity via an anisotropy factor as a function of mesh alignment angle:\n$$\n\\alpha(\\theta) \\;=\\; \\frac{\\|\\mathrm{err}\\|_{L_2}(\\theta)}{\\min_{\\theta'} \\|\\mathrm{err}\\|_{L_2}(\\theta')}.\n$$\n\nImplementation constraints and data for the test suite:\n- Mesh size: use $N = 24$ primary cells per coordinate direction.\n- Angular speed: $\\Omega = 2\\pi$ so that $T = 1$.\n- Gaussian width: $\\sigma = 0.08$.\n- Angles: evaluate for $\\theta \\in \\{\\,0,\\;\\pi/8,\\;\\pi/4,\\;3\\pi/8,\\;\\pi/2\\,\\}$, where all angles are in radians.\n- Time step: choose a globally stable $\\Delta t$ using a Courant-Friedrichs-Lewy number $\\text{CFL} = 0.35$ with respect to the face-normal speeds and control-volume areas, and adjust the number of steps to land exactly at $T$ by using $n_{\\text{steps}} = \\lceil T/\\Delta t \\rceil$ and $\\Delta t \\leftarrow T/n_{\\text{steps}}$.\n- Units: Report angles in radians; all other quantities are nondimensional.\n\nYour program must compute, for each $\\theta$ in the test suite and for each of the two formulations (cell-centered and vertex-centered), the error norm $\\|\\mathrm{err}\\|_{L_2}(\\theta)$ and the anisotropy factor $\\alpha(\\theta)$ defined above. The final output must be a single line containing a JSON-like list with four sublists in the following order:\n- the list of $L_2$ errors for the cell-centered formulation in the order of the given angles,\n- the list of $L_2$ errors for the vertex-centered formulation in the same order,\n- the list of anisotropy factors for the cell-centered formulation in the same order,\n- the list of anisotropy factors for the vertex-centered formulation in the same order.\n\nFor example, the required output format is\n\"[ [e_cc_theta1,e_cc_theta2,...], [e_vc_theta1,e_vc_theta2,...], [alpha_cc_theta1,alpha_cc_theta2,...], [alpha_vc_theta1,alpha_vc_theta2,...] ]\"\nwhere all entries are floating-point numbers.\n\nYour implementation must be entirely self-contained, require no user input, and must rely only on the stated libraries. All angles must be treated in radians, and all outputs must be floating-point numbers. The printed line must be exactly in the specified single-line bracketed list format.",
            "solution": "The user has provided a valid, well-posed problem statement from the field of computational fluid dynamics. The task is to simulate the advection of a scalar field under solid-body rotation using two different finite volume formulations—cell-centered and vertex-centered—on rotated structured meshes, and to quantify the error and its directional anisotropy.\n\nThe solution proceeds by first establishing the mathematical and numerical framework, and then implementing it to compute the required quantities.\n\n1.  **Governing Equation and Integral Form**\n\nThe governing equation for the advection of a passive scalar field $\\phi(\\boldsymbol{x}, t)$ by a velocity field $\\boldsymbol{u}(\\boldsymbol{x})$ is the conservation law:\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u}\\,\\phi) = 0\n$$\nThe problem specifies a divergence-free velocity field, $\\nabla \\cdot \\boldsymbol{u} = 0$, which simplifies the equation to the advection form $\\frac{\\partial \\phi}{\\partial t} + \\boldsymbol{u} \\cdot \\nabla \\phi = 0$. However, the finite volume method is most naturally derived from the conservative form. Integrating over a fixed control volume $\\mathcal{C}$ with boundary $\\partial \\mathcal{C}$ and applying the divergence theorem yields the integral form of the conservation law:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{\\mathcal{C}} \\phi \\,\\mathrm{d}A \\;+\\; \\oint_{\\partial \\mathcal{C}} (\\boldsymbol{u}\\,\\phi) \\cdot \\boldsymbol{n} \\,\\mathrm{d}s = 0\n$$\nwhere $\\boldsymbol{n}$ is the outward-pointing unit normal vector to the boundary $\\partial \\mathcal{C}$. Rearranging gives the rate of change of the average scalar value in the control volume as the net flux across its boundary:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\bar{\\phi}_{\\mathcal{C}} \\;=\\; -\\frac{1}{|\\mathcal{C}|} \\oint_{\\partial \\mathcal{C}} \\phi\\,(\\boldsymbol{u}\\cdot \\boldsymbol{n}) \\,\\mathrm{d}s\n$$\nwhere $|\\mathcal{C}|$ is the area of the control volume and $\\bar{\\phi}_{\\mathcal{C}}$ is the average value of $\\phi$ over $\\mathcal{C}$.\n\n2.  **Finite Volume Discretization**\n\nThe finite volume method discretizes the domain into a set of non-overlapping control volumes $\\{\\mathcal{C}_k\\}$ that cover the domain. Within each control volume $\\mathcal{C}_k$, we track the evolution of a single unknown value, $\\phi_k$, which represents the average value $\\bar{\\phi}_{\\mathcal{C}_k}$. The integral equation for each control volume becomes an ordinary differential equation (ODE) for $\\phi_k$:\n$$\n\\frac{\\mathrm{d}\\phi_k}{\\mathrm{d}t} = -\\frac{1}{|\\mathcal{C}_k|} \\sum_{f \\in \\partial \\mathcal{C}_k} F_f\n$$\nHere, the boundary integral has been approximated as a sum of fluxes $F_f$ over the discrete faces (edges in 2D) of the control volume. The flux through a face $f$ is given by $F_f = \\int_f \\phi\\,(\\boldsymbol{u}\\cdot \\boldsymbol{n}) \\,\\mathrm{d}s$.\n\n3.  **Numerical Flux Approximation**\n\nThe problem specifies approximating the flux integral over each straight face $f$ using a midpoint quadrature rule and a first-order upwind scheme. The flux is thus:\n$$\nF_f \\approx \\phi_f \\, (\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f) \\, l_f\n$$\nwhere $l_f$ is the length of the face, $\\boldsymbol{u}_f$ and $\\boldsymbol{n}_f$ are the velocity and outward normal vector at the face midpoint, respectively. The scalar value $\\phi_f$ is chosen via upwinding based on the sign of the normal velocity $(\\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f)$:\n$$\n\\phi_f = \\begin{cases} \\phi_k  \\text{if } \\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f \\geq 0 \\quad \\text{(outflow from } \\mathcal{C}_k \\text{)} \\\\ \\phi_{\\text{adj}}  \\text{if } \\boldsymbol{u}_f \\cdot \\boldsymbol{n}_f  0 \\quad \\text{(inflow to } \\mathcal{C}_k \\text{)} \\end{cases}\n$$\nwhere $\\phi_{\\text{adj}}$ is the scalar value from the control volume adjacent to $\\mathcal{C}_k$ across face $f$. This choice ensures that information is propagated in the direction of the flow, a necessary condition for the stability of this explicit advection scheme.\n\n4.  **Control Volume Formulations**\n\nTwo formulations are to be compared:\n\n-   **Cell-Centered FVM (CC-FVM):** The control volumes $\\mathcal{C}_k$ are the primary quadrilateral cells of the mesh. The unknown scalar value $\\phi_k$ is associated with the geometric center of the cell. The faces of the control volume are the four edges of the quadrilateral cell.\n\n-   **Vertex-Centered FVM (VC-FVM):** The unknown scalar values $\\phi_k$ are associated with the vertices of the primary mesh. The control volume for each vertex is the dual polygon formed by connecting the centers of the primary cells that meet at that vertex. For the structured quadrilateral mesh used here, each vertex is shared by four cells (respecting periodicity), so its dual control volume is a quadrilateral.\n\n5.  **Semi-Discrete System**\n\nSubstituting the numerical flux into the ODE for each control volume yields a system of coupled ODEs, known as the semi-discrete formulation, which can be written in vector form:\n$$\n\\frac{\\mathrm{d}\\boldsymbol{\\phi}}{\\mathrm{d}t} = \\mathcal{L}(\\boldsymbol{\\phi})\n$$\nwhere $\\boldsymbol{\\phi}$ is the vector of all unknown scalar values $\\{\\phi_k\\}$, and $\\mathcal{L}$ is the spatial discretization operator that computes the negative of the flux divergence for each control volume.\n\n6.  **Temporal Discretization: SSPRK2**\n\nThe problem requires a second-order accurate, two-stage Strong-Stability-Preserving Runge-Kutta (SSPRK2) method to integrate the semi-discrete system in time. Given the solution $\\boldsymbol{\\phi}^n$ at time $t_n$, the solution at $t_{n+1} = t_n + \\Delta t$ is computed via:\n1.  $\\boldsymbol{\\phi}^{(1)} = \\boldsymbol{\\phi}^{n} + \\Delta t\\,\\mathcal{L}(\\boldsymbol{\\phi}^{n})$\n2.  $\\boldsymbol{\\phi}^{n+1} = \\frac{1}{2}\\,\\boldsymbol{\\phi}^{n} + \\frac{1}{2}\\,\\left(\\boldsymbol{\\phi}^{(1)} + \\Delta t\\,\\mathcal{L}(\\boldsymbol{\\phi}^{(1)})\\right)$\n\n7.  **Mesh and Time Step**\n\nA uniform $N \\times N$ Cartesian mesh is generated on the unit square and then rigidly rotated by an angle $\\theta$ around the domain center $(0.5, 0.5)$. Geometric quantities for each control volume (area, face midpoints, face normals, face lengths) are calculated based on the rotated coordinates.\n\nThe time step $\\Delta t$ is constrained by the Courant-Friedrichs-Lewy (CFL) condition for stability. For an explicit upwind scheme, a stable time step must satisfy:\n$$\n\\Delta t \\le \\text{CFL} \\times \\min_k \\left( \\frac{|\\mathcal{C}_k|}{\\sum_{f \\in \\partial \\mathcal{C}_k} \\max(0, (\\boldsymbol{u} \\cdot \\boldsymbol{n})_f) \\, l_f} \\right)\n$$\nWe compute the term on the right, which represents a characteristic flow-through time for the smallest/fastest-moving cells, to find a stable time step $\\Delta t_0$ for the given $\\text{CFL}=0.35$. To ensure the simulation ends exactly at the final time $T=1$, the number of steps is set to $n_{\\text{steps}} = \\lceil T/\\Delta t_0 \\rceil$, and the time step is adjusted to $\\Delta t = T/n_{\\text{steps}}$.\n\n8.  **Error and Anisotropy Calculation**\n\nAfter one full rotation period $T$, the numerical solution $\\phi_k^{\\text{num}}(T)$ is compared to the exact solution, which is simply the initial condition $\\phi_k^{\\text{ref}}(0)$. The discrete $L_2$ error norm is computed as:\n$$\n\\|\\mathrm{err}\\|_{L_2} \\;=\\; \\left(\\sum_{k} |\\mathcal{C}_k|\\,\\big(\\phi_k^{\\text{num}}(T) - \\phi_k^{\\text{ref}}(0)\\big)^2\\right)^{1/2}\n$$\nThe anisotropy factor $\\alpha(\\theta)$, which measures the sensitivity of the error to the mesh orientation, is calculated by normalizing the error at each angle $\\theta$ by the minimum error observed across all tested angles for that formulation:\n$$\n\\alpha(\\theta) \\;=\\; \\frac{\\|\\mathrm{err}\\|_{L_2}(\\theta)}{\\min_{\\theta'} \\|\\mathrm{err}\\|_{L_2}(\\theta')}\n$$\nThe following code implements this entire procedure for both FVM formulations and over the specified range of mesh rotation angles.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares cell-centered and vertex-centered finite volume methods\n    for the solid-body rotation of a Gaussian scalar field on rotated meshes.\n    \"\"\"\n    \n    # --- Problem Constants ---\n    N = 24\n    OMEGA = 2.0 * np.pi\n    T_FINAL = 1.0\n    SIGMA = 0.08\n    XC, YC = 0.5, 0.5\n    CFL = 0.35\n    ANGLES = [0.0, np.pi/8, np.pi/4, 3*np.pi/8, np.pi/2]\n    CENTER_PT = np.array([XC, YC])\n\n    # --- Helper Functions ---\n    def rotate_point(p, center, angle_rad):\n        \"\"\"Rotates a 2D point around a center.\"\"\"\n        x, y = p\n        cx, cy = center\n        cos_a, sin_a = np.cos(angle_rad), np.sin(angle_rad)\n        x_rot = cos_a * (x - cx) - sin_a * (y - cy) + cx\n        y_rot = sin_a * (x - cx) + cos_a * (y - cy) + cy\n        return np.array([x_rot, y_rot])\n\n    def get_velocity(p):\n        \"\"\"Calculates the solid-body rotation velocity at a point.\"\"\"\n        x, y = p\n        u = -OMEGA * (y - YC)\n        v = OMEGA * (x - XC)\n        return np.array([u, v])\n\n    def shoelace_area(vertices):\n        \"\"\"Calculates the area of a polygon using the shoelace formula.\"\"\"\n        x, y = vertices[:, 0], vertices[:, 1]\n        return 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n\n    def run_simulation(formulation, theta):\n        \"\"\"\n        Runs a single simulation for a given formulation and mesh angle.\n        \n        Returns:\n            float: The L2 error norm of the final solution.\n        \"\"\"\n        # --- 1. Geometric Setup ---\n        dx = 1.0 / N\n        \n        # Base grid points\n        unrotated_verts = np.array([[[i * dx, j * dx] for j in range(N + 1)] for i in range(N + 1)])\n        unrotated_centers = np.array([[[ (i + 0.5) * dx, (j + 0.5) * dx] for j in range(N)] for i in range(N)])\n        \n        # Rotated grid points\n        rotated_verts = np.array([[rotate_point(unrotated_verts[i, j], CENTER_PT, theta) for j in range(N + 1)] for i in range(N + 1)])\n        rotated_centers = np.array([[rotate_point(unrotated_centers[i, j], CENTER_PT, theta) for j in range(N)] for i in range(N)])\n\n        rep_points = np.zeros((N, N, 2))\n        cv_areas = np.zeros((N, N))\n        faces_info = [[[] for _ in range(N)] for _ in range(N)]\n        \n        max_cfl_term = 0.0\n\n        for i in range(N):\n            for j in range(N):\n                ip1, im1 = (i + 1) % N, (i - 1 + N) % N\n                jp1, jm1 = (j + 1) % N, (j - 1 + N) % N\n\n                if formulation == 'cell-centered':\n                    rep_points[i, j] = rotated_centers[i, j]\n                    \n                    v_bl, v_br = rotated_verts[i, j], rotated_verts[i + 1, j]\n                    v_tr, v_tl = rotated_verts[i + 1, j + 1], rotated_verts[i, j + 1]\n                    cv_verts = np.array([v_bl, v_br, v_tr, v_tl]) # CCW order\n                    cv_areas[i, j] = shoelace_area(cv_verts)\n                    \n                    face_pts = [(v_bl, v_br), (v_br, v_tr), (v_tr, v_tl), (v_tl, v_bl)] # bottom, right, top, left\n                    neighbors = [(i, jm1), (ip1, j), (i, jp1), (im1, j)]\n                elif formulation == 'vertex-centered':\n                    rep_points[i, j] = rotated_verts[i, j]\n                    \n                    c_bl, c_br = rotated_centers[im1, jm1], rotated_centers[i, jm1]\n                    c_tr, c_tl = rotated_centers[i, j], rotated_centers[im1, j]\n                    cv_verts = np.array([c_bl, c_br, c_tr, c_tl]) # CCW order\n                    cv_areas[i, j] = shoelace_area(cv_verts)\n\n                    face_pts = [(c_bl, c_br), (c_br, c_tr), (c_tr, c_tl), (c_tl, c_bl)]\n                    neighbors = [(i, jm1), (ip1, j), (i, jp1), (im1, j)]\n                \n                current_outflow_rate = 0.0\n                current_faces = []\n                for k in range(4):\n                    p1, p2 = face_pts[k]\n                    edge_vec = p2 - p1\n                    length = np.linalg.norm(edge_vec)\n                    normal = np.array([edge_vec[1], -edge_vec[0]]) / length if length > 0 else np.array([0.,0.])\n                    midpoint = 0.5 * (p1 + p2)\n                    \n                    u_dot_n = np.dot(get_velocity(midpoint), normal)\n                    current_outflow_rate += max(0, u_dot_n) * length\n                    current_faces.append({'normal': normal, 'length': length, 'neighbor': neighbors[k], 'midpoint': midpoint})\n                \n                faces_info[i][j] = current_faces\n                if cv_areas[i, j] > 1e-12:\n                    max_cfl_term = max(max_cfl_term, current_outflow_rate / cv_areas[i, j])\n\n        # --- 2. Initial Condition  Time Stepping ---\n        phi0 = np.exp(-((rep_points[:, :, 0] - XC)**2 + (rep_points[:, :, 1] - YC)**2) / (2 * SIGMA**2))\n        phi = phi0.copy()\n        \n        dt_cfl = CFL / max_cfl_term if max_cfl_term > 1e-12 else float('inf')\n        n_steps = int(np.ceil(T_FINAL / dt_cfl))\n        dt = T_FINAL / n_steps\n\n        # --- 3. Time Integration (SSPRK2) ---\n        def compute_L(phi_field):\n            L = np.zeros_like(phi_field)\n            for i in range(N):\n                for j in range(N):\n                    net_flux = 0.0\n                    for face in faces_info[i][j]:\n                        u_dot_n = np.dot(get_velocity(face['midpoint']), face['normal'])\n                        if u_dot_n >= 0: # Outflow\n                            phi_upwind = phi_field[i, j]\n                        else: # Inflow\n                            ni, nj = face['neighbor']\n                            phi_upwind = phi_field[ni, nj]\n                        net_flux += phi_upwind * u_dot_n * face['length']\n                    \n                    if cv_areas[i, j] > 1e-12:\n                        L[i, j] = -net_flux / cv_areas[i, j]\n            return L\n\n        for _ in range(n_steps):\n            k1 = compute_L(phi)\n            phi1 = phi + dt * k1\n            k2 = compute_L(phi1)\n            phi = 0.5 * phi + 0.5 * (phi1 + dt * k2)\n\n        # --- 4. Error Calculation ---\n        error = np.sqrt(np.sum(cv_areas * (phi - phi0)**2))\n        return error\n\n    # --- Main Execution Logic ---\n    errors_cc = [run_simulation('cell-centered', theta) for theta in ANGLES]\n    errors_vc = [run_simulation('vertex-centered', theta) for theta in ANGLES]\n    \n    min_err_cc = min(errors_cc) if errors_cc else 1.0\n    min_err_vc = min(errors_vc) if errors_vc else 1.0\n    \n    alphas_cc = [err / min_err_cc for err in errors_cc]\n    alphas_vc = [err / min_err_vc for err in errors_vc]\n\n    results = [errors_cc, errors_vc, alphas_cc, alphas_vc]\n    \n    # --- Format and Print Final Output ---\n    list_strs = [f\"[{','.join(map(str, sublist))}]\" for sublist in results]\n    print(f\"[{','.join(list_strs)}]\")\n\nsolve()\n```"
        }
    ]
}