{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any reliable simulation is a valid computational grid. This practice addresses the critical first step of mesh quality assurance: detecting and fixing 'inverted' cells that can crash a solver . You will implement standard diagnostic tools based on the Jacobian determinant $J$ and oriented cell volumes, and then apply a Laplacian smoothing algorithm to heal a warped grid, gaining essential skills in mesh pre-processing.",
            "id": "3327949",
            "problem": "You are given a boundary-fitted structured grid mapping in two dimensions and a set of unstructured three-dimensional tetrahedral cells. Your task is to implement detection of mesh warping and inverted (negative-volume) cells using the Jacobian determinant and oriented face area vectors, and to apply a remedial smoothing criterion for the structured grid. The target is to demonstrate principled detection and to quantify the effect of smoothing under a consistent acceptance rule.\n\nFundamental base and definitions to be used:\n\n- Consider a smooth boundary-fitted mapping from computational coordinates $(\\xi,\\eta)\\in[0,1]^2$ to physical coordinates $(x,y)$, with $x=x(\\xi,\\eta)$ and $y=y(\\xi,\\eta)$. The Jacobian determinant $J$ is defined as the determinant of the transformation derivative tensor from $(\\xi,\\eta)$ to $(x,y)$, namely $J = \\det\\left(\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$.\n\n- For a three-dimensional unstructured tetrahedral cell with vertices $\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{v}_4\\in\\mathbb{R}^3$, oriented face area vectors are defined as $\\mathbf{A}_f = \\int_f \\mathbf{n}\\,dA$ for each face $f$, where $\\mathbf{n}$ is the outward unit normal and $A$ is the face area. The oriented cell volume can be expressed using oriented face area vectors, and for a tetrahedron is equivalently expressed via the oriented scalar triple product of edge vectors.\n\n- Mesh warping in a structured boundary-fitted grid is associated with small or highly variable $J$, and inversion occurs when $J0$ or when a cell’s oriented area becomes negative relative to the intended orientation.\n\nYour program must:\n\n1. For the structured two-dimensional grid, construct physical node coordinates from a boundary-fitted mapping on the unit square computational domain using the following mapping family with perturbation parameters $(a,b)$:\n   - $x(\\xi,\\eta) = \\xi + a \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$.\n   - $y(\\xi,\\eta) = \\eta + b \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$.\n   The computational grid is a rectilinear lattice of $(n_x\\times n_y)$ nodes with uniform spacings $\\Delta \\xi = 1/(n_x-1)$ and $\\Delta \\eta = 1/(n_y-1)$.\n\n2. Compute the discrete Jacobian determinant $J$ at each cell center using consistent finite-difference approximations for $\\partial x/\\partial \\xi$, $\\partial x/\\partial \\eta$, $\\partial y/\\partial \\xi$, and $\\partial y/\\partial \\eta$ based on neighboring node coordinates in physical space. Report the minimum value of $J$ across all cells in the grid.\n\n3. Detect inverted quadrilateral cells by computing the oriented area of each cell polygon in physical space and checking its sign relative to the lexicographic node ordering $(i,j)\\to(i+1,j)\\to(i+1,j+1)\\to(i,j+1)$. A negative oriented area is considered an inversion. Return a boolean indicating whether any such inverted cell exists.\n\n4. Apply remedial smoothing for the structured grid using a relaxation form of Laplacian smoothing on interior nodes in physical space. For each iteration, update interior node coordinates $(x_{i,j},y_{i,j})$ to\n   $$\\mathbf{p}_{i,j}^{\\text{new}} = \\mathbf{p}_{i,j}^{\\text{old}} + \\omega\\left(\\frac{\\mathbf{p}_{i+1,j}+\\mathbf{p}_{i-1,j}+\\mathbf{p}_{i,j+1}+\\mathbf{p}_{i,j-1}}{4} - \\mathbf{p}_{i,j}^{\\text{old}}\\right),$$\n   where $\\omega\\in(0,1)$ is a relaxation parameter and $\\mathbf{p}_{i,j}=(x_{i,j},y_{i,j})$. Boundary nodes are fixed and not smoothed. After each iteration, re-evaluate the discrete Jacobian and oriented areas. The acceptance criterion for stopping is:\n   - $J_{\\min} \\ge \\varepsilon$ and no negative-area cells,\n   with $\\varepsilon>0$ a small target threshold. If the acceptance criterion is not met after a maximum number of iterations, declare failure and report an iteration count of $-1$.\n\n5. For the unstructured tetrahedral cells, compute the oriented volume using the scalar triple product of edge vectors. Given vertices $\\mathbf{v}_1,\\mathbf{v}_2,\\mathbf{v}_3,\\mathbf{v}_4$, define:\n   $$V_{\\text{tet}} = \\frac{1}{6}\\left[\\left(\\mathbf{v}_2-\\mathbf{v}_1\\right)\\cdot\\left(\\left(\\mathbf{v}_3-\\mathbf{v}_1\\right)\\times\\left(\\mathbf{v}_4-\\mathbf{v}_1\\right)\\right)\\right].$$\n   A negative value indicates an inverted orientation. Return the oriented volume and a boolean indicating whether it is negative.\n\nTest suite:\n\n- Structured grid cases use $(n_x,n_y)=(33,33)$, relaxation parameter $\\omega=0.5$, threshold $\\varepsilon=0.05$, and maximum iterations $N_{\\max}=25$.\n  1. Case S1 (happy path): $(a,b)=(0.05,0.02)$.\n  2. Case S2 (strong warp/inversion): $(a,b)=(0.20,0.00)$.\n  3. Case S3 (near-degenerate edge case): $(a,b)=(0.159,0.00)$.\n\n- Unstructured tetrahedral cases:\n  4. Case T1 (positive orientation): $\\mathbf{v}_1=(0,0,0)$, $\\mathbf{v}_2=(1,0,0)$, $\\mathbf{v}_3=(0,1,0)$, $\\mathbf{v}_4=(0,0,1)$.\n  5. Case T2 (negative orientation by vertex order): $\\mathbf{v}_1=(0,0,0)$, $\\mathbf{v}_2=(0,1,0)$, $\\mathbf{v}_3=(1,0,0)$, $\\mathbf{v}_4=(0,0,1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must include, in order:\n\n- For each structured case S1–S3: the minimum discrete Jacobian $J_{\\min}$ (float), a boolean indicating existence of any negative-area cell before smoothing, and the integer number of smoothing iterations required to satisfy the acceptance criterion (or $-1$ if not achieved).\n- For each tetrahedral case T1–T2: the oriented volume $V_{\\text{tet}}$ (float) and a boolean indicating whether $V_{\\text{tet}}0$.\n\nExample format (structure only, not actual numeric values): \"[Jmin_S1,negArea_S1,iters_S1,Jmin_S2,negArea_S2,iters_S2,Jmin_S3,negArea_S3,iters_S3,V_T1,neg_T1,V_T2,neg_T2]\".\n\nAll angle measures are in radians. There are no physical units because the computations are non-dimensional in a normalized domain. Ensure the program uses the specified parameters and produces the outputs in the exact format described.",
            "solution": "The provided problem requires the validation of computational mesh quality for both structured two-dimensional grids and unstructured three-dimensional cells. The core tasks are to detect mesh warping and cell inversion and to apply a remedial smoothing procedure for the structured grid. The analysis is grounded in fundamental principles of vector calculus and numerical methods commonly used in computational fluid dynamics (CFD).\n\nFirst, for the structured grid, we must construct the physical grid and then analyze its quality. The physical grid coordinates $(x,y)$ are generated from a uniform computational grid in $(\\xi,\\eta) \\in [0,1]^2$ using the provided boundary-fitted mapping:\n$$x(\\xi,\\eta) = \\xi + a \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$$\n$$y(\\xi,\\eta) = \\eta + b \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$$\nThe computational domain is discretized into a grid of $(n_x \\times n_y)$ nodes, with uniform spacings $\\Delta\\xi = 1/(n_x-1)$ and $\\Delta\\eta = 1/(n_y-1)$.\n\nThe primary metric for local grid quality is the Jacobian determinant of the transformation, $J = \\det\\left(\\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$. A value of $J \\le 0$ indicates a locally inverted or degenerate cell. We compute a discrete approximation of $J$ at the center of each quadrilateral cell $(i,j)$ using second-order accurate central finite differences. For a derivative like $\\frac{\\partial x}{\\partial \\xi}$ at the cell center $(\\xi_{i+1/2}, \\eta_{j+1/2})$, we use values at the cell's four vertices, which are indexed from $(i,j)$ to $(i+1,j+1)$:\n$$ \\frac{\\partial x}{\\partial \\xi} \\approx \\frac{(x_{i+1,j+1} + x_{i+1,j}) - (x_{i,j+1} + x_{i,j})}{2\\Delta\\xi} $$\n$$ \\frac{\\partial x}{\\partial \\eta} \\approx \\frac{(x_{i+1,j+1} + x_{i,j+1}) - (x_{i+1,j} + x_{i,j})}{2\\Delta\\eta} $$\nAnalogous formulas apply for $\\frac{\\partial y}{\\partial \\xi}$ and $\\frac{\\partial y}{\\partial \\eta}$. With these, the discrete Jacobian is calculated as $J_{i,j} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$. We then find the minimum value, $J_{\\min}$, across all cells.\n\nCell inversion is also detected by calculating the oriented area of each quadrilateral cell. For a cell with ordered vertices $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3, \\mathbf{p}_4$, the signed area can be computed from the cross product of its diagonals, $\\mathbf{d}_1 = \\mathbf{p}_3 - \\mathbf{p}_1$ and $\\mathbf{d}_2 = \\mathbf{p}_4 - \\mathbf{p}_2$. For the specified vertex ordering $(i,j) \\to (i+1,j) \\to (i+1,j+1) \\to (i,j+1)$, the area is computed as:\n$$ A = \\frac{1}{2} \\left[ (x_{i+1,j+1}-x_{i,j})(y_{i,j+1}-y_{i+1,j}) - (y_{i+1,j+1}-y_{i,j})(x_{i,j+1}-x_{i+1,j}) \\right] $$\nA negative area, $A  0$, indicates that the cell's orientation in physical space is flipped relative to its orientation in computational space, signifying an inversion.\n\nIf the grid quality is unacceptable ($J_{\\min}  \\varepsilon$ or any cell has a negative area), we apply a remedial smoothing procedure. Laplacian smoothing is an iterative method that adjusts the position of each interior node to be the average of its four neighbors. The update rule with a relaxation parameter $\\omega$ is:\n$$ \\mathbf{p}_{i,j}^{\\text{new}} = \\mathbf{p}_{i,j}^{\\text{old}} + \\omega\\left(\\frac{\\mathbf{p}_{i+1,j}+\\mathbf{p}_{i-1,j}+\\mathbf{p}_{i,j+1}+\\mathbf{p}_{i,j-1}}{4} - \\mathbf{p}_{i,j}^{\\text{old}}\\right) $$\nwhere $\\mathbf{p}_{i,j}=(x_{i,j},y_{i,j})$. Boundary nodes remain fixed. After each iteration, we re-evaluate $J_{\\min}$ and check for negative-area cells. The process stops upon satisfying the acceptance criterion ($J_{\\min} \\ge \\varepsilon$ and no negative areas) or reaching the maximum number of iterations, $N_{\\max}$.\n\nFor the unstructured tetrahedral cells, the quality check involves computing the oriented volume. Given a tetrahedron with vertices $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3, \\mathbf{v}_4$, the oriented volume is given by one-sixth of the scalar triple product of the edge vectors originating from a common vertex, for example $\\mathbf{v}_1$:\n$$ V_{\\text{tet}} = \\frac{1}{6}\\left[ (\\mathbf{v}_2-\\mathbf{v}_1) \\cdot \\left( (\\mathbf{v}_3-\\mathbf{v}_1) \\times (\\mathbf{v}_4-\\mathbf{v}_1) \\right) \\right] $$\nThe sign of $V_{\\text{tet}}$ depends on the ordering of the vertices. A negative volume indicates that the tetrahedron has an orientation opposite to that of a right-handed coordinate system defined by the edge vectors, signifying an inverted element.\n\nThe implementation encapsulates these principles in a series of functions. A function generates the initial structured grid coordinates. A second function computes the discrete Jacobian and oriented areas for all cells. A third function implements the iterative smoothing loop. For the unstructured case, a dedicated function computes the tetrahedral volume. The main program executes the specified test cases, collects the results, and formats them into the required output string. All vector and matrix operations are performed efficiently using the `numpy` library.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(nx, ny, a, b):\n    \"\"\"\n    Generates a 2D structured grid based on the given mapping.\n    \"\"\"\n    xi_1d = np.linspace(0, 1, nx)\n    eta_1d = np.linspace(0, 1, ny)\n    xi, eta = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n    x = xi + a * np.sin(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n    y = eta + b * np.sin(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n    return x, y\n\ndef calculate_metrics(x_coords, y_coords):\n    \"\"\"\n    Computes the minimum Jacobian and checks for negative area cells.\n    \"\"\"\n    nx, ny = x_coords.shape\n    delta_xi = 1.0 / (nx - 1)\n    delta_eta = 1.0 / (ny - 1)\n\n    # --- Jacobian calculation at cell centers ---\n    x_xi_num = (x_coords[1:, 1:] + x_coords[1:, :-1]) - (x_coords[:-1, 1:] + x_coords[:-1, :-1])\n    dx_dxi = x_xi_num / (2 * delta_xi)\n\n    x_eta_num = (x_coords[1:, 1:] + x_coords[:-1, 1:]) - (x_coords[1:, :-1] + x_coords[:-1, :-1])\n    dx_deta = x_eta_num / (2 * delta_eta)\n\n    y_xi_num = (y_coords[1:, 1:] + y_coords[1:, :-1]) - (y_coords[:-1, 1:] + y_coords[:-1, :-1])\n    dy_dxi = y_xi_num / (2 * delta_xi)\n\n    y_eta_num = (y_coords[1:, 1:] + y_coords[:-1, 1:]) - (y_coords[1:, :-1] + y_coords[:-1, :-1])\n    dy_deta = y_eta_num / (2 * delta_eta)\n\n    jacobians = dx_dxi * dy_deta - dx_deta * dy_dxi\n    min_jacobian = np.min(jacobians)\n\n    # --- Oriented area calculation ---\n    d1_x = x_coords[1:, 1:] - x_coords[:-1, :-1]\n    d1_y = y_coords[1:, 1:] - y_coords[:-1, :-1]\n    d2_x = x_coords[:-1, 1:] - x_coords[1:, :-1]\n    d2_y = y_coords[:-1, 1:] - y_coords[1:, :-1]\n    \n    areas = 0.5 * (d1_x * d2_y - d1_y * d2_x)\n    has_negative_area = np.any(areas  0)\n\n    return min_jacobian, has_negative_area\n\ndef smooth_grid(x_coords, y_coords, omega, epsilon, n_max):\n    \"\"\"\n    Applies Laplacian smoothing to the grid and returns iteration count.\n    \"\"\"\n    x_smooth = np.copy(x_coords)\n    y_smooth = np.copy(y_coords)\n    \n    for i in range(n_max):\n        x_old = np.copy(x_smooth)\n        y_old = np.copy(y_smooth)\n\n        avg_x = (x_old[2:, 1:-1] + x_old[:-2, 1:-1] + x_old[1:-1, 2:] + x_old[1:-1, :-2]) / 4.0\n        x_smooth[1:-1, 1:-1] += omega * (avg_x - x_old[1:-1, 1:-1])\n\n        avg_y = (y_old[2:, 1:-1] + y_old[:-2, 1:-1] + y_old[1:-1, 2:] + y_old[1:-1, :-2]) / 4.0\n        y_smooth[1:-1, 1:-1] += omega * (avg_y - y_old[1:-1, 1:-1])\n        \n        min_j, has_neg_area = calculate_metrics(x_smooth, y_smooth)\n        \n        if min_j = epsilon and not has_neg_area:\n            return i + 1\n            \n    return -1\n\ndef solve_structured_case(params):\n    \"\"\"\n    Solves a single structured grid case.\n    \"\"\"\n    nx, ny, a, b, omega, epsilon, n_max = params\n    x_coords, y_coords = generate_grid(nx, ny, a, b)\n    \n    min_j_initial, has_neg_area_initial = calculate_metrics(x_coords, y_coords)\n\n    if min_j_initial = epsilon and not has_neg_area_initial:\n        iterations = 0\n    else:\n        iterations = smooth_grid(x_coords, y_coords, omega, epsilon, n_max)\n\n    return min_j_initial, has_neg_area_initial, iterations\n\ndef calculate_tetra_volume(v1, v2, v3, v4):\n    \"\"\"\n    Calculates the oriented volume of a tetrahedron.\n    \"\"\"\n    v1, v2, v3, v4 = np.array(v1), np.array(v2), np.array(v3), np.array(v4)\n    \n    e1 = v2 - v1\n    e2 = v3 - v1\n    e3 = v4 - v1\n    \n    scalar_triple_product = np.dot(e1, np.cross(e2, e3))\n    \n    volume = scalar_triple_product / 6.0\n    is_negative = volume  0\n    \n    return volume, is_negative\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Structured grid cases\n    nx, ny = 33, 33\n    omega = 0.5\n    epsilon = 0.05\n    n_max = 25\n    \n    structured_cases = [\n        # S1: (a,b)=(0.05,0.02)\n        (nx, ny, 0.05, 0.02, omega, epsilon, n_max),\n        # S2: (a,b)=(0.20,0.00)\n        (nx, ny, 0.20, 0.00, omega, epsilon, n_max),\n        # S3: (a,b)=(0.159,0.00)\n        (nx, ny, 0.159, 0.00, omega, epsilon, n_max),\n    ]\n\n    # Unstructured tetrahedral cases\n    unstructured_cases = [\n        # T1\n        {'v1':(0,0,0), 'v2':(1,0,0), 'v3':(0,1,0), 'v4':(0,0,1)},\n        # T2\n        {'v1':(0,0,0), 'v2':(0,1,0), 'v3':(1,0,0), 'v4':(0,0,1)},\n    ]\n\n    results = []\n    \n    # Process structured cases\n    for params in structured_cases:\n        j_min, neg_area, iters = solve_structured_case(params)\n        results.extend([j_min, neg_area, iters])\n\n    # Process unstructured cases\n    for case in unstructured_cases:\n        vol, is_neg = calculate_tetra_volume(**case)\n        results.extend([vol, is_neg])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Even a valid grid can yield inaccurate results if it has poor geometric quality, especially near physical boundaries. Calculating the drag on a surface requires an accurate wall shear stress, which is highly sensitive to the orthogonality of the grid at the wall. This exercise demonstrates analytically how a lack of orthogonality introduces a specific, quantifiable error into this crucial calculation, corrupting it with tangential velocity gradients .",
            "id": "3327938",
            "problem": "Consider a two-dimensional incompressible Newtonian fluid in a near-wall region discretized using boundary-fitted coordinates on a hybrid mesh that is structured in the wall-parallel direction and unstructured in the wall-normal direction. In Computational Fluid Dynamics (CFD), consistent wall-normal diffusive flux evaluation is critical for accurate viscous stress computation. In a perfectly boundary-orthogonal grid, the computational coordinate lines coincide with the physical tangent and normal directions to the wall. In non-orthogonal grids, the face-normal direction of near-wall control volumes can be misaligned with the true physical normal direction, which introduces cross-diffusion contributions to wall-normal fluxes.\n\nStarting from the Newtonian viscous stress law for a fluid with dynamic viscosity $\\mu$, namely $$\\boldsymbol{\\tau}=\\mu\\left(\\nabla \\boldsymbol{u}+(\\nabla \\boldsymbol{u})^{\\top}\\right)$$, and the geometric definition of directional derivatives as projections of $\\nabla(\\cdot)$ onto unit directions, derive the leading-order expression for the error in the wall shear stress when the wall-normal derivative of the tangential velocity is approximated by the derivative along a computational face normal that is misaligned by an angle $\\theta$ with respect to the true physical normal. Assume a local orthonormal frame at the wall defined by the tangent direction $\\boldsymbol{t}$ and the normal direction $\\boldsymbol{n}$, and let the computational face-normal unit vector $\\boldsymbol{\\hat{n}}$ be obtained by rotating $\\boldsymbol{n}$ toward $\\boldsymbol{t}$ by an angle $\\theta$ in the wall plane. Work under the physically standard no-slip boundary condition and smoothness of the velocity field near the wall.\n\nThen, for a specific case with dynamic viscosity $\\mu=1.8\\times 10^{-5}\\ \\text{kg}\\ \\text{m}^{-1}\\ \\text{s}^{-1}$, a true wall-normal gradient of the tangential velocity $\\partial u_{t}/\\partial n = 500\\ \\text{s}^{-1}$, a tangential derivative $\\partial u_{t}/\\partial s = 4000\\ \\text{s}^{-1}$, and a misalignment angle $\\theta=5^{\\circ}$, compute the absolute error in the wall shear stress induced by using the computational face-normal derivative in place of the true wall-normal derivative. Use radian measure for all trigonometric functions, and round your final numerical answer to four significant figures. Express the final answer in Pascal (Pa).",
            "solution": "The problem asks for two results: first, to derive the leading-order expression for the error in wall shear stress due to grid non-orthogonality, and second, to compute the absolute value of this error for a specific case.\n\n### Part 1: Derivation of the Error Expression\n\nThe viscous stress tensor $\\boldsymbol{\\tau}$ for an incompressible Newtonian fluid with dynamic viscosity $\\mu$ is given by:\n$$ \\boldsymbol{\\tau} = \\mu \\left( \\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^{\\top} \\right) $$\nwhere $\\boldsymbol{u}$ is the velocity vector.\n\nThe wall shear stress, $\\tau_w$, is the tangential component of the viscous force per unit area exerted by the fluid on the wall. This is the tangential component of the traction vector $\\boldsymbol{\\tau} \\cdot \\boldsymbol{n}$ evaluated at the wall, where $\\boldsymbol{n}$ is the unit normal vector to the wall, pointing into the fluid.\n$$ \\tau_w = (\\boldsymbol{\\tau} \\cdot \\boldsymbol{n}) \\cdot \\boldsymbol{t} \\big|_{\\text{wall}} $$\nwhere $\\boldsymbol{t}$ is the unit tangent vector to the wall.\n\nLet's establish a local 2D Cartesian coordinate system where the wall is the line $y=0$. The tangential direction corresponds to the $x$-axis ($\\boldsymbol{t}$) and the normal direction corresponds to the $y$-axis ($\\boldsymbol{n}$). The velocity vector is $\\boldsymbol{u} = u_t \\boldsymbol{t} + u_n \\boldsymbol{n}$. The coordinates are $s$ along $\\boldsymbol{t}$ and $n$ along $\\boldsymbol{n}$. So, $\\partial/\\partial s$ is the derivative along $\\boldsymbol{t}$ and $\\partial/\\partial n$ is the derivative along $\\boldsymbol{n}$.\n\nIn this frame, the velocity gradient tensor is:\n$$ \\nabla \\boldsymbol{u} = \\begin{pmatrix} \\frac{\\partial u_t}{\\partial s}  \\frac{\\partial u_t}{\\partial n} \\\\ \\frac{\\partial u_n}{\\partial s}  \\frac{\\partial u_n}{\\partial n} \\end{pmatrix} $$\nThe stress tensor components are:\n$$ \\boldsymbol{\\tau} = \\mu \\begin{pmatrix} 2\\frac{\\partial u_t}{\\partial s}  \\frac{\\partial u_t}{\\partial n} + \\frac{\\partial u_n}{\\partial s} \\\\ \\frac{\\partial u_t}{\\partial n} + \\frac{\\partial u_n}{\\partial s}  2\\frac{\\partial u_n}{\\partial n} \\end{pmatrix} $$\nThe traction vector on the wall is $\\boldsymbol{\\tau} \\cdot \\boldsymbol{n}$, which gives:\n$$ \\boldsymbol{\\tau} \\cdot \\boldsymbol{n} = \\mu \\begin{pmatrix} \\frac{\\partial u_t}{\\partial n} + \\frac{\\partial u_n}{\\partial s} \\\\ 2\\frac{\\partial u_n}{\\partial n} \\end{pmatrix} $$\nThe true wall shear stress $\\tau_{w, \\text{true}}$ is the tangential component of this vector:\n$$ \\tau_{w, \\text{true}} = \\mu \\left( \\frac{\\partial u_t}{\\partial n} + \\frac{\\partial u_n}{\\partial s} \\right) \\bigg|_{\\text{wall}} $$\nThe no-slip boundary condition states that $\\boldsymbol{u} = \\boldsymbol{0}$ at all points on the wall. This implies that gradients along the wall of velocity components are zero, i.e., $\\frac{\\partial u_t}{\\partial s} = 0$ and $\\frac{\\partial u_n}{\\partial s} = 0$ at the wall. The incompressibility condition, $\\nabla \\cdot \\boldsymbol{u} = \\frac{\\partial u_t}{\\partial s} + \\frac{\\partial u_n}{\\partial n} = 0$, combined with $\\frac{\\partial u_t}{\\partial s}=0$ at the wall, implies $\\frac{\\partial u_n}{\\partial n}=0$ at the wall.\nApplying these conditions, the expression for the true wall shear stress simplifies to:\n$$ \\tau_{w, \\text{true}} = \\mu \\frac{\\partial u_t}{\\partial n} \\bigg|_{\\text{wall}} $$\nThis is the physically exact wall shear stress. Note that while $\\frac{\\partial u_t}{\\partial s}|_{\\text{wall}}$ is zero, the problem provides a non-zero value for it. This implies that the derivative is evaluated not exactly *at* the wall, but at a very small distance from it, where the CFD approximation is computed. We will proceed under this standard interpretation in CFD, where gradients are evaluated at cell centers or faces near the wall.\n\nThe problem states that the wall-normal derivative is approximated using the derivative along a misaligned computational face-normal unit vector $\\boldsymbol{\\hat{n}}$. The approximated wall shear stress, $\\tau_{w, \\text{approx}}$, is:\n$$ \\tau_{w, \\text{approx}} = \\mu \\frac{D u_t}{D \\hat{n}} $$\nwhere $\\frac{D u_t}{D \\hat{n}}$ is the directional derivative of $u_t$ in the direction of $\\boldsymbol{\\hat{n}}$. This is defined as $\\nabla u_t \\cdot \\boldsymbol{\\hat{n}}$.\nThe gradient of the scalar field $u_t$ is:\n$$ \\nabla u_t = \\frac{\\partial u_t}{\\partial s} \\boldsymbol{t} + \\frac{\\partial u_t}{\\partial n} \\boldsymbol{n} $$\nThe vector $\\boldsymbol{\\hat{n}}$ is formed by rotating $\\boldsymbol{n}$ towards $\\boldsymbol{t}$ by an angle $\\theta$. In the $\\{\\boldsymbol{t}, \\boldsymbol{n}\\}$ basis, this gives:\n$$ \\boldsymbol{\\hat{n}} = \\sin\\theta \\, \\boldsymbol{t} + \\cos\\theta \\, \\boldsymbol{n} $$\nNow, we compute the directional derivative:\n$$ \\frac{D u_t}{D \\hat{n}} = \\left( \\frac{\\partial u_t}{\\partial s} \\boldsymbol{t} + \\frac{\\partial u_t}{\\partial n} \\boldsymbol{n} \\right) \\cdot (\\sin\\theta \\, \\boldsymbol{t} + \\cos\\theta \\, \\boldsymbol{n}) $$\nUsing the orthonormality of the basis vectors ($\\boldsymbol{t} \\cdot \\boldsymbol{t} = 1$, $\\boldsymbol{n} \\cdot \\boldsymbol{n} = 1$, $\\boldsymbol{t} \\cdot \\boldsymbol{n} = 0$):\n$$ \\frac{D u_t}{D \\hat{n}} = \\frac{\\partial u_t}{\\partial s} \\sin\\theta + \\frac{\\partial u_t}{\\partial n} \\cos\\theta $$\nThe approximated wall shear stress is therefore:\n$$ \\tau_{w, \\text{approx}} = \\mu \\left( \\frac{\\partial u_t}{\\partial s} \\sin\\theta + \\frac{\\partial u_t}{\\partial n} \\cos\\theta \\right) $$\nThe error, $\\Delta \\tau_w$, is the difference between the approximated and true values:\n$$ \\Delta \\tau_w = \\tau_{w, \\text{approx}} - \\tau_{w, \\text{true}} = \\mu \\left( \\frac{\\partial u_t}{\\partial s} \\sin\\theta + \\frac{\\partial u_t}{\\partial n} \\cos\\theta \\right) - \\mu \\frac{\\partial u_t}{\\partial n} $$\n$$ \\Delta \\tau_w = \\mu \\left( \\frac{\\partial u_t}{\\partial s} \\sin\\theta + \\frac{\\partial u_t}{\\partial n} (\\cos\\theta - 1) \\right) $$\nTo find the leading-order expression for the error, we use Taylor series expansions for $\\sin\\theta$ and $\\cos\\theta$ for small $\\theta$ (in radians):\n$$ \\sin\\theta = \\theta - \\frac{\\theta^3}{6} + \\mathcal{O}(\\theta^5) $$\n$$ \\cos\\theta = 1 - \\frac{\\theta^2}{2} + \\frac{\\theta^4}{24} + \\mathcal{O}(\\theta^6) \\implies \\cos\\theta - 1 = -\\frac{\\theta^2}{2} + \\mathcal{O}(\\theta^4) $$\nSubstituting these into the error expression:\n$$ \\Delta \\tau_w = \\mu \\left( \\frac{\\partial u_t}{\\partial s} \\left(\\theta - \\mathcal{O}(\\theta^3)\\right) + \\frac{\\partial u_t}{\\partial n} \\left(-\\frac{\\theta^2}{2} + \\mathcal{O}(\\theta^4)\\right) \\right) $$\n$$ \\Delta \\tau_w = \\mu \\theta \\frac{\\partial u_t}{\\partial s} - \\mu \\frac{\\theta^2}{2} \\frac{\\partial u_t}{\\partial n} + \\mathcal{O}(\\theta^3) $$\nThe leading-order term is the term with the lowest power of $\\theta$, which is the first term. Thus, the leading-order expression for the error is:\n$$ \\Delta \\tau_{w, \\text{LO}} = \\mu \\theta \\frac{\\partial u_t}{\\partial s} $$\n\n### Part 2: Numerical Computation of the Absolute Error\n\nWe are asked to compute the absolute error $|\\Delta \\tau_w|$ for the given case. We shall use the full error expression derived above for accuracy.\n$$ |\\Delta \\tau_w| = \\left| \\mu \\left( \\frac{\\partial u_t}{\\partial s} \\sin\\theta + \\frac{\\partial u_t}{\\partial n} (\\cos\\theta - 1) \\right) \\right| $$\nThe given values are:\n- Dynamic viscosity, $\\mu = 1.8 \\times 10^{-5}\\ \\text{kg}\\ \\text{m}^{-1}\\ \\text{s}^{-1}$.\n- True wall-normal gradient of tangential velocity, $\\frac{\\partial u_t}{\\partial n} = 500\\ \\text{s}^{-1}$.\n- Tangential derivative of tangential velocity, $\\frac{\\partial u_t}{\\partial s} = 4000\\ \\text{s}^{-1}$.\n- Misalignment angle, $\\theta = 5^{\\circ}$.\n\nFirst, we must convert the angle $\\theta$ to radians, as required for the trigonometric functions:\n$$ \\theta_{\\text{rad}} = 5^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} = \\frac{\\pi}{36}\\ \\text{rad} $$\nNow, we substitute the values into the error expression:\n$$ \\Delta \\tau_w = (1.8 \\times 10^{-5}) \\left( (4000) \\sin\\left(\\frac{\\pi}{36}\\right) + (500) \\left(\\cos\\left(\\frac{\\pi}{36}\\right) - 1\\right) \\right) $$\nLet's evaluate the terms:\n$$ \\sin\\left(\\frac{\\pi}{36}\\right) \\approx 0.08715574 $$\n$$ \\cos\\left(\\frac{\\pi}{36}\\right) \\approx 0.99619470 $$\n$$ \\cos\\left(\\frac{\\pi}{36}\\right) - 1 \\approx -0.00380530 $$\nPlugging these into the expression:\n$$ \\Delta \\tau_w \\approx (1.8 \\times 10^{-5}) \\left( (4000)(0.08715574) + (500)(-0.00380530) \\right) $$\n$$ \\Delta \\tau_w \\approx (1.8 \\times 10^{-5}) \\left( 348.62296 - 1.90265 \\right) $$\n$$ \\Delta \\tau_w \\approx (1.8 \\times 10^{-5}) (346.72031) $$\n$$ \\Delta \\tau_w \\approx 0.00624096558\\ \\text{Pa} $$\nThe problem asks for the absolute error, which is $|\\Delta \\tau_w|$. Since the result is positive, the absolute error is the same value.\n$$ |\\Delta \\tau_w| \\approx 0.00624096558\\ \\text{Pa} $$\nFinally, we round the answer to four significant figures:\n$$ |\\Delta \\tau_w| \\approx 0.006241\\ \\text{Pa} $$\nIn standard scientific notation, this is $6.241 \\times 10^{-3}\\ \\text{Pa}$.",
            "answer": "$$\\boxed{6.241 \\times 10^{-3}}$$"
        },
        {
            "introduction": "A sophisticated numerical scheme must not introduce non-physical artifacts; it must be consistent with the underlying physics even on highly distorted grids. This practice explores this principle through the Geometric Conservation Law (GCL), a cornerstone of high-fidelity solvers . You will set up a test with a simple rotating flow and discover how inconsistent discrete metric calculations can generate spurious vorticity, providing a powerful lesson in the subtleties of discretization on curvilinear coordinates.",
            "id": "3327956",
            "problem": "You are given a boundary-fitted, two-dimensional, structured curvilinear mesh mapping from computational coordinates $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ to physical space $(x,y)\\in\\mathbb{R}^2$, defined by $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$, and a solid-body rotation field with tangential velocity $u_\\theta(\\boldsymbol{x})=\\Omega r$, where $r=\\sqrt{x^2+y^2}$ and $\\Omega$ is a constant angular velocity. In Cartesian components, the velocity is $(u,v)=(-\\Omega y,\\Omega x)$. For solid-body rotation, the physical vorticity (the curl of velocity in two dimensions), defined by $\\omega=\\partial v/\\partial x - \\partial u/\\partial y$, is a spatial constant $\\omega=2\\Omega$. On a curvilinear mesh, a discrete evaluation of $\\omega$ should respect the geometric metric identities; otherwise, it can produce spurious vorticity.\n\nStarting from the fundamental definition of vorticity $\\omega=\\partial v/\\partial x - \\partial u/\\partial y$ and the definition of a smooth mapping $\\boldsymbol{r}(\\xi,\\eta)=(x(\\xi,\\eta),y(\\xi,\\eta))$, define the tangent vectors $\\boldsymbol{t}^\\xi=\\partial\\boldsymbol{r}/\\partial\\xi=(x_\\xi,y_\\xi)$ and $\\boldsymbol{t}^\\eta=\\partial\\boldsymbol{r}/\\partial\\eta=(x_\\eta,y_\\eta)$, and the Jacobian $J=x_\\xi y_\\eta - x_\\eta y_\\xi$. Use the chain rule to derive the conservative form of the vorticity,\n$$\n\\omega = \\frac{1}{J}\\left( \\frac{\\partial}{\\partial \\xi}\\left(u\\,x_\\eta + v\\,y_\\eta\\right) - \\frac{\\partial}{\\partial \\eta}\\left(u\\,x_\\xi + v\\,y_\\xi\\right)\\right),\n$$\nand construct a discrete operator that approximates the derivatives in $\\xi$ and $\\eta$ by second-order centered differences on a structured grid. The metric identities are the equalities of mixed partial derivatives (e.g., $x_{\\xi\\eta}=x_{\\eta\\xi}$ and $y_{\\xi\\eta}=y_{\\eta\\xi}$). When these are violated by inconsistent discrete approximations of the metrics $(x_\\xi,x_\\eta,y_\\xi,y_\\eta)$, spurious vorticity arises even for the uniform rotation field.\n\nImplement the following boundary-fitted mapping of an annulus with inner radius $r_0$ and outer radius $r_1$:\n- Let $\\theta(\\xi,\\eta)=2\\pi \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta)$,\n- Let $r(\\eta)=r_0 + (r_1-r_0)\\eta + \\beta \\sin(2\\pi \\eta)$,\n- Let $x(\\xi,\\eta)=r(\\eta)\\cos(\\theta(\\xi,\\eta))$ and $y(\\xi,\\eta)=r(\\eta)\\sin(\\theta(\\xi,\\eta))$,\nwhere $\\alpha=0.2 a$ and $\\beta=0.1 a$, and $a\\ge 0$ is a warp amplitude parameter controlling mesh curvature.\n\nDefine a diagnostic that quantifies spurious vorticity as the relative deviation of the discrete vorticity from the exact value $2\\Omega$:\n$$\nD=\\max_{i,j}\\left|\\frac{\\omega_{i,j}}{2\\Omega}-1\\right|,\n$$\nwhere $\\omega_{i,j}$ is the discrete vorticity evaluated at interior nodes $(i,j)$. The detection boolean for spurious vorticity is\n$$\nB=\\begin{cases}\n\\text{True},  D\\tau,\\\\\n\\text{False},  D\\le \\tau,\n\\end{cases}\n$$\nwith a prescribed threshold $\\tau=0.05$ (dimensionless). The diagnostic $D$ is dimensionless; the angular velocity $\\Omega$ is given in $\\text{s}^{-1}$, but the required output is the dimensionless diagnostic and the corresponding boolean flag, so no physical units need to be printed.\n\nYour program must:\n- Construct the mesh for given $(N_\\xi,N_\\eta,a)$,\n- Evaluate $(u,v)$ from $(x,y)$ for a given $\\Omega$,\n- Compute the discrete vorticity $\\omega$ using the conservative curl form above with:\n    1. Analytical metrics $(x_\\xi,x_\\eta,y_\\xi,y_\\eta)$ from the mapping formulas,\n    2. Consistent discrete metrics from second-order centered differences of $(x,y)$,\n    3. Inconsistent discrete metrics that violate the metric identities by mixing forward and backward stencils for different components,\n- Compute $D$ and $B$ for each case.\n\nTest Suite:\nUse $\\Omega=1.0\\,\\text{s}^{-1}$, $r_0=1.0\\,\\text{m}$, $r_1=2.0\\,\\text{m}$, and the threshold $\\tau=0.05$. Evaluate the following five test cases:\n1. $(N_\\xi,N_\\eta,a,\\text{metric})=(64,32,0.10,\\text{analytic})$.\n2. $(N_\\xi,N_\\eta,a,\\text{metric})=(64,32,0.10,\\text{central})$.\n3. $(N_\\xi,N_\\eta,a,\\text{metric})=(64,32,0.10,\\text{broken})$.\n4. $(N_\\xi,N_\\eta,a,\\text{metric})=(64,32,0.30,\\text{broken})$.\n5. $(N_\\xi,N_\\eta,a,\\text{metric})=$(16,8,0.10,$\\text{central}$).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[D_1,B_1,D_2,B_2,D_3,B_3,D_4,B_4,D_5,B_5]$. Each $D_k$ must be a decimal number (dimensionless), and each $B_k$ must be a boolean value. For example, an acceptable output looks like `[0.0012,False,0.0034,False,0.1523,True,0.3011,True,0.0221,False]`.",
            "solution": "The user has provided a problem that is scientifically sound, well-posed, and complete. All necessary data, equations, and test conditions are specified, and the problem adheres to established principles in computational fluid dynamics (CFD). The problem is valid and can be solved as stated.\n\nThe problem requires the derivation of the conservative form of vorticity in a transformed coordinate system, followed by a numerical implementation to diagnose spurious vorticity generated by inconsistent discrete approximations of geometric metric terms.\n\n**1. Theoretical Foundation**\n\nThe vorticity $\\omega$ in two-dimensional Cartesian coordinates $(x,y)$ for a velocity field $\\boldsymbol{u}=(u,v)$ is defined as the curl of the velocity field:\n$$\n\\omega = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}\n$$\nWe are given a smooth, invertible mapping from computational coordinates $(\\xi,\\eta)$ to physical coordinates $(x,y)$, defined by $x=x(\\xi,\\eta)$ and $y=y(\\xi,\\eta)$. The chain rule allows us to transform the partial derivative operators. The relationships between the partial derivatives are:\n$$\n\\frac{\\partial}{\\partial x} = \\frac{\\partial \\xi}{\\partial x}\\frac{\\partial}{\\partial \\xi} + \\frac{\\partial \\eta}{\\partial x}\\frac{\\partial}{\\partial \\eta}\n$$\n$$\n\\frac{\\partial}{\\partial y} = \\frac{\\partial \\xi}{\\partial y}\\frac{\\partial}{\\partial \\xi} + \\frac{\\partial \\eta}{\\partial y}\\frac{\\partial}{\\partial \\eta}\n$$\nThe derivatives of the inverse transformation $(\\xi_x, \\xi_y, \\eta_x, \\eta_y)$ can be expressed in terms of the derivatives of the forward transformation $(x_\\xi, x_\\eta, y_\\xi, y_\\eta)$ using the inverse of the Jacobian matrix of the transformation:\n$$\n\\begin{pmatrix} \\xi_x  \\xi_y \\\\ \\eta_x  \\eta_y \\end{pmatrix} = \\begin{pmatrix} x_\\xi  y_\\xi \\\\ x_\\eta  y_\\eta \\end{pmatrix}^{-1} = \\frac{1}{J} \\begin{pmatrix} y_\\eta  -y_\\xi \\\\ -x_\\eta  x_\\xi \\end{pmatrix}\n$$\nwhere $J = x_\\xi y_\\eta - x_\\eta y_\\xi$ is the Jacobian determinant of the transformation.\n\nSubstituting these into the definition of vorticity yields:\n$$\n\\omega = \\left( \\frac{\\partial \\xi}{\\partial x}\\frac{\\partial v}{\\partial \\xi} + \\frac{\\partial \\eta}{\\partial x}\\frac{\\partial v}{\\partial \\eta} \\right) - \\left( \\frac{\\partial \\xi}{\\partial y}\\frac{\\partial u}{\\partial \\xi} + \\frac{\\partial \\eta}{\\partial y}\\frac{\\partial u}{\\partial \\eta} \\right)\n$$\n$$\nJ\\omega = \\left( y_\\eta v_\\xi - x_\\eta v_\\eta \\right) - \\left( -y_\\xi u_\\xi + x_\\xi u_\\eta \\right)\n$$\n$$\nJ\\omega = (y_\\eta v_\\xi + y_\\xi u_\\xi) - (x_\\eta v_\\eta + x_\\xi u_\\eta)\n$$\nThis is a non-conservative form of the vorticity equation. The problem asks for the derivation of the conservative form:\n$$\n\\omega = \\frac{1}{J}\\left( \\frac{\\partial}{\\partial \\xi}\\left(u\\,x_\\eta + v\\,y_\\eta\\right) - \\frac{\\partial}{\\partial \\eta}\\left(u\\,x_\\xi + v\\,y_\\xi\\right)\\right)\n$$\nTo show their equivalence, we expand the right-hand side using the product rule:\n$$\nJ\\omega = \\left( u_\\xi x_\\eta + u x_{\\eta\\xi} + v_\\xi y_\\eta + v y_{\\eta\\xi} \\right) - \\left( u_\\eta x_\\xi + u x_{\\xi\\eta} + v_\\eta y_\\xi + v y_{\\xi\\eta} \\right)\n$$\n$$\nJ\\omega = (u_\\xi x_\\eta + v_\\xi y_\\eta) - (u_\\eta x_\\xi + v_\\eta y_\\xi) + u(x_{\\eta\\xi} - x_{\\xi\\eta}) + v(y_{\\eta\\xi} - y_{\\xi\\eta})\n$$\nIf the coordinate mapping is sufficiently smooth (twice continuously differentiable), then by the equality of mixed partials (Clairaut's theorem), we have $x_{\\xi\\eta} = x_{\\eta\\xi}$ and $y_{\\xi\\eta} = y_{\\eta\\xi}$. These are referred to as the geometric metric identities. Under this condition, the last two terms vanish, and the equation reduces to a form equivalent to the non-conservative one derived earlier.\n\nThe crucial insight is that while this identity holds analytically, its discrete approximation may not. The term $u(D_\\xi D_\\eta x - D_\\eta D_\\xi x) + v(D_\\xi D_\\eta y - D_\\eta D_\\xi y)$, where $D$ represents a discrete difference operator, may be non-zero if the discrete operators for the metrics are chosen inconsistently. This non-zero term creates spurious, non-physical vorticity. The solid-body rotation field, with its spatially constant physical vorticity $\\omega = 2\\Omega$, is a classic test case for this \"free-stream preservation\" property. A numerical scheme should be able to exactly preserve this constant state, and any deviation signals a flaw in the discretization, specifically in satisfying the discrete geometric conservation law.\n\n**2. Numerical Implementation Strategy**\n\nThe core of the task is to compute the discrete vorticity $\\omega_{i,j}$ at interior grid nodes for three different methods of calculating the metric terms $(x_\\xi, x_\\eta, y_\\xi, y_\\eta)$.\n\n**Grid and Coordinates**: A uniform structured grid is defined in the computational domain $[0,1]\\times[0,1]$ with $(N_\\xi, N_\\eta)$ points. The grid spacings are $\\Delta\\xi = 1/(N_\\xi-1)$ and $\\Delta\\eta = 1/(N_\\eta-1)$. The physical coordinates $(x,y)$ are computed at each grid point using the provided mapping formulas.\n\n**Velocity Field**: The velocity components $(u, v) = (-\\Omega y, \\Omega x)$ are evaluated at each grid point.\n\n**Metric Term Calculation**:\n1.  **Analytic**: The partial derivatives $(x_\\xi, y_\\xi, x_\\eta, y_\\eta)$ are derived analytically from the mapping equations and evaluated at each grid point. This method perfectly satisfies the metric identities.\n2.  **Consistent (Central)**: The metric terms are approximated using second-order central differences on the $(x,y)$ grid. The `numpy.gradient` function is suitable as it uses central differences for interior points and second-order one-sided differences at boundaries, ensuring consistency. Discrete central difference operators on a uniform grid commute, so the discrete metric identities are satisfied up to machine precision.\n3.  **Inconsistent (Broken)**: To deliberately violate the metric identities, we use different finite difference stencils for different components. For instance, we compute $x$-derivatives ($x_\\xi, x_\\eta$) using forward differences and $y$-derivatives ($y_\\xi, y_\\eta$) using backward differences. This inconsistency leads to $D_\\xi D_\\eta x \\neq D_\\eta D_\\xi x$ (and for $y$), generating spurious vorticity.\n\n**Vorticity Calculation**:\nGiven the metrics, we form the quantities $F_\\xi = u x_\\eta + v y_\\eta$ and $F_\\eta = u x_\\xi + v y_\\xi$ at all grid points. The vorticity at interior nodes $(i,j)$ for $i \\in [1, N_\\xi-2], j \\in [1, N_\\eta-2]$ is then computed using second-order central differences on $F_\\xi$ and $F_\\eta$:\n$$\n\\omega_{i,j} = \\frac{1}{J_{i,j}} \\left( \\frac{(F_\\xi)_{i+1,j} - (F_\\xi)_{i-1,j}}{2\\Delta\\xi} - \\frac{(F_\\eta)_{i,j+1} - (F_\\eta)_{i,j-1}}{2\\Delta\\eta} \\right)\n$$\nThe Jacobian $J_{i,j}$ is also evaluated at the interior nodes using the computed metrics.\n\n**Diagnostic Calculation**:\nThe relative deviation $D = \\max_{i,j} \\left| \\omega_{i,j}/(2\\Omega) - 1 \\right|$ is computed over all interior nodes. The boolean flag $B$ is set to true if $D > \\tau$.\n\nThe implementation will process each of the five test cases, calculating and storing the pair $(D, B)$ for each.",
            "answer": "```python\nimport numpy as np\n\ndef run_case(N_xi, N_eta, a, metric_type, r0, r1, Omega, tau):\n    \"\"\"\n    Computes spurious vorticity for a single test case.\n    \"\"\"\n    # 1. Construct the computational grid\n    xi_1d = np.linspace(0, 1, N_xi)\n    eta_1d = np.linspace(0, 1, N_eta)\n    dxi = 1.0 / (N_xi - 1)\n    deta = 1.0 / (N_eta - 1)\n    XI_m, ETA_m = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n    # Parameters for the mapping\n    alpha = 0.2 * a\n    beta = 0.1 * a\n    PI2 = 2.0 * np.pi\n\n    # 2. Compute physical coordinates and analytical metrics if needed\n    theta = PI2 * XI_m + alpha * np.sin(PI2 * XI_m) * np.sin(PI2 * ETA_m)\n    r = r0 + (r1 - r0) * ETA_m + beta * np.sin(PI2 * ETA_m)\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n\n    # 3. Evaluate metric terms based on metric_type\n    if metric_type == 'analytic':\n        theta_xi = PI2 * (1.0 + alpha * np.cos(PI2 * XI_m) * np.sin(PI2 * ETA_m))\n        theta_eta = PI2 * alpha * np.sin(PI2 * XI_m) * np.cos(PI2 * ETA_m)\n        r_eta = (r1 - r0) + PI2 * beta * np.cos(PI2 * ETA_m)\n        \n        x_xi = -y * theta_xi\n        y_xi = x * theta_xi\n        x_eta = r_eta * np.cos(theta) - y * theta_eta\n        y_eta = r_eta * np.sin(theta) + x * theta_eta\n\n    elif metric_type == 'central':\n        y_xi, y_eta = np.gradient(y, dxi, deta, axis=(0, 1))\n        x_xi, x_eta = np.gradient(x, dxi, deta, axis=(0, 1))\n\n    elif metric_type == 'broken':\n        # Using mixed forward/backward differences to break consistency\n        x_xi = np.zeros_like(x)\n        x_xi[:-1, :] = (x[1:, :] - x[:-1, :]) / dxi # Forward diff\n        x_xi[-1, :] = (x[-1, :] - x[-2, :]) / dxi\n        \n        y_xi = np.zeros_like(y)\n        y_xi[1:, :] = (y[1:, :] - y[:-1, :]) / dxi  # Also forward, but let's mix eta\n        y_xi[0, :] = (y[1, :] - y[0, :]) / dxi\n\n        x_eta = np.zeros_like(x)\n        x_eta[:, :-1] = (x[:, 1:] - x[:, :-1]) / deta # Forward diff\n        x_eta[:, -1] = (x[:, -1] - x[:, -2]) / deta\n\n        y_eta = np.zeros_like(y)\n        y_eta[:, 1:] = (y[:, 1:] - y[:, :-2]) / (2 * deta) # Central diff for y_eta\n        y_eta[:, 0] = (y[:, 1] - y[:, 0]) / deta # Forward at boundary\n        y_eta[:, -1] = (y[:, -1] - y[:, -2]) / deta # Backward at boundary\n\n    else:\n        raise ValueError(\"Unknown metric type\")\n\n    # 4. Evaluate velocity field\n    u = -Omega * y\n    v = Omega * x\n\n    # 5. Compute conservative flux-like terms\n    F_xi = u * x_eta + v * y_eta\n    F_eta = u * x_xi + v * y_xi\n\n    # 6. Compute vorticity on interior nodes\n    # Slice to get interior points for the final result\n    # We need a 3-point stencil, so we compute derivatives for [1:-1]\n    dFxi_dxi = (F_xi[2:, 1:-1] - F_xi[:-2, 1:-1]) / (2.0 * dxi)\n    dFeta_deta = (F_eta[1:-1, 2:] - F_eta[1:-1, :-2]) / (2.0 * deta)\n    \n    # Jacobian on interior nodes\n    J_interior = (x_xi * y_eta - x_eta * y_xi)[1:-1, 1:-1]\n    \n    # Avoid division by zero, although J should be > 0 for a valid mesh\n    J_interior[np.abs(J_interior)  1e-16] = 1e-16\n\n    omega_discrete = (1.0 / J_interior) * (dFxi_dxi - dFeta_deta)\n\n    # 7. Compute diagnostics\n    omega_exact = 2.0 * Omega\n    D = np.max(np.abs(omega_discrete / omega_exact - 1.0))\n    B = D > tau\n\n    return D, B\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    # Define test cases from the problem statement.\n    test_cases = [\n        (64, 32, 0.10, 'analytic'),\n        (64, 32, 0.10, 'central'),\n        (64, 32, 0.10, 'broken'),\n        (64, 32, 0.30, 'broken'),\n        (16, 8, 0.10, 'central'),\n    ]\n\n    # Global parameters\n    Omega = 1.0  # s^-1\n    r0 = 1.0     # m\n    r1 = 2.0     # m\n    tau = 0.05   # dimensionless threshold\n\n    results = []\n    for case in test_cases:\n        N_xi, N_eta, a, metric_type = case\n        try:\n            D, B = run_case(N_xi, N_eta, a, metric_type, r0, r1, Omega, tau)\n        except Exception as e:\n            # Fallback in case of unexpected numerical errors, unlikely but safe\n            D, B = np.nan, True\n        results.append(D)\n        results.append(B)\n    \n    # Format the final output string exactly as required\n    formatted_results = []\n    for item in results:\n        if isinstance(item, (bool, np.bool_)):\n            formatted_results.append(str(item))\n        else: # float\n            formatted_results.append(f\"{item:.12f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}