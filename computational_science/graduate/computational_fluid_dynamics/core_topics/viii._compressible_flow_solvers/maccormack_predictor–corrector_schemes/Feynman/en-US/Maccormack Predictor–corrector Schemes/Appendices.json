{
    "hands_on_practices": [
        {
            "introduction": "While many introductory examples use constant coefficients, real-world fluid dynamics problems often involve spatially varying properties. This exercise is a crucial step in moving from idealized models to more realistic physics, focusing on the linear advection equation with a variable coefficient, $u_{t} + (a(x) u)_{x} = 0$. You will discover through analysis that a naive discretization of the non-conservative form of the equation leads to a loss of accuracy, and you will then construct a 'coefficient-aware' scheme that correctly respects the underlying conservation law, a key principle for building robust numerical methods.",
            "id": "3342575",
            "problem": "Consider the linear advection of a scalar field with a spatially varying transport coefficient described by the conservation law $u_{t} + (a(x) u)_{x} = 0$, where $a(x)$ is a smooth, time-independent function and $u(x,t)$ is sufficiently smooth. Let the spatial domain be discretized on a uniform grid with nodes $x_{i} = x_{0} + i \\,\\Delta x$, and let time be discretized with $t_{n} = t_{0} + n \\,\\Delta t$. Define the Courant ratio $\\lambda = \\Delta t / \\Delta x$. Assume periodic boundary conditions and focus on a generic interior node $x_{i}$.\n\nStart from the partial differential equation given above and the definitions of forward and backward discrete differences. Analyze the local truncation error at $x_{i}$ of a “naive” MacCormack predictor–corrector that discretizes the nonconservative form $u_{t} + a(x) u_{x} = 0$ by using $a_{i} = a(x_{i})$ in both predictor and corrector steps to multiply one-sided discrete differences of $u$. Derive, by Taylor expansion about $x_{i}$ and $t_{n}$ and using the conservation law $u_{t} = - (a u)_{x}$, the leading-order nonvanishing term in the local truncation error that arises due to the neglected coefficient gradient. Explain the loss of second-order accuracy caused by this term.\n\nThen, construct a coefficient-aware MacCormack predictor–corrector formulated in conservative form, using cell-centered discrete fluxes $f_{i}^{n} = a_{i} \\, u_{i}^{n}$ in both predictor and corrector. Eliminate the intermediate predicted state to write the one-step combined update for $u_{i}^{n+1}$ explicitly in terms of $u_{i-1}^{n}$, $u_{i}^{n}$, $u_{i+1}^{n}$ and $a_{i-1}$, $a_{i}$, $a_{i+1}$, together with $\\lambda$. The expression must be algebraically closed, containing no predicted quantities, and must be consistent with second-order accuracy under smoothness of $a(x)$ and $u(x,t)$. Your final answer should be the single closed-form analytic expression for $u_{i}^{n+1}$ produced by this coefficient-aware conservative MacCormack scheme. No numerical evaluation is required.",
            "solution": "We begin from the conservation law $u_{t} + (a u)_{x} = 0$, where $a(x)$ is smooth, time-independent, and $u(x,t)$ is smooth. The fundamental base is the conservation form and its product-rule expansion $(a u)_{x} = a u_{x} + a_{x} u$, together with Taylor expansions in space and time at a grid point.\n\nAnalysis of the naive nonconservative MacCormack and loss of second order:\n\nConsider the naive MacCormack predictor–corrector that discretizes $u_{t} + a(x) u_{x} = 0$ by multiplying one-sided differences of $u$ by $a_{i} = a(x_{i})$. Its predictor and corrector at node $i$ are\n$$\nu_{i}^{*} = u_{i}^{n} - \\lambda \\, a_{i} \\left(u_{i+1}^{n} - u_{i}^{n}\\right),\n$$\n$$\nu_{i}^{n+1} = \\frac{1}{2} \\left[ u_{i}^{n} + u_{i}^{*} - \\lambda \\, a_{i} \\left( u_{i}^{*} - u_{i-1}^{*} \\right) \\right].\n$$\nTo assess consistency with the conservation law, insert the exact solution $u(x,t)$ at $(x_{i},t_{n})$ and expand to leading orders in $\\Delta x$ and $\\Delta t$. Write $\\Delta x$ as $\\Delta$ for brevity. Taylor expand the spatial values:\n$$\nu_{i+1}^{n} = u + u_{x} \\Delta + \\frac{1}{2} u_{xx} \\Delta^{2} + \\frac{1}{6} u_{xxx} \\Delta^{3} + \\mathcal{O}(\\Delta^{4}),\n$$\n$$\nu_{i-1}^{n} = u - u_{x} \\Delta + \\frac{1}{2} u_{xx} \\Delta^{2} - \\frac{1}{6} u_{xxx} \\Delta^{3} + \\mathcal{O}(\\Delta^{4}),\n$$\nand $a_{i-1} = a - a_{x} \\Delta + \\frac{1}{2} a_{xx} \\Delta^{2} + \\mathcal{O}(\\Delta^{3})$, where all derivatives are evaluated at $(x_{i},t_{n})$. The predictor yields\n$$\nu_{i}^{*} = u - \\lambda \\, a \\left( u_{x} \\Delta + \\frac{1}{2} u_{xx} \\Delta^{2} + \\frac{1}{6} u_{xxx} \\Delta^{3} \\right) + \\mathcal{O}(\\Delta^{4}).\n$$\nA similar expansion at $i-1$ gives\n\\begin{align*}\nu_{i-1}^{*} &= \\left[ u - u_{x} \\Delta + \\frac{1}{2} u_{xx} \\Delta^{2} - \\frac{1}{6} u_{xxx} \\Delta^{3} \\right] \\\\\n&\\quad - \\lambda \\left[ a u_{x} \\Delta + \\left( -\\frac{1}{2} a u_{xx} - a_{x} u_{x} \\right) \\Delta^{2} + \\left( \\frac{1}{6} a u_{xxx} + \\frac{1}{2} a_{x} u_{xx} + \\frac{1}{2} a_{xx} u_{x} \\right) \\Delta^{3} \\right] + \\mathcal{O}(\\Delta^{4}).\n\\end{align*}\nSubtract to obtain\n\\begin{align*}\nu_{i}^{*} - u_{i-1}^{*} &= u_{x} \\Delta - \\frac{1}{2} u_{xx} \\Delta^{2} + \\frac{1}{6} u_{xxx} \\Delta^{3} \\\\\n&\\quad + \\lambda \\left[ \\left( - a u_{xx} - a_{x} u_{x} \\right) \\Delta^{2} + \\left( \\frac{1}{2} a_{x} u_{xx} + \\frac{1}{2} a_{xx} u_{x} \\right) \\Delta^{3} \\right] + \\mathcal{O}(\\Delta^{4}).\n\\end{align*}\nNow form the corrector:\n\\begin{align*}\nu_{i}^{n+1} &= \\frac{1}{2} \\left\\{ \\left[ u + u_{i}^{*} \\right] - \\lambda a \\left[ u_{i}^{*} - u_{i-1}^{*} \\right] \\right\\} \\\\\n&= \\frac{1}{2} \\left\\{ 2 u - \\lambda a \\left( u_{x} \\Delta + \\frac{1}{2} u_{xx} \\Delta^{2} + \\frac{1}{6} u_{xxx} \\Delta^{3} \\right) - \\lambda a \\left[ u_{x} \\Delta - \\frac{1}{2} u_{xx} \\Delta^{2} + \\frac{1}{6} u_{xxx} \\Delta^{3} \\right] \\right. \\\\\n&\\qquad \\left. - \\lambda^{2} a \\left[ \\left( - a u_{xx} - a_{x} u_{x} \\right) \\Delta^{2} + \\left( \\frac{1}{2} a_{x} u_{xx} + \\frac{1}{2} a_{xx} u_{x} \\right) \\Delta^{3} \\right] \\right\\} + \\mathcal{O}(\\Delta^{4}).\n\\end{align*}\nSimplify the leading terms:\n$$\nu_{i}^{n+1} = u - \\lambda a \\, u_{x} \\Delta - \\frac{1}{6} \\lambda a \\, u_{xxx} \\Delta^{3} - \\frac{1}{2} \\lambda^{2} a \\left( - a u_{xx} - a_{x} u_{x} \\right) \\Delta^{2} + \\mathcal{O}(\\Delta^{3}, \\lambda^{2} \\Delta^{3}).\n$$\nSince $\\lambda \\Delta = \\Delta t$, the leading-order temporal increment generated by the scheme is $- a u_{x} \\Delta t$. However, the true time derivative from the conservation law is $u_{t} = - (a u)_{x} = - a u_{x} - a_{x} u$. Therefore, the local truncation error at order $\\Delta t$ contains the unbalanced term $+ a_{x} u \\, \\Delta t$. This is a first-order term and demonstrates that discretizing the nonconservative form $u_{t} + a(x) u_{x} = 0$ with the naive MacCormack loses consistency with the conservation law when $a_{x} \\neq 0$, and thus cannot achieve second-order accuracy in the presence of coefficient gradients.\n\nConstruction of the coefficient-aware conservative MacCormack and combined update:\n\nTo restore second-order accuracy and consistency with the conservation law, we discretize in conservative form using cell-centered fluxes $f_{i}^{n} = a_{i} \\, u_{i}^{n}$. The predictor–corrector reads\n$$\nu_{i}^{*} = u_{i}^{n} - \\lambda \\left( f_{i+1}^{n} - f_{i}^{n} \\right) = u_{i}^{n} - \\lambda \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right),\n$$\n$$\nu_{i}^{n+1} = \\frac{1}{2} \\left[ u_{i}^{n} + u_{i}^{*} - \\lambda \\left( f_{i}^{*} - f_{i-1}^{*} \\right) \\right],\n$$\nwith $f_{i}^{*} = a_{i} \\, u_{i}^{*}$ (since $a$ is time-independent). Eliminating the predicted variables, we obtain\n\\begin{align*}\nf_{i}^{*} &= a_{i} u_{i}^{*} = a_{i} u_{i}^{n} - \\lambda a_{i} \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right), \\\\\nf_{i-1}^{*} &= a_{i-1} u_{i-1}^{*} = a_{i-1} u_{i-1}^{n} - \\lambda a_{i-1} \\left( a_{i} u_{i}^{n} - a_{i-1} u_{i-1}^{n} \\right).\n\\end{align*}\nSubstitute into the corrector and combine with the predictor to write a single-step update. First compute $u_{i}^{n} + u_{i}^{*}$:\n$$\nu_{i}^{n} + u_{i}^{*} = 2 u_{i}^{n} - \\lambda \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right).\n$$\nNext compute $f_{i}^{*} - f_{i-1}^{*}$:\n\\begin{align*}\nf_{i}^{*} - f_{i-1}^{*} &= \\left( a_{i} u_{i}^{n} - a_{i-1} u_{i-1}^{n} \\right) - \\lambda \\left[ a_{i} \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right) - a_{i-1} \\left( a_{i} u_{i}^{n} - a_{i-1} u_{i-1}^{n} \\right) \\right].\n\\end{align*}\nTherefore,\n\\begin{align*}\nu_{i}^{n+1} &= \\frac{1}{2} \\left\\{ 2 u_{i}^{n} - \\lambda \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right) - \\lambda \\left[ \\left( a_{i} u_{i}^{n} - a_{i-1} u_{i-1}^{n} \\right) - \\lambda \\left( a_{i} \\left( a_{i+1} u_{i+1}^{n} - a_{i} u_{i}^{n} \\right) - a_{i-1} \\left( a_{i} u_{i}^{n} - a_{i-1} u_{i-1}^{n} \\right) \\right) \\right] \\right\\} \\\\\n&= u_{i}^{n} - \\frac{\\lambda}{2} \\left( a_{i+1} u_{i+1}^{n} - a_{i-1} u_{i-1}^{n} \\right) + \\frac{\\lambda^{2}}{2} \\left[ a_{i} a_{i+1} u_{i+1}^{n} - \\left( a_{i}^{2} + a_{i-1} a_{i} \\right) u_{i}^{n} + a_{i-1}^{2} u_{i-1}^{n} \\right].\n\\end{align*}\nThis explicit update uses only the values at $i-1$, $i$, and $i+1$ and the local coefficients $a_{i-1}$, $a_{i}$, $a_{i+1}$, and is consistent with the conservation form. A Taylor analysis analogous to the one above, but now carried through on the flux $f = a u$, shows that the first-order temporal increment is $- \\Delta t (a u)_{x}$ (correct), and the leading local truncation error is of order $\\mathcal{O}(\\Delta t^{2}, \\Delta x^{2})$ under smoothness, thereby restoring second-order accuracy.\n\nThe requested final expression for the coefficient-aware conservative MacCormack combined update is the closed-form analytic update for $u_{i}^{n+1}$ given above.",
            "answer": "$$\\boxed{u_{i}^{n+1} = u_{i}^{n} - \\frac{\\lambda}{2}\\left(a_{i+1} u_{i+1}^{n} - a_{i-1} u_{i-1}^{n}\\right) + \\frac{\\lambda^{2}}{2}\\left[a_{i} a_{i+1} u_{i+1}^{n} - \\left(a_{i}^{2} + a_{i-1} a_{i}\\right) u_{i}^{n} + a_{i-1}^{2} u_{i-1}^{n}\\right]}$$"
        },
        {
            "introduction": "Hyperbolic conservation laws, like the inviscid Burgers' equation, are notorious for developing discontinuities, or 'shocks,' even from smooth initial data. This hands-on practice provides a powerful computational demonstration of a fundamental principle: only schemes formulated in conservation form can correctly capture the speed and location of these shocks . By implementing and comparing both a conservative and a non-conservative MacCormack scheme, you will directly observe the failure of the non-conservative approach and gain a lasting appreciation for the practical implications of the Lax-Wendroff theorem.",
            "id": "3342598",
            "problem": "Consider the one-dimensional inviscid Burgers equation in conservation form, given by $u_t + \\left(\\frac{u^2}{2}\\right)_x = 0$, where $u = u(x,t)$ denotes a scalar velocity field on a periodic domain with spatial coordinate $x$. The conservation law is understood in the weak sense, so that discontinuous solutions may occur and obey an integral balance derived from the conservation principle. The flux function is $f(u) = \\frac{u^2}{2}$. This equation admits shock waves for Riemann-type initial data with $u_L > u_R$, and the shock speed determined by the Rankine–Hugoniot jump condition is $s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{u_L + u_R}{2}$.\n\nMacCormack predictor–corrector schemes are used to advance hyperbolic partial differential equations. In conservation law form, a MacCormack method advances the solution by predicting with a forward spatial difference of flux and correcting with a backward difference of the predicted flux. A nonconservative variant instead advances the variable using the nonconservative differential form $u_t + u\\,u_x = 0$, applying forward and backward differences to $u$ rather than to the flux $f(u)$. For discontinuous solutions, only the conservative formulation enforces the correct shock motion derived from the integral conservation law, while the nonconservative formulation is not guaranteed to propagate shocks with the correct speed.\n\nYour task is to construct a counterexample demonstrating that a nonconservative MacCormack update yields an incorrect shock location compared to both the conservative MacCormack update and the analytical Rankine–Hugoniot speed for the inviscid Burgers equation. Proceed as follows:\n\n1. Use a periodic domain of length $L = 2$, identified with the interval $[-1,1)$. Let $N$ be the number of uniformly spaced grid points, so that $\\Delta x = L/N$. Represent values at cell centers $x_i = -L/2 + i\\,\\Delta x$ for $i = 0,1,\\dots,N-1$.\n\n2. Initialize Riemann data at time $t=0$ with a single discontinuity located at $x = x_0$, defined by\n   $$\n   u(x,0) = \n   \\begin{cases}\n   u_L, & x < x_0, \\\\\n   u_R, & x \\ge x_0,\n   \\end{cases}\n   $$\n   with periodic continuation outside the interval $[-1,1)$.\n\n3. Implement two explicit MacCormack predictor–corrector schemes with a constant time step $\\Delta t$ satisfying a Courant–Friedrichs–Lewy condition based on the maximum characteristic speed. Use a dimensionless Courant number $\\text{CFL}$ and set $\\Delta t = \\text{CFL}\\,\\Delta x / \\max(|u_L|,|u_R|)$.\n   - Conservative MacCormack: apply predictor and corrector using forward and backward differences of the flux function $f(u) = \\frac{u^2}{2}$, ensuring a discretization consistent with the conservation law.\n   - Nonconservative MacCormack: apply predictor and corrector using forward and backward differences of the primitive variable $u$ in the nonconservative form $u_t + u\\,u_x = 0$.\n\n4. Advance each scheme for $n$ steps where $n = \\lceil T/\\Delta t \\rceil$, yielding a final time $t_{\\text{end}} = n\\,\\Delta t$.\n\n5. Estimate the numerical shock location at $t_{\\text{end}}$ for each scheme by identifying the position $x$ at which the solution crosses the midpoint value $m = \\frac{u_L + u_R}{2}$ between neighboring grid points, using linear interpolation between cell centers. If multiple crossings exist due to periodicity or numerical oscillations, select the crossing whose position minimizes the periodic distance to the analytical shock location. If no crossing is detected, approximate the shock location by the position of maximum magnitude of the discrete gradient and then refine using local interpolation.\n\n6. Compute the analytical shock location using the Rankine–Hugoniot speed $s = \\frac{u_L + u_R}{2}$, namely $x_{\\text{exact}}(t_{\\text{end}}) = x_0 + s\\,t_{\\text{end}}$, interpreting positions modulo the domain length $L$ to remain in $[-1,1)$.\n\n7. For each test case, report the absolute periodic distance between the numerical shock location and the analytical shock location at $t_{\\text{end}}$, separately for the conservative and nonconservative MacCormack schemes.\n\nUse the following test suite, which includes a clear shock propagation, a moderate shock, and a stationary shock:\n- Case 1: $u_L = 2.0$, $u_R = 0.0$, $x_0 = 0.0$, $N = 1000$, $T = 0.3$, $\\text{CFL} = 0.4$.\n- Case 2: $u_L = 1.5$, $u_R = 0.5$, $x_0 = -0.2$, $N = 1000$, $T = 0.5$, $\\text{CFL} = 0.4$.\n- Case 3: $u_L = 1.0$, $u_R = -1.0$, $x_0 = 0.3$, $N = 1000$, $T = 0.4$, $\\text{CFL} = 0.4$.\n\nAll quantities are dimensionless; no physical units are required. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of conservative error followed by nonconservative error for each case, namely $[e_{\\text{cons},1},e_{\\text{noncons},1},e_{\\text{cons},2},e_{\\text{noncons},2},e_{\\text{cons},3},e_{\\text{noncons},3}]$, where each $e$ is a floating-point number representing the absolute periodic distance between the computed and analytical shock locations at the final time for the corresponding scheme and case.",
            "solution": "The problem requires constructing a numerical counterexample to demonstrate that a nonconservative finite difference scheme fails to compute the correct shock speed for the inviscid Burgers' equation, unlike a conservative scheme. This will be achieved by implementing and comparing two variants of the MacCormack method.\n\nThe one-dimensional inviscid Burgers' equation in conservation-law form is\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{u^2}{2} \\right) = 0\n$$\nwhere $u(x,t)$ is the velocity, and the flux function is $f(u) = \\frac{u^2}{2}$. For smooth solutions, where the derivatives exist, the chain rule can be applied to yield the nonconservative form:\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n$$\nHowever, hyperbolic conservation laws like Burgers' equation are known to develop discontinuities (shock waves) even from smooth initial data. For discontinuous solutions, the differential forms are not well-defined, and one must refer to the integral form of the conservation law. The dynamics of a discontinuity are governed by the Rankine–Hugoniot jump condition, which is a direct consequence of this integral form. For a shock moving with speed $s$, separating two constant states $u_L$ (left) and $u_R$ (right), the condition is:\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}\n$$\nFor Burgers' equation, this gives the analytical shock speed:\n$$\ns = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}\n$$\nA numerical scheme must be formulated in \"conservation form\" to ensure that its solutions converge to a weak solution that satisfies this jump condition. A nonconservative scheme does not respect the integral balance and typically converges to a solution with an incorrect shock speed.\n\nWe will discretize the spatial domain $x \\in [-1, 1)$, of length $L=2$, using $N$ uniformly spaced cell centers $x_i = -L/2 + i \\Delta x$ for $i = 0, \\dots, N-1$, where $\\Delta x = L/N$. The time step $\\Delta t$ is determined by a Courant–Friedrichs–Lewy (CFL) condition, $\\Delta t = \\text{CFL} \\Delta x / \\max(|u_L|, |u_R|)$, to ensure numerical stability.\n\nThe initial condition is a Riemann problem with a step discontinuity at $x=x_0$:\n$$\nu(x,0) = \n\\begin{cases}\nu_L, & x < x_0, \\\\\nu_R, & x \\ge x_0,\n\\end{cases}\n$$\nWe advance the solution to a final time $t_{\\text{end}} = n \\Delta t$, where $n = \\lceil T/\\Delta t \\rceil$.\n\nThe two MacCormack schemes are implemented as follows. Let $u_i^n$ be the numerical solution at grid point $i$ and time $t^n = n \\Delta t$.\n\n**1. Conservative MacCormack Scheme**\nThis scheme discretizes the conservation law $u_t + f(u)_x=0$.\n*   Predictor step (forward difference on flux):\n    $$\n    u_i^* = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( f(u_{i+1}^n) - f(u_i^n) \\right)\n    $$\n*   Corrector step (backward difference on predicted flux):\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - \\frac{\\Delta t}{\\Delta x} \\left( f(u_i^*) - f(u_{i-1}^*) \\right) \\right)\n    $$\nHere, indices are handled periodically, e.g., $u_{N} = u_0$ and $u_{-1} = u_{N-1}$. This scheme is in conservation form and is expected to compute the correct shock speed in the limit of grid refinement.\n\n**2. Nonconservative MacCormack Scheme**\nThis scheme discretizes the nonconservative form $u_t + u u_x=0$.\n*   Predictor step (forward difference on $u$):\n    $$\n    u_i^* = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n    $$\n*   Corrector step (backward difference on predicted $u$):\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - u_i^* \\frac{\\Delta t}{\\Delta x} (u_i^* - u_{i-1}^*) \\right)\n    $$\nThis formulation does not discretize a flux difference at the cell interfaces and thus does not enforce a local conservation property. As a result, it is not guaranteed to capture the correct shock dynamics.\n\nAfter evolving the solution to $t_{\\text{end}}$ with both schemes, we determine the numerical shock location. This is done by finding where the numerical solution profile crosses the midpoint value $m = (u_L + u_R)/2$. We use linear interpolation between the two grid points bracketing the crossing. If multiple crossings occur due to numerical oscillations, we select the one closest to the analytical shock position, $x_{\\text{analytical}}(t_{\\text{end}}) = x_0 + s \\cdot t_{\\text{end}}$, using the periodic distance on the domain. The absolute periodic distance between two points $p_1$ and $p_2$ on a domain of length $L$ is given by $\\min(|p_1 - p_2|, L - |p_1 - p_2|)$.\n\nThe error for each scheme is then calculated as the absolute periodic distance between its computed numerical shock location, $x_{\\text{numerical}}$, and the analytical shock location, $x_{\\text{analytical}}$, at the final time $t_{\\text{end}}$. The results for the three test cases will demonstrate that the error for the nonconservative scheme is substantially larger than for the conservative one, confirming that the former computes an incorrect shock speed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation using conservative and nonconservative\n    MacCormack schemes to demonstrate the importance of conservation form\n    for shock capturing.\n    \"\"\"\n    test_cases = [\n        # (u_L, u_R, x_0, N, T, CFL)\n        (2.0, 0.0, 0.0, 1000, 0.3, 0.4),\n        (1.5, 0.5, -0.2, 1000, 0.5, 0.4),\n        (1.0, -1.0, 0.3, 1000, 0.4, 0.4),\n    ]\n\n    results = []\n\n    for u_L, u_R, x_0, N, T, CFL in test_cases:\n        L = 2.0\n        dx = L / N\n        x = -L/2 + np.arange(N) * dx\n        \n        # CFL condition and time steps\n        max_speed = max(abs(u_L), abs(u_R))\n        if max_speed == 0:\n            # Avoid division by zero if max speed is zero, choose a reasonable dt\n            max_speed = 1.0\n        dt = CFL * dx / max_speed\n        num_steps = math.ceil(T / dt)\n        t_end = num_steps * dt\n\n        # Initial condition\n        u0 = np.full(N, u_R, dtype=np.float64)\n        u0[x < x_0] = u_L\n        \n        u_cons = u0.copy()\n        u_noncons = u0.copy()\n\n        # --- Time evolution ---\n        for _ in range(num_steps):\n            # Conservative MacCormack\n            f = 0.5 * u_cons**2\n            # Predictor\n            u_star_c = u_cons - (dt / dx) * (np.roll(f, -1) - f)\n            # Corrector\n            f_star = 0.5 * u_star_c**2\n            u_cons = 0.5 * (u_cons + u_star_c - (dt / dx) * (f_star - np.roll(f_star, 1)))\n\n            # Nonconservative MacCormack\n            # Predictor\n            u_star_nc = u_noncons - u_noncons * (dt / dx) * (np.roll(u_noncons, -1) - u_noncons)\n            # Corrector\n            u_noncons = 0.5 * (u_noncons + u_star_nc - u_star_nc * (dt / dx) * (u_star_nc - np.roll(u_star_nc, 1)))\n        \n        # --- Analysis ---\n        # Analytical shock location\n        s = (u_L + u_R) / 2.0\n        x_analytical = x_0 + s * t_end\n        # Map to periodic domain [-L/2, L/2)\n        x_analytical = -L/2 + (x_analytical - (-L/2)) % L\n\n        midpoint_val = (u_L + u_R) / 2.0\n        \n        def find_shock_location(u_final, x_grid, L_domain, analytical_pos, dx_grid):\n            \"\"\"\n            Finds the numerical shock location by looking for a crossing of the\n            midpoint value, refined by linear interpolation.\n            \"\"\"\n            crossings = []\n            # Find all crossings of midpoint_val\n            for i in range(N):\n                u_i = u_final[i]\n                u_i_plus_1 = u_final[(i + 1) % N]\n                if (u_i - midpoint_val) * (u_i_plus_1 - midpoint_val) <= 0 and u_i != u_i_plus_1:\n                    x_i = x_grid[i]\n                    x_cross = x_i + dx_grid * (midpoint_val - u_i) / (u_i_plus_1 - u_i)\n                    crossings.append(x_cross)\n\n            if crossings:\n                # Find crossing closest to analytical solution\n                min_dist = float('inf')\n                best_pos = crossings[0]\n                for pos in crossings:\n                    dist = abs(pos - analytical_pos)\n                    periodic_dist = min(dist, L_domain - dist)\n                    if periodic_dist < min_dist:\n                        min_dist = periodic_dist\n                        best_pos = pos\n                return best_pos\n            else:\n                # Fallback: max gradient\n                grad = np.abs(np.roll(u_final, -1) - u_final)\n                max_grad_idx = np.argmax(grad)\n                \n                u_a = u_final[max_grad_idx]\n                u_b = u_final[(max_grad_idx + 1) % N]\n                x_a = x_grid[max_grad_idx]\n                \n                if abs(u_b - u_a) < 1e-9: # Avoid division by zero\n                    return x_a + dx_grid / 2.0\n                \n                x_pos = x_a + dx_grid * (midpoint_val - u_a) / (u_b - u_a)\n                return x_pos\n\n        def periodic_map(pos, length):\n            \"\"\"Maps a position to the periodic interval [-length/2, length/2).\"\"\"\n            return -length/2 + (pos - (-length/2)) % length\n\n        x_num_cons = find_shock_location(u_cons, x, L, x_analytical, dx)\n        x_num_noncons = find_shock_location(u_noncons, x, L, x_analytical, dx)\n        \n        x_num_cons = periodic_map(x_num_cons, L)\n        x_num_noncons = periodic_map(x_num_noncons, L)\n        \n        def periodic_distance(p1, p2, length):\n            \"\"\"Calculates the absolute periodic distance between two points.\"\"\"\n            dist = abs(p1 - p2)\n            return min(dist, length - dist)\n\n        error_cons = periodic_distance(x_num_cons, x_analytical, L)\n        error_noncons = periodic_distance(x_num_noncons, x_analytical, L)\n\n        results.extend([error_cons, error_noncons])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice serves as a capstone, challenging you to apply the conservative MacCormack scheme to a system of equations that governs gas dynamics: the compressible Euler equations. You will tackle practical challenges encountered in real CFD codes, including implementing various physical boundary conditions and addressing numerical error that leads to a drift in conserved quantities . By designing and implementing a correction procedure to enforce the global conservation of mass, momentum, and energy, you will learn a vital technique for ensuring the physical fidelity of long-duration simulations.",
            "id": "3342540",
            "problem": "Consider the one-dimensional compressible Euler equations for an ideal gas, written in conservative form on a spatial domain $[0,L]$ as\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\nwhere the conserved variable vector is $U = [\\rho, \\rho u, E]^T$, with $\\rho$ the mass density in $\\mathrm{kg/m^3}$, $u$ the velocity in $\\mathrm{m/s}$, and $E$ the total energy density in $\\mathrm{J/m^3}$. For an ideal gas, the pressure $p$ in $\\mathrm{Pa}$ satisfies $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right)$ with adiabatic index $\\gamma = 1.4$, and the physical flux is\n$$\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu(E + p)\n\\end{bmatrix}.\n$$\nIn an Arbitrary Lagrangian–Eulerian (ALE) description with a prescribed mesh-face velocity field $w(x,t)$ in $\\mathrm{m/s}$, the effective advective flux of the conserved variables becomes\n$$\nG(U,x,t) = F(U) - w(x,t)\\,U,\n$$\nso that the governing equation in the physical coordinate $x$ is\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial G(U,x,t)}{\\partial x} = 0.\n$$\nYou will implement a second-order MacCormack predictor–corrector scheme for this conservative hyperbolic system on a uniformly sampled set of cell centers with ghost cells for boundary closures. The scheme must be applied to the ALE form with the flux $G(U,x,t)$ as above. Use the following scientifically consistent setup:\n\n- Domain length: $L = 1$ $\\mathrm{m}$.\n- Ideal-gas parameter: $\\gamma = 1.4$.\n- Initial conditions at $t=0$ specified at each cell center $x \\in [0,L]$:\n  $$\n  \\rho(x,0) = \\rho_0 + \\varepsilon_\\rho \\sin\\left(\\frac{2\\pi x}{L}\\right), \\quad u(x,0) = u_0 + \\varepsilon_u \\sin\\left(\\frac{2\\pi x}{L}\\right), \\quad p(x,0) = p_0 + \\varepsilon_p \\cos\\left(\\frac{2\\pi x}{L}\\right),\n  $$\n  with constants $\\rho_0 = 1$ $\\mathrm{kg/m^3}$, $u_0 = 10$ $\\mathrm{m/s}$, $p_0 = 1000$ $\\mathrm{Pa}$, $\\varepsilon_\\rho = 0.01$ $\\mathrm{kg/m^3}$, $\\varepsilon_u = 0.5$ $\\mathrm{m/s}$, $\\varepsilon_p = 10$ $\\mathrm{Pa}$. The total energy density is initialized from the equation of state.\n\n- Time step selection: at each step, select $\\Delta t$ from a Courant–Friedrichs–Lewy (CFL) condition using the maximum local characteristic speed\n  $$\n  a(x,t) = \\left|u(x,t) - w(x,t)\\right| + c(x,t), \\quad c(x,t) = \\sqrt{\\gamma \\frac{p(x,t)}{\\rho(x,t)}},\n  $$\n  with $\\mathrm{CFL} = 0.5$, so that $\\Delta t = \\mathrm{CFL}\\, \\Delta x / \\max_x a(x,t)$, and clip the last step to hit the final time exactly.\n\n- Boundary closures through ghost cells:\n  - Periodic: $U(0^-,t) = U(L^-,t)$ and $U(L^+,t) = U(0^+,t)$.\n  - Transmissive (outflow): zero-gradient, i.e., $U(0^-,t) = U(0^+,t)$ and $U(L^+,t) = U(L^-,t)$.\n  - Reflective (wall): $\\rho$ and $E$ mirrored, velocity reversed, i.e., $\\rho(0^-,t) = \\rho(0^+,t)$, $E(0^-,t) = E(0^+,t)$, $(\\rho u)(0^-,t) = -(\\rho u)(0^+,t)$, and similarly at $x=L$.\n\n- Conservation tracking: define the total mass $M(t) = \\int_0^L \\rho(x,t)\\,dx$, total momentum $P(t) = \\int_0^L \\rho(x,t)u(x,t)\\,dx$, and total energy $K(t) = \\int_0^L E(x,t)\\,dx$. These must be computed in $\\mathrm{kg}$, $\\mathrm{kg\\cdot m/s}$, and $\\mathrm{J}$ respectively, by summing conservative variables over cells and multiplying by $\\Delta x$.\n\n- Conservation enforcement: design and implement a correction that enforces exact conservation of $M(t)$, $P(t)$, and $K(t)$ to machine precision relative to the initial totals. Specifically, after each MacCormack step, compute the error vector\n  $$\n  e(t) = \\begin{bmatrix} M(t) - M(0) \\\\ P(t) - P(0) \\\\ K(t) - K(0) \\end{bmatrix},\n  $$\n  and apply a volume-weighted uniform correction $\\delta = e(t)/L$ to each interior cell’s conserved variables so that the corrected totals satisfy $M(t) = M(0)$, $P(t) = P(0)$, and $K(t) = K(0)$ up to machine precision. Ensure scientific realism by avoiding non-physical states; if needed, scale the correction to maintain $\\rho > 0$ and $p > 0$ everywhere, while documenting the mathematical rationale in your implementation comments.\n\nImplement the MacCormack predictor–corrector scheme from first principles for the ALE flux $G(U,x,t)$ without using external solvers. Your program must run the following test suite of distinct parameter sets, each specified by final time $T$ in $\\mathrm{s}$, number of cells $N$, boundary closure type, and moving-mesh velocity function $w(x,t)$:\n\n- Test A (happy path, conservative baseline): $N=64$, $T=0.002$ $\\mathrm{s}$, periodic boundary, static mesh $w(x,t) = 0$ $\\mathrm{m/s}$.\n- Test B (transmissive boundary, static mesh): $N=64$, $T=0.002$ $\\mathrm{s}$, transmissive boundary, static mesh $w(x,t) = 0$ $\\mathrm{m/s}$.\n- Test C (reflective boundary, spatially and temporally varying mesh): $N=64$, $T=0.002$ $\\mathrm{s}$, reflective boundary, $w(x,t) = W_0 \\sin\\left(\\frac{2\\pi x}{L}\\right)\\cos\\left(\\frac{2\\pi t}{T}\\right)$ with $W_0 = 5$ $\\mathrm{m/s}$.\n- Test D (periodic boundary, constant nonzero mesh speed): $N=128$, $T=0.001$ $\\mathrm{s}$, periodic boundary, $w(x,t) = W_0$ with $W_0 = 2$ $\\mathrm{m/s}$.\n\nFor each test case, run two simulations:\n- One without conservation enforcement, to measure the raw numerical drift.\n- One with the per-step conservation enforcement described above.\n\nFor each simulation, report the absolute final errors $|M(T) - M(0)|$ in $\\mathrm{kg}$, $|P(T) - P(0)|$ in $\\mathrm{kg\\cdot m/s}$, and $|K(T) - K(0)|$ in $\\mathrm{J}$. Therefore, the result for each test case is a list of six floating-point numbers:\n$$\n\\left[\\,|M_{\\text{no}}|,\\,|P_{\\text{no}}|,\\,|K_{\\text{no}}|,\\,|M_{\\text{enf}}|,\\,|P_{\\text{enf}}|,\\,|K_{\\text{enf}}|\\,\\right],\n$$\nwhere the subscript “no” denotes no enforcement and “enf” denotes enforcement.\n\nYour program should produce a single line of output containing the aggregated results for all four test cases as a comma-separated list enclosed in square brackets, flattening the per-test lists in order $A$, $B$, $C$, $D$. For example, the output format must be\n$$\n[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{A}_4,\\text{A}_5,\\text{A}_6,\\text{B}_1,\\dots,\\text{D}_6],\n$$\nwith each entry a floating-point number in $\\mathrm{SI}$ units as specified above.",
            "solution": "### Principle-Based Design of the Numerical Solver\n\nThe solution will be developed by systematically discretizing the governing partial differential equations and implementing the specified numerical algorithms from first principles.\n\n**1. Governing Equations in ALE Form**\n\nThe conservative form of the 1D Euler equations is given by:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\nwhere $U = [\\rho, \\rho u, E]^T$ is the vector of conserved variables (mass density, momentum density, total energy density) and $F(U)$ is the physical flux vector. In an ALE formulation with a prescribed mesh velocity $w(x,t)$, the equation transforms to:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial G(U,x,t)}{\\partial x} = 0\n$$\nwhere the ALE flux $G(U,x,t) = F(U) - w(x,t)U$ accounts for the relative motion between the fluid and the computational grid. The numerical scheme will be applied to this ALE form.\n\n**2. Finite Difference Discretization**\n\nWe discretize the spatial domain $[0, L]$ into $N$ uniform cells of width $\\Delta x = L/N$. The cell centers are located at $x_i = (i + 1/2)\\Delta x$ for $i=0, \\dots, N-1$. The solution at time $t^n = n\\Delta t$ in cell $i$ is denoted by $U_i^n \\approx U(x_i, t^n)$. To handle boundary conditions, we introduce one ghost cell at each end of the domain, extending our discrete solution vector to $N+2$ points.\n\n**3. MacCormack Predictor-Corrector Scheme**\n\nThe MacCormack scheme is a two-step, second-order accurate method for hyperbolic equations. For the equation $\\frac{\\partial U}{\\partial t} + \\frac{\\partial G}{\\partial x} = 0$, the scheme is:\n\n*   **Predictor Step:** A forward difference is used for the spatial derivative to obtain a predicted state $U^*$.\n    $$\n    U_i^* = U_i^n - \\frac{\\Delta t}{\\Delta x} (G_{i+1}^n - G_i^n)\n    $$\n    where $G_i^n = G(U_i^n, x_i, t^n)$. This step is first-order accurate.\n\n*   **Corrector Step:** A backward difference is used on the predicted state to correct the solution and achieve second-order accuracy.\n    $$\n    U_i^{n+1} = \\frac{1}{2} \\left[ U_i^n + U_i^* - \\frac{\\Delta t}{\\Delta x} (G_i^* - G_{i-1}^*) \\right]\n    $$\n    where $G_i^* = G(U_i^*, x_i, t^n + \\Delta t)$. The final update $U_i^{n+1}$ is an average of the initial state and the corrected predicted state.\n\n**4. Time Step Stability (CFL Condition)**\n\nThe explicit nature of the MacCormack scheme requires a stability constraint on the time step $\\Delta t$. The Courant-Friedrichs-Lewy (CFL) condition dictates that the numerical domain of dependence must contain the physical domain of dependence. For the ALE formulation, this is expressed as:\n$$\n\\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_x a(x,t)}\n$$\nwhere the maximum characteristic speed relative to the moving mesh is $a(x,t) = |u(x,t) - w(x,t)| + c(x,t)$, with $c(x,t) = \\sqrt{\\gamma p/\\rho}$ being the local speed of sound. We use the specified $\\text{CFL} = 0.5$ and clip the final time step to land exactly on the target time $T$.\n\n**5. Boundary Conditions**\n\nGhost cells are populated at the beginning of each step (for both the predictor and corrector stages) to enforce boundary conditions:\n*   **Periodic:** The value in the left ghost cell is copied from the last interior cell, and the right ghost cell is copied from the first interior cell.\n*   **Transmissive:** A zero-gradient condition is applied by copying the value from the adjacent interior cell into the ghost cell.\n*   **Reflective:** Density and total energy are mirrored (even symmetry), while momentum is reversed (odd symmetry) to simulate a solid wall with zero normal velocity.\n\n**6. Conservation Enforcement**\n\nNumerical schemes for conservation laws can suffer from drift, failing to conserve global quantities like total mass, momentum, and energy, especially with non-periodic boundaries. The problem specifies a post-processing step to enforce exact conservation.\n\nAfter each full MacCormack step, the total quantities $M(t)$, $P(t)$, $K(t)$ are computed by numerically integrating the density fields over the domain: $\\mathbf{Q}(t) = \\Delta x \\sum_i U_i(t)$. The numerical error vector is calculated as $e(t) = \\mathbf{Q}(t) - \\mathbf{Q}(0)$.\n\nTo nullify this error, a uniform correction $\\delta = e(t)/L$ is subtracted from the conserved variable vector $U_i$ in every interior cell:\n$$\nU_{i, \\text{corrected}} = U_i - \\delta\n$$\nThis procedure guarantees that the corrected total quantity $\\mathbf{Q}_{\\text{corrected}}(t)$ equals the initial total $\\mathbf{Q}(0)$ up to machine precision. The validity of this correction relies on the assumption that the resulting state remains physical (i.e., $\\rho > 0$ and $p > 0$). For the small-amplitude perturbations and short simulation times in this problem, this assumption is expected to hold without needing to scale the correction, which would otherwise violate the \"exact enforcement\" requirement. Assertions will be used in the implementation to verify this.\n\n**7. Implementation Strategy**\n\nA modular Python program will be structured as follows:\n*   Helper functions encapsulate the physics (conversions between primitive and conserved variables, flux calculations).\n*   A dedicated function handles the application of boundary conditions to the ghost cells.\n*   A primary `run_simulation` function orchestrates the time-stepping loop, implementing the MacCormack scheme and the optional conservation enforcement.\n*   A `solve` function defines the test suite, invokes `run_simulation` for each configuration, and formats the final output as specified.\n\nVectorized NumPy operations will be used for efficiency, acting on arrays representing the state across all grid cells simultaneously.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and print results.\n    \"\"\"\n    # Global constants defined in the problem statement\n    L = 1.0\n    GAMMA = 1.4\n    CFL = 0.5\n    RHO_0 = 1.0\n    U_0 = 10.0\n    P_0 = 1000.0\n    EPS_RHO = 0.01\n    EPS_U = 0.5\n    EPS_P = 10.0\n\n    # --- Helper Functions for Physics ---\n\n    def to_primitives(U):\n        \"\"\"Converts an array of conserved variables to primitive variables.\"\"\"\n        rho = U[0, :]\n        # Add a floor for stability against non-physical states.\n        # This is precautionary as the problem setup should not lead to it.\n        rho = np.maximum(rho, 1e-9)\n        u = U[1, :] / rho\n        pressure = (GAMMA - 1.0) * (U[2, :] - 0.5 * rho * u**2)\n        pressure = np.maximum(pressure, 1e-9)\n        return rho, u, pressure\n\n    def to_conserved(rho, u, p):\n        \"\"\"Converts arrays of primitive variables to conserved variables.\"\"\"\n        ru = rho * u\n        E = p / (GAMMA - 1.0) + 0.5 * rho * u**2\n        return np.vstack([rho, ru, E])\n\n    def get_flux_F(U):\n        \"\"\"Computes the physical flux F(U).\"\"\"\n        rho, u, p = to_primitives(U)\n        F = np.zeros_like(U)\n        F[0, :] = rho * u\n        F[1, :] = rho * u**2 + p\n        F[2, :] = u * (U[2, :] + p)\n        return F\n\n    def get_flux_G(U, x, t, w_func):\n        \"\"\"Computes the ALE flux G(U, x, t).\"\"\"\n        F = get_flux_F(U)\n        w = w_func(x, t)\n        if isinstance(w, (int, float)): # For constant w\n            return F - w * U\n        return F - w[np.newaxis, :] * U\n\n    # --- Helper Functions for Numerics ---\n\n    def apply_bc(U, bc_type):\n        \"\"\"Applies boundary conditions by setting ghost cell values.\"\"\"\n        if bc_type == 'periodic':\n            U[:, 0] = U[:, -2]\n            U[:, -1] = U[:, 1]\n        elif bc_type == 'transmissive':\n            U[:, 0] = U[:, 1]\n            U[:, -1] = U[:, -2]\n        elif bc_type == 'reflective':\n            # Left wall\n            U[0, 0] = U[0, 1]\n            U[1, 0] = -U[1, 1]\n            U[2, 0] = U[2, 1]\n            # Right wall\n            U[0, -1] = U[0, -2]\n            U[1, -1] = -U[1, -2]\n            U[2, -1] = U[2, -2]\n        return U\n\n    # --- Main Simulation Logic ---\n    \n    def run_simulation(N, T, bc_type, w_func, enforce_conservation):\n        \"\"\"Runs a single simulation case.\"\"\"\n        dx = L / N\n        x = np.linspace(dx/2.0, L - dx/2.0, N)\n        x_full = np.linspace(dx/2.0 - dx, L - dx/2.0 + dx, N + 2)\n\n        rho_init = RHO_0 + EPS_RHO * np.sin(2.0 * np.pi * x / L)\n        u_init = U_0 + EPS_U * np.sin(2.0 * np.pi * x / L)\n        p_init = P_0 + EPS_P * np.cos(2.0 * np.pi * x / L)\n        \n        U = np.zeros((3, N + 2))\n        U[:, 1:-1] = to_conserved(rho_init, u_init, p_init)\n        \n        totals_0 = np.sum(U[:, 1:-1], axis=1) * dx\n        t = 0.0\n\n        while t < T:\n            apply_bc(U, bc_type)\n\n            rho_int, u_int, p_int = to_primitives(U[:, 1:-1])\n            w_int = w_func(x, t)\n            c_sound = np.sqrt(GAMMA * p_int / rho_int)\n            a_max = np.max(np.abs(u_int - w_int) + c_sound)\n            \n            dt = CFL * dx / a_max if a_max > 0 else T - t\n            if t + dt > T:\n                dt = T - t\n            if dt <= 0:\n                break\n\n            # Predictor step\n            G = get_flux_G(U[:, 1:], x_full[1:], t, w_func)\n            U_star = np.zeros_like(U)\n            U_star[:, 1:-1] = U[:, 1:-1] - (dt / dx) * (G[:, 1:] - G[:, :-1])\n\n            apply_bc(U_star, bc_type)\n\n            # Corrector step\n            G_star = get_flux_G(U_star[:, :-1], x_full[:-1], t + dt, w_func)\n            U[:, 1:-1] = 0.5 * (U[:, 1:-1] + U_star[:, 1:-1] - (dt / dx) * (G_star[:, 1:] - G_star[:, :-1]))\n\n            if enforce_conservation:\n                totals_t = np.sum(U[:, 1:-1], axis=1) * dx\n                error = totals_t - totals_0\n                correction = error / L\n                \n                U_corrected = U[:, 1:-1] - correction[:, np.newaxis]\n                \n                # The mathematical rationale for not scaling the correction:\n                # The problem demands enforcement of exact conservation to machine precision.\n                # Scaling the correction by a factor less than 1 would only partially\n                # reduce the error, failing to meet this requirement. The phrase \"if needed\"\n                # implies that for the given tests, scaling should not be necessary.\n                # We verify this expectation with assertions.\n                rho_check, _, p_check = to_primitives(U_corrected)\n                assert np.all(rho_check > 0), f\"Negative density with correction at t={t+dt}\"\n                assert np.all(p_check > 0), f\"Negative pressure with correction at t={t+dt}\"\n\n                U[:, 1:-1] = U_corrected\n\n            t += dt\n\n        totals_T = np.sum(U[:, 1:-1], axis=1) * dx\n        final_errors = np.abs(totals_T - totals_0)\n        return final_errors\n\n    # --- Test Suite Execution ---\n\n    w0_C = 5.0\n    w0_D = 2.0\n    \n    test_cases = [\n        {'N': 64, 'T': 0.002, 'bc_type': 'periodic', 'w_func': lambda x, t: 0.0},\n        {'N': 64, 'T': 0.002, 'bc_type': 'transmissive', 'w_func': lambda x, t: 0.0},\n        {'N': 64, 'T': 0.002, 'bc_type': 'reflective', 'w_func': lambda x, t, T_case=0.002: w0_C * np.sin(2*np.pi * x / L) * np.cos(2*np.pi * t / T_case)},\n        {'N': 128, 'T': 0.001, 'bc_type': 'periodic', 'w_func': lambda x, t: w0_D}\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        errors_no_enf = run_simulation(**case_params, enforce_conservation=False)\n        all_results.extend(errors_no_enf)\n\n        errors_enf = run_simulation(**case_params, enforce_conservation=True)\n        all_results.extend(errors_enf)\n    \n    print(f\"[{','.join(f'{r:.15e}' for r in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}