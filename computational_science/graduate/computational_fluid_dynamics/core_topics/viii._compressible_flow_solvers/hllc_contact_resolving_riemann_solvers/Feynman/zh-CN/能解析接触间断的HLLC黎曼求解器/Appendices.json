{
    "hands_on_practices": [
        {
            "introduction": "理论知识必须通过实践来巩固。在编写复杂的计算流体动力学代码之前，通过手动计算来分解 HLLC 求解器的核心机制是至关重要的。这个练习将引导你逐步完成计算单个界面上 HLLC 数值通量的完整过程，包括估算波速、构建“星区”状态，并最终确定正确的通量分支，从而为你后续的编程实践打下坚实的基础。",
            "id": "3330293",
            "problem": "考虑理想气体的一维欧拉方程，其比热比为 $\\gamma$，守恒变量为 $U = (\\rho,\\ \\rho u,\\ E)^{\\mathsf{T}}$，通量为 $F(U) = \\big(\\rho u,\\ \\rho u^{2} + p,\\ u\\,(E + p)\\big)^{\\mathsf{T}}$，其中 $E = \\dfrac{p}{\\gamma - 1} + \\dfrac{1}{2}\\,\\rho\\,u^{2}$。界面上的黎曼问题具有左右原始状态 $U_{L} = (\\rho_{L}, u_{L}, p_{L})$ 和 $U_{R} = (\\rho_{R}, u_{R}, p_{R})$。假设理想气体的声速为 $a = \\sqrt{\\gamma p/\\rho}$。设数值状态为 $U_{L} = (\\rho_{L}, u_{L}, p_{L}) = (0.8,\\ 1.0,\\ 0.5)$，$U_{R} = (\\rho_{R}, u_{R}, p_{R}) = (1.2,\\ -0.5,\\ 0.7)$，且 $\\gamma = 1.4$。\n\n使用 Harten–Lax–van Leer–Contact (HLLC) 接触间断分解黎曼求解器，确定界面处 HLLC 数值通量的动量通量分量，即 $F_{\\mathrm{HLLC}}(U_{L}, U_{R})$ 的第二个分量，其为一个标量。为使波速估计具体化，使用 Davis 估计来计算边界信号速度，\n$S_{L} = \\min\\{u_{L} - a_{L},\\ u_{R} - a_{R}\\}$ 和 $S_{R} = \\max\\{u_{L} + a_{L},\\ u_{R} + a_{R}\\}$，\n其中 $a_{L} = \\sqrt{\\gamma p_{L}/\\rho_{L}}$ 和 $a_{R} = \\sqrt{\\gamma p_{R}/\\rho_{R}}$。根据波速的符号确定合适的 HLLC 分支，构建由跨波的 Rankine–Hugoniot 条件所施加的星区状态和星区通量，然后计算界面处的 $F_{\\mathrm{HLLC}}$ 的动量通量分量。\n\n将最终数值答案报告为单个无量纲标量，并四舍五入到四位有效数字。",
            "solution": "该问题要求对于一个由给定的左右状态定义的黎曼问题，确定界面处的 Harten–Lax–van Leer–Contact (HLLC) 数值通量 $F_{\\mathrm{HLLC}}$ 的动量通量分量。控制方程为理想气体的一维欧拉方程。\n\n守恒变量向量为 $U = (\\rho, \\rho u, E)^{\\mathsf{T}}$，通量向量为 $F(U) = (\\rho u, \\rho u^2 + p, u(E + p))^{\\mathsf{T}}$。总能量密度 $E$ 通过理想气体的状态方程与压力 $p$ 相关：$E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2$。\n\nHLLC 通量 $F_{\\mathrm{HLLC}}(U_L, U_R)$ 是关于比率 $x/t$ 的分段常数函数，由波速估计值 $S_L$、$S_M$（接触间断）和 $S_R$ 定义。HLLC 通量的公式为：\n$$\nF_{\\mathrm{HLLC}} =\n\\begin{cases}\nF_L  &\\text{if } x/t \\le S_L \\\\\nF_L^*  &\\text{if } S_L \\le x/t \\le S_M \\\\\nF_R^*  &\\text{if } S_M \\le x/t \\le S_R \\\\\nF_R  &\\text{if } x/t \\ge S_R\n\\end{cases}\n$$\n在单元界面处，我们在 $x/t=0$ 处计算通量。使用的具体公式取决于 $S_L$、$S_M$ 和 $S_R$ 的符号。我们必须首先计算这些波速。\n\n给定的原始变量为：\n左状态：$(\\rho_L, u_L, p_L) = (0.8, 1.0, 0.5)$\n右状态：$(\\rho_R, u_R, p_R) = (1.2, -0.5, 0.7)$\n比热比：$\\gamma = 1.4$\n\n首先，我们使用公式 $a = \\sqrt{\\gamma p / \\rho}$ 计算左右状态的声速。\n$$ a_L = \\sqrt{\\frac{\\gamma p_L}{\\rho_L}} = \\sqrt{\\frac{1.4 \\times 0.5}{0.8}} = \\sqrt{0.875} \\approx 0.935414 $$\n$$ a_R = \\sqrt{\\frac{\\gamma p_R}{\\rho_R}} = \\sqrt{\\frac{1.4 \\times 0.7}{1.2}} = \\sqrt{\\frac{0.98}{1.2}} \\approx 0.903696 $$\n\n接下来，我们计算最快的左行和右行信号速度 $S_L$ 和 $S_R$ 的 Davis 估计值。\n$$ S_L = \\min\\{u_L - a_L, u_R - a_R\\} = \\min\\{1.0 - 0.935414, -0.5 - 0.903696\\} $$\n$$ S_L = \\min\\{0.064586, -1.403696\\} = -1.403696 $$\n$$ S_R = \\max\\{u_L + a_L, u_R + a_R\\} = \\max\\{1.0 + 0.935414, -0.5 + 0.903696\\} $$\n$$ S_R = \\max\\{1.935414, 0.403696\\} = 1.935414 $$\n\n现在，我们计算接触波的速度 $S_M$。其公式是通过强制星区中的压力 $p_L^*$ 和 $p_R^*$ 相等来推导的。\n$$ S_M = \\frac{p_R - p_L + \\rho_L u_L (S_L - u_L) - \\rho_R u_R (S_R - u_R)}{\\rho_L (S_L - u_L) - \\rho_R (S_R - u_R)} $$\n我们计算分子和分母中的各项：\n分子：\n$$ N = (0.7 - 0.5) + (0.8)(1.0)( -1.403696 - 1.0) - (1.2)(-0.5)(1.935414 - (-0.5)) $$\n$$ N = 0.2 + 0.8(-2.403696) - (-0.6)(2.435414) $$\n$$ N = 0.2 - 1.922957 + 1.461248 = -0.261709 $$\n分母：\n$$ D = 0.8(-2.403696) - 1.2(2.435414) $$\n$$ D = -1.922957 - 2.922497 = -4.845454 $$\n因此，接触波的速度为：\n$$ S_M = \\frac{-0.261709}{-4.845454} \\approx 0.054012 $$\n\n根据波速 $S_L \\approx -1.404$、$S_M \\approx 0.054$ 和 $S_R \\approx 1.935$，我们可以确定包含界面 $x/t=0$ 的区域。我们观察到 $S_L \\le 0 \\le S_M$。因此，合适的通量是左星区的通量 $F_L^*$。\n\n问题要求该通量向量的第二个分量，即动量通量。星区 $K \\in \\{L, R\\}$ 中的通量向量由 $F_K^* = (\\rho_K^* S_M, \\rho_K^* S_M^2 + p^*, S_M(E_K^* + p^*))^{\\mathsf{T}}$ 给出，其中 $u^*=S_M$ 和 $p^*$ 是星区中的均匀速度和压力。动量通量分量是第二个分量：\n$$ (F_L^*)_2 = \\rho_L^* S_M^2 + p^* $$\n我们需要计算左星区中的压力 $p^*$ 和密度 $\\rho_L^*$。\n压力 $p^*$ 由跨越 $S_L$ 波的 Rankine-Hugoniot 条件给出：\n$$ p^* = p_L + \\rho_L(S_L - u_L)(S_M - u_L) $$\n$$ p^* = 0.5 + 0.8(-1.403696 - 1.0)(0.054012 - 1.0) $$\n$$ p^* = 0.5 + 0.8(-2.403696)(-0.945988) $$\n$$ p^* = 0.5 + 1.819397 \\approx 2.31940 $$\n\n密度 $\\rho_L^*$ 可从跨越 $S_L$ 波的质量守恒跳跃条件中得到：\n$$ \\rho_L^* = \\rho_L \\frac{S_L - u_L}{S_L - S_M} $$\n$$ \\rho_L^* = 0.8 \\frac{-1.403696 - 1.0}{-1.403696 - 0.054012} = 0.8 \\frac{-2.403696}{-1.457708} $$\n$$ \\rho_L^* = 0.8 \\times 1.64901 \\approx 1.31921 $$\n\n最后，我们计算动量通量分量：\n$$ (F_L^*)_2 = p^* + \\rho_L^* S_M^2 $$\n$$ (F_L^*)_2 \\approx 2.31940 + (1.31921)(0.054012)^2 $$\n$$ (F_L^*)_2 \\approx 2.31940 + (1.31921)(0.0029173) $$\n$$ (F_L^*)_2 \\approx 2.31940 + 0.003848 $$\n$$ (F_L^*)_2 \\approx 2.323248 $$\n将结果四舍五入到四位有效数字，得到 $2.323$。",
            "answer": "$$\\boxed{2.323}$$"
        },
        {
            "introduction": "HLLC 求解器名称中的“C”代表“接触（Contact）”，这正是其相较于 HLLE 等更简单方案的核心优势所在。本练习设计为一个数值实验，旨在揭示精确估计接触波速 $S_M$ 的重要性。通过在一个纯接触间断问题中人为地扰动 $S_M$，你将直接观察到它对被动标量输运的影响，从而深刻理解 HLLC 方案保持物理真实性的内在机理。",
            "id": "3330267",
            "problem": "考虑一个附加了被动平流标量的一维可压缩欧拉方程，该方程作为一个守恒律系统，定义在空间域 $[0,1]$ 和时间 $t \\ge 0$ 上。未知守恒变量向量为 $U = [\\rho, \\rho u, E, \\rho Y]^{\\top}$，其中 $\\rho$ 是密度， $u$ 是速度， $E$ 是总能量密度，而 $Y \\in [0,1]$ 是一个无量纲的被动质量分数。通量为 $F(U) = [\\rho u, \\rho u^{2} + p, u(E + p), \\rho Y u]^{\\top}$，其热力学封闭关系由理想气体定律 $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^{2}\\right)$ 给出，其中 $\\gamma > 1$ 是比热比。被动标量 $Y$ 通过守恒变量 $\\rho Y$ 进行输运，并且不影响欧拉子系统的动力学。\n\n您将为欧拉子系统实现一个采用 Harten-Lax-van Leer-Contact (HLLC) 黎曼求解器的一阶有限体积法，并对被动标量进行一致的守恒通量计算。每个界面上的数值通量必须是由左、右状态构成的三波黎曼扇推导出的 HLLC 通量，并使用根据局部信号速度计算的标准双侧波速界和一个接触波速 $S_M$。为分离接触波的作用，我们研究一个纯接触间断：两侧的压力和速度相等，但密度和被动标量分数不同。因此，精确解是一个以速度 $u$ 移动的单一接触波，其中 $Y$ 被被动平流。在精确算术和精确接触波速估计下，HLLC 求解器不应产生超出初始区间 $[Y_{\\min}, Y_{\\max}]$ 的被动标量值；然而，如果接触波速 $S_M$ 估计不准，$\\rho$ 和 $\\rho Y$ 的守恒更新会变得不一致，并在计算 $Y = (\\rho Y)/\\rho$ 时产生越界。我们通过在每个界面和时间步对接触波速估计引入一个受控扰动 $\\Delta S_M$ 来量化此效应，即将 HLLC 通量中的 $S_M$ 替换为 $S_M' = S_M + \\Delta S_M$。其中 $S_M$ 是从动量和压力平衡推导出的标准 HLLC 接触波速估计，而 $\\Delta S_M$ 是每个测试用例指定的恒定误差。\n\n您的实现必须：\n- 用 $N$ 个宽度为 $\\Delta x = 1/N$ 的均匀单元离散化区域。\n- 在空间上使用周期性边界条件。\n- 使用显式前向欧拉时间积分器，Courant-Friedrichs-Lewy (CFL) 数为 $0.5$，以及自适应时间步长 $\\Delta t = \\text{CFL}\\cdot \\Delta x / \\max_{i} \\lambda_i$，其中 $\\lambda_i$ 是局部界面信号速度（取每个界面上左、右 HLL 速度绝对值的最大值）。\n- 对每个界面黎曼问题，使用左、右守恒状态、给定 $\\gamma$ 的理想气体、基于局部速度和声速的左、右波速 $S_L$ 和 $S_R$ 的 Davis 型双侧估计，以及星区中由压力和动量平衡得出的名义接触波速 $S_M$，来计算欧拉子系统的 HLLC 通量。然后，通过设置 $S_M' = S_M + \\Delta S_M$ 来施加受扰动的接触波速，并在所有守恒量（包括 $\\rho Y$）的 HLLC 星区状态和通量公式中一致地使用 $S_M'$。\n- 在 $x_0 = 0.5$ 处初始化一个单一接触间断，两侧具有均匀的压力和速度，但密度和被动标量不同，具体数值由以下每个测试用例指定。\n- 推进到指定的最终时间 $T$，移动距离不超过区域的一小部分，以避免与第二个周期性间断相互作用。\n\n对于每次模拟，按如下方式定义被动标量过冲。设 $Y_{\\text{num}}(x_i, T)$ 为在时间 $T$ 时单元 $i$ 中的数值被动标量，并设 $Y_{\\min} = \\min(Y_L, Y_R)$ 和 $Y_{\\max} = \\max(Y_L, Y_R)$ 为初始物理界限。定义单元 $i$ 的非负越界量为\n$$\n\\delta_i^{+} = \\max\\{\\,Y_{\\text{num}}(x_i,T) - Y_{\\max},\\, 0\\,\\}, \\quad\n\\delta_i^{-} = \\max\\{\\,Y_{\\min} - Y_{\\text{num}}(x_i,T),\\, 0\\,\\}.\n$$\n然后将标量过冲幅值定义为\n$$\n\\mathcal{O} = \\max_i \\left( \\max\\{ \\delta_i^{+}, \\delta_i^{-} \\} \\right).\n$$\n为将过冲与接触波速误差关联起来，定义归一化灵敏度\n$$\n\\kappa = \\frac{\\mathcal{O}}{|\\Delta S_M| + \\varepsilon},\n$$\n其中 $\\varepsilon = 10^{-12}$ 用于在精确接触情况 $\\Delta S_M = 0$ 时避免除以零。\n\n您的任务是实现上述方法，并为以下五个测试用例中的每一个计算 $(\\mathcal{O}, \\kappa)$。所有用例均使用 $N = 200$ 个单元，$\\text{CFL} = 0.5$ 以及最终时间 $T = 0.001$ 秒。所有物理量均采用国际单位制（SI）：密度单位为 $\\text{kg}/\\text{m}^3$，速度单位为 $\\text{m}/\\text{s}$，压力单位为 $\\text{Pa}$，时间单位为 $\\text{s}$。输出 $\\mathcal{O}$ 和 $\\kappa$ 是无量纲的。\n\n测试套件（每个用例指定 $(\\rho_L, \\rho_R, u, p, Y_L, Y_R, \\gamma, \\Delta S_M)$）：\n- 用例 1: $(1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, 0.0)$\n- 用例 2: $(1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, 50.0)$\n- 用例 3: $(1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, -50.0)$\n- 用例 4: $(0.5, 5.0, 50.0, 100000.0, 0.0, 1.0, 1.4, 30.0)$\n- 用例 5: $(1.0, 3.0, 0.0, 100000.0, 0.1, 0.9, 1.4, 30.0)$\n\n算法要求和验收标准：\n- 从守恒律原理和理想气体关系出发；不要引入除上述规定之外的额外数值限制器或后处理。\n- 必须使用 HLLC 黎曼求解器进行通量计算，并且受扰动的接触波速 $S_M' = S_M + \\Delta S_M$ 必须在星区状态构建和所有守恒变量的通量计算中被一致地应用。\n- 对每个测试用例，报告两个浮点数：过冲幅值 $\\mathcal{O}$ 和归一化灵敏度 $\\kappa$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按 $[\\mathcal{O}_1, \\kappa_1, \\mathcal{O}_2, \\kappa_2, \\mathcal{O}_3, \\kappa_3, \\mathcal{O}_4, \\kappa_4, \\mathcal{O}_5, \\kappa_5]$ 的顺序排列。\n\n您的程序必须是一个完整的、可运行的实现，它能产生所要求的单行输出，不包含任何额外文本。",
            "solution": "该问题要求实现一个一阶有限体积法，用以求解增广了被动平流标量的一维欧拉方程。该方法的核心是 Harten-Lax-van Leer-Contact (HLLC) 黎曼求解器，其中接触波速的估计值被有意地扰动，以研究其对被动标量正性的影响。\n\n### 1. 控制方程\n\n守恒律系统由 $\\partial_t U + \\partial_x F(U) = 0$ 给出，其中 $U$ 是守恒变量向量，$F(U)$ 是通量向量。它们定义如下：\n$$\nU = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\\\ \\rho Y \\end{pmatrix}, \\quad F(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E+p) \\\\ \\rho u Y \\end{pmatrix}\n$$\n这里，$\\rho$ 是质量密度，$u$ 是流体速度，$E$ 是单位体积的总能量，$Y$ 是被动标量的质量分数，且 $Y \\in [0, 1]$。该系统由理想气体状态方程封闭，该方程将压力 $p$ 与守恒变量联系起来：\n$$\np = (\\gamma - 1) \\left( E - \\frac{1}{2}\\rho u^2 \\right) = (\\gamma - 1) \\left( E - \\frac{(\\rho u)^2}{2\\rho} \\right)\n$$\n其中 $\\gamma$ 是比热比。第四个方程 $\\partial_t(\\rho Y) + \\partial_x(\\rho u Y) = 0$ 描述了标量 $Y$ 的被动平流。\n\n### 2. 有限体积离散化\n\n空间域 $[0, 1]$ 被离散化为 $N$ 个均匀单元，由 $i$ 索引，每个单元宽度为 $\\Delta x = 1/N$。在时间 $t$ 的单元平均守恒量表示为 $U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} U(x, t) dx$。单元 $i$ 的半离散有限体积格式为：\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。我们使用显式前向欧拉方法进行时间积分：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n时间步长 $\\Delta t$ 自适应地选择以满足 Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_{j} |\\lambda_{\\max, j}|}\n$$\n其中 $\\text{CFL}=0.5$，而 $|\\lambda_{\\max, j}|$ 是所有界面 $j$ 上的最大波速（的绝对值）。\n\n### 3. HLLC 黎曼求解器\n\n数值通量 $F_{i+1/2}$ 是通过求解界面处的黎曼问题来计算的，其左状态为 $U_L = U_i^n$，右状态为 $U_R = U_{i+1}^n$。HLLC 黎曼求解器用一个三波模型来近似解，该模型由一个左行波、一个右行波以及在它们之间移动的接触间断组成。\n\n#### 3.1. 波速估计\n首先，我们将左（$L$）和右（$R$）守恒状态 $U_K$（其中 $K \\in \\{L, R\\}$）转换为原始变量 $W_K = [\\rho_K, u_K, p_K, Y_K]^\\top$。每个状态下的声速为 $c_K = \\sqrt{\\gamma p_K / \\rho_K}$。最左侧（$S_L$）和最右侧（$S_R$）波的速度使用 Davis 公式进行估计：\n$$\nS_L = \\min(u_L - c_L, u_R - c_R)\n$$\n$$\nS_R = \\max(u_L + c_L, u_R + c_R)\n$$\n\n#### 3.2. 受扰动的接触波速\nHLLC 求解器引入了一个中间波，即速度为 $S_M$ 的接触间断。$S_M$ 的标准估计值由跨越星区的动量和压力平衡推导得出：\n$$\nS_M = \\frac{p_R - p_L + \\rho_L u_L (S_L - u_L) - \\rho_R u_R (S_R - u_R)}{\\rho_L(S_L - u_L) - \\rho_R(S_R - u_R)}\n$$\n对于纯接触间断的特定初始条件（$p_L=p_R$，$u_L=u_R=u$），此公式简化为 $S_M = u$，即精确的接触波速。该问题要求对此估计引入一个受控扰动 $\\Delta S_M$。受扰动的接触波速 $S_M'$ 在整个 HLLC 通量计算中使用：\n$$\nS_M' = S_M + \\Delta S_M\n$$\n\n#### 3.3. 星区状态与通量\nHLLC 近似在波之间的区域定义了两个中间“星区”状态 $U_L^*$ 和 $U_R^*$。在整个星区中，压力 $p^*$ 和速度 $u^*$ 是恒定的，且 $u^*=S_M'$。压力 $p^*$ 是通过确保跨越左、右波的 Rankine-Hugoniot 条件的一致性来求得的：\n$$\np^* = p_L + \\rho_L (u_L - S_L)(u_L - S_M') = p_R + \\rho_R(u_R - S_R)(u_R - S_M')\n$$\n我们可以用左状态来计算 $p^*$。然后可以计算星区状态 $U_K^*$（对于 $K=L,R$）。一种有效的方法是首先定义一个辅助向量 $P^* = [0, p^*, p^*S_M', 0]^\\top$，然后计算：\n$$\nU_K^* = \\frac{S_K U_K - F(U_K) + P^*}{S_K - S_M'}\n$$\n该公式正确地构造了星区状态，包括守恒的被动标量 $(\\rho Y)_K^* = \\rho_K^* Y_K$，因为 $Y$ 在接触波上是恒定的（$Y_L^* = Y_L, Y_R^* = Y_R$），并且 $P^*$ 的第四个分量为零。星区中的密度为 $\\rho_K^* = \\rho_K \\frac{S_K - u_K}{S_K - S_M'}$。当 $S_M'$ 不是真实的接触波速时，$\\rho$ 和 $\\rho Y$ 的更新会变得不一致，可能导致 $Y = (\\rho Y)/\\rho$ 出现非物理值。\n\n最终的 HLLC 数值通量 $F_{HLLC}$ 由界面（速度为 $0$）相对于波速 $S_L$、$S_M'$ 和 $S_R$ 的位置决定：\n$$\nF_{HLLC} = \\begin{cases}\n    F_L = F(U_L)  &\\text{if } 0 \\le S_L \\\\\n    F_L^* = F_L + S_L(U_L^* - U_L)  &\\text{if } S_L \\le 0 \\le S_M' \\\\\n    F_R^* = F_R + S_R(U_R^* - U_R)  &\\text{if } S_M' \\le 0 \\le S_R \\\\\n    F_R = F(U_R)  &\\text{if } S_R \\le 0\n\\end{cases}\n$$\n\n### 4. 模拟与分析\n\n对于每个测试用例，算法按以下步骤进行：\n1.  **初始化**：在包含 $N=200$ 个单元的网格上设置一个分段常数的初始状态，间断位于 $x=0.5$。对于中心点 $x_i  0.5$ 的单元，状态为 $(\\rho_L, u, p, Y_L)$；对于 $x_i \\ge 0.5$ 的单元，状态为 $(\\rho_R, u, p, Y_R)$。将这些原始变量转换为守恒变量向量 $U$。\n2.  **时间推进**：将系统从 $t=0$ 演化到最终时间 $T=0.001$。在每个时间步中：\n    a.  考虑周期性边界条件，计算所有界面上的最大波速 $|\\lambda_{\\max}|$。\n    b.  使用 CFL 条件计算时间步长 $\\Delta t$。\n    c.  对每个界面，使用指定的 $\\Delta S_M$ 计算 HLLC 通量 $F_{i+1/2}$。\n    d.  使用前向欧拉方法更新所有单元的状态向量 $U_i$。\n3.  **后处理**：在时间 $T$，计算逐单元的被动标量 $Y_{\\text{num}}(x_i, T) = (\\rho Y)_i / \\rho_i$。\n4.  **指标计算**：确定初始标量的最小值和最大值 $Y_{\\min}$ 和 $Y_{\\max}$。按问题陈述中定义的方式计算过冲幅值 $\\mathcal{O}$ 和归一化灵敏度 $\\kappa$：\n    $$\n    \\mathcal{O} = \\max_i \\left( \\max\\{ Y_{\\text{num}}(x_i,T) - Y_{\\max}, 0 \\}, \\max\\{ Y_{\\min} - Y_{\\text{num}}(x_i,T), 0 \\} \\right)\n    $$\n    $$\n    \\kappa = \\frac{\\mathcal{O}}{|\\Delta S_M| + \\varepsilon}, \\quad \\text{with } \\varepsilon = 10^{-12}\n    $$\n为五个测试用例中的每一个计算配对 $(\\mathcal{O}, \\kappa)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function to run the CFD simulation for all test cases.\n    \"\"\"\n\n    def primitive_to_conserved(W, gamma):\n        \"\"\"Converts primitive variables [rho, u, p, Y] to conserved [rho, rho*u, E, rho*Y].\"\"\"\n        rho, u, p, Y = W\n        U = np.zeros(4)\n        U[0] = rho\n        U[1] = rho * u\n        U[2] = p / (gamma - 1.0) + 0.5 * rho * u**2\n        U[3] = rho * Y\n        return U\n\n    def conserved_to_primitive(U, gamma):\n        \"\"\"Converts conserved variables [rho, rho*u, E, rho*Y] to primitive [rho, u, p, Y].\"\"\"\n        W = np.zeros(4)\n        rho = U[0]\n        if rho = 0: # Avoid division by zero or negative density\n            return np.array([1e-9, 0.0, 1e-9, 0.0])\n        \n        u = U[1] / rho\n        p = (gamma - 1.0) * (U[2] - 0.5 * rho * u**2)\n        Y = U[3] / rho\n        W[0] = rho\n        W[1] = u\n        W[2] = p if p > 0 else 1e-9\n        W[3] = Y\n        return W\n\n    def get_flux(U, gamma):\n        \"\"\"Computes the flux vector F(U).\"\"\"\n        F = np.zeros(4)\n        rho, u, p, _ = conserved_to_primitive(U, gamma)\n        E = U[2]\n        rhoY = U[3]\n\n        F[0] = rho * u\n        F[1] = rho * u**2 + p\n        F[2] = u * (E + p)\n        F[3] = u * rhoY\n        return F\n\n    def hllc_flux(U_L, U_R, gamma, delta_S_M):\n        \"\"\"Computes the HLLC flux given left and right states.\"\"\"\n        W_L = conserved_to_primitive(U_L, gamma)\n        W_R = conserved_to_primitive(U_R, gamma)\n\n        rho_L, u_L, p_L, Y_L = W_L\n        rho_R, u_R, p_R, Y_R = W_R\n\n        c_L = np.sqrt(gamma * p_L / rho_L)\n        c_R = np.sqrt(gamma * p_R / rho_R)\n\n        # Davis wave speed estimates\n        S_L = min(u_L - c_L, u_R - c_R)\n        S_R = max(u_L + c_L, u_R + c_R)\n        \n        # Nominal contact wave speed\n        num_S_M = p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)\n        den_S_M = rho_L * (S_L - u_L) - rho_R * (S_R - u_R)\n        S_M = num_S_M / den_S_M if abs(den_S_M) > 1e-9 else (u_L + u_R) / 2.0\n\n        # Perturbed contact wave speed\n        S_M_prime = S_M + delta_S_M\n\n        if 0.0 = S_L:\n            return get_flux(U_L, gamma)\n        if S_R = 0.0:\n            return get_flux(U_R, gamma)\n\n        # Pressure in the star region\n        p_star = p_L + rho_L * (u_L - S_L) * (u_L - S_M_prime)\n\n        F_L = get_flux(U_L, gamma)\n        F_R = get_flux(U_R, gamma)\n\n        if S_L  0.0 = S_M_prime:\n            P_star_vec = np.array([0., p_star, p_star * S_M_prime, 0.])\n            den = S_L - S_M_prime\n            if abs(den)  1e-9: den = -1e-9\n            U_L_star = (S_L * U_L - F_L + P_star_vec) / den\n            return F_L + S_L * (U_L_star - U_L)\n        \n        elif S_M_prime  0.0 = S_R:\n            P_star_vec = np.array([0., p_star, p_star * S_M_prime, 0.])\n            den = S_R - S_M_prime\n            if abs(den)  1e-9: den = 1e-9\n            U_R_star = (S_R * U_R - F_R + P_star_vec) / den\n            return F_R + S_R * (U_R_star - U_R)\n            \n        return np.zeros(4) # Should not be reached with proper S_L, S_R estimates\n\n    # Simulation parameters\n    N = 200\n    CFL = 0.5\n    T_final = 0.001\n    epsilon = 1e-12\n    domain_length = 1.0\n    dx = domain_length / N\n\n    test_cases = [\n        # (rho_L, rho_R, u, p, Y_L, Y_R, gamma, delta_S_M)\n        (1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, 0.0),\n        (1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, 50.0),\n        (1.0, 2.0, 200.0, 100000.0, 0.2, 0.8, 1.4, -50.0),\n        (0.5, 5.0, 50.0, 100000.0, 0.0, 1.0, 1.4, 30.0),\n        (1.0, 3.0, 0.0, 100000.0, 0.1, 0.9, 1.4, 30.0)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        rho_L, rho_R, u_contact, p_contact, Y_L, Y_R, gamma, delta_S_M = case\n\n        # Initial conditions\n        W_L = np.array([rho_L, u_contact, p_contact, Y_L])\n        W_R = np.array([rho_R, u_contact, p_contact, Y_R])\n        U_L = primitive_to_conserved(W_L, gamma)\n        U_R = primitive_to_conserved(W_R, gamma)\n\n        U = np.zeros((4, N))\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Discontinuity at x=0.5\n        U[:, x  0.5] = U_L[:, np.newaxis]\n        U[:, x >= 0.5] = U_R[:, np.newaxis]\n\n        t = 0.0\n        while t  T_final:\n            max_lambda = 0.0\n            \n            # Calculate max wave speed for dt\n            for i in range(N):\n                U_i = U[:, i]\n                U_j = U[:, (i + 1) % N]\n                W_i = conserved_to_primitive(U_i, gamma)\n                W_j = conserved_to_primitive(U_j, gamma)\n                \n                c_i = np.sqrt(gamma * W_i[2] / W_i[0])\n                c_j = np.sqrt(gamma * W_j[2] / W_j[0])\n\n                s_l_local = min(W_i[1] - c_i, W_j[1] - c_j)\n                s_r_local = max(W_i[1] + c_i, W_j[1] + c_j)\n                max_lambda = max(max_lambda, abs(s_l_local), abs(s_r_local))\n            \n            dt = CFL * dx / max_lambda if max_lambda > 0 else T_final\n            if t + dt > T_final:\n                dt = T_final - t\n            \n            # Compute fluxes at interfaces\n            fluxes = np.zeros((4, N))\n            for i in range(N):\n                U_i_L = U[:, i]\n                U_i_R = U[:, (i + 1) % N]\n                fluxes[:, i] = hllc_flux(U_i_L, U_i_R, gamma, delta_S_M)\n            \n            # Update states\n            U_next = np.copy(U)\n            for i in range(N):\n                flux_L = fluxes[:, (i - 1 + N) % N]\n                flux_R = fluxes[:, i]\n                U_next[:, i] = U[:, i] - (dt / dx) * (flux_R - flux_L)\n            \n            U = U_next\n            t += dt\n\n        # Post-processing\n        Y_num = U[3, :] / U[0, :]\n        Y_min_init = min(Y_L, Y_R)\n        Y_max_init = max(Y_L, Y_R)\n\n        overshoot = np.maximum(Y_num - Y_max_init, 0.0)\n        undershoot = np.maximum(Y_min_init - Y_num, 0.0)\n        \n        O = np.max(np.maximum(overshoot, undershoot))\n        kappa = O / (abs(delta_S_M) + epsilon)\n        \n        results.extend([O, kappa])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了 HLLC 通量的计算方法和核心原理后，下一步是将其应用于一个完整的流体动力学求解器中。这个综合性练习要求你构建一个一维有限体积程序，并用它来评估和比较 HLLC 与其前身 HLLE 求解器在处理强激波问题时的表现。通过计算和分析离散熵产，你将验证数值格式是否遵循物理上的熵增原理，并量化 HLLC 在减少数值耗散、更精确捕捉激波结构方面的优势。",
            "id": "3330274",
            "problem": "你需要设计并实现一个用于求解可压缩欧拉方程的一维有限体积法求解器，以计算数值捕捉的激波剖面上的离散熵产生，并比较四种近似黎曼求解器的组合：Harten-Lax-van Leer-Einfeldt (HLLE) 和 Harten-Lax-van Leer-Contact (HLLC)，每种求解器都分别在有和没有 Harten 熵修正的情况下使用。目标是评估对于强激波，哪种组合能最好地满足熵不等式。该求解器必须对理想气体的守恒变量进行演化，并根据最后两个时间层级的数据计算离散熵产生量。\n\n控制方程为理想气体的一维欧拉方程守恒形式，\n$$\n\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0,\n$$\n其中守恒变量为\n$$\n\\mathbf{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ E \\end{bmatrix},\n$$\n通量为\n$$\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E + p) \\end{bmatrix}.\n$$\n理想气体状态方程为\n$$\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right),\n$$\n其中 $\\rho$ 是密度，$u$ 是速度，$E$ 是总能量密度，$p$ 是压力，$\\gamma$ 是绝热指数。使用 $\\gamma = 1.4$。\n\n对于数值近似，在单位长度域 $x \\in [0,1]$ 上使用包含 $N_x$ 个单元的均匀网格，用左右两个常数状态初始化一个黎曼问题，并使用根据 Courant-Friedrichs-Lewy (CFL) 条件计算出的稳定时间步长，通过守恒显式有限体积法进行更新演化。在两端应用透射（零梯度）边界条件。在每个界面上，使用 HLLE 或 HLLC 计算数值通量。对于带有熵修正的版本，对估算的左右波速应用经典的 Harten 熵修正，如下所示：如果波速 $S$ 满足 $|S|  \\delta$，则设置\n$$\nS \\leftarrow \\tfrac{1}{2}\\left(\\frac{S^2}{\\delta} + \\delta\\right),\n$$\n其中\n$$\n\\delta = k \\max(a_L, a_R),\n$$\n$a_L$ 和 $a_R$ 是界面左右状态的声速，并使用 $k = 0.1$。对于不带熵修正的版本，使用未经修改的波速。Harten 熵修正应用于 HLLE 和 HLLC 使用的左右波速；不要修改 HLLC 使用的接触波速。\n\n将理想气体的比熵（不考虑加法和乘法常数）定义为\n$$\ns = \\ln(p) - \\gamma \\ln(\\rho),\n$$\n并定义数学熵和熵通量对\n$$\n\\eta = -\\frac{\\rho s}{\\gamma - 1}, \\qquad q = -\\frac{\\rho u s}{\\gamma - 1}.\n$$\n对于光滑解，该熵对满足\n$$\n\\partial_t \\eta + \\partial_x q = 0,\n$$\n而对于激波，熵不等式要求\n$$\n\\partial_t \\eta + \\partial_x q \\le 0.\n$$\n根据计算出的离散解，将最后一个时间步长内的域积分熵产生构造为\n$$\n\\mathcal{P} = \\sum_{i=1}^{N_x} \\left(-\\frac{\\eta_i^{n+1} - \\eta_i^{n}}{\\Delta t} - \\frac{Q_{i+\\frac{1}{2}}^{n} - Q_{i-\\frac{1}{2}}^{n}}{\\Delta x}\\right)\\Delta x,\n$$\n其中 $Q_{i+\\frac{1}{2}}^{n}$ 是界面处熵通量的一个相容数值近似，你必须将其实现为算术平均\n$$\nQ_{i+\\frac{1}{2}}^{n} = \\tfrac{1}{2}\\left(q_i^n + q_{i+1}^n\\right).\n$$\n一个满足熵不等式的求解器应得出 $\\mathcal{P} \\ge 0$，且其主要由集中在激波处的熵产生贡献。\n\n实现以下测试套件。所有量均为无量纲；将所有输出报告为无量纲的原始浮点数。对每个算例，使用规定的网格尺寸和最终时间，CFL 数为 $\\text{CFL} = 0.5$：\n\n- 测试算例 A（强激波，标准网格）：左状态 $(\\rho_L, u_L, p_L) = (10, 0, 1000)$，右状态 $(\\rho_R, u_R, p_R) = (1, 0, 1)$，单元数 $N_x = 200$，最终时间 $T = 0.005$。\n- 测试算例 B（强激波，粗网格）：左状态 $(\\rho_L, u_L, p_L) = (10, 0, 1000)$，右状态 $(\\rho_R, u_R, p_R) = (1, 0, 1)$，单元数 $N_x = 50$，最终时间 $T = 0.005$。\n- 测试算例 C（中等强度激波，标准网格）：左状态 $(\\rho_L, u_L, p_L) = (1, 0, 10)$，右状态 $(\\rho_R, u_R, p_R) = (1, 0, 1)$，单元数 $N_x = 200$，最终时间 $T = 0.005$。\n\n对每个测试算例，按此顺序计算并返回四个值：\n1. 使用 HLLE 且无熵修正时的 $\\mathcal{P}$，\n2. 使用 HLLE 且带熵修正时的 $\\mathcal{P}$，\n3. 使用 HLLC 且无熵修正时的 $\\mathcal{P}$，\n4. 使用 HLLC 且带熵修正时的 $\\mathcal{P}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表包含三个子列表（每个测试算例一个），每个子列表按指定顺序包含四个浮点数结果。例如，输出格式必须为\n$$\n[\\,[r_{A,1}, r_{A,2}, r_{A,3}, r_{A,4}],\\,[r_{B,1}, r_{B,2}, r_{B,3}, r_{B,4}],\\,[r_{C,1}, r_{C,2}, r_{C,3}, r_{C,4}]\\,].\n$$",
            "solution": "我们从一维欧拉方程开始，该方程表达了理想气体的质量、动量和能量守恒。守恒变量为 $\\mathbf{U} = [\\rho, \\rho u, E]^T$，通量为 $\\mathbf{F}(\\mathbf{U}) = [\\rho u, \\rho u^2 + p, u(E + p)]^T$，并由理想气体状态方程 $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)$ 封闭该方程组。我们将区域 $x \\in [0,1]$ 离散为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的均匀单元，并使用显式守恒有限体积法在时间上进行演化，\n$$\n\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\hat{\\mathbf{F}}_{i+\\frac{1}{2}}^n - \\hat{\\mathbf{F}}_{i-\\frac{1}{2}}^n\\right),\n$$\n其中 $\\hat{\\mathbf{F}}_{i+\\frac{1}{2}}^n$ 是在时间层级 $n$ 时，单元 $i$ 和 $i+1$ 之间界面上的数值通量。稳定的时间步长由 Courant-Friedrichs-Lewy 条件选择，\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_i \\left(|u_i| + a_i\\right)},\n$$\n其中声速 $a_i = \\sqrt{\\gamma p_i / \\rho_i}$，且 $\\text{CFL} = 0.5$。通过将邻近边界的状态复制到虚拟单元来实施透射边界条件，从而使边界上的空间导数为零。\n\n为了近似界面处的通量，我们采用两种能解析接触间断的近似黎曼求解器：HLLE (Harten-Lax-van Leer with Einfeldt speeds) 和 HLLC (Harten-Lax-van Leer-Contact)。两种求解器都依赖于对左右信号速度的估计，记为 $S_L$ 和 $S_R$。这些速度通常通过限制最快的左行和右行特征波来导出，使用\n$$\nS_L = \\min\\left(u_L - a_L, u_R - a_R\\right), \\qquad S_R = \\max\\left(u_L + a_L, u_R + a_R\\right),\n$$\n其中 $u_L, a_L$ 和 $u_R, a_R$ 分别是界面左右状态的速度和声速。HLLE 使用这两个速度构造一个单一的中间状态，该状态与跨越两道波扇的 Rankine-Hugoniot 跳跃条件相容，从而产生一个稳健的、保持正定性的通量，但该通量往往具有耗散性。HLLC 在此基础上增加了一个接触波速 $S_M$；两侧的中间“星区”状态被构造成在跨越 $S_M$ 时保持接触间断（密度和速度）和压力的一致性，这显著减少了耗散，并能更清晰地解析接触间断和剪切波。\n\n对于 HLLC，接触波速 $S_M$ 是通过对左右波应用 Rankine-Hugoniot 条件，强制星区的动量和压力一致性来推导的。其结果是一个以左右原始变量以及 $S_L, S_R$ 表示的 $S_M$ 表达式。然后通过应用跳跃条件获得星区状态的守恒变量及其对应的通量：\n$$\n\\rho_L^\\ast = \\rho_L \\frac{S_L - u_L}{S_L - S_M}, \\quad p^\\ast = p_L + \\rho_L (S_L - u_L)(S_M - u_L),\n$$\n右星区状态有类似的表达式，星区通量由以下方式构造\n$$\n\\mathbf{F}_L^\\ast = \\mathbf{F}_L + S_L\\left(\\mathbf{U}_L^\\ast - \\mathbf{U}_L\\right), \\qquad\n\\mathbf{F}_R^\\ast = \\mathbf{F}_R + S_R\\left(\\mathbf{U}_R^\\ast - \\mathbf{U}_R\\right).\n$$\nHLLC 通量 $\\hat{\\mathbf{F}}$ 根据 $S_L$, $S_M$ 和 $S_R$ 的符号从 $\\mathbf{F}_L$、$\\mathbf{F}_L^\\ast$、$\\mathbf{F}_R^\\ast$ 或 $\\mathbf{F}_R$ 中选择。\n\nHarten 熵修正通过修改声速点附近的波速，使其平滑过渡并避免伪压缩，从而解决了跨音速稀疏波中的非物理解，因而在离散层面上强制满足熵不等式。给定波速 $S$ 和局部声速 $a_L$ 和 $a_R$，应用\n$$\nS \\leftarrow \\begin{cases}\n\\tfrac{1}{2}\\left(\\frac{S^2}{\\delta} + \\delta\\right),  |S|  \\delta,\\\\\nS,  \\text{otherwise},\n\\end{cases}\n\\quad \\text{with} \\quad \\delta = k \\max(a_L, a_R),\n$$\n其中 $k$ 是一个小参数；此处，$k = 0.1$。此修正应用于 $S_L$ 和 $S_R$；$S_M$ 保持不变。\n\n为评估哪种求解器满足熵不等式，我们计算最后一个时间步长的离散熵产生量。对于理想气体，一个方便的熵对是\n$$\ns = \\ln(p) - \\gamma \\ln(\\rho), \\qquad \\eta = -\\frac{\\rho s}{\\gamma - 1}, \\qquad q = -\\frac{\\rho u s}{\\gamma - 1}.\n$$\n针对激波的熵不等式表明\n$$\n\\partial_t \\eta + \\partial_x q \\le 0,\n$$\n意味着物理熵在穿过激波时增加。在离散形式下，我们定义最后一个时间步长内的域积分熵产生，\n$$\n\\mathcal{P} = \\sum_{i=1}^{N_x} \\left(-\\frac{\\eta_i^{n+1} - \\eta_i^{n}}{\\Delta t} - \\frac{Q_{i+\\frac{1}{2}}^{n} - Q_{i-\\frac{1}{2}}^{n}}{\\Delta x}\\right)\\Delta x,\n$$\n其中 $Q_{i+\\frac{1}{2}}^{n}$ 是界面上的数值熵通量。一个简单的相容近似是算术平均，\n$$\nQ_{i+\\frac{1}{2}}^{n} = \\tfrac{1}{2}\\left(q_i^n + q_{i+1}^n\\right).\n$$\n因此，$\\mathcal{P} \\ge 0$ 表示熵产生，符合不等式的要求；$\\mathcal{P}  0$ 则表示违反了该不等式。\n\n算法设计：\n1. 对于每个测试算例，使用指定的黎曼数据和 $\\gamma = 1.4$ 初始化网格，并通过 $E_i = p_i/(\\gamma - 1) + \\tfrac{1}{2}\\rho_i u_i^2$ 计算初始守恒变量 $\\mathbf{U}_i^0$。\n2. 进行时间循环直到 $t \\ge T$。在每个步长中：\n   - 从 $\\mathbf{U}_i^n$ 计算原始变量。\n   - 计算局部声速 $a_i$ 和最大信号速度，以通过 CFL 条件确定 $\\Delta t$。\n   - 按照规定，使用 HLLE 或 HLLC（带或不带熵修正）计算界面通量。\n   - 使用有限体积法更新 $\\mathbf{U}_i^{n+1}$，通过将虚拟单元设置为与边界相邻的内部单元相等来实施透射边界条件，以避免伪反射。\n3. 存储最后两个时间层级 $\\mathbf{U}_i^{n}$ 和 $\\mathbf{U}_i^{n+1}$。根据 $\\mathbf{U}_i^n$ 和理想气体关系式计算 $\\eta_i^n$、$\\eta_i^{n+1}$ 和 $q_i^n$。\n4. 计算界面熵通量 $Q_{i+\\frac{1}{2}}^{n} = \\tfrac{1}{2}(q_i^n + q_{i+1}^n)$ 并使用上述公式评估 $\\mathcal{P}$。\n5. 对每个测试算例，为四种求解器配置（HLLE 无修正、HLLE 带修正、HLLC 无修正、HLLC 带修正）重复此过程，收集相应的 $\\mathcal{P}$ 值。\n\n科学解释与预期：\n- HLLE 具有更强的耗散性，倾向于在激波处产生稳健的熵增；因此，预计其 $\\mathcal{P}$ 为非负值，且相对于 HLLC 较大。\n- HLLC 能够清晰地解析接触波，由于其减少了人工耗散，可能会产生较低的 $\\mathcal{P}$；然而，在没有熵修正的情况下，在跨音速区域或分辨率不足的激波处，可能会发生小的局部违规，可能在粗网格上或声速点附近产生轻微的负 $\\mathcal{P}$ 值。\n- Harten 熵修正通过平滑接近零的波速来改善此类问题，从而更一致地强制满足熵不等式。使用该修正后，在强激波测试中，HLLE 和 HLLC 都应得出 $\\mathcal{P} \\ge 0$，其中 HLLC 通常表现出较低但为正的熵产生，这表明其数值耗散较低，但仍遵守不等式。\n\n该程序为每种配置计算无量纲标量 $\\mathcal{P}$，按测试算例汇总，并以要求的嵌套列表格式输出。这使得评估可以量化，并能在不同求解器和网格分辨率之间直接比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Euler equations solver with HLLE and HLLC fluxes, optional Harten entropy fix.\n# Computes domain-integrated discrete entropy production over the last time step.\n\nGAMMA = 1.4\n\ndef prim_from_cons(U, gamma):\n    rho = U[0]\n    mom = U[1]\n    E = U[2]\n    u = mom / rho\n    p = (gamma - 1.0) * (E - 0.5 * rho * u * u)\n    return rho, u, p\n\ndef cons_from_prim(rho, u, p, gamma):\n    E = p / (gamma - 1.0) + 0.5 * rho * u * u\n    return np.array([rho, rho * u, E])\n\ndef flux_from_cons(U, gamma):\n    rho, u, p = prim_from_cons(U, gamma)\n    F = np.array([rho * u, rho * u * u + p, u * (U[2] + p)])\n    return F\n\ndef sound_speed(rho, p, gamma):\n    return np.sqrt(gamma * p / max(rho, 1e-16))\n\ndef harten_entropy_fix(S, aL, aR, k=0.1):\n    delta = k * max(aL, aR)\n    if abs(S)  delta:\n        return 0.5 * (S * S / delta + delta)\n    else:\n        return S\n\ndef hlle_flux(UL, UR, gamma, use_entropy_fix=False, k=0.1):\n    rhoL, uL, pL = prim_from_cons(UL, gamma)\n    rhoR, uR, pR = prim_from_cons(UR, gamma)\n    aL = sound_speed(rhoL, pL, gamma)\n    aR = sound_speed(rhoR, pR, gamma)\n    SL = min(uL - aL, uR - aR)\n    SR = max(uL + aL, uR + aR)\n    if use_entropy_fix:\n        SL = harten_entropy_fix(SL, aL, aR, k)\n        SR = harten_entropy_fix(SR, aL, aR, k)\n    FL = flux_from_cons(UL, gamma)\n    FR = flux_from_cons(UR, gamma)\n    if SL >= 0.0:\n        return FL\n    elif SR = 0.0:\n        return FR\n    else:\n        return (SR * FL - SL * FR + SL * SR * (UR - UL)) / (SR - SL + 1e-16)\n\ndef hllc_flux(UL, UR, gamma, use_entropy_fix=False, k=0.1):\n    rhoL, uL, pL = prim_from_cons(UL, gamma)\n    rhoR, uR, pR = prim_from_cons(UR, gamma)\n    aL = sound_speed(rhoL, pL, gamma)\n    aR = sound_speed(rhoR, pR, gamma)\n\n    SL = min(uL - aL, uR - aR)\n    SR = max(uL + aL, uR + aR)\n    if use_entropy_fix:\n        SL = harten_entropy_fix(SL, aL, aR, k)\n        SR = harten_entropy_fix(SR, aL, aR, k)\n\n    FL = flux_from_cons(UL, gamma)\n    FR = flux_from_cons(UR, gamma)\n\n    # Compute contact wave speed SM\n    denom = rhoL * (SL - uL) - rhoR * (SR - uR)\n    # Avoid division by zero\n    if abs(denom)  1e-12:\n        # Fall back to HLLE flux if degenerate\n        return hlle_flux(UL, UR, gamma, use_entropy_fix, k)\n    SM = (pR - pL + rhoL * (SL - uL) * uL - rhoR * (SR - uR) * uR) / denom\n\n    # Left star state\n    rhoL_star = rhoL * (SL - uL) / (SL - SM + 1e-16)\n    p_star_L = pL + rhoL * (SL - uL) * (SM - uL)\n    # Energy star:\n    EL = UL[2]\n    # Using jump condition for energy flux across left wave:\n    EL_star = ((SL - uL) * EL - pL * uL + p_star_L * SM) / (SL - SM + 1e-16)\n    UL_star = np.array([rhoL_star, rhoL_star * SM, EL_star])\n    FL_star = FL + SL * (UL_star - UL)\n\n    # Right star state\n    rhoR_star = rhoR * (SR - uR) / (SR - SM + 1e-16)\n    p_star_R = pR + rhoR * (SR - uR) * (SM - uR)\n    ER = UR[2]\n    ER_star = ((SR - uR) * ER - pR * uR + p_star_R * SM) / (SR - SM + 1e-16)\n    UR_star = np.array([rhoR_star, rhoR_star * SM, ER_star])\n    FR_star = FR + SR * (UR_star - UR)\n\n    if SL >= 0.0:\n        return FL\n    elif SL  0.0 = SM:\n        return FL_star\n    elif SM  0.0 = SR:\n        return FR_star\n    else:\n        return FR\n\ndef compute_dt(U, gamma, dx, cfl):\n    # Compute maximum |u| + a over all cells\n    rho = U[:, 0]\n    u = U[:, 1] / np.maximum(rho, 1e-16)\n    E = U[:, 2]\n    p = (gamma - 1.0) * (E - 0.5 * rho * u * u)\n    a = np.sqrt(np.maximum(gamma * p / np.maximum(rho, 1e-16), 0.0))\n    max_speed = np.max(np.abs(u) + a)\n    if max_speed  1e-12:\n        return 1e-6  # Small dt if stationary\n    return cfl * dx / max_speed\n\ndef apply_transmissive_bc(U):\n    # Transmissive: copy boundary-adjacent interior states to ghost cells if needed\n    # Here we simply ensure the first and last cells are preserved (no explicit ghost cells used).\n    return U\n\ndef step(U, gamma, dx, dt, flux_func):\n    N = U.shape[0]\n    # Compute interface fluxes\n    F_interfaces = np.zeros((N + 1, 3))\n    for i in range(N + 1):\n        if i == 0:\n            UL = U[0].copy()\n            UR = U[0].copy()\n        elif i == N:\n            UL = U[N - 1].copy()\n            UR = U[N - 1].copy()\n        else:\n            UL = U[i - 1]\n            UR = U[i]\n        F_interfaces[i] = flux_func(UL, UR, gamma)\n    # Update\n    U_new = U.copy()\n    for i in range(N):\n        U_new[i] = U[i] - (dt / dx) * (F_interfaces[i + 1] - F_interfaces[i])\n    return apply_transmissive_bc(U_new)\n\ndef compute_entropy_arrays(U, gamma):\n    rho = U[:, 0]\n    u = U[:, 1] / np.maximum(rho, 1e-16)\n    E = U[:, 2]\n    p = (gamma - 1.0) * (E - 0.5 * rho * u * u)\n    # Avoid log of nonpositive numbers\n    p_clamped = np.maximum(p, 1e-16)\n    rho_clamped = np.maximum(rho, 1e-16)\n    s = np.log(p_clamped) - gamma * np.log(rho_clamped)\n    eta = -rho_clamped * s / (gamma - 1.0)\n    q = -rho_clamped * u * s / (gamma - 1.0)\n    return eta, q\n\ndef compute_entropy_production(U_prev, U_curr, gamma, dx, dt):\n    eta_prev, q_prev = compute_entropy_arrays(U_prev, gamma)\n    eta_curr, _ = compute_entropy_arrays(U_curr, gamma)\n    # Interface entropy flux by arithmetic average of q at cell centers\n    Q_interfaces = np.zeros(U_curr.shape[0] + 1)\n    for i in range(U_curr.shape[0] + 1):\n        if i == 0:\n            qi = q_prev[0]\n            qip = q_prev[0]\n        elif i == U_curr.shape[0]:\n            qi = q_prev[-1]\n            qip = q_prev[-1]\n        else:\n            qi = q_prev[i - 1]\n            qip = q_prev[i]\n        Q_interfaces[i] = 0.5 * (qi + qip)\n    # Residual per cell and integrated production\n    production = 0.0\n    for i in range(U_curr.shape[0]):\n        res = - (eta_curr[i] - eta_prev[i]) / dt - (Q_interfaces[i + 1] - Q_interfaces[i]) / dx\n        production += res * dx\n    return float(production)\n\ndef run_case(left, right, Nx, T, gamma, cfl, solver_name, use_entropy_fix):\n    # Initialize\n    x = np.linspace(0.0, 1.0, Nx)\n    U = np.zeros((Nx, 3))\n    for i in range(Nx):\n        if x[i]  0.5:\n            rho, u, p = left\n        else:\n            rho, u, p = right\n        U[i] = cons_from_prim(rho, u, p, gamma)\n    t = 0.0\n    prev_U = U.copy()\n    # Select flux function\n    if solver_name == \"HLLE\":\n        flux_func = (lambda UL, UR, g: hlle_flux(UL, UR, g, use_entropy_fix=use_entropy_fix, k=0.1))\n    elif solver_name == \"HLLC\":\n        flux_func = (lambda UL, UR, g: hllc_flux(UL, UR, g, use_entropy_fix=use_entropy_fix, k=0.1))\n    else:\n        raise ValueError(\"Unknown solver\")\n    # Time integration\n    while t  T:\n        dx = 1.0 / Nx\n        dt = compute_dt(U, gamma, dx, cfl)\n        # Adjust final step\n        if t + dt > T:\n            dt = T - t\n        prev_U = U.copy()\n        U = step(U, gamma, dx, dt, flux_func)\n        t += dt\n    # Compute entropy production over last step\n    production = compute_entropy_production(prev_U, U, gamma, dx, dt)\n    return production\n\ndef solve():\n    # Define the test cases from the problem statement.\n    gamma = GAMMA\n    cfl = 0.5\n\n    test_cases = [\n        # (left_state (rho,u,p), right_state (rho,u,p), Nx, T)\n        ((10.0, 0.0, 1000.0), (1.0, 0.0, 1.0), 200, 0.005),  # Test case A\n        ((10.0, 0.0, 1000.0), (1.0, 0.0, 1.0), 50, 0.005),   # Test case B\n        ((1.0, 0.0, 10.0), (1.0, 0.0, 1.0), 200, 0.005),    # Test case C\n    ]\n\n    results = []\n    for left, right, Nx, T in test_cases:\n        res_case = []\n        # HLLE without entropy fix\n        res_case.append(run_case(left, right, Nx, T, gamma, cfl, solver_name=\"HLLE\", use_entropy_fix=False))\n        # HLLE with entropy fix\n        res_case.append(run_case(left, right, Nx, T, gamma, cfl, solver_name=\"HLLE\", use_entropy_fix=True))\n        # HLLC without entropy fix\n        res_case.append(run_case(left, right, Nx, T, gamma, cfl, solver_name=\"HLLC\", use_entropy_fix=False))\n        # HLLC with entropy fix\n        res_case.append(run_case(left, right, Nx, T, gamma, cfl, solver_name=\"HLLC\", use_entropy_fix=True))\n        results.append(res_case)\n\n    # Format nested list output in a single line\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{val:.8f}\" for val in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(sub) for sub in results) + \"]\"\n    print(output)\n\nsolve()\n```"
        }
    ]
}