{
    "hands_on_practices": [
        {
            "introduction": "为了精确模拟包含激波等间断的流动，数值方法必须在光滑区域具有高阶精度，并在激波阵面附近保持无振荡。本练习的核心是实现五阶加权基本无振荡 (Weighted Essentially Non-Oscillatory, WENO) 格式的重构部分，这是现代激波捕捉方法的基石。通过亲手编写WENO逻辑，您将深入理解这些格式如何自适应地利用信息，以获得清晰、稳定的激波剖面 。",
            "id": "3361322",
            "problem": "考虑一维标量守恒律 $q_t + f(q)_x = 0$，它作为可压缩欧拉方程特征场的一个模型，其中 $q$ 表示一个通用的守恒标量，$f(q)$ 是其物理通量。在空间步长为 $\\Delta x$ 的均匀网格上使用有限体积法时，主要未知量是索引为整数 $i$ 的网格上的平均值 $\\bar{q}_i$。在激波、膨胀波或接触间断附近，从网格平均值重构的点值必须忠实于底层的守恒律，同时避免产生伪振荡。一种广泛使用的方法是加权基本不振荡 (WENO) 重构，特别是五阶加权基本不振荡 (WENO) 格式。\n\n您的任务是：假设网格均匀且特征速度为正（因此适合采用左偏重构），根据网格平均值 $\\bar{q}_{i-2}$、$\\bar{q}_{i-1}$、$\\bar{q}_{i}$、$\\bar{q}_{i+1}$ 和 $\\bar{q}_{i+2}$，推导、实现并评估在界面 $x_{i+\\frac{1}{2}}$ 处左状态的五阶加权基本不振荡 (WENO) 重构。该重构由三个二次候选界面值构成一个凸组合，这些值建立在三个三点子模板 $\\{\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_i\\}$、$\\{\\bar{q}_{i-1},\\bar{q}_i,\\bar{q}_{i+1}\\}$ 和 $\\{\\bar{q}_i,\\bar{q}_{i+1},\\bar{q}_{i+2}\\}$ 之上。非线性权基于光滑度指示子，这些指示子根据数据的局部变化计算得出。其基本定义是：光滑度指示子测量每个候选多项式在网格邻域上导数的 $L^2$ 范数，并惩罚高频内容。\n\n请使用以下规范：\n- 设非线性权中的小正参数为 $\\epsilon = 10^{-6}$，次方为 $p = 2$。\n- 使用与在光滑区域达到形式五阶精度相一致的均匀线性权。\n- 将给定的五个网格平均值视为重构 $x_{i+\\frac{1}{2}}$ 处左状态的唯一可用数据；除WENO机制外，不要引入任何额外的耗散或限制器。\n\n您必须实现一个完整的、可运行的程序，该程序为每个提供的测试用例计算：\n- 三个光滑度指示子 $\\beta_k$，其中 $k \\in \\{0,1,2\\}$。\n- 从光滑度指示子和线性权获得的三个非线性权 $\\omega_k$，其中 $k \\in \\{0,1,2\\}$。\n- 在界面 $x_{i+\\frac{1}{2}}$ 处重构的左状态 $q_{i+\\frac{1}{2}}^{-}$。\n\n由于问题是以无量纲形式提出的，因此不需要物理单位。问题不涉及角度和百分比。\n\n测试套件：\n- 情况1（位于网格 $i$ 和 $i+1$ 之间的强激波）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [5.0,5.0,5.0,0.2,0.2]$。\n- 情况2（光滑单调斜坡）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [0.0,0.5,1.0,1.5,2.0]$。\n- 情况3（常数状态）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,1.0,1.0,1.0,1.0]$。\n- 情况4（网格 $i$ 附近的局部极值）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,2.0,3.0,2.0,1.0]$。\n- 情况5（类接触弱跳跃）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,1.0,0.9,0.9,0.9]$。\n\n您的程序应生成单行输出，其中包含上述五种情况的重构界面值 $q_{i+\\frac{1}{2}}^{-}$，格式为方括号内以逗号分隔的列表（例如 $[r_1,r_2,r_3,r_4,r_5]$）。每个 $r_j$ 都必须是浮点数。输出必须是确定性的，使用指定的 $\\epsilon$ 和 $p$ 计算，不得有外部输入或随机性。",
            "solution": "该问题要求推导并实现网格界面处左状态的五阶加权基本不振荡 (WENO) 重构，记为 $q_{i+\\frac{1}{2}}^{-}$。此重构是求解双曲守恒律（如一维标量守恒律 $q_t + f(q)_x = 0$）的高分辨率有限体积格式的基本组成部分。其目标是在解的光滑区域获得高阶精确的近似，同时在激波、膨胀波或接触间断等不连续处保持清晰、无振荡的剖面。该重构基于由五个连续网格平均值组成的模板：$\\{\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_{i}, \\bar{q}_{i+1}, \\bar{q}_{i+2}\\}$。\n\nWENO的核心思想是通过若干个低阶候选近似的凸组合来构造一个高阶近似。组合权重称为非线性权，它根据每个候选模板上数据的局部光滑度动态计算得出。这使得格式能够自适应，为跨越间断的模板分配接近于零的权重，从而防止振荡，同时在光滑区域以特定方式组合候选模板以实现高阶精度。\n\n五阶WENO重构 $q_{i+\\frac{1}{2}}^{-}$ 是三个三阶（二次）重构 $q_{i+\\frac{1}{2}}^{(k)}$（其中 $k \\in \\{0, 1, 2\\}$）的凸组合：\n$$\nq_{i+\\frac{1}{2}}^{-} = \\sum_{k=0}^{2} \\omega_k q_{i+\\frac{1}{2}}^{(k)}\n$$\n此处，$\\omega_k$ 是非线性权。每个候选重构 $q_{i+\\frac{1}{2}}^{(k)}$ 基于从主5点模板中选出的一个独特的三点子模板。对于界面 $x_{i+\\frac{1}{2}}$ 处左状态的重构，子模板选择为向左偏置：\n-   $S_0 = \\{\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_i\\}$\n-   $S_1 = \\{\\bar{q}_{i-1}, \\bar{q}_i, \\bar{q}_{i+1}\\}$\n-   $S_2 = \\{\\bar{q}_i, \\bar{q}_{i+1}, \\bar{q}_{i+2}\\}$\n\n候选重构 $q_{i+\\frac{1}{2}}^{(k)}$ 是在每个子模板上定义的二次多项式在界面 $x_{i+\\frac{1}{2}}$ 处的值。根据保持网格平均值的原则推导出的标准重构公式如下：\n$$\n\\begin{aligned}\nq_{i+\\frac{1}{2}}^{(0)} = \\frac{2}{6}\\bar{q}_{i-2} - \\frac{7}{6}\\bar{q}_{i-1} + \\frac{11}{6}\\bar{q}_{i} \\\\\nq_{i+\\frac{1}{2}}^{(1)} = -\\frac{1}{6}\\bar{q}_{i-1} + \\frac{5}{6}\\bar{q}_{i} + \\frac{2}{6}\\bar{q}_{i+1} \\\\\nq_{i+\\frac{1}{2}}^{(2)} = \\frac{2}{6}\\bar{q}_{i} + \\frac{5}{6}\\bar{q}_{i+1} - \\frac{1}{6}\\bar{q}_{i+2}\n\\end{aligned}\n$$\n\n在流场的光滑区域，为达到五阶精度，非线性权 $\\omega_k$ 必须逼近一组特定的常数值，即线性权 $d_k$。候选重构与这些线性权的组合构成了五阶迎风线性格式。对于所选的左偏模板，这些线性权为：\n$$\nd_0 = \\frac{1}{10}, \\quad d_1 = \\frac{6}{10}, \\quad d_2 = \\frac{3}{10}\n$$\n验证可知，$\\sum_{k=0}^2 d_k = \\frac{1}{10} + \\frac{6}{10} + \\frac{3}{10} = 1$。当使用这些权重时，得到的重构为 $\\sum_{k=0}^2 d_k q_{i+\\frac{1}{2}}^{(k)} = \\frac{1}{60}(2\\bar{q}_{i-2} - 13\\bar{q}_{i-1} + 47\\bar{q}_{i} + 27\\bar{q}_{i+1} - 3\\bar{q}_{i+2})$，这是标准的五阶线性重构公式。\n\n从线性权到非线性权的转换是通过光滑度指示子 $\\beta_k$ 实现的。这些指示子衡量解在每个子模板 $S_k$ 上的粗糙度。它们被定义为重构多项式在一个代表性区间上导数的平方 $L^2$-范数的加权和。对于三个子模板 $S_0, S_1, S_2$，标准的 Jiang-Shu 光滑度指示子为：\n$$\n\\begin{aligned}\n\\beta_0 = \\frac{13}{12}(\\bar{q}_{i-2} - 2\\bar{q}_{i-1} + \\bar{q}_i)^2 + \\frac{1}{4}(\\bar{q}_{i-2} - 4\\bar{q}_{i-1} + 3\\bar{q}_i)^2 \\\\\n\\beta_1 = \\frac{13}{12}(\\bar{q}_{i-1} - 2\\bar{q}_i + \\bar{q}_{i+1})^2 + \\frac{1}{4}(\\bar{q}_{i-1} - \\bar{q}_{i+1})^2 \\\\\n\\beta_2 = \\frac{13}{12}(\\bar{q}_i - 2\\bar{q}_{i+1} + \\bar{q}_{i+2})^2 + \\frac{1}{4}(3\\bar{q}_i - 4\\bar{q}_{i+1} + \\bar{q}_{i+2})^2\n\\end{aligned}\n$$\n$\\beta_k$ 的值较小表示函数在模板 $S_k$ 上是光滑的，而较大的值则表示存在强梯度或间断。\n\n非线性权 $\\omega_k$ 由光滑度指示子 $\\beta_k$ 和线性权 $d_k$ 计算得出。首先，计算未归一化的权重 $\\alpha_k$：\n$$\n\\alpha_k = \\frac{d_k}{(\\epsilon + \\beta_k)^p}, \\quad k \\in \\{0, 1, 2\\}\n$$\n这里，$\\epsilon$ 是一个很小的正数，用于避免当模板完全光滑（$\\beta_k=0$）时出现除以零的情况，$p$ 是一个正整数幂，通常设为 2。本问题指定 $\\epsilon = 10^{-6}$ 和 $p=2$。\n\n最后，通过对 $\\alpha_k$ 进行归一化得到非线性权 $\\omega_k$：\n$$\n\\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n$$\n根据构造，$\\sum_{k=0}^{2} \\omega_k = 1$。如果一个模板 $S_k$ 穿过一个间断，其对应的 $\\beta_k$ 将会很大，从而使得 $\\alpha_k$ 和 $\\omega_k$ 很小。这有效地移除了该模板带来的振荡贡献。在光滑区域，所有的 $\\beta_k$ 都很小且量级相近，使得非线性权 $\\omega_k$ 逼近线性权 $d_k$，从而恢复五阶精度。这种自适应过程确保了高精度和无振荡行为，这也是WENO方法的标志。\n\n计算 $q_{i+\\frac{1}{2}}^{-}$ 的完整算法如下：\n1.  给定五个网格平均值 $\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_{i}, \\bar{q}_{i+1}, \\bar{q}_{i+2}$。\n2.  计算三个光滑度指示子 $\\beta_0, \\beta_1, \\beta_2$。\n3.  使用线性权 $d_0=0.1, d_1=0.6, d_2=0.3$ 和参数 $\\epsilon=10^{-6}, p=2$ 计算未归一化的权重 $\\alpha_0, \\alpha_1, \\alpha_2$。\n4.  计算归一化后的非线性权 $\\omega_0, \\omega_1, \\omega_2$。\n5.  计算三个候选重构 $q_{i+\\frac{1}{2}}^{(0)}, q_{i+\\frac{1}{2}}^{(1)}, q_{i+\\frac{1}{2}}^{(2)}$。\n6.  计算最终的重构值 $q_{i+\\frac{1}{2}}^{-} = \\omega_0 q_{i+\\frac{1}{2}}^{(0)} + \\omega_1 q_{i+\\frac{1}{2}}^{(1)} + \\omega_2 q_{i+\\frac{1}{2}}^{(2)}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_weno5_reconstruction(q_stencil):\n    \"\"\"\n    Computes the 5th-order WENO reconstruction of the left state at the\n    interface i+1/2 from a 5-point stencil of cell averages.\n\n    Args:\n        q_stencil (list or np.ndarray): A list or array of 5 floating-point\n            numbers representing the cell averages [q_{i-2}, q_{i-1}, q_{i},\n            q_{i+1}, q_{i+2}].\n\n    Returns:\n        float: The reconstructed left state q_{i+1/2}^{-}.\n    \"\"\"\n    # Parameters for WENO-5\n    epsilon = 1e-6\n    p = 2\n    \n    # Linear weights for 5th order accuracy\n    d0, d1, d2 = 0.1, 0.6, 0.3\n\n    # Unpack stencil for clarity\n    q_im2, q_im1, q_i, q_ip1, q_ip2 = q_stencil\n\n    # 1. Compute smoothness indicators (beta_k)\n    # These are the standard Jiang-Shu smoothness indicators.\n    beta_0 = (13.0/12.0) * (q_im2 - 2*q_im1 + q_i)**2 + (1.0/4.0) * (q_im2 - 4*q_im1 + 3*q_i)**2\n    beta_1 = (13.0/12.0) * (q_im1 - 2*q_i + q_ip1)**2 + (1.0/4.0) * (q_im1 - q_ip1)**2\n    beta_2 = (13.0/12.0) * (q_i - 2*q_ip1 + q_ip2)**2 + (1.0/4.0) * (3*q_i - 4*q_ip1 + q_ip2)**2\n    betas = np.array([beta_0, beta_1, beta_2])\n\n    # 2. Compute nonlinear weights (omega_k)\n    alphas = np.array([d0, d1, d2]) / (epsilon + betas)**p\n    omega = alphas / np.sum(alphas)\n\n    # 3. Compute candidate reconstructions (q_k)\n    # These are the 3rd order reconstructions on each sub-stencil.\n    q_0 = (2.0/6.0)*q_im2 - (7.0/6.0)*q_im1 + (11.0/6.0)*q_i\n    q_1 = -(1.0/6.0)*q_im1 + (5.0/6.0)*q_i + (2.0/6.0)*q_ip1\n    q_2 = (2.0/6.0)*q_i + (5.0/6.0)*q_ip1 - (1.0/6.0)*q_ip2\n    qs = np.array([q_0, q_1, q_2])\n    \n    # 4. Compute the final reconstructed value\n    # This is the convex combination of the candidate reconstructions.\n    q_final = np.dot(omega, qs)\n    \n    return q_final\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: strong shock\n        [5.0, 5.0, 5.0, 0.2, 0.2],\n        # Case 2: smooth monotone ramp\n        [0.0, 0.5, 1.0, 1.5, 2.0],\n        # Case 3: constant state\n        [1.0, 1.0, 1.0, 1.0, 1.0],\n        # Case 4: local extremum\n        [1.0, 2.0, 3.0, 2.0, 1.0],\n        # Case 5: contact-like weak jump\n        [1.0, 1.0, 0.9, 0.9, 0.9],\n    ]\n\n    results = []\n    for case in test_cases:\n        q_stencil = np.array(case)\n        result = compute_weno5_reconstruction(q_stencil)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "高效地解析激波和接触间断的精细结构，通常需要将计算资源集中在最关键的区域，这正是自适应网格加密 (Adaptive Mesh Refinement, AMR) 的作用。本练习将挑战您设计并测试用于决定网格加密位置的AMR“传感器”，同时您将直面一个关键的物理原则：伽利略不变性。您将研究一个不恰当的传感器设计如何破坏这一基本不变性，从而导致与物理现实不符的模拟结果 。",
            "id": "3361325",
            "problem": "考虑理想气体的一维 ($1$-D) 可压缩欧拉方程，其绝热指数为 $\\gamma$。对于密度 $\\rho(x,t)$、动量 $\\rho(x,t) u(x,t)$ 和总能量 $E(x,t)$，其守恒形式写作：\n$$\n\\partial_t \\rho + \\partial_x (\\rho u) = 0,\\quad\n\\partial_t (\\rho u) + \\partial_x \\left(\\rho u^2 + p\\right) = 0,\\quad\n\\partial_t E + \\partial_x \\left((E+p)u\\right) = 0,\n$$\n理想气体状态方程为 $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)$，声速为 $a = \\sqrt{\\gamma p / \\rho}$。接触间断的特征是 $\\rho$ 发生跳跃，而 $p$ 和 $u$ 保持连续；激波是一种 $p$、$u$ 和 $\\rho$ 均发生跳跃且满足朗金-雨贡纽（Rankine–Hugoniot）条件的间断；膨胀（稀疏）波扇则是一个连续的自相似区域，其中 $p$、$u$ 和 $\\rho$ 呈等熵相关的单调变化。\n\n具有恒定速度增量 $\\Delta u$ 的伽利略变换将 $(x,t,u,p,\\rho)$ 映射到 $(x',t',u',p',\\rho')$，其关系为 $x' = x - \\Delta u\\, t$，$t' = t$，$u' = u - \\Delta u$，$p' = p$ 和 $\\rho' = \\rho$。欧拉方程具有伽利略不变性：如果 $(\\rho,u,p)$ 是一个解，那么 $(\\rho',u',p')$ 在带撇坐标系中也是一个解。\n\n你的任务是，在一个包含相互作用的膨胀波扇、接触间断和激波的合成快照上，算法性地评估两种自适应网格加密 (AMR) 加密传感器的行为，并通过一个恒定的速度增量 $\\Delta u$ 来测试伽利略不变性。你将在接触间断处计算一个加密一致性度量，以量化在伽利略增量下加密决策的一致性程度。\n\n在空间域 $x \\in [0,1]$ 上，使用 $N$ 个均匀间隔的网格点（间距为 $\\Delta x = 1/(N-1)$），构建一个在时间 $t=0$ 的无量纲初始快照。使用以下分段光滑剖面，其中所有物理量均为无量纲：\n\n- 左侧状态 ($x \\le x_a$): $\\rho = \\rho_L$, $u = u_L$, $p = p_L$.\n- 膨胀波扇 ($x \\in (x_a,x_b]$): 定义光滑斜坡参数 $s_r(x) = \\max\\{0,\\min\\{1,(x - x_a)/(x_b - x_a)\\}\\}$，设 $p(x) = (1-s_r)p_L + s_r p_*$, $u(x) = (1-s_r)u_L + s_r u_*$，并使用等熵关系 $p/\\rho^\\gamma = K$ (其中 $K = p_L/\\rho_L^\\gamma$) 来设定 $\\rho(x) = \\left(p(x)/K\\right)^{1/\\gamma}$。\n- 膨胀后，接触前 ($x \\in (x_b,x_c - \\delta_c]$): $\\rho = \\rho_1$, $u = u_*$, $p = p_*$，其中 $\\rho_1 = \\left(p_*/K\\right)^{1/\\gamma}$。\n- 以 $x_c$ 为中心、半宽为 $\\delta_c$ 的接触区域: 保持 $u = u_*$ 和 $p = p_*$ 连续，但使用宽度为 $w_c$ 的双曲正切平滑施加一个从 $\\rho_1$ 到 $\\rho_2 = f_c \\rho_1$ 的光滑密度跳跃：对于 $x \\in [x_c - \\delta_c, x_c + \\delta_c]$，$\\rho(x) = \\rho_1 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c}{w_c}\\right)\\right)\\left(\\rho_2 - \\rho_1\\right)$。\n- 接触后，激波前 ($x \\in (x_c + \\delta_c, x_s - \\delta_s]$): $\\rho = \\rho_2$, $u = u_*$, $p = p_*$.\n- 以 $x_s$ 为中心、半宽为 $\\delta_s$ 的激波区域: 使用宽度为 $w_s$ 的双曲正切平滑施加光滑跳跃，以增加压力和密度并减小速度：$p(x) = p_* + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(p_3 - p_*\\right)$, $u(x) = u_* + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(u_3 - u_*\\right)$, and $\\rho(x) = \\rho_2 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(\\rho_3 - \\rho_2\\right)$.\n- 激波右侧 ($x > x_s$ 平滑区域之外): 上述平滑关系饱和到右侧状态 $(\\rho_3,u_3,p_3)$。\n\n使用参数 $N = 2048$, $\\gamma = 1.4$, $x_a = 0.25$, $x_b = 0.45$, $x_c = 0.5$, $x_s = 0.7$, $\\delta_c = 0.01$, $\\delta_s = 0.01$, $w_c = 0.002$, $w_s = 0.003$, 以及基态 $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 1.0$, $p_* = 0.5$, $u_* = 0.6$, $f_c = 1.5$, $p_3 = 1.5$, $u_3 = 0.2$, $\\rho_3 = 2.0$。所有值均为无量纲。\n\n定义两种 AMR 加密传感器：\n\n- 传感器 $\\mathcal{S}_{\\mathrm{GI}}$ (伽利略不变): 计算中心有限差分以近似 $\\partial_x p$ 和 $\\partial_x \\rho$，构造标量场\n$$\ns_{\\mathrm{GI}}(x_i) = \\frac{|\\partial_x p(x_i)|}{\\max_j |p(x_j)|} + \\frac{|\\partial_x \\rho(x_i)|}{\\max_j |\\rho(x_j)|},\n$$\n如果 $s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)$（其中 $\\theta = 0.2$），则标记单元格 $i$。该传感器仅使用压力和密度梯度，因此在均匀速度增量 $u \\mapsto u + \\Delta u$ ($t=0$时)下是不变的。\n- 传感器 $\\mathcal{S}_{\\mathrm{NGI}}$ (非伽利略不变): 如果一个单元格被 $\\mathcal{S}_{\\mathrm{GI}}$ 标记，或者局部马赫数的大小超过阈值 $M_{\\mathrm{thr}}$，则标记该单元格，即：\n$$\n\\text{flag}_{\\mathrm{NGI}}(x_i) = \\left[s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)\\right] \\,\\vee\\, \\left[\\frac{|u(x_i)|}{a(x_i)} \\ge M_{\\mathrm{thr}}\\right].\n$$\n由于该传感器依赖于绝对速度大小，因此它不是伽利略不变的。\n\n为测试伽利略不变性，通过施加一个均匀的速度增量 $\\Delta u$ 来定义 $t=0$ 时的增量后快照：$u'(x) = u(x) + \\Delta u$，其中 $p'(x) = p(x)$ 且 $\\rho'(x) = \\rho(x)$。在增量后的快照上为两种传感器重新计算标记。\n\n将接触点处的加密一致性定义为原始标记和增量后标记之间的 Jaccard 指数，该指数仅限于窗口 $W_c = \\{x: |x - x_c| \\le w_{\\mathrm{win}}\\}$（其中 $w_{\\mathrm{win}} = 0.02$）内，\n$$\nJ = \\frac{\\left|\\{i \\in W_c: \\text{flag}(x_i) = 1 \\wedge \\text{flag}'(x_i) = 1\\}\\right|}{\\left|\\{i \\in W_c: \\text{flag}(x_i) = 1 \\vee \\text{flag}'(x_i) = 1\\}\\right|},\n$$\n约定如果分母为零，则 $J = 1$。计算 $\\mathcal{S}_{\\mathrm{GI}}$ 的 $J_{\\mathrm{GI}}$ 和 $\\mathcal{S}_{\\mathrm{NGI}}$ 的 $J_{\\mathrm{NGI}}$。\n\n测试套件。对以下参数集评估一致性度量，其中每个测试用例都是一个序对 $(\\Delta u, M_{\\mathrm{thr}})$：\n\n- 测试 1: $(\\Delta u, M_{\\mathrm{thr}}) = (0.0, 0.8)$.\n- 测试 2: $(\\Delta u, M_{\\mathrm{thr}}) = (0.5, 0.8)$.\n- 测试 3: $(\\Delta u, M_{\\mathrm{thr}}) = (1.0, 0.8)$.\n- 测试 4 (马赫数阈值宽松的边缘情况): $(\\Delta u, M_{\\mathrm{thr}}) = (0.5, 0.2)$.\n\n所有量均为无量纲。本问题不涉及角度。你的程序应将结果输出为单行，其中包含一个按指定顺序排列的测试结果列表，每个结果是包含两个浮点数 $[J_{\\mathrm{GI}}, J_{\\mathrm{NGI}}]$ 的列表。确切格式必须是单行，内容为方括号括起来的逗号分隔列表，例如 $[[1.0,1.0],[1.0,0.9],[1.0,0.7],[1.0,0.5]]$（此处数字仅为示例）。最终输出必须是且仅是这一行带方括号的列表，不得包含任何额外文本。",
            "solution": "问题陈述是有效的。它基于气体动力学和计算方法的原理，提供了一个适定的、自洽且客观的任务。所有必要的常数、方程和程序步骤都已明确给出，从而可以得到唯一且可验证的解。\n\n任务是在一个合成的一维流体动力学剖面上实现并评估两种自适应网格加密（AMR）传感器，并测试它们在伽利略速度增量下的行为。问题的核心在于数值上验证伽利略不变性的概念。\n\n算法设计分几个不同的步骤进行，每一步都基于问题中描述的物理和数学原理。\n\n首先，我们构建气体的初始物理状态。该状态由离散一维空间域 $x \\in [0,1]$ 上的密度 $\\rho(x)$、速度 $u(x)$ 和压力 $p(x)$ 定义。该域被离散化为 $N=2048$ 个均匀间隔的网格点。根据给定的规范逐段构建剖面，该剖面代表了一系列基本的流体动力学结构：一个恒定的左侧状态、一个等熵膨胀波扇、一个接触间断和一个激波。每个结构都由空间坐标 $x$ 的函数定义。为了效率和清晰度，此构建过程使用向量化的 `numpy` 操作执行。例如，位于 $x_a=0.25$ 和 $x_b=0.45$ 之间的膨胀波扇的光滑斜坡参数 $s_r(x)$ 是使用 `numpy.clip` 实现的。接触间断和激波使用双曲正切函数进行平滑，例如，接触间断的密度为 $\\rho(x) = \\rho_1 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c}{w_c}\\right)\\right)\\left(\\rho_2 - \\rho_1\\right)$，这是数值模拟中为跳跃创建可微近似的标准方法。\n\n其次，我们实现两种 AMR 加密传感器 $\\mathcal{S}_{\\mathrm{GI}}$ 和 $\\mathcal{S}_{\\mathrm{NGI}}$。\n伽利略不变传感器 $\\mathcal{S}_{\\mathrm{GI}}$ 由标量场 $s_{\\mathrm{GI}}(x_i) = \\frac{|\\partial_x p(x_i)|}{\\max_j |p(x_j)|} + \\frac{|\\partial_x \\rho(x_i)|}{\\max_j |\\rho(x_j)|}$ 定义。空间导数 $\\partial_x p$ 和 $\\partial_x \\rho$ 使用中心有限差分进行近似。`numpy.gradient` 函数适用于此任务，因为它为内部点计算二阶精确梯度，并在边界处计算一阶精确梯度。如果 $s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)$，则网格单元 $i$ 被标记为需要加密，其中阈值 $\\theta = 0.2$。该传感器预期是伽利略不变的，因为在固定时间下的伽利略增量中，压力 $p$ 和密度 $\\rho$ 本身是不变的（$p'=p$, $\\rho'=\\rho$），因此它们的空间梯度也是不变的。\n\n非伽利略不变传感器 $\\mathcal{S}_{\\mathrm{NGI}}$ 在一个单元格被 $\\mathcal{S}_{\\mathrm{GI}}$ 标记，或者局部马赫数大小 $M(x_i) = |u(x_i)|/a(x_i)$ 超过给定阈值 $M_{\\mathrm{thr}}$ 时，对该单元格进行标记。声速由 $a(x_i) = \\sqrt{\\gamma p(x_i) / \\rho(x_i)}$ 给出。该传感器不是伽利略不变的，因为在问题指定的变换下，速度变换为 $u' = u - \\Delta u$。虽然声速 $a$ 保持不变（因为 $p$ 和 $\\rho$ 不变），但马赫数变为 $M' = |u - \\Delta u|/a$，这与 $M$ 不同。因此，基于马赫数的标记决策在原始参考系和增量后的参考系之间可能会改变。\n\n第三，我们实现伽利略不变性的测试。对于由速度增量 $\\Delta u$ 和马赫数阈值 $M_{\\mathrm{thr}}$ 定义的每个测试用例，我们执行以下步骤：\n$1$. 计算初始流体状态 $(\\rho, u, p)$。\n$2$. 创建增量后的状态 $(\\rho', u', p')$，其中 $\\rho'=\\rho$，$p'=p$，且 $u' = u + \\Delta u$。注意，问题陈述中使用 $u' = u - \\Delta u$ 表示向运动参考系的变换，但要求通过增加一个速度来定义 $t=0$ 时的增量后快照，因此我们实现 $u_{new} = u_{old} + \\Delta u$。这是创建新初始条件的一致解释。\n$3$. 在原始状态和增量后状态上为两种传感器（$\\mathcal{S}_{\\mathrm{GI}}$, $\\mathcal{S}_{\\mathrm{NGI}}$）计算加密标记。\n$4$. 使用 Jaccard 指数 $J$ 量化加密标记的一致性。该度量通过比较原始状态下的标记单元格集合 $\\text{flag}(x_i)$ 和增量后状态的集合 $\\text{flag}'(x_i)$ 来为每个传感器计算。比较范围被限制在以接触间断为中心（$x_c=0.5$）的窗口 $W_c = \\{x: |x - x_c| \\le w_{\\mathrm{win}}\\}$ 内，其中 $w_{\\mathrm{win}}=0.02$。Jaccard 指数 $J = |\\text{intersection}|/|\\text{union}|$，在完全一致时为 $1.0$。如果标记单元格的并集为空，则根据问题的约定取 $J = 1.0$。\n\n最终输出是一个列表，其中包含每个测试用例计算出的指数对 $[J_{\\mathrm{GI}}, J_{\\mathrm{NGI}}]$。根据伽利略不变性原理，我们预期所有测试的 $J_{\\mathrm{GI}}$ 都将为 $1.0$，因为该传感器的定义量是不变的。相反，$J_{\\mathrm{NGI}}$ 预计会变化，仅在 $\\Delta u=0$ 或在窗口 $W_c$ 内马赫数条件在两个参考系中都满足或都不满足时才等于 $1.0$。对于速度增量导致马赫数超过阈值 $M_{\\mathrm{thr}}$ 的情况，$J_{\\mathrm{NGI}}$ 将小于 $1.0$，从而定量地证明了该传感器的不变性缺失。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Galilean coherence of two AMR sensors on a synthetic 1D gas dynamics profile.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_u, M_thr)\n        (0.0, 0.8),\n        (0.5, 0.8),\n        (1.0, 0.8),\n        (0.5, 0.2),\n    ]\n\n    # Global parameters from the problem statement\n    N = 2048\n    gamma = 1.4\n    x_a = 0.25\n    x_b = 0.45\n    x_c = 0.5\n    x_s = 0.7\n    delta_c = 0.01\n    delta_s = 0.01\n    w_c = 0.002\n    w_s = 0.003\n    rho_L = 1.0\n    u_L = 0.0\n    p_L = 1.0\n    p_star = 0.5\n    u_star = 0.6\n    f_c = 1.5\n    p_3 = 1.5\n    u_3 = 0.2\n    rho_3 = 2.0\n    theta = 0.2\n    w_win = 0.02\n\n    # Create the spatial grid\n    x = np.linspace(0.0, 1.0, N)\n\n    def generate_profile(x_grid):\n        \"\"\"\n        Generates the 1D fluid profile (rho, u, p) based on the piecewise definitions.\n        \"\"\"\n        # Initialize arrays\n        rho = np.zeros_like(x_grid)\n        u = np.zeros_like(x_grid)\n        p = np.zeros_like(x_grid)\n\n        # Derived constants and states\n        K = p_L / (rho_L**gamma)\n        rho_1 = (p_star / K)**(1.0 / gamma)\n        rho_2 = f_c * rho_1\n\n        # Region definitions using boolean masks for clear partitioning\n        # Left state\n        cond_L = x_grid = x_a\n        rho[cond_L], u[cond_L], p[cond_L] = rho_L, u_L, p_L\n\n        # Expansion fan\n        cond_fan = (x_grid > x_a)  (x_grid = x_b)\n        s_r_fan = (x_grid[cond_fan] - x_a) / (x_b - x_a)\n        p[cond_fan] = (1.0 - s_r_fan) * p_L + s_r_fan * p_star\n        u[cond_fan] = (1.0 - s_r_fan) * u_L + s_r_fan * u_star\n        rho[cond_fan] = (p[cond_fan] / K)**(1.0 / gamma)\n\n        # Post-expansion, pre-contact\n        cond_post_fan = (x_grid > x_b)  (x_grid = x_c - delta_c)\n        rho[cond_post_fan], u[cond_post_fan], p[cond_post_fan] = rho_1, u_star, p_star\n\n        # Contact region\n        cond_contact = (x_grid > x_c - delta_c)  (x_grid = x_c + delta_c)\n        u[cond_contact], p[cond_contact] = u_star, p_star\n        tanh_c = np.tanh((x_grid[cond_contact] - x_c) / w_c)\n        rho[cond_contact] = rho_1 + 0.5 * (1.0 + tanh_c) * (rho_2 - rho_1)\n        \n        # Post-contact, pre-shock\n        cond_post_contact = (x_grid > x_c + delta_c)  (x_grid = x_s - delta_s)\n        rho[cond_post_contact], u[cond_post_contact], p[cond_post_contact] = rho_2, u_star, p_star\n\n        # Shock region\n        cond_shock = (x_grid > x_s - delta_s)  (x_grid = x_s + delta_s)\n        tanh_s = np.tanh((x_grid[cond_shock] - x_s) / w_s)\n        p[cond_shock] = p_star + 0.5 * (1.0 + tanh_s) * (p_3 - p_star)\n        u[cond_shock] = u_star + 0.5 * (1.0 + tanh_s) * (u_3 - u_star)\n        rho[cond_shock] = rho_2 + 0.5 * (1.0 + tanh_s) * (rho_3 - rho_2)\n\n        # Right state\n        cond_R = x_grid > x_s + delta_s\n        rho[cond_R], u[cond_R], p[cond_R] = rho_3, u_3, p_3\n        \n        return rho, u, p\n\n    def get_gi_flags(rho, p, x_grid, theta_val):\n        \"\"\"Computes flags for the Galilean-invariant sensor S_GI.\"\"\"\n        dp_dx = np.gradient(p, x_grid)\n        drho_dx = np.gradient(rho, x_grid)\n        \n        max_p_abs = np.max(np.abs(p))\n        max_rho_abs = np.max(np.abs(rho))\n        \n        s_gi = np.zeros_like(x_grid)\n        if max_p_abs > 1e-12:\n            s_gi += np.abs(dp_dx) / max_p_abs\n        if max_rho_abs > 1e-12:\n            s_gi += np.abs(drho_dx) / max_rho_abs\n            \n        max_s_gi = np.max(s_gi)\n        if max_s_gi  1e-12:\n            return np.zeros_like(x_grid, dtype=bool)\n            \n        return s_gi >= theta_val * max_s_gi\n\n    def get_ngi_flags(u, a, gi_flags, m_thresh):\n        \"\"\"Computes flags for the non-Galilean-invariant sensor S_NGI.\"\"\"\n        mach = np.abs(u) / a\n        mach_flags = mach >= m_thresh\n        return np.logical_or(gi_flags, mach_flags)\n\n    def calculate_jaccard_index(flags1, flags2, x_grid, center, win_half_width):\n        \"\"\"Calculates the Jaccard index between two flag arrays within a window.\"\"\"\n        window_mask = np.abs(x_grid - center) = win_half_width\n        \n        flags1_win = flags1[window_mask]\n        flags2_win = flags2[window_mask]\n        \n        intersection = np.sum(np.logical_and(flags1_win, flags2_win))\n        union = np.sum(np.logical_or(flags1_win, flags2_win))\n        \n        return 1.0 if union == 0 else float(intersection) / float(union)\n\n    results = []\n    \n    # Generate the base state once, as it's the same for all tests\n    rho_base, u_base, p_base = generate_profile(x)\n    a_base = np.sqrt(gamma * p_base / rho_base)\n\n    for delta_u, m_thr in test_cases:\n        # --- Original State Analysis ---\n        flags_gi_orig = get_gi_flags(rho_base, p_base, x, theta)\n        flags_ngi_orig = get_ngi_flags(u_base, a_base, flags_gi_orig, m_thr)\n        \n        # --- Boosted State Analysis ---\n        u_boosted = u_base + delta_u\n        p_boosted = p_base\n        rho_boosted = rho_base\n        a_boosted = a_base\n        \n        flags_gi_boosted = get_gi_flags(rho_boosted, p_boosted, x, theta)\n        flags_ngi_boosted = get_ngi_flags(u_boosted, a_boosted, flags_gi_boosted, m_thr)\n        \n        # --- Compute Coherence Metrics ---\n        J_gi = calculate_jaccard_index(flags_gi_orig, flags_gi_boosted, x, x_c, w_win)\n        J_ngi = calculate_jaccard_index(flags_ngi_orig, flags_ngi_boosted, x, x_c, w_win)\n        \n        results.append([J_gi, J_ngi])\n\n    # Format the final output string exactly as required\n    results_str = ','.join(f'[{res[0]},{res[1]}]' for res in results)\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代CFD模拟的速度在很大程度上取决于其在GPU等并行硬件上的执行效率。我们所研究的激波、稀疏波和接触间断等不同结构，会产生不同的计算负载，并通过一种称为“线程束发散 (warp divergence)”的现象来降低并行性能。在本练习中，您将在黎曼求解器的背景下对这一效应进行建模和分析，比较一个朴素实现与一个经过优化的“波感知”批处理策略，从而量化通过硬件感知算法设计可能实现的显著性能提升 。",
            "id": "3361328",
            "problem": "考虑一维多方理想气体的欧拉方程，其比热比为 $\\gamma$，以密度 $\\rho$、动量 $\\rho u$ 和总能量 $E$ 的守恒形式表示，空间坐标为 $x$，时间为 $t$：\n$$\n\\frac{\\partial}{\\partial t}\n\\begin{pmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{pmatrix}\n+\n\\frac{\\partial}{\\partial x}\n\\begin{pmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu(E + p)\n\\end{pmatrix}\n= \n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix},\n\\quad\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2} \\rho u^2\\right).\n$$\n黎曼问题包含在 $t = 0$ 时 $x = 0$ 处的分段常数左右状态，演化为一个自相似解。该解的特征是两个非线性波（激波或稀疏波）被一个接触间断分开。左右非线性波的分类源于自相似解的一致性条件：星区压力 $p_\\star$ 与初始压力 $p_L$ 和 $p_R$ 的比较，决定了是出现激波（$p_\\star > p_{L}$ 或 $p_\\star > p_{R}$）还是稀疏波（$p_\\star  p_{L}$ 或 $p_\\star  p_{R}$）。接触间断在传输密度和内能跳跃的同时，保持其两侧的压力和速度不变。\n\n在图形处理器（GPU）上，执行黎曼求解器的 warp（单指令多线程，SIMT 组）中的线程会根据局部波的类型是激波、稀疏波还是仅为接触更新而产生不同的分支。当同一 warp 中的线程采取不同分支时，就会出现 Warp 分化，迫使每个不同的分支路径串行执行。设激波分支、稀疏波分支和接触分支的周期成本分别为 $L_S$、$L_R$ 和 $L_C$。假设周期成本对于每种波类型是确定的，并且除了分类之外不依赖于局部状态。\n\n一种基于原则的批处理策略通过按波类型将线程分配给 warp 来减少分化。相比之下，朴素排序将混合的波类型任意分布在各个 warp 中。为了分析分化热点并量化批处理的好处，建立以下模型：\n\n- 一个内核启动 $N$ 个线程，这些线程被划分为大小为 $W$ 的 warp。其局部解需要激波、稀疏波或接触分支的线程数分别为 $n_S$、$n_R$ 和 $n_C$，满足 $n_S + n_R + n_C = N$。\n- 在朴素排序中，假设线程被随机排列，然后划分为 warp。对于从 $N$ 个线程中无放回均匀采样的大小为 $w$ 的 warp，该 warp 包含至少一个类型为 $T \\in \\{S, R, C\\}$ 的线程的概率等于 $1$ 减去所有 $w$ 个线程都属于大小为 $N - n_T$ 的补集的概率。因此，在大小为 $w$ 的 warp 中，类型 $T$ 的缺失概率为\n$$\n\\mathbb{P}\\{\\text{warp 中无 }T\\}\n=\n\\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}\n\\quad \\text{对于 } w \\le N - n_T,\n$$\n而对于 $w > N - n_T$ 则等于 $0$。一个大小为 $w$ 的随机 warp 的期望周期成本是\n$$\n\\mathbb{E}[C_{\\text{warp}}(w)] = L_S \\left(1 - \\frac{\\binom{N - n_S}{w}}{\\binom{N}{w}}\\right) + L_R \\left(1 - \\frac{\\binom{N - n_R}{w}}{\\binom{N}{w}}\\right) + L_C \\left(1 - \\frac{\\binom{N - n_C}{w}}{\\binom{N}{w}}\\right).\n$$\n有 $M = \\left\\lfloor \\frac{N}{W} \\right\\rfloor$ 个大小为 $W$ 的完整 warp 和一个大小为 $W_{\\text{last}} = N - M W$ 的最终（可能不完整的）warp（$W_{\\text{last}} = 0$ 表示没有不完整的 warp），朴素排序的期望总周期成本为\n$$\n\\mathbb{E}[C_{\\text{naive}}] = M \\cdot \\mathbb{E}[C_{\\text{warp}}(W)] + \\begin{cases}\n\\mathbb{E}[C_{\\text{warp}}(W_{\\text{last}}),  \\text{若 } W_{\\text{last}} > 0,\\\\\n0,  \\text{若 } W_{\\text{last}} = 0.\n\\end{cases}\n$$\n每个大小为 $w$ 的 warp 执行的不同分支的期望数量（一种衡量分化热点严重性的指标）是\n$$\n\\mathbb{E}[B(w)] = \\sum_{T \\in \\{S,R,C\\}} \\left(1 - \\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}\\right).\n$$\n\n- 在波类型批处理中，按波类型形成连续队列，并从每个队列中分配 warp。类型 $T$ 消耗的 warp 数量为 $\\left\\lceil \\frac{n_T}{W} \\right\\rceil$，每个这样的 warp 只执行该分支，周期成本为 $L_T$。批处理的总周期成本为\n$$\nC_{\\text{batch}} = \\left\\lceil \\frac{n_S}{W} \\right\\rceil L_S + \\left\\lceil \\frac{n_R}{W} \\right\\rceil L_R + \\left\\lceil \\frac{n_C}{W} \\right\\rceil L_C.\n$$\n将批处理占用率定义为所有批处理 warp 中活动通道的比例：\n$$\n\\mathrm{Occ}_{\\text{batch}} = \\frac{N}{W \\left( \\left\\lceil \\frac{n_S}{W} \\right\\rceil + \\left\\lceil \\frac{n_R}{W} \\right\\rceil + \\left\\lceil \\frac{n_C}{W} \\right\\rceil \\right)}.\n$$\n批处理相对于朴素排序的改进因子是\n$$\n\\mathrm{Imp} = \\frac{\\mathbb{E}[C_{\\text{naive}}]}{C_{\\text{batch}}}.\n$$\n\n从欧拉方程的守恒律结构、Rankine–Hugoniot 跳跃条件和稀疏扇积分曲线所蕴含的波分类出发，并使用上述 SIMT 执行模型，实现一个程序，为每个测试用例计算改进因子 $\\mathrm{Imp}$、在朴素排序下完整 warp 大小 $W$ 的每个 warp 的期望不同分支数 $\\mathbb{E}[B(W)]$，以及批处理占用率 $\\mathrm{Occ}_{\\text{batch}}$。\n\n您的程序应通过稳定的浮点数乘积来使用精确的有限总体缺失概率 $\\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}$，而不是显式使用阶乘。所有量都是无量纲的。将每个测试用例的三个指标输出为浮点数，四舍五入到六位小数。\n\n测试套件：\n- 情况 A（均衡混合）：$W = 32$，$N = 1024$，$n_S = 410$，$n_R = 410$，$n_C = 204$，$L_S = 900$，$L_R = 700$，$L_C = 250$。\n- 情况 B（激波主导）：$W = 32$，$N = 320$，$n_S = 288$，$n_R = 16$，$n_C = 16$，$L_S = 1200$，$L_R = 850$，$L_C = 300$。\n- 情况 C（无激波）：$W = 16$，$N = 160$，$n_S = 0$，$n_R = 80$，$n_C = 80$，$L_S = 1000$，$L_R = 500$，$L_C = 220$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总情况 A、B 和 C 的结果。对于每种情况，按 $\\mathrm{Imp}$、$\\mathbb{E}[B(W)]$、$\\mathrm{Occ}_{\\text{batch}}$ 的顺序输出三个计算指标。例如，输出应类似于 $[\\text{Imp}_A,\\mathbb{E}[B(W)]_A,\\mathrm{Occ}_{\\text{batch},A},\\text{Imp}_B,\\mathbb{E}[B(W)]_B,\\mathrm{Occ}_{\\text{batch},B},\\text{Imp}_C,\\mathbb{E}[B(W)]_C,\\mathrm{Occ}_{\\text{batch},C}]$，每个值都四舍五入到六位小数并表示为十进制数。",
            "solution": "问题陈述被认为是有效的。其科学基础在于计算流体力学（CFD）和并行计算性能建模的原理。该问题是良构的，提供了一套自洽的定义、公式和数据，从而可以得到唯一且可验证的解。语言是客观的，参数在数值模拟环境中是物理上合理的。中心任务不是求解欧拉方程本身，而是使用所提供的概率性能模型，分析和比较 GPU 上并行黎曼求解器的两种不同计算策略。线程类型（$n_S, n_R, n_C$）的分布是给定的，代表了物理分类的结果，该分类不属于所需计算的一部分。\n\n解决方案通过实现所述的朴素执行策略和批处理执行策略的数学模型来展开。\n\n首先，我们定义一个核心函数来计算一个大小为 $w$ 的随机 warp 不包含特定类型 $T$ 线程的概率。给定总共 $N$ 个线程，其中 $n_T$ 个是类型 $T$，从整个总体中选择 $w$ 个线程的方法数是 $\\binom{N}{w}$。选择 $w$ 个*不*是类型 $T$ 的线程的方法数是 $\\binom{N - n_T}{w}$。缺失概率是这两个量的比值。为了在不使用可能导致溢出的阶乘的情况下稳健地计算这个比值，我们将其表示为分数乘积的形式：\n$$\n\\mathbb{P}\\{\\text{大小为 } w \\text{ 的 warp 中无 }T\\} = \\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}} = \\prod_{i=0}^{w-1} \\frac{N - n_T - i}{N - i}\n$$\n此计算在 $w \\le N - n_T$ 时有效。如果 $w > N - n_T$，则不可能选择 $w$ 个非类型 $T$ 的线程，因此概率为 $0$。在这种情况下，乘积形式正确地得到 $0$，因为对于某个 $i  w$，分子项 $(N - n_T - i)$ 中会有一个变为零。这个函数，我们称之为 $p_a(N, n_T, w)$，是朴素排序模型的基础。\n\n有了这个概率，我们就可以计算朴素排序策略的指标。每个大小为 $w$ 的 warp 执行的不同分支的期望数量，记为 $\\mathbb{E}[B(w)]$，是每种分支类型存在的概率之和。分支类型 $T$ 存在的概率是 $1 - p_a(N, n_T, w)$。\n$$\n\\mathbb{E}[B(w)] = \\sum_{T \\in \\{S,R,C\\}} \\left(1 - p_a(N, n_T, w)\\right)\n$$\n一个大小为 $w$ 的 warp 的期望周期成本，记为 $\\mathbb{E}[C_{\\text{warp}}(w)]$，是每种分支类型的周期成本之和，按其出现的概率加权。\n$$\n\\mathbb{E}[C_{\\text{warp}}(w)] = L_S \\left(1 - p_a(N, n_S, w)\\right) + L_R \\left(1 - p_a(N, n_R, w)\\right) + L_C \\left(1 - p_a(N, n_C, w)\\right)\n$$\n朴素策略的总期望成本 $\\mathbb{E}[C_{\\text{naive}}]$，是通过对所有 warp 的成本求和来计算的。问题被划分为 $M = \\lfloor N/W \\rfloor$ 个大小为 $W$ 的完整 warp，如果 $N$ 不是 $W$ 的倍数，则还有一个大小为 $W_{\\text{last}} = N \\pmod W$ 的不完整 warp。\n$$\n\\mathbb{E}[C_{\\text{naive}}] = M \\cdot \\mathbb{E}[C_{\\text{warp}}(W)] + (\\mathbb{E}[C_{\\text{warp}}(W_{\\text{last}})] \\text{ 如果 } W_{\\text{last}} > 0 \\text{ 否则 } 0)\n$$\n\n接下来，我们评估波类型批处理策略的指标。在此策略中，线程按类型排序，完全消除了 warp 分化。总周期成本 $C_{\\text{batch}}$ 是处理每种类型的成本之和。对于具有 $n_T$ 个线程的类型 $T$，所需的 warp 数量为 $\\lceil n_T/W \\rceil$。\n$$\nC_{\\text{batch}} = \\left\\lceil \\frac{n_S}{W} \\right\\rceil L_S + \\left\\lceil \\frac{n_R}{W} \\right\\rceil L_R + \\left\\lceil \\frac{n_C}{W} \\right\\rceil L_C\n$$\n对于正整数 $a, b$，向上取整函数 $\\lceil a/b \\rceil$ 可以使用整数算术计算为 $(a + b - 1) // b$。\n\n批处理占用率 $\\mathrm{Occ}_{\\text{batch}}$ 衡量 GPU 通道的利用率。它是总线程数 $N$ 与所有 warp 中分配的总通道数之比。\n$$\n\\mathrm{Occ}_{\\text{batch}} = \\frac{N}{W \\left( \\left\\lceil \\frac{n_S}{W} \\right\\rceil + \\left\\lceil \\frac{n_R}{W} \\right\\rceil + \\left\\lceil \\frac{n_C}{W} \\right\\rceil \\right)}\n$$\n\n最后，改进因子 $\\mathrm{Imp}$ 量化了批处理相对于朴素方法的性能增益。它是期望的朴素成本与确定性的批处理成本之比。\n$$\n\\mathrm{Imp} = \\frac{\\mathbb{E}[C_{\\text{naive}}]}{C_{\\text{batch}}}\n$$\n\n将这些公式应用于提供的三个测试用例。所需的指标是 $\\mathrm{Imp}$、$\\mathbb{E}[B(W)]$（对于大小为 $W$ 的完整 warp）和 $\\mathrm{Occ}_{\\text{batch}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the improvement factor, expected number of branches,\n    and batched occupancy for each case and prints the results in the\n    specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (balanced mixture)\n        {'W': 32, 'N': 1024, 'n_S': 410, 'n_R': 410, 'n_C': 204, 'L_S': 900, 'L_R': 700, 'L_C': 250},\n        # Case B (shock-dominant)\n        {'W': 32, 'N': 320, 'n_S': 288, 'n_R': 16, 'n_C': 16, 'L_S': 1200, 'L_R': 850, 'L_C': 300},\n        # Case C (no shocks)\n        {'W': 16, 'N': 160, 'n_S': 0, 'n_R': 80, 'n_C': 80, 'L_S': 1000, 'L_R': 500, 'L_C': 220},\n    ]\n\n    results = []\n    for case in test_cases:\n        imp, exp_b, occ_batch = calculate_metrics(case)\n        results.extend([f\"{imp:.6f}\", f\"{exp_b:.6f}\", f\"{occ_batch:.6f}\"])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef prob_absence(N, n_T, w):\n    \"\"\"\n    Calculates the probability that a random warp of size w contains no threads of type T.\n    P{no T in warp} = B(N - n_T, w) / B(N, w)\n    This is computed using a stable product form.\n    \n    Args:\n        N (int): Total number of threads.\n        n_T (int): Number of threads of type T.\n        w (int): Warp size.\n        \n    Returns:\n        float: Probability of absence.\n    \"\"\"\n    if w == 0:\n        return 1.0\n    if w > N - n_T:\n        return 0.0\n    \n    prob = 1.0\n    for i in range(w):\n        prob *= (N - n_T - i) / (N - i)\n    return prob\n\ndef calculate_metrics(case):\n    \"\"\"\n    Calculates the required metrics for a single test case.\n    \n    Args:\n        case (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        tuple: A tuple containing (Imp, E[B(W)], Occ_batch).\n    \"\"\"\n    W = case['W']\n    N = case['N']\n    n_S, n_R, n_C = case['n_S'], case['n_R'], case['n_C']\n    L_S, L_R, L_C = case['L_S'], case['L_R'], case['L_C']\n\n    # --- Naive Ordering Calculation ---\n    \n    def expected_warp_cost(w):\n        if w == 0:\n            return 0.0\n        p_absence_S = prob_absence(N, n_S, w)\n        p_absence_R = prob_absence(N, n_R, w)\n        p_absence_C = prob_absence(N, n_C, w)\n        \n        cost = L_S * (1 - p_absence_S) + L_R * (1 - p_absence_R) + L_C * (1 - p_absence_C)\n        return cost\n\n    M = N // W\n    W_last = N % W\n    \n    E_C_warp_full = expected_warp_cost(W)\n    E_C_warp_last = expected_warp_cost(W_last)\n    \n    E_C_naive = M * E_C_warp_full + E_C_warp_last\n\n    # Expected number of branches for a full warp of size W\n    p_absence_S_full = prob_absence(N, n_S, W)\n    p_absence_R_full = prob_absence(N, n_R, W)\n    p_absence_C_full = prob_absence(N, n_C, W)\n    \n    E_B_W = (1 - p_absence_S_full) + (1 - p_absence_R_full) + (1 - p_absence_C_full)\n\n    # --- Wave-Type Batching Calculation ---\n\n    def ceil_div(a, b):\n        if a == 0:\n            return 0\n        return (a + b - 1) // b\n\n    warps_S = ceil_div(n_S, W)\n    warps_R = ceil_div(n_R, W)\n    warps_C = ceil_div(n_C, W)\n\n    C_batch = warps_S * L_S + warps_R * L_R + warps_C * L_C\n    \n    total_batched_warps = warps_S + warps_R + warps_C\n    if total_batched_warps == 0:\n        Occ_batch = 0.0 # Or undefined, but 0 is safe for N=0\n    else:\n        Occ_batch = N / (W * total_batched_warps)\n\n    # --- Final Metrics ---\n    \n    if C_batch == 0:\n        Imp = 0.0 # Or undefined, depending on convention. Assume 0 improvement if no work.\n    else:\n        Imp = E_C_naive / C_batch\n\n    return Imp, E_B_W, Occ_batch\n\nsolve()\n```"
        }
    ]
}