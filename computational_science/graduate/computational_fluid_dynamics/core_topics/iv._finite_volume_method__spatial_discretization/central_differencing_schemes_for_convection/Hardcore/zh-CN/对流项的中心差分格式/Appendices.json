{
    "hands_on_practices": [
        {
            "introduction": "中心差分格式因其二阶精度而备受青睐，然而，当将其应用于对流主导的问题时，会暴露出一个致命的缺陷。第一个实践将通过一个直观的案例来展示这一问题。我们将求解一个稳态对流扩散问题，并亲眼观察当网格尺度上的对流输运远远超过扩散时，非物理振荡是如何产生的，这一现象由佩克莱数（Peclet number）控制 。",
            "id": "3298174",
            "problem": "考虑在单位区间 $x \\in [0,1]$ 上，输运标量场 $\\phi(x)$ 的一维、稳态、常系数对流-扩散边值问题：\n$$\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0,$$\n其狄利克雷边界数据在域的端点上施加了一个单位阶跃，\n$$\\phi(0) = 1,\\quad \\phi(1) = 0.$$\n从 $\\phi$ 在控制体上的守恒以及扩散通量和对流通量的定义出发，使用有限体积法（FVM），并结合均匀网格和用于界面值的中心差分格式（CDS），为内部节点构建离散代数方程组。令网格佩克莱数定义为\n$$\\mathrm{Pe} \\equiv \\frac{\\rho u\\,\\Delta x}{\\Gamma},$$\n其中 $\\Delta x$ 是均匀网格宽度。使用此离散化方法，实现一个求解器，该求解器针对给定的内部节点数 $n$ 和指定的 $\\mathrm{Pe}$ 值，计算离散解向量 $\\{\\phi_i\\}_{i=0}^{n+1}$，其中 $\\phi_0 = 1$ 和 $\\phi_{n+1} = 0$ 是边界值，而 $\\{\\phi_i\\}_{i=1}^{n}$ 是内部未知数。从基本原理出发，论证离散系数是如何由通量平衡和中心插值产生的，并解释为何当 $|\\mathrm{Pe}|$ 足够大时，离散解可能会出现非物理振荡（非单调性和超出区间 $[0,1]$ 的过冲）。\n\n实现一个程序，该程序：\n- 为给定的 $\\mathrm{Pe}$ 和 $n$ 值，在均匀网格上构建并求解 FVM–CDS 离散化产生的三对角线性系统。\n- 基于两项诊断标准，报告是否存在非物理振荡：\n  1. 单调性：对于边界数据 $\\phi(0)=1$ 和 $\\phi(1)=0$，物理上可接受的解是单调递减的。令离散差分为 $d_i = \\phi_i - \\phi_{i-1}$，其中 $i \\in \\{1,2,\\dots,n+1\\}$。如果存在某个 $i$ 使得 $d_i > \\varepsilon$（$\\varepsilon$ 是一个很小的容差），则声明解是非单调的。\n  2. 有界性：如果 $\\max_i \\phi_i > 1 + \\varepsilon$ 或 $\\min_i \\phi_i < 0 - \\varepsilon$，则声明存在过冲。将最大过冲量级量化为\n  $$\\max\\left(\\max_i \\phi_i - 1,\\; 0,\\; 0 - \\min_i \\phi_i\\right),$$\n  解释为一个非负实数。\n- 为每个测试案例汇总一个包含四项内容的结果： \n  1. 一个布尔值，指示是否检测到振荡（如果出现非单调性或过冲，则为真），\n  2. 一个浮点数，等于最大过冲量级，\n  3. 一个浮点数，等于总变差增量，定义为 $\\left(\\sum_{i=1}^{n+1} |d_i|\\right) - 1$，\n  4. 完整的离散解向量 $[\\phi_0, \\phi_1, \\dots, \\phi_{n+1}]$。\n\n您的程序应使用 $\\varepsilon = 10^{-12}$ 的容差进行诊断，并且应将所有报告的浮点数（第2项和第3项，以及离散解向量中的所有条目）在最终输出中四舍五入到6位小数。\n\n测试套件：\n为以下五组参数 $(\\mathrm{Pe}, n)$ 提供结果，所有测试中使用相同的边界值 $\\phi(0)=1$ 和 $\\phi(1)=0$：\n- 案例 A (理想情况，扩散主导)：$(\\mathrm{Pe}, n) = (0, 8)$。\n- 案例 B (阈值)：$(\\mathrm{Pe}, n) = (2, 8)$。\n- 案例 C (对流主导，正向流动)：$(\\mathrm{Pe}, n) = (4, 8)$。\n- 案例 D (对流主导，反向流动)：$(\\mathrm{Pe}, n) = (-4, 8)$。\n- 案例 E (中等对流)：$(\\mathrm{Pe}, n) = (1.5, 8)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个结果列表，每个测试案例一个结果，按 A 到 E 的顺序排列。每个结果本身必须是一个形式为 \n$[\\text{oscillatory},\\ \\text{overshoot},\\ \\text{variation\\_excess},\\ \\text{solution}]$ 的列表，\n其中 $\\text{oscillatory}$ 是布尔值，$\\text{overshoot}$ 和 $\\text{variation\\_excess}$ 是四舍五入到6位小数的浮点数，而 $\\text{solution}$ 是一个四舍五入到6位小数的浮点数列表。例如，一个语法上有效的输出结构是\n$$\\big[\\ [\\text{True},\\ 0.123456,\\ 0.234567,\\ [1.000000, \\dots, 0.000000]],\\ \\dots\\ \\big].$$",
            "solution": "问题陈述被评估为有效。它提出了一个来自计算流体动力学领域的适定的、有科学依据的边值问题，并要求进行标准的数值求解和分析。所有必要的数据和定义都已提供，且前提条件是一致且符合事实的。\n\n### 离散代数方程组的推导\n\n我们从标量场 $\\phi(x)$ 的一维、稳态、常系数对流-扩散方程开始：\n$$\n\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) - \\rho u \\frac{d\\phi}{dx} = 0\n$$\n其中 $\\Gamma$ 是扩散系数，$\\rho$ 是密度，而 $u$ 是速度。通过将总通量 $J(x)$ 定义为扩散通量 $J_D(x) = -\\Gamma \\frac{d\\phi}{dx}$ 和对流通量 $J_C(x) = \\rho u \\phi$ 之和，该方程可以写成守恒形式。控制方程此时等价于声明总通量的散度为零：\n$$\n\\frac{dJ}{dx} = 0 \\quad \\text{其中} \\quad J(x) = J_C(x) + J_D(x) = \\rho u \\phi(x) - \\Gamma \\frac{d\\phi}{dx}\n$$\n\n有限体积法（FVM）的基础是在覆盖整个区域的一组控制体（或单元）上，执行守恒定律的积分形式。我们考虑在区域 $x \\in [0, 1]$ 上的均匀网格。该区域被划分为 $n$ 个内部单元，对应 $n$ 个内部节点，索引为 $i=1, 2, \\dots, n$。节点位于单元中心。边界节点位于 $x_0=0$ 和 $x_{n+1}=1$。均匀单元宽度为 $\\Delta x = 1/(n+1)$。节点 $i$ 的控制体从其西界面 $w$（位于 $x_{i-1/2}$）延伸到其东界面 $e$（位于 $x_{i+1/2}$）。\n\n将守恒定律 $\\frac{dJ}{dx} = 0$ 在节点 $i$ 的控制体上积分，得到：\n$$\n\\int_{w}^{e} \\frac{dJ}{dx} dx = 0\n$$\n根据微积分基本定理，这变成了一个单元界面上通量的简单平衡：\n$$\nJ_e - J_w = 0\n$$\n其中 $J_e = J(x_{i+1/2})$ 和 $J_w = J(x_{i-1/2})$ 分别是东界面和西界面上的总通量。\n\n下一步是近似这些界面通量。中心差分格式（CDS）通过在相邻单元中心节点之间进行线性插值来近似单元界面上的值。\n位于 $x_{i+1/2}$ 的东界面 $e$ 上的通量为 $J_e = (\\rho u \\phi)_e - (\\Gamma \\frac{d\\phi}{dx})_e$。\n使用 CDS：\n- 标量值 $\\phi_e$ 通过对节点 $i$ 和 $i+1$ 处的值取平均来近似：$\\phi_e \\approx \\frac{\\phi_i + \\phi_{i+1}}{2}$。\n- 梯度 $(\\frac{d\\phi}{dx})_e$ 使用以界面为中心的中心差分来近似：$(\\frac{d\\phi}{dx})_e \\approx \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}$。\n\n将这些代入 $J_e$ 的表达式中：\n$$\nJ_e \\approx \\rho u \\left(\\frac{\\phi_i + \\phi_{i+1}}{2}\\right) - \\Gamma \\left(\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\\right)\n$$\n类似地，位于 $x_{i-1/2}$ 的西界面 $w$ 上的通量使用节点 $i-1$ 和 $i$ 来近似：\n$$\nJ_w \\approx \\rho u \\left(\\frac{\\phi_{i-1} + \\phi_i}{2}\\right) - \\Gamma \\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right)\n$$\n将这些通量近似值代入平衡方程 $J_e - J_w = 0$ 中：\n$$\n\\left[ \\rho u \\frac{\\phi_i + \\phi_{i+1}}{2} - \\Gamma \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} \\right] - \\left[ \\rho u \\frac{\\phi_{i-1} + \\phi_i}{2} - \\Gamma \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} \\right] = 0\n$$\n现在我们收集乘以 $\\phi_{i-1}$、$\\phi_i$ 和 $\\phi_{i+1}$ 的项：\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} + \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\Gamma}{\\Delta x}\\right)\\phi_i - \\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} = 0\n$$\n为了遵循惯例，重新整理并乘以-1，得到标准的三点格式：\n$$\n\\left(\\frac{\\Gamma}{\\Delta x} + \\frac{\\rho u}{2}\\right)\\phi_{i-1} - \\left(\\frac{2\\Gamma}{\\Delta x}\\right)\\phi_i + \\left(\\frac{\\Gamma}{\\Delta x} - \\frac{\\rho u}{2}\\right)\\phi_{i+1} = 0\n$$\n为简化起见，我们将整个方程除以 $\\Gamma/\\Delta x$，并引入无量纲的网格佩克莱数 $\\mathrm{Pe} \\equiv \\frac{\\rho u \\Delta x}{\\Gamma}$，它代表了网格尺度上对流与扩散输运强度的比值。\n$$\n\\left(1 + \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\rho u \\Delta x}{2\\Gamma}\\right)\\phi_{i+1} = 0\n$$\n这得到了内部节点 $i$ 的最终离散代数方程：\n$$\n\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} - 2\\phi_i + \\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1} = 0\n$$\n该方程对每个内部节点 $i=1, \\dots, n$ 都有效。对于 $i=1$，$\\phi_{i-1}$ 是已知的边界值 $\\phi_0 = 1$。对于 $i=n$，$\\phi_{i+1}$ 是已知的边界值 $\\phi_{n+1}=0$。这些代入操作产生了一个关于 $n$ 个未知内部值 $\\{\\phi_i\\}_{i=1}^n$ 的 $n$ 元三对角线性方程组。\n\n### 非物理振荡的来源\n\n离散方程可以重新排列，以将其邻近点的函数形式表示 $\\phi_i$：\n$$\n\\phi_i = \\frac{1}{2}\\left(1 + \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i-1} + \\frac{1}{2}\\left(1 - \\frac{\\mathrm{Pe}}{2}\\right)\\phi_{i+1}\n$$\n为了使解在物理上是现实的（即有界且单调，与给定边界条件的二阶微分方程的物理特性一致），节点 $\\phi_i$ 处的值必须是其邻近点 $\\phi_{i-1}$ 和 $\\phi_{i+1}$ 的加权平均值。这要求加权系数为非负。\n1. $\\phi_{i-1}$ 的系数：$\\frac{1}{2}(1 + \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 + \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\ge -2$。\n2. $\\phi_{i+1}$ 的系数：$\\frac{1}{2}(1 - \\frac{\\mathrm{Pe}}{2}) \\ge 0 \\implies 1 - \\frac{\\mathrm{Pe}}{2} \\ge 0 \\implies \\mathrm{Pe} \\le 2$。\n\n结合这些条件，只有当 $|\\mathrm{Pe}| \\le 2$ 时，所有系数才为非负。当此条件满足时，该格式保证能产生单调解。\n\n当流动是对流主导，以至于 $|\\mathrm{Pe}| > 2$ 时，其中一个系数会变为负数。例如，如果 $\\mathrm{Pe} > 2$，$\\phi_{i+1}$ 的系数为负。此时 $\\phi_i$ 的方程就涉及到其邻近点之间的外插，而不是内插。这可能导致计算出的 $\\phi_i$ 值落在其邻近点定义的范围之外（例如，$\\phi_i > \\max(\\phi_{i-1}, \\phi_{i+1})$ 或 $\\phi_i < \\min(\\phi_{i-1}, \\phi_{i+1})$）。这种数学特性是非物理振荡（摆动）的来源，包括过冲和下冲，这些是中心差分格式在强对流区域中的典型失效表现。解不再保证是单调的或受边界值限制。这种不稳定性使得在对流主导问题中必须使用其他更复杂的格式，如迎风差分格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the convection-diffusion problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement: (Pe, n)\n    test_cases = [\n        (0.0, 8),   # Case A: Pure diffusion\n        (2.0, 8),   # Case B: Threshold\n        (4.0, 8),   # Case C: Convection-dominated, forward\n        (-4.0, 8),  # Case D: Convection-dominated, reverse\n        (1.5, 8),   # Case E: Moderate convection\n    ]\n\n    # Global parameters\n    phi_0 = 1.0\n    phi_L = 0.0\n    epsilon = 1e-12\n    \n    results = []\n    \n    for Pe, n_interior in test_cases:\n        # 1. Build and solve the linear system\n        \n        # Coefficients of the discrete equation: c_W*phi_{i-1} + c_P*phi_i + c_E*phi_{i+1} = 0\n        c_W = 1.0 + Pe / 2.0\n        c_P = -2.0\n        c_E = 1.0 - Pe / 2.0\n        \n        # Assemble the n x n tridiagonal matrix A in banded format for SciPy\n        # ab[0,:] = super-diagonal (c_E)\n        # ab[1,:] = main diagonal (c_P)\n        # ab[2,:] = sub-diagonal (c_W)\n        ab = np.zeros((3, n_interior))\n        ab[0, 1:] = c_E\n        ab[1, :] = c_P\n        ab[2, :-1] = c_W\n        \n        # Assemble the right-hand side vector b\n        b = np.zeros(n_interior)\n        # For i=1, the term c_W * phi_0 moves to the RHS\n        b[0] = -c_W * phi_0\n        # For i=n, the term c_E * phi_{n+1} is zero since phi_{n+1}=0\n        \n        # Solve the system A * phi_interior = b\n        phi_interior = scipy.linalg.solve_banded((1, 1), ab, b)\n        \n        # Construct the full solution vector including boundaries\n        phi_full = np.concatenate(([phi_0], phi_interior, [phi_L]))\n        \n        # 2. Perform diagnostics\n        \n        # Monotonicity check\n        # d_i = phi_i - phi_{i-1}. For monotonic decrease, all d_i should be = 0.\n        diffs = np.diff(phi_full)\n        is_non_monotone = np.any(diffs > epsilon)\n        \n        # Boundedness check (overshoot/undershoot)\n        max_phi = np.max(phi_full)\n        min_phi = np.min(phi_full)\n        is_overshoot = (max_phi > 1.0 + epsilon) or (min_phi  0.0 - epsilon)\n        \n        # Oscillation detection\n        oscillatory = is_non_monotone or is_overshoot\n        \n        # Maximum overshoot magnitude\n        overshoot_mag = np.max([max_phi - 1.0, 0.0, 0.0 - min_phi])\n        \n        # Excess total variation\n        # Total variation for monotonic solution from 1 to 0 is 1.\n        total_variation = np.sum(np.abs(diffs))\n        variation_excess = total_variation - 1.0\n        \n        # 3. Format and aggregate results\n        \n        # Round floats to 6 decimal places as required\n        rounded_overshoot = round(overshoot_mag, 6)\n        rounded_variation = round(variation_excess, 6)\n        rounded_solution = [round(x, 6) for x in phi_full]\n\n        case_result = [\n            oscillatory,\n            rounded_overshoot,\n            rounded_variation,\n            rounded_solution\n        ]\n        results.append(case_result)\n\n    # 4. Print the final output in the exact required format\n    # Manually construct the string to ensure exact formatting (spacing, decimals)\n    result_strings = []\n    for res in results:\n        osc_str = str(res[0])\n        ov_str = f\"{res[1]:.6f}\"\n        var_str = f\"{res[2]:.6f}\"\n        sol_str = '[' + ', '.join([f\"{x:.6f}\" for x in res[3]]) + ']'\n        result_strings.append(f\"[{osc_str}, {ov_str}, {var_str}, {sol_str}]\")\n        \n    final_output = '[' + ', '.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在目睹了中心差分格式的稳定性问题后，我们现在将在时变问题的背景下剖析其误差特性。对于纯对流方程，该格式会产生色散误差，即不同的波分量以错误的速度传播，从而导致尾随的波纹。本练习将采用精确解验证法（method of manufactured solutions）和精密的傅里叶分析，来精确地分离和量化空间离散误差（即色散误差）与时间积分误差，从而帮助您更深入地理解该格式的行为 。",
            "id": "3298150",
            "problem": "考虑在周期性域上的恒定速度线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0,\\quad x \\in [0,2\\pi),\\ t \\ge 0,\n$$\n该方程具有周期性边界条件。设制造的精确解为\n$$\nu(x,t) = \\sin(k x - a t),\n$$\n该解在 $x$ 方向上是 $2\\pi$ 周期的，并且所有角度均使用弧度。所有变量都是无量纲的。您将研究在均匀网格上用于对流的二阶中心差分格式，并在固定的库朗-弗里德里希斯-列维 (CFL) 数下，量化 $L^2$ 误差与网格间距 $\\Delta x$ 的关系，同时分离空间和时间误差的贡献。\n\n从上述守恒律和在间距为 $\\Delta x$ 的均匀网格上的二阶中心差分算子的定义出发，\n$$\n(D_c u)_j \\equiv \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x},\n$$\n方法线法半离散系统为\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u},\n$$\n其中 $\\mathbf{u}$ 是周期性网格上节点值的向量。对于时间积分，使用经典的四阶龙格-库塔方法。\n\n您的程序必须对下文指定的每个测试用例，以及给定网格加密集中的每个网格尺寸 $N$，在一个共同的最终时间 $T$ 计算以下量，同时保持由固定的库朗-弗里德里希斯-列维 (CFL) 数确定的时间步长：\n- 纯空间误差：通过在离散傅里叶基中对角化循环中心差分算子，对半离散系统进行精确的时间积分得到。这会产生时间上精确的半离散解 $\\mathbf{u}_{\\text{space}}(T;\\Delta x)$，其与在网格上采样的解析解之差可以分离出空间离散误差。\n- 纯时间误差：通过使用经典的四阶龙格-库塔方法进行时间积分，并在每个阶段通过在周期性网格上进行谱方法微分（即，使用离散傅里叶变换计算网格上所有可表示的傅里叶模式的精确导数 $\\partial u/\\partial x$）来应用精确的空间导数算子。这会产生 $\\mathbf{u}_{\\text{time}}(T;\\Delta x)$，其与在网格上采样的解析解之差可以分离出时间离散误差。\n- 总误差：通过使用经典的四阶龙格-库塔方法进行时间积分，并在每个阶段应用二阶中心差分算子得到。这会产生 $\\mathbf{u}_{\\text{total}}(T;\\Delta x)$，其与在网格上采样的解析解之差结合了空间和时间误差。\n\n对于每个数值解 $\\mathbf{u}_{\\text{num}} \\in \\{\\mathbf{u}_{\\text{space}},\\mathbf{u}_{\\text{time}},\\mathbf{u}_{\\text{total}}\\}$，计算相对于在网格上采样的精确解的离散 $L^2$ 误差，\n$$\nE_{L^2}(\\Delta x) \\equiv \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2},\n$$\n其中 $x_j = j\\,\\Delta x$ 且 $\\Delta x = \\frac{2\\pi}{N}$。\n\n时间步进必须使用由固定的库朗-弗里德里希斯-列维 (CFL) 数确定的时间步长 $\\Delta t$，\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|},\n$$\n如有必要，缩短最后一步以精确到达时间 $T$。角度必须以弧度为单位。\n\n在可完整运行的程序中实现上述内容，该程序需为每个测试用例的每个网格尺寸 $N$ 返回一个元组，该元组由网格间距和三个 $L^2$ 误差组成：\n$$\n\\left[\\Delta x,\\ E^{\\text{space}}_{L^2}(\\Delta x),\\ E^{\\text{time}}_{L^2}(\\Delta x),\\ E^{\\text{total}}_{L^2}(\\Delta x)\\right].\n$$\n\n测试套件：\n- 用例 1：$a = 1.0$, $k = 4$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$。\n- 用例 2：$a = 1.0$, $k = 16$, $\\text{CFL} = 0.5$, $T = 1.0$, $N \\in \\{64, 128, 256, 512\\}$。\n- 用例 3：$a = 0.3$, $k = 3$, $\\text{CFL} = 0.9$, $T = 2.0$, $N \\in \\{64, 128, 256, 512\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个有效的 JSON 数组形式的结果。顶层是按上述顺序排列的测试用例列表。每个测试用例包含一个按升序排列的网格尺寸 $N$ 的列表。每个元素是该 $N$ 对应的列表 $\\left[\\Delta x,E^{\\text{space}}_{L^2},E^{\\text{time}}_{L^2},E^{\\text{total}}_{L^2}\\right]$。例如，具有两个网格尺寸的输出将如下所示\n$$\n\\left[\\left[[\\Delta x_1,E^{\\text{space}}_{L^2}(\\Delta x_1),E^{\\text{time}}_{L^2}(\\Delta x_1),E^{\\text{total}}_{L^2}(\\Delta x_1)],\\ [\\Delta x_2,E^{\\text{space}}_{L^2}(\\Delta x_2),E^{\\text{time}}_{L^2}(\\Delta x_2),E^{\\text{total}}_{L^2}(\\Delta x_2)]\\right],\\ \\dots\\right]\n$$\n其中填入实际数值。所有数字必须以标准浮点表示法的小数形式打印。角度以弧度为单位，此问题中没有物理单位。",
            "solution": "该问题要求对线性平流方程的二阶中心差分格式的误差特性进行数值研究。该分析涉及将总数值误差分解为空间分量和时间分量。这通过设计三个独立的数值实验来实现：一个在时间上精确以分离空间误差，一个在空间上精确以分离时间误差，以及一个对两者都使用数值近似以捕捉总误差。\n\n控制偏微分方程 (PDE) 是一维恒定速度 $a$ 的线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\,\\frac{\\partial u}{\\partial x} = 0\n$$\n域是周期性的，$x \\in [0,2\\pi)$，我们考虑时间 $t \\ge 0$。提供了一个制造解用于验证和误差分析：\n$$\nu(x,t) = \\sin(k x - a t)\n$$\n其中 $k$ 是波数。该解在 $x$ 方向上是 $2\\pi$ 周期的，并满足该偏微分方程。\n\n数值解在由 $N$ 个点组成的均匀网格上求解，$x_j = j\\,\\Delta x$，其中 $j=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 2\\pi/N$。采用方法线法 (MOL)，即首先对空间导数进行离散化，从而得到一个关于时间的常微分方程组 (ODEs)。空间离散化使用二阶中心差分算子 $D_c$：\n$$\n\\left(D_c u\\right)_j = \\frac{u_{j+1} - u_{j-1}}{2\\,\\Delta x}\n$$\n这导出了半离散系统：\n$$\n\\frac{d \\mathbf{u}}{dt} = -a\\, D_c \\mathbf{u}\n$$\n其中 $\\mathbf{u}(t)$ 是节点值向量 $[u(x_0, t), u(x_1, t), \\dots, u(x_{N-1}, t)]^T$。对于时间积分，指定了经典的四阶龙格-库塔 (RK4) 方法。时间步长 $\\Delta t$ 由一个固定的库朗-弗里德里希斯-列维 (CFL) 数确定：\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|}\n$$\n模拟运行至最终时间 $T$。误差使用离散 $L^2$ 范数进行量化，定义为：\n$$\nE_{L^2}(\\Delta x) = \\left(\\Delta x \\sum_{j=0}^{N-1} \\left[u_{\\text{num}}(x_j,T) - u(x_j,T)\\right]^2\\right)^{1/2}\n$$\n\n问题的核心是在最终时间 $T$ 计算三种类型的误差。\n\n1.  **纯空间误差 ($E^{\\text{space}}_{L^2}$)**：\n    为了分离空间离散化带来的误差，我们对半离散系统 $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ 进行精确的时间积分。这是一个线性常微分方程组 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{A} \\mathbf{u}$，其中矩阵 $\\mathbf{A}$ 代表算子 $-a D_c$。其精确解为 $\\mathbf{u}(T) = e^{\\mathbf{A}T} \\mathbf{u}(0)$。由于 $D_c$ 在周期性网格上是一个循环矩阵，因此通过离散傅里叶变换 (DFT) 对 $\\mathbf{A}$ 进行对角化，可以高效地计算矩阵指数。\n    算子 $-a D_c$ 的特征值可以通过将其应用于傅里叶模式 $e^{imx}$ 来找到，其中 $m$ 是一个整数波数。\n    $$\n    -a D_c e^{imx} = -a \\frac{e^{im(x+\\Delta x)} - e^{im(x-\\Delta x)}}{2\\Delta x} = -a \\frac{i \\sin(m \\Delta x)}{\\Delta x} e^{imx}\n    $$\n    因此，对应于波数 $m$ 的特征值 $\\lambda_m$ 是 $\\lambda_m = -ia \\frac{\\sin(m \\Delta x)}{\\Delta x}$。该项通常被称为离散算子的符号。每个傅里叶系数 $\\hat{u}_m(t)$ 的精确演化由 $\\frac{d\\hat{u}_m}{dt} = \\lambda_m \\hat{u}_m$ 给出，从而得到 $\\hat{u}_m(T) = \\hat{u}_m(0) e^{\\lambda_m T}$。\n    算法如下：\n    a. 通过在网格上采样 $u(x,0)=\\sin(kx)$ 来计算初始条件向量 $\\mathbf{u}(0)$。\n    b. 计算其 DFT 以获得初始傅里叶系数 $\\hat{\\mathbf{u}}(0)$。\n    c. 对于网格上可表示的每个波数 $m$，将相应的系数 $\\hat{u}_m(0)$ 乘以演化因子 $e^{\\lambda_m T}$。\n    d. 计算所得系数的逆 DFT 以获得解向量 $\\mathbf{u}_{\\text{space}}(T)$。\n    e. 计算与在网格上采样的精确解 $u(x,T)$ 的 $L^2$ 误差 $E^{\\text{space}}_{L^2}$。\n\n2.  **纯时间误差 ($E^{\\text{time}}_{L^2}$)**：\n    为了分离时间积分带来的误差，对于网格可以表示的所有傅里叶模式，偏微分方程中的空间导数被精确计算。这被称为谱方法微分。半离散系统变为 $\\frac{d \\mathbf{u}}{dt} = -a \\frac{\\partial \\mathbf{u}}{\\partial x}_{\\text{exact}}$，然后使用 RK4 方法进行积分。带限函数的精确导数在傅里叶空间中计算。$u(x) = \\sum_m \\hat{u}_m e^{imx}$ 的导数是 $\\frac{\\partial u}{\\partial x} = \\sum_m (im) \\hat{u}_m e^{imx}$。\n    每个 RK4 阶段的算法是：\n    a. 给定状态向量 $\\mathbf{v}$，计算其 DFT，$\\hat{\\mathbf{v}}$。\n    b. 将每个系数 $\\hat{v}_m$ 乘以 $im$。\n    c. 计算 IDFT 以获得精确的导数向量 $\\frac{\\partial \\mathbf{v}}{\\partial x}$。\n    d. ODE 求解器的右侧项则为 $-a \\frac{\\partial \\mathbf{v}}{\\partial x}$。\n    从 $\\mathbf{u}(0)$ 开始，重复此过程所需的步数，以获得 $\\mathbf{u}_{\\text{time}}(T)$。然后计算 $L^2$ 误差 $E^{\\text{time}}_{L^2}$。\n\n3.  **总误差 ($E^{\\text{total}}_{L^2}$)**：\n    这是标准的数值模拟，其中空间和时间都被离散化。半离散系统 $\\frac{d \\mathbf{u}}{dt} = -a D_c \\mathbf{u}$ 使用 RK4 方法进行积分。在每个 RK4 阶段，通过将中心差分算子 $D_c$ 应用于当前状态向量来计算右侧项。这会产生解 $\\mathbf{u}_{\\text{total}}(T)$，并由此计算总误差 $E^{\\text{total}}_{L^2}$。\n\n通过在一系列加密的网格（增加 $N$）上计算这三个误差度量，我们可以分析空间、时间和组合格式的收敛率。空间格式是二阶的，因此 $E^{\\text{space}}_{L^2}$ 应与 $(\\Delta x)^2$ 成比例。RK4 积分器是四阶的，因此 $E^{\\text{time}}_{L^2}$ 应与 $(\\Delta t)^4$ 成比例，对于固定的 CFL 数，这与 $(\\Delta x)^4$ 成比例。总误差通常由阶数较低的分量主导，因此预计 $E^{\\text{total}}_{L^2}$ 将与 $(\\Delta x)^2$ 成比例。",
            "answer": "```python\nimport numpy as np\nimport json\nimport math\n\ndef calculate_spatial_solution(u0, a, T, N, dx):\n    \"\"\"\n    Computes the semi-discrete solution integrated exactly in time.\n    This isolates the spatial discretization error.\n    \"\"\"\n    # DFT of initial condition\n    u0_hat = np.fft.fft(u0)\n    \n    # Integer wavenumbers corresponding to FFT output\n    m = np.fft.fftfreq(N) * N\n    \n    # Symbol of the central difference operator (modified wavenumber)\n    # Handle m=0 case to avoid 0/0, though sin(0)/dx is 0 anyway.\n    # The term is i * sin(m*dx)/dx. The evolution is exp(-a * T * i * sin(m*dx)/dx)\n    m_modified = np.zeros_like(m, dtype=float)\n    non_zero_m = m != 0\n    m_modified[non_zero_m] = np.sin(m[non_zero_m] * dx) / dx\n    \n    # Evolve each Fourier mode exactly in time\n    evolution_operator = np.exp(-1j * a * m_modified * T)\n    uT_hat = u0_hat * evolution_operator\n    \n    # Inverse DFT to get the solution in physical space\n    uT = np.fft.ifft(uT_hat)\n    \n    return uT.real\n\ndef rk4_step(rhs_func, u, dt, *args):\n    \"\"\"A single step of the classical 4th-order Runge-Kutta method.\"\"\"\n    k1 = rhs_func(u, *args)\n    k2 = rhs_func(u + dt / 2.0 * k1, *args)\n    k3 = rhs_func(u + dt / 2.0 * k2, *args)\n    k4 = rhs_func(u + dt * k3, *args)\n    return u + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef spectral_rhs(u, a, N):\n    \"\"\"RHS function using spectral differentiation for -a * du/dx.\"\"\"\n    u_hat = np.fft.fft(u)\n    m = np.fft.fftfreq(N) * N\n    du_dx_hat = 1j * m * u_hat\n    du_dx = np.fft.ifft(du_dx_hat)\n    return -a * du_dx\n\ndef calculate_temporal_solution(u0, a, T, N, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and spectral differentiation in space.\n    This isolates the temporal discretization error.\n    \"\"\"\n    u = u0.copy().astype(np.complex128)\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(spectral_rhs, u, dt, a, N)\n        t += dt\n        \n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(spectral_rhs, u, dt_final, a, N)\n        \n    return u.real\n\ndef central_diff_rhs(u, a, dx):\n    \"\"\"RHS function using 2nd-order central differences for -a * du/dx.\"\"\"\n    du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2.0 * dx)\n    return -a * du_dx\n\ndef calculate_total_solution(u0, a, T, dx, dt):\n    \"\"\"\n    Computes the solution using RK4 in time and central differences in space.\n    This captures the total numerical error.\n    \"\"\"\n    u = u0.copy()\n    t = 0.0\n    num_steps = math.floor(T / dt)\n    \n    for _ in range(num_steps):\n        u = rk4_step(central_diff_rhs, u, dt, a, dx)\n        t += dt\n\n    # Final shortened step to hit T exactly\n    if T - t > 1e-12:\n        dt_final = T - t\n        u = rk4_step(central_diff_rhs, u, dt_final, a, dx)\n        \n    return u.real\n\ndef compute_errors_for_case(a, k, CFL, T, N):\n    \"\"\"\n    Main computation for a single grid size N.\n    Sets up the problem and computes the three error types.\n    \"\"\"\n    # Grid and initial conditions\n    dx = 2.0 * np.pi / N\n    x = np.arange(N) * dx\n    u_initial = np.sin(k * x)\n    u_exact_final = np.sin(k * x - a * T)\n    dt = CFL * dx / np.abs(a)\n\n    # 1. Spatial-only error\n    u_space = calculate_spatial_solution(u_initial, a, T, N, dx)\n    error_space = np.sqrt(dx * np.sum((u_space - u_exact_final)**2))\n    \n    # 2. Temporal-only error\n    u_time = calculate_temporal_solution(u_initial, a, T, N, dt)\n    error_time = np.sqrt(dx * np.sum((u_time - u_exact_final)**2))\n\n    # 3. Total error\n    u_total = calculate_total_solution(u_initial, a, T, dx, dt)\n    error_total = np.sqrt(dx * np.sum((u_total - u_exact_final)**2))\n    \n    return [dx, error_space, error_time, error_total]\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'k': 4,  'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 1.0, 'k': 16, 'CFL': 0.5, 'T': 1.0, 'N_list': [64, 128, 256, 512]},\n        {'a': 0.3, 'k': 3,  'CFL': 0.9, 'T': 2.0, 'N_list': [64, 128, 256, 512]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = []\n        for N in case['N_list']:\n            result_tuple = compute_errors_for_case(\n                case['a'], case['k'], case['CFL'], case['T'], N\n            )\n            case_results.append(result_tuple)\n        all_results.append(case_results)\n\n    # Print the final result in the specified JSON format on a single line\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```"
        },
        {
            "introduction": "前面的实践突显了核心的困境：中心差分格式虽然精确但会产生振荡，而简单的一阶迎风格式虽然稳定但耗散过大。最后一个实践将通过引导您实现一个现代的混合通量格式来弥合这一差距。通过设计一个“光滑度传感器”，我们可以动态地将低耗散的中心通量与稳健的 Rusanov（类迎风）通量相融合，仅在需要捕捉急剧梯度的地方施加人工耗散以抑制振荡，同时在解的光滑区域保持高精度 。",
            "id": "3298134",
            "problem": "考虑周期性区域上守恒形式的一维线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\n其中平流速度 $a0$ 为常数。所有量均为无量纲，所有角度（例如，正弦函数的参数）均以弧度为单位。在有限体积框架下，使用宽度为 $\\Delta x$ 的均匀网格单元，并将单元平均未知量 $u_i(t)$ 定义在单元中心。对一个单元进行积分得到的守恒律可表示为\n$$\n\\frac{d}{dt}u_i(t) = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是在单元交界面 $x_{i+\\frac{1}{2}}$ 处逼近物理通量 $f(u)=a\\,u$ 的相容数值通量。\n\n从该有限体积方法基础和数值通量的定义出发：\n\n- 交界面上的中心通量取决于从相邻单元重构的状态 $u_L$ 和 $u_R$，并且是这些状态下物理通量的一个对称、相容的平均值。\n- Rusanov（也称为局部Lax–Friedrichs）通量是一种用于双曲守恒律的单调通量，它增加了一个与最大局部波速成正比的耗散项。\n\n在每个交界面上定义一个光滑度传感器，其形式为\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon},\n$$\n其中 $\\varepsilon0$，在一维情况下，梯度大小可近似为\n$$\n\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x}.\n$$\n\n任务：\n\n1. 基于单元平均的有限体积公式和上述定义，在每个交界面上推导出一个混合数值通量。该通量使用光滑度传感器 $S_{i+\\frac{1}{2}}$ 来混合中心通量和Rusanov通量的贡献，使得在光滑区域，该通量接近中心差分格式，而在间断附近，则接近迎风格式（Rusanov）。写出由此产生的半离散格式，并指出该混合方法引入的等效耗散贡献。\n\n2. 从基本原理（质量守恒和特征输运）出发，解释为什么对于一个光滑的傅里叶模态，当传感器 $S_{i+\\frac{1}{2}}$ 很小时，混合通量应比纯迎风格式减少耗散；并解释为什么在间断附近，传感器 $S_{i+\\frac{1}{2}}$ 应趋近于1，从而恢复单调的激波捕捉行为。\n\n3. 使用推导出的混合通量和周期性边界条件，实现一个一维求解器。时间步进采用强稳定保持三阶龙格-库塔（SSP-RK3）方法，并使用保证稳定性的库朗-弗里德里希斯-列维（CFL）数 $C = a\\,\\Delta t/\\Delta x$。在 $x_{i+\\frac{1}{2}}$ 处的界面梯度大小必须计算为 $|u_{i+1}-u_i|/\\Delta x$，并且必须使用传感器 $S_{i+\\frac{1}{2}}$ 在数值通量中混合每个交界面上的中心和Rusanov贡献。取 $a=1$ 和区域长度 $L=1$。\n\n4. 针对以下初始条件分析其行为：\n   - 一个光滑的正弦波，$u(x,0) = \\sin(2\\pi x)$ 在 $[0,1]$ 上。演化一个完整的平流周期 $T = L/a$，并报告相对于时刻 $T$ 的精确解的均方根误差（每个单元的离散 $\\ell^2$ 范数，即所有单元上均方误差的平方根）。将此误差报告为无单位的浮点数。\n   - 一个间断的方波，在 $[0,1]$ 上（具有周期性），当 $x\\in[0.25,0.5)$ 时 $u(x,0) = 1$，否则 $u(x,0)=0$。演化到时间 $T=\\frac{1}{4}L/a$，并报告两个浮点数：过冲幅度 $\\max(0,\\max_i u_i - 1)$ 和下冲幅度 $\\max(0,0 - \\min_i u_i)$。\n\n5. 使用以下参数元组的测试套件 $(\\text{初始条件类型}, N, C, \\varepsilon, \\text{周期数})$，其中 $N$ 是单元数量，$C$ 是库朗-弗里德里希斯-列维数，$\\varepsilon$ 是光滑度正则化参数，$\\text{cycles}$ 是要模拟的域穿越次数（因此最终时间为 $T = \\text{cycles}\\times L/a$）：\n   - $($sine$, 128, 0.45, 10^{-2}, 1.0)$\n   - $($sine$, 128, 0.45, 10^{-6}, 1.0)$\n   - $($step$, 512, 0.45, 10^{-2}, 0.25)$\n   - $($step$, 512, 0.45, 10^{1}, 0.25)$\n\n6. 最终输出格式：您的程序应生成一行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，顺序与测试套件相同。对于正弦波情况，输出一个表示最终时刻均方根误差的浮点数。对于阶跃波情况，输出一个包含两个浮点数的列表 $[\\,\\text{过冲},\\,\\text{下冲}\\,]$。例如，一个语法上有效的输出格式为\n$$\n[\\ e_1,\\ e_2,\\ [o_3,u_3],\\ [o_4,u_4]\\ ],\n$$\n其中 $e_j$ 是浮点数，$o_k,u_k$ 是浮点数。",
            "solution": "该问题经评估有效。所有提供的信息在科学上是合理的、自洽的，并且足以推导和实现一个完整的解决方案。这些任务是计算流体力学领域的标准练习，特别涉及现代激波捕捉有限体积格式的设计和分析。\n\n根据问题陈述的要求，解决方案分几个部分展开。\n\n_**1. 混合通量和半离散格式的推导**_\n\n推导的基础是用于守恒律的一维有限体积法。对于线性平流方程 $\\partial_t u + \\partial_x f(u) = 0$，其物理通量为 $f(u) = a u$，宽度为 $\\Delta x$ 的单元 $i$ 的半离散守恒律为：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right)\n$$\n其中 $u_i$ 是单元平均量，$F_{i\\pm\\frac{1}{2}}$ 是单元交界面上的数值通量。给定平流速度 $a  0$。\n\n首先，我们定义在单元 $i$（左状态 $u_L=u_i$）和单元 $i+1$（右状态 $u_R=u_{i+1}$）之间的交界面 $x_{i+\\frac{1}{2}}$ 上的组分通量。\n\n**中心通量**是左右状态物理通量的算术平均值：\n$$\nF_{i+\\frac{1}{2}}^{C} = \\frac{f(u_i) + f(u_{i+1})}{2} = a \\frac{u_i + u_{i+1}}{2}\n$$\n该通量可得到二阶精度的空间离散，但由于缺乏数值耗散，对于纯平流问题是不稳定的。\n\n**Rusanov通量**（或局部Lax-Friedrichs通量）引入耗散以确保稳定性。其定义为：\n$$\nF_{i+\\frac{1}{2}}^{R} = \\frac{f(u_i) + f(u_{i+1})}{2} - \\frac{\\alpha_{i+\\frac{1}{2}}}{2}(u_{i+1} - u_i)\n$$\n其中 $\\alpha_{i+\\frac{1}{2}}$ 是交界面处的最大局部波速。对于线性平流方程，唯一的波速（通量雅可比矩阵 $\\partial f / \\partial u$ 的特征值）是 $a$。因此，$\\alpha_{i+\\frac{1}{2}} = |a|$。由于 $a  0$，我们有 $\\alpha_{i+\\frac{1}{2}} = a$。将此代入Rusanov通量定义中，得到：\n$$\nF_{i+\\frac{1}{2}}^{R} = a \\frac{u_i + u_{i+1}}{2} - \\frac{a}{2}(u_{i+1} - u_i) = \\frac{a u_i + a u_{i+1} - a u_{i+1} + a u_i}{2} = a u_i\n$$\n对于 $a0$，这是一阶迎风通量，以其鲁棒性和单调性而闻名，但同时也具有强耗散性（一阶精度）。\n\n接下来，我们按照规定在交界面 $x_{i+\\frac{1}{2}}$ 处定义**光滑度传感器**：\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon}\n$$\n使用所提供的一维梯度大小近似值 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x}$，传感器变为：\n$$\nS_{i+\\frac{1}{2}} = \\frac{\\frac{|u_{i+1} - u_i|}{\\Delta x}}{\\frac{|u_{i+1} - u_i|}{\\Delta x} + \\varepsilon} = \\frac{|u_{i+1} - u_i|}{|u_{i+1} - u_i| + \\varepsilon \\Delta x}\n$$\n参数 $\\varepsilon  0$ 对传感器进行正则化，并充当阈值。\n\n**混合通量** $F_{i+\\frac{1}{2}}^{H}$ 的构建旨在混合中心通量和Rusanov通量。一种常见的表达方式是从中心通量开始，并添加一个由传感器缩放的耗散项。该耗散项是中心通量与Rusanov通量之差：\n$$\nF_{i+\\frac{1}{2}}^{R} - F_{i+\\frac{1}{2}}^{C} = a u_i - a \\frac{u_i + u_{i+1}}{2} = -\\frac{a}{2}(u_{i+1} - u_i)\n$$\n混合通量则是一个凸组合，$F^H = (1-S)F^C + S F^R$，可以重写为：\n$$\nF_{i+\\frac{1}{2}}^{H} = F_{i+\\frac{1}{2}}^{C} + S_{i+\\frac{1}{2}} \\left( F_{i+\\frac{1}{2}}^{R} - F_{i+\\frac{1}{2}}^{C} \\right) = a \\frac{u_i + u_{i+1}}{2} - S_{i+\\frac{1}{2}} \\frac{a}{2}(u_{i+1} - u_i)\n$$\n这个公式清楚地表明，混合通量是中心通量加上一个可控量的数值耗散。\n\n将此混合通量代入半离散有限体积格式中，得到：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{H} - F_{i-\\frac{1}{2}}^{H} \\right)\n$$\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left[ \\left( a \\frac{u_i + u_{i+1}}{2} - S_{i+\\frac{1}{2}} \\frac{a}{2}(u_{i+1} - u_i) \\right) - \\left( a \\frac{u_{i-1} + u_i}{2} - S_{i-\\frac{1}{2}} \\frac{a}{2}(u_i - u_{i-1}) \\right) \\right]\n$$\n将中心通量项和耗散项分组，得到最终的半离散形式：\n$$\n\\frac{d u_i}{dt} = -a \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} + \\frac{a}{2\\Delta x} \\left[ S_{i+\\frac{1}{2}}(u_{i+1} - u_i) - S_{i-\\frac{1}{2}}(u_i - u_{i-1}) \\right]\n$$\n第一项是平流项 $-a \\partial_x u$ 的标准二阶中心差分近似。第二项是由混合引入的**等效耗散贡献**。该项具有耗散通量散度的形式，类似于一个非线性人工扩散项 $\\partial_x(\\nu(u) \\partial_x u)$，其中交界面 $x_{i+\\frac{1}{2}}$ 处的数值粘性系数可以确定为 $\\nu_{i+\\frac{1}{2}} = S_{i+\\frac{1}{2}} \\frac{a \\Delta x}{2}$。\n\n_**2. 从基本原理出发的解释**_\n\n混合格式的行为由光滑度传感器 $S$ 决定。\n\n_在光滑区域的行为（例如，傅里叶模态）：_\n对于光滑解，例如正弦波 $u(x,t) = \\sin(k(x-at))$，相邻单元之间的差值 $|u_{i+1} - u_i|$ 与网格间距 $\\Delta x$ 成正比。具体来说，$|u_{i+1} - u_i| \\approx |\\partial_x u| \\Delta x = |k \\cos(k(x-at))| \\Delta x$，其量级为 $O(\\Delta x)$。因此，梯度近似为 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x} = O(1)$。传感器变为 $S_{i+\\frac{1}{2}} \\approx \\frac{\\|\\nabla u\\|}{\\|\\nabla u\\| + \\varepsilon}$。\n如果选择的 $\\varepsilon$ 远大于典型的梯度大小 $\\|\\nabla u\\|$，那么 $S_{i+\\frac{1}{2}}$ 将会很小。例如，如果 $\\varepsilon \\gg \\|\\nabla u\\|$，则 $S \\to 0$。在此极限下，耗散项消失，通量 $F^H$ 趋近于中心通量 $F^C$，从而得到一个更高阶（耗散更小）的格式。从基本原理来看，特征输运决定了波形应在传播过程中保持不变。数值耗散是低阶格式（如纯迎风的Rusanov格式）固有的特性，它会衰减傅里叶模态的振幅，导致精度损失。通过在不需要耗散的地方（即 $S$ 很小的光滑区域）减少耗散，与一阶Rusanov格式相比，混合格式能更好地保持光滑波的形状和振幅。由于半离散方程的通量差分形式，质量是守恒的。（注意：对于本问题中给定的正弦波参数，$\\|\\nabla u\\| \\approx 2\\pi \\gg \\varepsilon$，因此传感器 $S$ 将接近1，格式的行为将类似于耗散的Rusanov格式。如果 $\\varepsilon$ 选择得当，该原理仍然成立。）\n\n_在间断附近的行为：_\n在间断（例如阶跃）附近，解在单个单元内表现出巨大的跳跃。差值 $|u_{i+1} - u_i|$ 的量级为 $O(1)$，与 $\\Delta x$ 无关。因此，梯度近似 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\approx \\frac{|u_{i+1} - u_i|}{\\Delta x} = O(1/\\Delta x)$。随着网格加密（$\\Delta x \\to 0$），该项变得非常大。\n传感器为 $S_{i+\\frac{1}{2}} = \\frac{\\|\\nabla u\\|_{i+\\frac{1}{2}}}{\\|\\nabla u\\|_{i+\\frac{1}{2}} + \\varepsilon}$。当 $\\|\\nabla u\\|_{i+\\frac{1}{2}} \\to \\infty$ 时，分母由该项主导，因此 $S_{i+\\frac{1}{2}} \\to 1$。\n当 $S_{i+\\frac{1}{2}} \\to 1$ 时，混合通量 $F^H$ 趋近于Rusanov通量 $F^R$。Rusanov通量在此处等价于一阶迎风格式，是一种**单调**通量。单调性是为处理间断而设计的格式的一个关键属性，因为它保证不会产生新的局部极值（过冲或下冲）。这可以防止在间断周围形成非物理振荡（吉布斯现象）。因此，通过在梯度大的地方转换为Rusanov通量，混合格式会自动激活必要的耗散，以清晰且鲁棒地捕捉间断，体现了所期望的“激波捕捉”行为，同时保持严格的质量守恒。\n\n_**3. 实现摘要**_\n\n数值求解器按如下方式实现：\n- **区域和网格：** 将长度为 $L=1$ 的一维区域离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元。\n- **时间积分：** 使用强稳定保持三阶龙格-库塔（SSP-RK3）方法对半离散方程进行时间推进。时间步长 $\\Delta t$ 由库朗-弗里德里希斯-列维（CFL）数决定，$\\Delta t = C \\Delta x / a$。\n- **空间离散：** 在龙格-库塔方法的每个阶段，计算半离散方程的右端项 $\\mathcal{L}(u)$。这包括：\n    1. 应用周期性边界条件，通常使用数组滚动或幽灵单元处理。\n    2. 对于每个交界面 $x_{i+\\frac{1}{2}}$，使用状态 $u_i$ 和 $u_{i+1}$ 以及推导出的传感器和通量公式，计算混合通量 $F_{i+\\frac{1}{2}}^{H}$。\n    3. 对所有单元 $i$ 计算通量差 $(F_{i+\\frac{1}{2}}^{H} - F_{i-\\frac{1}{2}}^{H})$。\n    4. 除以 $-\\Delta x$ 得到最终的更新向量 $\\mathcal{L}(u)_i$。\n\n_**4. 分析方法**_\n\n- **正弦波情况：** 初始条件为 $u(x,0) = \\sin(2\\pi x)$。模拟运行一个完整周期，$T = L/a = 1$。由于周期性，此时的精确解与初始条件相同，$u_{exact}(x,T) = u(x-aT,0) = u(x-1,0) = u(x,0)$。误差通过离散 $\\ell^2$ 范数（均方根误差）来量化：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} (u_i(T) - u_{i, \\text{exact}}(T))^2}\n$$\n- **方波情况：** 初始条件是阶跃函数。模拟运行时间为 $T=0.25$，这将阶跃平移了四分之一的区域长度。激波捕捉的质量通过非物理振荡的幅度来衡量：\n$$\n\\text{过冲} = \\max(0, \\max_i u_i(T) - 1.0)\n$$\n$$\n\\text{下冲} = \\max(0, 0.0 - \\min_i u_i(T))\n$$\n这些指标量化了格式在多大程度上违反了 $[0, 1]$ 的原始范围。\n\n_**5. 测试套件的预期结果**_\n\n- **情况1和2（正弦波）：** 梯度大小 $\\|\\nabla u\\| \\approx 2\\pi \\approx 6.28$。对于 $\\varepsilon=10^{-2}$ 和 $\\varepsilon=10^{-6}$，梯度大小都远大于 $\\varepsilon$。因此，在这两种情况下，传感器 $S$ 都将非常接近1。该格式的行为将几乎与一阶Rusanov（迎风）格式完全相同，后者是强耗散的。我们预计会得到一个相对较大的均方根误差，表明其为一阶精度，其中 $\\varepsilon=10^{-6}$ 的误差与 $\\varepsilon=10^{-2}$ 的误差相比，差异很小（可能略大）。\n- **情况3（阶跃波, $\\varepsilon=10^{-2}$）：** 在间断处，$\\|\\nabla u\\| = 1/\\Delta x = 512$。由于 $\\|\\nabla u\\| \\gg \\varepsilon$，传感器 $S \\to 1$。这会正确地激活单调的Rusanov通量，从而抑制振荡。我们预计过冲和下冲会非常小或为零。\n- **情况4（阶跃波, $\\varepsilon=10^{1}$）：** 在这种情况下，与梯度大小 $\\|\\nabla u\\|=512$ 相比，$\\varepsilon=10$ 并不小。间断处的传感器值将为 $S = 512 / (512+10) \\approx 0.98$。由于 $S  1$，通量不是完全的Rusanov通量；它保留了中心通量的成分，而中心通量已知会在间断处产生振荡。因此，我们预计在这种情况下会出现显著的过冲和下冲。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a hybrid flux scheme.\n    \"\"\"\n\n    def spatial_operator(u, a, dx, eps):\n        \"\"\"\n        Computes the right-hand side of the semi-discrete equation du/dt = L(u).\n        L(u) = -1/dx * (F_{i+1/2} - F_{i-1/2})\n        \"\"\"\n        # Periodic boundary conditions by rolling the array\n        u_p = np.roll(u, -1)  # u_{i+1} for all i\n\n        # Left and right states at interfaces i+1/2\n        u_L = u\n        u_R = u_p\n\n        # 1. Compute smoothness sensor S_{i+1/2}\n        # Using the formulation S = |u_R-u_L| / (|u_R-u_L| + eps*dx) is numerically\n        # more stable than the gradient formulation to avoid division by dx then\n        # multiplication by dx later.\n        # grad_norm = np.abs(u_R - u_L) / dx\n        # sensor = grad_norm / (grad_norm + eps)\n        # The line below is equivalent and avoids potential floating point issues with small dx.\n        sensor = np.abs(u_R - u_L) / (np.abs(u_R - u_L) + eps * dx)\n\n        # 2. Compute hybrid flux F^H_{i+1/2}\n        # F^H = a*(u_L+u_R)/2 - S*a/2*(u_R-u_L)\n        F_central = a * (u_L + u_R) / 2.0\n        F_dissipative_term = sensor * a / 2.0 * (u_R - u_L)\n        F_iph = F_central - F_dissipative_term # Flux at i+1/2\n\n        # 3. Compute flux at i-1/2 by rolling\n        F_imh = np.roll(F_iph, 1)\n\n        # 4. Compute RHS\n        rhs = -(F_iph - F_imh) / dx\n        return rhs\n\n    test_cases = [\n        ('sine', 128, 0.45, 1e-2, 1.0),\n        ('sine', 128, 0.45, 1e-6, 1.0),\n        ('step', 512, 0.45, 1e-2, 0.25),\n        ('step', 512, 0.45, 1e1, 0.25),\n    ]\n\n    results = []\n    a = 1.0\n    L = 1.0\n\n    for case in test_cases:\n        ic_type, N, C, eps, cycles = case\n        \n        # Grid and time step\n        dx = L / N\n        dt = C * dx / a\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Initial condition\n        if ic_type == 'sine':\n            u0 = np.sin(2.0 * np.pi * x)\n        elif ic_type == 'step':\n            u0 = np.zeros(N)\n            u0[(x >= 0.25)  (x  0.5)] = 1.0\n        else:\n            raise ValueError(f\"Unknown IC type: {ic_type}\")\n\n        u = u0.copy()\n        \n        # Simulation time\n        T_final = cycles * L / a\n        num_steps = int(np.ceil(T_final / dt))\n        # Adjust dt to hit T_final exactly\n        dt = T_final / num_steps\n        \n        # SSP-RK3 time integration loop\n        for _ in range(num_steps):\n            # Stage 1\n            L_u = spatial_operator(u, a, dx, eps)\n            u1 = u + dt * L_u\n            \n            # Stage 2\n            L_u1 = spatial_operator(u1, a, dx, eps)\n            u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt * L_u1\n            \n            # Stage 3\n            L_u2 = spatial_operator(u2, a, dx, eps)\n            u = (1.0/3.0) * u + (2.0/3.0) * u2 + (2.0/3.0) * dt * L_u2\n\n        # Post-processing and analysis\n        if ic_type == 'sine':\n            # Exact solution after 1 cycle is the initial condition\n            u_exact = u0\n            rmse = np.sqrt(np.mean((u - u_exact)**2))\n            results.append(rmse)\n        elif ic_type == 'step':\n            overshoot = max(0.0, np.max(u) - 1.0)\n            undershoot = max(0.0, 0.0 - np.min(u))\n            results.append([overshoot, undershoot])\n    \n    # Custom string conversion to match the example format [o, u]\n    def format_result(item):\n        if isinstance(item, list):\n            return f\"[{item[0]}, {item[1]}]\"\n        return str(item)\n    \n    # The final format required is a Python list representation.\n    # The default string conversion of a list of lists/floats is correct.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}