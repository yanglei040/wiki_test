{
    "hands_on_practices": [
        {
            "introduction": "在将数值格式应用于实际问题之前，进行理论分析以确定其稳定性至关重要。冯·诺依曼（von Neumann）稳定性分析是一种基本工具，通过考察每个傅里叶模式随时间的增长或衰减来评估线性格式的稳定性。本练习将引导您推导出一阶迎风格式在与两种不同时间积分器耦合时的放大因子，从而确定保证单调性（即不产生新的极值）的 Courant–Friedrichs–Lewy (CFL) 条件 。",
            "id": "3318483",
            "problem": "考虑一维常系数线性平流方程 $u_{t} + a\\,u_{x} = 0$（其中 $a>0$），该方程定义在一个无限、均匀的网格上，网格间距为 $\\Delta x$，并具有周期性以便进行 Fourier 分析。使用施主单元（一阶迎风）通量对对流项进行离散化，以获得一个半离散常微分方程。时间上使用前向显式 Euler 方法或三阶强稳定保持 Runge-Kutta 方法 (SSPRK(3)) 进行推进。定义 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。\n\n使用 von Neumann 分析方法，并采用离散 Fourier 模 $u_{j}^{n} = \\hat{u}^{n}\\exp(\\mathrm{i}\\,k\\,j\\,\\Delta x)$，推导施主单元格式与每种时间积分器耦合时的放大因子 $G(k)$：\n- $G_{\\mathrm{E}}(k)$，用于显式 Euler 方法，\n- $G_{\\mathrm{SSPRK3}}(k)$，用于 SSPRK(3) 方法。\n\n施加单调性要求：\n- 对于任何波数，Fourier 振幅在一个时间步内不增长，即对所有 $k$ 都有 $|G(k)| \\leq 1$，\n- 更新过程不会在物理空间中产生新的极值点，即，它是当前时间层级上现有解值的凸组合，或由它们与非负权重构成的复合。\n\n对于每种时间积分器，确定在施主单元空间离散化下能同时满足两个单调性要求的 CFL 数 $\\nu$ 的最紧上界。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境，将你的最终答案表示为单行矩阵中的一对数值 $\\left(\\nu_{\\max}^{\\mathrm{Euler}},\\,\\nu_{\\max}^{\\mathrm{SSPRK3}}\\right)$。无需四舍五入；CFL 数是无量纲的，因此不要报告单位。",
            "solution": "本题要求确定线性平流方程的一阶迎风离散格式在与两种不同的时间积分器耦合时，满足两个指定单调性要求的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu$ 的最紧上界。\n\n控制偏微分方程为具有恒定正波速 $a$ 的一维线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0, \\quad a > 0\n$$\n\n首先，我们在间距为 $\\Delta x$ 的均匀网格上离散化空间导数 $u_x$。题目指定了施主单元（或称一阶迎风）格式。由于波速 $a$ 为正，信息从左向右传播，因此迎风方向是从节点 $j-1$ 到 $j$。我们对 $u_x$ 使用一阶后向差分：\n$$\nu_x \\bigg|_{j} \\approx \\frac{u_j - u_{j-1}}{\\Delta x}\n$$\n将其代入控制方程，得到一个半离散的常微分方程组 (ODEs)，每个网格点 $j$ 对应一个方程：\n$$\n\\frac{du_j(t)}{dt} = -\\frac{a}{\\Delta x} \\left(u_j(t) - u_{j-1}(t)\\right)\n$$\n这可以写成 $\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})$ 的形式，其中 $L$ 是空间离散化算子。\n\n分析过程将分别考虑每种时间积分器。\n\n### 1. 前向显式 Euler 时间积分\n\n前向 Euler 方法将解从时间层级 $n$ 更新到 $n+1$ 的方式为 $u_j^{n+1} = u_j^n + \\Delta t \\left(\\frac{du_j}{dt}\\right)^n$。将此应用于我们的半离散方程，得到：\n$$\nu_j^{n+1} = u_j^n + \\Delta t \\left( -\\frac{a}{\\Delta x} (u_j^n - u_{j-1}^n) \\right)\n$$\n使用 CFL 数的定义 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$，全离散格式为：\n$$\nu_j^{n+1} = u_j^n - \\nu (u_j^n - u_{j-1}^n)\n$$\n$$\nu_j^{n+1} = (1-\\nu)u_j^n + \\nu u_{j-1}^n\n$$\n\n我们现在根据所述的两个要求来分析这个格式。\n\n**要求2：凸组合**\n第二个要求是更新过程是现有解值的凸组合，对于这个线性格式，这意味着右侧的系数必须为非负且总和为 $1$。\n系数为 $c_0 = 1-\\nu$ 和 $c_{-1} = \\nu$。\n系数之和为 $(1-\\nu) + \\nu = 1$。\n为使系数非负，我们要求：\n1. $\\nu \\ge 0$：由于 $a>0$、$\\Delta t>0$ 和 $\\Delta x>0$，这个条件自然满足。\n2. $1-\\nu \\ge 0 \\implies \\nu \\le 1$。\n因此，当且仅当 $0 \\le \\nu \\le 1$ 时，该格式是单调的（不产生新的极值点）。从此条件得出的最紧上界是 $\\nu \\le 1$。\n\n**要求1：Von Neumann 稳定性**\n第一个要求是对于所有波数 $k$，$|G(k)| \\le 1$。我们通过将单个 Fourier 模 $u_j^n = \\hat{u}^n \\exp(\\mathrm{i} k j \\Delta x)$ 代入离散方程来推导放大因子 $G_{\\mathrm{E}}(k)$：\n$$\n\\hat{u}^{n+1}\\exp(\\mathrm{i} k j \\Delta x) = (1-\\nu)\\hat{u}^n\\exp(\\mathrm{i} k j \\Delta x) + \\nu\\hat{u}^n\\exp(\\mathrm{i} k (j-1) \\Delta x)\n$$\n两边同除以 $\\hat{u}^n \\exp(\\mathrm{i} k j \\Delta x)$，我们得到放大因子 $G_{\\mathrm{E}}(k) = \\frac{\\hat{u}^{n+1}}{\\hat{u}^n}$：\n$$\nG_{\\mathrm{E}}(k) = (1-\\nu) + \\nu \\exp(-\\mathrm{i} k \\Delta x)\n$$\n令 $\\theta = k \\Delta x$。则 $G_{\\mathrm{E}}(\\theta) = 1 - \\nu + \\nu e^{-\\mathrm{i}\\theta} = (1 - \\nu + \\nu\\cos\\theta) - \\mathrm{i}\\nu\\sin\\theta$。\n其模的平方为：\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = (1 - \\nu + \\nu\\cos\\theta)^2 + (\\nu\\sin\\theta)^2\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = (1-\\nu)^2 + 2\\nu(1-\\nu)\\cos\\theta + \\nu^2\\cos^2\\theta + \\nu^2\\sin^2\\theta\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = 1 - 2\\nu + \\nu^2 + 2\\nu(1-\\nu)\\cos\\theta + \\nu^2 = 1 - 2\\nu + 2\\nu^2 + 2\\nu(1-\\nu)\\cos\\theta\n$$\n$$\n|G_{\\mathrm{E}}(\\theta)|^2 = 1 - 2\\nu(1-\\nu) + 2\\nu(1-\\nu)\\cos\\theta = 1 - 2\\nu(1-\\nu)(1-\\cos\\theta)\n$$\n稳定性条件 $|G_{\\mathrm{E}}(\\theta)|^2 \\le 1$ 要求 $ -2\\nu(1-\\nu)(1-\\cos\\theta) \\le 0$。由于 $\\nu>0$ 且对所有 $\\theta$ 都有 $1-\\cos\\theta \\ge 0$，这简化为条件 $1-\\nu \\ge 0$，即 $\\nu \\le 1$。\n\n两个要求都导出了相同的条件。CFL 数的最紧上界是：\n$$\n\\nu_{\\max}^{\\mathrm{Euler}} = 1\n$$\n\n### 2. 三阶强稳定保持 Runge-Kutta (SSPRK(3))\n\n用于 $\\frac{d\\mathbf{u}}{dt} = L(\\mathbf{u})$ 的 SSPRK(3) 方法由以下三个阶段给出：\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t L(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} \\mathbf{u}^{(1)} + \\frac{1}{4} \\Delta t L(\\mathbf{u}^{(1)}) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} \\mathbf{u}^{(2)} + \\frac{2}{3} \\Delta t L(\\mathbf{u}^{(2)})\n\\end{aligned}\n$$\n该方法可以被解释为类前向 Euler 步的凸组合。令 $P_E(\\mathbf{u}) = \\mathbf{u} + \\Delta t L(\\mathbf{u})$ 为前向 Euler 算子。SSPRK(3) 格式可以写为：\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = P_E(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4} \\mathbf{u}^n + \\frac{1}{4} P_E(\\mathbf{u}^{(1)}) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3} \\mathbf{u}^n + \\frac{2}{3} P_E(\\mathbf{u}^{(2)})\n\\end{aligned}\n$$\n\n**要求2：凸组合**\nSSP 方法的关键特性是，如果前向 Euler 方法 $P_E$ 在 CFL 条件 $\\nu \\le \\nu_0$ 下是单调的，那么 SSPRK 方法在相关的 CFL 条件下也是单调的。对于给定的 SSPRK(3) 格式，已知如果前向 Euler 步是单调的，那么它也是单调的。如前一节所证，采用一阶迎风空间离散的前向 Euler 步，$u_j^{n+1} = (1-\\nu)u_j^n + \\nu u_{j-1}^n$，在 $0 \\le \\nu \\le 1$ 时是单调的。\nSSPRK(3) 格式是保持非负性和凸性的运算（正系数加法和 $P_E$ 的应用）的复合，前提是 $P_E$ 本身是一个单调算子。这要求 $\\nu \\le 1$。因此，单调性的最紧上界是 $\\nu \\le 1$。\n\n**要求1：Von Neumann 稳定性**\n为了推导 $G_{\\mathrm{SSPRK3}}(k)$，我们在 Fourier 空间中分析该方法。空间算子 $L$ 的放大因子是 $\\hat{L}(k)$。\n$$\nL(e^{\\mathrm{i} k j \\Delta x}) = -\\frac{a}{\\Delta x}(e^{\\mathrm{i} k j \\Delta x} - e^{\\mathrm{i} k (j-1) \\Delta x}) = \\left(-\\frac{a}{\\Delta x}(1 - e^{-\\mathrm{i} k \\Delta x})\\right) e^{\\mathrm{i} k j \\Delta x}\n$$\n令 $z = \\Delta t \\hat{L}(k) = -\\nu(1-e^{-\\mathrm{i} k \\Delta x})$。时间积分格式的放大因子是其稳定性多项式 $R(z)$。对于 SSPRK(3)，其为：\n$$\nG_{\\mathrm{SSPRK3}}(k) = R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3\n$$\n格式的稳定性要求 $|R(z)| \\le 1$ 对所有由 $z = -\\nu(1-e^{-\\mathrm{i}\\theta})$（其中 $\\theta=k\\Delta x$ 扫过 $[-\\pi, \\pi]$）描绘出的 $z$ 值成立。$z$ 在复平面上的轨迹是一个以 $(-\\nu, 0)$ 为中心、半径为 $\\nu$ 的圆。由 $|R(z)| \\le 1$ 定义的经典 RK3 方法的稳定区域，在实轴上包含区间 $[-2.51, 0]$。为了使 $z$ 的轨迹落在此区域内，其最左侧的点 $-2\\nu$ 必须在边界内。这得出 $-2\\nu \\gtrsim -2.51$，即 $\\nu \\lesssim 1.25$。\n\n**SSPRK(3) 的结论**\n单调性要求（凸组合）施加了条件 $\\nu \\le 1$。Von Neumann 稳定性要求 ($|G| \\le 1$) 施加了条件 $\\nu \\lesssim 1.25$。为了*同时*满足两个要求，我们必须取更严格的条件。\n因此，SSPRK(3) 格式的 CFL 数的最紧上界是：\n$$\n\\nu_{\\max}^{\\mathrm{SSPRK3}} = 1\n$$\n\n### 最终结果\n\n满足一阶迎风格式的两个单调性要求的 CFL 数 $\\nu$ 的最紧上界是 $\\nu_{\\max}^{\\mathrm{Euler}} = 1$ 和 $\\nu_{\\max}^{\\mathrm{SSPRK3}} = 1$。所要求的最终答案是数值对 $(\\nu_{\\max}^{\\mathrm{Euler}}, \\nu_{\\max}^{\\mathrm{SSPRK3}})$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了稳定性边界，但验证计算代码的正确行为同样重要。网格加密研究是计算流体力学中一种标准的验证技术，用于凭经验衡量数值格式的收敛阶数。在此练习中，您将实施一阶迎风格式来求解一个简单的平流问题，并通过一系列逐步加密的网格来量化误差，从而凭经验验证该格式的一阶收敛精度 。",
            "id": "3318421",
            "problem": "考虑由守恒律 $$\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$$ 控制的一维被动标量线性平流问题，其通量为 $$f(u) = a\\,u,$$ 其中 $$u(x,t)$$ 是一个光滑标量场，$$a$$ 是一个恒定的平流速度。在一个长度为 $$L$$ 的周期性域上的均匀网格上，目标是设计并实现一个网格加密研究，以经验性地验证应用于光滑余弦波输运的一阶迎风空间离散格式的一阶收敛性。推导和实现必须从守恒律和与信息传播方向一致的单调数值通量选择开始，并且不得假定任何快捷公式。该研究必须使用一阶显式时间积分器，并选择合适的时间步长以在不同的网格加密程度上保持 Courant–Friedrichs–Lewy (CFL) 数为常数。\n\n使用以下物理和数值上一致的设置：\n- 域长度 $$L = 1\\,\\mathrm{m}$$，采用周期性边界条件。\n- 平流速度 $$a \\in \\{1\\,\\mathrm{m/s}, -1\\,\\mathrm{m/s}\\}$$，由测试套件指定。\n- 初始条件 $$u(x,0) = \\cos\\left(2\\pi k\\, \\frac{x}{L}\\right),$$，波数 $$k = 1$$ (无量纲)。\n- 均匀网格，包含 $$N$$ 个单元，单元中心为 $$x_i = \\left(i + \\frac{1}{2}\\right)\\Delta x$$，其中 $$i \\in \\{0,1,\\dots,N-1\\}$$，且 $$\\Delta x = \\frac{L}{N}$$。\n- 最终物理时间 $$T = \\frac{L}{2\\,|a|}$$，单位为 $$\\mathrm{s}$$。\n- 时间步长 $$\\Delta t$$ 的选择应使每个测试用例和每次网格加密的 Courant–Friedrichs–Lewy (CFL) 数 $$\\nu = \\frac{|a|\\,\\Delta t}{\\Delta x}$$ 保持恒定；调整 $$\\Delta t$$，使得整数步数 $$n_{\\text{steps}}$$ 对每个网格都精确满足 $$n_{\\text{steps}}\\,\\Delta t = T$$。\n\n空间离散要求：\n- 在周期性网格上实现一个与 $$a$$ 的符号一致的一阶迎风空间离散格式。该离散格式必须从守恒律和单调数值通量推导得出，并且只能使用迎风方向上最近邻的信息。\n\n时间离散要求：\n- 对半离散系统使用一阶显式时间积分器。\n\n误差测量：\n- 在最终时间 $$T$$，将单元中心 $$x_i$$ 处的数值解 $$u_i^{n_{\\text{final}}}$$ 与精确解 $$u_{\\text{exact}}(x_i,T) = \\cos\\left(2\\pi k\\,\\frac{x_i - a\\,T}{L}\\right)$$ 进行比较，并计算以下离散误差范数：\n  1. 离散 $$L^1$$ 范数 $$\\|e\\|_{1} = \\sum_{i=0}^{N-1} |e_i|\\,\\Delta x,$$ 其中 $$e_i = u_i^{n_{\\text{final}}} - u_{\\text{exact}}(x_i,T).$$\n  2. 离散 $$L^2$$ 范数 $$\\|e\\|_{2} = \\left(\\sum_{i=0}^{N-1} e_i^2\\,\\Delta x\\right)^{1/2}.$$\n  3. 离散 $$L^{\\infty}$$ 范数 $$\\|e\\|_{\\infty} = \\max_{0 \\le i \\le N-1} |e_i|.$$\n\n观测到的收敛阶：\n- 对于每种范数，给定一个加密集 $$\\{N_j\\}$$ 以及相应的 $$\\Delta x_j$$ 和误差值 $$E_j$$，通过对 $$\\log(E_j)$$ 与 $$\\log(\\Delta x_j)$$ 进行线性最小二乘拟合来估计观测到的阶数 $$p$$。将 $$p$$ 以实数形式报告。\n\n测试套件规范：\n- 使用 $$k = 1$$，$$L = 1\\,\\mathrm{m}$$，以及加密集 $$N \\in \\{50, 100, 200, 400\\}$$。\n- 对 $$a$$ 和 CFL 使用以下三组参数：\n  1. 情况 A (理想情况，正速度，中等 CFL): $$a = 1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.5$$。\n  2. 情况 B (边界情况，负速度以测试迎风方向切换): $$a = -1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.5$$。\n  3. 情况 C (接近CFL=1的情况以探测稳定性边界): $$a = 1\\,\\mathrm{m/s}$$ 且 $$\\nu = 0.9$$。\n\n单位和输出：\n- 所有物理量必须使用 $$\\mathrm{m}$$ 作为长度单位，$$\\mathrm{s}$$ 作为时间单位。\n- 最终程序输出必须是单行文本，其中包含一个由方括号括起来的逗号分隔列表，列表内含九个不带单位的实数，按顺序分别代表情况 A、B 和 C 的 $$L^1$$、$$L^2$$ 和 $$L^{\\infty}$$ 范数的观测收敛阶 $$p$$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，顺序为 $$[p_{A,1}, p_{A,2}, p_{A,\\infty}, p_{B,1}, p_{B,2}, p_{B,\\infty}, p_{C,1}, p_{C,2}, p_{C,\\infty}]$$，其中每个 $$p$$ 都是一个浮点数。",
            "solution": "该问题要求进行网格加密研究，以验证一维线性平流方程的一阶迎风格式的一阶收敛性。推导和实现必须从第一性原理出发。\n\n我们从守恒形式的一维线性平流方程开始：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是一个标量场，通量由 $f(u) = a\\,u$ 给出，其中 $a$ 是一个恒定的平流速度。\n\n为了推导数值格式，我们采用有限体积法。我们将长度为 $L$ 的空间域划分为 $N$ 个均匀单元（或称控制体积）$C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, 1, \\dots, N-1$。每个单元的宽度为 $\\Delta x = L/N$，单元中心为 $x_i = (i + 1/2)\\Delta x$。将守恒律在一个单元 $C_i$ 上积分，得到：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial f(u)}{\\partial x} dx = 0\n$$\n我们将单元 $i$ 在时间 $t$ 的单元平均值 $u$ 定义为：\n$$\nu_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx\n$$\n假设 $\\Delta x$ 是常数，第一项变为 $\\Delta x \\frac{d u_i}{dt}$。根据微积分基本定理，第二项变为 $f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))$。现在，方程成为关于单元平均值 $u_i$ 的一个常微分方程 (ODE)：\n$$\n\\frac{d u_i}{dt} + \\frac{f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t))}{\\Delta x} = 0\n$$\n单元界面处通量的点值（例如 $f(u(x_{i+1/2},t))$）是未知的。我们用数值通量函数 $\\hat{f}$ 来替代它们，该函数依赖于界面左右两侧的状态。设 $\\hat{f}_{i+1/2}$ 为界面 $x_{i+1/2}$ 处的数值通量，它依赖于单元平均值 $u_i$ 和 $u_{i+1}$。守恒律的半离散形式为：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} (\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2})\n$$\n问题指定了一阶迎风空间离散格式。迎风通量是一种单调通量，它遵循由特征速度 $f'(u) = a$ 的符号决定的信息传播方向。\n左状态 $u_L$ 和右状态 $u_R$ 之间的一阶迎风数值通量为：\n$$\n\\hat{f}(u_L, u_R) =\n\\begin{cases}\nf(u_L) = a\\,u_L  \\text{if } a > 0 \\\\\nf(u_R) = a\\,u_R  \\text{if } a  0\n\\end{cases}\n$$\n这可以使用平流速度的正部 $a^+ = \\max(a, 0)$ 和负部 $a^- = \\min(a, 0)$ 紧凑地写为：\n$$\n\\hat{f}(u_L, u_R) = a^+ u_L + a^- u_R\n$$\n对于我们的网格，界面 $x_{i+1/2}$ 处的通量是 $\\hat{f}_{i+1/2} = \\hat{f}(u_i, u_{i+1}) = a^+ u_i + a^- u_{i+1}$，而在界面 $x_{i-1/2}$ 处的通量是 $\\hat{f}_{i-1/2} = \\hat{f}(u_{i-1}, u_i) = a^+ u_{i-1} + a^- u_i$。将这些代入半离散方程，得到：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x} \\left( (a^+ u_i + a^- u_{i+1}) - (a^+ u_{i-1} + a^- u_i) \\right) = -\\frac{1}{\\Delta x} \\left( a^+(u_i - u_{i-1}) + a^-(u_{i+1} - u_i) \\right)\n$$\n接下来，我们使用一阶显式（向前欧拉）方法进行时间离散。设 $u_i^n$ 为单元 $i$ 在时间步 $n$ 的数值解。时间导数近似为 $\\frac{du_i}{dt} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$。全离散格式为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = -\\frac{1}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a^+(u_i^n - u_{i-1}^n) + a^-(u_{i+1}^n - u_i^n) \\right)\n$$\n我们来分析 $a$ 的符号的两种情况：\n1. 如果 $a > 0$：$a^+ = a$ 且 $a^- = 0$。格式变为 $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n)$。\n2. 如果 $a  0$：$a^+ = 0$ 且 $a^- = a$。格式变为 $u_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n)$。\n\n引入 Courant–Friedrichs–Lewy (CFL) 数 $\\nu = \\frac{|a| \\Delta t}{\\Delta x}$，我们可以写出 $\\frac{\\Delta t}{\\Delta x} = \\frac{\\nu}{|a|}$。更新规则变为：\n1. 如果 $a > 0$：$u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_i^n - u_{i-1}^n) = u_i^n - \\nu(u_i^n - u_{i-1}^n) = (1-\\nu)u_i^n + \\nu u_{i-1}^n$。\n2. 如果 $a  0$：$u_i^{n+1} = u_i^n - \\frac{a}{|a|}\\nu(u_{i+1}^n - u_i^n) = u_i^n + \\nu(u_{i+1}^n - u_i^n) = (1-\\nu)u_i^n + \\nu u_{i+1}^n$。\n\n问题说明该域是周期性的。这意味着对于单元 $i=0$，其“迎风”邻居 $u_{-1}$ 是 $u_{N-1}$。对于单元 $i=N-1$，其“顺风”邻居 $u_N$ 是 $u_0$。\n\n网格加密研究按以下步骤进行。对于由 $a$ 和目标 CFL 数 $\\nu_{\\text{target}}$ 定义的每个测试用例，我们在一个网格序列 $N \\in \\{50, 100, 200, 400\\}$ 上求解该问题。对于每个网格 $N$：\n- 网格间距为 $\\Delta x = L/N$。\n- 最终时间为 $T = L/(2|a|)$。\n- 目标时间步长为 $\\Delta t_{\\text{target}} = \\nu_{\\text{target}} \\Delta x / |a|$。\n- 时间步数必须为整数 $n_{\\text{steps}}$，以确保精确达到最终时间 $T$。我们首先计算一个非整数步数 $n_{\\text{float}} = T/\\Delta t_{\\text{target}} = (L/(2|a|)) / (\\nu_{\\text{target}} \\Delta x / |a|) = N/(2\\nu_{\\text{target}})$。然后我们将其四舍五入到最近的整数：$n_{\\text{steps}} = \\text{round}(n_{\\text{float}})$。\n- 实际使用的时间步长为 $\\Delta t = T/n_{\\text{steps}}$。实际的 CFL 数为 $\\nu_{\\text{actual}} = |a|\\Delta t / \\Delta x$，它将接近于 $\\nu_{\\text{target}}$。\n- 应用初始条件：$u_i^0 = \\cos(2\\pi k x_i/L)$。\n- 将解推进 $n_{\\text{steps}}$ 个时间步以达到 $t=T$。\n- 在 $t=T$ 时，计算误差 $e_i = u_i^{n_{\\text{steps}}} - u_{\\text{exact}}(x_i, T)$，其中 $u_{\\text{exact}}(x,t) = \\cos(2\\pi k (x - at)/L)$。\n- 计算离散误差范数 $\\|e\\|_1$、$\\|e\\|_2$ 和 $\\|e\\|_{\\infty}$。\n\n在获得加密序列中每个网格间距 $\\Delta x_j$ 的误差 $E_j$ 后，我们估计收敛阶 $p$。假设误差关系为 $E_j = C (\\Delta x_j)^p$，取对数得到 $\\log(E_j) = p \\log(\\Delta x_j) + \\log(C)$。这是一种线性关系。我们对点集 $(\\log(\\Delta x_j), \\log(E_j))$ 进行线性最小二乘拟合，所得的斜率即为观测到的收敛阶 $p$。对每种范数和每个测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the grid refinement study for all test cases.\n    \"\"\"\n\n    # Test suite specification\n    test_cases = [\n        # Case A: a = 1.0 m/s, nu = 0.5\n        {'a': 1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case B: a = -1.0 m/s, nu = 0.5\n        {'a': -1.0, 'nu_target': 0.5, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n        # Case C: a = 1.0 m/s, nu = 0.9\n        {'a': 1.0, 'nu_target': 0.9, 'L': 1.0, 'k': 1, 'N_list': [50, 100, 200, 400]},\n    ]\n    \n    all_results = []\n    for params in test_cases:\n        p1, p2, p_inf = run_convergence_study(**params)\n        all_results.extend([p1, p2, p_inf])\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{r:.8f}' for r in all_results)}]\")\n\ndef run_convergence_study(a, nu_target, N_list, L, k):\n    \"\"\"\n    Performs a grid refinement study for a single test case.\n\n    Args:\n        a (float): Advection speed.\n        nu_target (float): Target CFL number.\n        N_list (list): List of grid resolutions.\n        L (float): Domain length.\n        k (int): Wavenumber of the initial condition.\n\n    Returns:\n        tuple: A tuple containing the observed orders of convergence (p1, p2, p_inf).\n    \"\"\"\n    \n    dx_values = []\n    errors_l1 = []\n    errors_l2 = []\n    errors_linf = []\n\n    for N in N_list:\n        # 1. Setup grid and time parameters\n        dx = L / N\n        dx_values.append(dx)\n        \n        # Cell centers\n        x = (np.arange(N) + 0.5) * dx\n        \n        # Time parameters\n        T_final = L / (2.0 * abs(a))\n        \n        # Adjust dt to hit T_final exactly with an integer number of steps\n        dt_target = nu_target * dx / abs(a)\n        n_steps_float = T_final / dt_target\n        n_steps = int(round(n_steps_float))\n        dt = T_final / n_steps\n        \n        # Calculate actual CFL number based on the adjusted dt\n        nu_actual = abs(a) * dt / dx\n\n        # 2. Initial Condition\n        u = np.cos(2.0 * np.pi * k * x / L)\n        \n        # 3. Time Marching Loop\n        for _ in range(n_steps):\n            if a > 0.0:\n                # Upwind is from the left (i-1)\n                # u_new = (1-nu)*u + nu*u_im1\n                u_im1 = np.roll(u, 1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_im1\n            else: # a  0.0\n                # Upwind is from the right (i+1)\n                # u_new = (1-nu)*u + nu*u_ip1\n                u_ip1 = np.roll(u, -1)\n                u = (1.0 - nu_actual) * u + nu_actual * u_ip1\n\n        # 4. Error Calculation\n        # Exact solution at T_final\n        u_exact = np.cos(2.0 * np.pi * k * (x - a * T_final) / L)\n\n        # Error vector\n        error = u - u_exact\n\n        # Calculate and store norms\n        errors_l1.append(np.sum(np.abs(error)) * dx)\n        errors_l2.append(np.sqrt(np.sum(error**2) * dx))\n        errors_linf.append(np.max(np.abs(error)))\n\n    # 5. Calculate Order of Convergence\n    # Use linear regression on log(error) vs log(dx)\n    # log(E) = p * log(dx) + C, so the slope is the order p.\n    \n    log_dx = np.log(dx_values)\n    \n    log_err_l1 = np.log(errors_l1)\n    p1 = linregress(log_dx, log_err_l1).slope\n    \n    log_err_l2 = np.log(errors_l2)\n    p2 = linregress(log_dx, log_err_l2).slope\n    \n    log_err_linf = np.log(errors_linf)\n    p_inf = linregress(log_dx, log_err_linf).slope\n\n    return p1, p2, p_inf\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "一阶迎风格式虽然稳定，但其精度有限，一个显著的缺点是其固有的数值耗散或“伪耗散”现象。当流动方向与计算网格轴线不一致时，这种效应在多维问题中尤为突出。本练习旨在通过一个二维平流问题来量化这种数值误差，在该问题中，您将测量一个高斯分布轮廓在沿流动方向和垂直于流动方向上的扩散情况，从而深入理解该格式的主要局限性 。",
            "id": "3318407",
            "problem": "考虑二维空间中的线性常系数平流方程，\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\boldsymbol{a} \\cdot \\nabla \\phi = 0,\n$$\n其中 $\\phi(x,y,t)$ 是一个被动标量，$\\boldsymbol{a} = (a_x,a_y)$ 是一个恒定的平流速度。计算域为无量纲单位的周期性单位正方形 $[0,1]\\times[0,1]$，使用包含 $N_x \\times N_y$ 个单元的均匀笛卡尔网格进行离散，单元尺寸分别为 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。\n\n从平流的守恒形式和迎风数值通量的定义出发，推导此网格上针对恒定 $\\boldsymbol{a}$ 的一阶迎风（施主单元）半离散空间离散格式。然后，选择时间步长为 $\\Delta t$ 的单步显式前向欧拉时间积分方法，该时间步长需满足合适的 Courant–Friedrichs–Lewy (CFL) 稳定性要求。该格式必须使用周期性边界条件。\n\n你将创建一个二维斜向风平流测试，以测量伪扩散，并报告相对于 $\\boldsymbol{a}$ 与网格轴夹角的方向平滑。使用以下数学上指定的设置：\n\n- 在时间 $t=0$ 时的初始条件是一个平滑、局域化的高斯凸起，中心位于 $(x_0,y_0)$，\n$$\n\\phi(x,y,0) = \\exp\\left( - \\frac{(x-x_0)^2 + (y-y_0)^2}{2\\sigma^2} \\right),\n$$\n其中 $x_0=0.25$, $y_0=0.25$, 且 $\\sigma=0.05$（均为无量纲单位）。\n\n- 速度为 $\\boldsymbol{a} = (\\cos\\theta,\\sin\\theta)$，其中 $\\theta$ 为指定角度（以弧度为单位）。速度大小 $\\|\\boldsymbol{a}\\|$ 为 $1$。\n\n- 取 $N_x = N_y = 256$，$\\Delta t = 0.2\\,\\Delta x$，并使用显式前向欧拉方法积分至最终时间 $T=0.1$。实际积分时间 $T_{\\text{actual}}$ 应为整数步数与 $\\Delta t$ 的乘积。所有边界均使用周期性边界条件。\n\n为量化伪扩散和方向平滑，计算 $\\phi$ 相对于其质量加权质心的二阶中心矩，并将其投影到平行于和垂直于 $\\boldsymbol{a}$ 的方向上：\n\n1. 计算质量 $M = \\int_{0}^{1}\\int_{0}^{1} \\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y$、质心 $(\\bar{x}(t),\\bar{y}(t))$ 以及协方差矩阵\n$$\n\\mathbf{C}(t) = \\frac{1}{M}\\int_{0}^{1}\\int_{0}^{1} \n\\begin{bmatrix}\nx-\\bar{x}(t)\\\\\ny-\\bar{y}(t)\n\\end{bmatrix}\n\\begin{bmatrix}\nx-\\bar{x}(t)  y-\\bar{y}(t)\n\\end{bmatrix}\n\\phi(x,y,t)\\,\\mathrm{d}x\\,\\mathrm{d}y.\n$$\n2. 设沿流向和垂直于流向的单位向量分别为 $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|$ 和 $\\hat{\\boldsymbol{n}} = (-\\hat{s}_y,\\hat{s}_x)$。定义沿这些方向的方差为 $v_s(t) = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{s}}$ 和 $v_n(t) = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}(t)\\,\\hat{\\boldsymbol{n}}$。\n3. 通过以下公式估算有效方向数值扩散系数\n$$\nD_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\nD_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}},\n$$\n并报告方向平滑比 $R = D_{\\text{eff},n}/D_{\\text{eff},s}$。\n\n所有量均为无量纲量，并应以与单位长度域和单位速度大小一致的无量纲单位报告。角度在输出中必须以度为单位指定。\n\n测试套件：\n对以下角度 $\\theta$（此处以度为单位提供，需在内部转换为弧度）进行评估：$0$, $5$, $22.5$, $45$, $67.5$, $90$。这些角度覆盖了轴对齐流、近轴斜向流和对角流。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是一个包含四个浮点数的列表：$[\\theta_{\\text{deg}}, D_{\\text{eff},s}, D_{\\text{eff},n}, R]$。\n例如，输出格式必须为\n$$\n[\\,[\\theta_1,D_{\\text{eff},s,1},D_{\\text{eff},n,1},R_1],\\,[\\theta_2,D_{\\text{eff},s,2},D_{\\text{eff},n,2},R_2],\\,\\dots\\,]\n$$\n其中符号由数值代替。不应打印任何额外文本。",
            "solution": "该问题是有效的。它提出了一个计算流体动力学中标准的、适定的初边值问题，提供了所有必要的参数和明确的分析目标。其底层的物理和数学是合理的，数值方法是经典的。\n\n### 一阶迎风半离散格式的推导\n\n我们从二维线性平流方程的守恒形式开始：\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\boldsymbol{a}\\phi) = 0\n$$\n其中 $\\boldsymbol{a}=(a_x, a_y)$ 是一个恒定的速度向量。我们将此方程在一个面积为 $\\Delta x \\Delta y$ 的计算单元 $\\Omega_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$ 上积分。应用散度定理，我们得到积分形式：\n$$\n\\frac{d}{dt} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy + \\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = 0\n$$\n设 $\\phi_{i,j}(t)$ 为标量的单元平均值，$\\phi_{i,j}(t) = \\frac{1}{\\Delta x \\Delta y} \\iint_{\\Omega_{i,j}} \\phi \\,dx\\,dy$。该积分的时间导数近似为 $\\Delta x \\Delta y \\frac{d\\phi_{i,j}}{dt}$。边界积分（通量项）是穿过单元四个面（东、西、南、北）的通量之和：\n$$\n\\oint_{\\partial\\Omega_{i,j}} (\\phi\\boldsymbol{a}) \\cdot \\hat{\\boldsymbol{n}} \\,ds = (F_e - F_w) + (F_n - F_s)\n$$\n其中通量定义在单元面上。例如，穿过东侧面 $x_{i+1/2}$ 的通量为 $F_e = \\int_{y_{j-1/2}}^{y_{j+1/2}} \\phi(x_{i+1/2}, y) a_x \\,dy$。我们将其近似为 $F_e \\approx (\\phi_{i+1/2,j} a_x) \\Delta y$，其中 $\\phi_{i+1/2,j}$ 是 $\\phi$ 在该面上的值。对其他面也做类似近似：$F_w \\approx (\\phi_{i-1/2,j} a_x) \\Delta y$，$F_n \\approx (\\phi_{i,j+1/2} a_y) \\Delta x$，以及 $F_s \\approx (\\phi_{i,j-1/2} a_y) \\Delta x$。\n\n一阶迎风格式（或称施主单元格式）将单元面上的值定义为来自“上游”或“施主”单元的值，即流的来源单元。\n对于面 $x_{i+1/2}$，值 $\\phi_{i+1/2,j}$ 由 $a_x$ 的符号决定：\n$$\n\\phi_{i+1/2,j} = \\begin{cases} \\phi_{i,j}  \\text{if } a_x > 0 \\\\ \\phi_{i+1,j}  \\text{if } a_x  0 \\end{cases}\n$$\n此逻辑应用于所有面。一种方便的表达方式是将速度分量分解为正部和负部：$a_x = a_x^+ + a_x^-$，其中 $a_x^+ = \\max(a_x, 0)$，$a_x^- = \\min(a_x, 0)$。x方向的净通量 $F_e - F_w$ 变为：\n$$\nF_e - F_w \\approx \\left[ (a_x^+ \\phi_{i,j} + a_x^- \\phi_{i+1,j}) - (a_x^+ \\phi_{i-1,j} + a_x^- \\phi_{i,j}) \\right] \\Delta y\n$$\ny方向的净通量也有类似的表达式。将这些代入离散化的守恒定律，并除以单元面积 $\\Delta x \\Delta y$，我们得到单元平均值 $\\phi_{i,j}$ 的半离散方程：\n$$\n\\frac{d\\phi_{i,j}}{dt} = - \\left[ \\frac{a_x^+(\\phi_{i,j} - \\phi_{i-1,j}) + a_x^-(\\phi_{i+1,j} - \\phi_{i,j})}{\\Delta x} + \\frac{a_y^+(\\phi_{i,j} - \\phi_{i,j-1}) + a_y^-(\\phi_{i,j+1} - \\phi_{i,j})}{\\Delta y} \\right]\n$$\n\n### 使用前向欧拉方法的全离散格式\n\n为获得全离散格式，我们使用一阶显式前向欧拉方法对时间导数进行离散：$\\frac{d\\phi_{i,j}}{dt} \\approx \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t}$，其中上标 $n$ 表示时间层 $t^n = n\\Delta t$。\n这得到了更新公式：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\frac{\\Delta t}{\\Delta x} \\left[ a_x^+(\\phi_{i,j}^n - \\phi_{i-1,j}^n) + a_x^-(\\phi_{i+1,j}^n - \\phi_{i,j}^n) \\right] - \\frac{\\Delta t}{\\Delta y} \\left[ a_y^+(\\phi_{i,j}^n - \\phi_{i,j-1}^n) + a_y^-(\\phi_{i,j+1}^n - \\phi_{i,j}^n) \\right]\n$$\n此格式在 Courant–Friedrichs–Lewy (CFL) 条件 $|a_x|\\frac{\\Delta t}{\\Delta x} + |a_y|\\frac{\\Delta t}{\\Delta y} \\le 1$ 下是稳定的。问题指定 $\\Delta x = \\Delta y = 1/256$，$\\Delta t = 0.2 \\Delta x$，且 $\\|\\boldsymbol{a}\\|=1$。库朗数之和为 $C_x+C_y = \\frac{\\Delta t}{\\Delta x}(|a_x| + |a_y|) = 0.2(|\\cos\\theta| + |\\sin\\theta|)$。$|\\cos\\theta| + |\\sin\\theta|$ 的最大值是 $\\sqrt{2}$，因此最大CFL数为 $0.2\\sqrt{2} \\approx 0.283  1$，确保了稳定性。\n\n### 数值扩散分析\n\n该分析通过测量标量场的空间方差变化来量化格式中固有的数值扩散。所需的量是从网格上的离散解 $\\phi_{i,j}$ 中数值计算得出的。我们使用单元中心坐标 $x_i = (i+0.5)\\Delta x$ 和 $y_j = (j+0.5)\\Delta y$。\n\n1.  **质量和质心**：积分通过对所有单元求和来近似。总质量为 $M \\approx \\sum_{i,j} \\phi_{i,j} \\Delta x \\Delta y$。质心分量为 $\\bar{x} \\approx \\frac{1}{M} \\sum_{i,j} x_i \\phi_{i,j} \\Delta x \\Delta y$ 和 $\\bar{y} \\approx \\frac{1}{M} \\sum_{i,j} y_j \\phi_{i,j} \\Delta x \\Delta y$。由于传播距离相对于域大小较小，因此质心计算无需周期性校正。\n\n2.  **协方差矩阵**：协方差矩阵 $\\mathbf{C}$ 的分量也通过求和计算：\n    $$\n    C_{xx} \\approx \\frac{1}{M} \\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j} \\Delta x \\Delta y = \\frac{\\sum_{i,j} (x_i - \\bar{x})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{yy} \\approx \\frac{\\sum_{i,j} (y_j - \\bar{y})^2 \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}} \\\\\n    C_{xy} \\approx \\frac{\\sum_{i,j} (x_i - \\bar{x})(y_j - \\bar{y}) \\phi_{i,j}}{\\sum_{i,j} \\phi_{i,j}}\n    $$\n\n3.  **方向方差**：计算出 $\\mathbf{C}$ 后，通过投影找到平行于（$v_s$）和垂直于（$v_n$）流向 $\\hat{\\boldsymbol{s}} = \\boldsymbol{a}/\\|\\boldsymbol{a}\\|=(\\cos\\theta, \\sin\\theta)$ 的方差：\n    $$\n    v_s = \\hat{\\boldsymbol{s}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{s}} = C_{xx} \\cos^2\\theta + C_{yy} \\sin^2\\theta + 2 C_{xy} \\sin\\theta \\cos\\theta \\\\\n    v_n = \\hat{\\boldsymbol{n}}^\\top \\mathbf{C}\\,\\hat{\\boldsymbol{n}} = C_{xx} \\sin^2\\theta + C_{yy} \\cos^2\\theta - 2 C_{xy} \\sin\\theta \\cos\\theta\n    $$\n    其中 $\\hat{\\boldsymbol{n}} = (-\\sin\\theta, \\cos\\theta)$。\n\n4.  **有效扩散**：通过观察这些方差在模拟时间 $T_{\\text{actual}}$ 内的增长来估算有效数值扩散系数：\n    $$\n    D_{\\text{eff},s} = \\frac{v_s(T_{\\text{actual}}) - v_s(0)}{2\\,T_{\\text{actual}}}, \\quad\n    D_{\\text{eff},n} = \\frac{v_n(T_{\\text{actual}}) - v_n(0)}{2\\,T_{\\text{actual}}}\n    $$\n    这些系数是为初始状态（$t=0$）和最终状态（$t=T_{\\text{actual}}$）计算的。为保持一致性，初始方差 $v_s(0)$ 和 $v_n(0)$ 是从离散化的初始条件计算的，而不是从理想高斯分布的解析公式计算，以便仅分离出由数值格式本身引起的变化。比率 $R = D_{\\text{eff},n}/D_{\\text{eff},s}$ 量化了数值误差的各向异性，当其作用于垂直于流向时，通常被称为“伪扩散”。\n\n### 计算实现\n\n对每个指定的角度 $\\theta$ 进行模拟。对于每种情况，都会生成网格和初始高斯剖面。求解器的核心是一个时间循环，它迭代地应用全离散的迎风公式。周期性边界条件通过数组移位操作（例如，`numpy.roll`）得到高效处理。在最后一个时间步之后，调用分析程序对初始和最终标量场进行处理，以计算方差、有效扩散系数及其比率。然后整理结果并按指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D advection equation using a first-order upwind scheme\n    and analyzes the numerical diffusion for various flow angles.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        5.0,\n        22.5,\n        45.0,\n        67.5,\n        90.0,\n    ]\n\n    # Simulation parameters\n    Nx = 256\n    Ny = 256\n    x0 = 0.25\n    y0 = 0.25\n    sigma = 0.05\n    domain_size = 1.0\n    T_final = 0.1\n\n    dx = domain_size / Nx\n    dy = domain_size / Ny\n    dt = 0.2 * dx\n    \n    # Create grid\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x_coords, y_coords)\n\n    def calculate_analysis(phi, X_grid, Y_grid, s_hat, n_hat):\n        \"\"\"\n        Calculates mass, centroid, covariance matrix, and directional variances.\n        \"\"\"\n        # Mass calculation (dx*dy cancels out in ratios, so can be omitted)\n        mass = np.sum(phi)\n        if mass == 0:\n            return 0, 0, 0 # Should not happen with a Gaussian\n\n        # Centroid calculation\n        # The bump does not wrap around, so simple weighted average is fine.\n        x_bar = np.sum(X_grid * phi) / mass\n        y_bar = np.sum(Y_grid * phi) / mass\n\n        # Distances from centroid\n        dx_bar = X_grid - x_bar\n        dy_bar = Y_grid - y_bar\n        \n        # Covariance matrix components\n        C_xx = np.sum(dx_bar**2 * phi) / mass\n        C_yy = np.sum(dy_bar**2 * phi) / mass\n        C_xy = np.sum(dx_bar * dy_bar * phi) / mass\n\n        # Directional variances\n        s_x, s_y = s_hat\n        n_x, n_y = n_hat\n\n        v_s = C_xx * s_x**2 + C_yy * s_y**2 + 2 * C_xy * s_x * s_y\n        v_n = C_xx * n_x**2 + C_yy * n_y**2 + 2 * C_xy * n_x * n_y\n        \n        return v_s, v_n\n\n    results = []\n    \n    for theta_deg in test_cases:\n        theta_rad = np.radians(theta_deg)\n        \n        # Velocity vector and its positive/negative parts\n        ax = np.cos(theta_rad)\n        ay = np.sin(theta_rad)\n        ax_pos = max(ax, 0)\n        ax_neg = min(ax, 0)\n        ay_pos = max(ay, 0)\n        ay_neg = min(ay, 0)\n\n        # Projection vectors\n        s_hat = np.array([ax, ay])\n        n_hat = np.array([-ay, ax])\n        \n        # Initial condition\n        phi0 = np.exp(-((X - x0)**2 + (Y - y0)**2) / (2 * sigma**2))\n\n        # Analysis of initial condition\n        v_s0, v_n0 = calculate_analysis(phi0, X, Y, s_hat, n_hat)\n\n        # Time stepping\n        phi = phi0.copy()\n        num_steps = int(np.floor(T_final / dt))\n        T_actual = num_steps * dt\n\n        for _ in range(num_steps):\n            # Periodic BCs using numpy.roll\n            phi_im1 = np.roll(phi, 1, axis=1) # phi at i-1\n            phi_ip1 = np.roll(phi, -1, axis=1) # phi at i+1\n            phi_jm1 = np.roll(phi, 1, axis=0) # phi at j-1\n            phi_jp1 = np.roll(phi, -1, axis=0) # phi at j+1\n            \n            # Spatial derivative term (upwind)\n            dphi_dx_term = (ax_pos * (phi - phi_im1) + ax_neg * (phi_ip1 - phi)) / dx\n            dphi_dy_term = (ay_pos * (phi - phi_jm1) + ay_neg * (phi_jp1 - phi)) / dy\n\n            # Forward Euler update\n            phi -= dt * (dphi_dx_term + dphi_dy_term)\n\n        # Analysis of final condition\n        v_sT, v_nT = calculate_analysis(phi, X, Y, s_hat, n_hat)\n        \n        # Effective diffusion coefficients\n        if T_actual > 0:\n            D_eff_s = (v_sT - v_s0) / (2 * T_actual)\n            D_eff_n = (v_nT - v_n0) / (2 * T_actual)\n        else:\n            D_eff_s = 0.0\n            D_eff_n = 0.0\n\n        # Smoothing ratio\n        # Avoid division by zero, although D_eff_s should be positive.\n        if D_eff_s != 0:\n            R = D_eff_n / D_eff_s\n        else:\n            # If stream-wise diffusion is zero, but cross-stream is not, ratio is infinite.\n            # If both are zero, ratio is undefined, we can set it to 0 or 1. \n            # In this problem, D_eff_s > 0 is expected for T>0.\n            R = np.inf if D_eff_n != 0 else 0.0\n            \n        results.append([theta_deg, D_eff_s, D_eff_n, R])\n\n    # Final print statement in the exact required format.\n    case_strings = [f\"[{c[0]},{c[1]},{c[2]},{c[3]}]\" for c in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}