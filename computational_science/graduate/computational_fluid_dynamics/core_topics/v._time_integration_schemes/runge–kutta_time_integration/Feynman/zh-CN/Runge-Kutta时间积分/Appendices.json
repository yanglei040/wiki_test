{
    "hands_on_practices": [
        {
            "introduction": "在计算流体力学中，一个关键步骤是理解空间离散格式与时间积分方法的相互作用如何影响数值稳定性。本练习将指导您对一个经典的对流-扩散方程进行冯·诺依曼稳定性分析。通过这个过程，您将学习如何将物理参数（如对流速度和粘性系数）和网格参数与显式龙格-库塔方法的最大稳定时间步长联系起来，这是任何CFD实践者都必须掌握的基础技能。",
            "id": "3359928",
            "problem": "考虑计算流体动力学 (CFD) 中的一维线性平流-扩散偏微分方程 (PDE)\n$$\nu_{t}(x,t) + a\\,u_{x}(x,t) = \\nu\\,u_{xx}(x,t),\n$$\n其中平流速度 $a>0$ 和运动粘度 $\\nu>0$ 为常数，定义在周期性域 $x \\in [0,L]$ 上。在均匀网格 $x_{j} = j h$（其中 $j=0,1,\\ldots,N-1$，网格间距 $h = L/N$）上对空间进行离散化，并用 $y_{j}(t) \\equiv u(x_{j},t)$ 表示节点解。对 $u_{x}$ 和 $u_{xx}$ 使用二阶中心有限差分，并施加周期性边界条件。\n\n1. 推导矩阵形式的半离散常微分方程 (ODE) 组 $y'(t) = A\\,y(t)$，并明确指出贡献于平流和扩散的离散算子。\n\n2. 证明由于周期性和均匀间距，离散傅里叶模态\n$$\n\\phi_{j}(\\theta) = \\exp(i j \\theta), \\quad \\theta \\in [-\\pi,\\pi],\n$$\n是矩阵 $A$ 的特征向量，并推导相应的特征值 $\\lambda(\\theta)$ 作为 $\\theta$ 的函数，强调平流和扩散分别对 $\\lambda(\\theta)$ 的实部和虚部的贡献。\n\n3. 考虑使用经典的显式四阶龙格-库塔 (RK) 方法进行时间积分。当应用于标量测试方程 $y'=\\lambda y$ 时，设单步放大因子为 $R(z)$。确定最大稳定时间步长 $\\Delta t_{\\max}$，使得\n$$\n\\max_{\\theta \\in [-\\pi,\\pi]} \\left| R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right) \\right| \\leq 1.\n$$\n使用以下物理和数值参数：$L = 1$ (米)，$N = 128$，$a = 0.2$ (米/秒)，以及 $\\nu = 10^{-3}$ (平方米/秒)。\n\n将您的 $\\Delta t_{\\max}$ 最终答案四舍五入至四位有效数字，并以秒为单位表示。",
            "solution": "根据指定标准，用户提供的问题被评估为有效。它在计算流体动力学方面有科学依据，问题提法恰当，客观，并包含完整解答所需的所有信息。\n\n### 第1部分：半离散ODE系统的推导\n\n给定的一维线性平流-扩散方程为：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n我们使用均匀网格对空间域 $x \\in [0,L]$ 进行离散化，网格点为 $x_j = j h$，其中 $j=0, 1, \\ldots, N-1$，网格间距为 $h=L/N$。这些网格点上的解表示为 $y_j(t) = u(x_j, t)$。通过用有限差分近似替换空间导数，可以得到PDE的半离散形式。\n\n对于一阶空间导数，二阶中心差分为：\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_{x_j} \\approx \\frac{u(x_{j+1}, t) - u(x_{j-1}, t)}{2h} = \\frac{y_{j+1}(t) - y_{j-1}(t)}{2h}\n$$\n对于二阶空间导数，二阶中心差分为：\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_j} \\approx \\frac{u(x_{j+1}, t) - 2u(x_j, t) + u(x_{j-1}, t)}{h^2} = \\frac{y_{j+1}(t) - 2y_j(t) + y_{j-1}(t)}{h^2}\n$$\n由于是周期性域，索引以 $N$ 为模，即 $y_{j+N} = y_j$。例如，$y_{-1} = y_{N-1}$ 且 $y_N = y_0$。\n\n将这些近似值代入PDE，得到一个常微分方程 (ODE) 组，每个网格点 $j$ 对应一个方程：\n$$\n\\frac{d y_j}{d t} = -a \\left( \\frac{y_{j+1} - y_{j-1}}{2h} \\right) + \\nu \\left( \\frac{y_{j+1} - 2y_j + y_{j-1}}{h^2} \\right)\n$$\n设 $y(t) = [y_0(t), y_1(t), \\ldots, y_{N-1}(t)]^T$ 为解向量。该系统可以写成矩阵形式 $y'(t) = A y(t)$。我们可以识别出平流和扩散的贡献。令 $A = A_{adv} + A_{diff}$。\n\n平流算子 $A_{adv}$ 对应于项 $-a u_x$：\n$$\n(A_{adv} y)_j = -\\frac{a}{2h} (y_{j+1} - y_{j-1})\n$$\n扩散算子 $A_{diff}$ 对应于项 $\\nu u_{xx}$：\n$$\n(A_{diff} y)_j = \\frac{\\nu}{h^2} (y_{j+1} - 2y_j + y_{j-1})\n$$\n组合算子 $A = A_{adv} + A_{diff}$ 作用于 $y_j$ 的形式为：\n$$\n(A y)_j = \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) y_{j+1} - \\frac{2\\nu}{h^2} y_j + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) y_{j-1}\n$$\n由于周期性边界条件，矩阵 $A$ 是一个 $N \\times N$ 的循环矩阵。\n\n### 第2部分：特征值分析\n\n我们检验离散傅里叶模态 $\\phi_j(\\theta) = \\exp(ij\\theta)$ 是否为矩阵 $A$ 的特征向量。设向量 $\\phi(\\theta)$ 的分量为 $[\\phi_j(\\theta)]_j = \\exp(ij\\theta)$。我们将算子 $A$ 应用于此向量。结果的第 $j$ 个分量为：\n$$\n(A \\phi(\\theta))_j = \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) \\exp(i(j+1)\\theta) - \\frac{2\\nu}{h^2} \\exp(ij\\theta) + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) \\exp(i(j-1)\\theta)\n$$\n提出因子 $\\exp(ij\\theta)$：\n$$\n(A \\phi(\\theta))_j = \\exp(ij\\theta) \\left[ \\left(\\frac{\\nu}{h^2} - \\frac{a}{2h}\\right) \\exp(i\\theta) - \\frac{2\\nu}{h^2} + \\left(\\frac{\\nu}{h^2} + \\frac{a}{2h}\\right) \\exp(-i\\theta) \\right]\n$$\n这表明 $(A \\phi(\\theta))_j = \\lambda(\\theta) \\phi_j(\\theta)$，从而证实 $\\phi(\\theta)$ 是 $A$ 的一个特征向量。相应的特征值 $\\lambda(\\theta)$ 是方括号中的表达式：\n$$\n\\lambda(\\theta) = \\frac{\\nu}{h^2} (\\exp(i\\theta) - 2 + \\exp(-i\\theta)) - \\frac{a}{2h} (\\exp(i\\theta) - \\exp(-i\\theta))\n$$\n使用欧拉恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$ 和 $\\exp(i\\theta) - \\exp(-i\\theta) = 2i\\sin(\\theta)$，我们可以简化 $\\lambda(\\theta)$：\n$$\n\\lambda(\\theta) = \\frac{\\nu}{h^2} (2\\cos(\\theta) - 2) - \\frac{a}{2h} (2i\\sin(\\theta))\n$$\n$$\n\\lambda(\\theta) = \\frac{2\\nu}{h^2}(\\cos(\\theta) - 1) - i\\frac{a}{h}\\sin(\\theta)\n$$\n该表达式将特征值分离为其虚部和实部。\n特征值的实部来源于扩散项：\n$$\n\\text{Re}(\\lambda(\\theta)) = \\frac{2\\nu}{h^2}(\\cos(\\theta) - 1)\n$$\n因为 $\\nu > 0$ 且 $\\cos(\\theta) - 1 \\le 0$，所以实部总为非正值，这反映了扩散算子的耗散性质。\n\n特征值的虚部来源于平流项：\n$$\n\\text{Im}(\\lambda(\\theta)) = -\\frac{a}{h}\\sin(\\theta)\n$$\n这是对平流算子使用中心差分近似所产生的色散性质的特征。\n\n### 第3部分：最大稳定时间步长\n\n经典的四阶龙格-库塔 (RK4) 方法，当应用于标量测试方程 $y'=\\lambda y$ 时，其放大因子由指数函数的泰勒级数展开式截断至四阶项给出：\n$$\nR(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\n其中 $z = \\Delta t \\lambda$。为保证数值稳定性，对于系统的所有特征值，放大因子的模必须不大于1。这给出了条件：\n$$\n\\max_{\\theta \\in [-\\pi,\\pi]} |R(\\Delta t \\lambda(\\theta))| \\le 1\n$$\n这意味着对于所有的 $\\theta$，复数 $z(\\theta) = \\Delta t \\lambda(\\theta)$ 必须位于 RK4 方法的稳定区域内。稳定区域是集合 $S = \\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$。\n\n对于 $\\theta \\in [-\\pi, \\pi]$，特征值 $\\lambda(\\theta)$ 的轨迹在复平面上形成一个椭圆，中心位于 $(-\\frac{2\\nu}{h^2}, 0)$，半轴分别为 $\\frac{2\\nu}{h^2}$ (实轴) 和 $\\frac{a}{h}$ (虚轴)。$z(\\theta)$ 的轨迹是该椭圆的一个缩放版本。\n\nRK4 方法的稳定区域与负实轴的交集约为 $[-2.785, 0]$，与虚轴的交集约为 $[-2.828i, 2.828i]$ (更精确地，是 $[-2\\sqrt{2}i, 2\\sqrt{2}i]$)。稳定区域沿负实轴在原点附近被“挤压”。特征值椭圆 $\\lambda(\\theta)$ 在 $\\theta=0$ 处总是与原点相切。随着 $\\Delta t$ 的增加，缩放后的椭圆 $z(\\theta)$ 会扩张。该椭圆上第一个离开稳定区域的点将是其最左侧的点，该点位于负实轴上。此点对应于傅里叶模态 $\\theta = \\pi$。\n\n在 $\\theta = \\pi$ 处，特征值为纯实数：\n$$\n\\lambda(\\pi) = \\frac{2\\nu}{h^2}(\\cos(\\pi) - 1) - i\\frac{a}{h}\\sin(\\pi) = \\frac{2\\nu}{h^2}(-1 - 1) - 0 = -\\frac{4\\nu}{h^2}\n$$\n这是模最大的特征值。此模态的稳定性条件是：\n$$\n|\\Delta t \\lambda(\\pi)| \\le S_R\n$$\n其中 $S_R \\approx 2.78529$ 是 RK4 在负实轴上的稳定区间长度。该值是 $|R(-x)|=1$ 的正根，具体来说是 $R(-x) = -1$ 的根。\n$$\n\\Delta t \\frac{4\\nu}{h^2} \\le S_R\n$$\n因此，最大稳定时间步长为：\n$$\n\\Delta t_{\\max} = \\frac{S_R h^2}{4\\nu}\n$$\n现在，我们代入给定的数值参数：\n$L = 1$, $N = 128$，所以网格间距为 $h = L/N = 1/128$。\n$\\nu = 10^{-3}$。\n$S_R \\approx 2.78529$。\n$$\n\\Delta t_{\\max} = \\frac{2.78529 \\times (1/128)^2}{4 \\times 10^{-3}} = \\frac{2.78529}{16384 \\times 4 \\times 10^{-3}} = \\frac{2.78529}{65.536}\n$$\n$$\n\\Delta t_{\\max} \\approx 0.04250333...\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta t_{\\max} = 0.04250$。",
            "answer": "$$\n\\boxed{0.04250}\n$$"
        },
        {
            "introduction": "虽然高阶方法因其精度而备受青睐，但它们有时会在解中引入非物理的振荡（新的极小值或极大值），这在许多物理模拟中是不可接受的（例如，浓度或密度不能为负）。本编码练习将通过一个具体反例，展示经典的四阶龙格-库塔方法存在的这一陷阱。通过将其与强稳定性保持（SSP）方法进行对比，您将深刻理解为何对于特定类型的问题，尤其是在处理激波或陡峭梯度时，SSP特性至关重要。",
            "id": "3359952",
            "problem": "考虑计算流体动力学中常用于模拟扩散的标量线性抛物守恒律，其偏微分方程为 $u_t = \\kappa u_{xx}$，其中 $u(t,x)$ 是一个标量场，$t$ 是时间（单位：秒），$x$ 是空间（单位：米），$\\kappa$ 是扩散系数（单位：$\\mathrm{m}^2/\\mathrm{s}$）。在间距为 $\\Delta x$ 的均匀网格上，并采用 Dirichlet 边界条件的一种标准空间半离散化方法，使用拉普拉斯算子的二阶中心差分近似。令 $u_i(t)$ 表示网格点 $x_i$ 处 $u(t,x)$ 的近似值，并按分量定义半离散算子 $L(u)$ 如下：\n$$\nL(u)_i = \\frac{\\kappa}{\\Delta x^2}\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n$$\n对所有内部索引 $i$ 均成立，而边界索引在所有时间上都固定为 $u_0(t)=0$ 和 $u_{N-1}(t)=0$（即定义域端点处的 Dirichlet 边界条件）。已知显式 Forward Euler 方法 $u^{n+1} = u^n + \\Delta t\\, L(u^n)$ 在时间步长 $\\Delta t$ 足够小的情况下是单调的，即能保持 $u$ 的最小和最大值界限，具体来说，当无量纲参数 $\\mu = \\kappa \\Delta t / \\Delta x^2$ 满足 $\\mu \\leq 1/2$ 时成立。与此相反，非强稳定性保持（Strong Stability Preserving, SSP）的高阶 Runge–Kutta 方法，例如经典的四阶 Runge–Kutta 方法，即使空间离散是单调的，并且 $\\Delta t$ 处于 Forward Euler 方法的单调性限制范围内，也可能无法保持此类界限。\n\n您的任务是构造一个显式反例，以证明在单调的空间离散上使用非 SSP Runge–Kutta 时间积分器时，界限保持会失效。请使用上述半离散扩散算子 $L(u)$，并为大小为 $\\Delta t$ 的单个时间步实现三个时间积分器：Forward Euler、经典的四阶 Runge–Kutta 和三阶 SSP Runge–Kutta（Shu–Osher 形式）。从一个非负且以 1 为界的初始条件开始，该初始条件为网格中心的一个单位脉冲：\n$$\nu_i^0 = \\begin{cases}\n1  \\text{if } i = \\lfloor (N-1)/2 \\rfloor, \\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n定义域端点对所有 $n$ 满足 Dirichlet 边界条件 $u_0^n = 0$ 和 $u_{N-1}^n = 0$。\n\n您必须编写一个程序，该程序针对每个指定的测试用例，使用指定的积分器执行恰好一个时间步，然后检查更新后解 $u^{1}$ 的任一分量是否位于初始数据 $ [ \\min_i u^0_i, \\max_i u^0_i ] = [0,1] $ 的凸包之外。也就是说，检测是否存在任何索引 $i$ 使得 $u^{1}_i < 0$ 或 $u^{1}_i > 1$。如果发生此类违规，则表明时间积分器与空间离散的耦合产生了一个“新极值”，该测试用例的布尔答案应为 $true$。否则，布尔答案应为 $false$。\n\n使用以下测试套件，该套件通过改变方法和时间步来说明这一现象：\n\n- 测试用例 1：Forward Euler， $N = 51$，$\\Delta x = 1\\,\\mathrm{m}$，$\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 0.5\\,\\mathrm{s}$（因此 $\\mu = 0.5$）。报告是否生成了新极值。\n- 测试用例 2：经典的四阶 Runge–Kutta（非 SSP）， $N = 51$，$\\Delta x = 1\\,\\mathrm{m}$，$\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 0.5\\,\\mathrm{s}$（因此 $\\mu = 0.5$）。报告是否生成了新极值。\n- 测试用例 3：三阶强稳定性保持 Runge–Kutta（Shu–Osher 形式），$N = 51$，$\\Delta x = 1\\,\\mathrm{m}$，$\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 0.5\\,\\mathrm{s}$（因此 $\\mu = 0.5$）。报告是否生成了新极值。\n- 测试用例 4：经典的四阶 Runge–Kutta（非 SSP），$N = 51$，$\\Delta x = 1\\,\\mathrm{m}$，$\\kappa = 1\\,\\mathrm{m}^2/\\mathrm{s}$，$\\Delta t = 0.05\\,\\mathrm{s}$（因此 $\\mu = 0.05$）。报告是否生成了新极值。\n\n所有角度（如果出现）必须以弧度表示。所有物理量必须使用指定的单位处理。您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的布尔值列表，例如 $[true,false,true,false]$。\n\n用于推理的基础理论如下：\n\n- 当 $\\mu \\leq 1/2$ 时，半离散中心差分拉普拉斯算子是一种在 Forward Euler 方法下单调的 $M$-矩阵空间离散。\n- 经典的四阶 Runge–Kutta 方法不是强稳定性保持的，这意味着它不允许存在一个非零系数 $C$ 使其能表示为 Forward Euler 步长的凸组合，因此该方法不必继承 Forward Euler 方法的界限保持性质。\n- 三阶强稳定性保持 Runge–Kutta 方法被设计用于在相同的 Forward Euler 时间步长限制下保持单调性。\n\n您的实现必须遵循这些原则来构造反例，并以所描述的精确输出格式返回测试套件的布尔值。",
            "solution": "该问题要求构造一个数值反例，以证明一种非强稳定性保持（SSP）的时间积分方法，特别是经典的四阶 Runge–Kutta（RK4）方法，即使与单调的空间离散耦合，并使用在较简单的 Forward Euler 方法的单调性限制内的时间步，也可能无法保持解的界限（即产生新极值）。我们将把这种行为与 Forward Euler 方法本身以及三阶 SSP Runge–Kutta 方法进行比较，在给定条件下，后两者预期会保持解的界限。\n\n控制偏微分方程是标量线性扩散方程：\n$$\nu_t = \\kappa u_{xx}\n$$\n其中 $u(t,x)$ 是标量场，$t$ 是时间，$x$ 是空间坐标，$\\kappa$ 是扩散系数。\n\n空间域在具有 $N$ 个点和网格间距 $\\Delta x$ 的均匀网格上进行离散化。方程的半离散形式为 $\\frac{du}{dt} = L(u)$，其中 $u(t)$ 是表示网格点上解 $u_i(t)$ 的向量，$L$ 是空间算子。问题指定了拉普拉斯算子的二阶中心差分近似，它为内部网格点 $i=1, \\dots, N-2$ 定义了算子 $L(u)$：\n$$\nL(u)_i = \\frac{\\kappa}{\\Delta x^2}\\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n$$\n边界条件为 Dirichlet 类型，在所有时间上 $u_0(t) = 0$ 且 $u_{N-1}(t) = 0$。\n\n初始条件是网格中心的一个单位脉冲，对于有 $N$ 个点的网格，该中心位于索引 $i_c = \\lfloor (N-1)/2 \\rfloor$ 处：\n$$\nu_i^0 = \\begin{cases}\n1  \\text{if } i = i_c, \\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n这个初始条件是非负的，其值被界定在凸包 $[0, 1]$ 内。如果经过一个时间步后的解 $u^1$ 仍保持在此凸包内，即对所有 $i$ 都有 $0 \\leq u_i^1 \\leq 1$，则称该方法是保界的。\n\n我们将实现并测试三种用于执行大小为 $\\Delta t$ 的单个时间步的显式时间积分格式：\n\n1.  **Forward Euler (FE)**：这是最简单的显式方法，由下式给出：\n    $$\n    u^{n+1} = u^n + \\Delta t L(u^n)\n    $$\n    对于给定的空间离散，已知如果时间步 $\\Delta t$ 满足条件 $$ \\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2} \\leq \\frac{1}{2} $$，则该方法是单调的，因此是保界的。\n\n2.  **经典的四阶 Runge–Kutta (RK4)**：这是一种高阶方法，由以下几个阶段定义：\n    $$\n    \\begin{aligned}\n    k_1 = L(u^n) \\\\\n    k_2 = L(u^n + \\frac{\\Delta t}{2} k_1) \\\\\n    k_3 = L(u^n + \\frac{\\Delta t}{2} k_2) \\\\\n    k_4 = L(u^n + \\Delta t k_3) \\\\\n    u^{n+1} = u^n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{aligned}\n    $$\n    该方法不是强稳定性保持的。它不能被写成 Forward Euler 步长的凸组合。因此，即使 Forward Euler 步长是保界的（即 $\\mu \\leq 1/2$），RK4 方法也不保证是保界的，并且可能产生新的极值（下冲或过冲）。\n\n3.  **三阶强稳定性保持 Runge–Kutta (SSP-RK3)**：此方法专门设计用于保持单调性。其 Shu–Osher 形式由下式给出：\n    $$\n    \\begin{aligned}\n    u^{(1)} = u^n + \\Delta t L(u^n) \\\\\n    u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} \\left(u^{(1)} + \\Delta t L(u^{(1)})\\right) \\\\\n    u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} \\left(u^{(2)} + \\Delta t L(u^{(2)})\\right)\n    \\end{aligned}\n    $$\n    此方法的每个阶段都是先前阶段和 Forward Euler 步长的凸组合。这种结构确保了，如果在给定的时间步长限制下 Forward Euler 步长是保界的，那么整个 SSP-RK3 方法在相同的限制下也是保界的。\n\n实现过程将首先把空间算子 $L$ 定义为一个作用于代表解向量 $u$ 的 NumPy 数组的函数。对于每个测试用例，我们将初始化解向量 $u^0$，应用指定积分器的一个步长以获得 $u^1$，然后检查 $u^1$ 的任一分量是否位于初始范围 $[0, 1]$ 之外。\n\n**测试用例分析**：\n- **测试用例 1**：使用 $\\mu = 0.5$ 的 Forward Euler 方法。这处于单调性条件的极限。该方法应该是保界的。我们预期结果为 `false`。\n- **测试用例 2**：使用 $\\mu = 0.5$ 的经典 RK4 方法。尽管 $\\Delta t$ 满足 FE 的单调性条件，但 RK4 方法不是 SSP 的。我们预期它会无法保持界限，在初始脉冲附近产生一个负下冲。结果应为 `true`。这是核心的演示。\n- **测试用例 3**：使用 $\\mu = 0.5$ 的 SSP-RK3 方法。由于该方法是 SSP 的且 $\\Delta t$ 满足 FE 条件，它将继承保界性质。我们预期结果为 `false`。\n- **测试用例 4**：使用更小时间步 $\\mu = 0.05$ 的经典 RK4 方法。对于足够小的时间步，RK4 的非 SSP 效应变得可以忽略不计，因为该方法能更好地逼近真实解。在如此小的 $\\mu$ 值下，预期它不会产生新极值。结果应为 `false`。\n\n程序将执行这四个测试，并为每个测试报告一个布尔值，指示是否生成了新极值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a counterexample for non-SSP Runge-Kutta methods.\n    \"\"\"\n\n    def L_operator(u, kappa_div_dx2):\n        \"\"\"\n        Applies the semi-discrete spatial operator L(u) for the diffusion equation.\n        L(u)_i = (kappa/dx^2) * (u_{i-1} - 2u_i + u_{i+1})\n        Dirichlet boundary conditions u_0=0, u_{N-1}=0 are handled by keeping\n        the first and last elements of the output vector as 0.\n        \"\"\"\n        N = u.shape[0]\n        Lu = np.zeros(N)\n        \n        # Vectorized calculation for interior points\n        u_left = u[:-2]   # u[0]...u[N-3]\n        u_mid = u[1:-1]  # u[1]...u[N-2]\n        u_right = u[2:]    # u[2]...u[N-1]\n        \n        Lu[1:-1] = kappa_div_dx2 * (u_left - 2 * u_mid + u_right)\n        \n        return Lu\n\n    def run_simulation(method, N, dx, kappa, dt):\n        \"\"\"\n        Runs a single time step for a given method and parameters.\n        Returns True if a new extremum is generated, False otherwise.\n        \"\"\"\n        # Initial condition: unit spike at the center\n        u0 = np.zeros(N)\n        center_idx = (N - 1) // 2\n        u0[center_idx] = 1.0\n\n        kappa_div_dx2 = kappa / (dx**2)\n\n        # Apply one time step of the selected integrator\n        if method == 'FE':\n            # Forward Euler\n            u1 = u0 + dt * L_operator(u0, kappa_div_dx2)\n        \n        elif method == 'RK4':\n            # Classical Fourth-Order Runge-Kutta\n            k1 = L_operator(u0, kappa_div_dx2)\n            k2 = L_operator(u0 + 0.5 * dt * k1, kappa_div_dx2)\n            k3 = L_operator(u0 + 0.5 * dt * k2, kappa_div_dx2)\n            k4 = L_operator(u0 + dt * k3, kappa_div_dx2)\n            u1 = u0 + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n        elif method == 'SSP3':\n            # Third-Order SSP Runge-Kutta (Shu-Osher)\n            u_stage1 = u0 + dt * L_operator(u0, kappa_div_dx2)\n            u_stage2 = 0.75 * u0 + 0.25 * (u_stage1 + dt * L_operator(u_stage1, kappa_div_dx2))\n            u1 = (1.0 / 3.0) * u0 + (2.0 / 3.0) * (u_stage2 + dt * L_operator(u_stage2, kappa_div_dx2))\n        \n        else:\n            raise ValueError(\"Unknown method specified\")\n\n        # Check if the solution is outside the initial bounds [0, 1]\n        # The convex hull of the initial data is [min(u0), max(u0)] = [0, 1]\n        min_u1 = np.min(u1)\n        max_u1 = np.max(u1)\n        \n        # Per problem, check for strict violation. Floating point tolerance is not\n        # necessary here as the expected violation for RK4 is significant.\n        is_violated = (min_u1 < 0.0) or (max_u1 > 1.0)\n        \n        return is_violated\n\n    # Define the test cases from the problem statement.\n    # (method, N, dx, kappa, dt)\n    test_cases = [\n        ('FE', 51, 1.0, 1.0, 0.5),    # Case 1: FE, mu=0.5\n        ('RK4', 51, 1.0, 1.0, 0.5),   # Case 2: RK4, mu=0.5\n        ('SSP3', 51, 1.0, 1.0, 0.5),  # Case 3: SSP3, mu=0.5\n        ('RK4', 51, 1.0, 1.0, 0.05),  # Case 4: RK4, mu=0.05\n    ]\n\n    results = []\n    for case in test_cases:\n        method, N, dx, kappa, dt = case\n        result = run_simulation(method, N, dx, kappa, dt)\n        results.append(str(result).lower()) # Convert boolean to lowercase string\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "刚性（Stiffness）是计算流体力学中一个普遍存在的重大挑战，它指的是系统中不同物理过程在极为悬殊的时间尺度上发生。本高级数值实验将对比解决刚性问题的两种强大策略：算子分裂法和隐式-显式（IMEX）龙格-库塔方法。通过亲手实现和评估这两种方法，您将在一个实际问题背景下，深入洞察在精度、稳定性和计算成本之间的权衡。",
            "id": "3359953",
            "problem": "您将设计并实现一个数值实验（通过代码），以证明对于一维空间中的刚性反应流，非分裂的隐式-显式龙格-库塔（IMEX RK）时间积分器在精度和成本上均优于 Strang 分裂法。控制方程是线性平流-弛豫模型\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\frac{s(x) - u}{\\varepsilon}, \\quad x \\in [0,1], \\quad t \\in [0,T],\n$$\n该方程具有周期性边界条件，其中 $a \\gt 0$ 是平流速度，$\\varepsilon \\gt 0$ 是刚度参数，$s(x)$ 是一个空间变化的平衡态。数值实验请考虑以下规范：\n\n- 使用具有 $N$ 个单元和单元中心未知量的均匀网格对空间进行离散化。对平流算子使用一阶迎风有限体积半离散化。也就是说，如果 $a \\gt 0$，则空间算子近似为\n$$\n\\left(F_E(u)\\right)_i = -\\frac{a}{\\Delta x} \\left(u_i - u_{i-1}\\right),\n$$\n采用周期性索引，其中 $\\Delta x = 1/N$。\n- 源项取为 $s(x) = \\sin(4\\pi x)$，初始条件取为 $u(x,0) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$。\n- 在时间区间 $[0,T]$ 上实现两种时间积分器：\n  1. 一种非分裂的二阶两阶段隐式-显式龙格-库塔（IMEX RK）格式，其隐式部分为对角隐式且 L-稳定，具体为带有参数 $\\gamma = 1 - 1/\\sqrt{2}$ 的 Ascher–Ruuth–Spiteri 两阶段方法。将显式（平流）右端项记为 $F_E(u)$，隐式（反应）右端项记为 $F_I(u) = \\left(s - u\\right)/\\varepsilon$。使用加法龙格-库塔形式，其显式 tableau 为\n  $$\n  A^{E} = \\begin{bmatrix} 0 & 0 \\\\ \\gamma & 0 \\end{bmatrix}, \\quad b^{E} = \\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\end{bmatrix},\n  $$\n  隐式 tableau 为\n  $$\n  A^{I} = \\begin{bmatrix} \\gamma & 0 \\\\ 1-\\gamma & \\gamma \\end{bmatrix}, \\quad b^{I} = \\begin{bmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\end{bmatrix}.\n  $$\n  2. 一种二阶 Strang 分裂格式，在每个时间步 $\\Delta t$ 内交替进行反应和平流：一个反应半步，一个由显式二阶两阶段龙格-库塔格式推进的完整平流步，以及最后一个反应半步。对于反应子步，精确地对线性弛豫进行积分：\n  $$\n  u^{\\text{new}} = s + \\left(u^{\\text{old}} - s\\right) \\exp\\left(-\\frac{\\Delta t}{\\varepsilon}\\right),\n  $$\n  对半步应用 $\\Delta t/2$。\n- 对于每种方法，根据 Courant–Friedrichs–Lewy 数（CFL）选择时间步长\n$$\n\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{a}.\n$$\n- 通过特征线法定义任意时刻 $t$ 的参考（精确）解。沿着特征线 $x(t) = x_0 + a t$，解满足一个线性弛豫常微分方程。对于 $s(x) = \\sin(4\\pi x)$ 和给定的 $u(x,0)$，精确解可以用以下闭合形式表示\n$$\nu(x,t) = e^{-\\lambda t} u_0(x - a t) + \\lambda \\int_{0}^{t} e^{-\\lambda \\sigma} s\\!\\left(x - a\\sigma\\right)\\, d\\sigma,\n$$\n其中 $\\lambda = 1/\\varepsilon$，$u_0(x) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$，并且该积分可以使用关于 $\\int e^{-\\lambda \\sigma}\\cos(b \\sigma)\\, d\\sigma$ 和 $\\int e^{-\\lambda \\sigma}\\sin(b \\sigma)\\, d\\sigma$（其中 $b = 4\\pi a$）的恒等式进行解析计算。\n- 在最终时刻 $T$ 使用离散 $L^2$-范数测量数值解 $u_h$ 相对于精确解 $u_{\\text{exact}}$ 的误差\n$$\n\\left\\| u_h - u_{\\text{exact}} \\right\\|_2 = \\sqrt{ \\Delta x \\sum_{i=0}^{N-1} \\left(u_{h,i} - u_{\\text{exact}}(x_i,T)\\right)^2 }.\n$$\n- 以与右端项求值和隐式求解次数成比例的单位来衡量成本。将每时间步的成本定义为 $C_{\\text{step}} = 2 + 2$（对两种方法均适用），每个完整步长计为 2 次显式平流残差求值和 2 次反应求解，因此总成本为 $C_{\\text{total}} = C_{\\text{step}} \\times$ (步数)。\n- 对于下面的每个测试用例，计算：\n  1. 一个布尔值，表示在相同的 $\\Delta t$ 下，IMEX RK 方法的误差是否严格小于 Strang 分裂法。\n  2. 一个布尔值，表示 IMEX RK 方法是否比 Strang 分裂法在达到相同或更高精度时成本更低。为了评估这一点，保持 IMEX 的时间步长不变，然后通过整数因子 $m \\in \\{1,2,4,8,16,32\\}$ 细化 Strang 分裂法的时间步长，即使用 $\\Delta t_{\\text{split}} = \\Delta t / m$，并找到使 Strang 分裂误差小于或等于 IMEX 误差的最小 $m$。在该 $m$ 值下比较成本。如果集合中不存在这样的 $m$，则认为 IMEX 方法成本更低。\n- 使用 $a = 1$，以及每个测试指定的 $T$。\n\n您的程序必须实现上述数值方法，并为以下测试套件生成结果：\n- 测试 1：$N = 256$，$\\varepsilon = 10^{-3}$，$\\text{CFL} = 0.9$，$T = 0.2$。\n- 测试 2：$N = 256$，$\\varepsilon = 10^{-5}$，$\\text{CFL} = 0.9$，$T = 0.2$。\n- 测试 3：$N = 128$，$\\varepsilon = 10^{-4}$，$\\text{CFL} = 0.99$，$T = 0.3$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目对应一个测试，并且本身是按上述顺序排列的包含两个布尔值的列表。例如，输出格式必须是\n```\n[[true,true],[true,true],[true,true]]\n```\n不涉及物理单位或角度。根据定义，三角函数中的所有角度都以弧度为单位。输出条目必须是布尔值。",
            "solution": "该问题提出了一个适定且有科学依据的数值实验，用于比较两种时间积分方案——隐式-显式（IMEX）龙格-库塔方法和 Strang 分裂法——在刚性平流-反应问题上的表现。详细的验证证实了该问题是自洽的、客观的，并且没有科学或逻辑上的缺陷。因此，我们着手构建解决方案。\n\n问题的核心是求解具有周期性边界条件的一维线性平流-反应方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\frac{s(x) - u}{\\varepsilon}, \\quad x \\in [0,1], \\quad t \\in [0,T]\n$$\n这里，$a > 0$ 是恒定的平流速度，$\\varepsilon > 0$ 是弛豫时间，它决定了反应项的刚度，$s(x)$ 是平衡态。当 $\\varepsilon$ 很小时，就会出现刚性，导致反应项在比平流项快得多的时间尺度上运作。\n\n空间域在一个包含 $N$ 个宽度为 $\\Delta x = 1/N$ 的单元的均匀网格上进行离散化。单元中心的未知量表示为 $u_i(t) \\approx u(x_i, t)$，其中 $x_i = (i+0.5)\\Delta x$，对于 $i = 0, \\dots, N-1$。这产生了一个常微分方程（ODEs）系统：\n$$\n\\frac{d\\mathbf{u}}{dt} = F_E(\\mathbf{u}) + F_I(\\mathbf{u})\n$$\n其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。平流算子 $F_E$ 是非刚性（显式）部分，反应算子 $F_I$ 是刚性（隐式）部分。\n平流项使用一阶迎风有限体积法进行离散化。对于 $a>0$，界面 $x_{i-1/2}$ 处的通量近似为 $a u_{i-1}$，从而得到半离散化形式：\n$$\n(F_E(\\mathbf{u}))_i = -\\frac{a}{\\Delta x} (u_i - u_{i-1})\n$$\n周期性通过模 $N$ 的索引算术来处理。反应项是纯粹局部的：\n$$\n(F_I(\\mathbf{u}))_i = \\frac{s(x_i) - u_i}{\\varepsilon}\n$$\n具体的初始条件是 $u(x,0) = \\cos(2\\pi x) + \\tfrac{1}{2}\\sin(6\\pi x)$，源项是 $s(x) = \\sin(4\\pi x)$。\n\n误差分析需要一个参考解。所提供的特征线法给出了精确解。沿着特征曲线 $x(t) = x_0 + at$，控制偏微分方程简化为常微分方程 $\\frac{du}{dt} = \\frac{s(x_0+at) - u}{\\varepsilon}$。这个线性常微分方程的通解是齐次解和特解之和。一个稳定且富有洞察力的表示是：\n$$\nu(x,t) = u_{\\text{eq}}(x) + e^{-t/\\varepsilon} \\left( u(x-at, 0) - u_{\\text{eq}}(x-at) \\right)\n$$\n其中 $u(x-at,0) = u_0(x-at)$ 是沿特征线平流的初始条件，$u_{\\text{eq}}(x)$ 是稳态方程 $a \\frac{du}{dx} = \\frac{s(x) - u}{\\varepsilon}$ 的平衡解。通过代入 $s(x) = \\sin(4\\pi x)$ 并假设解的形式为 $u_{\\text{eq}}(x) = A\\sin(4\\pi x) + B\\cos(4\\pi x)$，我们发现：\n$$\nu_{\\text{eq}}(x) = \\frac{\\sin(4\\pi x) - 4\\pi a \\varepsilon \\cos(4\\pi x)}{1 + (4\\pi a \\varepsilon)^2}\n$$\n这种形式的精确解对于小的 $\\varepsilon$ 是鲁棒的，因为项 $e^{-t/\\varepsilon}$ 会迅速衰减到零。\n\n该数值实验比较了两种二阶时间积分器。\n\n1.  **非分裂 IMEX 龙格-库塔方法：** Ascher–Ruuth–Spiteri ARS(2,2,2) 格式是一种 L-稳定、两阶段、二阶的对角隐式龙格-库塔（DIRK）方法，用于处理隐式部分，而对显式部分则采用显式方法。对于一个常微分方程系统 $\\mathbf{u}' = F_E(\\mathbf{u}) + F_I(\\mathbf{u})$，阶段 $\\mathbf{Y}_1, \\mathbf{Y}_2$ 和最终解 $\\mathbf{u}^{n+1}$ 是从 $\\mathbf{u}^n$ 在一个时间步 $\\Delta t$ 内按如下方式计算的：\n    -   阶段 1：求解 $\\mathbf{Y}_1$：\n        $$\n        \\mathbf{Y}_1 = \\mathbf{u}^n + \\Delta t \\gamma F_I(\\mathbf{Y}_1)\n        $$\n        由于 $F_I$ 是线性的，这对每个分量都是一个代数求解：$(\\mathbf{Y}_1)_i = \\frac{(\\mathbf{u}^n)_i + \\Delta t \\gamma s_i / \\varepsilon}{1 + \\Delta t \\gamma / \\varepsilon}$，其中 $\\gamma = 1 - 1/\\sqrt{2}$。\n    -   阶段 2：求解 $\\mathbf{Y}_2$：\n        $$\n        \\mathbf{Y}_2 = \\mathbf{u}^n + \\Delta t \\gamma F_E(\\mathbf{Y}_1) + \\Delta t (1-\\gamma) F_I(\\mathbf{Y}_1) + \\Delta t \\gamma F_I(\\mathbf{Y}_2)\n        $$\n        同样，这是对 $\\mathbf{Y}_2$ 的一个分量式代数求解。\n    -   最终解：\n        $$\n        \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\frac{\\Delta t}{2} \\left[ F_E(\\mathbf{Y}_1) + F_E(\\mathbf{Y}_2) + F_I(\\mathbf{Y}_1) + F_I(\\mathbf{Y}_2) \\right]\n        $$\n\n2.  **Strang 分裂法：** 该方法将完整算子分解为平流和反应部分，并按顺序对称地应用它们，以达到二阶精度。从 $\\mathbf{u}^n$ 到 $\\mathbf{u}^{n+1}$ 的一个步长包括三个子步骤：\n    -   1. 反应半步：$\\mathbf{u}^* = \\mathcal{S}_{\\Delta t/2}(\\mathbf{u}^n)$。在 $\\Delta t/2$ 上积分 $\\frac{d\\mathbf{u}}{dt} = F_I(\\mathbf{u})$。使用精确解：\n        $$\n        u_i^* = s_i + (u_i^n - s_i) \\exp\\left(-\\frac{\\Delta t}{2\\varepsilon}\\right)\n        $$\n    -   2. 平流全步：$\\mathbf{u}^{**} = \\mathcal{A}_{\\Delta t}(\\mathbf{u}^*)$。使用二阶显式龙格-库塔格式（例如，Heun 方法）在整个时间步 $\\Delta t$ 上积分 $\\frac{d\\mathbf{u}}{dt} = F_E(\\mathbf{u})$：\n        $$\n        \\mathbf{k}_1 = F_E(\\mathbf{u}^*)\n        $$\n        $$\n        \\mathbf{k}_2 = F_E(\\mathbf{u}^* + \\Delta t \\mathbf{k}_1)\n        $$\n        $$\n        \\mathbf{u}^{**} = \\mathbf{u}^* + \\frac{\\Delta t}{2}(\\mathbf{k}_1 + \\mathbf{k}_2)\n        $$\n    -   3. 反应半步：$\\mathbf{u}^{n+1} = \\mathcal{S}_{\\Delta t/2}(\\mathbf{u}^{**})$。这是在 $\\Delta t/2$ 上的另一个精确反应步骤：\n        $$\n        u_i^{n+1} = s_i + (u_i^{**} - s_i) \\exp\\left(-\\frac{\\Delta t}{2\\varepsilon}\\right)\n        $$\n    对于刚性问题，分裂方法可能会出现阶数降低的问题，其中分裂误差包含诸如 $\\Delta t^2 / \\varepsilon$ 的项，这些项随着 $\\varepsilon \\to 0$ 而变大。\n\n比较基于精度和成本。误差是在最终时刻 $T$ 使用离散 $L^2$-范数与精确解进行比较来测量的。计算成本定义为 $C_{\\text{total}} = 4 \\times (\\text{时间步数})$，两种方法每步都计入两次显式求值和两次隐式求解（或其等效操作）。实验评估 (1) 在相同时间步 $\\Delta t$ 下，IMEX 是否更精确，以及 (2) 为达到由其自身误差设定的目标精度，IMEX 是否成本更低。对于第二点，将 Strang 分裂法的时间步长通过因子 $m \\in \\{1,2,4,8,16,32\\}$ 进行细化，直到其误差小于或等于 IMEX 的误差，然后比较成本。如果即使在 $m=32$ 时也无法达到所需精度，则根据定义认为 IMEX 成本更低。该实现将为每个指定的测试用例执行此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print results.\n    \"\"\"\n\n    test_cases = [\n        # (N, epsilon, CFL, T)\n        (256, 1e-3, 0.9, 0.2),\n        (256, 1e-5, 0.9, 0.2),\n        (128, 1e-4, 0.99, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = run_comparison(*case)\n        results.append(case_result)\n\n    # Format the final output string to match the problem specification\n    # e.g., [[True,False],[True,True],[True,True]]\n    output_str = str(results).replace(\" \", \"\").replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\n\ndef run_comparison(N, epsilon, CFL, T):\n    \"\"\"\n    Runs the full comparison for a single test case.\n    \"\"\"\n    # --- 1. Setup ---\n    a = 1.0\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    dt = CFL * dx / a\n\n    u0 = np.cos(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x)\n    s = np.sin(4 * np.pi * x)\n\n    # --- 2. Run IMEX Method ---\n    u_imex = run_integrator(\n        imex_step, u0, s, dt, T, N, a, epsilon, gamma\n    )\n    num_steps_imex = int(np.ceil(T / dt))\n    cost_imex = 4 * num_steps_imex\n\n    # --- 3. Run Strang Splitting Method (baseline) ---\n    u_strang_base = run_integrator(\n        strang_step, u0, s, dt, T, N, a, epsilon, gamma\n    )\n\n    # --- 4. Compute Errors and Compare Accuracy ---\n    u_exact_final = get_exact_solution(x, T, a, epsilon)\n    error_imex = compute_l2_error(u_imex, u_exact_final, dx)\n    error_strang_base = compute_l2_error(u_strang_base, u_exact_final, dx)\n\n    acc_better = error_imex < error_strang_base\n\n    # --- 5. Compare Cost for a Given Accuracy ---\n    cost_better = False\n    found_m = False\n    refinement_factors = [1, 2, 4, 8, 16, 32]\n\n    for m in refinement_factors:\n        dt_split = dt / m\n        u_strang_refined = run_integrator(\n            strang_step, u0, s, dt_split, T, N, a, epsilon, gamma\n        )\n        error_strang_refined = compute_l2_error(u_strang_refined, u_exact_final, dx)\n\n        if error_strang_refined <= error_imex:\n            num_steps_strang = int(np.ceil(T / dt_split))\n            cost_strang_refined = 4 * num_steps_strang\n            cost_better = cost_imex < cost_strang_refined\n            found_m = True\n            break\n            \n    if not found_m:\n        # If Strang can't match accuracy even with 32x refinement, IMEX is cheaper.\n        cost_better = True\n\n    return [acc_better, cost_better]\n\n\n# --- Helper Functions ---\n\ndef advection_rhs(u, a, dx):\n    \"\"\"Computes the first-order upwind discretization of the advection term.\"\"\"\n    return -a / dx * (u - np.roll(u, 1))\n\n\ndef get_exact_solution(x, t, a, epsilon):\n    \"\"\"Computes the exact solution at a given time t.\"\"\"\n    \n    def u0_func(x_arg):\n        return np.cos(2 * np.pi * x_arg) + 0.5 * np.sin(6 * np.pi * x_arg)\n\n    def u_eq(x_arg):\n        b = 4.0 * np.pi * a\n        return (np.sin(4 * np.pi * x_arg) - b * epsilon * np.cos(4 * np.pi * x_arg)) / (1.0 + (b * epsilon)**2)\n\n    lambd = 1.0 / epsilon\n    x_char = (x - a * t) % 1.0\n    \n    # This form is numerically stable for small epsilon (large lambda)\n    transient_term = np.exp(-lambd * t) * (u0_func(x_char) - u_eq(x_char))\n    \n    return u_eq(x) + transient_term\n\n\ndef imex_step(u, s, dt, N, a, epsilon, gamma):\n    \"\"\"Performs one step of the IMEX Runge-Kutta scheme.\"\"\"\n    dx = 1.0 / N\n    \n    # Common denominator for implicit solves\n    denom = 1.0 + dt * gamma / epsilon\n\n    # Stage 1\n    Y1 = (u + dt * gamma * s / epsilon) / denom\n    \n    # Stage 2\n    F_E_Y1 = advection_rhs(Y1, a, dx)\n    F_I_Y1 = (s - Y1) / epsilon\n    RHS2 = u + dt * gamma * F_E_Y1 + dt * (1.0 - gamma) * F_I_Y1\n    Y2 = (RHS2 + dt * gamma * s / epsilon) / denom\n\n    # Final update\n    F_E_Y2 = advection_rhs(Y2, a, dx)\n    F_I_Y2 = (s - Y2) / epsilon\n    u_new = u + 0.5 * dt * (F_E_Y1 + F_E_Y2 + F_I_Y1 + F_I_Y2)\n    return u_new\n\n\ndef strang_step(u, s, dt, N, a, epsilon, gamma):\n    \"\"\"Performs one step of the Strang splitting scheme.\"\"\"\n    dx = 1.0 / N\n    \n    # 1. Reaction half-step\n    exp_term = np.exp(-0.5 * dt / epsilon)\n    u_star = s + (u - s) * exp_term\n    \n    # 2. Advection full-step (Heun's method)\n    k1 = advection_rhs(u_star, a, dx)\n    u_tmp = u_star + dt * k1\n    k2 = advection_rhs(u_tmp, a, dx)\n    u_ss = u_star + 0.5 * dt * (k1 + k2)\n    \n    # 3. Reaction half-step\n    u_new = s + (u_ss - s) * exp_term\n    return u_new\n\n\ndef run_integrator(step_func, u0, s, dt, T, N, a, epsilon, gamma):\n    \"\"\"\n    Evolves the solution u from t=0 to t=T using the provided step function.\n    Handles the final partial time step.\n    \"\"\"\n    u = u0.copy()\n    num_steps = int(T / dt)\n    dt_final = T - num_steps * dt\n    \n    for _ in range(num_steps):\n        u = step_func(u, s, dt, N, a, epsilon, gamma)\n        \n    if dt_final > 1e-12:  # Avoid tiny final steps due to float precision\n        u = step_func(u, s, dt_final, N, a, epsilon, gamma)\n        \n    return u\n\n\ndef compute_l2_error(u_num, u_exact, dx):\n    \"\"\"Computes the discrete L2 error norm.\"\"\"\n    return np.sqrt(dx * np.sum((u_num - u_exact)**2))\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}