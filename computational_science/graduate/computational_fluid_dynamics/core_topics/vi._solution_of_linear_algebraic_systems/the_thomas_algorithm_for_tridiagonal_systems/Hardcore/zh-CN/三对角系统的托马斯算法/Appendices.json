{
    "hands_on_practices": [
        {
            "introduction": "要想真正掌握托马斯算法，首先必须亲手演练其计算过程。本练习提供了一个具体的 $4 \\times 4$ 三对角系统供您求解。通过手动执行前向消元和后向回代步骤，您将对该算法如何高效地变换和求解方程组获得扎实的程序性理解，为更复杂的实现打下坚实的基础。",
            "id": "1030146",
            "problem": "考虑以下三对角方程组：\n$$\n\\begin{cases}\n2x_1 - x_2 = 3 \\\\\n-x_1 + 3x_2 - 2x_3 = 1 \\\\\n-\\frac{1}{2}x_2 + 4x_3 - x_4 = 0 \\\\\n-\\frac{3}{2}x_3 + 5x_4 = 2\n\\end{cases}\n$$\n使用托马斯算法求解该方程组，并给出 $x_4$ 的值。托马斯算法包括一个用于修改系数的正向追赶过程和一个从最后一个变量开始计算解的反向回代过程。",
            "solution": "对于一个形如 $A\\mathbf{x} = \\mathbf{d}$ 的三对角系统，我们采用与文章主体部分一致的记法：\n- 下对角线元素 $\\{a_i\\}_{i=2}^n$\n- 主对角线元素 $\\{b_i\\}_{i=1}^n$\n- 上对角线元素 $\\{c_i\\}_{i=1}^{n-1}$\n- 右端向量 $\\mathbf{d}$\n\n该算法包含两个步骤：\n\n1.  **前向消元**：此过程修改主对角线元素和右端项。我们将修改后的值记为 $\\tilde{b}_i$ 和 $\\tilde{d}_i$。\n    - 初始化: $\\tilde{b}_1 = b_1$, $\\tilde{d}_1 = d_1$\n    - 对 $i = 2, \\dots, n$ 迭代：\n      - $m_i = a_i / \\tilde{b}_{i-1}$\n      - $\\tilde{b}_i = b_i - m_i \\cdot c_{i-1}$\n      - $\\tilde{d}_i = d_i - m_i \\cdot \\tilde{d}_{i-1}$\n\n2.  **反向回代**：从 $x_n$ 到 $x_1$ 求解。\n    - $x_n = \\tilde{d}_n / \\tilde{b}_n$\n    - 对 $i = n-1, \\dots, 1$ 迭代：$x_i = (\\tilde{d}_i - c_i \\cdot x_{i+1}) / \\tilde{b}_i$\n\n**给定系统的系数：**\n- 下对角线 $a$: $a_2 = -1$, $a_3 = -\\frac{1}{2}$, $a_4 = -\\frac{3}{2}$\n- 主对角线 $b$: $b_1 = 2$, $b_2 = 3$, $b_3 = 4$, $b_4 = 5$\n- 上对角线 $c$: $c_1 = -1$, $c_2 = -2$, $c_3 = -1$\n- 右端项 $d$: $d_1 = 3$, $d_2 = 1$, $d_3 = 0$, $d_4 = 2$\n\n**前向消元：**\n\n- 对于 $i=1$：\n  $\\tilde{b}_1 = b_1 = 2$\n  $\\tilde{d}_1 = d_1 = 3$\n\n- 对于 $i=2$：\n  $m_2 = a_2 / \\tilde{b}_1 = (-1) / 2 = -\\frac{1}{2}$\n  $\\tilde{b}_2 = b_2 - m_2 \\cdot c_1 = 3 - (-\\frac{1}{2})(-1) = 3 - \\frac{1}{2} = \\frac{5}{2}$\n  $\\tilde{d}_2 = d_2 - m_2 \\cdot \\tilde{d}_1 = 1 - (-\\frac{1}{2})(3) = 1 + \\frac{3}{2} = \\frac{5}{2}$\n\n- 对于 $i=3$：\n  $m_3 = a_3 / \\tilde{b}_2 = (-\\frac{1}{2}) / (\\frac{5}{2}) = -\\frac{1}{5}$\n  $\\tilde{b}_3 = b_3 - m_3 \\cdot c_2 = 4 - (-\\frac{1}{5})(-2) = 4 - \\frac{2}{5} = \\frac{18}{5}$\n  $\\tilde{d}_3 = d_3 - m_3 \\cdot \\tilde{d}_2 = 0 - (-\\frac{1}{5})(\\frac{5}{2}) = \\frac{1}{2}$\n\n- 对于 $i=4$：\n  $m_4 = a_4 / \\tilde{b}_3 = (-\\frac{3}{2}) / (\\frac{18}{5}) = -\\frac{3}{2} \\cdot \\frac{5}{18} = -\\frac{5}{12}$\n  $\\tilde{b}_4 = b_4 - m_4 \\cdot c_3 = 5 - (-\\frac{5}{12})(-1) = 5 - \\frac{5}{12} = \\frac{55}{12}$\n  $\\tilde{d}_4 = d_4 - m_4 \\cdot \\tilde{d}_3 = 2 - (-\\frac{5}{12})(\\frac{1}{2}) = 2 + \\frac{5}{24} = \\frac{53}{24}$\n\n**反向回代：**\n\n- 对于 $x_4$：\n  $x_4 = \\tilde{d}_4 / \\tilde{b}_4 = (\\frac{53}{24}) / (\\frac{55}{12}) = \\frac{53}{24} \\cdot \\frac{12}{55} = \\frac{53}{2 \\cdot 55} = \\frac{53}{110}$\n\n因此，$x_4 = \\frac{53}{110}$。",
            "answer": "$$ \\boxed{\\frac{53}{110}} $$"
        },
        {
            "introduction": "从手动计算到实际编程是计算科学中的关键一步。本练习挑战您将托马斯算法应用于源自一维扩散方程的线性系统，这是一维计算流体动力学中的一个基石问题。通过将其性能与通用的 $LU$ 分解求解器进行比较，您将从量化的角度体会到这种专用算法在计算效率和数值稳定性方面的巨大优势。",
            "id": "3383321",
            "problem": "考虑一维稳态扩散方程，这是计算流体动力学（CFD）中的一个典型模型，其形式为 $-\\dfrac{d^2 u}{dx^2} = f(x)$，定义在单位区间 $[0,1]$ 上，并带有齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。使用具有 $n$ 个内部节点的均匀网格、网格间距 $h = \\dfrac{1}{n+1}$，以及二阶导数的二阶中心差分近似，可以得到一个线性系统 $A \\mathbf{u} = \\mathbf{b}$。其中，$A$ 是一个三对角矩阵，其主对角线上的元素为 $2$，次对角线和超对角线上的元素为 $-1$。具体来说，$A \\in \\mathbb{R}^{n \\times n}$ 的元素为 $a_i = -1$（对于 $i = 2,\\dots,n$），$b_i = 2$（对于 $i = 1,\\dots,n$），以及 $c_i = -1$（对于 $i = 1,\\dots,n-1$），因此 $A$ 是与此离散化相对应的 Toeplitz 三对角矩阵。\n\n从数值线性代数的角度来看，在这种情况下，求解 $A \\mathbf{x} = \\mathbf{b}$ 有两种经典方法：\n- 托马斯算法（不进行主元选择的三对角高斯消去法），该算法利用了三对角结构。\n- 基于带部分主元选择的 LU (Lower-Upper) 分解的通用稠密求解器，该方法忽略稀疏性并将 $A$ 视为稠密矩阵。\n\n仅从上述离散化出发，实现这两种求解器，并在同一个三对角系统上比较它们的数值精度和计算成本。通过以下方式构造一个合成的右端项，以保证存在已知的精确解：对于给定的 $n$，定义精确解向量 $\\mathbf{x}^{\\star} \\in \\mathbb{R}^n$，其元素为 $x_i^{\\star} = \\sin\\!\\left(\\pi \\dfrac{i}{n+1}\\right)$（对于 $i = 1,\\dots,n$）。然后设置 $\\mathbf{b} = A \\mathbf{x}^{\\star}$。对于每种求解器，计算：\n- 相对 2-范数误差 $e = \\dfrac{\\lVert \\mathbf{x} - \\mathbf{x}^{\\star} \\rVert_2}{\\lVert \\mathbf{x}^{\\star} \\rVert_2}$，\n- 2-范数残差 $r = \\lVert \\mathbf{b} - A \\mathbf{x} \\rVert_2$。\n\n对于计算成本，按如下方式报告运算次数：\n- 对于托马斯算法，使用精确计数 $F_{\\mathrm{T}}(n) = 8n - 7$，该计数将每次加法、减法、乘法和除法视为一次浮点运算。\n- 对于带部分主元选择的稠密 LU 求解器，使用标准的稠密估计 $F_{\\mathrm{LU}}(n) = \\dfrac{2}{3} n^3 + 2 n^2$，该估计涵盖了分解以及前向和后向代换的成本。\n\n您的实现必须是一个完整的、可运行的程序，能够：\n- 根据上述规范为每个测试用例构造 $A$ 和 $\\mathbf{b}$，\n- 用两种方法求解该系统，\n- 计算规定的精度指标和成本估算，\n- 以指定格式生成输出。\n\n测试套件：\n- 使用以下内部节点数 $n$ 的集合来测试不同的区域和边界情况：$n \\in \\{\\,1,\\,2,\\,50,\\,400\\,\\}$。\n\n可量化的答案：\n- 对于每个测试用例 $n$，生成一个包含六个浮点数的列表：$[e_{\\mathrm{T}}, e_{\\mathrm{LU}}, r_{\\mathrm{T}}, r_{\\mathrm{LU}}, F_{\\mathrm{T}}(n), F_{\\mathrm{LU}}(n)]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每一项是对应于一个测试用例（按 $n = 1$, $n = 2$, $n = 50$, $n = 400$ 的顺序）的列表。例如：$[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$。\n- 所有报告的量均为无量纲实数（无物理单位）。不使用角度，也不需要百分比；任何比率都必须以实数形式提供。",
            "solution": "所提出的问题是有效的。这是一个在数值线性代数领域中适定且具有科学依据的问题，在计算流体动力学中有直接应用。所有必要的数据和定义都已提供，没有矛盾或含糊之处。\n\n该问题要求比较两种不同的数值方法，用于求解由一维稳态扩散方程的有限差分法离散化产生的线性系统 $A \\mathbf{x} = \\mathbf{b}$。这两种方法是托马斯算法（一种针对三对角系统的专用求解器）和基于带部分主元选择的 LU 分解的通用稠密求解器。\n\n控制偏微分方程是在单位区间 $x \\in [0, 1]$ 上的一维泊松方程：\n$$\n-\\frac{d^2 u}{dx^2} = f(x)\n$$\n其边界条件为齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n引入一个具有 $n$ 个内部节点 $x_i = i h$（$i=1, \\dots, n$）的均匀网格，其中网格间距为 $h = \\frac{1}{n+1}$。边界点为 $x_0 = 0$ 和 $x_{n+1} = 1$。在每个内部节点 $x_i$ 处，使用二阶导数的二阶中心差分近似：\n$$\n\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此式代入控制方程，得到一个包含 $n$ 个线性方程的系统：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i) \\quad \\text{for } i = 1, \\dots, n\n$$\n其中 $u_0 = u(0) = 0$ 且 $u_{n+1} = u(1) = 0$。整理后可得：\n$$\n-u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i)\n$$\n这可以表示为一个矩阵系统 $A \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_n]^T$ 是内部节点处未知值的向量，$\\mathbf{b} = h^2 [f(x_1), \\dots, f(x_n)]^T$，而 $A$ 是问题陈述中定义的 $n \\times n$ 三对角矩阵：\n$$\nA = \\begin{pmatrix}\n2  -1    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  2\n\\end{pmatrix}\n$$\n该矩阵是对称正定的。对于第一行和最后一行，它是严格对角占优的；对于所有其他行，它是弱对角占优的。这些性质对于数值求解器的稳定性至关重要。\n\n问题通过首先定义一个精确解 $\\mathbf{x}^{\\star}$，然后计算 $\\mathbf{b} = A \\mathbf{x}^{\\star}$ 的方式，指定了一个合成的右端向量 $\\mathbf{b}$。精确解的各分量为 $x_i^{\\star} = \\sin(\\pi \\frac{i}{n+1})$（$i=1, \\dots, n$）。这种方法，即制造解方法，可以精确地量化数值误差。\n\n**方法 1：托马斯算法**\n\n托马斯算法是一种高效的专用方法，用于求解三对角方程组。它是高斯消去法的一种形式，避免了对矩阵零元素的操作，从而使其计算成本为 $O(n)$ 级别。它包括两个阶段：一个前向消元过程和一个后向代入过程。\n\n给定一个三对角系统，其有次对角线 $a_i$（$i=2, \\dots, n$）、主对角线 $d_i$（$i=1, \\dots, n$）、超对角线 $c_i$（$i=1, \\dots, n-1$）以及右端向量 $r_i$：\n$$\na_i x_{i-1} + d_i x_i + c_i x_{i+1} = r_i\n$$\n问题陈述中使用 $b_i$ 表示主对角线，因此我们在这里使用该记法（$d_i \\equiv b_i$）：\n1.  **前向消元**：该算法修改超对角线系数 $c_i$ 和右端向量 $r_i$。设修改后的系数为 $c'_i$ 和 $r'_i$。\n    $$\n    c'_1 = \\frac{c_1}{b_1} \\quad ; \\quad r'_1 = \\frac{r_1}{b_1}\n    $$\n    对于 $i = 2, \\dots, n-1$：\n    $$\n    c'_i = \\frac{c_i}{b_i - a_i c'_{i-1}}\n    $$\n    以及对于 $i = 2, \\dots, n$：\n    $$\n    r'_i = \\frac{r_i - a_i r'_{i-1}}{b_i - a_i c'_{i-1}}\n    $$\n2.  **后向代入**：解向量 $\\mathbf{x}$ 以相反的顺序计算。\n    $$\n    x_n = r'_n\n    $$\n    对于 $i = n-1, \\dots, 1$：\n    $$\n    x_i = r'_i - c'_i x_{i+1}\n    $$\n由于矩阵 $A$ 是对角占优的，分母 $b_i - a_i c'_{i-1}$ 永远不为零，这保证了该算法是适定的，并且无需主元选择即可保持数值稳定。其计算成本由 $F_{\\mathrm{T}}(n) = 8n - 7$ 次浮点运算给出。\n\n**方法 2：带部分主元选择的稠密 LU 分解**\n\n这是一种适用于任何可逆方阵的通用方法。它不利用 $A$ 的三对角结构。该方法首先将矩阵 $A$ 分解为乘积 $PA = LU$，其中 $P$ 是一个排列矩阵（表示为保证数值稳定性而进行的行交换，称为部分主元选择），$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。\n\n系统 $A\\mathbf{x} = \\mathbf{b}$ 被转换为 $PA\\mathbf{x} = P\\mathbf{b}$，即 $LU\\mathbf{x} = P\\mathbf{b}$。该问题分两步求解：\n1.  **前向代换**：求解下三角系统 $L\\mathbf{y} = P\\mathbf{b}$ 得到 $\\mathbf{y}$。\n2.  **后向代换**：求解上三角系统 $U\\mathbf{x} = \\mathbf{y}$ 得到 $\\mathbf{x}$。\n\n虽然这种方法很鲁棒，但对于三对角矩阵来说，其计算成本要高得多。成本主要由分解步骤决定，对于一个稠密的 $n \\times n$ 矩阵，其成本为 $O(n^3)$。问题给出的标准成本估计为 $F_{\\mathrm{LU}}(n) = \\frac{2}{3}n^3 + 2n^2$。\n\n**比较指标**\n\n对于每种求解器，我们计算两个关键指标：\n1.  **相对 2-范数误差**：$e = \\frac{\\lVert \\mathbf{x} - \\mathbf{x}^{\\star} \\rVert_2}{\\lVert \\mathbf{x}^{\\star} \\rVert_2}$。该指标衡量计算出的解 $\\mathbf{x}$ 与已知精确解 $\\mathbf{x}^{\\star}$ 的接近程度。值越小表示精度越高。\n2.  **2-范数残差**：$r = \\lVert \\mathbf{b} - A \\mathbf{x} \\rVert_2$。该指标衡量计算出的解 $\\mathbf{x}$ 对原始方程的满足程度。残差小并不总能保证误差小，尤其对于病态矩阵，但它是求解器性能的一个重要指标。\n\n实现将通过遍历指定的 $n$ 值，为每个 $n$ 构建矩阵 $A$ 和向量 $\\mathbf{x}^{\\star}$、$\\mathbf{b}$，应用两种求解器，并计算指定的六个量（$e_{\\mathrm{T}}$, $e_{\\mathrm{LU}}$, $r_{\\mathrm{T}}$, $r_{\\mathrm{LU}}$, $F_{\\mathrm{T}}(n)$, $F_{\\mathrm{LU}}(n)$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as dense_solve\n\ndef thomas_solver(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system Ax = d.\n    'a' is the sub-diagonal (n-1 elements), 'b' is the main diagonal (n elements),\n    'c' is the super-diagonal (n-1 elements), 'd' is the RHS vector (n elements).\n    The problem statement uses 1-based indexing for math notation, but here we\n    use 0-based indexing standard in programming.\n    a: sub-diagonal, a[i] is A[i+1, i]\n    b: main-diagonal, b[i] is A[i, i]\n    c: super-diagonal, c[i] is A[i, i+1]\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create modifiable copies of the super-diagonal and RHS vector\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    \n    for i in range(1, n - 1):\n        denominator = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denominator\n\n    denominator = b[n - 1] - a[n - 2] * c_prime[n - 2]\n    d_prime[n - 1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / denominator\n    \n    # Backward substitution\n    x = np.zeros(n)\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the comparison for the test suite.\n    \"\"\"\n    test_cases = [1, 2, 50, 400]\n    results = []\n\n    for n in test_cases:\n        # Step 1: Construct the linear system A x = b with a known solution x_star\n        \n        # Define the matrix A as a dense matrix for the LU solver and for calculating residuals\n        if n == 1:\n            A = np.array([[2.0]])\n        else:\n            main_diag_vals = np.full(n, 2.0)\n            sub_diag_vals = np.full(n - 1, -1.0)\n            sup_diag_vals = np.full(n - 1, -1.0)\n            A = np.diag(main_diag_vals) + np.diag(sup_diag_vals, k=1) + np.diag(sub_diag_vals, k=-1)\n        \n        # Define the exact solution vector x_star\n        i = np.arange(1, n + 1)\n        x_star = np.sin(np.pi * i / (n + 1))\n        \n        # Compute the right-hand side vector b = A * x_star\n        b = A @ x_star\n        \n        # Step 2: Solve the system using both methods\n        \n        # Method 1: Thomas Algorithm\n        if n > 1:\n            x_T = thomas_solver(sub_diag_vals, main_diag_vals, sup_diag_vals, b)\n        else: # Handle n=1 case for Thomas algorithm\n            x_T = thomas_solver(np.array([]), np.array([2.0]), np.array([]), b)\n\n        # Method 2: Dense LU solver with partial pivoting\n        x_LU = dense_solve(A, b)\n        \n        # Step 3: Compute accuracy metrics and computational costs\n        \n        # Relative 2-norm error\n        norm_x_star = np.linalg.norm(x_star)\n        e_T = np.linalg.norm(x_T - x_star) / norm_x_star\n        e_LU = np.linalg.norm(x_LU - x_star) / norm_x_star\n        \n        # 2-norm residual\n        r_T = np.linalg.norm(b - A @ x_T)\n        r_LU = np.linalg.norm(b - A @ x_LU)\n        \n        # Computational cost estimates\n        F_T = float(8 * n - 7)\n        F_LU = (2.0 / 3.0) * n**3 + 2.0 * n**2\n        \n        # Store the results for this test case\n        results.append([e_T, e_LU, r_T, r_LU, F_T, F_LU])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的CFD问题通常涉及耦合方程组或多维区域，这会产生块三对角结构而非标量结构。这项高级练习将指导您将托马斯算法推广到处理此类块系统，这是开发高效隐式求解器的一项关键技能。您将实现块托马斯算法并研究块内主元选择的作用，这是确保复杂模拟稳定性的一个关键考虑因素。",
            "id": "3383363",
            "problem": "给定一个在计算流体力学中出现的耦合三分量动量系统，其沿一条空间线的线隐式离散化。经过空间半离散化和线性化后，每条线上的代数系统简化为如下形式的块三对角线性系统：\n$$\n\\mathbf{C}_i \\,\\mathbf{x}_{i-1} + \\mathbf{A}_i \\,\\mathbf{x}_i + \\mathbf{B}_i \\,\\mathbf{x}_{i+1} = \\mathbf{d}_i,\\quad i=1,\\dots,n,\n$$\n约定 $\\mathbf{C}_1=\\mathbf{0}$ 和 $\\mathbf{B}_n=\\mathbf{0}$。每个 $\\mathbf{A}_i,\\mathbf{B}_i,\\mathbf{C}_i \\in \\mathbb{R}^{3\\times 3}$ 是一个 $3\\times 3$ 的块，对应于三个动量分量的耦合，每个未知量 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 是线位置 $i$ 处的三个未知数组成的块。右端项是 $\\mathbf{d}_i \\in \\mathbb{R}^3$。组装后的矩阵维度为 $3n \\times 3n$，且是块三对角的。\n\n仅从 Gaussian elimination 的基本定义和通过 Schur complements 的块分解原理出发，实现块 Thomas 算法，对此类具有 $3\\times 3$ 块的块三对角系统执行前向消元和回代。您的实现必须支持两种块内策略，且这两种策略都应保持 $\\mathcal{O}(n)$ 的复杂度：\n\n- 策略 $\\mathsf{NP}$：块内 $3\\times 3$ 求解通过 Gaussian elimination 完成，在 $3\\times 3$ 块内部不进行任何行主元选择（no pivoting）。这可以通过无需行交换的显式消元步骤来实现。您可以假设，对于除以非常小的主元的情况，通过向主元添加一个量级为 $\\varepsilon$ 的微小正扰动来处理，以避免除以零，其中 $\\varepsilon$ 是一个小的常数，例如 $10^{-15}$；这是一种静态阻尼，而非动态主元选择。\n\n- 策略 $\\mathsf{LU}$：块内 $3\\times 3$ 求解通过标准的带部分主元选择的分解（例如，在每个 $3\\times 3$ 块内部使用置换矩阵的典型线性求解器例程）来完成。这种方法仅在正在求解的 $3\\times 3$ 块内部进行主元选择，因此保留了块三对角稀疏性和 $\\mathcal{O}(n)$ 复杂度。\n\n您的任务是编写一个完整的程序，该程序：\n\n- 根据下面的规范，构建四个具有 $3\\times 3$ 块的确定性测试系统。\n- 通过您的块 Thomas 实现，使用策略 $\\mathsf{NP}$ 和 $\\mathsf{LU}$ 分别求解每个系统。\n- 对于每个策略和测试，计算相对于参考解的相对 $\\ell_2$ 误差。参考解是通过使用高精度稠密求解器求解完全组装的稠密 $3n\\times 3n$ 系统得到的。对于产生近似解 $\\hat{\\mathbf{x}}$ 的策略，其相对于参考解 $\\mathbf{x}^\\star$ 的相对误差为：\n$$\ne_{\\mathrm{rel}} = \\frac{\\|\\hat{\\mathbf{x}} - \\mathbf{x}^\\star\\|_2}{\\|\\mathbf{x}^\\star\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示 $\\mathbb{R}^{3n}$ 上的欧几里得范数。\n\n系统构建。对于每个测试，您必须按如下方式生成块 $\\{\\mathbf{A}_i\\}$、$\\{\\mathbf{B}_i\\}$、$\\{\\mathbf{C}_i\\}$ 和右端项 $\\{\\mathbf{d}_i\\}$：\n\n- 使用提供的整数种子选择一个可复现的伪随机数生成器状态。对于每个 $i \\in \\{1,\\dots,n\\}$，从标准正态分布中抽取一个具有独立元素的初步随机矩阵 $\\mathbf{R}_i \\in \\mathbb{R}^{3\\times 3}$，同样地抽取 $\\mathbf{S}_i,\\mathbf{T}_i \\in \\mathbb{R}^{3\\times 3}$。将初步的非对角块设置为 $\\mathbf{B}_i^{(0)} = \\beta \\,\\mathbf{S}_i$（对于 $i=1,\\dots,n-1$）和 $\\mathbf{C}_i^{(0)} = \\beta \\,\\mathbf{T}_i$（对于 $i=2,\\dots,n$）。将初步的对角块定义为 $\\mathbf{A}_i^{(0)} = \\mathbf{R}_i$。\n- 通过设置以下方式强制块对角占优：\n$$\n\\mathbf{A}_i = \\mathbf{A}_i^{(0)} + \\left(\\alpha + 1.1\\cdot \\|\\mathbf{B}_i^{(0)}\\|_1 + 1.1\\cdot \\|\\mathbf{C}_i^{(0)}\\|_1\\right)\\mathbf{I}_3,\n$$\n约定 $\\mathbf{B}_n^{(0)}=\\mathbf{0}$ 和 $\\mathbf{C}_1^{(0)}=\\mathbf{0}$。这里 $\\|\\cdot\\|_1$ 是矩阵 $1$-范数，$\\mathbf{I}_3$ 是 $3\\times 3$ 单位矩阵。然后设置 $\\mathbf{B}_i=\\mathbf{B}_i^{(0)}$（对于 $i=1,\\dots,n-1$）和 $\\mathbf{C}_i=\\mathbf{C}_i^{(0)}$（对于 $i=2,\\dots,n$）；取 $\\mathbf{B}_n=\\mathbf{0}$ 和 $\\mathbf{C}_1=\\mathbf{0}$。\n- 对于指定的“病态”测试，通过将 $\\mathbf{A}_j$ 的元素 $(1,1)$ 替换为微小值 $10^{-12}$，并将对称的非对角元素 $(1,2)$ 和 $(2,1)$ 设置为 $1$，来进一步修改单个指定的对角块索引 $j$，所有其他元素保持不变。这会创建一个局部病态的 $3\\times 3$ 块，同时保持全局系统的可解性。\n- 对于每个 $i \\in \\{1,\\dots,n\\}$，抽取一个具有独立标准正态分布元素的 $\\mathbf{d}_i \\in \\mathbb{R}^{3}$。\n\n测试套件。精确实现以下四个测试：\n\n- 测试 $\\mathbf{T1}$：$n=1$，$\\alpha=5$，$\\beta=0.2$，种子 $=7$，无病态条件修改。\n- 测试 $\\mathbf{T2}$：$n=8$，$\\alpha=10$，$\\beta=0.1$，种子 $=11$，无病态条件修改。\n- 测试 $\\mathbf{T3}$：$n=12$，$\\alpha=1$，$\\beta=0.05$，种子 $=13$，在索引 $j=\\lfloor n/2 \\rfloor$ 处应用病态条件修改。\n- 测试 $\\mathbf{T4}$：$n=50$，$\\alpha=3$，$\\beta=0.05$，种子 $=2$，无病态条件修改。\n\n所有量都是无量纲的，因此不需要物理单位。\n\n算法要求。\n\n- 从 Gaussian elimination 和块 Schur complements 推导出您的块 Thomas 前向消元和回代。您不能组装或使用问题陈述中任何简化此推导的公式；您的实现必须基于消元原理本身。\n- 通过将主元选择（如有）限制在块内 $3\\times 3$ 操作中，确保策略 $\\mathsf{NP}$ 和 $\\mathsf{LU}$ 都在 $\\mathcal{O}(n)$ 时间内运行。不允许跨越不同 $i$ 的块重排。\n\n参考计算。对于每个测试，组装完整的稠密 $3n\\times 3n$ 矩阵，并用稠密直接求解器求解，以获得参考解 $\\mathbf{x}^\\star$。\n\n输出规范。您的程序必须生成一行输出，其中包含两种策略在所有四个测试中的相对误差，顺序如下：\n$$\n[\\;e_{\\mathrm{rel}}(\\mathsf{NP},\\mathbf{T1}),\\;e_{\\mathrm{rel}}(\\mathsf{LU},\\mathbf{T1}),\\;e_{\\mathrm{rel}}(\\mathsf{NP},\\mathbf{T2}),\\;e_{\\mathrm{rel}}(\\mathsf{LU},\\mathbf{T2}),\\;e_{\\mathrm{rel}}(\\mathsf{NP},\\mathbf{T3}),\\;e_{\\mathrm{rel}}(\\mathsf{LU},\\mathbf{T3}),\\;e_{\\mathrm{rel}}(\\mathsf{NP},\\mathbf{T4}),\\;e_{\\mathrm{rel}}(\\mathsf{LU},\\mathbf{T4})\\;].\n$$\n输出必须以 Python 列表字面量的形式打印在一行上，其条目使用十进制表示法，不含任何额外文本。\n\n您的程序必须是完整且可直接运行的，不得读取任何输入，并且只能使用标准库和指定的数值库。最终答案是实数，因此应表示为不带任何单位和百分号的十进制浮点数。",
            "solution": "该问题是有效的。它在数值线性代数领域具有科学依据，特别是在计算物理和工程中常见的块三对角系统的求解。问题设定是适定的，所有参数、构造规则和测试用例都已明确无误地指定。对角占优的构造确保了生成的系统是非奇异的。该问题是客观且可验证的。\n\n任务是实现并比较块 Thomas 算法的两种策略，该算法是用于块三对角系统的专用直接求解器。推导必须源于 Gaussian elimination 的基本原理，该原理可以通过块分解和 Schur complements 优雅地表达。\n\n给定一个如下形式的线性系统：\n$$\n\\mathbf{C}_i \\mathbf{x}_{i-1} + \\mathbf{A}_i \\mathbf{x}_i + \\mathbf{B}_i \\mathbf{x}_{i+1} = \\mathbf{d}_i, \\quad i=1, \\dots, n\n$$\n边界条件为 $\\mathbf{C}_1 = \\mathbf{0}$ 和 $\\mathbf{B}_n = \\mathbf{0}$。每个 $\\mathbf{A}_i, \\mathbf{B}_i, \\mathbf{C}_i$ 是一个 $3 \\times 3$ 的矩阵块，而 $\\mathbf{x}_i, \\mathbf{d}_i$ 是 $3 \\times 1$ 的向量。写成矩阵形式为 $\\mathbf{M}\\mathbf{x}=\\mathbf{d}$，其中 $\\mathbf{M}$ 是一个块三对角矩阵：\n$$\n\\mathbf{M} = \\begin{pmatrix}\n\\mathbf{A}_1  \\mathbf{B}_1    \\mathbf{0} \\\\\n\\mathbf{C}_2  \\mathbf{A}_2  \\mathbf{B}_2   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  \\mathbf{C}_{n-1}  \\mathbf{A}_{n-1}  \\mathbf{B}_{n-1} \\\\\n\\mathbf{0}    \\mathbf{C}_n  \\mathbf{A}_n\n\\end{pmatrix}\n$$\n\n块 Thomas 算法是块 Gaussian elimination（或块 LDU 分解）的直接应用。其核心思想是执行一次前向消元扫描，将系统转换为块上双对角形式，然后通过一次回代扫描求得解。\n\n**1. 通过 Schur Complements 进行前向消元**\n\n系统的第一个块行为 $\\mathbf{A}_1 \\mathbf{x}_1 + \\mathbf{B}_1 \\mathbf{x}_2 = \\mathbf{d}_1$。第一个消元步骤的目标是通过将第一个块行左乘 $\\mathbf{C}_2 \\mathbf{A}_1^{-1}$ 并从第二个块行中减去，来消除第二行中的 $\\mathbf{C}_2$ 块。此操作变换了系统：\n- 第二个块方程 $\\mathbf{C}_2 \\mathbf{x}_1 + \\mathbf{A}_2 \\mathbf{x}_2 + \\mathbf{B}_2 \\mathbf{x}_3 = \\mathbf{d}_2$ 变为：\n$$\n\\left(\\mathbf{A}_2 - \\mathbf{C}_2 \\mathbf{A}_1^{-1} \\mathbf{B}_1\\right) \\mathbf{x}_2 + \\mathbf{B}_2 \\mathbf{x}_3 = \\mathbf{d}_2 - \\mathbf{C}_2 \\mathbf{A}_1^{-1} \\mathbf{d}_1\n$$\n新的对角块 $\\mathbf{A}'_2 = \\mathbf{A}_2 - \\mathbf{C}_2 \\mathbf{A}_1^{-1} \\mathbf{B}_1$ 是 $\\mathbf{A}_1$ 在前导 $2 \\times 2$ 块子矩阵中的 Schur complement。右端项也相应更新：$\\mathbf{d}'_2 = \\mathbf{d}_2 - \\mathbf{C}_2 \\mathbf{A}_1^{-1} \\mathbf{d}_1$。\n\n这个过程迭代进行。在第 $i$ 步（$i = 2, \\dots, n$），我们假设第 $(i-1)$ 个方程已被转换为 $\\mathbf{A}'_{i-1} \\mathbf{x}_{i-1} + \\mathbf{B}_{i-1} \\mathbf{x}_i = \\mathbf{d}'_{i-1}$。我们用它来从第 $i$ 个方程中消去 $\\mathbf{C}_i$。这为修改后的块 $\\mathbf{A}'_i$ 和 $\\mathbf{d}'_i$ 产生了一个通用的递推关系：\n$$\n\\mathbf{A}'_i = \\mathbf{A}_i - \\mathbf{C}_i (\\mathbf{A}'_{i-1})^{-1} \\mathbf{B}_{i-1}\n$$\n$$\n\\mathbf{d}'_i = \\mathbf{d}_i - \\mathbf{C}_i (\\mathbf{A}'_{i-1})^{-1} \\mathbf{d}'_{i-1}\n$$\n初始条件为 $\\mathbf{A}'_1 = \\mathbf{A}_1$ 和 $\\mathbf{d}'_1 = \\mathbf{d}_1$。在数值计算中，我们避免计算矩阵的逆，而是求解线性方程组。\n定义中间矩阵 $\\mathbf{P}_i$ 和向量 $\\mathbf{q}_i$ 会更高效：\n$$\n\\mathbf{P}_{i-1} = (\\mathbf{A}'_{i-1})^{-1} \\mathbf{B}_{i-1} \\quad \\text{和} \\quad \\mathbf{q}_{i-1} = (\\mathbf{A}'_{i-1})^{-1} \\mathbf{d}'_{i-1}\n$$\n代入这些定义，递推关系变为：\n$$\n\\mathbf{A}'_i = \\mathbf{A}_i - \\mathbf{C}_i \\mathbf{P}_{i-1}\n$$\n$$\n\\mathbf{d}'_i = \\mathbf{d}_i - \\mathbf{C}_i \\mathbf{q}_{i-1}\n$$\n然后我们计算下一个 $\\mathbf{P}_i$ 和 $\\mathbf{q}_i$：\n$$\n\\mathbf{P}_i = (\\mathbf{A}'_i)^{-1} \\mathbf{B}_i \\quad \\text{对于 } i  n\n$$\n$$\n\\mathbf{q}_i = (\\mathbf{A}'_i)^{-1} \\mathbf{d}'_i\n$$\n这个前向扫描从 $i=1$ 到 $n$ 进行，计算并存储所有的 $\\mathbf{P}_i$（对于 $i=1, \\dots, n-1$）和 $\\mathbf{q}_i$（对于 $i=1, \\dots, n$）。\n\n**2. 回代**\n\n前向消元后，原始系统等价于一个块上双对角系统：\n$$\n\\mathbf{A}'_i \\mathbf{x}_i + \\mathbf{B}_i \\mathbf{x}_{i+1} = \\mathbf{d}'_i, \\quad i=1, \\dots, n-1\n$$\n$$\n\\mathbf{A}'_n \\mathbf{x}_n = \\mathbf{d}'_n\n$$\n从最后一个方程，我们可以直接解出 $\\mathbf{x}_n$：\n$$\n\\mathbf{x}_n = (\\mathbf{A}'_n)^{-1} \\mathbf{d}'_n = \\mathbf{q}_n\n$$\n剩余的未知数可以通过重新排列其他方程并从 $i=n-1$ 向下回代到 $1$ 来找到：\n$$\n\\mathbf{x}_i = (\\mathbf{A}'_i)^{-1} (\\mathbf{d}'_i - \\mathbf{B}_i \\mathbf{x}_{i+1}) = \\mathbf{q}_i - \\mathbf{P}_i \\mathbf{x}_{i+1}\n$$\n这构成了回代扫描。\n\n**3. 实现策略与复杂度**\n\n每一步的核心计算任务是 $3 \\times 3$ 矩阵-矩阵乘法和求解 $3 \\times 3$ 线性系统。这些操作的复杂度是常数，即 $\\mathcal{O}(3^3) = \\mathcal{O}(1)$。由于前向和后向扫描迭代 $n$ 次，块 Thomas 算法的总体复杂度是 $\\mathcal{O}(n)$，这相对于通用稠密求解器的 $\\mathcal{O}(n^3)$ 复杂度是一个显著的改进。\n\n求解 $3 \\times 3$ 系统需要两种策略：\n- **策略 $\\mathsf{LU}$ (带主元选择的 LU 分解):** 该策略采用标准的、高质量的数值库例程（例如 `numpy.linalg.solve`）。这类例程通常实现带部分行主元选择的 LU 分解，以确保数值稳定性，特别是在主元元素接近于零时。主元选择被限制在每个 $3 \\times 3$ 块内部，从而保留了全局的块三对角结构和 $\\mathcal{O}(n)$ 复杂度。\n\n- **策略 $\\mathsf{NP}$ (无主元选择):** 该策略使用一个不进行任何行交换的 Gaussian elimination 的自定义实现。对于一个系统 $\\mathbf{M}\\mathbf{y}=\\mathbf{z}$，它通过前向消元创建一个上三角系统，然后进行回代。为防止除以零，当对角主元的绝对值小于 $\\varepsilon = 10^{-15}$ 时，会加上一个小的正常数 $\\varepsilon$。这种形式的静态阻尼是一种简单的正则化方法，但如果遇到并非纯粹由奇异性导致的小主元，它在数值上可能不稳定，正如病态条件测试用例所展示的那样。\n\n提供的程序实现了这一逻辑。它首先构建指定的测试系统，然后通过推导出的块 Thomas 算法，使用 $\\mathsf{NP}$ 和 $\\mathsf{LU}$ 两种策略分别求解。通过组装并求解完整的 $3n \\times 3n$ 矩阵来计算一个高精度的参考解。最后，计算每种情况下的相对 $\\ell_2$ 误差并报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to construct, solve, and evaluate the block tridiagonal systems.\n    \"\"\"\n    \n    # Epsilon for static damping in No-Pivoting strategy\n    EPS = 1e-15\n\n    def solve_3x3_np(M, z):\n        \"\"\"\n        Solves a 3x3 linear system Mx=z using Gaussian elimination without pivoting.\n        A small positive constant EPS is added to small pivots to avoid division by zero.\n        M is a 3x3 matrix.\n        z can be a 3-element vector or a 3x3 matrix.\n        \"\"\"\n        M_aug = M.copy()\n        z_aug = z.copy()\n\n        is_vector = z_aug.ndim == 1\n        if is_vector:\n            z_aug = z_aug.reshape(-1, 1)\n\n        # Forward elimination\n        for i in range(3):\n            pivot = M_aug[i, i]\n            if abs(pivot)  EPS:\n                pivot += EPS if pivot >= 0 else -EPS\n            \n            M_aug[i, i+1:] /= pivot\n            z_aug[i, :] /= pivot\n            M_aug[i, i] = 1.0 # Not strictly necessary, but good practice\n            \n            for j in range(i + 1, 3):\n                factor = M_aug[j, i]\n                M_aug[j, i+1:] -= factor * M_aug[i, i+1:]\n                z_aug[j, :] -= factor * z_aug[i, :]\n\n        # Back substitution\n        x = np.zeros_like(z_aug)\n        for i in range(2, -1, -1):\n            x[i, :] = z_aug[i, :]\n            for j in range(i + 1, 3):\n                x[i, :] -= M_aug[i, j] * x[j, :]\n                \n        return x.flatten() if is_vector else x\n\n    def block_thomas_solver(As, Bs, Cs, ds, n, solve_3x3_func):\n        \"\"\"\n        Solves a block tridiagonal system using the block Thomas algorithm.\n        As, Bs, Cs are lists of 3x3 coefficient blocks.\n        ds is a list of 3x1 right-hand side blocks.\n        n is the number of blocks.\n        solve_3x3_func is the function to use for solving 3x3 systems.\n        \"\"\"\n        if n == 0:\n            return np.array([])\n        \n        # Allocate space for intermediate matrices and vectors\n        Ps = [np.zeros((3, 3)) for _ in range(n - 1)]\n        qs = [np.zeros(3) for _ in range(n)]\n        xs = [np.zeros(3) for _ in range(n)]\n\n        # Forward elimination sweep\n        # Handle i = 0 (first block row, 1-based index)\n        A_prime = As[0]\n        qs[0] = solve_3x3_func(A_prime, ds[0])\n        if n > 1:\n            Ps[0] = solve_3x3_func(A_prime, Bs[0])\n\n        # Handle i = 1 to n-1 (2 to n in 1-based index)\n        for i in range(1, n):\n            A_prime = As[i] - Cs[i] @ Ps[i-1]\n            d_prime = ds[i] - Cs[i] @ qs[i-1]\n            \n            qs[i] = solve_3x3_func(A_prime, d_prime)\n            if i  n - 1:\n                Ps[i] = solve_3x3_func(A_prime, Bs[i])\n\n        # Backward substitution sweep\n        xs[n-1] = qs[n-1]\n        for i in range(n - 2, -1, -1):\n            xs[i] = qs[i] - Ps[i] @ xs[i+1]\n        \n        return np.concatenate(xs)\n\n    def construct_system(n, alpha, beta, seed, ill_cond_j=None):\n        \"\"\"\n        Constructs the block tridiagonal system according to the problem specification.\n        ill_cond_j is the 0-based index for ill-conditioning.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        As = [None] * n\n        ds = [rng.standard_normal(size=3) for _ in range(n)]\n        \n        # Temp blocks for diagonal dominance calculation\n        A0s = [rng.standard_normal(size=(3, 3)) for _ in range(n)]\n        B0s = [np.zeros((3,3)) for _ in range(n)]\n        C0s = [np.zeros((3,3)) for _ in range(n)]\n\n        for i in range(n - 1): B0s[i] = beta * rng.standard_normal(size=(3, 3))\n        for i in range(1, n): C0s[i] = beta * rng.standard_normal(size=(3, 3))\n\n        # Enforce block diagonal dominance\n        for i in range(n):\n            norm_B = np.linalg.norm(B0s[i], ord=1) if i  n else 0\n            norm_C = np.linalg.norm(C0s[i], ord=1) if i > 0 else 0\n            As[i] = A0s[i] + (alpha + 1.1 * norm_B + 1.1 * norm_C) * np.eye(3)\n\n        Bs_final = B0s[:-1]\n        Cs_final = C0s # C_0 is all zeros anyway and not used.\n\n        # Apply ill-conditioning if specified\n        if ill_cond_j is not None and 0 = ill_cond_j  n:\n            As[ill_cond_j] = As[ill_cond_j].copy() # Avoid modifying original if needed later\n            As[ill_cond_j][0, 0] = 1e-12\n            As[ill_cond_j][0, 1] = 1.0\n            As[ill_cond_j][1, 0] = 1.0\n\n        return As, Bs_final, Cs_final, ds\n\n    def assemble_and_solve_reference(As, Bs, Cs, ds, n):\n        \"\"\"\n        Assembles the full 3n x 3n matrix and solves it to get a reference solution.\n        \"\"\"\n        if n == 0:\n            return np.array([])\n            \n        dim = 3 * n\n        M_full = np.zeros((dim, dim))\n        d_full = np.concatenate(ds)\n        \n        for i in range(n):\n            M_full[3*i:3*(i+1), 3*i:3*(i+1)] = As[i]\n            if i  n - 1:\n                M_full[3*i:3*(i+1), 3*(i+1):3*(i+2)] = Bs[i]\n            if i > 0:\n                M_full[3*i:3*(i+1), 3*(i-1):3*i] = Cs[i]\n\n        return np.linalg.solve(M_full, d_full)\n\n    # Define test cases: (n, alpha, beta, seed, ill_cond_j in 1-based indexing)\n    test_cases = [\n        (1, 5, 0.2, 7, None),\n        (8, 10, 0.1, 11, None),\n        (12, 1, 0.05, 13, 6), \n        (50, 3, 0.05, 2, None),\n    ]\n\n    results = []\n    for n, alpha, beta, seed, j_ill in test_cases:\n        ill_cond_idx = j_ill - 1 if j_ill is not None else None\n        \n        As, Bs, Cs, ds = construct_system(n, alpha, beta, seed, ill_cond_idx)\n\n        x_ref = assemble_and_solve_reference(As, Bs, Cs, ds, n)\n        norm_x_ref = np.linalg.norm(x_ref)\n        if norm_x_ref == 0: norm_x_ref = 1.0 # Avoid division by zero for null solution\n\n        # Strategy NP (No Pivoting)\n        x_np = block_thomas_solver(As, Bs, Cs, ds, n, solve_3x3_np)\n        error_np = np.linalg.norm(x_np - x_ref) / norm_x_ref\n        results.append(error_np)\n        \n        # Strategy LU (LU with Partial Pivoting)\n        x_lu = block_thomas_solver(As, Bs, Cs, ds, n, np.linalg.solve)\n        error_lu = np.linalg.norm(x_lu - x_ref) / norm_x_ref\n        results.append(error_lu)\n\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}