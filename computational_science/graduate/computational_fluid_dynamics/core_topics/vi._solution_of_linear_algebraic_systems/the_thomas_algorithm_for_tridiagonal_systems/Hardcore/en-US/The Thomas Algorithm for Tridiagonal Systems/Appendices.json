{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, we begin with a direct application of the Thomas algorithm to a small, well-defined system. This exercise is designed to develop procedural fluency by requiring a step-by-step execution of the forward elimination and backward substitution passes. By working through the mechanics manually, you will gain an intuitive grasp of how the algorithm transforms the system into an easily solvable form, which is essential before tackling more complex computational problems .",
            "id": "1030146",
            "problem": "Consider the tridiagonal system of equations:\n$$\n\\begin{cases}\n2x_1 - x_2 &= 3 \\\\\n-x_1 + 3x_2 - 2x_3 &= 1 \\\\\n-\\dfrac{1}{2}x_2 + 4x_3 - x_4 &= 0 \\\\\n-\\dfrac{3}{2}x_3 + 5x_4 &= 2\n\\end{cases}\n$$\nSolve this system using the Thomas algorithm and provide the value of $x_4$. The Thomas algorithm consists of a forward sweep to modify coefficients and a backward sweep to compute solutions starting from the last variable.",
            "solution": "The Thomas algorithm solves the tridiagonal system $A\\mathbf{x} = \\mathbf{d}$ by first performing an LU factorization $A=LU$ and then solving the two bidiagonal systems $L\\mathbf{y} = \\mathbf{d}$ (forward substitution) and $U\\mathbf{x} = \\mathbf{y}$ (backward substitution). The steps are combined for efficiency.\n\nThe system is defined by the diagonals:\n- Sub-diagonal $a = \\left\\{-1, -\\dfrac{1}{2}, -\\dfrac{3}{2}\\right\\}$\n- Main diagonal $b = \\{2, 3, 4, 5\\}$\n- Super-diagonal $c = \\{-1, -2, -1\\}$\n- Right-hand side vector $\\mathbf{d} = \\{3, 1, 0, 2\\}$\n\n**1. Forward Elimination and Substitution:**\nWe compute the diagonal of the upper triangular matrix, $\\tilde{b}$, and the modified right-hand side, $\\mathbf{y}$.\n\n- For $i=1$:\n  - $\\tilde{b}_1 = b_1 = 2$\n  - $y_1 = d_1 = 3$\n\n- For $i=2$:\n  - The multiplier is $l_2 = a_2 / \\tilde{b}_1 = -1 / 2 = -\\dfrac{1}{2}$.\n  - The new diagonal element is $\\tilde{b}_2 = b_2 - l_2 \\cdot c_1 = 3 - \\left(-\\dfrac{1}{2}\\right)(-1) = 3 - \\dfrac{1}{2} = \\dfrac{5}{2}$.\n  - The new RHS element is $y_2 = d_2 - l_2 \\cdot y_1 = 1 - \\left(-\\dfrac{1}{2}\\right)(3) = 1 + \\dfrac{3}{2} = \\dfrac{5}{2}$.\n\n- For $i=3$:\n  - The multiplier is $l_3 = a_3 / \\tilde{b}_2 = (-\\dfrac{1}{2}) / (\\dfrac{5}{2}) = -\\dfrac{1}{5}$.\n  - The new diagonal element is $\\tilde{b}_3 = b_3 - l_3 \\cdot c_2 = 4 - \\left(-\\dfrac{1}{5}\\right)(-2) = 4 - \\dfrac{2}{5} = \\dfrac{18}{5}$.\n  - The new RHS element is $y_3 = d_3 - l_3 \\cdot y_2 = 0 - \\left(-\\dfrac{1}{5}\\right)\\left(\\dfrac{5}{2}\\right) = \\dfrac{1}{2}$.\n\n- For $i=4$:\n  - The multiplier is $l_4 = a_4 / \\tilde{b}_3 = (-\\dfrac{3}{2}) / (\\dfrac{18}{5}) = -\\dfrac{3}{2} \\cdot \\dfrac{5}{18} = -\\dfrac{5}{12}$.\n  - The new diagonal element is $\\tilde{b}_4 = b_4 - l_4 \\cdot c_3 = 5 - \\left(-\\dfrac{5}{12}\\right)(-1) = 5 - \\dfrac{5}{12} = \\dfrac{55}{12}$.\n  - The new RHS element is $y_4 = d_4 - l_4 \\cdot y_3 = 2 - \\left(-\\dfrac{5}{12}\\right)\\left(\\dfrac{1}{2}\\right) = 2 + \\dfrac{5}{24} = \\dfrac{53}{24}$.\n\nThe transformed upper triangular system $U\\mathbf{x} = \\mathbf{y}$ is:\n$$\n\\begin{pmatrix}\n2 & -1 & 0 & 0 \\\\\n0 & 5/2 & -2 & 0 \\\\\n0 & 0 & 18/5 & -1 \\\\\n0 & 0 & 0 & 55/12\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\ x_2 \\\\ x_3 \\\\ x_4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n3 \\\\ 5/2 \\\\ 1/2 \\\\ 53/24\n\\end{pmatrix}\n$$\n\n**2. Backward Substitution:**\nWe solve for $\\mathbf{x}$ starting from the last variable.\n\n- For $x_4$:\n  - $x_4 = y_4 / \\tilde{b}_4 = \\left(\\dfrac{53}{24}\\right) / \\left(\\dfrac{55}{12}\\right) = \\dfrac{53}{24} \\cdot \\dfrac{12}{55} = \\dfrac{53}{2 \\cdot 55} = \\dfrac{53}{110}$\n\nThe problem only asks for $x_4$.\n\nThus, $x_4 = \\dfrac{53}{110}$.",
            "answer": "$$ \\boxed{\\dfrac{53}{110}} $$"
        },
        {
            "introduction": "Moving beyond pure mechanics, this problem explores the crucial interplay between a numerical solver and the physical model it represents. Here, you will use the Thomas algorithm to solve a system arising from the discretization of a convection-diffusion equation, a fundamental problem in fluid dynamics. The exercise is designed to reveal a critical concept: even when a linear system is solved exactly, the resulting solution can be physically unrealistic if the underlying discretization scheme (in this case, central differencing) fails to preserve important mathematical properties of the continuous operator, such as monotonicity . This practice underscores the fact that the quality of a simulation depends just as much on the discretization as on the algebraic solver.",
            "id": "3383308",
            "problem": "Consider steady one-dimensional transport of a passive scalar $\\,\\phi(x)\\,$ governed by the conservation law with constant properties,\n$$ \\frac{d}{dx}\\Big(\\Gamma \\frac{d\\phi}{dx}\\Big) - \\rho v \\frac{d\\phi}{dx} = 0, $$\non the interval $\\,x \\in [0,L]\\,$ with Dirichlet boundary conditions $\\,\\phi(0)=1\\,$ and $\\,\\phi(L)=0\\,$. Let the domain length be $\\,L=1\\,$ and discretize it into $\\,N=4\\,$ interior control volumes of uniform width $\\,\\Delta x = L/(N+1)\\,$ on a uniform grid with unit cross-sectional area $\\,A=1\\,$. Use central differencing for the convective and diffusive fluxes at the cell faces in a cell-centered finite volume formulation to obtain a tridiagonal linear system for the interior nodal values $\\,\\{\\phi_i\\}_{i=1}^{N}\\,$.\n\nTake constant positive flow $\\,v>0\\,$ and constants $\\,\\Gamma=0.2\\,$ and $\\,\\rho v = 4\\,$ so that the face mass flux is $\\,F=\\rho v\\,$ and the diffusive conductance is $\\,D=\\Gamma/\\Delta x\\,$. Assemble the tridiagonal system in the coefficient form\n$$ a_i\\,\\phi_{i-1} + b_i\\,\\phi_i + c_i\\,\\phi_{i+1} = d_i, \\quad i=1,\\dots,N, $$\nwith the boundary values incorporated into the right-hand side where needed. Then, solve this tridiagonal system exactly using the Thomas algorithm to obtain the discrete solution. In the process, explicitly identify the central-differencing coefficients $\\,a_W\\,$ and $\\,a_E\\,$ at a generic interior node and determine whether the resulting off-diagonal entries in the system matrix satisfy the nonpositivity requirement of a nonsingular $\\,M$-matrix. Conclude whether the discrete solution is monotone between the boundary values.\n\nWhat is the computed value of the interior nodal unknown $\\,\\phi_3\\,$? Express your answer as a dimensionless number rounded to four significant figures.",
            "solution": "We start from the steady one-dimensional convection–diffusion balance with constant properties,\n$$ \\frac{d}{dx}\\Big(\\Gamma \\frac{d\\phi}{dx}\\Big) - \\rho v \\frac{d\\phi}{dx} = 0, $$\nand apply a cell-centered finite volume method on $\\,x\\in[0,L]\\,$ with $\\,L=1\\,$, $\\,N=4\\,$ interior cells, and uniform spacing $\\,\\Delta x = L/(N+1) = 1/5 = 0.2\\,$. The cross-sectional area is $\\,A=1\\,$, the diffusivity is $\\,\\Gamma=0.2\\,$, and the mass flux is $\\,F=\\rho v = 4\\,$. The diffusive conductance per face is\n$$ D \\equiv \\frac{\\Gamma}{\\Delta x} = \\frac{0.2}{0.2} = 1. $$\n\nUsing central differencing for both convection and diffusion, the finite volume balance for an interior node $P$ is $a_P\\,\\phi_P = a_W\\,\\phi_W + a_E\\,\\phi_E$, with coefficients for positive flow ($v>0$):\n$$ a_W = D + \\frac{F}{2} = 1 + \\frac{4}{2} = 3, \\qquad a_E = D - \\frac{F}{2} = 1 - \\frac{4}{2} = -1, \\qquad a_P = a_W + a_E = 3 - 1 = 2. $$\nThe standard form $a_i \\phi_{i-1} + b_i \\phi_i + c_i \\phi_{i+1} = d_i$ is constructed from $a_P\\,\\phi_i - a_W\\,\\phi_{i-1} - a_E\\,\\phi_{i+1} = 0$. This gives diagonal $b_i = a_P = 2$, sub-diagonal $a_i = -a_W = -3$, and super-diagonal $c_i = -a_E = 1$. The boundary conditions $\\phi_0=1$ and $\\phi_5=0$ are incorporated into the right-hand side $d_i$.\n- For $i=1$: $b_1 \\phi_1 + c_1 \\phi_2 = d_1$, where $d_1 = a_W \\phi_0 = 3 \\cdot 1 = 3$.\n- For $i=4$: $a_4 \\phi_3 + b_4 \\phi_4 = d_4$, where $d_4 = a_E \\phi_5 = (-1) \\cdot 0 = 0$.\n\nThe super-diagonal entries $c_i = -a_E = 1$ are positive. This violates the non-positivity requirement for off-diagonal elements of an $M$-matrix, which is expected since the cell Péclet number $Pe = F/D = 4/1 = 4 > 2$. This indicates a potential for non-monotone solutions.\n\nWe solve the system using the Thomas algorithm (LU factorization method). The system is defined by:\n- $a = \\{-3, -3, -3\\}$\n- $b = \\{2, 2, 2, 2\\}$\n- $c = \\{1, 1, 1\\}$\n- $d = \\{3, 0, 0, 0\\}$\n\n**1. Forward Elimination and Substitution:**\n- For $i=1$: $\\tilde{b}_1 = b_1 = 2$. $y_1 = d_1 = 3$.\n- For $i=2$: $l_2 = a_2/\\tilde{b}_1 = -3/2$.\n  $\\tilde{b}_2 = b_2 - l_2 c_1 = 2 - (-3/2)(1) = 7/2$.\n  $y_2 = d_2 - l_2 y_1 = 0 - (-3/2)(3) = 9/2$.\n- For $i=3$: $l_3 = a_3/\\tilde{b}_2 = -3/(7/2) = -6/7$.\n  $\\tilde{b}_3 = b_3 - l_3 c_2 = 2 - (-6/7)(1) = 20/7$.\n  $y_3 = d_3 - l_3 y_2 = 0 - (-6/7)(9/2) = 27/7$.\n- For $i=4$: $l_4 = a_4/\\tilde{b}_3 = -3/(20/7) = -21/20$.\n  $\\tilde{b}_4 = b_4 - l_4 c_3 = 2 - (-21/20)(1) = 61/20$.\n  $y_4 = d_4 - l_4 y_3 = 0 - (-21/20)(27/7) = 81/20$.\n\n**2. Backward Substitution:**\n- For $\\phi_4$: $\\phi_4 = y_4 / \\tilde{b}_4 = (81/20) / (61/20) = 81/61$.\n- For $\\phi_3$: $\\phi_3 = (y_3 - c_3 \\phi_4) / \\tilde{b}_3 = (27/7 - 1 \\cdot 81/61) / (20/7) = \\frac{(1647-567)/427}{20/7} = \\frac{1080/427}{20/7} = \\frac{1080}{427} \\cdot \\frac{7}{20} = \\frac{54}{61}$.\n\nThe solution profile $\\{\\phi_1, \\phi_2, \\phi_3, \\phi_4\\}$ is $\\{60/61, 63/61, 54/61, 81/61\\}$. The solution is non-monotone, with values exceeding the boundary maximum of 1, as predicted by the M-matrix criterion violation.\n\nThe value of $\\phi_3$ is:\n$$ \\phi_3 = \\frac{54}{61} \\approx 0.8852459... $$\nRounded to four significant figures, the result is $0.8852$.",
            "answer": "$$\\boxed{0.8852}$$"
        },
        {
            "introduction": "The primary motivation for using the Thomas algorithm is its exceptional efficiency. This hands-on coding exercise provides a powerful, quantitative comparison between the specialized Thomas algorithm and a general-purpose LU factorization solver. By implementing both methods and applying them to a system derived from the one-dimensional diffusion equation, you will directly observe the dramatic difference in computational cost, which scales as $O(n)$ for the Thomas algorithm versus $O(n^3)$ for a dense solver . This practice solidifies why specialized sparse solvers are indispensable tools in computational science, particularly for the large systems encountered in CFD.",
            "id": "3383321",
            "problem": "Consider the one-dimensional steady diffusion equation, a canonical model in Computational Fluid Dynamics (CFD), given by $-\\dfrac{d^2 u}{dx^2} = f(x)$ on the unit interval $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Using a uniform grid with $n$ interior nodes, grid spacing $h = \\dfrac{1}{n+1}$, and the second-order central difference approximation for the second derivative, one arrives at a linear system $A \\mathbf{u} = \\mathbf{b}$ where $A$ is tridiagonal with entries $-1$ on the sub- and super-diagonals and $2$ on the main diagonal. Explicitly, $A \\in \\mathbb{R}^{n \\times n}$ has $a_i = -1$ for $i = 2,\\dots,n$, $b_i = 2$ for $i = 1,\\dots,n$, and $c_i = -1$ for $i = 1,\\dots,n-1$, so that $A$ is the Toeplitz tridiagonal matrix corresponding to this discretization.\n\nFrom the perspective of numerical linear algebra, there are two classical ways to solve $A \\mathbf{x} = \\mathbf{b}$ in this setting:\n- The Thomas algorithm (tridiagonal Gaussian elimination without pivoting), which exploits the tridiagonal structure.\n- A general-purpose dense solver based on Lower-Upper (LU) factorization with partial pivoting, which ignores sparsity and treats $A$ as a dense matrix.\n\nStarting only from the discretization described above, implement both solvers and compare their numerical accuracy and computational cost on the same tridiagonal system. Construct a synthetic right-hand side guaranteeing a known exact solution as follows: For a given $n$, define the exact vector $\\mathbf{x}^{\\star} \\in \\mathbb{R}^n$ by $x_i^{\\star} = \\sin\\!\\left(\\pi \\dfrac{i}{n+1}\\right)$ for $i = 1,\\dots,n$. Then set $\\mathbf{b} = A \\mathbf{x}^{\\star}$. For each solver, compute:\n- The relative $2$-norm error $e = \\dfrac{\\lVert \\mathbf{x} - \\mathbf{x}^{\\star} \\rVert_2}{\\lVert \\mathbf{x}^{\\star} \\rVert_2}$,\n- The $2$-norm residual $r = \\lVert \\mathbf{b} - A \\mathbf{x} \\rVert_2$.\n\nFor computational cost, report operation counts as follows:\n- For the Thomas algorithm, use the exact count $F_{\\mathrm{T}}(n) = 8n - 7$, obtained by counting each addition, subtraction, multiplication, and division as one floating-point operation.\n- For the dense LU solver with partial pivoting, use the standard dense estimate $F_{\\mathrm{LU}}(n) = \\dfrac{2}{3} n^3 + 2 n^2$, covering factorization plus forward and backward substitution.\n\nYour implementation must be a complete, runnable program that:\n- Constructs $A$ and $\\mathbf{b}$ from the above specification for each test case,\n- Solves the system by both methods,\n- Computes the prescribed accuracy metrics and cost estimates,\n- Produces output in the specified format.\n\nTest suite:\n- Use the following set of interior-node counts $n$ to test different regimes and edge cases: $n \\in \\{\\,1,\\,2,\\,50,\\,400\\,\\}$.\n\nQuantifiable answers:\n- For each test case $n$, produce a list of six floats: $[e_{\\mathrm{T}}, e_{\\mathrm{LU}}, r_{\\mathrm{T}}, r_{\\mathrm{LU}}, F_{\\mathrm{T}}(n), F_{\\mathrm{LU}}(n)]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item is the list corresponding to one test case in the order $n = 1$, $n = 2$, $n = 50$, $n = 400$. For example: $[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$.\n- All reported quantities are dimensionless real numbers (no physical units). Angles are not used, and no percentages are required; any ratios must be provided as real numbers.",
            "solution": "The Python code provided in the answer implements a numerical experiment to compare the Thomas algorithm with a general-purpose dense LU solver. The script performs the following steps for each specified problem size `n`:\n\n1.  **System Construction**: It builds the tridiagonal matrix `A` using `numpy.diag`. The exact solution vector `x_star` is created using the specified sine function, a technique known as the Method of Manufactured Solutions. The right-hand side vector `b` is then computed by multiplying `A` and `x_star`, ensuring that `x_star` is the true solution to the system `A @ x = b`.\n\n2.  **Thomas Algorithm Implementation**: A function `thomas_solver` is defined to solve the tridiagonal system. It takes the three diagonals and the right-hand side vector as input. It implements a standard forward elimination pass to compute modified coefficients, followed by a backward substitution pass to find the solution vector `x`. This implementation correctly exploits the sparse structure of the matrix for an efficient $O(n)$ solution.\n\n3.  **Solvers Execution**:\n    *   The custom `thomas_solver` function is called to compute the solution `x_T`.\n    *   SciPy's `scipy.linalg.solve` function, a highly optimized general-purpose solver typically based on LU factorization with pivoting, is used to compute the solution `x_LU` by treating `A` as a dense matrix.\n\n4.  **Metrics Calculation**:\n    *   For both solutions (`x_T` and `x_LU`), the script calculates the relative 2-norm error against the known exact solution `x_star`. This measures the accuracy of each method.\n    *   It also computes the 2-norm of the residual `b - A @ x` for both solutions. This measures how well each solution satisfies the original linear equation.\n    *   The theoretical floating-point operation counts for both algorithms are calculated using the formulas provided in the problem statement.\n\n5.  **Output Generation**: The script gathers the six computed metrics (two errors, two residuals, two costs) for each value of `n` and formats the final results as a nested list, printed to a single line as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as dense_solve\n\ndef thomas_solver(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system Ax = d.\n    'a' is the sub-diagonal (n-1 elements), 'b' is the main diagonal (n elements),\n    'c' is the super-diagonal (n-1 elements), 'd' is the RHS vector (n elements).\n    The problem statement uses 1-based indexing for math notation, but here we\n    use 0-based indexing standard in programming.\n    a: sub-diagonal, a[i] is A[i+1, i]\n    b: main-diagonal, b[i] is A[i, i]\n    c: super-diagonal, c[i] is A[i, i+1]\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create modifiable copies of the super-diagonal and RHS vector\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    \n    for i in range(1, n - 1):\n        denominator = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denominator\n\n    denominator = b[n - 1] - a[n - 2] * c_prime[n - 2]\n    d_prime[n - 1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / denominator\n    \n    # Backward substitution\n    x = np.zeros(n)\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n        \n    return x\n\ndef solve():\n    \"\"\"\n    Main function to run the comparison for the test suite.\n    \"\"\"\n    test_cases = [1, 2, 50, 400]\n    results = []\n\n    for n in test_cases:\n        # Step 1: Construct the linear system A x = b with a known solution x_star\n        \n        # Define the matrix A as a dense matrix for the LU solver and for calculating residuals\n        if n == 1:\n            A = np.array([[2.0]])\n        else:\n            main_diag_vals = np.full(n, 2.0)\n            sub_diag_vals = np.full(n - 1, -1.0)\n            sup_diag_vals = np.full(n - 1, -1.0)\n            A = np.diag(main_diag_vals) + np.diag(sup_diag_vals, k=1) + np.diag(sub_diag_vals, k=-1)\n        \n        # Define the exact solution vector x_star\n        i = np.arange(1, n + 1)\n        x_star = np.sin(np.pi * i / (n + 1))\n        \n        # Compute the right-hand side vector b = A * x_star\n        b = A @ x_star\n        \n        # Step 2: Solve the system using both methods\n        \n        # Method 1: Thomas Algorithm\n        if n > 1:\n            x_T = thomas_solver(sub_diag_vals, main_diag_vals, sup_diag_vals, b)\n        else: # Handle n=1 case for Thomas algorithm\n            x_T = thomas_solver(np.array([]), np.array([2.0]), np.array([]), b)\n\n        # Method 2: Dense LU solver with partial pivoting\n        x_LU = dense_solve(A, b)\n        \n        # Step 3: Compute accuracy metrics and computational costs\n        \n        # Relative 2-norm error\n        norm_x_star = np.linalg.norm(x_star)\n        e_T = np.linalg.norm(x_T - x_star) / norm_x_star\n        e_LU = np.linalg.norm(x_LU - x_star) / norm_x_star\n        \n        # 2-norm residual\n        r_T = np.linalg.norm(b - A @ x_T)\n        r_LU = np.linalg.norm(b - A @ x_LU)\n        \n        # Computational cost estimates\n        F_T = float(8 * n - 7)\n        F_LU = (2.0 / 3.0) * n**3 + 2.0 * n**2\n        \n        # Store the results for this test case\n        results.append([e_T, e_LU, r_T, r_LU, F_T, F_LU])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}