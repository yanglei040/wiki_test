{
    "hands_on_practices": [
        {
            "introduction": "要真正理解数值格式的缺陷，没有什么比通过实践来验证其理论上的弱点更有效的方法了。本练习采用“制造解方法”(Method of Manufactured Solutions, MMS)，这是一个用于代码验证和算子行为分析的强大工具。通过将两种不同的离散格式应用于一个纯粹的棋盘格压力场，你将亲眼看到不稳定的同位网格格式为何会对此模式“失明”，而Rhie–Chow类型的稳定格式又是如何修正这一根本性缺陷的 。",
            "id": "3354196",
            "problem": "考虑一个在方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维不可压缩稳态流，边界条件为周期性边界条件。该流场在一个均匀的、同位（collocated）的笛卡尔网格上进行离散，该网格包含 $N \\times N$ 个控制体，大小为 $\\Delta x = \\Delta y = 1/N$。目标是使用制造解验证法（MMS）检验同位网格上的压力-速度解耦和棋盘格现象，并量化在使用和不使用稳定化的情况下由压力梯度形成面速度时离散散度的行为。\n\n基本原理：\n- 不可压缩流的质量守恒要求 $\\nabla \\cdot \\mathbf{u} = 0$。\n- 在有限体积法（FVM）的同位网格上，单元 $(i,j)$ 处的离散连续性残差定义为\n$$\nR_{i,j} = \\frac{u_{e,i,j} - u_{w,i,j}}{\\Delta x} + \\frac{v_{n,i,j} - v_{s,i,j}}{\\Delta y},\n$$\n其中 $u_{e,i,j}$ 和 $u_{w,i,j}$ 分别是单元 $(i,j)$ 的东、西面速度，$v_{n,i,j}$ 和 $v_{s,i,j}$ 分别是单元 $(i,j)$ 的南、北面速度。周期性意味着索引是循环的：如果 $i = N-1$，则 $i+1$ 映射到 $0$；如果 $i = 0$，则 $i-1$ 映射到 $N-1$；$j$ 的情况类似。\n\n制造解：\n- 在单元中心 $(x_i, y_j) = \\left(\\frac{i+1/2}{N}, \\frac{j+1/2}{N}\\right)$ 定义两个制造压力场：\n  1. 一个光滑场：\n  $$\n  p(x_i, y_j) = \\sin(2\\pi x_i) \\sin(2\\pi y_j).\n  $$\n  2. 一个离散棋盘格场：\n  $$\n  p_{i,j} = (-1)^{i+j}.\n  $$\n- 在单元中心定义一个线性的、扩散主导的压力-速度响应，该响应在同位 FVM 下近似离散动量平衡，形式如下：\n$$\nu_{i,j} = -\\kappa_c \\left(\\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}\\right), \\quad v_{i,j} = -\\kappa_c \\left(\\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}\\right),\n$$\n其中 $\\kappa_c > 0$ 是一个无量纲柔度参数。这种代数封闭关系模拟了扩散主导离散化中压力到速度耦合的主导阶项。\n\n待研究的面速度形成格式：\n- 一种同位的中心插值格式，通过平均相邻单元中心速度来形成面速度：\n  - 东、西面：\n  $$\n  u_{e,i,j} = \\frac{u_{i,j} + u_{i+1,j}}{2}, \\quad u_{w,i,j} = \\frac{u_{i-1,j} + u_{i,j}}{2}.\n  $$\n  - 南、北面：\n  $$\n  v_{n,i,j} = \\frac{v_{i,j} + v_{i,j+1}}{2}, \\quad v_{s,i,j} = \\frac{v_{i,j-1} + v_{i,j}}{2}.\n  $$\n- 一种类 Rhie–Chow 稳定化面插值格式，通过一个与扩散主导离散化一致的压力差项来增强面速度：\n  - 东、西面：\n  $$\n  u_{e,i,j} = \\frac{u_{i,j} + u_{i+1,j}}{2} - \\kappa_f \\left[\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} - \\frac{1}{2}\\left(\\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x} + \\frac{p_{i+2,j} - p_{i,j}}{2\\Delta x}\\right)\\right],\n  $$\n  $$\n  u_{w,i,j} = \\frac{u_{i-1,j} + u_{i,j}}{2} - \\kappa_f \\left[\\frac{p_{i,j} - p_{i-1,j}}{\\Delta x} - \\frac{1}{2}\\left(\\frac{p_{i,j} - p_{i-2,j}}{2\\Delta x} + \\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}\\right)\\right],\n  $$\n  - 南、北面：\n  $$\n  v_{n,i,j} = \\frac{v_{i,j} + v_{i,j+1}}{2} - \\kappa_f \\left[\\frac{p_{i,j+1} - p_{i,j}}{\\Delta y} - \\frac{1}{2}\\left(\\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y} + \\frac{p_{i,j+2} - p_{i,j}}{2\\Delta y}\\right)\\right],\n  $$\n  $$\n  v_{s,i,j} = \\frac{v_{i,j-1} + v_{i,j}}{2} - \\kappa_f \\left[\\frac{p_{i,j} - p_{i,j-1}}{\\Delta y} - \\frac{1}{2}\\left(\\frac{p_{i,j} - p_{i,j-2}}{2\\Delta y} + \\frac{p_{i,j+1} - p_{i,j-1}}{2\\Delta y}\\right)\\right],\n  $$\n  其中所有索引都是周期性的，$\\kappa_f > 0$ 是一个无量纲稳定化参数。方括号中的项从面压力差中减去了插值得到的单元中心压力梯度，从而抑制压力-速度解耦。\n\n性能指标：\n- 对于每种配置，计算所有单元的离散连续性残差 $R_{i,j}$，并返回离散 $L^2$ 范数\n$$\n\\|R\\|_2 = \\left(\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} R_{i,j}^2\\right)^{1/2}.\n$$\n\n单位：\n- 所有量均为无量纲；以浮点数形式报告 $\\|R\\|_2$。\n\n测试套件：\n- 使用以下参数集 $(N, \\text{scheme}, \\text{pressure}, \\kappa_c, \\kappa_f)$：\n  1. $(16, \\text{central}, \\text{smooth}, 1.0, 1.0)$\n  2. $(16, \\text{stabilized}, \\text{smooth}, 1.0, 1.0)$\n  3. $(16, \\text{central}, \\text{checkerboard}, 1.0, 1.0)$\n  4. $(16, \\text{stabilized}, \\text{checkerboard}, 1.0, 1.0)$\n  5. $(5, \\text{stabilized}, \\text{checkerboard}, 1.0, 1.0)$\n  6. $(5, \\text{central}, \\text{checkerboard}, 1.0, 1.0)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），每个结果是对应于上述测试用例的 $\\|R\\|_2$ 值。不应打印其他文本。",
            "solution": "本问题的目标是分析和量化同位网格上压力-速度解耦的数值现象。这是通过对两种不同的压力场和两种不同的面速度插值格式使用制造解验证法（MMS）来完成的。性能指标是连续性残差的离散 $L^2$ 范数 $\\|R\\|_2$。\n\n其控制原理是不可压缩流的质量守恒，要求速度场的散度为零：$\\nabla \\cdot \\mathbf{u} = 0$。在同位网格的有限体积离散化中，这对每个控制体 $(i,j)$ 由离散连续性残差 $R_{i,j}$ 表示：\n$$\nR_{i,j} = \\frac{u_{e,i,j} - u_{w,i,j}}{\\Delta x} + \\frac{v_{n,i,j} - v_{s,i,j}}{\\Delta y}\n$$\n给定均匀方形网格，$\\Delta x = \\Delta y = h = 1/N$。因此，\n$$\nR_{i,j} = \\frac{1}{h} (u_{e,i,j} - u_{w,i,j} + v_{n,i,j} - v_{s,i,j})\n$$\n该过程涉及为所有单元 $(i,j)$ 计算 $R_{i,j}$，然后计算网格平均的 $L^2$ 范数：\n$$\n\\|R\\|_2 = \\left(\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} R_{i,j}^2\\right)^{1/2}\n$$\n计算分阶段进行：\n$1$. 在单元中心 $(x_i, y_j) = \\left(\\frac{i+1/2}{N}, \\frac{j+1/2}{N}\\right)$ 定义压力场 $p_{i,j}$。\n$2$. 单元中心的速度场 $(u_{i,j}, v_{i,j})$ 是根据压力场，使用所提供的代数模型计算得出的，该模型代表了压力驱动、扩散主导的流动：\n$$\nu_{i,j} = -\\kappa_c \\left(\\frac{p_{i+1,j} - p_{i-1,j}}{2h}\\right), \\quad v_{i,j} = -\\kappa_c \\left(\\frac{p_{i,j+1} - p_{i,j-1}}{2h}\\right)\n$$\n所有索引均按周期性处理。\n$3$. 面速度 ($u_{e,i,j}, u_{w,i,j}, v_{n,i,j}, v_{s,i,j}$) 根据单元中心的速度和压力，使用中心或稳定化插值格式计算得出。\n$4$. 使用面速度计算残差场 $R_{i,j}$，并由此确定最终的范数 $\\|R\\|_2$。\n\n让我们来分析这些格式的行为。\n\n**1. 中心插值格式**\n面速度通过对相邻单元中心速度进行简单平均获得：\n$$\nu_{e,i,j} = \\frac{u_{i,j} + u_{i+1,j}}{2}, \\quad u_{w,i,j} = \\frac{u_{i-1,j} + u_{i,j}}{2}\n$$\n单元 $(i,j)$ 的面速度差变为：\n$$\nu_{e,i,j} - u_{w,i,j} = \\frac{u_{i+1,j} - u_{i-1,j}}{2}\n$$\n$v$-速度也存在类似的表达式。将这些代入残差方程得到：\n$$\nR_{i,j} = \\frac{1}{2h} (u_{i+1,j} - u_{i-1,j} + v_{i,j+1} - v_{i,j-1})\n$$\n通过代入 $u_{i,j}$ 和 $v_{i,j}$ 的定义，我们纯粹用压力来表示残差：\n$$\nR_{i,j} = \\frac{1}{2h} \\left[ -\\frac{\\kappa_c}{2h}(p_{i+2,j} - p_{i,j}) + \\frac{\\kappa_c}{2h}(p_{i,j} - p_{i-2,j}) \\right] + \\frac{1}{2h} \\left[ -\\frac{\\kappa_c}{2h}(p_{i,j+2} - p_{i,j}) + \\frac{\\kappa_c}{2h}(p_{i,j} - p_{i,j-2}) \\right]\n$$\n$$\nR_{i,j} = -\\frac{\\kappa_c}{4h^2} (p_{i+2,j} + p_{i-2,j} + p_{i,j+2} + p_{i,j-2} - 4p_{i,j})\n$$\n这是一个宽模板离散拉普拉斯算子。现在，考虑棋盘格压力场 $p_{i,j} = (-1)^{i+j}$：\n$$\np_{i \\pm 2, j} = (-1)^{i \\pm 2 +j} = (-1)^{i+j} = p_{i,j} \\quad \\text{和} \\quad p_{i, j \\pm 2} = (-1)^{i + j \\pm 2} = (-1)^{i+j} = p_{i,j}\n$$\n因此，对于棋盘格场，残差为：\n$$\nR_{i,j} = -\\frac{\\kappa_c}{4h^2} (p_{i,j} + p_{i,j} + p_{i,j} + p_{i,j} - 4p_{i,j}) = 0\n$$\n对于这种高度振荡的、非物理的压力场，离散散度恒为零。这表明，同位网格上的中心差分格式的零空间包含最高频率模式，这是压力-速度解耦的根本原因。因此，对于中心格式和棋盘格压力，我们必须得到 $\\|R\\|_2 = 0$。\n\n**2. 稳定化的类 Rhie–Chow 插值格式**\n该格式在面速度计算中增加了一个稳定项。对于东面：\n$$\nu_{e,i,j} = \\underbrace{\\frac{u_{i,j} + u_{i+1,j}}{2}}_{\\text{中心部分}} - \\underbrace{\\kappa_f \\left[\\frac{p_{i+1,j} - p_{i,j}}{h} - \\frac{1}{2}\\left(\\frac{p_{i+1,j} - p_{i-1,j}}{2h} + \\frac{p_{i+2,j} - p_{i,j}}{2h}\\right)\\right]}_{\\text{稳定化部分}}\n$$\n现在的残差 $R_{i,j}$ 是中心格式的残差 $R_{i,j}^{\\text{central}}$ 与稳定项贡献的总和。对所有四个面的稳定项进行仔细的符号操作后，可以发现它们对残差 $R_{i,j}$ 的贡献是：\n$$\nR_{i,j}^{\\text{stab}} = \\frac{\\kappa_f}{4h^2} \\left[ (p_{i+2,j} - 4p_{i+1,j} + 6p_{i,j} - 4p_{i-1,j} + p_{i-2,j}) + (p_{i,j+2} - 4p_{i,j+1} + 6p_{i,j} - 4p_{i,j-1} + p_{i,j-2}) \\right]\n$$\n这是一个离散双调和算子。让我们分析它对棋盘格压力场 $p_{i,j} = (-1)^{i+j}$ 的影响。如前所述，$R_{i,j}^{\\text{central}}=0$。对于稳定项，我们计算有限差分：\n$$\np_{i+2,j} - 4p_{i+1,j} + 6p_{i,j} - 4p_{i-1,j} + p_{i-2,j} = p_{i,j} - 4(-p_{i,j}) + 6p_{i,j} - 4(-p_{i,j}) + p_{i,j} = (1+4+6+4+1)p_{i,j} = 16p_{i,j}\n$$\n对于 $j$ 方向的模板，也得到相同的结果 $16p_{i,j}$。因此，对于带有稳定格式的棋盘格场：\n$$\nR_{i,j} = R_{i,j}^{\\text{central}} + R_{i,j}^{\\text{stab}} = 0 + \\frac{\\kappa_f}{4h^2} (16p_{i,j} + 16p_{i,j}) = \\frac{32\\kappa_f}{4h^2}p_{i,j} = \\frac{8\\kappa_f}{h^2}p_{i,j}\n$$\n代入 $h=1/N$ 和 $p_{i,j}=(-1)^{i+j}$ 得到：\n$$\nR_{i,j} = 8\\kappa_f N^2 (-1)^{i+j}\n$$\n该残差非零且数值较大，表明稳定化已成功地从零空间中消除了棋盘格模式。我们现在可以计算其 $L^2$ 范数：\n$$\n\\|R\\|_2^2 = \\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} (8\\kappa_f N^2 (-1)^{i+j})^2 = \\frac{1}{N^2}\\sum_{i,j} (8\\kappa_f N^2)^2 = \\frac{1}{N^2} \\cdot N^2 (8\\kappa_f N^2)^2 = (8\\kappa_f N^2)^2\n$$\n$$\n\\|R\\|_2 = 8\\kappa_f N^2\n$$\n这个解析结果为实施提供了精确的验证目标。对于光滑压力场，稳定项是关于 $h$ 的高阶项，并作为小的修正；而对于非光滑场，它提供了必要的稳定性。\n\n下面的 Python 程序实现了计算每个指定测试用例的 $\\|R\\|_2$ 的完整数值过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_one_case(N, scheme, pressure_type, kappa_c, kappa_f):\n    \"\"\"\n    Calculates the L2 norm of the discrete continuity residual for a single test case.\n    \"\"\"\n    h = 1.0 / N\n\n    # 1. Define grid and pressure field\n    i_ = np.arange(N)\n    j_ = np.arange(N)\n    ii, jj = np.meshgrid(i_, j_, indexing='ij')\n\n    if pressure_type == 'smooth':\n        x = (ii + 0.5) * h\n        y = (jj + 0.5) * h\n        p = np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n    elif pressure_type == 'checkerboard':\n        p = (-1.0)**(ii + jj)\n    else:\n        raise ValueError(f\"Unknown pressure type: {pressure_type}\")\n\n    # Pre-roll pressure fields for convenience, handling periodic boundary conditions.\n    # Indices needed are up to i+/-2, j+/-2.\n    p_ip1 = np.roll(p, -1, axis=0)\n    p_im1 = np.roll(p, 1, axis=0)\n    p_ip2 = np.roll(p, -2, axis=0)\n    p_im2 = np.roll(p, 2, axis=0)\n\n    p_jp1 = np.roll(p, -1, axis=1)\n    p_jm1 = np.roll(p, 1, axis=1)\n    p_jp2 = np.roll(p, -2, axis=1)\n    p_jm2 = np.roll(p, 2, axis=1)\n\n    # 2. Compute cell-centered velocities\n    u = -kappa_c * (p_ip1 - p_im1) / (2.0 * h)\n    v = -kappa_c * (p_jp1 - p_jm1) / (2.0 * h)\n\n    # Pre-roll cell-centered velocities for face interpolation\n    u_ip1 = np.roll(u, -1, axis=0)\n    u_im1 = np.roll(u, 1, axis=0)\n    v_jp1 = np.roll(v, -1, axis=1)\n    v_jm1 = np.roll(v, 1, axis=1)\n\n    # 3. Compute face velocities based on the selected scheme\n    if scheme == 'central':\n        u_e = (u + u_ip1) / 2.0\n        u_w = (u_im1 + u) / 2.0\n        v_n = (v + v_jp1) / 2.0\n        v_s = (v_jm1 + v) / 2.0\n    elif scheme == 'stabilized':\n        # Interpolated velocity part (same as central scheme)\n        u_e_interp = (u + u_ip1) / 2.0\n        u_w_interp = (u_im1 + u) / 2.0\n        v_n_interp = (v + v_jp1) / 2.0\n        v_s_interp = (v_jm1 + v) / 2.0\n\n        # Stabilization term for east face 'e' of cell (i,j)\n        grad_p_e = (p_ip1 - p) / h\n        interp_grad_p_e = 0.5 * ((p_ip1 - p_im1) / (2.0*h) + (p_ip2 - p) / (2.0*h))\n        u_e = u_e_interp - kappa_f * (grad_p_e - interp_grad_p_e)\n\n        # Stabilization term for west face 'w' of cell (i,j)\n        grad_p_w = (p - p_im1) / h\n        interp_grad_p_w = 0.5 * ((p - p_im2) / (2.0*h) + (p_ip1 - p_im1) / (2.0*h))\n        u_w = u_w_interp - kappa_f * (grad_p_w - interp_grad_p_w)\n\n        # Stabilization term for north face 'n' of cell (i,j)\n        grad_p_n = (p_jp1 - p) / h\n        interp_grad_p_n = 0.5 * ((p_jp1 - p_jm1) / (2.0*h) + (p_jp2 - p) / (2.0*h))\n        v_n = v_n_interp - kappa_f * (grad_p_n - interp_grad_p_n)\n\n        # Stabilization term for south face 's' of cell (i,j)\n        grad_p_s = (p - p_jm1) / h\n        interp_grad_p_s = 0.5 * ((p - p_jm2) / (2.0*h) + (p_jp1 - p_jm1) / (2.0*h))\n        v_s = v_s_interp - kappa_f * (grad_p_s - interp_grad_p_s)\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    # 4. Compute the discrete continuity residual for each cell\n    R = (u_e - u_w) / h + (v_n - v_s) / h\n\n    # 5. Compute the final discrete L2 norm over the grid\n    l2_norm = np.sqrt(np.mean(R**2))\n    \n    return l2_norm\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (N, scheme, pressure_type, kappa_c, kappa_f)\n    test_cases = [\n        (16, 'central', 'smooth', 1.0, 1.0),\n        (16, 'stabilized', 'smooth', 1.0, 1.0),\n        (16, 'central', 'checkerboard', 1.0, 1.0),\n        (16, 'stabilized', 'checkerboard', 1.0, 1.0),\n        (5, 'stabilized', 'checkerboard', 1.0, 1.0),\n        (5, 'central', 'checkerboard', 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, scheme, pressure_type, kappa_c, kappa_f = case\n        result = solve_one_case(N, scheme, pressure_type, kappa_c, kappa_f)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在认识到棋盘格伪影的根本原因之后，下一步是学习如何在实际的CFD后处理中诊断和量化它们。本练习将指导你构建一个诊断工具箱，用以检测压力-速度解耦。你将实现三种不同的度量方法：一种基于傅里葉频谱分析，一种比较不同离散梯度的大小，还有一种计算最近邻点的相关性，从而从多个角度识别这种数值病态 。",
            "id": "3354208",
            "problem": "您的任务是设计并实现一套诊断程序，用于量化和检测二维结构化周期性网格上的压力-速度解耦和奇偶棋盘格现象。从不可压缩连续性方程和动量方程出发，认识到压力梯度项的离散化必须与质量通量相一致，以避免解耦。对于采用朴素线性插值计算面心压力的同位网格，形式为 $p_{i,j} = (-1)^{i+j}$ 的奇偶压力模式会导致面心压力相互抵消，离散梯度坍缩为零，尽管在单单元尺度上的物理梯度不为零。这导致了典型的棋盘格病态问题。您的任务是推导并实现三个度量指标来检测和量化这种病态，并对几个测试场进行分类。\n\n基本原理：\n- 不可压缩连续性方程为 $\\nabla \\cdot \\mathbf{u} = 0$。\n- 动量方程包含压力梯度项，写作 $\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\text{other terms}$，其中 $\\rho$ 是流体密度，$\\mathbf{u}$ 是速度，而 $p$ 是压力。\n- 在一个具有 $N_x$ 个 $x$ 方向单元、$N_y$ 个 $y$ 方向单元，以及间距为 $\\Delta x$ 和 $\\Delta y$ 的结构化、周期性、均匀网格上，单元中心的 $\\nabla p$ 的同位中心差分离散格式使用相隔两个单元的最近邻点。通过算术插值 $p^{x}_{i+1/2,j} = \\frac{1}{2}\\left(p_{i+1,j}+p_{i,j}\\right)$ 定义的面心压力 $p^{x}_{i+1/2,j}$ 对于棋盘格模式等于零，这意味着即使单单元前向差分 $\\frac{p_{i+1,j}-p_{i,j}}{\\Delta x}$ 不为零，基于面心的离散梯度 $\\frac{p^{x}_{i+1/2,j}-p^{x}_{i-1/2,j}}{\\Delta x} = 0$ 也为零。这是可通过奇偶模式检测到的压力-速度解耦的本质。\n\n需实现的诊断指标：\n- 度量指标 1（谱奇偶能量分数）：使用 $p_{i,j}$ 的二维离散傅里叶变换 (DFT) 来量化集中在奈奎斯特波数处的能量。对于周期性网格，离散波数为 $k_x = \\frac{2\\pi m_x}{N_x \\Delta x}$（其中 $m_x \\in \\{0,\\dots, N_x-1\\}$）和 $k_y = \\frac{2\\pi m_y}{N_y \\Delta y}$（其中 $m_y \\in \\{0,\\dots, N_y-1\\}$）。对于偶数的 $N_x$ 和 $N_y$，奈奎斯特波数为 $k_x = \\frac{\\pi}{\\Delta x}$（对应于 $m_x = \\frac{N_x}{2}$）和 $k_y = \\frac{\\pi}{\\Delta y}$（对应于 $m_y = \\frac{N_y}{2}$）。令 $P(m_y,m_x)$ 为 $p_{i,j}$ 的 DFT。定义总谱能量 $E = \\sum_{m_y=0}^{N_y-1}\\sum_{m_x=0}^{N_x-1} \\left|P(m_y,m_x)\\right|^2$。定义奈奎斯特能量 $E_{\\text{nyq}}$ 为在四个频点 $(m_y,m_x) \\in \\{(0,\\frac{N_y}{2}),(\\frac{N_y}{2},0),(\\frac{N_y}{2},\\frac{N_x}{2})\\}$ 上的能量总和，如有重复则不计。奇偶能量分数为 $\\Phi_{\\text{oe}} = \\frac{E_{\\text{nyq}}}{E}$。\n- 度量指标 2（基于单单元与双单元梯度的解耦比）：定义单单元前向差分梯度幅值\n$$D_1 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i,j}}{\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j}}{\\Delta y}\\right)^2\\right],$$\n采用周期性索引。定义双单元中心差分梯度幅值\n$$D_2 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}\\right)^2\\right],$$\n同样采用周期性索引。解耦比为 $R = \\frac{D_2}{D_1}$，约定若 $D_1 = 0$ 则设 $R = 1$ 以避免在常数场中出现伪检测。对于完美的棋盘格模式，$D_1$ 很大而 $D_2 = 0$，导致 $R \\approx 0$。\n- 度量指标 3（最近邻相关性）：定义归一化的最近邻相关性为\n$$C = \\frac{\\frac{1}{2N}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[p_{i,j} p_{i+1,j} + p_{i,j} p_{i,j+1}\\right]}{\\frac{1}{N}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}^2},$$\n其中 $N = N_x N_y$。对于完美的棋盘格模式 $p_{i,j} = (-1)^{i+j}$，有 $p_{i+1,j} = -p_{i,j}$ 和 $p_{i,j+1} = -p_{i,j}$，得到 $C = -1$。对于邻近值一致的光滑场，$C$ 接近 $1$。\n\n分类规则：\n- 如果满足 $\\Phi_{\\text{oe}} \\ge \\alpha$ 或 $C \\le -\\beta$ 或 $R \\le \\gamma$，则声明检测到棋盘格现象，其中阈值为 $\\alpha = 0.5$、$\\beta = 0.5$ 和 $\\gamma = 0.1$。\n\n实现要求：\n- 构建一个周期性网格，参数为 $N_x = 16$、$N_y = 16$、$\\Delta x = 1$ 和 $\\Delta y = 1$。\n- 构建以下压力场 $p_{i,j}$ 的测试套件：\n    - 情况 1（光滑可分模式）：$p_{i,j} = \\sin\\left(2\\pi \\frac{i}{N_x}\\right) \\sin\\left(2\\pi \\frac{j}{N_y}\\right)$。\n    - 情况 2（完美棋盘格模式）：$p_{i,j} = (-1)^{i+j}$。\n    - 情况 3（光滑与棋盘格混合模式）：$p_{i,j} = 0.7\\,(-1)^{i+j} + 0.3\\,\\sin\\left(2\\pi \\frac{i}{N_x}\\right) \\sin\\left(2\\pi \\frac{j}{N_y}\\right)$。\n    - 情况 4（均匀场）：$p_{i,j} = 1$。\n    - 情况 5（零均值随机场）：$p_{i,j}$ 从正态分布 $\\mathcal{N}(0,1)$ 中独立抽取，并使用固定的伪随机种子以保证可复现性。\n- 对每种情况，计算 $\\Phi_{\\text{oe}}$、$R$ 和 $C$，并应用分类规则。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的分类结果，以逗号分隔的列表形式包含在方括号中，按用例顺序排列，每个元素为布尔值（例如，$\\texttt{[True,False,True,False,False]}$）。不应打印任何其他文本。",
            "solution": "该问题要求设计并实现三个不同的数值诊断工具，以检测压力-速度解耦。这是一种在计算流体动力学模拟中，常在压力场中表现为“棋盘格”模式的现象。这个问题在同位网格（压力和速度分量存储在相同的网格位置）上尤为普遍。我们将验证问题陈述，详细说明每种诊断方法的理论基础，然后构建一个程序，将它们应用于一组测试用例。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- **控制方程**：不可压缩连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$；动量方程压力项 $\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\text{other terms}$。\n- **网格与离散化**：二维、结构化、周期性、均匀网格，包含 $N_x \\times N_y$ 个尺寸为 $\\Delta x \\times \\Delta y$ 的单元；同位变量排布。\n- **棋盘格模式**：$p_{i,j} = (-1)^{i+j}$。\n- **面心压力插值**：$p^{x}_{i+1/2,j} = \\frac{1}{2}\\left(p_{i+1,j}+p_{i,j}\\right)$。\n- **度量指标 1 ($\\Phi_{\\text{oe}}$)**：谱奇偶能量分数。\n    - $p_{i,j}$ 的 DFT 为 $P(m_y,m_x)$。\n    - 总谱能量：$E = \\sum_{m_y=0}^{N_y-1}\\sum_{m_x=0}^{N_x-1} \\left|P(m_y,m_x)\\right|^2$。\n    - 奈奎斯特能量 $E_{\\text{nyq}}$：对应于奈奎斯特频率的 $(m_y,m_x)$ 频点上 $|P|^2$ 的和，对于偶数 $N_x, N_y$，具体为 $(0, N_x/2)$、$(N_y/2, 0)$ 和 $(N_y/2, N_x/2)$。\n    - 公式：$\\Phi_{\\text{oe}} = E_{\\text{nyq}} / E$。\n- **度量指标 2 ($R$)**：解耦比。\n    - 单单元前向差分梯度幅值和：$D_1 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i,j}}{\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j}}{\\Delta y}\\right)^2\\right]$。\n    - 双单元中心差分梯度幅值和：$D_2 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}\\right)^2\\right]$。\n    - 公式：$R = D_2 / D_1$，若 $D_1=0$ 则 $R=1$。\n- **度量指标 3 ($C$)**：最近邻相关性。\n    - 公式：$C = \\frac{\\frac{1}{2N}\\sum_{i,j}\\left[p_{i,j} p_{i+1,j} + p_{i,j} p_{i,j+1}\\right]}{\\frac{1}{N}\\sum_{i,j} p_{i,j}^2}$，其中 $N = N_x N_y$。\n- **分类规则**：如果 $\\Phi_{\\text{oe}} \\ge 0.5$ 或 $C \\le -0.5$ 或 $R \\le 0.1$，则检测到棋盘格现象。\n- **实现参数**：$N_x = 16$，$N_y = 16$，$\\Delta x = 1$，$\\Delta y = 1$。\n- **测试用例**：1) 光滑可分模式，2) 完美棋盘格模式，3) 光滑/棋盘格混合模式，4) 均匀场，5) 零均值随机场。\n\n**第二步：基于提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它使用标准的、定义明确的数学和计算技术来解决流体动力学数值分析中的一个典型问题（压力-速度解耦）。所提供的度量指标公式是用于诊断此类数值伪影的正确表述。所选的测试用例能够很好地探测度量指标在不同条件（光滑、纯振荡、混合、常数和噪声场）下的行为。问题描述中 Metric 1 存在一个微小的歧义，它提到“四个频点的总和”，但列出了三个特定的索引对。这被解释为一个印刷错误，列出的三个频点——$(0, N_x/2)$、$(N_y/2, 0)$ 和 $(N_y/2, N_x/2)$——是捕捉沿坐标轴和对角线的奇偶振荡的正确频点，并且是足够的。这个小问题不影响严谨的求解。因此，该问题被认定为有效。\n\n**第三步：结论与行动**\n该问题有效。将提供一个完整的解决方案。\n\n### 求解推导与实现策略\n\n问题的核心在于离散算子在网格上的性质。在许多早期的同位网格 CFD 方法中使用的压力梯度朴素中心差分格式，其离散算子的零空间并非平凡。具体来说，它包含高频模式，如棋盘格模式 $p_{i,j} = C(-1)^{i+j}$，其中 $C$ 是一个常数。对于这样的场，在单元中心使用 $i-1$ 和 $i+1$ 处的值计算的压力梯度恒为零，从而使压力场与速度场解耦，并允许伪影、非物理的压力振荡增长。这三个度量指标就是为了检测此类模式的特征而设计的。\n\n**度量指标 1：谱奇偶能量分数, $\\Phi_{\\text{oe}}$**\n该度量指标在傅里叶空间中操作。棋盘格模式 $p_{i,j} = (-1)^{i+j}$ 代表了在间距为 $\\Delta x$ 和 $\\Delta y$ 的网格上可以解析的最高空间频率。在离散傅里叶域中，该模式的能量完全集中在奈奎斯特频率上，其对应的波数为 $k_x = \\pi / \\Delta x$ 和 $k_y = \\pi / \\Delta y$。\n\n设 $p_{i,j}$ 是 $N_x \\times N_y$ 网格上的压力场。其二维离散傅里叶变换 (DFT) 由下式给出：\n$$ P(m_y, m_x) = \\sum_{j=0}^{N_y-1} \\sum_{i=0}^{N_x-1} p_{i,j} e^{-2\\pi i (m_x i / N_x + m_y j / N_y)} $$\n其中 $m_x \\in \\{0, \\dots, N_x-1\\}$ 和 $m_y \\in \\{0, \\dots, N_y-1\\}$ 是频率指数。\n根据 Parseval 定理，场中的总能量与傅里叶系数的模平方和成正比：\n$$ E = \\sum_{m_y=0}^{N_y-1} \\sum_{m_x=0}^{N_x-1} |P(m_y, m_x)|^2 $$\n对于给定的偶数网格维度（$N_x=16$, $N_y=16$），奈奎斯特频率指数为 $m_x = N_x/2 = 8$ 和 $m_y = N_y/2 = 8$。与奇偶振荡相关的能量出现在对应于纯 $x$ 方向、纯 $y$ 方向或两者兼有的振荡频率上。因此，相关的频点是 $(m_y, m_x) = (0, N_x/2)$、$(N_y/2, 0)$ 和 $(N_y/2, N_x/2)$。奈奎斯特能量是这些频点中能量的总和：\n$$ E_{\\text{nyq}} = |P(0, N_x/2)|^2 + |P(N_y/2, 0)|^2 + |P(N_y/2, N_x/2)|^2 $$\n该度量指标是此奈奎斯特能量与总能量的比值：\n$$ \\Phi_{\\text{oe}} = \\frac{E_{\\text{nyq}}}{E} $$\n一个接近 $1$ 的 $\\Phi_{\\text{oe}}$ 值表明该场主要由类似棋盘格的模式主导。\n\n**度量指标 2：解耦比, $R$**\n该度量指标在物理空间中操作，比较用两种不同模板计算的压力场梯度的大小。双单元中心差分，例如 $\\frac{p_{i+1,j} - p_{i-1,j}}{2\\Delta x}$，正是对棋盘格模式“视而不见”的算子。对于 $p_{i,j} = (-1)^{i+j}$，我们有 $p_{i+1,j} = p_{i-1,j} = -p_{i,j}$，所以分子为零。而单单元前向差分 $\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}$ 对此模式仍然敏感。\n\n该度量指标计算使用两种模板的梯度场平方幅值的全网格总和。\n$D_1$ 使用单单元模板：\n$$ D_1 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i,j}}{\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j}}{\\Delta y}\\right)^2\\right] $$\n$D_2$ 使用双单元模板：\n$$ D_2 = \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[\\left(\\frac{p_{i+1,j}-p_{i-1,j}}{2\\Delta x}\\right)^2 + \\left(\\frac{p_{i,j+1}-p_{i,j-1}}{2\\Delta y}\\right)^2\\right] $$\n网格是周期性的，因此索引是循环的。比值 $R = D_2/D_1$ 量化了解耦程度。对于光滑场，两种模板都能提供相似的梯度近似，因此 $R \\approx 1$。对于完美的棋盘格模式，$D_2 = 0$ 而 $D_1 > 0$，得到 $R = 0$。小的 $R$ 值表示存在解耦。对于常数场，$D_1=0$，按照约定我们设 $R=1$。\n\n**度量指标 3：最近邻相关性, $C$**\n该度量指标为棋盘格模式的符号交替结构提供了最直接的检验。完美的棋盘格有 $p_{i+1,j} = -p_{i,j}$ 和 $p_{i,j+1} = -p_{i,j}$。因此，一个点与其邻居之间的相关性将是强烈的负相关。\n该度量指标定义为单元值与其邻居值乘积的平均值，并由场本身的均方值归一化：\n$$ C = \\frac{\\frac{1}{2N}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left[p_{i,j} p_{i+1,j} + p_{i,j} p_{i,j+1}\\right]}{\\frac{1}{N}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}^2} $$\n其中 $N = N_x N_y$。对于完美的棋盘格，$p_{i,j}p_{i+1,j} = -p_{i,j}^2$ 且 $p_{i,j}p_{i,j+1} = -p_{i,j}^2$。如果 $p_{i,j} = \\pm 1$，则分子变为 $\\frac{1}{2N}\\sum(-1-1) = -1$，分母为 $1$，因此 $C=-1$。对于光滑场，$p_{i+1,j} \\approx p_{i,j}$，导致 $C \\approx 1$。一个接近 $-1$ 的 $C$ 值是棋盘格现象的强烈指标。\n\n**实现**\n实现将遵循这些原则。我们将为每个度量指标定义 Python 函数。将使用 NumPy 的 `fft.fft2` 函数来实现 Metric 1。对于 Metric 2 和 3，`numpy.roll` 函数非常适合在周期性网格上实现所需的平移操作。将生成五个测试用例，并为每个用例计算三个度量指标。最后，通过分类规则中条件的逻辑“或”运算来确定每个用例的布尔输出。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_phi_oe(p_field, Nx, Ny):\n    \"\"\"\n    Calculates Metric 1: Spectral odd-even energy fraction (Phi_oe).\n    \"\"\"\n    # Compute the 2D Discrete Fourier Transform of the pressure field.\n    p_fft = np.fft.fft2(p_field)\n    \n    # Total spectral energy is the sum of the squared magnitudes of the FFT coefficients.\n    total_energy = np.sum(np.abs(p_fft)**2)\n    \n    if total_energy == 0:\n        return 0.0\n\n    # For even Nx, Ny, the Nyquist frequency indices are Nx/2 and Ny/2.\n    nx_nyq, ny_nyq = Nx // 2, Ny // 2\n    \n    # Nyquist energy is the sum of energy at the highest frequencies.\n    # Corresponds to odd-even oscillations in x, y, and both directions.\n    e_nyq = (\n        np.abs(p_fft[0, nx_nyq])**2 +\n        np.abs(p_fft[ny_nyq, 0])**2 +\n        np.abs(p_fft[ny_nyq, nx_nyq])**2\n    )\n    \n    phi_oe = e_nyq / total_energy\n    return phi_oe\n\ndef calculate_r_ratio(p_field, dx, dy):\n    \"\"\"\n    Calculates Metric 2: Decoupling ratio (R).\n    \"\"\"\n    # D1: Sum of squared one-cell forward differences.\n    # np.roll provides periodic boundary conditions.\n    # For D1x, we compute (p_{i+1,j} - p_{i,j}) / dx\n    diff_x_1 = (np.roll(p_field, -1, axis=1) - p_field) / dx\n    # For D1y, we compute (p_{i,j+1} - p_{i,j}) / dy\n    diff_y_1 = (np.roll(p_field, -1, axis=0) - p_field) / dy\n    \n    d1 = np.sum(diff_x_1**2 + diff_y_1**2)\n\n    # If D1 is zero (constant field), return 1 as per problem convention.\n    if d1 == 0:\n        return 1.0\n\n    # D2: Sum of squared two-cell central differences.\n    # For D2x, we compute (p_{i+1,j} - p_{i-1,j}) / (2*dx)\n    diff_x_2 = (np.roll(p_field, -1, axis=1) - np.roll(p_field, 1, axis=1)) / (2 * dx)\n    # For D2y, we compute (p_{i,j+1} - p_{i,j-1}) / (2*dy)\n    diff_y_2 = (np.roll(p_field, -1, axis=0) - np.roll(p_field, 1, axis=0)) / (2 * dy)\n    \n    d2 = np.sum(diff_x_2**2 + diff_y_2**2)\n    \n    r_ratio = d2 / d1\n    return r_ratio\n\ndef calculate_c_corr(p_field, Nx, Ny):\n    \"\"\"\n    Calculates Metric 3: Nearest-neighbor correlation (C).\n    \"\"\"\n    N = Nx * Ny\n    \n    # Denominator: Mean square of the field.\n    p_sq_mean = np.sum(p_field**2) / N\n    \n    if p_sq_mean == 0:\n        return 1.0 # Or some neutral value; 1 is appropriate for non-checkerboard.\n\n    # Numerator: Average of products with neighbors.\n    # Sum of p_{i,j} * p_{i+1,j}\n    corr_x = np.sum(p_field * np.roll(p_field, -1, axis=1))\n    # Sum of p_{i,j} * p_{i,j+1}\n    corr_y = np.sum(p_field * np.roll(p_field, -1, axis=0))\n    \n    numerator = (corr_x + corr_y) / (2 * N)\n    \n    c_corr = numerator / p_sq_mean\n    return c_corr\n    \ndef solve():\n    \"\"\"\n    Main function to run diagnostics on all test cases.\n    \"\"\"\n    # Grid parameters\n    Nx, Ny = 16, 16\n    dx, dy = 1.0, 1.0\n    \n    # Classification thresholds\n    alpha = 0.5\n    beta = 0.5\n    gamma = 0.1\n\n    # Grid generation\n    i = np.arange(Nx)\n    j = np.arange(Ny)\n    I, J = np.meshgrid(i, j, indexing='ij')\n\n    # Test cases generation\n    p_smooth = np.sin(2 * np.pi * I / Nx) * np.sin(2 * np.pi * J / Ny)\n    p_checker = (-1)**(I + J)\n    p_mixed = 0.7 * p_checker + 0.3 * p_smooth\n    p_uniform = np.ones((Nx, Ny))\n    \n    # Reproducible random field\n    np.random.seed(42)\n    p_random = np.random.normal(0, 1, (Nx, Ny))\n\n    test_cases = [\n        p_smooth, \n        p_checker, \n        p_mixed, \n        p_uniform, \n        p_random\n    ]\n    \n    results = []\n    \n    for p_field in test_cases:\n        # Calculate the three metrics for the current field\n        phi_oe = calculate_phi_oe(p_field, Nx, Ny)\n        r_ratio = calculate_r_ratio(p_field, dx, dy)\n        c_corr = calculate_c_corr(p_field, Nx, Ny)\n        \n        # Apply the classification rule\n        is_checkerboard = (phi_oe >= alpha) or (c_corr = -beta) or (r_ratio = gamma)\n        results.append(is_checkerboard)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "理论上的缺陷最终会在求解器算法的实际表现中暴露出来。本练习将让你在一个简化的压力修正算法框架内，观察棋盘格模式的产生与抑制。通过在一个未加稳定措施的同位网格上实现SIMPLE和PISO算法的核心步骤，你将探索压力亚松弛因子 $\\alpha_p$ 等技术选择如何直接影响数值解的稳定性 。",
            "id": "3354212",
            "problem": "考虑一个二维不可压缩的顶盖驱动方腔，其方形域的边长为 $L$ 米，内含密度为 $\\rho$（单位：千克/立方米）和运动粘度为 $\\nu$（单位：平方米/秒）的牛顿流体。在时间 $t=0$ 秒时，空腔顶盖（上边界）被脉冲式启动。在基于均匀笛卡尔网格的同位有限体积离散化中，压力和速度分量存储在相同的单元中心。众所周知，在这种同位网格布置中，如果不进行额外的稳定化处理，对面通量进行中心差分插值会导致压力-速度解耦，并出现奇偶（棋盘格）压力场。\n\n您的任务是，在一个同位网格上，使用压力耦合方程组的半隐式方法 (SIMPLE) 或算子分裂的压力隐式方法 (PISO) 实现一个简化的压力修正路径，并明确省略 Rhie–Chow 插值。从具有恒定 $\\rho$ 和 $\\nu$ 的不可压缩 Navier–Stokes 方程以及连续性方程\n$$\n\\nabla \\cdot \\mathbf{u} = 0,\n$$\n和早期时间的线性动量平衡（在脉冲启动后立即忽略对流，以便粘性效应和压力效应占主导地位）\n$$\n\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p + \\rho \\nu \\nabla^2 \\mathbf{u} + \\mathbf{S},\n$$\n出发，使用中心差分进行同位离散化，驱动一个单时间步的预测-修正循环，以展示压力亚松弛对棋盘格压力模式出现或抑制的影响。\n\n为确保科学真实性和可复现性，同时保持计算的可处理性，请采用以下建模选择和算法步骤。\n\n1. 网格与离散化：\n   - 在边长为 $L$ 米的方形域中，使用一个包含 $N_x \\times N_y$ 个内部单元的均匀同位网格，网格间距为 $ \\Delta x = L / N_x $ 和 $ \\Delta y = L / N_y $。\n   - 使用中心差分来近似单元中心的​​空间导数。\n   - 通过对相邻单元中心速度进行算术平均来计算面法向质量通量（明确不应用 Rhie–Chow 插值或任何在界面上的压力平滑）。\n   - 对压力修正求解施加 Dirichlet 条件，在域边界上设 $p=0$，以正则化线性系统。\n\n2. 时间与材料参数：\n   - 使用大小为 $\\Delta t$ 秒的单个时间步。\n   - 使用流体密度 $\\rho$（单位：千克/立方米）和运动粘度 $\\nu$（单位：平方米/秒）。\n   - 使用对角动量系数 $a_u = \\rho/\\Delta t + 2 \\rho \\nu \\left(1/\\Delta x^2 + 1/\\Delta y^2\\right)$ 来表示速度预测子中局部惯性和粘性扩散的半隐式平衡。\n\n3. 脉冲启动模型：\n   - 通过在 $t=0$ 秒时，施加在顶盖边界附近的一个空间局域的、产生散度的体积力 $\\mathbf{S} = (S_x, 0)$ 来表示顶盖的脉冲启动。令 $x$ 分量为\n     $$\n     S_x(x,y) = \\rho \\frac{U_0}{\\Delta t} \\exp\\!\\left(-\\frac{L-y}{\\sigma}\\right) \\sin\\!\\left(\\frac{2\\pi x}{L}\\right),\n     $$\n     其中 $U_0$ 是顶盖速度（单位：米/秒），$\\sigma$ 是一个穿透长度尺度，设为 $\\sigma = 0.1 L$ 米。使用 $S_y=0$。\n   - 计算预测速度\n     $$\n     u^* = \\frac{\\Delta t}{a_u} S_x, \\quad v^* = 0,\n     $$\n     于单元中心。这将基于对 $u^*$ 和 $v^*$ 的界面算术插值，在界面上产生一个散度场\n     $$\n     b = -\\nabla \\cdot \\mathbf{u}^*。\n     $$\n\n4. 同位网格上的压力修正路径：\n   - 将由压力引起的速度修正定义为\n     $$\n     u' = -\\frac{\\Delta t}{\\rho\\, a_u}\\frac{\\partial p'}{\\partial x}, \\quad v' = -\\frac{\\Delta t}{\\rho\\, a_u}\\frac{\\partial p'}{\\partial y},\n     $$\n     并通过将 $u'$ 和 $v'$ 平均到界面上然后进行差分，来计算该修正的散度贡献。\n   - SIMPLE 路径：\n     - 计算残差 $r = b - \\mathcal{C}(p)$，其中 $\\mathcal{C}(p)$ 表示当前压力场通过上述压力-速度耦合所引起的散度。\n     - 使用一个具有间距 $\\Delta x$ 和 $\\Delta y$ 的五点拉普拉斯算子 $L$ 来求解一个正则化的 Dirichlet 泊松问题 $L p_c = r$。\n     - 使用亚松弛更新压力 $p \\leftarrow p + \\alpha_p p_c$，其中 $\\alpha_p \\in (0,1]$ 是压力亚松弛因子。\n     - 在修正循环期间不更新预测子 $u^*,v^*$（单次预测，多次压力修正）。\n   - PISO 路径：\n     - 在一个总步长内执行 $N_{\\text{corr}} \\in \\{2,3\\}$ 次连续的修正。在每次修正中：\n       - 构造 $r = b - \\mathcal{C}(p)$，求解 $L p_c = r$，并更新 $p \\leftarrow p + p_c$（使用 $\\alpha_p=1$）。\n       - 使用压力梯度修正来更新速度，$u \\leftarrow u^* + u'$ 和 $v \\leftarrow v^* + v'$。\n       - 使用算术插值从更新后的面法向质量通量重新计算 $b$，然后进行下一次修正。\n\n5. 棋盘格振幅度量：\n   - 在 $N_x \\times N_y$ 网格上定义规范的奇偶掩码 $S_{i,j} = (-1)^{i+j}$。\n   - 将最终压力场（在所有修正之后）的棋盘格振幅计算为\n     $$\n     A = \\frac{\\left|\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} S_{i,j}\\,\\left(p_{i,j} - \\bar{p}\\right)\\right|}{\\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left|p_{i,j} - \\bar{p}\\right|},\n     $$\n     其中 $\\bar{p}$ 是 $p$ 在内部单元上的空间平均值。这个无量纲比率量化了奇偶模式的相对存在。\n\n请在一个自包含的程序中实现上述内容，该程序构建网格和算子，对每个测试用例执行指定的预测-修正路径，并报告每个用例的棋盘格振幅 $A$。\n\n使用以下参数值（在适用处注明单位）：\n- 域边长 $L = 1$ 米。\n- 顶盖速度 $U_0 = 1$ 米/秒。\n- 流体密度 $\\rho = 1$ 千克/立方米。\n- 运动粘度 $\\nu = 10^{-3}$ 平方米/秒。\n- 时间步长 $\\Delta t = 10^{-3}$ 秒。\n\n测试套件：\n- 用例 1：$N_x = 32$, $N_y = 32$，SIMPLE 算法，$\\alpha_p = 0.2$。\n- 用例 2：$N_x = 32$, $N_y = 32$，SIMPLE 算法，$\\alpha_p = 0.8$。\n- 用例 3：$N_x = 32$, $N_y = 32$，PISO 算法，$N_{\\text{corr}} = 2$ 且 $\\alpha_p = 1.0$。\n- 用例 4：$N_x = 16$, $N_y = 16$，SIMPLE 算法，$\\alpha_p = 0.8$。\n- 用例 5：$N_x = 32$, $N_y = 32$，PISO 算法，$N_{\\text{corr}} = 3$ 且 $\\alpha_p = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列结果，例如 $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$，其中每个 $\\text{result}$ 是表示相应案例的棋盘格振幅 $A$ 的浮点数。不应产生任何其他输出。所有角度（如果出现）必须以弧度为单位，但本任务不涉及角度。由于最终输出是无量纲的，因此数值答案不需要物理单位，尽管所有输入参数必须遵守上述指定的单位。",
            "solution": "用户提供的问题是计算流体动力学（CFD）领域一个定义明确的数值练习，被认为是有效的。它要求在同位网格上实现一个简化的压力修正方案，以演示压力-速度解耦现象，该现象表现为棋盘格压力振荡。该问题具有科学依据，内容自洽，且算法具体。\n\n问题的核心在于求解一个由连续性方程和简化的动量方程推导出的压力泊松方程。我们需要在适用于从静止状态脉冲启动的一系列简化假设下，实现两种经典的压力修正算法：SIMPLE 和 PISO。具体来说，对流项被忽略，速度预测仅由一个旨在模拟顶盖脉冲启动的预设体积力驱动。关键的是，该方案省略了 Rhie-Chow 插值，而 Rhie-Chow 插值是同位网格上棋盘格问题的标准修正方法，从而确保该现象能够被观察到。\n\n解决方案的结构如下：\n1.  **网格与参数设置**：我们定义物理域、网格分辨率（$N_x \\times N_y$）以及所有相关的物理常数（$L, \\rho, \\nu, U_0, \\Delta t$）。由此，我们推导出网格间距（$\\Delta x, \\Delta y$）和对角动量系数 $a_u$。\n2.  **预测步**：计算初始速度预测，记为 $\\mathbf{u}^* = (u^*, v^*)$。根据规定，该场源于代表脉冲顶盖运动的体积力 $\\mathbf{S}$。简化的动量平衡给出 $u^* = \\frac{\\Delta t}{a_u} S_x$ 和 $v^*=0$。这个预测场 $\\mathbf{u}^*$ 通常不满足连续性方程，即 $\\nabla \\cdot \\mathbf{u}^* \\neq 0$。\n3.  **离散算子**：为了在我们的同位网格上实现有限体积法，我们需要散度、梯度和拉普拉斯算子的离散版本。\n    -   梯度 $\\nabla p$ 使用中心差分进行离散化。\n    -   散度 $\\nabla \\cdot \\mathbf{u}$ 通过先对单元中心速度进行算术平均以获得面法向通量，然后对每个控制体应用散度定理来进行离散化。这一特定选择是压力-速度解耦的根本原因。\n    -   形如 $-\\nabla^2 p' = S$ 的压力泊松方程，使用稀疏线性系统求解。为二维网格构建负拉普拉斯算子（$-\\nabla^2$）的矩阵，并施加齐次 Dirichlet 边界条件（在所有边界上 $p=0$）。\n4.  **压力修正步**：这是算法的核心，通过计算压力场来强制满足连续性。最终速度场 $\\mathbf{u}$ 通过压力梯度修正与预测场 $\\mathbf{u}^*$ 相关联：$\\mathbf{u} = \\mathbf{u}^* - \\frac{\\Delta t}{\\rho a_u}\\nabla p$。强制执行连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$，会得到压力泊松方程：\n    $$\n    \\nabla \\cdot \\left( \\frac{\\Delta t}{\\rho a_u} \\nabla p \\right) = \\nabla \\cdot \\mathbf{u}^*\n    $$\n    由于 $\\frac{\\Delta t}{\\rho a_u}$ 是常数，该方程简化为 $-\\nabla^2 p = -\\frac{\\rho a_u}{\\Delta t} \\nabla \\cdot \\mathbf{u}^* = \\frac{\\rho a_u}{\\Delta t} b$，其中 $b = -\\nabla \\cdot \\mathbf{u}^*$ 是散度源项。\n\n    -   **SIMPLE 路径**：这是一个迭代过程。我们从一个初始压力猜测（例如 $p^{(0)}=0$）开始，并迭代地优化它。对于每次迭代，我们计算连续性方程的残差 $r = b - \\mathcal{C}(p^{(k)})$，其中 $\\mathcal{C}(p^{(k)})$ 是当前压力猜测 $p^{(k)}$ 提供的散度修正。我们求解压力修正量 $p_c$ 以消除此残差，并通过亚松弛更新压力场：$p^{(k+1)} = p^{(k)} + \\alpha_p p_c$。此过程重复固定的内迭代次数。所实现的程序等效于求解完整泊松方程的 Richardson 迭代求解器。\n    -   **PISO 路径**：这是一个非迭代的预测-修正步序列。在初始预测之后，我们执行 $N_{\\text{corr}}$ 次修正步。在每一步中，我们计算当前速度场的散度，求解泊松方程以获得压力修正量，并更新压力和速度场。与 SIMPLE 的关键区别在于，速度场在修正序列内部被更新，并且后续压力求解的源项是这个新更新速度场的散度。\n5.  **棋盘格振幅指标**：在获得最终压力场 $p$ 后，我们使用指定的棋盘格振幅指标 $A$ 来量化奇偶振荡的强度。该指标测量压力脉动在最高频率模式 $(-1)^{i+j}$ 上的投影，并通过脉动的总幅度进行归一化。更高的 $A$ 值表示更强的棋盘格现象。\n\n最终程序封装了此逻辑，遍历所提供的五个测试用例，为每个用例计算棋盘格振幅 $A$，并以指定格式打印结果。预期 SIMPLE 算法中较高的压力亚松弛（$\\alpha_p$）和更粗的网格将导致更大的 $A$ 值，而 PISO 算法，特别是使用更多修正子时，在抑制这些振荡方面将更有效。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef setup_grid_and_params(L, Nx, Ny, rho, nu, dt, sigma_factor):\n    \"\"\"Sets up grid, coordinates, and physical parameters.\"\"\"\n    dx = L / Nx\n    dy = L / Ny\n    \n    # Cell-centered coordinates\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n    au = rho / dt + 2 * rho * nu * (1/dx**2 + 1/dy**2)\n    sigma = sigma_factor * L\n    \n    return (dx, dy, xx, yy, au, sigma)\n\n\ndef get_predictor_velocities(rho, U0, dt, L, au, sigma, xx, yy):\n    \"\"\"Computes the predictor velocity field u*.\"\"\"\n    # Sx is defined at cell centers\n    Sx = rho * (U0 / dt) * np.exp(-(L - yy) / sigma) * np.sin(2 * np.pi * xx / L)\n    u_star = (dt / au) * Sx\n    v_star = np.zeros_like(u_star)\n    return u_star, v_star\n\n\ndef compute_divergence(u, v, dx, dy):\n    \"\"\"Computes divergence of a cell-centered vector field using arithmetic averaging for face values.\"\"\"\n    # Pad with zeros for boundary conditions (zero velocity assumed at walls for this calculation)\n    u_padded = np.pad(u, 1, 'constant', constant_values=0)\n    v_padded = np.pad(v, 1, 'constant', constant_values=0)\n    \n    # Face velocities (arithmetic average)\n    u_face_e = 0.5 * (u_padded[1:-1, 1:-1] + u_padded[2:, 1:-1])\n    u_face_w = 0.5 * (u_padded[1:-1, 1:-1] + u_padded[:-2, 1:-1])\n    v_face_n = 0.5 * (v_padded[1:-1, 1:-1] + v_padded[1:-1, 2:])\n    v_face_s = 0.5 * (v_padded[1:-1, 1:-1] + v_padded[1:-1, :-2])\n    \n    div = (u_face_e - u_face_w) / dx + (v_face_n - v_face_s) / dy\n    return div\n\n\ndef compute_gradient(p, dx, dy):\n    \"\"\"Computes gradient of a cell-centered scalar field with zero Dirichlet BCs.\"\"\"\n    # Pad with zeros for Dirichlet BCs p=0\n    p_padded = np.pad(p, 1, 'constant', constant_values=0)\n    \n    grad_x = (p_padded[2:, 1:-1] - p_padded[:-2, 1:-1]) / (2 * dx)\n    grad_y = (p_padded[1:-1, 2:] - p_padded[1:-1, :-2]) / (2 * dy)\n    \n    return grad_x, grad_y\n\ndef get_laplacian_matrix(Nx, Ny, dx, dy):\n    \"\"\"Creates a sparse matrix for the negative 2D Laplacian (-del^2) with Dirichlet BCs using Kronecker product.\"\"\"\n    L_x = diags([1, -2, 1], [-1, 0, 1], shape=(Nx, Nx)) / dx**2\n    L_y = diags([1, -2, 1], [-1, 0, 1], shape=(Ny, Ny)) / dy**2\n\n    I_x = identity(Nx)\n    I_y = identity(Ny)\n\n    A = - (kron(I_y, L_x) + kron(L_y, I_x))\n    return A.tocsr()\n\n\ndef compute_checkerboard_amplitude(p):\n    \"\"\"Computes the checkerboard amplitude metric for a pressure field.\"\"\"\n    Nx, Ny = p.shape\n    if p.size == 0:\n        return 0.0\n        \n    p_mean = np.mean(p)\n    p_fluctuation = p - p_mean\n    \n    denominator = np.sum(np.abs(p_fluctuation))\n    if denominator  1e-15:\n        return 0.0\n\n    ii, jj = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n    mask = (-1)**(ii + jj)\n    \n    numerator = np.abs(np.sum(mask * p_fluctuation))\n        \n    return numerator / denominator\n\n\ndef run_case(case_params):\n    # Fixed physical parameters\n    L, rho, nu, U0, dt, sigma_factor = 1.0, 1.0, 1e-3, 1.0, 1e-3, 0.1\n    \n    # Case-specific parameters\n    Nx, Ny = case_params['Nx'], case_params['Ny']\n    method = case_params['method']\n    alpha_p = case_params.get('alpha_p')\n    N_corr = case_params.get('N_corr')\n\n    # Setup\n    dx, dy, xx, yy, au, sigma = setup_grid_and_params(L, Nx, Ny, rho, nu, dt, sigma_factor)\n    u_star, v_star = get_predictor_velocities(rho, U0, dt, L, au, sigma, xx, yy)\n    lap_mat = get_laplacian_matrix(Nx, Ny, dx, dy)\n    D = dt / (rho * au) # D = \\Delta t / (\\rho a_u)\n    \n    p = np.zeros((Nx, Ny))\n\n    if method == 'SIMPLE':\n        num_inner_iter = 10 # A reasonable number of inner iterations for the SIMPLE loop\n        b = -compute_divergence(u_star, v_star, dx, dy)\n        \n        # We solve -D \\nabla^2 p_total = b, which is equivalent to -\\nabla^2 p_total = b/D\n        poisson_rhs_total = b.flatten() / D\n        p_total_flat = spsolve(lap_mat, poisson_rhs_total)\n        \n        p_flat = p.flatten()\n        # This is a Richardson iteration to solve for the pressure\n        for _ in range(num_inner_iter):\n            pc_flat = p_total_flat - p_flat\n            p_flat += alpha_p * pc_flat\n            \n        p = p_flat.reshape((Nx, Ny))\n\n    elif method == 'PISO':\n        # Start with predictor field\n        u_curr, v_curr = u_star.copy(), v_star.copy()\n        \n        for _ in range(N_corr):\n            b_corr = -compute_divergence(u_curr, v_curr, dx, dy)\n            # Solve -D \\nabla^2 p_c = b_corr => -\\nabla^2 p_c = b_corr / D\n            poisson_rhs_corr = b_corr.flatten() / D\n            pc_flat = spsolve(lap_mat, poisson_rhs_corr)\n            pc = pc_flat.reshape((Nx, Ny))\n\n            p += pc\n            \n            # Update velocity from total pressure and original predictor u*\n            grad_px, grad_py = compute_gradient(p, dx, dy)\n            u_curr = u_star - D * grad_px\n            v_curr = v_star - D * grad_py\n\n    return compute_checkerboard_amplitude(p)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'method': 'SIMPLE', 'alpha_p': 0.2},\n        {'Nx': 32, 'Ny': 32, 'method': 'SIMPLE', 'alpha_p': 0.8},\n        {'Nx': 32, 'Ny': 32, 'method': 'PISO', 'N_corr': 2, 'alpha_p': 1.0},\n        {'Nx': 16, 'Ny': 16, 'method': 'SIMPLE', 'alpha_p': 0.8},\n        {'Nx': 32, 'Ny': 32, 'method': 'PISO', 'N_corr': 3, 'alpha_p': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        amplitude = run_case(case)\n        results.append(f\"{amplitude:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}