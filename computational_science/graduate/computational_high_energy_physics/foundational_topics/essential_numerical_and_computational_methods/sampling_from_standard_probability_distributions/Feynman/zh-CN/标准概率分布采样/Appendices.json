{
    "hands_on_practices": [
        {
            "introduction": "在对撞机物理学中，垂直于束流轴的横向动量（$p_T$）是一个关键的可观测量。本练习  将引导您从第一性原理出发，在动量分量服从高斯分布的假设下，推导出 $p_T$ 的分布，即瑞利分布。通过实现逆变换采样法并对其进行统计验证，您将掌握变量替换定理和一种基础采样技术，并学会如何确保模拟的准确性。",
            "id": "3532740",
            "problem": "你需要为一个对撞机事件中的各向同性软背景建模，其中一条重建径迹的横向动量分量 $p_{x}$ 和 $p_{y}$ 被建模为均值为零、方差为 $\\sigma^{2}$ 的独立同分布高斯随机变量。在本练习中，将所有变量视为无量纲。从独立高斯变量的联合密度和变量替换定理出发，推导横向动量大小 $p_{T} = \\sqrt{p_{x}^{2} + p_{y}^{2}}$ 的分布。你的推导必须从独立高斯变量联合密度的基本定义以及到极坐标变换的雅可比行列式开始，不得使用目标分布的任何预先给定的形式。然后，求出累积分布函数 (CDF) 并推导其反函数，以便从 $[0,1)$ 上的均匀分布中对 $p_{T}$ 进行逆变换采样。\n\n为 $p_{T}$ 实现两种采样器：\n- 一个通过变换高斯分量实现的采样器：独立地抽取 $p_{x} \\sim \\mathcal{N}(0,\\sigma^{2})$ 和 $p_{y} \\sim \\mathcal{N}(0,\\sigma^{2})$，然后返回 $p_{T}=\\sqrt{p_{x}^{2}+p_{y}^{2}}$。\n- 一个逆变换采样器：抽取 $U \\sim \\mathrm{Uniform}[0,1)$，并使用你推导出的逆累积分布函数 (CDF) 对 $U$ 进行变换。为保证在 $U \\approx 0$ 附近的数值稳定性，请使用基于 $\\log1p$ 的公式来实现，以避免灾难性抵消。\n\n使用以下具有固定种子和样本大小的测试套件。所有随机数生成都必须使用带有固定种子的现代伪随机数生成器，以确保可复现性。\n\n参考定义：\n- $\\mathcal{N}(0,\\sigma^{2})$ 的概率密度函数 (PDF) 是 $f(x) = \\dfrac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\!\\left(-\\dfrac{x^{2}}{2\\sigma^{2}}\\right)$。\n- 累积分布函数 (CDF) 是概率密度函数从 $-\\infty$ 到其参数的积分。\n- Kolmogorov–Smirnov (KS) 统计量是经验累积分布函数与理论累积分布函数之间绝对差的上确界；Kolmogorov–Smirnov (KS) 检验为拟合优度提供一个 $p$-值。\n\n测试套件与要求输出：\n- 情况 A (均值检查)：使用逆变换采样器，设置 $\\sigma = 1.25$，样本大小 $N = 2\\times 10^{5}$，种子 $s_{1} = 123456$。计算经验均值 $\\hat{\\mu}$ 并与推导出的分布的理论均值 $\\mu_{\\mathrm{th}}$ 进行比较。输出一个布尔值，指示相对误差 $\\left|\\hat{\\mu}-\\mu_{\\mathrm{th}}\\right|/\\mu_{\\mathrm{th}}$ 是否小于 $\\epsilon_{\\mu} = 0.01$（以十进制表示）。\n- 情况 B (方差检查)：使用与情况 A 相同的样本，计算经验方差 $\\widehat{\\mathrm{Var}}$ 并与理论方差 $\\mathrm{Var}_{\\mathrm{th}}$ 进行比较。输出一个布尔值，指示相对误差 $\\left|\\widehat{\\mathrm{Var}}-\\mathrm{Var}_{\\mathrm{th}}\\right|/\\mathrm{Var}_{\\mathrm{th}}$ 是否小于 $\\epsilon_{\\mathrm{var}} = 0.02$（以十进制表示）。\n- 情况 C (单样本 Kolmogorov–Smirnov 拟合优度)：使用与情况 A 相同的样本，计算原假设为样本遵循给定 $\\sigma$ 的推导分布时的 Kolmogorov–Smirnov $p$-值。将该 $p$-值作为一个浮点数输出，保留 $6$ 位小数。\n- 情况 D (逆变换数值稳定性)：对于 $\\sigma = 2.0$ 和均匀分布输入 $U \\in \\{0,\\;10^{-12},\\;0.5,\\;1-10^{-12}\\}$，计算逆变换采样器的输出，并将这四个值作为一个浮点数列表返回，每个值保留 $6$ 位小数，顺序与所列的 $U$ 值相对应。\n- 情况 E (双样本分布一致性)：设 $\\sigma = 0.8$，$N = 1.5\\times 10^{5}$。使用高斯分量法和种子 $s_{2} = 20231017$ 生成一个样本，并使用逆变换采样器和种子 $s_{3} = 424242$ 生成另一个独立样本。计算这两个样本之间的双样本 Kolmogorov–Smirnov 统计量。输出一个布尔值，指示该统计量是否小于 $\\delta = 0.02$（以十进制表示）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的条目按以下顺序排列：\n$[\\text{mean\\_ok},\\text{var\\_ok},\\text{ks\\_p\\_value},\\text{inverse\\_values},\\text{twosample\\_ok}]$，\n其中 $\\text{mean\\_ok}$、$\\text{var\\_ok}$ 和 $\\text{twosample\\_ok}$ 是布尔值；$\\text{ks\\_p\\_value}$ 是一个保留 $6$ 位小数的浮点数；$\\text{inverse\\_values}$ 是一个包含四个浮点数的列表，每个浮点数保留 $6$ 位小数。例如，一个语法正确的行应如下所示：$[{\\rm True},{\\rm True},0.123456,[0.000000,1.234567,2.345678,9.876543],{\\rm True}]$（此处的数字仅为示例）。",
            "solution": "本问题要求推导横向动量大小 $p_{T}$ 的概率分布，然后实现并测试两种采样方法。推导必须从第一性原理开始。\n\n### 第 1 部分：$p_{T}$ 分布的推导\n\n给定横向动量分量 $p_x$ 和 $p_y$ 是来自均值为 $0$、方差为 $\\sigma^2$ 的高斯分布的独立同分布 (i.i.d.) 随机变量。对于这样一个变量，比如 $z$，其概率密度函数 (PDF) 为：\n$$\nf(z; \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{z^2}{2\\sigma^2}\\right)\n$$\n由于 $p_x$ 和 $p_y$ 是独立的，它们的联合 PDF $f(p_x, p_y)$ 是它们各自 PDF 的乘积：\n$$\nf(p_x, p_y) = f(p_x; \\sigma) f(p_y; \\sigma) = \\left(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\right) \\exp\\left(-\\frac{p_x^2}{2\\sigma^2}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}\\sigma}\\right) \\exp\\left(-\\frac{p_y^2}{2\\sigma^2}\\right)\n$$\n$$\nf(p_x, p_y) = \\frac{1}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_x^2 + p_y^2}{2\\sigma^2}\\right)\n$$\n横向动量大小定义为 $p_T = \\sqrt{p_x^2 + p_y^2}$。为了找到 $p_T$ 的分布，我们进行变量替换，从笛卡尔坐标 $(p_x, p_y)$ 变换到极坐标 $(p_T, \\theta)$，其中：\n$$\np_x = p_T \\cos\\theta\n$$\n$$\np_y = p_T \\sin\\theta\n$$\n变换的范围是 $p_T \\in [0, \\infty)$ 和 $\\theta \\in [0, 2\\pi)$。变量替换定理指出，新的联合 PDF $g(p_T, \\theta)$ 与原始 PDF $f(p_x, p_y)$ 通过变换的雅可比行列式的绝对值 $|J|$ 相关联。\n$$\ng(p_T, \\theta) = f(p_x(p_T, \\theta), p_y(p_T, \\theta)) |J|\n$$\n雅可比行列式 $J$ 为：\n$$\nJ = \\det \\begin{pmatrix} \\frac{\\partial p_x}{\\partial p_T} & \\frac{\\partial p_x}{\\partial \\theta} \\\\ \\frac{\\partial p_y}{\\partial p_T} & \\frac{\\partial p_y}{\\partial \\theta} \\end{pmatrix} = \\det \\begin{pmatrix} \\cos\\theta & -p_T \\sin\\theta \\\\ \\sin\\theta & p_T \\cos\\theta \\end{pmatrix} = (p_T \\cos^2\\theta) - (-p_T \\sin^2\\theta) = p_T(\\cos^2\\theta + \\sin^2\\theta) = p_T\n$$\n由于 $p_T \\ge 0$，我们有 $|J| = p_T$。我们还注意到 $p_x^2 + p_y^2 = (p_T\\cos\\theta)^2 + (p_T\\sin\\theta)^2 = p_T^2$。将这些代入变换公式，得到 $p_T$ 和 $\\theta$ 的联合 PDF：\n$$\ng(p_T, \\theta) = \\frac{1}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) p_T\n$$\n为了求出 $p_T$ 的边际 PDF（我们记作 $h(p_T)$），我们将联合 PDF $g(p_T, \\theta)$ 对 $\\theta$ 的所有可能值进行积分：\n$$\nh(p_T) = \\int_0^{2\\pi} g(p_T, \\theta) \\,d\\theta = \\int_0^{2\\pi} \\frac{p_T}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) \\,d\\theta\n$$\n被积函数与 $\\theta$ 无关，所以我们有：\n$$\nh(p_T) = \\frac{p_T}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) \\int_0^{2\\pi} 1 \\,d\\theta = \\frac{p_T}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) [2\\pi]\n$$\n$$\nh(p_T) = \\frac{p_T}{\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right), \\quad \\text{for } p_T \\ge 0\n$$\n这是尺度参数为 $\\sigma$ 的瑞利分布的 PDF。\n\n### 第 2 部分：累积分布函数 (CDF) 和逆变换采样\n\nCDF $F(p_T)$ 是 PDF 从 $0$ 到某个值 $p_T$ 的积分：\n$$\nF(p_T) = \\int_0^{p_T} h(t) \\,dt = \\int_0^{p_T} \\frac{t}{\\sigma^2} \\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right) \\,dt\n$$\n我们使用换元法，令 $u = \\frac{t^2}{2\\sigma^2}$，这意味着 $du = \\frac{2t}{2\\sigma^2} dt = \\frac{t}{\\sigma^2} dt$。积分上下限从 $t=0$ 变为 $u=0$，从 $t=p_T$ 变为 $u = p_T^2/(2\\sigma^2)$。\n$$\nF(p_T) = \\int_0^{p_T^2/(2\\sigma^2)} e^{-u} \\,du = \\left[-e^{-u}\\right]_0^{p_T^2/(2\\sigma^2)} = -e^{-p_T^2/(2\\sigma^2)} - (-e^0) = 1 - \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right)\n$$\n对于逆变换采样，我们将 CDF 等于一个从 $[0,1)$ 上的均匀分布中抽取的随机变量 $U$，即 $U = F(p_T)$，然后解出 $p_T$：\n$$\nU = 1 - \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right)\n$$\n$$\n1-U = \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right)\n$$\n$$\n\\ln(1-U) = -\\frac{p_T^2}{2\\sigma^2}\n$$\n$$\np_T^2 = -2\\sigma^2 \\ln(1-U)\n$$\n$$\np_T = \\sqrt{-2\\sigma^2 \\ln(1-U)}\n$$\n这就是逆 CDF，$p_T = F^{-1}(U)$。为了在 $U$ 接近 $0$ 时保持数值稳定性，$\\ln(1-U)$ 这一项可能会遭受灾难性抵消。我们使用函数 $\\mathrm{log1p}(x) = \\ln(1+x)$，该函数的实现对于小的 $|x|$ 是精确的。我们可以将 $\\ln(1-U)$ 写为 $\\mathrm{log1p}(-U)$。数值稳定的公式是：\n$$\np_T = \\sqrt{-2\\sigma^2 \\mathrm{log1p}(-U)}\n$$\n\n### 第 3 部分：理论矩\n\n为了进行验证测试，我们需要瑞利分布的理论均值 ($\\mu_{\\mathrm{th}}$) 和理论方差 ($\\mathrm{Var}_{\\mathrm{th}}$)。\n均值是 $p_T$ 的期望值：\n$$\n\\mu_{\\mathrm{th}} = E[p_T] = \\int_0^\\infty p_T h(p_T) \\,dp_T = \\int_0^\\infty \\frac{p_T^2}{\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) \\,dp_T\n$$\n该积分的计算结果为：\n$$\n\\mu_{\\mathrm{th}} = \\sigma \\sqrt{\\frac{\\pi}{2}}\n$$\n二阶矩是 $p_T^2$ 的期望值：\n$$\nE[p_T^2] = \\int_0^\\infty p_T^2 h(p_T) \\,dp_T = \\int_0^\\infty \\frac{p_T^3}{\\sigma^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma^2}\\right) \\,dp_T\n$$\n该积分的计算结果为：\n$$\nE[p_T^2] = 2\\sigma^2\n$$\n方差则由 $\\mathrm{Var}_{\\mathrm{th}} = E[p_T^2] - (E[p_T])^2$ 给出：\n$$\n\\mathrm{Var}_{\\mathrm{th}} = 2\\sigma^2 - \\left(\\sigma\\sqrt{\\frac{\\pi}{2}}\\right)^2 = 2\\sigma^2 - \\sigma^2 \\frac{\\pi}{2} = \\sigma^2\\left(2 - \\frac{\\pi}{2}\\right)\n$$\n这些公式将用于验证生成的样本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef sampler_gauss_components(sigma, n_samples, rng):\n    \"\"\"\n    Generates pT samples by transforming Gaussian-distributed components.\n    p_x, p_y ~ N(0, sigma^2)\n    pT = sqrt(p_x^2 + p_y^2)\n    \"\"\"\n    px = rng.normal(loc=0.0, scale=sigma, size=n_samples)\n    py = rng.normal(loc=0.0, scale=sigma, size=n_samples)\n    return np.sqrt(px**2 + py**2)\n\ndef sampler_inverse_transform(sigma, n_samples, rng, u_values=None):\n    \"\"\"\n    Generates pT samples using inverse transform sampling from the derived CDF.\n    Uses log1p for numerical stability.\n    If u_values is provided, it transforms those instead of generating new ones.\n    \"\"\"\n    if u_values is None:\n        u_values = rng.uniform(low=0.0, high=1.0, size=n_samples)\n    \n    # The term np.log1p(-u_values) is equivalent to np.log(1-u_values) but\n    # provides higher precision for small u_values.\n    # It handles u_values=0 correctly, returning 0.\n    with np.errstate(divide='ignore'): # ignore log(0) warning for u=1\n        return np.sqrt(-2 * sigma**2 * np.log1p(-u_values))\n\ndef solve():\n    \"\"\"\n    Performs all derivations, implementations, and tests as specified in the problem.\n    \"\"\"\n    \n    results = []\n\n    # Case A, B, C setup\n    sigma_A = 1.25\n    N_A = 2 * 10**5\n    seed_1 = 123456\n    rng_A = np.random.default_rng(seed_1)\n    \n    # Generate one sample for cases A, B, C\n    samples_A = sampler_inverse_transform(sigma_A, N_A, rng_A)\n\n    # --- Case A: Mean Check ---\n    mu_th = sigma_A * np.sqrt(np.pi / 2.0)\n    mu_hat = np.mean(samples_A)\n    rel_error_mu = np.abs(mu_hat - mu_th) / mu_th\n    epsilon_mu = 0.01\n    mean_ok = rel_error_mu  epsilon_mu\n    \n    # --- Case B: Variance Check ---\n    var_th = sigma_A**2 * (2.0 - np.pi / 2.0)\n    var_hat = np.var(samples_A)\n    rel_error_var = np.abs(var_hat - var_th) / var_th\n    epsilon_var = 0.02\n    var_ok = rel_error_var  epsilon_var\n\n    # --- Case C: One-sample KS Goodness-of-Fit ---\n    # The derived distribution is a Rayleigh distribution with scale=sigma.\n    # We use scipy.stats.rayleigh for the theoretical CDF.\n    # The parameters for scipy.stats.rayleigh are (loc, scale).\n    _, ks_p_value = stats.kstest(samples_A, 'rayleigh', args=(0, sigma_A))\n\n    # --- Case D: Inverse Transform Numerical Stability ---\n    sigma_D = 2.0\n    u_values_D = np.array([0.0, 1e-12, 0.5, 1.0 - 1e-12])\n    inverse_values = sampler_inverse_transform(sigma_D, n_samples=None, rng=None, u_values=u_values_D)\n\n    # --- Case E: Two-sample Distributional Consistency ---\n    sigma_E = 0.8\n    N_E = int(1.5 * 10**5)\n    seed_2 = 20231017\n    seed_3 = 424242\n    delta = 0.02\n\n    rng_E2 = np.random.default_rng(seed_2)\n    sample_E_gauss = sampler_gauss_components(sigma_E, N_E, rng_E2)\n\n    rng_E3 = np.random.default_rng(seed_3)\n    sample_E_inv = sampler_inverse_transform(sigma_E, N_E, rng_E3)\n\n    ks_stat_2samp, _ = stats.ks_2samp(sample_E_gauss, sample_E_inv)\n    twosample_ok = ks_stat_2samp  delta\n\n    # --- Format and Print Final Output ---\n    # Format the list of floats for Case D as a string to match the required output style\n    inverse_values_str = f\"[{','.join([f'{v:.6f}' for v in inverse_values])}]\"\n\n    # Assemble the final result string\n    final_output_str = (\n        f\"[{mean_ok},\"\n        f\"{var_ok},\"\n        f\"{ks_p_value:.6f},\"\n        f\"{inverse_values_str},\"\n        f\"{twosample_ok}]\"\n    )\n    \n    # Python's f-string formatting of booleans is 'True'/'False', which matches the required output.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "生成正态分布随机数是几乎所有物理模拟的基石，从探测器响应到理论建模都离不开它。本练习  旨在比较两种从均匀分布生成高斯变量的经典方法：Box-Muller 变换和 Marsaglia 极坐标法。除了推导算法本身，本练习的核心挑战在于分析它们在现代并行计算架构（如 GPU）上的性能，这会引导您思考分支分化和线程束（warp）执行等对高性能科学计算至关重要的概念。",
            "id": "3532699",
            "problem": "你需要构建一个完整的、可运行的程序，用于在计算高能物理背景下，比较通过 Box–Muller 方法和 Marsaglia 极坐标方法从标准正态分布中采样。从标准正态分布的概率密度函数和单位区间上均匀分布的基本定义出发，推导从独立均匀分布随机数对到独立标准正态分布随机数对的变换，并量化在单指令多线程 (SIMT) 图形处理单元 (GPU) 执行模型下的分支发散和期望运行时间。所有角度必须以弧度为单位处理。\n\n你的程序必须实现以下从第一性原理推导出的任务：\n\n- 基本定义：\n  - 两个单位区间上的独立均匀随机变量 $U_1$ 和 $U_2$ 服从 $U_1,U_2 \\sim \\mathrm{Uniform}(0,1)$。\n  - 一个标准正态随机变量 $Z$ 的概率密度函数为 $f_Z(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-z^2/2)$。\n\n- Box–Muller 方法：\n  - 使用变量替换和二维联合高斯分布的极坐标表示，推导并论证从 $U_1,U_2$ 到两个独立标准正态变量的变换。\n  - 该方法必须不含接受/拒绝分支。你必须假设角度以弧度为单位。\n\n- Marsaglia 极坐标方法：\n  - 通过在单位圆盘上的接受/拒绝步骤以及利用二维平滑映射下的概率守恒进行径向重新缩放，推导并论证从正方形上的两个独立抽样到采样的规则。\n  - 使用几何概率，推导接受概率 $p$ 以及每个线程直到首次接受所需的迭代次数的分布。将后者建模为一个支撑集为正整数的几何随机变量。\n\n- 用于期望迭代次数和发散的 SIMT warp 模型：\n  - 考虑一个包含 $W$ 个独立线程的 warp，每个线程需要一个被接受的数对。令 $G_i$ 表示线程 $i$ 在 Marsaglia 极坐标方法下直到首次接受所进行的接受/拒绝迭代次数。\n  - 从基本概率和独立性出发，推导最大值 $M_W = \\max\\{G_1,\\dots,G_W\\}$ 的分布函数的精确表达式，并由此推导其期望 $\\mathbb{E}[M_W]$ 的一个收敛级数表达式。\n  - 定义当所有 $W$ 个线程都活跃时，初始的每次迭代分支发散概率 $D_0$ 为在第一次迭代中，并非所有线程都做出相同分支决策的概率。用 $p$ 和 $W$ 表示 $D_0$。\n  - 定义在一个 warp 内部，接受分支被执行至少一次的期望迭代次数（即，在活跃线程中至少有一次接受的迭代）。利用期望的线性和独立性，推导其期望 $\\mathbb{E}[K_W]$ 的一个收敛级数。\n\n- 基于操作计数的成本模型：\n  - 假设每种算法的操作计数如下：\n    - Box–Muller 方法每生成一对正态分布随机数：\n      - 均匀抽样：$2$ 次。\n      - 超越函数：一次 $\\log$ 和一次 $\\sqrt$ 合并计算成本；一次 $\\sin$ 和一次 $\\cos$ 合并计算成本。\n      - 基本算术运算：$4$ 次。\n    - Marsaglia 极坐标方法每次迭代尝试（由所有活跃线程在每次迭代中执行）：\n      - 均匀抽样：$2$ 次。\n      - 基本算术运算：$7$ 次运算，用于映射到正方形、计算 $S$ 和比较。\n    - Marsaglia 极坐标方法接受路径的额外操作（在 warp 中至少有一次接受的迭代中执行）：\n      - 超越函数：一次 $\\log$ 和一次 $\\sqrt$ 合并计算成本。\n      - 基本算术运算：$4$ 次运算，用于缩放和形成输出。\n  - 定义成本参数：\n    - $c_{\\mathrm{uni}}$ = 一次均匀抽样的成本。\n    - $c_{\\mathrm{basic}}$ = 一次基本算术运算的成本。\n    - $c_{\\log\\sqrt}$ = 一次 $\\log$ 和一次 $\\sqrt$ 的合并成本。\n    - $c_{\\mathrm{trigpair}}$ = 一次 $\\sin$ 和一次 $\\cos$ 的合并成本。\n  - 根据这些计数和成本，定义：\n    - Box–Muller 方法每个 warp 每生成一对正态分布随机数的时间：$T_{\\mathrm{BM}} = 2 c_{\\mathrm{uni}} + c_{\\log\\sqrt} + c_{\\mathrm{trigpair}} + 4 c_{\\mathrm{basic}}$。\n    - Marsaglia 极坐标方法每个 warp 每生成一对正态分布随机数的时间：$T_{\\mathrm{MP}} = \\mathbb{E}[M_W]\\,(2 c_{\\mathrm{uni}} + 7 c_{\\mathrm{basic}}) + \\mathbb{E}[K_W]\\,(c_{\\log\\sqrt} + 4 c_{\\mathrm{basic}})$。\n  - 定义占用开销因子 $F_{\\mathrm{occ}} = \\mathbb{E}[M_W]\\,p$，以量化相对于相同条件下单线程期望的减速情况。\n\n- 每个测试用例的必需输出：\n  - 接受概率 $p$。\n  - Marsaglia 极坐标方法的期望 warp 迭代次数 $\\mathbb{E}[M_W]$。\n  - 所有 $W$ 个线程都活跃时的初始发散概率 $D_0$。\n  - 占用开销因子 $F_{\\mathrm{occ}}$。\n  - Box–Muller 方法每个 warp 每对的时间 $T_{\\mathrm{BM}}$。\n  - Marsaglia 极坐标方法每个 warp 每对的时间 $T_{\\mathrm{MP}}$。\n  - 比率 $R = T_{\\mathrm{MP}}/T_{\\mathrm{BM}}$。\n\n测试套件：\n- 每个测试用例指定 $(W, c_{\\mathrm{uni}}, c_{\\mathrm{basic}}, c_{\\log\\sqrt}, c_{\\mathrm{trigpair}})$。\n- 使用以下四种情况：\n  - 情况 A（单线程边界）：$W = 1$, $c_{\\mathrm{uni}} = 1.0$, $c_{\\mathrm{basic}} = 0.25$, $c_{\\log\\sqrt} = 10.0$, $c_{\\mathrm{trigpair}} = 8.0$。\n  - 情况 B（小 warp）：$W = 8$, $c_{\\mathrm{uni}} = 1.0$, $c_{\\mathrm{basic}} = 0.25$, $c_{\\log\\sqrt} = 10.0$, $c_{\\mathrm{trigpair}} = 8.0$。\n  - 情况 C（典型 NVIDIA warp）：$W = 32$, $c_{\\mathrm{uni}} = 1.0$, $c_{\\mathrm{basic}} = 0.25$, $c_{\\log\\sqrt} = 10.0$, $c_{\\mathrm{trigpair}} = 8.0$。\n  - 情况 D（典型 AMD wavefront）：$W = 64$, $c_{\\mathrm{uni}} = 1.0$, $c_{\\mathrm{basic}} = 0.25$, $c_{\\log\\sqrt} = 10.0$, $c_{\\mathrm{trigpair}} = 8.0$。\n\n角度单位规范：\n- 所有三角函数必须使用以弧度为单位的角度。\n\n最终输出格式：\n- 你的程序必须生成单行，包含一个由四个内部列表组成的列表，每个测试用例一个。每个内部列表必须按 $[p,\\ \\mathbb{E}[M_W],\\ D_0,\\ F_{\\mathrm{occ}},\\ T_{\\mathrm{BM}},\\ T_{\\mathrm{MP}},\\ R]$ 的顺序排列，所有条目均为十进制浮点数。外部列表必须用方括号括起来，内部列表必须用逗号分隔。例如，一个结构正确的输出看起来像 $[[x_1,x_2,\\dots,x_7],[y_1,y_2,\\dots,y_7],[z_1,\\dots,z_7],[w_1,\\dots,w_7]]$，其中每个 $x_i,y_i,z_i,w_i$ 都是一个浮点数。",
            "solution": "该问题是有效的，因为它在科学上基于已建立的概率论和计算模型，问题陈述清晰，信息充分且一致，并且可以形式化为一个可解的结构。解决方案通过从第一性原理推导必要的数学表达式，然后进行数值实现，以评估给定测试用例的指定性能指标。\n\n### 1. Box–Muller 方法：推导\nBox–Muller 方法从两个独立的均匀分布变量 $U_1, U_2 \\sim \\mathrm{Uniform}(0,1)$ 生成两个独立的标准正态变量 $Z_1$ 和 $Z_2$。\n\n令 $Z_1$ 和 $Z_2$ 为独立的标准正态随机变量。它们的联合概率密度函数 (PDF) 由它们各自 PDF 的乘积给出：\n$$f_{Z_1, Z_2}(z_1, z_2) = f_{Z_1}(z_1) f_{Z_2}(z_2) = \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_1^2/2}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_2^2/2}\\right) = \\frac{1}{2\\pi} e^{-(z_1^2 + z_2^2)/2}$$\n我们进行变量替换到极坐标 $(R, \\Theta)$，其中 $z_1 = r\\cos\\theta$ 和 $z_2 = r\\sin\\theta$。定义域为 $r \\in [0, \\infty)$，且根据问题指定使用弧度，$\\theta \\in [0, 2\\pi)$。半径的平方为 $r^2 = z_1^2 + z_2^2$。\n\n从 $(r, \\theta)$到 $(z_1, z_2)$ 的此变换的雅可比行列式为：\n$$|J| = \\left| \\det \\begin{pmatrix} \\frac{\\partial z_1}{\\partial r}  \\frac{\\partial z_1}{\\partial \\theta} \\\\ \\frac{\\partial z_2}{\\partial r}  \\frac{\\partial z_2}{\\partial \\theta} \\end{pmatrix} \\right| = \\left| \\det \\begin{pmatrix} \\cos\\theta  -r\\sin\\theta \\\\ \\sin\\theta  r\\cos\\theta \\end{pmatrix} \\right| = r\\cos^2\\theta + r\\sin^2\\theta = r$$\n极坐标下的联合 PDF 为 $g(r, \\theta) = f_{Z_1, Z_2}(r\\cos\\theta, r\\sin\\theta) |J|$，这给出：\n$$g(r, \\theta) = \\frac{1}{2\\pi} e^{-r^2/2} \\cdot r = \\left(r e^{-r^2/2}\\right) \\left(\\frac{1}{2\\pi}\\right)$$\n这个 PDF 可以分离成一个关于 $r$ 的函数和一个关于 $\\theta$ 的函数，这意味着随机变量 $R$ 和 $\\Theta$ 是独立的。$\\Theta$ 的边缘 PDF 是 $g_\\Theta(\\theta) = \\frac{1}{2\\pi}$ 对于 $\\theta \\in [0, 2\\pi)$，这是一个均匀分布。$R$ 的边缘 PDF 是 $g_R(r) = r e^{-r^2/2}$ 对于 $r \\ge 0$，这是一个瑞利分布。\n\n为了生成 $R$ 和 $\\Theta$ 的样本，我们使用逆变换采样法。\n对于角度 $\\Theta$，我们可以抽取 $U_2 \\sim \\mathrm{Uniform}(0,1)$ 并设置 $\\Theta = 2\\pi U_2$。\n对于半径 $R$，首先找到 $S = R^2$ 的分布会更容易。使用 $s=r^2$（因此 $r=\\sqrt{s}$ 和 $dr/ds = 1/(2\\sqrt{s})$）的变量替换公式：\n$$g_S(s) = g_R(\\sqrt{s}) \\left|\\frac{dr}{ds}\\right| = \\sqrt{s} e^{-s/2} \\cdot \\frac{1}{2\\sqrt{s}} = \\frac{1}{2}e^{-s/2}$$\n这是率参数为 $\\lambda=1/2$ 的指数分布的 PDF。我们可以通过抽取 $U_1 \\sim \\mathrm{Uniform}(0,1)$ 并设置 $s = F_S^{-1}(U_1)$ 来从此分布生成一个样本 $s$。其累积分布函数 (CDF) 是 $F_S(s) = 1 - e^{-s/2}$。对其求逆得到 $s = -2\\ln(1-U_1)$。由于 $1-U_1$ 在 $(0,1)$ 上也是均匀分布，我们可以将其简化为 $S = -2\\ln(U_1)$。\n\n因此，完整的变换是：\n1. 生成 $U_1, U_2 \\sim \\mathrm{Uniform}(0,1)$。\n2. 计算 $R = \\sqrt{-2\\ln U_1}$ 和 $\\Theta = 2\\pi U_2$。\n3. 变换回笛卡尔坐标以获得标准正态变量：\n$$Z_1 = R \\cos(\\Theta) = \\sqrt{-2\\ln U_1} \\cos(2\\pi U_2)$$\n$$Z_2 = R \\sin(\\Theta) = \\sqrt{-2\\ln U_1} \\sin(2\\pi U_2)$$\n此方法没有分支。\n\n### 2. Marsaglia 极坐标方法：推导\n此方法避免了 Box-Muller 方法中的三角函数。\n1. 生成两个独立的均匀分布变量 $V_1, V_2 \\sim \\mathrm{Uniform}(-1,1)$。这可以通过抽取 $U_1', U_2' \\sim \\mathrm{Uniform}(0,1)$ 并设置 $V_1=2U_1'-1$, $V_2=2U_2'-1$ 来完成。\n2. 计算 $S = V_1^2 + V_2^2$。\n3. 如果 $S=0$ 或 $S1$，则点 $(V_1, V_2)$ 被拒绝，返回步骤 1。否则，该点被接受。\n\n**接受概率 ($p$)：**\n点 $(V_1, V_2)$ 在正方形 $[-1,1] \\times [-1,1]$ 内均匀分布，其面积为 $A_{\\mathrm{square}}=2 \\times 2 = 4$。接受区域是单位圆盘 $S \\le 1$，其面积为 $A_{\\mathrm{disk}}=\\pi (1)^2 = \\pi$。接受概率 $p$ 是这些面积的比值：\n$$p = \\frac{A_{\\mathrm{disk}}}{A_{\\mathrm{square}}} = \\frac{\\pi}{4}$$\n\n**变换：**\n一个被接受的点 $(V_1, V_2)$ 在单位圆盘内是均匀分布的。令此点为 $(X,Y)$。我们想找到其半径平方 $S=X^2+Y^2$ 的分布。$R=\\sqrt{S}$ 的 CDF 是 $F_R(r) = P(R \\le r)$。对于单位圆盘上的均匀分布，这个概率是半径为 $r$ 的圆盘面积与单位圆盘面积的比值：$F_R(r) = \\frac{\\pi r^2}{\\pi (1)^2} = r^2$ 对于 $r \\in [0,1]$。\n$S=R^2$ 的 CDF 则是 $F_S(s) = P(S \\le s) = P(R^2 \\le s) = P(R \\le \\sqrt{s}) = (\\sqrt{s})^2 = s$ 对于 $s \\in [0,1]$。这是 $\\mathrm{Uniform}(0,1)$ 分布的 CDF。\n\n因此，对于一个被接受的数对，值 $S=V_1^2+V_2^2$ 是一个来自 $\\mathrm{Uniform}(0,1)$ 的随机变量。我们可以在 Box-Muller 逻辑中使用这个 $S$ 来代替 $U_1$。我们设置一个径向因子 $\\sqrt{-2\\ln S}$。点 $(V_1, V_2)$ 的角度 $\\Theta$ 满足 $\\cos\\Theta = V_1/\\sqrt{S}$ 和 $\\sin\\Theta = V_2/\\sqrt{S}$。将这些代入 Box-Muller 公式得到：\n$$Z_1 = \\sqrt{-2\\ln S} \\cos(\\Theta) = \\sqrt{-2\\ln S} \\frac{V_1}{\\sqrt{S}} = V_1 \\sqrt{\\frac{-2\\ln S}{S}}$$\n$$Z_2 = \\sqrt{-2\\ln S} \\sin(\\Theta) = \\sqrt{-2\\ln S} \\frac{V_2}{\\sqrt{S}} = V_2 \\sqrt{\\frac{-2\\ln S}{S}}$$\n此变换产生两个独立的标准正态变量，而无需计算三角函数。其代价是接受/拒绝循环。一个线程 $i$ 获得首次接受所需的迭代次数 $G_i$ 服从成功概率为 $p=\\pi/4$ 的几何分布。其 PDF 为 $P(G_i=k) = (1-p)^{k-1}p$ 对于 $k \\in \\{1, 2, 3, \\dots\\}$。\n\n### 3. SIMT Warp 模型：推导\n考虑一个包含 $W$ 个线程的 warp，其中线程 $i$ 需要 $G_i$ 次迭代。整个 warp 在最后一个线程完成时才完成，这需要 $M_W = \\max\\{G_1, \\dots, G_W\\}$ 次迭代。\n\n**迭代次数上限的期望值 $\\mathbb{E}[M_W]$：**\n单个几何变量 $G_i$ 的 CDF 是 $F_G(k) = P(G_i \\le k) = \\sum_{j=1}^k (1-p)^{j-1}p = 1 - (1-p)^k$。\n由于 $G_i$ 是独立同分布的，它们的最大值 $M_W$ 的 CDF 是：\n$$F_{M_W}(k) = P(M_W \\le k) = P(G_1 \\le k, \\dots, G_W \\le k) = (F_G(k))^W = (1 - (1-p)^k)^W$$\n一个取值为 $\\{1, 2, \\dots\\}$ 的随机变量的期望是 $\\mathbb{E}[X] = \\sum_{k=1}^\\infty P(X \\ge k)$。这可以写成 $\\mathbb{E}[X] = \\sum_{k=0}^\\infty (1 - F_X(k))$。对于 $M_W$：\n$$\\mathbb{E}[M_W] = \\sum_{k=0}^{\\infty} (1 - F_{M_W}(k)) = \\sum_{k=0}^{\\infty} \\left[1 - (1 - (1-p)^k)^W\\right]$$\n这个无穷级数是收敛的，将进行数值计算。\n\n**初始分支发散概率 $D_0$：**\n在第一次迭代中，所有 $W$ 个线程都是活跃的。每个线程要么接受（概率为 $p$），要么拒绝（概率为 $1-p$）。如果所有线程做出相同的决策，则 warp 不会发散。\n$P(\\text{全部接受}) = p^W$\n$P(\\text{全部拒绝}) = (1-p)^W$\n发散的概率是 $D_0 = 1 - (P(\\text{全部接受}) + P(\\text{全部拒绝}))$。\n$$D_0 = 1 - (p^W + (1-p)^W)$$\n\n**有接受的期望迭代次数 $\\mathbb{E}[K_W]$：**\n在 warp 中至少有一个线程接受的迭代上会产生开销。令 $K_W$ 为这类迭代的次数。我们可以利用线性性求其期望：$\\mathbb{E}[K_W] = \\sum_{k=1}^\\infty P(\\text{迭代 } k \\text{ 至少有一次接受})$。\n事件“在迭代 $k$ 上至少有一个线程接受”是事件 $\\{G_i=k\\}$ 对 $i=1, \\dots, W$ 的并集。这些事件是独立的。\n$P(G_i=k) = (1-p)^{k-1}p$。\n$P(\\text{在迭代 } k \\text{ 上至少有一次接受}) = 1 - P(\\text{在迭代 } k \\text{ 上没有接受}) = 1 - \\prod_{i=1}^W P(G_i \\ne k)$。\n$P(G_i \\ne k) = 1 - (1-p)^{k-1}p$。\n所以，$P(\\text{在迭代 } k \\text{ 上至少有一次接受}) = 1 - (1 - (1-p)^{k-1}p)^W$。\n期望是所有可能迭代的和：\n$$\\mathbb{E}[K_W] = \\sum_{k=1}^{\\infty} \\left[1 - (1 - (1-p)^{k-1}p)^W\\right]$$\n这也是一个待数值计算的收敛级数。\n\n### 4. 成本模型与最终计算\n待计算的量定义如下：\n- **接受概率：** $p = \\pi/4$。\n- **期望 warp 迭代次数：** $\\mathbb{E}[M_W] = \\sum_{k=0}^{\\infty} [1 - (1 - (1-p)^k)^W]$。\n- **初始发散概率：** $D_0 = 1 - p^W - (1-p)^W$。\n- **占用开销因子：** $F_{\\mathrm{occ}} = \\mathbb{E}[M_W] \\, p$。这衡量了相对于理想单线程情况（平均迭代次数为 $1/p$）的减速程度。\n- **Box-Muller warp 时间：** $T_{\\mathrm{BM}} = 2 c_{\\mathrm{uni}} + c_{\\log\\sqrt} + c_{\\mathrm{trigpair}} + 4 c_{\\mathrm{basic}}$。\n- **Marsaglia 极坐标 warp 时间：** $T_{\\mathrm{MP}} = \\mathbb{E}[M_W]\\,(2 c_{\\mathrm{uni}} + 7 c_{\\mathrm{basic}}) + \\mathbb{E}[K_W]\\,(c_{\\log\\sqrt} + 4 c_{\\mathrm{basic}})$。\n- **比率：** $R = T_{\\mathrm{MP}}/T_{\\mathrm{BM}}$。\n\n将为每个测试用例计算这些量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and compares the Box-Muller and Marsaglia polar methods for\n    sampling from a standard normal distribution under a SIMT GPU execution model.\n    \"\"\"\n\n    test_cases = [\n        # (W, c_uni, c_basic, c_logsqrt, c_trigpair)\n        (1, 1.0, 0.25, 10.0, 8.0),   # Case A: Single thread\n        (8, 1.0, 0.25, 10.0, 8.0),   # Case B: Small warp\n        (32, 1.0, 0.25, 10.0, 8.0),  # Case C: NVIDIA warp\n        (64, 1.0, 0.25, 10.0, 8.0),  # Case D: AMD wavefront\n    ]\n\n    results = []\n    \n    # Acceptance probability for Marsaglia polar method\n    p = np.pi / 4.0\n\n    # Numerical summation tolerance\n    tolerance = 1e-17\n\n    for case in test_cases:\n        W, c_uni, c_basic, c_logsqrt, c_trigpair = case\n\n        # Calculate E[M_W]\n        # E[M_W] = sum_{k=0 to inf} (1 - (1 - (1-p)^k)^W)\n        q = 1.0 - p\n        expected_m_w = 0.0\n        k = 0\n        while True:\n            term = 1.0 - (1.0 - q**k)**W\n            if k > 0 and term  tolerance:\n                break\n            expected_m_w += term\n            k += 1\n            # Safety break for very slow convergence, though not expected here\n            if k > 20000:\n                break\n        \n        # Calculate E[K_W]\n        # E[K_W] = sum_{k=1 to inf} [1 - (1 - (1-p)^(k-1)*p)^W]\n        expected_k_w = 0.0\n        k = 1\n        while True:\n            term_base = 1.0 - (q**(k - 1)) * p\n            term = 1.0 - term_base**W\n            if k > 1 and term  tolerance:\n                break\n            expected_k_w += term\n            k += 1\n            if k > 20000:\n                break\n\n        # Calculate initial divergence probability D_0\n        d_0 = 1.0 - (p**W + (1.0 - p)**W)\n\n        # Calculate occupancy overhead factor F_occ\n        f_occ = expected_m_w * p\n        \n        # Calculate Box-Muller warp time T_BM\n        t_bm = 2 * c_uni + c_logsqrt + c_trigpair + 4 * c_basic\n\n        # Calculate Marsaglia polar warp time T_MP\n        t_mp_loop = expected_m_w * (2 * c_uni + 7 * c_basic)\n        t_mp_accept = expected_k_w * (c_logsqrt + 4 * c_basic)\n        t_mp = t_mp_loop + t_mp_accept\n        \n        # Calculate the ratio R\n        r = t_mp / t_bm\n\n        case_results = [\n            p,\n            expected_m_w,\n            d_0,\n            f_occ,\n            t_bm,\n            t_mp,\n            r\n        ]\n        results.append(case_results)\n\n    # Format output as specified\n    formatted_results = []\n    for res_list in results:\n        formatted_list = f\"[{','.join(f'{x:.7f}' for x in res_list)}]\"\n        formatted_results.append(formatted_list)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在实验数据分析中，我们常常需要从复杂的高维后验概率分布中采样，而直接采样方法在这种情况下通常是不可行的。本练习  将介绍解决此类问题的强大工具——Metropolis-Hastings MCMC 算法，并将其应用于径迹拟合中常见的多元高斯后验分布。通过分析算法的混合时间（通过谱隙），您将深刻理解提议分布的选择（特别是预处理技术）如何显著影响采样器的效率，这对于解决实际的推断问题至关重要。",
            "id": "3532724",
            "problem": "考虑一个Metropolis–Hastings (MH) 马尔可夫链蒙特卡洛 (MCMC) 算法，其目标分布是由线性化带电粒子追踪拟合产生的多元高斯后验分布。目标分布为零均值多元正态分布，其协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{d \\times d}$，即\n$$\n\\pi(\\mathbf{x}) \\propto \\exp\\left(-\\tfrac{1}{2}\\,\\mathbf{x}^{\\top}\\Sigma^{-1}\\mathbf{x}\\right), \\quad \\mathbf{x}\\in\\mathbb{R}^d.\n$$\n考虑两种提议机制：\n\n1. 标量、各向同性的高斯随机游走提议\n$\nq_{\\mathrm{sc}}(\\mathbf{y}\\mid \\mathbf{x}) = \\mathcal{N}(\\mathbf{y};\\,\\mathbf{x},\\, s^2 I_d),\n$\n其中 $s0$ 是提议步长。\n\n2. 与目标协方差对齐的预处理高斯随机游走提议\n$\nq_{\\mathrm{pc}}(\\mathbf{y}\\mid \\mathbf{x}) = \\mathcal{N}(\\mathbf{y};\\,\\mathbf{x},\\, s^2 \\Sigma).\n$\n\n两种提议都在标准的Metropolis–Hastings接受-拒绝步骤中使用，以使生成的马尔可夫链是$\\pi$-可逆的。\n\n您的任务是通过马尔可夫算子的谱隙来分析其在 $L^2(\\pi)$ 上的混合性质。令 $P$ 表示作用于关于 $\\pi$ 的平方可积函数上的MH转移核。$L^2(\\pi)$ 谱隙定义为\n$$\n\\mathrm{gap}(P) \\equiv 1 - \\|P\\|_{L^2_0(\\pi)\\to L^2_0(\\pi)} = \\inf_{f\\in L^2(\\pi),\\,\\mathbb{E}_{\\pi}[f]=0,\\,f\\not\\equiv 0} \\frac{\\mathcal{E}_P(f,f)}{\\mathrm{Var}_{\\pi}(f)},\n$$\n其中Dirichlet型为\n$$\n\\mathcal{E}_P(f,f) = \\tfrac{1}{2}\\,\\mathbb{E}_{\\pi}\\left[\\int \\left(f(\\mathbf{y})-f(\\mathbf{x})\\right)^2 \\,\\alpha(\\mathbf{x},\\mathbf{y})\\, q(\\mathbf{y}\\mid \\mathbf{x})\\, \\mathrm{d}\\mathbf{y}\\right],\n$$\n其中 $\\alpha(\\mathbf{x},\\mathbf{y})$ 是MH接受概率，$q$ 是提议密度。\n\n仅从上述基本定义、多元正态分布满足高斯Poincaré不等式这一事实出发\n$\n\\mathrm{Var}_{\\pi}(f) \\leq \\mathbb{E}_{\\pi}\\left[\\nabla f(\\mathbf{x})^{\\top}\\Sigma\\,\\nabla f(\\mathbf{x})\\right]\n$\n（对于足够光滑的 $f$），以及 $f(\\mathbf{y})$ 在 $\\mathbf{x}$ 附近的基本泰勒展开，完成以下任务：\n\n- 对于标量提议 $q_{\\mathrm{sc}}(\\mathbf{y}\\mid \\mathbf{x})$ 和预处理提议 $q_{\\mathrm{pc}}(\\mathbf{y}\\mid \\mathbf{x})$，在 $s\\to 0$ 的情况下，推导相应MH核的 $L^2(\\pi)$ 谱隙的小步长渐近估计。您的推导必须对标量提议给出一个用 $s$ 和 $\\Sigma$ 的特征值表示的下界估计和一个上界估计，对预处理提议给出一个与 $\\Sigma$ 的特征值无关的估计。您的推导必须通过 $\\Sigma$ 的极端特征值（记为 $\\lambda_{\\min}(\\Sigma)$ 和 $\\lambda_{\\max}(\\Sigma)$）明确表示。\n\n- 使用得到的表达式，实现一个程序，对下面列出的每个测试用例，计算三个值：标量提议谱隙的渐近下界估计、标量提议谱隙的渐近上界估计以及预处理提议谱隙的渐近估计。每个值都必须是一个实数。\n\n- 您的程序必须输出单行，其中包含一个列表的列表，每个内部列表对应一个测试用例，并按指定顺序排列。每个内部列表的形式必须是 $[\\mathrm{gap\\_lower\\_scalar}, \\mathrm{gap\\_upper\\_scalar}, \\mathrm{gap\\_preconditioned}]$，每个浮点数值必须精确到 $10$ 位小数。\n\n本问题不涉及物理单位。不出现角度。所有量均为无量纲实数。\n\n测试套件（每个测试用例是一对，由 $\\Sigma$ 的特征值列表和步长 $s$ 组成）：\n\n1. $\\left([\\;4.0\\;],\\, 0.1\\right)$\n2. $\\left([\\;1.0,\\,4.0,\\,9.0\\;],\\, 0.05\\right)$\n3. $\\left([\\;0.01,\\,1.0,\\,1.0,\\,2.0,\\,10.0\\;],\\, 0.02\\right)$\n4. $\\left([\\;3.0,\\,3.0,\\,3.0\\;],\\, 0.2\\right)$\n5. $\\left([\\;0.5,\\,1.0,\\,3.0,\\,100.0\\;],\\, 0.1\\right)$\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表的列表。例如，包含两个测试用例的输出应类似于 $[[a,b,c],[d,e,f]]$，其中每个 $a,b,c,d,e,f$ 都精确到 $10$ 位小数。",
            "solution": "此问题经评估有效，因为它在科学上基于马尔可夫链蒙特卡洛方法的理论，问题定义良好，目标明确，且无任何可指明的缺陷。可以进行推导和实现。\n\n任务是为两种不同的提议机制，推导Metropolis-Hastings (MH) 核在小步长 ($s \\to 0$) 情况下的 $L^2(\\pi)$ 谱隙的渐近估计。目标分布是一个d维零均值多元正态分布 $\\pi(\\mathbf{x}) = \\mathcal{N}(\\mathbf{x}; \\mathbf{0}, \\Sigma)$。\n\n谱隙定义为：\n$$\n\\mathrm{gap}(P) = \\inf_{f\\in L^2(\\pi),\\,\\mathbb{E}_{\\pi}[f]=0,\\,f\\not\\equiv 0} \\frac{\\mathcal{E}_P(f,f)}{\\mathrm{Var}_{\\pi}(f)}\n$$\n其中Dirichlet型为：\n$$\n\\mathcal{E}_P(f,f) = \\tfrac{1}{2}\\,\\mathbb{E}_{\\pi}\\left[\\int \\left(f(\\mathbf{y})-f(\\mathbf{x})\\right)^2 \\,\\alpha(\\mathbf{x},\\mathbf{y})\\, q(\\mathbf{y}\\mid \\mathbf{x})\\, \\mathrm{d}\\mathbf{y}\\right]\n$$\n提议具有随机游走形式 $\\mathbf{y} = \\mathbf{x} + s\\mathbf{z}$，其中 $s$ 是步长，$\\mathbf{z}$ 是一个随机向量。对于小步长 $s$，我们可以对 $f(\\mathbf{y})$ 在 $\\mathbf{x}$ 附近使用泰勒展开：\n$$\nf(\\mathbf{y}) - f(\\mathbf{x}) = f(\\mathbf{x} + s\\mathbf{z}) - f(\\mathbf{x}) = s\\nabla f(\\mathbf{x})^{\\top}\\mathbf{z} + O(s^2)\n$$\n在 $s \\to 0$ 的极限下，我们有 $\\mathbf{y} \\to \\mathbf{x}$。接受概率 $\\alpha(\\mathbf{x},\\mathbf{y}) = \\min(1, \\pi(\\mathbf{y})/\\pi(\\mathbf{x}))$ 趋近于1，因为 $\\pi(\\mathbf{y})/\\pi(\\mathbf{x}) \\to 1$。通过设 $\\alpha(\\mathbf{x},\\mathbf{y}) \\approx 1$ 并使用泰勒展开的主导项，可以得到Dirichlet型的一阶近似：\n$$\n\\mathcal{E}_P(f,f) \\approx \\tfrac{1}{2}\\,\\mathbb{E}_{\\pi;\\mathbf{x}}\\left[\\int \\left(s\\nabla f(\\mathbf{x})^{\\top}\\mathbf{z}\\right)^2 q(\\mathbf{y}\\mid \\mathbf{x})\\, \\mathrm{d}\\mathbf{y}\\right]\n$$\n该积分是关于 $\\mathbf{y}$ 的，等价于关于 $\\mathbf{z}$ 的期望。令 $C_z = \\mathbb{E}[\\mathbf{z}\\mathbf{z}^{\\top}]$ 为 $\\mathbf{z}$ 的协方差矩阵。\n$$\n\\mathcal{E}_P(f,f) \\approx \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\mathbb{E}_{\\mathbf{z}}\\left[ (\\nabla f(\\mathbf{x})^{\\top}\\mathbf{z})(\\mathbf{z}^{\\top}\\nabla f(\\mathbf{x})) \\right] \\right]\n$$\n$$\n\\mathcal{E}_P(f,f) \\approx \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\nabla f(\\mathbf{x})^{\\top} \\mathbb{E}_{\\mathbf{z}}[\\mathbf{z}\\mathbf{z}^{\\top}] \\nabla f(\\mathbf{x}) \\right] = \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\nabla f(\\mathbf{x})^{\\top} C_z \\nabla f(\\mathbf{x}) \\right]\n$$\n谱隙表达式的分母是 $\\mathrm{Var}_{\\pi}(f)$，对此问题提供了高斯Poincaré不等式：\n$$\n\\mathrm{Var}_{\\pi}(f) \\leq \\mathbb{E}_{\\pi}\\left[\\nabla f(\\mathbf{x})^{\\top}\\Sigma\\,\\nabla f(\\mathbf{x})\\right]\n$$\n已知对于形如 $f(\\mathbf{x}) = \\mathbf{v}^\\top\\mathbf{x}$ 的线性函数，该不等式变为等式。\n\n我们现在分析两种具体的提议。\n\n**1. 标量、各向同性的高斯提议 ($q_{\\mathrm{sc}}$)**\n提议为 $q_{\\mathrm{sc}}(\\mathbf{y}\\mid \\mathbf{x}) = \\mathcal{N}(\\mathbf{y};\\,\\mathbf{x},\\, s^2 I_d)$。这意味着提议增量 $\\mathbf{y}-\\mathbf{x}$ 的协方差为 $s^2 I_d$。由于我们定义了 $\\mathbf{y}-\\mathbf{x} = s\\mathbf{z}$，$\\mathbf{z}$ 的协方差为 $C_z = I_d$。\nDirichlet型的近似为：\n$$\n\\mathcal{E}_{P_{\\mathrm{sc}}}(f,f) \\approx \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\nabla f^{\\top} I_d \\nabla f \\right] = \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]\n$$\n定义谱隙的比率的渐近表达式为：\n$$\n\\frac{\\mathcal{E}_{P_{\\mathrm{sc}}}(f,f)}{\\mathrm{Var}_{\\pi}(f)} \\approx \\frac{\\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathrm{Var}_{\\pi}(f)}\n$$\n对分母使用Poincaré不等式，我们可以建立该比率的一个下界：\n$$\n\\frac{\\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathrm{Var}_{\\pi}(f)} \\geq \\frac{\\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]} = \\frac{s^2}{2} \\frac{\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]}\n$$\n期望之比由 $\\Sigma^{-1}$ 的极端特征值（即 $1/\\lambda_{\\max}(\\Sigma)$ 和 $1/\\lambda_{\\min}(\\Sigma)$）界定。具体来说，$\\inf_f \\frac{\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]} = \\frac{1}{\\lambda_{\\max}(\\Sigma)}$。这为谱隙提供了一个下界估计，代表了链的最慢混合模式：\n$$\n\\mathrm{gap}_{\\mathrm{sc, lower}} = \\frac{s^2}{2\\lambda_{\\max}(\\Sigma)}\n$$\n问题也要求一个上界估计。在MCMC性能的背景下，这通常指最快混合模式的收敛速率，它对应于相同期望比率的上确界：$\\sup_f \\frac{\\mathbb{E}_{\\pi}\\left[ \\|\\nabla f\\|^2 \\right]}{\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]} = \\frac{1}{\\lambda_{\\min}(\\Sigma)}$。这给出了上界估计：\n$$\n\\mathrm{gap}_{\\mathrm{sc, upper}} = \\frac{s^2}{2\\lambda_{\\min}(\\Sigma)}\n$$\n当使用各向同性提议时，这两个估计刻画了目标分布不同主轴上的收敛速度范围。\n\n**2. 预处理高斯提议 ($q_{\\mathrm{pc}}$)**\n提议为 $q_{\\mathrm{pc}}(\\mathbf{y}\\mid \\mathbf{x}) = \\mathcal{N}(\\mathbf{y};\\,\\mathbf{x},\\, s^2 \\Sigma)$。提议增量 $\\mathbf{y}-\\mathbf{x}$ 的协方差为 $s^2 \\Sigma$。这意味着 $C_z = \\Sigma$。\nDirichlet型的近似变为：\n$$\n\\mathcal{E}_{P_{\\mathrm{pc}}}(f,f) \\approx \\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[ \\nabla f^{\\top} \\Sigma \\nabla f \\right]\n$$\n比率的渐近表达式为：\n$$\n\\frac{\\mathcal{E}_{P_{\\mathrm{pc}}}(f,f)}{\\mathrm{Var}_{\\pi}(f)} \\approx \\frac{\\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]}{\\mathrm{Var}_{\\pi}(f)}\n$$\n根据Poincaré不等式，我们知道分母总是小于或等于分子（相差一个因子 $\\tfrac{s^2}{2}$）。因此：\n$$\n\\frac{\\tfrac{s^2}{2}\\,\\mathbb{E}_{\\pi}\\left[\\nabla f^{\\top}\\Sigma\\,\\nabla f\\right]}{\\mathrm{Var}_{\\pi}(f)} \\geq \\frac{s^2}{2}\n$$\n已知这种预处理算法的扩散极限，其最慢模式与线性函数 $f(\\mathbf{x}) = \\mathbf{v}^{\\top}\\mathbf{x}$ 相关联。对于此类函数，Poincaré不等式等号成立：$\\mathrm{Var}_{\\pi}(f) = \\mathbb{E}_{\\pi}[\\nabla f^{\\top}\\Sigma \\nabla f]$。对于这些函数，该比率恰好是 $\\tfrac{s^2}{2}$。由于谱隙是该比率在所有函数上的下确界，这表明谱隙精确地是 $\\tfrac{s^2}{2}$。该估计与 $\\Sigma$ 的特征值无关，符合要求。\n$$\n\\mathrm{gap}_{\\mathrm{pc}} = \\frac{s^2}{2}\n$$\n\n**公式总结：**\n- 标量提议的渐近下界估计：$\\mathrm{gap}_{\\mathrm{sc, lower}} = \\frac{s^2}{2 \\lambda_{\\max}(\\Sigma)}$\n- 标量提议的渐近上界估计：$\\mathrm{gap}_{\\mathrm{sc, upper}} = \\frac{s^2}{2 \\lambda_{\\min}(\\Sigma)}$\n- 预处理提议的渐近估计：$\\mathrm{gap}_{\\mathrm{pc}} = \\frac{s^2}{2}$\n\n这些公式将被实现以解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating asymptotic spectral gap estimates\n    for Metropolis-Hastings algorithms with scalar and preconditioned proposals.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (list_of_eigenvalues, step_size_s).\n    test_cases = [\n        ([4.0], 0.1),\n        ([1.0, 4.0, 9.0], 0.05),\n        ([0.01, 1.0, 1.0, 2.0, 10.0], 0.02),\n        ([3.0, 3.0, 3.0], 0.2),\n        ([0.5, 1.0, 3.0, 100.0], 0.1)\n    ]\n\n    # This list will store the string representation of each inner list of results.\n    final_result_strings = []\n\n    for eigenvalues, s in test_cases:\n        # Find the extremal eigenvalues of the covariance matrix Sigma.\n        lambda_min = np.min(eigenvalues)\n        lambda_max = np.max(eigenvalues)\n        \n        # Calculate s^2, a common term in all estimates.\n        s_squared = s**2\n        \n        # 1. Asymptotic lower estimate for the scalar proposal spectral gap.\n        # Formula: s^2 / (2 * lambda_max)\n        gap_lower_scalar = s_squared / (2.0 * lambda_max)\n        \n        # 2. Asymptotic upper estimate for the scalar proposal spectral gap.\n        # Formula: s^2 / (2 * lambda_min)\n        gap_upper_scalar = s_squared / (2.0 * lambda_min)\n        \n        # 3. Asymptotic estimate for the preconditioned proposal spectral gap.\n        # Formula: s^2 / 2\n        gap_preconditioned = s_squared / 2.0\n        \n        # Format the results for the current test case into a string '[val1,val2,val3]'\n        # with each value rounded to 10 decimal places.\n        inner_string = (\n            f\"[{gap_lower_scalar:.10f},\"\n            f\"{gap_upper_scalar:.10f},\"\n            f\"{gap_preconditioned:.10f}]\"\n        )\n        final_result_strings.append(inner_string)\n\n    # Final print statement in the exact required format '[[...],[...],...]'.\n    # This is achieved by joining the formatted strings of the inner lists.\n    print(f\"[{','.join(final_result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}