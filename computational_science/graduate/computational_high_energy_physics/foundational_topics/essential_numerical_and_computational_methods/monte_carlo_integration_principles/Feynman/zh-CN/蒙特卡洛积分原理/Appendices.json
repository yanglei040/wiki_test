{
    "hands_on_practices": [
        {
            "introduction": "蒙特卡洛积分一个广为人知的特性是其误差随样本量 $N$ 的增加而以 $1/\\sqrt{N}$ 的速率减小。然而，这一宝贵的特性是中心极限定理 (CLT) 的直接结果，而该定理的成立依赖于一个关键前提：被积函数的方差必须是有限的。本练习  将引导你通过一个模拟实验，亲手探究当这一前提不被满足时会发生什么，从而深刻理解蒙特卡洛方法背后的理论基石及其适用边界。",
            "id": "2411534",
            "problem": "考虑单位区间上由下式给出的一族积分\n$$ I(p) \\equiv \\int_{0}^{1} u^{p} \\, du, $$\n其中 $p$ 是一个实数参数，满足 $p > -1$，以使积分存在且有限。对于一个在 $[0,1]$ 上均匀分布的随机变量 $U$，将积分被积函数定义为 $f_{p}(U) = U^{p}$。其精确值为\n$$ I(p) = \\frac{1}{p+1}. $$\n对于给定的样本大小 $n \\in \\mathbb{N}$ 和批次数 $B \\in \\mathbb{N}$，考虑 $B$ 个独立的批次，每批包含从 $[0,1]$ 上的均匀分布中独立抽取的 $n$ 个样本 $U_{1},\\dots,U_{n}$。对于每批 $b \\in \\{1,\\dots,B\\}$，定义批次样本均值\n$$ \\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} f_{p}(U_{i}), $$\n以及无偏批次样本方差\n$$ s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} \\left( f_{p}(U_{i}) - \\bar{f}_{b} \\right)^{2}, $$\n前提是 $n \\ge 2$。当 $n \\ge 2$ 时，定义名义 $95\\%$ 水平正态置信区间半宽度\n$$ h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}. $$\n对于每个 $n \\ge 2$ 的批次 $b$，构建名义区间\n$$ \\left[ \\bar{f}_{b} - h_{b}, \\, \\bar{f}_{b} + h_{b} \\right]. $$\n设批次 $b$ 的覆盖指示变量为 $C_{b} = 1$（如果 $I(p)$ 位于上述区间内），否则为 $C_{b} = 0$。如果 $n < 2$，按照惯例定义 $C_{b} = 0$，因为样本方差未定义。定义跨批次的经验覆盖率为\n$$ \\widehat{\\mathrm{cov}} = \\frac{1}{B} \\sum_{b=1}^{B} C_{b}. $$\n请注意，对于 $p \\le -\\tfrac{1}{2}$，方差 $\\mathbb{V}[f_{p}(U)]$ 是无穷大的，因为\n$$ \\mathbb{E}\\left[ f_{p}(U)^{2} \\right] = \\int_{0}^{1} u^{2p} \\, du $$\n是发散的，尽管对于所有 $p > -1$，$I(p)$ 仍然是有限的。这种情况违反了中心极限定理（CLT）通常要求的有限方差条件，因此名义上基于正态分布的误差界限可能会失效。\n\n您的任务是编写一个完整的程序，该程序针对每个测试用例，以小数形式生成经验覆盖率 $\\widehat{\\mathrm{cov}}$。每个测试用例指定 $(p, n, B, \\text{seed})$，其中 $\\text{seed}$ 用于初始化伪随机数生成器以确保可复现性。角度和物理单位不出现；无需单位转换。所有答案必须以小数形式表示。\n\n测试集：\n- 测试 $1$：$p = -\\tfrac{1}{2}$, $n = 500$, $B = 200$, $\\text{seed} = 17$。\n- 测试 $2$：$p = -0.6$, $n = 500$, $B = 200$, $\\text{seed} = 19$。\n- 测试 $3$：$p = \\tfrac{1}{2}$, $n = 500$, $B = 200$, $\\text{seed} = 23$。\n- 测试 $4$：$p = \\tfrac{1}{2}$, $n = 5000$, $B = 200$, $\\text{seed} = 29$。\n- 测试 $5$：$p = -\\tfrac{1}{2}$, $n = 5000$, $B = 200$, $\\text{seed} = 31$。\n- 测试 $6$：$p = \\tfrac{1}{2}$, $n = 1$, $B = 200$, $\\text{seed} = 37$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 $1$ 到 $6$ 的六个经验覆盖率，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如，\n$$ [x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}]. $$",
            "solution": "问题陈述已经过评估并确定为有效。这是一个在计算统计学中定义明确的问题，其基础是蒙特卡洛积分和假设检验的原理。定义清晰，参数完整，其背景（探究中心极限定理的局限性）在科学上是合理的。不存在矛盾、歧义或事实错误。\n\n任务是执行蒙特卡洛模拟，以计算积分 $I(p) = \\int_{0}^{1} u^{p} \\, du$ 的名义 $95\\%$ 置信区间的经验覆盖率。该模拟将检验覆盖行为如何随参数 $p$ 变化，该参数控制着被积函数 $f_{p}(U) = U^{p}$ 的方差的有限性，其中 $U \\sim \\text{Uniform}[0,1]$。\n\n该积分的精确值已知为 $I(p) = \\frac{1}{p+1}$（对于 $p > -1$）。\n\n针对由 $(p, n, B, \\text{seed})$ 指定的单个测试用例，计算经验覆盖率 $\\widehat{\\mathrm{cov}}$ 的算法如下：\n\n1.  使用提供的整数`seed`初始化一个伪随机数生成器，以确保可复现性。\n2.  计算积分的真实值，我们记作 $I_{true} = \\frac{1}{p+1}$。\n3.  对于样本大小 $n$ 小于 2 的情况，给出了一个特定规则。如果 $n  2$，样本方差 $s_{b}^{2}$ 未定义。按照惯例，所有批次的覆盖指示变量 $C_{b}$ 都设置为 $0$。因此，经验覆盖率 $\\widehat{\\mathrm{cov}}$ 为 $0$。此情况的计算在此终止。\n4.  对于 $n \\ge 2$ 的主要情况，模拟在 $B$ 个独立批次上进行。我们将维护一个计数器，初始为零，用于记录置信区间覆盖真实值 $I_{true}$ 的批次数。\n5.  一种高效的方法是一次性生成所有 $B$ 个批次所需的所有随机数。我们生成一个 $B \\times n$ 的独立随机变量矩阵，其中每个元素都从 $[0,1]$ 上的均匀分布中抽取。将此矩阵记为 $\\mathbf{U}$，其元素为 $U_{b,i}$，其中批次 $b \\in \\{1, \\dots, B\\}$，样本索引 $i \\in \\{1, \\dots, n\\}$。\n6.  将被积函数 $f_{p}(u) = u^{p}$ 逐元素应用于矩阵 $\\mathbf{U}$，得到一个新矩阵 $\\mathbf{F}$，其元素为 $F_{b,i} = (U_{b,i})^{p}$。$\\mathbf{F}$ 的每一行对应于单个批次的样本 $\\{f_{p}(U_{i})\\}_{i=1}^{n}$。\n7.  对于每个批次 $b$（即 $\\mathbf{F}$ 的每一行），我们计算所需的统计量：\n    a. 批次样本均值：$\\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} F_{b,i}$。这可以通过计算 $\\mathbf{F}$ 矩阵各列的均值来同时为所有批次计算。\n    b. 无偏批次样本方差：$s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} (F_{b,i} - \\bar{f}_{b})^{2}$。这也可以通过计算 $\\mathbf{F}$ 矩阵各列的样本方差（使用一度自由度校正，`ddof=1`）来为所有批次计算。\n8.  使用这些统计量，我们为每个批次计算名义 $95\\%$ 置信区间的半宽度：\n    $$h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}$$\n    注意，值 $1.96$ 是标准正态分布的 $0.975$ 分位数的近似值，即 $z_{0.025}$。\n9.  对于每个批次 $b$，我们判断置信区间 $[\\bar{f}_{b} - h_{b}, \\bar{f}_{b} + h_{b}]$ 是否包含真实值 $I_{true}$。这个条件等价于检验绝对误差 $|\\bar{f}_{b} - I_{true}|$ 是否小于或等于半宽度 $h_{b}$。\n10. 对满足此条件的批次数进行计数。设此计数为 $N_{covered}$。\n11. 经验覆盖率是覆盖区间数量与总批次数的比率：\n    $$\\widehat{\\mathrm{cov}} = \\frac{N_{covered}}{B}$$\n对指定的六个测试用例中的每一个执行此过程。理论上预期，对于 $p  -1/2$ 的情况（其中 $f_{p}(U)$ 的方差是有限的），中心极限定理成立，$\\widehat{\\mathrm{cov}}$ 应接近名义水平 $0.95$，尤其是在 $n$ 较大时。相反，对于 $p \\le -1/2$ 的情况，方差是无穷大的，基于正态分布的置信区间的理论基础无效，我们预计 $\\widehat{\\mathrm{cov}}$ 将显著偏离 $0.95$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_coverage(p: float, n: int, B: int, seed: int) -> float:\n    \"\"\"\n    Computes the empirical coverage fraction for a given set of parameters.\n\n    Args:\n        p: The exponent parameter for the integrand u^p.\n        n: The sample size for each batch.\n        B: The number of batches.\n        seed: The seed for the random number generator.\n\n    Returns:\n        The empirical coverage fraction as a float.\n    \"\"\"\n    # Per the problem statement, for n  2, the sample variance is not defined,\n    # and the coverage indicator C_b is 0 by convention. Thus, the total\n    # empirical coverage is 0.\n    if n  2:\n        return 0.0\n\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Calculate the exact value of the integral I(p) = 1/(p+1).\n    I_true = 1.0 / (p + 1.0)\n\n    # Generate all uniform random samples for all B batches at once.\n    # The shape of the resulting array is (B, n).\n    uniform_samples = rng.uniform(size=(B, n))\n\n    # Evaluate the integrand f_p(u) = u^p on the samples.\n    f_p_samples = uniform_samples**p\n\n    # Calculate batch means along axis 1 (across samples in a batch).\n    # The result is an array of shape (B,).\n    batch_means = np.mean(f_p_samples, axis=1)\n\n    # Calculate unbiased batch sample variances along axis 1.\n    # ddof=1 ensures the denominator is (n-1).\n    # The result is an array of shape (B,).\n    batch_variances = np.var(f_p_samples, axis=1, ddof=1)\n\n    # Calculate the half-width of the nominal 95% confidence interval for each batch.\n    # h_b = 1.96 * sqrt(s_b^2 / n)\n    # A small epsilon is not strictly necessary with standard floating point\n    # arithmetic as var >= 0, but good practice to consider. Here, it is omitted.\n    half_widths = 1.96 * np.sqrt(batch_variances / n)\n\n    # Determine for each batch if the true value is within the confidence interval.\n    # This is true if |sample_mean - true_value| = half_width.\n    # This operation returns a boolean array of shape (B,).\n    is_covered = np.abs(batch_means - I_true) = half_widths\n\n    # The empirical coverage is the mean of the boolean indicators (True=1, False=0).\n    coverage_fraction = np.mean(is_covered)\n\n    return coverage_fraction\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (p, n, B, seed)\n    test_cases = [\n        (-0.5, 500, 200, 17),    # Test 1\n        (-0.6, 500, 200, 19),    # Test 2\n        (0.5, 500, 200, 23),     # Test 3\n        (0.5, 5000, 200, 29),    # Test 4\n        (-0.5, 5000, 200, 31),   # Test 5\n        (0.5, 1, 200, 37),      # Test 6\n    ]\n\n    results = []\n    for p, n, B, seed in test_cases:\n        # Calculate the empirical coverage for the current test case.\n        result = compute_coverage(p, n, B, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "从理论基础转向粒子物理学的核心应用，计算相空间体积是预测粒子反应率的基础步骤。这个练习  将带领你完成一个典型的工作流程：将一个复杂的多维物理积分，通过理论推导和变量代换，简化为适合蒙特卡洛方法处理的一维积分。这不仅能巩固你对蒙特卡洛积分的理解，更展示了如何将理论物理与实际计算紧密结合。",
            "id": "3523401",
            "problem": "您的任务是设计并实现一个蒙特卡洛积分算法，用以计算高能物理中某个过程的洛伦兹不变三体相空间体积。该过程的总质心系四动量平方为 $s$，末态包含三个质量分别为 $m_1$、$m_2$ 和 $m_3$ 的粒子。该问题必须从蒙特卡洛积分和洛伦兹不变相空间测度的第一性原理出发进行构建。您应从三粒子洛伦兹不变相空间的定义出发构建您的解决方案，该定义是一个关于末态三动量的、受能量-动量守恒约束的分布积分，过程中不得依赖快捷公式。您的程序必须执行一次有效的变量替换，将其转换为对单个不变量的积分，并使用蒙特卡洛方法对变换后的变量进行抽样，以估算该积分的值。\n\n问题的基本原理：洛伦兹不变的 $n$ 体相空间定义为\n$$\n\\mathrm{d}\\Phi_n(P; m_1,\\dots,m_n) \\equiv (2\\pi)^4\\,\\delta^{(4)}\\!\\left(P - \\sum_{i=1}^{n} p_i\\right)\\,\\prod_{i=1}^{n}\\frac{\\mathrm{d}^3 \\mathbf{p}_i}{(2\\pi)^3\\,2E_i},\n$$\n其中 $P$ 是总入射四动量，$p_i$ 是满足 $p_i^2 = m_i^2$ 的出射在壳四动量，$E_i$ 是对应的能量，$\\delta^{(4)}$ 是四维狄拉克 $\\delta$ 函数。您的目标是计算积分后的三体相空间体积\n$$\n\\Phi_3(s; m_1,m_2,m_3) \\equiv \\int \\mathrm{d}\\Phi_3(P; m_1,m_2,m_3),\n$$\n将其表示为质心系不变量 $s \\equiv P^2$ 和末态质量的函数。您必须利用序贯二体衰变图像，推导出一个物理上有效的测度分解，并通过变量替换将其转换为对单个不变质量平方 $s_{12} \\equiv (p_1+p_2)^2$ 的积分。您需要确定 $s_{12}$ 的正确运动学限，并计算雅可比行列式，以便在完成角度积分后将原始测度转换为一个只对 $s_{12}$ 的积分。\n\n蒙特卡洛要求：为关于 $s_{12}$ 的一维积分实现一个蒙特卡洛估计器。该估计器需在单位区间内进行均匀抽样，然后将样本线性映射到物理允许的范围 $\\left[s_{12}^{\\min}, s_{12}^{\\max}\\right]$。最后，将结果乘以推导出的测度所要求的雅可比因子和常数因子。为保证可复现性，请使用固定的伪随机数生成器种子。将 $\\Phi_3(s; m_1,m_2,m_3)$ 的估算值以浮点数形式报告。\n\n单位要求：所有能量和质量都必须以吉电子伏特 (GeV) 为单位处理。最终的相空间体积 $\\Phi_3$ 以 GeV$^2$ 为单位表示。\n\n角度单位要求：在推导过程中引入的任何角度都必须理解为以弧度为单位进行测量。\n\n您的程序必须实现以下内容：\n- 一个计算 Källén 函数 $\\lambda(a,b,c) \\equiv a^2 + b^2 + c^2 - 2ab - 2ac - 2bc$ 的函数，并在经过正确的变量变换和角度积分后，在雅可比因子中一致地使用它。\n- 一个蒙特卡洛估计器，它从单位区间均匀抽取 $N$ 个独立样本，通过线性变换将它们映射到 $\\left[s_{12}^{\\min}, s_{12}^{\\max}\\right]$ 区间内的 $s_{12}$ 值，累加由推导测度所确定的被积函数的值，并输出缩放后的平均值作为最终估计。包含一个保护机制：当运动学阈值条件 $s  \\left(m_1 + m_2 + m_3\\right)^2$ 导致相空间为零时，函数返回 $0$。\n- 对伪随机数生成器使用固定的种子 $12345$。\n\n测试套件：\n为以下参数集提供估算值，所有单位酌情使用 GeV 和 GeV$^2$，每个案例的样本数 $N$ 如下所示：\n1. $s = 100$, $m_1 = 1$, $m_2 = 2$, $m_3 = 3$, $N = 200000$。\n2. $s = 25$, $m_1 = 0$, $m_2 = 0$, $m_3 = 0$, $N = 200000$。\n3. $s = (6.1)^2$, $m_1 = 2$, $m_2 = 2$, $m_3 = 2$, $N = 200000$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个条目是对应测试案例的 $\\Phi_3$ 的蒙特卡洛估算值（单位为 GeV$^2$），并按顺序排列。例如，您的输出应类似于\n$$\n[\\varphi_1,\\varphi_2,\\varphi_3],\n$$\n其中每个 $\\varphi_i$ 是一个浮点数。",
            "solution": "该问题要求设计并实现一个蒙特卡洛算法，用以计算洛伦兹不变的三体相空间体积 $\\Phi_3$。该方法必须从第一性原理推导，从洛伦兹不变相空间 (LIPS) 测度的定义开始，通过有效的变量替换，最终得到一个适合蒙特卡洛估算的一维积分。\n\n出发点是 $n$ 体 LIPS 的定义，适用于一个总四动量为 $P$ 的系统衰变为 $n$ 个四动量为 $p_i$、质量为 $m_i$ 的粒子：\n$$\n\\mathrm{d}\\Phi_n(P; m_1,\\dots,m_n) \\equiv (2\\pi)^4\\,\\delta^{(4)}\\!\\left(P - \\sum_{i=1}^{n} p_i\\right)\\,\\prod_{i=1}^{n}\\frac{\\mathrm{d}^3 \\mathbf{p}_i}{(2\\pi)^3\\,2E_i}\n$$\n其中 $p_i^2 = m_i^2$。我们关心的是 $n=3$ 时的总相空间体积，即该测度对所有末态动量的积分：\n$$\n\\Phi_3(s; m_1,m_2,m_3) \\equiv \\int \\mathrm{d}\\Phi_3(P; m_1,m_2,m_3)\n$$\n此处，$s=P^2$ 是质心能量的平方。在质心 (CM) 系中，$P=(\\sqrt{s}, \\mathbf{0})$。$\\mathrm{d}\\Phi_n$ 的量纲是 $(\\text{能量})^{2n-4}$，对于 $n=3$ 的情况，结果是 $(\\text{能量})^2$，这与要求的输出单位 $\\text{GeV}^2$ 一致。\n\n简化这个九维动量积分的关键在于将三体衰变分解为一系列二体衰变。我们将此衰变视为一个两步过程：首先，初态衰变为粒子 3 和一个四动量为 $p_{12} = p_1+p_2$ 的中间虚粒子。然后，这个中间态衰变为粒子 1 和粒子 2。该中间态的不变质量平方为 $s_{12} \\equiv p_{12}^2 = (p_1+p_2)^2$。\n\n我们可以通过先对固定的中间动量 $p_{12}$ 下的粒子 1 和 2 的相空间进行积分，然后再对 $p_{12}$ 和 $p_3$ 的相空间进行积分，来表示总的三体相空间积分。这可以通过在积分中插入一个单位算子来形式化地证明，从而得到以下分解：\n$$\n\\Phi_3 = \\int \\frac{\\mathrm{d}^3\\mathbf{p}_3}{(2\\pi)^3 2E_3} \\left[ \\int (2\\pi)^4 \\delta^{(4)}(P-p_3-p_{12}) \\frac{\\mathrm{d}^3\\mathbf{p}_1}{(2\\pi)^3 2E_1} \\frac{\\mathrm{d}^3\\mathbf{p}_2}{(2\\pi)^3 2E_2} \\right]\n$$\n其中 $p_{12}$ 被外部的 delta 函数固定为 $p_{12}=P-p_3$。方括号中的项是动量为 $p_{12}$ 的虚粒子衰变为粒子 1 和 2 的二体相空间。这正是 $\\Phi_2(s_{12}; m_1, m_2)$，其中 $s_{12} = (P-p_3)^2 = s+m_3^2-2\\sqrt{s}E_3$。积分后的二体相空间体积由一个熟知的公式给出：\n$$\n\\Phi_2(Q^2; m_a, m_b) = \\frac{\\sqrt{\\lambda(Q^2, m_a^2, m_b^2)}}{8\\pi Q^2}\n$$\n其中 $\\lambda(x,y,z) = x^2+y^2+z^2-2xy-2xz-2yz$ 是 Källén 运动学函数。这个结果是无量纲的。应用此公式，我们对 $\\Phi_3$ 的表达式变为：\n$$\n\\Phi_3 = \\int \\frac{\\mathrm{d}^3\\mathbf{p}_3}{(2\\pi)^3 2E_3} \\Phi_2(s-2\\sqrt{s}E_3+m_3^2; m_1, m_2)\n$$\n对 $\\mathrm{d}^3\\mathbf{p}_3$ 的积分在 CM 系中进行。使用球坐标，$\\mathrm{d}^3\\mathbf{p}_3 = |\\mathbf{p}_3|^2 \\mathrm{d}|\\mathbf{p}_3| \\mathrm{d}\\Omega_3$。角度积分给出一个 $4\\pi$ 因子。利用关系式 $E_3^2 = |\\mathbf{p}_3|^2 + m_3^2 \\implies E_3\\mathrm{d}E_3 = |\\mathbf{p}_3|\\mathrm{d}|\\mathbf{p}_3|$，积分测度变为：\n$$\n\\frac{4\\pi |\\mathbf{p}_3|E_3 \\mathrm{d}E_3}{(2\\pi)^3 2E_3} = \\frac{|\\mathbf{p}_3|}{4\\pi^2} \\mathrm{d}E_3\n$$\n现在我们将积分变量从 $E_3$ 变为 $s_{12}$。根据 $s_{12} = s+m_3^2-2\\sqrt{s}E_3$，我们有 $|\\mathrm{d}E_3| = \\frac{\\mathrm{d}s_{12}}{2\\sqrt{s}}$。在 CM 系中的动量 $|\\mathbf{p}_3|$ 也可以用不变量表示：它是衰变 $P \\to p_3 + p_{12}$ 中任一粒子的动量大小，因此 $|\\mathbf{p}_3| = \\frac{\\sqrt{\\lambda(s, m_3^2, s_{12})}}{2\\sqrt{s}}$。\n\n将这些表达式代回 $\\Phi_3$ 的积分中：\n$$\n\\Phi_3 = \\int \\left( \\frac{1}{4\\pi^2} \\frac{\\sqrt{\\lambda(s, m_3^2, s_{12})}}{2\\sqrt{s}} \\right) \\left( \\frac{\\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{8\\pi s_{12}} \\right) \\left( \\frac{\\mathrm{d}s_{12}}{2\\sqrt{s}} \\right)\n$$\n合并常数因子和与 $s$ 相关的项，得到最终的一维积分：\n$$\n\\Phi_3 = \\frac{1}{128\\pi^3 s} \\int_{s_{12}^{\\min}}^{s_{12}^{\\max}} \\frac{\\sqrt{\\lambda(s, s_{12}, m_3^2)} \\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{s_{12}} \\mathrm{d}s_{12}\n$$\n$s_{12}$ 的运动学限由物理约束决定。$s_{12}$ 的最小值是产生粒子 1 和 2 的阈值，即它们相对彼此静止时：$s_{12}^{\\min} = (m_1+m_2)^2$。最大值出现在粒子 3 以最小可能动量产生时，即相对于粒子 1 和 2 的质心系静止。这对应于总可用能量减去粒子 3 的静止质量后全部用于粒子对 $(1,2)$，所以 $\\sqrt{s_{12}^{\\max}} = \\sqrt{s}-m_3$，给出 $s_{12}^{\\max} = (\\sqrt{s}-m_3)^2$。如果 $\\sqrt{s}  m_1+m_2+m_3$，那么 $s_{12}^{\\max}  s_{12}^{\\min}$，积分范围为空，$\\Phi_3=0$，这正确地反映了运动学阈值。\n\n为了使用蒙特卡洛方法估算此积分，我们定义被积函数为：\n$$\nf(s_{12}) = \\frac{\\sqrt{\\lambda(s, s_{12}, m_3^2)} \\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{s_{12}}\n$$\n积分 $I = \\int_{s_{12}^{\\min}}^{s_{12}^{\\max}} f(s_{12}) \\mathrm{d}s_{12}$ 可估算为：\n$$\nI \\approx \\frac{s_{12}^{\\max} - s_{12}^{\\min}}{N} \\sum_{i=1}^{N} f(x_i)\n$$\n其中 $x_i$ 是从区间 $[s_{12}^{\\min}, s_{12}^{\\max}]$ 上的均匀分布中抽取的 $N$ 个随机数。这可以通过在 $[0,1]$ 上的均匀分布中生成随机数 $u_i$，然后应用线性变换 $x_i = s_{12}^{\\min} + u_i (s_{12}^{\\max} - s_{12}^{\\min})$ 来实现。$\\Phi_3$ 的最终估算值通过将 $I$ 的估算值乘以预因子 $\\frac{1}{128\\pi^3 s}$ 得到。算法必须实现这一逻辑，包括 Källén 函数、运动学限的计算和阈值检查。为了保证可复现性，随机数生成器使用固定的种子。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for three-body phase-space volume estimation.\n    \"\"\"\n    \n    test_cases = [\n        # (s, m1, m2, m3, N)\n        (100.0, 1.0, 2.0, 3.0, 200000),\n        (25.0, 0.0, 0.0, 0.0, 200000),\n        ((6.1)**2, 2.0, 2.0, 2.0, 200000),\n    ]\n\n    results = []\n    seed = 12345\n\n    for case in test_cases:\n        s, m1, m2, m3, N = case\n        phi3_estimate = estimate_phi3(s, m1, m2, m3, N, seed)\n        results.append(phi3_estimate)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef kallen_lambda(a, b, c):\n    \"\"\"\n    Calculates the Källén (or triangle) function lambda(a, b, c).\n    This function can accept scalar or numpy array inputs.\n    \"\"\"\n    return a**2 + b**2 + c**2 - 2*a*b - 2*a*c - 2*b*c\n\ndef estimate_phi3(s, m1, m2, m3, N, seed):\n    \"\"\"\n    Estimates the three-body phase-space volume Phi_3 using Monte Carlo integration.\n    \n    Args:\n        s (float): The square of the center-of-mass energy in GeV^2.\n        m1 (float): Mass of particle 1 in GeV.\n        m2 (float): Mass of particle 2 in GeV.\n        m3 (float): Mass of particle 3 in GeV.\n        N (int): The number of Monte Carlo samples.\n        seed (int): The seed for the random number generator.\n        \n    Returns:\n        float: The estimated value of Phi_3 in GeV^2.\n    \"\"\"\n    sqrts = np.sqrt(s)\n    \n    # Kinematic threshold check\n    if sqrts  (m1 + m2 + m3):\n        return 0.0\n\n    # Calculate kinematic limits for the invariant mass squared s_12\n    s12_min = (m1 + m2)**2\n    s12_max = (sqrts - m3)**2\n    \n    # If the integration range is non-positive, phase space is zero.\n    if s12_max = s12_min:\n        return 0.0\n\n    # Set up the random number generator with a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed)\n    \n    # Generate N uniform random samples in [0, 1)\n    u_samples = rng.uniform(0, 1, N)\n    \n    # Map samples to the integration domain [s12_min, s12_max]\n    s12_samples = s12_min + (s12_max - s12_min) * u_samples\n\n    # Pre-calculate squared masses\n    m1_sq = m1**2\n    m2_sq = m2**2\n    m3_sq = m3**2\n\n    # Calculate the two Källén functions\n    # Handle potential small negative values from floating point inaccuracies\n    lambda1 = kallen_lambda(s12_samples, m1_sq, m2_sq)\n    lambda1[lambda1  0] = 0.0\n    \n    lambda2 = kallen_lambda(s, s12_samples, m3_sq)\n    lambda2[lambda2  0] = 0.0\n    \n    # Calculate the integrand value for each sample of s12\n    # Ensure s12 is not zero to avoid division by zero. s12_samples will be > s12_min >= 0\n    # In the massless case, s12_min is 0, so we need to handle the s12=0 point.\n    # The integrand at s12=0 limit is 0, so we can safely replace NaNs with 0.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        integrand_values = (np.sqrt(lambda1) * np.sqrt(lambda2)) / s12_samples\n    integrand_values = np.nan_to_num(integrand_values, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # Calculate the Monte Carlo estimate of the integral part\n    integral_volume = s12_max - s12_min\n    integral_estimate = integral_volume * np.mean(integrand_values)\n\n    #\n    # Final formula for Phi_3:\n    # Phi_3 = (1 / (128 * pi^3 * s)) * Integral(...)\n    #\n    prefactor = 1.0 / (128.0 * np.pi**3 * s)\n    \n    phi3 = prefactor * integral_estimate\n    \n    return phi3\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了蒙特卡洛积分的基本原理和应用之后，一个关键的进阶主题是如何提高计算效率，即减小估计的方差。分层抽样 (Stratified Sampling) 是一种强大而通用的方差缩减技术，尤其适用于被积函数在不同积分区域表现出显著差异的场景。本练习  将指导你从第一性原理出发，推导并应用奈曼分配 (Neyman Allocation) 这一最优样本分配策略，以最小的计算成本获得最高的积分精度。",
            "id": "3523390",
            "problem": "您的任务是分析用于在计算高能物理中估计全截面的蒙特卡洛积分策略。蒙特卡洛（MC）积分用于估计随机事件权重的期望值。在对撞机分析中，事件按喷注多重性（记为 $n_{\\text{jet}} \\in \\{0,1,2,3+\\}$）进行分类，我们可以跨这些类别进行分层抽样。全截面定义为在事件生成分布下，单个事件权重的期望值。\n\n从以下基础出发：\n- 期望的无偏估计量是独立同分布抽样的样本均值。\n- 在简单随机抽样下，期望估计量的方差是总体方差除以样本大小。\n- 全方差定律指出，对于随机变量 $Y$ 和层索引 $H$，有 $\\mathrm{Var}(Y) = \\mathbb{E}[\\mathrm{Var}(Y \\mid H)] + \\mathrm{Var}(\\mathbb{E}[Y \\mid H])$。\n- 在分层抽样中，若层权重为 $W_h = \\mathbb{P}(H = h)$，每层的样本数为 $n_h$，则均值的分层估计量是各层样本均值的加权和。\n\n考虑构成全截面的单个事件权重 $Y$。设存在 $H$ 个层，对应于喷注多重性类别 $n_{\\text{jet}}$。对于每个层 $h \\in \\{1,\\dots,H\\}$，令 $W_h$ 表示层概率（落入该层的事件比例），令 $m_h = \\mathbb{E}[Y \\mid H = h]$ 表示单个事件权重的条件均值，令 $s_h = \\sqrt{\\mathrm{Var}(Y \\mid H = h)}$ 表示条件标准差。令 $N$ 表示可用的总样本大小。您的任务是：\n1. 从上面列出的基础出发，推导出全截面的简单（非分层）蒙特卡洛估计量的方差，以及分层估计量的方差，将其表示为 $(W_h, m_h, s_h, n_h)$ 的函数。\n2. 使用数学上严格的优化论证，推导出在约束条件 $\\sum_{h=1}^H n_h = N$ 下，使分层估计量方差最小化的各层样本分配 $n_h$。这种分配在经典抽样理论中被称为 Neyman 分配。\n3. 在您的最优分配下，推导出分层估计量的相应最小方差，并将方差缩减因子表示为最小分层方差与非分层方差之比。\n4. 实现一个完整的、可运行的程序，为下面的每个测试用例计算方差缩减因子（以浮点数形式）。\n\n您的推导中的所有答案都必须以纯数学术语表达，任何提及物理的讨论都应仅作为动机，而不改变数学内容。不涉及角度，所要求的输出是无量纲的，因此不需要物理单位。最终的程序输出必须严格遵守本问题末尾给出的输出格式规范。\n\n测试套件：\n- 测试用例 A（四个层，对应 $n_{\\text{jet}} \\in \\{0,1,2,3+\\}$）：\n  - 层权重 $W = [0.58, 0.26, 0.11, 0.05]$。\n  - 条件均值 $m = [18.0, 28.0, 50.0, 95.0]$。\n  - 条件标准差 $s = [7.5, 12.0, 30.0, 75.0]$。\n  - 总样本数 $N = 100000$。\n- 测试用例 B（四个层，均值和标准差相等，用于探测分层无改进的边界情况）：\n  - 层权重 $W = [0.40, 0.30, 0.20, 0.10]$。\n  - 条件均值 $m = [20.0, 20.0, 20.0, 20.0]$。\n  - 条件标准差 $s = [10.0, 10.0, 10.0, 10.0]$。\n  - 总样本数 $N = 25000$。\n- 测试用例 C（三个层，包括一个条件方差为零的有效确定性类别）：\n  - 层权重 $W = [0.70, 0.20, 0.10]$。\n  - 条件均值 $m = [25.0, 60.0, 40.0]$。\n  - 条件标准差 $s = [8.0, 0.0, 12.0]$。\n  - 总样本数 $N = 50000$。\n- 测试用例 D（四个层，包含一个罕见的高方差尾部类别）：\n  - 层权重 $W = [0.70, 0.20, 0.08, 0.02]$。\n  - 条件均值 $m = [10.0, 35.0, 55.0, 150.0]$。\n  - 条件标准差 $s = [5.0, 20.0, 35.0, 200.0]$。\n  - 总样本数 $N = 200000$。\n\n对于每个测试用例，计算全截面的非分层估计量的方差、Neyman 分配下分层估计量的最小方差，并返回定义为最小分层方差与非分层方差之比的方差缩减因子（以浮点数表示）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$）。每个元素必须是对应测试用例（按 A、B、C、D 顺序）的方差缩减因子。",
            "solution": "所述问题具有科学依据、提法明确、客观，并为得出唯一解提供了所有必要信息。这是抽样理论（特别是分层抽样和 Neyman 分配）在计算物理背景下的一个标准应用。所有提供的数据都是一致的，任务可以用数学形式化。因此，该问题是有效的。我们着手进行推导和求解。\n\n目标是分析两种用于全截面的蒙特卡洛估计量的方差，这在数学上等同于估计代表单个事件权重的随机变量 $Y$ 的期望 $\\mu = \\mathbb{E}[Y]$。对于 $H$ 个层，可用的信息包括层概率 $W_h = \\mathbb{P}(H=h)$、条件均值 $m_h = \\mathbb{E}[Y \\mid H=h]$、条件标准差 $s_h = \\sqrt{\\mathrm{Var}(Y \\mid H=h)}$ 以及总样本大小 $N$。\n\n### 任务1：简单估计量和分层估计量的方差\n\n首先，我们推导简单（非分层）蒙特卡洛估计量的方差。基于大小为 $N$ 的简单随机样本，$\\mu = \\mathbb{E}[Y]$ 的估计量是样本均值：\n$$\n\\hat{\\mu}_{\\text{simple}} = \\frac{1}{N} \\sum_{i=1}^{N} Y_i\n$$\n该估计量的方差由下式给出：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{simple}}) = \\frac{\\mathrm{Var}(Y)}{N}\n$$\n为了用给定的各层量来表示 $\\mathrm{Var}(Y)$，我们使用全方差定律：\n$$\n\\mathrm{Var}(Y) = \\mathbb{E}[\\mathrm{Var}(Y \\mid H)] + \\mathrm{Var}(\\mathbb{E}[Y \\mid H])\n$$\n第一项，即期望条件方差，是各层方差 $s_h^2$ 的加权平均值：\n$$\n\\mathbb{E}[\\mathrm{Var}(Y \\mid H)] = \\sum_{h=1}^{H} W_h \\mathrm{Var}(Y \\mid H=h) = \\sum_{h=1}^{H} W_h s_h^2\n$$\n第二项是条件期望的方差。条件期望 $\\mathbb{E}[Y \\mid H]$ 是一个离散随机变量，以概率 $W_h$ 取值 $m_h$。其方差为：\n$$\n\\mathrm{Var}(\\mathbb{E}[Y \\mid H]) = \\mathbb{E}[(\\mathbb{E}[Y \\mid H])^2] - (\\mathbb{E}[\\mathbb{E}[Y \\mid H]])^2\n$$\n右侧的各项为：\n$$\n\\mathbb{E}[(\\mathbb{E}[Y \\mid H])^2] = \\sum_{h=1}^{H} W_h m_h^2\n$$\n$$\n\\mathbb{E}[\\mathbb{E}[Y \\mid H]] = \\sum_{h=1}^{H} W_h m_h\n$$\n将这些结合起来，条件期望的方差为：\n$$\n\\mathrm{Var}(\\mathbb{E}[Y \\mid H]) = \\left(\\sum_{h=1}^{H} W_h m_h^2\\right) - \\left(\\sum_{h=1}^{H} W_h m_h\\right)^2\n$$\n因此，$Y$ 的总方差为：\n$$\n\\mathrm{Var}(Y) = \\sum_{h=1}^{H} W_h s_h^2 + \\sum_{h=1}^{H} W_h m_h^2 - \\left(\\sum_{h=1}^{H} W_h m_h\\right)^2\n$$\n而简单估计量的方差为：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{simple}}) = \\frac{1}{N}\\left[ \\sum_{h=1}^{H} W_h s_h^2 + \\sum_{h=1}^{H} W_h m_h^2 - \\left(\\sum_{h=1}^{H} W_h m_h\\right)^2 \\right]\n$$\n接下来，我们考虑分层估计量。给定各层样本大小 $n_h$ 满足 $\\sum n_h = N$，各层样本均值为 $\\hat{m}_h$。$\\mu$ 的分层估计量为：\n$$\n\\hat{\\mu}_{\\text{strat}} = \\sum_{h=1}^{H} W_h \\hat{m}_h\n$$\n由于各层之间的抽样是独立的，该估计量的方差是各项方差之和：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = \\mathrm{Var}\\left(\\sum_{h=1}^{H} W_h \\hat{m}_h\\right) = \\sum_{h=1}^{H} W_h^2 \\mathrm{Var}(\\hat{m}_h)\n$$\n$h$ 层的样本均值方差为 $\\mathrm{Var}(\\hat{m}_h) = \\frac{\\mathrm{Var}(Y \\mid H=h)}{n_h} = \\frac{s_h^2}{n_h}$。代入此式，我们得到分层估计量的方差：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = \\sum_{h=1}^{H} \\frac{W_h^2 s_h^2}{n_h}\n$$\n\n### 任务2：最优样本分配（Neyman 分配）\n\n我们旨在找到样本分配 $\\{n_h\\}_{h=1}^H$，以在约束条件 $\\sum_{h=1}^H n_h = N$ 下最小化方差 $\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}})$。我们采用拉格朗日乘数法。需要最小化的目标函数是 $V(n_1, \\dots, n_H) = \\sum_{h=1}^H \\frac{W_h^2 s_h^2}{n_h}$，约束条件为 $g(n_1, \\dots, n_H) = \\sum_{h=1}^H n_h - N = 0$。\n\n拉格朗日函数为：\n$$\n\\mathcal{L}(n_1, \\dots, n_H, \\lambda) = \\sum_{h=1}^{H} \\frac{W_h^2 s_h^2}{n_h} + \\lambda \\left(\\sum_{h=1}^{H} n_h - N\\right)\n$$\n为求最小值，我们将关于每个 $n_k$ 的偏导数设为零：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial n_k} = -\\frac{W_k^2 s_k^2}{n_k^2} + \\lambda = 0 \\implies n_k^2 = \\frac{W_k^2 s_k^2}{\\lambda}\n$$\n假设 $n_k  0$，我们取正平方根：\n$$\nn_k = \\frac{W_k s_k}{\\sqrt{\\lambda}}\n$$\n这表明，一个层中的最优样本数 $n_k$ 与其权重 $W_k$ 和标准差 $s_k$ 的乘积成正比。为求出 $\\sqrt{\\lambda}$ 的值，我们使用约束条件：\n$$\n\\sum_{k=1}^{H} n_k = \\sum_{k=1}^{H} \\frac{W_k s_k}{\\sqrt{\\lambda}} = \\frac{1}{\\sqrt{\\lambda}} \\sum_{k=1}^{H} W_k s_k = N\n$$\n解出 $\\sqrt{\\lambda}$：\n$$\n\\sqrt{\\lambda} = \\frac{\\sum_{j=1}^{H} W_j s_j}{N}\n$$\n将其代回 $n_k$ 的表达式，我们得到最优分配，即 Neyman 分配：\n$$\nn_k = N \\frac{W_k s_k}{\\sum_{j=1}^{H} W_j s_j}\n$$\n\n### 任务3：最小方差与缩减因子\n\n现在我们通过将最优分配 $n_h$ 代入方差公式，来推导分层估计量的最小方差：\n$$\n\\mathrm{Var}_{\\text{min}}(\\hat{\\mu}_{\\text{strat}}) = \\sum_{h=1}^{H} \\frac{W_h^2 s_h^2}{n_h} = \\sum_{h=1}^{H} \\frac{W_h^2 s_h^2}{N \\frac{W_h s_h}{\\sum_{j} W_j s_j}}\n$$\n简化求和内的表达式：\n$$\n\\frac{W_h^2 s_h^2}{N \\frac{W_h s_h}{\\sum_{j} W_j s_j}} = \\frac{W_h s_h}{N} \\left(\\sum_{j=1}^{H} W_j s_j\\right)\n$$\n对 $h$ 求和：\n$$\n\\mathrm{Var}_{\\text{min}}(\\hat{\\mu}_{\\text{strat}}) = \\frac{1}{N} \\left(\\sum_{j=1}^{H} W_j s_j\\right) \\left(\\sum_{h=1}^{H} W_h s_h\\right) = \\frac{1}{N} \\left(\\sum_{h=1}^{H} W_h s_h\\right)^2\n$$\n方差缩减因子是最小分层方差与非分层方差之比。分子和分母中的因子 $1/N$ 会被约掉：\n$$\nR = \\frac{\\mathrm{Var}_{\\text{min}}(\\hat{\\mu}_{\\text{strat}})}{\\mathrm{Var}(\\hat{\\mu}_{\\text{simple}})} = \\frac{\\frac{1}{N} \\left(\\sum_{h=1}^{H} W_h s_h\\right)^2}{\\frac{1}{N} \\mathrm{Var}(Y)} = \\frac{\\left(\\sum_{h=1}^{H} W_h s_h\\right)^2}{\\mathrm{Var}(Y)}\n$$\n代入 $\\mathrm{Var}(Y)$ 的完整表达式，方差缩减因子的最终公式为：\n$$\nR = \\frac{\\left(\\sum_{h=1}^{H} W_h s_h\\right)^2}{\\sum_{h=1}^{H} W_h s_h^2 + \\sum_{h=1}^{H} W_h m_h^2 - \\left(\\sum_{h=1}^{H} W_h m_h\\right)^2}\n$$\n此公式将用于实现计算，以得出给定测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the variance reduction factor for stratified sampling\n    under Neyman allocation compared to simple random sampling for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {'W': np.array([0.58, 0.26, 0.11, 0.05]),\n         'm': np.array([18.0, 28.0, 50.0, 95.0]),\n         's': np.array([7.5, 12.0, 30.0, 75.0]),\n         'N': 100000},\n        # Test case B\n        {'W': np.array([0.40, 0.30, 0.20, 0.10]),\n         'm': np.array([20.0, 20.0, 20.0, 20.0]),\n         's': np.array([10.0, 10.0, 10.0, 10.0]),\n         'N': 25000},\n        # Test case C\n        {'W': np.array([0.70, 0.20, 0.10]),\n         'm': np.array([25.0, 60.0, 40.0]),\n         's': np.array([8.0, 0.0, 12.0]),\n         'N': 50000},\n        # Test case D\n        {'W': np.array([0.70, 0.20, 0.08, 0.02]),\n         'm': np.array([10.0, 35.0, 55.0, 150.0]),\n         's': np.array([5.0, 20.0, 35.0, 200.0]),\n         'N': 200000}\n    ]\n\n    results = []\n    for case in test_cases:\n        W = case['W']\n        m = case['m']\n        s = case['s']\n\n        # Numerator: Squared per-stratum weighted average of standard deviations.\n        # This is proportional to the minimal variance under Neyman allocation.\n        # Var_min_strat = (1/N) * (sum(W_h * s_h))^2\n        numerator = (np.sum(W * s))**2\n\n        # Denominator: Total variance of the random variable Y.\n        # This is proportional to the variance of the simple random sampling estimator.\n        # Var(Y) = E[Var(Y|H)] + Var(E[Y|H])\n        \n        # E[Var(Y|H)] = sum(W_h * s_h^2)\n        expected_cond_var = np.sum(W * s**2)\n        \n        # Var(E[Y|H]) = E[(E[Y|H])^2] - (E[E[Y|H]])^2\n        # E[Y|H] is a random variable taking value m_h with probability W_h.\n        var_cond_exp = np.sum(W * m**2) - (np.sum(W * m))**2\n        \n        # Total variance Var(Y)\n        denominator = expected_cond_var + var_cond_exp\n        \n        # The variance reduction factor is the ratio. The 1/N factor cancels.\n        if denominator == 0:\n            # Handle the case where total variance is zero (all s_h=0 and all m_h are equal)\n            # In this case, stratified variance is also zero, so reduction is perfect.\n            # However, if s_h are all zero but m_h differ, Var(Y)>0 but Var_strat_min=0.\n            # A divide-by-zero isn't expected for the given test cases, but it's good practice.\n            # For Test Case B, denominator is non-zero (100).\n            variance_reduction_factor = 0.0 if numerator == 0 else float('inf')\n        else:\n            variance_reduction_factor = numerator / denominator\n        \n        results.append(variance_reduction_factor)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}