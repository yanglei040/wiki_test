{
    "hands_on_practices": [
        {
            "introduction": "本实践探讨了马尔可夫链蒙特卡洛（MCMC）中的一个基本问题：如何在高维空间中进行有效探索。随着参数数量$d$的增加，简单的随机游走Metropolis算法的性能严重依赖于提议步长$\\sigma$的缩放方式。本练习将引导你完成一个经典推导（），证明最优缩放为$\\sigma \\propto 1/\\sqrt{d}$，并由此得出在大维数极限下，最优接受率约为$0.234$这一著名结果。完成此推导将使你对“维度灾难”以及如何调整MCMC算法以获得最佳性能有深刻的定量理解。",
            "id": "3521352",
            "problem": "考虑一个在 $\\mathbb{R}^{d}$ 上的高维目标分布，它可以分解为乘积形式 $\\pi_{d}(x) = \\prod_{i=1}^{d} f(x_{i})$，其中 $f$ 是一个一维概率密度函数，且其对数是二阶连续可微的。定义 $g(x) = \\frac{d}{dx} \\ln f(x)$，并假设 Fisher 信息 $I = \\mathbb{E}_{X \\sim f}\\!\\left[g(X)^{2}\\right]$ 是有限的，且 $\\mathbb{E}_{X \\sim f}\\!\\left[g'(X)\\right]$ 存在。使用 Metropolis-Hastings (MH) 随机游走提议 $Y = X + \\sigma Z$，其中 $X \\in \\mathbb{R}^{d}$ 是当前状态，$Z \\sim \\mathcal{N}(0, I_{d})$ 是一个标准多元正态分布，$\\sigma$ 是一个标量步长。接受概率由标准 MH 准则给出：$\\alpha(X,Y) = \\min\\!\\left\\{1, \\frac{\\pi_{d}(Y)}{\\pi_{d}(X)}\\right\\}$。\n\n你的任务是在高维极限 $d \\to \\infty$ 下，在标度机制 $\\sigma = \\frac{l}{\\sqrt{d}}$（其中 $l  0$ 为常数）下，分析随机游走 Metropolis 算法的渐进行为。假设算法处于平稳状态，$X \\sim \\pi_{d}$。仅从核心定义和已知的结论（Metropolis-Hastings 接受准则、$\\ln f$ 的 Taylor 展开、中心极限定理以及对光滑 $f$ 成立的分部积分恒等式 $\\mathbb{E}\\!\\left[g'(X)\\right] + \\mathbb{E}\\!\\left[g(X)^{2}\\right] = 0$）出发，执行以下步骤：\n\n1. 推导对数接受率的高维极限，并证明其依分布收敛到一个带位移的高斯分布。利用此结果，得到极限平均接受概率 $\\alpha(l)$ 作为 $l$ 和 Fisher 信息 $I$ 的函数的闭式表达式。\n\n2. 借鉴马尔可夫链蒙特卡洛 (MCMC) 中常用的扩散极限思想，将算法的效率定义为与期望平方跳跃距离成正比。在此标度机制下，将效率简化为一个形式为 $S(l) = C \\, l^{2} \\alpha(l)$ 的函数，其中 $C  0$ 是一个不依赖于 $l$ 的常数。确定使 $S(l)$ 最大化的 $l$。\n\n3. 根据最优的 $l$ 值，推导出在 $d \\to \\infty$ 极限下的相应渐进最优接受率 $\\alpha^{\\star}$。给出 $\\alpha^{\\star}$ 的数值，并四舍五入到三位有效数字。将最终答案表示为一个无单位的纯数。",
            "solution": "问题要求分析在高维极限 $d \\to \\infty$ 下的随机游走 Metropolis-Hastings 算法。我们将按要求分三步进行：首先，推导极限平均接受概率；其次，找到最优的标度参数；最后，计算相应的最优接受率。\n\n**第一部分：极限平均接受概率**\n\n目标分布为 $\\pi_{d}(x) = \\prod_{i=1}^{d} f(x_{i})$，提议为 $Y = X + \\sigma Z$，其中 $Z \\sim \\mathcal{N}(0, I_d)$。提议密度是对称的，即 $q(Y|X) = q(X|Y)$，因此 Metropolis-Hastings 接受概率为 $\\alpha(X,Y) = \\min\\!\\left\\{1, \\frac{\\pi_{d}(Y)}{\\pi_{d}(X)}\\right\\}$。我们关心的是当 $d \\to \\infty$ 时，对数接受率 $\\Delta = \\ln\\left(\\frac{\\pi_{d}(Y)}{\\pi_{d}(X)}\\right)$ 的行为。\n\n鉴于目标分布的乘积形式，该对数比率是一个和式：\n$$\n\\Delta = \\ln\\left(\\frac{\\prod_{i=1}^{d} f(Y_{i})}{\\prod_{i=1}^{d} f(X_{i})}\\right) = \\sum_{i=1}^{d} \\left( \\ln f(Y_{i}) - \\ln f(X_{i}) \\right)\n$$\n每个分量的提议是 $Y_i = X_i + \\sigma Z_i$，其中 $Z_i \\sim \\mathcal{N}(0,1)$ 是独立的。我们处于标度机制 $\\sigma = \\frac{l}{\\sqrt{d}}$ 下，其中 $l  0$ 为某个常数。由于当 $d \\to \\infty$ 时 $\\sigma \\to 0$，我们可以对 $\\ln f(Y_i)$ 在 $X_i$ 周围进行 Taylor 展开：\n$$\n\\ln f(Y_i) = \\ln f(X_i) + (Y_i - X_i) \\left.\\frac{d}{dx}\\ln f(x)\\right|_{x=X_i} + \\frac{1}{2}(Y_i - X_i)^2 \\left.\\frac{d^2}{dx^2}\\ln f(x)\\right|_{x=X_i} + O((Y_i-X_i)^3)\n$$\n令 $g(x) = \\frac{d}{dx}\\ln f(x)$。展开式变为：\n$$\n\\ln f(Y_i) - \\ln f(X_i) = (\\sigma Z_i) g(X_i) + \\frac{1}{2}(\\sigma Z_i)^2 g'(X_i) + O(\\sigma^3)\n$$\n将此代入 $\\Delta$ 的和式中，并使用 $\\sigma = l/\\sqrt{d}$：\n$$\n\\Delta = \\sum_{i=1}^{d} \\left[ \\frac{l}{\\sqrt{d}} Z_i g(X_i) + \\frac{l^2}{2d} Z_i^2 g'(X_i) + O\\left(d^{-3/2}\\right) \\right]\n$$\n$$\n\\Delta = \\frac{l}{\\sqrt{d}} \\sum_{i=1}^{d} Z_i g(X_i) + \\frac{l^2}{2d} \\sum_{i=1}^{d} Z_i^2 g'(X_i) + O\\left(d^{-1/2}\\right)\n$$\n我们在 $d \\to \\infty$ 的极限下分析这两个和式。假设算法处于平稳状态，所以当前状态 $X$ 从 $\\pi_d$ 中抽取，这意味着分量 $X_i$ 是从 $f$ 中抽取的独立同分布 (i.i.d.) 样本。$Z_i$ 项是独立同分布的 $\\mathcal{N}(0,1)$，并且独立于 $X_i$。\n\n令 $W_i = Z_i g(X_i)$。$W_i$ 各项是独立同分布的随机变量。我们计算它们的均值和方差。$g(X_i)$ 的期望是 $\\mathbb{E}[g(X_i)] = \\int_{-\\infty}^{\\infty} g(x)f(x)dx = \\int_{-\\infty}^{\\infty} f'(x)dx = [f(x)]_{-\\infty}^{\\infty} = 0$，因为 $f$ 是一个概率密度函数。因此，$\\mathbb{E}[W_i] = \\mathbb{E}[Z_i]\\mathbb{E}[g(X_i)] = 0 \\cdot 0 = 0$。\n方差为 $\\text{Var}(W_i) = \\mathbb{E}[W_i^2] - (\\mathbb{E}[W_i])^2 = \\mathbb{E}[Z_i^2 g(X_i)^2] = \\mathbb{E}[Z_i^2]\\mathbb{E}[g(X_i)^2] = 1 \\cdot I = I$，其中 $I$ 是 Fisher 信息。\n$\\Delta$ 中的第一项是 $T_1 = l \\left( \\frac{1}{\\sqrt{d}} \\sum_{i=1}^{d} W_i \\right)$。根据中心极限定理，$\\frac{1}{\\sqrt{d}} \\sum_{i=1}^{d} W_i \\xrightarrow{d} \\mathcal{N}(0, I)$。因此，$T_1 \\xrightarrow{d} \\mathcal{N}(0, l^2 I)$。\n\n第二项是 $T_2 = \\frac{l^2}{2} \\left( \\frac{1}{d} \\sum_{i=1}^{d} Z_i^2 g'(X_i) \\right)$。根据大数定律，该平均值依概率收敛于其期望：\n$$\n\\frac{1}{d} \\sum_{i=1}^{d} Z_i^2 g'(X_i) \\xrightarrow{p} \\mathbb{E}[Z_i^2 g'(X_i)] = \\mathbb{E}[Z_i^2]\\mathbb{E}[g'(X_i)] = 1 \\cdot \\mathbb{E}[g'(X_i)]\n$$\n使用给定的恒等式 $\\mathbb{E}[g'(X)] + \\mathbb{E}[g(X)^2] = 0$，我们有 $\\mathbb{E}[g'(X_i)] = -\\mathbb{E}[g(X_i)^2] = -I$。\n因此，$T_2 \\xrightarrow{p} \\frac{l^2}{2} (-I) = -\\frac{1}{2}l^2 I$。\n\n根据 Slutsky 定理，$\\Delta = T_1 + T_2 + O(d^{-1/2})$ 的极限分布是 $T_1$ 和 $T_2$ 极限的和：\n$$\n\\Delta \\xrightarrow{d} \\mathcal{N}\\left(-\\frac{1}{2}l^2 I, l^2 I\\right)\n$$\n极限下的平均接受概率为 $\\alpha(l) = \\mathbb{E}[\\min(1, \\exp(\\Delta_{\\infty}))]$，其中 $\\Delta_{\\infty} \\sim \\mathcal{N}\\left(-\\frac{1}{2}l^2 I, l^2 I\\right)$。令 $\\Delta_{\\infty} = -\\frac{1}{2}l^2 I + l\\sqrt{I} \\zeta$，其中 $\\zeta \\sim \\mathcal{N}(0,1)$。该期望为：\n$$\n\\alpha(l) = \\int_{-\\infty}^{\\infty} \\min(1, \\exp(-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta)) \\phi(\\zeta) d\\zeta\n$$\n其中 $\\phi(\\zeta)$ 是标准正态概率密度函数。当指数项小于1时，即 $-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta  0$ 时，项 $\\exp(-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta)$ 小于 1。这可以简化为 $\\zeta  \\frac{l\\sqrt{I}}{2}$。\n$$\n\\alpha(l) = \\int_{-\\infty}^{l\\sqrt{I}/2} \\exp(-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta) \\phi(\\zeta) d\\zeta + \\int_{l\\sqrt{I}/2}^{\\infty} 1 \\cdot \\phi(\\zeta) d\\zeta\n$$\n第二个积分是尾部概率 $P(\\zeta  l\\sqrt{I}/2) = 1 - \\Phi(l\\sqrt{I}/2) = \\Phi(-l\\sqrt{I}/2)$，其中 $\\Phi$ 是标准正态累积分布函数。\n对于第一个积分，我们对指数部分进行配方：指数函数的参数是 $\\exp(-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta) \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\zeta^2/2) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2}l^2 I + l\\sqrt{I}\\zeta - \\frac{\\zeta^2}{2})$。指数是 $-\\frac{1}{2}(\\zeta^2 - 2 l\\sqrt{I}\\zeta + l^2 I) = -\\frac{1}{2}(\\zeta-l\\sqrt{I})^2$。\n因此，第一个被积函数是 $\\frac{1}{\\sqrt{2\\pi}}\\exp(-\\frac{1}{2}(\\zeta-l\\sqrt{I})^2)$。\n积分变为 $\\int_{-\\infty}^{l\\sqrt{I}/2} \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2}(\\zeta-l\\sqrt{I})^2) d\\zeta$。令 $u = \\zeta-l\\sqrt{I}$。积分为 $\\int_{-\\infty}^{-l\\sqrt{I}/2} \\phi(u) du = \\Phi(-l\\sqrt{I}/2)$。\n因此，$\\alpha(l) = \\Phi(-l\\sqrt{I}/2) + \\Phi(-l\\sqrt{I}/2) = 2\\Phi(-l\\sqrt{I}/2)$。\n\n**第二部分：MCMC 效率的优化**\n\n采样器的效率被认为与期望平方跳跃距离成正比，即 $S(l) \\propto \\mathbb{E}[\\alpha(X,Y) \\|Y-X\\|^2]$。在高维极限下，接受概率 $\\alpha(X,Y)$ 收敛到上面推导出的确定性值 $\\alpha(l)$。跳跃向量为 $Y-X = \\sigma Z = \\frac{l}{\\sqrt{d}}Z$。平方跳跃距离为 $\\|Y-X\\|^2 = \\frac{l^2}{d}\\|Z\\|^2 = \\frac{l^2}{d}\\sum_{i=1}^d Z_i^2$。期望平方跳跃距离为 $\\mathbb{E}[\\|Y-X\\|^2] = \\frac{l^2}{d} \\sum_{i=1}^d \\mathbb{E}[Z_i^2] = \\frac{l^2}{d} \\cdot d = l^2$。\n因此，效率函数与 $l^2 \\alpha(l)$ 成正比。我们旨在最大化 $S(l) = l^2 \\alpha(l) = 2l^2 \\Phi(-l\\sqrt{I}/2)$。为简化起见，令 $k = l\\sqrt{I}$，我们对 $k0$ 最大化 $f(k) \\propto k^2 \\Phi(-k/2)$。\n我们将导数设为零：$\\frac{d}{dk} \\left(k^2 \\Phi(-k/2)\\right) = 0$。\n$$\n2k \\Phi(-k/2) + k^2 \\cdot \\phi(-k/2) \\cdot \\left(-\\frac{1}{2}\\right) = 0\n$$\n由于 $k0$，我们可以两边同除以 $k$。使用 $\\phi(-u)=\\phi(u)$：\n$$\n2 \\Phi(-k/2) - \\frac{k}{2} \\phi(k/2) = 0\n$$\n令 $x = k/2 = l\\sqrt{I}/2$，最优 $l$ 的条件由以下超越方程的解给出：\n$$\n2\\Phi(-x) = x\\phi(x)\n$$\n该方程隐式地定义了最优标度参数 $l$。\n\n**第三部分：渐进最优接受率**\n\n最优接受率 $\\alpha^\\star$ 对应于在第二部分中找到的最优标度参数 $l^\\star$ 下的 $\\alpha(l)$ 值。\n从第一部分可知，接受率为 $\\alpha(l) = 2\\Phi(-l\\sqrt{I}/2)$。在最优点，我们有 $\\alpha^\\star = 2\\Phi(-l^\\star\\sqrt{I}/2)$。\n从第二部分可知，最优性条件是 $2\\Phi(-l^\\star\\sqrt{I}/2) = \\frac{l^\\star\\sqrt{I}}{2} \\phi(l^\\star\\sqrt{I}/2)$。\n令 $x^\\star = l^\\star\\sqrt{I}/2$，我们可以将最优接受率写为：\n$$\n\\alpha^\\star = x^\\star \\phi(x^\\star)\n$$\n其中 $x^\\star$ 是方程 $2\\Phi(-x) = x\\phi(x)$ 的正解。这个方程必须通过数值方法求解。令 $h(x) = x\\phi(x) - 2\\Phi(-x)$。使用数值求根方法（如 Newton 法），我们找到解约为 $x^\\star \\approx 1.1906$。\n现在我们可以计算最优接受率的数值：\n$$\n\\alpha^\\star = x^\\star\\phi(x^\\star) = x^\\star \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x^\\star)^2}{2}\\right)\n$$\n代入 $x^\\star \\approx 1.1906$：\n$$\n\\alpha^\\star \\approx 1.1906 \\cdot \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{1.1906^2}{2}\\right) \\approx 1.1906 \\cdot \\frac{1}{2.5066} \\exp(-0.70877) \\approx 1.1906 \\cdot 0.39894 \\cdot 0.49220 \\approx 0.23377\n$$\n四舍五入到三位有效数字，最优接受率是 $0.234$。",
            "answer": "$$\n\\boxed{0.234}\n$$"
        },
        {
            "introduction": "在许多物理学和统计学问题中，参数并非无约束的，而是受到特定限制，例如分支比必须为正且总和为一。在原始受限空间中直接应用标准的MCMC提议通常效率低下或不正确。一种强大且通用的策略是通过变量变换将受限参数映射到无约束空间。本练习（）专注于推导此类变换的雅可比行列式，特别是用于单纯形上参数的加性对数比变换。掌握这项技术对于为各种实际贝叶斯推断问题正确实现MCMC采样器至关重要。",
            "id": "3521320",
            "problem": "在高能对撞机实验中，一个重中性共振衰变到 $d$ 个独占通道。设分支分数向量为 $b = (b_1, b_2, \\dots, b_d)$，其被约束在单位单纯形上，因此对所有 $i$ 都有 $b_i  0$ 且 $\\sum_{i=1}^{d} b_i = 1$。你观测到来自 $N = \\sum_{i=1}^{d} n_i$ 次衰变的计数 $n_1, n_2, \\dots, n_d$，并使用多项分布 $L(n \\mid b) \\propto \\prod_{i=1}^{d} b_i^{n_i}$ 对似然进行建模，其先验为狄利克雷分布 $p(b) \\propto \\prod_{i=1}^{d} b_i^{a_i - 1}$，其中超参数 $a_i  0$ 是固定的。你希望使用马尔可夫链蒙特卡洛（MCMC）方法，特别是Metropolis-Hastings（MH）方法，从后验分布 $\\pi_Y(b \\mid n) \\propto L(n \\mid b) p(b)$ 中进行采样，同时要遵守单纯形约束。\n\n为了构建一个无约束的参数化，考虑从单纯形到 $\\mathbb{R}^{d-1}$ 的加性对数比逻辑变换，定义为\n$$\nz_i = \\ln\\!\\left(\\frac{b_i}{b_d}\\right), \\quad i = 1, 2, \\dots, d-1,\n$$\n其逆映射为\n$$\nb_i(z) = \\frac{\\exp(z_i)}{1 + \\sum_{k=1}^{d-1} \\exp(z_k)}, \\quad i = 1, \\dots, d-1, \\qquad\nb_d(z) = \\frac{1}{1 + \\sum_{k=1}^{d-1} \\exp(z_k)}.\n$$\n你设计一个MH方案，通过在 $\\mathbb{R}^{d-1}$ 上的对称高斯随机游走 $q(z' \\mid z)$ 在无约束空间中进行提议，然后映射回 $b' = b(z')$ 以在物理空间中进行评估。根据变量替换公式，$z$-空间中的目标密度为\n$$\n\\pi_Z(z \\mid n) \\propto \\pi_Y(b(z) \\mid n) \\left| \\det\\!\\left(\\frac{\\partial b}{\\partial z}\\right) \\right|,\n$$\n其中 $\\frac{\\partial b}{\\partial z}$ 表示从 $z \\mapsto (b_1, \\dots, b_{d-1})$ 的逆映射的 $(d-1) \\times (d-1)$ 雅可比矩阵。\n\n从Metropolis-Hastings接受准则的基本定义和概率密度的变量替换定理出发，推导出所需的雅可比因子 $\\left| \\det\\!\\left(\\frac{\\partial b}{\\partial z}\\right) \\right|$，并将其表示为关于 $b_1, \\dots, b_d$ 的闭式表达式。将你的最终答案表示为单个解析表达式。不需要数值近似。",
            "solution": "该问题要求推导从一个受约束的单纯形空间到一个无约束的欧几里得空间进行变量替换时的雅可比因子 $\\left| \\det\\left(\\frac{\\partial b}{\\partial z}\\right) \\right|$。当在无约束空间中提议移动时，这个因子对于正确构建Metropolis-Hastings接受概率至关重要。\n\n设无约束变量的向量为 $z = (z_1, z_2, \\dots, z_{d-1}) \\in \\mathbb{R}^{d-1}$。问题定义了从这个空间映射回分支分数向量 $b = (b_1, b_2, \\dots, b_d)$ 的前 $d-1$ 个分量的映射。向量 $b$ 位于 $(d-1)$-维单纯形 $\\mathcal{S}^{d-1}$ 上，其定义为对于所有 $i=1, \\dots, d$ 都有 $b_i  0$ 且 $\\sum_{i=1}^{d} b_i = 1$。逆映射由下式给出：\n$$\nb_i(z) = \\frac{\\exp(z_i)}{1 + \\sum_{k=1}^{d-1} \\exp(z_k)}, \\quad i = 1, \\dots, d-1\n$$\n$$\nb_d(z) = \\frac{1}{1 + \\sum_{k=1}^{d-1} \\exp(z_k)}\n$$\n需要计算的量是雅可比矩阵 $J = \\frac{\\partial b}{\\partial z}$ 行列式的绝对值，其中 $J$ 是一个 $(d-1) \\times (d-1)$ 矩阵，其元素为 $J_{ij} = \\frac{\\partial b_i}{\\partial z_j}$，其中 $i, j \\in \\{1, 2, \\dots, d-1\\}$。\n\n首先，我们计算偏导数 $J_{ij}$。我们定义分母为 $S(z) = 1 + \\sum_{k=1}^{d-1} \\exp(z_k)$。根据所提供的映射定义，我们可以在 $b_i$ 和 $S$ 之间建立直接关系。\n注意到 $b_d = 1/S$ 且对于 $i=1, \\dots, d-1$ 有 $b_i = b_d \\exp(z_i)$。这意味着 $\\exp(z_i) = b_i/b_d$。\n我们可以验证 $S(z)$ 的一致性：\n$$\nS(z) = 1 + \\sum_{k=1}^{d-1} \\exp(z_k) = 1 + \\sum_{k=1}^{d-1} \\frac{b_k}{b_d} = \\frac{b_d + \\sum_{k=1}^{d-1} b_k}{b_d} = \\frac{\\sum_{k=1}^{d} b_k}{b_d} = \\frac{1}{b_d}\n$$\n这证实了 $b_i = \\exp(z_i) / S = \\exp(z_i) b_d$。\n\n现在，我们使用商法则计算 $i, j \\in \\{1, \\dots, d-1\\}$ 时的偏导数 $\\frac{\\partial b_i}{\\partial z_j}$。\n\n情况1：$i = j$。\n$$\n\\frac{\\partial b_i}{\\partial z_i} = \\frac{\\partial}{\\partial z_i} \\left( \\frac{\\exp(z_i)}{S(z)} \\right) = \\frac{\\frac{\\partial \\exp(z_i)}{\\partial z_i} S(z) - \\exp(z_i) \\frac{\\partial S(z)}{\\partial z_i}}{S(z)^2}\n$$\n由于 $\\frac{\\partial S(z)}{\\partial z_i} = \\exp(z_i)$，我们有：\n$$\n\\frac{\\partial b_i}{\\partial z_i} = \\frac{\\exp(z_i) S(z) - \\exp(z_i) \\exp(z_i)}{S(z)^2} = \\frac{\\exp(z_i)}{S(z)} - \\left( \\frac{\\exp(z_i)}{S(z)} \\right)^2\n$$\n代入 $b_i = \\exp(z_i)/S(z)$，我们得到：\n$$\n\\frac{\\partial b_i}{\\partial z_i} = b_i - b_i^2 = b_i(1 - b_i)\n$$\n\n情况2：$i \\neq j$。\n$$\n\\frac{\\partial b_i}{\\partial z_j} = \\frac{\\partial}{\\partial z_j} \\left( \\frac{\\exp(z_i)}{S(z)} \\right) = \\frac{0 \\cdot S(z) - \\exp(z_i) \\frac{\\partial S(z)}{\\partial z_j}}{S(z)^2}\n$$\n由于 $\\frac{\\partial S(z)}{\\partial z_j} = \\exp(z_j)$，我们有：\n$$\n\\frac{\\partial b_i}{\\partial z_j} = \\frac{-\\exp(z_i) \\exp(z_j)}{S(z)^2} = - \\left( \\frac{\\exp(z_i)}{S(z)} \\right) \\left( \\frac{\\exp(z_j)}{S(z)} \\right)\n$$\n代入 $b_i = \\exp(z_i)/S(z)$ 和 $b_j = \\exp(z_j)/S(z)$，我们得到：\n$$\n\\frac{\\partial b_i}{\\partial z_j} = -b_i b_j\n$$\n\n因此，雅可比矩阵 $J$ 的元素为：\n$$\nJ_{ij} = \\frac{\\partial b_i}{\\partial z_j} =\n\\begin{cases}\nb_i(1 - b_i)  \\text{if } i = j \\\\\n-b_i b_j  \\text{if } i \\neq j\n\\end{cases}\n$$\n这可以紧凑地写为 $J_{ij} = \\delta_{ij} b_i - b_i b_j$，其中 $\\delta_{ij}$ 是克罗内克δ。\n\n我们现在计算这个 $(d-1) \\times (d-1)$ 矩阵 $J$ 的行列式。我们可以从每一行 $i$ 中提出因子 $b_i$：\n$$\nJ = \n\\begin{pmatrix}\nb_1(1-b_1)  -b_1 b_2  \\dots  -b_1 b_{d-1} \\\\\n-b_2 b_1  b_2(1-b_2)  \\dots  -b_2 b_{d-1} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n-b_{d-1} b_1  -b_{d-1} b_2  \\dots  b_{d-1}(1-b_{d-1})\n\\end{pmatrix}\n$$\n令 $D = \\text{diag}(b_1, b_2, \\dots, b_{d-1})$。我们可以将 $J$ 写成 $J = D \\cdot M$，其中 $M$ 是元素为 $M_{ij} = \\delta_{ij} - b_j$ 的矩阵。\n$$\nM = \n\\begin{pmatrix}\n1-b_1  -b_2  \\dots  -b_{d-1} \\\\\n-b_1  1-b_2  \\dots  -b_{d-1} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n-b_1  -b_2  \\dots  1-b_{d-1}\n\\end{pmatrix}\n$$\n$J$ 的行列式是 $\\det(J) = \\det(D) \\det(M)$。\n对角矩阵 $D$ 的行列式就是其对角元素的乘积：\n$$\n\\det(D) = \\prod_{i=1}^{d-1} b_i\n$$\n为了求 $M$ 的行列式，我们注意到 $M$ 具有 $I - uv^T$ 的形式，其中 $I$ 是 $(d-1) \\times (d-1)$ 的单位矩阵， $u$ 是一个全为1的列向量，$u = (1, 1, \\dots, 1)^T$，而 $v$ 是前 $d-1$ 个分支分数的列向量，$v = (b_1, b_2, \\dots, b_{d-1})^T$。\n$$\nuv^T = \\begin{pmatrix} 1 \\\\ 1 \\\\ \\vdots \\\\ 1 \\end{pmatrix} \\begin{pmatrix} b_1  b_2  \\dots  b_{d-1} \\end{pmatrix} = \\begin{pmatrix}\nb_1  b_2  \\dots  b_{d-1} \\\\\nb_1  b_2  \\dots  b_{d-1} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nb_1  b_2  \\dots  b_{d-1}\n\\end{pmatrix}\n$$\n矩阵 $M$ 确实是 $I - uv^T$。根据矩阵行列式引理，对于任意向量 $u, v$，我们有 $\\det(I - uv^T) = 1 - v^T u$。\n在我们的例子中，\n$$\nv^T u = \\begin{pmatrix} b_1  b_2  \\dots  b_{d-1} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ \\vdots \\\\ 1 \\end{pmatrix} = \\sum_{k=1}^{d-1} b_k\n$$\n因此，$M$ 的行列式是：\n$$\n\\det(M) = 1 - \\sum_{k=1}^{d-1} b_k\n$$\n使用单纯形约束 $\\sum_{k=1}^{d} b_k = 1$，我们可以用 $b_d$ 来表示这个结果：\n$$\n1 - \\sum_{k=1}^{d-1} b_k = b_d\n$$\n所以，$\\det(M) = b_d$。\n\n结合这些结果，雅可比矩阵 $J$ 的行列式是：\n$$\n\\det(J) = \\det(D) \\det(M) = \\left( \\prod_{i=1}^{d-1} b_i \\right) b_d\n$$\n这给出了所有 $d$ 个分支分数的乘积：\n$$\n\\det(J) = \\prod_{i=1}^{d} b_i\n$$\n最后一步是根据概率密度的变量替换公式要求，取其绝对值。问题说明对于所有 $i$，$b_i  0$。因此，乘积 $\\prod_{i=1}^{d} b_i$ 是严格为正的。\n因此，所需的雅可比因子是：\n$$\n\\left| \\det\\left(\\frac{\\partial b}{\\partial z}\\right) \\right| = \\left| \\prod_{i=1}^{d} b_i \\right| = \\prod_{i=1}^{d} b_i\n$$\n这就是雅可比行列式关于分支分数 $b_1, \\dots, b_d$ 的闭式表达式。",
            "answer": "$$\\boxed{\\prod_{i=1}^{d} b_i}$$"
        },
        {
            "introduction": "标准的MCMC算法在处理多峰目标分布时可能会遇到困难，常常被困在单个模式中，无法充分探索整个参数空间。并行回火（或称副本交换MCMC）是一种先进的方法，通过在不同“温度”下模拟系统的多个副本并允许它们交换构型来克服这一挑战。这个动手实践问题（）要求你为此类模拟设计一个最优的温度阶梯。你将从物理原理出发，推导温度的间隔规则，以确保相邻副本之间具有高且均匀的交换概率，从而最大化算法在复杂能量景观中导航的效率。",
            "id": "3521299",
            "problem": "您的任务是构建一个完整、可运行的程序，为在格点规范理论设置中对不同瞬子扇区进行采样的回火跃迁设计一个温度阶梯。规范场上的目标分布由具有作用量 $S(U)$ 的玻尔兹曼权重给出，因此构型的分布遵循 $\\pi_{\\beta}(U) \\propto \\exp(-\\beta S(U))$，其中 $\\beta = 1/T$ 是逆温度，T 是温度。考虑一组 m 个副本，其温度为 $T_1  T_2  \\dots  T_m$，并允许在相邻温度之间进行副本交换移动。对于一个交换副本 i 和 j 之间构型的提议，Metropolis-Hastings 接受概率为\n$$\n\\alpha_{i \\leftrightarrow j} = \\min\\left\\{1, \\exp\\left[(1/T_i - 1/T_j)(S(U_j) - S(U_i))\\right]\\right\\}。\n$$\n您的目标是设计温度阶梯 $T_1, T_2, \\dots, T_m$，在由固定副本数 m 和固定边界温度 $T_1$ 与 $T_m$ 决定的固定计算预算下，最大化相邻副本之间的期望交换接受率。您必须从马尔可夫链蒙特卡洛（MCMC）的基本原理，特别是 Metropolis-Hastings 方法，以及经过充分检验的热力学事实出发来构建这个阶梯。\n\n起始点与建模假设：\n- 使用正则系综，逆温度为 $\\beta = 1/T$，玻尔兹曼常数设为 $k_B = 1$。\n- 将作用量建模为随机变量 $E$，其服从与恒定热容 $C_v$ 一致的高斯分布：\n  - 均值 $\\mu(T) = E_0 + C_v T$，\n  - 方差 $\\sigma^2(T) = C_v T^2$。\n- 这些关系与标准的正则系综恒等式一致：$\\mathrm{Var}(E) = C_v T^2$ 和 $d\\langle E\\rangle/dT = C_v$，以及 $d\\langle E\\rangle/d\\beta = -\\mathrm{Var}(E)$，从而确保了在计算高能物理学中的科学真实性。\n\n任务：\n1. 从第一性原理出发，设计一个算法，在副本间温度间隔较小的情况下，通过适当地设置阶梯上逆温度 $\\beta_i = 1/T_i$ 的间距，近似地最大化相邻副本之间的期望交换接受率。您必须从 Metropolis-Hastings 接受率的定义和高斯作用量模型出发，使用在小增量下有效的、有原则的近似方法来推导间距规则。\n2. 实现一个数值稳定的函数，用于计算在两个温度 $T_i$ 和 $T_j$ 之间，基于高斯模型的期望交换接受率，而无需模拟单个规范场构型。该期望值必须通过对 $E_i \\sim \\mathcal{N}(\\mu(T_i),\\sigma^2(T_i))$ 和 $E_j \\sim \\mathcal{N}(\\mu(T_j),\\sigma^2(T_j))$ 的高斯分布进行解析积分来计算。\n3. 使用您推导出的间距规则，为下面的每个测试用例构建温度阶梯。确保温度严格递增且在规定的边界内。\n4. 对每个测试用例，将温度阶梯输出为一组浮点数列表，四舍五入到六位小数。\n\n测试套件：\n- 案例 A（一般情况）：$m=6$， $T_1=0.5$， $T_m=2.0$， $C_v=20$， $E_0=0.0$。\n- 案例 B（不同范围和偏移）：$m=5$， $T_1=0.7$， $T_m=1.8$， $C_v=15$， $E_0=1.0$。\n- 案例 C（在较高热容下具有紧凑阶梯的边缘情况）：$m=4$， $T_1=0.9$，$T_m=1.2$，$C_v=50$，$E_0=0.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的阶梯，形式为用方括号括起来的逗号分隔列表，其中每个元素本身就是针对一个测试用例的温度列表（例如， $[[t_{1,1},t_{1,2},\\dots,t_{1,m}], [t_{2,1},\\dots,t_{2,m}], [t_{3,1},\\dots,t_{3,m}]]$）。\n- 所有温度必须四舍五入到六位小数。\n- 在此公式中，温度是无量纲的，因此无需打印物理单位。",
            "solution": "该问题要求为副本交换蒙特卡洛（也称为并行回火）设计一个最优的温度阶梯。目标是在给定固定副本数 m 和边界温度 $T_1$ 与 $T_m$ 的情况下，最大化相邻副本之间的交换接受率。在给定温度 $T$ 下，系统的作用量（能量）$S(U)$ 被建模为一个高斯随机变量 E，其均值为 $\\mu(T) = E_0 + C_v T$，方差为 $\\sigma^2(T) = C_v T^2$。\n\n### 基于原理的温度间距规则推导\n\n**1. 最大化交换接受率**\n\n在温度为 $T_i$ 和 $T_{i+1}$（对应逆温度为 $\\beta_i=1/T_i$ 和 $\\beta_{i+1}=1/T_{i+1}$）的副本之间交换构型的 Metropolis-Hastings 接受概率由下式给出：\n$$\n\\alpha_{i \\leftrightarrow i+1} = \\min\\left\\{1, \\exp\\left[(\\beta_i - \\beta_{i+1})(E_{i+1} - E_i)\\right]\\right\\}\n$$\n其中 $E_i$ 和 $E_{i+1}$ 分别是各自副本中构型的能量。为了确保在温度空间中进行有效的随机游走，我们希望在所有相邻对 $(i, i+1)$ 上都有一个均匀（且高）的接受概率 $\\langle \\alpha_{i \\leftrightarrow i+1} \\rangle$。阶梯中任何地方出现低接受率的瓶颈都会困住构型，从而阻碍采样效率。\n\n**2. 热力学距离启发式方法**\n\n直接求解方程 $\\langle \\alpha_{i \\leftrightarrow i+1} \\rangle = \\text{const}$ 对所有 $i$ 而言在解析上是具有挑战性的。一个被广泛使用且有效的启发式方法是转而要求相邻温度之间的“热力学距离”是恒定的。这基于以下推理：对于较小的温度间隙，接受概率是相邻副本能量分布之间统计重叠的单调函数。通过保持这种重叠恒定，我们期望接受率也大致恒定。\n\n**3. 定义度量**\n\n一种定义两个无限接近的逆温度 $\\beta$ 和 $\\beta+d\\beta$ 处的统计系统之间距离的自然方式是通过信息几何度量。度量元 $ds$ 可以选择为与 $d\\beta$ 成正比，并乘以一个考虑了典型能量涨落的因子。一个标准的选择（可以从正则系综的 Fisher 信息度量中推导出来）是将步长与能量的标准差 $\\sigma_E(T)$ 相关联。我们将无穷小距离定义为：\n$$\nds \\propto d\\beta \\cdot \\sigma_E(T)\n$$\n使用给定的模型，$\\sigma_E(T) = \\sqrt{\\mathrm{Var}(E)} = \\sqrt{C_v T^2} = \\sqrt{C_v} T$。代入 $T=1/\\beta$：\n$$\nds = k \\cdot d\\beta \\cdot \\frac{\\sqrt{C_v}}{\\beta}\n$$\n其中 k 是任意比例常数。为了使间距最优，我们需要在这个新坐标 s 中采取相等的步长。\n\n**4. 积分与离散化**\n\n为了在 $T_1$（或 $\\beta_1$）和 $T_m$（或 $\\beta_m$）之间创建 $m-1$ 个相等的区间，我们首先通过在整个范围内对 $ds$ 进行积分来计算总热力学距离 $S_{total}$。由于我们有 $T_1  T_m$，因此 $\\beta_1 > \\beta_m$。\n$$\nS_{total} = \\int_{\\beta_m}^{\\beta_1} k \\frac{\\sqrt{C_v}}{\\beta} d\\beta = k\\sqrt{C_v} [\\ln \\beta]_{\\beta_m}^{\\beta_1} = k\\sqrt{C_v} (\\ln \\beta_1 - \\ln \\beta_m)\n$$\n我们将这个总距离分成 $m-1$ 个相等的段，每段长度为 $\\Delta S = \\frac{S_{total}}{m-1}$。温度阶梯的条件是任何相邻对 $(\\beta_{i+1}, \\beta_i)$ 之间的距离都等于 $\\Delta S$：\n$$\n\\int_{\\beta_{i+1}}^{\\beta_i} k \\frac{\\sqrt{C_v}}{\\beta} d\\beta = \\Delta S\n$$\n这得到：\n$$\nk\\sqrt{C_v} (\\ln \\beta_i - \\ln \\beta_{i+1}) = \\frac{k\\sqrt{C_v} (\\ln \\beta_1 - \\ln \\beta_m)}{m-1}\n$$\n简化后，我们得到核心的间距规则：\n$$\n\\ln \\beta_i - \\ln \\beta_{i+1} = \\frac{\\ln \\beta_1 - \\ln \\beta_m}{m-1} = \\text{const}\n$$\n这表明逆温度的对数 $\\ln \\beta_i$ 必须是线性间隔的。\n\n**5. 等比级数规则**\n\n$\\ln \\beta_i$ 的线性间距意味着 $\\beta_i$ 值本身成等比级数。设常数差为 $C = \\ln\\beta_i - \\ln\\beta_{i+1}$。那么 $\\ln\\beta_{i+1} = \\ln\\beta_i - C$，这意味着 $\\beta_{i+1} = \\beta_i e^{-C}$。逆温度构成一个等比数列。\n\n第 $i$ 个逆温度 $\\beta_i$（对于 $i=1, \\dots, m$）可以表示为：\n$$\n\\beta_i = \\beta_1 \\cdot r^{i-1}\n$$\n其中 $r$ 是公比。我们可以使用在 $i=m$ 处的边界条件来求 $r$：\n$$\n\\beta_m = \\beta_1 \\cdot r^{m-1} \\implies r = \\left(\\frac{\\beta_m}{\\beta_1}\\right)^{\\frac{1}{m-1}}\n$$\n由于 $T_i = 1/\\beta_i$，温度也构成一个等比级数：\n$$\nT_i = \\frac{1}{\\beta_1 \\cdot r^{i-1}} = T_1 \\cdot \\left(\\frac{1}{r}\\right)^{i-1}\n$$\n设温度比为 $q = 1/r$。代入 $r$ 的表达式：\n$$\nq = \\left(\\frac{\\beta_1}{\\beta_m}\\right)^{\\frac{1}{m-1}} = \\left(\\frac{T_m}{T_1}\\right)^{\\frac{1}{m-1}}\n$$\n因此，温度阶梯由以下等比级数给出：\n$$\nT_i = T_1 \\cdot q^{i-1} = T_1 \\cdot \\left(\\frac{T_m}{T_1}\\right)^{\\frac{i-1}{m-1}} \\quad \\text{for } i = 1, 2, \\dots, m\n$$\n这个算法仅依赖于边界温度 $T_1$、$T_m$ 和副本数 m。恒定热容 $C_v$ 的具体值对推导至关重要（特别是 $C_v$ 是恒定的这一事实），但在最终的相对间距公式中被消去了。\n\n### 期望接受率的解析公式\n\n作为次要任务，我们推导了两个温度 $T_a$ 和 $T_b$ 之间期望交换接受概率 $\\langle \\alpha_{a \\leftrightarrow b} \\rangle$ 的解析表达式。设 $T_b > T_a$，则 $\\beta_b  \\beta_a$。交换指数为 $X = (\\beta_a - \\beta_b)(E_b - E_a)$。由于 $E_a$ 和 $E_b$ 是独立的高斯变量，$E_a \\sim \\mathcal{N}(\\mu_a, \\sigma_a^2)$ 和 $E_b \\sim \\mathcal{N}(\\mu_b, \\sigma_b^2)$，它们的差 $E_b - E_a$ 也是高斯分布的。因此，$X$ 是一个高斯随机变量，$X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$，其参数为：\n$$\n\\mu_X = (\\beta_a - \\beta_b)(\\mu_b - \\mu_a) = C_v \\frac{(T_b - T_a)^2}{T_a T_b}\n$$\n$$\n\\sigma_X^2 = (\\beta_a - \\beta_b)^2 (\\sigma_a^2 + \\sigma_b^2) = C_v \\frac{(T_b - T_a)^2 (T_a^2 + T_b^2)}{(T_a T_b)^2}\n$$\n期望接受率是 $X$ 的分布 $p(x)$ 上的积分：\n$$\n\\langle \\alpha \\rangle = \\int_{-\\infty}^{\\infty} \\min(1, e^x) p(x) dx = \\int_{-\\infty}^{0} e^x p(x) dx + \\int_{0}^{\\infty} p(x) dx\n$$\n这些积分的计算得出了闭式表达式：\n$$\n\\langle \\alpha \\rangle = e^{\\mu_X + \\sigma_X^2/2} \\Phi\\left(-\\frac{\\mu_X + \\sigma_X^2}{\\sigma_X}\\right) + \\Phi\\left(\\frac{\\mu_X}{\\sigma_X}\\right)\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数（CDF）。这个公式可以用于验证，但并未用于构建温度阶梯本身。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_expected_acceptance(Ta, Tb, Cv, E0):\n    \"\"\"\n    Computes the expected swap acceptance probability between two replicas\n    at temperatures Ta and Tb, based on the analytical formula for a\n    Gaussian energy model.\n\n    This function is implemented as per the problem description but is not\n    used for generating the temperature ladder itself.\n\n    Args:\n        Ta (float): Temperature of the first replica.\n        Tb (float): Temperature of the second replica.\n        Cv (float): Constant volume heat capacity.\n        E0 (float): Energy offset.\n\n    Returns:\n        float: The expected acceptance probability.\n    \"\"\"\n    if Ta == Tb:\n        return 1.0\n\n    # Ensure Ta  Tb for consistency\n    if Ta  Tb:\n        Ta, Tb = Tb, Ta\n\n    beta_a = 1.0 / Ta\n    beta_b = 1.0 / Tb\n\n    # Parameters for the energy distributions E_a and E_b\n    # mu_a = E0 + Cv * Ta\n    # mu_b = E0 + Cv * Tb\n    # sigma_sq_a = Cv * Ta**2\n    # sigma_sq_b = Cv * Tb**2\n    \n    # The random variable for the exponent is X = (beta_a - beta_b) * (E_b - E_a)\n    # X follows a normal distribution N(mu_X, sigma_sq_X)\n    \n    # Calculate mu_X\n    mu_b_minus_mu_a = Cv * (Tb - Ta)\n    beta_a_minus_beta_b = (1.0 / Ta) - (1.0 / Tb)\n    mu_X = beta_a_minus_beta_b * mu_b_minus_mu_a\n\n    # Calculate sigma_sq_X\n    sigma_sq_a_plus_sigma_sq_b = Cv * (Ta**2 + Tb**2)\n    sigma_sq_X = (beta_a_minus_beta_b**2) * sigma_sq_a_plus_sigma_sq_b\n\n    if sigma_sq_X  1e-12: # Avoid division by zero if temperatures are very close\n        return 1.0 if mu_X =0 else np.exp(mu_X)\n\n    sigma_X = np.sqrt(sigma_sq_X)\n\n    # The formula for expected acceptance is:\n    # E[alpha] = exp(mu_X + sigma_sq_X/2) * Phi(-(mu_X + sigma_sq_X)/sigma_X) + Phi(mu_X/sigma_X)\n    # where Phi is the standard normal CDF.\n\n    # This can be numerically unstable if the arguments are large.\n    # We use log-space calculations for the first term.\n    arg1_cdf = -(mu_X + sigma_sq_X) / sigma_X\n    log_term1 = mu_X + sigma_sq_X / 2.0 + norm.logcdf(arg1_cdf)\n    term1 = np.exp(log_term1)\n    \n    arg2_cdf = mu_X / sigma_X\n    term2 = norm.cdf(arg2_cdf)\n\n    return term1 + term2\n\ndef construct_temperature_ladder(m, T1, Tm, Cv, E0):\n    \"\"\"\n    Constructs a temperature ladder with m replicas between T1 and Tm.\n\n    The ladder is a geometric progression in temperature, derived from the\n    principle of keeping the \"thermodynamic distance\" between adjacent\n    replicas constant for a system with constant heat capacity Cv.\n\n    Args:\n        m (int): The number of replicas.\n        T1 (float): The lowest temperature.\n        Tm (float): The highest temperature.\n        Cv (float): Constant volume heat capacity (used in derivation, not formula).\n        E0 (float): Energy offset (used in derivation, not formula).\n\n    Returns:\n        list[float]: A list of m temperatures forming the ladder.\n    \"\"\"\n    if m  2:\n        return [T1] if m == 1 else []\n        \n    # The temperatures {T_i} form a geometric progression T_i = T_1 * q^(i-1)\n    # The ratio q is determined by the boundary conditions T_1 and T_m.\n    # T_m = T_1 * q^(m-1) = q = (T_m / T_1)^(1 / (m-1))\n    \n    ratio = (Tm / T1)**(1.0 / (m - 1))\n    \n    temperatures = [T1 * (ratio**i) for i in range(m)]\n    \n    return temperatures\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: m=6, T1=0.5, Tm=2.0, Cv=20, E0=0.0\n        {'m': 6, 'T1': 0.5, 'Tm': 2.0, 'Cv': 20, 'E0': 0.0},\n        # Case B: m=5, T1=0.7, Tm=1.8, Cv=15, E0=1.0\n        {'m': 5, 'T1': 0.7, 'Tm': 1.8, 'Cv': 15, 'E0': 1.0},\n        # Case C: m=4, T1=0.9, Tm=1.2, Cv=50, E0=0.0\n        {'m': 4, 'T1': 0.9, 'Tm': 1.2, 'Cv': 50, 'E0': 0.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        ladder = construct_temperature_ladder(case['m'], case['T1'], case['Tm'], case['Cv'], case['E0'])\n        # Format results to six decimal places as required.\n        formatted_ladder = [f\"{temp:.6f}\" for temp in ladder]\n        all_results.append(formatted_ladder)\n\n    # Format the final output string to be exactly as specified:\n    # [[t1,t2,...],[...]] with no spaces.\n    inner_strings = []\n    for res_list in all_results:\n        inner_str = '[' + ','.join(res_list) + ']'\n        inner_strings.append(inner_str)\n    \n    final_output_string = '[' + ','.join(inner_strings) + ']'\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}