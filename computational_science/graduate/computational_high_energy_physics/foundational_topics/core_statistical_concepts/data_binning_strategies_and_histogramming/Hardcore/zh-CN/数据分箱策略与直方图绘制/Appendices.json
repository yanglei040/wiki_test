{
    "hands_on_practices": [
        {
            "introduction": "任何基于直方图的分析，其最基础的操作便是将数据点正确地填入对应的区间中。在实践中，我们普遍采用半开区间 $[b_i, b_{i+1})$ 的约定来避免数据点在边界上被重复计算，但其在代码实现中，尤其是在处理浮点数精度问题时，需要特别小心。这项实践将帮助你构建一个数值上稳健的装箱算法，该算法能够正确处理机器精度极限下的边界情况，这是科学计算软件中一个至关重要但常被忽视的细节 。",
            "id": "3510256",
            "problem": "给定一个由实值构成的有序区间边界数组 $b_0  b_1  \\cdots  b_M$（其中 $M \\ge 2$），该数组根据约定 $[b_i, b_{i+1})$（对于 $i \\in \\{0,1,\\dots,M-1\\}$）定义了半开直方图区间。在计算高能物理学中，诸如横向动量 $p_T$ 等物理可观测量以吉电子伏特 (GeV) 为单位进行测量，而直方图的构建要求在浮点数边界附近有明确且可复现的区间分配。根据半开约定，任何满足 $b_i \\le x  b_{i+1}$ 的值 $x$ 都必须被分配到区间索引 $i$；值 $x  b_0$ 为下溢；值 $x \\ge b_M$ 为上溢（即被排除在已定义的区间之外）。您的任务是实现一个数值稳定的分配函数，该函数遵循半开区间的定义，并能避免对极度接近 $b_{i+1}$ 的值发生浮点边界误分类。\n\n从以下基础概念出发：\n- 电气与电子工程师协会 (IEEE) $754$ 浮点标准定义了实数轴上可表示的数，其间距与机器相关，包含了最低有效位 (ULP) 的概念，并提供了后继/前驱函数 $\\operatorname{nextafter}(y, z)$，该函数返回紧邻 $y$ 且朝向 $z$ 方向的可表示数。\n- 当比较操作被恰当定义时，在有序数组上进行单调二分搜索可以产生与全序比较和半开区间划分一致的索引。\n- 半开划分 $[b_i, b_{i+1})$ 是不相交的，并覆盖了区间 $[b_0, b_M)$。\n\n设计并实现一个分配函数，该函数：\n1. 对于每个输入值 $x$，当 $b_0 \\le x  b_M$ 时，返回一个有效的区间索引 $i \\in \\{0,\\dots,M-1\\}$，并从区间计数中排除下溢（$x  b_0$）和上溢（$x \\ge b_M$）的值。\n2. 确保在浮点表示中等于右边界 $b_{i+1}$ 的值被分配到下一个区间 $i+1$（遵循半开区间的规则），并通过使用与 IEEE $754$ 语义一致的比较策略或边界处理方法，而不是临时的绝对容差，来防止与 $b_{i+1}$ 相差一个 ULP 以内的值被错误分类。\n3. 对给定的测试数据，以整数形式生成每个区间的计数。\n\n将您的解决方案实现为一个完整的、可运行的程序。使用以下测试套件。所有可观测量均以吉电子伏特 (GeV) 为单位；计数是无量纲的整数。在所有情况下，均采用半开约定 $[b_i, b_{i+1})$，并从计数中排除下溢（$x  b_0$）和上溢（$x \\ge b_M$）。\n\n测试用例 1（正常路径，显式边界探测）：\n- 区间边界 $b = [0.0, 50.0, 100.0, 200.0]$ GeV。\n- 值 $x$ (GeV)：$[0.0, 12.5, \\operatorname{nextafter}(50.0, -\\infty), 50.0, \\operatorname{nextafter}(50.0, +\\infty), 75.0, \\operatorname{nextafter}(100.0, -\\infty), 100.0, \\operatorname{nextafter}(100.0, +\\infty), 150.0, \\operatorname{nextafter}(200.0, -\\infty), 200.0, 250.0]$。\n\n测试用例 2（横向动量中典型的非均匀区间）：\n- 区间边界 $b = [0.5, 1.0, 2.0, 5.0, 10.0]$ GeV。\n- 值 $x$ (GeV)：$[0.4999, 0.5, \\operatorname{nextafter}(0.5, +\\infty), \\operatorname{nextafter}(1.0, -\\infty), 1.0, \\operatorname{nextafter}(1.0, +\\infty), 1.5, \\operatorname{nextafter}(2.0, -\\infty), 2.0, 3.0, \\operatorname{nextafter}(5.0, -\\infty), 5.0, 7.5, \\operatorname{nextafter}(10.0, -\\infty), 10.0]$。\n\n测试用例 3（小上界范围的边界压力测试）：\n- 区间边界 $b = [0.0, 0.1, 1.0]$ GeV。\n- 值 $x$ (GeV)：$[-10^{-12}, 0.0, \\operatorname{nextafter}(0.0, +\\infty), \\operatorname{nextafter}(0.1, -\\infty), 0.1, \\operatorname{nextafter}(0.1, +\\infty), \\operatorname{nextafter}(1.0, -\\infty), 1.0]$。\n\n测试用例 4（更宽的物理学驱动范围）：\n- 区间边界 $b = [0.0, 20.0, 50.0, 100.0, 200.0, 400.0]$ GeV。\n- 值 $x$ (GeV)：$[0.0, \\operatorname{nextafter}(20.0, -\\infty), 20.0, 35.0, \\operatorname{nextafter}(50.0, -\\infty), 50.0, 75.0, \\operatorname{nextafter}(100.0, -\\infty), 100.0, 150.0, \\operatorname{nextafter}(200.0, -\\infty), 200.0, 300.0, \\operatorname{nextafter}(400.0, -\\infty), 400.0, 800.0]$。\n\n您的程序必须输出单行结果，格式为方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是遵循半开分配规则的、排除了下溢和上溢的每个区间的计数值列表。具体来说，输出格式必须是：\n\"[$R_1, R_2, R_3, R_4$]\"\n其中 $R_k$ 是测试用例 $k$ 按区间顺序 $i = 0,1,\\dots,M-1$ 的整数计数值列表。例如，一个元素可能看起来像 \"[3,4,4]\"。不得打印任何其他文本。",
            "solution": "该问题要求实现一个数值稳定的直方图分箱函数。给定一个由 $M+1$ 个区间边界组成的有序数组 $b = \\{b_0, b_1, \\dots, b_M\\}$，其中 $b_0  b_1  \\cdots  b_M$，以及一组数据值 $\\{x\\}$，我们必须将每个值 $x$ 分配到一个唯一的区间索引 $i \\in \\{0, 1, \\dots, M-1\\}$。分箱约定由半开区间 $[b_i, b_{i+1})$ 定义，这意味着当且仅当条件 $b_i \\le x  b_{i+1}$ 满足时，值 $x$ 才属于区间 $i$。位于总范围 $[b_0, b_M)$ 之外的值，特别是下溢（$x  b_0$）和上溢（$x \\ge b_M$），应从计数中排除。主要挑战是确保这一逻辑得到稳健地执行，特别是对于极度接近区间边界 $b_{i+1}$ 的浮点值，并且不能依赖临时的绝对容差。\n\n解决方案必须基于 IEEE 754 浮点算术的形式化属性。标准比较运算符（$, \\le, >, \\ge$）对所有可表示的浮点数都有明确的定义。因此，正确实现严格不等式 $x  b_{i+1}$ 的关键在于正确使用这些基本运算符，而高质量的数值库正是这样做的。问题中提到的 $\\operatorname{nextafter}(y, z)$ 用于构造测试值，以机器精度探测这些边界条件。\n\n一个稳健且高效的算法可以通过二分搜索的原理来构建，因为区间边界是排序的。`NumPy` 库提供了一个高度优化且经过充分测试的函数 `numpy.digitize`，它正是为此目的而设计的。该函数能为数组中的每个值找到 ULP 精度的区间。\n\n具体的实现策略如下：\n\n1.  **使用 `numpy.digitize` 进行区间索引**：我们将使用函数 `numpy.digitize(x, bins, right=False)`。`bins` 参数对应我们的边界数组 $b$，$x$ 是要分箱的值数组。参数 `right=False` 指定区间形式为 $[b_{i-1}, b_i)$，这与我们要求的约定 $[b_i, b_{i+1})$ 直接对应。该函数返回从 1 开始的索引。\n    - 对于满足 $b_i \\le x  b_{i+1}$（其中 $i \\in \\{0, \\dots, M-1\\}$）的值 $x$，`numpy.digitize` 返回索引 $i+1$。\n    - 对于下溢值 $x  b_0$，它返回 $0$。\n    - 对于上溢值 $x \\ge b_M$，它返回 $M+1$。\n\n2.  **索引转换**：`numpy.digitize` 返回的从 1 开始的索引可以转换为更便于我们使用的从 0 开始的区间表示。通过从返回的索引数组中减去 $1$：\n    - 位于区间 $i$（对于 $i \\in \\{0, \\dots, M-1\\}$）中的值被映射到索引 $(i+1) - 1 = i$。\n    - 下溢值被映射到索引 $0 - 1 = -1$。\n    - 上溢值被映射到索引 $(M+1) - 1 = M$。\n    这样就形成了一个清晰的区分：有效的区间索引落在 $[0, M-1]$ 范围内，而下溢和上溢则被映射到此范围之外的索引。\n\n3.  **筛选与计数**：现在我们可以分离出落在已定义区间内的值。我们创建一个布尔掩码来仅选择满足 $0 \\le i_{bin}  M$ 的索引 $i_{bin}$。应用此掩码后，我们得到一个包含所有在范围内的值的有效、从 0 开始的区间编号数组。\n\n4.  **使用 `numpy.bincount` 进行聚合**：最后一步是计算每个区间索引出现的次数。`numpy.bincount` 函数非常适合此任务。它接受一个非负整数数组，并返回一个数组，其中索引 $k$ 处的值是 $k$ 在输入数组中出现的次数。通过提供 `minlength=M` 参数，我们确保结果计数数组的长度等于区间的数量，对于碰巧为空的区间，其计数值为 $0$。这样就生成了所需的每个区间的计数值。\n\n这种方法不仅计算效率高，而且数值上也很稳健。它依赖于一个标准的、经过严格审查的库函数（`numpy.digitize`），该函数在浮点精度的极限下正确实现比较，从而满足了问题的所有要求。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the histogram binning problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"b_edges\": [0.0, 50.0, 100.0, 200.0],\n            \"x_values\": [\n                0.0, \n                12.5, \n                np.nextafter(50.0, -np.inf), \n                50.0, \n                np.nextafter(50.0, np.inf), \n                75.0, \n                np.nextafter(100.0, -np.inf), \n                100.0, \n                np.nextafter(100.0, np.inf), \n                150.0, \n                np.nextafter(200.0, -np.inf), \n                200.0, \n                250.0\n            ]\n        },\n        {\n            \"b_edges\": [0.5, 1.0, 2.0, 5.0, 10.0],\n            \"x_values\": [\n                0.4999, \n                0.5, \n                np.nextafter(0.5, np.inf), \n                np.nextafter(1.0, -np.inf), \n                1.0, \n                np.nextafter(1.0, np.inf), \n                1.5, \n                np.nextafter(2.0, -np.inf), \n                2.0, \n                3.0, \n                np.nextafter(5.0, -np.inf), \n                5.0, \n                7.5, \n                np.nextafter(10.0, -np.inf), \n                10.0\n            ]\n        },\n        {\n            \"b_edges\": [0.0, 0.1, 1.0],\n            \"x_values\": [\n                -1e-12, \n                0.0, \n                np.nextafter(0.0, np.inf), \n                np.nextafter(0.1, -np.inf), \n                0.1, \n                np.nextafter(0.1, np.inf), \n                np.nextafter(1.0, -np.inf), \n                1.0\n            ]\n        },\n        {\n            \"b_edges\": [0.0, 20.0, 50.0, 100.0, 200.0, 400.0],\n            \"x_values\": [\n                0.0, \n                np.nextafter(20.0, -np.inf), \n                20.0, \n                35.0, \n                np.nextafter(50.0, -np.inf), \n                50.0, \n                75.0, \n                np.nextafter(100.0, -np.inf), \n                100.0, \n                150.0, \n                np.nextafter(200.0, -np.inf), \n                200.0, \n                300.0, \n                np.nextafter(400.0, -np.inf), \n                400.0, \n                800.0\n            ]\n        }\n    ]\n\n    def calculate_bin_counts(b_edges_np, x_values_np):\n        \"\"\"\n        Calculates per-bin counts for given edges and values.\n\n        Args:\n            b_edges_np (np.ndarray): Sorted array of bin edges.\n            x_values_np (np.ndarray): Array of values to bin.\n\n        Returns:\n            list: A list of integer counts for each bin.\n        \"\"\"\n        num_bins = len(b_edges_np) - 1\n        \n        # np.digitize uses right=False for [b[i-1], b[i]) interval convention.\n        # It returns 1-based bin indices.\n        # Underflows (x  b[0]) get index 0.\n        # Overflows (x >= b[-1]) get index len(b).\n        digitized_indices = np.digitize(x_values_np, b_edges_np, right=False)\n        \n        # Convert to 0-based indices:\n        # A value in bin `i` gets index `i`.\n        # Underflows get index -1.\n        # Overflows get index num_bins.\n        bin_indices = digitized_indices - 1\n        \n        # Filter for indices that correspond to actual bins (0 to num_bins-1)\n        valid_mask = (bin_indices >= 0)  (bin_indices  num_bins)\n        valid_indices = bin_indices[valid_mask]\n        \n        # Count occurrences of each valid bin index.\n        # minlength ensures all bins are represented in the output, even if empty.\n        counts = np.bincount(valid_indices, minlength=num_bins)\n        \n        return counts.tolist()\n\n    all_results = []\n    for case in test_cases:\n        b = np.array(case[\"b_edges\"], dtype=float)\n        x = np.array(case[\"x_values\"], dtype=float)\n        \n        counts = calculate_bin_counts(b, x)\n        all_results.append(counts)\n\n    # Format the final output string according to the specification.\n    # R_k is formatted as a string like \"[c1,c2,c3]\" with no spaces.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    \n    # The final output is a comma-separated list of these formatted strings,\n    # enclosed in a single pair of square brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何填充直方图之后，一个关键问题随之而来：箱宽（bin width）应该设为多少？箱宽 $h$ 的选择是一个经典的“偏差-方差权衡”问题，过窄的箱宽会引入高方差（统计涨落），而过宽的箱宽则会引入高偏差（无法分辨分布的精细结构）。本练习介绍了一种基于数据驱动的原则性方法——最小二乘交叉验证（Least-Squares Cross-Validation, LSCV），以直接从数据中选择最优的 $h$。通过推导并实现 LSCV 损失函数，你将深入理解非参数密度估计的核心思想，并超越依赖主观经验或启发式规则来选择箱宽的阶段 。",
            "id": "3510284",
            "problem": "给定一个大小为 $N$ 的单变量数据集，要求使用箱宽为 $h$ 的分段常数直方图估计器进行密度估计。请将以下定义作为基本依据。\n\n- 箱宽为 $h$ 的直方图密度估计器 $\\hat{f}_h(x)$ 的定义方法是：将实数轴划分为宽度为 $h$ 的相邻区间（箱），并在每个箱内赋一个恒定的密度值，该值等于箱内的数据点数除以 $N h$。\n- 密度估计器的风险可以通过积分平方误差（ISE）来衡量，其定义为 $\\int \\left(\\hat{f}_h(x) - f(x)\\right)^2 \\, dx$，其中 $f(x)$ 是未知的真实密度函数。\n- 留一交叉验证（LOOCV）为每个数据点 $x_i$ 构建一个密度估计器，该估计器在除 $x_i$ 之外的所有数据上进行拟合，我们将其表示为 $\\hat{f}_{-i,h}(x)$，以减轻在训练点上评估估计器所带来的偏差。\n\n任务：\n1. 从上述定义出发，并且不使用任何现成的简化公式，推导出一个基于 LOOCV 的原则性最小二乘交叉验证（LSCV）准则，用于估计直方图密度估计的 ISE。您的推导必须将 LOOCV 目标函数完全用数据集 $\\{x_i\\}_{i=1}^N$、箱宽 $h$ 以及在 $h$ 下产生的箱计数来表示。您应该明确分箱方案以及如何将数据点映射到其对应的箱。\n2. 实现一个程序，对于一个给定的有限箱宽候选集，使用您推导的表达式计算每个候选 $h$ 的 LOOCV 损失，并返回使损失最小的 $h$。如果有多个 $h$ 达到相同的最小值（在数值相等的情况下），则返回其中最小的 $h$。\n3. 分箱方案规范（必须完全遵循以获得满分）：\n   - 对于给定的 $h > 0$，定义锚点 $a = \\left\\lfloor \\frac{\\min_i x_i}{h} \\right\\rfloor h$。\n   - 定义箱的边界为 $a + k h$（其中 $k$ 为整数），并对所有箱使用形式为 $[a + k h, a + (k+1) h)$ 的半开区间，最后一个箱除外，它包含数据范围的右端点。在实践中，构建足够多的连续箱以覆盖所有 $x_i$，从而确保每个点都恰好落在一个箱内。\n   - 通过 $b(i) = \\left\\lfloor \\frac{x_i - a}{h} \\right\\rfloor$ 将每个 $x_i$ 映射到其箱索引。\n4. 约束和假设：\n   - 假设 $N \\ge 2$。\n   - 您的实现必须是确定性的，并且不得依赖任何随机化。\n   - 此问题不涉及任何物理单位。\n5. 测试套件：\n   对于每个测试用例，您将得到一个数据集 $\\{x_i\\}$ 和一个箱宽候选集 $\\mathcal{H}$。对于每个测试用例，返回 $\\mathcal{H}$ 中使您的 LOOCV 损失最小的那个 $h$。\n   - 测试用例 1：\n     - 数据：$[\\,0.1,\\,0.2,\\,0.25,\\,0.9,\\,1.1,\\,1.2,\\,1.25,\\,2.0,\\,2.1,\\,2.2\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.2,\\,0.5,\\,1.0\\,]$\n   - 测试用例 2：\n     - 数据：$[\\,-1.0,\\,-0.9,\\,-0.9,\\,0.0,\\,0.1,\\,0.1,\\,0.2,\\,1.5,\\,1.6\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.25,\\,0.5,\\,1.0\\,]$\n   - 测试用例 3：\n     - 数据：$[\\,0.0,\\,0.49,\\,1.01\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.25,\\,0.5,\\,1.0\\,]$\n   - 测试用例 4：\n     - 数据：$[\\,3.0,\\,3.1,\\,3.2,\\,7.8,\\,7.9,\\,8.0,\\,8.1,\\,8.2\\,]$\n     - 候选集 $\\mathcal{H}$：$[\\,0.1,\\,0.2,\\,0.5,\\,1.0,\\,2.0\\,]$\n6. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，结果为用逗号分隔并包含在方括号中的列表。例如，输出必须类似于 $[h_1,h_2,h_3,h_4]$，其中每个 $h_j$ 是为测试用例 $j$ 选择的箱宽，表示为十进制数。\n\n您的程序必须是一个完整的、可运行的实现，它不接受任何输入，并完全按照指定格式打印一行输出。它必须仅使用标准库和指定的数值库，并精确地复现指定的分箱规则。每个测试用例的答案是一个浮点数（即所选的 $h$）。",
            "solution": "目标是为选择直方图密度估计器的箱宽 $h$ 推导出一个最小二乘交叉验证（LSCV）准则，并实现一个算法从候选集中找到最优的 $h$。\n\n推导从积分平方误差（ISE）开始，它衡量了真实密度 $f(x)$ 与直方图估计器 $\\hat{f}_h(x)$ 之间的差异。ISE 定义为：\n$$\nJ(h) = \\text{ISE} = \\int \\left( \\hat{f}_h(x) - f(x) \\right)^2 dx\n$$\n展开平方项，我们得到：\n$$\nJ(h) = \\int \\hat{f}_h(x)^2 dx - 2 \\int \\hat{f}_h(x) f(x) dx + \\int f(x)^2 dx\n$$\n交叉验证的目标是找到使 $J(h)$ 最小化的 $h$ 值。项 $\\int f(x)^2 dx$ 是一个关于 $h$ 的常数，在最小化过程中可以忽略。因此我们只需最小化风险函数 $R(h)$：\n$$\nR(h) = \\int \\hat{f}_h(x)^2 dx - 2 \\int \\hat{f}_h(x) f(x) dx\n$$\n挑战在于 $R(h)$ 仍然依赖于未知的密度函数 $f(x)$。留一交叉验证（LOOCV）方法通过用其留一估计替换期望项 $\\mathbb{E}[\\hat{f}_h(X)] = \\int \\hat{f}_h(x) f(x) dx$，从而提供了对 $R(h)$ 的一个近似无偏估计。这涉及到在每个被排除的点 $x_i$ 上对留一估计器 $\\hat{f}_{-i,h}(x)$ 的值进行平均。因此，我们表示为 $L(h)$ 的 LSCV 目标函数是：\n$$\nL(h) = \\int \\hat{f}_h(x)^2 dx - \\frac{2}{N} \\sum_{i=1}^N \\hat{f}_{-i,h}(x_i)\n$$\n我们现在使用提供的分箱方案来推导 $L(h)$ 中两项的表达式。设箱的集合为 $\\{B_k\\}$，箱 $B_k$ 中数据点的数量为 $n_k$。数据点的总数为 $N = \\sum_k n_k$。对于任何 $x \\in B_k$，直方图估计器定义为 $\\hat{f}_h(x) = \\frac{n_k}{Nh}$。每个箱的宽度为 $h$。\n\n第一项 $\\int \\hat{f}_h(x)^2 dx$ 是估计器的积分平方值。由于估计器是分段常数，我们可以将积分写成所有箱上的总和：\n$$\n\\int \\hat{f}_h(x)^2 dx = \\sum_k \\int_{B_k} \\left( \\frac{n_k}{Nh} \\right)^2 dx = \\sum_k \\left( \\frac{n_k}{Nh} \\right)^2 \\cdot (\\text{width of } B_k) = \\sum_k \\frac{n_k^2}{N^2 h^2} h = \\frac{1}{N^2 h} \\sum_k n_k^2\n$$\n\n第二项涉及留一估计器 $\\hat{f}_{-i,h}(x_i)$。该估计器是根据大小为 $N-1$ 的数据集（除 $x_i$ 之外的所有点）构建的，但使用与全样本估计器 $\\hat{f}_h(x)$ 相同的分箱网格。设 $x_i$ 是箱 $B_{k_i}$ 中的一个点。对于完整数据集，此箱中的点数为 $n_{k_i}$。对于留一估计器 $\\hat{f}_{-i,h}$，总点数为 $N-1$，而箱 $B_{k_i}$ 中的点数为 $n_{k_i}-1$。因此，估计器在 $x_i$ 处的值为：\n$$\n\\hat{f}_{-i,h}(x_i) = \\frac{\\text{count in bin } B_{k_i} \\text{ (w/o } x_i)}{\\text{(total points w/o } x_i) \\times h} = \\frac{n_{k_i} - 1}{(N-1)h}\n$$\n我们将此量对所有 $i=1, \\dots, N$ 求和：\n$$\n\\sum_{i=1}^N \\hat{f}_{-i,h}(x_i) = \\sum_{i=1}^N \\frac{n_{k_i} - 1}{(N-1)h}\n$$\n这个和可以按箱重新组合。对于每个箱 $B_k$，有 $n_k$ 个点，对于其中每个点，该项均为 $\\frac{n_k - 1}{(N-1)h}$。因此，总和变为：\n$$\n\\sum_{i=1}^N \\hat{f}_{-i,h}(x_i) = \\sum_k n_k \\left( \\frac{n_k - 1}{(N-1)h} \\right) = \\frac{1}{(N-1)h} \\sum_k (n_k^2 - n_k)\n$$\n\n现在我们将这两个推导出的表达式代回目标函数 $L(h)$：\n$$\nL(h) = \\frac{1}{N^2 h} \\sum_k n_k^2 - \\frac{2}{N} \\left( \\frac{1}{(N-1)h} \\sum_k (n_k^2 - n_k) \\right)\n$$\n提取公因式并使用 $\\sum_k n_k = N$：\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{1}{N^2} \\sum_k n_k^2 - \\frac{2}{N(N-1)} \\left( \\sum_k n_k^2 - \\sum_k n_k \\right) \\right]\n$$\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{1}{N^2} \\sum_k n_k^2 - \\frac{2}{N(N-1)} \\left( \\sum_k n_k^2 - N \\right) \\right]\n$$\n$$\nL(h) = \\frac{1}{h} \\left[ \\left(\\frac{1}{N^2} - \\frac{2}{N(N-1)}\\right) \\sum_k n_k^2 + \\frac{2N}{N(N-1)} \\right]\n$$\n合并 $\\sum_k n_k^2$ 的系数：\n$$\n\\frac{1}{N^2} - \\frac{2}{N(N-1)} = \\frac{N-1 - 2N}{N^2(N-1)} = \\frac{-(N+1)}{N^2(N-1)}\n$$\n将其代回，我们得到：\n$$\nL(h) = \\frac{1}{h} \\left[ \\frac{-(N+1)}{N^2(N-1)} \\sum_k n_k^2 + \\frac{2N}{N(N-1)} \\right]\n$$\n将第二项乘以 $N/N$ 以获得公分母，得到 LSCV 损失函数的最终表达式：\n$$\nL(h) = \\frac{2N^2 - (N+1)\\sum_k n_k^2}{N^2(N-1)h}\n$$\n该表达式仅依赖于样本大小 $N$、箱宽 $h$ 以及由 $h$ 导出的箱计数 $\\{n_k\\}$。\n\n算法流程是遍历集合 $\\mathcal{H}$ 中的每个候选箱宽 $h$。对于每个 $h$，我们执行以下步骤：\n1.  计算分箱锚点 $a = \\lfloor \\frac{\\min_i x_i}{h} \\rfloor h$。\n2.  对每个数据点 $x_i$，确定其箱索引 $b(i) = \\lfloor \\frac{x_i - a}{h} \\rfloor$。\n3.  通过计算每个唯一箱索引的出现次数来计算箱计数 $\\{n_k\\}$。\n4.  计算计数的平方和 $\\sum_k n_k^2$。\n5.  使用推导出的公式评估损失 $L(h)$。\n6.  最优的 $h$ 是导致 $L(h)$ 值最小的那个。如果出现平局，则选择最小的 $h$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LSCV problem for histogram density estimation across multiple test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([0.1, 0.2, 0.25, 0.9, 1.1, 1.2, 1.25, 2.0, 2.1, 2.2]), [0.1, 0.2, 0.5, 1.0]),\n        (np.array([-1.0, -0.9, -0.9, 0.0, 0.1, 0.1, 0.2, 1.5, 1.6]), [0.1, 0.25, 0.5, 1.0]),\n        (np.array([0.0, 0.49, 1.01]), [0.25, 0.5, 1.0]),\n        (np.array([3.0, 3.1, 3.2, 7.8, 7.9, 8.0, 8.1, 8.2]), [0.1, 0.2, 0.5, 1.0, 2.0]),\n    ]\n\n    results = []\n    for data, candidates in test_cases:\n        N = data.shape[0]\n        min_loss = float('inf')\n        best_h = -1.0\n\n        # Iterate through each candidate bin width\n        for h in candidates:\n            # 1. Calculate the binning anchor\n            min_x = np.min(data)\n            a = np.floor(min_x / h) * h\n\n            # 2. Determine bin index for each data point\n            bin_indices = np.floor((data - a) / h)\n\n            # 3. Compute bin counts\n            # np.unique returns unique elements and their counts\n            _, counts = np.unique(bin_indices, return_counts=True)\n\n            # 4. Calculate the sum of squared counts\n            sum_nk_sq = np.sum(np.power(counts, 2))\n\n            # 5. Evaluate the LSCV loss L(h) using the derived formula\n            # L(h) = (2*N^2 - (N+1)*sum(n_k^2)) / (N^2*(N-1)*h)\n            # We can ignore the constant positive denominator N^2*(N-1)\n            # when comparing losses for different h values, but we will\n            # compute the full loss for correctness.\n            # The case N=1 is not possible due to problem constraints (N>=2).\n            numerator = 2 * N**2 - (N + 1) * sum_nk_sq\n            denominator = N**2 * (N - 1) * h\n            loss = numerator / denominator\n\n            # 6. Track the h that minimizes the loss\n            # The candidate list is sorted, so the first h to achieve the\n            # minimum will be the smallest one.\n            if loss  min_loss:\n                min_loss = loss\n                best_h = h\n        \n        results.append(best_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "直方图不仅是计数的集合，更是一组统计测量值，因此为其赋予有效的统计不确定度至关重要。高能物理实验中的计数通常遵循泊松（Poisson）分布，而广泛使用的不确定度高斯近似 $\\sigma = \\sqrt{n}$ 仅在计数值 $n$ 较大时才有效。这项实践要求你通过计算置信区间的频率主义覆盖范围（frequentist coverage），来量化这一近似的适用极限。这项练习为你提供了一种严谨的方法，用以确定安全使用对称高斯误差棒所需的最低计数值阈值，这对任何需要进行统计推断的物理学家来说都是一项至关重要的知识 。",
            "id": "3510291",
            "problem": "在计算高能物理学中，直方图中的分箱事件计数被建模为来自泊松过程的抽样。令 $N \\sim \\mathrm{Poisson}(\\lambda)$ 表示在单个直方图分箱中的计数，其平均率 $\\lambda \\in [0,\\infty)$ 固定但未知。对计数统计不确定度的一种常见近似是高斯法则 $\\sigma = \\sqrt{n}$，它被对称地应用于观测计数 $n \\in \\{0,1,2,\\dots\\}$，从而在计数尺度上形成一个围绕该计数的区间。当这种对称误差棒被用作潜在平均率 $\\lambda$ 的近似置信区间时，由于 $N$ 是离散的且 $\\lambda$ 是非负的，其频率论覆盖率可能会偏离指定的名义覆盖率。\n\n定义由高斯法则在平均率尺度上导出的对称区间为\n$$\nI(n; z) = \\left[\\max\\{0,\\, n - z\\sqrt{n}\\},\\; n + z\\sqrt{n}\\right],\n$$\n其中 $z \\ge 0$ 是一个选定的标准正态分位数，用于定义名义中心覆盖率。与 $z$ 相关的名义中心覆盖率为\n$$\nC_0(z) = \\Phi(z) - \\Phi(-z),\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数。对于一个固定的 $\\lambda$，区间法则 $I(\\cdot; z)$ 的频率论覆盖率为\n$$\nC(\\lambda; z) = \\sum_{k=0}^{\\infty} \\mathbf{1}\\{\\lambda \\in I(k; z)\\} \\, \\Pr(N=k \\mid \\lambda),\n$$\n其中 $\\Pr(N=k \\mid \\lambda) = e^{-\\lambda} \\lambda^k/k!$ 且 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n你需要确定在哪个计数区间内，$\\sigma=\\sqrt{n}$ 的高斯近似所实现的覆盖误差小于指定的容差。对于给定的容差参数 $\\epsilon > 0$ 和指定的误差度量类型，将 $\\lambda$ 处的覆盖误差定义为绝对误差\n$$\nE_{\\mathrm{abs}}(\\lambda; z) = \\left|C(\\lambda; z) - C_0(z)\\right|\n$$\n或相对误差\n$$\nE_{\\mathrm{rel}}(\\lambda; z) = \\frac{\\left|C(\\lambda; z) - C_0(z)\\right|}{C_0(z)}.\n$$\n对于在 $[0,\\Lambda_{\\max}]$ 上步长均匀为 $\\Delta\\lambda$ 的给定网格 $\\{\\lambda_j\\}$，将最小阈值计数 $n_{\\min}$ 定义为满足以下条件的最小整数：对于所有网格点 $\\lambda_j \\ge n_{\\min}$，所选误差 $E(\\lambda_j; z)$ 小于或等于 $\\epsilon$。\n\n从上述基本定义出发，不使用任何预先制表的近似值，编写一个程序，该程序：\n- 对于所有满足 $\\lambda \\in I(k; z)$ 的 $k \\in \\{0,1,2,\\dots\\}$，通过对泊松概率质量函数求和来计算 $C(\\lambda; z)$，其中对无限和的截断需有数学依据，以保证截断后的剩余项可以忽略不计。\n- 从第一性原理出发计算名义中心正态覆盖率 $C_0(z)$。\n- 在一个均匀网格 $\\{\\lambda_j\\}_{j=0}^{J}$（其中 $\\lambda_0 = 0$, $\\lambda_J = \\Lambda_{\\max}$, $\\lambda_{j+1} - \\lambda_j = \\Delta\\lambda$）上评估 $E_{\\mathrm{abs}}$ 或 $E_{\\mathrm{rel}}$。\n- 找到最小整数 $n_{\\min}$，使得对于每个网格点 $\\lambda_j \\ge n_{\\min}$，误差都小于或等于 $\\epsilon$。如果在扫描范围内不存在这样的整数，则返回 -1。\n\n你的实现必须避免任何外部输入，并且必须使用以下参数值的测试套件：\n- 测试用例 1（一般情况）：$z = 1.0$，相对误差，$\\epsilon = 0.10$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例 2（更严格的容差）：$z = 1.0$，相对误差，$\\epsilon = 0.05$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例 3（更宽的区间）：$z = 2.0$，相对误差，$\\epsilon = 0.10$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n- 测试用例 4（绝对误差）：$z = 1.0$，绝对误差，$\\epsilon = 0.02$，$\\Lambda_{\\max} = 200.0$，$\\Delta\\lambda = 0.05$。\n\n你的程序应生成单行输出，其中包含四个阈值 $[n_{\\min}^{(1)}, n_{\\min}^{(2)}, n_{\\min}^{(3)}, n_{\\min}^{(4)}]$，以方括号括起来的逗号分隔列表形式表示，并按上述顺序对应四个测试用例。所有值都必须是整数。不涉及物理单位。不涉及角度。所有容差均按要求以小数形式指定。算法必须以纯粹的数学和逻辑术语表达，并且必须易于理解且可用任何现代编程语言实现；你必须以指定的单行格式准确输出结果。",
            "solution": "该问题是有效的。它提出了一个明确定义的计算任务，该任务基于实验高能物理的统计方法。所有参数和定义都清晰、一致且科学合理。\n\n### 基于原理的解决方案设计\n\n核心任务是找到最小整数计数阈值 $n_{\\min}$，当计数值高于该阈值时，一个受高斯启发的、用于泊松均值 $\\lambda$ 的对称置信区间能够达到指定的覆盖准确度水平。该算法分四个主要阶段进行：(1) 计算名义覆盖率 $C_0(z)$，(2) 在 $\\lambda$ 值的网格上计算实际的频率论覆盖率 $C(\\lambda; z)$，(3) 评估覆盖误差，以及 (4) 搜索阈值 $n_{\\min}$。\n\n#### 1. 名义覆盖率计算\n\n名义中心覆盖率 $C_0(z)$ 定义为标准正态分布在 $-z$ 和 $z$ 之间的面积。\n$$\nC_0(z) = \\Phi(z) - \\Phi(-z)\n$$\n其中 $\\Phi$ 是标准正态分布的累积分布函数 (CDF)。标准正态CDF可以用误差函数 $\\mathrm{erf}(x)$ 来表示，该函数在科学计算库中广泛可用。它们之间的关系是 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\mathrm{erf}(x/\\sqrt{2})\\right)$。将此代入 $C_0(z)$ 的定义，并利用 $\\mathrm{erf}(-x) = -\\mathrm{erf}(x)$ 的性质，我们得到一个直接的公式：\n$$\nC_0(z) = \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right) - \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{-z}{\\sqrt{2}}\\right)\\right) = \\frac{1}{2}\\left(\\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right) - \\mathrm{erf}\\left(\\frac{-z}{\\sqrt{2}}\\right)\\right) = \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\n$$\n该公式提供了一种从第一性原理出发，以数值上稳定且高效的方式计算 $C_0(z)$ 的方法。\n\n#### 2. 频率论覆盖率计算\n\n对于给定的平均率 $\\lambda$，频率论覆盖率 $C(\\lambda; z)$ 是随机区间 $I(N; z)$ 包含 $\\lambda$ 的概率。这是通过对所有观测计数 $k$ 的概率求和来计算的，其中 $k$ 对应的区间 $I(k; z)$ “覆盖”了 $\\lambda$。\n$$\nC(\\lambda; z) = \\sum_{k=0}^{\\infty} \\mathbf{1}\\{\\lambda \\in I(k; z)\\} \\, \\Pr(N=k \\mid \\lambda)\n$$\n问题陈述中提到了对无限和进行截断。然而，对于任何给定的 $\\lambda \\ge 0$，使得指示函数 $\\mathbf{1}\\{\\lambda \\in I(k; z)\\}$ 非零的整数 $k$ 的集合是有限的。我们可以确定求和的精确整数范围，从而避免任何由截断引起的近似。\n\n条件 $\\lambda \\in I(k; z)$ 等价于以下不等式系统：\n$$\n\\max\\{0, k - z\\sqrt{k}\\} \\le \\lambda \\le k + z\\sqrt{k}\n$$\n对于 $\\lambda > 0$，这可以简化为关于 $k$ 的一对不等式。通过令 $y = \\sqrt{k}$（因此 $y \\ge 0$），不等式变为关于 $y$ 的二次不等式：\n1. $y^2 - zy - \\lambda \\le 0$\n2. $y^2 + zy - \\lambda \\ge 0$\n\n解出相应二次等式的根，并分析 $y = \\sqrt{k} \\ge 0$ 的不等式，即可得到 $\\sqrt{k}$ 的解范围：\n$$\n\\frac{-z + \\sqrt{z^2 + 4\\lambda}}{2} \\le \\sqrt{k} \\le \\frac{z + \\sqrt{z^2 + 4\\lambda}}{2}\n$$\n将这些边界平方，得到 $k$ 的范围：\n$$\nk_{\\min}(\\lambda, z) \\le k \\le k_{\\max}(\\lambda, z)\n$$\n其中 $k_{\\min}(\\lambda, z) = \\left(\\frac{-z + \\sqrt{z^2 + 4\\lambda}}{2}\\right)^2$ 且 $k_{\\max}(\\lambda, z) = \\left(\\frac{z + \\sqrt{z^2 + 4\\lambda}}{2}\\right)^2$。\n因此，求和是在所有满足 $\\lceil k_{\\min}(\\lambda, z) \\rceil \\le k \\le \\lfloor k_{\\max}(\\lambda, z) \\rfloor$ 的整数 $k$ 上进行的。对于任何 $\\lambda > 0$，该范围是有限的。如果 $\\lceil k_{\\min} \\rceil > \\lfloor k_{\\max} \\rfloor$，则和为空，且 $C(\\lambda, z) = 0$。\n\n对于 $\\lambda = 0$ 的特殊情况，覆盖条件 $0 \\in I(k; z)$ 简化为 $\\max\\{0, k - z\\sqrt{k}\\} = 0$，其成立的充要条件是 $k - z\\sqrt{k} \\le 0$，即 $k \\le z^2$。对于 $\\lambda=0$，泊松和中唯一的非零项是 $\\Pr(N=0 \\mid \\lambda=0) = 1$。由于 $k=0$ 总是满足 $k \\le z^2$（因为 $z \\ge 0$），区间 $I(0;z)=[0,0]$ 覆盖了 $\\lambda=0$，因此 $C(0;z) = 1$。\n\n该算法通过在确定的整数范围 $[\\lceil k_{\\min} \\rceil, \\lfloor k_{\\max} \\rfloor]$ 上迭代，并对泊松概率 $\\Pr(N=k \\mid \\lambda) = e^{-\\lambda}\\lambda^k/k!$ 求和来计算 $C(\\lambda; z)$，这些概率是使用数值稳定的库函数计算的。\n\n#### 3. 误差评估\n\n对于网格 $\\{\\lambda_j\\}$ 上的每个点，利用 $C_0(z)$ 和 $C(\\lambda_j; z)$，按规定计算误差：\n- 绝对误差：$E_{\\mathrm{abs}}(\\lambda_j; z) = |C(\\lambda_j; z) - C_0(z)|$\n- 相对误差：$E_{\\mathrm{rel}}(\\lambda_j; z) = |C(\\lambda_j; z) - C_0(z)| / C_0(z)$\n\n这会生成一个误差值数组，网格上的每个点 $\\lambda_j$ 都对应一个误差值。\n\n#### 4. 阈值 $n_{\\min}$ 的确定\n\n最后一步是找到最小整数 $n_{\\min}$，使得对于每个网格点 $\\lambda_j \\ge n_{\\min}$，误差 $E(\\lambda_j; z)$ 不超过容差 $\\epsilon$。一种直接而高效的方法是从 $\\lambda$ 网格的末端向后搜索。\n\n1.  我们找出网格上使误差条件 $E(\\lambda_{\\text{fail}}; z) > \\epsilon$ 被违反的最大值，我们称之为 $\\lambda_{\\text{fail}}$。这可以通过反向迭代计算出的误差数组来找到。\n2.  如果不存在这样的 $\\lambda_{\\text{fail}}$（即，对于所有 $\\lambda_j$，误差都在容差范围内），则该条件对所有 $\\lambda_j \\ge 0$ 都成立，最小整数阈值为 $n_{\\min} = 0$。\n3.  如果找到了这样的 $\\lambda_{\\text{fail}}$，任何有效的整数阈值 $n_{\\min}$ 都必须严格大于 $\\lambda_{\\text{fail}}$，以确保所有后续的网格点 $\\lambda_j \\ge n_{\\min}$ 都满足误差标准。满足此条件的最小整数是 $n_{\\min} = \\lfloor \\lambda_{\\text{fail}} \\rfloor + 1$。\n4.  最后，我们检查计算出的 $n_{\\min}$ 是否在直至 $\\Lambda_{\\max}$ 的扫描范围内。如果 $n_{\\min} > \\lfloor \\Lambda_{\\max} \\rfloor$，这意味着在指定的整数范围内不存在满足条件的阈值，结果为 $-1$。否则，计算出的 $n_{\\min}$ 就是答案。\n\n这种结构化方法通过严格遵守定义来确保正确性，并采用高效的搜索算法来找到最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Solves for the minimal threshold count n_min for four test cases.\n    \"\"\"\n    test_cases = [\n        # z, error_type, epsilon, Lambda_max, delta_lambda\n        (1.0, 'relative', 0.10, 200.0, 0.05),\n        (1.0, 'relative', 0.05, 200.0, 0.05),\n        (2.0, 'relative', 0.10, 200.0, 0.05),\n        (1.0, 'absolute', 0.02, 200.0, 0.05),\n    ]\n\n    results = []\n\n    for z, error_type, epsilon, Lambda_max, delta_lambda in test_cases:\n        # Step 1: Compute nominal coverage C_0(z)\n        # C_0(z) = Phi(z) - Phi(-z) = erf(z / sqrt(2))\n        c0 = erf(z / np.sqrt(2))\n\n        # Step 2: Set up the lambda grid and calculate coverage errors\n        num_points = int(round(Lambda_max / delta_lambda)) + 1\n        lambdas = np.linspace(0.0, Lambda_max, num_points)\n        errors = np.zeros_like(lambdas)\n\n        for i, lambda_val in enumerate(lambdas):\n            # Step 2a: Compute frequentist coverage C(lambda, z)\n            if lambda_val == 0.0:\n                # For lambda=0, P(N=0)=1. The interval I(0;z)=[0,0] covers lambda=0.\n                # For k>0, P(N=k)=0. So C(0,z) = 1.\n                c_lambda_z = 1.0\n            else:\n                # For lambda > 0, find the finite range of k for the sum.\n                # The condition is k - z*sqrt(k) = lambda = k + z*sqrt(k).\n                # This defines a range [k_min, k_max].\n                sqrt_term = np.sqrt(z**2 + 4 * lambda_val)\n                k_min_val = ((-z + sqrt_term) / 2)**2\n                k_max_val = ((z + sqrt_term) / 2)**2\n                \n                k_start = int(np.ceil(k_min_val))\n                k_end = int(np.floor(k_max_val))\n\n                if k_start > k_end:\n                    c_lambda_z = 0.0\n                else:\n                    k_range = np.arange(k_start, k_end + 1)\n                    # Sum Poisson probabilities over the determined range of k\n                    pmf_values = poisson.pmf(k_range, mu=lambda_val)\n                    c_lambda_z = np.sum(pmf_values)\n\n            # Step 2b: Compute the error E(lambda, z)\n            if error_type == 'absolute':\n                error = np.abs(c_lambda_z - c0)\n            else:  # 'relative'\n                # Avoid division by zero if c0 is zero, though not possible for z>0\n                error = np.abs(c_lambda_z - c0) / c0 if c0 != 0 else 0.0\n            \n            errors[i] = error\n\n        # Step 3: Find the minimal threshold count n_min\n        # Find the index of the last lambda value where the error exceeds the tolerance.\n        last_bad_idx = -1\n        # Search backwards from the end of the grid.\n        for i in range(len(lambdas) - 1, -1, -1):\n            if errors[i] > epsilon:\n                last_bad_idx = i\n                break\n        \n        if last_bad_idx == -1:\n            # If no lambda value has an error > epsilon, the condition holds for all lambda >= 0.\n            n_min = 0\n        else:\n            # The condition is violated up to lambda_fail = lambdas[last_bad_idx].\n            # n_min must be an integer > lambda_fail.\n            lambda_fail = lambdas[last_bad_idx]\n            n_min = int(np.floor(lambda_fail)) + 1\n        \n        # If the required n_min is outside the scanned range, no solution exists.\n        if n_min > int(Lambda_max):\n            results.append(-1)\n        else:\n            results.append(n_min)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}