{
    "hands_on_practices": [
        {
            "introduction": "Cabibbo-Kobayashi-Maskawa (CKM) 矩阵，$V$，是标准模型中夸克味物理的基石。本练习将让你亲手实践如何根据粒子数据组 (PDG) 给出的标准参数化来构建该矩阵。通过实现一个数值诊断程序，你还将探索其至关重要的幺正性，并体会到在浮点数运算中维持这一性质的实际挑战。",
            "id": "3507884",
            "problem": "在粒子物理标准模型的味物理和电荷-宇称 (CP) 破坏的背景下，您需要为 Cabibbo–Kobayashi–Maskawa (CKM) 矩阵实现一个数值诊断程序。Cabibbo–Kobayashi–Maskawa (CKM) 矩阵是一个幺正矩阵，它将下型夸克的弱相互作用本征态旋转到质量本征基，并且它可以通过三个混合角和一个 CP 破坏相位来进行参数化。目标是使用标准的粒子数据组 (PDG) 参数化从给定参数构建 CKM 矩阵，然后通过计算幺正性求和中最大违背项的大小来检验数值幺正性。\n\n基础：\n- 带电流弱相互作用通过一个三维幺正矩阵——Cabibbo–Kobayashi–Maskawa (CKM) 矩阵——耦合夸克味二重态。\n- 一个幺正矩阵 $U$ 满足 $U^{\\dagger} U = I$ 和 $U U^{\\dagger} = I$，其中 $I$ 是相同维度的单位矩阵，而 $U^{\\dagger}$ 是共轭转置。\n- 标准的粒子数据组 (PDG) 参数化将 CKM 矩阵 $V$ 表示为乘积 $V = R_{23}(\\theta_{23}) R_{13}(\\theta_{13}, \\delta) R_{12}(\\theta_{12})$，其中 $R_{12}$ 和 $R_{23}$ 是相应二维子空间中的实旋转，而 $R_{13}$ 是一个复旋转，它将 CP 破坏相位 $\\delta$ 作为一个模为1的相位因子嵌入到 $(1,3)$ 和 $(3,1)$ 矩阵元中。记 $c_{ij} \\equiv \\cos \\theta_{ij}$ 和 $s_{ij} \\equiv \\sin \\theta_{ij}$，$R_{12}$、$R_{23}$ 和 $R_{13}$ 的定义如下：\n$$\nR_{12}(\\theta_{12}) =\n\\begin{pmatrix}\nc_{12} & s_{12} & 0 \\\\\n-s_{12} & c_{12} & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix},\\quad\nR_{23}(\\theta_{23}) =\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & c_{23} & s_{23} \\\\\n0 & -s_{23} & c_{23}\n\\end{pmatrix},\n$$\n$$\nR_{13}(\\theta_{13}, \\delta) =\n\\begin{pmatrix}\nc_{13} & 0 & s_{13} e^{-i \\delta} \\\\\n0 & 1 & 0 \\\\\n- s_{13} e^{i \\delta} & 0 & c_{13}\n\\end{pmatrix}.\n$$\n这些是 $3 \\times 3$ 的幺正矩阵；在精确计算中，它们的乘积也是幺正的。\n\n您的任务是：\n1. 在浮点运算中，使用上述 PDG 参数化，根据输入 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$ 实现 $V$ 的构建。所有角度必须以弧度为单位进行解释。\n2. 为任意复 $3 \\times 3$ 矩阵 $V$ 定义一个幺正性破坏诊断量\n$$\nD(V) \\equiv \\max\\big\\{\\ \\max_{i,j} \\left| \\left(V^{\\dagger} V - I\\right)_{ij} \\right|,\\ \\max_{i,j} \\left| \\left(V V^{\\dagger} - I\\right)_{ij} \\right| \\ \\big\\}.\n$$\n该诊断量是一个非负实数，对于完全幺正的矩阵其值恰好为零，而在发生舍入误差的浮点运算中其值为正。\n3. 对于下面测试套件中的每个参数集，构建 $V$ 并计算 $D(V)$ 作为一个浮点数。\n\n角度单位要求：\n- 所有角度 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$ 均以弧度为单位指定。\n\n测试套件：\n- 情况1（典型的小混合，非平凡的 CP 相位）：$\\theta_{12} = \\arcsin(0.2243)$, $\\theta_{23} = \\arcsin(0.0422)$, $\\theta_{13} = \\arcsin(0.00394)$, $\\delta = \\pi/3$。\n- 情况2（相同的混合，CP 守恒）：$\\theta_{12} = \\arcsin(0.2243)$, $\\theta_{23} = \\arcsin(0.0422)$, $\\theta_{13} = \\arcsin(0.00394)$, $\\delta = 0$。\n- 情况3（无混合角，任意相位）：$\\theta_{12} = 0$, $\\theta_{23} = 0$, $\\theta_{13} = 0$, $\\delta = 2.0$。\n- 情况4（强的 $(1,3)$ 混合边缘情况，带相位）：$\\theta_{12} = 0.7$, $\\theta_{23} = 1.1$, $\\theta_{13} = \\pi/2$, $\\delta = \\pi$。\n- 情况5（微小角度，通用相位）：$\\theta_{12} = 10^{-8}$, $\\theta_{23} = 10^{-8}$, $\\theta_{13} = 10^{-8}$, $\\delta = \\pi/7$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表。\n- 每个条目必须是对应测试用例的 $D(V)$ 值，经过四舍五入并格式化为小数点后恰好有 12 位数字的科学记数法。\n- 例如，一个包含两个结果的输出应如下所示：`[1.234000000000e-12,5.670000000000e-16]`。\n\n除了上面指定的角度单位外，最终答案中没有其他物理单位。",
            "solution": "该问题要求实现一个数值诊断程序，用于测试使用标准粒子数据组 (PDG) 参数化构建的 Cabibbo-Kobayashi-Maskawa (CKM) 矩阵 $V$ 的幺正性。解决方案包括从一组给定的参数构建矩阵，然后计算一个度量，该度量用于量化由浮点运算引起的与完全幺正性的偏差。\n\n基本原理是 CKM 矩阵必须是幺正的，即 $V^{\\dagger}V = VV^{\\dagger} = I$，其中 $I$ 是 $3 \\times 3$ 的单位矩阵，$V^{\\dagger}$ 是 $V$ 的共轭转置。在精确计算中，幺正矩阵的乘积也是幺正的。在数值计算中，任何与此等式的偏差都源于浮点舍入误差。我们的目标是量化这种偏差。\n\n该解决方案是逐步实现的。\n\n**步骤1：构建旋转矩阵**\n\nCKM 矩阵 $V$ 由三个混合角 $\\theta_{12}$、$\\theta_{23}$、$\\theta_{13}$ 和一个 CP 破坏相位 $\\delta$ 参数化。其构建由三个旋转矩阵的乘积给出：$V = R_{23}(\\theta_{23}) \\cdot R_{13}(\\theta_{13}, \\delta) \\cdot R_{12}(\\theta_{12})$。我们首先实现这些 $3 \\times 3$ 矩阵中每一个的构建。为清晰起见，令 $c_{ij} = \\cos \\theta_{ij}$ 和 $s_{ij} = \\sin \\theta_{ij}$。\n\n旋转矩阵 $R_{12}(\\theta_{12})$ 定义如下：\n$$\nR_{12}(\\theta_{12}) =\n\\begin{pmatrix}\nc_{12} & s_{12} & 0 \\\\\n-s_{12} & c_{12} & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\n这是一个表示在 $(1,2)$ 平面中旋转的实值矩阵。\n\n旋转矩阵 $R_{23}(\\theta_{23})$ 定义如下：\n$$\nR_{23}(\\theta_{23}) =\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & c_{23} & s_{23} \\\\\n0 & -s_{23} & c_{23}\n\\end{pmatrix}\n$$\n这是一个表示在 $(2,3)$ 平面中旋转的实值矩阵。\n\n包含 CP 破坏相位 $\\delta$ 的旋转矩阵 $R_{13}(\\theta_{13}, \\delta)$ 定义如下：\n$$\nR_{13}(\\theta_{13}, \\delta) =\n\\begin{pmatrix}\nc_{13} & 0 & s_{13} e^{-i \\delta} \\\\\n0 & 1 & 0 \\\\\n- s_{13} e^{i \\delta} & 0 & c_{13}\n\\end{pmatrix}\n$$\n由于复指数项 $e^{\\pm i \\delta} = \\cos\\delta \\pm i \\sin\\delta$，该矩阵是复值的。因此，所有后续的矩阵运算都必须使用复数运算来执行。在我们的实现中，我们将对所有矩阵使用复浮点数据类型（例如 `np.complex128`）以确保兼容性和精度。\n\n**步骤2：组装 CKM 矩阵**\n\n在定义了各个旋转矩阵之后，CKM 矩阵 $V$ 通过按指定顺序执行矩阵乘法来计算：\n$$\nV = R_{23}(\\theta_{23}) \\cdot R_{13}(\\theta_{13}, \\delta) \\cdot R_{12}(\\theta_{12})\n$$\n乘法的顺序至关重要，必须严格遵守。像 NumPy 这样的数值库可以使用 `numpy.matmul` 或 `@` 运算符高效地处理此操作。\n\n**步骤3：幺正性破坏诊断**\n\n任务的核心是计算诊断量 $D(V)$，它衡量了与幺正性的偏差。其定义如下：\n$$\nD(V) \\equiv \\max\\big\\{\\ \\max_{i,j} \\left| \\left(V^{\\dagger} V - I\\right)_{ij} \\right|,\\ \\max_{i,j} \\left| \\left(V V^{\\dagger} - I\\right)_{ij} \\right| \\ \\big\\}\n$$\n计算过程如下：\n1. 计算 $V$ 的共轭转置，记为 $V^{\\dagger}$。\n2. 计算幺正性条件的两个残差矩阵：$M_1 = V^{\\dagger}V - I$ 和 $M_2 = VV^{\\dagger} - I$。在理想情况下，$M_1$ 和 $M_2$ 都将是零矩阵。\n3. 计算 $M_1$ 中所有元素的最大绝对值。即 $\\max_{i,j} |(M_1)_{ij}|$。因为 $M_1$ 的元素是复数，所以需要取绝对值。\n4. 类似地，计算 $M_2$ 中所有元素的最大绝对值：$\\max_{i,j} |(M_2)_{ij}|$。\n5. 诊断量 $D(V)$ 是这两个最大值中较大的一个。这个单一的非负实数表示了在所有矩阵元中，对幺正性条件的最大违背量级。\n\n**步骤4：算法实现与输出格式化**\n\n整体算法将这些步骤封装在一个循环中，该循环遍历所提供的测试用例。\n1. 定义一个参数集列表 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$，对应于五个测试用例。以 `arcsin(x)` 形式给出的角度值通过数值计算得出。\n2. 对于每个参数集，调用一个函数来执行步骤1-3，返回 $D(V)$ 的值。\n3. 计算出的 $D(V)$ 值存储在一个列表中。\n4. 最后，将结果列表格式化为单个字符串。每个数值都转换为小数点后恰好有 12 位精度的科学记数法字符串（例如 `1.234000000000e-16`）。这些字符串用逗号连接，并用方括号 `[...]` 括起来，然后作为最终输出打印。在此类科学计算中，使用双精度浮点数（$64$ 位）是标准做法，以最小化舍入误差，而 $D(V)$ 正是为此设计的度量。\n\n此过程为构建 CKM 矩阵和评估其数值幺正性提供了一个稳健且可验证的方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the CKM unitarity diagnostic for a suite of test cases.\n    \"\"\"\n\n    def calculate_ckm_diagnostic(theta_12, theta_23, theta_13, delta):\n        \"\"\"\n        Constructs the CKM matrix and computes its unitarity violation diagnostic.\n\n        Args:\n            theta_12 (float): Mixing angle in the 1-2 plane (radians).\n            theta_23 (float): Mixing angle in the 2-3 plane (radians).\n            theta_13 (float): Mixing angle in the 1-3 plane (radians).\n            delta (float): CP-violating phase (radians).\n\n        Returns:\n            float: The unitarity diagnostic D(V).\n        \"\"\"\n        # Calculate cosines and sines of the mixing angles\n        c12, s12 = np.cos(theta_12), np.sin(theta_12)\n        c23, s23 = np.cos(theta_23), np.sin(theta_23)\n        c13, s13 = np.cos(theta_13), np.sin(theta_13)\n\n        # Define the rotation matrix R_12\n        # All matrices are initialized as complex to handle complex arithmetic\n        R12 = np.array([\n            [c12,  s12, 0],\n            [-s12, c12, 0],\n            [0,    0,   1]\n        ], dtype=np.complex128)\n\n        # Define the rotation matrix R_23\n        R23 = np.array([\n            [1, 0,    0   ],\n            [0, c23,  s23 ],\n            [0, -s23, c23 ]\n        ], dtype=np.complex128)\n\n        # Define the complex rotation matrix R_13\n        R13 = np.array([\n            [c13, 0, s13 * np.exp(-1j * delta)],\n            [0,   1, 0                       ],\n            [-s13 * np.exp(1j * delta), 0, c13]\n        ], dtype=np.complex128)\n\n        # Construct the CKM matrix V = R_23 @ R_13 @ R_12\n        V = R23 @ R13 @ R12\n\n        # Define the 3x3 identity matrix\n        I = np.identity(3, dtype=np.complex128)\n        # Compute the conjugate transpose of V\n        V_dagger = V.conj().T\n\n        # Compute the residual matrices for the unitarity check\n        res_V_dagger_V = V_dagger @ V - I\n        res_V_V_dagger = V @ V_dagger - I\n\n        # Compute the maximum absolute element value for each residual matrix\n        d1 = np.abs(res_V_dagger_V).max()\n        d2 = np.abs(res_V_V_dagger).max()\n\n        # The diagnostic is the maximum of the two values\n        return max(d1, d2)\n\n    # Define the test cases from the problem statement.\n    # Parameters: (theta_12, theta_23, theta_13, delta) in radians.\n    test_cases = [\n        # Case 1: typical small mixings, nontrivial CP phase\n        (np.arcsin(0.2243), np.arcsin(0.0422), np.arcsin(0.00394), np.pi / 3),\n        # Case 2: same mixings, CP-conserving\n        (np.arcsin(0.2243), np.arcsin(0.0422), np.arcsin(0.00394), 0.0),\n        # Case 3: no mixing angles, arbitrary phase\n        (0.0, 0.0, 0.0, 2.0),\n        # Case 4: strong (1,3) mixing edge with phase\n        (0.7, 1.1, np.pi / 2, np.pi),\n        # Case 5: tiny angles, generic phase\n        (1e-8, 1e-8, 1e-8, np.pi / 7)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the diagnostic D(V) for the current case\n        result = calculate_ckm_diagnostic(*case)\n        results.append(result)\n\n    # Format results to scientific notation with 12 decimal places\n    formatted_results = [f\"{res:.12e}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "CKM 矩阵中复数相位的存在，是标准模型对夸克部分观察到的电荷共轭-宇称 (CP) 破坏现象的解释。本练习通过一个清晰简洁的玩具模型，阐明了直接 CP 破坏的核心机制。通过操纵两种衰变振幅之间的干涉，你将亲身发现产生不对称性所必需的两个条件：弱相位差和强相位差的存在。",
            "id": "3507893",
            "problem": "实现一个程序，在一个介子衰变的树图-企鹅图干涉的玩具模型中，测试振幅级别的电荷-宇称（CP）变换，并计算直接的CP不对称性。其科学基础是包含Cabibbo–Kobayashi–Maskawa（CKM）矩阵的标准模型，该矩阵在衰变振幅中提供了复数弱相位，以及量子力学的振幅叠加原理。将到末态 $f$ 的衰变振幅定义为一个树图贡献和一个企鹅图贡献的相干叠加，每个贡献都由一个实数大小、一个强相位和一个弱相位来表征。在CP变换下，弱相位反号，而强相位因其源于量子色动力学（QCD）而保持不变。直接CP不对称性定义为一个过程与其CP共轭过程的衰变概率的归一化差异。\n\n从以下基本事实出发：\n- 衰变概率与量子力学振幅的模平方成正比。\n- 在CP变换下，来自Cabibbo–Kobayashi–Maskawa（CKM）矩阵的弱相位变号，而强相位不变。\n\n为一个双拓扑模型构建以下对象：\n- 到末态 $f$ 的衰变振幅 $A_f$，由下式构成\n  $$A_f = T\\,e^{i(\\delta_T + \\phi_T)} + P\\,e^{i(\\delta_P + \\phi_P)},$$\n  其中 $T$ 和 $P$ 是实数非负大小，$\\delta_T$ 和 $\\delta_P$ 是实数强相位，$\\phi_T$ 和 $\\phi_P$ 是实数弱相位。\n- 其CP共轭振幅 $\\bar A_{\\bar f}$，通过反转弱相位并保持强相位不变得到：\n  $$\\bar A_{\\bar f} = T\\,e^{i(\\delta_T - \\phi_T)} + P\\,e^{i(\\delta_P - \\phi_P)}.$$\n\n你的程序必须：\n1. 实现一个函数，在给定所有相位参数以弧度为单位的 $(T,P,\\delta_T,\\delta_P,\\phi_T,\\phi_P)$ 的情况下，计算 $A_f$ 和 $\\bar A_{\\bar f}$。\n2. 实现一个振幅级别的CP变换验证，明确检查树图和企鹅图贡献是否按 $T\\,e^{i(\\delta_T + \\phi_T)} \\to T\\,e^{i(\\delta_T - \\phi_T)}$ 和 $P\\,e^{i(\\delta_P + \\phi_P)} \\to P\\,e^{i(\\delta_P - \\phi_P)}$ 变换，并且总振幅在小的数值容差内遵循 $A_f \\to \\bar A_{\\bar f}$。每个测试用例的验证输出必须是一个布尔值。\n3. 计算直接CP不对称性，定义为\n  $$A_{CP} = \\frac{|A_f|^2 - |\\bar A_{\\bar f}|^2}{|A_f|^2 + |\\bar A_{\\bar f}|^2},$$\n  对每个测试用例，结果为一个浮点数。\n4. 所有相位参数均使用弧度作为角度单位。\n5. 对于每个测试用例，将布尔值的CP变换检查和浮点数 $A_{CP}$ 汇总到一个列表中，顺序为 $[\\text{check}_1, A_{CP,1}, \\text{check}_2, A_{CP,2}, \\dots]$。\n6. 精确打印一行，其中包含最终的汇总列表，格式为 $[x_1,x_2,\\dots,x_{2N}]$。\n\n测试套件：\n提供以下测试用例，每个用例为一个元组 $(T,P,\\delta_T,\\delta_P,\\phi_T,\\phi_P)$，角度以弧度为单位：\n- 情况1（一般干涉）：$(0.3, 1.0, 0.1, 0.5, 1.2, 0.0)$。\n- 情况2（无企鹅图边界）：$(1.0, 0.0, 0.7, 0.0, 0.9, 0.0)$。\n- 情况3（强相位差为零）：$(0.6, 0.6, 0.2, 0.2, 1.0, 0.1)$。\n- 情况4（近最大干涉）：$(1.0, 1.0, 0.0, \\pi/2, \\pi/3, 0.0)$。\n- 情况5（层级结构且强相位较大）：$(0.05, 1.0, 0.4, 2.5, 1.2, 0.2)$。\n\n覆盖性设计：\n- 情况1用于检验具有非平凡强相位和弱相位的一般树图-企鹅图干涉。\n- 情况2确保在缺少一种拓扑时不对称性消失。\n- 情况3检查在尽管存在弱相位但强相位差为零时，直接CP不对称性消失的情况。\n- 情况4探测在强相位正交且弱相位差较大时的近最大直接CP不对称性。\n- 情况5检查在树图振幅较小且企鹅图强相位较大情况下的数值稳定性和CP变换。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。角度必须解释为弧度。除弧度外，不涉及其他物理单位。所有浮点数必须以标准十进制表示法打印。",
            "solution": "本解答旨在阐明直接CP破坏的产生机制。当一个粒子与其反粒子衰变到对应末态的速率不同时，就发生了直接CP破坏。在标准模型中，这源于至少两个具有不同强相位和弱相位的衰变路径的干涉。\n\n一个过程 $M \\to f$ 的衰变振幅 $A_f$ 由一个树水平振幅和一个企鹅水平振幅的和给出。每个贡献都是一个复数，由一个实数大小、一个来自量子色动力学（QCD）的强相位 $\\delta$ 和一个来自CKM矩阵的弱相位 $\\phi$ 来表征。总振幅为：\n$$A_f = T\\,e^{i(\\delta_T + \\phi_T)} + P\\,e^{i(\\delta_P + \\phi_P)}$$\n这里，$T$ 和 $P$ 分别是树图振幅和企鹅图振幅的实数非负大小。项 $\\delta_T$ 和 $\\delta_P$ 是强相位，$\\phi_T$ 和 $\\phi_P$ 是弱相位。所有相位都以弧度为单位。\n\nCP变换的一个基本性质是它不改变强相互作用动力学，但作用于弱相互作用耦合常数。因此，在CP变换下，强相位保持不变（$\\delta \\to \\delta$），而弱相位变号（$\\phi \\to -\\phi$）。将此变换应用于 $A_f$ 可得到过程 $\\bar{M} \\to \\bar{f}$ 的CP共轭振幅 $\\bar{A}_{\\bar{f}}$：\n$$\\bar{A}_{\\bar{f}} = T\\,e^{i(\\delta_T - \\phi_T)} + P\\,e^{i(\\delta_P - \\phi_P)}$$\n\n衰变率（或概率）与衰变振幅的模平方成正比。我们来计算 $|A_f|^2$ 和 $|\\bar{A}_{\\bar{f}}|^2$。一个振幅 $A = M_1 e^{i\\alpha_1} + M_2 e^{i\\alpha_2}$ 的模平方为 $|A|^2 = A A^* = M_1^2 + M_2^2 + 2 M_1 M_2 \\cos(\\alpha_1 - \\alpha_2)$。\n将其应用于 $A_f$：\n$$|A_f|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T + \\phi_T) - (\\delta_P + \\phi_P)\\right)$$\n$$|A_f|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\delta_P) + (\\phi_T - \\phi_P)\\right)$$\n对 $\\bar{A}_{\\bar{f}}$ 也类似：\n$$|\\bar{A}_{\\bar{f}}|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\phi_T) - (\\delta_P - \\phi_P)\\right)$$\n$$|\\bar{A}_{\\bar{f}}|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\delta_P) - (\\phi_T - \\phi_P)\\right)$$\n\n直接CP不对称性 $A_{CP}$ 定义为这两个衰变率之间的归一化差异：\n$$A_{CP} = \\frac{|A_f|^2 - |\\bar{A}_{\\bar{f}}|^2}{|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2}$$\n我们来分析分子，使用三角恒等式 $\\cos(a+b) - \\cos(a-b) = -2\\sin(a)\\sin(b)$，其中 $a = \\delta_T - \\delta_P$ 且 $b = \\phi_T - \\phi_P$：\n$$|A_f|^2 - |\\bar{A}_{\\bar{f}}|^2 = 2TP \\left[ \\cos(a+b) - \\cos(a-b) \\right] = -4TP \\sin(\\delta_T - \\delta_P) \\sin(\\phi_T - \\phi_P)$$\n这个结果意义深远：要发生直接CP破坏（$A_{CP} \\neq 0$），必须同时满足两个条件（假设 $T, P > 0$）：\n1. 必须存在非零的强相位差：$\\sin(\\delta_T - \\delta_P) \\neq 0$，这意味着对于任意整数 $n$，$\\delta_T - \\delta_P \\neq n\\pi$。\n2. 必须存在非零的弱相位差：$\\sin(\\phi_T - \\phi_P) \\neq 0$，这意味着对于任意整数 $k$，$\\phi_T - \\phi_P \\neq k\\pi$。\n\n分母是：\n$$|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2 = 2(T^2 + P^2) + 2TP \\left( \\cos(a+b) + \\cos(a-b) \\right)$$\n使用恒等式 $\\cos(a+b) + \\cos(a-b) = 2\\cos(a)\\cos(b)$：\n$$|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2 = 2(T^2 + P^2) + 4TP \\cos(\\delta_T - \\delta_P) \\cos(\\phi_T - \\phi_P)$$\n因此，CP不对称性的完整表达式为：\n$$A_{CP} = \\frac{-2TP \\sin(\\delta_T - \\delta_P) \\sin(\\phi_T - \\phi_P)}{T^2 + P^2 + 2TP \\cos(\\delta_T - \\delta_P) \\cos(\\phi_T - \\phi_P)}$$\n\n对于每组参数 $(T, P, \\delta_T, \\delta_P, \\phi_T, \\phi_P)$，计算任务包括两个部分：\n1. **CP变换验证**：问题要求明确检查CP变换规则是否被正确应用。这不仅仅是同义反复的检查，而是对振幅结构的验证。对于树图振幅 $A_T = T e^{i(\\delta_T + \\phi_T)}$，我们可以将其分为强相互作用部分 $S_T = T e^{i\\delta_T}$ 和弱相互作用部分 $W_T = e^{i\\phi_T}$，使得 $A_T = S_T W_T$。CP变换后的振幅为 $A'_T = S_T W_T^*$，其中 $W_T^*$ 是 $W_T$ 的复共轭。验证将包括确认以这种方式构建的 $A'_T$ 在数值上等于定义为 $\\bar{A}_T = T e^{i(\\delta_T - \\phi_T)}$ 的振幅。此检查对树图和企鹅图贡献以及它们的和都执行。\n2. **CP不对称性计算**：这涉及使用复数算术计算 $|A_f|^2$ 和 $|\\bar{A}_{\\bar{f}}|^2$，然后将这些值代入 $A_{CP}$ 的定义中。将使用一个小的数值容差（例如，$10^{-12}$）进行浮点数比较。如果分母 $|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2$ 为零（这只在 $T=0$ 和 $P=0$ 时发生），则不对称性是未定义的（$0/0$），应视为 $0$，因为没有衰变意味着没有不对称性。\n\n该算法通过遍历所提供的5个测试用例来进行。对于每个用例，它将计算两个所需的量——布尔验证结果和浮点不对称性 $A_{CP}$——并将它们汇总到一个有序列表中作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes direct CP asymmetries and verifies CP transformation for a set of\n    toy model decay parameters.\n    \"\"\"\n\n    # Test suite with each case as a tuple (T, P, delta_T, delta_P, phi_T, phi_P)\n    # in radians for all phase parameters.\n    test_cases = [\n        # Case 1 (general interference)\n        (0.3, 1.0, 0.1, 0.5, 1.2, 0.0),\n        # Case 2 (no penguin boundary)\n        (1.0, 0.0, 0.7, 0.0, 0.9, 0.0),\n        # Case 3 (zero strong-phase difference)\n        (0.6, 0.6, 0.2, 0.2, 1.0, 0.1),\n        # Case 4 (near-maximal interference)\n        (1.0, 1.0, 0.0, np.pi/2, np.pi/3, 0.0),\n        # Case 5 (hierarchical with large strong phase)\n        (0.05, 1.0, 0.4, 2.5, 1.2, 0.2),\n    ]\n\n    results = []\n    for params in test_cases:\n        check, A_CP = process_case(params)\n        results.append(check)\n        results.append(A_CP)\n\n    # Final print statement in the exact required format.\n    # The str() conversion for booleans produces 'True' or 'False'.\n    # The str() conversion for floats may use scientific notation for very small\n    # or large numbers, but for values of Acp between -1 and 1, this is unlikely.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(params):\n    \"\"\"\n    Calculates the CP transform verification and asymmetry for a single case.\n\n    Args:\n        params (tuple): A tuple containing (T, P, delta_T, delta_P, phi_T, phi_P).\n\n    Returns:\n        tuple: A tuple containing (boolean_check, A_CP_float).\n    \"\"\"\n    T, P, delta_T, delta_P, phi_T, phi_P = params\n    \n    # Numerical tolerance for floating point comparisons\n    TOL = 1e-12\n\n    # 1. Implement functions to compute A_f and A_bar_f_bar\n    # Using Euler's formula e^(i*x) = cos(x) + i*sin(x), represented by np.exp(1j*x)\n    \n    # Amplitudes for the original process\n    tree_amp = T * np.exp(1j * (delta_T + phi_T))\n    penguin_amp = P * np.exp(1j * (delta_P + phi_P))\n    A_f = tree_amp + penguin_amp\n\n    # Amplitudes for the CP-conjugate process\n    cp_tree_amp = T * np.exp(1j * (delta_T - phi_T))\n    cp_penguin_amp = P * np.exp(1j * (delta_P - phi_P))\n    A_bar_f_bar = cp_tree_amp + cp_penguin_amp\n    \n    # 2. Implement amplitude-level CP transformation verification\n    # This check validates that the CP-transformed components, constructed by\n    # conjugating the weak phase factor, match the directly computed CP-conjugate amplitudes.\n    \n    # Construct strong and weak phase factors\n    strong_part_T = T * np.exp(1j * delta_T)\n    weak_part_T = np.exp(1j * phi_T)\n    \n    strong_part_P = P * np.exp(1j * delta_P)\n    weak_part_P = np.exp(1j * phi_P)\n\n    # Apply CP transformation by conjugating the weak phase factor\n    verified_cp_tree = strong_part_T * np.conj(weak_part_T)\n    verified_cp_penguin = strong_part_P * np.conj(weak_part_P)\n    verified_A_bar = verified_cp_tree + verified_cp_penguin\n\n    # Perform a numerical comparison with a tolerance\n    check_tree = np.isclose(verified_cp_tree, cp_tree_amp, atol=TOL, rtol=TOL)\n    check_penguin = np.isclose(verified_cp_penguin, cp_penguin_amp, atol=TOL, rtol=TOL)\n    check_full = np.isclose(verified_A_bar, A_bar_f_bar, atol=TOL, rtol=TOL)\n    \n    # The final boolean check aggregates the component-wise checks\n    cp_check_result = bool(check_tree and check_penguin and check_full)\n\n    # 3. Compute the direct CP asymmetry A_CP\n    # Probability (rate) is proportional to the squared modulus of the amplitude.\n    prob_f = np.abs(A_f)**2\n    prob_f_bar = np.abs(A_bar_f_bar)**2\n    \n    denominator = prob_f + prob_f_bar\n    \n    if np.isclose(denominator, 0.0, atol=TOL):\n        # If there is no decay, there can be no asymmetry.\n        A_CP = 0.0\n    else:\n        numerator = prob_f - prob_f_bar\n        A_CP = numerator / denominator\n        \n    return cp_check_result, A_CP\n\nsolve()\n```"
        },
        {
            "introduction": "CKM 矩阵的参数并非直接测量得出，而是通过全局统计分析，结合大量不同类型的实验测量值来确定的。本练习将让你扮演唯象学家的角色，执行一个简化的全局拟合来约束幺正三角的顶点 $(\\bar{\\rho}, \\bar{\\eta})$。通过“留一法”交叉检验，你将学习一种评估 CKM 模型内部自洽性并识别最具影响力测量的强大技术。",
            "id": "3507825",
            "problem": "您的任务是在标准模型对夸克味混合和电荷-宇称（CP）破坏的描述框架内，实现一个计算性的留一法交叉检验。带电流相互作用由 Cabibbo-Kobayashi-Maskawa (CKM) 矩阵（我们记为 $V$）介导。该矩阵 $V$ 是幺正的，并允许使用由参数 $\\lambda$、 $A$、 $\\bar{\\rho}$ 和 $\\bar{\\eta}$ 表征的 Wolfenstein 参数化。由关系式 $V_{ud} V_{ub}^* + V_{cd} V_{cb}^* + V_{td} V_{tb}^* = 0$ 在复平面中定义的幺正三角形（UT）的顶点是 $(\\bar{\\rho}, \\bar{\\eta})$。该顶点受到已精确测量的可观测量约束，在 Wolfenstein 展开的领头阶以及在全局拟合中使用的标准归一化下，这些可观测量可以与 $(\\bar{\\rho}, \\bar{\\eta})$ 关联如下：\n- $R_u = \\sqrt{\\bar{\\rho}^2 + \\bar{\\eta}^2}$，\n- $R_t = \\sqrt{(1 - \\bar{\\rho})^2 + \\bar{\\eta}^2}$，\n- $\\sin(2\\beta)$，其中角度 $\\beta$ 由 $\\beta = \\arctan\\left(\\frac{\\bar{\\eta}}{1 - \\bar{\\rho}}\\right)$ 给出,\n- $\\gamma = \\arctan\\left(\\frac{\\bar{\\eta}}{\\bar{\\rho}}\\right)$（角度必须以弧度处理），\n- $\\epsilon_K^\\text{model} = K_\\epsilon \\, \\bar{\\eta} \\, (1 - \\bar{\\rho})$，其中 $K_\\epsilon$ 是一个由数据集提供的归一化常数，吸收了短程和强子因子，从而使 $\\epsilon_K^\\text{model}$ 成为无量纲量。\n\n您的程序必须执行以下任务：\n1. 对于每个数据集，为一组给定的包含约束构建最小二乘目标（卡方）：\n$$\n\\chi^2(\\bar{\\rho}, \\bar{\\eta}) = \\sum_{j \\in \\mathcal{I}} \\left( \\frac{O_j^\\text{model}(\\bar{\\rho}, \\bar{\\eta}) - O_j^\\text{meas}}{\\sigma_j} \\right)^2,\n$$\n其中 $\\mathcal{I}$ 是拟合中包含的约束的索引集，$O_j^\\text{model}$ 是约束 $j$ 的模型预测值，$O_j^\\text{meas}$ 是测量的中心值，而 $\\sigma_j$ 是给出的标准差。拟合参数为 $(\\bar{\\rho}, \\bar{\\eta})$，其定义域必须限制在 $\\bar{\\rho} \\in [-0.2, 1.2]$ 和 $\\bar{\\eta} \\in [0.0, 0.8]$。\n\n2. 获取数据集中完整约束集下的最佳拟合顶点 $(\\bar{\\rho}_\\text{full}, \\bar{\\eta}_\\text{full})$ 以及最小化的拟合优度，表示为 $\\chi^2/\\text{dof}$，其中 $\\text{dof} = N_\\text{constraints} - 2$。角度必须以弧度为单位。\n\n3. 执行留一法交叉检验：对于每个约束 $i$，将其从集合中移除，重新拟合 $(\\bar{\\rho}, \\bar{\\eta})$，并计算：\n   - 顶点偏移幅度\n   $$\n   \\Delta_i = \\sqrt{(\\bar{\\rho}_i - \\bar{\\rho}_\\text{full})^2 + (\\bar{\\eta}_i - \\bar{\\eta}_\\text{full})^2},\n   $$\n   其中 $(\\bar{\\rho}_i, \\bar{\\eta}_i)$ 是留一法最佳拟合顶点，\n   - 拟合优度的变化\n   $$\n   \\delta_i = \\left(\\frac{\\chi^2}{\\text{dof}}\\right)_i - \\left(\\frac{\\chi^2}{\\text{dof}}\\right)_\\text{full}.\n   $$\n\n4. 将每个数据集的留一法结果聚合为一个由双元素列表 $[\\Delta_i, \\delta_i]$ 组成的列表，并按照约束移除序列 $[R_u, R_t, \\sin(2\\beta), \\gamma, \\epsilon_K]$排序。\n\n5. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个数据集的结果本身必须是一个列表的列表 $[\\,[\\Delta_1,\\delta_1], \\ldots, [\\Delta_5,\\delta_5]\\,]$。因此，最终输出必须是一个包含每个数据集对应一个此类列表的单一列表，例如，`[[[\\Delta_1,\\delta_1],\\ldots,[\\Delta_5,\\delta_5]], \\ldots]`。\n\n使用以下数据集测试套件，每个数据集都包含标准模型参数和带有不确定度的测量值。所有角度均以弧度为单位，所有其他可观测量均为无量纲：\n\n数据集 1：\n- $A = 0.82$，$\\lambda = 0.225$，$K_\\epsilon = 0.0072$，\n- $R_u^\\text{meas} = 0.38$，$\\sigma_{R_u} = 0.03$，\n- $R_t^\\text{meas} = 0.92$，$\\sigma_{R_t} = 0.05$，\n- $\\sin(2\\beta)^\\text{meas} = 0.69$，$\\sigma_{\\sin(2\\beta)} = 0.02$，\n- $\\gamma^\\text{meas} = 1.18$，$\\sigma_\\gamma = 0.10$（弧度），\n- $\\epsilon_K^\\text{meas} = 0.00217$，$\\sigma_{\\epsilon_K} = 0.00010$。\n\n数据集 2：\n- $A = 0.80$，$\\lambda = 0.226$，$K_\\epsilon = 0.0070$，\n- $R_u^\\text{meas} = 0.36$，$\\sigma_{R_u} = 0.06$，\n- $R_t^\\text{meas} = 0.91$，$\\sigma_{R_t} = 0.04$，\n- $\\sin(2\\beta)^\\text{meas} = 0.695$，$\\sigma_{\\sin(2\\beta)} = 0.015$，\n- $\\gamma^\\text{meas} = 1.20$，$\\sigma_\\gamma = 0.05$（弧度），\n- $\\epsilon_K^\\text{meas} = 0.00210$，$\\sigma_{\\epsilon_K} = 0.00012$。\n\n数据集 3：\n- $A = 0.83$，$\\lambda = 0.224$，$K_\\epsilon = 0.0073$，\n- $R_u^\\text{meas} = 0.3437$，$\\sigma_{R_u} = 0.03$，\n- $R_t^\\text{meas} = 1.009$，$\\sigma_{R_t} = 0.06$，\n- $\\sin(2\\beta)^\\text{meas} = 0.628$，$\\sigma_{\\sin(2\\beta)} = 0.03$，\n- $\\gamma^\\text{meas} = 1.424$，$\\sigma_\\gamma = 0.08$（弧度），\n- $\\epsilon_K^\\text{meas} = 0.002356$，$\\sigma_{\\epsilon_K} = 0.00010$。\n\n实现约束：\n- 使用带有有界优化器的确定性多起点策略，在 $(\\bar{\\rho}, \\bar{\\eta})$ 上最小化 $\\chi^2$，以确保 $(\\bar{\\rho}, \\bar{\\eta})$ 保持在定义域 $\\bar{\\rho} \\in [-0.2, 1.2]$，$\\bar{\\eta} \\in [0.0, 0.8]$ 内。\n- 角度必须严格以弧度处理。\n- 所有数据集的拟合参数数量为 $2$。\n- 除角度以弧度为单位外，所有计算均为无量纲。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个数据集贡献一个包含五个双元素列表的列表，按 $[R_u, R_t, \\sin(2\\beta), \\gamma, \\epsilon_K]$ 排序，其中每个内部的双元素列表按顺序包含 $\\Delta_i$ 和 $\\delta_i$ 作为浮点数。因此，最终输出看起来像一个单一的 Python 风格的列表的列表，例如 $[[[\\Delta_1,\\delta_1],\\ldots,[\\Delta_5,\\delta_5]], [[\\Delta_1,\\delta_1],\\ldots,[\\Delta_5,\\delta_5]], [[\\Delta_1,\\delta_1],\\ldots,[\\Delta_5,\\delta_5]]]$。",
            "solution": "本问题的目标是实现一个简化的全局卡方（$\\chi^2$）拟合，以从一组实验测量中确定CKM幺正三角形的顶点参数 $(\\bar{\\rho}, \\bar{\\eta})$，并使用留一法（Leave-One-Out, LOO）交叉检验来评估模型和数据的自洽性。\n\n**1. 核心方法：最小化 $\\chi^2$**\n\n拟合的核心是构建一个 $\\chi^2$ 函数，它量化了模型预测与实验测量值之间的一致性：\n$$\n\\chi^2(\\bar{\\rho}, \\bar{\\eta}) = \\sum_{j} \\left( \\frac{O_j^\\text{model}(\\bar{\\rho}, \\bar{\\eta}) - O_j^\\text{meas}}{\\sigma_j} \\right)^2\n$$\n其中，$O_j^\\text{model}$ 是依赖于 $(\\bar{\\rho}, \\bar{\\eta})$ 的理论预测值，$O_j^\\text{meas}$ 和 $\\sigma_j$ 分别是实验测量的中心值和不确定度。最佳拟合参数 $(\\bar{\\rho}, \\bar{\\eta})$ 就是使 $\\chi^2$ 最小化的那对值。\n\n模型预测 $O_j^\\text{model}$ 包括：\n*   $R_u = \\sqrt{\\bar{\\rho}^2 + \\bar{\\eta}^2}$\n*   $R_t = \\sqrt{(1 - \\bar{\\rho})^2 + \\bar{\\eta}^2}$\n*   $\\sin(2\\beta) = \\frac{2\\bar{\\eta}(1 - \\bar{\\rho})}{(1 - \\bar{\\rho})^2 + \\bar{\\eta}^2}$\n*   $\\gamma = \\operatorname{atan2}(\\bar{\\eta}, \\bar{\\rho})$\n*   $\\epsilon_K^\\text{model} = K_\\epsilon \\, \\bar{\\eta} \\, (1 - \\bar{\\rho})$\n\n注意，对于角度 $\\beta$ 和 $\\gamma$ 的计算，使用双参数反正切函数 `atan2` 是处理象限问题的标准做法，可以避免歧义和除零错误。\n\n为了找到全局最小值，我们将采用带有边界约束的多起点优化策略。在指定的参数空间 $(\\bar{\\rho} \\in [-0.2, 1.2], \\bar{\\eta} \\in [0.0, 0.8])$ 内选择多个初始点进行优化，并选取给出最低 $\\chi^2$ 值的结果。\n\n**2. 评估拟合：留一法交叉检验**\n\n找到完整约束集下的最佳拟合顶点 $(\\bar{\\rho}_\\text{full}, \\bar{\\eta}_\\text{full})$ 后，我们执行留一法交叉检验来评估每个约束的影响力以及整个数据集的内部自洽性。该过程如下：\n1.  对于数据集中的每一个约束 $i$，暂时将其移除。\n2.  使用剩余的约束重新进行拟合，得到一个新的最佳拟合顶点 $(\\bar{\\rho}_i, \\bar{\\eta}_i)$。\n3.  计算两个关键指标：\n    *   **顶点偏移 $\\Delta_i$**: 新顶点相对于全局顶点的移动距离，$\\Delta_i = \\sqrt{(\\bar{\\rho}_i - \\bar{\\rho}_\\text{full})^2 + (\\bar{\\eta}_i - \\bar{\\eta}_\\text{full})^2}$。这个值越大，说明被移除的约束 $i$ 对确定顶点位置的“拉力”越强。\n    *   **拟合优度变化 $\\delta_i$**: 两个拟合的归一化 $\\chi^2$（即 $\\chi^2/\\text{dof}$）之差。一个大的正值 $\\delta_i$ 可能表示移除约束 $i$ 后，剩余约束之间的一致性变得更差，暗示约束 $i$ 可能与其他约束存在“张力”。\n\n通过分析所有约束的 $[\\Delta_i, \\delta_i]$ 对，我们可以深入了解CKM模型的内部一致性，并识别出哪些测量在全局拟合中起着主导作用。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Performs a leave-one-out cross-check for CKM Unitarity Triangle fits.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": {\"K_eps\": 0.0072},\n            \"constraints\": [\n                {\"name\": \"Ru\", \"meas\": 0.38, \"sigma\": 0.03},\n                {\"name\": \"Rt\", \"meas\": 0.92, \"sigma\": 0.05},\n                {\"name\": \"sin2beta\", \"meas\": 0.69, \"sigma\": 0.02},\n                {\"name\": \"gamma\", \"meas\": 1.18, \"sigma\": 0.10},\n                {\"name\": \"eps_K\", \"meas\": 0.00217, \"sigma\": 0.00010},\n            ],\n        },\n        {\n            \"params\": {\"K_eps\": 0.0070},\n            \"constraints\": [\n                {\"name\": \"Ru\", \"meas\": 0.36, \"sigma\": 0.06},\n                {\"name\": \"Rt\", \"meas\": 0.91, \"sigma\": 0.04},\n                {\"name\": \"sin2beta\", \"meas\": 0.695, \"sigma\": 0.015},\n                {\"name\": \"gamma\", \"meas\": 1.20, \"sigma\": 0.05},\n                {\"name\": \"eps_K\", \"meas\": 0.00210, \"sigma\": 0.00012},\n            ],\n        },\n        {\n            \"params\": {\"K_eps\": 0.0073},\n            \"constraints\": [\n                {\"name\": \"Ru\", \"meas\": 0.3437, \"sigma\": 0.03},\n                {\"name\": \"Rt\", \"meas\": 1.009, \"sigma\": 0.06},\n                {\"name\": \"sin2beta\", \"meas\": 0.628, \"sigma\": 0.03},\n                {\"name\": \"gamma\", \"meas\": 1.424, \"sigma\": 0.08},\n                {\"name\": \"eps_K\", \"meas\": 0.002356, \"sigma\": 0.00010},\n            ],\n        },\n    ]\n\n    def chi_squared(p, K_eps, constraints, included_indices):\n        \"\"\"\n        Calculates the chi-squared value for a given set of parameters and constraints.\n        p: a tuple (rho_bar, eta_bar)\n        \"\"\"\n        rho_bar, eta_bar = p\n        \n        # Define model predictions as a list of lambda functions\n        model_funcs = [\n            lambda p_in: np.sqrt(p_in[0]**2 + p_in[1]**2),\n            lambda p_in: np.sqrt((1 - p_in[0])**2 + p_in[1]**2),\n            lambda p_in: (2 * p_in[1] * (1 - p_in[0])) / ((1 - p_in[0])**2 + p_in[1]**2) if ((1 - p_in[0])**2 + p_in[1]**2) != 0 else 0.0,\n            lambda p_in: np.arctan2(p_in[1], p_in[0]),\n            lambda p_in: K_eps * p_in[1] * (1 - p_in[0])\n        ]\n\n        total_chi2 = 0.0\n        for i in included_indices:\n            constraint = constraints[i]\n            model_val = model_funcs[i](p)\n            meas_val = constraint['meas']\n            sigma_val = constraint['sigma']\n            total_chi2 += ((model_val - meas_val) / sigma_val)**2\n            \n        return total_chi2\n\n    def perform_fit(K_eps, constraints, included_indices):\n        \"\"\"\n        Performs a bounded multi-start minimization of the chi-squared function.\n        \"\"\"\n        bounds = ((-0.2, 1.2), (0.0, 0.8))\n        starts = [(-0.2, 0.0), (1.2, 0.0), (-0.2, 0.8), (1.2, 0.8), (0.5, 0.4)]\n        \n        best_res = None\n        \n        for start_point in starts:\n            res = minimize(\n                chi_squared,\n                x0=start_point,\n                args=(K_eps, constraints, included_indices),\n                method='L-BFGS-B',\n                bounds=bounds\n            )\n            \n            if best_res is None or res.fun  best_res.fun:\n                best_res = res\n                \n        return best_res.x, best_res.fun\n\n    all_results = []\n    \n    for case in test_cases:\n        K_eps = case['params']['K_eps']\n        constraints = case['constraints']\n        num_constraints = len(constraints)\n        \n        # 1. Full fit\n        all_indices = list(range(num_constraints))\n        p_full, chi2_full = perform_fit(K_eps, constraints, all_indices)\n        rho_full, eta_full = p_full\n        dof_full = num_constraints - 2\n        gof_full = chi2_full / dof_full\n        \n        dataset_loo_results = []\n        \n        # 2. Leave-one-out (LOO) fits\n        for i in range(num_constraints):\n            loo_indices = [j for j in all_indices if j != i]\n            \n            p_loo, chi2_loo = perform_fit(K_eps, constraints, loo_indices)\n            rho_loo, eta_loo = p_loo\n            dof_loo = len(loo_indices) - 2\n            gof_loo = chi2_loo / dof_loo\n            \n            # Calculate apex shift\n            delta_p = np.sqrt((rho_loo - rho_full)**2 + (eta_loo - eta_full)**2)\n            \n            # Calculate change in goodness-of-fit\n            delta_gof = gof_loo - gof_full\n            \n            dataset_loo_results.append([delta_p, delta_gof])\n            \n        all_results.append(dataset_loo_results)\n\n    def format_nested_list(obj):\n        \"\"\"Recursively formats a nested list into a compact string representation.\"\"\"\n        if isinstance(obj, list):\n            return f\"[{','.join(format_nested_list(item) for item in obj)}]\"\n        elif isinstance(obj, (int, float, np.number)):\n            return f\"{obj}\"\n        else:\n            return str(obj)\n\n    # Format the final list for printing.\n    formatted_results = [format_nested_list(res) for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}