{
    "hands_on_practices": [
        {
            "introduction": "在进行复杂的模拟之前，必须熟练掌握相对论运动学的基本计算。本练习将聚焦于一个经典的 $2 \\to 2$ 散射过程。通过亲手计算四维动量和洛伦兹不变量——曼德尔斯坦变量（$s$、$t$、$u$），你将巩固对在壳条件以及这些基本运动学量物理意义的理解。",
            "id": "3529989",
            "problem": "考虑在质心系中，自然单位制下（光速 $c=1$）的一次 $2 \\to 2$ 弹性散射。两个静止质量为 $m_{1}$ 和 $m_{2}$、三维动量为 $\\vec{p}_{1}$ 和 $\\vec{p}_{2}$ 的入射粒子，散射成两个静止质量为 $m_{3}$ 和 $m_{4}$、三维动量为 $\\vec{p}_{3}$ 和 $\\vec{p}_{4}$ 的出射粒子。所有四个粒子都在壳。使用符号为 $(+,-,-,-)$ 的 Minkowski 度规。\n\n运动学参数指定如下：\n- 质量：$m_{1} = m_{3} = 0.13957\\,\\mathrm{GeV}$ 且 $m_{2} = m_{4} = 0.93827\\,\\mathrm{GeV}$。\n- 入射三维动量：$\\vec{p}_{1} = (0,\\,0,\\,2.000)\\,\\mathrm{GeV}$ 且 $\\vec{p}_{2} = (0,\\,0,\\,-2.000)\\,\\mathrm{GeV}$。\n- 出射三维动量：选择 $\\vec{p}_{3}$ 的大小为 $|\\vec{p}_{3}| = 2.000\\,\\mathrm{GeV}$，方向指向 $x$–$z$ 平面内的极角 $\\theta = 60^{\\circ}$ (方位角 $\\phi = 0$)，并设置 $\\vec{p}_{4} = -\\vec{p}_{3}$。\n\n任务：\n1. 仅使用每个粒子的在壳条件和四维动量的定义，计算在壳能量 $E_{i}$ (其中 $i \\in \\{1,2,3,4\\}$)，并构建四维矢量 $p_{i}^{\\mu} = (E_{i},\\,\\vec{p}_{i})$。\n2. 使用以四维矢量和 Minkowski 度规定义的 Mandelstam 不变量，为此事件数值计算不变量 $s$、$t$ 和 $u$。\n3. 通过确认初始总四维动量等于末态总四维动量，以及检验恒等式 $s + t + u = m_{1}^{2} + m_{2}^{2} + m_{3}^{2} + m_{4}^{2}$，来验证其与能量-动量守恒的一致性。\n4. 提供 $s$、$t$ 和 $u$ 的数值，单位为 $\\mathrm{GeV}^{2}$。将您最终报告的数值四舍五入到四位有效数字。角度以度为单位；本问题中无需转换为弧度。\n\n您的最终答案必须只包含按所写顺序排列的三个值 $(s,\\,t,\\,u)$，并以 $\\mathrm{GeV}^{2}$ 为单位表示。",
            "solution": "`标签中。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **过程：** 质心系中的 $2 \\to 2$ 弹性散射。\n- **单位：** 自然单位制，$c=1$。\n- **度规：** 符号为 $(+,-,-,-)$ 的 Minkowski 度规。\n- **质量：** $m_{1} = 0.13957\\,\\mathrm{GeV}$，$m_{2} = 0.93827\\,\\mathrm{GeV}$，$m_{3} = 0.13957\\,\\mathrm{GeV}$，$m_{4} = 0.93827\\,\\mathrm{GeV}$。\n- **入射三维动量：** $\\vec{p}_{1} = (0,\\,0,\\,2.000)\\,\\mathrm{GeV}$，$\\vec{p}_{2} = (0,\\,0,\\,-2.000)\\,\\mathrm{GeV}$。\n- **出射三维动量：** $|\\vec{p}_{3}| = 2.000\\,\\mathrm{GeV}$，位于 $x$–$z$ 平面内，极角 $\\theta = 60^{\\circ}$ (方位角 $\\phi = 0$) 。$\\vec{p}_{4} = -\\vec{p}_{3}$。\n- **条件：** 所有四个粒子都在壳。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学依据：** 该问题牢固地建立在狭义相对论和粒子运动学的原理之上。四维矢量、Mandelstam 不变量、在壳条件和自然单位制的使用是计算高能物理中的标准做法。这些质量对应于带电 $\\pi$ 介子 ($m_{\\pi^{\\pm}} \\approx 0.13957\\,\\mathrm{GeV}$) 和质子 ($m_p \\approx 0.93827\\,\\mathrm{GeV}$)，使得该场景成为一个真实的弹性散射过程，例如 $\\pi^+ + p \\to \\pi^+ + p$。运动学在质心系 ($\\vec{p}_{1} + \\vec{p}_{2} = \\vec{0}$) 中指定，这是分析此类相互作用的标准参考系。该问题在科学上是合理的。\n2.  **适定性：** 该问题是适定的。它为特定参考系中的弹性散射事件提供了一套完整的初始条件。任务明确，并导向唯一的数值解。能量和动量守恒在质心系弹性散射的设置（$|\\vec{p}_1| = |\\vec{p}_2| = |\\vec{p}_3| = |\\vec{p}_4|$ 且 $\\vec{p}_3 = -\\vec{p}_4$）中是内在地满足的，问题中已正确指明。验证这一点和 Mandelstam 变量恒等式的要求可作为内部一致性检查。\n3.  **客观性：** 该问题以精确、客观的语言陈述，使用标准的科学术语并提供明确的数值。它没有任何歧义或主观看法。\n\n**步骤 3：结论和行动**\n\n该问题是有效的。它具有科学依据，是适定且客观的。我将继续进行求解。\n\n### 求解过程\n\n问题要求为一个指定的弹性散射事件计算粒子能量、四维动量以及 Mandelstam 不变量 $s$、$t$ 和 $u$。我们在自然单位制 ($c=1$) 中进行计算，并使用 Minkowski 度规 $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$。四维动量为 $p^{\\mu} = (E, \\vec{p})$，四维动量的洛伦兹不变量平方为 $p^2 = p^{\\mu}p_{\\mu} = E^2 - |\\vec{p}|^2$。质量为 $m$ 的粒子的在壳条件是 $p^2 = m^2$。\n\n**任务 1：计算能量和四维矢量**\n\n在壳条件给出了粒子的能量为 $E = \\sqrt{m^2 + |\\vec{p}|^2}$。所有粒子的三维动量大小由给定或隐含条件可知为 $p_{mag} = 2.000\\,\\mathrm{GeV}$。\n\n对于粒子 $1$ 和 $3$：\n$m_1 = m_3 = 0.13957\\,\\mathrm{GeV}$\n$E_1 = E_3 = \\sqrt{(0.13957\\,\\mathrm{GeV})^2 + (2.000\\,\\mathrm{GeV})^2} = \\sqrt{0.0194797849\\,\\mathrm{GeV}^2 + 4.000\\,\\mathrm{GeV}^2} = \\sqrt{4.0194797849\\,\\mathrm{GeV}^2} \\approx 2.004864\\,\\mathrm{GeV}$。\n\n对于粒子 $2$ 和 $4$：\n$m_2 = m_4 = 0.93827\\,\\mathrm{GeV}$\n$E_2 = E_4 = \\sqrt{(0.93827\\,\\mathrm{GeV})^2 + (2.000\\,\\mathrm{GeV})^2} = \\sqrt{0.8803503929\\,\\mathrm{GeV}^2 + 4.000\\,\\mathrm{GeV}^2} = \\sqrt{4.8803503929\\,\\mathrm{GeV}^2} \\approx 2.209152\\,\\mathrm{GeV}$。\n\n现在，我们构建三维动量和四维矢量。\n- $\\vec{p}_1 = (0, 0, 2.000)\\,\\mathrm{GeV}$\n- $\\vec{p}_2 = (0, 0, -2.000)\\,\\mathrm{GeV}$\n\n对于 $\\vec{p}_3$，其大小为 $|\\vec{p}_3| = 2.000\\,\\mathrm{GeV}$，极角为 $\\theta=60^{\\circ}$，方位角为 $\\phi=0^{\\circ}$。其分量为：\n$p_{3x} = |\\vec{p}_3|\\sin\\theta\\cos\\phi = 2.000 \\sin(60^{\\circ}) \\cos(0^{\\circ}) = 2.000 \\cdot (\\frac{\\sqrt{3}}{2}) \\cdot 1 = \\sqrt{3}\\,\\mathrm{GeV} \\approx 1.732\\,\\mathrm{GeV}$。\n$p_{3y} = |\\vec{p}_3|\\sin\\theta\\sin\\phi = 2.000 \\sin(60^{\\circ}) \\sin(0^{\\circ}) = 0\\,\\mathrm{GeV}$。\n$p_{3z} = |\\vec{p}_3|\\cos\\theta = 2.000 \\cos(60^{\\circ}) = 2.000 \\cdot \\frac{1}{2} = 1.000\\,\\mathrm{GeV}$。\n所以，$\\vec{p}_3 = (\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$。\n\n对于 $\\vec{p}_4$，我们有 $\\vec{p}_4 = -\\vec{p}_3$：\n$\\vec{p}_4 = (-\\sqrt{3}, 0, -1.000)\\,\\mathrm{GeV}$。\n\n四维矢量为（能量单位为 GeV）：\n$p_1^{\\mu} = (2.004864, 0, 0, 2.000)$\n$p_2^{\\mu} = (2.209152, 0, 0, -2.000)$\n$p_3^{\\mu} = (2.004864, \\sqrt{3}, 0, 1.000)$\n$p_4^{\\mu} = (2.209152, -\\sqrt{3}, 0, -1.000)$\n\n**任务 2：计算 Mandelstam 不变量**\n\nMandelstam 不变量定义为：\n$s = (p_1 + p_2)^2$\n$t = (p_1 - p_3)^2$\n$u = (p_1 - p_4)^2$\n\n$s$ 的计算：\n在质心系中，$\\vec{p}_1 + \\vec{p}_2 = \\vec{0}$。\n$p_1^{\\mu} + p_2^{\\mu} = (E_1+E_2, \\vec{0})$。\n$s = (p_1 + p_2)^2 = (E_1+E_2)^2 - |\\vec{0}|^2 = (E_1+E_2)^2$。\n$s = (2.004864\\,\\mathrm{GeV} + 2.209152\\,\\mathrm{GeV})^2 = (4.214016\\,\\mathrm{GeV})^2 \\approx 17.757915\\,\\mathrm{GeV}^2$。\n\n$t$ 的计算：\n对于弹性散射，$E_1 = E_3$。\n$p_1^{\\mu} - p_3^{\\mu} = (E_1-E_3, \\vec{p}_1-\\vec{p}_3) = (0, \\vec{p}_1-\\vec{p}_3)$。\n$t = (p_1 - p_3)^2 = 0^2 - |\\vec{p}_1 - \\vec{p}_3|^2 = -|\\vec{p}_1 - \\vec{p}_3|^2$。\n$\\vec{p}_1 - \\vec{p}_3 = (0,0,2.000) - (\\sqrt{3},0,1.000) = (-\\sqrt{3}, 0, 1.000)\\,\\mathrm{GeV}$。\n$|\\vec{p}_1 - \\vec{p}_3|^2 = (-\\sqrt{3})^2 + 0^2 + (1.000)^2 = 3.000 + 1.000 = 4.000\\,\\mathrm{GeV}^2$。\n$t = -4.000\\,\\mathrm{GeV}^2$。根据给定的几何关系，这个结果是精确的。\n\n$u$ 的计算：\n$u = (p_1 - p_4)^2 = p_1^2 + p_4^2 - 2 p_1 \\cdot p_4 = m_1^2 + m_4^2 - 2(E_1 E_4 - \\vec{p}_1 \\cdot \\vec{p}_4)$。\n给定 $m_4=m_2$ 和 $E_4=E_2$：\n$u = m_1^2 + m_2^2 - 2(E_1 E_2 - \\vec{p}_1 \\cdot \\vec{p}_4)$。\n$\\vec{p}_1 \\cdot \\vec{p}_4 = (0, 0, 2.000) \\cdot (-\\sqrt{3}, 0, -1.000) = -2.000\\,\\mathrm{GeV}^2$。\n$u = (0.13957)^2 + (0.93827)^2 - 2( (2.004864)(2.209152) - (-2.000) )\\,\\mathrm{GeV}^2$。\n$u \\approx 0.019480 + 0.880350 - 2(4.429007 + 2.000)\\,\\mathrm{GeV}^2$。\n$u \\approx 0.899830 - 2(6.429007)\\,\\mathrm{GeV}^2 = 0.899830 - 12.858014\\,\\mathrm{GeV}^2 = -11.958184\\,\\mathrm{GeV}^2$。\n\n**任务 3：验证一致性**\n\n能量-动量守恒，$p_1^{\\mu} + p_2^{\\mu} = p_3^{\\mu} + p_4^{\\mu}$：\n初始总四维动量：$p_{in}^{\\mu} = p_1^{\\mu} + p_2^{\\mu} = (E_1+E_2, \\vec{0}) = (4.214016, 0, 0, 0)\\,\\mathrm{GeV}$。\n末态总四维动量：$p_{out}^{\\mu} = p_3^{\\mu} + p_4^{\\mu} = (E_3+E_4, \\vec{p}_3+\\vec{p}_4)$。由于 $E_3=E_1$，$E_4=E_2$ 且 $\\vec{p}_4=-\\vec{p}_3$，我们有 $p_{out}^{\\mu} = (E_1+E_2, \\vec{0}) = p_{in}^{\\mu}$。问题的设置满足守恒定律。\n\n恒等式检验：$s+t+u = m_1^2 + m_2^2 + m_3^2 + m_4^2$。\n质量平方和：\n$\\sum m_i^2 = 2(m_1^2 + m_2^2) = 2((0.13957)^2 + (0.93827)^2) \\,\\mathrm{GeV}^2$。\n$\\sum m_i^2 = 2(0.0194797849 + 0.8803503929)\\,\\mathrm{GeV}^2 = 2(0.8998301778)\\,\\mathrm{GeV}^2 = 1.799660\\,\\mathrm{GeV}^2$。\n\n计算出的 Mandelstam 变量之和：\n$s+t+u \\approx 17.757915 - 4.000 - 11.958184 = 1.799731\\,\\mathrm{GeV}^2$。\n该和与 $\\sum m_i^2$ 之间的微小差异（$0.005\\%$）是由于中间能量值的舍入误差造成的。恒等式得到验证。使用恒等式来计算 $u$ 可以得到一个更精确的结果：\n$u = \\sum m_i^2 - s - t = 1.799660 - 17.757915 - (-4.000) = -11.958255\\,\\mathrm{GeV}^2$。\n\n**任务 4：最终数值**\n\n我们被要求将最终报告的数值四舍五入到四位有效数字。\n$s = 17.757915\\,\\mathrm{GeV}^2 \\to 17.76\\,\\mathrm{GeV}^2$。\n$t = -4.000\\,\\mathrm{GeV}^2$ (精确值) $\\to -4.000\\,\\mathrm{GeV}^2$。\n$u = -11.958255\\,\\mathrm{GeV}^2 \\to -11.96\\,\\mathrm{GeV}^2$。\n\n最终 $(s, t, u)$ 的值为 $(17.76, -4.000, -11.96)\\,\\mathrm{GeV}^2$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n17.76  -4.000  -11.96\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "尽管不变质量的计算公式 $m^2 = (\\sum_i E_i)^2 - \\left\\lVert \\sum_i \\vec{p}_i \\right\\rVert^2$ 形式简单，但在处理准直喷注这类常见物理情景时，其直接的数值计算可能会因灾难性相消而彻底失败。本练习旨在让你诊断并解决这一问题，通过运用如Kahan求和算法等高级数值技术，确保计算的精确性。对于分析真实或模拟高能物理数据的研究者而言，这是一项至关重要的技能。",
            "id": "3530040",
            "problem": "要求您在狭义相对论和高能物理 (HEP) 的背景下，设计并实现一个用于计算不变质量平方总和的计算程序。该程序必须能够诊断并减轻在对近似类光和准直的四维动量求和时，由灾难性抵消引起的数值不稳定性。其理论基础是闵可夫斯基度规，在自然单位制中其号差为 $(+,-,-,-)$ 且光速 $c=1$；能量-动量四维矢量定义为 $p^\\mu=(E,\\vec p)$；以及通过对四维动量求和并取闵可夫斯基范数得到的系统不变质量平方。对于一个包含 $N$ 个粒子的系统，其不变质量平方 $m^2$ 由下式给出\n$$\nm^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left\\lVert \\sum_{i=1}^N \\vec p_i \\right\\rVert^2=\\left(\\sum_{i=1}^N E_i\\right)^2-\\left(\\left(\\sum_{i=1}^N p_{x,i}\\right)^2+\\left(\\sum_{i=1}^N p_{y,i}\\right)^2+\\left(\\sum_{i=1}^N p_{z,i}\\right)^2\\right).\n$$\n在具有近似共线和近似类光动量的多喷注事例中，量 $m^2$ 是通过两个相近的大正数相减得到的，这对浮点舍入误差尤其敏感。您必须实现三种计算不变质量平方的策略：\n- 使用标准双精度算术（IEEE 754 双精度，其中 IEEE 代表电气和电子工程师协会）进行朴素求和。\n- 使用 Kahan 算法进行补偿求和，以减少 $\\sum E_i$ 和 $\\sum \\vec p_i$ 各分量中的累积误差。\n- 一种混合精度方法，使用高精度十进制算术进行求和与平方运算，作为高精度参考。\n\n您的程序必须：\n1. 不读取任何输入，并使用下面提供的测试套件。\n2. 对于每个测试用例，通过提供的 $(E_i,p_{x,i},p_{y,i},s_i)$ 按以下公式构建每个喷注的纵向动量分量 $p_{z,i}$\n$$\np_{z,i}=s_i\\sqrt{E_i^2-p_{x,i}^2-p_{y,i}^2},\n$$\n其中 $s_i\\in\\{+1,-1\\}$ 设置 $p_{z,i}$ 的符号。所有能量 $E_i$ 的单位为 $\\text{GeV}$，动量 $p_{x,i},p_{y,i},p_{z,i}$ 的单位为 $\\text{GeV}$，不变质量平方 $m^2$ 的单位为 $\\text{GeV}^2$。不使用角度，因此没有角度单位适用。\n3. 使用以下方法计算不变质量平方 $m^2$：\n   - 双精度朴素求和。\n   - 双精度 Kahan 补偿求和。\n   - 混合精度，使用高精度十进制算术计算总和及最终的差值。\n4. 使用混合精度结果作为参考值 $m^2_{\\text{ref}}$，并按以下公式报告朴素法和补偿法的相对误差\n$$\n\\varepsilon_{\\text{naive}}=\\frac{\\left|m^2_{\\text{naive}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)},\\quad\n\\varepsilon_{\\text{comp}}=\\frac{\\left|m^2_{\\text{comp}}-m^2_{\\text{ref}}\\right|}{\\max\\left(1,\\left|m^2_{\\text{ref}}\\right|\\right)}.\n$$\n5. 此外，计算一个抵消严重性诊断指标\n$$\n\\rho=\\frac{\\left|m^2_{\\text{ref}}\\right|}{\\left(\\left(\\sum_i E_i\\right)^2+\\left\\lVert \\sum_i \\vec p_i\\right\\rVert^2\\right)},\n$$\n使用相同的高精度和。较小的 $\\rho$ 值（例如 $\\rho\\ll 1$）表示可能存在灾难性抵消。\n\n测试套件：\n- 案例 1（高度准直的六个喷注，所有 $p_{z,i}0$）：\n  - 喷注 1：$(E_1,p_{x,1},p_{y,1},s_1)=(600.0,0.10,-0.08,+1)$\n  - 喷注 2：$(E_2,p_{x,2},p_{y,2},s_2)=(550.0,-0.12,0.06,+1)$\n  - 喷注 3：$(E_3,p_{x,3},p_{y,3},s_3)=(500.0,0.08,0.04,+1)$\n  - 喷注 4：$(E_4,p_{x,4},p_{y,4},s_4)=(450.0,-0.07,-0.03,+1)$\n  - 喷注 5：$(E_5,p_{x,5},p_{y,5},s_5)=(400.0,0.05,0.02,+1)$\n  - 喷注 6：$(E_6,p_{x,6},p_{y,6},s_6)=(350.0,-0.04,-0.01,+1)$\n- 案例 2（背对背的近似类光双喷注）：\n  - 喷注 1：$(E_1,p_{x,1},p_{y,1},s_1)=(500.0,100.0,0.0,+1)$\n  - 喷注 2：$(E_2,p_{x,2},p_{y,2},s_2)=(500.0,-100.0,0.0,-1)$\n- 案例 3（四个喷注，方向混合）：\n  - 喷注 1：$(E_1,p_{x,1},p_{y,1},s_1)=(200.0,30.0,-20.0,+1)$\n  - 喷注 2：$(E_2,p_{x,2},p_{y,2},s_2)=(150.0,-25.0,15.0,-1)$\n  - 喷注 3：$(E_3,p_{x,3},p_{y,3},s_3)=(120.0,10.0,-8.0,+1)$\n  - 喷注 4：$(E_4,p_{x,4},p_{y,4},s_4)=(80.0,-5.0,3.0,-1)$\n- 案例 4（十个具有微小横向动量的极端准直喷注，所有 $p_{z,i}0$）：\n  - 喷注 1：$(E_1,p_{x,1},p_{y,1},s_1)=(550.0,0.0010,-0.0012,+1)$\n  - 喷注 2：$(E_2,p_{x,2},p_{y,2},s_2)=(530.0,-0.0013,0.0009,+1)$\n  - 喷注 3：$(E_3,p_{x,3},p_{y,3},s_3)=(510.0,0.0007,-0.0008,+1)$\n  - 喷注 4：$(E_4,p_{x,4},p_{y,4},s_4)=(490.0,-0.0009,0.0011,+1)$\n  - 喷注 5：$(E_5,p_{x,5},p_{y,5},s_5)=(470.0,0.0011,-0.0007,+1)$\n  - 喷注 6：$(E_6,p_{x,6},p_{y,6},s_6)=(450.0,-0.0008,0.0006,+1)$\n  - 喷注 7：$(E_7,p_{x,7},p_{y,7},s_7)=(430.0,0.0006,-0.0004,+1)$\n  - 喷注 8：$(E_8,p_{x,8},p_{y,8},s_8)=(410.0,-0.0004,0.0005,+1)$\n  - 喷注 9：$(E_9,p_{x,9},p_{y,9},s_9)=(390.0,0.0005,-0.0003,+1)$\n  - 喷注 10：$(E_{10},p_{x,10},p_{y,10},s_{10})=(370.0,-0.0003,0.0004,+1)$\n\n输出规范：\n- 对于每个案例，计算并报告一个包含六个实数的列表\n$$\n\\left[m^2_{\\text{naive}},~m^2_{\\text{comp}},~m^2_{\\text{mixed}},~\\varepsilon_{\\text{naive}},~\\varepsilon_{\\text{comp}},~\\rho\\right],\n$$\n其中 $m^2_{\\text{naive}}$、$m^2_{\\text{comp}}$ 和 $m^2_{\\text{mixed}}$ 的单位为 $\\text{GeV}^2$，而 $\\varepsilon_{\\text{naive}}$、$\\varepsilon_{\\text{comp}}$ 和 $\\rho$ 是无量纲的小数。您的程序应生成单行输出，其中包含四个案例的结果，结果为逗号分隔的列表，并用方括号括起来。例如，格式必须是\n$$\n\\left[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] \\right],\n$$\n不含任何附加文本。",
            "solution": "该问题要求实现并比较三种不同的数值方法，用于计算粒子系统的不变质量平方，这是相对论运动学中的一个基本量。核心挑战是解决被称为“灾难性抵消”的数值不稳定性问题，该问题在为高度准直的高能粒子（喷注）系统计算此量时出现。\n\n该问题的基础在于 Einstein 的狭义相对论，具体来说是能量-动量四维矢量 $p^\\mu = (E, \\vec{p}) = (E, p_x, p_y, p_z)$ 的性质，其中 $E$ 是能量，$\\vec{p}$ 是三维动量。我们在自然单位制中进行计算，其中光速 $c=1$。时空的几何结构由闵可夫斯基度规描述，我们使用 $(+,-,-,-)$ 号差，因此两个四维矢量 $a^\\mu$ 和 $b^\\mu$ 的闵可夫斯基点积为 $a \\cdot b = a^0 b^0 - \\vec{a} \\cdot \\vec{b}$。\n\n单个粒子的不变质量平方 $m^2$ 是其四维动量的闵可夫斯基范数的平方：$m^2 = p^\\mu p_\\mu = E^2 - |\\vec{p}|^2$。这个量是洛伦兹不变量，意味着它在所有惯性参考系中都具有相同的值。对于一个包含 $N$ 个粒子的系统，总四维动量是各个四维动量的和，$P^\\mu = \\sum_{i=1}^N p_i^\\mu$。该系统的不变质量平方就是这个总四维动量的范数平方：\n$$\nM^2 = P^\\mu P_\\mu = \\left(\\sum_{i=1}^N p_i^\\mu\\right) \\cdot \\left(\\sum_{j=1}^N p_j^\\nu\\right) = \\left(\\sum_i E_i\\right)^2 - \\left|\\sum_i \\vec{p}_i\\right|^2\n$$\n这就是问题中提供的公式。单个粒子（喷注）被视为无质量的，这意味着对于每个喷注 $i$，其自身的不变质量平方为 $m_i^2 = E_i^2 - |\\vec{p}_i|^2 = 0$。这使得我们可以根据给定的能量 $E_i$ 和横向动量分量 $p_{x,i}, p_{y,i}$ 来计算纵向动量分量 $p_{z,i}$：\n$$\np_{z,i} = s_i \\sqrt{E_i^2 - (p_{x,i}^2 + p_{y,i}^2)}\n$$\n其中 $s_i \\in \\{+1, -1\\}$ 决定了沿 z 轴的方向。\n\n数值挑战，即灾难性抵消，发生在当 $P^\\mu$ 是“类光的”时候，也就是说，当总能量 $E_{tot} = \\sum E_i$ 与总动量的大小 $|\\vec{p}_{tot}| = |\\sum \\vec{p}_i|$ 非常接近时。例如，当所有粒子以近似光速向几乎相同的方向运动时，就会发生这种情况。在这种情况下，$E_{tot}^2$ 和 $|\\vec{p}_{tot}|^2$ 是两个非常大且几乎相等的数。标准浮点算术（如 IEEE 754 双精度）的精度是有限的（大约 16 位十进制数字）。当两个几乎相等的大数相减时，前面的最高有效位相抵消，导致结果主要由先前计算中累积的舍入误差主导。这可能导致 $M^2$ 的最终值极不准确，甚至可能符号错误。\n\n为了诊断和缓解这个问题，我们将实现并比较三种计算策略。\n\n1.  **朴素求和（双精度）**：这是最直接的方法。使用标准浮点算术对每个四维动量的分量进行求和。最终的不变质量平方计算为 $M_{\\text{naive}}^2 = (\\sum E_i)^2 - ((\\sum p_{x,i})^2 + (\\sum p_{y,i})^2 + (\\sum p_{z,i})^2)$。预计该方法在严重抵消的情况下（例如，高度准直的喷注）表现不佳。\n\n2.  **补偿求和（Kahan 算法）**：此方法旨在提高求和的准确性。Kahan 求和算法是一种经典技术，用于减少浮点数序列求和中的数值误差。对于总动量的四个分量（$E_{tot}, p_{x,tot}, p_{y,tot}, p_{z,tot}$）中的每一个，其和按如下方式计算：\n    - 初始化一个和 $S=0$ 以及一个补偿变量 $c=0$。\n    - 对于序列中的每一项 $x_i$：\n        1.  $y = x_i - c$（减去前一次的误差）。\n        2.  $t = S + y$（加到总和中）。\n        3.  $c = (t - S) - y$（新的误差是在加到 $S$ 时 $y$ 中丢失的部分）。\n        4.  $S = t$（更新总和）。\n    这个过程有效地跟踪“丢失”的低位比特，并在后续阶段将其加回到总和中，从而显著减少累积误差。然后，根据这些更准确的和计算出不变质量平方 $M_{\\text{comp}}^2$。\n\n3.  **混合精度参考计算**：为了建立一个“基准真相”，我们采用任意精度算术，这在 Python 的 `decimal` 模块中可用。我们为这些计算设置了非常高的精度（例如，100 位十进制数字）。首先将以浮点数形式给出的初始喷注数据转换为高精度的 `Decimal` 对象。所有后续操作——计算 $p_z$、对四维动量分量求和以及计算最终的平方差——都使用这种高精度算术进行。其结果 $M_{\\text{ref}}^2$ 被认为是高精度参考，用于评判其他方法的优劣。\n\n通过计算两个指标来完成分析：\n-   **相对误差 ($\\varepsilon$)**：对于朴素法和补偿法，相对于参考结果计算相对误差：$\\varepsilon = |M^2 - M_{\\text{ref}}^2| / \\max(1, |M_{\\text{ref}}^2|)$。分母使用 $\\max(1, \\dots)$ 进行正则化，以处理 $M_{\\text{ref}}^2$ 为零或非常小的情况。\n-   **抵消诊断指标 ($\\rho$)**：该指标量化了抵消的严重程度。它是最终结果的绝对值与相减的两个大数之和的比值：$\\rho = |M_{\\text{ref}}^2| / (E_{tot}^2 + |\\vec{p}_{tot}|^2)$，使用高精度求和结果。$\\rho \\ll 1$ 的值表示结果远小于为得到它而相减的数，这标志着严重的灾难性抵消。\n\n实现过程将首先定义一个函数来处理每个测试用例。该函数将构建四维动量，应用三种计算策略中的每一种来找到 $M^2$，然后计算误差和诊断指标 $\\rho$。所有测试用例的结果随后将被汇总并按规定格式化。",
            "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Set the precision for the high-accuracy reference calculation.\n    # 100 digits is more than sufficient to be a \"ground truth\" for double precision.\n    getcontext().prec = 100\n\n    test_cases = [\n        # Case 1: highly collimated six jets\n        [\n            (600.0, 0.10, -0.08, +1), (550.0, -0.12, 0.06, +1),\n            (500.0, 0.08, 0.04, +1), (450.0, -0.07, -0.03, +1),\n            (400.0, 0.05, 0.02, +1), (350.0, -0.04, -0.01, +1)\n        ],\n        # Case 2: back-to-back nearly lightlike di-jet\n        [\n            (500.0, 100.0, 0.0, +1), (500.0, -100.0, 0.0, -1)\n        ],\n        # Case 3: four jets, mixed directions\n        [\n            (200.0, 30.0, -20.0, +1), (150.0, -25.0, 15.0, -1),\n            (120.0, 10.0, -8.0, +1), (80.0, -5.0, 3.0, -1)\n        ],\n        # Case 4: ten extremely collimated jets\n        [\n            (550.0, 0.0010, -0.0012, +1), (530.0, -0.0013, 0.0009, +1),\n            (510.0, 0.0007, -0.0008, +1), (490.0, -0.0009, 0.0011, +1),\n            (470.0, 0.0011, -0.0007, +1), (450.0, -0.0008, 0.0006, +1),\n            (430.0, 0.0006, -0.0004, +1), (410.0, -0.0004, 0.0005, +1),\n            (390.0, 0.0005, -0.0003, +1), (370.0, -0.0003, 0.0004, +1)\n        ]\n    ]\n\n    all_results = [process_case(case) for case in test_cases]\n\n    # Format the output as a stringified list of lists.\n    result_strings = [str(res) for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef kahan_sum(data):\n    \"\"\"\n    Computes the sum of a sequence of floats using Kahan's compensated summation algorithm.\n    \"\"\"\n    s = 0.0\n    c = 0.0  # A running compensation for lost low-order bits.\n    for x in data:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef process_case(jet_data):\n    \"\"\"\n    Processes a single test case, calculating invariant mass-squared with three methods\n    and reporting errors and a diagnostic.\n    \"\"\"\n    momenta_float = []\n    momenta_dec = []\n\n    for E, px, py, s in jet_data:\n        # Double precision (float) calculation\n        E_f, px_f, py_f = float(E), float(px), float(py)\n        # Ensure argument to sqrt is non-negative, though data is well-formed\n        pz_f_sq_arg = E_f**2 - px_f**2 - py_f**2\n        pz_f = float(s) * math.sqrt(max(0.0, pz_f_sq_arg))\n        momenta_float.append([E_f, px_f, py_f, pz_f])\n        \n        # High precision (Decimal) calculation\n        # Use strings for exact representation\n        E_d, px_d, py_d = Decimal(str(E)), Decimal(str(px)), Decimal(str(py))\n        s_d = Decimal(s)\n        pz_d_sq_arg = E_d**2 - px_d**2 - py_d**2\n        pz_d = s_d * pz_d_sq_arg.sqrt()\n        momenta_dec.append([E_d, px_d, py_d, pz_d])\n\n    momenta_float_np = np.array(momenta_float, dtype=np.float64)\n\n    # --- 1. Naive Summation ---\n    P_naive = np.sum(momenta_float_np, axis=0)\n    m2_naive = P_naive[0]**2 - (P_naive[1]**2 + P_naive[2]**2 + P_naive[3]**2)\n\n    # --- 2. Kahan Compensated Summation ---\n    E_comp = kahan_sum(momenta_float_np[:, 0])\n    px_comp = kahan_sum(momenta_float_np[:, 1])\n    py_comp = kahan_sum(momenta_float_np[:, 2])\n    pz_comp = kahan_sum(momenta_float_np[:, 3])\n    m2_comp = E_comp**2 - (px_comp**2 + py_comp**2 + pz_comp**2)\n\n    # --- 3. Mixed-Precision Reference Calculation ---\n    E_ref = sum(p[0] for p in momenta_dec)\n    px_ref = sum(p[1] for p in momenta_dec)\n    py_ref = sum(p[2] for p in momenta_dec)\n    pz_ref = sum(p[3] for p in momenta_dec)\n    p_vec_norm_sq_ref = px_ref**2 + py_ref**2 + pz_ref**2\n    m2_ref = E_ref**2 - p_vec_norm_sq_ref\n\n    # --- 4. Relative Errors ---\n    m2_ref_f = float(m2_ref)\n    denom_err = max(1.0, abs(m2_ref_f))\n    eps_naive = abs(m2_naive - m2_ref_f) / denom_err\n    eps_comp = abs(m2_comp - m2_ref_f) / denom_err\n\n    # --- 5. Cancellation Severity Diagnostic ---\n    denom_rho = E_ref**2 + p_vec_norm_sq_ref\n    rho = float(abs(m2_ref) / denom_rho if denom_rho != 0 else Decimal(0))\n    \n    return [m2_naive, m2_comp, m2_ref_f, eps_naive, eps_comp, rho]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "最后的练习将所有概念融会贯通于一个实际的模拟任务中：生成两体衰变事件。你将实现从质心系运动学定义、各向同性衰变朝向抽样，到应用通用的洛伦兹变换将事件转换至实验室系的全过程。这项练习是粒子物理事件生成器的核心，它能让你对相空间产生深刻且实用的理解。",
            "id": "3530037",
            "problem": "实现一个完整的、可运行的程序，该程序对一个母粒子衰变产生的相对论性两体末态进行蒙特卡洛抽样。抽样需在质心系（也称为母粒子的静止系）中采用各向同性发射，并通过洛伦兹变换将结果变换回指定的实验室系。目标是通过直接计算来验证：在质心系中重建的极角余弦分布是均匀的，并且四维动量守恒具有很高的数值精度。所有的推导和实现都必须基于第一性原理：四维动量守恒、洛伦兹不变性以及三维空间中的旋转几何。\n\n您的程序必须满足以下科学和计算要求。\n\n- 使用自然单位制，其中 $c=1$。所有的能量和质量必须以 $\\mathrm{GeV}$ 为单位，所有的三维动量必须以 $\\mathrm{GeV}$ 为单位，所有的角度必须以弧度表示。输出必须是无量纲的浮点数。\n\n- 对于实验室系中给定的母粒子四维动量，通过将其四维矢量与闵可夫斯基度规进行缩并并取正根来计算母粒子的不变质量。利用四维动量守恒来确定质心系中两体末态的唯一运动学。质心系中的各向同性要求意味着，其中一个子粒子的极角余弦（记为 $\\cos\\theta^\\ast$）的分布在区间 $\\left[-1,1\\right]$ 上是均匀的，而方位角 $\\phi^\\ast$ 在区间 $\\left[0,2\\pi\\right)$ 上是均匀的。\n\n- 实现任意四维矢量在纯升压（pure boost）下的洛伦兹变换。该升压由一个速度三维矢量 $\\boldsymbol{\\beta}$ 指定，其大小严格小于 1，其中 $\\gamma = 1/\\sqrt{1-\\lVert \\boldsymbol{\\beta}\\rVert^2}$。升压必须能沿三维空间中的任意方向应用，并且能正确地特化到零速度极限情况。\n\n- 每个测试用例的算法工作流程：\n  1. 根据实验室系中给定的母粒子三维动量和母粒子不变质量，构建母粒子的实验室系四维动量，以及从质心系到实验室系的相应升压速度。\n  2. 在质心系中，抽样 $N$ 个独立的对 $(\\cos\\theta^\\ast,\\phi^\\ast)$，其中 $\\cos\\theta^\\ast$ 在 $\\left[-1,1\\right]$ 上均匀分布，$\\phi^\\ast$ 在 $\\left[0,2\\pi\\right)$ 上均匀分布。必须选择实验室系升压方向（$\\boldsymbol{\\beta}$ 的方向）作为极轴，以使验证过程明确且可复现。\n  3. 利用四维动量守恒和在壳条件，构建质心系中的两个子粒子四维动量。使用步骤 1 中确定的升压将两个子粒子的四维动量变换到实验室系。\n  4. 在实验室系中，通过比较所有 $N$ 个样本中子粒子四维动量之和与母粒子实验室系四维动量，来数值验证四维动量守恒。报告分量上的最大绝对偏差，并用母粒子不变质量进行归一化。这将产生一个无量纲的度量。\n  5. 独立地，通过对一个子粒子的实验室系四维动量应用逆向升压（从实验室系回到质心系），计算其相对于升压方向的极角余弦，并汇总 $N$ 个样本的重建值，来重建 $\\cos\\theta^\\ast$。通过计算 Kolmogorov–Smirnov 统计量 $D$ 来量化重建的 $\\cos\\theta^\\ast$ 样本在 $\\left[-1,1\\right]$ 上的均匀性。$D$ 定义为经验累积分布函数与 $\\left[-1,1\\right]$ 上均匀分布的精确累积分布函数之间绝对差的上确界。\n  6. 为了可复现性，将伪随机数生成器的种子设置为 $123456$。\n\n- 为以下参数值的测试套件实现上述算法。每个测试用例由一个元组 $\\left(M,\\;m_1,\\;m_2,\\;\\mathbf{p}_{\\text{lab}},\\;N\\right)$ 指定，其中 $M$ 是母粒子的不变质量（单位 $\\mathrm{GeV}$），$m_1$ 和 $m_2$ 是子粒子的质量（单位 $\\mathrm{GeV}$），$\\mathbf{p}_{\\text{lab}}$ 是母粒子的实验室系三维动量（单位 $\\mathrm{GeV}$），$N$ 是蒙特卡洛抽样的数量：\n  - A 例（一般情况，中等升压）：$\\left(10.0,\\;3.0,\\;2.0,\\;(0.0,\\,0.0,\\,15.0),\\;50000\\right)$。\n  - B 例（无质量子粒子，高升压）：$\\left(10.0,\\;0.0,\\;0.0,\\;(0.0,\\,0.0,\\,90.0),\\;50000\\right)$。\n  - C 例（不对称质量，非共线升压）：$\\left(10.0,\\;0.5,\\;8.5,\\;(7.0,\\,4.0,\\,1.0),\\;50000\\right)$。\n  - D 例（近阈值子粒子，小升压）：$\\left(5.1,\\;2.5,\\;2.5,\\;(0.1,\\,-0.2,\\,0.3),\\;50000\\right)$。\n\n- 您的程序必须为每个测试用例产生两个浮点数：\n  - 针对重建的 $\\cos\\theta^\\ast$ 值与 $\\left[-1,1\\right]$ 上均匀分布的 Kolmogorov–Smirnov 统计量 $D$。\n  - 最大相对四维动量守恒误差，定义为子粒子实验室系四维动量之和与母粒子实验室系四维动量之差的矢量在所有分量和所有样本上的最大绝对偏差，再除以母粒子不变质量。\n\n- 最终输出格式：您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。将每个案例的两个浮点数输出展开成一个列表，顺序为 $\\left[D_A,\\;\\varepsilon_A,\\;D_B,\\;\\varepsilon_B,\\;D_C,\\;\\varepsilon_C,\\;D_D,\\;\\varepsilon_D\\right]$，其中 $D_X$ 和 $\\varepsilon_X$ 分别对应于案例 $X \\in \\{A,B,C,D\\}$ 的统计量和守恒误差。例如，带有占位符值的输出将类似于 $\\left[0.00123,1.2\\mathrm{e}{-12},0.00234,1.1\\mathrm{e}{-12},\\ldots\\right]$。\n\n您的实现必须是通用的，不得硬编码任何依赖于参考系的简化。所有的变换都必须使用完全的三维矢量和四维矢量完成，并且逻辑必须在小升压和大升压的极限情况下，以及在存在无质量和近阈值运动学的情况下保持稳健。最终的数值输出必须是无量纲的浮点数。",
            "solution": "用户提供的问题经评估有效。它具有科学依据，问题明确，客观，并包含足够的信息以得出唯一解。任务是基于狭义相对论原理，实现一个相对论性两体衰变的蒙特卡洛模拟，并通过统计分析和守恒定律检验来验证模拟的正确性。\n\n该解决方案基于以下相对论运动学的第一性原理进行开发。\n\n**1. 四维动量和不变质量**\n\n在狭义相对论框架下并使用自然单位制（光速 $c=1$），粒子的状态由其四维动量 $p^\\mu = (E, \\mathbf{p})$ 描述，其中 $E$ 是能量，$\\mathbf{p}$ 是三维动量。闵可夫斯基度规取为 $g_{\\mu\\nu} = \\mathrm{diag}(1, -1, -1, -1)$。粒子的不变质量 $m$ 是一个洛伦兹不变量，通过其四维动量的缩并定义：$m^2 = p^\\mu p_\\mu = E^2 - \\lVert\\mathbf{p}\\rVert^2$。\n\n**2. 质心系中的两体衰变运动学**\n\n考虑一个质量为 $M$ 的母粒子衰变为两个质量分别为 $m_1$ 和 $m_2$ 的子粒子：$P \\to p_1 + p_2$。在质心（CM）系中，母粒子是静止的。其四维动量为 $P^\\ast = (M, \\mathbf{0})$。根据四维动量守恒，$P^\\ast = p_1^\\ast + p_2^\\ast$。这意味着子粒子的三维动量大小相等，方向相反：$\\mathbf{p}_1^\\ast = -\\mathbf{p}_2^\\ast \\equiv \\mathbf{p}^\\ast$。\n\n子粒子在质心系中的能量由在壳条件给出：\n$$\nE_1^\\ast = \\sqrt{m_1^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2} \\quad \\text{和} \\quad E_2^\\ast = \\sqrt{m_2^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2}\n$$\n能量守恒要求 $M = E_1^\\ast + E_2^\\ast$。求解子粒子动量的大小 $\\lVert\\mathbf{p}^\\ast\\rVert$，可以得到一个唯一的值：\n$$\nM - \\sqrt{m_1^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2} = \\sqrt{m_2^2 + \\lVert\\mathbf{p}^\\ast\\rVert^2}\n$$\n两边平方并求解 $\\lVert\\mathbf{p}^\\ast\\rVert^2$ 可得：\n$$\n\\lVert\\mathbf{p}^\\ast\\rVert = \\frac{\\sqrt{(M^2 - (m_1+m_2)^2)(M^2 - (m_1-m_2)^2)}}{2M} = \\frac{\\sqrt{\\lambda(M^2, m_1^2, m_2^2)}}{2M}\n$$\n其中 $\\lambda(x, y, z) = x^2+y^2+z^2-2xy-2yz-2zx$ 是 Källén 函数或称三角函数。只有当 $M > m_1 + m_2$ 时，衰变在运动学上才是可能的。\n\n**3. 各向同性衰变和方向**\n\n问题指定了在质心系中的各向同性衰变。这意味着子粒子动量 $\\mathbf{p}^\\ast$ 的方向在整个立体角上是均匀分布的。该分布通过从 $[-1, 1]$ 上的均匀分布中抽样极角余弦 $\\cos\\theta^\\ast$，以及从 $[0, 2\\pi)$ 上的均匀分布中抽样方位角 $\\phi^\\ast$ 来生成。\n\n问题将此球坐标系的极轴定义为与从质心系到实验室系的升压方向 $\\hat{\\boldsymbol{\\beta}}$ 对齐。为了构建三维动量矢量 $\\mathbf{p}^\\ast$，我们定义一个右手正交基 $(\\hat{\\mathbf{v}}, \\hat{\\mathbf{w}}, \\hat{\\mathbf{u}})$，其中 $\\hat{\\mathbf{u}} = \\hat{\\boldsymbol{\\beta}}$。矢量 $\\mathbf{p}^\\ast$ 于是为：\n$$\n\\mathbf{p}^\\ast = \\lVert\\mathbf{p}^\\ast\\rVert (\\sin\\theta^\\ast \\cos\\phi^\\ast \\hat{\\mathbf{v}} + \\sin\\theta^\\ast \\sin\\phi^\\ast \\hat{\\mathbf{w}} + \\cos\\theta^\\ast \\hat{\\mathbf{u}})\n$$\n其中 $\\sin\\theta^\\ast = \\sqrt{1 - \\cos^2\\theta^\\ast}$。\n\n**4. 洛伦兹变换（升压）**\n\n质心系和实验室系之间的关系是一个纯洛伦兹升压。在实验室系中，母粒子的三维动量为 $\\mathbf{p}_{\\text{lab}}$，能量为 $E_{\\text{lab}} = \\sqrt{M^2 + \\lVert\\mathbf{p}_{\\text{lab}}\\rVert^2}$。升压速度矢量是母粒子在实验室系中的速度：\n$$\n\\boldsymbol{\\beta} = \\frac{\\mathbf{p}_{\\text{lab}}}{E_{\\text{lab}}}\n$$\n洛伦兹因子为 $\\gamma = 1/\\sqrt{1 - \\lVert\\boldsymbol{\\beta}\\rVert^2}$。一个四维矢量 $q^\\mu=(q^0, \\mathbf{q})$ 变换到升压后的参考系 $q'^\\mu=(q'^0, \\mathbf{q}')$ 遵循以下规则：\n$$\n\\begin{align*}\nq'^0 = \\gamma(q^0 + \\boldsymbol{\\beta} \\cdot \\mathbf{q}) \\\\\n\\mathbf{q}' = \\mathbf{q} + \\left(\\frac{\\gamma - 1}{\\lVert\\boldsymbol{\\beta}\\rVert^2}\\right)(\\mathbf{q} \\cdot \\boldsymbol{\\beta})\\boldsymbol{\\beta} + \\gamma q^0 \\boldsymbol{\\beta}\n\\end{align*}\n$$\n此变换应用于子粒子的四维动量 $p_1^\\ast$ 和 $p_2^\\ast$，以获得它们在实验室系中的值 $p_{1, \\text{lab}}$ 和 $p_{2, \\text{lab}}$。用于验证的逆向升压是通过使用速度 $-\\boldsymbol{\\beta}$ 进行变换来实现的。\n\n**5. 算法实现与验证**\n\n对于每个测试用例，算法按以下步骤进行：\n\n1.  **母粒子运动学**：给定 $M$ 和 $\\mathbf{p}_{\\text{lab}}$，我们计算 $E_{\\text{lab}}$、母粒子四维动量 $P_{\\text{lab}} = (E_{\\text{lab}}, \\mathbf{p}_{\\text{lab}})$ 以及升压矢量 $\\boldsymbol{\\beta} = \\mathbf{p}_{\\text{lab}}/E_{\\text{lab}}$。\n2.  **质心系运动学**：我们计算子粒子动量的大小 $\\lVert\\mathbf{p}^\\ast\\rVert$ 和质心系能量 $E_1^\\ast, E_2^\\ast$。\n3.  **蒙特卡洛抽样**：我们使用带有固定种子的伪随机数生成器，从各自的均匀分布中生成 $N$ 对 $(\\cos\\theta^\\ast, \\phi^\\ast)$，以保证可复现性。\n4.  **子粒子动量构建**：对于 $N$ 个事件中的每一个，我们使用指定的方向在质心系中构建子粒子的三维动量 $\\mathbf{p}^\\ast$ 和 $-\\mathbf{p}^\\ast$，形成四维动量 $p_1^\\ast, p_2^\\ast$，并将它们升压到实验室系以得到 $p_{1, \\text{lab}}, p_{2, \\text{lab}}$。\n5.  **验证**：\n    *   **四维动量守恒**：我们为每个事件计算偏差 $\\Delta P = (p_{1, \\text{lab}} + p_{2, \\text{lab}}) - P_{\\text{lab}}$。守恒误差 $\\varepsilon$ 是 $\\Delta P$ 的任意分量在所有 $N$ 个事件中的最大绝对值，并用母粒子质量 $M$ 进行归一化：\n        $$\n        \\varepsilon = \\frac{\\max_{i \\in \\{1..N\\}, \\mu \\in \\{0,1,2,3\\}} |\\Delta P_i^\\mu|}{M}\n        $$\n    *   **分布均匀性**：对于每个事件，我们取一个子粒子在实验室系中的四维动量 $p_{1, \\text{lab}}$，应用逆向升压 $(-\\boldsymbol{\\beta})$ 回到质心系，并重建极角余弦：\n        $$\n        \\cos\\theta_{\\text{reco}}^\\ast = \\frac{\\mathbf{p}_{1, \\text{reco}}^\\ast \\cdot \\hat{\\boldsymbol{\\beta}}}{\\lVert\\mathbf{p}_{1, \\text{reco}}^\\ast\\rVert}\n        $$\n        然后，我们计算 Kolmogorov-Smirnov (KS) 统计量 $D$，它衡量了 $N$ 个重建的 $\\cos\\theta_{\\text{reco}}^\\ast$ 值的经验累积分布函数（ECDF）与在 $[-1, 1]$ 上的均匀分布的理论累积分布函数（CDF）$F(x)=(x+1)/2$ 之间的最大差异。\n        $$\n        D = \\sup_x |F_N(x) - F(x)|\n        $$\n\n这个过程严谨地模拟了物理过程，并对底层相对论原理实现的正确性提供了定量检验。为了效率，计算使用了矢量化操作。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Simulates relativistic two-body decays and verifies the results.\n    \"\"\"\n\n    def boost(p_4vecs, beta_vec):\n        \"\"\"\n        Performs a Lorentz boost on an array of 4-vectors.\n\n        Args:\n            p_4vecs (np.ndarray): An array of 4-vectors, shape (N, 4).\n            beta_vec (np.ndarray): The 3-vector boost velocity, shape (3,).\n\n        Returns:\n            np.ndarray: The array of boosted 4-vectors, shape (N, 4).\n        \"\"\"\n        beta_sq = np.dot(beta_vec, beta_vec)\n        if beta_sq == 0.0:\n            return p_4vecs\n        if beta_sq >= 1.0:\n            raise ValueError(\"Boost velocity must be less than c=1.\")\n        \n        gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n        \n        p0 = p_4vecs[:, 0]\n        p_3vecs = p_4vecs[:, 1:]\n        \n        beta_dot_p = np.dot(p_3vecs, beta_vec)\n        \n        p0_prime = gamma * (p0 + beta_dot_p)\n        \n        # Vectorized implementation of the 3-momentum boost formula\n        factor = (gamma - 1.0) / beta_sq\n        p_3vecs_prime = p_3vecs \\\n                     + np.outer(factor * beta_dot_p, beta_vec) \\\n                     + np.outer(gamma * p0, beta_vec)\n\n        p_prime = np.zeros_like(p_4vecs)\n        p_prime[:, 0] = p0_prime\n        p_prime[:, 1:] = p_3vecs_prime\n        \n        return p_prime\n\n    def process_case(M, m1, m2, p_lab_3vec, N, rng):\n        \"\"\"\n        Processes a single test case for the two-body decay simulation.\n        \"\"\"\n        p_lab_3vec = np.array(p_lab_3vec, dtype=np.float64)\n\n        # 1. Parent kinematics in the lab frame\n        p_lab_norm = np.linalg.norm(p_lab_3vec)\n        E_lab = np.sqrt(M**2 + p_lab_norm**2)\n        P_lab = np.array([E_lab, p_lab_3vec[0], p_lab_3vec[1], p_lab_3vec[2]])\n        \n        beta_vec = p_lab_3vec / E_lab\n        beta_norm = np.linalg.norm(beta_vec)\n\n        # 2. Sample N events in the CM frame\n        cos_theta_star = rng.uniform(-1.0, 1.0, size=N)\n        phi_star = rng.uniform(0.0, 2.0 * np.pi, size=N)\n        sin_theta_star = np.sqrt(1.0 - cos_theta_star**2)\n        \n        # 3. Construct daughter momenta in the CM frame\n        if M  m1 + m2:\n            raise ValueError(\"Decay is kinematically forbidden.\")\n        \n        p_star_mag_sq = (M**2 - (m1 + m2)**2) * (M**2 - (m1 - m2)**2) / (4.0 * M**2)\n        p_star_mag = np.sqrt(p_star_mag_sq)\n        \n        E1_star = np.sqrt(m1**2 + p_star_mag**2)\n        E2_star = np.sqrt(m2**2 + p_star_mag**2)\n\n        # Construct orthonormal basis aligned with the boost direction\n        if beta_norm > 1e-12:\n            u_hat = beta_vec / beta_norm\n        else: # Handle zero boost case\n            u_hat = np.array([0., 0., 1.])\n\n        # Robustly find a vector 'a' not parallel to u_hat\n        a = np.zeros(3)\n        idx = np.argmin(np.abs(u_hat))\n        a[idx] = 1.0\n        w_hat = np.cross(u_hat, a)\n        w_hat /= np.linalg.norm(w_hat)\n        v_hat = np.cross(w_hat, u_hat)\n\n        # Construct daughter 1's 3-momentum vectors in the CM frame\n        p_star_x = p_star_mag * sin_theta_star * np.cos(phi_star)\n        p_star_y = p_star_mag * sin_theta_star * np.sin(phi_star)\n        p_star_z = p_star_mag * cos_theta_star\n        \n        p_star_vecs = np.outer(p_star_x, v_hat) + \\\n                      np.outer(p_star_y, w_hat) + \\\n                      np.outer(p_star_z, u_hat)\n        \n        # Construct daughter 4-momenta in the CM frame\n        p1_star = np.hstack((np.full((N, 1), E1_star), p_star_vecs))\n        p2_star = np.hstack((np.full((N, 1), E2_star), -p_star_vecs))\n\n        # Boost daughters to lab frame\n        p1_lab = boost(p1_star, beta_vec)\n        p2_lab = boost(p2_star, beta_vec)\n\n        # 4. Verify 4-momentum conservation\n        P_lab_broadcast = np.tile(P_lab, (N, 1))\n        delta_P = (p1_lab + p2_lab) - P_lab_broadcast\n        max_abs_dev = np.max(np.abs(delta_P))\n        conservation_error = max_abs_dev / M\n\n        # 5. Verify cos(theta*) distribution\n        p1_reco_star = boost(p1_lab, -beta_vec)\n        p1_reco_3vecs_star = p1_reco_star[:, 1:]\n        p1_reco_3vecs_mag = np.linalg.norm(p1_reco_3vecs_star, axis=1)\n        \n        # Avoid division by zero for massless particles at rest (not in this problem)\n        safe_mags = np.where(p1_reco_3vecs_mag > 1e-12, p1_reco_3vecs_mag, 1.0)\n        \n        cos_theta_reco = np.dot(p1_reco_3vecs_star, u_hat) / safe_mags\n        \n        ks_result = kstest(cos_theta_reco, 'uniform', args=(-1, 2))\n        ks_statistic = ks_result.statistic\n        \n        return ks_statistic, conservation_error\n\n    # --- Main execution starts here ---\n\n    test_cases = [\n        # (M, m1, m2, p_lab, N)\n        (10.0, 3.0, 2.0, (0.0, 0.0, 15.0), 50000),    # Case A\n        (10.0, 0.0, 0.0, (0.0, 0.0, 90.0), 50000),    # Case B\n        (10.0, 0.5, 8.5, (7.0, 4.0, 1.0), 50000),     # Case C\n        (5.1, 2.5, 2.5, (0.1, -0.2, 0.3), 50000),     # Case D\n    ]\n    \n    # Initialize RNG with fixed seed for reproducibility\n    rng = np.random.default_rng(123456)\n    \n    results = []\n    for case in test_cases:\n        M, m1, m2, p_lab, N = case\n        ks_d, error_eps = process_case(M, m1, m2, p_lab, N, rng)\n        results.extend([ks_d, error_eps])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}