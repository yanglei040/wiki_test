{
    "hands_on_practices": [
        {
            "introduction": "在实际的物理分析中，我们经常需要在多个相互关联的区间（例如，相邻的质量箱）中进行搜索。在这种情况下，简单的邦费罗尼校正会高估我们“观察”的次数，从而得出过于保守的结论。本练习将介绍一种更为严谨的方法，通过直接从相关性矩阵计算“有效试验次数”（$M_{\\mathrm{eff}}$），来量化真实的搜索空间，为评估全局显著性提供更精确的基础。",
            "id": "3539414",
            "problem": "考虑一个由质量分箱索引标记的局部假设检验序列，每个检验在原假设下对一个固定的检验统计量产生一个局部尾部概率 $p_{\\mathrm{loc}} \\in [0,1]$。由于有限的质量分辨率和重叠窗口，相邻的质量分箱是相关的。通过一个 $M \\times M$ 的对称三对角相关矩阵 $\\mathbf{C}$ 来对此相关性进行建模，其元素为\n- 对所有 $i$，$C_{ii} = 1$\n- 对 $i = 1,\\dots,M-1$，$C_{i,i+1} = C_{i+1,i} = \\rho$\n- 其他情况下 $C_{ij} = 0$\n其中 $\\rho \\in (-1,1)$ 是相邻分箱之间的相关性。你可以假设对于下文测试套件中的 $\\rho$ 和 $M$ 值，$\\mathbf{C}$ 是正定的。\n\n全局“别处效应”校正概率 $p_{\\mathrm{glob}}$ 定义为在整个搜索范围内观测到至少一个与已观测到的同样显著的局部涨落的概率。当检验是独立的时，$p_{\\mathrm{glob}}$ 和 $p_{\\mathrm{loc}}$ 在 $N$ 次试验中的确切关系由 $p_{\\mathrm{glob}} = 1 - (1 - p_{\\mathrm{loc}})^{N}$ 给出。在存在相关性的情况下，用一个依赖于 $\\mathbf{C}$ 的有效独立试验次数 $M_{\\mathrm{eff}}$ 来代替 $N$。从 $\\mathbf{C}$ 的谱中数值计算 $M_{\\mathrm{eff}}$，然后将 $M_{\\mathrm{eff}}$ 代入独立试验公式中计算 $p_{\\mathrm{glob}}$。\n\n你的程序必须：\n- 为每个给定的 $(M,\\rho)$ 构建 $\\mathbf{C}$。\n- 使用从谱导出的一个有原则的有效维度度量，从 $\\mathbf{C}$ 的特征值中数值计算 $M_{\\mathrm{eff}}$。\n- 对于每种情况，使用以 $M_{\\mathrm{eff}}$ 代替整数计数的独立试验组合方法，从 $p_{\\mathrm{loc}}$ 和 $M_{\\mathrm{eff}}$ 计算 $p_{\\mathrm{glob}}$。所有概率都必须作为 $[0,1]$ 中的无量纲数处理，并以小数形式报告，而非百分比。\n\n测试套件：\n1. $M = 100$, $\\rho = 0.5$, $p_{\\mathrm{loc}} = 2.87 \\times 10^{-7}$。\n2. $M = 100$, $\\rho = 0.0$, $p_{\\mathrm{loc}} = 2.87 \\times 10^{-7}$。\n3. $M = 100$, $\\rho = 0.45$, $p_{\\mathrm{loc}} = 10^{-3}$。\n4. $M = 50$, $\\rho = -0.45$, $p_{\\mathrm{loc}} = 0.05$。\n5. $M = 1000$, $\\rho = 0.2$, $p_{\\mathrm{loc}} = 10^{-9}$。\n6. $M = 100$, $\\rho = 0.49$, $p_{\\mathrm{loc}} = 10^{-6}$。\n\n输出规范：\n- 对每个测试用例，输出一个双元素列表 $[M_{\\mathrm{eff}}, p_{\\mathrm{glob}}]$。\n- 将所有测试用例的结果聚合到一个列表中，保持上述顺序。\n- 将每个数值条目四舍五入到十二位有效数字。\n- 你的程序应生成单行输出，包含用方括号括起来的、以逗号分隔的结果。例如，最终输出必须如下所示：\n$[ [M_{\\mathrm{eff}}^{(1)},p_{\\mathrm{glob}}^{(1)}], [M_{\\mathrm{eff}}^{(2)},p_{\\mathrm{glob}}^{(2)}], \\dots ]$\n除了标准的逗号和括号外，没有额外的空白要求。\n\n不应读取任何外部输入；所有参数均如上所述，程序必须是自包含和确定性的。",
            "solution": "用户提供的问题是有效的。它以高能物理的统计方法为科学基础，在其术语的标准解释下是提法恰当的，并且其表述是客观的。因此，我们将提供一个完整的解决方案。\n\n该问题要求在一系列 $M$ 个相关的假设检验中，从一个局部p值 ($p_{\\mathrm{loc}}$) 计算全局p值（或经“别处效应”校正的p值，$p_{\\mathrm{glob}}$）。用于合并 $N$ 个独立检验的标准公式 $p_{\\mathrm{glob}} = 1 - (1 - p_{\\mathrm{loc}})^{N}$，可以通过引入有效独立试验次数 $M_{\\mathrm{eff}}$ 来适用于相关检验。问题的核心是根据给定的相关模型确定 $M_{\\mathrm{eff}}$。\n\n**1. 相关模型和有效试验次数**\n\n相邻检验之间的相关性由一个 $M \\times M$ 的对称三对角相关矩阵 $\\mathbf{C}$ 描述，其元素为：\n$$\nC_{ij} =\n\\begin{cases}\n1  \\text{if } i=j \\\\\n\\rho  \\text{if } |i-j|=1 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n其中 $\\rho \\in (-1, 1)$ 是相邻分箱之间的相关系数。\n\n问题指定 $M_{\\mathrm{eff}}$ 应当是一个“从 $\\mathbf{C}$ 的谱导出的有原则的有效维度度量”。对于一组相关变量，一个标准的、有原则的有效参数数量（或自由度）的度量是从相关矩阵的特征值 $\\{\\lambda_i\\}_{i=1}^M$ 导出的。该度量有时与参与率有关，定义为：\n$$\nM_{\\mathrm{eff}} = \\frac{\\left(\\sum_{i=1}^M \\lambda_i\\right)^2}{\\sum_{i=1}^M \\lambda_i^2}\n$$\n对任何相关矩阵，其特征值之和等于其迹。$\\mathbf{C}$ 的迹是 $\\mathrm{Tr}(\\mathbf{C}) = \\sum_{i=1}^M C_{ii} = \\sum_{i=1}^M 1 = M$。因此，$M_{\\mathrm{eff}}$ 的公式简化为：\n$$\nM_{\\mathrm{eff}} = \\frac{M^2}{\\sum_{i=1}^M \\lambda_i^2}\n$$\n这个表达式正确地再现了预期的极限情况：对于独立检验（$\\rho=0$），$\\mathbf{C}=\\mathbf{I}$，所有 $\\lambda_i=1$，且 $M_{\\mathrm{eff}} = M^2/M = M$。对于完全相关的检验，$M_{\\mathrm{eff}} \\to 1$。\n\n**2. 特征值和 $M_{\\mathrm{eff}}$ 的解析计算**\n\n矩阵 $\\mathbf{C}$ 是一种特殊类型的对称三对角托普利兹（Toeplitz）矩阵。这类矩阵的特征值具有已知的解析形式。对于一个主对角线上为 $a$、第一副对角线上为 $b$ 的 $M \\times M$ 矩阵，其特征值为 $\\lambda_k = a + 2b \\cos\\left(\\frac{k\\pi}{M+1}\\right)$，其中 $k=1, \\dots, M$。在我们的例子中，$a=1$，$b=\\rho$，所以 $\\mathbf{C}$ 的特征值为：\n$$\n\\lambda_k = 1 + 2\\rho \\cos\\left(\\frac{k\\pi}{M+1}\\right), \\quad k=1, \\dots, M\n$$\n虽然可以数值计算这些特征值，但对其平方和 $\\sum_{i=1}^M \\lambda_i^2$ 进行解析计算提供了一个更优雅、高效和精确的解决方案。\n\n我们计算特征值的平方和：\n$$\n\\sum_{k=1}^M \\lambda_k^2 = \\sum_{k=1}^M \\left(1 + 2\\rho \\cos\\left(\\frac{k\\pi}{M+1}\\right)\\right)^2\n$$\n$$\n= \\sum_{k=1}^M \\left(1 + 4\\rho \\cos\\left(\\frac{k\\pi}{M+1}\\right) + 4\\rho^2 \\cos^2\\left(\\frac{k\\pi}{M+1}\\right)\\right)\n$$\n$$\n= M + 4\\rho \\sum_{k=1}^M \\cos\\left(\\frac{k\\pi}{M+1}\\right) + 4\\rho^2 \\sum_{k=1}^M \\cos^2\\left(\\frac{k\\pi}{M+1}\\right)\n$$\n这些和可以解析地求出。第一个和为零：$\\sum_{k=1}^M \\cos\\left(\\frac{k\\pi}{M+1}\\right) = 0$。对于第二个和，我们使用恒等式 $\\cos^2(x) = \\frac{1}{2}(1+\\cos(2x))$：\n$$\n\\sum_{k=1}^M \\cos^2\\left(\\frac{k\\pi}{M+1}\\right) = \\sum_{k=1}^M \\frac{1}{2}\\left(1 + \\cos\\left(\\frac{2k\\pi}{M+1}\\right)\\right) = \\frac{M}{2} + \\frac{1}{2}\\sum_{k=1}^M \\cos\\left(\\frac{2k\\pi}{M+1}\\right)\n$$\n余下的和计算结果为 $\\sum_{k=1}^M \\cos\\left(\\frac{2k\\pi}{M+1}\\right) = -1$。\n因此，$\\sum_{k=1}^M \\cos^2\\left(\\frac{k\\pi}{M+1}\\right) = \\frac{M}{2} - \\frac{1}{2} = \\frac{M-1}{2}$。\n\n将这些结果代回特征值平方和的表达式中：\n$$\n\\sum_{k=1}^M \\lambda_k^2 = M + 4\\rho(0) + 4\\rho^2\\left(\\frac{M-1}{2}\\right) = M + 2\\rho^2(M-1)\n$$\n这就得到了 $M_{\\mathrm{eff}}$ 的一个闭式解析表达式：\n$$\nM_{\\mathrm{eff}} = \\frac{M^2}{M + 2\\rho^2(M-1)}\n$$\n该公式仅依赖于给定的参数 $M$ 和 $\\rho$。\n\n**3. 全局p值的计算**\n\n确定了 $M_{\\mathrm{eff}}$ 后，全局p值通过将 $M_{\\mathrm{eff}}$ 代入独立试验公式来计算：\n$$\np_{\\mathrm{glob}} = 1 - (1 - p_{\\mathrm{loc}})^{M_{\\mathrm{eff}}}\n$$\n为了数值稳定性，特别是当 $p_{\\mathrm{loc}}$ 很小时，最好使用对数和指数函数进行计算。令 $x = -p_{\\mathrm{loc}}$。项 $(1 - p_{\\mathrm{loc}})^{M_{\\mathrm{eff}}} = (1+x)^{M_{\\mathrm{eff}}} = \\exp(M_{\\mathrm{eff}} \\ln(1+x))$。使用库函数 `log1p`（计算 $\\ln(1+x)$）和 `expm1`（计算 $e^y-1$）可以提供更高的精度。计算变为：\n$$\np_{\\mathrm{glob}} = 1 - \\exp(M_{\\mathrm{eff}} \\cdot \\mathrm{log1p}(-p_{\\mathrm{loc}})) = -\\mathrm{expm1}(M_{\\mathrm{eff}} \\cdot \\mathrm{log1p}(-p_{\\mathrm{loc}}))\n$$\n\n**4. 算法总结**\n\n对于每个由 $(M, \\rho, p_{\\mathrm{loc}})$ 定义的测试用例：\n1.  使用导出的解析公式计算 $M_{\\mathrm{eff}}$：$M_{\\mathrm{eff}} = M^2 / (M + 2\\rho^2(M-1))$。\n2.  使用数值稳定的公式计算 $p_{\\mathrm{glob}}$：$p_{\\mathrm{glob}} = -\\mathrm{expm1}(M_{\\mathrm{eff}} \\cdot \\mathrm{log1p}(-p_{\\mathrm{loc}}))$。\n3.  将 $M_{\\mathrm{eff}}$ 和 $p_{\\mathrm{glob}}$ 四舍五入到12位有效数字。\n4.  将结果格式化为双元素列表，并为最终输出进行聚合。\n\n这种方法绕过了数值矩阵对角化，为所需量的计算提供了一个直接、精确且高效的方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the look-elsewhere effect problem for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (M, rho, p_loc)\n        (100, 0.5, 2.87e-7),\n        (100, 0.0, 2.87e-7),\n        (100, 0.45, 1e-3),\n        (50, -0.45, 0.05),\n        (1000, 0.2, 1e-9),\n        (100, 0.49, 1e-6),\n    ]\n\n    def round_to_sf(x, sf):\n        \"\"\"\n        Rounds a number x to a specified number of significant figures (sf).\n        \"\"\"\n        if x == 0:\n            return 0.0\n        # Calculate the number of decimal places to round to\n        order_of_magnitude = np.floor(np.log10(np.abs(x)))\n        decimal_places = sf - 1 - int(order_of_magnitude)\n        return np.round(x, decimal_places)\n\n    results_pairs = []\n    for M, rho, p_loc in test_cases:\n        # Step 1: Calculate the effective number of trials, M_eff.\n        # This is the analytical solution derived from the eigenvalues of the\n        # specified tridiagonal correlation matrix.\n        if M == 1:\n            m_eff = 1.0\n        else:\n            m_eff = M**2 / (M + 2 * rho**2 * (M - 1))\n\n        # Step 2: Calculate the global p-value, p_glob.\n        # Use a numerically stable formula to avoid precision loss for small p_loc.\n        # p_glob = 1 - (1 - p_loc)**M_eff\n        #        = -expm1(M_eff * log1p(-p_loc))\n        p_glob = -np.expm1(m_eff * np.log1p(-p_loc))\n\n        # Step 3: Round results to 12 significant figures.\n        m_eff_rounded = round_to_sf(m_eff, 12)\n        p_glob_rounded = round_to_sf(p_glob, 12)\n\n        results_pairs.append([m_eff_rounded, p_glob_rounded])\n\n    # Step 4: Format the output as specified.\n    # We construct the string manually to ensure the exact format is met,\n    # including number representation and brackets.\n    output_parts = []\n    for pair in results_pairs:\n        # Use a general format with sufficient precision to represent the\n        # rounded numbers correctly, including scientific notation.\n        meff_str = f\"{pair[0]:.15g}\"\n        pglob_str = f\"{pair[1]:.15g}\"\n        output_parts.append(f\"[{meff_str},{pglob_str}]\")\n\n    print(f\"[{','.join(output_parts)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在有效试验次数概念的基础上，本练习将探讨一个对实验设计至关重要的问题：“别处效应”的实际代价是什么？您将建立一个程序，用以确定达到发现级显著性所需的最小信号强度 $\\mu$，从而展示更大的搜索空间（即更大的 $M_{\\mathrm{eff}}$）如何直接导致更高的新发现门槛。这个过程量化了搜索过程中固有的灵敏度损失。",
            "id": "3539395",
            "problem": "您的任务是量化计算高能物理中典型的一维凸点搜寻因“别处效应”（look-elsewhere effect）而导致的灵敏度损失。考虑一个在质量谱上进行扫描的搜寻，其有效独立试验次数表示为 $M_{\\mathrm{eff}}$，其中，每个质量假设都被视为一个计数实验，其预期本底产额为 $b$，信号模型在单位信号强度下的预期产额为 $s_{0}$。实际的信号强度乘子表示为 $\\mu$，从而得到预期信号产额 $s(\\mu) = \\mu s_{0}$。假设该搜寻在每个质量值上采用基于似然比的局部检验，并使用以 $M_{\\mathrm{eff}}$ 为特征的有效试验因子在整个扫描范围内进行汇总。\n\n从计数的泊松似然、剖面似然比的概念以及通过标准正态分布的累积分布函数（CDF）将尾部概率映射到高斯等效显著性的标准方法出发，推导一种计算最小信号强度 $\\mu$ 的方法，使得全局显著性 $Z_{\\mathrm{glob}}(\\mu)$ 达到或超过 $5$（五西格玛）的发现阈值。然后，在该最小 $\\mu$ 值下，量化相应的局部中位显著性 $Z_{\\mathrm{loc}}(\\mu)$，以说明由“别处效应”引入的灵敏度差距。\n\n科学真实性和普适性要求：\n- 将 $b$ 和 $s_{0}$ 视为无量纲的预期计数值。\n- 角度单位不适用。\n- 程序必须实现一个数值稳定且逻辑上合理的流程，该流程从基于泊松似然的检验和标准正态尾部概率映射的定义出发，而不依赖于任何临时的或纯经验的捷径。\n\n您的程序应以完全确定的方式实现以下任务：\n1. 对于每个测试用例 $(M_{\\mathrm{eff}}, b, s_{0})$，计算使得 $Z_{\\mathrm{glob}}(\\mu) \\ge 5$ 的最小 $\\mu$，并报告该最小 $\\mu$ 值以及在该 $\\mu$ 值下计算出的相应 $Z_{\\mathrm{loc}}(\\mu)$。\n2. 使用一个稳健的数值搜索方法，该方法的合理性可由基于似然的显著性相对于 $\\mu$ 的单调性来证明。\n\n测试套件：\n- 用例 1：$M_{\\mathrm{eff}} = 1$, $b = 100$, $s_{0} = 5$。\n- 用例 2：$M_{\\mathrm{eff}} = 100$, $b = 100$, $s_{0} = 5$。\n- 用例 3：$M_{\\mathrm{eff}} = 10000$, $b = 1000$, $s_{0} = 10$。\n- 用例 4：$M_{\\mathrm{eff}} = 500$, $b = 1$, $s_{0} = 1$。\n- 用例 5：$M_{\\mathrm{eff}} = 1000$, $b = 10000$, $s_{0} = 50$。\n\n答案规格：\n- 对于每个测试用例，生成一个包含两个浮点数的列表：最小的 $\\mu$ 值和在该 $\\mu$ 值下计算出的 $Z_{\\mathrm{loc}}(\\mu)$。\n- 所有输出都必须是无量纲的。\n- 浮点数以十进制形式表示，并四舍五入到小数点后六位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为由方括号括起来的列表的逗号分隔列表，例如：$[\\,[\\mu_{1}, Z_{\\mathrm{loc},1}], [\\mu_{2}, Z_{\\mathrm{loc},2}], \\dots\\,]$。",
            "solution": "用户提供的问题已经过严格验证，被确定为具有科学依据、定义明确且客观。它概述了高能物理中一个标准但并非无足轻重的灵敏度计算问题。该问题没有科学缺陷、矛盾或含糊之处。所有提供的参数都足以推导出一个唯一且有意义的解。\n\n该问题要求我们量化因“别处效应”而导致的灵敏度损失，这涉及到找到能够产生 $5\\sigma$ 全局显著性的最小信号强度 $\\mu$，并确定相应的局部显著性。解决方案首先为局部搜寻建立统计框架，然后使用所提供的有效试验因子 $M_{\\mathrm{eff}}$ 将其扩展到全局背景。\n\n局部搜寻（在固定质量处的“凸点搜寻”）的核心是一个计数实验。观测到的事件数 $n$ 被建模为一个服从泊松分布的随机变量。该分布的均值是预期本底事件数 $b$ 和预期信号事件数 $s(\\mu) = \\mu s_0$ 的总和。参数 $\\mu$ 是信号强度乘子。问题假设 $b$ 和 $s_0$ 是已知常数。在给定信号强度 $\\mu$ 的情况下，观测到 $n$ 个事件的泊松似然函数为：\n$$ L(\\mu) = \\frac{(\\mu s_0 + b)^n e^{-(\\mu s_0 + b)}}{n!} $$\n\n为了检验信号的存在，我们将纯本底假设（$\\mathcal{H}_0$，其中 $\\mu=0$）与信号加本底假设（$\\mathcal{H}_1$，其中 $\\mu0$）进行比较。用于发现的标准检验统计量是剖面似然比 $q_0$：\n$$ q_0 = -2 \\ln \\frac{L(\\mu=0)}{L(\\hat{\\mu})} $$\n其中 $\\hat{\\mu}$ 是在给定数据 $n$ 的情况下使似然函数 $L(\\mu)$ 最大化的 $\\mu$ 值。$\\hat{\\mu}$ 的值被约束为非负，因为负的信号强度是不符合物理实际的。最大化 $L(\\mu)$ 等价于最大化 $\\ln L(\\mu)$。$\\ln L(\\mu)$ 相对于 $\\mu$ 的导数为：\n$$ \\frac{d}{d\\mu} \\ln L(\\mu) = \\frac{n s_0}{\\mu s_0 + b} - s_0 $$\n将导数设为零可得 $\\hat{\\mu} s_0 + b = n$，或 $\\hat{\\mu} = (n-b)/s_0$。如果 $n \\le b$，无约束的最大值出现在负的 $\\mu$ 处，因此在物理区域 $\\mu \\ge 0$ 内的最大值位于 $\\hat{\\mu}=0$。\n因此，检验统计量为：\n$$ q_0 = \\begin{cases} -2 \\ln \\frac{L(0)}{L(\\hat{\\mu})}  \\text{if } n  b \\\\ 0  \\text{if } n \\le b \\end{cases} $$\n代入似然表达式，对于 $nb$ 我们有 $L(\\hat{\\mu}) = \\frac{n^n e^{-n}}{n!}$ 和 $L(0) = \\frac{b^n e^{-b}}{n!}$。该比率变为 $\\frac{L(0)}{L(\\hat{\\mu})} = \\left(\\frac{b}{n}\\right)^n e^{n-b}$。\n这得到：\n$$ q_0 = -2 \\left[ n \\ln\\left(\\frac{b}{n}\\right) + n-b \\right] = 2 \\left[ n \\ln\\left(\\frac{n}{b}\\right) - (n-b) \\right] $$\n\n为了计算在给定真实信号强度 $\\mu$ 下的*中位*显著性，我们使用 Asimov 数据集。在此过程中，观测数据 $n$ 被其在信号强度为 $\\mu$ 的假设下的期望值所替代，即 $n_A = \\mu s_0 + b$。由于发现灵敏度研究假设 $\\mu0$（且 $s_00$），我们有 $n_A  b$，因此可以使用 $q_0$ 的主要公式。将 $n_A$ 代替 $n$ 得到 Asimov 检验统计量 $q_{0,A}$：\n$$ q_{0,A}(\\mu) = 2 \\left[ (\\mu s_0 + b) \\ln\\left(\\frac{\\mu s_0 + b}{b}\\right) - ((\\mu s_0 + b) - b) \\right] $$\n$$ q_{0,A}(\\mu) = 2 \\left[ (\\mu s_0 + b) \\ln\\left(1 + \\frac{\\mu s_0}{b}\\right) - \\mu s_0 \\right] $$\n局部显著性 $Z_{\\mathrm{loc}}$ 通过 $Z_{\\mathrm{loc}} = \\sqrt{q_0}$ 与检验统计量相关联（这是 Wilks 定理的一个结果）。因此，中位局部显著性为：\n$$ Z_{\\mathrm{loc}}(\\mu) = \\sqrt{q_{0,A}(\\mu)} = \\sqrt{2 \\left[ (\\mu s_0 + b) \\ln\\left(1 + \\frac{\\mu s_0}{b}\\right) - \\mu s_0 \\right]} $$\n对于 $\\mu  0$，该函数随 $\\mu$ 单调递增。\n\n接下来，我们将局部显著性与全局显著性联系起来。显著性 $Z$ 是通过标准正态分布 $\\Phi(Z)$ 的尾部概率（p值）来定义的：\n$$ p = 1 - \\Phi(Z) $$\n其中 $p$ 是纯本底涨落产生一个至少与观测到的结果一样像信号的概率。其反向关系为 $Z = \\Phi^{-1}(1-p)$。\n\n“别处效应”通过使用有效独立试验次数 $M_{\\mathrm{eff}}$ 来解释。全局p值 $p_{\\mathrm{glob}}$ 通过 Bonferroni 校正与局部p值 $p_{\\mathrm{loc}}$ 相关联：\n$$ p_{\\mathrm{glob}} \\approx M_{\\mathrm{eff}} \\cdot p_{\\mathrm{loc}} $$\n这种近似对于小的p值是有效的，而高显著性搜寻正是这种情况。问题将 $M_{\\mathrm{eff}}$ 作为输入提供，这使得该关系成为定义性的。\n结合这些关系，我们得到了局部显著性和全局显著性之间的一个映射：\n$$ 1 - \\Phi(Z_{\\mathrm{glob}}) = M_{\\mathrm{eff}} \\left[ 1 - \\Phi(Z_{\\mathrm{loc}}) \\right] $$\n\n问题要求找到能达到全局显著性 $Z_{\\mathrm{glob}} \\ge 5$ 的最小 $\\mu$。我们求解边界情况，即 $Z_{\\mathrm{glob}} = 5$。\n首先，我们找到与 $5$ 的全局显著性相对应的所需局部显著性 $Z_{\\mathrm{loc}}^{\\mathrm{req}}$。\n1.  计算目标全局p值：$p_{\\mathrm{glob}}^{\\mathrm{target}} = 1 - \\Phi(5)$。\n2.  计算所需局部p值：$p_{\\mathrm{loc}}^{\\mathrm{req}} = p_{\\mathrm{glob}}^{\\mathrm{target}} / M_{\\mathrm{eff}}$。\n3.  计算所需局部显著性：$Z_{\\mathrm{loc}}^{\\mathrm{req}} = \\Phi^{-1}(1 - p_{\\mathrm{loc}}^{\\mathrm{req}})$。\n\n最后，我们必须找到能产生这个所需局部显著性的信号强度 $\\mu$。我们求解以下关于 $\\mu$ 的方程：\n$$ Z_{\\mathrm{loc}}(\\mu) = Z_{\\mathrm{loc}}^{\\mathrm{req}} $$\n将两边平方以简化数值搜索：\n$$ 2 \\left[ (\\mu s_0 + b) \\ln\\left(1 + \\frac{\\mu s_0}{b}\\right) - \\mu s_0 \\right] = (Z_{\\mathrm{loc}}^{\\mathrm{req}})^2 $$\n这是一个关于 $\\mu$ 的超越方程。由于左侧对于 $\\mu$ 是单调的，我们可以采用像二分法这样的稳健数值求根方法。我们寻求以下函数的根：\n$$ f(\\mu) = 2 \\left[ (\\mu s_0 + b) \\ln\\left(1 + \\frac{\\mu s_0}{b}\\right) - \\mu s_0 \\right] - (Z_{\\mathrm{loc}}^{\\mathrm{req}})^2 $$\n可以通过注意到 $f(0)  0$ 然后找到一个上界 $\\mu_{\\mathrm{high}}$ 使得 $f(\\mu_{\\mathrm{high}})  0$ 来确定 $\\mu$ 的搜索区间。$f(\\mu)=0$ 的根就是我们所寻求的最小信号强度 $\\mu^*$。相应的局部显著性是 $Z_{\\mathrm{loc}}(\\mu^*) = Z_{\\mathrm{loc}}^{\\mathrm{req}}$。\n\n对于每个测试用例 $(M_{\\mathrm{eff}}, b, s_0)$ 的步骤如下：\n1.  根据 $M_{\\mathrm{eff}}$ 和目标 $Z_{\\mathrm{glob}}=5$ 计算 $Z_{\\mathrm{loc}}^{\\mathrm{req}}$。\n2.  数值求解方程 $f(\\mu)=0$ 以找到 $\\mu^*$。\n3.  报告数对 $[\\mu^*, Z_{\\mathrm{loc}}^{\\mathrm{req}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the minimal signal strength mu for a 5-sigma global discovery\n    and the corresponding local significance, accounting for the look-elsewhere effect.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 100, 5),     # M_eff, b, s0\n        (100, 100, 5),\n        (10000, 1000, 10),\n        (500, 1, 1),\n        (1000, 10000, 50),\n    ]\n\n    results = []\n    \n    # The discovery threshold for global significance\n    Z_GLOB_TARGET = 5.0\n\n    def calculate_mu_and_z_loc(M_eff, b, s0):\n        \"\"\"\n        Calculates the minimal mu and corresponding Z_loc for a single case.\n        \"\"\"\n        # 1. Calculate the target global p-value for Z_glob = 5\n        # Use norm.sf (survival function, 1-cdf) for better precision in the far tail\n        p_glob_target = norm.sf(Z_GLOB_TARGET)\n\n        # 2. Calculate the required local p-value using the trials factor\n        # If M_eff makes p_loc >= 1, it's an unphysical scenario, but the code handles it.\n        p_loc_req = min(p_glob_target / M_eff, 1.0)\n\n        # 3. Calculate the required local significance from the local p-value\n        # Use norm.isf (inverse survival function) for precision\n        Z_loc_req = norm.isf(p_loc_req)\n\n        # 4. Define the function whose root we need to find.\n        # This function represents Z_loc_squared(mu) - Z_loc_req_squared = 0\n        Z_loc_req_sq = Z_loc_req**2\n        \n        def objective_func(mu):\n            if mu = 0:\n                return -Z_loc_req_sq\n            \n            s = mu * s0\n            \n            # The Asimov test statistic q_{0,A} is Z_loc_squared\n            # q_0A = 2 * ((s + b) * ln(1 + s/b) - s)\n            term1 = s + b\n            term2 = np.log1p(s / b) # log1p(x) is ln(1+x), more accurate for small x\n            q_0A = 2 * (term1 * term2 - s)\n            \n            return q_0A - Z_loc_req_sq\n\n        # 5. Use a bisection method to find the root mu.\n        # Bisection is robust due to the monotonicity of the objective function.\n        mu_low = 0.0\n        mu_high = 1.0\n        \n        # Find an upper bound for the search interval\n        # The objective function is monotonic, so g(mu_high) must be > 0\n        while objective_func(mu_high)  0:\n            mu_high *= 2.0\n            if mu_high > 1e6: # Safety break for pathological cases\n                raise RuntimeError(\"Failed to bracket root for mu.\")\n\n        # Bisection search\n        tolerance = 1e-9\n        max_iterations = 100\n        for _ in range(max_iterations):\n            mu_mid = (mu_low + mu_high) / 2\n            if mu_mid == mu_low or mu_mid == mu_high: # Reached precision limit\n                break\n            \n            g_mid = objective_func(mu_mid)\n            \n            if g_mid  0:\n                mu_low = mu_mid\n            else:\n                mu_high = mu_mid\n            \n            if (mu_high - mu_low)  tolerance:\n                break\n        \n        minimal_mu = (mu_low + mu_high) / 2\n        \n        return [minimal_mu, Z_loc_req]\n\n    for case in test_cases:\n        M_eff, b, s0 = case\n        mu, z_loc = calculate_mu_and_z_loc(M_eff, b, s0)\n        # Format the numbers to six decimal places as required.\n        results.append(f\"[{mu:.6f},{z_loc:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管解析公式非常强大，但许多复杂的分析依赖于蒙特卡洛（MC）模拟来估计全局p值。本练习深入探讨了这一实际情况，探索如何量化从有限数量的MC伪实验中得出的全局p值估计的统计不确定性。您将比较不同的统计技术，以报告一个不仅包含估计值，还包括其相应置信区间的稳健测量结果。",
            "id": "3539338",
            "problem": "考虑一个在计算高能物理学中广泛使用的“别处效应”（Look-Elsewhere Effect, LEE）的简化模型。您通过扫描 $K$ 个近似独立的位置来进行搜索。在每个位置，纯背景假设下的局部检验会产生一个局域 $p$ 值，在原假设下，该值被建模为从 $[0,1]$ 上的均匀分布中独立抽取的值。假设一项分析报告了一个最显著的局域观测值 $p_{\\text{loc}}$。将全局 $p$ 值定义为 $p_{\\text{glob}} = \\mathbb{P}(\\min\\{U_1,\\dots,U_K\\} \\le p_{\\text{loc}} \\mid H_0)$，其中 $U_i \\overset{\\text{iid}}{\\sim} \\mathrm{Uniform}(0,1)$，$H_0$ 表示纯背景假设。从此基础推导 $p_{\\text{glob}}$，并将其用作估计的目标。\n\n在实际搜索中，$p_{\\text{glob}}$ 是使用有限数量的蒙特卡洛（Monte Carlo, MC）伪实验来估计的，记为 $N_{\\text{MC}}$。对于每个伪实验，研究者会执行扫描并记录是否至少有一个位置产生了小于或等于 $p_{\\text{loc}}$ 的局域 $p$ 值。将发生这种情况的伪实验数量（在 $N_{\\text{MC}}$ 中）记为 $B$。通常的估计量是 $\\hat{p}_{\\text{glob}} = B / N_{\\text{MC}}$。由于 $N_{\\text{MC}}$ 是有限的，$\\hat{p}_{\\text{glob}}$ 存在必须量化的不确定性。\n\n您的任务如下，针对每个给定的测试用例 $(K, p_{\\text{loc}}, N_{\\text{MC}})$：\n\n1.  从第一性原理出发，计算由模型 $U_i \\overset{\\text{iid}}{\\sim} \\mathrm{Uniform}(0,1)$ 和定义 $p_{\\text{glob}} = \\mathbb{P}(\\min\\{U_1,\\dots,U_K\\} \\le p_{\\text{loc}} \\mid H_0)$ 所隐含的真实全局 $p$ 值 $p_{\\text{glob}}$。\n2.  通过从 $B \\sim \\mathrm{Binomial}(N_{\\text{MC}}, p_{\\text{glob}})$ 中抽取一个单次实现 $B$ 并计算相应的估计值 $\\hat{p}_{\\text{glob}} = B / N_{\\text{MC}}$，来模拟一个有限 $N_{\\text{MC}}$ 的研究。为保证可复现性，使用一个固定的随机数生成器种子，具体为种子值 $12345$。\n3.  使用两种方法量化由于有限的 $N_{\\text{MC}}$ 导致的 $\\hat{p}_{\\text{glob}}$ 的不确定性：\n    -   对 $N_{\\text{MC}}$ 个伯努利结果进行非参数自举（bootstrap）。通过使用经验成功概率 $\\hat{p}_{\\text{glob}}$ 和 $N_{\\text{MC}}$ 次试验对均值进行抽样自举复制来实现这一点，并计算 $\\hat{p}_{\\text{glob}}$ 的自举标准差 $s_{\\text{boot}}$。使用恰好 $R_{\\text{boot}} = 20000$ 个自举复制。\n    -   两种基于 $B$ 的二项模型的参数化近似方法：\n        (i) delta方法（正态）近似 $s_{\\text{norm}} \\approx \\sqrt{\\hat{p}_{\\text{glob}}(1-\\hat{p}_{\\text{glob}})/N_{\\text{MC}}}$，以及\n        (ii) 基于 Jeffreys 先验 $\\mathrm{Beta}(1/2, 1/2)$ 的 $p_{\\text{glob}}$ 的一个 $68.26894921370859\\%$ 等尾区间，即由 $\\mathrm{Beta}(B+1/2, N_{\\text{MC}}-B+1/2)$ 的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数给出的中心可信区间，其中 $\\alpha = 1 - 0.6826894921370859$。\n\n为每个测试用例报告以下六个量，均为浮点数：$p_{\\text{glob}}$、$\\hat{p}_{\\text{glob}}$、$s_{\\text{boot}}$、$s_{\\text{norm}}$、Jeffreys 区间下界和 Jeffreys 区间上界。\n\n待执行的测试套件，旨在探测一系列不同情况，包括中等的全局概率、可能导致 $B$ 很小的小概率情况，以及接近边界 $B=0$ 的场景：\n\n-   用例 A: $K = 50$, $p_{\\text{loc}} = 2.7 \\times 10^{-3}$, $N_{\\text{MC}} = 500$。\n-   用例 B: $K = 5000$, $p_{\\text{loc}} = 1.0 \\times 10^{-5}$, $N_{\\text{MC}} = 2000$。\n-   用例 C: $K = 200000$, $p_{\\text{loc}} = 1.0 \\times 10^{-7}$, $N_{\\text{MC}} = 1000$。\n-   用例 D: $K = 100$, $p_{\\text{loc}} = 1.0 \\times 10^{-6}$, $N_{\\text{MC}} = 50000$。\n\n您的程序必须生成单行输出，其中包含一个列表的列表形式的结果，每个内部列表对应一个测试用例，顺序为 A、B、C、D。每个内部列表必须是 `[p_glob, p_hat, s_boot, s_norm, jeffreys_lower, jeffreys_upper]` 的形式。所有浮点数必须四舍五入到六位有效数字。不涉及物理单位；所有概率都以小数形式报告，而不是百分比或分数。程序必须是自包含的，不需要任何输入，并且必须使用上面指定的固定随机种子以确保可复现性。",
            "solution": "该问题要求进行一个多步骤分析，涉及概率论、蒙特卡洛模拟和统计推断，以在一个简化的背景下评估“别处效应”（LEE）。解决方案的步骤是，首先推导全局 $p$ 值的解析形式，然后模拟一个有限统计量的实验，最后用三种不同的方法量化测量结果的统计不确定性。\n\n### 1. 解析全局 $p$ 值 ($p_{\\text{glob}}$)\n\n问题将全局 $p$ 值 $p_{\\text{glob}}$ 定义为，在纯背景假设 $H_0$ 下，观测到最小局域 $p$ 值小于或等于已发现值 $p_{\\text{loc}}$ 的概率。该模型假定有 $K$ 个独立的搜索位置，每个位置的局域 $p$ 值 $U_i$ 是从 $\\mathrm{Uniform}(0,1)$ 分布中独立抽取的值。\n数学上，这表示为：\n$$\np_{\\text{glob}} = \\mathbb{P}(\\min\\{U_1, \\dots, U_K\\} \\le p_{\\text{loc}})\n$$\n其中 $U_i \\overset{\\text{iid}}{\\sim} \\mathrm{Uniform}(0,1)$，对于 $i=1, \\dots, K$。\n\n为了计算这个概率，计算其互补概率更为方便：即最小局域 $p$ 值大于 $p_{\\text{loc}}$ 的概率。\n$$\n1 - p_{\\text{glob}} = \\mathbb{P}(\\min\\{U_1, \\dots, U_K\\}  p_{\\text{loc}})\n$$\n条件 $\\min\\{U_1, \\dots, U_K\\}  p_{\\text{loc}}$ 等价于所有单个 $U_i$ 都大于 $p_{\\text{loc}}$ 的条件。\n$$\n1 - p_{\\text{glob}} = \\mathbb{P}(U_1  p_{\\text{loc}} \\text{ and } U_2  p_{\\text{loc}} \\text{ and } \\dots \\text{ and } U_K  p_{\\text{loc}})\n$$\n由于 $U_i$ 是独立的，联合概率是各个概率的乘积：\n$$\n1 - p_{\\text{glob}} = \\prod_{i=1}^{K} \\mathbb{P}(U_i  p_{\\text{loc}})\n$$\n对于单个随机变量 $U \\sim \\mathrm{Uniform}(0,1)$，其累积分布函数（CDF）为 $F_U(x) = x$，对于 $x \\in [0,1]$。概率 $\\mathbb{P}(U  p_{\\text{loc}})$ 由 $1 - F_U(p_{\\text{loc}})$ 给出，简化为 $1 - p_{\\text{loc}}$。\n将此代回，我们得到：\n$$\n1 - p_{\\text{glob}} = (1 - p_{\\text{loc}})^K\n$$\n因此，全局 $p$ 值的精确解析表达式为：\n$$\np_{\\text{glob}} = 1 - (1 - p_{\\text{loc}})^K\n$$\n为了在 $p_{\\text{loc}}$ 非常接近 $0$ 时保持数值稳定性，最好使用 $p_{\\text{glob}} = -\\mathrm{expm1}(K \\cdot \\mathrm{log1p}(-p_{\\text{loc}}))$ 进行计算，其中 $\\mathrm{expm1}(x) = e^x - 1$ 且 $\\mathrm{log1p}(x) = \\ln(1+x)$。\n\n### 2. 蒙特卡洛估计 ($\\hat{p}_{\\text{glob}}$)\n\n在实际场景中，$p_{\\text{glob}}$ 是通过有限数量的伪实验 $N_{\\text{MC}}$ 来估计的。每个伪实验是一次试验，如果 $K$ 个位置中至少有一个产生的局域 $p$ 值小于或等于 $p_{\\text{loc}}$，则试验成功。根据定义，任何单次试验的成功概率为 $p_{\\text{glob}}$。\n\n在 $N_{\\text{MC}}$ 次独立试验中，成功的总次数 $B$ 服从二项分布：\n$$\nB \\sim \\mathrm{Binomial}(N_{\\text{MC}}, p_{\\text{glob}})\n$$\n问题要求通过从该分布中抽取 $B$ 的一个单次实现来模拟一次这样的研究。使用固定的随机数生成器种子（$12345$）以确保可复现性。由此产生的全局 $p$ 值的点估计为：\n$$\n\\hat{p}_{\\text{glob}} = \\frac{B}{N_{\\text{MC}}}\n$$\n\n### 3. 不确定性量化\n\n必须量化估计值 $\\hat{p}_{\\text{glob}}$ 的统计不确定性。我们采用三种指定的方法。\n\n#### a) 自举标准差 ($s_{\\text{boot}}$)\n问题指定了一个自举程序。尽管被称为“非参数”，但所描述的实现是一个参数化自举，因为它从由数据参数化的理论分布中进行重抽样，而不是从数据本身进行重抽样。该过程如下：\n1.  通过从由我们的估计值 $\\hat{p}_{\\text{glob}}$ 参数化的二项分布中抽样，生成 $R_{\\text{boot}} = 20000$ 个成功次数的自举复制 $B^{(r)}$：\n    $$\n    B^{(r)} \\sim \\mathrm{Binomial}(N_{\\text{MC}}, \\hat{p}_{\\text{glob}}) \\quad \\text{for } r = 1, \\dots, R_{\\text{boot}}\n    $$\n2.  对于每个复制，计算一个自举估计值 $\\hat{p}^{(r)}_{\\text{glob}} = B^{(r)} / N_{\\text{MC}}$。\n3.  自举标准差 $s_{\\text{boot}}$ 是所得的 $R_{\\text{boot}}$ 个估计值集合的标准差：\n    $$\n    s_{\\text{boot}} = \\sqrt{\\frac{1}{R_{\\text{boot}}} \\sum_{r=1}^{R_{\\text{boot}}} \\left(\\hat{p}^{(r)}_{\\text{glob}} - \\bar{p}_{\\text{boot}}\\right)^2}\n    $$\n    其中 $\\bar{p}_{\\text{boot}}$ 是自举估计值的均值。在 $R_{\\text{boot}} \\to \\infty$ 的极限下，$s_{\\text{boot}}$ 收敛到生成分布的标准差，即 $\\sqrt{\\hat{p}_{\\text{glob}}(1 - \\hat{p}_{\\text{glob}})/N_{\\text{MC}}}$。\n\n#### b) 正态近似标准差 ($s_{\\text{norm}}$)\n该方法依赖于二项分布的正态近似。估计量 $\\hat{p}_{\\text{glob}} = B/N_{\\text{MC}}$ 的方差是 $\\mathrm{Var}(\\hat{p}_{\\text{glob}}) = p_{\\text{glob}}(1-p_{\\text{glob}})/N_{\\text{MC}}$。标准误是该方差的平方根。delta方法通过用其最大似然估计 $\\hat{p}_{\\text{glob}}$ 替换未知的真实参数 $p_{\\text{glob}}$ 来近似此标准误。这产生了标准差的估计值：\n$$\ns_{\\text{norm}} = \\sqrt{\\frac{\\hat{p}_{\\text{glob}}(1 - \\hat{p}_{\\text{glob}})}{N_{\\text{MC}}}}\n$$\n这个量是自举估计 $s_{\\text{boot}}$ 期望近似的值。$s_{\\text{boot}}$ 和 $s_{\\text{norm}}$ 之间的任何差异都是由于有限的自举复制次数 $R_{\\text{boot}}$ 造成的。\n\n#### c) Jeffreys 可信区间\n这种贝叶斯方法用可信区间来量化不确定性。感兴趣的参数是 $p_{\\text{glob}}$。\n-   **先验:** 二项比例的 Jeffreys 先验是 $\\mathrm{Beta}(1/2, 1/2)$ 分布。其概率密度函数为 $f(p) \\propto p^{-1/2}(1-p)^{-1/2}$。\n-   **似然:** 在 $N_{\\text{MC}}$ 次试验中观测到 $B$ 次成功的似然由二项概率质量函数给出：$\\mathbb{P}(B | p_{\\text{glob}}) \\propto p_{\\text{glob}}^B (1 - p_{\\text{glob}})^{N_{\\text{MC}}-B}$。\n-   **后验:** 由于 Beta 先验和二项似然的共轭性，$p_{\\text{glob}}$ 的后验分布也是一个 Beta 分布：\n    $$\n    p_{\\text{glob}} | B, N_{\\text{MC}} \\sim \\mathrm{Beta}(B + 1/2, N_{\\text{MC}} - B + 1/2)\n    $$\n问题要求一个 $68.2689...\\%$ 的等尾可信区间，这对应于高斯分布的中心 $1\\sigma$ 区域。设此置信水平为 $1-\\alpha$，其中 $\\alpha = 1 - 0.6826894921370859$。区间的下界和上界是后验 Beta 分布的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数。\n-   下界 = $\\mathrm{Beta.ppf}(\\alpha/2; B+1/2, N_{\\text{MC}}-B+1/2)$\n-   上界 = $\\mathrm{Beta.ppf}(1-\\alpha/2; B+1/2, N_{\\text{MC}}-B+1/2)$\n这种方法特别稳健，即使观测到的计数 $B$ 为 $0$，也能提供一个非零区间。\n\n现在将继续实施，将这些公式应用于每个测试用例，使用指定的随机种子以保证可复现性，并将所有最终值四舍五入到六位有效数字。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import beta\n\ndef round_to_6sf(value):\n    \"\"\"Rounds a floating-point number to 6 significant figures.\"\"\"\n    if value == 0:\n        return 0.0\n    return float(f\"{value:.6g}\")\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n    # Seed the random number generator for reproducibility.\n    rng = np.random.default_rng(12345)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, p_loc, N_MC)\n        (50, 2.7e-3, 500),\n        (5000, 1.0e-5, 2000),\n        (200000, 1.0e-7, 1000),\n        (100, 1.0e-6, 50000),\n    ]\n\n    # Constants for calculations\n    R_BOOT = 20000\n    # This is scipy.stats.norm.cdf(1) - scipy.stats.norm.cdf(-1)\n    CONF_LEVEL = 0.6826894921370859\n    alpha = 1 - CONF_LEVEL\n    q_low = alpha / 2\n    q_high = 1 - alpha / 2\n\n    all_results = []\n\n    for K, p_loc, N_MC in test_cases:\n        # Task 1: Compute the true global p-value.\n        # Use log1p/expm1 for numerical stability with small p_loc.\n        p_glob = -np.expm1(K * np.log1p(-p_loc))\n\n        # Task 2: Emulate a finite-N_MC study.\n        # Draw a single realization B from the Binomial distribution.\n        B = rng.binomial(N_MC, p_glob)\n        p_hat_glob = B / N_MC\n\n        # Task 3: Quantify uncertainty on p_hat_glob.\n        \n        # a) Nonparametric (parametric as described) bootstrap.\n        # Draw R_BOOT replicates from Binomial(N_MC, p_hat_glob).\n        if p_hat_glob > 0:\n            bootstrap_reps = rng.binomial(N_MC, p_hat_glob, size=R_BOOT) / N_MC\n            s_boot = np.std(bootstrap_reps)\n        else:\n            # If p_hat_glob is 0, all bootstrap replicates are 0.\n            s_boot = 0.0\n\n        # b-i) Delta-method (normal) approximation.\n        s_norm = np.sqrt(p_hat_glob * (1 - p_hat_glob) / N_MC)\n\n        # b-ii) Jeffreys prior credible interval.\n        # Posterior is Beta(B + 1/2, N_MC - B + 1/2)\n        post_alpha = B + 0.5\n        post_beta_param = N_MC - B + 0.5\n        jeffreys_lower = beta.ppf(q_low, post_alpha, post_beta_param)\n        jeffreys_upper = beta.ppf(q_high, post_alpha, post_beta_param)\n\n        # Collate and round results to 6 significant figures.\n        case_results = [\n            round_to_6sf(p_glob),\n            round_to_6sf(p_hat_glob),\n            round_to_6sf(s_boot),\n            round_to_6sf(s_norm),\n            round_to_6sf(jeffreys_lower),\n            round_to_6sf(jeffreys_upper),\n        ]\n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[1,2,3],[4,5,6]]\n    result_str = \",\".join(map(str, all_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}