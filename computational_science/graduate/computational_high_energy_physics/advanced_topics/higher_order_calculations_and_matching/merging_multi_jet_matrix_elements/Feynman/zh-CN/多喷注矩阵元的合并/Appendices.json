{
    "hands_on_practices": [
        {
            "introduction": "在任何CKKW类型的合并算法中，最基础的一步是从固定阶矩阵元计算出的末态部分子出发，重建一个合理的级联历史。这个练习将指导你通过亲手实现$k_T$喷注算法来完成这一任务，该算法能够逆转部分子簇射的过程，从而为连接矩阵元和部分子簇射提供关键的输入信息。通过这个实践，你将掌握将一组部分子动量转化为有序分支历史的核心技能。",
            "id": "3522316",
            "problem": "在每个测试用例中，会给出四个无质量部分子 (parton)，由横向动量 $p_T$（单位为 $\\mathrm{GeV}$）、快度 $y$（无量纲）和方位角 $\\phi$（单位为弧度）指定。您的任务是从这些输入动量开始，实现纵向不变 $k_T$ 喷注算法，以计算完整的聚类序列，并重构 Catani–Krauss–Kuhn–Webber (CKKW) 合并所需的有序分支历史。在合并两个伪粒子时，请使用 $E$ 方案重组（四维矢量相加）。角度单位为弧度，所有与动量相关的量均应以 $\\mathrm{GeV}$ 为单位。喷注半径参数固定为 $R=0.6$。\n\n需要使用的基本定义：\n- 对于每个伪粒子 $i$，定义其横向动量 $p_{T,i} = \\sqrt{p_{x,i}^2 + p_{y,i}^2}$、方位角 $\\phi_i = \\mathrm{atan2}(p_{y,i}, p_{x,i})$ 和快度 $y_i = \\frac{1}{2}\\ln\\left(\\frac{E_i + p_{z,i}}{E_i - p_{z,i}}\\right)$。\n- 参数 $p=1$ 的纵向不变 $k_T$ 算法的配对距离为\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2},\n$$\n其中 $\\Delta R_{ij}^2 = (y_i - y_j)^2 + \\Delta\\phi_{ij}^2$，并且 $\\Delta\\phi_{ij}$ 通过标准环绕处理取值于 $[-\\pi,\\pi]$ 内。\n- 束流距离为\n$$\nd_{iB} = p_{T,i}^2.\n$$\n- 在每次迭代中，找出所有 $\\{d_{ij}\\}$ 和 $\\{d_{iB}\\}$ 中的最小距离。如果最小值是 $d_{ij}$，则使用四维矢量相加 $(E, \\vec{p}) \\rightarrow (E_i + E_j, \\vec{p}_i + \\vec{p}_j)$ 合并 $i$ 和 $j$，并记录此合并事件。如果最小值是 $d_{iB}$，则宣布 $i$ 为一个最终喷注并将其移除，不记录合并事件。\n- 持续此过程直到没有伪粒子剩下。\n- 对于 CKKW 历史，与 $i$ 和 $j$ 合并相关的分支尺度定义为 $k_T = \\sqrt{d_{ij}}$。将记录的合并事件按 $k_T$ 降序排列，并提供有序列表形式的分支历史。\n\n每个合并事件用列表 $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$ 表示，其中 $[\\text{orig}_i]$ 和 $[\\text{orig}_j]$ 是两个合并聚类中包含的原始部分子索引（每个测试用例的第一个部分子从 $0$ 开始）的列表，而 $k_T$ 是一个浮点数。按 $k_T$ 的降序排列合并事件。如果没有发生合并，则为该测试用例返回一个空列表。所有 $k_T$ 值表示为四舍五入到 $6$ 位小数。角度必须是弧度，所有动量分量必须是 $\\mathrm{GeV}$。对于无质量部分子，通过以下方式构建输入四维矢量：\n$$\nE = p_T\\,\\cosh(y),\\quad p_x = p_T\\cos(\\phi),\\quad p_y = p_T\\sin(\\phi),\\quad p_z = p_T\\,\\sinh(y).\n$$\n\n测试套件（每个测试用例是四个三元组 $(p_T, y, \\phi)$ 的列表）：\n- 测试用例 $1$（一般聚类行为）：\n  $[(50.0,\\,0.1,\\,0.0),\\,(48.0,\\,0.12,\\,0.15),\\,(40.0,\\,1.5,\\,2.0),\\,(30.0,\\,-1.2,\\,-2.5)]$.\n- 测试用例 $2$（在 $\\pm\\pi$ 附近的方位角环绕处理）：\n  $[(35.0,\\,0.0,\\,3.10),\\,(33.0,\\,0.0,\\,-3.08),\\,(20.0,\\,0.5,\\,1.0),\\,(10.0,\\,-0.5,\\,-1.0)]$.\n- 测试用例 $3$（软粒子通过束流距离立即成为喷注）：\n  $[(100.0,\\,0.0,\\,0.5),\\,(80.0,\\,0.3,\\,-0.2),\\,(5.0,\\,2.0,\\,1.0),\\,(60.0,\\,-1.0,\\,2.0)]$.\n- 测试用例 $4$（近共线的软粒子对）：\n  $[(15.0,\\,0.2,\\,0.2),\\,(14.0,\\,0.201,\\,0.201),\\,(50.0,\\,-2.0,\\,0.5),\\,(45.0,\\,2.0,\\,-0.5)]$.\n\n您的程序应生成单行输出，其中包含一个以逗号分隔、并用方括号括起来的列表形式的结果，其中每个元素按上述顺序对应一个测试用例。每个元素必须是为该测试用例指定的有序合并事件列表。例如，四个测试用例的有效输出形式为\n$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$,\n其中每个内部列表是相应测试用例的有序分支历史。不应打印任何额外文本。",
            "solution": "该问题是有效的，要求实现纵向不变 $k_T$ 喷注聚类算法，以确定由四个无质量部分子组成的集合的 CKKW 合并历史。解决方案的结构是一个分步的算法流程，随后是 Python 实现。\n\n**基于原理的算法设计**\n\n解决方案的核心是一个迭代算法，该算法将初始的部分子列表逐步分组形成喷注。该过程由一个距离度量控制，此度量在每一步确定动量空间中哪些粒子是“最近”的。\n\n**1. 状态表示：伪粒子**\n我们首先为每个部分子或中间聚类定义一个计算表示，我们称之为“伪粒子”。每个伪粒子对象封装了两个关键信息：\n- 其四维动量 $P^\\mu = (E, p_x, p_y, p_z)$，以一个 $4$ 分量矢量的形式存储。所有后续的运动学属性都由此派生。\n- 一个由已合并形成此伪粒子的、从 $0$ 开始索引的原始部分子组成的列表。\n\n最初，对于每个具有运动学参数 $(p_{T,i}, y_i, \\phi_i)$ 的输入部分子 $i$，我们使用无质量粒子的关系构建其四维动量：\n$$\n\\begin{aligned}\nE_i = p_{T,i}\\,\\cosh(y_i) \\\\\np_{x,i} = p_{T,i}\\cos(\\phi_i) \\\\\np_{y,i} = p_{T,i}\\sin(\\phi_i) \\\\\np_{z,i} = p_{T,i}\\,\\sinh(y_i)\n\\end{aligned}\n$$\n这将创建初始的伪粒子集合，每个伪粒子包含一个单一的原始部分子索引。根据任何伪粒子的四维动量 $P^\\mu=(E, p_x, p_y, p_z)$，可按需重新计算其横向动量 $p_T$、快度 $y$ 和方位角 $\\phi$：\n$$\np_T = \\sqrt{p_x^2 + p_y^2}\n$$\n$$\ny = \\frac{1}{2}\\ln\\left(\\frac{E + p_z}{E - p_z}\\right)\n$$\n$$\n\\phi = \\mathrm{atan2}(p_y, p_x)\n$$\n\n**2. 迭代聚类循环**\n算法在一个循环中进行，直到活动伪粒子列表为空。在每次迭代中，都基于一组计算出的距离做出单个决策。\n\n**2a. 距离计算**\n为当前 $N$ 个伪粒子的集合计算两种类型的距离：\n- **配对距离 ($d_{ij}$)**：对于每对唯一的伪粒子 $(i, j)$，计算一个距离。该度量量化了它们在动量空间中的分离程度。对于参数 $p=1$ 的纵向不变 $k_T$ 算法，公式为：\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2}\n$$\n其中 $R=0.6$ 是喷注半径参数，$\\Delta R_{ij}^2$ 是快度-方位角平面上的平方分离：\n$$\n\\Delta R_{ij}^2 = (y_i - y_j)^2 + (\\Delta\\phi_{ij})^2\n$$\n方位角差 $\\Delta\\phi_{ij} = \\phi_i - \\phi_j$ 必须仔细处理以遵循其周期性，确保其值在区间 $[-\\pi, \\pi]$ 内。\n\n- **束流距离 ($d_{iB}$)**：对于每个伪粒子 $i$，计算一个束流距离。该度量代表了粒子的“硬度”及其成为独立喷注而非更大喷注一部分的倾向。其定义为：\n$$\nd_{iB} = p_{T,i}^2\n$$\n\n**2b. 寻找最小距离**\n计算完所有 $N(N-1)/2$ 个配对距离 $\\{d_{ij}\\}$ 和所有 $N$ 个束流距离 $\\{d_{iB}\\}$ 后，算法确定全局最小值 $d_{\\min} = \\min(\\min_{\\{i,j\\}} d_{ij}, \\min_k d_{kB})$。\n\n**2c. 操作：合并或最终化**\n所采取的操作取决于 $d_{\\min}$ 是配对距离还是束流距离：\n- **如果 $d_{\\min} = d_{ij}$ (配对合并):** 这表示粒子 $i$ 和 $j$ 是最接近的一对。它们被合并成一个新的、单一的伪粒子。\n    - **重组：** $E$ 方案重组规则规定四维动量相加：$P_{new}^\\mu = P_i^\\mu + P_j^\\mu$。原始部分子索引的列表被连接起来：$\\text{orig}_{new} = \\text{orig}_i \\cup \\text{orig}_j$。\n    - **记录：** 此合并事件是 CKKW 历史中的一个分支。我们将其记录为一个三元组 $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$，其中 $[\\text{orig}_i]$ 和 $[\\text{orig}_j]$ 是原始索引的排序列表，而 $k_T = \\sqrt{d_{ij}}$ 是分裂的特征横向动量尺度。\n    - **状态更新：** 粒子 $i$ 和 $j$ 从活动列表中移除，新的合并粒子被添加进去。\n\n- **如果 $d_{\\min} = d_{iB}$ (最终化喷注):** 这表示粒子 $i$ 比它与任何其他粒子的“距离”更“硬”（即具有更大的 $p_T^2$）。因此它被宣布为一个末态喷注。\n    - **状态更新：** 粒子 $i$ 从活动列表中移除。此操作不记录合并事件。\n\n**3. 终止与输出生成**\n当没有伪粒子剩下时，循环终止。最后一步是准备输出。收集到的合并事件列表按分支尺度 $k_T$ 的降序排列。这个排序后的列表代表了 CKKW 分支历史，显示了从最硬到最软的分裂序列。最终输出中的 $k_T$ 值按要求四舍五入到 $6$ 位小数。如果在整个过程中没有发生合并（例如，所有初始部分子都立即被宣布为喷注），则为该测试用例返回一个空列表。",
            "answer": "```python\nimport numpy as np\n\nclass PseudoParticle:\n    \"\"\"A class to represent a pseudo-particle in the jet clustering process.\"\"\"\n    def __init__(self, E, px, py, pz, original_indices):\n        \"\"\"\n        Initializes a pseudo-particle with its 4-momentum and original parton indices.\n        \n        Args:\n            E (float): Energy.\n            px (float): Momentum in x-direction.\n            py (float): Momentum in y-direction.\n            pz (float): Momentum in z-direction.\n            original_indices (list[int]): List of 0-indexed original partons.\n        \"\"\"\n        self.four_vector = np.array([E, px, py, pz], dtype=np.float64)\n        # Keep original indices sorted for canonical representation\n        self.original_indices = sorted(original_indices)\n        self.update_kinematics()\n\n    def update_kinematics(self):\n        \"\"\"Calculates pT, rapidity (y), and azimuth (phi) from the 4-momentum.\"\"\"\n        E, px, py, pz = self.four_vector\n        self.pT = np.sqrt(px**2 + py**2)\n        \n        if self.pT  1e-12: # Effectively zero transverse momentum\n            self.phi = 0.0\n            # Rapidity is singular for massless particles with pT=0.\n            # Handle this case, although unlikely with E-scheme recombination.\n            if abs(E - abs(pz))  1e-9:\n                self.y = np.sign(pz) * 1e9 if pz != 0 else 0.0\n            else:\n                self.y = 0.5 * np.log((E + pz) / (E - pz))\n        else:\n            self.phi = np.arctan2(py, px)\n            # This formula is robust for massive particles (E-pz > 0 for E^2 > p^2)\n            self.y = 0.5 * np.log((E + pz) / (E - pz))\n\ndef run_kt_algorithm(initial_partons_data, R):\n    \"\"\"\n    Implements the longitudinally invariant kt jet algorithm.\n\n    Args:\n        initial_partons_data (list[tuple]): List of (pT, y, phi) for each initial parton.\n        R (float): The jet radius parameter.\n\n    Returns:\n        list: The ordered list of merge events, sorted by descending kT.\n    \"\"\"\n    particles = []\n    for i, (pT, y, phi) in enumerate(initial_partons_data):\n        E = pT * np.cosh(y)\n        px = pT * np.cos(phi)\n        py = pT * np.sin(phi)\n        pz = pT * np.sinh(y)\n        particles.append(PseudoParticle(E, px, py, pz, [i]))\n\n    merges = []\n    R2 = R**2\n\n    while particles:\n        num_particles = len(particles)\n        if num_particles == 0:\n            break\n\n        min_dist = float('inf')\n        min_type = None\n        min_indices = None\n\n        # Calculate pairwise distances (d_ij)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                p_i, p_j = particles[i], particles[j]\n                \n                delta_y = p_i.y - p_j.y\n                delta_phi = p_i.phi - p_j.phi\n                # Wrap delta_phi to the range [-pi, pi]\n                delta_phi = (delta_phi + np.pi) % (2 * np.pi) - np.pi\n                \n                delta_R2 = delta_y**2 + delta_phi**2\n                d_ij = min(p_i.pT**2, p_j.pT**2) * delta_R2 / R2\n\n                if d_ij  min_dist:\n                    min_dist = d_ij\n                    min_type = 'pair'\n                    min_indices = (i, j)\n        \n        # Calculate beam distances (d_iB)\n        for i in range(num_particles):\n            d_iB = particles[i].pT**2\n            if d_iB  min_dist:\n                min_dist = d_iB\n                min_type = 'beam'\n                min_indices = (i,)\n\n        # Perform the action corresponding to the minimum distance\n        if min_type == 'pair':\n            i, j = min_indices\n            \n            # Ensure i  j for easier list removal\n            if i > j: i, j = j, i\n            \n            p_i, p_j = particles[i], particles[j]\n\n            # Record the merge event for CKKW history\n            kT = np.sqrt(min_dist)\n            orig_i, orig_j = p_i.original_indices, p_j.original_indices\n            \n            # Ensure canonical ordering of original index lists for deterministic output\n            if orig_i > orig_j: orig_i, orig_j = orig_j, orig_i\n            \n            merges.append([orig_i, orig_j, kT])\n\n            # Merge particles using E-scheme recombination (4-vector addition)\n            new_4vec = p_i.four_vector + p_j.four_vector\n            new_orig_indices = p_i.original_indices + p_j.original_indices\n            new_particle = PseudoParticle(new_4vec[0], new_4vec[1], new_4vec[2], new_4vec[3], new_orig_indices)\n\n            # Remove old particles (higher index first) and add the new one\n            del particles[j]\n            del particles[i]\n            particles.append(new_particle)\n            \n        elif min_type == 'beam':\n            i = min_indices[0]\n            del particles[i] # Declare particle as a jet and remove\n        elif num_particles == 1: # Handle the last remaining particle\n            del particles[0]\n        else: # Should not occur\n            break\n\n    # Sort merges by k_T in descending order\n    merges.sort(key=lambda x: x[2], reverse=True)\n    \n    # Format the final list with rounded k_T\n    formatted_merges = [[m[0], m[1], round(m[2], 6)] for m in merges]\n        \n    return formatted_merges\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        [(50.0, 0.1, 0.0), (48.0, 0.12, 0.15), (40.0, 1.5, 2.0), (30.0, -1.2, -2.5)],\n        # Test Case 2\n        [(35.0, 0.0, 3.10), (33.0, 0.0, -3.08), (20.0, 0.5, 1.0), (10.0, -0.5, -1.0)],\n        # Test Case 3\n        [(100.0, 0.0, 0.5), (80.0, 0.3, -0.2), (5.0, 2.0, 1.0), (60.0, -1.0, 2.0)],\n        # Test Case 4\n        [(15.0, 0.2, 0.2), (14.0, 0.201, 0.201), (50.0, -2.0, 0.5), (45.0, 2.0, -0.5)],\n    ]\n    \n    JET_RADIUS = 0.6\n    \n    all_results = []\n    for case in test_cases:\n        result = run_kt_algorithm(case, JET_RADIUS)\n        all_results.append(result)\n    \n    # Convert the list of results to a string, removing spaces for a compact format.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "获得了喷注聚类历史后，下一个挑战是如何将固定阶计算与全阶部分子簇射无缝地连接起来。这个练习通过一个简化但功能强大的模型，来演示CKKW-L方案中的核心机制——截断（veto）。你将利用Sudakov因子来计算事件的接受概率，从而理解算法如何避免重复计算部分子辐射，这是确保合并结果物理一致性的关键一步。",
            "id": "3522333",
            "problem": "给定一个简化的计算模型，用于研究多喷注过程中 Catani-Krauss-Kuhn-Webber with Lönnblad 变体 (CKKW-L) 的匹配方法。考虑产生一个 $Z$ 玻色子和两个部分子的质子-质子 (pp) 碰撞，记为 $pp \\to Z + 2$ partons。在 CKKW-L 框架中，来自矩阵元产生器的每个事件都被赋予聚类节点标度，这些标度被解释为色腿的簇射起始标度。然后，从每个节点标度向下到匹配标度执行一个带否决的部分子簇射，如果任何簇射辐射的演化标度高于匹配标度，则该事件被拒绝。您的任务是实现一个程序，针对指定的事件样本和匹配标度，计算被 CKKW-L 否决方法拒绝的事件比例。\n\n基本和建模假设：\n- 假设量子色动力学 (QCD) 的软-共线辐射，其演化变量等同于一个类横动量标度 $t$（单位为 $\\mathrm{GeV}$）。单位 $\\ln t$ 的辐射率的领头近似由以下公式建模：\n$$ \\mathrm{d} \\mathcal{P} \\approx \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t}, $$\n其中 $C$ 是一个色因子。对于夸克腿，取 $C = C_F = \\frac{4}{3}$。\n- 对强耦合常数使用单圈跑动，其中有 $n_f$ 个活性味，并在 $\\Lambda_{\\mathrm{QCD}}$ 处有朗道极点：\n$$ \\alpha_s(Q) = \\frac{4 \\pi}{\\beta_0 \\ln\\left(\\frac{Q^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2 n_f}{3}. $$\n- 在一个上标度 $t_{\\mathrm{upper}}$ 和一个下标度 $t_{\\mathrm{lower}}$ 之间的无辐射概率（Sudakov 形式因子）是\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\exp\\left(- \\int_{t_{\\mathrm{lower}}}^{t_{\\mathrm{upper}}} \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t} \\right). $$\n对于上述单圈 $\\alpha_s$，该积分得出解析表达式\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\!\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\!\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}}, \\quad \\text{for } t_{\\mathrm{upper}}  t_{\\mathrm{lower}}  \\Lambda_{\\mathrm{QCD}}, $$\n并且如果 $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$，则 $\\Delta = 1$。\n- 对于一个 $pp \\to Z + 2$ partons 事件，我们为两个色腿建模，每个色腿从其各自的节点标度 $t_i$（单位为 $\\mathrm{GeV}$）开始。如果两个腿都没有在匹配标度 $t_{\\mathrm{merge}}$（单位为 $\\mathrm{GeV}$）之上发生辐射，则该事件被带否决的簇射接受。在简化的解析模型中，事件的接受概率是 Sudakov 因子的乘积\n$$ P_{\\mathrm{acc}} = \\prod_{i=1}^{2} \\Delta(t_i, t_{\\mathrm{merge}}), \\quad \\text{with the convention } \\Delta(t_i, t_{\\mathrm{merge}}) = 1 \\text{ if } t_i \\le t_{\\mathrm{merge}}. $$\n拒绝概率是 $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$。\n- 对于所有色腿，您必须使用 $n_f = 5$、$\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$ 和 $C = C_F = \\frac{4}{3}$。所有能量标度都必须以 $\\mathrm{GeV}$ 为单位处理。\n\n您的程序必须为下面的每个测试用例计算被 CKKW-L 否决方法拒绝的事件比例：\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} \\left( 1 - \\prod_{i=1}^{2} \\Delta(t_{e,i}, t_{\\mathrm{merge}}) \\right), $$\n其中 $t_{e,i}$ 是事件 $e$ 中腿 $i$ 的节点标度，$N$ 是该测试用例样本中的事件数。\n\n测试套件：\n- 测试用例 1（正常路径）：匹配标度 $t_{\\mathrm{merge}} = 15~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本，其节点标度（单位为 $\\mathrm{GeV}$）如下：\n    - 事件 1：$[35.0, 25.0]$\n    - 事件 2：$[40.0, 18.0]$\n    - 事件 3：$[22.0, 21.0]$\n    - 事件 4：$[30.0, 16.0]$\n    - 事件 5：$[15.0, 50.0]$\n- 测试用例 2（包含等于和低于截断值腿的边界条件）：匹配标度 $t_{\\mathrm{merge}} = 20~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本：\n    - 事件 1：$[20.0, 50.0]$\n    - 事件 2：$[20.0, 20.0]$\n    - 事件 3：$[25.0, 20.0]$\n    - 事件 4：$[21.0, 19.5]$\n    - 事件 5：$[100.0, 35.0]$\n- 测试用例 3（低匹配标度的近红外边缘情况）：匹配标度 $t_{\\mathrm{merge}} = 0.5~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本：\n    - 事件 1：$[30.0, 25.0]$\n    - 事件 2：$[80.0, 60.0]$\n    - 事件 3：$[22.0, 21.0]$\n    - 事件 4：$[100.0, 35.0]$\n    - 事件 5：$[15.0, 50.0]$\n\n答案规范：\n- 所有计算必须以 $\\mathrm{GeV}$ 为单位。\n- 对于每个测试用例，将比例 $R$ 作为区间 $[0, 1]$ 内的浮点数输出。\n- 您的程序应生成单行输出，其中包含三个结果，格式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是相应测试用例的浮点数结果。",
            "solution": "用户提供的问题是有效的。这是一个来自计算高能物理领域的、定义明确且具有科学依据的问题。所有必要的数据、常数和公式均已提供，不存在内部矛盾或歧义。该模型虽然经过简化，但基于量子色动力学（QCD）的既定原则，特别是 CKKW-L 匹配程序。\n\n任务是为几个模拟的 $pp \\to Z + 2$ 部分子事件样本计算平均拒绝比例 $R$。拒绝比例是单个事件拒绝概率 $P_{\\mathrm{rej}, e}$ 在 $N$ 个事件样本上的平均值：\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} P_{\\mathrm{rej}, e} $$\n事件的拒绝与否由带否决的部分子簇射决定。只有当一个事件的色腿在其各自的起始标度 $t_i$ 和一个共同的匹配标度 $t_{\\mathrm{merge}}$ 之间没有发生部分子辐射时，该事件才被接受。两个标度之间无辐射的概率由 Sudakov 形式因子 $\\Delta$ 给出。对于指定的具有 2 个色腿（起始标度为 $t_1$ 和 $t_2$）的过程，假设辐射是独立的，则事件的总接受概率是各个无辐射概率的乘积：\n$$ P_{\\mathrm{acc}} = \\Delta(t_1, t_{\\mathrm{merge}}) \\cdot \\Delta(t_2, t_{\\mathrm{merge}}) $$\n因此，单个事件的拒绝概率是 $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$。\n\n此计算的核心部分是 Sudakov 形式因子 $\\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}})$。问题提供了其解析表达式，该表达式由强耦合常数 $\\alpha_s(t)$ 的单圈跑动推导而来：\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}} $$\n该公式适用于条件 $t_{\\mathrm{upper}}  t_{\\mathrm{lower}}  \\Lambda_{\\mathrm{QCD}}$。根据 CKKW-L 规则的规定，如果起始标度 $t_{\\mathrm{upper}}$ 已经等于或低于匹配标度 $t_{\\mathrm{lower}}$，则不存在用于簇射的区间。在这种情况下，不可能发生可被否决的辐射，无辐射概率为 1，即当 $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$ 时 $\\Delta = 1$。\n\n为了实现计算，我们首先确定所需物理常数的数值。\n活性夸克味的数目给定为 $n_f = 5$。\nQCD 标度参数指定为 $\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$。\n夸克腿（这里所指的部分子类型）的色因子是 Casimir 不变量 $C = C_F = \\frac{4}{3}$。\n使用这些输入，我们计算 QCD β 函数的领头阶系数：\n$$ \\beta_0 = 11 - \\frac{2 n_f}{3} = 11 - \\frac{2 \\cdot 5}{3} = 11 - \\frac{10}{3} = \\frac{23}{3} $$\n现在可以将 Sudakov 公式中的指数预先计算为一个单一的常数值：\n$$ \\frac{2 C}{\\beta_0} = \\frac{2 \\cdot \\frac{4}{3}}{\\frac{23}{3}} = \\frac{\\frac{8}{3}}{\\frac{23}{3}} = \\frac{8}{23} $$\n为提高数值稳定性和计算效率，可以利用对数性质 $\\ln(x^2) = 2 \\ln(x)$ 来简化 Sudakov 公式：\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{2 \\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{2 \\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} = \\left( \\frac{\\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{\\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} $$\n这将是实现时采用的形式。\n\n解决每个测试用例的算法步骤如下：\n1. 对于由一个匹配标度 $t_{\\mathrm{merge}}$ 和一个包含 $N$ 个事件的样本所定义的每个测试用例，初始化一个列表来存储每个事件的拒绝概率。\n2. 遍历样本中的每个事件 $e$。每个事件由两个节点标度 $t_{e,1}$ 和 $t_{e,2}$ 描述。\n3. 对于当前事件，计算其接受概率 $P_{\\mathrm{acc}, e}$。\n    a. 对第一条腿，计算 Sudakov 因子 $\\Delta_1 = \\Delta(t_{e,1}, t_{\\mathrm{merge}})$。计算时首先检查是否 $t_{e,1} \\le t_{\\mathrm{merge}}$。如果此条件为真，则 $\\Delta_1 = 1$。否则，使用解析公式。\n    b. 类似地，对第二条腿，计算其 Sudakov 因子 $\\Delta_2 = \\Delta(t_{e,2}, t_{\\mathrm{merge}})$。\n    c. 事件的总接受概率是独立腿的因子的乘积：$P_{\\mathrm{acc}, e} = \\Delta_1 \\cdot \\Delta_2$。\n4. 计算事件的拒绝概率为 $P_{\\mathrm{rej}, e} = 1 - P_{\\mathrm{acc}, e}$。\n5. 存储该值 $P_{\\mathrm{rej}, e}$。\n6. 遍历完样本中所有 $N$ 个事件后，通过计算所有存储的 $P_{\\mathrm{rej}, e}$ 值的算术平均值来得出该测试用例的最终拒绝比例 $R$。\n7. 对所有三个测试用例重复此过程，并收集所得的 $R$ 值作为最终输出。\n\n这个分步逻辑在提供的 Python 程序中得以实现。一个专用函数用于计算 Sudakov 因子，并正确处理边界条件。另一个函数负责组织计算整个事件样本的平均拒绝比例。主函数 `solve` 设置测试用例数据，为每个用例调用计算逻辑，并将结果格式化为指定精确的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define global constants based on the problem statement.\n# All scales are in GeV.\nLAMBDA_QCD = 0.2  # QCD scale parameter\nN_F = 5          # Number of active flavors\nC_F = 4.0 / 3.0  # Casimir color factor for quarks\n\n# Pre-calculate derived constants for efficiency.\nBETA_0 = 11.0 - (2.0 * N_F / 3.0)  # Leading-order beta function coefficient\nSUDOKOV_EXPONENT = (2.0 * C_F) / BETA_0   # Exponent for the Sudakov form factor\n\ndef sudakov(t_upper, t_lower):\n    \"\"\"\n    Calculates the Sudakov form factor (no-emission probability)\n    between an upper scale t_upper and a lower scale t_lower.\n\n    Args:\n        t_upper (float): The shower starting scale (node scale).\n        t_lower (float): The lower scale cutoff (merging scale).\n\n    Returns:\n        float: The no-emission probability Delta(t_upper, t_lower).\n    \"\"\"\n    # Per the CKKW-L convention, if the starting scale is at or below the\n    # merging scale, there is no phase space for a vetoable emission.\n    # The no-emission probability is therefore 1.\n    if t_upper = t_lower:\n        return 1.0\n\n    # The analytic formula is valid for scales > Lambda_QCD. Here we apply\n    # the simplified and more numerically stable version of the formula.\n    log_arg_lower = t_lower / LAMBDA_QCD\n    log_arg_upper = t_upper / LAMBDA_QCD\n\n    base = np.log(log_arg_lower) / np.log(log_arg_upper)\n    \n    return base ** SUDOKOV_EXPONENT\n\ndef calculate_rejection_fraction(t_merge, event_sample):\n    \"\"\"\n    Calculates the average rejection fraction for a sample of events.\n\n    Args:\n        t_merge (float): The merging scale.\n        event_sample (list of lists of floats): A list of events, where each\n                                                event is a list of node scales.\n\n    Returns:\n        float: The average rejection fraction for the sample.\n    \"\"\"\n    rejection_probabilities = []\n    for node_scales in event_sample:\n        # For each event, calculate acceptance probability as the product of\n        # Sudakov factors for each of its two colored legs.\n        p_acc = 1.0\n        for t_node in node_scales:\n            p_acc *= sudakov(t_node, t_merge)\n        \n        # The rejection probability is 1 - acceptance probability.\n        p_rej = 1.0 - p_acc\n        rejection_probabilities.append(p_rej)\n    \n    # The rejection fraction is the average of rejection probabilities over the sample.\n    return np.mean(rejection_probabilities)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (merging_scale, list_of_events)\n    # Each event is a list of its node scales.\n    test_cases = [\n        (15.0, [\n            [35.0, 25.0],\n            [40.0, 18.0],\n            [22.0, 21.0],\n            [30.0, 16.0],\n            [15.0, 50.0]\n        ]),\n        (20.0, [\n            [20.0, 50.0],\n            [20.0, 20.0],\n            [25.0, 20.0],\n            [21.0, 19.5],\n            [100.0, 35.0]\n        ]),\n        (0.5, [\n            [30.0, 25.0],\n            [80.0, 60.0],\n            [22.0, 21.0],\n            [100.0, 35.0],\n            [15.0, 50.0]\n        ])\n    ]\n\n    results = []\n    for t_merge, event_sample in test_cases:\n        rejection_fraction = calculate_rejection_fraction(t_merge, event_sample)\n        results.append(rejection_fraction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个合格的合并算法必须保证总截面的守恒，即所有末态喷注数目的分截面之和必须等于总的遍举截面，这一性质被称为幺正性。这个实践构建了一个玩具模型，用以模拟合并过程中的不完美之处如何导致对幺正性的破坏。通过计算与$1$的偏离，你将学会如何定量地检验合并算法的这一基本理论要求，这是评估和调试任何实际合并方案的重要诊断工具。",
            "id": "3522327",
            "problem": "考虑在质心能量为 $Q$ 时，电子-正电子湮灭为强子的过程，$e^+ e^- \\to$ 强子。在量子色动力学 (QCD) 中，对于给定的喷注分辨或合并尺度 $Q_{\\text{cut}}$，专属的 $n$ 喷注产率可以在领头对数近似 (LLA) 下进行建模，方法是将高于 $Q_{\\text{cut}}$ 的辐射视为一个泊松过程，其平均辐射数 $\\lambda(Q,Q_{\\text{cut}})$ 由积分形式的强耦合常数确定。在多喷注矩阵元 (ME) 与部分子簇射 (PS) 的幺正合并中，所有专属 $n$ 喷注截面之和等于总遍举截面。您的任务是使用一个合并样本来演示幺正性检验：将专属的 $n$ 喷注产率对 $n$ 求和，并与总截面（归一化为1）进行比较，并在一个受控的玩具模型中量化偏差。\n\n基本定义与假设：\n- 使用领头对数近似 (LLA)，假设辐射是独立的，并使用 Sudakov 形状因子表示无辐射概率。\n- 高于 $Q_{\\text{cut}}$ 的可分辨辐射数 $m$ 服从均值为 $\\lambda$ 的泊松分布，而专属的 $n$ 喷注末态精确对应于 $m = n - 2$ 次辐射。\n- 使用归一化截面，即设总遍举截面为 $\\sigma_{\\text{tot}} = 1$（无量纲）。\n- 平均辐射数 $\\lambda(Q,Q_{\\text{cut}})$ 定义为\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu,\n$$\n其中 $C_F = \\frac{4}{3}$ 是 $\\mathrm{SU}(3)$ 基础表示的二次卡西米尔算符，强耦合常数 $\\alpha_s(\\mu)$ 服从单圈跑动，\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2}{3} n_f, \\quad n_f = 5, \\quad \\Lambda = 0.2 \\ \\mathrm{GeV}.\n$$\n假设 $Q  Q_{\\text{cut}}  \\Lambda$，以确保所有对数都有定义。\n\n专属概率：\n- 高于 $Q_{\\text{cut}}$ 恰好有 $m$ 次辐射的概率是\n$$\nP(m; \\lambda) = \\frac{e^{-\\lambda} \\lambda^m}{m!}.\n$$\n- 专属的 $n$ 喷注产率为 $R_n = P(n-2; \\lambda)$，其中 $n \\ge 2$。\n\n合并样本模型：\n- 假设矩阵元最高合并到 $N_{\\mathrm{ME}}$ 个喷注。这意味着最多 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ 次辐射通过基于 ME 的重加权进行修正，而 $m  m_{\\mathrm{ME}}$ 的辐射仍然由 PS 描述。\n- 通过为 ME 修正的多重数引入一个权重因子来模拟残余的合并扭曲：\n$$\nw(m) = 1 + \\varepsilon \\, g(m), \\quad \\text{对于 } m \\le m_{\\mathrm{ME}},\n$$\n对于 $m  m_{\\mathrm{ME}}$，则 $w(m) = 1$。这里 $\\varepsilon$ 是一个可调的实参数，用于控制扭曲的幅度，而 $g(m)$ 是一个固定的形状函数，用于捕捉典型的 ME-PS 张力模式。使用以下显式函数形式\n$$\ng(m) = \\exp\\!\\left(-\\frac{m}{m_0}\\right) - c, \\quad m_0 = 1.5, \\quad c = 0.4,\n$$\n仅适用于 $m \\le m_{\\mathrm{ME}}$，对于 $m  m_{\\mathrm{ME}}$ 则 $g(m)=0$。\n\n幺正性检验：\n- 合并后的专属和 $S$ 为\n$$\nS(Q,Q_{\\text{cut}},N_{\\mathrm{ME}},\\varepsilon) = \\sum_{m=0}^{\\infty} P(m;\\lambda(Q,Q_{\\text{cut}})) \\, w(m).\n$$\n- 理想极限下的幺正性意味着 $S = 1$。将分数偏差（无量纲）定义为\n$$\n\\Delta \\equiv S - 1.\n$$\n\n算法要求：\n- 使用上述积分和单圈跑动的 $\\alpha_s$、$C_F = \\frac{4}{3}$、$n_f = 5$ 和 $\\Lambda = 0.2 \\ \\mathrm{GeV}$ 计算 $\\lambda(Q,Q_{\\text{cut}})$。\n- 计算 $P(m;\\lambda)$，对于 $m = 0,1,2,\\dots$，直到被忽略的尾部 $\\sum_{m=M_{\\max}+1}^{\\infty} P(m;\\lambda)$ 小于容差 $10^{-12}$；如果需要，可以设定 $M_{\\max}$ 的上限。\n- 应用合并权重 $w(m)$ 得到 $S$，然后得到 $\\Delta$。\n- 返回四舍五入到 $8$ 位小数的 $\\Delta$ 作为十进制数（无百分号）。所有量都是无量纲的。\n\n测试套件：\n为以下参数集 $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$ 提供结果，其中能量单位为 $\\mathrm{GeV}$：\n- 情况 1：$(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 0.0)$，一个预期具有完美幺正性的“理想”情况。\n- 情况 2：$(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 4, \\varepsilon = 0.5)$，在低多重数区域有中等程度的合并扭曲。\n- 情况 3：$(Q = 91.1876, Q_{\\text{cut}} = 1.0, N_{\\mathrm{ME}} = 5, \\varepsilon = 0.2)$，较低的 $Q_{\\text{cut}}$ 会增加平均辐射数。\n- 情况 4：$(Q = 200.0, Q_{\\text{cut}} = 20.0, N_{\\mathrm{ME}} = 4, \\varepsilon = -0.3)$，更高的能量和负的扭曲参数以探究抑制效应。\n- 情况 5：$(Q = 91.1876, Q_{\\text{cut}} = 80.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 1.0)$，接近边界条件，其中 $Q_{\\text{cut}}$ 接近 $Q$，导致平均辐射数很小。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的分数偏差 $\\Delta$，格式为逗号分隔的列表并用方括号括起，例如 $\\left[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5\\right]$，其中每个 $\\delta_i$ 都四舍五入到 $8$ 位小数。所有输出都是无量纲的十进制数。",
            "solution": "该问题的目标是在一个简化的多喷注矩阵元 (ME) 与部分子簇射 (PS) 合并模型中，计算与幺正性的分数偏差 $\\Delta$。幺正性要求所有专属喷注产率之和等于总遍举截面。在这个归一化的框架中，这个和应该等于 $1$。偏差 $\\Delta$ 量化了由一个玩具模型引入的对该原则的违背程度。\n\n计算过程主要分为两个阶段：首先，我们推导平均辐射数 $\\lambda(Q, Q_{\\text{cut}})$ 的解析表达式；其次，我们利用这个表达式推导出一个计算效率高的、精确的偏差 $\\Delta$ 公式。\n\n**1. 平均辐射数 $\\lambda(Q, Q_{\\text{cut}})$ 的计算**\n\n平均辐射数 $\\lambda$ 由强耦合常数 $\\alpha_s(\\mu)$ 在辐射尺度 $\\mu$ 上的积分定义：\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu\n$$\n单圈跑动的强耦合常数由下式给出：\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}\n$$\n其中 $\\beta_0 = 11 - \\frac{2}{3} n_f$。当 $n_f = 5$ 时，我们有 $\\beta_0 = 11 - \\frac{10}{3} = \\frac{23}{3}$。基础表示的二次卡西米尔算符为 $C_F = \\frac{4}{3}$。\n\n将 $\\alpha_s(\\mu)$ 的表达式代入 $\\lambda$ 的积分中：\n$$\n\\lambda = \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\left( \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\right) \\frac{d\\mu}{\\mu} = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\frac{d\\mu}{\\mu}\n$$\n使用对数性质 $\\ln(a^b) = b \\ln(a)$，分母可以写成 $2\\ln(\\mu/\\Lambda)$。\n$$\n\\lambda = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{2\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu} = \\frac{4 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu}\n$$\n为了求解这个积分，我们进行变量替换。令 $u = \\ln(\\mu/\\Lambda)$。其微分为 $du = \\frac{1}{\\mu/\\Lambda} \\cdot \\frac{1}{\\Lambda} d\\mu = \\frac{d\\mu}{\\mu}$。积分限从 $\\mu \\in [Q_{\\text{cut}}, Q]$ 变为 $u \\in [\\ln(Q_{\\text{cut}}/\\Lambda), \\ln(Q/\\Lambda)]$。\n积分变为：\n$$\n\\lambda = \\frac{4 C_F}{\\beta_0} \\int_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)} \\frac{1}{u} \\, du = \\frac{4 C_F}{\\beta_0} \\left[ \\ln u \\right]_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)}\n$$\n计算该定积分，得到 $\\lambda$ 的最终解析表达式：\n$$\n\\lambda(Q, Q_{\\text{cut}}) = \\frac{4 C_F}{\\beta_0} \\left( \\ln\\left(\\ln\\frac{Q}{\\Lambda}\\right) - \\ln\\left(\\ln\\frac{Q_{\\text{cut}}}{\\Lambda}\\right) \\right) = \\frac{4 C_F}{\\beta_0} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right)\n$$\n代入 $C_F$ 和 $\\beta_0$ 的数值：\n$$\n\\frac{4 C_F}{\\beta_0} = \\frac{4 \\cdot (4/3)}{23/3} = \\frac{16/3}{23/3} = \\frac{16}{23}\n$$\n因此，我们得到了一个仅依赖于能量尺度 $Q$、$Q_{\\text{cut}}$ 和 $\\Lambda$ 的 $\\lambda$ 的闭合形式解。\n\n**2. 分数偏差 $\\Delta$ 的计算**\n\n合并后的总专属和 $S$ 定义为对所有可能的辐射数 $m$ 的求和，并用泊松概率 $P(m;\\lambda)$ 和合并权重因子 $w(m)$ 加权：\n$$\nS = \\sum_{m=0}^{\\infty} P(m; \\lambda) w(m)\n$$\n权重因子 $w(m)$ 是分段定义的：\n$$\nw(m) = \\begin{cases} 1 + \\varepsilon \\, g(m)  \\text{对于 } m \\le m_{\\mathrm{ME}} \\\\ 1  \\text{对于 } m  m_{\\mathrm{ME}} \\end{cases}\n$$\n其中 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ 是由矩阵元修正的最大辐射数。\n\n我们可以将 $S$ 的求和分成两部分：\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) \\cdot 1\n$$\n第二项是泊松分布的尾部。泊松分布的基本性质是它归一化为1：$\\sum_{m=0}^{\\infty} P(m; \\lambda) = 1$。这意味着第二项可以表示为：\n$$\n\\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) = 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda)\n$$\n将此代回 $S$ 的表达式中：\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\left( 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right)\n$$\n分数偏差定义为 $\\Delta \\equiv S - 1$。\n$$\n\\Delta = S - 1 = \\left( \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right) - 1\n$$\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (w(m) - 1)\n$$\n根据 $w(m)$ 的定义，对于 $m \\le m_{\\mathrm{ME}}$，我们有 $w(m) - 1 = \\varepsilon g(m)$。这得出了 $\\Delta$ 的最终精确表达式：\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (\\varepsilon g(m)) = \\varepsilon \\sum_{m=0}^{m_{\\mathrm{ME}}} \\frac{e^{-\\lambda} \\lambda^m}{m!} \\left( \\exp\\left(-\\frac{m}{m_0}\\right) - c \\right)\n$$\n这个结果是一个从 $m=0$ 到 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}}-2$ 的有限和。这在计算上是有利的，因为它避免了近似无限级数和管理截断误差的需要。问题描述中提到的求和直到满足某个容差对应于对 $S$ 的数值暴力求解，而这种解析简化直接提供了精确结果。\n\n**3. 算法流程**\n\n对于由参数集 $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$ 给出的每个测试用例，$\\Delta$ 的计算按以下步骤进行：\n1.  定义物理和模型常数：$\\Lambda = 0.2 \\ \\mathrm{GeV}$，$C_F = 4/3$，$n_f = 5$，$m_0 = 1.5$，以及 $c = 0.4$。\n2.  计算 $\\beta_0 = 11 - 2/3 \\cdot n_f = 23/3$。\n3.  使用推导出的解析公式计算平均辐射数 $\\lambda$：\n    $$ \\lambda = \\frac{16}{23} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right) $$\n4.  确定最大修正多重数 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$。\n5.  如果 $\\varepsilon = 0$，则偏差 $\\Delta$ 立刻为 $0$。否则，计算 $\\Delta$ 的有限和。\n6.  初始化一个和变量，$\\Delta_{\\text{sum}} = 0$。\n7.  从 $m=0$ 到 $m_{\\mathrm{ME}}$ 进行迭代。在每一步中：\n    a.  计算泊松概率 $P(m; \\lambda) = \\frac{e^{-\\lambda}\\lambda^m}{m!}$。为保持数值稳定性，最好迭代计算：$P(m;\\lambda) = P(m-1;\\lambda) \\cdot \\frac{\\lambda}{m}$，其中 $P(0;\\lambda) = e^{-\\lambda}$。\n    b.  计算扭曲项 $g(m) = \\exp(-m/m_0) - c$。\n    c.  将乘积 $P(m; \\lambda) \\cdot g(m)$ 加到运行和 $\\Delta_{\\text{sum}}$ 中。\n8.  最终偏差为 $\\Delta = \\varepsilon \\cdot \\Delta_{\\text{sum}}$。\n9.  按要求将 $\\Delta$ 的最终结果四舍五入到 $8$ 位小数。\n此流程将针对指定的五个测试用例分别执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the unitarity deviation problem for the given test cases.\n    \"\"\"\n\n    # Define physical and model constants from the problem statement.\n    LAMBDA_QCD = 0.2  # GeV\n    C_F = 4.0 / 3.0\n    N_F = 5.0\n    BETA_0 = 11.0 - (2.0 / 3.0) * N_F\n    \n    # Distortion function parameters\n    M0 = 1.5\n    C_G = 0.4\n\n    # Define the test cases from the problem statement.\n    # Format: (Q [GeV], Q_cut [GeV], N_ME, epsilon)\n    test_cases = [\n        (91.1876, 5.0, 6, 0.0),   # Case 1\n        (91.1876, 5.0, 4, 0.5),   # Case 2\n        (91.1876, 1.0, 5, 0.2),   # Case 3\n        (200.0, 20.0, 4, -0.3),  # Case 4\n        (91.1876, 80.0, 6, 1.0),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        q, q_cut, n_me_jets, epsilon = case\n        \n        # Calculate the fractional deviation Delta.\n        delta = calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                                    LAMBDA_QCD, C_F, BETA_0, M0, C_G)\n        \n        # Round the result to 8 decimal places.\n        results.append(round(delta, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                        lambda_qcd, c_f, beta_0, m0, c_g):\n    \"\"\"\n    Calculates the fractional deviation Delta for a single parameter set.\n    \n    The calculation uses the analytical formula derived in the solution:\n    Delta = epsilon * sum_{m=0 to m_ME} P(m; lambda) * g(m)\n    \"\"\"\n    # A merging distortion of size epsilon=0 leads to perfect unitarity, Delta=0.\n    if epsilon == 0.0:\n        return 0.0\n\n    # Calculate the mean number of emissions, lambda.\n    # lambda = (4*C_F/beta_0) * ln( ln(Q/Lambda)/ln(Q_cut/Lambda) )\n    prefactor = (4.0 * c_f) / beta_0\n    log_arg = np.log(q / lambda_qcd) / np.log(q_cut / lambda_qcd)\n    lambda_val = prefactor * np.log(log_arg)\n    \n    # Maximum number of ME-corrected emissions.\n    m_me = n_me_jets - 2\n\n    # Calculate the sum part of the Delta formula.\n    # sum_{m=0 to m_ME} (P(m; lambda) * g(m))\n    delta_sum = 0.0\n    \n    # To avoid large numbers in lambda^m and m!, calculate Poisson probabilities\n    # iteratively: P(m) = P(m-1) * lambda / m\n    poisson_prob = np.exp(-lambda_val)  # P(0; lambda)\n    \n    for m in range(m_me + 1):\n        # For m=0, poisson_prob is already P(0).\n        # For m > 0, it was updated in the previous iteration's end.\n        \n        # Calculate distortion function g(m)\n        g_m = np.exp(-m / m0) - c_g\n        \n        # Add term to the sum\n        delta_sum += poisson_prob * g_m\n        \n        # Update Poisson probability for the next iteration m+1\n        if m  m_me: # No need to update after the last term.\n          poisson_prob *= lambda_val / (m + 1.0)\n            \n    # Final deviation is epsilon times the sum.\n    delta = epsilon * delta_sum\n    \n    return delta\n\nsolve()\n```"
        }
    ]
}