{
    "hands_on_practices": [
        {
            "introduction": "为了运用色动对偶（color-kinematics duality），我们必须首先将散射振幅表示为所有三阶图（cubic graph）的和。这个练习将引导你为五点振幅构建这种表示，并理解其背后图结构和雅可比恒等式（Jacobi identity）的组合学 。掌握这一基础步骤是进行任何涉及色动对偶的计算或证明的关键。",
            "id": "3508621",
            "problem": "考虑一个非阿贝尔规范理论中的树级五点色序部分振幅 $A_{5}(1,2,3,4,5)$。使用色剥离表示，其中相互作用完全是三次的，并且每个图贡献一个运动学分子项乘以两个标量传播子的乘积。从杨-米尔斯理论中树级振幅可以表示为具有运动学分子项 $n_{g}$ 和由曼德尔施塔姆不变量构建的标量传播子的三次图之和的基本分解出发。李代数结构常数 $f^{a b c}$ 服从雅可比恒等式 $f^{a b e} f^{e c d} + f^{b c e} f^{e a d} + f^{c a e} f^{e b d} = 0$，而色-运动学对偶性要求运动学分子项表现出相同的三元组约束。\n\n任务1：将色序振幅 $A_{5}(1,2,3,4,5)$ 构建为与固定循环序 $1,2,3,4,5$ 一致的五个平面三次图之和的三次表示。使用双粒子曼德尔施塔姆不变量 $s_{i\\,i+1} = (p_{i} + p_{i+1})^{2}$（其中指标模5）和附加到每个平面三次图的运动学分子项 $n_{i\\,i+1\\,|\\,j\\,j+1}$ 来写出您的表达式。\n\n任务2：现在考虑带有标记为 $\\{1,2,3,4,5\\}$ 的外腿的全套三次树图，不施加平面性。使用三次树的第一性原理组合学以及每个内边定义一个唯一的图的雅可比三元组这一事实，确定：\n- 不同三次图的总数，以及\n- 在五点色-运动学对偶表示中约束运动学分子项的不同雅可比三元组的总数。\n\n将您的最终答案表示为包含两个整数 $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$ 的单行矩阵。无需四舍五入，最终答案中不报告单位。",
            "solution": "该问题要求完成与非阿贝尔规范理论中五点树级振幅结构相关的两个任务，这些任务在色-运动学对偶性框架内。\n\n首先，我们将给定的概念形式化。一个具有 $n$ 个外部粒子（腿）的树级散射振幅可以分解为对所有具有 $n$ 个标记外腿的不同三次树图的求和。全振幅由下式给出\n$$ \\mathcal{A}_n = g^{n-2} \\sum_{g} \\frac{c_g n_g}{D_g} $$\n其中 $g$ 索引三次图的集合，$g$ 是耦合常数，$c_g$ 是由李代数结构常数 $f^{abc}$ 构建的色因子，$n_g$ 是依赖于动量和极化的运动学分子项，而 $D_g$ 是逆传播子（分母）的乘积。对于一个三次图，所有顶点的度都为3。一个 $n$ 点三次图有 $n$ 个外腿，$n-2$ 个内顶点，以及 $n-3$ 条内边（传播子）。对于 $n=5$，有 $5-3=2$ 个内部传播子。\n\n色因子 $c_g$ 对于任何通过特定结构变换相关的图三元组 $(i,j,k)$ 满足 $c_i+c_j+c_k=0$ 形式的雅可比恒等式。色-运动学对偶性假设，可以找到一个运动学分子项 $n_g$ 的表示，使得它们服从相同的雅可比恒等式，即 $n_i+n_j+n_k=0$。\n\n一个色序部分振幅，例如 $A_{5}(1,2,3,4,5)$，是通过仅对相对于指定外腿循环序是平面的三次图求和得到的。\n\n任务1：构建色序振幅 $A_{5}(1,2,3,4,5)$ 的三次表示。\n\n对于一个具有固定外腿循环序 $(1,2,3,4,5)$ 的五点振幅，存在五个相应的平面三次图。每个图有 $5-3=2$ 个传播子。这些图的拓扑结构可以通过将外腿放置在一个圆上，并用不交叉的内线连接顶点来可视化。对于 $n=5$，这五个平面图在腿标签的循环置换下都是拓扑等价的。\n\n让我们描述这样一个图的拓扑结构。两个相邻的腿，比如 $1$ 和 $2$，在一个顶点相遇。另一对相邻的腿，$4$ 和 $5$，在第二个顶点相遇。来自这两个顶点的内线，连同剩下的腿 $3$，在第三个顶点相遇。\n这个图的传播子与内线相关联。流经它们的动量是 $p_1+p_2$ 和 $p_4+p_5$。相应的分母是 $1/((p_1+p_2)^2 (p_4+p_5)^2)$。使用双粒子曼德尔施塔姆不变量表示法 $s_{ij} = (p_i+p_j)^2$，分母乘积是 $s_{12}s_{45}$。问题将此图的分子项表示为 $n_{i\\,i+1\\,|\\,j\\,j+1}$。对于这个特定的图，我们有相邻对 $(1,2)$ 和 $(4,5)$，所以我们可以设 $i=1$ 和 $j=4$。因此分子项是 $n_{12|45}$。\n\n对于序 $(1,2,3,4,5)$ 的五个平面图是通过循环置换标签 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 1$ 得到的。这五个图及其贡献是：\n1.  腿 $(1,2)$ 和 $(4,5)$ 配对。传播子：$s_{12}, s_{45}$。贡献：$\\frac{n_{12|45}}{s_{12}s_{45}}$。\n2.  腿 $(2,3)$ 和 $(5,1)$ 配对。传播子：$s_{23}, s_{51}$。贡献：$\\frac{n_{23|51}}{s_{23}s_{51}}$。\n3.  腿 $(3,4)$ 和 $(1,2)$ 配对。传播子：$s_{34}, s_{12}$。贡献：$\\frac{n_{34|12}}{s_{34}s_{12}}$。\n4.  腿 $(4,5)$ 和 $(2,3)$ 配对。传播子：$s_{45}, s_{23}$。贡献：$\\frac{n_{45|23}}{s_{45}s_{23}}$。\n5.  腿 $(5,1)$ 和 $(3,4)$ 配对。传播子：$s_{51}, s_{34}$。贡献：$\\frac{n_{51|34}}{s_{51}s_{34}}$。\n\n将这些贡献相加得到色序振幅：\n$$ A_{5}(1,2,3,4,5) = \\frac{n_{12|45}}{s_{12}s_{45}} + \\frac{n_{23|51}}{s_{23}s_{51}} + \\frac{n_{34|12}}{s_{34}s_{12}} + \\frac{n_{45|23}}{s_{45}s_{23}} + \\frac{n_{51|34}}{s_{51}s_{34}} $$\n这个表达式满足了第一个任务的要求。\n\n任务2：确定五点情况下不同三次图的总数（$N_{\\text{graphs}}$）和不同雅可比三元组的总数（$N_{\\text{Jacobi}}$）。\n\n不同三次图的总数，$N_{\\text{graphs}}$：\n计算具有 $n$ 个标记外腿的不同三次树图数量的问题，等价于计算具有 $n$ 个标记叶子的无根二叉树的数量。这是组合学中的一个标准结果。此类树的数量由双阶乘 $(2n-5)!!$ 给出。\n对于 $n=5$ 条腿，不同三次图的总数是：\n$$ N_{\\text{graphs}} = (2 \\cdot 5 - 5)!! = 5!! = 5 \\cdot 3 \\cdot 1 = 15 $$\n这 $15$ 个图包括平面和非平面拓扑。一个图由其两个传播子指定，这对应于将5条腿划分为两对和一个单体，例如 $(\\{i,j\\}, \\{k,l\\}, \\{m\\})$。这样做的组合方式数为 $\\binom{5}{4} \\times 3 = 15$，这证实了公式。\n\n不同雅可比三元组的总数，$N_{\\text{Jacobi}}$：\n运动学分子项的雅可比恒等式 $n_i+n_j+n_k=0$ 关联了一个图的三元组。参与雅可比恒等式的图三元组 $(g_i, g_j, g_k)$ 在结构上由四个子树如何连接到一个中心的类四点顶点结构来定义。该恒等式源于连接这四个子树的三种方式，对应于一个四点函数的 s、t 和 u 通道。\n因此，不同雅可比恒等式的数量是将 $n$ 个外腿划分为四个非空集合的方式数，这些集合代表了四个子树的叶子集。\n对于 $n=5$ 条腿，我们需要找到将标签集 $\\{1,2,3,4,5\\}$ 划分为4个非空子集的方式数。这种划分唯一可能的结构是有一个大小为2的子集和三个大小为1的子集。例如，这种类型的一个划分是 $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$。\n此类划分的数量由选择形成该对的两条腿的方式数决定。剩下的三条腿将自动形成单元素集。从5个元素中选择2个的方式数由二项式系数 $\\binom{5}{2}$ 给出。\n$$ N_{\\text{Jacobi}} = \\binom{5}{2} = \\frac{5!}{2!(5-2)!} = \\frac{5 \\cdot 4}{2} = 10 $$\n这10个划分中的每一个都定义了一个唯一的分子项雅可比三元组。例如，划分 $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$ 对应于具有传播子对 $(s_{12},s_{34})$、$(s_{12},s_{35})$ 和 $(s_{12},s_{45})$ 的三个图的分子项之间的关系，假设该关系是通过固定一个传播子通道来构建的。更准确地说，该关系关联了对应于配对 $((\\{1,2\\},\\{3\\}),(\\{4\\},\\{5\\}))$、$((\\{1,2\\},\\{4\\}),(\\{3\\},\\{5\\}))$ 和 $((\\{1,2\\},\\{5\\}),(\\{3\\},\\{4\\}))$ 的图的分子项，其中表示法指明了这四个组是如何配对的。\n因此，有10个不同的雅可比三元组约束着运动学分子项。\n\n最终答案包含两个整数 $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$。\n$N_{\\text{graphs}} = 15$\n$N_{\\text{Jacobi}} = 10$\n\n最终答案：$(15, 10)$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 15 & 10 \\end{pmatrix} } $$"
        },
        {
            "introduction": "色动对偶一个惊人的推论是色序振幅（color-ordered amplitude）之间存在线性关系，即所谓的BCJ关系（Bern–Carrasco–Johansson relations）。本练习提供了一个机会，使用著名的Parke-Taylor公式，对一个五点MHV（maximally helicity violating）振幅明确地验证这样一条基本BCJ关系 。这个计算为对偶性的威力提供了直接而具体的证据，并加深你对抽象的分子（numerator）关系如何转化为具体的振幅关系的理解。",
            "id": "3508625",
            "problem": "考虑树图层级的纯杨-米尔斯理论，其中有五个不同的外部胶子，其无质量动量为 $\\{p_{1},p_{2},p_{3},p_{4},p_{5}\\}$，满足 $\\sum_{i=1}^{5} p_{i}=0$。我们使用以三次图表示组织的色剥离部分振幅 $A(1,2,3,4,5)$。在这种表示法中，振幅被写成对所有三次图 $i$ 的求和，每个图都带有色因子 $c_{i}$、运动学分子 $n_{i}$ 和传播子分母 $D_{i}$，即\n$$\n\\mathcal{A}_{\\text{tree}}=\\sum_{i} \\frac{c_{i}\\,n_{i}}{D_{i}}.\n$$\n色因子 $c_{i}$ 满足反对称性和雅可比恒等式。色-运动学对偶性（CK对偶性）要求运动学分子 $n_{i}$ 遵守相同的反对称性和雅可比恒等式。分子的局域性意味着每个 $n_{i}$ 都是动量和极化矢量的多项式，并且除了 $D_{i}$ 中已有的极点外，不会在曼德尔施塔姆不变量中引入额外的极点。在保持CK对偶性的同时确保局域性的一种方法是，利用线性化场强 $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$ 和曼德尔施塔姆不变量 $s_{ij}=(p_{i}+p_{j})^{2}$ 来构造分子，并避免使用任何 $s_{ij}$ 的负幂次。\n\n在五点情况下，选择一个半梯形主图，其有序的外部腿沿链遵循 $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$ 的顺序，并将其分子表示为 $n_{12|3|45}$。构造一个显式的局域拟设\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\n其中常数 $\\alpha$ 通过与物理振幅匹配来确定，并通过三次顶点的反对称性和内部边上的雅可比关系生成所有其他分子，从而使CK对偶性对整个集合 $\\{n_{i}\\}$ 成立。假设螺旋度构型为 $(1^{-},2^{-},3^{+},4^{+},5^{+})$，并使用旋量-螺旋度形式，其中包含 $\\langle i j\\rangle$ 和 $[i j]$ 尖括号和方括号，且 $s_{ij}=\\langle i j\\rangle [j i]$。\n\n从三次图表示出发，解释该拟设的局域性如何防止非局域项的出现，以及施加在局域拟设上的CK对偶性如何导致色序振幅之间的一个线性关系，即著名的基本Bern–Carrasco–Johansson (BCJ) 关系。然后，使用给定螺旋度构型下色序振幅的最大螺旋度破坏 (MHV) Parke–Taylor 公式，\n$$\nA(\\sigma(1^{-},2^{-},3^{+},4^{+},5^{+}))= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle},\n$$\n计算以下色序振幅的线性组合，\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\n并给出其精确值。最终答案必须是一个无单位的实数值或闭式解析表达式。如果需要近似，则四舍五入到四位有效数字；否则，给出精确值。",
            "solution": "树图层级杨-米尔斯振幅的三次图表示法将贡献项组织起来，使得每一项都含有一个色因子 $c_{i}$、一个运动学分子 $n_{i}$ 和传播子 $D_{i}$ 的乘积。色因子由规范群的结构常数 $f^{abc}$ 构造，并在交换顶点处的腿时满足反对称性，对于任何因单个边翻转而不同的三联图，满足雅可比恒等式 $c_{i}+c_{j}+c_{k}=0$。色-运动学对偶性要求运动学分子 $n_{i}$ 满足相同的代数性质：\n- 运动学反对称性：在交换连接到三次顶点的两条腿时，$n_{i}$ 变号。\n- 运动学雅可比恒等式：对于任何通过边翻转关联的三联图 $(i,j,k)$，$n_{i}+n_{j}+n_{k}=0$。\n\n在此背景下，局域性意味着分子 $n_{i}$ 不包含曼德尔施塔姆不变量 $s_{ij}$ 的负幂次；振幅中的所有极点都应来自传播子分母 $D_{i}$。一种在保持规范不变性的同时强制实现局域性的稳健方法是，从线性化场强 $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$ 构造分子，这些场强在 $\\varepsilon_{i}^{\\mu}\\rightarrow \\varepsilon_{i}^{\\mu}+ \\beta\\, p_{i}^{\\mu}$ 变换下是显式规范不变的，并且是动量和极化矢量的局域多项式。\n\n在五点情况下，考虑外部腿呈链式 $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$ 的半梯形主图。其分子的一种局域且规范不变的拟设为\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\n其中，迹是在闵可夫斯基度规下对相邻场强的指标进行缩并，$\\alpha$ 是一个常数，通过将计算出的振幅与已知的色序振幅匹配来确定。该拟设：\n1. 是局域的，因为它只包含 $p_{i}$ 和 $\\varepsilon_{i}$ 的多项式依赖，而不含曼德尔施塔姆不变量的逆。\n2. 是规范不变的，因为 $F_{i}$ 是规范不变的，其乘积的迹也是规范不变的。\n3. 可以通过顶点的反对称性生成剩余的分子，并通过在内部边翻转上施加雅可比约束来安排，以满足反对称性和雅可比关系。蕴含在 $F_{i}$ 的迹中的循环性和对易结构，连同动量守恒和比安基恒等式 $p_{i[\\mu}F_{i\\nu\\rho]}=0$，提供了足够的自由度来调整接触项，从而在不引入非局域性的情况下满足所有运动学雅可比恒等式。换言之，接触项用于在等效的局域表示之间转换，这些表示是“BCJ规范”，在其中CK对偶性成立。\n\n一旦运动学雅可比恒等式对一组局域分子成立，一个振幅层级的结果是色序振幅之间的一个线性关系，即著名的基本Bern–Carrasco–Johansson (BCJ) 关系。这个关系可以通过将全振幅用两种等效的方式写出（使用不同的色基），并利用运动学雅可比恒等式以一种镜像色雅可比重排的方式将一组分子用另一组表示出来，从而推导得出。当分子遵循对偶性时，不同色序之间的不匹配会相互抵消，从而得到一个线性恒等式，其运动学系数是附着于沿色链移动的腿的曼德尔施塔姆不变量之和。\n\n对于 $n=5$，将腿1插入到 $(2,3,4,5)$ 中的不同位置，基本BCJ关系产生特定的线性组合\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\n当分子满足CK对偶性且是局域的时，该组合必须为零。为了在最大螺旋度破坏构型 $(1^{-},2^{-},3^{+},4^{+},5^{+})$ 中显式地验证这一点，我们使用 Parke–Taylor 公式。对于任意排序 $\\sigma$，在腿1和2处具有负螺旋度的色序MHV振幅为\n$$\nA(\\sigma)= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle}.\n$$\n因此，\n\\begin{align*}\nA(2,1,3,4,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 1\\rangle\\,\\langle 1 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,1,4,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 1\\rangle\\,\\langle 1 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,4,1,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 1\\rangle\\,\\langle 1 5\\rangle\\,\\langle 5 2\\rangle}.\n\\end{align*}\n通过将这些振幅乘以它们各自的运动学系数来构造 $L$。使用 $s_{ij}=\\langle i j\\rangle [j i]$ 和反对称性 $\\langle i j\\rangle=-\\langle j i\\rangle$ 来重写所有项，使它们共享公分母 $\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle$ 和一个因子 $\\mathrm{i}\\,\\langle 1 2\\rangle^{3}$，例如通过适当地乘以每个项的分子和分母。将 $L$ 通分后，分子变成一个由旋量乘积线性组合构成的和，这些旋量乘积乘以来自 $s_{ij}$ 的 $[j i]$ 因子。由于尖括号之间的舒outen恒等式（例如，\n$$\n\\langle a b\\rangle \\langle c d\\rangle + \\langle b c\\rangle \\langle a d\\rangle + \\langle c a\\rangle \\langle b d\\rangle = 0,\n$$\n）和动量守恒恒等式（如 $\\sum_{k} |k]\\langle k|=0$），以及有序链的重标号对称性，这些项成对抵消。详细的代数运算反映了由CK对偶性在被积函数层级保证的抵消，并为 $L$ 产生一个恒为零的分子。因此，\n$$\nL=0.\n$$\n这个显式检验与从局域CK对偶分子的一般推导是一致的：对一组局域分子强制执行运动学雅可比恒等式，意味着色序振幅的基本BCJ组合为零。分子拟设的局域性是至关重要的；非局域项（曼德尔施塔姆不变量的逆）会破坏推导所需的极点结构的匹配，从而阻碍导致振幅层级BCJ关系的抵消。\n\n因此，对于五点MHV构型和任何局域CK对偶表示，上面定义的 $L$ 的值精确为零。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "色动对偶不仅用于理论验证，它还是现代多圈计算的强大工具。这个高级计算练习模拟了被积函数（integrand）的重构过程，你将利用幺正割迹（unitarity cut）数据和CK对偶的约束，在有限域上确定未知的分子多项式 。通过实现这一算法，你将亲身体验振幅研究前沿所使用的尖端技术，从而架起理论原则与实际计算之间的桥梁。",
            "id": "3508572",
            "problem": "要求您实现一个完整的、在有限域上的、对运动学分子的多元插值和线性约束重构。该重构针对一个由色-运动学（CK）对偶和广义幺正切割约束的5点、2圈三次图的玩具子集。您编写的程序必须在模一个素数的意义下重构未知的多项式分子系数，并在独立的验证点上验证雅可比恒等式约束和切割一致性。最终输出必须是单行，包含一个布尔值列表，表示每个测试用例是否成功。\n\n从以下基本依据和核心定义开始：\n\n- 色-运动学（CK）对偶指出，对于颜色因子服从李代数雅可比恒等式的三次图，存在服从同构雅可比关系的运动学分子，具体来说，对于每一组颜色因子满足 $c_s + c_t + c_u = 0$ 的图三元组，其运动学分子满足 $n_s + n_t + n_u = 0$。\n\n- Bern-Carrasco-Johansson (BCJ) 关系是CK对偶在振幅层面的推论，其中与雅可比关系一致的运动学分子重排不改变物理振幅。\n\n- 广义幺正切割通过匹配树图的乘积，从在壳条件重构被积函数。在分离出图的拓扑结构的最大切割上，切割数据直接在特定的运动学点上约束该图的分子值。\n\n您的任务是在素数模 $p$ 的有限域上，重构两个独立的分母多项式 $n_a(x)$ 和 $n_b(x)$，用于雅可比三元组中的两个图，并使用CK对偶通过系数级恒等式 $c_c = -c_a - c_b$ 来消去第三个分子 $n_c(x)$。在这里，每个分子都被建模为运动学变量\n$$\nx = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)\n$$\n的多项式，使用单项式基\n$$\nM(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big).\n$$\n因此，每个分子被参数化为\n$$\nn_g(x) = \\sum_{j=1}^{6} c_{g,j}\\, M_j(x),\n$$\n对于 $g \\in \\{a,b,c\\}$，其未知系数向量为 $c_a, c_b, c_c \\in \\mathbb{F}_p^6$。CK对偶强制要求\n$$\nc_c = -c_a - c_b \\quad \\text{over} \\quad \\mathbb{F}_p.\n$$\n广义幺正切割在采样点 $x_i$ 处提供切割数据 $y_{g,i}$，在此处使用的玩具最大切割模型中，它直接等于模 $p$ 的分子求值：\n$$\ny_{g,i} \\equiv n_g(x_i) \\pmod{p}.\n$$\n\n您必须实现一个有限域求解器，该求解器：\n- 根据样本方程\n$$\nM(x_i)\\cdot c_a = y_{a,i}, \\quad M(x_i)\\cdot c_b = y_{b,i}, \\quad M(x_i)\\cdot c_c = y_{c,i},\n$$\n构建线性系统，并使用CK对偶消去 $c_c$ 以产生约束\n$$\n-M(x_i)\\cdot c_a - M(x_i)\\cdot c_b = y_{c,i}.\n$$\n- 通过带有模算术的高斯消元法，求解得到的（可能超定的）线性系统模 $p$，以获得 $c_a$ 和 $c_b$。\n- 通过 $c_c = -c_a - c_b$ 恢复 $c_c$ 并验证：\n    1. 在独立的验证点上，雅可比恒等式 $n_a(x) + n_b(x) + n_c(x) \\equiv 0 \\pmod{p}$ 成立。\n    2. 在额外的验证点上，对于 $g \\in \\{a,b,c\\}$，切割一致性 $n_g(x) \\equiv y_{g}(x) \\pmod{p}$ 成立。\n\n所有算术必须在素数模 $p$ 的有限域 $\\mathbb{F}_p$ 中完成。您必须实现模逆元和模行化简。不要使用浮点运算；所有量必须是模 $p$ 约化后的整数。\n\n单位规范：不涉及物理单位；所有量都是模一个素数的纯整数。不使用角度。\n\n测试套件和最终输出规范：\n- 对所有图和所有测试用例，使用以下单项式基 $M(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big)$。\n- 对于每个测试用例，提供一个固定的素数 $p$ 以及一组样本点和一组验证点。在每个点 $x=(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)$，应用上述方程。切割数据 $y_{g,i}$ 在程序内部由一个隐藏的预言机分子综合生成，该分子在所有测试用例中都是固定的（程序将确定性地定义和使用它，以便结果是可复现的）。\n- 您的程序应生成单行输出，其中包含形如方括号内逗号分隔列表的结果（例如，“[result1,result2,result3]”），每个结果是一个布尔值，指示对于该测试用例，重构的系数是否在提供的验证点上通过了雅可比恒等式和切割一致性两项验证。\n\n要实现的测试用例：\n- 测试用例 1（理想路径）：\n    - 素数模：$p=101$。\n    - 用于重构的样本点（6个点，最小确定）：\n        1. $(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)=(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$。\n    - 验证点（3个点）：\n        1. $(3,1,4,1,5)$,\n        2. $(9,2,6,5,3)$,\n        3. $(10,20,30,40,50)$。\n- 测试用例 2（超定系统和鲁棒性）：\n    - 素数模：$p=97$。\n    - 用于重构的样本点（8个点，超定）：\n        1. $(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$,\n        7. $(4,5,6,7,8)$,\n        8. $(10,9,8,7,6)$。\n    - 验证点（3个点）：\n        1. $(3,5,7,11,13)$,\n        2. $(6,5,4,3,2)$,\n        3. $(8,13,21,34,55)$。\n- 测试用例 3（包括零的边界值）：\n    - 素数模：$p=89$。\n    - 用于重构的样本点（6个点）：\n        1. $(0,0,0,0,0)$,\n        2. $(1,0,0,0,0)$,\n        3. $(0,1,0,0,0)$,\n        4. $(0,0,1,0,0)$,\n        5. $(0,0,0,1,0)$,\n        6. $(0,0,0,0,1)$。\n    - 验证点（3个点）：\n        1. $(2,3,5,7,11)$,\n        2. $(13,17,19,23,29)$,\n        3. $(1,1,1,1,1)$。\n\n您的程序必须：\n- 在 $\\mathbb{F}_p$ 上构建增广线性系统，该系统包括图 $a$ 和 $b$ 的方程以及图 $c$ 经CK对偶约化后的方程。\n- 通过在有限域上使用行全主元的高斯消元法求解 $c_a$ 和 $c_b$（按列进行前向选择即可）。\n- 使用CK对偶恢复 $c_c$。\n- 在验证点上验证CK雅可比恒等式和切割一致性。\n- 打印一行形如“[bool1,bool2,bool3]”的输出。\n\n不允许外部输入、文件或网络访问。代码必须完全自包含且确定性。",
            "solution": "所提出的问题是理论高能物理学中一个明确定义的计算任务。它要求为一组费曼图重构运动学分子多项式，这些多项式受色-运动学（CK）对偶的约束。重构将在有限域 $\\mathbb{F}_p$ 上进行，使用广义幺正切割提供的一组样本数据点。然后，重构的有效性将在另一组独立的验证点上进行测试。该问题在科学上是有根据的，数学上是一致的，并且在计算上是可行的。因此，该问题被判定为有效的。\n\n解决方案主要分为四个阶段：\n1.  **系统构建**：我们将物理约束转化为有限域 $\\mathbb{F}_p$ 上的线性方程组。\n2.  **数据生成**：我们按要求定义一个预言机，以综合生成用于重构和验证的切割数据。\n3.  **系统求解**：我们使用带有模算术的高斯-若尔当消元法为此线性系统实现一个求解器。\n4.  **重构与验证**：我们使用解来重构分子多项式，并根据所需的物理一致性条件对其进行验证。\n\n### 1. 理论阐述与线性系统构建\n\n问题指定了两个独立的分子 $n_a(x)$ 和 $n_b(x)$，以及第三个分子 $n_c(x)$，它通过雅可比恒等式 $n_a(x) + n_b(x) + n_c(x) = 0$ 依赖于前两者。运动学变量由向量 $x = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$ 给出。每个分子被参数化为来自基 $M(x) = (1, s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$ 的单项式的线性组合。\n对于一个图 $g \\in \\{a,b,c\\}$ 的分子 $n_g(x)$ 写为：\n$$n_g(x) = \\sum_{j=1}^{6} c_{g,j} M_j(x) = M(x) \\cdot c_g$$\n其中 $c_g = (c_{g,1}, \\dots, c_{g,6})^T$ 是在 $\\mathbb{F}_p$ 中的未知系数向量。雅可比恒等式 $n_a+n_b+n_c=0$ 意味着对系数的约束：\n$$M(x) \\cdot c_a + M(x) \\cdot c_b + M(x) \\cdot c_c = 0$$\n由于这对所有 $x$ 都必须成立，并且 $M(x)$ 中的单项式是线性无关的，这要求一个系数级别的恒等式：\n$$c_a + c_b + c_c = 0 \\quad \\implies \\quad c_c = -c_a - c_b \\pmod p$$\n待求解的未知系数是 $c_a$ 的6个分量和 $c_b$ 的6个分量，总共12个未知数。我们定义一个单一的未知数向量 $C \\in \\mathbb{F}_p^{12}$ 作为 $c_a$ 和 $c_b$ 的拼接：\n$$C = (c_{a,1}, \\dots, c_{a,6}, c_{b,1}, \\dots, c_{b,6})^T$$\n广义幺正切割为一组运动学点 $x_i$ 提供了样本数据 $(x_i, y_{a,i}, y_{b,i}, y_{c,i})$，其中 $y_{g,i} \\equiv n_g(x_i) \\pmod p$。这些关系提供了一个线性方程组。对于每个样本点 $x_i$：\n1.  $M(x_i) \\cdot c_a = y_{a,i}$\n2.  $M(x_i) \\cdot c_b = y_{b,i}$\n3.  $M(x_i) \\cdot c_c = y_{c,i}$\n\n将 $c_c = -c_a - c_b$ 代入第三个方程得到：\n$$-M(x_i) \\cdot c_a - M(x_i) \\cdot c_b = y_{c,i}$$\n对于每个样本点 $i$，我们得到了关于组合未知向量 $C$ 的一个联立方程组。设 $M_i$ 为在 $x_i$ 处求值的单项式基的 $1 \\times 6$ 行向量。这些方程可以写成矩阵形式。对于单个点 $x_i$，我们有：\n$$\n\\begin{pmatrix}\nM_i & \\mathbf{0}_{1 \\times 6} \\\\\n\\mathbf{0}_{1 \\times 6} & M_i \\\\\n-M_i & -M_i\n\\end{pmatrix}\n\\begin{pmatrix} c_a \\\\ c_b \\end{pmatrix}\n=\n\\begin{pmatrix} y_{a,i} \\\\ y_{b,i} \\\\ y_{c,i} \\end{pmatrix}\n$$\n将所有 $k$ 个样本点的这些方程堆叠起来，得到一个大型线性系统 $A_{sys} \\cdot C = Y_{sys}$，其中 $A_{sys}$ 是一个 $(3k) \\times 12$ 的矩阵，$Y_{sys}$ 是一个 $(3k) \\times 1$ 的向量。\n\n### 2. 预言机数据生成\n\n问题陈述，切割数据 $y_{g,i}$ 必须由一个固定的、隐藏的预言机生成。我们通过选择固定的整数系数向量来定义这些预言机分子。我们选择：\n-   $c_a^{\\text{true}} = (3, 5, -2, 1, 8, 4)$\n-   $c_b^{\\text{true}} = (7, -1, 0, 6, -3, 2)$\n\n第三个系数向量由雅可比恒等式确定：\n-   $c_c^{\\text{true}} = -c_a^{\\text{true}} - c_b^{\\text{true}} = (-10, -4, 2, -7, -5, -6)$\n\n对于任何给定的运动学点 $x_i$ 和素数 $p$，切割数据生成为 $y_{g,i} = (M(x_i) \\cdot c_g^{\\text{true}}) \\pmod p$。这确保了提供的输入数据与底层的CK对偶结构内部一致。\n\n### 3. 有限域线性系统求解器\n\n为求解模素数 $p$ 的方程 $A_{sys} \\cdot C = Y_{sys}$，我们实现高斯-若尔当消元法。该算法将增广矩阵 $[A_{sys} | Y_{sys}]$ 转换为其简化行阶梯形（RREF），从中可以直接提取解。所有算术运算（加、减、乘、除）都在模 $p$ 的意义下进行。除以一个元素 $d$ 被替换为乘以其模乘法逆元 $d^{-1} \\pmod p$。由于 $p$ 是素数，费马小定理保证了对于任何 $d \\not\\equiv 0 \\pmod p$，其模逆元 $d^{-1} \\equiv d^{p-2} \\pmod p$。\n\n算法逐列进行，使用行主元选择（交换行以将非零元素带到主元位置）来确保使用非零主元进行消元。将系统转换为RREF后：\n-   对于唯一确定系统（独立方程数等于变量数），增广矩阵的左侧部分变为 $12 \\times 12$ 的单位矩阵，右侧部分包含 $C$ 的唯一解。\n-   对于相容的超定系统（独立方程数多于变量数），RREF在系数矩阵部分的底部将有零行。相容性要求增广部分的相应条目也为零。唯一解从非零行中读取。\n-   不相容系统将产生形如 $(0, \\dots, 0 | d)$ 且 $d \\not\\equiv 0 \\pmod p$ 的行，表示无解。\n\n### 4. 重构与验证\n\n一旦求解器返回系数向量 $C$，我们提取重构的系数 $c_a^{\\text{recon}}$、$c_b^{\\text{recon}}$。然后我们计算 $c_c^{\\text{recon}} = -c_a^{\\text{recon}} - c_b^{\\text{recon}} \\pmod p$。这三个向量定义了重构的分子多项式 $n_g^{\\text{recon}}(x)$。\n\n验证在另一组点 $x_v$ 上进行。对于每个验证点，我们执行两个检查：\n1.  **切割一致性**：我们计算我们重构的分子值 $n_g^{\\text{recon}}(x_v)$，并与预言机值 $y_g(x_v) = (M(x_v) \\cdot c_g^{\\text{true}}) \\pmod p$ 进行比较。仅当对于所有 $g \\in \\{a,b,c\\}$ 和所有验证点，$n_g^{\\text{recon}}(x_v) \\equiv y_g(x_v) \\pmod p$ 时，重构才有效。\n2.  **雅可比恒等式**：我们验证重构分子的和模 $p$ 为零：$(n_a^{\\text{recon}}(x_v) + n_b^{\\text{recon}}(x_v) + n_c^{\\text{recon}}(x_v)) \\equiv 0 \\pmod p$。根据我们对 $c_c^{\\text{recon}}$ 的构造，这个代数恒等式对于多项式本身是保证成立的，因此在任何求值点都成立。此检查用作验证重构过程内部逻辑的手段。\n\n当且仅当所有验证点都通过这两项检查时，一个测试用例才被认为是成功的（评估为 `True`）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for numerator reconstruction and validation.\n    \"\"\"\n\n    # Oracle Definition: Hidden, true coefficient vectors for the numerators.\n    # These are fixed for all test cases to ensure reproducibility.\n    TRUE_CA = np.array([3, 5, -2, 1, 8, 4], dtype=np.int64)\n    TRUE_CB = np.array([7, -1, 0, 6, -3, 2], dtype=np.int64)\n    TRUE_CC = -(TRUE_CA + TRUE_CB)\n\n    def monomial_basis_eval(x_point):\n        \"\"\"Evaluates the monomial basis M(x) at a given point x.\"\"\"\n        s12, s23, s34, l1, l2 = x_point\n        return np.array([1, s12, s23, s34, l1, l2], dtype=np.int64)\n\n    def evaluate_numerator(coeffs, x_point, p):\n        \"\"\"Evaluates a numerator polynomial n(x) = M(x) . c at a point x mod p.\"\"\"\n        m_vec = monomial_basis_eval(x_point)\n        # Use Python's arbitrary-precision integers for dot product before modulo\n        val = np.dot(m_vec, coeffs)\n        return int(val % p)\n\n    def generate_cut_data(x_point, p):\n        \"\"\"Generates oracle cut data (y_a, y_b, y_c) for a given point x and prime p.\"\"\"\n        y_a = evaluate_numerator(TRUE_CA, x_point, p)\n        y_b = evaluate_numerator(TRUE_CB, x_point, p)\n        y_c = evaluate_numerator(TRUE_CC, x_point, p)\n        return y_a, y_b, y_c\n\n    def mod_inv(n, p):\n        \"\"\"Computes the modular multiplicative inverse of n modulo p using Fermat's Little Theorem.\"\"\"\n        return pow(n, p - 2, p)\n\n    def solve_modular_linear_system(A, b, p):\n        \"\"\"\n        Solves the linear system Ax = b over the finite field F_p using Gauss-Jordan elimination.\n        A is an m x n matrix, b is an m-element vector.\n        Returns the solution vector x if a unique solution exists, otherwise None.\n        \"\"\"\n        m, n = A.shape\n        # Use python lists of lists of standard ints for safe modular arithmetic\n        aug = [list(map(int, A[i])) + [int(b[i])] for i in range(m)]\n\n        pivot_row = 0\n        for j in range(n):  # Iterate through columns (variables)\n            if pivot_row == m:\n                break\n\n            # Find a row with a non-zero pivot in the current column\n            i = pivot_row\n            while i  m and aug[i][j] == 0:\n                i += 1\n\n            if i  m:  # Pivot found\n                aug[pivot_row], aug[i] = aug[i], aug[pivot_row]  # Swap rows\n\n                # Normalize the pivot row\n                pivot_val = aug[pivot_row][j]\n                inv_pivot = mod_inv(pivot_val, p)\n                for k in range(j, n + 1):\n                    aug[pivot_row][k] = (aug[pivot_row][k] * inv_pivot) % p\n\n                # Eliminate other entries in the current column\n                for i in range(m):\n                    if i != pivot_row:\n                        factor = aug[i][j]\n                        if factor == 0: continue\n                        for k in range(j, n + 1):\n                            aug[i][k] = (aug[i][k] - factor * aug[pivot_row][k]) % p\n                \n                pivot_row += 1\n        \n        # Check for inconsistencies in overdetermined systems\n        for i in range(pivot_row, m):\n            if aug[i][n] != 0:\n                return None  # No solution\n\n        # Check for unique solution (RREF should be [I_n; 0 | solution; 0])\n        if pivot_row  n:\n            return None # Not a unique solution\n        \n        solution = np.zeros(n, dtype=np.int64)\n        for i in range(n):\n            solution[i] = aug[i][n]\n            \n        return solution\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p\": 101,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2)],\n            \"validations\": [(3,1,4,1,5), (9,2,6,5,3), (10,20,30,40,50)],\n        },\n        {\n            \"p\": 97,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2), (4,5,6,7,8), (10,9,8,7,6)],\n            \"validations\": [(3,5,7,11,13), (6,5,4,3,2), (8,13,21,34,55)],\n        },\n        {\n            \"p\": 89,\n            \"samples\": [(0,0,0,0,0), (1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1)],\n            \"validations\": [(2,3,5,7,11), (13,17,19,23,29), (1,1,1,1,1)],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        sample_points = case[\"samples\"]\n        validation_points = case[\"validations\"]\n        \n        num_samples = len(sample_points)\n        num_unknowns = 12\n        \n        A_sys = np.zeros((3 * num_samples, num_unknowns), dtype=np.int64)\n        Y_sys = np.zeros(3 * num_samples, dtype=np.int64)\n\n        for i, point in enumerate(sample_points):\n            m_vec = monomial_basis_eval(point)\n            y_a, y_b, y_c = generate_cut_data(point, p)\n\n            # Equation for n_a: M(x_i) . c_a = y_a_i\n            A_sys[3*i, 0:6] = m_vec\n            Y_sys[3*i] = y_a\n\n            # Equation for n_b: M(x_i) . c_b = y_b_i\n            A_sys[3*i+1, 6:12] = m_vec\n            Y_sys[3*i+1] = y_b\n            \n            # Equation for n_c via CK: -M(x_i).c_a - M(x_i).c_b = y_c_i\n            A_sys[3*i+2, 0:6] = -m_vec\n            A_sys[3*i+2, 6:12] = -m_vec\n            Y_sys[3*i+2] = y_c\n            \n        C_recon = solve_modular_linear_system(A_sys, Y_sys, p)\n\n        if C_recon is None:\n            results.append(False)\n            continue\n            \n        c_a_recon = C_recon[0:6]\n        c_b_recon = C_recon[6:12]\n        c_c_recon = (-(c_a_recon + c_b_recon)) % p\n\n        case_is_valid = True\n        for point in validation_points:\n            # Oracle values at validation point\n            y_a_val, y_b_val, y_c_val = generate_cut_data(point, p)\n            \n            # Reconstructed numerator values at validation point\n            n_a_recon = evaluate_numerator(c_a_recon, point, p)\n            n_b_recon = evaluate_numerator(c_b_recon, point, p)\n            n_c_recon = evaluate_numerator(c_c_recon, point, p)\n            \n            # 1. Cut consistency check\n            if not (n_a_recon == y_a_val and n_b_recon == y_b_val and n_c_recon == y_c_val):\n                case_is_valid = False\n                break\n                \n            # 2. Jacobi identity check\n            if (n_a_recon + n_b_recon + n_c_recon) % p != 0:\n                case_is_valid = False\n                break\n        \n        if not case_is_valid:\n            results.append(False)\n            continue\n\n        results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}