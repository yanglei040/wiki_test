{
    "hands_on_practices": [
        {
            "introduction": "在进行任何散射振幅计算之前，我们必须首先用一种明确且无冗余的方式来描述散射事件的运动学构型。这个练习  探讨了如何使用一个最小的洛伦兹不变量集合来描述一个 $n$ 粒子散射过程。理解这个不变量的数目对于构建高效且通用的矩阵元生成器至关重要，因为它定义了任何振幅计算的基本输入空间。",
            "id": "3505457",
            "problem": "考虑一个在四维闵可夫斯基时空中的标准模型框架下的通用量子场论（QFT）树级散射过程。在自动化矩阵元生成中，代码必须使用由外部动量构建的洛伦兹不变量来表示运动学。设一个 $2 \\to 2$ 的无质量散射过程，其入射四维动量为 $p_{1}$ 和 $p_{2}$，出射四维动量为 $p_{3}$ 和 $p_{4}$，所有动量均满足 $p_{i}^{2} = 0$ 以及总动量守恒 $\\sum_{i=1}^{4} p_{i} = 0$。从第一性原理出发定义正则曼德尔施塔姆不变量，并推导在无质量情况下它们之间的依赖关系。\n\n然后，推广到四维空间中的 $n$ 点无质量振幅，其中有 $n \\geq 4$ 个外部类光动量 $\\{p_{1},\\dots,p_{n}\\}$，满足 $p_{i}^{2} = 0$ 和 $\\sum_{i=1}^{n} p_{i} = 0$。严格地从在壳条件、总动量守恒和全局洛伦兹不变性出发，推导完全参数化（在一个全局洛伦兹变换的意义下）通用外部运动学所需的独立洛伦兹不变量的最小数量。构建一个仅由二粒子不变量 $s_{ij} \\equiv 2\\,p_{i}\\cdot p_{j}$ 组成的显式最小集，该集合适用于自动化代码，并证明其独立性。\n\n你的最终答案必须是关于 $n$ 的函数，表示独立不变量最小数量的单一闭合形式表达式。最终答案中不允许出现任何中间等式。如果你引入任何数值，除非有明确指示，否则不要四舍五入，此处无此要求。所有数学公式都用 LaTeX 表示，仅在需要时说明单位；此处不需要单位。如果出现角度，必须以弧度为单位；此处不需要角度。",
            "solution": "该问题要求推导在四维时空中参数化 $n$ 点无质量散射振幅运动学所需的独立洛伦兹不变量的最小数量。首先，将分析 $2 \\to 2$ 散射（$n=4$）的特定情况，然后推广到任意 $n \\geq 4$。\n\n给定的约束条件是所有外部四维动量 $\\{p_1, \\dots, p_n\\}$ 都是类光的（在壳且无质量），满足 $p_i^2 = 0$，并且总动量守恒，$\\sum_{i=1}^n p_i = 0$。后一种约定，即所有动量被平等对待（例如，全部视为入射或全部视为出射），是自动化矩阵元生成系统中的标准做法。洛伦兹不变量定义为 $s_{ij} \\equiv 2 p_i \\cdot p_j$。请注意，在在壳条件 $p_i^2=0$ 下，另一种常见的定义 $s_{ij} \\equiv (p_i+p_j)^2$ 是等价的，因为 $(p_i+p_j)^2 = p_i^2 + p_j^2 + 2 p_i \\cdot p_j = 0 + 0 + 2 p_i \\cdot p_j = s_{ij}$。\n\n**第一部分：$2 \\to 2$ 散射（$n=4$）分析**\n\n对于一个无质量粒子的 $2 \\to 2$ 过程，我们有四个动量 $p_1, p_2, p_3, p_4$，它们满足 $p_i^2 = 0$（其中 $i \\in \\{1,2,3,4\\}$）和 $p_1+p_2+p_3+p_4=0$。\n问题要求定义正则曼德尔施塔姆不变量。在物理散射过程 $p_1 + p_2 \\to p_3' + p_4'$ 中，动量守恒为 $p_1+p_2 = p_3'+p_4'$。为了与问题的约定 $\\sum p_i=0$ 匹配，我们将出射的物理动量定义为 $p_3 = -p_3'$ 和 $p_4 = -p_4'$。标准的曼德尔施塔姆变量是：\n$$s = (p_1+p_2)^2$$\n$$t = (p_1-p_3')^2 = (p_1+p_3)^2$$\n$$u = (p_1-p_4')^2 = (p_1+p_4)^2$$\n使用在壳条件 $p_i^2=0$，它们变为：\n$$s = 2 p_1 \\cdot p_2 = s_{12}$$\n$$t = 2 p_1 \\cdot p_3 = s_{13}$$\n$$u = 2 p_1 \\cdot p_4 = s_{14}$$\n为了找出它们之间的依赖关系，我们使用动量守恒定律。将 $p_1$ 与守恒方程 $\\sum_{j=1}^4 p_j=0$ 做点积，我们得到：\n$$p_1 \\cdot (p_1+p_2+p_3+p_4) = 0$$\n$$p_1^2 + p_1 \\cdot p_2 + p_1 \\cdot p_3 + p_1 \\cdot p_4 = 0$$\n由于 $p_1^2=0$，并使用 $s_{ij}$ 的定义，这得出：\n$$\\frac{1}{2}s_{12} + \\frac{1}{2}s_{13} + \\frac{1}{2}s_{14} = 0$$\n$$s+t+u = 0$$\n这是无质量 $2 \\to 2$ 散射的著名关系。它表明三个曼德尔施塔姆变量中只有两个是独立的。例如，给定 $s$ 和 $t$，$u$ 就被确定了。因此，对于 $n=4$，独立不变量的最小数量是 $2$。\n\n**第二部分：推广到 $n$ 点振幅**\n\n我们现在推导在 $D=4$ 维中指定通用 $n$ 点无质量散射过程运动学所需的独立洛伦兹不变量的最小数量。这类不变量的数量等于运动学构型模空间的维数。我们可以通过计算总自由度并减去由约束和对称性移除的自由度来计算这个维数。\n\n1.  **初始自由度**：我们从 $n$ 个四维矢量 $\\{p_1, \\dots, p_n\\}$ 开始。每个四维矢量 $p_i$ 有 $D=4$ 个分量。因此，初始变量的总数为 $n \\times D = 4n$。\n\n2.  **约束条件**：该系统受两种类型的物理约束：\n    *   **在壳条件**：每个粒子都是无质量且在壳的，意味着其四维动量的平方为零：$p_i^2 = 0$。这提供了 $n$ 个独立的标量方程。\n    *   **动量守恒**：总动量是守恒的：$\\sum_{i=1}^n p_i = 0$。这是一个矢量方程，提供了 $D=4$ 个独立的标量约束。\n\n    施加这些约束后剩余的变量数量为 $4n - n - 4 = 3n - 4$。\n\n3.  **对称性冗余**：物理散射振幅与观察者的惯性参考系无关。因此，运动学仅在全局洛伦兹变换的意义下是确定的。这类变换的集合构成洛伦兹群 $SO(1, D-1)$。该群的参数（或生成元）数量为 $\\binom{D}{2}$。对于 $D=4$，参数数量为 $\\binom{4}{2} = 6$（三个空间旋转和三个洛伦兹助推）。这些变换不改变洛伦兹不变量，因此我们上面计算的 $3n-4$ 个变量不是独立的不变量。我们必须减去洛伦兹群的参数数量，以找到不变量空间的维数。\n\n4.  **不变量的最小数量**：独立洛伦兹不变量的最小数量是运动学变量的数量减去洛伦兹群的参数数量：\n    $$N_{\\text{indep}} = (nD - n - D) - \\binom{D}{2}$$\n    代入 $D=4$：\n    $$N_{\\text{indep}} = (4n - n - 4) - \\binom{4}{2} = (3n - 4) - 6 = 3n - 10$$\n    该公式对 $n \\ge 4$ 有效。对于 $n=4$，它正确地得出 $3(4) - 10 = 2$。对于 $n=5$，它得出 $3(5) - 10 = 5$。\n\n**一个显式最小集的构建**\n\n问题要求构建一个由 $3n-10$ 个形如 $s_{ij} = 2 p_i \\cdot p_j$ 的独立不变量组成的显式最小集。这类不变量的总数为 $\\binom{n}{2}$，对于 $n>4$，这个数大于 $3n-10$。这意味着在 $s_{ij}$ 之间存在非平凡的关系。这些关系源于两个方面：\n1.  **线性约束**：根据动量守恒，对于任何 $i \\in \\{1, \\dots, n\\}$，我们有 $\\sum_{j \\neq i} s_{ij} = 2 p_i \\cdot \\sum_{j \\neq i} p_j = 2 p_i \\cdot (-p_i) = -2 p_i^2 = 0$。这类关系中有 $n-1$ 个是独立的。\n2.  **非线性约束**：动量存在于 $D=4$ 维时空这一事实施加了进一步的非线性约束，称为格拉姆行列式条件。对于任何 $k>D$ 个矢量的集合，其格拉姆矩阵（点积矩阵）的行列式必须为零。由于动量守恒，所有 $n$ 个动量的格拉姆矩阵的秩最多为 $D-1=3$。这些条件导致了 $s_{ij}$ 之间复杂的多项式关系。\n\n构建一个基需要仔细选择 $s_{ij}$，以避免所有此类线性和非线性依赖关系。对于通用运动学（即不局限于低维子空间）和 $n \\ge 4$，一个由 $3n-10$ 个独立不变量组成的有效最小集的构造如下：\n$$ \\mathcal{B} = \\{s_{1,j} \\mid j=2, \\dots, n-2\\} \\cup \\{s_{2,j} \\mid j=3, \\dots, n-1\\} \\cup \\{s_{3,j} \\mid j=4, \\dots, n-1\\} $$\n我们来验证这个集合的大小。元素数量为：\n$$ ( (n-2) - 2 + 1 ) + ( (n-1) - 3 + 1 ) + ( (n-1) - 4 + 1 ) = (n-3) + (n-3) + (n-4) = 3n-10 $$\n对于 $n \\ge 5$，这个计数是正确的。对于边界情况 $n=4$，该集合为 $\\{s_{1,2}\\} \\cup \\{s_{2,3}\\} \\cup \\emptyset$，给出两个不变量 $\\{s_{12}, s_{23}\\}$。这是一个有效的基，因为 $s_{13}$ 可以通过线性关系确定（例如，$s_{13}=s_{24}$ 和 $s_{12}+s_{13}+s_{14}=0$）。\n\n在形式上证明此集合对于通用运动学的独立性并非易事，但可以直观地理解。涉及 $p_1, p_2, p_3$ 的不变量用于建立一个“参考系”，而其余的不变量则相对于此参考系定位其他动量 $p_4, \\dots, p_{n-1}$（$p_n$ 则由动量守恒确定）。选择特定的下标是为了避免最简单的依赖关系，同时又能张成整个 $3n-10$ 维空间。\n\n问题要求的最终答案是关于 $n$ 的函数，表示独立不变量最小数量的单一闭合形式表达式。根据自由度的计算，这个数量是 $3n-10$。",
            "answer": "$$\\boxed{3n-10}$$"
        },
        {
            "introduction": "一个自动化的矩阵元生成器首先会枚举一个过程所有可能的费曼图，但其中许多在拓扑上是完全相同的。这个练习  深入探讨了自动化过程的计算机科学核心：利用图论来识别和消除重复的图。通过实现一个规范化算法，您将学习如何避免冗余计算，这是优化性能的关键一步，特别是对于涉及多粒子末态的过程。",
            "id": "3505556",
            "problem": "您的任务是为非阿贝尔规范理论中的树级费曼图拓扑设计并验证一个规范化模块，重点是自动化矩阵元生成。在杨-米尔斯（Yang–Mills）理论的树级水平上，纯胶子图可以表示为无向树，其中内部相互作用顶点的度为 $3$（三次表示），外部腿（胶子）对应于度为 $1$ 的叶节点。当且仅当两个这样的树作为无标记图是同构的，它们才表示相同的图拓扑。计算问题在于，通过算法识别并合并由图同构产生的重复项，这是自动化矩阵元生成中避免对相同拓扑进行冗余评估的关键步骤。\n\n从以下基本基础出发：\n\n- 图同构的定义：如果存在一个双射 $\\phi: V \\to V'$，使得对于每个无序对 $\\{u,v\\} \\subset V$，当且仅当 $\\{\\phi(u),\\phi(v)\\} \\in E'$ 时，有 $\\{u,v\\} \\in E$，那么两个无向图 $G = (V,E)$ 和 $G' = (V',E')$ 是同构的。\n- 树的概念：一个无向连通无环图。\n- 一个组合学事实：当一个有 $n$ 个叶节点的满二叉有根树通过抑制根节点（将其两条关联边收缩为一条）转换为无根树时，会产生一个无根树，其内部顶点度均为 $3$，叶节点度均为 $1$；这是树级胶子图的标准三次表示。\n- 经过充分检验的树同构方法，该方法通过使用中心和有根规范编码来生成规范形式，其中树的中心是通过迭代移除叶节点直到剩下一个或两个节点来获得的。\n\n您的程序必须：\n\n1. 为无向树实现一个规范化例程，该例程为同构树返回相同的规范字符串表示，为非同构树返回不同的表示。该例程必须：\n   - 对于无根树，通过迭代移除叶节点来找到其中心。\n   - 对于有根树，通过收集子树的规范编码，对其进行排序，并用分隔符连接它们来递归计算规范编码。无根树的规范形式选择为在所有中心上取到的字典序最小的有根规范形式。\n2. 按如下方式生成表示 $n$-胶子树拓扑的树集合：\n   - 通过将 $n$ 个叶节点递归地分裂为 $k$ 和 $n-k$ 个叶节点（其中 $k \\in \\{1,\\dots,n-1\\}$），并组合左右子树，来枚举所有具有 $n$ 个叶节点的有序满二叉有根树。然后通过抑制根节点（移除根节点并将其两个子节点用一条边连接）将每棵树转换为无根三次树，从而生成一个内部节点度为 $3$、叶节点度为 $1$ 的无向树图。\n   - 创建带有随机节点标签排列的集合以模拟随机标记。为此，必须在节点标识符上应用随机双射，以生成相同拓扑的同构副本。\n3. 使用规范化例程将每个集合压缩为唯一的拓扑，并报告找到的不同规范代表元的数量。\n\n设计选择必须源于上述定义，并且不得依赖任何现成的图同构库。所有图操作都应在您的代码中明确实现。\n\n测试套件和要求输出：\n\n实现以下测试案例，每个案例生成一个整数，表示在所述集合中找到的唯一拓扑的数量：\n- 案例 A（标签不变性验证）：对于 $n = 7$，选择一个由上述枚举生成的任意无根三次树，然后通过应用 $50$ 个独立的、均匀随机的节点标识符排列来生成 $M = 50$ 个同构副本。计算每个副本的规范形式，并统计唯一规范代表元的数量。这应当能验证同构的重新标记被合并。使用固定的伪随机种子以确保结果是确定性的。\n- 案例 B（标准枚举）：对于 $n = 6$，枚举所有具有 $n$ 个叶节点的有序满二叉有根树，将每棵树转换为无根三次树，进行规范化，并统计唯一代表元的数量。\n- 案例 C（复杂度增长）：与案例 B 相同，但 $n = 7$。\n- 案例 D（增加覆盖范围）：与案例 B 相同，但 $n = 8$。\n- 案例 E（边界情况）：与案例 B 相同，但 $n = 3$。\n\n您的程序应生成单行输出，其中包含按 [案例 A, 案例 B, 案例 C, 案例 D, 案例 E] 顺序排列的结果，形式为逗号分隔的列表并用方括号括起，例如，“[1,2,3,6,1]”。不涉及物理单位，也不涉及角度。所有输出均为整数。",
            "solution": "所提出的问题涉及在非阿贝尔规范理论（如杨-米尔斯理论）的自动化矩阵元生成背景下，对树级费曼图拓扑进行规范化。在树级水平上，纯胶子散射振幅由一类特定的图表示：无根、无向树，其中所有内部顶点的度为 $3$，外部粒子（胶子）对应于度为 $1$ 的叶节点。基本的计算挑战在于，枚举过程中产生的许多不同的标记图可能对应于相同的底层物理拓扑。识别并消除这些重复项对于效率至关重要。这正是应用于此特定树族的图同构问题。\n\n解决方案基于为每棵树定义一个规范表示的原则。规范形式是图的整个同构类的唯一字符串或标签。当且仅当两个图的规范形式相同时，它们才是同构的。该问题指定了一种稳健、标准的树规范化算法，该算法利用了树的结构特性，即其中心。\n\n**理论与算法框架**\n\n1.  **图表示**：使用邻接表来表示无向图，具体来说是一个字典，其中键是整数顶点标识符，值是相邻顶点标识符的列表。\n\n2.  **拓扑生成**：通过枚举所有具有 $n$ 个叶节点的*有序满二叉有根树*来生成候选拓扑的初始集合。此类树的数量是第 $(n-1)$ 个卡特兰数 $C_{n-1}$。此枚举是递归执行的：为了形成一个有 $n$ 个叶节点的树，我们将一个有 $k$ 个叶节点的左子树和一个有 $n-k$ 个叶节点的右子树组合起来，其中 $k \\in \\{1, 2, \\dots, n-1\\}$。然后，每个抽象树结构被实现为一个具体的图。构建一个有 $n$ 个叶节点和 $n-1$ 个内部节点的有根图，总共有 $2n-1$ 个顶点。然后，通过“抑制根节点”将此有根树转换为所需的无根三次树表示。此操作涉及移除根顶点并用一条新边连接其两个子节点。最终得到的图有 $n$ 个叶节点（度为 $1$）和 $n-2$ 个内部顶点（度为 $3$），精确地模拟了 $n$-胶子树级相互作用。\n\n3.  **通过树中心进行规范化**：解决方案的核心是规范化标记算法，该算法分三步进行：\n    a. **寻找中心**：无根树的中心提供了一个独特的结构参考点。它由一个顶点（单中心树）或两个相邻顶点（双中心树）组成。中心是通过迭代剪枝算法找到的：移除所有度为 $1$ 的顶点（叶节点）。在得到的较小树上重复此过程，直到只剩下一个或两个顶点。这些最后的顶点构成中心。\n    b. **有根规范形式**：一旦树在概念上以某个顶点为“根”，其规范形式就可以递归计算。对于给定节点，首先计算其子节点下悬挂的子树的规范形式。然后将得到的这些字符串按字典序排序并连接起来，用定界符（在本实现中为括号）括起来，形成该节点的规范字符串。叶节点没有子节点，其基本规范形式为 `()`。递归定义如下：\n    $$\n    \\text{CanonicalForm}(\\text{node}) = \\text{\"(\"} + \\text{sorted\\_join}(\\{\\text{CanonicalForm}(\\text{child}_i)\\}) + \\text{\")\"}\n    $$\n    c. **无根规范形式**：原始无根树的规范形式由其中心确定。它被定义为字典序*最小*的有根规范形式，其中候选形式是通过将树的根分别定在其每个中心顶点上生成的。如果中心是单个顶点 $c$，则只有一个候选形式。如果中心是一对顶点 $\\{c_1, c_2\\}$，我们计算分别以 $c_1$ 和 $c_2$ 为根的有根规范形式，并选择字典序较小的字符串。此过程确保了对于任何给定的树拓扑，无论初始顶点标记如何，都能得到唯一的结果。\n\n4.  **测试套件与验证**：该算法通过一个指定的测试套件进行验证：\n    *   **案例 A（$n=7$，标签不变性）**：此案例作为一个健全性检查。创建一个单一的树拓扑，并通过对其顶点标签应用随机排列生成 $M=50$ 个同构副本。一个正确的规范化算法必须将所有这些标签不同但结构相同的图映射到同一个规范字符串。因此，唯一代表元的数量必须为 $1$。\n    *   **案例 B, C, D, E（$n=6, 7, 8, 3$）**：这些案例测试完整的枚举和规范化流程。对于每个 $n$，生成所有有序二叉树，将其转换为无根三次树，并进行规范化。找到的唯一规范形式的数量对应于具有 $n$ 个叶节点的、不同的无标记三次树的数量。这些数量在组合学中是已知的，为算法的正确性提供了明确的验证。对于 $n=3, 6, 7, 8$，不同树拓扑的预期数量分别为 $1, 2, 3, 6$。\n\n该实现将这些原则封装到一组函数中，这些函数用于生成、操作和规范化树图，最终计算出每个测试案例所需的计数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nimport sys\n\n# It is necessary to increase the recursion limit for deeper tree structures\n# that can arise during generation, particularly for n=8.\nsys.setrecursionlimit(3000)\n\n_memo_generate_trees = {}\n\ndef generate_ordered_binary_trees(n):\n    \"\"\"\n    Recursively generates all ordered full binary trees with n leaves.\n    The trees are represented as nested tuples, where () is a leaf.\n    Uses memoization to avoid recomputing for the same n.\n    \"\"\"\n    if n in _memo_generate_trees:\n        return _memo_generate_trees[n]\n    if n == 1:\n        return [()]  # A leaf is represented by an empty tuple\n    \n    trees = []\n    for k in range(1, n):\n        left_subtrees = generate_ordered_binary_trees(k)\n        right_subtrees = generate_ordered_binary_trees(n - k)\n        for L in left_subtrees:\n            for R in right_subtrees:\n                trees.append((L, R))\n    \n    _memo_generate_trees[n] = trees\n    return trees\n\ndef build_graph_from_tuple(tree_tuple, n_leaves):\n    \"\"\"\n    Converts a nested tuple representation of a rooted binary tree\n    into an adjacency list graph representation.\n    Leaves are labeled 0 to n-1, internal nodes from n upwards.\n    Returns the adjacency list and the ID of the root node.\n    \"\"\"\n    adj = defaultdict(list)\n    leaf_counter = [0]\n    internal_counter = [n_leaves]\n\n    def _build(subtree):\n        # Base case: a leaf node\n        if not subtree:\n            node_id = leaf_counter[0]\n            leaf_counter[0] += 1\n            return node_id\n\n        # Recursive step: an internal node\n        node_id = internal_counter[0]\n        internal_counter[0] += 1\n        \n        left_id = _build(subtree[0])\n        right_id = _build(subtree[1])\n\n        adj[node_id].append(left_id)\n        adj[left_id].append(node_id)\n        adj[node_id].append(right_id)\n        adj[right_id].append(node_id)\n        \n        return node_id\n\n    root_id = _build(tree_tuple)\n    return dict(adj), root_id\n\ndef convert_to_unrooted(adj, root_id):\n    \"\"\"\n    Converts a rooted binary tree graph to an unrooted cubic tree by\n    suppressing the root: removing the root and connecting its two children.\n    \"\"\"\n    unrooted_adj = {k: list(v) for k, v in adj.items()}\n    \n    # A tree with n=2 leaves becomes a single edge between the leaves.\n    if len(adj) == 3 and n_leaves_from_adj(adj) == 2:\n        leaves = [k for k, v in adj.items() if len(v) == 1]\n        l1, l2 = leaves\n        return {l1: [l2], l2: [l1]}\n\n    if root_id not in unrooted_adj or len(unrooted_adj[root_id]) != 2:\n         # This block handles simple cases or malformed inputs gracefully.\n         # For n=3+, the root will always have 2 children in our generation scheme.\n         return unrooted_adj\n\n    c1, c2 = unrooted_adj[root_id]\n    \n    del unrooted_adj[root_id]\n    \n    unrooted_adj[c1].remove(root_id)\n    unrooted_adj[c2].remove(root_id)\n    \n    unrooted_adj[c1].append(c2)\n    unrooted_adj[c2].append(c1)\n    \n    return unrooted_adj\n\ndef find_center(adj):\n    \"\"\"\n    Finds the center(s) of a tree by iteratively removing leaves.\n    Returns a list containing one or two central node IDs.\n    \"\"\"\n    if not adj:\n        return []\n    if len(adj) == 2:\n        return list(adj.keys())\n\n    nodes = set(adj.keys())\n    degrees = {node: len(neighbors) for node, neighbors in adj.items()}\n    \n    leaves = [node for node, deg in degrees.items() if deg == 1]\n    \n    count = len(leaves)\n    while len(nodes) - count > 0:\n        new_leaves = []\n        for leaf in leaves:\n            for neighbor in adj[leaf]:\n                degrees[neighbor] -= 1\n                if degrees[neighbor] == 1:\n                    new_leaves.append(neighbor)\n        count += len(new_leaves)\n        if not new_leaves:\n            break\n        leaves = new_leaves\n        \n    return leaves\n\ndef _rooted_canonical_form(adj, root, parent):\n    \"\"\"\n    Recursively computes the canonical string for a tree rooted at `root`.\n    `parent` is used to prevent traversing backwards.\n    \"\"\"\n    children = [n for n in adj.get(root, []) if n != parent]\n    if not children:\n        return \"()\"\n    \n    child_forms = []\n    for child in children:\n        child_forms.append(_rooted_canonical_form(adj, child, root))\n    \n    child_forms.sort()\n    return \"(\" + \"\".join(child_forms) + \")\"\n\ndef get_canonical_form(adj):\n    \"\"\"\n    Computes the canonical form of an unrooted tree by finding its center(s)\n    and choosing the lexicographically minimal rooted representation.\n    \"\"\"\n    if not adj: return \"\"\n    if len(adj) == 1: return \"()\"\n\n    centers = find_center(adj)\n    \n    candidate_forms = []\n    for c in centers:\n        # parent is set to a value guaranteed not to be a node ID\n        candidate_forms.append(_rooted_canonical_form(adj, c, -1))\n        \n    return min(candidate_forms)\n\ndef n_leaves_from_adj(adj):\n    \"\"\"Helper to count leaves (degree-1 nodes) in a graph.\"\"\"\n    return sum(1 for node in adj if len(adj[node]) == 1)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        {'type': 'A', 'n': 7, 'M': 50},\n        {'type': 'B', 'n': 6},\n        {'type': 'C', 'n': 7},\n        {'type': 'D', 'n': 8},\n        {'type': 'E', 'n': 3},\n    ]\n\n    results = []\n    \n    # Pre-clear memoization for clean runs if solve() were called multiple times\n    _memo_generate_trees.clear()\n\n    for case in test_cases_params:\n        n = case['n']\n        \n        if case['type'] == 'A':\n            # Case A: Validate canonicalization on isomorphic graphs\n            canonical_forms = set()\n            # Generate a single representative tree for n=7\n            # We pick the first one generated for simplicity.\n            first_tree_tuple = generate_ordered_binary_trees(n)[0]\n            base_adj, root_id = build_graph_from_tuple(first_tree_tuple, n)\n            base_unrooted_adj = convert_to_unrooted(base_adj, root_id)\n            \n            canonical_forms.add(get_canonical_form(base_unrooted_adj))\n            \n            # Generate M isomorphic copies by permuting node labels\n            nodes = sorted(list(base_unrooted_adj.keys()))\n            num_nodes = len(nodes)\n            rng = np.random.default_rng(seed=42) # for deterministic result\n            \n            for _ in range(case['M']):\n                perm = rng.permutation(nodes)\n                mapping = {old: new for old, new in zip(nodes, perm)}\n                \n                permuted_adj = defaultdict(list)\n                for u, neighbors in base_unrooted_adj.items():\n                    new_u = mapping[u]\n                    for v in neighbors:\n                        new_v = mapping[v]\n                        permuted_adj[new_u].append(new_v)\n                \n                canonical_forms.add(get_canonical_form(dict(permuted_adj)))\n\n            results.append(len(canonical_forms))\n\n        else:\n            # Cases B, C, D, E: Enumerate and count unique topologies\n            ordered_trees = generate_ordered_binary_trees(n)\n            canonical_forms = set()\n\n            for tree_tuple in ordered_trees:\n                adj, root_id = build_graph_from_tuple(tree_tuple, n)\n                unrooted_adj = convert_to_unrooted(adj, root_id)\n                form = get_canonical_form(unrooted_adj)\n                canonical_forms.add(form)\n\n            results.append(len(canonical_forms))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的代码实现不仅要高效，还必须在物理上准确，尤其是在处理像标准模型这样复杂的规范理论时。这项实践  通过验证戈德斯通玻色子等效定理，提供了一个强有力的数值测试来检验底层物理的正确性。通过比较纵向极化的 $W$ 玻色子与其对应的戈德斯通玻色子在高能下的行为，您将亲身体验电弱物理的精妙之处以及验证在计算物理中的重要性。",
            "id": "3505533",
            "problem": "你的任务是设计并实现一个完整、可运行的程序，通过比较高能下 $f\\bar f \\to W_L^+ W_L^-$ 和 $f\\bar f \\to \\phi^+ \\phi^-$ 过程的非极化、自旋平均的矩阵元平方，在树图层面数值上检验戈德斯通玻色子等效性定理，同时量化有限能量下的偏差。背景是标准模型 (SM) 的电弱部分，在费曼规范下的树图层面，所有外部费米子被视为无质量，并忽略粒子宽度。你必须基于量子场论和标准模型 (SM) 中经过充分检验的公式和定义，从第一性原理出发。\n\n从以下基础出发：\n- 使用符号为 $g_{\\mu\\nu} = \\mathrm{diag}(+1,-1,-1,-1)$ 的闵可夫斯基度规。\n- 对于无质量费米子，非极化、自旋求和并自旋平均的初态费米子流关联函数是\n$$\n\\frac{1}{4}\\sum_{\\text{spins}} J_\\mu^{(V)} J_\\nu^{(V')*} = \\frac{1}{2}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right) \\left(p_{2\\mu} p_{1\\nu} + p_{2\\nu} p_{1\\mu} - g_{\\mu\\nu}\\, p_1\\cdot p_2\\right),\n$$\n其中 $J_\\mu^{(V)} = \\bar v(p_2) \\gamma_\\mu (g_L^{(V)} P_L + g_R^{(V)} P_R) u(p_1)$ 且 $P_{L,R} = \\tfrac{1}{2}(1 \\mp \\gamma^5)$。\n- 对于通过 s 道中性规范玻色子交换 $V \\in \\{\\gamma, Z\\}$ 的过程 $f\\bar f \\to \\phi^+ \\phi^-$，标量流是导数耦合的：$V\\phi\\phi$ 顶点为 $i g_{V\\phi} (k_+ - k_-)^\\mu$。\n- 对于通过 s 道 $V \\in \\{\\gamma,Z\\}$ 交换的过程 $f\\bar f \\to W^+ W^-$，三线性规范顶点是\n$$\n\\Gamma_{\\mu\\alpha\\beta}(q,k_+,k_-) = (k_- - k_+)_\\mu g_{\\alpha\\beta} + (q - 2 k_-)_\\alpha g_{\\beta\\mu} + (2 k_+ - q)_\\beta g_{\\mu\\alpha},\n$$\n其中 $q = p_1 + p_2 = k_+ + k_-$，并且矢量玻色子传播子取为 $-i g_{\\mu\\nu}/(s - m_V^2)$。\n- 对于质量为 $m_W$、四动量为 $k^\\mu = (E,\\vec{k})$ 的在壳 $W$ 玻色子，其纵向极化矢量为\n$$\n\\varepsilon_L^\\mu(k) = \\left(\\frac{|\\vec{k}|}{m_W}, \\frac{E}{m_W}\\,\\hat{k}\\right),\n$$\n其中 $\\hat{k} = \\vec{k}/|\\vec{k}|$，满足 $\\varepsilon_L\\cdot k = 0$ 和 $\\varepsilon_L^2 = -1$。\n- 树图层面的电弱耦合：\n    - 电荷 $e = \\sqrt{4\\pi \\alpha_{\\mathrm{em}}}$。\n    - 弱混合：$\\cos\\theta_W = m_W/m_Z$、$\\sin^2\\theta_W = 1 - \\cos^2\\theta_W$ 以及 $g = e/\\sin\\theta_W$。\n    - 初态费米子取为上夸克 $f = u$：电荷 $Q_f = +\\tfrac{2}{3}$，左手征分量的弱同位旋为 $T_3^f = +\\tfrac{1}{2}$，右手征分量的弱同位旋为 $T_3^f = 0$。中性流的手征耦合为\n      $$\n      g_L^{(Z)} = \\frac{g}{\\cos\\theta_W}\\left(T_3^f - Q_f \\sin^2\\theta_W\\right),\\quad\n      g_R^{(Z)} = -\\frac{g}{\\cos\\theta_W}\\,Q_f \\sin^2\\theta_W,\n      $$\n      对于光子，$g_L^{(\\gamma)} = g_R^{(\\gamma)} = e Q_f$。\n    - 戈德斯通玻色子耦合：对于作为希格斯二重态的带电分量 $\\phi^\\pm$，$T_3^\\phi = +\\tfrac{1}{2}$ 且 $Q_\\phi=+1$，\n      $$\n      g_{Z\\phi} = \\frac{g}{\\cos\\theta_W}\\left(T_3^\\phi - \\sin^2\\theta_W Q_\\phi\\right) = \\frac{g}{\\cos\\theta_W}\\left(\\tfrac{1}{2} - \\sin^2\\theta_W\\right),\\quad g_{\\gamma\\phi} = e Q_\\phi = e.\n      $$\n    - 三线性规范耦合：$g_{\\gamma WW} = e$，$g_{ZWW} = e \\cot\\theta_W$。\n\n你必须：\n1. 为 $f(p_1)\\bar f(p_2)\\to X(k_+) Y(k_-)$（其中 $X,Y\\in\\{W^+_L,W^-_L\\}$ 或 $X,Y\\in\\{\\phi^+,\\phi^-\\}$）构建质心系中的运动学。使用 $p_1^\\mu = (\\sqrt{s}/2,0,0,+\\sqrt{s}/2)$、$p_2^\\mu = (\\sqrt{s}/2,0,0,-\\sqrt{s}/2)$、$k_\\pm^\\mu = (E_W,\\pm |\\vec{k}|\\sin\\theta,0,\\pm |\\vec{k}|\\cos\\theta)$，其中 $E_W = \\sqrt{s}/2$ 且 $|\\vec{k}| = \\sqrt{E_W^2 - m_W^2}$。将戈德斯通玻色子的质量取为 $m_W$，这对应于费曼规范。\n2. 对于 $f\\bar f \\to \\phi^+ \\phi^-$，构建矢量\n$$\nS_V^\\mu = \\frac{g_{V\\phi}}{s - m_V^2} (k_+ - k_-)^\\mu,\\quad V\\in\\{\\gamma,Z\\},\\ m_\\gamma = 0.\n$$\n3. 对于 $f\\bar f \\to W_L^+ W_L^-$，构建矢量\n$$\nX_V^\\mu = \\frac{g_{VWW}}{s - m_V^2}\\left[(k_- - k_+ )^\\mu (\\varepsilon_+\\cdot \\varepsilon_-) + \\big((q - 2k_-)\\cdot \\varepsilon_+\\big)\\,\\varepsilon_-^\\mu + \\big((2k_+ - q)\\cdot \\varepsilon_- \\big)\\,\\varepsilon_+^\\mu \\right],\n$$\n其中 $\\varepsilon_\\pm^\\mu$ 是 $W^\\pm$ 的纵向极化矢量。\n4. 使用上述自旋平均的流关联函数，计算非极化、自旋平均的矩阵元平方为\n$$\n\\overline{|{\\cal M}|^2} = \\frac{1}{2}\\sum_{V,V'\\in\\{\\gamma,Z\\}}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right)\\left[p_2\\cdot A_V\\,\\, p_1\\cdot A_{V'} + p_2\\cdot A_{V'}\\,\\, p_1\\cdot A_V - (p_1\\cdot p_2)\\, A_V\\cdot A_{V'}\\right],\n$$\n其中，对于标量道，$A_V^\\mu$ 是 $S_V^\\mu$；对于纵向矢量道，$A_V^\\mu$ 是 $X_V^\\mu$。所有点积都是使用 $g_{\\mu\\nu}$ 的闵可夫斯基点积。\n5. 通过计算无量纲比率来量化有限能量下的偏差\n$$\n\\delta(s,\\cos\\theta) = \\frac{\\overline{|{\\cal M}(f\\bar f\\to W_L^+ W_L^-)|^2}}{\\overline{|{\\cal M}(f\\bar f\\to \\phi^+ \\phi^-)|^2}} - 1,\n$$\n根据戈德斯通玻色子等效性定理，当 $\\sqrt{s}\\to \\infty$ 时，该比率应趋近于 0。\n\n使用以下物理常数和约定：\n- $m_W = 80.379$ GeV, $m_Z = 91.1876$ GeV, $\\alpha_{\\mathrm{em}} = 1/127.95$, $m_\\gamma = 0$ GeV。\n- 所有能量单位必须是 GeV。角度必须通过无量纲的 $\\cos\\theta$ 指定。\n\n测试组：\n- 提供以下参数集 $(\\sqrt{s}\\,\\text{[GeV]}, \\cos\\theta)$ 的结果：\n  - $(200.0, 0.0)$,\n  - $(500.0, 0.3)$,\n  - $(1000.0, -0.7)$,\n  - $(3000.0, 0.9)$,\n  - $(170.0, 0.0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试组中的顺序相同，例如：$[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5]$。",
            "solution": "我们的目标是通过比较标准模型 (SM) 中树图层面下 $f\\bar f\\to W_L^+W_L^-$ 和 $f\\bar f\\to \\phi^+\\phi^-$ 过程的非极化、自旋平均的矩阵元平方，来检验戈德斯通玻色子等效性定理。该定理预测，对于 $\\sqrt{s}\\gg m_W$ 的情况，纵向极化矢量玻色子对的产生振幅应与相应戈德斯通玻色子对的产生振幅一致，其差异为被能量的逆幂次所压低的修正项。\n\n基于原理的设置：\n1. 运动学和度规。我们在质心 (CoM) 系中工作，使用闵可夫斯基度规 $g_{\\mu\\nu} = \\mathrm{diag}(+1,-1,-1,-1)$。入射动量为 $p_1^\\mu=(\\sqrt{s}/2,0,0,+\\sqrt{s}/2)$ 和 $p_2^\\mu=(\\sqrt{s}/2,0,0,-\\sqrt{s}/2)$。出射动量 $k_\\pm^\\mu$ 的能量为 $E_W=\\sqrt{s}/2$，三动量为 $\\vec{k}_\\pm = \\pm |\\vec{k}|(\\sin\\theta,0,\\cos\\theta)$，其中 $|\\vec{k}|=\\sqrt{E_W^2-m_W^2}$。我们在费曼规范中将戈德斯通玻色子的质量取为 $m_W$，以使 $W_L^+W_L^-$ 和 $\\phi^+\\phi^-$ 的运动学相同。总动量为 $q^\\mu=p_1^\\mu+p_2^\\mu=k_+^\\mu+k_-^\\mu$。\n\n2. 电弱耦合。在树图层面，电磁耦合为 $e=\\sqrt{4\\pi\\alpha_{\\mathrm{em}}}$，弱混合参数为 $\\cos\\theta_W = m_W/m_Z$、$\\sin\\theta_W = \\sqrt{1-\\cos^2\\theta_W}$ 以及 $g=e/\\sin\\theta_W$。对于初态的上夸克，中性流的手征耦合为\n$$\ng_L^{(Z)}=\\frac{g}{\\cos\\theta_W}\\left(T_3^f - Q_f\\sin^2\\theta_W\\right),\\quad g_R^{(Z)}=-\\frac{g}{\\cos\\theta_W}Q_f\\sin^2\\theta_W,\n$$\n其中 $Q_f=+\\tfrac{2}{3}$，左手征分量的 $T_3^f=+\\tfrac{1}{2}$，右手征分量的 $T_3^f=0$。对于光子，$g_L^{(\\gamma)}=g_R^{(\\gamma)}=eQ_f$。对于戈德斯通玻色子，$g_{\\gamma\\phi}=e Q_\\phi=e$ 且 $g_{Z\\phi}=\\frac{g}{\\cos\\theta_W}\\left(\\tfrac{1}{2}-\\sin^2\\theta_W\\right)$。对于三线性规范耦合，$g_{\\gamma WW}=e$ 且 $g_{ZWW}=e\\cot\\theta_W$。\n\n3. 纵向极化。有质量矢量玻色子的精确纵向极化矢量被选为\n$$\n\\varepsilon_L^\\mu(k) = \\left(\\frac{|\\vec{k}|}{m_W}, \\frac{E_W}{m_W}\\,\\hat{k}\\right),\n$$\n其中 $\\hat{k}=\\vec{k}/|\\vec{k}|$。在我们的度规下，它满足 $\\varepsilon_L\\cdot k=0$ 和 $\\varepsilon_L^2=-1$。\n\n4. 通过费曼规则计算振幅。对于 s 道交换 $V\\in\\{\\gamma,Z\\}$（传播子为 $-ig_{\\mu\\nu}/(s-m_V^2)$，耦合为实数），给定 V 的振幅可以分解为一个费米子流和一个末态结构的乘积。我们定义，对于标量道，\n$$\nS_V^\\mu = \\frac{g_{V\\phi}}{s-m_V^2}(k_+ - k_-)^\\mu,\n$$\n对于矢量道，\n$$\nX_V^\\mu = \\frac{g_{VWW}}{s-m_V^2}\\left[(k_- - k_+ )^\\mu (\\varepsilon_+\\cdot \\varepsilon_-) + \\big((q - 2k_-)\\cdot \\varepsilon_+\\big)\\,\\varepsilon_-^\\mu + \\big((2k_+ - q)\\cdot \\varepsilon_- \\big)\\,\\varepsilon_+^\\mu \\right],\n$$\n这是三线性顶点与纵向极化矢量缩并的结果。完整振幅是费米子流 $J_\\mu^{(V)}=\\bar v \\gamma_\\mu (g_L^{(V)}P_L+g_R^{(V)}P_R) u$ 对 $V\\in\\{\\gamma,Z\\}$ 的求和。\n\n5. 使用迹方法进行自旋平均。对于无质量费米子，非极化、自旋求和并自旋平均的流关联函数是\n$$\n\\frac{1}{4}\\sum_{\\text{spins}} J_\\mu^{(V)} J_\\nu^{(V')*} = \\frac{1}{2}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right) \\left(p_{2\\mu} p_{1\\nu} + p_{2\\nu} p_{1\\mu} - g_{\\mu\\nu}\\, p_1\\cdot p_2\\right).\n$$\n因此，非极化、自旋平均的振幅平方具有紧凑形式\n$$\n\\overline{|{\\cal M}|^2} = \\frac{1}{2}\\sum_{V,V'\\in\\{\\gamma,Z\\}}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right)\\left[p_2\\cdot A_V\\,\\, p_1\\cdot A_{V'} + p_2\\cdot A_{V'}\\,\\, p_1\\cdot A_V - (p_1\\cdot p_2)\\, A_V\\cdot A_{V'}\\right],\n$$\n其中，对于 $\\phi^+\\phi^-$ 道，$A_V^\\mu = S_V^\\mu$；对于 $W_L^+W_L^-$ 道，$A_V^\\mu = X_V^\\mu$。\n\n6. 戈德斯通玻色子等效性定理与偏差。等效性定理指出\n$$\n{\\cal M}(f\\bar f \\to W_L^+ W_L^-)\\;=\\;{\\cal M}(f\\bar f \\to \\phi^+ \\phi^-)\\;+\\;{\\cal O}\\!\\left(\\frac{m_W}{\\sqrt{s}}\\right),\n$$\n因此，在大 $\\sqrt{s}$ 时，非极化矩阵元平方的比率\n$$\n\\delta(s,\\cos\\theta) = \\frac{\\overline{|{\\cal M}(f\\bar f\\to W_L^+ W_L^-)|^2}}{\\overline{|{\\cal M}(f\\bar f\\to \\phi^+ \\phi^-)|^2}} - 1,\n$$\n趋于 $0$。有限能量修正是由于使用了精确的纵向极化矢量和完整的三线性顶点，而不是直接用 $\\phi$ 替代 $W_L$ 而产生的。\n\n算法实现：\n- 根据 $(\\sqrt{s},\\cos\\theta)$ 构建 $p_1$、$p_2$、$k_\\pm$ 的四动量，能量单位为 GeV。\n- 为纵向 $W^\\pm$ 构建 $\\varepsilon_\\pm^\\mu$。\n- 使用耦合和传播子，为每个 $V\\in\\{\\gamma,Z\\}$ 计算 $S_V^\\mu$ 和 $X_V^\\mu$。\n- 使用 $g_{\\mu\\nu}=\\mathrm{diag}(+1,-1,-1,-1)$ 计算所有闵可夫斯基点积。\n- 使用基于迹的张量缩并来组装两个道的 $\\overline{|{\\cal M}|^2}$：\n$$\nT_{\\mu\\nu} = p_{2\\mu}p_{1\\nu} + p_{2\\nu}p_{1\\mu} - g_{\\mu\\nu}\\,p_1\\cdot p_2,\n$$\n以及缩并\n$$\n{\\cal C}(A,B) = p_2\\cdot A\\, p_1\\cdot B + p_2\\cdot B\\, p_1\\cdot A - (p_1\\cdot p_2)\\, A\\cdot B.\n$$\n- 形成 $\\delta(s,\\cos\\theta)$ 并报告测试组的结果。\n\n参数选择：\n- $m_W = 80.379$ GeV, $m_Z = 91.1876$ GeV, $\\alpha_{\\mathrm{em}} = 1/127.95$, $m_\\gamma = 0$ GeV。\n- $\\cos\\theta_W = m_W/m_Z$, $\\sin^2\\theta_W = 1-\\cos^2\\theta_W$, $e=\\sqrt{4\\pi\\alpha_{\\mathrm{em}}}$, $g=e/\\sin\\theta_W$。\n- 上夸克初态：$Q_f=+\\tfrac{2}{3}$， $T_3^f=+\\tfrac{1}{2}$ (左手)，$T_3^f=0$ (右手)。\n\n测试组与输出：\n- 对以下有序列表中的 $(\\sqrt{s}\\,[\\mathrm{GeV}],\\cos\\theta)$ 求 $\\delta$ 值：\n  - $(200.0, 0.0)$,\n  - $(500.0, 0.3)$,\n  - $(1000.0, -0.7)$,\n  - $(3000.0, 0.9)$,\n  - $(170.0, 0.0)$。\n- 打印单行：一个用方括号括起来的逗号分隔列表，例如 $[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5]$。\n\n该构造严格遵循标准模型的费曼规则、洛伦兹不变性以及通过迹技术进行的自旋平均，从而确保了对两个道进行第一性原理的、规范不变的比较。在有限能量下的偏差量化了超出渐近高能极限的次领头修正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Minkowski metric with signature (+,-,-,-)\nETA = np.diag([1.0, -1.0, -1.0, -1.0])\n\ndef minkowski_dot(a, b):\n    \"\"\"Minkowski dot product with metric diag(+,-,-,-).\"\"\"\n    return float(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3])\n\ndef vector_add(a, b):\n    return a + b\n\ndef vector_sub(a, b):\n    return a - b\n\ndef scalar_mul(c, a):\n    return c * a\n\ndef polarization_longitudinal(k, m):\n    \"\"\"\n    Exact longitudinal polarization vector for a massive vector boson with 4-momentum k=(E,kx,ky,kz),\n    epsilon_L = (|k|/m, (E/m) * k_hat), where k_hat = k_vec / |k|.\n    \"\"\"\n    E = k[0]\n    kv = k[1:]\n    p = np.linalg.norm(kv)\n    if p == 0.0:\n        # At exact threshold, choose an arbitrary direction; here default z.\n        khat = np.array([0.0, 0.0, 1.0])\n    else:\n        khat = kv / p\n    eps0 = p / m\n    eps_spatial = (E / m) * khat\n    return np.array([eps0, eps_spatial[0], eps_spatial[1], eps_spatial[2]], dtype=float)\n\ndef build_kinematics(sqrt_s, cos_theta, mW):\n    \"\"\"\n    Build 4-vectors in the COM frame:\n    p1=(E,0,0,+E), p2=(E,0,0,-E),\n    k+ and k- with scattering angle theta and equal energies E_W = sqrt_s/2.\n    \"\"\"\n    Ecm = sqrt_s\n    E = Ecm / 2.0\n    p1 = np.array([E, 0.0, 0.0, +E], dtype=float)\n    p2 = np.array([E, 0.0, 0.0, -E], dtype=float)\n\n    # Final-state W momenta\n    EW = E\n    p_abs_sq = EW*EW - mW*mW\n    if p_abs_sq = 0:\n        p_abs = 0.0\n    else:\n        p_abs = np.sqrt(p_abs_sq)\n\n    # Ensure cos_theta within [-1,1]\n    ct = float(np.clip(cos_theta, -1.0, 1.0))\n    st_sq = max(0.0, 1.0 - ct*ct)\n    st = np.sqrt(st_sq)\n\n    k_plus = np.array([EW, +p_abs*st, 0.0, +p_abs*ct], dtype=float)\n    k_minus = np.array([EW, -p_abs*st, 0.0, -p_abs*ct], dtype=float)\n\n    return p1, p2, k_plus, k_minus\n\ndef build_couplings():\n    \"\"\"\n    Electroweak parameters and couplings.\n    \"\"\"\n    # Physical constants (GeV)\n    mW = 80.379\n    mZ = 91.1876\n    alpha_em = 1.0 / 127.95\n    e = np.sqrt(4.0 * np.pi * alpha_em)\n    cW = mW / mZ\n    sW = np.sqrt(max(0.0, 1.0 - cW*cW))\n    g = e / sW\n\n    # Initial-state fermion: up-quark\n    Qf = +2.0/3.0\n    T3L = +0.5  # only for left-chiral; right has T3=0\n\n    # Chiral couplings to Z\n    gL_Z = (g / cW) * (T3L - Qf * sW*sW)\n    gR_Z = -(g / cW) * (Qf * sW*sW)\n\n    # Photon couplings (vector-like)\n    gL_A = e * Qf\n    gR_A = e * Qf\n\n    # Goldstone couplings\n    Qphi = +1.0\n    T3phi = +0.5\n    g_A_phi = e * Qphi\n    g_Z_phi = (g / cW) * (T3phi - (sW*sW) * Qphi)\n\n    # Trilinear gauge couplings\n    g_A_WW = e\n    g_Z_WW = e * cW / sW  # = g * cW\n\n    # Vector boson masses\n    mA = 0.0\n    mZ_val = mZ\n\n    couplings = {\n        \"e\": e,\n        \"g\": g,\n        \"sW\": sW,\n        \"cW\": cW,\n        \"mW\": mW,\n        \"mZ\": mZ_val,\n        \"mA\": mA,\n        # fermion chiral couplings\n        \"gL\": {\"A\": gL_A, \"Z\": gL_Z},\n        \"gR\": {\"A\": gR_A, \"Z\": gR_Z},\n        # scalar and trilinear couplings\n        \"gVphi\": {\"A\": g_A_phi, \"Z\": g_Z_phi},\n        \"gVWW\": {\"A\": g_A_WW, \"Z\": g_Z_WW},\n    }\n    return couplings\n\ndef A_vector_scalar_channel(p1, p2, k_plus, k_minus, V, couplings):\n    \"\"\"\n    Build A_V^\\mu for scalar channel: S_V^\\mu = g_{Vphi}/(s - m_V^2) * (k_plus - k_minus)^\\mu\n    \"\"\"\n    q = vector_add(k_plus, k_minus)\n    s = minkowski_dot(q, q)\n    if V == \"A\":\n        mV2 = 0.0\n    else:\n        mV2 = couplings[\"mZ\"]**2\n    denom = s - mV2\n    gVphi = couplings[\"gVphi\"][V]\n    vec = vector_sub(k_plus, k_minus)\n    return scalar_mul(gVphi / denom, vec)\n\ndef A_vector_vector_channel(p1, p2, k_plus, k_minus, V, couplings):\n    \"\"\"\n    Build A_V^\\mu for vector channel with longitudinal polarizations.\n    X_V^\\mu = g_{VWW}/(s - m_V^2) [ (k_- - k_+ )^\\mu (epsp·epsm) + ((q - 2k_- )·epsp) epsm^\\mu + ((2k_+ - q)·epsm) epsp^\\mu ]\n    \"\"\"\n    q = vector_add(k_plus, k_minus)\n    s = minkowski_dot(q, q)\n    if V == \"A\":\n        mV2 = 0.0\n    else:\n        mV2 = couplings[\"mZ\"]**2\n    denom = s - mV2\n    gVWW = couplings[\"gVWW\"][V]\n\n    # Longitudinal polarization vectors\n    eps_p = polarization_longitudinal(k_plus, couplings[\"mW\"])\n    eps_m = polarization_longitudinal(k_minus, couplings[\"mW\"])\n\n    # Compute needed components\n    km_minus_kp = vector_sub(k_minus, k_plus)\n    q_minus_2km = vector_sub(q, scalar_mul(2.0, k_minus))\n    two_kp_minus_q = vector_sub(scalar_mul(2.0, k_plus), q)\n\n    epsp_dot_epsm = minkowski_dot(eps_p, eps_m)\n    qmk_dot_epsp = minkowski_dot(q_minus_2km, eps_p)\n    tkmq_dot_epsm = minkowski_dot(two_kp_minus_q, eps_m)\n\n    term1 = scalar_mul(epsp_dot_epsm, km_minus_kp)\n    term2 = scalar_mul(qmk_dot_epsp, eps_m)\n    term3 = scalar_mul(tkmq_dot_epsm, eps_p)\n\n    X = vector_add(term1, vector_add(term2, term3))\n    return scalar_mul(gVWW / denom, X)\n\ndef contraction_T(p1, p2, A, B):\n    \"\"\"\n    Compute C(A,B) = p2·A p1·B + p2·B p1·A - (p1·p2) A·B\n    \"\"\"\n    p2dotA = minkowski_dot(p2, A)\n    p1dotB = minkowski_dot(p1, B)\n    p2dotB = minkowski_dot(p2, B)\n    p1dotA = minkowski_dot(p1, A)\n    p1dotp2 = minkowski_dot(p1, p2)\n    AdotB = minkowski_dot(A, B)\n    return p2dotA * p1dotB + p2dotB * p1dotA - p1dotp2 * AdotB\n\ndef M2_unpolarized_channel(p1, p2, k_plus, k_minus, channel, couplings):\n    \"\"\"\n    Compute the unpolarized, spin-averaged squared matrix element:\n    M2 = (1/2) sum_{V,V' in {A,Z}} (gL^V gL^V' + gR^V gR^V') * C(A_V, A_V')\n    where A_V is S_V for scalar channel or X_V for vector channel.\n    \"\"\"\n    # Build A_V for V in A,Z\n    if channel == \"scalar\":\n        AV = {\n            \"A\": A_vector_scalar_channel(p1, p2, k_plus, k_minus, \"A\", couplings),\n            \"Z\": A_vector_scalar_channel(p1, p2, k_plus, k_minus, \"Z\", couplings),\n        }\n    elif channel == \"vector\":\n        AV = {\n            \"A\": A_vector_vector_channel(p1, p2, k_plus, k_minus, \"A\", couplings),\n            \"Z\": A_vector_vector_channel(p1, p2, k_plus, k_minus, \"Z\", couplings),\n        }\n    else:\n        raise ValueError(\"Unknown channel\")\n\n    gL = couplings[\"gL\"]\n    gR = couplings[\"gR\"]\n\n    # Sum over V,V'\n    M2 = 0.0\n    for V in (\"A\", \"Z\"):\n        for Vp in (\"A\", \"Z\"):\n            coeff = 0.5 * (gL[V] * gL[Vp] + gR[V] * gR[Vp])\n            M2 += coeff * contraction_T(p1, p2, AV[V], AV[Vp])\n    return M2\n\ndef compute_delta(sqrt_s, cos_theta, couplings):\n    \"\"\"\n    Compute delta(s,cosθ) = M2_vector / M2_scalar - 1.\n    \"\"\"\n    mW = couplings[\"mW\"]\n    p1, p2, k_plus, k_minus = build_kinematics(sqrt_s, cos_theta, mW)\n    # sanity check: ensure above threshold to avoid kinematic issues\n    # Build matrix elements\n    M2_scalar = M2_unpolarized_channel(p1, p2, k_plus, k_minus, \"scalar\", couplings)\n    M2_vector = M2_unpolarized_channel(p1, p2, k_plus, k_minus, \"vector\", couplings)\n    # Avoid division by zero\n    if M2_scalar == 0.0:\n        return np.nan\n    return (M2_vector / M2_scalar) - 1.0\n\ndef solve():\n    # Define the test cases from the problem statement as (sqrt(s) in GeV, cos(theta))\n    test_cases = [\n        (200.0, 0.0),\n        (500.0, 0.3),\n        (1000.0, -0.7),\n        (3000.0, 0.9),\n        (170.0, 0.0),\n    ]\n\n    couplings = build_couplings()\n\n    results = []\n    for sqrt_s, cos_theta in test_cases:\n        delta = compute_delta(sqrt_s, cos_theta, couplings)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}