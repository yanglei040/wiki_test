{
    "hands_on_practices": [
        {
            "introduction": "The foundation of calculating any hadron property on the lattice lies in constructing the correct correlation functions from fundamental quark fields. This theoretical exercise delves into the combinatorial core of this process, guiding you through the Wick contractions for a proton two-point function. Mastering this practice  is essential for understanding the origin of the signals measured in simulations and the non-trivial group theory factors that determine their strength.",
            "id": "3507023",
            "problem": "Consider Quantum Chromodynamics (QCD) in Euclidean space with the color group Special Unitary group of degree $3$ (SU($3$)). Let $u(x)$ and $d(x)$ denote Grassmann-valued up and down quark fields with color indices $a,b,c \\in \\{1,2,3\\}$ and suppressed Dirac spinor indices. Define the standard local proton interpolating operator at spacetime point $x$,\n$$\nO_{p}(x) \\equiv \\epsilon^{abc} \\left( u^{a}(x) \\right)^{T} C \\gamma_{5} d^{b}(x)\\, u^{c}(x),\n$$\nwhere $\\epsilon^{abc}$ is the totally antisymmetric Levi-Civita symbol in color space, $\\gamma_{5}$ is the Euclidean chirality matrix, and $C$ is the charge conjugation matrix satisfying $C \\gamma_{\\mu} C^{-1} = - \\gamma_{\\mu}^{T}$ and $C^{T} = - C$. The adjoint operator at the origin is\n$$\n\\bar{O}_{p}(0) \\equiv \\epsilon^{a'b'c'}\\, \\bar{u}^{c'}(0)\\, \\bar{d}^{b'}(0)\\, \\gamma_{5} C \\left( \\bar{u}^{a'}(0) \\right)^{T}.\n$$\nThe zero-momentum Euclidean two-point correlation function is\n$$\nC(t) \\equiv \\sum_{\\vec{x}} \\left\\langle O_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) \\right\\rangle,\n$$\nwith the path integral average taken over gauge and fermion fields, and with the usual fermion Wick contractions producing quark propagators $S_{f}(x,0) \\equiv \\left\\langle f(x)\\, \\bar{f}(0) \\right\\rangle$ for flavor $f \\in \\{u,d\\}$.\n\nStarting from Wick’s theorem for Grassmann fields and the antisymmetry of $\\epsilon^{abc}$, perform the Wick contractions between the fields in $O_{p}(\\vec{x},t)$ and $\\bar{O}_{p}(\\vec{0},0)$, carefully accounting for:\n- the two identical up-quark fields and the two identical anti-up-quark fields, which admit $2!$ distinct pairings, and\n- the permutation signs arising from fermionic anticommutation when realizing each pairing.\n\nThen, carry out the color-index algebra implied by the products of Levi-Civita symbols and Kronecker deltas generated by the contractions, and sum over the color indices. Leave all Dirac spinor structures and gamma matrices unevaluated; focus solely on the net overall color coefficient multiplying the spinor-space contraction after the color sums are completed.\n\nCompute the final net color factor $F_{\\text{color}}$ as a single integer. No rounding is required and there are no physical units associated with $F_{\\text{color}}$; report $F_{\\text{color}}$ as a pure number.",
            "solution": "The fundamental bases are Wick’s theorem for Grassmann fields and the antisymmetry properties of fermion fields and the Levi-Civita symbol. We work in Euclidean space, and we only perform the color algebra, leaving the spinor structure with $\\gamma_{5}$ and $C$ implicit.\n\nWe begin with the explicit product of operators inside the correlator,\n$$\nO_{p}(\\vec{x},t)\\, \\bar{O}_{p}(\\vec{0},0) = \\epsilon^{abc}\\, \\epsilon^{a'b'c'} \\left( u^{a} \\right)^{T} C \\gamma_{5} d^{b}\\, u^{c}\\, \\bar{u}^{c'}\\, \\bar{d}^{b'}\\, \\gamma_{5} C \\left( \\bar{u}^{a'} \\right)^{T},\n$$\nwhere all fields are evaluated at the appropriate spacetime points and we suppress explicit arguments for brevity. By Wick’s theorem for Grassmann fields, the correlator is the sum over all complete pairings of $u$ with $\\bar{u}$ and $d$ with $\\bar{d}$, each pairing contributing a product of propagators multiplied by a sign determined by the permutation parity needed to bring fields into contracted pairs.\n\nThere is a unique pairing for the $d$ fields: $d^{b}$ with $\\bar{d}^{b'}$. For the $u$ fields, there are two identical up-quark fields $u^{a}$ and $u^{c}$ and two corresponding anti-up-quark fields $\\bar{u}^{a'}$ and $\\bar{u}^{c'}$. Thus, there are $2! = 2$ distinct pairings:\n- The direct pairing: $u^{a}$ contracts with $\\bar{u}^{a'}$ and $u^{c}$ contracts with $\\bar{u}^{c'}$.\n- The exchange pairing: $u^{a}$ contracts with $\\bar{u}^{c'}$ and $u^{c}$ contracts with $\\bar{u}^{a'}$.\n\nEach contraction generates a Kronecker delta in color space between the color indices of the contracted fields. For the $d$ fields, we obtain $\\delta_{bb'}$. For the $u$ fields, the direct pairing yields $\\delta_{aa'}\\, \\delta_{cc'}$, while the exchange pairing yields $\\delta_{ac'}\\, \\delta_{ca'}$.\n\nTherefore, the color structures for the two pairings are\n$$\n\\text{Direct:}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'},\n$$\nand\n$$\n\\text{Exchange:}\\quad \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'}.\n$$\n\nWe now perform the color sums. For the direct pairing,\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{aa'}\\, \\delta_{bb'}\\, \\delta_{cc'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc}.\n$$\nUsing the standard identity\n$$\n\\sum_{a,b,c=1}^{3} \\epsilon^{abc}\\, \\epsilon^{abc} = 3! = 6,\n$$\nwe find that the direct color factor equals $6$.\n\nFor the exchange pairing,\n$$\n\\sum_{a,b,c,a',b',c'} \\epsilon^{abc}\\, \\epsilon^{a'b'c'}\\, \\delta_{ac'}\\, \\delta_{bb'}\\, \\delta_{ca'} = \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba}.\n$$\nThe mapping $(a,b,c) \\mapsto (c,b,a)$ is a single transposition (swapping $a$ and $c$), which is odd. Hence,\n$$\n\\epsilon^{cba} = -\\, \\epsilon^{abc},\n$$\nand therefore\n$$\n\\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{cba} = - \\sum_{a,b,c} \\epsilon^{abc}\\, \\epsilon^{abc} = - 6.\n$$\nSo the exchange color factor from $\\epsilon$-contractions and Kronecker deltas is $-6$.\n\nWe must also account for the fermionic sign associated with the permutation needed to realize the exchange pairing of the identical up-quark fields. Wick’s theorem for Grassmann fields dictates that exchanging the pairing of identical fermions introduces a relative minus sign between the direct and exchange pairings. Thus, the exchange contribution acquires an extra factor of $-1$ from the fermionic permutation parity relative to the direct term.\n\nCombining the fermionic sign with the color algebra for the exchange pairing gives\n$$\n(+\\text{fermionic sign for direct}) \\times 6 \\quad\\text{and}\\quad (-\\text{fermionic sign for exchange}) \\times (-6) = +6.\n$$\nTherefore, both pairings contribute $+6$ to the net color factor. Summing over the two pairings,\n$$\nF_{\\text{color}} = 6 + 6 = 12.\n$$\n\nThis $F_{\\text{color}}$ multiplies whatever spinor-space structure arises from the $C \\gamma_{5}$ insertions and the spinor indices of the propagators; we have left those unevaluated as required. The final net color factor is the pure number $12$.",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "With a correlation function in hand, the next step is to extract physical information, such as hadron masses. This exercise  introduces the spectral decomposition of correlators and a crucial technique, parity projection, used to disentangle states with opposite parity, like the nucleon and its negative-parity partner. By implementing this method on synthetic data, you will gain practical experience in turning raw correlator data into initial mass estimates.",
            "id": "3507006",
            "problem": "You are tasked with deriving, implementing, and testing a parity-projected mass extraction method for zero-momentum baryon two-point correlation functions in Euclidean Lattice Quantum Chromodynamics (Lattice QCD). The target quantities are the positive-parity and negative-parity ground-state masses expressed in lattice units.\n\nThe starting point must be the Euclidean path-integral formulation and the spectral representation of two-point functions, together with the Dirac algebra in Euclidean space. Use the following foundational laws and definitions:\n- The zero-momentum baryon two-point function in Euclidean time is defined as the spinor matrix $C_{\\alpha\\beta}(t) = \\sum_{\\vec{x}} \\langle 0 | \\mathcal{O}_{\\alpha}(t,\\vec{x}) \\overline{\\mathcal{O}}_{\\beta}(0) | 0 \\rangle$, with Euclidean time extent $T$, anti-periodic temporal boundary conditions for fermions, and time indices $t \\in \\{0,1,\\dots,T-1\\}$.\n- Parity at zero momentum is represented by projection using Euclidean $\\gamma$-matrices. In standard Euclidean conventions, use $\\gamma_{4}$ such that $\\gamma_{4} = \\mathrm{diag}(1,1,-1,-1)$, and define the positive- and negative-parity projectors $P_{\\pm} = \\frac{1 \\pm \\gamma_{4}}{2}$.\n- The spectral representation at zero momentum and the existence of a transfer matrix imply a discrete sum over states with positive and negative parity and exponential Euclidean time decay, consistent with anti-periodic temporal boundary conditions for fermions.\n\nYour derivation and implementation must proceed as follows.\n- Use the spectral representation and the parity projectors to show that, at zero momentum and with anti-periodic temporal boundary conditions, the correlator matrix can be consistently modeled, for a single dominant state of each parity, as a superposition of a forward-propagating positive-parity exponential and a backward-propagating negative-parity exponential. Explicitly, construct a synthetic correlator consistent with these principles:\n  $$C(t) = A_{+}\\, P_{+}\\, e^{-M_{+}\\, t}\\;-\\;A_{-}\\, P_{-}\\, e^{-M_{-}\\, (T - t)},$$\n  where $A_{+} \\gt 0$ and $A_{-} \\gt 0$ are overlap amplitudes, $M_{+} \\gt 0$ and $M_{-} \\gt 0$ are the positive- and negative-parity ground-state masses, $T \\in \\mathbb{Z}_{\\gt 0}$ is the temporal extent, and $t \\in \\{0,1,\\dots,T-1\\}$. All quantities are in lattice units.\n- From first principles, demonstrate how parity projection using $P_{+}$ and $P_{-}$ isolates single-exponential decays for each parity without contamination from the opposite-parity backward propagating contribution. Conclude a practical, fitting-free estimator for $M_{+}$ and $M_{-}$ that uses only adjacent-time correlator values and is valid when a single state dominates in the selected time window. Your estimator must be derived from the projected correlators and must not rely on providing any target formula in this problem statement.\n- Define the projected scalar correlators you will use for mass extraction as traces with parity projectors. To isolate a forward-decaying negative-parity signal, use a time-reversed construction consistent with the spectral representation and anti-periodic boundary conditions. Explicitly specify the projected scalar correlators used for the estimators in your solution.\n- For numerical estimation, use an average of the adjacent-time estimators over a plateau window. For each test case with temporal extent $T$, define the window indices as $t_{\\mathrm{start}} = \\max(1,\\lfloor T/8 \\rfloor)$ and $t_{\\mathrm{end}} = \\min(\\lfloor T/4 \\rfloor, T-2)$, and average the pointwise estimators over all integer $t$ in this window. The final answers for $M_{+}$ and $M_{-}$ must be reported in lattice units as real numbers rounded to six decimal places.\n\nImplement a program that:\n- Constructs $C(t)$ for each provided test case using the given parameters and the definition above.\n- Builds the parity projectors $P_{\\pm}$ from $\\gamma_{4}$ as specified.\n- Forms the projected scalar correlators and computes the adjacent-time effective-mass estimators over the specified window to produce a single estimate for $M_{+}$ and $M_{-}$ for each test case.\n- Rounds each estimated mass to six decimal places.\n\nTest suite:\n- Use the following five test cases, each given as a tuple $(T, M_{+}, M_{-}, A_{+}, A_{-})$:\n  - Case $1$: $(64, 0.5, 0.8, 1.2, 0.9)$\n  - Case $2$: $(48, 0.3, 1.1, 2.0, 0.5)$\n  - Case $3$: $(32, 1.5, 1.6, 1.0, 1.3)$\n  - Case $4$: $(40, 0.7, 0.7, 1.7, 0.4)$\n  - Case $5$: $(16, 0.4, 1.3, 0.8, 1.1)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the results for the five cases in order, placing the positive-parity estimate first and the negative-parity estimate second for each case. For example, the output must have the form\n  $$[M_{+}^{(1)}, M_{-}^{(1)}, M_{+}^{(2)}, M_{-}^{(2)}, M_{+}^{(3)}, M_{-}^{(3)}, M_{+}^{(4)}, M_{-}^{(4)}, M_{+}^{(5)}, M_{-}^{(5)}],$$\nwith each entry rounded to six decimal places and expressed in lattice units.",
            "solution": "The problem requires the derivation and implementation of a method to extract positive- and negative-parity ground-state baryon masses from a synthetic two-point correlation function in Lattice QCD. This task will be addressed by first validating the problem statement and then proceeding with a principled derivation of the required estimators, followed by a description of the numerical implementation.\n\nThe problem statement is determined to be **valid**. It is scientifically grounded in the principles of Lattice QCD, providing a well-posed and objective task with a self-contained and consistent setup. The model provided is a standard simplification used in hadronic physics, and all parameters and procedures are clearly defined.\n\n### Theoretical Derivation of Mass Estimators\n\nThe starting point is the provided model for the zero-momentum baryon two-point correlation function matrix, valid for Euclidean time slices $t \\in \\{0, 1, \\dots, T-1\\}$:\n$$\nC(t) = A_{+} P_{+} e^{-M_{+} t} - A_{-} P_{-} e^{-M_{-} (T - t)}\n$$\nHere, $M_{\\pm} > 0$ are the ground-state masses for positive ($+$) and negative ($-$) parity states, $A_{\\pm} > 0$ are the corresponding amplitudes, $T$ is the temporal extent of the lattice, and $P_{\\pm}$ are the parity projectors. All quantities are in lattice units.\n\nThe parity projectors are defined in terms of the Euclidean gamma matrix $\\gamma_4$:\n$$\nP_{\\pm} = \\frac{1 \\pm \\gamma_{4}}{2}\n$$\nWith the specified representation $\\gamma_{4} = \\mathrm{diag}(1,1,-1,-1)$, the projectors become diagonal matrices $P_{+} = \\mathrm{diag}(1,1,0,0)$ and $P_{-} = \\mathrm{diag}(0,0,1,1)$. These operators satisfy the fundamental properties of projectors: they are idempotent ($P_{\\pm}^2 = P_{\\pm}$) and orthogonal ($P_{+} P_{-} = P_{-} P_{+} = 0$), and they form a complete set ($P_{+} + P_{-} = I$, where $I$ is the identity matrix).\n\nThe task is to extract $M_+$ and $M_-$ using these projectors. This is achieved by defining projected scalar correlators and deriving an effective mass formula from them.\n\n#### Positive-Parity Mass ($M_+$) Extraction\n\nWe define the positive-parity projected scalar correlator, $G_+(t)$, by taking the trace of the full correlator matrix $C(t)$ multiplied by the positive-parity projector $P_+$:\n$$\nG_+(t) = \\mathrm{Tr}\\left[P_+ C(t)\\right]\n$$\nSubstituting the given expression for $C(t)$:\n$$\nG_+(t) = \\mathrm{Tr}\\left[P_+ \\left( A_{+} P_{+} e^{-M_{+} t} - A_{-} P_{-} e^{-M_{-} (T - t)} \\right)\\right]\n$$\nUsing the linearity of the trace and the projector properties:\n$$\nG_+(t) = A_{+} e^{-M_{+} t} \\mathrm{Tr}[P_+ P_+] - A_{-} e^{-M_{-} (T - t)} \\mathrm{Tr}[P_+ P_-]\n$$\nSince $P_+ P_+ = P_+$ and $P_+ P_- = 0$, the expression simplifies to:\n$$\nG_+(t) = A_{+} e^{-M_{+} t} \\mathrm{Tr}[P_+]\n$$\nThe trace of $P_+$ in four dimensions is $\\mathrm{Tr}[\\mathrm{diag}(1,1,0,0)] = 2$. Thus, we have isolated a pure, forward-propagating exponential decay:\n$$\nG_+(t) = 2 A_{+} e^{-M_{+} t}\n$$\nTo find a fitting-free estimator for $M_+$, we consider the ratio of this correlator at adjacent time slices, $t$ and $t+1$:\n$$\n\\frac{G_+(t+1)}{G_+(t)} = \\frac{2 A_{+} e^{-M_{+} (t+1)}}{2 A_{+} e^{-M_{+} t}} = e^{-M_{+}}\n$$\nTaking the natural logarithm of both sides and solving for $M_+$ yields the adjacent-time effective mass estimator, $M_+(t)$:\n$$\nM_+(t) = -\\ln\\left(\\frac{G_+(t+1)}{G_+(t)}\\right) = \\ln\\left(\\frac{G_+(t)}{G_+(t+1)}\\right)\n$$\nFor the given ideal correlator form, $M_+(t)$ is constant and equal to the true mass $M_+$ for all $t$.\n\n#### Negative-Parity Mass ($M_-$) Extraction\n\nThe negative-parity component in $C(t)$ is a backward-propagating state, proportional to $e^{-M_-(T-t)}$. To handle this symmetrically with the positive-parity case, we follow the instruction to use a \"time-reversed construction\" to obtain a forward-decaying signal. We define a new scalar correlator, $G_-(t')$, which is constructed by applying the $P_-$ projector to the time-reversed correlator matrix $C(T-t')$:\n$$\nG_-(t') = -\\mathrm{Tr}\\left[P_- C(T-t')\\right]\n$$\nThe leading minus sign is included by convention to yield a positive-definite quantity, as will become clear. Relabeling the time variable from $t'$ back to $t$ for notational consistency in the analysis window, we use:\n$$\nG_-(t) = -\\mathrm{Tr}\\left[P_- C(T-t)\\right]\n$$\nTo evaluate this, we first find $C(T-t)$:\n$$\nC(T-t) = A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} (T - (T-t))} = A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} t}\n$$\nNow, we apply the projection and trace:\n$$\nG_-(t) = -\\mathrm{Tr}\\left[P_- \\left( A_{+} P_{+} e^{-M_{+} (T-t)} - A_{-} P_{-} e^{-M_{-} t} \\right)\\right]\n$$\n$$\nG_-(t) = -A_{+} e^{-M_{+} (T-t)} \\mathrm{Tr}[P_- P_+] + A_{-} e^{-M_{-} t} \\mathrm{Tr}[P_- P_-]\n$$\nUsing $P_- P_+ = 0$ and $P_- P_- = P_-$, this simplifies to:\n$$\nG_-(t) = A_{-} e^{-M_{-} t} \\mathrm{Tr}[P_-]\n$$\nThe trace of $P_-$ is $\\mathrm{Tr}[\\mathrm{diag}(0,0,1,1)] = 2$. This gives a forward-propagating exponential decay for the negative-parity state:\n$$\nG_-(t) = 2 A_{-} e^{-M_{-} t}\n$$\nThe effective mass estimator for the negative-parity state, $M_-(t)$, is derived identically to the positive-parity case:\n$$\nM_-(t) = \\ln\\left(\\frac{G_-(t)}{G_-(t+1)}\\right)\n$$\nThis estimator will yield the true mass $M_-$ for all $t$.\n\n### Numerical Estimation Algorithm\n\nThe algorithm proceeds as follows for each test case $(T, M_{+}, M_{-}, A_{+}, A_{-})$:\n$1$. Construct the parity projectors $P_{+}$ and $P_{-}$ from the given definition of $\\gamma_4$.\n$2$. Define a function to compute the correlator matrix $C(t)$ for any $t \\in \\{0, 1, \\dots, T-1\\}$ using the provided synthetic model.\n$3$. Determine the analysis window for averaging the effective masses, defined by $t_{\\mathrm{start}} = \\max(1,\\lfloor T/8 \\rfloor)$ and $t_{\\mathrm{end}} = \\min(\\lfloor T/4 \\rfloor, T-2)$.\n$4$. For each integer time slice $t$ from $t_{\\mathrm{start}}$ to $t_{\\mathrm{end}}$, calculate the pointwise effective masses:\n    $$\n    M_+(t) = \\ln\\left( \\frac{\\mathrm{Tr}[P_+ C(t)]}{\\mathrm{Tr}[P_+ C(t+1)]} \\right)\n    $$\n    $$\n    M_-(t) = \\ln\\left( \\frac{-\\mathrm{Tr}[P_- C(T-t)]}{-\\mathrm{Tr}[P_- C(T-(t+1))]} \\right)\n    $$\n$5$. Compute the final estimates for $M_+$ and $M_-$ by averaging the pointwise values over the analysis window:\n    $$\n    \\bar{M}_{\\pm} = \\frac{1}{t_{\\mathrm{end}} - t_{\\mathrm{start}} + 1} \\sum_{t=t_{\\mathrm{start}}}^{t_{\\mathrm{end}}} M_{\\pm}(t)\n    $$\n$6$. Round the final average masses $\\bar{M}_+$ and $\\bar{M}_-$ to six decimal places.\n\nSince the synthetic data is noise-free and perfectly described by the single-state model, the pointwise effective masses $M_{\\pm}(t)$ will be constant within the analysis window. The averaging step, while formally required, will simply return the constant value.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a parity-projected mass extraction method for baryon\n    two-point correlation functions in Lattice QCD.\n    \"\"\"\n\n    # Test suite: each case is a tuple (T, M_+, M_-, A_+, A_-)\n    test_cases = [\n        (64, 0.5, 0.8, 1.2, 0.9),\n        (48, 0.3, 1.1, 2.0, 0.5),\n        (32, 1.5, 1.6, 1.0, 1.3),\n        (40, 0.7, 0.7, 1.7, 0.4),\n        (16, 0.4, 1.3, 0.8, 1.1),\n    ]\n\n    results = []\n    \n    # Define the Euclidean gamma matrix gamma_4 and projectors P_±.\n    # The matrices are defined as real, as specified in the problem.\n    gamma_4 = np.diag([1.0, 1.0, -1.0, -1.0])\n    identity_4 = np.identity(4)\n    P_plus = 0.5 * (identity_4 + gamma_4)\n    P_minus = 0.5 * (identity_4 - gamma_4)\n\n    for case in test_cases:\n        T, M_plus_true, M_minus_true, A_plus, A_minus = case\n\n        # Correlator construction function based on the provided model\n        def get_C(t, T_val, M_p, M_m, A_p, A_m):\n            \"\"\"\n            Constructs the synthetic correlator matrix C(t).\n            C(t) = A_+ P_+ e^(-M_+ t) - A_- P_- e^(-M_- (T - t))\n            \"\"\"\n            term_plus = A_p * P_plus * np.exp(-M_p * t)\n            term_minus = A_m * P_minus * np.exp(-M_m * (T_val - t))\n            return term_plus - term_minus\n\n        # Define the analysis window [t_start, t_end]\n        t_start = max(1, T // 8)\n        t_end = min(T // 4, T - 2)\n\n        m_eff_plus_values = []\n        m_eff_minus_values = []\n\n        # Iterate over the analysis window to compute pointwise effective masses\n        for t in range(t_start, t_end + 1):\n            # ===== Positive-Parity Effective Mass M_+(t) =====\n            # G_+(t) = Tr[P_+ C(t)]\n            C_t = get_C(t, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_plus_t = np.trace(P_plus @ C_t)\n            \n            # G_+(t+1) = Tr[P_+ C(t+1)]\n            C_t1 = get_C(t + 1, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_plus_t1 = np.trace(P_plus @ C_t1)\n            \n            # M_+(t) = ln( G_+(t) / G_+(t+1) )\n            m_eff_plus = np.log(G_plus_t / G_plus_t1)\n            m_eff_plus_values.append(m_eff_plus)\n\n            # ===== Negative-Parity Effective Mass M_-(t) =====\n            # Use time-reversed construction for a forward-decaying signal.\n            # G_-(t) = -Tr[P_- C(T-t)]\n            C_T_minus_t = get_C(T - t, T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_minus_t = -np.trace(P_minus @ C_T_minus_t)\n\n            # G_-(t+1) = -Tr[P_- C(T-(t+1))]\n            C_T_minus_t1 = get_C(T - (t + 1), T, M_plus_true, M_minus_true, A_plus, A_minus)\n            G_minus_t1 = -np.trace(P_minus @ C_T_minus_t1)\n\n            # M_-(t) = ln( G_-(t) / G_-(t+1) )\n            m_eff_minus = np.log(G_minus_t / G_minus_t1)\n            m_eff_minus_values.append(m_eff_minus)\n\n        # Average the pointwise masses over the window\n        # For this ideal synthetic data, the average is the same as any point.\n        M_plus_est = np.mean(m_eff_plus_values)\n        M_minus_est = np.mean(m_eff_minus_values)\n\n        # Append rounded results for the current case\n        results.append(round(M_plus_est, 6))\n        results.append(round(M_minus_est, 6))\n\n    # Format the final output as a comma-separated list in brackets\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Lattice simulations are performed at a finite lattice spacing $a$, introducing discretization errors that must be removed to obtain a physical prediction. This final practice  addresses the critical step of continuum extrapolation, where results from multiple lattice spacings are used to determine the true value of an observable in the $a \\to 0$ limit. You will apply weighted least-squares fitting and model comparison techniques to see firsthand how Symanzik improvement systematically reduces these artifacts and leads to a precise continuum result.",
            "id": "3507086",
            "problem": "In Lattice Quantum Chromodynamics (LQCD), the Symanzik effective theory predicts that discretization artifacts in observables scale as powers of the lattice spacing $a$. For Wilson fermions, leading-order discretization errors scale as $\\mathcal{O}(a)$, while tuning the Sheikholeslami-Wohlert (SW) coefficient $c_{\\text{SW}}$ nonperturbatively removes the $\\mathcal{O}(a)$ term, leaving $\\mathcal{O}(a^2)$ artifacts. Consider the nucleon mass $M_N(a)$ measured at several lattice spacings in gigaelectron volts (GeV), with statistical uncertainties assumed Gaussian and uncorrelated. The $\\mathcal{O}(a)$-dominated scaling model and the $\\mathcal{O}(a^2)$-dominated scaling model are, respectively, $$M_N(a) = M_0 + c_1 a + c_2 a^2$$ and $$M_N(a) = M_0 + c_2 a^2,$$ where $M_0$ is the continuum-limit nucleon mass, $c_1$ and $c_2$ are nuisance parameters, and $a$ is given in femtometer (fm). The weighted least-squares estimator (equivalently, maximum-likelihood under Gaussian noise) minimizes the objective $$\\chi^2 = \\sum_i \\frac{\\left[y_i - M_N(a_i)\\right]^2}{\\sigma_i^2},$$ where $y_i$ are the measured masses at spacings $a_i$ with uncertainties $\\sigma_i$.\n\nStarting from the fundamental base that the Symanzik expansion organizes lattice artifacts in powers of $a$ and that Gaussian error models imply weighted least-squares optimality, implement the following tasks:\n\n1. For each test case, fit the unimproved measurements (corresponding to a Wilson action without nonperturbative tuning of the Sheikholeslami-Wohlert (SW) coefficient $c_{\\text{SW}}$) to the $\\mathcal{O}(a)$ scaling model $M_N(a) = M_0 + c_1 a + c_2 a^2$ using weighted least squares, and extract the continuum-limit mass $M_0$ in GeV.\n2. For each test case, fit the improved measurements (corresponding to nonperturbative tuning of $c_{\\text{SW}}$) to the $\\mathcal{O}(a^2)$ scaling model $M_N(a) = M_0 + c_2 a^2$ using weighted least squares, and extract the continuum-limit mass $M_0$ in GeV.\n3. On the improved dataset of each test case, quantitatively compare the $\\mathcal{O}(a)$ model versus the $\\mathcal{O}(a^2)$ model using the Akaike Information Criterion (AIC). Under Gaussian errors, use $$\\mathrm{AIC}' = \\chi^2 + 2k,$$ where $k$ is the number of fitted parameters. Report $1$ if the $\\mathcal{O}(a^2)$ model is preferred (smaller $\\mathrm{AIC}'$) on the improved dataset, and $0$ otherwise.\n4. For each test case, compute the effect size as the difference $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$ in GeV, rounded to six decimals.\n\nYour program must produce the following final output format as a single line: a comma-separated flat list enclosed in square brackets, aggregating the four outputs per test case in order, namely $M_{0,\\text{unimproved}}$, $M_{0,\\text{improved}}$, $\\Delta M_0$, and the AIC-preference indicator. Therefore, for three test cases, the program must print twelve values in the order case $1$ (four values), case $2$ (four values), case $3$ (four values). All masses must be expressed in GeV and rounded to six decimals. The AIC-preference indicator must be an integer ($1$ or $0$).\n\nUse the following test suite, with lattice spacings $a$ in femtometer (fm), masses $y$ in gigaelectron volts (GeV), and uncertainties $\\sigma$ in GeV:\n\n- Test case $1$:\n  - Unimproved: $a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$, $y = \\{0.9680, 0.9590, 0.9510, 0.9480\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$.\n  - Improved: $a = \\{0.12, 0.09, 0.06, 0.045\\}\\,\\mathrm{fm}$, $y = \\{0.9420, 0.9400, 0.9390, 0.9385\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0040, 0.0035, 0.0030, 0.0030\\}\\,\\mathrm{GeV}$.\n- Test case $2$:\n  - Unimproved: $a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$, $y = \\{0.9530, 0.9490, 0.9450, 0.9440\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$.\n  - Improved: $a = \\{0.08, 0.06, 0.04, 0.03\\}\\,\\mathrm{fm}$, $y = \\{0.9405, 0.9397, 0.9393, 0.9392\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0030, 0.0025, 0.0020, 0.0020\\}\\,\\mathrm{GeV}$.\n- Test case $3$:\n  - Unimproved: $a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$, $y = \\{0.9870, 0.9750, 0.9680\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$.\n  - Improved: $a = \\{0.15, 0.12, 0.10\\}\\,\\mathrm{fm}$, $y = \\{0.9460, 0.9430, 0.9420\\}\\,\\mathrm{GeV}$, $\\sigma = \\{0.0050, 0.0040, 0.0040\\}\\,\\mathrm{GeV}$.\n\nAll computations must be performed in double precision. Angles are not involved in this problem. The final output must be a single line of the form $$[x_1,x_2,\\dots,x_{12}],$$ where each $x_i$ is one of the specified floats (in GeV, six decimals) or integers ($0$ or $1$).",
            "solution": "The problem requires performing a continuum extrapolation of nucleon mass data simulated in Lattice Quantum Chromodynamics (LQCD). This is a standard procedure to remove discretization artifacts, which are errors arising from approximating continuous spacetime with a discrete grid of points. The Symanzik effective theory provides a systematic framework for this, predicting that for a lattice spacing $a$, observables like the nucleon mass $M_N(a)$ approach their continuum value $M_0$ as a power series in $a$.\n\nThe core of the problem is to fit numerical data to two different theoretical models using the method of weighted least squares. This method is statistically optimal for fitting a model to data points with known, uncorrelated Gaussian uncertainties. The objective is to find the set of model parameters $\\vec{p}$ that minimizes the chi-squared function, $\\chi^2$:\n$$\n\\chi^2(\\vec{p}) = \\sum_{i=1}^{N} \\frac{\\left[y_i - f(a_i; \\vec{p})\\right]^2}{\\sigma_i^2}\n$$\nwhere $\\{y_i\\}$ are the $N$ measured mass values at corresponding lattice spacings $\\{a_i\\}$, $\\{\\sigma_i\\}$ are their statistical uncertainties, and $f(a; \\vec{p})$ is the theoretical model.\n\nThe two models are linear in their parameters, which allows us to formulate the problem as a weighted linear least-squares problem. Let's define a weight for each data point as $w_i = 1/\\sigma_i$. Minimizing the $\\chi^2$ is equivalent to solving the ordinary least-squares problem for the weighted quantities $y'_i = y_i w_i$ and $f'(a_i; \\vec{p}) = f(a_i; \\vec{p}) w_i$.\n\nIn matrix form, we want to solve the system $\\mathbf{A} \\vec{p} \\approx \\vec{Y}$, where $\\vec{Y}$ is the vector of weighted measurements with elements $Y_i = y_i / \\sigma_i$, $\\vec{p}$ is the vector of parameters to be determined, and $\\mathbf{A}$ is the weighted design matrix. The solution that minimizes the squared norm $||\\mathbf{A} \\vec{p} - \\vec{Y}||^2$ (which is precisely the $\\chi^2$) is given by the normal equations:\n$$\n\\vec{p} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\vec{Y}\n$$\nThis is numerically and robustly solved using linear algebra routines, such as those provided by `numpy.linalg.lstsq`, which typically employ methods like Singular Value Decomposition (SVD).\n\nThe four tasks for each test case are executed as follows:\n\n**1. Unimproved Continuum Extrapolation:**\nThe \"unimproved\" data, from a Wilson-type action suffering from leading-order discretization errors of $\\mathcal{O}(a)$, are fitted to the corresponding scaling model:\n$$\nM_N(a) = M_0 + c_1 a + c_2 a^2\n$$\nThe parameters to be determined are $\\vec{p} = (M_0, c_1, c_2)^T$. The weighted design matrix $\\mathbf{A}_{\\text{unimp}}$ has rows given by $(1/\\sigma_i, a_i/\\sigma_i, a_i^2/\\sigma_i)$. Solving the linear system yields the parameter vector, from which we extract the continuum-limit mass $M_{0,\\text{unimproved}} = p_1$.\n\n**2. Improved Continuum Extrapolation:**\nThe \"improved\" data, where the $\\mathcal{O}(a)$ artifacts are non-perturbatively removed by tuning the Sheikholeslami-Wohlert (SW) coefficient $c_{\\text{SW}}$, are expected to have leading errors of $\\mathcal{O}(a^2)$. Therefore, we fit them to the simpler model:\n$$\nM_N(a) = M_0 + c_2 a^2\n$$\nHere, the parameters are $\\vec{p} = (M_0, c_2)^T$. The weighted design matrix $\\mathbf{A}_{\\text{imp}}$ has rows $(1/\\sigma_i, a_i^2/\\sigma_i)$. Solving this system yields a new parameter vector, from which we extract the improved continuum-limit mass $M_{0,\\text{improved}} = p_1$.\n\n**3. Model Comparison using AIC:**\nTo quantitatively assess whether the removal of the $c_1 a$ term is justified for the \"improved\" dataset, we use the Akaike Information Criterion (AIC). A simplified version suitable for least-squares fitting with Gaussian errors is $\\mathrm{AIC}' = \\chi^2_{\\text{min}} + 2k$, where $\\chi^2_{\\text{min}}$ is the minimum value of the $\\chi^2$ from the fit, and $k$ is the number of parameters in the model. A lower AIC' value indicates a better model, balancing goodness-of-fit with model simplicity.\n\nWe perform two fits on the improved dataset:\n- Fit to the $\\mathcal{O}(a)$ model ($M_N(a) = M_0 + c_1 a + c_2 a^2$): Number of parameters $k_a = 3$. We compute its minimum chi-squared, $\\chi^2_a$, and its AIC score, $\\mathrm{AIC}'_a = \\chi^2_a + 2k_a = \\chi^2_a + 6$.\n- Fit to the $\\mathcal{O}(a^2)$ model ($M_N(a) = M_0 + c_2 a^2$): Number of parameters $k_{a^2} = 2$. We compute its minimum chi-squared, $\\chi^2_{a^2}$, and its AIC score, $\\mathrm{AIC}'_{a^2} = \\chi^2_{a^2} + 2k_{a^2} = \\chi^2_{a^2} + 4$.\n\nThe problem asks for an indicator that is $1$ if the $\\mathcal{O}(a^2)$ model is preferred, meaning $\\mathrm{AIC}'_{a^2} < \\mathrm{AIC}'_a$, and $0$ otherwise.\n\n**4. Calculation of Effect Size:**\nThe difference $\\Delta M_0 = M_{0,\\text{unimproved}} - M_{0,\\text{improved}}$ is calculated. This quantity represents the systematic shift in the determined continuum mass due to the improvement of the lattice action, i.e., the effect of removing the dominant $\\mathcal{O}(a)$ discretization artifacts.\n\nThe implementation will process each test case by constructing the appropriate design matrices and response vectors, calling a numerical least-squares solver to find the parameters and the residual sum of squares (the $\\chi^2$), and then using these results to compute the four required quantities.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lattice QCD continuum extrapolation problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"a\": [0.12, 0.09, 0.06, 0.045],\n            \"unimproved\": {\n                \"y\": [0.9680, 0.9590, 0.9510, 0.9480],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            },\n            \"improved\": {\n                \"y\": [0.9420, 0.9400, 0.9390, 0.9385],\n                \"sigma\": [0.0040, 0.0035, 0.0030, 0.0030]\n            }\n        },\n        {\n            \"a\": [0.08, 0.06, 0.04, 0.03],\n            \"unimproved\": {\n                \"y\": [0.9530, 0.9490, 0.9450, 0.9440],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            },\n            \"improved\": {\n                \"y\": [0.9405, 0.9397, 0.9393, 0.9392],\n                \"sigma\": [0.0030, 0.0025, 0.0020, 0.0020]\n            }\n        },\n        {\n            \"a\": [0.15, 0.12, 0.10],\n            \"unimproved\": {\n                \"y\": [0.9870, 0.9750, 0.9680],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            },\n            \"improved\": {\n                \"y\": [0.9460, 0.9430, 0.9420],\n                \"sigma\": [0.0050, 0.0040, 0.0040]\n            }\n        }\n    ]\n\n    def perform_weighted_fit(a, y, sigma, basis_functions):\n        \"\"\"\n        Performs a weighted linear least-squares fit.\n\n        Args:\n            a (np.ndarray): Independent variable values.\n            y (np.ndarray): Dependent variable values.\n            sigma (np.ndarray): Uncertainties on y.\n            basis_functions (list of callables): Basis functions for the model.\n\n        Returns:\n            tuple: A tuple containing the fitted parameters and the minimum chi-squared.\n        \"\"\"\n        weights = 1.0 / sigma\n        Y_weighted = y * weights\n        \n        A_weighted = np.zeros((len(a), len(basis_functions)))\n        for i, func in enumerate(basis_functions):\n            A_weighted[:, i] = func(a) * weights\n            \n        params, residuals, _, _ = np.linalg.lstsq(A_weighted, Y_weighted, rcond=None)\n        \n        # residuals is an array with one element, the sum of squared residuals,\n        # which is the chi-squared value for the fit.\n        chi_squared = residuals[0] if residuals.size > 0 else 0.0\n        \n        return params, chi_squared\n\n    all_results = []\n    \n    # Define the basis functions for the two models\n    o_a_basis = [lambda x: 1.0, lambda x: x, lambda x: x**2]\n    o_a2_basis = [lambda x: 1.0, lambda x: x**2]\n\n    for case in test_cases:\n        a_vals = np.array(case['a'], dtype=np.float64)\n        \n        # --- Task 1: Fit unimproved data with O(a) model ---\n        unimp_y = np.array(case['unimproved']['y'], dtype=np.float64)\n        unimp_sigma = np.array(case['unimproved']['sigma'], dtype=np.float64)\n        params_unimp, _ = perform_weighted_fit(a_vals, unimp_y, unimp_sigma, o_a_basis)\n        m0_unimproved = params_unimp[0]\n\n        # --- Task 2: Fit improved data with O(a^2) model ---\n        imp_y = np.array(case['improved']['y'], dtype=np.float64)\n        imp_sigma = np.array(case['improved']['sigma'], dtype=np.float64)\n        params_imp_a2, chi2_a2_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a2_basis)\n        m0_improved = params_imp_a2[0]\n\n        # --- Task 3: Compare models on improved data using AIC ---\n        # Fit 1: O(a) model on improved data\n        k_a = len(o_a_basis)\n        _, chi2_a_on_imp = perform_weighted_fit(a_vals, imp_y, imp_sigma, o_a_basis)\n        aic_a = chi2_a_on_imp + 2 * k_a\n\n        # Fit 2: O(a^2) model on improved data (already done)\n        k_a2 = len(o_a2_basis)\n        aic_a2 = chi2_a2_on_imp + 2 * k_a2\n        \n        # Report 1 if O(a^2) model is preferred (smaller AIC)\n        aic_indicator = 1 if aic_a2  aic_a else 0\n\n        # --- Task 4: Compute effect size ---\n        delta_m0 = m0_unimproved - m0_improved\n\n        # --- Aggregate and format results for this case ---\n        all_results.extend([\n            f\"{m0_unimproved:.6f}\",\n            f\"{m0_improved:.6f}\",\n            f\"{delta_m0:.6f}\",\n            str(aic_indicator)\n        ])\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}