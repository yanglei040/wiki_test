{
    "hands_on_practices": [
        {
            "introduction": "为了建立对分类器性能的深刻理解，我们首先从一个理想化的解析场景开始。这个练习要求您推导在简单高斯假设下，最优分类器的接收者操作特征（ROC）曲线。通过这个“纸笔”练习，您将掌握如何利用内曼-皮尔逊引理，将信号与背景分布的统计距离直接与分类器的性能联系起来，从而为评估更复杂的现实世界模型建立一个重要的理论基准。",
            "id": "3524097",
            "problem": "在一个用于计算高能物理中信号甄别的二元分类场景中，考虑一个从属于信号类 $S$ 或背景类 $B$ 的事例中测量得到的一维特征 $x$。类条件密度是方差相等的高斯分布，具体为 $p(x \\mid S) = \\mathcal{N}(\\mu_{S}, \\sigma^{2})$ 和 $p(x \\mid B) = \\mathcal{N}(\\mu_{B}, \\sigma^{2})$，其中 $\\mu_{S}$、$\\mu_{B}$ 和 $\\sigma > 0$ 是有限常数，且 $\\mu_{S} > \\mu_{B}$。使用Neyman–Pearson引理和似然比检验 (LRT) 作为假阳性约束下的最优检测器，通过对由似然比阈值导出的决策区域上的高斯分布进行解析积分，构建受试者工作特征 (ROC) 曲线。消去阈值以获得一个闭式函数关系，该关系将真阳性率表示为所有允许阈值下假阳性率的函数。你的最终答案必须是关于 $\\mu_{S}$、$\\mu_{B}$ 和 $\\sigma$ 的单一闭式解析表达式，并且可以包含标准正态分布的累积分布函数。不要提供任何数值近似；要求提供精确表达式。",
            "solution": "用户希望推导一个具有高斯类条件密度的二元分类问题的受试者工作特征 (ROC) 曲线。\n\n### 问题验证\n\n**第1步：提取已知条件**\n-   **二元分类：** 信号类 $S$ 对 背景类 $B$。\n-   **特征：** 一维特征 $x$。\n-   **类条件密度：**\n    -   信号：$p(x \\mid S) = \\mathcal{N}(\\mu_{S}, \\sigma^{2})$\n    -   背景：$p(x \\mid B) = \\mathcal{N}(\\mu_{B}, \\sigma^{2})$\n-   **参数：** $\\mu_{S}$、$\\mu_{B}$ 和 $\\sigma$ 是有限常数。\n-   **约束条件：** $\\sigma > 0$ 且 $\\mu_{S} > \\mu_{B}$。\n-   **方法：** Neyman–Pearson引理和似然比检验 (LRT)。\n-   **目标：** 通过找到真阳性率 (TPR) 和假阳性率 (FPR) 之间的闭式函数关系来构建 ROC 曲线。最终表达式应使用 $\\mu_{S}$、$\\mu_{B}$ 和 $\\sigma$ 表示，并可包含标准正态分布的累积分布函数。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题是统计信号处理和决策理论中的一个经典基础练习，这也是高能物理数据分析的核心组成部分。高斯分布和Neyman-Pearson引理的使用是标准且科学合理的。\n-   **适定性：** 该问题是适定的。分布被完全指定，条件 $\\mu_{S} > \\mu_{B}$ 确保了这是一个非平凡的甄别问题。目标明确，且存在唯一的解析解。\n-   **客观性：** 该问题以精确、客观的数学语言陈述。\n-   **缺陷评估：** 该问题未违反任何无效性标准。它是科学合理的、可形式化的、完整的、可行的和适定的。\n\n**第3步：结论与行动**\n该问题是 **有效的**。将提供解答。\n\n### 解答推导\n\n该问题要求推导受试者工作特征 (ROC) 曲线，该曲线描述了二元分类器的性能。ROC 曲线是真阳性率 (TPR) 对 假阳性率 (FPR) 的图。\n\n根据Neyman–Pearson引理，用于甄别两个简单假设 $H_B: x \\sim p(x \\mid B)$ (背景) 和 $H_S: x \\sim p(x \\mid S)$ (信号) 的最优检验是似然比检验 (LRT)。似然比 $\\Lambda(x)$ 定义为：\n$$\n\\Lambda(x) = \\frac{p(x \\mid S)}{p(x \\mid B)}\n$$\n决策规则是，如果 $\\Lambda(x) > \\eta$，则将观测值 $x$ 分类为信号，其中 $\\eta$ 是一个决策阈值。$\\eta$ 的值决定了 ROC 曲线上的一个点。\n\n鉴于类条件密度是方差相等的高斯分布：\n$$\np(x \\mid S) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(x - \\mu_{S})^2}{2\\sigma^2}\\right)\n$$\n$$\np(x \\mid B) = \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(x - \\mu_{B})^2}{2\\sigma^2}\\right)\n$$\n似然比为：\n$$\n\\Lambda(x) = \\frac{\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(x - \\mu_{S})^2}{2\\sigma^2}\\right)}{\\frac{1}{\\sqrt{2\\pi}\\sigma}\\exp\\left(-\\frac{(x - \\mu_{B})^2}{2\\sigma^2}\\right)} = \\exp\\left( \\frac{(x - \\mu_{B})^2 - (x - \\mu_{S})^2}{2\\sigma^2} \\right)\n$$\n由于自然对数 $\\ln$ 是一个单调递增函数，不等式 $\\Lambda(x) > \\eta$ 等价于 $\\ln(\\Lambda(x)) > \\ln(\\eta)$。对似然比取对数可以简化表达式：\n$$\n\\ln(\\Lambda(x)) = \\frac{(x^2 - 2x\\mu_{B} + \\mu_{B}^2) - (x^2 - 2x\\mu_{S} + \\mu_{S}^2)}{2\\sigma^2} = \\frac{2x(\\mu_{S} - \\mu_{B}) - (\\mu_{S}^2 - \\mu_{B}^2)}{2\\sigma^2}\n$$\n$$\n\\ln(\\Lambda(x)) = \\frac{\\mu_{S} - \\mu_{B}}{\\sigma^2}x - \\frac{\\mu_{S}^2 - \\mu_{B}^2}{2\\sigma^2}\n$$\n决策规则 $\\ln(\\Lambda(x)) > \\ln(\\eta)$ 变为：\n$$\n\\frac{\\mu_{S} - \\mu_{B}}{\\sigma^2}x > \\ln(\\eta) + \\frac{\\mu_{S}^2 - \\mu_{B}^2}{2\\sigma^2}\n$$\n鉴于问题陈述 $\\mu_{S} > \\mu_{B}$，项 $\\frac{\\mu_{S} - \\mu_{B}}{\\sigma^2}$ 是正的。因此，该不等式等价于，如果 $x$ 大于某个我们记为 $x_{th}$ 的阈值，就将事件分类为信号：\n$$\nx > x_{th} \\quad \\text{其中} \\quad x_{th} = \\frac{\\sigma^2}{\\mu_{S} - \\mu_{B}}\\left(\\ln(\\eta) + \\frac{\\mu_{S}^2 - \\mu_{B}^2}{2\\sigma^2}\\right)\n$$\n信号的决策区域是 $\\Omega_{S} = \\{x \\in \\mathbb{R} \\mid x > x_{th}\\}$。将LRT阈值 $\\eta$ 从 $0$ 变到 $\\infty$ 对应于将 $x_{th}$ 从 $-\\infty$ 变到 $\\infty$。\n\nTPR 和 FPR 分别定义为信号或背景事件落入信号决策区域 $\\Omega_S$ 的概率：\n$$\n\\text{TPR}(x_{th}) = P(x \\in \\Omega_S \\mid S) = \\int_{x_{th}}^{\\infty} p(x \\mid S) dx\n$$\n$$\n\\text{FPR}(x_{th}) = P(x \\in \\Omega_S \\mid B) = \\int_{x_{th}}^{\\infty} p(x \\mid B) dx\n$$\n这些积分可以用标准正态分布 $\\mathcal{N}(0, 1)$ 的累积分布函数 (CDF) 来表示，我们将其记为 $\\Phi(z) = \\int_{-\\infty}^{z} \\frac{1}{\\sqrt{2\\pi}} \\exp(-t^2/2) dt$。\n对于一个一般的高斯变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，概率 $P(X > a)$ 由下式给出：\n$$\nP(X > a) = P\\left(\\frac{X - \\mu}{\\sigma} > \\frac{a - \\mu}{\\sigma}\\right) = 1 - \\Phi\\left(\\frac{a - \\mu}{\\sigma}\\right)\n$$\n使用标准正态PDF的对称性 $1 - \\Phi(z) = \\Phi(-z)$，我们有：\n$$\nP(X > a) = \\Phi\\left(-\\frac{a - \\mu}{\\sigma}\\right) = \\Phi\\left(\\frac{\\mu - a}{\\sigma}\\right)\n$$\n将此应用于我们的 TPR 和 FPR 表达式：\n$$\n\\text{TPR}(x_{th}) = \\Phi\\left(\\frac{\\mu_{S} - x_{th}}{\\sigma}\\right)\n$$\n$$\n\\text{FPR}(x_{th}) = \\Phi\\left(\\frac{\\mu_{B} - x_{th}}{\\sigma}\\right)\n$$\n这两个方程提供了 ROC 曲线的参数表示，其中 $x_{th}$ 是参数。为了得到所期望的表示 TPR 为 FPR 函数的闭式关系，我们必须消去 $x_{th}$。\n从 FPR 方程中，我们使用标准正态CDF的反函数（分位数函数或概率单位函数），记为 $\\Phi^{-1}$，来解出 $x_{th}$：\n$$\n\\Phi^{-1}(\\text{FPR}) = \\frac{\\mu_{B} - x_{th}}{\\sigma}\n$$\n$$\n\\sigma \\Phi^{-1}(\\text{FPR}) = \\mu_{B} - x_{th}\n$$\n$$\nx_{th} = \\mu_{B} - \\sigma \\Phi^{-1}(\\text{FPR})\n$$\n现在，将 $x_{th}$ 的这个表达式代入 TPR 方程中：\n$$\n\\text{TPR} = \\Phi\\left(\\frac{\\mu_{S} - (\\mu_{B} - \\sigma \\Phi^{-1}(\\text{FPR}))}{\\sigma}\\right)\n$$\n简化 $\\Phi$ 的参数：\n$$\n\\text{TPR} = \\Phi\\left(\\frac{\\mu_{S} - \\mu_{B} + \\sigma \\Phi^{-1}(\\text{FPR})}{\\sigma}\\right)\n$$\n$$\n\\text{TPR} = \\Phi\\left(\\frac{\\mu_{S} - \\mu_{B}}{\\sigma} + \\Phi^{-1}(\\text{FPR})\\right)\n$$\n这就是 ROC 曲线的最终闭式解析表达式，它关联了真阳性率和假阳性率。该表达式取决于指定的参数 $\\mu_S$、$\\mu_B$ 和 $\\sigma$，并涉及标准正态CDF $\\Phi$ 及其反函数 $\\Phi^{-1}$。项 $\\frac{\\mu_S - \\mu_B}{\\sigma}$ 是以标准差为单位的、衡量两个分布之间间隔的度量。",
            "answer": "$$\n\\boxed{\\Phi\\left(\\frac{\\mu_{S} - \\mu_{B}}{\\sigma} + \\Phi^{-1}(\\text{FPR})\\right)}\n$$"
        },
        {
            "introduction": "在掌握了理想情况下的理论后，我们将转向一个更贴近高能物理实验现实的计算问题。真实物理量（如粒子能量）往往无法被完美测量，我们观测到的是经过探测器响应“模糊”后的结果。本练习要求您通过数值积分，将真实的“部分子能级”能量分布与高斯探测器传递函数进行卷积，来构建给定观测能量下的信号和背景似然，进而计算出最优判别函数。",
            "id": "3524159",
            "problem": "考虑一个用于高能物理 (HEP) 多变量信号甄别的简化二元假设检验，该检验在一个二体到二体 ($2 \\to 2$) 散射过程的质心 (CoM) 系的玩具模型中进行。单个测量的标量可观测量 $x$ 表示一个末态粒子的量能器能量测量值。真实但潜在的能量是 $E$。探测器响应由高斯传递函数建模，部分子级能量分布取决于假设 $H \\in \\{S,B\\}$，其中 $S$ 表示信号假设，$B$ 表示背景假设。所有能量都必须以 $\\mathrm{GeV}$ 为单位处理，概率密度函数 (PDF) 需被视为关于能量（单位 $\\mathrm{GeV}$）的函数。\n\n从全概率定律和传递函数的定义出发，在假设 $H$ 下观测到 $x$ 的条件似然由以下积分给出\n$$\nP(x \\mid H) \\;=\\; \\int_{0}^{E_{\\max}} W(x \\mid E)\\, f_H(E)\\, dE,\n$$\n其中 $W(x \\mid E)$ 是探测器传递函数，$f_H(E)$ 是在假设 $H$ 下归一化的部分子级能量概率密度函数。\n\n您必须使用以下具体且物理上合理的建模选择：\n- 能量支撑集：$E \\in [0, E_{\\max}]$，其中 $E_{\\max} = 1000\\,\\mathrm{GeV}$。\n- 探测器传递函数 (高斯)：对于任意实数 $x$ 和 $E \\in [0,E_{\\max}]$，\n$$\nW(x \\mid E) \\;=\\; \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{\\text{meas}}}\\,\\exp\\!\\left(-\\frac{(x - E)^2}{2\\,\\sigma_{\\text{meas}}^2}\\right), \\quad \\sigma_{\\text{meas}} = 20\\,\\mathrm{GeV}.\n$$\n- 信号先验 (部分子级) 概率密度函数：在 $[0,E_{\\max}]$ 上的截断高斯形状，均值 $\\mu_S = 500\\,\\mathrm{GeV}$，宽度参数 $\\tau_S = 60\\,\\mathrm{GeV}$，\n$$\nf_S(E) \\;=\\; \\frac{\\exp\\!\\left(-\\frac{(E - \\mu_S)^2}{2\\,\\tau_S^2}\\right)}{Z_S}, \\quad Z_S \\;=\\; \\int_{0}^{E_{\\max}} \\exp\\!\\left(-\\frac{(E - \\mu_S)^2}{2\\,\\tau_S^2}\\right)\\, dE.\n$$\n- 背景先验 (部分子级) 概率密度函数：在 $[0,E_{\\max}]$ 上的下降幂律，标度 $E_0 = 200\\,\\mathrm{GeV}$，指数 $n = 3.5$，\n$$\nf_B(E) \\;=\\; \\frac{\\left(1 + \\frac{E}{E_0}\\right)^{-n}}{Z_B}, \\quad Z_B \\;=\\; \\int_{0}^{E_{\\max}} \\left(1 + \\frac{E}{E_0}\\right)^{-n} dE.\n$$\n\n通过针对两个简单假设的 Neyman–Pearson (NP) 构造，定义最优等先验判别函数 $D(x)$ 如下\n$$\nD(x) \\;=\\; \\frac{P(x \\mid S)}{P(x \\mid S) + P(x \\mid B)}.\n$$\n\n任务：\n- 使用所提供的 $W(x \\mid E)$ 和 $f_H(E)$，明确地写出 $P(x \\mid H)$ 的积分表达式。\n- 在每个指定的 $x$ 值处，通过对能量 $E$ 在 $[0, E_{\\max}]$ 上进行一维数值积分，计算 $P(x \\mid S)$、$P(x \\mid B)$ 和 $D(x)$ 的数值近似值。归一化系数 $Z_S$ 和 $Z_B$ 的计算必须与主似然积分使用相同的数值精度标准。\n- 所有中间和最终计算都必须与所述单位一致；然而，最终报告的值是纯数，对于 $P(x \\mid H)$ 对应于单位为 $\\mathrm{GeV}^{-1}$ 的概率密度函数值，对于 $D(x)$ 则是无量纲的。\n- 报告每个请求的数值，四舍五入到 $6$ 位小数。\n\n测试组：\n- 使用以下 $x$ 值 (单位 $\\mathrm{GeV}$): $x \\in \\{500.0,\\, 50.0,\\, 950.0,\\, 0.0,\\, 1000.0\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的扁平列表，顺序为\n$$\n[\\;P(x_1\\mid S),\\;P(x_1\\mid B),\\;D(x_1),\\;P(x_2\\mid S),\\;P(x_2\\mid B),\\;D(x_2),\\;\\ldots\\;],\n$$\n每个浮点数按要求四舍五入到 $6$ 位小数。不得打印任何额外文本。\n- 程序必须完全自包含，不需要用户输入，并且只使用指定的数值库。",
            "solution": "该问题要求为高能物理中一个简化的信号与背景假设检验计算条件似然和一个最优判别函数。问题的核心在于通过一个探测器响应模型，将一个真实的、潜在的能量分布与一个测量的可观测量联系起来。这种关系在数学上由一个卷积积分来描述。\n\n其基本原理是全概率定律。给定一个假设 $H$（$H$ 为信号 $S$ 或背景 $B$），观测到测量能量 $x$ 的概率密度，是通过对所有可能的真实能量值 $E$ 进行边缘化得到的。这通过以下积分表示：\n$$\nP(x \\mid H) = \\int P(x, E \\mid H) \\, dE\n$$\n使用条件概率的定义，$P(x, E \\mid H) = P(x \\mid E, H) f_H(E)$，其中 $f_H(E)$ 是在假设 $H$ 下真实能量 $E$ 的概率密度。探测器响应 $W(x \\mid E)$ 被假定为独立于底层的物理假设，因此 $P(x \\mid E, H) = W(x \\mid E)$。于是积分变为：\n$$\nP(x \\mid H) = \\int_{0}^{E_{\\max}} W(x \\mid E) f_H(E) \\, dE\n$$\n积分在真实能量的允许范围 $E \\in [0, E_{\\max}]$ 上进行。\n\n问题为所有组件提供了具体的函数形式：\n能量范围由 $E_{\\max} = 1000\\,\\mathrm{GeV}$ 定义。\n探测器传递函数 $W(x \\mid E)$ 将测量分辨率建模为一个以真实能量 $E$ 为中心的高斯分布：\n$$\nW(x \\mid E) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_{\\text{meas}}}\\,\\exp\\!\\left(-\\frac{(x - E)^2}{2\\,\\sigma_{\\text{meas}}^2}\\right), \\quad \\text{with } \\sigma_{\\text{meas}} = 20\\,\\mathrm{GeV}\n$$\n部分子级能量概率密度函数 $f_H(E)$ 必须在定义域 $[0, E_{\\max}]$ 上归一化为1。\n\n对于信号假设 ($H=S$):\n概率密度函数 $f_S(E)$ 是一个截断高斯分布，均值为 $\\mu_S = 500\\,\\mathrm{GeV}$，宽度为 $\\tau_S = 60\\,\\mathrm{GeV}$。\n$$\nf_S(E) = \\frac{1}{Z_S} \\exp\\!\\left(-\\frac{(E - \\mu_S)^2}{2\\,\\tau_S^2}\\right)\n$$\n其中归一化常数 $Z_S$ 由未归一化分布在能量支撑集上的积分给出：\n$$\nZ_S = \\int_{0}^{E_{\\max}} \\exp\\!\\left(-\\frac{(E - \\mu_S)^2}{2\\,\\tau_S^2}\\right) dE\n$$\n\n对于背景假设 ($H=B$):\n概率密度函数 $f_B(E)$ 是一个下降幂律分布，标度为 $E_0 = 200\\,\\mathrm{GeV}$，指数为 $n = 3.5$。\n$$\nf_B(E) = \\frac{1}{Z_B} \\left(1 + \\frac{E}{E_0}\\right)^{-n}\n$$\n相应的归一化常数 $Z_B$ 是：\n$$\nZ_B = \\int_{0}^{E_{\\max}} \\left(1 + \\frac{E}{E_0}\\right)^{-n} dE\n$$\n\n将这些定义代入主卷积积分，我们得到条件似然的显式表达式：\n对于信号：\n$$\nP(x \\mid S) = \\int_{0}^{1000} \\left[ \\frac{1}{\\sqrt{2\\pi}\\,(20)}\\exp\\!\\left(-\\frac{(x - E)^2}{2\\,(20)^2}\\right) \\right] \\left[ \\frac{1}{Z_S}\\exp\\!\\left(-\\frac{(E - 500)^2}{2\\,(60)^2}\\right) \\right] dE\n$$\n对于背景：\n$$\nP(x \\mid B) = \\int_{0}^{1000} \\left[ \\frac{1}{\\sqrt{2\\pi}\\,(20)}\\exp\\!\\left(-\\frac{(x - E)^2}{2\\,(20)^2}\\right) \\right] \\left[ \\frac{1}{Z_B}\\left(1 + \\frac{E}{200}\\right)^{-3.5} \\right] dE\n$$\n这些积分，包括用于 $Z_S$ 和 $Z_B$ 的积分，并非都有简单的闭式解析解，必须进行数值计算。问题指定对所有积分使用一致的数值方法。完成此任务的一个稳健方法是数值积分法，例如 Python 中 `scipy.integrate.quad` 函数所提供的，它实现了一个高精度自适应积分算法。\n\n计算过程如下：\n1.  通过对未归一化的概率密度函数从 $E=0$ 到 $E=E_{\\max}$ 进行积分，数值计算归一化常数 $Z_S$ 和 $Z_B$。\n2.  对于可观测量 $x$ 的每个指定值，数值计算积分 $P(x \\mid S)$ 和 $P(x \\mid B)$。\n3.  根据这些似然值，计算 Neyman-Pearson 判别函数 $D(x)$。在信号和背景的先验概率相等的情况下，这等同于信号假设的后验概率：\n$$\nD(x) = \\frac{P(x \\mid S)}{P(x \\mid S) + P(x \\mid B)}\n$$\n这个量为甄别两种假设提供了一个最优度量，其值趋近于 $1$ 表示一个类信号事件，趋近于 $0$ 表示一个类背景事件。要求的值是为测试组 $\\{500.0, 50.0, 950.0, 0.0, 1000.0\\}$ 中的每个 $x$ 计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes likelihoods and discriminant for a HEP hypothesis test.\n    \"\"\"\n    # Define the physical and model constants from the problem statement.\n    E_max = 1000.0  # GeV\n    sigma_meas = 20.0  # GeV\n    mu_S = 500.0  # GeV\n    tau_S = 60.0  # GeV\n    E_0 = 200.0  # GeV\n    n = 3.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [500.0, 50.0, 950.0, 0.0, 1000.0]\n\n    # --- Step 1: Define unnormalized parton-level PDFs ---\n\n    def unnormalized_fs(E):\n        \"\"\"Unnormalized signal PDF.\"\"\"\n        return np.exp(-(E - mu_S)**2 / (2 * tau_S**2))\n\n    def unnormalized_fb(E):\n        \"\"\"Unnormalized background PDF.\"\"\"\n        return (1 + E / E_0)**(-n)\n\n    # --- Step 2: Compute normalization constants Z_S and Z_B ---\n    # The integrals are computed numerically for consistency as required.\n    Z_S, _ = quad(unnormalized_fs, 0, E_max)\n    Z_B, _ = quad(unnormalized_fb, 0, E_max)\n\n    # --- Step 3: Define normalized PDFs and the transfer function ---\n\n    def f_S(E):\n        \"\"\"Normalized signal PDF f_S(E).\"\"\"\n        return unnormalized_fs(E) / Z_S\n\n    def f_B(E):\n        \"\"\"Normalized background PDF f_B(E).\"\"\"\n        return unnormalized_fb(E) / Z_B\n\n    def W(x, E):\n        \"\"\"Detector transfer function W(x|E).\"\"\"\n        return (1 / (np.sqrt(2 * np.pi) * sigma_meas)) * np.exp(-(x - E)**2 / (2 * sigma_meas**2))\n\n    # --- Step 4: Compute likelihoods and discriminant for each x ---\n    \n    results = []\n    for x in test_cases:\n        # Define the integrands for the convolution integrals P(x|H).\n        # The integrand is the product of the transfer function and the prior PDF.\n        def integrand_S(E):\n            return W(x, E) * f_S(E)\n\n        def integrand_B(E):\n            return W(x, E) * f_B(E)\n\n        # Perform numerical integration to find the likelihoods P(x|S) and P(x|B).\n        P_x_S, _ = quad(integrand_S, 0, E_max)\n        P_x_B, _ = quad(integrand_B, 0, E_max)\n\n        # Compute the optimal discriminant D(x).\n        # A check for division by zero is prudent, though unlikely in this scenario\n        # as the likelihoods are integrals of non-negative functions.\n        denominator = P_x_S + P_x_B\n        if denominator == 0:\n            # This case corresponds to an observed x that is impossible under both hypotheses.\n            # The discriminant is undefined; a neutral value of 0.5 is a reasonable default.\n            D_x = 0.5\n        else:\n            D_x = P_x_S / denominator\n        \n        results.extend([P_x_S, P_x_B, D_x])\n\n    # --- Step 5: Format and print the final output ---\n\n    # Format each number to 6 decimal places as a string.\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    \n    # Print the final result in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀的分类器不仅应能有效地区分信号与背景，其输出分数还应能被解释为可靠的概率。本练习将引导您解决分类器校准这一关键问题，您将使用保序回归（Isotonic Regression）这一强大的非参数技术来校准一个非理想分类器的输出。通过实现“邻近违规者合并” (PAV) 算法并计算布莱尔分数（Brier Score），您将学会如何量化并提升分类器输出的概率意义，使其从一个排序工具转变为一个精确的统计测量工具。",
            "id": "3524128",
            "problem": "给定来自计算高能物理中用于信号甄别的多变量分类器的分箱验证数据。每个箱对应一个连续的分类器得分范围，并包含一定数量的信号事件和背景事件。假设该分类器产生一个被解释为未校准概率估计的分数，您希望通过保序回归解决一个单调回归问题，将其校准为合适的概率，然后使用 Brier 分数来量化校准质量。\n\n从以下基础开始：\n- 平方损失下的经验风险最小化原则要求最小化预测相对于目标的加权均方误差。对于分箱数据，使用每个箱内观测到的正例分数，这变成最小化加权平方偏差和。\n- 保序回归是在由权重导出的范数下，将一个向量投影到非递减序列锥上，从而产生一个最小化加权平方损失的非递减函数估计。\n- Brier 分数是预测概率与二元结果之间平方差的平均值。\n\n形式上，假设有 $n$ 个箱，索引为 $i \\in \\{1,\\dots,n\\}$。对于每个箱 $i$，给定：\n- 一个代表性的分类器得分 $x_i \\in [0,1]$（假设各箱已按 $x_i$ 递增排序）。\n- 信号事件数 $s_i \\in \\mathbb{N}$ 和背景事件数 $b_i \\in \\mathbb{N}$，总数为 $n_i = s_i + b_i$。\n定义观测正例率 $y_i = s_i / n_i$。定义校准权重 $w_i = n_i$。\n\n您的任务是：\n1. 实现保序回归以解决单调回归问题\n$$\n\\min_{f_1,\\dots,f_n} \\sum_{i=1}^{n} w_i \\left(f_i - y_i\\right)^2 \\quad \\text{subject to} \\quad f_1 \\le f_2 \\le \\dots \\le f_n,\n$$\n为每个箱生成校准后的概率 $f_i$。使用正确的算法（带权重的平方损失下的保序回归）精确求解此问题（不要近似求解）。\n2. 计算分箱验证数据在校准前和校准后的 Brier 分数。对于箱级别的预测，事件级别的 Brier 分数可以使用计数精确计算：\n$$\n\\text{Brier}(p) = \\frac{1}{\\sum_{i=1}^{n} n_i} \\sum_{i=1}^{n} \\left[ s_i \\left(p_i - 1\\right)^2 + b_i \\left(p_i - 0\\right)^2 \\right],\n$$\n其中 $p_i$ 是箱 $i$ 中所有事件的预测概率。使用 $p_i = x_i$ 计算校准前的 Brier 分数，使用 $p_i = f_i$ 计算校准后的 Brier 分数。\n3. 为一个包含四种情况的测试套件生成结果，这些情况探究了解决方案的不同方面，包括非单调的观测率、已经是单调的情况、极端概率和得分并列的情况。\n\n使用以下测试套件：\n- 情况 1（需要合并的非单调观测率）：\n  - $x = [0.05, 0.15, 0.30, 0.45, 0.60]$\n  - $s = [5, 12, 10, 8, 25]$\n  - $b = [95, 88, 90, 92, 75]$\n- 情况 2（已经是单调且接近校准）：\n  - $x = [0.02, 0.10, 0.25, 0.40, 0.55, 0.70]$\n  - $s = [2, 8, 20, 35, 55, 70]$\n  - $b = [98, 92, 80, 65, 45, 30]$\n- 情况 3（包含 $y_i$ 接近 $0$ 和 $1$ 的箱的极端情况）：\n  - $x = [0.05, 0.20, 0.50, 0.80, 0.95]$\n  - $s = [0, 4, 25, 80, 95]$\n  - $b = [100, 96, 75, 20, 5]$\n- 情况 4（得分并列且存在局部非单调性）：\n  - $x = [0.10, 0.10, 0.30, 0.30, 0.30, 0.60]$\n  - $s = [12, 8, 25, 18, 20, 40]$\n  - $b = [88, 92, 75, 82, 80, 60]$\n\n算法要求：\n- 使用 Pool Adjacent Violators (PAV) 算法实现保序回归，其中 Pool Adjacent Violators (PAV) 是带权重平方损失下保序回归的标准精确算法。\n- 除了指定的环境外，不要依赖外部数据或任何机器学习库。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\text{pre}_1, \\text{post}_1, \\text{pre}_2, \\text{post}_2, \\text{pre}_3, \\text{post}_3, \\text{pre}_4, \\text{post}_4]$，其中 $\\text{pre}_k$ 和 $\\text{post}_k$ 分别是情况 $k$ 的校准前和校准后 Brier 分数。将每个浮点数四舍五入到六位小数，不要打印任何其他文本。",
            "solution": "问题陈述已经过验证，被确定为一个有效、适定且有科学依据的问题。\n\n### 问题验证\n\n#### 步骤 1：提取的已知信息\n- **任务**：使用保序回归校准未校准的分类器得分，并使用 Brier 分数评估校准质量。\n- **每个箱 $i$ 的数据**：\n    - 代表性分类器得分：$x_i \\in [0,1]$，各箱按 $x_i$ 递增排序。\n    - 信号事件数：$s_i \\in \\mathbb{N}$。\n    - 背景事件数：$b_i \\in \\mathbb{N}$。\n- **派生量**：\n    - 每个箱的总事件数：$n_i = s_i + b_i$。\n    - 观测正例率（经验概率）：$y_i = s_i / n_i$。\n    - 回归权重：$w_i = n_i$。\n- **保序回归问题**：通过求解约束优化问题找到校准后的概率 $f_i$：\n$$\n\\min_{f_1,\\dots,f_n} \\sum_{i=1}^{n} w_i \\left(f_i - y_i\\right)^2 \\quad \\text{subject to} \\quad f_1 \\le f_2 \\le \\dots \\le f_n\n$$\n- **算法**：必须使用 Pool Adjacent Violators (PAV) 算法进行精确求解。\n- **评估指标**：对于一组分箱预测 $p_i$，Brier 分数由以下公式给出：\n$$\n\\text{Brier}(p) = \\frac{1}{\\sum_{i=1}^{n} n_i} \\sum_{i=1}^{n} \\left[ s_i \\left(p_i - 1\\right)^2 + b_i \\left(p_i - 0\\right)^2 \\right]\n$$\n- **评估场景**：\n    - 校准前：使用未校准的得分 $p_i = x_i$。\n    - 校准后：使用保序回归解 $p_i = f_i$。\n- **测试套件**：提供了四种具体情况，为每种情况定义了向量 $x$、$s$ 和 $b$。\n    - 情况 1：`x = [0.05, 0.15, 0.30, 0.45, 0.60]`, `s = [5, 12, 10, 8, 25]`, `b = [95, 88, 90, 92, 75]`\n    - 情况 2：`x = [0.02, 0.10, 0.25, 0.40, 0.55, 0.70]`, `s = [2, 8, 20, 35, 55, 70]`, `b = [98, 92, 80, 65, 45, 30]`\n    - 情况 3：`x = [0.05, 0.20, 0.50, 0.80, 0.95]`, `s = [0, 4, 25, 80, 95]`, `b = [100, 96, 75, 20, 5]`\n    - 情况 4：`x = [0.10, 0.10, 0.30, 0.30, 0.30, 0.60]`, `s = [12, 8, 25, 18, 20, 40]`, `b = [88, 92, 75, 82, 80, 60]`\n\n#### 步骤 2：使用提取的已知信息进行验证\n该问题具有科学依据、适定且客观。\n- **科学合理性**：分类器校准、保序回归、Pool Adjacent Violators (PAV) 算法和 Brier 分数等概念都是统计学和机器学习中标准且成熟的课题。将其应用于高能物理信号甄别是一个常见且合适的用例。\n- **适定性**：该问题定义了一个明确的目标（计算校准前后的 Brier 分数），提供了所有必要的数据和公式，并指定了要使用的确切算法 (PAV)。已知 PAV 算法能为加权最小二乘保序回归问题产生唯一解。\n- **完整性和一致性**：问题是完全自洽的。所有变量 ($x_i, s_i, b_i$)、定义 ($y_i, w_i, n_i$)、优化标准、评估指标和测试数据都已明确提供。没有内部矛盾。\n- **现实性**：所提供的数据（事件计数和分类器得分）对于来自物理实验的分箱数据是现实的。\n- **清晰性**：问题以精确的数学和算法术语表述，没有留下任何模糊空间。\n\n#### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 求解方法\n\n目标是校准分类器的输出并量化其改进。对于每个箱 $i$，提供的分类器得分 $x_i$ 被视为初始的、未校准的概率估计。校准过程旨在找到一组新的概率 $f_i$，这些概率相对于箱的排序是单调非递减的，并且更“接近”这些箱中真实观测到的事件分数。\n\n#### 步骤 1：初始数据处理\n对于每个测试用例，我们都得到了代表性得分 $x_i$、信号计数 $s_i$ 和背景计数 $b_i$。基于这些，我们首先为每个箱 $i \\in \\{1, \\dots, n\\}$ 计算必要的派生量：\n- 事件总数：$n_i = s_i + b_i$。\n- 观测到的信号分数，即经验概率：$y_i = s_i / n_i$。如果 $n_i = 0$，则该值为 $0$，不过所有测试用例中 $n_i > 0$。\n- 每个箱的权重，即事件数：$w_i = n_i$。\n\n#### 步骤 2：校准前 Brier 分数\nBrier 分数衡量预测概率与实际结果之间的均方误差。对于分箱数据，可以直接从计数中计算得出。在校准之前，箱 $i$ 中每个事件的预测概率取为代表性得分 $x_i$。校准前的 Brier 分数 $\\text{Brier}_{\\text{pre}}$ 计算如下：\n$$\n\\text{Brier}_{\\text{pre}} = \\frac{1}{\\sum_{j=1}^{n} n_j} \\sum_{i=1}^{n} \\left[ s_i \\left(x_i - 1\\right)^2 + b_i \\left(x_i - 0\\right)^2 \\right]\n$$\n在这里，项 $s_i(x_i - 1)^2$ 代表 $s_i$ 个信号事件（真实结果为 $1$）的平方误差总和，而 $b_i(x_i - 0)^2$ 是 $b_i$ 个背景事件（真实结果为 $0$）的误差。\n\n#### 步骤 3：使用 Pool Adjacent Violators (PAV) 算法进行保序回归\n校准的核心是找到一组校准后的概率 $f = (f_1, f_2, \\dots, f_n)$，这组概率在概率单调非递减的约束下，最小化了相对于观测分数 $y_i$ 的加权平方误差和。这就是保序回归问题：\n$$\n\\min_{f_1,\\dots,f_n} \\sum_{i=1}^{n} n_i \\left(f_i - y_i\\right)^2 \\quad \\text{subject to} \\quad f_1 \\le f_2 \\le \\dots \\le f_n\n$$\nPAV 算法为该问题提供了精确解。它通过迭代地识别和解决单调性约束的“违规”来操作，即在所考虑的序列中出现 $y_i > y_{i+1}$ 的情况。解决方法包括“合并”相邻的箱块，并用它们的加权平均值替换其各自的值，直到整个序列变为非递减。\n\n该算法可以实现如下：\n1. 初始化一个活动块集合。每个块代表一个或多个连续的原始箱。一个块可以用其总信号计数 $\\sum s_k$ 和总事件计数 $\\sum n_k$ 来表示。\n2. 遍历所有箱 $i = 1, \\dots, n$。对于每个箱，用其值 $(s_i, n_i)$ 创建一个新块，并将其添加到活动集合中。\n3. 添加新块后，检查其值（信号事件分数）是否小于活动集合中前一个块的值。\n   - 一个跨越从 $a$到 $b$ 的原始箱的块 $j$ 的值为 $V_j = (\\sum_{k=a}^{b} s_k) / (\\sum_{k=a}^{b} n_k)$。\n   - 如果存在违规 $V_{\\text{last}} < V_{\\text{prev}}$，则合并最后两个块。新的合并块的总信号计数等于被合并块的信号计数之和，总事件计数等于它们的事件计数之和。\n   - 向后重复此合并过程，直到活动集合中当前所有块都满足单调性约束。\n4. 遍历完所有箱后，活动集合包含最终的合并块集合。\n5. 构建解向量 $f = (f_1, \\dots, f_n)$。对于最终活动集合中的每个块，构成该块的所有原始箱都被赋予相同的校准概率，即该块的值。\n\n#### 步骤 4：校准后 Brier 分数\n从 PAV 算法获得校准概率 $f_i$ 后，使用与之前相同的公式计算校准后的 Brier 分数 $\\text{Brier}_{\\text{post}}$，但将未校准的得分 $x_i$ 替换为校准后的概率 $f_i$：\n$$\n\\text{Brier}_{\\text{post}} = \\frac{1}{\\sum_{j=1}^{n} n_j} \\sum_{i=1}^{n} \\left[ s_i \\left(f_i - 1\\right)^2 + b_i \\left(f_i - 0\\right)^2 \\right]\n$$\n根据构造，保序回归解 $f$ 最小化了相对于经验概率 $y_i$ 的加权均方误差。由于 Brier 分数是一个相关的性能度量，我们预期 $\\text{Brier}_{\\text{post}} \\le \\text{Brier}_{\\text{pre}}$，如果原始得分 $x_i$ 未被良好校准或非单调，则为严格不等式。\n将上述过程应用于 4 个测试用例中的每一个，以生成所需的校准前和校准后 Brier 分数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the calibration and Brier score calculation for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"x\": np.array([0.05, 0.15, 0.30, 0.45, 0.60]),\n            \"s\": np.array([5, 12, 10, 8, 25]),\n            \"b\": np.array([95, 88, 90, 92, 75]),\n        },\n        {\n            \"x\": np.array([0.02, 0.10, 0.25, 0.40, 0.55, 0.70]),\n            \"s\": np.array([2, 8, 20, 35, 55, 70]),\n            \"b\": np.array([98, 92, 80, 65, 45, 30]),\n        },\n        {\n            \"x\": np.array([0.05, 0.20, 0.50, 0.80, 0.95]),\n            \"s\": np.array([0, 4, 25, 80, 95]),\n            \"b\": np.array([100, 96, 75, 20, 5]),\n        },\n        {\n            \"x\": np.array([0.10, 0.10, 0.30, 0.30, 0.30, 0.60]),\n            \"s\": np.array([12, 8, 25, 18, 20, 40]),\n            \"b\": np.array([88, 92, 75, 82, 80, 60]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        pre_brier, post_brier = run_calibration(case['x'], case['s'], case['b'])\n        results.append(f\"{pre_brier:.6f}\")\n        results.append(f\"{post_brier:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef pav_algorithm(s, n):\n    \"\"\"\n    Implements the Pool Adjacent Violators (PAV) algorithm.\n\n    The problem is to find a non-decreasing sequence f that minimizes\n    sum(n_i * (f_i - y_i)^2), where y_i = s_i / n_i.\n    This is equivalent to minimizing sum(n_i * (f_i - s_i/n_i)^2).\n    The PAV algorithm provides the exact solution.\n\n    Args:\n        s (np.ndarray): Array of signal counts per bin.\n        n (np.ndarray): Array of total events per bin.\n\n    Returns:\n        np.ndarray: The calibrated, isotonic probabilities f_i.\n    \"\"\"\n    num_bins = len(s)\n    if num_bins == 0:\n        return np.array([])\n    \n    # Active set of blocks. Each block is [sum_s, sum_n, start_index].\n    active_set = []\n    \n    for i in range(num_bins):\n        # Add new block for the current bin\n        active_set.append([s[i], n[i], i])\n        \n        # Merge blocks backwards if monotonicity is violated\n        while len(active_set) > 1:\n            last_block = active_set[-1]\n            prev_block = active_set[-2]\n            \n            # Value of a block is its signal fraction\n            val_last = last_block[0] / last_block[1] if last_block[1] > 0 else 0\n            val_prev = prev_block[0] / prev_block[1] if prev_block[1] > 0 else 0\n\n            if val_last < val_prev:\n                # Merge the last two blocks\n                merged_s = prev_block[0] + last_block[0]\n                merged_n = prev_block[1] + last_block[1]\n                merged_start_idx = prev_block[2]\n                \n                # Replace the last two blocks with the merged one\n                active_set.pop()\n                active_set.pop()\n                active_set.append([merged_s, merged_n, merged_start_idx])\n            else:\n                # No violation, stop merging for this step\n                break\n\n    # Reconstruct the solution vector f from the final blocks\n    f = np.zeros(num_bins)\n    for block in active_set:\n        sum_s, sum_n, start_idx = block\n        value = sum_s / sum_n if sum_n > 0 else 0\n        end_idx = num_bins\n        # Find the end index for this block\n        block_idx_in_set = active_set.index(block)\n        if block_idx_in_set + 1 < len(active_set):\n            end_idx = active_set[block_idx_in_set + 1][2]\n        \n        for i in range(start_idx, end_idx):\n            f[i] = value\n            \n    return f\n\ndef calculate_brier_score(p, s, b):\n    \"\"\"\n    Calculates the Brier score for binned data.\n\n    Args:\n        p (np.ndarray): Array of predicted probabilities for each bin.\n        s (np.ndarray): Array of signal counts per bin.\n        b (np.ndarray): Array of background counts per bin.\n        \n    Returns:\n        float: The calculated Brier score.\n    \"\"\"\n    n = s + b\n    total_events = np.sum(n)\n    if total_events == 0:\n        return 0.0\n\n    # Loss is sum of s_i*(p_i-1)^2 + b_i*(p_i-0)^2 for each bin i\n    total_loss = np.sum(s * (p - 1)**2 + b * p**2)\n    \n    return total_loss / total_events\n\ndef run_calibration(x, s, b):\n    \"\"\"\n    Performs calibration and calculates pre/post Brier scores.\n    \n    Args:\n        x (np.ndarray): Classifier scores.\n        s (np.ndarray): Signal counts.\n        b (np.ndarray): Background counts.\n\n    Returns:\n        tuple[float, float]: (pre-calibration Brier, post-calibration Brier).\n    \"\"\"\n    # 1. Calculate pre-calibration Brier score\n    pre_brier = calculate_brier_score(x, s, b)\n    \n    # 2. Perform isotonic regression using PAV\n    n = s + b\n    # The problem implies y_i = s_i / n_i, but pav_algorithm works directly with s and n\n    # to avoid floating point issues and correctly calculate weighted averages.\n    f = pav_algorithm(s, n)\n    \n    # 3. Calculate post-calibration Brier score\n    post_brier = calculate_brier_score(f, s, b)\n    \n    return pre_brier, post_brier\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}