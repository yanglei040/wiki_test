{
    "hands_on_practices": [
        {
            "introduction": "在任何物理过程中，四动量守恒都是一条不可违背的基本定律。部分子簇射将高能碰撞中的单个部分子演化为一簇部分子，这可以被看作一个分裂过程的链条，而链条中的每一个环节都必须精确地满足守恒律。本练习  将指导你通过编码实现两种不同的反冲方案——角序时间型分支和偶极子反冲映射——来亲手验证能量-动量守恒是如何在算法层面得到保证的，从而为理解更复杂的簇射算法打下坚实的运动学基础。",
            "id": "3527678",
            "problem": "考虑在量子色动力学 (QCD) 部分子簇射的简化模型中，能量动量守恒的构建与验证。使用狭义相对论中的基本原理：孤立系统总四维动量守恒，因此所有末态粒子的四维动量之和等于初始四维动量。设四维动量在度规符号差为 $(+,-,-,-)$ 的四维闵可夫斯基 (Minkowski) 空间中表示为 $p^{\\mu} = (E, p_x, p_y, p_z)$，并设所有部分子均被视为具有指定不变质量的点状粒子。任务是实现两种不同的簇射运动学和一个验证程序：\n\n1. 角序类时分支，建模为连续的二体衰变，其中一个质量为 $M$ 的有质量母部分子衰变为两个不变质量分别为 $m_1$ 和 $m_2$ 的子代粒子。在母粒子静止系中，精确的二体相对论性衰变运动学要求子代粒子的三维动量大小等于\n$$\np^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}, \\quad \\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc,\n$$\n子代粒子的能量为\n$$\nE_1 = \\frac{M^2 + m_1^2 - m_2^2}{2M}, \\quad E_2 = \\frac{M^2 + m_2^2 - m_1^2}{2M}.\n$$\n后续的衰变发生在正在衰变的子代粒子的静止系中，然后使用洛伦兹 (Lorentz) 变换将衰变产物变换回实验室参考系。发射方向由极角和方位角 $(\\theta,\\phi)$ 指定；通过要求连续发射满足 $\\theta_{\\text{next}} \\le \\theta_{\\text{previous}}$ 来强制实现角序。这种局域反冲方案确保了每次分支的精确守恒，因为两个子代粒子在内部共同承担反冲，使得在进行洛伦兹变换前回母粒子静止系中它们的四维矢量之和等于母粒子的四维矢量，并且洛伦兹变换保持四维动量之和不变。\n\n2. 偶极子反冲映射，用于一个末态偶极子。该偶极子最初由质心 (CM) 系中的两个无质量部分子组成，总四维动量为 $P^{\\mu} = (Q, 0, 0, 0)$，其中 $Q$ 是质心能量。产生一个无质量发射，其三维动量大小为 $|\\vec{k}|$，方向为 $\\hat{k}$ ($\\theta_k,\\phi_k$)，能量为 $E_k = |\\vec{k}|$，并满足 $0  |\\vec{k}|  Q/2$。余下的两个反冲部分子被视为无质量，并对称地承担反冲，使其三维动量之和为 $-\\vec{k}$，能量之和为 $Q - E_k$。定义\n$$\nE = \\frac{Q - |\\vec{k}|}{2}, \\quad \\cos\\alpha = \\frac{|\\vec{k}|}{Q - |\\vec{k}|}, \\quad \\alpha = \\arccos\\left(\\frac{|\\vec{k}|}{Q - |\\vec{k}|}\\right).\n$$\n选择一个与 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$。然后构造两个单位矢量\n$$\n\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}, \\quad \\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u},\n$$\n并将反冲四维矢量设置为\n$$\np_1^{\\mu} = (E, E\\,\\hat{n}_1), \\quad p_2^{\\mu} = (E, E\\,\\hat{n}_2), \\quad k^{\\mu} = (|\\vec{k}|, |\\vec{k}|\\,\\hat{k}),\n$$\n根据构造，这确保了 $p_1^{\\mu} + p_2^{\\mu} + k^{\\mu} = (Q, 0, 0, 0)$ 精确成立。\n\n实现一个程序，该程序：\n- 使用提供的参数为两种运动学构建末态四维矢量。\n- 将末态四维矢量求和，并将结果与初始四维动量进行比较，以验证能量动量守恒。\n- 对四维动量比较的每个分量使用 $10^{-9}\\,\\mathrm{GeV}$ 的数值容差。\n\n所有能量必须以 $\\mathrm{GeV}$ 为单位，所有角度必须以弧度为单位。程序必须输出布尔值，以指示每个测试用例的守恒定律是否在容差范围内成立。\n\n测试套件。对于角序分支，使用三组参数集，每组指定 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$：\n- 案例 A1: $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (100, 20, 0, 0.6, 1.0, 0.3, 0.4)$。\n- 案例 A2 (第一次软发射): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (50, 49, 0, 0.2, 2.2, 0.1, 1.7)$。\n- 案例 A3 (第一次近共线发射): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$。\n\n对于偶极子反冲映射，使用三组参数集，每组指定 $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$：\n- 案例 D1: $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 20, 1.0, 2.4)$。\n- 案例 D2 (软发射): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 1.0, 0.8, 0.5)$。\n- 案例 D3 (近最大能量发射): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 49.999, 2.0, 0.1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），其中每个 $result_i$ 为 $\\texttt{True}$ 或 $\\texttt{False}$。",
            "solution": "用户的请求是验证并解决一个关于两种简化部分子簇射运动学模型中能量动量守恒的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **原理**：孤立系统中四维动量守恒。\n*   **四维动量**：$p^{\\mu} = (E, p_x, p_y, p_z)$，度规符号差为 $(+,-,-,-)$。\n*   **容差**：数值比较容差为 $10^{-9}\\,\\mathrm{GeV}$。\n*   **单位**：能量/质量单位为 $\\mathrm{GeV}$，角度单位为弧度。\n\n*   **模型 1 (角序类时分支)**：\n    *   一系列 $1 \\to 2$ 衰变。\n    *   初始粒子：质量为 $M$，静止。初始四维动量 $p_{init}^{\\mu} = (M,0,0,0)$。\n    *   一般衰变 $A \\to B+C$：在 $A$（质量为 $M_A$）的静止系中，子代粒子（质量为 $m_B, m_C$）的动量大小为 $p^* = \\frac{\\sqrt{\\lambda(M_A^2, m_B^2, m_C^2)}}{2M_A}$，能量为 $E_B = \\frac{M_A^2 + m_B^2 - m_C^2}{2M_A}$，$E_C = \\frac{M_A^2 + m_C^2 - m_B^2}{2M_A}$，其中 $\\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc$ 是凯伦 (Källén) 函数。\n    *   后续衰变的产物从母粒子的静止系变换回实验室系。\n    *   测试用例提供参数 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$。\n        *   A1: $(100, 20, 0, 0.6, 1.0, 0.3, 0.4)$\n        *   A2: $(50, 49, 0, 0.2, 2.2, 0.1, 1.7)$\n        *   A3: $(80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$\n\n*   **模型 2 (偶极子反冲映射)**：\n    *   初始状态：质心系，总四维动量为 $P^{\\mu} = (Q, 0, 0, 0)$。\n    *   末态：一个无质量发射 $k$，两个无质量反冲部分子 $p_1, p_2$。\n    *   发射的动量大小为 $|\\vec{k}|$，能量为 $E_k = |\\vec{k}|$，方向为 $\\hat{k}(\\theta_k, \\phi_k)$，且满足 $0  |\\vec{k}|  Q/2$。\n    *   反冲参数：$E = \\frac{Q-|\\vec{k}|}{2}$ 和 $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$。\n    *   反冲方向：对于与 $\\hat{k}$ 正交的 $\\hat{u}$，$\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ 和 $\\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$。\n    *   末态四维矢量：$k^{\\mu}=(|\\vec{k}|, |\\vec{k}|\\hat{k})$，$p_1^{\\mu}=(E, E\\hat{n}_1)$，$p_2^{\\mu}=(E, E\\hat{n}_2)$。\n    *   测试用例提供参数 $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$。\n        *   D1: $(100, 20, 1.0, 2.4)$\n        *   D2: $(100, 1.0, 0.8, 0.5)$\n        *   D3: $(100, 49.999, 2.0, 0.1)$\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在科学上基于狭义相对论和标准的高能物理运动学。它是客观且可形式化的。\n\n存在两点模糊之处：\n1.  **模型 1**：问题描述了“连续二体衰变”，并提供了一个参数元组 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$。第一次衰变产生的中间粒子的质量没有明确说明。这构成了一个**设置不完整（未指定）**的缺陷。然而，一个合理且标准的解释可以解决这个问题：\n    *   第一次衰变是 $P_0(M) \\to P_1(m_1) + P_2(m_2)$，其中 $M, m_1, m_2$ 在测试用例中给出。\n    *   第二次衰变是 $P_1(m_1) \\to P_{11} + P_{12}$。最终产物 $P_{11}$ 和 $P_{12}$ 的质量必须被假设。在这种简化模型中，一个标准的假设是它们是无质量的。\n    这种解释以物理上一致的顺序使用了所有提供的参数，并使问题变得可解。\n2.  **模型 2**：构造过程需要选择一个与 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$。$\\hat{u}$ 的选择没有被指定，这是一个**不适定/模糊**的缺陷。然而，分析检验表明，末态四维动量之和 $p_1^\\mu + p_2^\\mu + k^\\mu$ 与 $\\hat{u}$ 的选择无关。因此，任何对 $\\hat{u}$ 的有效选择都将得出关于四维动量守恒的相同结论。这种模糊性不影响所提出问题的最终答案。\n\n鉴于这些模糊之处可以通过合理和标准的解释（模型 1）来解决，或者不影响最终结果（模型 2），该问题被认为是有效的。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。着手求解。\n\n### 解法\n\n解法要求实现所描述的两种运动学方案，并对提供的测试用例进行四维动量守恒的数值验证。\n\n**模型 1：角序分支**\n\n该过程被解释为一个两步衰变链。\n1.  **初始状态**：一个质量为 $M$ 的粒子 $P_0$ 在实验室参考系中静止。其四维动量为 $p_{P_0}^\\mu = (M, 0, 0, 0)$。\n2.  **第一次衰变**：$P_0$ 衰变为 $P_1$（质量为 $m_1$）和 $P_2$（质量为 $m_2$）。由于 $P_0$ 是静止的，这次衰变发生在实验室系中。\n    *   子代粒子的动量大小 $p^*$ 使用凯伦 (Källén) 函数计算：$p^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}$。\n    *   能量为 $E_1 = \\frac{M^2+m_1^2-m_2^2}{2M}$ 和 $E_2 = \\frac{M^2+m_2^2-m_1^2}{2M}$。\n    *   $P_1$ 的方向由 $(\\theta_1, \\phi_1)$ 给出。我们构造一个单位矢量 $\\hat{n}_1$ 并找到三维动量 $\\vec{p}_1 = p^*\\hat{n}_1$ 和 $\\vec{p}_2 = -p^*\\hat{n}_1$。\n    *   在实验室系中的四维动量是 $p_1^\\mu = (E_1, \\vec{p}_1)$ 和 $p_2^\\mu = (E_2, \\vec{p}_2)$。粒子 $P_2$ 是一个末态粒子。\n3.  **第二次衰变**：粒子 $P_1$ 衰变为两个无质量的子代粒子 $P_{11}$ 和 $P_{12}$。这次衰变发生在 $P_1$ 的静止系中。\n    *   在 $P_1$ 静止系中，母粒子质量为 $m_1$，子代粒子质量为 $0$。\n    *   子代粒子的动量大小为 $p' = \\frac{\\sqrt{\\lambda(m_1^2,0,0)}}{2m_1} = \\frac{m_1}{2}$。它们的能量为 $E'_{11}=E'_{12}=\\frac{m_1}{2}$。\n    *   衰变方向由 $(\\theta_2, \\phi_2)$ 给出，定义了一个单位矢量 $\\hat{n}_2$。三维动量为 $\\vec{p}'_{11} = p'\\hat{n}_2$ 和 $\\vec{p}'_{12} = -p'\\hat{n}_2$。\n    *   静止系中的四维动量为 $p_{11}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{11})$ 和 $p_{12}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{12})$。\n4.  **洛伦兹变换**：四维动量 $p_{11}^{\\prime\\mu}$ 和 $p_{12}^{\\prime\\mu}$ 从 $P_1$ 静止系变换回实验室系。变换的速度矢量为 $\\vec{\\beta} = \\vec{p}_1/E_1$。应用标准的洛伦兹变换得到实验室系中的四维动量 $p_{11}^\\mu$ 和 $p_{12}^\\mu$。\n5.  **验证**：将末态四维动量之和 $p_{final}^\\mu = p_2^\\mu + p_{11}^\\mu + p_{12}^\\mu$ 与初始四维动量 $p_{P_0}^\\mu$进行比较。每个分量必须在 $10^{-9}\\,\\mathrm{GeV}$ 的容差范围内匹配。\n\n**模型 2：偶极子反冲映射**\n\n1.  **初始状态**：系统的总四维动量为 $P_{init}^\\mu = (Q, 0, 0, 0)$。\n2.  **发射构造**：发射的无质量粒子 $k$ 的能量为 $E_k=|\\vec{k}|$，其三维动量 $\\vec{k}$ 由 $|\\vec{k}|$, $\\theta_k$, 和 $\\phi_k$ 构造。其四维动量为 $k^\\mu=(|\\vec{k}|, \\vec{k})$。\n3.  **反冲构造**：两个无质量反冲部分子 ($p_1, p_2$) 具有相等的能量 $E = (Q-|\\vec{k}|)/2$。\n    *   我们计算 $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$ 和 $\\sin\\alpha = \\sqrt{1-\\cos^2\\alpha}$。\n    *   一个与发射方向 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$ 以编程方式构造。\n    *   反冲方向单位矢量为 $\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ 和 $\\hat{n}_2 =-\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$。\n    *   反冲四维动量为 $p_1^\\mu = (E, E\\hat{n}_1)$ 和 $p_2^\\mu = (E, E\\hat{n}_2)$。\n4.  **验证**：将末态四维动量之和 $p_{final}^\\mu = k^\\mu + p_1^\\mu + p_2^\\mu$与初始四维动量 $P_{init}^\\mu$进行比较。\n\n实现将表明，对于所有测试用例，守恒定律都成立，因为运动学构造是精确的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spherical_to_cartesian(r, theta, phi):\n    \"\"\"Converts spherical coordinates to a Cartesian 3-vector.\"\"\"\n    x = r * np.sin(theta) * np.cos(phi)\n    y = r * np.sin(theta) * np.sin(phi)\n    z = r * np.cos(theta)\n    return np.array([x, y, z])\n\ndef kallen_lambda(a, b, c):\n    \"\"\"Calculates the Källén function lambda(a, b, c).\"\"\"\n    return a**2 + b**2 + c**2 - 2*a*b - 2*a*c - 2*b*c\n\ndef lorentz_boost(p_prime, beta_vec):\n    \"\"\"\n    Boosts a 4-vector p_prime from a frame moving with velocity beta_vec.\n    p_prime: 4-vector (E', p'_x, p'_y, p'_z) in the moving frame.\n    beta_vec: 3-vector velocity of the moving frame relative to the lab frame.\n    Returns: Boosted 4-vector (E, p_x, p_y, p_z) in the lab frame.\n    \"\"\"\n    beta_sq = np.dot(beta_vec, beta_vec)\n    if beta_sq >= 1.0:\n        raise ValueError(\"Velocity must be less than the speed of light (c=1).\")\n    if beta_sq < 1e-16:\n        return p_prime\n\n    beta = np.sqrt(beta_sq)\n    gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n    beta_hat = beta_vec / beta\n\n    E_prime = p_prime[0]\n    p_prime_vec = p_prime[1:]\n\n    p_prime_parallel_mag = np.dot(p_prime_vec, beta_hat)\n    p_prime_parallel = p_prime_parallel_mag * beta_hat\n    p_prime_perp = p_prime_vec - p_prime_parallel\n\n    p_parallel_mag_boosted = gamma * (p_prime_parallel_mag + beta * E_prime)\n    p_parallel_boosted = p_parallel_mag_boosted * beta_hat\n    E_boosted = gamma * (E_prime + beta * p_prime_parallel_mag)\n\n    p_vec_boosted = p_parallel_boosted + p_prime_perp\n\n    return np.array([E_boosted, p_vec_boosted[0], p_vec_boosted[1], p_vec_boosted[2]])\n\ndef get_orthogonal_unit_vector(v):\n    \"\"\"Computes a unit vector that is orthogonal to the input 3-vector v.\"\"\"\n    v_norm = np.linalg.norm(v)\n    if v_norm < 1e-12:\n        return np.array([1.0, 0.0, 0.0])\n    v_unit = v / v_norm\n\n    if np.abs(v_unit[2]) < 0.9: \n        fixed_vec = np.array([0.0, 0.0, 1.0])\n    else:\n        fixed_vec = np.array([1.0, 0.0, 0.0])\n    \n    ortho_vec = np.cross(v_unit, fixed_vec)\n    return ortho_vec / np.linalg.norm(ortho_vec)\n\ndef solve_angular_ordered(M, m1, m2, theta1, phi1, theta2, phi2, tol):\n    \"\"\"Solution for the angular-ordered branching case.\"\"\"\n    p_initial = np.array([M, 0.0, 0.0, 0.0])\n    \n    if M <= m1 + m2: return False\n    lambda_val = kallen_lambda(M**2, m1**2, m2**2)\n    if lambda_val < 0: return False\n    p_star = np.sqrt(lambda_val) / (2 * M)\n\n    E1 = (M**2 + m1**2 - m2**2) / (2 * M)\n    E2 = (M**2 + m2**2 - m1**2) / (2 * M)\n\n    n1_vec = spherical_to_cartesian(1.0, theta1, phi1)\n    p1 = np.concatenate(([E1], p_star * n1_vec))\n    p2 = np.concatenate(([E2], -p_star * n1_vec))\n\n    final_momenta = [p2]\n\n    if m1 < 1e-12:\n        final_momenta.append(p1)\n    else:\n        p_prime = m1 / 2.0\n        E_prime_daughter = m1 / 2.0\n\n        n2_vec = spherical_to_cartesian(1.0, theta2, phi2)\n        p11_prime = np.concatenate(([E_prime_daughter], p_prime * n2_vec))\n        p12_prime = np.concatenate(([E_prime_daughter], -p_prime * n2_vec))\n    \n        beta_vec_p1 = p1[1:] / p1[0]\n        p11 = lorentz_boost(p11_prime, beta_vec_p1)\n        p12 = lorentz_boost(p12_prime, beta_vec_p1)\n\n        final_momenta.append(p11)\n        final_momenta.append(p12)\n\n    p_final = np.sum(final_momenta, axis=0)\n    return np.all(np.abs(p_final - p_initial) < tol)\n\ndef solve_dipole_recoil(Q, k_mag, theta_k, phi_k, tol):\n    \"\"\"Solution for the dipole recoil mapping case.\"\"\"\n    p_initial = np.array([Q, 0.0, 0.0, 0.0])\n\n    k_vec = spherical_to_cartesian(k_mag, theta_k, phi_k)\n    k_hat = k_vec / k_mag if k_mag > 0 else np.array([0., 0., 0.])\n    p_k = np.concatenate(([k_mag], k_vec))\n\n    if Q - k_mag <= 0 or k_mag >= Q - k_mag: return False\n    \n    E = (Q - k_mag) / 2.0\n    cos_alpha = k_mag / (Q - k_mag)\n    sin_alpha = np.sqrt(1.0 - cos_alpha**2)\n\n    u_hat = get_orthogonal_unit_vector(k_hat)\n    \n    n1_hat = -cos_alpha * k_hat + sin_alpha * u_hat\n    n2_hat = -cos_alpha * k_hat - sin_alpha * u_hat\n    \n    p1 = np.concatenate(([E], E * n1_hat))\n    p2 = np.concatenate(([E], E * n2_hat))\n\n    p_final = p_k + p1 + p2\n    return np.all(np.abs(p_final - p_initial) < tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    angular_cases = [\n        (100, 20, 0, 0.6, 1.0, 0.3, 0.4),\n        (50, 49, 0, 0.2, 2.2, 0.1, 1.7),\n        (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1),\n    ]\n    dipole_cases = [\n        (100, 20, 1.0, 2.4),\n        (100, 1.0, 0.8, 0.5),\n        (100, 49.999, 2.0, 0.1),\n    ]\n\n    tolerance = 1e-9\n    results = []\n\n    for case in angular_cases:\n        result = solve_angular_ordered(*case, tol=tolerance)\n        results.append(result)\n\n    for case in dipole_cases:\n        result = solve_dipole_recoil(*case, tol=tolerance)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经知道必须在每次分裂中保持能量-动量守恒，但一个更实际的问题是：我们如何从分裂的物理参数（如能量分配分数 $z$ 和横向动量 $p_T$）出发，具体地构建出末态部分子的四动量？这就引出了“运动学映射”的概念，它是一套将抽象参数转化为具体四动量的数学公式，同时必须保证所有末态粒子都满足在壳条件。本练习  要求你推导并实现一个现代的偶极子运动学映射，并通过数值测试来检验其在相空间边界处的物理有效性和数值稳定性，这是开发稳健簇射算法的一项核心技能。",
            "id": "3527734",
            "problem": "一个末态类时部分子簇射可以使用偶极图像进行建模，其中两个出射的无质量部分子（其四动量表示为 $p_i$ 和 $p_j$）形成一个色连通偶极，其不变质量平方为 $s = (p_i + p_j)^2$。一次共线辐射表现为辐射体 $i$ 分裂成两个无质量的子代粒子（四动量为 $p_a$ 和 $p_b$），而旁观者 $j$ 则反冲到一个新的四动量 $p_j'$，从而保证总四动量守恒，并且所有出射部分子都保持在其各自的质量壳上。该分裂由一个能量分配变量 $z \\in (0,1)$ 和一个相对于偶极轴定义的横动量标度 $p_T^2 \\ge 0$ 来参数化。此映射必须是精确的，即它在闵可夫斯基空间中代数上一致，并避免所有出射部分子出现任何类空虚度，同时还需确保能量为非负值。\n\n从适用于计算高能物理的第一性原理出发，即：\n- 对于一个四动量为 $p$、质量为 $m$ 的粒子，其在壳条件为 $p^2 = m^2$，其中 $p^2 = p^\\mu p_\\mu$ 使用号差为 $(+,-,-,-)$ 的闵可夫斯基度规计算。\n- 对于无质量部分子，该条件为 $p^2 = 0$。\n- 四动量守恒要求 $p_i + p_j = p_a + p_b + p_j'$。\n- 物理动量必须具有非负的能量分量，即 $p^0 \\ge 0$。\n\n你的任务是：\n1. 仅从这些原理出发，推导运动学映射参数需满足的条件，以确保对于任意 $z \\in (0,1)$ 和 $p_T^2 \\ge 0$， $p_a^2 = p_b^2 = p_j'^2 = 0$、$p_a^0 \\ge 0$、$p_b^0 \\ge 0$、$p_j'^0 \\ge 0$ 以及 $p_i + p_j = p_a + p_b + p_j'$ 这些条件同时成立。请用 $z$、$p_T^2$ 和 $s$ 显式地表达这些条件。\n2. 实现一个程序，在偶极质心系中构建一个与所推导条件一致的偶极运动学映射。在此参考系中，使用 $p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$ 和 $p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$，两者均为无质量且背对背。使用一个横向四矢量 $k_T = (0, \\sqrt{p_T^2}, 0, 0)$，它与 $p_i$ 和 $p_j$ 都正交，并满足 $k_T^2 = -p_T^2$。用 $p_i$、$p_j$、$z$、$p_T^2$ 和 $k_T$ 来构造 $p_a$、$p_b$ 和 $p_j'$，以满足精确的动量守恒和在壳条件。\n3. 通过对每个测试案例检查以下内容，来测试偶极映射在极端能量分配极限（$z \\to 0$ 和 $z \\to 1$）以及典型和边界配置下的数值稳定性和物理有效性：\n   - 在壳性：$|p_a^2|$、$|p_b^2|$ 和 $|p_j'^2|$ 每个都小于一个与 $s$ 成正比的容差，具体为 $\\epsilon_{\\text{mass}} = 10^{-12} \\, s$。\n   - 能量非负性：$p_a^0 \\ge -\\epsilon_E$、$p_b^0 \\ge -\\epsilon_E$、$p_j'^0 \\ge -\\epsilon_E$，其中 $\\epsilon_E = 10^{-12} \\, \\sqrt{s}$。\n   - 在数值容差内的精确四动量守恒：$\\|p_i + p_j - (p_a + p_b + p_j')\\|_2 \\le \\epsilon_{\\text{mom}}$，其中 $\\epsilon_{\\text{mom}} = 10^{-12} \\, \\sqrt{s}$。\n\n量 $s$ 和 $p_T^2$ 必须以 $\\mathrm{GeV}^2$ 为单位表示，能量以 $\\mathrm{GeV}$ 为单位，程序必须通过横向构造隐式处理所有角度，而不引入任何角度变量。输出应为无单位的布尔值。\n\n使用以下测试套件，其设计旨在探测典型、边界和极端条件：\n- 案例1 (典型内部): $s = 10^{4}$, $z = 0.5$, $p_T^2 = 0.5 \\, s \\, z (1 - z)$。\n- 案例2 (接近边界下方): $s = 10^{4}$, $z = 0.5$, $p_T^2 = s \\, z (1 - z) - 10^{-5}$。\n- 案例3 (精确边界): $s = 10^{4}$, $z = 0.5$, $p_T^2 = s \\, z (1 - z)$。\n- 案例4 (超出边界无效): $s = 10^{4}$, $z = 0.5$, $p_T^2 = 1.01 \\, s \\, z (1 - z)$。\n- 案例5 (极端 $z \\to 0$): $s = 10^{4}$, $z = 10^{-12}$, $p_T^2 = 0.9 \\, s \\, z (1 - z)$。\n- 案例6 (极端 $z \\to 1$): $s = 10^{4}$, $z = 1 - 10^{-12}$, $p_T^2 = 0.9 \\, s \\, z (1 - z)$。\n- 案例7 (大标度): $s = 10^{8}$, $z = 0.5$, $p_T^2 = 0.1 \\, s \\, z (1 - z)$。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个条目都是一个布尔值，指示该运动学映射是否通过了该测试案例的所有检查。",
            "solution": "此问题旨在为偶极部分子簇射分裂推导运动学约束，并实现和测试一个相应的运动学映射。该过程涉及一对色连通的无质量部分子，即辐射体 $i$ 和旁观者 $j$。辐射体发生分裂 $i \\to a+b$，同时旁观者 $j$ 发生反冲 $j \\to j'$。这一过程必须遵循基本的物理原理：四动量守恒、所有末态无质量粒子的在壳条件，以及能量非负的要求。\n\n我们首先从第一性原理出发，正式推导运动学参数（即能量分配分数 $z$ 和横动量平方 $p_T^2$）所受的约束。\n\n### 第一部分：运动学条件的推导\n\n给定初态有两个无质量部分子 $p_i$ 和 $p_j$，满足 $p_i^2=0$ 和 $p_j^2=0$。它们的总不变质量平方为 $s=(p_i+p_j)^2 = p_i^2 + p_j^2 + 2p_i \\cdot p_j = 2p_i \\cdot p_j$。末态包含三个无质量部分子 $p_a$、$p_b$ 和 $p_j'$，它们必须满足 $p_a^2=0$、$p_b^2=0$ 和 $p_j'^2=0$。该过程遵守四动量守恒：$p_i+p_j = p_a+p_b+p_j'$。\n\n为了构建末态动量，我们需要一个用初态动量 $p_i, p_j$ 以及运动学变量 $z$ 和 $p_T^2$ 表示的参数化形式。对于分裂 $i \\to a+b$，一个通用且有物理动机的拟设是将子代粒子的动量表示为母粒子动量 $p_i$、一个横向分量 $k_T$ 以及一个与另一偶极腿 $p_j$ 成比例的修正项的组合，以维持在壳条件。我们定义一个横向四矢量 $k_T$，它满足 $k_T \\cdot p_i = 0$、$k_T \\cdot p_j = 0$ 和 $k_T^2=-p_T^2$。所提出的参数化形式是：\n$$p_a = z p_i + \\alpha p_j + k_T$$\n$$p_b = (1-z) p_i + \\beta p_j - k_T$$\n这里，$z$ 代表在共线极限下（$p_T^2 \\to 0$）部分子 $a$ 的能量分数。系数 $\\alpha$ 和 $\\beta$ 是待定未知数，将通过在壳条件来确定。\n\n接下来，我们施加在壳条件 $p_a^2=0$：\n$$p_a^2 = (z p_i + \\alpha p_j + k_T)^2 = z^2 p_i^2 + \\alpha^2 p_j^2 + k_T^2 + 2z\\alpha (p_i \\cdot p_j) + 2z (p_i \\cdot k_T) + 2\\alpha (p_j \\cdot k_T) = 0$$\n利用已知属性 $p_i^2=0$、$p_j^2=0$、$k_T^2=-p_T^2$、$p_i \\cdot k_T=0$、$p_j \\cdot k_T=0$ 以及 $p_i \\cdot p_j = s/2$，方程显著简化为：\n$$0 + 0 - p_T^2 + 2z\\alpha (s/2) + 0 + 0 = 0$$\n$$- p_T^2 + z\\alpha s = 0$$\n解出 $\\alpha$ 得：\n$$\\alpha = \\frac{p_T^2}{zs}$$\n\n类似地，我们施加在壳条件 $p_b^2=0$：\n$$p_b^2 = ((1-z)p_i + \\beta p_j - k_T)^2 = (1-z)^2 p_i^2 + \\beta^2 p_j^2 + k_T^2 + 2(1-z)\\beta (p_i \\cdot p_j) - 2(1-z) (p_i \\cdot k_T) - 2\\beta (p_j \\cdot k_T) = 0$$\n这简化为：\n$$-p_T^2 + (1-z)\\beta s = 0$$\n解出 $\\beta$ 得：\n$$\\beta = \\frac{p_T^2}{(1-z)s}$$\n\n在确定了 $\\alpha$ 和 $\\beta$ 后，动量 $p_a$ 和 $p_b$ 就被完全指定了：\n$$p_a = z p_i + \\frac{p_T^2}{zs} p_j + k_T$$\n$$p_b = (1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T$$\n\n现在，我们使用四动量守恒来确定反冲后旁观者的动量 $p_j'$：\n$$p_j' = p_i + p_j - (p_a + p_b)$$\n代入 $p_a$ 和 $p_b$ 的表达式：\n$$p_j' = p_i + p_j - \\left( \\left(z p_i + \\frac{p_T^2}{zs} p_j + k_T\\right) + \\left((1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T\\right) \\right)$$\n$$p_j' = p_i + p_j - \\left( (z+1-z)p_i + \\left(\\frac{p_T^2}{zs} + \\frac{p_T^2}{(1-z)s}\\right)p_j \\right)$$\n$$p_j' = p_i + p_j - p_i - \\frac{p_T^2}{s}\\left(\\frac{1}{z} + \\frac{1}{1-z}\\right)p_j$$\n$$p_j' = p_j - \\frac{p_T^2}{s}\\left(\\frac{1-z+z}{z(1-z)}\\right)p_j$$\n$$p_j' = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j$$\n反冲后旁观者动量的这个异常简洁的形式确保了其在壳条件 $p_j'^2=0$ 自动满足，因为 $p_j'^2 = (\\text{标量因子})^2 p_j^2$ 且 $p_j^2=0$。\n\n最后，我们必须强制所有末态粒子具有非负能量 ($p^0 \\ge 0$)。我们在指定的偶极质心系中计算能量分量：\n$$p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$$\n$$p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$$\n$$k_T = (0, \\sqrt{p_T^2}, 0, 0)$$\n能量分量为：\n$$p_a^0 = z p_i^0 + \\frac{p_T^2}{zs} p_j^0 + k_T^0 = z \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{zs} \\frac{\\sqrt{s}}{2} + 0 = \\frac{\\sqrt{s}}{2} \\left( z + \\frac{p_T^2}{zs} \\right)$$\n$$p_b^0 = (1-z) p_i^0 + \\frac{p_T^2}{(1-z)s} p_j^0 - k_T^0 = (1-z) \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{(1-z)s} \\frac{\\sqrt{s}}{2} - 0 = \\frac{\\sqrt{s}}{2} \\left( 1-z + \\frac{p_T^2}{(1-z)s} \\right)$$\n$$p_j'^0 = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j^0 = \\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right)$$\n鉴于 $s>0$、$z \\in (0,1)$ 和 $p_T^2 \\ge 0$， $p_a^0$ 和 $p_b^0$ 的表达式显然是非负项的非负和。唯一非平凡的约束来自于要求 $p_j'^0 \\ge 0$：\n$$\\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) \\ge 0$$\n由于 $\\sqrt{s}/2 > 0$，这意味着：\n$$1 - \\frac{p_T^2}{s z(1-z)} \\ge 0$$\n$$\\implies p_T^2 \\le s z(1-z)$$\n\n总而言之，对于一个参数为 $z \\in (0,1)$ 和 $p_T^2 \\ge 0$ 的物理有效的运动学映射，必须满足以下条件：\n$$0 \\le p_T^2 \\le s z(1-z)$$\n这定义了辐射的可及相空间。\n\n### 第二部分：实现与测试\n程序将实现所推导的运动学映射，并根据问题陈述中指定的一系列测试对其进行检验。一个函数将根据输入参数 $s, z, p_T^2$ 构建末态四动量 $p_a, p_b, p_j'$。然后，这些动量将根据三个标准进行验证：在壳性、能量非负性和四动量守恒，所有验证都在指定的数值容差范围内进行。案例4中，$p_T^2 > s z(1-z)$，预计将无法通过 $p_j'$ 的能量非负性测试，从而证实我们推导的边界的有效性。所有其他案例都构造在物理相空间的内部或边界上，预计将通过检查，从而测试实现的数值稳定性，特别是在软极限（$z \\to 0$）和共线极限（$z \\to 1$）下。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the dipole kinematic map tests.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: typical interior\n        {'s': 1e4, 'z': 0.5, 'pT2': 0.5 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 2: near-boundary below\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5) - 1e-5},\n        # Case 3: exact boundary\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5)},\n        # Case 4: above-boundary invalid\n        {'s': 1e4, 'z': 0.5, 'pT2': 1.01 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 5: extreme z -> 0\n        {'s': 1e4, 'z': 1e-12, 'pT2': 0.9 * 1e4 * 1e-12 * (1 - 1e-12)},\n        # Case 6: extreme z -> 1\n        {'s': 1e4, 'z': 1.0 - 1e-12, 'pT2': 0.9 * 1e4 * (1.0 - 1e-12) * (1 - (1.0 - 1e-12))},\n        # Case 7: large scale\n        {'s': 1e8, 'z': 0.5, 'pT2': 0.1 * 1e8 * 0.5 * (1 - 0.5)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s, z, pT2 = case['s'], case['z'], case['pT2']\n        \n        # Perform the kinematic test for the current case\n        passed = test_kinematic_map(s, z, pT2)\n        results.append(passed)\n\n    # Format and print the final output as a single-line string.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef dot_product(p1, p2):\n    \"\"\"\n    Computes the Minkowski dot product of two four-vectors.\n    Metric signature is (+, -, -, -).\n    \"\"\"\n    return p1[0] * p2[0] - p1[1] * p2[1] - p1[2] * p2[2] - p1[3] * p2[3]\n\ndef mass_sq(p):\n    \"\"\"Computes the squared invariant mass of a four-vector.\"\"\"\n    return dot_product(p, p)\n\ndef construct_kinematic_map(s, z, pT2):\n    \"\"\"\n    Constructs the final-state four-momenta for a dipole splitting.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        tuple: A tuple containing the four-momenta of the initial state (p_i, p_j)\n               and final state (p_a, p_b, p_j_prime).\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n    E_cm_half = sqrt_s / 2.0\n    \n    # Define initial state momenta in the CM frame\n    p_i = np.array([E_cm_half, 0.0, 0.0, E_cm_half])\n    p_j = np.array([E_cm_half, 0.0, 0.0, -E_cm_half])\n    \n    # Define the transverse vector. Handle pT2 < 0 case for safety, though not expected by givens.\n    pT = np.sqrt(max(0, pT2))\n    k_T = np.array([0.0, pT, 0.0, 0.0])\n\n    # Calculate coefficients for the kinematic map based on the derivation\n    alpha = pT2 / (z * s)\n    beta = pT2 / ((1.0 - z) * s)\n    \n    # Construct final state momenta\n    p_a = z * p_i + alpha * p_j + k_T\n    p_b = (1.0 - z) * p_i + beta * p_j - k_T\n    \n    # The recoil factor for p_j' can lead to precision loss if pT2 is very close\n    # to the kinematic limit. Reconstructing from conservation is more robust for tests.\n    p_j_prime_reco = p_i + p_j - (p_a + p_b)\n\n    return p_i, p_j, p_a, p_b, p_j_prime_reco\n\n\ndef test_kinematic_map(s, z, pT2):\n    \"\"\"\n    Tests the physical validity of the kinematic map for a given set of parameters.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        bool: True if all checks pass, False otherwise.\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n\n    # Define numerical tolerances\n    eps_mass = 1e-12 * s\n    eps_E = 1e-12 * sqrt_s\n    eps_mom = 1e-12 * sqrt_s\n    \n    # The derived condition for physical kinematics\n    kinematic_limit = s * z * (1 - z)\n    \n    # If pT2 is clearly unphysical, fail early. This is primarily for the energy check.\n    # The code must still be able to handle this case numerically.\n    # Note: pT2 can be slightly above the limit due to float precision issues\n    # in the test case definitions. The energy check is the ultimate arbiter.\n    \n    # Construct the momenta\n    p_i, p_j, p_a, p_b, p_j_prime = construct_kinematic_map(s, z, pT2)\n\n    # 1. On-shellness check\n    # Check that final state particles are on their mass shell (m=0)\n    check_a_mass = np.abs(mass_sq(p_a)) < eps_mass\n    check_b_mass = np.abs(mass_sq(p_b)) < eps_mass\n    check_j_mass = np.abs(mass_sq(p_j_prime)) < eps_mass\n    \n    # 2. Energy non-negativity check\n    # The tolerance eps_E allows for small negative values from floating-point errors.\n    check_a_E = p_a[0] >= -eps_E\n    check_b_E = p_b[0] >= -eps_E\n    check_j_E = p_j_prime[0] >= -eps_E\n    \n    # 3. Four-momentum conservation check\n    p_initial = p_i + p_j\n    p_final = p_a + p_b + p_j_prime\n    mom_diff_vec = p_initial - p_final\n    # The problem specifies the L2 norm of the difference 4-vector.\n    check_mom_cons = np.linalg.norm(mom_diff_vec) <= eps_mom\n\n    # The case passes only if all checks are satisfied\n    all_checks_passed = all([\n        check_a_mass, check_b_mass, check_j_mass,\n        check_a_E, check_b_E, check_j_E,\n        check_mom_cons\n    ])\n    \n    # Un-comment the following block to debug individual checks for a failing case.\n    # if not all_checks_passed:\n    #     print(f\"\\n--- FAILED CASE: s={s}, z={z}, pT2={pT2} ---\")\n    #     print(f\"pT2_limit = {kinematic_limit}\")\n    #     print(f\"Mass checks (a, b, j'): {check_a_mass}, {check_b_mass}, {check_j_mass}\")\n    #     print(f\"  Values: p_a^2={mass_sq(p_a)}, p_b^2={mass_sq(p_b)}, p_j'^2={mass_sq(p_j_prime)}\")\n    #     print(f\"Energy checks (a, b, j'): {check_a_E}, {check_b_E}, {check_j_E}\")\n    #     print(f\"  Values: E_a={p_a[0]}, E_b={p_b[0]}, E_j'={p_j_prime[0]}\")\n    #     print(f\"Momentum conservation check: {check_mom_cons}\")\n    #     print(f\"  Value: ||diff|| = {np.linalg.norm(mom_diff_vec)}\")\n    #     print(f\"Tolerances: eps_mass={eps_mass}, eps_E={eps_E}, eps_mom={eps_mom}\")\n    \n    return all_checks_passed\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在掌握了如何构建单次运动学有效的分裂后，下一个关键问题是：分裂发生的概率和时机由什么决定？这触及了部分子簇射的概率性本质，其核心由描述无辐射概率的苏达科夫形状因子（Sudakov form factor）所支配。本高级练习  将引导你实现“否决算法”（veto algorithm）——这是现代事件生成器中驱动概率性演化的主力引擎。通过亲手实现这一关键算法，并将其蒙特卡洛模拟结果与解析理论进行统计比较，你将深刻理解运动学构造是如何与簇射的动力学演化相结合的。",
            "id": "3527761",
            "problem": "考虑一个类时部分子演化变量 $t$，在马尔可夫部分子簇射中，从一个初始标度 $t_0$ 按序演化至一个截断值 $t_{\\min}$。其基本原理是，将发射表示为一个沿着有序演化、瞬时强度（风险率）为 $\\lambda_{\\text{true}}(t)$ 的非齐次泊松过程。无发射概率，也称为 Sudakov 形状因子，由标准公式定义\n$$\n\\Delta(t) = \\exp\\!\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right),\n$$\n这是非齐次泊松过程在区间 $[t, t_0]$ 内出现零个点的概率。\n\n在部分子簇射蒙特卡罗中使用的否决算法里，我们引入一个过高估计强度 $\\lambda_{\\text{over}}(t)$，使得对于所有 $t \\in [t_{\\min}, t_0]$ 都有 $\\lambda_{\\text{true}}(t) \\le \\lambda_{\\text{over}}(t)$，并根据 $\\lambda_{\\text{over}}(t)$ 生成提议点。在标度 $t_i$ 处的每个提议以概率 $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$ 被接受，否则被否决（拒绝）。被接受的提议定义了筛选点过程，该过程再现了真实的发射分布。\n\n您的任务是：\n\n1. 从 Sudakov 形状因子的定义出发，针对特定的真实强度\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\n推导出 $\\Delta(t_{\\min})$，其中 $A \\ge 0$ 和 $B \\ge 0$ 是固定实数参数，适用于 $t \\in [t_{\\min}, t_0]$。用 $A$、$B$、$t_0$ 和 $t_{\\min}$ 表示您最终的 $\\Delta(t_{\\min})$ 公式。\n\n2. 使用否决算法的筛选表示法，其过高估计强度为\n$$\n\\lambda_{\\text{over}}(t) = \\frac{C_{\\text{over}}}{t},\n$$\n推导出 $\\Delta(t_{\\min})$ 的两个无偏蒙特卡罗估计量：\n   - 一个拒绝乘积估计量，\n     $$\n     \\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle,\n     $$\n     其中 $t_i$ 是根据 $\\lambda_{\\text{over}}(t)$ 在 $[t_{\\min}, t_0]$ 中生成的提议标度，$p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$，$N_{\\text{prop}}$ 是在该区间内生成的提议的（随机）数量。\n   - 一个零接受指示函数估计量，\n     $$\n     \\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle,\n     $$\n     其中 $N_{\\text{acc}}$ 是在接受概率为 $p(t_i)$ 的筛选下，在 $[t_{\\min}, t_0]$ 中被接受的提议数量，$\\mathbb{I}\\{\\cdot\\}$ 是指示函数。\n\n3. 实现一个完整的、可运行的程序，该程序：\n   - 对每个测试用例，通过从 $t_0$ 到 $t_{\\min}$ 根据 $\\lambda_{\\text{over}}(t)$ 生成提议标度 $t_i$ 来模拟 $N$ 个独立的演化区间，使用统计上正确的方法。为保证数值稳定性，您可以将演化变量重新参数化为 $u = \\ln t$，并注意在 $u$ 中的提议生成过程变为齐次的。\n   - 对每个演化区间，计算乘积 $\\prod_i (1 - p(t_i))$ 和零接受指示函数 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$，其中 $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$。\n   - 通过样本方差，在 $N$ 个区间上估计 $\\hat{\\Delta}_{\\Pi}$ 和 $\\hat{\\Delta}_0$ 的抽样均值和抽样标准误差（样本均值的标准差）。\n   - 将每个估计量与第1部分的解析解 $\\Delta(t_{\\min})$ 进行比较，并报告其绝对差是否小于或等于其估计抽样标准误差的 $3$ 倍。对每个测试用例，产生两个布尔结果：一个用于 $\\hat{\\Delta}_{\\Pi}$，一个用于 $\\hat{\\Delta}_0$。\n   - 使用以下测试套件，它覆盖了恒定强度情况、强度依赖于$t$并饱和过高估计的情况，以及真实强度为零的边界情况：\n     - 情况1：$t_0 = 1.0$，$t_{\\min} = 10^{-3}$，$A = 0.5$，$B = 0.0$，$C_{\\text{over}} = 1.0$，$N = 100000$。\n     - 情况2：$t_0 = 1.0$，$t_{\\min} = 10^{-3}$，$A = 0.4$，$B = 0.5$，$C_{\\text{over}} = 0.9$，$N = 120000$。\n     - 情况3：$t_0 = 10^{-2}$，$t_{\\min} = 10^{-3}$，$A = 0.0$，$B = 0.0$，$C_{\\text{over}} = 0.3$，$N = 80000$。\n\n4. 最终输出格式规范：\n   - 您的程序应产生单行输出，其中包含六个布尔结果，形式为逗号分隔的列表并用方括号括起来，顺序如下\n     $$\n     [\\text{Case1-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case1-}\\hat{\\Delta}_0,\\, \\text{Case2-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case2-}\\hat{\\Delta}_0,\\, \\text{Case3-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case3-}\\hat{\\Delta}_0].\n     $$\n\n角度、物理单位和百分比未在本问题中出现。所有量均为无量纲量。每个布尔值的验证标准是 $\\left|\\hat{\\Delta} - \\Delta(t_{\\min})\\right| \\le 3\\, \\sigma_{\\hat{\\Delta}}$ 是否成立，其中 $\\sigma_{\\hat{\\Delta}}$ 是相应蒙特卡罗估计量的估计抽样标准误差。程序必须是自包含的，不需要任何输入，并遵守指定的运行时环境。",
            "solution": "该问题是适定的、科学上合理的且内部一致的。我们开始求解，求解过程包括三个部分：解析推导、蒙特卡罗估计量的理论论证，以及用于验证结果的数值实现。\n\n该问题围绕一个类时部分子演化的模拟展开，该演化被建模为在演化变量 $t \\in [t_{\\min}, t_0]$ 上的一个非齐次泊松过程。该过程的瞬时速率由 $\\lambda_{\\text{true}}(t)$ 给出。在起始标度 $t_0$ 和较低标度 $t$ 之间不发生发射的概率是 Sudakov 形状因子 $\\Delta(t)$。\n\n**第1部分：Sudakov 形状因子的解析计算**\n\nSudakov 形状因子定义为：\n$$\n\\Delta(t) = \\exp\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right)\n$$\n我们需要计算当真实强度函数为以下形式时 $\\Delta(t_{\\min})$ 的值：\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\n其中 $A \\ge 0$ 和 $B \\ge 0$ 是常数。\n\n首先，我们计算指数中的定积分，记为 $I$：\n$$\nI = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t')\\, dt' = \\int_{t_{\\min}}^{t_0} \\frac{A + B\\, t'}{t'}\\, dt'\n$$\n被积函数可以分离为两项：\n$$\nI = \\int_{t_{\\min}}^{t_0} \\left( \\frac{A}{t'} + B \\right) dt'\n$$\n进行积分得到：\n$$\nI = \\left[ A \\ln|t'| + B t' \\right]_{t_{\\min}}^{t_0}\n$$\n由于演化变量 $t$ 是正数（$t_{\\min} > 0$），我们可以去掉绝对值符号：\n$$\nI = (A \\ln(t_0) + B t_0) - (A \\ln(t_{\\min}) + B t_{\\min})\n$$\n按常数 $A$ 和 $B$ 分组：\n$$\nI = A (\\ln(t_0) - \\ln(t_{\\min})) + B (t_0 - t_{\\min})\n$$\n使用对数的性质 $\\ln(x) - \\ln(y) = \\ln(x/y)$，我们得到：\n$$\nI = A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) + B (t_0 - t_{\\min})\n$$\n将此积分代回 Sudakov 形状因子的定义，得到 $\\Delta(t_{\\min})$ 的最终解析表达式：\n$$\n\\Delta(t_{\\min}) = \\exp(-I) = \\exp\\left( -A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) - B (t_0 - t_{\\min}) \\right)\n$$\n这个公式也可以写成如下形式：\n$$\n\\Delta(t_{\\min}) = \\left(\\frac{t_0}{t_{\\min}}\\right)^{-A} \\exp(-B (t_0 - t_{\\min}))\n$$\n\n**第2部分：无偏蒙特卡罗估计量的推导**\n\n否决算法通过筛选一个由更易抽样的过高估计过程（强度为 $\\lambda_{\\text{over}}(t) \\ge \\lambda_{\\text{true}}(t)$）生成的提议流，来为强度为 $\\lambda_{\\text{true}}(t)$ 的过程生成事件。从筛选过程中接受的发射是真实泊松过程的一个点。\n\n**估计量 $\\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle$ （零接受指示函数）**\n\n根据定义，$\\Delta(t_{\\min})$ 是在区间 $[t_{\\min}, t_0]$ 内真实发射数 $N_{\\text{emissions}}$ 为零的概率。在此区间内，来自否决算法的接受提议数 $N_{\\text{acc}}$ 与 $N_{\\text{emissions}}$ 服从相同的分布。具体来说，$N_{\\text{acc}}$ 是一个服从泊松分布的随机变量，其均值为 $\\mu_{\\text{acc}} = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'$。\n\n观测到 $N_{\\text{acc}} = 0$ 的概率由零事件的泊松概率给出：\n$$\nP(N_{\\text{acc}} = 0) = \\frac{\\mu_{\\text{acc}}^0 e^{-\\mu_{\\text{acc}}}}{0!} = e^{-\\mu_{\\text{acc}}} = \\exp\\left(-\\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'\\right) = \\Delta(t_{\\min})\n$$\n根据定义，指示函数 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ 的期望是它所指示事件的概率：\n$$\n\\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle = P(N_{\\text{acc}} = 0) = \\Delta(t_{\\min})\n$$\n因此，$\\hat{\\Delta}_0$ 是 $\\Delta(t_{\\min})$ 的一个无偏估计量。蒙特卡罗估计是通过对多次独立模拟中 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ 的值进行平均得到的。\n\n**估计量 $\\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle$ （拒绝乘积）**\n\n该估计量的无偏性可以通过泊松点过程的性质来证明。提议标度 $\\{t_i\\}$ 构成一个强度为 $\\lambda_{\\text{over}}(t)$ 的泊松点过程。对于任意函数 $g(t)$，在一个区间 $[a,b]$ 内，对于一个速率为 $\\lambda(t)$ 的泊松过程的所有点，乘积 $\\prod_i g(t_i)$ 的期望由其特征泛函给出：\n$$\n\\mathbb{E}\\left[ \\prod_{i} g(t_i) \\right] = \\exp\\left( \\int_a^b (g(t)-1) \\lambda(t) dt \\right)\n$$\n在我们的情况下，该过程是 $[t_{\\min}, t_0]$ 上的提议过程，因此 $\\lambda(t) = \\lambda_{\\text{over}}(t)$。被乘的函数是 $g(t_i) = 1 - p(t_i)$，其中 $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$ 是接受概率。\n将这些代入公式：\n$$\n\\hat{\\Delta}_{\\Pi} = \\mathbb{E}\\left[ \\prod_{i=1}^{N_{\\text{prop}}} \\left(1 - \\frac{\\lambda_{\\text{true}}(t_i)}{\\lambda_{\\text{over}}(t_i)}\\right) \\right]\n= \\exp\\left( \\int_{t_{\\min}}^{t_0} \\left( \\left(1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')}\\right) - 1 \\right) \\lambda_{\\text{over}}(t') dt' \\right)\n$$\n积分内的项简化为：\n$$\n\\left( 1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} - 1 \\right) \\lambda_{\\text{over}}(t') = \\left( - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} \\right) \\lambda_{\\text{over}}(t') = - \\lambda_{\\text{true}}(t')\n$$\n因此，期望变为：\n$$\n\\hat{\\Delta}_{\\Pi} = \\exp\\left( - \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt' \\right) = \\Delta(t_{\\min})\n$$\n这表明 $\\hat{\\Delta}_{\\Pi}$ 也是 $\\Delta(t_{\\min})$ 的一个无偏估计量。每次模拟试验产生一个权重，多次试验中这些权重的平均值会收敛到真实的 Sudakov 形状因子。\n\n**第3部分：蒙特卡罗模拟策略**\n\n该实现将遵循推导出的原理来数值估计 $\\Delta(t_{\\min})$ 并验证估计量。\n\n**提议标度的生成：** 提议强度是 $\\lambda_{\\text{over}}(t) = C_{\\text{over}}/t$。顺序生成发射可能很慢。一种更高效的方法是重新参数化演化变量。令 $u = \\ln t$。从 $t_0$ 到 $t_{\\min}$ 的演化对应于从 $u_0 = \\ln t_0$ 到 $u_{\\min} = \\ln t_{\\min}$ 的演化。强度测度变换为 $d\\mu = \\lambda(t) dt$。在新变量 $u$ 中，强度变为 $\\lambda_u(u) = \\lambda_t(t(u)) |dt/du| = (C_{\\text{over}}/e^u) \\cdot e^u = C_{\\text{over}}$。\n在 $u$ 变量中的提议过程是在区间 $[u_{\\min}, u_0]$ 上速率为常数 $C_{\\text{over}}$ 的齐次泊松过程。这可以被高效地模拟：\n1.  计算提议的平均数量：$\\mu_{\\text{prop}} = C_{\\text{over}} (u_0 - u_{\\min}) = C_{\\text{over}} \\ln(t_0/t_{\\min})$。\n2.  对于给定的试验，从均值为 $\\mu_{\\text{prop}}$ 的泊松分布中抽取实际的提议数量 $N_{\\text{prop}}$。\n3.  在区间 $[u_{\\min}, u_0]$ 中均匀生成 $N_{\\text{prop}}$ 个值 $u_i$。\n4.  转换回原始变量：$t_i = \\exp(u_i)$。\n\n**估计量的计算：** 对于 $N$ 次独立试验中的每一次：\n1.  如上所述，生成一组提议标度 $\\{t_i\\}_{i=1}^{N_{\\text{prop}}}$。\n2.  每个提议的接受概率计算为 $p(t_i) = (A + B t_i) / C_{\\text{over}}$。题目给出了 $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$，但由于对于所有测试用例和 $t \\in [t_{\\min}, t_0]$ 都有 $A + Bt \\le C_{\\text{over}}$ 得到保证，因此 $\\min$ 操作是多余的。\n3.  $\\hat{\\Delta}_{\\Pi}$ 估计量的试验值为 $V_{\\Pi} = \\prod_{i=1}^{N_{\\text{prop}}} (1 - p(t_i))$。\n4.  为了得到 $\\hat{\\Delta}_0$ 估计量的试验值，我们模拟筛选过程：对于每个提议 $t_i$，生成一个均匀随机数 $r_i \\in [0,1)$，如果 $r_i  p(t_i)$ 则接受。我们计算接受的提议总数 $N_{\\text{acc}}$。估计量的值为 $V_0 = \\mathbb{I}\\{N_{\\text{acc}}=0\\}$，即如果 $N_{\\text{acc}}=0$ 则为 $1$，否则为 $0$。\n\n**统计分析：** 经过 $N$ 次试验后，我们得到两组结果 $\\{V_{\\Pi,j}\\}_{j=1}^N$ 和 $\\{V_{0,j}\\}_{j=1}^N$。\n对于每个估计量 $\\hat{\\Delta}$（代表 $\\hat{\\Delta}_{\\Pi}$ 或 $\\hat{\\Delta}_0$），我们计算：\n- 样本均值：$\\bar{V} = \\frac{1}{N} \\sum_{j=1}^N V_j$。这是我们对 $\\Delta(t_{\\min})$ 的数值估计。\n- 样本标准差：$s = \\sqrt{\\frac{1}{N-1} \\sum_{j=1}^N (V_j - \\bar{V})^2}$。\n- 均值的抽样标准误差：$\\sigma_{\\bar{V}} = s / \\sqrt{N}$。\n\n最后的验证步骤是检查解析值 $\\Delta(t_{\\min})$ 是否位于估计均值的 $3$ 个标准误差范围内，即 $|\\bar{V} - \\Delta(t_{\\min})| \\le 3 \\sigma_{\\bar{V}}$ 是否成立。这是一致性的标准统计检验，结果在 $3\\sigma$ 范围内通常被认为是相容的。对于每个测试用例中的每个估计量，将报告一个布尔值（`True` 或 `False`）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (t0, t_min, A, B, C_over, N)\n        (1.0, 1e-3, 0.5, 0.0, 1.0, 100000),\n        (1.0, 1e-3, 0.4, 0.5, 0.9, 120000),\n        (1e-2, 1e-3, 0.0, 0.0, 0.3, 80000),\n    ]\n\n    all_results = []\n    # A fixed seed ensures reproducibility of the Monte Carlo simulation.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    for i, case in enumerate(test_cases):\n        t0, t_min, A, B, C_over, N = case\n        \n        # 1. Analytical Sudakov calculation\n        log_ratio = np.log(t0 / t_min)\n        t_diff = t0 - t_min\n        integral_val = A * log_ratio + B * t_diff\n        delta_analytic = np.exp(-integral_val)\n\n        # 2. Monte Carlo simulation setup\n        u0 = np.log(t0)\n        u_min = np.log(t_min)\n        # Mean number of proposals in u-space for a homogeneous Poisson process\n        mu_prop = C_over * (u0 - u_min)\n\n        pi_estimator_values = np.zeros(N)\n        zero_estimator_values = np.zeros(N)\n\n        for j in range(N):\n            # Generate number of proposals from Poisson distribution\n            N_prop = rng.poisson(mu_prop)\n\n            if N_prop == 0:\n                pi_estimator_values[j] = 1.0\n                zero_estimator_values[j] = 1.0\n            else:\n                # Generate proposal locations in u-space (uniform)\n                u_proposals = rng.uniform(u_min, u0, size=N_prop)\n                # Transform back to t-space\n                t_proposals = np.exp(u_proposals)\n                \n                # Acceptance probabilities for each proposal\n                # The min(..., 1) is not strictly needed due to problem constraints\n                # but included for robustness.\n                p_values = np.minimum((A + B * t_proposals) / C_over, 1.0)\n                \n                # Estimator 1: Product of rejections\n                pi_estimator_values[j] = np.prod(1.0 - p_values)\n                \n                # Estimator 2: Zero acceptances\n                # Perform thinning to find number of accepted proposals\n                accept_rolls = rng.uniform(0.0, 1.0, size=N_prop)\n                N_acc = np.sum(accept_rolls < p_values)\n                zero_estimator_values[j] = 1.0 if N_acc == 0 else 0.0\n        \n        # 3. Statistical analysis and verification\n        # For pi_estimator\n        mean_pi = np.mean(pi_estimator_values)\n        std_pi = np.std(pi_estimator_values, ddof=1)\n        sem_pi = std_pi / np.sqrt(N)\n        \n        # Handle the case where standard error is zero (e.g., constant results)\n        if sem_pi > 0:\n            is_valid_pi = np.abs(mean_pi - delta_analytic) <= 3 * sem_pi\n        else:\n            is_valid_pi = np.isclose(mean_pi, delta_analytic)\n            \n        all_results.append(is_valid_pi)\n        \n        # For zero_estimator\n        mean_zero = np.mean(zero_estimator_values)\n        std_zero = np.std(zero_estimator_values, ddof=1)\n        sem_zero = std_zero / np.sqrt(N)\n\n        if sem_zero > 0:\n            is_valid_zero = np.abs(mean_zero - delta_analytic) <= 3 * sem_zero\n        else:\n            is_valid_zero = np.isclose(mean_zero, delta_analytic)\n\n        all_results.append(is_valid_zero)\n\n    # 4. Final print statement in the exact required format\n    # The output will be like [True,True,True,True,True,True]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}