{
    "hands_on_practices": [
        {
            "introduction": "The Lund string model provides a powerful picture of hadronization, describing it as a sequence of probabilistic breaks in a color flux tube. To truly grasp how this model works, it is essential to perform a hands-on calculation from first principles. This exercise  challenges you to compute the probability of a specific, ordered hadron sequence by meticulously applying the model's core rules for flavor suppression, spin state selection, and quark-diquark production, building a fundamental intuition for the hadronization process.",
            "id": "3516046",
            "problem": "A color string in Quantum Chromodynamics (QCD) connects an initial left endpoint quark $u$ to an initial right endpoint antiquark $\\bar{u}$. In a simplified string hadronization model, the string undergoes exactly two breaks, each break producing either a quark–antiquark pair $q\\bar{q}$ or a diquark–antidiquark pair $(qq)(\\overline{qq})$. The hadrons are formed sequentially from the left, with the rule that at each step the current left endpoint quark combines with the newly produced antiquark to form a meson; the newly produced quark then becomes the next left endpoint for the subsequent step. After two breaks, three mesons are formed: the first uses the initial $u$, the second uses the quark left from the first break, and the third uses the quark left from the second break combined with the original right endpoint $\\bar{u}$.\n\nAssume the following well-tested modeling ingredients:\n- At each break, the probability to produce a quark–antiquark pair rather than a diquark–antidiquark pair is $P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$, where $\\lambda_{qq}$ is the diquark suppression factor. For this problem, take $\\lambda_{qq} = 0.07$.\n- Conditional on producing a quark–antiquark pair, the flavor weights are isospin symmetric for $u$ and $d$ and strange-suppressed for $s$, with weights $w(u) = 1$, $w(d) = 1$, and $w(s) = \\gamma_{s}$, normalized by $Z = w(u)+w(d)+w(s) = 2 + \\gamma_{s}$. For this problem, take $\\gamma_{s} = 0.32$. Thus, the flavor-selection probabilities at a break are $P(u\\bar{u}\\mid q\\bar{q}) = \\frac{1}{Z}$, $P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{Z}$, and $P(s\\bar{s}\\mid q\\bar{q}) = \\frac{\\gamma_{s}}{Z}$.\n- For the meson quantum numbers, assume that for a given flavor content $q\\bar{q}'$ the model chooses between a pseudoscalar state (denoted by $P$) and a vector state (denoted by $V$) with a universal vector-to-pseudoscalar ratio $r_{V/P}$. The corresponding probabilities are $p_{V} = \\frac{r_{V/P}}{1+r_{V/P}}$ and $p_{P} = \\frac{1}{1+r_{V/P}}$. For this problem, take $r_{V/P} = 0.6$, so $p_{V} = \\frac{0.6}{1.6}$ and $p_{P} = \\frac{1}{1.6}$.\n- Ignore neutral flavor mixing effects and any additional dynamical mass or phase-space weights beyond the above probabilities.\n\nThe available meson species for the relevant flavor pairs are:\n- For $u\\bar{d}$: $\\pi^{+}$ (pseudoscalar), $\\rho^{+}$ (vector).\n- For $d\\bar{u}$: $\\pi^{-}$ (pseudoscalar), $\\rho^{-}$ (vector).\n- For $u\\bar{s}$: $K^{+}$ (pseudoscalar), $K^{*+}$ (vector).\n- For $d\\bar{s}$: $K^{0}$ (pseudoscalar), $K^{*0}$ (vector).\n- For $s\\bar{u}$: $K^{-}$ (pseudoscalar), $K^{*-}$ (vector).\n- For $s\\bar{d}$: $\\bar{K}^{0}$ (pseudoscalar), $\\bar{K}^{*0}$ (vector).\n\nConsider the ordered hadron sequence\n$$\nK^{+},\\ \\bar{K}^{0},\\ \\rho^{-},\n$$\nproduced by two breaks of the string starting from the $u$–$\\bar{u}$ endpoints, using the sequential left-to-right formation rule described above. Under the model and parameters specified, and enforcing total flavor and electric charge conservation, compute the probability of generating exactly this ordered sequence. Express your answer as a dimensionless number and round your result to six significant figures.",
            "solution": "The problem asks for the probability of producing the specific ordered sequence of hadrons $K^{+},\\ \\bar{K}^{0},\\ \\rho^{-}$ from an initial $u\\bar{u}$ string via two breaks. We must calculate the probability of the sequence of events required to produce this final state, according to the specified model rules. The total probability $P_{total}$ will be the product of the probabilities of each step in the sequence.\n\nThe hadronization process can be broken down as follows:\nInitial string: $u_{L} \\cdots \\bar{u}_{R}$\n\n**Step 1: Formation of the first meson, $M_1 = K^{+}$**\n-   The first meson, $K^{+}$, has quark content $u\\bar{s}$.\n-   It is formed from the initial left-endpoint quark, $u$, and an antiquark created in the first string break. This antiquark must be an $\\bar{s}$.\n-   Therefore, the first string break must produce an $s\\bar{s}$ pair. The new quark, $s$, becomes the new left-endpoint for the next step.\n-   The probability of this break has two components:\n    1.  The break must produce a quark-antiquark pair ($q\\bar{q}$) rather than a diquark-antidiquark pair. The probability is $P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$.\n    2.  Given a $q\\bar{q}$ break, the flavor produced must be $s\\bar{s}$. The probability is $P(s\\bar{s}\\mid q\\bar{q}) = \\frac{\\gamma_{s}}{Z} = \\frac{\\gamma_{s}}{2+\\gamma_{s}}$.\n-   The probability of the first break being of type $s\\bar{s}$ is $P_{\\text{break 1}} = P(q\\bar{q}) \\times P(s\\bar{s}\\mid q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}}$.\n-   The resulting $u\\bar{s}$ pair must form a $K^{+}$ meson, which is a pseudoscalar state ($P$). The alternative is the vector meson $K^{*+}$. The probability of forming a pseudoscalar is $p_P = \\frac{1}{1+r_{V/P}}$.\n\nThe total probability for the first hadron to be a $K^{+}$ is $P_1 = P_{\\text{break 1}} \\times p_P = \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}}$.\n\n**Step 2: Formation of the second meson, $M_2 = \\bar{K}^{0}$**\n-   After the first break, the propagating left-endpoint quark is an $s$.\n-   The second meson, $\\bar{K}^{0}$, has quark content $s\\bar{d}$. It must be formed from the current left-endpoint quark, $s$, and an antiquark from the second break. This antiquark must be a $\\bar{d}$.\n-   Therefore, the second string break must produce a $d\\bar{d}$ pair. The new quark, $d$, becomes the final left-endpoint quark.\n-   The probability of this break is calculated similarly to the first:\n    1.  The break must be a $q\\bar{q}$ type: $P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$.\n    2.  The flavor must be $d\\bar{d}$: $P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{Z} = \\frac{1}{2+\\gamma_{s}}$.\n-   The probability of the second break being of type $d\\bar{d}$ is $P_{\\text{break 2}} = P(q\\bar{q}) \\times P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}}$.\n-   The resulting $s\\bar{d}$ pair must form a $\\bar{K}^{0}$ meson, which is a pseudoscalar state ($P$). The alternative is the vector meson $\\bar{K}^{*0}$. The probability is $p_P = \\frac{1}{1+r_{V/P}}$.\n\nThe total probability for the second hadron to be a $\\bar{K}^{0}$ is $P_2 = P_{\\text{break 2}} \\times p_P = \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}}$.\n\n**Step 3: Formation of the third meson, $M_3 = \\rho^{-}$**\n-   After the second break, the final left-endpoint quark is a $d$.\n-   This $d$ quark combines with the original right-endpoint antiquark, which is a $\\bar{u}$, to form the third and final meson.\n-   The meson has quark content $d\\bar{u}$. The problem states this meson is a $\\rho^{-}$.\n-   A $\\rho^{-}$ is a vector meson ($V$). The alternative is the pseudoscalar meson $\\pi^{-}$. The probability of forming a vector meson is $p_V = \\frac{r_{V/P}}{1+r_{V/P}}$. No new string break is involved.\n\nThe probability for the third hadron to be a $\\rho^{-}$ is $P_3 = p_V = \\frac{r_{V/P}}{1+r_{V/P}}$.\n\n**Total Probability**\nThe total probability $P_{total}$ for the ordered sequence $K^{+},\\ \\bar{K}^{0},\\ \\rho^{-}$ is the product of the probabilities of each independent step:\n$$P_{total} = P_1 \\times P_2 \\times P_3$$\n$$P_{total} = \\left( \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}} \\right) \\times \\left( \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}} \\right) \\times \\left( \\frac{r_{V/P}}{1+r_{V/P}} \\right)$$\nCombining the terms, we get:\n$$P_{total} = \\frac{\\gamma_{s} r_{V/P}}{(1+\\lambda_{qq})^2 (2+\\gamma_{s})^2 (1+r_{V/P})^3}$$\nNow, we substitute the given numerical values: $\\lambda_{qq} = 0.07$, $\\gamma_{s} = 0.32$, and $r_{V/P} = 0.6$.\n-   $1 + \\lambda_{qq} = 1 + 0.07 = 1.07$\n-   $2 + \\gamma_{s} = 2 + 0.32 = 2.32$\n-   $1 + r_{V/P} = 1 + 0.6 = 1.6$\n\nSubstituting these into the expression for $P_{total}$:\n$$P_{total} = \\frac{(0.32) (0.6)}{(1.07)^2 (2.32)^2 (1.6)^3}$$\n$$P_{total} = \\frac{0.192}{(1.1449) (5.3824) (4.096)}$$\n$$P_{total} = \\frac{0.192}{6.16246976 \\times 4.096}$$\n$$P_{total} = \\frac{0.192}{25.23891404...}$$\n$$P_{total} \\approx 0.0076072979$$\nThe problem requires the answer to be rounded to six significant figures.\n$$P_{total} \\approx 0.00760730$$\nThis can be written in scientific notation as $7.60730 \\times 10^{-3}$.",
            "answer": "$$\\boxed{0.00760730}$$"
        },
        {
            "introduction": "While understanding the rules for a single event is crucial, the power of a physical model lies in its ability to describe entire datasets and have its parameters constrained by them. In this practice , we elevate our analysis by treating string breaking as a formal stochastic process. You will derive and implement a Maximum Likelihood Estimator to determine the fundamental string break rate, a key parameter of the model, from mock experimental data on hadron multiplicities and transverse momenta.",
            "id": "3516073",
            "problem": "Consider a simplified computational model of hadronization in Quantum Chromodynamics (QCD) where a color flux tube is approximated as a relativistic string. The string can break by quark-antiquark pair production, and the break points partition the string into hadrons. Assume a stochastic description where break events occur on the string worldsheet as a homogeneous Poisson process with constant rate per unit area. Specifically, let the worldsheet area be $A$ (in $\\mathrm{fm}^2$) and let the break rate per unit area be $\\lambda$ (in $\\mathrm{fm}^{-2}$). The observed hadron multiplicity for an event is $n \\in \\mathbb{N}_0$, interpreted as the number of break events in area $A$. In addition, model the transverse momentum magnitude $p_T$ (in $\\mathrm{GeV}$) of produced hadrons as arising from independent transverse momentum components that are each Gaussian distributed with zero mean and common variance $\\sigma^2$. For the magnitude $p_T$, this implies a Rayleigh distribution parameterized by $\\sigma$. To connect the breaking rate to transverse dynamics, assume an empirical proportionality $\\sigma^2 = c \\lambda$ with a known constant $c$ (in $\\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$), reflecting that higher break densities per area give larger transverse momentum variance.\n\nYour tasks are:\n1. Starting from the axioms of a homogeneous Poisson process on area, and the independence of disjoint regions, derive from first principles the probability mass function $P(n \\mid \\lambda, A)$ for the number of break events $n$ in area $A$.\n2. Using the assumptions above, construct the joint likelihood for data consisting of event-wise pairs $(A_i, n_i)$ and an associated set of transverse momentum magnitudes $\\{p_{T,j}\\}$, all conditionally independent given $\\lambda$. Derive the estimator $\\hat{\\lambda}$ by maximizing the joint likelihood with respect to $\\lambda > 0$, starting from the definitions of the Poisson process and the Rayleigh distribution.\n3. Implement a program that, given the following test suite of parameter values and observed data, computes the maximum likelihood estimate $\\hat{\\lambda}$ for each case and prints the results.\n\nUse the following constant in all test cases: $c = 0.25$ in $\\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$. For each case, $A$ values are in $\\mathrm{fm}^2$, $n$ values are counts (unitless), and $p_T$ values are in $\\mathrm{GeV}$. Express the final estimated break rates $\\hat{\\lambda}$ in $\\mathrm{fm}^{-2}$, rounded to six decimal places.\n\nTest suite:\nCase $1$ (general case with both multiplicity and transverse momentum data):\n- $A$ values: $[2.0, 1.5, 3.0]$ in $\\mathrm{fm}^2$.\n- $n$ values: $[2, 1, 3]$.\n- $p_T$ samples: $[0.45, 0.62, 0.38, 0.77, 0.31, 0.55, 0.49, 0.70, 0.29, 0.58]$ in $\\mathrm{GeV}$.\n\nCase $2$ (boundary case with no transverse momentum samples):\n- $A$ values: $[1.0, 1.0, 1.0, 1.0]$ in $\\mathrm{fm}^2$.\n- $n$ values: $[1, 1, 2, 0]$.\n- $p_T$ samples: $[]$ (empty list).\n\nCase $3$ (larger area and higher multiplicity with transverse momentum data):\n- $A$ values: $[5.0, 4.0]$ in $\\mathrm{fm}^2$.\n- $n$ values: $[7, 6]$.\n- $p_T$ samples: $[0.60, 0.80, 0.47, 0.51, 0.72, 0.66, 0.43, 0.58, 0.75, 0.49, 0.69, 0.55]$ in $\\mathrm{GeV}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[0.123456,0.654321,1.000000]$). The list must contain, in order, the three $\\hat{\\lambda}$ values corresponding to Case $1$, Case $2$, and Case $3$.\n\nAll answers that involve physical quantities must be provided in the specified units.",
            "solution": "The solution is divided into three parts as requested: the derivation of the Poisson probability mass function (PMF), the derivation of the maximum likelihood estimator for the break rate $\\lambda$, and the implementation of this estimator for the given test cases.\n\n### Part 1: Derivation of the Poisson Probability Mass Function (PMF)\n\nWe derive the PMF for the number of break events, $n$, in a worldsheet of area $A$, governed by a homogeneous Poisson process with rate $\\lambda$ per unit area. We begin from first principles, based on the process's behavior over an infinitesimally small area $\\Delta A$.\n\nThe axioms for the process are:\n1. The probability of exactly one event in a small area $\\Delta A$ is proportional to the area: $P(n=1 \\text{ in } \\Delta A) = \\lambda \\Delta A + o(\\Delta A)$, where $o(\\Delta A)$ represents terms that go to zero faster than $\\Delta A$.\n2. The probability of more than one event in $\\Delta A$ is negligible: $P(n \\ge 2 \\text{ in } \\Delta A) = o(\\Delta A)$.\n3. From the above, the probability of zero events in $\\Delta A$ is $P(n=0 \\text{ in } \\Delta A) = 1 - \\lambda \\Delta A - o(\\Delta A)$.\n4. The numbers of events in disjoint areas are independent random variables.\n\nLet $P_n(A)$ be the probability of observing exactly $n$ events in an area $A$. We consider the probability of $n$ events in a slightly larger area $A + \\Delta A$. Using the independence axiom, we can write $P_n(A+\\Delta A)$ by considering the mutually exclusive ways this can occur:\n- $n$ events in area $A$ and $0$ events in area $\\Delta A$. The probability is $P_n(A) P_0(\\Delta A) = P_n(A)(1 - \\lambda \\Delta A + o(\\Delta A))$.\n- $n-1$ events in area $A$ and $1$ event in area $\\Delta A$. The probability is $P_{n-1}(A) P_1(\\Delta A) = P_{n-1}(A)(\\lambda \\Delta A + o(\\Delta A))$.\n- Any other combination involves at least two events in $\\Delta A$, with a probability of order $o(\\Delta A)$.\n\nSumming these probabilities, we get:\n$$P_n(A+\\Delta A) = P_n(A)(1 - \\lambda \\Delta A) + P_{n-1}(A)(\\lambda \\Delta A) + o(\\Delta A)$$\nRearranging the terms gives:\n$$\\frac{P_n(A+\\Delta A) - P_n(A)}{\\Delta A} = \\lambda (P_{n-1}(A) - P_n(A)) + \\frac{o(\\Delta A)}{\\Delta A}$$\nTaking the limit as $\\Delta A \\to 0$, we obtain a system of ordinary differential-difference equations:\n$$\\frac{d P_n(A)}{d A} = \\lambda (P_{n-1}(A) - P_n(A)) \\quad \\text{for } n \\ge 1$$\nFor the case $n=0$, there is no $P_{-1}(A)$ term, so the equation becomes:\n$$\\frac{d P_0(A)}{d A} = -\\lambda P_0(A)$$\nThe initial condition is that there are zero events in zero area, so $P_0(0) = 1$. The solution to this first-order ODE is:\n$$P_0(A) = e^{-\\lambda A}$$\nNow, we can solve for $n=1$:\n$$\\frac{d P_1(A)}{d A} = \\lambda (P_0(A) - P_1(A)) = \\lambda(e^{-\\lambda A} - P_1(A))$$\nWith the initial condition $P_1(0)=0$, this linear first-order ODE has the solution:\n$$P_1(A) = (\\lambda A) e^{-\\lambda A}$$\nBy induction, we can show that the general solution for any $n \\in \\mathbb{N}_0$ is:\n$$P(n \\mid \\lambda, A) \\equiv P_n(A) = \\frac{(\\lambda A)^n e^{-\\lambda A}}{n!}$$\nThis is the Probability Mass Function of a Poisson distribution with mean $\\lambda A$.\n\n### Part 2: Derivation of the Maximum Likelihood Estimator (MLE)\n\nWe are given two types of data, conditionally independent given $\\lambda$:\n1. A set of $M$ event multiplicity observations $\\{(A_i, n_i)\\}_{i=1}^M$.\n2. A set of $N$ transverse momentum magnitude samples $\\{p_{T,j}\\}_{j=1}^N$.\n\nThe joint likelihood function $L(\\lambda)$ is the product of the probabilities of all individual observations.\n\nThe likelihood from the multiplicity data, $L_n(\\lambda)$, is the product of Poisson probabilities:\n$$L_n(\\lambda) = \\prod_{i=1}^M P(n_i \\mid \\lambda, A_i) = \\prod_{i=1}^M \\frac{(\\lambda A_i)^{n_i} e^{-\\lambda A_i}}{n_i!}$$\nThe likelihood from the transverse momentum data, $L_{p_T}(\\lambda)$, is the product of Rayleigh probability densities. The PDF for a Rayleigh-distributed variable $x$ with parameter $\\sigma$ is $f(x; \\sigma) = \\frac{x}{\\sigma^2} e^{-x^2/(2\\sigma^2)}$. With the given relation $\\sigma^2 = c\\lambda$, the PDF for a single $p_{T,j}$ measurement is:\n$$f(p_{T,j} \\mid \\lambda) = \\frac{p_{T,j}}{c\\lambda} e^{-p_{T,j}^2/(2c\\lambda)}$$\nThe likelihood for all $p_T$ data is:\n$$L_{p_T}(\\lambda) = \\prod_{j=1}^N f(p_{T,j} \\mid \\lambda) = \\prod_{j=1}^N \\frac{p_{T,j}}{c\\lambda} e^{-p_{T,j}^2/(2c\\lambda)}$$\nThe total likelihood is $L(\\lambda) = L_n(\\lambda) \\cdot L_{p_T}(\\lambda)$. It is more convenient to work with the log-likelihood, $\\mathcal{L}(\\lambda) = \\ln(L(\\lambda))$. Terms not dependent on $\\lambda$ can be ignored for maximization.\n$$\\mathcal{L}(\\lambda) = \\ln(L_n(\\lambda)) + \\ln(L_{p_T}(\\lambda))$$\n$$\\mathcal{L}(\\lambda) = \\sum_{i=1}^M (n_i \\ln(\\lambda A_i) - \\lambda A_i) + \\sum_{j=1}^N (-\\ln(c\\lambda) - \\frac{p_{T,j}^2}{2c\\lambda}) + \\text{const}$$\nExpanding the logarithms and grouping terms based on $\\lambda$:\n$$\\mathcal{L}(\\lambda) = \\sum_{i=1}^M (n_i \\ln\\lambda + n_i\\ln A_i - \\lambda A_i) + \\sum_{j=1}^N (-\\ln c - \\ln\\lambda - \\frac{p_{T,j}^2}{2c\\lambda}) + \\text{const}$$\n$$\\mathcal{L}(\\lambda) = \\ln\\lambda \\left(\\sum_{i=1}^M n_i\\right) - \\lambda \\left(\\sum_{i=1}^M A_i\\right) - \\ln\\lambda \\left(\\sum_{j=1}^N 1\\right) - \\frac{1}{\\lambda} \\left(\\frac{1}{2c}\\sum_{j=1}^N p_{T,j}^2\\right) + \\text{const}$$\nLet's introduce summary statistics: $N_{tot} = \\sum_{i=1}^M n_i$, $A_{tot} = \\sum_{i=1}^M A_i$, and $S_{p_T^2} = \\sum_{j=1}^N p_{T,j}^2$. The number of $p_T$ samples is $N$.\n$$\\mathcal{L}(\\lambda) = (N_{tot} - N)\\ln\\lambda - A_{tot}\\lambda - \\frac{S_{p_T^2}}{2c\\lambda} + \\text{const}$$\nTo find the maximum, we differentiate with respect to $\\lambda$ and set the result to zero:\n$$\\frac{d\\mathcal{L}}{d\\lambda} = \\frac{N_{tot} - N}{\\lambda} - A_{tot} + \\frac{S_{p_T^2}}{2c\\lambda^2} = 0$$\nAssuming $\\lambda > 0$, we multiply by $\\lambda^2$:\n$$(N_{tot} - N)\\lambda - A_{tot}\\lambda^2 + \\frac{S_{p_T^2}}{2c} = 0$$\nThis is a quadratic equation for $\\lambda$:\n$$A_{tot}\\lambda^2 - (N_{tot} - N)\\lambda - \\frac{S_{p_T^2}}{2c} = 0$$\nUsing the quadratic formula, $\\lambda = \\frac{-b \\pm \\sqrt{b^2-4ac_{quad}}}{2a}$, where $a = A_{tot}$, $b = -(N_{tot} - N)$, and $c_{quad} = -\\frac{S_{p_T^2}}{2c}$:\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) \\pm \\sqrt{(-(N_{tot} - N))^2 - 4(A_{tot})(-\\frac{S_{p_T^2}}{2c})}}{2A_{tot}}$$\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) \\pm \\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} S_{p_T^2}}{c}}}{2A_{tot}}$$\nSince $\\lambda$ must be a positive rate, we must choose the root that yields a positive value. The term under the square root, $\\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} S_{p_T^2}}{c}}$, is strictly greater than $|N_{tot}-N|$ (as long as $A_{tot}>0$ and $S_{p_T^2}>0$). Therefore, the minus sign would yield a negative $\\hat{\\lambda}$. We must take the plus sign.\nThe final estimator is:\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) + \\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} \\sum_{j=1}^N p_{T,j}^2}{c}}}{2 \\sum_{i=1}^M A_i}$$\nThis formula is valid provided $A_{tot} = \\sum A_i > 0$.\n\n### Part 3: Implementation and Test Case Computation\n\nThe derived formula for $\\hat{\\lambda}$ is implemented to calculate the estimates for the three test cases using the constant $c=0.25 \\, \\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$.\n\n**Case 1:**\n- $A = [2.0, 1.5, 3.0]$\n- $n = [2, 1, 3]$\n- $p_T$ samples: $10$ values provided.\n- Summary statistics: $A_{tot} = 6.5$, $N_{tot} = 6$, $N=10$, $S_{p_T^2} = \\sum p_{T,j}^2 \\approx 2.8734$.\n- $\\hat{\\lambda}_1 = \\frac{(6-10) + \\sqrt{(6-10)^2 + \\frac{2 \\cdot 6.5 \\cdot 2.8734}{0.25}}}{2 \\cdot 6.5} = \\frac{-4 + \\sqrt{16 + 149.4168}}{13} \\approx 0.681650 \\, \\mathrm{fm}^{-2}$.\n\n**Case 2:**\n- $A = [1.0, 1.0, 1.0, 1.0]$\n- $n = [1, 1, 2, 0]$\n- $p_T$ samples: empty list.\n- Summary statistics: $A_{tot} = 4.0$, $N_{tot} = 4$, $N=0$, $S_{p_T^2} = 0$.\n- In this case, the formula simplifies to the standard Poisson MLE: $\\hat{\\lambda}_2 = \\frac{N_{tot}}{A_{tot}} = \\frac{4}{4.0} = 1.000000 \\, \\mathrm{fm}^{-2}$.\n\n**Case 3:**\n- $A = [5.0, 4.0]$\n- $n = [7, 6]$\n- $p_T$ samples: $12$ values provided.\n- Summary statistics: $A_{tot} = 9.0$, $N_{tot} = 13$, $N=12$, $S_{p_T^2} = \\sum p_{T,j}^2 \\approx 4.5375$.\n- $\\hat{\\lambda}_3 = \\frac{(13-12) + \\sqrt{(13-12)^2 + \\frac{2 \\cdot 9.0 \\cdot 4.5375}{0.25}}}{2 \\cdot 9.0} = \\frac{1 + \\sqrt{1 + 326.7}}{18} \\approx 1.055710 \\, \\mathrm{fm}^{-2}$.\n\nThe following code implements these computations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum likelihood estimate (MLE) for the string break rate lambda\n    for three different test cases based on a derived formula.\n    \"\"\"\n    C_CONSTANT = 0.25  # fm^2 * GeV^2\n\n    test_cases = [\n        {\n            \"A_vals\": [2.0, 1.5, 3.0],\n            \"n_vals\": [2, 1, 3],\n            \"pT_samples\": [0.45, 0.62, 0.38, 0.77, 0.31, 0.55, 0.49, 0.70, 0.29, 0.58],\n        },\n        {\n            \"A_vals\": [1.0, 1.0, 1.0, 1.0],\n            \"n_vals\": [1, 1, 2, 0],\n            \"pT_samples\": [],\n        },\n        {\n            \"A_vals\": [5.0, 4.0],\n            \"n_vals\": [7, 6],\n            \"pT_samples\": [0.60, 0.80, 0.47, 0.51, 0.72, 0.66, 0.43, 0.58, 0.75, 0.49, 0.69, 0.55],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A_vals = np.array(case[\"A_vals\"])\n        n_vals = np.array(case[\"n_vals\"])\n        pT_samples = np.array(case[\"pT_samples\"])\n\n        # Calculate summary statistics\n        A_tot = np.sum(A_vals)\n        N_tot = np.sum(n_vals)\n        N_pT = len(pT_samples)\n        S_pT_sq = np.sum(pT_samples**2)\n        \n        # Check for A_tot = 0, which would require a different formula (linear eq).\n        # This case is not present in the problem suite but is good practice.\n        if A_tot == 0:\n            # If A_tot is 0, the quadratic term vanishes. Equation becomes linear:\n            # -(N_tot - N) * lambda - S_pT_sq / (2c) = 0\n            # (N - N_tot) * lambda = S_pT_sq / (2c)\n            # lambda = S_pT_sq / (2 * c * (N - N_tot))\n            if N_pT > N_tot:\n                lambda_hat = S_pT_sq / (2 * C_CONSTANT * (N_pT - N_tot))\n            else:\n                # Physically/statistically problematic case, likely indicates no solution or model breakdown.\n                # For this problem, we can assume A_tot > 0 as per the test cases.\n                lambda_hat = np.nan # Or raise an error\n        else:\n            # General formula derived from the quadratic equation for lambda:\n            # A_tot * lambda^2 - (N_tot - N) * lambda - S_pT_sq / (2c) = 0\n            term_under_sqrt = (N_tot - N_pT)**2 + (2 * A_tot * S_pT_sq) / C_CONSTANT\n            \n            numerator = (N_tot - N_pT) + np.sqrt(term_under_sqrt)\n            denominator = 2 * A_tot\n            \n            lambda_hat = numerator / denominator\n\n        results.append(lambda_hat)\n\n    # Format the output as specified, with 6 decimal places.\n    output_str = f\"[{','.join([f'{res:.6f}' for res in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Tuning the many parameters of modern hadronization models is a computationally intensive task, traditionally reliant on slow, grid-based methods. This advanced practice  introduces a cutting-edge solution: differentiable programming. You will construct a simplified, yet physically realistic, \"surrogate\" for the Lund fragmentation function and derive the analytical gradient of a $\\chi^2$ goodness-of-fit function, enabling the use of highly efficient, gradient-based optimization algorithms that are transforming modern computational physics.",
            "id": "3516042",
            "problem": "You are tasked with constructing a self-consistent, differentiable surrogate for the Lund string fragmentation in high-energy collisions and using it to compute the gradient of a chi-squared objective with respect to the shape parameter. The surrogate must be scientifically plausible and internally consistent with common modeling practices in hadronization. You must implement it as a runnable program that, for a suite of parameter sets, computes the analytical gradient of the chi-squared objective with respect to the parameter $a$ and compares it to a finite-difference estimate.\n\nFundamental base and modeling assumptions:\n- The string fragmentation probability density in terms of the light-cone momentum fraction $z$ is modeled by a Lund-like expression that depends on a shape parameter $a$, a slope parameter $b$ in units of inverse squared giga-electron volts, and the transverse mass $m_{T}$ of the produced hadron. Specifically, the unnormalized species-weighted integrand takes the form\n$$\nq(z; a, b, m_T) \\propto z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right),\n$$\nfor $z \\in [z_{\\min}, z_{\\max}]$ with $z_{\\min} > 0$ and $z_{\\max}  1$ to ensure convergence and differentiability. This is consistent with the widely used Lund-symmetric fragmentation form and is used here as the foundational base for a differentiable surrogate.\n- The strangeness suppression factor $\\gamma_s$ ($0  \\gamma_s  1$) multiplies yields of strange hadrons relative to non-strange hadrons.\n\nScientific and numerical details:\n- Use $z_{\\min} = 10^{-4}$ and $z_{\\max} = 1 - 10^{-4}$.\n- Use the charged pion mass $m_{\\pi} = 0.13957\\,\\mathrm{GeV}$ and the charged kaon mass $m_{K} = 0.493677\\,\\mathrm{GeV}$.\n- Use a fixed effective transverse momentum scale $p_{T0} = 0.35\\,\\mathrm{GeV}$ and define the transverse masses as $m_{T,\\pi}^2 = m_{\\pi}^2 + p_{T0}^2$ and $m_{T,K}^2 = m_{K}^2 + p_{T0}^2$.\n- The parameter $b$ is in units of $\\mathrm{GeV}^{-2}$, and $a$ and $\\gamma_s$ are dimensionless.\n- No angles are involved, so no angle units are required.\n\nDefine the following three observables predicted by the surrogate:\n1. A multiplicity proxy observable $O_M(a,b)$ defined by\n$$\nO_M(a,b) = C_{\\mathrm{mult}} \\cdot \\frac{\\int_{z_{\\min}}^{z_{\\max}} \\frac{1}{z} \\, q(z; a, b, m_{T,\\pi}) \\, dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) \\, dz},\n$$\nwhere $C_{\\mathrm{mult}}$ is a calibration constant chosen such that at the reference parameter point $(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}, \\gamma_{s,\\mathrm{ref}}) = (0.3, 0.58, 0.3)$ the predicted $O_M$ exactly matches the observed charged multiplicity $O_M^{\\mathrm{obs}} = 20.9$ (in counts). This ensures scientific realism by anchoring the surrogate to a plausible measurement at the $Z$ boson pole. You must compute $C_{\\mathrm{mult}}$ from this requirement using the above integrals evaluated at the reference point.\n2. The mean momentum fraction observable $O_z(a,b)$ defined by\n$$\nO_z(a,b) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} z \\, q(z; a, b, m_{T,\\pi}) \\, dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) \\, dz}.\n$$\n3. The strange-to-total charged hadron fraction $O_{K/\\pi}(a,b,\\gamma_s)$ defined by\n$$\nY_{\\pi}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,\\pi}^2}{z}\\right) dz,\n$$\n$$\nY_{K}(a,b,\\gamma_s) = \\gamma_s \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,K}^2}{z}\\right) dz,\n$$\n$$\nO_{K/\\pi}(a,b,\\gamma_s) = \\frac{Y_{K}(a,b,\\gamma_s)}{Y_{\\pi}(a,b) + Y_{K}(a,b,\\gamma_s)}.\n$$\n\nObserved values and uncertainties for the chi-squared objective:\n- Use $O_M^{\\mathrm{obs}} = 20.9$ with $\\sigma_M = 0.5$ (counts).\n- Use $O_z^{\\mathrm{obs}} = 0.25$ with $\\sigma_z = 0.02$ (dimensionless).\n- Use $O_{K/\\pi}^{\\mathrm{obs}} = 0.13$ with $\\sigma_{K/\\pi} = 0.02$ (dimensionless).\n\nDefine the chi-squared objective as\n$$\n\\chi^2(a,b,\\gamma_s) = \\left(\\frac{O_M(a,b) - O_M^{\\mathrm{obs}}}{\\sigma_M}\\right)^2 + \\left(\\frac{O_z(a,b) - O_z^{\\mathrm{obs}}}{\\sigma_z}\\right)^2 + \\left(\\frac{O_{K/\\pi}(a,b,\\gamma_s) - O_{K/\\pi}^{\\mathrm{obs}}}{\\sigma_{K/\\pi}}\\right)^2.\n$$\n\nYour tasks:\n- Derive and implement a differentiable computation of $\\frac{\\partial \\chi^2}{\\partial a}$ based on first principles, using the fact that derivatives of integrals of the form $\\int g(z)\\, z^{-1} \\left(1-z\\right)^a \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right) dz$ with respect to $a$ can be expressed as integrals where $\\frac{\\partial}{\\partial a}$ acts on the factor $\\left(1-z\\right)^a$. You must derive expressions for the required derivatives of the observables with respect to $a$ without resorting to black-box automatic differentiation.\n- Compute a finite-difference approximation to $\\frac{\\partial \\chi^2}{\\partial a}$ using the symmetric difference formula with step size $\\delta = 10^{-3}$:\n$$\n\\left.\\frac{\\partial \\chi^2}{\\partial a}\\right|_{\\mathrm{FD}} \\approx \\frac{\\chi^2(a+\\delta,b,\\gamma_s) - \\chi^2(a-\\delta,b,\\gamma_s)}{2\\delta}.\n$$\n- For numerical integration, use a uniform grid in $z$ of at least $N = 5000$ points on $[z_{\\min}, z_{\\max}]$ and a stable quadrature rule. The final answers are unitless numbers.\n\nTest suite:\nEvaluate the analytical and finite-difference gradients for the following four parameter sets, chosen to test a range of behaviors:\n1. $(a,b,\\gamma_s) = (0.3, 0.58, 0.3)$.\n2. $(a,b,\\gamma_s) = (1.2, 0.58, 0.3)$.\n3. $(a,b,\\gamma_s) = (0.1, 0.30, 0.2)$.\n4. $(a,b,\\gamma_s) = (0.5, 0.90, 0.35)$.\n\nRequired outputs:\n- For each parameter set, compute the analytical gradient $\\frac{\\partial \\chi^2}{\\partial a}$ and the finite-difference gradient, and report the relative discrepancy defined as\n$$\n\\mathrm{RelErr} = \\frac{\\left|\\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{analytic}} - \\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(\\left|\\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{FD}}\\right|, 10^{-12}\\right)}.\n$$\n- Your program should produce a single line of output containing the four relative discrepancies as a comma-separated list enclosed in square brackets, in the order of the test suite parameter sets, for example, $\\left[0.0012,0.0345,0.0008,0.0123\\right]$.\n\nAll calculations must be in the stated physical units: masses in $\\mathrm{GeV}$, $b$ in $\\mathrm{GeV}^{-2}$, and the final outputs dimensionless. Ensure scientific realism and numerical stability throughout.",
            "solution": "The problem requires the construction and validation of a differentiable surrogate model for hadronization, based on the Lund string fragmentation function. The primary task is to compute the analytical gradient of a $\\chi^2$ objective function with respect to a shape parameter $a$, and to compare this with a finite-difference approximation.\n\nFirst, we formalize the components of the model. The unnormalized probability density for producing a hadron of transverse mass $m_T$ with light-cone momentum fraction $z$ is given by\n$$ q(z; a, b, m_T) \\propto z^{-1} (1-z)^{a} \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right) $$\nwhere $a$ is a dimensionless shape parameter and $b$ is a slope parameter in units of $\\mathrm{GeV}^{-2}$. To facilitate the derivation, we define a general family of integrals over the specified range $z \\in [z_{\\min}, z_{\\max}]$:\n$$ K_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{n-1} (1-z)^a \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) dz $$\nHere, the index $h$ denotes the hadron species (pion, $\\pi$, or kaon, $K$), and $n$ determines the power of the momentum fraction $z$ in the integrand's pre-factor.\n\nThe three physical observables can be expressed in terms of these integrals. The proportionality constants in $q(z)$ cancel in the ratios defining the observables.\n\n1.  The multiplicity proxy, $O_M(a,b)$, is defined as\n    $$ O_M(a,b) = C_{\\mathrm{mult}} \\frac{\\int_{z_{\\min}}^{z_{\\max}} z^{-1} q(z; a, b, m_{T,\\pi}) dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) dz} = C_{\\mathrm{mult}} \\frac{K_{\\pi}^{(-1)}(a,b)}{K_{\\pi}^{(0)}(a,b)} $$\n    The constant $C_{\\mathrm{mult}}$ is determined by the condition that $O_M(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}) = O_M^{\\mathrm{obs}} = 20.9$ at the reference point $(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}) = (0.3, 0.58)$. This yields:\n    $$ C_{\\mathrm{mult}} = O_M^{\\mathrm{obs}} \\frac{K_{\\pi}^{(0)}(a_{\\mathrm{ref}}, b_{\\mathrm{ref}})}{K_{\\pi}^{(-1)}(a_{\\mathrm{ref}}, b_{\\mathrm{ref}})} $$\n\n2.  The mean momentum fraction, $O_z(a,b)$, is defined as\n    $$ O_z(a,b) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} z \\, q(z; a, b, m_{T,\\pi}) dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) dz} = \\frac{K_{\\pi}^{(1)}(a,b)}{K_{\\pi}^{(0)}(a,b)} $$\n\n3.  The strange-to-total charged hadron fraction, $O_{K/\\pi}(a,b,\\gamma_s)$, is built from the integrated yields $Y_\\pi$ and $Y_K$:\n    $$ Y_{\\pi}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,\\pi}^2}{z}\\right) dz = K_{\\pi}^{(0)}(a,b) $$\n    $$ Y_{K}(a,b,\\gamma_s) = \\gamma_s \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,K}^2}{z}\\right) dz = \\gamma_s K_{K}^{(0)}(a,b) $$\n    Thus, the observable is:\n    $$ O_{K/\\pi}(a,b,\\gamma_s) = \\frac{Y_{K}}{Y_{\\pi} + Y_{K}} = \\frac{\\gamma_s K_{K}^{(0)}(a,b)}{K_{\\pi}^{(0)}(a,b) + \\gamma_s K_{K}^{(0)}(a,b)} $$\n\nThe objective function to be minimized is the $\\chi^2$:\n$$ \\chi^2(a,b,\\gamma_s) = \\sum_{i \\in \\{M, z, K/\\pi\\}} \\left(\\frac{O_i(a,b,\\gamma_s) - O_i^{\\mathrm{obs}}}{\\sigma_i}\\right)^2 $$\n\nTo compute the analytical gradient $\\frac{\\partial \\chi^2}{\\partial a}$, we use the chain rule:\n$$ \\frac{\\partial \\chi^2}{\\partial a} = \\sum_{i \\in \\{M, z, K/\\pi\\}} \\frac{\\partial \\chi^2}{\\partial O_i} \\frac{\\partial O_i}{\\partial a} = \\sum_{i \\in \\{M, z, K/\\pi\\}} 2 \\frac{O_i - O_i^{\\mathrm{obs}}}{\\sigma_i^2} \\frac{\\partial O_i}{\\partial a} $$\nThe core task is to find the derivatives $\\frac{\\partial O_i}{\\partial a}$. This requires differentiating the integrals $K_h^{(n)}$ with respect to $a$. Using the Leibniz integral rule (differentiating under the integral sign), as the integration limits do not depend on $a$:\n$$ \\frac{\\partial}{\\partial a} K_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} \\frac{\\partial}{\\partial a} \\left[ z^{n-1} (1-z)^a \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) \\right] dz $$\nSince $\\frac{\\partial}{\\partial a}(1-z)^a = (1-z)^a \\ln(1-z)$, we define a second family of integrals, $J_h^{(n)}$:\n$$ J_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{n-1} (1-z)^a \\ln(1-z) \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) dz = \\frac{\\partial}{\\partial a} K_{h}^{(n)}(a,b) $$\n\nNow we can compute the derivatives of the observables using the quotient rule:\n$$ \\frac{\\partial O_M}{\\partial a} = C_{\\mathrm{mult}} \\frac{\\partial}{\\partial a}\\left(\\frac{K_{\\pi}^{(-1)}}{K_{\\pi}^{(0)}}\\right) = C_{\\mathrm{mult}} \\frac{J_{\\pi}^{(-1)} K_{\\pi}^{(0)} - K_{\\pi}^{(-1)} J_{\\pi}^{(0)}}{(K_{\\pi}^{(0)})^2} $$\n$$ \\frac{\\partial O_z}{\\partial a} = \\frac{\\partial}{\\partial a}\\left(\\frac{K_{\\pi}^{(1)}}{K_{\\pi}^{(0)}}\\right) = \\frac{J_{\\pi}^{(1)} K_{\\pi}^{(0)} - K_{\\pi}^{(1)} J_{\\pi}^{(0)}}{(K_{\\pi}^{(0)})^2} $$\n$$ \\frac{\\partial O_{K/\\pi}}{\\partial a} = \\frac{\\partial}{\\partial a}\\left(\\frac{\\gamma_s K_{K}^{(0)}}{K_{\\pi}^{(0)} + \\gamma_s K_{K}^{(0)}}\\right) = \\frac{\\gamma_s (J_K^{(0)} K_\\pi^{(0)} - K_K^{(0)} J_\\pi^{(0)})}{(K_\\pi^{(0)} + \\gamma_s K_K^{(0)})^2} $$\nSubstituting these expressions into the formula for $\\frac{\\partial \\chi^2}{\\partial a}$ provides the final analytical gradient.\n\nThe numerical implementation proceeds as follows. First, the constant $C_{\\mathrm{mult}}$ is computed by numerically evaluating $K_{\\pi}^{(0)}$ and $K_{\\pi}^{(-1)}$ at the reference parameters. For each parameter set in the test suite, we then:\n1.  Numerically evaluate all required integrals: $K_{\\pi}^{(-1)}$, $K_{\\pi}^{(0)}$, $K_{\\pi}^{(1)}$, $K_{K}^{(0)}$ and their derivative counterparts $J_{\\pi}^{(-1)}$, $J_{\\pi}^{(0)}$, $J_{\\pi}^{(1)}$, $J_{K}^{(0)}$. A uniform grid in $z$ with $N=5000$ points and the trapezoidal rule for quadrature are used as specified.\n2.  Calculate the values of the observables $O_M, O_z, O_{K/\\pi}$.\n3.  Calculate the derivatives $\\frac{\\partial O_M}{\\partial a}, \\frac{\\partial O_z}{\\partial a}, \\frac{\\partial O_{K/\\pi}}{\\partial a}$.\n4.  Assemble the full analytical gradient $\\frac{\\partial \\chi^2}{\\partial a}$.\n\nFor validation, a finite-difference approximation of the gradient is computed using the symmetric difference formula with a step size $\\delta=10^{-3}$:\n$$ \\left.\\frac{\\partial \\chi^2}{\\partial a}\\right|_{\\mathrm{FD}} \\approx \\frac{\\chi^2(a+\\delta, b, \\gamma_s) - \\chi^2(a-\\delta, b, \\gamma_s)}{2\\delta} $$\nThis requires re-computing the $\\chi^2$ value, and thus the base $K$-integrals and observables, at the perturbed parameter points $(a \\pm \\delta, b, \\gamma_s)$.\n\nFinally, the relative discrepancy between the analytical and finite-difference gradients is computed for each test case to verify the correctness of the analytical derivation and implementation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes analytical and finite-difference gradients of a chi-squared\n    objective for a hadronization surrogate model and reports their relative\n    discrepancy for several test cases.\n    \"\"\"\n    #\n    # --- Problem Constants and Setup ---\n    #\n    Z_MIN = 1e-4\n    Z_MAX = 1 - 1e-4\n    N_POINTS = 5000\n    M_PI = 0.13957   # GeV\n    M_K = 0.493677    # GeV\n    P_T0 = 0.35      # GeV\n    MT2_PI = M_PI**2 + P_T0**2\n    MT2_K = M_K**2 + P_T0**2\n    OBS_M = 20.9\n    SIGMA_M = 0.5\n    OBS_Z = 0.25\n    SIGMA_Z = 0.02\n    OBS_KPI = 0.13\n    SIGMA_KPI = 0.02\n    A_REF, B_REF, _ = 0.3, 0.58, 0.3\n    DELTA_A = 1e-3\n\n    #\n    # --- Physics Model and Calculation Class ---\n    #\n    class LundSurrogate:\n        \"\"\"\n        A class to encapsulate the calculations for the Lund surrogate model.\n        \"\"\"\n        def __init__(self, z_grid, mt2_pi, mt2_k, C_mult):\n            self.z = z_grid\n            self.mt2_pi = mt2_pi\n            self.mt2_k = mt2_k\n            self.C_mult = C_mult\n            self.obs_vals = {'M': OBS_M, 'z': OBS_Z, 'Kpi': OBS_KPI}\n            self.sigmas = {'M': SIGMA_M, 'z': SIGMA_Z, 'Kpi': SIGMA_KPI}\n\n        def _integrator(self, integrand):\n            return np.trapz(integrand, self.z)\n\n        def _compute_integral_family(self, a, b, mt2):\n            \"\"\"Computes K and J integrals for a given hadron type.\"\"\"\n            # Base terms of the integrands\n            one_minus_z = 1 - self.z\n            common_term = (one_minus_z)**a * np.exp(-b * mt2 / self.z)\n            log_term = np.log(one_minus_z)\n\n            # Integrals for pions (pi)\n            K_vals = {\n                -1: self._integrator(self.z**(-2) * common_term),\n                 0: self._integrator(self.z**(-1) * common_term),\n                 1: self._integrator(common_term),\n            }\n            J_vals = {\n                -1: self._integrator(self.z**(-2) * common_term * log_term),\n                 0: self._integrator(self.z**(-1) * common_term * log_term),\n                 1: self._integrator(common_term * log_term),\n            }\n            return K_vals, J_vals\n        \n        def calculate_observables_and_chi2(self, a, b, gamma_s):\n            \"\"\"Calculates observables and the chi-squared value.\"\"\"\n            # K integrals are sufficient for the chi-squared value\n            K_pi_integrals, _ = self._compute_integral_family(a, b, self.mt2_pi)\n            K_k_integrals, _ = self._compute_integral_family(a, b, self.mt2_k)\n\n            K_pi_neg1, K_pi_0, K_pi_1 = K_pi_integrals[-1], K_pi_integrals[0], K_pi_integrals[1]\n            K_k_0 = K_k_integrals[0]\n\n            # Observables\n            O_M = self.C_mult * K_pi_neg1 / K_pi_0\n            O_z = K_pi_1 / K_pi_0\n            \n            Y_pi = K_pi_0\n            Y_k = gamma_s * K_k_0\n            O_Kpi = Y_k / (Y_pi + Y_k)\n            \n            observables = {'M': O_M, 'z': O_z, 'Kpi': O_Kpi}\n\n            # Chi-squared\n            chi2 = ((observables['M'] - self.obs_vals['M']) / self.sigmas['M'])**2\n            chi2 += ((observables['z'] - self.obs_vals['z']) / self.sigmas['z'])**2\n            chi2 += ((observables['Kpi'] - self.obs_vals['Kpi']) / self.sigmas['Kpi'])**2\n            \n            return observables, chi2\n\n        def get_analytic_gradient(self, a, b, gamma_s):\n            \"\"\"Computes the analytical gradient of chi-squared w.r.t. a.\"\"\"\n            # 1. Compute all K and J integrals\n            K_pi, J_pi = self._compute_integral_family(a, b, self.mt2_pi)\n            K_k, J_k = self._compute_integral_family(a, b, self.mt2_k)\n            \n            K_pi_neg1, K_pi_0, K_pi_1 = K_pi[-1], K_pi[0], K_pi[1]\n            J_pi_neg1, J_pi_0, J_pi_1 = J_pi[-1], J_pi[0], J_pi[1]\n            K_k_0, J_k_0 = K_k[0], J_k[0]\n\n            # 2. Compute observables (re-used for chi2 term)\n            observables, _ = self.calculate_observables_and_chi2(a, b, gamma_s)\n\n            # 3. Compute observable derivatives\n            dO_M_da = self.C_mult * (J_pi_neg1 * K_pi_0 - K_pi_neg1 * J_pi_0) / (K_pi_0**2)\n            dO_z_da = (J_pi_1 * K_pi_0 - K_pi_1 * J_pi_0) / (K_pi_0**2)\n            \n            dO_Kpi_da_num = gamma_s * (J_k_0 * K_pi_0 - K_k_0 * J_pi_0)\n            dO_Kpi_da_den = (K_pi_0 + gamma_s * K_k_0)**2\n            dO_Kpi_da = dO_Kpi_da_num / dO_Kpi_da_den\n            \n            # 4. Assemble full gradient using chain rule\n            dchi2_da = 0\n            dchi2_da += 2 * (observables['M'] - self.obs_vals['M']) / self.sigmas['M']**2 * dO_M_da\n            dchi2_da += 2 * (observables['z'] - self.obs_vals['z']) / self.sigmas['z']**2 * dO_z_da\n            dchi2_da += 2 * (observables['Kpi'] - self.obs_vals['Kpi']) / self.sigmas['Kpi']**2 * dO_Kpi_da\n            \n            return dchi2_da\n\n        def get_fd_gradient(self, a, b, gamma_s, delta):\n            \"\"\"Computes the finite-difference gradient of chi-squared w.r.t. a.\"\"\"\n            _, chi2_plus = self.calculate_observables_and_chi2(a + delta, b, gamma_s)\n            _, chi2_minus = self.calculate_observables_and_chi2(a - delta, b, gamma_s)\n            return (chi2_plus - chi2_minus) / (2 * delta)\n\n    #\n    # --- Main Execution Logic ---\n    #\n    \n    # 1. Setup integration grid\n    z_grid = np.linspace(Z_MIN, Z_MAX, N_POINTS)\n    \n    # 2. Calibrate C_mult at the reference point\n    one_minus_z_ref = 1 - z_grid\n    common_term_ref = (one_minus_z_ref)**A_REF * np.exp(-B_REF * MT2_PI / z_grid)\n    K_pi_0_ref = np.trapz(z_grid**(-1) * common_term_ref, z_grid)\n    K_pi_neg1_ref = np.trapz(z_grid**(-2) * common_term_ref, z_grid)\n    C_mult = OBS_M * K_pi_0_ref / K_pi_neg1_ref\n    \n    # 3. Instantiate model with calibrated constant\n    model = LundSurrogate(z_grid, MT2_PI, MT2_K, C_mult)\n\n    # 4. Define test suite\n    test_cases = [\n        (0.3, 0.58, 0.3),\n        (1.2, 0.58, 0.3),\n        (0.1, 0.30, 0.2),\n        (0.5, 0.90, 0.35),\n    ]\n\n    results = []\n    for a, b, gamma_s in test_cases:\n        # a) Compute analytical gradient\n        grad_analytic = model.get_analytic_gradient(a, b, gamma_s)\n        \n        # b) Compute finite difference gradient for comparison\n        grad_fd = model.get_fd_gradient(a, b, gamma_s, DELTA_A)\n        \n        # c) Calculate relative discrepancy\n        numerator = np.abs(grad_analytic - grad_fd)\n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_err = numerator / denominator\n        results.append(rel_err)\n\n    # 5. Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}