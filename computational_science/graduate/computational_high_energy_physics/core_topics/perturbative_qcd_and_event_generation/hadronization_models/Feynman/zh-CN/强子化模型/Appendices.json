{
    "hands_on_practices": [
        {
            "introduction": "理论只有通过实践才能得到最深刻的理解。让我们从一个基础练习开始，模拟强子化过程的核心机制。此练习将带您手动追踪夸克在弦碎裂过程中的流动，并计算产生特定强子序列的概率。通过这种方式，您将具体地应用到诸如味抑制和自旋统计等基本规则，从而对弦模型的工作原理建立起直观的认识。",
            "id": "3516046",
            "problem": "在量子色动力学（QCD）中，一个色弦连接着一个初始的左端夸克 $u$ 和一个初始的右端反夸克 $\\bar{u}$。在一个简化的弦强子化模型中，该弦经历恰好两次断裂，每次断裂产生一个夸克-反夸克对 $q\\bar{q}$ 或一个双夸克-反双夸克对 $(qq)(\\overline{qq})$。强子从左端顺序形成，其规则是，在每一步中，当前的左端夸克与新产生的反夸克结合形成一个介子；新产生的夸克则成为下一步的左端点。经过两次断裂后，形成三个介子：第一个使用初始的 $u$ 夸克，第二个使用第一次断裂后剩下的夸克，第三个使用第二次断裂后剩下的夸克与原始的右端反夸克 $\\bar{u}$ 结合。\n\n假设使用以下经过充分检验的模型要素：\n- 在每次断裂时，产生夸克-反夸克对而非双夸克-反双夸克对的概率是 $P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$，其中 $\\lambda_{qq}$ 是双夸克抑制因子。对于本问题，取 $\\lambda_{qq} = 0.07$。\n- 在产生夸克-反夸克对的条件下，味权重对于 $u$ 和 $d$ 是同位旋对称的，对于 $s$ 则是奇异数抑制的，权重分别为 $w(u) = 1$，$w(d) = 1$ 和 $w(s) = \\gamma_{s}$，通过 $Z = w(u)+w(d)+w(s) = 2 + \\gamma_{s}$ 进行归一化。对于本问题，取 $\\gamma_{s} = 0.32$。因此，在一次断裂中选择不同味的概率为 $P(u\\bar{u}\\mid q\\bar{q}) = \\frac{1}{Z}$，$P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{Z}$ 和 $P(s\\bar{s}\\mid q\\bar{q}) = \\frac{\\gamma_{s}}{Z}$。\n- 对于介子的量子数，假设对于给定的味组分 $q\\bar{q}'$，模型会在一个赝标量态（用 $P$ 表示）和一个矢量态（用 $V$ 表示）之间进行选择，其通用的矢量-赝标量比为 $r_{V/P}$。相应的概率为 $p_{V} = \\frac{r_{V/P}}{1+r_{V/P}}$ 和 $p_{P} = \\frac{1}{1+r_{V/P}}$。对于本问题，取 $r_{V/P} = 0.6$，所以 $p_{V} = \\frac{0.6}{1.6}$ 且 $p_{P} = \\frac{1}{1.6}$。\n- 忽略中性味混合效应以及上述概率之外的任何额外动力学质量或相空间权重。\n\n对于相关的味对，可用的介子种类如下：\n- 对于 $u\\bar{d}$：$\\pi^{+}$（赝标量），$\\rho^{+}$（矢量）。\n- 对于 $d\\bar{u}$：$\\pi^{-}$（赝标量），$\\rho^{-}$（矢量）。\n- 对于 $u\\bar{s}$：$K^{+}$（赝标量），$K^{*+}$（矢量）。\n- 对于 $d\\bar{s}$：$K^{0}$（赝标量），$K^{*0}$（矢量）。\n- 对于 $s\\bar{u}$：$K^{-}$（赝标量），$K^{*-}$（矢量）。\n- 对于 $s\\bar{d}$：$\\bar{K}^{0}$（赝标量），$\\bar{K}^{*0}$（矢量）。\n\n考虑有序的强子序列\n$$\nK^{+},\\ \\bar{K}^{0},\\ \\rho^{-},\n$$\n该序列是通过从 $u$–$\\bar{u}$ 端点开始的弦经过两次断裂，并使用上述从左到右顺序形成规则而产生的。在指定的模型和参数下，并强制要求总味和电荷守恒，计算产生这个确切有序序列的概率。将您的答案表示为一个无量纲数，并四舍五入到六位有效数字。",
            "solution": "用户要求我解决一个计算性高能物理问题。\n\n### 第一步：提取已知条件\n-   初始弦端点：左端夸克 $u$，右端反夸克 $\\bar{u}$。\n-   弦断裂次数：恰好 $2$ 次。\n-   强子形成规则：从左端顺序形成；左端夸克与新产生的反夸克结合形成一个介子；新产生的夸克成为下一个左端点。\n-   形成的总介子数：$3$。\n-   双夸克抑制因子：$\\lambda_{qq} = 0.07$。\n-   夸克-反夸克对产生概率：$P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$。\n-   奇异数抑制因子：$\\gamma_{s} = 0.32$。\n-   味归一化因子：$Z = 2 + \\gamma_{s}$。\n-   味选择概率：$P(u\\bar{u}\\mid q\\bar{q}) = \\frac{1}{Z}$，$P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{Z}$，$P(s\\bar{s}\\mid q\\bar{q}) = \\frac{\\gamma_{s}}{Z}$。\n-   矢量-赝标量比：$r_{V/P} = 0.6$。\n-   矢量和赝标量形成概率：$p_{V} = \\frac{r_{V/P}}{1+r_{V/P}} = \\frac{0.6}{1.6}$，$p_{P} = \\frac{1}{1+r_{V/P}} = \\frac{1}{1.6}$。\n-   已提供相关味对的可用介子种类。\n-   目标有序强子序列：$K^{+},\\ \\bar{K}^{0},\\ \\rho^{-}$。\n-   约束条件：强制要求总味和电荷守恒。\n-   最终答案格式：无量纲数，四舍五入到六位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了一个简化的 Lund 弦碎裂模型，这是高能物理中强子化建模的基石。所有概念，如弦断裂、味抑制（$\\gamma_s$）、双夸克抑制（$\\lambda_{qq}$）和自旋态概率（$r_{V/P}$），都是该领域的标准和成熟概念。参数值在唯象上是现实的。该问题是这些原理的有效应用。\n-   **问题定义明确**：问题提供了计算特定概率所需的所有参数和规则。问题是明确的。我们可以追踪夸克流并验证其一致性。\n    -   初始态：$u\\bar{u}$。净味为零，净电荷为 $Q(u)+Q(\\bar{u}) = \\frac{2}{3} - \\frac{2}{3} = 0$。\n    -   末态：$K^{+}(u\\bar{s})$，$\\bar{K}^{0}(s\\bar{d})$，$\\rho^{-}(d\\bar{u})$。\n    -   味守恒：末态的夸克组分为 $(u\\bar{s}) + (s\\bar{d}) + (d\\bar{u})$。将夸克和反夸克相加得到 $(u+\\bar{u})+(s+\\bar{s})+(d+\\bar{d})$，这意味着净味为零，与初始态一致。\n    -   电荷守恒：末态的总电荷为 $Q(K^{+}) + Q(\\bar{K}^{0}) + Q(\\rho^{-}) = (+1) + (0) + (-1) = 0$，与初始态一致。\n-   **客观性**：问题以精确、定量的术语陈述，没有主观语言。\n-   该问题没有被任何列出的无效性标准所影响。它是一个基于已建立的科学模型的完整、一致且可解的问题。\n\n### 第三步：结论与行动\n该问题是有效的。将提供一个解决方案。\n\n该问题要求计算从初始 $u\\bar{u}$ 弦通过两次断裂产生特定有序强子序列 $K^{+},\\ \\bar{K}^{0},\\ \\rho^{-}$ 的概率。我们必须根据指定的模型规则，计算产生此末态所需事件序列的概率。总概率 $P_{total}$ 将是序列中每一步概率的乘积。\n\n强子化过程可以分解如下：\n初始弦：$u_{L} \\cdots \\bar{u}_{R}$\n\n**步骤 1：形成第一个介子, $M_1 = K^{+}$**\n-   第一个介子 $K^{+}$ 的夸克组分是 $u\\bar{s}$。\n-   它由初始的左端夸克 $u$ 和第一次弦断裂中产生的反夸克形成。这个反夸克必须是 $\\bar{s}$。\n-   因此，第一次弦断裂必须产生一个 $s\\bar{s}$ 对。新产生的夸克 $s$ 成为下一步的新左端点。\n-   这次断裂的概率有两个组成部分：\n    1.  断裂必须产生夸克-反夸克对（$q\\bar{q}$）而不是双夸克-反双夸克对。概率为 $P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$。\n    2.  给定一次 $q\\bar{q}$ 断裂，产生的味必须是 $s\\bar{s}$。概率为 $P(s\\bar{s}\\mid q\\bar{q}) = \\frac{\\gamma_{s}}{Z} = \\frac{\\gamma_{s}}{2+\\gamma_{s}}$。\n-   第一次断裂类型为 $s\\bar{s}$ 的概率是 $P_{\\text{break 1}} = P(q\\bar{q}) \\times P(s\\bar{s}\\mid q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}}$。\n-   产生的 $u\\bar{s}$ 对必须形成一个 $K^{+}$ 介子，它是一个赝标量态（$P$）。另一种可能是矢量介子 $K^{*+}$。形成赝标量的概率是 $p_P = \\frac{1}{1+r_{V/P}}$。\n\n第一个强子是 $K^{+}$ 的总概率是 $P_1 = P_{\\text{break 1}} \\times p_P = \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}}$。\n\n**步骤 2：形成第二个介子, $M_2 = \\bar{K}^{0}$**\n-   第一次断裂后，传播的左端夸克是 $s$。\n-   第二个介子 $\\bar{K}^{0}$ 的夸克组分是 $s\\bar{d}$。它必须由当前的左端夸克 $s$ 和第二次断裂产生的反夸克形成。这个反夸克必须是 $\\bar{d}$。\n-   因此，第二次弦断裂必须产生一个 $d\\bar{d}$ 对。新产生的夸克 $d$ 成为最终的左端夸克。\n-   这次断裂的概率计算方法与第一次类似：\n    1.  断裂必须是 $q\\bar{q}$ 类型：$P(q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}}$。\n    2.  味必须是 $d\\bar{d}$：$P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{Z} = \\frac{1}{2+\\gamma_{s}}$。\n-   第二次断裂类型为 $d\\bar{d}$ 的概率是 $P_{\\text{break 2}} = P(q\\bar{q}) \\times P(d\\bar{d}\\mid q\\bar{q}) = \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}}$。\n-   产生的 $s\\bar{d}$ 对必须形成一个 $\\bar{K}^{0}$ 介子，它是一个赝标量态（$P$）。另一种可能是矢量介子 $\\bar{K}^{*0}$。概率是 $p_P = \\frac{1}{1+r_{V/P}}$。\n\n第二个强子是 $\\bar{K}^{0}$ 的总概率是 $P_2 = P_{\\text{break 2}} \\times p_P = \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}}$。\n\n**步骤 3：形成第三个介子, $M_3 = \\rho^{-}$**\n-   第二次断裂后，最终的左端夸克是 $d$。\n-   这个 $d$ 夸克与原始的右端反夸克 $\\bar{u}$ 结合，形成第三个也是最后一个介子。\n-   该介子的夸克组分为 $d\\bar{u}$。问题指出这个介子是 $\\rho^{-}$。\n-   $\\rho^{-}$ 是一个矢量介子（$V$）。另一种可能是赝标量介子 $\\pi^{-}$。形成矢量介子的概率是 $p_V = \\frac{r_{V/P}}{1+r_{V/P}}$。这一步不涉及新的弦断裂。\n\n第三个强子是 $\\rho^{-}$ 的概率是 $P_3 = p_V = \\frac{r_{V/P}}{1+r_{V/P}}$。\n\n**总概率**\n有序序列 $K^{+},\\ \\bar{K}^{0},\\ \\rho^{-}$ 的总概率 $P_{total}$ 是每一步独立概率的乘积：\n$$P_{total} = P_1 \\times P_2 \\times P_3$$\n$$P_{total} = \\left( \\frac{1}{1+\\lambda_{qq}} \\frac{\\gamma_{s}}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}} \\right) \\times \\left( \\frac{1}{1+\\lambda_{qq}} \\frac{1}{2+\\gamma_{s}} \\frac{1}{1+r_{V/P}} \\right) \\times \\left( \\frac{r_{V/P}}{1+r_{V/P}} \\right)$$\n合并各项，我们得到：\n$$P_{total} = \\frac{\\gamma_{s} r_{V/P}}{(1+\\lambda_{qq})^2 (2+\\gamma_{s})^2 (1+r_{V/P})^3}$$\n现在，我们代入给定的数值：$\\lambda_{qq} = 0.07$，$\\gamma_{s} = 0.32$ 和 $r_{V/P} = 0.6$。\n-   $1 + \\lambda_{qq} = 1 + 0.07 = 1.07$\n-   $2 + \\gamma_{s} = 2 + 0.32 = 2.32$\n-   $1 + r_{V/P} = 1 + 0.6 = 1.6$\n\n将这些值代入 $P_{total}$ 的表达式：\n$$P_{total} = \\frac{(0.32) (0.6)}{(1.07)^2 (2.32)^2 (1.6)^3}$$\n$$P_{total} = \\frac{0.192}{(1.1449) (5.3824) (4.096)}$$\n$$P_{total} = \\frac{0.192}{6.16246976 \\times 4.096}$$\n$$P_{total} = \\frac{0.192}{25.23891404...}$$\n$$P_{total} \\approx 0.0076072979$$\n问题要求答案四舍五入到六位有效数字。\n$$P_{total} \\approx 0.00760730$$\n这可以用科学记数法写成 $7.60730 \\times 10^{-3}$。",
            "answer": "$$\\boxed{0.00760730}$$"
        },
        {
            "introduction": "在理解了单次碎裂事件的微观规则之后，我们现在转向模型的整体统计特性。我们将弦的断裂看作是在弦世界面上的一个随机过程，这很自然地引出了泊松过程模型。本练习旨在建立理论模型与实验数据之间的桥梁，您将学习如何基于物理模型构建似然函数，并利用模拟的“实验”数据（如强子多重性和横动量）来估计模型的基本参数，这是现象学研究中的一项核心技能。",
            "id": "3516073",
            "problem": "考虑一个量子色动力学（QCD）中强子化的简化计算模型，其中色流管被近似为一根相对论性弦。这根弦可以通过夸克-反夸克对的产生而断裂，断裂点将弦分割成多个强子。假设一个随机性描述，其中断裂事件在弦世界面上作为均匀泊松过程发生，其单位面积的速率为常数。具体来说，设世界面面积为 $A$（单位为 $\\mathrm{fm}^2$），单位面积的断裂速率为 $\\lambda$（单位为 $\\mathrm{fm}^{-2}$）。一次事件中观测到的强子多重数为 $n \\in \\mathbb{N}_0$，解释为在面积 $A$ 内发生的断裂事件的数量。此外，将产生的强子的横向动量大小 $p_T$（单位为 $\\mathrm{GeV}$）建模为由独立的横向动量分量产生，每个分量都服从均值为零、共同方差为 $\\sigma^2$ 的高斯分布。对于大小 $p_T$ 而言，这意味着一个由 $\\sigma$ 参数化的瑞利分布。为了将断裂速率与横向动力学联系起来，假设一个经验正比关系 $\\sigma^2 = c \\lambda$，其中 $c$ 是一个已知常数（单位为 $\\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$），这反映了单位面积上更高的断裂密度会产生更大的横向动量方差。\n\n你的任务是：\n1. 从面积上的均匀泊松过程的公理以及不相交区域的独立性出发，从第一性原理推导在面积 $A$ 内发生 $n$ 次断裂事件的概率质量函数 $P(n \\mid \\lambda, A)$。\n2. 使用上述假设，为由逐事件对 $(A_i, n_i)$ 和一组相关的横向动量大小 $\\{p_{T,j}\\}$ 组成的数据构建联合似然，所有数据在给定 $\\lambda$ 的条件下都是条件独立的。从泊松过程和瑞利分布的定义出发，通过关于 $\\lambda > 0$ 最大化联合似然来推导估计量 $\\hat{\\lambda}$。\n3. 实现一个程序，在给定以下参数值和观测数据的测试套件的情况下，计算每种情况下的最大似然估计 $\\hat{\\lambda}$ 并打印结果。\n\n在所有测试用例中，使用以下常数：$c = 0.25$，单位为 $\\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$。对于每种情况，$A$ 值为 $\\mathrm{fm}^2$，$n$ 值为计数（无单位），$p_T$ 值为 $\\mathrm{GeV}$。将最终估计的断裂速率 $\\hat{\\lambda}$ 以 $\\mathrm{fm}^{-2}$ 表示，并四舍五入到六位小数。\n\n测试套件：\n情况1（包含多重数和横向动量数据的通用情况）：\n- $A$ 值：$[2.0, 1.5, 3.0]$，单位 $\\mathrm{fm}^2$。\n- $n$ 值：$[2, 1, 3]$。\n- $p_T$ 样本：$[0.45, 0.62, 0.38, 0.77, 0.31, 0.55, 0.49, 0.70, 0.29, 0.58]$，单位 $\\mathrm{GeV}$。\n\n情况2（没有横向动量样本的边界情况）：\n- $A$ 值：$[1.0, 1.0, 1.0, 1.0]$，单位 $\\mathrm{fm}^2$。\n- $n$ 值：$[1, 1, 2, 0]$。\n- $p_T$ 样本：$[]$（空列表）。\n\n情况3（具有更大面积、更高多重数以及横向动量数据的情况）：\n- $A$ 值：$[5.0, 4.0]$，单位 $\\mathrm{fm}^2$。\n- $n$ 值：$[7, 6]$。\n- $p_T$ 样本：$[0.60, 0.80, 0.47, 0.51, 0.72, 0.66, 0.43, 0.58, 0.75, 0.49, 0.69, 0.55]$，单位 $\\mathrm{GeV}$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[0.123456,0.654321,1.000000]$）。该列表必须按顺序包含与情况1、情况2和情况3相对应的三个 $\\hat{\\lambda}$ 值。\n\n所有涉及物理量的答案都必须以指定的单位给出。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它在一个简化的、但有物理动机的强子化唯象模型中，提出了一个标准的统计估计任务。所有必需的数据和常数都已提供。\n\n根据要求，解答分为三个部分：泊松概率质量函数（PMF）的推导，断裂速率 $\\lambda$ 的最大似然估计量的推导，以及针对给定测试用例对此估计量的实现。\n\n### 第1部分：泊松概率质量函数（PMF）的推导\n\n我们推导在面积为 $A$ 的世界面中，由单位面积速率为 $\\lambda$ 的均匀泊松过程所支配的断裂事件数 $n$ 的PMF。我们从第一性原理开始，基于该过程在无穷小面积 $\\Delta A$ 上的行为。\n\n该过程的公理是：\n1. 在一个很小面积 $\\Delta A$ 内恰好发生一次事件的概率与该面积成正比：$P(n=1 \\text{ in } \\Delta A) = \\lambda \\Delta A + o(\\Delta A)$，其中 $o(\\Delta A)$ 表示比 $\\Delta A$ 更快趋于零的项。\n2. 在 $\\Delta A$ 内发生一次以上事件的概率是可忽略的：$P(n \\ge 2 \\text{ in } \\Delta A) = o(\\Delta A)$。\n3. 由上可知，在 $\\Delta A$ 内不发生事件的概率是 $P(n=0 \\text{ in } \\Delta A) = 1 - \\lambda \\Delta A - o(\\Delta A)$。\n4. 在不相交区域内发生的事件数是独立的随机变量。\n\n设 $P_n(A)$ 是在面积 $A$ 内观测到恰好 $n$ 次事件的概率。我们考虑在稍大的面积 $A + \\Delta A$ 内发生 $n$ 次事件的概率。利用独立性公理，我们可以通过考虑以下互斥的发生方式来写出 $P_n(A+\\Delta A)$：\n- 在面积 $A$ 内发生 $n$ 次事件，在面积 $\\Delta A$ 内发生 $0$ 次事件。其概率为 $P_n(A) P_0(\\Delta A) = P_n(A)(1 - \\lambda \\Delta A + o(\\Delta A))$。\n- 在面积 $A$ 内发生 $n-1$ 次事件，在面积 $\\Delta A$ 内发生 $1$ 次事件。其概率为 $P_{n-1}(A) P_1(\\Delta A) = P_{n-1}(A)(\\lambda \\Delta A + o(\\Delta A))$。\n- 任何其他组合都涉及在 $\\Delta A$ 内至少发生两次事件，其概率为 $o(\\Delta A)$ 阶。\n\n将这些概率相加，我们得到：\n$$P_n(A+\\Delta A) = P_n(A)(1 - \\lambda \\Delta A) + P_{n-1}(A)(\\lambda \\Delta A) + o(\\Delta A)$$\n重新整理这些项，得到：\n$$\\frac{P_n(A+\\Delta A) - P_n(A)}{\\Delta A} = \\lambda (P_{n-1}(A) - P_n(A)) + \\frac{o(\\Delta A)}{\\Delta A}$$\n当 $\\Delta A \\to 0$ 时取极限，我们得到一个常微分-差分方程组：\n$$\\frac{d P_n(A)}{d A} = \\lambda (P_{n-1}(A) - P_n(A)) \\quad \\text{for } n \\ge 1$$\n对于 $n=0$ 的情况，没有 $P_{-1}(A)$ 项，因此方程变为：\n$$\\frac{d P_0(A)}{d A} = -\\lambda P_0(A)$$\n初始条件是在零面积内发生零次事件，所以 $P_0(0) = 1$。这个一阶常微分方程的解是：\n$$P_0(A) = e^{-\\lambda A}$$\n现在，我们可以求解 $n=1$ 的情况：\n$$\\frac{d P_1(A)}{d A} = \\lambda (P_0(A) - P_1(A)) = \\lambda(e^{-\\lambda A} - P_1(A))$$\n在初始条件 $P_1(0)=0$ 下，这个线性一阶常微分方程的解为：\n$$P_1(A) = (\\lambda A) e^{-\\lambda A}$$\n通过数学归纳法，我们可以证明对于任何 $n \\in \\mathbb{N}_0$ 的通解是：\n$$P(n \\mid \\lambda, A) \\equiv P_n(A) = \\frac{(\\lambda A)^n e^{-\\lambda A}}{n!}$$\n这就是均值为 $\\lambda A$ 的泊松分布的概率质量函数。\n\n### 第2部分：最大似然估计量（MLE）的推导\n\n我们被给予两种类型的数据，在给定 $\\lambda$ 的条件下它们是条件独立的：\n1. 一组包含 $M$ 个事件多重数观测值 $\\{(A_i, n_i)\\}_{i=1}^M$。\n2. 一组包含 $N$ 个横向动量大小样本 $\\{p_{T,j}\\}_{j=1}^N$。\n\n联合似然函数 $L(\\lambda)$ 是所有单个观测值概率的乘积。\n\n来自多重数数据的似然 $L_n(\\lambda)$ 是泊松概率的乘积：\n$$L_n(\\lambda) = \\prod_{i=1}^M P(n_i \\mid \\lambda, A_i) = \\prod_{i=1}^M \\frac{(\\lambda A_i)^{n_i} e^{-\\lambda A_i}}{n_i!}$$\n来自横向动量数据的似然 $L_{p_T}(\\lambda)$ 是瑞利概率密度的乘积。参数为 $\\sigma$ 的瑞利分布变量 $x$ 的概率密度函数（PDF）是 $f(x; \\sigma) = \\frac{x}{\\sigma^2} e^{-x^2/(2\\sigma^2)}$。根据给定的关系 $\\sigma^2 = c\\lambda$，单个 $p_{T,j}$ 测量的PDF为：\n$$f(p_{T,j} \\mid \\lambda) = \\frac{p_{T,j}}{c\\lambda} e^{-p_{T,j}^2/(2c\\lambda)}$$\n所有 $p_T$ 数据的似然为：\n$$L_{p_T}(\\lambda) = \\prod_{j=1}^N f(p_{T,j} \\mid \\lambda) = \\prod_{j=1}^N \\frac{p_{T,j}}{c\\lambda} e^{-p_{T,j}^2/(2c\\lambda)}$$\n总似然为 $L(\\lambda) = L_n(\\lambda) \\cdot L_{p_T}(\\lambda)$。处理对数似然 $\\mathcal{L}(\\lambda) = \\ln(L(\\lambda))$ 更为方便。在最大化过程中，不依赖于 $\\lambda$ 的项可以忽略。\n$$\\mathcal{L}(\\lambda) = \\ln(L_n(\\lambda)) + \\ln(L_{p_T}(\\lambda))$$\n$$\\mathcal{L}(\\lambda) = \\sum_{i=1}^M (n_i \\ln(\\lambda A_i) - \\lambda A_i) + \\sum_{j=1}^N (-\\ln(c\\lambda) - \\frac{p_{T,j}^2}{2c\\lambda}) + \\text{const}$$\n展开对数并根据 $\\lambda$ 对各项进行分组：\n$$\\mathcal{L}(\\lambda) = \\sum_{i=1}^M (n_i \\ln\\lambda + n_i\\ln A_i - \\lambda A_i) + \\sum_{j=1}^N (-\\ln c - \\ln\\lambda - \\frac{p_{T,j}^2}{2c\\lambda}) + \\text{const}$$\n$$\\mathcal{L}(\\lambda) = \\ln\\lambda \\left(\\sum_{i=1}^M n_i\\right) - \\lambda \\left(\\sum_{i=1}^M A_i\\right) - \\ln\\lambda \\left(\\sum_{j=1}^N 1\\right) - \\frac{1}{\\lambda} \\left(\\frac{1}{2c}\\sum_{j=1}^N p_{T,j}^2\\right) + \\text{const}$$\n让我们引入汇总统计量：$N_{tot} = \\sum_{i=1}^M n_i$, $A_{tot} = \\sum_{i=1}^M A_i$, 以及 $S_{p_T^2} = \\sum_{j=1}^N p_{T,j}^2$。$p_T$ 样本的数量为 $N$。\n$$\\mathcal{L}(\\lambda) = (N_{tot} - N)\\ln\\lambda - A_{tot}\\lambda - \\frac{S_{p_T^2}}{2c\\lambda} + \\text{const}$$\n为了找到最大值，我们对 $\\lambda$ 求导并将结果设为零：\n$$\\frac{d\\mathcal{L}}{d\\lambda} = \\frac{N_{tot} - N}{\\lambda} - A_{tot} + \\frac{S_{p_T^2}}{2c\\lambda^2} = 0$$\n假设 $\\lambda > 0$，我们两边乘以 $\\lambda^2$：\n$$(N_{tot} - N)\\lambda - A_{tot}\\lambda^2 + \\frac{S_{p_T^2}}{2c} = 0$$\n这是一个关于 $\\lambda$ 的二次方程：\n$$A_{tot}\\lambda^2 - (N_{tot} - N)\\lambda - \\frac{S_{p_T^2}}{2c} = 0$$\n使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2-4ac_{quad}}}{2a}$，其中 $a = A_{tot}$, $b = -(N_{tot} - N)$, 且 $c_{quad} = -\\frac{S_{p_T^2}}{2c}$：\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) \\pm \\sqrt{(-(N_{tot} - N))^2 - 4(A_{tot})(-\\frac{S_{p_T^2}}{2c})}}{2A_{tot}}$$\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) \\pm \\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} S_{p_T^2}}{c}}}{2A_{tot}}$$\n由于 $\\lambda$ 必须是一个正的速率，我们必须选择能产生正值的根。平方根下的项 $\\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} S_{p_T^2}}{c}}$ 严格大于 $|N_{tot}-N|$（只要 $A_{tot}>0$ 且 $S_{p_T^2}>0$）。因此，减号会产生一个负的 $\\hat{\\lambda}$。我们必须取加号。\n最终的估计量是：\n$$\\hat{\\lambda} = \\frac{(N_{tot} - N) + \\sqrt{(N_{tot} - N)^2 + \\frac{2 A_{tot} \\sum_{j=1}^N p_{T,j}^2}{c}}}{2 \\sum_{i=1}^M A_i}$$\n该公式在 $A_{tot} = \\sum A_i > 0$ 的条件下有效。\n\n### 第3部分：实现与测试用例计算\n\n使用推导出的 $\\hat{\\lambda}$ 公式和常数 $c=0.25 \\, \\mathrm{fm}^2 \\cdot \\mathrm{GeV}^2$ 来计算三个测试用例的估计值。\n\n**情况1：**\n- $A = [2.0, 1.5, 3.0]$\n- $n = [2, 1, 3]$\n- $p_T$ 样本：提供了10个值。\n- 汇总统计量：$A_{tot} = 6.5$, $N_{tot} = 6$, $N=10$, $S_{p_T^2} = \\sum p_{T,j}^2 \\approx 2.8734$。\n- $\\hat{\\lambda}_1 = \\frac{(6-10) + \\sqrt{(6-10)^2 + \\frac{2 \\cdot 6.5 \\cdot 2.8734}{0.25}}}{2 \\cdot 6.5} = \\frac{-4 + \\sqrt{16 + 149.4168}}{13} \\approx 0.681650 \\, \\mathrm{fm}^{-2}$。\n\n**情况2：**\n- $A = [1.0, 1.0, 1.0, 1.0]$\n- $n = [1, 1, 2, 0]$\n- $p_T$ 样本：空列表。\n- 汇总统计量：$A_{tot} = 4.0$, $N_{tot} = 4$, $N=0$, $S_{p_T^2} = 0$。\n- 在这种情况下，公式简化为标准的泊松 MLE：$\\hat{\\lambda}_2 = \\frac{N_{tot}}{A_{tot}} = \\frac{4}{4.0} = 1.000000 \\, \\mathrm{fm}^{-2}$。\n\n**情况3：**\n- $A = [5.0, 4.0]$\n- $n = [7, 6]$\n- $p_T$ 样本：提供了12个值。\n- 汇总统计量：$A_{tot} = 9.0$, $N_{tot} = 13$, $N=12$, $S_{p_T^2} = \\sum p_{T,j}^2 \\approx 4.5375$。\n- $\\hat{\\lambda}_3 = \\frac{(13-12) + \\sqrt{(13-12)^2 + \\frac{2 \\cdot 9.0 \\cdot 4.5375}{0.25}}}{2 \\cdot 9.0} = \\frac{1 + \\sqrt{1 + 326.7}}{18} \\approx 1.055710 \\, \\mathrm{fm}^{-2}$。\n\n以下代码实现了这些计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum likelihood estimate (MLE) for the string break rate lambda\n    for three different test cases based on a derived formula.\n    \"\"\"\n    C_CONSTANT = 0.25  # fm^2 * GeV^2\n\n    test_cases = [\n        {\n            \"A_vals\": [2.0, 1.5, 3.0],\n            \"n_vals\": [2, 1, 3],\n            \"pT_samples\": [0.45, 0.62, 0.38, 0.77, 0.31, 0.55, 0.49, 0.70, 0.29, 0.58],\n        },\n        {\n            \"A_vals\": [1.0, 1.0, 1.0, 1.0],\n            \"n_vals\": [1, 1, 2, 0],\n            \"pT_samples\": [],\n        },\n        {\n            \"A_vals\": [5.0, 4.0],\n            \"n_vals\": [7, 6],\n            \"pT_samples\": [0.60, 0.80, 0.47, 0.51, 0.72, 0.66, 0.43, 0.58, 0.75, 0.49, 0.69, 0.55],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A_vals = np.array(case[\"A_vals\"])\n        n_vals = np.array(case[\"n_vals\"])\n        pT_samples = np.array(case[\"pT_samples\"])\n\n        # Calculate summary statistics\n        A_tot = np.sum(A_vals)\n        N_tot = np.sum(n_vals)\n        N_pT = len(pT_samples)\n        S_pT_sq = np.sum(pT_samples**2)\n        \n        # Check for A_tot = 0, which would require a different formula (linear eq).\n        # This case is not present in the problem suite but is good practice.\n        if A_tot == 0:\n            # If A_tot is 0, the quadratic term vanishes. Equation becomes linear:\n            # -(N_tot - N) * lambda - S_pT_sq / (2c) = 0\n            # (N - N_tot) * lambda = S_pT_sq / (2c)\n            # lambda = S_pT_sq / (2 * c * (N - N_tot))\n            if N_pT > N_tot:\n                lambda_hat = S_pT_sq / (2 * C_CONSTANT * (N_pT - N_tot))\n            else:\n                # Physically/statistically problematic case, likely indicates no solution or model breakdown.\n                # For this problem, we can assume A_tot > 0 as per the test cases.\n                lambda_hat = np.nan # Or raise an error\n        else:\n            # General formula derived from the quadratic equation for lambda:\n            # A_tot * lambda^2 - (N_tot - N) * lambda - S_pT_sq / (2c) = 0\n            term_under_sqrt = (N_tot - N_pT)**2 + (2 * A_tot * S_pT_sq) / C_CONSTANT\n            \n            numerator = (N_tot - N_pT) + np.sqrt(term_under_sqrt)\n            denominator = 2 * A_tot\n            \n            lambda_hat = numerator / denominator\n\n        results.append(lambda_hat)\n\n    # Format the output as specified, with 6 decimal places.\n    output_str = f\"[{','.join([f'{res:.6f}' for res in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "调整像强子化这样复杂而计算成本高昂的模拟模型是一项重大挑战。现代方法是使用“可微代理模型”（differentiable surrogate models）来解决此问题。本练习将引导您构建一个简化的、可微分的强子化模型，并推导出 $\\chi^2$ 目标函数相对于模型参数的解析梯度。通过完成这项任务，您不仅能掌握现代自动调优框架背后的原理，还能深入了解物理建模、数值优化和软件实现三者之间的相互作用。",
            "id": "3516042",
            "problem": "您的任务是为高能碰撞中的 Lund 弦碎裂构建一个自洽的、可微的代理模型，并用它来计算卡方目标函数关于形状参数的梯度。该代理模型必须在科学上合理，并与强子化中常见的建模实践在内部保持一致。您必须将其实现为一个可运行的程序，该程序能对一系列参数集计算卡方目标函数关于参数 $a$ 的解析梯度，并将其与有限差分估计进行比较。\n\n基本基础和建模假设：\n- 关于光锥动量分数 $z$ 的弦碎裂概率密度由一个类 Lund 表达式建模，该表达式依赖于一个形状参数 $a$、一个单位为平方吉电子伏特倒数的斜率参数 $b$，以及所产生强子的横向质量 $m_{T}$。具体而言，未归一化的、按粒子种类加权的被积函数形式为\n$$\nq(z; a, b, m_T) \\propto z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right),\n$$\n其中 $z \\in [z_{\\min}, z_{\\max}]$，且 $z_{\\min} > 0$ 和 $z_{\\max}  1$ 以确保收敛性和可微性。这与广泛使用的 Lund 对称碎裂形式一致，并在此处用作可微代理模型的基础。\n- 奇异数抑制因子 $\\gamma_s$ ($0  \\gamma_s  1$) 用于乘以奇异强子相对于非奇异强子的产额。\n\n科学和数值细节：\n- 使用 $z_{\\min} = 10^{-4}$ 和 $z_{\\max} = 1 - 10^{-4}$。\n- 使用带电 $\\pi$ 介子质量 $m_{\\pi} = 0.13957\\,\\mathrm{GeV}$ 和带电 $K$ 介子质量 $m_{K} = 0.493677\\,\\mathrm{GeV}$。\n- 使用固定的有效横向动量标度 $p_{T0} = 0.35\\,\\mathrm{GeV}$，并定义横向质量为 $m_{T,\\pi}^2 = m_{\\pi}^2 + p_{T0}^2$ 和 $m_{T,K}^2 = m_{K}^2 + p_{T0}^2$。\n- 参数 $b$ 的单位为 $\\mathrm{GeV}^{-2}$，$a$ 和 $\\gamma_s$ 是无量纲的。\n- 不涉及角度，因此不需要角度单位。\n\n定义以下由代理模型预测的三个观测量：\n1. 一个多重数代理观测量 $O_M(a,b)$，定义为\n$$\nO_M(a,b) = C_{\\mathrm{mult}} \\cdot \\frac{\\int_{z_{\\min}}^{z_{\\max}} \\frac{1}{z} \\, q(z; a, b, m_{T,\\pi}) \\, dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) \\, dz},\n$$\n其中 $C_{\\mathrm{mult}}$ 是一个校准常数，其选择使得在参考参数点 $(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}, \\gamma_{s,\\mathrm{ref}}) = (0.3, 0.58, 0.3)$ 时，预测的 $O_M$ 与观测到的带电粒子多重数 $O_M^{\\mathrm{obs}} = 20.9$（计数）完全匹配。通过将代理模型锚定在 $Z$ 玻色子极点处的一个合理测量值上，这确保了科学真实性。您必须根据此要求，使用在参考点计算的上述积分来计算 $C_{\\mathrm{mult}}$。\n2. 平均动量分数观测量 $O_z(a,b)$，定义为\n$$\nO_z(a,b) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} z \\, q(z; a, b, m_{T,\\pi}) \\, dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) \\, dz}。\n$$\n3. 奇异带电强子与总带电强子之比 $O_{K/\\pi}(a,b,\\gamma_s)$，定义为\n$$\nY_{\\pi}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,\\pi}^2}{z}\\right) dz,\n$$\n$$\nY_{K}(a,b,\\gamma_s) = \\gamma_s \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,K}^2}{z}\\right) dz,\n$$\n$$\nO_{K/\\pi}(a,b,\\gamma_s) = \\frac{Y_{K}(a,b,\\gamma_s)}{Y_{\\pi}(a,b) + Y_{K}(a,b,\\gamma_s)}。\n$$\n\n卡方目标函数的观测值和不确定度：\n- 使用 $O_M^{\\mathrm{obs}} = 20.9$，不确定度为 $\\sigma_M = 0.5$（计数）。\n- 使用 $O_z^{\\mathrm{obs}} = 0.25$，不确定度为 $\\sigma_z = 0.02$（无量纲）。\n- 使用 $O_{K/\\pi}^{\\mathrm{obs}} = 0.13$，不确定度为 $\\sigma_{K/\\pi} = 0.02$（无量纲）。\n\n将卡方目标函数定义为\n$$\n\\chi^2(a,b,\\gamma_s) = \\left(\\frac{O_M(a,b) - O_M^{\\mathrm{obs}}}{\\sigma_M}\\right)^2 + \\left(\\frac{O_z(a,b) - O_z^{\\mathrm{obs}}}{\\sigma_z}\\right)^2 + \\left(\\frac{O_{K/\\pi}(a,b,\\gamma_s) - O_{K/\\pi}^{\\mathrm{obs}}}{\\sigma_{K/\\pi}}\\right)^2。\n$$\n\n您的任务：\n- 基于第一性原理，推导并实现一个 $\\frac{\\partial \\chi^2}{\\partial a}$ 的可微计算。利用形如 $\\int g(z)\\, z^{-1} \\left(1-z\\right)^a \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right) dz$ 的积分对 $a$ 的导数可以表示为 $\\frac{\\partial}{\\partial a}$ 作用于因子 $\\left(1-z\\right)^a$ 上的积分这一事实。您必须推导出所需观测量对 $a$ 的导数表达式，而不依赖于黑箱自动微分。\n- 使用步长为 $\\delta = 10^{-3}$ 的对称差分公式，计算 $\\frac{\\partial \\chi^2}{\\partial a}$ 的有限差分近似：\n$$\n\\left.\\frac{\\partial \\chi^2}{\\partial a}\\right|_{\\mathrm{FD}} \\approx \\frac{\\chi^2(a+\\delta,b,\\gamma_s) - \\chi^2(a-\\delta,b,\\gamma_s)}{2\\delta}。\n$$\n- 对于数值积分，在 $[z_{\\min}, z_{\\max}]$ 上使用一个至少有 $N = 5000$ 个点的均匀 $z$ 网格和一个稳定的求积法则。最终答案是无单位的数值。\n\n测试集：\n为以下四个参数集评估解析梯度和有限差分梯度，这些参数集被选择用于测试一系列行为：\n1. $(a,b,\\gamma_s) = (0.3, 0.58, 0.3)$。\n2. $(a,b,\\gamma_s) = (1.2, 0.58, 0.3)$。\n3. $(a,b,\\gamma_s) = (0.1, 0.30, 0.2)$。\n4. $(a,b,\\gamma_s) = (0.5, 0.90, 0.35)$。\n\n所需输出：\n- 对于每个参数集，计算解析梯度 $\\frac{\\partial \\chi^2}{\\partial a}$ 和有限差分梯度，并报告定义如下的相对差异：\n$$\n\\mathrm{RelErr} = \\frac{\\left|\\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{analytic}} - \\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(\\left|\\left(\\frac{\\partial \\chi^2}{\\partial a}\\right)_{\\mathrm{FD}}\\right|, 10^{-12}\\right)}。\n$$\n- 您的程序应生成单行输出，其中包含四个相对差异，以逗号分隔的列表形式并用方括号括起，顺序与测试集参数集的顺序一致，例如 $\\left[0.0012,0.0345,0.0008,0.0123\\right]$。\n\n所有计算必须使用规定的物理单位：质量以 $\\mathrm{GeV}$ 为单位，$b$ 以 $\\mathrm{GeV}^{-2}$ 为单位，最终输出为无量纲。在整个过程中确保科学真实性和数值稳定性。",
            "solution": "该问题要求构建并验证一个基于 Lund 弦碎裂函数的可微强子化代理模型。主要任务是计算一个 $\\chi^2$ 目标函数关于形状参数 $a$ 的解析梯度，并将其与有限差分近似进行比较。\n\n首先，我们形式化模型的各个组成部分。产生一个横向质量为 $m_T$、光锥动量分数为 $z$ 的强子的未归一化概率密度由下式给出\n$$ q(z; a, b, m_T) \\propto z^{-1} (1-z)^{a} \\exp\\left(-\\frac{b\\, m_T^2}{z}\\right) $$\n其中 $a$ 是一个无量纲的形状参数，$b$ 是一个单位为 $\\mathrm{GeV}^{-2}$ 的斜率参数。为方便推导，我们定义一个在指定范围 $z \\in [z_{\\min}, z_{\\max}]$ 上的通用积分族：\n$$ K_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{n-1} (1-z)^a \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) dz $$\n这里，索引 $h$ 表示强子种类（$\\pi$ 介子或 $K$ 介子），$n$ 决定了被积函数前因子中动量分数 $z$ 的幂次。\n\n三个物理观测量可以用这些积分来表示。$q(z)$ 中的比例常数在定义观测量的比值中被消去。\n\n1.  多重数代理 $O_M(a,b)$ 定义为\n    $$ O_M(a,b) = C_{\\mathrm{mult}} \\frac{\\int_{z_{\\min}}^{z_{\\max}} z^{-1} q(z; a, b, m_{T,\\pi}) dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) dz} = C_{\\mathrm{mult}} \\frac{K_{\\pi}^{(-1)}(a,b)}{K_{\\pi}^{(0)}(a,b)} $$\n    常数 $C_{\\mathrm{mult}}$ 由条件 $O_M(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}) = O_M^{\\mathrm{obs}} = 20.9$ 在参考点 $(a_{\\mathrm{ref}}, b_{\\mathrm{ref}}) = (0.3, 0.58)$ 处确定。这得出：\n    $$ C_{\\mathrm{mult}} = O_M^{\\mathrm{obs}} \\frac{K_{\\pi}^{(0)}(a_{\\mathrm{ref}}, b_{\\mathrm{ref}})}{K_{\\pi}^{(-1)}(a_{\\mathrm{ref}}, b_{\\mathrm{ref}})} $$\n\n2.  平均动量分数 $O_z(a,b)$ 定义为\n    $$ O_z(a,b) = \\frac{\\int_{z_{\\min}}^{z_{\\max}} z \\, q(z; a, b, m_{T,\\pi}) dz}{\\int_{z_{\\min}}^{z_{\\max}} q(z; a, b, m_{T,\\pi}) dz} = \\frac{K_{\\pi}^{(1)}(a,b)}{K_{\\pi}^{(0)}(a,b)} $$\n\n3.  奇异带电强子与总带电强子之比 $O_{K/\\pi}(a,b,\\gamma_s)$ 由积分产额 $Y_\\pi$ 和 $Y_K$ 构建：\n    $$ Y_{\\pi}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,\\pi}^2}{z}\\right) dz = K_{\\pi}^{(0)}(a,b) $$\n    $$ Y_{K}(a,b,\\gamma_s) = \\gamma_s \\int_{z_{\\min}}^{z_{\\max}} z^{-1} \\left(1-z\\right)^{a} \\exp\\left(-\\frac{b\\, m_{T,K}^2}{z}\\right) dz = \\gamma_s K_{K}^{(0)}(a,b) $$\n    因此，观测量为：\n    $$ O_{K/\\pi}(a,b,\\gamma_s) = \\frac{Y_{K}}{Y_{\\pi} + Y_{K}} = \\frac{\\gamma_s K_{K}^{(0)}(a,b)}{K_{\\pi}^{(0)}(a,b) + \\gamma_s K_{K}^{(0)}(a,b)} $$\n\n待最小化的目标函数是 $\\chi^2$：\n$$ \\chi^2(a,b,\\gamma_s) = \\sum_{i \\in \\{M, z, K/\\pi\\}} \\left(\\frac{O_i(a,b,\\gamma_s) - O_i^{\\mathrm{obs}}}{\\sigma_i}\\right)^2 $$\n\n为计算解析梯度 $\\frac{\\partial \\chi^2}{\\partial a}$，我们使用链式法则：\n$$ \\frac{\\partial \\chi^2}{\\partial a} = \\sum_{i \\in \\{M, z, K/\\pi\\}} \\frac{\\partial \\chi^2}{\\partial O_i} \\frac{\\partial O_i}{\\partial a} = \\sum_{i \\in \\{M, z, K/\\pi\\}} 2 \\frac{O_i - O_i^{\\mathrm{obs}}}{\\sigma_i^2} \\frac{\\partial O_i}{\\partial a} $$\n核心任务是求导数 $\\frac{\\partial O_i}{\\partial a}$。这需要对积分 $K_h^{(n)}$ 关于 $a$ 求导。由于积分限不依赖于 $a$，使用莱布尼茨积分法则（在积分号下求导）：\n$$ \\frac{\\partial}{\\partial a} K_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} \\frac{\\partial}{\\partial a} \\left[ z^{n-1} (1-z)^a \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) \\right] dz $$\n由于 $\\frac{\\partial}{\\partial a}(1-z)^a = (1-z)^a \\ln(1-z)$，我们定义第二个积分族 $J_h^{(n)}$：\n$$ J_{h}^{(n)}(a,b) = \\int_{z_{\\min}}^{z_{\\max}} z^{n-1} (1-z)^a \\ln(1-z) \\exp\\left(-\\frac{b m_{T,h}^2}{z}\\right) dz = \\frac{\\partial}{\\partial a} K_{h}^{(n)}(a,b) $$\n\n现在我们可以使用商法则计算观测量的导数：\n$$ \\frac{\\partial O_M}{\\partial a} = C_{\\mathrm{mult}} \\frac{\\partial}{\\partial a}\\left(\\frac{K_{\\pi}^{(-1)}}{K_{\\pi}^{(0)}}\\right) = C_{\\mathrm{mult}} \\frac{J_{\\pi}^{(-1)} K_{\\pi}^{(0)} - K_{\\pi}^{(-1)} J_{\\pi}^{(0)}}{(K_{\\pi}^{(0)})^2} $$\n$$ \\frac{\\partial O_z}{\\partial a} = \\frac{\\partial}{\\partial a}\\left(\\frac{K_{\\pi}^{(1)}}{K_{\\pi}^{(0)}}\\right) = \\frac{J_{\\pi}^{(1)} K_{\\pi}^{(0)} - K_{\\pi}^{(1)} J_{\\pi}^{(0)}}{(K_{\\pi}^{(0)})^2} $$\n$$ \\frac{\\partial O_{K/\\pi}}{\\partial a} = \\frac{\\partial}{\\partial a}\\left(\\frac{\\gamma_s K_{K}^{(0)}}{K_{\\pi}^{(0)} + \\gamma_s K_{K}^{(0)}}\\right) = \\frac{\\gamma_s (J_K^{(0)} K_\\pi^{(0)} - K_K^{(0)} J_\\pi^{(0)})}{(K_\\pi^{(0)} + \\gamma_s K_K^{(0)})^2} $$\n将这些表达式代入 $\\frac{\\partial \\chi^2}{\\partial a}$ 的公式中，即可得到最终的解析梯度。\n\n数值实现过程如下。首先，通过在参考参数下数值计算 $K_{\\pi}^{(0)}$ 和 $K_{\\pi}^{(-1)}$ 来计算常数 $C_{\\mathrm{mult}}$。对于测试集中的每个参数集，我们接着：\n1.  数值计算所有必需的积分：$K_{\\pi}^{(-1)}$, $K_{\\pi}^{(0)}$, $K_{\\pi}^{(1)}$, $K_{K}^{(0)}$ 及其对应的导数形式 $J_{\\pi}^{(-1)}$, $J_{\\pi}^{(0)}$, $J_{\\pi}^{(1)}$, $J_{K}^{(0)}$。按要求使用一个有 $N=5000$ 个点的均匀 $z$ 网格和梯形求积法则。\n2.  计算观测量 $O_M, O_z, O_{K/\\pi}$ 的值。\n3.  计算导数 $\\frac{\\partial O_M}{\\partial a}, \\frac{\\partial O_z}{\\partial a}, \\frac{\\partial O_{K/\\pi}}{\\partial a}$。\n4.  组装完整的解析梯度 $\\frac{\\partial \\chi^2}{\\partial a}$。\n\n为了验证，使用步长 $\\delta=10^{-3}$ 的对称差分公式计算梯度的有限差分近似：\n$$ \\left.\\frac{\\partial \\chi^2}{\\partial a}\\right|_{\\mathrm{FD}} \\approx \\frac{\\chi^2(a+\\delta, b, \\gamma_s) - \\chi^2(a-\\delta, b, \\gamma_s)}{2\\delta} $$\n这需要在扰动参数点 $(a \\pm \\delta, b, \\gamma_s)$ 重新计算 $\\chi^2$ 值，因此也需要重新计算基础的 $K$-积分和观测量。\n\n最后，为每个测试案例计算解析梯度和有限差分梯度之间的相对差异，以验证解析推导和实现的正确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes analytical and finite-difference gradients of a chi-squared\n    objective for a hadronization surrogate model and reports their relative\n    discrepancy for several test cases.\n    \"\"\"\n    #\n    # --- Problem Constants and Setup ---\n    #\n    Z_MIN = 1e-4\n    Z_MAX = 1 - 1e-4\n    N_POINTS = 5000\n    M_PI = 0.13957   # GeV\n    M_K = 0.493677    # GeV\n    P_T0 = 0.35      # GeV\n    MT2_PI = M_PI**2 + P_T0**2\n    MT2_K = M_K**2 + P_T0**2\n    OBS_M = 20.9\n    SIGMA_M = 0.5\n    OBS_Z = 0.25\n    SIGMA_Z = 0.02\n    OBS_KPI = 0.13\n    SIGMA_KPI = 0.02\n    A_REF, B_REF, _ = 0.3, 0.58, 0.3\n    DELTA_A = 1e-3\n\n    #\n    # --- Physics Model and Calculation Class ---\n    #\n    class LundSurrogate:\n        \"\"\"\n        A class to encapsulate the calculations for the Lund surrogate model.\n        \"\"\"\n        def __init__(self, z_grid, mt2_pi, mt2_k, C_mult):\n            self.z = z_grid\n            self.mt2_pi = mt2_pi\n            self.mt2_k = mt2_k\n            self.C_mult = C_mult\n            self.obs_vals = {'M': OBS_M, 'z': OBS_Z, 'Kpi': OBS_KPI}\n            self.sigmas = {'M': SIGMA_M, 'z': SIGMA_Z, 'Kpi': SIGMA_KPI}\n\n        def _integrator(self, integrand):\n            return np.trapz(integrand, self.z)\n\n        def _compute_integral_family(self, a, b, mt2):\n            \"\"\"Computes K and J integrals for a given hadron type.\"\"\"\n            # Base terms of the integrands\n            one_minus_z = 1 - self.z\n            common_term = (one_minus_z)**a * np.exp(-b * mt2 / self.z)\n            log_term = np.log(one_minus_z)\n\n            # Integrals for pions (pi)\n            K_vals = {\n                -1: self._integrator(self.z**(-2) * common_term),\n                 0: self._integrator(self.z**(-1) * common_term),\n                 1: self._integrator(common_term),\n            }\n            J_vals = {\n                -1: self._integrator(self.z**(-2) * common_term * log_term),\n                 0: self._integrator(self.z**(-1) * common_term * log_term),\n                 1: self._integrator(common_term * log_term),\n            }\n            return K_vals, J_vals\n        \n        def calculate_observables_and_chi2(self, a, b, gamma_s):\n            \"\"\"Calculates observables and the chi-squared value.\"\"\"\n            # K integrals are sufficient for the chi-squared value\n            K_pi_integrals, _ = self._compute_integral_family(a, b, self.mt2_pi)\n            K_k_integrals, _ = self._compute_integral_family(a, b, self.mt2_k)\n\n            K_pi_neg1, K_pi_0, K_pi_1 = K_pi_integrals[-1], K_pi_integrals[0], K_pi_integrals[1]\n            K_k_0 = K_k_integrals[0]\n\n            # Observables\n            O_M = self.C_mult * K_pi_neg1 / K_pi_0\n            O_z = K_pi_1 / K_pi_0\n            \n            Y_pi = K_pi_0\n            Y_k = gamma_s * K_k_0\n            O_Kpi = Y_k / (Y_pi + Y_k)\n            \n            observables = {'M': O_M, 'z': O_z, 'Kpi': O_Kpi}\n\n            # Chi-squared\n            chi2 = ((observables['M'] - self.obs_vals['M']) / self.sigmas['M'])**2\n            chi2 += ((observables['z'] - self.obs_vals['z']) / self.sigmas['z'])**2\n            chi2 += ((observables['Kpi'] - self.obs_vals['Kpi']) / self.sigmas['Kpi'])**2\n            \n            return observables, chi2\n\n        def get_analytic_gradient(self, a, b, gamma_s):\n            \"\"\"Computes the analytical gradient of chi-squared w.r.t. a.\"\"\"\n            # 1. Compute all K and J integrals\n            K_pi, J_pi = self._compute_integral_family(a, b, self.mt2_pi)\n            K_k, J_k = self._compute_integral_family(a, b, self.mt2_k)\n            \n            K_pi_neg1, K_pi_0, K_pi_1 = K_pi[-1], K_pi[0], K_pi[1]\n            J_pi_neg1, J_pi_0, J_pi_1 = J_pi[-1], J_pi[0], J_pi[1]\n            K_k_0, J_k_0 = K_k[0], J_k[0]\n\n            # 2. Compute observables (re-used for chi2 term)\n            observables, _ = self.calculate_observables_and_chi2(a, b, gamma_s)\n\n            # 3. Compute observable derivatives\n            dO_M_da = self.C_mult * (J_pi_neg1 * K_pi_0 - K_pi_neg1 * J_pi_0) / (K_pi_0**2)\n            dO_z_da = (J_pi_1 * K_pi_0 - K_pi_1 * J_pi_0) / (K_pi_0**2)\n            \n            dO_Kpi_da_num = gamma_s * (J_k_0 * K_pi_0 - K_k_0 * J_pi_0)\n            dO_Kpi_da_den = (K_pi_0 + gamma_s * K_k_0)**2\n            dO_Kpi_da = dO_Kpi_da_num / dO_Kpi_da_den\n            \n            # 4. Assemble full gradient using chain rule\n            dchi2_da = 0\n            dchi2_da += 2 * (observables['M'] - self.obs_vals['M']) / self.sigmas['M']**2 * dO_M_da\n            dchi2_da += 2 * (observables['z'] - self.obs_vals['z']) / self.sigmas['z']**2 * dO_z_da\n            dchi2_da += 2 * (observables['Kpi'] - self.obs_vals['Kpi']) / self.sigmas['Kpi']**2 * dO_Kpi_da\n            \n            return dchi2_da\n\n        def get_fd_gradient(self, a, b, gamma_s, delta):\n            \"\"\"Computes the finite-difference gradient of chi-squared w.r.t. a.\"\"\"\n            _, chi2_plus = self.calculate_observables_and_chi2(a + delta, b, gamma_s)\n            _, chi2_minus = self.calculate_observables_and_chi2(a - delta, b, gamma_s)\n            return (chi2_plus - chi2_minus) / (2 * delta)\n\n    #\n    # --- Main Execution Logic ---\n    #\n    \n    # 1. Setup integration grid\n    z_grid = np.linspace(Z_MIN, Z_MAX, N_POINTS)\n    \n    # 2. Calibrate C_mult at the reference point\n    one_minus_z_ref = 1 - z_grid\n    common_term_ref = (one_minus_z_ref)**A_REF * np.exp(-B_REF * MT2_PI / z_grid)\n    K_pi_0_ref = np.trapz(z_grid**(-1) * common_term_ref, z_grid)\n    K_pi_neg1_ref = np.trapz(z_grid**(-2) * common_term_ref, z_grid)\n    C_mult = OBS_M * K_pi_0_ref / K_pi_neg1_ref\n    \n    # 3. Instantiate model with calibrated constant\n    model = LundSurrogate(z_grid, MT2_PI, MT2_K, C_mult)\n\n    # 4. Define test suite\n    test_cases = [\n        (0.3, 0.58, 0.3),\n        (1.2, 0.58, 0.3),\n        (0.1, 0.30, 0.2),\n        (0.5, 0.90, 0.35),\n    ]\n\n    results = []\n    for a, b, gamma_s in test_cases:\n        # a) Compute analytical gradient\n        grad_analytic = model.get_analytic_gradient(a, b, gamma_s)\n        \n        # b) Compute finite difference gradient for comparison\n        grad_fd = model.get_fd_gradient(a, b, gamma_s, DELTA_A)\n        \n        # c) Calculate relative discrepancy\n        numerator = np.abs(grad_analytic - grad_fd)\n        denominator = np.maximum(np.abs(grad_fd), 1e-12)\n        rel_err = numerator / denominator\n        results.append(rel_err)\n\n    # 5. Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}