{
    "hands_on_practices": [
        {
            "introduction": "在开始任何复杂的物理分析之前，我们必须确保所用数据的格式统一且数值准确。本练习聚焦于单位转换这一基本任务，这是处理来自不同来源（如不同蒙特卡洛生成器）的数据时不可或缺的步骤。此练习将引导你不仅执行单位换算，还需量化在此过程中产生的浮点数舍入误差，这是计算科学中一项至关重要的实践技能，能够加深你对数值精度的理解。",
            "id": "3513376",
            "problem": "您将获得一个基于高能物理蒙特卡洛 (HepMC3) 库建模的抽象事件记录。在 HepMC3 中，诸如四维动量分量之类的类能量使用单一能量单位存储，而诸如顶点位置之类的类空间量则使用单一长度单位存储。HepMC3 对通用用途生成器产生的事件记录所使用的传统默认单位是能量以 $\\,\\mathrm{GeV}\\,$ 为单位，长度以 $\\,\\mathrm{mm}\\,$ 为单位，并为能量单位 $\\,\\{\\mathrm{eV},\\mathrm{keV},\\mathrm{MeV},\\mathrm{GeV},\\mathrm{TeV}\\}\\,$ 和长度单位 $\\,\\{\\mathrm{mm},\\mathrm{cm},\\mathrm{m}\\}\\,$ 提供了明确定义的枚举。一个事件记录由一系列粒子组成，每个粒子都有一个四维动量 $(E,p_x,p_y,p_z)$ 和一个产生顶点位置 $(x,y,z)$，其中 $(E,p_x,p_y,p_z)$ 的单位是 $\\,\\mathrm{GeV}\\,$，$(x,y,z)$ 的单位是 $\\,\\mathrm{mm}\\,$。\n\n从量纲分析和标准单位定义出发，推导出将类能量从 $\\,\\mathrm{GeV}\\,$ 转换为 $\\,\\mathrm{MeV}\\,$ 以及将类长度量从 $\\,\\mathrm{mm}\\,$ 转换为 $\\,\\mathrm{cm}\\,$ 的数学上正确的转换方法。假设所有数值计算均采用符合电气和电子工程师协会 (IEEE) $\\,754\\,$ 标准的双精度浮点数执行，其中机器 ε $\\,\\epsilon\\,$ 定义为在双精度下满足 $\\,1+\\epsilon \\neq 1\\,$ 的最小正数。\n\n您的任务是实现一个程序，该程序能：\n- 使用从基本单位定义推导出的正确乘法转换因子，将给定的事件记录从 $(\\mathrm{GeV},\\mathrm{mm})$ 转换为 $(\\mathrm{MeV},\\mathrm{cm})$。\n- 量化由这些转换所使用的浮点运算引入的舍入误差的严格上界，并以绝对误差界表示。对能量转换使用乘以一个可精确表示的整数因子的单次乘法的第一性原理浮点舍入模型，对长度转换使用乘以一个非精确十进制因子的模型。必须按每个数值字段计算这些界限，并按事件聚合为该事件内所有转换量的最大绝对误差界。\n- 生成单行输出，其中包含每个事件的结果列表。每个事件的结果必须是一个双元素列表 $[E_{\\max},L_{\\max}]$，其中 $E_{\\max}$ 是所有转换后的类能量（单位为 $\\,\\mathrm{MeV}\\,$）中的最大绝对误差界，$L_{\\max}$ 是所有转换后的类长度量（单位为 $\\,\\mathrm{cm}\\,$）中的最大绝对误差界。所有输出必须是不带单位的标准十进制形式的实数。\n\n基本依据：\n- 使用定义 $\\,1\\,\\mathrm{GeV} = 10^{3}\\,\\mathrm{MeV}\\,$。\n- 使用定义 $\\,1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}\\,$。\n- 使用 IEEE $\\,754\\,$ 的向最近舍入模型进行单次浮点乘法，机器 ε 为 $\\,\\epsilon\\,$。将乘以一个可精确表示的整数 $\\,k\\,$ 的操作视为最多引入一次舍入，其相对误差界为 $\\,\\epsilon\\,$；将乘以一个非精确十进制因子 $\\,q\\,$ 的操作视为表示 $\\,q\\,$（相对误差界为 $\\,\\epsilon\\,$）和单次舍入乘法（相对误差界为 $\\,\\epsilon\\,$）的组合，从而得出一个总相对误差不超过 $\\,2\\epsilon\\,$ 的保守界限。\n\n单位与数值输出：\n- 转换输出为程序内部使用；最终打印的结果必须是如上所述的误差界，并且必须是以标准十进制表示法打印的无量纲数值。\n- 本任务不使用角度；没有需要指定的角度单位。\n\n测试套件：\n您必须将您的程序应用于以下三个事件记录。每个事件是一个粒子列表，每个粒子由两个元组定义：$(E,p_x,p_y,p_z)$（单位为 $\\,\\mathrm{GeV}\\,$）和 $(x,y,z)$（单位为 $\\,\\mathrm{mm}\\,$）：\n\n- 事件 $\\,1\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (91.1876,1.0,-2.0,10.0)$，$(x,y,z) = (0.5,-1.2,30.0)$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (45.5938,-0.3,0.1,-5.0)$，$(x,y,z) = (0.0,0.0,0.0)$\n  - 粒子 $\\,3\\,$：$(E,p_x,p_y,p_z) = (0.005,0.001,0.0002,-0.0001)$，$(x,y,z) = (0.001,-0.002,0.005)$\n- 事件 $\\,2\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (13000.0,100.0,-200.0,5000.0)$，$(x,y,z) = (1000000.0,0.0,-1000000.0)$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (0.0,0.0,0.0,0.0)$，$(x,y,z) = (1.0,-1.0,1.0)$\n- 事件 $\\,3\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (1.0\\times 10^{-9},-1.0\\times 10^{-9},2.0\\times 10^{-9},-3.0\\times 10^{-9})$，$(x,y,z) = (1.0\\times 10^{-6},-2.0\\times 10^{-6},3.0\\times 10^{-6})$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (5.0\\times 10^{-3},-5.0\\times 10^{-3},0.0,1.0\\times 10^{-2})$，$(x,y,z) = (1.0\\times 10^{-3},0.0,-1.0\\times 10^{-3})$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的各事件结果列表，其中每个元素是双元素列表 $[E_{\\max},L_{\\max}]$。例如，输出必须采用 $[\\,[E_{\\max}^{(1)},L_{\\max}^{(1)}],[E_{\\max}^{(2)},L_{\\max}^{(2)}],[E_{\\max}^{(3)},L_{\\max}^{(3)}]\\,]$ 的形式，并用数值替代符号。",
            "solution": "该问题要求为高能物理中的事件记录推导转换因子并分析相关的浮点误差。此分析将分三步进行：首先，推导乘法转换因子；其次，为绝对浮点误差的上界建模和计算；第三，阐述一个将这些计算应用于给定测试数据的算法。\n\n**1. 转换因子的推导**\n\n问题指定了基于标准单位定义的类能量和类长度量的转换。\n\n- **能量转换 ($\\mathrm{GeV} \\to \\mathrm{MeV}$)**：给出的定义是 $1\\,\\mathrm{GeV} = 10^3\\,\\mathrm{MeV}$。要将一个以 $\\mathrm{GeV}$ 为单位的值 $Q_{\\mathrm{GeV}}$ 转换为其以 $\\mathrm{MeV}$ 为单位的等价值 $Q_{\\mathrm{MeV}}$，我们需乘以从该恒等式推导出的适当转换因子：\n$$ Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times \\left( \\frac{10^3\\,\\mathrm{MeV}}{1\\,\\mathrm{GeV}} \\right) = Q_{\\mathrm{GeV}} \\times 1000 $$\n转换因子是整数 $k = 1000$。在 IEEE $754$ 双精度二进制格式中，整数 $1000$ 是可以精确表示的，因为它可以写成 $1000 = 125 \\times 2^3$，而整数尾数 $125$ 仅需 7 位，远在 52 位的限制之内。\n\n- **长度转换 ($\\mathrm{mm} \\to \\mathrm{cm}$)**：给出的定义是 $1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}$。要将一个以 $\\mathrm{mm}$ 为单位的值 $P_{\\mathrm{mm}}$ 转换为其以 $\\mathrm{cm}$ 为单位的等价值 $P_{\\mathrm{cm}}$，转换方式为：\n$$ P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times \\left( \\frac{1\\,\\mathrm{cm}}{10\\,\\mathrm{mm}} \\right) = P_{\\mathrm{mm}} \\times 0.1 $$\n转换因子是十进制小数 $q = 0.1$。在二进制中，这是一个无限循环小数（$0.000110011..._2$）。因此，$0.1$ 无法在任何有限位二进制浮点系统中被精确表示，包括 IEEE $754$ 双精度。\n\n**2. 浮点误差分析**\n\n问题强制要求基于 IEEE $754$ 双精度算术的第一性原理模型进行误差分析，我们将其机器 ε 记为 $\\epsilon$。机器 ε $\\epsilon$ 是单次基本浮点运算的相对误差的上界，即 $fl(x \\odot y) = (x \\odot y)(1+\\delta)$，其中 $|\\delta| \\le \\epsilon$。\n\n- **能量转换的绝对误差界**：转换公式为 $Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times 1000$。问题指出，乘以可精确表示的因子 $1000$ 最多引入一次舍入。计算值 $Q'_{\\mathrm{MeV}}$ 与精确的数学结果 $Q_{\\mathrm{GeV}} \\times 1000$ 之间的关系为：\n$$ Q'_{\\mathrm{MeV}} = fl(Q_{\\mathrm{GeV}} \\times 1000) = (Q_{\\mathrm{GeV}} \\times 1000)(1 + \\delta_{E}) $$\n其中相对误差 $|\\delta_{E}| \\le \\epsilon$。因此，绝对误差 $\\Delta Q_E = |Q'_{\\mathrm{MeV}} - (Q_{\\mathrm{GeV}} \\times 1000)|$ 的界限为：\n$$ \\text{bound}(\\Delta Q_E) = |(Q_{\\mathrm{GeV}} \\times 1000)\\delta_{E}| \\le |Q_{\\mathrm{GeV}} \\times 1000| \\times \\epsilon $$\n对于每个事件，最大绝对误差界 $E_{\\max}$ 是该事件内所有粒子的所有类能量 $\\{E, p_x, p_y, p_z\\}$ 的此界限的最大值。该最大值由具有最大绝对值的分量决定：\n$$ E_{\\max} = \\left( \\max_{\\text{event}} |Q_{\\mathrm{GeV}}| \\right) \\times 1000 \\times \\epsilon $$\n得到的误差界 $E_{\\max}$ 的单位是 $\\mathrm{MeV}$。\n\n- **长度转换的绝对误差界**：转换公式为 $P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times 0.1$。问题指定了一个保守模型，其中此操作的总相对误差界为 $2\\epsilon$。这既考虑了表示非精确因子 $0.1$ 时的初始误差，也考虑了后续乘法产生的误差。计算值 $P'_{\\mathrm{cm}}$ 与精确的数学结果 $P_{\\mathrm{mm}} \\times 0.1$ 之间的关系为：\n$$ P'_{\\mathrm{cm}} = (P_{\\mathrm{mm}} \\times 0.1)(1 + \\delta_{L}) $$\n其中总相对误差 $|\\delta_{L}| \\le 2\\epsilon$。因此，绝对误差 $\\Delta Q_L = |P'_{\\mathrm{cm}} - (P_{\\mathrm{mm}} \\times 0.1)|$ 的界限为：\n$$ \\text{bound}(\\Delta Q_L) = |(P_{\\mathrm{mm}} \\times 0.1)\\delta_{L}| \\le |P_{\\mathrm{mm}} \\times 0.1| \\times 2\\epsilon $$\n对于每个事件，最大绝对误差界 $L_{\\max}$ 是该事件内所有粒子的所有类长度量 $\\{x, y, z\\}$ 的此界限的最大值：\n$$ L_{\\max} = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.1 \\times 2\\epsilon = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.2 \\times \\epsilon $$\n得到的误差界 $L_{\\max}$ 的单位是 $\\mathrm{cm}$。\n\n**3. 算法与实现**\n\n用于计算测试套件所需误差界的算法如下：\n1.  获取 IEEE $754$ 双精度数的机器 ε $\\epsilon$。\n2.  对于测试套件中的每个事件：\n    a. 将 `max_abs_energy_GeV` 和 `max_abs_length_mm` 初始化为 $0.0$。\n    b. 遍历事件中的每个粒子。\n        i. 对于粒子的四维动量 $(E, p_x, p_y, p_z)$（单位为 $\\mathrm{GeV}$），找到其分量中的最大绝对值。将 `max_abs_energy_GeV` 更新为其当前值与这个新最大值中的较大者。\n        ii. 对于粒子的顶点位置 $(x, y, z)$（单位为 $\\mathrm{mm}$），找到其分量中的最大绝对值。将 `max_abs_length_mm` 更新为其当前值与这个新最大值中的较大者。\n    c. 处理完所有粒子后，使用推导出的公式计算整个事件的最大绝对误差界：\n       - $E_{\\max} = \\texttt{max\\_abs\\_energy\\_GeV} \\times 1000 \\times \\epsilon$\n       - $L_{\\max} = \\texttt{max\\_abs\\_length\\_mm} \\times 0.2 \\times \\epsilon$\n    d. 存储结果对 $[E_{\\max}, L_{\\max}]$。\n3.  根据指定的输出格式 `[[E_max_1,L_max_1],[E_max_2,L_max_2],...]`，将存储的结果对列表格式化为单个字符串，并打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating floating-point error bounds for unit\n    conversions in high-energy physics event records.\n    \"\"\"\n\n    # Define the test suite from the problem statement.\n    # Structure: list of events.\n    # Each event: list of particles.\n    # Each particle: tuple of (four_momentum_GeV, vertex_position_mm).\n    test_cases = [\n        # Event 1\n        [\n            ((91.1876, 1.0, -2.0, 10.0), (0.5, -1.2, 30.0)),\n            ((45.5938, -0.3, 0.1, -5.0), (0.0, 0.0, 0.0)),\n            ((0.005, 0.001, 0.0002, -0.0001), (0.001, -0.002, 0.005))\n        ],\n        # Event 2\n        [\n            ((13000.0, 100.0, -200.0, 5000.0), (1000000.0, 0.0, -1000000.0)),\n            ((0.0, 0.0, 0.0, 0.0), (1.0, -1.0, 1.0))\n        ],\n        # Event 3\n        [\n            ((1.0e-9, -1.0e-9, 2.0e-9, -3.0e-9), (1.0e-6, -2.0e-6, 3.0e-6)),\n            ((5.0e-3, -5.0e-3, 0.0, 1.0e-2), (1.0e-3, 0.0, -1.0e-3))\n        ]\n    ]\n\n    # Get machine epsilon for IEEE 754 double precision (np.float64).\n    epsilon = np.finfo(np.float64).eps\n\n    results = []\n    for event in test_cases:\n        max_abs_energy_component_gev = 0.0\n        max_abs_length_component_mm = 0.0\n\n        # Find the maximum absolute value for energy and length quantities in the event.\n        for particle in event:\n            momenta, positions = particle\n            \n            # Find max absolute value for energy-like quantities (in GeV)\n            current_max_e = max(map(abs, momenta))\n            if current_max_e > max_abs_energy_component_gev:\n                max_abs_energy_component_gev = current_max_e\n\n            # Find max absolute value for length-like quantities (in mm)\n            current_max_l = max(map(abs, positions))\n            if current_max_l > max_abs_length_component_mm:\n                max_abs_length_component_mm = current_max_l\n\n        # Calculate E_max: absolute error bound for energy conversion (in MeV).\n        # The model is: E_max = (max |val_GeV|) * 1000 * epsilon\n        e_max = max_abs_energy_component_gev * 1000.0 * epsilon\n\n        # Calculate L_max: absolute error bound for length conversion (in cm).\n        # The model is: L_max = (max |val_mm|) * 0.1 * 2 * epsilon\n        l_max = max_abs_length_component_mm * 0.2 * epsilon\n        \n        results.append([e_max, l_max])\n\n    # Format the final output string exactly as specified.\n    # Python's default float-to-string conversion produces standard decimal form.\n    output_str = \"[\" + \",\".join([f\"[{e},{l}]\" for e, l in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的数据处理后，我们将面临一个更贴近现实的复杂场景：在不同版本的事件记录格式之间迁移数据。这项实践要求你将事件记录不仅视为数值列表，而是一个代表粒子历史的结构化图形。你将练习在转换单位和处理离散数据（如粒子状态码）的同时，如何保持事件图的拓扑结构，从而深刻体会数据模型完整性的重要性。",
            "id": "3513391",
            "problem": "您的任务是实现一个转换器，用于转换高能物理事件记录的两种内存表示。这两种表示抽象了高能物理蒙特卡洛（HepMC）$2$ 版本和 $3$ 版本格式的共同特征。每个事件是一个有向二分图，包含顶点节点（产生或衰变点）和粒子节点（连接顶点的边）。输入表示（类 HepMC$2$）分别声明其动量-能量和时空单位。输出表示（类 HepMC$3$）必须保留图结构，并将所有数值显式转换为固定的目标单位。该转换器还必须通过一个明确定义的函数，将整数粒子状态码从输入约定映射到输出约定。您必须实现一个可运行的程序，对一个小型的事件测试套件执行此转换，为每个事件检查三个不变量，并输出结果。\n\n使用的基础和定义：\n- 一个 HepMC 事件可以理想化为一个有向二分图 $G = (V \\cup P, E)$，其中 $V$ 是顶点集，$P$ 是粒子集，$E$ 是连接 $V$ 与 $P$ 以及 $P$ 与 $V$ 的边，使得任意两个 $V$ 节点或两个 $P$ 节点之间没有边。每个粒子 $p \\in P$ 最多有一个产生顶点 $\\mathrm{prod}(p) \\in V$ 和一个终止顶点 $\\mathrm{end}(p) \\in V$。每个顶点 $v \\in V$ 有一个入边集合 $\\mathrm{in}(v) \\subseteq P$ 和一个出边集合 $\\mathrm{out}(v) \\subseteq P$，它们满足由粒子端点导出的集合等式：$\\mathrm{in}(v) = \\{ p \\in P \\mid \\mathrm{end}(p) = v \\}$ 和 $\\mathrm{out}(v) = \\{ p \\in P \\mid \\mathrm{prod}(p) = v \\}$。\n- 四维动量表示为元组 $(p_x, p_y, p_z, E)$，四维位置表示为 $(x, y, z, t)$。在光速 $c = 1$ 的自然单位制中，能量和动量的单位是相同的。单位转换是纯粹的缩放：如果输入动量-能量单位是 $\\mathsf{MEV}$，目标单位是 $\\mathsf{GEV}$，则缩放因子 $s_p$ 为 $s_p = 10^{-3}$；如果输入单位是 $\\mathsf{GEV}$，则 $s_p = 1$。对于时空，如果输入长度单位是 $\\mathsf{CM}$，目标单位是 $\\mathsf{MM}$，则缩放因子 $s_\\ell$ 为 $s_\\ell = 10$；如果输入单位是 $\\mathsf{MM}$，则 $s_\\ell = 1$。将 $s_p$ 应用于所有四维动量分量，将 $s_\\ell$ 应用于所有四维位置分量。\n- 粒子状态码是整数。您必须定义一个确定性的映射函数 $f: \\mathbb{Z} \\to \\mathbb{Z}$ 来进行转换。您需要选择一种约定，该约定能够解决非标准代码的歧义，同时保留典型语义，如末态（final-state）和已衰变/中间态（decayed/intermediate）类别。您必须在代码注释中记录您的选择。\n\n您的目标输出表示必须：\n- 使用固定的目标单位：动量-能量使用 $\\mathsf{GEV}$，时空使用 $\\mathsf{MM}$。\n- 精确保留事件图结构：对于每个粒子和顶点，在单位和状态码值转换后，输入和输出之间的关系 $\\mathrm{prod}(\\cdot)$ 和 $\\mathrm{end}(\\cdot)$ 以及导出的集合 $\\mathrm{in}(\\cdot)$、$\\mathrm{out}(\\cdot)$ 必须匹配。\n- 使用您定义的 $f(s)$ 映射状态码，并将其应用于每个粒子。\n\n对于下面测试套件中的每个事件，您的程序必须按此顺序计算三个布尔值结果，并将它们追加到一个扁平列表中：\n- Units-correct（单位正确）：一个布尔值，指示所有四维动量和四维位置是否已通过正确的缩放因子转换为指定的目标单位，相对容差在 $10^{-12}$ 以内。\n- Status-correct（状态正确）：一个布尔值，指示输出中的每个粒子状态是否等于对输入状态 $s$ 应用 $f(s)$ 的结果。\n- Graph-preserved（图结构保留）：一个布尔值，指示就每个粒子的产生和终止顶点以及每个顶点的入/出粒子集而言，输入和输出图是否具有相同的邻接关系。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,...]”）。列表元素必须是布尔值。\n\n测试套件规范：\n将测试套件实现为三个具体的类 HepMC$2$ 事件，其内容与下文完全一致。所有数值必须按其声明的输入单位进行解释，并在输出中转换为目标单位。\n\n事件 A：\n- 输入单位：动量-能量单位 $\\mathsf{MEV}$，长度单位 $\\mathsf{MM}$。\n- 顶点：\n  - 顶点 $v_1$：标识符 $1$，位置 $(x,y,z,t) = (0.0, 0.0, 0.0, 0.0)$。\n  - 顶点 $v_2$：标识符 $2$，位置 $(x,y,z,t) = (0.0, 0.0, 1.0, 1.0)$。\n- 粒子：\n  - 粒子 $p_1$：标识符 $1$，状态 $2$，四维动量 $(p_x,p_y,p_z,E) = (0.0, 0.0, 1000.0, 1100.0)$，$\\mathrm{prod}(p_1) = v_1$，$\\mathrm{end}(p_1) = v_2$。\n  - 粒子 $p_2$：标识符 $2$，状态 $1$，四维动量 $(100.0, 0.0, 400.0, 412.3105626)$，$\\mathrm{prod}(p_2) = v_2$，$\\mathrm{end}(p_2) = \\varnothing$。\n  - 粒子 $p_3$：标识符 $3$，状态 $1$，四维动量 $(-100.0, 0.0, 600.0, 687.6894374)$，$\\mathrm{prod}(p_3) = v_2$，$\\mathrm{end}(p_3) = \\varnothing$。\n\n事件 B：\n- 输入单位：动量-能量单位 $\\mathsf{GEV}$，长度单位 $\\mathsf{CM}$。\n- 顶点：\n  - 顶点 $v_{10}$：标识符 $10$，位置 $(0.0, 0.0, 0.0, 0.0)$。\n  - 顶点 $v_{11}$：标识符 $11$，位置 $(0.1, -0.2, 0.3, 0.0)$。\n- 粒子：\n  - 粒子 $p_{12}$：标识符 $12$，状态 $2$，四维动量 $(0.3, 0.4, 0.0, 0.5)$，$\\mathrm{prod}(p_{12}) = v_{10}$，$\\mathrm{end}(p_{12}) = v_{11}$。\n  - 粒子 $p_{13}$：标识符 $13$，状态 $1$，四维动量 $(0.1, 0.2, 0.0, 0.2236067977)$，$\\mathrm{prod}(p_{13}) = v_{11}$，$\\mathrm{end}(p_{13}) = \\varnothing$。\n  - 粒子 $p_{14}$：标识符 $14$，状态 $1$，四维动量 $(0.2, 0.2, 0.0, 0.2763932023)$，$\\mathrm{prod}(p_{14}) = v_{11}$，$\\mathrm{end}(p_{14}) = \\varnothing$。\n  - 粒子 $p_{10}$：标识符 $10$，状态 $3$，四维动量 $(0.0, 0.0, 0.0, 0.0)$，没有附加产生或终止顶点。\n\n事件 C：\n- 输入单位：动量-能量单位 $\\mathsf{MEV}$，长度单位 $\\mathsf{CM}$。\n- 顶点：\n  - 顶点 $v_{100}$：标识符 $100$，位置 $(0.0, 0.0, 0.0, 0.0)$。\n  - 顶点 $v_{101}$：标识符 $101$，位置 $(0.0, 0.0, 0.01, 0.01)$。\n  - 顶点 $v_{102}$：标识符 $102$，位置 $(0.0, 0.0, 0.02, 0.02)$。\n- 粒子：\n  - 粒子 $p_{100}$：标识符 $100$，状态 $2$，四维动量 $(0.0, 0.0, 1500.0, 1600.0)$，$\\mathrm{prod}(p_{100}) = v_{100}$，$\\mathrm{end}(p_{100}) = v_{101}$。\n  - 粒子 $p_{101}$：标识符 $101$，状态 $2$，四维动量 $(0.0, 0.0, 1000.0, 1100.0)$，$\\mathrm{prod}(p_{101}) = v_{101}$，$\\mathrm{end}(p_{101}) = v_{102}$。\n  - 粒子 $p_{102}$：标识符 $102$，状态 $1$，四维动量 $(0.0, 0.0, 500.0, 500.0)$，$\\mathrm{prod}(p_{102}) = v_{102}$，$\\mathrm{end}(p_{102}) = \\varnothing$。\n  - 粒子 $p_{103}$：标识符 $103$，状态 $1$，四维动量 $(0.0, 0.0, 500.0, 600.0)$，$\\mathrm{prod}(p_{103}) = v_{102}$，$\\mathrm{end}(p_{103}) = \\varnothing$。\n\n单位转换目标和容差：\n- 将所有 $(p_x, p_y, p_z, E)$ 转换为 $\\mathsf{GEV}$。\n- 将所有 $(x, y, z, t)$ 转换为 $\\mathsf{MM}$。\n- 比较浮点数时，使用 $10^{-12}$ 的绝对或相对容差。\n\n状态映射约定：\n- 定义并使用一个映射 $f(s)$，它保留了末态和已衰变/中间态代码（其中 $s \\in \\{1,2\\}$）的含义，并为文档或其他非传播条目分配一个一致的代码。对于所有其他 $s$，提供一个有良好文档记录的常规选择。您必须在源代码注释中描述 $f$。\n\n输出格式要求：\n- 您的程序必须生成单行输出，其中包含一个包含 $9$ 个布尔值的扁平列表，顺序完全如下：事件 A 的 $(\\text{Units-correct}, \\text{Status-correct}, \\text{Graph-preserved})$，其后是同样顺序的事件 B，再其后是同样顺序的事件 C。打印的行必须是 `\"[val1,val2,...,val9]\"` 的格式。\n\n所有计算必须使用与所述单位规则一致的内部浮点运算来执行。不允许文件输入或输出；在程序内部构建测试事件。不允许使用指定之外的外部库。",
            "solution": "该问题要求为高能物理事件记录实现一个转换器。这项任务可以分解为三个主要组成部分：数据结构定义、数据转换和验证。该解决方案遵循基于原则的方法设计，确保每一步的正确性和清晰性。\n\n首先，为了将问题形式化，我们为事件数据建立一个健壮的内存表示。一个事件是一个有向二分图 $G = (V \\cup P, E)$，其中 $V$ 是顶点集，$P$ 是粒子集。我们定义 Python 类来为这些实体建模。`Vertex` 类存储一个唯一的整数标识符、一个四维位置向量 $(x, y, z, t)$ 以及入射和出射粒子列表。`Particle` 类存储一个唯一的整数标识符、一个粒子状态码、一个四维动量向量 $(p_x, p_y, p_z, E)$ 以及对其产生和终止顶点的引用。`Event` 类聚合了顶点和粒子，以及事件范围的动量-能量和长度单位。使用 NumPy 数组表示四维向量，为处理数值操作提供了一种计算上高效的方式。\n\n其次，我们实现转换逻辑。该过程从一个输入 `Event` 生成一个目标表示的新 `Event` 对象。转换涉及对数据应用三种不同的变换：\n\n1.  **单位转换：** 所有数值量必须转换为目标单位：动量-能量使用吉电子伏特（$\\mathsf{GEV}$），时空使用毫米（$\\mathsf{MM}$）。这是通过应用缩放因子来实现的。动量-能量缩放因子 $s_p$ 在从 $\\mathsf{MEV}$ 转换为 $\\mathsf{GEV}$ 时为 $10^{-3}$，如果输入已是 $\\mathsf{GEV}$ 则为 $1$。长度缩放因子 $s_\\ell$ 在从 $\\mathsf{CM}$ 转换为 $\\mathsf{MM}$ 时为 $10$，如果输入已是 $\\mathsf{MM}$ 则为 $1$。对每个粒子，其四维动量向量乘以 $s_p$。对每个顶点，其四维位置向量乘以 $s_\\ell$。\n\n2.  **状态码映射：** 粒子状态码是表示粒子在事件历史中作用的整数。我们必须定义一个确定性映射函数 $f: \\mathbb{Z} \\to \\mathbb{Z}$，以从输入约定转换为输出约定。对于 $f(s)$，一个标准且合乎逻辑的选择是保留常用代码的传统含义，同时优雅地处理其他代码。我们定义 $f(1) = 1$ 用于末态粒子，$f(2) = 2$ 用于已衰变的中间态粒子，以及 $f(3) = 0$ 用于文档条目。所有其他非标准代码也映射到 $0$，这对于在目标方案中没有直接物理解释的代码是一种常见做法。在转换过程中，该函数 $f(s)$ 应用于每个粒子的状态码。\n\n3.  **图结构保留：** 事件的历史编码在其图拓扑中，特别是在粒子和顶点之间的连接中。关系 $\\mathrm{prod}(p)$（粒子 $p$ 的产生顶点）和 $\\mathrm{end}(p)$（粒子 $p$ 的终止顶点）必须被保留。转换过程通过首先创建一套具有转换后数值数据的新粒子和顶点，然后重新建立它们之间的链接来实现这一点。对于每个新粒子，其产生和终止顶点引用被设置为与原始顶点相对应（通过唯一标识符）的新顶点。由于顶点 $v$ 的入射粒子集 $\\mathrm{in}(v)$ 和出射粒子集 $\\mathrm{out}(v)$ 完全由所有粒子的 $\\mathrm{prod}(\\cdot)$ 和 $\\mathrm{end}(\\cdot)$ 关系确定，因此保留这些关系可保证整个图结构得以保留。\n\n第三，为每个转换后的事件检查一组三个不变量，以验证转换的正确性。这些检查的结果是布尔值，构成最终输出。\n\n1.  **Units-correct（单位正确）：** 这个不变量通过遍历输出事件的所有粒子和顶点来验证。对每个实体，我们检查其四维向量是否在数值上等于原始四维向量乘以适当的缩放因子（$s_p$ 或 $s_\\ell$）。比较使用 `numpy.allclose` 执行，该函数能以指定的 $10^{-12}$ 相对容差稳健地处理浮点运算。只有当所有实体的检查都通过时，该不变量才成立。\n\n2.  **Status-correct（状态正确）：** 通过遍历输出事件中的所有粒子，并确保每个粒子的状态码等于对输入事件中相应粒子的状态码应用映射函数 $f(s)$ 的结果，来确认此不变量。\n\n3.  **Graph-preserved（图结构保留）：** 通过验证拓扑完整性来测试此不变量。对于输入事件中的每个粒子，我们通过其标识符在输出事件中找到其对应部分。然后我们比较它们各自产生顶点和终止顶点的标识符。如果对于每个粒子，输出事件中的产生和终止顶点标识符与输入事件中的相匹配，则认为图结构被保留。这包括正确处理可能缺少产生或终止顶点的粒子（例如，没有记录衰变顶点的初始或末态粒子）。\n\n总体实现处理了所提供套件中的三个测试事件，为每个事件执行转换和验证，并将得到的九个布尔值聚合到一个扁平列表中作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A deterministic function to map particle status codes.\n# This function must be documented as per the problem description.\n# Convention chosen:\n# - Status 1 (final-state) maps to 1.\n# - Status 2 (intermediate/decayed) maps to 2.\n# - Status 3 (documentation) maps to 0, a common convention for non-physical entries.\n# - All other status codes are mapped to 0 as a catch-all for undefined/non-standard codes.\ndef status_map(s: int) -> int:\n    \"\"\"Maps an input status code to an output status code.\"\"\"\n    if s == 1:\n        return 1\n    if s == 2:\n        return 2\n    if s == 3:\n        return 0\n    return 0\n\nclass Vertex:\n    \"\"\"Represents a vertex in the event graph.\"\"\"\n    def __init__(self, id_val: int, pos: tuple):\n        self.id = id_val\n        self.pos = np.array(pos, dtype=float)\n        self.incoming_particles = []\n        self.outgoing_particles = []\n\n    def __repr__(self) -> str:\n        return f\"Vertex(id={self.id}, pos={self.pos})\"\n\nclass Particle:\n    \"\"\"Represents a particle in the event graph.\"\"\"\n    def __init__(self, id_val: int, status: int, mom: tuple):\n        self.id = id_val\n        self.status = status\n        self.mom = np.array(mom, dtype=float)\n        self.prod_vertex = None\n        self.end_vertex = None\n\n    def __repr__(self) -> str:\n        prod_id = self.prod_vertex.id if self.prod_vertex else None\n        end_id = self.end_vertex.id if self.end_vertex else None\n        return f\"Particle(id={self.id}, status={self.status}, mom={self.mom}, prod={prod_id}, end={end_id})\"\n\nclass Event:\n    \"\"\"Represents a single event, containing vertices and particles.\"\"\"\n    def __init__(self, mom_unit: str, len_unit: str):\n        self.mom_unit = mom_unit\n        self.len_unit = len_unit\n        self.vertices = {}  # map id -> Vertex\n        self.particles = {} # map id -> Particle\n\n    def add_vertex(self, vertex: Vertex):\n        self.vertices[vertex.id] = vertex\n\n    def add_particle(self, particle: Particle):\n        self.particles[particle.id] = particle\n\ndef convert_event(input_event: Event) -> Event:\n    \"\"\"Converts an event to the target representation.\"\"\"\n    # Determine scaling factors\n    s_p = 1e-3 if input_event.mom_unit == 'MEV' else 1.0\n    s_l = 10.0 if input_event.len_unit == 'CM' else 1.0\n    \n    # Create new event with target units\n    output_event = Event('GEV', 'MM')\n\n    # Convert vertices\n    for v_id, v_in in input_event.vertices.items():\n        new_pos = v_in.pos * s_l\n        output_event.add_vertex(Vertex(v_id, tuple(new_pos)))\n\n    # Convert particles\n    for p_id, p_in in input_event.particles.items():\n        new_mom = p_in.mom * s_p\n        new_status = status_map(p_in.status)\n        output_event.add_particle(Particle(p_id, new_status, tuple(new_mom)))\n\n    # Re-establish graph links\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        if p_in.prod_vertex:\n            prod_v_out = output_event.vertices[p_in.prod_vertex.id]\n            p_out.prod_vertex = prod_v_out\n            prod_v_out.outgoing_particles.append(p_out)\n        if p_in.end_vertex:\n            end_v_out = output_event.vertices[p_in.end_vertex.id]\n            p_out.end_vertex = end_v_out\n            end_v_out.incoming_particles.append(p_out)\n            \n    return output_event\n\ndef run_checks(input_event: Event, output_event: Event):\n    \"\"\"Performs the three required checks and returns the boolean results.\"\"\"\n    # Determine scaling factors again for verification\n    s_p = 1e-3 if input_event.mom_unit == 'MEV' else 1.0\n    s_l = 10.0 if input_event.len_unit == 'CM' else 1.0\n    \n    # 1. Units-correct check\n    units_correct = True\n    # Check particle momenta\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        expected_mom = p_in.mom * s_p\n        if not np.allclose(p_out.mom, expected_mom, rtol=1e-12, atol=1e-12):\n            units_correct = False\n            break\n    # Check vertex positions\n    if units_correct:\n        for v_id, v_in in input_event.vertices.items():\n            v_out = output_event.vertices[v_id]\n            expected_pos = v_in.pos * s_l\n            if not np.allclose(v_out.pos, expected_pos, rtol=1e-12, atol=1e-12):\n                units_correct = False\n                break\n\n    # 2. Status-correct check\n    status_correct = True\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        if p_out.status != status_map(p_in.status):\n            status_correct = False\n            break\n\n    # 3. Graph-preserved check\n    graph_preserved = True\n    for p_id, p_in in input_event.particles.items():\n        p_out = output_event.particles[p_id]\n        \n        in_prod_id = p_in.prod_vertex.id if p_in.prod_vertex else None\n        out_prod_id = p_out.prod_vertex.id if p_out.prod_vertex else None\n        \n        in_end_id = p_in.end_vertex.id if p_in.end_vertex else None\n        out_end_id = p_out.end_vertex.id if p_out.end_vertex else None\n        \n        if in_prod_id != out_prod_id or in_end_id != out_end_id:\n            graph_preserved = False\n            break\n\n    return units_correct, status_correct, graph_preserved\n\ndef solve():\n    \"\"\"Main function to define tests, run conversion and checks, and print results.\"\"\"\n    test_cases = [\n        # Event A\n        {\n            \"units\": (\"MEV\", \"MM\"),\n            \"vertices\": [\n                (1, (0.0, 0.0, 0.0, 0.0)),\n                (2, (0.0, 0.0, 1.0, 1.0)),\n            ],\n            \"particles\": [\n                (1, 2, (0.0, 0.0, 1000.0, 1100.0)),\n                (2, 1, (100.0, 0.0, 400.0, 412.3105626)),\n                (3, 1, (-100.0, 0.0, 600.0, 687.6894374)),\n            ],\n            \"links\": [\n                (1, 1, 2),\n                (2, 2, None),\n                (3, 2, None),\n            ]\n        },\n        # Event B\n        {\n            \"units\": (\"GEV\", \"CM\"),\n            \"vertices\": [\n                (10, (0.0, 0.0, 0.0, 0.0)),\n                (11, (0.1, -0.2, 0.3, 0.0)),\n            ],\n            \"particles\": [\n                (12, 2, (0.3, 0.4, 0.0, 0.5)),\n                (13, 1, (0.1, 0.2, 0.0, 0.2236067977)),\n                (14, 1, (0.2, 0.2, 0.0, 0.2763932023)),\n                (10, 3, (0.0, 0.0, 0.0, 0.0)),\n            ],\n            \"links\": [\n                (12, 10, 11),\n                (13, 11, None),\n                (14, 11, None),\n                (10, None, None),\n            ]\n        },\n        # Event C\n        {\n            \"units\": (\"MEV\", \"CM\"),\n            \"vertices\": [\n                (100, (0.0, 0.0, 0.0, 0.0)),\n                (101, (0.0, 0.0, 0.01, 0.01)),\n                (102, (0.0, 0.0, 0.02, 0.02)),\n            ],\n            \"particles\": [\n                (100, 2, (0.0, 0.0, 1500.0, 1600.0)),\n                (101, 2, (0.0, 0.0, 1000.0, 1100.0)),\n                (102, 1, (0.0, 0.0, 500.0, 500.0)),\n                (103, 1, (0.0, 0.0, 500.0, 600.0)),\n            ],\n            \"links\": [\n                (100, 100, 101),\n                (101, 101, 102),\n                (102, 102, None),\n                (103, 102, None),\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Build input event from data\n        input_event = Event(*case_data[\"units\"])\n        for v_data in case_data[\"vertices\"]:\n            input_event.add_vertex(Vertex(*v_data))\n        for p_data in case_data[\"particles\"]:\n            input_event.add_particle(Particle(*p_data))\n        \n        for p_id, prod_v_id, end_v_id in case_data[\"links\"]:\n            particle = input_event.particles[p_id]\n            if prod_v_id is not None:\n                prod_v = input_event.vertices[prod_v_id]\n                particle.prod_vertex = prod_v\n                prod_v.outgoing_particles.append(particle)\n            if end_v_id is not None:\n                end_v = input_event.vertices[end_v_id]\n                particle.end_vertex = end_v\n                end_v.incoming_particles.append(particle)\n        \n        # Perform conversion\n        output_event = convert_event(input_event)\n        \n        # Run checks and store results\n        check_results = run_checks(input_event, output_event)\n        results.extend(check_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的实践环节将从数据转换转向数据验证，以确保事件记录在物理上和逻辑上都是自洽且有效的。这项练习要求你编写一个验证器，将基本的物理原理（如四动量守恒）和逻辑规则（如粒子生命周期的有效性与因果关系）代码化。通过这个过程，你将巩固对事件记录如何编码一个一致物理过程的理解，并将理论知识应用于确保数据质量的实际挑战中。",
            "id": "3513428",
            "problem": "您的任务是设计并实现一个程序化验证器，用于验证高能物理事件记录。这些记录将粒子历史表示为一个由粒子连接的顶点（相互作用或衰变）构成的图。该验证器必须强制执行逻辑上和物理上一致的状态跃迁及相关约束。事件数据模型遵循一个简化的标准模型，其灵感来源于 HepMC 和 HEPEVT 等格式：\n\n- 每个粒子具有：\n  - 一个唯一的整数标识符 $p \\in \\mathbb{Z}$。\n  - 一个整数状态 $s \\in \\{-1,1,2\\}$，其中 $s=-1$ 表示入射束流粒子，$s=1$ 表示末态稳定粒子，$s=2$ 表示中间衰变或传播粒子。\n  - 一个产生顶点标识符 $v_{\\mathrm{prod}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$ 和一个终止顶点标识符 $v_{\\mathrm{end}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$。\n  - 一个四动量 $p^{\\mu}=(E,p_x,p_y,p_z)$，采用自然单位制，光速 $c$ 设为 $1$。所有分量均以吉电子伏特 (GeV) 为单位。即，$E$ 的单位是 $\\mathrm{GeV}$，$(p_x,p_y,p_z)$ 的单位也是 $\\mathrm{GeV}$。\n\n- 每个顶点具有：\n  - 一个唯一的整数标识符 $v \\in \\mathbb{Z}$。\n  - 一个入射粒子标识符列表和一个出射粒子标识符列表。\n\n验证器必须强制执行以下源于基本原理的约束：\n\n1. 状态-顶点关联规则：\n   - 如果 $s=-1$ (入射)，则 $v_{\\mathrm{prod}}=\\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$。\n   - 如果 $s=1$ (末态)，则 $v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}=\\varnothing$。\n   - 如果 $s=2$ (中间)，则 $v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$。\n\n2. 顶点-粒子一致性：\n   - 对于每个顶点 $v$，其声明的入射粒子集合必须等于集合 $\\{p \\mid v_{\\mathrm{end}}(p)=v\\}$，其声明的出射粒子集合必须等于集合 $\\{p \\mid v_{\\mathrm{prod}}(p)=v\\}$。\n   - 对于每个顶点 $v$，入射粒子的状态必须满足 $s \\in \\{-1,2\\}$，出射粒子的状态必须满足 $s \\in \\{1,2\\}$。\n   - 每个顶点必须至少有一个入射粒子和至少一个出射粒子。\n\n3. 每个顶点 $v$ 处的四动量守恒：\n   - 设 $\\sum_{\\mathrm{in}} p^{\\mu}$ 为入射四动量之和，$\\sum_{\\mathrm{out}} p^{\\mu}$ 为出射四动量之和。守恒条件为\n     $$\\left|\\sum_{\\mathrm{in}} p^{\\mu} - \\sum_{\\mathrm{out}} p^{\\mu}\\right| \\le \\varepsilon \\quad \\text{component-wise},$$\n     对于给定的容差 $\\varepsilon > 0$，这被解释为每个分量的 $\\mathrm{GeV}$ 界限。使用 $\\varepsilon = 10^{-9}\\,\\mathrm{GeV}$。\n\n4. 粒子-顶点图的因果非循环性：\n   - 构建一个有向图，其中对于每个顶点 $v$，对于每个入射粒子 $p_{\\mathrm{in}}$ 和每个出射粒子 $p_{\\mathrm{out}}$，添加一条边 $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$。该图必须是一个有向无环图 (DAG)。任何循环都违反了因果性。\n\n您的程序必须实现这些检查，并输出每个提供的事件是否有效。每个事件的输出必须是一个布尔值，其中 $ \\mathrm{True}$ 表示事件通过所有检查，否则为 $ \\mathrm{False}$。\n\n所有能量和动量分量都应以 $\\mathrm{GeV}$ 为单位进行解释和验证，使用 $c=1$ 的自然单位制。\n\n测试套件：\n根据以下具体事件实现您的验证器。每个事件由一个粒子列表和一个顶点列表指定。每个粒子记录是一个元组 $(\\text{id}, s, v_{\\mathrm{prod}}, v_{\\mathrm{end}}, (E,p_x,p_y,p_z))$，每个顶点记录是一个元组 $(\\text{id}, [\\text{incoming}], [\\text{outgoing}])$。\n\n- 事件 $1$ (正常流程，有效)：\n  - 粒子：\n    - $(1,-1,\\varnothing,101,(100,0,0,100))$\n    - $(2,-1,\\varnothing,101,(100,0,0,-100))$\n    - $(3,2,101,102,(120,0,0,10))$\n    - $(4,1,101,\\varnothing,(80,0,0,-10))$\n    - $(5,1,102,\\varnothing,(60,10,0,5))$\n    - $(6,1,102,\\varnothing,(60,-10,0,5))$\n  - 顶点：\n    - $(101,[1,2],[3,4])$\n    - $(102,[3],[5,6])$\n\n- 事件 $2$ (无效：末态粒子有一个终止顶点，并在该顶点作为入射粒子参与)：\n  - 粒子：\n    - $(11,-1,\\varnothing,201,(10,0,0,0))$\n    - $(10,1,201,202,(10,0,0,0))$\n  - 顶点：\n    - $(201,[11],[10])$\n    - $(202,[10],[])$\n\n- 事件 $3$ (无效：中间粒子没有终止顶点)：\n  - 粒子：\n    - $(20,-1,\\varnothing,301,(50,0,0,0))$\n    - $(21,2,301,\\varnothing,(50,0,0,0))$\n  - 顶点：\n    - $(301,[20],[21])$\n\n- 事件 $4$ (无效：入射粒子有产生顶点)：\n  - 粒子：\n    - $(30,-1,401,402,(5,0,0,0))$\n  - 顶点：\n    - $(401,[],[30])$\n    - $(402,[30],[])$\n\n- 事件 $5$ (无效：顶点-粒子不匹配，且一个出射粒子的产生顶点不一致)：\n  - 粒子：\n    - $(40,-1,\\varnothing,501,(10,0,0,0))$\n    - $(41,2,501,502,(10,0,0,0))$\n    - $(42,1,503,\\varnothing,(10,0,0,0))$\n  - 顶点：\n    - $(501,[40],[41])$\n    - $(502,[41],[42])$\n    - $(503,[],[42])$\n\n- 事件 $6$ (无效：某个顶点的四动量不守恒，超出了容差 $\\varepsilon$)：\n  - 粒子：\n    - $(50,-1,\\varnothing,601,(10,0,0,0))$\n    - $(51,1,601,\\varnothing,(9,0,0,0))$\n  - 顶点：\n    - $(601,[50],[51])$\n\n- 事件 $7$ (无效：图中存在因果循环)：\n  - 粒子：\n    - $(60,2,701,702,(5,0,0,0))$\n    - $(61,2,702,701,(5,0,0,0))$\n  - 顶点：\n    - $(701,[61],[60])$\n    - $(702,[60],[61])$\n\n您的程序必须评估这 $7$ 个事件，并生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。例如，输出格式必须严格为 $[\\mathrm{result}_1,\\mathrm{result}_2,\\ldots,\\mathrm{result}_7]$ 的形式，其中每个 $\\mathrm{result}_i$ 是一个布尔值。",
            "solution": "对高能物理事件记录进行程序化验证需要一系列检查，以确保事件的逻辑自洽性及其对基本物理定律的遵守。我们将设计一个验证器，系统地应用四类约束：（1）状态-顶点关联规则，（2）顶点-粒子图一致性，（3）每个顶点的四动量守恒，以及（4）因果非循环性。一个事件只有在通过所有检查时才被视为有效。\n\n首先，为了实现高效访问，以粒子和顶点列表形式提供的事件数据将被解析为将唯一标识符映射到其各自数据结构的字典。标识符为 $p$ 的粒子表示为 $P_p$，标识符为 $v$ 的顶点表示为 $V_v$。粒子 $p$ 的四动量为 $p^{\\mu}$。空顶点标识符 $\\varnothing$ 在实现中由一个空值表示。\n\n**1. 状态-顶点关联规则**\n\n这套规则形式化了粒子在事件中的生命周期。粒子的状态 $s$ 决定了其在事件历史图中的位置。\n\n*   **原理**：粒子根据其角色进行分类。入射束流粒子（$s=-1$）源于事件外部，因此没有产生顶点（$v_{\\mathrm{prod}}=\\varnothing$），但它必须在某个顶点发生相互作用（$v_{\\mathrm{end}}\\neq \\varnothing$）。末态粒子（$s=1$）是稳定的并离开相互作用区域，因此它必须在某个顶点产生（$v_{\\mathrm{prod}}\\neq \\varnothing$），但没有后续的衰变或相互作用顶点（$v_{\\mathrm{end}}=\\varnothing$）。中间粒子（$s=2$）被产生并随后衰变或相互作用，因此它必须被一个产生顶点和一个终止顶点所界定（$v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$）。\n\n*   **算法**：验证器遍历事件中的每个粒子 $P_p$。对于每个粒子，它检查以下逻辑条件：\n    *   如果 $s(P_p) = -1$，必须满足 $v_{\\mathrm{prod}}(P_p) = \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$。\n    *   如果 $s(P_p) = 1$，必须满足 $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) = \\varnothing$。\n    *   如果 $s(P_p) = 2$，必须满足 $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$。\n    任何粒子未能满足其中任一条件都将使整个事件无效。\n\n**2. 顶点-粒子一致性**\n\n此检查确保粒子和顶点记录为事件的图拓扑提供了一致且完整的描述。\n\n*   **原理**：事件记录包含对事件图的两种视角：粒子的顶点指针（$v_{\\mathrm{prod}}, v_{\\mathrm{end}}$）和顶点的粒子列表（入射、出射）。这两种视角必须相互一致。此外，一个顶点代表一次物理相互作用，必须有粒子进入和离开，并且这些粒子的状态必须与其角色相符。\n\n*   **算法**：验证器遍历每个顶点 $V_v$。对于每个顶点，它执行四项检查：\n    1.  **拓扑一致性**：它构建实际的入射粒子集合 $I_{actual} = \\{p \\mid v_{\\mathrm{end}}(P_p) = v\\}$ 和实际的出射粒子集合 $O_{actual} = \\{p \\mid v_{\\mathrm{prod}}(P_p) = v\\}$。然后，它验证这些集合与顶点数据中提供的声明的入射和出射粒子列表 $I_{declared}$ 和 $O_{declared}$ 是否相同。即，$I_{actual} = \\text{set}(I_{declared})$ 且 $O_{actual} = \\text{set}(O_{declared})$。\n    2.  **顶点的粒子状态**：对于每个粒子 $p \\in I_{declared}$，验证器检查其状态 $s(P_p) \\in \\{-1, 2\\}$。对于每个粒子 $p' \\in O_{declared}$，它检查其状态 $s(P_{p'}) \\in \\{1, 2\\}$。末态粒子（$s=1$）不能成为顶点的入射粒子，初态粒子（$s=-1$）也不能从顶点出射。\n    3.  **顶点粒子数**：一个物理顶点必须代表一次相互作用或衰变。因此，它必须至少有一个入射粒子和至少一个出射粒子。验证器检查 $|I_{declared}| \\ge 1$ 和 $|O_{declared}| \\ge 1$。\n    在这些检查中发现任何顶点的任何差异都会将事件标记为无效。\n\n**3. 四动量守恒**\n\n这是基于物理学最基本的守恒定律之一的严格测试。\n\n*   **原理**：在没有外场的情况下，一个孤立系统的总四动量是守恒的。在每个代表局部相互作用的顶点处，所有入射粒子的四动量之和必须等于所有出射粒子的四动量之和。这源于物理定律在时空平移下的不变性（诺特定理）。\n\n*   **算法**：对于每个顶点 $V_v$，验证器计算所有入射粒子的四动量之和 $\\sum_{\\mathrm{in}} p^{\\mu} = \\sum_{p \\in I_{declared}} p^{\\mu}(P_p)$，以及所有出射粒子的四动量之和 $\\sum_{\\mathrm{out}} p^{\\mu} = \\sum_{p' \\in O_{declared}} p^{\\mu}(P_{p'})$。由于有限浮点精度，直接进行相等性检查是不合适的。取而代之的条件是，四个分量（能量和三个动量分量）中每个分量的绝对差必须小于或等于一个很小的容差 $\\varepsilon$。问题指定 $\\varepsilon = 10^{-9} \\, \\mathrm{GeV}$。\n    $$ \\left| \\left(\\sum_{\\mathrm{in}} p^{\\mu}\\right)_k - \\left(\\sum_{\\mathrm{out}} p^{\\mu}\\right)_k \\right| \\le \\varepsilon $$\n    对于每个分量 $k \\in \\{0, 1, 2, 3\\}$。在任何顶点违反此条件都将使事件无效。\n\n**4. 因果非循环性**\n\n此约束确保事件历史在因果上是可能的。\n\n*   **原理**：因果性规定结果不能先于其原因。在粒子历史图的背景下，这意味着一个粒子不能是其自身的祖先。例如，一个粒子不能衰变成某些产物，然后这些产物再相互作用重新形成原始粒子。产生和衰变的序列必须构成一个有向无环图（DAG）。\n\n*   **算法**：构建一个有向图，其中节点代表粒子。如果存在一个顶点 $V_v$，其中 $p_{\\mathrm{in}}$ 是入射粒子，$p_{\\mathrm{out}}$ 是出射粒子，则添加一条边 $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$。该图代表了因果和世系的流向。为检查循环，采用了深度优先搜索（DFS）算法。在遍历过程中，使用三种状态跟踪节点：未访问、正在访问（当前在递归栈中）和已访问（所有后代已探索完毕）。如果 DFS 遇到一个当前处于“正在访问”状态的节点，则说明找到了一条反向边，这表示存在一个循环。任何循环的存在都违反了因果性，并使事件无效。\n\n通过有条不紊地应用这四个层面的验证，程序可以严格确定任何给定事件记录的物理和逻辑有效性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validator.\n    \"\"\"\n    \n    # Represents the null vertex identifier ø.\n    NULL_VERTEX = None\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Event 1 (valid)\n        {\n            \"particles\": [\n                (1, -1, NULL_VERTEX, 101, (100, 0, 0, 100)),\n                (2, -1, NULL_VERTEX, 101, (100, 0, 0, -100)),\n                (3, 2, 101, 102, (120, 0, 0, 10)),\n                (4, 1, 101, NULL_VERTEX, (80, 0, 0, -10)),\n                (5, 1, 102, NULL_VERTEX, (60, 10, 0, 5)),\n                (6, 1, 102, NULL_VERTEX, (60, -10, 0, 5)),\n            ],\n            \"vertices\": [\n                (101, [1, 2], [3, 4]),\n                (102, [3], [5, 6]),\n            ]\n        },\n        # Event 2 (invalid: final-state particle has end vertex)\n        {\n            \"particles\": [\n                (11, -1, NULL_VERTEX, 201, (10, 0, 0, 0)),\n                (10, 1, 201, 202, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (201, [11], [10]),\n                (202, [10], []),\n            ]\n        },\n        # Event 3 (invalid: intermediate without end vertex)\n        {\n            \"particles\": [\n                (20, -1, NULL_VERTEX, 301, (50, 0, 0, 0)),\n                (21, 2, 301, NULL_VERTEX, (50, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (301, [20], [21]),\n            ]\n        },\n        # Event 4 (invalid: incoming with production vertex)\n        {\n            \"particles\": [\n                (30, -1, 401, 402, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (401, [], [30]),\n                (402, [30], []),\n            ]\n        },\n        # Event 5 (invalid: vertex-particle mismatch)\n        {\n            \"particles\": [\n                (40, -1, NULL_VERTEX, 501, (10, 0, 0, 0)),\n                (41, 2, 501, 502, (10, 0, 0, 0)),\n                (42, 1, 503, NULL_VERTEX, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (501, [40], [41]),\n                (502, [41], [42]),\n                (503, [], [42]),\n            ]\n        },\n        # Event 6 (invalid: four-momentum not conserved)\n        {\n            \"particles\": [\n                (50, -1, NULL_VERTEX, 601, (10, 0, 0, 0)),\n                (51, 1, 601, NULL_VERTEX, (9, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (601, [50], [51]),\n            ]\n        },\n        # Event 7 (invalid: causal cycle)\n        {\n            \"particles\": [\n                (60, 2, 701, 702, (5, 0, 0, 0)),\n                (61, 2, 702, 701, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (701, [61], [60]),\n                (702, [60], [61]),\n            ]\n        }\n    ]\n\n    results = [validate_event(case[\"particles\"], case[\"vertices\"], NULL_VERTEX) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_event(particles_list, vertices_list, null_vertex_id):\n    \"\"\"\n    Performs all validation checks for a single event.\n    \"\"\"\n    \n    # Pre-processing: Create efficient look-up maps\n    particles_map = {p[0]: {\"id\": p[0], \"s\": p[1], \"v_prod\": p[2], \"v_end\": p[3], \"pmu\": np.array(p[4])} for p in particles_list}\n    vertices_map = {v[0]: {\"id\": v[0], \"in\": v[1], \"out\": v[2]} for v in vertices_list}\n\n    # 1. Status-vertex incidence rules\n    for p_id, p_data in particles_map.items():\n        s, v_prod, v_end = p_data[\"s\"], p_data[\"v_prod\"], p_data[\"v_end\"]\n        if s == -1 and not (v_prod == null_vertex_id and v_end != null_vertex_id): return False\n        if s == 1 and not (v_prod != null_vertex_id and v_end == null_vertex_id): return False\n        if s == 2 and not (v_prod != null_vertex_id and v_end != null_vertex_id): return False\n\n    # 2. Vertex-particle consistency\n    for v_id, v_data in vertices_map.items():\n        # Check vertex population\n        if not (v_data[\"in\"] and v_data[\"out\"]): return False\n\n        # Compare declared vs actual particle sets at vertex\n        actual_in = {p_id for p_id, p in particles_map.items() if p[\"v_end\"] == v_id}\n        actual_out = {p_id for p_id, p in particles_map.items() if p[\"v_prod\"] == v_id}\n        if set(v_data[\"in\"]) != actual_in or set(v_data[\"out\"]) != actual_out: return False\n\n        # Check status of particles at vertex\n        for p_id in v_data[\"in\"]:\n            if particles_map[p_id][\"s\"] not in [-1, 2]: return False\n        for p_id in v_data[\"out\"]:\n            if particles_map[p_id][\"s\"] not in [1, 2]: return False\n    \n    # 3. Four-momentum conservation\n    epsilon = 1e-9\n    for v_id, v_data in vertices_map.items():\n        sum_in_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"in\"]], axis=0)\n        sum_out_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"out\"]], axis=0)\n        if not np.all(np.abs(sum_in_pmu - sum_out_pmu) = epsilon): return False\n\n    # 4. Causal acyclicity\n    # Build adjacency list for the particle causality graph\n    adj = {p_id: [] for p_id in particles_map}\n    for v_data in vertices_map.values():\n        for p_in in v_data[\"in\"]:\n            for p_out in v_data[\"out\"]:\n                adj[p_in].append(p_out)\n    \n    # DFS-based cycle detection\n    # States: 0 = unvisited, 1 = visiting, 2 = visited\n    path = set()  # Corresponds to state 1 (visiting)\n    visited = set() # Corresponds to state 2 (visited)\n\n    def has_cycle(node):\n        path.add(node)\n        for neighbor in adj.get(node, []):\n            if neighbor in path:\n                return True\n            if neighbor not in visited:\n                if has_cycle(neighbor):\n                    return True\n        path.remove(node)\n        visited.add(node)\n        return False\n\n    for node in particles_map:\n        if node not in visited:\n            if has_cycle(node):\n                return False\n\n    return True\n\nsolve()\n```"
        }
    ]
}