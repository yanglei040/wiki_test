{
    "hands_on_practices": [
        {
            "introduction": "准确地模拟带电粒子在磁场中的传播是径迹模拟的第一步。在实际探测器中，磁场并非完全均匀，因此数值积分算法（例如“步进器”）的步长选择对于控制模拟误差至关重要。本练习  将从基本的洛伦兹力定律出发，推导在非均匀磁场中为满足特定曲率精度要求所需的最大步长，从而将基础物理原理与径迹模拟中的核心计算挑战联系起来。",
            "id": "3536223",
            "problem": "在螺线管桶状探测器中进行带电粒子径迹的计算传播时，一种常用的一阶步进器会在路径长度为 $\\Delta s$ 的有限步长内将磁场近似为常数，其值取步长起始点的值。在一个桶状区域，测得磁场大小的空间梯度为 $0.05\\ \\mathrm{T/m}$。假设在任何单一步长内，磁场大小沿步进方向线性变化。考虑一个横向动量为 $p_{T}=5\\ \\mathrm{GeV}/c$ 的单电荷粒子在横向平面内运动。径迹追踪程序要求每一步的曲率大小绝对误差，即真实的步长平均曲率与步进器的恒定场曲率之差，必须低于 $\\delta\\kappa_{\\max}=10^{-4}\\ \\mathrm{m^{-1}}$。你可以假设最坏情况下的朝向，即步长方向与磁场最陡峭增加的方向一致。\n\n请仅从洛伦兹力定律和磁场中带电粒子曲率的定义出发，并将沿步长的磁场变化视为线性变化，推导出满足曲率误差界限的 $\\Delta s$ 的一个上界。然后，计算允许的最大步长的数值。\n\n根据需要使用以下基本物理常数：光速 $c=2.99792458\\times 10^{8}\\ \\mathrm{m/s}$，元电荷大小 $|e|=1.602176634\\times 10^{-19}\\ \\mathrm{C}$，以及 $1\\ \\mathrm{eV}=1.602176634\\times 10^{-19}\\ \\mathrm{J}$。请将 $\\Delta s$ 的最终答案以厘米为单位表示，并四舍五入到三位有效数字。你的最终答案必须是一个实数。",
            "solution": "该问题要求基于曲率误差的约束，为粒子径迹追踪模拟推导步长 $\\Delta s$ 的上界。该问题是自洽的，其科学基础为经典电磁学和力学，并且是良定的。因此，该问题被认为是有效的，可以构建一个完整的解。\n\n这个问题的基础是洛伦兹力定律，它描述了电荷为 $q$、速度为 $\\vec{v}$ 的粒子在磁场 $\\vec{B}$ 中所受的力 $\\vec{F}$：\n$$ \\vec{F} = q(\\vec{v} \\times \\vec{B}) $$\n对于一个在垂直于磁场 $\\vec{B}$ 的横向平面内运动的粒子，力的大小为 $F = |q| v_T B$，其中 $v_T$ 是横向速率， $B$ 是磁场大小。这个力充当向心力 $F_c = \\frac{mv_T^2}{R}$，使粒子沿圆形轨道运动。这个圆的半径是 $R$，$m$ 是相对论质量。用横向动量 $p_T = m v_T$ 表示，向心力为 $F_c = \\frac{p_T v_T}{R}$。\n\n令洛伦兹力与向心力相等，可得：\n$$ |q| v_T B = \\frac{p_T v_T}{R} $$\n曲率 $\\kappa$ 定义为曲率半径的倒数，即 $\\kappa = \\frac{1}{R}$。求解 $\\kappa$ 可得到曲率、磁场和横向动量之间的基本关系：\n$$ \\kappa = \\frac{|q| B}{p_T} $$\n在高能物理学中，通常方便以能量除以光速的单位（如 $\\mathrm{GeV}/c$）来表示动量。令 $E_T = p_T c$ 为横向能量。给定的横向动量为 $p_T = 5\\ \\mathrm{GeV}/c$，这意味着 $E_T = 5\\ \\mathrm{GeV}$。我们可以将曲率方程重写为：\n$$ \\kappa = \\frac{|q| c B}{p_T c} = \\frac{|q| c B}{E_T} $$\n在这里，所有量都必须使用一致的单位制，例如国际单位制（SI）。\n\n问题指出，磁场大小 $B$ 沿步进方向线性变化。步长方向与磁场最陡峭增加的方向一致，因此梯度由 $G = 0.05\\ \\mathrm{T/m}$ 给出。设 $s$ 是沿步长的路径长度，从 $s=0$ 到 $s=\\Delta s$。沿步长的任意点 $s$ 处的磁场为：\n$$ B(s) = B_0 + G s $$\n其中 $B_0$ 是步长起始点（$s=0$）的磁场。因此，真实曲率也沿步长线性变化：\n$$ \\kappa(s) = \\frac{|q| c (B_0 + G s)}{E_T} $$\n\n数值步进算法在步长范围内将曲率近似为常数，使用步长起始点的磁场值 $B_0$。因此，步进器的曲率 $\\kappa_{step}$ 为：\n$$ \\kappa_{step} = \\kappa(0) = \\frac{|q| c B_0}{E_T} $$\n\n“真实的步长平均曲率” $\\bar{\\kappa}_{true}$ 是真实曲率函数 $\\kappa(s)$ 在区间 $[0, \\Delta s]$ 上的平均值：\n$$ \\bar{\\kappa}_{true} = \\frac{1}{\\Delta s} \\int_{0}^{\\Delta s} \\kappa(s) \\,ds = \\frac{1}{\\Delta s} \\int_{0}^{\\Delta s} \\frac{|q| c (B_0 + G s)}{E_T} \\,ds $$\n进行积分：\n$$ \\bar{\\kappa}_{true} = \\frac{|q| c}{E_T \\Delta s} \\left[ B_0 s + \\frac{1}{2} G s^2 \\right]_0^{\\Delta s} = \\frac{|q| c}{E_T \\Delta s} \\left( B_0 \\Delta s + \\frac{1}{2} G (\\Delta s)^2 \\right) $$\n$$ \\bar{\\kappa}_{true} = \\frac{|q| c}{E_T} \\left( B_0 + \\frac{1}{2} G \\Delta s \\right) $$\n正如线性函数所预期的那样，这个结果等价于在步长中点 $s = \\frac{\\Delta s}{2}$ 处计算的真实曲率。\n\n每一步的曲率大小绝对误差 $\\delta\\kappa$ 是真实平均曲率与步进器近似值之间的差：\n$$ \\delta\\kappa = |\\bar{\\kappa}_{true} - \\kappa_{step}| = \\left| \\frac{|q| c}{E_T} \\left( B_0 + \\frac{1}{2} G \\Delta s \\right) - \\frac{|q| c B_0}{E_T} \\right| $$\n$$ \\delta\\kappa = \\left| \\frac{|q| c B_0}{E_T} + \\frac{|q| c G \\Delta s}{2 E_T} - \\frac{|q| c B_0}{E_T} \\right| = \\frac{|q| c G \\Delta s}{2 E_T} $$\n问题对这个误差施加了一个上界，$\\delta\\kappa \\le \\delta\\kappa_{\\max}$，其中 $\\delta\\kappa_{\\max} = 10^{-4}\\ \\mathrm{m^{-1}}$。我们可以利用这一点来找到最大允许步长 $\\Delta s_{\\max}$：\n$$ \\frac{|q| c G \\Delta s}{2 E_T} \\le \\delta\\kappa_{\\max} \\implies \\Delta s \\le \\frac{2 E_T \\delta\\kappa_{\\max}}{|q| c G} $$\n因此，步长的上界是：\n$$ \\Delta s_{\\max} = \\frac{2 E_T \\delta\\kappa_{\\max}}{|q| c G} $$\n为了对此表达式进行数值计算，我们必须使用国际单位制（SI）。已知条件如下：\n-   单电荷粒子，所以 $|q|$ 是元电荷 $|e| = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$。\n-   横向能量 $E_T = 5\\ \\mathrm{GeV} = 5 \\times 10^9\\ \\mathrm{eV}$。为了转换成焦耳，我们使用 $1\\ \\mathrm{eV} = 1.602176634 \\times 10^{-19}\\ \\mathrm{J}$。所以，$E_T = 5 \\times 10^9 \\times (1.602176634 \\times 10^{-19})\\ \\mathrm{J}$。\n-   最大曲率误差 $\\delta\\kappa_{\\max} = 10^{-4}\\ \\mathrm{m^{-1}}$。\n-   磁场梯度 $G = 0.05\\ \\mathrm{T/m}$。\n-   光速 $c = 2.99792458 \\times 10^8\\ \\mathrm{m/s}$。\n\n将这些值代入 $\\Delta s_{\\max}$ 的表达式：\n$$ \\Delta s_{\\max} = \\frac{2 \\times (5 \\times 10^9 \\times 1.602176634 \\times 10^{-19}\\ \\mathrm{J}) \\times (10^{-4}\\ \\mathrm{m^{-1}})}{(1.602176634 \\times 10^{-19}\\ \\mathrm{C}) \\times (2.99792458 \\times 10^8\\ \\mathrm{m/s}) \\times (0.05\\ \\mathrm{T/m})} $$\n元电荷的数值 $1.602176634 \\times 10^{-19}$ 同时出现在分子（来自电子伏特到焦耳的转换）和分母（作为以库仑为单位的电荷）中。这些项相互消去，显著简化了计算：\n$$ \\Delta s_{\\max} = \\frac{2 \\times (5 \\times 10^9) \\times (10^{-4}\\ \\mathrm{m^{-1}})}{(2.99792458 \\times 10^8\\ \\mathrm{m/s}) \\times (0.05\\ \\mathrm{T/m})} $$\n$$ \\Delta s_{\\max} = \\frac{10 \\times 10^5}{(2.99792458 \\times 10^8) \\times 0.05} \\cdot \\frac{\\mathrm{J} \\cdot \\mathrm{m}^{-1}}{\\mathrm{C} \\cdot (\\mathrm{m/s}) \\cdot (\\mathrm{T/m})} $$\n我们来检查一下单位：$\\mathrm{J/(C \\cdot T \\cdot s^{-1})} = \\mathrm{J/(C \\cdot (J \\cdot s \\cdot C^{-1} m^{-2}) \\cdot s^{-1}}) = \\mathrm{J/(J \\cdot m^{-2})} = \\mathrm{m}^2$。这是不正确的。重新评估符号表达式和单位。\n错误在于单位推导。公式 $\\Delta s_{\\max} = \\frac{2 E_T \\delta\\kappa_{\\max}}{|q| c G}$ 在量纲上是正确的：\n$\\frac{[\\mathrm{J}][\\mathrm{m}^{-1}]}{[\\mathrm{C}][\\mathrm{m/s}][\\mathrm{T/m}]} = \\frac{[\\mathrm{N} \\cdot \\mathrm{m}][\\mathrm{m}^{-1}]}{[\\mathrm{C}][\\mathrm{m/s}][\\mathrm{N \\cdot s / (C \\cdot m)}][\\mathrm{m}^{-1}]} = \\frac{[\\mathrm{N}]}{[\\mathrm{N}][\\mathrm{m}^{-1}]} = [\\mathrm{m}]$。该表达式是有效的。\n\n继续数值计算：\n$$ \\Delta s_{\\max} = \\frac{10^6}{2.99792458 \\times 10^8 \\times 0.05}\\ \\mathrm{m} $$\n$$ \\Delta s_{\\max} = \\frac{10^6}{0.149896229 \\times 10^8}\\ \\mathrm{m} = \\frac{10^6}{1.49896229 \\times 10^7}\\ \\mathrm{m} $$\n$$ \\Delta s_{\\max} = \\frac{1}{14.9896229}\\ \\mathrm{m} \\approx 0.0667128\\ \\mathrm{m} $$\n问题要求结果以厘米为单位，所以我们乘以100：\n$$ \\Delta s_{\\max} \\approx 6.67128\\ \\mathrm{cm} $$\n四舍五入到三位有效数字，我们得到：\n$$ \\Delta s_{\\max} \\approx 6.67\\ \\mathrm{cm} $$",
            "answer": "$$\\boxed{6.67}$$"
        },
        {
            "introduction": "在模拟了粒子径迹之后，下一步是模拟探测器如何响应粒子的穿过。这涉及到对电子学噪声和硬件阈值变化等真实世界效应的建模，这些效应共同决定了探测器的效率。本练习  旨在通过推导并实现探测器效率“开启曲线”（S-curve）的解析形式，来实践如何运用统计模型描述探测器宏观性能，这是一个连接微观物理过程和探测器整体响应的关键技能。",
            "id": "3536201",
            "problem": "考虑一个二元阈值径迹探测器模块，其中每个读出通道在沉积电荷与电子学噪声之和超过该通道的阈值时产生一次击中。令沉积电荷表示为 $q$，单位为千电子电荷 $(\\mathrm{ke})$，其中 $1\\,\\mathrm{ke} = 10^{3}$ 个电子。每个通道的电子学噪声被建模为一个高斯随机变量 $n \\sim \\mathcal{N}(0,\\sigma_{n}^{2})$，其中 $\\sigma_{n}$ 的单位为 $\\mathrm{ke}$。模块中各个通道的阈值不完全相同；它们根据高斯分布 $T \\sim \\mathcal{N}(T_{0},\\sigma_{T}^{2})$ 弥散，其中 $T_{0}$ 和 $\\sigma_{T}$ 的单位均为 $\\mathrm{ke}$。假设 $n$ 和 $T$ 是统计独立的。\n\n对于一个固定的阈值 $T$，单个通道在 $q + n > T$ 时记录一次击中。因此，单通道响应，即在给定 $q$ 和 $T$ 的情况下的击中概率，被定义为含噪信号超过阈值的事件。平均模块效率开启曲线，记为 $\\bar{\\epsilon}(q)$，是单通道响应对阈值弥散的期望平均值，可以写成单通道响应与阈值分布的卷积：\n$$\n\\bar{\\epsilon}(q) = \\int_{-\\infty}^{+\\infty} \\epsilon(q \\mid T)\\, p_{T}(T)\\, dT,\n$$\n其中 $\\epsilon(q \\mid T)$ 是阈值为 $T$ 时的单通道响应，$p_{T}(T)$ 是 $T$ 的概率密度函数。累积分布函数 (CDF) 指的是概率密度函数从 $-\\infty$ 到一个给定值的积分。\n\n您的任务是，从高斯随机变量和独立性的基本定义出发，通过将卷积解释为独立高斯随机变量之和超过零的概率，来推导 $\\bar{\\epsilon}(q)$ 的闭式表达式。然后实现一个程序，用于计算指定参数集和电荷样本下的 $\\bar{\\epsilon}(q)$。\n\n单位与数值说明：\n- 输入参数 $q$、$T_{0}$、$\\sigma_{n}$ 和 $\\sigma_{T}$ 的单位均为 $\\mathrm{ke}$。\n- 输出 $\\bar{\\epsilon}(q)$ 是无单位的，并且必须以 $0$ 到 $1$ 之间的实数报告。\n- 所有报告的数值结果必须四舍五入到 $6$ 位小数。\n\n测试组：\n为以下三个参数集和 $q$ 值列表计算 $\\bar{\\epsilon}(q)$。按给定顺序追加所有 $q$ 的结果，并按所列顺序追加所有测试用例的结果。\n\n1. 一般情况（理想路径）：$T_{0} = 20$，$\\sigma_{n} = 0.8$，$\\sigma_{T} = 2$，其中 $q \\in \\{15, 18, 20, 22, 25\\}$。\n2. 无阈值弥散（边界情况）：$T_{0} = 20$，$\\sigma_{n} = 1$，$\\sigma_{T} = 0$，其中 $q \\in \\{19, 20, 21\\}$。\n3. 阈值弥散占主导（边缘情况）：$T_{0} = 20$，$\\sigma_{n} = 0.01$，$\\sigma_{T} = 5$，其中 $q \\in \\{10, 15, 20, 25, 30\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的元素按测试用例排序，然后按指定的 $q$ 值排序（例如，$[r_{1},r_{2},\\dots]$）。每个 $r_{i}$ 都必须是四舍五入到 $6$ 位小数的浮点数。",
            "solution": "问题要求推导平均模块效率 $\\bar{\\epsilon}(q)$ 的闭式表达式，并针对指定参数进行数值评估。分析始于对问题陈述的严格验证。\n\n给定条件如下：\n- 沉积电荷：$q$（单位 $\\mathrm{ke}$）。\n- 单通道电子学噪声：$n$，一个服从分布 $n \\sim \\mathcal{N}(0, \\sigma_{n}^{2})$ 的高斯随机变量。\n- 单通道阈值：$T$，一个服从分布 $T \\sim \\mathcal{N}(T_{0}, \\sigma_{T}^{2})$ 的高斯随机变量。\n- 统计独立性：$n$ 和 $T$ 是独立的随机变量。\n- 对于固定阈值 $T$ 的击中条件：$q + n  T$。\n- 给定 $T$ 的单通道响应：$\\epsilon(q \\mid T) = P(q + n  T \\mid T)$。\n- 平均模块效率：$\\bar{\\epsilon}(q) = \\int_{-\\infty}^{+\\infty} \\epsilon(q \\mid T)\\, p_{T}(T)\\, dT$，其中 $p_{T}(T)$ 是 $T$ 的概率密度函数 (PDF)。\n\n该问题具有科学依据，因为此模型是探测器响应的标准表示。问题是适定的，所有变量、参数和分布都有清晰的定义，确保可以推导出唯一的解。语言客观且正式。满足有效问题的所有条件。\n\n推导过程如下。平均模块效率 $\\bar{\\epsilon}(q)$ 定义为单通道响应 $\\epsilon(q \\mid T)$ 在阈值 $T$ 的分布上的期望。\n$$\n\\bar{\\epsilon}(q) = E_{T}[\\epsilon(q \\mid T)] = E_{T}[P(q + n  T \\mid T)]\n$$\n根据全概率定律（或迭代期望），这等价于发生击中的无条件概率：\n$$\n\\bar{\\epsilon}(q) = P(q + n  T)\n$$\n这种解释避免了对卷积积分进行直接且更复杂的计算。通过分析事件 $q + n  T$ 的概率即可解决此问题。为方便起见，我们重新排列不等式，将随机变量 $n$ 和 $T$ 组合在一起：\n$$\nq + n - T  0\n$$\n我们定义一个新的随机变量 $S = n - T$。问题现在转化为求概率 $P(q + S  0)$，这等价于 $P(S  -q)$。\n\n变量 $S$ 是两个独立高斯随机变量的线性组合。此类组合的性质是公认的。\n1. 随机变量 $n$ 服从分布 $n \\sim \\mathcal{N}(\\mu_{n}, \\sigma_{n}^{2})$，其中 $\\mu_{n}=0$。\n2. 随机变量 $T$ 服从分布 $T \\sim \\mathcal{N}(\\mu_{T}, \\sigma_{T}^{2})$，其中 $\\mu_{T}=T_{0}$。\n3. 随机变量 $-T$ 也是高斯变量。如果一个随机变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，那么 $aX+b \\sim \\mathcal{N}(a\\mu+b, a^2\\sigma^2)$。因此，$-T = (-1)T + 0$ 服从分布 $-T \\sim \\mathcal{N}(-T_{0}, (-1)^2\\sigma_{T}^{2}) = \\mathcal{N}(-T_{0}, \\sigma_{T}^{2})$。\n\n由于 $n$ 和 $T$ 是独立的，所以 $n$ 和 $-T$ 也是独立的。因此，和 $S = n + (-T)$ 是一个高斯随机变量。其均值 $\\mu_{S}$ 是其分量均值的和：\n$$\n\\mu_{S} = E[n - T] = E[n] - E[T] = 0 - T_{0} = -T_{0}\n$$\n其方差 $\\sigma_{S}^{2}$ 是其独立分量方差的和：\n$$\n\\sigma_{S}^{2} = \\mathrm{Var}(n - T) = \\mathrm{Var}(n) + \\mathrm{Var}(-T) = \\sigma_{n}^{2} + \\sigma_{T}^{2}\n$$\n因此，随机变量 $S$ 服从分布 $S \\sim \\mathcal{N}(-T_{0}, \\sigma_{n}^{2} + \\sigma_{T}^{2})$。我们定义一个有效总标准差 $\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{n}^{2} + \\sigma_{T}^{2}}$。\n\n我们现在计算概率 $P(S  -q)$。为此，我们通过定义一个新变量 $Z$ 来标准化变量 $S$：\n$$\nZ = \\frac{S - \\mu_{S}}{\\sigma_{S}} = \\frac{S - (-T_{0})}{\\sigma_{\\mathrm{eff}}} = \\frac{S + T_{0}}{\\sigma_{\\mathrm{eff}}}\n$$\n变量 $Z$ 服从标准正态分布 $Z \\sim \\mathcal{N}(0, 1)$。我们将不等式 $S  -q$ 转换为关于 $Z$ 的不等式：\n$$\nS  -q \\implies S + T_{0}  -q + T_{0} \\implies \\frac{S + T_{0}}{\\sigma_{\\mathrm{eff}}}  \\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\n$$\n所以，我们有：\n$$\n\\bar{\\epsilon}(q) = P(S  -q) = P\\left(Z  \\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n对于标准正态变量 $Z$，概率 $P(Z  z)$ 由 $1 - \\Phi(z)$ 给出，其中 $\\Phi(z)$ 是标准正态分布的累积分布函数 (CDF)。\n$$\n\\bar{\\epsilon}(q) = 1 - \\Phi\\left(\\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n根据标准正态分布的对称性，有 $\\Phi(-z) = 1 - \\Phi(z)$。应用此性质，我们得到最终的紧凑表达式：\n$$\n\\bar{\\epsilon}(q) = \\Phi\\left(-\\frac{T_{0} - q}{\\sigma_{\\mathrm{eff}}}\\right) = \\Phi\\left(\\frac{q - T_{0}}{\\sigma_{\\mathrm{eff}}}\\right)\n$$\n代入 $\\sigma_{\\mathrm{eff}}$ 的定义，平均模块效率的闭式解为：\n$$\n\\bar{\\epsilon}(q) = \\Phi\\left(\\frac{q - T_{0}}{\\sqrt{\\sigma_{n}^{2} + \\sigma_{T}^{2}}}\\right)\n$$\n该表达式在探测器物理学中被称为“S曲线”或开启曲线。标准正态CDF通过 $\\Phi(z) = \\frac{1}{2}\\left[1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right]$ 与误差函数 $\\mathrm{erf}(x)$ 相关联。这使得可以使用标准库函数进行数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the mean module efficiency for given detector parameters and charge values.\n    \"\"\"\n\n    # Test suite:\n    # Each tuple contains (T0, sigma_n, sigma_T, list_of_q_values)\n    # All charge and threshold parameters are in units of kilo-electron charge (ke).\n    test_cases = [\n        # 1. General case (happy path)\n        (20.0, 0.8, 2.0, [15.0, 18.0, 20.0, 22.0, 25.0]),\n\n        # 2. No threshold dispersion (boundary case)\n        (20.0, 1.0, 0.0, [19.0, 20.0, 21.0]),\n\n        # 3. Dominant threshold dispersion (edge case)\n        (20.0, 0.01, 5.0, [10.0, 15.0, 20.0, 25.0, 30.0]),\n    ]\n\n    all_results = []\n\n    for T0, sigma_n, sigma_T, q_values in test_cases:\n        # The total effective standard deviation is the quadrature sum of the\n        # noise and threshold standard deviations.\n        # sigma_eff = sqrt(sigma_n^2 + sigma_T^2)\n        # Using np.hypot is numerically stable for cases where one term is much larger.\n        sigma_eff = np.hypot(sigma_n, sigma_T)\n\n        for q in q_values:\n            # The argument of the CDF. If sigma_eff is zero, this can lead to division by zero.\n            # However, sigma_eff can only be zero if both sigma_n and sigma_T are zero,\n            # which would make the response a step function. The test cases avoid this singularity.\n            if sigma_eff  0:\n                z = (q - T0) / sigma_eff\n                # The mean efficiency is the CDF of the standard normal distribution\n                # evaluated at z.\n                efficiency = norm.cdf(z)\n            else:\n                # Handle the deterministic case where all noise/dispersion is zero.\n                # The response is a Heaviside step function.\n                efficiency = 1.0 if q  T0 else (0.5 if q == T0 else 0.0)\n\n            # Round the result to 6 decimal places as required.\n            all_results.append(round(efficiency, 6))\n\n    # Format the final output as a comma-separated list in brackets.\n    # Using map(str, ...) ensures float representation without scientific notation\n    # for small numbers after rounding.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "径迹重建完成后，其参数被用于物理分析，例如通过测量撞击参数来识别短寿命粒子的衰变。这些测量的精度受到探测器分辨率的直接影响，特别是主要作用点（primary vertex）的位置不确定性。本练习  侧重于不确定性传播，要求你分析计算主要作用点测量误差如何影响横向撞击参数 $d_0$ 和纵向撞击参数 $z_0$ 的偏差与分辨率，这是评估探测器物理分析能力的一项核心任务。",
            "id": "3536226",
            "problem": "考虑一个放置在均匀磁场中的径迹探测器。在相互作用点附近的短距离内，带电粒子的径迹可以近似为直线。真实的初级顶点被假定在原点。测量出的初级顶点位置被建模为一个随机向量 $\\delta \\mathbf{r} = (\\delta x, \\delta y, \\delta z)$，它表示顶点位置相对于原点的测量误差。该测量误差由一个多元正态分布建模，其均值向量为 $\\boldsymbol{\\mu}$（单位：米），协方差矩阵为 $\\Sigma$（单位：平方米），其中可能包含各分量之间的相关性。在稠密环境中，由于重建偏差和分辨率下降，$\\boldsymbol{\\mu}$ 和 $\\Sigma$ 都可能偏离理想的低密度情况下的数值。\n\n在原点附近，一条径迹由一个穿过原点的直线表示，其单位方向向量为 $\\hat{\\mathbf{u}}(\\phi, \\theta) = (\\cos \\phi \\sin \\theta, \\sin \\phi \\sin \\theta, \\cos \\theta)$，其中 $\\phi$ 是横向平面内的方位角（单位：弧度），$\\theta$ 是从 $z$ 轴测量的极角（单位：弧度）。定义横向单位切向量和法向量分别为 $\\hat{\\mathbf{t}}(\\phi) = (\\cos \\phi, \\sin \\phi)$ 和 $\\hat{\\mathbf{n}}(\\phi) = (-\\sin \\phi, \\cos \\phi)$。\n\n带符号的横向影响参数 $d_0$ 定义为径迹与测量的主顶点之间的横向最近距离，其符号约定在右手坐标系中由横向法向量 $\\hat{\\mathbf{n}}(\\phi)$ 决定。纵向影响参数 $z_0$ 定义为径迹在横向最近点的 $z$ 坐标与测量的主顶点的 $z$ 坐标之差。\n\n假设主顶点位移和局部径迹曲率很小，从而影响参数偏差可以相对于 $\\delta \\mathbf{r}$ 进行线性化。将 $\\delta \\mathbf{r}$ 视为服从所提供的均值 $\\boldsymbol{\\mu}$ 和协方差矩阵 $\\Sigma$ 的多元正态分布。对于一个径迹系综，计算：\n1. 系综平均 $d_0$ 偏差（单位：米）。\n2. 系综平均 $z_0$ 偏差（单位：米）。\n3. $d_0$ 偏差的系综均方根（RMS）（单位：米），定义为在主顶点分布和径迹样本上对 $d_0^2$ 进行系综平均后再开平方根。\n4. $z_0$ 偏差的系综均方根（RMS）（单位：米），定义类似。\n\n角度必须以弧度为单位。所有距离必须以米为单位表示。你的程序不能执行任何事件级别的蒙特卡洛抽样；相反，你必须基于线性化和多元正态分布的性质使用解析传播。系综平均必须使用指定的权重对所提供的有限径迹集合进行计算。\n\n测试套件：\n对于每个测试用例，会给出一组径迹角度和权重，以及 $\\boldsymbol{\\mu}$ 和 $\\Sigma$。协方差矩阵 $\\Sigma$ 是对称的，其元素以平方米为单位给出。在所有情况下，答案都以米为单位。\n\n- 测试用例1（低密度基线）：\n  - $\\boldsymbol{\\mu} = (0,\\ 0,\\ 0)$。\n  - $\\Sigma$ 元素：\n    - $\\Sigma_{xx} = (20 \\times 10^{-6})^2$, $\\Sigma_{yy} = (20 \\times 10^{-6})^2$, $\\Sigma_{zz} = (40 \\times 10^{-6})^2$,\n    - $\\Sigma_{xy} = \\Sigma_{xz} = \\Sigma_{yz} = 0$。\n  - 径迹（每个权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.0,\\ 1.3)$，\n    - $(\\phi,\\ \\theta) = (1.0,\\ 1.0)$，\n    - $(\\phi,\\ \\theta) = (2.3,\\ 0.8)$，\n    - $(\\phi,\\ \\theta) = (3.0,\\ \\frac{\\pi}{2})$，\n    - $(\\phi,\\ \\theta) = (4.2,\\ 1.2)$。\n\n- 测试用例2（具有各向异性横向分辨率和非零均值偏差的稠密环境）：\n  - $\\boldsymbol{\\mu} = (10 \\times 10^{-6},\\ -5 \\times 10^{-6},\\ 30 \\times 10^{-6})$。\n  - $\\Sigma$ 元素：\n    - $\\Sigma_{xx} = (60 \\times 10^{-6})^2$, $\\Sigma_{yy} = (40 \\times 10^{-6})^2$, $\\Sigma_{zz} = (80 \\times 10^{-6})^2$,\n    - $\\Sigma_{xy} = 0.3 \\times (60 \\times 10^{-6}) \\times (40 \\times 10^{-6})$,\n    - $\\Sigma_{xz} = \\Sigma_{yz} = 0$。\n  - 径迹（每个权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.2,\\ 1.4)$,\n    - $(\\phi,\\ \\theta) = (1.1,\\ 0.9)$,\n    - $(\\phi,\\ \\theta) = (2.5,\\ 1.1)$,\n    - $(\\phi,\\ \\theta) = (3.7,\\ 1.2)$,\n    - $(\\phi,\\ \\theta) = (5.0,\\ 0.7)$,\n    - $(\\phi,\\ \\theta) = (0.8,\\ 1.3)$。\n\n- 测试用例3（具有x–z相关的向前区径迹混合）：\n  - $\\boldsymbol{\\mu} = (0,\\ 0,\\ 15 \\times 10^{-6})$。\n  - $\\Sigma$ 元素：\n    - $\\Sigma_{xx} = (50 \\times 10^{-6})^2$, $\\Sigma_{yy} = (50 \\times 10^{-6})^2$, $\\Sigma_{zz} = (70 \\times 10^{-6})^2$,\n    - $\\Sigma_{xy} = -0.2 \\times (50 \\times 10^{-6}) \\times (50 \\times 10^{-6})$,\n    - $\\Sigma_{xz} = 0.2 \\times (50 \\times 10^{-6}) \\times (70 \\times 10^{-6})$,\n    - $\\Sigma_{yz} = 0$。\n  - 径迹（每个权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.0,\\ 0.25)$,\n    - $(\\phi,\\ \\theta) = (1.5,\\ 0.35)$,\n    - $(\\phi,\\ \\theta) = (\\pi,\\ 0.5)$,\n    - $(\\phi,\\ \\theta) = (4.0,\\ 0.9)$。\n\n- 测试用例4（确定性偏差，零协方差）：\n  - $\\boldsymbol{\\mu} = (30 \\times 10^{-6},\\ -30 \\times 10^{-6},\\ -20 \\times 10^{-6})$。\n  - $\\Sigma$ 是零矩阵（所有元素为 $0$）。\n  - 径迹（每个权重为 $1$）：\n    - $(\\phi,\\ \\theta) = (0.3,\\ 1.0)$,\n    - $(\\phi,\\ \\theta) = (2.7,\\ 1.2)$,\n    - $(\\phi,\\ \\theta) = (5.5,\\ 0.8)$。\n\n计算与输出规范：\n- 对每个测试用例，计算上面列出的四个量：系综平均 $d_0$，系综平均 $z_0$，系综 RMS $d_0$，系综 RMS $z_0$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”），将测试用例1的四个结果、接着是测试用例2的四个结果、然后是测试用例3、最后是测试用例4的结果连接起来。所有输出都必须以米为单位。",
            "solution": "该问题要求在给定主顶点位置测量误差的统计模型下，计算粒子径迹的横向（$d_0$）和纵向（$z_0$）影响参数的系综平均偏差和均方根（RMS）值。我们需要进行解析计算，将顶点测量的误差传播到影响参数。\n\n### 问题形式化\n\n真实主顶点位于原点 $\\mathbf{r}_{true} = (0, 0, 0)$。测量的主顶点位置 $\\mathbf{r}_v$ 相对于真实顶点有一个随机位移向量 $\\delta \\mathbf{r} = (\\delta x, \\delta y, \\delta z)$。该位移被建模为一个三维多元正态分布 $\\delta \\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$，其均值向量为 $\\boldsymbol{\\mu} = (\\mu_x, \\mu_y, \\mu_z)^T$，协方差矩阵为 $\\Sigma$。\n\n一条径迹被近似为一条穿过真实原点的直线，其单位方向向量为 $\\hat{\\mathbf{u}}(\\phi, \\theta) = (\\sin\\theta \\cos\\phi, \\sin\\theta \\sin\\phi, \\cos\\theta)$，其中 $\\phi$ 是方位角，$\\theta$ 是极角。\n\n### 影响参数的推导\n\n首先，我们将影响参数 $d_0$ 和 $z_0$ 表示为顶点位移分量 $\\delta x$、$\\delta y$ 和 $\\delta z$ 的线性函数。\n\n1.  **横向影响参数 ($d_0$)**：带符号的横向影响参数 $d_0$ 是在横向（$x$-$y$）平面内，径迹路径（一条穿过原点的直线）与测量的顶点横向位置 $\\mathbf{r}_{v,T} = (\\delta x, \\delta y)$ 之间的带符号最近距离。符号由其在横向法向量 $\\hat{\\mathbf{n}}(\\phi) = (-\\sin\\phi, \\cos\\phi)$ 上的投影决定。\n    $$d_0 = \\mathbf{r}_{v,T} \\cdot \\hat{\\mathbf{n}}(\\phi) = (\\delta x, \\delta y) \\cdot (-\\sin\\phi, \\cos\\phi)$$\n    $$d_0 = -\\delta x \\sin\\phi + \\delta y \\cos\\phi$$\n    这是 $\\delta \\mathbf{r}$ 的一个线性函数。我们可以写成 $d_0 = \\mathbf{c}_{d_0}^T \\delta \\mathbf{r}$，其中系数向量为 $\\mathbf{c}_{d_0} = (-\\sin\\phi, \\cos\\phi, 0)^T$。\n\n2.  **纵向影响参数 ($z_0$)**：纵向影响参数 $z_0$ 定义为 $z_0 = z_{track} - z_v$，其中 $z_v = \\delta z$ 是测量的顶点 $z$ 坐标，而 $z_{track}$ 是径迹在横向最近点的 $z$ 坐标。从原点到该点的横向路径长度 $s_T$ 是 $\\mathbf{r}_{v,T}$ 在横向径迹方向 $\\hat{\\mathbf{t}}(\\phi) = (\\cos\\phi, \\sin\\phi)$ 上的投影：\n    $$s_T = \\mathbf{r}_{v,T} \\cdot \\hat{\\mathbf{t}}(\\phi) = \\delta x \\cos\\phi + \\delta y \\sin\\phi$$\n    假设 $\\sin\\theta \\neq 0$，沿径迹对应的三维路径长度为 $s = s_T / \\sin\\theta$。径迹在该点的 $z$ 坐标为 $z_{track} = s \\cos\\theta = s_T \\cot\\theta$。\n    $$z_{track} = (\\delta x \\cos\\phi + \\delta y \\sin\\phi) \\cot\\theta$$\n    因此，$z_0$ 是：\n    $$z_0 = (\\delta x \\cos\\phi + \\delta y \\sin\\phi) \\cot\\theta - \\delta z$$\n    这也是 $\\delta \\mathbf{r}$ 的一个线性函数，可写为 $z_0 = \\mathbf{c}_{z_0}^T \\delta \\mathbf{r}$，其系数向量为 $\\mathbf{c}_{z_0} = (\\cos\\phi \\cot\\theta, \\sin\\phi \\cot\\theta, -1)^T$。\n\n### 偏差和均方根计算\n\n对于一个泛型量 $Q = \\mathbf{c}^T \\delta \\mathbf{r}$，其中 $\\delta \\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\Sigma)$，其期望值（均值）和方差由随机向量仿射变换的标准法则给出：\n-   均值：$E[Q] = \\mathbf{c}^T E[\\delta \\mathbf{r}] = \\mathbf{c}^T \\boldsymbol{\\mu}$\n-   方差：$\\text{Var}(Q) = \\mathbf{c}^T \\text{Cov}(\\delta \\mathbf{r}) \\mathbf{c} = \\mathbf{c}^T \\Sigma \\mathbf{c}$\n\n均方值与均值和方差的关系为 $E[Q^2] = \\text{Var}(Q) + (E[Q])^2$。下标 $v$ 将表示对顶点分布的期望。\n\n**对于参数为 $(\\phi, \\theta)$ 的单条径迹：**\n\n-   **平均偏差**：\n    $$E_v[d_0] = \\mathbf{c}_{d_0}^T \\boldsymbol{\\mu} = -\\mu_x \\sin\\phi + \\mu_y \\cos\\phi$$\n    $$E_v[z_0] = \\mathbf{c}_{z_0}^T \\boldsymbol{\\mu} = (\\mu_x \\cos\\phi + \\mu_y \\sin\\phi) \\cot\\theta - \\mu_z$$\n\n-   **方差**：\n    $$\\text{Var}_v(d_0) = \\mathbf{c}_{d_0}^T \\Sigma \\mathbf{c}_{d_0} = \\Sigma_{xx} \\sin^2\\phi + \\Sigma_{yy} \\cos^2\\phi - 2\\Sigma_{xy} \\sin\\phi \\cos\\phi$$\n    $$\\text{Var}_v(z_0) = \\mathbf{c}_{z_0}^T \\Sigma \\mathbf{c}_{z_0} = \\cot^2\\theta(\\Sigma_{xx}\\cos^2\\phi + \\Sigma_{yy}\\sin^2\\phi + 2\\Sigma_{xy}\\sin\\phi\\cos\\phi) - 2\\cot\\theta(\\Sigma_{xz}\\cos\\phi + \\Sigma_{yz}\\sin\\phi) + \\Sigma_{zz}$$\n\n-   **均方值**：\n    $$E_v[d_0^2] = \\text{Var}_v(d_0) + (E_v[d_0])^2$$\n    $$E_v[z_0^2] = \\text{Var}_v(z_0) + (E_v[z_0])^2$$\n\n### 系综平均\n\n问题要求计算的量是同时对顶点分布和一个包含 $N$ 条径迹的有限样本 $\\{(\\phi_i, \\theta_i)\\}_{i=1}^N$ 进行平均，每条径迹的权重为 $w_i$。总权重为 $W = \\sum_{i=1}^N w_i$。一个量 $X$ 的系综平均，记作 $\\langle X \\rangle$，计算如下：\n$$\\langle X \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[X_i]$$\n其中 $X_i$ 是为径迹 $i$ 计算的量。\n\n四个需要计算的量是：\n1.  系综平均 $d_0$ 偏差: $\\langle d_0 \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[d_{0, i}]$\n2.  系综平均 $z_0$ 偏差: $\\langle z_0 \\rangle = \\frac{1}{W} \\sum_{i=1}^N w_i E_v[z_{0, i}]$\n3.  $d_0$ 的系综均方根: $\\text{RMS}(d_0) = \\sqrt{\\langle d_0^2 \\rangle} = \\sqrt{\\frac{1}{W} \\sum_{i=1}^N w_i E_v[d_{0, i}^2]}$\n4.  $z_0$ 的系综均方根: $\\text{RMS}(z_0) = \\sqrt{\\langle z_0^2 \\rangle} = \\sqrt{\\frac{1}{W} \\sum_{i=1}^N w_i E_v[z_{0, i}^2]}$\n\n这些公式为每个测试用例提供了一个完整的解析计算方案，无需进行蒙特卡洛模拟。具体实现涉及将这些公式应用于给定的 $\\boldsymbol{\\mu}$、$\\Sigma$ 和径迹样本的数值数据。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n\n    def build_sigma(params):\n        \"\"\"\n        Builds the 3x3 symmetric covariance matrix from a dictionary of parameters.\n        \"\"\"\n        sigma = np.zeros((3, 3))\n        sigma[0, 0] = params.get('xx', 0.0)\n        sigma[1, 1] = params.get('yy', 0.0)\n        sigma[2, 2] = params.get('zz', 0.0)\n        sigma[0, 1] = sigma[1, 0] = params.get('xy', 0.0)\n        sigma[0, 2] = sigma[2, 0] = params.get('xz', 0.0)\n        sigma[1, 2] = sigma[2, 1] = params.get('yz', 0.0)\n        return sigma\n\n    def calculate_ensemble_stats(mu, sigma, tracks):\n        \"\"\"\n        Calculates ensemble statistics for a given mu, sigma, and set of tracks.\n        \"\"\"\n        sum_mean_d0 = 0.0\n        sum_mean_z0 = 0.0\n        sum_mean_sq_d0 = 0.0\n        sum_mean_sq_z0 = 0.0\n        total_weight = 0.0\n\n        mu_x, mu_y, mu_z = mu\n        s_xx, s_xy, s_xz = sigma[0, 0], sigma[0, 1], sigma[0, 2]\n        s_yy, s_yz = sigma[1, 1], sigma[1, 2]\n        s_zz = sigma[2, 2]\n\n        for phi, theta, weight in tracks:\n            sin_phi = np.sin(phi)\n            cos_phi = np.cos(phi)\n            \n            # Handle cot(theta) carefully for theta near multiples of pi.\n            # For this problem's inputs, this is safe.\n            sin_theta = np.sin(theta)\n            if np.isclose(sin_theta, 0):\n                # For tracks along the z-axis, cot(theta) is infinite.\n                # z0 definition is ill-defined. However, test cases avoid this.\n                # If needed, a special handling would be placed here.\n                # For this problem, we can assume sin_theta is not zero.\n                cot_theta = np.inf if np.cos(theta)  0 else -np.inf\n            else:\n                cot_theta = np.cos(theta) / sin_theta\n\n            # Mean biases for this track\n            mean_d0 = -mu_x * sin_phi + mu_y * cos_phi\n            mean_z0 = (mu_x * cos_phi + mu_y * sin_phi) * cot_theta - mu_z\n\n            # Variances for this track\n            var_d0 = s_xx * sin_phi**2 + s_yy * cos_phi**2 - 2 * s_xy * sin_phi * cos_phi\n            \n            var_z0_term1 = (s_xx * cos_phi**2 + s_yy * sin_phi**2 + 2 * s_xy * sin_phi * cos_phi) * cot_theta**2\n            var_z0_term2 = -2 * (s_xz * cos_phi + s_yz * sin_phi) * cot_theta\n            var_z0_term3 = s_zz\n            var_z0 = var_z0_term1 + var_z0_term2 + var_z0_term3\n            \n            # Mean squares for this track\n            mean_sq_d0 = var_d0 + mean_d0**2\n            mean_sq_z0 = var_z0 + mean_z0**2\n\n            # Accumulate weighted sums\n            sum_mean_d0 += weight * mean_d0\n            sum_mean_z0 += weight * mean_z0\n            sum_mean_sq_d0 += weight * mean_sq_d0\n            sum_mean_sq_z0 += weight * mean_sq_z0\n            total_weight += weight\n\n        # Final ensemble averages\n        ensemble_mean_d0 = sum_mean_d0 / total_weight\n        ensemble_mean_z0 = sum_mean_z0 / total_weight\n        ensemble_mean_sq_d0 = sum_mean_sq_d0 / total_weight\n        ensemble_mean_sq_z0 = sum_mean_sq_z0 / total_weight\n\n        # RMS values\n        ensemble_rms_d0 = np.sqrt(ensemble_mean_sq_d0)\n        ensemble_rms_z0 = np.sqrt(ensemble_mean_sq_z0)\n\n        return [ensemble_mean_d0, ensemble_mean_z0, ensemble_rms_d0, ensemble_rms_z0]\n\n    # Test Case Definitions\n    test_cases = [\n        # Test Case 1\n        {\n            \"mu\": np.array([0.0, 0.0, 0.0]),\n            \"sigma_params\": {\n                'xx': (20e-6)**2, 'yy': (20e-6)**2, 'zz': (40e-6)**2,\n                'xy': 0.0, 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.0, 1.3, 1.0), (1.0, 1.0, 1.0), (2.3, 0.8, 1.0),\n                (3.0, np.pi/2, 1.0), (4.2, 1.2, 1.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"mu\": np.array([10e-6, -5e-6, 30e-6]),\n            \"sigma_params\": {\n                'xx': (60e-6)**2, 'yy': (40e-6)**2, 'zz': (80e-6)**2,\n                'xy': 0.3 * (60e-6) * (40e-6), 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.2, 1.4, 1.0), (1.1, 0.9, 1.0), (2.5, 1.1, 1.0),\n                (3.7, 1.2, 1.0), (5.0, 0.7, 1.0), (0.8, 1.3, 1.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"mu\": np.array([0.0, 0.0, 15e-6]),\n            \"sigma_params\": {\n                'xx': (50e-6)**2, 'yy': (50e-6)**2, 'zz': (70e-6)**2,\n                'xy': -0.2 * (50e-6) * (50e-6), 'xz': 0.2 * (50e-6) * (70e-6), 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.0, 0.25, 1.0), (1.5, 0.35, 1.0), (np.pi, 0.5, 1.0), (4.0, 0.9, 1.0)\n            ]\n        },\n        # Test Case 4\n        {\n            \"mu\": np.array([30e-6, -30e-6, -20e-6]),\n            \"sigma_params\": {\n                'xx': 0.0, 'yy': 0.0, 'zz': 0.0, 'xy': 0.0, 'xz': 0.0, 'yz': 0.0\n            },\n            \"tracks\": [\n                (0.3, 1.0, 1.0), (2.7, 1.2, 1.0), (5.5, 0.8, 1.0)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        mu = case['mu']\n        sigma = build_sigma(case['sigma_params'])\n        tracks = case['tracks']\n        results = calculate_ensemble_stats(mu, sigma, tracks)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}