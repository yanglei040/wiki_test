{
    "hands_on_practices": [
        {
            "introduction": "此练习旨在为顶点拟合建立基石：基于高斯误差的最大似然原理推导出的加权最小二乘法。通过实现其直接解（等同于单步牛顿法），您不仅能构建一个基础的拟合器，还能分析并量化一个关键的现实问题：来自衰变次级径迹的污染如何对主顶点估计产生偏倚。这项实践对于理解基础拟合器的性能基线和局限性至关重要。",
            "id": "3528935",
            "problem": "你的任务是为高能物理中的带电粒子径迹开发一个数学上具有良好原理且计算上稳健的最大似然主顶点拟合器，该拟合器集成了牛顿法更新步骤以及在存在位移次级衰变情况下的估计量偏差分析。每条径迹为其到某个公共顶点的最近接近点提供一个三维测量值。对于径迹 $i$，其测量位置是一个向量 $\\vec{r}_i \\in \\mathbb{R}^3$（单位为 $\\mathrm{mm}$），并带有一个对称正定协方差矩阵 $C_i \\in \\mathbb{R}^{3 \\times 3}$（单位为 $\\mathrm{mm}^2$）。假设所有径迹的测量误差都是独立的高斯误差。主顶点位置为 $\\vec{v} \\in \\mathbb{R}^3$（单位为 $\\mathrm{mm}$）。目标是通过最小化二次目标函数来估计 $\\vec{v}$：\n$$\n\\chi^2(\\vec{v}) = \\sum_{i=1}^N (\\vec{r}_i - \\vec{v})^\\top C_i^{-1} (\\vec{r}_i - \\vec{v}),\n$$\n该函数是负对数似然（相差一个加性常数），与独立高斯不确定性一致。\n\n从高斯似然的定义、测量的独立性以及对称正定协方差矩阵的性质出发，从第一性原理推导使 $\\chi^2(\\vec{v})$ 最小化的估计量 $\\hat{\\vec{v}}$ 所满足的平稳条件，并利用 $\\chi^2(\\vec{v})$ 的梯度和Hessian矩阵推导牛顿法更新步骤。解释为什么对于二次目标函数，牛顿法能在一步内收敛到唯一最小值点。实现牛顿法更新，为提供的测试集计算 $\\hat{\\vec{v}}$。\n\n然后，分析当一部分比例为 $\\epsilon$ 的径迹源于位于 $\\vec{v}_0 + \\vec{d}$ 的位移次级顶点，而其余比例为 $1 - \\epsilon$ 的径迹源于位于 $\\vec{v}_0$ 的真实主顶点时，估计量的偏差。假设位移径迹的测量值中心在 $\\vec{v}_0 + \\vec{d}$，主顶点径迹的测量值中心在 $\\vec{v}_0$，协方差均为指定的 $C_i$。推导预期估计量偏差向量 $\\mathbb{E}[\\hat{\\vec{v}} - \\vec{v}_0]$，用逆协方差 $W_i = C_i^{-1}$、位移 $\\vec{d}$ 和位移径迹的污染集 $S$ 来表示。解释在何种条件下偏差简化为 $\\epsilon \\vec{d}$，以及协方差的异质性如何改变偏差。对于下方的每个测试用例，通过牛顿法更新计算拟合的 $\\hat{\\vec{v}}$，并报告偏差大小 $\\|\\hat{\\vec{v}} - \\vec{v}_0\\|_2$（单位为 $\\mathrm{mm}$）。\n\n严格使用以下测试集，其中所有向量单位为 $\\mathrm{mm}$，所有协方差矩阵单位为 $\\mathrm{mm}^2$。对于每个测试用例，程序必须按如下方式构造观测值：对于主顶点集 $P$ 中的径迹，设置 $\\vec{r}_i = \\vec{v}_0$；对于位移次级顶点集 $S$ 中的径迹，设置 $\\vec{r}_i = \\vec{v}_0 + \\vec{d}$。不允许进行随机抽样；所有输入都是确定性的。在所有情况下，牛顿法都必须在三维空间中应用，并使用完整的 $3 \\times 3$ 矩阵。\n\n测试用例 1（各向同性，等权重，部分污染）：\n- $N = 12$\n- $\\vec{v}_0 = (0.0, 0.0, 0.0)$\n- $\\vec{d} = (0.4, -0.1, 0.2)$\n- $\\epsilon = 0.25$，其中 $S = \\{0, 1, 2\\}$ 且 $P = \\{3, 4, 5, 6, 7, 8, 9, 10, 11\\}$\n- 对所有 $i$，$C_i = \\operatorname{diag}(0.05^2, 0.05^2, 0.05^2)$\n\n测试用例 2（各向同性，等权重，无污染）：\n- $N = 8$\n- $\\vec{v}_0 = (1.0, -1.0, 0.5)$\n- $\\vec{d} = (0.3, 0.3, -0.1)$\n- $\\epsilon = 0.0$，其中 $S = \\emptyset$ 且 $P = \\{0, 1, 2, 3, 4, 5, 6, 7\\}$\n- 对所有 $i$，$C_i = \\operatorname{diag}(0.02^2, 0.02^2, 0.02^2)$\n\n测试用例 3（各向同性，等权重，完全污染）：\n- $N = 5$\n- $\\vec{v}_0 = (0.0, 0.0, 0.0)$\n- $\\vec{d} = (-0.2, 0.5, 0.1)$\n- $\\epsilon = 1.0$，其中 $S = \\{0, 1, 2, 3, 4\\}$ 且 $P = \\emptyset$\n- 对所有 $i$，$C_i = \\operatorname{diag}(0.02^2, 0.02^2, 0.02^2)$\n\n测试用例 4（各向异性，非均匀权重，污染与较大协方差相关）：\n- $N = 10$\n- $\\vec{v}_0 = (0.2, -0.3, 0.1)$\n- $\\vec{d} = (0.8, 0.0, -0.2)$\n- $\\epsilon = 0.4$，其中 $S = \\{6, 7, 8, 9\\}$ 且 $P = \\{0, 1, 2, 3, 4, 5\\}$\n- 对于 $i \\in P$：$C_i = \\operatorname{diag}(0.01^2, 0.01^2, 0.01^2)$\n- 对于 $i \\in S$：$C_i = \\operatorname{diag}(0.10^2, 0.05^2, 0.02^2)$\n\n测试用例 5（各向异性，方向依赖权重，污染发生在沿 $\\vec{d}$ 方向精确的径迹中）：\n- $N = 9$\n- $\\vec{v}_0 = (0.0, 0.0, 0.0)$\n- $\\vec{d} = (0.05, 0.60, 0.0)$\n- $\\epsilon = \\tfrac{1}{3}$，其中 $S = \\{0, 1, 2\\}$ 且 $P = \\{3, 4, 5, 6, 7, 8\\}$\n- 对于 $i \\in \\{0, 1, 2\\}$：$C_i = \\operatorname{diag}(0.2^2, 0.02^2, 0.02^2)$\n- 对于 $i \\in \\{3, 4, 5\\}$：$C_i = \\operatorname{diag}(0.02^2, 0.2^2, 0.02^2)$\n- 对于 $i \\in \\{6, 7, 8\\}$：$C_i = \\operatorname{diag}(0.02^2, 0.02^2, 0.2^2)$\n\n你的程序必须：\n- 对于每个测试用例，按规定构造测量集 $\\{\\vec{r}_i\\}_{i=1}^N$ 和协方差集 $\\{C_i\\}_{i=1}^N$。\n- 从任意初始猜测 $\\vec{v}^{(0)}$ 开始，计算 $\\chi^2(\\vec{v})$ 的牛顿法更新，并获得拟合顶点 $\\hat{\\vec{v}}$。\n- 计算每个测试用例的偏差大小 $\\|\\hat{\\vec{v}} - \\vec{v}_0\\|_2$（单位为 $\\mathrm{mm}$）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含五个测试用例的偏差大小，形式为方括号括起来的逗号分隔列表，单位为 $\\mathrm{mm}$，每个值四舍五入到六位小数（例如，$[\\text{bias}_1,\\text{bias}_2,\\text{bias}_3,\\text{bias}_4,\\text{bias}_5]$）。",
            "solution": "该问题是有效的，因为它在科学上基于统计估计理论，问题设定良好（well-posed）且具有唯一解，并使用客观、精确的数学形式化语言进行了描述。它代表了一个标准的加权最小二乘问题，这对于独立高斯误差而言等价于最大似然估计，是实验数据分析中的一项基本任务。所有参数和条件都已明确指定。\n\n该问题要求推导和实现一个最大似然主顶点拟合器，包括对估计量偏差的分析。我们将首先推导估计量和牛顿-拉夫逊（Newton-Raphson）优化步骤，然后分析在径迹样本受污染情况下的偏差。\n\n**第 1 部分：顶点估计量的推导**\n\n该估计量的基础是最大似然原理。对于一组包含 $N$ 个独立径迹测量值 $\\{\\vec{r}_i\\}_{i=1}^N$，给定真实顶点位置 $\\vec{v}$，观测到这些测量值的概率由似然函数 $L(\\vec{v})$ 描述。由于假设测量误差是高斯且独立的，似然函数是各个高斯概率密度函数的乘积：\n$$\nL(\\vec{v}; \\{\\vec{r}_i\\}) = \\prod_{i=1}^N \\frac{1}{\\sqrt{(2\\pi)^3 \\det(C_i)}} \\exp\\left(-\\frac{1}{2} (\\vec{r}_i - \\vec{v})^\\top C_i^{-1} (\\vec{r}_i - \\vec{v})\\right)\n$$\n其中 $\\vec{r}_i \\in \\mathbb{R}^3$ 是径迹 $i$ 的测量最近接近点，而 $C_i \\in \\mathbb{R}^{3 \\times 3}$ 是其对应的协方差矩阵。\n\n最大化似然函数 $L(\\vec{v})$ 等价于最大化其对数，即对数似然函数 $\\ln L(\\vec{v})$，后者在计算上更易于处理：\n$$\n\\ln L(\\vec{v}) = \\sum_{i=1}^N \\left( -\\frac{3}{2}\\ln(2\\pi) - \\frac{1}{2}\\ln(\\det(C_i)) - \\frac{1}{2} (\\vec{r}_i - \\vec{v})^\\top C_i^{-1} (\\vec{r}_i - \\vec{v}) \\right)\n$$\n为了找到使 $\\ln L(\\vec{v})$ 最大化的顶点位置 $\\hat{\\vec{v}}$，我们可以等价地最小化负对数似然。去掉相对于 $\\vec{v}$ 是常数的项后，这等价于最小化目标函数 $\\chi^2(\\vec{v})$：\n$$\n\\chi^2(\\vec{v}) = \\sum_{i=1}^N (\\vec{r}_i - \\vec{v})^\\top C_i^{-1} (\\vec{r}_i - \\vec{v})\n$$\n这是一个加权最小二乘问题，其中每个测量值的权重矩阵是其协方差矩阵的逆，即 $W_i = C_i^{-1}$。鉴于每个 $C_i$ 都是对称正定的，每个 $W_i$ 也同样如此。\n\n**第 2 部分：平稳条件和牛顿法**\n\n为了找到 $\\chi^2(\\vec{v})$ 的最小值，我们寻找其相对于 $\\vec{v}$ 的梯度为零的平稳点。求和中单个项的梯度为：\n$$\n\\nabla_{\\vec{v}} \\left( (\\vec{r}_i - \\vec{v})^\\top W_i (\\vec{r}_i - \\vec{v}) \\right) = -2 W_i (\\vec{r}_i - \\vec{v})\n$$\n整个 $\\chi^2(\\vec{v})$ 函数的梯度，记为 $\\vec{g}(\\vec{v})$，是这些单个梯度的和：\n$$\n\\vec{g}(\\vec{v}) = \\nabla_{\\vec{v}} \\chi^2(\\vec{v}) = \\sum_{i=1}^N -2 W_i (\\vec{r}_i - \\vec{v}) = 2 \\left( \\sum_{i=1}^N W_i \\right) \\vec{v} - 2 \\left( \\sum_{i=1}^N W_i \\vec{r}_i \\right)\n$$\n将梯度设为零，$\\vec{g}(\\hat{\\vec{v}}) = \\vec{0}$，得到平稳条件：\n$$\n\\left( \\sum_{i=1}^N W_i \\right) \\hat{\\vec{v}} = \\sum_{i=1}^N W_i \\vec{r}_i\n$$\n令 $W = \\sum_{i=1}^N W_i$ 为总权重矩阵。估计顶点 $\\hat{\\vec{v}}$ 的解为：\n$$\n\\hat{\\vec{v}} = \\left( \\sum_{i=1}^N W_i \\right)^{-1} \\left( \\sum_{i=1}^N W_i \\vec{r}_i \\right) = W^{-1} \\sum_{i=1}^N W_i \\vec{r}_i\n$$\n该解是测量向量 $\\vec{r}_i$ 的一个广义加权平均，权重为矩阵 $W_i$。\n\n牛顿-拉夫逊方法提供了一个迭代方案来寻找函数的最小值：$\\vec{v}^{(k+1)} = \\vec{v}^{(k)} - [H(\\vec{v}^{(k)})]^{-1} \\vec{g}(\\vec{v}^{(k)})$，其中 $H$ 是 Hessian 矩阵（二阶偏导数矩阵）。\n$\\chi^2(\\vec{v})$ 的 Hessian 矩阵是：\n$$\nH(\\vec{v}) = \\nabla_{\\vec{v}} (\\vec{g}(\\vec{v})^\\top) = \\nabla_{\\vec{v}} \\left( 2 \\vec{v}^\\top \\sum_{i=1}^N W_i - 2 \\sum_{i=1}^N \\vec{r}_i^\\top W_i \\right) = 2 \\sum_{i=1}^N W_i = 2W\n$$\nHessian 矩阵是一个常数矩阵，与 $\\vec{v}$ 无关。这是二次目标函数的一个典型特征。\n将梯度和 Hessian 矩阵代入从任意起始点 $\\vec{v}^{(0)}$ 开始的牛顿法更新规则：\n$$\n\\vec{v}^{(1)} = \\vec{v}^{(0)} - (2W)^{-1} \\left( 2W\\vec{v}^{(0)} - 2 \\sum_{i=1}^N W_i \\vec{r}_i \\right)\n$$\n$$\n\\vec{v}^{(1)} = \\vec{v}^{(0)} - (2W)^{-1}(2W) \\vec{v}^{(0)} + (2W)^{-1}(2) \\sum_{i=1}^N W_i \\vec{r}_i\n$$\n$$\n\\vec{v}^{(1)} = \\vec{v}^{(0)} - \\vec{v}^{(0)} + W^{-1} \\sum_{i=1}^N W_i \\vec{r}_i = W^{-1} \\sum_{i=1}^N W_i \\vec{r}_i\n$$\n第一步的结果 $\\vec{v}^{(1)}$ 正是解析解 $\\hat{\\vec{v}}$。此更新与起始点 $\\vec{v}^{(0)}$ 无关。这表明对于二次目标函数，牛顿法在单步内即可收敛到唯一的最小值点。\n\n**第 3 部分：估计量偏差分析**\n\n现在我们分析当径迹样本被污染时估计量 $\\hat{\\vec{v}}$ 的偏差。比例为 $1-\\epsilon$ 的径迹源于真实主顶点 $\\vec{v}_0$，而比例为 $\\epsilon$ 的径迹源于位移次级顶点 $\\vec{v}_0 + \\vec{d}$。令 $P$ 为主顶点径迹集合，$S$ 为次级顶点径迹集合。问题为该分析指定了确定性测量值：对于 $i \\in P$，$\\vec{r}_i = \\vec{v}_0$；对于 $i \\in S$，$\\vec{r}_i = \\vec{v}_0 + \\vec{d}$。这些可以被解释为期望值 $\\mathbb{E}[\\vec{r}_i]$。\n\n估计量的期望值为：\n$$\n\\mathbb{E}[\\hat{\\vec{v}}] = \\mathbb{E}\\left[ W^{-1} \\sum_{i=1}^N W_i \\vec{r}_i \\right] = W^{-1} \\sum_{i=1}^N W_i \\mathbb{E}[\\vec{r}_i]\n$$\n将求和分解为主顶点集和次级顶点集：\n$$\n\\mathbb{E}[\\hat{\\vec{v}}] = W^{-1} \\left( \\sum_{i \\in P} W_i \\mathbb{E}[\\vec{r}_i] + \\sum_{i \\in S} W_i \\mathbb{E}[\\vec{r}_i] \\right) = W^{-1} \\left( \\sum_{i \\in P} W_i \\vec{v}_0 + \\sum_{i \\in S} W_i (\\vec{v}_0 + \\vec{d}) \\right)\n$$\n令 $W_P = \\sum_{i \\in P} W_i$ 且 $W_S = \\sum_{i \\in S} W_i$。则 $W = W_P + W_S$。\n$$\n\\mathbb{E}[\\hat{\\vec{v}}] = W^{-1} \\left( (W_P + W_S) \\vec{v}_0 + W_S \\vec{d} \\right) = W^{-1} (W \\vec{v}_0 + W_S \\vec{d}) = \\vec{v}_0 + W^{-1} W_S \\vec{d}\n$$\n估计量偏差向量是估计量的期望与真实值 $\\vec{v}_0$ 之间的差：\n$$\n\\text{Bias} = \\mathbb{E}[\\hat{\\vec{v}}] - \\vec{v}_0 = W^{-1} W_S \\vec{d}\n$$\n在特定条件下，偏差会简化为 $\\epsilon \\vec{d}$ 的简单形式。如果所有径迹具有相同的协方差矩阵，$C_i = C_0$ for all $i=1, \\dots, N$，那么它们的权重也相同，$W_i = W_0$。在这种情况下，$W_S = |S| W_0$ 且 $W = N W_0$。偏差变为：\n$$\n\\text{Bias} = (N W_0)^{-1} (|S| W_0) \\vec{d} = \\frac{|S|}{N} (W_0^{-1} W_0) \\vec{d} = \\frac{|S|}{N} \\vec{d} = \\epsilon \\vec{d}\n$$\n这种协方差同质、各向同性的条件在测试用例 1、2 和 3 中得到满足。\n\n当协方差矩阵是异质的时，偏差会被修正。矩阵 $W^{-1} W_S$ 作为线性变换作用于位移向量 $\\vec{d}$。偏差不再必然平行于 $\\vec{d}$ 或按 $\\epsilon$ 缩放。不确定性较小（$W_i$ 较大）的径迹对总权重的贡献更大，从而更有力地将拟合顶点拉向自己。如果受污染的径迹（$i \\in S$）不如主顶点径迹精确（权重较小），因子 $W^{-1}W_S$ 会对位移 $\\vec{d}$ 进行降权，导致偏差较小。相反，如果受污染的径迹比主顶点径迹更精确，它们将产生更强的拉力，导致偏差更大。这种效应在测试用例 4 和 5 中进行了探讨。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the primary vertex fit and bias for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Isotropic, equal weights, partial contamination\",\n            \"N\": 12,\n            \"v0\": np.array([0.0, 0.0, 0.0]),\n            \"d\": np.array([0.4, -0.1, 0.2]),\n            \"S_indices\": {0, 1, 2},\n            \"cov_map\": {\n                \"all\": np.diag([0.05**2, 0.05**2, 0.05**2])\n            },\n            \"track_cov_map_indices\": {\"all_tracks\": list(range(12))}\n        },\n        {\n            \"name\": \"Case 2: Isotropic, equal weights, no contamination\",\n            \"N\": 8,\n            \"v0\": np.array([1.0, -1.0, 0.5]),\n            \"d\": np.array([0.3, 0.3, -0.1]),\n            \"S_indices\": set(),\n            \"cov_map\": {\n                \"all\": np.diag([0.02**2, 0.02**2, 0.02**2])\n            },\n            \"track_cov_map_indices\": {\"all_tracks\": list(range(8))}\n        },\n        {\n            \"name\": \"Case 3: Isotropic, equal weights, full contamination\",\n            \"N\": 5,\n            \"v0\": np.array([0.0, 0.0, 0.0]),\n            \"d\": np.array([-0.2, 0.5, 0.1]),\n            \"S_indices\": {0, 1, 2, 3, 4},\n            \"cov_map\": {\n                \"all\": np.diag([0.02**2, 0.02**2, 0.02**2])\n            },\n            \"track_cov_map_indices\": {\"all_tracks\": list(range(5))}\n        },\n        {\n            \"name\": \"Case 4: Anisotropic, heterogeneous weights\",\n            \"N\": 10,\n            \"v0\": np.array([0.2, -0.3, 0.1]),\n            \"d\": np.array([0.8, 0.0, -0.2]),\n            \"S_indices\": {6, 7, 8, 9},\n            \"cov_map\": {\n                \"primary\": np.diag([0.01**2, 0.01**2, 0.01**2]),\n                \"secondary\": np.diag([0.10**2, 0.05**2, 0.02**2])\n            },\n            \"track_cov_map_indices\": {\n                \"primary\": [0, 1, 2, 3, 4, 5],\n                \"secondary\": [6, 7, 8, 9]\n            }\n        },\n        {\n            \"name\": \"Case 5: Anisotropic, direction-dependent weights\",\n            \"N\": 9,\n            \"v0\": np.array([0.0, 0.0, 0.0]),\n            \"d\": np.array([0.05, 0.60, 0.0]),\n            \"S_indices\": {0, 1, 2},\n            \"cov_map\": {\n                \"s_group\": np.diag([0.2**2, 0.02**2, 0.02**2]),\n                \"p1_group\": np.diag([0.02**2, 0.2**2, 0.02**2]),\n                \"p2_group\": np.diag([0.02**2, 0.02**2, 0.2**2])\n            },\n            \"track_cov_map_indices\": {\n                \"s_group\": [0, 1, 2],\n                \"p1_group\": [3, 4, 5],\n                \"p2_group\": [6, 7, 8]\n            }\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        v0 = case[\"v0\"]\n        d = case[\"d\"]\n        S_indices = case[\"S_indices\"]\n        cov_map = case[\"cov_map\"]\n        track_cov_map_indices = case[\"track_cov_map_indices\"]\n        \n        # Initialize lists for measurements and covariances\n        r_list = [np.zeros(3) for _ in range(N)]\n        C_list = [np.zeros((3, 3)) for _ in range(N)]\n\n        # Construct measurements r_i and covariances C_i\n        for i in range(N):\n            if i in S_indices:\n                r_list[i] = v0 + d\n            else:\n                r_list[i] = v0\n        \n        if \"all_tracks\" in track_cov_map_indices:\n            C_val = cov_map[\"all\"]\n            for i in range(N):\n                C_list[i] = C_val\n        else:\n            if \"primary\" in track_cov_map_indices:\n                primary_indices = set(track_cov_map_indices[\"primary\"])\n                c_primary = cov_map[\"primary\"]\n                c_secondary = cov_map[\"secondary\"]\n                for i in range(N):\n                    if i in primary_indices:\n                         C_list[i] = c_primary\n                    else:\n                         C_list[i] = c_secondary\n            else: # Case 5 special structure\n                for group_name, indices in track_cov_map_indices.items():\n                    c_val = cov_map[group_name]\n                    for idx in indices:\n                        C_list[idx] = c_val\n\n        # Calculate weight matrices W_i = C_i^{-1}\n        W_list = [np.linalg.inv(C) for C in C_list]\n\n        # Calculate total weight matrix W and weighted sum of measurements\n        W_total = np.sum(W_list, axis=0)\n        sum_Wr = np.zeros(3)\n        for i in range(N):\n            sum_Wr += W_list[i] @ r_list[i]\n            \n        # Compute fitted vertex v_hat using the one-step Newton update\n        # which is equivalent to solving the linear system W * v_hat = sum(W_i * r_i)\n        v_hat = np.linalg.solve(W_total, sum_Wr)\n\n        # Compute bias magnitude ||v_hat - v0||\n        bias_magnitude = np.linalg.norm(v_hat - v0)\n        results.append(bias_magnitude)\n\n    # Print final results in the required format\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际数据处理中，顶点拟合常常会受到离群径迹的干扰。在应用复杂的鲁棒算法之前，掌握诊断单个径迹影响的工具十分关键。本练习将介绍一种基于谢尔曼-莫里森公式（Sherman-Morrison formula）的强大且高效的计算技巧，它可以在无需从头重新拟合的情况下，精确计算当移除某条高$\\chi^2$径迹后顶点位置发生的变化。",
            "id": "3528987",
            "problem": "在横向平面内的最小二乘主顶点拟合中，顶点位置 $\\mathbf{x} \\in \\mathbb{R}^{2}$ 通过求解正规方程 $\\mathbf{N}\\,\\mathbf{x}=\\mathbf{b}$ 来估计。其中 $\\mathbf{N}=\\sum_{i} w_{i}\\,\\mathbf{n}_{i}\\mathbf{n}_{i}^{\\top}$ 且 $\\mathbf{b}=\\sum_{i} w_{i}\\,\\mathbf{n}_{i}\\,d_{i}$，$w_{i}$ 是径迹到顶点的线性化约束的逆方差权重，$\\mathbf{n}_{i}$ 是这些约束的单位法线方向，而 $d_{i}$ 是相对于当前线性化点的带符号标量残差（碰撞参数）。考虑一个拟合，其\n$$\n\\mathbf{N}=\\begin{pmatrix}50  5 \\\\ 5  20\\end{pmatrix}, \\quad \\mathbf{b}=\\begin{pmatrix}10 \\\\ -5\\end{pmatrix},\n$$\n使得当前的顶点估计为 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$。现在，确定一条产生较大卡方值（卡方用希腊字母 $\\chi^{2}$ 表示）的径迹，其单位法线方向为\n$$\n\\mathbf{n}=\\begin{pmatrix} \\tfrac{3}{5} \\\\ \\tfrac{4}{5} \\end{pmatrix},\n$$\n权重为\n$$\nw=100,\n$$\n带符号残差为\n$$\nd=\\tfrac{3}{2} \\text{ mm}.\n$$\n从拟合中移除该径迹会使正规矩阵和右侧项变为\n$$\n\\mathbf{N}'=\\mathbf{N}-w\\,\\mathbf{n}\\mathbf{n}^{\\top}, \\qquad \\mathbf{b}'=\\mathbf{b}-w\\,\\mathbf{n}\\,d.\n$$\n从最小二乘正规方程的公式和矩阵的秩-1逆矩阵更新恒等式（Sherman–Morrison）出发，推导更新后的顶点 $\\mathbf{x}'=\\mathbf{N}'^{-1}\\mathbf{b}'$ 的解析表达式，并用它来计算移除该径迹所引起的 $x$ 分量的变化 $\\Delta x_{x}=\\left(x'_{x}-x_{x}\\right)$。将 $\\Delta x_{x}$ 的最终数值以微米为单位表示，并将您的答案四舍五入到四位有效数字。避免中间取整；在最终转换为微米之前，进行精确或符号操作。",
            "solution": "该问题要求计算从最小二乘拟合中移除一条离群径迹后，顶点位置 $x$ 分量的变化量 $\\Delta x_{x} = x'_{x}-x_{x}$。初始顶点位置为 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$，更新后的顶点位置为 $\\mathbf{x}'=\\mathbf{N}'^{-1}\\mathbf{b}'$。\n\n首先，我们推导顶点位置向量变化量 $\\Delta\\mathbf{x} = \\mathbf{x}' - \\mathbf{x}$ 的一般解析表达式。\n更新后的正规矩阵和右侧向量由下式给出：\n$$ \\mathbf{N}' = \\mathbf{N} - w\\,\\mathbf{n}\\mathbf{n}^{\\top} $$\n$$ \\mathbf{b}' = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n其中 $w$、$\\mathbf{n}$ 和 $d$ 分别是被移除径迹的权重、法线方向和带符号残差。\n\n更新后的顶点 $\\mathbf{x}'$ 满足新的正规方程：\n$$ \\mathbf{N}'\\mathbf{x}' = \\mathbf{b}' $$\n代入 $\\mathbf{N}'$ 和 $\\mathbf{b}'$ 的表达式：\n$$ (\\mathbf{N} - w\\,\\mathbf{n}\\mathbf{n}^{\\top})\\mathbf{x}' = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n我们将左侧的项展开：\n$$ \\mathbf{N}\\mathbf{x}' - w\\,\\mathbf{n}(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{b} - w\\,d\\,\\mathbf{n} $$\n由于初始正规矩阵 $\\mathbf{N}$ 是可逆的（我们将验证这一点），我们可以从左侧乘以 $\\mathbf{N}^{-1}$：\n$$ \\mathbf{N}^{-1}\\mathbf{N}\\mathbf{x}' - w\\,\\mathbf{N}^{-1}\\mathbf{n}(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{N}^{-1}\\mathbf{b} - w\\,d\\,\\mathbf{N}^{-1}\\mathbf{n} $$\n使用定义 $\\mathbf{I}=\\mathbf{N}^{-1}\\mathbf{N}$ 和 $\\mathbf{x}=\\mathbf{N}^{-1}\\mathbf{b}$，上式简化为：\n$$ \\mathbf{x}' - w\\,(\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}') = \\mathbf{x} - w\\,d\\,(\\mathbf{N}^{-1}\\mathbf{n}) $$\n重新整理以找到变化量 $\\Delta \\mathbf{x} = \\mathbf{x}' - \\mathbf{x}$ 的表达式：\n$$ \\Delta\\mathbf{x} = \\mathbf{x}' - \\mathbf{x} = w\\,(\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}') - w\\,d\\,(\\mathbf{N}^{-1}\\mathbf{n}) $$\n$$ \\Delta\\mathbf{x} = w\\,(\\mathbf{n}^{\\top}\\mathbf{x}' - d)(\\mathbf{N}^{-1}\\mathbf{n}) $$\n这个 $\\Delta\\mathbf{x}$ 的表达式通过标量项 $\\mathbf{n}^{\\top}\\mathbf{x}' - d$ 依赖于未知的更新后顶点 $\\mathbf{x}'$。为了求出这一项，我们可以用 $\\mathbf{n}^{\\top}$ 左乘 $\\Delta\\mathbf{x}$ 的方程：\n$$ \\mathbf{n}^{\\top}(\\mathbf{x}' - \\mathbf{x}) = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})(\\mathbf{n}^{\\top}\\mathbf{x}' - d) $$\n令被移除径迹相对于新顶点的标量残差为 $r' = \\mathbf{n}^{\\top}\\mathbf{x}' - d$，其相对于旧顶点的残差为 $r = \\mathbf{n}^{\\top}\\mathbf{x} - d$。方程变为：\n$$ (r' + d) - (r + d) = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})r' $$\n$$ r' - r = w\\,(\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n})r' $$\n$$ r'(1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}) = r $$\n求解 $r'$ 得到：\n$$ r' = \\frac{r}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} = \\frac{\\mathbf{n}^{\\top}\\mathbf{x} - d}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} $$\n将此结果代回 $\\Delta\\mathbf{x}$ 的表达式中：\n$$ \\Delta\\mathbf{x} = w\\,\n\\left( \\frac{\\mathbf{n}^{\\top}\\mathbf{x} - d}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} \\right)\n(\\mathbf{N}^{-1}\\mathbf{n}) $$\n这就是所求的解析表达式。我们现在使用给定的数值进行数值计算。\n\n给定的量是：\n$$ \\mathbf{N}=\\begin{pmatrix} 50  5 \\\\ 5  20 \\end{pmatrix}, \\quad \\mathbf{b}=\\begin{pmatrix} 10 \\\\ -5 \\end{pmatrix}, \\quad \\mathbf{n}=\\begin{pmatrix} 3/5 \\\\ 4/5 \\end{pmatrix}, \\quad w=100, \\quad d=\\frac{3}{2} \\, \\text{mm} $$\n所有与长度相关的量的单位均假定为毫米 ($mm$)。\n\n1.  计算 $\\mathbf{N}^{-1}$：\n    $\\det(\\mathbf{N}) = (50)(20) - (5)(5) = 1000 - 25 = 975$。由于 $\\det(\\mathbf{N}) \\neq 0$，该矩阵是可逆的。\n    $$ \\mathbf{N}^{-1} = \\frac{1}{975}\\begin{pmatrix} 20  -5 \\\\ -5  50 \\end{pmatrix} = \\frac{5}{975}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix} $$\n\n2.  计算初始顶点位置 $\\mathbf{x}$：\n    $$ \\mathbf{x} = \\mathbf{N}^{-1}\\mathbf{b} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix}\\begin{pmatrix} 10 \\\\ -5 \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 4(10)+(-1)(-5) \\\\ -1(10)+10(-5) \\end{pmatrix} = \\frac{1}{195}\\begin{pmatrix} 45 \\\\ -60 \\end{pmatrix} = \\frac{15}{195}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} = \\frac{1}{13}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} $$\n\n3.  计算项 $\\mathbf{n}^{\\top}\\mathbf{x} - d$：\n    $$ \\mathbf{n}^{\\top}\\mathbf{x} = \\begin{pmatrix} \\frac{3}{5}  \\frac{4}{5} \\end{pmatrix} \\frac{1}{13}\\begin{pmatrix} 3 \\\\ -4 \\end{pmatrix} = \\frac{1}{65}(3 \\cdot 3 + 4 \\cdot (-4)) = \\frac{9-16}{65} = -\\frac{7}{65} $$\n    $$ \\mathbf{n}^{\\top}\\mathbf{x} - d = -\\frac{7}{65} - \\frac{3}{2} = \\frac{-14 - 3(65)}{130} = \\frac{-14-195}{130} = -\\frac{209}{130} $$\n\n4.  计算向量 $\\mathbf{v} = \\mathbf{N}^{-1}\\mathbf{n}$：\n    $$ \\mathbf{v} = \\frac{1}{195}\\begin{pmatrix} 4  -1 \\\\ -1  10 \\end{pmatrix}\\begin{pmatrix} 3/5 \\\\ 4/5 \\end{pmatrix} = \\frac{1}{195 \\cdot 5}\\begin{pmatrix} 4(3)-1(4) \\\\ -1(3)+10(4) \\end{pmatrix} = \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n\n5.  计算分母中的标量 $1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}$。首先，求 $\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n} = \\mathbf{n}^{\\top}\\mathbf{v}$：\n    $$ \\mathbf{n}^{\\top}\\mathbf{v} = \\begin{pmatrix} \\frac{3}{5}  \\frac{4}{5} \\end{pmatrix} \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{1}{5 \\cdot 975}(3 \\cdot 8 + 4 \\cdot 37) = \\frac{24+148}{4875} = \\frac{172}{4875} $$\n    现在计算完整的分母：\n    $$ 1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n} = 1 - 100\\left(\\frac{172}{4875}\\right) = 1 - 4 \\cdot 25 \\left(\\frac{172}{195 \\cdot 25}\\right) = 1 - \\frac{688}{195} = \\frac{195-688}{195} = -\\frac{493}{195} $$\n\n6.  组合 $\\Delta\\mathbf{x}$ 的表达式：\n    $$ \\Delta\\mathbf{x} = \\frac{w(\\mathbf{n}^{\\top}\\mathbf{x} - d)}{1 - w\\,\\mathbf{n}^{\\top}\\mathbf{N}^{-1}\\mathbf{n}} (\\mathbf{N}^{-1}\\mathbf{n}) = \\frac{100(-\\frac{209}{130})}{-\\frac{493}{195}} \\left( \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} \\right) $$\n    首项标量因子为：\n    $$ \\frac{-20900/130}{-493/195} = \\frac{2090}{13}\\frac{195}{493} = \\frac{2090}{13} \\frac{15 \\cdot 13}{493} = \\frac{2090 \\cdot 15}{493} = \\frac{31350}{493} $$\n    所以，\n    $$ \\Delta\\mathbf{x} = \\frac{31350}{493} \\left( \\frac{1}{975}\\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} \\right) = \\frac{31350}{493 \\cdot 975} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n    化简标量分数：\n    $$ \\frac{31350}{975} = \\frac{31350/25}{975/25} = \\frac{1254}{39} = \\frac{1254/3}{39/3} = \\frac{418}{13} $$\n    因此，向量变为：\n    $$ \\Delta\\mathbf{x} = \\frac{418/13}{493} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{418}{13 \\cdot 493} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} = \\frac{418}{6409} \\begin{pmatrix} 8 \\\\ 37 \\end{pmatrix} $$\n\n7.  提取 $x$ 分量 $\\Delta x_{x}$：\n    $$ \\Delta x_{x} = \\frac{418}{6409} \\cdot 8 = \\frac{3344}{6409} \\, \\text{mm} $$\n\n8.  转换为微米 ($\\mu\\text{m}$) 并四舍五入到四位有效数字。\n    $$ \\Delta x_{x} = \\frac{3344}{6409} \\times 1000 \\, \\mu\\text{m} \\approx 0.521766266... \\times 1000 \\, \\mu\\text{m} = 521.766266... \\, \\mu\\text{m} $$\n    四舍五入到四位有效数字得到 $521.8 \\, \\mu\\text{m}$。",
            "answer": "$$\\boxed{521.8}$$"
        },
        {
            "introduction": "现代顶点重建技术通常采用鲁棒估计器自动降低离群点的影响，而非手动移除它们。这项高级实践将指导您实现迭代重加权最小二乘（Iteratively Reweighted Least Squares, IRLS）算法，这是鲁棒拟合的通用框架。您将推导并比较两种不同的鲁棒损失函数（Huber损失和Student-t损失），并通过模拟研究它们的经验击穿点，从而定量地理解它们在高污染环境下的稳健性。",
            "id": "3528981",
            "problem": "您的任务是设计、推导和评估在对撞机事件中三维主顶点位置的稳健估计量，其中每条重建径迹都提供一个最近接点位置及其相关的协方差。顶点位置由三维向量 $\\vec{v} \\in \\mathbb{R}^{3}$ 表示，第 $i$ 条径迹的测量值为 $\\vec{r}_{i} \\in \\mathbb{R}^{3}$，其协方差矩阵 $C_{i} \\in \\mathbb{R}^{3 \\times 3}$ 是对称正定的。马氏残差范数定义为\n$$\n\\rho_{i}(\\vec{v}) = \\sqrt{(\\vec{r}_{i} - \\vec{v})^{\\top} C_{i}^{-1} (\\vec{r}_{i} - \\vec{v})}.\n$$\n稳健拟合范式是通过最小化一系列稳健损失之和来估计 $\\vec{v}$，\n$$\n\\min_{\\vec{v} \\in \\mathbb{R}^{3}} \\sum_{i=1}^{N} \\phi(\\rho_{i}(\\vec{v})),\n$$\n其中 $\\phi(\\cdot)$ 是一个非负可微的损失函数。从以下基本基础出发：\n- 在高斯误差假设下的最大似然估计会导出最小二乘法，即 $\\phi(\\rho) = \\tfrac{1}{2}\\rho^{2}$。\n- 对于一般的稳健损失，一阶最优性条件会导出一个迭代重加权最小二乘方案，该方案基于得分函数 $\\psi(\\rho) = \\tfrac{d\\phi(\\rho)}{d\\rho}$ 和权重函数 $w(\\rho) = \\psi(\\rho)/\\rho$，并约定在需要时 $w(0)$ 取极限 $\\lim_{\\rho \\to 0^{+}} \\psi(\\rho)/\\rho$。\n- 给定权重 $w_{i} \\equiv w(\\rho_{i})$，$\\vec{v}$ 的重加权正规方程的一次迭代形式如下\n$$\n\\left(\\sum_{i=1}^{N} w_{i} C_{i}^{-1}\\right)\\vec{v} = \\sum_{i=1}^{N} w_{i} C_{i}^{-1} \\vec{r}_{i}.\n$$\n您的任务是：\n1) 使用以上定义，为以下两种稳健损失推导权重函数 $w_{i}(\\rho_{i})$，并用残差范数 $\\rho$ 表示：\n- Huber 损失，其截断参数为 $k0$，由一个分段函数 $\\phi(\\rho)$ 定义，当 $\\rho$ 较小时为二次函数，当 $\\rho$ 较大时为线性函数。\n- 自由度为 $\\nu0$ 的 $d$ 维观测值的多元 Student-$t$ 分布的负对数似然，它产生一个形式为 $\\phi(\\rho)$ 的损失函数，该函数通过一个包含 $1+\\rho^{2}/\\nu$ 的对数项依赖于 $d$、$\\nu$ 和 $\\rho$。\n2) 针对这两种稳健损失，实现一个迭代重加权最小二乘算法，以在给定 $\\{\\vec{r}_{i}, C_{i}\\}_{i=1}^{N}$ 的情况下估计主顶点 $\\vec{v}$。使用维度 $d=3$。通过使用收敛容差和最大迭代次数来确保数值稳定性。所有坐标单位均为毫米 (mm)；此部分要求您报告的输出量是无量纲的，但算法内部必须以毫米为单位处理位置。\n3) 通过模拟含有比例递增的离群点的数据，研究在污染下的经验性崩溃行为。使用以下物理上和数值上合理的场景：\n- 真实顶点 $\\vec{v}_{\\text{true}} = (0,0,0)$ mm。\n- 径迹数量 $N=100$。\n- 正常点：$N_{\\text{in}} = \\lfloor (1-p) N \\rfloor$ 条径迹，从以 $\\vec{v}_{\\text{true}}$ 为中心、各向同性协方差为 $\\sigma_{\\text{in}}^{2} I_{3}$ 的正态分布中独立采样，其中 $\\sigma_{\\text{in}} = 0.03$ mm。每个正常点的协方差为 $C_{i} = \\sigma_{\\text{in}}^{2} I_{3}$。\n- 离群点：$N_{\\text{out}} = N - N_{\\text{in}}$ 条径迹，从均值为 $\\vec{\\mu}_{\\text{out}} = (10,-10,5)$ mm、各向同性协方差为 $\\sigma_{\\text{out}}^{2} I_{3}$ 的正态分布中独立采样，其中 $\\sigma_{\\text{out}} = 2.0$ mm。为简单起见，离群点也使用相同的每径迹协方差 $C_{i} = \\sigma_{\\text{in}}^{2} I_{3}$，这代表了对坏径迹不确定性的低估。\n- 考虑离群点比例 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$。\n- 如果估计的顶点 $\\hat{\\vec{v}}$ 满足 $\\|\\hat{\\vec{v}} - \\vec{v}_{\\text{true}}\\|_{2}  1.0$ mm，则定义在给定的 $p$ 值下发生失效（崩溃）。\n- 对于每种稳健损失，报告给定集合中导致失效的最小 $p$ 值。如果集合中没有任何 $p$ 值导致失效，则报告 $1.0$。\n为保证数值可复现性，请在模拟中使用固定的随机种子。不涉及角度；不需要角度单位。所有距离单位均为毫米；下面要求的输出是无量纲的。\n测试套件和要求输出：\n- 在残差范数 $\\rho \\in \\{0.5, 1.5, 3.0\\}$ 下使用以下参数进行权重函数评估测试：\n  - Huber: $k = 1.5$。\n  - Student-$t$: $\\nu = 4$, $d = 3$。\n- 使用 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$ 和上述模拟设计进行崩溃研究。\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[w_{H}(0.5), w_{H}(1.5), w_{H}(3.0), w_{T}(0.5), w_{T}(1.5), w_{T}(3.0), p_{\\text{break,Huber}}, p_{\\text{break,Student}}]$,\n其中 $w_{H}(\\cdot)$ 和 $w_{T}(\\cdot)$ 分别是为 Huber 损失和 Student-$t$ 损失推导出的权重函数，$p_{\\text{break,Huber}}$ 和 $p_{\\text{break,Student}}$ 是如上文定义的测试集中的最小失效比例。这八个输出是无量纲的实数。该单行输出必须严格遵循此列表格式，不得包含任何附加文本。",
            "solution": "主顶点重建问题是实验粒子物理学中的一项基本任务。它可以被构建为统计学中的一个 M-估计问题，其目标是找到一个顶点位置 $\\vec{v} \\in \\mathbb{R}^{3}$，以最小化应用于测量径迹残差的一系列损失函数之和。使用稳健损失函数对于降低并非源于主相互作用的离群径迹的影响至关重要。本解决方案首先为指定的稳健损失推导权重函数，然后描述用于寻找顶点的迭代重加权最小二乘 (IRLS) 算法，最后详细说明用于测试估计量崩溃点的模拟设计。\n\n**1. 权重函数的推导**\n\nIRLS 算法依赖于一个权重函数 $w(\\rho)$，该函数由所选的损失函数 $\\phi(\\rho)$ 推导得出。权重函数通过得分函数 $\\psi(\\rho) = \\frac{d\\phi}{d\\rho}$ 定义为 $w(\\rho) = \\psi(\\rho)/\\rho$。\n\n**Huber 损失**\n带有截断参数 $k  0$ 的 Huber 损失函数是针对小残差的二次损失和针对大残差的线性损失的混合。由于马氏范数 $\\rho$ 总是非负的，该损失函数为：\n$$\n\\phi_H(\\rho) = \\begin{cases} \\frac{1}{2}\\rho^2  \\text{if } 0 \\le \\rho \\le k \\\\ k\\rho - \\frac{1}{2}k^2  \\text{if } \\rho  k \\end{cases}\n$$\n相应的得分函数 $\\psi_H(\\rho) = \\frac{d\\phi_H}{d\\rho}$ 通过对 $\\rho$ 求导获得：\n$$\n\\psi_H(\\rho) = \\begin{cases} \\rho  \\text{if } 0 \\le \\rho \\le k \\\\ k  \\text{if } \\rho  k \\end{cases}\n$$\n这可以更紧凑地写为 $\\psi_H(\\rho) = \\min(\\rho, k)$。因此，权重函数 $w_H(\\rho) = \\psi_H(\\rho)/\\rho$ 为：\n$$\nw_H(\\rho) = \\begin{cases} 1  \\text{if } 0 \\le \\rho \\le k \\\\ k/\\rho  \\text{if } \\rho  k \\end{cases}\n$$\n这可以表示为 $w_H(\\rho) = \\min(1, k/\\rho)$。该函数为在截断值 $k$ 以内的残差分配常数权重 1（等价于标准最小二乘法），并对大于 $k$ 的残差降低权重。\n\n**Student-t 损失**\n该损失函数源于自由度为 $\\nu$ 的 $d$ 维多元 Student-t 分布的负对数似然。其概率密度函数与 $(1 + \\frac{1}{\\nu} \\rho^2)^{-(\\nu+d)/2}$ 成正比，其中 $\\rho^2 = (\\vec{r} - \\vec{v})^\\top C^{-1} (\\vec{r} - \\vec{v})$ 是马氏距离的平方。忽略加性常数后，负对数似然给出的损失函数为：\n$$\n\\phi_T(\\rho) = \\frac{\\nu+d}{2} \\log\\left(1 + \\frac{\\rho^2}{\\nu}\\right)\n$$\n得分函数 $\\psi_T(\\rho) = \\frac{d\\phi_T}{d\\rho}$ 可通过链式法则求得：\n$$\n\\psi_T(\\rho) = \\frac{\\nu+d}{2} \\cdot \\frac{1}{1 + \\rho^2/\\nu} \\cdot \\frac{d}{d\\rho}\\left(\\frac{\\rho^2}{\\nu}\\right) = \\frac{\\nu+d}{2} \\cdot \\frac{\\nu}{\\nu + \\rho^2} \\cdot \\frac{2\\rho}{\\nu} = \\frac{(\\nu+d)\\rho}{\\nu + \\rho^2}\n$$\n相应的权重函数 $w_T(\\rho) = \\psi_T(\\rho)/\\rho$ 为：\n$$\nw_T(\\rho) = \\frac{\\nu+d}{\\nu + \\rho^2}\n$$\n随着残差范数 $\\rho$ 的增加，该权重函数平滑地减小，从而对离群点进行软性地降权。与 Huber 损失不同，它没有一个尖锐的截断点。\n\n**2. 迭代重加权最小二乘 (IRLS) 算法**\n\n$\\sum_i \\phi(\\rho_i(\\vec{v}))$ 的最小化是一个非线性优化问题。IRLS 算法是找到解的一个迭代过程。每次迭代都涉及解决一个加权最小二乘问题，其中的权重根据上一次迭代的残差进行更新。通用的更新步骤由以下正规方程控制：\n$$\n\\vec{v}^{(t+1)} = \\left(\\sum_{i=1}^{N} w_{i}^{(t)} C_{i}^{-1}\\right)^{-1} \\left(\\sum_{i=1}^{N} w_{i}^{(t)} C_{i}^{-1} \\vec{r}_{i}\\right)\n$$\n其中 $w_i^{(t)} = w(\\rho_i(\\vec{v}^{(t)}))$ 是使用前一次迭代的顶点估计 $\\vec{v}^{(t)}$ 计算出的权重。\n\n问题中的模拟设计带来了一个显著的简化，即所有协方差矩阵都是相同且各向同性的：对所有 $i$ 都有 $C_i = \\sigma_{\\text{in}}^2 I_3$。因此，其逆矩阵为 $C_i^{-1} = (1/\\sigma_{\\text{in}}^2) I_3$。将此代入正规方程：\n$$\n\\left(\\sum_{i=1}^{N} w_{i}^{(t)} \\frac{1}{\\sigma_{\\text{in}}^2} I_3\\right)\\vec{v}^{(t+1)} = \\sum_{i=1}^{N} w_{i}^{(t)} \\frac{1}{\\sigma_{\\text{in}}^2} I_3 \\vec{r}_{i}\n$$\n常数矩阵项 $(1/\\sigma_{\\text{in}}^2) I_3$ 可以被提取出来并从等式两边消去，得到：\n$$\n\\left(\\sum_{i=1}^{N} w_{i}^{(t)}\\right) \\vec{v}^{(t+1)} = \\sum_{i=1}^{N} w_{i}^{(t)} \\vec{r}_{i}\n$$\n这表明更新后的顶点估计就是径迹位置的加权平均：\n$$\n\\vec{v}^{(t+1)} = \\frac{\\sum_{i=1}^{N} w_i^{(t)} \\vec{r}_i}{\\sum_{i=1}^{N} w_i^{(t)}}\n$$\n马氏范数也简化为：\n$$\n\\rho_i(\\vec{v}) = \\sqrt{(\\vec{r}_i - \\vec{v})^\\top \\left(\\frac{1}{\\sigma_{\\text{in}}^2}I_3\\right) (\\vec{r}_i - \\vec{v})} = \\frac{1}{\\sigma_{\\text{in}}} \\sqrt{(\\vec{r}_i - \\vec{v})^\\top (\\vec{r}_i - \\vec{v})} = \\frac{\\|\\vec{r}_i - \\vec{v}\\|_2}{\\sigma_{\\text{in}}}\n$$\n算法流程如下：\n1.  将 $\\vec{v}^{(0)}$ 初始化为所有 $\\vec{r}_i$ 的未加权平均值。\n2.  对于 $t = 0, 1, 2, \\dots$，直到达到最大迭代次数：\n    a.  计算范数 $\\rho_i^{(t)} = \\|\\vec{r}_i - \\vec{v}^{(t)}\\|_2 / \\sigma_{\\text{in}}$。\n    b.  使用相应的推导函数（Huber 或 Student-t）计算权重 $w_i^{(t)} = w(\\rho_i^{(t)})$。\n    c.  使用加权平均公式更新顶点估计 $\\vec{v}^{(t+1)}$。\n    d.  检查收敛性：如果 $\\|\\vec{v}^{(t+1)} - \\vec{v}^{(t)}\\|_2$ 小于指定的容差，则终止。\n3.  最终的 $\\vec{v}^{(t+1)}$ 即为估计的顶点位置。\n\n**3. 经验性崩溃研究**\n\n估计量的崩溃点，通俗地讲，是它在产生任意错误的估计之前所能容忍的最大污染数据比例。本研究对这种行为进行了经验性分析。\n对于每个离群点比例 $p \\in \\{0.0, 0.2, 0.4, 0.6\\}$：\n- 模拟一个包含 $N=100$ 条径迹的数据集。\n- $N_{\\text{in}} = \\lfloor (1-p)N \\rfloor$ 个正常点位置从以真实顶点 $\\vec{v}_{\\text{true}} = (0,0,0)$ mm 为中心、标准差为 $\\sigma_{\\text{in}} = 0.03$ mm 的窄高斯分布中抽取。\n- $N_{\\text{out}} = N - N_{\\text{in}}$ 个离群点位置从以 $\\vec{\\mu}_{\\text{out}} = (10,-10,5)$ mm 为中心、具有较大离散度（$\\sigma_{\\text{out}} = 2.0$ mm）的不同高斯分布中抽取。\n- 在这个组合数据集上，分别对 Huber 损失和 Student-t 损失运行 IRLS 算法，以获得估计值 $\\hat{\\vec{v}}$。所有径迹的协方差均假定为 $C_i = \\sigma_{\\text{in}}^2 I_3$。\n- 如果估计值与真实顶点之间的距离超过一个阈值，即 $\\|\\hat{\\vec{v}} - \\vec{v}_{\\text{true}}\\|_2  1.0$ mm，则宣布发生“崩溃”或“失效”。\n- 对于每种损失函数，报告的量是测试集中导致失效的最小 $p$ 值。如果在所有测试比例下均未发生失效，则报告 $1.0$，表示稳健性至少达到了 $p=0.6$。固定的随机种子确保了模拟的可复现性。\n\n以上为解决该问题的理论和方法论框架。具体实现将直接遵循这些原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust vertex reconstruction problem by:\n    1. Deriving and evaluating weight functions for Huber and Student-t losses.\n    2. Implementing an Iteratively Reweighted Least Squares (IRLS) algorithm.\n    3. Performing a breakdown study to find the failure point for each estimator.\n    \"\"\"\n\n    # --- Part 1: Weight Function Definitions and Evaluation ---\n\n    def w_huber(rho, k):\n        \"\"\"Calculates the Huber weight function.\"\"\"\n        rho = np.asarray(rho)\n        # The weight is min(1, k/|rho|). Since rho is a norm, it's non-negative.\n        # We need to handle the case rho = 0, where the weight is 1.\n        weights = np.ones_like(rho, dtype=float)\n        mask = rho > 0\n        weights[mask] = np.minimum(1.0, k / rho[mask])\n        return weights\n\n    def w_student_t(rho, nu, d):\n        \"\"\"Calculates the Student-t weight function.\"\"\"\n        rho = np.asarray(rho)\n        return (nu + d) / (nu + rho**2)\n\n    # Test parameters\n    rhos_test = np.array([0.5, 1.5, 3.0])\n    k_huber = 1.5\n    nu_student_t = 4.0\n    d_student_t = 3.0\n\n    # Evaluate weights for the test cases\n    weights_huber = w_huber(rhos_test, k=k_huber)\n    weights_student_t = w_student_t(rhos_test, nu=nu_student_t, d=d_student_t)\n\n    # --- Part 2: IRLS Algorithm ---\n\n    def irls_vertex_fit(r_tracks, sigma_in, weight_func, *args, max_iter=100, tol=1e-6):\n        \"\"\"\n        Performs an Iteratively Reweighted Least Squares fit for the vertex position.\n        This simplified version assumes C_i = sigma_in^2 * I_3 for all i.\n        \"\"\"\n        # Initial guess: unweighted mean (least squares solution)\n        v = np.mean(r_tracks, axis=0)\n\n        for _ in range(max_iter):\n            v_old = v\n            \n            # Calculate Mahalanobis norms (simplified form)\n            distances = np.linalg.norm(r_tracks - v, axis=1)\n            rhos = distances / sigma_in\n            \n            # Calculate weights\n            weights = weight_func(rhos, *args)\n            \n            # Update vertex as a weighted average\n            sum_weights = np.sum(weights)\n            if sum_weights  1e-9: # Avoid division by zero if all weights are tiny\n                # This could happen if all points are extreme outliers. Reset to mean.\n                v = np.mean(r_tracks, axis=0)\n            else:\n                v = np.sum(r_tracks * weights[:, np.newaxis], axis=0) / sum_weights\n\n            # Check for convergence\n            if np.linalg.norm(v - v_old)  tol:\n                break\n        \n        return v\n\n    # --- Part 3: Breakdown Study ---\n\n    def run_breakdown_study():\n        \"\"\"\n        Simulates track data with outliers and finds the breakdown point.\n        \"\"\"\n        # Fixed random seed for reproducibility\n        rng = np.random.default_rng(12345)\n        \n        # Simulation parameters from the problem description\n        v_true = np.array([0.0, 0.0, 0.0])\n        num_tracks = 100\n        sigma_in = 0.03  # mm\n        mu_out = np.array([10.0, -10.0, 5.0]) # mm\n        sigma_out = 2.0  # mm\n        outlier_fractions = [0.0, 0.2, 0.4, 0.6]\n        breakdown_threshold = 1.0  # mm\n\n        p_break_huber = 1.0\n        p_break_student = 1.0\n        huber_failed = False\n        student_failed = False\n\n        for p in sorted(outlier_fractions):\n            # Generate data\n            num_inliers = int(np.floor((1 - p) * num_tracks))\n            num_outliers = num_tracks - num_inliers\n\n            inliers = rng.normal(loc=v_true, scale=sigma_in, size=(num_inliers, 3))\n            outliers = rng.normal(loc=mu_out, scale=sigma_out, size=(num_outliers, 3))\n\n            if num_outliers > 0:\n                tracks = np.vstack((inliers, outliers))\n            else:\n                tracks = inliers\n\n            # Run IRLS for Huber loss\n            if not huber_failed:\n                v_huber = irls_vertex_fit(tracks, sigma_in, w_huber, k_huber)\n                error_huber = np.linalg.norm(v_huber - v_true)\n                if error_huber > breakdown_threshold:\n                    p_break_huber = p\n                    huber_failed = True\n\n            # Run IRLS for Student-t loss\n            if not student_failed:\n                v_student = irls_vertex_fit(tracks, sigma_in, w_student_t, nu_student_t, d_student_t)\n                error_student = np.linalg.norm(v_student - v_true)\n                if error_student > breakdown_threshold:\n                    p_break_student = p\n                    student_failed = True\n            \n            # If both have failed, we can stop early\n            if huber_failed and student_failed:\n                break\n\n        return p_break_huber, p_break_student\n\n    p_break_huber, p_break_student = run_breakdown_study()\n\n    # --- Final Output Formatting ---\n    results = [\n        *weights_huber,\n        *weights_student_t,\n        p_break_huber,\n        p_break_student\n    ]\n    \n    # Format the final output string exactly as required.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}