{
    "hands_on_practices": [
        {
            "introduction": "理论计算与实验测量的可靠连接，要求我们使用的观测量对量子色动力学 (QCD) 中的红外和共线辐射不敏感。这个实践旨在通过一个具体的编程练习来阐明这一核心原则。你将通过数值方法，直接对比一个红外与共线 (IRC) 安全的现代算法 (anti-$k_T$) 和一个不安全的旧式算法（有固定种子阈值的锥形算法），以验证共线分裂下两者行为的巨大差异。通过完成这项练习 ，你将深刻理解为何 IRC 安全性是喷注算法设计的基石，并对不同算法在处理 QCD 物理时的优劣获得直观感受。",
            "id": "3517907",
            "problem": "您需要编写一个完整、独立的程序，该程序构建一个受控的共线分裂场景，并数值上验证 anti-$k_{T}$ 聚类算法相对于带有种子阈值的基于种子的锥形算法的不稳定性的共线性安全性。在末态粒子无质量近似下工作，粒子由横向动量、快度和方位角 $(p_{T}, y, \\phi)$ 表示，其四动量由常规关系定义。使用 Minkowski 度规符号 $(+,-,-,-)$ 和 $E$ 方案重组（四矢量求和）。\n\n待使用的基本基础和定义：\n- 使用 Minkowski 度规计算喷注质量平方，$m_{J}^{2} = \\left(\\sum_{i} p_{i}^{\\mu}\\right)^{2} = \\left(\\sum_{i} E_{i}\\right)^{2} - \\left\\|\\sum_{i} \\vec{p}_{i}\\right\\|^{2}$。\n- 通过 $(p_{T}, y, \\phi)$ 与四动量分量之间的映射对无质量粒子建模：$p_{x} = p_{T} \\cos\\phi$，$p_{y} = p_{T} \\sin\\phi$，$p_{z} = p_{T} \\sinh y$，$E = p_{T} \\cosh y$。\n- 使用快度-方位角距离 $\\Delta R = \\sqrt{(\\Delta y)^{2} + (\\Delta \\phi)^{2}}$，其中 $\\Delta \\phi$ 定义为圆上的最小角差。\n- 实现 anti-$k_{T}$ 序列重组算法，其距离度量为\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2},\n$$\n其中 $R$ 是喷注半径参数，使用 $E$ 方案重组，直到所有剩余对象都被声明为喷注。\n- 实现一个简化的基于种子的迭代锥形算法，使用种子阈值 $p_{T}^{\\text{seed}}$：种子是所有满足 $p_{T} \\ge p_{T}^{\\text{seed}}$ 的粒子；对每个种子，围绕一个初始化为种子方向的轴构建一个半径为 $R$ 的锥体；包括所有满足 $\\Delta R \\le R$ 的粒子；从求和后的四动量重新计算轴；迭代直到轴在一个小的容差范围内稳定；返回所有不同的稳定锥体作为喷注。如果没有种子存在，算法不返回任何喷注。\n\n待构建的场景：\n- 考虑一个未分裂事件 $\\mathcal{E}_{0}$，它由一个单一的无质量粒子组成，其四动量 $p^{\\mu}$ 由 $(p_{T,0}, y_{0}, \\phi_{0})$ 定义。\n- 通过用两个动量分别为 $z\\,p^{\\mu}$ 和 $(1-z)\\,p^{\\mu}$ 的共线子粒子替换 $p^{\\mu}$ 来构建一个分裂事件 $\\mathcal{E}_{\\text{split}}$，这两个子粒子由一个小的但受控的快度-方位角距离 $\\Delta R$ 分开。为了在近似保持净轴不变的同时参数化该分离，将子粒子分别放置在 $(y_{0} - \\Delta R/2, \\phi_{0})$ 和 $(y_{0} + \\Delta R/2, \\phi_{0})$，其横向动量分别为 $z\\,p_{T,0}$ 和 $(1-z)\\,p_{T,0}$。在精确共线极限下，通过将两个子粒子都放置在 $(y_{0}, \\phi_{0})$ 来取 $\\Delta R = 0$。\n\n要求的计算：\n- 对每个事件，使用半径为 $R$ 的 anti-$k_{T}$ 算法聚类喷注，并使用喷注组分的 $E$ 方案四矢量和计算领头喷注质量平方 $m_{J}^{2}$（单位为 $\\text{GeV}^{2}$）。\n- 使用相同的 $R$ 和种子阈值 $p_{T}^{\\text{seed}}$，用基于种子的锥形算法重复上述过程。如果算法不返回任何喷注，则为了比较目的，将领头喷注质量平方视为未定义。\n- 通过绝对差\n$$\n\\Delta m^{2}_{\\text{anti-}k_{T}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|,\n$$\n来量化 anti-$k_{T}$ 的共线性安全性，如果 $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$，则声明其为数值不变，其中 $\\varepsilon$ 是一个数值容差。\n- 通过\n$$\n\\Delta m^{2}_{\\text{cone}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|\n$$\n来量化基于种子的锥形算法的行为，如果两个质量都有定义；否则，如果分裂事件不返回任何喷注，则设置一个哨兵值 $-1$ 来表明因缺少种子导致的不稳定性。\n\n单位和角度：\n- 能量使用 $\\text{GeV}$，喷注质量平方以 $\\text{GeV}^{2}$ 报告。\n- 角度使用弧度。\n\n数值参数：\n- 使用 $R = 0.4$，$p_{T,0} = 100\\,\\text{GeV}$，$(y_{0}, \\phi_{0}) = (0, 0)$，$p_{T}^{\\text{seed}} = 65\\,\\text{GeV}$，以及数值容差 $\\varepsilon = 10^{-12}\\,\\text{GeV}^{2}$。\n\n测试套件：\n对于下面的每个元组 $(z, \\Delta R)$，如前所述构建 $\\mathcal{E}_{0}$ 和 $\\mathcal{E}_{\\text{split}}$，为两种算法计算上述量，并记录结果。\n\n- 测试 1（理想路径，明显的种子不稳定性）：$(z, \\Delta R) = (0.6, 0.0)$。\n- 测试 2（带有幸存种子的不对称分裂）：$(z, \\Delta R) = (0.9, 10^{-6})$。\n- 测试 3（对称的、小的但有限的分离）：$(z, \\Delta R) = (0.5, 10^{-3})$。\n- 测试 4（在种子阈值处的边界情况）：$(z, \\Delta R) = (0.65, 10^{-6})$。\n- 测试 5（远在锥体内部的非零分离）：$(z, \\Delta R) = (0.6, 0.2)$。\n\n答案规范：\n- 对于每个测试，程序必须输出一个三元素列表 $[\\Delta m^{2}_{\\text{anti-}k_{T}}, \\Delta m^{2}_{\\text{cone}} \\text{ 或 } -1.0, \\text{invariance}]$，其中第三个元素是一个布尔值，如果 $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- 将五个每个测试的列表按测试的原始顺序聚合到一个单一列表中。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是按指定顺序排列的三元素列表（例如，`[[a_1,b_1,c_1],[a_2,b_2,c_2],...]`）。所有喷注质量平方值必须是表示 $\\text{GeV}^{2}$ 的浮点数，不变性标志必须是布尔值。",
            "solution": "该问题要求对两种不同的喷注聚类算法进行共线性安全性分析：序列重组 anti-$k_T$ 算法和简化的基于种子的迭代锥形算法。我们的任务是构建一个受控的共线分裂场景，并数值上验证每种算法的预期行为。\n\n**1. 理论框架和定义**\n\n我们在无质量粒子近似下操作，其中每个粒子的状态由其横向动量 $p_T$、快度 $y$ 和方位角 $\\phi$ 定义。四动量 $p^\\mu = (E, p_x, p_y, p_z)$ 通过以下关系构建：\n$$\np_x = p_T \\cos\\phi\n$$\n$$\np_y = p_T \\sin\\phi\n$$\n$$\np_z = p_T \\sinh y\n$$\n$$\nE = \\sqrt{p_x^2 + p_y^2 + p_z^2} = \\sqrt{p_T^2 + (p_T \\sinh y)^2} = p_T \\cosh y\n$$\n在快度-方位角平面中，粒子间的距离由 $\\Delta R = \\sqrt{(\\Delta y)^2 + (\\Delta \\phi)^2}$ 给出，其中 $\\Delta \\phi$ 是最短的角距离。一个由一组组分粒子 $\\{i\\}$ 构成的喷注 $J$ 的不变质量平方，使用 $E$ 方案（四矢量求和）和符号为 $(+,-,-,-)$ 的 Minkowski 度规计算：\n$$\nm_J^2 = P_J^\\mu P_{J, \\mu} = \\left(\\sum_i p_i^\\mu\\right)^2 = \\left(\\sum_i E_i\\right)^2 - \\left\\|\\sum_i \\vec{p}_i\\right\\|^2\n$$\n\n**2. 共线分裂场景**\n\n为了测试共线性安全性，我们将对一个事件 $\\mathcal{E}_0$ 计算的可观测量与对一个修改后的事件 $\\mathcal{E}_{\\text{split}}$ 计算的可观测量进行比较。\n- 事件 $\\mathcal{E}_0$：一个单一的无质量粒子，其四动量 $p^\\mu$ 对应于 $(p_{T,0}, y_0, \\phi_0)$。由单个无质量粒子组成的喷注具有 $m_J^2 = (p^\\mu)^2 = 0$。\n- 事件 $\\mathcal{E}_{\\text{split}}$：粒子 $p^\\mu$ 被两个共线子粒子 $p_1^\\mu$ 和 $p_2^\\mu$ 替换。它们的动量分别是原始粒子动量的 $z$ 和 $(1-z)$ 部分。它们被一个小的距离 $\\Delta R$ 分开。具体的参数化是：\n  - 粒子 1：$(p_T, y, \\phi) = (z p_{T,0}, y_0 - \\Delta R/2, \\phi_0)$\n  - 粒子 2：$(p_T, y, \\phi) = ((1-z) p_{T,0}, y_0 + \\Delta R/2, \\phi_0)$\n\n如果一个可观测量在 $\\mathcal{E}_{\\text{split}}$ 上的值随着分裂间距 $\\Delta R \\to 0$ 而平滑地趋近于其在 $\\mathcal{E}_0$ 上的值，则该可观测量是**共线性安全**的。\n\n**3. 算法设计与预期行为**\n\n**Anti-$k_T$ 算法：**\n这是一个序列重组算法。它迭代地合并具有最小距离的一对对象（粒子或原喷注），直到所有对象之间的距离都大于一个与束流距离相关的阈值。距离度量为：\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2}\n$$\n在我们有两个相邻粒子的场景中，$\\Delta R_{12} = \\Delta R$。对于任何 $\\Delta R  R$ 的构型，粒子间距离 $d_{12}$ 将小于束流距离 $d_{1B}$ 和 $d_{2B}$。因此，两个子粒子将首先被合并。最终的喷注将具有四动量 $P_J^\\mu = p_1^\\mu + p_2^\\mu$。该喷注的不变质量平方可以解析地计算。当 $y_0 = 0$ 且 $\\phi_0=0$ 时：\n$$\nm_J^2(\\mathcal{E}_{\\text{split}}) = 4z(1-z) p_{T,0}^2 \\sinh^2(\\Delta R/2)\n$$\n当 $\\Delta R \\to 0$ 时，$m_J^2(\\mathcal{E}_{\\text{split}}) \\to 0$，这恰好是 $m_J^2(\\mathcal{E}_0)$。这证明了来自 anti-$k_T$ 算法的喷注质量是一个共线性安全的可观测量。通过检查 $\\Delta m^2_{\\text{anti-}k_T} = |m_J^2(\\mathcal{E}_{\\text{split}}) - m_J^2(\\mathcal{E}_0)| \\le \\varepsilon$（对于一个小的容差 $\\varepsilon$）来进行数值测试。对于任何有限的 $\\Delta R  0$，我们预计这个差值是非零的，并且可能大于一个非常小的 $\\varepsilon$，但对于 $\\Delta R = 0$，它必须精确为零。\n\n**基于种子的锥形算法：**\n此算法在根本上是不同的。它寻找围绕高 $p_T$ “种子” 的稳定粒子锥。\n1. 识别所有 $p_T \\ge p_T^{\\text{seed}}$ 的粒子。这些是种子。\n2. 如果没有种子存在，则找不到喷注。\n3. 对每个种子进行迭代：围绕一个轴形成一个半径为 $R$ 的锥体，对其中的粒子动量求和，并使用该和的方向作为新轴。当轴稳定时，过程停止。\n\n该算法预期是**共线性不安全**的。考虑一个 $p_T  p_T^{\\text{seed}}$ 的粒子分裂成两个子粒子，且它们的 $p_T$ 都小于 $p_T^{\\text{seed}}$。\n- 在 $\\mathcal{E}_0$ 中，单个粒子是一个种子，并且找到了一个喷注。\n- 在 $\\mathcal{E}_{\\text{split}}$ 中，两个子粒子都不符合作为种子的条件。该算法找不到种子，因此不返回任何喷注。\n喷注寻找的结果在事件发生无穷小变化（分裂）时从一个喷注突变为零个喷注，这是不安全算法的标志。这将由一个哨兵值 $-1$ 来表示。如果一个种子在分裂中幸存下来，算法将找到一个喷注，并且可以计算质量差 $\\Delta m^2_{\\text{cone}}$，其结果通常与 anti-$k_T$ 相似，因为锥体将包含两个共线子粒子。\n\n**4. 实现策略**\n\n我们将实现辅助函数来管理四矢量转换和运动学计算。两种喷注算法将作为独立的函数实现。主程序将循环遍历指定的测试用例。对于每个用例，它将构建 $\\mathcal{E}_0$ 和 $\\mathcal{E}_{\\text{split}}$，应用两种算法，计算领头喷注的质量平方，然后计算所需的量 $\\Delta m^2_{\\text{anti-}k_T}$、其不变性状态以及 $\\Delta m^2_{\\text{cone}}$（或哨兵值）。最终结果将按照规定聚合到一个列表的列表中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the jet algorithm safety analysis.\n    \"\"\"\n    # Global parameters\n    R = 0.4\n    PT0 = 100.0  # GeV\n    Y0, PHI0 = 0.0, 0.0\n    PT_SEED = 65.0  # GeV\n    EPSILON = 1e-12  # GeV^2\n\n    CONE_STABILITY_TOL = 1e-9\n\n    # Test suite\n    test_cases = [\n        # (z, DeltaR)\n        (0.6, 0.0),\n        (0.9, 1e-6),\n        (0.5, 1e-3),\n        (0.65, 1e-6),\n        (0.6, 0.2),\n    ]\n\n    # Helper class for particles\n    class Particle:\n        def __init__(self, pt, y, phi):\n            self.pt = pt\n            self.y = y\n            self.phi = phi\n            self.pmu = self.to_pmu()\n\n        def to_pmu(self):\n            px = self.pt * np.cos(self.phi)\n            py = self.pt * np.sin(self.phi)\n            pz = self.pt * np.sinh(self.y)\n            e = self.pt * np.cosh(self.y)\n            return np.array([e, px, py, pz])\n\n        @staticmethod\n        def from_pmu(pmu):\n            e, px, py, pz = pmu\n            pt = np.sqrt(px**2 + py**2)\n            if pt  1e-15:\n                return 0.0, 0.0, 0.0\n            \n            # Rapidity y = 0.5 * log((E+pz)/(E-pz))\n            # phi = atan2(py, px)\n            if abs(e + pz)  1e-15 or abs(e - pz)  1e-15:\n                y = 0.0 # handle potential numerical issues for very specific kinematics\n            else:\n                y = 0.5 * np.log((e + pz) / (e - pz))\n                \n            phi = np.arctan2(py, px)\n            return pt, y, phi\n\n    # Kinematic helpers\n    def delta_phi(phi1, phi2):\n        dphi = phi1 - phi2\n        while dphi > np.pi: dphi -= 2 * np.pi\n        while dphi = -np.pi: dphi += 2 * np.pi\n        return dphi\n\n    def delta_R2(y1, phi1, y2, phi2):\n        dy = y1 - y2\n        dphi = delta_phi(phi1, phi2)\n        return dy**2 + dphi**2\n\n    def get_jet_mass_sq(pmu_sum):\n        return pmu_sum[0]**2 - pmu_sum[1]**2 - pmu_sum[2]**2 - pmu_sum[3]**2\n\n    # Algorithm implementations\n    def anti_kt_cluster(particles):\n        protojets = {i: p.pmu for i, p in enumerate(particles)}\n        protojets_coords = {i: (p.y, p.phi, p.pt) for i, p in enumerate(particles)}\n        jets = []\n        \n        while protojets:\n            min_dist = np.inf\n            merge_pair = None # (i, j)\n            beam_jet_idx = None # i\n            \n            ids = list(protojets.keys())\n\n            # d_iB distances\n            for i in ids:\n                dist_ib = 1.0 / (protojets_coords[i][2]**2)\n                if dist_ib  min_dist:\n                    min_dist = dist_ib\n                    beam_jet_idx = i\n                    merge_pair = None\n            \n            # d_ij distances\n            for i in range(len(ids)):\n                for j in range(i + 1, len(ids)):\n                    id_i, id_j = ids[i], ids[j]\n                    y_i, phi_i, pt_i = protojets_coords[id_i]\n                    y_j, phi_j, pt_j = protojets_coords[id_j]\n                    \n                    dr2 = delta_R2(y_i, phi_i, y_j, phi_j)\n                    dist_ij = min(1.0/pt_i**2, 1.0/pt_j**2) * dr2 / R**2\n                    \n                    if dist_ij  min_dist:\n                        min_dist = dist_ij\n                        merge_pair = (id_i, id_j)\n                        beam_jet_idx = None\n\n            if beam_jet_idx is not None:\n                jets.append(protojets[beam_jet_idx])\n                del protojets[beam_jet_idx]\n                del protojets_coords[beam_jet_idx]\n            elif merge_pair:\n                i, j = merge_pair\n                pmu_i, pmu_j = protojets[i], protojets[j]\n                \n                new_pmu = pmu_i + pmu_j\n                new_pt, new_y, new_phi = Particle.from_pmu(new_pmu)\n                \n                del protojets[i]\n                del protojets_coords[i]\n                del protojets[j]\n                del protojets_coords[j]\n                \n                new_id = max(ids) + 1 if ids else 0\n                protojets[new_id] = new_pmu\n                protojets_coords[new_id] = (new_y, new_phi, new_pt)\n                \n        # Sort jets by pT and return\n        jets.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return jets\n\n    def cone_cluster(particles):\n        seeds = [p for p in particles if p.pt >= PT_SEED]\n        if not seeds:\n            return []\n\n        stable_cones_pmu = []\n        for seed in seeds:\n            axis_y, axis_phi = seed.y, seed.phi\n            \n            for _ in range(100): # max iterations\n                old_axis_y, old_axis_phi = axis_y, axis_phi\n                \n                constituents_pmu = np.array([0.0, 0.0, 0.0, 0.0])\n                for p in particles:\n                    if delta_R2(p.y, p.phi, axis_y, axis_phi) = R**2:\n                        constituents_pmu += p.pmu\n                \n                if constituents_pmu[0]  1e-15:\n                    # no particles in cone, rare but possible\n                    break\n                \n                _, new_y, new_phi = Particle.from_pmu(constituents_pmu)\n                axis_y, axis_phi = new_y, new_phi\n\n                if delta_R2(old_axis_y, old_axis_phi, axis_y, axis_phi)  CONE_STABILITY_TOL**2:\n                    break\n            \n            stable_cones_pmu.append(constituents_pmu)\n        \n        # Remove duplicate cones (very simple check for this problem)\n        unique_cones = []\n        for cone_pmu in stable_cones_pmu:\n            is_duplicate = False\n            for unique_pmu in unique_cones:\n                 if np.allclose(cone_pmu, unique_pmu):\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_cones.append(cone_pmu)\n        \n        unique_cones.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return unique_cones\n\n\n    results = []\n    for z, delta_R in test_cases:\n        # Event E0: unsplit\n        event0 = [Particle(PT0, Y0, PHI0)]\n        \n        # Event E_split\n        p1 = Particle(z * PT0, Y0 - delta_R / 2, PHI0)\n        p2 = Particle((1 - z) * PT0, Y0 + delta_R / 2, PHI0)\n        event_split = [p1, p2]\n\n        # Process E0\n        jets0_akt = anti_kt_cluster(event0)\n        m2_0_akt = get_jet_mass_sq(jets0_akt[0]) if jets0_akt else 0.0\n        \n        jets0_cone = cone_cluster(event0)\n        m2_0_cone = get_jet_mass_sq(jets0_cone[0]) if jets0_cone else 0.0\n\n        # Process E_split\n        jets_split_akt = anti_kt_cluster(event_split)\n        m2_split_akt = get_jet_mass_sq(jets_split_akt[0]) if jets_split_akt else 0.0\n\n        jets_split_cone = cone_cluster(event_split)\n        m2_split_cone_defined = bool(jets_split_cone)\n        m2_split_cone = get_jet_mass_sq(jets_split_cone[0]) if m2_split_cone_defined else 0.0\n        \n        # Calculate differences\n        delta_m2_akt = abs(m2_split_akt - m2_0_akt)\n        invariance_akt = delta_m2_akt = EPSILON\n\n        if m2_split_cone_defined:\n            delta_m2_cone = abs(m2_split_cone - m2_0_cone)\n        else:\n            delta_m2_cone = -1.0\n            \n        results.append([float(delta_m2_akt), float(delta_m2_cone), invariance_akt])\n\n    # Final print statement\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2]).lower()}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "即便我们使用了 IRC 安全的喷注算法，由这些喷注定义的观测量本身却不一定具备完全的 IRC 安全性。这个练习将引导你深入探索这一精妙之处，这对于现代喷注子结构物理的研究至关重要。我们将构建一个仅共线安全但非软安全的事件形状观测量，并展示如何利用如软脱落 (Soft Drop) 这样的修饰 (grooming) 技术来恢复其完整的苏达科夫 (Sudakov) 安全性。这项实践  为你提供了喷注修饰的动手经验，这是一种减轻非必要辐射污染、提升对撞机测量精度的前沿工具。",
            "id": "3517881",
            "problem": "要求您使用一个简单的确定性聚类模型，构建并分析一个共线安全但软不安全的事件形状观测量，然后应用一个修饰程序来恢复 Sudakov 安全性。您将在一维角空间中实现 Cambridge/Aachen 聚类算法，并从生成的二元聚类树中计算两个观测量：一个是未经修饰的末次分裂动量共享分数，它是共线安全但软不安全的；另一个是使用 Soft Drop 修饰的经过修饰的动量共享分数，它是 Sudakov 安全的。接着，您将数值上探究当 Soft Drop 阈值参数 $z_\\text{cut}$ 趋近于 $0$ 时，经过修饰的观测量如何过渡到未经修饰的观测量。\n\n基本原理：\n- 核心行为由量子色动力学 (QCD) 的红外和共线结构决定。如果一个观测量对于增加动量为零的发射不敏感，则它是红外安全的；如果它对于将一个粒子替换为动量之和等于原始动量的两个共线粒子不敏感，则它是共线安全的。像 Cambridge/Aachen 这样的确定性聚类算法被设计成在喷注层面上是红外和共线安全的。\n- 您必须使用以下定义和事实作为基本原理：\n  1. Cambridge/Aachen 聚类：在每次迭代中，合并角距离最小的一对伪喷注，其中在一维方位角空间中的成对角间距为 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$。持续此过程直到只剩下一个伪喷注，从而产生一个二元聚类树。使用 $p_T$ 方案重组，即合并节点 $a$ 和 $b$ 时，新的伪喷注的总横向动量为 $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$，角度为 $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$。\n  2. 未经修饰的末次分裂事件形状是在最终聚类步骤中的动量共享：\n     $$ z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     这是共线安全的，因为任何共线分裂都发生在消失角上，并在末次分裂之前被合并，从而使末次分裂保持不变。它是软不安全的，因为增加一个动量为 $\\epsilon$ 的广角发射可以产生一个末次分裂，其 $z_{\\text{last}} \\approx \\epsilon/(p_{T,\\text{hard}} + \\epsilon) \\to 0$ 当 $\\epsilon \\to 0$ 时。\n  3. 角指数 $\\beta = 0$ 的 Soft Drop 修饰被递归地定义为从根节点开始对 C/A 树进行解聚类：在每次分裂成横向动量为 $p_{T,1}$ 和 $p_{T,2}$ 的两个分支时，计算\n     $$ z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     如果 $z  z_\\text{cut}$，则接受该分裂并定义 $z_g = z$。如果 $z \\le z_\\text{cut}$，则丢弃较软的分支并在较硬的分支上继续解聚类。如果没有分裂通过阈值，则定义 $z_g = 0$。对于固定的 $z_\\text{cut}  0$，$z_g$ 是 Sudakov 安全的；当 $z_\\text{cut} \\to 0$ 时，$z_g$ 趋近于未经修饰的 $z_{\\text{last}}$ 并失去软安全性。\n\n任务：\n- 对由横向动量 $p_T$（单位 $\\text{GeV}$）和角度 $\\phi$（单位弧度）表示的粒子列表实现一维 Cambridge/Aachen 聚类。将 $\\phi$ 视为一个没有周期性环绕的实数（单位弧度）；仅使用 $\\Delta\\phi = |\\phi_i - \\phi_j|$。\n- 使用上述重组方案，通过反复合并 $\\Delta\\phi$ 最小的粒子对来构建二元树。最后一次合并定义了末次分裂。对于只包含单个粒子的集合，按照惯例定义 $z_{\\text{last}} = 0$。\n- 实现 $\\beta = 0$ 和阈值 $z_\\text{cut}$ 的 Soft Drop 修饰。解聚类从聚类树的根节点开始：在每个子节点动量为 $p_{T,1}$ 和 $p_{T,2}$ 的分裂处，如上计算 $z$ 并与 $z_\\text{cut}$ 比较。如果 $z  z_\\text{cut}$，设置 $z_g = z$；否则，丢弃较软的子节点并沿着较硬的子节点继续解聚类。如果在未接受任何分裂的情况下到达叶节点，则定义 $z_g = 0$。对于单粒子输入，对所有 $z_\\text{cut}$ 定义 $z_g = 0$。\n- 为测试套件中的每个事件计算一个列表，其中包含 $[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$。所有输出均为无量纲实数。不要进行四舍五入；报告您的实现所产生的全精度浮点结果。\n\n单位和约定：\n- 所有横向动量 $p_T$ 的单位均为 $\\text{GeV}$。\n- 所有角度 $\\phi$ 的单位均为弧度。\n- 输出 $z_{\\text{last}}$ 和 $z_g$ 是无量纲的。\n\n测试套件：\n- 事件 $1$（软不安全演示）：三个粒子， $[(p_T,\\phi)] = [(100, 0.0), (50, 0.1), (10^{-6}, 1.0)]$。这会在硬聚类和广角软粒子之间产生一个末次分裂，使得 $z_{\\text{last}}$ 对软发射敏感。对于 $z_\\text{cut} \\in \\{0.1, 0.01\\}$，经过修饰的 $z_g$ 会选择硬分裂，并随着 $z_\\text{cut} \\to 0$ 过渡到 $z_{\\text{last}}$。\n- 事件 $2$（共线安全性检查）：三个粒子， $[(p_T,\\phi)] = [(70, 0.0), (30, 10^{-6}), (50, 0.8)]$。两个近似共线的粒子模拟了一个 $100$ $\\text{GeV}$ 分支的共线分裂；C/A 算法会首先合并它们，因此末次分裂，以及 $z_{\\text{last}}$ 和 $z_g$，将保持与对应的双分支情况下的值相等。\n- 事件 $3$（边界情况）：一个粒子， $[(p_T,\\phi)] = [(123, 0.5)]$。没有分裂；按照惯例，对于所有 $z_\\text{cut}$，$z_{\\text{last}} = 0$ 且 $z_g = 0$。\n\n您的程序应生成单行输出，其中包含以上述顺序排列的三个事件的结果，格式为逗号分隔的列表的列表，例如，\n\"[[z_last_1,zg_1_0.1,zg_1_0.01,zg_1_1e-9],[z_last_2,zg_2_0.1,zg_2_0.01,zg_2_1e-9],[z_last_3,zg_3_0.1,zg_3_0.01,zg_3_1e-9]]\"\n并用数值填充占位符。不应打印任何其他文本。",
            "solution": "该问题是有效的。\n\n### 步骤 1：提取已知条件\n- **任务**：实现 Cambridge/Aachen (C/A) 聚类、一个未经修饰的观测量 $z_{\\text{last}}$ 和一个使用 Soft Drop 的修饰观测量 $z_g$。在给定的测试套件上分析它们的行为。\n- **聚类算法**：一维 Cambridge/Aachen (C/A)。\n    - **度量**：迭代合并角距离 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$ 最小的一对伪喷注 $(i, j)$。\n    - **重组方案**：对于合并横向动量为 $p_{T,a}$、$p_{T,b}$ 和角度为 $\\phi_a$、$\\phi_b$ 的伪喷注 $a$ 和 $b$：\n        - $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$\n        - $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$\n- **未经修饰的观测量 ($z_{\\text{last}}$)**:\n    - 定义为最终聚类步骤中的动量共享。对于两个动量为 $p_{T,1}$ 和 $p_{T,2}$ 的子喷注，$z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$。\n    - 对于只有一个粒子的事件，$z_{\\text{last}} = 0$。\n- **修饰观测量 ($z_g$)**:\n    - **算法**：使用角指数 $\\beta = 0$ 和动量共享阈值 $z_\\text{cut}$ 的 Soft Drop 修饰。\n    - **过程**：从根节点开始递归地对 C/A 树进行解聚类。在每次分裂成动量为 $p_{T,1}$ 和 $p_{T,2}$ 的分支时，计算 $z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$。\n        - 如果 $z  z_\\text{cut}$，分裂被接受。定义 $z_g = z$ 并停止。\n        - 如果 $z \\le z_\\text{cut}$，较软的分支被丢弃。在较硬的分支上继续解聚类。\n        - 如果没有分裂通过阈值（即到达叶节点），则定义 $z_g = 0$。\n    - 对于只有一个粒子的事件，$z_g = 0$。\n- **计算任务**：为每个事件计算一个包含四个值的列表：$[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$。\n- **测试套件**：\n    - 事件 1： $[(p_T=100\\,\\text{GeV}, \\phi=0.0), (p_T=50\\,\\text{GeV}, \\phi=0.1), (p_T=10^{-6}\\,\\text{GeV}, \\phi=1.0)]$\n    - 事件 2： $[(p_T=70\\,\\text{GeV}, \\phi=0.0), (p_T=30\\,\\text{GeV}, \\phi=10^{-6}), (p_T=50\\,\\text{GeV}, \\phi=0.8)]$\n    - 事件 3： $[(p_T=123\\,\\text{GeV}, \\phi=0.5)]$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上植根于量子色动力学 (QCD) 和喷注物理学，特别是涉及红外和共线 (IRC) 安全性、喷注聚类算法 (C/A) 和喷注修饰技术 (Soft Drop) 等成熟概念。所提供的算法和观测量定义是标准且正确的。该问题是适定 (well-posed) 的，因为 C/A 算法和 Soft Drop 程序的确定性确保了任何给定输入都有唯一解。问题陈述是客观、完整且自洽的，提供了所有必要的定义、常数和测试用例。物理场景虽经简化但合情合理，可作为关键物理原理的有效教学示例。因此，该问题被认为是**有效的**。\n\n### 步骤 3：进行求解\n\n#### 基于原理的算法设计\n\n解决方案的关键在于构建一个二元聚类树，然后对其进行分析。这个由 Cambridge/Aachen (C/A) 算法生成的结构，编码了喷注形成的几何历史。然后通过遍历这棵树来计算观测量。\n\n**1. 伪喷注的数据结构和树的构建**\n\n为了表示聚类过程中任意时刻的系统状态，我们定义一个 `PseudoJet` 对象。该对象封装了粒子或粒子簇的运动学属性，特别是其横向动量 $p_T$ 和角度 $\\phi$。关键是，为了形成二元树，每个由合并产生的 `PseudoJet` 还必须存储对其两个组成部分（在解聚类意义上的子节点）的引用。代表初始粒子的 `PseudoJet` 是没有子节点的叶节点。\n\n**2. Cambridge/Aachen (C/A) 聚类实现**\n\nC/A 算法遵循角序原理。它通过迭代合并角间距 $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$ 最小的一对伪喷注来构建喷注结构。此过程实现如下：\n1. 从输入粒子初始化一个 `PseudoJet` 对象列表。\n2. 当列表中还存在多于一个 `PseudoJet` 时：\n    a. 找到使 $\\Delta\\phi_{ij}$ 最小的一对 $(i, j)$。这是一个对所有唯一对的暴力搜索。\n    b. 使用指定的 $p_T$ 方案重组规则将这对合并成一个新的 `PseudoJet`：$p_{T,\\text{new}} = p_{T,i} + p_{T,j}$ 和 $\\phi_{\\text{new}} = (p_{T,i}\\phi_i + p_{T,j}\\phi_j) / p_{T,\\text{new}}$。两个被合并的伪喷注被存储为新伪喷注的子节点。\n    c. 从活动列表中移除被合并的伪喷注，并添加新形成的伪喷注。\n3. 当只剩下一个 `PseudoJet` 时，过程终止。这就是聚类树的根节点。\n\n**3. 未经修饰的观测量：$z_{\\text{last}}$**\n\n观测量 $z_{\\text{last}}$ 是 C/A 序列中最后一次分裂的动量平衡的度量。它是直接从树的根节点的两个子节点计算出来的。如果它们的动量是 $p_{T,1}$ 和 $p_{T,2}$，那么 $z_{\\text{last}} = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$。\n\n这个观测量是共线安全的，因为共线分裂产生的粒子具有非常小的角间距。C/A 算法会在早期阶段将它们合并，从而使最终的、最大角度的分裂保持不变。然而，$z_{\\text{last}}$ 是软不安全的。如事件 1 所示，一个位于大角度的软粒子（例如，$p_T = 10^{-6}\\,\\text{GeV}$ at $\\phi=1.0$）会被最后合并。这次最终分裂变得极不平衡，导致当软粒子的动量趋于零时，$z_{\\text{last}} \\to 0$，使得该观测量对软辐射敏感。\n\n**4. 使用 Soft Drop 的修饰观测量：$z_g$**\n\nSoft Drop 修饰旨在通过移除软的、广角的辐射来恢复 Sudakov 安全性。它通过对 C/A 树进行“解聚类”来操作，有效地逆转了聚类过程。我们的实现是一个从根节点向下遍历树的递归函数：\n\n`get_zg(node, z_cut)`:\n1.  **基准情形**：如果 `node` 是一个叶节点（没有子节点），意味着我们已经解聚类到初始粒子而没有找到满足修饰条件的分裂。根据定义，我们返回 $z_g=0$。\n2.  **递归步骤**：如果 `node` 有动量为 $p_{T,1}$ 和 $p_{T,2}$ 的子节点，我们计算动量共享 $z = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$。\n    a.  **条件通过**：如果 $z  z_\\text{cut}$，则该分裂被认为是“足够硬”的。我们接受此分裂并将其 $z$ 值作为最终的 $z_g$ 返回。递归终止。\n    b.  **条件失败**：如果 $z \\le z_\\text{cut}$，则分裂太软。丢弃较软的子分支，函数在较硬的子分支上递归调用自身：`get_zg(harder_child, z_cut)`。\n\n对于事件 1，当 $z_\\text{cut}=0.1$ 或 $z_\\text{cut}=0.01$ 时，树根处的初始软分裂不满足条件。算法继续处理硬喷注内部的下一个分裂，该分裂是平衡的（$z=1/3$）并通过了条件，得到 $z_g=1/3$。这展示了软污染的移除。当 $z_\\text{cut} \\to 0$ 时（例如 $z_\\text{cut} = 10^{-9}$），Soft Drop 条件变得更加宽松。最初的软分裂现在通过了条件（$z_{\\text{last}} \\approx 6.7 \\times 10^{-9}  10^{-9}$），所以 $z_g$ 变得等于 $z_{\\text{last}}$，恢复了未经修饰的、软不安全的行为。\n\n对于事件 2，近似共线的粒子首先被合并，模拟了一个单一的硬分支。最后一次分裂发生在两个硬组分之间，产生一个较大的 $z_{\\text{last}} = 1/3$。这个分裂立即满足所有给定 $z_\\text{cut}$ 值的 Soft Drop 条件，所以 $z_g = z_{\\text{last}} = 1/3$ 始终成立。这说明了该过程的共线安全性。\n\n边界情况，即事件 3，只有一个粒子，没有分裂，因此按照惯例，所有的 $z_{\\text{last}}$ 和 $z_g$ 值都定义为 $0$。\n\n该实现将为所有测试用例计算这些值，并按要求格式化它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass PseudoJet:\n    \"\"\"\n    Represents a particle or a cluster of particles (jet) with its kinematic\n    properties and clustering history.\n    \"\"\"\n    def __init__(self, pT, phi, children=None):\n        self.pT = np.float64(pT)\n        self.phi = np.float64(phi)\n        self.children = children  # A tuple (child1, child2) or None for leaves\n\ndef solve_for_event(particles_data):\n    \"\"\"\n    Performs C/A clustering and calculates z_last and z_g for a single event.\n    \"\"\"\n    num_particles = len(particles_data)\n\n    # Handle boundary cases as per problem definition\n    if num_particles = 1:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Initialize list of active pseudojets\n    active_jets = [PseudoJet(pT, phi) for pT, phi in particles_data]\n\n    # Cambridge/Aachen clustering loop\n    while len(active_jets) > 1:\n        min_dist = np.inf\n        best_pair_indices = None\n\n        # Find pair with minimum angular distance\n        for i in range(len(active_jets)):\n            for j in range(i + 1, len(active_jets)):\n                dist = np.abs(active_jets[i].phi - active_jets[j].phi)\n                if dist  min_dist:\n                    min_dist = dist\n                    best_pair_indices = (i, j)\n        \n        # Unpack indices, ensuring i  j for easier list manipulation\n        i, j = sorted(best_pair_indices)\n        jet1, jet2 = active_jets[i], active_jets[j]\n\n        # pT-scheme recombination\n        new_pT = jet1.pT + jet2.pT\n        new_phi = (jet1.pT * jet1.phi + jet2.pT * jet2.phi) / new_pT\n        \n        # Create new jet, storing its history\n        new_jet = PseudoJet(new_pT, new_phi, children=(jet1, jet2))\n        \n        # Update the list of active jets for the next iteration\n        # Remove merged jets (larger index first) and add the new one\n        active_jets.pop(j)\n        active_jets.pop(i)\n        active_jets.append(new_jet)\n        \n    root_node = active_jets[0]\n\n    # Calculate z_last from the final split\n    child1, child2 = root_node.children\n    z_last = np.min([child1.pT, child2.pT]) / (child1.pT + child2.pT)\n\n    # Calculate z_g for specified z_cut values\n    z_cuts = [0.1, 0.01, 1e-9]\n    z_g_values = []\n    \n    def get_zg_recursive(node, z_cut):\n        \"\"\"\n        Recursively applies the Soft Drop grooming condition.\n        \"\"\"\n        # Base case: leaf node reached, no split passed the condition\n        if not node.children:\n            return np.float64(0.0)\n\n        pT1, pT2 = node.children[0].pT, node.children[1].pT\n        \n        # Momentum sharing for the current split\n        z = np.min([pT1, pT2]) / (pT1 + pT2)\n\n        if z > z_cut:\n            # Soft Drop condition passed, this is the groomed split\n            return z\n        else:\n            # Condition failed, drop softer branch and continue on harder branch\n            if pT1 > pT2:\n                harder_child = node.children[0]\n            else:\n                harder_child = node.children[1]\n            return get_zg_recursive(harder_child, z_cut)\n\n    for z_cut in z_cuts:\n        zg = get_zg_recursive(root_node, z_cut)\n        z_g_values.append(zg)\n\n    return [z_last] + z_g_values\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Event 1: soft-unsafe demonstration\n        [(100, 0.0), (50, 0.1), (1e-6, 1.0)],\n        # Event 2: collinear safety check\n        [(70, 0.0), (30, 1e-6), (50, 0.8)],\n        # Event 3: boundary case with one particle\n        [(123, 0.5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result_list = solve_for_event(case)\n        results.append(result_list)\n\n    # Format the output exactly as specified.\n    # The output is a string representation of a list of lists of floats.\n    list_strs = []\n    for res_list in results:\n        # Format each inner list to \"[v1,v2,v3,v4]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_strs.append(list_str)\n\n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(list_strs)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "顺序重组喷注算法的 IRC 安全性并非凭空产生，而是其距离度量数学形式的直接结果。这个高级实践将带你探究这一安全性的根本来源。你将实现一个广义的喷注算法，其中距离度量中的角度指数 $\\alpha$ 是一个可变参数。通过改变 $\\alpha$ 的值并观察共线安全性何时失效 ，你将亲手发现保证算法行为良好的精确数学条件，从而对喷注物理的理论基础获得更深层次的理解。",
            "id": "3517894",
            "problem": "从高能物理中使用的喷注算法的既定定义和通用结构出发，实现一个带有广义距离度量的序贯重组喷注算法，以研究红外和共线 (IRC) 安全性。其基本原理如下：\n\n- 序贯重组算法定义了对距离和束流距离，以迭代地将粒子聚类成喷注。对于由索引 $i$ 和 $j$ 标记的粒子，其横向动量为 $p_{Ti}$ 和 $p_{Tj}$，快度为 $y_i$ 和 $y_j$，方位角为 $\\phi_i$ 和 $\\phi_j$，定义角间距为\n$$\n\\Delta R_{ij} \\equiv \\sqrt{(y_i - y_j)^2 + (\\phi_i - \\phi_j)^2},\n$$\n其中所有角度均以弧度为单位。喷注半径参数为 $R$。\n\n- 通用距离度量族为\n$$\nd_{ij} = \\min\\left(p_{Ti}^{2p},\\, p_{Tj}^{2p}\\right)\\,\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}, \\qquad d_{iB} = p_{Ti}^{2p},\n$$\n其中 $p$ 是指定算法族的幂指数（例如，$p=-1$ 对应于 anti-$k_T$ 算法），$\\alpha$ 是一个广义角度指数。标准广义 $k_T$ 算法使用 $\\alpha=2$。在这里，您将考虑 $\\alpha \\neq 2$ 的情况，并研究其对 IRC 安全性的影响。\n\n- 重组方案是四动量（所谓的 E-方案）求和：当聚类 $i$ 和 $j$ 时，使用 $E = p_T \\cosh y$、$p_x = p_T \\cos\\phi$、$p_y = p_T \\sin\\phi$、$p_z = p_T \\sinh y$ 从 $(p_T, y, \\phi)$ 定义无质量四动量 $(E,\\vec{p})$，并通过对四动量求和进行重组。新的原初喷注运动学特性可从总和中恢复，假设为无质量运动学：$p_T = \\sqrt{p_x^2+p_y^2}$，$\\phi = \\operatorname{atan2}(p_y,p_x)$，以及 $y = \\tfrac{1}{2}\\ln\\left(\\frac{E+p_z}{E-p_z}\\right)$。\n\n待测试的安全性的定义：\n\n- 红外安全性：在 $p_T \\to 0$ 的极限下，添加一个任意软的粒子（其 $p_T \\to 0$）不能改变硬喷注的集合。\n\n- 共线安全性：在 $\\Delta R \\to 0$ 的极限下，用两个动量之和等于原始动量的共线粒子（其 $\\Delta R \\to 0$）替换一个粒子，不能改变最终重建的喷注。\n\n算法任务：\n\n1. 实现上述指定的包含性序贯重组算法。在每一步中，计算所有的 $d_{ij}$ 和 $d_{iB}$。选择最小的距离。如果它是一个对距离 $d_{ij}$，则通过四动量求和重组 $i$ 和 $j$；如果它是一个束流距离 $d_{iB}$，则声明 $i$ 为一个最终喷注并将其从原初喷注列表中移除。迭代此过程，直到没有原初喷注剩下。\n\n2. 为给定的 $(p,\\alpha,R)$ 实现两个诊断测试：\n   - 红外测试：对一个基础构型进行聚类，然后对添加了一个横向动量为 $\\epsilon p_T$（其中 $\\epsilon$ 极小）的极软粒子后的相同构型进行聚类。比较两组最硬的喷注，以验证它们在 $\\epsilon \\to 0$ 的极限下是一致的（通过使用一个非常小的 $\\epsilon$ 和数值容差来数值近似这个极限）。\n   - 共线测试：对一个基础构型进行聚类，然后对一个通过将一个硬粒子替换为两个向量和等于原始粒子且间距极小的近似共线粒子所获得的构型进行聚类。比较得到的喷注，以验证它们在 $\\Delta R \\to 0$ 的极限下是一致的（通过使用一个非常小的 $\\Delta R$ 和数值容差来数值近似这个极限）。\n\n3. 数值比较协议：\n   - 按 $p_T$ 降序对最终喷注进行排序，并在每次测试中比较两种构型的前 $N$ 个喷注（$N$ 的选择如下所述）。如果两个喷注的横向动量在相对容差 $\\delta_{p_T}$ 内一致，并且它们的轴在 $\\Delta R$ 上的角度容差 $\\delta_R$ 内一致，则认为它们匹配。\n   - 使用以下容差：$\\delta_{p_T} = 10^{-9}$（无量纲，相对值）和 $\\delta_R = 10^{-9}$（弧度）。在红外测试中，软粒子横向动量分数使用 $\\epsilon = 10^{-12}$，并使用 $\\Delta R_{\\text{split}} = 10^{-6}$ 的共线分裂间距，通过平衡的方位角和快度偏移来实现该间距。\n\n基础构型：\n\n- 红外测试基础构型包含两个硬粒子：\n  - 粒子 A：$(p_T, y, \\phi) = (100.0, 0.0, 0.0)$，\n  - 粒子 B：$(p_T, y, \\phi) = (80.0, 0.3, 1.8)$，\n  以及要添加的软粒子：\n  - 粒子 S：$(p_T, y, \\phi) = (\\epsilon \\times 100.0, 0.1, 0.9)$。\n  比较有和没有粒子 S 的构型之间的前 $N=2$ 个喷注。\n\n- 共线测试基础构型包含两个粒子：\n  - 粒子 H：$(p_T, y, \\phi) = (100.0, 0.0, 0.0)$，\n  - 粒子 M：$(p_T, y, \\phi) = (50.0, 0.4, 2.5)$。\n  共线分裂构型用两个粒子 $H_1$ 和 $H_2$ 替换粒子 H，其 $(p_T, y, \\phi)$ 分别为 $(60.0, \\delta y, \\delta \\phi)$ 和 $(40.0, -\\delta y, -\\delta \\phi)$，选择它们以满足\n  $$\n  \\sqrt{(2\\delta y)^2 + (2\\delta \\phi)^2} = \\Delta R_{\\text{split}} = 10^{-6}.\n  $$\n  为具体起见，取 $\\delta y = \\delta \\phi = \\Delta R_{\\text{split}}/(2\\sqrt{2})$。比较未分裂和分裂构型之间的前 $N=2$ 个喷注。\n\n测试套件和要求的输出：\n\n对以下由 $(p,\\alpha,R)$ 指定的参数集评估这两个诊断测试：\n\n- 测试 1：$(p,\\alpha,R) = (-1.0, 2.0, 0.6)$。\n- 测试 2：$(p,\\alpha,R) = (-1.0, 1.0, 0.6)$。\n- 测试 3：$(p,\\alpha,R) = (-1.0, 0.0, 0.6)$。\n- 测试 4：$(p,\\alpha,R) = (-1.0, -1.0, 0.6)$。\n\n对于每个测试，计算一个整数分数\n$$\nS = 2 \\times I + C,\n$$\n其中，如果红外测试通过，则 $I$ 为 $1$，否则为 $0$；如果共线测试通过，则 $C$ 为 $1$，否则为 $0$。因此 $S \\in \\{0,1,2,3\\}$，其中 $S=3$ 表示红外和共线安全性测试都通过，$S=2$ 表示只有红外测试通过，$S=1$ 表示只有共线测试通过，$S=0$ 表示两者都失败。\n\n您的程序应生成单行输出，其中包含测试 1 到 4 的分数，格式为方括号内以逗号分隔的列表（例如，“[3,3,2,2]”）。角度必须以弧度为单位。$p_T$ 不需要进行物理单位转换，因为只执行无量纲的安全性检查。输出必须完全由上述规范确定，无需任何用户输入。",
            "solution": "目标是评估一个广义序贯重组算法族的红外和共线 (IRC) 安全性，该算法族由对距离中的幂 $p$ 和广义角度指数 $\\alpha$ 参数化\n$$\nd_{ij} = \\min\\left(p_{Ti}^{2p},\\, p_{Tj}^{2p}\\right)\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha},\n$$\n束流距离为 $d_{iB} = p_{Ti}^{2p}$。标准广义 $k_T$ 族使用 $\\alpha=2$；在这里，我们探究 $\\alpha \\neq 2$ 的情况。\n\n原理：\n\n1. 红外安全性要求在 $p_T \\to 0$ 的极限下，添加一个粒子不会改变硬喷注的集合。在序贯重组算法中，添加一个无穷小软粒子 $s$ 会通过增加 $d_{sj}$ 和 $d_{sB}$ 来修改距离集合。对于 $p  0$（例如，anti-$k_T$ 算法中 $p=-1$），$d_{sB} = p_{Ts}^{2p}$ 极大，而 $d_{sj} = \\min(p_{Ts}^{2p}, p_{Tj}^{2p})(\\Delta R_{sj}/R)^{\\alpha} = p_{Tj}^{2p}(\\Delta R_{sj}/R)^{\\alpha}$，因为 $p_{Ts}^{2p}$ 很大而 $p_{Tj}^{2p}$ 很小。软粒子在被声明为喷注之前会并入某个硬原初喷注中。四动量重组通过一个被 $p_{Ts}$ 抑制的加性贡献来改变硬喷注的四动量；在 $p_{Ts} \\to 0$ 的极限下，这种扰动消失。因此，在缓和的条件下，硬喷注在红外极限下是稳定的。在数值上，必须设置一个非常小的 $\\epsilon$ 并用严格的容差比较喷注。\n\n2. 共线安全性要求，如果一个粒子分裂成两个 $\\Delta R \\to 0$ 且动量之和等于原始动量的粒子，聚类过程应在任何束流声明之前首先重组这对粒子，从而有效地撤销分裂并恢复原始的最终喷注。对于广义度量，\n$$\nd_{ij} = \\min(p_{Ti}^{2p}, p_{Tj}^{2p})\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}.\n$$\n到束流的距离为 $d_{iB} = p_{Ti}^{2p}$ 和 $d_{jB} = p_{Tj}^{2p}$。为了使共线安全性稳健成立，要求在 $\\Delta R_{ij} \\to 0$ 时有 $d_{ij}  \\min(d_{iB}, d_{jB})$。等价于，\n$$\n\\min(p_{Ti}^{2p}, p_{Tj}^{2p})\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}  \\min(p_{Ti}^{2p}, p_{Tj}^{2p}).\n$$\n消去公因式得到\n$$\n\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}  1.\n$$\n对于 $\\Delta R_{ij}/R  1$，当且仅当 $\\alpha  0$ 时该不等式成立，当 $\\alpha  0$ 时不成立，当 $\\alpha = 0$ 时为临界情况（相等）。因此，根据第一性原理，在严格极限下，该广义度量对于 $\\alpha  0$ 是共线安全的，而对于 $\\alpha \\le 0$ 则不满足共线安全性。对于 $\\alpha=0$ 的失败表现为一种简并，即对距离等于较小的束流距离；在实践中，这种简并可能被扰动打破，导致不稳健的聚类。\n\n算法设计：\n\n- 通过在每一步计算所有距离 $d_{ij}$ 和 $d_{iB}$ 并选择最小值来实现包含性聚类。如果最小值是对距离，则通过四动量求和进行合并；如果是束流距离，则将该原初喷注最终确定为喷注。\n\n- 将粒子表示为从 $(p_T, y, \\phi)$ 导出的无质量四动量，通过 $E = p_T \\cosh y$，$p_x = p_T \\cos\\phi$，$p_y = p_T \\sin\\phi$ 和 $p_z = p_T \\sinh y$。重组时，对 $(E, \\vec{p})$ 求和，并通过 $p_T = \\sqrt{p_x^2+p_y^2}$，$\\phi = \\operatorname{atan2}(p_y,p_x)$ 和 $y = \\tfrac{1}{2}\\ln\\left(\\frac{E+p_z}{E-p_z}\\right)$ 恢复 $(p_T, y, \\phi)$，并采用小的数值保护措施以保持 $E > |p_z|$。\n\n诊断：\n\n- 对于红外测试，对有和没有添加软粒子的基础双硬粒子构型进行聚类。通过检查前 $N=2$ 个喷注的 $p_T$ 值在相对容差 $\\delta_{p_T} = 10^{-9}$ 内一致，且它们的轴在 $\\Delta R$ 上的一致性在 $\\delta_R = 10^{-9}$ 内，来比较它们。软粒子使用相对于硬标度为 $\\epsilon = 10^{-12}$ 的值。通过此测试得到 $I=1$，失败则得到 $I=0$。\n\n- 对于共线测试，对双粒子基础构型和一个分裂构型进行聚类，其中 $p_T=100.0$ 的粒子被替换为两个 $p_T=60.0$ 和 $p_T=40.0$ 的近似共线粒子，通过选择 $\\delta y = \\delta \\phi = \\Delta R_{\\text{split}}/(2\\sqrt{2})$ 使其间距为 $\\Delta R_{\\text{split}}=10^{-6}$。使用相同的容差比较前 $N=2$ 个喷注。通过此测试得到 $C=1$，失败则得到 $C=0$。\n\n计分和预期趋势：\n\n- 对于 $(p,\\alpha,R) = (-1.0, 2.0, 0.6)$（具有标准角度指数的 anti-$k_T$），两个测试都应通过，得到 $S=3$。\n\n- 对于 $(p,\\alpha,R) = (-1.0, 1.0, 0.6)$，由于 $\\alpha0$，共线安全性不等式 $(\\Delta R/R)^{\\alpha}  1$ 对小的 $\\Delta R$ 成立，因此它也应该是共线安全的；红外安全性得以保持，因此 $S=3$。\n\n- 对于 $(p,\\alpha,R) = (-1.0, 0.0, 0.6)$，共线安全性不等式变为等式，表明不稳健性。在数值上，根据微妙的排序，人们可能检测到也可能检测不到失败，但算法将根据规定的容差客观地比较结果。如果聚类结果恰好相同，则 $C=1$；否则 $C=0$。\n\n- 对于 $(p,\\alpha,R) = (-1.0, -1.0, 0.6)$，共线安全性不等式被违反，因此分裂的粒子对在束流声明之前不会优先重组；这通常会改变结果并导致 $C=0$。对于使用四动量重组的序贯重组算法，红外安全性通常是保留的，所以预期 $I=1$。程序将通过数值检查来确认。\n\n实现细节：\n\n- 代码完全按照规定计算距离并进行聚类直至完成。\n\n- 喷注比较是通过匹配两个前 $N$ 个喷注的列表来完成的：按 $p_T$ 排序，然后使用指定的容差检查成对的一致性。\n\n- 最终输出打印一行，其中包含测试 1 到 4 的整数分数 $S = 2I + C$ 列表。\n\n该方法将 IRC 安全性的基本定义与计算算法相结合，并提供了一个跨参数区域的具体、可测试的基准，突出了当 $\\alpha \\le 0$ 时共线安全性的退化，同时确认了当 $\\alpha > 0$ 时的稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Utilities to convert between (pt, y, phi) and massless four-vectors (E, px, py, pz)\ndef ptyphi_to_four(pt, y, phi):\n    px = pt * np.cos(phi)\n    py = pt * np.sin(phi)\n    pz = pt * np.sinh(y)\n    E = pt * np.cosh(y)\n    return np.array([E, px, py, pz], dtype=float)\n\ndef four_to_ptyphi(four):\n    E, px, py, pz = four\n    pt = np.hypot(px, py)\n    phi = np.arctan2(py, px)\n    # Numerical safeguard: ensure E > |pz|\n    # If E = |pz| due to rounding, nudge slightly to avoid invalid rapidity.\n    tiny = 1e-18\n    if E = abs(pz):\n        # increase E minimally\n        E = abs(pz) + (abs(pz) + 1.0) * tiny\n    y = 0.5 * np.log((E + pz) / (E - pz))\n    return float(pt), float(y), float(phi)\n\ndef deltaR(y1, phi1, y2, phi2):\n    dphi = np.arctan2(np.sin(phi1 - phi2), np.cos(phi1 - phi2))\n    dy = y1 - y2\n    return np.hypot(dy, dphi)\n\n# Sequential recombination clustering with generalized metric\ndef cluster_jets(particles, p, alpha, R):\n    # particles: list of (pt, y, phi)\n    # Represent protojets as dictionaries holding both kinematics and 4-vector\n    protojets = []\n    for pt, y, phi in particles:\n        four = ptyphi_to_four(pt, y, phi)\n        protojets.append({\"pt\": pt, \"y\": y, \"phi\": phi, \"four\": four})\n\n    jets = []\n\n    # Predefine exponent calculation with care for alpha=0\n    def dij(pi, pj):\n        # Pairwise distance\n        pti = pi[\"pt\"]\n        ptj = pj[\"pt\"]\n        # min(pt^{2p})\n        wij = min(pti ** (2.0 * p), ptj ** (2.0 * p))\n        if alpha == 0.0:\n            ang = 1.0\n        else:\n            ang = (deltaR(pi[\"y\"], pi[\"phi\"], pj[\"y\"], pj[\"phi\"]) / R) ** alpha\n        return wij * ang\n\n    def diB(pi):\n        return pi[\"pt\"] ** (2.0 * p)\n\n    # Main clustering loop\n    while len(protojets) > 0:\n        # Compute all distances and find global minimum\n        min_val = None\n        min_pair = None  # (i,j)\n        min_beam = None  # i\n        n = len(protojets)\n        # Pairwise\n        for i in range(n):\n            # Beam distance\n            di = diB(protojets[i])\n            if (min_val is None) or (di  min_val) or (di == min_val and min_beam is None and min_pair is not None):\n                min_val = di\n                min_beam = i\n                min_pair = None\n            # Pairwise distances\n            for j in range(i + 1, n):\n                dij_val = dij(protojets[i], protojets[j])\n                if (min_val is None) or (dij_val  min_val) or (dij_val == min_val and min_pair is None):\n                    min_val = dij_val\n                    min_pair = (i, j)\n                    min_beam = None\n\n        # Act on minimum\n        if min_pair is not None:\n            i, j = min_pair\n            # Recombine i and j by four-vector sum\n            fi = protojets[i][\"four\"]\n            fj = protojets[j][\"four\"]\n            fsum = fi + fj\n            pt_new, y_new, phi_new = four_to_ptyphi(fsum)\n            new = {\"pt\": pt_new, \"y\": y_new, \"phi\": phi_new, \"four\": fsum}\n            # Remove j>i first to keep indices correct\n            for idx in sorted([i, j], reverse=True):\n                del protojets[idx]\n            protojets.append(new)\n        else:\n            # Beam declaration\n            i = min_beam\n            jets.append(protojets[i])\n            del protojets[i]\n\n    # Sort jets by pt descending\n    jets.sort(key=lambda J: -J[\"pt\"])\n    # Convert to simple tuples for comparison\n    jets_simple = [(J[\"pt\"], J[\"y\"], J[\"phi\"]) for J in jets]\n    return jets_simple\n\n# Matching utilities\ndef match_jets(jetsA, jetsB, N=2, rel_pt_tol=1e-9, dr_tol=1e-9):\n    # Compare top N jets from both lists\n    JA = jetsA[:N]\n    JB = jetsB[:N]\n    if len(JA) != len(JB):\n        return False\n    # Sort both by pt descending (already sorted in cluster_jets)\n    for (ptA, yA, phiA), (ptB, yB, phiB) in zip(JA, JB):\n        # Relative pt agreement\n        if ptA == 0.0 and ptB == 0.0:\n            pt_ok = True\n        else:\n            denom = max(ptA, ptB, 1e-30)\n            pt_ok = abs(ptA - ptB) / denom = rel_pt_tol\n        # Axis agreement\n        dr = deltaR(yA, phiA, yB, phiB)\n        if not (pt_ok and dr = dr_tol):\n            return False\n    return True\n\n# Infrared test\ndef infrared_test(p, alpha, R, eps=1e-12):\n    # Base configuration: two hard particles\n    base_particles = [\n        (100.0, 0.0, 0.0),\n        (80.0, 0.3, 1.8),\n    ]\n    # Add very soft particle scaled by eps relative to 100.0\n    soft_particle = (100.0 * eps, 0.1, 0.9)\n    jets_base = cluster_jets(base_particles, p, alpha, R)\n    jets_soft = cluster_jets(base_particles + [soft_particle], p, alpha, R)\n    # Compare top N=2 jets\n    return match_jets(jets_base, jets_soft, N=2, rel_pt_tol=1e-9, dr_tol=1e-9)\n\n# Collinear test\ndef collinear_test(p, alpha, R, dr_split=1e-6):\n    # Base configuration: one hard and one medium\n    base_particles = [\n        (100.0, 0.0, 0.0),       # H\n        (50.0, 0.4, 2.5),        # M\n    ]\n    # Split H into H1 and H2 with separation dr_split and balanced offsets\n    delta = dr_split / (2.0 * np.sqrt(2.0))\n    H1 = (60.0, delta, delta)\n    H2 = (40.0, -delta, -delta)\n    split_particles = [H1, H2, (50.0, 0.4, 2.5)]\n    jets_base = cluster_jets(base_particles, p, alpha, R)\n    jets_split = cluster_jets(split_particles, p, alpha, R)\n    # Compare top N=2 jets\n    return match_jets(jets_base, jets_split, N=2, rel_pt_tol=1e-9, dr_tol=1e-9)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (p, alpha, R)\n    test_cases = [\n        (-1.0, 2.0, 0.6),   # Test 1\n        (-1.0, 1.0, 0.6),   # Test 2\n        (-1.0, 0.0, 0.6),   # Test 3\n        (-1.0, -1.0, 0.6),  # Test 4\n    ]\n\n    results = []\n    for p, alpha, R in test_cases:\n        I = 1 if infrared_test(p, alpha, R, eps=1e-12) else 0\n        C = 1 if collinear_test(p, alpha, R, dr_split=1e-6) else 0\n        score = 2 * I + C\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}