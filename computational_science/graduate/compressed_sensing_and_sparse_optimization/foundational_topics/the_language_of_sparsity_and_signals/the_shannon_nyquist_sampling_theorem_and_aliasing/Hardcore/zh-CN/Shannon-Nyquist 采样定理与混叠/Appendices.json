{
    "hands_on_practices": [
        {
            "introduction": "这个入门练习将带你亲手计算混叠的直接后果。通过对一个包含超出奈奎斯特极限频率分量的多音信号进行采样，你将直接观察到高频分量如何“折叠”回基带，甚至与其它分量叠加。这个练习旨在巩固你对离散时间信号频谱周期性以及混叠现象核心机制的理解 ()。",
            "id": "3490203",
            "problem": "考虑一个连续时间稀疏多音信号，其模型为复指数的有限和，\n$$\ns(t) \\;=\\; \\sum_{k=1}^{5} c_k \\,\\exp\\!\\big(\\mathrm{i}\\,2\\pi f_k\\,t\\big),\n$$\n其中 $t$ 是时间，$f_k$ 是互不相同的正载波频率，$c_k$ 是复振幅。该信号以采样频率 $F_s$ 进行均匀理想点采样（无抗混叠滤波），得到离散时间序列 $x[n] \\,=\\, s(n T_s)$，其中 $n$ 为整数，$T_s \\,=\\, 1/F_s$。\n\n设采样频率为 $F_s \\,=\\, 2000$，各音调分布在不同的奈奎斯特区，具体如下：\n- $f_1 \\,=\\, 700$，对应 $c_1 \\,=\\, 1$，\n- $f_2 \\,=\\, 2400$，对应 $c_2 \\,=\\, 2\\,\\exp\\!\\big(\\mathrm{i}\\,\\frac{\\pi}{3}\\big)$，\n- $f_3 \\,=\\, 4400$，对应 $c_3 \\,=\\, 3\\,\\exp\\!\\big(-\\mathrm{i}\\,\\frac{\\pi}{6}\\big)$，\n- $f_4 \\,=\\, 3900$，对应 $c_4 \\,=\\, -\\,\\mathrm{i}$，\n- $f_5 \\,=\\, 5100$，对应 $c_5 \\,=\\, \\frac{1}{2}$。\n\n在理想采样条件下，每个频率为 $f_k$ 的连续时间音调会产生一个离散时间复指数，其离散时间弧度频率为 $\\omega_k \\,=\\, 2\\pi\\,\\frac{f_k}{F_s}$。该频率以 $2\\pi$ 为周期定义，并通常表示在主区间 $[-\\pi,\\pi]$ 内。由于混叠效应，不同的 $f_k$ 值可能会映射到 $[-\\pi,\\pi]$ 内的同一个离散时间频率，此时它们的复振幅根据线性性质相加。\n\n从采样和频谱周期性的第一性原理出发，推导在区间 $[-\\pi,\\pi]$ 内所有唯一的混叠离散时间弧度频率及其对应的直角坐标形式的复振幅。将混叠到同一离散时间频率的音调进行合并。按离散时间频率的升序对所得的频率-振幅对进行排序。离散时间频率以弧度表示，振幅以直角坐标形式的精确复数表示。无需四舍五入。\n\n将你的最终答案表示为一个单行矩阵，其中交替出现离散时间频率和复振幅条目，即按 $\\omega$ 的升序排列的 $\\omega_1, A_1, \\omega_2, A_2, \\dots$。",
            "solution": "该问题是有效的，因为它科学地基于数字信号处理的原理，问题本身提法良好，提供了所有必要信息，并且其表述是客观的。\n\n该问题要求计算对一个多音信号进行均匀采样后，得到的唯一混叠离散时间频率及其对应的复振幅。\n\n连续时间信号由下式给出\n$$s(t) = \\sum_{k=1}^{5} c_k \\exp(\\mathrm{i} 2\\pi f_k t)$$\n以速率 $F_s$ 对该信号进行采样，意味着对于整数 $n$，令 $t=nT_s = n/F_s$。得到的离散时间序列为 $x[n] = s(n/F_s)$，根据线性性质，它是各个采样后音调之和：\n$$x[n] = \\sum_{k=1}^{5} c_k \\exp\\left(\\mathrm{i} 2\\pi f_k \\frac{n}{F_s}\\right) = \\sum_{k=1}^{5} c_k \\exp(\\mathrm{i} \\omega_k n)$$\n其中 $\\omega_k = 2\\pi \\frac{f_k}{F_s}$ 是对应于连续时间频率 $f_k$ 的离散时间弧度频率。\n\n混叠现象的核心在于离散时间复指数 $\\exp(\\mathrm{i} \\omega n)$ 在 $\\omega$ 上是周期性的，周期为 $2\\pi$。也就是说，对于任何整数 $m$，\n$$\\exp(\\mathrm{i} (\\omega + 2\\pi m) n) = \\exp(\\mathrm{i} \\omega n) \\exp(\\mathrm{i} 2\\pi m n) = \\exp(\\mathrm{i} \\omega n)$$\n因为对于整数 $m$ 和 $n$，$\\exp(\\mathrm{i} 2\\pi m n) = 1$。因此，所有映射到相差 $2\\pi$ 整数倍的离散时间频率 $\\omega_k$ 的连续时间频率 $f_k$ 在采样后是无法区分的。标准惯例是将任何离散时间频率用其在主区间 $[-\\pi, \\pi]$ 内的唯一混叠别名来表示。\n\n给定一个连续频率 $f$ 和一个采样频率 $F_s$，可以通过将 $\\omega = 2\\pi \\frac{f}{F_s}$ 映射到主区间来找到混叠频率 $\\omega_{\\text{alias}} \\in [-\\pi, \\pi]$。这可以表示为：\n$$\\omega_{\\text{alias}} = \\omega - 2\\pi m = 2\\pi \\frac{f}{F_s} - 2\\pi m$$\n其中选择整数 $m$ 使得 $-\\pi \\le \\omega_{\\text{alias}} \\le \\pi$。这等价于找到 $m$ 使得 $-\\frac{1}{2} \\le \\frac{f}{F_s} - m \\le \\frac{1}{2}$，这意味着 $m$ 是最接近归一化频率 $\\frac{f}{F_s}$ 的整数，即 $m = \\text{round}(\\frac{f}{F_s})$。\n\n给定的采样频率是 $F_s = 2000$。我们现在将为 5 个音调中的每一个计算其混叠离散时间频率。我们还将复振幅转换为直角坐标形式 $a+b\\mathrm{i}$。\n\n**音调 1：**\n- 频率：$f_1 = 700$。\n- 归一化频率：$\\frac{f_1}{F_s} = \\frac{700}{2000} = 0.35$。\n- $m_1 = \\text{round}(0.35) = 0$。\n- 混叠离散时间频率：$\\omega'_1 = 2\\pi (\\frac{f_1}{F_s} - m_1) = 2\\pi(0.35 - 0) = 0.7\\pi = \\frac{7\\pi}{10}$。\n- 复振幅：$c_1 = 1$。\n\n**音调 2：**\n- 频率：$f_2 = 2400$。\n- 归一化频率：$\\frac{f_2}{F_s} = \\frac{2400}{2000} = 1.2$。\n- $m_2 = \\text{round}(1.2) = 1$。\n- 混叠离散时间频率：$\\omega'_2 = 2\\pi (\\frac{f_2}{F_s} - m_2) = 2\\pi(1.2 - 1) = 0.4\\pi = \\frac{2\\pi}{5}$。\n- 复振幅：$c_2 = 2\\exp(\\mathrm{i}\\frac{\\pi}{3}) = 2\\left(\\cos\\frac{\\pi}{3} + \\mathrm{i}\\sin\\frac{\\pi}{3}\\right) = 2\\left(\\frac{1}{2} + \\mathrm{i}\\frac{\\sqrt{3}}{2}\\right) = 1 + \\mathrm{i}\\sqrt{3}$。\n\n**音调 3：**\n- 频率：$f_3 = 4400$。\n- 归一化频率：$\\frac{f_3}{F_s} = \\frac{4400}{2000} = 2.2$。\n- $m_3 = \\text{round}(2.2) = 2$。\n- 混叠离散时间频率：$\\omega'_3 = 2\\pi (\\frac{f_3}{F_s} - m_3) = 2\\pi(2.2 - 2) = 0.4\\pi = \\frac{2\\pi}{5}$。\n- 复振幅：$c_3 = 3\\exp(-\\mathrm{i}\\frac{\\pi}{6}) = 3\\left(\\cos(-\\frac{\\pi}{6}) + \\mathrm{i}\\sin(-\\frac{\\pi}{6})\\right) = 3\\left(\\frac{\\sqrt{3}}{2} - \\mathrm{i}\\frac{1}{2}\\right) = \\frac{3\\sqrt{3}}{2} - \\mathrm{i}\\frac{3}{2}$。\n\n**音调 4：**\n- 频率：$f_4 = 3900$。\n- 归一化频率：$\\frac{f_4}{F_s} = \\frac{3900}{2000} = 1.95$。\n- $m_4 = \\text{round}(1.95) = 2$。\n- 混叠离散时间频率：$\\omega'_4 = 2\\pi (\\frac{f_4}{F_s} - m_4) = 2\\pi(1.95 - 2) = 2\\pi(-0.05) = -0.1\\pi = -\\frac{\\pi}{10}$。\n- 复振幅：$c_4 = -\\mathrm{i}$。\n\n**音调 5：**\n- 频率：$f_5 = 5100$。\n- 归一化频率：$\\frac{f_5}{F_s} = \\frac{5100}{2000} = 2.55$。\n- $m_5 = \\text{round}(2.55) = 3$。\n- 混叠离散时间频率：$\\omega'_5 = 2\\pi (\\frac{f_5}{F_s} - m_5) = 2\\pi(2.55 - 3) = 2\\pi(-0.45) = -0.9\\pi = -\\frac{9\\pi}{10}$。\n- 复振幅：$c_5 = \\frac{1}{2}$。\n\n现在，我们必须合并混叠到同一频率的音调。我们观察到音调 2 和音调 3 都混叠到 $\\omega = \\frac{2\\pi}{5}$。根据线性性质，它们的复振幅相加。\n- 对于 $\\omega = \\frac{2\\pi}{5}$ 的合并振幅：\n$$A_{2+3} = c_2 + c_3 = (1 + \\mathrm{i}\\sqrt{3}) + \\left(\\frac{3\\sqrt{3}}{2} - \\mathrm{i}\\frac{3}{2}\\right) = \\left(1 + \\frac{3\\sqrt{3}}{2}\\right) + \\mathrm{i}\\left(\\sqrt{3} - \\frac{3}{2}\\right)$$\n\n这样我们就得到了唯一的混叠频率及其最终复振幅的完整集合：\n1.  频率：$-\\frac{9\\pi}{10}$ (来自音调 5)，振幅：$\\frac{1}{2}$。\n2.  频率：$-\\frac{\\pi}{10}$ (来自音调 4)，振幅：$-\\mathrm{i}$。\n3.  频率：$\\frac{2\\pi}{5}$ (来自音调 2 和 3)，振幅：$\\left(1 + \\frac{3\\sqrt{3}}{2}\\right) + \\mathrm{i}\\left(\\sqrt{3} - \\frac{3}{2}\\right)$。\n4.  频率：$\\frac{7\\pi}{10}$ (来自音调 1)，振幅：$1$。\n\n问题要求按离散时间频率的升序对这些对进行排序。这些频率是 $-\\frac{9\\pi}{10}$，$-\\frac{\\pi}{10}$，$\\frac{2\\pi}{5} = \\frac{4\\pi}{10}$ 和 $\\frac{7\\pi}{10}$。当前列表已经按频率升序排列。\n\n最终结果以一个单行矩阵的形式呈现，其中频率和振幅交替出现。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -\\frac{9\\pi}{10}  \\frac{1}{2}  -\\frac{\\pi}{10}  -\\mathrm{i}  \\frac{2\\pi}{5}  \\left(1 + \\frac{3\\sqrt{3}}{2}\\right) + \\mathrm{i}\\left(\\sqrt{3} - \\frac{3}{2}\\right)  \\frac{7\\pi}{10}  1 \\end{pmatrix} } $$"
        },
        {
            "introduction": "从分析混叠现象到主动控制它，我们进入下一个更高级的实践。这个问题将引导你探索一种源于压缩感知的精密设计原则，即如何构建一个亚奈奎斯特采样方案来最小化由互 coherence (相干性) 量化的“最坏情况”下的混叠效应 ()。这项练习将抽象的采样掩模特性与具体的数论构造联系起来，揭示了信号处理与纯数学之间的深刻联系。",
            "id": "3490149",
            "problem": "考虑一个离散时间、长度为$n$的信号，其频谱内容支撑在整数频率索引集 $\\{0,1,\\dots,n-1\\}$ 中的谐波相关频率 $f$ 和 $2f$ 上，该索引集按模 $n$ 解释。设 $\\Lambda \\subset \\{0,1,\\dots,n-1\\}$ 为一个基数为 $k := |\\Lambda|$ 的采样掩码，并设 $\\boldsymbol{F} \\in \\mathbb{C}^{n \\times n}$ 表示酉离散傅里叶变换 (DFT)。压缩测量值通过选择由 $\\Lambda$ 索引的行来获得，因此感知算子为 $\\boldsymbol{A} := \\boldsymbol{P}_{\\Lambda} \\boldsymbol{F}$，其中 $\\boldsymbol{P}_{\\Lambda}$ 提取 $\\boldsymbol{F}$ 的那 $k$ 行。由 $f$ 和 $g$ 索引的两个不同频谱列之间的混叠由互相关性量化，其定义为在该掩码下它们归一化内积的最大幅值，\n$$\n\\mu(\\Lambda) := \\max_{f \\neq g} \\left| \\frac{1}{k} \\sum_{j \\in \\Lambda} \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi (f-g) j}{n}\\right) \\right|.\n$$\n从第一性原理出发，建立一个选择 $\\Lambda$ 的理论准则——该准则基于采样掩码的离散时间自相关结构——以最小化谐波相关频率（特别是形如 $f$ 和 $2f$ 的频率对）的混叠，其方法是通过利用 $\\Lambda$ 的数论性质来减少 $\\mu(\\Lambda)$ 中的峰值。你的推导应从 $\\mu(\\Lambda)$ 的定义和 $\\Lambda$ 的指示序列的周期自相关出发，而不引用预先推导出的相干性公式。\n\n假设一个经过充分检验的数论事实：当素数 $p$ 满足 $p \\equiv 3 \\pmod{4}$ 时，模 $p$ 的二次剩余集合在加法群 $\\mathbb{Z}_{p}$ 中构成一个循环差集。在此假设下，将你的准则具体化到这样一个由模 $p$ 的二次剩余构成的采样掩码 $\\Lambda$ 上，并确定在此选择下的最坏情况互相关性值。\n\n最后，取 $n = p = 43$，并选择 $\\Lambda$ 为模 $43$ 的二次剩余集。使用你推导出的准则，计算此 $\\Lambda$ 的最坏情况互相关性 $\\mu(\\Lambda)$ 的精确值。将你的最终答案表示为一个无舍入的精确实数。",
            "solution": "问题要求我们找到一个选择采样掩码 $\\Lambda$ 的准则，以最小化由互相关性 $\\mu(\\Lambda)$ 量化的频谱分量之间的混叠。该准则应从第一性原理推导，将 $\\mu(\\Lambda)$ 与 $\\Lambda$ 的自相关结构联系起来。然后，我们将此准则应用于使用二次剩余的特定 $\\Lambda$ 构造，并计算当 $n=43$ 时得到的相干性。\n\n首先，我们建立互相关性与采样掩码指示序列的自相关之间的联系。互相关性的定义为：\n$$\n\\mu(\\Lambda) := \\max_{f \\neq g} \\left| \\frac{1}{k} \\sum_{j \\in \\Lambda} \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi (f-g) j}{n}\\right) \\right|\n$$\n其中 $k = |\\Lambda|$ 且 $f, g \\in \\{0, 1, \\dots, n-1\\}$。\n\n让我们定义一个与掩码 $\\Lambda$ 对应的长度为 $n$ 的二元指示序列 $x[j]$：\n$$\nx[j] = \\begin{cases} 1  \\text{若 } j \\in \\Lambda \\\\ 0  \\text{若 } j \\notin \\Lambda \\end{cases}\n$$\n该求和可以写成对所有 $j \\in \\{0, 1, \\dots, n-1\\}$ 的求和：\n$$\n\\sum_{j \\in \\Lambda} \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi (f-g) j}{n}\\right) = \\sum_{j=0}^{n-1} x[j] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi (f-g) j}{n}\\right)\n$$\n令 $m = (f-g) \\pmod n$。由于 $f \\neq g$，$m$ 是 $\\{1, 2, \\dots, n-1\\}$ 中的一个非零整数。上面的表达式是序列 $x[j]$ 的离散傅里叶变换 (DFT) 的第 $m$ 个系数，我们将其记为 $X[m]$：\n$$\nX[m] = \\sum_{j=0}^{n-1} x[j] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m j}{n}\\right)\n$$\n互相关性现在可以用指示序列的DFT来表示：\n$$\n\\mu(\\Lambda) = \\max_{m \\in \\{1, \\dots, n-1\\}} \\left| \\frac{1}{k} X[m] \\right| = \\frac{1}{k} \\max_{m \\in \\{1, \\dots, n-1\\}} |X[m]|\n$$\n因此，最小化最坏情况下的混叠 $\\mu(\\Lambda)$ 等价于最小化掩码指示序列的偏离中心 ($m \\neq 0$) 的DFT系数的最大幅值。\n\n接下来，我们将 $|X[m]|$ 与 $x[j]$ 的周期自相关联系起来。$x[j]$ 在延迟 $\\tau$ 处的周期自相关定义为：\n$$\nR_x[\\tau] = \\sum_{j=0}^{n-1} x[j] \\, x[(j+\\tau) \\pmod n]\n$$\n这个值 $R_x[\\tau]$ 计算了 $\\Lambda$ 中相隔距离为 $\\tau$ 的索引对的数量。具体来说，$R_x[\\tau] = |\\Lambda \\cap (\\Lambda - \\tau)|$，其中 $\\Lambda - \\tau = \\{j-\\tau \\pmod n \\mid j \\in \\Lambda\\}$。\n在延迟 $\\tau=0$ 处，我们有 $R_x[0] = \\sum_{j=0}^{n-1} x[j]^2 = \\sum_{j \\in \\Lambda} 1^2 = k$。\n\n离散周期信号的维纳-辛钦定理指出，自相关序列的DFT是信号的功率谱，即 $\\text{DFT}\\{R_x\\}[m] = |X[m]|^2$。我们按要求从第一性原理推导它。\n\\begin{align*}\n\\text{DFT}\\{R_x\\}[m] = \\sum_{\\tau=0}^{n-1} R_x[\\tau] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right) \\\\\n= \\sum_{\\tau=0}^{n-1} \\left( \\sum_{j=0}^{n-1} x[j] \\, x[j+\\tau] \\right) \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right) \\\\\n= \\sum_{j=0}^{n-1} x[j] \\sum_{\\tau=0}^{n-1} x[j+\\tau] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right)\n\\end{align*}\n令 $l = j+\\tau \\pmod n$，所以 $\\tau = l-j \\pmod n$。\n\\begin{align*}\n\\text{DFT}\\{R_x\\}[m] = \\sum_{j=0}^{n-1} x[j] \\sum_{l=0}^{n-1} x[l] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m (l-j)}{n}\\right) \\\\\n= \\left( \\sum_{j=0}^{n-1} x[j] \\exp\\!\\left(\\mathrm{i} \\frac{2\\pi m j}{n}\\right) \\right) \\left( \\sum_{l=0}^{n-1} x[l] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m l}{n}\\right) \\right) \\\\\n= \\left( \\sum_{j=0}^{n-1} x[j] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi (-m) j}{n}\\right) \\right) (X[m]) \\\\\n= X[-m] \\cdot X[m]\n\\end{align*}\n由于序列 $x[j]$ 是实值的，其DFT具有厄米共轭对称性，$X[-m] = (X[m])^*$，其中星号表示复共轭。因此，\n$$\n|X[m]|^2 = (X[m])^* X[m] = X[-m] X[m] = \\text{DFT}\\{R_x\\}[m]\n$$\n这证实了这一关系。为了最小化峰值 $\\max_{m \\neq 0} |X[m]|$，应选择 $x[j]$ 使其功率谱 $|X[m]|^2$ 在 $m \\neq 0$ 时尽可能平坦。这反过来又表明自相关序列 $R_x[\\tau]$ 应具有特定的结构。\n为使 $m \\neq 0$ 时的功率谱 $|X[m]|^2$ 平坦，$R_x[\\tau]$ 的理想结构是一个两级结构：\n$$\nR_x[\\tau] = \\begin{cases} k  \\text{若 } \\tau = 0 \\pmod n \\\\ \\lambda  \\text{若 } \\tau \\neq 0 \\pmod n \\end{cases}\n$$\n对于某个常数 $\\lambda$。其指示序列具有此性质的集合 $\\Lambda$ 被称为循环 $(n, k, \\lambda)$-差集。对于这样的集合，$m \\neq 0$ 时的功率谱为：\n\\begin{align*}\n|X[m]|^2 = \\sum_{\\tau=0}^{n-1} R_x[\\tau] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right) \\\\\n= R_x[0] + \\sum_{\\tau=1}^{n-1} R_x[\\tau] \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right) \\\\\n= k + \\lambda \\sum_{\\tau=1}^{n-1} \\exp\\!\\left(-\\mathrm{i} \\frac{2\\pi m \\tau}{n}\\right)\n\\end{align*}\n使用恒等式 $\\sum_{\\tau=0}^{n-1} \\exp(-\\mathrm{i} 2\\pi m \\tau / n) = 0$ (对于 $m \\neq 0$)，我们得到 $\\sum_{\\tau=1}^{n-1} \\exp(-\\mathrm{i} 2\\pi m \\tau / n) = -1$。\n因此，对于所有 $m \\in \\{1, \\dots, n-1\\}$，功率谱是恒定的：\n$$\n|X[m]|^2 = k - \\lambda\n$$\n这导致偏离中心的DFT系数具有恒定的幅值：$|X[m]| = \\sqrt{k-\\lambda}$。\n选择 $\\Lambda$ 以最小化混叠的理论准则是将其选为一个循环差集。对于这样的选择，互相关性对于所有 $f \\neq g$ 的对 $(f,g)$ 都是恒定的，并取值为：\n$$\n\\mu(\\Lambda) = \\frac{1}{k} \\sqrt{k - \\lambda}\n$$\n\n现在，我们将此准则具体化到问题给出的情况。我们被告知假设当素数 $p$ 满足 $p \\equiv 3 \\pmod 4$ 时，模 $p$ 的二次剩余集 $\\Lambda$ 在 $\\mathbb{Z}_p$ 中构成一个循环差集。令 $n=p$。\n这个特定差集（佩利差集）的参数是：\n- $p$：基础集的大小，所以 $n=p$。\n- $k$：集合 $\\Lambda$ 的大小。模素数 $p$ 的非零二次剩余的数量是 $k = (p-1)/2$。\n- $\\lambda$：任何非零元素可以写成 $\\Lambda$ 中两个元素之差的方式数。对于这种构造，$\\lambda = (k-1)/2 = \\frac{(p-1)/2 - 1}{2} = \\frac{p-3}{4}$。条件 $p \\equiv 3 \\pmod 4$ 确保 $p-3$ 是 $4$ 的倍数，因此 $\\lambda$ 是一个整数。\n\n对于这种 $\\Lambda$ 的选择，我们可以计算 $k-\\lambda$ 的值：\n$$\nk - \\lambda = \\frac{p-1}{2} - \\frac{p-3}{4} = \\frac{2(p-1) - (p-3)}{4} = \\frac{2p-2-p+3}{4} = \\frac{p+1}{4}\n$$\n将此代入我们关于 $\\mu(\\Lambda)$ 的表达式中：\n$$\n\\mu(\\Lambda) = \\frac{1}{k} \\sqrt{k - \\lambda} = \\frac{1}{(p-1)/2} \\sqrt{\\frac{p+1}{4}} = \\frac{2}{p-1} \\frac{\\sqrt{p+1}}{2} = \\frac{\\sqrt{p+1}}{p-1}\n$$\n这就是对于由模素数 $p \\equiv 3 \\pmod 4$ 的二次剩余构造的掩码的最坏情况互相关性。\n\n最后，我们将此结果应用于 $n=p=43$ 的具体情况。\n首先，我们验证 $p$ 满足条件：$43 = 4 \\times 10 + 3$，所以 $43 \\equiv 3 \\pmod 4$。\n该理论直接适用。采样掩码 $\\Lambda$ 是模 $43$ 的二次剩余集。\n样本数量为 $k = (43-1)/2 = 21$。\n自相关参数为 $\\lambda = (43-3)/4 = 10$。\n问题要求计算最坏情况互相关性 $\\mu(\\Lambda)$ 的精确值。使用我们推导的公式：\n$$\n\\mu(\\Lambda) = \\frac{\\sqrt{p+1}}{p-1} = \\frac{\\sqrt{43+1}}{43-1} = \\frac{\\sqrt{44}}{42}\n$$\n我们简化这个表达式：\n$$\n\\mu(\\Lambda) = \\frac{\\sqrt{4 \\times 11}}{42} = \\frac{2\\sqrt{11}}{42} = \\frac{\\sqrt{11}}{21}\n$$\n这就是指定采样掩码的最坏情况互相关性的精确值。",
            "answer": "$$\\boxed{\\frac{\\sqrt{11}}{21}}$$"
        },
        {
            "introduction": "最后一个练习将问题完全反转：我们不再试图避免混叠，而是利用其可预测的结构来解决一个逆问题。你将开发一个“盲检测器”，判断多个经过不同方式混叠的测量结果是否可能源于同一个稀疏信号 ()。这项练习展示了如何通过数论（整数余数类）的视角，将对混叠的深刻理解转化为一种强大的推断工具，即使是从看似不完整的数据中也能提取有效信息。",
            "id": "3490170",
            "problem": "考虑一个离散时间复值信号 $x \\in \\mathbb{C}^{N}$，其离散傅里叶变换 (DFT) 为 $X = F x$，其中 $F \\in \\mathbb{C}^{N \\times N}$ 是酉离散傅里叶变换 (DFT) 矩阵。设 $X$ 的未知支撑集为 $S \\subset \\{0,1,\\ldots,N-1\\}$，其势为 $|S| = s$。假设当且仅当 $k \\in S$ 时，$X[k] \\neq 0$，并且非零系数为严格正实数，以避免在混叠下发生抵消。考虑通过在时域以能整除 $N$ 的因子 $R_i$ 对 $x$ 进行降采样而获得的亚奈奎斯特观测，得到 $M_i = N / R_i$。得到的混叠谱 $y_i \\in \\mathbb{C}^{M_i}$ 由标准混叠求和公式给出\n$$\ny_i[m] = \\sum_{r=0}^{R_i - 1} X[m + r M_i], \\quad m \\in \\{0,1,\\ldots,M_i-1\\}.\n$$\n等价地，定义一个线性混叠算子 $P_{\\Lambda_i} : \\mathbb{C}^{N} \\to \\mathbb{C}^{M_i}$，它对模 $M_i$ 的剩余类进行聚合，使得 $y_i = P_{\\Lambda_i} X = P_{\\Lambda_i} F x$。对于一个固定的阈值 $\\tau  0$，设 $y_i$ 的观测支撑集为 $A_i = \\{ m \\in \\{0,1,\\ldots,M_i-1\\} : |y_i[m]|  \\tau \\}$。在严格正系数的假设下，Shannon-Nyquist 采样定理和混叠公式意味着\n$$\nA_i = \\{ k \\bmod M_i : k \\in S \\}.\n$$\n\n您的任务是实现一个盲混叠检测器。给定在亚奈奎斯特速率 $M_i$（其中 $M_i$ 整除 $N$）下产生的多个混叠谱 $y_i$，该检测器需要判断是否存在一个单一的稀疏支撑集 $S \\subset \\{0,\\ldots,N-1\\}$ 且 $|S| = s$，能够通过混叠产生所有的 $y_i$。将此问题表述并求解为一个整数剩余类的可行性问题：\n- 找到一个 $S \\subset \\{0,\\ldots,N-1\\}$ 且 $|S| = s$，使得对于每个 $i$，\n$$\n\\{ k \\bmod M_i : k \\in S \\} = A_i.\n$$\n\n算法要求：\n- 构建候选集 $U = \\{ k \\in \\{0,\\ldots,N-1\\} : k \\bmod M_i \\in A_i \\text{ for all } i \\}$。\n- 通过检查是否可以从 $U$ 中选择 $s$ 个不同的索引，使得它们对每个 $M_i$ 取模后的余数集合恰好等于 $A_i$，来判断可行性。将此问题视为一个带预算约束的集合覆盖问题，并对于给定的测试规模，通过回溯法精确求解。\n\n使用以下测试套件。在每种情况下，根据指定的 $X$ 和 $S$ 上的严格正实系数，通过混叠求和公式生成 $y_i$；在计算 $A_i$ 时使用阈值 $\\tau = 10^{-12}$。\n\n- 测试用例 1 (理想情况):\n    - $N = 24$, $s = 3$, $M_1 = 6$, $M_2 = 8$.\n    - 真实支撑集 $S = \\{3,7,17\\}$，其中 $X[3] = 1.0$, $X[7] = 0.9$, $X[17] = 1.1$，所有其他 $k$ 的 $X[k] = 0$。\n\n- 测试用例 2 (边界条件，单点支撑集):\n    - $N = 24$, $s = 1$, $M_1 = 6$, $M_2 = 8$.\n    - 真实支撑集 $S = \\{9\\}$，其中 $X[9] = 1.0$，所有其他 $k$ 的 $X[k] = 0$。\n\n- 测试用例 3 (因稀疏度过小而不可行):\n    - $N = 24$, $s = 2$, $M_1 = 6$, $M_2 = 8$.\n    - 观测值 $y_i$ 由真实支撑集 $S = \\{3,7,17\\}$ 生成，其中 $X[3] = 1.0$, $X[7] = 0.9$, $X[17] = 1.1$，所有其他 $k$ 的 $X[k] = 0$。\n\n- 测试用例 4 (模数不互质，可行):\n    - $N = 30$, $s = 3$, $M_1 = 6$, $M_2 = 10$.\n    - 真实支撑集 $S = \\{1,13,22\\}$，其中 $X[1] = 1.0$, $X[13] = 0.8$, $X[22] = 1.3$，所有其他 $k$ 的 $X[k] = 0$。\n\n- 测试用例 5 (不同采样器之间的观测结果相互矛盾):\n    - $N = 24$, $s = 2$, $M_1 = 6$, $M_2 = 8$.\n    - $y_1$ 由 $S_1 = \\{2,5\\}$ 生成，其中 $X[2] = 1.0$, $X[5] = 0.7$，否则 $X[k] = 0$。\n    - $y_2$ 由 $S_2 = \\{1,9\\}$ 生成，其中 $X[1] = 1.2$, $X[9] = 0.6$，否则 $X[k] = 0$。\n\n对于每个测试用例，您的程序必须：\n- 使用混叠求和公式生成混叠谱 $y_i$。\n- 使用阈值 $\\tau$ 计算观测支撑集 $A_i$。\n- 解决可行性问题，并输出一个布尔值，指示是否存在一个大小为 $s$ 的集合 $S$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含 5 个测试用例的结果，格式为方括号内以逗号分隔的列表（例如，\"[True,False,True,False,True]\"）。",
            "solution": "所提出的问题是一个有效且良构的可行性问题，其根源在于压缩感知和亚奈奎斯特采样的原理。它旨在探究一组混叠的、低速率的观测值是否可以由一个单一的、稀疏的高维信号来解释。问题的核心是在特定约束下逆转混叠过程，以检验是否存在一个给定势为 $s$ 的稀疏频率支撑集 $S$。\n\n解决方案系统地按以下步骤进行：\n\n1.  **数据生成**：对于每个测试用例，我们首先模拟物理观测过程。构建一个全分辨率频谱 $X \\in \\mathbb{C}^{N}$，该频谱是稀疏的，其支撑集 $S$ 的大小为 $|S| = s_{true}$。此支撑集上的非零系数被设置为指定的严格正实数值。然后使用离散混叠求和公式生成混叠谱 $y_i \\in \\mathbb{C}^{M_i}$：\n    $$y_i[m] = \\sum_{r=0}^{R_i - 1} X[m + r M_i]$$\n    其中 $M_i = N/R_i$ 是混叠谱的大小。这一过程通过数组重塑和求和操作得以高效实现。对于模拟矛盾测量的测试用例 5，使用两个不同的频谱 $X_1$ 和 $X_2$ 分别生成 $y_1$ 和 $y_2$。\n\n2.  **观测支撑集提取**：从生成的混叠谱 $y_i$ 中，提取出观测支撑集 $A_i$。根据问题定义，观测支撑集 $A_i$ 包含所有索引 $m$，其对应的混叠系数幅值 $|y_i[m]|$ 超过一个微小的正阈值 $\\tau = 10^{-12}$。此步骤模拟了识别哪些频率仓包含信号能量的实际任务。问题中关于真实谱系数为严格正实数的假设确保了在混叠过程中不会发生抵消，从而保证了观测支撑集恰好是真实支撑集的余数集合，即 $A_i = \\{ k \\bmod M_i : k \\in S \\}$。\n\n3.  **候选全集构建**：核心的可行性问题是找到一个大小为 $s$ 的集合 $S \\subset \\{0, \\ldots, N-1\\}$，该集合与所有观测支撑集 $A_i$ 一致。解决此问题的第一步是识别所有可能属于这样一个集合 $S$ 的索引。一个索引 $k \\in \\{0, \\ldots, N-1\\}$ 成为一个潜在候选者，当且仅当它对每个 $M_i$ 取模的余数都落入相应的观测支撑集 $A_i$ 中。我们构建所有此类候选者的全集，记为 $U$：\n    $$U = \\{ k \\in \\{0, \\ldots, N-1\\} : (k \\bmod M_i) \\in A_i \\text{ for all } i \\}$$\n    任何有效的解 $S$ 都必须是 $U$ 的一个子集。\n\n4.  **通过回溯法进行组合可行性搜索**：最后也是最关键的一步是确定是否存在一个大小为 $s$ 的 $U$ 的子集，能够完美解释所有的观测支撑集 $A_i$。这是一个组合搜索问题。问题陈述要求通过回溯法获得精确解，这对于指定的问题规模是合适的。\n    该算法如下：\n    -   一个初始的剪枝步骤检查问题是否显然不可行。如果 $|U|  s$，则不可能形成一个大小为 $s$ 的支撑集。类似地，如果对任何 $i$ 有 $|A_i|  s$，一个大小为 $s$ 的支撑集也不可能生成超过 $s$ 个不同的余数。\n    -   一个递归回溯函数探索 $U$ 中所有大小为 $s$ 的子集。\n    -   函数 `_backtrack(start_index, current_S)` 尝试构建一个解集 `current_S`。\n    -   **基本情况**：当形成一个大小为 $s$ 的子集 `current_S` 时，测试其有效性。对于每个观测 $i$，计算余数集合 $\\{k \\bmod M_i : k \\in \\text{current\\_S}\\}$ 并与观测支撑集 $A_i$ 进行比较。如果对所有的 $i$ 这些集合都相同，则找到了一个有效的解，搜索成功终止 (返回 True)。\n    -   **递归步骤**：函数从 `start_index` 开始遍历 $U$ 中的剩余候选者。对于每个候选者，将其添加到 `current_S` 中并进行递归调用。如果递归调用返回 True，则将解向上传播。否则，移除该候选者（回溯），并继续搜索下一个候选者。\n    -   **剪枝**：如果剩余候选者的数量不足以达到目标大小 $s$，则对搜索进行剪枝。\n\n这种系统化的方法正确地将问题形式化，构建了搜索空间，并对解进行穷举搜索，从而为每个测试用例的可行性问题提供了明确的答案。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the blind aliasing detector problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {'N': 24, 's': 3, 'M_list': [6, 8], 'tau': 1e-12, 'setup': ({3: 1.0, 7: 0.9, 17: 1.1},)},\n        # Test case 2 (boundary condition, singleton support)\n        {'N': 24, 's': 1, 'M_list': [6, 8], 'tau': 1e-12, 'setup': ({9: 1.0},)},\n        # Test case 3 (infeasible due to too-small sparsity)\n        {'N': 24, 's': 2, 'M_list': [6, 8], 'tau': 1e-12, 'setup': ({3: 1.0, 7: 0.9, 17: 1.1},)},\n        # Test case 4 (non-coprime moduli, feasible)\n        {'N': 30, 's': 3, 'M_list': [6, 10], 'tau': 1e-12, 'setup': ({1: 1.0, 13: 0.8, 22: 1.3},)},\n        # Test case 5 (contradictory observations across samplers)\n        {'N': 24, 's': 2, 'M_list': [6, 8], 'tau': 1e-12, 'setup': ({2: 1.0, 5: 0.7}, {1: 1.2, 9: 0.6})},\n    ]\n\n    def generate_aliased_spectra(N, M_list, setup):\n        \"\"\"Generates aliased spectra based on the setup for one test case.\"\"\"\n        y_list = []\n        # Case 5: Multiple sources, one for each measurement M_i\n        if len(setup) == len(M_list) and isinstance(setup[0], dict):\n            for i, M in enumerate(M_list):\n                coeffs = setup[i]\n                X = np.zeros(N, dtype=np.float64)\n                for k, v in coeffs.items():\n                    X[k] = v\n                \n                R = N // M\n                X_reshaped = X.reshape((R, M))\n                y = np.sum(X_reshaped, axis=0)\n                y_list.append(y)\n        else: # Cases 1-4: Single source for all measurements M_i\n            coeffs = setup[0]\n            X = np.zeros(N, dtype=np.float64)\n            for k, v in coeffs.items():\n                X[k] = v\n            \n            for M in M_list:\n                R = N // M\n                X_reshaped = X.reshape((R, M))\n                y = np.sum(X_reshaped, axis=0)\n                y_list.append(y)\n        return y_list\n\n    def compute_observed_supports(y_list, tau):\n        \"\"\"Computes observed supports A_i from aliased spectra y_i.\"\"\"\n        A_list = []\n        for y in y_list:\n            A = {m for m, val in enumerate(y) if np.abs(val)  tau}\n            A_list.append(A)\n        return A_list\n\n    def detect_feasibility(N, s, M_list, A_list):\n        \"\"\"\n        Determines if a sparse support of size s exists that explains the observed supports A_list.\n        \"\"\"\n        # Preliminary check: a support of size s can generate at most s distinct residues.\n        for A in A_list:\n            if len(A)  s:\n                return False\n\n        # Step 1: Construct the candidate universe U\n        U = []\n        for k in range(N):\n            is_candidate = True\n            for i, M in enumerate(M_list):\n                if k % M not in A_list[i]:\n                    is_candidate = False\n                    break\n            if is_candidate:\n                U.append(k)\n        \n        # Check if it is possible to select s elements from U\n        if len(U)  s:\n            return False\n\n        # Step 2: Search for a valid subset of U via backtracking\n        def _backtrack(start_index, current_s_set):\n            # Base case: a candidate solution of size s is formed\n            if len(current_s_set) == s:\n                # Check if this candidate is a valid solution\n                for i, M in enumerate(M_list):\n                    generated_A = {k % M for k in current_s_set}\n                    if generated_A != A_list[i]:\n                        return False  # This candidate is not a solution\n                return True  # A valid solution is found\n\n            # Pruning: if not enough candidates are left to reach size s\n            needed = s - len(current_s_set)\n            remaining_candidates = len(U) - start_index\n            if remaining_candidates  needed:\n                return False\n\n            # Recursive step: iterate through remaining candidates\n            for i in range(start_index, len(U)):\n                # Add candidate and recurse\n                current_s_set.add(U[i])\n                if _backtrack(i + 1, current_s_set):\n                    return True\n                # Backtrack\n                current_s_set.remove(U[i])\n            \n            return False\n\n        return _backtrack(0, set())\n\n    results = []\n    for case in test_cases:\n        y_list = generate_aliased_spectra(case['N'], case['M_list'], case['setup'])\n        A_list = compute_observed_supports(y_list, case['tau'])\n        is_feasible = detect_feasibility(case['N'], case['s'], case['M_list'], A_list)\n        results.append(is_feasible)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}