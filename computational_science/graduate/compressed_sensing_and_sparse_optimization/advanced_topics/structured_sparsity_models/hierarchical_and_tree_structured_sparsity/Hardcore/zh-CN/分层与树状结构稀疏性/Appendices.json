{
    "hands_on_practices": [
        {
            "introduction": "要掌握任何结构化稀疏模型，第一步是理解其基础的几何形态。本练习提供了一个具体的实践机会，让您通过计算一个信号在所有树稀疏信号集合上的最佳逼近，来直接地与该模型的组合特性以及在有效支撑集上最大化信号能量的原则进行互动。这个过程将阐明如何通过枚举搜索，在一个小的、可控的场景中找到精确的欧几里得投影 。",
            "id": "3450706",
            "problem": "考虑如下的树状结构稀疏性分层模型。设数据向量 $v \\in \\mathbb{R}^{8}$ 由 $v = (0.9, -0.3, 2.1, 0.2, -0.1, 0.5, -3.0, 2.6)^{\\top}$ 给出。设索引集 $\\{1,2,3,4,5,6,7,8\\}$ 上的树 $\\mathcal{T}$ 是一个深度为 $3$ 的有根树，根节点为索引 $1$，索引 $1$ 的子节点为索引 $2$ 和 $3$，索引 $2$ 的子节点为索引 $4$ 和 $5$，索引 $3$ 的子节点为索引 $6$、$7$ 和 $8$。如果 $\\mathcal{T}$ 在 $A$ 上的导出子图是连通的，则称子集 $A \\subseteq \\{1,\\dots,8\\}$ 为连通子树支撑集。\n\n定义模型 $\\mathcal{M}_{3}$ 为所有对应于基数为 $3$ 的连通子树支撑集的坐标子空间的并集，即，每个 $x \\in \\mathcal{M}_{3}$ 的支撑集等于某个满足 $|A| = 3$ 且 $A$ 是连通子树支撑集的 $A \\subseteq \\{1,\\dots,8\\}$。\n\n使用欧几里得范数 $\\|\\cdot\\|_{2}$，计算 $v$ 在 $\\mathcal{M}_{3}$ 上的精确欧几里得投影，该投影被理解为在 $w \\in \\mathcal{M}_{3}$ 上使 $\\|v - w\\|_{2}$ 最小化的元素 $w^{\\star} \\in \\mathcal{M}_{3}$。你的推导必须从第一性原理（欧几里得投影到坐标子空间并集以及树中连通性的定义）出发，并且必须证明所选的支撑集在连通子树约束下是最优的。\n\n对于你的最终答案，将 $3$ 个选定的索引按升序排列，后跟投影向量的 $8$ 个分量，连接成一个单行矩阵。无需四舍五入。最终答案必须是单一表达式。",
            "solution": "该问题要求计算给定向量 $v \\in \\mathbb{R}^{8}$ 在非凸集 $\\mathcal{M}_{3}$ 上的欧几里得投影。集合 $\\mathcal{M}_{3}$ 被定义为根据树状结构稀疏性模型选择的特定坐标子空间的并集。\n\n设向量为 $v = (0.9, -0.3, 2.1, 0.2, -0.1, 0.5, -3.0, 2.6)^{\\top}$。索引集 $\\{1, 2, 3, 4, 5, 6, 7, 8\\}$ 上的树 $\\mathcal{T}$ 由以下父子关系定义：根是节点 $1$；节点 $1$ 的子节点为 $\\{2, 3\\}$；节点 $2$ 的子节点为 $\\{4, 5\\}$；节点 $3$ 的子节点为 $\\{6, 7, 8\\}$。\n\n模型 $\\mathcal{M}_{3}$ 是所有坐标子空间 $S_A$ 的并集，其中支撑集 $A \\subseteq \\{1, \\dots, 8\\}$ 的基数为 $|A|=3$ 并且在 $\\mathcal{T}$ 中形成一个连通子树。形式上，$\\mathcal{M}_{3} = \\bigcup_{A \\in \\mathcal{A}_3} S_A$，其中 $\\mathcal{A}_3 = \\{ A \\subseteq \\{1, \\dots, 8\\} : |A|=3 \\text{ 且 } A \\text{ 是连通子树支撑集} \\}$ 且 $S_A = \\{ x \\in \\mathbb{R}^8 : x_i = 0 \\text{ 对于所有 } i \\notin A \\}$。\n\n我们寻求找到向量 $w^{\\star} \\in \\mathcal{M}_{3}$，它最小化到 $v$ 的欧几里得距离，即\n$$w^{\\star} = \\arg\\min_{w \\in \\mathcal{M}_{3}} \\|v - w\\|_{2}$$\n由于 $\\mathcal{M}_{3}$ 是线性子空间的并集，最优向量 $w^{\\star}$ 必定是 $v$ 在这些子空间之一上的正交投影。令 $P_{S_A}(v)$ 表示 $v$ 在子空间 $S_A$ 上的正交投影。该优化问题等价于找到子空间 $S_{A^{\\star}}$，使得其投影最接近 $v$：\n$$w^{\\star} = P_{S_{A^{\\star}}}(v) \\quad \\text{其中} \\quad A^{\\star} = \\arg\\min_{A \\in \\mathcal{A}_3} \\|v - P_{S_A}(v)\\|_{2}$$\n最小化距离等价于最小化距离的平方。从 $v$ 到其在 $S_A$ 上的投影的平方距离由 $v$ 中被置零的分量的平方和给出：\n$$\\|v - P_{S_A}(v)\\|_{2}^{2} = \\sum_{i \\notin A} v_i^2$$\n使用勾股定理，$\\|v\\|_{2}^{2} = \\|P_{S_A}(v)\\|_{2}^{2} + \\|v - P_{S_A}(v)\\|_{2}^{2}$，我们可以将表达式重写为：\n$$\\|v - P_{S_A}(v)\\|_{2}^{2} = \\|v\\|_{2}^{2} - \\|P_{S_A}(v)\\|_{2}^{2} = \\sum_{i=1}^{8} v_i^2 - \\sum_{i \\in A} v_i^2$$\n由于 $\\sum_{i=1}^{8} v_i^2$ 是关于 $A$ 的选择的常数，最小化距离等价于最大化 $v$ 在支撑集 $A$ 上的分量的平方和：\n$$A^{\\star} = \\arg\\max_{A \\in \\mathcal{A}_3} \\sum_{i \\in A} v_i^2$$\n\n我们的第一步是枚举所有可能的基数为 $3$ 的连通子树支撑集 $A$。在树上，一个有 $3$ 个节点的连通图只能有两种拓扑结构：长度为 $2$ 的路径（祖父-父-子）或一个中心节点带两个子节点的星形图（一个父节点与两个子节点）。\n\n树的结构规定如下：\n\\begin{itemize}\n    \\item 边：$(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (3,8)$。\n\\end{itemize}\n我们列出所有大小为 $3$ 的连通子树：\n\\begin{enumerate}\n    \\item 路径型子树（祖父-父-子）：\n    \\begin{itemize}\n        \\item $\\{1, 2, 4\\}$\n        \\item $\\{1, 2, 5\\}$\n        \\item $\\{1, 3, 6\\}$\n        \\item $\\{1, 3, 7\\}$\n        \\item $\\{1, 3, 8\\}$\n    \\end{itemize}\n    \\item 星形子树（一个父节点与两个子节点）：\n    \\begin{itemize}\n        \\item $\\{1, 2, 3\\}$ (父节点 $1$, 子节点 $2, 3$)\n        \\item $\\{2, 4, 5\\}$ (父节点 $2$, 子节点 $4, 5$)\n        \\item $\\{3, 6, 7\\}$ (父节点 $3$, 子节点 $6, 7$)\n        \\item $\\{3, 6, 8\\}$ (父节点 $3$, 子节点 $6, 8$)\n        \\item $\\{3, 7, 8\\}$ (父节点 $3$, 子节点 $7, 8$)\n    \\end{itemize}\n\\end{enumerate}\n这就构成了包含十个可能支撑集的完整集合 $\\mathcal{A}_3$。\n\n接下来，我们计算 $v$ 各分量的平方值：\n$v_1^2 = (0.9)^2 = 0.81$\n$v_2^2 = (-0.3)^2 = 0.09$\n$v_3^2 = (2.1)^2 = 4.41$\n$v_4^2 = (0.2)^2 = 0.04$\n$v_5^2 = (-0.1)^2 = 0.01$\n$v_6^2 = (0.5)^2 = 0.25$\n$v_7^2 = (-3.0)^2 = 9.00$\n$v_8^2 = (2.6)^2 = 6.76$\n\n现在，我们为每个支撑集 $A \\in \\mathcal{A}_3$ 计算和 $\\sum_{i \\in A} v_i^2$：\n\\begin{itemize}\n    \\item $A = \\{1, 2, 4\\}: \\sum v_i^2 = 0.81 + 0.09 + 0.04 = 0.94$\n    \\item $A = \\{1, 2, 5\\}: \\sum v_i^2 = 0.81 + 0.09 + 0.01 = 0.91$\n    \\item $A = \\{1, 3, 6\\}: \\sum v_i^2 = 0.81 + 4.41 + 0.25 = 5.47$\n    \\item $A = \\{1, 3, 7\\}: \\sum v_i^2 = 0.81 + 4.41 + 9.00 = 14.22$\n    \\item $A = \\{1, 3, 8\\}: \\sum v_i^2 = 0.81 + 4.41 + 6.76 = 11.98$\n    \\item $A = \\{1, 2, 3\\}: \\sum v_i^2 = 0.81 + 0.09 + 4.41 = 5.31$\n    \\item $A = \\{2, 4, 5\\}: \\sum v_i^2 = 0.09 + 0.04 + 0.01 = 0.14$\n    \\item $A = \\{3, 6, 7\\}: \\sum v_i^2 = 4.41 + 0.25 + 9.00 = 13.66$\n    \\item $A = \\{3, 6, 8\\}: \\sum v_i^2 = 4.41 + 0.25 + 6.76 = 11.42$\n    \\item $A = \\{3, 7, 8\\}: \\sum v_i^2 = 4.41 + 9.00 + 6.76 = 20.17$\n\\end{itemize}\n\n比较这些和，最大值为 $20.17$，对应于支撑集 $A^{\\star} = \\{3, 7, 8\\}$。在这些顶点上的导出子图由边 $(3,7)$ 和 $(3,8)$ 组成，这确实是一个连通的树结构。因为这个和是唯一的最大值，所以投影是唯一的。\n\n因此，$v$ 在 $\\mathcal{M}_{3}$ 上的投影 $w^{\\star}$ 是 $v$ 在子空间 $S_{A^{\\star}}$ 上的投影，它通过保留 $v$ 在索引 $\\{3, 7, 8\\}$ 处的分量并将所有其他分量置零来获得。\n给定 $v = (0.9, -0.3, 2.1, 0.2, -0.1, 0.5, -3.0, 2.6)^{\\top}$，投影向量 $w^{\\star}$ 为：\n$$w^{\\star} = (0, 0, v_3, 0, 0, 0, v_7, v_8)^{\\top} = (0, 0, 2.1, 0, 0, 0, -3.0, 2.6)^{\\top}$$\n\n最终答案要求将 $3$ 个选定的索引按升序排列 ($3, 7, 8$)，后跟投影向量 $w^{\\star}$ 的 $8$ 个分量连接起来。\n这产生一个包含 $3+8=11$ 个元素的行向量： $(3, 7, 8, 0, 0, 2.1, 0, 0, 0, -3.0, 2.6)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  & 7  & 8  & 0  & 0  & 2.1  & 0  & 0  & 0  & -3.0  & 2.6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从几何视角转换到概率视角，许多先进的方法采用贝叶斯框架来为结构化稀疏性建模。本练习将探讨如何利用条件概率构建一个树稀疏结构上的生成模型，这为理解贝叶斯分层模型及其相关的推断算法奠定了基础。通过计算一个特定子树支撑的先验概率，您将练习在有向图模型上应用概率链式法则 。",
            "id": "3450736",
            "problem": "考虑一个深度为 $3$ 的有根有向树，其节点和父子结构如下。根节点为 $r$。第 $1$ 层由节点 $A$ 和 $B$ 组成，其中 $r$ 是 $A$ 和 $B$ 的父节点。第 $2$ 层由节点 $C$ 和 $D$（$A$ 的子节点）以及 $E$ 和 $F$（$B$ 的子节点）组成。第 $3$ 层由节点 $G$ 和 $H$（$C$ 的子节点）、$I$ 和 $J$（$D$ 的子节点）、$K$ 和 $L$（$E$ 的子节点）以及 $M$ 和 $N$（$F$ 的子节点）组成。对于每个节点 $i$，有一个二元包含变量 $z_i \\in \\{0,1\\}$，表示节点 $i$ 是否在支撑集中。\n\n假设一个分层先验通过以下规则强制实现连通子树稀疏性：\n- 根包含变量 $z_r$ 是一个参数为 $\\pi_{\\text{root}} \\in (0,1)$ 的伯努利随机变量，即 $\\mathbb{P}(z_r = 1) = \\pi_{\\text{root}}$ 且 $\\mathbb{P}(z_r = 0) = 1 - \\pi_{\\text{root}}$。\n- 对于从父节点 $i$ 到子节点 $j$ 的每条有向边，在 $z_i = 1$ 的条件下，子包含变量 $z_j$ 在兄弟节点间独立抽取，其概率为\n$$\n\\mathbb{P}(z_j = 1 \\mid z_i = 1) = p_{j \\mid i}, \\quad \\mathbb{P}(z_j = 0 \\mid z_i = 1) = 1 - p_{j \\mid i},\n$$\n其中 $p_{j \\mid i} \\in (0,1)$ 是与边 $i \\to j$ 相关的转移概率。假设在给定父节点的条件下，子节点之间是条件独立的。\n- 连通性是通过在父节点被排除时不允许包含子节点来强制实现的：对于所有边 $i \\to j$，\n$$\n\\mathbb{P}(z_j = 1 \\mid z_i = 0) = 0, \\quad \\mathbb{P}(z_j = 0 \\mid z_i = 0) = 1.\n$$\n\n令特定于边的转移概率表示为\n$$\np_{A \\mid r} = a, \\quad p_{B \\mid r} = b, \\quad p_{C \\mid A} = c, \\quad p_{D \\mid A} = d, \\quad p_{E \\mid B} = e, \\quad p_{F \\mid B} = f,\n$$\n$$\np_{G \\mid C} = g, \\quad p_{H \\mid C} = h, \\quad p_{I \\mid D} = i, \\quad p_{J \\mid D} = j, \\quad p_{K \\mid E} = k, \\quad p_{L \\mid E} = \\ell, \\quad p_{M \\mid F} = m, \\quad p_{N \\mid F} = n,\n$$\n所有这些概率都在 $(0,1)$ 区间内，并记 $\\pi_{\\text{root}} = \\pi$。\n\n考虑连通子树支撑集\n$$\nS = \\{ r, A, C, G \\},\n$$\n即事件 $z_r = 1$、$z_A = 1$、$z_C = 1$、$z_G = 1$，且所有其他包含变量均为零：\n$$\nz_B = 0, \\; z_D = 0, \\; z_H = 0, \\; z_E = 0, \\; z_F = 0, \\; z_I = 0, \\; z_J = 0, \\; z_K = 0, \\; z_L = 0, \\; z_M = 0, \\; z_N = 0.\n$$\n\n仅从有向树概率的基本规则和上述模型假设出发，推导并计算恰好是此支撑集 $S$ 的边际先验概率，用 $\\pi$ 和所列转移概率的封闭形式解析表达式表示。不需要进行数值取整，也没有单位。您的最终答案必须是单个解析表达式。",
            "solution": "问题要求计算特定连通子树支撑集 $S = \\{ r, A, C, G \\}$ 的边际先验概率。这对应于一个联合事件，即 $S$ 中节点的包含变量为 $1$，而树中所有其他节点的包含变量为 $0$。所描述的概率模型是一个基于有向树的贝叶斯网络。计算贝叶斯网络中特定变量配置的联合概率的基本原理是链式法则，该法则指出联合概率是每个变量在其父节点给定条件下的条件概率的乘积。\n\n树中所有节点的集合是 $V = \\{r, A, B, C, D, E, F, G, H, I, J, K, L, M, N\\}$。节点总数为 $15$。指定的支撑集 $S = \\{ r, A, C, G \\}$ 定义了对于 $i \\in V$ 的每个包含变量 $z_i$ 的状态。具体来说：\n$z_r = 1, z_A = 1, z_C = 1, z_G = 1$。\n所有其他包含变量均为 $0$：\n$z_B = 0, z_D = 0, z_H = 0, z_E = 0, z_F = 0, z_I = 0, z_J = 0, z_K = 0, z_L = 0, z_M = 0, z_N = 0$。\n\n这个特定配置的联合概率，我们记为 $\\mathbb{P}(S)$，可以分解为根节点状态的概率与每个子节点在其父节点状态给定条件下的条件概率的乘积。由于指定了在给定父节点条件下兄弟节点之间的条件独立性，分解如下：\n$$\n\\mathbb{P}(S) = \\mathbb{P}(z_r) \\prod_{j \\in V \\setminus \\{r\\}} \\mathbb{P}(z_j \\mid z_{\\text{parent}(j)})\n$$\n对整个树结构展开这个乘积，得到：\n\\begin{align*}\n\\mathbb{P}(S) = \\;  \\mathbb{P}(z_r=1) \\\\\n \\times \\mathbb{P}(z_A=1 \\mid z_r=1) \\cdot \\mathbb{P}(z_B=0 \\mid z_r=1) \\\\\n \\times \\mathbb{P}(z_C=1 \\mid z_A=1) \\cdot \\mathbb{P}(z_D=0 \\mid z_A=1) \\\\\n \\times \\mathbb{P}(z_E=0 \\mid z_B=0) \\cdot \\mathbb{P}(z_F=0 \\mid z_B=0) \\\\\n \\times \\mathbb{P}(z_G=1 \\mid z_C=1) \\cdot \\mathbb{P}(z_H=0 \\mid z_C=1) \\\\\n \\times \\mathbb{P}(z_I=0 \\mid z_D=0) \\cdot \\mathbb{P}(z_J=0 \\mid z_D=0) \\\\\n \\times \\mathbb{P}(z_K=0 \\mid z_E=0) \\cdot \\mathbb{P}(z_L=0 \\mid z_E=0) \\\\\n \\times \\mathbb{P}(z_M=0 \\mid z_F=0) \\cdot \\mathbb{P}(z_N=0 \\mid z_F=0)\n\\end{align*}\n我们现在使用模型的规则和给定的参数来计算这个乘积中的每一项。\n\n1.  **根节点 ($r$)**：\n    问题陈述 $\\mathbb{P}(z_r=1) = \\pi_{\\text{root}} = \\pi$。\n\n2.  **$r$ 的子节点 ($A, B$)**：父节点是 $r$，其状态是 $z_r=1$。\n    - 对于节点 A：$\\mathbb{P}(z_A=1 \\mid z_r=1) = p_{A \\mid r} = a$。\n    - 对于节点 B：$\\mathbb{P}(z_B=0 \\mid z_r=1) = 1 - \\mathbb{P}(z_B=1 \\mid z_r=1) = 1 - p_{B \\mid r} = 1 - b$。\n\n3.  **$A$ 的子节点 ($C, D$)**：父节点是 $A$，其状态是 $z_A=1$。\n    - 对于节点 C：$\\mathbb{P}(z_C=1 \\mid z_A=1) = p_{C \\mid A} = c$。\n    - 对于节点 D：$\\mathbb{P}(z_D=0 \\mid z_A=1) = 1 - \\mathbb{P}(z_D=1 \\mid z_A=1) = 1 - p_{D \\mid A} = 1 - d$。\n\n4.  **$C$ 的子节点 ($G, H$)**：父节点是 $C$，其状态是 $z_C=1$。\n    - 对于节点 G：$\\mathbb{P}(z_G=1 \\mid z_C=1) = p_{G \\mid C} = g$。\n    - 对于节点 H：$\\mathbb{P}(z_H=0 \\mid z_C=1) = 1 - \\mathbb{P}(z_H=1 \\mid z_C=1) = 1 - p_{H \\mid C} = 1 - h$。\n\n5.  **父节点未激活的节点**：模型强制规定，如果父节点 $i$ 不在支撑集中（$z_i=0$），那么任何子节点 $j$ 也不能在支撑集中。这是由规则 $\\mathbb{P}(z_j=1 \\mid z_i=0) = 0$ 给出的，这意味着 $\\mathbb{P}(z_j=0 \\mid z_i=0) = 1$。我们将此规则应用于所有以 $z_i=0$ 的节点为根的子树。\n    - $B$ 的子节点 ($E, F$)：$z_B=0$。所以，$\\mathbb{P}(z_E=0 \\mid z_B=0) = 1$ 且 $\\mathbb{P}(z_F=0 \\mid z_B=0) = 1$。\n    - $D$ 的子节点 ($I, J$)：$z_D=0$。所以，$\\mathbb{P}(z_I=0 \\mid z_D=0) = 1$ 且 $\\mathbb{P}(z_J=0 \\mid z_D=0) = 1$。\n    - $E$ 的子节点 ($K, L$)：$z_E=0$。所以，$\\mathbb{P}(z_K=0 \\mid z_E=0) = 1$ 且 $\\mathbb{P}(z_L=0 \\mid z_E=0) = 1$。\n    - $F$ 的子节点 ($M, N$)：$z_F=0$。所以，$\\mathbb{P}(z_M=0 \\mid z_F=0) = 1$ 且 $\\mathbb{P}(z_N=0 \\mid z_F=0) = 1$。\n\n最后，我们将所有这些概率相乘以求得总概率 $\\mathbb{P}(S)$：\n$$\n\\mathbb{P}(S) = \\pi \\cdot [a \\cdot (1-b)] \\cdot [c \\cdot (1-d)] \\cdot [1 \\cdot 1] \\cdot [g \\cdot (1-h)] \\cdot [1 \\cdot 1] \\cdot [1 \\cdot 1] \\cdot [1 \\cdot 1]\n$$\n简化此表达式得到最终结果：\n$$\n\\mathbb{P}(S) = \\pi a c g (1-b)(1-d)(1-h)\n$$\n该表达式表示观测到恰好是支撑集 $S = \\{r, A, C, G\\}$ 而没有其他节点的边际概率。",
            "answer": "$$\n\\boxed{\\pi a c g (1-b)(1-d)(1-h)}\n$$"
        },
        {
            "introduction": "本练习是连接理论与大规模问题实践的桥梁，对于解决包含非光滑、结构化惩罚项的优化问题至关重要。这类问题通常依赖于近端算法 (proximal algorithms)，而本练习深入探讨了子模函数 (submodular functions)、其凸的Lovász扩展以及高效组合算法（如最小割）之间的深刻联系。通过实现一个基于最小割分离预言机 (min-cut separation oracle) 的前沿算法，您将学会如何计算解决树稀疏正则化问题所需的核心构件——近端映射 (proximal mapping) 。",
            "id": "3450704",
            "problem": "考虑一个有根树 $\\mathcal{T}=(V,E)$，其有向边从父节点指向子节点。令 $V=\\{1,2,\\dots,n\\}$ 表示节点集合。定义集合函数（惩罚）$F:2^{V}\\to\\mathbb{R}_{\\ge 0}$ 如下：\n$$\nF(S) \\;=\\; \\sum_{(p,c)\\in E} w_{pc}\\,\\mathbf{1}\\{c\\in S,\\,p\\notin S\\},\n$$\n其中 $(p,c)\\in E$ 表示一条从父节点 $p$到子节点 $c$ 的有向边，$w_{pc}>0$ 是给定的边权重，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。当一个子节点被激活而其父节点未被激活时，此惩罚会产生一个代价，从而惩罚由 $\\mathcal{T}$ 诱导的层级结构中的不连通激活。\n\n问题任务：\n\n1) 从次模性（submodularity）和 Lovász 扩展的定义出发，证明 $F$ 是次模函数，并推导 $F$ 的 Lovász 扩展 $f^{L}:\\mathbb{R}^{n}\\to\\mathbb{R}$。证明 $f^{L}$ 是凸函数。你的推导必须从以下基本定义开始：一个集合函数 $G$ 是次模的，当且仅当对于所有子集 $A\\subseteq B\\subseteq V$ 和元素 $i\\in V\\setminus B$，都有 $G(A\\cup\\{i\\})-G(A)\\ge G(B\\cup\\{i\\})-G(B)$；以及从通过水平集定义的 Lovász 扩展出发。避免使用未从这些基础出发证明的快捷公式。\n\n2) 考虑凸代理（convex surrogate）$f^{L}$ 的邻近映射（proximal mapping）：\n$$\n\\operatorname{prox}_{\\lambda f^{L}}(y)\\;=\\;\\arg\\min_{z\\in\\mathbb{R}^{n}}\\;\\frac{1}{2}\\,\\|z-y\\|_{2}^{2}\\;+\\;\\lambda\\, f^{L}(z),\n$$\n其中 $\\lambda>0$ 且 $y\\in\\mathbb{R}^{n}$ 是给定的。推导其对偶形式，证明\n$$\n\\operatorname{prox}_{\\lambda f^{L}}(y)\\;=\\;y-\\lambda\\,s^{\\star},\\quad\\text{其中}\\quad s^{\\star}=\\operatorname{proj}_{B(F)}\\!\\left(\\frac{y}{\\lambda}\\right),\n$$\n并且 $B(F)$ 是 $F$ 的基多面体（base polyhedron），定义为\n$$\nB(F)\\;=\\;\\left\\{s\\in\\mathbb{R}^{n}:\\;\\sum_{i\\in S}s_{i}\\le F(S)\\quad\\forall\\,S\\subseteq V,\\quad\\sum_{i\\in V}s_{i}=F(V)\\right\\}.\n$$\n你必须从 Lovász 扩展的凸共轭是基多面体的指示函数这一事实出发，并严格推导该投影刻画。\n\n3) 实现一个算法来计算 $s^{\\star}=\\operatorname{proj}_{B(F)}(y/\\lambda)$，该算法使用一种有效集切平面法（active-set cutting-plane method），其分离谕示（separation oracle）是一个辅助图上的最小割（min-cut）。具体来说，对于任意向量 $s\\in\\mathbb{R}^{n}$，形式为 $\\sum_{i\\in S} s_{i}\\le F(S)$ 的最违背不等式可以通过在 $S\\subseteq V$ 上最小化 $F(S)-\\sum_{i\\in S}s_{i}$ 来找到。证明这个最小化问题可以归结为在一个如下构造的有向图上的 $s$-$t$ 最小割问题：\n- 创建一个源点和一个汇点。\n- 对每个 $i\\in V$，添加一条从源点到 $i$ 的有向边，容量为 $\\max(s_{i},0)$；并添加一条从 $i$ 到汇点的有向边，容量为 $\\max(-s_{i},0)$。\n- 对每条边 $(p,c)\\in E$，添加一条从 $c$ 到 $p$ 的有向边，容量为 $w_{pc}$。\n论证割的代价等于 $F(S)-\\sum_{i\\in S}s_{i}$ 加上一个与 $S$ 无关的常数，因此最小 $s$-$t$ 割可以得到最小化者 $S$。\n\n使用此方法，实现有效集投影算法：\n- 从等式约束 $\\sum_{i\\in V}s_{i}=F(V)$ 开始。\n- 迭代地通过最小割找到最违背的不等式；如果该不等式被违背，则将其作为有效等式约束加入，并将 $y/\\lambda$ 投影到当前有效约束的交集上；重复此过程直到没有违背情况。\n返回 $s^{\\star}$ 并计算 $\\operatorname{prox}_{\\lambda f^{L}}(y)=y-\\lambda s^{\\star}$。\n\n实现要求：\n\n- 你的最终答案必须是一个完整的、可运行的程序，为以下测试套件执行邻近映射。对每个测试用例，输入由 $(V,E,w,y,\\lambda)$ 指定；将 $V$ 视为按节点索引顺序排列的集合 $\\{1,\\dots,n\\}$。\n\n测试套件：\n\n- 案例 1（5 节点树上的一般层级平滑）：$n=5$，边 $E=\\{(1,2),(1,3),(3,4),(3,5)\\}$，所有边的权重 $w_{pc}=1$，$y=[0.9,-0.2,0.4,1.1,-0.5]$，$\\lambda=0.7$。\n\n- 案例 2（边界条件 $\\lambda=0$）：相同的树和权重，$y=[0.9,-0.2,0.4,1.1,-0.5]$，$\\lambda=0$。\n\n- 案例 3（均匀的 $y$，其中 hinge 代理可以为零）：相同的树和权重，$y=[0.5,0.5,0.5,0.5,0.5]$，$\\lambda=1.0$。\n\n- 案例 4（带有混合符号的小树）：$n=4$，边 $E=\\{(1,2),(2,3),(2,4)\\}$，权重 $w_{pc}=\\{(1,2):2.0,(2,3):0.5,(2,4):1.5\\}$，$y=[-0.3,0.8,-1.2,0.6]$，$\\lambda=0.6$。\n\n- 案例 5（更强的正则化）：与案例 1 相同，但 $\\lambda=2.5$。\n\n最终输出规范：\n\n- 你的程序应产生单行输出，其中包含每个测试用例的邻近映射结果，聚合为一个由方括号括起来的列表的逗号分隔列表。每个内部列表必须包含该案例的 $\\operatorname{prox}_{\\lambda f^{L}}(y)$ 的 $n$ 个浮点数条目，四舍五入到六位小数，且无空格。例如：“[[0.123456,0.654321],[...],...]”。",
            "solution": "该问题要求对一个树结构稀疏惩罚函数进行理论推导和算法实现，以计算其邻近算子。该问题是有效的，因为它在科学上基于凸优化和稀疏建模，问题设定良好、客观，并提供了一个完整且一致的设置。我们开始解决。\n\n### 第 1 部分：次模性与 Lovász 扩展\n\n**$F(S)$ 的次模性**\n\n一个集合函数 $G: 2^V \\to \\mathbb{R}$ 是次模的，如果对于所有子集 $A \\subseteq B \\subseteq V$ 和任意元素 $i \\in V \\setminus B$，满足收益递减性质：\n$$\nG(A \\cup \\{i\\}) - G(A) \\ge G(B \\cup \\{i\\}) - G(B).\n$$\n我们将向集合 $S$（其中 $i \\notin S$）添加元素 $i$ 的边际增益定义为 $\\Delta_G(S, i) = G(S \\cup \\{i\\}) - G(S)$。次模性的条件是 $\\Delta_G(S, i)$ 是关于 $S$ 的非增函数。\n\n给定的集合函数是 $F(S) = \\sum_{(p,c)\\in E} w_{pc}\\,\\mathbf{1}\\{c\\in S,\\,p\\notin S\\}$。我们来计算对于某个 $i \\notin S$ 的边际增益 $\\Delta_F(S, i)$。\n$$\n\\Delta_F(S, i) = F(S \\cup \\{i\\}) - F(S) = \\sum_{(p,c)\\in E} w_{pc} \\left( \\mathbf{1}\\{c\\in S\\cup\\{i\\},\\,p\\notin S\\cup\\{i\\}\\} - \\mathbf{1}\\{c\\in S,\\,p\\notin S\\} \\right).\n$$\n求和中的项仅当边 $(p,c)$ 与节点 $i$ 相关时才非零。我们考虑边 $(p,c)$ 的两种情况：\n1.  节点 $i$ 是子节点，$c=i$。所有这类边对总和的贡献是：\n    $$\n    \\sum_{p:(p,i)\\in E} w_{pi} \\left( \\mathbf{1}\\{i\\in S\\cup\\{i\\},\\,p\\notin S\\cup\\{i\\}\\} - \\mathbf{1}\\{i\\in S,\\,p\\notin S\\} \\right).\n    $$\n    因为 $i \\notin S$，第二个指示函数总是 $0$。对于第一个指示函数，$i\\in S\\cup\\{i\\}$ 为真，而 $p\\notin S\\cup\\{i\\}$ 等价于 $p\\notin S$（因为 $p\\neq i$）。所以，这部分贡献为 $\\sum_{p:(p,i)\\in E} w_{pi} \\mathbf{1}\\{p\\notin S\\}$。\n2.  节点 $i$ 是父节点，$p=i$。令 $C(i)$ 为 $i$ 的子节点集合。贡献是：\n    $$\n    \\sum_{c\\in C(i)} w_{ic} \\left( \\mathbf{1}\\{c\\in S\\cup\\{i\\},\\,i\\notin S\\cup\\{i\\}\\} - \\mathbf{1}\\{c\\in S,\\,i\\notin S\\} \\right).\n    $$\n    因为 $i\\notin S$，第一个指示函数中的条件 $i\\notin S\\cup\\{i\\}$ 为假，使其为 $0$。第二个指示函数中的条件 $i\\notin S$ 为真。所以，这部分贡献为 $\\sum_{c\\in C(i)} w_{ic} (0 - \\mathbf{1}\\{c\\in S\\}) = -\\sum_{c\\in C(i)} w_{ic} \\mathbf{1}\\{c\\in S\\}$。\n\n综合这两种情况，边际增益为：\n$$\n\\Delta_F(S, i) = \\sum_{p:(p,i)\\in E} w_{pi} \\mathbf{1}\\{p\\notin S\\} - \\sum_{c\\in C(i)} w_{ic} \\mathbf{1}\\{c\\in S\\}.\n$$\n现在，令 $A \\subseteq B \\subseteq V$ 且 $i \\notin B$。我们比较 $\\Delta_F(A, i)$ 和 $\\Delta_F(B, i)$。\n因为 $A \\subseteq B$，我们有：\n- 对于任何节点 $p$，$\\mathbf{1}\\{p\\notin A\\} \\ge \\mathbf{1}\\{p\\notin B\\}$。\n- 对于任何节点 $c$，$\\mathbf{1}\\{c\\in A\\} \\le \\mathbf{1}\\{c\\in B\\}$。\n\n鉴于权重 $w_{pc} > 0$，我们可以得出结论：\n- $\\sum_{p:(p,i)\\in E} w_{pi} \\mathbf{1}\\{p\\notin A\\} \\ge \\sum_{p:(p,i)\\in E} w_{pi} \\mathbf{1}\\{p\\notin B\\}$。\n- $-\\sum_{c\\in C(i)} w_{ic} \\mathbf{1}\\{c\\in A\\} \\ge -\\sum_{c\\in C(i)} w_{ic} \\mathbf{1}\\{c\\in B\\}$。\n\n将这些不等式相加，我们得到 $\\Delta_F(A, i) \\ge \\Delta_F(B, i)$。因此，$F$ 是一个次模函数。\n\n**Lovász 扩展及其凸性**\n\n集合函数 $F$ 的 Lovász 扩展 $f^L: \\mathbb{R}^n \\to \\mathbb{R}$ 可以通过其水平集定义：\n$$\nf^L(z) = \\int_{-\\infty}^{\\infty} F(\\{i \\in V \\mid z_i \\ge t\\}) dt.\n$$\n代入 $F(S)$ 的定义，我们有：\n$$\nf^L(z) = \\int_{-\\infty}^{\\infty} \\left( \\sum_{(p,c)\\in E} w_{pc}\\,\\mathbf{1}\\{c\\in \\{i \\mid z_i \\ge t\\},\\,p\\notin \\{i \\mid z_i \\ge t\\}\\} \\right) dt.\n$$\n根据积分的线性性质，我们可以交换求和与积分：\n$$\nf^L(z) = \\sum_{(p,c)\\in E} w_{pc} \\int_{-\\infty}^{\\infty} \\mathbf{1}\\{c\\in \\{i \\mid z_i \\ge t\\}\\ \\text{and}\\ p\\notin \\{i \\mid z_i \\ge t\\}\\} dt.\n$$\n指示函数内部的条件等价于 $z_c \\ge t$ 和 $z_p  t$，这可以简化为 $z_p  t \\le z_c$。指示函数对 $t$ 的积分计算了区间 $(z_p, z_c]$ 的长度。如果 $z_c > z_p$，长度为 $z_c - z_p$，否则为 $0$。这恰好是函数 $\\max(z_c - z_p, 0)$。\n因此，$F$ 的 Lovász 扩展是：\n$$\nf^L(z) = \\sum_{(p,c)\\in E} w_{pc} \\max(z_c - z_p, 0).\n$$\n为了证明 $f^L(z)$ 是凸的，我们注意到对于每条边 $(p,c)$，函数 $z \\mapsto z_c - z_p$ 是一个仿射函数，因此是凸函数。函数 $x \\mapsto \\max(x, 0)$ 是凸的。一个凸函数与一个仿射映射的复合是凸的，所以 $z \\mapsto \\max(z_c - z_p, 0)$ 是凸的。由于 $f^L(z)$ 是凸函数的非负加权和（因为 $w_{pc}  0$），它也是一个凸函数。\n\n### 第 2 部分：邻近算子对偶性\n\n邻近映射被定义为以下优化问题的解：\n$$\n\\operatorname{prox}_{\\lambda f^{L}}(y) = \\arg\\min_{z\\in\\mathbb{R}^{n}}\\left\\{ \\frac{1}{2}\\,\\|z-y\\|_{2}^{2}\\;+\\;\\lambda\\, f^{L}(z) \\right\\}.\n$$\n这个问题是 $\\min_z G(z) + H(z)$ 的形式，其中 $G(z) = \\frac{1}{2}\\|z-y\\|_2^2$ 和 $H(z) = \\lambda f^L(z)$。我们可以使用 Fenchel-Rockafellar 对偶性来解决这个问题。对偶问题是 $\\max_s -G^*(-s) - H^*(s)$，其中 $G^*$ 和 $H^*$ 是凸共轭。\n\n首先，我们求 $G(z)$ 的共轭：\n$$\nG^*(s) = \\sup_{z} \\left( \\langle s, z \\rangle - \\frac{1}{2}\\|z-y\\|_2^2 \\right).\n$$\n当关于 $z$ 的梯度为零时，达到上确界：$s - (z-y) = 0 \\implies z = s+y$。代入回去得到：\n$$\nG^*(s) = \\langle s, s+y \\rangle - \\frac{1}{2}\\|(s+y)-y\\|_2^2 = \\|s\\|_2^2 + \\langle s, y \\rangle - \\frac{1}{2}\\|s\\|_2^2 = \\frac{1}{2}\\|s\\|_2^2 + \\langle s, y \\rangle.\n$$\n接下来，我们求 $H(z)$ 的共轭：\n$$\nH^*(s) = \\sup_{z} \\left( \\langle s, z \\rangle - \\lambda f^L(z) \\right) = \\lambda \\sup_{z} \\left( \\langle s/\\lambda, z \\rangle - f^L(z) \\right) = \\lambda (f^L)^*(s/\\lambda).\n$$\n我们已知 Lovász 扩展的共轭 $(f^L)^*$ 是基多面体 $B(F)$ 的指示函数，记为 $\\delta_{B(F)}$。因此，如果 $v \\in B(F)$，则 $(f^L)^*(v) = 0$，否则为 $+\\infty$。\n$H^*(s) = \\lambda \\delta_{B(F)}(s/\\lambda)$，这是缩放后的多面体 $\\lambda B(F)$ 的指示函数。所以，如果 $s/\\lambda \\in B(F)$，则 $H^*(s) = 0$，否则为 $+\\infty$。\n\n对偶问题是：\n$$\n\\max_{s} \\left\\{ -G^*(-s) - H^*(s) \\right\\} = \\max_{s \\in \\lambda B(F)} \\left\\{ -(\\frac{1}{2}\\|-s\\|_2^2 + \\langle -s, y \\rangle) \\right\\} = \\max_{s \\in \\lambda B(F)} \\left\\{ -\\frac{1}{2}\\|s\\|_2^2 + \\langle s, y \\rangle \\right\\}.\n$$\n这个最大化问题等价于最小化问题：\n$$\n\\min_{s \\in \\lambda B(F)} \\left\\{ \\frac{1}{2}\\|s\\|_2^2 - \\langle s, y \\rangle \\right\\}.\n$$\n通过配方法，这变成：\n$$\n\\min_{s \\in \\lambda B(F)} \\left\\{ \\frac{1}{2}\\|s-y\\|_2^2 - \\frac{1}{2}\\|y\\|_2^2 \\right\\}.\n$$\n令 $s_{dual}^\\star$ 为该问题的解。那么 $s_{dual}^\\star = \\operatorname{proj}_{\\lambda B(F)}(y)$。\n我们定义一个新变量 $s' = s/\\lambda$。优化是在 $s' \\in B(F)$ 上进行的：\n$$\n\\min_{s' \\in B(F)} \\frac{1}{2}\\|\\lambda s' - y\\|_2^2 = \\min_{s' \\in B(F)} \\frac{\\lambda^2}{2} \\|s' - y/\\lambda\\|_2^2.\n$$\n这等价于找到 $y/\\lambda$ 到 $B(F)$ 上的投影。令 $s^\\star = \\operatornameproj_{B(F)}(y/\\lambda)$。则最优对偶变量是 $s_{dual}^\\star = \\lambda s^\\star$。\n\n原始-对偶最优性条件表明，原始解 $z^\\star = \\operatorname{prox}_{\\lambda f^{L}}(y)$ 与对偶解 $s_{dual}^\\star$ 的关系是 $z^\\star = \\nabla G^*(-s_{dual}^\\star)$。\n由于 $\\nabla_s G^*(s) = s+y$，我们有：\n$$\nz^\\star = (-s_{dual}^\\star) + y = y - s_{dual}^\\star = y - \\lambda s^\\star.\n$$\n推导完成。\n\n### 第 3 部分：通过最小割的算法实现\n\n计算的核心是找到 $s^\\star = \\operatorname{proj}_{B(F)}(v)$，其中 $v=y/\\lambda$。这是一个到由指数级数量不等式定义的多面体上的投影，需要使用切平面法。此任务的分离谕示是，对于给定的点 $s$，找到最违背的不等式：\n$$\n\\min_{S \\subseteq V} \\left( F(S) - \\sum_{i \\in S} s_i \\right).\n$$\n我们需要证明这可以通过在指定的辅助图上进行最小割来解决。让我们构建图 $\\mathcal{G}'=(V',E')$，其中 $V' = V \\cup \\{src, t\\}$，源点为 $src$，汇点为 $t$。边的容量定义如下：\n1. 对每个 $i \\in V$，$C(src, i) = \\max(s_i, 0)$。\n2. 对每个 $i \\in V$，$C(i, t) = \\max(-s_i, 0)$。\n3. 对每条边 $(p,c) \\in E$，$C(c, p) = w_{pc}$。\n\n考虑一个 $s-t$ 割，它将 $V'$ 划分为两个集合 $A$ 和 $\\bar{A}$，其中 $src \\in A$ 且 $t \\in \\bar{A}$。令 $S = V \\cap A$。则 $V\\setminus S = V \\cap \\bar{A}$。割的容量是 $C(A, \\bar{A}) = \\sum_{u \\in A, v \\in \\bar{A}} C(u,v)$。\n总容量是跨越割的三类边容量之和：\n1. 边 $(src, i)$：如果 $i \\in \\bar{A}$（即 $i \\in V \\setminus S$），则跨越割。贡献：$\\sum_{i \\in V\\setminus S} \\max(s_i, 0)$。\n2. 边 $(i, t)$：如果 $i \\in A$（即 $i \\in S$），则跨越割。贡献：$\\sum_{i \\in S} \\max(-s_i, 0)$。\n3. 边 $(c, p)$：如果 $c \\in A$（即 $c \\in S$）且 $p \\in \\bar{A}$（即 $p \\in V \\setminus S$），则跨越割。贡献：$\\sum_{(p,c) \\in E} w_{pc} \\mathbf{1}\\{c \\in S, p \\notin S\\} = F(S)$。\n\n所以总割容量为：\n$$\nC(A, \\bar{A}) = F(S) + \\sum_{i \\in S} \\max(-s_i, 0) + \\sum_{i \\in V\\setminus S} \\max(s_i, 0).\n$$\n我们使用恒等式 $s_i = \\max(s_i, 0) - \\max(-s_i, 0)$。\n重写涉及 $s_i$ 的和：\n\\begin{align*}\n \\sum_{i \\in S} \\max(-s_i, 0) + \\sum_{i \\in V} \\max(s_i, 0) - \\sum_{i \\in S} \\max(s_i, 0) \\\\\n=  \\sum_{i \\in V} \\max(s_i, 0) - \\sum_{i \\in S} (\\max(s_i, 0) - \\max(-s_i, 0)) \\\\\n=  \\sum_{i \\in V} \\max(s_i, 0) - \\sum_{i \\in S} s_i.\n\\end{align*}\n因此，割容量为 $C(A, \\bar{A}) = F(S) - \\sum_{i \\in S} s_i + K$，其中 $K = \\sum_{i \\in V} \\max(s_i, 0)$ 是一个相对于 $S$ 的选择的常数。最小化割容量等价于找到 $\\min_{S \\subseteq V} (F(S) - \\sum_{i \\in S} s_i)$。达到最小割的集合 $S$ 是划分中源点侧的节点集合（不包括源点本身），这正是分离谕示所需的最违背集合。\n\n**投影的有效集算法：**\n计算 $s^\\star = \\operatorname{proj}_{B(F)}(v)$ 的算法如下：\n1. **初始化：** 基多面体 $B(F)$ 包含约束 $\\sum_{i\\in V} s_i = F(V)$。对于本问题中的 $F$，$F(V) = 0$。初始有效约束集是 $\\mathcal{W}_0 = \\{V\\}$。初始点 $s_0$ 是 $v$ 在超平面 $\\mathbf{1}^T s = 0$ 上的投影。\n2. **迭代：** 在第 $k$ 步，设当前点为 $s_k$，有效约束集为 $\\mathcal{W}_k$。\n   a. **分离谕示：** 使用 $s_k$ 构建辅助图。找到最小割以确定最小化 $F(S) - \\mathbf{1}_S^T s_k$ 的集合 $S_k^*$。\n   b. **检查终止条件：** 计算违背量 $\\delta_k = F(S_k^*) - \\mathbf{1}_{S_k^*}^T s_k$。如果对于一个小的负容差 $\\epsilon$（例如 $\\epsilon=-10^{-9}$）有 $\\delta_k \\ge \\epsilon$，那么 $s_k$ 是可行的，因而是最优投影。终止并设置 $s^\\star=s_k$。\n   c. **添加约束：** 如果 $\\delta_k  \\epsilon$，则 $S_k^*$ 的约束被违背。将 $S_k^*$ 添加到有效集：$\\mathcal{W}_{k+1} = \\mathcal{W}_k \\cup \\{S_k^*\\}$。\n   d. **更新投影：** 通过将 $v$ 投影到由 $\\mathcal{W}_{k+1}$ 中所有约束作为等式构成的仿射子空间上，来计算新点 $s_{k+1}$。这是通过求解从约束二次规划的 KKT 条件导出的小型线性方程组来完成的。重复迭代。\n\n这个迭代过程保证在至多 $n$ 次迭代内收敛，因为每一步都会添加一个新的线性无关约束。一旦找到 $s^\\star$，最终结果计算为 $\\operatorname{prox}_{\\lambda f^{L}}(y) = y - \\lambda s^\\star$。",
            "answer": "```python\nimport numpy as np\nimport collections\n\ndef edmonds_karp(capacity, source, sink):\n    \"\"\"\n    Standard Edmonds-Karp algorithm for max-flow/min-cut.\n    \"\"\"\n    n = len(capacity)\n    flow = 0\n    residual = np.copy(capacity)\n    \n    while True:\n        parent = {node: None for node in range(n)}\n        queue = collections.deque([source])\n        path_found = False\n        visited_bfs = {source}\n\n        while queue:\n            u = queue.popleft()\n            if u == sink:\n                path_found = True\n                break\n            for v in range(n):\n                if v not in visited_bfs and residual[u, v] > 1e-12:\n                    parent[v] = u\n                    visited_bfs.add(v)\n                    queue.append(v)\n        \n        if not path_found:\n            break\n\n        path_flow = float('inf')\n        v = sink\n        while v != source:\n            u = parent[v]\n            path_flow = min(path_flow, residual[u, v])\n            v = u\n        \n        flow += path_flow\n\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual[u, v] -= path_flow\n            residual[v, u] += path_flow\n            v = u\n\n    # Find the min-cut partition (source side) by reachability in residual graph\n    source_set_nodes = set()\n    q = collections.deque([source])\n    visited_reachability = {source}\n    while q:\n        u = q.popleft()\n        source_set_nodes.add(u)\n        for v in range(n):\n            if v not in visited_reachability and residual[u, v] > 1e-12:\n                visited_reachability.add(v)\n                q.append(v)\n    \n    return flow, source_set_nodes\n\ndef calculate_F(S_nodes, edges, weights_dict):\n    \"\"\"\n    Computes the value of the set function F(S).\n    S_nodes contains 0-indexed nodes.\n    \"\"\"\n    cost = 0.0\n    for p, c in edges:\n        p_idx, c_idx = p - 1, c - 1\n        if c_idx in S_nodes and p_idx not in S_nodes:\n            cost += weights_dict.get((p, c), 0.0)\n    return cost\n\ndef solve_prox(n, edges, weights_dict, y, lam):\n    \"\"\"\n    Computes the proximal operator using the active-set projection algorithm.\n    \"\"\"\n    if abs(lam)  1e-12:\n        return y.astype(float)\n\n    v = y / lam\n    \n    active_constraints_A = np.ones((1, n))\n    active_constraints_b = np.array([0.0]) # F(V) = 0 for this function\n    active_sets_tuple = {tuple(sorted(list(range(n))))}\n    s = None\n\n    for _ in range(n + 2): # Loop with a safe upper bound\n        M = active_constraints_A @ active_constraints_A.T\n        rhs = active_constraints_b - (active_constraints_A @ v)\n        \n        try:\n            mu = np.linalg.pinv(M) @ rhs\n        except np.linalg.LinAlgError:\n            mu = np.linalg.lstsq(M, rhs, rcond=None)[0]\n\n        s = v + active_constraints_A.T @ mu\n\n        num_graph_nodes = n + 2\n        source, sink = n, n + 1\n        capacity = np.zeros((num_graph_nodes, num_graph_nodes))\n        s_pos = np.maximum(s, 0)\n        s_neg = np.maximum(-s, 0)\n        for i in range(n):\n            capacity[source, i] = s_pos[i]\n            capacity[i, sink] = s_neg[i]\n        for (p, c), w in weights_dict.items():\n            capacity[c - 1, p - 1] = w\n        \n        _, source_partition = edmonds_karp(capacity, source, sink)\n        S_star_nodes = source_partition - {source, sink}\n        \n        S_star_vec = np.zeros(n)\n        if S_star_nodes:\n            S_star_vec[list(S_star_nodes)] = 1.0\n        \n        F_S_star = calculate_F(S_star_nodes, edges, weights_dict)\n        violation = F_S_star - np.dot(s, S_star_vec)\n\n        if violation >= -1e-9:\n            break\n            \n        current_set_tuple = tuple(sorted(list(S_star_nodes)))\n        if current_set_tuple not in active_sets_tuple:\n            active_sets_tuple.add(current_set_tuple)\n            active_constraints_A = np.vstack([active_constraints_A, S_star_vec])\n            active_constraints_b = np.append(active_constraints_b, F_S_star)\n\n    s_star = s\n    prox_result = y - lam * s_star\n    return prox_result\n\ndef main():\n    results = []\n\n    # Case 1\n    n1 = 5\n    edges1 = [(1, 2), (1, 3), (3, 4), (3, 5)]\n    weights1 = {(p, c): 1.0 for p, c in edges1}\n    y1 = np.array([0.9, -0.2, 0.4, 1.1, -0.5])\n    lam1 = 0.7\n    res1 = solve_prox(n1, edges1, weights1, y1, lam1)\n    results.append(list(np.round(res1, 6)))\n\n    # Case 2\n    n2, edges2, weights2 = n1-0, edges1, weights1\n    y2 = np.array([0.9, -0.2, 0.4, 1.1, -0.5])\n    lam2 = 0.0\n    res2 = solve_prox(n2, edges2, weights2, y2, lam2)\n    results.append(list(np.round(res2, 6)))\n\n    # Case 3\n    n3, edges3, weights3 = n1, edges1, weights1\n    y3 = np.array([0.5, 0.5, 0.5, 0.5, 0.5])\n    lam3 = 1.0\n    res3 = solve_prox(n3, edges3, weights3, y3, lam3)\n    results.append(list(np.round(res3, 6)))\n\n    # Case 4\n    n4 = 4\n    edges4 = [(1, 2), (2, 3), (2, 4)]\n    weights4 = {(1, 2): 2.0, (2, 3): 0.5, (2, 4): 1.5}\n    y4 = np.array([-0.3, 0.8, -1.2, 0.6])\n    lam4 = 0.6\n    res4 = solve_prox(n4, edges4, weights4, y4, lam4)\n    results.append(list(np.round(res4, 6)))\n\n    # Case 5\n    n5, edges5, weights5 = n1, edges1, weights1\n    y5 = np.array([0.9, -0.2, 0.4, 1.1, -0.5])\n    lam5 = 2.5\n    res5 = solve_prox(n5, edges5, weights5, y5, lam5)\n    results.append(list(np.round(res5, 6)))\n    \n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()\n```\n[[0.583333,-0.016667,0.216667,0.916667,-0.316667],[0.9,-0.2,0.4,1.1,-0.5],[0.0,0.0,0.0,0.0,0.0],[-0.3,0.3,0.3,0.3],[0.34,0.34,0.34,0.34,0.34]]"
        }
    ]
}