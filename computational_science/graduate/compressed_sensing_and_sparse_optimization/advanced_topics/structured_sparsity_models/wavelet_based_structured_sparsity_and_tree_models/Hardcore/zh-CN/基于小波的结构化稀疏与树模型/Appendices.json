{
    "hands_on_practices": [
        {
            "introduction": "除了基本的投影操作，现代优化算法（如ISTA/FISTA或ADMM）通过近端算子（proximal operators）来求解复杂的带罚项问题。这些算子能够有效处理鼓励树稀疏性等非光滑正则化项。本练习将展示如何为一个常见的树结构罚项推导并高效实现其近端算子，揭示罚项结构与可解耦的逐节点计算之间的深刻联系。",
            "id": "3494242",
            "problem": "考虑一个有根树 $\\mathcal{T} = (\\mathcal{V}, \\mathcal{E})$，其具有一个指定的根节点 $r \\in \\mathcal{V}$，其中每个节点 $v \\in \\mathcal{V}$ 都有一个有限的子节点集合 $\\mathrm{ch}(v) \\subseteq \\mathcal{V}$。对于每个节点 $v \\in \\mathcal{V}$，定义一个关联的变量块 $x_v \\in \\mathbb{R}^{d_v}$，其中 $d_v \\in \\mathbb{N}$ 是节点 $v$ 的块维度。令 $\\mathcal{L} \\subseteq \\mathcal{V}$ 表示叶节点（没有子节点的节点）的集合，对于每个叶节点 $\\ell \\in \\mathcal{L}$，令 $P(\\ell)$ 表示从根节点 $r$ 到叶节点 $\\ell$ 的唯一根到叶路径上的节点集合。令 $y_v \\in \\mathbb{R}^{d_v}$ 为在节点 $v$ 处的给定观测值。定义惩罚项\n$$\n\\Phi(x) = \\lambda \\sum_{\\ell \\in \\mathcal{L}} \\sum_{v \\in P(\\ell)} \\lVert x_v \\rVert_2,\n$$\n其中 $\\lambda  0$ 是一个给定的正则化参数，$\\lVert \\cdot \\rVert_2$ 表示欧几里得范数。考虑 $\\Phi$ 的近端映射，对于 $\\tau  0$ 定义为\n$$\n\\operatorname{prox}_{\\tau \\Phi}(y) = \\arg\\min_{x} \\left\\{ \\frac{1}{2} \\sum_{v \\in \\mathcal{V}} \\lVert x_v - y_v \\rVert_2^2 + \\tau \\lambda \\sum_{\\ell \\in \\mathcal{L}} \\sum_{v \\in P(\\ell)} \\lVert x_v \\rVert_2 \\right\\}。\n$$\n从近端映射的核心定义和有根树的结构出发，根据第一性原理推导出近端映射 $\\operatorname{prox}_{\\tau \\Phi}(y)$ 可以通过在树上进行动态规划，在 $\\mathcal{O}(n)$ 时间内计算得出，其中 $n = |\\mathcal{V}|$。特别地，证明在对路径求和进行重新索引后，目标函数在节点间解耦，并且计算可以简化为使用叶子计数递归表示的、带有节点特定权重的分块收缩。明确推导叶子计数 $c_v$ 的递归步骤，其中 $c_v$ 是以 $v$ 为根的子树中的叶子数量，并根据 $c_v$ 在每个节点上实现分块近端更新。\n\n您的程序必须实现此推导，并为以下测试套件计算 $\\operatorname{prox}_{\\tau \\Phi}(y)$。在所有情况下，根节点索引为 $0$，树由每个节点 $v$ 的子节点列表指定，并且每个节点都有一个指定的块 $y_v \\in \\mathbb{R}^{d_v}$。对每种情况使用提供的 $\\lambda$ 和 $\\tau$ 值。\n\n测试用例 $\\mathbf{1}$（链式树，基准情况）：\n- 树：$0 \\rightarrow 1 \\rightarrow 2 \\rightarrow 3$。\n- 块维度：$d_0 = 2$, $d_1 = 2$, $d_2 = 2$, $d_3 = 2$。\n- 观测值：$y_0 = [0.6, -0.8]$, $y_1 = [0.1, 0.0]$, $y_2 = [0.0, 0.0]$, $y_3 = [3.0, 4.0]$。\n- 参数：$\\lambda = 0.5$, $\\tau = 0.5$。\n\n测试用例 $\\mathbf{2}$（星形树，突出根部聚合）：\n- 树：$0 \\rightarrow \\{1, 2, 3\\}$，其中 $1, 2, 3$ 为叶节点。\n- 块维度：$d_0 = 3$, $d_1 = 1$, $d_2 = 1$, $d_3 = 1$。\n- 观测值：$y_0 = [1.0, 0.0, 0.0]$, $y_1 = [0.3]$, $y_2 = [0.0]$, $y_3 = [0.5]$。\n- 参数：$\\lambda = 0.4$, $\\tau = 1.0$。\n\n测试用例 $\\mathbf{3}$（平衡二叉树，混合块大小）：\n- 树：$0 \\rightarrow \\{1, 2\\}$, $1 \\rightarrow \\{3, 4\\}$, $2 \\rightarrow \\{5, 6\\}$，叶节点为 $3, 4, 5, 6$。\n- 块维度：$d_0 = 2$, $d_1 = 2$, $d_2 = 2$, $d_3 = 1$, $d_4 = 1$, $d_5 = 1$, $d_6 = 1$。\n- 观测值：$y_0 = [0.5, 0.5]$, $y_1 = [1.2, 0.0]$, $y_2 = [0.0, 0.9]$, $y_3 = [0.2]$, $y_4 = [1.0]$, $y_5 = [0.1]$, $y_6 = [0.0]$。\n- 参数：$\\lambda = 0.2$, $\\tau = 1.5$。\n\n测试用例 $\\mathbf{4}$（单节点树，边界情况）：\n- 树：单个节点 $0$（一个叶节点）。\n- 块维度：$d_0 = 3$。\n- 观测值：$y_0 = [0.3, -0.4, 0.0]$。\n- 参数：$\\lambda = 0.7$, $\\tau = 0.5$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果是一个列表，该列表包含按节点升序索引排列的近端块，这些块被连接并展平为单个实数列表。例如，格式为 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，除了列表分隔符所需的空格外，不添加任何空格。不涉及物理单位或角度单位，答案必须是实值浮点数。最终输出必须是确定性的，并且完全根据给定数据计算得出，无需任何外部输入。",
            "solution": "该问题要求推导一种高效算法来计算树结构正则化项 $\\Phi(x)$ 的近端映射，并实现该算法。近端映射定义为：\n$$\n\\operatorname{prox}_{\\tau \\Phi}(y) = \\arg\\min_{x} \\left\\{ F(x) = \\frac{1}{2} \\sum_{v \\in \\mathcal{V}} \\lVert x_v - y_v \\rVert_2^2 + \\tau \\Phi(x) \\right\\}\n$$\n其中惩罚项 $\\Phi(x)$ 由下式给出\n$$\n\\Phi(x) = \\lambda \\sum_{\\ell \\in \\mathcal{L}} \\sum_{v \\in P(\\ell)} \\lVert x_v \\rVert_2.\n$$\n变量是与有根树 $\\mathcal{T} = (\\mathcal{V}, \\mathcal{E})$ 的每个节点 $v$ 相关联的块 $x_v \\in \\mathbb{R}^{d_v}$。集合 $\\mathcal{L}$ 包含叶节点，$P(\\ell)$ 是从根到叶节点 $\\ell$ 的路径上的节点集合。参数 $\\lambda$ 和 $\\tau$ 是正常数。\n\n推导的核心在于重构惩罚项，以在变量块 $\\{x_v\\}_{v \\in \\mathcal{V}}$ 之间解耦优化问题。惩罚项涉及对叶节点及其祖先节点的双重求和。我们可以改变这个求和的顺序。我们可以遍历每个节点 $v \\in \\mathcal{V}$，并对其所属的每个叶路径的贡献求和，而不是遍历每个叶节点并对其祖先求和。\n\n让我们重写 $\\tau \\Phi(x)$ 项：\n$$\n\\tau \\Phi(x) = \\tau \\lambda \\sum_{\\ell \\in \\mathcal{L}} \\sum_{v \\in P(\\ell)} \\lVert x_v \\rVert_2.\n$$\n改变求和顺序得到：\n$$\n\\tau \\Phi(x) = \\tau \\lambda \\sum_{v \\in \\mathcal{V}} \\sum_{\\ell \\in \\mathcal{L} \\text{ s.t. } v \\in P(\\ell)} \\lVert x_v \\rVert_2.\n$$\n一个节点 $v$ 在到叶节点 $\\ell$ 的路径 $P(\\ell)$ 上，当且仅当 $\\ell$ 是以 $v$ 为根的子树中的一个叶节点。让我们定义 $c_v$ 为以节点 $v$ 为根的子树中的叶子数量。那么内部求和是 $c_v$ 个相同项 $\\lVert x_v \\rVert_2$ 的和：\n$$\n\\sum_{\\ell \\in \\mathcal{L} \\text{ s.t. } v \\in P(\\ell)} \\lVert x_v \\rVert_2 = c_v \\lVert x_v \\rVert_2.\n$$\n将其代回，惩罚项简化为：\n$$\n\\tau \\Phi(x) = \\tau \\lambda \\sum_{v \\in \\mathcal{V}} c_v \\lVert x_v \\rVert_2.\n$$\n现在，我们可以将这个简化的惩罚项代入目标函数 $F(x)$：\n$$\nF(x) = \\frac{1}{2} \\sum_{v \\in \\mathcal{V}} \\lVert x_v - y_v \\rVert_2^2 + \\tau \\lambda \\sum_{v \\in \\mathcal{V}} c_v \\lVert x_v \\rVert_2.\n$$\n我们可以按节点 $v$ 对各项进行重组：\n$$\nF(x) = \\sum_{v \\in \\mathcal{V}} \\left( \\frac{1}{2} \\lVert x_v - y_v \\rVert_2^2 + (\\tau \\lambda c_v) \\lVert x_v \\rVert_2 \\right).\n$$\n目标函数 $F(x)$ 已成功解耦为一系列独立函数的和，每个函数对应一个变量块 $x_v$。为了找到 $F(x)$ 的最小值，我们可以独立地最小化和中的每一项。对于每个节点 $v \\in \\mathcal{V}$，我们必须解决以下子问题：\n$$\nx_v^* = \\arg\\min_{x_v \\in \\mathbb{R}^{d_v}} \\left\\{ \\frac{1}{2} \\lVert x_v - y_v \\rVert_2^2 + (\\tau \\lambda c_v) \\lVert x_v \\rVert_2 \\right\\}.\n$$\n这是函数 $g(z) = \\alpha \\lVert z \\rVert_2$ 在点 $y_v$ 处的近端算子的标准定义，其中缩放因子为 $\\alpha_v = \\tau \\lambda c_v$。解由块软阈值算子给出：\n$$\nx_v^* = \\left( 1 - \\frac{\\tau \\lambda c_v}{\\lVert y_v \\rVert_2} \\right)_+ y_v,\n$$\n其中 $(a)_+ = \\max(a, 0)$。这个公式可以展开为：\n$$\nx_v^* = \\begin{cases} \\left( 1 - \\frac{\\tau \\lambda c_v}{\\lVert y_v \\rVert_2} \\right) y_v  \\text{if } \\lVert y_v \\rVert_2  \\tau \\lambda c_v \\\\ \\mathbf{0}  \\text{if } \\lVert y_v \\rVert_2 \\le \\tau \\lambda c_v \\end{cases}\n$$\n其中 $\\mathbf{0}$ 是 $\\mathbb{R}^{d_v}$ 中的零向量。\n\n为了实现这个解法，我们首先需要计算所有 $v \\in \\mathcal{V}$ 的叶子计数 $c_v$。这些计数可以使用树上的动态规划高效地计算。节点 $v$ 的值 $c_v$ 由其子节点 $\\mathrm{ch}(v)$ 的计数决定。\n$c_v$ 的递归如下：\n1.  **基本情况**：如果节点 $v$ 是一个叶节点（即 $\\mathrm{ch}(v) = \\emptyset$），则以 $v$ 为根的子树只包含一个叶节点，即 $v$ 本身。因此，$c_v = 1$。\n2.  **递归步骤**：如果节点 $v$ 不是叶节点，其子树中的叶节点集合是其子节点子树中叶节点集合的不交并集。因此，总计数是其子节点计数的总和：\n    $$\n    c_v = \\sum_{u \\in \\mathrm{ch}(v)} c_u.\n    $$\n这个递归可以通过对树进行一次后序遍历（即从叶节点到根节点的自底向上遍历）来解决。对于每个节点 $v$，我们首先递归地计算其所有子节点 $u \\in \\mathrm{ch}(v)$ 的计数，然后使用上述公式计算 $c_v$。这需要 $\\mathcal{O}(|\\mathcal{V}|) = \\mathcal{O}(n)$ 的时间。\n\n计算 $\\operatorname{prox}_{\\tau \\Phi}(y)$ 的完整算法如下：\n1.  使用树的后序遍历为所有 $v \\in \\mathcal{V}$ 计算叶子计数 $c_v$。这可以通过带记忆化的递归函数实现，需要 $\\mathcal{O}(n)$ 的时间。\n2.  对于每个节点 $v \\in \\mathcal{V}$，使用其特定的阈值 $\\alpha_v = \\tau \\lambda c_v$ 和块软阈值公式计算最优块 $x_v^*$。这涉及计算 $y_v$ 的 $\\ell_2$-范数并应用收缩公式，所需时间与块维度 $d_v$ 成正比。\n总时间复杂度是叶子计数计算和分块更新时间的总和，即 $\\mathcal{O}(n + \\sum_{v \\in \\mathcal{V}} d_v)$。假设块维度很小且可视为常数，则复杂度为 $\\mathcal{O}(n)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the proximal problem for all specified test cases.\n    \"\"\"\n    \n    # Test case 1: chain tree\n    tc1_children = [[1], [2], [3], []]\n    tc1_y_blocks = [np.array([0.6, -0.8]), np.array([0.1, 0.0]), np.array([0.0, 0.0]), np.array([3.0, 4.0])]\n    tc1_lambda = 0.5\n    tc1_tau = 0.5\n\n    # Test case 2: star tree\n    tc2_children = [[1, 2, 3], [], [], []]\n    tc2_y_blocks = [np.array([1.0, 0.0, 0.0]), np.array([0.3]), np.array([0.0]), np.array([0.5])]\n    tc2_lambda = 0.4\n    tc2_tau = 1.0\n\n    # Test case 3: balanced binary tree\n    tc3_children = [[1, 2], [3, 4], [5, 6], [], [], [], []]\n    tc3_y_blocks = [\n        np.array([0.5, 0.5]), np.array([1.2, 0.0]), np.array([0.0, 0.9]),\n        np.array([0.2]), np.array([1.0]), np.array([0.1]), np.array([0.0])\n    ]\n    tc3_lambda = 0.2\n    tc3_tau = 1.5\n\n    # Test case 4: single node tree\n    tc4_children = [[]]\n    tc4_y_blocks = [np.array([0.3, -0.4, 0.0])]\n    tc4_lambda = 0.7\n    tc4_tau = 0.5\n\n    test_cases = [\n        (tc1_children, tc1_y_blocks, tc1_lambda, tc1_tau),\n        (tc2_children, tc2_y_blocks, tc2_lambda, tc2_tau),\n        (tc3_children, tc3_y_blocks, tc3_lambda, tc3_tau),\n        (tc4_children, tc4_y_blocks, tc4_lambda, tc4_tau),\n    ]\n\n    results = []\n    \n    def compute_leaf_counts(children):\n        \"\"\"\n        Computes the number of leaves in the subtree of each node\n        using a post-order traversal (recursive DFS with memoization).\n        \"\"\"\n        num_nodes = len(children)\n        counts = -1 * np.ones(num_nodes, dtype=int)\n\n        def dfs(node_idx):\n            # If already computed, return the stored value\n            if counts[node_idx] != -1:\n                return counts[node_idx]\n\n            node_children = children[node_idx]\n            # Base case: if the node is a leaf\n            if not node_children:\n                counts[node_idx] = 1\n                return 1\n\n            # Recursive step: sum of leaf counts of children\n            current_count = 0\n            for child_idx in node_children:\n                current_count += dfs(child_idx)\n            \n            counts[node_idx] = current_count\n            return current_count\n\n        # The tree is rooted at index 0\n        dfs(0)\n        return counts\n\n    for case in test_cases:\n        children, y_blocks, lambda_val, tau_val = case\n        num_nodes = len(children)\n        \n        # Step 1: Compute leaf counts c_v for all nodes v\n        leaf_counts = compute_leaf_counts(children)\n        \n        # Step 2: Compute the proximal map for each block\n        x_blocks_result = []\n        for v in range(num_nodes):\n            y_v = y_blocks[v]\n            c_v = leaf_counts[v]\n            \n            # Compute the threshold T_v = tau * lambda * c_v\n            threshold = tau_val * lambda_val * c_v\n            \n            # Compute the L2 norm of the observation block y_v\n            norm_y_v = np.linalg.norm(y_v)\n            \n            # Apply the block soft-thresholding formula\n            if norm_y_v > threshold:\n                shrinkage_factor = 1.0 - threshold / norm_y_v\n                x_v = shrinkage_factor * y_v\n            else:\n                x_v = np.zeros_like(y_v)\n            \n            x_blocks_result.append(x_v)\n        \n        # Flatten the list of result blocks into a single list of floats\n        if x_blocks_result:\n            flat_result = np.concatenate(x_blocks_result).tolist()\n        else:\n            flat_result = []\n            \n        results.append(flat_result)\n\n    # Format the final output exactly as specified\n    # The string representation of a Python list of floats is used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "父节点闭合特性可以通过整数变量进行精确建模，但这通常会导致计算上难以处理的混合整数规划问题。一种常见的策略是使用凸罚项来代替，这种罚项旨在鼓励而非严格强制该结构。本练习通过一个具体的计算实例，对精确的混合整数公式与其凸松弛版本进行比较，最终计算“积分间隙”（integrality gap），从而量化了进行凸化所需付出的代价。",
            "id": "3494193",
            "problem": "考虑一个一维正交小波变换，其小波系数上有一个有根二叉树，该树编码了规范的父节点闭合性（如果一个子系数被激活，那么其父系数也必须被激活）。设该树由一个索引为 $0$ 的根节点和两个索引为 $1$ 和 $2$ 的子节点组成。假设测量值已在小波域中（因此变换矩阵为单位矩阵），并且我们寻求系数 $x \\in \\mathbb{R}^{3}$，以在平方数据保真度与树结构模型选择成本之间进行权衡。\n\n从以下基本要素开始：\n- 小波变换是正交的，因此在小波域中，标准的最小二乘数据保真度为 $\\frac{1}{2}\\|x - y\\|_{2}^{2}$。\n- 父节点闭合性可以通过二元激活变量 $z_{j} \\in \\{0,1\\}$ 以及约束 $z_{1} \\leq z_{0}$ 和 $z_{2} \\leq z_{0}$ 来精确强制执行。\n- 激活与系数大小之间的联系可以用一个大M约束 $|x_{j}| \\leq M z_{j}$ 来表示，其中 $M  0$ 是用户指定的上界。\n- 混合整数二次规划（MIQP）的目标函数可以通过每节点成本 $\\lambda z_{j}$ 来惩罚激活。\n\n使用具体实例，其中 $M = 1$，$\\lambda = 0.12$，数据为 $y = (y_{0}, y_{1}, y_{2}) = (0.1, 0.7, 0.7)$。\n\n任务：\n1. 为此实例构建精确的混合离散-连续公式，该公式通过二元变量强制执行父节点闭合性。您的公式必须包括数据保真度项 $\\frac{1}{2}\\sum_{j=0}^{2}(x_{j} - y_{j})^{2}$、激活惩罚项 $\\lambda \\sum_{j=0}^{2} z_{j}$、大M联系 $|x_{j}| \\leq M z_{j}$、二元约束 $z_{j} \\in \\{0,1\\}$ 以及父节点闭合性约束 $z_{1} \\leq z_{0}$ 和 $z_{2} \\leq z_{0}$。\n2. 将二元约束松弛到区间 $z_{j} \\in [0,1]$ 以获得凸松弛。以闭式形式消去变量 $x_{j}$，从而得到一个仅包含连续变量 $z_{j}$ 的等价凸目标函数。利用父节点闭合性意味着 $z_{0} \\geq \\max\\{z_{1}, z_{2}\\}$ 这一事实来简化父节点的贡献。\n3. 计算此实例的精确混合整数模型的最优目标值。\n4. 计算此实例的凸松弛的最优目标值。\n5. 将此最小化问题的整数差距定义为 $G = \\frac{p_{\\mathrm{MIP}}}{p_{\\mathrm{REL}}}$，其中 $p_{\\mathrm{MIP}}$ 是精确混合整数规划的最优目标值，$p_{\\mathrm{REL}}$ 是凸松弛的最优目标值。为此实例精确计算 $G$。\n\n将您的最终答案以单个实数（无单位）的形式给出。不要四舍五入；以化简分数或闭式表达式的形式报告精确值。",
            "solution": "该问题提法明确，具有科学依据，并为获得唯一解提供了所有必要信息。我们验证问题并按顺序解决五个任务。\n\n给定参数如下：\n- 数据向量：$y = (y_{0}, y_{1}, y_{2}) = (0.1, 0.7, 0.7)$。\n- 大M常数：$M=1$。\n- 正则化参数：$\\lambda = 0.12$。\n- 小波变换是单位变换，因此我们直接处理系数 $x \\in \\mathbb{R}^{3}$。\n- 树结构意味着父子关系 $(0,1)$ 和 $(0,2)$。\n\n### 任务1：混合整数二次规划（MIQP）公式\n\n目标函数结合了平方 $\\ell_2$ 数据保真度项和对激活系数数量的惩罚项。约束条件强制执行父节点闭合的树结构，并将连续系数 $x_j$ 与二元激活变量 $z_j$ 联系起来。\n\n通用公式为：\n$$ \\min_{x \\in \\mathbb{R}^{3}, z \\in \\{0,1\\}^{3}} \\quad \\frac{1}{2}\\sum_{j=0}^{2}(x_{j} - y_{j})^{2} + \\lambda \\sum_{j=0}^{2} z_{j} $$\n约束条件：\n$$ |x_{j}| \\leq M z_{j} \\quad \\text{for } j \\in \\{0, 1, 2\\} $$\n$$ z_{1} \\leq z_{0} $$\n$$ z_{2} \\leq z_{0} $$\n\n代入具体实例值 ($y_{0}=0.1, y_{1}=0.7, y_{2}=0.7, M=1, \\lambda=0.12$)：\n$$ \\min_{x, z} \\quad \\frac{1}{2}\\left((x_{0} - 0.1)^{2} + (x_{1} - 0.7)^{2} + (x_{2} - 0.7)^{2}\\right) + 0.12(z_{0} + z_{1} + z_{2}) $$\n约束条件：\n$$ |x_{0}| \\leq z_{0} $$\n$$ |x_{1}| \\leq z_{1} $$\n$$ |x_{2}| \\leq z_{2} $$\n$$ z_{1} \\leq z_{0} $$\n$$ z_{2} \\leq z_{0} $$\n$$ z_{0}, z_{1}, z_{2} \\in \\{0, 1\\} $$\n\n### 任务2：凸松弛与变量消去\n\n我们通过将二元约束 $z_{j} \\in \\{0,1\\}$ 松弛为连续约束 $z_{j} \\in [0,1]$ 来获得凸松弛。目标函数可以重构为首先在固定 $z$ 的情况下对 $x$ 进行最小化，然后再对 $z$ 进行最小化。\n$$ \\min_{z \\in [0,1]^3} \\left( \\lambda \\sum_{j=0}^{2} z_{j} + \\sum_{j=0}^{2} \\min_{x_j, |x_j| \\le Mz_j} \\frac{1}{2}(x_j-y_j)^2 \\right) $$\n对每个系数 $x_j$ 的内部最小化是 $y_j$ 在区间 $[-Mz_j, Mz_j]$ 上的投影。解为 $x_j^* = \\text{sgn}(y_j)\\min(|y_j|, Mz_j)$。这个内部最小化的值为 $\\frac{1}{2}(x_j^*-y_j)^2$，可以简化为 $\\frac{1}{2}\\max(0, |y_j| - Mz_j)^2$。\n\n将其代回目标函数，我们得到一个只关于 $z$ 的凸问题：\n$$ \\min_{z \\in [0,1]^3} \\quad \\lambda \\sum_{j=0}^{2} z_{j} + \\frac{1}{2}\\sum_{j=0}^{2} \\max(0, |y_j| - Mz_j)^2 $$\n约束条件为父节点闭合性约束 $z_{1} \\leq z_{0}$ 和 $z_{2} \\leq z_{0}$。\n\n对于我们的具体实例，这变成：\n$$ \\min_{z_{0},z_{1},z_{2}} \\quad 0.12(z_{0}+z_{1}+z_{2}) + \\frac{1}{2}\\max(0, 0.1-z_{0})^{2} + \\frac{1}{2}\\max(0, 0.7-z_{1})^{2} + \\frac{1}{2}\\max(0, 0.7-z_{2})^{2} $$\n约束条件：\n$$ z_{1} \\leq z_{0} $$\n$$ z_{2} \\leq z_{0} $$\n$$ z_{0}, z_{1}, z_{2} \\in [0,1] $$\n父节点对目标的贡献是项 $0.12 z_{0} + \\frac{1}{2}\\max(0, 0.1-z_{0})^{2}$。父节点闭合性约束 $z_{0} \\geq \\max\\{z_1, z_2\\}$作为优化变量的约束来处理。\n\n### 任务3：MIQP的最优值 ($p_{\\mathrm{MIP}}$)\n\n我们对所有满足父节点闭合性约束 $z_1 \\le z_0$ 和 $z_2 \\le z_0$ 的二元变量 $z_j$ 的有效组合，计算MIQP目标函数的值。对于每个固定的 $z$，最优的 $x_j$ 是 $\\text{sgn}(y_j)\\min(|y_j|, z_j)$。\n\n1.  $(z_{0},z_{1},z_{2})=(0,0,0)$: $x=(0,0,0)$。目标值：$\\frac{1}{2}((0-0.1)^2 + (0-0.7)^2 + (0-0.7)^2) + 0 = \\frac{1}{2}(0.01+0.49+0.49) = 0.495$。\n2.  $(z_{0},z_{1},z_{2})=(1,0,0)$: $x=(0.1,0,0)$。目标值：$\\frac{1}{2}(0 + (0-0.7)^2 + (0-0.7)^2) + 0.12(1) = 0.49 + 0.12 = 0.61$。\n3.  $(z_{0},z_{1},z_{2})=(1,1,0)$: $x=(0.1,0.7,0)$。目标值：$\\frac{1}{2}(0 + 0 + (0-0.7)^2) + 0.12(2) = 0.245+0.24 = 0.485$。\n4.  $(z_{0},z_{1},z_{2})=(1,0,1)$: $x=(0.1,0,0.7)$。根据与前一情况的对称性，目标值为 $0.485$。\n5.  $(z_{0},z_{1},z_{2})=(1,1,1)$: $x=(0.1,0.7,0.7)$。数据保真度项为 $0$。目标值：$0.12(3) = 0.36$。\n\n比较这些值：$\\{0.495, 0.61, 0.485, 0.36\\}$。最小值是 $0.36$。\n因此，混合整数规划的最优值为 $p_{\\mathrm{MIP}} = 0.36 = \\frac{9}{25}$。\n\n### 任务4：凸松弛的最优值 ($p_{\\mathrm{REL}}$)\n\n我们必须解决任务2中的凸规划问题。由于目标函数和约束关于 $z_1$ 和 $z_2$ 是对称的，最优解将有 $z_1^*=z_2^*$。设这个公共值为 $z_c$。问题简化为：\n$$ \\min_{z_0, z_c} \\quad p(z_0, z_c) = 0.12 z_0 + 0.24 z_c + \\frac{1}{2}\\max(0, 0.1-z_0)^2 + \\max(0, 0.7-z_c)^2 $$\n约束条件为 $0 \\leq z_c \\leq z_0 \\leq 1$。\n\n目标函数的梯度在可行域内部非零，因此最小值必定位于边界上。我们检查边界线 $z_c = z_0 = z$ (对于 $z \\in [0,1]$)。目标函数变成单个变量 $z$ 的函数：\n$$ g(z) = 0.36z + \\frac{1}{2}\\max(0, 0.1-z)^2 + \\max(0, 0.7-z)^2 $$\n我们分段分析：\n- 对于 $z \\in [0.1, 0.7)$，目标函数为 $g(z) = 0.36z + (0.7-z)^2 = z^2 - 1.04z + 0.49$。\n导数为 $g'(z) = 2z - 1.04$。令 $g'(z)=0$ 得到 $z = 0.52$。这个点位于区间 $[0.1, 0.7)$ 内，是最小值的候选点。\n值为 $g(0.52) = (0.52)^2 - 1.04(0.52) + 0.49 = 0.2704 - 0.5408 + 0.49 = 0.2196$。\n- 对于 $z \\geq 0.7$，$g(z) = 0.36z$，在 $z=0.7$ 处取最小值，得到 $g(0.7)=0.36(0.7)=0.252$。\n- 对于 $z  0.1$，$g(z)$ 的导数始终为负，因此函数向 $z=0.1$ 递减。\n\n在直线 $z_c=z_0=z$ 上的最小值出现在 $z=0.52$。可以通过检查完整三变量问题的Karush-Kuhn-Tucker (KKT) 条件来验证点 $(z_0, z_1, z_2) = (0.52, 0.52, 0.52)$ 是全局最小值。\n\n我们现在计算在 $z_0=z_1=z_2=0.52 = \\frac{13}{25}$ 时的最优值 $p_{\\mathrm{REL}}$。\n$$ p_{\\mathrm{REL}} = 0.12(3 \\times 0.52) + \\frac{1}{2}\\max(0, 0.1-0.52)^2 + 2 \\times \\frac{1}{2}\\max(0, 0.7-0.52)^2 $$\n$$ p_{\\mathrm{REL}} = 0.36(0.52) + 0 + (0.7-0.52)^2 = 0.1872 + (0.18)^2 = 0.1872 + 0.0324 = 0.2196 $$\n以分数形式表示，$z^* = \\frac{13}{25}$ 且 $\\lambda=\\frac{3}{25}$。\n$$ p_{\\mathrm{REL}} = 3 \\lambda z^* + (y_1-z^*)^2 = 3\\left(\\frac{3}{25}\\right)\\left(\\frac{13}{25}\\right) + \\left(\\frac{7}{10}-\\frac{13}{25}\\right)^2 = \\frac{117}{625} + \\left(\\frac{35-26}{50}\\right)^2 $$\n$$ p_{\\mathrm{REL}} = \\frac{117}{625} + \\left(\\frac{9}{50}\\right)^2 = \\frac{117}{625} + \\frac{81}{2500} = \\frac{468+81}{2500} = \\frac{549}{2500} $$\n\n### 任务5：整数差距 ($G$)\n\n此最小化问题的整数差距定义为 $G = \\frac{p_{\\mathrm{MIP}}}{p_{\\mathrm{REL}}}$。\n使用精确的分数值：\n$$ p_{\\mathrm{MIP}} = \\frac{9}{25} $$\n$$ p_{\\mathrm{REL}} = \\frac{549}{2500} $$\n差距为：\n$$ G = \\frac{9/25}{549/2500} = \\frac{9}{25} \\times \\frac{2500}{549} = 9 \\times \\frac{100}{549} $$\n我们观察到 $5+4+9=18$，所以 $549$ 可以被 $9$ 整除。实际上，$549 \\div 9 = 61$。\n$$ G = \\frac{9 \\times 100}{9 \\times 61} = \\frac{100}{61} $$\n这是一个最简分数，因为 $61$ 是一个素数。",
            "answer": "$$\\boxed{\\frac{100}{61}}$$"
        }
    ]
}