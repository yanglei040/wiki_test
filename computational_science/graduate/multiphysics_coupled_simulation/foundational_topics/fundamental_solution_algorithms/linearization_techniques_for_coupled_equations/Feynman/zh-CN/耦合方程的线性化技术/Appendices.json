{
    "hands_on_practices": [
        {
            "introduction": "掌握耦合系统的牛顿-拉夫逊方法，始于精通单次迭代的计算。本练习将这一过程分解为核心步骤，旨在通过一个简洁的二维热力学耦合玩具模型，让您亲手计算雅可比矩阵、求解修正量，并更新解向量。通过这个基础练习 ，您将为理解和实现更复杂的非线性求解器奠定坚实的数学基础。",
            "id": "3512855",
            "problem": "考虑一个耦合热力学玩具模型的无量纲双场残差向量，定义为\n$$\nR(U) \\equiv \\begin{bmatrix} R_{1}(T,u) \\\\ R_{2}(T,u) \\end{bmatrix}\n= \\begin{bmatrix} \\sin(T) + \\alpha\\, u \\\\ u^{3} - T \\end{bmatrix},\n$$\n其中 $U \\equiv \\begin{bmatrix} T \\\\ u \\end{bmatrix}$，标量参数 $\\alpha \\in \\mathbb{R}$ 代表耦合强度，且所有量均为无量纲。假设 $\\alpha \\neq -3$ 以避免在所关注的状态下出现奇异雅可比矩阵。设当前迭代值为 $U^{(k)} = \\begin{bmatrix} T^{(k)} \\\\ u^{(k)} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$，牛顿更新的阻尼因子为 $\\lambda \\in (0,1]$。\n\n从残差在 $U^{(k)}$ 处的一阶泰勒线性化和耦合系统的牛顿步长定义出发，在 $U^{(k)}$ 处执行一次阻尼牛顿迭代，以计算：\n- 雅可比矩阵 $J(U^{(k)}) \\equiv \\dfrac{\\partial R}{\\partial U}\\big|_{U^{(k)}}$，\n- 牛顿增量 $\\Delta U$，其解为 $J(U^{(k)})\\,\\Delta U = -R(U^{(k)})$，\n- 阻尼更新 $U^{+} = U^{(k)} + \\lambda\\, \\Delta U$。\n\n将你的最终答案以行向量的形式报告\n$$\n\\big(J_{11},\\, J_{12},\\, J_{21},\\, J_{22},\\, \\Delta T,\\, \\Delta u,\\, T^{+},\\, u^{+}\\big),\n$$\n其中 $J_{ij}$ 是 $J(U^{(k)})$ 的元素，而 $\\Delta T$、$\\Delta u$、$T^{+}$、 $u^{+}$ 分别是 $\\Delta U$ 和 $U^{+}$ 的分量。无需四舍五入。请用 $\\alpha$ 和 $\\lambda$ 的符号形式表示你的答案。",
            "solution": "首先验证问题，以确保其自洽、科学上合理且适定。\n\n### 步骤 1：提取已知条件\n- **残差向量**：$R(U) \\equiv \\begin{bmatrix} R_{1}(T,u) \\\\ R_{2}(T,u) \\end{bmatrix} = \\begin{bmatrix} \\sin(T) + \\alpha\\, u \\\\ u^{3} - T \\end{bmatrix}$\n- **状态向量**：$U \\equiv \\begin{bmatrix} T \\\\ u \\end{bmatrix}$\n- **耦合参数**：$\\alpha \\in \\mathbb{R}$\n- **约束条件**：$\\alpha \\neq -3$\n- **当前迭代值**：$U^{(k)} = \\begin{bmatrix} T^{(k)} \\\\ u^{(k)} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$\n- **阻尼因子**：$\\lambda \\in (0,1]$\n- **任务**：计算雅可比矩阵 $J(U^{(k)})$、牛顿增量 $\\Delta U$ 以及阻尼更新 $U^{+} = U^{(k)} + \\lambda\\,\\Delta U$。\n- **要求的输出**：行向量 $\\big(J_{11},\\, J_{12},\\, J_{21},\\, J_{22},\\, \\Delta T,\\, \\Delta u,\\, T^{+},\\, u^{+}\\big)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是应用牛顿法求解非线性方程组的标准练习，这是数值分析和计算科学中的一个基本课题。\n- **科学/事实合理性**：该问题在数学上是合理的。它采用了已确立的概念：向量函数、偏导数、泰勒级数线性化以及用于求根的牛顿法。\n- **适定性**：该问题是适定的。它提供了所有必要的函数、常数和初始值。约束条件 $\\alpha \\neq -3$ 至关重要，因为它确保了雅可比矩阵在给定点是可逆的，从而保证了牛顿步长的唯一解。\n- **客观性**：该问题使用精确、客观的数学语言陈述。\n- **结论**：该问题是有效的。没有缺陷。\n\n### 步骤 3：判定与操作\n该问题有效。解法如下。\n\n牛顿法求解方程组的核心是求解线性系统 $J(U^{(k)}) \\Delta U = -R(U^{(k)})$，其中 $J$ 是残差向量 $R$ 的雅可比矩阵。\n\n**1. 计算雅可比矩阵**\n雅可比矩阵 $J(U)$ 是残差向量 $R(U)$ 的所有一阶偏导数组成的矩阵。\n$$\nJ(U) = \\frac{\\partial R}{\\partial U} = \\begin{bmatrix} \\frac{\\partial R_1}{\\partial T} & \\frac{\\partial R_1}{\\partial u} \\\\ \\frac{\\partial R_2}{\\partial T} & \\frac{\\partial R_2}{\\partial u} \\end{bmatrix}\n$$\n给定 $R_1(T,u) = \\sin(T) + \\alpha u$ 和 $R_2(T,u) = u^3 - T$，其偏导数为：\n- $\\frac{\\partial R_1}{\\partial T} = \\cos(T)$\n- $\\frac{\\partial R_1}{\\partial u} = \\alpha$\n- $\\frac{\\partial R_2}{\\partial T} = -1$\n- $\\frac{\\partial R_2}{\\partial u} = 3u^2$\n\n因此，雅可比矩阵为：\n$$\nJ(T,u) = \\begin{bmatrix} \\cos(T) & \\alpha \\\\ -1 & 3u^2 \\end{bmatrix}\n$$\n\n**2. 在当前迭代值 $U^{(k)}$ 处计算雅可比矩阵**\n我们在点 $U^{(k)} = (T^{(k)}, u^{(k)}) = (0, 1)$ 处计算 $J(T,u)$。\n$$\nJ(U^{(k)}) = J(0,1) = \\begin{bmatrix} \\cos(0) & \\alpha \\\\ -1 & 3(1)^2 \\end{bmatrix} = \\begin{bmatrix} 1 & \\alpha \\\\ -1 & 3 \\end{bmatrix}\n$$\n该矩阵的分量是最终答案的前四个元素：\n- $J_{11} = 1$\n- $J_{12} = \\alpha$\n- $J_{21} = -1$\n- $J_{22} = 3$\n\n**3. 在当前迭代值 $U^{(k)}$ 处计算残差**\n我们在点 $U^{(k)} = (0, 1)$ 处计算 $R(U)$。\n$$\nR(U^{(k)}) = R(0,1) = \\begin{bmatrix} \\sin(0) + \\alpha(1) \\\\ (1)^3 - 0 \\end{bmatrix} = \\begin{bmatrix} \\alpha \\\\ 1 \\end{bmatrix}\n$$\n\n**4. 求解牛顿增量 $\\Delta U$**\n需要求解的线性系统是 $J(U^{(k)})\\,\\Delta U = -R(U^{(k)})$，其中 $\\Delta U = \\begin{bmatrix} \\Delta T \\\\ \\Delta u \\end{bmatrix}$。\n$$\n\\begin{bmatrix} 1 & \\alpha \\\\ -1 & 3 \\end{bmatrix} \\begin{bmatrix} \\Delta T \\\\ \\Delta u \\end{bmatrix} = -\\begin{bmatrix} \\alpha \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} -\\alpha \\\\ -1 \\end{bmatrix}\n$$\n为求解这个 $2 \\times 2$ 系统，我们计算雅可比矩阵的逆。$J(U^{(k)})$ 的行列式是：\n$$\n\\det(J(U^{(k)})) = (1)(3) - (\\alpha)(-1) = 3 + \\alpha\n$$\n条件 $\\alpha \\neq -3$ 确保了 $\\det(J(U^{(k)})) \\neq 0$，因此该矩阵是可逆的。其逆矩阵为：\n$$\n[J(U^{(k)})]^{-1} = \\frac{1}{3+\\alpha} \\begin{bmatrix} 3 & -\\alpha \\\\ 1 & 1 \\end{bmatrix}\n$$\n现在，我们将线性系统两边同时乘以雅可比矩阵的逆来求得 $\\Delta U$：\n$$\n\\Delta U = [J(U^{(k)})]^{-1} (-R(U^{(k)})) = \\frac{1}{3+\\alpha} \\begin{bmatrix} 3 & -\\alpha \\\\ 1 & 1 \\end{bmatrix} \\begin{bmatrix} -\\alpha \\\\ -1 \\end{bmatrix}\n$$\n执行矩阵-向量乘法：\n$$\n\\begin{bmatrix} \\Delta T \\\\ \\Delta u \\end{bmatrix} = \\frac{1}{3+\\alpha} \\begin{bmatrix} (3)(-\\alpha) + (-\\alpha)(-1) \\\\ (1)(-\\alpha) + (1)(-1) \\end{bmatrix} = \\frac{1}{3+\\alpha} \\begin{bmatrix} -3\\alpha + \\alpha \\\\ -\\alpha - 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{-2\\alpha}{3+\\alpha} \\\\ \\frac{-(\\alpha+1)}{3+\\alpha} \\end{bmatrix}\n$$\n牛顿增量的分量是：\n- $\\Delta T = \\frac{-2\\alpha}{3+\\alpha}$\n- $\\Delta u = -\\frac{\\alpha+1}{3+\\alpha}$\n\n**5. 计算阻尼更新 $U^{+}$**\n新状态 $U^{+}$ 使用阻尼更新规则计算：$U^{+} = U^{(k)} + \\lambda \\Delta U$。\n$$\nU^{+} = \\begin{bmatrix} T^{+} \\\\ u^{+} \\end{bmatrix} = \\begin{bmatrix} T^{(k)} \\\\ u^{(k)} \\end{bmatrix} + \\lambda \\begin{bmatrix} \\Delta T \\\\ \\Delta u \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} + \\lambda \\begin{bmatrix} \\frac{-2\\alpha}{3+\\alpha} \\\\ -\\frac{\\alpha+1}{3+\\alpha} \\end{bmatrix}\n$$\n更新后状态的分量是：\n- $T^{+} = 0 + \\lambda \\left( \\frac{-2\\alpha}{3+\\alpha} \\right) = \\frac{-2\\lambda\\alpha}{3+\\alpha}$\n- $u^{+} = 1 + \\lambda \\left( -\\frac{\\alpha+1}{3+\\alpha} \\right) = 1 - \\frac{\\lambda(\\alpha+1)}{3+\\alpha} = \\frac{3+\\alpha - \\lambda\\alpha - \\lambda}{3+\\alpha} = \\frac{3-\\lambda + \\alpha(1-\\lambda)}{3+\\alpha}$\n\n**6. 组合最终答案**\n最终答案是行向量 $\\big(J_{11}, J_{12}, J_{21}, J_{22}, \\Delta T, \\Delta u, T^{+}, u^{+}\\big)$。汇总所有计算出的分量：\n- $J_{11} = 1$\n- $J_{12} = \\alpha$\n- $J_{21} = -1$\n- $J_{22} = 3$\n- $\\Delta T = \\frac{-2\\alpha}{3+\\alpha}$\n- $\\Delta u = -\\frac{\\alpha+1}{3+\\alpha}$\n- $T^{+} = \\frac{-2\\lambda\\alpha}{3+\\alpha}$\n- $u^{+} = \\frac{3-\\lambda + \\alpha(1-\\lambda)}{3+\\alpha}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & \\alpha & -1 & 3 & \\frac{-2\\alpha}{3+\\alpha} & -\\frac{\\alpha+1}{3+\\alpha} & \\frac{-2\\lambda\\alpha}{3+\\alpha} & \\frac{3-\\lambda + \\alpha(1-\\lambda)}{3+\\alpha} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "从单个代数步骤过渡到求解完整的非线性偏微分方程（PDE）系统，是理论联系实际的关键一步。本练习将指导您实现皮卡（Picard）迭代（一种常见且直观的定点线性化方法）来求解一个耦合的PDE模型。您将亲手进行方程离散化、构建线性子问题并观察迭代收敛过程 ，从而获得构建基本多物理场求解器的宝贵实践经验。",
            "id": "3512832",
            "problem": "考虑一个在一维区间 $[0,1]$ 上具有狄利克雷边界条件的稳态双场多物理场模型。该耦合系统由一个具有温度相关热导率的热传导方程和一个具有温度相关迁移率的类扩散方程组成。从散度形式的偏微分方程（Partial Differential Equations, PDE）出发，一维空间维度 $x$ 上的控制方程为\n$$\n-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right) = q(u), \\quad \\frac{d}{dx}\\left(C(T)\\frac{du}{dx}\\right) = 0,\n$$\n其中 $T(x)$ 是温度，$u(x)$ 是第二个场（例如，浓度或电势），$k(T)$ 是一个正的热导率，$C(T)$ 是一个正的迁移率，$q(u)$ 是一个源项。这些方程将通过皮卡（不动点）方法进行线性化和求解：对于皮卡迭代指数 $k=0,1,2,\\ldots$，通过将非线性系数和源项冻结在先前迭代 $(T^k,u^k)$ 的值来计算 $(T^{k+1},u^{k+1})$，即\n$$\n-\\frac{d}{dx}\\left(k(T^k)\\frac{d T^{k+1}}{dx}\\right) = q(u^k), \\quad \\frac{d}{dx}\\left(C(T^k)\\frac{d u^{k+1}}{dx}\\right) = 0.\n$$\n这样，在每次皮卡迭代中，会产生两个线性子问题，它们仅通过冻结在先前迭代的系数进行耦合。您的任务是以一种鲁棒且自洽的方式实现这种皮卡迭代，使用二阶有限差分法在均匀网格上离散化空间算子，并在每次迭代中求解所得到的三对角线性系统。\n\n设计基本依据：\n- 基于守恒定律的散度形式被用来构建跨单元面的离散通量。\n- 在光滑性假设下，有限差分法使用二阶中心差分来近似空间导数，并通过消除边界未知数来强制执行狄利克雷边界条件。\n\n离散化要求：\n- 使用具有 $N$ 个内部节点的均匀网格，间距 $h=1/(N+1)$，内部网格点为 $x_i = i h$，$i = 1,\\ldots,N$。\n- 对于可变系数，使用面心算术平均值来离散化散度形式：\n$$\nk_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(k(T_i^k) + k(T_{i+1}^k)\\right), \\quad C_{i+\\frac{1}{2}} = \\frac{1}{2}\\left(C(T_i^k) + C(T_{i+1}^k)\\right),\n$$\n其中边界面在需要时使用 $T$ 的边界值。\n- 每个子问题的线性算子必须组装成与离散散度算子一致的三对角形式，并通过将边界贡献移至右侧来施加狄利克雷边界条件。\n\n算法要求：\n- 在每次全局迭代中，为皮卡迭代实现两种耦合序列：\n  1. 先 $T$ 后 $u$ 序列：首先求解 $T$ 子问题，然后求解 $u$ 子问题。\n  2. 先 $u$ 后 $T$ 序列：首先求解 $u$ 子问题，然后求解 $T$ 子问题。\n- 在两种序列中，每个子问题都使用在先前迭代 $(T^k,u^k)$ 中冻结的系数和源项。\n- 使用 $T^0$ 和 $u^0$ 作为其各自边界值之间的线性插值作为初始猜测。\n- 停止准则由更新量的无穷范数定义：\n$$\n\\max\\left(\\|T^{k+1}-T^k\\|_{\\infty}, \\|u^{k+1}-u^k\\|_{\\infty}\\right)  \\varepsilon,\n$$\n并设置最大迭代次数 $k_{\\max}$ 以防止无限循环。\n\n所有测试用例共有的数值参数：\n- 使用 $N=50$ 个内部点。\n- 设置容差 $\\varepsilon = 10^{-8}$ (无量纲)。\n- 设置最大迭代次数 $k_{\\max}=200$。\n\n测试套件：\n为以下四个测试用例，在两种耦合序列下实现并运行皮卡迭代。在每个用例中，根据指定定义系数函数 $k(T)$、$C(T)$ 和 $q(u)$，以及狄利克雷边界值 $T(0)$、$T(1)$、$u(0)$、$u(1)$。确保在所提供的参数范围内，$k(T)0$ 和 $C(T)0$ 在定义域上成立。\n\n- 用例 1 (中等非线性，中等耦合)：\n  - $k(T) = 1 + 0.5\\,T$\n  - $C(T) = \\exp(0.3\\,T)$\n  - $q(u) = 0.1 + u^2$\n  - 边界：$T(0)=0$, $T(1)=1$; $u(0)=1$, $u(1)=0$\n\n- 用例 2 (常系数和零源；边界一致性)：\n  - $k(T) = 1$\n  - $C(T) = 1$\n  - $q(u) = 0$\n  - 边界：$T(0)=0$, $T(1)=0$; $u(0)=1$, $u(1)=1$\n\n- 用例 3 (强非线性，强耦合)：\n  - $k(T) = 0.5 + 5\\,T^2$\n  - $C(T) = 0.1 + 2\\,T$\n  - $q(u) = 0.5\\,u + 2\\,u^2$\n  - 边界：$T(0)=2$, $T(1)=0$; $u(0)=0$, $u(1)=1$\n\n- 用例 4 (迁移率非线性，源项为常数)：\n  - $k(T) = 2$\n  - $C(T) = 0.5 + 3\\,\\exp(T)$\n  - $q(u) = 0.2$\n  - 边界：$T(0)=0$, $T(1)=1$; $u(0)=0.5, u(1)=0.5$\n\n最终输出规范：\n- 对于每个用例，记录在两种耦合序列（先 $T$ 后 $u$ 和先 $u$ 后 $T$）下，达到停止准则（或达到 $k_{\\max}$）所执行的皮卡迭代次数。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按用例和序列排序：\n  $[n_{TU}^{(1)},n_{UT}^{(1)},n_{TU}^{(2)},n_{UT}^{(2)},n_{TU}^{(3)},n_{UT}^{(3)},n_{TU}^{(4)},n_{UT}^{(4)}]$,\n其中 $n_{TU}^{(j)}$ 是用例 $j$ 使用先 $T$ 后 $u$ 序列的迭代次数，$n_{UT}^{(j)}$ 是用例 $j$ 使用先 $u$ 后 $T$ 序列的迭代次数。所有条目必须是整数。",
            "solution": "所呈现的问题是一个有效、适定且自洽的陈述，描述了一个耦合多物理系统的数值解法。它基于连续介质力学（热传导、扩散）和数值分析（有限差分、迭代法）的标准原理。所有参数、方程、边界条件和算法要求都已足够精确地指定，以允许唯一且可验证的实现。\n\n问题的核心是使用不动点（皮卡）迭代方案在区域 $x \\in [0, 1]$ 上求解一个由两个耦合的非线性二阶常微分方程组成的系统。控制方程为：\n$$\n-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right) = q(u) \\quad \\text{(方程 T)}\n$$\n$$\n\\frac{d}{dx}\\left(C(T)\\frac{du}{dx}\\right) = 0 \\quad \\text{(方程 U)}\n$$\n两个场 $T(x)$ 和 $u(x)$ 均具有狄利克雷边界条件。\n\n皮卡迭代法通过在上一迭代的解处评估非线性系数和源项来线性化该系统。对于迭代 $k+1$，给定来自迭代 $k$ 的解 $(T^k, u^k)$，我们为 $(T^{k+1}, u^{k+1})$ 求解以下两个线性方程：\n$$\n-\\frac{d}{dx}\\left(k(T^k)\\frac{dT^{k+1}}{dx}\\right) = q(u^k) \\quad \\text{(线性化的 T-子问题)}\n$$\n$$\n-\\frac{d}{dx}\\left(C(T^k)\\frac{du^{k+1}}{dx}\\right) = 0 \\quad \\text{(线性化的 U-子问题)}\n$$\n请注意，我们已将方程 U 乘以 $-1$，以便将两个子问题都转换为类泊松方程的标准形式，这便于开发通用的离散化方法。\n\n该公式的一个关键方面是，两个线性化的子问题在单次迭代内是解耦的。$T^{k+1}$ 的方程仅依赖于上一次迭代的量 ($T^k, u^k$)，对于 $u^{k+1}$ 的方程也是如此。因此，求解这两个子问题的顺序——即所谓的“先 $T$ 后 $u$”和“先 $u$ 后 $T$”序列——对最终的解 $T^{k+1}$ 和 $u^{k+1}$ 没有影响。两种序列都将产生完全相同的迭代序列，因此会以完全相同的迭代次数收敛。这是皮卡（或类雅可比）方案的一个特性，与类高斯-赛德尔方案相反，后者会在同一次迭代中立即使用最新更新的信息。\n\n我们现在将为一个在具有 $N$ 个内部节点 $x_i = i h$（其中 $i=1,\\ldots,N$，$h=1/(N+1)$ 是网格间距）的均匀网格上的通用稳态散度形式扩散方程推导有限差分格式。通用方程为：\n$$\n-\\frac{d}{dx}\\left(A(x)\\frac{dy}{dx}\\right) = S(x)\n$$\n我们将此方程在以节点 $x_i$ 为中心的控制体积 $[x_{i-1/2}, x_{i+1/2}]$ 上积分，其中 $x_{i\\pm1/2} = x_i \\pm h/2$。这得到：\n$$\n-\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}\\left(A(x)\\frac{dy}{dx}\\right) dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} S(x) dx\n$$\n对左侧应用微积分基本定理，并近似右侧，我们得到：\n$$\n-\\left[A\\frac{dy}{dx}\\right]_{x_{i+1/2}} + \\left[A\\frac{dy}{dx}\\right]_{x_{i-1/2}} \\approx h S(x_i)\n$$\n单元面上的通量项使用二阶中心差分近似：\n$$\n\\left[A\\frac{dy}{dx}\\right]_{x_{i+1/2}} \\approx A(x_{i+1/2}) \\frac{y(x_{i+1}) - y(x_i)}{h}\n$$\n$$\n\\left[A\\frac{dy}{dx}\\right]_{x_{i-1/2}} \\approx A(x_{i-1/2}) \\frac{y(x_i) - y(x_{i-1})}{h}\n$$\n将这些代入积分方程并除以 $h$，得到节点 $i$ 处的离散方程：\n$$\n-\\frac{1}{h^2} \\left( A_{i+1/2}(y_{i+1} - y_i) - A_{i-1/2}(y_i - y_{i-1}) \\right) = S_i\n$$\n其中 $y_i \\approx y(x_i)$，$S_i = S(x_i)$，面系数 $A_{i\\pm1/2}$ 使用先前皮卡迭代中节点值的指定算术平均值进行评估。重新整理各项，我们得到节点 $i$ 的代数方程：\n$$\n-A_{i-1/2} y_{i-1} + (A_{i-1/2} + A_{i+1/2}) y_i - A_{i+1/2} y_{i+1} = h^2 S_i\n$$\n这个对于 $i=1, \\ldots, N$ 的方程组构成了一个三对角线性系统。边界条件 $y_0 = y(0)$ 和 $y_{N+1} = y(1)$ 通过将涉及这些已知值的项移动到节点 $i=1$ 和 $i=N$ 方程的右侧来并入。\n\n**应用于 T-子问题：**\n$T^{k+1}_i$ 的离散方程为：\n$$\n-k^k_{i-1/2} T^{k+1}_{i-1} + (k^k_{i-1/2} + k^k_{i+1/2}) T^{k+1}_i - k^k_{i+1/2} T^{k+1}_{i+1} = h^2 q(u^k_i)\n$$\n其中 $k^k_{i+1/2} = \\frac{1}{2}(k(T^k_i) + k(T^k_{i+1}))$。对于边界节点：\n- 对于 $i=1$：项 $-k^k_{1/2} T^{k+1}_0$ 变为一个已知值 $k^k_{1/2} T(0)$，加到右侧。\n- 对于 $i=N$：项 $-k^k_{N+1/2} T^{k+1}_{N+1}$ 变为 $k^k_{N+1/2} T(1)$，加到右侧。\n\n**应用于 U-子问题：**\n$u^{k+1}_i$ 的离散方程为：\n$$\n-C^k_{i-1/2} u^{k+1}_{i-1} + (C^k_{i-1/2} + C^k_{i+1/2}) u^{k+1}_i - C^k_{i+1/2} u^{k+1}_{i+1} = 0\n$$\n其中 $C^k_{i+1/2} = \\frac{1}{2}(C(T^k_i) + C(T^k_{i+1}))$。对于边界节点：\n- 对于 $i=1$：项 $-C^k_{1/2} u^{k+1}_0$ 变为 $C^k_{1/2} u(0)$，加到右侧。\n- 对于 $i=N$：项 $-C^k_{N+1/2} u^{k+1}_{N+1}$ 变为 $C^k_{N+1/2} u(1)$，加到右侧。\n\n总体算法如下：\n1.  初始化 $k=0$ 以及解向量 $T^0$ 和 $u^0$，作为它们各自边界值之间的线性插值。\n2.  开始迭代循环，重复直到收敛或 $k$ 达到 $k_{\\max}$。\n3.  在循环内部，使用来自 $T^k$ 的系数和来自 $u^k$ 的源项，构建并求解 $T^{k+1}$ 的三对角线性系统。\n4.  使用来自 $T^k$ 的系数，构建并求解 $u^{k+1}$ 的三对角线性系统。\n5.  计算更新量的无穷范数，$\\delta_T = \\|T^{k+1}-T^k\\|_{\\infty}$ 和 $\\delta_u = \\|u^{k+1}-u^k\\|_{\\infty}$。\n6.  如果 $\\max(\\delta_T, \\delta_u)  \\varepsilon$，则解已收敛。终止循环并记录迭代次数。\n7.  为下一次迭代更新解：$T^k \\leftarrow T^{k+1}$，$u^k \\leftarrow u^{k+1}$。\n\n为每个测试用例实施此过程，以确定收敛所需的迭代次数。三对角系统使用 `scipy.linalg.solve_banded` 高效求解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef picard_solver(k_func, C_func, q_func, T0, T1, u0, u1, N, epsilon, k_max):\n    \"\"\"\n    Solves the coupled 1D system using Picard iteration and finite differences.\n    \"\"\"\n    # 1. Grid and Initial Guess Setup\n    h = 1.0 / (N + 1)\n    x = np.linspace(0, 1, N + 2)\n\n    # Initialize full solution vectors (including boundaries)\n    T_full = np.linspace(T0, T1, N + 2)\n    u_full = np.linspace(u0, u1, N + 2)\n    \n    # Extract interior points for iteration\n    T_k = T_full[1:-1].copy()\n    u_k = u_full[1:-1].copy()\n\n    for k_iter in range(k_max):\n        T_prev = T_k.copy()\n        u_prev = u_k.copy()\n        \n        # Update full solution vectors with previous iterate's values\n        T_full[1:-1] = T_k\n        u_full[1:-1] = u_k\n\n        # 2. Solve T-subproblem for T^{k+1}\n        # Assemble coefficients k(T^k)\n        k_vals = k_func(T_full)\n        k_half = 0.5 * (k_vals[:-1] + k_vals[1:]) # Face values, size N+1\n        \n        # Assemble tridiagonal matrix for T\n        # scipy.linalg.solve_banded expects matrix `ab` in a specific format:\n        # ab[0,:] = super-diagonal (shifted)\n        # ab[1,:] = main diagonal\n        # ab[2,:] = sub-diagonal (shifted)\n        A_T = np.zeros((3, N))\n        A_T[0, 1:]  = -k_half[1:N]\n        A_T[1, :]   = k_half[0:N] + k_half[1:N+1]\n        A_T[2, :-1] = -k_half[1:N]\n        \n        # Assemble right-hand side vector for T\n        b_T = h**2 * q_func(u_k)\n        b_T[0] += k_half[0] * T0\n        b_T[-1] += k_half[-1] * T1\n        \n        T_k_next = solve_banded((1, 1), A_T, b_T)\n\n        # 3. Solve U-subproblem for u^{k+1}\n        # Assemble coefficients C(T^k)\n        C_vals = C_func(T_full)\n        C_half = 0.5 * (C_vals[:-1] + C_vals[1:]) # Face values, size N+1\n\n        # Assemble tridiagonal matrix for U\n        A_U = np.zeros((3, N))\n        A_U[0, 1:]  = -C_half[1:N]\n        A_U[1, :]   = C_half[0:N] + C_half[1:N+1]\n        A_U[2, :-1] = -C_half[1:N]\n        \n        # Assemble right-hand side vector for U\n        b_U = np.zeros(N)\n        b_U[0] += C_half[0] * u0\n        b_U[-1] += C_half[-1] * u1\n        \n        u_k_next = solve_banded((1, 1), A_U, b_U)\n\n        # 4. Check for convergence\n        err_T = np.linalg.norm(T_k_next - T_prev, np.inf)\n        err_U = np.linalg.norm(u_k_next - u_prev, np.inf)\n\n        if max(err_T, err_U)  epsilon:\n            return k_iter + 1\n\n        # 5. Update for next iteration\n        T_k = T_k_next\n        u_k = u_k_next\n\n    return k_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Global parameters\n    N = 50\n    epsilon = 1e-8\n    k_max = 200\n\n    test_cases = [\n        # Case 1\n        {\n            \"k_func\": lambda T: 1.0 + 0.5 * T,\n            \"C_func\": lambda T: np.exp(0.3 * T),\n            \"q_func\": lambda u: 0.1 + u**2,\n            \"T_bcs\": (0.0, 1.0),\n            \"u_bcs\": (1.0, 0.0)\n        },\n        # Case 2\n        {\n            \"k_func\": lambda T: 1.0,\n            \"C_func\": lambda T: 1.0,\n            \"q_func\": lambda u: 0.0,\n            \"T_bcs\": (0.0, 0.0),\n            \"u_bcs\": (1.0, 1.0)\n        },\n        # Case 3\n        {\n            \"k_func\": lambda T: 0.5 + 5.0 * T**2,\n            \"C_func\": lambda T: 0.1 + 2.0 * T,\n            \"q_func\": lambda u: 0.5 * u + 2.0 * u**2,\n            \"T_bcs\": (2.0, 0.0),\n            \"u_bcs\": (0.0, 1.0)\n        },\n        # Case 4\n        {\n            \"k_func\": lambda T: 2.0,\n            \"C_func\": lambda T: 0.5 + 3.0 * np.exp(T),\n            \"q_func\": lambda u: 0.2,\n            \"T_bcs\": (0.0, 1.0),\n            \"u_bcs\": (0.5, 0.5)\n        }\n    ]\n\n    # Vectorize functions for performance\n    for case in test_cases:\n        case[\"k_func\"] = np.vectorize(case[\"k_func\"])\n        case[\"C_func\"] = np.vectorize(case[\"C_func\"])\n        case[\"q_func\"] = np.vectorize(case[\"q_func\"])\n\n    results = []\n    for case in test_cases:\n        # Run the solver for the current case\n        num_iterations = picard_solver(\n            k_func=case[\"k_func\"],\n            C_func=case[\"C_func\"],\n            q_func=case[\"q_func\"],\n            T0=case[\"T_bcs\"][0],\n            T1=case[\"T_bcs\"][1],\n            u0=case[\"u_bcs\"][0],\n            u1=case[\"u_bcs\"][1],\n            N=N,\n            epsilon=epsilon,\n            k_max=k_max\n        )\n        \n        # As per the problem's strict Picard definition, the order of solving\n        # the uncoupled subproblems does not matter. The iteration count for\n        # T-then-u and u-then-T sequences is identical.\n        results.append(num_iterations)  # n_TU\n        results.append(num_iterations)  # n_UT\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "仅仅求解耦合系统是不够的，深入理解线性化后系统的结构和数值特性同样至关重要。本练习引导您探索舒尔补（Schur complement）的概念，它是在耦合系统中通过分块消元自然产生的。通过分析一个典型的线性热弹性问题 ，您将研究问题参数和消元顺序如何影响子系统的条件数，这对于设计高效、鲁棒的分解求解策略至关重要。",
            "id": "3512972",
            "problem": "考虑在准静态、稳态设定下，机械位移与温度之间的线性热弹性耦合。从线性动量守恒和稳態能量平衡出发，结合小应变和小温差的线性化本构关系，（在对一维单位区间使用带有齐次狄利克雷边界条件的标准二阶中心差分格式进行空间离散化后）可以得到一个关于位移和温度增量的耦合线性系统。该代数系统具有以下分块形式\n$$\n\\mathbf{J}\n=\n\\begin{bmatrix}\n\\mathbf{K}_u  \\mathbf{B} \\\\\n\\mathbf{B}^\\top  \\mathbf{K}_T\n\\end{bmatrix},\n$$\n其中 $\\mathbf{K}_u$ 和 $\\mathbf{K}_T$ 是对称正定的类刚度矩阵，$\\mathbf{B}$ 代表在温度和位移增量上呈线性的热弹性耦合。在整个问题中，所有量均为无量纲。\n\n你将处理以下一个具体的、纯代数的特例，它抽象了热弹性雅可比矩阵的基本特征。对于给定的整数 $N \\geq 2$，定义 $N \\times N$ 的三对角矩阵\n$$\n\\mathbf{K}_N = \\operatorname{tridiag}(-1,2,-1),\n$$\n即，当 $i = 1,\\dots,N-1$ 时，$(\\mathbf{K}_N)_{ii} = 2$，$(\\mathbf{K}_N)_{i,i+1} = (\\mathbf{K}_N)_{i+1,i} = -1$，其余元素为零。对于给定的正标量 $s_u$ 和 $s_T$，定义\n$$\n\\mathbf{K}_u = s_u \\, \\mathbf{K}_N, \\quad \\mathbf{K}_T = s_T \\, \\mathbf{K}_N.\n$$\n设 $\\gamma  0$ 为一个标量耦合振幅。考虑耦合块 $\\mathbf{B}$ 的两种形式：\n- 均匀耦合：$\\mathbf{B} = \\gamma \\, \\mathbf{I}_N$。\n- 非均匀耦合：$\\mathbf{B} = \\gamma \\, \\operatorname{diag}(\\mathbf{w})$，其元素为 $w_i = 1 + 0.5 \\sin(2\\pi x_i)$，其中 $x_i = \\frac{i}{N+1}$，$i=1,\\dots,N$。\n\n根据分块高斯消元的基本定义，首先消去一个场会为剩余的场产生一个降阶系统，该系统由一个舒尔补矩阵来表征。具体来说，首先消去位移会产生一个关于温度的舒尔补，而首先消去温度会产生一个关于位移的舒尔补。在不使用任何预先推导公式的情况下，从舒尔补是精确分块消元的代数结果这一定义出发，推导这两个舒尔补的表达式，然后使用这些表达式来评估它们的光谱条件。\n\n你的任务是：\n1. 根据分块高斯消元的定义以及对称正定矩阵的性质，推导出对应两种消元顺序的两个舒尔补的显式表达式，用 $\\mathbf{K}_u$、$\\mathbf{K}_T$ 和 $\\mathbf{B}$ 来表示。\n2. 使用谱条件数的定义 $\\kappa_2(\\mathbf{A}) = \\|\\mathbf{A}\\|_2 \\,\\|\\mathbf{A}^{-1}\\|_2$（其等于 $\\mathbf{A}$ 的最大奇异值与最小奇异值之比），设计一个算法来计算两个舒尔补中每一个的 $\\kappa_2$。你不能假设舒尔补是正定的；如果一个舒尔补是不定的，你仍必须通过奇异值计算其2-范数条件数。\n3. 实现一个程序，对于下面的每个测试用例，该程序构建 $\\mathbf{K}_N$、$\\mathbf{K}_u$、$\\mathbf{K}_T$ 和 $\\mathbf{B}$；通过精确代数消元构成两个舒尔补；计算它们的光谱条件数；并返回以下比率：\n$$\nR = \\frac{\\kappa_2(\\text{先消去 } \\mathbf{u} \\text{ 得到的关于 } T \\text{ 的舒尔补})}{\\kappa_2(\\text{先消去 } T \\text{ 得到的关于 } \\mathbf{u} \\text{ 的舒尔补})}.\n$$\n对每个测试用例，以浮点数形式输出 $R$。\n\n所有计算都是无量纲实数运算。不要引入任何额外的物理单位。定义中出现的角度，单位为弧度。\n\n测试套件（每个元组为 $(N, s_u, s_T, \\gamma, \\text{heterogeneous})$，其中 heterogeneous 标志为 $0$ 表示均匀耦合，为 $1$ 表示非均匀耦合）：\n- 案例A（理想路径，均匀，弱耦合）：$(10, 1.0, 1.0, 0.1, 0)$。\n- 案例B（均匀，刚度对比）：$(10, 100.0, 1.0, 1.0, 0)$。\n- 案例C（均匀，尺寸效应与近共振耦合）：$(50, 1.0, 1.0, 1.0, 0)$。\n- 案例D（非均匀，中等耦合）：$(10, 1.0, 1.0, 1.0, 1)$。\n- 案例E（非均匀，刚度对比）：$(10, 100.0, 1.0, 0.5, 1)$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[rA,rB,rC,rD,rE]\"），其中每个条目是对应测试用例（按上述顺序）的 $R$ 的浮点值。输出中不得有多余的文本或行。",
            "solution": "该问题被评估为有效。它在耦合系统力学方面具有科学依据，是适定的（提供了所有必要信息），并且陈述客观。其前提是一致的，任务是可通过计算验证的。\n\n该问题要求推导和比较由一个代表离散化线性热弹性力学的分块线性系统产生的两个舒尔补的光谱条件。该系统由下式给出\n$$\n\\mathbf{J} \\begin{pmatrix} \\delta \\mathbf{u} \\\\ \\delta \\mathbf{T} \\end{pmatrix} = \\begin{bmatrix} \\mathbf{K}_u  \\mathbf{B} \\\\ \\mathbf{B}^\\top  \\mathbf{K}_T \\end{bmatrix} \\begin{pmatrix} \\delta \\mathbf{u} \\\\ \\delta \\mathbf{T} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f}_u \\\\ \\mathbf{f}_T \\end{pmatrix}\n$$\n其中 $\\delta \\mathbf{u}$ 和 $\\delta \\mathbf{T}$ 分别代表位移和温度增量向量。矩阵 $\\mathbf{K}_u$ 和 $\\mathbf{K}_T$被指定为对称正定（SPD），$\\mathbf{B}$ 是耦合矩阵。\n\n**1. 舒尔补的推导**\n\n舒尔补产生于分块高斯消元的过程。我们推导对应于两种可能消元顺序的两个舒尔补。\n\n**情况1：首先消去位移增量（$\\delta \\mathbf{u}$）以求得关于温度的舒尔补（$\\mathbf{S}_T$）**\n\n我们从以下两个分块方程开始：\n$$\n(1) \\quad \\mathbf{K}_u \\delta \\mathbf{u} + \\mathbf{B} \\delta \\mathbf{T} = \\mathbf{f}_u\n$$\n$$\n(2) \\quad \\mathbf{B}^\\top \\delta \\mathbf{u} + \\mathbf{K}_T \\delta \\mathbf{T} = \\mathbf{f}_T\n$$\n从方程（1）中，我们求解 $\\delta \\mathbf{u}$。由于 $\\mathbf{K}_u$ 被给定为对称正定，因此它是可逆的。\n$$\n\\mathbf{K}_u \\delta \\mathbf{u} = \\mathbf{f}_u - \\mathbf{B} \\delta \\mathbf{T} \\implies \\delta \\mathbf{u} = \\mathbf{K}_u^{-1} (\\mathbf{f}_u - \\mathbf{B} \\delta \\mathbf{T})\n$$\n接下来，我们将 $\\delta \\mathbf{u}$ 的这个表达式代入方程（2）：\n$$\n\\mathbf{B}^\\top \\left[ \\mathbf{K}_u^{-1} (\\mathbf{f}_u - \\mathbf{B} \\delta \\mathbf{T}) \\right] + \\mathbf{K}_T \\delta \\mathbf{T} = \\mathbf{f}_T\n$$\n展开并整理各项以分离出 $\\delta \\mathbf{T}$：\n$$\n\\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{f}_u - \\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{B} \\delta \\mathbf{T} + \\mathbf{K}_T \\delta \\mathbf{T} = \\mathbf{f}_T\n$$\n$$\n(\\mathbf{K}_T - \\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{B}) \\delta \\mathbf{T} = \\mathbf{f}_T - \\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{f}_u\n$$\n左侧乘以 $\\delta \\mathbf{T}$ 的矩阵是在矩阵 $\\mathbf{J}$ 中块 $\\mathbf{K}_u$ 的舒尔补。这是消去位移后温度系统的有效矩阵。我们将其记为 $\\mathbf{S}_T$。\n$$\n\\mathbf{S}_T = \\mathbf{K}_T - \\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{B}\n$$\n\n**情况2：首先消去温度增量（$\\delta \\mathbf{T}$）以求得关于位移的舒尔补（$\\mathbf{S}_u$）**\n\n这个过程与第一种情况对称。我们从方程（2）开始求解 $\\delta \\mathbf{T}$。由于 $\\mathbf{K}_T$ 是对称正定的，因此它是可逆的。\n$$\n\\mathbf{K}_T \\delta \\mathbf{T} = \\mathbf{f}_T - \\mathbf{B}^\\top \\delta \\mathbf{u} \\implies \\delta \\mathbf{T} = \\mathbf{K}_T^{-1} (\\mathbf{f}_T - \\mathbf{B}^\\top \\delta \\mathbf{u})\n$$\n将 $\\delta \\mathbf{T}$ 的这个表达式代入方程（1）：\n$$\n\\mathbf{K}_u \\delta \\mathbf{u} + \\mathbf{B} \\left[ \\mathbf{K}_T^{-1} (\\mathbf{f}_T - \\mathbf{B}^\\top \\delta \\mathbf{u}) \\right] = \\mathbf{f}_u\n$$\n展开并整理以分离出 $\\delta \\mathbf{u}$：\n$$\n\\mathbf{K}_u \\delta \\mathbf{u} + \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{f}_T - \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{B}^\\top \\delta \\mathbf{u} = \\mathbf{f}_u\n$$\n$$\n(\\mathbf{K}_u - \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{B}^\\top) \\delta \\mathbf{u} = \\mathbf{f}_u - \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{f}_T\n$$\n在 $\\mathbf{J}$ 中块 $\\mathbf{K}_T$ 的舒尔补是作用于 $\\delta \\mathbf{u}$ 的矩阵，我们将其记为 $\\mathbf{S}_u$。\n$$\n\\mathbf{S}_u = \\mathbf{K}_u - \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{B}^\\top\n$$\n\n**2. 谱条件数计算算法**\n\n矩阵 $\\mathbf{A}$ 的谱条件数（或2-范数条件数）定义为 $\\kappa_2(\\mathbf{A}) = \\|\\mathbf{A}\\|_2 \\|\\mathbf{A}^{-1}\\|_2$。对于任何矩阵 $\\mathbf{A}$，这都等价于其最大奇异值 $\\sigma_{\\max}(\\mathbf{A})$ 与其最小奇异值 $\\sigma_{\\min}(\\mathbf{A})$ 之比：\n$$\n\\kappa_2(\\mathbf{A}) = \\frac{\\sigma_{\\max}(\\mathbf{A})}{\\sigma_{\\min}(\\mathbf{A})}\n$$\n$\\mathbf{A}$ 的奇异值是对称半正定矩阵 $\\mathbf{A}^\\top \\mathbf{A}$ 的特征值的平方根。至关重要的是，这个定义对任何矩阵都成立，包括非对称、奇异或不定矩阵。该问题正确地要求我们不能假设舒尔补 $\\mathbf{S}_T$ 和 $\\mathbf{S}_u$ 是正定的。虽然它们是对称的（可以通过取其转置来验证），但从一个对称正定矩阵 $\\mathbf{K}_T$ 中减去一个半正定项 $\\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{B}$ 可能会得到一个不定矩阵。\n\n对于给定的舒尔补矩阵 $\\mathbf{A}$，计算 $\\kappa_2(\\mathbf{A})$ 的算法如下：\n1. 计算 $\\mathbf{A}$ 的奇异值。标准数值库为此提供了鲁棒的 SVD（奇异值分解）算法。\n2. 确定最大奇异值 $\\sigma_{\\max}$。\n3. 确定最小奇异值 $\\sigma_{\\min}$。\n4. 如果 $\\sigma_{\\min}$ 为零或在数值上与零无法区分，则矩阵是奇异的，其条件数为无穷大。在浮点运算中，这将导致一个非常大的数值。\n5. 如果 $\\sigma_{\\min}  0$，则条件数是比率 $\\sigma_{\\max} / \\sigma_{\\min}$。\n\n**3. 实现计划**\n\n程序将为每个测试用例 $(N, s_u, s_T, \\gamma, \\text{heterogeneous})$ 执行以下步骤：\n1. **构建矩阵**：\n    * 构成 $N \\times N$ 矩阵 $\\mathbf{K}_N = \\operatorname{tridiag}(-1, 2, -1)$。\n    * 对其进行缩放以得到 $\\mathbf{K}_u = s_u \\mathbf{K}_N$ 和 $\\mathbf{K}_T = s_T \\mathbf{K}_N$。\n    * 根据 `heterogeneous` 标志构建耦合矩阵 $\\mathbf{B}$：\n        * 如果 `heterogeneous` 为 $0$：$\\mathbf{B} = \\gamma \\mathbf{I}_N$。\n        * 如果 `heterogeneous` 为 $1$：计算向量 $\\mathbf{w}$，其元素为 $w_i = 1 + 0.5 \\sin(2\\pi x_i)$，其中 $x_i = i/(N+1)$，并构成对角矩阵 $\\mathbf{B} = \\gamma \\operatorname{diag}(\\mathbf{w})$。\n2. **构成舒尔补**：\n    * 计算逆矩阵 $\\mathbf{K}_u^{-1}$ 和 $\\mathbf{K}_T^{-1}$。\n    * 计算 $\\mathbf{S}_T = \\mathbf{K}_T - \\mathbf{B}^\\top \\mathbf{K}_u^{-1} \\mathbf{B}$。\n    * 计算 $\\mathbf{S}_u = \\mathbf{K}_u - \\mathbf{B} \\mathbf{K}_T^{-1} \\mathbf{B}^\\top$。注意，对于所考虑的两种耦合类型，$\\mathbf{B}$ 都是对角矩阵，因此 $\\mathbf{B}^\\top = \\mathbf{B}$。\n3. **计算条件数**：\n    * 使用计算2-范数条件数的数值库函数来计算 $\\kappa_2(\\mathbf{S}_T)$。\n    * 使用相同的函数计算 $\\kappa_2(\\mathbf{S}_u)$。\n4. **计算比率**：\n    * 计算所需的比率 $R = \\kappa_2(\\mathbf{S}_T) / \\kappa_2(\\mathbf{S}_u)$。\n5. **存储与输出**：\n    * 将计算出的 $R$ 值附加到结果列表中。\n    * 处理完所有测试用例后，将列表格式化为指定的字符串 `\"[rA,rB,rC,rD,rE]\"` 并打印。\n\n此过程遵循了上面定义的推导和算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermoelastic Schur complement conditioning problem for a suite of test cases.\n    \"\"\"\n    # Test suite (N, s_u, s_T, gamma, heterogeneous_flag)\n    # heterogeneous_flag: 0 for uniform, 1 for heterogeneous coupling\n    test_cases = [\n        (10, 1.0, 1.0, 0.1, 0),    # Case A\n        (10, 100.0, 1.0, 1.0, 0),   # Case B\n        (50, 1.0, 1.0, 1.0, 0),    # Case C\n        (10, 1.0, 1.0, 1.0, 1),    # Case D\n        (10, 100.0, 1.0, 0.5, 1),   # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        N, s_u, s_T, gamma, heterogeneous = case\n\n        # 1. Construct matrices\n        \n        # K_N is tridiag(-1, 2, -1)\n        K_N = 2 * np.eye(N) - np.diag(np.ones(N - 1), k=1) - np.diag(np.ones(N - 1), k=-1)\n        \n        K_u = s_u * K_N\n        K_T = s_T * K_N\n        \n        if heterogeneous == 0:\n            # Uniform coupling: B = gamma * I\n            B = gamma * np.eye(N)\n        else:\n            # Heterogeneous coupling: B = gamma * diag(w)\n            x_i = (np.arange(N) + 1.0) / (N + 1.0)\n            w_i = 1.0 + 0.5 * np.sin(2 * np.pi * x_i)\n            B = gamma * np.diag(w_i)\n            \n        # 2. Form Schur complements\n        # Both coupling matrices B are symmetric (diagonal), so B.T = B.\n        \n        # Compute inverses\n        try:\n            K_u_inv = np.linalg.inv(K_u)\n            K_T_inv = np.linalg.inv(K_T)\n        except np.linalg.LinAlgError:\n            # This should not happen since K_u and K_T are SPD\n            results.append(np.nan)\n            continue\n            \n        # Schur complement on T (temperature)\n        S_T = K_T - B.T @ K_u_inv @ B\n        \n        # Schur complement on u (displacement)\n        S_u = K_u - B @ K_T_inv @ B.T\n        \n        # 3. Compute spectral condition numbers (p=2 for 2-norm)\n        cond_S_T = np.linalg.cond(S_T, p=2)\n        cond_S_u = np.linalg.cond(S_u, p=2)\n        \n        # 4. Calculate the ratio R\n        if cond_S_u == 0:\n             # Avoid division by zero, though this is unlikely for the given problems\n             R = np.inf\n        else:\n             R = cond_S_T / cond_S_u\n\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}