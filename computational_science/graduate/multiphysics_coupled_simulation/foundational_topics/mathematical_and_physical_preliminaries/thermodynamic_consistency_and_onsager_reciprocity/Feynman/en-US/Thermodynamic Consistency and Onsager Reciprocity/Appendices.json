{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex code, it is crucial to grasp the mathematical structure of thermodynamic consistency. This exercise serves as a conceptual playground to explore what happens when a constitutive matrix violates fundamental physical laws, leading to non-physical results like negative entropy production . You will then learn the theoretical basis for 'repairing' such a matrix by finding its closest valid counterpart, establishing a key principle for building robust numerical models.",
            "id": "3529609",
            "problem": "Consider a one-dimensional multiphysics coupled system near equilibrium with two slow fields: internal energy density and solute concentration. In the linear irreversible regime, the flux vector $\\mathbf{J} = (J_{q}, J_{c})^{\\top}$ is related to the conjugate thermodynamic forces $\\mathbf{X} = (\\partial_{x}(1/T), \\partial_{x}(\\mu/T))^{\\top}$ via a linear constitutive relation $\\mathbf{J} = \\mathbf{L}\\,\\mathbf{X}$, where $\\mathbf{L} \\in \\mathbb{R}^{2 \\times 2}$ collects cross-couplings between heat and mass transport. The entropy production rate is $\\sigma = \\mathbf{X}^{\\top}\\mathbf{J}$.\n\nStart from a baseline constitutive matrix that satisfies Onsager reciprocity and thermodynamic consistency\n$$\n\\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nwhich has a degeneracy vector $\\mathbf{g} = (1,1)^{\\top}$ such that $\\mathbf{L}_{\\mathrm{base}}\\,\\mathbf{g} = \\mathbf{0}$, consistent with the General Equation for the Non-Equilibrium Reversible-Irreversible Coupling (GENERIC) degeneracy condition that the irreversible operator annihilates the energy gradient.\n\nDesign a modified constitutive relation that violates the non-negativity of entropy production $\\sigma \\ge 0$ and Onsager symmetry. To that end, define a symmetric perturbation\n$$\n\\Delta \\mathbf{S} = -\\frac{1}{2}\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix}\n$$\nwhich shifts the zero eigenvalue of $\\mathbf{L}_{\\mathrm{base}}$ along $\\mathbf{g}$ to a negative value, and add an antisymmetric perturbation\n$$\n\\mathbf{N} = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}\n$$\nso that the modified constitutive matrix is\n$$\n\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}\n$$\n\nTasks:\n- Using only foundational principles of linear irreversible thermodynamics and the second law, evaluate the entropy production $\\sigma$ for the specific force $\\mathbf{X} = \\mathbf{g}$ under $\\mathbf{L}_{\\mathrm{viol}}$, and determine whether it violates $\\sigma \\ge 0$.\n- Enforce thermodynamic consistency by repairing $\\mathbf{L}_{\\mathrm{viol}}$ to a matrix $\\mathbf{L}_{\\mathrm{rep}}$ that satisfies Onsager reciprocity (symmetry), positive semidefiniteness, and the GENERIC degeneracy constraint $\\mathbf{L}_{\\mathrm{rep}}\\,\\mathbf{g} = \\mathbf{0}$. Among all such repairs, choose the one that minimizes the Frobenius norm distance to $\\mathbf{L}_{\\mathrm{viol}}$.\n- Provide the repaired matrix $\\mathbf{L}_{\\mathrm{rep}}$ as your final answer. Express your answer exactly; do not round.",
            "solution": "The problem requires a two-part analysis of a constitutive matrix $\\mathbf{L}_{\\mathrm{viol}}$ designed to violate thermodynamic principles. First, we must verify that it indeed leads to a negative entropy production for a specific thermodynamic force. Second, we must repair this matrix to find a new matrix $\\mathbf{L}_{\\mathrm{rep}}$ that satisfies all thermodynamic constraints and is closest to $\\mathbf{L}_{\\mathrm{viol}}$ in the sense of the Frobenius norm.\n\nFirst, we explicitly construct the matrix $\\mathbf{L}_{\\mathrm{viol}}$. It is defined as the sum of three matrices:\n$\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}$\nGiven the definitions:\n$\\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$, $\\Delta \\mathbf{S} = -\\frac{1}{2}\\begin{pmatrix} 1 & 1 \\\\ 1 & 1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} & -\\frac{1}{2} \\\\ -\\frac{1}{2} & -\\frac{1}{2} \\end{pmatrix}$, and $\\mathbf{N} = \\begin{pmatrix} 0 & 1 \\\\ -1 & 0 \\end{pmatrix}$.\nSumming these matrices component-wise:\n$$\n\\mathbf{L}_{\\mathrm{viol}} = \\begin{pmatrix} 1 - \\frac{1}{2} + 0 & -1 - \\frac{1}{2} + 1 \\\\ -1 - \\frac{1}{2} - 1 & 1 - \\frac{1}{2} + 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2} & -\\frac{1}{2} \\\\ -\\frac{5}{2} & \\frac{1}{2} \\end{pmatrix}\n$$\n\nNext, we evaluate the entropy production rate, $\\sigma = \\mathbf{X}^{\\top}\\mathbf{J} = \\mathbf{X}^{\\top}\\mathbf{L}\\mathbf{X}$, for the specific case where the thermodynamic force vector is $\\mathbf{X} = \\mathbf{g} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$.\nSubstituting $\\mathbf{L} = \\mathbf{L}_{\\mathrm{viol}}$ and $\\mathbf{X} = \\mathbf{g}$:\n$$\n\\sigma = \\mathbf{g}^{\\top} \\mathbf{L}_{\\mathrm{viol}} \\mathbf{g} = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2} & -\\frac{1}{2} \\\\ -\\frac{5}{2} & \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\nPerforming the matrix multiplication:\n$$\n\\sigma = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2}(1) - \\frac{1}{2}(1) \\\\ -\\frac{5}{2}(1) + \\frac{1}{2}(1) \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = (1)(0) + (1)(-2) = -2\n$$\nSince $\\sigma = -2$, which is less than $0$, the matrix $\\mathbf{L}_{\\mathrm{viol}}$ violates the second law of thermodynamics, which requires non-negative entropy production, $\\sigma \\ge 0$, for all possible forces $\\mathbf{X}$.\n\nThe second task is to find a repaired matrix $\\mathbf{L}_{\\mathrm{rep}}$ that minimizes the Frobenius norm distance $\\|\\mathbf{L}_{\\mathrm{rep}} - \\mathbf{L}_{\\mathrm{viol}}\\|_F$ subject to three conditions:\n1.  Onsager reciprocity: $\\mathbf{L}_{\\mathrm{rep}}$ must be symmetric, i.e., $\\mathbf{L}_{\\mathrm{rep}} = \\mathbf{L}_{\\mathrm{rep}}^{\\top}$.\n2.  Thermodynamic consistency: $\\mathbf{L}_{\\mathrm{rep}}$ must be positive semidefinite (PSD), ensuring $\\sigma = \\mathbf{X}^{\\top}\\mathbf{L}_{\\mathrm{rep}}\\mathbf{X} \\ge 0$ for all $\\mathbf{X}$.\n3.  GENERIC degeneracy: $\\mathbf{L}_{\\mathrm{rep}}\\mathbf{g} = \\mathbf{0}$, where $\\mathbf{g} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$.\n\nLet us characterize the set of matrices that satisfy these three conditions. Let $\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$.\nThe symmetry condition requires $b=c$. So, $\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} a & b \\\\ b & d \\end{pmatrix}$.\nThe degeneracy condition requires:\n$$\n\\mathbf{L}_{\\mathrm{rep}}\\mathbf{g} = \\begin{pmatrix} a & b \\\\ b & d \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a+b \\\\ b+d \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\nThis yields $a = -b$ and $d = -b$. Thus, the matrix must have the form:\n$$\n\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} -b & b \\\\ b & -b \\end{pmatrix} = -b \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nLet $k = -b$. The matrix is $\\mathbf{L}_{\\mathrm{rep}} = k \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} = k \\mathbf{L}_{\\mathrm{base}}$.\n\nFinally, the PSD condition requires that all eigenvalues of $\\mathbf{L}_{\\mathrm{rep}}$ be non-negative. The eigenvalues of $\\mathbf{L}_{\\mathrm{base}}$ are $\\lambda_1 = 0$ and $\\lambda_2 = 2$. Therefore, the eigenvalues of $\\mathbf{L}_{\\mathrm{rep}} = k \\mathbf{L}_{\\mathrm{base}}$ are $0$ and $2k$. For the matrix to be PSD, we must have $2k \\ge 0$, which implies $k \\ge 0$.\n\nSo, the set of all valid matrices is the convex cone $C = \\{ k \\mathbf{L}_{\\mathrm{base}} \\mid k \\ge 0 \\}$. The problem is to find the projection of $\\mathbf{L}_{\\mathrm{viol}}$ onto this set $C$. The projection is the matrix in $C$ that minimizes the Frobenius norm distance. This is a standard orthogonal projection problem. The optimal coefficient $k$ for projecting $\\mathbf{L}_{\\mathrm{viol}}$ onto the line spanned by $\\mathbf{L}_{\\mathrm{base}}$ is given by:\n$$\nk = \\frac{\\langle \\mathbf{L}_{\\mathrm{viol}}, \\mathbf{L}_{\\mathrm{base}} \\rangle_F}{\\|\\mathbf{L}_{\\mathrm{base}}\\|_F^2}\n$$\nwhere $\\langle \\cdot, \\cdot \\rangle_F$ is the Frobenius inner product (sum of the element-wise products).\nLet's compute the inner product:\n$$\n\\langle \\mathbf{L}_{\\mathrm{viol}}, \\mathbf{L}_{\\mathrm{base}} \\rangle_F = \\sum_{i,j} (\\mathbf{L}_{\\mathrm{viol}})_{ij} (\\mathbf{L}_{\\mathrm{base}})_{ij} = (\\frac{1}{2})(1) + (-\\frac{1}{2})(-1) + (-\\frac{5}{2})(-1) + (\\frac{1}{2})(1)\n$$\n$$\n= \\frac{1}{2} + \\frac{1}{2} + \\frac{5}{2} + \\frac{1}{2} = \\frac{1+1+5+1}{2} = \\frac{8}{2} = 4\n$$\nNext, we compute the squared Frobenius norm of $\\mathbf{L}_{\\mathrm{base}}$:\n$$\n\\|\\mathbf{L}_{\\mathrm{base}}\\|_F^2 = 1^2 + (-1)^2 + (-1)^2 + 1^2 = 1 + 1 + 1 + 1 = 4\n$$\nThe coefficient $k$ is therefore:\n$$\nk = \\frac{4}{4} = 1\n$$\nSince $k=1 \\ge 0$, this value lies within the allowed range for the scaling factor. The projection onto the cone $C$ is the same as the projection onto the line. The repaired matrix is thus:\n$$\n\\mathbf{L}_{\\mathrm{rep}} = k \\mathbf{L}_{\\mathrm{base}} = 1 \\cdot \\mathbf{L}_{\\mathrm{base}} = \\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThis result can be understood by noting that the perturbations $\\Delta \\mathbf{S}$ and $\\mathbf{N}$ are orthogonal to $\\mathbf{L}_{\\mathrm{base}}$ in the Frobenius inner product space. The projection of $\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}$ onto the space spanned by $\\mathbf{L}_{\\mathrm{base}}$ eliminates the orthogonal components, leaving just $\\mathbf{L}_{\\mathrm{base}}$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "In practical simulations, numerical errors or simplification schemes can yield mobility matrices that violate thermodynamic constraints, causing simulations to become unstable or generate unphysical results. This practice challenges you to implement a projection algorithm that corrects these matrices during a time-dependent simulation . By comparing the behavior of a system with and without this correction, you will gain direct insight into how enforcing Onsager reciprocity and positive entropy production ensures numerical stability and physical fidelity.",
            "id": "3529587",
            "problem": "Consider a multiphysics coupled simulation in the linear regime of nonequilibrium thermodynamics, where generalized fluxes $J$ are related to generalized forces $X$ by a linear constitutive law $J = L\\,X$. To be thermodynamically consistent, the matrix $L$ must satisfy Onsager reciprocity $L = L^\\top$ and ensure nonnegative entropy production $X^\\top L X \\ge 0$ for all $X$, that is, $L$ must be symmetric positive semidefinite. In practice, numerical discretization and time integration may produce a matrix $L$ that violates these properties (for example through round-off or operator splitting), which can lead to instability and loss of physical fidelity.\n\nYour task is to design and implement a correction scheme that projects a numerically obtained matrix $L$ onto the closest matrix $\\widehat{L}$, in the Frobenius norm sense, that satisfies both $L = L^\\top$ and $L \\succeq 0$. Then, quantify the impact of this correction on stability and physical fidelity in an explicit time integration of a linear gradient flow with quadratic free energy.\n\nStarting from the following fundamental base:\n- The Second Law of Thermodynamics requires the entropy production $\\sigma = X^\\top L X$ to be nonnegative for all forces $X$, so $L$ must be symmetric positive semidefinite.\n- In a gradient-flow model for a state vector $x \\in \\mathbb{R}^n$ with quadratic free energy $F(x) = \\tfrac{1}{2} x^\\top K x$ and positive semidefinite stiffness $K$, a linear mobility $L$ yields the evolution $\\dot{x} = - L K x$. Under exact continuous dynamics with $L \\succeq 0$ and $K \\succeq 0$, the free energy $F$ is nonincreasing.\n\nYou must:\n1. Propose and implement a correction scheme that maps an arbitrary square matrix $L$ to the closest matrix $\\widehat{L}$ (in Frobenius norm) subject to $\\widehat{L} = \\widehat{L}^\\top$ and $\\widehat{L} \\succeq 0$.\n2. For each test case below, construct $L$, $K$, the time step $\\Delta t$, and an initial condition $x_0$. Integrate the explicit Euler scheme $x_{k+1} = x_k - \\Delta t\\,L K x_k$ for $N$ steps with $N = 100$, once using the original $L$ and once using the corrected $\\widehat{L}$. Use dimensionless quantities; no physical units are required.\n3. For each run (original $L$ and corrected $\\widehat{L}$), compute the following quantitative metrics:\n   - The Frobenius projection distance $d = \\|L - \\widehat{L}\\|_F$.\n   - The spectral radius $\\rho$ of the update matrix $I - \\Delta t\\,L K$, that is $\\rho = \\max_i |\\lambda_i(I - \\Delta t\\,L K)|$.\n   - The maximum positive energy increment over the trajectory, defined as $\\max\\{ F(x_{k+1}) - F(x_k), 0 \\}$ across all steps $k$.\n   - The minimal entropy production proxy given by $\\lambda_{\\min}\\!\\left(\\tfrac{L + L^\\top}{2}\\right)$.\n   - A boolean indicating whether the free energy $F$ is nonincreasing across all steps (monotone), that is $F(x_{k+1}) \\le F(x_k)$ holds for all $k$.\n4. Aggregate the results for each test case into a list with the following order:\n   $[d,\\ \\rho(L),\\ \\rho(\\widehat{L}),\\ \\text{max\\_dE}(L),\\ \\text{max\\_dE}(\\widehat{L}),\\ \\lambda_{\\min}((L+L^\\top)/2),\\ \\lambda_{\\min}((\\widehat{L}+\\widehat{L}^\\top)/2),\\ \\text{is\\_monotone}(L),\\ \\text{is\\_monotone}(\\widehat{L})]$.\n\nTest Suite (all quantities are dimensionless and deterministic via fixed seeds):\n- Case $1$ ($n=3$):\n  - Construct $L$ as $L = Q \\operatorname{diag}(1.5,0.8,0.2) Q^\\top + E$, where $Q$ is obtained by a $\\mathrm{QR}$ factorization of a random normal matrix with seed $42$ and $E$ is a small perturbation $0.01$ times a random normal matrix with seed $0$.\n  - Construct $K = P \\operatorname{diag}(2.0,1.0,0.5) P^\\top$, where $P$ is the $\\mathrm{QR}$ factorization of a random normal matrix with seed $7$.\n  - Time step $\\Delta t = 0.1$.\n  - Initial condition $x_0$ drawn from a random normal vector with seed $123$.\n- Case $2$ ($n=4$):\n  - Start with a random normal matrix with seed $1$ to form a trial $L$, then set its symmetric part $S = (L + L^\\top)/2$ and shift it so that $\\lambda_{\\min}(S) = -0.5$ by $S \\leftarrow S - \\alpha I$ with $\\alpha = \\lambda_{\\min}(S) + 0.5$. Add a skew-symmetric part $A$ constructed from a random normal matrix with seed $2$ via $A = 0.3\\,(R - R^\\top)$, and set $L = S + A$.\n  - Construct $K = P \\operatorname{diag}(2.0,1.5,1.0,0.5) P^\\top$, where $P$ is the $\\mathrm{QR}$ factorization of a random normal matrix with seed $8$.\n  - Time step $\\Delta t = 0.1$.\n  - Initial condition $x_0$ drawn from a random normal vector with seed $124$.\n- Case $3$ ($n=3$):\n  - Construct a nearly consistent but borderline indefinite matrix by $S = Q \\operatorname{diag}(1.0,0.5,-10^{-3}) Q^\\top$, with $Q$ from seed $77$, and add a small skew-symmetric perturbation $A = 0.02\\,(R - R^\\top)$ with $R$ from seed $3$, then $L = S + A$.\n  - Construct $K = P \\operatorname{diag}(1.5,1.0,0.5) P^\\top$, where $P$ is from seed $9$.\n  - Time step $\\Delta t = 0.3$.\n  - Initial condition $x_0$ from seed $125$.\n- Case $4$ ($n=3$):\n  - Construct a singular positive semidefinite core $S = Q \\operatorname{diag}(1.0,0.0,0.2) Q^\\top$, with $Q$ from seed $55$, and add a tiny perturbation $E$ with $E = 0.005\\,R$ from seed $4$, then $L = S + E$.\n  - Construct $K = P \\operatorname{diag}(1.2,0.9,0.4) P^\\top$, where $P$ is from seed $10$.\n  - Time step $\\Delta t = 0.2$.\n  - Initial condition $x_0$ from seed $126$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets (for example, `[[...],[...],[...],[...]]`). Each inner list must follow the order above and contain the following types: the first seven entries are real numbers (floating-point), and the last two entries are booleans. No other text should be printed.",
            "solution": "The problem requires the formulation and implementation of a numerical correction scheme to enforce thermodynamic consistency on a mobility matrix $L$ arising in a multiphysics simulation. Specifically, an arbitrary square matrix $L$ must be projected onto the set of symmetric positive semidefinite (SPSD) matrices. The resulting corrected matrix, denoted $\\widehat{L}$, will be the closest matrix to $L$ in the Frobenius norm sense that satisfies the Onsager reciprocity condition ($\\widehat{L} = \\widehat{L}^\\top$) and ensures nonnegative entropy production ($\\widehat{L} \\succeq 0$). We will then analyze the effect of this correction on the stability and physical fidelity of a numerical simulation of a linear gradient flow.\n\n### Part 1: The Correction Scheme - Projection onto the SPSD Cone\n\nThe core task is to solve the following optimization problem for a given matrix $L \\in \\mathbb{R}^{n \\times n}$:\n$$\n\\text{minimize} \\quad \\frac{1}{2} \\|L - \\widehat{L}\\|_F^2 \\\\\n\\text{subject to} \\quad \\widehat{L} = \\widehat{L}^\\top \\text{ and } \\widehat{L} \\succeq 0\n$$\nwhere $\\|A\\|_F = \\sqrt{\\operatorname{tr}(A^\\top A)}$ is the Frobenius norm.\n\nWe can decompose any square matrix $L$ into its symmetric and skew-symmetric parts:\n$$\nL = L_S + L_A\n$$\nwhere $L_S = \\frac{1}{2}(L + L^\\top)$ is the symmetric part and $L_A = \\frac{1}{2}(L - L^\\top)$ is the skew-symmetric part. The space of square matrices is an orthogonal direct sum of the subspaces of symmetric and skew-symmetric matrices with respect to the Frobenius inner product $\\langle A, B \\rangle_F = \\operatorname{tr}(A^\\top B)$.\n\nThe objective function can be rewritten using this decomposition. Since $\\widehat{L}$ is required to be symmetric, the difference $L_S - \\widehat{L}$ is symmetric. The term $L_A$ is skew-symmetric. Due to the orthogonality of symmetric and skew-symmetric matrices, we have:\n$$\n\\|L - \\widehat{L}\\|_F^2 = \\|(L_S - \\widehat{L}) + L_A\\|_F^2 = \\|L_S - \\widehat{L}\\|_F^2 + \\|L_A\\|_F^2\n$$\nTo minimize $\\|L - \\widehat{L}\\|_F^2$, we only need to minimize $\\|L_S - \\widehat{L}\\|_F^2$, as $\\|L_A\\|_F^2$ is a fixed quantity. This decouples the problem into two parts:\n1.  The skew-symmetric part $L_A$ is projected to the zero matrix, as the closest symmetric matrix to $L_A$ is $0$.\n2.  The symmetric part $L_S$ must be projected onto the cone of positive semidefinite matrices.\n\nThe problem is thus reduced to finding the SPSD matrix $\\widehat{L}$ that is closest to the symmetric matrix $L_S$. This is a well-known result in matrix analysis. The solution is obtained via the spectral decomposition of $L_S$. Let the eigendecomposition of the real symmetric matrix $L_S$ be:\n$$\nL_S = U \\Lambda U^\\top\n$$\nwhere $U$ is an orthogonal matrix whose columns are the eigenvectors of $L_S$, and $\\Lambda = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\dots, \\lambda_n)$ is a diagonal matrix of the corresponding real eigenvalues.\n\nThe closest SPSD matrix $\\widehat{L}$ to $L_S$ is found by projecting the eigenvalues onto the non-negative real line. We construct a new diagonal matrix $\\Lambda_+$ where each diagonal entry is given by $(\\Lambda_+)_{ii} = \\max(\\lambda_i, 0)$. The corrected matrix $\\widehat{L}$ is then reconstructed as:\n$$\n\\widehat{L} = U \\Lambda_+ U^\\top\n$$\nBy construction, $\\widehat{L}$ is symmetric. Its eigenvalues are the diagonal entries of $\\Lambda_+$, which are all non-negative, so $\\widehat{L}$ is positive semidefinite. This procedure gives the unique solution to the optimization problem.\n\nThe algorithmic steps for the correction are:\n1.  Given $L$, compute its symmetric part: $L_S = \\frac{1}{2}(L + L^\\top)$.\n2.  Compute the spectral decomposition of $L_S$ to find its eigenvalues $\\lambda_i$ and eigenvectors (the matrix $U$).\n3.  Set all negative eigenvalues to zero: $\\lambda_i^+ = \\max(\\lambda_i, 0)$.\n4.  Reconstruct the corrected matrix: $\\widehat{L} = U \\operatorname{diag}(\\lambda_1^+, \\dots, \\lambda_n^+) U^\\top$.\n\n### Part 2: Analysis of Simulation Metrics\n\nWe now analyze the quantitative metrics used to evaluate the impact of this correction on the gradient flow model $\\dot{x} = -L K x$ with free energy $F(x) = \\frac{1}{2} x^\\top K x$. The system is discretized using the explicit Euler method: $x_{k+1} = (I - \\Delta t L K) x_k$.\n\n-   **Frobenius Projection Distance, $d = \\|L - \\widehat{L}\\|_F$**: This metric quantifies the magnitude of the correction applied to $L$. A large value indicates a significant departure of the original numerical matrix from thermodynamic consistency.\n\n-   **Minimal Entropy Production Proxy, $\\lambda_{\\min}\\!\\left(\\tfrac{L + L^\\top}{2}\\right)$**: The rate of entropy production in the continuous model is $\\sigma = X^\\top L X$ where $X$ is the generalized force. As $X^\\top L_A X = 0$, this is equal to $\\sigma = X^\\top L_S X$. The second law of thermodynamics requires $\\sigma \\ge 0$ for all $X$. This is equivalent to the symmetric part $L_S$ being positive semidefinite. The quantity $\\lambda_{\\min}(L_S)$ is therefore a direct measure of physical consistency. If $\\lambda_{\\min}(L_S) < 0$, there exists a thermodynamic force that would lead to a decrease in entropy, which is unphysical. The correction guarantees that $\\lambda_{\\min}(\\widehat{L}) \\ge 0$.\n\n-   **Spectral Radius, $\\rho(I - \\Delta t\\,L K)$**: The stability of the explicit Euler scheme is governed by the spectral radius of the update matrix $M = I - \\Delta t\\,L K$. The scheme is stable if and only if $\\rho(M) \\le 1$. If $L$ is not symmetric, the product $LK$ can have eigenvalues with negative real parts or complex eigenvalues, which can easily lead to $\\rho(M) > 1$ and numerical instability. The correction to $\\widehat{L}$ ensures that $\\widehat{L}$ is SPSD. While $\\widehat{L}K$ is not guaranteed to be symmetric, its eigenvalues have non-negative real parts if $K$ is SPSD, which generally improves the stability properties of the scheme. The condition $\\rho(M) \\le 1$ becomes more readily satisfied for a given time step $\\Delta t$.\n\n-   **Energy Evolution, $\\max\\{ F(x_{k+1}) - F(x_k), 0 \\}$ and `is_monotone`**: In a true gradient flow, the free energy must be non-increasing, i.e., $\\dot{F} \\le 0$. The time derivative of our free energy is $\\dot{F} = (\\nabla F)^\\top \\dot{x} = (Kx)^\\top (-LKx) = -(Kx)^\\top L (Kx)$. This is non-positive if $L$ is positive semidefinite on the space of forces. An uncorrected $L$ with $\\lambda_{\\min}(L_S) < 0$ can lead to $\\dot{F} > 0$, a non-physical increase in free energy. In the discrete simulation, we measure the maximum positive energy increment $F(x_{k+1}) - F(x_k)$ over the trajectory. An uncorrected $L$ may produce positive increments, whereas the corrected $\\widehat{L}$ is expected to maintain energy non-increase, $F(x_{k+1}) \\le F(x_k)$ for all steps $k$, provided $\\Delta t$ is within the stability limit. The boolean metric `is_monotone` summarizes this behavior over the entire simulation.\n\nThe evaluation across the test cases will demonstrate how the projection algorithm restores these essential physical and numerical properties.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    test_cases = [\n        {'n': 3, 'L_seed_Q': 42, 'L_seed_E': 0, 'K_seed_P': 7,\n         'x0_seed': 123, 'dt': 0.1, 'case_id': 1},\n        {'n': 4, 'L_seed_trial': 1, 'L_seed_R': 2, 'K_seed_P': 8,\n         'x0_seed': 124, 'dt': 0.1, 'case_id': 2},\n        {'n': 3, 'L_seed_Q': 77, 'L_seed_R': 3, 'K_seed_P': 9,\n         'x0_seed': 125, 'dt': 0.3, 'case_id': 3},\n        {'n': 3, 'L_seed_Q': 55, 'L_seed_R': 4, 'K_seed_P': 10,\n         'x0_seed': 126, 'dt': 0.2, 'case_id': 4},\n    ]\n\n    results = []\n    N_STEPS = 100\n\n    for params in test_cases:\n        L, K, x0 = _construct_matrices(params)\n        dt = params['dt']\n        \n        # 1. Propose and implement a correction scheme\n        L_hat = _project_to_spsd(L)\n        \n        # 2. Run simulations\n        traj_L = _run_simulation(L, K, x0, dt, N_STEPS)\n        traj_L_hat = _run_simulation(L_hat, K, x0, dt, N_STEPS)\n        \n        # 3. Compute quantitative metrics\n        case_results = _calculate_metrics(L, L_hat, K, dt, traj_L, traj_L_hat)\n        \n        # 4. Aggregate results\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _construct_matrices(params):\n    \"\"\"Constructs L, K, and x0 for a given test case.\"\"\"\n    n = params['n']\n    case_id = params['case_id']\n\n    # Construct L\n    if case_id == 1:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_e = np.random.default_rng(params['L_seed_E'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        E = rng_e.normal(size=(n, n))\n        L = Q @ np.diag([1.5, 0.8, 0.2]) @ Q.T + 0.01 * E\n    elif case_id == 2:\n        rng_trial = np.random.default_rng(params['L_seed_trial'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        L_trial = rng_trial.normal(size=(n, n))\n        S = 0.5 * (L_trial + L_trial.T)\n        lambda_min_S = np.min(np.linalg.eigvalsh(S))\n        alpha = lambda_min_S + 0.5\n        S_shifted = S - alpha * np.eye(n)\n        R = rng_r.normal(size=(n, n))\n        A = 0.3 * (R - R.T)\n        L = S_shifted + A\n    elif case_id == 3:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        S = Q @ np.diag([1.0, 0.5, -1e-3]) @ Q.T\n        R = rng_r.normal(size=(n, n))\n        A = 0.02 * (R - R.T)\n        L = S + A\n    elif case_id == 4:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        S = Q @ np.diag([1.0, 0.0, 0.2]) @ Q.T\n        E = 0.005 * rng_r.normal(size=(n, n))\n        L = S + E\n    else:\n        raise ValueError(\"Invalid case_id\")\n\n    # Construct K\n    rng_p = np.random.default_rng(params['K_seed_P'])\n    P, _ = np.linalg.qr(rng_p.normal(size=(n, n)))\n    if case_id == 1:\n        K = P @ np.diag([2.0, 1.0, 0.5]) @ P.T\n    elif case_id == 2:\n        K = P @ np.diag([2.0, 1.5, 1.0, 0.5]) @ P.T\n    elif case_id == 3:\n        K = P @ np.diag([1.5, 1.0, 0.5]) @ P.T\n    elif case_id == 4:\n        K = P @ np.diag([1.2, 0.9, 0.4]) @ P.T\n        \n    # Construct x0\n    rng_x0 = np.random.default_rng(params['x0_seed'])\n    x0 = rng_x0.normal(size=n)\n    \n    return L, K, x0\n\n\ndef _project_to_spsd(L):\n    \"\"\"Projects matrix L onto the closest symmetric positive semidefinite matrix.\"\"\"\n    L_s = 0.5 * (L + L.T)\n    eigvals, eigvecs = np.linalg.eigh(L_s)\n    eigvals[eigvals  0] = 0\n    L_hat = eigvecs @ np.diag(eigvals) @ eigvecs.T\n    return L_hat\n\n\ndef _run_simulation(L, K, x0, dt, N):\n    \"\"\"Runs the explicit Euler simulation for N steps.\"\"\"\n    x_traj = [x0]\n    x = x0.copy()\n    update_matrix = np.eye(len(x0)) - dt * L @ K\n    for _ in range(N):\n        x = update_matrix @ x\n        x_traj.append(x)\n    return np.array(x_traj)\n\ndef _calculate_metrics(L, L_hat, K, dt, traj_L, traj_L_hat):\n    \"\"\"Calculates all required metrics for a test case.\"\"\"\n    n = L.shape[0]\n\n    # Frobenius projection distance\n    d = np.linalg.norm(L - L_hat, 'fro')\n\n    # Spectral radius of update matrix\n    update_matrix_L = np.eye(n) - dt * L @ K\n    rho_L = np.max(np.abs(np.linalg.eigvals(update_matrix_L)))\n    \n    update_matrix_L_hat = np.eye(n) - dt * L_hat @ K\n    rho_L_hat = np.max(np.abs(np.linalg.eigvals(update_matrix_L_hat)))\n    \n    # Energy calculations\n    def get_energy(x, K_mat):\n        return 0.5 * x.T @ K_mat @ x\n\n    energies_L = np.array([get_energy(vec, K) for vec in traj_L])\n    energy_increments_L = np.diff(energies_L)\n    max_dE_L = np.max(np.maximum(energy_increments_L, 0))\n    # A tolerance is prudent for floating point comparisons\n    is_monotone_L = np.all(energy_increments_L = 1e-12)\n\n    energies_L_hat = np.array([get_energy(vec, K) for vec in traj_L_hat])\n    energy_increments_L_hat = np.diff(energies_L_hat)\n    max_dE_L_hat = np.max(np.maximum(energy_increments_L_hat, 0))\n    is_monotone_L_hat = np.all(energy_increments_L_hat = 1e-12)\n\n    # Minimal entropy production proxy\n    lambda_min_L_sym = np.min(np.linalg.eigvalsh(0.5 * (L + L.T)))\n    # L_hat is already symmetric SPSD, so the min eigenvalue is non-negative\n    lambda_min_L_hat_sym = np.min(np.linalg.eigvalsh(L_hat))\n    \n    return [\n        d,\n        rho_L,\n        rho_L_hat,\n        max_dE_L,\n        max_dE_L_hat,\n        lambda_min_L_sym,\n        lambda_min_L_hat_sym,\n        is_monotone_L,\n        is_monotone_L_hat\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While correcting inconsistencies as they appear is a powerful tool, a more robust and elegant strategy is to design numerical methods that are 'correct-by-construction.' This hands-on coding task guides you through the implementation of a Finite Volume scheme where the discretization itself inherently preserves thermodynamic consistency . You will use the matrix harmonic mean to construct face-based transport coefficients that guarantee the resulting global system respects the physical laws of reciprocity and non-negative entropy production.",
            "id": "3529576",
            "problem": "Design and implement a one-dimensional cell-centered Finite Volume Method (FVM) for a two-field coupled diffusive system consistent with linear irreversible thermodynamics. The two thermodynamic forces are the gradients of two scalar potentials, denoted by $ \\phi_1 $ and $ \\phi_2 $, and the two corresponding fluxes are denoted by $ J_1 $ and $ J_2 $. At every point in space, the flux vector $ J \\in \\mathbb{R}^2 $ and the force vector $ X \\in \\mathbb{R}^2 $ satisfy the linear Onsager relation $ J = - L X $, where $ L \\in \\mathbb{R}^{2 \\times 2} $ is the local Onsager matrix. The Onsager matrix is symmetric and positive definite for all points in the domain. The local entropy production density is $ \\sigma = X^\\top L X $, which is nonnegative by the second law of thermodynamics.\n\nYour task is to construct a discrete FVM operator on a one-dimensional mesh that:\n- Enforces discrete reciprocity $ L = L^\\top $ across cell faces by using the matrix harmonic mean for face interpolation.\n- Ensures that the assembled global stiffness matrix $ K $ is symmetric.\n- Ensures that the discrete entropy production summed over all faces is nonnegative for any given field values.\n\nThe numerical method must adhere to the following specifications:\n\n- Geometry and discretization:\n  - Consider a one-dimensional domain $ x \\in [0, L_x] $ with cell-centered unknowns. Let there be $ N $ cells with widths $ \\Delta x_i $ for $ i \\in \\{0, 1, \\dots, N-1\\} $ and $ \\sum_{i=0}^{N-1} \\Delta x_i = L_x $. The cell centers are located at positions $ x_i = x_{\\text{left}} + \\sum_{k=0}^{i-1} \\Delta x_k + \\tfrac{1}{2}\\Delta x_i $ with $ x_{\\text{left}} = 0 $. Internal faces are located midway between adjacent cell centers, so that the center-to-center distance for the face between cells $ i $ and $ i+1 $ is $ d_{i+\\frac{1}{2}} = \\tfrac{1}{2}(\\Delta x_i + \\Delta x_{i+1}) $. Boundary faces are located at the domain endpoints with distances $ d_{\\frac{1}{2}} = \\tfrac{1}{2}\\Delta x_0 $ and $ d_{N-\\frac{1}{2}} = \\tfrac{1}{2}\\Delta x_{N-1} $ to the nearest cell center.\n\n- Local constitutive law:\n  - At each cell $ i $, the Onsager matrix $ L_i \\in \\mathbb{R}^{2 \\times 2} $ is symmetric positive definite. The flux at a face is computed using a face Onsager matrix $ L_f $ defined by the matrix harmonic mean of the two neighboring cell matrices:\n    $$ L_f = \\left( \\tfrac{1}{2}\\left( L_{\\text{left}}^{-1} + L_{\\text{right}}^{-1} \\right) \\right)^{-1}, $$\n    where for an internal face $ L_{\\text{left}} = L_i $ and $ L_{\\text{right}} = L_{i+1} $. For a boundary face with a single adjacent cell $ i $, use $ L_f = L_i $.\n\n- Discrete flux and assembly:\n  - Let $ u_i = \\begin{bmatrix} \\phi_{1,i} \\\\ \\phi_{2,i} \\end{bmatrix} $ denote the vector of the two potentials at cell $ i $. For an internal face between cells $ i $ and $ i+1 $, define the discrete gradient proxy $ \\Delta u_{i+\\frac{1}{2}} = u_{i+1} - u_i $ and the distance $ d_{i+\\frac{1}{2}} $ as above. The two-component flux vector at the face is\n    $$ J_{i+\\frac{1}{2}} = - L_f \\left( \\frac{\\Delta u_{i+\\frac{1}{2}}}{d_{i+\\frac{1}{2}}} \\right). $$\n    The face contributes the symmetric $ 2 \\times 2 $ block $ S_{i+\\frac{1}{2}} = \\tfrac{L_f}{d_{i+\\frac{1}{2}}} $ to the global stiffness matrix $ K \\in \\mathbb{R}^{2N \\times 2N} $ in a block tridiagonal fashion:\n    - Add $ +S_{i+\\frac{1}{2}} $ to the diagonal block of cell $ i $ and $ +S_{i+\\frac{1}{2}} $ to the diagonal block of cell $ i+1 $.\n    - Add $ -S_{i+\\frac{1}{2}} $ to the off-diagonal block coupling $ i $ to $ i+1 $, and also add $ -S_{i+\\frac{1}{2}} $ to the block coupling $ i+1 $ to $ i $.\n    This assembly yields a symmetric matrix $ K $ by construction.\n  - For a Dirichlet boundary face with boundary potential vector $ u_b \\in \\mathbb{R}^2 $ and adjacent cell $ i $, define $ S_b = \\tfrac{L_f}{d} $ with $ L_f = L_i $ and $ d $ equal to the distance from the cell center to the boundary. Add $ +S_b $ to the diagonal block of cell $ i $. If building a linear system $ K u = f $, then add $ f_i \\mathrel{+}= S_b u_b $. In this task, you only need to assemble $ K $ and the facewise entropy production; you do not need to solve for $ u $.\n\n- Discrete entropy production:\n  - For each face with face matrix $ L_f $ and distance $ d $, define the face entropy production contribution\n    $$ \\sigma_f = \\left( \\frac{\\Delta u}{d} \\right)^\\top L_f \\left( \\frac{\\Delta u}{d} \\right), $$\n    where for internal faces $ \\Delta u = u_{i+1} - u_i $, and for boundary faces $ \\Delta u = u_i - u_b $. The total entropy production is the sum over all faces $ \\sum_f \\sigma_f $, and each $ \\sigma_f $ must be nonnegative.\n\n- Stacking of unknowns:\n  - Stack the unknowns in the order $ [\\phi_{1,0}, \\phi_{2,0}, \\phi_{1,1}, \\phi_{2,1}, \\dots, \\phi_{1,N-1}, \\phi_{2,N-1}] $ so that $ K \\in \\mathbb{R}^{2N \\times 2N} $ is assembled from $ 2 \\times 2 $ blocks.\n\nImplement a program that assembles $ K $ and computes the set $ \\{\\sigma_f\\} $ for the following three test cases. In all cases, take the cross-sectional area as $ 1 $ and treat all quantities as dimensionless.\n\n- Test case $ 1 $ (uniform grid, mild coupling):\n  - $ L_x = 1 $ and $ N = 5 $ with $ \\Delta x_i = 0.2 $ for all $ i $.\n  - Cell centers are at $ x_i \\in \\{0.1, 0.3, 0.5, 0.7, 0.9\\} $.\n  - For cell $ i \\in \\{0,1,2,3,4\\} $, define\n    $$ L_i = \\begin{bmatrix} a_i  c \\\\ c  b_i \\end{bmatrix}, \\quad a_i = 1.0 + 0.2 i, \\quad b_i = 2.0 + 0.1 i, \\quad c = 0.1. $$\n  - Potentials at $ x $ are $ \\phi_1(x) = \\sin(\\pi x) $ and $ \\phi_2(x) = \\cos(\\pi x) $, evaluated at the cell centers.\n  - Dirichlet boundary potentials: at $ x=0 $, $ u_b = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} $; at $ x=1 $, $ u_b = \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix} $.\n\n- Test case $ 2 $ (uniform grid, extreme contrast):\n  - $ L_x = 1 $ and $ N = 4 $ with $ \\Delta x_i = 0.25 $ for all $ i $.\n  - For cell $ i $, let\n    $$ (k_1, k_2) = \\begin{cases} (10^{-3}, 10^{3})  \\text{if } i \\text{ is even}, \\\\ (10^{3}, 10^{-3})  \\text{if } i \\text{ is odd}, \\end{cases} \\quad \\alpha = 0.2, \\quad L_i = \\begin{bmatrix} k_1  \\alpha \\\\ \\alpha  k_2 \\end{bmatrix}. $$\n  - Potentials at $ x $ are $ \\phi_1(x) = x $ and $ \\phi_2(x) = 1 - x $, evaluated at the cell centers $ x_i \\in \\{0.125, 0.375, 0.625, 0.875\\} $.\n  - Dirichlet boundary potentials: at $ x=0 $, $ u_b = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} $; at $ x=1 $, $ u_b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} $.\n\n- Test case $ 3 $ (nonuniform grid, strong but admissible coupling):\n  - $ L_x = 1 $ and $ N = 3 $ with $ \\Delta x = [0.1, 0.7, 0.2] $ so centers are $ x \\in \\{0.05, 0.45, 0.90\\} $.\n  - For cell $ i \\in \\{0,1,2\\} $, define\n    $$ d_{1,i} = 1 + i, \\quad d_{2,i} = 2 + 2 i, \\quad c_i = 0.4 \\sqrt{d_{1,i} d_{2,i}}, \\quad L_i = \\begin{bmatrix} d_{1,i}  c_i \\\\ c_i  d_{2,i} \\end{bmatrix}. $$\n  - Potentials at $ x $ are $ \\phi_1(x) = x^2 $ and $ \\phi_2(x) = -x^2 + x $, evaluated at the cell centers.\n  - Dirichlet boundary potentials: at $ x=0 $, $ u_b = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix} $; at $ x=1 $, $ u_b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} $.\n\nFor each test case, do the following:\n- Assemble the global stiffness matrix $ K \\in \\mathbb{R}^{2N \\times 2N} $ as specified above.\n- Compute the Frobenius norm of the symmetry defect $ \\|K - K^\\top\\|_F $.\n- Compute all face entropy production contributions $ \\sigma_f $ (including boundary faces) and report the minimum value among them.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a two-element list $ [s, m] $ where $ s $ is the Frobenius norm of the symmetry defect as a floating-point number and $ m $ is the minimum face entropy production as a floating-point number. The final output must therefore be a list of three two-element lists in the order of the test cases, for example $ [[s_1, m_1],[s_2, m_2],[s_3, m_3]] $. All reported quantities are dimensionless real numbers.",
            "solution": "The user-provided problem is assessed as **valid**.\n\n### Step 1: Extract Givens\n- **System**: A one-dimensional, two-field coupled diffusive system.\n- **Thermodynamic Framework**: Linear irreversible thermodynamics.\n- **Potentials**: $\\phi_1$, $\\phi_2$.\n- **Fluxes**: $J_1$, $J_2$.\n- **Constitutive Law**: $J = - L X$, where $J = [J_1, J_2]^\\top$ is the flux vector, $X = [\\nabla \\phi_1, \\nabla \\phi_2]^\\top$ is the force vector (gradient of potentials), and $L \\in \\mathbb{R}^{2 \\times 2}$ is the symmetric positive definite Onsager matrix.\n- **Entropy Production**: $\\sigma = X^\\top L X \\ge 0$.\n- **Discretization Method**: Cell-centered Finite Volume Method (FVM).\n- **Domain**: $x \\in [0, L_x]$.\n- **Mesh**: $N$ cells with widths $\\Delta x_i$ for $i \\in \\{0, \\dots, N-1\\}$. Cell centers are $x_i = \\sum_{k=0}^{i-1} \\Delta x_k + \\frac{1}{2}\\Delta x_i$.\n- **Face Geometry**:\n    - Internal face (between cells $i, i+1$): distance $d_{i+\\frac{1}{2}} = \\frac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$.\n    - Boundary faces (at $x=0, L_x$): distance from adjacent cell center $i$ is $d = \\frac{1}{2}\\Delta x_i$.\n- **Face Constitutive Law (Interpolation)**: The face Onsager matrix $L_f$ is the matrix harmonic mean of neighboring cell matrices $L_{\\text{left}}$ and $L_{\\text{right}}$: $L_f = \\left( \\frac{1}{2}\\left( L_{\\text{left}}^{-1} + L_{\\text{right}}^{-1} \\right) \\right)^{-1}$. For a boundary face, $L_f$ is the matrix from the single adjacent cell.\n- **Discrete Flux**: For an internal face between $i$ and $i+1$, $J_{i+\\frac{1}{2}} = - L_f \\frac{u_{i+1} - u_i}{d_{i+\\frac{1}{2}}}$, where $u_i = [\\phi_{1,i}, \\phi_{2,i}]^\\top$.\n- **Global Stiffness Matrix ($K$) Assembly**:\n    - For an internal face, the block $S_{i+\\frac{1}{2}} = \\frac{L_f}{d_{i+\\frac{1}{2}}}$ is assembled as: $K_{i,i} \\mathrel{+}= S_{i+\\frac{1}{2}}$, $K_{i+1,i+1} \\mathrel{+}= S_{i+\\frac{1}{2}}$, $K_{i,i+1} \\mathrel{+}= -S_{i+\\frac{1}{2}}$, $K_{i+1,i} \\mathrel{+}= -S_{i+\\frac{1}{2}}$.\n    - For a Dirichlet boundary face adjacent to cell $i$, the block $S_b = \\frac{L_f}{d}$ is assembled as: $K_{i,i} \\mathrel{+}= S_b$.\n- **Discrete Entropy Production**: For any face, $\\sigma_f = \\left( \\frac{\\Delta u}{d} \\right)^\\top L_f \\left( \\frac{\\Delta u}{d} \\right)$, where for internal faces $\\Delta u = u_{i+1} - u_i$ and for boundary faces $\\Delta u = u_i - u_b$.\n- **Unknown Stacking**: $u = [\\phi_{1,0}, \\phi_{2,0}, \\dots, \\phi_{1,N-1}, \\phi_{2,N-1}]^\\top$.\n- **Tasks**: For each test case, assemble $K$, compute the Frobenius norm of its symmetry defect, $\\|K - K^\\top\\|_F$, and find the minimum face entropy production, $\\min(\\{\\sigma_f\\})$.\n- **Test Cases**: Three fully specified test cases are provided with all necessary parameters (geometry, cell matrices $L_i$, potential fields $\\phi_k$, and boundary conditions $u_b$).\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on the well-established principles of linear irreversible thermodynamics, specifically the Onsager reciprocal relations. The numerical method (FVM with matrix harmonic averaging) is a standard and thermodynamically consistent approach for discretizing such coupled transport phenomena. The properties of the Onsager matrix ($L=L^\\top$, positive definiteness) and their connection to the second law of thermodynamics (non-negative entropy production) are correctly stated.\n2.  **Well-Posed**: The problem is well-posed. All required data, constitutive relations, and discretization rules are provided. The tasks are specific and algorithmic. A unique solution exists for the specified computations.\n3.  **Objective**: The problem is stated in precise, objective mathematical language, free of any subjectivity or ambiguity.\n4.  **Flaw Check**:\n    - **Scientific Unsoundness**: None. The use of the matrix harmonic mean for $L_f$ correctly preserves the symmetry and positive definiteness of the cell matrices $L_i$, which in turn ensures the discrete system is thermodynamically consistent. The assembly rule for $K$ is designed to produce a symmetric matrix. The expression for $\\sigma_f$ is a quadratic form that must be non-negative if $L_f$ is positive semi-definite. A quick check of the provided $L_i$ matrices confirms they are all symmetric and positive definite for all test cases.\n    - **Non-Formalizable**: None. The problem is a formal numerical methods task.\n    - **Incomplete/Contradictory**: The problem is self-contained. There is a minor inconsistency in Test Case 3 where the pre-computed list of cell centers gives $x_2=0.85$ while the defining formula gives $x_2=0.9$. This is a trivial typo, and the defining formula is the unambiguous rule to follow. The problem remains solvable.\n    - **Unrealistic/Infeasible**: None. The parameters are within physically plausible (dimensionless) ranges.\n    - **Ill-Posed**: None. The problem is well-structured.\n    - **Trivial/Tautological**: None. The task requires a non-trivial implementation of a numerical algorithm.\n    - **Outside Verifiability**: None. The results are deterministic and verifiable by computation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Design\nThe solution implements a one-dimensional, cell-centered finite volume scheme for a coupled two-field system governed by Onsager's linear irreversible thermodynamics. The core design ensures that the discrete system preserves fundamental physical properties of the continuous system: reciprocity and non-negative entropy production.\n\n1.  **Thermodynamic Consistency**: The continuous system is characterized by a symmetric, positive-definite Onsager matrix $L$, which guarantees reciprocity ($L=L^\\top$) and non-negative entropy production ($\\sigma = X^\\top L X \\ge 0$). The numerical method must preserve these properties at the discrete level.\n\n2.  **Discrete Reciprocity and Positivity**: At each computational face, the effective Onsager matrix $L_f$ must be symmetric and positive definite. The problem specifies using the matrix harmonic mean: $L_f = \\left( \\frac{1}{2}(L_{\\text{left}}^{-1} + L_{\\text{right}}^{-1}) \\right)^{-1}$. This choice is crucial because:\n    - If $L_{\\text{left}}$ and $L_{\\text{right}}$ are symmetric, so are their inverses. The sum of symmetric matrices is symmetric, and the inverse of a symmetric matrix is symmetric. Thus, $L_f$ is guaranteed to be symmetric.\n    - Similarly, if the cell matrices are positive definite, their inverses are also positive definite. The sum of positive definite matrices is positive definite, and the inverse of a positive definite matrix is positive definite. Thus, $L_f$ is guaranteed to be positive definite.\n    This ensures that the discrete constitutive law at each face is physically consistent.\n\n3.  **Global System Symmetry**: The global stiffness matrix $K$ represents the coupling between all degrees of freedom. For a system rooted in a variational principle or potential theory, this matrix should be symmetric. The specified assembly rule for an internal face between cells $i$ and $i+1$ involves adding the symmetric block $S_f = L_f / d_f$ to the diagonal blocks $K_{i,i}$ and $K_{i+1,i+1}$, and subtracting it from the off-diagonal blocks $K_{i,i+1}$ and $K_{i+1,i}$. Since $K_{i,i+1} = -S_f$ and $K_{i+1,i} = -S_f = (-S_f)^\\top$, this assembly method constructs a block-symmetric, and therefore globally symmetric, matrix $K$. The implementation verifies this by computing $\\|K - K^\\top\\|_F$, which should be zero up to floating-point precision.\n\n4.  **Discrete Second Law**: The total entropy production is the sum of contributions from each face. The contribution from a single face, $\\sigma_f = (\\frac{\\Delta u}{d})^\\top L_f (\\frac{\\Delta u}{d})$, is a quadratic form. Since step 2 guarantees $L_f$ is positive definite, $\\sigma_f$ is guaranteed to be non-negative for any potential difference $\\Delta u$. This confirms that the discretization respects the second law of thermodynamics at a local, per-face level.\n\nThe implementation proceeds by first setting up the geometry and material properties for each test case. It then iterates through all computational faces (internal and boundary), calculates the corresponding face matrix $L_f$ and stiffness block $S_f$, and assembles $S_f$ into the global matrix $K$. Simultaneously, it computes the face entropy production $\\sigma_f$. Finally, it calculates the required metrics: the symmetry defect of $K$ and the minimum value of $\\sigma_f$ across all faces.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all three test cases.\n    \"\"\"\n\n    def run_case(N, delta_x_values, L_i_func, phi_funcs, u_b_left, u_b_right):\n        \"\"\"\n        Processes a single test case, assembles the stiffness matrix K,\n        and computes the required metrics.\n        \"\"\"\n        # 1. Setup Geometry and Fields\n        delta_x = np.array(delta_x_values)\n        # The problem defines cell centers as x_i = sum_{k=0}^{i-1} dx_k + 0.5*dx_i\n        # which can be computed efficiently.\n        x_centers = np.cumsum(delta_x) - 0.5 * delta_x\n\n        L_i_list = [L_i_func(i) for i in range(N)]\n        u_i_list = [np.array([phi_funcs[0](x), phi_funcs[1](x)]) for x in x_centers]\n\n        # 2. Initialize\n        K = np.zeros((2 * N, 2 * N))\n        sigmas = []\n\n        # 3. Loop over Internal Faces (i to i+1)\n        for i in range(N - 1):\n            L_left, L_right = L_i_list[i], L_i_list[i+1]\n            u_left, u_right = u_i_list[i], u_i_list[i+1]\n\n            d_face = 0.5 * (delta_x[i] + delta_x[i+1])\n\n            # Face matrix (matrix harmonic mean)\n            L_left_inv = np.linalg.inv(L_left)\n            L_right_inv = np.linalg.inv(L_right)\n            L_f = np.linalg.inv(0.5 * (L_left_inv + L_right_inv))\n\n            # Stiffness block\n            S_f = L_f / d_face\n\n            # Assembly into global K\n            idx1_start, idx1_end = 2 * i, 2 * i + 2\n            idx2_start, idx2_end = 2 * (i + 1), 2 * (i + 1) + 2\n            K[idx1_start:idx1_end, idx1_start:idx1_end] += S_f\n            K[idx2_start:idx2_end, idx2_start:idx2_end] += S_f\n            K[idx1_start:idx1_end, idx2_start:idx2_end] -= S_f\n            K[idx2_start:idx2_end, idx1_start:idx1_end] -= S_f\n\n            # Entropy production\n            delta_u = u_right - u_left\n            X_f = delta_u / d_face\n            sigma_f = X_f.T @ L_f @ X_f\n            sigmas.append(sigma_f)\n\n        # 4. Handle Boundary Faces\n        # Left boundary (x=0, adjacent to cell 0)\n        L_f_left = L_i_list[0]\n        d_left = 0.5 * delta_x[0]\n        S_b_left = L_f_left / d_left\n        K[0:2, 0:2] += S_b_left\n        \n        delta_u_left = u_i_list[0] - u_b_left\n        X_f_left = delta_u_left / d_left\n        sigma_f_left = X_f_left.T @ L_f_left @ X_f_left\n        sigmas.append(sigma_f_left)\n\n        # Right boundary (x=Lx, adjacent to cell N-1)\n        L_f_right = L_i_list[N - 1]\n        d_right = 0.5 * delta_x[N-1]\n        S_b_right = L_f_right / d_right\n        K[2*(N-1):2*N, 2*(N-1):2*N] += S_b_right\n\n        delta_u_right = u_i_list[N-1] - u_b_right\n        X_f_right = delta_u_right / d_right\n        sigma_f_right = X_f_right.T @ L_f_right @ X_f_right\n        sigmas.append(sigma_f_right)\n\n        # 5. Compute final metrics\n        s = np.linalg.norm(K - K.T, 'fro')\n        m = np.min(sigmas)\n\n        return [s, m]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 5, \"delta_x\": [0.2] * 5,\n            \"L_i_func\": lambda i: np.array([[1.0 + 0.2 * i, 0.1], [0.1, 2.0 + 0.1 * i]]),\n            \"phi_funcs\": [lambda x: np.sin(np.pi * x), lambda x: np.cos(np.pi * x)],\n            \"u_b_left\": np.array([0.0, 1.0]), \"u_b_right\": np.array([0.0, -1.0])\n        },\n        # Test Case 2\n        {\n            \"N\": 4, \"delta_x\": [0.25] * 4,\n            \"L_i_func\": lambda i: np.array([[1e-3, 0.2], [0.2, 1e3]]) if i % 2 == 0 else np.array([[1e3, 0.2], [0.2, 1e-3]]),\n            \"phi_funcs\": [lambda x: x, lambda x: 1.0 - x],\n            \"u_b_left\": np.array([0.0, 1.0]), \"u_b_right\": np.array([1.0, 0.0])\n        },\n        # Test Case 3\n        {\n            \"N\": 3, \"delta_x\": [0.1, 0.7, 0.2],\n            \"L_i_func\": lambda i: np.array([\n                [1.0 + i, 0.4 * np.sqrt((1.0 + i) * (2.0 + 2.0 * i))],\n                [0.4 * np.sqrt((1.0 + i) * (2.0 + 2.0 * i)), 2.0 + 2.0 * i]\n            ]),\n            \"phi_funcs\": [lambda x: x**2, lambda x: -x**2 + x],\n            \"u_b_left\": np.array([0.0, 0.0]), \"u_b_right\": np.array([1.0, 0.0])\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        result = run_case(case_data[\"N\"], case_data[\"delta_x\"], case_data[\"L_i_func\"],\n                          case_data[\"phi_funcs\"], case_data[\"u_b_left\"], case_data[\"u_b_right\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces, so we remove them\n    # to match the concise output format '[[s,m],[s,m]]'.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        }
    ]
}