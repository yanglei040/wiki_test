{
    "hands_on_practices": [
        {
            "introduction": "在多物理场仿真中，选择单向耦合还是双向耦合是在计算成本和求解精度之间做出的基本权衡。本练习提供了一种量化方法，用于评估将双向耦合问题简化为单向时所引入的误差。通过一个简化的线性基准问题，我们将动手计算该误差，并探索它与系统内在耦合强度指标之间的关系，从而加深对耦合近似后果的理解。",
            "id": "3500851",
            "problem": "考虑一个用于双场多物理场系统的无量纲线性化基准，该基准区分单向耦合和双向耦合，以及界面耦合和体耦合。设状态向量为 $x = [u, T]^\\top$，代表在计算域上聚合的两个标量场，控制线性系统为 $J x = f$，其中\n$$\nJ = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}, \\quad f = \\begin{bmatrix} f_u \\\\ f_T \\end{bmatrix},\n$$\n其中 $a > 0$ 和 $d > 0$ 代表自耦合（对角）类刚度项，而 $b$ 和 $c$ 代表非对角耦合贡献。界面耦合由高度不对称的非对角量值表示（例如 $|b| \\ll |c|$），而体耦合由可比较的非对角量值表示（例如 $|b| \\approx |c|$）。双向耦合解是完整系统 $J x = f$ 的精确解 $x^{\\text{two}}$。单向耦合解 $x^{\\text{one}}$ 假设 $u$ 驱动 $T$ 但反之则不然，它是通过先求解 $a u^{\\text{one}} = f_u$ 然后再求解 $c u^{\\text{one}} + d T^{\\text{one}} = f_T$ 得到的。\n\n您的任务是量化从双向耦合切换到单向耦合所引入的误差，并将其与耦合强度度量以及将单向解代入完整双向方程时观测到的残差相关联。完全使用无量纲量进行计算。不涉及角度。不需要物理单位。\n\n对于每个测试用例，执行以下操作：\n- 通过求解 $J x = f$ 计算双向解 $x^{\\text{two}}$。\n- 通过求解 $a u^{\\text{one}} = f_u$ 然后求解 $c u^{\\text{one}} + d T^{\\text{one}} = f_T$ 计算单向解 $x^{\\text{one}}$。\n- 计算残差向量 $r = J x^{\\text{one}} - f$。\n- 计算误差向量 $e = x^{\\text{two}} - x^{\\text{one}}$ 及其欧几里得范数 $\\|e\\|_2$。\n- 计算残差的欧几里得范数 $\\|r\\|_2$。\n- 计算耦合强度度量\n$$\n\\Gamma = \\sqrt{\\left(\\frac{|b|}{a}\\right)\\left(\\frac{|c|}{d}\\right)}.\n$$\n- 使用 $J$ 的最小奇异值 $\\sigma_{\\min}$ 计算基于奇异值分解 (SVD) 的逆矩阵的诱导二范数 $\\|J^{-1}\\|_2$，然后计算乘积 $\\|J^{-1}\\|_2 \\cdot \\|r\\|_2$。\n\n测试套件：\n- 情况 $1$（弱、对称、类体耦合）：$a = 1.0$, $d = 1.0$, $b = 0.05$, $c = 0.05$, $f_u = 1.0$, $f_T = 0.0$。\n- 情况 $2$（强、对称、类体耦合）：$a = 1.0$, $d = 1.0$, $b = 0.6$, $c = 0.6$, $f_u = 1.0$, $f_T = 0.0$。\n- 情况 $3$（不对称、类界面耦合）：$a = 1.0$, $d = 1.0$, $b = 0.02$, $c = 0.5$, $f_u = 1.0$, $f_T = 0.5$。\n- 情况 $4$（近奇异强耦合）：$a = 1.0$, $d = 1.0$, $b = 0.95$, $c = 0.95$, $f_u = 1.0$, $f_T = 1.0$。\n- 情况 $5$（一个非对角元素为零，类界面耦合）：$a = 1.0$, $d = 1.0$, $b = 0.0$, $c = 0.5$, $f_u = 1.0$, $f_T = 1.0$。\n\n答案规格：\n- 对于每个测试用例，生成一个列表 $[E, R, \\Gamma, B]$，其中 $E = \\|e\\|_2$，$R = \\|r\\|_2$，$\\Gamma$ 如上定义，且 $B = \\|J^{-1}\\|_2 \\cdot R$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，有效的输出格式为 $[[E_1,R_1,\\Gamma_1,B_1],[E_2,R_2,\\Gamma_2,B_2],\\ldots]$。\n\n您的实现必须解决所有情况，并以上述确切格式打印单行聚合结果。",
            "solution": "该问题是有效的，因为它在科学上基于线性代数和耦合系统数值方法的理论，对于所有测试用例，其矩阵都是可逆的，因此是适定的，并且使用精确的数学语言进行了客观陈述。我们现在开始进行求解。\n\n问题的核心是分析双场多物理场系统中单向耦合近似所引入的误差。该系统由线性方程 $J x = f$ 描述，其中状态向量为 $x = [u, T]^\\top$，系统矩阵为 $J = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}$，驱动向量为 $f = [f_u, f_T]^\\top$。对角项 $a > 0$ 和 $d > 0$ 是给定的。\n\n首先，我们定义要比较的两个解。\n\n**双向耦合解**，记为 $x^{\\text{two}} = [u^{\\text{two}}, T^{\\text{two}}]^\\top$，是完整系统的精确解。它通过求解完整的方程组得到，其矩阵形式为：\n$$\n\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\begin{bmatrix} u^{\\text{two}} \\\\ T^{\\text{two}} \\end{bmatrix} = \\begin{bmatrix} f_u \\\\ f_T \\end{bmatrix}\n$$\n该解可以形式上写为 $x^{\\text{two}} = J^{-1} f$，并通过标准的线性求解器进行数值计算。\n\n**单向耦合解** $x^{\\text{one}} = [u^{\\text{one}}, T^{\\text{one}}]^\\top$ 基于这样的假设：场 $u$ 影响 $T$，但 $T$ 不影响 $u$。这通过从第一个方程中移除耦合项 $b$（实际上是将其设置为 $0$）来简化问题。这导致了一个顺序求解过程：\n1. 从第一个方程求解 $u^{\\text{one}}$，忽略 $T^{\\text{one}}$ 的影响：\n   $$\n   a u^{\\text{one}} = f_u \\implies u^{\\text{one}} = \\frac{f_u}{a}\n   $$\n2. 将已知的 $u^{\\text{one}}$ 代入第二个方程并求解 $T^{\\text{one}}$：\n   $$\n   c u^{\\text{one}} + d T^{\\text{one}} = f_T \\implies T^{\\text{one}} = \\frac{f_T - c u^{\\text{one}}}{d}\n   $$\n\n接下来，我们定义用于量化此近似效果的度量。\n\n**误差向量** $e$ 是精确的双向解与近似的单向解之间的差：\n$$\ne = x^{\\text{two}} - x^{\\text{one}}\n$$\n此误差的大小由其欧几里得范数 $E = \\|e\\|_2$ 衡量。\n\n**残差向量** $r$ 是通过将近似解 $x^{\\text{one}}$ 代回原始的双向系统方程，并求其与驱动向量 $f$ 的差得到的：\n$$\nr = J x^{\\text{one}} - f\n$$\n我们来分析 $r = [r_u, r_T]^\\top$ 的分量。第一个分量是：\n$$\nr_u = a u^{\\text{one}} + b T^{\\text{one}} - f_u\n$$\n代入 $u^{\\text{one}} = f_u/a$，我们得到：\n$$\nr_u = a \\left(\\frac{f_u}{a}\\right) + b T^{\\text{one}} - f_u = f_u + b T^{\\text{one}} - f_u = b T^{\\text{one}}\n$$\n第二个分量是：\n$$\nr_T = c u^{\\text{one}} + d T^{\\text{one}} - f_T\n$$\n根据 $T^{\\text{one}}$ 的定义，我们有 $c u^{\\text{one}} + d T^{\\text{one}} = f_T$。因此：\n$$\nr_T = f_T - f_T = 0\n$$\n所以，残差向量具有一个特定的结构：$r = [b T^{\\text{one}}, 0]^\\top$。残差的大小由其欧几里得范数衡量，$R = \\|r\\|_2 = \\sqrt{(b T^{\\text{one}})^2 + 0^2} = |b T^{\\text{one}}|$。这表明，只有当被忽略的耦合项 $b$ 非零时，残差才非零。\n\n**耦合强度度量** $\\Gamma$ 定义为缩放后的非对角项的几何平均值：\n$$\n\\Gamma = \\sqrt{\\left(\\frac{|b|}{a}\\right)\\left(\\frac{|c|}{d}\\right)}\n$$\n该度量提供了系统耦合强度的一种启发式度量。\n\n最后，我们将误差和残差关联起来。根据它们的定义，我们有 $J x^{\\text{two}} = f$ 和 $J x^{\\text{one}} = r + f$。将这两个方程相减得到：\n$$\nJ x^{\\text{two}} - J x^{\\text{one}} = f - (r+f)\n$$\n$$\nJ (x^{\\text{two}} - x^{\\text{one}}) = -r\n$$\n$$\nJ e = -r \\implies e = -J^{-1} r\n$$\n取欧几里得范数并应用诱导矩阵范数的性质，可得出众所知的误差界：\n$$\n\\|e\\|_2 = \\|J^{-1} r\\|_2 \\le \\|J^{-1}\\|_2 \\|r\\|_2\n$$\n问题要求计算这个界，$B = \\|J^{-1}\\|_2 \\cdot R$。项 $\\|J^{-1}\\|_2$ 是矩阵 $J^{-1}$ 的诱导2-范数（或谱范数）。该范数等于 $J^{-1}$ 的最大奇异值，也就是 $J$ 的最小奇异值 $\\sigma_{\\min}(J)$ 的倒数。\n$$\n\\|J^{-1}\\|_2 = \\frac{1}{\\sigma_{\\min}(J)}\n$$\n$J$ 的奇异值通过奇异值分解 (SVD) 求得。\n\n每个测试用例的算法如下：\n1.  根据给定的参数 $a, b, c, d, f_u, f_T$ 构建矩阵 $J$ 和向量 $f$。\n2.  使用顺序公式计算 $x^{\\text{one}} = [u^{\\text{one}}, T^{\\text{one}}]^\\top$。\n3.  通过求解线性系统 $J x = f$ 计算 $x^{\\text{two}}$。\n4.  计算误差向量 $e = x^{\\text{two}} - x^{\\text{one}}$ 及其范数 $E = \\|e\\|_2$。\n5.  计算残差向量 $r = J x^{\\text{one}} - f$ 及其范数 $R = \\|r\\|_2$。\n6.  计算耦合度量 $\\Gamma$。\n7.  对 $J$ 执行 SVD 以找到 $\\sigma_{\\min}(J)$。\n8.  计算界 $B = (1/\\sigma_{\\min}(J)) \\cdot R$。\n9.  收集四个值 $[E, R, \\Gamma, B]$ 作为最终输出。\n对所有提供的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The scipy library is not required for this problem.\n\ndef solve():\n    \"\"\"\n    Solves the multiphysics coupling benchmark for a set of test cases.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (a, d, b, c, f_u, f_T)\n    test_cases = [\n        # Case 1 (weak, symmetric volume-like coupling)\n        (1.0, 1.0, 0.05, 0.05, 1.0, 0.0),\n        # Case 2 (strong, symmetric volume-like coupling)\n        (1.0, 1.0, 0.6, 0.6, 1.0, 0.0),\n        # Case 3 (asymmetric interface-like coupling)\n        (1.0, 1.0, 0.02, 0.5, 1.0, 0.5),\n        # Case 4 (near-singular strong coupling)\n        (1.0, 1.0, 0.95, 0.95, 1.0, 1.0),\n        # Case 5 (one off-diagonal zero, interface-like)\n        (1.0, 1.0, 0.0, 0.5, 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, d, b, c, f_u, f_T = case\n\n        # 1. Define J matrix and f vector\n        J = np.array([[a, b], [c, d]])\n        f = np.array([f_u, f_T])\n\n        # 2. Compute the two-way coupled solution x_two\n        # This is the exact solution to Jx = f\n        x_two = np.linalg.solve(J, f)\n\n        # 3. Compute the one-way coupled solution x_one\n        # Assumes u drives T, but not vice versa.\n        u_one = f_u / a\n        T_one = (f_T - c * u_one) / d\n        x_one = np.array([u_one, T_one])\n\n        # 4. Compute the residual vector r and its norm R\n        # r = J * x_one - f\n        r = J @ x_one - f\n        R = np.linalg.norm(r, ord=2)\n\n        # 5. Compute the error vector e and its norm E\n        # e = x_two - x_one\n        e = x_two - x_one\n        E = np.linalg.norm(e, ord=2)\n\n        # 6. Compute the coupling strength metric Gamma\n        Gamma = np.sqrt((np.abs(b) / a) * (np.abs(c) / d))\n\n        # 7. Compute the SVD-based bound B\n        # B = ||J_inv||_2 * ||r||_2\n        # ||J_inv||_2 = 1 / sigma_min(J)\n        singular_values = np.linalg.svd(J, compute_uv=False)\n        sigma_min = singular_values[-1] # SVD returns values in descending order\n\n        # Handle the case where the matrix is singular (sigma_min is zero).\n        # For this problem set, all matrices are invertible.\n        if sigma_min > 1e-15:\n            norm_J_inv = 1.0 / sigma_min\n            B = norm_J_inv * R\n        else:\n            # If r is nearly zero, the bound is 0. Otherwise, it's infinite.\n            B = 0.0 if R  1e-15 else np.inf\n\n        results.append([E, R, Gamma, B])\n\n    # Format the output as a single-line string: [[...],[...],...]\n    # Create a list of string representations for each inner list\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    # Join the inner list strings and enclose in the outer brackets\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在分析了稳态问题中的精度损失后，我们转向瞬态仿真中一个更为关键的问题：数值稳定性。这个练习将通过一个理论推导，揭示为何看似简单的显式分区格式在强双向反馈下会变得不稳定。理解这种失效模式对于设计可靠的多物理场求解器至关重要，并为选择更鲁棒的隐式或强耦合算法提供了理论依据。",
            "id": "3500848",
            "problem": "一对线性耦合的物理子系统，在稳态附近进行一致线性化和空间离散化后，可用以下一阶常微分方程建模：\n$$\n\\dot{x}(t) \\;=\\; -a\\,x(t) \\;+\\; b\\,y(t),\\qquad \\dot{y}(t) \\;=\\; -c\\,y(t) \\;+\\; d\\,x(t),\n$$\n其中 $a0$ 和 $c0$ 表示每个子系统的内在耗散（弛豫），$b$ 和 $d$ 表示物理间耦合的强度。考虑一个分区显式 Gauss–Seidel 耦合方案，采用步长为 $h0$ 的前向欧拉时间步进：使用前一时间层的 $y$ 更新 $x$，然后使用新更新的 $x$ 更新 $y$。该方案将 $(x^n,y^n)$ 映射到 $(x^{n+1},y^{n+1})$。将 $d=0$ 的情况解释为单向耦合（子系统 $y$ 驱动 $x$，但反之不然），将 $b\\neq 0, d\\neq 0$ 的情况解释为双向耦合。\n\n要求您在离散时间线性稳定性的意义上分析稳定性（即单步更新矩阵的两个特征值都严格位于复平面的单位圆盘内部），并将分析与界面耦合和体积耦合联系起来。请从第一性原理出发，不要假设任何关于更新矩阵特征值的现成公式。相反，您需要推导出更新矩阵，并直接根据其特征多项式进行推理。\n\n1. 推导 $2\\times 2$ 线性更新矩阵 $M(a,b,c,d,h)$，使得 \n$$\n\\begin{pmatrix} x^{n+1} \\\\[4pt] y^{n+1} \\end{pmatrix} \\;=\\; M(a,b,c,d,h)\\,\\begin{pmatrix} x^{n} \\\\[4pt] y^{n} \\end{pmatrix}.\n$$\n\n2. 使用 $M(a,b,c,d,h)$ 的特征多项式和 $2\\times 2$ 实矩阵的离散时间稳定性判据，证明对于 $d=0$ 的单向耦合，只要解耦的前向欧拉步是稳定的（即 $0ha2$ 且 $0hc2$），则耦合方案对于任何耦合强度 $b$ 都是稳定的。\n\n3. 同样使用特征多项式，证明对于双向耦合，如果物理耦合参数满足 $bd  ac$，则该方案对于满足解耦前向欧拉稳定性条件的**任意**步长 $h0$ 都是无条件不稳定的。您可以通过论证更新矩阵的一个特征值在 $h$ 从 $0$ 增加时立即离开单位圆盘来做到这一点。\n\n4. 简要讨论 $bd  ac$ 这一条件如何与体积耦合和界面耦合的概念联系起来。",
            "solution": "我们从给定的线性化模型开始\n$$\n\\dot{x}(t) \\;=\\; -a\\,x(t) \\;+\\; b\\,y(t),\\qquad \\dot{y}(t) \\;=\\; -c\\,y(t) \\;+\\; d\\,x(t),\n$$\n其中 $a0$ 且 $c0$。采用步长为 $h0$ 的前向欧拉时间步进的分区显式 Gauss–Seidel 更新首先使用时间层 $n$ 的 $y$ 推进 $x$，然后使用时间层 $n+1$ 的已更新的 $x$ 推进 $y$。\n\n对第一个方程应用前向欧拉法，\n$$\nx^{n+1} \\;=\\; x^{n} \\;+\\; h\\bigl(-a\\,x^{n} + b\\,y^{n}\\bigr) \\;=\\; (1 - h a)\\,x^{n} + h b\\,y^{n}.\n$$\n接下来，使用 $x^{n+1}$ 和 $y^{n}$ 推进 $y$：\n$$\ny^{n+1} \\;=\\; y^{n} \\;+\\; h\\bigl(-c\\,y^{n} + d\\,x^{n+1}\\bigr)\n\\;=\\; y^{n} + h\\bigl(-c\\,y^{n} + d\\bigl((1-h a)\\,x^{n} + h b\\,y^{n}\\bigr)\\bigr).\n$$\n合并各项得到\n$$\ny^{n+1} \\;=\\; \\bigl(1 - h c + h^{2} b d\\bigr)\\,y^{n} \\;+\\; h d\\,(1 - h a)\\,x^{n}.\n$$\n因此，将 $(x^{n},y^{n})$ 映射到 $(x^{n+1},y^{n+1})$ 的线性更新矩阵 $M(a,b,c,d,h)$ 为\n$$\nM(a,b,c,d,h) \\;=\\;\n\\begin{pmatrix}\n1 - h a  h b \\\\\nh d\\,(1 - h a)  1 - h c + h^{2} b d\n\\end{pmatrix}.\n$$\n\n为了分析离散时间稳定性，我们考虑 $M$ 的特征多项式，\n$$\np(\\lambda) \\;=\\; \\lambda^{2} - \\operatorname{tr}(M)\\,\\lambda + \\det(M).\n$$\n计算迹：\n$$\n\\operatorname{tr}(M) \\;=\\; (1 - h a) + (1 - h c + h^{2} b d) \\;=\\; 2 - h(a + c) + h^{2} b d.\n$$\n计算行列式：\n$$\n\\det(M) \\;=\\; (1 - h a)\\,(1 - h c + h^{2} b d) - (h b)\\bigl(h d\\,(1 - h a)\\bigr).\n$$\n最后两项相互抵消：\n$$\n\\det(M) \\;=\\; (1 - h a)\\Bigl[(1 - h c + h^{2} b d) - h^{2} b d\\Bigr] \\;=\\; (1 - h a)\\,(1 - h c).\n$$\n这种显式交错格式的一个显著结构特性是 $\\det(M)$ 与耦合强度 $b$ 和 $d$ 无关。\n\n对于一个实 $2\\times 2$ 矩阵，离散时间线性稳定性（两个特征值都严格位于单位圆盘内部）由其特征多项式 $p(\\lambda) = \\lambda^{2} + \\alpha_{1}\\lambda + \\alpha_{0}$ 上的 Jury 判据来刻画；用迹和行列式表示，其充要不等式为\n$$\n1 - \\operatorname{tr}(M) + \\det(M) \\;\\; 0,\\qquad\n1 + \\operatorname{tr}(M) + \\det(M) \\;\\; 0,\\qquad\n1 - \\det(M) \\;\\; 0.\n$$\n\n首先，考虑 $d=0$ 的单向耦合。更新矩阵变为上三角矩阵：\n$$\nM(a,b,c,0,h) \\;=\\; \\begin{pmatrix} 1 - h a  h b \\\\ 0  1 - h c \\end{pmatrix},\n$$\n因此其特征值就是 $\\lambda_{1} = 1 - h a$ 和 $\\lambda_{2} = 1 - h c$。两个特征值都严格位于单位圆盘内部的条件是 $|1 - h a|  1$ 和 $|1 - h c|  1$，这等价于 $0  h a  2$ 和 $0  h c  2$。因此，只要解耦的前向欧拉步本身是稳定的，单向耦合就稳定，而与 $b$ 的值无关。\n\n接下来，考虑 $b\\neq 0$ 和 $d\\neq 0$ 的双向耦合。为了检测特征值在单位圆上穿过 $+1$ 的情况，计算特征多项式在 $\\lambda = 1$ 处的值：\n$$\np(1) \\;=\\; 1 - \\operatorname{tr}(M) + \\det(M).\n$$\n使用上面的表达式，\n\\begin{align*}\np(1)\n= 1 - \\bigl(2 - h(a + c) + h^{2} b d\\bigr) + (1 - h a)(1 - h c) \\\\\n= \\bigl(1 - 2 + 1\\bigr) + h(a + c) - h^{2} b d - \\bigl(h a + h c - h^{2} a c\\bigr) \\\\\n= h^{2} a c - h^{2} b d \\\\\n= h^{2}\\,(a c - b d).\n\\end{align*}\n因此，$p(1)=0$ 当且仅当 $b d = a c$。在基准的解耦步长条件 $0ha2$ 和 $0hc2$ 下，我们有 $\\det(M) = (1-ha)(1-hc)$ 满足 $|\\det(M)|1$。这意味着两个特征值的乘积的模小于1，因此没有特征值等于1（除非另一个是1/det(M)，但这在 $h\\to 0$ 时是不可能的）。更确切地说，稳定性判据的第一个条件 $p(1)  0$ 要求 $h^{2}(ac - bd)  0$，这等价于 $ac  bd$。如果 $bd  ac$，则 $p(1)  0$。对于非常小的 $h0$，矩阵 $M$ 接近单位矩阵，其特征值都在单位圆内部。如果 $bd  ac$，那么对于任何 $h0$（无论多小），我们都有 $p(1)  0$。由于 $p(\\lambda)$ 是关于 $h$ 的连续函数，且 $p(1)$ 从 $h=0$ 时的 $0$ 变为负值，这意味着当 $h$ 从零增加时，必然有一个实特征值穿过 $+1$（从小于1到大于1），从而导致不稳定。因此，条件 $bd  ac$ 意味着该方案对于任何满足解耦稳定性条件的 $h0$ 都是无条件不稳定的。\n\n最后，讨论与体积和界面耦合的联系。在界面耦合问题中，一个场的全部影响通过一个低维流形传递给另一个场。通常，一个方向的耦合（例如，流体对固体的作用，$d$）比另一个方向（例如，固体对流体的反作用，$b$）要强得多，或者一个耦合系数非常小。因此，乘积 $bd$ 可能很小。例如，在流固耦合中，固体对流体的反作用（通过改变边界）可能比流体对固体的直接加载要弱，这可以用小的 $b$ 来建模。相比之下，在体积耦合中，两个场在整个域中相互作用，耦合系数 $b$ 和 $d$ 可能量级相当。在这种情况下，$bd$ 的值可能很大，超过耗散项的乘积 $ac$ 的可能性更高。因此，$bd  ac$ 的不稳定性条件在对称的、强双向的体积耦合问题中比在高度不对称的界面耦合问题中更有可能被触发。这与数值实践中的观察结果是一致的，即显式分区方案在处理强体积耦合（如附加质量效应）时尤其容易失败。",
            "answer": "此题为理论证明题，其完整解答已在“解答”部分给出。"
        },
        {
            "introduction": "综合前两个练习中关于精度、成本和耦合强度的概念，我们将在本节设计一个更高级的“智能”求解策略。这个最终的实践练习要求我们创建一个自适应算法，它能根据一个实时的敏感度指标，在简单的单向耦合和更精确的双向耦合之间动态切换。这种方法反映了现代计算工程中的一个重要趋势，即通过适应问题自身特性来优化求解性能。",
            "id": "3500789",
            "problem": "要求您对一个线性化的双物理场界面问题，形式化、实现并评估一个自适应耦合模式开关。该开关基于界面敏感度指标，决定采用单向耦合还是双向耦合。目标是展示精度-成本权衡与耦合模式和界面相互作用强度的函数关系，涵盖界面（低秩）和体积（满秩）两种耦合情况。\n\n考虑一个流场和结构场之间的线性化、稳态、耦合问题。设离散的流场未知量为 $u_f \\in \\mathbb{R}^{n_f}$，离散的结构场未知量为 $u_s \\in \\mathbb{R}^{n_s}$。流体和结构的残差定义为\n$$\nR_f(u_f,u_s) = A_f u_f - b_f - C u_s,\\quad\nR_s(u_f,u_s) = A_s u_s - b_s - D u_f,\n$$\n其中 $A_f \\in \\mathbb{R}^{n_f \\times n_f}$ 和 $A_s \\in \\mathbb{R}^{n_s \\times n_s}$ 是可逆的对称正定矩阵，$C \\in \\mathbb{R}^{n_f \\times n_s}$ 和 $D \\in \\mathbb{R}^{n_s \\times n_f}$ 是耦合矩阵，$b_f \\in \\mathbb{R}^{n_f}$ 和 $b_s \\in \\mathbb{R}^{n_s}$ 是已知的载荷向量。精确的整体解 $\\left(u_f^\\star, u_s^\\star\\right)$ 求解块线性系统\n$$\n\\begin{bmatrix}\nA_f  -C\\\\\n-D  A_s\n\\end{bmatrix}\n\\begin{bmatrix}\nu_f\\\\\nu_s\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb_f\\\\\nb_s\n\\end{bmatrix}.\n$$\n\n定义界面敏感度指标为\n$$\nS = \\left\\lVert \\frac{\\partial R_f}{\\partial u_s} \\right\\rVert_2 = \\lVert C \\rVert_2,\n$$\n其中 $\\lVert \\cdot \\rVert_2$ 表示矩阵谱范数。自适应规则如下：\n- 如果 $S \\le S_{\\text{crit}}$，执行一次单向耦合更新，包括一次前向扫描：\n  $$\n  \\text{初始化 } u_s^{(0)} = 0,\\quad\n  \\text{求解 } A_f u_f^{(1)} = b_f + C u_s^{(0)},\\quad\n  \\text{然后 } A_s u_s^{(1)} = b_s + D u_f^{(1)}.\n  $$\n  近似解为 $(u_f^{(1)}, u_s^{(1)})$。\n- 如果 $S  S_{\\text{crit}}$，从 $u_s^{(0)} = 0$ 开始执行双向不动点迭代：\n  $$\n  \\text{对于 } k = 0,1,2,\\dots \\text{ 直到收敛:}\n  $$\n  $$\n  \\text{求解 } A_f u_f^{(k+1)} = b_f + C u_s^{(k)},\\quad\n  \\text{然后 } A_s u_s^{(k+1)} = b_s + D u_f^{(k+1)}.\n  $$\n  当组合残差范数\n  $$\n  \\lVert r^{(k+1)} \\rVert_2 = \\left\\lVert\n  \\begin{bmatrix}\n  R_f(u_f^{(k+1)},u_s^{(k+1)})\\\\\n  R_s(u_f^{(k+1)},u_s^{(k+1)})\n  \\end{bmatrix}\n  \\right\\rVert_2\n  $$\n  满足 $\\lVert r^{(k+1)} \\rVert_2 \\le \\varepsilon$ 时停止，其中 $\\varepsilon$ 是一个预设的容差。使用 $\\varepsilon = 10^{-10}$ 和最多 $100$ 次迭代。近似解是终止时的 $(u_f^{(k^\\star)}, u_s^{(k^\\star)})$。\n\n将成本模型定义为执行的子求解次数。每次求解 $A_f$ 或 $A_s$ 计为 $1$ 个成本单位。因此：\n- 单向耦合的成本为 $2$。\n- 具有 $k$ 次完整迭代的双向耦合成本为 $2k$。\n\n将精度度量定义为相对误差\n$$\nE = \\frac{\\left\\lVert\n\\begin{bmatrix}\nu_f^{\\text{approx}}\\\\\nu_s^{\\text{approx}}\n\\end{bmatrix}\n-\n\\begin{bmatrix}\nu_f^\\star\\\\\nu_s^\\star\n\\end{bmatrix}\n\\right\\rVert_2}{\\left\\lVert\n\\begin{bmatrix}\nu_f^\\star\\\\\nu_s^\\star\n\\end{bmatrix}\n\\right\\rVert_2}.\n$$\n该度量是无量纲的，并且必须以十进制数报告。\n\n需要检验两种类型的耦合：\n- 界面耦合：使用 $C = k_c\\, e_1 e_1^\\top$ 和 $D = k_d\\, e_1 e_1^\\top$ 的低秩界面相互作用，其中 $e_1 \\in \\mathbb{R}^{n}$ 是第一个规范基向量，且 $n = n_f = n_s$。\n- 体积耦合：使用 $C = k_c\\, I$ 和 $D = k_d\\, I$ 的满秩分布相互作用，其中 $I$ 是大小为 $n$ 的单位矩阵。\n\n使用 $n_f = n_s = 3$。令\n$$\nA_f = \\mathrm{diag}(5,7,9),\\quad A_s = \\mathrm{diag}(4,6,8),\\quad\nb_f = \\begin{bmatrix}1\\\\1\\\\1\\end{bmatrix},\\quad b_s = \\begin{bmatrix}0.5\\\\-0.5\\\\1.0\\end{bmatrix}.\n$$\n\n实现上述自适应算法并评估以下测试套件。每个测试用例指定了耦合类型、耦合尺度 $k_c$ 和 $k_d$ 以及阈值 $S_{\\text{crit}}$。\n\n- 测试用例 1：界面耦合，$k_c = 0.5$，$k_d = 0.5$，$S_{\\text{crit}} = 1.0$。\n- 测试用例 2：界面耦合，$k_c = 6.0$，$k_d = 3.0$，$S_{\\text{crit}} = 1.0$。\n- 测试用例 3：体积耦合，$k_c = 3.0$，$k_d = 2.0$，$S_{\\text{crit}} = 3.0$。\n- 测试用例 4：体积耦合，$k_c = 10.0$，$k_d = 1.0$，$S_{\\text{crit}} = 5.0$。\n- 测试用例 5：体积耦合，$k_c = 10.0$，$k_d = 1.0$，$S_{\\text{crit}} = 100.0$。\n\n对于每个测试用例，计算：\n- 相对误差 $E$，如上定义（无量纲，十进制）。\n- 总成本 $C_{\\text{tot}}$，即子求解次数（整数）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。列表必须按顺序交错排列每个测试用例的误差和成本，即，\n$$\n[\\;E_1, C_{\\text{tot},1}, E_2, C_{\\text{tot},2}, E_3, C_{\\text{tot},3}, E_4, C_{\\text{tot},4}, E_5, C_{\\text{tot},5}\\;].\n$$\n所有条目都必须以数字形式报告；误差为十进制数，成本为整数。不涉及物理单位；所有量均为无量纲。不使用角度。不使用百分比；仅报告十进制数。",
            "solution": "该问题要求为一个线性化的双物理场问题实现并评估一个自适应耦合算法。选择低成本的单向耦合还是高成本、更精确的双向迭代耦合，由一个界面敏感度指标决定。性能通过一个相对误差度量和一个基于子系统求解次数的成本模型进行评估。\n\n首先，我们为该问题建立数学框架。该系统涉及两个耦合场 $u_f \\in \\mathbb{R}^{n_f}$ 和 $u_s \\in \\mathbb{R}^{n_s}$，由以下残差方程控制：\n$$\nR_f(u_f,u_s) = A_f u_f - b_f - C u_s = 0,\n$$\n$$\nR_s(u_f,u_s) = A_s u_s - b_s - D u_f = 0.\n$$\n问题指定了维度 $n_f = n_s = 3$ 并提供了常数矩阵和向量：\n$$\nA_f = \\mathrm{diag}(5, 7, 9), \\quad A_s = \\mathrm{diag}(4, 6, 8),\n$$\n$$\nb_f = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}, \\quad b_s = \\begin{bmatrix} 0.5 \\\\ -0.5 \\\\ 1.0 \\end{bmatrix}.\n$$\n$A_f$ 和 $A_s$ 都是对称正定矩阵，这保证了它们的可逆性。\n\n耦合矩阵 $C$ 和 $D$ 取决于耦合类型和强度参数 $k_c$ 和 $k_d$。\n对于**界面耦合**，矩阵是低秩的：\n$$\nC = k_c e_1 e_1^\\top, \\quad D = k_d e_1 e_1^\\top,\n$$\n其中 $e_1 = [1, 0, 0]^\\top$ 是 $\\mathbb{R}^3$ 中的第一个规范基向量。\n对于**体积耦合**，矩阵是满秩的：\n$$\nC = k_c I, \\quad D = k_d I,\n$$\n其中 $I$ 是 $3 \\times 3$ 的单位矩阵。\n\n精度的参考基准是精确解 $(u_f^\\star, u_s^\\star)$，通过求解整体块线性系统获得：\n$$\nM U = B \\quad \\text{其中} \\quad M = \\begin{bmatrix} A_f  -C \\\\ -D  A_s \\end{bmatrix}, \\quad U = \\begin{bmatrix} u_f \\\\ u_s \\end{bmatrix}, \\quad B = \\begin{bmatrix} b_f \\\\ b_s \\end{bmatrix}.\n$$\n我们将精确解表示为 $U^\\star = [u_f^{\\star \\top}, u_s^{\\star \\top}]^\\top$。对于每个测试用例，我们首先通过求解这个 $6 \\times 6$ 的线性系统来计算 $U^\\star$。\n\n问题的核心是自适应算法。决策基于界面敏感度指标 $S = \\lVert C \\rVert_2$，其中 $\\lVert \\cdot \\rVert_2$ 是矩阵谱范数。给定一个临界阈值 $S_{\\text{crit}}$，算法按如下方式进行：\n\n如果 $S \\le S_{\\text{crit}}$，则使用**单向耦合**方案。这是一个单次前向传递，计算成本低廉。\n1. 初始化结构场为零：$u_s^{(0)} = 0$。\n2. 求解流场：$A_f u_f^{(1)} = b_f + C u_s^{(0)} = b_f$。\n3. 求解结构场：$A_s u_s^{(1)} = b_s + D u_f^{(1)}$。\n近似解为 $U^{\\text{approx}} = [u_f^{(1)\\top}, u_s^{(1)\\top}]^\\top$。该过程涉及两次子系统求解（一次求解 $A_f$，一次求解 $A_s$），因此总成本定义为 $C_{\\text{tot}} = 2$。\n\n如果 $S  S_{\\text{crit}}$，则采用基于不动点（高斯-赛德尔）迭代的**双向耦合**方案。这种方案更精确，但计算成本更高。\n1. 初始化结构场：$u_s^{(0)} = 0$。\n2. 进行迭代， $k = 0, 1, 2, \\dots$，最多 $100$ 次迭代：\n    a. 求解流场：$A_f u_f^{(k+1)} = b_f + C u_s^{(k)}$。\n    b. 求解结构场：$A_s u_s^{(k+1)} = b_s + D u_f^{(k+1)}$。\n    c. 计算组合残差向量 $r^{(k+1)} = [R_f(u_f^{(k+1)}, u_s^{(k+1)})^\\top, R_s(u_f^{(k+1)}, u_s^{(k+1)})^\\top]^\\top$。\n    d. 检查收敛性：如果 $\\lVert r^{(k+1)} \\rVert_2 \\le \\varepsilon = 10^{-10}$，终止迭代。\n3. 近似解 $U^{\\text{approx}} = [u_f^{(k^\\star)\\top}, u_s^{(k^\\star)\\top}]^\\top$ 是最后一次迭代 $k^\\star$ 的结果。\n成本为 $C_{\\text{tot}} = 2 \\times k^\\star$，其中 $k^\\star$ 是执行的总迭代次数。\n\n对于这两种情况，在获得近似解 $U^{\\text{approx}}$ 后，相对误差 $E$ 计算如下：\n$$\nE = \\frac{\\lVert U^{\\text{approx}} - U^\\star \\rVert_2}{\\lVert U^\\star \\rVert_2}.\n$$\n\n每个测试用例的步骤如下：\n1. 根据测试用例参数构建矩阵 $A_f$、$A_s$、$C$、$D$ 和向量 $b_f$、$b_s$。\n2. 组装并求解整体系统 $M U = B$ 以找到精确解 $U^\\star$。\n3. 计算敏感度指标 $S = \\lVert C \\rVert_2$。\n4. 将 $S$ 与 $S_{\\text{crit}}$ 比较，以选择单向或双向耦合过程。\n5. 执行所选过程以找到近似解 $U^{\\text{approx}}$ 和总成本 $C_{\\text{tot}}$。\n6. 使用 $U^{\\text{approx}}$ 和 $U^\\star$ 计算相对误差 $E$。\n7. 存储结果对 $(E, C_{\\text{tot}})$。\n\n由于矩阵 $A_f$ 和 $A_s$ 是对角矩阵，求解像 $A_f u_f = v_f$ 这样的子系统在计算上非常简单，可以通过逐元素相除来完成：$u_{f,i} = v_{f,i} / (A_f)_{ii}$。这简化了步骤 2 和 5 的实现。实现将为五个指定的测试用例中的每一个计算这些量，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Formalizes, implements, and assesses an adaptive coupling mode switch\n    for a linearized two-physics interface problem.\n    \"\"\"\n    \n    # Static problem data\n    n_f, n_s = 3, 3\n    Af = np.diag([5., 7., 9.])\n    As = np.diag([4., 6., 8.])\n    bf = np.array([1., 1., 1.])\n    bs = np.array([0.5, -0.5, 1.0])\n    epsilon = 1e-10\n    max_iter = 100\n\n    test_cases = [\n        {'type': 'interface', 'kc': 0.5, 'kd': 0.5, 'Scrit': 1.0},\n        {'type': 'interface', 'kc': 6.0, 'kd': 3.0, 'Scrit': 1.0},\n        {'type': 'volume', 'kc': 3.0, 'kd': 2.0, 'Scrit': 3.0},\n        {'type': 'volume', 'kc': 10.0, 'kd': 1.0, 'Scrit': 5.0},\n        {'type': 'volume', 'kc': 10.0, 'kd': 1.0, 'Scrit': 100.0}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        kc, kd = case['kc'], case['kd']\n        n = n_f  # Since n_f = n_s\n\n        if case['type'] == 'interface':\n            e1e1T = np.zeros((n, n))\n            e1e1T[0, 0] = 1.0\n            C = kc * e1e1T\n            D = kd * e1e1T\n        elif case['type'] == 'volume':\n            I = np.eye(n)\n            C = kc * I\n            D = kd * I\n        \n        # 1. Calculate exact solution\n        M = np.block([\n            [Af, -C],\n            [-D, As]\n        ])\n        B = np.concatenate((bf, bs))\n        U_star = np.linalg.solve(M, B)\n        norm_U_star = np.linalg.norm(U_star)\n\n        # 2. Adaptive coupling algorithm\n        S = np.linalg.norm(C, 2)\n        Scrit = case['Scrit']\n\n        cost = 0\n        \n        # Helper for subsolves since Af and As are diagonal\n        diag_Af = np.diag(Af)\n        diag_As = np.diag(As)\n\n        if S = Scrit:\n            # One-way coupling\n            cost = 2\n            u_s_approx = np.zeros(n_s) # u_s^(0)\n            \n            # Solve for u_f^(1)\n            rhs_f = bf + C @ u_s_approx\n            u_f_approx = rhs_f / diag_Af\n            \n            # Solve for u_s^(1)\n            rhs_s = bs + D @ u_f_approx\n            u_s_approx = rhs_s / diag_As\n        else:\n            # Two-way coupling\n            u_s_k = np.zeros(n_s) # u_s^(0)\n            \n            u_f_approx = np.zeros(n_f)\n            u_s_approx = np.zeros(n_s)\n            \n            num_iterations = 0\n            for k in range(1, max_iter + 1):\n                num_iterations = k\n                # Solve for u_f^(k+1)\n                rhs_f = bf + C @ u_s_k\n                u_f_approx = rhs_f / diag_Af\n                \n                # Solve for u_s^(k+1)\n                rhs_s = bs + D @ u_f_approx\n                u_s_approx = rhs_s / diag_As\n                \n                # Check convergence\n                res_f = Af @ u_f_approx - bf - C @ u_s_approx\n                res_s = As @ u_s_approx - bs - D @ u_f_approx\n                res_norm = np.linalg.norm(np.concatenate((res_f, res_s)))\n                \n                if res_norm = epsilon:\n                    break\n                \n                u_s_k = u_s_approx\n            \n            cost = 2 * num_iterations\n\n        # 3. Calculate error\n        U_approx = np.concatenate((u_f_approx, u_s_approx))\n        error = np.linalg.norm(U_approx - U_star) / norm_U_star if norm_U_star > 0 else 0.0\n\n        results.extend([error, cost])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.16f}' if isinstance(x, float) else str(x) for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}