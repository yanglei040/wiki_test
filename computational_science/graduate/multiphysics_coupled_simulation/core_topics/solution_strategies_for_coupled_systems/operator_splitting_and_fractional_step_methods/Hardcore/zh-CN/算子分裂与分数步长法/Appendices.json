{
    "hands_on_practices": [
        {
            "introduction": "压力投影法是求解不可压缩Navier-Stokes方程的经典分数步法。该方法的成功不仅依赖于将动量方程和不可压缩性约束解耦，还关键地取决于如何正确处理每个子问题的边界条件。本练习  将指导你推导与对流出流条件相容的压力泊松方程边界条件，并量化当使用不正确的边界条件时所产生的伪反射误差，从而深化对该方法内部工作机理的理解。",
            "id": "3519215",
            "problem": "考虑一个不可压缩牛顿流体，其在占据空间域 $\\Omega = \\{(x,y) \\in \\mathbb{R}^{2} : 0 \\le x \\le L,\\, 0 \\le y \\le H\\}$ 的直通道内，由不可压缩Navier–Stokes方程描述。流体密度为 $\\rho$，动力粘度为 $\\mu$。设出口边界 $\\Gamma_{\\text{out}} = \\{x=L\\}$ 处的单位外法向量为 $\\mathbf{n} = \\mathbf{e}_{x}$。流动主要沿 $\\mathbf{e}_{x}$ 方向，并在 $\\Gamma_{\\text{out}}$ 处具有稳定的出口速度 $U_{b} > 0$。一个一阶压力投影分数步（也称为算子分裂）格式通过以下方式推进速度：\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n},\n$$\n然后通过求解压力子问题来施加不可压缩性约束：\n$$\n\\nabla^{2} p^{n+1} = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^{*},\n$$\n随后进行速度修正：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}.\n$$\n您可以假设解是光滑的，并且在出口处，与对流输运相比，粘性正应力可以忽略不计，这是中高雷诺数通道出口流的典型状态。\n\n任务1（推导）：从不可压缩Navier–Stokes动量方程和上述分数步框架出发，在 $\\Gamma_{\\text{out}}$ 处围绕稳定出口速度 $U_{b}$ 线性化动量平衡的法向分量，并对出口速度施加对流辐射条件，\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}},\n$$\n其中 $u_{n} = \\mathbf{u} \\cdot \\mathbf{n}$。在给定假设下，推导出在 $\\Gamma_{\\text{out}}$ 处与分数步投影一致的相应压力边界条件，并表示为 $p^{n+1}$ 的诺伊曼(Neumann)条件。\n\n任务2（错误指定下的伪反射量化）：考虑沿流向 $x \\in [0,L]$ 的压力子问题的一维代理模型，其右端项选为代表中间速度场散度的单一傅里叶模态，\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\!\\left(\\frac{\\pi x}{L}\\right),\n$$\n其中 $G$ 为常数。在入口边界 $x=0$ 处，采用参考压力条件 $p(0) = 0$。对于出口边界 $x=L$：\n- 情况A（物理上一致的出口）：施加任务1中推导出的诺伊曼(Neumann)边界条件，并计算 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$。\n- 情况B（错误指定的出口）：施加狄利克雷(Dirichlet)条件 $p(L) = 0$ 以代替诺伊曼(Neumann)条件，并计算 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L}$。\n\n将反射系数 $\\mathcal{R}$ 定义为情况B中由错误指定的狄利克雷(Dirichlet)条件引起的出口法向速度修正的量值与情况A中入口法向速度修正的量值之比，两者均在边界处测量。使用速度修正关系式\n$$\nu_{n}^{\\text{corr}}(x) = - \\frac{\\Delta t}{\\rho} \\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x},\n$$\n将 $\\mathcal{R}$ 表示为\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}.\n$$\n\n答案格式要求：请以一个两元素的行矩阵形式提供您的最终答案，其中依次包含任务1的出口压力诺伊曼(Neumann)边界条件的值（为数值或在 $x=L$ 处求值的闭式表达式）和任务2的反射系数 $\\mathcal{R}$。无需四舍五入。反射系数是无量纲的。请勿在最终的方框答案中包含单位。",
            "solution": "该问题经核实具有科学依据、是适定的且客观的。这是对计算流体力学中投影法的数值边界条件的标准分析。我现在开始解答。\n\n该问题包含两个任务。任务1是为一个使用分数步投影法的通道流模拟，推导其出口边界上的压力诺伊曼(Neumann)边界条件。任务2是通过一个简化的一维模型，量化因使用不正确的压力边界条件而在出口处引起的伪反射。\n\n### 任务1：出口压力边界条件的推导\n\n目标是找到在出口边界 $\\Gamma_{\\text{out}} = \\{x=L\\}$ 上，与所施加的速度对流辐射条件相一致的压力 $p^{n+1}$ 的边界条件。此边界处的法向量为 $\\mathbf{n} = \\mathbf{e}_{x}$，因此法向对应于 $x$ 方向，法向速度为 $u_{n} = \\mathbf{u} \\cdot \\mathbf{n} = u_{x}$。法向导数为 $\\frac{\\partial}{\\partial n} = \\frac{\\partial}{\\partial x}$。\n\n分数步法的速度修正步骤由下式给出：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{*} - \\frac{\\Delta t}{\\rho} \\nabla p^{n+1}\n$$\n在边界 $\\Gamma_{\\text{out}}$ 处与单位外法向量 $\\mathbf{n}$ 作点积，得到新时间步 $n+1$ 处的法向速度分量：\n$$\nu_{n}^{n+1} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\n该方程将所需的压力诺伊曼(Neumann)条件 $\\frac{\\partial p^{n+1}}{\\partial n}$ 与边界上的速度联系起来。为了求解它，我们需要一个在 $\\Gamma_{\\text{out}}$ 上的 $u_n^{n+1}$ 的表达式。\n\n问题对出口速度施加了对流辐射条件：\n$$\n\\frac{\\partial u_{n}}{\\partial t} + U_{b}\\frac{\\partial u_{n}}{\\partial n} = 0 \\quad \\text{on } \\Gamma_{\\text{out}}\n$$\n我们可以使用与给定投影格式的整体一阶时间精度相符的一阶显式格式（时间导数用前向欧拉，空间导数在时间 $n$ 求解）对该方程进行时间离散化：\n$$\n\\frac{u_{n}^{n+1} - u_{n}^{n}}{\\Delta t} + U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} = 0\n$$\n求解 $u_{n}^{n+1}$ 得到新时间步下出口处的目标法向速度：\n$$\nu_{n}^{n+1} = u_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n现在，我们将 $u_n^{n+1}$ 的这个表达式代入速度修正方程的法向分量中：\n$$\nu_{n}^{n} - \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n} = u_{n}^{*} - \\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n}\n$$\n重新整理以求解压力梯度，得到：\n$$\n\\frac{\\Delta t}{\\rho} \\frac{\\partial p^{n+1}}{\\partial n} = (u_{n}^{*} - u_{n}^{n}) + \\Delta t \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n项 $(u_{n}^{*} - u_{n}^{n})$ 由动量预测步确定：\n$$\n\\rho \\frac{\\mathbf{u}^{*} - \\mathbf{u}^{n}}{\\Delta t} = - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n}\n$$\n取该方程的法向分量，得到：\n$$\n\\frac{\\rho}{\\Delta t}(u_{n}^{*} - u_{n}^{n}) = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)\\mathbf{u}^{n} + \\mu \\nabla^{2}\\mathbf{u}^{n} + \\mathbf{f}^{n} \\right] \\cdot \\mathbf{n}\n$$\n将此式代入我们的压力梯度表达式中：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = \\left[ - \\rho (\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} + \\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n现在，我们应用问题陈述中提供的假设，这些假设在时间层 $n$ 和边界 $\\Gamma_{\\text{out}}$ 上进行评估：\n1.  围绕稳定出口速度 $U_b$ 对对流项进行线性化：$(\\mathbf{u}^{n} \\cdot \\nabla)u_{n}^{n} \\approx U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}$。\n2.  粘性正应力可忽略：这意味着出口处粘性力项的法向分量可忽略，因此 $\\mu (\\nabla^{2}\\mathbf{u}^{n}) \\cdot \\mathbf{n} \\approx 0$。\n\n将这些假设应用于压力梯度方程：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} \\approx \\left[ - \\rho \\left( U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} \\right) + 0 + f_{n}^{n} \\right] + \\rho \\, U_{b} \\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = - \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n} + f_{n}^{n} + \\rho \\, U_{b}\\frac{\\partial u_{n}^{n}}{\\partial n}\n$$\n对流项相互抵消，剩下：\n$$\n\\frac{\\partial p^{n+1}}{\\partial n} = f_{n}^{n}\n$$\n问题没有指明体积力 $\\mathbf{f}^{n}$。在此类典型应用和模型问题中，除非另有说明，体积力通常假定为零。为了得到一个具体的值并确保与任务2（其中隐含没有体积力项）的一致性，我们假设 $\\mathbf{f}^{n} = \\mathbf{0}$。因此，$f_n^n = 0$。\n得到的出口压力诺伊曼(Neumann)边界条件是：\n$$\n\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x=L} = 0\n$$\n\n### 任务2：伪反射的量化\n\n我们分析压力的一维代理问题，由以下常微分方程给出：\n$$\n\\frac{\\mathrm{d}^{2} p}{\\mathrm{d} x^{2}} = G \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n通解可以通过对 $x$ 积分两次得到：\n$$\n\\frac{\\mathrm{d} p}{\\mathrm{d} x} = \\int G \\sin\\left(\\frac{\\pi x}{L}\\right) \\mathrm{d}x = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\n$$\n$$\np(x) = \\int \\left(-G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) + C_1\\right) \\mathrm{d}x = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi x}{L}\\right) + C_1 x + C_2\n$$\n\n**情况A：物理上一致的出口**\n边界条件为 $p(0) = 0$（入口）和 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$（出口，来自任务1）。\n\n应用 $p(0) = 0$：\n$$\np(0) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(0) + C_1(0) + C_2 = 0 \\implies C_2=0\n$$\n应用 $\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = 0$：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi L}{L}\\right) + C_1 = -G \\frac{L}{\\pi} \\cos(\\pi) + C_1 = 0\n$$\n$$\n-G \\frac{L}{\\pi} (-1) + C_1 = 0 \\implies C_1 = -G \\frac{L}{\\pi}\n$$\n情况A的压力梯度是 $\\frac{\\mathrm{d} p_A}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi}$。\n\n**情况B：错误指定的出口**\n边界条件为 $p(0) = 0$（入口）和 $p(L) = 0$（出口）。\n\n应用 $p(0) = 0$ 得到 $C_2 = 0$，和之前一样。\n应用 $p(L) = 0$：\n$$\np(L) = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin\\left(\\frac{\\pi L}{L}\\right) + C_1 L = -G \\left(\\frac{L}{\\pi}\\right)^2 \\sin(\\pi) + C_1 L = 0\n$$\n$$\n0 + C_1 L = 0 \\implies C_1 = 0\n$$\n情况B的压力梯度是 $\\frac{\\mathrm{d} p_B}{\\mathrm{d} x} = -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right)$。\n\n**反射系数 $\\mathcal{R}$ 的计算**\n反射系数定义为：\n$$\n\\mathcal{R} = \\frac{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}}\\right|}{\\left|\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}}\\right|}\n$$\n首先，我们计算分子：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=L,\\ \\text{Case B}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) \\right) \\right|_{x=L} = -G \\frac{L}{\\pi} \\cos(\\pi) = G \\frac{L}{\\pi}\n$$\n接下来，我们计算分母：\n$$\n\\left.\\frac{\\mathrm{d} p}{\\mathrm{d} x}\\right|_{x=0,\\ \\text{Case A}} = \\left. \\left( -G \\frac{L}{\\pi} \\cos\\left(\\frac{\\pi x}{L}\\right) - G \\frac{L}{\\pi} \\right) \\right|_{x=0} = -G \\frac{L}{\\pi} \\cos(0) - G \\frac{L}{\\pi} = -G \\frac{L}{\\pi} - G \\frac{L}{\\pi} = -2G \\frac{L}{\\pi}\n$$\n现在，我们计算它们量值的比率：\n$$\n\\mathcal{R} = \\frac{\\left| G \\frac{L}{\\pi} \\right|}{\\left| -2G \\frac{L}{\\pi} \\right|} = \\frac{|G| \\frac{L}{\\pi}}{2|G| \\frac{L}{\\pi}} = \\frac{1}{2}\n$$\n\n最终答案要求任务1的出口压力诺伊曼(Neumann)边界条件值（为 $0$）和任务2的反射系数 $\\mathcal{R}$（为 $\\frac{1}{2}$）。这些以一个两元素的行矩阵形式提供。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{1}{2} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "将算子分裂法应用于耦合不同物理子系统时，一个常见挑战是如何确保交界面处的数值稳定性。直接或不恰当的耦合策略可能导致伪振荡，破坏仿真的物理真实性。本练习  提供了一个最小化的多物理场耦合模型，用于分析这种振荡现象，并引导你推导出一个最优的“通量混合”策略来抑制振荡，这在协同仿真和分区多物理场求解器中是一种实用技术。",
            "id": "3519194",
            "problem": "考虑一个两个子系统（记为 A 和 B）之间热耦合界面的极简无量纲模型，该模型源于对热方程的半离散有限体积处理，其中每个子系统贡献一个界面控制体。令 $u_A(t)$ 和 $u_B(t)$ 表示两侧的界面温度。这些控制体的基本能量平衡方程为\n$$\nC_A \\frac{d u_A}{d t} \\;=\\; -F(t), \\qquad C_B \\frac{d u_B}{d t} \\;=\\; F(t),\n$$\n其中 $C_A>0$ 和 $C_B>0$ 是界面控制体的热容（或集总热质量），$F(t)$ 是从子系统 A 指向子系统 B 的界面热通量。在连续层面上，本问题不需要精确的热导；相反，假设在给定的离散时间层 $t^n$，两个独立的求解器使用各自的界面热导模型，提出了符合傅里叶定律的界面通量预测：\n$$\nF_A^n \\;=\\; k_A \\,\\big(u_A^n - u_B^n\\big), \\qquad F_B^n \\;=\\; k_B \\,\\big(u_A^n - u_B^n\\big),\n$$\n其中 $k_A>0$ 且 $k_B>0$。在算子分裂（分数步）的背景下，一种常见的做法是通过混合两种预测来计算单一的守恒通量：\n$$\nF^{n} \\;=\\; F^\\star \\;=\\; \\theta \\,F_A^n + \\big(1-\\theta\\big)\\,F_B^n \\;=\\; k_\\theta \\,\\big(u_A^n - u_B^n\\big), \\quad \\text{其中} \\quad k_\\theta \\;=\\; \\theta k_A + (1-\\theta) k_B,\n$$\n其中 $\\theta \\in [0,1]$ 是一个混合参数。然后，在一个时间步长 $\\Delta t>0$ 上使用显式一阶分数步，更新公式为\n$$\nu_A^{n+1} \\;=\\; u_A^n \\;-\\; \\frac{\\Delta t}{C_A}\\,F^{n}, \\qquad\nu_B^{n+1} \\;=\\; u_B^n \\;+\\; \\frac{\\Delta t}{C_B}\\,F^{n}.\n$$\n定义界面跳跃为 $d^n \\;=\\; u_A^n - u_B^n$。从上述基本能量平衡和给定的显式更新出发，完成以下任务：\n\n1) 推导 $d^{n+1}$ 关于 $d^n$、$\\Delta t$、$C_A$、$C_B$ 和 $k_\\theta$ 的闭式线性递推关系。利用此关系精确定义在这种情况下，一个时间步后什么构成伪振荡，并陈述出现此类振荡的条件。\n\n2) 考虑由 $\\theta \\in [0,1]$ 参数化的混合通量族。对于一组固定的正参数 $\\Delta t$、$C_A$、$C_B$、$k_A$ 和 $k_B$，确定使界面跳躍的单步放大率最小化的值 $\\theta(\\Delta t)$。您的推导必须：\n- 识别出在一步内即可消除跳跃的有效目标热导（如果可实现）。\n- 通过遵循由 $\\theta \\in [0,1]$ 得出的凸性约束 $k_\\theta \\in [\\min(k_A,k_B),\\max(k_A,k_B)]$，将最优有效热导转换为一个允许的 $\\theta$。\n- 显式处理退化情况 $k_A = k_B$，此时所有 $\\theta$ 产生相同的 $k_\\theta$。\n- 给出最终的最小化放大率，并指明在此最优 $\\theta$ 下，单步更新是否是振荡的。\n\n3) 实现一个程序，对于下面的每个测试案例，计算并返回：\n- 位于 $[0,1]$ 中的最小化 $\\theta(\\Delta t)$，\n- 界面跳跃的最小化单步放大率，\n- 一个布尔值，指示在最小化 $\\theta$ 下单步更新是否是振荡的。\n\n测试套件包含以下五个参数集 $(C_A, C_B, k_A, k_B, \\Delta t)$：\n- 案例1（理想路径，可实现精确抵消）：$(1.0,\\,1.0,\\,4.0,\\,1.0,\\,0.4)$。\n- 案例2（大时间步，振荡区域；下界激活）：$(1.0,\\,1.0,\\,4.0,\\,1.0,\\,1.0)$。\n- 案例3（小时间步；上界激活）：$(1.0,\\,1.0,\\,4.0,\\,1.0,\\,0.05)$。\n- 案例4（不等热容，可实现精确抵消）：$(2.0,\\,1.0,\\,3.0,\\,0.5,\\,0.3)$。\n- 案例5（退化热导 $k_A=k_B$）：$(1.0,\\,3.0,\\,2.0,\\,2.0,\\,0.4)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，按上述顺序包含五个案例的结果。\n- 每个结果必须是 $[\\theta^\\star,\\,|g^\\star|,\\,\\text{oscillatory}]$ 形式的列表，其中 $\\theta^\\star$ 是 $[0,1]$ 中的最小化值， $|g^\\^\\star|$ 是最小化的单步放大率，而 $\\text{oscillatory}$ 是一个布尔值，如果在 $\\theta^\\star$ 处单步更新是振荡的，则为 true，否则为 false。\n- 输出中的所有浮点数必须打印小数点后十位。\n- 整体格式示例：`[[\\theta_1,|g_1|,\\text{bool}_1],[\\theta_2,|g_2|,\\text{bool}_2],\\dots]`。\n\n您的程序必须是完整且可直接运行的，不得需要任何用户输入或外部文件。预期输出纯粹是数值（浮点数和布尔值），没有物理单位。",
            "solution": "从基本能量平衡方程\n$$\nC_A \\frac{d u_A}{d t} \\;=\\; -F(t), \\qquad C_B \\frac{d u_B}{d t} \\;=\\; F(t),\n$$\n和时间步长为 $\\Delta t$ 的混合显式更新\n$$\nu_A^{n+1} \\;=\\; u_A^n \\;-\\; \\frac{\\Delta t}{C_A} F^{n}, \\qquad\nu_B^{n+1} \\;=\\; u_B^n \\;+\\; \\frac{\\Delta t}{C_B} F^{n},\n$$\n我们有，在时间层 $n$ 的界面通量为\n$$\nF^{n} \\;=\\; F^\\star \\;=\\; \\theta F_A^n + (1-\\theta) F_B^n \\;=\\; \\big(\\theta k_A + (1-\\theta) k_B\\big)\\,\\big(u_A^n - u_B^n\\big) \\;=\\; k_\\theta \\, d^n,\n$$\n其中 $d^n \\;=\\; u_A^n - u_B^n$ 表示界面跳跃，$k_\\theta \\;=\\; \\theta k_A + (1-\\theta) k_B$。\n\n定义和\n$$\nS \\;=\\; \\frac{1}{C_A} + \\frac{1}{C_B}.\n$$\n将两个显式更新相减以获得跳跃的递推关系：\n$$\nd^{n+1} \\;=\\; u_A^{n+1} - u_B^{n+1} \\;=\\; \\Big(u_A^n - \\frac{\\Delta t}{C_A} k_\\theta d^n\\Big) \\;-\\; \\Big(u_B^n + \\frac{\\Delta t}{C_B} k_\\theta d^n\\Big)\n\\;=\\; d^n - \\Delta t\\,k_\\theta \\Big(\\frac{1}{C_A} + \\frac{1}{C_B}\\Big) d^n.\n$$\n因此，\n$$\nd^{n+1} \\;=\\; g(\\theta)\\, d^n, \\qquad \\text{其中} \\quad g(\\theta) \\;=\\; 1 - \\Delta t\\,k_\\theta\\,S \\;=\\; 1 - \\Delta t\\,S\\,\\big(\\theta k_A + (1-\\theta) k_B\\big).\n$$\n\n一个时间步内的伪振荡对应于界面跳跃的符号反转，即 $d^{n+1}$ 和 $d^n$ 符号相反。由于递推是标量的，这当且仅当\n$$\ng(\\theta)  0 \\quad \\Longleftrightarrow \\quad 1 - \\Delta t\\,k_\\theta\\,S  0 \\quad \\Longleftrightarrow \\quad \\Delta t\\,k_\\theta\\,S  1.\n$$\n因此，当单步放大因子 $g(\\theta)$ 为负时，会发生振荡。\n\n为了最小化振荡，我们最小化单步放大因子的模：\n$$\n\\min_{\\theta \\in [0,1]} \\; \\big|g(\\theta)\\big| \\;=\\; \\min_{\\theta \\in [0,1]} \\; \\big|1 - \\Delta t\\,S\\,k_\\theta\\big|.\n$$\n令\n$$\nk_{\\min} \\;=\\; \\min(k_A,k_B), \\qquad k_{\\max} \\;=\\; \\max(k_A,k_B).\n$$\n因为 $k_\\theta$ 是一个凸组合，对于 $\\theta \\in [0,1]$，有 $k_\\theta \\in [k_{\\min},k_{\\max}]$。定义可以在一步内使跳跃为零的目标热导：\n$$\nk_{\\text{target}} \\;=\\; \\frac{1}{\\Delta t\\,S}.\n$$\n如果 $k_{\\text{target}} \\in [k_{\\min},k_{\\max}]$，那么精确的最小化器将 $k_\\theta$ 设为 $k_{\\text{target}}$，得到\n$$\ng(\\theta^\\star) \\;=\\; 1 - \\Delta t\\,S\\,k_{\\text{target}} \\;=\\; 0,\n$$\n所以跳跃在一步内被消除，不发生振荡。\n\n如果 $k_{\\text{target}} \\notin [k_{\\min},k_{\\max}]$，则在最近的边界上达到最小值：\n$$\nk_\\theta^\\star \\;=\\; \\begin{cases}\nk_{\\min},  \\text{如果 } k_{\\text{target}} \\le k_{\\min},\\\\\nk_{\\max},  \\text{如果 } k_{\\text{target}} \\ge k_{\\max},\n\\end{cases}\n$$\n这给出了最小化的模\n$$\n\\big|g^\\star\\big| \\;=\\; \\big|1 - \\Delta t\\,S\\,k_\\theta^\\star\\big|.\n$$\n\n为了将最优有效热导 $k_\\theta^\\star$ 映射回 $\\theta^\\star$，使用仿射关系 $k_\\theta = k_B + \\theta (k_A - k_B)$。如果 $k_A \\neq k_B$，则\n$$\n\\theta^\\star \\;=\\; \\operatorname{clip}_{[0,1]}\\!\\left(\\frac{k_{\\text{target}} - k_B}{k_A - k_B}\\right),\n$$\n其中裁剪操作强制区间为 $[0,1]$，并隐式地实现了上述的边界选择。如果 $k_A = k_B$，则 $k_\\theta$ 与 $\\theta$ 无关，所以所有的 $\\theta$ 都是等价的；一个自然的约定是设置 $\\theta^\\star = \\tfrac{1}{2}$。\n\n最后，当且仅当 $g^\\star = 1 - \\Delta t\\,S\\,k_\\theta^\\star  0$ 时，更新在最小化 $\\theta^\\star$ 处是振荡的。\n\n每个测试案例 $(C_A, C_B, k_A, k_B, \\Delta t)$ 的算法：\n- 计算 $S \\leftarrow \\tfrac{1}{C_A} + \\tfrac{1}{C_B}$。\n- 计算 $k_{\\text{target}} \\leftarrow \\tfrac{1}{\\Delta t\\,S}$。\n- 如果 $k_A \\neq k_B$，设置\n$$\n\\theta^\\star \\leftarrow \\operatorname{clip}_{[0,1]}\\!\\left(\\frac{k_{\\text{target}} - k_B}{k_A - k_B}\\right).\n$$\n否则设置 $\\theta^\\star \\leftarrow \\tfrac{1}{2}$。\n- 计算 $k_\\theta^\\star \\leftarrow k_B + \\theta^\\star (k_A - k_B)$。\n- 计算 $g^\\star \\leftarrow 1 - \\Delta t\\,S\\,k_\\theta^\\star$。\n- 报告 $\\theta^\\star$、$\\big|g^\\star\\big|$ 和布尔值 $(g^\\star  0)$。\n\n将此应用于所提供的案例（使用精确算术推理）：\n- 案例1：$C_A=C_B=1$, $S=2$, $\\Delta t=0.4$, $k_A=4$, $k_B=1$。则 $k_{\\text{target}}=\\tfrac{1}{0.4\\cdot 2}=1.25 \\in [1,4]$。因此 $\\theta^\\star = \\tfrac{1.25-1}{4-1}=\\tfrac{1}{12}$, $g^\\star = 0$, 非振荡的。\n- 案例2：同样的 $S=2$, $\\Delta t=1.0$, $k_{\\text{target}}=\\tfrac{1}{2}=0.5 \\le k_{\\min}=1$。因此 $\\theta^\\star=0$, $k_\\theta^\\star=1$, $g^\\star=1-1\\cdot 2\\cdot 1=-1$, 振荡的。\n- 案例3：同样的 $S=2$, $\\Delta t=0.05$, $k_{\\text{target}}=\\tfrac{1}{0.1}=10 \\ge k_{\\max}=4$。因此 $\\theta^\\star=1$, $k_\\theta^\\star=4$, $g^\\star=1-0.05\\cdot 2\\cdot 4=0.6$, 非振荡的。\n- 案例4：$C_A=2$, $C_B=1$, $S=\\tfrac{1}{2}+1=\\tfrac{3}{2}$, $\\Delta t=0.3$, $k_A=3$, $k_B=0.5$。则 $k_{\\text{target}}=\\tfrac{1}{0.3\\cdot 1.5}=\\tfrac{1}{0.45}=\\tfrac{20}{9}\\approx 2.222\\in[0.5,3]$。因此 $\\theta^\\star=\\dfrac{\\frac{20}{9}-0.5}{3-0.5}=\\dfrac{\\frac{20}{9}-\\frac{1}{2}}{\\frac{5}{2}}=\\dfrac{\\frac{40-9}{18}}{\\frac{5}{2}}=\\dfrac{\\frac{31}{18}}{\\frac{5}{2}}=\\frac{31}{45}\\approx 0.688\\overline{8}$, $g^\\star=0$, 非振荡的。\n- 案例5：$C_A=1$, $C_B=3$, $S=1+\\tfrac{1}{3}=\\tfrac{4}{3}$, $\\Delta t=0.4$, $k_A=k_B=2$。任何 $\\theta$ 都给出 $k_\\theta^\\star=2$，因此按惯例设置 $\\theta^\\star=\\tfrac{1}{2}$。则 $g^\\star = 1 - 0.4\\cdot \\tfrac{4}{3}\\cdot 2 = 1 - \\tfrac{16}{15} = -\\tfrac{1}{15} \\approx -0.066\\overline{6}$, 小幅振荡的。\n\n该程序实现了这些计算，并以要求的单行格式打印结果，浮点值保留小数点后十位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef compute_theta_star_and_gain(CA, CB, kA, kB, dt):\n    # Compute S = 1/CA + 1/CB\n    S = (1.0 / CA) + (1.0 / CB)\n    # Target conductance to nullify the jump in one step\n    k_target = 1.0 / (dt * S)\n    # Handle degenerate case where kA == kB\n    if abs(kA - kB)  1e-15:\n        theta_star = 0.5  # by convention; any theta yields the same k_theta\n    else:\n        # Compute unclipped theta that would achieve k_target exactly\n        theta_unclipped = (k_target - kB) / (kA - kB)\n        # Clip to [0, 1]\n        theta_star = 0.0 if theta_unclipped  0.0 else (1.0 if theta_unclipped  1.0 else theta_unclipped)\n    # Effective conductance at theta_star\n    k_theta = kB + theta_star * (kA - kB)\n    # One-step amplification factor g\n    g = 1.0 - dt * S * k_theta\n    # Magnitude and oscillatory boolean\n    abs_g = abs(g)\n    oscillatory = g  0.0\n    return theta_star, abs_g, oscillatory\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (C_A, C_B, k_A, k_B, Delta t)\n    test_cases = [\n        (1.0, 1.0, 4.0, 1.0, 0.4),   # Case 1\n        (1.0, 1.0, 4.0, 1.0, 1.0),   # Case 2\n        (1.0, 1.0, 4.0, 1.0, 0.05),  # Case 3\n        (2.0, 1.0, 3.0, 0.5, 0.3),   # Case 4\n        (1.0, 3.0, 2.0, 2.0, 0.4),   # Case 5\n    ]\n\n    results = []\n    for CA, CB, kA, kB, dt in test_cases:\n        theta_star, abs_g, oscillatory = compute_theta_star_and_gain(CA, CB, kA, kB, dt)\n        # Format with ten digits after decimal for floats\n        results.append(f\"[{theta_star:.10f},{abs_g:.10f},{str(oscillatory).lower()}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在多物理场问题中，不同物理过程的时间尺度常常存在巨大差异，例如，化学反应（刚性）可能远快于对流输运（非刚性）。本练习  对比了处理此类问题的两种主流方法：算子分裂法和隐式-显式（IMEX）方法。练习将超越形式上的精度阶，深入探讨诸如正定性和熵稳定性等关键的定性性质，帮助你理解为何对刚性项进行简单的显式处理会失败，以及隐式方法（在算子分裂和IMEX中均有应用）如何解决这一核心挑战。",
            "id": "3519207",
            "problem": "要求您分析并实现一阶算子分裂和隐式-显式（IMEX）积分方法，用于求解一个模拟单一物质质量分数的一维反应平流方程。该数学模型是在周期性域 $x \\in [0,1)$ 上的带有线性弛豫源项的标量守恒律：\n$$\n\\partial_t y(x,t) + a\\,\\partial_x y(x,t) = -k\\,(y(x,t) - y_{\\mathrm{eq}}),\n$$\n其中 $a0$ 是一个常数平流速度，$k0$ 是一个刚性参数，$y_{\\mathrm{eq}}0$ 是一个常数平衡态。状态量 $y$ 是无量纲的，代表物质质量分数，因此物理真实性要求 $y \\ge 0$。为评估源项的热力学一致性，使用凸数学熵密度\n$$\n\\eta(y) = y \\ln\\!\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) - (y - y_{\\mathrm{eq}}), \\quad y  0,\n$$\n以及离散熵泛函\n$$\nH(\\mathbf{y}) = \\sum_{i=0}^{N-1} \\eta(y_i)\\,\\Delta x,\n$$\n其中 $\\mathbf{y} = (y_0,\\dots,y_{N-1})^\\top$ 是在一个具有 $N$ 个单元、间距为 $\\Delta x = 1/N$ 的均匀周期性网格上的单元平均值向量。\n\n从守恒律的基本原理和标准的有限体积离散化出发，按以下步骤进行。\n\n- 使用与 $a$ 符号一致的一阶迎风通量和前向欧拉时间步进方法来离散化平流算子 $B$。使用周期性边界条件。\n\n- 使用两种选项来离散化刚性化学反应算子 $A$：将后向欧拉（全隐式）和前向欧拉（全显式）时间步进方法独立应用于每个单元的线性弛豫常微分方程 $\\dot{y} = -k(y - y_{\\mathrm{eq}})$。\n\n- 在一个时间步长 $\\Delta t$ 上构造两种一阶李氏算子分裂方法：$A \\circ B$，其中 $A$ 通过后向欧拉实现化学反应步；以及 $A \\circ B$，其中 $A$ 通过前向欧拉实现化学反应步。在每种情况下，先执行时间步长为 $\\Delta t$ 的化学反应子步，然后执行时间步长为 $\\Delta t$ 的平流子步。\n\n- 构造一个一阶 IMEX 欧拉方法，其中在同一个完整时间步长 $\\Delta t$ 内，平流项被显式处理，化学反应项被隐式处理。\n\n您的任务：\n\n1) 根据前向欧拉、后向欧拉和针对 $a0$ 的一阶迎风有限体积离散化的定义，推导每种方法（包括算子分裂和 IMEX）关于网格函数值的更新公式。利用以下事实：前向欧拉应用于 $\\dot{y} = f(y)$ 得到 $y^{n+1} = y^n + \\Delta t\\,f(y^n)$，后向欧拉得到 $y^{n+1} = y^n + \\Delta t\\,f(y^{n+1})$。证明应用于线性弛豫的后向欧拉方法对于 $y^n \\ge 0$ 是无条件保正的，而当前向欧拉的 $k \\Delta t$ 相对于 $y^n$ 和 $y_{\\mathrm{eq}}$ 足够大时，可能会产生负值。\n\n2) 证明熵密度 $\\eta$ 对于 $y0$ 是严格凸的，并在 $y = y_{\\mathrm{eq}}$ 处达到其唯一最小值。由此得出结论，任何一个朝向 $y_{\\mathrm{eq}}$ 的压缩映射的化学反应时间积分器都是熵耗散的，即在该子步中 $H$ 不会增加。解释为什么对于线性弛豫，后向欧拉化学反应步对于任何 $\\Delta t0$ 都是熵稳定的。\n\n3) 在一个均匀周期性网格上实现并比较三种方法，参数为 $N = 100$, $\\Delta x = 1/N$, $a = 0.5$, $y_{\\mathrm{eq}} = 0.05$，最终时间为 $T = 0.2$。使用初始条件：\n$$\ny(x,0) = y_{\\mathrm{eq}} + 0.4\\,\\exp\\big(-200\\,(x-0.25)^2\\big) + 0.2\\,\\exp\\big(-400\\,(x-0.75)^2\\big).\n$$\n通过重复大小为 $\\Delta t$ 的步长演化到时间 $T$，如果 $T/\\Delta t$ 不是整数，则使用一个最终的缩短步长，以确保总模拟时间恰好等于 $T$。\n\n4) 对于以下 $(k,\\Delta t)$ 对的测试套件，运行所有三种方法：\n   - 案例 A (理想情况)：$(k,\\Delta t) = (1000, 0.001)$。\n   - 案例 B (非常刚性)：$(k,\\Delta t) = (8000, 0.01)$。\n   - 案例 C (CFL 边界)：$(k,\\Delta t) = (500, 0.02)$。\n\n对于每个案例，计算以下七个输出：\n   - $p_{\\mathrm{BE}}$：一个布尔值，表示在使用带后向欧拉化学反应的算子分裂方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{BE}}$：一个布尔值，表示在使用后向欧拉化学反应的整个模拟过程中，每个化学反应子步之后的离散熵 $H$ 是否相对于该子步之前没有增加。\n   - $p_{\\mathrm{IMEX}}$：一个布尔值，表示在使用 IMEX 欧拉方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{IMEX}}$：一个布尔值，表示在整个模拟过程中，每个完整 IMEX 步之后的离散熵 $H$ 是否相对于该步之前没有增加。\n   - $p_{\\mathrm{EE}}$：一个布尔值，表示在使用带前向欧拉化学反应的算子分裂方法时，所有自由度在最终时间后是否保持非负。\n   - $e_{\\mathrm{EE}}$：一个布尔值，表示在使用前向欧拉化学反应的整个模拟过程中，每个前向欧拉化学反应子步之后的离散熵 $H$ 是否相对于该子步之前没有增加。\n   - $d_{\\mathrm{L1}}$：IMEX 和后向欧拉分裂方法最终状态之间的离散 $\\ell^1$ 差，定义为 $\\sum_i |y^{\\mathrm{IMEX}}_i - y^{\\mathrm{BE\\mbox{-}split}}_i|\\,\\Delta x$，以浮点数形式表示。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例贡献一个形式为 $[p_{\\mathrm{BE}}, e_{\\mathrm{BE}}, p_{\\mathrm{IMEX}}, e_{\\mathrm{IMEX}}, p_{\\mathrm{EE}}, e_{\\mathrm{EE}}, d_{\\mathrm{L1}}]$ 的子列表。例如，最终输出格式必须类似于 $[[\\text{案例 A 输出}],[\\text{案例 B 输出}],[\\text{案例 C 输出}]]$。",
            "solution": "该问题阐述了一个一维反应平流方程，这是输运现象中的一个标准偏微分方程（PDE）。所有参数、初始条件和数值方法在既有的数学和计算科学文献中都有明确定义。该问题在科学上是合理的、自洽的且适定的。任务涉及对此类方程的标准推导和典型数值格式（算子分裂、IMEX）的实现。因此，该问题被认为是有效的。\n\n### 任务1：数值格式的推导\n\n控制偏微分方程为 $\\partial_t y + a\\,\\partial_x y = -k(y - y_{\\mathrm{eq}})$，可写成 $\\partial_t y = A(y) + B(y)$ 的形式，其中 $A(y) = -k(y - y_{\\mathrm{eq}})$ 是化学反应算子，$B(y) = -a\\,\\partial_x y$ 是平流算子。\n\n我们将空间域 $[0,1)$ 离散为 $N$ 个宽度为 $\\Delta x = 1/N$ 的单元。设 $y_i(t)$ 为单元 $i$ 中的单元平均值。\n\n**平流算子 ($B$) 离散化**\n平流算子 $B(y) = -a\\,\\partial_x y$ 使用一阶迎风有限体积法进行离散化。由于 $a0$，单元 $i$ 和 $i+1$ 之间的界面 $i+1/2$ 处的通量为 $F_{i+1/2} = a y_i$。单元 $i$ 的半离散方程为：\n$$\n\\frac{d y_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} = -\\frac{a y_i - a y_{i-1}}{\\Delta x}\n$$\n对 方程 $\\dot{\\mathbf{y}} = \\mathcal{B}(\\mathbf{y})$ 应用一个时间步长为 $\\Delta t$ 的前向欧拉步，其中 $\\mathcal{B}$ 是离散平流算子，得到更新公式：\n$$\ny_i^* = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)\n$$\n其中周期性边界条件意味着 $y_{-1}^n = y_{N-1}^n$。\n\n**化学反应算子 ($A$) 离散化**\n化学反应算子 $A(y) = -k(y - y_{\\mathrm{eq}})$ 对应于在每个单元中独立应用的常微分方程（ODE）$\\dot{y} = -k(y-y_{\\mathrm{eq}})$。\n\n- **前向欧拉 (FE) 离散化**：\n  更新规则为 $y^{n+1} = y^n + \\Delta t \\, f(y^n)$，其中 $f(y) = -k(y - y_{\\mathrm{eq}})$。\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^n - y_{\\mathrm{eq}})) = y^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n  $$\n  为了保正性，如果 $y^n \\ge 0$，我们需要 $y^{n+1} \\ge 0$。如果 $k\\Delta t  1$，项 $(1-k\\Delta t)$ 为负。保正性可能被违反。例如，如果 $k\\Delta t=2$ 且 $y^n  2y_{\\mathrm{eq}}$，那么 $y^{n+1} = -y^n+2y_{\\mathrm{eq}}  0$。因此，用于此反应的 FE 格式不是无条件保正的。\n\n- **后向欧拉 (BE) 离散化**：\n  更新规则为 $y^{n+1} = y^n + \\Delta t \\, f(y^{n+1})$。\n  $$\n  y^{n+1} = y^n + \\Delta t(-k(y^{n+1} - y_{\\mathrm{eq}}))\n  $$\n  解出 $y^{n+1}$：\n  $y^{n+1}(1 + k \\Delta t) = y^n + k \\Delta t y_{\\mathrm{eq}}$\n  $$\n  y^{n+1} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n  $$\n  由于 $y^n \\ge 0$，$k  0$，$\\Delta t  0$ 和 $y_{\\mathrm{eq}}  0$，分子和分母都严格为正。因此，$y^{n+1}  0$。BE 格式是无条件保正的。\n\n**完整格式的构造**\n\n1.  **算子分裂，后向欧拉化学反应 ($A \\circ B$)**：\n    这是一阶李-特罗特 (Lie-Trotter) 分裂，其中先应用化学反应子步，然后是平流子步。\n    -   步骤 1 (化学反应, BE): 对每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{**} = \\frac{y_i^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}\n        $$\n    -   步骤 2 (平流, FE): 对每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n2.  **算子分裂，前向欧拉化学反应 ($A \\circ B$)**：\n    与上述类似，但化学反应子步使用前向欧拉。\n    -   步骤 1 (化学反应, FE): 对每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{**} = y_i^n(1 - k \\Delta t) + k \\Delta t y_{\\mathrm{eq}}\n        $$\n    -   步骤 2 (平流, FE): 对每个单元 $i=0, \\dots, N-1$：\n        $$\n        y_i^{n+1} = y_i^{**} - \\frac{a \\Delta t}{\\Delta x}(y_i^{**} - y_{i-1}^{**})\n        $$\n\n3.  **IMEX 欧拉方法**：\n    IMEX 欧拉方法在单步内显式处理非刚性的平流项，隐式处理刚性的化学反应项。\n    $$\n    \\frac{y_i^{n+1} - y_i^n}{\\Delta t} = \\underbrace{-k(y_i^{n+1} - y_{\\mathrm{eq}})}_{\\text{隐式}} + \\underbrace{\\left(-\\frac{a}{\\Delta x}(y_i^n - y_{i-1}^n)\\right)}_{\\text{显式}}\n    $$\n    整理以解出 $y_i^{n+1}$：\n    $y_i^{n+1} - y_i^n = -k \\Delta t y_i^{n+1} + k \\Delta t y_{\\mathrm{eq}} - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n)$\n    $y_i^{n+1}(1 + k \\Delta t) = y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}}$\n    $$\n    y_i^{n+1} = \\frac{1}{1 + k \\Delta t} \\left( y_i^n - \\frac{a \\Delta t}{\\Delta x}(y_i^n - y_{i-1}^n) + k \\Delta t y_{\\mathrm{eq}} \\right)\n    $$\n\n### 任务2：熵分析\n\n数学熵密度由 $\\eta(y) = y \\ln(y/y_{\\mathrm{eq}}) - (y - y_{\\mathrm{eq}})$ 给出，其中 $y0$。\n\n**$\\eta(y)$ 的凸性和最小值**\n首先，我们求 $\\eta(y)$ 关于 $y$ 的一阶和二阶导数：\n$$\n\\eta'(y) = \\frac{d}{dy} \\left( y \\ln y - y \\ln y_{\\mathrm{eq}} - y + y_{\\mathrm{eq}} \\right) = (\\ln y + 1) - \\ln y_{\\mathrm{eq}} - 1 = \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right)\n$$\n$$\n\\eta''(y) = \\frac{d}{dy} \\left( \\ln y - \\ln y_{\\mathrm{eq}} \\right) = \\frac{1}{y}\n$$\n对于质量分数的物理域 $y  0$，二阶导数 $\\eta''(y) = 1/y$ 严格为正。这证明了 $\\eta(y)$ 对于 $y0$ 是一个严格凸函数。\n\n严格凸函数的唯一最小值出现在其一阶导数为零的地方。\n$$\n\\eta'(y) = 0 \\implies \\ln\\left(\\frac{y}{y_{\\mathrm{eq}}}\\right) = 0 \\implies \\frac{y}{y_{\\mathrm{eq}}} = 1 \\implies y = y_{\\mathrm{eq}}\n$$\n因此，$\\eta(y)$ 在平衡态 $y = y_{\\mathrm{eq}}$ 处达到其唯一的全局最小值。最小值为 $\\eta(y_{\\mathrm{eq}}) = y_{\\mathrm{eq}} \\ln(1) - (y_{\\mathrm{eq}} - y_{\\mathrm{eq}}) = 0$。\n\n**熵耗散和压缩映射**\n离散熵为 $H(\\mathbf{y}) = \\sum_i \\eta(y_i) \\Delta x$。如果在一个步长内 $H$ 不增加，则该化学反应 ODE 的积分器是熵耗散的（或熵稳定的）。由于 $\\eta(y)$ 是凸函数且其最小值在 $y_{\\mathrm{eq}}$ 处，任何使状态更接近 $y_{\\mathrm{eq}}$ 的更新 $y^n \\to y^{n+1}$（即，一个朝向 $y_{\\mathrm{eq}}$ 的压缩映射）都将导致 $\\eta(y^{n+1}) \\le \\eta(y^n)$。如果这对所有单元 $i$ 都成立，那么 $H(\\mathbf{y}^{n+1}) \\le H(\\mathbf{y}^n)$。\n\n**后向欧拉化学反应步的熵稳定性**\n让我们分析 BE 更新 $y^* = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t}$ 与平衡点之间的距离。\n$$\ny^* - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}}}{1 + k \\Delta t} - y_{\\mathrm{eq}} = \\frac{y^n + k \\Delta t y_{\\mathrm{eq}} - y_{\\mathrm{eq}}(1 + k \\Delta t)}{1 + k \\Delta t} = \\frac{y^n - y_{\\mathrm{eq}}}{1 + k \\Delta t}\n$$\n取绝对值：\n$$\n|y^* - y_{\\mathrm{eq}}| = \\frac{1}{1 + k \\Delta t} |y^n - y_{\\mathrm{eq}}|\n$$\n由于 $k0$ 和 $\\Delta t0$，因子 $1/(1+k\\Delta t)$ 严格小于 $1$。这表明对于任何时间步长 $\\Delta t  0$，BE 步都是一个朝向平衡点 $y_{\\mathrm{eq}}$ 的严格压缩映射。因此，对于任何 $y^n \\neq y_{\\mathrm{eq}}$，都有 $\\eta(y^*)  \\eta(y^n)$，而如果 $y^n = y_{\\mathrm{eq}}$，则 $\\eta(y^*) = \\eta(y^n)$。所以，BE 化学反应步是无条件熵稳定的。\n\n对 IMEX 格式的类似分析表明，它可以被解释为一个显式迎风平流步（由于 $\\eta$ 的凸性而是熵稳定的），其后跟着一个无条件熵稳定的 BE 反应步。因此，我们期望完整的 IMEX 步是熵稳定的。然而，显式 FE 化学反应步在 $k \\Delta t  2$ 时不是压缩映射，预计在刚性区域会违反熵稳定性。\n\n### 实现与比较\n实现了三种数值方法——带后向欧拉化学反应的算子分裂法（Split-BE）、带前向欧拉化学反应的算子分裂法（Split-FE）和 IMEX 欧拉法。系统从指定的初始条件演化到时间 $T=0.2$。对于三个测试案例中的每一个 $(k, \\Delta t)$，都用每种方法运行模拟。在模拟过程中，我们跟踪两个属性：\n1.  **保正性**: 解向量 $\\mathbf{y}$ 是否在所有网格点上都保持非负。这在最终时间 $T$ 进行检查。\n2.  **熵稳定性**: 对于每个相关步骤（分裂法中的化学反应子步，IMEX 中的完整步），我们计算该步骤前后的离散熵 $H(\\mathbf{y})$，并验证其没有增加。一个初始化为 true 的布尔标志在第一次违反时被设置为 false。\n使用离散 $\\ell^1$-范数比较 Split-BE 和 IMEX 方法的最终状态，以量化它们的差异。根据问题规范，系统地收集每个测试案例的结果。实现细节在最终答案的代码块中提供。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactive advection problem using three different numerical methods\n    and reports on their stability properties and differences.\n    \"\"\"\n    # Global parameters\n    N = 100\n    L = 1.0\n    dx = L / N\n    a = 0.5\n    y_eq = 0.05\n    T = 0.2\n    x = np.linspace(0, L, N, endpoint=False)\n\n    # Initial condition\n    y0 = y_eq + 0.4 * np.exp(-200 * (x - 0.25)**2) + 0.2 * np.exp(-400 * (x - 0.75)**2)\n\n    # Entropy function eta(y)\n    # Define eta(0) = y_eq for continuity as y*ln(y) - 0 for y-0+\n    def eta(y, y_eq_val):\n        # Use np.where to handle y=0 case to avoid log(0) warnings\n        y_safe = np.where(y  0, y, 1.0) # a dummy value for log, result not used\n        log_term = np.where(y  0, y_safe * np.log(y_safe / y_eq_val), 0)\n        return log_term - (y - y_eq_val)\n\n    # Discrete entropy functional H(y)\n    def discrete_entropy(y, y_eq_val, dx_val):\n        return np.sum(eta(y, y_eq_val)) * dx_val\n\n    # --- Method Implementations ---\n\n    def run_split_be(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        cfl = a_val * dt / dx_val\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time  1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Backward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = (y + k * t_step * y_eq_val) / (1.0 + k * t_step)\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem  H_before_chem + 1e-12: # Check with tolerance\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n        \n        positivity = np.all(y = 0)\n        return y, positivity, entropy_stable\n\n    def run_split_fe(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n\n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time  1e-12:\n            time_steps.append(remaining_time)\n\n        for t_step in time_steps:\n            # Chemistry substep (Forward Euler)\n            H_before_chem = discrete_entropy(y, y_eq_val, dx_val)\n            y_star = y * (1.0 - k * t_step) + k * t_step * y_eq_val\n            H_after_chem = discrete_entropy(y_star, y_eq_val, dx_val)\n            if H_after_chem  H_before_chem + 1e-12:\n                entropy_stable = False\n            \n            # Advection substep (Forward Euler, Upwind)\n            cfl_step = a_val * t_step / dx_val\n            y = y_star - cfl_step * (y_star - np.roll(y_star, 1))\n\n        positivity = np.all(y = 0)\n        return y, positivity, entropy_stable\n\n    def run_imex(y_init, k, dt, T_final, a_val, y_eq_val, dx_val):\n        y = y_init.copy()\n        entropy_stable = True\n        \n        num_steps = int(T_final / dt)\n        remaining_time = T_final - num_steps * dt\n\n        time_steps = [dt] * num_steps\n        if remaining_time  1e-12:\n            time_steps.append(remaining_time)\n        \n        for t_step in time_steps:\n            H_before = discrete_entropy(y, y_eq_val, dx_val)\n            \n            # IMEX update\n            cfl_step = a_val * t_step / dx_val\n            advection_term = y - cfl_step * (y - np.roll(y, 1))\n            numerator = advection_term + k * t_step * y_eq_val\n            denominator = 1.0 + k * t_step\n            y = numerator / denominator\n            \n            H_after = discrete_entropy(y, y_eq_val, dx_val)\n            if H_after  H_before + 1e-12:\n                entropy_stable = False\n        \n        positivity = np.all(y = 0)\n        return y, positivity, entropy_stable\n\n    # Test cases\n    test_cases = [\n        (1000, 0.001),  # Case A\n        (8000, 0.01),   # Case B\n        (500, 0.02),    # Case C\n    ]\n    \n    all_results = []\n\n    for k_val, dt_val in test_cases:\n        y_be, p_be, e_be = run_split_be(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_imex, p_imex, e_imex = run_imex(y0, k_val, dt_val, T, a, y_eq, dx)\n        y_ee, p_ee, e_ee = run_split_fe(y0, k_val, dt_val, T, a, y_eq, dx)\n        \n        d_l1 = np.sum(np.abs(y_imex - y_be)) * dx\n        \n        case_results = [p_be, e_be, p_imex, e_imex, p_ee, e_ee, d_l1]\n        all_results.append(case_results)\n\n    # Format output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        if isinstance(v, np.bool_):\n            return str(v).lower()\n        return f\"{v:.15g}\"\n\n    sublist_strs = []\n    for res in all_results:\n        sublist_strs.append(f\"[{','.join(format_val(v) for v in res)}]\")\n    \n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}