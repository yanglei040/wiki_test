{
    "hands_on_practices": [
        {
            "introduction": "在深入研究由偏微分方程描述的复杂物理系统之前，我们首先通过一个简单的代数系统来建立对雅可比矩阵的核心直观认识。这个练习旨在阐明多物理场耦合在线性化牛顿系统中的具体数学体现。通过亲手计算一个 $2 \\times 2$ 系统的偏导数，您将清楚地看到非对角线项是如何表示场间相互作用的，这是整体式求解方法的基础 。",
            "id": "3515394",
            "problem": "在一个双场多物理场问题的单体（全耦合）隐式解中，代数残差向量由两个分量 $R_{u}(u,v)$ 和 $R_{v}(u,v)$ 定义，这两个分量必须同时为零。考虑具有以下残差的耦合代数系统：\n$$\nR_{u}(u,v) = u + 2v - 1, \\qquad R_{v}(u,v) = 3u + v^{2} - 2.\n$$\n在单体系统的 Newton 线性化中，分块雅可比矩阵 $J(u,v)$ 是残差向量相对于状态向量的 Fréchet 导数，等价于对于状态向量分量 $x_{1}=u$ 和 $x_{2}=v$ 的偏导数矩阵 $J_{ij}(u,v) = \\frac{\\partial R_{i}}{\\partial x_{j}}(u,v)$。使用此基本定义，组装完整的 $2\\times 2$ 分块雅可比矩阵 $J(u,v)$，并在状态 $(u,v)=(1,1)$ 处对其进行求值。然后，基于非线性系统 Newton 方法的基本原理，解释在求解 $(u,v)=(1,1)$ 处的增量 $(\\Delta u,\\Delta v)$ 的线性化系统时，该雅可比矩阵的非对角线元素如何影响 Newton 更新方向。\n\n将最终答案以在 $(u,v)=(1,1)$ 处求值的雅可比矩阵形式提供，写成一个单独的 $2\\times 2$ 矩阵。无需四舍五入，也无单位适用。关于非对角线元素的解释性讨论是您解题思路的一部分，无需出现在最终答案中。",
            "solution": "该问题被验证为科学上合理、适定且客观。它代表了 Newton-Raphson 方法在非线性代数方程组中的一个标准应用，这是耦合多物理场问题单体解中的一项基本技术。所有必要信息均已提供，任务明确。\n\n该问题要求对给定的非线性代数残差系统组装和求值雅可比矩阵，然后结合 Newton 方法的背景对其结构进行解释。\n\n耦合代数系统由一个必须趋于零的残差向量 $R(u,v)$ 定义。残差向量的分量如下：\n$$\nR(u,v) = \\begin{pmatrix} R_{u}(u,v) \\\\ R_{v}(u,v) \\end{pmatrix} = \\begin{pmatrix} u + 2v - 1 \\\\ 3u + v^{2} - 2 \\end{pmatrix}\n$$\n状态向量为 $x = \\begin{pmatrix} u \\\\ v \\end{pmatrix}$。在单体 Newton-Raphson 方案中，系统在当前状态 $(u^k, v^k)$ 被线性化，以找到一个更接近解的增量更新 $(\\Delta u, \\Delta v)$。该线性化由以下方程给出：\n$$\nJ(u^k, v^k) \\begin{pmatrix} \\Delta u \\\\ \\Delta v \\end{pmatrix} = -R(u^k, v^k)\n$$\n其中 $J(u^k, v^k)$ 是在状态 $(u^k, v^k)$ 处求值的雅可比矩阵。\n\n雅可比矩阵 $J(u,v)$ 定义为残差向量各分量相对于状态向量各分量的所有一阶偏导数组成的矩阵。对于我们的 $2 \\times 2$ 系统，雅可比矩阵为：\n$$\nJ(u,v) = \\begin{pmatrix} \\frac{\\partial R_{u}}{\\partial u} & \\frac{\\partial R_{u}}{\\partial v} \\\\ \\frac{\\partial R_{v}}{\\partial u} & \\frac{\\partial R_{v}}{\\partial v} \\end{pmatrix}\n$$\n我们通过对给定的残差函数求导来计算雅可比矩阵的每个元素：\n\n左上角元素 $J_{11}$ 是 $R_u$ 对 $u$ 的导数：\n$$\nJ_{11}(u,v) = \\frac{\\partial R_{u}}{\\partial u} = \\frac{\\partial}{\\partial u}(u + 2v - 1) = 1\n$$\n\n右上角元素 $J_{12}$ 是 $R_u$ 对 $v$ 的导数。这是一个非对角项，表示变量 $v$ 对第一个方程的耦合：\n$$\nJ_{12}(u,v) = \\frac{\\partial R_{u}}{\\partial v} = \\frac{\\partial}{\\partial v}(u + 2v - 1) = 2\n$$\n\n左下角元素 $J_{21}$ 是 $R_v$ 对 $u$ 的导数。这是另一个非对角项，表示变量 $u$ 对第二个方程的耦合：\n$$\nJ_{21}(u,v) = \\frac{\\partial R_{v}}{\\partial u} = \\frac{\\partial}{\\partial u}(3u + v^{2} - 2) = 3\n$$\n\n右下角元素 $J_{22}$ 是 $R_v$ 对 $v$ 的导数：\n$$\nJ_{22}(u,v) = \\frac{\\partial R_{v}}{\\partial v} = \\frac{\\partial}{\\partial v}(3u + v^{2} - 2) = 2v\n$$\n\n将这些分量组合起来，得到完整的符号雅可比矩阵：\n$$\nJ(u,v) = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2v \\end{pmatrix}\n$$\n问题要求在特定状态 $(u,v)=(1,1)$ 处对该雅可比矩阵进行求值：\n$$\nJ(1,1) = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2(1) \\end{pmatrix} = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix}\n$$\n这就是最终答案所要求的矩阵。\n\n为了解释非对角线元素的作用，我们首先在点 $(u,v)=(1,1)$ 处计算残差向量：\n$$\nR(1,1) = \\begin{pmatrix} 1 + 2(1) - 1 \\\\ 3(1) + (1)^{2} - 2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\n$$\n因此，在该点的 Newton 更新系统为：\n$$\n\\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix} \\begin{pmatrix} \\Delta u \\\\ \\Delta v \\end{pmatrix} = -\\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -2 \\end{pmatrix}\n$$\n该矩阵方程对应于以下线性方程组：\n$$\n\\begin{cases} 1\\Delta u + 2\\Delta v = -2 \\\\ 3\\Delta u + 2\\Delta v = -2 \\end{cases}\n$$\n雅可比矩阵的非对角线元素 $J_{12} = \\frac{\\partial R_u}{\\partial v} = 2$ 和 $J_{21} = \\frac{\\partial R_v}{\\partial u} = 3$ 是该问题“全耦合”性质的核心。\n项 $J_{12} = 2$ 表明第一个残差 $R_u$ 对变量 $v$ 的变化很敏感。它在线性化系统中的存在意味着确定更新量 $\\Delta u$ 的方程与更新量 $\\Delta v$ 是耦合的。具体来说，第一个方程 $1\\Delta u + 2\\Delta v = -2$ 表明 $\\Delta u$ 的选择取决于 $\\Delta v$ 的值。\n类似地，项 $J_{21} = 3$ 表明第二个残差 $R_v$ 对变量 $u$ 的变化很敏感。这通过第二个方程 $3\\Delta u + 2\\Delta v = -2$ 将更新量 $\\Delta v$ 的确定与更新量 $\\Delta u$ 耦合起来。\n\n如果系统是解耦的，非对角项将为零。在这种假设情况下，更新方程将是 $J_{11}\\Delta u = -R_u$ 和 $J_{22}\\Delta v = -R_v$，从而可以独立计算 $\\Delta u$ 和 $\\Delta v$。由于非对角线元素非零，增量方程组必须同时求解。这种由雅可比矩阵的非零非对角块所体现的数学耦合，是多物理场问题单体求解方法的定义特征，其中一个物理场（由 $u$ 表示）的行为直接影响另一个物理场（由 $v$ 表示），反之亦然。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "现在，我们将抽象的代数概念应用到一个具体的物理问题中，即非线性热传导。在工程和科学领域，我们通常使用有限元方法 (FEM) 将连续的控制方程（偏微分方程）离散化为代数方程组。这个练习将指导您从弱形式出发，通过“一致性线性化”来推导非线性有限元问题的雅可比矩阵（或称切线刚度矩阵），并揭示材料非线性是如何导致雅可比矩阵依赖于解的状态的 。",
            "id": "3515324",
            "problem": "考虑一个无量纲稳态一维非线性热传导问题。该问题在一个横跨无量纲长度为 $h=3$、单位横截面积杆的单个双节点线性有限元上进行分析。温度场 $T(x)$ 通过标准线性形函数 $N_1(x)=1-x/h$ 和 $N_2(x)=x/h$ 近似为 $T(x)=N_1(x)\\,T_1+N_2(x)\\,T_2$，其中 $T_1$ 和 $T_2$ 是节点温度。热导率与温度相关，由 $k(T)=1+T$ 给出，其中 $T$ 是无量纲的。假设没有内部热源，并专注于弱形式中的内部算子。\n\n从强形式 $-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right)=0$ 出发，在有限元法 (FEM) 框架内，使用标准的 Galerkin 方法构建残差，并采用整体式 Newton-Raphson (NR) 方法所需的一致性线性化，从第一性原理推导单元级雅可比矩阵的各项 $J_{ij}=\\frac{\\partial R_i}{\\partial T_j}$（其中 $i,j\\in\\{1,2\\}$），$R_i$ 是与测试函数 $N_i$ 相关的单元残差。然后，在当前 NR 迭代步中，给定节点值为 $T_1=0.2$ 和 $T_2=0.8$，计算四个雅可比项 $J_{11}$、$J_{12}$、$J_{21}$ 和 $J_{22}$ 的数值。\n\n将这四个项表示为无量纲数，并将每个数四舍五入到四位有效数字。以单行向量的形式报告您的最终答案，顺序为 $(J_{11},\\,J_{12},\\,J_{21},\\,J_{22})$。",
            "solution": "本题要求使用有限元法 (FEM) 推导并计算一维非线性热传导问题的单元级雅可比矩阵。\n\n无内部热源的稳态热传导方程的强形式如下：\n$$-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right) = 0$$\n其中 $x$ 是空间坐标，$T(x)$ 是温度场，$k(T)$ 是与温度相关的热导率。\n\n为了推导弱形式，我们将强形式乘以一个测试函数 $w(x)$，并在从 $x=0$ 到 $x=h$ 的单元域上积分。\n$$\\int_0^h w(x) \\left[-\\frac{d}{dx}\\left(k(T(x))\\frac{dT}{dx}\\right)\\right] dx = 0$$\n应用分部积分法来降低导数的阶数，并将其分布在试探函数和测试函数之间，我们得到：\n$$\\int_0^h \\frac{dw}{dx} k(T(x)) \\frac{dT}{dx} dx - \\left[ w(x) k(T(x)) \\frac{dT}{dx} \\right]_0^h = 0$$\n第二项代表单元边界上的热通量。在组装单元级算子时，我们只考虑积分部分，它定义了内部残差。\n\n根据 Galerkin 方法，测试函数 $w(x)$ 从用于近似温度场的基函数（形函数）的同一集合中选取，即对于 $i=1,2$，$w(x) = N_i(x)$。温度场 $T(x)$ 近似为节点温度 $T_j$ 和形函数 $N_j(x)$ 的线性组合：\n$$T(x) = \\sum_{j=1}^{2} N_j(x) T_j = N_1(x)T_1 + N_2(x)T_2$$\n单元残差向量 $\\mathbf{R}$ 的分量 $R_i$ 对应于每个测试函数 $N_i(x)$：\n$$R_i = \\int_0^h \\frac{dN_i}{dx} k(T(x)) \\frac{dT}{dx} dx$$\n长度为 $h$ 的双节点线性单元的形函数为：\n$$N_1(x) = 1 - \\frac{x}{h}, \\quad N_2(x) = \\frac{x}{h}$$\n它们在单元上为常数的导数为：\n$$B_1 = \\frac{dN_1}{dx} = -\\frac{1}{h}, \\quad B_2 = \\frac{dN_2}{dx} = \\frac{1}{h}$$\n温度梯度在单元上也为常数：\n$$\\frac{dT}{dx} = \\frac{d}{dx}(N_1T_1+N_2T_2) = B_1T_1+B_2T_2 = \\frac{T_2-T_1}{h}$$\n热导率由 $k(T) = 1+T$ 给出。\n\nNewton-Raphson 迭代格式需要雅可比矩阵，或称切线刚度矩阵。其各项由残差分量 $R_i$ 对节点温度未知数 $T_j$ 的偏导数定义：\n$$J_{ij} = \\frac{\\partial R_i}{\\partial T_j} = \\frac{\\partial}{\\partial T_j} \\left( \\int_0^h \\frac{dN_i}{dx} k(T(x)) \\frac{dT}{dx} dx \\right)$$\n由于积分是关于 $x$ 的，我们可以将微分移到积分内部：\n$$J_{ij} = \\int_0^h \\frac{dN_i}{dx} \\frac{\\partial}{\\partial T_j} \\left( k(T(x)) \\frac{dT}{dx} \\right) dx$$\n使用乘法法则进行微分：\n$$J_{ij} = \\int_0^h \\frac{dN_i}{dx} \\left( \\frac{\\partial k(T)}{\\partial T_j} \\frac{dT}{dx} + k(T) \\frac{\\partial}{\\partial T_j}\\left(\\frac{dT}{dx}\\right) \\right) dx$$\n我们计算偏导数项：\n$$\\frac{\\partial}{\\partial T_j}\\left(\\frac{dT}{dx}\\right) = \\frac{\\partial}{\\partial T_j}\\left(\\sum_{l=1}^{2} B_l T_l\\right) = B_j = \\frac{dN_j}{dx}$$\n$$\\frac{\\partial k(T)}{\\partial T_j} = \\frac{dk}{dT} \\frac{\\partial T}{\\partial T_j} = \\frac{dk}{dT} N_j(x)$$\n给定 $k(T)=1+T$，我们有 $\\frac{dk}{dT}=1$。\n将这些代入 $J_{ij}$ 的表达式中：\n$$J_{ij} = \\int_0^h B_i \\left( (1) N_j(x) \\frac{dT}{dx} + k(T(x)) B_j \\right) dx$$\n$$J_{ij} = \\int_0^h B_i B_j k(T(x)) dx + \\int_0^h B_i N_j(x) \\frac{dT}{dx} dx$$\n由于 $B_i$、$B_j$ 和 $\\frac{dT}{dx}$ 在单元内是常数，我们可以将它们从积分中提出：\n$$J_{ij} = B_i B_j \\int_0^h k(T(x)) dx + B_i \\frac{dT}{dx} \\int_0^h N_j(x) dx$$\n我们需要计算这些积分：\n$$\\int_0^h N_1(x) dx = \\int_0^h (1-\\frac{x}{h}) dx = \\left[x - \\frac{x^2}{2h}\\right]_0^h = h - \\frac{h^2}{2h} = \\frac{h}{2}$$\n$$\\int_0^h N_2(x) dx = \\int_0^h \\frac{x}{h} dx = \\left[\\frac{x^2}{2h}\\right]_0^h = \\frac{h^2}{2h} = \\frac{h}{2}$$\n$$\\int_0^h k(T(x)) dx = \\int_0^h (1+T(x)) dx = h + \\int_0^h (N_1(x)T_1 + N_2(x)T_2) dx = h + T_1\\frac{h}{2} + T_2\\frac{h}{2} = h\\left(1 + \\frac{T_1+T_2}{2}\\right)$$\n将这些积分代回 $J_{ij}$ 的表达式中：\n$$J_{ij} = B_i B_j h\\left(1 + \\frac{T_1+T_2}{2}\\right) + B_i \\left(\\frac{T_2-T_1}{h}\\right) \\frac{h}{2}$$\n$$J_{ij} = B_i B_j h\\left(1 + \\frac{T_1+T_2}{2}\\right) + B_i \\frac{T_2-T_1}{2}$$\n\n现在我们计算雅可比矩阵的四个项：\n对于 $J_{11}$ ($i=1, j=1$): $B_1 = -1/h$\n$$J_{11} = \\left(-\\frac{1}{h}\\right)\\left(-\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(-\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) - \\frac{T_2-T_1}{2h} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2 - T_2+T_1}{2}\\right) = \\frac{1}{h}(1+T_1)$$\n对于 $J_{12}$ ($i=1, j=2$): $B_1 = -1/h, B_2 = 1/h$\n$$J_{12} = \\left(-\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(-\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) - \\frac{T_2-T_1}{2h} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2 + T_2-T_1}{2}\\right) = -\\frac{1}{h}(1+T_2)$$\n对于 $J_{21}$ ($i=2, j=1$): $B_2 = 1/h, B_1 = -1/h$\n$$J_{21} = \\left(\\frac{1}{h}\\right)\\left(-\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\frac{T_2-T_1}{2h} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2 - (T_2-T_1)}{2}\\right) = -\\frac{1}{h}(1+T_1)$$\n对于 $J_{22}$ ($i=2, j=2$): $B_2 = 1/h$\n$$J_{22} = \\left(\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\frac{T_2-T_1}{2h} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2 + T_2-T_1}{2}\\right) = \\frac{1}{h}(1+T_2)$$\n符号雅可比矩阵为：\n$$\\mathbf{J} = \\frac{1}{h} \\begin{pmatrix} 1+T_1 & -(1+T_2) \\\\ -(1+T_1) & 1+T_2 \\end{pmatrix}$$\n现在，我们代入给定的数值：$h=3$，$T_1=0.2$ 和 $T_2=0.8$。\n$$J_{11} = \\frac{1}{3}(1+0.2) = \\frac{1.2}{3} = 0.4$$\n$$J_{12} = -\\frac{1}{3}(1+0.8) = -\\frac{1.8}{3} = -0.6$$\n$$J_{21} = -\\frac{1}{3}(1+0.2) = -\\frac{1.2}{3} = -0.4$$\n$$J_{22} = \\frac{1}{3}(1+0.8) = \\frac{1.8}{3} = 0.6$$\n题目要求答案四舍五入到四位有效数字。\n$J_{11} = 0.4000$\n$J_{12} = -0.6000$\n$J_{21} = -0.4000$\n$J_{22} = 0.6000$\n最终答案是这四个项组成的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4000 & -0.6000 & -0.4000 & 0.6000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在最后的这个实践中，我们将从雅可比矩阵的构建转向其应用与分析，探讨一个在实际操作中至关重要的问题：精确雅可比矩阵与数值近似雅可比矩阵之间的权衡。虽然解析雅可比矩阵是精确的，但其推导和实现可能非常复杂，因此有限差分等近似方法被广泛使用。本练习通过一个简化的磁流体动力学 (MHD) 模型，让您亲身体验和量化雅可比矩阵的近似误差对牛顿法收敛性以及物理系统稳定性分析结果的深远影响 。",
            "id": "3515360",
            "problem": "考虑一个简化的、无量纲的、三振幅的电阻磁流体动力学（MHD）稳定性模型，该模型是通过对稳态动量平衡、感应方程和压力闭合项进行 Galerkin 截断得到的。设未知量为无量纲振幅 $U$、$B$ 和 $P$，分别代表流体速度、磁扰动和压力扰动。完全耦合的残差向量 $\\mathbf{F}(U,B,P)$ 定义为\n$$\n\\mathbf{F}(U,B,P) =\n\\begin{bmatrix}\nF_u(U,B,P) \\\\\nF_b(U,B,P) \\\\\nF_p(U,B,P)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf - \\alpha P + \\beta B^2 - \\gamma U - \\delta U^3 \\\\\n\\theta U B - \\eta B - \\zeta B^3 \\\\\nP - \\chi U^2 - \\xi B^2\n\\end{bmatrix},\n$$\n其中所有量均为无量纲，参数 $f$、$\\alpha$、$\\beta$、$\\gamma$、$\\delta$、$\\theta$、$\\eta$、$\\zeta$、$\\chi$ 和 $\\xi$ 均为正常数，但 $\\gamma$ 除外，它可能为正或为负，具体取决于净线性驱动或阻尼。\n\n求解非线性系统 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$（其中 $\\mathbf{x}=[U,B,P]^T$）的整体（完全耦合）Newton 方法需要组装雅可比矩阵\n$$\n\\mathbf{J}(\\mathbf{x}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}(\\mathbf{x}) =\n\\begin{bmatrix}\n\\frac{\\partial F_u}{\\partial U} & \\frac{\\partial F_u}{\\partial B} & \\frac{\\partial F_u}{\\partial P} \\\\\n\\frac{\\partial F_b}{\\partial U} & \\frac{\\partial F_b}{\\partial B} & \\frac{\\partial F_b}{\\partial P} \\\\\n\\frac{\\partial F_p}{\\partial U} & \\frac{\\partial F_p}{\\partial B} & \\frac{\\partial F_p}{\\partial P}\n\\end{bmatrix}.\n$$\n考虑两种组装策略：\n- 精确雅可比矩阵：每个偏导数都根据残差的定义进行解析评估。\n- 有限差分雅可比矩阵：$\\mathbf{J}$ 的每一列 $j$ 通过前向差分公式近似计算\n$$\n\\mathbf{J}_{:,j}(\\mathbf{x}) \\approx \\frac{\\mathbf{F}(\\mathbf{x}+h\\,\\mathbf{e}_j) - \\mathbf{F}(\\mathbf{x})}{h},\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个单位向量，$h>0$ 是所选的有限差分步长。\n\n为了在收敛状态 $\\mathbf{x}^\\star$ 下进行稳定性表征，考虑雅可比矩阵的特征值 $\\lambda_i(\\mathbf{J}(\\mathbf{x}^\\star))$。在这个简化模型中，由雅可比矩阵近似误差引起的伪不稳定模式定义为在有限差分雅可比矩阵谱中存在、但在精确雅可比矩阵谱中不存在的、具有严格正实部的额外特征值，通过计数差来量化\n$$\nN_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau),\n$$\n其中\n$$\nN_+^{\\text{FD}}(\\tau) = \\#\\left\\{i \\,\\middle|\\, \\operatorname{Re}(\\lambda_i(\\mathbf{J}_{\\text{FD}}(\\mathbf{x}^\\star))) > \\tau \\right\\},\\quad\nN_+^{\\text{EX}}(\\tau) = \\#\\left\\{i \\,\\middle|\\, \\operatorname{Re}(\\lambda_i(\\mathbf{J}_{\\text{EX}}(\\mathbf{x}^\\star))) > \\tau \\right\\},\n$$\n并且 $\\tau$ 是一个小的正阈值。\n\n您的任务是，从指定的初始猜测值 $\\mathbf{x}_0$ 开始，为该系统实现一个带有回溯线搜索的整体 Newton 求解器，该求解器使用精确和有限差分两种雅可比矩阵组装方法。对于每个测试用例，执行以下步骤：\n1. 使用精确雅可比矩阵求解 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$ 以获得 $\\mathbf{x}_{\\text{EX}}^\\star$，并记录一个布尔值 $C_{\\text{EX}}$，指示求解器是否在给定容差内收敛。\n2. 使用指定的 $h$ 组装 $\\mathbf{J}_{\\text{EX}}(\\mathbf{x}_{\\text{EX}}^\\star)$ 和 $\\mathbf{J}_{\\text{FD}}(\\mathbf{x}_{\\text{EX}}^\\star)$，然后计算：\n   - 伪特征值的数量 $S = \\max\\left(0, N_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau)\\right)$。\n   - 谱半径的差异 $\\Delta \\rho = \\left|\\max_i \\left|\\lambda_i(\\mathbf{J}_{\\text{FD}}(\\mathbf{x}_{\\text{EX}}^\\star))\\right| - \\max_i \\left|\\lambda_i(\\mathbf{J}_{\\text{EX}}(\\mathbf{x}_{\\text{EX}}^\\star))\\right| \\right|$。\n3. 使用相同的初始猜测值，通过有限差分雅可比矩阵求解 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$ 以获得 $\\mathbf{x}_{\\text{FD}}^\\star$，并记录一个布尔值 $C_{\\text{FD}}$，指示求解器是否在容差内收敛。\n\n所有测试用例均采用以下具体的参数值（无量纲）：\n- $f = 0.05$, $\\alpha = 1.5$, $\\beta = 0.7$, $\\gamma = 0.3$, $\\delta = 1.2$, $\\theta = 0.9$, $\\eta = 0.25$, $\\zeta = 0.5$, $\\chi = 0.8$, $\\xi = 0.6$。\n\n使用以下测试套件，通过改变有限差分步长 $h$ 和初始猜测值 $\\mathbf{x}_0$ 来探究准确性和鲁棒性：\n- 测试用例 A（理想路径，精确的有限差分雅可比矩阵）：\n  - $h = 10^{-8}$。\n  - $\\mathbf{x}_0 = [0.2, 0.05, 0.01]$。\n- 测试用例 B（中等有限差分步长，可能存在轻微性能下降）：\n  - $h = 10^{-3}$。\n  - $\\mathbf{x}_0 = [0.5, 0.3, 0.1]$。\n- 测试用例 C（大有限差分步长，可能存在显著的近似误差）：\n  - $h = 10^{-1}$。\n  - $\\mathbf{x}_0 = [0.7, 0.5, 0.2]$。\n\n所有量均为无量纲；无需物理单位。使用 $\\|\\mathbf{F}(\\mathbf{x})\\|_2 < 10^{-12}$ 的收敛容差，最多 $50$ 次 Newton 迭代，以及当残差范数不减小时将步长最多缩减10次、每次缩减为一半的回溯线搜索。\n\n将不稳定性阈值设为 $\\tau = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为方括号内以逗号分隔的列表，每个测试用例的结果本身是按 $[C_{\\text{EX}}, C_{\\text{FD}}, S, \\Delta \\rho]$ 顺序排列的四个值的列表。例如，输出格式必须为\n$$\n[\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}],\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}],\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}]\\ ].\n$$",
            "solution": "该问题要求实现并比较一个用于非线性方程组的整体 Newton 求解器，该求解器使用两种不同的雅可比矩阵组装策略：精确解析雅可比矩阵和有限差分近似。\n\n### 1. 数学公式\n\n待解系统是一组三个耦合的非线性代数方程，由残差向量 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{0}$ 表示，其中 $\\mathbf{x} = [U, B, P]^T$ 是无量纲振幅的状态向量。残差向量由下式给出：\n$$\n\\mathbf{F}(U,B,P) =\n\\begin{bmatrix}\nF_u(U,B,P) \\\\\nF_b(U,B,P) \\\\\nF_p(U,B,P)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf - \\alpha P + \\beta B^2 - \\gamma U - \\delta U^3 \\\\\n\\theta U B - \\eta B - \\zeta B^3 \\\\\nP - \\chi U^2 - \\xi B^2\n\\end{bmatrix} = \\mathbf{0}\n$$\n常量 $f, \\alpha, \\beta, \\gamma, \\delta, \\theta, \\eta, \\zeta, \\chi, \\xi$ 具有给定的固定值。\n\n### 2. 整体 Newton-Raphson 方法\n\nNewton-Raphson 方法是一种用于寻找非线性方程组根的迭代算法。从一个初始猜测值 $\\mathbf{x}_0$ 开始，它生成一个理想情况下收敛到解 $\\mathbf{x}^\\star$ 的近似序列 $\\mathbf{x}_k$。该方法的核心是通过在当前迭代点 $\\mathbf{x}_k$ 对 $\\mathbf{F}$ 进行一阶泰勒展开推导出的更新规则：\n$$\n\\mathbf{F}(\\mathbf{x}_{k+1}) \\approx \\mathbf{F}(\\mathbf{x}_k) + \\mathbf{J}(\\mathbf{x}_k)(\\mathbf{x}_{k+1} - \\mathbf{x}_k)\n$$\n令 $\\mathbf{F}(\\mathbf{x}_{k+1}) = \\mathbf{0}$ 并将更新步长定义为 $\\Delta\\mathbf{x}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$，我们得到关于更新量的线性系统：\n$$\n\\mathbf{J}(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -\\mathbf{F}(\\mathbf{x}_k)\n$$\n这里，$\\mathbf{J}(\\mathbf{x}_k)$ 是 $\\mathbf{F}$ 在 $\\mathbf{x}_k$ 处求值的雅可比矩阵。在解出 $\\Delta\\mathbf{x}_k$ 后，下一个迭代点计算为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta\\mathbf{x}_k$。\n\n### 3. 雅可比矩阵组装策略\n\n雅可比矩阵 $\\mathbf{J}$ 包含残差分量相对于状态变量的偏导数。指定了两种组装方法。\n\n**a) 精确解析雅可比矩阵 ($\\mathbf{J}_{\\text{EX}}$)**\n\n此方法涉及将 $\\mathbf{F}$ 的每个分量对 $\\mathbf{x} = [U, B, P]^T$ 中的每个变量进行解析微分。得到的导数如下：\n- $\\frac{\\partial F_u}{\\partial U} = -\\gamma - 3\\delta U^2$\n- $\\frac{\\partial F_u}{\\partial B} = 2\\beta B$\n- $\\frac{\\partial F_u}{\\partial P} = -\\alpha$\n\n- $\\frac{\\partial F_b}{\\partial U} = \\theta B$\n- $\\frac{\\partial F_b}{\\partial B} = \\theta U - \\eta - 3\\zeta B^2$\n- $\\frac{\\partial F_b}{\\partial P} = 0$\n\n- $\\frac{\\partial F_p}{\\partial U} = -2\\chi U$\n- $\\frac{\\partial F_p}{\\partial B} = -2\\xi B$\n- $\\frac{\\partial F_p}{\\partial P} = 1$\n\n将这些导数组装成矩阵形式，便得到精确的雅可比矩阵：\n$$\n\\mathbf{J}_{\\text{EX}}(U,B,P) =\n\\begin{bmatrix}\n-\\gamma - 3\\delta U^2 & 2\\beta B & -\\alpha \\\\\n\\theta B & \\theta U - \\eta - 3\\zeta B^2 & 0 \\\\\n-2\\chi U & -2\\xi B & 1\n\\end{bmatrix}\n$$\n\n**b) 有限差分雅可比矩阵 ($\\mathbf{J}_{\\text{FD}}$)**\n\n此方法以数值方式近似偏导数。问题指定了前向差分格式。雅可比矩阵的第 $j$ 列通过扰动状态向量 $\\mathbf{x}$ 的第 $j$ 个分量来近似：\n$$\n\\mathbf{J}_{:,j}(\\mathbf{x}) \\approx \\frac{\\mathbf{F}(\\mathbf{x}+h\\,\\mathbf{e}_j) - \\mathbf{F}(\\mathbf{x})}{h}\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量（例如，$\\mathbf{e}_1 = [1, 0, 0]^T$），$h$ 是一个小的正步长。这种方法避免了手动微分的需要，但引入了与 $h$ 成比例的截断误差。\n\n### 4. 全局化：回溯线搜索\n\n标准的 Newton 步 ($\\Delta\\mathbf{x}_k$) 不能保证残差范数 $\\|\\mathbf{F}(\\mathbf{x})\\|_2$ 的减小，尤其是在离解较远时。为提高鲁棒性，采用回溯线搜索。更新规则被修改为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k$，其中 $\\alpha_k \\in (0, 1]$ 是一个步长。我们从 $\\alpha_k=1$（完整的 Newton 步）开始，并检查是否满足 $\\|\\mathbf{F}(\\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k)\\|_2 < \\|\\mathbf{F}(\\mathbf{x}_k)\\|_2$。如果条件不满足，$\\alpha_k$ 将被连续减小（例如，每次乘以因子 $1/2$），直到实现残差范数的减小或达到最大缩减次数。如果找不到合适的 $\\alpha_k$，求解器将终止，表示不收敛。\n\n### 5. 稳定性与谱分析\n\n在收敛解 $\\mathbf{x}^\\star$ 处，该稳态的稳定性由雅可比矩阵 $\\mathbf{J}(\\mathbf{x}^\\star)$ 的特征值 $\\lambda_i$ 决定。如果任何特征值具有严格为正的实部 ($\\operatorname{Re}(\\lambda_i) > 0$)，则系统是不稳定的。任务要求量化由有限差分近似引入的伪不稳定模式。这是通过计算 $S = \\max(0, N_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau))$ 来完成的，其中 $N_+$ 是实部大于一个小的阈值 $\\tau = 10^{-6}$ 的特征值的数量。此外，还计算两个雅可比矩阵之间的谱半径之差 $\\Delta \\rho$，作为衡量整体谱失真的指标。谱半径 $\\rho(\\mathbf{J})$ 定义为 $\\max_i |\\lambda_i(\\mathbf{J})|$。\n\n### 6. 实现策略\n\n解决方案使用 Python 的 `numpy` 库实现。\n1.  一个函数 `residual` 为给定的状态向量 $\\mathbf{x}$ 计算 $\\mathbf{F}(\\mathbf{x})$。\n2.  函数 `exact_jacobian` 和 `fd_jacobian` 实现了上述两种组装策略。\n3.  创建了一个通用的 `newton_solver` 函数。它接受一个初始猜测值 $\\mathbf{x}_0$ 和一个雅可比矩阵组装函数的句柄。它迭代求解线性系统并应用回溯线搜索，直到残差的 L2 范数低于 $10^{-12}$ 的容差或达到 $50$ 的最大迭代次数。\n4.  对于每个测试用例，首先使用精确雅可比矩阵调用 `newton_solver`。得到的解 $\\mathbf{x}_{\\text{EX}}^\\star$ 用于计算 $\\mathbf{J}_{\\text{EX}}$ 和 $\\mathbf{J}_{\\text{FD}}$。\n5.  `numpy.linalg.eigvals` 用于找到两个矩阵的特征值。然后用这些特征值来计算伪模式的数量 $S$ 和谱半径的差异 $\\Delta\\rho$。\n6.  第二次使用有限差分雅可比矩阵和相同的初始猜测值 $\\mathbf{x}_0$ 调用 `newton_solver`，以确定其收敛行为。\n7.  收集每个测试用例的结果 ($C_{\\text{EX}}$, $C_{\\text{FD}}$, $S$, $\\Delta \\rho$)，并以指定格式打印。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Solves the MHD amplitude model using a monolithic Newton method\n    with both exact and finite-difference Jacobians and analyzes the results.\n    \"\"\"\n    \n    # ------------------ Parameters and Configuration ------------------\n    # Dimensionless physical parameters\n    PARAMS = {\n        'f': 0.05, 'alpha': 1.5, 'beta': 0.7, 'gamma': 0.3, 'delta': 1.2,\n        'theta': 0.9, 'eta': 0.25, 'zeta': 0.5, 'chi': 0.8, 'xi': 0.6\n    }\n    \n    # Newton solver settings\n    TOL = 1e-12\n    MAX_ITER = 50\n    MAX_LS_STEPS = 10\n    \n    # Stability analysis threshold\n    TAU = 1e-6\n    \n    # Test cases {h_value, initial_guess}\n    test_cases = [\n        {'h': 1e-8, 'x0': [0.2, 0.05, 0.01]},  # Test case A\n        {'h': 1e-3, 'x0': [0.5, 0.3, 0.1]},    # Test case B\n        {'h': 1e-1, 'x0': [0.7, 0.5, 0.2]}     # Test case C\n    ]\n    \n    # ------------------ Core Mathematical Functions ------------------\n    def residual(x, params):\n        \"\"\"Computes the residual vector F(x).\"\"\"\n        U, B, P = x\n        p = params\n        F_u = p['f'] - p['alpha']*P + p['beta']*B**2 - p['gamma']*U - p['delta']*U**3\n        F_b = p['theta']*U*B - p['eta']*B - p['zeta']*B**3\n        F_p = P - p['chi']*U**2 - p['xi']*B**2\n        return np.array([F_u, F_b, F_p])\n\n    def exact_jacobian(x, params):\n        \"\"\"Computes the exact analytical Jacobian matrix J_EX(x).\"\"\"\n        U, B, P = x\n        p = params\n        J = np.zeros((3, 3))\n        # dF_u/dx\n        J[0, 0] = -p['gamma'] - 3*p['delta']*U**2\n        J[0, 1] = 2*p['beta']*B\n        J[0, 2] = -p['alpha']\n        # dF_b/dx\n        J[1, 0] = p['theta']*B\n        J[1, 1] = p['theta']*U - p['eta'] - 3*p['zeta']*B**2\n        J[1, 2] = 0\n        # dF_p/dx\n        J[2, 0] = -2*p['chi']*U\n        J[2, 1] = -2*p['xi']*B\n        J[2, 2] = 1\n        return J\n\n    def fd_jacobian(x, h, params):\n        \"\"\"Computes the finite-difference Jacobian matrix J_FD(x).\"\"\"\n        n = len(x)\n        J = np.zeros((n, n))\n        F0 = residual(x, params)\n        for j in range(n):\n            x_plus_h = x.copy()\n            x_plus_h[j] += h\n            F_plus_h = residual(x_plus_h, params)\n            J[:, j] = (F_plus_h - F0) / h\n        return J\n\n    # ------------------ Newton Solver Implementation ------------------\n    def newton_solver(x0, jacobian_func, params, tol, max_iter, max_ls_steps):\n        \"\"\"Monolithic Newton solver with backtracking line search.\"\"\"\n        x_k = np.array(x0, dtype=float)\n\n        for _ in range(max_iter):\n            F_k = residual(x_k, params)\n            norm_Fk = np.linalg.norm(F_k)\n\n            if norm_Fk  tol:\n                return x_k, True\n\n            try:\n                J_k = jacobian_func(x_k)\n                dx = np.linalg.solve(J_k, -F_k)\n            except np.linalg.LinAlgError:\n                return x_k, False  # Singular matrix\n\n            # Backtracking line search\n            alpha = 1.0\n            for _ in range(max_ls_steps):\n                x_new = x_k + alpha * dx\n                norm_F_new = np.linalg.norm(residual(x_new, params))\n                if norm_F_new  norm_Fk:\n                    x_k = x_new\n                    break\n                alpha /= 2.0\n            else:\n                # Line search failed to find a decreasing step\n                return x_k, False\n        \n        # Max iterations reached\n        return x_k, False\n\n    # ------------------ Main Execution Logic ------------------\n    all_results = []\n    for case in test_cases:\n        h, x0_list = case['h'], case['x0']\n        x0 = np.array(x0_list, dtype=float)\n\n        # 1. Solve with Exact Jacobian\n        jac_ex_func = lambda x: exact_jacobian(x, PARAMS)\n        x_ex_star, C_ex = newton_solver(x0, jac_ex_func, PARAMS, TOL, MAX_ITER, MAX_LS_STEPS)\n        \n        # 2. Assemble Jacobians at the exact solution and analyze\n        J_ex_at_sol = exact_jacobian(x_ex_star, PARAMS)\n        J_fd_at_sol = fd_jacobian(x_ex_star, h, PARAMS)\n        \n        eigs_ex = np.linalg.eigvals(J_ex_at_sol)\n        eigs_fd = np.linalg.eigvals(J_fd_at_sol)\n        \n        # Count spurious unstable modes\n        N_plus_ex = np.sum(np.real(eigs_ex) > TAU)\n        N_plus_fd = np.sum(np.real(eigs_fd) > TAU)\n        S = max(0, N_plus_fd - N_plus_ex)\n        \n        # Calculate difference in spectral radii\n        rho_ex = np.max(np.abs(eigs_ex))\n        rho_fd = np.max(np.abs(eigs_fd))\n        delta_rho = np.abs(rho_fd - rho_ex)\n        \n        # 3. Solve with Finite-Difference Jacobian\n        jac_fd_func = lambda x: fd_jacobian(x, h, PARAMS)\n        _, C_fd = newton_solver(x0, jac_fd_func, PARAMS, TOL, MAX_ITER, MAX_LS_STEPS)\n        \n        all_results.append([C_ex, C_fd, int(S), delta_rho])\n\n    # Final print statement in the exact required format\n    print(f\"[[{all_results[0][0]}, {all_results[0][1]}, {all_results[0][2]}, {all_results[0][3]}], [{all_results[1][0]}, {all_results[1][1]}, {all_results[1][2]}, {all_results[1][3]}], [{all_results[2][0]}, {all_results[2][1]}, {all_results[2][2]}, {all_results[2][3]}]]\")\n\nsolve()\n```"
        }
    ]
}