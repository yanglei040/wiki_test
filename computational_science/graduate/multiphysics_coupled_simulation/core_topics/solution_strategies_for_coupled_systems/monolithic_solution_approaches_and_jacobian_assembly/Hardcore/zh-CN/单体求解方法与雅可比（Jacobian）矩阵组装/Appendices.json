{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的偏微分方程之前，我们可以通过一个简单的代数方程组来理解整体式耦合的核心。这个练习  通过让你计算一个双变量系统的雅可比矩阵，并解释代表耦合的“非对角”项对求解过程的实际意义，从而揭开雅可比矩阵的神秘面纱。这个基础练习旨在建立对雅可比矩阵在多物理场耦合求解器中角色的直观理解。",
            "id": "3515394",
            "problem": "在一个双场多物理场问题的单体（全耦合）隐式解法中，代数残差向量由两个必须同时为零的分量 $R_{u}(u,v)$ 和 $R_{v}(u,v)$ 定义。考虑具有以下残差的耦合代数系统\n$$\nR_{u}(u,v) = u + 2v - 1, \\qquad R_{v}(u,v) = 3u + v^{2} - 2.\n$$\n在单体系统的牛顿线性化中，块雅可比矩阵 $J(u,v)$ 是残差向量相对于状态向量的弗雷歇导数（Fréchet derivative），等效于偏导数矩阵 $J_{ij}(u,v) = \\frac{\\partial R_{i}}{\\partial x_{j}}(u,v)$，其中状态向量分量为 $x_{1}=u$ 和 $x_{2}=v$。使用这个基本定义，构建完整的 $2\\times 2$ 块雅可比矩阵 $J(u,v)$，并在状态 $(u,v)=(1,1)$ 处对其进行求值。然后，基于非线性系统牛顿法的基本原理，解释在求解状态 $(u,v)=(1,1)$ 处的增量 $(\\Delta u,\\Delta v)$ 的线性化系统时，该雅可比矩阵的非对角线元素如何影响牛顿更新方向。\n\n将最终答案以在 $(u,v)=(1,1)$ 处求值的雅可比矩阵形式给出，写成一个单一的 $2\\times 2$ 矩阵。无需四舍五入，无单位适用。关于非对角线元素的解释性讨论是您解题思路的一部分，无需出现在最终答案中。",
            "solution": "该问题经检验具有科学依据、良态且客观。它代表了牛顿-拉夫逊（Newton-Raphson）方法在非线性代数方程组中的一个标准应用，这是耦合多物理场问题单体解法中的一项基本技术。所有必要信息均已提供，任务明确。\n\n该问题要求针对给定的非线性代数残差系统，构建并评估其雅可比矩阵，然后在牛顿法的背景下解释其结构。\n\n耦合代数系统由一个必须趋于零的残差向量 $R(u,v)$ 定义。残差向量的分量如下：\n$$\nR(u,v) = \\begin{pmatrix} R_{u}(u,v) \\\\ R_{v}(u,v) \\end{pmatrix} = \\begin{pmatrix} u + 2v - 1 \\\\ 3u + v^{2} - 2 \\end{pmatrix}\n$$\n状态向量为 $x = \\begin{pmatrix} u \\\\ v \\end{pmatrix}$。在单体牛顿-拉夫逊（Newton-Raphson）方案中，系统在当前状态 $(u^k, v^k)$ 处被线性化，以找到一个更接近解的增量更新 $(\\Delta u, \\Delta v)$。该线性化由以下方程给出：\n$$\nJ(u^k, v^k) \\begin{pmatrix} \\Delta u \\\\ \\Delta v \\end{pmatrix} = -R(u^k, v^k)\n$$\n其中 $J(u^k, v^k)$ 是在状态 $(u^k, v^k)$ 处求值的雅可比矩阵。\n\n雅可比矩阵 $J(u,v)$ 定义为残差向量各分量对状态向量各分量的一阶偏导数所组成的矩阵。对于我们的 $2 \\times 2$ 系统，雅可比矩阵为：\n$$\nJ(u,v) = \\begin{pmatrix} \\frac{\\partial R_{u}}{\\partial u} & \\frac{\\partial R_{u}}{\\partial v} \\\\ \\frac{\\partial R_{v}}{\\partial u} & \\frac{\\partial R_{v}}{\\partial v} \\end{pmatrix}\n$$\n我们通过对给定的残差函数求导来计算雅可比矩阵的每个元素：\n\n左上角的元素 $J_{11}$ 是 $R_u$ 关于 $u$ 的导数：\n$$\nJ_{11}(u,v) = \\frac{\\partial R_{u}}{\\partial u} = \\frac{\\partial}{\\partial u}(u + 2v - 1) = 1\n$$\n\n右上角的元素 $J_{12}$ 是 $R_u$ 关于 $v$ 的导数。这是一个非对角项，表示变量 $v$ 到第一个方程的耦合：\n$$\nJ_{12}(u,v) = \\frac{\\partial R_{u}}{\\partial v} = \\frac{\\partial}{\\partial v}(u + 2v - 1) = 2\n$$\n\n左下角的元素 $J_{21}$ 是 $R_v$ 关于 $u$ 的导数。这是另一个非对角项，表示变量 $u$ 到第二个方程的耦合：\n$$\nJ_{21}(u,v) = \\frac{\\partial R_{v}}{\\partial u} = \\frac{\\partial}{\\partial u}(3u + v^{2} - 2) = 3\n$$\n\n右下角的元素 $J_{22}$ 是 $R_v$ 关于 $v$ 的导数：\n$$\nJ_{22}(u,v) = \\frac{\\partial R_{v}}{\\partial v} = \\frac{\\partial}{\\partial v}(3u + v^{2} - 2) = 2v\n$$\n\n组合这些分量得到完整的符号雅可比矩阵：\n$$\nJ(u,v) = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2v \\end{pmatrix}\n$$\n题目要求在特定状态 $(u,v)=(1,1)$ 处评估该雅可比矩阵：\n$$\nJ(1,1) = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2(1) \\end{pmatrix} = \\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix}\n$$\n这就是最终答案所要求的矩阵。\n\n为了解释非对角线元素的作用，我们首先在点 $(u,v)=(1,1)$ 处计算残差向量：\n$$\nR(1,1) = \\begin{pmatrix} 1 + 2(1) - 1 \\\\ 3(1) + (1)^{2} - 2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\n$$\n因此，在该点的牛顿更新系统为：\n$$\n\\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix} \\begin{pmatrix} \\Delta u \\\\ \\Delta v \\end{pmatrix} = -\\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -2 \\end{pmatrix}\n$$\n该矩阵方程对应于以下线性方程组：\n$$\n\\begin{cases} 1\\Delta u + 2\\Delta v = -2 \\\\ 3\\Delta u + 2\\Delta v = -2 \\end{cases}\n$$\n雅可比矩阵的非对角线元素 $J_{12} = \\frac{\\partial R_u}{\\partial v} = 2$ 和 $J_{21} = \\frac{\\partial R_v}{\\partial u} = 3$ 是该问题“全耦合”特性的核心。\n项 $J_{12} = 2$ 表明第一个残差 $R_u$ 对变量 $v$ 的变化敏感。它在线性化系统中的存在意味着确定更新量 $\\Delta u$ 的方程与更新量 $\\Delta v$ 是耦合的。具体来说，第一个方程 $1\\Delta u + 2\\Delta v = -2$ 表明 $\\Delta u$ 的选择取决于 $\\Delta v$ 的值。\n同样，项 $J_{21} = 3$ 表明第二个残差 $R_v$ 对变量 $u$ 的变化敏感。这通过第二个方程 $3\\Delta u + 2\\Delta v = -2$ 将更新量 $\\Delta v$ 的确定与更新量 $\\Delta u$ 耦合起来。\n\n如果系统是解耦的，非对角线项将为零。在这种假设情况下，更新方程将是 $J_{11}\\Delta u = -R_u$ 和 $J_{22}\\Delta v = -R_v$，从而可以独立计算 $\\Delta u$ 和 $\\Delta v$。由于非对角线元素不为零，增量的方程组必须联立求解。这种由雅可比矩阵的非零非对角块所体现的数学耦合，是多物理场问题单体解法的决定性特征，其中一个物理场（由 $u$ 表示）的行为直接影响另一个物理场（由 $v$ 表示），反之亦然。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & 2 \\\\ 3 & 2 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在代数示例的基础上，我们现在转向一个更真实的场景，即一个离散化的偏微分方程。这项练习  将引导你从弱形式出发，推导非线性热传导问题的单元级雅可比矩阵（或称“切线刚度矩阵”）。它展示了非线性材料属性（如 $k(T)$）如何使得这种线性化成为基于牛顿法求解器的必要步骤，将雅可比的概念与有限元方法具体联系起来。",
            "id": "3515324",
            "problem": "考虑一个无量纲稳态一维非线性热传导问题，该问题定义在一个跨越无量纲长度为 $h=3$、单位横截面积杆件的单个双节点线性有限元上。温度场 $T(x)$ 由标准线性形函数 $N_1(x)=1-x/h$ 和 $N_2(x)=x/h$ 近似表示为 $T(x)=N_1(x)\\,T_1+N_2(x)\\,T_2$，其中 $T_1$ 和 $T_2$ 是节点温度。热导率与温度相关，由 $k(T)=1+T$ 给出，其中 $T$ 是无量纲的。假设没有内部热源，并关注弱形式中的内部算子。\n\n从强形式 $-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right)=0$ 出发，在有限元法 (FEM) 框架内，使用标准的Galerkin方法构造残差，并采用整体Newton-Raphson (NR) 方法所需的一致线性化，从第一性原理推导单元级雅可比矩阵项 $J_{ij}=\\frac{\\partial R_i}{\\partial T_j}$ (其中 $i,j\\in\\{1,2\\}$)，$R_i$ 是与试函数 $N_i$ 相关的单元残差。然后，在由节点值 $T_1=0.2$ 和 $T_2=0.8$ 给出的当前NR迭代步，计算四个雅可比矩阵项 $J_{11}$、$J_{12}$、$J_{21}$ 和 $J_{22}$ 的数值。\n\n将这四个项表示为无量纲数，并将每个数值四舍五入到四位有效数字。以单行向量的形式报告你的最终答案，顺序为 $\\left(J_{11},\\,J_{12},\\,J_{21},\\,J_{22}\\right)$。",
            "solution": "该问题是使用有限元法 (FEM) 推导并计算一个一维非线性热传导问题的单元级雅可比矩阵。\n\n无内热源的稳态热传导方程的强形式如下：\n$$-\\frac{d}{dx}\\left(k(T)\\frac{dT}{dx}\\right) = 0$$\n其中 $x$ 是空间坐标，$T(x)$ 是温度场，$k(T)$ 是与温度相关的热导率。\n\n为推导弱形式，我们将强形式乘以一个试函数 $w(x)$，并在从 $x=0$ 到 $x=h$ 的单元域上进行积分。\n$$\\int_0^h w(x) \\left[-\\frac{d}{dx}\\left(k(T(x))\\frac{dT}{dx}\\right)\\right] dx = 0$$\n应用分部积分法以降低导数的阶数，并将其分布到试探函数和检验函数上，我们得到：\n$$\\int_0^h \\frac{dw}{dx} k(T(x)) \\frac{dT}{dx} dx - \\left[ w(x) k(T(x)) \\frac{dT}{dx} \\right]_0^h = 0$$\n第二项表示单元边界上的热通量。在组装单元级算子时，我们只考虑积分部分，它定义了内部残差。\n\n根据Galerkin方法，检验函数 $w(x)$ 从用于近似温度场的基函数（形函数）的同一集合中选取，即 $w(x) = N_i(x)$，其中 $i=1,2$。温度场 $T(x)$ 近似为节点温度 $T_j$ 和形函数 $N_j(x)$ 的线性组合：\n$$T(x) = \\sum_{j=1}^{2} N_j(x) T_j = N_1(x)T_1 + N_2(x)T_2$$\n单元残差向量 $\\mathbf{R}$ 的分量 $R_i$ 对应于每个检验函数 $N_i(x)$：\n$$R_i = \\int_0^h \\frac{dN_i}{dx} k(T(x)) \\frac{dT}{dx} dx$$\n长度为 $h$ 的双节点线性单元的形函数为：\n$$N_1(x) = 1 - \\frac{x}{h}, \\quad N_2(x) = \\frac{x}{h}$$\n它们的导数在单元上是常数，为：\n$$B_1 = \\frac{dN_1}{dx} = -\\frac{1}{h}, \\quad B_2 = \\frac{dN_2}{dx} = \\frac{1}{h}$$\n温度梯度在单元上也是常数：\n$$\\frac{dT}{dx} = \\frac{d}{dx}(N_1T_1+N_2T_2) = B_1T_1+B_2T_2 = \\frac{T_2-T_1}{h}$$\n热导率由 $k(T) = 1+T$ 给出。\n\nNewton-Raphson迭代格式需要雅可比矩阵，或称切线刚度矩阵。其矩阵项由残差分量 $R_i$ 对节点温度未知量 $T_j$ 的偏导数定义：\n$$J_{ij} = \\frac{\\partial R_i}{\\partial T_j} = \\frac{\\partial}{\\partial T_j} \\left( \\int_0^h \\frac{dN_i}{dx} k(T(x)) \\frac{dT}{dx} dx \\right)$$\n由于积分是关于 $x$ 的，我们可以将微分移到积分号内：\n$$J_{ij} = \\int_0^h \\frac{dN_i}{dx} \\frac{\\partial}{\\partial T_j} \\left( k(T(x)) \\frac{dT}{dx} \\right) dx$$\n使用微分的乘法法则：\n$$J_{ij} = \\int_0^h \\frac{dN_i}{dx} \\left( \\frac{\\partial k(T)}{\\partial T_j} \\frac{dT}{dx} + k(T) \\frac{\\partial}{\\partial T_j}\\left(\\frac{dT}{dx}\\right) \\right) dx$$\n我们计算偏导数项：\n$$\\frac{\\partial}{\\partial T_j}\\left(\\frac{dT}{dx}\\right) = \\frac{\\partial}{\\partial T_j}\\left(\\sum_{l=1}^{2} B_l T_l\\right) = B_j = \\frac{dN_j}{dx}$$\n$$\\frac{\\partial k(T)}{\\partial T_j} = \\frac{dk}{dT} \\frac{\\partial T}{\\partial T_j} = \\frac{dk}{dT} N_j(x)$$\n给定 $k(T)=1+T$，我们有 $\\frac{dk}{dT}=1$。\n将这些代入 $J_{ij}$ 的表达式中：\n$$J_{ij} = \\int_0^h B_i \\left( (1) N_j(x) \\frac{dT}{dx} + k(T(x)) B_j \\right) dx$$\n$$J_{ij} = \\int_0^h B_i B_j k(T(x)) dx + \\int_0^h B_i N_j(x) \\frac{dT}{dx} dx$$\n由于 $B_i$、$B_j$ 和 $\\frac{dT}{dx}$ 在单元内是常数，我们可以将它们从积分中提出：\n$$J_{ij} = B_i B_j \\int_0^h k(T(x)) dx + B_i \\frac{dT}{dx} \\int_0^h N_j(x) dx$$\n我们需要计算以下积分：\n$$\\int_0^h N_1(x) dx = \\int_0^h (1-\\frac{x}{h}) dx = \\left[x - \\frac{x^2}{2h}\\right]_0^h = h - \\frac{h^2}{2h} = \\frac{h}{2}$$\n$$\\int_0^h N_2(x) dx = \\int_0^h \\frac{x}{h} dx = \\left[\\frac{x^2}{2h}\\right]_0^h = \\frac{h^2}{2h} = \\frac{h}{2}$$\n$$\\int_0^h k(T(x)) dx = \\int_0^h (1+T(x)) dx = h + \\int_0^h (N_1(x)T_1 + N_2(x)T_2) dx = h + T_1\\frac{h}{2} + T_2\\frac{h}{2} = h\\left(1 + \\frac{T_1+T_2}{2}\\right)$$\n将这些积分结果代回 $J_{ij}$ 的表达式中：\n$$J_{ij} = B_i B_j h\\left(1 + \\frac{T_1+T_2}{2}\\right) + B_i \\left(\\frac{T_2-T_1}{h}\\right) \\frac{h}{2}$$\n$$J_{ij} = B_i B_j h\\left(1 + \\frac{T_1+T_2}{2}\\right) + B_i \\frac{T_2-T_1}{2}$$\n\n现在我们计算雅可比矩阵的四个项：\n对于 $J_{11}$ ($i=1, j=1$)：$B_1 = -1/h$\n$$J_{11} = \\left(-\\frac{1}{h}\\right)\\left(-\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(-\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) - \\frac{T_2-T_1}{2h} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2 - T_2+T_1}{2}\\right) = \\frac{1}{h}(1+T_1)$$\n对于 $J_{12}$ ($i=1, j=2$)：$B_1 = -1/h, B_2 = 1/h$\n$$J_{12} = \\left(-\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(-\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) - \\frac{T_2-T_1}{2h} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2 + T_2-T_1}{2}\\right) = -\\frac{1}{h}(1+T_2)$$\n对于 $J_{21}$ ($i=2, j=1$)：$B_2 = 1/h, B_1 = -1/h$\n$$J_{21} = \\left(\\frac{1}{h}\\right)\\left(-\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\frac{T_2-T_1}{2h} = -\\frac{1}{h}\\left(1 + \\frac{T_1+T_2 - (T_2-T_1)}{2}\\right) = -\\frac{1}{h}(1+T_1)$$\n对于 $J_{22}$ ($i=2, j=2$)：$B_2 = 1/h$\n$$J_{22} = \\left(\\frac{1}{h}\\right)\\left(\\frac{1}{h}\\right)h\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\left(\\frac{1}{h}\\right)\\frac{T_2-T_1}{2} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2}{2}\\right) + \\frac{T_2-T_1}{2h} = \\frac{1}{h}\\left(1 + \\frac{T_1+T_2 + T_2-T_1}{2}\\right) = \\frac{1}{h}(1+T_2)$$\n符号雅可比矩阵为：\n$$\\mathbf{J} = \\frac{1}{h} \\begin{pmatrix} 1+T_1 & -(1+T_2) \\\\ -(1+T_1) & 1+T_2 \\end{pmatrix}$$\n现在，我们代入给定的数值：$h=3$，$T_1=0.2$ 和 $T_2=0.8$。\n$$J_{11} = \\frac{1}{3}(1+0.2) = \\frac{1.2}{3} = 0.4$$\n$$J_{12} = -\\frac{1}{3}(1+0.8) = -\\frac{1.8}{3} = -0.6$$\n$$J_{21} = -\\frac{1}{3}(1+0.2) = -\\frac{1.2}{3} = -0.4$$\n$$J_{22} = \\frac{1}{3}(1+0.8) = \\frac{1.8}{3} = 0.6$$\n问题要求答案四舍五入到四位有效数字。\n$J_{11} = 0.4000$\n$J_{12} = -0.6000$\n$J_{21} = -0.4000$\n$J_{22} = 0.6000$\n最终答案是这四个项组成的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4000 & -0.6000 & -0.4000 & 0.6000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "推导解析雅可比矩阵可能复杂且容易出错，这使得有限差分等数值近似方法看起来很有吸引力。这个编程练习  将理论付诸实践，要求你比较一个牛顿求解器在使用精确雅可比矩阵和近似雅可比矩阵时的性能，并对系统进行稳定性分析。你将亲身体会到雅可比矩阵的不准确性会如何降低收敛速度，甚至导致错误的物理结论，例如预测出虚假的系统不稳定性。",
            "id": "3515360",
            "problem": "考虑一个通过对稳态动量平衡方程、感应方程和压力闭合项进行 Galerkin 截断得到的电阻磁流体动力学（MHD）稳定性的简化、无量纲、三振幅模型。设未知量为无量纲振幅 $U$、$B$ 和 $P$，分别代表流体速度、磁扰动和压力扰动。完全耦合的残差向量 $\\mathbf{F}(U,B,P)$ 定义为\n$$\n\\mathbf{F}(U,B,P) =\n\\begin{bmatrix}\nF_u(U,B,P) \\\\\nF_b(U,B,P) \\\\\nF_p(U,B,P)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf - \\alpha P + \\beta B^2 - \\gamma U - \\delta U^3 \\\\\n\\theta U B - \\eta B - \\zeta B^3 \\\\\nP - \\chi U^2 - \\xi B^2\n\\end{bmatrix},\n$$\n其中所有量均为无量纲，参数 $f$、$\\alpha$、$\\beta$、$\\gamma$、$\\delta$、$\\theta$、$\\eta$、$\\zeta$、$\\chi$ 和 $\\xi$ 均为正常数，但 $\\gamma$ 除外，它可能是正值或负值，具体取决于净线性驱动或阻尼。\n\n求解非线性系统 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$（其中 $\\mathbf{x}=[U,B,P]^T$）的单体（完全耦合）牛顿法需要构建雅可比矩阵\n$$\n\\mathbf{J}(\\mathbf{x}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}(\\mathbf{x}) =\n\\begin{bmatrix}\n\\frac{\\partial F_u}{\\partial U} & \\frac{\\partial F_u}{\\partial B} & \\frac{\\partial F_u}{\\partial P} \\\\\n\\frac{\\partial F_b}{\\partial U} & \\frac{\\partial F_b}{\\partial B} & \\frac{\\partial F_b}{\\partial P} \\\\\n\\frac{\\partial F_p}{\\partial U} & \\frac{\\partial F_p}{\\partial B} & \\frac{\\partial F_p}{\\partial P}\n\\end{bmatrix}.\n$$\n考虑两种构建策略：\n- 精确雅可比矩阵：每个偏导数都根据残差的定义进行解析计算。\n- 有限差分雅可比矩阵：$\\mathbf{J}$ 的每一列 $j$ 通过前向差分公式近似：\n$$\n\\mathbf{J}_{:,j}(\\mathbf{x}) \\approx \\frac{\\mathbf{F}(\\mathbf{x}+h\\,\\mathbf{e}_j) - \\mathbf{F}(\\mathbf{x})}{h},\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个单位向量，$h>0$ 是所选的有限差分步长。\n\n为了在收敛状态 $\\mathbf{x}^\\star$ 下进行稳定性表征，考虑雅可比矩阵的特征值 $\\lambda_i(\\mathbf{J}(\\mathbf{x}^\\star))$。在这个简化模型中，由雅可比矩阵近似误差引起的伪不稳定模式被定义为：在有限差分雅可比矩阵谱中存在、但在精确雅可比矩阵谱中不存在的、具有严格正实部的额外特征值。其数量通过以下计数差异来量化：\n$$\nN_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau),\n$$\n其中\n$$\nN_+^{\\text{FD}}(\\tau) = \\#\\left\\{i \\,\\middle|\\, \\operatorname{Re}(\\lambda_i(\\mathbf{J}_{\\text{FD}}(\\mathbf{x}^\\star))) > \\tau \\right\\},\\quad\nN_+^{\\text{EX}}(\\tau) = \\#\\left\\{i \\,\\middle|\\, \\operatorname{Re}(\\lambda_i(\\mathbf{J}_{\\text{EX}}(\\mathbf{x}^\\star))) > \\tau \\right\\},\n$$\n且 $\\tau$ 是一个小的正常数阈值。\n\n您的任务是为该系统实现一个带有回溯线搜索的单体牛顿求解器，该求解器使用精确和有限差分两种雅可比矩阵构建方法，并从指定的初始猜测值 $\\mathbf{x}_0$ 开始。对于每个测试用例，执行以下步骤：\n1. 使用精确雅可比矩阵求解 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$，得到 $\\mathbf{x}_{\\text{EX}}^\\star$，并记录一个布尔值 $C_{\\text{EX}}$，指示求解器是否在给定容差内收敛。\n2. 使用指定的 $h$ 构建 $\\mathbf{J}_{\\text{EX}}(\\mathbf{x}_{\\text{EX}}^\\star)$ 和 $\\mathbf{J}_{\\text{FD}}(\\mathbf{x}_{\\text{EX}}^\\star)$，然后计算：\n   - 伪特征值的数量 $S = \\max\\left(0, N_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau)\\right)$。\n   - 谱半径的差异 $\\Delta \\rho = \\left|\\max_i \\left|\\lambda_i(\\mathbf{J}_{\\text{FD}}(\\mathbf{x}_{\\text{EX}}^\\star))\\right| - \\max_i \\left|\\lambda_i(\\mathbf{J}_{\\text{EX}}(\\mathbf{x}_{\\text{EX}}^\\star))\\right| \\right|$。\n3. 使用有限差分雅可比矩阵和相同的初始猜测值求解 $\\mathbf{F}(\\mathbf{x})=\\mathbf{0}$，得到 $\\mathbf{x}_{\\text{FD}}^\\star$，并记录一个布尔值 $C_{\\text{FD}}$，指示求解器是否在容差内收敛。\n\n对所有测试用例采用以下具体参数值（无量纲）：\n- $f = 0.05$, $\\alpha = 1.5$, $\\beta = 0.7$, $\\gamma = 0.3$, $\\delta = 1.2$, $\\theta = 0.9$, $\\eta = 0.25$, $\\zeta = 0.5$, $\\chi = 0.8$, $\\xi = 0.6$。\n\n使用以下测试套件，通过改变有限差分步长 $h$ 和初始猜测值 $\\mathbf{x}_0$ 来探究其准确性和鲁棒性：\n- 测试用例 A（理想路径，精确的有限差分雅可比矩阵）：\n  - $h = 10^{-8}$。\n  - $\\mathbf{x}_0 = [0.2, 0.05, 0.01]$。\n- 测试用例 B（中等有限差分步长，可能存在轻微性能下降）：\n  - $h = 10^{-3}$。\n  - $\\mathbf{x}_0 = [0.5, 0.3, 0.1]$。\n- 测试用例 C（大有限差分步长，可能存在显著的近似误差）：\n  - $h = 10^{-1}$。\n  - $\\mathbf{x}_0 = [0.7, 0.5, 0.2]$。\n\n所有量均为无量纲；无需物理单位。使用收敛容差 $\\|\\mathbf{F}(\\mathbf{x})\\|_2 < 10^{-12}$，最大牛顿迭代次数为 $50$ 次，并采用回溯线搜索，当残差范数未减小时，最多可将步长缩减为原来的 $1/2$ 共 $10$ 次。\n\n将不稳定性阈值设为 $\\tau = 10^{-6}$。\n\n您的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身是一个包含四个值的列表，顺序为 $[C_{\\text{EX}}, C_{\\text{FD}}, S, \\Delta \\rho]$。例如，输出格式必须为\n$$\n[\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}],\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}],\\ [\\text{bool},\\text{bool},\\text{int},\\text{float}]\\ ].\n$$",
            "solution": "该问题要求实现并比较一个用于求解非线性方程组的单体牛顿求解器，其中使用两种不同的雅可比矩阵构建策略：精确解析雅可比矩阵和有限差分近似。\n\n### 1. 数学公式\n\n待求解的系统是一组由三个耦合的非线性代数方程组成的方程组，表示为残差向量 $\\mathbf{F}(\\mathbf{x}) = \\mathbf{0}$，其中 $\\mathbf{x} = [U, B, P]^T$ 是无量纲振幅的状态向量。残差向量由下式给出：\n$$\n\\mathbf{F}(U,B,P) =\n\\begin{bmatrix}\nF_u(U,B,P) \\\\\nF_b(U,B,P) \\\\\nF_p(U,B,P)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf - \\alpha P + \\beta B^2 - \\gamma U - \\delta U^3 \\\\\n\\theta U B - \\eta B - \\zeta B^3 \\\\\nP - \\chi U^2 - \\xi B^2\n\\end{bmatrix} = \\mathbf{0}\n$$\n常数 $f, \\alpha, \\beta, \\gamma, \\delta, \\theta, \\eta, \\zeta, \\chi, \\xi$ 均为给定的固定值。\n\n### 2. 单体牛顿-拉夫逊方法\n\n牛顿-拉夫逊方法是一种用于寻找非线性方程组根的迭代算法。从初始猜测值 $\\mathbf{x}_0$ 开始，它生成一个近似序列 $\\mathbf{x}_k$，理想情况下该序列会收敛到解 $\\mathbf{x}^\\star$。该方法的核心是更新规则，它源于 $\\mathbf{F}$ 在当前迭代点 $\\mathbf{x}_k$ 附近的一阶泰勒展开：\n$$\n\\mathbf{F}(\\mathbf{x}_{k+1}) \\approx \\mathbf{F}(\\mathbf{x}_k) + \\mathbf{J}(\\mathbf{x}_k)(\\mathbf{x}_{k+1} - \\mathbf{x}_k)\n$$\n令 $\\mathbf{F}(\\mathbf{x}_{k+1}) = \\mathbf{0}$ 并将更新步长定义为 $\\Delta\\mathbf{x}_k = \\mathbf{x}_{k+1} - \\mathbf{x}_k$，我们得到关于更新量的线性系统：\n$$\n\\mathbf{J}(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -\\mathbf{F}(\\mathbf{x}_k)\n$$\n此处，$\\mathbf{J}(\\mathbf{x}_k)$ 是 $\\mathbf{F}$ 在 $\\mathbf{x}_k$ 处求值的雅可比矩阵。求解出 $\\Delta\\mathbf{x}_k$ 后，下一个迭代点计算为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta\\mathbf{x}_k$。\n\n### 3. 雅可比矩阵构建策略\n\n雅可比矩阵 $\\mathbf{J}$ 包含残差分量相对于状态变量的偏导数。问题指定了两种构建方法。\n\n**a) 精确解析雅可比矩阵 ($\\mathbf{J}_{\\text{EX}}$)**\n\n该方法涉及将 $\\mathbf{F}$ 的每个分量对 $\\mathbf{x} = [U, B, P]^T$ 中的每个变量进行解析微分。得到的导数如下：\n- $\\frac{\\partial F_u}{\\partial U} = -\\gamma - 3\\delta U^2$\n- $\\frac{\\partial F_u}{\\partial B} = 2\\beta B$\n- $\\frac{\\partial F_u}{\\partial P} = -\\alpha$\n\n- $\\frac{\\partial F_b}{\\partial U} = \\theta B$\n- $\\frac{\\partial F_b}{\\partial B} = \\theta U - \\eta - 3\\zeta B^2$\n- $\\frac{\\partial F_b}{\\partial P} = 0$\n\n- $\\frac{\\partial F_p}{\\partial U} = -2\\chi U$\n- $\\frac{\\partial F_p}{\\partial B} = -2\\xi B$\n- $\\frac{\\partial F_p}{\\partial P} = 1$\n\n将这些导数组合成矩阵形式，即可得到精确雅可比矩阵：\n$$\n\\mathbf{J}_{\\text{EX}}(U,B,P) =\n\\begin{bmatrix}\n-\\gamma - 3\\delta U^2 & 2\\beta B & -\\alpha \\\\\n\\theta B & \\theta U - \\eta - 3\\zeta B^2 & 0 \\\\\n-2\\chi U & -2\\xi B & 1\n\\end{bmatrix}\n$$\n\n**b) 有限差分雅可比矩阵 ($\\mathbf{J}_{\\text{FD}}$)**\n\n该方法以数值方式近似偏导数。问题指定了前向差分格式。雅可比矩阵的第 $j$ 列通过扰动状态向量 $\\mathbf{x}$ 的第 $j$ 个分量来近似：\n$$\n\\mathbf{J}_{:,j}(\\mathbf{x}) \\approx \\frac{\\mathbf{F}(\\mathbf{x}+h\\,\\mathbf{e}_j) - \\mathbf{F}(\\mathbf{x})}{h}\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量（例如，$\\mathbf{e}_1 = [1, 0, 0]^T$），$h$ 是一个小的正步长。这种方法避免了手动微分的需要，但引入了与 $h$ 成比例的截断误差。\n\n### 4. 全局化：回溯线搜索\n\n标准牛顿步（$\\Delta\\mathbf{x}_k$）并不能保证残差范数 $\\|\\mathbf{F}(\\mathbf{x})\\|_2$ 的减小，尤其是在远离解的情况下。为了提高鲁棒性，采用了回溯线搜索。更新过程被修改为 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k$，其中 $\\alpha_k \\in (0, 1]$ 是一个步长。我们从 $\\alpha_k=1$（完整牛顿步）开始，并检查是否满足 $\\|\\mathbf{F}(\\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k)\\|_2 < \\|\\mathbf{F}(\\mathbf{x}_k)\\|_2$。如果不满足该条件，则逐步减小 $\\alpha_k$（例如，每次乘以因子 $1/2$），直到残差范数减小或达到最大缩减次数。如果找不到合适的 $\\alpha_k$，求解器将终止，表示不收敛。\n\n### 5. 稳定性与谱分析\n\n在收敛解 $\\mathbf{x}^\\star$ 处，此稳态的稳定性由雅可比矩阵 $\\mathbf{J}(\\mathbf{x}^\\star)$ 的特征值 $\\lambda_i$ 决定。如果任何特征值具有严格为正的实部（$\\operatorname{Re}(\\lambda_i) > 0$），则系统不稳定。任务要求量化由有限差分近似引入的伪不稳定模式。这通过计算 $S = \\max(0, N_+^{\\text{FD}}(\\tau) - N_+^{\\text{EX}}(\\tau))$ 来完成，其中 $N_+$是实部大于小阈值 $\\tau = 10^{-6}$ 的特征值数量。此外，还计算了两个雅可比矩阵谱半径的差异 $\\Delta \\rho$，作为整体谱失真的度量。谱半径 $\\rho(\\mathbf{J})$ 定义为 $\\max_i |\\lambda_i(\\mathbf{J})|$。\n\n### 6. 实现策略\n\n解决方案使用 Python 的 `numpy` 库实现。\n1.  一个 `residual` 函数，用于计算给定状态向量 $\\mathbf{x}$ 的残差 $\\mathbf{F}(\\mathbf{x})$。\n2.  `exact_jacobian` 和 `fd_jacobian` 函数，用于实现上述两种构建策略。\n3.  创建一个通用的 `newton_solver` 函数。它接收一个初始猜测值 $\\mathbf{x}_0$ 和一个雅可比矩阵构建函数的句柄。它迭代求解线性系统并应用回溯线搜索，直到残差的 L2 范数低于 $10^{-12}$ 的容差或达到 50 次的最大迭代次数。\n4.  对于每个测试用例，首先使用精确雅可比矩阵调用 `newton_solver`。得到的解 $\\mathbf{x}_{\\text{EX}}^\\star$ 用于计算 $\\mathbf{J}_{\\text{EX}}$ 和 $\\mathbf{J}_{\\text{FD}}$。\n5.  使用 `numpy.linalg.eigvals` 来寻找两个矩阵的特征值。然后用这些特征值计算伪模式的数量 $S$ 和谱半径差异 $\\Delta\\rho$。\n6.  第二次调用 `newton_solver`，使用有限差分雅可比矩阵和相同的初始猜测值 $\\mathbf{x}_0$，以确定其收敛行为。\n7.  收集每个测试用例的结果（$C_{\\text{EX}}$、$C_{\\text{FD}}$、$S$、$\\Delta \\rho$）并按指定格式打印。",
            "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Solves the MHD amplitude model using a monolithic Newton method\n    with both exact and finite-difference Jacobians and analyzes the results.\n    \"\"\"\n    \n    # ------------------ Parameters and Configuration ------------------\n    # Dimensionless physical parameters\n    PARAMS = {\n        'f': 0.05, 'alpha': 1.5, 'beta': 0.7, 'gamma': 0.3, 'delta': 1.2,\n        'theta': 0.9, 'eta': 0.25, 'zeta': 0.5, 'chi': 0.8, 'xi': 0.6\n    }\n    \n    # Newton solver settings\n    TOL = 1e-12\n    MAX_ITER = 50\n    MAX_LS_STEPS = 10\n    \n    # Stability analysis threshold\n    TAU = 1e-6\n    \n    # Test cases {h_value, initial_guess}\n    test_cases = [\n        {'h': 1e-8, 'x0': [0.2, 0.05, 0.01]},  # Test case A\n        {'h': 1e-3, 'x0': [0.5, 0.3, 0.1]},    # Test case B\n        {'h': 1e-1, 'x0': [0.7, 0.5, 0.2]}     # Test case C\n    ]\n    \n    # ------------------ Core Mathematical Functions ------------------\n    def residual(x, params):\n        \"\"\"Computes the residual vector F(x).\"\"\"\n        U, B, P = x\n        p = params\n        F_u = p['f'] - p['alpha']*P + p['beta']*B**2 - p['gamma']*U - p['delta']*U**3\n        F_b = p['theta']*U*B - p['eta']*B - p['zeta']*B**3\n        F_p = P - p['chi']*U**2 - p['xi']*B**2\n        return np.array([F_u, F_b, F_p])\n\n    def exact_jacobian(x, params):\n        \"\"\"Computes the exact analytical Jacobian matrix J_EX(x).\"\"\"\n        U, B, P = x\n        p = params\n        J = np.zeros((3, 3))\n        # dF_u/dx\n        J[0, 0] = -p['gamma'] - 3*p['delta']*U**2\n        J[0, 1] = 2*p['beta']*B\n        J[0, 2] = -p['alpha']\n        # dF_b/dx\n        J[1, 0] = p['theta']*B\n        J[1, 1] = p['theta']*U - p['eta'] - 3*p['zeta']*B**2\n        J[1, 2] = 0\n        # dF_p/dx\n        J[2, 0] = -2*p['chi']*U\n        J[2, 1] = -2*p['xi']*B\n        J[2, 2] = 1\n        return J\n\n    def fd_jacobian(x, h, params):\n        \"\"\"Computes the finite-difference Jacobian matrix J_FD(x).\"\"\"\n        n = len(x)\n        J = np.zeros((n, n))\n        F0 = residual(x, params)\n        for j in range(n):\n            x_plus_h = x.copy()\n            x_plus_h[j] += h\n            F_plus_h = residual(x_plus_h, params)\n            J[:, j] = (F_plus_h - F0) / h\n        return J\n\n    # ------------------ Newton Solver Implementation ------------------\n    def newton_solver(x0, jacobian_func, params, tol, max_iter, max_ls_steps):\n        \"\"\"Monolithic Newton solver with backtracking line search.\"\"\"\n        x_k = np.array(x0, dtype=float)\n\n        for _ in range(max_iter):\n            F_k = residual(x_k, params)\n            norm_Fk = np.linalg.norm(F_k)\n\n            if norm_Fk  tol:\n                return x_k, True\n\n            try:\n                J_k = jacobian_func(x_k)\n                dx = np.linalg.solve(J_k, -F_k)\n            except np.linalg.LinAlgError:\n                return x_k, False  # Singular matrix\n\n            # Backtracking line search\n            alpha = 1.0\n            for _ in range(max_ls_steps):\n                x_new = x_k + alpha * dx\n                norm_F_new = np.linalg.norm(residual(x_new, params))\n                if norm_F_new  norm_Fk:\n                    x_k = x_new\n                    break\n                alpha /= 2.0\n            else:\n                # Line search failed to find a decreasing step\n                return x_k, False\n        \n        # Max iterations reached, check final residual\n        if np.linalg.norm(residual(x_k, params))  tol:\n            return x_k, True\n        return x_k, False\n\n    # ------------------ Main Execution Logic ------------------\n    all_results = []\n    for case in test_cases:\n        h, x0_list = case['h'], case['x0']\n        x0 = np.array(x0_list, dtype=float)\n\n        # 1. Solve with Exact Jacobian\n        jac_ex_func = lambda x: exact_jacobian(x, PARAMS)\n        x_ex_star, C_ex = newton_solver(x0, jac_ex_func, PARAMS, TOL, MAX_ITER, MAX_LS_STEPS)\n        \n        # 2. Assemble Jacobians at the exact solution and analyze\n        J_ex_at_sol = exact_jacobian(x_ex_star, PARAMS)\n        J_fd_at_sol = fd_jacobian(x_ex_star, h, PARAMS)\n        \n        eigs_ex = np.linalg.eigvals(J_ex_at_sol)\n        eigs_fd = np.linalg.eigvals(J_fd_at_sol)\n        \n        # Count spurious unstable modes\n        N_plus_ex = np.sum(np.real(eigs_ex) > TAU)\n        N_plus_fd = np.sum(np.real(eigs_fd) > TAU)\n        S = max(0, N_plus_fd - N_plus_ex)\n        \n        # Calculate difference in spectral radii\n        rho_ex = np.max(np.abs(eigs_ex))\n        rho_fd = np.max(np.abs(eigs_fd))\n        delta_rho = np.abs(rho_fd - rho_ex)\n        \n        # 3. Solve with Finite-Difference Jacobian\n        jac_fd_func = lambda x: fd_jacobian(x, h, PARAMS)\n        x_fd_star, C_fd = newton_solver(x0, jac_fd_func, PARAMS, TOL, MAX_ITER, MAX_LS_STEPS)\n        \n        all_results.append([C_ex, C_fd, int(S), delta_rho])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\"],\", \"], \").replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```"
        }
    ]
}