{
    "hands_on_practices": [
        {
            "introduction": "雅可比-向量积是任何JFNK方法的核心算子。在用它解决复杂问题之前，我们必须确保其实现的正确性。本实践将介绍泰勒测试，这是一种验证方向导数计算准确性的基本技术，并指导您将其应用于一个耦合热弹性模型 ()。",
            "id": "3512009",
            "problem": "给定一个适用于多物理场模拟的耦合残差算子，要求使用泰勒检验来验证无矩阵雅可比-向量积的实现。其背景是对区间 $[0,1]$ 上的一个一维耦合热弹性模型应用雅可比无关牛顿-克雷洛夫 (JFNK) 方法，该模型具有从一个构造解导出的狄利克雷边界条件。未知场为在 $n$ 个内点 $x_i = i h$（其中 $h = 1/(n+1)$ 且 $i = 1,2,\\dots,n$）上采样的温度 $T \\in \\mathbb{R}^n$ 和位移 $y \\in \\mathbb{R}^n$。对于 $u = [T;y] \\in \\mathbb{R}^{2n}$ 的残差算子 $F(u)$ 按分量为内部节点定义如下\n$$\nF_T(T,y)_i = -k \\, L(T)_i + \\beta \\, T_i \\, y_i - s_i,\n$$\n$$\nF_y(T,y)_i = -E \\, L(y)_i + \\gamma \\, T_i^2 - f_i,\n$$\n其中 $k > 0$、$E > 0$、$\\beta > 0$ 和 $\\gamma > 0$ 是材料系数，$s \\in \\mathbb{R}^n$ 和 $f \\in \\mathbb{R}^n$ 是源向量，$L(\\cdot)$ 是作用于具有狄利克雷边界的内部节点的标准二阶中心有限差分拉普拉斯算子：\n$$\nL(w)_i = \\frac{w_{i-1} - 2 w_i + w_{i+1}}{h^2}, \\quad i = 1,\\dots,n,\n$$\n其中 $w_0$ 和 $w_{n+1}$ 被设为狄利克雷边界值 $w(0)$ 和 $w(1)$。构造的精确场为\n$$\nT_{\\mathrm{ex}}(x) = e^x + \\sin(\\pi x), \\quad y_{\\mathrm{ex}}(x) = \\cos(\\pi x) + x,\n$$\n其狄利克雷边界值为 $T(0) = T_{\\mathrm{ex}}(0)$、$T(1) = T_{\\mathrm{ex}}(1)$、$y(0) = y_{\\mathrm{ex}}(0)$ 和 $y(1) = y_{\\mathrm{ex}}(1)$。构造源向量以使构造解成为一个离散解，即：\n$$\ns_i = -k \\, L\\!\\left(T_{\\mathrm{ex}}\\right)_i + \\beta \\, T_{\\mathrm{ex}}(x_i) \\, y_{\\mathrm{ex}}(x_i), \\quad\nf_i = -E \\, L\\!\\left(y_{\\mathrm{ex}}\\right)_i + \\gamma \\, \\big(T_{\\mathrm{ex}}(x_i)\\big)^2.\n$$\n将状态 $u = [T;y]$ 和方向 $v = [v_T; v_y] \\in \\mathbb{R}^{2n}$ 处的雅可比-向量积 $J(u)v$ 定义为 $F$ 在 $u$ 点沿 $v$ 方向的方向导数。对于上述算子，解析雅可比-向量积为\n$$\n\\left(J(u)v\\right)_T{}_i = -k \\, L(v_T)_i + \\beta \\left( v_{T,i} \\, y_i + T_i \\, v_{y,i} \\right),\n$$\n$$\n\\left(J(u)v\\right)_y{}_i = -E \\, L(v_y)_i + \\gamma \\left( 2 T_i \\, v_{T,i} \\right).\n$$\n另外，一种使用小探测参数 $\\xi > 0$ 的无矩阵有限差分雅可比-向量积实现由下式给出\n$$\nJ_\\xi(u)v = \\frac{F(u + \\xi v) - F(u)}{\\xi}.\n$$\n需要验证的泰勒检验性质是，对于足够小的 $\\epsilon > 0$，\n$$\nR(\\epsilon; u, v, J) = \\frac{ \\left\\| F(u + \\epsilon v) - F(u) - \\epsilon \\, J(u)v \\right\\|_2 }{\\epsilon} \\quad \\text{与 } \\epsilon \\text{ 呈线性关系, 即 } R(\\epsilon) = \\mathcal{O}(\\epsilon),\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。为定量评估线性关系，对 $\\log_{10} R(\\epsilon)$ 与 $\\log_{10} \\epsilon$ 进行线性拟合，并使用其斜率作为观测阶数。\n\n您的任务是：\n- 使用指定的中心差分和狄利克雷边界实现残差 $F(u)$。\n- 实现两个雅可比-向量积：上面给出的解析 $J(u)v$ 和带有可配置 $\\xi$ 的无矩阵有限差分 $J_\\xi(u)v$。\n- 对于每个测试用例，生成一个随机扰动状态 $u = u_{\\mathrm{ex}} + \\delta u$ 和一个随机方向 $v$，两者都应是可复现的，并在一组给定的 $\\epsilon$ 值上评估 $\\log_{10} R(\\epsilon)$ 对 $\\log_{10} \\epsilon$ 的斜率。\n- 对于每个测试用例，返回一个布尔值，指示观测到的斜率是否在围绕 $1$ 的一个容差区间内。\n\n使用以下参数值和测试套件：\n- 通用系数：$k = 2.3$，$E = 5.0$，$\\beta = 1.1$，$\\gamma = 0.7$。\n- 从 $T_{\\mathrm{ex}}(x)$ 和 $y_{\\mathrm{ex}}(x)$ 在 $x = 0$ 和 $x = 1$ 处获得的狄利克雷边界。\n- 随机扰动：$u = u_{\\mathrm{ex}} + 0.1 \\, r$，其中 $r$ 是 $\\mathbb{R}^{2n}$ 中的一个固定种子随机向量，$v$ 是 $\\mathbb{R}^{2n}$ 中的一个固定种子随机单位向量。\n- Epsilon 集合：$\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}, 10^{-7}, 10^{-8} \\}$。\n\n测试用例：\n1. 正常路径：$n = 50$，解析 $J(u)v$，容差 $\\delta = 0.05$。\n2. 无矩阵（正确）：$n = 50$，$J_\\xi(u)v$ 且 $\\xi = 10^{-10}$，容差 $\\delta = 0.1$。\n3. 无矩阵（退化）：$n = 50$，$J_\\xi(u)v$ 且 $\\xi = 10^{-2}$，容差 $\\delta = 0.1$。\n4. 小系统覆盖：$n = 3$，解析 $J(u)v$，容差 $\\delta = 0.1$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，结果为逗号分隔的列表并用方括号括起。例如，如果所有测试都通过，输出应精确为 \"[True,True,True,True]\"。\n- 所有输出均为布尔值；不涉及物理单位。",
            "solution": "所提出的问题是一个在数值验证方面定义明确的练习，这是计算科学与工程中的一项关键实践。其目标是为一个耦合多物理场系统验证雅可比-向量积的实现，这是雅可比无关牛顿-克雷洛夫 (JFNK) 方法的核心组成部分。该验证框架采用构造解方法 (MMS) 来建立一个已知的精确解，并使用泰勒检验来评估雅可比实现的正确性。该问题具有科学依据、数学上一致且算法上完整。因此，它被认为是有效的，我们可以着手提供完整解答。\n\n解答方法分几步进行：\n1.  连续模型的离散化及代数残差算子 $F(u)$ 的构建。\n2.  通过 MMS 实现源项 $s$ 和 $f$，以确保构造的场是离散系统的精确解。\n3.  实现两种不同的雅可比-向量积程序：一种基于解析推导，$J(u)v$；另一种基于有限差分近似，$J_\\xi(u)v$。\n4.  执行泰勒检验，以验证所实现的雅可比-向量积的行为是否如泰勒定理所预测。\n\n让我们详细阐述每一步。\n\n**1. 离散化与残差算子 $F(u)$**\n\n该问题涉及定义域 $x \\in [0,1]$ 上的一个一维耦合热弹性模型。系统状态由温度场 $T(x)$ 和位移场 $y(x)$ 描述。为进行数值求解，这些连续场在 $n$ 个内部点 $x_i = i h$ (其中 $i=1,\\dots,n$) 进行离散化，其中 $h = 1/(n+1)$ 是均匀网格间距。离散状态由一个向量 $u \\in \\mathbb{R}^{2n}$ 表示，它是内部节点上温度和位移向量的拼接：$u = [T_1, \\dots, T_n, y_1, \\dots, y_n]^T$。\n\n控制方程被表述为一个非线性代数方程组 $F(u) = 0$，其中 $F: \\mathbb{R}^{2n} \\to \\mathbb{R}^{2n}$ 是残差算子。该算子对每个内部节点 $i \\in \\{1,\\dots,n\\}$ 按分量定义：\n$$\nF_T(T,y)_i = -k \\, L(T)_i + \\beta \\, T_i \\, y_i - s_i\n$$\n$$\nF_y(T,y)_i = -E \\, L(y)_i + \\gamma \\, T_i^2 - f_i\n$$\n算子 $L(\\cdot)$ 是具有狄利克雷边界条件的一维离散拉普拉斯算子。对于一个具有边界值 $w_0$ 和 $w_{n+1}$ 的离散场 $w \\in \\mathbb{R}^n$，其在节点 $i$ 上的作用由二阶中心差分公式给出：\n$$\nL(w)_i = \\frac{w_{i-1} - 2 w_i + w_{i+1}}{h^2}\n$$\n在计算第一个 ($i=1$) 和最后一个 ($i=n$) 内部节点的拉普拉斯算子时，此算子的实现必须正确地包含固定的边界值 $w_0$ 和 $w_{n+1}$。\n\n**2. 构造解方法 (MMS)**\n\n为了验证我们数值实现的正确性，我们需要一个已知精确解的问题。MMS 提供了一种系统化的方法来实现这一点。我们假设或“构造”一个光滑函数作为精确解，然后将其代入离散的控制方程，以推导出必要的源项 ($s_i$ 和 $f_i$)，从而使我们的构造解成为离散系统的精确解。\n\n规定的构造解是：\n$$\nT_{\\mathrm{ex}}(x) = e^x + \\sin(\\pi x)\n$$\n$$\ny_{\\mathrm{ex}}(x) = \\cos(\\pi x) + x\n$$\n由此，我们得到狄利克雷边界值：$T(0)=1$，$T(1)=e$，$y(0)=1$ 和 $y(1)=0$。然后通过用精确解计算残差方程来计算源向量 $s$ 和 $f$，以确保 $F(u_{\\mathrm{ex}}) = 0$：\n$$\ns_i = -k \\, L(T_{\\mathrm{ex}})_i + \\beta \\, T_{\\mathrm{ex}}(x_i) \\, y_{\\mathrm{ex}}(x_i)\n$$\n$$\nf_i = -E \\, L(y_{\\mathrm{ex}})_i + \\gamma \\, \\big(T_{\\mathrm{ex}}(x_i)\\big)^2\n$$\n其中 $T_{\\mathrm{ex}}$ 和 $y_{\\mathrm{ex}}$ 在离散网格点 $x_i$ 处求值。\n\n**3. 雅可比-向量积的实现**\n\n该数值任务的核心是实现并验证雅可比矩阵 $J(u) = \\frac{\\partial F}{\\partial u}(u)$ 作用于向量 $v$ 的过程，而无需显式地构建该矩阵。\n\n*   **解析雅可比-向量积 $J(u)v$**：这是通过取 $F(u)$ 在方向 $v$ 上的 Gâteaux 导数得到的。对于状态 $u=[T;y]$ 和方向 $v=[v_T;v_y]$，积 $J(u)v$ 的分量由下式给出：\n    $$\n    \\left(J(u)v\\right)_T{}_i = -k \\, L(v_T)_i + \\beta \\left( v_{T,i} \\, y_i + T_i \\, v_{y,i} \\right)\n    $$\n    $$\n    \\left(J(u)v\\right)_y{}_i = -E \\, L(v_y)_i + \\gamma \\left( 2 T_i \\, v_{T,i} \\right)\n    $$\n    由于 $T$ 和 $y$ 的狄利克雷边界条件是固定的，对状态的任何扰动 $v$ 都必须保持这些边界。这意味着扰动向量的分量 $v_T$ 和 $v_y$ 的边界值必须为零。拉普拉斯算子 $L(v_T)$ 和 $L(v_y)$ 必须在零狄利克雷边界条件下计算。\n\n*   **有限差分雅可比-向量积 $J_\\xi(u)v$**：这提供了一个使用向前有限差分对雅可比-向量积的无矩阵近似：\n    $$\n    J_\\xi(u)v = \\frac{F(u + \\xi v) - F(u)}{\\xi}\n    $$\n    该公式近似了定义雅可比作用的方向导数。此近似的精度为 $\\mathcal{O}(\\xi)$ 阶。\n\n**4. 泰勒检验**\n\n泰勒检验是验证雅可比实现正确性的基本程序。它基于残差算子 $F$ 的一阶泰勒展开：\n$$\nF(u + \\epsilon v) = F(u) + \\epsilon J(u)v + \\mathcal{O}(\\epsilon^2)\n$$\n整理后可得截断误差的表达式：\n$$\nF(u + \\epsilon v) - F(u) - \\epsilon J(u)v = \\mathcal{O}(\\epsilon^2)\n$$\n问题定义了一个归一化残差 $R(\\epsilon)$，我们需要检验其缩放行为：\n$$\nR(\\epsilon) = \\frac{ \\left\\| F(u + \\epsilon v) - F(u) - \\epsilon \\, J(u)v \\right\\|_2 }{\\epsilon}\n$$\n鉴于分子是 $\\mathcal{O}(\\epsilon^2)$ 阶，我们期望 $R(\\epsilon)$ 是 $\\mathcal{O}(\\epsilon)$ 阶，即 $R(\\epsilon) = C \\epsilon^p$，收敛阶数 $p=1$。为验证这一点，我们可以绘制 $\\log_{10} R(\\epsilon)$ 对 $\\log_{10} \\epsilon$ 的图像。该关系变为 $\\log_{10} R(\\epsilon) = p \\log_{10} \\epsilon + \\log_{10} C$，这是线性的。通过线性回归确定的这条线的斜率应约等于 $1$。\n\n*   **对于解析雅可比 $J(u)v$**：误差项确实是 $\\mathcal{O}(\\epsilon^2)$，因此我们期望对数-对数图的斜率非常接近 $1$，仅受浮点精度的限制。测试用例1和4使用此雅可比，应该会通过。\n\n*   **对于有限差分雅可比 $J_\\xi(u)v$**：被测试的项是 $F(u + \\epsilon v) - F(u) - \\epsilon J_\\xi(u)v$。$J_\\xi(u)v$ 相对于真实雅可比 $J(u)v$ 的误差是 $\\mathcal{O}(\\xi)$。总误差由 $\\epsilon$ 和 $\\xi$ 共同主导：\n    $$\n    \\text{Error} = \\left( \\frac{\\epsilon^2}{2} - \\frac{\\epsilon\\xi}{2} \\right) H(u)(v,v) + \\dots\n    $$\n    其中 $H(u)$ 是海森矩阵。因此，误差的范数是 $\\mathcal{O}(\\epsilon|\\epsilon - \\xi|)$，而 $R(\\epsilon)$ 的缩放行为是 $\\mathcal{O}(|\\epsilon - \\xi|)$。\n    -   在测试用例2中，$\\xi=10^{-10}$ 远小于测试集中的任何 $\\epsilon$。因此，$|\\epsilon-\\xi| \\approx \\epsilon$，并且 $R(\\epsilon)$ 的行为是 $\\mathcal{O}(\\epsilon)$。斜率应接近 $1$。\n    -   在测试用例3中，$\\xi=10^{-2}$。对于 $\\epsilon > \\xi$，$R(\\epsilon)$ 的行为是 $\\mathcal{O}(\\epsilon)$。对于 $\\epsilon < \\xi$，$R(\\epsilon)$ 的行为是一个常数 $\\mathcal{O}(\\xi)$，导致斜率为 $0$。在整个 $\\epsilon$ 值范围内的线性回归将产生一个远小于 $1$ 的斜率，导致此测试失败，这符合对“退化”实现的预期。\n\n实现将通过为每个数学组件定义 Python 函数，使用可复现的随机向量设置每个测试用例，执行泰勒检验，并将所得斜率与 $1$ 在给定容差内进行比较来完成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating Jacobian-vector product implementations\n    using a Taylor test for a coupled 1D thermoelastic model.\n    \"\"\"\n\n    # --- Problem Constants and Definitions ---\n    K_COEFF = 2.3\n    E_COEFF = 5.0\n    BETA_COEFF = 1.1\n    GAMMA_COEFF = 0.7\n    EPSILONS = np.logspace(-1, -8, 8)\n\n    def t_ex(x):\n        return np.exp(x) + np.sin(np.pi * x)\n\n    def y_ex(x):\n        return np.cos(np.pi * x) + x\n\n    def laplacian(w, w0, w_np1, h):\n        w_padded = np.concatenate(([w0], w, [w_np1]))\n        lw = (w_padded[:-2] - 2 * w_padded[1:-1] + w_padded[2:]) / h**2\n        return lw\n\n    def residual(u, n, s, f, t0, t_np1, y0, y_np1, h):\n        T = u[:n]\n        y = u[n:]\n        lt = laplacian(T, t0, t_np1, h)\n        ly = laplacian(y, y0, y_np1, h)\n        f_t = -K_COEFF * lt + BETA_COEFF * T * y - s\n        f_y = -E_COEFF * ly + GAMMA_COEFF * T**2 - f\n        return np.concatenate((f_t, f_y))\n\n    def jvp_analytic(u, v, n, h):\n        T = u[:n]\n        y = u[n:]\n        v_t = v[:n]\n        v_y = v[n:]\n        # Perturbations have zero Dirichlet BCs\n        l_vt = laplacian(v_t, 0.0, 0.0, h)\n        l_vy = laplacian(v_y, 0.0, 0.0, h)\n        jv_t = -K_COEFF * l_vt + BETA_COEFF * (v_t * y + T * v_y)\n        jv_y = -E_COEFF * l_vy + GAMMA_COEFF * (2 * T * v_t)\n        return np.concatenate((jv_t, jv_y))\n\n    def jvp_fd(u, v, xi, F_func, F_args):\n        f_u = F_func(u, *F_args)\n        f_u_plus_xiv = F_func(u + xi * v, *F_args)\n        return (f_u_plus_xiv - f_u) / xi\n\n    test_cases = [\n        # n, jac_type, jac_param (xi), tolerance\n        (50, 'analytic', None, 0.05),\n        (50, 'fd', 1e-10, 0.1),\n        (50, 'fd', 1e-2, 0.1),\n        (3, 'analytic', None, 0.1)\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed=12345)\n\n    for n, jac_type, jac_param, tolerance in test_cases:\n        # --- System Setup ---\n        h = 1.0 / (n + 1)\n        x_nodes = np.linspace(h, 1.0 - h, n)\n\n        t0, t_np1 = t_ex(0.0), t_ex(1.0)\n        y0, y_np1 = y_ex(0.0), y_ex(1.0)\n\n        # --- Manufactured Solution and Sources ---\n        t_ex_nodes = t_ex(x_nodes)\n        y_ex_nodes = y_ex(x_nodes)\n        u_ex = np.concatenate((t_ex_nodes, y_ex_nodes))\n\n        lt_ex = laplacian(t_ex_nodes, t0, t_np1, h)\n        ly_ex = laplacian(y_ex_nodes, y0, y_np1, h)\n        s_source = -K_COEFF * lt_ex + BETA_COEFF * t_ex_nodes * y_ex_nodes\n        f_source = -E_COEFF * ly_ex + GAMMA_COEFF * t_ex_nodes**2\n\n        # --- Perturbation and Direction Vectors ---\n        r_perturb = rng.random(2 * n)\n        u = u_ex + 0.1 * r_perturb\n\n        v_raw = rng.random(2 * n)\n        v = v_raw / np.linalg.norm(v_raw)\n\n        # --- Select Jv Implementation ---\n        F_args = (n, s_source, f_source, t0, t_np1, y0, y_np1, h)\n        if jac_type == 'analytic':\n            jvp_func = lambda u_state, v_dir: jvp_analytic(u_state, v_dir, n, h)\n        else: # jac_type == 'fd'\n            xi = jac_param\n            jvp_func = lambda u_state, v_dir: jvp_fd(u_state, v_dir, xi, residual, F_args)\n\n        # --- Taylor Test ---\n        r_values = []\n        eps_values = []\n        \n        f_u = residual(u, *F_args)\n        jvp = jvp_func(u, v)\n\n        for eps in EPSILONS:\n            # For FD Jv, if eps is too close to xi, skip to avoid numerical instability\n            if jac_type == 'fd' and np.isclose(eps, jac_param):\n                continue\n                \n            f_u_plus_epsv = residual(u + eps * v, *F_args)\n            taylor_resid_vec = f_u_plus_epsv - f_u - eps * jvp\n            r_eps = np.linalg.norm(taylor_resid_vec) / eps\n            \n            if r_eps > 0:\n                r_values.append(r_eps)\n                eps_values.append(eps)\n\n        # --- Slope Calculation and Verification ---\n        if len(r_values)  2:\n            # Not enough data points to perform linear regression\n            slope = -np.inf\n        else:\n            log_eps = np.log10(eps_values)\n            log_r = np.log10(r_values)\n            lin_reg_result = linregress(log_eps, log_r)\n            slope = lin_reg_result.slope\n\n        results.append(abs(slope - 1.0)  tolerance)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "当我们能够验证雅可比-向量积的正确性后，下一步便是优化其计算精度。有限差分微扰参数 $\\epsilon$ 的选择至关重要，它涉及到截断误差与舍入误差之间的权衡。本实践 () 提供了一种基于一阶理论的系统方法来估计最优的 $\\epsilon$ 值，从而摆脱盲目猜测，确保求解器的鲁棒性和效率。",
            "id": "3511972",
            "problem": "您的任务是设计并实施一项计算研究，以在用于耦合多物理场残差映射的无雅可比 Newton–Krylov (JFNK) 方法中，选择用于近似雅可比-向量积的有限差分扰动 $\\,\\epsilon\\,$。该研究必须基于第一性原理，并且必须平衡截断误差和浮点舍入误差。目标是雅可比-向量积的前向差分近似，\n$$\nJ(u)\\,v \\approx \\frac{F(u+\\epsilon\\,v)-F(u)}{\\epsilon} ,\n$$\n其中 $\\,F:\\mathbb{R}^n\\to\\mathbb{R}^n\\,$ 是一个光滑的残差算子。\n\n从以下基本依据出发：\n- Newton 方法通过使用由雅可比矩阵 $\\,J(u)\\,$ 定义的线性化来迭代更新 $\\,u\\,$，从而求解 $\\,F(u)=0\\,$。\n- 无雅可比的 Newton–Krylov (JFNK) 方法用对 $\\,F\\,$ 的求值替代了 $\\,J(u)\\,$ 的显式构造，并使用 $\\,J(u)\\,v\\,$ 的无矩阵近似。\n- 前向差分近似和一个 Taylor 展开表明，主阶截断误差的大小随 $\\,\\epsilon\\,$ 缩放，且与沿方向 $\\,v\\,$ 的局部二次曲率成正比。\n- 具有单位舍入 $\\,u\\,$ 的 IEEE 浮点运算意味着减法 $\\,F(u+\\epsilon v)-F(u)\\,$ 承受一个量级为 $\\,u\\,\\|F(u)\\|\\,$ 的绝对舍入误差，在差商中，该误差的缩放行为如同 $\\,u\\,\\|F(u)\\|/\\epsilon\\,$。\n\n您的任务是通过以下方式为最优 $\\,\\epsilon\\,$ 构建一个有原则的估计器：\n1. 通过在 $\\,\\alpha=0,\\alpha=h,\\alpha=2h\\,$ 处使用三个样本进行二次拟合，来估计标量函数 $\\,g(\\alpha)=\\|F(u+\\alpha\\,v)\\|\\,$ 在 $\\,\\alpha=0\\,$ 处的局部曲率。对于一个小的 $\\,h0\\,$，令 $\\,s_0=\\|F(u)\\|\\,,\\,s_1=\\|F(u+h\\,v)\\|\\,,\\,s_2=\\|F(u+2h\\,v)\\|\\,$。拟合 $\\,g(\\alpha)\\approx a+b\\,\\alpha+\\tfrac{1}{2}c\\,\\alpha^2\\,$ 并使用恒等式\n$$\nc \\approx \\frac{s_2 - 2\\,s_1 + s_0}{h^2} ,\n$$\n来获得曲率估计值 $\\,c\\,$。使用 $\\,\\tau=\\max(|c|,\\,\\tau_{\\min})\\,$ 作为一个稳健的曲率大小，其中 $\\,\\tau_{\\min}0\\,$ 是一个小的安全下限。\n2. 平衡前向差分近似中的截断误差和舍入误差，得到一个误差模型\n$$\nE(\\epsilon) \\approx \\frac{1}{2}\\,\\tau\\,\\epsilon \\;+\\; \\frac{r\\,u\\,\\|F(u)\\|}{\\epsilon} ,\n$$\n其中 $\\,r0\\,$ 是一个常数，它捕捉了分子中舍入贡献的尺度。关于 $\\,\\epsilon\\,$ 最小化此标量模型，并使用得到的解析最小化子作为建议的 $\\,\\epsilon^\\star\\,$。为了数值稳健性，将 $\\,\\epsilon^\\star\\,$ 限制在边界 $\\,\\epsilon_{\\min}\\le \\epsilon^\\star \\le \\epsilon_{\\max}\\,$ 内。\n\n您将使用一个无量纲、光滑、耦合的三变量多物理场残差算子 $\\,F:\\mathbb{R}^3\\to\\mathbb{R}^3\\,$ 来测试您的方法，其定义如下\n$$\nF_1(u) = k_x\\,x \\;-\\; \\alpha\\,T \\;-\\; \\beta\\,c^2 \\;-\\; f_{\\text{ext}},\n$$\n$$\nF_2(u) = k_T\\,(T - T_{\\text{env}}) \\;+\\; \\gamma\\,x^2 \\;-\\; \\delta\\,c,\n$$\n$$\nF_3(u) = k_c\\,(c - c_{\\text{in}}) \\;+\\; \\eta\\,T\\,x \\;-\\; \\mu\\,x,\n$$\n其中 $\\,u=(x,T,c)\\,$ 且参数 $\\,k_x,\\alpha,\\beta,k_T,T_{\\text{env}},\\gamma,\\delta,k_c,c_{\\text{in}},\\eta,\\mu,f_{\\text{ext}}\\,$ 是固定的。所有量都是无量纲的，并以一致的任意单位表示。\n\n实现一个程序，该程序：\n- 对于下文的每个测试用例，使用以下参数计算 $\\,\\epsilon^\\star\\,$：\n  - 机器单位舍入 $\\,u=\\,$ 双精度单位舍入。\n  - 舍入比例因子 $\\,r=\\,$ $2$。\n  - 曲率下限 $\\,\\tau_{\\min}=\\,$ $10^{-30}$。\n  - 曲率探测步长 $\\,h=\\,$ 按每个测试用例指定。\n  - 边界 $\\,\\epsilon_{\\min}=\\,$ $10^{-16}$ 和 $\\,\\epsilon_{\\max}=\\,$ $10^{-1}$。\n- 使用上文描述的通过三样本二次拟合得到的曲率估计。\n- 为每个测试用例输出所选的 $\\,\\epsilon^\\star\\,$，格式为浮点数。\n\n该测试套件由五个参数集组成：\n- 用例 A (一般耦合，中等曲率，理想路径)：\n  - 参数： $\\,k_x=3.0,\\;\\alpha=0.5,\\;\\beta=0.7,\\;k_T=2.0,\\;T_{\\text{env}}=1.0,\\;\\gamma=0.4,\\;\\delta=0.3,\\;k_c=1.5,\\;c_{\\text{in}}=0.8,\\;\\eta=0.6,\\;\\mu=0.9,\\;f_{\\text{ext}}=0.0\\,$。\n  - 状态与方向： $\\,u=(0.2,\\,0.4,\\,0.3)\\,,\\;v=(0.1,\\,-0.2,\\,0.05)\\,$。\n  - 曲率步长： $\\,h=10^{-4}\\,$。\n- 用例 B (由强非线性耦合导致的高曲率)：\n  - 参数： $\\,k_x=2.5,\\;\\alpha=0.7,\\;\\beta=5.0,\\;k_T=1.2,\\;T_{\\text{env}}=0.5,\\;\\gamma=6.0,\\;\\delta=0.4,\\;k_c=0.9,\\;c_{\\text{in}}=0.2,\\;\\eta=0.8,\\;\\mu=0.3,\\;f_{\\text{ext}}=0.0\\,$。\n  - 状态与方向： $\\,u=(0.5,\\,1.0,\\,0.7)\\,,\\;v=(0.2,\\,-0.3,\\,0.1)\\,$。\n  - 曲率步长： $\\,h=10^{-4}\\,$。\n- 用例 C (近线性区域，非常小的曲率)：\n  - 参数： $\\,k_x=1.0,\\;\\alpha=0.1,\\;\\beta=10^{-6},\\;k_T=0.8,\\;T_{\\text{env}}=0.1,\\;\\gamma=10^{-6},\\;\\delta=0.05,\\;k_c=0.7,\\;c_{\\text{in}}=0.3,\\;\\eta=0.02,\\;\\mu=0.01,\\;f_{\\text{ext}}=0.0\\,$。\n  - 状态与方向： $\\,u=(0.3,\\,0.2,\\,0.1)\\,,\\;v=(1.0,\\,1.0,\\,1.0)\\,$。\n  - 曲率步长： $\\,h=10^{-4}\\,$。\n- 用例 D (大残差范数，舍入误差主导)：\n  - 参数： $\\,k_x=4.0,\\;\\alpha=1.2,\\;\\beta=0.9,\\;k_T=3.5,\\;T_{\\text{env}}=10.0,\\;\\gamma=0.1,\\;\\delta=0.2,\\;k_c=2.0,\\;c_{\\text{in}}=5.0,\\;\\eta=0.3,\\;\\mu=0.2,\\;f_{\\text{ext}}=1000.0\\,$。\n  - 状态与方向： $\\,u=(2.0,\\,5.0,\\,3.0)\\,,\\;v=(0.5,\\,-0.1,\\,0.2)\\,$。\n  - 曲率步长： $\\,h=10^{-4}\\,$。\n- 用例 E (接近根的状态，$\\,\\|F(u)\\|\\,$ 很小，曲率下限生效)：\n  - 参数： $\\,k_x=2.0,\\;\\alpha=1.0,\\;\\beta=0.5,\\;k_T=2.0,\\;T_{\\text{env}}=0.0,\\;\\gamma=0.2,\\;\\delta=0.4,\\;k_c=1.0,\\;c_{\\text{in}}=0.0,\\;\\eta=0.3,\\;\\mu=0.6,\\;f_{\\text{ext}}=0.0\\,$。\n  - 状态与方向选择使残差变小： $\\,u=(0.0,\\,0.0,\\,0.0)\\,,\\;v=(0.01,\\,0.02,\\,-0.03)\\,$。\n  - 曲率步长： $\\,h=10^{-4}\\,$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$\\,\\left[\\epsilon_A,\\epsilon_B,\\epsilon_C,\\epsilon_D,\\epsilon_E\\right]\\,$）。每个条目必须是浮点数。由于残差是无量纲的，且扰动是与状态空间具有相同无量纲单位的标量，因此不需要物理单位。",
            "solution": "所提出的问题是有效的。这是一个数值分析领域内的适定、有科学依据的问题，具体涉及无雅可比 Newton–Krylov (JFNK) 方法的实现。所有必要的数据、函数和参数都已提供，并且没有内部矛盾或逻辑缺陷。任务是实现一种有原则的启发式方法，用于选择有限差分步长 $\\epsilon$，以最佳方式平衡截断误差和浮点舍入误差。我们现在开始提供一个完整的解决方案。\n\n问题的核心是在不显式构造雅可比矩阵 $J(u)$ 的情况下，近似其在向量 $v$ 上的作用，记为 $J(u)v$。一种常用技术是前向差分公式：\n$$\nJ(u)v \\approx \\frac{F(u+\\epsilon v) - F(u)}{\\epsilon}\n$$\n扰动参数 $\\epsilon$ 的选择至关重要。一个非常小的 $\\epsilon$ 可以最小化截断误差，但在分子中容易受到灾难性抵消（一种舍入误差形式）的影响。一个大的 $\\epsilon$ 可以减轻舍入误差，但会遭受较大的截断误差。目标是找到一个最优的 $\\epsilon$，以平衡这两个相互竞争的误差源。\n\n问题提供了一个关于 $\\epsilon$ 的总误差函数 $E(\\epsilon)$ 模型：\n$$\nE(\\epsilon) \\approx \\frac{1}{2}\\tau\\epsilon + \\frac{r u \\|F(u)\\|}{\\epsilon}\n$$\n第一项 $\\frac{1}{2}\\tau\\epsilon$ 代表主阶截断误差。这个误差源于在 $F(u+\\epsilon v)$ 的 Taylor 级数展开中忽略了高阶项。参数 $\\tau$ 是函数范数局部曲率的度量，它决定了展开式中二次项的大小。第二项 $\\frac{r u \\|F(u)\\|}{\\epsilon}$ 模拟了舍入误差。它的来源是两个几乎相等的数 $F(u+\\epsilon v)$ 和 $F(u)$ 之间的浮点减法。这个减法的绝对误差与机器单位舍入 $u$ 的量级相同，并按被减数的数量级（即 $u\\|F(u)\\|$）进行缩放。这个误差随后被除以小参数 $\\epsilon$ 而放大。因子 $r$ 是一个经验缩放常数。\n\n为了找到最优的 $\\epsilon$（记为 $\\epsilon^\\star$），我们对误差函数 $E(\\epsilon)$ 关于 $\\epsilon$ 进行最小化。我们求 $E(\\epsilon)$ 的导数并将其设为零：\n$$\n\\frac{dE}{d\\epsilon} = \\frac{d}{d\\epsilon} \\left( \\frac{1}{2}\\tau\\epsilon + \\frac{r u \\|F(u)\\|}{\\epsilon} \\right) = \\frac{1}{2}\\tau - \\frac{r u \\|F(u)\\|}{\\epsilon^2}\n$$\n将导数设为零以找到极值点：\n$$\n\\frac{1}{2}\\tau - \\frac{r u \\|F(u)\\|}{\\epsilon^2} = 0 \\implies \\frac{1}{2}\\tau = \\frac{r u \\|F(u)\\|}{\\epsilon^2}\n$$\n解出 $\\epsilon^2$：\n$$\n\\epsilon^2 = \\frac{2 r u \\|F(u)\\|}{\\tau}\n$$\n这给出了无约束的最优扰动：\n$$\n\\epsilon^\\star_{\\text{unc}} = \\sqrt{\\frac{2 r u \\|F(u)\\|}{\\tau}}\n$$\n二阶导数 $\\frac{d^2E}{d\\epsilon^2} = \\frac{2 r u \\|F(u)\\|}{\\epsilon^3}$ 对于 $\\epsilon  0$ 是正的，证实了该极值点是一个最小值点。\n\n下一步是估计曲率参数 $\\tau$。问题指定了一种方法，该方法基于在 $\\alpha=0$ 处对标量函数 $g(\\alpha) = \\|F(u+\\alpha v)\\|$ 进行二次拟合。我们对于某个小的探测步长 $h$，在三个点 $\\alpha=0$、$\\alpha=h$ 和 $\\alpha=2h$ 处对 $g(\\alpha)$ 进行采样。令 $s_0 = g(0) = \\|F(u)\\|$，$s_1 = g(h) = \\|F(u+hv)\\|$，以及 $s_2 = g(2h) = \\|F(u+2hv)\\|$。一个函数在某点的二阶导数可以通过其值的中心差分公式来近似。对于二次函数 $g(\\alpha) \\approx a+b\\alpha+\\frac{1}{2}c\\alpha^2$，其二阶导数是常数 $c$。一个用于二阶导数 $g''(0)$ 的标准三点有限差分公式给出：\n$$\nc = g''(0) \\approx \\frac{g(2h) - 2g(h) + g(0)}{(2h - h)^2} = \\frac{s_2 - 2s_1 + s_0}{h^2}\n$$\n这提供了我们对 $c$ 的估计。为确保稳健性，特别是在近线性区域，其中 $|c|$ 可能非常小或为零（导致除以零或一个非常大的 $\\epsilon^\\star$），我们使用一个有下限的曲率大小：\n$$\n\\tau = \\max(|c|, \\tau_{\\min})\n$$\n综合这些部分，计算最终被限制的扰动 $\\epsilon^\\star$ 的完整算法如下：\n1. 给定一个状态 $u$、一个方向 $v$、一个探测步长 $h$、一个残差函数 $F$ 以及常数 $r, u, \\tau_{\\min}, \\epsilon_{\\min}, \\epsilon_{\\max}$。\n2. 计算三个范数样本：$s_0 = \\|F(u)\\|$，$s_1 = \\|F(u+hv)\\|$，$s_2 = \\|F(u+2hv)\\|$。\n3. 计算曲率估计：$c = \\frac{s_2 - 2s_1 + s_0}{h^2}$。\n4. 确定稳健的曲率大小：$\\tau = \\max(|c|, \\tau_{\\min})$。\n5. 如果 $s_0 = 0$（即 $u$ 是 $F$ 的一个根），则 $\\epsilon^\\star_{\\text{unc}}$ 表达式的分子为零，因此 $\\epsilon^\\star_{\\text{unc}} = 0$。否则，计算无约束的最优扰动：\n    $$\n    \\epsilon^\\star_{\\text{unc}} = \\sqrt{\\frac{2 r u s_0}{\\tau}}\n    $$\n6. 最后，将结果限制在一个预定义的合理范围 $[\\epsilon_{\\min}, \\epsilon_{\\max}]$ 内：\n    $$\n    \\epsilon^\\star = \\max(\\epsilon_{\\min}, \\min(\\epsilon^\\star_{\\text{unc}}, \\epsilon_{\\max}))\n    $$\n\n此过程将针对所提供的五个测试用例实施，使用指定的多物理场残差算子 $F(u)$ 及其相关参数。对于 $u=(x,T,c)$，残差算子定义为：\n$$\nF(u) = \\begin{pmatrix} F_1(u) \\\\ F_2(u) \\\\ F_3(u) \\end{pmatrix} = \\begin{pmatrix} k_x x - \\alpha T - \\beta c^2 - f_{\\text{ext}} \\\\ k_T(T - T_{\\text{env}}) + \\gamma x^2 - \\delta c \\\\ k_c(c - c_{\\text{in}}) + \\eta T x - \\mu x \\end{pmatrix}\n$$\n我们将使用双精度浮点运算，其机器单位舍入 $u$ 约为 $2.22 \\times 10^{-16}$。其他常数给定为 $r=2$，$\\tau_{\\min}=10^{-30}$，$\\epsilon_{\\min}=10^{-16}$ 和 $\\epsilon_{\\max}=10^{-1}$。",
            "answer": "```python\nimport numpy as np\n\ndef residual_F(u, params):\n    \"\"\"\n    Computes the multiphysics residual vector F(u).\n\n    Args:\n        u (np.ndarray): The state vector [x, T, c].\n        params (dict): A dictionary of model parameters.\n\n    Returns:\n        np.ndarray: The residual vector F(u).\n    \"\"\"\n    x, T, c = u\n    \n    F1 = params['k_x'] * x \\\n         - params['alpha'] * T \\\n         - params['beta'] * c**2 \\\n         - params['f_ext']\n         \n    F2 = params['k_T'] * (T - params['T_env']) \\\n         + params['gamma'] * x**2 \\\n         - params['delta'] * c\n         \n    F3 = params['k_c'] * (c - params['c_in']) \\\n         + params['eta'] * T * x \\\n         - params['mu'] * x\n         \n    return np.array([F1, F2, F3])\n\ndef compute_optimal_epsilon(u, v, h, params):\n    \"\"\"\n    Computes the optimal finite-difference perturbation epsilon.\n\n    Args:\n        u (np.ndarray): The current state vector.\n        v (np.ndarray): The direction vector for the Jacobian-vector product.\n        h (float): The probing step for curvature estimation.\n        params (dict): A dictionary of model parameters.\n\n    Returns:\n        float: The calculated optimal perturbation epsilon_star.\n    \"\"\"\n    # Global constants for the calculation\n    U_MACHINE = np.finfo(float).eps\n    R_FACTOR = 2.0\n    TAU_MIN = 1e-30\n    EPS_MIN = 1e-16\n    EPS_MAX = 1e-1\n\n    # Step 1: Compute the three norm samples s0, s1, s2\n    s0 = np.linalg.norm(residual_F(u, params))\n    s1 = np.linalg.norm(residual_F(u + h * v, params))\n    s2 = np.linalg.norm(residual_F(u + 2 * h * v, params))\n    \n    # Step 2: Compute the curvature estimate c\n    # Note: Handle h=0 case, though not expected from problem statement\n    if h == 0.0:\n        c = 0.0\n    else:\n        c = (s2 - 2 * s1 + s0) / (h**2)\n        \n    # Step 3: Determine the robust curvature magnitude tau\n    tau = max(abs(c), TAU_MIN)\n    \n    # Step 4: Compute the unconstrained optimal perturbation\n    # Handle the case where we are at a root (s0 = 0)\n    if s0 == 0.0:\n        eps_unc = 0.0\n    else:\n        numerator = 2 * R_FACTOR * U_MACHINE * s0\n        eps_unc = np.sqrt(numerator / tau)\n        \n    # Step 5: Clamp the result to lie within the bounds [eps_min, eps_max]\n    epsilon_star = np.clip(eps_unc, EPS_MIN, EPS_MAX)\n    \n    return epsilon_star\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {'k_x': 3.0, 'alpha': 0.5, 'beta': 0.7, 'k_T': 2.0, 'T_env': 1.0, 'gamma': 0.4, 'delta': 0.3, 'k_c': 1.5, 'c_in': 0.8, 'eta': 0.6, 'mu': 0.9, 'f_ext': 0.0},\n            \"u\": np.array([0.2, 0.4, 0.3]),\n            \"v\": np.array([0.1, -0.2, 0.05]),\n            \"h\": 1e-4\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {'k_x': 2.5, 'alpha': 0.7, 'beta': 5.0, 'k_T': 1.2, 'T_env': 0.5, 'gamma': 6.0, 'delta': 0.4, 'k_c': 0.9, 'c_in': 0.2, 'eta': 0.8, 'mu': 0.3, 'f_ext': 0.0},\n            \"u\": np.array([0.5, 1.0, 0.7]),\n            \"v\": np.array([0.2, -0.3, 0.1]),\n            \"h\": 1e-4\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {'k_x': 1.0, 'alpha': 0.1, 'beta': 1e-6, 'k_T': 0.8, 'T_env': 0.1, 'gamma': 1e-6, 'delta': 0.05, 'k_c': 0.7, 'c_in': 0.3, 'eta': 0.02, 'mu': 0.01, 'f_ext': 0.0},\n            \"u\": np.array([0.3, 0.2, 0.1]),\n            \"v\": np.array([1.0, 1.0, 1.0]),\n            \"h\": 1e-4\n        },\n        {\n            \"name\": \"Case D\",\n            \"params\": {'k_x': 4.0, 'alpha': 1.2, 'beta': 0.9, 'k_T': 3.5, 'T_env': 10.0, 'gamma': 0.1, 'delta': 0.2, 'k_c': 2.0, 'c_in': 5.0, 'eta': 0.3, 'mu': 0.2, 'f_ext': 1000.0},\n            \"u\": np.array([2.0, 5.0, 3.0]),\n            \"v\": np.array([0.5, -0.1, 0.2]),\n            \"h\": 1e-4\n        },\n        {\n            \"name\": \"Case E\",\n            \"params\": {'k_x': 2.0, 'alpha': 1.0, 'beta': 0.5, 'k_T': 2.0, 'T_env': 0.0, 'gamma': 0.2, 'delta': 0.4, 'k_c': 1.0, 'c_in': 0.0, 'eta': 0.3, 'mu': 0.6, 'f_ext': 0.0},\n            \"u\": np.array([0.0, 0.0, 0.0]),\n            \"v\": np.array([0.01, 0.02, -0.03]),\n            \"h\": 1e-4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_star = compute_optimal_epsilon(case[\"u\"], case[\"v\"], case[\"h\"], case[\"params\"])\n        results.append(eps_star)\n        \n    # Format the final output string as specified.\n    output_str = f\"[{','.join(f'{r:.15e}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "对于大规模且具有挑战性的问题，预处理是加速Krylov求解器收敛的必要手段。然而，应用预处理（尤其是左预处理）会给求解器的停止准则带来一些微妙但关键的影响。本实践 () 深入探讨了左、右预处理之间的重要区别，并展示了如何推导出一个安全的内部Krylov迭代停止容差，以确保外部牛顿迭代的稳定收敛。",
            "id": "3511966",
            "problem": "雅可比无关的牛顿-克雷洛夫 (Jacobian-free Newton–Krylov, JFNK) 方法通过迭代求解线性化方程 $J(u) s = -F(u)$ 的牛顿修正量 $s$ 来求解非线性系统 $F(u) = 0$，其中 $J(u)$ 是 $F$ 在 $u$ 处的雅可比矩阵。克雷洛夫子空间方法，例如广义最小残差法 (Generalized Minimal Residual, GMRES)，被用于求解这些线性系统而无需显式地构造 $J(u)$，并且通常使用预条件子 $P$ 来加速收敛。在右预处理中，我们求解 $(J(u) P^{-1}) y = -F(u)$ 并恢复 $s = P^{-1} y$，而在左预处理中，我们求解 $(P^{-1} J(u)) s = -P^{-1} F(u)$。非精确牛顿法要求线性求解产生的修正量 $s$ 使得真实的线性残差 $r = F(u) + J(u) s$ 满足一个非精确性判据 $\\lVert r \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2$，其中 $\\eta \\in (0,1)$ 是一个给定的强制项。在右预处理中，克雷洛夫方法监控真实的残差范数 $\\lVert r \\rVert_2$，而在左预处理中，该方法监控预处理后的残差范数 $\\lVert P^{-1} r \\rVert_2$。目标是从第一性原理出发，分析 $\\lVert F(u) \\rVert_2$ 如何映射到 $\\lVert P^{-1} F(u) \\rVert_2$，并确定一个左预处理克雷洛夫残差的充分停止阈值，以保证真实残差满足非精确牛顿判据。\n\n从诱导矩阵范数和预处理的基本定义出发，并且不使用任何未经证明的捷径，推导出用 $\\lVert P \\rVert_2$ 和 $\\lVert P^{-1} \\rVert_2$ 来表示 $\\lVert r \\rVert_2$ 和 $\\lVert P^{-1} r \\rVert_2$ 之间关系的界。然后，利用这些界，推导出一个充分的左预处理克雷洛夫停止阈值，以保证当克雷洛夫迭代因条件 $\\lVert P^{-1} r \\rVert_2 \\le \\tau \\lVert P^{-1} F(u) \\rVert_2$ 而停止时，非精确性判据 $\\lVert r \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2$ 能够得到满足。对向量使用欧几里得范数，对矩阵使用其对应的诱导范数。在所有情况下，假设 $P$ 是非奇异的。\n\n你的任务是实现一个程序，对于一个固定的强制项 $\\eta = 10^{-2}$，为每个提供的测试用例计算：\n- 矩阵 $2$-范数 $\\lVert P \\rVert_2$，\n- 矩阵 $2$-范数 $\\lVert P^{-1} \\rVert_2$，\n- $2$-范数条件数 $\\kappa_2(P) = \\lVert P \\rVert_2 \\, \\lVert P^{-1} \\rVert_2$，\n- 一个充分的左预处理克雷洛夫容差 $\\tau_{\\text{suff}}$，它能确保真实残差满足非精确牛顿判据，\n- 以及一个布尔标志，指示朴素选择 $\\tau = \\eta$（即，使用与右预处理中真实残差相同的数值）在你的界下是否保证安全。\n\n使用以下预条件子 $P \\in \\mathbb{R}^{3 \\times 3}$ 的测试套件：\n- 情况 $1$ (边界，单位矩阵): $P_1 = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。\n- 情况 $2$ (中等条件数的对角矩阵): $P_2 = \\operatorname{diag}(2, 1, 0.5)$。\n- 情况 $3$ (高度病态的对角矩阵): $P_3 = \\operatorname{diag}(10^{4}, 1, 10^{-4})$。\n- 情况 $4$ (非对称，上三角矩阵): $P_4 = \\begin{bmatrix} 3  1  0 \\\\ 0  2  1 \\\\ 0  0  1 \\end{bmatrix}$。\n\n你的程序必须：\n- 使用矩阵 $2$-范数为每种情况计算上面列出的量，\n- 设置 $\\eta = 10^{-2}$，\n- 对每种情况，生成一个形式为 $[\\lVert P \\rVert_2, \\lVert P^{-1} \\rVert_2, \\kappa_2(P), \\tau_{\\text{suff}}, \\text{naive\\_safe}]$ 的结果，其中 $\\text{naive\\_safe}$ 是一个布尔值，指示 $\\tau = \\eta$ 在你的界下是否保证满足非精确性判据，\n- 将所有情况的结果聚合到一个单一列表中。\n\n最终输出格式：你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试用例的列表，按给定顺序排列。例如，打印的输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。不应打印任何额外的文本。所有数值都是无单位的。不出现角度，且不得使用百分比。答案类型为：范数、条件数和 $\\tau_{\\text{suff}}$ 为浮点数，安全标志为布尔值。",
            "solution": "问题陈述已经过验证，被认为是可靠、适定且客观的。它提出了一个数值线性代数中的标准、可验证的问题。\n\n问题的核心是将左预处理克雷洛夫求解器的停止判据与真实的、非预处理线性系统的非精确牛顿判据联系起来。给定一个非线性系统 $F(u) = 0$，通过牛顿法求解。在每个牛顿步中，我们求解线性系统 $J(u)s = -F(u)$ 以获得更新量 $s$，其中 $J(u)$ 是雅可比矩阵。在非精确牛顿法中，我们仅要求计算出的解 $s$ 产生的真实线性残差 $r = F(u) + J(u)s$ 满足以下条件：\n$$ \\lVert r \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2 $$\n其中 $\\eta \\in (0, 1)$ 是一个给定的强制项。\n\n在左预处理克雷洛夫方法中，所求解的线性系统是 $P^{-1}J(u)s = -P^{-1}F(u)$，其中 $P$ 是一个非奇异预条件子矩阵。克雷洛夫求解器监控预处理后残差的范数，即 $P^{-1}r$。当这个预处理后的残差足够小，满足以下形式的判据时，求解器终止：\n$$ \\lVert P^{-1}r \\rVert_2 \\le \\tau \\lVert P^{-1}F(u) \\rVert_2 $$\n其中 $-P^{-1}F(u)$ 是预处理后系统的右端项，$\\tau$ 是克雷洛夫容差。\n\n我们的目标是为容差 $\\tau$ 找到一个充分值，以保证真实残差 $r$ 满足非精确牛顿判据。这需要建立 $\\lVert r \\rVert_2$ 和 $\\lVert P^{-1}r \\rVert_2$ 之间的关系。\n\n**第1部分：范数界的推导**\n\n向量 $x$ 的范数与其变换 $Ax$ 的范数之间的关系受矩阵 $A$ 的诱导矩阵范数所限制。根据定义，矩阵 $A$ 的诱导 $2$-范数为 $\\lVert A \\rVert_2 = \\sup_{x \\ne 0} \\frac{\\lVert Ax \\rVert_2}{\\lVert x \\rVert_2}$。这直接推出了对于任意向量 $x$ 都成立的性质 $\\lVert Ax \\rVert_2 \\le \\lVert A \\rVert_2 \\lVert x \\rVert_2$。\n\n我们可以利用此性质来关联 $\\lVert r \\rVert_2$ 和 $\\lVert P^{-1}r \\rVert_2$。\n\n首先，将向量 $r$ 视为将 $P$ 应用于向量 $P^{-1}r$ 的结果。\n$$ r = P(P^{-1}r) $$\n对两边取 $2$-范数并应用矩阵范数性质：\n$$ \\lVert r \\rVert_2 = \\lVert P(P^{-1}r) \\rVert_2 \\le \\lVert P \\rVert_2 \\lVert P^{-1}r \\rVert_2 $$\n这给出了用预处理后残差范数表示的真实残差范数的一个上界。\n\n其次，将向量 $P^{-1}r$ 视为将 $P^{-1}$ 应用于向量 $r$ 的结果。\n$$ P^{-1}r = P^{-1}(r) $$\n再次取 $2$-范数并应用该性质：\n$$ \\lVert P^{-1}r \\rVert_2 \\le \\lVert P^{-1} \\rVert_2 \\lVert r \\rVert_2 $$\n这为预处理后残差范数提供了一个上界。由于 $P$ 是非奇异的，所以 $P^{-1}$ 也是非奇异的，且 $\\lVert P^{-1} \\rVert_2  0$。我们可以重新整理这个不等式，得到真实残差范数的一个下界：\n$$ \\lVert r \\rVert_2 \\ge \\frac{\\lVert P^{-1}r \\rVert_2}{\\lVert P^{-1} \\rVert_2} $$\n结合这些结果，我们建立了关联这两个范数的双边不等式：\n$$ \\frac{1}{\\lVert P^{-1} \\rVert_2} \\lVert P^{-1}r \\rVert_2 \\le \\lVert r \\rVert_2 \\le \\lVert P \\rVert_2 \\lVert P^{-1}r \\rVert_2 $$\n\n**第2部分：充分克雷洛夫容差 $\\tau_{\\text{suff}}$ 的推导**\n\n我们希望找到一个容差 $\\tau_{\\text{suff}}$，使得如果克雷洛夫求解器在满足 $\\lVert P^{-1}r \\rVert_2 \\le \\tau_{\\text{suff}} \\lVert P^{-1}F(u) \\rVert_2$ 时终止，那么非精确牛顿判据 $\\lVert r \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2$ 保证成立。\n\n从第1部分推导出的上界开始：\n$$ \\lVert r \\rVert_2 \\le \\lVert P \\rVert_2 \\lVert P^{-1}r \\rVert_2 $$\n我们将克雷洛夫停止条件代入此不等式：\n$$ \\lVert r \\rVert_2 \\le \\lVert P \\rVert_2 \\left( \\tau_{\\text{suff}} \\lVert P^{-1}F(u) \\rVert_2 \\right) $$\n现在，我们必须将 $\\lVert P^{-1}F(u) \\rVert_2$ 与 $\\lVert F(u) \\rVert_2$ 联系起来。再次使用矩阵范数性质：\n$$ \\lVert P^{-1}F(u) \\rVert_2 \\le \\lVert P^{-1} \\rVert_2 \\lVert F(u) \\rVert_2 $$\n将此界代入我们关于 $\\lVert r \\rVert_2$ 的不等式中：\n$$ \\lVert r \\rVert_2 \\le \\tau_{\\text{suff}} \\lVert P \\rVert_2 \\left( \\lVert P^{-1} \\rVert_2 \\lVert F(u) \\rVert_2 \\right) $$\n$$ \\lVert r \\rVert_2 \\le \\tau_{\\text{suff}} \\left( \\lVert P \\rVert_2 \\lVert P^{-1} \\rVert_2 \\right) \\lVert F(u) \\rVert_2 $$\n括号中的项是 $P$ 的 $2$-范数条件数的定义，记作 $\\kappa_2(P)$。\n$$ \\lVert r \\rVert_2 \\le \\tau_{\\text{suff}} \\kappa_2(P) \\lVert F(u) \\rVert_2 $$\n为了满足非精确牛顿判据 $\\lVert r \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2$，我们必须确保我们找到的界小于或等于期望的界。因此，我们要求：\n$$ \\tau_{\\text{suff}} \\kappa_2(P) \\lVert F(u) \\rVert_2 \\le \\eta \\lVert F(u) \\rVert_2 $$\n假设非线性残差 $F(u)$ 不为零（否则问题已经解决），我们可以除以 $\\lVert F(u) \\rVert_2$：\n$$ \\tau_{\\text{suff}} \\kappa_2(P) \\le \\eta $$\n为了找到一个充分的容差，我们可以解出 $\\tau_{\\text{suff}}$：\n$$ \\tau_{\\text{suff}} \\le \\frac{\\eta}{\\kappa_2(P)} $$\n任何满足此不等式的 $\\tau$ 都是充分的。为了让克雷洛夫求解器能够尽早终止，我们选择容差可能的最大值，即上界本身。\n$$ \\tau_{\\text{suff}} = \\frac{\\eta}{\\kappa_2(P)} $$\n\n**第3部分：朴素选择 $\\tau = \\eta$ 的分析**\n\n对于左预处理容差的“朴素”选择是使用与真实残差容差相同的值，即设置 $\\tau = \\eta$。这个选择是安全的当且仅当它满足我们推导出的充分条件：\n$$ \\eta \\le \\frac{\\eta}{\\kappa_2(P)} $$\n由于 $\\eta  0$，我们可以除以 $\\eta$ 得到：\n$$ 1 \\le \\frac{1}{\\kappa_2(P)} $$\n这等价于 $\\kappa_2(P) \\le 1$。\n然而，对于任何非奇异矩阵 $A$，条件数具有性质 $\\kappa(A) = \\lVert A \\rVert \\lVert A^{-1} \\rVert \\ge \\lVert A A^{-1} \\rVert = \\lVert I \\rVert = 1$。因此，条件 $\\kappa_2(P) \\le 1$ 只有在 $\\kappa_2(P) = 1$ 时才能满足。\n在 $2$-范数的情况下，这种情况发生在酉矩阵的标量倍数的矩阵上。例如，单位矩阵 $P=I$ 的条件数为 $\\kappa_2(I)=1$。\n\n总之，根据此分析，朴素选择 $\\tau = \\eta$ 只有在预条件子的条件数恰好为 $1$ 时才能保证安全。对于任何条件数 $\\kappa_2(P)  1$ 的病态预条件子，使用 $\\tau = \\eta$ 并不能保证满足真实残差的非精确牛顿判据。\n\n**计算计划**\n\n对于每个给定的预条件子矩阵 $P_i$，我们将使用 $\\eta = 10^{-2}$ 执行以下计算：\n1.  使用 `numpy.linalg.norm` 计算 $\\lVert P_i \\rVert_2$。\n2.  使用 `numpy.linalg.inv` 计算 $P_i^{-1}$，然后计算 $\\lVert P_i^{-1} \\rVert_2$。\n3.  计算条件数 $\\kappa_2(P_i) = \\lVert P_i \\rVert_2 \\lVert P_i^{-1} \\rVert_2$。\n4.  计算充分容差 $\\tau_{\\text{suff}} = \\eta / \\kappa_2(P_i)$。\n5.  通过测试 $\\kappa_2(P_i) \\le 1$ 来确定布尔标志 `naive_safe`。\n结果将被聚合成一个列表的列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a sufficient stopping tolerance for a left-preconditioned\n    Krylov solver to satisfy the inexact Newton criterion on the true residual.\n    \"\"\"\n    \n    # The inexact Newton forcing term.\n    eta = 1e-2\n\n    # The test suite of preconditioner matrices.\n    test_cases = [\n        # Case 1: Identity matrix (perfectly conditioned).\n        np.array([[1.0, 0.0, 0.0],\n                  [0.0, 1.0, 0.0],\n                  [0.0, 0.0, 1.0]]),\n        # Case 2: Moderately conditioned diagonal matrix.\n        np.array([[2.0, 0.0, 0.0],\n                  [0.0, 1.0, 0.0],\n                  [0.0, 0.0, 0.5]]),\n        # Case 3: Highly ill-conditioned diagonal matrix.\n        np.array([[1e4, 0.0, 0.0],\n                  [0.0, 1.0, 0.0],\n                  [0.0, 0.0, 1e-4]]),\n        # Case 4: Nonsymmetric, upper triangular matrix.\n        np.array([[3.0, 1.0, 0.0],\n                  [0.0, 2.0, 1.0],\n                  [0.0, 0.0, 1.0]])\n    ]\n\n    results = []\n    for P in test_cases:\n        # Compute the matrix 2-norm of P.\n        norm_P = np.linalg.norm(P, 2)\n        \n        # Compute the inverse of P and its 2-norm.\n        P_inv = np.linalg.inv(P)\n        norm_P_inv = np.linalg.norm(P_inv, 2)\n        \n        # Calculate the 2-norm condition number as defined in the problem.\n        # This is kappa_2(P) = ||P||_2 * ||P^-1||_2.\n        # Using np.linalg.cond(P, 2) would be more numerically stable but\n        # the problem asks for the explicit calculation based on the formula.\n        kappa_2 = norm_P * norm_P_inv\n        \n        # Derive the sufficient tolerance for the left-preconditioned residual.\n        # tau_suff = eta / kappa_2 ensures ||r|| = eta * ||F(u)||.\n        tau_suff = eta / kappa_2\n        \n        # Check if the naive choice tau = eta is guaranteed to be safe.\n        # This is true if and only if kappa_2(P) = 1. Since kappa >= 1 always,\n        # this is equivalent to kappa_2(P) == 1.\n        # We use np.isclose for robust floating-point comparison.\n        naive_safe = bool(np.isclose(kappa_2, 1.0))\n        \n        # Append the results for the current case.\n        results.append([\n            float(norm_P),\n            float(norm_P_inv),\n            float(kappa_2),\n            float(tau_suff),\n            naive_safe\n        ])\n\n    # Format the final output string to match the required format: [[...],[...],...]\n    # without any spaces.\n    outer_list_str = []\n    for inner_list in results:\n        # Convert each item in the inner list to its string representation.\n        # str(True) -> 'True', str(3.14) -> '3.14'\n        inner_list_str = ','.join(map(str, inner_list))\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output_str = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}