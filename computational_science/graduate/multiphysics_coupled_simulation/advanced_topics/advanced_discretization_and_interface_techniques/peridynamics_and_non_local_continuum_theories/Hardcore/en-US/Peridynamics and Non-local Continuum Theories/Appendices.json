{
    "hands_on_practices": [
        {
            "introduction": "A hallmark of peridynamics is its inherent length scale, which leads to physical phenomena not captured by classical, local theories. This practice explores one such phenomenon: wave dispersion. By analyzing wave propagation in a simple one-dimensional bar, you will derive the exact relationship between a wave's frequency and its wavenumber, revealing how wave speed in a peridynamic solid depends on wavelength—a stark contrast to the constant wave speed predicted by classical elasticity.",
            "id": "3520663",
            "problem": "Consider an infinite one-dimensional uniform bar described by Peridynamics (PD), where Peridynamics (PD) is a non-local continuum theory in which material points interact through pairwise bonds over a finite spatial horizon. Assume a bond-based, linearly elastic peridynamic model with a uniform horizon $\\,\\delta\\,$ and a constant micro-modulus $\\,c\\,$ for bonds of length $\\,|\\xi|\\leq \\delta\\,$, with zero interaction otherwise. Let the mass density be $\\,\\rho\\,$, and neglect external body forces. Starting from Newton's second law and the bond-based peridynamic equation of motion for small longitudinal displacements, consider small-amplitude plane-wave solutions of the form $\\,u(x,t)=U\\exp(i(k x - \\omega t))\\,$ with real wavenumber $\\,k\\,$ and angular frequency $\\,\\omega\\,$. Derive the exact dispersion relation as a closed-form analytic expression for $\\,\\omega^{2}(k)\\,$ in terms of $\\,c\\,$, $\\,\\rho\\,$, $\\,\\delta\\,$, and $\\,k\\,$. Then, expand your result in powers of the nondimensional wavenumber $\\,k\\delta\\,$ to identify the classical local continuum limit and the corresponding effective wave speed. Express your final answer as the exact closed-form expression for $\\,\\omega^{2}(k)\\,$ in terms of $\\,c\\,$, $\\,\\rho\\,$, $\\,\\delta\\,$, and $\\,k\\,$. No numerical evaluation is required, and no units are to be included in the final expression.",
            "solution": "The derivation begins from Newton's second law applied to a material point at position $\\,x\\,$, with mass density $\\,\\rho\\,$, and the bond-based linear peridynamic equation of motion. In a one-dimensional setting with horizon $\\,\\delta\\,$ and constant micro-modulus $\\,c\\,$ for $\\,|\\xi|\\leq \\delta\\,$, the peridynamic equation of motion for small longitudinal displacements $\\,u(x,t)\\,$ reads\n$$\n\\rho\\,\\ddot{u}(x,t) \\;=\\; \\int_{-\\delta}^{\\delta} c\\,\\big(u(x+\\xi,t)-u(x,t)\\big)\\,d\\xi,\n$$\nwhere $\\,\\xi\\,$ denotes the relative position vector in one dimension and $\\,\\ddot{u}\\,$ the second time derivative of $\\,u\\,$. This form is a direct consequence of Newton's second law together with the bond-based peridynamic linear pairwise force function for one-dimensional kinematics.\n\nWe seek plane-wave solutions of the form\n$$\nu(x,t) \\;=\\; U\\,\\exp\\!\\big(i(kx-\\omega t)\\big),\n$$\nwith amplitude $\\,U\\,$, real wavenumber $\\,k\\,$, and angular frequency $\\,\\omega\\,$. Substituting this ansatz into the equation of motion, the left-hand side becomes\n$$\n\\rho\\,\\ddot{u}(x,t) \\;=\\; \\rho\\,(-\\omega^{2})\\,U\\,\\exp\\!\\big(i(kx-\\omega t)\\big).\n$$\nThe right-hand side becomes\n$$\n\\int_{-\\delta}^{\\delta} c\\,\\big(U\\,\\exp\\!\\big(i(k(x+\\xi)-\\omega t)\\big) - U\\,\\exp\\!\\big(i(kx-\\omega t)\\big)\\big)\\,d\\xi\n\\;=\\; U\\,\\exp\\!\\big(i(kx-\\omega t)\\big)\\,\\int_{-\\delta}^{\\delta} c\\,\\big(\\exp(i k \\xi)-1\\big)\\,d\\xi.\n$$\nCanceling the common factor $\\,U\\,\\exp\\!\\big(i(kx-\\omega t)\\big)\\,$ yields the dispersion relation in implicit integral form:\n$$\n-\\rho\\,\\omega^{2} \\;=\\; \\int_{-\\delta}^{\\delta} c\\,\\big(\\exp(i k \\xi)-1\\big)\\,d\\xi.\n$$\nWe evaluate the integral explicitly. The integral of $\\,\\exp(i k \\xi)\\,$ over the symmetric interval is\n$$\n\\int_{-\\delta}^{\\delta} \\exp(i k \\xi)\\,d\\xi \\;=\\; \\left.\\frac{\\exp(i k \\xi)}{i k}\\right|_{-\\delta}^{\\delta}\n\\;=\\; \\frac{\\exp(i k \\delta)-\\exp(-i k \\delta)}{i k}\n\\;=\\; \\frac{2\\,\\sin(k\\delta)}{k}.\n$$\nThe integral of $\\,1\\,$ over the same interval is $\\,\\int_{-\\delta}^{\\delta} 1\\,d\\xi = 2\\delta\\,$. Therefore,\n$$\n\\int_{-\\delta}^{\\delta} c\\,\\big(\\exp(i k \\xi)-1\\big)\\,d\\xi\n\\;=\\; c\\left(\\frac{2\\,\\sin(k\\delta)}{k} \\;-\\; 2\\delta\\right).\n$$\nThe dispersion relation becomes\n$$\n-\\rho\\,\\omega^{2} \\;=\\; c\\left(\\frac{2\\,\\sin(k\\delta)}{k} \\;-\\; 2\\delta\\right),\n$$\nor equivalently\n$$\n\\omega^{2}(k) \\;=\\; \\frac{2c}{\\rho}\\left(\\delta \\;-\\; \\frac{\\sin(k\\delta)}{k}\\right).\n$$\nThis is the exact closed-form analytic expression for the peridynamic dispersion relation for small-amplitude longitudinal waves in an infinite one-dimensional bar with constant micro-modulus over a finite horizon.\n\nTo connect with the classical local continuum limit, we expand for small nondimensional wavenumber $\\,k\\delta\\ll 1\\,$ using the Taylor series\n$$\n\\sin(k\\delta) \\;=\\; k\\delta \\;-\\; \\frac{(k\\delta)^{3}}{6} \\;+\\; \\frac{(k\\delta)^{5}}{120} \\;-\\; \\cdots.\n$$\nThen\n$$\n\\delta \\;-\\; \\frac{\\sin(k\\delta)}{k}\n\\;=\\; \\delta \\;-\\; \\left(\\delta \\;-\\; \\frac{k^{2}\\delta^{3}}{6} \\;+\\; \\frac{k^{4}\\delta^{5}}{120} \\;-\\; \\cdots\\right)\n\\;=\\; \\frac{k^{2}\\delta^{3}}{6} \\;-\\; \\frac{k^{4}\\delta^{5}}{120} \\;+\\; \\cdots.\n$$\nTherefore, at leading order,\n$$\n\\omega^{2}(k) \\;\\approx\\; \\frac{2c}{\\rho}\\,\\frac{k^{2}\\delta^{3}}{6}\n\\;=\\; \\left(\\frac{c\\,\\delta^{3}}{3\\,\\rho}\\right)\\,k^{2}.\n$$\nIn the classical one-dimensional local elastic continuum governed by $\\,\\rho\\,\\ddot{u} = E\\,\\partial^{2}u/\\partial x^{2}\\,$, plane waves satisfy\n$$\n\\omega^{2}(k) \\;=\\; \\frac{E}{\\rho}\\,k^{2}.\n$$\nMatching the leading-order behavior identifies the effective local modulus for the bond-based peridynamic model in one dimension as $\\,E_{\\mathrm{eff}} = c\\,\\delta^{3}/3\\,$, and the effective wave speed squared as $\\,E_{\\mathrm{eff}}/\\rho = c\\,\\delta^{3}/(3\\rho)\\,$. Higher-order terms in the peridynamic dispersion relation introduce non-local dispersion that deviates from the local theory at larger $\\,k\\delta\\,$, while the small $\\,k\\delta\\,$ limit reproduces the classical linear dispersion $\\,\\omega\\propto k\\,$.\n\nThe requested final expression for the exact dispersion relation is thus the closed form\n$$\n\\omega^{2}(k) \\;=\\; \\frac{2c}{\\rho}\\left(\\delta \\;-\\; \\frac{\\sin(k\\delta)}{k}\\right).\n$$",
            "answer": "$$\\boxed{\\frac{2c}{\\rho}\\left(\\delta-\\frac{\\sin(k\\delta)}{k}\\right)}$$"
        },
        {
            "introduction": "For any physical theory to be predictive, its parameters must be connected to experimentally measurable quantities. Peridynamics is no exception; its microscopic parameters, like the micromodulus, must be calibrated to match macroscopic material properties like the shear modulus. This exercise guides you through a fundamental calibration procedure, equating the strain energy of a nonlocal bond-based model to its classical counterpart under pure shear to determine the micromodulus constant.",
            "id": "3520735",
            "problem": "Consider a homogeneous, microelastic, bond-based peridynamic solid in three-dimensional space with a finite interaction horizon of radius $\\delta$. The reference bond vector between two material points is $\\boldsymbol{\\xi}$ with length $r=\\|\\boldsymbol{\\xi}\\|$. The spherically symmetric micromodulus (also called kernel) is given by\n$$\nc(r)=\\begin{cases}\nc_0\\left(1-\\dfrac{r}{\\delta}\\right), & 0\\le r\\le \\delta, \\\\\n0, & r>\\delta,\n\\end{cases}\n$$\nwhere $c_0$ is a constant to be determined. Assume small deformations and a homogeneous deformation characterized by the infinitesimal strain tensor $\\boldsymbol{\\varepsilon}$. In the bond-based microelastic model, the bond stretch is defined as $s=\\hat{\\boldsymbol{\\xi}}\\cdot \\boldsymbol{\\varepsilon}\\,\\hat{\\boldsymbol{\\xi}}$, where $\\hat{\\boldsymbol{\\xi}}=\\boldsymbol{\\xi}/\\|\\boldsymbol{\\xi}\\|$, and the peridynamic strain energy density at a point is\n$$\nW_{\\mathrm{PD}}=\\dfrac{1}{4}\\int_{|\\boldsymbol{\\xi}|\\le \\delta} c(\\|\\boldsymbol{\\xi}\\|)\\,s^2\\,\\|\\boldsymbol{\\xi}\\|\\,\\mathrm{d}V',\n$$\nwith $\\mathrm{d}V'$ the volume measure at the point $\\boldsymbol{x}'=\\boldsymbol{x}+\\boldsymbol{\\xi}$. For a homogeneous pure shear deformation in the $x_1$–$x_2$ plane with shear parameter $\\gamma$, the nonzero components of $\\boldsymbol{\\varepsilon}$ are $\\varepsilon_{12}=\\varepsilon_{21}=\\gamma/2$. In classical linear elasticity for an isotropic solid with shear modulus $\\mu$, the corresponding strain energy density for this pure shear state is\n$$\nW_{\\mathrm{cl}}=\\dfrac{1}{2}\\,\\mu\\,\\gamma^2.\n$$\nDetermine the value of $c_0$ as a closed-form analytic expression in terms of $\\mu$ and $\\delta$ such that, in the limit $\\delta\\to 0$ under the homogeneous pure shear deformation, the peridynamic model recovers the classical response, meaning $W_{\\mathrm{PD}}=W_{\\mathrm{cl}}$ for this deformation. Express your final answer as a single analytic expression in terms of $\\mu$ and $\\delta$. Do not include units in your final expression.",
            "solution": "The problem requires the determination of the constant $c_0$ for a given peridynamic micromodulus function. This is achieved by equating the peridynamic strain energy density, $W_{\\mathrm{PD}}$, to the classical linear elastic strain energy density, $W_{\\mathrm{cl}}$, for a state of homogeneous pure shear. This method is a standard calibration procedure, ensuring that the non-local peridynamic model reproduces the behavior of the classical local model for homogeneous deformations.\n\nThe classical strain energy density for an isotropic solid subjected to pure shear with shear parameter $\\gamma$ is given as:\n$$\nW_{\\mathrm{cl}} = \\frac{1}{2} \\mu \\gamma^2\n$$\nwhere $\\mu$ is the shear modulus.\n\nThe peridynamic strain energy density is given by the expression:\n$$\nW_{\\mathrm{PD}} = \\frac{1}{4} \\int_{|\\boldsymbol{\\xi}| \\le \\delta} c(\\|\\boldsymbol{\\xi}\\|) s^2 \\|\\boldsymbol{\\xi}\\| \\, \\mathrm{d}V'\n$$\nWe must first evaluate the bond stretch, $s$, for the specified deformation. The strain tensor $\\boldsymbol{\\varepsilon}$ for pure shear in the $x_1$-$x_2$ plane has non-zero components $\\varepsilon_{12} = \\varepsilon_{21} = \\gamma/2$. All other components are zero. The bond stretch $s$ is defined as $s = \\hat{\\boldsymbol{\\xi}} \\cdot \\boldsymbol{\\varepsilon} \\hat{\\boldsymbol{\\xi}}$, where $\\hat{\\boldsymbol{\\xi}} = \\boldsymbol{\\xi} / \\|\\boldsymbol{\\xi}\\| = (\\hat{\\xi}_1, \\hat{\\xi}_2, \\hat{\\xi}_3)^T$ is the unit vector along the bond.\n\nLet's compute the product $\\boldsymbol{\\varepsilon} \\hat{\\boldsymbol{\\xi}}$:\n$$\n\\boldsymbol{\\varepsilon} \\hat{\\boldsymbol{\\xi}} = \\begin{pmatrix} 0 & \\gamma/2 & 0 \\\\ \\gamma/2 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} \\hat{\\xi}_1 \\\\ \\hat{\\xi}_2 \\\\ \\hat{\\xi}_3 \\end{pmatrix} = \\begin{pmatrix} (\\gamma/2)\\hat{\\xi}_2 \\\\ (\\gamma/2)\\hat{\\xi}_1 \\\\ 0 \\end{pmatrix}\n$$\nNow, we compute the dot product $\\hat{\\boldsymbol{\\xi}} \\cdot (\\boldsymbol{\\varepsilon} \\hat{\\boldsymbol{\\xi}})$:\n$$\ns = \\hat{\\xi}_1 \\left(\\frac{\\gamma}{2}\\hat{\\xi}_2\\right) + \\hat{\\xi}_2 \\left(\\frac{\\gamma}{2}\\hat{\\xi}_1\\right) + \\hat{\\xi}_3(0) = \\gamma \\hat{\\xi}_1 \\hat{\\xi}_2\n$$\nThe square of the bond stretch is therefore:\n$$\ns^2 = \\gamma^2 \\hat{\\xi}_1^2 \\hat{\\xi}_2^2\n$$\nNow we substitute this and the given micromodulus function $c(r)=c_0(1-r/\\delta)$ into the expression for $W_{\\mathrm{PD}}$. Let $r = \\|\\boldsymbol{\\xi}\\|$. The integration is over a sphere of radius $\\delta$.\n$$\nW_{\\mathrm{PD}} = \\frac{1}{4} \\int_{|\\boldsymbol{\\xi}| \\le \\delta} c_0 \\left(1-\\frac{r}{\\delta}\\right) (\\gamma^2 \\hat{\\xi}_1^2 \\hat{\\xi}_2^2) r \\, \\mathrm{d}V'\n$$\nTo evaluate this integral, we switch to spherical coordinates. Let $\\boldsymbol{\\xi} = (r\\sin\\theta\\cos\\phi, r\\sin\\theta\\sin\\phi, r\\cos\\theta)$. The unit vector components are $\\hat{\\xi}_1 = \\sin\\theta\\cos\\phi$, $\\hat{\\xi}_2 = \\sin\\theta\\sin\\phi$, and $\\hat{\\xi}_3 = \\cos\\theta$. The volume element is $\\mathrm{d}V' = r^2 \\sin\\theta \\, \\mathrm{d}r \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi$. The integration limits are $r \\in [0, \\delta]$, $\\theta \\in [0, \\pi]$, and $\\phi \\in [0, 2\\pi]$.\n\nSubstituting these into the integral for $W_{\\mathrm{PD}}$:\n$$\nW_{\\mathrm{PD}} = \\frac{1}{4} \\int_0^{2\\pi} \\int_0^{\\pi} \\int_0^{\\delta} c_0 \\left(1-\\frac{r}{\\delta}\\right) \\gamma^2 (\\sin\\theta\\cos\\phi)^2 (\\sin\\theta\\sin\\phi)^2 r (r^2 \\sin\\theta) \\, \\mathrm{d}r \\, \\mathrm{d}\\theta \\, \\mathrm{d}\\phi\n$$\nWe can factor out constants and separate the integral into radial and angular parts:\n$$\nW_{\\mathrm{PD}} = \\frac{c_0 \\gamma^2}{4} \\left[ \\int_0^{\\delta} r^3 \\left(1-\\frac{r}{\\delta}\\right) \\mathrm{d}r \\right] \\left[ \\int_0^{\\pi} \\sin^5\\theta \\, \\mathrm{d}\\theta \\right] \\left[ \\int_0^{2\\pi} \\cos^2\\phi \\sin^2\\phi \\, \\mathrm{d}\\phi \\right]\n$$\nLet's evaluate each integral separately.\n\nThe radial integral $I_r$:\n$$\nI_r = \\int_0^{\\delta} \\left(r^3 - \\frac{r^4}{\\delta}\\right) \\mathrm{d}r = \\left[ \\frac{r^4}{4} - \\frac{r^5}{5\\delta} \\right]_0^{\\delta} = \\frac{\\delta^4}{4} - \\frac{\\delta^5}{5\\delta} = \\frac{\\delta^4}{4} - \\frac{\\delta^4}{5} = \\frac{\\delta^4}{20}\n$$\nThe polar integral $I_\\theta$:\n$$\nI_\\theta = \\int_0^{\\pi} \\sin^5\\theta \\, \\mathrm{d}\\theta = \\int_0^{\\pi} (\\sin^2\\theta)^2 \\sin\\theta \\, \\mathrm{d}\\theta = \\int_0^{\\pi} (1-\\cos^2\\theta)^2 \\sin\\theta \\, \\mathrm{d}\\theta\n$$\nUsing the substitution $u = \\cos\\theta$, $\\mathrm{d}u = -\\sin\\theta \\, \\mathrm{d}\\theta$:\n$$\nI_\\theta = \\int_{1}^{-1} (1-u^2)^2 (-\\mathrm{d}u) = \\int_{-1}^{1} (1 - 2u^2 + u^4) \\mathrm{d}u = \\left[ u - \\frac{2u^3}{3} + \\frac{u^5}{5} \\right]_{-1}^{1} = 2 \\left(1 - \\frac{2}{3} + \\frac{1}{5}\\right) = 2 \\left(\\frac{15-10+3}{15}\\right) = \\frac{16}{15}\n$$\nThe azimuthal integral $I_\\phi$:\n$$\nI_\\phi = \\int_0^{2\\pi} \\cos^2\\phi \\sin^2\\phi \\, \\mathrm{d}\\phi = \\int_0^{2\\pi} \\left(\\frac{\\sin(2\\phi)}{2}\\right)^2 \\mathrm{d}\\phi = \\frac{1}{4} \\int_0^{2\\pi} \\sin^2(2\\phi) \\, \\mathrm{d}\\phi\n$$\nUsing the identity $\\sin^2(x) = \\frac{1 - \\cos(2x)}{2}$:\n$$\nI_\\phi = \\frac{1}{4} \\int_0^{2\\pi} \\frac{1 - \\cos(4\\phi)}{2} \\mathrm{d}\\phi = \\frac{1}{8} \\left[ \\phi - \\frac{\\sin(4\\phi)}{4} \\right]_0^{2\\pi} = \\frac{1}{8} (2\\pi) = \\frac{\\pi}{4}\n$$\nNow, we assemble the expression for $W_{\\mathrm{PD}}$:\n$$\nW_{\\mathrm{PD}} = \\frac{c_0 \\gamma^2}{4} \\cdot I_r \\cdot I_\\theta \\cdot I_\\phi = \\frac{c_0 \\gamma^2}{4} \\left(\\frac{\\delta^4}{20}\\right) \\left(\\frac{16}{15}\\right) \\left(\\frac{\\pi}{4}\\right)\n$$\n$$\nW_{\\mathrm{PD}} = c_0 \\gamma^2 \\frac{16 \\pi \\delta^4}{4 \\cdot 20 \\cdot 15 \\cdot 4} = c_0 \\gamma^2 \\frac{16 \\pi \\delta^4}{4800} = c_0 \\gamma^2 \\frac{\\pi \\delta^4}{300}\n$$\nTo find $c_0$, we equate the peridynamic and classical strain energy densities, $W_{\\mathrm{PD}} = W_{\\mathrm{cl}}$:\n$$\nc_0 \\gamma^2 \\frac{\\pi \\delta^4}{300} = \\frac{1}{2} \\mu \\gamma^2\n$$\nThe term $\\gamma^2$ cancels from both sides, as the equivalence must hold for any amount of small shear:\n$$\nc_0 \\frac{\\pi \\delta^4}{300} = \\frac{\\mu}{2}\n$$\nFinally, we solve for $c_0$:\n$$\nc_0 = \\frac{\\mu}{2} \\frac{300}{\\pi \\delta^4} = \\frac{150 \\mu}{\\pi \\delta^4}\n$$\nThis is the required expression for $c_0$ in terms of the shear modulus $\\mu$ and the horizon radius $\\delta$.",
            "answer": "$$\n\\boxed{\\frac{150 \\mu}{\\pi \\delta^4}}\n$$"
        },
        {
            "introduction": "The practical power of nonlocal theories like peridynamics is unlocked through computational simulation. A critical step in these simulations is computing the deformation at each point, which in state-based peridynamics is captured by the nonlocal deformation gradient. This hands-on coding challenge tasks you with translating the abstract mathematical definition of the nonlocal deformation gradient—a best-fit linear map—into a concrete numerical algorithm, providing direct experience with the computational foundations of the theory.",
            "id": "3520731",
            "problem": "You are asked to design and implement a program that computes the nonlocal deformation gradient in the sense of peridynamics and non-local continuum theories for a prescribed affine displacement field sampled on a perturbed particle set, and to quantify the resulting approximation error. The program must implement the estimator from first principles as a weighted least-squares best-fit of a linear map to relative deformations over a finite neighborhood (horizon). The answer must be reproducible and must not require any external input.\n\nFundamental base. Begin from the following universally accepted principles:\n- The deformation map at a material point is approximated locally by an affine map. Given a body undergoing motion, let the position of a material point initially at position $\\mathbf{x} \\in \\mathbb{R}^{2}$ be mapped to $\\mathbf{y}(\\mathbf{x}) \\in \\mathbb{R}^{2}$. For sufficiently smooth motions, the best linear approximation in the neighborhood of $\\mathbf{x}_{0}$ is encoded by the deformation gradient $\\mathbf{F}(\\mathbf{x}_{0})$, defined in the classical local theory by $\\mathbf{F}(\\mathbf{x}_{0}) = \\nabla \\mathbf{y}(\\mathbf{x}_{0})$.\n- In a non-local setting, a best-fit linear map can be identified as the minimizer of a weighted least-squares functional over a finite horizon. Specifically, for a given symmetric nonnegative weight (kernel) $\\omega(r)$ with compact or rapidly decaying support and a horizon radius $\\delta$, define relative vectors $\\boldsymbol{\\xi} = \\mathbf{x} - \\mathbf{x}_{0}$ and $\\boldsymbol{\\eta} = \\mathbf{y}(\\mathbf{x}) - \\mathbf{y}(\\mathbf{x}_{0})$. Consider the functional\n$$\n\\mathcal{J}(\\mathbf{F}) = \\int_{\\|\\boldsymbol{\\xi}\\| \\le \\delta} \\omega\\!\\left(\\|\\boldsymbol{\\xi}\\|\\right)\\,\\left\\| \\mathbf{F}\\,\\boldsymbol{\\xi} - \\boldsymbol{\\eta} \\right\\|^{2}\\,\\mathrm{d}V,\n$$\nwhose minimizer provides a non-local estimate $\\widehat{\\mathbf{F}}(\\mathbf{x}_{0})$ of the deformation gradient. This estimator is grounded in well-tested relationships of linear regression and weighted least squares (LS).\n- The affine displacement field $\\mathbf{u}(\\mathbf{x})$ is prescribed as $\\mathbf{u}(\\mathbf{x}) = \\mathbf{A}\\,\\mathbf{x} + \\mathbf{b}$, with constant matrix $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$ and constant vector $\\mathbf{b} \\in \\mathbb{R}^{2}$. The motion is then $\\mathbf{y}(\\mathbf{x}) = \\mathbf{x} + \\mathbf{u}(\\mathbf{x}) = (\\mathbf{I} + \\mathbf{A})\\,\\mathbf{x} + \\mathbf{b}$, where $\\mathbf{I}$ is the identity. The exact deformation gradient is $\\mathbf{F}_{\\mathrm{exact}} = \\mathbf{I} + \\mathbf{A}$.\n- The particle discretization of the integral is performed on a nominal square lattice of spacing $h$ within a square domain of half-side length $L$, with each lattice point perturbed by independent Gaussian noise of zero mean and standard deviation $p\\,h$ applied independently to each coordinate. Particles are assigned equal volume $h^{2}$.\n\nTasks.\n- Derive, from the first variation of the functional $\\mathcal{J}(\\mathbf{F})$, a discrete formula for the non-local deformation gradient estimator $\\widehat{\\mathbf{F}}(\\mathbf{x}_{0})$ in terms of weighted sums over neighbors within the horizon $\\delta$. You must use only the principles above; do not employ any specialized formulas outside of what follows from the least-squares minimization and basic calculus.\n- Implement a program that:\n  - Generates the particle set on the square domain $\\{ \\mathbf{x} \\in \\mathbb{R}^{2} : -L \\le x_{1} \\le L,\\,-L \\le x_{2} \\le L \\}$ at lattice spacing $h$, then adds Gaussian perturbations with standard deviation $p\\,h$. Use a pseudo-random generator with a fixed seed for each test case to ensure reproducibility, as specified below.\n  - At the evaluation point $\\mathbf{x}_{0}$, collects all neighbors with $0 < \\|\\boldsymbol{\\xi}\\| \\le \\delta$, where $\\boldsymbol{\\xi} = \\mathbf{x} - \\mathbf{x}_{0}$.\n  - Uses the Gaussian kernel $\\omega(r) = \\exp\\!\\left( - (r/\\delta)^{2} \\right)$.\n  - Forms the discrete weighted least-squares estimator you derived to compute $\\widehat{\\mathbf{F}}(\\mathbf{x}_{0})$. If the discrete normal matrix is ill-conditioned or singular, use a Tikhonov regularization $\\lambda\\,\\mathbf{I}$ with $\\lambda > 0$ chosen to be small and dimensionally consistent; report what you choose for $\\lambda$ and why, and implement it consistently.\n  - Computes the relative Frobenius norm error\n  $$\n  e = \\frac{\\left\\| \\widehat{\\mathbf{F}}(\\mathbf{x}_{0}) - \\mathbf{F}_{\\mathrm{exact}} \\right\\|_{F}}{\\left\\| \\mathbf{F}_{\\mathrm{exact}} \\right\\|_{F}}.\n  $$\n- For each test case, the output must be a single floating-point number equal to the error $e$, rounded to eight decimal places.\n\nTest suite. Your program must evaluate the following five test cases and output all five results in a single line as specified below. In all cases, the units are purely mathematical and dimensionless. The angle unit is not applicable. For each case, list $(\\mathbf{A},\\mathbf{b},L,h,\\delta,p,\\mathbf{x}_{0},\\text{seed})$:\n- Case $1$: $\\mathbf{A} = \\begin{bmatrix} 0.1 & 0.2 \\\\ -0.05 & 0.15 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0.01 \\\\ -0.02 \\end{bmatrix}$, $L = 0.5$, $h = 0.05$, $\\delta = 0.2$, $p = 0.0$, $\\mathbf{x}_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, seed $= 1$.\n- Case $2$: same $\\mathbf{A}$ and $\\mathbf{b}$ as Case $1$, $L = 0.5$, $h = 0.05$, $\\delta = 0.2$, $p = 0.1$, $\\mathbf{x}_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, seed $= 2$.\n- Case $3$: same $\\mathbf{A}$ and $\\mathbf{b}$ as Case $1$, $L = 0.5$, $h = 0.05$, $\\delta = 0.12$, $p = 0.25$, $\\mathbf{x}_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, seed $= 3$.\n- Case $4$: $\\mathbf{A} = \\begin{bmatrix} 0.05 & -0.3 \\\\ 0.3 & -0.02 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0.03 \\\\ 0.02 \\end{bmatrix}$, $L = 0.5$, $h = 0.04$, $\\delta = 0.18$, $p = 0.15$, $\\mathbf{x}_{0} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, seed $= 4$.\n- Case $5$: $\\mathbf{A} = \\begin{bmatrix} 0.12 & 0.0 \\\\ 0.0 & -0.08 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, $L = 0.4$, $h = 0.04$, $\\delta = 0.2$, $p = 0.05$, $\\mathbf{x}_{0} = \\begin{bmatrix} 0.35 \\\\ 0.0 \\end{bmatrix}$, seed $= 5$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $5$. Each error must be rounded to exactly eight digits after the decimal point, in standard decimal notation. For example, an output for three hypothetical results would be written as $[\\;0.00012345,0.00123456,0.01234567\\;]$.\n\nNotes and constraints.\n- You must not use any external input. All parameters are embedded in the program.\n- If, for any test case, there are no neighbors within the horizon $\\delta$, return the Not-a-Number value as defined by the programming language. However, given the parameters above, this scenario should not occur.\n- Report and justify the choice of regularization parameter $\\lambda$ in your approach inside your solution explanation. The implemented program must use the same choice.",
            "solution": "The non-local deformation gradient $\\widehat{\\mathbf{F}}$ is derived from first principles by minimizing the weighted least-squares functional $\\mathcal{J}(\\mathbf{F})$.\n\nThe functional is defined as:\n$$\n\\mathcal{J}(\\mathbf{F}) = \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) \\left\\| \\mathbf{F}\\,\\boldsymbol{\\xi} - \\boldsymbol{\\eta} \\right\\|^{2}\\,\\mathrm{d}V\n$$\nwhere $\\mathcal{H}$ is the neighborhood of $\\mathbf{x}_0$ defined by $\\|\\boldsymbol{\\xi}\\| \\le \\delta$. The necessary condition for a minimum is that the first variation of $\\mathcal{J}$ with respect to $\\mathbf{F}$ vanishes. Setting the gradient of the functional to the zero tensor yields the Euler-Lagrange equation:\n$$\n\\nabla_{\\mathbf{F}}\\mathcal{J} = \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) \\cdot 2 (\\widehat{\\mathbf{F}}\\boldsymbol{\\xi}-\\boldsymbol{\\eta})\\boldsymbol{\\xi}^T \\,\\mathrm{d}V = \\mathbf{0}\n$$\nDistributing the terms and rearranging for $\\widehat{\\mathbf{F}}$ gives the normal equation:\n$$\n\\widehat{\\mathbf{F}} \\left( \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) (\\boldsymbol{\\xi} \\otimes \\boldsymbol{\\xi}) \\,\\mathrm{d}V \\right) = \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) (\\boldsymbol{\\eta} \\otimes \\boldsymbol{\\xi}) \\,\\mathrm{d}V\n$$\nwhere $\\otimes$ denotes the tensor product. We define the shape tensor $\\mathbf{K}$ and the mixed dyadic tensor $\\mathbf{M}$ as:\n$$\n\\mathbf{K} = \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) (\\boldsymbol{\\xi} \\otimes \\boldsymbol{\\xi}) \\,\\mathrm{d}V \\quad \\text{and} \\quad \\mathbf{M} = \\int_{\\mathcal{H}} \\omega(\\|\\boldsymbol{\\xi}\\|) (\\boldsymbol{\\eta} \\otimes \\boldsymbol{\\xi}) \\,\\mathrm{d}V\n$$\nThe normal equation is then $\\widehat{\\mathbf{F}} \\mathbf{K} = \\mathbf{M}$. Provided $\\mathbf{K}$ is invertible, the solution is $\\widehat{\\mathbf{F}} = \\mathbf{M} \\mathbf{K}^{-1}$.\n\nFor the discrete particle system, the integrals are replaced by sums over neighbor particles $j$ within the horizon $\\delta$ of the evaluation point $\\mathbf{x}_{0}$. Each particle $j$ has an associated volume (area in 2D) $V_j = h^2$. The discrete forms of $\\mathbf{K}$ and $\\mathbf{M}$ are:\n$$\n\\mathbf{K} = \\sum_{j \\in \\mathcal{H}_{0}} \\omega(\\|\\boldsymbol{\\xi}_j\\|) (\\boldsymbol{\\xi}_j \\otimes \\boldsymbol{\\xi}_j) V_j \\quad \\text{and} \\quad \\mathbf{M} = \\sum_{j \\in \\mathcal{H}_{0}} \\omega(\\|\\boldsymbol{\\xi}_j\\|) (\\boldsymbol{\\eta}_j \\otimes \\boldsymbol{\\xi}_j) V_j\n$$\nwhere $\\boldsymbol{\\xi}_j = \\mathbf{x}_j - \\mathbf{x}_0$ and $\\boldsymbol{\\eta}_j = \\mathbf{y}(\\mathbf{x}_j) - \\mathbf{y}(\\mathbf{x}_0)$. The sum is over the set of neighbors $\\mathcal{H}_0 = \\{j \\mid 0  \\|\\mathbf{x}_j - \\mathbf{x}_0\\| \\le \\delta\\}$.\n\nThe shape tensor $\\mathbf{K}$ can be singular or ill-conditioned if the neighbor particles are poorly distributed. To ensure a stable solution, Tikhonov regularization is applied by adding a small term $\\lambda \\mathbf{I}$ to $\\mathbf{K}$, where $\\mathbf{I}$ is the identity tensor. The regularized system is $\\widehat{\\mathbf{F}} (\\mathbf{K} + \\lambda \\mathbf{I}) = \\mathbf{M}$, yielding the solution:\n$$\n\\widehat{\\mathbf{F}} = \\mathbf{M} (\\mathbf{K} + \\lambda \\mathbf{I})^{-1}\n$$\nThe regularization parameter $\\lambda$ must be dimensionally consistent with the entries of $\\mathbf{K}$, which have units of length to the fourth power. A robust choice for $\\lambda$ is to make it proportional to the average magnitude of the diagonal entries of $\\mathbf{K}$. We choose $\\lambda = \\epsilon_{reg} \\cdot \\frac{1}{2}\\mathrm{tr}(\\mathbf{K})$, where $\\epsilon_{reg} = 10^{-9}$ is a small, dimensionless constant. This ensures that the regularization is scaled appropriately to the problem's characteristics while being small enough not to excessively bias the solution.\n\nFor the prescribed affine motion $\\mathbf{y}(\\mathbf{x}) = (\\mathbf{I}+\\mathbf{A})\\mathbf{x} + \\mathbf{b} = \\mathbf{F}_{\\mathrm{exact}}\\mathbf{x} + \\mathbf{b}$, the relative displacement vector $\\boldsymbol{\\eta}_j$ is:\n$$\n\\boldsymbol{\\eta}_j = \\mathbf{y}(\\mathbf{x}_j) - \\mathbf{y}(\\mathbf{x}_0) = (\\mathbf{F}_{\\mathrm{exact}}\\mathbf{x}_j + \\mathbf{b}) - (\\mathbf{F}_{\\mathrm{exact}}\\mathbf{x}_0 + \\mathbf{b}) = \\mathbf{F}_{\\mathrm{exact}}(\\mathbf{x}_j - \\mathbf{x}_0) = \\mathbf{F}_{\\mathrm{exact}}\\boldsymbol{\\xi}_j\n$$\nSubstituting this into the expression for $\\mathbf{M}$:\n$$\n\\mathbf{M} = \\sum_{j \\in \\mathcal{H}_{0}} \\omega_j (\\mathbf{F}_{\\mathrm{exact}}\\boldsymbol{\\xi}_j \\otimes \\boldsymbol{\\xi}_j) V_j = \\mathbf{F}_{\\mathrm{exact}} \\left( \\sum_{j \\in \\mathcal{H}_{0}} \\omega_j (\\boldsymbol{\\xi}_j \\otimes \\boldsymbol{\\xi}_j) V_j \\right) = \\mathbf{F}_{\\mathrm{exact}}\\mathbf{K}\n$$\nTherefore, in the absence of numerical errors, the estimator should exactly recover the deformation gradient: $\\widehat{\\mathbf{F}} = (\\mathbf{F}_{\\mathrm{exact}}\\mathbf{K})\\mathbf{K}^{-1} = \\mathbf{F}_{\\mathrm{exact}}$. The computed error $e$ will thus be non-zero only due to floating-point arithmetic limitations, and its magnitude will reflect the numerical stability of the implementation.\n\nThe algorithm proceeds as follows:\n1.  For each test case, generate the perturbed particle positions $\\mathbf{x}_j$ using the specified parameters and random seed.\n2.  At the evaluation point $\\mathbf{x}_0$, identify all neighbor particles within the horizon $\\delta$.\n3.  Compute the discrete shape tensor $\\mathbf{K}$ and mixed tensor $\\mathbf{M}$ by summing over the identified neighbors.\n4.  Calculate the regularization parameter $\\lambda$ from the trace of $\\mathbf{K}$.\n5.  Solve the regularized linear system for the estimated deformation gradient $\\widehat{\\mathbf{F}} = \\mathbf{M} (\\mathbf{K} + \\lambda \\mathbf{I})^{-1}$.\n6.  Compute the exact deformation gradient $\\mathbf{F}_{\\mathrm{exact}} = \\mathbf{I} + \\mathbf{A}$.\n7.  Calculate the relative error $e$ using the Frobenius norm and append it to the results list.\n8.  Format the final list of errors as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (A, b, L, h, delta, p, x0, seed) - No perturbation\n        {'A': np.array([[0.1, 0.2], [-0.05, 0.15]]), 'b': np.array([0.01, -0.02]),\n         'L': 0.5, 'h': 0.05, 'delta': 0.2, 'p': 0.0, 'x0': np.array([0.0, 0.0]), 'seed': 1},\n        # Case 2: Same as Case 1, but with perturbation\n        {'A': np.array([[0.1, 0.2], [-0.05, 0.15]]), 'b': np.array([0.01, -0.02]),\n         'L': 0.5, 'h': 0.05, 'delta': 0.2, 'p': 0.1, 'x0': np.array([0.0, 0.0]), 'seed': 2},\n        # Case 3: Smaller horizon, larger perturbation\n        {'A': np.array([[0.1, 0.2], [-0.05, 0.15]]), 'b': np.array([0.01, -0.02]),\n         'L': 0.5, 'h': 0.05, 'delta': 0.12, 'p': 0.25, 'x0': np.array([0.0, 0.0]), 'seed': 3},\n        # Case 4: Different material parameters and discretization\n        {'A': np.array([[0.05, -0.3], [0.3, -0.02]]), 'b': np.array([0.03, 0.02]),\n         'L': 0.5, 'h': 0.04, 'delta': 0.18, 'p': 0.15, 'x0': np.array([0.0, 0.0]), 'seed': 4},\n        # Case 5: Different material parameters, off-center evaluation point\n        {'A': np.array([[0.12, 0.0], [0.0, -0.08]]), 'b': np.array([0.0, 0.0]),\n         'L': 0.4, 'h': 0.04, 'delta': 0.2, 'p': 0.05, 'x0': np.array([0.35, 0.0]), 'seed': 5},\n    ]\n\n    results = []\n    for params in test_cases:\n        error = calculate_error_for_case(params)\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_error_for_case(params):\n    \"\"\"\n    Calculates the relative Frobenius norm error for a single test case.\n    \"\"\"\n    # Unpack parameters\n    A = params['A']\n    b = params['b']\n    L = params['L']\n    h = params['h']\n    delta = params['delta']\n    p = params['p']\n    x0 = params['x0']\n    seed = params['seed']\n    \n    # Initialize a pseudo-random number generator with a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate the particle set\n    # Create the nominal square lattice, ensuring endpoints are included.\n    grid_coords = np.arange(-L, L + h / 2, h)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n    x_nominal = np.vstack([xx.ravel(), yy.ravel()]).T\n\n    # Add independent Gaussian perturbations to each coordinate.\n    perturbations = rng.normal(loc=0.0, scale=p * h, size=x_nominal.shape)\n    x_perturbed = x_nominal + perturbations\n    \n    # Each particle is assigned an equal volume V_p = h^2.\n    V_p = h**2\n\n    # 2. Identify neighbors of the evaluation point x0\n    neighbor_positions = []\n    for x_j in x_perturbed:\n        xi = x_j - x0\n        dist = np.linalg.norm(xi)\n        # Condition for neighbors: 0  ||xi|| = delta\n        if 0.0  dist = delta:\n            neighbor_positions.append(x_j)\n            \n    if not neighbor_positions:\n        return np.nan\n\n    neighbors = np.array(neighbor_positions)\n\n    # 3. Compute the discrete K (shape) and M (mixed) tensors.\n    K = np.zeros((2, 2))\n    M = np.zeros((2, 2))\n\n    # Define the affine motion for the evaluation point x0.\n    I = np.eye(2)\n    F_exact = I + A\n    y0 = F_exact @ x0 + b\n\n    # Gaussian weight kernel function.\n    def omega(r, delta_):\n        return np.exp(-(r / delta_)**2)\n\n    for x_j in neighbors:\n        # Relative position vector.\n        xi = x_j - x0\n        r = np.linalg.norm(xi)\n        w = omega(r, delta)\n\n        # Compute relative displacement vector eta.\n        y_j = F_exact @ x_j + b\n        eta = y_j - y0\n        \n        # Reshape for outer products.\n        xi_col = xi.reshape(2, 1)\n        eta_col = eta.reshape(2, 1)\n        \n        # Accumulate sums for K and M.\n        K += w * (xi_col @ xi_col.T) * V_p\n        M += w * (eta_col @ xi_col.T) * V_p\n        \n    # 4. Apply Tikhonov regularization and solve for the estimated deformation gradient F_hat.\n    # The regularization parameter lambda is chosen to be a small fraction of the\n    # average of the diagonal elements of K to ensure dimensional consistency and stability.\n    trace_K = np.trace(K)\n    epsilon_reg = 1e-9\n    lambda_reg = epsilon_reg * 0.5 * trace_K\n    \n    # Regularize the shape tensor K.\n    K_reg = K + lambda_reg * np.eye(2)\n    \n    # Solve for F_hat from F_hat * K_reg = M.\n    try:\n        F_hat = M @ np.linalg.inv(K_reg)\n    except np.linalg.LinAlgError:\n        # This is unlikely with regularization but is handled as a precaution.\n        return np.nan\n        \n    # 5. Compute the relative Frobenius norm error.\n    error = np.linalg.norm(F_hat - F_exact, 'fro') / np.linalg.norm(F_exact, 'fro')\n    \n    return error\n\n# Execute the solution process.\nsolve()\n\n```"
        }
    ]
}