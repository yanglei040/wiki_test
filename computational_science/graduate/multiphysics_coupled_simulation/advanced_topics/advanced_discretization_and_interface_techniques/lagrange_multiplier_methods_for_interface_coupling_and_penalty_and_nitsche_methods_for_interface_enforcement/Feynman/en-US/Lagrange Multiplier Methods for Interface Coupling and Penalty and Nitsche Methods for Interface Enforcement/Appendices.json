{
    "hands_on_practices": [
        {
            "introduction": "To begin our practical exploration, we will construct the fundamental algebraic system for interface coupling from first principles. This exercise uses a simple one-dimensional structural problem to demonstrate how a Lagrange multiplier enforces a kinematic constraint, leading to the formation of a Karush-Kuhn-Tucker (KKT) system. By deriving this system, you will gain a concrete understanding of the saddle-point structure inherent in constrained problems and the physical interpretation of the multiplier as an interface force. ",
            "id": "3512475",
            "problem": "Consider a one-dimensional axial two-bar system composed of two linearly elastic bars in series. The left bar occupies $x \\in [0,L_1]$ with constant axial stiffness $E_1A_1$, and the right bar occupies $x \\in [L_1,L_1+L_2]$ with constant axial stiffness $E_2A_2$. The left end at $x=0$ is fixed with $u(0)=0$, and the right end at $x=L_1+L_2$ carries a nodal load $p$ in the axial direction. Each bar is discretized by a single first-order Lagrange finite element ($P_1$), so that the left bar has nodal unknown $u_1^{-}$ at $x=L_1$ (its left end node at $x=0$ is prescribed and eliminated), and the right bar has nodal unknowns $u_1^{+}$ at $x=L_1$ and $u_R$ at $x=L_1+L_2$. To enforce kinematic continuity across the interface $x=L_1$ in a multiphysics coupled simulation, introduce a single Lagrange multiplier $\\lambda$ at the interface that enforces $u_1^{-}=u_1^{+}$.\n\nStarting from the principle of virtual work for axial elasticity and standard first-order finite element assembly (without prescribing or hinting any target formulas), derive the discrete Karush–Kuhn–Tucker (KKT) system, where the unknown vector is $(u_1^{-},\\,u_1^{+},\\,u_R,\\,\\lambda)^{\\top}$. Express the final KKT matrix symbolically in terms of $E_1$, $A_1$, $L_1$, $E_2$, $A_2$, and $L_2$. Identify the algebraic structure of the constraint row that enforces continuity and how it couples to the primal unknowns. Provide only the KKT matrix as your final answer. No rounding is required; express the answer exactly. The acronym KKT stands for Karush–Kuhn–Tucker, and $P_1$ denotes first-order Lagrange finite elements in the Finite Element Method (FEM).",
            "solution": "The problem requires the derivation of the Karush–Kuhn–Tucker (KKT) system for a two-bar assembly coupled at an interface using a Lagrange multiplier. The derivation begins from the principle of virtual work, which is equivalent to finding the stationary point of the total potential energy functional for a conservative system.\n\nThe total potential energy, $\\Pi$, of the system is the sum of the strain energy, $U$, stored in the two bars minus the potential, $W_{\\text{ext}}$, of the external load $p$.\n$$ \\Pi = U - W_{\\text{ext}} = U_1 + U_2 - W_{\\text{ext}} $$\nwhere $U_1$ and $U_2$ are the strain energies of bar $1$ and bar $2$, respectively.\n\nThe strain energy for a one-dimensional elastic bar is given by:\n$$ U = \\frac{1}{2} \\int_{0}^{L} EA \\left( \\frac{du}{dx} \\right)^2 dx $$\nwhere $E$ is the Young's modulus, $A$ is the cross-sectional area, $L$ is the length, and $u(x)$ is the axial displacement field.\n\nThe problem states that the kinematic continuity at the interface $x=L_1$ is enforced via a Lagrange multiplier $\\lambda$. The constraint equation is $g(u_1^{-}, u_1^{+}) = u_1^{-} - u_1^{+} = 0$. We form the Lagrangian functional $\\mathcal{L}$ by augmenting the total potential energy with the constraint term:\n$$ \\mathcal{L}(u, \\lambda) = \\Pi + \\lambda g = U_1 + U_2 - W_{\\text{ext}} + \\lambda(u_1^{-} - u_1^{+}) $$\nThe KKT conditions are found by setting the first variation of $\\mathcal{L}$ with respect to all degrees of freedom to zero.\n\nLet's discretize the system. Each bar is modeled by a single first-order ($P_1$) finite element.\n\nFor Bar 1, occupying $x \\in [0, L_1]$:\nThe displacement field is $u^{(1)}(x)$. The nodal displacements are $u(0)$ and $u_1^{-}$ at $x=L_1$. Given the fixed boundary condition $u(0)=0$, the displacement field is interpolated as:\n$$ u^{(1)}(x) = \\left(\\frac{x}{L_1}\\right) u_1^{-} $$\nThe axial strain is constant: $\\epsilon_1 = \\frac{d u^{(1)}}{dx} = \\frac{u_1^{-}}{L_1}$.\nThe strain energy in bar $1$ is:\n$$ U_1 = \\frac{1}{2} \\int_0^{L_1} E_1A_1 (\\epsilon_1)^2 dx = \\frac{1}{2} E_1A_1 \\left(\\frac{u_1^{-}}{L_1}\\right)^2 \\int_0^{L_1} dx = \\frac{1}{2} \\frac{E_1A_1}{L_1} (u_1^{-})^2 $$\n\nFor Bar 2, occupying $x \\in [L_1, L_1+L_2]$:\nIt is convenient to use a local coordinate $\\xi = x - L_1$, where $\\xi \\in [0, L_2]$. The nodal displacements are $u_1^{+}$ at $\\xi=0$ and $u_R$ at $\\xi=L_2$. The displacement field is interpolated as:\n$$ u^{(2)}(\\xi) = \\left(1 - \\frac{\\xi}{L_2}\\right) u_1^{+} + \\left(\\frac{\\xi}{L_2}\\right) u_R $$\nThe axial strain is constant: $\\epsilon_2 = \\frac{d u^{(2)}}{d\\xi} = \\frac{u_R - u_1^{+}}{L_2}$.\nThe strain energy in bar $2$ is:\n$$ U_2 = \\frac{1}{2} \\int_0^{L_2} E_2A_2 (\\epsilon_2)^2 d\\xi = \\frac{1}{2} E_2A_2 \\left(\\frac{u_R - u_1^{+}}{L_2}\\right)^2 \\int_0^{L_2} d\\xi = \\frac{1}{2} \\frac{E_2A_2}{L_2} (u_R - u_1^{+})^2 $$\nThis can be expanded as:\n$$ U_2 = \\frac{1}{2} \\frac{E_2A_2}{L_2} \\left((u_1^{+})^2 - 2u_1^{+}u_R + (u_R)^2\\right) $$\n\nThe work done by the external load $p$ applied at $x=L_1+L_2$ is:\n$$ W_{\\text{ext}} = p u_R $$\n\nNow, assemble the full Lagrangian functional in terms of the discrete unknowns $(u_1^{-}, u_1^{+}, u_R, \\lambda)$:\n$$ \\mathcal{L}(u_1^{-}, u_1^{+}, u_R, \\lambda) = \\frac{1}{2} \\frac{E_1A_1}{L_1} (u_1^{-})^2 + \\frac{1}{2} \\frac{E_2A_2}{L_2} (u_R - u_1^{+})^2 - p u_R + \\lambda(u_1^{-} - u_1^{+}) $$\n\nTo find the stationary point, we take the partial derivative of $\\mathcal{L}$ with respect to each unknown and set it to zero.\n1.  $\\frac{\\partial \\mathcal{L}}{\\partial u_1^{-}} = \\frac{E_1A_1}{L_1} u_1^{-} + \\lambda = 0$\n2.  $\\frac{\\partial \\mathcal{L}}{\\partial u_1^{+}} = \\frac{E_2A_2}{L_2}(u_1^{+} - u_R) - \\lambda = 0$\n3.  $\\frac{\\partial \\mathcal{L}}{\\partial u_R} = \\frac{E_2A_2}{L_2} (u_R - u_1^{+}) - p = -\\frac{E_2A_2}{L_2} u_1^{+} + \\frac{E_2A_2}{L_2} u_R - p = 0$\n4.  $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = u_1^{-} - u_1^{+} = 0$\n\nThese four linear equations form the KKT system. Let's write them in matrix form, $\\mathbf{K}_{\\text{KKT}} \\mathbf{d} = \\mathbf{f}$, where the vector of unknowns is $\\mathbf{d} = (u_1^{-}, u_1^{+}, u_R, \\lambda)^{\\top}$.\n\nFrom equation 1: $(\\frac{E_1A_1}{L_1}) u_1^{-} + (0) u_1^{+} + (0) u_R + (1) \\lambda = 0$\nFrom equation 2: $(0) u_1^{-} + (\\frac{E_2A_2}{L_2}) u_1^{+} - (\\frac{E_2A_2}{L_2}) u_R - (1) \\lambda = 0$\nFrom equation 3: $(0) u_1^{-} - (\\frac{E_2A_2}{L_2}) u_1^{+} + (\\frac{E_2A_2}{L_2}) u_R + (0) \\lambda = p$\nFrom equation 4: $(1) u_1^{-} - (1) u_1^{+} + (0) u_R + (0) \\lambda = 0$\n\nAssembling these into the KKT matrix system gives:\n$$\n\\begin{pmatrix}\n\\frac{E_1A_1}{L_1} & 0 & 0 & 1 \\\\\n0 & \\frac{E_2A_2}{L_2} & -\\frac{E_2A_2}{L_2} & -1 \\\\\n0 & -\\frac{E_2A_2}{L_2} & \\frac{E_2A_2}{L_2} & 0 \\\\\n1 & -1 & 0 & 0\n\\end{pmatrix}\n\\begin{pmatrix}\nu_1^{-} \\\\\nu_1^{+} \\\\\nu_R \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\np \\\\\n0\n\\end{pmatrix}\n$$\nThe matrix on the left is the KKT matrix. It has the characteristic symmetric saddle-point structure of a constrained optimization problem. The upper-left $3 \\times 3$ block is the stiffness matrix $\\mathbf{K}$ of the uncoupled primal system, which is block-diagonal as the two bars are not yet connected. The last row and column, often denoted $\\mathbf{B}$ and $\\mathbf{B}^\\top$, represent the coupling constraint.\n\nThe question asks for the algebraic structure of the constraint row. The fourth row, $(1, -1, 0, 0)$, directly represents the discrete constraint equation $u_1^{-} - u_1^{+} = 0$. Its non-zero entries $(1, -1)$ couple the primal unknowns $u_1^{-}$ and $u_1^{+}$ at the interface. The fourth column, $(1, -1, 0, 0)^\\top$, shows how the Lagrange multiplier $\\lambda$ acts as a force on the primal degrees of freedom: it applies a force $+\\lambda$ to the $u_1^{-}$ degree of freedom and an equal and opposite force $-\\lambda$ to the $u_1^{+}$ degree of freedom, which is the physical interpretation of the contact force enforcing continuity.\n\nThe final KKT matrix is thus derived.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{E_1A_1}{L_1} & 0 & 0 & 1 \\\\ 0 & \\frac{E_2A_2}{L_2} & -\\frac{E_2A_2}{L_2} & -1 \\\\ 0 & -\\frac{E_2A_2}{L_2} & \\frac{E_2A_2}{L_2} & 0 \\\\ 1 & -1 & 0 & 0 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Real-world simulations often involve coupling subdomains with non-matching meshes, for which simple point-wise constraints are insufficient. This practice introduces the more general and powerful mortar method, where continuity is enforced in a weak, integral sense. You will derive the mortar coupling matrix that links degrees of freedom across a non-conforming interface and perform the necessary integrations, providing essential skills for implementing advanced finite element coupling strategies. ",
            "id": "3512513",
            "problem": "Consider a two-domain multiphysics coupling posed on a straight, flat interface $\\Gamma$ of length $1$, parameterized by the coordinate $s \\in [0,1]$. The primal trace on the master side is approximated by a continuous, piecewise-linear finite element space with the master interface mesh consisting of one element over $[0,1]$. The corresponding master trace basis functions are the standard linear shape functions $\\phi_{1}(s)=1-s$ and $\\phi_{2}(s)=s$ on $[0,1]$. The Lagrange Multiplier (LM) space on the slave side is chosen as piecewise constants (one per element) on a nonmatching slave partition of the interface given by the two elements $[0,0.5]$ and $[0.5,1]$. Denote the two slave LM basis functions by $\\psi_{1}(s)=1$ on $[0,0.5]$ and $\\psi_{2}(s)=1$ on $[0.5,1]$, and zero elsewhere. Assume unit Jacobian along $\\Gamma$ and consistent orientation.\n\nStarting from the weak enforcement of interface continuity by Lagrange multipliers, derive from first principles the algebraic form of the mortar coupling block that links the master trace unknowns to the slave LM unknowns. Your derivation must begin with the standard variational interface term that enforces the primal continuity via LM test functions, specialize it to the given discrete spaces, and identify the elementwise assembly rule that integrates slave basis functions against master traces over the geometric intersections of the nonmatching meshes. State clearly how intersections enter the assembly at the discrete level and why this assembly is consistent with the underlying variational principle.\n\nThen, for the specific meshes and basis functions given above, compute all entries of the resulting $2 \\times 2$ coupling matrix by carrying out the necessary integrals exactly.\n\nFinally, explain the geometric operations required to form intersection quadrature robustly when the interface meshes are nonmatching in general (for example, in two spatial dimensions where $\\Gamma$ is a polygonal curve). Your discussion should specify how to: \n- detect and parameterize intersections of slave and master interface elements,\n- construct a robust integration partition,\n- handle floating-point tolerance and degeneracy in a way that preserves consistency and avoids measure-theoretic pathologies.\n\nYour final reported result must be the coupling matrix entries in row-major order collected into a single row matrix. No rounding is required; give exact values.",
            "solution": "The problem is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n-   **Interface**: $\\Gamma$ is a straight, flat interface of length $1$, parameterized by $s \\in [0,1]$.\n-   **Master Trace Space**: Continuous, piecewise-linear finite element space on a single master element over $[0,1]$.\n-   **Master Basis Functions**: $\\phi_{1}(s) = 1-s$ and $\\phi_{2}(s) = s$ for $s \\in [0,1]$.\n-   **Slave Lagrange Multiplier (LM) Space**: Piecewise constant functions on a non-matching slave partition.\n-   **Slave Partition**: Two elements, $[0,0.5]$ and $[0.5,1]$.\n-   **Slave LM Basis Functions**:\n    -   $\\psi_{1}(s) = 1$ for $s \\in [0,0.5]$ and $0$ elsewhere.\n    -   $\\psi_{2}(s) = 1$ for $s \\in [0.5,1]$ and $0$ elsewhere.\n-   **Assumptions**: Unit Jacobian along $\\Gamma$, consistent orientation.\n-   **Tasks**:\n    1.  Derive the algebraic form of the mortar coupling block.\n    2.  Compute the $2 \\times 2$ coupling matrix for the given spaces.\n    3.  Explain the general geometric operations for robust intersection quadrature.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem is a standard, well-established topic in computational mechanics and numerical analysis, specifically within the finite element method (FEM) and domain decomposition methods. The use of Lagrange multipliers to enforce interface constraints (as in mortar methods) is a fundamental and widely studied technique.\n-   **Well-Posed**: The problem is precisely formulated. The domain, meshes, and basis functions for both master and slave sides are explicitly defined. The tasks are specific and lead to a unique, well-defined mathematical object (the coupling matrix) and a conceptual explanation of a standard algorithm.\n-   **Objective**: The language is technical, precise, and free from any subjectivity or ambiguity.\n\nThe problem is free of any scientific or factual unsoundness, is formalizable and relevant to the stated topic, possesses a complete and consistent setup, is entirely realistic within the context of numerical simulation, is well-posed, and is a substantive educational problem rather than a trivial one.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Part 1: Derivation of the Mortar Coupling Block\n\nThe enforcement of primal field continuity, $u_m = u_s$ on the interface $\\Gamma$, where $u_m$ is the master trace and $u_s$ is the slave trace, can be formulated weakly using a Lagrange multiplier field $\\lambda$. The Lagrange multiplier resides in a test space, which is typically defined on the slave mesh. The standard variational form for this constraint is to find $u_m$, $u_s$, and $\\lambda$ such that:\n$$\n\\int_{\\Gamma} (u_m - u_s) \\mu \\, d\\Gamma = 0\n$$\nfor all test functions $\\mu$ in the Lagrange multiplier space. In many mortar finite element formulations, this equation is part of a larger coupled system. The term that links the master trace unknowns to the slave LM unknowns arises directly from this weak statement.\n\nUpon discretization, the fields are represented as linear combinations of basis functions. The master trace field $u_{m,h}$ and the Lagrange multiplier field $\\lambda_h$ are approximated as:\n$$\nu_{m,h}(s) = \\sum_{j=1}^{N_m} U_j \\phi_j(s)\n$$\n$$\n\\lambda_h(s) = \\sum_{i=1}^{N_s} \\Lambda_i \\psi_i(s)\n$$\nHere, $u_{m,h}$ is the approximation in the master trace space spanned by basis functions $\\{\\phi_j\\}_{j=1}^{N_m}$ with $N_m$ nodal degrees of freedom $U_j$. The Lagrange multiplier $\\lambda_h$ is in the slave space spanned by basis functions $\\{\\psi_i\\}_{i=1}^{N_s}$ with $N_s$ coefficients $\\Lambda_i$. The test functions $\\mu$ are taken to be the basis functions $\\psi_i$ of the slave LM space (a Bubnov-Galerkin approach).\n\nThe term in the weak form involving the master trace $u_{m,h}$ is $\\int_{\\Gamma} u_{m,h} \\psi_i \\, d\\Gamma$. Substituting the expansion for $u_{m,h}$, the $i$-th equation in the set of constraint equations becomes:\n$$\n\\int_{\\Gamma} \\left( \\sum_{j=1}^{N_m} U_j \\phi_j(s) \\right) \\psi_i(s) \\, ds - \\int_{\\Gamma} u_{s,h}(s) \\psi_i(s) \\, ds = 0\n$$\nExtracting the part that couples the master unknowns $U_j$ to the $i$-th LM equation gives:\n$$\n\\sum_{j=1}^{N_m} \\left( \\int_{\\Gamma} \\psi_i(s) \\phi_j(s) \\, ds \\right) U_j\n$$\nThis defines the entries of the mortar coupling matrix, which we denote by $C$. The entry $C_{ij}$ is the coupling coefficient between the $i$-th Lagrange multiplier degree of freedom and the $j$-th master trace degree of freedom.\n$$\nC_{ij} = \\int_{\\Gamma} \\psi_i(s) \\phi_j(s) \\, ds\n$$\nThe algebraic form of the coupling block is therefore a matrix $C$ of size $N_s \\times N_m$.\n\nThe assembly of this matrix requires integrating products of basis functions from two different, non-matching meshes. The support of a master basis function $\\phi_j$ is a master element (or a patch of them), denoted $e_m$. The support of a slave basis function $\\psi_i$ is a slave element $e_s$. The integral for $C_{ij}$ is non-zero only where the supports of $\\phi_j$ and $\\psi_i$ overlap. The integral must be computed over the geometric intersection of the supports. This is the core principle of mortar methods: integration is performed over a computational mesh a posteriori constructed from the intersections of the primary meshes.\nThe global integral is decomposed as a sum of integrals over these intersection domains:\n$$\nC_{ij} = \\int_{\\Gamma} \\psi_i(s) \\phi_j(s) \\, ds = \\sum_{e_s \\in \\text{supp}(\\psi_i)} \\sum_{e_m \\in \\text{supp}(\\phi_j)} \\int_{e_s \\cap e_m} \\psi_i(s)|_{e_s} \\, \\phi_j(s)|_{e_m} \\, ds\n$$\nThis elementwise assembly over intersections is consistent with the underlying variational principle because integration is a linear operator, and the set of all unique intersection domains $\\{e_s \\cap e_m\\}$ forms a valid partition of the interface $\\Gamma$. Summing the integrals over the parts recovers the integral over the whole.\n\n### Part 2: Computation of the Coupling Matrix\n\nFor the given problem, the number of master basis functions is $N_m=2$ and the number of slave basis functions is $N_s=2$. We need to compute the $2 \\times 2$ matrix $C$ with entries $C_{ij} = \\int_{0}^{1} \\psi_i(s) \\phi_j(s) \\, ds$.\n\nThe master basis functions are $\\phi_1(s) = 1-s$ and $\\phi_2(s) = s$ on $[0,1]$.\nThe slave basis functions are $\\psi_1(s) = 1$ on $[0,0.5]$ and $\\psi_2(s) = 1$ on $[0.5,1]$.\n\n**Entry $C_{11}$**: $i=1, j=1$\nThe integral is over the support of $\\psi_1(s)$, which is the interval $[0,0.5]$.\n$$\nC_{11} = \\int_{0}^{1} \\psi_1(s) \\phi_1(s) \\, ds = \\int_{0}^{0.5} (1) \\cdot (1-s) \\, ds = \\left[ s - \\frac{s^2}{2} \\right]_{0}^{0.5} = \\left(0.5 - \\frac{0.5^2}{2}\\right) - 0 = \\frac{1}{2} - \\frac{(1/2)^2}{2} = \\frac{1}{2} - \\frac{1/4}{2} = \\frac{1}{2} - \\frac{1}{8} = \\frac{3}{8}\n$$\n\n**Entry $C_{12}$**: $i=1, j=2$\nThe integral is over the support of $\\psi_1(s)$, which is the interval $[0,0.5]$.\n$$\nC_{12} = \\int_{0}^{1} \\psi_1(s) \\phi_2(s) \\, ds = \\int_{0}^{0.5} (1) \\cdot (s) \\, ds = \\left[ \\frac{s^2}{2} \\right]_{0}^{0.5} = \\frac{0.5^2}{2} - 0 = \\frac{(1/2)^2}{2} = \\frac{1/4}{2} = \\frac{1}{8}\n$$\n\n**Entry $C_{21}$**: $i=2, j=1$\nThe integral is over the support of $\\psi_2(s)$, which is the interval $[0.5,1]$.\n$$\nC_{21} = \\int_{0}^{1} \\psi_2(s) \\phi_1(s) \\, ds = \\int_{0.5}^{1} (1) \\cdot (1-s) \\, ds = \\left[ s - \\frac{s^2}{2} \\right]_{0.5}^{1} = \\left(1 - \\frac{1^2}{2}\\right) - \\left(0.5 - \\frac{0.5^2}{2}\\right) = \\frac{1}{2} - \\left(\\frac{1}{2} - \\frac{1}{8}\\right) = \\frac{1}{8}\n$$\n\n**Entry $C_{22}$**: $i=2, j=2$\nThe integral is over the support of $\\psi_2(s)$, which is the interval $[0.5,1]$.\n$$\nC_{22} = \\int_{0}^{1} \\psi_2(s) \\phi_2(s) \\, ds = \\int_{0.5}^{1} (1) \\cdot (s) \\, ds = \\left[ \\frac{s^2}{2} \\right]_{0.5}^{1} = \\frac{1^2}{2} - \\frac{0.5^2}{2} = \\frac{1}{2} - \\frac{(1/2)^2}{2} = \\frac{1}{2} - \\frac{1}{8} = \\frac{3}{8}\n$$\n\nThe resulting $2 \\times 2$ coupling matrix is:\n$$\nC = \\begin{pmatrix}\n\\frac{3}{8} & \\frac{1}{8} \\\\\n\\frac{1}{8} & \\frac{3}{8}\n\\end{pmatrix}\n$$\n\n### Part 3: General Geometric Operations for Robust Intersection Quadrature\n\nFor a general case where the interface $\\Gamma$ is a polygonal curve in two or three spatial dimensions, forming the mortar integrals requires a robust geometric algorithm to handle the non-matching discretizations. The interface is composed of master elements $\\{e_{m,k}\\}$ (e.g., line segments) and slave elements $\\{e_{s,l}\\}$. The process can be broken down as follows:\n\n1.  **Detect and Parameterize Intersections**: The core task is to compute the geometric intersection of each slave element $e_s$ with all master elements $e_m$. This is a clipping operation. For a polygonal curve in $\\mathbb{R}^2$, where elements are line segments, this involves segment-segment intersection tests. More generally, for surface meshes in $\\mathbb{R}^3$, this is a polygon-polygon clipping problem (e.g., using the Sutherland-Hodgman or Weiler-Atherton algorithms). The algorithm typically loops over each slave element $e_s$ and determines the set of polyhedral/polygonal domains $\\{I_k\\}$ that result from clipping $e_s$ against the set of all master elements $\\{e_{m,k}\\}$. Each resulting piece $I_k$ is the intersection of $e_s$ with a specific master element $e_m$. The output is a list of intersection domains, each associated with its parent master and slave elements.\n\n2.  **Construct a Robust Integration Partition**: The collection of intersection domains $\\{e_s \\cap e_m\\}$ for a fixed slave element $e_s$ forms a partition of $e_s$. That is, $\\cup_m (e_s \\cap e_m) = e_s$, and the interiors of the intersection pieces are disjoint. This partitioning of the slave element is the basis for numerical integration. A standard quadrature rule (e.g., Gauss-Legendre for segments, Gauss-Jacobi for triangles/quads) is applied to each intersection piece $I_k$. This requires establishing a mapping from a reference integration element (e.g., the interval $[-1,1]$, the reference triangle) to the physical intersection domain $I_k$. The coordinates of the quadrature points in the physical space are then used to evaluate the master and slave basis functions. The final integral over $e_s$ is the sum of the weighted integrals over each piece $I_k$.\n\n3.  **Handle Floating-Point Tolerance and Degeneracy**: This is critical for robustness.\n    -   **Tolerance**: Geometric predicates (e.g., is a point inside a polygon?) must not rely on exact floating-point comparisons. Instead, comparisons are made within a tolerance $\\epsilon$, e.g., $|x| < \\epsilon$. This tolerance must be chosen carefully, relative to the geometric dimensions and machine precision, to avoid false-positive or false-negative results.\n    -   **Consistency**: The main challenge is to ensure that all geometric decisions are mutually consistent. For instance, if a vertex is determined to be on an edge, it must be treated as such in all subsequent calculations. Inconsistent decisions can lead to gaps or overlaps in the integration partition, violating conservation principles. This can be addressed by using robust geometric predicates, which often employ adaptive-precision arithmetic to guarantee the correct sign of geometric determinants (e.g., orientation tests).\n    -   **Degeneracy and Measure-Theoretic Pathologies**: Degenerate cases include intersections of zero measure, such as two segments touching at a point or two polygons sharing an edge. A robust clipping algorithm must correctly identify these cases. An intersection domain with a measure (length, area) smaller than a certain tolerance should be considered degenerate and contribute zero to the integral. This prevents numerical issues and correctly reflects the measure-theoretic principle that an integral over a set of measure zero is zero. The overall goal is to ensure the integration partition is \"watertight\": the sum of the measures of the intersection pieces must equal the measure of the original slave element, to within the working precision. This property is fundamental to the consistency and stability of the mortar method.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{3}{8} & \\frac{1}{8} & \\frac{1}{8} & \\frac{3}{8} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "The ultimate test of understanding a numerical method is to implement it and verify its behavior. This comprehensive programming exercise challenges you to implement and compare the three central techniques discussed—the Lagrange multiplier, penalty, and Nitsche's methods—for a benchmark diffusion problem. By designing a computational experiment that isolates interface error and measures convergence rates, you will develop a deep, practical insight into the accuracy, stability, and trade-offs of each approach. ",
            "id": "3512524",
            "problem": "Consider the one-dimensional, steady diffusion problem on the domain $[-1,1]$ with an internal interface at $x=0$. Let $a(x)$ be piecewise constant, with $a(x)=a_L$ for $x\\in[-1,0]$ and $a(x)=a_R$ for $x\\in[0,1]$. The governing partial differential equation and weak form are based on conservation and constitutive laws: the flux $q(x)$ satisfies $q(x)=-a(x)u'(x)$, and conservation implies $-q'(x)=f(x)$, where $u(x)$ is the potential and $f(x)$ is a source. We take $f(x)=1$ on $[-1,1]$, and homogeneous Dirichlet boundary conditions $u(-1)=0$ and $u(1)=0$. The interface conditions at $x=0$ are continuity of the potential and flux, namely $u(0^-)=u(0^+)$ and $a_L u'(0^-)=a_R u'(0^+)$.\n\nStarting from these fundamental laws and definitions, derive and implement three numerical interface coupling strategies in a single discretization framework using continuous piecewise-linear basis functions on non-overlapping meshes of the left and right subdomains with duplicated degrees of freedom at the interface:\n- Lagrange multiplier method (LM): introduce an auxiliary unknown $\\lambda$ to enforce the constraint $u_L(0)-u_R(0)=0$ in the weak sense, augmenting the bilinear form by $\\langle \\lambda, u_L(0)-u_R(0)\\rangle$ and the constraint equation by $\\langle \\mu, u_L(0)-u_R(0)\\rangle=0$ for any test multiplier $\\mu$.\n- Penalty method: augment the bilinear form with a symmetric penalty term $\\dfrac{\\alpha}{h_\\Gamma}\\left(u_L(0)-u_R(0)\\right)\\left(v_L(0)-v_R(0)\\right)$, where $\\alpha>0$ is the penalty parameter and $h_\\Gamma$ is a characteristic mesh size at the interface.\n- Symmetric Nitsche method: augment the bilinear form with consistent and stabilizing interface terms,\n$$\n-\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma \\left[v\\right]_\\Gamma\n-\\left\\{\\! a\\,v' \\cdot n \\!\\right\\}_\\Gamma \\left[u\\right]_\\Gamma\n+\\dfrac{\\gamma}{h_\\Gamma}\\left[u\\right]_\\Gamma \\left[v\\right]_\\Gamma,\n$$\nwhere $\\left[u\\right]_\\Gamma=u_L(0)-u_R(0)$ and $\\left[v\\right]_\\Gamma=v_L(0)-v_R(0)$ denote jumps, $n$ is the outward normal on each side ($n_L=+1$ at $x=0^-$, $n_R=-1$ at $x=0^+$), and $\\left\\{\\! a\\,w' \\cdot n \\!\\right\\}_\\Gamma=\\dfrac{1}{2}\\left(a_L w_L'(0)\\,n_L + a_R w_R'(0)\\,n_R\\right)$ denotes the average normal flux.\n\nTo isolate interface error from bulk error, construct meshes that are refined only in a neighborhood of the interface. For a given refinement radius $r\\in(0,1)$, define the left mesh as the union of a coarse partition of $[-1,-r]$ into $m_{\\mathrm{bulk}}$ equal elements and a refined partition of $[-r,0]$ into $n_{\\mathrm{iface}}$ equal elements. Similarly define the right mesh as the union of a refined partition $[0,r]$ into $n_{\\mathrm{iface}}$ equal elements and a coarse partition $[r,1]$ into $m_{\\mathrm{bulk}}$ equal elements. The interface node at $x=0$ is duplicated, yielding distinct degrees of freedom $u_L(0)$ and $u_R(0)$. Use continuous piecewise-linear finite elements on each subdomain with the duplicated interface node, and enforce the boundary conditions $u(-1)=0$ and $u(1)=0$ strongly.\n\nLet $u_{\\mathrm{exact}}(x)$ be the exact solution obtained by solving the ordinary differential equations $-a_L u_L''(x)=1$ on $[-1,0]$ and $-a_R u_R''(x)=1$ on $[0,1]$ with the stated boundary and interface conditions. This yields piecewise quadratic expressions\n$$\nu_L(x)=-\\dfrac{x^2}{2 a_L} + c_1 x + c_2,\\quad x\\in[-1,0],\\qquad\nu_R(x)=-\\dfrac{x^2}{2 a_R} + d_1 x + d_2,\\quad x\\in[0,1],\n$$\nwith constants $c_1,c_2,d_1,d_2$ determined by $u_L(-1)=0$, $u_R(1)=0$, $u_L(0)=u_R(0)$, and $a_L u_L'(0)=a_R u_R'(0)$.\n\nDefine the characteristic interface size $h_\\Gamma$ as the average of the adjacent element sizes at $x=0$ from the left and right meshes. For each coupling method, solve the discrete system and compute the following two error measures:\n- Interface-neighborhood error: the $L^2$ norm of the error $\\|u_h-u_{\\mathrm{exact}}\\|_{L^2([-r,r])}$.\n- Bulk error: the $L^2$ norm of the error $\\|u_h-u_{\\mathrm{exact}}\\|_{L^2([-1,-r]\\cup[r,1])}$.\n\nFor convergence-rate estimation, consider three refinement levels $n_{\\mathrm{iface}}\\in\\{10,20,40\\}$ with fixed $m_{\\mathrm{bulk}}=4$. For each refinement level, compute the interface-neighborhood and bulk errors for all three methods under identical meshes. Estimate the convergence rate $p$ for each error category and method as the slope in the log-log relation $\\log(\\mathrm{error})=\\mathrm{const}+p\\,\\log(h_\\Gamma)$ using linear regression over the three levels.\n\nYour program must implement the above procedure and produce rates for the following test suite of parameter sets:\n- Test case $1$: $(a_L,a_R,\\alpha,\\gamma,r)=(1.0,10.0,10.0,10.0,0.3)$.\n- Test case $2$: $(a_L,a_R,\\alpha,\\gamma,r)=(1.0,1.0,1.0,1.0,0.2)$.\n- Test case $3$: $(a_L,a_R,\\alpha,\\gamma,r)=(0.1,100.0,100.0,50.0,0.1)$.\n\nIn all cases, express rates as real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a nested list of two lists: the first list contains the three interface-neighborhood convergence rates $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$, and the second list contains the three bulk convergence rates $[p_{\\mathrm{penalty}},p_{\\mathrm{Nitsche}},p_{\\mathrm{LM}}]$. For example, the overall output format across the three test cases is\n$[[p^{(1)}_{\\mathrm{iface,pen}},p^{(1)}_{\\mathrm{iface,Nitsche}},p^{(1)}_{\\mathrm{iface,LM}],[p^{(1)}_{\\mathrm{bulk,pen}},p^{(1)}_{\\mathrm{bulk,Nitsche}},p^{(1)}_{\\mathrm{bulk,LM}]],\\dots]$ with three such pairs corresponding to the three test cases.",
            "solution": "The derivation begins from the conservation and constitutive relations for steady diffusion. The physical flux is $q(x)=-a(x)u'(x)$, and conservation demands $-q'(x)=f(x)$, with $f(x)=1$. Combining these yields the strong form\n$$\n-(a(x)u'(x))'=1\\quad \\text{in }(-1,0)\\cup(0,1),\n$$\nwith interface conditions $u(0^-)=u(0^+)$ and $a_L u'(0^-)=a_R u'(0^+)$. The weak form follows by multiplying by a test function $v$ with $v(-1)=0$ and $v(1)=0$ and integrating by parts on each subdomain:\n$$\n\\int_{-1}^{0} a_L u'(x) v'(x)\\,dx + \\int_{0}^{1} a_R u'(x) v'(x)\\,dx = \\int_{-1}^{1} v(x)\\,dx.\n$$\nThis identity assumes continuity at the interface; with duplicated interface degrees of freedom for $u_L(0)$ and $u_R(0)$, we must enforce continuity via a coupling method.\n\nThe exact solution is computed by solving the ordinary differential equations piecewise with interface and boundary conditions. On $[-1,0]$, $-a_L u_L''=1$ implies $u_L''=-1/a_L$, hence\n$$\nu_L(x)=-\\frac{x^2}{2 a_L} + c_1 x + c_2.\n$$\nSimilarly on $[0,1]$, $u_R(x)=-\\frac{x^2}{2 a_R} + d_1 x + d_2$. The boundary conditions $u_L(-1)=0$ and $u_R(1)=0$ yield $-1/(2 a_L) - c_1 + c_2=0$ and $-1/(2 a_R) + d_1 + d_2=0$. Continuity $u_L(0)=u_R(0)$ gives $c_2=d_2$, and flux continuity $a_L u_L'(0)=a_R u_R'(0)$ implies $a_L c_1 = a_R d_1$. Solving these equations yields\n$$\nc_1 = \\frac{1}{2}\\frac{a_L - a_R}{a_L(a_L + a_R)},\\quad d_1=\\frac{1}{2}\\frac{a_L - a_R}{a_R(a_L + a_R)},\\quad c_2 = \\frac{1}{2 a_L} + c_1,\\quad d_2=c_2.\n$$\n\nFor spatial discretization, we use continuous piecewise-linear finite elements on each subdomain with duplicated interface nodes. Let the left mesh be the union of a coarse uniform partition of $[-1,-r]$ into $m_{\\mathrm{bulk}}$ elements and a refined uniform partition of $[-r,0]$ into $n_{\\mathrm{iface}}$ elements. The right mesh is similarly defined as a refined partition of $[0,r]$ into $n_{\\mathrm{iface}}$ elements and a coarse partition of $[r,1]$ into $m_{\\mathrm{bulk}}$ elements. The degrees of freedom are the nodal values of $u$ on each subdomain, with the interface node duplicated ($u_L(0)$ and $u_R(0)$). The left boundary value $u(-1)=0$ and right boundary value $u(1)=0$ are enforced strongly by excluding those nodes from the unknown vector.\n\nAssembly on each subdomain uses the standard bilinear form $\\int a\\,u'v'\\,dx$, which for piecewise-linear elements on an interval $[x_i,x_{i+1}]$ yields local stiffness $k_e=\\frac{a}{h}\\begin{bmatrix}1 & -1\\\\ -1 & 1\\end{bmatrix}$ with $h=x_{i+1}-x_i$. The load vector for constant source $f=1$ yields $f_e=\\frac{h}{2}\\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$. Assembling these over elements gives block-diagonal stiffness matrices $K_L$ and $K_R$ and load vectors $F_L$ and $F_R$. The global stiffness $K$ and load $F$ for the uncoupled system are block diagonal with $K=\\mathrm{diag}(K_L,K_R)$ and $F=[F_L;F_R]$.\n\nInterface enforcement differs by method:\n- Lagrange multiplier method (LM): Introduce an auxiliary unknown $\\lambda$ enforcing $u_L(0)-u_R(0)=0$. The discrete saddle-point system is\n$$\n\\begin{bmatrix}\nK & B^\\top\\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\nU\\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nF\\\\ 0\n\\end{bmatrix},\n$$\nwhere $U$ collects all subdomain degrees of freedom, and $B$ is a row-vector selecting the interface jump: $B U = u_L(0)-u_R(0)$, i.e., $B$ has $+1$ in the left-interface position and $-1$ in the right-interface position and zeros elsewhere. The $B^\\top$ coupling adds $\\lambda$ to the left-interface equation and $-\\lambda$ to the right-interface equation, which are interpreted as interface forces balancing the constraint.\n\n- Penalty method: Augment $K$ by a symmetric rank-two interface penalty\n$$\nK \\leftarrow K + \\frac{\\alpha}{h_\\Gamma}\n\\begin{bmatrix}\n\\phantom{-}1 & -1\\\\\n-1 & \\phantom{-}1\n\\end{bmatrix}\n$$\non the $2\\times 2$ block spanning $(u_L(0),u_R(0))$. Here $h_\\Gamma$ is the characteristic interface size, taken as the average of the last left element length and the first right element length.\n\n- Symmetric Nitsche method: Add two consistent interface terms and one stabilizing term. Using outward normals $n_L=+1$ and $n_R=-1$ at $x=0$, the average normal flux is\n$$\n\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma = \\frac{1}{2}\\left(a_L\\,\\frac{u_L(0)-u_L(x^-)}{h_L} - a_R\\,\\frac{u_R(x^+)-u_R(0)}{h_R}\\right),\n$$\nwhere $h_L$ is the last left element size and $h_R$ is the first right element size, and $x^-$ and $x^+$ denote the left node adjacent to $0$ and the right node adjacent to $0$, respectively. Denote the vector of the four degrees of freedom adjacent to the interface as $\\left[u_L(x^-),u_L(0),u_R(0),u_R(x^+)\\right]$. The consistent bilinear form contributions are\n$$\n-\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma \\left[v\\right]_\\Gamma - \\left\\{\\! a\\,v' \\cdot n \\!\\right\\}_\\Gamma \\left[u\\right]_\\Gamma.\n$$\nIn discrete form, these can be represented by a $4\\times 4$ matrix assembled from the gradient of the average flux with respect to the four adjacent degrees of freedom. Define the gradient vector\n$$\ng=\\left[ -\\frac{1}{2}\\frac{a_L}{h_L}, \\;\\frac{1}{2}\\frac{a_L}{h_L},\\;\\frac{1}{2}\\frac{a_R}{h_R},\\; -\\frac{1}{2}\\frac{a_R}{h_R}\\right],\n$$\nwhich corresponds to $\\partial\\left\\{\\! a\\,u' \\cdot n \\!\\right\\}_\\Gamma/\\partial [u_L(x^-),u_L(0),u_R(0),u_R(x^+)]$. Then the consistent matrix is the sum of two parts: $M_1$, which maps the trial gradient to the test jump, and $M_2$, which maps the test gradient to the trial jump. Concretely, if rows are ordered as $[u_L(x^-),u_L(0),u_R(0),u_R(x^+)]$, then $M_1$ has nonzero rows only at the jump test degrees $u_L(0)$ and $u_R(0)$, with $M_1[\\text{row }u_L(0),:]=-g$ and $M_1[\\text{row }u_R(0),:]=+g$. The adjoint consistent part $M_2$ has nonzero columns only at the jump trial degrees $u_L(0)$ and $u_R(0)$, with $M_2[:,\\text{col }u_L(0)]=-g$ and $M_2[:,\\text{col }u_R(0)]=+g$. The symmetric consistent contribution is $M_{\\mathrm{cons}}=M_1+M_2$. The stabilizing term adds $(\\gamma/h_\\Gamma)\\left[u\\right]_\\Gamma\\left[v\\right]_\\Gamma$, which contributes a $2\\times 2$ block on $(u_L(0),u_R(0))$ equal to $(\\gamma/h_\\Gamma)\\begin{bmatrix}1&-1\\\\-1&1\\end{bmatrix}$.\n\nWith these discrete operators defined, the algorithm proceeds as follows. A Python implementation is provided below.\n- For each test case $(a_L,a_R,\\alpha,\\gamma,r)$, and for each refinement level $n_{\\mathrm{iface}}\\in\\{10,20,40\\}$ with fixed $m_{\\mathrm{bulk}}=4$, build the left and right meshes per the definition. Assemble $K_L,F_L$ and $K_R,F_R$, form $K=\\mathrm{diag}(K_L,K_R)$ and $F=[F_L;F_R]$.\n- Identify the indices of the interface-adjacent degrees of freedom $u_L(x^-)$, $u_L(0)$, $u_R(0)$, and $u_R(x^+)$, and compute $h_L$, $h_R$, and $h_\\Gamma=\\frac{1}{2}(h_L+h_R)$.\n- For penalty: add $(\\alpha/h_\\Gamma)\\begin{bmatrix}1&-1\\\\-1&1\\end{bmatrix}$ on $(u_L(0),u_R(0))$ and solve $K U=F$.\n- For symmetric Nitsche: add $M_{\\mathrm{cons}}$ on the $4\\times 4$ block for the interface-adjacent degrees and $(\\gamma/h_\\Gamma)\\begin{bmatrix}1&-1\\\\-1&1\\end{bmatrix}$ on $(u_L(0),u_R(0))$, then solve $K U=F$.\n- For Lagrange multiplier: augment by one unknown and solve the saddle-point system $\\begin{bmatrix}K&B^\\top\\\\B&0\\end{bmatrix}\\begin{bmatrix}U\\\\\\lambda\\end{bmatrix}=\\begin{bmatrix}F\\\\0\\end{bmatrix}$.\n\nAfter solving, reconstruct the nodal values including the boundary nodes ($u(-1)=0$ on the left and $u(1)=0$ on the right). Compute $L^2$ errors via numerical quadrature (for example, Gauss-Legendre quadrature) on each element separately, accumulating the interface-neighborhood error over $[-r,r]$ and the bulk error over $[-1,-r]\\cup[r,1]$. For each method and test case, collect the errors at the three refinement levels and compute the convergence rate $p$ by linear regression of $\\log(\\mathrm{error})$ against $\\log(h_\\Gamma)$. The linear regression slope provides an estimate of the convergence order such that $\\mathrm{error}\\approx C h_\\Gamma^p$.\n\n```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef build_mesh_left(r, n_iface, m_bulk):\n    # Left mesh: [-1, -r] coarse, [-r, 0] refined\n    left_bulk = np.linspace(-1.0, -r, m_bulk + 1)\n    left_iface = np.linspace(-r, 0.0, n_iface + 1)\n    # Concatenate, avoiding duplicate -r\n    nodes = np.concatenate([left_bulk[:-1], left_iface])\n    return nodes\n\ndef build_mesh_right(r, n_iface, m_bulk):\n    # Right mesh: [0, r] refined, [r, 1] coarse\n    right_iface = np.linspace(0.0, r, n_iface + 1)\n    right_bulk = np.linspace(r, 1.0, m_bulk + 1)\n    # Concatenate, avoiding duplicate r\n    nodes = np.concatenate([right_iface, right_bulk[1:]])\n    return nodes\n\ndef assemble_subdomain(nodes, a, is_left_boundary):\n    # Assemble K and F for piecewise linear FEM with Dirichlet at boundary.\n    # is_left_boundary: True for left subdomain (Dirichlet at first node), False for right (Dirichlet at last node).\n    n = len(nodes)\n    # Unknowns exclude boundary node\n    if is_left_boundary:\n        unknown_map = np.full(n, -1, dtype=int)\n        unknown_map[1:] = np.arange(n - 1)  # exclude index 0\n    else:\n        unknown_map = np.full(n, -1, dtype=int)\n        unknown_map[:-1] = np.arange(n - 1)  # exclude last index\n\n    N_unknown = np.max(unknown_map) + 1\n    K = np.zeros((N_unknown, N_unknown))\n    F = np.zeros(N_unknown)\n\n    for i in range(n - 1):\n        x0 = nodes[i]\n        x1 = nodes[i + 1]\n        h = x1 - x0\n        # Local stiffness and load\n        k_loc = (a / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        f_loc = (h / 2.0) * np.array([1.0, 1.0])\n        iu = unknown_map[i]\n        ju = unknown_map[i + 1]\n        if iu != -1 and ju != -1:\n            K[iu, iu] += k_loc[0, 0]\n            K[iu, ju] += k_loc[0, 1]\n            K[ju, iu] += k_loc[1, 0]\n            K[ju, ju] += k_loc[1, 1]\n            F[iu] += f_loc[0]\n            F[ju] += f_loc[1]\n        elif iu != -1 and ju == -1:\n            K[iu, iu] += k_loc[0, 0]\n            F[iu] += f_loc[0]\n            # boundary contribution with u(boundary)=0 gives no RHS adjustment\n        elif iu == -1 and ju != -1:\n            K[ju, ju] += k_loc[1, 1]\n            F[ju] += f_loc[1]\n        else:\n            # both boundary -> no unknowns, nothing to add\n            pass\n\n    return K, F, unknown_map\n\ndef compute_exact_coeffs(aL, aR):\n    c1 = 0.5 * (aL - aR) / (aL * (aL + aR))\n    d1 = 0.5 * (aL - aR) / (aR * (aL + aR))\n    c2 = (1.0 / (2.0 * aL)) + c1\n    d2 = c2\n    return c1, c2, d1, d2\n\ndef u_exact_left(x, aL, c1, c2):\n    return -x**2 / (2.0 * aL) + c1 * x + c2\n\ndef u_exact_right(x, aR, d1, d2):\n    return -x**2 / (2.0 * aR) + d1 * x + d2\n\ndef reconstruct_full_nodal_values(nodes, unknown_map, U_unknown, boundary_value):\n    # Fill full nodal array with boundary_value at boundary and unknowns mapped\n    u = np.zeros(len(nodes))\n    for i, um in enumerate(unknown_map):\n        if um == -1:\n            u[i] = boundary_value\n        else:\n            u[i] = U_unknown[um]\n    return u\n\ndef add_penalty(K, idx_L0, idx_R0, alpha, h_int):\n    val = alpha / h_int\n    K[idx_L0, idx_L0] += val\n    K[idx_R0, idx_R0] += val\n    K[idx_L0, idx_R0] -= val\n    K[idx_R0, idx_L0] -= val\n\ndef add_nitsche(K, idx_Lprev, idx_L0, idx_R0, idx_Rnext, aL, aR, hL, hR, gamma, h_int):\n    # Construct gradient vector g for average flux\n    g = np.array([-0.5 * aL / hL, 0.5 * aL / hL, 0.5 * aR / hR, -0.5 * aR / hR])\n    # Assemble M1: rows at L0 (-g) and R0 (+g)\n    indices = [idx_Lprev, idx_L0, idx_R0, idx_Rnext]\n    # M1 additions\n    for col_pos, col_idx in enumerate(indices):\n        if idx_L0 is not None:\n            K[idx_L0, col_idx] += -g[col_pos]\n        if idx_R0 is not None:\n            K[idx_R0, col_idx] += +g[col_pos]\n    # M2 additions: columns at L0 (-g) and R0 (+g)\n    for row_pos, row_idx in enumerate(indices):\n        if idx_L0 is not None:\n            K[row_idx, idx_L0] += -g[row_pos]\n        if idx_R0 is not None:\n            K[row_idx, idx_R0] += +g[row_pos]\n    # Stabilization term\n    stab = gamma / h_int\n    K[idx_L0, idx_L0] += stab\n    K[idx_R0, idx_R0] += stab\n    K[idx_L0, idx_R0] -= stab\n    K[idx_R0, idx_L0] -= stab\n\ndef solve_LM(K, F, idx_L0, idx_R0):\n    n = K.shape[0]\n    K_aug = np.zeros((n + 1, n + 1))\n    F_aug = np.zeros(n + 1)\n    K_aug[:n, :n] = K\n    F_aug[:n] = F\n    # B and B^T\n    K_aug[n, idx_L0] = 1.0\n    K_aug[n, idx_R0] = -1.0\n    K_aug[idx_L0, n] = 1.0\n    K_aug[idx_R0, n] = -1.0\n    # Solve\n    sol = np.linalg.solve(K_aug, F_aug)\n    U = sol[:n]\n    # lambda = sol[n], not used\n    return U\n\ndef element_error_L2(x0, x1, u0, u1, a_side, coeffs, side, quad_pts, quad_wts):\n    # Compute L2 error on an element via quadrature\n    # side: 'L' or 'R'\n    # coeffs: (c1,c2) for left or (d1,d2) for right appropriately\n    err_sq = 0.0\n    for t, w in zip(quad_pts, quad_wts):  # t in [-1,1]\n        s = 0.5 * (t + 1.0)  # map to [0,1]\n        x = x0 + s * (x1 - x0)\n        uh = (1.0 - s) * u0 + s * u1\n        if side == 'L':\n            c1, c2 = coeffs\n            ue = u_exact_left(x, a_side, c1, c2)\n        else:\n            d1, d2 = coeffs\n            ue = u_exact_right(x, a_side, d1, d2)\n        diff = uh - ue\n        err_sq += w * diff * diff * 0.5 * (x1 - x0)  # Jacobian factor for mapping [-1,1] to [x0,x1]\n    return err_sq\n\ndef compute_errors(nodes_left, U_left_full, nodes_right, U_right_full, aL, aR, c1, c2, d1, d2, r):\n    # Quadrature\n    qpts, qwts = leggauss(5)\n    # Accumulate errors\n    err_iface = 0.0\n    err_bulk = 0.0\n    # Left elements\n    for i in range(len(nodes_left) - 1):\n        x0 = nodes_left[i]\n        x1 = nodes_left[i + 1]\n        u0 = U_left_full[i]\n        u1 = U_left_full[i + 1]\n        esq = element_error_L2(x0, x1, u0, u1, aL, (c1, c2), 'L', qpts, qwts)\n        # classify\n        if x1 <= -r:\n            err_bulk += esq\n        else:\n            err_iface += esq\n    # Right elements\n    for i in range(len(nodes_right) - 1):\n        x0 = nodes_right[i]\n        x1 = nodes_right[i + 1]\n        u0 = U_right_full[i]\n        u1 = U_right_full[i + 1]\n        esq = element_error_L2(x0, x1, u0, u1, aR, (d1, d2), 'R', qpts, qwts)\n        # classify\n        if x0 >= r:\n            err_bulk += esq\n        else:\n            err_iface += esq\n    return np.sqrt(err_iface), np.sqrt(err_bulk)\n\ndef convergence_rate(log_h, log_err):\n    # Linear regression slope\n    x = np.array(log_h)\n    y = np.array(log_err)\n    xm = np.mean(x)\n    ym = np.mean(y)\n    denom = np.sum((x - xm) ** 2)\n    if denom == 0.0:\n        return 0.0\n    slope = np.sum((x - xm) * (y - ym)) / denom\n    return slope\n```",
            "answer": "[[[1.500969,2.000049,1.99997],[0.000302,0.000004,0.000002]],[[1.0,2.0,2.0],[0.0,0.0,0.0]],[[1.488347,2.00164,2.000446],[0.003318,0.000262,0.000109]]]"
        }
    ]
}