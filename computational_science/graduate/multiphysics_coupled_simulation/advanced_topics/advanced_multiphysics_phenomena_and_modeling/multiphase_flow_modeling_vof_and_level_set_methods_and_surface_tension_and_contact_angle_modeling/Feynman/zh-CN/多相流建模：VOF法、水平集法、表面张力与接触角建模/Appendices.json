{
    "hands_on_practices": [
        {
            "introduction": "在多相流模拟中，精确模拟表面张力是一个核心挑战。由于离散化曲率和表面张力时产生的数值误差，计算结果中常常会出现被称为“伪电流”的非物理性流动。本练习将指导您从第一性原理出发，推导并量化这些寄生流的大小，从而深入理解不同数值方法（如连续表面力模型与鬼点法）和网格特性如何影响模拟的准确性 。",
            "id": "3516350",
            "problem": "考虑一个二维、不可压缩、粘性、牛顿、不混溶的两相系统，其中一个半径为 $R$ 的圆形液滴静止于一个矩形域的中心。真实的物理解决方案是处处速度为零，并且跨界面的静水压力跳跃等于表面张力与曲率的乘积。然而，在数值多相流方法中，表面张力和曲率的离散化会引入残余不平衡，从而驱动被称为伪电流（也称为寄生电流）的非物理流动。您的任务是通过比较连续表面力（CSF）模型和鬼点流体法（GFM）以及两种曲率估计器：高度函数估计器（HF）和水平集估计器（LS），来量化这些伪电流的峰值大小及其随网格分辨率和各向异性的标度关系。\n\n您必须从低雷诺数流动和表面张力表示的第一性原理出发，仅使用下述基本定律和经过充分检验的方法阶数事实，来推导峰值伪速度的闭式预测。然后在一个程序中实现该预测，以评估特定的测试案例并打印结果。\n\n使用的基本和公认事实：\n- 对于牛顿流体，在稳态、无惯性（斯托克斯）极限下，不可压缩的 Navier–Stokes 方程简化为 $\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}$ 和 $\\nabla \\cdot \\mathbf{u} = 0$，其中 $\\mu$ 是动力粘度，$\\mathbf{u}$ 是速度， $p$ 是压力，$\\mathbf{f}$ 是体积力密度。\n- 界面上精确的表面张力牵引力会产生跨界面的压力跳跃 $[p] = \\sigma \\kappa$，其中 $\\sigma$ 是表面张力，$\\kappa$ 是曲率。\n- 在类 CSF 的离散化中，表面张力被正则化为体积力 $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$，其中 $C$ 是一个在与网格间距成比例的厚度上涂抹的指示场。曲率误差 $\\delta \\kappa$ 会留下一个残余力密度，其大小与指示场的梯度大小成标度关系。\n- 在类 GFM 的尖锐跳跃离散化中，表面张力表现为在界面上强制执行的跳跃条件；曲率误差 $\\delta \\kappa$ 会产生一个跳跃误差 $\\delta p = \\sigma \\delta \\kappa$，从而在界面附近驱动一个局部的斯托克斯响应。\n- 对于光滑界面，高度函数曲率估计器（HF）具有二阶精度，而基于一阶精度法线和中心差分的标准水平集曲率估计器（LS）在通用网格上对曲率的精度实际上是一阶的。将这些阶数表示为 $q_{\\text{HF}} = 2$ 和 $q_{\\text{LS}} = 1$。\n- 对于间距为 $\\Delta x$ 和 $\\Delta y$ 的各向异性笛卡尔网格，融合了各向异性的基于 LS 离散化的有效网格长度为 $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$，而 HF 类型的列重构受限于较粗的方向，因此 $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$。\n- 曲率的单位是长度的倒数。对于光滑的圆形界面，曲率的截断误差在量纲上可以建模为\n  $\\delta \\kappa_{\\text{geom}} \\sim C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q$，\n  其中 $C_k$ 是一个与方法相关的无量纲常数，$q$ 是曲率估计器的精度阶数。\n- 在固体壁面上的接触角建模会在三相接触线附近引入一个额外的曲率缺陷，该缺陷与网格尺寸以及平衡接触角大小的余弦值成线性标度关系。将其建模为\n  $\\delta \\kappa_{\\text{CA}} \\sim C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|$，\n  其中 $\\theta_e$ 是规定的平衡接触角，$h_{\\text{wall}}$ 是垂直于壁面的网格间距，$C_{\\text{CA}}$ 是一个无量纲常数。\n\n目标：\n1. 从稳态斯托克斯动量平衡和上述模型出发，为由曲率误差 $\\delta \\kappa$ 产生的峰值伪速度 $U_{\\max}$ 推导一个适用于 CSF 和 GFM 的标度表达式。您的推导必须说明粘性响应的特征长度如何引入，并且必须量纲一致。结果以米/秒表示。\n2. 通过每种曲率估计器的有效长度 $h_{\\text{eff}}$ 来整合网格各向异性。对于 HF 使用 $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$，对于 LS 使用 $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$。\n3. 使用以下无量纲常数进行数值评估：$C_{\\text{HF}} = 0.25$, $C_{\\text{LS}} = 0.05$, $C_{\\text{CSF}} = 1.0$, $C_{\\text{GFM}} = 0.25$, $C_{\\text{CA}} = 0.75$。这里 $C_{\\text{HF}}$ 和 $C_{\\text{LS}}$ 分别对应于 HF 和 LS 的 $C_k$，$C_{\\text{CSF}}$ 和 $C_{\\text{GFM}}$ 是模拟 CSF 和 GFM 界面附近粘性响应相对强度的前置因子。\n4. 当指定壁面接触案例时，使用 $h_{\\text{wall}} = \\Delta x$ 和以度为单位的平衡接触角 $\\theta_e$ 来包含接触角曲率误差的贡献。在计算余弦值时将角度转换为弧度。\n\n参数和单位：\n- 半径 $R$，单位为米。\n- 表面张力 $\\sigma$，单位为牛顿/米。\n- 粘度 $\\mu$，单位为帕斯卡·秒。\n- 网格间距 $\\Delta x$ 和 $\\Delta y$，单位为米。\n- 平衡接触角 $\\theta_e$（如果适用），单位为度。\n- 输出速度，单位为米/秒。\n\n测试套件：\n使用 $R = 1.0 \\times 10^{-3}$，$\\sigma = 0.072$ 和 $\\mu = 1.0 \\times 10^{-3}$。评估以下五个案例的峰值伪速度。对于每个案例，指定方法（CSF 或 GFM）、曲率估计器（HF 或 LS）、$\\Delta x$、$\\Delta y$ 以及壁面/接触角（如果适用）。\n\n- 案例 1（理想路径）：在各向同性网格上使用 CSF 和 HF。\n  - $\\Delta x = \\Delta y = R/32$。\n  - 无壁面，无接触角项。\n\n- 案例 2（方法敏感性）：在各向同性网格上使用 CSF 和 LS。\n  - $\\Delta x = \\Delta y = R/32$。\n  - 无壁面，无接触角项。\n\n- 案例 3（各向异性效应）：在各向异性网格上使用 CSF 和 HF。\n  - $\\Delta x = R/64$, $\\Delta y = R/16$。\n  - 无壁面，无接触角项。\n\n- 案例 4（各向异性下的模型比较）：在各向异性网格上使用 GFM 和 LS。\n  - $\\Delta x = R/64$, $\\Delta y = R/16$。\n  - 无壁面，无接触角项。\n\n- 案例 5（壁面接触角）：在具有壁面接触曲率缺陷的各向同性网格上使用 GFM 和 HF。\n  - $\\Delta x = \\Delta y = R/32$。\n  - 规定的平衡接触角 $\\theta_e = 60$ 度。\n\n要求的最终输出格式：\n- 您的程序必须计算每个案例的峰值伪速度 $U_{\\max}$（单位为米/秒），并打印一行包含五个浮点数结果的逗号分隔列表，并用方括号括起来，例如，“[v1,v2,v3,v4,v5]”。\n- 每个值表示为六位有效数字。\n- 程序不得读取任何输入，并且必须在内部嵌入测试套件。",
            "solution": "任务是推导数值两相流模拟中峰值伪速度 $U_{\\max}$ 的闭式表达式，并用它来评估五个特定的测试案例。该推导将基于所提供的物理原理和标度律。\n\n我们从流体运动的控制方程开始，即稳态、无惯性、不可压缩的 Navier-Stokes（斯托克斯）方程：\n$$\n\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}\n$$\n其中 $\\mu$ 是动力粘度，$\\mathbf{u}$ 是速度场， $p$ 是压力，$\\mathbf{f}$ 是体积体力。伪电流是由离散化的粘性项、压力项和表面张力项之间的不平衡产生的非物理流动。\n\n对斯托克斯方程进行量纲分析可以洞察速度的标度关系。设 $U$ 为特征速度大小，$L$ 为流动变化的特征长度尺度。粘性项的标度为 $\\mu |\\nabla^2 \\mathbf{u}| \\sim \\mu U/L^2$。该项必须与压力梯度 $|\\nabla p| \\sim \\delta P/L$ 或体力 $|\\mathbf{f}| \\sim F$ 相平衡。这导致了两种可能的速度标度关系：\n1. 压力驱动流：$\\mu U/L^2 \\sim \\delta P/L \\implies U \\sim \\frac{\\delta P \\cdot L}{\\mu}$\n2. 力驱动流：$\\mu U/L^2 \\sim F \\implies U \\sim \\frac{F \\cdot L^2}{\\mu}$\n\n伪电流是由在计算网格尺度上发生的数值误差驱动的。因此，所产生的流动模式的特征长度尺度 $L$ 与有效网格间距 $h_{\\text{eff}}$ 成正比。因此，我们设定 $L \\sim h_{\\text{eff}}$。\n\n我们现在分析所提供的两种表面张力模型：连续表面力（CSF）模型和鬼点流体法（GFM）。\n\n对于 CSF 模型，表面张力被正则化为体积力 $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$，其中 $C$ 是一个在界面上涂抹的指示函数（例如，体积分数）。曲率误差 $\\delta \\kappa$ 会导致一个残余力密度 $\\delta \\mathbf{f}_{\\text{st}}$，其大小为 $F = |\\delta \\mathbf{f}_{\\text{st}}| \\sim \\sigma (\\delta \\kappa) |\\nabla C|$。指示函数的梯度在几个网格单元内从 $0$ 过渡到 $1$，其标度为 $|\\nabla C| \\sim 1/h_{\\text{eff}}$。因此，残余力密度为 $F \\sim \\sigma (\\delta \\kappa)/h_{\\text{eff}}$。使用力驱动的速度标度关系，我们发现：\n$$\nU_{\\max} \\sim \\frac{F \\cdot L^2}{\\mu} \\sim \\frac{(\\sigma (\\delta \\kappa) / h_{\\text{eff}}) \\cdot h_{\\text{eff}}^2}{\\mu} = \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n为此模型引入给定的无量纲前置因子 $C_{\\text{CSF}}$，我们得到：\n$$\nU_{\\max, \\text{CSF}} = C_{\\text{CSF}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n\n对于 GFM，表面张力被强制为跨界面的尖锐压力跳跃。曲率误差 $\\delta \\kappa$ 导致此压力跳跃出现误差 $\\delta P \\sim \\delta p = \\sigma \\delta \\kappa$。这种压力不平衡驱动了流动。使用压力驱动的速度标度关系并设 $L \\sim h_{\\text{eff}}$，我们得到：\n$$\nU_{\\max} \\sim \\frac{\\delta P \\cdot L}{\\mu} \\sim \\frac{(\\sigma \\delta \\kappa) \\cdot h_{\\text{eff}}}{\\mu}\n$$\n为此模型引入前置因子 $C_{\\text{GFM}}$ 得到：\n$$\nU_{\\max, \\text{GFM}} = C_{\\text{GFM}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n两种模型都产生相似的标度结构。我们可以写出一个通用表达式：\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n其中 $C_{\\text{method}}$ 是 $C_{\\text{CSF}}$ 或 $C_{\\text{GFM}}$。\n\n下一步是代入总曲率误差 $\\delta \\kappa$ 的模型。问题陈述此误差由几何离散化贡献，以及在适用情况下，由壁面接触角处理贡献。我们假设这些贡献相加：\n$$\n\\delta \\kappa = \\delta \\kappa_{\\text{geom}} + \\delta \\kappa_{\\text{CA}}\n$$\n所提供的显式模型是：\n$$\n\\delta \\kappa_{\\text{geom}} = C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q\n$$\n$$\n\\delta \\kappa_{\\text{CA}} = C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|\n$$\n其中 $C_k$ 和 $q$ 取决于所选的曲率估计器（HF 或 LS），$R$ 是液滴半径，$C_{\\text{CA}}$ 是接触角误差的常数，$h_{\\text{wall}}$ 是垂直于壁面的网格间距，$\\theta_e$ 是平衡接触角。\n\n将 $\\delta \\kappa$ 的完整表达式代入我们的速度标度关系，得到峰值伪速度的最终预测公式：\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma h_{\\text{eff}}}{\\mu} \\left[ C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\n为清晰起见，可以通过提取因子 $1/R$ 并识别毛细速度尺度 $V_{cap} = \\sigma/\\mu$ 来重新排列此式：\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma}{\\mu} \\frac{h_{\\text{eff}}}{R} \\left[ C_k \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\n该公式整合了表面张力模型（$C_{\\text{method}}$）、曲率估计器（$C_k, q, h_{\\text{eff}}$）、网格各向异性（通过 $h_{\\text{eff}}$）和接触角效应。对于没有壁面的情况，接触角项设置为零。此表达式将被实现以评估指定的测试案例。$h_{\\text{eff}}$ 的定义取决于估计器：$h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$ 和 $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and evaluates the peak spurious velocity for several test cases\n    in multiphase flow simulation.\n    \"\"\"\n    # Define physical parameters and dimensionless constants from the problem.\n    R = 1.0e-3  # meters\n    sigma = 0.072  # N/m\n    mu = 1.0e-3  # Pa.s\n\n    C_CSF = 1.0\n    C_GFM = 0.25\n    C_HF = 0.25\n    C_LS = 0.05\n    C_CA = 0.75\n\n    # Orders of accuracy for curvature estimators.\n    q_HF = 2\n    q_LS = 1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 2, 'method': 'CSF', 'estimator': 'LS', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 3, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 4, 'method': 'GFM', 'estimator': 'LS', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 5, 'method': 'GFM', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': 60},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Determine case-specific parameters\n        if case['method'] == 'CSF':\n            C_method = C_CSF\n        else: # GFM\n            C_method = C_GFM\n\n        dx = R / case['dx_div']\n        dy = R / case['dy_div']\n\n        if case['estimator'] == 'HF':\n            C_k = C_HF\n            q = q_HF\n            h_eff = np.max([dx, dy])\n        else: # LS\n            C_k = C_LS\n            q = q_LS\n            h_eff = np.sqrt((dx**2 + dy**2) / 2)\n\n        # Calculate geometric error contribution\n        # U_max_geom = C_method * C_k * (sigma / mu) * (h_eff / R)**(q + 1)\n        geom_err_factor = C_k * (h_eff / R)**q\n\n        # Calculate contact angle error contribution\n        ca_err_factor = 0.0\n        if case['theta_e_deg'] is not None:\n            theta_e = np.radians(case['theta_e_deg'])\n            h_wall = dx\n            ca_err_factor = C_CA * (h_wall / R) * np.abs(np.cos(theta_e))\n        \n        # Combine terms using the derived formula:\n        # U_max = C_method * (sigma/mu) * (h_eff/R) * [geom_err_factor + ca_err_factor]\n        total_err_term = geom_err_factor + ca_err_factor\n        U_max = C_method * (sigma / mu) * (h_eff / R) * total_err_term\n\n        results.append(U_max)\n\n    # Format output to six significant figures and join into a single string.\n    formatted_results = [f'{val:.6g}' for val in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在分析了数值误差的宏观效应后，我们深入到算法实现的核心细节。对于流体体积（VOF）等界面捕捉方法，精确重构固液气三相接触线处的界面至关重要。本练习聚焦于边界网格单元内的核心几何重构算法，要求您实现一个既能强制施加静态接触角又能保证质量守恒的界面重构逻辑 。",
            "id": "3516372",
            "problem": "考虑在流体体积（VOF）法中，特别是在分段线性界面计算（PLIC）表示中，对液-气界面进行的二维几何重构。该重构在一个边长为 $L$（单位：米）的单个笛卡尔方形单元中进行。单元内的流体区域由一个单位界面法向量 $\\mathbf{m} \\in \\mathbb{R}^2$ 和一个标量截距 $d$（单位：米）定义的半平面近似，使得流体占据集合 $\\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$。单元内流体的体积分数（在二维中为面积分数）为 $C \\in [0,1]$，并且必须通过几何重构（质量守恒）来精确强制执行。在与固体壁面相邻的边界单元中，必须在重构的界面方向上强制执行静态接触角。\n\n使用以下与上下文相适应的基本原理：用于平衡润湿的 Young-Dupré 关系 $\\sigma_{sg} - \\sigma_{sl} = \\sigma_{lg} \\cos \\theta$，意味着在三相线上存在一个平衡接触角 $\\theta$，该接触角约束了液-气界面相对于壁面的方向。在二维几何表示中，这通过强制界面法线 $\\mathbf{m}$ 和壁面单位法线 $\\mathbf{n}_w$ 之间的夹角等于 $\\theta$（以弧度为单位）来建模，即 $\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) = \\theta$。此外，与平流的一致性要求重构的法线应尽可能接近从体积分数场推断出的界面方向，该方向由一个给定的非零向量 $\\mathbf{n}_0 \\in \\mathbb{R}^2$（不一定是单位向量）表示，这通常是 VOF 中体积分数的局部梯度。\n\n您的任务是为每个测试用例实现以下步骤：\n- 通过选择单位界面法线 $\\mathbf{m}$ 来强制执行静态接触角约束，该法线满足 $\\|\\mathbf{m}\\|=1$ 和 $\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) = \\theta$，并且在所有此类单位向量中，以最小二乘的方式最小化与给定 $\\mathbf{n}_0$ 的欧几里得偏差。您必须纯粹用几何术语表达此构造，并确保其与壁面方向一致。所有角度必须以弧度为单位。\n- 给定 $\\mathbf{m}$，计算唯一的截距 $d$（单位：米），使得多边形 $\\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$ 的面积等于 $C L^2$。将流体视为满足 $\\mathbf{m}\\cdot \\mathbf{x} \\le d$ 的集合。计算必须在数值公差范围内精确，并且对所有允许的 $C \\in [0,1]$ 都具有鲁棒性。\n- 对于每个测试用例，生成两个输出：无量纲归一化截距 $d/L$ 和绝对接触角残差 $\\Delta = |\\arccos(\\mathbf{m}\\cdot \\mathbf{n}_w) - \\theta|$（以弧度为单位）。\n\n角度单位要求：所有角度均以弧度处理。物理单位要求：$L$ 和 $d$ 的单位是米；然而，要求的输出是无量纲截距 $d/L$ 和残差 $\\Delta$（以弧度为单位）。\n\n设计约束：\n- 您必须从上述基本定律和核心定义（Young-Dupré 平衡以及角度和法线的几何约束）出发，而不使用预先推导的 PLIC 面积分数快捷公式。面积必须通过用半平面裁剪正方形并对所得多边形的面积进行积分，从第一性原理计算得出。\n- 该算法必须具有通用性，对多相流建模具有科学现实性，对边界和边缘情况具有鲁棒性，并应通过构造来遵守质量守恒。\n\n测试套件：\n实现您的程序以处理以下参数值集，每个参数集为一个元组 $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta)$，其中向量由其笛卡尔分量给出：\n1. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.3,\\, (1.0,\\, 0.2),\\, (0.0,\\, 1.0),\\, \\pi/3\\,)$\n2. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.01,\\, (0.0,\\, 1.0),\\, (1.0,\\, 0.0),\\, 2\\pi/3\\,)$\n3. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,0.8,\\, 0.5,\\, (-1.0,\\, 2.0),\\, (1/\\sqrt{2},\\, 1/\\sqrt{2}),\\, \\pi/2\\,)$\n4. $(L, C, \\mathbf{n}_0, \\mathbf{n}_w, \\theta) = (\\,1.0,\\, 0.95,\\, (0.1,\\, -1.0),\\, (0.0,\\, -1.0),\\, \\pi - 0.05\\,)$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，条目按 $[d_1/L,\\Delta_1,d_2/L,\\Delta_2,d_3/L,\\Delta_3,d_4/L,\\Delta_4]$ 的顺序排列。例如，一个语法正确的输出可能看起来像 $[0.12345,0.00000,0.23456,0.00001,0.34567,0.00000,0.45678,0.00002]$。",
            "solution": "用户在计算流体力学领域提供了一个定义明确的问题，具体涉及使用流体体积（VOF）法在边界单元中对流体界面进行几何重构。任务是根据物理和数值约束确定界面的方向和位置。该问题具有科学依据、是适定的，并且所有必要的参数都已提供。\n\n解决方案按照问题陈述分为两个主要阶段进行：\n1.  确定单位界面法向量 $\\mathbf{m}$。\n2.  计算截距 $d$，以强制满足给定的体积分数 $C$。\n\n我将系统地处理每个阶段，并基于基本的几何和物理原理进行构建。\n\n### 第1部分：确定界面法向量 $\\mathbf{m}$\n\n界面法向量 $\\mathbf{m}$ 必须满足两个条件：它必须是一个单位向量（$\\|\\mathbf{m}\\| = 1$），该向量遵循与壁面法线 $\\mathbf{n}_w$ 的静态接触角 $\\theta$；并且它必须是与给定方向 $\\mathbf{n}_0$ 最接近的此类向量。\n\n接触角约束由 $\\arccos(\\mathbf{m} \\cdot \\mathbf{n}_w) = \\theta$ 给出，这等价于线性约束 $\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$。\n\n第二个条件是最小化与 $\\mathbf{n}_0$ 的欧几里得偏差，即最小化 $\\|\\mathbf{m} - \\mathbf{n}_0\\|^2$。展开此表达式，我们得到：\n$$\n\\|\\mathbf{m} - \\mathbf{n}_0\\|^2 = \\mathbf{m} \\cdot \\mathbf{m} - 2\\mathbf{m} \\cdot \\mathbf{n}_0 + \\mathbf{n}_0 \\cdot \\mathbf{n}_0 = \\|\\mathbf{m}\\|^2 - 2\\mathbf{m} \\cdot \\mathbf{n}_0 + \\|\\mathbf{n}_0\\|^2\n$$\n由于 $\\|\\mathbf{m}\\|=1$ 且对于给定的测试用例 $\\|\\mathbf{n}_0\\|$ 是一个固定值，最小化此数量等价于最大化点积 $\\mathbf{m} \\cdot \\mathbf{n}_0$。此外，最大化 $\\mathbf{m} \\cdot \\mathbf{n}_0$ 等价于最大化 $\\mathbf{m} \\cdot \\hat{\\mathbf{n}}_0$，其中 $\\hat{\\mathbf{n}}_0 = \\mathbf{n}_0 / \\|\\mathbf{n}_0\\|$ 是沿 $\\mathbf{n}_0$ 方向的单位向量。\n\n为了解决这个约束优化问题，我们在由壁面法线 $\\mathbf{n}_w$ 及其正交切向量 $\\mathbf{t}_w$ 定义的二维坐标系中工作。由于 $\\mathbf{n}_w$ 是一个单位向量，我们可以通过将 $\\mathbf{n}_w$ 旋转 $\\pi/2$ 弧度来构造一个单位切向量 $\\mathbf{t}_w$。如果 $\\mathbf{n}_w = (n_{wx}, n_{wy})$，则 $\\mathbf{t}_w = (-n_{wy}, n_{wx})$。集合 $\\{\\mathbf{n}_w, \\mathbf{t}_w\\}$ 构成一个标准正交基。\n\n任何二维单位向量 $\\mathbf{m}$ 都可以用这个基底表示为：\n$$\n\\mathbf{m} = \\alpha \\mathbf{n}_w + \\beta \\mathbf{t}_w, \\quad \\text{其中} \\quad \\alpha^2 + \\beta^2 = 1\n$$\n应用接触角约束：\n$$\n\\mathbf{m} \\cdot \\mathbf{n}_w = (\\alpha \\mathbf{n}_w + \\beta \\mathbf{t}_w) \\cdot \\mathbf{n}_w = \\alpha \\|\\mathbf{n}_w\\|^2 + \\beta (\\mathbf{t}_w \\cdot \\mathbf{n}_w) = \\alpha(1) + \\beta(0) = \\alpha\n$$\n因此，约束 $\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$ 直接确定了 $\\alpha = \\cos\\theta$。\n\n将此代入单位向量条件 $\\alpha^2 + \\beta^2 = 1$：\n$$\n\\cos^2\\theta + \\beta^2 = 1 \\implies \\beta^2 = 1 - \\cos^2\\theta = \\sin^2\\theta\n$$\n这给出了 $\\beta$ 的两个可能值：$\\beta = \\sin\\theta$ 或 $\\beta = -\\sin\\theta$（因为 $\\theta \\in [0, \\pi]$，所以 $\\sin\\theta \\ge 0$）。这产生了两个候选法向量：\n$$\n\\mathbf{m}_1 = (\\cos\\theta)\\mathbf{n}_w + (\\sin\\theta)\\mathbf{t}_w \\\\\n\\mathbf{m}_2 = (\\cos\\theta)\\mathbf{n}_w - (\\sin\\theta)\\mathbf{t}_w\n$$\n为了在这两个候选向量之间做出选择，我们选择与 $\\hat{\\mathbf{n}}_0$ 的点积最大的那个：\n$$\n\\mathbf{m}_1 \\cdot \\hat{\\mathbf{n}}_0 = (\\cos\\theta)(\\mathbf{n}_w \\cdot \\hat{\\mathbf{n}}_0) + (\\sin\\theta)(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0) \\\\\n\\mathbf{m}_2 \\cdot \\hat{\\mathbf{n}}_0 = (\\cos\\theta)(\\mathbf{n}_w \\cdot \\hat{\\mathbf{n}}_0) - (\\sin\\theta)(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0)\n$$\n比较这些，我们发现如果 $(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0) \\ge 0$，则选择 $\\mathbf{m}_1$；如果 $(\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0)  0$，则选择 $\\mathbf{m}_2$。这可以通过将 $\\beta$ 系数的符号设置为与 $\\hat{\\mathbf{n}}_0$ 在 $\\mathbf{t}_w$ 上的投影的符号相匹配来捕捉。\n在 $\\mathbf{t}_w \\cdot \\hat{\\mathbf{n}}_0 = 0$（或 $\\sin\\theta=0$）的退化情况下，两种选择是等效的，我们可以采用一种约定（例如，选择正号）。\n\n$\\mathbf{m}$ 的最终表达式为：\n$$\n\\mathbf{m} = (\\cos\\theta)\\mathbf{n}_w + \\text{sign}(\\hat{\\mathbf{n}}_0 \\cdot \\mathbf{t}_w) (\\sin\\theta)\\mathbf{t}_w\n$$\n其中我们定义 $\\text{sign}(0)$ 为 $1$。\n\n然后计算接触角残差 $\\Delta = |\\arccos(\\mathbf{m} \\cdot \\mathbf{n}_w) - \\theta|$。根据构造，$\\mathbf{m} \\cdot \\mathbf{n}_w = \\cos\\theta$，因此这个残差应该在浮点精度范围内为零，这可以作为对该方法的验证。\n\n### 第2部分：计算截距 $d$\n\n给定法向量 $\\mathbf{m}$，我们必须找到截距 $d$，使得单元内流体区域的面积等于 $C L^2$。流体区域定义为 $S = \\{\\mathbf{x} \\in [0,L]^2 \\mid \\mathbf{m}\\cdot \\mathbf{x} \\le d\\}$。这是一个质量守恒约束。\n\n该问题可以进行无量纲化处理。令 $\\mathbf{x}' = \\mathbf{x}/L$ 和 $d' = d/L$。单元变为单位正方形 $[0,1]^2$，流体区域由 $\\mathbf{m} \\cdot \\mathbf{x}' \\le d'$ 定义。这个无量纲区域的面积 $A(d')$ 必须等于体积分数 $C$。函数 $A(d')$ 是 $d'$ 的一个单调递增函数，因此对于任何给定的 $C \\in [0,1]$，都存在一个唯一的解 $d'$。我们可以通过使用数值求根算法求解方程 $A(d') - C = 0$ 来找到这个 $d'$。\n\n这部分的核心是函数 $A(d')$，它计算由半平面 $\\mathbf{m} \\cdot \\mathbf{x}' - d' \\le 0$ 裁剪单位正方形得到的面积。根据问题约束，这个面积不能通过预先推导的公式计算，而必须从第一性原理出发。一个鲁棒的算法是执行正方形多边形对直线的几何裁剪，然后计算所得多边形的面积。\n\n裁剪可以使用 Sutherland-Hodgman 算法的一个变体来实现。单位正方形，其顶点为 $(0,0), (1,0), (1,1), (0,1)$，被半空间 $\\mathbf{m} \\cdot \\mathbf{x}' - d' \\le 0$ 裁剪。该算法遍历正方形的边，生成一个新的顶点列表，这些顶点构成了流体多边形的边界。\n\n一旦按顺序找到了被裁剪多边形的顶点，其面积就可以使用鞋带（或测量员）公式计算：\n$$\n\\text{面积} = \\frac{1}{2} \\left| \\sum_{i=1}^{N} (x_i y_{i+1} - x_{i+1} y_i) \\right|\n$$\n其中 $(x_{N+1}, y_{N+1}) = (x_1, y_1)$，$N$ 是顶点数。\n\n为了找到产生目标面积 $C$ 的 $d'$ 值，我们可以使用二分法或 Brent 方法。我们需要定义一个保证包含根的区间 $[d'_{min}, d'_{max}]$。在单位正方形内，$\\mathbf{m} \\cdot \\mathbf{x}'$ 的值是有界的。最小值和最大值是：\n$$\nd'_{min} = \\min_{\\mathbf{x}' \\in [0,1]^2} (\\mathbf{m} \\cdot \\mathbf{x}') = \\min(m_x, 0) + \\min(m_y, 0) \\\\\nd'_{max} = \\max_{\\mathbf{x}' \\in [0,1]^2} (\\mathbf{m} \\cdot \\mathbf{x}') = \\max(m_x, 0) + \\max(m_y, 0)\n$$\n有了函数 $g(d') = A(d') - C$ 和包含根的区间 $[d'_{min}, d'_{max}]$，像 `scipy.optimize.brentq` 这样的求根算法可以高效地找到满足面积约束的唯一 $d'$。这个 $d'$ 就是最终所需的输出 $d/L$。\n\n该实现将通过这两个阶段处理每个测试用例，以计算所需的输出对：无量纲截距 $d/L$ 和接触角残差 $\\Delta$。",
            "answer": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves the PLIC-VOF reconstruction problem for a set of test cases.\n\n    For each case, it first computes the interface normal vector 'm' that satisfies\n    the contact angle constraint and is closest to a given normal 'n0'.\n    Then, it calculates the interface intercept 'd' such that the fluid area\n    matches the given volume fraction 'C'.\n\n    Outputs are the dimensionless intercept d/L and the contact angle residual.\n    \"\"\"\n\n    test_cases = [\n        # (L, C, n0, nw, theta)\n        (1.0, 0.3, (1.0, 0.2), (0.0, 1.0), np.pi / 3),\n        (1.0, 0.01, (0.0, 1.0), (1.0, 0.0), 2 * np.pi / 3),\n        (0.8, 0.5, (-1.0, 2.0), (1.0 / np.sqrt(2), 1.0 / np.sqrt(2)), np.pi / 2),\n        (1.0, 0.95, (0.1, -1.0), (0.0, -1.0), np.pi - 0.05),\n    ]\n\n    results = []\n    TOL = 1e-12 # A small tolerance for floating point comparisons\n\n    for L, C, n0_tuple, nw_tuple, theta in test_cases:\n        n0 = np.array(n0_tuple, dtype=float)\n        nw = np.array(nw_tuple, dtype=float)\n\n        # Part 1: Determine the interface normal vector 'm'\n        \n        # Normalize n0, which is given as non-zero.\n        n0_hat = n0 / np.linalg.norm(n0)\n        \n        # Construct the orthonormal tangent vector to nw\n        tw = np.array([-nw[1], nw[0]])\n        \n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Determine the sign of the tangent component to maximize dot product with n0_hat\n        # sign(0) is handled by defaulting to 1.\n        sign_beta = np.sign(np.dot(n0_hat, tw))\n        if abs(sign_beta)  TOL:\n            sign_beta = 1.0\n            \n        m = cos_theta * nw + sign_beta * sin_theta * tw\n\n        # Compute the contact angle residual\n        dot_product = np.dot(m, nw)\n        # Clip to handle potential floating point inaccuracies outside [-1, 1]\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        delta = np.abs(np.arccos(dot_product) - theta)\n\n        # Part 2: Calculate the intercept 'd'\n        \n        def shoelace_area(vertices):\n            \"\"\"Computes the area of a polygon using the shoelace formula.\"\"\"\n            if len(vertices)  3:\n                return 0.0\n            \n            x = vertices[:, 0]\n            y = vertices[:, 1]\n            return 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n\n        def calculate_area_in_unit_square(d_norm, m_vec):\n            \"\"\"\n            Calculates the fluid area in a unit square [0,1]x[0,1] for a given\n            interface normal 'm_vec' and normalized intercept 'd_norm'.\n            The fluid is the region where m.x = d_norm.\n            \"\"\"\n            square_vertices = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n            \n            output_vertices = []\n            for i in range(4):\n                p1 = square_vertices[i]\n                p2 = square_vertices[(i + 1) % 4]\n                \n                val_p1 = np.dot(m_vec, p1) - d_norm\n                val_p2 = np.dot(m_vec, p2) - d_norm\n                \n                p1_inside = val_p1 = TOL\n                p2_inside = val_p2 = TOL\n                \n                if p2_inside:\n                    if not p1_inside: # Crossing from out to in\n                        # The denominator should not be zero unless the line is parallel to the edge\n                        # and not crossing, which this logic branch won't enter.\n                        # However, for robustness:\n                        denom = val_p2 - val_p1\n                        if abs(denom)  TOL: continue # Edge is parallel to line, no intersection.\n                        t = -val_p1 / denom\n                        intersection = p1 + t * (p2 - p1)\n                        output_vertices.append(intersection)\n                    output_vertices.append(p2)\n                elif p1_inside: # Crossing from in to out\n                    denom = val_p2 - val_p1\n                    if abs(denom)  TOL: continue\n                    t = -val_p1 / denom\n                    intersection = p1 + t * (p2 - p1)\n                    output_vertices.append(intersection)\n\n            if not output_vertices:\n                # This occurs if the whole square is inside or outside\n                # Check value at a test point, e.g., the center\n                if np.dot(m_vec, [0.5, 0.5]) - d_norm = TOL:\n                    return 1.0 # Whole square is fluid\n                else:\n                    return 0.0 # No fluid in square\n            \n            return shoelace_area(np.array(output_vertices))\n\n        # Root finding for d_norm = d/L\n        \n        # Bounding interval for the root search\n        mx_pos = max(m[0], 0.0)\n        mx_neg = min(m[0], 0.0)\n        my_pos = max(m[1], 0.0)\n        my_neg = min(m[1], 0.0)\n        d_norm_min = mx_neg + my_neg\n        d_norm_max = mx_pos + my_pos\n\n        # Define the function whose root we want to find: Area(d_norm) - C = 0\n        def objective_func(d_norm):\n            return calculate_area_in_unit_square(d_norm, m) - C\n\n        # Handle trivial cases C=0 or C=1 to avoid root-finder issues at boundaries\n        if C  TOL:\n            d_norm_final = d_norm_min\n        elif C > 1.0 - TOL:\n            d_norm_final = d_norm_max\n        else:\n            # Use a robust root-finding algorithm\n            d_norm_final = optimize.brentq(objective_func, d_norm_min - TOL, d_norm_max + TOL)\n        \n        results.extend([d_norm_final, delta])\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将视角从单个算法扩展到一个完整的动态模拟。真实的流动模拟不仅需要精确的物理模型，还需要稳定可靠的边界条件处理，尤其是在流体进出计算域时。本练习将通过实现一个水平集（Level-Set）方法的对流求解器，让您亲手处理入口、出口以及壁面接触角等多种动态边界条件，并评估模拟结果的准确性 。",
            "id": "3516353",
            "problem": "考虑由不可压缩纳维–斯托克斯方程和界面捕捉法模拟的两种不可混溶、不可压缩的流体。设界面由水平集函数 $\\phi(\\mathbf{x},t)$ 表示，其值等于到界面的符号距离，在一个相中为正，在另一个相中为负。界面在给定速度场 $\\mathbf{u}$ 中的平流由输运方程 $ \\partial \\phi / \\partial t + \\mathbf{u} \\cdot \\nabla \\phi = 0 $ 控制。由表面张力引起的毛细力使用连续表面力（CSF）方法建模，其中体积毛细力密度为 $\\mathbf{f}_{\\mathrm{st}} = \\sigma \\kappa \\delta_\\epsilon(\\phi) \\nabla \\phi$，其中 $\\sigma$ 为常数表面张力系数，$\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\|\\nabla \\phi\\| \\right)$ 为曲率，$\\delta_\\epsilon(\\phi)$ 为从正则化 Heaviside 函数 $H_\\epsilon(\\phi)$ 构建的正则化 delta 函数。\n\n在单位法向量为 $\\mathbf{n}_w$ 的固体壁面处，通过 $\\mathbf{n}\\cdot \\mathbf{n}_w = \\cos \\theta$ 为水平集法线 $\\mathbf{n} = \\nabla \\phi / \\|\\nabla \\phi\\|$ 施加静态接触角边界条件，其中 $\\theta$ 是给定的静态接触角（以弧度为单位）。在位于 $y=0$ 和 $y=L_y$ 的平面水平壁面上，$\\phi$ 的法向和切向导数存在边界关系。例如，在底部壁面处，该关系的形式为 $\\partial \\phi / \\partial y = \\cot \\theta \\, \\partial \\phi / \\partial x$。在入口边界处，水平集场 $\\phi$ 由已知的来流界面形状和速度给定。在出口（开放）边界处，其向外法线在 $+x$ 方向且 $\\mathbf{u}=(U,0)$，$U0$，通过在虚拟区域中设置零法向梯度 $\\partial \\phi / \\partial x = 0$ 来实现与出射特征线一致的 $\\phi$ 的无反射开放边界条件，而内部更新则使用迎风格式。\n\n您需要在均匀笛卡尔网格上为三个测试案例实现 $\\phi$ 的二维类有限体积平流。每个案例的速度场是均匀的，$\\mathbf{u} = (U,0)$，其中 $U$ 为常数。时间离散化是显式的，在 $x$ 方向上采用与 $U$ 符号一致的一阶迎风格式。对于 $U0$，更新公式为\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, U \\, \\frac{\\phi_{i,j}^{n} - \\phi_{i-1,j}^{n}}{\\Delta x},\n$$\n适用于内部索引 $i \\ge 1$，而 $i=0$ 边界由狄利克雷入口值 $\\phi_{\\mathrm{in}}(0,y,t^{n+1})$ 设定。对于 $U=0$，由于平流，$\\phi$ 不随时间变化。通过在壁面法向方向 $y$ 构建虚拟值以满足离散关系，从而弱施加用于梯度和曲率计算的壁面接触角边界条件：\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = \\cot \\theta \\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{y=0}, \\quad\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=L_y} = \\cot \\theta_{\\mathrm{top}} \\left.\\frac{\\partial \\phi}{\\partial x}\\right|_{y=L_y},\n$$\n其中 $\\theta_{\\mathrm{top}} = \\pi - \\theta$。\n\n对于曲率，使用中心差分计算 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\|\\nabla \\phi\\| \\right)$，在 $y$ 边界上使用上述的适当虚拟值，在 $x$ 边界上使用零梯度虚拟值处理。使用平滑的 Heaviside 函数和 delta 函数\n$$\nH_\\epsilon(\\phi) = \n\\begin{cases}\n0,  \\phi \\le -\\epsilon,\\\\\n\\frac{1}{2}\\left[1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi}\\sin\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon,\\\\\n1,  \\phi \\ge \\epsilon,\n\\end{cases}\n\\quad\n\\delta_\\epsilon(\\phi) = H_\\epsilon'(\\phi) = \n\\begin{cases}\n\\frac{1}{2\\epsilon}\\left[1 + \\cos\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon,\\\\\n0,  \\text{否则。}\n\\end{cases}\n$$\n定义体积分数 $C = H_\\epsilon(\\phi)$。\n\n您在每个测试案例中的任务是：\n1. 使用所述的格式和边界条件，将 $\\phi$ 从 $t=0$ 演化到 $t=T$。\n2. 计算在时间 $t=T$ 时，水平集场相对于精确平流形状的均方根误差：\n$$\nE_\\phi = \\left( \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[\\phi_{i,j}^{\\mathrm{num}}(T) - \\phi_{i,j}^{\\mathrm{exact}}(T)\\right]^2 \\right)^{1/2}.\n$$\n以米为单位表示 $E_\\phi$。\n3. 使用 CSF 表示法，计算在右边界 $x=L_x$ 处，开放边界法向方向上的积分毛细牵引力贡献：\n$$\nF_{\\mathrm{cap}} = \\int_0^{L_y} f_{\\mathrm{st},x}(x=L_x^{-},y) \\, \\mathrm{d}y \\approx \\sum_{j=0}^{N_y-1} \\left[ \\sigma \\, \\kappa \\, \\delta_\\epsilon(\\phi)\\, \\frac{\\partial \\phi}{\\partial x} \\right]_{i=N_x-1,j} \\Delta y,\n$$\n其中方括号内的项在最后一个内部列 $i=N_x-1$ 上计算。以 $\\mathrm{N/m}$ 为单位表示 $F_{\\mathrm{cap}}$。\n\n角度必须以弧度提供和解释。所有长度必须以米为单位，时间以秒为单位，速度以米/秒为单位。表面张力 $\\sigma$ 必须以牛顿/米为单位。使用 Courant–Friedrichs–Lewy (CFL) 条件选择一个稳定的时间步长，$\\Delta t = \\mathrm{CFL} \\, \\Delta x / \\max(|U|,10^{-8})$，其中 $\\mathrm{CFL} = 0.4$，并通过将最后一步的大小设置为与 $T$ 匹配来使用最少数量的均匀步长以精确达到 $T$。\n\n精确解和入口条件的界面定义：\n- 直线界面（平面接触角一致性入口）：定义一条法线角度为 $\\alpha = \\theta + \\pi/2$ 的直线和一个在线上的点 $\\mathbf{r}_0(t) = (x_c + U t, y_c)$。精确解和入口水平集是到该直线的符号距离，\n$$\n\\phi_{\\mathrm{line}}(x,y,t) = \\cos\\alpha \\, (x - x_c - U t) + \\sin\\alpha \\, (y - y_c).\n$$\n- 圆形界面（静止时的毛细主导形状）：选择半径 $R$ 和中心 $(x_{\\mathrm{ctr}}, y_{\\mathrm{ctr}})$；精确水平集为\n$$\n\\phi_{\\mathrm{circ}}(x,y,t) = \\sqrt{(x - x_{\\mathrm{ctr}})^2 + (y - y_{\\mathrm{ctr}})^2} - R.\n$$\n\n测试套件：\n- 案例 1（平面入口/出口，中等速度，斜接触角）：$L_x = 1.0$, $L_y = 0.5$, $N_x = 120$, $N_y = 60$, $U = 0.6$, $\\theta = \\pi/3$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.4$, $x_c = 0.25 L_x$, $y_c = 0.5 L_y$。\n- 案例 2（静止曲面界面的开放边界）：$L_x = 0.6$, $L_y = 0.4$, $N_x = 80$, $N_y = 60$, $U = 0.0$, $\\theta = \\pi/2$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.01$，圆形界面参数 $R = 0.08$, $x_{\\mathrm{ctr}} = 0.45$, $y_{\\mathrm{ctr}} = 0.20$。\n- 案例 3（平面入口/出口，较高速度，不同角度）：$L_x = 0.5$, $L_y = 0.3$, $N_x = 80$, $N_y = 48$, $U = 1.2$, $\\theta = \\pi/4$, $\\sigma = 0.072$, $\\epsilon = 2 \\Delta x$, $T = 0.15$, $x_c = 0.20 L_x$, $y_c = 0.5 L_y$。\n\n要求输出：\n- 对于每个案例，计算对 $\\left(E_\\phi, F_{\\mathrm{cap}}\\right)$，其中 $E_\\phi$ 以米为单位，$F_{\\mathrm{cap}}$ 以牛顿/米为单位。您的程序应生成一行输出，其中包含所有结果，形式为方括号内以逗号分隔的列表，按案例顺序展平为 $[E_{\\phi,1}, F_{\\mathrm{cap},1}, E_{\\phi,2}, F_{\\mathrm{cap},2}, E_{\\phi,3}, F_{\\mathrm{cap},3}]$，每个数字为普通十进制数。",
            "solution": "该问题被评估为有效。这是一个适定的、有科学依据的计算流体动力学问题，特别关注水平集场的数值平流和表面张力效应的计算。所有必要的参数、方程和边界条件都已提供，并且没有内部矛盾。\n\n解决方法是为三个指定的测试案例分别执行数值模拟。模拟的核心是在二维均匀笛卡尔网格上演化水平集函数 $\\phi(\\mathbf{x}, t)$。演化由平流方程控制，时间上使用显式前向欧拉方法离散，空间上使用一阶迎风格式离散。\n\n以下是方法的逐步分解：\n\n**1. 网格与初始化**\n对于每个测试案例，定义一个尺寸为 $L_x \\times L_y$、分辨率为 $N_x \\times N_y$ 的均匀笛卡尔网格。网格间距为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。水平集场 $\\phi$ 在时间 $t=0$ 时在此网格上初始化。界面的初始形状可以是直线（案例1和3）或圆形（案例2），$\\phi$ 定义为到此初始界面的符号距离。\n- 对于直线界面，精确水平集函数为 $\\phi_{\\mathrm{line}}(x,y,t) = \\cos\\alpha \\, (x - x_c - U t) + \\sin\\alpha \\, (y - y_c)$，其中 $\\alpha = \\theta + \\pi/2$。\n- 对于圆形界面，$\\phi_{\\mathrm{circ}}(x,y,t) = \\sqrt{(x - x_{\\mathrm{ctr}})^2 + (y - y_{\\mathrm{ctr}})^2} - R$。\n\n**2. 时间积分**\n平流方程 $\\partial \\phi / \\partial t + U \\partial \\phi / \\partial x = 0$ 从 $t=0$ 到 $t=T$ 进行数值求解。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件确定：$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / \\max(|U|, 10^{-8})$，其中 $\\mathrm{CFL}=0.4$。为精确达到最终时间 $T$，模拟采用一系列大小为 $\\Delta t$ 的均匀步长，然后是一个较小的时间步长以覆盖剩余时间。对于 $U=0$ 的案例2，场 $\\phi$ 不演化。\n\n**3. 空间离散化与边界条件**\n- **平流：** 对空间导数 $\\partial \\phi / \\partial x$ 使用一阶迎风格式。对于 $U  0$，更新规则为：\n$$\n\\phi_{i,j}^{n+1} = \\phi_{i,j}^{n} - \\Delta t \\, U \\, \\frac{\\phi_{i,j}^{n} - \\phi_{i-1,j}^{n}}{\\Delta x}\n$$\n- **入口边界 ($x=0$)：** 应用狄利克雷（Dirichlet）边界条件。入口列 ($i=0$) 的 $\\phi$ 值在每个时间步使用已知的来流界面精确解 $\\phi_{\\mathrm{in}}(0,y,t^{n+1})$ 进行设置。\n- **出口边界 ($x=L_x$)：** 对于 $U0$，由于信息从内部传播，迎风格式在出口处不需要显式边界条件。\n- **壁面边界 ($y=0, L_y$)：** 静态接触角条件 $\\mathbf{n}\\cdot \\mathbf{n}_w = \\cos \\theta$ 用于梯度和曲率计算。该条件被转化为壁面上 $\\phi$ 的偏导数之间的关系，例如，在 $y=0$ 处为 $\\partial \\phi / \\partial y = \\cot \\theta \\, \\partial \\phi / \\partial x$。这是通过在物理域外为 $\\phi$ 构建虚拟单元值来实现的。对于底部壁面上的网格点 $(i,0)$，虚拟值 $\\phi_{i,-1}$ 被设置为满足此边界条件的离散版本。壁面上的一阶精确离散化得到：\n$$\n\\frac{\\phi_{i,0} - \\phi_{i,-1}}{\\Delta y} = \\cot\\theta \\left. \\frac{\\partial \\phi}{\\partial x} \\right|_{i,0}\n$$\n这使我们能够解出 $\\phi_{i,-1}$。在顶部壁面 ($y=L_y$) 应用类似的过程，接触角为 $\\theta_{\\mathrm{top}} = \\pi - \\theta$。壁面边界处的 $\\partial\\phi/\\partial x$ 项对于内部壁面点使用中心差分计算，在角点使用单边差分计算。\n\n**4. 曲率与力计算**\n曲率 $\\kappa$ 是根据水平集场使用涉及二阶偏导数的标准公式计算的：\n$$\n\\kappa = \\frac{\\phi_{xx} \\phi_y^2 - 2 \\phi_x \\phi_y \\phi_{xy} + \\phi_{yy} \\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\n所有偏导数（$\\phi_x, \\phi_y, \\phi_{xx}, \\phi_{yy}, \\phi_{xy}$）都使用二阶中心差分格式计算。这需要用一层虚拟单元来填充 `phi` 场，这些虚拟单元根据上述边界条件进行填充。对于 $x$ 边界，为曲率计算所需的虚拟单元使用零梯度条件（$\\partial\\phi/\\partial x = 0$）。\n\n**5. 最终输出计算**\n在将解演化到 $t=T$ 后，为每个案例计算两个量：\n- **均方根误差 ($E_\\phi$)：** 在整个网格上计算最终数值解 $\\phi^{\\mathrm{num}}(T)$ 与精确解析解 $\\phi^{\\mathrm{exact}}(T)$ 之间的均方根误差。\n$$\nE_\\phi = \\left( \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[\\phi_{i,j}^{\\mathrm{num}}(T) - \\phi_{i,j}^{\\mathrm{exact}}(T)\\right]^2 \\right)^{1/2}\n$$\n- **积分毛细牵引力 ($F_{\\mathrm{cap}}$)：** 通过在边界上积分连续表面力（CSF）密度 $f_{\\mathrm{st},x}$ 的 $x$ 分量来计算垂直于出口边界的毛细力贡献。这通过对最后一个内部网格单元列 ($i=N_x-1$) 的求和来近似：\n$$\nF_{\\mathrm{cap}} \\approx \\sum_{j=0}^{N_y-1} \\left[ \\sigma \\, \\kappa \\, \\delta_\\epsilon(\\phi)\\, \\frac{\\partial \\phi}{\\partial x} \\right]_{i=N_x-1,j} \\Delta y\n$$\n正则化 delta 函数 $\\delta_\\epsilon(\\phi)$ 将力定位在界面周围的薄带 $|\\phi|\\epsilon$ 内。由于所有测试案例中的界面都不与出口边界列相交或接近，该力预计为零。\n整个过程被封装在一个 Python 脚本中，使用 `numpy` 库进行数值计算。",
            "answer": "```python\nimport numpy as np\n\ndef delta_eps(phi, epsilon):\n    \"\"\"\n    Computes the regularized Dirac delta function based on a smoothed Heaviside function.\n\n    Args:\n        phi (np.ndarray): The level-set field.\n        epsilon (float): The thickness parameter for regularization.\n\n    Returns:\n        np.ndarray: The value of the regularized delta function.\n    \"\"\"\n    res = np.zeros_like(phi)\n    mask = np.abs(phi)  epsilon\n    phi_masked = phi[mask]\n    res[mask] = (1.0 / (2.0 * epsilon)) * (1.0 + np.cos(np.pi * phi_masked / epsilon))\n    return res\n\ndef get_phi_line(x_grid, y_grid, t, xc, yc, U, theta):\n    \"\"\"\n    Computes the signed distance function for a straight line interface.\n\n    Args:\n        x_grid (np.ndarray): X-coordinates of the grid.\n        y_grid (np.ndarray): Y-coordinates of the grid.\n        t (float): Current time.\n        xc (float): Initial x-position of a point on the line.\n        yc (float): Initial y-position of a point on the line.\n        U (float): Advection velocity in x-direction.\n        theta (float): Contact angle in radians.\n\n    Returns:\n        np.ndarray: The level-set field for the line.\n    \"\"\"\n    alpha = theta + np.pi / 2.0\n    cos_alpha = np.cos(alpha)\n    sin_alpha = np.sin(alpha)\n    return cos_alpha * (x_grid - xc - U * t) + sin_alpha * (y_grid - yc)\n\ndef get_phi_circ(x_grid, y_grid, t, x_ctr, y_ctr, R):\n    \"\"\"\n    Computes the signed distance function for a circular interface.\n\n    Args:\n        x_grid (np.ndarray): X-coordinates of the grid.\n        y_grid (np.ndarray): Y-coordinates of the grid.\n        t (float): Current time (unused for static case).\n        x_ctr (float): X-coordinate of the circle's center.\n        y_ctr (float): Y-coordinate of the circle's center.\n        R (float): Radius of the circle.\n\n    Returns:\n        np.ndarray: The level-set field for the circle.\n    \"\"\"\n    return np.sqrt((x_grid - x_ctr)**2 + (y_grid - y_ctr)**2) - R\n\ndef compute_kappa_and_dphidx(phi, dx, dy, theta):\n    \"\"\"\n    Computes curvature and the x-gradient of the level-set field.\n\n    Args:\n        phi (np.ndarray): The level-set field.\n        dx (float): Grid spacing in x.\n        dy (float): Grid spacing in y.\n        theta (float): Contact angle in radians.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the curvature field and the d(phi)/dx field.\n    \"\"\"\n    Nx, Ny = phi.shape\n    theta_top = np.pi - theta\n\n    phi_pad = np.pad(phi, 1, 'constant')\n\n    # X-boundary ghost cells (zero-gradient for curvature calculation)\n    phi_pad[0, 1:-1] = phi[0, :]\n    phi_pad[-1, 1:-1] = phi[-1, :]\n\n    # Y-boundary ghost cells (contact angle)\n    cot_theta = 1.0 / np.tan(theta) if abs(np.sin(theta)) > 1e-12 else 0.0\n    cot_theta_top = 1.0 / np.tan(theta_top) if abs(np.sin(theta_top)) > 1e-12 else 0.0\n\n    for i in range(Nx):\n        ip = i + 1\n        # Bottom wall\n        if i == 0:\n            dphidx_wall_bot = (phi[i + 1, 0] - phi[i, 0]) / dx\n        elif i == Nx - 1:\n            dphidx_wall_bot = (phi[i, 0] - phi[i - 1, 0]) / dx\n        else:\n            dphidx_wall_bot = (phi[i + 1, 0] - phi[i - 1, 0]) / (2.0 * dx)\n        phi_pad[ip, 0] = phi[i, 0] - dy * cot_theta * dphidx_wall_bot\n\n        # Top wall\n        if i == 0:\n            dphidx_wall_top = (phi[i + 1, -1] - phi[i, -1]) / dx\n        elif i == Nx - 1:\n            dphidx_wall_top = (phi[i, -1] - phi[i - 1, -1]) / dx\n        else:\n            dphidx_wall_top = (phi[i + 1, -1] - phi[i - 1, -1]) / (2.0 * dx)\n        phi_pad[ip, -1] = phi[i, -1] + dy * cot_theta_top * dphidx_wall_top\n\n    # Corner ghost cells\n    phi_pad[0,0] = (phi_pad[1,0] + phi_pad[0,1])/2.0\n    phi_pad[-1,0] = (phi_pad[-2,0] + phi_pad[-1,1])/2.0\n    phi_pad[0,-1] = (phi_pad[1,-1] + phi_pad[0,-2])/2.0\n    phi_pad[-1,-1] = (phi_pad[-2,-1] + phi_pad[-1,-2])/2.0\n\n    # Derivatives using central differences on the padded grid\n    dphidx = (phi_pad[2:, 1:-1] - phi_pad[:-2, 1:-1]) / (2.0 * dx)\n    dphidy = (phi_pad[1:-1, 2:] - phi_pad[1:-1, :-2]) / (2.0 * dy)\n    d2phidx2 = (phi_pad[2:, 1:-1] - 2.0 * phi[... , :] + phi_pad[:-2, 1:-1]) / (dx**2)\n    d2phidy2 = (phi_pad[1:-1, 2:] - 2.0 * phi[... , :] + phi_pad[1:-1, :-2]) / (dy**2)\n    d2phidxy = (phi_pad[2:, 2:] - phi_pad[:-2, 2:] - phi_pad[2:, :-2] + phi_pad[:-2, :-2]) / (4.0 * dx * dy)\n\n    mag_grad_sq = dphidx**2 + dphidy**2\n    mag_grad_sq[mag_grad_sq  1e-24] = 1e-24\n    \n    numerator = d2phidx2 * dphidy**2 - 2.0 * dphidx * dphidy * d2phidxy + d2phidy2 * dphidx**2\n    kappa = numerator / (mag_grad_sq**1.5)\n    \n    return kappa, dphidx\n\ndef solve_case(Lx, Ly, Nx, Ny, U, theta, sigma, T, interface_type, **kwargs):\n    \"\"\"\n    Solves a single test case for level-set advection and force calculation.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    x = (np.arange(Nx) + 0.5) * dx\n    y = (np.arange(Ny) + 0.5) * dy\n    x_grid, y_grid = np.meshgrid(x, y, indexing='ij')\n\n    epsilon = 2.0 * dx\n\n    if interface_type == 'line':\n        phi = get_phi_line(x_grid, y_grid, 0, U=U, theta=theta, **kwargs)\n    else: # circ\n        phi = get_phi_circ(x_grid, y_grid, 0, **kwargs)\n\n    t = 0.0\n    if abs(U) > 1e-12:\n        cfl = 0.4\n        dt_base = cfl * dx / abs(U)\n        \n        num_steps = int(np.floor(T / dt_base))\n        dt_last = T - num_steps * dt_base\n\n        dts = [dt_base] * num_steps\n        if dt_last > 1e-12:\n            dts.append(dt_last)\n\n        for dt in dts:\n            phi_n = phi.copy()\n            if U > 0:\n                phi_inflow = get_phi_line(0, y, t + dt, U=U, theta=theta, **kwargs)\n                phi[0, :] = phi_inflow\n                phi[1:, :] = phi_n[1:, :] - U * dt / dx * (phi_n[1:, :] - phi_n[:-1, :])\n            t += dt\n\n    phi_num = phi\n    \n    if interface_type == 'line':\n        phi_exact = get_phi_line(x_grid, y_grid, T, U=U, theta=theta, **kwargs)\n    else: # circ\n        phi_exact = get_phi_circ(x_grid, y_grid, T, **kwargs)\n        \n    e_phi = np.sqrt(np.mean((phi_num - phi_exact)**2))\n    \n    kappa, dphidx = compute_kappa_and_dphidx(phi_num, dx, dy, theta)\n    \n    phi_out = phi_num[-1, :]\n    kappa_out = kappa[-1, :]\n    dphidx_out = dphidx[-1, :]\n    \n    delta_out = delta_eps(phi_out, epsilon)\n    \n    integrand = sigma * kappa_out * delta_out * dphidx_out\n    f_cap = np.sum(integrand) * dy\n    \n    return e_phi, f_cap\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {'Lx': 1.0, 'Ly': 0.5, 'Nx': 120, 'Ny': 60, 'U': 0.6, 'theta': np.pi/3, \n         'sigma': 0.072, 'T': 0.4, 'interface_type': 'line', \n         'xc': 0.25 * 1.0, 'yc': 0.5 * 0.5},\n        # Case 2\n        {'Lx': 0.6, 'Ly': 0.4, 'Nx': 80, 'Ny': 60, 'U': 0.0, 'theta': np.pi/2, \n         'sigma': 0.072, 'T': 0.01, 'interface_type': 'circ', \n         'x_ctr': 0.45, 'y_ctr': 0.20, 'R': 0.08},\n        # Case 3\n        {'Lx': 0.5, 'Ly': 0.3, 'Nx': 80, 'Ny': 48, 'U': 1.2, 'theta': np.pi/4, \n         'sigma': 0.072, 'T': 0.15, 'interface_type': 'line', \n         'xc': 0.20 * 0.5, 'yc': 0.5 * 0.3}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack kwargs not used by solve_case directly\n        kwargs_for_phi = {k: v for k, v in params.items() if k in ['xc', 'yc', 'x_ctr', 'y_ctr', 'R']}\n        \n        e_phi, f_cap = solve_case(\n            Lx=params['Lx'], Ly=params['Ly'], Nx=params['Nx'], Ny=params['Ny'],\n            U=params['U'], theta=params['theta'], sigma=params['sigma'], T=params['T'],\n            interface_type=params['interface_type'], **kwargs_for_phi\n        )\n        results.extend([e_phi, f_cap])\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}