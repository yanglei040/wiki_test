{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of realistic damage modeling is capturing the different responses of materials to tension and compression. Many quasi-brittle materials, like concrete or ceramics, can withstand immense compressive loads but fail easily under tension. This exercise  provides hands-on practice in implementing a common technique called a tension-compression split, which mathematically isolates the tensile stresses that drive damage, ensuring that no damage occurs under pure compressive states.",
            "id": "3501250",
            "problem": "Consider a small-strain, linear-elastic, isotropic material under an unconfined compression test and related loading paths. The scalar damage variable $d \\in [0,1]$ is coupled to the elasticity via a tension-compression split that only degrades the energetic and stress contributions associated with tension. The governing base is the Cauchy stress-strain relation of isotropic linear elasticity, the spectral decomposition of a symmetric tensor, and an energy-based (local) damage evolution law. Use the following foundational facts as the starting point:\n- The Cauchy stress $\\boldsymbol{\\sigma}$ is related to the infinitesimal strain $\\boldsymbol{\\varepsilon}$ by Hooke’s law: $\\boldsymbol{\\sigma} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}$, where $\\lambda$ and $\\mu$ are the Lamé parameters and $\\boldsymbol{I}$ is the second-order identity tensor.\n- The Lamé parameters satisfy $\\mu = \\dfrac{E}{2(1+\\nu)}$ and $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$, where $E$ is Young’s modulus and $\\nu$ is Poisson’s ratio.\n- The spectral decomposition of a symmetric tensor employs its principal values and orthonormal eigenvectors. For any scalar $x$, define the positive and negative parts by $\\langle x \\rangle_{+} = \\max(x,0)$ and $\\langle x \\rangle_{-} = \\min(x,0)$.\n\nTension-compression split model assumptions:\n- Compute the undamaged stress $\\boldsymbol{\\sigma}^{0}$ from Hooke’s law.\n- Split $\\boldsymbol{\\sigma}^{0}$ spectrally into $\\boldsymbol{\\sigma}^{0}_{+}$ and $\\boldsymbol{\\sigma}^{0}_{-}$ by applying $\\langle \\cdot \\rangle_{+}$ and $\\langle \\cdot \\rangle_{-}$ to the principal stresses of $\\boldsymbol{\\sigma}^{0}$ and reconstructing with the corresponding eigenvectors.\n- The damage-driving positive strain energy density is defined as $\\psi_{+} = \\dfrac{1}{2} \\sum_{i=1}^{3} \\langle \\sigma^{0}_{i} \\rangle_{+} \\, \\varepsilon_{i}$, where $\\sigma^{0}_{i}$ and $\\varepsilon_{i}$ are the $i$-th principal values of stress and strain for a coaxial state. Only the positive stress part contributes to $\\psi_{+}$.\n- The total stress is $\\boldsymbol{\\sigma} = (1-d) \\boldsymbol{\\sigma}^{0}_{+} + \\boldsymbol{\\sigma}^{0}_{-}$.\n- The damage variable $d$ evolves from the positive energy via a smooth local law $d = 1 - \\exp\\!\\left( - \\dfrac{\\psi_{+}}{R} \\right)$, where $R$ is a material damage energy scale with units of energy per unit volume.\n\nUnconfined (free lateral surfaces) uniaxial loading kinematics:\n- For an imposed axial engineering strain $\\varepsilon_{x}$ under zero lateral stresses $\\sigma_{y} = \\sigma_{z} = 0$, the lateral strains $\\varepsilon_{y}$ and $\\varepsilon_{z}$ must be determined consistently with the constitutive law and the boundary conditions.\n- For hydrostatic loading, the strain is specified by $\\boldsymbol{\\varepsilon} = \\varepsilon_{h} \\boldsymbol{I}$.\n\nMaterial and numerical parameters for all test cases:\n- Young’s modulus $E = 30 \\times 10^{9} \\ \\mathrm{Pa}$.\n- Poisson’s ratio $\\nu = 0.25$.\n- Damage energy scale $R = 2 \\times 10^{5} \\ \\mathrm{J/m^{3}}$.\n- Zero-damage verification tolerance $\\tau = 10^{-12}$.\n\nTasks to implement:\n1. Using Hooke’s law and the boundary conditions, compute $\\boldsymbol{\\sigma}^{0}$ and the strain principal values for each test case.\n2. Perform the spectral tension-compression split on $\\boldsymbol{\\sigma}^{0}$, construct $\\boldsymbol{\\sigma}^{0}_{+}$ and $\\boldsymbol{\\sigma}^{0}_{-}$, and evaluate the positive energy $\\psi_{+}$.\n3. Compute the scalar damage $d$ and the final stress $\\boldsymbol{\\sigma} = (1-d)\\boldsymbol{\\sigma}^{0}_{+} + \\boldsymbol{\\sigma}^{0}_{-}$.\n4. Report the axial Cauchy stress component $\\sigma_{x}$ in pascals and the damage scalar $d$. Also report a boolean flag indicating whether $|d| \\le \\tau$.\n\nTest suite:\n- Case $\\mathrm{T1}$ (unconfined uniaxial compression, “happy path”): axial strain $\\varepsilon_{x} = -5 \\times 10^{-3}$, lateral surfaces traction-free ($\\sigma_{y}=\\sigma_{z}=0$).\n- Case $\\mathrm{T2}$ (unconfined uniaxial tension): axial strain $\\varepsilon_{x} = +5 \\times 10^{-3}$, lateral surfaces traction-free ($\\sigma_{y}=\\sigma_{z}=0$).\n- Case $\\mathrm{T3}$ (boundary case, zero axial strain): axial strain $\\varepsilon_{x} = 0$, lateral surfaces traction-free ($\\sigma_{y}=\\sigma_{z}=0$).\n- Case $\\mathrm{T4}$ (edge case, hydrostatic compression): hydrostatic strain $\\varepsilon_{h} = -2 \\times 10^{-3}$.\n\nFor each test case, the program must output a list $[\\sigma_{x}, d, \\mathrm{is\\_zero}]$, where $\\sigma_{x}$ is the axial Cauchy stress in $\\mathrm{Pa}$, $d$ is the computed damage scalar, and $\\mathrm{is\\_zero}$ is a boolean indicating $|d| \\le \\tau$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[\\sigma_{x}^{(1)}, d^{(1)}, \\mathrm{is\\_zero}^{(1)}],[\\sigma_{x}^{(2)}, d^{(2)}, \\mathrm{is\\_zero}^{(2)}],\\ldots]$). The numerical values must be produced in $\\mathrm{Pa}$ for stresses and as dimensionless floats for $d$.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, objective, and internally consistent. It provides a clear, formalizable task within the domain of continuum damage mechanics. All necessary material parameters, constitutive laws, and loading conditions are specified, allowing for a unique and meaningful solution for each test case.\n\nThe solution process involves applying the principles of linear elasticity and the specified damage model to four distinct loading cases. We begin by calculating the material's Lamé parameters from the given Young's modulus, $E$, and Poisson's ratio, $\\nu$.\n\nGiven material parameters:\n- Young’s modulus $E = 30 \\times 10^{9} \\ \\mathrm{Pa}$.\n- Poisson’s ratio $\\nu = 0.25$.\n- Damage energy scale $R = 2 \\times 10^{5} \\ \\mathrm{J/m^{3}}$.\n\nThe Lamé parameters $\\mu$ and $\\lambda$ are calculated as:\n$$ \\mu = \\dfrac{E}{2(1+\\nu)} = \\dfrac{30 \\times 10^{9} \\ \\mathrm{Pa}}{2(1+0.25)} = 12 \\times 10^{9} \\ \\mathrm{Pa} $$\n$$ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)} = \\dfrac{(30 \\times 10^{9} \\ \\mathrm{Pa}) \\times 0.25}{(1+0.25)(1-2 \\times 0.25)} = \\dfrac{7.5 \\times 10^{9} \\ \\mathrm{Pa}}{1.25 \\times 0.5} = 12 \\times 10^{9} \\ \\mathrm{Pa} $$\n\nThe analysis for each test case proceeds as follows.\n\n**Analysis for Unconfined Uniaxial Loading (Cases T1, T2, T3)**\n\nFor these cases, an axial strain $\\varepsilon_{x}$ is imposed, and the lateral surfaces are traction-free, meaning the final Cauchy stresses $\\sigma_{y}$ and $\\sigma_{z}$ are zero. The total stress is given by $\\boldsymbol{\\sigma} = (1-d) \\boldsymbol{\\sigma}^{0}_{+} + \\boldsymbol{\\sigma}^{0}_{-}$, where $\\boldsymbol{\\sigma}^{0}_{+}$ and $\\boldsymbol{\\sigma}^{0}_{-}$ are derived from the spectral decomposition of the undamaged stress $\\boldsymbol{\\sigma}^{0}$. Due to the axial symmetry of the loading, the principal axes of stress and strain align with the coordinate system, and we can assume $\\varepsilon_y = \\varepsilon_z$. The principal undamaged stresses are $\\sigma^0_x, \\sigma^0_y, \\sigma^0_z$.\n\nThe condition $\\sigma_y=0$ is written as:\n$$ \\sigma_y = (1-d) \\langle \\sigma^0_y \\rangle_{+} + \\langle \\sigma^0_y \\rangle_{-} = 0 $$\nIf $\\sigma^0_y > 0$, this becomes $(1-d)\\sigma^0_y = 0$, which requires $\\sigma^0_y = 0$ (assuming $d<1$). If $\\sigma^0_y \\le 0$, this becomes $\\sigma^0_y = 0$. Thus, for the final lateral stress to be zero, the undamaged lateral stress must also be zero: $\\sigma^0_y = \\sigma^0_z = 0$.\n\nThis establishes that the state corresponds to uniaxial stress in the undamaged configuration. From Hooke's law for uniaxial stress:\n$$ \\sigma^0_x = E \\varepsilon_x $$\n$$ \\varepsilon_y = \\varepsilon_z = -\\nu \\varepsilon_x $$\nThe strain principal values are $(\\varepsilon_x, -\\nu\\varepsilon_x, -\\nu\\varepsilon_x)$.\nThe undamaged stress principal values are $(E\\varepsilon_x, 0, 0)$.\n\nThe damage-driving positive strain energy density $\\psi_{+}$ is:\n$$ \\psi_{+} = \\dfrac{1}{2} \\sum_{i=1}^{3} \\langle \\sigma^{0}_{i} \\rangle_{+} \\, \\varepsilon_{i} = \\dfrac{1}{2} \\left( \\langle E\\varepsilon_x \\rangle_{+} \\varepsilon_x + \\langle 0 \\rangle_{+} \\varepsilon_y + \\langle 0 \\rangle_{+} \\varepsilon_z \\right) = \\dfrac{1}{2} \\langle E\\varepsilon_x \\rangle_{+} \\varepsilon_x $$\nThe damage scalar $d$ is then $d = 1 - \\exp(-\\psi_{+}/R)$.\nThe final axial stress $\\sigma_x$ is:\n$$ \\sigma_x = (1-d)\\langle E\\varepsilon_x \\rangle_{+} + \\langle E\\varepsilon_x \\rangle_{-} $$\n\n**Case T1: Unconfined Compression ($\\varepsilon_{x} = -5 \\times 10^{-3}$)**\n- Axial strain: $\\varepsilon_{x} = -0.005$.\n- Lateral strains: $\\varepsilon_{y} = \\varepsilon_{z} = -0.25 \\times (-0.005) = 0.00125$.\n- Undamaged axial stress: $\\sigma^{0}_{x} = (30 \\times 10^{9}) \\times (-0.005) = -150 \\times 10^{6} \\ \\mathrm{Pa}$. This is compressive.\n- Positive energy density: Since $\\sigma^0_x$ is negative, $\\langle \\sigma^0_x \\rangle_{+} = 0$. Therefore, $\\psi_{+} = 0$.\n- Damage: $d = 1 - \\exp(0) = 0$.\n- Final axial stress: $\\sigma_x = (1-0)\\langle -150 \\times 10^6 \\rangle_{+} + \\langle -150 \\times 10^6 \\rangle_{-} = 0 + (-150 \\times 10^6) = -150 \\times 10^6 \\ \\mathrm{Pa}$.\n- Damage check: $|d| = 0 \\le 10^{-12}$ is true.\n- Result: $[\\sigma_x, d, \\text{is\\_zero}] = [-150000000.0, 0.0, \\text{True}]$.\n\n**Case T2: Unconfined Tension ($\\varepsilon_{x} = +5 \\times 10^{-3}$)**\n- Axial strain: $\\varepsilon_{x} = 0.005$.\n- Lateral strains: $\\varepsilon_{y} = \\varepsilon_{z} = -0.25 \\times (0.005) = -0.00125$.\n- Undamaged axial stress: $\\sigma^{0}_{x} = (30 \\times 10^{9}) \\times (0.005) = 150 \\times 10^{6} \\ \\mathrm{Pa}$. This is tensile.\n- Positive energy density: $\\psi_{+} = \\dfrac{1}{2} (150 \\times 10^{6}) \\times (0.005) = 375000 \\ \\mathrm{J/m^{3}}$.\n- Damage: $d = 1 - \\exp\\left(-\\dfrac{375000}{200000}\\right) = 1 - \\exp(-1.875) \\approx 0.84664$.\n- Final axial stress: $\\sigma_x = (1-d)\\langle 150 \\times 10^6 \\rangle_{+} + \\langle 150 \\times 10^6 \\rangle_{-} = (1-0.84664) \\times (150 \\times 10^6) + 0 \\approx 23004051.5 \\ \\mathrm{Pa}$.\n- Damage check: $|d| \\approx 0.84664 \\le 10^{-12}$ is false.\n- Result: $[\\sigma_x, d, \\text{is\\_zero}] \\approx [23004051.5, 0.84664, \\text{False}]$.\n\n**Case T3: Zero Axial Strain ($\\varepsilon_{x} = 0$)**\n- Axial strain: $\\varepsilon_{x} = 0$.\n- All strain components are zero: $\\varepsilon_x = \\varepsilon_y = \\varepsilon_z = 0$.\n- The undamaged stress tensor is zero: $\\boldsymbol{\\sigma}^0 = \\boldsymbol{0}$.\n- Positive energy density: $\\psi_{+} = 0$.\n- Damage: $d = 0$.\n- Final axial stress: $\\sigma_x = 0 \\ \\mathrm{Pa}$.\n- Damage check: $|d| = 0 \\le 10^{-12}$ is true.\n- Result: $[\\sigma_x, d, \\text{is\\_zero}] = [0.0, 0.0, \\text{True}]$.\n\n**Analysis for Hydrostatic Loading (Case T4)**\n\nFor this case, the strain tensor is $\\boldsymbol{\\varepsilon} = \\varepsilon_{h} \\boldsymbol{I}$, where $\\varepsilon_h$ is the hydrostatic strain.\nThe principal strains are $\\varepsilon_1 = \\varepsilon_2 = \\varepsilon_3 = \\varepsilon_h$.\nThe trace is $\\mathrm{tr}(\\boldsymbol{\\varepsilon}) = 3\\varepsilon_h$.\nThe undamaged stress tensor is calculated from Hooke's Law:\n$$ \\boldsymbol{\\sigma}^{0} = \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon} = \\lambda (3\\varepsilon_h) \\boldsymbol{I} + 2 \\mu (\\varepsilon_h \\boldsymbol{I}) = (3\\lambda + 2\\mu)\\varepsilon_h \\boldsymbol{I} $$\nThe state of stress is also hydrostatic. Let $\\sigma^0_h = (3\\lambda + 2\\mu)\\varepsilon_h$. The principal undamaged stresses are $\\sigma^0_1 = \\sigma^0_2 = \\sigma^0_3 = \\sigma^0_h$.\nThe positive energy density is:\n$$ \\psi_{+} = \\dfrac{1}{2} \\sum_{i=1}^{3} \\langle \\sigma^{0}_{i} \\rangle_{+} \\, \\varepsilon_{i} = \\dfrac{1}{2} \\left( 3 \\times \\langle \\sigma^0_h \\rangle_{+} \\varepsilon_h \\right) $$\n\n**Case T4: Hydrostatic Compression ($\\varepsilon_{h} = -2 \\times 10^{-3}$)**\n- Hydrostatic strain: $\\varepsilon_h = -0.002$.\n- Undamaged hydrostatic stress: $\\sigma^{0}_{h} = (3 \\times 12 \\times 10^{9} + 2 \\times 12 \\times 10^{9}) \\times (-0.002) = (60 \\times 10^{9}) \\times (-0.002) = -120 \\times 10^{6} \\ \\mathrm{Pa}$. This is compressive. All principal stresses are negative.\n- Positive energy density: Since $\\sigma^0_h$ is negative, $\\langle \\sigma^0_h \\rangle_{+} = 0$. Therefore, $\\psi_{+} = 0$.\n- Damage: $d = 1 - \\exp(0) = 0$.\n- Final stress: $\\boldsymbol{\\sigma} = (1-0)\\boldsymbol{\\sigma}^0_{+} + \\boldsymbol{\\sigma}^0_{-} = \\boldsymbol{0} + \\boldsymbol{\\sigma}^0 = \\boldsymbol{\\sigma}^0$. The final axial stress is $\\sigma_x = \\sigma^0_h = -120 \\times 10^6 \\ \\mathrm{Pa}$.\n- Damage check: $|d| = 0 \\le 10^{-12}$ is true.\n- Result: $[\\sigma_x, d, \\text{is\\_zero}] = [-120000000.0, 0.0, \\text{True}]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the damage mechanics problem for the specified test cases.\n    \"\"\"\n    \n    # Material and numerical parameters\n    E = 30e9  # Young's modulus in Pa\n    nu = 0.25  # Poisson's ratio\n    R = 2e5   # Damage energy scale in J/m^3\n    tau = 1e-12 # Zero-damage verification tolerance\n    \n    # Test suite definition\n    # Structure: (case_type, strain_value)\n    # case_type can be 'uniaxial' or 'hydrostatic'\n    test_cases = [\n        ('uniaxial', -5e-3), # Case T1\n        ('uniaxial', +5e-3), # Case T2\n        ('uniaxial', 0.0),    # Case T3\n        ('hydrostatic', -2e-3) # Case T4\n    ]\n\n    # Calculate Lamé parameters\n    lame_mu = E / (2 * (1 + nu))\n    lame_lambda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\n    results = []\n    \n    for case_type, strain_val in test_cases:\n        sigma_x = 0.0\n        d = 0.0\n        \n        if case_type == 'uniaxial':\n            # Unconfined uniaxial loading kinematics\n            eps_x = strain_val\n            \n            # For unconfined loading (sigma_y=sigma_z=0), the undamaged\n            # state is also one of uniaxial stress.\n            # Principal strains: eps_x, -nu*eps_x, -nu*eps_x\n            # Principal undamaged stresses: E*eps_x, 0, 0\n            \n            sigma0_x = E * eps_x\n            \n            # Positive energy density calculation\n            # psi+ = 1/2 * sum( <sigma0_i>+ * eps_i )\n            # Only the first principal component can contribute.\n            sigma0_x_pos = max(sigma0_x, 0.0)\n            psi_plus = 0.5 * sigma0_x_pos * eps_x\n            \n            # Damage evolution\n            if R > 0:\n                d = 1.0 - np.exp(-psi_plus / R)\n            else:\n                d = 1.0 if psi_plus > 0 else 0.0\n\n            # Final stress calculation\n            # sigma = (1-d)*sigma0+ + sigma0-\n            sigma0_x_neg = min(sigma0_x, 0.0)\n            sigma_x = (1.0 - d) * sigma0_x_pos + sigma0_x_neg\n            \n        elif case_type == 'hydrostatic':\n            # Hydrostatic loading kinematics\n            eps_h = strain_val\n            \n            # Principal strains: eps_h, eps_h, eps_h\n            # Undamaged stress is also hydrostatic\n            sigma0_h = (3 * lame_lambda + 2 * lame_mu) * eps_h\n            \n            # Positive energy density calculation\n            # psi+ = 1/2 * sum( <sigma0_i>+ * eps_i )\n            sigma0_h_pos = max(sigma0_h, 0.0)\n            # Sum over three identical principal components\n            psi_plus = 0.5 * (3.0 * sigma0_h_pos * eps_h)\n\n            # Damage evolution\n            if R > 0:\n                d = 1.0 - np.exp(-psi_plus / R)\n            else:\n                d = 1.0 if psi_plus > 0 else 0.0\n                \n            # Final stress calculation for the x-component\n            # sigma_x = (1-d)*<sigma0_h>+ + <sigma0_h>-\n            sigma0_h_neg = min(sigma0_h, 0.0)\n            sigma_x = (1.0 - d) * sigma0_h_pos + sigma0_h_neg\n\n        # Check if damage is effectively zero\n        is_zero = abs(d) <= tau\n        \n        results.append([float(sigma_x), float(d), is_zero])\n\n    # Final print statement in the exact required format.\n    # The str() function on a list handles the boolean True/False correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Damage is an irreversible process; once a microcrack forms, it does not simply vanish when the load is removed. This exercise  delves into the computational method for enforcing this physical principle, known as the history field approach. By tracking the maximum tensile energy a material point has ever experienced, you will implement a damage model that correctly accumulates degradation during loading and prevents \"healing\" during unloading, a critical feature for simulating cyclic fatigue and complex load histories.",
            "id": "3501246",
            "problem": "Consider a one-dimensional prismatic bar subjected to cyclic axial loading, modeled as a spatially uniform state with a scalar damage variable $d \\in [0,1]$ that degrades only the tensile part of the stored elastic energy. Let the bar have Young's modulus $E$ (in $\\mathrm{Pa}$), and let the damage evolution be governed by a fracture phase-field of the Ambrosio-Tortorelli type with fracture toughness $G_c$ (in $\\mathrm{N/m}$) and internal length scale parameter $l$ (in $\\mathrm{m}$). The total free energy density per unit volume is composed of a degraded tensile elastic part and an undegraded compressive elastic part, plus a crack surface density contribution. Specifically, define the strain energy density split by\n$$\n\\psi(\\varepsilon,d) = (1-d)^2\\,\\psi^+(\\varepsilon) + \\psi^-(\\varepsilon),\n$$\nwhere the axial strain $\\varepsilon$ is dimensionless, the tensile energy density is $\\psi^+(\\varepsilon) = \\tfrac{1}{2} E\\,\\langle \\varepsilon \\rangle_+^2$, and the compressive energy density is $\\psi^-(\\varepsilon) = \\tfrac{1}{2} E\\,\\langle \\varepsilon \\rangle_-^2$, with the standard positive-negative split $\\langle \\varepsilon \\rangle_+ = \\max(\\varepsilon,0)$ and $\\langle \\varepsilon \\rangle_- = \\min(\\varepsilon,0)$. The fracture regularization energy density is given by\n$$\n\\gamma(d,\\nabla d) = G_c \\left( \\frac{d^2}{2l} + \\frac{l}{2} |\\nabla d|^2 \\right).\n$$\nAssume a spatially uniform solution so that $|\\nabla d| = 0$. The damage irreversibility is enforced by the history field approach: introduce the history field $H(t)$ as the running maximum of the tensile energy density,\n$$\nH(t) = \\max_{s \\in [0,t]} \\psi^+(\\varepsilon(s)),\n$$\nwhich satisfies the irreversibility constraints of Kuhn-Tucker type $H(t) \\ge \\psi^+(\\varepsilon(t))$, $\\dot{H}(t) \\ge 0$, and $\\left(H(t) - \\psi^+(\\varepsilon(t))\\right)\\dot{H}(t) = 0$. Starting solely from the above energy definitions and the principle of minimum potential energy, derive the local stationarity condition for $d$ under the history field approach in the uniform case, and use it to compute the time evolution of $d(t)$ for given strain histories.\n\nYour program must implement the following tasks:\n- Construct cyclic strain histories $\\varepsilon(t)$ as prescribed sequences, compute $\\psi^+(\\varepsilon(t))$, update the history field $H(t)$, and compute $d(t)$ at each time step from the derived uniform stationarity condition. Demonstrate algorithmically that damage does not heal under unloading by verifying that $d(t)$ does not decrease when the strain is decreasing or compressive.\n- For each test case, report two outputs: the final damage level $d_\\mathrm{final}$ (dimensionless, rounded to six decimals) and a boolean that is true if and only if the damage does not heal under unloading across the entire history, as determined by checking that $d(t)$ does not decrease on any time interval where $\\varepsilon(t)$ is decreasing. The boolean must be computed with a numerical tolerance that is physically reasonable.\n\nPhysical units: use $E$ in $\\mathrm{Pa}$, $G_c$ in $\\mathrm{N/m}$, $l$ in $\\mathrm{m}$, and strain is dimensionless. The computed $d$ is dimensionless.\n\nTest suite specification:\n1. Happy path cyclic reloading with increasing amplitude:\n   - $E = 70 \\times 10^9\\,\\mathrm{Pa}$, $G_c = 1000\\,\\mathrm{N/m}$, $l = 0.01\\,\\mathrm{m}$.\n   - Triangular strain cycles with amplitudes $[0.004, 0.006]$, each cycle composed of linear segments $0 \\to A \\to -A \\to 0$, with $50$ points per segment.\n2. Low-amplitude repeated cycles:\n   - $E = 70 \\times 10^9\\,\\mathrm{Pa}$, $G_c = 1000\\,\\mathrm{N/m}$, $l = 0.01\\,\\mathrm{m}$.\n   - Triangular strain cycles with amplitudes $[0.0005, 0.0005, 0.0005, 0.0005, 0.0005]$, same segment definition and $50$ points per segment.\n3. Pure compression history (edge case):\n   - $E = 70 \\times 10^9\\,\\mathrm{Pa}$, $G_c = 1000\\,\\mathrm{N/m}$, $l = 0.01\\,\\mathrm{m}$.\n   - Constant compressive strain history $\\varepsilon(t) = -0.004$ with $150$ points.\n4. Increased fracture toughness:\n   - $E = 70 \\times 10^9\\,\\mathrm{Pa}$, $G_c = 5000\\,\\mathrm{N/m}$, $l = 0.01\\,\\mathrm{m}$.\n   - Triangular strain cycles with amplitudes $[0.006, 0.006]$, $50$ points per segment.\n5. Reduced internal length scale:\n   - $E = 70 \\times 10^9\\,\\mathrm{Pa}$, $G_c = 1000\\,\\mathrm{N/m}$, $l = 0.001\\,\\mathrm{m}$.\n   - Triangular strain cycle with amplitude $[0.006]$, $50$ points per segment.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be formatted as a list $[d_\\mathrm{final},\\text{boolean}]$ without spaces, for example, $\\big[[0.123456,\\text{True}],[0.000000,\\text{True}],\\dots\\big]$.",
            "solution": "The problem requires the derivation of a damage evolution law for a one-dimensional bar under cyclic loading, based on a phase-field fracture model, and its subsequent numerical implementation to analyze specific load histories.\n\n### 1. Governing Principles and Model Formulation\nThe total free energy density per unit volume, $\\Pi$, for a spatially uniform material state is the sum of the mechanical strain energy density, $\\psi(\\varepsilon,d)$, and the fracture regularization energy density, $\\gamma(d, \\nabla d)$.\n\nThe givens are:\n- Mechanical strain energy density with tensile/compressive split:\n$$\n\\psi(\\varepsilon,d) = (1-d)^2\\,\\psi^+(\\varepsilon) + \\psi^-(\\varepsilon)\n$$\nwhere $\\psi^+(\\varepsilon) = \\tfrac{1}{2} E\\,\\langle \\varepsilon \\rangle_+^2$ is the tensile part and $\\psi^-(\\varepsilon) = \\tfrac{1}{2} E\\,\\langle \\varepsilon \\rangle_-^2$ is the compressive part. The damage variable $d \\in [0,1]$ degrades only the tensile stiffness.\n- Fracture regularization energy density:\n$$\n\\gamma(d,\\nabla d) = G_c \\left( \\frac{d^2}{2l} + \\frac{l}{2} |\\nabla d|^2 \\right)\n$$\nwhere $G_c$ is the fracture toughness and $l$ is an internal length scale.\n- We assume a spatially uniform state, which implies the gradient of damage is zero: $|\\nabla d| = 0$.\n\nCombining these, the total energy density for a uniform state is:\n$$\n\\Pi(\\varepsilon, d) = (1-d)^2\\,\\psi^+(\\varepsilon) + \\psi^-(\\varepsilon) + G_c \\frac{d^2}{2l}\n$$\n\n### 2. Derivation of the Damage Evolution Law\nA critical aspect of damage mechanics is irreversibility: damage cannot heal. This is enforced using a history field, $H(t)$, which tracks the maximum tensile energy density experienced by the material up to time $t$:\n$$\nH(t) = \\max_{s \\in [0,t]} \\psi^+(\\varepsilon(s))\n$$\nThis history field is, by definition, a non-decreasing function of time, $\\dot{H}(t) \\ge 0$. In the variational framework for dissipative processes, the evolution of the internal variable $d$ is governed by the stationarity of an effective potential where the driving force for damage, $\\psi^+(\\varepsilon)$, is replaced by its historical maximum, $H$. This ensures that damage can only grow or remain constant, never decrease.\n\nThe effective potential governing the current state of damage is therefore:\n$$\n\\Pi_\\mathrm{eff}(d, H) = (1-d)^2 H + \\psi^-(\\varepsilon) + G_c \\frac{d^2}{2l}\n$$\nThe state of damage $d$ evolves to minimize this potential. We find the stationary point by taking the partial derivative with respect to $d$ and setting it to zero. The term $\\psi^-(\\varepsilon)$ is independent of $d$ and does not affect the minimization.\n$$\n\\frac{\\partial \\Pi_\\mathrm{eff}}{\\partial d} = \\frac{\\partial}{\\partial d} \\left( (1-d)^2 H + G_c \\frac{d^2}{2l} \\right) = 0\n$$\n$$\n2(1-d)(-1)H + G_c \\frac{2d}{2l} = 0\n$$\n$$\n-2H(1-d) + \\frac{G_c}{l}d = 0\n$$\nSolving this algebraic equation for $d$:\n$$\n\\frac{G_c}{l}d = 2H(1-d)\n$$\n$$\nG_c d = 2lH - 2lHd\n$$\n$$\nd(G_c + 2lH) = 2lH\n$$\nThis yields the explicit expression for the damage variable as a function of the history field $H$:\n$$\nd(t) = \\frac{2lH(t)}{G_c + 2lH(t)}\n$$\nThis equation constitutes the local damage evolution law. Since $l, G_c > 0$ and $H(t) \\ge 0$, it is guaranteed that $d(t) \\in [0, 1)$. Furthermore, since $H(t)$ is a non-decreasing function of time, $d(t)$ is also non-decreasing, thus satisfying the irreversibility of damage.\n\n### 3. Algorithmic Implementation\nThe time evolution of damage, $d(t)$, for a given strain history, $\\varepsilon(t)$, can be computed via a discrete time-stepping algorithm. Initialize $H(t_0)=0$ and $d(t_0)=0$ for a pristine material at time $t_0=0$. For each subsequent time step $t_i$:\n\n1.  **Update Strain:** Obtain the strain $\\varepsilon_i = \\varepsilon(t_i)$ from the prescribed history.\n2.  **Calculate Tensile Energy:** Compute the current tensile elastic energy density: $\\psi^+_i = \\frac{1}{2} E \\max(\\varepsilon_i, 0)^2$.\n3.  **Update History Field:** Update the history field using its definition: $H_i = \\max(H_{i-1}, \\psi^+_i)$, where $H_{i-1}$ is the value from the previous time step.\n4.  **Compute Damage:** Calculate the current damage value using the derived law: $d_i = \\frac{2lH_i}{G_c + 2lH_i}$.\n\nThis procedure is repeated for all time steps in the strain history.\n\n### 4. Strain History Generation\nThe problem defines triangular strain cycles with amplitude $A$ following the path $0 \\to A \\to -A \\to 0$, with each of the three segments ($0 \\to A$, $A \\to -A$, $-A \\to 0$) discretized into a specified number of points, $N_p=50$. This is interpreted as a total of $3 \\times N_p = 150$ points per cycle. We generate the points for each segment using linear spacing and concatenate them to form the full history. For test cases with multiple cycles, the generated cycle arrays are concatenated.\n\n### 5. Non-Healing Verification\nThe problem requires an algorithmic check to verify that damage does not heal. The derived model inherently enforces this, as $d(t)$ is a monotonically increasing function of the non-decreasing history field $H(t)$. The numerical verification algorithm iterates through the computed history and checks if, for any time step $t_i$, the condition $\\varepsilon_i < \\varepsilon_{i-1}$ (unloading) is accompanied by $d_i < d_{i-1}$ (healing). Due to floating-point arithmetic, this check must use a small numerical tolerance, $\\tau$. The check is formulated as: if $\\varepsilon_i < \\varepsilon_{i-1}$ and $d_i < d_{i-1} - \\tau$, then healing has occurred. A boolean flag is set to `True` if no such healing is detected throughout the entire history. For calculations involving damage $d \\in [0,1]$, a tolerance of $\\tau=10^{-9}$ is physically reasonable.",
            "answer": "```python\nimport numpy as np\n\ndef generate_strain_history(amplitudes, n_points_per_segment):\n    \"\"\"\n    Generates a cyclic strain history based on given amplitudes.\n    Each cycle follows 0 -> A -> -A -> 0, with n_points_per_segment on each\n    of the three linear segments, for a total of 3 * n_points_per_segment points.\n    \"\"\"\n    histories = []\n    for A in amplitudes:\n        s1 = np.linspace(0, A, n_points_per_segment)\n        s2 = np.linspace(A, -A, n_points_per_segment)\n        s3 = np.linspace(-A, 0, n_points_per_segment)\n        cycle = np.concatenate((s1, s2, s3))\n        histories.append(cycle)\n    \n    if not histories:\n        return np.array([])\n        \n    strain_history = np.concatenate(histories)\n    return strain_history\n\ndef compute_damage_evolution(params, strain_history):\n    \"\"\"\n    Computes the time evolution of damage based on the derived model.\n    \"\"\"\n    E, Gc, l = params['E'], params['Gc'], params['l']\n    \n    num_steps = len(strain_history)\n    d_history = np.zeros(num_steps)\n    H_history = np.zeros(num_steps)\n    \n    H_current = 0.0\n    \n    for i in range(num_steps):\n        epsilon = strain_history[i]\n        \n        # Calculate tensile elastic energy density\n        psi_plus = 0.5 * E * (max(epsilon, 0.0))**2\n        \n        # Update history field\n        H_current = max(H_current, psi_plus)\n        H_history[i] = H_current\n        \n        # Compute damage\n        denominator = Gc + 2.0 * l * H_current\n        if denominator > 0:\n            d_history[i] = (2.0 * l * H_current) / denominator\n        else:\n            d_history[i] = 0.0\n            \n    return d_history\n\ndef check_no_healing(strain_history, d_history):\n    \"\"\"\n    Checks if damage decreases during any unloading phase.\n    A small numerical tolerance is used to account for floating point errors.\n    \"\"\"\n    tolerance = 1e-9  # Physically reasonable tolerance for damage in [0,1]\n    is_non_healing = True\n    for i in range(1, len(strain_history)):\n        # Check for unloading condition\n        if strain_history[i] < strain_history[i-1]:\n            # Check if damage has decreased (healed)\n            if d_history[i] < d_history[i-1] - tolerance:\n                is_non_healing = False\n                break\n    return is_non_healing\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # 1. Happy path cyclic reloading with increasing amplitude\n        {'E': 70e9, 'Gc': 1000, 'l': 0.01, 'amplitudes': [0.004, 0.006], 'n_points_per_segment': 50, 'special_case': None},\n        # 2. Low-amplitude repeated cycles\n        {'E': 70e9, 'Gc': 1000, 'l': 0.01, 'amplitudes': [0.0005]*5, 'n_points_per_segment': 50, 'special_case': None},\n        # 3. Pure compression history (edge case)\n        {'E': 70e9, 'Gc': 1000, 'l': 0.01, 'amplitudes': [], 'n_points_per_segment': 0, 'special_case': 'compression'},\n        # 4. Increased fracture toughness\n        {'E': 70e9, 'Gc': 5000, 'l': 0.01, 'amplitudes': [0.006, 0.006], 'n_points_per_segment': 50, 'special_case': None},\n        # 5. Reduced internal length scale\n        {'E': 70e9, 'Gc': 1000, 'l': 0.001, 'amplitudes': [0.006], 'n_points_per_segment': 50, 'special_case': None},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        if case['special_case'] == 'compression':\n            strain_history = np.full(150, -0.004)\n        else:\n            strain_history = generate_strain_history(case['amplitudes'], case['n_points_per_segment'])\n        \n        # If strain history is empty (e.g. no cycles), avoid error\n        if len(strain_history) == 0:\n            d_final = 0.0\n            is_non_healing = True\n        else:\n            d_history = compute_damage_evolution(case, strain_history)\n            d_final = d_history[-1]\n            is_non_healing = check_no_healing(strain_history, d_history)\n        \n        # Format result string without spaces as per specification\n        result_str = f\"[{d_final:.6f},{is_non_healing}]\"\n        results.append(result_str)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This practice bridges the gap between constitutive modeling and structural analysis by simulating a classic fracture mechanics experiment: the Double Cantilever Beam (DCB) test. You will combine principles from linear elastic beam theory with a Cohesive Zone Model (CZM) to predict crack propagation . This exercise develops the essential skill of coupling a local fracture criterion, defined by the CZM, with the global structural compliance and energy release rate to simulate the complete load-displacement response of a fracturing component.",
            "id": "3501282",
            "problem": "A symmetric Double Cantilever Beam (DCB) specimen composed of two identical, linearly elastic arms is opened under quasi-static, displacement-controlled loading. The interface between the arms is governed by a bilinear Cohesive Zone Model (CZM). The goal is to compute the load–displacement response via first principles and estimate the fracture energy per unit area $G_c$ from the area under the traction–separation curve. Then, use an energy release rate criterion to couple the cohesive-fracture with structural compliance and simulate crack growth. The analysis must adhere to the following physical and mathematical assumptions: small strains, small deflections, linear elasticity in the beam arms, Euler–Bernoulli kinematics, and quasi-static loading. Acronyms must be defined on first use: Double Cantilever Beam (DCB) and Cohesive Zone Model (CZM).\n\nStart from the following fundamental bases:\n- The definition of curvature and linear beam theory for Euler–Bernoulli beams (plane sections remain plane), including the relationship between bending moment and curvature $M = E I \\kappa$ and the end deflection of a cantilever beam under an end force.\n- The definition of fracture energy release rate $G$ as the energy released per newly created crack surface area, and the compliance method to express $G$ in terms of applied load $P$ and the derivative of compliance $C(a)$ with respect to crack length $a$.\n\nProblem tasks:\n1. Derive the DCB compliance $C(a)$ for two identical arms of thickness $h$ and width $b$ made of a material of Young’s modulus $E$, each behaving as an Euler–Bernoulli cantilever of length equal to the current crack length $a$. Express the opening displacement $\\delta$ as a function of the applied load $P$ and define $C(a)$ by the relation $\\delta = C(a) P$.\n2. For a bilinear traction–separation law with an initial linear elastic branch of stiffness $K$ up to a peak traction $\\sigma_{\\max}$ at separation $\\Delta_0$, followed by a linear softening branch down to zero traction at separation $\\Delta_f$, compute the fracture energy per unit area $G_c$ as the area under the traction–separation curve, i.e., $G_c = \\int_0^{\\Delta_f} t(\\Delta)\\, d\\Delta$. Do not assume any shortcut formulas; explicitly reason about the geometry of the piecewise-linear curve.\n3. Using the compliance method for energy release rate, and letting $B$ denote the specimen width $b$, express the energy release rate $G$ in terms of $P$, $B$, and $\\frac{dC}{da}$, and explain how crack advance is determined by the condition $G \\ge G_c$ under displacement control. The simulation must update the crack length $a$ in small increments $\\Delta a$ whenever $G \\ge G_c$, with the constraint $a \\le L$, where $L$ is the arm length.\n4. Implement a quasi-static displacement ramp from $\\delta = 0$ to a specified maximum $\\delta_{\\max}$ in increments $\\Delta \\delta$, computing at each increment the equilibrium load $P$ from the current compliance and crack length, checking the energy release rate $G$, and incrementing $a$ by $\\Delta a$ until $G < G_c$ or $a = L$. Assume monotonic loading and use a stable update rule.\n\nPhysical units must be strictly in the International System (SI) of units. Report loads in newtons (N), displacements in meters (m), lengths in meters (m), moduli in pascals (Pa), and fracture energy in joules per square meter (J/m$^2$). Angles do not appear. Percentages are not used.\n\nTest Suite:\nProvide results for the following three parameter sets, each specified as $(E,b,h,a_0,L,\\sigma_{\\max},\\Delta_0,\\Delta_f,\\delta_{\\max},\\Delta \\delta,\\Delta a)$ with all quantities in SI units.\n\n- Case 1 (general case, moderate toughness):\n  - $E = 70 \\times 10^9\\,\\text{Pa}$, $b = 0.02\\,\\text{m}$, $h = 0.003\\,\\text{m}$, $a_0 = 0.05\\,\\text{m}$, $L = 0.2\\,\\text{m}$,\n  - $\\sigma_{\\max} = 12 \\times 10^6\\,\\text{Pa}$, $\\Delta_0 = 2 \\times 10^{-5}\\,\\text{m}$, $\\Delta_f = 5 \\times 10^{-4}\\,\\text{m}$,\n  - $\\delta_{\\max} = 0.006\\,\\text{m}$, $\\Delta \\delta = 2 \\times 10^{-5}\\,\\text{m}$, $\\Delta a = 5 \\times 10^{-4}\\,\\text{m}$.\n- Case 2 (lower toughness and thinner arms; tests stable propagation behavior):\n  - $E = 30 \\times 10^9\\,\\text{Pa}$, $b = 0.015\\,\\text{m}$, $h = 0.0025\\,\\text{m}$, $a_0 = 0.03\\,\\text{m}$, $L = 0.18\\,\\text{m}$,\n  - $\\sigma_{\\max} = 8 \\times 10^6\\,\\text{Pa}$, $\\Delta_0 = 1.5 \\times 10^{-5}\\,\\text{m}$, $\\Delta_f = 1.5 \\times 10^{-4}\\,\\text{m}$,\n  - $\\delta_{\\max} = 0.004\\,\\text{m}$, $\\Delta \\delta = 1 \\times 10^{-5}\\,\\text{m}$, $\\Delta a = 2.5 \\times 10^{-4}\\,\\text{m}$.\n- Case 3 (stiff arms, higher peak traction; tests no propagation within the displacement range):\n  - $E = 200 \\times 10^9\\,\\text{Pa}$, $b = 0.02\\,\\text{m}$, $h = 0.004\\,\\text{m}$, $a_0 = 0.06\\,\\text{m}$, $L = 0.25\\,\\text{m}$,\n  - $\\sigma_{\\max} = 15 \\times 10^6\\,\\text{Pa}$, $\\Delta_0 = 1 \\times 10^{-5}\\,\\text{m}$, $\\Delta_f = 3 \\times 10^{-4}\\,\\text{m}$,\n  - $\\delta_{\\max} = 0.002\\,\\text{m}$, $\\Delta \\delta = 1 \\times 10^{-5}\\,\\text{m}$, $\\Delta a = 2 \\times 10^{-4}\\,\\text{m}$.\n\nRequired outputs per case:\n- The fracture energy $G_c$ in $\\text{J}/\\text{m}^2$.\n- The peak load $P_{\\text{peak}}$ attained over the displacement ramp in $\\text{N}$.\n- The final crack length $a_{\\text{final}}$ at $\\delta = \\delta_{\\max}$ in $\\text{m}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, one per test case, each inner list ordered as $[G_c,P_{\\text{peak}},a_{\\text{final}}]$, enclosed in square brackets. For example, $[[g_1,p_1,a_1],[g_2,p_2,a_2],[g_3,p_3,a_3]]$ with all entries as floating-point numbers in SI units.",
            "solution": "The problem requires the analysis of crack propagation in a symmetric Double Cantilever Beam (DCB) specimen. The solution will be developed by first establishing the fundamental relationships from linear elastic beam theory and fracture mechanics, and then integrating them into a numerical simulation algorithm as specified. All physical quantities are expressed in SI units.\n\nThe analysis is performed in four principal steps as requested:\n1. Derivation of the beam compliance as a function of crack length.\n2. Calculation of the critical fracture energy from the given cohesive law.\n3. Formulation of the energy release rate and the crack propagation criterion.\n4. Implementation of a quasi-static displacement-controlled simulation to compute the load-displacement response and track crack growth.\n\n**1. Derivation of DCB Compliance $C(a)$**\n\nThe DCB specimen is modeled as two identical cantilever beams, each of length $a$ corresponding to the current crack length. The arms have a rectangular cross-section of width $b$ and thickness $h$, and are made of a linear elastic material with Young's modulus $E$. The analysis adheres to Euler-Bernoulli beam theory, which is appropriate for slender beams under small deflections.\n\nA total opening load $P_{\\text{total}}$ is applied, which splits equally between the two arms. This standard configuration is equivalent to analyzing a single arm of length $a$ subjected to an end load $P = P_{\\text{total}}/2$ and considering an opening displacement of $\\delta = 2 \\delta_{\\text{arm}}$, where $\\delta_{\\text{arm}}$ is the deflection of a single arm. However, the problem defines $P$ as the total applied load on a single pin, so we consider each arm loaded by $P$. The total opening displacement at the loading points is the sum of the deflections of the upper and lower arms.\n\nThe deflection $\\delta_{\\text{arm}}$ at the end of a single cantilever beam of length $a$ under a transverse point load $P$ is given by the standard formula:\n$$\n\\delta_{\\text{arm}} = \\frac{P a^3}{3EI}\n$$\nwhere $I$ is the second moment of area of the beam's cross-section. For a rectangular cross-section of width $b$ and thickness $h$, $I$ is:\n$$\nI = \\frac{bh^3}{12}\n$$\nSubstituting $I$ into the deflection formula for a single arm gives:\n$$\n\\delta_{\\text{arm}} = \\frac{P a^3}{3E \\left(\\frac{bh^3}{12}\\right)} = \\frac{4Pa^3}{Ebh^3}\n$$\nThe total opening displacement $\\delta$ is the sum of the deflections of the top and bottom arms, which are identical:\n$$\n\\delta = \\delta_{\\text{arm, top}} + \\delta_{\\text{arm, bottom}} = 2\\delta_{\\text{arm}} = \\frac{8Pa^3}{Ebh^3}\n$$\nThe compliance of the DCB specimen, $C(a)$, is defined by the relationship $\\delta = C(a)P$. From the expression for $\\delta$, we can directly identify the compliance:\n$$\nC(a) = \\frac{8a^3}{Ebh^3}\n$$\n\n**2. Computation of Fracture Energy $G_c$**\n\nThe interface between the two arms is described by a bilinear Cohesive Zone Model (CZM). This model defines the traction $t$ across the interface as a function of the separation $\\Delta$. The traction-separation law is piecewise linear:\n- An initial linear elastic branch for $0 \\le \\Delta \\le \\Delta_0$:\n  $$\n  t(\\Delta) = \\frac{\\sigma_{\\max}}{\\Delta_0}\\Delta\n  $$\n- A linear softening branch for $\\Delta_0 < \\Delta \\le \\Delta_f$:\n  $$\n  t(\\Delta) = \\sigma_{\\max}\\left(\\frac{\\Delta_f - \\Delta}{\\Delta_f - \\Delta_0}\\right)\n  $$\nwhere $\\sigma_{\\max}$ is the peak traction reached at a critical separation $\\Delta_0$, and $\\Delta_f$ is the final separation at which the traction vanishes and the surfaces are completely debonded.\n\nThe fracture energy per unit area, $G_c$, is defined as the total work done to create a unit area of new fracture surface. This is equivalent to the area under the traction-separation curve:\n$$\nG_c = \\int_0^{\\Delta_f} t(\\Delta) \\, d\\Delta\n$$\nWe compute this integral by summing the areas of the two linear segments (two triangles):\n$$\nG_c = \\int_0^{\\Delta_0} \\frac{\\sigma_{\\max}}{\\Delta_0}\\Delta \\, d\\Delta + \\int_{\\Delta_0}^{\\Delta_f} \\sigma_{\\max}\\left(\\frac{\\Delta_f - \\Delta}{\\Delta_f - \\Delta_0}\\right) \\, d\\Delta\n$$\nEvaluating the first integral:\n$$\n\\int_0^{\\Delta_0} \\frac{\\sigma_{\\max}}{\\Delta_0}\\Delta \\, d\\Delta = \\frac{\\sigma_{\\max}}{\\Delta_0} \\left[\\frac{\\Delta^2}{2}\\right]_0^{\\Delta_0} = \\frac{\\sigma_{\\max}}{\\Delta_0}\\frac{\\Delta_0^2}{2} = \\frac{1}{2}\\sigma_{\\max}\\Delta_0\n$$\nEvaluating the second integral:\n$$\n\\int_{\\Delta_0}^{\\Delta_f} \\sigma_{\\max}\\left(\\frac{\\Delta_f - \\Delta}{\\Delta_f - \\Delta_0}\\right) \\, d\\Delta = \\frac{\\sigma_{\\max}}{\\Delta_f - \\Delta_0} \\left[\\Delta_f\\Delta - \\frac{\\Delta^2}{2}\\right]_{\\Delta_0}^{\\Delta_f}\n$$\n$$\n= \\frac{\\sigma_{\\max}}{\\Delta_f - \\Delta_0} \\left[ \\left(\\Delta_f^2 - \\frac{\\Delta_f^2}{2}\\right) - \\left(\\Delta_f\\Delta_0 - \\frac{\\Delta_0^2}{2}\\right) \\right]\n$$\n$$\n= \\frac{\\sigma_{\\max}}{\\Delta_f - \\Delta_0} \\left[ \\frac{\\Delta_f^2}{2} - \\Delta_f\\Delta_0 + \\frac{\\Delta_0^2}{2} \\right] = \\frac{\\sigma_{\\max}}{2(\\Delta_f - \\Delta_0)} (\\Delta_f^2 - 2\\Delta_f\\Delta_0 + \\Delta_0^2)\n$$\n$$\n= \\frac{\\sigma_{\\max}}{2(\\Delta_f - \\Delta_0)} (\\Delta_f - \\Delta_0)^2 = \\frac{1}{2}\\sigma_{\\max}(\\Delta_f - \\Delta_0)\n$$\nSumming the two parts:\n$$\nG_c = \\frac{1}{2}\\sigma_{\\max}\\Delta_0 + \\frac{1}{2}\\sigma_{\\max}(\\Delta_f - \\Delta_0) = \\frac{1}{2}\\sigma_{\\max}(\\Delta_0 + \\Delta_f - \\Delta_0) = \\frac{1}{2}\\sigma_{\\max}\\Delta_f\n$$\nThis result, corresponding to the area of a triangle with base $\\Delta_f$ and height $\\sigma_{\\max}$, represents the critical energy release rate for the material interface.\n\n**3. Energy Release Rate and Crack Growth Criterion**\n\nThe energy release rate, $G$, is the energy dissipated per unit increase in fracture area. Using the compliance method for a body of width $B=b$, $G$ is given by:\n$$\nG = \\frac{P^2}{2b} \\frac{dC}{da}\n$$\nWe must first compute the derivative of the compliance $C(a)$:\n$$\n\\frac{dC}{da} = \\frac{d}{da}\\left(\\frac{8a^3}{Ebh^3}\\right) = \\frac{24a^2}{Ebh^3}\n$$\nSubstituting this into the expression for $G$:\n$$\nG = \\frac{P^2}{2b} \\left(\\frac{24a^2}{Ebh^3}\\right) = \\frac{12P^2a^2}{Eb^2h^3}\n$$\nCrack propagation occurs when the energy release rate $G$ reaches the critical fracture energy $G_c$. The criterion for crack advance is therefore:\n$$\nG \\ge G_c\n$$\nFor a displacement-controlled test, it is useful to express $G$ in terms of the applied displacement $\\delta$. Using $P = \\delta/C(a)$:\n$$\nG = \\frac{12a^2}{Eb^2h^3} \\left(\\frac{\\delta}{C(a)}\\right)^2 = \\frac{12a^2\\delta^2}{Eb^2h^3 C(a)^2} = \\frac{12a^2\\delta^2}{Eb^2h^3} \\left(\\frac{Ebh^3}{8a^3}\\right)^2 = \\frac{12a^2\\delta^2}{Eb^2h^3} \\frac{E^2b^2h^6}{64a^6} = \\frac{12E h^3 \\delta^2}{64a^4}\n$$\n$$\nG = \\frac{3E h^3 \\delta^2}{16a^4}\n$$\nThis expression shows that for a fixed displacement $\\delta$, $G$ decreases rapidly as the crack length $a$ increases (as $a^{-4}$). This indicates that crack propagation in a displacement-controlled DCB test is stable.\n\n**4. Algorithmic Implementation for Quasi-Static Simulation**\n\nA numerical simulation is implemented to trace the load-displacement response and crack growth. The loading is applied as a sequence of small displacement increments $\\Delta\\delta$.\n\nThe algorithm proceeds as follows:\n1. Initialize parameters for the specific test case: $E, b, h, a_0, L, G_c, \\delta_{\\max}, \\Delta\\delta, \\Delta a$.\n2. Initialize state variables: current crack length $a \\leftarrow a_0$, peak load $P_{\\text{peak}} \\leftarrow 0$.\n3. Begin the main loop, incrementing the applied displacement $\\delta$ from $\\Delta\\delta$ to $\\delta_{\\max}$.\n4. Within each displacement step (for a fixed $\\delta$), enter an inner loop to check for crack propagation and find the stable equilibrium state.\n   a. Calculate the current compliance $C(a)$ and the corresponding trial load $P = \\delta/C(a)$.\n   b. Calculate the energy release rate $G$ using the current values of $P$ and $a$.\n   c. Check the propagation condition: If $G \\ge G_c$ and the crack has not reached the end of the specimen ($a < L$), advance the crack by one increment: $a \\leftarrow \\min(a + \\Delta a, L)$.\n   d. Repeat the inner loop (recalculating $C, P, G$) until the condition $G < G_c$ is met or $a=L$. This signifies that the crack has arrested at a new stable length for the current displacement $\\delta$.\n5. Once the inner loop terminates, the final equilibrium load $P$ for the current displacement step $\\delta$ is known. Update the peak load encountered so far: $P_{\\text{peak}} \\leftarrow \\max(P_{\\text{peak}}, P)$.\n6. Continue the outer loop to the next displacement increment.\n7. After the simulation completes (i.e., $\\delta$ reaches $\\delta_{\\max}$), the final values of $G_c$, $P_{\\text{peak}}$, and $a_{\\text{final}}$ are reported.\nThis procedure correctly models the quasi-static evolution of the system, where at each infinitesimally slow loading step, the crack propagates until it finds a new configuration where the energy release rate is balanced by the material's fracture toughness.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DCB fracture mechanics problem for three test cases.\n    \"\"\"\n    \n    # Test cases defined as (E, b, h, a0, L, sigma_max, Delta_0, Delta_f, delta_max, delta_delta, delta_a)\n    # All units are SI units.\n    test_cases = [\n        # Case 1 (general case, moderate toughness)\n        (70e9, 0.02, 0.003, 0.05, 0.2, 12e6, 2e-5, 5e-4, 0.006, 2e-5, 5e-4),\n        # Case 2 (lower toughness and thinner arms; tests stable propagation behavior)\n        (30e9, 0.015, 0.0025, 0.03, 0.18, 8e6, 1.5e-5, 1.5e-4, 0.004, 1e-5, 2.5e-4),\n        # Case 3 (stiff arms, higher peak traction; tests no propagation within the displacement range)\n        (200e9, 0.02, 0.004, 0.06, 0.25, 15e6, 1e-5, 3e-4, 0.002, 1e-5, 2e-4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E, b, h, a0, L, sigma_max, _, Delta_f, delta_max, delta_delta, delta_a = case\n        \n        # --- Task 2: Compute fracture energy Gc ---\n        # Gc is the area under the bilinear traction-separation curve, which is a triangle.\n        # Gc = 0.5 * sigma_max * Delta_f\n        Gc = 0.5 * sigma_max * Delta_f\n\n        # --- Task 4: Implement the quasi-static simulation ---\n        a = a0\n        p_peak = 0.0\n        \n        # Discretize the displacement ramp\n        num_steps = int(round(delta_max / delta_delta))\n        displacements = np.linspace(delta_delta, delta_max, num=num_steps)\n\n        for delta in displacements:\n            # Inner loop for crack propagation at a fixed displacement 'delta'\n            # The crack extends until G < Gc, reaching a stable length for this 'delta'\n            while True:\n                if a >= L:\n                    # No more crack growth possible if length limit is reached\n                    break\n\n                # --- Task 1: Derive DCB compliance C(a) ---\n                # C(a) = 8 * a^3 / (E * b * h^3)\n                compliance = (8.0 * a**3) / (E * b * h**3)\n                \n                # Calculate equilibrium load P for the current displacement and crack length\n                P = delta / compliance\n\n                # --- Task 3: Energy Release Rate G and Crack Growth Criterion ---\n                # G = (12 * P^2 * a^2) / (E * b^2 * h^3)\n                G = (12.0 * P**2 * a**2) / (E * b**2 * h**3)\n\n                # Check for crack propagation\n                if G >= Gc:\n                    a += delta_a\n                    # Clamp crack length to the specimen length\n                    a = min(a, L)\n                else:\n                    # Equilibrium is reached for this displacement step\n                    break\n\n            # After reaching equilibrium, calculate the final load for this step\n            final_compliance = (8.0 * a**3) / (E * b * h**3)\n            final_P = delta / final_compliance\n            \n            # Update the peak load\n            p_peak = max(p_peak, final_P)\n\n        a_final = a\n        \n        results.append([Gc, p_peak, a_final])\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[g1,p1,a1],[g2,p2,a2],[g3,p3,a3]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}