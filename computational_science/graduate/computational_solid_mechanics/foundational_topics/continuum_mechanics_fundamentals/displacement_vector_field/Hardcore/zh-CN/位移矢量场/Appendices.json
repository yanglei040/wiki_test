{
    "hands_on_practices": [
        {
            "introduction": "变形梯度 $ \\mathbf{F} $ 是连接材料参考构型与当前构型的桥梁，是连续介质力学的基石。本练习将通过一个给定的非均匀位移场，让您亲手计算这一核心物理量，并求解其行列式（即雅可比行列式 $ J = \\det \\mathbf{F} $），它描述了局部体积的变化。掌握这一基本计算，是进一步分析应变和应力的关键第一步。",
            "id": "3559304",
            "problem": "一个三维超弹性体占据一个由坐标 $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$ 描述的参考构型。该运动根据运动学定义 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{u}(\\mathbf{X})$ 将每个物质点映射到其当前位置 $\\mathbf{x}(\\mathbf{X})$，其中 $\\mathbf{u}(\\mathbf{X})$ 是位移矢量场。对于位移场\n$$\n\\mathbf{u}(\\mathbf{X}) = \\big(a X_{1}^{2},\\, b X_{1} X_{2},\\, c X_{3}\\big),\n$$\n其中 $a$、$b$ 和 $c$ 为实常数，使用变形梯度 $\\mathbf{F}(\\mathbf{X}) = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$ 的基本定义和位移梯度 $\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X})$（其分量为 $\\frac{\\partial u_{i}}{\\partial X_{j}}$）的定义来：\n\n- 推导位移梯度张量 $\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X})$。\n- 从运动学定义推导变形梯度 $\\mathbf{F}(\\mathbf{X})$。\n- 在任意参考点 $\\mathbf{X}$ 处计算雅可比行列式 $\\det \\mathbf{F}(\\mathbf{X})$。\n\n将雅可比行列式的最终答案表示为关于 $a$、$b$、$c$ 和 $\\mathbf{X}$ 相关分量的单个闭式解析表达式。不需要进行数值舍入。雅可比行列式是无量纲的；最终表达式中不要包含单位。",
            "solution": "经审查，问题陈述有效。这是一个连续介质力学中适定的问题，基于既定原理，并为获得唯一解提供了所有必要信息。\n\n该问题要求基于给定的位移场，推导超弹性体的几个运动学量。我们已知参考坐标 $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$ 和位移矢量场 $\\mathbf{u}(\\mathbf{X})$。位移矢量场的分量如下：\n$$\nu_{1}(\\mathbf{X}) = a X_{1}^{2}\n$$\n$$\nu_{2}(\\mathbf{X}) = b X_{1} X_{2}\n$$\n$$\nu_{3}(\\mathbf{X}) = c X_{3}\n$$\n其中 $a$、$b$ 和 $c$ 是实常数。\n\n第一个任务是推导位移梯度张量，记为 $\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X})$。该二阶张量的分量由 $(\\nabla_{\\mathbf{X}} \\mathbf{u})_{ij} = \\frac{\\partial u_{i}}{\\partial X_{j}}$ 给出。我们通过对位移分量关于参考坐标求偏导数，来计算九个分量中的每一个。\n\n对于第一个分量 $u_{1}$：\n$$\n\\frac{\\partial u_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(a X_{1}^{2}) = 2 a X_{1}\n$$\n$$\n\\frac{\\partial u_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(a X_{1}^{2}) = 0\n$$\n$$\n\\frac{\\partial u_{1}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(a X_{1}^{2}) = 0\n$$\n\n对于第二个分量 $u_{2}$：\n$$\n\\frac{\\partial u_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(b X_{1} X_{2}) = b X_{2}\n$$\n$$\n\\frac{\\partial u_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(b X_{1} X_{2}) = b X_{1}\n$$\n$$\n\\frac{\\partial u_{2}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(b X_{1} X_{2}) = 0\n$$\n\n对于第三个分量 $u_{3}$：\n$$\n\\frac{\\partial u_{3}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(c X_{3}) = 0\n$$\n$$\n\\frac{\\partial u_{3}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(c X_{3}) = 0\n$$\n$$\n\\frac{\\partial u_{3}}{\\partial X_{3}} = \\frac{\\partial}{\\partial X_{3}}(c X_{3}) = c\n$$\n\n将这些分量组合成一个矩阵，我们得到位移梯度张量 $\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X})$：\n$$\n\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X}) =\n\\begin{pmatrix}\n\\frac{\\partial u_{1}}{\\partial X_{1}}  \\frac{\\partial u_{1}}{\\partial X_{2}}  \\frac{\\partial u_{1}}{\\partial X_{3}} \\\\\n\\frac{\\partial u_{2}}{\\partial X_{1}}  \\frac{\\partial u_{2}}{\\partial X_{2}}  \\frac{\\partial u_{2}}{\\partial X_{3}} \\\\\n\\frac{\\partial u_{3}}{\\partial X_{1}}  \\frac{\\partial u_{3}}{\\partial X_{2}}  \\frac{\\partial u_{3}}{\\partial X_{3}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2 a X_{1}  0  0 \\\\\nb X_{2}  b X_{1}  0 \\\\\n0  0  c\n\\end{pmatrix}\n$$\n\n第二个任务是推导变形梯度张量 $\\mathbf{F}(\\mathbf{X})$。关联当前位置 $\\mathbf{x}$ 和参考位置 $\\mathbf{X}$ 的运动学定义是 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{u}(\\mathbf{X})$。变形梯度的定义为 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$。应用此定义：\n$$\n\\mathbf{F}(\\mathbf{X}) = \\frac{\\partial}{\\partial \\mathbf{X}} \\left( \\mathbf{X} + \\mathbf{u}(\\mathbf{X}) \\right) = \\frac{\\partial \\mathbf{X}}{\\partial \\mathbf{X}} + \\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{X}}\n$$\n项 $\\frac{\\partial \\mathbf{X}}{\\partial \\mathbf{X}}$ 是恒等映射的梯度，即二阶单位张量 $\\mathbf{I}$。其分量为 $(\\mathbf{I})_{ij} = \\frac{\\partial X_{i}}{\\partial X_{j}} = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克符号。项 $\\frac{\\partial \\mathbf{u}}{\\partial \\mathbf{X}}$ 是我们刚刚推导出的位移梯度张量 $\\nabla_{\\mathbf{X}} \\mathbf{u}(\\mathbf{X})$。因此，变形梯度由以下关系式给出：\n$$\n\\mathbf{F} = \\mathbf{I} + \\nabla_{\\mathbf{X}} \\mathbf{u}\n$$\n代入 $\\mathbf{I}$ 和 $\\nabla_{\\mathbf{X}} \\mathbf{u}$ 的矩阵形式：\n$$\n\\mathbf{F}(\\mathbf{X}) =\n\\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n+\n\\begin{pmatrix}\n2 a X_{1}  0  0 \\\\\nb X_{2}  b X_{1}  0 \\\\\n0  0  c\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 + 2 a X_{1}  0  0 \\\\\nb X_{2}  1 + b X_{1}  0 \\\\\n0  0  1 + c\n\\end{pmatrix}\n$$\n\n第三个也是最后一个任务是计算雅可比行列式，$J = \\det \\mathbf{F}(\\mathbf{X})$。雅可比行列式衡量了从参考构型到当前构型的局部体积变化。我们计算 $\\mathbf{F}$ 的 $3 \\times 3$ 矩阵的行列式。\n$\\mathbf{F}$ 的矩阵是一个下三角矩阵。行列式的一个基本性质是，三角矩阵（无论是上三角还是下三角）的行列式是其对角线元素的乘积。\n因此，我们可以写出：\n$$\n\\det \\mathbf{F}(\\mathbf{X}) = (1 + 2 a X_{1})(1 + b X_{1})(1 + c)\n$$\n该表达式给出了在任意参考点 $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$ 处的雅可比行列式，其是关于常数 $a$、$b$、$c$ 和坐标 $X_{1}$ 的函数。它与 $X_{2}$ 和 $X_{3}$ 无关。",
            "answer": "$$\n\\boxed{(1 + 2aX_{1})(1 + bX_{1})(1+c)}\n$$"
        },
        {
            "introduction": "当我们掌握了变形梯度后，下一步便是计算应变，但选择何种应变度量至关重要。本练习通过一个看似简单的刚体转动案例，深刻揭示了无穷小应变张量$\\boldsymbol{\\varepsilon}$与几何精确的格林-拉格朗日应变张量$\\mathbf{E}$之间的本质区别。您将通过计算发现，即使在线性理论下应变为零，对于有限转动$\\mathbf{E}$仍不为零，这清晰地展示了为何非线性项对于精确描述运动学至关重要。",
            "id": "3559297",
            "problem": "考虑一个处于其参考构型中的均匀体，其物质点位置矢量为 $\\mathbf{X} = (X_{1}, X_{2}, X_{3})$。给定位移矢量场为 $\\mathbf{u}(\\mathbf{X}) = (\\theta X_{2}, -\\theta X_{1}, 0)$，其中 $\\theta$ 是一个有限常数角。当前构型由 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{u}(\\mathbf{X})$ 给出。使用连续介质力学的基本运动学定义，推导变形梯度 $\\mathbf{F}$ 和 Green-Lagrange 应变张量 $\\mathbf{E}$。然后，从右 Cauchy–Green 变形张量和无穷小应变张量的定义出发，从第一性原理上解释为什么当 $\\theta$ 为有限值时，Green-Lagrange 应变不为零，尽管从此位移场计算得到的位移梯度的对称部分（即无穷小应变）为零。\n\n您的推导必须基于以下定义：\n- 变形梯度定义为 $\\mathbf{F} = \\partial \\mathbf{x} / \\partial \\mathbf{X}$。\n- 右 Cauchy–Green 变形张量定义为 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$。\n- Green–Lagrange 应变张量定义为 $\\mathbf{E} = \\tfrac{1}{2}(\\mathbf{C} - \\mathbf{I})$，其中 $\\mathbf{I}$ 是单位张量。\n- 无穷小（线性化）应变张量为 $\\boldsymbol{\\varepsilon}^{\\text{lin}} = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}})$。\n\n假设角度 $\\theta$ 以弧度为单位。无需进行数值舍入。请以 $3 \\times 3$ 矩阵表达式的形式给出 $\\mathbf{E}$ 关于 $\\theta$ 的最终答案，并以弧度表示该角度。除了这个最终答案，您的解答还必须推导出 $\\mathbf{F}$ 并包含所要求的解释。",
            "solution": "问题陈述经评估有效。它在连续介质力学方面有科学依据，是适定的、客观的。它提供了推导所求量和阐述解释所需的所有必要定义和数据。\n\n该问题要求针对给定的位移场，推导变形梯度 $\\mathbf{F}$ 和 Green-Lagrange 应变张量 $\\mathbf{E}$，然后解释该场下 Green-Lagrange 应变与无穷小应变之间的差异。\n\n参考构型中的位置矢量为 $\\mathbf{X} = (X_1, X_2, X_3)$。\n给定的位移矢量场为 $\\mathbf{u}(\\mathbf{X}) = (\\theta X_2, -\\theta X_1, 0)$，其中 $\\theta$ 是一个有限常数。\n当前构型中的位置矢量由 $\\mathbf{x}(\\mathbf{X}) = \\mathbf{X} + \\mathbf{u}(\\mathbf{X})$ 给出。\n用分量形式表示，当前坐标 $x_i$ 为：\n$$x_1 = X_1 + u_1(\\mathbf{X}) = X_1 + \\theta X_2$$\n$$x_2 = X_2 + u_2(\\mathbf{X}) = X_2 - \\theta X_1$$\n$$x_3 = X_3 + u_3(\\mathbf{X}) = X_3 + 0 = X_3$$\n\n首先，我们推导变形梯度 $\\mathbf{F}$，其定义为 $F_{ij} = \\frac{\\partial x_i}{\\partial X_j}$。\n\n$\\mathbf{F}$ 的分量计算如下：\n$F_{11} = \\frac{\\partial x_1}{\\partial X_1} = \\frac{\\partial}{\\partial X_1}(X_1 + \\theta X_2) = 1$\n$F_{12} = \\frac{\\partial x_1}{\\partial X_2} = \\frac{\\partial}{\\partial X_2}(X_1 + \\theta X_2) = \\theta$\n$F_{13} = \\frac{\\partial x_1}{\\partial X_3} = \\frac{\\partial}{\\partial X_3}(X_1 + \\theta X_2) = 0$\n\n$F_{21} = \\frac{\\partial x_2}{\\partial X_1} = \\frac{\\partial}{\\partial X_1}(X_2 - \\theta X_1) = -\\theta$\n$F_{22} = \\frac{\\partial x_2}{\\partial X_2} = \\frac{\\partial}{\\partial X_2}(X_2 - \\theta X_1) = 1$\n$F_{23} = \\frac{\\partial x_2}{\\partial X_3} = \\frac{\\partial}{\\partial X_3}(X_2 - \\theta X_1) = 0$\n\n$F_{31} = \\frac{\\partial x_3}{\\partial X_1} = \\frac{\\partial}{\\partial X_1}(X_3) = 0$\n$F_{32} = \\frac{\\partial x_3}{\\partial X_2} = \\frac{\\partial}{\\partial X_2}(X_3) = 0$\n$F_{33} = \\frac{\\partial x_3}{\\partial X_3} = \\frac{\\partial}{\\partial X_3}(X_3) = 1$\n\n将这些分量组合成矩阵形式，变形梯度为：\n$$\\mathbf{F} = \\begin{pmatrix} 1  \\theta  0 \\\\ -\\theta  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\n\n接下来，我们推导 Green–Lagrange 应变张量 $\\mathbf{E}$。这需要用到右 Cauchy–Green 变形张量 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$。\n$\\mathbf{F}$ 的转置为：\n$$\\mathbf{F}^{\\mathsf{T}} = \\begin{pmatrix} 1  -\\theta  0 \\\\ \\theta  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\n现在，我们计算矩阵乘积 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$：\n$$\\mathbf{C} = \\begin{pmatrix} 1  -\\theta  0 \\\\ \\theta  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  \\theta  0 \\\\ -\\theta  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\n$$= \\begin{pmatrix} (1)(1) + (-\\theta)(-\\theta) + (0)(0)  (1)(\\theta) + (-\\theta)(1) + (0)(0)  (1)(0) + (-\\theta)(0) + (0)(1) \\\\ (\\theta)(1) + (1)(-\\theta) + (0)(0)  (\\theta)(\\theta) + (1)(1) + (0)(0)  (\\theta)(0) + (1)(0) + (0)(1) \\\\ (0)(1) + (0)(-\\theta) + (1)(0)  (0)(\\theta) + (0)(1) + (1)(0)  (0)(0) + (0)(0) + (1)(1) \\end{pmatrix}$$\n$$= \\begin{pmatrix} 1 + \\theta^2  0  0 \\\\ 0  1 + \\theta^2  0 \\\\ 0  0  1 \\end{pmatrix}$$\nGreen–Lagrange 应变张量定义为 $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$，其中 $\\mathbf{I}$ 是二阶单位张量。\n$$\\mathbf{E} = \\frac{1}{2} \\left( \\begin{pmatrix} 1 + \\theta^2  0  0 \\\\ 0  1 + \\theta^2  0 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\right)$$\n$$\\mathbf{E} = \\frac{1}{2} \\begin{pmatrix} \\theta^2  0  0 \\\\ 0  \\theta^2  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}\\theta^2  0  0 \\\\ 0  \\frac{1}{2}\\theta^2  0 \\\\ 0  0  0 \\end{pmatrix}$$\n对于任何有限的非零角度 $\\theta$，Green–Lagrange 应变张量 $\\mathbf{E}$ 均不为零。\n\n现在，我们研究无穷小应变张量 $\\boldsymbol{\\varepsilon}^{\\text{lin}}$ 并解释其差异。\n首先，我们计算位移梯度张量 $\\nabla \\mathbf{u}$，其分量为 $(\\nabla \\mathbf{u})_{ij} = \\frac{\\partial u_i}{\\partial X_j}$。\n$u_1 = \\theta X_2$, $u_2 = -\\theta X_1$, $u_3 = 0$。\n$(\\nabla \\mathbf{u})_{11} = \\frac{\\partial u_1}{\\partial X_1} = 0$, $(\\nabla \\mathbf{u})_{12} = \\frac{\\partial u_1}{\\partial X_2} = \\theta$, $(\\nabla \\mathbf{u})_{13} = \\frac{\\partial u_1}{\\partial X_3} = 0$\n$(\\nabla \\mathbf{u})_{21} = \\frac{\\partial u_2}{\\partial X_1} = -\\theta$, $(\\nabla \\mathbf{u})_{22} = \\frac{\\partial u_2}{\\partial X_2} = 0$, $(\\nabla \\mathbf{u})_{23} = \\frac{\\partial u_2}{\\partial X_3} = 0$\n$(\\nabla \\mathbf{u})_{31} = \\frac{\\partial u_3}{\\partial X_1} = 0$, $(\\nabla \\mathbf{u})_{32} = \\frac{\\partial u_3}{\\partial X_2} = 0$, $(\\nabla \\mathbf{u})_{33} = \\frac{\\partial u_3}{\\partial X_3} = 0$\n因此，位移梯度张量为：\n$$\\nabla \\mathbf{u} = \\begin{pmatrix} 0  \\theta  0 \\\\ -\\theta  0  0 \\\\ 0  0  0 \\end{pmatrix}$$\n该张量是纯斜对称的，即 $(\\nabla \\mathbf{u})^{\\mathsf{T}} = -\\nabla \\mathbf{u}$。\n\n无穷小应变张量是位移梯度的对称部分：\n$$\\boldsymbol{\\varepsilon}^{\\text{lin}} = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}})$$\n代入计算出的 $\\nabla \\mathbf{u}$：\n$$\\boldsymbol{\\varepsilon}^{\\text{lin}} = \\frac{1}{2} \\left( \\begin{pmatrix} 0  \\theta  0 \\\\ -\\theta  0  0 \\\\ 0  0  0 \\end{pmatrix} + \\begin{pmatrix} 0  -\\theta  0 \\\\ \\theta  0  0 \\\\ 0  0  0 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\mathbf{0}$$\n所以，无穷小应变为零张量。\n\n这一看似矛盾的现象的解释在于 Green–Lagrange 应变张量 $\\mathbf{E}$ 和无穷小应变张量 $\\boldsymbol{\\varepsilon}^{\\text{lin}}$ 之间的基本关系。该关系可以通过将 $\\mathbf{F} = \\mathbf{I} + \\nabla \\mathbf{u}$ 代入 $\\mathbf{E}$ 的定义中推导得出。\n$$\\mathbf{E} = \\frac{1}{2}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} - \\mathbf{I}) = \\frac{1}{2}((\\mathbf{I} + \\nabla \\mathbf{u})^{\\mathsf{T}}(\\mathbf{I} + \\nabla \\mathbf{u}) - \\mathbf{I})$$\n$$\\mathbf{E} = \\frac{1}{2}((\\mathbf{I} + (\\nabla \\mathbf{u})^{\\mathsf{T}})(\\mathbf{I} + \\nabla \\mathbf{u}) - \\mathbf{I})$$\n$$\\mathbf{E} = \\frac{1}{2}(\\mathbf{I} + \\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}} + (\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u} - \\mathbf{I})$$\n$$\\mathbf{E} = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}}) + \\frac{1}{2}(\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u}$$\n认识到第一项是 $\\boldsymbol{\\varepsilon}^{\\text{lin}}$，我们有：\n$$\\mathbf{E} = \\boldsymbol{\\varepsilon}^{\\text{lin}} + \\frac{1}{2}(\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u}$$\n这个方程表明，Green-Lagrange 应变张量由一个线性部分（即无穷小应变张量）和一个非线性（二次）部分 $\\frac{1}{2}(\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u}$ 组成。\n\n对于给定的问题：\n1.  线性部分 $\\boldsymbol{\\varepsilon}^{\\text{lin}}$ 为零。在线性化理论中，零应变张量意味着刚体运动（平移加旋转）。斜对称的位移梯度表示无穷小转动，线性化理论认为这是无应变的。\n2.  然而，问题指明 $\\theta$ 是一个*有限*角。这意味着位移梯度不是无穷小的，二次项 $(\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u}$ 不能被忽略。\n3.  让我们明确地计算这个非线性项：\n$$(\\nabla \\mathbf{u})^{\\mathsf{T}} \\nabla \\mathbf{u} = \\begin{pmatrix} 0  -\\theta  0 \\\\ \\theta  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  \\theta  0 \\\\ -\\theta  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} \\theta^2  0  0 \\\\ 0  \\theta^2  0 \\\\ 0  0  0 \\end{pmatrix}$$\n4.  将此代入 $\\mathbf{E}$ 的完整表达式中：\n$$\\mathbf{E} = \\mathbf{0} + \\frac{1}{2} \\begin{pmatrix} \\theta^2  0  0 \\\\ 0  \\theta^2  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}\\theta^2  0  0 \\\\ 0  \\frac{1}{2}\\theta^2  0 \\\\ 0  0  0 \\end{pmatrix}$$\n这个结果与我们最初对 $\\mathbf{E}$ 的计算相符。\n\n总之，无穷小应变张量 $\\boldsymbol{\\varepsilon}^{\\text{lin}}$ 仅当位移梯度 $\\nabla \\mathbf{u}$ 的所有分量都远小于1时才是一个有效的近似。对于给定的位移场，当 $\\theta$ 为有限值时，它代表一个具有大梯度（特别是大的转动分量）的变形。线性化应变张量错误地将此视为无应变的刚体运动。而 Green–Lagrange 应变张量 $\\mathbf{E}$ 是一个几何上精确的度量，它正确地考虑了由有限转动和位移引起的非线性。$\\mathbf{E}$ 的非零分量表明，与线性理论的预测相反，给定的位移场确实会引起应变。具体来说，它导致了沿 $X_1$ 和 $X_2$ 方向的拉伸，这被其定义中的二次项所捕捉。这凸显了线性应变理论在存在有限转动时的基本局限性。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}\\theta^2  0  0 \\\\\n0  \\frac{1}{2}\\theta^2  0 \\\\\n0  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论的最终目的是指导实践，本练习将解析力学与计算方法紧密相连。有限元方法（FEM）将连续的位移场离散化，我们必须有方法验证其正确性。本练习引入了计算力学中的一个基本基准测试——“分片检验”（Patch Test），以验证您选择的单元列式能否精确地重现由线性位移场产生的恒定应变状态。成功通过此检验是保证有限元程序收敛性和可靠性的必要条件。",
            "id": "3559279",
            "problem": "您必须设计、论证并实现一个二维面片检验 (patch test)，该检验在小应变线性弹性的背景下，验证在结构化网格上的双线性四边形单元（通常表示为 $Q_{1}$）能够精确再现一个线性位移矢量场。起点必须是虚功原理、对称小应变张量的定义，以及平面应力和平面应变下的线性弹性 Cauchy 应力-应变关系。您的任务是构建一个计算实验，在该实验中，当边界牵引力从精确应力场一致地导出，并且刚体模式受到最小约束时，有限元离散化必须能够以机器精度精确再现线性位移场。\n\n问题设置如下。考虑一个矩形域 $\\Omega = [0,L_{x}] \\times [0,L_{y}]$，该域通过 $Q_{1}$ 双线性四边形单元的结构化网格进行离散化。未知量是位移矢量场 $\\mathbf{u}(x,y) = [u(x,y), v(x,y)]^{\\mathsf{T}}$。假设小应变，采用对称应变定义 $\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right)$，单位厚度，无体力，并且在边界 $\\partial \\Omega$ 上规定了边界牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n}$，其中 $\\mathbf{n}$ 是外法向单位矢量，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力。对于本构行为，使用线性弹性：Cauchy 应力 $\\boldsymbol{\\sigma}$ 通过适用于平面应变或平面应力的相应线性弹性定律与 $\\boldsymbol{\\varepsilon}$ 相关联。所有材料常数必须采用国际单位制（SI 单位）：杨氏模量 $E$（单位为帕斯卡）和无量纲的泊松比 $\\nu$。\n\n您的有限元离散化必须仅基于：\n- 小应变线性弹性的虚功原理。\n- 对称应变张量的定义。\n- 平面应变和平面应力的线性弹性 Cauchy 应力-应变关系（胡克定律）。\n- 使用足以对出现的所有多项式进行积分的精确数值积分，即 Gauss 求积。\n\n您必须验证对以下形式的线性位移场的精确再现：\n$\\displaystyle u(x,y) = a_{0} + a_{1}\\,x + a_{2}\\,y,\\quad v(x,y) = b_{0} + b_{1}\\,x + b_{2}\\,y,$\n其中 $a_{0},a_{1},a_{2},b_{0},b_{1},b_{2}$ 是常数。对于该场，对称应变在 $\\Omega$ 中是恒定的，因此根据胡克定律计算出的应力也是恒定的。使用此恒定应力在 $\\partial \\Omega$ 的每个部分上定义边界牵引力 $\\mathbf{t}=\\boldsymbol{\\sigma}\\mathbf{n}$。通过在节点 $(x,y)=(0,0)$ 处为两个分量规定精确位移，并在节点 $(x,y)=(L_{x},0)$ 处规定精确垂直位移，来消除刚体模式。不允许设置其他位移边界条件。所有其他边界必须是与 $\\mathbf{t}=\\boldsymbol{\\sigma}\\mathbf{n}$ 一致的牵引力边界。假设单位厚度 $t=1$。\n\n实现要求：\n- 使用 $Q_{1}$ 单元组装全局刚度矩阵，每个单元上使用对称小应变-位移矩阵和精确的 Gauss 求积（对内部使用 $2\\times 2$ Gauss 法则，对每个边界边使用 $2$ 点 Gauss 法则）。\n- 通过沿边界边积分 $\\mathbf{N}^{\\mathsf{T}}\\mathbf{t}$ 来组装一致的全局牵引力向量，其中 $\\mathbf{N}$ 是边的 $Q_{1}$ 形函数矩阵。\n- 在线性系统中通过直接消元法（行和列修改）施加位移约束，并保持对称性。\n- 求解线性系统以获得节点位移向量，并从规定的线性场计算节点精确位移。\n- 计算所有位移分量的最大节点位移绝对误差 $\\max_{i}| U_{i}^{\\text{num}} - U_{i}^{\\text{exact}}|$。此误差必须以米为单位报告。\n\n测试套件：\n评估以下四种情况中每一种的最大节点位移绝对误差。所有长度单位为米，杨氏模量单位为帕斯卡。角度单位不适用。\n\n- 情况 1（理想情况，单单元，平面应变）：\n  - $N_{x}=1$，$N_{y}=1$，$L_{x}=1.0$，$L_{y}=1.0$，$E=1.00\\times 10^{3}$，$\\nu=0.30$，平面应变。\n  - 系数：$a_{0}=0.10$，$a_{1}=0.20$，$a_{2}=-0.30$，$b_{0}=-0.05$，$b_{1}=0.40$，$b_{2}=0.25$。\n\n- 情况 2（矩形网格，平面应力）：\n  - $N_{x}=2$，$N_{y}=3$，$L_{x}=2.0$，$L_{y}=1.0$，$E=2.10\\times 10^{5}$，$\\nu=0.29$，平面应力。\n  - 系数：$a_{0}=-0.02$，$a_{1}=0.15$，$a_{2}=0.05$，$b_{0}=0.03$，$b_{1}=-0.10$，$b_{2}=0.12$。\n\n- 情况 3（高纵横比单元，平面应变）：\n  - $N_{x}=4$，$N_{y}=1$，$L_{x}=8.0$，$L_{y}=1.0$，$E=7.00\\times 10^{4}$，$\\nu=0.33$，平面应变。\n  - 系数：$a_{0}=0.00$，$a_{1}=0.05$，$a_{2}=1.50$，$b_{0}=0.01$，$b_{1}=-1.20$，$b_{2}=0.02$。\n\n- 情况 4（中等密度网格，平面应力）：\n  - $N_{x}=3$，$N_{y}=3$，$L_{x}=1.5$，$L_{y}=1.5$，$E=3.00\\times 10^{5}$，$\\nu=0.25$，平面应力。\n  - 系数：$a_{0}=0.005$，$a_{1}=-0.08$，$a_{2}=0.06$，$b_{0}=-0.01$，$b_{1}=0.07$，$b_{2}=-0.09$。\n\n最终输出规范：\n- 您的程序必须为四种情况中的每一种计算最大节点位移绝对误差（以米为单位），表示为浮点数。\n- 您的程序必须生成单行输出，其中包含一个逗号分隔的列表，并用方括号括起，例如 `[r_1,r_2,r_3,r_4]`，其中 $r_k$ 是情况 $k$ 的结果。",
            "solution": "所提出的问题是计算固体力学中一个经典的验证程序，称为面片检验 (patch test)。其目的是验证有限元公式能否精确再现恒定应变状态。对于基于位移的有限元方法，这是收敛的必要条件。该问题提法恰当，科学上合理，并为构建有效的计算实验提供了所有必要信息。我们将着手解决。\n\n### 1. 理论基础：虚功原理\n\n有限元模型的基础是虚功原理 (PVW)，它是力学平衡方程的弱形式。对于一个占据域 $\\Omega$、边界为 $\\partial\\Omega$、受到体力 $\\mathbf{f}$ 和在边界部分 $\\partial\\Omega_t$ 上受到表面牵引力 $\\mathbf{t}$ 的物体，虚功原理指出，对于任何运动学上容许的虚位移场 $\\delta\\mathbf{u}$，内虚功必须等于外虚功：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV = \\int_{\\Omega} \\mathbf{f} \\cdot \\delta\\mathbf{u} \\, dV + \\int_{\\partial\\Omega_t} \\mathbf{t} \\cdot \\delta\\mathbf{u} \\, dS\n$$\n这里，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量，定义为虚位移梯度的对称部分，即 $\\delta\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla(\\delta\\mathbf{u}) + (\\nabla(\\delta\\mathbf{u}))^{\\mathsf{T}})$。问题指定无体力（$\\mathbf{f}=\\mathbf{0}$）和单位厚度，因此体积和面积分分别简化为面积和线积分：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dA = \\int_{\\partial\\Omega_t} \\mathbf{t} \\cdot \\delta\\mathbf{u} \\, dL\n$$\n\n### 2. 有限元离散化\n\n我们将域 $\\Omega$ 离散化为不重叠的双线性四边形单元（$Q_1$）网格。在每个单元 $e$ 内，位移场 $\\mathbf{u}(\\mathbf{x})$ 通过使用形函数 $\\mathbf{N}(\\mathbf{x})$ 插值节点位移 $\\mathbf{d}^e$ 来近似：\n$$\n\\mathbf{u}(\\mathbf{x}) \\approx \\mathbf{u}^h(\\mathbf{x}) = \\mathbf{N}(\\mathbf{x}) \\mathbf{d}^e\n$$\n对于一个有四个节点的 $Q_1$ 单元，矩阵的结构如下：\n$$\n\\mathbf{N} = \\begin{bmatrix} N_1  0  N_2  0  N_3  0  N_4  0 \\\\ 0  N_1  0  N_2  0  N_3  0  N_4 \\end{bmatrix}, \\quad \\mathbf{d}^e = [u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4]^{\\mathsf{T}}\n$$\n其中 $N_i(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_i \\xi)(1+\\eta_i \\eta)$ 是在父单元域 $[-1, 1] \\times [-1, 1]$ 上的双线性形函数。\n\n小应变张量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$（使用工程剪切应变 $\\gamma_{xy} = 2\\varepsilon_{xy}$）通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移相关联：\n$$\n\\boldsymbol{\\varepsilon}^h = \\mathbf{B} \\mathbf{d}^e, \\quad \\text{其中} \\quad \\mathbf{B}_i = \\begin{bmatrix} \\partial N_i/\\partial x  0 \\\\ 0  \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y  \\partial N_i/\\partial x \\end{bmatrix} \\quad \\text{以及} \\quad \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\n$$\n相对于物理坐标 $(x,y)$ 的导数是使用链式法则和等参映射的雅可比矩阵找到的：$\\left\\{\\partial N_i/\\partial x, \\partial N_i/\\partial y\\right\\}^{\\mathsf{T}} = \\mathbf{J}^{-1} \\left\\{\\partial N_i/\\partial \\xi, \\partial N_i/\\partial \\eta\\right\\}^{\\mathsf{T}}$。对于指定的结构化矩形网格，雅可比矩阵 $\\mathbf{J}$ 在每个单元内是恒定的。\n\n本构关系是胡克定律 (Hooke's Law)，$\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 是材料弹性矩阵。对于**平面应变**：\n$$\n\\mathbf{D}_{\\text{strain}} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{bmatrix}\n$$\n对于**平面应力**：\n$$\n\\mathbf{D}_{\\text{stress}} = \\frac{E}{1-\\nu^2} \\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1-\\nu}{2} \\end{bmatrix}\n$$\n将有限元近似代入虚功原理，并注意到它对任意虚位移 $\\delta\\mathbf{d}$ 都成立，我们得到离散化系统 $\\mathbf{K}\\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U}$ 是节点位移的全局向量。单元刚度矩阵 $\\mathbf{k}^e$ 和全局刚度矩阵 $\\mathbf{K}$ 由下式组装而成：\n$$\n\\mathbf{k}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\mathsf{T}} \\mathbf{D} \\mathbf{B} \\, t \\, dA\n$$\n问题指定单位厚度 $t=1$。该积分使用 $2 \\times 2$ Gauss 求积法则进行数值计算，这足以对矩形单元产生的多项式被积函数进行精确积分。\n\n### 3. 面片检验设置\n\n面片检验的本质是应用从已知精确解导出的边界条件，而单元应该能够再现这个解。在这里，目标是一个线性位移场：\n$$\nu(x,y) = a_0 + a_1 x + a_2 y \\quad , \\quad v(x,y) = b_0 + b_1 x + b_2 y\n$$\n该场在整个域 $\\Omega$ 内产生恒定的应变状态：\n$$\n\\boldsymbol{\\varepsilon}_{\\text{exact}} = \\begin{Bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{Bmatrix} = \\begin{Bmatrix} \\partial u / \\partial x \\\\ \\partial v / \\partial y \\\\ \\partial u / \\partial y + \\partial v / \\partial x \\end{Bmatrix} = \\begin{Bmatrix} a_1 \\\\ b_2 \\\\ a_2 + b_1 \\end{Bmatrix}\n$$\n相应的 Cauchy 应力 $\\boldsymbol{\\sigma}_{\\text{exact}} = \\mathbf{D} \\boldsymbol{\\varepsilon}_{\\text{exact}}$ 也是恒定的。这个恒定应力用于在整个边界 $\\partial\\Omega$ 上定义牵引力 $\\mathbf{t} = \\boldsymbol{\\sigma}_{\\text{exact}} \\mathbf{n}$，其中 $\\mathbf{n}$ 是外法向单位矢量。\n\n外力向量 $\\mathbf{F}$ 是根据这些牵引力导出的一致节点力组装而成的。对于一个边界边，单元力向量是：\n$$\n\\mathbf{f}^e_{\\text{ext}} = \\int_{\\text{edge}} \\mathbf{N}^{\\mathsf{T}} \\mathbf{t} \\, t \\, dL\n$$\n此积分沿每个边界边使用 $2$ 点 Gauss 法则进行计算。对于长度为 $L_{edge}$ 的直边上的恒定牵引力 $\\mathbf{t}$，此积分将总力 $\\mathbf{t} L_{edge}$ 平均分配到该边的两个节点上。\n\n### 4. 系统求解与验证\n\n全局系统 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ 是奇异的，因为仅有牵引力的边界条件不能排除刚体运动（二维中的两次平移和一次旋转）。为了获得唯一解，我们必须施加最小位移边界条件。问题规定：\n1. $u(0,0) = a_0$\n2. $v(0,0) = b_0$\n3. $v(L_x,0) = b_0 + b_1 L_x$\n\n这三个约束足以消除三个刚体模式。它们通过一种保持刚度矩阵对称性的直接消元法施加到线性系统上。这涉及修改与约束自由度 (DOF) 对应的 $\\mathbf{K}$ 的行和列，并相应地调整力向量 $\\mathbf{F}$。对于一个规定的自由度 $U_k = d$：\n1. 对于所有自由的自由度 $i$，更新力分量：$F_i \\leftarrow F_i - K_{ik} d$。\n2. 将矩阵的第 $k$ 行和第 $k$ 列设置为零，即对于 $i \\neq k$，$K_{ik} = K_{ki} = 0$。\n3. 将对角线元素设置为 1：$K_{kk} \\leftarrow 1$。\n4. 将力分量设置为规定值：$F_k \\leftarrow d$。\n\n在求解修改后的系统得到数值节点位移 $\\mathbf{U}_{\\text{num}}$ 后，我们将它们与精确节点位移 $\\mathbf{U}_{\\text{exact}}$进行比较，后者是通过在每个节点的坐标处评估线性位移场计算得出的。如果最大绝对误差在机器精度量级，则验证成功：\n$$\n\\text{Error} = \\max_{i} | (\\mathbf{U}_{\\text{num}})_i - (\\mathbf{U}_{\\text{exact}})_i | \\approx 0\n$$\n\n此程序系统地应用于所提供的四个测试案例。",
            "answer": "```python\nimport numpy as np\n\ndef get_constitutive_matrix(E, nu, case_type):\n    \"\"\"\n    Constructs the 2D linear elastic constitutive matrix D.\n    \n    Args:\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        case_type (str): 'plane_strain' or 'plane_stress'.\n\n    Returns:\n        np.ndarray: The 3x3 constitutive matrix.\n    \"\"\"\n    if case_type == 'plane_strain':\n        factor = E / ((1 + nu) * (1 - 2 * nu))\n        D = factor * np.array([\n            [1 - nu, nu, 0],\n            [nu, 1 - nu, 0],\n            [0, 0, (1 - 2 * nu) / 2]\n        ])\n    elif case_type == 'plane_stress':\n        factor = E / (1 - nu**2)\n        D = factor * np.array([\n            [1, nu, 0],\n            [nu, 1, 0],\n            [0, 0, (1 - nu) / 2]\n        ])\n    else:\n        raise ValueError(\"Invalid case_type. Must be 'plane_strain' or 'plane_stress'.\")\n    return D\n\ndef get_shape_func_derivs_parent(xi, eta):\n    \"\"\"\n    Computes derivatives of Q1 shape functions with respect to parent coordinates.\n    Node ordering is counter-clockwise from bottom-left: (-1,-1), (1,-1), (1,1), (-1,1).\n    \"\"\"\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return dN_dxi, dN_deta\n\ndef solve_patch_test_case(params):\n    \"\"\"\n    Runs a single patch test case.\n    \"\"\"\n    Nx, Ny, Lx, Ly, E, nu, case_type, coeffs = params\n    a0, a1, a2, b0, b1, b2 = coeffs\n\n    # 1. Mesh Generation\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_elements = Nx * Ny\n    \n    nodes = np.zeros((num_nodes, 2))\n    for j in range(num_nodes_y):\n        for i in range(num_nodes_x):\n            node_idx = j * num_nodes_x + i\n            nodes[node_idx] = [i * Lx / Nx, j * Ly / Ny]\n\n    elements = np.zeros((num_elements, 4), dtype=int)\n    for j in range(Ny):\n        for i in range(Nx):\n            el_idx = j * Nx + i\n            n1 = j * num_nodes_x + i        # bottom-left\n            n2 = j * num_nodes_x + i + 1    # bottom-right\n            n3 = (j + 1) * num_nodes_x + i + 1  # top-right\n            n4 = (j + 1) * num_nodes_x + i      # top-left\n            elements[el_idx] = [n1, n2, n3, n4]\n\n    # 2. Exact Solution  Material Properties\n    eps_exact = np.array([a1, b2, a2 + b1]) # [exx, eyy, gxy]\n    D = get_constitutive_matrix(E, nu, case_type)\n    sigma_exact = D @ eps_exact\n\n    # 3. Assembly of Global Stiffness Matrix K\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    \n    gp_loc = 1.0 / np.sqrt(3)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    hx, hy = Lx / Nx, Ly / Ny\n    \n    # Pre-calculate for rectangular elements\n    J = np.array([[hx / 2, 0], [0, hy / 2]])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n\n    for el_nodes_indices in elements:\n        ke = np.zeros((8, 8))\n        for gp, w in zip(gauss_points, gauss_weights):\n            xi, eta = gp\n            dN_dxi, dN_deta = get_shape_func_derivs_parent(xi, eta)\n            \n            dN_dx_dy = invJ @ np.vstack((dN_dxi, dN_deta))\n            dN_dx = dN_dx_dy[0, :]\n            dN_dy = dN_dx_dy[1, :]\n\n            B = np.zeros((3, 8))\n            B[0, 0::2] = dN_dx\n            B[1, 1::2] = dN_dy\n            B[2, 0::2] = dN_dy\n            B[2, 1::2] = dN_dx\n            \n            ke += B.T @ D @ B * detJ * w\n        \n        dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes_indices])\n        K[np.ix_(dof_indices, dof_indices)] += ke\n\n    # 4. Assembly of Global Force Vector F\n    F = np.zeros(num_dofs)\n    boundary_edges = {\n        'bottom': [(j * num_nodes_x + i, j * num_nodes_x + i + 1) for j in range(Ny) for i in range(Nx) if j == 0],\n        'right': [(j * num_nodes_x + i + 1, (j + 1) * num_nodes_x + i + 1) for j in range(Ny) for i in range(Nx) if i == Nx - 1],\n        'top': [((j + 1) * num_nodes_x + i, (j + 1) * num_nodes_x + i + 1) for j in range(Ny) for i in range(Nx) if j == Ny - 1],\n        'left': [(j * num_nodes_x + i, (j + 1) * num_nodes_x + i) for j in range(Ny) for i in range(Nx) if i == 0]\n    }\n    # Correct order for outward normal\n    boundary_edges['top'] = [(n2, n1) for n1, n2 in boundary_edges['top']]\n    boundary_edges['left'] = [(n2, n1) for n1, n2 in boundary_edges['left']]\n\n    normals = {'bottom': np.array([0, -1]),'right': np.array([1, 0]),'top': np.array([0, 1]),'left': np.array([-1, 0])}\n    edge_lengths = {'bottom': hx, 'top': hx, 'left': hy, 'right': hy}\n\n    for side, edges in boundary_edges.items():\n        if not edges: continue\n        traction = np.array([sigma_exact[0]*normals[side][0] + sigma_exact[2]*normals[side][1],\n                             sigma_exact[2]*normals[side][0] + sigma_exact[1]*normals[side][1]])\n        force_per_node = traction * edge_lengths[side] / 2.0\n        for n1, n2 in edges:\n            F[2 * n1:2 * n1 + 2] += force_per_node\n            F[2 * n2:2 * n2 + 2] += force_per_node\n\n    # 5. Apply Displacement Boundary Conditions\n    node_0_idx = 0\n    node_Lx0_idx = Nx\n    \n    u0 = a0 + a1 * nodes[node_0_idx, 0] + a2 * nodes[node_0_idx, 1]\n    v0 = b0 + b1 * nodes[node_0_idx, 0] + b2 * nodes[node_0_idx, 1]\n    vLx0 = b0 + b1 * nodes[node_Lx0_idx, 0] + b2 * nodes[node_Lx0_idx, 1]\n\n    prescribed_dofs = {\n        2 * node_0_idx: u0,            # u(0,0)\n        2 * node_0_idx + 1: v0,        # v(0,0)\n        2 * node_Lx0_idx + 1: vLx0     # v(Lx,0)\n    }\n    \n    free_dofs = np.setdiff1d(np.arange(num_dofs), list(prescribed_dofs.keys()))\n    \n    for dof, val in prescribed_dofs.items():\n        F[free_dofs] -= K[free_dofs, dof] * val\n    \n    for dof, val in prescribed_dofs.items():\n        K[dof, :] = 0\n        K[:, dof] = 0\n        K[dof, dof] = 1\n        F[dof] = val\n\n    # 6. Solve and Compute Error\n    U_num = np.linalg.solve(K, F)\n    \n    U_exact = np.zeros(num_dofs)\n    for i in range(num_nodes):\n        x, y = nodes[i, 0], nodes[i, 1]\n        U_exact[2 * i] = a0 + a1 * x + a2 * y\n        U_exact[2 * i + 1] = b0 + b1 * x + b2 * y\n        \n    error = np.max(np.abs(U_num - U_exact))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'Nx': 1, 'Ny': 1, 'Lx': 1.0, 'Ly': 1.0, 'E': 1.00e3, 'nu': 0.30, 'type': 'plane_strain', \n         'coeffs': (0.10, 0.20, -0.30, -0.05, 0.40, 0.25)},\n        # Case 2\n        {'Nx': 2, 'Ny': 3, 'Lx': 2.0, 'Ly': 1.0, 'E': 2.10e5, 'nu': 0.29, 'type': 'plane_stress',\n         'coeffs': (-0.02, 0.15, 0.05, 0.03, -0.10, 0.12)},\n        # Case 3\n        {'Nx': 4, 'Ny': 1, 'Lx': 8.0, 'Ly': 1.0, 'E': 7.00e4, 'nu': 0.33, 'type': 'plane_strain',\n         'coeffs': (0.00, 0.05, 1.50, 0.01, -1.20, 0.02)},\n        # Case 4\n        {'Nx': 3, 'Ny': 3, 'Lx': 1.5, 'Ly': 1.5, 'E': 3.00e5, 'nu': 0.25, 'type': 'plane_stress',\n         'coeffs': (0.005, -0.08, 0.06, -0.01, 0.07, -0.09)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        params = (case['Nx'], case['Ny'], case['Lx'], case['Ly'], case['E'], case['nu'], case['type'], case['coeffs'])\n        result = solve_patch_test_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}