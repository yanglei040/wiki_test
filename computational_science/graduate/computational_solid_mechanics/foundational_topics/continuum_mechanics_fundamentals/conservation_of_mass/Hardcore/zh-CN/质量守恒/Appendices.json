{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个实践将引导您解决时间积分中的一个基本挑战。您将直接从连续性方程中推导出一个数值积分格式，并观察算法选择如何导致质量在长时间积分后不能完美守恒——这种现象被称为数值质量漂移。这个练习将帮助您建立对数值方法本身重要性的直观理解，而不仅仅是依赖于正确的物理方程。",
            "id": "3550657",
            "problem": "考虑计算固体力学中一根变形杆的一维拉格朗日离散化。假设该杆最初占据一个长度为 $L$ 的参考区间，并均匀地划分为 $N$ 个物质点，每个物质点关联一个参考子体积 $\\Delta V_0 = L/N$。初始质量密度是均匀的，等于 $\\rho_0$（单位为 $\\mathrm{kg}/\\mathrm{m}^3$）。速度场满足局部体积应变率（速度的散度）在空间上是均匀的且随时间变化，记为 $s(t)$（单位为 $\\mathrm{s}^{-1}$），并由 $s(t) = k \\cos(\\omega t)$ 给出，其中 $k$ 是一个常数（单位为 $\\mathrm{s}^{-1}$），$\\omega$ 是角频率（单位为 $\\mathrm{rad}/\\mathrm{s}$，即弧度/秒）。\n\n从任意物质区域的基本质量守恒定律（即该区域内质量的时间导数为零）出发，并使用拉格朗日描述，仅基于以物质时间导数表示的连续性方程，推导一个用于质量密度 $\\rho$ 的预测-校正显式格式。推导必须从第一性原理开始：质量守恒的积分形式和物质导数的定义。不要先验地假设任何目标离散公式。作为推导的一部分，定义将参考体积映射到当前体积的变形雅可比行列式 $J$，并利用在拉格朗日框架下，质量守恒意味着乘积 $\\rho J$ 在精确时间演化下是不变的这一事实。\n\n在离散算法中，在每个时间步 $n$，让自适应时间步长 $\\Delta t_n$ 由以下规则控制：\n$$\n\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert},\n$$\n其中 $\\Delta t_{\\max}$（单位为 $\\mathrm{s}$）是用户指定的最大时间步长，$\\gamma$（无量纲）是自适应系数，$t_n$ 是当前时间。预测-校正格式必须构造为时间上二阶精度，并且仅使用在 $t_n$ 和 $t_{n+1} = t_n + \\Delta t_n$ 时刻可用的值。\n\n实现你推导的格式，在每个时间步更新质量密度 $\\rho$ 和变形雅可比行列式 $J$，初始条件为 $\\rho(0) = \\rho_0$ 和 $J(0) = 1$。对于均匀的 $s(t)$，每个物质点具有相同的演化过程；然而，为了计算总质量，需要使用每个子体积的当前质量 $\\rho(t) J(t) \\Delta V_0$ 对 $N$ 个参考子体积进行聚合。将时间 $t$ 的总质量定义为\n$M(t) = \\sum_{i=1}^{N} \\rho(t) J(t) \\Delta V_0 = \\rho(t) J(t) L,$\n初始总质量定义为 $M(0) = \\rho_0 L$。\n\n对于每次模拟，运行直到最终时间 $T$（单位为 $\\mathrm{s}$），并以无量纲小数形式报告质量漂移\n$\\delta = \\frac{M(T) - M(0)}{M(0)}$。\n将输出 $\\delta$ 表示为小数（不带百分号）。使用以下参数值测试套件，在不同的自适应时间步长情景下评估算法。物理参数必须根据其指定单位进行解释。\n\n- 测试用例1（一般情况）：\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.2$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 10.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.5$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.005$ $\\mathrm{s}$,\n  - $\\gamma = 2.0$。\n- 测试用例2（接近恒定时间步长和近乎不可压缩的演化）：\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.01$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 5.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.2$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.001$ $\\mathrm{s}$,\n  - $\\gamma = 0.5$。\n- 测试用例3（在更快的体积振荡下的强自适应性）：\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.5$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 30.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.4$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.002$ $\\mathrm{s}$,\n  - $\\gamma = 5.0$。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按给定测试用例的顺序排列结果，例如 $[\\delta_1,\\delta_2,\\delta_3]$。每个 $\\delta_i$ 都必须是上面定义的小数。不应产生任何其他输出。$\\omega$ 的角度单位是弧度，所有时间单位都是秒。长度单位必须是米，密度单位必须是千克/立方米，如指定。解决方案应是通用的，并且仅依赖于规定的物理定律和定义，从而为指定的测试套件提供正确的算法实现。",
            "solution": "该问题被评估为有效，因为它科学地基于连续介质力学的原理，问题定义良好，具有明确的目标和足够的数据，并以客观、正式的语言表述。它提出了一个计算力学中标准的、尽管简化的、可通过推导和实现数值方法来解决的问题。\n\n所需数值格式的推导从质量守恒基本原理出发。\n\n**1. 控制微分方程的推导**\n\n质量守恒定律指出，对于随变形体一起移动的任意物质体积 $\\mathcal{V}(t)$，其质量随时间保持不变。该体积内的质量 $M$ 由密度场 $\\rho(\\mathbf{x}, t)$ 在当前体积 $\\mathcal{V}(t)$ 上的积分给出：\n$$ M = \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV $$\n质量守恒意味着该质量的物质时间导数为零：\n$$ \\frac{dM}{dt} = \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV = 0 $$\n将雷诺输运定理应用于随时间变化的物质体积上的积分，我们得到：\n$$ \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho \\, dV = \\int_{\\mathcal{V}(t)} \\left( \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) \\right) dV = 0 $$\n其中 $\\mathbf{v}$ 是速度场。由于这对任意物质体积 $\\mathcal{V}(t)$ 都成立，被积函数必须为零，这便得出了欧拉形式的连续性方程：\n$$ \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) = 0 $$\n展开散度项得到 $\\nabla \\cdot (\\rho \\mathbf{v}) = (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v})$。将其代回，我们有：\n$$ \\frac{\\partial \\rho}{\\partial t} + (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\n密度的物质时间导数，表示物质粒子的密度变化率，定义为 $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + \\mathbf{v} \\cdot \\nabla \\rho$。因此，连续性方程可以在拉格朗日框架下写为：\n$$ \\frac{D\\rho}{Dt} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\n问题指定体积应变率 $\\nabla \\cdot \\mathbf{v}$ 在空间上是均匀的，并由一个随时间变化的函数 $s(t) = k \\cos(\\omega t)$ 给出。因此，任何物质点密度的控制常微分方程（ODE）是：\n$$ \\frac{D\\rho}{Dt} = -\\rho(t) s(t) $$\n接下来，我们引入变形雅可比行列式 $J$。雅可比行列式 $J$ 定义为变形梯度张量 $\\mathbf{F}$ 的行列式，即 $J = \\det(\\mathbf{F})$。它提供了局部体积变化的度量，通过 $dV = J dV_0$ 将当前构型中的微分体积元 $dV$ 与其在参考构型中的对应物 $dV_0$ 联系起来。雅可比行列式的物质时间导数由著名的关系式（刘维尔公式）给出：\n$$ \\frac{DJ}{Dt} = J (\\nabla \\cdot \\mathbf{v}) $$\n使用给定的体积应变率表达式，雅可比行列式的控制常微分方程是：\n$$ \\frac{DJ}{Dt} = J(t) s(t) $$\n对于精确的连续解，乘积 $\\rho J$ 是一个不变量。这可以通过求其物质时间导数来证明：\n$$ \\frac{D(\\rho J)}{Dt} = J \\frac{D\\rho}{Dt} + \\rho \\frac{DJ}{Dt} = J(-\\rho s(t)) + \\rho(J s(t)) = 0 $$\n由于 $\\rho(0) = \\rho_0$ 且 $J(0) = 1$，我们有 $\\rho(t)J(t) = \\rho_0 J(0) = \\rho_0$ 对所有时间 $t$ 成立。这表示一个物质单元内的质量 $\\rho dV = \\rho J dV_0$ 是守恒的，因为它始终等于初始质量 $\\rho_0 dV_0$。数值格式可能无法完美地保持这个不变量，从而导致“质量漂移”。\n\n**2. 预测-校正格式的推导**\n\n我们的任务是推导一个二阶显式预测-校正格式来求解关于 $\\rho$ 和 $J$ 的两个耦合常微分方程。我们将使用标准的二阶格式 Heun 方法。让我们考虑一个一般的一阶常微分方程 $\\dot{y} = f(t, y)$。从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t_n$ 的更新如下：\n\n- **预测步：** 使用前向欧拉法计算 $y_{n+1}$ 的一个初始估计值。设其为 $y_{n+1}^*$。\n  $$ y_{n+1}^* = y_n + \\Delta t_n f(t_n, y_n) $$\n- **校正步：** 通过对区间开始处的斜率 $f(t_n, y_n)$ 和使用预测值 $y_{n+1}^*$ 计算的区间结束处的斜率进行平均，来计算最终值 $y_{n+1}$。这等效于应用梯形法则。\n  $$ y_{n+1} = y_n + \\frac{\\Delta t_n}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}^*) \\right] $$\n\n我们将此方法应用于我们的两个常微分方程。\n\n**对于雅可比行列式 $J$：**\n常微分方程为 $\\dot{J} = J s(t)$，因此 $f(t, J) = J s(t)$。\n- 预测：$J_{n+1}^* = J_n + \\Delta t_n (J_n s(t_n)) = J_n (1 + \\Delta t_n s(t_n))$。\n- 校正：\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_{n+1}^* s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_n(1 + \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} s(t_n) + \\frac{\\Delta t_n}{2} s(t_{n+1}) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n\n**对于密度 $\\rho$：**\n常微分方程为 $\\dot{\\rho} = -\\rho s(t)$，因此 $f(t, \\rho) = -\\rho s(t)$。\n- 预测：$\\rho_{n+1}^* = \\rho_n + \\Delta t_n (-\\rho_n s(t_n)) = \\rho_n (1 - \\Delta t_n s(t_n))$。\n- 校正：\n  $$ \\rho_{n+1} = \\rho_n + \\frac{\\Delta t_n}{2} \\left[ (-\\rho_n s(t_n)) + (-\\rho_{n+1}^* s(t_{n+1})) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n - \\frac{\\Delta t_n}{2} \\left[ \\rho_n s(t_n) + \\rho_n(1 - \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n \\left( 1 - \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n这两个更新公式构成了用于 $\\rho$ 和 $J$ 的最终数值格式。\n\n**3. 数值算法与评估**\n\n模拟从 $t=0$ 迭代进行到最终时间 $T$。\n1.  初始化状态变量：$t \\leftarrow 0$, $\\rho \\leftarrow \\rho_0$, $J \\leftarrow 1$。\n2.  当 $t  T$ 时循环：\n    a. 设当前时间为 $t_n=t$。\n    b. 计算应变率 $s(t_n) = k \\cos(\\omega t_n)$。\n    c. 计算自适应时间步长：$\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert}$。\n    d. 为确保模拟在 $T$ 时刻精确结束，如果 $t_n + \\Delta t_n > T$，则调整时间步长为 $\\Delta t_n = T - t_n$。\n    e. 计算时间步结束时的时间：$t_{n+1} = t_n + \\Delta t_n$。\n    f. 计算未来时刻的应变率：$s(t_{n+1}) = k \\cos(\\omega t_{n+1})$。\n    g. 使用推导出的预测-校正公式将 $\\rho$ 和 $J$ 更新到它们在 $t_{n+1}$ 时刻的值。\n    h. 更新当前时间：$t \\leftarrow t_{n+1}$。\n3.  循环终止后，最终值为 $\\rho(T)$ 和 $J(T)$。\n4.  计算质量漂移 $\\delta$。时间 $t$ 的总质量为 $M(t) = \\rho(t) J(t) L$。初始质量为 $M(0) = \\rho_0 L$。漂移为：\n    $$ \\delta = \\frac{M(T) - M(0)}{M(0)} = \\frac{\\rho(T)J(T)L - \\rho_0 L}{\\rho_0 L} = \\frac{\\rho(T)J(T)}{\\rho_0} - 1 $$\n    注意，参数 $L$ 和 $N$ 是物理概念化的一部分，但由于相消和问题的空间均匀性，它们不影响无量纲漂移 $\\delta$ 的最终值。\n\n实现将对每个提供的测试用例遵循此算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a predictor-corrector scheme for mass conservation\n    in computational solid mechanics and calculates the numerical mass drift.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.2, 'omega': 10.0,\n            'T': 0.5, 'dt_max': 0.005, 'gamma': 2.0\n        },\n        # Test case 2 (near-constant time step and near-incompressible evolution)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.01, 'omega': 5.0,\n            'T': 0.2, 'dt_max': 0.001, 'gamma': 0.5\n        },\n        # Test case 3 (strong adaptivity under faster volumetric oscillations)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.5, 'omega': 30.0,\n            'T': 0.4, 'dt_max': 0.002, 'gamma': 5.0\n        },\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Extract parameters for the current simulation\n        rho_0 = params['rho_0']\n        k = params['k']\n        omega = params['omega']\n        T = params['T']\n        dt_max = params['dt_max']\n        gamma = params['gamma']\n        \n        # Initialize simulation variables\n        t = 0.0\n        rho = rho_0\n        J = 1.0\n        \n        # Volumetric strain rate function\n        def s(time):\n            return k * np.cos(omega * time)\n            \n        # Set a small epsilon for floating point comparisons with the final time T\n        epsilon = 1e-9\n        \n        # Time-stepping loop\n        while t  T - epsilon:\n            # State at the beginning of the step (t_n)\n            t_n = t\n            rho_n = rho\n            J_n = J\n            \n            s_n = s(t_n)\n            \n            # Calculate adaptive time step\n            dt = dt_max / (1.0 + gamma * np.abs(s_n))\n            \n            # Ensure the final step lands exactly on T\n            if t_n + dt > T:\n                dt = T - t_n\n                \n            t_n_plus_1 = t_n + dt\n            \n            # Strain rate at the end of the step (t_{n+1})\n            s_n_plus_1 = s(t_n_plus_1)\n            \n            # Apply the second-order predictor-corrector (Heun's method) updates\n            common_term_1 = 0.5 * dt * (s_n + s_n_plus_1)\n            common_term_2 = 0.5 * (dt**2) * s_n * s_n_plus_1\n            \n            # Update density\n            rho = rho_n * (1.0 - common_term_1 + common_term_2)\n            \n            # Update Jacobian\n            J = J_n * (1.0 + common_term_1 + common_term_2)\n            \n            # Advance time\n            t = t_n_plus_1\n\n        # Calculate mass drift\n        # The conserved quantity in the exact solution is rho * J.\n        # Initial value: rho_0 * J(0) = rho_0 * 1.0\n        # Final value: rho(T) * J(T)\n        delta = (rho * J - rho_0) / rho_0\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从时间维度转向空间维度，本实践将探讨有限元法（FEM）中的空间离散化选择如何影响质量守恒。您将研究一种常用的技术——选择性减缩积分，并发现它如何引发非物理的、振荡的密度场，即“沙漏模式”。这个练习揭示了选择稳定且精确的单元列式对于保证局部质量守恒的重要性。",
            "id": "3550637",
            "problem": "考虑一个二维双线性四边形有限元，在参考构型中占据单位正方形，面积为 $A_0 = 1\\,\\mathrm{m}^2$，单位厚度为米。设四个节点位于参数位置 $(\\xi,\\eta) \\in \\{-1,1\\} \\times \\{-1,1\\}$，按节点 $1$ 在 $(-1,-1)$，节点 $2$ 在 $(1,-1)$，节点 $3$ 在 $(1,1)$，以及节点 $4$ 在 $(-1,1)$ 的顺序排列。设每个节点 $i=1,\\dots,4$ 的节点体积应变值被指定为 $\\theta_i$，这被理解为小应变极限下位移场散度的最佳可用离散近似。在小应变范围内，变形梯度的雅可比行列式满足 $J \\approx 1 + \\theta$。质量守恒定律指出，当前质量密度 $\\rho$ 和参考质量密度 $\\rho_0$ 满足逐点关系 $\\rho\\,J = \\rho_0$。\n\n在对体积约束使用选择性减缩积分的混合有限元格式中，$J \\approx 1$ 的强制执行仅使用单元中心 $(\\xi,\\eta)=(0,0)$ 来完成，而偏响应则可能用更多的点进行积分。这种选择性强制可能会引入伪体积模式，这些模式不改变单元平均值，但在局部振荡，可能在保持单元平均约束的同时产生伪密度变化。\n\n您的任务是实现一个程序，对于一组给定的单个双线性单元的节点体积应变模式 $\\{\\theta_i\\}_{i=1}^4$，严格基于基本原理执行以下步骤：\n\n1. 使用双线性形函数在单元上插值体积应变场。设双线性形函数为\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n插值后的体积应变为\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i.\n$$\n设置 $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$ 且参考密度为 $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$。\n\n2. 通过在单元中心 $(\\xi,\\eta)=(0,0)$ 处计算雅可比行列式来定义减缩（单点）强制密度 $\\rho_{\\mathrm{red}}$：\n$$\nJ_c = J(0,0),\\quad \\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c}.\n$$\n这对应于仅使用中心点来强制体积约束。\n\n3. 通过在标准的 $2\\times 2$ 高斯求积点集上计算质量守恒残差来量化伪密度模式。使用高斯点 $(\\xi_g,\\eta_g)$，其中 $\\xi_g,\\eta_g\\in\\{-1/\\sqrt{3},\\,1/\\sqrt{3}\\}$，每个点的权重为 $w_g = 1$。在每个高斯点处，计算\n$r_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0,$\n以及残差的方差\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}}\\right)^2,\\quad \\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}}.\n$$\n同时报告减缩强制与全平均之间的差异：\n$$\n\\Delta J = J_c - \\bar{J},\\quad \\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 J(\\xi_g,\\eta_g).\n$$\n使用小应变近似计算单元质量\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,A_0/4,\n$$\n以及质量误差\n$$\ne_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0\\,A_0.\n$$\n将 $m_{\\mathrm{red}}$ 以 $\\mathrm{kg}$ 表示，$e_m^{\\mathrm{red}}$ 以 $\\mathrm{kg}$ 表示。\n\n4. 提出并实现一种在减少伪密度残差的同时保持质量的稳定化方法。考虑在高斯点处进行以下保持质量的混合：\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right),\n$$\n其中 $\\beta\\in[0,1]$ 是一个稳定化参数，$\\bar{J}$ 是 $2\\times 2$ 高斯平均值。证明此选择保持单元质量，即：\n$$\n\\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 = \\rho_0\\,A_0,\n$$\n对于任何 $\\beta\\in[0,1]$，并且减少了残差方差。用 $\\beta=0.75$ 实现此方法。计算\n$$\nr_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g) - \\rho_0,\\quad\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{stab}} - \\bar{r}^{\\mathrm{stab}}\\right)^2,\n$$\n以及质量误差\n$$\ne_m^{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 - \\rho_0\\,A_0.\n$$\n\n5. 使用以下节点体积应变模式（无量纲）的测试套件来评估上述量。对于每种情况，设置单元面积 $A_0 = 1\\,\\mathrm{m^2}$ 和参考密度 $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$：\n- 情况1（均匀压缩，理想情况）：$\\theta = [-0.02,-0.02,-0.02,-0.02]$。\n- 情况2（近不可压缩沙漏模式，边界情况）：$\\theta = [10^{-6},-10^{-6},10^{-6},-10^{-6}]$。\n- 情况3（中等沙漏模式，伪模式）：$\\theta = [0.05,-0.05,0.05,-0.05]$。\n- 情况4（强沙漏模式，物理合理性内的边缘情况）：$\\theta = [0.2,-0.2,0.2,-0.2]$。\n\n6. 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例贡献一个包含四个值的列表：\n$$\n\\left[\\Delta J,\\ \\mathrm{Var}_{\\mathrm{red}},\\ \\mathrm{Var}_{\\mathrm{stab}},\\ e_m^{\\mathrm{red}}\\right].\n$$\n第一个量 $\\Delta J$ 是无量纲的，方差的单位是 $(\\mathrm{kg/m^3})^2$，质量误差的单位是 $\\mathrm{kg}$。最后一行必须是以下形式\n$$\n\\big[\\,[d_1,v_{r1},v_{s1},e_{m1}],\\ [d_2,v_{r2},v_{s2},e_{m2}],\\ [d_3,v_{r3},v_{s3},e_{m3}],\\ [d_4,v_{r4},v_{s4},e_{m4}]\\,\\big].\n$$",
            "solution": "该问题被验证为科学上合理、适定且自洽。它使用既定原理和清晰定义，探讨了计算固体力学中的一个标准课题——有限元分析中由选择性减缩积分产生的伪模式。我们继续进行求解。\n\n问题的核心在于分析在双线性四边形单元中对应变能的体积部分使用单点求积（选择性减缩积分）的后果，并评估一种稳定化技术。该分析取决于双线性形函数的性质及其在参考域上的积分。\n\n节点体积应变 $\\{\\theta_i\\}_{i=1}^4$ 使用双线性形函数 $N_i(\\xi,\\eta)$ 在单元上进行插值：\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i\n$$\n代入给定的形函数并合并各项，得到一个关于 $\\xi$ 和 $\\eta$ 的双线性多项式：\n$$\n\\theta(\\xi,\\eta) = c_0 + c_1\\xi + c_2\\eta + c_3\\xi\\eta\n$$\n其中系数是节点值的线性组合：\n$c_0 = \\frac{1}{4}(\\theta_1+\\theta_2+\\theta_3+\\theta_4)$\n$c_1 = \\frac{1}{4}(-\\theta_1+\\theta_2+\\theta_3-\\theta_4)$\n$c_2 = \\frac{1}{4}(-\\theta_1-\\theta_2+\\theta_3+\\theta_4)$\n$c_3 = \\frac{1}{4}(\\theta_1-\\theta_2+\\theta_3-\\theta_4)$\n\n变形梯度的雅可比行列式的小应变近似为 $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$。\n\n减缩积分方案在单元中心 $(\\xi,\\eta)=(0,0)$ 处计算雅可比行列式，以定义一个单一的、覆盖整个单元的密度。\n中心的雅可比行列式为：\n$$\nJ_c = J(0,0) = 1 + \\theta(0,0) = 1 + c_0\n$$\n相应的减缩强制密度 $\\rho_{\\mathrm{red}}$ 在整个单元上是恒定的：\n$$\n\\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c} = \\frac{\\rho_0}{1+c_0}\n$$\n\n为了评估这种近似的质量，我们将其与使用标准 $2\\times2$ 高斯求积法则计算的平均雅可比行列式 $\\bar{J}$ 进行比较。高斯点为 $(\\xi_g, \\eta_g)$，其中 $\\xi_g, \\eta_g \\in \\{\\pm a\\}$，$a=1/\\sqrt{3}$，所有权重均为 $w_g=1$。平均雅可比行列式为：\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 w_g J(\\xi_g,\\eta_g) = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0 + c_1\\xi_g + c_2\\eta_g + c_3\\xi_g\\eta_g)\n$$\n由于高斯点的对称性，关于 $\\xi$ 或 $\\eta$ 的线性项之和为零：$\\sum \\xi_g = 0$ 和 $\\sum \\eta_g = 0$。对于双线性四边形单元，$2\\times2$ 高斯法则能将项 $c_3\\xi\\eta$ 精确地积分到其在单元上的真实平均值，即零。具体来说，$\\sum \\xi_g \\eta_g = a^2 - a^2 - a^2 + a^2 = 0$。因此，总和简化为：\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0) = \\frac{1}{4} \\cdot 4(1+c_0) = 1+c_0\n$$\n因此，对于一个在未扭曲（矩形）域上的双线性单元，我们得出了一个关键结果，即 $J_c = \\bar{J}$。这直接意味着要报告的第一个量 $\\Delta J$ 对于所有测试用例都恒等于零：\n$$\n\\Delta J = J_c - \\bar{J} = 0\n$$\n这个结果特定于理想几何形状和双线性插值；对于扭曲的单元，这个等式将不成立。\n\n接下来，我们为减缩方案评估每个高斯点 $g$ 处的质量守恒残差：\n$$\nr_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0 = \\frac{\\rho_0}{J_c} J(\\xi_g,\\eta_g) - \\rho_0\n$$\n单元上的平均残差为：\n$$\n\\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}} = \\frac{1}{4}\\left(\\frac{\\rho_0}{J_c} \\sum_{g=1}^4 J_g - 4\\rho_0\\right) = \\frac{\\rho_0}{J_c}\\left(\\frac{1}{4}\\sum_{g=1}^4 J_g\\right) - \\rho_0 = \\frac{\\rho_0}{J_c}\\bar{J} - \\rho_0\n$$\n由于 $J_c = \\bar{J}$，平均残差总是为零：$\\bar{r}^{\\mathrm{red}} = 0$。\n残差的方差，它量化了伪振荡，则为：\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}})^2 = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2\n$$\n代入 $r_g^{\\mathrm{red}}$ 的表达式并使用 $J_c=1+c_0$：\n$$\nr_g^{\\mathrm{red}} = \\frac{\\rho_0}{1+c_0} (1+c_0+c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g) - \\rho_0 = \\frac{\\rho_0}{1+c_0}(c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g)\n$$\n方差是通过对这四项在高斯点上的平方求和来计算的。在平方和中的交叉项（例如，$2c_1c_2\\xi_g\\eta_g$）在对称的高斯模式上求和为零。最终推导出的方差公式为：\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\left(\\frac{\\rho_0}{1+c_0}\\right)^2 \\left( \\frac{1}{3}(c_1^2+c_2^2) + \\frac{1}{9}c_3^2 \\right)\n$$\n减缩方案下的总单元质量通过数值积分计算：\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\rho_{\\mathrm{red}} \\sum_{g=1}^4 J_g = A_0 \\rho_{\\mathrm{red}} \\bar{J}\n$$\n再次，由于 $J_c = \\bar{J}$ 且 $\\rho_{\\mathrm{red}} = \\rho_0/J_c$，质量是精确守恒的：\n$$\nm_{\\mathrm{red}} = A_0 \\frac{\\rho_0}{J_c} J_c = \\rho_0 A_0\n$$\n因此，质量误差也恒等于零：$e_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0 A_0 = 0$。\n\n所提出的稳定化方法在每个高斯点引入了一个混合密度：\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right)\n$$\n我们可以证明该方案是保持质量的。稳定化后的质量为：\n$$\nm_{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(g)\\,J(g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\sum_{g=1}^4 \\left[\\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( \\rho_{\\mathrm{red}}\\sum J_g + \\beta\\sum\\left(\\rho_0 - \\frac{\\rho_0 J_g}{\\bar{J}}\\right) \\right) = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}\\sum J_g\\right) \\right)\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}4\\bar{J}\\right) \\right) = A_0 \\rho_{\\mathrm{red}}\\bar{J} = m_{\\mathrm{red}} = \\rho_0 A_0\n$$\n因此，稳定化后的质量误差 $e_m^{\\mathrm{stab}}$ 也为零。\n\n一个高斯点处的稳定化残差是 $r_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(g)J_g - \\rho_0$。使用 $\\rho_{\\mathrm{stab}}$ 的定义和 $J_c=\\bar{J}$：\n$$\nr_g^{\\mathrm{stab}} = \\left[\\frac{\\rho_0}{\\bar{J}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g - \\rho_0 = \\rho_0\\left(\\frac{J_g}{\\bar{J}} + \\beta\\left(1 - \\frac{J_g}{\\bar{J}}\\right) - 1\\right)\n$$\n$$\nr_g^{\\mathrm{stab}} = \\rho_0(1-\\beta)\\left(\\frac{J_g}{\\bar{J}}-1\\right) = (1-\\beta)r_g^{\\mathrm{red}}\n$$\n这个优雅的结果表明，稳定化方案将局部质量残差统一按因子 $(1-\\beta)$ 缩小。由于平均残差 $\\bar{r}^{\\mathrm{red}}$ 为零，$\\bar{r}^{\\mathrm{stab}}$ 也为零。因此，方差按 $(1-\\beta)^2$ 进行缩放：\n$$\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{stab}})^2 = (1-\\beta)^2 \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2 = (1-\\beta)^2 \\mathrm{Var}_{\\mathrm{red}}\n$$\n当 $\\beta = 0.75$ 时，我们有 $\\mathrm{Var}_{\\mathrm{stab}} = (0.25)^2 \\mathrm{Var}_{\\mathrm{red}} = 0.0625\\,\\mathrm{Var}_{\\mathrm{red}}$。\n\n算法实现将为每个测试用例计算 $c_0, c_1, c_2, c_3$，然后将它们用于推导出的 $\\mathrm{Var}_{\\mathrm{red}}$ 公式中。其他三个所需的输出量 $\\Delta J$、$\\mathrm{Var}_{\\mathrm{stab}}$ 和 $e_m^{\\mathrm{red}}$ 可直接得出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (uniform compression, happy path)\n        [-0.02, -0.02, -0.02, -0.02],\n        # Case 2 (near-incompressible hourglass, boundary case)\n        [1e-6, -1e-6, 1e-6, -1e-6],\n        # Case 3 (moderate hourglass, spurious mode)\n        [0.05, -0.05, 0.05, -0.05],\n        # Case 4 (strong hourglass, edge case)\n        [0.2, -0.2, 0.2, -0.2],\n    ]\n\n    # Global parameters\n    rho_0 = 1000.0  # kg/m^3\n    beta = 0.75     # stabilization parameter\n\n    results = []\n    for theta_nodes in test_cases:\n        t1, t2, t3, t4 = theta_nodes\n\n        # 1. Compute coefficients of the interpolated strain field\n        # theta(xi, eta) = c0 + c1*xi + c2*eta + c3*xi*eta\n        c0 = 0.25 * (t1 + t2 + t3 + t4)\n        c1 = 0.25 * (-t1 + t2 + t3 - t4)\n        c2 = 0.25 * (-t1 - t2 + t3 + t4)\n        c3 = 0.25 * (t1 - t2 + t3 - t4)\n\n        # 2. Compute J_c and Bar(J) and their difference Delta_J\n        # For a bilinear quad on a rectangular domain, J_c = Bar(J), so Delta_J = 0.\n        J_c = 1.0 + c0\n        delta_J = 0.0\n\n        # 3. Compute the variance of the residuals for the reduced scheme.\n        # Var_red = (rho_0 / J_c)^2 * ( (1/3)*(c1^2 + c2^2) + (1/9)*c3^2 )\n        # This is derived in the solution text.\n        if np.isclose(J_c, 0):\n            # Avoid division by zero, though not expected in these test cases.\n            var_red = float('inf')\n        else:\n            factor = (rho_0 / J_c)**2\n            term = (1.0/3.0) * (c1**2 + c2**2) + (1.0/9.0) * (c3**2)\n            var_red = factor * term\n\n        # 4. Compute the mass error for the reduced scheme.\n        # As derived, for this specific problem setup, the mass error is zero.\n        e_m_red = 0.0\n\n        # 5. Compute the variance for the stabilized scheme.\n        # Var_stab = (1 - beta)^2 * Var_red\n        var_stab = (1.0 - beta)**2 * var_red\n        \n        # Store the results for this case.\n        results.append([delta_J, var_red, var_stab, e_m_red])\n\n    # Format the final output string as specified.\n    # [[d1,vr1,vs1,em1], [d2,vr2,vs2,em2], ...]\n    case_strings = []\n    for res in results:\n        # Format each number in the sublist\n        num_strings = [f\"{val:.12g}\" for val in res]\n        # Join numbers into a sublist string \"[n1,n2,n3,n4]\"\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join all case strings into the final output string\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个实践将带您进入一个高度实用且高级的场景：在拓扑结构发生变化（例如在断裂或手术模拟中）时保持质量守恒。您将实现一个保守的切割算法，该算法在分割有限元单元的同时，通过在参考构型中重新分配节点质量，确保系统总质量保持不变。这项动手任务突显了在参考构型中执行此类操作以维护基本物理定律的必要性。",
            "id": "3550666",
            "problem": "给定一个二维薄实体，该实体被离散化为用于有限元法 (FEM) 的线性三角形单元。参考构型是一个被离散化为结构化网格的方形域。该材料具有恒定的参考质量密度 $\\rho_0$ 和恒定的厚度 $t$。质量守恒定律指出，在使用参考质量度量的情况下，总质量在任何内部拓扑变化（如切割）下保持不变。您的任务是实现一个保守的切割操作，该操作通过预设的切割折线分割相交的单元，并重新分配节点集总质量，以使节点质量的总和与原始总质量相等。切割在当前（可能已变形）构型中给出；为保证质量守恒，您必须严格在参考构型中执行相交和面积计算。\n\n使用的基本原理：\n- 质量守恒意味着每个材料单元的质量是恒定的，等于参考密度乘以参考体积。对于薄的平面应力实体，单元质量为 $m_e = \\rho_0 \\, t \\, A_0$，其中 $A_0$ 是单元在参考构型中的面积，$\\rho_0$ 是参考密度， $t$ 是厚度。\n- 对于线性三角形单元，一致质量矩阵的行和集总法（row-sum lumping）为每个顶点产生相等的质量贡献；即，一个单元对其三个节点中每一个的集总质量贡献为 $m_e / 3$。\n- 在均匀变形梯度 $\\mathbf{F}$ 下，雅可比行列式 $J = \\det \\mathbf{F}$ 通过 $\\rho \\, J = \\rho_0$ 关联当前度量和参考度量，但用于计算的守恒质量度量是 $m_e = \\rho_0 \\, t \\, A_0$，它与 $\\mathbf{F}$ 无关。\n\n要实现的切割模型：\n- 切割由当前构型中的一条折线定义。为了进行质量守恒的分割，对于给定的均匀变形梯度 $\\mathbf{F}$，通过 $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$ 将当前构型中的每个折线顶点 $\\mathbf{x}$ 映射到参考构型。对于单位变形情况，即 $\\mathbf{F} = \\mathbf{I}$，切割折线已处于参考构型中。\n- 在参考构型中执行分割。对于每个切割线段，对于每个三角形：\n  - 计算线段与三角形三条边的交点。仅当交点严格位于线段和边的内部（在容差范围内排除端点）且线段与边不共线时，才认为是一个有效交点。\n  - 如果恰好有两个有效交点，它们必须位于共享一个顶点的三角形的两条不同边上。设共享顶点为 $\\mathbf{V}$，设 $\\mathbf{P}$ 位于边 $(\\mathbf{V}, \\mathbf{V}_1)$ 上，$\\mathbf{Q}$ 位于边 $(\\mathbf{V}, \\mathbf{V}_2)$ 上。用三个子三角形：$(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$、$(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$ 替换该三角形。这种划分在参考构型中精确地保持了面积守恒。\n  - 如果有效交点少于两个，或者线段与三角形的某条边共线，则不分割该三角形。\n- 逐个线段地应用上述过程来处理折线，并在处理完每个线段后更新网格。\n\n节点质量重新分配：\n- 在执行所有切割并细分三角形后，通过对每个子三角形，将其三个顶点（包括任何新创建的节点）各自加上 $\\rho_0 \\, t \\, A_{0,\\text{sub}} / 3$ 的量来计算新的集总节点质量。\n- 新节点质量的总和必须等于从初始网格计算出的原始总质量。所有计算都必须使用参考构型面积。\n\n网格、材料和测试套件：\n- 参考域：单位正方形 $[0,1] \\times [0,1]$，被离散化为 $N_x \\times N_y$ 个方形单元的结构化网格，每个方形单元沿左下到右上的对角线分割成两个三角形。使用 $N_x = 3$ 和 $N_y = 3$，因此有 $(N_x+1)(N_y+1) = 16$ 个节点和 $2 N_x N_y = 18$ 个三角形。\n- 参考质量密度：$\\rho_0 = 7800 \\,\\text{kg/m}^3$。\n- 厚度：$t = 0.01 \\,\\text{m}$。\n- 高变形测试的变形梯度：\n  $$\\mathbf{F} = \\begin{bmatrix} 1.8  0.9 \\\\ 0.2  0.7 \\end{bmatrix},$$\n  其行列式为 $J = 1.08$。\n- 定义三个测试用例，每个用例包含一个在当前构型下的切割折线和一个变形梯度 $\\mathbf{F}$：\n  1. 理想情况：无变形下横跨域的水平切割。使用 $\\mathbf{F} = \\mathbf{I}$ 和顶点为 $\\{(-0.2, 0.5), (1.2, 0.5)\\}$ 的折线。\n  2. 边界条件：沿现有网格边进行切割，使得许多线段与三角形的边共线；这应导致不发生分割。使用 $\\mathbf{F} = \\mathbf{I}$ 和顶点为 $\\{(0, 0), (1, 1)\\}$ 的折线。\n  3. 高变形与复杂切割：使用上述 $\\mathbf{F}$ 和在当前构型下顶点为 $\\{(-0.2, 0.2), (0.3, 0.6), (0.7, 0.4), (1.2, 0.8)\\}$ 的折线。对于此情况，在执行任何分割之前，使用 $\\mathbf{F}^{-1}$ 将折线映射到参考构型。\n\n要求的输出和单位：\n- 对于每个测试用例，计算切割前总质量与切割后节点质量总和之间的绝对差异，单位均为千克 (kilograms)。将每个差异以 $\\text{kg}$ 为单位表示为四舍五入到 $12$ 位小数的浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`\"[a,b,c]\"`），其中 $a$、$b$ 和 $c$ 分别是测试用例1、2和3的差异值，每个值都以 $\\text{kg}$ 为单位四舍五- 入到 $12$ 位小数。\n\n科学真实性和约束条件：\n- 所有相交和面积计算都必须在参考构型中进行，以确保在切割下参考质量度量的精确守恒。\n- 交点处理必须排除在顶点处的退化相交和共线重叠；只有与边存在恰好两个有效交点的三角形才会被分割。\n- 该算法必须是确定性的和自包含的。不允许用户输入。",
            "solution": "用户提供的问题是有效的，因为它科学上基于质量守恒原理，数学上是适定的（well-posed），具有清晰确定的算法，并且陈述客观。它展示了计算力学中处理拓扑变化（如切割）同时保持总质量守恒的标准流程。\n\n解决方案通过实现指定的切割和质量重新分配算法来推进。对于每个测试用例，我们执行以下步骤：\n\n1.  **网格和质量初始化**：为参考单位正方形域 $[0,1] \\times [0,1]$ 生成一个由线性三角形单元组成的结构化网格。该域被离散化为一个 $3 \\times 3$ 的单元格网格，每个单元格被细分为两个三角形，从而产生 $16$ 个节点和 $18$ 个三角形。使用给定的参考密度 $\\rho_0 = 7800 \\,\\text{kg/m}^3$ 和厚度 $t = 0.01 \\,\\text{m}$ 计算此初始构型的总质量。单个单元的质量为 $m_e = \\rho_0 \\, t \\, A_0$，其中 $A_0$ 是单元在参考构型中的面积。初始总质量 $M_{\\text{pre}}$ 是所有单元质量的总和。该值作为质量守恒的基准。\n\n2.  **切割折线变换**：每个测试用例提供一条由当前（可能已变形）构型中的顶点定义的切割折线，以及一个相关的均匀变形梯度 $\\mathbf{F}$。为确保质量相对于参考度量是守恒的，所有几何运算（相交、面积计算）都必须在参考构型中进行。因此，给定折线的每个顶点 $\\mathbf{x}$ 通过变换 $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$ 映射到其对应的参考位置 $\\mathbf{X}$。如果变形是单位变形（$\\mathbf{F}=\\mathbf{I}$），则折线已处于参考构型中。\n\n3.  **迭代网格切割**：算法遍历参考映射折线的每个线段。对于每个线段，它遍历网格当前状态下的所有三角形。\n    *   **交点检测**：使用一个线段相交程序来查找切割线段与三角形三条边之间的所有“有效”交点。有效交点定义为严格发生在切割线段和三角形边的内部，并使用数值容差来排除端点和顶点。线段与边共线的情况也被排除。\n    *   **分割准则**：当且仅当切割线段与三角形的边产生恰好两个有效交点时，该三角形才被标记为待分割。这两个交点必须位于共享一个公共顶点的两条不同边上。\n    *   **三角形细分**：如果一个三角形 $(\\mathbf{V}, \\mathbf{V}_1, \\mathbf{V}_2)$ 被分割，交点 $\\mathbf{P}$ 在边 $(\\mathbf{V}, \\mathbf{V}_1)$ 上，交点 $\\mathbf{Q}$ 在边 $(\\mathbf{V}, \\mathbf{V}_2)$ 上，那么它将被替换为三个新的子三角形，具体如下：$(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$、$(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$ 和 $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$。这种细分精确地划分了原始三角形的面积。新的交点 $\\mathbf{P}$ 和 $\\mathbf{Q}$ 被添加到全局节点列表中。使用一个映射来确保在相同几何位置创建的新节点由单个节点索引表示，以保持网格拓扑。\n    *   **网格更新**：在检查完所有三角形与单个切割线段的相交情况后，更新网格。被分割的原始三角形被移除，新生成的子三角形被添加到网格的单元列表中。然后，这个更新后的网格将用于处理下一个切割线段。\n\n4.  **切割后质量计算与差异**：在处理完折线的所有线段后，得到最终的网格拓扑。通过对最终网格中所有三角形的贡献求和，计算出切割后的总质量 $M_{\\text{post}}$。对于每个参考面积为 $A_{0,\\text{sub}}$ 的子三角形，其质量 $m_{\\text{sub}} = \\rho_0 \\, t \\, A_{0,\\text{sub}}$ 被计算出来，并平均分配到其三个顶点（集总质量），即每个节点 $m_{\\text{sub}}/3$。所有节点质量的总和即为 $M_{\\text{post}}$。\n\n5.  **最终结果**：对每个测试用例计算绝对差异 $|M_{\\text{post}} - M_{\\text{pre}}|$。由于在参考坐标系中采用了精确的保面积细分方法，该差异预计在浮点精度范围内为零。最终输出是这些差异的列表，格式化为 $12$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A small tolerance for floating-point comparisons and geometric checks.\nTOL = 1e-9\n\ndef triangle_area(p1, p2, p3):\n    \"\"\"Computes the area of a triangle defined by three 2D points.\"\"\"\n    return 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\ndef find_segment_intersection(seg1_p1, seg1_p2, seg2_p1, seg2_p2):\n    \"\"\"\n    Finds the intersection of two line segments.\n    Returns the intersection point if it's a \"proper\" intersection, otherwise None.\n    A proper intersection occurs strictly inside both segments.\n    \"\"\"\n    r = seg1_p2 - seg1_p1\n    s = seg2_p2 - seg2_p1\n    q_minus_p = seg2_p1 - seg1_p1\n\n    denom = np.cross(r, s)\n    \n    # If denominator is close to zero, segments are parallel or colinear.\n    if abs(denom)  TOL:\n        return None\n        \n    u = np.cross(q_minus_p, s) / denom\n    v = np.cross(q_minus_p, r) / denom\n    \n    # A proper intersection must be strictly within both segments.\n    if TOL  u  1.0 - TOL and TOL  v  1.0 - TOL:\n        intersection_point = seg1_p1 + u * r\n        return intersection_point\n        \n    return None\n\nclass MeshCutter:\n    \"\"\"\n    Manages the mesh, cutting operations, and mass calculations.\n    \"\"\"\n    def __init__(self, Nx, Ny, rho0, t):\n        self.Nx = Nx\n        self.Ny = Ny\n        self.rho0 = rho0\n        self.t = t\n        self.nodes_orig = None\n        self.triangles_orig = None\n        self._generate_initial_mesh()\n        self.pre_cut_mass = self._calculate_total_mass(self.nodes_orig, self.triangles_orig)\n        \n        self.nodes = None\n        self.triangles = None\n\n    def _generate_initial_mesh(self):\n        \"\"\"Generates the initial structured triangular mesh on the unit square.\"\"\"\n        x = np.linspace(0, 1, self.Nx + 1)\n        y = np.linspace(0, 1, self.Ny + 1)\n        xv, yv = np.meshgrid(x, y)\n        self.nodes_orig = [np.array(p) for p in zip(xv.flatten(), yv.flatten())]\n        \n        self.triangles_orig = []\n        for j in range(self.Ny):\n            for i in range(self.Nx):\n                n00 = j * (self.Nx + 1) + i\n                n10 = j * (self.Nx + 1) + (i + 1)\n                n01 = (j + 1) * (self.Nx + 1) + i\n                n11 = (j + 1) * (self.Nx + 1) + (i + 1)\n                \n                self.triangles_orig.append([n00, n10, n11])\n                self.triangles_orig.append([n00, n11, n01])\n\n    def _calculate_total_mass(self, nodes, triangles):\n        \"\"\"Calculates the total mass of the mesh based on lumped nodal contributions.\"\"\"\n        if not nodes or not triangles:\n            return 0.0\n            \n        nodal_masses = np.zeros(len(nodes))\n        for tri_indices in triangles:\n            p1, p2, p3 = [nodes[i] for i in tri_indices]\n            area = triangle_area(p1, p2, p3)\n            mass_per_element = self.rho0 * self.t * area\n            lumped_mass_per_node = mass_per_element / 3.0\n            for idx in tri_indices:\n                nodal_masses[idx] += lumped_mass_per_node\n        return np.sum(nodal_masses)\n\n    def run_case(self, polyline_current, F_matrix):\n        \"\"\"Runs a single cutting test case.\"\"\"\n        self.nodes = self.nodes_orig[:]\n        self.triangles = [tri[:] for tri in self.triangles_orig]\n\n        if not np.allclose(F_matrix, np.identity(2)):\n            F_inv = np.linalg.inv(F_matrix)\n            ref_polyline = [F_inv @ p for p in polyline_current]\n        else:\n            ref_polyline = polyline_current\n\n        node_map = {tuple(np.round(n, 12)): i for i, n in enumerate(self.nodes)}\n\n        def get_or_add_node(p):\n            p_tuple = tuple(np.round(p, 12))\n            if p_tuple in node_map:\n                return node_map[p_tuple]\n            \n            new_idx = len(self.nodes)\n            self.nodes.append(p)\n            node_map[p_tuple] = new_idx\n            return new_idx\n\n        for i_seg in range(len(ref_polyline) - 1):\n            seg_p1, seg_p2 = ref_polyline[i_seg], ref_polyline[i_seg + 1]\n            \n            newly_created_triangles = []\n            triangles_to_remove_indices = set()\n\n            for i_tri, tri_indices in enumerate(self.triangles):\n                tri_coords = [self.nodes[idx] for idx in tri_indices]\n                \n                intersections = []\n                for j in range(3):\n                    edge_p1_idx, edge_p2_idx = tri_indices[j], tri_indices[(j + 1) % 3]\n                    edge_p1, edge_p2 = tri_coords[j], tri_coords[(j + 1) % 3]\n                    \n                    intersection_pt = find_segment_intersection(seg_p1, seg_p2, edge_p1, edge_p2)\n                    \n                    if intersection_pt is not None:\n                        is_duplicate = any(np.allclose(intersection_pt, existing_pt[1]) for existing_pt in intersections)\n                        if not is_duplicate:\n                            intersections.append(((edge_p1_idx, edge_p2_idx), intersection_pt))\n\n                if len(intersections) == 2:\n                    edge1_indices, P = intersections[0]\n                    edge2_indices, Q = intersections[1]\n\n                    shared_v_idx_set = set(edge1_indices)  set(edge2_indices)\n                    if not shared_v_idx_set:\n                        continue\n                    \n                    V_idx = shared_v_idx_set.pop()\n                    V1_idx = (set(edge1_indices) - {V_idx}).pop()\n                    V2_idx = (set(edge2_indices) - {V_idx}).pop()\n\n                    P_idx = get_or_add_node(P)\n                    Q_idx = get_or_add_node(Q)\n                    \n                    newly_created_triangles.append([V_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, Q_idx, V2_idx])\n                    \n                    triangles_to_remove_indices.add(i_tri)\n\n            if triangles_to_remove_indices:\n                self.triangles = [tri for i, tri in enumerate(self.triangles) if i not in triangles_to_remove_indices]\n                self.triangles.extend(newly_created_triangles)\n\n        post_cut_mass = self._calculate_total_mass(self.nodes, self.triangles)\n        discrepancy = abs(post_cut_mass - self.pre_cut_mass)\n        return discrepancy\n\ndef solve():\n    RHO_0 = 7800.0\n    THICKNESS = 0.01\n\n    F_I = np.identity(2)\n    F_high = np.array([[1.8, 0.9], [0.2, 0.7]])\n\n    cut1 = [np.array([-0.2, 0.5]), np.array([1.2, 0.5])]\n    cut2 = [np.array([0.0, 0.0]), np.array([1.0, 1.0])]\n    cut3 = [np.array([-0.2, 0.2]), np.array([0.3, 0.6]), np.array([0.7, 0.4]), np.array([1.2, 0.8])]\n\n    test_cases = [\n        (cut1, F_I),\n        (cut2, F_I),\n        (cut3, F_high)\n    ]\n\n    results = []\n    \n    cutter = MeshCutter(Nx=3, Ny=3, rho0=RHO_0, t=THICKNESS)\n    for polyline, F in test_cases:\n        discrepancy = cutter.run_case(polyline, F)\n        results.append(discrepancy)\n\n    formatted_results = [\"{:.12f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}