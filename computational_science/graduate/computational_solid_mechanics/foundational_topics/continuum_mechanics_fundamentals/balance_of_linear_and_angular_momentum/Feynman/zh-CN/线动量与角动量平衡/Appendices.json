{
    "hands_on_practices": [
        {
            "introduction": "有限元法的核心是验证其能否准确再现基本的物理状态。常应力分片检验（patch test）是验证有限元单元离散格式是否正确的基石，它要求单元集合在常应力场下能够精确再现平衡状态，即内力的合力与合力矩均为零。通过这项实践，你将实现这一关键测试，从而深刻理解离散化的平衡方程如何确保线动量和角动量在静态下的守恒。",
            "id": "3546843",
            "problem": "考虑一个二维小应变连续体，其占据一个平面上的有界多边形域，坐标单位为米。假设体力与惯性为零，因此在线性动量守恒下，内部的平衡方程简化为 $ \\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} $，其中 $ \\boldsymbol{\\sigma} $ 是柯西应力张量。进一步假设柯西应力张量在整个域内是空间均匀且对称的，即 $ \\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\top} $。边界面力在概念上取为 $ \\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n} $，从而使连续体在均匀应力状态下处于平衡。\n\n给定由线性三节点三角形单元（也称为 $ P_1 $ 单元）组成的网格。对于每个节点位置为 $ (x_1,y_1) $、$ (x_2,y_2) $ 和 $ (x_3,y_3) $ 的单元，其形函数 $ N_1 $、$ N_2 $ 和 $ N_3 $ 是线性的，并满足单位分解 $ \\sum_{i=1}^{3} N_i = 1 $ 和线性完备性 $ \\sum_{i=1}^{3} x_i N_i = x $、$ \\sum_{i=1}^{3} y_i N_i = y $。在线性三角形单元内，梯度 $ \\nabla N_i $ 是一个常数。利用虚功原理以及线性和角动量守恒，通过在每个单元上对应力与从 $ \\nabla N_i $ 导出的适当检验函数进行积分，并将贡献值累加到共享节点上，可以得到组装后的内部节点力向量。取单位厚度，因此力的单位是牛顿（N），力矩的单位是牛顿米（N·m）。\n\n任务：实现一个常应力片元检验。对于每个给定的网格和指定的均匀对称柯西应力 $ \\boldsymbol{\\sigma} $，计算组装后的内部节点力。然后通过检查以下内容来验证全局守恒性：\n- 合内力 $ \\boldsymbol{F} = \\sum_{a} \\boldsymbol{f}_a $ 在数值上为零（全局线性动量守恒），其中 $ \\boldsymbol{f}_a $ 是节点 $ a $ 处的内部节点力。\n- 绕原点的合内力矩 $ M_z = \\sum_{a} (x_a f_{a,y} - y_a f_{a,x}) $ 在数值上为零（全局角动量守恒），其中 $ (x_a,y_a) $ 是节点坐标，$ (f_{a,x}, f_{a,y}) $ 是 $ \\boldsymbol{f}_a $ 的分量。\n\n你必须使用线性的形函数梯度（每个单元内为常数），以闭合形式精确处理每个三角形单元，并且必须在共享节点上将贡献值累加起来。使用 $ 10^{-9} $ N 作为合力大小 $ \\| \\boldsymbol{F} \\|_2 $ 的数值公差，以及 $ 10^{-9} $ N·m 作为 $ |M_z| $ 的数值公差，来判断“消失”是否成立。\n\n物理单位：\n- 坐标单位为米 (m)。\n- 应力分量单位为帕斯卡 (Pa)。\n- 厚度为单位长度 (m)。\n- 力的单位为牛顿 (N)。\n- 力矩单位为牛顿米 (N·m)。\n\n本问题不使用角度单位。\n\n测试套件：\n对于每个测试用例，给定一组节点、一个三角剖分（单元），以及一个单位为帕斯卡的均匀对称柯西应力张量 $ \\boldsymbol{\\sigma} $。\n- 测试用例1（正常情况，凸形方形网格）：\n  - 节点：$ [(0,0), (1,0), (1,1), (0,1)] $。\n  - 单元（基于0的节点索引）：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 2.0\\times 10^6  0.5\\times 10^6 \\\\ 0.5\\times 10^6  1.0\\times 10^6 \\end{bmatrix} $ Pa。\n- 测试用例2（扭斜四边形网格）：\n  - 节点：$ [(0.0,0.0), (2.0,0.2), (2.2,1.0), (0.3,1.2)] $。\n  - 单元：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 0.0  3.0\\times 10^6 \\\\ 3.0\\times 10^6  0.0 \\end{bmatrix} $ Pa。\n- 测试用例3（单个三角形，类似边界的情况）：\n  - 节点：$ [(0.0,0.0), (2.0,0.0), (0.0,1.0)] $。\n  - 单元：$ [(0,1,2)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 1.0\\times 10^6  0.0 \\\\ 0.0  1.0\\times 10^6 \\end{bmatrix} $ Pa。\n- 测试用例4（细长的近退化三角形）：\n  - 节点：$ [(0.0,0.0), (1.0,1.0\\times 10^{-8}), (1.0,0.0), (0.5,1.0\\times 10^{-8})] $。\n  - 单元：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 4.0\\times 10^6  2.0\\times 10^6 \\\\ 2.0\\times 10^6  0.5\\times 10^6 \\end{bmatrix} $ Pa。\n\n要求输出：\n你的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身是一个包含两个布尔值的列表 `[force_zero, moment_zero]`，其中如果 $ \\| \\boldsymbol{F} \\|_2  10^{-9} $ N，则 `force_zero` 为 true，如果 $ |M_z|  10^{-9} $ N·m，则 `moment_zero` 为 true。例如：`[[true,true],[true,true],...]`。",
            "solution": "该问题陈述是计算固体力学中的一个有效练习，具体来说是针对线性三角形单元的常应力片元检验。它具有科学依据，问题提法恰当，并为求解提供了所有必要信息。\n\n解法源于虚功原理，该原理指出，对于处于平衡状态的物体，由应力所做的内虚功等于由外加载荷所做的外虚功。对于没有体力的连续体域 $\\Omega$，内虚功 $\\delta W_{\\text{int}}$ 由下式给出：\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV\n$$\n其中 $\\boldsymbol{\\sigma}$ 是柯西应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量。\n\n在有限元方法中，域 $\\Omega$ 被离散为单元。在每个单元 $\\Omega_e$ 内，位移场 $\\boldsymbol{u}$ 通过形函数矩阵 $\\boldsymbol{N}$ 从节点位移 $\\boldsymbol{d}^e$ 插值得到：\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{N}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\n小应变张量 $\\boldsymbol{\\varepsilon}$ 通过应变-位移矩阵 $\\boldsymbol{B}$ 与节点位移相关：\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\boldsymbol{B}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\n虚应变则为 $\\delta\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\delta\\boldsymbol{d}^e$。将其代入虚功表达式，并使用Voigt标记法（其中应力 $\\boldsymbol{\\sigma}$ 和应变 $\\boldsymbol{\\varepsilon}$ 表示为向量）来表示张量点积，可得：\n$$\n\\delta W_{\\text{int}}^e = \\int_{\\Omega_e} (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV = (\\delta\\boldsymbol{d}^e)^T \\left( \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV \\right)\n$$\n内虚功也定义为内部节点力 $\\boldsymbol{f}_{\\text{int}}^e$ 所做的功：\n$$\n\\delta W_{\\text{int}}^e = (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{f}_{\\text{int}}^e\n$$\n通过比较这两个表达式，可得单元内部力向量为：\n$$\n\\boldsymbol{f}_{\\text{int}}^e = \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV\n$$\n对于单位厚度 $h=1$ 的二维问题，体积积分变为面积积分。对于线性三角形单元，形函数的梯度是常数，这使得矩阵 $\\boldsymbol{B}$ 也是常数。鉴于应力张量 $\\boldsymbol{\\sigma}$ 也是均匀的，该积分简化为：\n$$\n\\boldsymbol{f}_{\\text{int}}^e = A_e \\, h \\, \\boldsymbol{B}^T \\boldsymbol{\\sigma} = A_e \\boldsymbol{B}^T \\boldsymbol{\\sigma}\n$$\n其中 $A_e$ 是单元的面积。\n\n一种更直接的方法是避免构造完整的 $\\boldsymbol{B}$ 矩阵。单元单个节点 $i$ 上的力 $\\boldsymbol{f}_i^e$ 可以通过考虑其对虚功的贡献来找到。结果为：\n$$\n\\boldsymbol{f}_i^e = \\int_{A_e} (\\nabla N_i)^T \\boldsymbol{\\sigma} \\, dA\n$$\n其中 $N_i$ 是节点 $i$ 的形函数。由于 $\\nabla N_i$ 和 $\\boldsymbol{\\sigma}$ 是常数，因此：\n$$\n\\boldsymbol{f}_i^e = A_e (\\nabla N_i)^T \\boldsymbol{\\sigma}\n$$\n对于顶点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的线性三角形，其形函数 $N_i$ 的梯度为：\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A_e} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix}\n$$\n其中 $A_e = \\frac{1}{2} (x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2))$ 是三角形的有向面积，系数为：\n$$\n\\begin{array}{lll}\nb_1 = y_2 - y_3  \\quad  c_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1  \\quad  c_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2  \\quad  c_3 = x_2 - x_1\n\\end{array}\n$$\n应力张量为 $\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{xx}  \\sigma_{xy} \\\\ \\sigma_{yx}  \\sigma_{yy} \\end{pmatrix}$。由于它是对称的，所以 $\\sigma_{xy} = \\sigma_{yx}$。\n节点 $i$ 的力向量 $\\boldsymbol{f}_i^e = (f_{ix}^e, f_{iy}^e)^T$ 计算如下：\n$$\n\\boldsymbol{f}_i^e = A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x}  \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} \\begin{pmatrix} \\sigma_{xx}  \\sigma_{xy} \\\\ \\sigma_{xy}  \\sigma_{yy} \\end{pmatrix}\n= A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_i}{\\partial y} \\sigma_{xy} \\\\ \\frac{\\partial N_i}{\\partial x} \\sigma_{xy} + \\frac{\\partial N_i}{\\partial y} \\sigma_{yy} \\end{pmatrix}\n$$\n代入梯度的表达式：\n$$\nf_{ix}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xx} + \\frac{c_i}{2A_e} \\sigma_{xy} \\right) = \\frac{1}{2} (b_i \\sigma_{xx} + c_i \\sigma_{xy})\n$$\n$$\nf_{iy}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xy} + \\frac{c_i}{2A_e} \\sigma_{yy} \\right) = \\frac{1}{2} (b_i \\sigma_{xy} + c_i \\sigma_{yy})\n$$\n片元检验要求验证全局平衡。总内力 $\\boldsymbol{F}$ 是所有组装节点力 $\\boldsymbol{f}_a$ 的总和：\n$$\n\\boldsymbol{F} = \\sum_a \\boldsymbol{f}_a = \\sum_a \\left( \\sum_{e \\in \\text{patch}(a)} \\boldsymbol{f}_{a,e} \\right) = \\sum_e \\sum_{i=1}^3 \\boldsymbol{f}_i^e\n$$\n单个单元的力之和为零，因为 $\\sum_i b_i = (y_2 - y_3) + (y_3 - y_1) + (y_1 - y_2) = 0$ 并且 $\\sum_i c_i = (x_3 - x_2) + (x_1 - x_3) + (x_2 - x_1) = 0$。因此，任何单元片元的总力 $\\boldsymbol{F}$ 必须为零。\n\n绕原点的总力矩 $M_z$ 是所有组装节点力产生的力矩之和：\n$$\nM_z = \\sum_a (x_a f_{a,y} - y_a f_{a,x}) = \\sum_e \\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e)\n$$\n其中 $(x_i, y_i)$ 是单元 $e$ 的节点坐标。可以通过代数运算证明，单个单元的力矩贡献为零：$\\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e) = 0$。这依赖于恒等式 $\\sum y_i b_i = 0$、$\\sum x_i c_i = 0$ 以及 $\\sum x_i b_i = \\sum y_i c_i = 2A_e$。因此，任何片元的总力矩 $M_z$ 也必须为零。\n\n对每个测试用例，算法流程如下：\n1. 初始化一个所有节点上的全局力向量，其值全为零。\n2. 对于每个三角形单元：\n    a. 确定其三个节点的坐标 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$。\n    b. 计算 $i=1, 2, 3$ 对应的系数 $b_i$ 和 $c_i$。\n    c. 使用推导出的公式计算三个节点中每个节点的单元节点力分量 $(f_{ix}^e, f_{iy}^e)$。\n    d. 将这些单元力添加到全局力向量的相应条目中。\n3. 处理完所有单元后，通过对全局力向量中的所有向量求和来计算合力 $\\boldsymbol{F}$。检查其 L2-范数 $\\|\\boldsymbol{F}\\|_2$ 是否小于公差 $10^{-9}$。\n4. 通过对所有节点的叉积 $\\boldsymbol{r}_a \\times \\boldsymbol{f}_a$ 求和来计算合力矩 $M_z$。检查其绝对值 $|M_z|$ 是否小于公差 $10^{-9}$。\n5. 记录力与力矩检查的布尔结果。\n\n这个过程严格测试了线性三角形的有限元公式是否满足恒定应力状态下的线性和角动量基本守恒定律，这是任何有限元代码的关键验证测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a constant-stress patch test on several 2D triangular meshes.\n    Verifies that the sum of internal nodal forces and the sum of moments of these\n    forces about the origin are numerically zero, as required by the principles\n    of conservation of linear and angular momentum for a body in equilibrium.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[2.0e6, 0.5e6], [0.5e6, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.2), (2.2, 1.0), (0.3, 1.2)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[0.0, 3.0e6], [3.0e6, 0.0]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"stress\": np.array([[1.0e6, 0.0], [0.0, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0e-8), (1.0, 0.0), (0.5, 1.0e-8)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[4.0e6, 2.0e6], [2.0e6, 0.5e6]])\n        }\n    ]\n\n    results = []\n    \n    # Set the numerical tolerance.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        nodes = np.array(case[\"nodes\"], dtype=np.float64)\n        elements = np.array(case[\"elements\"], dtype=np.int64)\n        stress = case[\"stress\"]\n        \n        num_nodes = len(nodes)\n        global_forces = np.zeros((num_nodes, 2), dtype=np.float64)\n\n        # Extract stress components\n        s_xx = stress[0, 0]\n        s_yy = stress[1, 1]\n        s_xy = stress[0, 1]  # Stress tensor is symmetric\n\n        # Loop over each element to calculate and assemble internal forces\n        for element_indices in elements:\n            # Get nodal coordinates for the current element\n            p1 = nodes[element_indices[0]]\n            p2 = nodes[element_indices[1]]\n            p3 = nodes[element_indices[2]]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            x3, y3 = p3\n            \n            # Calculate coefficients for shape function gradients\n            # b_i = y_j - y_k, c_i = x_k - x_j (for i,j,k in cyclic order)\n            b1 = y2 - y3\n            c1 = x3 - x2\n            \n            b2 = y3 - y1\n            c2 = x1 - x3\n            \n            b3 = y1 - y2\n            c3 = x2 - x1\n            \n            b_coeffs = [b1, b2, b3]\n            c_coeffs = [c1, c2, c3]\n\n            # Calculate elemental nodal forces\n            # f_ix = 0.5 * (b_i * sigma_xx + c_i * sigma_xy)\n            # f_iy = 0.5 * (b_i * sigma_xy + c_i * sigma_yy)\n            for i in range(3):\n                node_global_idx = element_indices[i]\n                b_i = b_coeffs[i]\n                c_i = c_coeffs[i]\n                \n                f_ix = 0.5 * (b_i * s_xx + c_i * s_xy)\n                f_iy = 0.5 * (b_i * s_xy + c_i * s_yy)\n                \n                # Assemble into global force vector\n                global_forces[node_global_idx, 0] += f_ix\n                global_forces[node_global_idx, 1] += f_iy\n\n        # --- Verification Step ---\n        \n        # 1. Check balance of linear momentum (resultant force)\n        total_force = np.sum(global_forces, axis=0)\n        force_magnitude = np.linalg.norm(total_force)\n        force_is_zero = force_magnitude  tolerance\n\n        # 2. Check balance of angular momentum (resultant moment about origin)\n        total_moment = 0.0\n        for i in range(num_nodes):\n            x_i, y_i = nodes[i]\n            f_ix, f_iy = global_forces[i]\n            total_moment += x_i * f_iy - y_i * f_ix\n            \n        moment_is_zero = abs(total_moment)  tolerance\n        \n        # Store results as strings 'true'/'false' for output formatting\n        results.append(f\"[{str(force_is_zero).lower()},{str(moment_is_zero).lower()}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从静态分析过渡到动态分析，我们不仅要离散化刚度，还必须离散化惯性。在有限元法中，质量矩阵的构造通常有一致质量和集总质量两种选择，这个选择对模拟结果有着深远影响。本实践将引导你通过编程探索这两种质量矩阵在模拟刚体旋转时对角动量守恒的不同表现，揭示离散化方法如何影响物理守恒律的保持。",
            "id": "3546856",
            "problem": "您需要实现一个程序，研究有限元法 (FEM) 中离散质量表示的选择如何影响自由刚体旋转过程中的角动量守恒，量化误差并应用修正。重点是弹性体在自由旋转下的线动量和角动量平衡，在这种情况下，运动学简化为刚体运动，且在没有应变的情况下内部弹性力消失。\n\n作为起点的基本假设和定律是：\n- 积分形式的牛顿第二定律（针对连续体）：对于任何区域，其质量密度为 $\\rho$，单位质量的体力为 $\\mathbf{b}$，边界上的面力为 $\\mathbf{t}$，速度场为 $\\mathbf{v}$，\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{t}\\,dS.$$\n- 积分形式的角动量平衡：\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{x}\\times\\mathbf{t}\\,dS.$$\n- 自由刚体旋转对应于 $\\mathbf{b}=\\mathbf{0}$ 且无边界面力，速度场为 $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$，其中 $\\boldsymbol{\\omega}$ 是角速度矢量，$\\mathbf{x}_{\\mathrm{cm}}$ 是质心。\n\n在平面体的离散 FEM 设置中，对于线性三角形网格，质量矩阵可以以两种形式构建：\n- 一致质量矩阵 $M$，定义为\n$$M=\\int_{\\Omega}\\rho\\,\\mathbf{N}\\mathbf{N}^{T}\\,d\\Omega,$$\n其中 $\\mathbf{N}$ 集合了标量形函数，对于矢量自由度以块对角方式组装。\n- 集中质量向量 $m$，通过对一致质量矩阵进行对角化得到，使得每个标量自由度的节点质量为 $m_{i}=\\sum_{j}M_{ij}$。\n\n对于节点值的速度向量 $\\mathbf{v}_{h}$，离散线动量为\n$$\\mathbf{p}_{\\mathrm{cons}} = M\\,\\mathbf{v}_{h},\\quad \\mathbf{p}_{\\mathrm{lump}} = \\mathrm{diag}(m)\\,\\mathbf{v}_{h}.$$\n关于质心 $\\mathbf{x}_{\\mathrm{cm}}$ 的离散角动量计算如下\n$$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{cons},a},\\quad \\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{lump},a},$$\n其中 $\\mathbf{x}_{a}$ 是节点位置，$\\mathbf{p}_{\\cdot,a}$ 是节点动量矢量。\n\n您的程序必须：\n1. 构建一个以原点为中心的宽度为 $W$、高度为 $H$ 的矩形的平面网格，离散为 $n_{x}\\times n_{y}$ 个矩形单元，每个单元被分成两个三角形。假设厚度 $t$ 和密度 $\\rho$ 均匀。\n2. 逐单元组装线性三角形的一致质量贡献，使用精确积分为标量质量子矩阵\n$$M_{e}^{\\mathrm{scalar}}=\\rho\\,t\\,\\frac{A_{e}}{12}\\begin{bmatrix}2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{bmatrix},$$\n并对矢量自由度进行块对角组装。\n3. 使用 $m_{i} = \\rho\\,t\\,\\sum_{e\\ni i}\\frac{A_{e}}{3}$ 组装每个节点的集中质量（对于每个标量自由度，两个面内方向相同）。\n4. 将节点速度初始化为刚体场 $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$，其中 $\\boldsymbol{\\omega}=(0,0,\\omega_{z})$，$\\omega_{z}$ 为指定值。使用由集中质量计算出的质量加权质心作为 $\\mathbf{x}_{\\mathrm{cm}}$。\n5. 计算离散角动量 $\\mathbf{L}_{\\mathrm{cons}}$ 和 $\\mathbf{L}_{\\mathrm{lump}}$，并报告相对误差\n$$E=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n6. 提出并应用一个修正：计算集中惯性张量\n$$I_{\\mathrm{lump}}=\\sum_{a=1}^{N}m_{a}\\left(\\|\\mathbf{r}_{a}\\|^{2}I_{3}-\\mathbf{r}_{a}\\mathbf{r}_{a}^{T}\\right),\\quad \\mathbf{r}_{a}=\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}},$$\n求解修正角速度\n$$\\delta\\boldsymbol{\\omega}=I_{\\mathrm{lump}}^{-1}\\left(\\mathbf{L}_{\\mathrm{cons}}-\\mathbf{L}_{\\mathrm{lump}}\\right),$$\n应用修正后的速度 $\\mathbf{v}_{a}^{\\mathrm{corr}}=\\mathbf{v}_{a}+\\delta\\boldsymbol{\\omega}\\times\\mathbf{r}_{a}$，并重新计算 $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$。报告修正后的相对误差\n$$E_{\\mathrm{corr}}=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n\n物理单位：使用国际单位制 (SI)。输入参数中，$W$ 和 $H$ 的单位是米 ($\\mathrm{m}$)，$\\rho$ 的单位是千克每立方米 ($\\mathrm{kg/m^{3}}$)，$t$ 的单位是米 ($\\mathrm{m}$)，$\\omega_{z}$ 的单位是弧度每秒 ($\\mathrm{rad/s}$)。输出是无量纲的浮点数（相对误差），因此不需要单位转换。\n\n您的程序应为以下参数值的测试套件生成结果：\n- 测试用例 1（正常路径，粗网格）：$W=1.0$, $H=1.0$, $n_{x}=2$, $n_{y}=2$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=3.0$。\n- 测试用例 2（边界情况，单单元）：$W=1.0$, $H=1.0$, $n_{x}=1$, $n_{y}=1$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=2.0$。\n- 测试用例 3（非正方形矩形，中等分辨率）：$W=2.0$, $H=0.5$, $n_{x}=20$, $n_{y}=5$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=1.5$。\n- 测试用例 4（细网格，较大自旋）：$W=1.0$, $H=1.0$, $n_{x}=40$, $n_{y}=40$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=7.0$。\n\n对于每个测试用例，计算并返回一个包含两个浮点数 $[E,E_{\\mathrm{corr}}]$ 的列表。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的列表的逗号分隔列表。例如：“[[e1_before,e1_after],[e2_before,e2_after],...]”。",
            "solution": "该问题已经过验证，被确定为一个在计算固体力学领域定义良好且科学上合理的问题。它探讨了在刚体旋转的有限元法 (FEM) 模拟中，不同质量集中方案对角动量守恒的影响。所提供的量化和修正方法是标准且正确的。我们将继续详细推导计算步骤。\n\n该解决方案按照问题陈述中规定的任务顺序实现。\n\n1.  **网格生成**\n    一个宽度为 $W$、高度为 $H$ 的矩形域以原点为中心，因此其角点位于 $(\\pm W/2, \\pm H/2)$。该域被离散化为一个 $n_{x} \\times n_{y}$ 的矩形单元格网格。网格的节点位于网格点上。节点数量为 $N_{nodes}=(n_{x}+1)(n_{y}+1)$。位于网格位置 $(i,j)$ 的节点的坐标 $(x_i, y_j)$ 由以下公式给出：\n    $$x_i = -\\frac{W}{2} + i \\frac{W}{n_x}, \\quad i=0, 1, \\dots, n_x$$\n    $$y_j = -\\frac{H}{2} + j \\frac{H}{n_y}, \\quad j=0, 1, \\dots, n_y$$\n    每个矩形单元随后被细分为两个线性三角形单元。在所有单元中都使用了一致的对角分割模式，例如，连接每个单元的左下角到右上角。这个过程生成了 $2 \\times n_x \\times n_y$ 个三角形单元。对于这种结构化网格，每个三角形的面积 $A_e$ 是恒定的：\n    $$A_e = \\frac{1}{2}\\left(\\frac{W}{n_x}\\right)\\left(\\frac{H}{n_y}\\right)$$\n\n2.  **一致质量矩阵组装**\n    该问题涉及平面运动，每个节点有两个自由度 (DOF)（每个笛卡尔坐标方向 $x$ 和 $y$ 各一个）。总自由度数为 $N_{dof} = 2 N_{nodes}$。一致质量矩阵 $M$ 由单元级贡献组装而成。对于一个线性三角形，标量单元质量矩阵给出如下：\n    $$M_{e}^{\\mathrm{scalar}}=\\rho t \\frac{A_{e}}{12}\\begin{bmatrix}2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{bmatrix}$$\n    其中 $\\rho$ 是密度，$t$ 是厚度。对于矢量自由度，假设 $x$ 和 $y$ 方向之间没有质量耦合，全局质量矩阵 $M$ 的构造方式是：首先组装一个大小为 $N_{nodes} \\times N_{nodes}$ 的标量质量矩阵 $M_s$，然后填充完整的 $N_{dof} \\times N_{dof}$ 矩阵，使得 $M_{2i,2j} = M_{2i+1,2j+1} = (M_s)_{ij}$ 且 $M_{2i,2j+1} = M_{2i+1,2j} = 0$。矩阵 $M_s$ 是使用标准的 FEM 组装程序构建的，根据节点连接性将所有单元的 $M_{e}^{\\mathrm{scalar}}$ 贡献累加到全局矩阵中。\n\n3.  **集中质量组装**\n    集中质量矩阵是一个对角矩阵。每个节点 $a$ 处的标量质量 $m_a$ 是通过对标量一致质量矩阵 $M_s$ 对应行中的元素求和得到的：\n    $$m_a = \\sum_{j=1}^{N_{nodes}} (M_s)_{aj}$$\n    这等同于所提供的公式 $m_a = \\rho t \\sum_{e \\ni a} \\frac{A_e}{3}$。集中质量矩阵 $M_{\\mathrm{lump}}$ 是一个大小为 $N_{dof} \\times N_{dof}$ 的对角矩阵，其中节点 $a$ 的对角线元素都等于 $m_a$。\n\n4.  **速度初始化**\n    首先，使用集中节点质量计算质心 $\\mathbf{x}_{\\mathrm{cm}}$：\n    $$\\mathbf{x}_{\\mathrm{cm}} = \\frac{\\sum_{a=1}^{N_{nodes}} m_a \\mathbf{x}_a}{\\sum_{a=1}^{N_{nodes}} m_a}$$\n    由于网格的对称性和均匀的密度，计算出的 $\\mathbf{x}_{\\mathrm{cm}}$ 将位于原点 $(0,0)$。节点速度向量 $\\mathbf{v}_h$ 被初始化为表示围绕该质心的角速度为 $\\boldsymbol{\\omega}=(0,0,\\omega_z)$ 的刚体旋转。对于每个位置向量为 $\\mathbf{x}_a$ 的节点 $a$，其速度 $\\mathbf{v}_a$ 为：\n    $$\\mathbf{v}_a = \\boldsymbol{\\omega} \\times (\\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}})$$\n    在分量形式下，设 $\\mathbf{r}_a = \\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}} = (r_{ax}, r_{ay})$，速度为 $\\mathbf{v}_a = (-\\omega_z r_{ay}, \\omega_z r_{ax})$。这些值填充了全局速度向量 $\\mathbf{v}_h$。\n\n5.  **角动量与误差计算**\n    针对两种质量表示，计算节点线动量矢量：\n    $$\\mathbf{p}_{\\mathrm{cons}} = M \\mathbf{v}_h \\quad \\text{和} \\quad \\mathbf{p}_{\\mathrm{lump}} = M_{\\mathrm{lump}} \\mathbf{v}_h$$\n    然后通过对每个节点 $a$ 的贡献求和，计算关于 $\\mathbf{x}_{\\mathrm{cm}}$ 的总离散角动量：\n    $$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{cons},a}$$\n    $$\\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{lump},a}$$\n    其中 $\\mathbf{p}_{\\cdot,a}$ 是节点 $a$ 的二维线动量矢量。对于这个平面问题，角动量矢量将只具有非零的 $z$ 分量。相对误差 $E$ 计算如下：\n    $$E = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n\n6.  **修正程序**\n    为了修正集中质量的角动量，应用了一个修正速度场。首先，计算集中惯性张量 $I_{\\mathrm{lump}}$。它代表了集中质量系统的转动惯量：\n    $$I_{\\mathrm{lump}}=\\sum_{a=1}^{N_{nodes}} m_a (\\|\\mathbf{r}_a\\|^2 I_3 - \\mathbf{r}_a \\mathbf{r}_a^T)$$\n    其中 $I_3$ 是 $3 \\times 3$ 单位矩阵，$\\mathbf{r}_a$ 是三维位置矢量（$z=0$）。角动量差异 $\\Delta \\mathbf{L} = \\mathbf{L}_{\\mathrm{cons}} - \\mathbf{L}_{\\mathrm{lump}}$ 用于通过求解线性系统来找到修正角速度 $\\delta \\boldsymbol{\\omega}$：\n    $$I_{\\mathrm{lump}} \\, \\delta\\boldsymbol{\\omega} = \\Delta \\mathbf{L}$$\n    然后修正节点速度：\n    $$\\mathbf{v}_{a}^{\\mathrm{corr}} = \\mathbf{v}_a + \\delta\\boldsymbol{\\omega} \\times \\mathbf{r}_a$$\n    使用修正后的速度向量 $\\mathbf{v}_h^{\\mathrm{corr}}$，重新计算集中角动量，得到 $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$。根据构造，$\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$ 应等于 $\\mathbf{L}_{\\mathrm{cons}}$。计算最终的修正后相对误差 $E_{\\mathrm{corr}}$，预期该值接近机器精度零。\n    $$E_{\\mathrm{corr}} = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n每个测试用例的结果由一对 $[E, E_{\\mathrm{corr}}]$ 组成。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    def solve_case(W, H, nx, ny, rho, t, omega_z):\n        \"\"\"\n        Computes the angular momentum errors for a single test case.\n\n        Args:\n            W (float): Width of the rectangle.\n            H (float): Height of the rectangle.\n            nx (int): Number of cells in the x-direction.\n            ny (int): Number of cells in the y-direction.\n            rho (float): Material density.\n            t (float): Thickness of the planar body.\n            omega_z (float): Angular velocity about the z-axis.\n\n        Returns:\n            list[float, float]: A list containing the initial relative error E and the corrected relative error E_corr.\n        \"\"\"\n        # 1. Mesh Generation\n        num_nodes = (nx + 1) * (ny + 1)\n        nodes = np.zeros((num_nodes, 2), dtype=np.float64)\n        node_map = {}\n        k = 0\n        dx, dy = W / nx, H / ny\n        for j in range(ny + 1):\n            for i in range(nx + 1):\n                nodes[k] = [-W/2 + i * dx, -H/2 + j * dy]\n                node_map[(i, j)] = k\n                k += 1\n\n        elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n1 = node_map[(i, j)]\n                n2 = node_map[(i + 1, j)]\n                n3 = node_map[(i + 1, j + 1)]\n                n4 = node_map[(i, j + 1)]\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n\n        Ae = 0.5 * dx * dy\n\n        # 2. Consistent Mass Matrix Assembly\n        M_scalar = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n        M_element_scalar = (rho * t * Ae / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        for el_nodes in elements:\n            for i_local in range(3):\n                for j_local in range(3):\n                    i_global = el_nodes[i_local]\n                    j_global = el_nodes[j_local]\n                    M_scalar[i_global, j_global] += M_element_scalar[i_local, j_local]\n\n        num_dofs = 2 * num_nodes\n        M_consistent = np.zeros((num_dofs, num_dofs), dtype=np.float64)\n        for i in range(num_nodes):\n            for j in range(num_nodes):\n                M_consistent[2*i, 2*j] = M_scalar[i, j]\n                M_consistent[2*i+1, 2*j+1] = M_scalar[i, j]\n\n        # 3. Lumped Mass Assembly\n        m_scalar = np.sum(M_scalar, axis=1)\n        M_lumped_diag = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            M_lumped_diag[2*i] = m_scalar[i]\n            M_lumped_diag[2*i+1] = m_scalar[i]\n\n        # 4. Velocity Initialization\n        # Center of mass is (0,0) by symmetry. Using analytical result avoids float precision issues.\n        x_cm = np.array([0.0, 0.0])\n        r_nodes = nodes - x_cm\n        v_h = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            v_h[2*i]   = -omega_z * r_nodes[i, 1]\n            v_h[2*i+1] =  omega_z * r_nodes[i, 0]\n\n        # 5. Angular Momentum and Error Calculation\n        p_cons = M_consistent @ v_h\n        p_lump = M_lumped_diag * v_h\n\n        L_cons_z = np.sum(r_nodes[:, 0] * p_cons[1::2] - r_nodes[:, 1] * p_cons[0::2])\n        L_lump_z = np.sum(r_nodes[:, 0] * p_lump[1::2] - r_nodes[:, 1] * p_lump[0::2])\n        \n        L_cons_vec = np.array([0.0, 0.0, L_cons_z])\n        L_lump_vec = np.array([0.0, 0.0, L_lump_z])\n        \n        norm_L_cons = np.linalg.norm(L_cons_vec)\n        error = np.linalg.norm(L_lump_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n\n        # 6. Correction Procedure\n        I_lump = np.zeros((3, 3), dtype=np.float64)\n        r_nodes_3d = np.hstack([r_nodes, np.zeros((num_nodes, 1), dtype=np.float64)])\n        for i in range(num_nodes):\n            r_vec = r_nodes_3d[i, :]\n            I_node = m_scalar[i] * (np.dot(r_vec, r_vec) * np.eye(3) - np.outer(r_vec, r_vec))\n            I_lump += I_node\n        \n        delta_L = L_cons_vec - L_lump_vec\n        \n        try:\n            delta_omega_vec = np.linalg.solve(I_lump, delta_L)\n        except np.linalg.LinAlgError:\n            delta_omega_vec = np.zeros(3)\n\n        v_h_corr = np.copy(v_h)\n        for i in range(num_nodes):\n            v_corr_delta = np.cross(delta_omega_vec, r_nodes_3d[i, :])\n            v_h_corr[2*i]   += v_corr_delta[0]\n            v_h_corr[2*i+1] += v_corr_delta[1]\n            \n        p_lump_corr = M_lumped_diag * v_h_corr\n        \n        L_lump_corr_z = np.sum(r_nodes[:, 0] * p_lump_corr[1::2] - r_nodes[:, 1] * p_lump_corr[0::2])\n        L_lump_corr_vec = np.array([0.0, 0.0, L_lump_corr_z])\n\n        error_corr = np.linalg.norm(L_lump_corr_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n            \n        return [error, error_corr]\n\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1.0, 1.0, 3.0),\n        (1.0, 1.0, 1, 1, 1.0, 1.0, 2.0),\n        (2.0, 0.5, 20, 5, 1.0, 1.0, 1.5),\n        (1.0, 1.0, 40, 40, 1.0, 1.0, 7.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个可靠的动力学模拟器必须严格遵守牛顿-欧拉方程，正确解耦线运动和角运动。本实践旨在设计并实现一个优雅而强大的验证测试：对一个刚体施加一个纯力偶（即合力为零，合力矩不为零）。理论上，这应仅引起转动而非平动，通过检查线动量是否保持为零，你可以验证你的动力学代码是否正确地遵循了线动量和角动量的平衡法则。",
            "id": "3546907",
            "problem": "考虑一个在三维欧几里得空间中的自由刚体，其质量为 $m$，在物体坐标系中的惯性张量 $[\\mathbf{I}_b]$ 是一个常数。该刚体的平移状态由其质心位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$ 给出，其旋转状态由一个单位四元数表示的姿态 $\\mathbf{q}(t)$ 和在惯性（世界）坐标系中的角速度 $\\boldsymbol{\\omega}(t)$ 给出。外力 $\\mathbf{F}_i$ 作用于相对于质心的、固连于刚体上的点 $\\mathbf{r}_{b,i}$。旋转矩阵 $\\mathbf{R}(t)$ 将物体坐标系中的向量映射到世界坐标系中，因此世界坐标系中的作用点为 $\\mathbf{r}_i(t) = \\mathbf{R}(t)\\,\\mathbf{r}_{b,i}$。\n\n基本原理：\n- 线性动量平衡：$\\dfrac{d\\mathbf{P}}{dt} = \\sum_i \\mathbf{F}_i$，其中 $\\mathbf{P} = m\\,\\mathbf{v}$ 是线性动量。\n- 绕质心的角动量平衡：$\\dfrac{d\\mathbf{H}}{dt} = \\sum_i \\left(\\mathbf{r}_i(t) \\times \\mathbf{F}_i\\right)$，其中 $\\mathbf{H}$ 是世界坐标系中的角动量。\n- 运动学关系：$\\mathbf{P} = m\\,\\mathbf{v}$，并且在世界坐标系中，$\\mathbf{H}(t) = \\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t)$，其中 $\\mathbf{I}(t) = \\mathbf{R}(t)\\,[\\mathbf{I}_b]\\,\\mathbf{R}(t)^\\top$。四元数 $\\mathbf{q}(t)$ 的演化与 $\\boldsymbol{\\omega}(t)$ 一致，从而保持 $\\|\\mathbf{q}(t)\\| = 1$。所有角度必须以弧度为单位进行解释。\n\n目标：\n设计并实现一个计算测试，通过在不同点施加大小相等、方向相反的力来产生一个合力为零的净力偶（纯力矩），以检测与线性和角动量平衡相关的代码错误。验证对于各种参数集，只有角向运动发生：线性动量 $\\mathbf{P}(t)$ 和质心速度 $\\mathbf{v}(t)$ 保持为零（在严格的数值公差范围内），而角动量 $\\mathbf{H}(t)$ 随时间变化。\n\n实现要求：\n- 使用一个直接强制执行上述基本平衡关系的时间步进方案。在每个时间步，计算合力 $\\sum_i \\mathbf{F}_i$ 和合力矩 $\\sum_i (\\mathbf{r}_i(t) \\times \\mathbf{F}_i)$，通过时间积分更新 $\\mathbf{P}$ 和 $\\mathbf{H}$，通过求解 $\\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t) = \\mathbf{H}(t)$ 获得 $\\boldsymbol{\\omega}(t)$，并推进 $\\mathbf{q}(t)$，同时保持其单位范数。\n- 从静止开始：$\\mathbf{v}(0) = \\mathbf{0}$，$\\boldsymbol{\\omega}(0) = \\mathbf{0}$，$\\mathbf{P}(0) = \\mathbf{0}$，$\\mathbf{H}(0) = \\mathbf{0}$，以及单位姿态 $\\mathbf{q}(0)$。\n- 使用国际单位制 (SI)：质量单位为 $\\mathrm{kg}$，长度为 $\\mathrm{m}$，时间为 $\\mathrm{s}$，力为 $\\mathrm{N}$，角动量为 $\\mathrm{kg\\,m^2/s}$，线性动量为 $\\mathrm{kg\\,m/s}$。\n- 设数值公差为：线性动量大小的公差 $\\,\\varepsilon_P = 10^{-12}\\,\\mathrm{kg\\,m/s}$，质心速度大小的公差 $\\,\\varepsilon_v = 10^{-12}\\,\\mathrm{m/s}$，并要求角动量变化的最小幅度 $\\Delta H_{\\min} = 10^{-6}\\,\\mathrm{kg\\,m^2/s}$ 来断定角向运动已经发生。\n\n每个测试用例的验收判据：\n- 在最终时间 $T$ 计算 $\\|\\mathbf{P}(T)\\|$ 和 $\\|\\mathbf{v}(T)\\|$。计算 $\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\|$。如果同时满足 $\\|\\mathbf{P}(T)\\| \\le \\varepsilon_P$，$\\|\\mathbf{v}(T)\\| \\le \\varepsilon_v$ 和 $\\Delta H \\ge \\Delta H_{\\min}$，则声明测试用例通过（布尔值 true）。否则，声明其失败（布尔值 false）。\n\n测试套件：\n使用以下五个参数集。在每种情况下，都提供了对角化的物体坐标系惯性 $[\\mathbf{I}_b] = \\mathrm{diag}(I_x, I_y, I_z)$、时间步长 $\\Delta t$ 和持续时间 $T$。所有角度均以弧度为单位。\n\n- 情况 1（纯力偶，力臂和力不共线）：\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$。\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.15,\\,0,\\,0]\\,\\mathrm{m}$。\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$。\n- 情况 2（退化力偶，力作用于同一点）：\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$。\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$。\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$。\n- 情况 3（作用线共线，零力矩）：\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$。\n  - $\\mathbf{r}_{b,1} = [0,\\,0,\\,0.2]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [0,\\,0,\\,-0.2]\\,\\mathrm{m}$。\n  - $\\mathbf{F}_1 = [0,\\,0,\\,5]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$。\n- 情况 4（近似力偶，带有微小合力，应不满足判据）：\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$。\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.15,\\,0,\\,0]\\,\\mathrm{m}$。\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -(1 - 0.02)\\,\\mathbf{F}_1$。\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$。\n- 情况 5（纯力偶，具有一般的非轴对齐的力和力臂）：\n  - $m = 1.2\\,\\mathrm{kg}$, $I_x = 0.4\\,\\mathrm{kg\\,m^2}$, $I_y = 0.4\\,\\mathrm{kg\\,m^2}$, $I_z = 0.6\\,\\mathrm{kg\\,m^2}$。\n  - $\\mathbf{r}_{b,1} = [0.1,\\,0.05,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.05,\\,-0.02,\\,0.03]\\,\\mathrm{m}$。\n  - $\\mathbf{F}_1 = [5,\\,-3,\\,4]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$。\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$。\n\n你的程序必须运行这五个情况，为每个情况评估验收判据，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[true, false, ...]`）。预期的输出是布尔值，每个测试用例一个，按上述情况的顺序排列。不应打印任何其他文本。",
            "solution": "首先对问题进行验证，以确保其科学上合理、良定且完整。\n\n### 步骤 1：提取给定条件\n- **系统**：一个自由刚体，质量为 $m$，具有一个恒定的物体坐标系惯性张量 $[\\mathbf{I}_b]$。\n- **状态变量**：质心位置 $\\mathbf{x}(t)$ 和速度 $\\mathbf{v}(t)$；姿态表示为单位四元数 $\\mathbf{q}(t)$ 和惯性坐标系角速度 $\\boldsymbol{\\omega}(t)$。\n- **动力学**：\n    - 线性动量：$\\mathbf{P} = m\\,\\mathbf{v}$，其变化率为 $\\dfrac{d\\mathbf{P}}{dt} = \\sum_i \\mathbf{F}_i$。\n    - 角动量：$\\mathbf{H}(t) = \\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t)$，其变化率为 $\\dfrac{d\\mathbf{H}}{dt} = \\sum_i (\\mathbf{r}_i(t) \\times \\mathbf{F}_i)$。\n    - 惯性张量变换：$\\mathbf{I}(t) = \\mathbf{R}(t)\\,[\\mathbf{I}_b]\\,\\mathbf{R}(t)^\\top$，其中 $\\mathbf{R}(t)$ 是与 $\\mathbf{q}(t)$ 对应的旋转矩阵。\n    - 力的作用点：$\\mathbf{r}_i(t) = \\mathbf{R}(t)\\,\\mathbf{r}_{b,i}$，其中 $\\mathbf{r}_{b,i}$ 是固连于物体的点。\n- **初始条件**：刚体在 $t=0$ 时从静止开始，即 $\\mathbf{v}(0) = \\mathbf{0}$，$\\boldsymbol{\\omega}(0) = \\mathbf{0}$，这意味着 $\\mathbf{P}(0) = \\mathbf{0}$ 和 $\\mathbf{H}(0) = \\mathbf{0}$。初始姿态 $\\mathbf{q}(0)$ 是单位姿态。\n- **目标**：实现一个计算测试，以验证施加纯力矩（零合力）会产生纯粹的角向运动。\n- **数值实现**：需要一个时间步进方案。在每个时间步，计算合力和力矩，通过积分更新 $\\mathbf{P}$ 和 $\\mathbf{H}$，通过求解 $\\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t) = \\mathbf{H}(t)$ 求得 $\\boldsymbol{\\omega}(t)$，并推进 $\\mathbf{q}(t)$。\n- **验收判据**：对于最终时间 $T$，如果 $\\|\\mathbf{P}(T)\\| \\le \\varepsilon_P$、$\\|\\mathbf{v}(T)\\| \\le \\varepsilon_v$ 和 $\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\| \\ge \\Delta H_{\\min}$，则测试用例通过。\n- **公差**：$\\varepsilon_P = 10^{-12}\\,\\mathrm{kg\\,m/s}$，$\\varepsilon_v = 10^{-12}\\,\\mathrm{m/s}$，$\\Delta H_{\\min} = 10^{-6}\\,\\mathrm{kg\\,m^2/s}$。\n- **测试用例**：提供了五个不同的参数集，指定了 $m$、$[\\mathbf{I}_b]$、力的作用点 $\\mathbf{r}_{b,i}$、力 $\\mathbf{F}_i$、时间步长 $\\Delta t$ 和总时间 $T$。\n\n### 步骤 2：使用提取的给定条件进行验证\n该问题科学地基于经典刚体动力学的牛顿-欧拉方程。所有指定的方程，例如惯性张量的变换以及线性和角动量的定义，都是标准且正确的。这个问题是良定的，为初始值问题提供了完整的初始条件、控制微分方程（隐式地）和参数。语言客观而精确。所提供的数据在量纲上是一致的，并且在物理上是现实的。该任务是计算动力学中的一个标准练习，要求为运动方程实现一个数值积分器。这个问题并非微不足道，其解决方案在算法上是可验证的。\n\n### 步骤 3：结论和行动\n问题被认为是有效的。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n该解决方案涉及在指定的时间间隔 $T$ 内对刚体的运动方程进行数值积分。刚体的状态可以通过其线性动量 $\\mathbf{P}$、角动量 $\\mathbf{H}$ 和姿态四元数 $\\mathbf{q}$ 来描述。质心位置 $\\mathbf{x}$ 对于验证不是必需的。\n\n**1. 控制方程：**\n基本原理是线性和角动量平衡。\n线性动量的变化率等于净外力：\n$$ \\frac{d\\mathbf{P}}{dt} = \\mathbf{F}_{net} = \\sum_{i} \\mathbf{F}_i $$\n绕质心的角动量的变化率等于净外力矩：\n$$ \\frac{d\\mathbf{H}}{dt} = \\boldsymbol{\\tau}_{net} = \\sum_{i} (\\mathbf{r}_i(t) \\times \\mathbf{F}_i) $$\n刚体的姿态由单位四元数 $\\mathbf{q}(t) = [q_w, q_x, q_y, q_z]^\\top$ 表示。其变化率由关联其与世界坐标系角速度 $\\boldsymbol{\\omega}(t)$ 的运动学方程控制：\n$$ \\frac{d\\mathbf{q}}{dt} = \\frac{1}{2} \\mathbf{q} \\otimes \\mathbf{p}(\\boldsymbol{\\omega}) $$\n其中 $\\mathbf{p}(\\boldsymbol{\\omega}) = [0, \\omega_x, \\omega_y, \\omega_z]^\\top$ 是 $\\boldsymbol{\\omega}$ 的纯四元数表示，$\\otimes$ 表示四元数乘法。\n\n**2. 数值积分方案：**\n我们将采用显式前向欧拉积分方案，这是对问题要求的一个直接而简单的解释。对于状态向量 $\\mathbf{Y} = [\\mathbf{P}^\\top, \\mathbf{H}^\\top, \\mathbf{q}^\\top]^\\top$，从时间 $t_k$ 到 $t_{k+1} = t_k + \\Delta t$ 的更新规则是：\n$$ \\mathbf{Y}_{k+1} = \\mathbf{Y}_k + \\left. \\frac{d\\mathbf{Y}}{dt} \\right|_{t_k} \\Delta t $$\n每个时间步的算法如下：\n\n1.  **给定 $t_k$ 时的状态**：$\\mathbf{P}_k$, $\\mathbf{H}_k$, $\\mathbf{q}_k$。\n2.  **计算导出量**：\n    a. 将四元数 $\\mathbf{q}_k$ 转换为旋转矩阵 $\\mathbf{R}_k$。\n    b. 将物体坐标系惯性张量 $[\\mathbf{I}_b]$ 变换到世界坐标系：$\\mathbf{I}_k = \\mathbf{R}_k [\\mathbf{I}_b] \\mathbf{R}_k^\\top$。\n    c. 求解线性系统 $\\mathbf{I}_k \\boldsymbol{\\omega}_k = \\mathbf{H}_k$ 以求得角速度 $\\boldsymbol{\\omega}_k$。\n3.  **计算变化率（导数）**：\n    a. 对所有测试用例，合力 $\\mathbf{F}_{net}$ 是恒定的。\n    b. 将固连于物体的作用点变换到世界坐标系：$\\mathbf{r}_{i,k} = \\mathbf{R}_k \\mathbf{r}_{b,i}$。\n    c. 计算合力矩：$\\boldsymbol{\\tau}_{net,k} = \\sum_i (\\mathbf{r}_{i,k} \\times \\mathbf{F}_i)$。\n    d. 因此时间导数为 $\\dot{\\mathbf{P}}_k = \\mathbf{F}_{net}$ 和 $\\dot{\\mathbf{H}}_k = \\boldsymbol{\\tau}_{net,k}$。\n    e. 计算四元数变化率：$\\dot{\\mathbf{q}}_k = \\frac{1}{2} \\mathbf{q}_k \\otimes \\mathbf{p}(\\boldsymbol{\\omega}_k)$。\n4.  **将状态更新到 $t_{k+1}$**：\n    a. $\\mathbf{P}_{k+1} = \\mathbf{P}_k + \\dot{\\mathbf{P}}_k \\Delta t$。\n    b. $\\mathbf{H}_{k+1} = \\mathbf{H}_k + \\dot{\\mathbf{H}}_k \\Delta t$。\n    c. $\\mathbf{q}_{k+1, \\text{un-normalized}} = \\mathbf{q}_k + \\dot{\\mathbf{q}}_k \\Delta t$。\n5.  **步后校正**：\n    a. 更新后的四元数必须重新归一化以保持其单位长度，这对于它代表有效旋转至关重要：$\\mathbf{q}_{k+1} = \\mathbf{q}_{k+1, \\text{un-normalized}} / \\|\\mathbf{q}_{k+1, \\text{un-normalized}}\\|$。\n\n**3. 初始和最终条件：**\n仿真从 $\\mathbf{P}(0)=\\mathbf{0}$，$\\mathbf{H}(0)=\\mathbf{0}$ 和 $\\mathbf{q}(0) = [1, 0, 0, 0]^\\top$（单位旋转）开始。迭代到最终时间 $T$ 后，计算以下量：\n-   最终质心速度：$\\mathbf{v}(T) = \\mathbf{P}(T) / m$。\n-   最终线性动量大小：$\\|\\mathbf{P}(T)\\|$。\n-   最终质心速率：$\\|\\mathbf{v}(T)\\|$。\n-   角动量变化大小：$\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\| = \\|\\mathbf{H}(T)\\|$。\n\n然后将这些最终值与指定的公差 $\\varepsilon_P$, $\\varepsilon_v$ 和 $\\Delta H_{\\min}$ 进行比较，以确定测试用例是否通过。当合力为零且合力矩非零时，预期结果为通过，这证实了数值实现正确地解耦了线性和角向动力学。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quat_to_rot(q):\n    \"\"\"Converts a quaternion to a rotation matrix.\"\"\"\n    # q is [w, x, y, z]\n    q_w, q_x, q_y, q_z = q\n    \n    # Pre-calculate squared terms\n    q_x2 = q_x * q_x\n    q_y2 = q_y * q_y\n    q_z2 = q_z * q_z\n    \n    # Pre-calculate cross-product terms\n    q_xy = q_x * q_y\n    q_xz = q_x * q_z\n    q_yz = q_y * q_z\n    q_wx = q_w * q_x\n    q_wy = q_w * q_y\n    q_wz = q_w * q_z\n    \n    R = np.array([\n        [1.0 - 2.0 * (q_y2 + q_z2), 2.0 * (q_xy - q_wz),       2.0 * (q_xz + q_wy)],\n        [2.0 * (q_xy + q_wz),       1.0 - 2.0 * (q_x2 + q_z2), 2.0 * (q_yz - q_wx)],\n        [2.0 * (q_xz - q_wy),       2.0 * (q_yz + q_wx),       1.0 - 2.0 * (q_x2 + q_y2)]\n    ])\n    return R\n\ndef quat_mult(q1, q2):\n    \"\"\"Multiplies two quaternions q1 * q2.\"\"\"\n    # q1, q2 are [w, x, y, z]\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    \n    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n    y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n    z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n    \n    return np.array([w, x, y, z])\n\ndef quat_rate(q, omega):\n    \"\"\"Computes the time derivative of a quaternion given angular velocity.\"\"\"\n    # omega is [ox, oy, oz]\n    omega_q = np.array([0.0, omega[0], omega[1], omega[2]])\n    return 0.5 * quat_mult(q, omega_q)\n    \ndef run_simulation(case_params):\n    \"\"\"Runs a single rigid body simulation test case.\"\"\"\n    m, Ib_diag, forces, rb_pts, dt, T, eps_P, eps_v, dH_min = case_params\n    \n    # Body-frame inertia tensor\n    Ib = np.diag(Ib_diag)\n    \n    # Unpack forces and points\n    F_list = [np.array(f) for f in forces]\n    rb_list = [np.array(r) for r in rb_pts]\n    \n    # Initial state\n    P = np.zeros(3)  # Linear momentum\n    H = np.zeros(3)  # Angular momentum\n    q = np.array([1.0, 0.0, 0.0, 0.0])  # Orientation quaternion [w, x, y, z]\n    H0 = np.copy(H)\n\n    # Net force (constant in these test cases)\n    F_net = sum(F_list)\n    \n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        # 1. Compute derived quantities from state (q, P, H)\n        R = quat_to_rot(q)\n        I_world = R @ Ib @ R.T\n        \n        # Avoid singular matrix for omega calculation if H is zero\n        if np.linalg.norm(H) > 1e-15:\n            omega = np.linalg.solve(I_world, H)\n        else:\n            omega = np.zeros(3)\n            \n        # 2. Compute rates of change\n        P_dot = F_net\n        \n        r_world_list = [R @ rb for rb in rb_list]\n        tau_net = sum(np.cross(r, F) for r, F in zip(r_world_list, F_list))\n        H_dot = tau_net\n        \n        q_dot = quat_rate(q, omega)\n        \n        # 3. Update state using explicit Euler method\n        P = P + P_dot * dt\n        H = H + H_dot * dt\n        q = q + q_dot * dt\n        \n        # 4. Re-normalize quaternion\n        q /= np.linalg.norm(q)\n        \n    # Final verification\n    v = P / m\n    \n    P_norm_final = np.linalg.norm(P)\n    v_norm_final = np.linalg.norm(v)\n    delta_H = np.linalg.norm(H - H0)\n    \n    passes = (P_norm_final = eps_P) and \\\n             (v_norm_final = eps_v) and \\\n             (delta_H >= dH_min)\n             \n    return passes\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report test cases.\n    \"\"\"\n    eps_P = 1e-12\n    eps_v = 1e-12\n    dH_min = 1e-6\n\n    test_cases_params = [\n        # Case 1\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8]], [[0.15, 0, 0], [-0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 2\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8]], [[0.15, 0, 0], [0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 3\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 5], [0, 0, -5]], [[0, 0, 0.2], [0, 0, -0.2]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 4\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8 * (1 - 0.02)]], [[0.15, 0, 0], [-0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 5\n        (1.2, [0.4, 0.4, 0.6], [[5, -3, 4], [-5, 3, -4]], [[0.1, 0.05, 0], [-0.05, -0.02, 0.03]], 0.001, 0.25, eps_P, eps_v, dH_min),\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = run_simulation(params)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}