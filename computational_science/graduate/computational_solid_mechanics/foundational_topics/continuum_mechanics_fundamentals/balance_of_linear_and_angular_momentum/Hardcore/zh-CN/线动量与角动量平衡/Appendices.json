{
    "hands_on_practices": [
        {
            "introduction": "在深入研究动量守恒的计算方法之前，我们首先要回到它的基本物理定义。本练习要求直接应用线性动量的积分定义来计算一个连续体的总动量变化 。通过处理给定的速度场 $\\boldsymbol{v}(\\boldsymbol{x},t)$ 和密度 $\\rho$，您将把抽象的积分公式 $\\boldsymbol{p}(t) = \\int_{\\Omega} \\rho \\boldsymbol{v} \\, dV$ 转化为一个具体的、可量化的结果，这是掌握连续介质力学基本技能的关键一步。",
            "id": "3546840",
            "problem": "考虑一个均匀的三维固体，其当前质量密度为常数 $\\rho$。在时间区间 $[0, T]$ 内，该物体占据固定的矩形区域 $\\Omega = [0, a] \\times [0, b] \\times [0, c] \\subset \\mathbb{R}^{3}$。假设在此时间区间内没有质量进入或离开 $\\Omega$。在当前构型中，对于 $t \\in [0, T]$，速度场由下式给出\n$$\n\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big),\n$$\n其中 $\\mathbf{x} = (x, y, z)$，常数 $\\alpha$ 的单位是 $\\mathrm{s}^{-2}$，常数 $\\beta$ 的单位是 $\\mathrm{s}^{-3}$。单位质量体力在空间上是均匀的，由下式给出\n$$\n\\mathbf{b}(\\mathbf{x}, t) = \\big(0,\\ \\tfrac{\\alpha a}{2},\\ \\beta a\\, t\\big),\n$$\n并且在边界 $\\partial \\Omega$ 上规定的面力在所有 $t \\in [0, T]$ 时都恒等于零。假设应变很小，因此占据的区域保持为 $\\Omega$ 且密度 $\\rho$ 不随时间变化。\n\n仅使用物体的总线性动量 $\\mathbf{p}(t)$ 的定义，计算在时间区间 $[0, T]$ 内总线性动量的变化 $\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$。请将您的最终答案表示为一个以牛顿-秒（使用 $\\mathrm{N\\cdot s}$）为单位的3分量行向量，并用 $\\rho$, $\\alpha$, $\\beta$, $a$, $b$, $c$ 和 $T$ 表示。不要近似；请提供一个精确的封闭形式表达式。",
            "solution": "首先验证该问题，以确保其是自洽的、有科学依据且适定的。\n\n**第 1 步：提取已知条件**\n- 物体：均匀的三维固体。\n- 当前质量密度：常数 $\\rho$。\n- 时间区间：$[0, T]$。\n- 占据区域：固定的矩形域 $\\Omega = [0, a] \\times [0, b] \\times [0, c]$。\n- 质量守恒：边界 $\\partial \\Omega$ 上没有质量通量。\n- 速度场：$\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big)$，其中 $\\mathbf{x} = (x, y, z) \\in \\Omega$ 且 $t \\in [0, T]$。\n- 常数：$\\alpha$ 的单位是 $\\mathrm{s}^{-2}$，$\\beta$ 的单位是 $\\mathrm{s}^{-3}$。\n- 单位质量体力：$\\mathbf{b}(\\mathbf{x}, t) = \\big(0,\\ \\tfrac{\\alpha a}{2},\\ \\beta a\\, t\\big)$。\n- 边界条件：$\\partial \\Omega$ 上的面力为零。\n- 假设：小应变，意味着区域 $\\Omega$ 和密度 $\\rho$ 随时间保持不变。\n\n**第 2 步：验证**\n在连续介质力学的框架内，该问题是适定的且科学上一致的。\n- 速度场 $\\mathbf{v}(\\mathbf{x}, t)$ 是无散度的：$\\nabla \\cdot \\mathbf{v} = \\frac{\\partial (0)}{\\partial x} + \\frac{\\partial (\\alpha t x)}{\\partial y} + \\frac{\\partial (\\beta t^2 x)}{\\partial z} = 0 + 0 + 0 = 0$。这与不可压缩材料的密度 $\\rho$ 恒定的假设一致，正如连续性方程 $\\frac{D\\rho}{Dt} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0$ 所要求的那样。\n- 所有给定量的单位都是一致的。例如，$\\mathbf{v}$ 的分量单位是 $\\mathrm{m/s}$，$\\mathbf{b}$ 的分量单位是 $\\mathrm{m/s^2}$。\n- 所提供的速度场、体力和边界条件的数据与柯西第一运动定律 $\\frac{d\\mathbf{p}}{dt} = \\mathbf{F}_{\\text{ext}}$ 一致，其中 $\\mathbf{F}_{\\text{ext}}$ 是总外力。这证实了不存在内部矛盾。\n- 该任务是具体的、客观的，并且可以使用标准原理解答。仅使用线性动量定义的指令为求解方法提供了明确的指导。\n\n**结论：** 问题有效。\n\n**第 3 步：求解**\n问题要求仅使用总线性动量 $\\mathbf{p}(t)$ 的定义来计算总线性动量的变化 $\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$。\n\n一个占据区域 $\\Omega$、密度为 $\\rho$、速度场为 $\\mathbf{v}(\\mathbf{x}, t)$ 的物体的总线性动量 $\\mathbf{p}(t)$ 的定义由以下体积积分给出：\n$$\n\\mathbf{p}(t) = \\int_{\\Omega} \\rho\\, \\mathbf{v}(\\mathbf{x}, t) \\, dV\n$$\n该物体的质量密度为常数 $\\rho$，占据固定的矩形区域 $\\Omega = [0, a] \\times [0, b] \\times [0, c]$。速度场由 $\\mathbf{v}(\\mathbf{x}, t) = \\big(0,\\ \\alpha\\, t\\, x,\\ \\beta\\, t^{2}\\, x\\big)$ 给出。\n\n我们将给定的表达式代入动量的定义中：\n$$\n\\mathbf{p}(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho \\begin{pmatrix} 0 \\\\ \\alpha t x \\\\ \\beta t^2 x \\end{pmatrix} dx\\, dy\\, dz\n$$\n由于 $\\rho$、$t$、$\\alpha$ 和 $\\beta$ 相对于空间积分变量 $x$、$y$ 和 $z$ 是常数，我们可以在积分过程中将它们视为常数。我们对向量 $\\mathbf{p}(t) = (p_x(t), p_y(t), p_z(t))$ 的每个分量分别计算积分。\n\n对于 $x$ 分量，$p_x(t)$：\n$$\np_x(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho \\cdot 0 \\, dx\\, dy\\, dz = 0\n$$\n\n对于 $y$ 分量，$p_y(t)$：\n$$\np_y(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho (\\alpha t x) \\, dx\\, dy\\, dz\n$$\n通过分离积分，我们得到：\n$$\np_y(t) = \\rho \\alpha t \\left( \\int_{0}^{a} x \\, dx \\right) \\left( \\int_{0}^{b} dy \\right) \\left( \\int_{0}^{c} dz \\right)\n$$\n计算每个积分：\n$$\n\\int_{0}^{a} x \\, dx = \\left[ \\frac{x^2}{2} \\right]_{0}^{a} = \\frac{a^2}{2}\n$$\n$$\n\\int_{0}^{b} dy = [y]_{0}^{b} = b\n$$\n$$\n\\int_{0}^{c} dz = [z]_{0}^{c} = c\n$$\n将这些结果代回 $p_y(t)$ 的表达式中：\n$$\np_y(t) = \\rho \\alpha t \\left( \\frac{a^2}{2} \\right) (b) (c) = \\frac{1}{2} \\rho \\alpha a^2 b c t\n$$\n\n对于 $z$ 分量，$p_z(t)$：\n$$\np_z(t) = \\int_{0}^{c} \\int_{0}^{b} \\int_{0}^{a} \\rho (\\beta t^2 x) \\, dx\\, dy\\, dz\n$$\n同样地，分离积分：\n$$\np_z(t) = \\rho \\beta t^2 \\left( \\int_{0}^{a} x \\, dx \\right) \\left( \\int_{0}^{b} dy \\right) \\left( \\int_{0}^{c} dz \\right)\n$$\n这些积分与之前相同。代入它们的值：\n$$\np_z(t) = \\rho \\beta t^2 \\left( \\frac{a^2}{2} \\right) (b) (c) = \\frac{1}{2} \\rho \\beta a^2 b c t^2\n$$\n\n组合各分量，总线性动量作为时间的函数为：\n$$\n\\mathbf{p}(t) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c t, \\frac{1}{2} \\rho \\beta a^2 b c t^2 \\right)\n$$\n\n问题要求计算总线性动量的变化，$\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0)$。\n首先，我们在 $t=T$ 时计算 $\\mathbf{p}(t)$：\n$$\n\\mathbf{p}(T) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right)\n$$\n接下来，我们在 $t=0$ 时计算 $\\mathbf{p}(t)$：\n$$\n\\mathbf{p}(0) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c (0), \\frac{1}{2} \\rho \\beta a^2 b c (0)^2 \\right) = (0, 0, 0)\n$$\n最后，我们计算差值：\n$$\n\\Delta \\mathbf{p} = \\mathbf{p}(T) - \\mathbf{p}(0) = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right) - (0, 0, 0)\n$$\n$$\n\\Delta \\mathbf{p} = \\left( 0, \\frac{1}{2} \\rho \\alpha a^2 b c T, \\frac{1}{2} \\rho \\beta a^2 b c T^2 \\right)\n$$\n这是最终答案，以给定参数表示为一个3分量行向量。单位是 $\\mathrm{kg \\cdot m/s}$，等同于 $\\mathrm{N \\cdot s}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{2} \\rho \\alpha a^2 b c T & \\frac{1}{2} \\rho \\beta a^2 b c T^2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从连续介质理论过渡到其数值实现，我们必须验证我们的离散化方案是否保留了基本的物理守恒律。恒定应力斑块测试（patch test）是有限元方法中一个基础且强大的验证工具 。通过本练习，您将编程实现该测试，以验证在线性三角单元上，均匀应力场 $\\boldsymbol{\\sigma}$ 确实能产生自平衡的节点力，即合力与合力矩均为零，从而确保了线性和角动量守恒在离散层面得以满足。",
            "id": "3546843",
            "problem": "考虑一个二维小应变连续体，其占据一个平面上的有界多边形域，坐标单位为米。假设体力为零，惯性为零，因此线性动量守恒在内部简化为 $ \\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} $，其中 $ \\boldsymbol{\\sigma} $ 是柯西应力张量。进一步假设柯西应力张量在整个域内是空间均匀且对称的，即 $ \\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\top} $。边界面力在概念上取为 $ \\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n} $，从而使连续体与均匀应力状态保持平衡。\n\n给定由线性三节点三角形单元（也称为 $ P_1 $ 单元）组成的网格。对于每个节点位置为 $ (x_1,y_1) $、$ (x_2,y_2) $ 和 $ (x_3,y_3) $ 的单元，其形函数 $ N_1 $、$ N_2 $ 和 $ N_3 $ 是线性的，并满足单位分解 $ \\sum_{i=1}^{3} N_i = 1 $ 和线性完备性 $ \\sum_{i=1}^{3} x_i N_i = x $、$ \\sum_{i=1}^{3} y_i N_i = y $。在每个线性三角形单元内，梯度 $ \\nabla N_i $ 是一个常数。利用虚功原理以及线性和角动量守恒，通过在每个单元上对从 $ \\nabla N_i $ 导出的适当检验函数与应力进行积分，并将共享节点的贡献相加，可以得到组装后的内部节点力向量。取单位厚度，因此力的单位为牛顿 (N)，力矩的单位为牛顿米 (N·m)。\n\n任务：实现一个恒定应力斑块检验。对于每个给定的网格和指定的均匀对称柯西应力 $ \\boldsymbol{\\sigma} $，计算组装后的内部节点力。然后通过检查以下条件来验证全局守恒性：\n- 合内力 $ \\boldsymbol{F} = \\sum_{a} \\boldsymbol{f}_a $ 在数值上为零（全局线性动量守恒），其中 $ \\boldsymbol{f}_a $ 是节点 $ a $ 处的内部节点力。\n- 绕原点的合内力矩 $ M_z = \\sum_{a} (x_a f_{a,y} - y_a f_{a,x}) $ 在数值上为零（全局角动量守恒），其中 $ (x_a,y_a) $ 是节点坐标，$ (f_{a,x}, f_{a,y}) $ 是 $ \\boldsymbol{f}_a $ 的分量。\n\n您必须使用线性的形函数梯度（每个单元内为常数）以闭合形式精确处理每个三角形单元，并且必须在共享节点上将贡献累加。使用 $ 10^{-9} $ N 的数值容差来判断合力大小 $ \\| \\boldsymbol{F} \\|_2 $ 是否“消失”，以及 $ 10^{-9} $ N·m 的数值容差来判断 $ |M_z| $ 是否“消失”。\n\n物理单位：\n- 坐标单位为米 (m)。\n- 应力分量单位为帕斯卡 (Pa)。\n- 厚度为单位1 (m)。\n- 力的单位为牛顿 (N)。\n- 力矩的单位为牛顿米 (N·m)。\n\n本问题不使用角度单位。\n\n测试套件：\n对于每个测试用例，会给出一组节点、一个三角剖分（单元）和一个以帕斯卡为单位的均匀对称柯西应力张量 $ \\boldsymbol{\\sigma} $。\n- 测试用例1（正常路径，凸方形网格）：\n  - 节点：$ [(0,0), (1,0), (1,1), (0,1)] $。\n  - 单元（基于0的节点索引）：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 2.0\\times 10^6 & 0.5\\times 10^6 \\\\ 0.5\\times 10^6 & 1.0\\times 10^6 \\end{bmatrix} $ Pa。\n- 测试用例2（扭斜四边形网格）：\n  - 节点：$ [(0.0,0.0), (2.0,0.2), (2.2,1.0), (0.3,1.2)] $。\n  - 单元：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 0.0 & 3.0\\times 10^6 \\\\ 3.0\\times 10^6 & 0.0 \\end{bmatrix} $ Pa。\n- 测试用例3（单三角形，类似边界的工况）：\n  - 节点：$ [(0.0,0.0), (2.0,0.0), (0.0,1.0)] $。\n  - 单元：$ [(0,1,2)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 1.0\\times 10^6 & 0.0 \\\\ 0.0 & 1.0\\times 10^6 \\end{bmatrix} $ Pa。\n- 测试用例4（细长的近退化三角形）：\n  - 节点：$ [(0.0,0.0), (1.0,1.0\\times 10^{-8}), (1.0,0.0), (0.5,1.0\\times 10^{-8})] $。\n  - 单元：$ [(0,1,2), (0,2,3)] $。\n  - 应力 $ \\boldsymbol{\\sigma} $：$ \\begin{bmatrix} 4.0\\times 10^6 & 2.0\\times 10^6 \\\\ 2.0\\times 10^6 & 0.5\\times 10^6 \\end{bmatrix} $ Pa。\n\n所需输出：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身是一个包含两个布尔值的列表 $ [\\mathrm{force\\_zero}, \\mathrm{moment\\_zero}] $，如果 $ \\| \\boldsymbol{F} \\|_2 < 10^{-9} $ N，则 $ \\mathrm{force\\_zero} $ 为 true；如果 $ |M_z| < 10^{-9} $ N·m，则 $ \\mathrm{moment\\_zero} $ 为 true。例如：$ [[\\mathrm{true},\\mathrm{true}],[\\mathrm{true},\\mathrm{true}],\\dots] $。",
            "solution": "该问题陈述是计算固体力学中的一个有效练习，特别是针对线性三角形单元的恒定应力斑块检验。它具有科学依据，提法明确，并为求解提供了所有必要信息。\n\n解法源于虚功原理，该原理指出，对于处于平衡状态的物体，由应力所做的内部虚功等于由外施力所做的外部虚功。对于一个没有体力的连续体域 $\\Omega$，其内部虚功 $\\delta W_{\\text{int}}$ 由下式给出：\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV\n$$\n其中 $\\boldsymbol{\\sigma}$ 是柯西应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量。\n\n在有限元方法中，域 $\\Omega$ 被离散化为单元。在每个单元 $\\Omega_e$ 内，位移场 $\\boldsymbol{u}$ 由节点位移 $\\boldsymbol{d}^e$ 通过形函数矩阵 $\\boldsymbol{N}$ 插值得到：\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{N}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\n小应变张量 $\\boldsymbol{\\varepsilon}$ 通过应变-位移矩阵 $\\boldsymbol{B}$ 与节点位移相关联：\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\boldsymbol{B}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\n虚应变则为 $\\delta\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\delta\\boldsymbol{d}^e$。将此代入虚功表达式，并使用 Voigt 标记法（其中应力 $\\boldsymbol{\\sigma}$ 和应变 $\\boldsymbol{\\varepsilon}$ 表示为向量）来表示张量点积，可得：\n$$\n\\delta W_{\\text{int}}^e = \\int_{\\Omega_e} (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV = (\\delta\\boldsymbol{d}^e)^T \\left( \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV \\right)\n$$\n内部虚功也定义为内部节点力 $\\boldsymbol{f}_{\\text{int}}^e$ 所做的功：\n$$\n\\delta W_{\\text{int}}^e = (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{f}_{\\text{int}}^e\n$$\n通过比较这两个表达式，单元内部力向量为：\n$$\n\\boldsymbol{f}_{\\text{int}}^e = \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV\n$$\n对于单位厚度 $h=1$ 的二维问题，体积积分变为面积积分。对于线性三角形单元，形函数的梯度是恒定的，这使得矩阵 $\\boldsymbol{B}$ 也是恒定的。鉴于应力张量 $\\boldsymbol{\\sigma}$ 也是均匀的，积分简化为：\n$$\n\\boldsymbol{f}_{\\text{int}}^e = A_e \\, h \\, \\boldsymbol{B}^T \\boldsymbol{\\sigma} = A_e \\boldsymbol{B}^T \\boldsymbol{\\sigma}\n$$\n其中 $A_e$ 是单元的面积。\n\n一种更直接的方法是避免构造完整的 $\\boldsymbol{B}$ 矩阵。单元单个节点 $i$ 上的力 $\\boldsymbol{f}_i^e$ 可以通过考虑其对虚功的贡献来求得。结果是：\n$$\n\\boldsymbol{f}_i^e = \\int_{A_e} (\\nabla N_i)^T \\boldsymbol{\\sigma} \\, dA\n$$\n其中 $N_i$ 是节点 $i$ 的形函数。由于 $\\nabla N_i$ 和 $\\boldsymbol{\\sigma}$ 是常数，此式变为：\n$$\n\\boldsymbol{f}_i^e = A_e (\\nabla N_i)^T \\boldsymbol{\\sigma}\n$$\n对于顶点为 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 的线性三角形，形函数 $N_i$ 的梯度为：\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A_e} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix}\n$$\n其中 $A_e = \\frac{1}{2} (x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2))$ 是三角形的有向面积，系数为：\n$$\n\\begin{array}{lll}\nb_1 = y_2 - y_3 & \\quad & c_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1 & \\quad & c_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2 & \\quad & c_3 = x_2 - x_1\n\\end{array}\n$$\n应力张量为 $\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{yx} & \\sigma_{yy} \\end{pmatrix}$。由于其对称性，$\\sigma_{xy} = \\sigma_{yx}$。\n节点 $i$ 的力向量 $\\boldsymbol{f}_i^e = (f_{ix}^e, f_{iy}^e)^T$ 计算如下：\n$$\n\\boldsymbol{f}_i^e = A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} & \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} \\begin{pmatrix} \\sigma_{xx} & \\sigma_{xy} \\\\ \\sigma_{xy} & \\sigma_{yy} \\end{pmatrix}\n= A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_i}{\\partial y} \\sigma_{xy} \\\\ \\frac{\\partial N_i}{\\partial x} \\sigma_{xy} + \\frac{\\partial N_i}{\\partial y} \\sigma_{yy} \\end{pmatrix}\n$$\n代入梯度的表达式：\n$$\nf_{ix}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xx} + \\frac{c_i}{2A_e} \\sigma_{xy} \\right) = \\frac{1}{2} (b_i \\sigma_{xx} + c_i \\sigma_{xy})\n$$\n$$\nf_{iy}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xy} + \\frac{c_i}{2A_e} \\sigma_{yy} \\right) = \\frac{1}{2} (b_i \\sigma_{xy} + c_i \\sigma_{yy})\n$$\n斑块检验要求验证全局平衡。总内力 $\\boldsymbol{F}$ 是所有组装后的节点力 $\\boldsymbol{f}_a$ 的总和：\n$$\n\\boldsymbol{F} = \\sum_a \\boldsymbol{f}_a = \\sum_a \\left( \\sum_{e \\in \\text{patch}(a)} \\boldsymbol{f}_{a,e} \\right) = \\sum_e \\sum_{i=1}^3 \\boldsymbol{f}_i^e\n$$\n单个单元的力之和为零，因为 $\\sum_i b_i = (y_2 - y_3) + (y_3 - y_1) + (y_1 - y_2) = 0$ 且 $\\sum_i c_i = (x_3 - x_2) + (x_1 - x_3) + (x_2 - x_1) = 0$。因此，任何单元斑块的总力 $\\boldsymbol{F}$ 必须为零。\n\n绕原点的总力矩 $M_z$ 是所有组装后的节点力的力矩之和：\n$$\nM_z = \\sum_a (x_a f_{a,y} - y_a f_{a,x}) = \\sum_e \\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e)\n$$\n其中 $(x_i, y_i)$ 是单元 $e$ 的节点坐标。通过代数运算可以证明，单个单元的力矩贡献为零：$\\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e) = 0$。这依赖于恒等式 $\\sum y_i b_i = 0$、$\\sum x_i c_i = 0$ 和 $\\sum x_i b_i = \\sum y_i c_i = 2A_e$。因此，任何斑块的总力矩 $M_z$ 也必须为零。\n\n对于每个测试用例，算法按以下步骤进行：\n1. 为所有节点初始化一个全零的全局力向量。\n2. 对于每个三角形单元：\n    a. 确定其三个节点的坐标 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$。\n    b. 对 $i=1, 2, 3$ 计算系数 $b_i$ 和 $c_i$。\n    c. 使用推导出的公式计算三个节点的单元节点力分量 $(f_{ix}^e, f_{iy}^e)$。\n    d. 将这些单元力添加到全局力向量的相应条目中。\n3. 处理完所有单元后，通过对全局力向量中的所有向量求和来计算合力 $\\boldsymbol{F}$。检查其 L2-范数 $\\|\\boldsymbol{F}\\|_2$ 是否小于容差 $10^{-9}$。\n4. 对所有节点，通过对叉乘 $\\boldsymbol{r}_a \\times \\boldsymbol{f}_a$ 求和来计算合力矩 $M_z$。检查其绝对值 $|M_z|$ 是否小于容差 $10^{-9}$。\n5. 记录力与力矩检查的布尔结果。\n\n此过程严格测试了线性三角形的有限元公式是否在恒定应力状态下满足线性和角动量守恒的基本定律，这是任何有限元代码的关键验证测试。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a constant-stress patch test on several 2D triangular meshes.\n    Verifies that the sum of internal nodal forces and the sum of moments of these\n    forces about the origin are numerically zero, as required by the principles\n    of conservation of linear and angular momentum for a body in equilibrium.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[2.0e6, 0.5e6], [0.5e6, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.2), (2.2, 1.0), (0.3, 1.2)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[0.0, 3.0e6], [3.0e6, 0.0]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"stress\": np.array([[1.0e6, 0.0], [0.0, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0e-8), (1.0, 0.0), (0.5, 1.0e-8)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[4.0e6, 2.0e6], [2.0e6, 0.5e6]])\n        }\n    ]\n\n    results = []\n    \n    # Set the numerical tolerance.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        nodes = np.array(case[\"nodes\"], dtype=np.float64)\n        elements = np.array(case[\"elements\"], dtype=np.int64)\n        stress = case[\"stress\"]\n        \n        num_nodes = len(nodes)\n        global_forces = np.zeros((num_nodes, 2), dtype=np.float64)\n\n        # Extract stress components\n        s_xx = stress[0, 0]\n        s_yy = stress[1, 1]\n        s_xy = stress[0, 1]  # Stress tensor is symmetric\n\n        # Loop over each element to calculate and assemble internal forces\n        for element_indices in elements:\n            # Get nodal coordinates for the current element\n            p1 = nodes[element_indices[0]]\n            p2 = nodes[element_indices[1]]\n            p3 = nodes[element_indices[2]]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            x3, y3 = p3\n            \n            # Calculate coefficients for shape function gradients\n            # b_i = y_j - y_k, c_i = x_k - x_j (for i,j,k in cyclic order)\n            b1 = y2 - y3\n            c1 = x3 - x2\n            \n            b2 = y3 - y1\n            c2 = x1 - x3\n            \n            b3 = y1 - y2\n            c3 = x2 - x1\n            \n            b_coeffs = [b1, b2, b3]\n            c_coeffs = [c1, c2, c3]\n\n            # Calculate elemental nodal forces\n            # f_ix = 0.5 * (b_i * sigma_xx + c_i * sigma_xy)\n            # f_iy = 0.5 * (b_i * sigma_xy + c_i * sigma_yy)\n            for i in range(3):\n                node_global_idx = element_indices[i]\n                b_i = b_coeffs[i]\n                c_i = c_coeffs[i]\n                \n                f_ix = 0.5 * (b_i * s_xx + c_i * s_xy)\n                f_iy = 0.5 * (b_i * s_xy + c_i * s_yy)\n                \n                # Assemble into global force vector\n                global_forces[node_global_idx, 0] += f_ix\n                global_forces[node_global_idx, 1] += f_iy\n\n        # --- Verification Step ---\n        \n        # 1. Check balance of linear momentum (resultant force)\n        total_force = np.sum(global_forces, axis=0)\n        force_magnitude = np.linalg.norm(total_force)\n        force_is_zero = force_magnitude < tolerance\n\n        # 2. Check balance of angular momentum (resultant moment about origin)\n        total_moment = 0.0\n        for i in range(num_nodes):\n            x_i, y_i = nodes[i]\n            f_ix, f_iy = global_forces[i]\n            total_moment += x_i * f_iy - y_i * f_ix\n            \n        moment_is_zero = abs(total_moment) < tolerance\n        \n        # Store results as strings 'true'/'false' for output formatting\n        results.append(f\"[{str(force_is_zero).lower()},{str(moment_is_zero).lower()}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在静态验证之后，我们转向动态问题，并探讨数值方法中的选择如何影响守恒定律的长期保持。在有限元法中，质量的表示（例如，一致质量矩阵与集中质量矩阵）对角动量守恒有着深远的影响 。本练习将指导您通过编程来量化这两种不同质量矩阵在刚体旋转问题中导致的角动量误差，并实施一种修正方案，从而深刻理解计算效率与物理精度之间的权衡。",
            "id": "3546856",
            "problem": "您需要实现一个程序，研究在有限元法（FEM）中，离散质量表示的选择如何影响自由刚体旋转过程中的角动量守恒，量化误差，并应用修正。重点是自由旋转下弹性固体的线动量和角动量平衡，在这种情况下，运动学简化为刚体运动，并且在没有应变时，内弹性力消失。\n\n基本出发点是以下基本假设和定律：\n- 连续介质的积分形式牛顿第二定律：对于任何区域，其质量密度为 $\\rho$，单位质量的体力为 $\\mathbf{b}$，边界上的面力为 $\\mathbf{t}$，速度场为 $\\mathbf{v}$，\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{t}\\,dS.$$\n- 积分形式的角动量平衡：\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{x}\\times\\mathbf{t}\\,dS.$$\n- 自由刚体旋转对应于 $\\mathbf{b}=\\mathbf{0}$ 且无边界面力，速度场为 $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$，其中 $\\boldsymbol{\\omega}$ 是角速度矢量，$\\mathbf{x}_{\\mathrm{cm}}$ 是质心。\n\n在一个离散的有限元法（FEM）设置中，对于一个具有均匀厚度的平面体，其网格由线性三角形组成，质量矩阵可以构造成两种形式：\n- 一致质量矩阵 $M$ 定义为\n$$M=\\int_{\\Omega}\\rho\\,\\mathbf{N}\\mathbf{N}^{T}\\,d\\Omega,$$\n其中 $\\mathbf{N}$ 集合了标量形函数，对于矢量自由度以分块对角的方式组装。\n- 集中质量矢量 $m$ 通过对角化一致质量矩阵获得，使得每个标量自由度的节点质量为 $m_{i}=\\sum_{j}M_{ij}$。\n\n对于节点值速度矢量 $\\mathbf{v}_{h}$ 的离散线动量为\n$$\\mathbf{p}_{\\mathrm{cons}} = M\\,\\mathbf{v}_{h},\\quad \\mathbf{p}_{\\mathrm{lump}} = \\mathrm{diag}(m)\\,\\mathbf{v}_{h}.$$\n关于质心 $\\mathbf{x}_{\\mathrm{cm}}$ 的离散角动量计算如下\n$$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{cons},a},\\quad \\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{lump},a},$$\n其中 $\\mathbf{x}_{a}$ 是节点位置，$\\mathbf{p}_{\\cdot,a}$ 是节点动量矢量。\n\n您的程序必须：\n1. 构建一个宽度为 $W$、高度为 $H$ 的矩形平面网格，该矩形以原点为中心，离散为 $n_{x}\\times n_{y}$ 个矩形单元，每个单元被分割成两个三角形。假设厚度 $t$ 和密度 $\\rho$ 均匀。\n2. 对线性三角形，以单元为单位组装一致质量贡献，使用精确积分计算标量质量子矩阵\n$$M_{e}^{\\mathrm{scalar}}=\\rho\\,t\\,\\frac{A_{e}}{12}\\begin{bmatrix}2&1&1\\\\1&2&1\\\\1&1&2\\end{bmatrix},$$\n并对矢量自由度进行分块对角组装。\n3. 使用 $m_{i} = \\rho\\,t\\,\\sum_{e\\ni i}\\frac{A_{e}}{3}$ 组装每个节点的集中质量（对于每个标量自由度，两个平面内方向相同）。\n4. 将节点速度初始化为刚体场 $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$，其中 $\\boldsymbol{\\omega}=(0,0,\\omega_{z})$，$\\omega_{z}$ 是指定的。使用根据集中质量计算的质量加权质心作为 $\\mathbf{x}_{\\mathrm{cm}}$。\n5. 计算离散角动量 $\\mathbf{L}_{\\mathrm{cons}}$ 和 $\\mathbf{L}_{\\mathrm{lump}}$，并报告相对误差\n$$E=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n6. 提出并应用一个修正：计算集中惯性张量\n$$I_{\\mathrm{lump}}=\\sum_{a=1}^{N}m_{a}\\left(\\|\\mathbf{r}_{a}\\|^{2}I_{3}-\\mathbf{r}_{a}\\mathbf{r}_{a}^{T}\\right),\\quad \\mathbf{r}_{a}=\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}},$$\n求解修正角速度\n$$\\delta\\boldsymbol{\\omega}=I_{\\mathrm{lump}}^{-1}\\left(\\mathbf{L}_{\\mathrm{cons}}-\\mathbf{L}_{\\mathrm{lump}}\\right),$$\n应用修正后的速度 $\\mathbf{v}_{a}^{\\mathrm{corr}}=\\mathbf{v}_{a}+\\delta\\boldsymbol{\\omega}\\times\\mathbf{r}_{a}$，并重新计算 $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$。报告修正后的相对误差\n$$E_{\\mathrm{corr}}=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n\n物理单位：使用国际单位制（SI）。输入参数中，$W$ 和 $H$ 的单位是米（$\\mathrm{m}$），$\\rho$ 的单位是千克/立方米（$\\mathrm{kg/m^{3}}$），$t$ 的单位是米（$\\mathrm{m}$），$\\omega_{z}$ 的单位是弧度/秒（$\\mathrm{rad/s}$）。输出是无量纲的浮点数（相对误差），因此不需要单位转换。\n\n您的程序应为以下参数值的测试套件生成结果：\n- 测试用例 1（正常情况，粗糙网格）：$W=1.0$, $H=1.0$, $n_{x}=2$, $n_{y}=2$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=3.0$。\n- 测试用例 2（边界情况，单单元）：$W=1.0$, $H=1.0$, $n_{x}=1$, $n_{y}=1$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=2.0$。\n- 测试用例 3（各向异性矩形，中等分辨率）：$W=2.0$, $H=0.5$, $n_{x}=20$, $n_{y}=5$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=1.5$。\n- 测试用例 4（精细网格，较快旋转）：$W=1.0$, $H=1.0$, $n_{x}=40$, $n_{y}=40$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=7.0$。\n\n对于每个测试用例，计算并返回一个包含两个浮点数 $[E, E_{\\mathrm{corr}}]$ 的列表。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的列表的逗号分隔列表。例如：\"[[e1_before,e1_after],[e2_before,e2_after],...]\"。",
            "solution": "该问题已经过验证，被确定为计算固体力学中一个适定且科学合理的问题。它探讨了在刚体旋转的有限元法（FEM）模拟中，不同质量集中方案对角动量守恒的影响。所提供的量化和修正方法是标准且正确的。我们将继续进行计算步骤的详细推导。\n\n解决方案是按照问题陈述中规定的任务顺序实现的。\n\n1.  **网格生成**\n    一个宽度为 $W$、高度为 $H$ 的矩形域以原点为中心，因此其角点位于 $(\\pm W/2, \\pm H/2)$。该域被离散化为 $n_{x} \\times n_{y}$ 个矩形单元组成的网格。网格的节点位于网格点上。节点数量为 $N_{nodes}=(n_{x}+1)(n_{y}+1)$。位于网格位置 $(i,j)$ 的节点的坐标 $(x_i, y_j)$ 由下式给出：\n    $$x_i = -\\frac{W}{2} + i \\frac{W}{n_x}, \\quad i=0, 1, \\dots, n_x$$\n    $$y_j = -\\frac{H}{2} + j \\frac{H}{n_y}, \\quad j=0, 1, \\dots, n_y$$\n    然后，每个矩形单元被细分为两个线性三角形单元。所有单元都采用一致的对角线分割模式，例如，连接每个单元的左下角和右上角。这个过程生成 $2 \\times n_x \\times n_y$ 个三角形单元。对于这种结构化网格，每个三角形的面积 $A_e$ 是恒定的：\n    $$A_e = \\frac{1}{2}\\left(\\frac{W}{n_x}\\right)\\left(\\frac{H}{n_y}\\right)$$\n\n2.  **一致质量矩阵组装**\n    该问题涉及平面运动，每个节点有两个自由度（DOF）（每个笛卡尔方向 $x$ 和 $y$ 各一个）。总自由度数为 $N_{dof} = 2 N_{nodes}$。一致质量矩阵 $M$ 是由单元级贡献组装而成的。对于一个线性三角形，标量单元质量矩阵如下：\n    $$M_{e}^{\\mathrm{scalar}}=\\rho t \\frac{A_{e}}{12}\\begin{bmatrix}2&1&1\\\\1&2&1\\\\1&1&2\\end{bmatrix}$$\n    其中 $\\rho$ 是密度，$t$ 是厚度。对于矢量自由度，假设 $x$ 和 $y$ 方向之间没有质量耦合，全局质量矩阵 $M$ 的构建方法是：首先组装一个大小为 $N_{nodes} \\times N_{nodes}$ 的标量质量矩阵 $M_s$，然后填充完整的 $N_{dof} \\times N_{dof}$ 矩阵，使得 $M_{2i,2j} = M_{2i+1,2j+1} = (M_s)_{ij}$ 且 $M_{2i,2j+1} = M_{2i+1,2j} = 0$。矩阵 $M_s$ 是通过标准的有限元法组装过程建立的，即根据节点连接性将所有单元的 $M_{e}^{\\mathrm{scalar}}$ 贡献累加到全局矩阵中。\n\n3.  **集中质量组装**\n    集中质量矩阵是一个对角矩阵。每个节点 $a$ 处的标量质量 $m_a$ 是通过对标量一致质量矩阵 $M_s$ 相应行的所有元素求和得到的：\n    $$m_a = \\sum_{j=1}^{N_{nodes}} (M_s)_{aj}$$\n    这等同于所给出的公式 $m_a = \\rho t \\sum_{e \\ni a} \\frac{A_e}{3}$。集中质量矩阵 $M_{\\mathrm{lump}}$ 是一个大小为 $N_{dof} \\times N_{dof}$ 的对角矩阵，其中节点 $a$ 的对角线元素都等于 $m_a$。\n\n4.  **速度初始化**\n    首先，使用集中节点质量计算质心 $\\mathbf{x}_{\\mathrm{cm}}$：\n    $$\\mathbf{x}_{\\mathrm{cm}} = \\frac{\\sum_{a=1}^{N_{nodes}} m_a \\mathbf{x}_a}{\\sum_{a=1}^{N_{nodes}} m_a}$$\n    由于网格的对称性和均匀的密度，计算出的 $\\mathbf{x}_{\\mathrm{cm}}$ 将位于原点 $(0,0)$。节点速度矢量 $\\mathbf{v}_h$ 被初始化以表示围绕该质心以角速度 $\\boldsymbol{\\omega}=(0,0,\\omega_z)$ 进行的刚体旋转。对于每个具有位置矢量 $\\mathbf{x}_a$ 的节点 $a$，其速度 $\\mathbf{v}_a$ 为：\n    $$\\mathbf{v}_a = \\boldsymbol{\\omega} \\times (\\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}})$$\n    用分量形式表示，设 $\\mathbf{r}_a = \\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}} = (r_{ax}, r_{ay})$，则速度为 $\\mathbf{v}_a = (-\\omega_z r_{ay}, \\omega_z r_{ax})$。这些值被填充到全局速度矢量 $\\mathbf{v}_h$ 中。\n\n5.  **角动量和误差计算**\n    为两种质量表示计算节点线动量矢量：\n    $$\\mathbf{p}_{\\mathrm{cons}} = M \\mathbf{v}_h \\quad \\text{和} \\quad \\mathbf{p}_{\\mathrm{lump}} = M_{\\mathrm{lump}} \\mathbf{v}_h$$\n    然后通过对每个节点 $a$ 的贡献求和，计算关于 $\\mathbf{x}_{\\mathrm{cm}}$ 的总离散角动量：\n    $$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{cons},a}$$\n    $$\\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{lump},a}$$\n    其中 $\\mathbf{p}_{\\cdot,a}$ 是节点 $a$ 的二维线动量矢量。对于这个平面问题，角动量矢量将仅有非零的 $z$ 分量。相对误差 $E$ 计算如下：\n    $$E = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n\n6.  **修正过程**\n    为了修正集中质量的角动量，应用一个修正速度场。首先，计算集中惯性张量 $I_{\\mathrm{lump}}$。它代表了集中质量系统的转动惯量：\n    $$I_{\\mathrm{lump}}=\\sum_{a=1}^{N_{nodes}} m_a (\\|\\mathbf{r}_a\\|^2 I_3 - \\mathbf{r}_a \\mathbf{r}_a^T)$$\n    其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵，$\\mathbf{r}_a$ 是三维位置矢量（$z=0$）。角动量差值 $\\Delta \\mathbf{L} = \\mathbf{L}_{\\mathrm{cons}} - \\mathbf{L}_{\\mathrm{lump}}$ 用于通过求解线性系统来找到修正角速度 $\\delta \\boldsymbol{\\omega}$：\n    $$I_{\\mathrm{lump}} \\, \\delta\\boldsymbol{\\omega} = \\Delta \\mathbf{L}$$\n    然后对节点速度进行修正：\n    $$\\mathbf{v}_{a}^{\\mathrm{corr}} = \\mathbf{v}_a + \\delta\\boldsymbol{\\omega} \\times \\mathbf{r}_a$$\n    使用修正后的速度矢量 $\\mathbf{v}_h^{\\mathrm{corr}}$，重新计算集中角动量，得到 $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$。根据构造，$\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$ 应等于 $\\mathbf{L}_{\\mathrm{cons}}$。计算最终的修正后相对误差 $E_{\\mathrm{corr}}$，预计其值接近机器精度零。\n    $$E_{\\mathrm{corr}} = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n每个测试用例的结果由一对数值 $[E, E_{\\mathrm{corr}}]$ 组成。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    def solve_case(W, H, nx, ny, rho, t, omega_z):\n        \"\"\"\n        Computes the angular momentum errors for a single test case.\n\n        Args:\n            W (float): Width of the rectangle.\n            H (float): Height of the rectangle.\n            nx (int): Number of cells in the x-direction.\n            ny (int): Number of cells in the y-direction.\n            rho (float): Material density.\n            t (float): Thickness of the planar body.\n            omega_z (float): Angular velocity about the z-axis.\n\n        Returns:\n            list[float, float]: A list containing the initial relative error E and the corrected relative error E_corr.\n        \"\"\"\n        # 1. Mesh Generation\n        num_nodes = (nx + 1) * (ny + 1)\n        nodes = np.zeros((num_nodes, 2), dtype=np.float64)\n        node_map = {}\n        k = 0\n        dx, dy = W / nx, H / ny\n        for j in range(ny + 1):\n            for i in range(nx + 1):\n                nodes[k] = [-W/2 + i * dx, -H/2 + j * dy]\n                node_map[(i, j)] = k\n                k += 1\n\n        elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n1 = node_map[(i, j)]\n                n2 = node_map[(i + 1, j)]\n                n3 = node_map[(i + 1, j + 1)]\n                n4 = node_map[(i, j + 1)]\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n\n        Ae = 0.5 * dx * dy\n\n        # 2. Consistent Mass Matrix Assembly\n        M_scalar = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n        M_element_scalar = (rho * t * Ae / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        for el_nodes in elements:\n            for i_local in range(3):\n                for j_local in range(3):\n                    i_global = el_nodes[i_local]\n                    j_global = el_nodes[j_local]\n                    M_scalar[i_global, j_global] += M_element_scalar[i_local, j_local]\n\n        num_dofs = 2 * num_nodes\n        M_consistent = np.zeros((num_dofs, num_dofs), dtype=np.float64)\n        for i in range(num_nodes):\n            for j in range(num_nodes):\n                M_consistent[2*i, 2*j] = M_scalar[i, j]\n                M_consistent[2*i+1, 2*j+1] = M_scalar[i, j]\n\n        # 3. Lumped Mass Assembly\n        m_scalar = np.sum(M_scalar, axis=1)\n        M_lumped_diag = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            M_lumped_diag[2*i] = m_scalar[i]\n            M_lumped_diag[2*i+1] = m_scalar[i]\n\n        # 4. Velocity Initialization\n        # Center of mass is (0,0) by symmetry. Using analytical result avoids float precision issues.\n        x_cm = np.array([0.0, 0.0])\n        r_nodes = nodes - x_cm\n        v_h = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            v_h[2*i]   = -omega_z * r_nodes[i, 1]\n            v_h[2*i+1] =  omega_z * r_nodes[i, 0]\n\n        # 5. Angular Momentum and Error Calculation\n        p_cons = M_consistent @ v_h\n        p_lump = M_lumped_diag * v_h\n\n        L_cons_z = np.sum(r_nodes[:, 0] * p_cons[1::2] - r_nodes[:, 1] * p_cons[0::2])\n        L_lump_z = np.sum(r_nodes[:, 0] * p_lump[1::2] - r_nodes[:, 1] * p_lump[0::2])\n        \n        L_cons_vec = np.array([0.0, 0.0, L_cons_z])\n        L_lump_vec = np.array([0.0, 0.0, L_lump_z])\n        \n        norm_L_cons = np.linalg.norm(L_cons_vec)\n        error = np.linalg.norm(L_lump_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n\n        # 6. Correction Procedure\n        I_lump = np.zeros((3, 3), dtype=np.float64)\n        r_nodes_3d = np.hstack([r_nodes, np.zeros((num_nodes, 1), dtype=np.float64)])\n        for i in range(num_nodes):\n            r_vec = r_nodes_3d[i, :]\n            I_node = m_scalar[i] * (np.dot(r_vec, r_vec) * np.eye(3) - np.outer(r_vec, r_vec))\n            I_lump += I_node\n        \n        delta_L = L_cons_vec - L_lump_vec\n        \n        try:\n            delta_omega_vec = np.linalg.solve(I_lump, delta_L)\n        except np.linalg.LinAlgError:\n            delta_omega_vec = np.zeros(3)\n\n        v_h_corr = np.copy(v_h)\n        for i in range(num_nodes):\n            v_corr_delta = np.cross(delta_omega_vec, r_nodes_3d[i, :])\n            v_h_corr[2*i]   += v_corr_delta[0]\n            v_h_corr[2*i+1] += v_corr_delta[1]\n            \n        p_lump_corr = M_lumped_diag * v_h_corr\n        \n        L_lump_corr_z = np.sum(r_nodes[:, 0] * p_lump_corr[1::2] - r_nodes[:, 1] * p_lump_corr[0::2])\n        L_lump_corr_vec = np.array([0.0, 0.0, L_lump_corr_z])\n\n        error_corr = np.linalg.norm(L_lump_corr_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n            \n        return [error, error_corr]\n\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1.0, 1.0, 3.0),\n        (1.0, 1.0, 1, 1, 1.0, 1.0, 2.0),\n        (2.0, 0.5, 20, 5, 1.0, 1.0, 1.5),\n        (1.0, 1.0, 40, 40, 1.0, 1.0, 7.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}