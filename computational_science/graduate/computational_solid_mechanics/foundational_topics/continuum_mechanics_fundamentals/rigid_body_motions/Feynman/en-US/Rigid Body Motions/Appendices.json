{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of rigid body kinematics is the physical principle that the distance between any two points within the body remains constant, implying an absence of deformation. In continuum mechanics, this translates to the precise mathematical condition that the rate-of-deformation tensor, $\\boldsymbol{D}$, must be zero everywhere. This exercise  challenges you to translate this fundamental theory into a practical, code-based test, allowing you to verify from a discrete velocity field whether a given motion is truly rigid.",
            "id": "3596983",
            "problem": "Design and implement a program that verifies whether a numerically sampled planar velocity (or displacement-per-unit-time) field represents a rigid body motion by testing three invariants derived from first principles: the vanishing of the rate-of-deformation tensor, the vanishing of the divergence, and the spatial constancy of the vorticity (curl). The program must construct several test fields on a uniform grid, compute numerical derivatives using finite differences, evaluate the invariants, and then decide per field whether it should be classified as rigid within a prescribed tolerance.\n\nThe fundamental base for the derivation is:\n- Newtonian kinematics and the definition of instantaneous velocity field $\\boldsymbol{v}(\\boldsymbol{x},t)$.\n- The velocity gradient $\\boldsymbol{L} := \\nabla \\boldsymbol{v}$, the rate-of-deformation tensor $\\boldsymbol{D} := \\dfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right)$, and the vorticity (curl) $\\boldsymbol{\\omega} := \\nabla \\times \\boldsymbol{v}$.\n- For a rigid body motion, the spatial velocity field has the form $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{c} + \\boldsymbol{\\Omega}\\,\\boldsymbol{x}$ with $\\boldsymbol{\\Omega}$ skew-symmetric, which implies the identities $\\boldsymbol{D} = \\boldsymbol{0}$ and $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{L}) = 0$, and yields spatially constant vorticity $\\boldsymbol{\\omega}$.\n\nYour program must:\n- Work in two spatial dimensions on a rectangular grid. Let the domain be $[-1,1]\\times[-0.9,0.9]$ with $N_x = 41$ points uniformly spaced in the $x$-direction and $N_y = 37$ points uniformly spaced in the $y$-direction. Thus the spacings are $\\Delta x = \\dfrac{2}{40} = 0.05$ and $\\Delta y = \\dfrac{1.8}{36} = 0.05$.\n- Represent the velocity field as $\\boldsymbol{v}(x,y) = \\left(v_x(x,y), v_y(x,y)\\right)$ sampled on the grid.\n- Compute numerical partial derivatives using finite differences:\n  - At interior grid points, use second-order central differences for $\\dfrac{\\partial (\\cdot)}{\\partial x}$ and $\\dfrac{\\partial (\\cdot)}{\\partial y}$.\n  - At boundary grid points, use first-order one-sided differences consistent with the grid spacing.\n- Assemble the velocity gradient $\\boldsymbol{L}(x,y)$ with entries $L_{11} = \\dfrac{\\partial v_x}{\\partial x}$, $L_{12} = \\dfrac{\\partial v_x}{\\partial y}$, $L_{21} = \\dfrac{\\partial v_y}{\\partial x}$, $L_{22} = \\dfrac{\\partial v_y}{\\partial y}$.\n- Form the rate-of-deformation tensor $\\boldsymbol{D} = \\dfrac{1}{2}\\left(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}\\right)$ pointwise. For two dimensions, the Frobenius norm of $\\boldsymbol{D}$ at each grid point is $||\\boldsymbol{D}||_F = \\sqrt{D_{11}^2 + 2 D_{12}^2 + D_{22}^2}$.\n- Compute the divergence $\\nabla \\cdot \\boldsymbol{v} = L_{11} + L_{22}$ pointwise.\n- Compute the scalar out-of-plane vorticity (two-dimensional curl) $\\omega_z = \\dfrac{\\partial v_y}{\\partial x} - \\dfrac{\\partial v_x}{\\partial y}$ pointwise. For a rigid motion in the plane, $\\omega_z$ is spatially constant (possibly zero), and equals twice the scalar angular velocity. Degrees or radians do not directly enter the computation; treat all quantities as dimensionless and angles as measured in radians.\n\nDefine the following decision metrics over the grid:\n- $E_D := \\max\\limits_{\\text{grid}} ||\\boldsymbol{D}||_F$,\n- $E_{\\mathrm{div}} := \\max\\limits_{\\text{grid}} \\left|\\nabla \\cdot \\boldsymbol{v}\\right|$,\n- $E_{\\mathrm{curlvar}} := \\max\\limits_{\\text{grid}} \\left|\\omega_z - \\overline{\\omega}_z\\right|$, where $\\overline{\\omega}_z$ is the spatial mean of $\\omega_z$ over the grid.\n\nUse the tolerances:\n- $T_D = 5\\times 10^{-3}$,\n- $T_{\\mathrm{div}} = 5\\times 10^{-3}$,\n- $T_{\\mathrm{curlvar}} = 5\\times 10^{-3}$.\n\nClassify a field as rigid if and only if all three conditions hold:\n- $E_D \\leq T_D$,\n- $E_{\\mathrm{div}} \\leq T_{\\mathrm{div}}$,\n- $E_{\\mathrm{curlvar}} \\leq T_{\\mathrm{curlvar}}$.\n\nImplement the following test suite, each defined by a closed-form velocity field sampled on the grid:\n- Test $1$ (pure translation): $\\boldsymbol{v}(x,y) = \\left(a, b\\right)$ with $a = 0.3$, $b = -0.2$. Expected to be rigid.\n- Test $2$ (pure rotation about the origin): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right)$ with $\\omega = 1.7$. Expected to be rigid.\n- Test $3$ (rotation plus translation): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right) + \\left(a, b\\right)$ with $\\omega = -0.8$, $a = 0.05$, $b = -0.04$. Expected to be rigid.\n- Test $4$ (simple shear, nonrigid): $\\boldsymbol{v}(x,y) = \\left(\\gamma y, 0\\right)$ with $\\gamma = 0.3$. Expected to be nonrigid.\n- Test $5$ (rotation plus small noise): $\\boldsymbol{v}(x,y) = \\omega \\left(-y, x\\right) + \\varepsilon \\,\\boldsymbol{\\eta}(x,y)$ with $\\omega = 0.6$, $\\varepsilon = 10^{-4}$, and $\\boldsymbol{\\eta}$ a zero-mean random field with independent components and unit variance; fix a deterministic seed so the result is reproducible. Expected to be rigid under the given tolerances.\n- Test $6$ (isotropic expansion, nonrigid): $\\boldsymbol{v}(x,y) = \\alpha \\left(x, y\\right)$ with $\\alpha = 10^{-2}$. Expected to be nonrigid.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of tests $1$ through $6$, with each entry a boolean literal of your programming language indicating whether the field is classified as rigid. For example, an output could look like $[\\mathrm{True},\\mathrm{False},\\dots]$.\n\nNo user input is required and no external files may be used. All random quantities must be generated with a fixed seed to ensure reproducibility. Angles are in radians. No physical units are required in the final output. The output type for each test is boolean, and the final output must be exactly one line in the specified format.",
            "solution": "The problem requires the design and implementation of a numerical procedure to classify two-dimensional velocity fields as representing rigid body motions. This validation is based on three fundamental kinematic invariants of rigid motion. The entire process, from grid generation to the final classification, is detailed below.\n\n### I. Kinematic Principles of Rigid Body Motion\n\nThe motion of a continuum is described by a velocity field $\\boldsymbol{v}(\\boldsymbol{x}, t)$, which assigns a velocity vector to each point $\\boldsymbol{x}$ in space at time $t$. For this problem, we consider steady (time-independent) planar velocity fields, $\\boldsymbol{v}(\\boldsymbol{x}) = (v_x(x,y), v_y(x,y))$.\n\nThe local behavior of the flow is characterized by the velocity gradient tensor, $\\boldsymbol{L}$, defined as:\n$$\n\\boldsymbol{L} = \\nabla \\boldsymbol{v} = \\begin{pmatrix} \\dfrac{\\partial v_x}{\\partial x} & \\dfrac{\\partial v_x}{\\partial y} \\\\ \\dfrac{\\partial v_y}{\\partial x} & \\dfrac{\\partial v_y}{\\partial y} \\end{pmatrix}\n$$\nThe tensor $\\boldsymbol{L}$ can be uniquely decomposed into its symmetric and skew-symmetric parts:\n$$\n\\boldsymbol{L} = \\boldsymbol{D} + \\boldsymbol{W}\n$$\nwhere $\\boldsymbol{D}$ is the rate-of-deformation (or strain rate) tensor and $\\boldsymbol{W}$ is the spin (or vorticity) tensor:\n$$\n\\boldsymbol{D} = \\frac{1}{2}(\\boldsymbol{L} + \\boldsymbol{L}^{\\mathsf{T}}) \\quad \\text{and} \\quad \\boldsymbol{W} = \\frac{1}{2}(\\boldsymbol{L} - \\boldsymbol{L}^{\\mathsf{T}})\n$$\nA motion is defined as rigid if and only if the distance between any two material points remains constant over time. This kinematic constraint implies that the rate-of-deformation tensor must be identically zero throughout the body, i.e., $\\boldsymbol{D} = \\boldsymbol{0}$. The velocity field for a general rigid body motion has the form $\\boldsymbol{v}(\\boldsymbol{x}) = \\boldsymbol{c} + \\boldsymbol{\\Omega}\\,\\boldsymbol{x}$, where $\\boldsymbol{c}$ is a constant translational velocity vector and $\\boldsymbol{\\Omega}$ is a constant skew-symmetric tensor representing angular velocity. For such a field, the velocity gradient is $\\boldsymbol{L} = \\boldsymbol{\\Omega}$, which is constant and skew-symmetric.\n\nFrom the condition $\\boldsymbol{D} = \\boldsymbol{0}$, two further invariants are derived:\n1.  **Zero Divergence**: The divergence of the velocity field, which represents the rate of volume change per unit volume, must be zero. The divergence is the trace of the velocity gradient, $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{L}) = \\mathrm{tr}(\\boldsymbol{D}) + \\mathrm{tr}(\\boldsymbol{W})$. Since $\\boldsymbol{W}$ is skew-symmetric, its trace is zero, so $\\nabla \\cdot \\boldsymbol{v} = \\mathrm{tr}(\\boldsymbol{D})$. Thus, if $\\boldsymbol{D} = \\boldsymbol{0}$, then $\\nabla \\cdot \\boldsymbol{v} = 0$.\n2.  **Spatially Constant Vorticity**: The vorticity vector, $\\boldsymbol{\\omega} = \\nabla \\times \\boldsymbol{v}$, measures the local angular velocity of a fluid element. For a 2D field $\\boldsymbol{v} = (v_x, v_y, 0)$, the vorticity has only one non-zero component, $\\omega_z = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$. This is related to the spin tensor via $\\omega_z = 2W_{21}$. For a rigid motion, $\\boldsymbol{L} = \\boldsymbol{\\Omega}$ is constant, which means $\\boldsymbol{W}$ is constant, and therefore the vorticity $\\omega_z$ must be spatially constant.\n\nThese three conditions form the basis of our numerical verification:\n- Condition 1: The magnitude of the rate-of-deformation tensor $\\boldsymbol{D}$ is zero.\n- Condition 2: The divergence $\\nabla \\cdot \\boldsymbol{v}$ is zero.\n- Condition 3: The scalar vorticity $\\omega_z$ is spatially constant.\n\n### II. Numerical Implementation\n\nWe are given a rectangular domain $[-1,1]\\times[-0.9,0.9]$ discretized into a uniform grid of $N_x = 41 \\times N_y = 37$ points. The grid spacings are $\\Delta x = \\frac{1 - (-1)}{41 - 1} = 0.05$ and $\\Delta y = \\frac{0.9 - (-0.9)}{37 - 1} = 0.05$. The velocity components $v_x(x,y)$ and $v_y(x,y)$ are sampled at each grid point $(x_j, y_i)$.\n\n**A. Numerical Differentiation**\n\nThe partial derivatives required for the velocity gradient $\\boldsymbol{L}$ are computed using finite differences. For a function $f(x,y)$ sampled on the grid as $f_{i,j} = f(x_j, y_i)$:\n- At interior points ($1 \\le j \\le N_x-2$), a second-order central difference scheme is used for accuracy:\n  $$ \\frac{\\partial f}{\\partial x}\\bigg|_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta x} $$\n- At boundary points ($j=0$ and $j=N_x-1$), first-order one-sided differences are used:\n  $$ \\frac{\\partial f}{\\partial x}\\bigg|_{i,0} \\approx \\frac{f_{i,1} - f_{i,0}}{\\Delta x} \\quad \\text{and} \\quad \\frac{\\partial f}{\\partial x}\\bigg|_{i,N_x-1} \\approx \\frac{f_{i,N_x-1} - f_{i,N_x-2}}{\\Delta x} $$\nAnalogous formulas are applied for the partial derivative with respect to $y$. This hybrid scheme provides a complete field of derivatives.\n\n**B. Calculation of Metrics**\n\nFor each of the six test velocity fields, we perform the following steps:\n1.  **Sample the Field**: The analytic functions for $v_x(x,y)$ and $v_y(x,y)$ are evaluated on the grid coordinates to produce two arrays, $\\boldsymbol{V}_x$ and $\\boldsymbol{V}_y$, of shape $(N_y, N_x)$. For the stochastic case, a fixed-seed random number generator is used to ensure reproducibility.\n2.  **Compute Velocity Gradient**: The numerical differentiation scheme is applied to $\\boldsymbol{V}_x$ and $\\boldsymbol{V}_y$ to compute the four components of the velocity gradient tensor $\\boldsymbol{L}$ at each grid point: $L_{11} = \\frac{\\partial v_x}{\\partial x}$, $L_{12} = \\frac{\\partial v_x}{\\partial y}$, $L_{21} = \\frac{\\partial v_y}{\\partial x}$, and $L_{22} = \\frac{\\partial v_y}{\\partial y}$.\n3.  **Evaluate Invariants**: At each grid point, we compute:\n    - The rate-of-deformation tensor components: $D_{11} = L_{11}$, $D_{22} = L_{22}$, and $D_{12} = \\frac{1}{2}(L_{12} + L_{21})$.\n    - The Frobenius norm of $\\boldsymbol{D}$: $||\\boldsymbol{D}||_F = \\sqrt{D_{11}^2 + 2 D_{12}^2 + D_{22}^2}$.\n    - The divergence: $\\nabla \\cdot \\boldsymbol{v} = L_{11} + L_{22}$.\n    - The scalar vorticity: $\\omega_z = L_{21} - L_{12}$.\n4.  **Compute Decision Metrics**: The spatially distributed fields of the invariants are reduced to single scalar metrics by taking the maximum value over the entire grid:\n    - $E_D = \\max_{\\text{grid}} ||\\boldsymbol{D}||_F$\n    - $E_{\\mathrm{div}} = \\max_{\\text{grid}} |\\nabla \\cdot \\boldsymbol{v}|$\n    - $E_{\\mathrm{curlvar}} = \\max_{\\text{grid}} |\\omega_z - \\overline{\\omega}_z|$, where $\\overline{\\omega}_z$ is the mean of $\\omega_z$ over all grid points.\n\n**C. Classification**\n\nA given velocity field is classified as 'rigid' if and only if all three of its computed metrics fall below their respective predefined tolerances:\n- $E_D \\leq T_D$, with $T_D = 5 \\times 10^{-3}$\n- $E_{\\mathrm{div}} \\leq T_{\\mathrm{div}}$, with $T_{\\mathrm{div}} = 5 \\times 10^{-3}$\n- $E_{\\mathrm{curlvar}} \\leq T_{\\mathrm{curlvar}}$, with $T_{\\mathrm{curlvar}} = 5 \\times 10^{-3}$\n\nAnalytically, the first three test cases represent true rigid body motions, so their metrics should be zero up to machine precision and numerical discretization error. The fourth (simple shear) and sixth (isotropic expansion) cases are non-rigid, and their metrics $E_D$ and/or $E_{\\mathrm{div}}$ are expected to be significantly larger than the tolerances. The fifth case, a rigid rotation with small additive noise, is designed to test the robustness of the method; the metrics are expected to be proportional to the noise amplitude $\\varepsilon$ divided by the grid spacing $\\Delta x$, which evaluates to an order of magnitude smaller than the tolerances, thus correctly classifying it as rigid. The implemented program executes this logic for each test case and reports the boolean classification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_derivatives(F, dx, dy):\n    \"\"\"\n    Computes partial derivatives of a 2D field F using finite differences.\n    - 2nd-order central differences for interior points.\n    - 1st-order one-sided differences for boundary points.\n    \n    Args:\n        F (np.ndarray): The 2D field of shape (Ny, Nx).\n        dx (float): Grid spacing in the x-direction.\n        dy (float): Grid spacing in the y-direction.\n    \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (dF_dx, dF_dy).\n    \"\"\"\n    Ny, Nx = F.shape\n    dF_dx = np.zeros_like(F)\n    dF_dy = np.zeros_like(F)\n\n    # Compute dF/dx\n    # Interior points (central difference)\n    dF_dx[:, 1:-1] = (F[:, 2:] - F[:, :-2]) / (2 * dx)\n    # Boundary points (one-sided differences)\n    dF_dx[:, 0] = (F[:, 1] - F[:, 0]) / dx\n    dF_dx[:, -1] = (F[:, -1] - F[:, -2]) / dx\n\n    # Compute dF/dy\n    # Interior points (central difference)\n    dF_dy[1:-1, :] = (F[2:, :] - F[:-2, :]) / (2 * dy)\n    # Boundary points (one-sided differences)\n    dF_dy[0, :] = (F[1, :] - F[0, :]) / dy\n    dF_dy[-1, :] = (F[-1, :] - F[-2, :]) / dy\n\n    return dF_dx, dF_dy\n\ndef verify_field(vx, vy, dx, dy, tolerances):\n    \"\"\"\n    Verifies if a velocity field (vx, vy) represents a rigid body motion.\n\n    Args:\n        vx (np.ndarray): The x-component of the velocity field.\n        vy (np.ndarray): The y-component of the velocity field.\n        dx (float): Grid spacing in x.\n        dy (float): Grid spacing in y.\n        tolerances (dict): A dictionary with keys 'T_D', 'T_div', 'T_curlvar'.\n\n    Returns:\n        bool: True if the field is classified as rigid, False otherwise.\n    \"\"\"\n    # 1. Compute components of the velocity gradient tensor L\n    dvx_dx, dvx_dy = compute_derivatives(vx, dx, dy)\n    dvy_dx, dvy_dy = compute_derivatives(vy, dx, dy)\n    \n    L11 = dvx_dx\n    L12 = dvx_dy\n    L21 = dvy_dx\n    L22 = dvy_dy\n\n    # 2. Compute invariants\n    # Rate-of-deformation tensor D\n    D11 = L11\n    D22 = L22\n    D12 = 0.5 * (L12 + L21)\n    \n    # Frobenius norm of D, pointwise\n    norm_D_F = np.sqrt(D11**2 + 2 * D12**2 + D22**2)\n    \n    # Divergence\n    div_v = L11 + L22\n\n    # Vorticity (scalar z-component)\n    omega_z = L21 - L12\n\n    # 3. Compute decision metrics\n    E_D = np.max(norm_D_F)\n    E_div = np.max(np.abs(div_v))\n    \n    mean_omega_z = np.mean(omega_z)\n    E_curlvar = np.max(np.abs(omega_z - mean_omega_z))\n\n    # 4. Classify the field\n    T_D = tolerances['T_D']\n    T_div = tolerances['T_div']\n    T_curlvar = tolerances['T_curlvar']\n\n    is_rigid = (E_D <= T_D) and (E_div <= T_div) and (E_curlvar <= T_curlvar)\n    \n    return is_rigid\n\ndef solve():\n    # Define grid parameters\n    Nx = 41\n    Ny = 37\n    x_min, x_max = -1.0, 1.0\n    y_min, y_max = -0.9, 0.9\n    \n    dx = (x_max - x_min) / (Nx - 1)\n    dy = (y_max - y_min) / (Ny - 1)\n\n    # Create grid\n    x = np.linspace(x_min, x_max, Nx)\n    y = np.linspace(y_min, y_max, Ny)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define tolerances\n    tolerances = {\n        'T_D': 5e-3,\n        'T_div': 5e-3,\n        'T_curlvar': 5e-3\n    }\n\n    # Define test cases\n    test_cases = [\n        # Test 1: Pure translation\n        lambda xx, yy: (0.3 * np.ones_like(xx), -0.2 * np.ones_like(yy)),\n        # Test 2: Pure rotation\n        lambda xx, yy: (1.7 * (-yy), 1.7 * xx),\n        # Test 3: Rotation plus translation\n        lambda xx, yy: (-0.8 * (-yy) + 0.05, -0.8 * xx - 0.04),\n        # Test 4: Simple shear (non-rigid)\n        lambda xx, yy: (0.3 * yy, np.zeros_like(xx)),\n        # Test 5: Rotation plus small noise\n        lambda xx, yy: (\n            lambda omega=0.6, eps=1e-4, seed=42: (\n                (rng := np.random.default_rng(seed)),\n                (omega * (-yy) + eps * rng.standard_normal(xx.shape), \n                 omega * xx + eps * rng.standard_normal(xx.shape))\n            )[1]\n        )(xx, yy),\n        # Test 6: Isotropic expansion (non-rigid)\n        lambda xx, yy: (1e-2 * xx, 1e-2 * yy)\n    ]\n\n    results = []\n    for test_func in test_cases:\n        vx, vy = test_func(xx, yy)\n        is_rigid = verify_field(vx, vy, dx, dy, tolerances)\n        results.append(is_rigid)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "In computational simulations, efficiency often goes hand-in-hand with accuracy, and effective algorithms know when to trade one for the other. This practice  explores a common and powerful technique: approximating small rigid rotations with a simple linear update rather than the computationally more intensive exponential map. By analytically deriving the error of this approximation, you will develop a quantitative understanding of its limitations and learn how to formulate a robust, error-based criterion for its use in advanced numerical codes.",
            "id": "3597030",
            "problem": "A rigid body in $\\mathbb{R}^3$ undergoes a pure rotation by angle $\\theta \\in \\mathbb{R}$ about a unit axis $\\hat{\\mathbf{n}} \\in \\mathbb{R}^3$ with $\\|\\hat{\\mathbf{n}}\\|=1$. Let $\\mathbf{R}(\\theta,\\hat{\\mathbf{n}}) \\in \\mathrm{SO}(3)$ denote the exact rotation matrix, obtained from the matrix exponential of the generator $\\mathbf{S}=[\\hat{\\mathbf{n}}]_{\\times}$, where $[\\cdot]_{\\times}$ denotes the $3 \\times 3$ skew-symmetric matrix that represents the cross product. In many time-stepping algorithms in computational solid mechanics, a small-rotation approximation is used at each step, replacing $\\mathbf{R}(\\theta,\\hat{\\mathbf{n}})$ by $\\mathbf{R}_{\\mathrm{s}}(\\theta,\\hat{\\mathbf{n}})=\\mathbf{I}+\\theta \\mathbf{S}$. Consider the error measure given by the Frobenius norm of the rotation matrix difference, $E_{F}(\\theta)=\\|\\mathbf{R}(\\theta,\\hat{\\mathbf{n}})-\\mathbf{R}_{\\mathrm{s}}(\\theta,\\hat{\\mathbf{n}})\\|_{F}$. Starting only from the definition $\\mathbf{R}(\\theta,\\hat{\\mathbf{n}})=\\exp(\\theta \\mathbf{S})$, the properties of the cross-product operator, and standard matrix norms and inner products, perform the following tasks:\n\n$1.$ Derive a closed-form expression for $E_{F}(\\theta)$ as a function of $\\theta$ that does not depend on the specific choice of $\\hat{\\mathbf{n}}$ except through its unit norm.\n\n$2.$ In the asymptotic regime of small $\\theta$, invert your leading-order approximation to obtain an asymptotically sharp threshold angle $\\theta_{\\mathrm{crit}}(\\tau_{F})$ such that $E_{F}(\\theta) \\le \\tau_{F}$ holds whenever $|\\theta| \\le \\theta_{\\mathrm{crit}}(\\tau_{F})$, to leading order in a small tolerance $\\tau_{F} > 0$. Express $\\theta_{\\mathrm{crit}}$ in radians.\n\n$3.$ Based on your result, state a practical switching criterion for an algorithm that integrates an angular velocity $\\boldsymbol{\\omega}(t)$ over a time step of size $\\Delta t$: use the small-rotation update if $\\|\\boldsymbol{\\omega}\\| \\Delta t \\le \\theta_{\\mathrm{crit}}(\\tau_{F})$, otherwise switch to a finite-rotation representation such as the exponential map.\n\nYour final reported answer must be the single closed-form asymptotic expression you obtained for $\\theta_{\\mathrm{crit}}(\\tau_{F})$ in item $2$. No numerical rounding is required. Angles must be in radians.",
            "solution": "The problem asks for an analysis of the error incurred by the small-rotation approximation in rigid body mechanics, culminating in a practical criterion for its use in numerical algorithms. The problem is well-posed, scientifically grounded, and can be solved using standard principles of linear algebra and calculus.\n\nThe analysis proceeds in three stages as requested by a three-part query. First, a closed-form expression for the Frobenius norm of the error matrix, $E_{F}(\\theta)$, is derived. Second, this expression is analyzed in the asymptotic limit of small rotation angles $\\theta$ to find a critical angle threshold $\\theta_{\\mathrm{crit}}(\\tau_{F})$ corresponding to a given error tolerance $\\tau_{F}$. Third, this result is translated into a practical switching criterion for numerical integration of rigid body motion.\n\nLet $\\hat{\\mathbf{n}}$ be the unit vector defining the axis of rotation, and $\\theta$ be the angle of rotation. The generator of the rotation is the skew-symmetric matrix $\\mathbf{S} = [\\hat{\\mathbf{n}}]_{\\times}$. The exact rotation matrix is given by the matrix exponential $\\mathbf{R}(\\theta, \\hat{\\mathbf{n}}) = \\exp(\\theta \\mathbf{S})$. The small-rotation approximation is the first-order Taylor expansion of this exponential, $\\mathbf{R}_{\\mathrm{s}}(\\theta, \\hat{\\mathbf{n}}) = \\mathbf{I} + \\theta \\mathbf{S}$.\n\nThe derivation will rely on the algebraic properties of the matrix $\\mathbf{S}$. For any vector $\\mathbf{v} \\in \\mathbb{R}^3$, $\\mathbf{S}\\mathbf{v} = \\hat{\\mathbf{n}} \\times \\mathbf{v}$. A key property is that powers of $\\mathbf{S}$ are related. Using the vector triple product identity, we have $\\mathbf{S}^2 \\mathbf{v} = \\hat{\\mathbf{n}} \\times (\\hat{\\mathbf{n}} \\times \\mathbf{v}) = (\\hat{\\mathbf{n}} \\cdot \\mathbf{v})\\hat{\\mathbf{n}} - (\\hat{\\mathbf{n}} \\cdot \\hat{\\mathbf{n}})\\mathbf{v} = (\\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T)\\mathbf{v} - \\mathbf{I}\\mathbf{v}$. Thus, the matrix identity is $\\mathbf{S}^2 = \\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T - \\mathbf{I}$. From this, we find $\\mathbf{S}^3 = \\mathbf{S}(\\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T - \\mathbf{I}) = \\mathbf{S}(\\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T) - \\mathbf{S}$. The first term is zero, since for any vector $\\mathbf{v}$, $\\mathbf{S}(\\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T)\\mathbf{v} = \\hat{\\mathbf{n}} \\times ((\\hat{\\mathbf{n}} \\cdot \\mathbf{v})\\hat{\\mathbf{n}}) = (\\hat{\\mathbf{n}}\\cdot\\mathbf{v})(\\hat{\\mathbf{n}}\\times\\hat{\\mathbf{n}}) = \\mathbf{0}$. Therefore, we arrive at the crucial identity $\\mathbf{S}^3 = -\\mathbf{S}$.\n\n**$1.$ Derivation of the error norm $E_{F}(\\theta)$**\n\nWe begin by expressing the exact rotation matrix $\\mathbf{R}$ in a closed form, known as Rodrigues' rotation formula, by expanding its exponential definition:\n$$ \\mathbf{R} = \\exp(\\theta \\mathbf{S}) = \\sum_{k=0}^{\\infty} \\frac{(\\theta \\mathbf{S})^k}{k!} = \\mathbf{I} + \\theta \\mathbf{S} + \\frac{\\theta^2}{2!} \\mathbf{S}^2 + \\frac{\\theta^3}{3!} \\mathbf{S}^3 + \\dots $$\nUsing $\\mathbf{S}^3 = -\\mathbf{S}$, $\\mathbf{S}^4 = -\\mathbf{S}^2$, and so on, we can group the terms:\n$$ \\mathbf{R} = \\mathbf{I} + \\left( \\theta - \\frac{\\theta^3}{3!} + \\frac{\\theta^5}{5!} - \\dots \\right) \\mathbf{S} + \\left( \\frac{\\theta^2}{2!} - \\frac{\\theta^4}{4!} + \\frac{\\theta^6}{6!} - \\dots \\right) \\mathbf{S}^2 $$\nThe series in parentheses are the Taylor series for $\\sin\\theta$ and $(1-\\cos\\theta)$, respectively. This yields Rodrigues' formula:\n$$ \\mathbf{R}(\\theta, \\hat{\\mathbf{n}}) = \\mathbf{I} + (\\sin\\theta)\\mathbf{S} + (1-\\cos\\theta)\\mathbf{S}^2 $$\nThe error matrix $\\mathbf{E}(\\theta)$ is the difference between the exact rotation and its first-order approximation:\n$$ \\mathbf{E}(\\theta) = \\mathbf{R}(\\theta, \\hat{\\mathbf{n}}) - \\mathbf{R}_{\\mathrm{s}}(\\theta, \\hat{\\mathbf{n}}) = (\\mathbf{I} + (\\sin\\theta)\\mathbf{S} + (1-\\cos\\theta)\\mathbf{S}^2) - (\\mathbf{I} + \\theta\\mathbf{S}) $$\n$$ \\mathbf{E}(\\theta) = (\\sin\\theta - \\theta)\\mathbf{S} + (1-\\cos\\theta)\\mathbf{S}^2 $$\nThe error measure is the Frobenius norm of this matrix, $E_{F}(\\theta) = \\|\\mathbf{E}(\\theta)\\|_{F}$. The square of the Frobenius norm is given by $E_{F}^2(\\theta) = \\mathrm{Tr}(\\mathbf{E}(\\theta)^T \\mathbf{E}(\\theta))$. The matrices $\\mathbf{S}$ and $\\mathbf{S}^2$ possess useful orthogonality properties under the Frobenius inner product $\\langle\\mathbf{A}, \\mathbf{B}\\rangle_{F} = \\mathrm{Tr}(\\mathbf{A}^T\\mathbf{B})$. Specifically, $\\mathbf{S}$ is skew-symmetric ($\\mathbf{S}^T = -\\mathbf{S}$) and $\\mathbf{S}^2$ is symmetric (($\\mathbf{S}^2)^T = \\mathbf{S}^2$). Their inner product is:\n$$ \\langle \\mathbf{S}, \\mathbf{S}^2 \\rangle_{F} = \\mathrm{Tr}(\\mathbf{S}^T \\mathbf{S}^2) = \\mathrm{Tr}(-\\mathbf{S} \\mathbf{S}^2) = -\\mathrm{Tr}(\\mathbf{S}^3) = -\\mathrm{Tr}(-\\mathbf{S}) = \\mathrm{Tr}(\\mathbf{S}) = 0 $$\nSince the trace of any skew-symmetric matrix is $0$. This orthogonality allows us to write the squared norm of the sum as the sum of squared norms:\n$$ E_{F}^2(\\theta) = \\|(\\sin\\theta - \\theta)\\mathbf{S} + (1-\\cos\\theta)\\mathbf{S}^2\\|_{F}^2 = (\\sin\\theta - \\theta)^2 \\|\\mathbf{S}\\|_{F}^2 + (1-\\cos\\theta)^2 \\|\\mathbf{S}^2\\|_{F}^2 $$\nWe now compute the norms of $\\mathbf{S}$ and $\\mathbf{S}^2$. The trace of $\\mathbf{S}^2 = \\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T - \\mathbf{I}$ is $\\mathrm{Tr}(\\hat{\\mathbf{n}}\\hat{\\mathbf{n}}^T) - \\mathrm{Tr}(\\mathbf{I}) = \\|\\hat{\\mathbf{n}}\\|^2 - 3 = 1-3 = -2$.\n$$ \\|\\mathbf{S}\\|_{F}^2 = \\mathrm{Tr}(\\mathbf{S}^T\\mathbf{S}) = \\mathrm{Tr}(-\\mathbf{S}^2) = -\\mathrm{Tr}(\\mathbf{S}^2) = -(-2) = 2 $$\n$$ \\|\\mathbf{S}^2\\|_{F}^2 = \\mathrm{Tr}((\\mathbf{S}^2)^T\\mathbf{S}^2) = \\mathrm{Tr}(\\mathbf{S}^4) = \\mathrm{Tr}(-\\mathbf{S}^2) = -(-2) = 2 $$\nSubstituting these norms back into the expression for $E_{F}^2(\\theta)$:\n$$ E_{F}^2(\\theta) = 2(\\sin\\theta - \\theta)^2 + 2(1-\\cos\\theta)^2 $$\nTaking the square root gives the closed-form expression for the error, which is independent of $\\hat{\\mathbf{n}}$:\n$$ E_{F}(\\theta) = \\sqrt{2 \\left( (\\sin\\theta - \\theta)^2 + (1-\\cos\\theta)^2 \\right)} $$\n\n**$2.$ Asymptotic analysis for $\\theta_{\\mathrm{crit}}(\\tau_{F})$**\n\nTo find the asymptotic behavior for small $\\theta$, we use the Taylor series expansions for $\\sin\\theta$ and $\\cos\\theta$ around $\\theta=0$:\n$$ \\sin\\theta = \\theta - \\frac{\\theta^3}{6} + O(\\theta^5) \\implies \\sin\\theta - \\theta = -\\frac{\\theta^3}{6} + O(\\theta^5) $$\n$$ \\cos\\theta = 1 - \\frac{\\theta^2}{2} + O(\\theta^4) \\implies 1 - \\cos\\theta = \\frac{\\theta^2}{2} + O(\\theta^4) $$\nSubstituting these into the expression for $E_{F}^2(\\theta)$:\n$$ E_{F}^2(\\theta) = 2\\left( \\left(-\\frac{\\theta^3}{6} + O(\\theta^5)\\right)^2 + \\left(\\frac{\\theta^2}{2} + O(\\theta^4)\\right)^2 \\right) = 2\\left( \\frac{\\theta^6}{36} + O(\\theta^8) + \\frac{\\theta^4}{4} + O(\\theta^6) \\right) $$\nFor small $\\theta$, the dominant term is the one with the lowest power of $\\theta$, which is $\\theta^4$:\n$$ E_{F}^2(\\theta) \\approx 2 \\left( \\frac{\\theta^4}{4} \\right) = \\frac{\\theta^4}{2} $$\nTaking the square root gives the leading-order approximation for the error norm:\n$$ E_{F}(\\theta) \\approx \\sqrt{\\frac{\\theta^4}{2}} = \\frac{|\\theta|^2}{\\sqrt{2}} $$\nThe problem defines $\\theta_{\\mathrm{crit}}(\\tau_{F})$ as the threshold angle for which $E_{F}(\\theta_{\\mathrm{crit}}) = \\tau_{F}$, for a small tolerance $\\tau_{F} > 0$. Using our asymptotic result:\n$$ \\frac{\\theta_{\\mathrm{crit}}^2}{\\sqrt{2}} = \\tau_{F} $$\nSolving for $\\theta_{\\mathrm{crit}}$ (taking the positive root as it represents an angle magnitude):\n$$ \\theta_{\\mathrm{crit}}^2 = \\tau_{F}\\sqrt{2} \\implies \\theta_{\\mathrm{crit}}(\\tau_{F}) = \\sqrt{\\tau_{F}\\sqrt{2}} = (\\tau_{F}^2 2)^{1/4} = 2^{1/4} \\tau_{F}^{1/2} $$\n\n**$3.$ Practical switching criterion**\n\nIn a numerical integration scheme for rigid body dynamics, the body's orientation is updated over a small time step $\\Delta t$. If the body has an angular velocity $\\boldsymbol{\\omega}(t)$, the angle of rotation over the time step is approximately $\\theta = \\|\\boldsymbol{\\omega}\\| \\Delta t$, and the axis is $\\hat{\\mathbf{n}} = \\boldsymbol{\\omega}/\\|\\boldsymbol{\\omega}\\|$. The incremental rotation matrix is $\\exp(\\Delta t[\\boldsymbol{\\omega}]_{\\times})$.\n\nThe error analysis above provides a quantitative basis for deciding when the computationally cheaper small-rotation approximation is sufficiently accurate. The criterion is to keep the approximation error $E_F$ below a prescribed tolerance $\\tau_F$. This translates to keeping the rotation angle $\\theta$ below the derived critical angle $\\theta_{\\mathrm{crit}}(\\tau_F)$.\n\nThe practical switching criterion is as follows:\nGiven a user-defined error tolerance $\\tau_F$, first compute the critical angle $\\theta_{\\mathrm{crit}}(\\tau_{F}) = 2^{1/4}\\tau_{F}^{1/2}$. Then, at each time step $\\Delta t$:\n\\begin{enumerate}\n    \\item Compute the magnitude of the angular increment: $\\theta = \\|\\boldsymbol{\\omega}\\| \\Delta t$.\n    \\item If $\\theta \\le \\theta_{\\mathrm{crit}}(\\tau_{F})$, the small-rotation approximation is sufficiently accurate. The orientation is updated using the linear formula: $\\mathbf{R}_{\\mathrm{new}} = (\\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times}) \\mathbf{R}_{\\mathrm{old}}$.\n    \\item If $\\theta > \\theta_{\\mathrm{crit}}(\\tau_{F})$, the error would exceed the tolerance. A more accurate, and typically more expensive, update must be used, such as the full exponential map: $\\mathbf{R}_{\\mathrm{new}} = \\exp(\\Delta t [\\boldsymbol{\\omega}]_{\\times}) \\mathbf{R}_{\\mathrm{old}}$.\n\\end{enumerate}\nThis criterion ensures computational efficiency by using the cheapest method within its regime of validity, while maintaining accuracy by switching to a better representation for larger rotations.",
            "answer": "$$\\boxed{2^{1/4} \\tau_{F}^{1/2}}$$"
        },
        {
            "introduction": "Accurately simulating rotational motion over long time horizons is a classic challenge in dynamics, as naive numerical methods can accumulate errors that violate fundamental geometric constraints. This exercise  directly contrasts a simple matrix-based forward Euler method with a more sophisticated quaternion-based midpoint integrator. Through derivation and implementation, you will discover why \"geometric integrators\" that respect the underlying structure of the rotation group $\\mathrm{SO}(3)$ are essential for ensuring the stability and physical realism of simulations.",
            "id": "3596985",
            "problem": "Consider planar-free rigid body rotations in three dimensions, characterized by the Special Orthogonal Group $\\mathrm{SO}(3)$ and unit quaternions. Let the body angular velocity be represented by the vector $\\boldsymbol{\\omega}(t) \\in \\mathbb{R}^3$ in radians per second, and the rotation matrix by $\\mathbf{R}(t) \\in \\mathrm{SO}(3)$. The rigid body kinematic equation is the first-order linear matrix ordinary differential equation $\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}$, where $[\\boldsymbol{\\omega}]_{\\times}$ is the skew-symmetric cross-product matrix. A unit quaternion $\\mathbf{q}(t) \\in \\mathbb{R}^4$ with scalar-first convention encodes the same rotation with the kinematic equation $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$, where $\\mathbf{S}(\\boldsymbol{\\omega}) \\in \\mathbb{R}^{4 \\times 4}$ is skew-symmetric.\n\nYour task is to implement, analyze, and compare two discrete time-stepping schemes over constant time steps of size $\\Delta t$:\n\n1. A midpoint update for unit quaternions defined by applying the implicit midpoint rule to $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$ with piecewise-constant $\\boldsymbol{\\omega}$ over each time step. This yields a linear update of the form $\\mathbf{q}_{n+1} = \\mathbf{C} \\, \\mathbf{q}_n$ for some matrix $\\mathbf{C}$ derived from $\\mathbf{S}(\\boldsymbol{\\omega})$ and $\\Delta t$. You must derive this update from the implicit midpoint rule using only fundamental definitions.\n\n2. A direct matrix forward Euler update for the rotation matrix defined by $\\mathbf{R}_{n+1} = \\mathbf{R}_n + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}_n$ without any re-orthonormalization.\n\nStarting from only the rigid body kinematic equations and the definition of the implicit midpoint rule, derive the quaternion midpoint update and justify whether it preserves the unit norm of $\\mathbf{q}$. Also, analyze whether the direct matrix forward Euler update preserves orthogonality of $\\mathbf{R}$. The analysis must explicitly quantify the orthogonality error of the matrix scheme and the norm error of the quaternion scheme.\n\nFor numerical evaluation, implement a program that for each specified test case integrates both schemes for $N$ uniform steps of size $\\Delta t$ with constant angular velocity $\\boldsymbol{\\omega}$ over each step. The quaternion scheme should be applied to $\\mathbf{q}$ and the direct matrix scheme to $\\mathbf{R}$. Construct $\\mathbf{R}_0$ from the initial quaternion $\\mathbf{q}_0$ using the standard scalar-first quaternion-to-rotation mapping. For each test case, compute the following two scalar metrics at the final time $t_N = N \\Delta t$:\n\n- The quaternion unit-norm deviation $e_q = \\lvert \\lVert \\mathbf{q}_N \\rVert_2 - 1 \\rvert$.\n- The matrix orthogonality deviation $e_R = \\lVert \\mathbf{R}_N^{\\top} \\mathbf{R}_N - \\mathbf{I} \\rVert_F$, where $\\lVert \\cdot \\rVert_F$ is the Frobenius norm.\n\nAll angles must be in radians and all times in seconds. Ensure that $\\boldsymbol{\\omega}$ is expressed in radians per second. Report each metric as a floating-point number rounded to $10$ decimal places.\n\nUse the following test suite, which explores a typical case, stress cases, a boundary case, and long-horizon accumulation:\n\n- Test A: $\\mathbf{q}_0 = [1, 0, 0, 0]^{\\top}$, $\\boldsymbol{\\omega} = [0.2, -0.1, 0.05]^{\\top}$ radians per second, $\\Delta t = 0.01$ seconds, $N = 1000$.\n- Test B: $\\mathbf{q}_0$ from axis-angle with axis $\\mathbf{a} = [1, 1, 1]^{\\top}/\\lVert [1, 1, 1]^{\\top} \\rVert_2$ and angle $\\theta = 1.7$ radians, that is $\\mathbf{q}_0 = [\\cos(\\theta/2), \\sin(\\theta/2)\\,\\mathbf{a}^{\\top}]^{\\top}$; $\\boldsymbol{\\omega} = [50, 0, 25]^{\\top}$ radians per second, $\\Delta t = 0.02$ seconds, $N = 10$.\n- Test C: $\\mathbf{q}_0$ from axis-angle with axis $\\mathbf{a} = [0, 1, 0]^{\\top}$ and angle $\\theta = 0.3$ radians; $\\boldsymbol{\\omega} = [0, 0, 0]^{\\top}$ radians per second, $\\Delta t = 0.05$ seconds, $N = 50$.\n- Test D: $\\mathbf{q}_0 = [1, 0, 0, 0]^{\\top}$, $\\boldsymbol{\\omega} = [1000, 0, 0]^{\\top}$ radians per second, $\\Delta t = 0.001$ seconds, $N = 100$.\n- Test E: $\\mathbf{q}_0$ from axis-angle with axis proportional to $[3, -1, 2]^{\\top}$ normalized to unit length and angle $\\theta = 2.2$ radians; $\\boldsymbol{\\omega} = [3, 4, 5]^{\\top}$ radians per second, $\\Delta t = 0.005$ seconds, $N = 2000$.\n\nYour program must:\n\n- Implement the quaternion midpoint update exactly as implied by the implicit midpoint rule for $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q}$ with constant $\\boldsymbol{\\omega}$ over each step.\n- Implement the direct matrix forward Euler update for $\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}$.\n- Use the scalar-first quaternion convention $\\mathbf{q} = [q_0, q_1, q_2, q_3]^{\\top}$.\n- Construct rotation matrices from quaternions via $\\mathbf{R}(\\mathbf{q}) = (q_0^2 - \\lVert \\mathbf{v} \\rVert_2^2) \\mathbf{I} + 2 \\mathbf{v}\\mathbf{v}^{\\top} + 2 q_0 [\\mathbf{v}]_{\\times}$ with $\\mathbf{v} = [q_1, q_2, q_3]^{\\top}$.\n- For each test case, produce a two-element list $[e_q, e_R]$ rounded to $10$ decimal places.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a two-element list with no spaces. For example, the output format must be like $[[x_1,y_1],[x_2,y_2],\\dots]$.\n\nNo additional text should be printed. The numeric computations must be self-contained without requiring any user input or external files.",
            "solution": "The problem presented is a well-posed and scientifically grounded exercise in computational rigid body dynamics. It requires the derivation, analysis, and comparison of two numerical integration schemes for the kinematic equations of motion. A thorough validation confirms that the problem is self-contained, consistent, and free of any scientific or logical flaws. We may therefore proceed with a complete solution.\n\nThe motion of a rigid body is described by its orientation in space. This orientation can be represented by a rotation matrix $\\mathbf{R}(t) \\in \\mathrm{SO}(3)$ or a unit quaternion $\\mathbf{q}(t) \\in \\mathbb{R}^4$. The evolution of these quantities is governed by first-order ordinary differential equations (ODEs). Given the body's angular velocity vector $\\boldsymbol{\\omega}(t) \\in \\mathbb{R}^3$, the kinematic equations are:\n\nFor the rotation matrix:\n$$\n\\dot{\\mathbf{R}} = [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R} \\quad (1)\n$$\nwhere $[\\boldsymbol{\\omega}]_{\\times}$ is the $3 \\times 3$ skew-symmetric matrix representing the cross-product operation with $\\boldsymbol{\\omega}$.\n\nFor the unit quaternion, using the scalar-first convention $\\mathbf{q} = [q_0, q_1, q_2, q_3]^{\\top}$:\n$$\n\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{S}(\\boldsymbol{\\omega}) \\mathbf{q} \\quad (2)\n$$\nwhere $\\mathbf{S}(\\boldsymbol{\\omega})$ is the $4 \\times 4$ skew-symmetric matrix:\n$$\n\\mathbf{S}(\\boldsymbol{\\omega}) = \\begin{pmatrix}\n0 & -\\omega_1 & -\\omega_2 & -\\omega_3 \\\\\n\\omega_1 & 0 & -\\omega_3 & \\omega_2 \\\\\n\\omega_2 & \\omega_3 & 0 & -\\omega_1 \\\\\n\\omega_3 & -\\omega_2 & \\omega_1 & 0\n\\end{pmatrix}\n$$\nThe problem requires an analysis of two discrete time-stepping schemes for these equations.\n\n### 1. Analysis of the Quaternion Midpoint Scheme\n\nThe first scheme is the implicit midpoint rule applied to the quaternion kinematic equation, Eq. ($2$). Let $\\mathbf{A} = \\frac{1}{2}\\mathbf{S}(\\boldsymbol{\\omega})$. Since $\\boldsymbol{\\omega}$ is constant over the time step $\\Delta t$, $\\mathbf{A}$ is a constant matrix. The ODE is a linear system $\\dot{\\mathbf{q}} = \\mathbf{A}\\mathbf{q}$.\n\nThe implicit midpoint rule for an ODE $\\dot{\\mathbf{y}} = f(t, \\mathbf{y})$ is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f\\left(t_n + \\frac{\\Delta t}{2}, \\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right)\n$$\nApplying this to our linear system $\\dot{\\mathbf{q}} = \\mathbf{A}\\mathbf{q}$, we have:\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{A} \\left(\\frac{\\mathbf{q}_n + \\mathbf{q}_{n+1}}{2}\\right)\n$$\nWe must now solve for $\\mathbf{q}_{n+1}$:\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_{n+1}\n$$\n$$\n\\mathbf{q}_{n+1} - \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_{n+1} = \\mathbf{q}_n + \\frac{\\Delta t}{2} \\mathbf{A} \\mathbf{q}_n\n$$\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{q}_{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right) \\mathbf{q}_n\n$$\nThis yields the explicit update rule $\\mathbf{q}_{n+1} = \\mathbf{C} \\mathbf{q}_n$, where the update matrix $\\mathbf{C}$ is:\n$$\n\\mathbf{C} = \\left(\\mathbf{I} - \\frac{\\Delta t}{2} \\mathbf{A}\\right)^{-1} \\left(\\mathbf{I} + \\frac{\\Delta t}{2} \\mathbf{A}\\right)\n$$\nThis expression is known as the Cayley transform of the matrix $\\frac{\\Delta t}{2}\\mathbf{A}$.\n\nNext, we analyze whether this scheme preserves the unit norm of the quaternion. A property of the continuous dynamics is that if $\\lVert \\mathbf{q}(0) \\rVert_2 = 1$, then $\\lVert \\mathbf{q}(t) \\rVert_2 = 1$ for all $t > 0$. This is because the generator matrix $\\mathbf{A}$ is skew-symmetric ($\\mathbf{A}^\\top = -\\mathbf{A}$), which implies $\\frac{d}{dt}(\\mathbf{q}^\\top\\mathbf{q}) = \\dot{\\mathbf{q}}^\\top\\mathbf{q} + \\mathbf{q}^\\top\\dot{\\mathbf{q}} = (\\mathbf{A}\\mathbf{q})^\\top\\mathbf{q} + \\mathbf{q}^\\top(\\mathbf{A}\\mathbf{q}) = \\mathbf{q}^\\top\\mathbf{A}^\\top\\mathbf{q} + \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top(-\\mathbf{A})\\mathbf{q} + \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = 0$.\n\nA numerical scheme that preserves this property is called a geometric integrator. For the midpoint scheme, norm preservation is equivalent to the update matrix $\\mathbf{C}$ being orthogonal, i.e., $\\mathbf{C}^\\top\\mathbf{C} = \\mathbf{I}$. Let $\\mathbf{B} = \\frac{\\Delta t}{2}\\mathbf{A}$. Since $\\mathbf{A}$ is skew-symmetric, $\\mathbf{B}$ is also skew-symmetric ($\\mathbf{B}^\\top = -\\mathbf{B}$).\nWe have $\\mathbf{C} = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})$. The transpose is:\n$$\n\\mathbf{C}^\\top = \\left((\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right)^\\top = (\\mathbf{I} + \\mathbf{B})^\\top \\left((\\mathbf{I} - \\mathbf{B})^{-1}\\right)^\\top = (\\mathbf{I} + \\mathbf{B}^\\top) (\\mathbf{I} - \\mathbf{B}^\\top)^{-1}\n$$\nSubstituting $\\mathbf{B}^\\top = -\\mathbf{B}$:\n$$\n\\mathbf{C}^\\top = (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\n$$\nNow, we compute $\\mathbf{C}^\\top\\mathbf{C}$:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = \\left[(\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\\right] \\left[(\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right]\n$$\nThe matrices $(\\mathbf{I} + \\mathbf{B})^{-1}$ and $(\\mathbf{I} - \\mathbf{B})$ commute. This can be shown as $(\\mathbf{I} - \\mathbf{B})(\\mathbf{I} + \\mathbf{B})^{-1} = (\\mathbf{I} + \\mathbf{B} - 2\\mathbf{B})(\\mathbf{I} + \\mathbf{B})^{-1} = \\mathbf{I} - 2\\mathbf{B}(\\mathbf{I} + \\mathbf{B})^{-1}$, and $(\\mathbf{I} + \\mathbf{B})^{-1}(\\mathbf{I} - \\mathbf{B}) = (\\mathbf{I} + \\mathbf{B})^{-1}(\\mathbf{I} + \\mathbf{B} - 2\\mathbf{B}) = \\mathbf{I} - 2(\\mathbf{I} + \\mathbf{B})^{-1}\\mathbf{B}$. Since $\\mathbf{B}$ and $(\\mathbf{I} + \\mathbf{B})^{-1}$ commute, these expressions are equal.\nTherefore, we can rearrange the product:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = (\\mathbf{I} - \\mathbf{B}) \\left[(\\mathbf{I} + \\mathbf{B})^{-1} (\\mathbf{I} - \\mathbf{B})^{-1}\\right] (\\mathbf{I} + \\mathbf{B})\n$$\nUsing the property $(\\mathbf{M}\\mathbf{N})^{-1} = \\mathbf{N}^{-1}\\mathbf{M}^{-1}$:\n$$\n\\mathbf{C}^\\top\\mathbf{C} = (\\mathbf{I} - \\mathbf{B}) \\left[(\\mathbf{I} - \\mathbf{B})(\\mathbf{I} + \\mathbf{B})\\right]^{-1} (\\mathbf{I} + \\mathbf{B}) = (\\mathbf{I} - \\mathbf{B}) [\\mathbf{I} - \\mathbf{B}^2]^{-1} (\\mathbf{I} + \\mathbf{B})\n$$\nThis path is complicated. A more direct proof is to show that $\\mathbf{C} \\mathbf{C}^\\top = \\mathbf{I}$:\n$$\n\\mathbf{C}\\mathbf{C}^\\top = \\left[(\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B})\\right] \\left[(\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\\right] = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} + \\mathbf{B}) (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1}\n$$\nSince $(\\mathbf{I}+\\mathbf{B})$ and $(\\mathbf{I}-\\mathbf{B})$ commute, the inner terms can be swapped:\n$$\n\\mathbf{C}\\mathbf{C}^\\top = (\\mathbf{I} - \\mathbf{B})^{-1} (\\mathbf{I} - \\mathbf{B}) (\\mathbf{I} + \\mathbf{B}) (\\mathbf{I} + \\mathbf{B})^{-1} = \\mathbf{I} \\cdot \\mathbf{I} = \\mathbf{I}\n$$\nThus, the update matrix $\\mathbf{C}$ is orthogonal. This guarantees that the norm of the quaternion is exactly preserved at each step:\n$$\n\\lVert \\mathbf{q}_{n+1} \\rVert_2^2 = \\mathbf{q}_{n+1}^\\top \\mathbf{q}_{n+1} = (\\mathbf{C}\\mathbf{q}_n)^\\top (\\mathbf{C}\\mathbf{q}_n) = \\mathbf{q}_n^\\top \\mathbf{C}^\\top \\mathbf{C} \\mathbf{q}_n = \\mathbf{q}_n^\\top \\mathbf{I} \\mathbf{q}_n = \\lVert \\mathbf{q}_n \\rVert_2^2\n$$\nThe quaternion unit-norm deviation $e_q = \\lvert \\lVert \\mathbf{q}_N \\rVert_2 - 1 \\rvert$ is therefore theoretically zero. Any observed deviation will be due solely to floating-point representation and arithmetic errors, which are expected to be on the order of machine precision.\n\n### 2. Analysis of the Matrix Forward Euler Scheme\n\nThe second scheme is the direct forward Euler update applied to Eq. ($1$):\n$$\n\\mathbf{R}_{n+1} = \\mathbf{R}_n + \\Delta t \\, \\dot{\\mathbf{R}}_n = \\mathbf{R}_n + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times} \\mathbf{R}_n = (\\mathbf{I} + \\Delta t \\, [\\boldsymbol{\\omega}]_{\\times}) \\mathbf{R}_n\n$$\nLet the update matrix be $\\mathbf{U} = \\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times}$. We analyze if this scheme preserves the orthogonality of the rotation matrix $\\mathbf{R}$. Assuming $\\mathbf{R}_n$ is orthogonal ($\\mathbf{R}_n^\\top\\mathbf{R}_n = \\mathbf{I}$), we check if $\\mathbf{R}_{n+1}$ is orthogonal.\n$$\n\\mathbf{R}_{n+1}^\\top \\mathbf{R}_{n+1} = \\left(\\mathbf{U} \\mathbf{R}_n\\right)^\\top \\left(\\mathbf{U} \\mathbf{R}_n\\right) = \\mathbf{R}_n^\\top \\mathbf{U}^\\top \\mathbf{U} \\mathbf{R}_n\n$$\nSince $\\mathbf{R}_n$ is orthogonal, for $\\mathbf{R}_{n+1}$ to be orthogonal, $\\mathbf{U}$ must be orthogonal, i.e., $\\mathbf{U}^\\top\\mathbf{U} = \\mathbf{I}$.\nThe matrix $[\\boldsymbol{\\omega}]_{\\times}$ is skew-symmetric, so $[\\boldsymbol{\\omega}]_{\\times}^\\top = -[\\boldsymbol{\\omega}]_{\\times}$. The transpose of $\\mathbf{U}$ is:\n$$\n\\mathbf{U}^\\top = (\\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times})^\\top = \\mathbf{I} - \\Delta t [\\boldsymbol{\\omega}]_{\\times}\n$$\nNow we compute $\\mathbf{U}^\\top\\mathbf{U}$:\n$$\n\\mathbf{U}^\\top\\mathbf{U} = (\\mathbf{I} - \\Delta t [\\boldsymbol{\\omega}]_{\\times}) (\\mathbf{I} + \\Delta t [\\boldsymbol{\\omega}]_{\\times}) = \\mathbf{I} - (\\Delta t)^2 [\\boldsymbol{\\omega}]_{\\times}^2\n$$\nThis quantity is not equal to $\\mathbf{I}$ unless $\\Delta t = 0$ or $\\boldsymbol{\\omega} = \\mathbf{0}$. Therefore, the forward Euler scheme does not preserve orthogonality. The matrix $\\mathbf{R}_n$ will progressively lose its orthogonality.\n\nThe orthogonality error after one step, starting from an orthogonal $\\mathbf{R}_n$, is:\n$$\n\\mathbf{R}_{n+1}^\\top\\mathbf{R}_{n+1} - \\mathbf{I} = \\mathbf{R}_n^\\top \\mathbf{U}^\\top\\mathbf{U} \\mathbf{R}_n - \\mathbf{R}_n^\\top\\mathbf{I}\\mathbf{R}_n = \\mathbf{R}_n^\\top (\\mathbf{U}^\\top\\mathbf{U} - \\mathbf{I}) \\mathbf{R}_n = -(\\Delta t)^2 \\mathbf{R}_n^\\top [\\boldsymbol{\\omega}]_{\\times}^2 \\mathbf{R}_n\n$$\nThe error matrix after one step is of order $(\\Delta t)^2$. Over $N$ steps, these errors accumulate. The total time of integration is $T = N\\Delta t$. The final error is expected to be proportional to $N(\\Delta t)^2 = (N\\Delta t)\\Delta t = T\\Delta t$. This first-order global error in orthogonality is a significant drawback of this simple scheme. The matrix orthogonality deviation $e_R = \\lVert \\mathbf{R}_N^{\\top} \\mathbf{R}_N - \\mathbf{I} \\rVert_F$ will therefore grow significantly with simulation time and step size, unlike the quaternion scheme where the error remains near machine precision.\n\n### 3. Numerical Implementation Strategy\n\nThe numerical evaluation proceeds by implementing both schemes and applying them to the specified test cases. Key components of the implementation are:\n- A function to convert an axis-angle representation to a scalar-first unit quaternion.\n- A function to convert a scalar-first quaternion to a $3 \\times 3$ rotation matrix using the provided formula.\n- For each test case:\n    1. Initialize $\\mathbf{q}_0$ and compute the corresponding $\\mathbf{R}_0$.\n    2. Pre-compute the constant update matrices for both schemes: $\\mathbf{C}$ for the quaternion midpoint method and $\\mathbf{U}$ for the matrix forward Euler method. This is efficient as $\\boldsymbol{\\omega}$ is constant.\n    3. Loop $N$ times, applying the respective update rules: $\\mathbf{q}_{n+1} = \\mathbf{C}\\mathbf{q}_n$ and $\\mathbf{R}_{n+1} = \\mathbf{U}\\mathbf{R}_n$.\n    4. After the loop, compute the final error metrics $e_q$ and $e_R$.\n    5. Store the results, rounded to $10$ decimal places as required.\n- Finally, format the collected results into the specified string format. This systematic approach will concretely demonstrate the analytical findings.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are required or permitted.\n\ndef skew(v):\n    \"\"\"\n    Constructs the 3x3 skew-symmetric matrix for a 3-vector v.\n    [v]_x\n    \"\"\"\n    return np.array([\n        [0, -v[2], v[1]],\n        [v[2], 0, -v[0]],\n        [-v[1], v[0], 0]\n    ])\n\ndef S_omega(omega):\n    \"\"\"\n    Constructs the 4x4 skew-symmetric matrix S(omega) for scalar-first\n    quaternion kinematics.\n    \"\"\"\n    w1, w2, w3 = omega\n    return np.array([\n        [0, -w1, -w2, -w3],\n        [w1, 0, -w3, w2],\n        [w2, w3, 0, -w1],\n        [w3, -w2, w1, 0]\n    ])\n\ndef q_to_R(q):\n    \"\"\"\n    Converts a scalar-first quaternion q = [q0, q1, q2, q3] to a 3x3\n    rotation matrix R.\n    \"\"\"\n    q0, q1, q2, q3 = q\n    v = np.array([q1, q2, q3])\n    # The formula is R = (q0^2 - ||v||^2)I + 2vv^T + 2q0[v]_x\n    # For a unit quaternion, q0^2 + ||v||^2 = 1, so q0^2 - ||v||^2 = 2q0^2 - 1.\n    R = (q0**2 - np.dot(v, v)) * np.identity(3) + 2 * np.outer(v, v) + 2 * q0 * skew(v)\n    return R\n\ndef aa_to_q(axis, angle):\n    \"\"\"\n    Converts an axis-angle representation to a scalar-first unit quaternion.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    norm = np.linalg.norm(axis)\n    if norm < 1e-12:\n        return np.array([1.0, 0.0, 0.0, 0.0])\n    axis = axis / norm\n    \n    theta_half = angle / 2.0\n    q0 = np.cos(theta_half)\n    v = axis * np.sin(theta_half)\n    return np.array([q0, v[0], v[1], v[2]])\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute error metrics.\n    \"\"\"\n    test_cases = [\n        # Test A: Typical case\n        {'q0_params': [1.0, 0.0, 0.0, 0.0], 'omega': [0.2, -0.1, 0.05], 'dt': 0.01, 'N': 1000},\n        # Test B: Stress case (high ang. vel. briefly)\n        {'q0_params': (([1, 1, 1], 1.7)), 'omega': [50, 0, 25], 'dt': 0.02, 'N': 10},\n        # Test C: Boundary case (zero ang. vel.)\n        {'q0_params': (([0, 1, 0], 0.3)), 'omega': [0, 0, 0], 'dt': 0.05, 'N': 50},\n        # Test D: Stress case (extreme ang. vel.)\n        {'q0_params': [1.0, 0.0, 0.0, 0.0], 'omega': [1000, 0, 0], 'dt': 0.001, 'N': 100},\n        # Test E: Long-horizon accumulation\n        {'q0_params': (([3, -1, 2], 2.2)), 'omega': [3, 4, 5], 'dt': 0.005, 'N': 2000}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        q0_params = case['q0_params']\n        omega = np.array(case['omega'], dtype=float)\n        dt = case['dt']\n        N = case['N']\n\n        # --- Initial Conditions ---\n        if isinstance(q0_params, list):\n            q0 = np.array(q0_params, dtype=float)\n        else:  # Tuple (axis, angle)\n            axis, angle = q0_params\n            q0 = aa_to_q(axis, angle)\n        \n        R0 = q_to_R(q0)\n\n        # --- Quaternion Midpoint Integration ---\n        q = q0.copy()\n        A = 0.5 * S_omega(omega)\n        Id4 = np.identity(4)\n        # Pre-compute update matrix C = (I - dt/2 * A)^-1 * (I + dt/2 * A)\n        C = np.linalg.inv(Id4 - (dt / 2.0) * A) @ (Id4 + (dt / 2.0) * A)\n        \n        for _ in range(N):\n            q = C @ q\n        \n        q_N = q\n        # Compute quaternion unit-norm deviation\n        e_q = np.abs(np.linalg.norm(q_N) - 1.0)\n\n        # --- Matrix Forward Euler Integration ---\n        R = R0.copy()\n        Id3 = np.identity(3)\n        omega_cross = skew(omega)\n        # Pre-compute update matrix U = I + dt * [omega]_x\n        U = Id3 + dt * omega_cross\n\n        for _ in range(N):\n            R = U @ R\n            \n        R_N = R\n        # Compute matrix orthogonality deviation\n        e_R = np.linalg.norm(R_N.T @ R_N - Id3, 'fro')\n\n        results.append([e_q, e_R])\n\n    # --- Final Output Formatting ---\n    # The output format must be exactly [[e_q1,e_R1],[e_q2,e_R2],...]\n    # Using f-string formatting handles rounding to 10 decimal places.\n    result_strings = [f\"[{res[0]:.10f},{res[1]:.10f}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}