{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的计算模型之前，确保我们的基础数值工具可靠是至关重要的。本练习将指导您通过代码来验证基本的张量恒等式，并将它们视为单元测试，以检测在行列式计算中与矩阵转置或主元选择相关的潜在错误 。通过实现和测试这些恒等式，您将更深刻地体会到抽象理论与稳健软件实现之间的联系。",
            "id": "3605426",
            "problem": "在计算固体力学中，考虑变形梯度张量 $F \\in \\mathbb{R}^{3 \\times 3}$，其中雅可比行列式 $J = \\det(F)$ 用于量化局部体积变化。为稳健地进行 $\\det(F)$ 的数值计算，必须在下-上 (LU) 分解中考虑主元选择，以避免因行置換引起的符号错误。伴随（或称代数余子式）张量 $\\mathrm{cof}(F)$ 以及转置/逆矩阵恒等式提供了原则性的单元测试，用于检测实现中的缺陷，尤其是与错误转置相关的缺陷。\n\n从适用于张量的基本线性代数定义和事实出发：\n- 转置 $F^T$ 定义为 $(F^T)_{ij} = F_{ji}$。\n- 可逆张量 $F$ 的逆 $F^{-1}$ 满足 $F F^{-1} = F^{-1} F = I$，其中 $I$ 是单位张量。\n- 对于所有可逆的 $F$，逆转置恒等式成立：$F^{-T} = (F^{-1})^T$。\n- 伴随（代数余子式）张量 $\\mathrm{cof}(F)$ 是带符号的余子式矩阵，对于可逆的 $F$，它满足 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$。\n- 克莱姆法则（Cramer's rule）意味着对于所有 $F \\in \\mathbb{R}^{n \\times n}$（包括奇异矩阵），都有 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$。\n- 带部分主元选择的 LU 分解得到 $P F = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵，这意味着 $\\det(F) = \\det(P)\\, \\det(U)$，因为 $\\det(L) = 1$。\n\n您的任务是编写一个程序，对每个给定的 $3 \\times 3$ 测试张量 $F$ 执行以下操作：\n1. 使用通用的后端调用（库函数行列式）计算 $\\det(F)$。\n2. 通过恒等式 $\\det(F) = \\det(P)\\, \\prod_i U_{ii}$，使用带部分主元选择的 LU 分解计算 $\\det(F)$，其中 $P F = L U$，$U_{ii}$ 是 $U$ 的对角线元素。\n3. 根据其作为带符号余子式矩阵的定义计算 $\\mathrm{cof}(F)$，然后使用从克莱姆法则导出的迹恒等式再次计算 $\\det(F)$：$\\det(F) = \\frac{1}{3}\\, \\mathrm{tr}\\left(F\\, \\mathrm{cof}(F)^T\\right)$。\n4. 仅对可逆的 $F$ 验证逆转置恒等式 $F^{-T} = (F^{-1})^T$（对于奇异矩阵，跳过或标记为假）。\n5. 仅对可逆的 $F$ 验证伴随矩阵恒等式 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$。\n6. 对所有 $F$ 验证克莱姆法则恒等式 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$。\n7. 比较三种行列式计算方法的结果，以检查可能由主元选择和舍入误差引起的任何差异。\n\n在矩阵相等性检查中，相对比较使用 $\\varepsilon = 10^{-11}$ 的容差，绝对比较使用 $\\delta = 10^{-12}$ 的容差（即，如果 $\\|A-B\\|_{\\infty} \\le \\delta + \\varepsilon \\|B\\|_{\\infty}$，则认为矩阵 $A$ 和 $B$ 相等）。\n\n测试套件（五个 $3 \\times 3$ 张量）：\n- 通用非奇异张量（正常情况）：\n$$\nF_1 = \\begin{bmatrix}\n1.2  &-0.3  &0.5 \\\\\n0.4  &2.1  &-1.0 \\\\\n-0.8  &0.7  &1.5\n\\end{bmatrix}\n$$\n- 对称正定张量：\n$$\nF_2 = \\begin{bmatrix}\n2  &-1  &0 \\\\\n-1  &2  &-1 \\\\\n0  &-1  &2\n\\end{bmatrix}\n$$\n- 通过将 $F_2$ 左乘 $D = \\mathrm{diag}(-1,1,1)$ 构造的负行列式张量：\n$$\nF_3 = D F_2 = \\begin{bmatrix}\n-2  &1  &0 \\\\\n-1  &2  &-1 \\\\\n0  &-1  &2\n\\end{bmatrix}\n$$\n- 近奇异张量（边界条件）：\n$$\nF_4 = \\begin{bmatrix}\n1  &1  &1 \\\\\n1 + 10^{-8}  &1 + 10^{-8}  &1 + 10^{-8} \\\\\n1  &2  &3\n\\end{bmatrix}\n$$\n- 奇异张量（精确秩亏）：\n$$\nF_5 = \\begin{bmatrix}\n1  &2  &3 \\\\\n2  &4  &6 \\\\\n0  &0  &1\n\\end{bmatrix}\n$$\n\n最终输出格式：\n对于每个测试用例 $F_k$，生成一个包含六个条目的列表，顺序严格如下：\n$[\\det_{\\mathrm{lib}}, \\det_{\\mathrm{pivot}}, \\det_{\\mathrm{trace}}, \\text{invT\\_ok}, \\text{cof\\_adj\\_ok}, \\text{cramer\\_ok}]$，其中：\n- $\\det_{\\mathrm{lib}}$ 是来自后端调用的行列式，\n- $\\det_{\\mathrm{pivot}}$ 是来自带主元选择的 LU 分解的行列式，\n- $\\det_{\\mathrm{trace}}$ 是来自迹恒等式的行列式，\n- $\\text{invT\\_ok}$ 是关于 $F^{-T} = (F^{-1})^T$ 的布尔值（仅对可逆 $F$；否则为假），\n- $\\text{cof\\_adj\\_ok}$ 是关于 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$ 的布尔值（仅对可逆 $F$；否则为假），\n- $\\text{cramer\\_ok}$ 是关于 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$ 的布尔值（对所有 $F$）。\n\n您的程序应生成一行输出，其中包含一个由五个案例结果组成的列表，以逗号分隔，并用方括号括起来，每个案例本身都以上述顺序表示为一个列表。例如：\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$。\n此计算不涉及物理单位。也不涉及角度。\n\n目标是使用这些恒等式作为原则性的单元测试，以捕捉转置错误，并检查因主元选择和数值舍入在计算 $\\det(F)$ 时产生的差异。",
            "solution": "我们从适用于变形梯度张量的线性代数基础和恒等式出发。对于 $F \\in \\mathbb{R}^{3 \\times 3}$，$\\det(F)$ 可以通过几种一致的方法获得；这些方法结果的不匹配揭示了数值或实现上的缺陷。\n\n通过分解法并使用主元选择计算行列式：在带部分主元选择的下-上 (LU) 分解中，我们得到 $P F = L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵（对角线元素等于 $1$），$U$ 是上三角矩阵。取行列式，\n$$\n\\det(P)\\, \\det(F) = \\det(L)\\, \\det(U) \\quad \\Rightarrow \\quad \\det(F) = \\det(P)\\, \\det(U),\n$$\n因为 $\\det(L) = 1$。该表达式明确显示了主元选择的影响：行置换会产生一个符号因子 $\\det(P) \\in \\{-1, +1\\}$，必须将其考虑在内，以避免 $\\det(F)$ 中出现符号错误。\n\n伴随矩阵和克莱姆法则恒等式：伴随（代数余子式）矩阵 $\\mathrm{cof}(F)$ 定义为带符号的余子式矩阵：\n$$\n\\mathrm{cof}(F)_{ij} = (-1)^{i+j} \\det(M_{ij}),\n$$\n其中 $M_{ij}$ 是通过删除第 $i$ 行和第 $j$ 列得到的余子式。克莱姆法则得出了一个对所有方阵（包括奇异矩阵）都有效的恒等式：\n$$\nF\\, \\mathrm{cof}(F)^T = \\det(F)\\, I.\n$$\n对于 $3 \\times 3$ 矩阵，对两边取迹可得\n$$\n\\mathrm{tr}\\!\\left(F\\, \\mathrm{cof}(F)^T\\right) = \\det(F)\\, \\mathrm{tr}(I) = 3\\, \\det(F),\n$$\n这导出了基于迹的行列式计算公式\n$$\n\\det(F) = \\frac{1}{3}\\, \\mathrm{tr}\\!\\left(F\\, \\mathrm{cof}(F)^T\\right).\n$$\n该公式仅依赖于伴随矩阵的定义并避免了求逆运算，使其在 $F$ 是奇异矩阵时依然稳健。\n\n逆转置恒等式和伴随矩阵-行列式恒等式：对于可逆的 $F$，逆转置恒等式\n$$\nF^{-T} = (F^{-1})^T\n$$\n可立即从 $F F^{-1} = I$ 和矩阵转置的性质得出。此外，经典的伴随矩阵恒等式\n$$\n\\mathrm{cof}(F) = \\det(F)\\, F^{-T}\n$$\n对可逆的 $F$ 成立，并且等价于 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$。\n\n数值验证策略和容差：我们采用相对容差 $\\varepsilon = 10^{-11}$ 和绝对容差 $\\delta = 10^{-12}$ 进行相等性检查。对于矩阵相等性 $A = B$，我们测试\n$$\n\\|A - B\\|_{\\infty} \\le \\delta + \\varepsilon \\, \\|B\\|_{\\infty},\n$$\n其中 $\\|\\cdot\\|_{\\infty}$ 是最大绝对值元素范数。在代码中，我们使用类似 `allclose` 的检查和这些容差。\n\n每个测试用例 $F$ 的算法计划：\n1. 通过标准的后端调用计算行列式 $\\det_{\\mathrm{lib}}$。\n2. 通过计算 $\\det(P)$ 和 $\\prod_i U_{ii}$，从带主元选择的 LU 分解中计算 $\\det_{\\mathrm{pivot}}$。\n3. 使用显式的 $3 \\times 3$ 带符号余子式计算 $\\mathrm{cof}(F)$，然后得到 $\\det_{\\mathrm{trace}} = \\frac{1}{3}\\, \\mathrm{tr}(F\\, \\mathrm{cof}(F)^T)$。\n4. 通过秩来判断可逆性：如果 $\\mathrm{rank}(F) = 3$，则继续；否则视为不可逆。\n5. 如果可逆，通过分别计算 $(F^{-1})^T$ 和 $(F^T)^{-1}$ 并使用容差检查相等性来验证 $F^{-T} = (F^{-1})^T$。\n6. 如果可逆，验证 $\\mathrm{cof}(F) = \\det_{\\mathrm{lib}}\\, F^{-T}$。\n7. 对所有 $F$，验证 $F\\, \\mathrm{cof}(F)^T = \\det_{\\mathrm{lib}}\\, I$。\n8. 记录元组 $[\\det_{\\mathrm{lib}}, \\det_{\\mathrm{pivot}}, \\det_{\\mathrm{trace}}, \\text{invT\\_ok}, \\text{cof\\_adj\\_ok}, \\text{cramer\\_ok}]$。\n\n边界情况的覆盖：\n- 通用非奇异情况测试了各种方法之间的一致性。\n- 对称正定情况检查了当 $F = F^T$（转置对称）时的行为。\n- 负行列式情况突出了方向反转的影响，确保主元选择中的符号处理是正确的。\n- 近奇异情况检验了数值稳定性（舍入和条件数）。\n- 奇异情况避免了求逆，并测试了仍然有效的克莱姆法则恒等式。\n\n最终输出将五个案例的结果汇总到一个顶层列表中，并作为单行打印。行列式计算之间的任何差异都源于主元选择的符号处理和数值舍入；基于 $F^{-T} = (F^{-1})^T$ 和 $\\mathrm{cof}(F) = \\det(F)\\, F^{-T}$ 的单元测试直接暴露与转置相关的实现错误和伴随矩阵的误用，而 $F\\, \\mathrm{cof}(F)^T = \\det(F)\\, I$ 则提供了一个即使在 $F$ 是奇异矩阵时也稳健的检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu\nimport json\n\ndef det_pivoting(A: np.ndarray) -> float:\n    \"\"\"\n    Compute det(A) using LU factorization with partial pivoting.\n    Given P @ A = L @ U, with L unit lower triangular, det(A) = det(P) * det(U).\n    \"\"\"\n    P, L, U = lu(A)\n    # det(P) is +/-1 for a permutation matrix; compute robustly\n    detP = np.linalg.det(P)\n    # Round to nearest integer to avoid tiny floating error\n    signP = int(np.round(detP))\n    detU = float(np.prod(np.diag(U)))\n    return signP * detU\n\ndef cofactor_3x3(A: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute the cofactor (adjugate) matrix of a 3x3 matrix A via signed minors.\n    \"\"\"\n    a = A\n    cof = np.empty((3, 3), dtype=float)\n    # Row 0\n    cof[0,0] = a[1,1]*a[2,2] - a[1,2]*a[2,1]\n    cof[0,1] = -(a[1,0]*a[2,2] - a[1,2]*a[2,0])\n    cof[0,2] = a[1,0]*a[2,1] - a[1,1]*a[2,0]\n    # Row 1\n    cof[1,0] = -(a[0,1]*a[2,2] - a[0,2]*a[2,1])\n    cof[1,1] = a[0,0]*a[2,2] - a[0,2]*a[2,0]\n    cof[1,2] = -(a[0,0]*a[2,1] - a[0,1]*a[2,0])\n    # Row 2\n    cof[2,0] = a[0,1]*a[1,2] - a[0,2]*a[1,1]\n    cof[2,1] = -(a[0,0]*a[1,2] - a[0,2]*a[1,0])\n    cof[2,2] = a[0,0]*a[1,1] - a[0,1]*a[1,0]\n    return cof\n\ndef det_trace_from_cof(A: np.ndarray, cofA: np.ndarray) -> float:\n    \"\"\"\n    Compute det(A) via the trace identity det(A) = (1/3) * tr(A @ cof(A).T) for 3x3.\n    \"\"\"\n    return float(np.trace(A @ cofA.T) / 3.0)\n\ndef is_invertible(A: np.ndarray) -> bool:\n    \"\"\"\n    Determine invertibility by rank for 3x3: rank == 3 => invertible.\n    \"\"\"\n    r = np.linalg.matrix_rank(A)\n    return r == 3\n\ndef allclose_inf_norm(A: np.ndarray, B: np.ndarray, rtol: float, atol: float) -> bool:\n    \"\"\"\n    Check max-norm closeness: ||A-B||_inf = atol + rtol * ||B||_inf\n    \"\"\"\n    diff = np.max(np.abs(A - B))\n    normB = np.max(np.abs(B))\n    return diff = (atol + rtol * normB)\n\ndef make_test_cases():\n    # F1: general non-singular\n    F1 = np.array([\n        [1.2, -0.3, 0.5],\n        [0.4,  2.1, -1.0],\n        [-0.8, 0.7, 1.5]\n    ], dtype=float)\n\n    # F2: symmetric positive definite\n    F2 = np.array([\n        [ 2.0, -1.0,  0.0],\n        [-1.0,  2.0, -1.0],\n        [ 0.0, -1.0,  2.0]\n    ], dtype=float)\n\n    # F3: negative determinant via left-multiplication by diag(-1,1,1)\n    D = np.diag([-1.0, 1.0, 1.0])\n    F3 = D @ F2\n\n    # F4: nearly singular\n    eps = 1e-8\n    F4 = np.array([\n        [1.0, 1.0, 1.0],\n        [1.0 + eps, 1.0 + eps, 1.0 + eps],\n        [1.0, 2.0, 3.0]\n    ], dtype=float)\n\n    # F5: singular (second row is 2x first row)\n    F5 = np.array([\n        [1.0, 2.0, 3.0],\n        [2.0, 4.0, 6.0],\n        [0.0, 0.0, 1.0]\n    ], dtype=float)\n\n    return [F1, F2, F3, F4, F5]\n\ndef solve():\n    rtol = 1e-11\n    atol = 1e-12\n\n    test_cases = make_test_cases()\n    results = []\n\n    for F in test_cases:\n        # Determinants\n        det_lib = float(np.linalg.det(F))\n        det_piv = det_pivoting(F)\n        cofF = cofactor_3x3(F)\n        det_trace = det_trace_from_cof(F, cofF)\n\n        # Invertibility check\n        invertible = is_invertible(F)\n\n        # Identity checks\n        if invertible:\n            invF = np.linalg.inv(F)\n            invT_from_inv = invF.T\n            invT_from_transpose = np.linalg.inv(F.T)\n            invT_ok = allclose_inf_norm(invT_from_inv, invT_from_transpose, rtol, atol)\n\n            # cof(F) = det(F) * F^{-T}\n            cof_adj_rhs = det_lib * invT_from_inv\n            cof_adj_ok = allclose_inf_norm(cofF, cof_adj_rhs, rtol, atol)\n        else:\n            invT_ok = False\n            cof_adj_ok = False\n\n        # Cramer's rule: F @ cof(F).T = det(F) * I for all F\n        lhs = F @ cofF.T\n        rhs = det_lib * np.eye(3)\n        cramer_ok = allclose_inf_norm(lhs, rhs, rtol, atol)\n\n        case_result = [det_lib, det_piv, det_trace, bool(invT_ok), bool(cof_adj_ok), bool(cramer_ok)]\n        results.append(case_result)\n\n    # Final print statement in the exact required format: single line, JSON-like brackets, no spaces.\n    print(json.dumps(results, separators=(',',':')))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在固体力学模拟中，检测材料单元何时趋于坍缩（即其体积变化趋近于零）对于数值稳定性和准确性至关重要。本练习挑战您超越简单的行列式计算，利用奇异值分解（SVD）实现一个稳健的近奇异性测试 。您将比较基于SVD和基于LU分解的行列式计算的敏感性，从而揭示为何SVD是诊断变形梯度条件数的更优越工具。",
            "id": "3605400",
            "problem": "在计算固体力学背景下，您将获得表示三维变形梯度的方阵，记为 $F \\in \\mathbb{R}^{3 \\times 3}$。变形梯度映射了微分线元，其雅可比行列式 $J = \\det(F)$ 用于衡量局部体积变化。在物理上允许的变形中，$J$ 是无量纲且严格为正的，但对接近零的值进行稳健的数值检测对于误差控制和网格自适应非常重要。\n\n基本事实：\n- 奇异值分解 (SVD) 将任何实数矩阵分解为 $F = U \\Sigma V^{T}$，其中 $U,V \\in \\mathbb{R}^{3 \\times 3}$ 是正交矩阵（即 $U^{T} U = I$ 和 $V^{T} V = I$），$\\Sigma = \\operatorname{diag}(\\sigma_1,\\sigma_2,\\sigma_3)$ 是由奇异值 $\\sigma_i \\ge 0$ 构成的对角矩阵。正交因子可以编码旋转或反射；$V^{T}$ 中的转置用于对齐主方向。\n- 行列式满足 $\\det(F) = \\det(U)\\,\\det(\\Sigma)\\,\\det(V^{T})$。由于 $\\det(U), \\det(V^{T}) \\in \\{-1,+1\\}$ 且 $\\det(\\Sigma) = \\prod_{i=1}^{3} \\sigma_i$，因此 $\\det(F)$ 的符号由 $\\operatorname{sign}(\\det(U)\\det(V^{T}))$ 给出，而其绝对值 $|\\det(F)| = \\prod_{i=1}^{3} \\sigma_i$。\n- 带主元选择的 LU 分解 (LU) 将 $F$ 分解为 $P F = L U$，其中 $P$ 是一个置换矩阵（元素为 $0$ 和 $1$ 的正交矩阵），$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。行列式为 $\\det(F) = \\det(P) \\det(U)$，因为 $\\det(L)=1$。矩阵 $P$ 体现了行置换；其行列式 $\\det(P) \\in \\{-1,+1\\}$ 等于置换的奇偶性。\n\n您的任务：\n1. 推导并实现一个基于 SVD 的稳健的 $J$ 近零测试，该测试应具备尺度感知能力和数值稳定性。该测试应仅使用 $F$ 的 SVD 分解得到的量，并且必须返回一个布尔值，指示 $|\\det(F)|$ 是否接近于零。该测试必须对正交因子不变，并能抵抗下溢。您必须将测试建立在以下基础上：\n   - 奇异值比率 $r = \\sigma_{\\min}/\\sigma_{\\max}$，通过条件数检测接近奇异的情况，以及\n   - 归一化行列式大小 $D_{\\mathrm{norm}} = \\prod_{i=1}^{3} (\\sigma_i/\\sigma_{\\max})$，用于检测相对于主拉伸的微小体积变化。\n   使用双精度机器精度 $\\varepsilon = \\text{machine epsilon}$。如果 $(r  \\sqrt{\\varepsilon})$ 或 $(D_{\\mathrm{norm}}  \\varepsilon)$，则矩阵 $F$ 应被分类为近零。\n2. 通过 SVD 使用 $\\det(F) = \\det(U)\\,\\det(\\Sigma)\\,\\det(V^{T})$ 计算带符号的 $J$，强调 $V^{T}$ 中转置在恢复正确符号中的作用，并使用 LU 通过 $\\det(F) = \\det(P)\\det(U)$ 计算 $J$。\n3. 比较两种方法（SVD 奇异值乘积与基于 LU 的行列式）在小扰动下的敏感性。对于每个测试用例矩阵 $F$，生成 $K$ 个随机扰动 $\\delta F$，其弗罗贝尼乌斯范数缩放至指定噪声水平 $\\eta$ 乘以 $\\|F\\|_F$，并使用两种方法计算所得 $J$ 的样本标准差。使用固定的随机种子以确保可复现性。\n\n重要的数学和物理要求：\n- 仅使用上述原理和定义。雅可比行列式 $J$ 是无量纲的。输出中不需要物理单位。\n- 角度单位不适用于此问题。\n- 最终计算的指标必须是纯数字：布尔值、整数、浮点数或这些类型的列表。\n\n测试套件：\n对于每个案例，$K=200$ 次扰动，噪声水平 $\\eta$ 如下所示：\n- 案例 1（良态拉伸）：$F = \\operatorname{diag}(1.2,\\,0.9,\\,1.1)$，$\\eta = 10^{-9}$。\n- 案例 2（近奇异且正向）：$F = \\operatorname{diag}(1,\\,1,\\,10^{-8})$，$\\eta = 10^{-12}$。\n- 案例 3（近奇异且方向反转）：$F = R\\,\\operatorname{diag}(1,\\,1,\\,10^{-8})$，其中 $R = \\operatorname{diag}(-1,\\,1,\\,1)$（正交矩阵，$\\det(R)=-1$），$\\eta = 10^{-12}$。\n- 案例 4（病态剪切）：\n$$\nF = \\begin{bmatrix}\n1  1000  0 \\\\\n0  10^{-6}  0 \\\\\n0  0  1\n\\end{bmatrix},\\quad \\eta = 10^{-12}.\n$$\n- 案例 5（极端下溢边界）：$F = \\operatorname{diag}(10^{-300},\\,10^{-300},\\,10^{-300})$，$\\eta = 10^{-310}$。\n\n扰动模型：\n- 对于每个案例，抽取具有独立标准正态分布条目的 $\\delta F$，并将其缩放以使 $\\|\\delta F\\|_F = \\eta \\|F\\|_F$。然后评估 $J(F+\\delta F)$。\n\n每个测试用例的必需输出：\n- 一个形式为 $[\\text{near\\_zero},\\,\\text{sign\\_match},\\,\\sigma_{J}^{\\mathrm{SVD}},\\,\\sigma_{J}^{\\mathrm{LU}},\\,\\Delta_{\\mathrm{rel}},\\,J_{\\mathrm{SVD}},\\,J_{\\mathrm{LU}}]$ 的子列表，其中：\n  - $\\text{near\\_zero}$ 是来自任务 1 中稳健测试的布尔值，\n  - $\\text{sign\\_match}$ 是一个布尔值，指示 $\\operatorname{sign}(J_{\\mathrm{SVD}}) = \\operatorname{sign}(J_{\\mathrm{LU}})$ 是否成立（将两者都为零视为匹配），\n  - $\\sigma_{J}^{\\mathrm{SVD}}$ 和 $\\sigma_{J}^{\\mathrm{LU}}$ 分别是 SVD 和 LU 方法在扰动下 $J$ 的样本标准差，\n  - $\\Delta_{\\mathrm{rel}} = \\frac{|J_{\\mathrm{SVD}} - J_{\\mathrm{LU}}|}{\\max(|J_{\\mathrm{SVD}}|,|J_{\\mathrm{LU}}|,10^{-300})}$ 是两种方法得到的基线行列式之间的相对绝对差，\n  - $J_{\\mathrm{SVD}}$ 是从 $U$、$\\Sigma$ 和 $V^{T}$ 计算出的带符号行列式，\n  - $J_{\\mathrm{LU}}$ 是通过 $\\det(P)\\det(U)$ 从 LU 分解得到的行列式。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且本身是如上所述的列表。例如：\n\"[[result_case1],[result_case2],[result_case3],[result_case4],[result_case5]]\"。",
            "solution": "该问题要求对变形梯度张量 $F$ 的行列式进行全面的数值分析，这是计算固体力学中的一个基本量。分析涉及比较两种计算行列式的标准方法，一种基于奇异值分解 (SVD)，另一种基于带主元选择的下上 (LU) 分解。核心任务是实现一个稳健的近奇异性测试，使用两种方法计算行列式，并评估每种方法在小扰动下的数值稳定性。\n\n解决此问题的逻辑流程如下：\n1.  对于每个测试矩阵 $F$，分别使用基于 SVD 和基于 LU 的方法计算其行列式，记为 $J_{\\mathrm{SVD}}$ 和 $J_{\\mathrm{LU}}$。\n2.  基于 $F$ 的奇异值，实现指定的用于判断行列式大小是否“近零”的稳健测试。\n3.  对于每个 $F$，进行蒙特卡洛模拟，生成 $K=200$ 个扰动矩阵 $F' = F + \\delta F$，其中扰动 $\\delta F$ 被缩放到指定的噪声水平 $\\eta$。\n4.  对于每个扰动矩阵 $F'$，使用 SVD 和 LU 两种方法计算其行列式。\n5.  对于两种方法，分别计算从扰动矩阵获得的行列式集合的样本标准差，记为 $\\sigma_{J}^{\\mathrm{SVD}}$ 和 $\\sigma_{J}^{\\mathrm{LU}}$。\n6.  最后，将每个测试用例的所有计算量汇总成指定的输出格式。\n\n所有数学运算都将使用双精度浮点算术执行，机器 epsilon $\\varepsilon$ 取为 `numpy.finfo(float).eps`。\n\n**1. 稳健的近零测试**\n\n问题定义了一个特定的测试，用于在数值稳健的意义上判断矩阵 $F$ 的行列式大小是否“近零”。此测试完全基于 $F$ 的 SVD 分解 $F = U \\Sigma V^{T}$ 所得到的奇异值，其中 $\\Sigma = \\operatorname{diag}(\\sigma_1, \\sigma_2, \\sigma_3)$ 且 $\\sigma_1 \\ge \\sigma_2 \\ge \\sigma_3 \\ge 0$。令 $\\sigma_{\\max} = \\sigma_1$ 且 $\\sigma_{\\min} = \\sigma_3$。\n\n该测试依赖于两个无量纲量：\n- 奇异值比率：$r = \\sigma_{\\min} / \\sigma_{\\max}$。这是矩阵条件数 $\\kappa(F)$ 的倒数。一个小的 $r$ 值表示矩阵是病态的，接近奇异（即其秩亏）。\n- 归一化行列式大小：$D_{\\mathrm{norm}} = \\prod_{i=1}^{3} (\\sigma_i / \\sigma_{\\max})$。该量衡量相对于最大拉伸所定义的立方体的体积变化。它被设计成对均匀缩放和下溢具有稳健性。例如，如果 $F$ 被一个非常小的数 $\\alpha$ 缩放，即 $F \\to \\alpha F$，则 $\\sigma_i \\to \\alpha \\sigma_i$，但 $D_{\\mathrm{norm}}$ 保持不变。\n\n如果矩阵 $F$ 是病态的或表现出显著的相对体积坍缩，则其被分类为具有近零行列式。该条件正式表述为：\n$$\n(\\text{near\\_zero}) \\equiv (r  \\sqrt{\\varepsilon}) \\lor (D_{\\mathrm{norm}}  \\varepsilon)\n$$\n其中 $\\varepsilon$ 是双精度浮点数的机器 epsilon。选择 $\\sqrt{\\varepsilon}$ 作为条件数的阈值是数值分析中一种常见的启发式方法。\n\n**2. 行列式计算方法**\n\n使用两种不同的方法来计算行列式 $J = \\det(F)$。\n\n**a) 基于 SVD 的行列式 ($J_{\\mathrm{SVD}}$)**\n根据 SVD 分解 $F = U \\Sigma V^{T}$，行列式由各因子行列式的乘积给出：\n$$\nJ_{\\mathrm{SVD}} = \\det(F) = \\det(U) \\det(\\Sigma) \\det(V^{T})\n$$\n由于 $U$ 和 $V$ 是正交矩阵，它们的行列式为 $+1$ 或 $-1$。对角矩阵 $\\Sigma$ 的行列式是其对角元素（即奇异值 $\\sigma_i$）的乘积。\n$$\n\\det(\\Sigma) = \\prod_{i=1}^{3} \\sigma_i\n$$\n奇异值的乘积给出了行列式的大小 $|\\det(F)|$，而乘积 $\\det(U)\\det(V^T)$ 提供了其符号。计算以 $J_{\\mathrm{SVD}} = \\det(U) \\cdot (\\prod_{i} \\sigma_i) \\cdot \\det(V^T)$ 的形式执行。直接计算 $\\prod \\sigma_i$ 可能会在奇异值非常小时导致下溢，即使归一化的测试量表现良好。\n\n**b) 基于 LU 的行列式 ($J_{\\mathrm{LU}}$)**\n如问题中所定义的，带部分主元选择的 LU 分解将 $F$ 分解为 $P F = L U$。这里，$P$ 是一个置换矩阵，$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。\n对等式两边取行列式：\n$$\n\\det(P F) = \\det(L U) \\implies \\det(P) \\det(F) = \\det(L) \\det(U)\n$$\n由于 $L$ 是单位三角矩阵，$\\det(L) = 1$。置换矩阵的行列式 $\\det(P)$ 是置换的符号，等于 $(-1)^k$，其中 $k$ 是行交换的次数。这得出：\n$$\n\\det(F) = \\frac{\\det(U)}{\\det(P)}\n$$\n由于 $\\det(P) \\in \\{-1, +1\\}$，我们有 $1/\\det(P) = \\det(P)$。上三角矩阵 $U$ 的行列式是其对角元素的乘积，即 $\\prod_{i} U_{ii}$。因此，\n$$\nJ_{\\mathrm{LU}} = \\det(P) \\prod_{i=1}^{3} U_{ii}\n$$\n`scipy.linalg.lu` 函数产生一个分解 $F=PLU$。为了与问题的 $PF=LU$ 约定对齐，我们可以用 $P^T$ 左乘：$P^T F = P^T(PLU) = (P^T P)LU = ILU = LU$。这意味着问题中的置换矩阵是 $P_{prob} = P_{scipy}^T$，而 $L$ 和 $U$ 因子是相同的。因此，行列式为 $\\det(F) = \\det(P_{prob})\\det(U) = \\det(P_{scipy}^T)\\det(U) = \\det(P_{scipy})\\det(U)$。因此，只要因子使用一致，无论使用哪种约定，公式都保持不变。\n\n**3. 扰动分析**\n\n为了评估每种方法的数值敏感性，我们进行扰动分析。对于每个测试用例 $F$，我们生成 $K=200$ 个随机扰动矩阵 $\\delta F$。每个 $\\delta F$ 首先通过从独立标准正态分布 $\\mathcal{N}(0, 1)$ 中抽取元素来构造一个原始矩阵 $\\delta F_{\\text{raw}}$。然后将该矩阵缩放，以匹配相对于 $F$ 的弗罗贝尼乌斯范数 $\\|F\\|_F = \\sqrt{\\sum_{i,j} F_{ij}^2}$ 的目标噪声水平。\n$$\n\\delta F = \\delta F_{\\text{raw}} \\cdot \\frac{\\eta \\|F\\|_F}{\\|\\delta F_{\\text{raw}}\\|_F}\n$$\n对于 $K$ 个扰动矩阵中的每一个 $F' = F+\\delta F$，我们使用 SVD 和 LU 两种方法计算行列式 $J(F')$。然后为每种方法计算得到的 $K$ 个行列式值的集合的样本标准差 ($\\sigma_J$)。较小的标准差意味着对于小的输入扰动具有更高的数值稳定性。使用固定的随机种子以确保可复现性。\n\n**4. 输出指标**\n\n对于每个测试用例，计算并报告以下七个指标：\n1.  $\\text{near\\_zero}$：来自稳健测试的布尔结果。\n2.  $\\text{sign\\_match}$：一个布尔值，如果 $\\operatorname{sign}(J_{\\mathrm{SVD}}) = \\operatorname{sign}(J_{\\mathrm{LU}})$ 则为 `True`。\n3.  $\\sigma_{J}^{\\mathrm{SVD}}$：SVD 方法在扰动下的行列式样本标准差。\n4.  $\\sigma_{J}^{\\mathrm{LU}}$：LU 方法在扰动下的行列式样本标准差。\n5.  $\\Delta_{\\mathrm{rel}}$：基线（未扰动）行列式之间的相对差异，定义为 $\\frac{|J_{\\mathrm{SVD}} - J_{\\mathrm{LU}}|}{\\max(|J_{\\mathrm{SVD}}|,|J_{\\mathrm{LU}}|,10^{-300})}$。下限值 $10^{-300}$ 防止除以零。\n6.  $J_{\\mathrm{SVD}}$：来自 SVD 方法的基线行列式。\n7.  $J_{\\mathrm{LU}}$：来自 LU 方法的基线行列式。\n\n这项综合分析将突出一系列场景下（包括良态、病态和近下溢情况）每种行列式计算方法的优缺点。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\nimport json\n\ndef solve():\n    \"\"\"\n    解决计算固体力学问题，通过分析各种变形梯度矩阵的行列式。\n    \"\"\"\n\n    # --- 问题参数 ---\n    K = 200  # 扰动次数\n    RANDOM_SEED = 42 # 用于可复现性\n    EPSILON = np.finfo(float).eps # 双精度机器 epsilon\n\n    # --- 测试用例 ---\n    F1 = np.diag([1.2, 0.9, 1.1])\n    F2 = np.diag([1.0, 1.0, 1e-8])\n    R3 = np.diag([-1.0, 1.0, 1.0])\n    F3 = R3 @ np.diag([1.0, 1.0, 1e-8])\n    F4 = np.array([[1.0, 1000.0, 0.0], [0.0, 1e-6, 0.0], [0.0, 0.0, 1.0]])\n    F5 = np.diag([1e-300, 1e-300, 1e-300])\n\n    test_cases = [\n        (F1, 1e-9),\n        (F2, 1e-12),\n        (F3, 1e-12),\n        (F4, 1e-12),\n        (F5, 1e-310),\n    ]\n\n    all_results = []\n\n    def get_det_from_svd(F_matrix):\n        \"\"\"从 SVD 因子计算行列式。\"\"\"\n        try:\n            u, s, vh = np.linalg.svd(F_matrix)\n            det_u = np.linalg.det(u)\n            det_vh = np.linalg.det(vh)\n            # 奇异值的直接乘积可能下溢，这是测试的一部分。\n            det_s = np.prod(s)\n            return det_u * det_s * det_vh\n        except np.linalg.LinAlgError:\n            return 0.0\n\n    def get_det_from_lu(F_matrix):\n        \"\"\"从 LU 因子计算行列式。\"\"\"\n        try:\n            # scipy.linalg.lu 函数返回 P, L, U 使得 F = P @ L @ U。\n            # 问题定义为 PF = LU。这意味着 P_prob = P_scipy.T。\n            # det(F) = det(P_prob)*det(U) = det(P_scipy.T)*det(U) = det(P_scipy)*det(U)。\n            # 所以行列式是 scipy 输出的 det(P)*product(diag(U))。\n            p, l, u = scipy.linalg.lu(F_matrix)\n            det_p = np.linalg.det(p)\n            det_u = np.prod(np.diag(u))\n            return det_p * det_u\n        except (np.linalg.LinAlgError, ValueError):\n            # 如果矩阵对于 LU 是奇异的，可能会引发 ValueError\n            return 0.0\n\n    for F, eta in test_cases:\n        # --- 任务1：稳健的近零测试  任务2：基线行列式 ---\n        u_base, s_base, vh_base = np.linalg.svd(F)\n        \n        # 近零测试\n        s_max = np.max(s_base) if s_base.size > 0 else 0.0\n        s_min = np.min(s_base) if s_base.size > 0 else 0.0\n\n        if s_max > 0:\n            r = s_min / s_max\n            # D_norm 应仔细计算，以避免在除以 s_max 之前发生中间下溢\n            d_norm = np.prod(s_base / s_max)\n        else: # 零矩阵情况\n            r = 0.0\n            d_norm = 0.0\n\n        near_zero = (r  np.sqrt(EPSILON)) or (d_norm  EPSILON)\n\n        # 基线行列式\n        J_svd = get_det_from_svd(F)\n        J_lu = get_det_from_lu(F)\n\n        # 符号匹配\n        sign_match = np.sign(J_svd) == np.sign(J_lu)\n\n        # 相对差异\n        denominator = max(abs(J_svd), abs(J_lu), 1e-300)\n        delta_rel = abs(J_svd - J_lu) / denominator\n\n        # --- 任务3：扰动分析 ---\n        np.random.seed(RANDOM_SEED)\n        dets_svd = []\n        dets_lu = []\n\n        norm_F = np.linalg.norm(F, 'fro')\n        target_norm_delta = eta * norm_F\n\n        for _ in range(K):\n            delta_F_raw = np.random.randn(3, 3)\n            norm_delta_F_raw = np.linalg.norm(delta_F_raw, 'fro')\n            \n            if norm_delta_F_raw > 0:\n                delta_F = delta_F_raw * (target_norm_delta / norm_delta_F_raw)\n            else: # 统计上不太可能的情况\n                delta_F = np.zeros((3, 3))\n            \n            F_perturbed = F + delta_F\n            \n            dets_svd.append(get_det_from_svd(F_perturbed))\n            dets_lu.append(get_det_from_lu(F_perturbed))\n\n        # 样本标准差 (ddof=1)\n        sigma_J_svd = np.std(dets_svd, ddof=1)\n        sigma_J_lu = np.std(dets_lu, ddof=1)\n        \n        # --- 汇总结果 ---\n        case_results = [\n            near_zero,\n            sign_match,\n            sigma_J_svd,\n            sigma_J_lu,\n            delta_rel,\n            J_svd,\n            J_lu\n        ]\n        all_results.append(case_results)\n\n    # --- 最终输出格式 ---\n    print(json.dumps(all_results, separators=(',',':')))\n\nsolve()\n```"
        },
        {
            "introduction": "许多先进的本构模型，尤其是在超弹性理论中，都使用雅可比行列式的对数 $ \\ln J $ 作为一个关键变量。在处理极端变形时，对 $ \\ln(\\det F) $ 的朴素计算可能会因为数值上溢或下溢而彻底失败。这个高级练习要求您设计并实现一个数值稳定的算法来计算 $ \\ln J $，它结合了SVD的强大功能和动态缩放技术，以确保您的计算在极大范围的尺度上保持稳健 。",
            "id": "3605427",
            "problem": "设计一个数值稳定的算法来计算雅可比行列式的自然对数 $\\,\\ln J\\,$，其中 $\\,J = \\det F\\,$ 且 $\\,F \\in \\mathbb{R}^{n \\times n}\\,$ 是一个表示计算固体力学中变形梯度的实方阵。假设 $\\,F\\,$ 可能是病态的，并且在具有物理意义的情况下 $\\,J0\\,$，但允许在人工测试中出现 $\\,J0\\,$。您的解答必须从第一性原理和核心定义出发。仅从以下基本事实开始：(i) 奇异值分解（SVD）的存在性，即任何实矩阵 $\\,F\\,$ 都允许分解为 $\\,F = U \\Sigma V^{T}\\,$，其中 $\\,U, V\\,$ 是正交矩阵，$\\,\\Sigma\\,$ 是对角矩阵，其非负对角元称为奇异值；(ii) 正交矩阵的行列式大小为 $\\,1\\,$；(iii) 行列式作为多重线性交替形式的定义，对于正规矩阵，其值等于特征值的乘积；(iv) 对于可逆矩阵 $\\,F\\,$，行列式的 Fréchet 微分满足 $\\,\\mathrm{d}(\\det F)[\\delta F] = \\det(F)\\,\\mathrm{tr}(F^{-1}\\delta F)\\,$，这意味着 $\\,\\mathrm{d}(\\ln \\det F)[\\delta F] = \\mathrm{tr}(F^{-1}\\delta F)\\,$。不要假设或陈述任何关于用奇异值表示 $\\,\\ln \\det F\\,$ 的闭式捷径；相反，您使用的任何此类表达式都必须从这些基础推导出来。\n\n您的任务分为三个部分：\n\n1) 推导与条件数分析。仅使用上述基本事实，推导出一个用奇异值分解（SVD）中的量表示 $\\,\\ln | \\det F |\\,$ 的表达式，并使用微扰分析和 Fréchet 微分来论证此计算的条件数。您的论证必须指明 $\\,F\\,$ 的哪些方面控制着灵敏度，并且必须与最小奇异值联系起来。提供绝对微扰 $\\,|\\delta(\\ln |\\det F|)|\\,$ 的一个界，用 $\\,F^{-1}\\,$ 的矩阵范数和 $\\,\\delta F\\,$ 的范数表示。\n\n2) 数值稳定算法。针对病态矩阵 $\\,F\\,$，提出一个计算 $\\,\\ln |\\det F|\\,$ 的数值稳定算法，该算法仅使用不会遭受灾难性下溢或上溢的运算。您的算法必须：\n- 在其设计中明确使用奇异值分解（SVD）$\\,F = U \\Sigma V^{T}\\,$。\n- 采用 2 的幂进行动态缩放，以防止浮点运算中的中间上溢或下溢。令 $\\,k = \\lfloor \\log_{2}\\|F\\|_{F}\\rfloor\\,$，按 $\\,a = 2^{-k}\\,$ 进行缩放，并将 $\\,\\ln |\\det F|\\,$ 与 $\\,aF\\,$ 的奇异值联系起来，而无需将奇异值相乘。\n- 同时，从正交因子中计算定向符号 $\\,s = \\operatorname{sign}(\\det F)\\in\\{-1,+1\\}\\,$。\n\n3) 实现与测试套件。将您的算法实现为一个不接受输入并评估一组固定测试矩阵 $\\,F_i\\,$ 的程序，生成所需的输出。角度应解释为弧度，对数为自然对数。该程序应评估以下五个 $\\,\\mathbb{R}^{3\\times 3}\\,$ 中的方阵：\n- 情况 1（良态，保向）：$\\,F_1 = R_z(\\theta_1)\\,\\mathrm{diag}(2.0,\\,0.5,\\,1.5)\\,R_y(\\phi_1)^{T}\\,$，其中 $\\,\\theta_1=0.7\\,$ 且 $\\,\\phi_1=-0.4\\,$。\n- 情况 2（高度病态但单位体积变化）：$\\,F_2 = R_x(\\alpha_2)\\,\\mathrm{diag}(10^{-12},\\,1.0,\\,10^{12})\\,R_z(\\beta_2)^{T}\\,$，其中 $\\,\\alpha_2=0.3\\,$ 且 $\\,\\beta_2=1.2\\,$。\n- 情况 3（极大尺度，朴素相乘有上溢风险）：$\\,F_3 = R_y(\\alpha_3)\\,\\mathrm{diag}(10^{100},\\,2\\cdot 10^{100},\\,5\\cdot 10^{99})\\,R_x(\\beta_3)^{T}\\,$，其中 $\\,\\alpha_3=0.9\\,$ 且 $\\,\\beta_3=-1.1\\,$。\n- 情况 4（极端尺度分离，朴素相乘有下溢风险）：$\\,F_4 = R_z(\\theta_4)\\,\\mathrm{diag}(10^{-300},\\,10^{-10},\\,10^{20})\\,R_y(\\phi_4)^{T}\\,$，其中 $\\,\\theta_4=-0.8\\,$ 且 $\\,\\phi_4=0.6\\,$。\n- 情况 5（反向）：$\\,F_5 = R_x(\\alpha_5)\\,\\mathrm{diag}(-2.0,\\,3.0,\\,5.0)\\,R_y(\\beta_5)^{T}\\,$，其中 $\\,\\alpha_5=0.5\\,$ 且 $\\,\\beta_5=-0.7\\,$。\n\n此处，对于 $\\,\\gamma \\in \\mathbb{R}\\,$，\n$$\nR_x(\\gamma)=\\begin{bmatrix}\n1  0  0\\\\\n0  \\cos\\gamma  -\\sin\\gamma\\\\\n0  \\sin\\gamma  \\cos\\gamma\n\\end{bmatrix},\\quad\nR_y(\\gamma)=\\begin{bmatrix}\n\\cos\\gamma  0  \\sin\\gamma\\\\\n0  1  0\\\\\n-\\sin\\gamma  0  \\cos\\gamma\n\\end{bmatrix},\\quad\nR_z(\\gamma)=\\begin{bmatrix}\n\\cos\\gamma  -\\sin\\gamma  0\\\\\n\\sin\\gamma  \\cos\\gamma  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n\n对于每种情况，您的程序必须输出一个列表 $\\,[\\ln|\\det F_i|,\\,s_i]\\,$，其中 $\\,s_i \\in\\{-1,+1\\}\\,$ 是从正交 SVD 因子计算出的定向符号。将所有五个结果汇总到一个列表中。最终输出格式必须是单行，包含一个由方括号括起来的五个内部列表的逗号分隔列表，例如 $\\,\\big[\\,[\\ell_1,s_1],[\\ell_2,s_2],\\dots,[\\ell_5,s_5]\\,\\big]\\,$，不含空格。\n\n您的实现必须使用自然对数和弧度表示角度，并且不得读取任何输入。输出 $\\,\\ln|\\det F_i|\\,$ 为浮点数，$\\,s_i\\,$ 为整数。这构成了测试套件和输出规范。",
            "solution": "任务是为可能病态的实方阵 $F \\in \\mathbb{R}^{n \\times n}$ 设计、论证和实现一个用于计算雅可比行列式自然对数 $\\ln J = \\ln(\\det F)$ 的数值稳定算法。解决方案按要求分为三个部分：推导与条件数分析、算法设计和实现。\n\n**第 1 部分：推导与条件数分析**\n\n本部分基于奇异值分解（SVD）推导 $\\ln|\\det F|$ 的表达式，并分析该问题的条件数。\n\n**$\\ln|\\det F|$ 的推导**\n\n我们给定以下基本事实：\n(i) 任何实矩阵 $F \\in \\mathbb{R}^{n \\times n}$ 都允许进行奇异值分解（SVD），即 $F = U \\Sigma V^{T}$，其中 $U, V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，其非负对角元 $\\sigma_i \\ge 0$ 被称为 $F$ 的奇异值。\n(ii) 任何正交矩阵的行列式的大小为 $1$。\n(iii) 行列式是一个多重线性交替形式，对于正规矩阵，其值为特征值的乘积。\n\n利用行列式的乘法性质，我们可以将 $F$ 的行列式写为：\n$$\n\\det F = \\det(U \\Sigma V^{T}) = (\\det U) (\\det \\Sigma) (\\det V^{T})\n$$\n根据事实 (ii)，由于 $U$ 和 $V$ 是正交的，它们的行列式为 $\\det U = \\pm 1$ 和 $\\det V = \\pm 1$。因为矩阵转置的行列式等于原矩阵的行列式，所以 $\\det V^T = \\det V = \\pm 1$。\n\n矩阵 $\\Sigma$ 是一个对角矩阵，它是正规矩阵的一个特例。根据事实 (iii)，其行列式是其特征值的乘积。对角矩阵的特征值就是其对角元，在本例中即为 $F$ 的奇异值 $\\sigma_i$。因此：\n$$\n\\det \\Sigma = \\prod_{i=1}^{n} \\sigma_i\n$$\n综合这些结果，我们得到用 $F$ 的 SVD 分量表示其行列式的表达式：\n$$\n\\det F = (\\det U) (\\det V^T) \\prod_{i=1}^{n} \\sigma_i\n$$\n为了找到 $\\ln|\\det F|$ 的表达式，我们首先取行列式的绝对值：\n$$\n|\\det F| = |(\\det U) (\\det V^T)| \\left| \\prod_{i=1}^{n} \\sigma_i \\right|\n$$\n由于 $|\\det U| = 1$，$|\\det V^T| = 1$，且奇异值 $\\sigma_i$ 是非负的，所以乘积 $\\prod_{i=1}^{n} \\sigma_i$ 也是非负的。因此，我们有：\n$$\n|\\det F| = \\prod_{i=1}^{n} \\sigma_i\n$$\n这个表达式表明，体积变化因子 $|\\det F|$ 完全由奇异值的乘积决定。对两边取自然对数，并利用对数的性质（乘积的对数等于对数的和），我们得到所需的表达式：\n$$\n\\ln|\\det F| = \\ln\\left(\\prod_{i=1}^{n} \\sigma_i\\right) = \\sum_{i=1}^{n} \\ln \\sigma_i\n$$\n此推导仅依赖于所提供的基本事实。该公式是数值稳定计算的基础，因为它避免了奇异值的显式相乘，这种相乘可能导致数值上溢或下溢。\n\n**条件数分析**\n\n我们给定事实 (iv)，即行列式的 Fréchet 微分，对于可逆矩阵 $F$，它导出了其自然对数的微分：\n$$\n\\mathrm{d}(\\ln \\det F)[\\delta F] = \\mathrm{tr}(F^{-1} \\delta F)\n$$\n其中 $\\delta F$ 是矩阵 $F$ 的一个微扰。对于一个小的微扰，这意味着 $\\ln(\\det F)$ 的变化，记作 $\\delta(\\ln \\det F)$，可以近似为：\n$$\n\\delta(\\ln \\det F) \\approx \\mathrm{tr}(F^{-1} \\delta F)\n$$\n问题关心的是 $\\ln|\\det F|$。如果我们假设微扰 $\\delta F$ 足够小，以至于 $\\mathrm{sign}(\\det(F+\\delta F)) = \\mathrm{sign}(\\det F)$，那么如果 $\\det F > 0$，则 $\\delta(\\ln|\\det F|) = \\delta(\\ln(\\det F))$；如果 $\\det F  0$，则 $\\delta(\\ln|\\det F|) = \\delta(\\ln(-\\det F))$。在这两种情况下，微分都是 $\\mathrm{tr}(F^{-1}\\delta F)$。所以，我们可以将 $\\ln|\\det F|$ 的微扰分析为：\n$$\n|\\delta(\\ln|\\det F|)| \\approx |\\mathrm{tr}(F^{-1} \\delta F)|\n$$\n为了给这个表达式定界，我们可以使用矩阵的弗罗贝尼乌斯内积的柯西-施瓦茨不等式。对于实矩阵 $A, B \\in \\mathbb{R}^{n \\times n}$，弗罗贝尼乌斯内积定义为 $\\langle A, B \\rangle_F = \\mathrm{tr}(A^T B)$。该不等式表明 $|\\langle A, B \\rangle_F| \\le \\|A\\|_F \\|B\\|_F$。令 $A = (F^{-1})^T$ 和 $B = \\delta F$，我们得到：\n$$\n|\\mathrm{tr}(((F^{-1})^T)^T \\delta F)| = |\\mathrm{tr}(F^{-1} \\delta F)| \\le \\|(F^{-1})^T\\|_F \\|\\delta F\\|_F\n$$\n由于弗罗贝尼乌斯范数在转置下不变，即 $\\|(F^{-1})^T\\|_F = \\|F^{-1}\\|_F$，我们得到以下界：\n$$\n|\\delta(\\ln|\\det F|)| \\lesssim \\|F^{-1}\\|_F \\|\\delta F\\|_F\n$$\n这个不等式将 $\\ln|\\det F|$ 的绝对微扰与 $F$ 的逆矩阵的范数以及微扰 $\\delta F$ 的范数联系起来。\n\n为了将这种灵敏度与 $F$ 的奇异值联系起来，我们用 $F$ 的奇异值来表示 $\\|F^{-1}\\|_F$。$F^{-1}$ 的 SVD 是 $F^{-1} = (U \\Sigma V^T)^{-1} = V \\Sigma^{-1} U^T$。$F^{-1}$ 的奇异值是 $F$ 的奇异值的倒数，即 $1/\\sigma_i$。$F^{-1}$ 的弗罗贝尼乌斯范数是其奇异值平方和的平方根：\n$$\n\\|F^{-1}\\|_F = \\sqrt{\\sum_{i=1}^{n} \\left(\\frac{1}{\\sigma_i}\\right)^2}\n$$\n令 $\\sigma_{\\min} = \\min_{i} \\{\\sigma_i\\}$ 为 $F$ 的最小奇异值。那么逆矩阵的范数有下界 $\\|F^{-1}\\|_F \\ge \\sqrt{(1/\\sigma_{\\min})^2} = 1/\\sigma_{\\min}$。如果 $\\sigma_{\\min}$ 非常小，那么 $F$ 是病态的（接近奇异），并且 $\\|F^{-1}\\|_F$ 会变得非常大。因此，即使对于一个小的微扰 $\\|\\delta F\\|_F$，$\\|F^{-1}\\|_F \\|\\delta F\\|_F$ 这一项也可能很大，这表明 $\\ln|\\det F|$ 的计算对 $F$ 的微扰是敏感的。因此，问题的条件数关键地由 $F$ 的最小奇异值控制。\n\n**第 2 部分：数值稳定算法**\n\n通过先计算 $J = \\det F$ 然后再取对数来朴素地计算 $\\ln|\\det F|$，容易出现数值问题。如果 $F$ 的奇异值非常大或非常小，它们的乘积 $J$ 在取对数之前很容易上溢或下溢标准的浮点表示。推导出的表达式 $\\ln|\\det F| = \\sum_i \\ln \\sigma_i$ 通过将乘积转换为和来避免了这个问题，求和是一个稳定得多的运算。\n\n然而，问题指明 SVD 计算本身可能会受到 $F$ 极端缩放的影响。为了预先阻止这种情况，需要一个动态缩放程序。\n\n所提出的算法如下：\n\n1.  **缩放**：给定矩阵 $F \\in \\mathbb{R}^{n \\times n}$，计算其弗罗贝尼乌斯范数 $\\|F\\|_F = \\sqrt{\\sum_{i,j=1}^{n} F_{ij}^2}$。为了将矩阵元素带入一个数值上有利的范围（数量级为 $1$），我们用 $2$ 的幂来缩放 $F$。\n    - 计算缩放指数 $k = \\lfloor \\log_2 \\|F\\|_F \\rfloor$。这可以使用 `floor(log2(norm))` 来计算。\n    - 定义缩放因子 $a = 2^{-k}$。\n    - 构建缩放后的矩阵 $F' = aF$。该矩阵的范数将在范围 $1 \\le \\|F'\\|_F  2$ 内。\n\n2.  **缩放矩阵的 SVD**：计算良态缩放矩阵 $F' = U' \\Sigma' (V')^T$ 的 SVD。这将得到正交矩阵 $U'$ 和 $(V')^T$，以及包含 $F'$ 的奇异值 $\\sigma'_i$ 的对角矩阵 $\\Sigma'$。\n\n3.  **计算 $\\ln|\\det F|$**：我们将 $\\det F$ 与 $\\det F'$ 联系起来。由 $F' = aF$，我们有 $\\det(F') = \\det(aF) = a^n \\det F$。因此，$\\det F = a^{-n} \\det F'$。\n    取绝对值的自然对数：\n    $$\n    \\ln|\\det F| = \\ln|a^{-n} \\det F'| = \\ln(a^{-n}) + \\ln|\\det F'| = -n \\ln(a) + \\sum_{i=1}^{n} \\ln \\sigma'_i\n    $$\n    代入 $a = 2^{-k}$，我们有 $\\ln a = \\ln(2^{-k}) = -k \\ln 2$。计算的最终表达式为：\n    $$\n    \\ln|\\det F| = -n(-k \\ln 2) + \\sum_{i=1}^{n} \\ln \\sigma'_i = nk \\ln 2 + \\sum_{i=1}^{n} \\ln \\sigma'_i\n    $$\n    这个计算是数值稳定的，因为它涉及对行为良好的奇异值 $\\sigma'_i$ 的对数求和，并加上一个缩放项。它完全避免了乘以原始奇异值 $\\sigma_i = \\sigma'_i/a$。\n\n4.  **计算定向符号**：定向符号为 $s = \\mathrm{sign}(\\det F)$。由于缩放因子 $a = 2^{-k}$ 是正的，所以 $\\mathrm{sign}(\\det F) = \\mathrm{sign}(\\det F')$。\n    从 $F'$ 的 SVD，我们有 $\\det F' = (\\det U') (\\det \\Sigma') (\\det (V')^T)$。对于一个非奇异矩阵，所有奇异值 $\\sigma'_i$ 都是正的，所以 $\\det \\Sigma' = \\prod_i \\sigma'_i > 0$。\n    因此，符号由正交因子的行列式决定：\n    $$\n    s = \\mathrm{sign}(\\det F) = (\\det U')(\\det(V')^T)\n    $$\n    $U'$ 和 $(V')^T$ 的行列式是数值计算的。由于已知它们是 $\\pm 1$，其乘积可以四舍五入到最接近的整数，以得到一个鲁棒的 $\\pm 1$ 符号。\n\n**算法总结**\n对于给定的矩阵 $F \\in \\mathbb{R}^{n \\times n}$：\na. 如果 $F$ 是零矩阵，则 $|\\det F| = 0$ 且 $\\ln|\\det F| = -\\infty$。符号未定义，但可取为 $0$ 或 $1$。我们假设 $F$ 非零。\nb. 计算弗罗贝尼乌斯范数 $\\|F\\|_F$。\nc. 计算缩放指数 $k = \\lfloor \\log_2 \\|F\\|_F \\rfloor$ 和因子 $a = 2^{-k}$。\nd. 构建缩放矩阵 $F' = aF$。\ne. 对 $F'$ 执行 SVD 以获得 $U'$、奇异值 $\\sigma'_i$ 和 $V'^T$。\nf. 计算 $\\ln|\\det F| = n k \\ln(2) + \\sum_i \\ln(\\sigma'_i)$。\ng. 计算符号 $s = \\mathrm{round}(\\det(U') \\cdot \\det(V'^T))$。\nh. 返回数对 $[\\ln|\\det F|, s]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef solve():\n    \"\"\"\n    Designs and executes a numerically stable algorithm to compute ln|det(F)| and sign(det(F))\n    for a given set of test matrices F.\n    \"\"\"\n\n    def Rx(gamma):\n        \"\"\"Rotation matrix about x-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]], dtype=np.float64)\n\n    def Ry(gamma):\n        \"\"\"Rotation matrix about y-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]], dtype=np.float64)\n\n    def Rz(gamma):\n        \"\"\"Rotation matrix about z-axis.\"\"\"\n        c = np.cos(gamma)\n        s = np.sin(gamma)\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]], dtype=np.float64)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (well-conditioned, orientation-preserving)\n        Rz(0.7) @ np.diag([2.0, 0.5, 1.5]) @ Ry(-0.4).T,\n        # Case 2 (highly ill-conditioned but with unit volume change)\n        Rx(0.3) @ np.diag([1e-12, 1.0, 1e12]) @ Rz(1.2).T,\n        # Case 3 (very large scales, risk of overflow)\n        Ry(0.9) @ np.diag([1e100, 2e100, 5e99]) @ Rx(-1.1).T,\n        # Case 4 (extreme scale separation, risk of underflow)\n        Rz(-0.8) @ np.diag([1e-300, 1e-10, 1e20]) @ Ry(0.6).T,\n        # Case 5 (orientation-reversing)\n        Rx(0.5) @ np.diag([-2.0, 3.0, 5.0]) @ Ry(-0.7).T\n    ]\n\n    results = []\n    \n    # Process each test case using the derived numerically stable algorithm\n    for F in test_cases:\n        n = F.shape[0]\n\n        # Step 1: Scaling\n        norm_F = np.linalg.norm(F, 'fro')\n        \n        # Handle the case of a zero matrix, though not in test suite.\n        if norm_F == 0:\n            log_det_abs = -np.inf\n            sign_det = 0 # Or undefined. Problem asks for +/-1. Assume non-singular.\n            results.append([log_det_abs, sign_det])\n            continue\n            \n        k = np.floor(np.log2(norm_F))\n        # a = 2.0**(-k) # not needed explicitly\n        \n        # Step 2: SVD of Scaled Matrix\n        F_scaled = F * (2.0**(-k))\n        U, s_scaled, Vt = np.linalg.svd(F_scaled)\n\n        # Step 3: Compute ln|det F|\n        # ln|det F| = nk*ln(2) + sum(ln(sigma_i_scaled))\n        log_det_abs = n * k * np.log(2) + np.sum(np.log(s_scaled))\n\n        # Step 4: Compute Orientation Sign\n        # sign(det F) = det(U) * det(Vt)\n        det_U = np.linalg.det(U)\n        det_Vt = np.linalg.det(Vt)\n        sign_det = int(np.round(det_U * det_Vt))\n        \n        results.append([log_det_abs, sign_det])\n\n    # Final print statement in the exact required format.\n    print(json.dumps(results, separators=(',',':')))\n\nsolve()\n```"
        }
    ]
}