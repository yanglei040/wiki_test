{
    "hands_on_practices": [
        {
            "introduction": "在连续介质力学中，虽然双点积 $A:B$ 和矩阵乘积的迹 $\\mathrm{tr}(AB)$ 在张量对称的常见情况下是等价的，但区分它们对于深刻理解张量代数至关重要。此练习旨在通过一个具体的反例，让您亲手验证在非对称情况下二者的差异，从而夯实您对双点积基本定义的理解，避免在更复杂的推导中出现概念混淆。",
            "id": "3604877",
            "problem": "考虑定义在具有标准正交基的三维欧几里得体上的二阶张量 $A$ 和 $B$。$A$ 和 $B$ 的双点积定义为 $A:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}$，其乘积的迹定义为 $\\mathrm{tr}(AB) = \\sum_{i=1}^{3} (AB)_{ii} = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}$。在计算固体力学中，等式 $A:B = \\mathrm{tr}(AB)$ 常在对称性假设下使用。从上述核心定义出发，在不假设对称性的情况下，提供一个分量形式的反例来证明 $A:B \\neq \\mathrm{tr}(AB)$。\n\n使用以下具体张量\n$$\nA = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0  0  0 \\\\\n3  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\n直接根据定义计算 $A:B$ 和 $\\mathrm{tr}(AB)$，并将标量差 $A:B - \\mathrm{tr}(AB)$ 作为一个实数报告。最终答案以不带单位的形式表示。",
            "solution": "该问题经验证是自洽的、科学上合理的且适定的。目标是计算给定的非对称二阶张量 $A$ 和 $B$ 的标量差 $A:B - \\mathrm{tr}(AB)$。\n\n提供的具体张量为：\n$$\nA = \\begin{pmatrix}\n0  2  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix},\\qquad\nB = \\begin{pmatrix}\n0  0  0 \\\\\n3  0  0 \\\\\n0  0  0\n\\end{pmatrix}.\n$$\n以分量形式表示，张量 $A$ 唯一的非零分量是 $A_{12} = 2$。张量 $B$ 唯一的非零分量是 $B_{21} = 3$。对于 $(i,j) \\in \\{1, 2, 3\\} \\times \\{1, 2, 3\\}$，所有其他分量 $A_{ij}$ 和 $B_{ij}$ 都等于 $0$。\n\n首先，我们使用所提供的定义计算双点积 $A:B$：\n$$\nA:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}\n$$\n这个运算，也称为弗罗贝尼乌斯内积，涉及将两个张量的对应分量之积求和。我们可以展开这个和：\n$$\nA:B = A_{11}B_{11} + A_{12}B_{12} + A_{13}B_{13} + A_{21}B_{21} + A_{22}B_{22} + A_{23}B_{23} + A_{31}B_{31} + A_{32}B_{32} + A_{33}B_{33}\n$$\n代入 $A$ 和 $B$ 的分量值：\n$$\nA:B = (0)(0) + (2)(0) + (0)(0) + (0)(3) + (0)(0) + (0)(0) + (0)(0) + (0)(0) + (0)(0)\n$$\n求和中的每一项都为零。例如，涉及非零分量 $A_{12}=2$ 的项是 $A_{12}B_{12}$，但 $B_{12}=0$。类似地，涉及非零分量 $B_{21}=3$ 的项是 $A_{21}B_{21}$，但 $A_{21}=0$。\n因此，双点积为：\n$$\nA:B = 0\n$$\n\n接下来，我们计算张量积 $AB$ 的迹，记为 $\\mathrm{tr}(AB)$。所提供的定义是：\n$$\n\\mathrm{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji}\n$$\n这个和涉及将分量 $A_{ij}$ 与分量 $B_{ji}$（注意 $B$ 的索引是转置的）相乘，并对所有 $i$ 和 $j$求和。我们来检查这个求和中的各项。$A$ 唯一的非零分量是 $A_{12} = 2$。因此，整个双重求和中唯一可能非零的项是 $i=1$ 且 $j=2$ 时的项。该项是 $A_{12}B_{21}$。所有其他项都将为零，因为当 $(i,j) \\neq (1,2)$ 时，$A_{ij}=0$。\n\n让我们计算这个唯一的非零项：\n$$\nA_{12}B_{21} = (2)(3) = 6\n$$\n由于和中的所有其他项都为零，迹的值完全由这一项确定：\n$$\n\\mathrm{tr}(AB) = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ji} = A_{12}B_{21} + \\sum_{(i,j) \\neq (1,2)} A_{ij}B_{ji} = 6 + 0 = 6\n$$\n或者，可以先计算矩阵乘积 $C = AB$：\n$$\nC = AB = \\begin{pmatrix} 0  2  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0 \\\\ 3  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} (0)(0)+(2)(3)+(0)(0)  (0)(0)+(2)(0)+(0)(0)  (0)(0)+(2)(0)+(0)(0) \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n$$\nC = \\begin{pmatrix} 6  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n迹是 $C$ 的对角元素之和：\n$$\n\\mathrm{tr}(AB) = \\mathrm{tr}(C) = C_{11} + C_{22} + C_{33} = 6 + 0 + 0 = 6\n$$\n两种方法得到相同的结果。\n\n最后，我们计算所需的标量差 $A:B - \\mathrm{tr}(AB)$：\n$$\nA:B - \\mathrm{tr}(AB) = 0 - 6 = -6\n$$\n这个反例表明，对于非对称张量，双点积 $A:B$ 通常不等于其乘积的迹 $\\mathrm{tr}(AB)$。当至少一个张量是对称的时候，该等式才成立，而这里情况并非如此。",
            "answer": "$$\\boxed{-6}$$"
        },
        {
            "introduction": "双点积不仅是计算标量内积的工具，更是执行张量分解与投影的关键算子。本实践将引导您应用双点积来定义和实现偏应力算子，该算子能将一个应力张量分解为引起体积变化的球量部分和引起形状变化的偏量部分，这在塑性力学和材料本构理论中是核心步骤。通过数值验证其幂等性 $dev(dev(\\sigma))=dev(\\sigma)$，您将进一步理解该算子作为一种投影操作的几何本质。",
            "id": "3604892",
            "problem": "请用一种现代编程语言设计并实现一个完整的算法，用于计算一个标量偏能量度量，并为一个给定的二阶张量验证其偏量投影的幂等性。请使用以下连续介质力学的核心定义，所有计算均限于三维二阶张量。\n\n设柯西应力张量表示为 $\\sigma \\in \\mathbb{R}^{3 \\times 3}$。二阶单位张量表示为 $I \\in \\mathbb{R}^{3 \\times 3}$，其双点积为 $I:I=3$。两个二阶张量 $A$ 和 $B$ 的双点积（也称双缩并）定义为 $A:B=\\sum_{i=1}^{3}\\sum_{j=1}^{3}A_{ij}B_{ij}$。偏量算子定义为 $dev(\\sigma)=\\sigma-\\dfrac{1}{3}(\\sigma:I)I$，它将 $\\sigma$ 映射到其无迹部分。\n\n从这些基本定义出发，您必须：\n\n1. 从第一性原理推导为何 $dev(dev(\\sigma))=dev(\\sigma)$，推导过程需明确使用 $I:I=3$ 以及双点积的性质。设计一个算法测试，通过测量差值 $dev(dev(\\sigma))-dev(\\sigma)$ 的弗罗贝尼乌斯范数 $||A||_{F}=\\sqrt{A:A}$，并与一个小的容差（使用 $10^{-10}$ 作为容差）进行比较，从而对给定输入在数值上验证幂等性。\n2. 将偏能量度量 $E_{dev}(\\sigma)$ 定义为标量 $E_{dev}(\\sigma)=\\dfrac{1}{2}\\,dev(\\sigma):dev(\\sigma)$ 并实现其计算。所有输入和输出均为无量纲；输出的能量值应表示为浮点数。\n\n您的实现必须是完全自包含的，并为以下数值指定的应力张量测试套件（每个均为对称 $3 \\times 3$ 矩阵）生成结果：\n\n- 一般情况（非零迹和剪切）： \n  $\\sigma_{A}=\\begin{bmatrix}120  -30  45 \\\\ -30  80  0 \\\\ 45  0  -10\\end{bmatrix}$。\n- 纯静水压力情况： $\\sigma_{B}=50\\,I=\\begin{bmatrix}50  0  0 \\\\ 0  50  0 \\\\ 0  0  50\\end{bmatrix}$。\n- 纯偏量情况（零迹含剪切）： \n  $\\sigma_{C}=\\begin{bmatrix}30  -6  0 \\\\ -6  -15  0 \\\\ 0  0  -15\\end{bmatrix}$。\n- 零张量（边界情况）： \n  $\\sigma_{D}=\\begin{bmatrix}0  0  0 \\\\ 0  0  0 \\\\ 0  0  0\\end{bmatrix}$。\n- 微小量级偏量情况（边缘情况）： \n  $\\sigma_{E}=\\begin{bmatrix}10^{-12}  2\\cdot 10^{-12}  -3\\cdot 10^{-12} \\\\ 2\\cdot 10^{-12}  -10^{-12}  4\\cdot 10^{-12} \\\\ -3\\cdot 10^{-12}  4\\cdot 10^{-12}  0\\end{bmatrix}$。\n\n对每个测试用例，计算：\n- 标量偏能量 $E_{dev}(\\sigma)$，以浮点数形式表示。\n- 一个布尔标志，指示幂等性在数值上是否成立，定义为 $||dev(dev(\\sigma))-dev(\\sigma)||_{F}  10^{-10}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表被方括号括起来。列表中的每个元素对应一个测试用例，并且本身是一个包含两个元素的列表，分别是浮点数形式的偏能量和布尔幂等性标志。例如，输出格式必须为 \n$[[E_{A},\\text{flag}_{A}],[E_{B},\\text{flag}_{B}],\\dots]$ 的形式，\n方括号列表前后不应有任何额外文本。",
            "solution": "问题陈述经评估为 **有效**。其科学基础扎根于连续介质力学原理，问题表述清晰，包含了所有必要的定义和数据，并以客观、正式的语言表达。不存在矛盾、歧义或事实性错误。因此，我们可以着手提供一个解决方案。\n\n该解决方案需要两个主要组成部分：对偏量算子幂等性的形式化推导，以及设计一个算法来为一组给定的测试用例计算所需的量。\n\n### 第1部分：偏量算子幂等性的推导\n\n偏量算子 $dev(\\cdot)$ 将一个二阶张量 $\\sigma$ 映射到其无迹部分。其定义如下：\n$$\ndev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I\n$$\n其中 $\\sigma$ 是一个二阶张量，$I$ 是二阶单位张量，$A:B$ 表示两个张量 $A$ 和 $B$ 的双点积（或双缩并），定义为 $A:B = \\sum_{i}\\sum_{j}A_{ij}B_{ij}$。项 $\\sigma:I$ 是 $\\sigma$ 的迹，记为 $tr(\\sigma)$。\n\n如果一个算子 $P$ 应用两次与应用一次的效果相同，即 $P(P(x)) = P(x)$，则该算子是幂等的。对于偏量算子，我们必须证明 $dev(dev(\\sigma)) = dev(\\sigma)$。\n\n我们定义张量 $\\sigma'$ 为对 $\\sigma$ 应用偏量算子的结果：\n$$\n\\sigma' = dev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I\n$$\n现在，我们将偏量算子应用于 $\\sigma'$：\n$$\ndev(\\sigma') = \\sigma' - \\frac{1}{3}(\\sigma':I)I\n$$\n为了继续推导，我们必须计算项 $\\sigma':I$，即偏量张量 $\\sigma'$ 的迹。我们将 $\\sigma'$ 的定义代入此表达式：\n$$\n\\sigma':I = \\left(\\sigma - \\frac{1}{3}(\\sigma:I)I\\right):I\n$$\n双点积是一种双线性形式，因此我们可以将其在减法上进行分配：\n$$\n\\sigma':I = (\\sigma:I) - \\left(\\frac{1}{3}(\\sigma:I)I\\right):I\n$$\n项 $\\frac{1}{3}(\\sigma:I)$ 是一个标量。标量可以从双点积运算中提取出来：\n$$\n\\sigma':I = (\\sigma:I) - \\frac{1}{3}(\\sigma:I)(I:I)\n$$\n问题陈述中提供了基本恒等式，即三维空间中的二阶单位张量满足 $I:I=3$。我们也可以从定义中验证这一点：$I:I = \\sum_{i,j} \\delta_{ij}\\delta_{ij} = \\sum_{i} \\delta_{ii} = \\delta_{11} + \\delta_{22} + \\delta_{33} = 1 + 1 + 1 = 3$。将此结果代入我们的方程：\n$$\n\\sigma':I = (\\sigma:I) - \\frac{1}{3}(\\sigma:I)(3)\n$$\n$$\n\\sigma':I = (\\sigma:I) - (\\sigma:I) = 0\n$$\n这证明了一个关键性质：任何由偏量算子得到的张量都是无迹的。\n\n现在我们将此结果 $\\sigma':I = 0$ 代回到 $dev(\\sigma')$ 的表达式中：\n$$\ndev(\\sigma') = \\sigma' - \\frac{1}{3}(0)I\n$$\n$$\ndev(\\sigma') = \\sigma' - 0 = \\sigma'\n$$\n由于我们最初定义了 $\\sigma' = dev(\\sigma)$，我们成功证明了：\n$$\ndev(dev(\\sigma)) = dev(\\sigma)\n$$\n至此，证明完成。偏量算子确实是一个幂等算子，这是投影算子的一个特征。它将一个张量从二阶张量的一般空间投影到无迹（偏量）张量的子空间上。\n\n### 第2部分：算法设计与实现\n\n基于上述经过验证的原理和推导，我们设计一个算法来执行所需的计算。\n\n**1. 数据表示：**\n所有二阶张量，如柯西应力 $\\sigma$ 和单位张量 $I$，都表示为 $3 \\times 3$ 的数值数组。\n\n**2. 核心操作：**\n\n*   **双点积：** 一个函数将计算双点积 $A:B = \\sum_{i,j} A_{ij}B_{ij}$。这对应于两个数组的逐元素乘法，然后对结果数组中的所有元素求和。\n\n*   **偏量算子：** 一个函数 `dev(tensor)` 将实现公式 $dev(\\sigma) = \\sigma - \\frac{1}{3}(\\sigma:I)I$。它将使用双点积函数来计算迹 $tr(\\sigma) = \\sigma:I$。\n\n**3. 所需计算：**\n\n*   **偏能量度量：** 计算标量偏能量 $E_{dev}(\\sigma) = \\frac{1}{2}dev(\\sigma):dev(\\sigma)$。首先，计算偏量张量 $\\sigma' = dev(\\sigma)$。然后，计算它与自身的双点积 $\\sigma':\\sigma'$，再乘以 $\\frac{1}{2}$。\n\n*   **幂等性验证：** 为了在数值上检验属性 $dev(dev(\\sigma)) = dev(\\sigma)$，我们计算方程两边的差值：$D = dev(dev(\\sigma)) - dev(\\sigma)$。由于浮点运算，这个差值可能不完全为零。因此，我们使用弗罗贝尼乌斯范数 $||D||_F = \\sqrt{D:D}$ 来量化其大小。如果该范数小于一个小的容差（指定为 $10^{-10}$），则认为幂等性在数值上成立。结果是一个布尔标志。\n\n**4. 总体流程：**\n主算法将对每个提供的输入应力张量执行以下步骤：\n1.  接收输入张量 $\\sigma$。\n2.  计算其偏量部分：$\\sigma' = dev(\\sigma)$。\n3.  计算偏能量：$E_{dev} = \\frac{1}{2} (\\sigma':\\sigma')$。\n4.  第二次应用偏量算子：$\\sigma'' = dev(\\sigma')$。\n5.  为进行幂等性检查，计算差值张量：$D = \\sigma'' - \\sigma'$。\n6.  计算差值的弗罗贝尼乌斯范数：$||D||_F = \\sqrt{D:D}$。\n7.  将范数与容差进行比较，以获得布尔标志：$\\text{flag} = (||D||_F  10^{-10})$。\n8.  存储数据对 $[E_{dev}, \\text{flag}]$。\n\n处理完所有测试用例后，收集到的结果将按照问题要求格式化为单个字符串，例如 `[[E_A, flag_A], [E_B, flag_B], ...]`，并打印到标准输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a scalar deviatoric energy measure and verifies the idempotence\n    of the deviatoric projection for a given suite of second-order stress tensors.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # sigma_A: General case\n        np.array([[120.0, -30.0, 45.0], \n                  [-30.0, 80.0, 0.0], \n                  [45.0, 0.0, -10.0]]),\n        \n        # sigma_B: Pure hydrostatic case\n        np.array([[50.0, 0.0, 0.0], \n                  [0.0, 50.0, 0.0], \n                  [0.0, 0.0, 50.0]]),\n        \n        # sigma_C: Pure deviatoric case\n        np.array([[30.0, -6.0, 0.0], \n                  [-6.0, -15.0, 0.0], \n                  [0.0, 0.0, -15.0]]),\n        \n        # sigma_D: Zero tensor\n        np.array([[0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0], \n                  [0.0, 0.0, 0.0]]),\n\n        # sigma_E: Tiny-magnitude deviatoric case\n        np.array([[1e-12, 2e-12, -3e-12],\n                  [2e-12, -1e-12, 4e-12],\n                  [-3e-12, 4e-12, 0.0]])\n    ]\n\n    results = []\n    \n    # Define the second-order identity tensor in 3D\n    identity_tensor = np.identity(3)\n    \n    # Define tolerance for the idempotence check\n    tolerance = 1e-10\n\n    def double_dot_product(tensor_A, tensor_B):\n        \"\"\"\n        Computes the double dot product A:B = sum(A_ij * B_ij).\n        \"\"\"\n        return np.sum(tensor_A * tensor_B)\n\n    def deviatoric_operator(tensor):\n        \"\"\"\n        Computes the deviatoric part of a tensor: dev(T) = T - 1/3 * tr(T) * I.\n        \"\"\"\n        trace = double_dot_product(tensor, identity_tensor)\n        return tensor - (trace / 3.0) * identity_tensor\n\n    for sigma in test_cases:\n        # 1. Compute the deviatoric part of the stress tensor\n        dev_sigma = deviatoric_operator(sigma)\n        \n        # 2. Compute the scalar deviatoric energy\n        # E_dev = 1/2 * dev(sigma):dev(sigma)\n        deviatoric_energy = 0.5 * double_dot_product(dev_sigma, dev_sigma)\n        \n        # 3. Verify the idempotence property: dev(dev(sigma)) = dev(sigma)\n        # We compute dev(dev(sigma))\n        dev_dev_sigma = deviatoric_operator(dev_sigma)\n        \n        # Calculate the difference tensor D = dev(dev(sigma)) - dev(sigma)\n        difference_tensor = dev_dev_sigma - dev_sigma\n        \n        # Calculate the Frobenius norm of the difference: ||D||_F = sqrt(D:D)\n        norm_of_difference = np.sqrt(double_dot_product(difference_tensor, difference_tensor))\n        \n        # Check if the norm is within the specified tolerance\n        idempotence_holds = norm_of_difference  tolerance\n        \n        # Append the result pair to the list\n        results.append([deviatoric_energy, idempotence_holds])\n\n    # Convert each two-element list result into its string representation\n    # e.g., [7358.333, True] becomes \"[7358.333333333333, True]\"\n    # Using python's boolean string representation 'True'/'False' directly.\n    string_results = [str(res).replace(\"True\", \"true\").replace(\"False\", \"false\") for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "超越基于分量的计算，我们可以从谱分解（即特征分解）的视角来揭示双点积更深层次的几何与物理意义。本练习旨在引导您探索双点积如何与张量的特征值和特征向量相关联，特别是当两个张量共轴（即拥有相同的特征向量）时，其双点积可以极大地简化。通过推导并实现基于谱分解的计算方法，您将对张量内积的基无关性及其与主方向和主值的关系建立起更为直观和深刻的认识。",
            "id": "3604862",
            "problem": "考虑两个二阶张量，表示为实对称矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 和 $B \\in \\mathbb{R}^{3 \\times 3}$，这在计算固体力学中常用于表示应力、应变或刚度张量。$A$ 和 $B$ 的双点积定义为 $A:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}$，它等于 $\\mathrm{tr}(A^{\\mathsf{T}}B)$，并且当 $A$ 和 $B$ 对称时，等于 $\\mathrm{tr}(AB)$。实对称张量 $A$ 的谱分解为 $A = Q \\Lambda Q^{\\mathsf{T}}$，其中 $Q$ 是由特征向量构成的正交矩阵，$\\Lambda$ 是由实特征值构成的对角矩阵。如果两个张量共享相同的特征向量，即它们可以被同一个正交矩阵同时对角化，则称它们是共轴的。\n\n从这些定义和性质出发，推导一个算法，该算法在张量共轴时使用谱分解来计算双点积 $A:B$，并严格确定简化表达式 $A:B = \\sum_{i=1}^{3} \\lambda_i \\mu_i$ 在何种条件下有效或无效，其中 $\\lambda_i$ 和 $\\mu_i$ 分别是 $A$ 和 $B$ 的特征值。您的推导和算法必须仅依赖于上述基本原理：二阶张量双点积的定义、实对称张量的谱分解以及迹的正交不变性。不得先验地假设任何其他简化公式。\n\n将您的推导实现为一个完整的、可运行的程序，该程序能够：\n- 直接根据分量计算 $A:B$。\n- 使用特征对，通过谱分解以基无关的方式计算 $A:B$，不假设共轴性，将结果表示为特征值和特征向量正交对齐度的函数。\n- 检测共轴性，并且当此条件成立时，通过简化的特征值配对公式计算 $A:B$。\n- 报告在每个测试用例中，$A:B = \\sum_{i=1}^{3} \\lambda_i \\mu_i$ 是否在 $10^{-12}$ 的数值容差内成立。\n- 使用下面指定的角度，单位为弧度。\n\n测试套件。使用以下四个 $3 \\times 3$ 对称张量对：\n1. $A_1 = \\mathrm{diag}(3,2,1)$ 和 $B_1 = \\mathrm{diag}(5,-1,4)$。\n2. 令 $R_z(\\theta)$ 为绕 $z$ 轴旋转角度 $\\theta$ 的旋转矩阵。当 $\\theta = \\pi/4$ 时，定义 $A_2 = R_z(\\theta)\\,\\mathrm{diag}(7,0,-2)\\,R_z(\\theta)^{\\mathsf{T}}$ 和 $B_2 = R_z(\\theta)\\,\\mathrm{diag}(1,3,4)\\,R_z(\\theta)^{\\mathsf{T}}$。\n3. 令 $R_x(\\phi)$ 为绕 $x$ 轴旋转角度 $\\phi$ 的旋转矩阵。当 $\\phi = \\pi/6$ 时，定义 $A_3 = \\mathrm{diag}(2,-1,3)$ 和 $B_3 = R_x(\\phi)\\,\\mathrm{diag}(4,6,-2)\\,R_x(\\phi)^{\\mathsf{T}}$。\n4. 令 $R_y(\\alpha)$ 为绕 $y$ 轴旋转角度 $\\alpha$ 的旋转矩阵。当 $\\alpha = \\pi/7$ 时，定义 $A_4 = 5 I$ 和 $B_4 = R_y(\\alpha)\\,\\mathrm{diag}(10,-2,1)\\,R_y(\\alpha)^{\\mathsf{T}}$，其中 $I$ 是单位矩阵。\n\n角度单位：弧度。\n\n数值容差：$10^{-12}$。\n\n对于每种情况 $k = 1,2,3,4$，您的程序必须生成一个列表，其中包含：\n- 逐分量计算的 $A_k:B_k$ 的直接值。\n- 使用特征对和正交不变性以基无关方式表示的 $A_k:B_k$ 的谱分解值。\n- 当检测到共轴时，通过最佳配对匹配特征向量计算出的共轴特征值配对值 $\\sum_{i=1}^{3} \\lambda_i \\mu_i$；否则，作为最大化特征向量对角线对齐度的配对计算出的值。\n- 一个布尔值，指示 $A_k:B_k = \\sum_{i=1}^{3} \\lambda_i \\mu_i$ 是否在规定的容差内成立。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内含四个按情况分类的子列表，无空格，并用方括号括起来。例如：\"[[case1_values],[case2_values],[case3_values],[case4_values]]\"。每个按情况分类的子列表必须采用“[direct,spectral,paired_sum,boolean]”的形式。此问题不涉及物理单位，所有角度均以弧度为单位。",
            "solution": "问题要求推导一个算法，该算法使用谱分解来计算两个二阶对称张量 $A$ 和 $B$ 的双点积，并分析简化表达式 $A:B = \\sum_{i=1}^{3} \\lambda_i \\mu_i$ 在何种条件下有效。推导必须基于第一性原理。\n\n设 $A, B \\in \\mathbb{R}^{3 \\times 3}$ 为实对称二阶张量。双点积按分量定义为 $A:B = \\sum_{i=1}^{3}\\sum_{j=1}^{3} A_{ij} B_{ij}$。使用迹算子的等效定义是 $A:B = \\mathrm{tr}(A^{\\mathsf{T}}B)$。由于 $A$ 是对称的，$A^{\\mathsf{T}} = A$，表达式变为 $A:B = \\mathrm{tr}(AB)$。\n\n实对称矩阵的谱定理保证了任何此类张量 $X$ 都可以分解为 $X = Q \\Lambda Q^{\\mathsf{T}}$，其中 $Q$ 是一个正交矩阵，其列是 $X$ 的特征向量，$\\Lambda$ 是一个包含相应实特征值的对角矩阵。设 $A$ 和 $B$ 的谱分解为：\n$$ A = Q_A \\Lambda_A Q_A^{\\mathsf{T}} \\quad \\text{和} \\quad B = Q_B \\Lambda_B Q_B^{\\mathsf{T}} $$\n此处，$\\Lambda_A = \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3)$ 和 $\\Lambda_B = \\mathrm{diag}(\\mu_1, \\mu_2, \\mu_3)$ 分别包含 $A$ 和 $B$ 的特征值。$Q_A$ 的列是 $A$ 的特征向量，记为 $\\mathbf{q}_{Aj}$，$Q_B$ 及其列 $\\mathbf{q}_{Bi}$ 也类似。\n\n为了推导双点积的谱形式，我们将这些分解代入迹表达式中：\n$$ A:B = \\mathrm{tr}( (Q_A \\Lambda_A Q_A^{\\mathsf{T}}) (Q_B \\Lambda_B Q_B^{\\mathsf{T}}) ) $$\n我们利用迹的循环性质，$\\mathrm{tr}(WXYZ) = \\mathrm{tr}(ZWXY)$。通过将迹内的乘积中的 $Q_B^{\\mathsf{T}}$ 循环排列到最前面，我们得到：\n$$ A:B = \\mathrm{tr}( Q_B^{\\mathsf{T}} Q_A \\Lambda_A Q_A^{\\mathsf{T}} Q_B \\Lambda_B ) $$\n我们定义一个正交矩阵 $C = Q_A^{\\mathsf{T}} Q_B$。该矩阵表示从 $B$ 的特征基到 $A$ 的特征基的变换。其转置为 $C^{\\mathsf{T}} = (Q_A^{\\mathsf{T}} Q_B)^{\\mathsf{T}} = Q_B^{\\mathsf{T}} Q_A$。双点积的表达式简化为：\n$$ A:B = \\mathrm{tr}( C^{\\mathsf{T}} \\Lambda_A C \\Lambda_B ) $$\n这个公式是基无关的，因为它仅取决于特征值和特征向量的相对方向。为了明确这一点，我们展开迹。迹内矩阵乘积的第 $(i, m)$ 个元素是：\n$$ (C^{\\mathsf{T}} \\Lambda_A C \\Lambda_B)_{im} = \\sum_{j,k,l} (C^{\\mathsf{T}})_{ij} (\\Lambda_A)_{jk} C_{kl} (\\Lambda_B)_{lm} $$\n由于 $\\Lambda_A$ 和 $\\Lambda_B$ 是对角矩阵，$(\\Lambda_A)_{jk} = \\delta_{jk} \\lambda_k$ 和 $(\\Lambda_B)_{lm} = \\delta_{lm} \\mu_m$。转置元素为 $(C^{\\mathsf{T}})_{ij} = C_{ji}$。表达式变为：\n$$ (C^{\\mathsf{T}} \\Lambda_A C \\Lambda_B)_{im} = \\sum_{j,k,l} C_{ji} (\\delta_{jk} \\lambda_k) C_{kl} (\\delta_{lm} \\mu_m) = \\sum_{j} C_{ji} \\lambda_j C_{jm} \\mu_m $$\n迹是对角元素之和 ($i=m$)：\n$$ A:B = \\sum_{i=1}^{3} \\left( \\sum_{j=1}^{3} C_{ji} \\lambda_j C_{ji} \\mu_i \\right) = \\sum_{i=1}^{3} \\sum_{j=1}^{3} \\lambda_j \\mu_i C_{ji}^2 $$\n矩阵元素 $C_{ji} = (\\mathbf{q}_{Aj})^{\\mathsf{T}} (\\mathbf{q}_{Bi}) = \\mathbf{q}_{Aj} \\cdot \\mathbf{q}_{Bi}$ 是 $A$ 的第 $j$ 个特征向量与 $B$ 的第 $i$ 个特征向量之间的点积。其平方 $C_{ji}^2$ 代表了这两个主方向之间的几何对齐程度。该公式从谱数据提供了 $A:B$ 的精确值，并作为“谱分解值”。\n\n接下来，我们确立简化表达式 $A:B = \\sum_{i=1}^{3} \\lambda_i \\mu_i$ 的有效性条件。这种形式表明特征值是直接配对的，而这仅在张量的主方向对齐时才具有物理意义。此条件称为共轴性。两个对称张量是共轴的，当且仅当它们可以被同一个正交矩阵同时对角化。一个等效的充要条件是这两个张量可交换，即 $AB=BA$。\n如果 $A$ 和 $B$ 是共轴的，我们可以设 $Q_A = Q_B = Q$。对齐矩阵变为 $C = Q_A^{\\mathsf{T}} Q_B = Q^{\\mathsf{T}}Q = I$，即单位矩阵。因此元素为 $C_{ji} = \\delta_{ji}$ (克罗内克δ)。将其代入通用谱公式可得：\n$$ A:B = \\sum_{i,j} \\lambda_j \\mu_i (\\delta_{ji})^2 = \\sum_{i,j} \\lambda_j \\mu_i \\delta_{ji} = \\sum_{i=1}^{3} \\lambda_i \\mu_i $$\n这证明了简化公式是有效的，当且仅当张量是共轴的，且特征值 $\\lambda_i, \\mu_i$ 是根据它们共享的特征向量配对的。形式为 $kI$ 的各向同性张量与任何其他对称张量都是共轴的，因为任何一组标准正交向量都构成其有效的特征基。\n\n算法实现如下：\n$1$. 直接值按 $A:B = \\sum_{ij} A_{ij}B_{ij}$ 计算。\n$2$. 谱值使用通用公式 $A:B = \\sum_{i,j} \\lambda_j \\mu_i C_{ji}^2$ 计算，其中 $(\\lambda, Q_A)$ 和 $(\\mu, Q_B)$ 是 $A$ 和 $B$ 的特征对，且 $C=Q_A^{\\mathsf{T}}Q_B$。该值必须在数值上与直接值匹配。\n$3$. “配对和”需要建立特征值之间的最优对应关系。标准的数值特征求解器会对特征值进行排序，这可能会破坏配对关系。一个稳健的方法是找到索引 $\\{1,2,3\\}$ 的一个排列 $\\pi$，使得总特征向量对齐度 $\\sum_{i=1}^3 |C_{i, \\pi(i)}|$ 最大化。这是一个经典的指派问题，可以高效求解。配对和则为 $\\sum_{i=1}^3 \\lambda_i \\mu_{\\pi(i)}$。\n$4$. 简化公式有效性的布尔检查将直接值与此配对和在给定的数值容差内进行比较。当且仅当张量共轴时，等式成立。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests an algorithm for computing the double dot\n    product of two second-order tensors using spectral decomposition.\n    \"\"\"\n    \n    # Numerical tolerance for comparisons\n    TOLERANCE = 1e-12\n\n    def R_x(phi):\n        \"\"\"Rotation matrix about the x-axis.\"\"\"\n        c, s = np.cos(phi), np.sin(phi)\n        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])\n\n    def R_y(alpha):\n        \"\"\"Rotation matrix about the y-axis.\"\"\"\n        c, s = np.cos(alpha), np.sin(alpha)\n        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])\n\n    def R_z(theta):\n        \"\"\"Rotation matrix about the z-axis.\"\"\"\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n\n    def compute_metrics(A, B):\n        \"\"\"\n        Computes the double dot product using three methods and checks equality.\n\n        Args:\n            A (np.ndarray): A 3x3 real symmetric tensor.\n            B (np.ndarray): A 3x3 real symmetric tensor.\n        \n        Returns:\n            list: [direct_val, spectral_val, paired_sum_val, is_equal_bool]\n        \"\"\"\n        # 1. Direct component-wise computation: A:B = sum(A_ij * B_ij)\n        # This is the ground truth value.\n        direct_val = np.sum(A * B)\n\n        # 2. Spectral decomposition\n        # np.linalg.eigh is used for real symmetric matrices.\n        # It returns eigenvalues in ascending order and corresponding eigenvectors.\n        lambda_vals, Q_A = np.linalg.eigh(A)\n        mu_vals, Q_B = np.linalg.eigh(B)\n\n        # 3. General spectral formula computation: A:B = sum_{i,j} lambda_j * mu_i * C_ji^2\n        # C is the alignment matrix C = Q_A^T @ Q_B.\n        C = Q_A.T @ Q_B\n        C_sq = C**2\n        \n        # Create outer products of eigenvalues and multiply element-wise with C_sq\n        # The sum is over j (rows) and i (columns): sum_{j,i} lambda_j mu_i C_ji^2\n        # `lambda_vals[:, None]` is a column vector (3,1) of eigenvalues of A\n        # `mu_vals[None, :]` is a row vector (1,3) of eigenvalues of B\n        lambda_mu_matrix = lambda_vals[:, np.newaxis] * mu_vals[np.newaxis, :]\n        spectral_val = np.sum(lambda_mu_matrix * C_sq)\n\n        # 4. Paired eigenvalue sum: sum_i lambda_i * mu_pi(i)\n        # We must find the optimal pairing of eigenvectors that maximizes alignment.\n        # This is an assignment problem. We want to maximize sum(|C_ij|) for a permutation.\n        # linear_sum_assignment finds a minimum cost assignment.\n        # Cost is set to -|C| to maximize |C|.\n        cost_matrix = -np.abs(C)\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        # 'col_ind' contains the permutation of B's eigenvalues that best aligns\n        # with A's eigenvalues (which are in sorted order, indices 0,1,2).\n        paired_sum_val = np.sum(lambda_vals * mu_vals[col_ind])\n\n        # 5. Check if the simplified co-axial formula holds\n        is_equal_bool = np.isclose(direct_val, paired_sum_val, atol=TOLERANCE, rtol=0)\n\n        return [direct_val, spectral_val, paired_sum_val, is_equal_bool]\n\n    # --- Test Suite ---\n    test_cases = []\n\n    # Case 1: Co-axial, diagonal tensors\n    A1 = np.diag([3., 2., 1.])\n    B1 = np.diag([5., -1., 4.])\n    test_cases.append((A1, B1))\n\n    # Case 2: Co-axial tensors, rotated eigenbasis\n    theta = np.pi / 4.\n    Rz = R_z(theta)\n    L_A2 = np.diag([7., 0., -2.])\n    L_B2 = np.diag([1., 3., 4.])\n    A2 = Rz @ L_A2 @ Rz.T\n    B2 = Rz @ L_B2 @ Rz.T\n    test_cases.append((A2, B2))\n\n    # Case 3: Non-co-axial tensors\n    phi = np.pi / 6.\n    Rx = R_x(phi)\n    A3 = np.diag([2., -1., 3.])\n    L_B3 = np.diag([4., 6., -2.])\n    B3 = Rx @ L_B3 @ Rx.T\n    test_cases.append((A3, B3))\n\n    # Case 4: Isotropic tensor with another tensor (always co-axial)\n    alpha = np.pi / 7.\n    Ry = R_y(alpha)\n    A4 = 5. * np.identity(3)\n    L_B4 = np.diag([10., -2., 1.])\n    B4 = Ry @ L_B4 @ Ry.T\n    test_cases.append((A4, B4))\n\n    # --- Execution and Output ---\n    results_list = []\n    for A, B in test_cases:\n        case_results = compute_metrics(A, B)\n        results_list.append(case_results)\n\n    # Format output string exactly as required.\n    # Eg: [[case1_val1,case1_val2,...],[case2_val1,case2_val2,...]]\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, bool):\n                items.append(str(item).lower())\n            else:\n                items.append(f\"{item:.14g}\") # Use general format for precision\n        return f\"[{','.join(items)}]\"\n\n    output_str = f\"[{','.join(map(format_list, results_list))}]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}