{
    "hands_on_practices": [
        {
            "introduction": "To truly master computational mechanics, one must look beyond simply using finite element software and understand how its core components are constructed. This practice guides you through the foundational derivation of the geometric stiffness matrix, $K_G$, from first principles. By analytically calculating the explicit matrix for a simple bilinear quadrilateral element under a predefined stress state, you will connect the abstract concept of the linearized virtual work to a tangible, numerical entity, demystifying a critical component for any nonlinear or stability analysis .",
            "id": "3579573",
            "problem": "Consider a single isoparametric bilinear quadrilateral element in the Finite Element Method (FEM) under plane stress, occupying a rectangle in the physical coordinates $\\{x,y\\}$ with $x \\in [-a,a]$, $y \\in [-b,b]$, and constant thickness $t$. The mapping from the natural coordinates $(\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ is $x = a \\,\\xi$ and $y = b \\,\\eta$, with the standard bilinear shape functions $N_{1}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$, $N_{2}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$, $N_{3}(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$, and $N_{4}(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$. Assume a uniform initial Cauchy stress field with $\\sigma_{xx} = \\sigma_{0}$ and $\\sigma_{yy} = \\sigma_{xy} = 0$ throughout the element. Using the Principle of Virtual Work and its linearization about the pre-stressed configuration, derive the geometric stiffness matrix $K_{G}$ in terms of the shape function gradients and the initial stress, and then evaluate the resulting integrals exactly for this element.\n\nAdopt the nodal degree-of-freedom ordering $\\{u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}\\}$ and compute the explicit $8 \\times 8$ analytic expression of $K_G$ in closed form in terms of $a$, $b$, $t$, and $\\sigma_{0}$. In your derivation, verify that the resulting matrix is symmetric. Express the final answer as a single closed-form matrix expression; no numerical rounding is required and no physical units need be specified in the answer.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in computational solid mechanics, specifically in the context of stability analysis using the Finite Element Method (FEM). All necessary information is provided, and the problem is free of contradictions or ambiguities. We may therefore proceed with the derivation.\n\nThe geometric stiffness matrix, $K_G$, arises from the linearization of the internal virtual work, accounting for the effect of an initial stress state on the element's stiffness. The contribution to the internal virtual work from this initial stress is given by:\n$$ \\delta W_{G} = \\int_{V_0} \\boldsymbol{S}^{(0)} : \\delta \\boldsymbol{E}_{NL} \\, dV_0 $$\nwhere $V_0$ is the volume of the element in the initial configuration, $\\boldsymbol{S}^{(0)}$ is the initial Second Piola-Kirchhoff stress tensor (which is equal to the initial Cauchy stress tensor $\\boldsymbol{\\sigma}^{(0)}$ as the configuration is unstrained), and $\\delta \\boldsymbol{E}_{NL}$ is the variation of the nonlinear part of the Green-Lagrange strain tensor. The nonlinear strain term is $\\boldsymbol{E}_{NL} = \\frac{1}{2} (\\nabla \\boldsymbol{u})^T (\\nabla \\boldsymbol{u})$, where $\\boldsymbol{u}$ is the displacement field and $\\nabla \\boldsymbol{u}$ is its gradient. The variation is $\\delta \\boldsymbol{E}_{NL} = \\frac{1}{2} [(\\nabla \\delta \\boldsymbol{u})^T (\\nabla \\boldsymbol{u}) + (\\nabla \\boldsymbol{u})^T (\\nabla \\delta \\boldsymbol{u})]$.\n\nSince $\\boldsymbol{S}^{(0)}$ is symmetric, the integrand becomes $\\boldsymbol{S}^{(0)} : \\delta \\boldsymbol{E}_{NL} = \\text{Tr}(\\boldsymbol{S}^{(0)} (\\nabla \\delta \\boldsymbol{u})^T (\\nabla \\boldsymbol{u}))$. In matrix-vector notation for a 2D problem, this can be written as:\n$$ \\delta W_G = \\int_{V_0} \\begin{pmatrix} \\frac{\\partial \\delta u_x}{\\partial x} & \\frac{\\partial \\delta u_y}{\\partial x} \\\\ \\frac{\\partial \\delta u_x}{\\partial y} & \\frac{\\partial \\delta u_y}{\\partial y} \\end{pmatrix} : \\begin{pmatrix} \\sigma_{xx}^{(0)} & \\sigma_{xy}^{(0)} \\\\ \\sigma_{yx}^{(0)} & \\sigma_{yy}^{(0)} \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial u_x}{\\partial x} & \\frac{\\partial u_x}{\\partial y} \\\\ \\frac{\\partial u_y}{\\partial x} & \\frac{\\partial u_y}{\\partial y} \\end{pmatrix} \\, dV_0 $$\nExpanding this expression gives the integrand:\n$$ \\sigma_{xx}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial x}\\right) + \\sigma_{yy}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial y} \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial \\delta u_y}{\\partial y} \\frac{\\partial u_y}{\\partial y}\\right) + \\sigma_{xy}^{(0)} \\left(\\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial \\delta u_x}{\\partial y} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial \\delta u_y}{\\partial y} \\frac{\\partial u_y}{\\partial x}\\right) $$\nGiven the initial stress state $\\sigma_{xx}^{(0)} = \\sigma_0$ and $\\sigma_{yy}^{(0)} = \\sigma_{xy}^{(0)} = 0$, the expression simplifies significantly to:\n$$ \\delta W_G = \\int_{V_0} \\sigma_0 \\left( \\frac{\\partial \\delta u_x}{\\partial x} \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial \\delta u_y}{\\partial x} \\frac{\\partial u_y}{\\partial x} \\right) \\, dV_0 $$\nThe displacement field $\\boldsymbol{u}(\\xi, \\eta) = (u_x, u_y)$ is interpolated from the nodal displacements $\\boldsymbol{d}$ using the shape functions $N_i(\\xi, \\eta)$:\n$$ u_x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ix} \\quad \\text{and} \\quad u_y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{iy} $$\nThe nodal displacement vector is $\\boldsymbol{d} = \\{u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}, u_{4x}, u_{4y}\\}^T$. Substituting the interpolated displacements into the expression for $\\delta W_G$:\n$$ \\delta W_G = \\int_{V_0} \\sigma_0 \\left( \\left(\\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x} \\delta u_{ix}\\right) \\left(\\sum_{j=1}^{4} \\frac{\\partial N_j}{\\partial x} u_{jx}\\right) + \\left(\\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x} \\delta u_{iy}\\right) \\left(\\sum_{j=1}^{4} \\frac{\\partial N_j}{\\partial x} u_{jy}\\right) \\right) \\, dV_0 $$\nThis is a bilinear form $\\delta \\boldsymbol{d}^T K_G \\boldsymbol{d}$. The components of the geometric stiffness matrix $K_G$ are given by:\n$$ (K_G)_{2i-1, 2j-1} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\n$$ (K_G)_{2i, 2j} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\nand all off-diagonal blocks $(K_G)_{2i-1, 2j}$ and $(K_G)_{2i, 2j-1}$ are zero. This structure shows that $K_G$ is symmetric since the integral is symmetric with respect to indices $i$ and $j$. The matrix can be expressed as a Kronecker product $K_G = \\boldsymbol{k} \\otimes \\boldsymbol{I}_2$, where $\\boldsymbol{I}_2$ is the $2 \\times 2$ identity matrix and $\\boldsymbol{k}$ is a $4 \\times 4$ matrix with components:\n$$ k_{ij} = \\int_{V_0} \\sigma_0 \\frac{\\partial N_i}{\\partial x} \\frac{\\partial N_j}{\\partial x} \\, dV_0 $$\nThe integral must be transformed to the natural coordinate system $(\\xi, \\eta)$. The differential volume is $dV_0 = t \\, dx \\, dy = t \\, \\det(\\boldsymbol{J}) \\, d\\xi \\, d\\eta$, where $\\boldsymbol{J}$ is the Jacobian matrix of the mapping.\nThe mapping is given by $x=a\\xi$ and $y=b\\eta$. The Jacobian is:\n$$ \\boldsymbol{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} a & 0 \\\\ 0 & b \\end{pmatrix} $$\nThe determinant is $\\det(\\boldsymbol{J}) = ab$. The relation between physical and natural coordinate derivatives is given by the chain rule:\n$$ \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\boldsymbol{J}^{-1} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1/a & 0 \\\\ 0 & 1/b \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{pmatrix} $$\nThis gives $\\frac{\\partial N_i}{\\partial x} = \\frac{1}{a} \\frac{\\partial N_i}{\\partial \\xi}$. Substituting this into the integral for $k_{ij}$:\n$$ k_{ij} = \\int_{-1}^{1} \\int_{-1}^{1} \\sigma_0 \\left( \\frac{1}{a} \\frac{\\partial N_i}{\\partial \\xi} \\right) \\left( \\frac{1}{a} \\frac{\\partial N_j}{\\partial \\xi} \\right) t (ab) \\, d\\xi \\, d\\eta = \\frac{\\sigma_0 t b}{a} \\int_{-1}^{1} \\int_{-1}^{1} \\frac{\\partial N_i}{\\partial \\xi} \\frac{\\partial N_j}{\\partial \\xi} \\, d\\xi \\, d\\eta $$\nNext, we compute the derivatives of the shape functions with respect to $\\xi$:\n$N_{1} = \\frac{1}{4}(1-\\xi)(1-\\eta) \\implies \\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta)$\n$N_{2} = \\frac{1}{4}(1+\\xi)(1-\\eta) \\implies \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta)$\n$N_{3} = \\frac{1}{4}(1+\\xi)(1+\\eta) \\implies \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta)$\n$N_{4} = \\frac{1}{4}(1-\\xi)(1+\\eta) \\implies \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta)$\nNow we evaluate the integrals of the products of these derivatives.\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1-\\eta)^2 \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1-2\\eta+\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta-\\eta^2+\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{1}{3} - (-\\frac{7}{3}) \\right) = \\frac{1}{3} $$\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1+\\eta)^2 \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1+2\\eta+\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta+\\eta^2+\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{7}{3} - (-\\frac{1}{3}) \\right) = \\frac{1}{3} $$\n$$ \\int_{-1}^{1} \\int_{-1}^{1} \\left(\\frac{1}{4}\\right)^2 (1-\\eta)(1+\\eta) \\, d\\xi d\\eta = \\frac{1}{16} [\\xi]_{-1}^1 \\int_{-1}^1 (1-\\eta^2)d\\eta = \\frac{2}{16} \\left[\\eta-\\frac{\\eta^3}{3}\\right]_{-1}^1 = \\frac{1}{8} \\left( \\frac{2}{3} - (-\\frac{2}{3}) \\right) = \\frac{1}{6} $$\nUsing these results, we construct the matrix $\\boldsymbol{k}$. Let $C = \\frac{\\sigma_0 t b}{a}$.\n$k_{11} = C \\cdot (1) \\cdot \\frac{1}{3}$, $k_{12} = C \\cdot (-1) \\cdot \\frac{1}{3}$, $k_{13} = C \\cdot (-1) \\cdot \\frac{1}{6}$, $k_{14} = C \\cdot (1) \\cdot \\frac{1}{6}$\n$k_{22} = C \\cdot (1) \\cdot \\frac{1}{3}$, $k_{23} = C \\cdot (1) \\cdot \\frac{1}{6}$, $k_{24} = C \\cdot (-1) \\cdot \\frac{1}{6}$\n$k_{33} = C \\cdot (1) \\cdot \\frac{1}{3}$, $k_{34} = C \\cdot (-1) \\cdot \\frac{1}{3}$\n$k_{44} = C \\cdot (1) \\cdot \\frac{1}{3}$\nAssembling the symmetric matrix $\\boldsymbol{k}$:\n$$ \\boldsymbol{k} = \\frac{\\sigma_0 t b}{a} \\begin{pmatrix} 1/3 & -1/3 & -1/6 & 1/6 \\\\ -1/3 & 1/3 & 1/6 & -1/6 \\\\ -1/6 & 1/6 & 1/3 & -1/3 \\\\ 1/6 & -1/6 & -1/3 & 1/3 \\end{pmatrix} = \\frac{\\sigma_0 t b}{6a} \\begin{pmatrix} 2 & -2 & -1 & 1 \\\\ -2 & 2 & 1 & -1 \\\\ -1 & 1 & 2 & -2 \\\\ 1 & -1 & -2 & 2 \\end{pmatrix} $$\nThe final $8 \\times 8$ geometric stiffness matrix $K_G = \\boldsymbol{k} \\otimes \\boldsymbol{I}_2$ is constructed by replacing each element $k_{ij}$ with the block $k_{ij}\\boldsymbol{I}_2$:\n$$ K_G = \\frac{\\sigma_0 t b}{6a} \\begin{pmatrix}\n 2\\boldsymbol{I}_2 & -2\\boldsymbol{I}_2 & -1\\boldsymbol{I}_2 &  1\\boldsymbol{I}_2 \\\\\n-2\\boldsymbol{I}_2 &  2\\boldsymbol{I}_2 &  1\\boldsymbol{I}_2 & -1\\boldsymbol{I}_2 \\\\\n-1\\boldsymbol{I}_2 &  1\\boldsymbol{I}_2 &  2\\boldsymbol{I}_2 & -2\\boldsymbol{I}_2 \\\\\n 1\\boldsymbol{I}_2 & -1\\boldsymbol{I}_2 & -2\\boldsymbol{I}_2 &  2\\boldsymbol{I}_2\n\\end{pmatrix} $$\nExpanding this into the full $8 \\times 8$ matrix yields the final result. The matrix is symmetric, as confirmed by the symmetry of $\\boldsymbol{k}$.",
            "answer": "$$\n\\boxed{\\frac{\\sigma_{0} t b}{6a} \\begin{pmatrix}\n 2 &  0 & -2 &  0 & -1 &  0 &  1 &  0 \\\\\n 0 &  2 &  0 & -2 &  0 & -1 &  0 &  1 \\\\\n-2 &  0 &  2 &  0 &  1 &  0 & -1 &  0 \\\\\n 0 & -2 &  0 &  2 &  0 &  1 &  0 & -1 \\\\\n-1 &  0 &  1 &  0 &  2 &  0 & -2 &  0 \\\\\n 0 & -1 &  0 &  1 &  0 &  2 &  0 & -2 \\\\\n 1 &  0 & -1 &  0 & -2 &  0 &  2 &  0 \\\\\n 0 &  1 &  0 & -1 &  0 & -2 &  0 &  2\n\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from analytical derivation to numerical implementation, we now explore *why* the geometric stiffness matrix is so crucial in practice. This exercise simulates a pre-tensioned membrane, a system where geometric effects are dominant and the material stiffness alone is insufficient to capture the physics. By coding a simple Newton-Raphson solver and comparing its convergence behavior with and without the $K_{\\text{geo}}$ term, you will gain direct, hands-on experience with how geometric stiffness stabilizes the numerical scheme and enables the rapid, quadratic convergence expected of a consistent tangent formulation .",
            "id": "3579552",
            "problem": "Consider a taut rectangular membrane modeled within the framework of the Finite Element Method (FEM) using a single assumed out-of-plane mode. The membrane occupies the domain $\\Omega = [0,L] \\times [0,W]$, has thickness $t$, isotropic linear elastic material with Young’s modulus $E$ and Poisson’s ratio $\\nu$, and is initially pre-tensioned with uniform in-plane stress resultants $N_{0x} = N_{0y} = T_0$ and $N_{0xy} = 0$, where $T_0$ is specified in $\\mathrm{N}/\\mathrm{m}$. The out-of-plane displacement is restricted to the form $w(x,y) = u\\,\\phi(x,y)$ with a single generalized coordinate $u \\in \\mathbb{R}$ and a smooth mode shape $\\phi(x,y)$ that satisfies essential boundary conditions appropriate to the membrane problem. Let the external transverse pressure $p$ (in $\\mathrm{N}/\\mathrm{m}^2$) act uniformly on the membrane.\n\nFrom the Principle of Virtual Work and the von Kármán strain approximations for a membrane, the weak form leads to a scalar nonlinear residual $R(u)$ in terms of the generalized coordinate $u$. The total consistent tangent stiffness $K_t(u)$ decomposes additively into a geometric stiffness contribution $K_{\\text{geo}}$ arising from the initial stress state and a material stiffness contribution $K_{\\text{mat}}(u)$ arising from the constitutive law and the kinematic nonlinearity. The geometric stiffness $K_{\\text{geo}}$ is independent of $u$, whereas $K_{\\text{mat}}(u)$ depends on $u$ due to the nonlinear membrane strains.\n\nYour goal is to implement a program that performs Newton iterations to solve $R(u) = 0$ under two linearization strategies:\n- Strategy A (full tangent): use the full consistent tangent $K_t(u) = K_{\\text{geo}} + K_{\\text{mat}}(u)$.\n- Strategy B (neglect geometric stiffness): use the reduced tangent $K_t^{\\neg \\text{geo}}(u) = K_{\\text{mat}}(u)$ while keeping the same residual $R(u)$.\n\nYou must:\n1. Start from the Principle of Virtual Work and the von Kármán membrane kinematics to express the scalar residual $R(u)$ as a function of $u$ for the single-mode approximation $w=u\\phi$. Using the definitions of the in-plane membrane strain measures $\\varepsilon_x$, $\\varepsilon_y$, and $\\gamma_{xy}$ under von Kármán assumptions, and the plane-stress constitutive law for the stress resultants $\\mathbf{N} = \\mathbf{C}\\,\\boldsymbol{\\varepsilon}$ (with $\\mathbf{C}$ being the standard isotropic membrane stiffness matrix, expressed in terms of $E$, $\\nu$, and $t$), derive the structure of $R(u)$ in terms of integrals over $\\Omega$ that involve derivatives of $\\phi$. These integrals define two scalar coefficients that will be needed by the algorithm:\n   - A geometric coefficient $\\alpha$ coming from the virtual work of the initial stress resultants $N_{0x}$, $N_{0y}$ and the variation of the membrane strains.\n   - A material coefficient $\\beta$ coming from the virtual work of the constitutive stress resultants $\\mathbf{N} = \\mathbf{C}\\,\\boldsymbol{\\varepsilon}$ and the variation of the membrane strains.\n   The external load contributes a generalized load amplitude $F$, which is the projection of $p$ onto the mode shape $\\phi$. The final scalar residual must take the form $R(u) = \\alpha\\,T_0\\,u + \\beta\\,u^3 - F$, and the consistent tangent must take the form $K_t(u) = \\alpha\\,T_0 + 3\\,\\beta\\,u^2$. The geometric and material tangent contributions are $K_{\\text{geo}} = \\alpha\\,T_0$ and $K_{\\text{mat}}(u) = 3\\,\\beta\\,u^2$, respectively. All definitions of $\\alpha$, $\\beta$, and $F$ must be given as integrals over $\\Omega$ in terms of $\\phi$ and its derivatives, derived from first principles as specified. Use the mode shape $\\phi(x,y) = \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{W}\\right)$.\n\n2. Implement a Newton solver for both strategies A and B. Use the same initial guess $u_0$ for both strategies, chosen based on a physically motivated approximation so that $u_0$ is strictly positive when $F>0$. Perform backtracking line search if needed to ensure a decrease in $|R(u)|$ at each iteration. Use a convergence tolerance on the residual magnitude of $\\varepsilon_{\\text{tol}} = 10^{-12}$ in $\\mathrm{N}$, and a maximum of $50$ iterations. Measure, for each strategy:\n   - The number of Newton iterations required to converge (an integer).\n   - The average residual reduction rate per iteration, defined as the arithmetic mean of the ratios $r_k = \\frac{|R(u_{k+1})|}{|R(u_k)|}$ over all accepted iterations before convergence (a float).\n\n3. Units must be consistent: $L$ and $W$ are in $\\mathrm{m}$, $t$ in $\\mathrm{m}$, $E$ in $\\mathrm{Pa}$, $\\nu$ is dimensionless, $T_0$ in $\\mathrm{N}/\\mathrm{m}$, $p$ in $\\mathrm{N}/\\mathrm{m}^2$, $u$ in $\\mathrm{m}$, $R(u)$ and $F$ in $\\mathrm{N}$, and stiffnesses in $\\mathrm{N}/\\mathrm{m}$. Report the average residual reduction rate as a dimensionless float, and the iteration count as an integer.\n\n4. Use the following test suite of parameter sets, each specified as a tuple $(L,W,t,E,\\nu,T_0,p)$, with all quantities expressed in the stated units:\n   - Test $1$: $(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,1000\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$.\n   - Test $2$: $(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,100\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$.\n   - Test $3$: $(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,0\\,\\mathrm{N}/\\mathrm{m},\\,1000\\,\\mathrm{N}/\\mathrm{m}^2)$.\n   - Test $4$: $(1.0\\,\\mathrm{m},\\,1.0\\,\\mathrm{m},\\,1.0\\times 10^{-4}\\,\\mathrm{m},\\,1.0\\times 10^{8}\\,\\mathrm{Pa},\\,0.3,\\,1000\\,\\mathrm{N}/\\mathrm{m},\\,5000\\,\\mathrm{N}/\\mathrm{m}^2)$.\n\n5. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sub-list of the form $[\\text{iters\\_full},\\text{iters\\_no\\_geo},\\text{avg\\_rate\\_full},\\text{avg\\_rate\\_no\\_geo}]$, with iteration counts as integers and average rates as floats. For example, the output should look like $\\left[\\left[i_1,j_1,r_1,s_1\\right],\\left[i_2,j_2,r_2,s_2\\right],\\left[i_3,j_3,r_3,s_3\\right],\\left[i_4,j_4,r_4,s_4\\right]\\right]$.\n\nYour implementation must be a complete, runnable program that computes $\\alpha$, $\\beta$, and $F$ from the stated integrals using the given mode shape $\\phi(x,y)$, performs the Newton iterations for both strategies A and B, and reports the requested metrics for the provided test suite in the exact format described.",
            "solution": "The user problem is deemed valid after careful evaluation. It is scientifically grounded in the principles of nonlinear solid mechanics, well-posed, and all necessary data and conditions for a unique solution are provided. The task involves a standard derivation in computational mechanics followed by the implementation of a numerical solution algorithm.\n\nThe solution is developed from the Principle of Virtual Work (PVW) for a single-mode approximation of a pre-tensioned membrane. The PVW states that for a system in equilibrium, the internal virtual work, $\\delta W_{\\text{int}}$, equals the external virtual work, $\\delta W_{\\text{ext}}$, for any kinematically admissible virtual displacement.\n\n$$ \\delta W_{\\text{int}} = \\delta W_{\\text{ext}} $$\n\nThe residual of the nonlinear system, $R(u)$, is defined by the PVW as $R(u) \\delta u = \\delta W_{\\text{int}} - \\delta W_{\\text{ext}} = 0$. Since this must hold for any arbitrary virtual displacement of the generalized coordinate, $\\delta u$, the term $R(u)$ must be zero.\n\nThe out-of-plane displacement $w$ and its variation $\\delta w$ are approximated using a single mode shape $\\phi(x,y)$ and a generalized coordinate $u$:\n$$ w(x,y) = u\\,\\phi(x,y) $$\n$$ \\delta w(x,y) = \\delta u\\,\\phi(x,y) $$\n\nThe internal virtual work is computed by integrating the contraction of the stress tensor with the variation of the strain tensor over the volume. For a thin membrane, this is expressed using stress resultants $\\mathbf{N}$ and membrane strains $\\boldsymbol{\\varepsilon}$. Using the material description with the Second Piola-Kirchhoff stress resultant $\\mathbf{N}^S$ and the Green-Lagrange strain $\\boldsymbol{\\varepsilon}_L$, the internal virtual work is:\n$$ \\delta W_{\\text{int}} = \\int_{\\Omega} (\\mathbf{N}^S)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA $$\nThe total stress resultant is the sum of the initial pre-tension $\\mathbf{N}_0$ and the elastically generated stress resultant $\\Delta\\mathbf{N}^S$, such that $\\mathbf{N}^S = \\mathbf{N}_0 + \\Delta\\mathbf{N}^S$. The Green-Lagrange membrane strains under von Kármán assumptions (neglecting in-plane displacements in the strain-displacement relations) are purely nonlinear:\n$$ \\boldsymbol{\\varepsilon}_L = \\begin{Bmatrix} \\varepsilon_x \\\\ \\varepsilon_y \\\\ \\gamma_{xy} \\end{Bmatrix} = \\frac{1}{2} u^2 \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2 \\phi_{,x} \\phi_{,y} \\end{Bmatrix} $$\nIts variation with respect to $u$ is:\n$$ \\delta\\boldsymbol{\\varepsilon}_L = \\frac{\\partial \\boldsymbol{\\varepsilon}_L}{\\partial u} \\delta u = u\\,\\delta u \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2 \\phi_{,x} \\phi_{,y} \\end{Bmatrix} $$\nThe constitutive relation for the change in stress is $\\Delta\\mathbf{N}^S = \\mathbf{C} \\boldsymbol{\\varepsilon}_L$, where $\\mathbf{C}$ is the plane-stress membrane stiffness matrix.\nThe internal virtual work can be additively decomposed:\n$$ \\delta W_{\\text{int}} = \\int_{\\Omega} (\\mathbf{N}_0 + \\mathbf{C}\\boldsymbol{\\varepsilon}_L)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA = \\underbrace{\\int_{\\Omega} \\mathbf{N}_0^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA}_{\\delta W_{\\text{geo}}} + \\underbrace{\\int_{\\Omega} (\\mathbf{C}\\boldsymbol{\\varepsilon}_L)^T \\delta\\boldsymbol{\\varepsilon}_L \\,dA}_{\\delta W_{\\text{mat}}} $$\n\nThe first term, $\\delta W_{\\text{geo}}$, represents the work done by the initial stress field. With $\\mathbf{N}_0 = \\{T_0, T_0, 0\\}^T$:\n$$ \\delta W_{\\text{geo}} = \\int_{\\Omega} \\begin{Bmatrix} T_0 \\\\ T_0 \\\\ 0 \\end{Bmatrix}^T \\left( u\\,\\delta u \\begin{Bmatrix} \\phi_{,x}^2 \\\\ \\phi_{,y}^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix} \\right) \\,dA = \\left( T_0 u \\int_{\\Omega} (\\phi_{,x}^2 + \\phi_{,y}^2) \\,dA \\right) \\delta u $$\nThis defines the geometric coefficient $\\alpha$:\n$$ \\alpha = \\int_{\\Omega} \\left( \\left(\\frac{\\partial\\phi}{\\partial x}\\right)^2 + \\left(\\frac{\\partial\\phi}{\\partial y}\\right)^2 \\right) \\,dA $$\nThe contribution to the residual is $\\alpha T_0 u$.\n\nThe second term, $\\delta W_{\\text{mat}}$, represents the work done by the elastic stresses.\n$$ \\delta W_{\\text{mat}} = \\int_{\\Omega} \\boldsymbol{\\varepsilon}_L^T \\mathbf{C} \\delta\\boldsymbol{\\varepsilon}_L \\,dA = \\int_{\\Omega} \\left(\\frac{1}{2}u^2 \\mathbf{v}^T \\mathbf{C}\\right) (u\\,\\delta u\\,\\mathbf{v}) \\,dA = \\left( \\frac{1}{2}u^3 \\int_{\\Omega} \\mathbf{v}^T \\mathbf{C} \\mathbf{v} \\,dA \\right)\\delta u $$\nwhere $\\mathbf{v} = \\{\\phi_{,x}^2, \\phi_{,y}^2, 2\\phi_{,x}\\phi_{,y}\\}^T$. This defines the material coefficient $\\beta$:\n$$ \\beta = \\frac{1}{2} \\int_{\\Omega} \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix}^T \\mathbf{C} \\begin{Bmatrix} (\\phi_{,x})^2 \\\\ (\\phi_{,y})^2 \\\\ 2\\phi_{,x}\\phi_{,y} \\end{Bmatrix} \\,dA $$\nThe plane-stress constitutive matrix is:\n$$ \\mathbf{C} = \\frac{E t}{1-\\nu^2} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{bmatrix} $$\nSubstituting $\\mathbf{C}$ into the expression for $\\beta$ and simplifying yields:\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\int_{\\Omega} \\left( (\\phi_{,x}^2 + \\phi_{,y}^2)^2 + (2\\nu - 1) (\\phi_{,x}^2 \\phi_{,y}^2 - (\\phi_{,x}\\phi_{,y})^2) \\right) \\, dA $$\nFor the chosen mode shape, $\\phi_{,x} \\propto \\cos(\\cdot)\\sin(\\cdot)$ and $\\phi_{,y} \\propto \\sin(\\cdot)\\cos(\\cdot)$, so $\\phi_{,x}^2 \\phi_{,y}^2 = (\\phi_{,x}\\phi_{,y})^2$, which simplifies the integrand considerably:\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\int_{\\Omega} (\\phi_{,x}^2 + \\phi_{,y}^2)^2 \\, dA $$\n\nThe external virtual work $\\delta W_{\\text{ext}}$ due to a uniform pressure $p$ is:\n$$ \\delta W_{\\text{ext}} = \\int_{\\Omega} p\\,\\delta w \\,dA = \\int_{\\Omega} p\\,(\\phi\\,\\delta u) \\,dA = \\left( p \\int_{\\Omega} \\phi \\,dA \\right) \\delta u $$\nThis defines the generalized force $F$:\n$$ F = p \\int_{\\Omega} \\phi \\,dA $$\n\nCombining terms, the scalar residual equation $R(u)=0$ is:\n$$ R(u) = \\alpha T_0 u + \\beta u^3 - F = 0 $$\nThe consistent tangent stiffness $K_t(u)$ is the derivative of the residual with respect to $u$:\n$$ K_t(u) = \\frac{dR}{du} = \\alpha T_0 + 3\\beta u^2 $$\nThis naturally decomposes into the geometric stiffness $K_{\\text{geo}} = \\alpha T_0$ and the material stiffness $K_{\\text{mat}}(u) = 3\\beta u^2$.\n\nThe coefficients $\\alpha$, $\\beta$, and $F$ are calculated for the mode shape $\\phi(x,y) = \\sin(\\frac{\\pi x}{L})\\sin(\\frac{\\pi y}{W})$ over the domain $\\Omega = [0,L] \\times [0,W]$. The required integrals are evaluated as follows:\n$$ \\int_0^L \\sin^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{2}, \\quad \\int_0^L \\cos^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{2} $$\n$$ \\int_0^L \\sin^4\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{3L}{8}, \\quad \\int_0^L \\cos^4\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{3L}{8} $$\n$$ \\int_0^L \\sin^2\\left(\\frac{\\pi x}{L}\\right)\\cos^2\\left(\\frac{\\pi x}{L}\\right)dx = \\frac{L}{8} $$\nThese identities apply analogously for integration with respect to $y$ over $[0,W]$.\n\nCalculation of $F$:\n$$ F = p \\int_0^L \\sin\\left(\\frac{\\pi x}{L}\\right)dx \\int_0^W \\sin\\left(\\frac{\\pi y}{W}\\right)dy = p \\left(\\frac{2L}{\\pi}\\right) \\left(\\frac{2W}{\\pi}\\right) = \\frac{4LWp}{\\pi^2} $$\n\nCalculation of $\\alpha$:\n$$ \\alpha = \\int_0^L \\hspace{-2mm} \\int_0^W \\hspace{-2mm} \\left(\\left(\\frac{\\pi}{L}\\right)^2 \\cos^2\\left(\\frac{\\pi x}{L}\\right)\\sin^2\\left(\\frac{\\pi y}{W}\\right) + \\left(\\frac{\\pi}{W}\\right)^2 \\sin^2\\left(\\frac{\\pi x}{L}\\right)\\cos^2\\left(\\frac{\\pi y}{W}\\right)\\right) dy dx $$\n$$ \\alpha = \\left(\\frac{\\pi}{L}\\right)^2 \\left(\\frac{L}{2}\\right)\\left(\\frac{W}{2}\\right) + \\left(\\frac{\\pi}{W}\\right)^2 \\left(\\frac{L}{2}\\right)\\left(\\frac{W}{2}\\right) = \\frac{\\pi^2 W}{4L} + \\frac{\\pi^2 L}{4W} = \\frac{\\pi^2}{4}\\left(\\frac{W}{L} + \\frac{L}{W}\\right) $$\n\nCalculation for $\\beta$: The integral required is $\\int_\\Omega (\\phi_{,x}^2 + \\phi_{,y}^2)^2 \\, dA$.\n$$ (\\phi_{,x}^2 + \\phi_{,y}^2)^2 = \\left(\\left(\\frac{\\pi}{L}\\right)^2 c_x^2 s_y^2 + \\left(\\frac{\\pi}{W}\\right)^2 s_x^2 c_y^2\\right)^2 = \\left(\\frac{\\pi}{L}\\right)^4 c_x^4 s_y^4 + \\left(\\frac{\\pi}{W}\\right)^4 s_x^4 c_y^4 + 2\\left(\\frac{\\pi^2}{LW}\\right)^2 c_x^2 s_x^2 c_y^2 s_y^2 $$\nwhere $s_x = \\sin(\\pi x/L)$, $c_y = \\cos(\\pi y/W)$, etc. Integrating term by term:\n$$ \\int_{\\Omega} (\\phi_{,x}^2+\\phi_{,y}^2)^2 dA = \\left(\\frac{\\pi}{L}\\right)^4\\left(\\frac{3L}{8}\\right)\\left(\\frac{3W}{8}\\right) + \\left(\\frac{\\pi}{W}\\right)^4\\left(\\frac{3L}{8}\\right)\\left(\\frac{3W}{8}\\right) + 2\\left(\\frac{\\pi^2}{LW}\\right)^2\\left(\\frac{L}{8}\\right)\\left(\\frac{W}{8}\\right) $$\n$$ = \\frac{9\\pi^4 W}{64 L^3} + \\frac{9\\pi^4 L}{64 W^3} + \\frac{2\\pi^4}{64 LW} = \\frac{\\pi^4}{64}\\left(\\frac{9W}{L^3} + \\frac{9L}{W^3} + \\frac{2}{LW}\\right) $$\nThus, the coefficient $\\beta$ is:\n$$ \\beta = \\frac{Et}{2(1-\\nu^2)} \\frac{\\pi^4}{64}\\left(\\frac{9W}{L^3} + \\frac{9L}{W^3} + \\frac{2}{LW}\\right) $$\nWith these coefficients, the Newton solver is implemented. A physically motivated initial guess $u_0$ is derived from the linearized problem: if $T_0 > 0$, the linear geometric stiffness dominates for small $u$, giving $u_0 \\approx F/(\\alpha T_0)$. If $T_0 = 0$, the problem is purely nonlinear, and the exact solution $u = (F/\\beta)^{1/3}$ is used as the initial guess. A backtracking line search is used to globalize the convergence of the Newton iterations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the nonlinear deflection of a pre-tensioned membrane using a\n    single-mode approximation and compares two Newton iteration strategies.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, W, t, E, nu, T0, p)\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 1000.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 100.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 0.0, 1000.0),\n        (1.0, 1.0, 1.0e-4, 1.0e8, 0.3, 1000.0, 5000.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case_results = run_case(case)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g. [[i1,j1,r1,s1],[i2,j2,r2,s2],...]\n    outer_parts = []\n    for res in all_results:\n        inner_parts = [str(item) for item in res]\n        inner_str = f\"[{','.join(inner_parts)}]\"\n        outer_parts.append(inner_str)\n    \n    final_output_str = f\"[{','.join(outer_parts)}]\"\n    print(final_output_str)\n\ndef calculate_coefficients(L, W, t, E, nu, p):\n    \"\"\"\n    Calculates the scalar coefficients F, alpha, and beta based on the\n    derived integral formulas.\n    \"\"\"\n    # Generalized force F\n    F = 4.0 * L * W * p / (np.pi**2)\n\n    # Geometric coefficient alpha\n    alpha = (np.pi**2 / 4.0) * (W / L + L / W)\n\n    # Material coefficient beta\n    C_factor = E * t / (1.0 - nu**2)\n    integral_term = (np.pi**4 / 64.0) * (\n        9.0 * W / L**3 + 9.0 * L / W**3 + 2.0 / (L * W)\n    )\n    beta = (C_factor / 2.0) * integral_term\n\n    return F, alpha, beta\n\ndef newton_solver(F, alpha, beta, T0, use_k_geo):\n    \"\"\"\n    Performs Newton iterations to solve R(u) = 0.\n    \n    Args:\n        F, alpha, beta, T0: Scalar coefficients of the problem.\n        use_k_geo (bool): If True, use full tangent. If False, neglect K_geo.\n\n    Returns:\n        tuple: (iteration_count, average_residual_reduction_rate).\n               Returns (-1, -1.0) on failure.\n    \"\"\"\n    TOL = 1.0e-12\n    MAX_ITER = 50\n\n    def residual(u):\n        return alpha * T0 * u + beta * u**3 - F\n\n    def tangent(u):\n        K_geo = alpha * T0\n        K_mat = 3.0 * beta * u**2\n        if use_k_geo:\n            return K_geo + K_mat\n        else:\n            # For Strategy B, K_geo is omitted from the tangent\n            return K_mat\n\n    # Initial guess for displacement u\n    k_lin = alpha * T0\n    # Use linear solution if stable, otherwise cubic solution\n    if k_lin > 1e-9:\n        u = F / k_lin\n    else:\n        # This branch is taken for T0 = 0\n        if beta > 1e-9:\n            u = (F / beta)**(1.0/3.0)\n        else:\n            # Case with no stiffness, solution is arbitrary or infinite\n            u = 0.0\n\n    R_current = residual(u)\n    if abs(R_current)  TOL:\n        return 0, 0.0\n\n    iterations = 0\n    reduction_rates = []\n\n    for i in range(MAX_ITER):\n        K = tangent(u)\n        \n        # Check for singular stiffness (e.g., in Strategy B at u=0)\n        if abs(K)  1e-12:\n            return -1, -1.0 # Failure: singular tangent\n\n        delta_u = -R_current / K\n\n        # Backtracking line search to ensure residual reduction\n        lambda_ls = 1.0\n        for _ in range(10): # Max 10 backtracking steps\n            u_next = u + lambda_ls * delta_u\n            R_next = residual(u_next)\n            if abs(R_next)  abs(R_current):\n                break\n            lambda_ls /= 2.0\n        else:\n            # Line search failed to find a decreasing step\n            return -2, -2.0 # Failure: line search\n\n        # Store reduction rate before updating state\n        if abs(R_current) > 1e-15: # Avoid division by zero\n            reduction_rates.append(abs(R_next) / abs(R_current))\n\n        # Update state for next iteration\n        u = u_next\n        R_current = R_next\n        iterations += 1\n\n        # Check for convergence\n        if abs(R_current)  TOL:\n            avg_rate = np.mean(reduction_rates) if reduction_rates else 0.0\n            return iterations, avg_rate\n\n    # If loop finishes, max iterations were reached without convergence\n    return MAX_ITER, np.mean(reduction_rates) if reduction_rates else -3.0\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for both strategies and returns the metrics.\n    \"\"\"\n    L, W, t, E, nu, T0, p = case_params\n\n    F, alpha, beta = calculate_coefficients(L, W, t, E, nu, p)\n\n    # Strategy A: Full tangent K_t = K_geo + K_mat\n    iters_full, avg_rate_full = newton_solver(\n        F, alpha, beta, T0, use_k_geo=True\n    )\n\n    # Strategy B: Reduced tangent K_t = K_mat\n    iters_no_geo, avg_rate_no_geo = newton_solver(\n        F, alpha, beta, T0, use_k_geo=False\n    )\n\n    return [iters_full, iters_no_geo, avg_rate_full, avg_rate_no_geo]\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice tackles a sophisticated but essential principle in large-deformation analysis: frame-indifference, which ensures that constitutive laws are independent of rigid body motion. You will implement the geometric stiffness for a co-rotational tetrahedral element, computing it independently in both the material (reference) and spatial (current) frames. By numerically verifying that these two distinct formulations yield identical results after the appropriate co-rotational transformation, this exercise provides a deep, hands-on confirmation of a cornerstone of continuum mechanics theory and a critical quality check for any robust finite element code .",
            "id": "3579576",
            "problem": "Implement a self-contained program that constructs the geometric stiffness contribution for a single co-rotational linear tetrahedral solid element and compares the result computed in the spatial frame versus the material frame. The objective is to verify frame-indifference and numerical equivalence of the geometric stiffness matrix, denoted by $K_\\text{geo}$, by directly using the foundational kinematics and stress push-forward without referencing pre-derived formulas. All quantities are dimensionless, and the angle unit, where applicable, must be radians.\n\nThe fundamental base of the derivation and implementation must start from the following continuum mechanics definitions:\n- Let the motion be $x(X)$, with $X \\in \\mathbb{R}^3$ the material (reference) coordinate and $x \\in \\mathbb{R}^3$ the spatial (current) coordinate.\n- The deformation gradient is $F = \\dfrac{\\partial x}{\\partial X}$, with Jacobian $J = \\det F$.\n- The Second Piola-Kirchhoff stress (SPK) tensor in the material frame is $S$, and the Cauchy stress tensor in the spatial frame is $\\sigma$, related by the push-forward $\\sigma = \\dfrac{1}{J} F S F^\\top$.\n- For a linear tetrahedral element with shape functions $\\{N_i\\}_{i=1}^4$, the material gradients $\\nabla_X N_i$ are constant over the element and the spatial gradients follow from the kinematic mapping $\\nabla_x N_i = F^{-\\top} \\nabla_X N_i$.\n- The co-rotational transformation uses the rotation $R$ obtained from the polar decomposition $F = R U$, with $U$ the right stretch. For an element with $4$ nodes and $3$ degrees of freedom per node, the co-rotational transformation is a block-diagonal matrix $T = \\operatorname{diag}(R, R, R, R)$ of size $12 \\times 12$.\n\nUsing only these definitions, derive and implement the geometric stiffness contribution for the element in both frames as bilinear forms assembled over the element volume. Your implementation must:\n1. Compute the constant material gradients $\\nabla_X N_i$ of the linear tetrahedron from its reference nodal coordinates using elementary geometry.\n2. Compute the deformation gradient $F$ from the current nodal coordinates via the discrete mapping $x(X) = \\sum_{i=1}^4 N_i(X) \\, x_i$, yielding $F = \\sum_{i=1}^4 x_i \\otimes \\nabla_X N_i$.\n3. Compute $J = \\det F$ and the current element volume $v = J \\, V$, where $V$ is the reference element volume.\n4. Compute the spatial gradients $\\nabla_x N_i = F^{-\\top} \\nabla_X N_i$ and the Cauchy stress $\\sigma = \\dfrac{1}{J} F S F^\\top$.\n5. Assemble the geometric stiffness $K_\\text{geo}$ in the material frame and in the spatial frame, each as a $12 \\times 12$ matrix composed of $3 \\times 3$ sub-blocks per node pair. Each sub-block must be a scalar times the $3 \\times 3$ identity, with the scalar obtained by integrating the appropriate bilinear form of shape function gradients and stress over the element domain.\n6. Compute the co-rotational versions $K_{\\text{geo},\\text{mat}}^{\\text{cr}} = T^\\top K_{\\text{geo},\\text{mat}} T$ and $K_{\\text{geo},\\text{spa}}^{\\text{cr}} = T^\\top K_{\\text{geo},\\text{spa}} T$ and verify their numerical equivalence by comparing their difference.\n\nYour program must evaluate the following test suite. In all three cases, use a linear mapping $x = F X$ with zero translation, and define the reference tetrahedron by its material coordinates. All angles are specified in radians.\n\n- Case 1 (general stretch with rotation):\n  - Reference nodes: $X_1 = (0, 0, 0)$, $X_2 = (1, 0, 0)$, $X_3 = (0, 1, 0)$, $X_4 = (0, 0, 1)$.\n  - Rotation $R_z(\\theta)$ about the $z$-axis with $\\theta = 0.3$ gives\n    $\n    R_z(\\theta) = \\begin{bmatrix}\n    \\cos(0.3)  -\\sin(0.3)  0 \\\\\n    \\sin(0.3)  \\cos(0.3)  0 \\\\\n    0  0  1\n    \\end{bmatrix}.\n    $\n  - Right stretch $U = \\operatorname{diag}(1.1, 0.9, 1.05)$, so take $F = R_z(\\theta) U$ and set $x_i = F X_i$.\n  - Material stress\n    $\n    S_1 = \\begin{bmatrix}\n    2.0  0.3  0.1 \\\\\n    0.3  1.5  0.2 \\\\\n    0.1  0.2  1.2\n    \\end{bmatrix}.\n    $\n\n- Case 2 (pure rotation):\n  - Reference nodes: $X_1 = (0, 0, 0)$, $X_2 = (1, 0, 0)$, $X_3 = (0, 1, 0)$, $X_4 = (0, 0, 1)$.\n  - Rotation $R_y(\\theta)$ about the $y$-axis with $\\theta = \\pi/4 \\approx 0.7853981633974483$ gives\n    $\n    R_y(\\theta) = \\begin{bmatrix}\n    \\cos(\\theta)  0  \\sin(\\theta) \\\\\n    0  1  0 \\\\\n    -\\sin(\\theta)  0  \\cos(\\theta)\n    \\end{bmatrix}.\n    $\n  - Right stretch $U = \\operatorname{diag}(1.0, 1.0, 1.0)$, so take $F = R_y(\\theta)$ and set $x_i = F X_i$.\n  - Material stress\n    $\n    S_2 = \\begin{bmatrix}\n    2.0  0.3  0.1 \\\\\n    0.3  1.5  0.2 \\\\\n    0.1  0.2  1.2\n    \\end{bmatrix}.\n    $\n\n- Case 3 (nearly degenerate reference, moderate rotation and stretch):\n  - Reference nodes: $X_1 = (0, 0, 0)$, $X_2 = (0.001, 0, 0)$, $X_3 = (0, 0.001, 0)$, $X_4 = (0, 0, 0.001)$.\n  - Rotation $R_x(\\theta)$ about the $x$-axis with $\\theta = 0.2$ gives\n    $\n    R_x(\\theta) = \\begin{bmatrix}\n    1  0  0 \\\\\n    0  \\cos(0.2)  -\\sin(0.2) \\\\\n    0  \\sin(0.2)  \\cos(0.2)\n    \\end{bmatrix}.\n    $\n  - Right stretch $U = \\operatorname{diag}(0.8, 1.2, 1.0)$, so take $F = R_x(\\theta) U$ and set $x_i = F X_i$.\n  - Material stress\n    $\n    S_3 = \\begin{bmatrix}\n    1.0  0.2  0.0 \\\\\n    0.2  0.5  0.1 \\\\\n    0.0  0.1  0.8\n    \\end{bmatrix}.\n    $\n\nFor each case, compute the relative Frobenius norm error\n$\nr = \\dfrac{\\lVert K_{\\text{geo},\\text{spa}}^{\\text{cr}} - K_{\\text{geo},\\text{mat}}^{\\text{cr}} \\rVert_F}{\\lVert K_{\\text{geo},\\text{mat}}^{\\text{cr}} \\rVert_F},\n$\nand a boolean verdict $b$ that is $1$ if $r \\le 10^{-12}$ and $0$ otherwise.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the format\n$\n[\\; r_1, r_2, r_3, b_1, b_2, b_3 \\;].\n$\nThe outputs $r_1$, $r_2$, and $r_3$ must be floating-point numbers, and $b_1$, $b_2$, and $b_3$ must be integers $0$ or $1$.",
            "solution": "The problem requires the validation of the frame-indifference property for the geometric stiffness matrix of a linear co-rotational tetrahedral element. This is accomplished by deriving and implementing the geometric stiffness matrix, $K_{\\text{geo}}$, from first principles in two distinct reference frames: the material (or reference) frame and the spatial (or current) frame. The numerical equivalence of these two formulations, after transformation to a common co-rotational frame, will serve as the verification.\n\nThe derivation begins with the fundamental principles of continuum mechanics and finite element discretization provided in the problem statement. The geometric stiffness matrix arises from the linearization of the internal virtual work with respect to displacements. For a hyperelastic material, this term involves the second Piola-Kirchhoff stress, $S$, in the material frame, and the Cauchy stress, $\\sigma$, in the spatial frame.\n\nThe geometric stiffness contribution to the total tangent stiffness matrix is given by a bilinear form involving the stress tensor and the gradients of the finite element shape functions. For a node pair $(I, J)$ in a 3D continuum element, the $3 \\times 3$ sub-block of the geometric stiffness matrix is a scalar multiple of the identity matrix.\n\nIn the material frame, this scalar is obtained by integrating over the reference volume, $V_0$:\n$$ (K_{\\text{geo, mat}})_{IJ} = \\left( \\int_{V_0} (\\nabla_X N_I)^T S (\\nabla_X N_J) dV_0 \\right) I_{3 \\times 3} $$\nwhere $\\nabla_X N_I$ is the gradient of the shape function for node $I$ with respect to the material coordinates $X$, and $S$ is the Second Piola-Kirchhoff stress tensor.\n\nIn the spatial frame, the formulation is analogous, integrating over the current volume, $v$:\n$$ (K_{\\text{geo, spa}})_{IJ} = \\left( \\int_{v} (\\nabla_x N_I)^T \\sigma (\\nabla_x N_J) dv \\right) I_{3 \\times 3} $$\nwhere $\\nabla_x N_I$ is the gradient with respect to the spatial coordinates $x$, and $\\sigma$ is the Cauchy stress tensor.\n\nFor a linear tetrahedral element, the shape function gradients ($\\nabla_X N_I$ and $\\nabla_x N_I$) as well as the stress tensors ($S$ and $\\sigma$, assuming constant stress over the element) are constant throughout the element's domain. Therefore, the integrals simplify to a product of the integrand and the volume of the domain. The scalar coefficients for the sub-blocks become:\n$$ s_{IJ}^{\\text{mat}} = V_0 \\cdot [(\\nabla_X N_I)^T S (\\nabla_X N_J)] $$\n$$ s_{IJ}^{\\text{spa}} = v \\cdot [(\\nabla_x N_I)^T \\sigma (\\nabla_x N_J)] $$\n\nA key aspect of this problem is to verify that these two formulations are indeed equivalent. This can be shown by substituting the fundamental kinematic and stress transformation rules into the spatial formulation:\n1.  Current element volume: $v = J V_0$, where $J = \\det(F)$ and $F$ is the deformation gradient.\n2.  Cauchy stress push-forward: $\\sigma = \\frac{1}{J} F S F^T$.\n3.  Shape function gradient transformation: $\\nabla_x N_I = F^{-T} \\nabla_X N_I$.\n\nSubstituting these into the expression for $s_{IJ}^{\\text{spa}}$:\n$$ s_{IJ}^{\\text{spa}} = (J V_0) \\cdot [(F^{-T} \\nabla_X N_I)^T (\\frac{1}{J} F S F^T) (F^{-T} \\nabla_X N_J)] $$\n$$ s_{IJ}^{\\text{spa}} = (J V_0 \\frac{1}{J}) \\cdot [(\\nabla_X N_I)^T F^{-1} F S F^T F^{-T} (\\nabla_X N_J)] $$\nUsing the property that $F^{-1} F = I$ and $F^T F^{-T} = I$, the expression simplifies to:\n$$ s_{IJ}^{\\text{spa}} = V_0 \\cdot [(\\nabla_X N_I)^T S (\\nabla_X N_J)] = s_{IJ}^{\\text{mat}} $$\nThis proves algebraically that the geometric stiffness matrices computed via the material and spatial formulations are identical, i.e., $K_{\\text{geo, mat}} = K_{\\text{geo, spa}}$. The problem thus becomes a numerical verification of this identity.\n\nThe implementation proceeds as follows:\n1.  **Shape Function Gradients**: For a given set of reference nodal coordinates $X_1, X_2, X_3, X_4$, the constant material gradients $\\nabla_X N_i$ and the reference volume $V_0$ are computed. This is done by solving the linear system derived from the shape function property $N_i(X_j) = \\delta_{ij}$. Specifically, if we form a $4 \\times 4$ matrix $C$ where the $j$-th row is $[1, X_j^T]$, the gradients are contained in the last three rows of $C^{-1}$.\n2.  **Kinematic and Stress Quantities**: Given the deformation gradient $F$ and the SPK stress $S$, we compute the Jacobian $J$, the current volume $v$, the Cauchy stress $\\sigma$, the inverse transpose of the deformation gradient $F^{-T}$, and the spatial gradients $\\nabla_x N_i$.\n3.  **Matrix Assembly**: The $12 \\times 12$ matrices $K_{\\text{geo, mat}}$ and $K_{\\text{geo, spa}}$ are assembled block by block. Each $3 \\times 3$ block $(I,J)$ is computed as $s_{IJ} I_{3 \\times 3}$ using the respective scalar coefficients derived above.\n4.  **Co-rotational Transformation and Comparison**: The polar decomposition $F = R U$ is computed to find the rotation tensor $R$. A global $12 \\times 12$ rotation matrix $T = \\operatorname{diag}(R, R, R, R)$ is formed. Both $K_{\\text{geo, mat}}$ and $K_{\\text{geo, spa}}$ are transformed into the co-rotational frame: $K_{\\text{geo,mat}}^{\\text{cr}} = T^T K_{\\text{geo,mat}} T$ and $K_{\\text{geo,spa}}^{\\text{cr}} = T^T K_{\\text{geo,spa}} T$. Since $K_{\\text{geo, mat}}$ and $K_{\\text{geo, spa}}$ are theoretically identical, their transformed versions must also be identical.\n5.  **Error Calculation**: The numerical equivalence is checked by computing the relative Frobenius norm of the difference: $r = \\lVert K_{\\text{geo,spa}}^{\\text{cr}} - K_{\\text{geo,mat}}^{\\text{cr}} \\rVert_F / \\lVert K_{\\text{geo,mat}}^{\\text{cr}} \\rVert_F$. This error is expected to be on the order of machine precision. A boolean verdict, $b$, is assigned based on whether $r$ is below a tolerance of $10^{-12}$.\n\nThis procedure is applied to each of the three test cases, which cover general deformation, pure rotation, and a nearly degenerate reference geometry, to ensure robustness of the implementation and verification of the principle across different scenarios.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import polar, det, inv, norm, block_diag\n\ndef compute_stiffness_comparison(X_nodes, F, S):\n    \"\"\"\n    Computes and compares geometric stiffness matrices for a tetrahedral element.\n\n    Args:\n        X_nodes (np.ndarray): 4x3 array of reference nodal coordinates.\n        F (np.ndarray): 3x3 deformation gradient tensor.\n        S (np.ndarray): 3x3 Second Piola-Kirchhoff stress tensor.\n\n    Returns:\n        tuple: A tuple containing the relative error (float) and the boolean verdict (int).\n    \"\"\"\n    # 1. Compute material gradients and reference volume V0\n    C = np.hstack([np.ones((4, 1)), X_nodes])\n    try:\n        G = inv(C)\n    except np.linalg.LinAlgError:\n        # Handle degenerate reference element\n        return float('inf'), 0\n    \n    # Gradients are columns of G[1:4, :].\n    # nabla_N_X_cols is a 3x4 matrix where column 'i' is the gradient of N_i.\n    nabla_N_X_cols = G[1:4, :]\n    V0 = np.abs(det(C)) / 6.0\n\n    # 2. Compute spatial quantities\n    J = det(F)\n    if J = 0:\n        # Invalid deformation (element inverted or collapsed)\n        return float('inf'), 0\n\n    v = J * V0\n    sigma = (1.0 / J) * F @ S @ F.T\n    F_inv_T = inv(F).T\n    \n    # nabla_N_x_cols is a 3x4 matrix of spatial gradients\n    nabla_N_x_cols = F_inv_T @ nabla_N_X_cols\n\n    # 3. Assemble K_geo,mat\n    K_mat = np.zeros((12, 12))\n    for i in range(4):\n        for j in range(4):\n            grad_Ni = nabla_N_X_cols[:, i]\n            grad_Nj = nabla_N_X_cols[:, j]\n            s_ij = V0 * (grad_Ni.T @ S @ grad_Nj)\n            K_mat[3*i:3*(i+1), 3*j:3*(j+1)] = s_ij * np.eye(3)\n\n    # 4. Assemble K_geo,spa\n    K_spa = np.zeros((12, 12))\n    for i in range(4):\n        for j in range(4):\n            grad_ni = nabla_N_x_cols[:, i]\n            grad_nj = nabla_N_x_cols[:, j]\n            t_ij = v * (grad_ni.T @ sigma @ grad_nj)\n            K_spa[3*i:3*(i+1), 3*j:3*(j+1)] = t_ij * np.eye(3)\n    \n    # 5. Co-rotational transform and compare\n    try:\n        R, _ = polar(F)\n    except np.linalg.LinAlgError:\n        return float('inf'), 0\n        \n    T = block_diag(R, R, R, R)\n    \n    K_mat_cr = T.T @ K_mat @ T\n    K_spa_cr = T.T @ K_spa @ T\n    \n    norm_mat_cr = norm(K_mat_cr, 'fro')\n    \n    if norm_mat_cr  1e-15: # Effectively a zero matrix\n        # If both matrices are zero, the error is zero.\n        # Given the proof K_mat = K_spa, if one is zero, the other must also be zero.\n        r = 0.0\n    else:\n        diff_norm = norm(K_spa_cr - K_mat_cr, 'fro')\n        r = diff_norm / norm_mat_cr\n        \n    b = 1 if r = 1e-12 else 0\n\n    return r, b\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the computations.\n    \"\"\"\n    # Case 1: General stretch with rotation\n    theta1 = 0.3\n    R1 = np.array([\n        [np.cos(theta1), -np.sin(theta1), 0],\n        [np.sin(theta1), np.cos(theta1), 0],\n        [0, 0, 1]\n    ])\n    U1 = np.diag([1.1, 0.9, 1.05])\n    F1 = R1 @ U1\n    S1 = np.array([\n        [2.0, 0.3, 0.1],\n        [0.3, 1.5, 0.2],\n        [0.1, 0.2, 1.2]\n    ])\n    X1_nodes = np.array([\n        [0.0, 0.0, 0.0],\n        [1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    case1 = (X1_nodes, F1, S1)\n\n    # Case 2: Pure rotation\n    theta2 = np.pi / 4\n    R2 = np.array([\n        [np.cos(theta2), 0, np.sin(theta2)],\n        [0, 1, 0],\n        [-np.sin(theta2), 0, np.cos(theta2)]\n    ])\n    U2 = np.eye(3)\n    F2 = R2 @ U2\n    S2 = np.array([\n        [2.0, 0.3, 0.1],\n        [0.3, 1.5, 0.2],\n        [0.1, 0.2, 1.2]\n    ])\n    X2_nodes = X1_nodes # Same reference geometry\n    case2 = (X2_nodes, F2, S2)\n\n    # Case 3: Nearly degenerate reference, moderate rotation and stretch\n    theta3 = 0.2\n    R3 = np.array([\n        [1, 0, 0],\n        [0, np.cos(theta3), -np.sin(theta3)],\n        [0, np.sin(theta3), np.cos(theta3)]\n    ])\n    U3 = np.diag([0.8, 1.2, 1.0])\n    F3 = R3 @ U3\n    S3 = np.array([\n        [1.0, 0.2, 0.0],\n        [0.2, 0.5, 0.1],\n        [0.0, 0.1, 0.8]\n    ])\n    X3_nodes = np.array([\n        [0.0, 0.0, 0.0],\n        [0.001, 0.0, 0.0],\n        [0.0, 0.001, 0.0],\n        [0.0, 0.0, 0.001]\n    ])\n    case3 = (X3_nodes, F3, S3)\n    \n    test_cases = [case1, case2, case3]\n    \n    r_values = []\n    b_values = []\n    for case_data in test_cases:\n        r, b = compute_stiffness_comparison(*case_data)\n        r_values.append(r)\n        b_values.append(b)\n        \n    all_results = r_values + b_values\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}