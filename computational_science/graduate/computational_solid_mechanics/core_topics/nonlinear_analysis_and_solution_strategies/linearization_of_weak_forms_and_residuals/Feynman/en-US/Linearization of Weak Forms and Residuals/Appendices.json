{
    "hands_on_practices": [
        {
            "introduction": "To build a robust nonlinear solver, we must first ground our understanding in the fundamentals of continuum mechanics. This exercise guides you through the rigorous process of deriving the consistent tangent operator from the first principles of hyperelasticity and finite-strain kinematics. By linearizing the stress and strain measures, you will uncover the precise relationship between an incremental change in deformation and the corresponding change in stress, a concept that forms the bedrock of computational solid mechanics .",
            "id": "3578792",
            "problem": "Consider a three-dimensional hyperelastic body occupying a reference configuration with material coordinates. Let the deformation gradient be $F$, the right Cauchy–Green tensor be $C=F^{\\top}F$, the Green–Lagrange strain be $E=\\tfrac{1}{2}(C-I)$, the Second Piola–Kirchhoff stress be $S$, the First Piola–Kirchhoff stress be $P$, and the Cauchy stress be $\\sigma$. Assume hyperelasticity with Helmholtz free energy per unit reference volume $\\Psi$ depending on $C$ (or equivalently on $E$), so that the constitutive relations follow from standard energy conjugacy. The Principle of Virtual Work (PVW) in the reference configuration states that the internal virtual work equals the external virtual work for all admissible virtual displacements.\n\nStarting from these fundamental bases:\n- frame-invariant kinematics $C=F^{\\top}F$ and $E=\\tfrac{1}{2}(C-I)$,\n- hyperelasticity $S=2\\,\\partial \\Psi/\\partial C$ and $P=F\\,S$,\n- the definition of the Cauchy stress $\\sigma=(1/J)\\,F\\,S\\,F^{\\top}$ with $J=\\det F$,\n- and the PVW for the internal virtual work $\\int_{\\Omega_{0}} P:\\nabla_{0} w\\,\\mathrm{d}V$,\n\nperform the following steps without invoking any pre-linearized or “shortcut” formulas:\n\n1) Derive the consistent linearization of the internal virtual work residual with respect to the deformation, identifying the tangent operator that maps an increment $\\delta F$ to $\\delta P$. In particular, derive an expression for $\\delta P$ in terms of $\\delta F$, $S$, and $\\delta S$, and express $\\delta S$ in terms of $\\delta C$ and the second derivative of $\\Psi$ with respect to $C$. Also, derive the corresponding spatial stress variation $\\delta \\sigma$ in terms of $\\delta F$, $S$, and $\\delta S$.\n\n2) Specialize to the Saint Venant–Kirchhoff (SVK) material, whose free energy depends on $E$ as $\\Psi(E)=\\tfrac{\\lambda}{2}\\,(\\mathrm{tr}\\,E)^{2}+\\mu\\,\\mathrm{tr}(E^{2})$, where $\\lambda$ and $\\mu$ are the Lamé parameters. Using your general linearization from part $1$, obtain the material tangent mapping $\\mathbb{A}$ with components $A_{iJkL}=\\partial P_{iJ}/\\partial F_{kL}$.\n\n3) Evaluate the specific tangent component $A_{1111}$ at a state of homogeneous stretch with $F=\\mathrm{diag}(a,b,c)$, where $a$, $b$, and $c$ are positive principal stretches. Provide your final answer as a single closed-form analytic expression in terms of $a$, $b$, $c$, $\\lambda$, and $\\mu$. Do not substitute numerical values. No units are required in the final answer.",
            "solution": "The user has provided a problem statement in the field of nonlinear continuum mechanics, specifically concerning the linearization of constitutive relations for a hyperelastic material.\n\n### Problem Validation\n\nFirst, I will perform a rigorous validation of the problem statement.\n\n**Step 1: Extract Givens**\n\n*   **Kinematics**:\n    *   Deformation gradient: $F$\n    *   Right Cauchy-Green tensor: $C = F^{\\top}F$\n    *   Green-Lagrange strain: $E = \\frac{1}{2}(C-I)$\n*   **Kinetics & Constitutive Law**:\n    *   Helmholtz free energy per unit reference volume: $\\Psi(C)$\n    *   Second Piola-Kirchhoff stress: $S = 2\\,\\frac{\\partial \\Psi}{\\partial C}$\n    *   First Piola-Kirchhoff stress: $P = F S$\n    *   Cauchy stress: $\\sigma = \\frac{1}{J}\\,F\\,S\\,F^{\\top}$, with $J = \\det F$\n*   **Principle of Virtual Work**:\n    *   Internal virtual work: $\\int_{\\Omega_{0}} P:\\nabla_{0} w\\,\\mathrm{d}V$\n*   **Specific Material Model (Saint Venant–Kirchhoff, SVK)**:\n    *   Free energy: $\\Psi(E) = \\frac{\\lambda}{2}\\,(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2})$, with Lamé parameters $\\lambda$ and $\\mu$.\n*   **State for Evaluation**:\n    *   Homogeneous stretch: $F = \\mathrm{diag}(a,b,c)$\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientific Groundedness**: The problem is based entirely on the established principles and standard definitions of nonlinear solid mechanics. The provided relationships between kinematic variables ($F, C, E$), stress tensors ($S, P, \\sigma$), and the hyperelastic potential ($\\Psi$) are fundamental to the field. The SVK model is a classic, albeit simplified, hyperelastic model. All aspects are scientifically sound.\n*   **Well-Posedness**: The problem is structured as a sequence of logical derivations followed by an evaluation for a specific case. Each step is well-defined, and the provided information is sufficient to arrive at a unique mathematical expression for the required quantity.\n*   **Objectivity**: The problem is stated using precise, unambiguous mathematical and physical terminology. It is free from subjective claims or interpretations.\n*   **Completeness**: All required definitions, equations, and the specific form of the constitutive law are provided. The state at which the final evaluation must be performed is explicitly given.\n*   **Consistency**: There are no internal contradictions in the provided definitions or objectives.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. It is a standard, non-trivial exercise in computational mechanics that tests fundamental understanding of constitutive modeling and linearization procedures. I will now proceed with a complete solution.\n\n### Solution\n\nThe solution is presented in three parts as requested.\n\n**Part 1: General Linearization of Stress Tensors**\n\nThe objective is to find the variation (Gateaux derivative) of the stress tensors $P$ and $\\sigma$ with respect to an infinitesimal change in the deformation gradient, denoted $\\delta F$.\n\n1.  **Variation of the First Piola-Kirchhoff Stress ($P$)**\n\n    The First Piola-Kirchhoff stress $P$ is related to the Second Piola-Kirchhoff stress $S$ by $P=FS$. To find its variation, $\\delta P$, we apply the product rule for differentiation:\n    $$ \\delta P = (\\delta F) S + F (\\delta S) $$\n    This expression gives $\\delta P$ in terms of $\\delta F$, $S$, and $\\delta S$ as requested.\n\n2.  **Variation of the Second Piola-Kirchhoff Stress ($S$)**\n\n    The material is hyperelastic, with the Second Piola-Kirchhoff stress derived from the Helmholtz free energy $\\Psi(C)$ as $S = 2 \\frac{\\partial \\Psi}{\\partial C}$. The variation $\\delta S$ is found by applying the chain rule, which yields a linear map from the variation of the right Cauchy-Green tensor, $\\delta C$, to $\\delta S$:\n    $$ \\delta S = 2 \\frac{\\partial}{\\partial C} \\left( \\frac{\\partial \\Psi}{\\partial C} \\right) : \\delta C = 2 \\frac{\\partial^2 \\Psi}{\\partial C \\partial C} : \\delta C $$\n    This is the expression for $\\delta S$ in terms of $\\delta C$ and the second derivative of $\\Psi$. The variation $\\delta C$ is related to $\\delta F$ through the definition $C=F^{\\top}F$:\n    $$ \\delta C = \\delta(F^{\\top}F) = (\\delta F)^{\\top}F + F^{\\top}(\\delta F) $$\n\n3.  **Variation of the Cauchy Stress ($\\sigma$)**\n\n    The Cauchy stress $\\sigma$ is given by $\\sigma = J^{-1} F S F^{\\top}$. Its variation is found by applying the product rule multiple times:\n    $$ \\delta \\sigma = \\delta(J^{-1}) F S F^{\\top} + J^{-1} (\\delta F) S F^{\\top} + J^{-1} F (\\delta S) F^{\\top} + J^{-1} F S (\\delta F)^{\\top} $$\n    The variation of the volume ratio is $\\delta J = J \\mathrm{tr}(F^{-1} \\delta F) = J (F^{-\\top} : \\delta F)$. Consequently, the variation of its inverse is $\\delta(J^{-1}) = -J^{-2} \\delta J = -J^{-1}(F^{-\\top} : \\delta F)$.\n    Substituting this into the expression for $\\delta \\sigma$ yields:\n    $$ \\delta \\sigma = -J^{-1} (F^{-\\top} : \\delta F) F S F^{\\top} + J^{-1} \\left( (\\delta F) S F^{\\top} + F (\\delta S) F^{\\top} + F S (\\delta F)^{\\top} \\right) $$\n    This provides the variation of the Cauchy stress in terms of $\\delta F$, $S$, and $\\delta S$.\n\n**Part 2: Material Tangent for the Saint Venant–Kirchhoff (SVK) Material**\n\nThe SVK model is defined by the strain energy function $\\Psi(E) = \\frac{\\lambda}{2}(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2})$.\n\nFirst, we derive the constitutive relation for the Second Piola-Kirchhoff stress $S$. The problem states $S = 2 \\frac{\\partial \\Psi}{\\partial C}$. Since $E = \\frac{1}{2}(C-I)$, it follows that $\\frac{\\partial E}{\\partial C} = \\frac{1}{2}I_s$, where $I_s$ is the fourth-order symmetric identity tensor. This implies the simpler relation $S = \\frac{\\partial \\Psi}{\\partial E}$. Applying this to the SVK energy function, we get:\n$$ S = \\frac{\\partial}{\\partial E} \\left( \\frac{\\lambda}{2}(\\mathrm{tr}\\,E)^{2} + \\mu\\,\\mathrm{tr}(E^{2}) \\right) = \\lambda (\\mathrm{tr}\\,E) \\frac{\\partial(\\mathrm{tr}\\,E)}{\\partial E} + \\mu \\frac{\\partial(\\mathrm{tr}(E^2))}{\\partial E} $$\nUsing the identities $\\frac{\\partial(\\mathrm{tr}\\,E)}{\\partial E} = I$ and $\\frac{\\partial(\\mathrm{tr}(E^2))}{\\partial E} = 2E$, we obtain the constitutive law for $S$:\n$$ S = \\lambda (\\mathrm{tr}\\,E) I + 2\\mu E $$\nNext, we derive the fourth-order material elasticity tensor $\\mathcal{C}$, defined by $\\delta S = \\mathcal{C} : \\delta E$.\n$$ \\mathcal{C}_{ijkl} = \\frac{\\partial S_{ij}}{\\partial E_{kl}} = \\frac{\\partial}{\\partial E_{kl}} \\left( \\lambda E_{pp} \\delta_{ij} + 2\\mu E_{ij} \\right) = \\lambda \\delta_{pp,kl} \\delta_{ij} + 2\\mu \\delta_{ij,kl} $$\nUsing $\\frac{\\partial E_{pp}}{\\partial E_{kl}} = \\delta_{kl}$ and $\\frac{\\partial E_{ij}}{\\partial E_{kl}} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl}+\\delta_{il}\\delta_{jk})$, we get:\n$$ \\mathcal{C}_{ijkl} = \\lambda \\delta_{ij} \\delta_{kl} + \\mu (\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}) $$\nThe first Piola-Kirchhoff tangent modulus $A_{iJkL}$ is defined by the relation $\\delta P_{iJ} = A_{iJkL} \\delta F_{kL}$. We start from $P_{iJ} = F_{iM} S_{MJ}$ and compute its derivative with respect to $F_{kL}$:\n$$ A_{iJkL} = \\frac{\\partial P_{iJ}}{\\partial F_{kL}} = \\frac{\\partial(F_{iM} S_{MJ})}{\\partial F_{kL}} = \\frac{\\partial F_{iM}}{\\partial F_{kL}} S_{MJ} + F_{iM} \\frac{\\partial S_{MJ}}{\\partial F_{kL}} $$\nUsing $\\frac{\\partial F_{iM}}{\\partial F_{kL}} = \\delta_{ik}\\delta_{ML}$, the first term is $\\delta_{ik}S_{LJ}$. For the second term, we use the chain rule:\n$$ \\frac{\\partial S_{MJ}}{\\partial F_{kL}} = \\frac{\\partial S_{MJ}}{\\partial E_{PQ}} \\frac{\\partial E_{PQ}}{\\partial F_{kL}} = \\mathcal{C}_{MJPQ} \\frac{\\partial E_{PQ}}{\\partial F_{kL}} $$\nThe derivative of the Green-Lagrange strain $E_{PQ} = \\frac{1}{2}(F_{RP}F_{RQ} - \\delta_{PQ})$ with respect to $F_{kL}$ is:\n$$ \\frac{\\partial E_{PQ}}{\\partial F_{kL}} = \\frac{1}{2} \\left( \\frac{\\partial F_{RP}}{\\partial F_{kL}} F_{RQ} + F_{RP} \\frac{\\partial F_{RQ}}{\\partial F_{kL}} \\right) = \\frac{1}{2} (\\delta_{Rk}\\delta_{PL} F_{RQ} + F_{RP} \\delta_{Rk}\\delta_{QL}) = \\frac{1}{2} (F_{kQ}\\delta_{PL} + F_{kP}\\delta_{QL}) $$\nSubstituting this back, we get:\n$$ F_{iM} \\frac{\\partial S_{MJ}}{\\partial F_{kL}} = F_{iM} \\mathcal{C}_{MJPQ} \\frac{1}{2} (F_{kQ}\\delta_{PL} + F_{kP}\\delta_{QL}) = \\frac{1}{2} F_{iM} (\\mathcal{C}_{MJLQ} F_{kQ} + \\mathcal{C}_{MJPL} F_{kP}) $$\nRenaming dummy summation indices and using the minor symmetry $\\mathcal{C}_{MJLQ} = \\mathcal{C}_{MJQL}$, this simplifies to:\n$$ \\frac{1}{2} F_{iM} (\\mathcal{C}_{MJLN} F_{kN} + \\mathcal{C}_{MJNL} F_{kN}) = F_{iM} F_{kN} \\mathcal{C}_{MJLN} $$\nThus, the complete expression for the material tangent modulus is:\n$$ A_{iJkL} = \\delta_{ik} S_{LJ} + F_{iM} F_{kN} \\mathcal{C}_{MJLN} $$\n\n**Part 3: Evaluation of $A_{1111}$**\n\nWe evaluate $A_{1111}$ for the state of homogeneous stretch $F = \\mathrm{diag}(a,b,c)$.\nIn component form, $F_{iJ} = \\lambda_i \\delta_{iJ}$ (no sum over $i$), where $\\lambda_1 = a$, $\\lambda_2 = b$, $\\lambda_3 = c$.\nWe need to evaluate $A_{1111}$, so we set $i=1, J=1, k=1, L=1$:\n$$ A_{1111} = \\delta_{11} S_{11} + F_{1M} F_{1N} \\mathcal{C}_{M11N} $$\nSince $F$ is diagonal, $F_{1M} = a \\delta_{1M}$ and $F_{1N} = a \\delta_{1N}$. The expression becomes:\n$$ A_{1111} = S_{11} + (a \\delta_{1M}) (a \\delta_{1N}) \\mathcal{C}_{M11N} = S_{11} + a^2 \\mathcal{C}_{1111} $$\nNow, we compute the components $S_{11}$ and $\\mathcal{C}_{1111}$.\nThe right Cauchy-Green tensor is $C = F^{\\top}F = \\mathrm{diag}(a^2, b^2, c^2)$, and the Green-Lagrange strain is $E = \\frac{1}{2}(C-I) = \\frac{1}{2}\\mathrm{diag}(a^2-1, b^2-1, c^2-1)$.\nThe trace of the strain is $\\mathrm{tr}\\,E = \\frac{1}{2}(a^2+b^2+c^2-3)$.\nThe component $S_{11}$ is:\n$$ S_{11} = \\lambda (\\mathrm{tr}\\,E) + 2\\mu E_{11} = \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + 2\\mu \\left(\\frac{1}{2}(a^2-1)\\right) = \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + \\mu(a^2-1) $$\nThe component $\\mathcal{C}_{1111}$ is:\n$$ \\mathcal{C}_{1111} = \\lambda \\delta_{11}\\delta_{11} + \\mu(\\delta_{11}\\delta_{11} + \\delta_{11}\\delta_{11}) = \\lambda(1)(1) + \\mu(1 \\cdot 1 + 1 \\cdot 1) = \\lambda + 2\\mu $$\nSubstituting these into the expression for $A_{1111}$:\n$$ A_{1111} = \\left[ \\frac{\\lambda}{2}(a^2+b^2+c^2-3) + \\mu(a^2-1) \\right] + a^2(\\lambda+2\\mu) $$\nExpanding and collecting terms:\n$$ A_{1111} = \\frac{\\lambda}{2}a^2 + \\frac{\\lambda}{2}b^2 + \\frac{\\lambda}{2}c^2 - \\frac{3\\lambda}{2} + \\mu a^2 - \\mu + \\lambda a^2 + 2\\mu a^2 $$\n$$ A_{1111} = a^2 \\left(\\frac{\\lambda}{2} + \\mu + \\lambda + 2\\mu \\right) + \\frac{\\lambda}{2}b^2 + \\frac{\\lambda}{2}c^2 - \\frac{3\\lambda}{2} - \\mu $$\n$$ A_{1111} = a^2 \\left(\\frac{3\\lambda}{2} + 3\\mu \\right) + \\frac{\\lambda}{2}(b^2 + c^2) - \\frac{3\\lambda}{2} - \\mu $$\nThis is the final closed-form analytical expression for the component $A_{1111}$.",
            "answer": "$$\n\\boxed{ a^{2} \\left(\\frac{3\\lambda}{2} + 3\\mu \\right) + \\frac{\\lambda}{2}(b^{2} + c^{2}) - \\frac{3\\lambda}{2} - \\mu }\n$$"
        },
        {
            "introduction": "Translating complex theoretical derivations into correct code is a significant challenge where errors can easily arise. This practice contrasts the classic \"pen-and-paper\" derivation of the tangent matrix with a modern computational approach: Automatic Differentiation (AD). By implementing a simple dual number system to compute the tangent and comparing it to the manually derived result, you will gain firsthand experience with a powerful verification technique and appreciate the utility of AD for complex models .",
            "id": "3578776",
            "problem": "You are to implement and verify the linearization of weak forms and residuals for a one-dimensional nonlinear bar element in computational solid mechanics using both hand-derived expressions and Automatic Differentiation (AD) via dual numbers. Consider a single two-node linear finite element for an axially loaded bar with constant cross-sectional area and length. The unknowns are the nodal axial displacements $u_1$ and $u_2$, collected into the vector $u = [u_1, u_2]^T$. All quantities in this problem are treated as dimensionless.\n\nStart from the weak form of equilibrium for a one-dimensional bar: the discrete residual for node $i$ is obtained by substituting the finite element approximation and using the definition of the axial strain. Use the following physically and mathematically well-founded ingredients.\n\n- The discrete residual vector $R(u)$ has components $R_i(u)$ defined by the internal virtual work minus external nodal forces, specifically $R_i(u) = \\int_{0}^{L} A \\,\\sigma(\\varepsilon(u))\\,N_i'(x)\\,\\mathrm{d}x - F_i^{\\text{ext}}$, where $A$ is the constant cross-sectional area, $L$ is the element length, $N_i'(x)$ is the spatial derivative of the linear shape function at node $i$, and $F_i^{\\text{ext}}$ is the external nodal force applied at node $i$.\n- The axial strain is defined as $\\varepsilon(u) = \\dfrac{\\mathrm{d}u}{\\mathrm{d}x}$. For the two-node linear element, this specializes to $\\varepsilon(u) = B\\,u$ with $B = \\left[-\\dfrac{1}{L}, \\dfrac{1}{L}\\right]$ constant over the element.\n- The constitutive law is a nonlinear, differentiable, isotropic material model given by $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3$, where $E$ is the elastic modulus and $\\alpha$ is a real material parameter that controls the cubic nonlinearity.\n\nTask objectives:\n\n1. Derive, from the above base, the consistent tangent matrix $K_{\\text{manual}}(u) = \\dfrac{\\partial R}{\\partial u}$ by hand, expressing it in terms of $A$, $L$, $B$, and the derivative of the stress with respect to strain.\n2. Implement $K_{\\text{AD}}(u) = \\dfrac{\\partial R}{\\partial u}$ using Automatic Differentiation (AD) via dual numbers. Construct dual variables for $u_1$ and $u_2$, propagate them through the residual computation, and extract the Jacobian matrix.\n3. Verify, for each test case provided, that the entries of $K_{\\text{AD}}$ and $K_{\\text{manual}}$ match within a strict absolute tolerance and that both $K_{\\text{AD}}$ and $K_{\\text{manual}}$ are symmetric. The tolerance for entrywise comparison and symmetry checks must be $10^{-12}$.\n\nImplementation details to respect:\n\n- Use the discrete residual defined above with the linear shape functions such that $B = \\left[-\\dfrac{1}{L}, \\dfrac{1}{L}\\right]$ is constant. The internal force vector is $f_{\\text{int}}(u) = \\int_{0}^{L} A\\,\\sigma(\\varepsilon(u))\\,B^T\\,\\mathrm{d}x$, and the residual is $R(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$ where $f_{\\text{ext}}$ collects the external nodal forces. For the purposes of this problem, use a single right-end nodal force so that $f_{\\text{ext}} = [0, t]^T$ with $t$ given in the test cases.\n- The AD implementation must use dual numbers with a derivative vector of length $2$ to carry the sensitivities with respect to $u_1$ and $u_2$ simultaneously. Implement addition, subtraction, multiplication, division, and integer powers for dual numbers; no transcendental functions are needed.\n\nTest suite:\n\nProvide results for the following parameter sets. For each case, $E$, $\\alpha$, $L$, $A$, $u_1$, $u_2$, and $t$ are specified.\n\n- Case $1$: $E = 1000.0$, $\\alpha = 200.0$, $L = 2.0$, $A = 3.0$, $u_1 = 0.1$, $u_2 = 0.5$, $t = 50.0$.\n- Case $2$: $E = 1000.0$, $\\alpha = 0.0$, $L = 1.5$, $A = 1.2$, $u_1 = 0.3$, $u_2 = -0.1$, $t = -10.0$.\n- Case $3$: $E = 800.0$, $\\alpha = 50.0$, $L = 1.0$, $A = 0.8$, $u_1 = 0.0$, $u_2 = 0.0$, $t = 0.0$.\n- Case $4$: $E = 10.0$, $\\alpha = 1.0$, $L = 10^{-6}$, $A = 1.0$, $u_1 = 0.0$, $u_2 = 10^{-6}$, $t = 0.0$.\n- Case $5$: $E = 500.0$, $\\alpha = 30.0$, $L = 5.0$, $A = 2.5$, $u_1 = 1.0$, $u_2 = -2.0$, $t = 20.0$.\n\nAnswer specification:\n\n- For each test case, compute $K_{\\text{AD}}$ and $K_{\\text{manual}}$, evaluate the maximum absolute entrywise difference, check symmetry of each matrix, and produce a result list containing four entries: $\\text{match}$ (a boolean indicating whether the maximum absolute difference is less than or equal to $10^{-12}$), $\\text{sym\\_AD}$ (a boolean indicating whether $K_{\\text{AD}}$ is symmetric within $10^{-12}$), $\\text{sym\\_manual}$ (a boolean indicating whether $K_{\\text{manual}}$ is symmetric within $10^{-12}$), and $\\text{max\\_abs\\_diff}$ (a float giving the maximum absolute entrywise difference).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself the four-entry list for the corresponding test case in the exact order listed above (for example, $[\\,[\\text{match}_1,\\text{sym\\_AD}_1,\\text{sym\\_manual}_1,\\text{max\\_abs\\_diff}_1],\\ldots\\,]$).",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically sound, and internally consistent problem from the field of computational solid mechanics. It provides all necessary definitions, parameters, and a clear objective. The premises are based on established principles of the Finite Element Method (FEA) and continuum mechanics.\n\nThe task is to compute the consistent tangent stiffness matrix for a nonlinear one-dimensional bar element using two methods—manual analytical derivation and Automatic Differentiation (AD)—and to verify their equivalence.\n\n### 1. Analytical Derivation of the Tangent Matrix ($K_{\\text{manual}}$)\n\nThe problem defines the residual vector $R(u) \\in \\mathbb{R}^2$ for a two-node element with nodal displacements $u = [u_1, u_2]^T$ as $R(u) = f_{\\text{int}}(u) - f_{\\text{ext}}$.\n\nThe external force vector is given as $f_{\\text{ext}} = [0, t]^T$.\nThe internal force vector is given by $f_{\\text{int}}(u) = \\int_{0}^{L} A\\,\\sigma(\\varepsilon(u))\\,B^T\\,\\mathrm{d}x$.\n\nFor a two-node linear element of length $L$, the axial strain $\\varepsilon$ is constant and is given by the B-matrix formulation:\n$$\n\\varepsilon = B u = \\begin{bmatrix} -\\frac{1}{L} & \\frac{1}{L} \\end{bmatrix} \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = \\frac{u_2 - u_1}{L}\n$$\nThe constitutive law is $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3$, where $E$ and $\\alpha$ are material constants.\n\nSince $A$, $\\sigma$, and $B$ are constant with respect to the spatial coordinate $x$, the integral for the internal force vector simplifies to:\n$$\nf_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon)\\,B^T \\int_{0}^{L} \\mathrm{d}x = A\\,L\\,\\sigma(\\varepsilon)\\,B^T\n$$\nSubstituting $B^T = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix}$:\n$$\nf_{\\text{int}}(u) = A\\,L\\,\\sigma(\\varepsilon) \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} = A\\,\\sigma(\\varepsilon) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\nThe residual vector is therefore:\n$$\nR(u) = \\begin{bmatrix} -A\\,\\sigma(\\varepsilon) \\\\ A\\,\\sigma(\\varepsilon) \\end{bmatrix} - \\begin{bmatrix} 0 \\\\ t \\end{bmatrix} = \\begin{bmatrix} -A\\,\\sigma(\\varepsilon) \\\\ A\\,\\sigma(\\varepsilon) - t \\end{bmatrix}\n$$\n\nThe consistent tangent matrix $K$ is the Jacobian of the residual vector with respect to the displacement vector $u$:\n$$\nK(u) = \\frac{\\partial R}{\\partial u} = \\begin{bmatrix} \\frac{\\partial R_1}{\\partial u_1} & \\frac{\\partial R_1}{\\partial u_2} \\\\ \\frac{\\partial R_2}{\\partial u_1} & \\frac{\\partial R_2}{\\partial u_2} \\end{bmatrix}\n$$\nSince $f_{\\text{ext}}$ is constant with respect to $u$, $\\frac{\\partial f_{\\text{ext}}}{\\partial u} = 0$. Thus, $K(u) = \\frac{\\partial f_{\\text{int}}}{\\partial u}$.\nWe apply the chain rule:\n$$\n\\frac{\\partial f_{\\text{int}}}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( A\\,L\\,\\sigma(\\varepsilon(u))\\,B^T \\right) = A\\,L\\,B^T \\otimes \\frac{\\partial \\sigma}{\\partial u} = A\\,L\\,B^T \\otimes \\left( \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} \\frac{\\partial \\varepsilon}{\\partial u} \\right)\n$$\nwhere $\\otimes$ denotes the outer product.\nThe derivative of stress with respect to strain is the material tangent modulus, $E_t$:\n$$\nE_t(\\varepsilon) = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon}(E\\,\\varepsilon + \\alpha\\,\\varepsilon^3) = E + 3\\alpha\\varepsilon^2\n$$\nThe derivative of strain with respect to the displacement vector is the B-matrix:\n$$\n\\frac{\\partial \\varepsilon}{\\partial u} = B = \\begin{bmatrix} -\\frac{1}{L} & \\frac{1}{L} \\end{bmatrix}\n$$\nSubstituting these into the expression for $K(u)$:\n$$\nK(u) = A\\,L\\,\\left( \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} \\right) B^T B = A\\,L\\,E_t(\\varepsilon)\\,B^T B\n$$\nThe matrix product $B^T B$ is:\n$$\nB^T B = \\begin{bmatrix} -1/L \\\\ 1/L \\end{bmatrix} \\begin{bmatrix} -1/L & 1/L \\end{bmatrix} = \\begin{bmatrix} 1/L^2 & -1/L^2 \\\\ -1/L^2 & 1/L^2 \\end{bmatrix} = \\frac{1}{L^2} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nFinally, the expression for the manual tangent matrix $K_{\\text{manual}}$ is:\n$$\nK_{\\text{manual}}(u) = A\\,L\\,(E + 3\\alpha\\varepsilon^2) \\frac{1}{L^2} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} = \\frac{A}{L}(E + 3\\alpha\\varepsilon^2) \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nwhere $\\varepsilon = (u_2 - u_1)/L$. This matrix is manifestly symmetric.\n\n### 2. Automatic Differentiation (AD) via Dual Numbers\n\nAutomatic Differentiation is a technique to numerically evaluate the derivative of a function specified by a computer program. We use the forward-mode AD based on dual numbers. A dual number is an object of the form $z = v + \\dot{v}\\epsilon$, where $v$ is the value, $\\dot{v}$ is the derivative, and $\\epsilon$ is an infinitesimal such that $\\epsilon^2 = 0$. For a function of multiple variables $f(x_1, ..., x_n)$, the derivative part can be a vector representing the gradient: $z = v + (\\nabla v)\\epsilon$.\n\nWe define a `Dual` number class to store a value and its derivative vector. The arithmetic operations for two dual numbers $z_1 = (v_1, \\nabla v_1)$ and $z_2 = (v_2, \\nabla v_2)$ are defined by applying the standard rules of calculus:\n- Addition/Subtraction: $z_1 \\pm z_2 = (v_1 \\pm v_2, \\nabla v_1 \\pm \\nabla v_2)$\n- Multiplication: $z_1 \\cdot z_2 = (v_1 v_2, v_1 \\nabla v_2 + v_2 \\nabla v_1)$\n- Power: $z_1^n = (v_1^n, n v_1^{n-1} \\nabla v_1)$\n\nTo compute the Jacobian $K_{\\text{AD}} = \\frac{\\partial R}{\\partial u}$, we follow these steps:\n1. Initialize the input displacements $u_1$ and $u_2$ as `Dual` numbers. The derivative \"seeds\" are the standard basis vectors in $\\mathbb{R}^2$:\n   - $u_{1,\\text{dual}} = \\text{Dual}(u_1, [1.0, 0.0])$\n   - $u_{2,\\text{dual}} = \\text{Dual}(u_2, [0.0, 1.0])$\n2. Propagate these dual numbers through the sequence of operations that calculate the residual vector $R(u) = [R_1(u), R_2(u)]^T$. This is done by writing a function for $R(u)$ that uses the overloaded arithmetic operators of the `Dual` class.\n3. The calculation yields the residual components as dual numbers:\n   - $R_{1,\\text{dual}} = (R_1(u), \\nabla_u R_1)$\n   - $R_{2,\\text{dual}} = (R_2(u), \\nabla_u R_2)$\n4. The derivative part of $R_{1,\\text{dual}}$ is the first row of the Jacobian, $[\\frac{\\partial R_1}{\\partial u_1}, \\frac{\\partial R_1}{\\partial u_2}]$. The derivative part of $R_{2,\\text{dual}}$ is the second row, $[\\frac{\\partial R_2}{\\partial u_1}, \\frac{\\partial R_2}{\\partial u_2}]$. Assembling these rows gives the full tangent matrix $K_{\\text{AD}}$.\n\n### 3. Verification Procedure\n\nFor each test case, we compute $K_{\\text{manual}}$ and $K_{\\text{AD}}$. The verification consists of two checks:\n1. **Match**: The maximum absolute entrywise difference between the two matrices is compared against a tolerance of $10^{-12}$:\n   $$\n   \\text{max\\_abs\\_diff} = \\max_{i,j} |(K_{\\text{AD}})_{ij} - (K_{\\text{manual}})_{ij}| \\le 10^{-12}\n   $$\n2. **Symmetry**: Each matrix is checked for symmetry by comparing it to its transpose. The maximum absolute difference is compared against the same tolerance:\n   $$\n   \\max_ {i,j} |K_{ij} - K_{ji}| \\le 10^{-12}\n   $$\nThe result for each case is a list of four booleans and one float: $[\\text{match}, \\text{sym\\_AD}, \\text{sym\\_manual}, \\text{max\\_abs\\_diff}]$.",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    A class to represent dual numbers for forward mode automatic differentiation.\n    The derivative component is a vector for multivariate functions.\n    \"\"\"\n    def __init__(self, value, deriv):\n        self.value = float(value)\n        self.deriv = np.asarray(deriv, dtype=float)\n\n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.value * other.deriv + other.value * self.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            if other.value == 0:\n                raise ValueError(\"Division by a dual number with zero value.\")\n            val = self.value / other.value\n            der = (self.deriv * other.value - self.value * other.deriv) / (other.value**2)\n            return Dual(val, der)\n        if other == 0:\n            raise ValueError(\"Division by zero.\")\n        return Dual(self.value / other, self.deriv / other)\n\n    def __rtruediv__(self, other):\n        if self.value == 0:\n            raise ValueError(\"Division by a dual number with zero value.\")\n        val = other / self.value\n        der = (-other * self.deriv) / (self.value**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        if not isinstance(power, (int, float)):\n            raise TypeError(\"Power must be a number.\")\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __neg__(self):\n        return Dual(-self.value, -self.deriv)\n\ndef compute_k_manual(params):\n    \"\"\"\n    Computes the tangent stiffness matrix using the analytically derived formula.\n    \"\"\"\n    E, alpha, L, A, u1, u2, _ = params\n    \n    if L == 0:\n        raise ValueError(\"Length L cannot be zero.\")\n    \n    eps = (u2 - u1) / L\n    E_t = E + 3 * alpha * eps**2\n    factor = (A / L) * E_t\n    \n    K_manual = factor * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    return K_manual\n\ndef compute_k_ad(params):\n    \"\"\"\n    Computes the tangent stiffness matrix using Automatic Differentiation with dual numbers.\n    \"\"\"\n    E, alpha, L, A, u1, u2, t = params\n    \n    if L == 0:\n        raise ValueError(\"Length L cannot be zero.\")\n\n    # Initialize input displacements as dual numbers\n    # The derivative \"seeds\" are the standard basis vectors in R^2\n    u1_d = Dual(u1, [1.0, 0.0])\n    u2_d = Dual(u2, [0.0, 1.0])\n\n    # Propagate dual numbers through residual calculation\n    # Strain\n    eps_d = (u2_d - u1_d) / L\n    \n    # Stress\n    sigma_d = E * eps_d + alpha * eps_d**3\n    \n    # Residual components R = f_int - f_ext\n    # R_1 = -A*sigma - 0\n    # R_2 = A*sigma - t\n    R1_d = -A * sigma_d\n    R2_d = A * sigma_d - t \n    \n    # The Jacobian is formed by the derivative parts of the final dual numbers\n    K_ad = np.vstack([R1_d.deriv, R2_d.deriv])\n    return K_ad\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (E,         alpha,   L,       A,     u1,   u2,        t)\n        (1000.0,    200.0,   2.0,     3.0,   0.1,  0.5,       50.0),\n        (1000.0,    0.0,     1.5,     1.2,   0.3,  -0.1,      -10.0),\n        (800.0,     50.0,    1.0,     0.8,   0.0,  0.0,       0.0),\n        (10.0,      1.0,     1.0e-6,  1.0,   0.0,  1.0e-6,    0.0),\n        (500.0,     30.0,    5.0,     2.5,   1.0,  -2.0,      20.0),\n    ]\n\n    results = []\n    TOL = 1.0e-12\n\n    for case in test_cases:\n        K_manual = compute_k_manual(case)\n        K_ad = compute_k_ad(case)\n\n        # 1. Compare K_ad and K_manual\n        max_abs_diff = np.max(np.abs(K_ad - K_manual))\n        match = max_abs_diff <= TOL\n\n        # 2. Check symmetry of K_ad\n        sym_ad_diff = np.max(np.abs(K_ad - K_ad.T))\n        sym_ad = sym_ad_diff <= TOL\n\n        # 3. Check symmetry of K_manual\n        sym_manual_diff = np.max(np.abs(K_manual - K_manual.T))\n        sym_manual = sym_manual_diff <= TOL\n        \n        results.append([match, bool(sym_ad), bool(sym_manual), max_abs_diff])\n    \n    # Format the output string to be a list of lists with no spaces\n    inner_strs = [f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Ultimately, the reliability of any finite element simulation hinges on the correctness of the implemented code. This practice introduces the Taylor remainder test, a definitive method for verifying that your coded tangent operator is the true mathematical derivative of your residual vector. By numerically checking that the error in the linear approximation of the residual vanishes at the correct rate, you will master an essential validation skill for debugging and ensuring the convergence of your nonlinear solvers .",
            "id": "3578726",
            "problem": "Consider a one-dimensional quasi-static bar of reference length $L$ and constant cross-sectional area $A$, discretized by the Finite Element Method (FEM) into $n_{\\text{el}}$ linear two-node elements and $n_{\\text{n}}$ nodes. Let the nodal displacement vector be $u \\in \\mathbb{R}^{n_{\\text{n}}}$ and let $\\Delta u \\in \\mathbb{R}^{n_{\\text{n}}}$ denote an arbitrary perturbation direction. Assume the small-strain kinematics with engineering strain $\\varepsilon(x) = \\dfrac{du}{dx}$ and a smooth nonlinear constitutive law $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$, where $E \\gt 0$ is the Young's modulus and $\\alpha \\ge 0$ is a nonlinearity parameter. The weak form of equilibrium for zero external loading reduces to the internal virtual work statement, and the associated global residual mapping $R(u)$ (the vector of nodal residual forces) is defined by assembling the element contributions $\\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma(B\\,u_e)\\,dx$, where $\\Omega_e$ is the element domain, $u_e$ are the nodal displacements for element $e$, and $B$ is the element strain-displacement operator. For a linear two-node element of length $L_e$, $B = \\left[-\\dfrac{1}{L_e},\\,\\dfrac{1}{L_e}\\right]$, so the element strain is constant, $\\varepsilon_e = B\\,u_e$.\n\nThe Gateaux derivative (directional derivative) of the residual $DR(u)\\cdot \\Delta u$ is the action of the tangent operator at $u$ on $\\Delta u$, which for the given constitutive law is obtained by differentiating $\\sigma(\\varepsilon)$ with respect to $\\varepsilon$, i.e., $C(u) = \\dfrac{d\\sigma}{d\\varepsilon}\\big\\rvert_{\\varepsilon = B\\,u_e} = E + 3\\,\\alpha\\,(B\\,u_e)^2$. The element-level linearization then yields the tangent contribution $\\int_{\\Omega_e} A\\,B^{\\top}\\,C(u)\\,B\\,\\Delta u_e\\,dx$, which is assembled into the global vector $DR(u)\\cdot \\Delta u$.\n\nYour task is to formulate and numerically verify the Taylor remainder test for the residual mapping using a finite element model with $n_{\\text{n}} = 3$ nodes at positions $x = 0$, $x = \\dfrac{L}{2}$, and $x = L$, and $n_{\\text{el}} = 2$ elements that partition the bar into equal lengths. Specifically, verify that the Taylor remainder satisfies\n$$\n\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\| = o(\\epsilon) \\quad \\text{as} \\quad \\epsilon \\to 0,\n$$\nby computing the ratio\n$$\n\\rho(\\epsilon) = \\dfrac{\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\|}{\\epsilon}\n$$\nfor a decreasing sequence of $\\epsilon$ values and checking that $\\rho(\\epsilon)$ tends to zero in a manner consistent with differentiability. Use the Euclidean norm for vectors. All quantities in this problem are dimensionless; no physical units are required.\n\nImplementation details to be followed:\n- The mesh is defined by $L = 1$, $A = 1$, nodal positions $x_1 = 0$, $x_2 = \\dfrac{1}{2}$, $x_3 = 1$, with elements $e_1 = (x_1, x_2)$ and $e_2 = (x_2, x_3)$.\n- For each element $e$, compute the constant element strain $\\varepsilon_e = B\\,u_e$, the stress $\\sigma_e = E\\,\\varepsilon_e + \\alpha\\,\\varepsilon_e^{3}$, and assemble the element residual $r_e = \\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma_e\\,dx = A\\,\\sigma_e\\,B^{\\top}\\,L_e$ into $R(u)$.\n- For the Gateaux derivative, compute the tangent modulus $C_e(u) = E + 3\\,\\alpha\\,\\varepsilon_e^{2}$ and assemble the action $DR(u)\\cdot \\Delta u$ via $k_e(u)\\,\\Delta u_e$, where $k_e(u) = \\int_{\\Omega_e} A\\,B^{\\top}\\,C_e(u)\\,B\\,dx = A\\,C_e(u)\\,(B^{\\top}B)\\,L_e$.\n- Verify the Taylor remainder condition by evaluating $\\rho(\\epsilon)$ for the sequence $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$ and checking that it is nonincreasing and that the smallest value is sufficiently small either in absolute terms or relative to the largest value, consistent with $o(\\epsilon)$.\n\nTest suite:\n- Case $1$: $E = 1000$, $\\alpha = 10$, $u = [0,\\, 10^{-3},\\, 2\\times 10^{-3}]$, $\\Delta u = [0,\\, -5\\times 10^{-4},\\, 3\\times 10^{-4}]$.\n- Case $2$: $E = 500$, $\\alpha = 0$, $u = [0,\\, 10^{-2},\\, 2\\times 10^{-2}]$, $\\Delta u = [2\\times 10^{-4},\\, 10^{-4},\\, -10^{-4}]$.\n- Case $3$: $E = 1000$, $\\alpha = 50$, $u = [0,\\, 2\\times 10^{-3},\\, 3\\times 10^{-3}]$, $\\Delta u = [0,\\, 0,\\, 0]$.\n- Case $4$: $E = 1000$, $\\alpha = 1000$, $u = [0,\\, 10^{-1},\\, 2\\times 10^{-1}]$, $\\Delta u = [0,\\, 5\\times 10^{-2},\\, -2\\times 10^{-2}]$.\n\nYour program should, for each case, compute the sequence $\\rho(\\epsilon)$, verify that it is nonincreasing and that the smallest value indicates convergence consistent with $o(\\epsilon)$, and return a boolean result per case indicating whether the Taylor remainder test passes. Use the fixed sequence $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets, for example, $[{\\text{result}_1},{\\text{result}_2},{\\text{result}_3},{\\text{result}_4}]$, where each ${\\text{result}_i}$ is either ${\\text{True}}$ or ${\\text{False}}$.",
            "solution": "The problem requires the numerical verification of the Taylor remainder test for the residual mapping in a nonlinear finite element context. This procedure is fundamental for validating the implementation of the tangent operator, which is the Gateaux derivative of the residual. The test confirms that the linearization of the residual is correct, a prerequisite for using Newton-Raphson and related methods to solve nonlinear systems of equations.\n\nThe verification is based on Taylor's theorem. For a differentiable mapping $R(u)$, the following holds for a displacement state $u$ and a perturbation direction $\\Delta u$:\n$$\nR(u + \\epsilon\\,\\Delta u) = R(u) + \\epsilon\\,DR(u)\\cdot \\Delta u + o(\\epsilon)\n$$\nwhere $DR(u)\\cdot \\Delta u$ is the Gateaux derivative of $R$ at $u$ in the direction $\\Delta u$, and $o(\\epsilon)$ represents higher-order terms that vanish faster than $\\epsilon$ as $\\epsilon \\to 0$. The test numerically verifies this property by evaluating the ratio:\n$$\n\\rho(\\epsilon) = \\dfrac{\\left\\| R(u + \\epsilon\\,\\Delta u) - R(u) - \\epsilon\\,DR(u)\\cdot \\Delta u \\right\\|_2}{\\epsilon}\n$$\nFor a correctly implemented Gateaux derivative, $\\rho(\\epsilon)$ must converge to $0$ as $\\epsilon \\to 0$. By analyzing the Taylor expansion further, the remainder term is $\\mathcal{O}(\\epsilon^2)$, which implies that $\\rho(\\epsilon)$ should behave as $\\mathcal{O}(\\epsilon)$. This is checked by computing $\\rho(\\epsilon)$ for a decreasing sequence of $\\epsilon$ values and confirming that the resulting sequence is nonincreasing.\n\nThe specific model is a one-dimensional bar of length $L=1$ and area $A=1$, discretized into $n_{\\text{el}} = 2$ linear elements and $n_{\\text{n}} = 3$ nodes located at $x_1=0$, $x_2=0.5$, and $x_3=1$. The element lengths are $L_{e1} = L_{e2} = 0.5$.\n\n**1. Formulation of the Residual Vector $R(u)$**\n\nThe global residual vector $R(u) \\in \\mathbb{R}^3$ is assembled from the contributions of the two elements. For a generic element $e$ with nodal displacements $u_e$, the constant strain is given by $\\varepsilon_e = B u_e$. For a linear element of length $L_e$, the strain-displacement operator is $B = \\left[-\\dfrac{1}{L_e}, \\dfrac{1}{L_e}\\right]$. With $L_e = 0.5$, we have $B = [-2, 2]$.\n\nFor element $1$ (nodes $1, 2$) with displacements $u_{e1} = [u_1, u_2]^T$:\n$$\n\\varepsilon_1 = [-2, 2] \\begin{bmatrix} u_1 \\\\ u_2 \\end{bmatrix} = 2(u_2 - u_1)\n$$\nFor element $2$ (nodes $2, 3$) with displacements $u_{e2} = [u_2, u_3]^T$:\n$$\n\\varepsilon_2 = [-2, 2] \\begin{bmatrix} u_2 \\\\ u_3 \\end{bmatrix} = 2(u_3 - u_2)\n$$\n\nThe stress in each element is calculated from the nonlinear constitutive law $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$:\n$$\n\\sigma_1 = E\\,\\varepsilon_1 + \\alpha\\,\\varepsilon_1^{3} \\quad , \\quad \\sigma_2 = E\\,\\varepsilon_2 + \\alpha\\,\\varepsilon_2^{3}\n$$\n\nThe element residual vector (internal force vector) $r_e$ is derived from the virtual work principle:\n$$\nr_e = \\int_{\\Omega_e} A\\,B^{\\top}\\,\\sigma_e\\,dx = A\\,L_e\\,B^{\\top}\\,\\sigma_e = (1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}\\sigma_e = \\begin{bmatrix} -\\sigma_e \\\\ \\sigma_e \\end{bmatrix}\n$$\nAssembling the contributions from element $1$ (acting on nodes $1,2$) and element $2$ (acting on nodes $2,3$) yields the global residual vector $R(u) = [R_1, R_2, R_3]^T$:\n$$\nR_1 = -\\sigma_1 \\\\\nR_2 = \\sigma_1 - \\sigma_2 \\\\\nR_3 = \\sigma_2\n$$\n\n**2. Formulation of the Tangent Operator Action $DR(u) \\cdot \\Delta u$**\n\nThe action of the tangent operator is constructed by assembling element-level contributions. The material tangent modulus $C_e$ for each element is the derivative of stress with respect to strain:\n$$\nC_e(u) = \\frac{d\\sigma}{d\\varepsilon}\\bigg\\rvert_{\\varepsilon = \\varepsilon_e} = E + 3\\,\\alpha\\,\\varepsilon_e^2\n$$\nSo, for our elements:\n$$\nC_1 = E + 3\\,\\alpha\\,\\varepsilon_1^2 \\quad , \\quad C_2 = E + 3\\,\\alpha\\,\\varepsilon_2^2\n$$\nThe action of the element tangent stiffness matrix $k_e$ on an elemental displacement perturbation $\\Delta u_e$ is given by $\\int_{\\Omega_e} A\\,B^{\\top}\\,C_e\\,B\\,\\Delta u_e\\,dx$. This can be computed as $A\\,L_e\\,B^{\\top}\\,C_e\\,\\Delta\\varepsilon_e$, where $\\Delta\\varepsilon_e = B\\,\\Delta u_e$.\n\nFor element $1$, the strain perturbation is $\\Delta\\varepsilon_1 = 2(\\Delta u_2 - \\Delta u_1)$. The action is:\n$$\n(1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}C_1\\,\\Delta\\varepsilon_1 = \\begin{bmatrix} -C_1\\,\\Delta\\varepsilon_1 \\\\ C_1\\,\\Delta\\varepsilon_1 \\end{bmatrix}\n$$\nFor element $2$, the strain perturbation is $\\Delta\\varepsilon_2 = 2(\\Delta u_3 - \\Delta u_2)$. The action is:\n$$\n(1)(0.5)\\begin{bmatrix} -2 \\\\ 2 \\end{bmatrix}C_2\\,\\Delta\\varepsilon_2 = \\begin{bmatrix} -C_2\\,\\Delta\\varepsilon_2 \\\\ C_2\\,\\Delta\\varepsilon_2 \\end{bmatrix}\n$$\nAssembling these actions gives the global tangent operator action $DR(u) \\cdot \\Delta u$:\n$$\n(DR(u)\\cdot\\Delta u)_1 = -C_1\\,\\Delta\\varepsilon_1 \\\\\n(DR(u)\\cdot\\Delta u)_2 = C_1\\,\\Delta\\varepsilon_1 - C_2\\,\\Delta\\varepsilon_2 \\\\\n(DR(u)\\cdot\\Delta u)_3 = C_2\\,\\Delta\\varepsilon_2\n$$\n\n**3. Algorithmic Procedure**\n\nFor each test case defined by parameters $(E, \\alpha, u, \\Delta u)$:\n1.  A function `calculate_R_and_DRdu` is implemented to compute $R(u)$ and $DR(u)\\cdot\\Delta u$ using the formulae derived above.\n2.  The main test function iterates through the sequence $\\epsilon \\in \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}\\}$.\n3.  In each iteration, it computes the perturbed displacement state $u_{\\epsilon} = u + \\epsilon\\,\\Delta u$.\n4.  It calculates the residual at the perturbed state, $R(u_{\\epsilon})$, by calling `calculate_R_and_DRdu`.\n5.  It computes the Taylor remainder vector: $Res = R(u_{\\epsilon}) - R(u) - \\epsilon\\,(DR(u)\\cdot\\Delta u)$.\n6.  It calculates the test ratio $\\rho(\\epsilon) = \\|Res\\|_2 / \\epsilon$.\n7.  After computing the sequence of $\\rho$ values, it verifies that the sequence is nonincreasing, i.e., $\\rho(\\epsilon_i) \\le \\rho(\\epsilon_{i-1})$ for the descending sequence of $\\epsilon$ values. This serves as the pass/fail criterion.\n\nSpecial cases are handled gracefully:\n- If $\\Delta u = 0$, the remainder is trivially zero, and the test passes.\n- If $\\alpha = 0$, the problem is linear. The stress is $\\sigma = E\\varepsilon$, and the residual $R(u)$ is a linear function of $u$. The Taylor remainder is analytically zero, resulting in a sequence of $\\rho$ values that are zero (or numerically close to zero), which is nonincreasing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_R_and_DRdu(u, delta_u, E, alpha):\n    \"\"\"\n    Computes the residual vector R(u) and the tangent action DR(u).du\n    for the 2-element, 3-node bar problem.\n\n    Args:\n        u (np.ndarray): The global nodal displacement vector of size 3.\n        delta_u (np.ndarray): The global nodal perturbation vector of size 3.\n        E (float): The Young's modulus.\n        alpha (float): The nonlinearity parameter.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the residual vector R(u)\n        and the tangent action vector DR(u).du.\n    \"\"\"\n    # Extract nodal displacements and perturbations\n    # Node indices are 0, 1, 2, corresponding to positions x=0, x=L/2, x=L.\n    u0, u1, u2 = u[0], u[1], u[2]\n    du0, du1, du2 = delta_u[0], delta_u[1], delta_u[2]\n\n    # Element properties are constant: L_e = 0.5, A = 1.\n    # The B-operator term B=[-1/L_e, 1/L_e] leads to a factor of 2.0.\n    B_factor = 2.0\n\n    # --- Element 1 (connects nodes 0 and 1) ---\n    eps1 = B_factor * (u1 - u0)\n    sigma1 = E * eps1 + alpha * eps1**3\n    C1 = E + 3.0 * alpha * eps1**2\n    delta_eps1 = B_factor * (du1 - du0)\n\n    # --- Element 2 (connects nodes 1 and 2) ---\n    eps2 = B_factor * (u2 - u1)\n    sigma2 = E * eps2 + alpha * eps2**3\n    C2 = E + 3.0 * alpha * eps2**2\n    delta_eps2 = B_factor * (du2 - du1)\n    \n    # Assemble Global Residual R(u)\n    # Element residual r_e = A*L_e*B^T*sigma_e = (1)*(0.5)*[-2, 2]^T*sigma_e = [-sigma_e, sigma_e]^T\n    R = np.array([\n        -sigma1,\n        sigma1 - sigma2,\n        sigma2\n    ])\n    \n    # Assemble Global Tangent Action DR(u).du\n    # Element action = A*L_e*B^T*C_e*delta_eps_e = [-C_e*delta_eps_e, C_e*delta_eps_e]^T\n    action1 = C1 * delta_eps1\n    action2 = C2 * delta_eps2\n    DRdu = np.array([\n        -action1,\n        action1 - action2,\n        action2\n    ])\n    \n    return R, DRdu\n\n\ndef run_taylor_test(params):\n    \"\"\"\n    Performs the Taylor remainder test for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (E, alpha, u, delta_u).\n\n    Returns:\n        bool: True if the test passes (rho sequence is nonincreasing), False otherwise.\n    \"\"\"\n    E, alpha, u_list, delta_u_list = params\n    u = np.array(u_list, dtype=np.float64)\n    delta_u = np.array(delta_u_list, dtype=np.float64)\n    \n    # Per the problem description, use this fixed sequence of epsilon values.\n    epsilons = [1e-1, 1e-2, 1e-3, 1e-4]\n    \n    # If the perturbation direction is the zero vector, the remainder is trivially zero.\n    if not np.any(delta_u):\n        return True\n\n    # Calculate the base residual R(u) and tangent action DR(u).du.\n    R_u, DR_du = calculate_R_and_DRdu(u, delta_u, E, alpha)\n\n    rho_vals = []\n    for eps in epsilons:\n        # Calculate the perturbed displacement state u_eps = u + eps * delta_u.\n        u_eps = u + eps * delta_u\n        \n        # Calculate the residual at the perturbed state, R(u_eps).\n        # We don't need the tangent action at u_eps, so the second return value is ignored.\n        R_u_eps, _ = calculate_R_and_DRdu(u_eps, delta_u, E, alpha)\n        \n        # Calculate the Taylor remainder vector.\n        remainder_vec = R_u_eps - R_u - eps * DR_du\n        \n        # Calculate its Euclidean norm.\n        remainder_norm = np.linalg.norm(remainder_vec)\n        \n        # Calculate the test ratio rho(epsilon).\n        # Division by eps is safe as it is always > 0.\n        rho = remainder_norm / eps\n        rho_vals.append(rho)\n\n    # Verify that the sequence of rho values is nonincreasing. This is the criterion for passing the test.\n    for i in range(1, len(rho_vals)):\n        # A direct comparison is used, as expected for this well-posed problem.\n        if rho_vals[i] > rho_vals[i-1]:\n            return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Standard nonlinear case\n        (1000.0, 10.0, [0.0, 1e-3, 2e-3], [0.0, -5e-4, 3e-4]),\n        # Case 2: Linear case (alpha = 0)\n        (500.0, 0.0, [0.0, 1e-2, 2e-2], [2e-4, 1e-4, -1e-4]),\n        # Case 3: Trivial perturbation (delta_u = 0)\n        (1000.0, 50.0, [0.0, 2e-3, 3e-3], [0.0, 0.0, 0.0]),\n        # Case 4: Strong nonlinearity and larger displacements\n        (1000.0, 1000.0, [0.0, 1e-1, 2e-1], [0.0, 5e-2, -2e-2])\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run the Taylor remainder test for each case.\n        result = run_taylor_test(case)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}