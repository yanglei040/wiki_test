{
    "hands_on_practices": [
        {
            "introduction": "Before implementing an iterative solver, it is crucial to understand the quantity it aims to minimize. In nonlinear mechanics, the Newton-Raphson method systematically drives the residual force vector—the imbalance between internal stresses and external loads—to zero. This foundational exercise  provides concrete practice in deriving and calculating this residual vector for a simple one-dimensional bar with material nonlinearity, solidifying the link between the continuous weak form and the discrete algebraic equations solved by the finite element method.",
            "id": "3583531",
            "problem": "Consider a quasi-static, one-dimensional bar of length $L = 2\\,\\mathrm{m}$, uniform cross-sectional area $A = 1\\,\\mathrm{m^2}$, and a nonlinear material law $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$, where $\\sigma$ is the Cauchy stress and $\\varepsilon$ is the small strain. The bar is subjected to a distributed load $q(x) = q_{0}\\,x$ with $q_{0} = 1.0 \\times 10^{5}\\,\\mathrm{N/m^2}$, and traction-free boundary conditions at $x=0$ and $x=L$.\n\nUsing the Finite Element Method (FEM) and the Newton-Raphson method (NR) for nonlinear equilibrium, start from the strong form of equilibrium and its weak form via the Principle of Virtual Work (PVW). Derive the element-level expression for the nodal residual vector $\\mathbf{r}^{e}(\\mathbf{u})$ in terms of the internal and external force contributions, for a linear two-node element on an interval $[x_{i}, x_{j}]$ with standard linear shape functions. Then, on a mesh of $2$ equal linear elements spanning $[0,2]$ with nodes at $x_{0}=0$, $x_{1}=1$, and $x_{2}=2$, assemble the global residual vector $\\mathbf{r}(\\mathbf{u})$.\n\nEvaluate the residual vector for the discrete displacement field $u_{h}(x)$ defined by nodal values $u_{0} = 0\\,\\mathrm{m}$, $u_{1} = 0.10\\,\\mathrm{m}$, and $u_{2} = 0.25\\,\\mathrm{m}$, with material parameters $E = 10^{6}\\,\\mathrm{Pa}$ and $\\alpha = 10^{7}\\,\\mathrm{Pa}$. Use exact arithmetic where possible. Express the final nodal residual vector in Newtons (N). The final answer must be a single row matrix containing the three nodal residuals. No rounding is required; provide exact values.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in the principles of continuum mechanics and the Finite Element Method, is well-posed, objective, and provides all necessary data for a unique solution. The interpretation of the distributed load $q(x)$ with units of N/m$^2$ for $q_0$ is resolved by dimensional analysis: the term $q(x)=q_0 x$ represents a force per unit length, with units $(N/m^2) \\cdot m = N/m$, which is consistent for a one-dimensional bar problem.\n\nThe solution proceeds by first establishing the governing equations in their strong and weak forms, then deriving the finite element residual expressions, and finally evaluating these expressions for the specified mesh and displacement field.\n\n**1. Governing Equations**\n\nThe strong form of the equilibrium equation for a one-dimensional bar is:\n$$\n\\frac{d(N)}{dx} + f(x) = 0 \\quad \\text{for } x \\in (0, L)\n$$\nwhere $N$ is the axial force and $f(x)$ is the distributed axial load per unit length. The axial force is $N = A\\sigma$, where $A$ is the cross-sectional area and $\\sigma$ is the Cauchy stress. The distributed load is given as $q(x) = q_0 x$, so we identify $f(x) = q(x)$. With a constant area $A$, the equilibrium equation becomes:\n$$\nA\\frac{d\\sigma}{dx} + q_0 x = 0\n$$\nThe material law is nonlinear: $\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$. The strain-displacement relation is $\\varepsilon = \\frac{du}{dx}$. The problem specifies traction-free boundary conditions, which means the axial force $N$ is zero at $x=0$ and $x=L$.\n\nTo derive the weak form, we employ the Principle of Virtual Work (PVW). We multiply the equilibrium equation by a virtual displacement $\\delta u$ and integrate over the domain $[0,L]$:\n$$\n\\int_{0}^{L} \\delta u \\left( A\\frac{d\\sigma}{dx} + q(x) \\right) dx = 0\n$$\nIntegrating the first term by parts yields:\n$$\n\\left[ \\delta u (A\\sigma) \\right]_0^L - \\int_0^L (A\\sigma) \\frac{d(\\delta u)}{dx} dx + \\int_0^L \\delta u q(x) dx = 0\n$$\nThe boundary term $\\left[ \\delta u (A\\sigma) \\right]_0^L$ represents the work done by external point forces at the boundaries. Since the boundaries are traction-free, $A\\sigma(0)=0$ and $A\\sigma(L)=0$, so this term vanishes. The derivative of the virtual displacement is the virtual strain, $\\delta\\varepsilon = d(\\delta u)/dx$. The weak form is thus:\n$$\n\\int_0^L \\sigma(\\varepsilon) \\delta\\varepsilon A \\,dx - \\int_0^L q(x) \\delta u \\,dx = 0\n$$\nFor the Newton-Raphson method, we define the residual, which represents the imbalance between internal and external forces for a given displacement field $u(x)$. The residual functional $R(u, \\delta u)$ is:\n$$\nR(u, \\delta u) = \\int_0^L A\\sigma(\\varepsilon) \\delta\\varepsilon \\,dx - \\int_0^L q(x) \\delta u \\,dx\n$$\nEquilibrium is achieved when $R(u, \\delta u) = 0$ for all admissible virtual displacements $\\delta u$.\n\n**2. Finite Element Formulation**\n\nWe discretize the domain into finite elements. For a generic two-node linear element on $[x_i, x_j]$, the displacement $u(x)$ is interpolated from the nodal displacements $u_i$ and $u_j$:\n$$\nu(x) = N_i(x)u_i + N_j(x)u_j = \\boldsymbol{N}(x) \\boldsymbol{u}^e\n$$\nwhere $\\boldsymbol{u}^e = \\begin{pmatrix} u_i & u_j \\end{pmatrix}^T$ and $\\boldsymbol{N} = \\begin{pmatrix} N_i(x) & N_j(x) \\end{pmatrix}$. The linear shape functions are:\n$$\nN_i(x) = \\frac{x_j-x}{L_e}, \\quad N_j(x) = \\frac{x-x_i}{L_e}\n$$\nwith element length $L_e = x_j - x_i$. The strain $\\varepsilon$ within the element is constant:\n$$\n\\varepsilon_e = \\frac{du}{dx} = \\frac{d\\boldsymbol{N}}{dx}\\boldsymbol{u}^e = \\begin{pmatrix} -\\frac{1}{L_e} & \\frac{1}{L_e} \\end{pmatrix} \\begin{pmatrix} u_i \\\\ u_j \\end{pmatrix} = \\frac{u_j - u_i}{L_e}\n$$\nThe strain-displacement matrix is $\\boldsymbol{B} = \\frac{1}{L_e} \\begin{pmatrix} -1 & 1 \\end{pmatrix}$. The virtual displacement and strain are interpolated similarly: $\\delta u = \\boldsymbol{N} \\boldsymbol{\\delta u}^e$ and $\\delta\\varepsilon = \\boldsymbol{B} \\boldsymbol{\\delta u}^e$.\n\nSubstituting these into the residual functional and summing over all elements gives:\n$$\n(\\boldsymbol{\\delta u})^T \\boldsymbol{r} = \\sum_e (\\boldsymbol{\\delta u}^e)^T \\left( \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx - \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx \\right)\n$$\nwhere $\\boldsymbol{r}$ is the global nodal residual vector. We can identify the element residual vector $\\boldsymbol{r}^e$:\n$$\n\\boldsymbol{r}^e = \\boldsymbol{f}_{int}^e - \\boldsymbol{f}_{ext}^e\n$$\nwhere $\\boldsymbol{f}_{int}^e$ is the element internal force vector and $\\boldsymbol{f}_{ext}^e$ is the element external force vector.\n\n**Derivation of Element Internal Force Vector $\\boldsymbol{f}_{int}^e$:**\n$$\n\\boldsymbol{f}_{int}^e = \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx = A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T \\int_{x_i}^{x_j} dx = A L_e \\sigma(\\varepsilon_e) \\boldsymbol{B}^T\n$$\n$$\n\\boldsymbol{f}_{int}^e = A L_e \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\frac{1}{L_e} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = A \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n\n**Derivation of Element External Force Vector $\\boldsymbol{f}_{ext}^e$:**\n$$\n\\boldsymbol{f}_{ext}^e = \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx = \\int_{x_i}^{x_j} q_0 x \\begin{pmatrix} (x_j-x)/L_e \\\\ (x-x_i)/L_e \\end{pmatrix} dx\n$$\nThe evaluation of this integral yields the standard result for a linear load on a linear element:\n$$\n\\boldsymbol{f}_{ext}^e = \\frac{q_0 L_e}{6} \\begin{pmatrix} 2x_i + x_j \\\\ x_i + 2x_j \\end{pmatrix}\n$$\n\n**3. Numerical Evaluation**\n\nThe bar is discretized into $2$ elements of equal length.\n- Total length $L=2\\,\\mathrm{m}$, so each element length is $L_e=1\\,\\mathrm{m}$.\n- Nodes are at $x_0=0$, $x_1=1$, and $x_2=2$.\n- Material parameters: $A=1\\,\\mathrm{m^2}$, $E=10^6\\,\\mathrm{Pa}$, $\\alpha=10^7\\,\\mathrm{Pa}$.\n- Load parameter: $q_0=10^5\\,\\mathrm{N/m^2}$.\n- Nodal displacements: $u_0=0\\,\\mathrm{m}$, $u_1=0.1\\,\\mathrm{m}$, $u_2=0.25\\,\\mathrm{m}$.\n\n**Element 1 (Nodes 0, 1):**\n$x_i=0$, $x_j=1$, $L_e=1$. Nodal displacements $u_0=0, u_1=0.1$.\n- Strain: $\\varepsilon^{(1)} = (u_1 - u_0)/L_e = (0.1 - 0)/1 = 0.1$.\n- Stress: $\\sigma^{(1)} = E\\varepsilon^{(1)} + \\alpha(\\varepsilon^{(1)})^3 = 10^6(0.1) + 10^7(0.1)^3 = 10^5 + 10^4 = 1.1 \\times 10^5\\,\\mathrm{Pa}$.\n- Internal force vector: $\\boldsymbol{f}_{int}^{(1)} = A\\sigma^{(1)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot (1.1 \\times 10^5) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -110000 \\\\ 110000 \\end{pmatrix}\\,\\mathrm{N}$.\n- External force vector: $\\boldsymbol{f}_{ext}^{(1)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(0)+1 \\\\ 0+2(1) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 50000/3 \\\\ 100000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n- Residual vector: $\\boldsymbol{r}^{(1)} = \\boldsymbol{f}_{int}^{(1)} - \\boldsymbol{f}_{ext}^{(1)} = \\begin{pmatrix} -110000 - 50000/3 \\\\ 110000 - 100000/3 \\end{pmatrix} = \\begin{pmatrix} -380000/3 \\\\ 230000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n\n**Element 2 (Nodes 1, 2):**\n$x_i=1$, $x_j=2$, $L_e=1$. Nodal displacements $u_1=0.1, u_2=0.25$.\n- Strain: $\\varepsilon^{(2)} = (u_2 - u_1)/L_e = (0.25 - 0.1)/1 = 0.15$.\n- Stress: $\\sigma^{(2)} = E\\varepsilon^{(2)} + \\alpha(\\varepsilon^{(2)})^3 = 10^6(0.15) + 10^7(0.15)^3 = 150000 + 10^7(0.003375) = 150000 + 33750 = 183750\\,\\mathrm{Pa}$.\n- Internal force vector: $\\boldsymbol{f}_{int}^{(2)} = A\\sigma^{(2)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot 183750 \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -183750 \\\\ 183750 \\end{pmatrix}\\,\\mathrm{N}$.\n- External force vector: $\\boldsymbol{f}_{ext}^{(2)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(1)+2 \\\\ 1+2(2) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 200000/3 \\\\ 250000/3 \\end{pmatrix}\\,\\mathrm{N}$.\n- Residual vector: $\\boldsymbol{r}^{(2)} = \\boldsymbol{f}_{int}^{(2)} - \\boldsymbol{f}_{ext}^{(2)} = \\begin{pmatrix} -183750 - 200000/3 \\\\ 183750 - 250000/3 \\end{pmatrix} = \\begin{pmatrix} (-551250-200000)/3 \\\\ (551250-250000)/3 \\end{pmatrix} = \\begin{pmatrix} -751250/3 \\\\ 301250/3 \\end{pmatrix}\\,\\mathrm{N}$.\n\n**Assembly of Global Residual Vector $\\boldsymbol{r}$**\nThe global residual vector $\\boldsymbol{r} = \\begin{pmatrix} r_0 & r_1 & r_2 \\end{pmatrix}^T$ is assembled from the element contributions:\n$$\nr_0 = r^{(1)}_0 = -\\frac{380000}{3}\n$$\n$$\nr_1 = r^{(1)}_1 + r^{(2)}_0 = \\frac{230000}{3} - \\frac{751250}{3} = \\frac{230000 - 751250}{3} = \\frac{-521250}{3} = -173750\n$$\n$$\nr_2 = r^{(2)}_1 = \\frac{301250}{3}\n$$\nThe final global residual vector, with components expressed in Newtons, is:\n$$\n\\boldsymbol{r} = \\begin{pmatrix} -380000/3 \\\\ -173750 \\\\ 301250/3 \\end{pmatrix}\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{380000}{3} & -173750 & \\frac{301250}{3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Once the residual is understood as the target, the next step is to formulate the tool for updating the solution: the tangent stiffness matrix. For the Newton-Raphson method to achieve its signature quadratic convergence, this matrix must be the \"consistent tangent,\" derived directly from the underlying constitutive model. This advanced practice  challenges you to move beyond simple scalar problems to a full three-dimensional hyperelastic continuum, deriving both the material and spatial tangent moduli and exploring their fundamental symmetries.",
            "id": "3583525",
            "problem": "Consider a three-dimensional hyperelastic body occupying a reference configuration with material coordinates described by the deformation gradient $\\mathbf{F}$, the right Cauchy-Green tensor $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$, and the Jacobian $J = \\det \\mathbf{F}$. Let the strain-energy density per unit reference volume be the compressible neo-Hookean model\n$$\n\\Psi(\\mathbf{F}) = \\frac{\\mu}{2}\\left(\\mathbf{F}:\\mathbf{F} - 3\\right) - \\mu \\ln J + \\frac{\\lambda}{2}\\left(\\ln J\\right)^{2},\n$$\nwhere $\\mu$ and $\\lambda$ are the Lamé parameters. The equilibrium problem is solved by a Newton-Raphson method applied to the weak form of equilibrium in either the total Lagrangian formulation (with second Piola-Kirchhoff stress $\\mathbf{S}$ and Green-Lagrange strain $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$) or the updated Lagrangian formulation (with Kirchhoff stress $\\boldsymbol{\\tau} = J \\boldsymbol{\\sigma}$ and spatial measures). The finite element method (FEM) residual is linearized consistently to obtain the algorithmic tangent.\n\nStarting from the principle of virtual work, the definitions of hyperelastic stress measures, and the consistent linearization of the internal force operator:\n\n- Derive the second Piola-Kirchhoff stress $\\mathbf{S}$ from $\\Psi(\\mathbf{F})$.\n- Derive the total Lagrangian consistent material tangent $\\mathbb{C}_{\\mathrm{TL}} = \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$ and express it compactly using fourth-order tensor products built from $\\mathbf{C}^{-1}$ and $J$. Use the conventions\n$$\n(\\mathbf{A} \\otimes \\mathbf{B})_{IJKL} = A_{IJ} B_{KL}, \\quad (\\mathbf{A} \\odot \\mathbf{B})_{IJKL} = \\frac{1}{2}\\left(A_{IK}B_{JL} + A_{IL}B_{JK}\\right),\n$$\nwith capital indices referring to the material frame.\n- Push-forward $\\mathbb{C}_{\\mathrm{TL}}$ to obtain the updated Lagrangian spatial consistent tangent $\\mathfrak{c}_{\\mathrm{UL}}$ in the current configuration using\n$$\n\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}.\n$$\nExpress $\\mathfrak{c}_{\\mathrm{UL}}$ using the identity tensor $\\mathbf{I}$, the symmetric fourth-order identity $\\mathbb{I}$ with components $\\mathbb{I}_{ijkl} = \\frac{1}{2}\\left(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}\\right)$, and $J$.\n- For both $\\mathbb{C}_{\\mathrm{TL}}$ and $\\mathfrak{c}_{\\mathrm{UL}}$, identify and justify their minor symmetry within each index pair and major symmetry under pair exchange based on the hyperelastic potential $\\Psi$.\n\nProvide your final pair of expressions $\\left[\\mathbb{C}_{\\mathrm{TL}},\\, \\mathfrak{c}_{\\mathrm{UL}}\\right]$ as closed-form analytic fourth-order tensors. No numerical evaluation is required. Express the final answer as a row matrix using the LaTeX pmatrix environment. No units are required, and no rounding is needed.",
            "solution": "The problem is valid as it is scientifically grounded in continuum mechanics, well-posed, objective, and self-contained. It presents a standard, non-trivial derivation in computational solid mechanics.\n\nThe solution proceeds in four stages:\n1.  Derivation of the second Piola-Kirchhoff stress tensor $\\mathbf{S}$.\n2.  Derivation of the total Lagrangian (material) consistent tangent modulus $\\mathbb{C}_{\\mathrm{TL}}$.\n3.  Push-forward of the material tangent to derive the updated Lagrangian (spatial) consistent tangent modulus $\\mathfrak{c}_{\\mathrm{UL}}$.\n4.  Analysis of the symmetries of both tangent operators.\n\n**1. Derivation of the Second Piola-Kirchhoff Stress S**\n\nThe principle of virtual work states that for a body in equilibrium, the internal virtual work equals the external virtual work. For a hyperelastic material, the variation of the internal work is derived from the variation of the total strain energy. The internal virtual work per unit reference volume is given by $\\delta W_{\\mathrm{int}} = \\mathbf{P}:\\delta\\mathbf{F}^{\\mathsf{T}}$, where $\\mathbf{P}$ is the first Piola-Kirchhoff stress tensor. Using the relationship $\\mathbf{P} = \\mathbf{F}\\mathbf{S}$, where $\\mathbf{S}$ is the symmetric second Piola-Kirchhoff stress tensor, we have:\n$$\n\\delta W_{\\mathrm{int}} = (\\mathbf{F}\\mathbf{S}):\\delta\\mathbf{F}^{\\mathsf{T}} = \\mathrm{tr}(\\mathbf{F}\\mathbf{S}\\,\\delta\\mathbf{F}) = \\mathrm{tr}(\\mathbf{S}\\,\\delta\\mathbf{F}\\mathbf{F})\n$$\nThis is not the most direct path. Instead, we can relate $\\delta W_{\\mathrm{int}}$ to the Green-Lagrange strain tensor $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$, where $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$. The variation of $\\mathbf{E}$ is $\\delta\\mathbf{E} = \\frac{1}{2}\\delta\\mathbf{C} = \\frac{1}{2}(\\delta\\mathbf{F}^{\\mathsf{T}}\\mathbf{F} + \\mathbf{F}^{\\mathsf{T}}\\delta\\mathbf{F})$. The internal virtual work can be expressed as $\\delta W_{\\mathrm{int}} = \\mathbf{S}:\\delta\\mathbf{E}$.\nFor a hyperelastic material with strain-energy density $\\Psi$, the variation of internal energy is simply $\\delta\\Psi$. Equating the two expressions for virtual work density yields:\n$$\n\\delta\\Psi = \\mathbf{S}:\\delta\\mathbf{E} = \\mathbf{S}:\\left(\\frac{1}{2}\\delta\\mathbf{C}\\right) = \\frac{1}{2}\\mathbf{S}:\\delta\\mathbf{C}\n$$\nFrom calculus, the variation of $\\Psi$ as a function of $\\mathbf{C}$ is $\\delta\\Psi = \\frac{\\partial\\Psi}{\\partial\\mathbf{C}}:\\delta\\mathbf{C}$. Comparing these expressions gives the fundamental relationship for the second Piola-Kirchhoff stress:\n$$\n\\mathbf{S} = 2\\frac{\\partial\\Psi}{\\partial\\mathbf{C}}\n$$\nTo apply this, we first express the given strain-energy density $\\Psi(\\mathbf{F})$ in terms of $\\mathbf{C}$. We use the relations $\\mathbf{F}:\\mathbf{F} = \\mathrm{tr}(\\mathbf{F}^{\\mathsf{T}}\\mathbf{F}) = \\mathrm{tr}(\\mathbf{C})$ and $J = \\det(\\mathbf{F}) = \\sqrt{\\det(\\mathbf{C})}$.\nThe strain-energy function becomes:\n$$\n\\Psi(\\mathbf{C}) = \\frac{\\mu}{2}(\\mathrm{tr}(\\mathbf{C}) - 3) - \\mu \\ln(\\sqrt{\\det\\mathbf{C}}) + \\frac{\\lambda}{2} (\\ln(\\sqrt{\\det\\mathbf{C}}))^{2}\n$$\nSimplifying the logarithmic terms:\n$$\n\\Psi(\\mathbf{C}) = \\frac{\\mu}{2}(\\mathrm{tr}(\\mathbf{C}) - 3) - \\frac{\\mu}{2}\\ln(\\det\\mathbf{C}) + \\frac{\\lambda}{8}(\\ln(\\det\\mathbf{C}))^{2}\n$$\nNow we compute the derivative of $\\Psi$ with respect to $\\mathbf{C}$. We require the standard tensor derivatives: $\\frac{\\partial(\\mathrm{tr}\\mathbf{C})}{\\partial\\mathbf{C}} = \\mathbf{I}$ and $\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} = (\\det\\mathbf{C})\\mathbf{C}^{-1} = J^{2}\\mathbf{C}^{-1}$.\nApplying the chain rule:\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\frac{1}{\\det\\mathbf{C}}\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} + \\frac{\\lambda}{8} \\cdot 2\\ln(\\det\\mathbf{C}) \\cdot \\frac{1}{\\det\\mathbf{C}}\\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}}\n$$\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1}) + \\frac{\\lambda}{4} (2\\ln J) \\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1})\n$$\n$$\n\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\frac{\\mu}{2}\\mathbf{I} - \\frac{\\mu}{2}\\mathbf{C}^{-1} + \\frac{\\lambda}{2}(\\ln J)\\mathbf{C}^{-1}\n$$\nFinally, the second Piola-Kirchhoff stress tensor is:\n$$\n\\mathbf{S} = 2\\frac{\\partial\\Psi}{\\partial\\mathbf{C}} = \\mu\\mathbf{I} + (\\lambda\\ln J - \\mu)\\mathbf{C}^{-1}\n$$\n\n**2. Derivation of the Total Lagrangian Tangent Modulus $\\mathbb{C}_{\\mathrm{TL}}$**\n\nThe total Lagrangian consistent tangent modulus relates the rate of change of $\\mathbf{S}$ to the rate of change of $\\mathbf{E}$: $\\dot{\\mathbf{S}} = \\mathbb{C}_{\\mathrm{TL}}:\\dot{\\mathbf{E}}$. This implies $\\mathbb{C}_{\\mathrm{TL}} = \\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{E}}$. Since $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C}-\\mathbf{I})$, $\\delta \\mathbf{E} = \\frac{1}{2}\\delta \\mathbf{C}$. The tangent modulus can be computed as:\n$$\n\\mathbb{C}_{\\mathrm{TL}} = 2\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}}\n$$\nWe differentiate the expression for $\\mathbf{S}$ with respect to $\\mathbf{C}$:\n$$\n\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}} = \\frac{\\partial}{\\partial\\mathbf{C}} \\left[ \\mu\\mathbf{I} + (\\lambda\\ln J - \\mu)\\mathbf{C}^{-1} \\right]\n$$\nThe term $\\mu\\mathbf{I}$ is constant with respect to $\\mathbf{C}$, so its derivative is zero. For the second term, we use the product rule for tensor functions $(f\\mathbf{G})'$, which is $\\frac{\\partial f}{\\partial \\mathbf{C}} \\otimes \\mathbf{G} + f \\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{C}}$. Here, $f(\\mathbf{C}) = \\lambda\\ln J - \\mu = \\frac{\\lambda}{2}\\ln(\\det\\mathbf{C}) - \\mu$ and $\\mathbf{G}(\\mathbf{C}) = \\mathbf{C}^{-1}$.\nFirst, we find the derivative of the scalar function $f$:\n$$\n\\frac{\\partial f}{\\partial \\mathbf{C}} = \\frac{\\lambda}{2} \\frac{1}{\\det\\mathbf{C}} \\frac{\\partial(\\det\\mathbf{C})}{\\partial\\mathbf{C}} = \\frac{\\lambda}{2} \\frac{1}{J^{2}}(J^{2}\\mathbf{C}^{-1}) = \\frac{\\lambda}{2}\\mathbf{C}^{-1}\n$$\nNext, we find the derivative of the tensor function $\\mathbf{G}$, which is a standard result for the derivative of a tensor inverse with respect to the tensor itself (assuming symmetry):\n$$\n\\frac{\\partial\\mathbf{C}^{-1}}{\\partial\\mathbf{C}} = -(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\nwhere the fourth-order tensor $(\\mathbf{A} \\odot \\mathbf{B})_{IJKL} = \\frac{1}{2}(A_{IK}B_{JL} + A_{IL}B_{JK})$.\nCombining these results using the product rule:\n$$\n\\frac{\\partial\\mathbf{S}}{\\partial\\mathbf{C}} = \\left(\\frac{\\lambda}{2}\\mathbf{C}^{-1}\\right) \\otimes \\mathbf{C}^{-1} + (\\lambda\\ln J - \\mu) \\left( -(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1}) \\right)\n$$\nFinally, multiplying by $2$ gives the material tangent modulus:\n$$\n\\mathbb{C}_{\\mathrm{TL}} = \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) - 2(\\lambda\\ln J - \\mu)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\n$$\n\\mathbb{C}_{\\mathrm{TL}} = \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) + 2(\\mu - \\lambda\\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})\n$$\n\n**3. Derivation of the Updated Lagrangian Tangent Modulus $\\mathfrak{c}_{\\mathrm{UL}}$**\n\nThe updated Lagrangian, or spatial, tangent modulus $\\mathfrak{c}_{\\mathrm{UL}}$ is obtained by pushing forward the material tangent $\\mathbb{C}_{\\mathrm{TL}}$ to the current (spatial) configuration. The push-forward operation is given by:\n$$\n\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}\n$$\nWe apply this operation to each term of $\\mathbb{C}_{\\mathrm{TL}}$.\n\nPush-forward of the first term, $\\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1})$:\nThe components are $\\mathbb{C}^{(1)}_{\\mathrm{TL}\\,IJKL} = \\lambda C^{-1}_{IJ} C^{-1}_{KL}$.\n$$\n\\mathfrak{c}^{(1)}_{\\mathrm{UL}\\,ijkl} = \\frac{\\lambda}{J} F_{iI} F_{jJ} F_{kK} F_{lL} (C^{-1}_{IJ} C^{-1}_{KL}) = \\frac{\\lambda}{J} (F_{iI} C^{-1}_{IJ} F_{jJ}) (F_{kK} C^{-1}_{KL} F_{lL})\n$$\nA key identity is that the push-forward of $\\mathbf{C}^{-1}$ is the identity tensor, i.e., $(F_{aI}C^{-1}_{IJ}F_{bJ}) = \\delta_{ab}$. Applying this to the two tensor products in our expression, we get:\n$$\n\\mathfrak{c}^{(1)}_{\\mathrm{UL}\\,ijkl} = \\frac{\\lambda}{J} \\delta_{ij}\\delta_{kl}\n$$\nIn tensor notation, this is $\\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I})$.\n\nPush-forward of the second term, $2(\\mu - \\lambda\\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1})$:\nThe components are $\\mathbb{C}^{(2)}_{\\mathrm{TL}\\,IJKL} = 2(\\mu - \\lambda\\ln J) \\frac{1}{2}(C^{-1}_{IK}C^{-1}_{JL} + C^{-1}_{IL}C^{-1}_{JK})$.\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} F_{iI} F_{jJ} F_{kK} F_{lL} (C^{-1}_{IK}C^{-1}_{JL} + C^{-1}_{IL}C^{-1}_{JK})\n$$\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} [(F_{iI}C^{-1}_{IK}F_{kK})(F_{jJ}C^{-1}_{JL}F_{lL}) + (F_{iI}C^{-1}_{IL}F_{lL})(F_{jJ}C^{-1}_{JK}F_{kK})]\n$$\nApplying the same identity to the terms in the sum gives:\n$$\n\\mathfrak{c}^{(2)}_{\\mathrm{UL}\\,ijkl} = \\frac{(\\mu - \\lambda\\ln J)}{J} [\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk}]\n$$\nThe term in brackets is $2\\mathbb{I}_{ijkl}$, where $\\mathbb{I}_{ijkl} = \\frac{1}{2}(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$ is the symmetric fourth-order identity tensor.\nThus, the second term becomes $\\frac{2(\\mu - \\lambda\\ln J)}{J}\\mathbb{I}$.\n\nCombining the two pushed-forward terms gives the spatial tangent modulus:\n$$\n\\mathfrak{c}_{\\mathrm{UL}} = \\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I}) + \\frac{2(\\mu - \\lambda\\ln J)}{J}\\mathbb{I}\n$$\n\n**4. Symmetry Analysis**\n\nThe existence of a hyperelastic potential $\\Psi$ ensures that the resulting tangent operators possess certain symmetries.\n\n-   **Symmetries of $\\mathbb{C}_{\\mathrm{TL}}$**: The material tangent is defined as $\\mathbb{C}_{\\mathrm{TL}} = 4\\frac{\\partial^2\\Psi}{\\partial\\mathbf{C}\\partial\\mathbf{C}}$.\n    -   **Minor Symmetries**: $\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,JIKL}$ and $\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,IJLK}$. These hold because the differentiation is with respect to the symmetric tensor $\\mathbf{C}$ (or $\\mathbf{E}$), and the stress tensor $\\mathbf{S}$ it is derived from is also symmetric. This structure is evident in the final expression, as $\\mathbf{C}^{-1}$ is symmetric and the tensor products $\\otimes$ and $\\odot$ are constructed to preserve these symmetries.\n    -   **Major Symmetry**: $\\mathbb{C}_{\\mathrm{TL}\\,IJKL} = \\mathbb{C}_{\\mathrm{TL}\\,KLIJ}$. This is a direct consequence of Schwarz's theorem on the equality of mixed partials for a sufficiently smooth potential $\\Psi$. The order of differentiation with respect to $C_{IJ}$ and $C_{KL}$ can be interchanged, guaranteeing this symmetry. Inspection of the derived formula for $\\mathbbC_{\\mathrm{TL}}$ confirms this property.\n\n-   **Symmetries of $\\mathfrak{c}_{\\mathrm{UL}}$**: The spatial tangent inherits the symmetries of the material tangent through the push-forward operation.\n    -   The mapping $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\frac{1}{J} F_{iI} F_{jJ} F_{kK} F_{lL}\\, \\mathbb{C}_{\\mathrm{TL}\\,IJKL}$ is a linear transformation that preserves the index symmetries of $\\mathbb{C}_{\\mathrm{TL}}$.\n    -   **Minor Symmetries**: $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,jikl}$ and $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,ijlk}$. These are evident from the final expression, which is built from the Kronecker delta $\\delta$. For instance, swapping $i$ and $j$ in $\\delta_{ij}\\delta_{kl}$ and $(\\delta_{ik}\\delta_{jl} + \\delta_{il}\\delta_{jk})$ leaves the expression unchanged.\n    -   **Major Symmetry**: $\\mathfrak{c}_{\\mathrm{UL}\\,ijkl} = \\mathfrak{c}_{\\mathrm{UL}\\,klij}$. This also holds, as can be directly verified from the final expression by swapping the index pair $(i,j)$ with $(k,l)$.\n\nThe symmetries of both tangent operators are a fundamental property stemming from their hyperelastic origin, which is crucial for the efficiency and symmetry of the stiffness matrix in finite element implementations.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\lambda (\\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}) + 2(\\mu - \\lambda \\ln J)(\\mathbf{C}^{-1} \\odot \\mathbf{C}^{-1}) & \\frac{\\lambda}{J}(\\mathbf{I} \\otimes \\mathbf{I}) + \\frac{2(\\mu - \\lambda \\ln J)}{J}\\mathbb{I} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Theoretical understanding culminates in practical implementation. This coding exercise  tasks you with building a nonlinear solver from the ground up to compare the performance of the full Newton-Raphson algorithm against its most common variant, the modified Newton method. By implementing both and analyzing their iteration counts and convergence rates on a well-defined problem, you will gain direct, quantitative insight into the fundamental trade-off between per-iteration computational cost and the overall speed of convergence.",
            "id": "3583538",
            "problem": "Implement a complete, runnable program that compares two Newton-Raphson strategies for solving a nonlinear equilibrium problem arising from a one-dimensional finite element discretization. The physical model is a single bar with one end fixed and one end subjected to a monotonically increasing axial load. The bar has uniform cross-sectional area and is discretized as a single linear two-node element, so the axial strain is uniform under the applied end displacement. The internal axial stress follows a nonlinear constitutive law. The goal is to formulate the equilibrium residual, derive the tangent needed for Newton iterations, and then implement and compare the full Newton method and the modified Newton method (freezing the tangent stiffness over multiple iterations). You must compute iteration counts and observed convergence rates and produce them in a single aggregated output line.\n\nFoundational base:\n- Global equilibrium in the Finite Element Method (FEM): the discrete equilibrium condition is $r(u) = 0$, where $r(u)$ is the residual force vector (here scalar), $u$ is the discrete nodal displacement, $r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$, and $f_{\\text{ext}}$ is the external nodal force vector (here scalar).\n- Kinematics: for a single uniform bar element of length $L$ with linear shape functions and one free end displacement $u$, the axial strain is $\\varepsilon = u / L$.\n- Nonlinear constitutive law: axial stress is given by $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$, where $E > 0$ is the Young’s modulus and $\\beta \\ge 0$ controls the cubic nonlinearity; assume nondimensionalized units so all quantities are dimensionless in this problem statement.\n- Internal force: for a uniform bar with cross-sectional area $A$ and constant strain, the internal force at the free node reduces to $f_{\\text{int}}(u) = A \\sigma(\\varepsilon)$.\n\nDefine the equilibrium residual for a given end load $P$ and nodal displacement $u$ as $r(u) = P - f_{\\text{int}}(u) = P - A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$. The consistent tangent, required by Newton-Raphson (NR), is $K_{\\text{T}}(u) = \\frac{dr}{du}$. The full Newton method at iteration $k$ uses the current $K_{\\text{T}}(u_k)$, while the modified Newton method freezes $K_{\\text{T}}$ at the start of each load increment and reuses it for all iterations within that increment.\n\nProgramming tasks:\n1. Starting from the equilibrium residual definition $r(u) = P - f_{\\text{int}}(u)$ and the constitutive law $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$, derive $r(u)$ and $K_{\\text{T}}(u)$ explicitly in terms of $u$, $E$, $\\beta$, $A$, $L$, and $P$.\n2. Implement two nonlinear solvers over a sequence of load increments:\n   - Full Newton method: update $K_{\\text{T}}(u_k)$ at every iteration within a load increment.\n   - Modified Newton method: freeze $K_{\\text{T}}$ at the start of each load increment (use the tangent evaluated at the first iterate of the increment, i.e., at the previous increment’s converged displacement).\n   Each load increment increases $P$ by $\\Delta P = P_{\\text{total}}/N_{\\text{inc}}$ and seeks a converged $u$ such that $|r(u)| \\le \\text{tol}$.\n3. Use the previous increment’s converged displacement as the initial guess for the next increment. For each increment, record the sequence of residual norms $||r(u_k)||$ until convergence.\n4. For the modified Newton method, compute the observed linear convergence factor averaged over all iterations and increments where at least two iterations occur: $\\lambda_k = \\frac{||r_{k+1}||}{||r_k||}$, and report the arithmetic mean over all such $\\lambda_k$. For the full Newton method, compute the observed quadratic factor averaged similarly: $q_k = \\frac{||r_{k+1}||}{||r_k||^2}$, reporting the arithmetic mean of all $q_k$ where at least two iterations occur.\n5. For each test case, compute the total number of iterations accumulated over all increments for the full Newton method and for the modified Newton method. Convergence tolerances apply to the residual norm $||r||$, which in this scalar case is $|r|$.\n\nTest suite:\nUse nondimensional parameters $A = 1$, $L = 1$, $E = 1$ for all test cases. Use maximum iterations per increment $\\text{max\\_iter} = 50$ and residual tolerance $\\text{tol} = 10^{-10}$. The test suite consists of four cases:\n- Case $1$: $\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$.\n- Case $2$: $\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$.\n- Case $3$: $\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$.\n- Case $4$ (near-linear boundary): $\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$.\n\nOutput specification:\n- For each test case, produce a list $[N_{\\text{full}}, N_{\\text{mod}}, R_{\\text{full}}, R_{\\text{mod}}]$ where $N_{\\text{full}}$ is the total number of iterations for the full Newton method, $N_{\\text{mod}}$ is the total number of iterations for the modified Newton method, $R_{\\text{full}}$ is the averaged quadratic factor for the full Newton method, and $R_{\\text{mod}}$ is the averaged linear convergence factor for the modified Newton method. All four values must be numeric; in cases with fewer than two iterations across all increments (for the factor definition), report $0.0$ for the corresponding rate.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sub-list per test case in order: case $1$, case $2$, case $3$, case $4$. For example, the exact format must be like $[[N_{\\text{full}},N_{\\text{mod}},R_{\\text{full}},R_{\\text{mod}}],\\ldots]$. As all outputs are counts or ratios, no physical units are required in the output.\n\nScientific realism constraints:\n- The problem is nondimensionalized, so all parameters are dimensionless, ensuring unit consistency.\n- The constitutive nonlinearity $\\beta \\ge 0$ guarantees a positive tangent modulus $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$, thereby avoiding loss of ellipticity and ensuring robust convergence for the chosen loads.\n- Use deterministic algorithms with no randomization, fixed tolerance $\\text{tol} = 10^{-10}$, and maximum iteration cap $\\text{max\\_iter} = 50$ to ensure reproducibility.\n\nYour implementation must be a complete, runnable program. Do not read any input or write any output other than the required single line. The implementation language must be Python with the constraints specified later. The results must be computed numerically by the program using the algorithms derived from first principles above.",
            "solution": "We start from the discrete equilibrium in the Finite Element Method (FEM): $r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$. For a one-dimensional bar of length $L$ and cross-sectional area $A$ with uniform strain, the axial strain is $\\varepsilon = u/L$. The constitutive law is $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ with $E > 0$ and $\\beta \\ge 0$. The internal nodal axial force at the free end equals the cross-sectional area times the axial stress, $f_{\\text{int}}(u) = A \\sigma(\\varepsilon) = A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$. The external nodal force is $f_{\\text{ext}} = P$. Consequently, the scalar residual is\n$$\nr(u) = P - A\\left(E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right).\n$$\nThe consistent tangent needed by Newton-Raphson (NR) is the derivative of $r(u)$ with respect to $u$:\n$$\nK_{\\text{T}}(u) = \\frac{dr}{du} = -A\\left(\\frac{E}{L} + 3\\beta \\frac{u^2}{L^3}\\right).\n$$\nThe negative sign is not problematic because the NR update solves $K_{\\text{T}}(u_k) \\Delta u_k = -r(u_k)$ and updates $u_{k+1} = u_k + \\Delta u_k$. Since $K_{\\text{T}}(u)$ is strictly negative for all $u$ when $E > 0$ and $\\beta \\ge 0$ with $A>0$, $L>0$, the iteration is well-posed; it leads to positive $\\Delta u_k$ when $r(u_k) > 0$ under monotonic loading.\n\nWe consider two algorithms:\n- Full Newton: At iteration $k$ within a given load increment, assemble $K_{\\text{T}}(u_k)$ from the current iterate. Solve $K_{\\text{T}}(u_k)\\Delta u_k = -r(u_k)$ and update $u_{k+1} = u_{k} + \\Delta u_k$. Repeat until $|r(u_{k+1})| \\le \\text{tol}$ or $k$ reaches $\\text{max\\_iter}$.\n- Modified Newton: At the start of each load increment, freeze $K_{\\text{T}}$ by evaluating it at the previous increment’s converged displacement $u^{(i-1)}$, which serves as the initial guess $u_0^{(i)}$. Then iterate with this fixed $K_{\\text{T}}$ for all Newton updates in the increment until convergence or $\\text{max\\_iter}$.\n\nLoading and initialization:\nWe adopt a load increment scheme with $N_{\\text{inc}}$ uniform steps. The total load is $P_{\\text{total}}$, and each increment increases the load by $\\Delta P = P_{\\text{total}} / N_{\\text{inc}}$. At increment $i$ ($i = 1, \\ldots, N_{\\text{inc}}$), the target load is $P_i = i \\Delta P$. The initial guess for $u$ at increment $i$ is the converged displacement from increment $i-1$, with $u^{(0)} = 0$ for the first increment. For each increment and each method, we record the residual norms $|r(u_k)|$ at each NR iteration $k$.\n\nConvergence rate measures:\n- For the modified Newton method with a frozen tangent within an increment, the expected local behavior near the solution is linear: $|r_{k+1}| \\approx \\lambda |r_k|$ where $0 < \\lambda < 1$ in the convergent regime. We estimate the linear factor at each step as $\\lambda_k = \\frac{|r_{k+1}|}{|r_k|}$ and compute the arithmetic average over all increments and all iteration indices $k$ where at least two residuals exist (i.e., $k$ ranges from $0$ to $n-2$ if $n$ residuals were recorded in that increment).\n- For the full Newton method with a consistent tangent, the local behavior near the solution is quadratic: $|r_{k+1}| \\approx q |r_k|^2$ for small $|r_k|$. We estimate the quadratic factor at each step as $q_k = \\frac{|r_{k+1}|}{|r_k|^2}$ and compute the arithmetic average over all increments and eligible iteration indices. In increments converging in fewer than two iterations, the factor cannot be estimated; those increments are excluded from the averages. If no eligible steps exist across all increments in a test case, we return $0.0$ for the corresponding averaged rate.\n\nTest cases and expectations:\nWe use nondimensional parameters $A = 1$, $L = 1$, $E = 1$, which implies $f_{\\text{int}}(u) = E u + \\beta u^3$ and $K_{\\text{T}}(u) = -\\left(E + 3\\beta u^2\\right)$ for this choice. We set $\\text{tol} = 10^{-10}$ and $\\text{max\\_iter} = 50$. Four cases are simulated:\n- Case $1$: $\\beta = 0.1$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$. Expect moderate nonlinearity; full Newton should exhibit near-quadratic convergence with small averaged $q$, while modified Newton should show linear convergence with a factor $\\lambda$ bounded away from zero.\n- Case $2$: $\\beta = 1.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$. Increased nonlinearity; full Newton remains efficient; modified Newton may require more iterations with a larger $\\lambda$.\n- Case $3$: $\\beta = 5.0$, $P_{\\text{total}} = 0.8$, $N_{\\text{inc}} = 8$. Strong nonlinearity; the tangent grows significantly with $u$. Full Newton should still converge robustly with near-quadratic behavior; modified Newton may have slower rates and higher iteration counts because the frozen tangent is less representative away from the initial guess.\n- Case $4$: $\\beta = 0.0$, $P_{\\text{total}} = 0.5$, $N_{\\text{inc}} = 5$. Purely linear; both methods reduce to solving a linear equation. From an arbitrary initial guess per increment (previous converged value), Newton converges in a single iteration per increment. The averaged rates cannot be meaningfully computed because there is at most one iteration per increment; thus the rate outputs should be $0.0$ for both methods in this case.\n\nOutput format:\nFor each test case, return the list $[N_{\\text{full}}, N_{\\text{mod}}, R_{\\text{full}}, R_{\\text{mod}}]$ and aggregate all four cases into a single top-level list, printed as one line, e.g., $[[N_{\\text{full}},N_{\\text{mod}},R_{\\text{full}},R_{\\text{mod}}], [\\cdots], [\\cdots], [\\cdots]]$. The values are integers for $N_{\\text{full}}$, $N_{\\text{mod}}$ and floating-point for $R_{\\text{full}}$, $R_{\\text{mod}}$. Because these are counts and nondimensional ratios, no physical units are required in the output.\n\nAlgorithmic robustness:\nWe set a strict residual tolerance $\\text{tol} = 10^{-10}$ to capture asymptotic behavior in the rate estimates. The positive tangent modulus $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$ ensures unique solutions for the specified loads. The maximum iteration cap $\\text{max\\_iter} = 50$ guards against pathological cases. The load stepping strategy maintains monotonic increase in $P$, and the choice of initial guesses promotes rapid convergence.\n\nThe program implements these steps exactly and prints the required single-line output in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef residual(u, P, E, beta, A, L):\n    # r(u) = P - A*(E*u/L + beta*(u/L)^3)\n    return P - A * (E * (u / L) + beta * (u / L) ** 3)\n\ndef tangent(u, E, beta, A, L):\n    # K_T(u) = dr/du = -A*(E/L + 3*beta*u^2/L^3)\n    return -A * (E / L + 3.0 * beta * (u ** 2) / (L ** 3))\n\ndef newton_solve(P_total, N_inc, E, beta, A, L, tol=1e-10, max_iter=50, mode=\"full\"):\n    \"\"\"\n    Solve the nonlinear equilibrium over load increments using either full Newton or modified Newton.\n    Returns:\n        total_iterations: int\n        avg_rate: float (quadratic factor for 'full', linear factor for 'modified')\n    \"\"\"\n    u = 0.0  # initial displacement for first increment\n    deltaP = P_total / N_inc\n    total_iterations = 0\n    rate_values = []  # stores lambda_k for 'modified' or q_k for 'full'\n\n    for i in range(1, N_inc + 1):\n        P_i = i * deltaP\n        # Initial guess is previous increment's converged displacement\n        u_i = u\n        residuals = []\n\n        # Freeze tangent for modified Newton at start of increment\n        if mode == \"modified\":\n            K_freeze = tangent(u_i, E, beta, A, L)\n\n        for k in range(max_iter):\n            r_k = residual(u_i, P_i, E, beta, A, L)\n            residuals.append(abs(r_k))\n            if abs(r_k) = tol:\n                # Converged at iteration k\n                total_iterations += k  # we count completed iterations before reaching tolerance\n                break\n            # Choose tangent according to method\n            if mode == \"full\":\n                K_t = tangent(u_i, E, beta, A, L)\n            else:\n                K_t = K_freeze\n\n            # Guard against zero tangent (should not occur with chosen parameters)\n            if K_t == 0.0:\n                # Fail-safe: break to avoid division by zero\n                total_iterations += k + 1\n                break\n\n            # Newton update: K_t * delta = -r_k  => delta = -r_k / K_t\n            delta = -r_k / K_t\n            u_i = u_i + delta\n\n            # If we reached the last allowed iteration without satisfying tol, count it\n            if k == max_iter - 1:\n                total_iterations += max_iter\n\n        # Post-processing for rate estimates within this increment\n        # We use the recorded residuals sequence residuals[0..n-1] to compute step-wise rates\n        n_res = len(residuals)\n        if n_res >= 2:\n            for idx in range(n_res - 1):\n                r_k = residuals[idx]\n                r_k1 = residuals[idx + 1]\n                if mode == \"modified\":\n                    # Linear factor lambda = r_{k+1} / r_k\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / r_k)\n                else:\n                    # Quadratic factor q = r_{k+1} / r_k^2\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / (r_k ** 2))\n\n        # Update global u for next increment initial guess\n        u = u_i\n\n    # Average the collected rates; if none, return 0.0\n    if len(rate_values) > 0:\n        avg_rate = float(np.mean(rate_values))\n    else:\n        avg_rate = 0.0\n\n    return total_iterations, avg_rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Using nondimensional parameters: A=1, L=1, E=1 for all cases.\n    test_cases = [\n        # (beta, P_total, N_inc, E, A, L)\n        (0.1, 0.5, 5, 1.0, 1.0, 1.0),  # Case 1\n        (1.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 2\n        (5.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 3\n        (0.0, 0.5, 5, 1.0, 1.0, 1.0),  # Case 4 (linear)\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, P_total, N_inc, E, A, L = case\n\n        # Full Newton\n        N_full, R_full = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"full\"\n        )\n        # Modified Newton (freeze tangent per increment)\n        N_mod, R_mod = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"modified\"\n        )\n\n        results.append([N_full, N_mod, R_full, R_mod])\n\n    # Final print statement in the exact required format.\n    # Single line: list of sublists per test case.\n    print(str(results))\n\nsolve()\n```"
        }
    ]
}