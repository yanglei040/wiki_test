{
    "hands_on_practices": [
        {
            "introduction": "为了在计算程序（例如有限元代码）中应用像广义-α方法这样的隐式方法，我们通常需要在每个时间步中将其表述为一个待求解的线性方程组。这个练习将引导你完成必要的代数推导，以得到“有效刚度矩阵”($K_{\\text{eff}}$)，这是实现该方法的核心部分。这项实践有助于巩固你对该方法的参数（如 $\\alpha_m, \\alpha_f, \\beta, \\gamma$）如何与物理系统的矩阵（$M, C, K$）相结合的理解，为实际的编程实现奠定理论基础。",
            "id": "3568325",
            "problem": "考虑计算固体力学中由以下二阶初值问题控制的线性结构动力学：\n$$\nM \\ddot{u}(t) + C \\dot{u}(t) + K u(t) = f(t),\n$$\n其中 $M$、$C$ 和 $K$ 分别为质量、阻尼和刚度矩阵，$u(t)$ 是位移向量，$\\dot{u}(t)$ 和 $\\ddot{u}(t)$ 是其速度和加速度，$f(t)$ 是外力。设时间网格为 $t_n$，具有均匀步长 $\\Delta t$。广义-α方法（用户指定高频谱半径 $\\rho_{\\infty} \\in [0,1]$）通过以下定义在加权时间点上强制平衡：\n$$\nx_{n+1-\\alpha} := (1-\\alpha)\\,x_{n+1} + \\alpha\\,x_{n},\n$$\n该定义应用于 $x \\in \\{u,\\dot{u},\\ddot{u},f\\}$，其中力和位移/速度的权重为 $\\alpha_f$，加速度的权重为 $\\alpha_m$，二者不同。位移、速度和加速度的运动学关系由标准的 Newmark 族给出：\n$$\nu_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1},\n$$\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n + \\gamma \\Delta t\\,\\ddot{u}_{n+1},\n$$\n其中 $\\beta$ 和 $\\gamma$ 为方法参数。在加权时间点上的广义-α平衡方程为：\n$$\nM \\ddot{u}_{n+1-\\alpha_m} + C \\dot{u}_{n+1-\\alpha_f} + K u_{n+1-\\alpha_f} = f_{n+1-\\alpha_f}.\n$$\n\n任务 A：从上述基本关系出发，对 Newmark 运动学关系进行变换，写出将 $u_{n+1}$ 和 $\\dot{u}_{n+1}$ 显式地表示为未知加速度 $\\ddot{u}_{n+1}$ 和已知的第 n 步的量的预估-校正关系。\n\n任务 B：利用加权平衡方程和这些关系，构建关于位移增量 $\\Delta u_{n+1} := u_{n+1} - u_n$ 的单步线性系统，形式如下：\n$$\nK_{\\text{eff}}\\,\\Delta u_{n+1} = r_{\\text{eff}},\n$$\n确定有效矩阵 $K_{\\text{eff}}$ 和有效右端项 $r_{\\text{eff}}$，用 $M$、$C$、$K$、$\\Delta t$、$\\alpha_f$、$\\alpha_m$、$\\beta$、$\\gamma$ 和第 n 步的数据表示。\n\n任务 C：为保证二阶精度和无条件稳定性，同时通过预设的无穷远处的谱半径 $\\rho_{\\infty}$ 控制高频数值耗散，广义-α方法的参数需要满足特定关系。陈述这些标准参数关系：$\\alpha_m(\\rho_{\\infty})$、$\\alpha_f(\\rho_{\\infty})$、$\\gamma(\\rho_{\\infty})$ 和 $\\beta(\\rho_{\\infty})$。\n\n最终交付成果。将这些关系代入任务 B 中得到的 $K_{\\text{eff}}$，并进行简化，以获得仅依赖于 $M$、$C$、$K$、$\\Delta t$ 和 $\\rho_{\\infty}$ 的单一闭式解析表达式 $K_{\\text{eff}}(M,C,K,\\Delta t,\\rho_{\\infty})$。将此简化后的 $K_{\\text{eff}}$ 表达式作为最终答案。不需包含单位，也无需四舍五入。",
            "solution": "该问题陈述是计算固体力学领域中关于广义-α时间积分方法的标准推导。它具有科学依据，提法恰当，客观，并包含了所有必要信息。因此，该问题被认为是有效的，并将提供解答。\n\n该问题分为三个任务，最终导出一个交付成果。我们将按顺序解决每个任务。\n\n### 任务 A：预估-校正关系\n\nNewmark 运动学关系提供了在时间 $t_{n+1}$ 更新位移 $u_{n+1}$ 和速度 $\\dot{u}_{n+1}$ 的表达式，这些表达式基于时间 $t_n$ 的状态和新的加速度 $\\ddot{u}_{n+1}$。这些关系本身即为所要求的预估-校正形式。\n\n第 n+1 步的位移由下式给出：\n$$\nu_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1}\n$$\n这可以解释为一个预估步骤：\n$$\n\\tilde{u}_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n\n$$\n然后是一个基于未知加速度 $\\ddot{u}_{n+1}$ 的校正步骤：\n$$\nu_{n+1} = \\tilde{u}_{n+1} + \\beta \\Delta t^2 \\ddot{u}_{n+1}\n$$\n类似地，第 n+1 步的速度由下式给出：\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n + \\gamma \\Delta t\\,\\ddot{u}_{n+1}\n$$\n这也可以分为一个预估步骤：\n$$\n\\tilde{\\dot{u}}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n\n$$\n和一个校正步骤：\n$$\n\\dot{u}_{n+1} = \\tilde{\\dot{u}}_{n+1} + \\gamma \\Delta t\\,\\ddot{u}_{n+1}\n$$\n问题陈述中原始的 Newmark 方程即为所求的显式关系。\n\n### 任务 B：有效刚度系统\n\n目标是构建一个形如 $K_{\\text{eff}}\\,\\Delta u_{n+1} = r_{\\text{eff}}$ 的线性系统，其中 $\\Delta u_{n+1} = u_{n+1} - u_n$。这需要将第 n+1 步的所有未知量用 $\\Delta u_{n+1}$ 和第 n 步的已知量来表示。\n\n从第一个 Newmark 关系中，我们可以分离出 $\\ddot{u}_{n+1}$：\n$$\n\\beta \\Delta t^2 \\ddot{u}_{n+1} = (u_{n+1} - u_n) - \\Delta t\\,\\dot{u}_n - \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n\n$$\n$$\n\\ddot{u}_{n+1} = \\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1} - \\frac{1}{\\beta \\Delta t}\\dot{u}_n - \\left(\\frac{1}{2\\beta}-1\\right)\\ddot{u}_n\n$$\n接下来，我们将上述表达式代入第二个 Newmark 关系来表示 $\\dot{u}_{n+1}$：\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t(1-\\gamma)\\ddot{u}_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1} - \\frac{1}{\\beta \\Delta t}\\dot{u}_n - \\left(\\frac{1}{2\\beta}-1\\right)\\ddot{u}_n \\right]\n$$\n$$\n\\dot{u}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t}\\Delta u_{n+1} + \\left(1-\\frac{\\gamma}{\\beta}\\right)\\dot{u}_n + \\Delta t\\left(1-\\frac{\\gamma}{2\\beta}\\right)\\ddot{u}_n\n$$\n位移更新很简单，$u_{n+1} = u_n + \\Delta u_{n+1}$。\n\n现在，将这些代入加权平衡方程：\n$$\nM \\ddot{u}_{n+1-\\alpha_m} + C \\dot{u}_{n+1-\\alpha_f} + K u_{n+1-\\alpha_f} = f_{n+1-\\alpha_f}\n$$\n使用定义 $x_{n+1-\\alpha} = (1-\\alpha)x_{n+1} + \\alpha x_n$，我们将所有与时间步 $n+1$ 相关的项移到左侧，与时间步 $n$ 相关的项移到右侧：\n$$\n(1-\\alpha_m)M \\ddot{u}_{n+1} + (1-\\alpha_f)C \\dot{u}_{n+1} + (1-\\alpha_f)K u_{n+1} = (1-\\alpha_f)f_{n+1} + \\alpha_f f_n - (\\alpha_m M \\ddot{u}_n + \\alpha_f C \\dot{u}_n + \\alpha_f K u_n)\n$$\n我们将 $\\ddot{u}_{n+1}$、$\\dot{u}_{n+1}$ 和 $u_{n+1}$ 的表达式用 $\\Delta u_{n+1}$ 来代入。将包含 $\\Delta u_{n+1}$ 的项分离到左侧，我们得到有效刚度矩阵 $K_{\\text{eff}}$ 的系数：\n$$\n(1-\\alpha_m)M \\left(\\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1}\\right) + (1-\\alpha_f)C \\left(\\frac{\\gamma}{\\beta \\Delta t}\\Delta u_{n+1}\\right) + (1-\\alpha_f)K (\\Delta u_{n+1}) + \\dots = \\dots\n$$\n因此，有效刚度矩阵 $K_{\\text{eff}}$ 为：\n$$\nK_{\\text{eff}} = \\frac{1-\\alpha_m}{\\beta \\Delta t^2} M + \\frac{(1-\\alpha_f) \\gamma}{\\beta \\Delta t} C + (1-\\alpha_f) K\n$$\n剩余的项构成了有效右端项 $r_{\\text{eff}}$，但问题不需要其显式表达式。\n\n### 任务 C：参数关系\n\n广义-α方法的参数是通过施加三个条件来确定的：二阶精度、线性系统的无条件稳定性以及由无穷频率极限下的谱半径 $\\rho_{\\infty}$ 量化的用户可控的数值耗散。\n\n为保证二阶精度，参数必须满足：\n$$\n\\gamma = \\frac{1}{2} + \\alpha_m - \\alpha_f\n$$\n通过将余下参数选为期望谱半径 $\\rho_{\\infty} \\in [0,1]$ 的函数，可以实现无条件稳定性和对高频耗散的控制。标准关系式为：\n$$\n\\alpha_f = \\frac{1}{\\rho_{\\infty}+1}\n$$\n$$\n\\alpha_m = \\frac{2-\\rho_{\\infty}}{\\rho_{\\infty}+1}\n$$\n为在给定 $\\rho_{\\infty}$ 的情况下最大化高频耗散，参数 $\\beta$ 选择为：\n$$\n\\beta = \\frac{1}{4}(1+\\alpha_m-\\alpha_f)^2\n$$\n现在我们可以推导 $\\gamma$ 和 $\\beta$ 关于 $\\rho_{\\infty}$ 的显式表达式。\n首先，对于 $\\gamma$：\n$$\n\\gamma = \\frac{1}{2} + \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}} - \\frac{1}{1+\\rho_{\\infty}} = \\frac{1}{2} + \\frac{1-\\rho_{\\infty}}{1+\\rho_{\\infty}} = \\frac{(1+\\rho_{\\infty}) + 2(1-\\rho_{\\infty})}{2(1+\\rho_{\\infty})} = \\frac{3-\\rho_{\\infty}}{2(\\rho_{\\infty}+1)}\n$$\n接下来，对于 $\\beta$：\n$$\n1+\\alpha_m-\\alpha_f = 1 + \\frac{1-\\rho_{\\infty}}{1+\\rho_{\\infty}} = \\frac{(1+\\rho_{\\infty})+(1-\\rho_{\\infty})}{1+\\rho_{\\infty}} = \\frac{2}{1+\\rho_{\\infty}}\n$$\n$$\n\\beta = \\frac{1}{4}\\left(\\frac{2}{1+\\rho_{\\infty}}\\right)^2 = \\frac{1}{4}\\frac{4}{(1+\\rho_{\\infty})^2} = \\frac{1}{(1+\\rho_{\\infty})^2}\n$$\n因此，这四个参数都被定义为 $\\rho_{\\infty}$ 的函数。\n\n### 最终交付成果：简化的有效刚度矩阵\n\n最后一步是将任务 C 中得到的 $\\alpha_m$、$\\alpha_f$、$\\gamma$ 和 $\\beta$ 的表达式代入任务 B 中推导出的 $K_{\\text{eff}}$ 表达式。\n\n$K_{\\text{eff}}$ 的表达式为：\n$$\nK_{\\text{eff}} = \\frac{1-\\alpha_m}{\\beta \\Delta t^2} M + \\frac{(1-\\alpha_f) \\gamma}{\\beta \\Delta t} C + (1-\\alpha_f) K\n$$\n我们将分别计算每个系数。\n\n1.  **$M$ 的系数**：\n    $$\n    \\frac{1-\\alpha_m}{\\beta} = \\frac{1 - \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}}}{\\frac{1}{(1+\\rho_{\\infty})^2}} = \\frac{\\frac{1+\\rho_{\\infty}-2+\\rho_{\\infty}}{1+\\rho_{\\infty}}}{\\frac{1}{(1+\\rho_{\\infty})^2}} = \\frac{\\frac{2\\rho_{\\infty}-1}{1+\\rho_{\\infty}}}{\\frac{1}{(1+\\rho_{\\infty})^2}} = (2\\rho_{\\infty}-1)(1+\\rho_{\\infty})\n    $$\n    所以，该项为 $\\frac{(2\\rho_{\\infty}-1)(1+\\rho_{\\infty})}{\\Delta t^2} M$。\n\n2.  **$C$ 的系数**：\n    $$\n    \\frac{(1-\\alpha_f) \\gamma}{\\beta} = \\frac{\\left(\\frac{1+\\rho_{\\infty}-1}{1+\\rho_{\\infty}}\\right) \\left(\\frac{3-\\rho_{\\infty}}{2(1+\\rho_{\\infty})}\\right)}{\\left(\\frac{1}{(1+\\rho_{\\infty})^2}\\right)} = \\frac{\\left(\\frac{\\rho_{\\infty}}{1+\\rho_{\\infty}}\\right) \\left(\\frac{3-\\rho_{\\infty}}{2(1+\\rho_{\\infty})}\\right)}{\\frac{1}{(1+\\rho_{\\infty})^2}} = \\frac{\\rho_{\\infty}(3-\\rho_{\\infty})}{2}\n    $$\n    所以，该项为 $\\frac{\\rho_{\\infty}(3-\\rho_{\\infty})}{2 \\Delta t} C$。\n\n3.  **$K$ 的系数**：\n    $$\n    1-\\alpha_f = 1 - \\frac{1}{1+\\rho_{\\infty}} = \\frac{\\rho_{\\infty}}{1+\\rho_{\\infty}}\n    $$\n    所以，该项为 $\\frac{\\rho_{\\infty}}{1+\\rho_{\\infty}} K$。\n\n结合这些结果，有效刚度矩阵的最终闭式解析表达式为：\n$$\nK_{\\text{eff}}(M,C,K,\\Delta t,\\rho_{\\infty}) = \\frac{(2\\rho_{\\infty}-1)(1+\\rho_{\\infty})}{\\Delta t^2} M + \\frac{\\rho_{\\infty}(3-\\rho_{\\infty})}{2 \\Delta t} C + \\frac{\\rho_{\\infty}}{1+\\rho_{\\infty}} K\n$$\n该表达式仅依赖于系统矩阵 $M、C、K$、时间步长 $\\Delta t$ 以及高频谱半径 $\\rho_{\\infty}$，符合要求。",
            "answer": "$$\n\\boxed{\\frac{(2\\rho_{\\infty}-1)(\\rho_{\\infty}+1)}{\\Delta t^2} M + \\frac{\\rho_{\\infty}(3-\\rho_{\\infty})}{2 \\Delta t} C + \\frac{\\rho_{\\infty}}{1+\\rho_{\\infty}} K}\n$$"
        },
        {
            "introduction": "广义-α方法的一个关键优势是它能够在不显著影响低频、具有物理意义的响应的同时，有效衰减由空间离散化（例如有限元网格）引入的虚假高频振荡。这个练习提供了一个具体的物理场景来量化这一效应。通过估算一个离散化杆模型中的最高模态频率，并利用谱半径 $\\rho_{\\infty}$ 的定义，你将能够计算出将这些不必要的数值噪声从模拟中移除所需的时间步数，从而深刻理解高频耗散的实际作用。",
            "id": "3568272",
            "problem": "一根均匀的棱柱杆在一维空间下进行建模，考虑小应变、线弹性、无外部阻尼的纵向运动。该杆的杨氏模量 $E = 210 \\,\\text{GPa}$，质量密度 $\\rho = 7800 \\,\\text{kg/m}^3$，长度 $L = 1.0 \\,\\text{m}$。有限元半离散模型在具有 $N_{e} = 100$ 个单元的均匀网格上使用线性形函数，因此节点间距为 $h = L/N_{e}$。时间积分采用广义-α方法 (generalized-alpha method)，其配置的无穷远处谱半径为 $\\rho_{\\infty} = 0.5$。\n\n仅从基本定律和核心定义出发，按以下步骤进行：\n- 使用连续介质的牛顿第二定律和一维本构关系，求出杆的纵向波速 $c$。\n- 利用节点间距为 $h$ 的节点网格的空间采样考虑，确定网格上可以表示的最高可分辨波数 $k_{\\max}$，并估计半离散模型对应的最高可分辨角频率 $\\omega_{\\max}$。\n- 利用广义-α法中无穷远处谱半径 $\\rho_{\\infty}$ 的定义及其对每时间步的渐近高频放大系数的影响，确定将 $\\omega_{\\max}$ 模式的振幅减小 $10^{-3}$ 倍所需的最小整数时间步数 $n$。\n\n报告以下内容：\n1. 最高可分辨角频率 $\\omega_{\\max}$ 的估计值，单位为弧度/秒，四舍五入到四位有效数字。\n2. 最小整数时间步数 $n$。\n\n将最终答案以 $\\left(\\omega_{\\max}, n\\right)$ 的形式表示为一个双元行向量。最终答案框中不要包含单位，但在计算中按上述规定对 $\\omega_{\\max}$ 使用弧度/秒作为单位。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于连续介质力学和计算方法，提法恰当，数据充分且一致，并且陈述客观。\n\n解答按要求分三部分进行。\n\n首先，我们推导均匀棱柱杆的纵向波速 $c$。我们将牛顿第二定律应用于杆的微元，其横截面积为 $A$，长度为 $dx$，质量密度为 $\\rho$。该微元的质量为 $dm = \\rho A dx$。作用在微元上的净力是其两端应力 $\\sigma$ 的差值，即 $dF = (\\sigma(x+dx) - \\sigma(x))A \\approx \\frac{\\partial\\sigma}{\\partial x} A dx$。根据牛顿第二定律 $dF = (dm) a$，其中加速度为 $a = \\frac{\\partial^2 u}{\\partial t^2}$（$u(x,t)$ 为纵向位移），可得：\n$$ \\frac{\\partial\\sigma}{\\partial x} A dx = (\\rho A dx) \\frac{\\partial^2 u}{\\partial t^2} $$\n这简化为一维运动方程：\n$$ \\frac{\\partial\\sigma}{\\partial x} = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\n对于小应变下的线弹性材料，其本构关系为 $\\sigma = E \\epsilon$，其中 $E$ 是杨氏模量，$\\epsilon$ 是轴向应变。应变的定义是位移的空间梯度，即 $\\epsilon = \\frac{\\partial u}{\\partial x}$。将此代入本构关系，得到 $\\sigma = E \\frac{\\partial u}{\\partial x}$。\n接下来，我们将这个应力表达式代入运动方程：\n$$ \\frac{\\partial}{\\partial x} \\left( E \\frac{\\partial u}{\\partial x} \\right) = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\n由于杆是均匀的，其性质 $E$ 和 $\\rho$ 是常数，因此我们可以写成：\n$$ E \\frac{\\partial^2 u}{\\partial x^2} = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\n整理该方程可得经典的一维波动方程：\n$$ \\frac{\\partial^2 u}{\\partial t^2} = \\frac{E}{\\rho} \\frac{\\partial^2 u}{\\partial x^2} $$\n通过将其与标准形式 $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$ 进行比较，我们确定波速的平方为 $c^2 = \\frac{E}{\\rho}$。因此，纵向波速为 $c = \\sqrt{\\frac{E}{\\rho}}$。\n根据给定的数值 $E = 210 \\,\\text{GPa} = 210 \\times 10^9 \\,\\text{Pa}$ 和 $\\rho = 7800 \\,\\text{kg/m}^3$，波速为：\n$$ c = \\sqrt{\\frac{210 \\times 10^9}{7800}} \\,\\text{m/s} $$\n\n其次，我们估计最高可分辨角频率 $\\omega_{\\max}$。长度为 $L = 1.0 \\,\\text{m}$ 的杆被离散为 $N_{e} = 100$ 个均匀的有限元。因此，节点间距为 $h = \\frac{L}{N_{e}} = \\frac{1.0}{100} = 0.01 \\,\\text{m}$。\n空间采样理论指出，间距为 $h$ 的网格最多只能表示最小波长为 $\\lambda_{\\min} = 2h$ 的波。这相当于奈奎斯特-香农采样定理在空间上的应用。该模式对应于交替符号的节点位移模式（例如，$..., +1, -1, +1, -1, ...$）。最高可分辨波数 $k_{\\max}$ 与此最小波长相关：\n$$ k_{\\max} = \\frac{2\\pi}{\\lambda_{\\min}} = \\frac{2\\pi}{2h} = \\frac{\\pi}{h} $$\n题目要求估计相应的最高角频率 $\\omega_{\\max}$。最简单直接的估计是通过使用来自连续介质波动方程的非色散关系 $\\omega = c k$ 得到。将此应用于最高波数，可得：\n$$ \\omega_{\\max} = c k_{\\max} = c \\frac{\\pi}{h} $$\n代入 $c$ 和 $h$ 的表达式：\n$$ \\omega_{\\max} = \\left( \\sqrt{\\frac{210 \\times 10^9}{7800}} \\right) \\frac{\\pi}{0.01} = 100\\pi \\sqrt{\\frac{210 \\times 10^9}{7800}} \\,\\text{rad/s} $$\n数值计算结果为：\n$$ \\omega_{\\max} \\approx 1630080.3 \\,\\text{rad/s} $$\n根据题目要求，将此值四舍五入到四位有效数字，得到：\n$$ \\omega_{\\max} \\approx 1.630 \\times 10^6 \\,\\text{rad/s} $$\n\n第三，我们确定为实现最高频率模式所需振幅衰减的最小时间步数 $n$。广义-α方法由一个参数 $\\rho_{\\infty}$（无穷远处谱半径）来表征。该参数定义了当无量纲频率 $\\Omega = \\omega \\Delta t$ 趋于无穷大时，数值放大因子 $A(\\Omega)$ 的渐近行为：\n$$ \\rho_{\\infty} = \\lim_{\\Omega \\to \\infty} |A(\\Omega)| $$\n对于半离散系统的最高频率模式，例如频率为 $\\omega_{\\max}$ 的模式，每时间步的放大因子近似为 $\\rho_{\\infty}$。设 $\\omega_{\\max}$ 模式的初始振幅为 $A_0$。经过 $n$ 个时间步后，其振幅 $A_n$ 近似为：\n$$ A_n \\approx A_0 (\\rho_{\\infty})^n $$\n题目要求振幅减小 $10^{-3}$ 倍，这意味着最终振幅与初始振幅之比必须满足 $A_n / A_0 \\le 10^{-3}$。这导致不等式：\n$$ (\\rho_{\\infty})^n \\le 10^{-3} $$\n给定 $\\rho_{\\infty} = 0.5$。代入此值：\n$$ (0.5)^n \\le 10^{-3} $$\n为了求解 $n$，我们对两边取自然对数：\n$$ \\ln\\left((0.5)^n\\right) \\le \\ln(10^{-3}) $$\n利用对数性质 $\\ln(a^b) = b\\ln(a)$：\n$$ n \\ln(0.5) \\le -3 \\ln(10) $$\n由于 $\\ln(0.5) = -\\ln(2)$ 是一个负值，用它相除会使不等号反向：\n$$ n \\ge \\frac{-3 \\ln(10)}{-\\ln(2)} = \\frac{3 \\ln(10)}{\\ln(2)} $$\n使用标准值 $\\ln(10) \\approx 2.302585$ 和 $\\ln(2) \\approx 0.693147$：\n$$ n \\ge \\frac{3 \\times 2.302585}{0.693147} \\approx 9.96578 $$\n由于时间步数 $n$ 必须是整数，我们必须找到满足此条件的最小整数。这可以通过对该值向上取整得到：\n$$ n = \\lceil 9.96578 \\rceil = 10 $$\n因此，至少需要 $10$ 个时间步。\n\n最终答案由四舍五入到四位有效数字的最高角频率估计值 $\\omega_{\\max}$ 和最小整数时间步数 $n$ 组成。\n$$ (\\omega_{\\max}, n) = (1.630 \\times 10^6, 10) $$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.630 \\times 10^6  10\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从理论走向实践，这个练习要求你亲手实现广义-α方法，以求解一个代表土体单元动力响应的单自由度系统的演化。这项练习的目标不仅是让代码成功运行，更重要的是要通过数值实验来验证该方法的一个关键特性：算法能量耗散。通过追踪系统机械能随时间的变化，你可以直观地观察到当谱半径 $\\rho_{\\infty}  1$ 时，该数值积分方法是如何从系统中移除能量的，尤其是在外力停止作用后，这与高频振荡的衰减现象直接相关。",
            "id": "3521406",
            "problem": "考虑一个单自由度（SDOF）振子，它代表了饱和土单元在动力荷载作用下的有效应力骨架响应。其控制方程是牛顿第二定律的有效应力形式：\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) = F_{\\mathrm{eff}}(t),\n$$\n其中 $m$ 是质量，$c$ 是黏性阻尼，$k$ 是土骨架的弹性刚度，$x(t)$ 是位移，$F_{\\mathrm{eff}}(t)$ 是根据有效应力原理从总应力中减去孔隙水压力贡献后得到的有效外部驱动力。对于与 Terzaghi 有效应力原理一致的一维表示，驱动力可以概念化为：\n$$\nF_{\\mathrm{eff}}(t) = F_{\\mathrm{tot}}(t)\\,\\left(1 - r_u(t)\\right),\n$$\n其中 $F_{\\mathrm{tot}}(t)$ 是一个物理上合理的瞬态荷载，$r_u(t)$ 是孔压比，在加载期间从 $0$ 线性增加到一个预设的最大值。\n\n您需要使用广义-α方法进行时间离散，所选参数应能强制实现二阶精度，并通过无穷远处的预设谱半径来控制高频算法耗散。广义-α方法引入了两个参数 $\\alpha_m$ 和 $\\alpha_f$，并使用 $t_{n+1-\\alpha_m}$ 处的加权运动学在加权时间层 $t_{n+1-\\alpha_f}$ 重新定义平衡。离散运动学更新关系属于 Newmark 族，其参数为 $\\gamma$ 和 $\\beta$：\n$$\nx_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1},\n$$\n$$\nv_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n + \\gamma\\,\\Delta t\\,a_{n+1},\n$$\n平衡在广义时间层级上强制执行：\n$$\nm\\,a_{n+1-\\alpha_m} + c\\,v_{n+1-\\alpha_f} + k\\,x_{n+1-\\alpha_f} = F_{n+1-\\alpha_f},\n$$\n其中\n$$\na_{n+1-\\alpha_m} = \\left(1 - \\alpha_m\\right)a_{n+1} + \\alpha_m\\,a_n,\\quad\nv_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)v_{n+1} + \\alpha_f\\,v_n,\\quad\nx_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)x_{n+1} + \\alpha_f\\,x_n,\n$$\n且 $F_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)F_{n+1} + \\alpha_f\\,F_n$。为了达到二阶精度和无条件稳定性，必须根据无穷远处的谱半径 $\\rho_{\\infty}$ 计算参数：\n$$\n\\alpha_m = \\frac{2 - \\rho_{\\infty}}{1 + \\rho_{\\infty}},\\quad\n\\alpha_f = \\frac{1}{1 + \\rho_{\\infty}},\\quad\n\\gamma = \\tfrac{1}{2} + \\alpha_m - \\alpha_f,\\quad\n\\beta = \\tfrac{1}{4}\\left(1 + \\alpha_m - \\alpha_f\\right)^2.\n$$\n\n时间步 $n$ 处的离散机械能为\n$$\nE_n = \\tfrac{1}{2} k\\,x_n^2 + \\tfrac{1}{2} m\\,v_n^2,\n$$\n单位为焦耳（Joules）。为了验证算法耗散，您必须计算序列 $\\{E_n\\}$，并检查在瞬态荷载于已知的截止时间 $t_{\\mathrm{off}}$ 停止后，机械能是否对 $n$ 非增（允许可忽略的数值容差），即对于所有满足 $t_n \\ge t_{\\mathrm{off}}$ 的时间步，是否有 $E_{n+1} \\le E_n$。\n\n所有测试均使用以下固定的物理参数：$k = 1\\,\\mathrm{MN/m} = 10^6\\,\\mathrm{N/m}$，$m = 1000\\,\\mathrm{kg}$，$c = 1000\\,\\mathrm{N\\cdot s/m}$，$\\Delta t = 0.005\\,\\mathrm{s}$，以及 $\\rho_{\\infty} = 0.5$。对于初始条件，请使用每个测试案例指定的 $x_0$ 和 $v_0$，并计算 $a_0 = \\left(F_{\\mathrm{eff}}(0) - c\\,v_0 - k\\,x_0\\right)/m$。\n\n实施三个测试案例，构成一个测试套件：\n- 测试 1（带有有效应力折减的通用瞬态加载）：当 $0 \\le t \\le T_p$ 时，$F_{\\mathrm{tot}}(t) = F_0\\sin\\left(\\pi t / T_p\\right)$，否则 $F_{\\mathrm{tot}}(t) = 0$，其中 $F_0 = 100000\\,\\mathrm{N}$，$T_p = 0.5\\,\\mathrm{s}$。当 $0 \\le t \\le T_p$ 时，$r_u(t) = r_{u,\\max}\\left(t/T_p\\right)$，线性增加至 $r_{u,\\max} = 0.4$；当 $t  T_p$ 时，$r_u(t) = r_{u,\\max}$。使用 $x_0 = 0\\,\\mathrm{m}$ 和 $v_0 = 0\\,\\mathrm{m/s}$。模拟至 $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$。截止时间为 $t_{\\mathrm{off}} = T_p$。\n- 测试 2（自由振动边界情况）：对于所有 $t$，$F_{\\mathrm{tot}}(t) = 0$，$r_u(t) = 0$。$x_0 = 0.01\\,\\mathrm{m}$，$v_0 = 0\\,\\mathrm{m/s}$。模拟至 $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$。截止时间为 $t_{\\mathrm{off}} = 0$。\n- 测试 3（短时高频瞬态）：当 $0 \\le t \\le T_p$ 时，$F_{\\mathrm{tot}}(t) = F_0\\sin\\left(\\pi t / T_p\\right)$，否则 $F_{\\mathrm{tot}}(t) = 0$，其中 $F_0 = 100000\\,\\mathrm{N}$，$T_p = 0.05\\,\\mathrm{s}$。$r_u(t) = 0$，$x_0 = 0\\,\\mathrm{m}$，$v_0 = 0\\,\\mathrm{m/s}$。模拟至 $T_{\\mathrm{total}} = 1.0\\,\\mathrm{s}$。截止时间为 $t_{\\mathrm{off}} = T_p$。\n\n对于每个测试，计算离散能量序列 $\\{E_n\\}$，并返回一个布尔值，指示在使用物理上合理的微小数值容差标准下，对于所有满足 $t_n \\ge t_{\\mathrm{off}}$ 的时间步，能量是否非增。内部计算能量单位为焦耳；每个测试返回的结果是一个布尔值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 `[b_1,b_2,b_3]`，其中每个 $b_i$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$，并且输出行中不允许有空格。",
            "solution": "用户提供了一个在计算动力学领域定义明确的问题，特别关注代表土单元响应的单自由度（SDOF）系统的时间积分。该问题要求实施广义-α方法进行时间离散，并验证该方法的耗散特性。\n\n### 第1步：提取已知条件\n- **控制方程**：$m\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) = F_{\\mathrm{eff}}(t)$\n- **有效力**：$F_{\\mathrm{eff}}(t) = F_{\\mathrm{tot}}(t)\\,\\left(1 - r_u(t)\\right)$\n- **数值方法**：广义-α方法。\n- **运动学更新（Newmark族）**：\n  - $x_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1}$\n  - $v_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n + \\gamma\\,\\Delta t\\,a_{n+1}$\n- **离散平衡方程**：$m\\,a_{n+1-\\alpha_m} + c\\,v_{n+1-\\alpha_f} + k\\,x_{n+1-\\alpha_f} = F_{n+1-\\alpha_f}$\n- **加权状态变量**：\n  - $a_{n+1-\\alpha_m} = \\left(1 - \\alpha_m\\right)a_{n+1} + \\alpha_m\\,a_n$\n  - $v_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)v_{n+1} + \\alpha_f\\,v_n$\n  - $x_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)x_{n+1} + \\alpha_f\\,x_n$\n  - $F_{n+1-\\alpha_f} = \\left(1 - \\alpha_f\\right)F_{n+1} + \\alpha_f\\,F_n$\n- **广义-α参数公式**：\n  - $\\alpha_m = \\frac{2 - \\rho_{\\infty}}{1 + \\rho_{\\infty}}$\n  - $\\alpha_f = \\frac{1}{1 + \\rho_{\\infty}}$\n  - $\\gamma = \\tfrac{1}{2} + \\alpha_m - \\alpha_f$\n  - $\\beta = \\tfrac{1}{4}\\left(1 + \\alpha_m - \\alpha_f\\right)^2$\n- **离散机械能**：$E_n = \\tfrac{1}{2} k\\,x_n^2 + \\tfrac{1}{2} m\\,v_n^2$\n- **验证标准**：对于 $t_n \\ge t_{\\mathrm{off}}$，验证在微小数值容差内是否有 $E_{n+1} \\le E_n$。\n- **固定物理参数**：\n  - $k = 10^6\\,\\mathrm{N/m}$\n  - $m = 1000\\,\\mathrm{kg}$\n  - $c = 1000\\,\\mathrm{N\\cdot s/m}$\n  - $\\Delta t = 0.005\\,\\mathrm{s}$\n  - $\\rho_{\\infty} = 0.5$\n- **初始加速度**：$a_0 = \\left(F_{\\mathrm{eff}}(0) - c\\,v_0 - k\\,x_0\\right)/m$\n- **测试案例1**：\n  - 当 $t \\in [0, 0.5]$ 时，$F_{\\mathrm{tot}}(t) = 100000\\sin\\left(\\pi t / 0.5\\right)$，否则为 $0$。\n  - 当 $t \\in [0, 0.5]$ 时，$r_u(t) = 0.4(t/0.5)$，否则为 $0.4$。\n  - $x_0 = 0\\,\\mathrm{m}$，$v_0 = 0\\,\\mathrm{m/s}$。\n  - $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$，$t_{\\mathrm{off}} = 0.5\\,\\mathrm{s}$。\n- **测试案例2**：\n  - $F_{\\mathrm{tot}}(t) = 0$，$r_u(t) = 0$。\n  - $x_0 = 0.01\\,\\mathrm{m}$，$v_0 = 0\\,\\mathrm{m/s}$。\n  - $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$，$t_{\\mathrm{off}} = 0\\,\\mathrm{s}$。\n- **测试案例3**：\n  - 当 $t \\in [0, 0.05]$ 时，$F_{\\mathrm{tot}}(t) = 100000\\sin\\left(\\pi t / 0.05\\right)$，否则为 $0$。\n  - $r_u(t) = 0$。\n  - $x_0 = 0\\,\\mathrm{m}$，$v_0 = 0\\,\\mathrm{m/s}$。\n  - $T_{\\mathrm{total}} = 1.0\\,\\mathrm{s}$，$t_{\\mathrm{off}} = 0.05\\,\\mathrm{s}$。\n- **输出格式**：单行，`[b_1,b_2,b_3]`，其中 $b_i \\in \\{\\mathrm{True}, \\mathrm{False}\\}$，无空格。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据，借鉴了牛顿第二定律、土力学中的Terzaghi有效应力原理以及广义-α方法，后者是计算力学中一种标准且有详细文档的数值积分方案。所有参数、初始条件和激励函数都为每个测试案例明确定义，使得问题自洽且适定。语言客观、正式。提供的数据在量纲上一致，并且对于土动力学问题是物理上合理的。该任务是工程数值方法的标准练习，不违反任何无效性标准。\n\n### 第3步：结论与行动\n该问题**有效**。将制定并实施一个解决方案。\n\n### 基于原理的求解方案设计\n问题的核心是使用广义-α方法在离散时间步上求解SDOF运动方程。这是一种隐式方法，意味着时间 $t_{n+1}$ 的状态依赖于同一时间步的加速度 $a_{n+1}$。这需要在每一步求解一个关于 $a_{n+1}$ 的方程。\n\n1.  **算法参数计算**：首先，根据给定的无穷远处谱半径 $\\rho_{\\infty} = 0.5$，使用提供的公式计算广义-α方法的参数（$\\alpha_m, \\alpha_f$）和相关的Newmark参数（$\\beta, \\gamma$）。这些参数控制算法的精度和数值耗散。对于 $\\rho_{\\infty}  1.0$，该方法为高频振动引入了人工阻尼，这在许多应用中是保证稳定性的理想特性。\n\n2.  **步进求解器的推导**：离散平衡方程在加权时间层 $t_{n+1-\\alpha_f}$ 强制执行：\n    $$m\\,a_{n+1-\\alpha_m} + c\\,v_{n+1-\\alpha_f} + k\\,x_{n+1-\\alpha_f} = F_{n+1-\\alpha_f}$$\n    未知数是新时间步的加速度 $a_{n+1}$。所有其他量都可以用第 $n$ 步的已知值和 $a_{n+1}$ 来表示。我们将加权状态变量的定义和Newmark运动学关系代入平衡方程。\n    Newmark更新可以写成预测-校正格式。预测值用帽子（$\\hat{\\cdot}$）表示，首先计算：\n    $$ \\hat{x}_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n $$\n    $$ \\hat{v}_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n $$\n    最终的“校正”步骤使用 $a_{n+1}$ 的解来更新这些值：\n    $$ x_{n+1} = \\hat{x}_{n+1} + \\beta\\,\\Delta t^2\\,a_{n+1} $$\n    $$ v_{n+1} = \\hat{v}_{n+1} + \\gamma\\,\\Delta t\\,a_{n+1} $$\n    将这些关系代入展开的平衡方程，得到一个关于 $a_{n+1}$ 的线性代数方程：\n    $$ C_{eff} \\cdot a_{n+1} = R_{eff} $$\n    有效刚度/质量系数 $C_{eff}$ 和有效残余力 $R_{eff}$ 是通过将所有包含 $a_{n+1}$ 的项收集在左侧，所有其他（已知）项收集在右侧得到的。\n    系数 $C_{eff}$ 为：\n    $$ C_{eff} = m(1 - \\alpha_m) + c(1 - \\alpha_f)\\gamma\\Delta t + k(1 - \\alpha_f)\\beta\\Delta t^2 $$\n    右侧的 $R_{eff}$ 是基于预测状态的残余：\n    $$ R_{eff} = F_{n+1-\\alpha_f} - \\left( m\\alpha_m a_n + c((1-\\alpha_f)\\hat{v}_{n+1} + \\alpha_f v_n) + k((1-\\alpha_f)\\hat{x}_{n+1} + \\alpha_f x_n)\\right) $$\n    其中 $F_{n+1-\\alpha_f} = (1-\\alpha_f)F_{\\mathrm{eff}}(t_{n+1}) + \\alpha_f F_{\\mathrm{eff}}(t_n)$。\n    在每个时间步 $n$，我们求解 $a_{n+1} = R_{eff}/C_{eff}$，然后更新 $x_{n+1}$ 和 $v_{n+1}$。\n\n3.  **时间模拟循环**：\n    - 初始化状态向量 $x, v, a$ 和能量向量 $E$。初始加速度 $a_0$ 由 $t=0$ 时的平衡方程计算得出。\n    - 对于从 $n=0$ 到最后一步的每个时间步，执行上述求解器计算以找到 $(x_{n+1}, v_{n+1}, a_{n+1})$。\n    - 在每一步，计算机械能 $E_{n+1} = \\tfrac{1}{2} k x_{n+1}^2 + \\tfrac{1}{2} m v_{n+1}^2$ 并存储它。\n\n4.  **能量耗散验证**：对于给定的测试案例，模拟完成后，遍历存储的能量序列 $\\{E_n\\}$。对于所有满足 $t_n = n \\cdot \\Delta t \\ge t_{\\mathrm{off}}$ 的时间索引 $n$，检查条件 $E_{n+1} \\le E_n$ 是否成立。为考虑浮点数不精确性，此检查实现为 $E_{n+1} \\le E_n + \\epsilon$，其中 $\\epsilon$ 是一个小的正容差（例如 $10^{-9}\\,\\mathrm{J}$）。如果在指定范围内的任何 $n$ 违反了此条件，则该测试案例的结果为 `False`；否则为 `True`。对所有三个测试案例重复此过程。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the SDOF oscillator problem.\n    \"\"\"\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a single simulation for a given test case using the generalized-alpha method.\n        \"\"\"\n        # --- 1. Unpack parameters and initialize ---\n        k = 1.0e6  # Stiffness (N/m)\n        m = 1000.0   # Mass (kg)\n        c = 1000.0   # Damping (N.s/m)\n        dt = 0.005   # Time step (s)\n        rho_infty = 0.5  # Spectral radius at infinity\n\n        x0 = case['x0']\n        v0 = case['v0']\n        T_total = case['T_total']\n        t_off = case['t_off']\n        force_func = case['force_func']\n        \n        # --- 2. Calculate generalized-alpha and Newmark parameters ---\n        alpha_f = 1.0 / (1.0 + rho_infty)\n        alpha_m = (2.0 - rho_infty) / (1.0 + rho_infty)\n        gamma = 0.5 + alpha_m - alpha_f\n        beta = 0.25 * (1.0 + alpha_m - alpha_f)**2\n\n        # --- 3. Set up simulation arrays ---\n        num_steps = int(round(T_total / dt))\n        t = np.linspace(0, T_total, num_steps + 1)\n        \n        x = np.zeros(num_steps + 1)\n        v = np.zeros(num_steps + 1)\n        a = np.zeros(num_steps + 1)\n        E = np.zeros(num_steps + 1)\n\n        x[0], v[0] = x0, v0\n        F_eff_0 = force_func(0.0)\n        a[0] = (F_eff_0 - c * v[0] - k * x[0]) / m\n        E[0] = 0.5 * k * x[0]**2 + 0.5 * m * v[0]**2\n\n        # --- 4. Time integration loop ---\n        # Pre-calculate effective coefficient (constant for linear system)\n        C_eff = m * (1.0 - alpha_m) + c * (1.0 - alpha_f) * gamma * dt + k * (1.0 - alpha_f) * beta * dt**2\n\n        for n in range(num_steps):\n            # Known state at step n\n            x_n, v_n, a_n = x[n], v[n], a[n]\n            t_n, t_n1 = t[n], t[n+1]\n\n            # Forces at n and n+1\n            F_n = force_func(t_n)\n            F_n1 = force_func(t_n1)\n            F_alpha_f = (1.0 - alpha_f) * F_n1 + alpha_f * F_n\n            \n            # Predictor step (for terms not multiplied by a_{n+1})\n            v_hat_n1 = v_n + (1.0 - gamma) * dt * a_n\n            x_hat_n1 = x_n + dt * v_n + (0.5 - beta) * dt**2 * a_n\n\n            # Form effective right-hand side (residual from predictors)\n            R_eff = F_alpha_f - (m * alpha_m * a_n + \n                                 c * ((1.0 - alpha_f) * v_hat_n1 + alpha_f * v_n) +\n                                 k * ((1.0 - alpha_f) * x_hat_n1 + alpha_f * x_n))\n\n            # Solve for acceleration at n+1\n            a_n1 = R_eff / C_eff\n            a[n+1] = a_n1\n\n            # Corrector step\n            v[n+1] = v_hat_n1 + gamma * dt * a_n1\n            x[n+1] = x_hat_n1 + beta * dt**2 * a_n1\n\n            # Calculate and store energy\n            E[n+1] = 0.5 * k * x[n+1]**2 + 0.5 * m * v[n+1]**2\n\n        # --- 5. Verify energy dissipation ---\n        n_off = int(round(t_off / dt))\n        tolerance = 1e-9  # Small tolerance for floating point comparisons\n\n        for i in range(n_off, num_steps):\n            if E[i+1] > E[i] + tolerance:\n                return False\n        \n        return True\n\n    # --- Test Case Definitions ---\n\n    # Case 1: General transient loading\n    F0_1 = 100000.0\n    Tp_1 = 0.5\n    ru_max_1 = 0.4\n    def force_case1(t):\n        if 0 = t = Tp_1:\n            F_tot = F0_1 * np.sin(np.pi * t / Tp_1)\n            r_u = ru_max_1 * (t / Tp_1)\n            return F_tot * (1.0 - r_u)\n        elif t > Tp_1:\n            return 0.0 * (1.0 - ru_max_1) # F_tot is 0\n        return 0.0\n\n    # Case 2: Free vibration\n    def force_case2(t):\n        return 0.0\n\n    # Case 3: Short transient\n    F0_3 = 100000.0\n    Tp_3 = 0.05\n    def force_case3(t):\n        if 0 = t = Tp_3:\n            return F0_3 * np.sin(np.pi * t / Tp_3)\n        return 0.0\n\n    test_cases = [\n        {'x0': 0.0, 'v0': 0.0, 'T_total': 3.0, 't_off': 0.5, 'force_func': force_case1},\n        {'x0': 0.01, 'v0': 0.0, 'T_total': 3.0, 't_off': 0.0, 'force_func': force_case2},\n        {'x0': 0.0, 'v0': 0.0, 'T_total': 1.0, 't_off': 0.05, 'force_func': force_case3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
            "answer": "[True,True,True]"
        }
    ]
}