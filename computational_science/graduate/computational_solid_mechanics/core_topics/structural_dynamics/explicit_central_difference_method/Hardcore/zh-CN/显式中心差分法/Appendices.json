{
    "hands_on_practices": [
        {
            "introduction": "显式中心差分法的核心特点是其条件稳定性，这意味着时间步长的选择至关重要。第一个实践练习将带你从第一性原理出发，将有限元模型的属性（质量和刚度矩阵）与最大稳定时间步长直接联系起来。通过本练习 ，你将探究不同的建模选择，特别是质量矩阵的构建方式（集总质量与一致质量），如何影响系统的最高固有频率 $\\omega_{\\max}$，进而决定其稳定性极限 $\\Delta t \\le \\Delta t_{\\mathrm{cr}} = 2/\\omega_{\\max}$。",
            "id": "3564321",
            "problem": "考虑一根长为 $L = 1.0\\,\\mathrm{m}$、横截面积为 $A = 1.0\\times 10^{-4}\\,\\mathrm{m}^{2}$、质量密度为 $\\rho = 7850\\,\\mathrm{kg/m^{3}}$、杨氏模量为 $E = 210\\,\\mathrm{GPa}$ 的直均质轴向变形杆。该杆被离散为两个等长的一维线性有限元，节点位于 $x=0$、$x=L/2$ 和 $x=L$ 处。两端节点 $x=0$ 和 $x=L$ 被固定（狄利克雷边界条件），使得中间节点的位移成为唯一有效的自由度 (DOF)。在无阻尼线性动力学条件下，假设半离散模型为 $M \\ddot{u} + K u = 0$，并使用显式中心差分法 (CDM)，该方法由加速度在均匀时间步长 $\\Delta t$ 上的中心差分近似定义。\n\n从控制轴向动量平衡方程及其 Galerkin 弱形式出发，对每个单元使用标准的线性形函数来：\n- 推导单元级一致质量矩阵和刚度矩阵，\n- 施加边界条件后，组装降阶后的单自由度系统，\n- 建立并求解广义特征值问题，以获得一致质量和集总质量两种离散化方式下的 $\\omega_{\\max}$，以及\n- 使用 CDM 稳定性要求计算每种质量模型对应的临界时间步长 $\\Delta t_{\\mathrm{cr}}$。\n\n在您的解答中，简要地从物理上解释为什么一致质量模型和集总质量模型预测的 $\\omega_{\\max}$ 会有所不同。\n\n将两个临界时间步长的最终数值四舍五入到四位有效数字，并以微秒为单位表示。报告有序对 $\\left(\\Delta t_{\\mathrm{cr}}^{\\text{consistent}},\\ \\Delta t_{\\mathrm{cr}}^{\\text{lumped}}\\right)$。",
            "solution": "用户提供的问题经评估有效。该问题具有科学依据、提法明确、客观，并包含了获得唯一解所需的所有信息。\n\n该问题要求推导单元矩阵、组装降阶系统、计算一致质量模型和集总质量模型下的最高自然频率 $\\omega_{\\max}$，以及显式中心差分法 (CDM) 相应的临界时间步长 $\\Delta t_{\\mathrm{cr}}$。\n\n给定参数如下：\n长度 $L=1.0\\,\\mathrm{m}$\n横截面积 $A=1.0\\times10^{-4}\\,\\mathrm{m}^2$\n质量密度 $\\rho=7850\\,\\mathrm{kg/m^3}$\n杨氏模量 $E=210\\,\\mathrm{GPa} = 210 \\times 10^9\\,\\mathrm{Pa}$\n\n杆被离散为两个等长单元。每个单元的长度为 $l_e = \\frac{L}{2} = 0.5\\,\\mathrm{m}$。\n\n**1. 单元级矩阵**\n\n对于一维线性杆单元，位移场 $u(x)$ 通过线性形函数 $N_1(x), N_2(x)$ 从节点位移 $u_1^e, u_2^e$ 插值得到。轴向应变为 $\\epsilon_x = \\frac{du}{dx} = \\mathbf{B}\\mathbf{u}^e$，其中 $\\mathbf{B}$ 是应变-位移矩阵。\n$\\mathbf{B} = \\begin{bmatrix} \\frac{dN_1}{dx}  \\frac{dN_2}{dx} \\end{bmatrix} = \\frac{1}{l_e}\\begin{bmatrix} -1  1 \\end{bmatrix}$。\n\n单元刚度矩阵 $\\mathbf{k}^e$ 由下式给出：\n$$\n\\mathbf{k}^e = \\int_{0}^{l_e} \\mathbf{B}^T (EA) \\mathbf{B} \\,dx = EA \\int_{0}^{l_e} \\frac{1}{l_e^2}\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\\begin{bmatrix} -1  1 \\end{bmatrix} dx = \\frac{EA}{l_e^2}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\int_{0}^{l_e} dx\n$$\n$$\n\\mathbf{k}^e = \\frac{EA}{l_e}\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n\n单元一致质量矩阵 $\\mathbf{m}_c^e$ 是根据动能，使用相同的形函数推导出来的：\n$$\n\\mathbf{m}_c^e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} \\,dx = \\rho A \\int_{0}^{l_e} \\begin{bmatrix} N_1^2  N_1 N_2 \\\\ N_1 N_2  N_2^2 \\end{bmatrix} dx\n$$\n使用局部坐标 $\\xi \\in [-1, 1]$，其中 $N_1(\\xi)=\\frac{1-\\xi}{2}$，$N_2(\\xi)=\\frac{1+\\xi}{2}$，且 $dx=\\frac{l_e}{2}d\\xi$：\n$$\n\\mathbf{m}_c^e = \\rho A \\frac{l_e}{2} \\int_{-1}^{1} \\frac{1}{4}\\begin{bmatrix} (1-\\xi)^2  1-\\xi^2 \\\\ 1-\\xi^2  (1+\\xi)^2 \\end{bmatrix} d\\xi = \\rho A \\frac{l_e}{8} \\begin{bmatrix} \\frac{8}{3}  \\frac{4}{3} \\\\ \\frac{4}{3}  \\frac{8}{3} \\end{bmatrix} = \\frac{\\rho A l_e}{6}\\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n\n单元集总质量矩阵 $\\mathbf{m}_l^e$ 是通过将单元总质量 $\\rho A l_e$ 平均分配到两个节点上（或通过将 $\\mathbf{m}_c^e$ 的行元素求和并置于对角线上）得到的：\n$$\n\\mathbf{m}_l^e = \\frac{\\rho A l_e}{2}\\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n$$\n\n**2. 系统组装与降阶**\n\n全局系统有三个节点（自由度为 $u_1, u_2, u_3$）。单元1连接节点1-2，单元2连接节点2-3。组装单元矩阵：\n$$\nK_{global} = \\frac{EA}{l_e} \\begin{bmatrix} 1  -1  0 \\\\ -1  1+1  -1 \\\\ 0  -1  1 \\end{bmatrix} = \\frac{EA}{l_e} \\begin{bmatrix} 1  -1  0 \\\\ -1  2  -1 \\\\ 0  -1  1 \\end{bmatrix}\n$$\n$$\nM_{c, global} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2  1  0 \\\\ 1  2+2  1 \\\\ 0  1  2 \\end{bmatrix} = \\frac{\\rho A l_e}{6} \\begin{bmatrix} 2  1  0 \\\\ 1  4  1 \\\\ 0  1  2 \\end{bmatrix}\n$$\n$$\nM_{l, global} = \\frac{\\rho A l_e}{2} \\begin{bmatrix} 1  0  0 \\\\ 0  1+1  0 \\\\ 0  0  1 \\end{bmatrix} = \\rho A l_e \\begin{bmatrix} 1/2  0  0 \\\\ 0  1  0 \\\\ 0  0  1/2 \\end{bmatrix}\n$$\n边界条件为 $u_1=0$ 和 $u_3=0$。这使得只有 $u_2$ 是有效自由度。通过取全局矩阵的 (2,2) 项得到降阶系统。令 $K$、$M_c$ 和 $M_l$ 为降阶后的 $1 \\times 1$ 矩阵。\n$$\nK = \\frac{2EA}{l_e}\n$$\n$$\nM_c = \\frac{4\\rho A l_e}{6} = \\frac{2\\rho A l_e}{3}\n$$\n$$\nM_l = \\rho A l_e\n$$\n代入 $l_e = L/2$：\n$$\nK = \\frac{2EA}{L/2} = \\frac{4EA}{L}\n$$\n$$\nM_c = \\frac{2\\rho A (L/2)}{3} = \\frac{\\rho A L}{3}\n$$\n$$\nM_l = \\rho A (L/2) = \\frac{\\rho A L}{2}\n$$\n\n**3. 广义特征值问题**\n\n单自由度的无阻尼运动方程为 $M\\ddot{u}_2 + Ku_2 = 0$。假设简谐运动 $u_2(t) = U_2 e^{i\\omega t}$，我们得到特征值问题 $(K - \\omega^2 M)U_2 = 0$。为了得到非平凡解，$\\det(K - \\omega^2 M) = 0$，这可简化为 $\\omega^2 = \\frac{K}{M}$。\n\n对于**一致质量**模型：\n$$\n\\omega_c^2 = \\frac{K}{M_c} = \\frac{4EA/L}{\\rho A L / 3} = \\frac{12EA}{\\rho A L^2} = \\frac{12E}{\\rho L^2}\n$$\n因此，最大（也是唯一）频率为 $\\omega_{\\max, c} = \\sqrt{\\frac{12E}{\\rho L^2}}$。\n\n对于**集总质量**模型：\n$$\n\\omega_l^2 = \\frac{K}{M_l} = \\frac{4EA/L}{\\rho A L / 2} = \\frac{8EA}{\\rho A L^2} = \\frac{8E}{\\rho L^2}\n$$\n因此，最大（也是唯一）频率为 $\\omega_{\\max, l} = \\sqrt{\\frac{8E}{\\rho L^2}}$。\n\n**物理解释**\n一致质量矩阵是使用与刚度矩阵相同的插值函数推导出来的。对于粗糙网格，这种方法产生的耦合惯性表示会使离散化系统在动力学上比其实际物理对应物更“硬”。一个更硬的系统会以更高的频率振动。相反，集总质量矩阵将惯性对角化，解耦了节点间的惯性效应。这种简化使系统在动力学上更“柔”，从而导致较低的自然频率。对于此类问题，一个已知的特性是，对于给定的网格，一致质量公式给出了连续系统真实自然频率的上限，而集总质量公式给出了下限。我们的结果 $\\omega_c^2 = \\frac{12E}{\\rho L^2}$ 和 $\\omega_l^2 = \\frac{8E}{\\rho L^2}$，与两端固定连续杆的精确基频平方 $\\omega_1^2 = \\frac{\\pi^2 E}{\\rho L^2} \\approx \\frac{9.87E}{\\rho L^2}$ 一致，其中 $\\omega_l  \\omega_1  \\omega_c$。\n\n**4. 临界时间步长计算**\n\n显式中心差分法的稳定性极限由下式给出：\n$$\n\\Delta t \\le \\Delta t_{\\mathrm{cr}} = \\frac{2}{\\omega_{\\max}}\n$$\n其中 $\\omega_{\\max}$ 是离散系统的最高自然频率。\n\n对于**一致质量**模型：\n$$\n\\omega_{\\max, c} = \\sqrt{\\frac{12(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{2.52 \\times 10^{12}}{7850}} \\approx 17917.00\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = \\frac{2}{17917.00} \\approx 1.11626 \\times 10^{-4}\\,\\mathrm{s} = 111.626\\,\\mu\\mathrm{s}\n$$\n四舍五入到四位有效数字，$\\Delta t_{\\mathrm{cr}}^{\\text{consistent}} = 111.6\\,\\mu\\mathrm{s}$。\n\n对于**集总质量**模型：\n$$\n\\omega_{\\max, l} = \\sqrt{\\frac{8(210 \\times 10^9)}{7850(1.0)^2}} = \\sqrt{\\frac{1.68 \\times 10^{12}}{7850}} \\approx 14629.17\\,\\mathrm{rad/s}\n$$\n$$\n\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = \\frac{2}{14629.17} \\approx 1.36713 \\times 10^{-4}\\,\\mathrm{s} = 136.713\\,\\mu\\mathrm{s}\n$$\n四舍五入到四位有效数字，$\\Delta t_{\\mathrm{cr}}^{\\text{lumped}} = 136.7\\,\\mu\\mathrm{s}$。\n\n最终答案是以微秒为单位的临界时间步长的有序对。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 111.6  136.7 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在掌握了稳定性的基本理论后，我们将把注意力转向一个实际的非线性应用。本练习  要求你实现显式中心差分法（以其蛙跳格式）来模拟固体力学中常见的两体碰撞问题。练习的重点不仅在于将数值结果与解析解进行比较，更在于验证你的数值格式是否遵循了基本的物理定律——线性动量守恒，这对于建立对仿真结果的信心至关重要。",
            "id": "3564243",
            "problem": "考虑一个计算固体力学中的一维双体碰撞问题，该问题由 Newton 第二定律和一个通过线性罚函数建模的无摩擦单边接触所支配。两个质点，其在一条直线上的位置分别为 $x_1(t)$ 和 $x_2(t)$（单位：米），仅沿该直线运动。质量 $1$ 初始位于左侧：$x_1(0) = 0$，质量 $2$ 初始位于右侧：$x_2(0) = \\text{gap}_0 > 0$。初始速度为 $v_1(0)$ 和 $v_2(0)$（单位：米/秒）。接触是无摩擦的，且仅在压缩状态下激活，接触力大小为 $f_c = k_c \\max(0, x_1 - x_2)$（单位：牛顿），以相等的大小和相反的方向作用于两个质量上。没有外力。所有物理量必须在国际单位制（SI）中处理：质量单位为千克，长度单位为米，时间单位为秒。\n\n您的任务是从第一性原理推导并实现一个显式中心差分时间积分器（蛙跳格式），以演化系统从时间 $t = 0$ 开始，直到任何接触事件后的第一次完全分离。该积分器必须仅使用以下基本依据构建：\n- Newton 第二定律，$m_i \\, \\ddot{x}_i = F_i$。\n- 通过时间差分关联速度和位置的运动学定义。\n- 罚函数接触模型 $f_c = k_c \\max(0, x_1 - x_2)$，其中内力为 $F_1 = -f_c$ 和 $F_2 = +f_c$。\n\n不得假定任何其他预打包的公式或方法。特别是，您必须确保在离散层面，内力的大小相等、方向相反的结构得以保持，从而使数值格式在数值舍入误差范围内满足总动量平衡。使用均匀的时间步长 $\\Delta t$，该步长由最高预期接触频率 $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$ 决定的线性化稳定性极限来选择。设 $\\Delta t = \\gamma \\, \\frac{2}{\\omega}$，其中 $\\gamma \\in (0, 1)$ 是一个给定的无量纲因子。\n\n验证目标：\n1. 动量守恒：在整个计算过程中跟踪总线性动量 $P(t) = m_1 v_1(t) + m_2 v_2(t)$，并记录其与初始值 $P(0)$ 的最大绝对偏差。如果此最大偏差不大于 $10^{-10}$ 千克·米/秒，则认为计算是动量守恒的。\n2. 碰撞后速度：当且仅当接触实际发生时（即压缩在某个时间点被激活），第一次分离后的速度必须与从守恒定律解析计算出的一维完全弹性（$e=1$）碰撞的速度相匹配。用 $v_1^+$ 和 $v_2^+$ 表示初始接触后完全分离时的第一次恒定速度。完全弹性碰撞的解析解为\n$$\nv_1^{\\star} = \\frac{m_1 - m_2}{m_1 + m_2} v_1(0) + \\frac{2 m_2}{m_1 + m_2} v_2(0), \\quad\nv_2^{\\star} = \\frac{2 m_1}{m_1 + m_2} v_1(0) + \\frac{m_2 - m_1}{m_1 + m_2} v_2(0).\n$$\n验证要求 $\\lvert v_1^+ - v_1^{\\star} \\rvert \\le 10^{-3}$ 米/秒 和 $\\lvert v_2^+ - v_2^{\\star} \\rvert \\le 10^{-3}$ 米/秒。在没有发生接触的情况下（物体从未压缩），解析的碰撞后速度就是初始速度，并且适用相同的容差。\n\n数值程序要求：\n- 以与 Newton 第二定律和罚函数接触模型一致的方式，构建具有半步速度的显式中心差分（蛙跳）格式。根据零外力和给定的初始数据，一致地初始化半步速度。\n- 当 $x_1 - x_2 > 0$ 时检测接触激活，当系统从 $x_1 - x_2 > 0$ 过渡到 $x_1 - x_2 \\le 0$ 时检测接触解除。在激活后的第一次解除时，记录 $v_1^+$ 和 $v_2^+$ 并停止模拟。\n- 使用足够长的模拟时域，以保证如果发生接触，能够捕捉到第一次分离。设置时域时需要考虑的自然频率是 $\\omega = \\sqrt{k_c \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)}$ 及其相关周期 $T = \\frac{2\\pi}{\\omega}$。\n\n测试套件：\n实现您的程序以运行以下四个独立的测试用例，每个用例由元组 $(m_1, m_2, \\text{gap}_0, v_1(0), v_2(0), k_c, \\gamma)$ 指定：\n\n- 测试 A（不等质量，相互靠近）：\n  - $m_1 = 1.0$ 千克, $m_2 = 2.0$ 千克, $\\text{gap}_0 = 0.01$ 米, $v_1(0) = 1.0$ 米/秒, $v_2(0) = 0.0$ 米/秒, $k_c = 1.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.90$。\n- 测试 B（无接触，相互分离）：\n  - $m_1 = 1.0$ 千克, $m_2 = 1.5$ 千克, $\\text{gap}_0 = 0.01$ 米, $v_1(0) = 0.0$ 米/秒, $v_2(0) = 0.5$ 米/秒, $k_c = 1.0 \\times 10^{5}$ 牛顿/米, $\\gamma = 0.90$。\n- 测试 C（刚性接触，接近稳定性极限）：\n  - $m_1 = 0.5$ 千克, $m_2 = 5.0$ 千克, $\\text{gap}_0 = 0.005$ 米, $v_1(0) = 2.0$ 米/秒, $v_2(0) = 0.0$ 米/秒, $k_c = 5.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.99$。\n- 测试 D（相等质量，一般性靠近）：\n  - $m_1 = 1.0$ 千克, $m_2 = 1.0$ 千克, $\\text{gap}_0 = 0.02$ 米, $v_1(0) = 1.2$ 米/秒, $v_2(0) = -0.4$ 米/秒, $k_c = 2.0 \\times 10^{6}$ 牛顿/米, $\\gamma = 0.80$。\n\n对于每个测试用例，计算：\n- 一个布尔值，指示在整个模拟过程中动量守恒是否保持在 $10^{-10}$ 千克·米/秒以内。\n- 一个布尔值，指示碰撞后速度是否在 $10^{-3}$ 米/秒内满足解析值。如果发生接触，则使用上述完全弹性公式；如果未发生接触，则使用初始值。\n\n使用逻辑与（两者必须为真）将这两个条件组合起来，为每个测试生成一个单一的布尔结果。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含按给定顺序排列的四个测试的结果，形式为用方括号括起来的逗号分隔列表。例如，输出可能看起来像 $[\\text{True},\\text{False},\\text{True},\\text{True}]$，但没有空格。元素必须是布尔值。",
            "solution": "用户要求为一维双体碰撞问题开发并验证一个数值解。该解必须使用显式中心差分（蛙跳）方法从第一性原理推导，并根据解析守恒定律进行验证。\n\n**1. 运动控制方程**\n\n该系统由两个质点 $m_1$ 和 $m_2$ 组成，其位置分别为 $x_1(t)$ 和 $x_2(t)$。其动力学由 Newton 第二定律控制：\n$$m_1 \\ddot{x}_1(t) = F_1(t)$$\n$$m_2 \\ddot{x}_2(t) = F_2(t)$$\n其中 $\\ddot{x}_i$ 表示质量 $i$ 的加速度，$F_i$ 是作用在其上的净力。问题指定了一个单边罚函数接触模型，且没有外力。接触力 $f_c$ 仅在发生侵入时（$g > 0$，其中 $g = x_1 - x_2$ 是有符号侵入量）激活。作用在质量上的力是内力，大小相等，方向相反：\n$$f_c(t) = k_c \\max(0, x_1(t) - x_2(t))$$\n$$F_1(t) = -f_c(t)$$\n$$F_2(t) = +f_c(t)$$\n这意味着系统上的总力为零，$F_1(t) + F_2(t) = 0$，因此系统的总线性动量必须守恒。\n\n**2. 显式中心差分（蛙跳）积分器的推导**\n\n我们用一个恒定的时间步长 $\\Delta t$ 来离散化时间，使得 $t_n = n \\Delta t$。我们用 $x_i^n$、$v_i^n$ 和 $a_i^n$ 分别表示质量 $i$ 在时间 $t_n$ 的位置、速度和加速度。\n\n蛙跳法将速度评估交错在半个时间步上，$t_{n \\pm 1/2} = (n \\pm 1/2) \\Delta t$，这增强了稳定性。基本中心差分近似为：\n半步 $n+1/2$ 处的速度围绕时间 $t_{n+1/2}$ 中心化：\n$$v_i^{n+1/2} = \\frac{x_i^{n+1} - x_i^n}{\\Delta t}$$\n整步 $n$ 处的加速度围绕时间 $t_n$ 中心化：\n$$a_i^n = \\frac{v_i^{n+1/2} - v_i^{n-1/2}}{\\Delta t}$$\n\n这些近似可以重排成一个显式时间步进算法。位置更新法则（“漂移”）由第一个公式推导而来：\n$$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\n速度更新法则（“踢”）由第二个公式推导而来：\n$$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n\n算法在每个时间步 $n$ 按以下步骤进行：\n1.  给定位置 $x_i^n$ 和来自前一个半步的速度 $v_i^{n-1/2}$。\n2.  基于当前位置 $x_i^n$ 计算力 $F_i^n$：\n    $$g^n = x_1^n - x_2^n$$\n    $$f_c^n = k_c \\max(0, g^n)$$\n    $$F_1^n = -f_c^n, \\quad F_2^n = +f_c^n$$\n3.  使用 Newton 定律 $a_i^n = F_i^n / m_i$ 计算加速度 $a_i^n$：\n    $$a_1^n = -f_c^n / m_1, \\quad a_2^n = +f_c^n / m_2$$\n4.  将速度从半步 $n-1/2$ 更新到 $n+1/2$：\n    $$v_i^{n+1/2} = v_i^{n-1/2} + \\Delta t \\cdot a_i^n$$\n5.  使用新计算的半步速度将位置从步 $n$ 更新到 $n+1$：\n    $$x_i^{n+1} = x_i^n + \\Delta t \\cdot v_i^{n+1/2}$$\n\n**3. 初始化**\n\n蛙跳格式需要一个半步上的初始速度 $v_i^{-1/2}$，以开始在 $n=0$ 的第一次迭代。我们给定了在 $t=0$ 的初始条件，即 $x_i^0$ 和 $v_i^0$。我们可以通过一个半步后向 Euler 步来近似 $v_i^{-1/2}$：\n$$v_i^0 \\approx \\frac{v_i^{1/2} + v_i^{-1/2}}{2}$$\n重排 $n=0$ 时的加速度公式，我们有 $v_i^{1/2} = v_i^{-1/2} + \\Delta t \\cdot a_i^0$。将此代入速度近似中得到：\n$$v_i^0 \\approx \\frac{(v_i^{-1/2} + \\Delta t \\cdot a_i^0) + v_i^{-1/2}}{2} = v_i^{-1/2} + \\frac{\\Delta t}{2} a_i^0$$\n解出 $v_i^{-1/2}$ 得到启动速度：\n$$v_i^{-1/2} = v_i^0 - \\frac{\\Delta t}{2} a_i^0$$\n对于这个特定问题，初始位置为 $x_1(0) = 0$ 和 $x_2(0) = \\text{gap}_0 > 0$。因此，初始侵入量是负的，$x_1^0 - x_2^0  0$，这意味着初始接触力 $f_c^0$ 为零。因此，初始加速度 $a_i^0$ 为零，启动过程简化为 $v_i^{-1/2} = v_i^0$。\n\n**4. 动量守恒**\n\n如规定，离散格式必须保持总线性动量。设 $P^{n+1/2} = m_1 v_1^{n+1/2} + m_2 v_2^{n+1/2}$ 为与半步速度相关的总动量。使用速度更新法则：\n$$P^{n+1/2} = m_1(v_1^{n-1/2} + \\Delta t \\cdot a_1^n) + m_2(v_2^{n-1/2} + \\Delta t \\cdot a_2^n)$$\n$$P^{n+1/2} = (m_1 v_1^{n-1/2} + m_2 v_2^{n-1/2}) + \\Delta t (m_1 a_1^n + m_2 a_2^n)$$\n$$P^{n+1/2} = P^{n-1/2} + \\Delta t (F_1^n + F_2^n)$$\n因为 $F_1^n + F_2^n = -f_c^n + f_c^n = 0$，我们有 $P^{n+1/2} = P^{n-1/2}$。这表明半步上的动量在迭代过程中是精确守恒的（在浮点精度范围内）。整步速度定义为 $v_i^n = (v_i^{n+1/2} + v_i^{n-1/2})/2$。因此，在整步 $n$ 的总动量 $P^n = m_1 v_1^n + m_2 v_2^n$ 也是恒定的，因为它是两个恒定量之和的平均值。\n\n**5. 实现与验证流程**\n\n模拟将基于推导出的算法来实现。\n- **时间步长：** 稳定的时间步长 $\\Delta t$ 计算为 $\\Delta t = \\gamma \\frac{2}{\\omega}$，其中 $\\omega = \\sqrt{k_c (\\frac{1}{m_1} + \\frac{1}{m_2})}$ 是双体接触振子的自然频率。\n- **模拟循环：** 循环进行迭代，更新位置和速度。使用一个布尔标志 `contact_activated` 来跟踪是否曾发生过侵入。\n- **终止条件：** 模拟在首次从侵入状态（$x_1^n - x_2^n > 0$）过渡到分离状态（$x_1^{n+1} - x_2^{n+1} \\le 0$）时停止。最终速度 $v_1^+$ 和 $v_2^+$ 取为分离时刻的半步速度 $v_1^{n+1/2}$ 和 $v_2^{n+1/2}$，因为它们代表了后续自由飞行区间的恒定速度。如果模拟在达到最大步数后仍未发生接触，则最终速度就是初始速度。\n- **验证：**\n    1.  **动量守恒：** 在每一步 $n$，使用整步速度定义计算总动量 $P^n$，并与初始动量 $P^0 = m_1 v_1^0 + m_2 v_2^0$ 进行比较。记录模拟过程中的最大绝对偏差，并与 $10^{-10}$ kg·m/s 的容差进行核对。\n    2.  **碰撞后速度：** 将数值得到的后分离速度（$v_1^+, v_2^+$）与完全弹性碰撞的解析速度（$v_1^{\\star}, v_2^{\\star}$）进行比较；如果未发生接触，则与初始速度比较。绝对差必须在 $10^{-3}$ m/s 的容差范围内。\n\n通过对两个验证结果进行逻辑与操作，为每个测试用例生成一个单一的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma):\n    \"\"\"\n    Runs a single simulation for the two-body impact problem.\n\n    Returns:\n        (bool, bool): A tuple containing the results for momentum conservation\n                      and post-impact velocity verification.\n    \"\"\"\n    # 1. Setup and Initialization\n    omega = np.sqrt(kc * (1/m1 + 1/m2))\n    dt = gamma * 2 / omega\n\n    # Initial state vectors\n    pos = np.array([0.0, gap0], dtype=np.float64)  # [x1, x2] at step n\n    vel_0 = np.array([v1_0, v2_0], dtype=np.float64) # [v1, v2] at t=0\n\n    # Initial acceleration is zero since there is no initial contact\n    accel_0 = np.array([0.0, 0.0], dtype=np.float64)\n    \n    # Initialize half-step velocity using the startup formula\n    # v_half(-1/2) = v(0) - dt/2 * a(0)\n    vel_half = vel_0 - (dt / 2.0) * accel_0  # Represents v at n-1/2\n\n    masses = np.array([m1, m2], dtype=np.float64)\n    inv_masses = 1.0 / masses\n\n    # Verification trackers\n    p_initial = np.dot(masses, vel_0)\n    max_p_dev = 0.0\n    \n    contact_activated = False\n    v_final = np.copy(vel_0) # Default final velocities are initial velocities\n\n    # Simulation horizon (large enough to capture events)\n    max_steps = 2_000_000\n\n    # 2. Main Simulation Loop (Leapfrog)\n    for n in range(max_steps):\n        # State at step n: pos, vel_half (which is v at n-1/2)\n        \n        # Calculate forces at step n based on pos_n\n        penetration = pos[0] - pos[1]\n        \n        if penetration > 0:\n            contact_activated = True\n        \n        fc = kc * max(0, penetration)\n        forces = np.array([-fc, fc], dtype=np.float64)\n\n        # Calculate accelerations at step n\n        accel_n = forces * inv_masses\n\n        # Calculate full-step velocity v_n for momentum check\n        # v_n = (v_{n+1/2} + v_{n-1/2}) / 2\n        # v_{n+1/2} = v_{n-1/2} + dt * a_n\n        vel_half_next = vel_half + dt * accel_n\n        vel_full_n = (vel_half_next + vel_half) / 2.0\n        \n        # Check momentum conservation at step n\n        p_current = np.dot(masses, vel_full_n)\n        max_p_dev = max(max_p_dev, abs(p_current - p_initial))\n        \n        # --- Update state for next step ---\n        # Update half-step velocity to n+1/2\n        vel_half = vel_half_next\n        \n        # Update position to n+1 using v_{n+1/2}\n        pos_next = pos + dt * vel_half\n\n        # Check for termination condition: first separation after contact\n        if contact_activated and (penetration > 0) and (pos_next[0] - pos_next[1] = 0):\n            v_final = np.copy(vel_half) # Final velocity is the constant post-impact velocity\n            break\n        \n        pos = pos_next\n    else: # This else clause runs if the for loop finishes without a break\n        # This handles the no-contact case. v_final remains vel_0.\n        pass\n\n    # 3. Verification\n    \n    # Check 1: Momentum conservation\n    momentum_ok = max_p_dev = 1e-10\n\n    # Check 2: Post-impact velocities\n    if contact_activated:\n        # Compare with analytical elastic collision velocities\n        m_sum = m1 + m2\n        v1_star = ((m1 - m2) / m_sum) * v1_0 + ((2 * m2) / m_sum) * v2_0\n        v2_star = ((2 * m1) / m_sum) * v1_0 + ((m2 - m1) / m_sum) * v2_0\n        v_analytical = np.array([v1_star, v2_star], dtype=np.float64)\n    else:\n        # No contact occurred, compare with initial velocities\n        v_analytical = vel_0\n\n    velocity_dev = np.abs(v_final - v_analytical)\n    velocity_ok = np.all(velocity_dev = 1e-3)\n    \n    return momentum_ok, velocity_ok\n\n\ndef solve():\n    # Test cases: (m1, m2, gap0, v1(0), v2(0), kc, gamma)\n    test_cases = [\n        # Test A (general unequal masses, approaching)\n        (1.0, 2.0, 0.01, 1.0, 0.0, 1.0e6, 0.90),\n        # Test B (no contact, separating)\n        (1.0, 1.5, 0.01, 0.0, 0.5, 1.0e5, 0.90),\n        # Test C (stiff contact, near stability limit)\n        (0.5, 5.0, 0.005, 2.0, 0.0, 5.0e6, 0.99),\n        # Test D (equal masses, generic approaching)\n        (1.0, 1.0, 0.02, 1.2, -0.4, 2.0e6, 0.80),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, gap0, v1_0, v2_0, kc, gamma = case\n        momentum_ok, velocity_ok = run_simulation_case(m1, m2, gap0, v1_0, v2_0, kc, gamma)\n        # Final result is the logical conjunction of both conditions\n        final_result = momentum_ok and velocity_ok\n        results.append(str(final_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个练习将第一个练习中的静态时间步长计算推广为一种适用于复杂动态仿真的运行时算法。在真实的模拟场景中，网格可能因为单元侵蚀等材料失效行为而发生改变。本高级实践  将指导你设计一个算法，用于实时监控网格中所有活动单元的稳定性限制（即CFL条件），并动态调整全局时间步长，从而确保仿真在高效和稳健的状态下进行，弥合教科书理论与工业级代码实现之间的差距。",
            "id": "3564264",
            "problem": "您的任务是从第一性原理出发，为通过有限元离散的一维小应变线弹性杆的显式中心差分积分，开发一种时间步长控制的运行时算法。由于单元侵蚀，网格可能在模拟过程中发生变化。目标是通过将全局时间增量维持在一个能适应几何和材料变化的保守稳定性边界之下，来确保数值稳定性，并通过随着网格演化跟踪最小的容许单元时间增量来实现此目标。\n\n从连续介质动量平衡及其半离散有限元形式出发，推导出一个用单元几何和材料量表示的、保守的、单元层面的稳定性边界。然后，设计一个运行时算法，在每个全局步中，计算一个全局稳定增量，该增量为当前激活单元集上的一个按安全系数缩放的最小值。当一个标量损伤变量超过阈值时，网格会通过一个侵蚀规则永久移除单元。该算法必须支持每步更新单元长度和损伤，必须立即在全局时间步长中反映单元的移除，并且必须继续模拟，直到达到预设的物理结束时间或所有单元均被移除。\n\n在每一步，根据当前的激活单元计算基于稳定性的候选增量，此时不考虑任何为满足结束时间的截断。将物理时间推进一个执行增量，该增量是基于稳定性的候选增量和到结束时间的剩余时间中的较小者。对于下面要求的统计数据，仅使用基于稳定性的候选值，忽略为精确达到结束时间而进行的最终截断。\n\n物理模型和更新规则：\n- 每个单元 $i$ 在步骤 $n$ 的当前长度为 $L_i^n$（单位为 $\\mathrm{m}$），密度为 $\\rho_i$（单位为 $\\mathrm{kg/m^3}$，是常数），当前杨氏模量为 $E_i^n$（单位为 $\\mathrm{Pa}$）。初始值为 $L_i^0 = L_{0,i}$，$E_i^0 = E_{0,i}$。\n- 单元波速为 $c_i^n$（单位为 $\\mathrm{m/s}$），由您从第一性原理推导得出。\n- 每步的长度更新为 $L_i^{n+1} = L_i^n (1 + s_i)$，其中 $s_i$ 是给定的每步工程应变增量（无量纲）。假设 $|s_i| \\ll 1$，因此小应变运动学在步进上是自洽的。\n- 标量损伤变量 $d_i^n \\in [0,1]$ 的演化规律为 $d_i^{n+1} = \\min\\{1, d_i^n + g_i\\}$，其中 $g_i \\ge 0$ 是给定的每步增量（无量纲）。模量退化规律为 $E_i^n = (1 - d_i^n) E_{0,i}$。\n- 侵蚀：如果在一个步骤结束时 $d_i^{n+1} \\ge d_{\\mathrm{thr},i}$，则单元 $i$ 在下一个步骤开始前被移除，并在此后保持非激活状态。\n- 步骤 $n$ 的全局时间增量是安全系数 $\\eta \\in (0,1)$ 乘以您必须使用显式中心差分法推导出的、在所有当前激活单元上取的单元层面保守稳定性边界的最小值。将此候选增量表示为 $\\Delta t_{\\mathrm{cand}}^n$。执行的增量为 $\\Delta t_{\\mathrm{exec}}^n = \\min\\{\\Delta t_{\\mathrm{cand}}^n, T_{\\mathrm{end}} - t^n\\}$。\n\n假设：\n- 一维杆运动学，小应变，线弹性，无外力；完全专注于齐次更新的稳定性。\n- 使用标准的有限元质量和刚度构造，以及一个适用于显式中心差分时间积分的、物理上合理的保守边界。\n- 安全系数为 $\\eta = 0.9$。\n- 当没有激活单元剩下时，将候选增量设为 $\\Delta t_{\\mathrm{cand}}^n = 0$ 并立即终止模拟。\n\n每个测试用例的必需输出：\n- 初始候选全局增量 $\\Delta t_{\\mathrm{cand}}^0$（单位为 $\\mathrm{s}$）。\n- 所有步骤中候选全局增量的最小值 $\\min_n \\Delta t_{\\mathrm{cand}}^n$（单位为 $\\mathrm{s}$）。\n- 所有步骤中候选全局增量的最大值 $\\max_n \\Delta t_{\\mathrm{cand}}^n$（单位为 $\\mathrm{s}$）。\n- 执行的总步数（一个整数），即终止前使用的 $\\Delta t_{\\mathrm{exec}}^n$ 的计数。\n对于最小值和最大值，不要考虑为精确达到 $T_{\\mathrm{end}}$ 而使用的最终截断；仅使用基于稳定性的候选值。\n\n单位和格式：\n- 所有长度单位必须是 $\\mathrm{m}$，密度单位是 $\\mathrm{kg/m^3}$，模量单位是 $\\mathrm{Pa}$，时间单位是 $\\mathrm{s}$。所有时间量都用 $\\mathrm{s}$ 表示。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个列表，顺序为 $[\\Delta t_{\\mathrm{cand}}^0, \\min_n \\Delta t_{\\mathrm{cand}}^n, \\max_n \\Delta t_{\\mathrm{cand}}^n, \\text{steps}]$。例如：$[[a,b,c,d],[e,f,g,h],[i,j,k,l]]$。对实数使用标准十进制或科学记数法。\n\n测试套件：\n- 案例 $1$（理想情况，无侵蚀）：\n  - $N = 4$。\n  - $\\rho = [7800, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.010, 0.012, 0.009, 0.011]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0, 0]$。\n  - $g = [0, 0, 0, 0]$。\n  - $d_{\\mathrm{thr}} = [1, 1, 1, 1]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$。\n- 案例 $2$（侵蚀导致全局时间步长在运行中途增加）：\n  - $N = 5$。\n  - $\\rho = [2700, 2700, 7800, 7800, 7800]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [7.0 \\times 10^{10}, 7.0 \\times 10^{10}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}, 2.10 \\times 10^{11}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.010, 0.006, 0.008, 0.005, 0.007]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0, 0, 0]$。\n  - $g = [0.02, 0.05, 0, 0.03, 0]$。\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5, 0.5, 0.5]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$。\n- 案例 $3$（边界情况，所有单元几乎立即侵蚀）：\n  - $N = 3$。\n  - $\\rho = [1000, 1000, 1000]\\ \\mathrm{kg/m^3}$。\n  - $E_0 = [3.0 \\times 10^{9}, 3.0 \\times 10^{9}, 3.0 \\times 10^{9}]\\ \\mathrm{Pa}$。\n  - $L_0 = [0.004, 0.004, 0.004]\\ \\mathrm{m}$。\n  - $s = [0, 0, 0]$。\n  - $g = [0.5, 0.5, 0.5]$。\n  - $d_{\\mathrm{thr}} = [0.5, 0.5, 0.5]$。\n  - $T_{\\mathrm{end}} = 1.0 \\times 10^{-3}\\ \\mathrm{s}$。\n\n您的实现应遵循您推导出的稳定性边界，并且必须根据上述规则管理不断变化的激活单元集。要求的最终输出格式是单行文本，包含一个由三个列表组成的列表，每个列表对应一个测试用例，如上所述，所有时间量单位为 $\\mathrm{s}$，步数为整数。",
            "solution": "在计算力学中，为显式动力学模拟确定一个稳定的时间增量是一个根本性问题。该方法要求为所选的时间积分方案——显式中心差分法——应用于空间离散系统——用有限元建模的杆——推导其稳定性极限。这个极限被称为 Courant-Friedrichs-Lewy (CFL) 条件，它规定信息（物理波）在单个时间步内传播的距离不能超过一个单元。我们将从第一性原理出发推导这个条件，然后构建一个算法，以根据不断变化的材料属性和网格几何形状来调整全局时间步长。\n\n### 基于稳定性的时间增量的推导\n\n1.  **连续介质运动方程**：假设小应变且无体力，一维弹性杆的动力学由动量平衡方程控制：\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial \\sigma}{\\partial x}\n    $$\n    其中 $\\rho$ 是材料密度，$u(x,t)$ 是轴向位移，$\\sigma(x,t)$ 是轴向应力。\n\n2.  **本构关系和运动学关系**：对于线弹性材料，应力通过胡克定律与应变 $\\epsilon$ 相关：$\\sigma = E \\epsilon$，其中 $E$ 是杨氏模量。小应变假设提供了运动学关系 $\\epsilon = \\frac{\\partial u}{\\partial x}$。将这些代入动量方程，得到一维波动方程：\n    $$\n    \\rho \\frac{\\partial^2 u}{\\partial t^2} = E \\frac{\\partial^2 u}{\\partial x^2} \\implies \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}\n    $$\n    其中 $c = \\sqrt{E/\\rho}$ 是材料的纵向波速。\n\n3.  **有限元半离散化**：将连续域离散为有限元。这个过程将偏微分方程转化为一个关于时间的常微分方程组，称为半离散运动方程：\n    $$\n    \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\mathbf{u}(t) = \\mathbf{F}_{\\text{ext}}(t)\n    $$\n    在这里，$\\mathbf{u}(t)$ 是全局节点位移向量，$\\ddot{\\mathbf{u}}(t)$ 是节点加速度向量，$\\mathbf{M}$ 是全局质量矩阵，$\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{F}_{\\text{ext}}$ 是外部节点力向量，在本问题中为零。对于显式方法，使用集总（对角）质量矩阵 $\\mathbf{M}_L$ 是标准且计算上必需的，它可以解耦方程。对于一个长度为 $L_i$、横截面积为 $A_i$（常数）的一维线性杆单元 $i$，其单元刚度矩阵 $\\mathbf{k}_i$ 和集总质量矩阵 $\\mathbf{m}_{L,i}$ 为：\n    $$\n    \\mathbf{k}_i = \\frac{A_i E_i}{L_i} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad \\mathbf{m}_{L,i} = \\frac{\\rho_i A_i L_i}{2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}\n    $$\n\n4.  **中心差分时间积分**：显式中心差分格式使用步骤 $n-1$、$n$ 和 $n+1$ 的节点位移来近似步骤 $n$ 的加速度：\n    $$\n    \\ddot{\\mathbf{u}}^n \\approx \\frac{\\mathbf{u}^{n+1} - 2\\mathbf{u}^n + \\mathbf{u}^{n-1}}{(\\Delta t)^2}\n    $$\n    将此代入半离散方程 $\\mathbf{M}_L \\ddot{\\mathbf{u}}^n + \\mathbf{K} \\mathbf{u}^n = \\mathbf{0}$，得到位移向量的更新规则：\n    $$\n    \\mathbf{u}^{n+1} = 2\\mathbf{u}^n - \\mathbf{u}^{n-1} - (\\Delta t)^2 \\mathbf{M}_L^{-1} \\mathbf{K} \\mathbf{u}^n\n    $$\n\n5.  **稳定性分析**：中心差分格式的数值稳定性是条件性的。误差分析表明，如果时间步长 $\\Delta t$ 满足以下条件，该格式是稳定的：\n    $$\n    \\Delta t \\le \\frac{2}{\\omega_{\\max}}\n    $$\n    其中 $\\omega_{\\max}$ 是离散系统的最高固有频率，由矩阵束 $(\\mathbf{K}, \\mathbf{M}_L)$ 的最大特征值的平方根给出，即 $\\omega_{\\max}^2 = \\lambda_{\\max}(\\mathbf{M}_L^{-1} \\mathbf{K})$。\n\n6.  **单元层面稳定性边界**：对于一个运行时算法来说，计算全局最大特征值 $\\omega_{\\max}$ 的计算成本过高。一种标准的、保守的做法是通过网格中任意单个单元的最大频率来界定 $\\omega_{\\max}$，即 $\\omega_{\\max} \\le \\max_i (\\omega_{\\max}^{(i)})$。单个单元 $i$ 的最高频率 $\\omega_{\\max}^{(i)}$ 可以通过求解单元级特征值问题找到：$(\\mathbf{k}_i - (\\omega^{(i)})^2 \\mathbf{m}_{L,i})\\mathbf{v} = \\mathbf{0}$。最大的非零特征值给出：\n    $$\n    (\\omega_{\\max}^{(i)})^2 = \\frac{4 E_i}{\\rho_i L_i^2} \\implies \\omega_{\\max}^{(i)} = \\frac{2}{L_i} \\sqrt{\\frac{E_i}{\\rho_i}} = \\frac{2 c_i}{L_i}\n    $$\n    将稳定性条件应用于此单元频率，得到该单元的稳定性极限：\n    $$\n    \\Delta t_i \\le \\frac{2}{\\omega_{\\max}^{(i)}} = \\frac{2}{2c_i/L_i} = \\frac{L_i}{c_i}\n    $$\n    这就是单元 $i$ 的 CFL 条件：时间步长不得大于速度为 $c_i$ 的波传播整个单元长度 $L_i$ 所需的时间。\n\n7.  **自适应全局时间增量**：为使整个网格稳定，全局时间步长 $\\Delta t$ 必须小于所有单元稳定性极限的最小值。因此，在每一步 $n$，我们通过对所有当前激活单元的最小单元时间步长应用安全系数 $\\eta$ 来计算候选全局增量：\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( \\frac{L_i^n}{c_i^n} \\right)\n    $$\n    问题规定，长度 $L_i^n$、密度 $\\rho_i$ 和杨氏模量 $E_i^n$ 是单元特定的，并且可以演化。模量随标量损伤变量 $d_i^n$ 退化，其关系为 $E_i^n = (1-d_i^n)E_{0,i}$。因此，波速也与状态相关：$c_i^n = \\sqrt{E_i^n / \\rho_i}$。候选时间增量的最终表达式为：\n    $$\n    \\Delta t_{\\mathrm{cand}}^n = \\eta \\min_{i \\in \\text{active}} \\left( L_i^n \\sqrt{\\frac{\\rho_i}{(1-d_i^n)E_{0,i}}} \\right)\n    $$\n\n### 算法设计\n该运行时算法在一个模拟循环中实现了这个推导出的公式，该循环跟踪每个单元状态的演化以及激活单元的集合。\n\n1.  **初始化**：对于每个测试用例，为单元属性初始化 numpy 数组：初始长度 ($L_0$)、密度 ($\\rho$)、初始模量 ($E_0$)、每步应变增量 ($s$) 和每步损伤增量 ($g$)。为当前长度 $L$、损伤 $d$ 和模量 $E$ 初始化状态数组。使用一个布尔数组 `active_mask` 来跟踪哪些单元参与模拟。将模拟时间 $t=0$ 和步数计数器设为0。\n\n2.  **模拟循环**：只要当前时间 $t$ 小于预设的结束时间 $T_{\\mathrm{end}}$ 并且至少存在一个激活单元，模拟就继续进行。\n    a.  **计算候选增量**：在每个步骤开始时，为所有 `active_mask` 为真的单元计算单元稳定性极限 $L_i^n / c_i^n$。需要特别注意模量 $E_i^n$ 可能变为零（由于损伤 $d_i^n=1$）的单元；它们对最小值的贡献被视为无穷大，从而有效地将它们从时间步长极限的考虑中移除。找到这些值的最小值，并通过乘以安全系数 $\\eta=0.9$ 来计算候选全局增量 $\\Delta t_{\\mathrm{cand}}^n$。\n    b.  **收集统计数据**：记录计算出的 $\\Delta t_{\\mathrm{cand}}^n$，以便后续计算模拟过程中的初始值、最小值和最大值。\n    c.  **确定执行增量**：实际采用的时间步长 $\\Delta t_{\\mathrm{exec}}^n$ 是候选增量和到达 $T_{\\mathrm{end}}$ 的剩余时间中的较小者。\n    d.  **推进状态**：模拟时间 $t$ 增加 $\\Delta t_{\\mathrm{exec}}^n$，步数计数器加一。\n    e.  **更新单元属性**：所有单元的长度 $L_i$、损伤 $d_i$ 和模量 $E_i$ 根据给定的规则进行更新：$L_i^{n+1} = L_i^n(1+s_i)$ 和 $d_i^{n+1} = \\min(1, d_i^n + g_i)$。\n    f.  **单元侵蚀**：更新损伤后，检查每个单元是否达到其侵蚀阈值 $d_{\\mathrm{thr},i}$。如果一个单元的损伤达到或超过其阈值，其在 `active_mask` 中的相应条目将被设置为 `False`，从而将其从后续的时间步长计算中永久移除。\n\n3.  **终止和输出**：当 $t \\ge T_{\\mathrm{end}}$ 或 `active_mask` 中不包含任何 `True` 值时，循环终止。然后，将收集到的统计数据（$\\Delta t_{\\mathrm{cand}}^0$、$\\min_n \\Delta t_{\\mathrm{cand}}^n$、$\\max_n \\Delta t_{\\mathrm{cand}}^n$ 和总步数）格式化并为该测试用例返回。\n\n此过程确保模拟在适应单元属性和活动网格配置变化的同时保持数值稳定。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the adaptive time-stepping statistics based on the explicit central difference method\n    stability for a 1D bar with evolving properties and element erosion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no erosion)\n        {\n            \"N\": 4,\n            \"rho\": [7800, 7800, 7800, 7800],\n            \"E0\": [2.10e11, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.012, 0.009, 0.011],\n            \"s\": [0, 0, 0, 0],\n            \"g\": [0, 0, 0, 0],\n            \"d_thr\": [1, 1, 1, 1],\n            \"T_end\": 1.0e-4\n        },\n        # Case 2 (erosion increases the global time step mid-run)\n        {\n            \"N\": 5,\n            \"rho\": [2700, 2700, 7800, 7800, 7800],\n            \"E0\": [7.0e10, 7.0e10, 2.10e11, 2.10e11, 2.10e11],\n            \"L0\": [0.010, 0.006, 0.008, 0.005, 0.007],\n            \"s\": [0, 0, 0, 0, 0],\n            \"g\": [0.02, 0.05, 0, 0.03, 0],\n            \"d_thr\": [0.5, 0.5, 0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-4\n        },\n        # Case 3 (edge case, all elements erode almost immediately)\n        {\n            \"N\": 3,\n            \"rho\": [1000, 1000, 1000],\n            \"E0\": [3.0e9, 3.0e9, 3.0e9],\n            \"L0\": [0.004, 0.004, 0.004],\n            \"s\": [0, 0, 0],\n            \"g\": [0.5, 0.5, 0.5],\n            \"d_thr\": [0.5, 0.5, 0.5],\n            \"T_end\": 1.0e-3\n        }\n    ]\n\n    all_results = []\n    eta = 0.9\n\n    for case_data in test_cases:\n        N = case_data[\"N\"]\n        T_end = case_data[\"T_end\"]\n        \n        # Convert lists to numpy arrays for vectorized operations\n        rho = np.array(case_data[\"rho\"], dtype=float)\n        E0 = np.array(case_data[\"E0\"], dtype=float)\n        s = np.array(case_data[\"s\"], dtype=float)\n        g = np.array(case_data[\"g\"], dtype=float)\n        d_thr = np.array(case_data[\"d_thr\"], dtype=float)\n        \n        # Initialize state variables\n        L = np.array(case_data[\"L0\"], dtype=float)\n        d = np.zeros(N, dtype=float)\n        active_mask = np.ones(N, dtype=bool)\n\n        current_time = 0.0\n        step_count = 0\n        dt_cand_history = []\n        \n        # Main simulation loop\n        while current_time  T_end and np.any(active_mask):\n            \n            # --- Step n: Calculation before advancing time ---\n\n            # 1. Compute current modulus based on damage from previous step\n            E = (1.0 - d) * E0\n\n            # 2. Compute stability-based candidate increment\n            L_active = L[active_mask]\n            rho_active = rho[active_mask]\n            E_active = E[active_mask]\n\n            # To avoid division by zero when E=0 (d=1), treat the term as infinity.\n            # E_active > 0 is a safe check.\n            c_squared_active = np.full_like(E_active, np.inf)\n            valid_E_mask = E_active > 0\n            if np.any(valid_E_mask):\n                c_squared_active[valid_E_mask] = E_active[valid_E_mask] / rho_active[valid_E_mask]\n            \n            # Element-wise stability limits (L/c)\n            dt_elems = L_active / np.sqrt(c_squared_active)\n            \n            dt_cand = eta * np.min(dt_elems)\n            dt_cand_history.append(dt_cand)\n\n            # 3. Determine executed time increment and advance time\n            time_to_end = T_end - current_time\n            dt_exec = min(dt_cand, time_to_end)\n            \n            current_time += dt_exec\n            step_count += 1\n            \n            # --- Update state for Step n+1 ---\n\n            # 4. Update element properties\n            L *= (1.0 + s)\n            d = np.minimum(1.0, d + g)\n\n            # 5. Apply erosion for the next step\n            # Element is removed if its new damage exceeds the threshold\n            eroded_mask = d >= d_thr\n            active_mask[eroded_mask] = False\n\n        # Post-processing for this test case\n        if not dt_cand_history:\n            # Case where simulation does not run (e.g., T_end=0 or no elements)\n            dt_cand_0 = 0.0\n            min_dt_cand = 0.0\n            max_dt_cand = 0.0\n        else:\n            dt_cand_0 = dt_cand_history[0]\n            min_dt_cand = min(dt_cand_history)\n            max_dt_cand = max(dt_cand_history)\n\n        all_results.append([dt_cand_0, min_dt_cand, max_dt_cand, step_count])\n\n    # Final print statement in the exact required format.\n    # The str() function on a list correctly formats it as '[...]'\n    # The outer join then assembles the final list of lists appearance.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}