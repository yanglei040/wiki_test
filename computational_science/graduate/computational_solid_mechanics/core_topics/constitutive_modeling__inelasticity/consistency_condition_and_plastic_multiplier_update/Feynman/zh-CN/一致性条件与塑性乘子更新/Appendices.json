{
    "hands_on_practices": [
        {
            "introduction": "为了打下坚实的基础，我们的第一个练习从最简单的情况入手：一个具有线性硬化的单轴材料模型。在这个理想化的场景中，我们可以推导出塑性乘子增量的精确解析解。这个练习  让你能够直接实现返回映射算法的核心逻辑，并将你的数值代码与此解析基准进行验证，从而确保你从根本上正确理解一致性条件。",
            "id": "3550975",
            "problem": "设计并实现一个使用各向同性线性硬化模型的单轴小应变弹塑性返回映射验证。从基本定义和定律出发，推导塑性乘子增量的闭式更新，并用它来验证由一致性条件驱动的数值实现。您的实现必须是一个完整的程序，对于几个指定的加载步，计算解析推导的塑性乘子增量和从带有一致性条件的隐式返回映射中数值获得的值，并对它们进行比较。\n\n模型假设和定义：\n\n- 运动学和弹性：在一维小应变中，总应变增量表示为 $\\Delta \\varepsilon$，塑性应变表示为 $\\varepsilon^{p}$，柯西应力表示为 $\\sigma$。线性弹性给出 $\\sigma = E \\left( \\varepsilon - \\varepsilon^{p} \\right)$，其中 $E$ 是杨氏模量（单位为 $\\mathrm{Pa}$）。试探应力为 $\\sigma^{\\mathrm{tr}} = E \\left( \\varepsilon_{n} + \\Delta \\varepsilon - \\varepsilon^{p}_{n} \\right)$，其中下标 $n$ 表示上一步。\n- 带线性各向同性硬化的屈服函数：$f(\\sigma,\\alpha) = \\lvert \\sigma \\rvert - \\left( \\sigma_{y0} + H \\alpha \\right)$，其中 $\\sigma_{y0}$ 是初始屈服应力（单位为 $\\mathrm{Pa}$），$H$ 是硬化模量（单位为 $\\mathrm{Pa}$），$\\alpha$ 是累积塑性应变（无量纲），定义为 $\\dot{\\alpha} = \\lvert \\dot{\\varepsilon}^{p} \\rvert$。\n- 相关联流动和 Karush-Kuhn-Tucker (KKT) 条件：塑性流动是相关联的，$\\dot{\\varepsilon}^{p} = \\dot{\\lambda} \\, \\mathrm{sign}(\\sigma)$，其中塑性乘子率为 $\\dot{\\lambda} \\ge 0$。KKT 条件为 $\\dot{\\lambda} \\ge 0$，$f \\le 0$ 和 $\\dot{\\lambda} f = 0$。塑性加载的一致性条件强制要求 $f(\\sigma_{n+1},\\alpha_{n+1}) = 0$。\n- 时间离散化：在大小为 $\\Delta t$ 的单个步长上使用隐式（后向欧拉）更新（对于此单轴、率无关的步长，您可以设 $\\Delta t = 1$ 而不失一般性）。在该步长上，塑性应变增量为 $\\Delta \\varepsilon^{p} = \\Delta \\lambda \\, \\mathrm{sign}(\\sigma_{n+1})$，其中 $\\Delta \\lambda \\ge 0$，硬化变量增量为 $\\Delta \\alpha = \\Delta \\lambda$。\n\n任务：\n\n- 仅从上述定义出发，推导单个单轴步中塑性乘子增量 $\\Delta \\lambda$ 关于 $E$、$H$、$\\sigma_{y0}$、$\\alpha_{n}$ 和 $\\sigma^{\\mathrm{tr}}$ 的闭式表达式。除这些定义和 KKT/一致性框架外，不要假设任何结果。\n- 推导相应的更新应力 $\\sigma_{n+1}$、塑性应变 $\\varepsilon^{p}_{n+1}$ 和硬化变量 $\\alpha_{n+1}$（针对弹性和塑性情况），并根据试探状态描述弹/塑性切换条件。\n- 实现两种计算 $\\Delta \\lambda$ 的途径：\n  - 基于您的推导的闭式途径。\n  - 一种通过对 $\\Delta \\lambda$ 进行标量牛顿迭代来强制执行离散一致性条件 $f(\\sigma_{n+1},\\alpha_{n+1}) = 0$ 的数值途径。\n- 使用数值途径计算步末屈服函数值 $f_{n+1} = f(\\sigma_{n+1},\\alpha_{n+1})$ 并验证一致性条件。\n\n物理单位和输出量：\n\n- 使用国际单位制 (SI)。应力 $E$、$\\sigma$、$\\sigma_{y0}$ 和 $H$ 以 $\\mathrm{Pa}$ (帕斯卡) 为单位。应变 $\\varepsilon$、$\\varepsilon^{p}$、$\\alpha$ 和 $\\Delta \\lambda$ 是无量纲的。\n- 您的程序必须为每个测试用例计算：\n  - 闭式塑性乘子增量 $\\Delta \\lambda_{\\mathrm{cf}}$ (无量纲)。\n  - 数值获得的塑性乘子增量 $\\Delta \\lambda_{\\mathrm{num}}$ (无量纲)。\n  - 绝对差 $\\lvert \\Delta \\lambda_{\\mathrm{cf}} - \\Delta \\lambda_{\\mathrm{num}} \\rvert$ (无量纲)。\n  - 步末屈服函数值 $f_{n+1}$ (单位为 $\\mathrm{Pa}$)。\n\n测试套件：\n\n为以下五个案例提供结果，这些案例旨在覆盖弹性、边界、塑性、硬化历史和压缩情况。在所有情况下，均取前一步的总应变为 $\\varepsilon_{n} = 0$。\n\n- 案例 A (严格弹性)：$E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$，$H = 0\\ \\mathrm{Pa}$，$\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$，$\\varepsilon^{p}_{n} = 0$，$\\alpha_{n} = 0$，$\\Delta \\varepsilon = 1.0 \\times 10^{-4}$。\n- 案例 B (恰好在屈服点)：$E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$，$H = 0\\ \\mathrm{Pa}$，$\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$，$\\varepsilon^{p}_{n} = 0$，$\\alpha_{n} = 0$，$\\Delta \\varepsilon = 1.1904761904761905 \\times 10^{-3}$。\n- 案例 C (屈服后的理想塑性)：$E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$，$H = 0\\ \\mathrm{Pa}$，$\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$，$\\varepsilon^{p}_{n} = 0$，$\\alpha_{n} = 0$，$\\Delta \\varepsilon = 3.0 \\times 10^{-3}$。\n- 案例 D (带先前历史的各向同性硬化)：$E = 2.00 \\times 10^{11}\\ \\mathrm{Pa}$，$H = 1.00 \\times 10^{9}\\ \\mathrm{Pa}$，$\\sigma_{y0} = 3.00 \\times 10^{8}\\ \\mathrm{Pa}$，$\\varepsilon^{p}_{n} = 4.0 \\times 10^{-4}$，$\\alpha_{n} = 6.0 \\times 10^{-4}$，$\\Delta \\varepsilon = 2.0 \\times 10^{-3}$。\n- 案例 E (带硬化的压缩塑性)：$E = 2.10 \\times 10^{11}\\ \\mathrm{Pa}$，$H = 2.00 \\times 10^{9}\\ \\mathrm{Pa}$，$\\sigma_{y0} = 2.50 \\times 10^{8}\\ \\mathrm{Pa}$，$\\varepsilon^{p}_{n} = -2.0 \\times 10^{-4}$，$\\alpha_{n} = 2.0 \\times 10^{-4}$，$\\Delta \\varepsilon = -2.0 \\times 10^{-3}$。\n\n数值实现要求：\n\n- 对数值途径使用标量牛顿法，最大迭代次数例如为 $k_{\\max} = 5$，一致性函数残差的容差为 $\\tau = 10^{-12}$。使用 $\\Delta \\lambda^{(0)} = 0$ 初始化牛顿迭代。\n- 对于弹性情况，您应检测到不需要塑性修正，并设置 $\\Delta \\lambda_{\\mathrm{cf}} = \\Delta \\lambda_{\\mathrm{num}} = 0$。\n- 在所有情况下，确保使用更新后的应力和硬化变量计算步末屈服函数 $f_{n+1}$，并以 $\\mathrm{Pa}$ 为单位报告其值。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含所有案例的结果，格式为方括号内以逗号分隔的列表。每个元素应为一个包含四个条目的列表，顺序为 $[\\Delta \\lambda_{\\mathrm{cf}}, \\Delta \\lambda_{\\mathrm{num}}, \\lvert \\Delta \\lambda_{\\mathrm{cf}} - \\Delta \\lambda_{\\mathrm{num}} \\rvert, f_{n+1}]$。例如，一个语法正确的输出看起来像 $[[a,b,c,d],[e,f,g,h],\\ldots]$，其中每个符号都被一个浮点数替换。",
            "solution": "该问题要求推导和实现一个用于带线性各向同性硬化的单轴小应变弹塑性模型的返回映射算法。这涉及到推导塑性乘子增量 $\\Delta\\lambda$ 的闭式表达式，并与通过牛顿-拉夫逊方案强制执行一致性条件的数值解进行验证。\n\n首先，我们建立适用于从时间 $n$ 到 $n+1$ 的单个加载步的时间离散形式的控制方程。该模型是率无关的，因此步长无关紧要。我们使用隐式后向欧拉积分方案。\n\n第 $n$ 步的状态是已知的：总应变 $\\varepsilon_n$、塑性应变 $\\varepsilon^p_n$ 和累积塑性应变 $\\alpha_n$。施加一个总应变增量 $\\Delta\\varepsilon$。目标是找到 $n+1$ 时的状态：$\\sigma_{n+1}$、$\\varepsilon^p_{n+1}$ 和 $\\alpha_{n+1}$。\n\n离散控制方程如下：\n1.  第 $n+1$ 步的总应变：$\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon$。\n2.  弹性本构律：$\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^p_{n+1})$，其中 $E$ 是杨氏模量。\n3.  塑性应变更新（流动法则）：$\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\varepsilon^p = \\varepsilon^p_n + \\Delta\\lambda \\, \\mathrm{sign}(\\sigma_{n+1})$。这里，$\\Delta\\lambda \\ge 0$ 是塑性乘子增量。\n4.  硬化变量更新：$\\alpha_{n+1} = \\alpha_n + \\Delta\\alpha$。从 $\\dot{\\alpha} = |\\dot{\\varepsilon}^p|$ 和 $\\dot{\\varepsilon}^p = \\dot{\\lambda} \\, \\mathrm{sign}(\\sigma)$，我们得到 $\\dot{\\alpha} = \\dot{\\lambda} |\\mathrm{sign}(\\sigma)| = \\dot{\\lambda}$（对于 $\\sigma \\ne 0$）。离散更新为 $\\Delta\\alpha = \\Delta\\lambda$。因此，$\\alpha_{n+1} = \\alpha_n + \\Delta\\lambda$。\n5.  屈服条件：状态必须满足 $f(\\sigma_{n+1}, \\alpha_{n+1}) \\le 0$，其中屈服函数为 $f(\\sigma, \\alpha) = |\\sigma| - \\sigma_y(\\alpha)$，屈服应力为 $\\sigma_y(\\alpha) = \\sigma_{y0} + H\\alpha$。$H$ 是硬化模量，$\\sigma_{y0}$ 是初始屈服应力。\n6.  离散形式的 Karush-Kuhn-Tucker (KKT) 条件：$\\Delta\\lambda \\ge 0$，$f_{n+1} \\le 0$，以及互补条件 $\\Delta\\lambda f_{n+1} = 0$。这意味着如果发生塑性流动（$\\Delta\\lambda > 0$），最终状态必须位于屈服面上，即 $f_{n+1}=0$。这是一致性条件。\n\n求解该系统的标准程序是弹性预测、塑性修正算法。\n\n**1. 弹性预测**\n\n首先，我们假设该步是纯弹性的，即 $\\Delta\\lambda = 0$。这会产生一个“试探”状态。\n-   塑性应变保持不变：$\\varepsilon^{p, \\mathrm{tr}} = \\varepsilon^p_n$。\n-   硬化变量保持不变：$\\alpha^{\\mathrm{tr}} = \\alpha_n$。\n-   试探应力由弹性定律计算得出：\n    $$ \\sigma^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{p, \\mathrm{tr}}) = E(\\varepsilon_n + \\Delta\\varepsilon - \\varepsilon^p_n) $$\n-   然后我们通过评估屈服函数来检查此试探状态是否可接受：\n    $$ f^{\\mathrm{tr}} = f(\\sigma^{\\mathrm{tr}}, \\alpha_n) = |\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n) $$\n\n**2. 弹/塑性加载条件**\n\n$f^{\\mathrm{tr}}$ 的值决定了该步的性质：\n-   如果 $f^{\\mathrm{tr}} \\le 0$，则试探状态有效，位于弹性域内部或其上。弹性行为的假设是正确的。该步是弹性的（如果 $f^{\\mathrm{tr}}=0$，则为中性加载）。最终状态即为试探状态：\n    $$ \\Delta\\lambda = 0 $$\n    $$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} $$\n    $$ \\varepsilon^p_{n+1} = \\varepsilon^p_n $$\n    $$ \\alpha_{n+1} = \\alpha_n $$\n-   如果 $f^{\\mathrm{tr}} > 0$，则试探状态在弹性域之外，这在物理上是不可接受的。弹性行为的假设是错误的，必须发生塑性变形。我们进入塑性修正步骤以强制执行一致性条件。\n\n**3. 塑性修正（返回映射）**\n\n对于塑性步（$f^{\\mathrm{tr}} > 0$），我们必须找到一个 $\\Delta\\lambda > 0$，使得最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 满足一致性条件 $f_{n+1}=0$。\n\n更新后的应力 $\\sigma_{n+1}$ 可以与试探应力 $\\sigma^{\\mathrm{tr}}$ 相关联：\n$$ \\sigma_{n+1} = E(\\varepsilon_{n+1} - \\varepsilon^p_{n+1}) = E(\\varepsilon_{n+1} - (\\varepsilon^p_n + \\Delta\\varepsilon^p)) = E(\\varepsilon_{n+1} - \\varepsilon^p_n) - E\\Delta\\varepsilon^p $$\n将第一项识别为试探应力，我们得到：\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\varepsilon^p $$\n代入流动法则 $\\Delta\\varepsilon^p = \\Delta\\lambda\\,\\mathrm{sign}(\\sigma_{n+1})$：\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma_{n+1}) $$\n对于这种单轴返回映射，应力修正发生在与最终应力相反的方向上，而最终应力与试探应力位于原点的同一侧。因此，我们可以断言 $\\mathrm{sign}(\\sigma_{n+1}) = \\mathrm{sign}(\\sigma^{\\mathrm{tr}})$。这简化了应力更新为：\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\n更新后的硬化变量为：\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\lambda $$\n现在，我们施加一致性条件 $f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$：\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1}) = 0 $$\n代入 $\\sigma_{n+1}$ 和 $\\alpha_{n+1}$ 的表达式：\n$$ |\\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}})| - (\\sigma_{y0} + H(\\alpha_n + \\Delta\\lambda)) = 0 $$\n由于返回路径将应力的大小从 $|\\sigma^{\\mathrm{tr}}|$ 减小到 $|\\sigma_{n+1}|$，绝对值内的项与 $\\sigma^{\\mathrm{tr}}$ 具有相同的符号。因此，$|\\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}})| = |\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda$。方程变为：\n$$ (|\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda) - (\\sigma_{y0} + H\\alpha_n + H\\Delta\\lambda) = 0 $$\n我们可以组合各项来求解 $\\Delta\\lambda$：\n$$ (|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)) - (E + H)\\Delta\\lambda = 0 $$\n第一个括号中的项正是试探屈服函数 $f^{\\mathrm{tr}}$。\n$$ f^{\\mathrm{tr}} - (E + H)\\Delta\\lambda = 0 $$\n这给出了塑性乘子增量的闭式表达式：\n$$ \\Delta\\lambda_{\\mathrm{cf}} = \\frac{f^{\\mathrm{tr}}}{E + H} $$\n由于 $f^{\\mathrm{tr}} > 0$，$E > 0$ 且 $H \\ge 0$，因此 $\\Delta\\lambda > 0$，这与塑性加载一致。\n\n塑性步的最终更新状态变量为：\n$$ \\Delta\\lambda = \\frac{|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)}{E+H} $$\n$$ \\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\lambda $$\n$$ \\sigma_{n+1} = \\sigma^{\\mathrm{tr}} - E\\Delta\\lambda\\,\\mathrm{sign}(\\sigma^{\\mathrm{tr}}) $$\n\n**4. 通过牛顿法进行数值求解**\n\n为验证此结果，我们通过寻找一致性方程的根来数值求解 $\\Delta\\lambda$。我们定义一个残差函数 $R(\\Delta\\lambda)$，它表示给定 $\\Delta\\lambda$ 时屈服函数的值：\n$$ R(\\Delta\\lambda) = |\\sigma^{\\mathrm{tr}}| - E\\Delta\\lambda - (\\sigma_{y0} + H\\alpha_n + H\\Delta\\lambda) $$\n简化得：\n$$ R(\\Delta\\lambda) = (|\\sigma^{\\mathrm{tr}}| - (\\sigma_{y0} + H\\alpha_n)) - (E + H)\\Delta\\lambda = f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda $$\n寻找 $R(\\Delta\\lambda)=0$ 的根的牛顿-拉夫逊迭代法是：\n$$ \\Delta\\lambda^{(k+1)} = \\Delta\\lambda^{(k)} - \\frac{R(\\Delta\\lambda^{(k)})}{R'(\\Delta\\lambda^{(k)})} $$\n其中 $R'(\\Delta\\lambda)$ 是残差关于 $\\Delta\\lambda$ 的导数：\n$$ R'(\\Delta\\lambda) = \\frac{d}{d(\\Delta\\lambda)} \\left[ f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda \\right] = -(E+H) $$\n导数是常数。更新规则变为：\n$$ \\Delta\\lambda^{(k+1)} = \\Delta\\lambda^{(k)} - \\frac{f^{\\mathrm{tr}} - (E+H)\\Delta\\lambda^{(k)}}{-(E+H)} = \\Delta\\lambda^{(k)} + \\frac{f^{\\mathrm{tr}}}{E+H} - \\Delta\\lambda^{(k)} = \\frac{f^{\\mathrm{tr}}}{E+H} $$\n这表明对于线性硬化模型，无论初始猜测如何，牛顿-拉夫逊方法在单次迭代中收敛到精确的解析解。我们的数值实现，从 $\\Delta\\lambda^{(0)}=0$ 开始并按照问题描述进行迭代，应产生与闭式解相同的结果，直到机器精度。\n\n**5. 验证和最终状态计算**\n\n对于弹性和塑性情况，在确定 $\\Delta\\lambda$ 后，我们计算最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 并评估最终屈服函数值 $f_{n+1} = |\\sigma_{n+1}| - (\\sigma_{y0} + H\\alpha_{n+1})$。对于弹性步，$f_{n+1}$ 将小于或等于 $0$。对于塑性步，$f_{n+1}$ 在数值上应为零，从而验证达到了一致性。程序将比较闭式解 $\\Delta\\lambda_{\\mathrm{cf}}$ 与数值计算的 $\\Delta\\lambda_{\\mathrm{num}}$，并报告它们的绝对差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite for the uniaxial elastoplastic model.\n    \"\"\"\n\n    def compute_update(E, H, sig_y0, eps_p_n, alpha_n, delta_eps):\n        \"\"\"\n        Computes the state update for a single load step using both closed-form and numerical methods.\n\n        Args:\n            E (float): Young's modulus (Pa)\n            H (float): Hardening modulus (Pa)\n            sig_y0 (float): Initial yield stress (Pa)\n            eps_p_n (float): Plastic strain at step n\n            alpha_n (float): Hardening variable at step n\n            delta_eps (float): Total strain increment\n\n        Returns:\n            tuple: A tuple containing (delta_lambda_cf, delta_lambda_num, diff, f_n1)\n                   - delta_lambda_cf (float): Closed-form plastic multiplier increment.\n                   - delta_lambda_num (float): Numerical plastic multiplier increment.\n                   - diff (float): Absolute difference between cf and num values.\n                   - f_n1 (float): Yield function value at the end of the step (Pa).\n        \"\"\"\n        # Problem states all cases have eps_n = 0\n        eps_n = 0.0\n\n        # Step 1: Elastic Predictor\n        # Trial stress\n        sigma_tr = E * (eps_n + delta_eps - eps_p_n)\n        \n        # Current yield stress\n        sigma_y_n = sig_y0 + H * alpha_n\n        \n        # Trial yield function\n        f_tr = np.abs(sigma_tr) - sigma_y_n\n        \n        # Step 2: Elastic/Plastic Check\n        if f_tr = 0:\n            # Elastic step\n            delta_lambda_cf = 0.0\n            delta_lambda_num = 0.0\n            sigma_n1 = sigma_tr\n            alpha_n1 = alpha_n\n        else:\n            # Plastic step\n\n            # --- Closed-form route ---\n            delta_lambda_cf = f_tr / (E + H)\n\n            # --- Numerical route (Newton's method) ---\n            k_max = 5\n            tolerance = 1e-12\n            delta_lambda_k = 0.0  # Initial guess as per problem statement\n\n            for _ in range(k_max):\n                # Calculate residual R(delta_lambda)\n                residual = f_tr - (E + H) * delta_lambda_k\n                \n                if np.abs(residual) = tolerance:\n                    break\n                \n                # Calculate Jacobian (derivative of R)\n                jacobian = -(E + H)\n                \n                # Newton update\n                delta_lambda_k -= residual / jacobian\n            \n            delta_lambda_num = delta_lambda_k\n            \n            # --- Calculate final state using the numerical result for verification ---\n            sign_sigma_tr = np.sign(sigma_tr)\n            sigma_n1 = sigma_tr - E * delta_lambda_num * sign_sigma_tr\n            alpha_n1 = alpha_n + delta_lambda_num\n\n        # Step 5: Verification\n        # Calculate final yield function value\n        f_n1 = np.abs(sigma_n1) - (sig_y0 + H * alpha_n1)\n\n        # Calculate absolute difference between analytical and numerical solutions\n        diff = np.abs(delta_lambda_cf - delta_lambda_num)\n        \n        return delta_lambda_cf, delta_lambda_num, diff, f_n1\n\n\n    test_cases = [\n        # Case A: strictly elastic\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 1.0e-4},\n        # Case B: exactly at yield\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 1.1904761904761905e-3},\n        # Case C: perfect plasticity beyond yield\n        {'E': 2.10e11, 'H': 0.0, 'sig_y0': 2.50e8, 'eps_p_n': 0.0, 'alpha_n': 0.0, 'delta_eps': 3.0e-3},\n        # Case D: isotropic hardening with prior history\n        {'E': 2.00e11, 'H': 1.00e9, 'sig_y0': 3.00e8, 'eps_p_n': 4.0e-4, 'alpha_n': 6.0e-4, 'delta_eps': 2.0e-3},\n        # Case E: compressive plasticity with hardening\n        {'E': 2.10e11, 'H': 2.00e9, 'sig_y0': 2.50e8, 'eps_p_n': -2.0e-4, 'alpha_n': 2.0e-4, 'delta_eps': -2.0e-3}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_update(**case)\n        # Format numbers to be easily representable\n        formatted_result = [f\"{x:.8e}\" for x in result]\n        results.append(str(formatted_result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界中的工程材料通常表现出复杂的行为，无法用简单的线性硬化来描述。下一个练习  将我们带入更贴近实际的J2塑性模型，该模型采用了非线性的组合硬化律。你将推导并实现一个牛顿-拉弗森（Newton-Raphson）迭代方案来求解标量一致性方程，从而获得处理计算塑性力学中核心的非线性问题的实践经验。",
            "id": "3550995",
            "problem": "考虑由偏应力第二不变量（J2）和线性弹性控制的小应变、各向同性、关联塑性。令 $G$ 表示剪切模量，$s$ 表示偏应力，von Mises 等效应力定义为 $\\sigma_{\\mathrm{eq}} = \\sqrt{\\frac{3}{2}} \\, \\lVert s \\rVert$。弹性预测步返回试探偏应力 $s^{\\mathrm{tr}}$ 和相应的试探等效应力 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$。对于关联流动法则，塑性应变增量为 $ \\Delta \\varepsilon^{p} = \\Delta \\lambda \\, \\frac{\\partial \\Phi}{\\partial \\sigma}$，其中屈服函数为 $\\Phi(\\sigma, \\kappa) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(\\kappa)$，$\\kappa$ 是累积（等效）塑性应变，$\\sigma_{y}$ 是当前屈服应力。\n\n在 J2 塑性的标准径向返回映射假设下，塑性修正保持偏应力的方向不变，其大小更新为\n$$\n\\sigma_{\\mathrm{eq}}^{n+1} = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda,\n$$\n内变量更新为\n$$\n\\kappa_{n+1} = \\kappa_{n} + \\Delta \\lambda.\n$$\n假设为 Voce 加线性组合类型的各向同性硬化，\n$$\n\\sigma_{y}(\\kappa) = \\sigma_{y0} + H \\, \\kappa + Q \\left( 1 - e^{-b \\kappa} \\right),\n$$\n其中 $\\sigma_{y0}$ 是初始屈服应力，$H$ 是线性硬化模量，$Q$ 和 $b$ 是 Voce 参数，$\\kappa$ 是累积塑性应变。\n\n当发生塑性加载时，一致性条件强制要求 $\\Phi(\\sigma_{n+1}, \\kappa_{n+1}) = 0$，这导出了关于塑性乘子增量 $\\Delta \\lambda$ 的标量非线性方程：\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}\\left( \\kappa_{n} + \\Delta \\lambda \\right) = 0,\n$$\n需满足加载/卸载条件：如果 $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_{y}(\\kappa_{n}) \\le 0$，则 $\\Delta \\lambda = 0$（弹性步）。否则，$\\Delta \\lambda  0$ 是上述方程的解。\n\n任务：从第一性原理推导求解标量方程 $r(\\Delta \\lambda) = 0$ 以获得 $\\Delta \\lambda$ 的 Newton-Raphson (NR) 迭代格式，包括用材料参数和状态变量表示的导数 $\\frac{dr}{d(\\Delta \\lambda)}$ 的显式表达式，并实现一个稳健的算法，该算法能够\n- 检测弹性步（如果 $r(0) \\le 0$，则 $\\Delta \\lambda = 0$），\n- 否则，使用限定在物理合理区间内的安全保护 Newton-Raphson 方法求解非线性方程，\n- 为每个测试用例返回收敛的 $\\Delta \\lambda$。\n\n所有应力单位必须为帕斯卡（$\\mathrm{Pa}$）。应变类量 $\\Delta \\lambda$ 和 $\\kappa$ 是无量纲的。本问题不涉及角度。您的最终程序必须计算并输出以下测试组中每个测试用例的 $\\Delta \\lambda$，每个测试用例以 $(G, \\sigma_{y0}, H, Q, b, \\kappa_{n}, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}})$ 的形式提供：\n\n- 测试 $1$（一般非线性硬化，“理想情况”）：$(80 \\times 10^{9}, 250 \\times 10^{6}, 1.0 \\times 10^{9}, 450 \\times 10^{6}, 20, 0.02, 800 \\times 10^{6})$。\n- 测试 $2$（弹性步边界）：$(80 \\times 10^{9}, 250 \\times 10^{6}, 1.0 \\times 10^{9}, 450 \\times 10^{6}, 20, 0.05, 500 \\times 10^{6})$。\n- 测试 $3$（纯线性硬化）：$(80 \\times 10^{9}, 250 \\times 10^{6}, 1.5 \\times 10^{9}, 0, 10, 0.0, 600 \\times 10^{6})$。\n- 测试 $4$（由大 $b$ 引起的强初始非线性）：$(80 \\times 10^{9}, 200 \\times 10^{6}, 0.5 \\times 10^{9}, 300 \\times 10^{6}, 200, 0.005, 700 \\times 10^{6})$。\n- 测试 $5$（较低的剪切模量）：$(30 \\times 10^{9}, 150 \\times 10^{6}, 0, 350 \\times 10^{6}, 5, 0.0, 400 \\times 10^{6})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\Delta\\lambda_{1},\\Delta\\lambda_{2},\\Delta\\lambda_{3},\\Delta\\lambda_{4},\\Delta\\lambda_{5}]$）。每个条目必须是一个表示相应测试用例计算出的 $\\Delta \\lambda$ 的十进制（浮点）数，单位为无量纲。",
            "solution": "该问题是有效的，因为它科学地基于计算塑性力学的原理，是适定的、客观的，并包含了唯一解所需的所有必要信息。\n\n问题的核心是求解塑性乘子增量 $\\Delta \\lambda$ 的标量非线性一致性方程，该方程出现在具有组合各向同性硬化的 J2 塑性的返回映射算法中。待求解的方程是 $r(\\Delta \\lambda) = 0$，其中残差函数 $r(\\Delta \\lambda)$ 由下式给出：\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}\\left( \\kappa_{n} + \\Delta \\lambda \\right)\n$$\n该方程必须在 Karush-Kuhn-Tucker (KKT) 条件下求解：$\\Delta \\lambda \\ge 0$，$r(\\Delta \\lambda) \\le 0$ 当 $\\Delta\\lambda=0$ 时，而 $r(\\Delta \\lambda) \\Delta\\lambda = 0$ 在此并未被用作公式，而是使用了一个更简单的形式，即 $\\Phi \\le 0$、$\\Delta\\lambda \\ge 0$ 以及 $\\Phi \\Delta\\lambda = 0$。给定的加载/卸载条件是该条件的一种实际实现：如果 $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\kappa_n) \\le 0$，则状态为弹性或中性加载，因此 $\\Delta \\lambda = 0$。否则，发生塑性加载，$\\Delta \\lambda  0$，并且必须强制执行一致性条件 $r(\\Delta \\lambda) = 0$。\n\n硬化定律被指定为 Voce 加线性组合模型：\n$$\n\\sigma_{y}(\\kappa) = \\sigma_{y0} + H \\, \\kappa + Q \\left( 1 - e^{-b \\kappa} \\right)\n$$\n其中 $\\kappa_n$ 是前一个收敛时间步的累积塑性应变。更新后的累积塑性应变为 $\\kappa_{n+1} = \\kappa_{n} + \\Delta \\lambda$。将其代入残差函数可得显式形式：\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\left[ \\sigma_{y0} + H(\\kappa_{n} + \\Delta \\lambda) + Q \\left( 1 - e^{-b(\\kappa_{n} + \\Delta \\lambda)} \\right) \\right]\n$$\n\n为了求解 $r(\\Delta \\lambda) = 0$ 以得到 $\\Delta \\lambda  0$，我们采用 Newton-Raphson (NR) 方法。迭代更新格式为：\n$$\n\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - \\frac{r(\\Delta \\lambda_k)}{r'(\\Delta \\lambda_k)}\n$$\n其中 $\\Delta \\lambda_k$ 是第 k 次迭代的估计值，而 $r'(\\Delta \\lambda_k) = \\frac{dr}{d(\\Delta \\lambda)}\\big|_{\\Delta \\lambda = \\Delta \\lambda_k}$。\n\n我们必须首先计算残差函数关于 $\\Delta \\lambda$ 的导数。对 $r(\\Delta \\lambda)$ 逐项求导：\n$$\n\\frac{dr}{d(\\Delta \\lambda)} = \\frac{d}{d(\\Delta \\lambda)} \\left( \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} \\right) - \\frac{d}{d(\\Delta \\lambda)} \\left( 3 G \\, \\Delta \\lambda \\right) - \\frac{d}{d(\\Delta \\lambda)} \\left( \\sigma_{y}(\\kappa_n + \\Delta \\lambda) \\right)\n$$\n第一项是常数，其导数为 0。第二项的导数为 $-3G$。对于第三项，我们使用链式法则：\n$$\n\\frac{d}{d(\\Delta \\lambda)} \\sigma_{y}(\\kappa_n + \\Delta \\lambda) = \\frac{d\\sigma_y}{d\\kappa}\\bigg|_{\\kappa = \\kappa_n + \\Delta \\lambda} \\cdot \\frac{d(\\kappa_n + \\Delta \\lambda)}{d(\\Delta \\lambda)} = \\frac{d\\sigma_y}{d\\kappa}\\bigg|_{\\kappa = \\kappa_n + \\Delta \\lambda} \\cdot 1\n$$\n屈服应力函数 $\\sigma_y(\\kappa)$ 的导数是切向硬化模量 $H_{\\mathrm{tan}}(\\kappa)$：\n$$\nH_{\\mathrm{tan}}(\\kappa) = \\frac{d\\sigma_y}{d\\kappa} = \\frac{d}{d\\kappa} \\left( \\sigma_{y0} + H \\kappa + Q (1 - e^{-b \\kappa}) \\right) = H + Q(-e^{-b\\kappa})(-b) = H + Q b e^{-b\\kappa}\n$$\n因此，残差的导数为：\n$$\nr'(\\Delta \\lambda) = -3G - \\left( H + Q b \\, e^{-b(\\kappa_n + \\Delta \\lambda)} \\right) = -\\left( 3G + H_{\\mathrm{tan}}(\\kappa_n + \\Delta \\lambda) \\right)\n$$\n对于物理上真实的材料，$G  0$，$H \\ge 0$，$Q \\ge 0$ 和 $b  0$，这确保了 $r'(\\Delta \\lambda)$ 恒为负。这意味着 $r(\\Delta \\lambda)$ 是一个单调递减函数，保证了当 $r(0)  0$ 时，对于 $\\Delta \\lambda  0$ 存在唯一根。\n\n$\\Delta \\lambda$ 的完整 Newton-Raphson 更新公式为：\n$$\n\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\frac{ \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\Delta \\lambda_k - \\sigma_{y}(\\kappa_n + \\Delta \\lambda_k) }{ 3G + H + Q b \\, e^{-b(\\kappa_n + \\Delta \\lambda_k)} }\n$$\n\n一个稳健的算法实现如下：\n1.  **弹性-塑性检验**：首先，计算初始残差 $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(\\kappa_n)$。如果 $r(0) \\le 0$，则该步为弹性步，解为 $\\Delta \\lambda = 0$。\n2.  **区间限定**：如果 $r(0)  0$（塑性步），则必须找到一个根。由于 $r(\\Delta \\lambda)$ 是单调的，我们可以稳健地为根确定区间。下界是 $\\lambda_a = 0$，此时 $r(\\lambda_a)  0$。可以通过考虑从试探应力开始的理想塑性情况来建立上界 $\\lambda_b$，这给出 $3G\\Delta\\lambda \\approx \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$。一个保证 $r(\\lambda_b)  0$ 的安全上界是 $\\lambda_b = \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}{3G}$，因为此时 $r(\\lambda_b) = -\\sigma_y(\\kappa_n+\\lambda_b)$，对于正的屈服应力，该值恒为负。因此，解被限定在 $[0, \\frac{\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}}{3G}]$ 区间内。\n3.  **安全保护迭代**：NR 迭代从一个初始猜测开始，例如 $\\Delta \\lambda_0 = 0$。\n    - 在每次迭代 $k$ 中，使用 NR 公式计算新的估计值 $\\Delta \\lambda_{k+1}$。\n    - 为确保稳健性，采用安全保护措施。如果 NR 更新值 $\\Delta \\lambda_{k+1}$ 超出当前区间 $[\\lambda_a, \\lambda_b]$，则拒绝该更新，并采取更保守的二分法步长，$\\Delta \\lambda_{k+1} = (\\lambda_a + \\lambda_b)/2$。\n    - 每步之后，根据 $r(\\Delta \\lambda_{k+1})$ 的符号更新区间。如果 $r(\\Delta \\lambda_{k+1})  0$，则更新下界：$\\lambda_a = \\Delta \\lambda_{k+1}$。否则，更新上界：$\\lambda_b = \\Delta \\lambda_{k+1}$。\n4.  **收敛**：迭代持续进行，直到残差的绝对值 $\\lvert r(\\Delta \\lambda_k) \\rvert$ 小于规定的容差（例如 $1.0 \\, \\mathrm{Pa}$），或达到最大迭代次数。\n这种将快速收敛的局部方法（NR）与全局收敛但较慢的方法（二分法）相结合，为求解一致性条件提供了一种稳健而高效的算法。",
            "answer": "```python\nimport numpy as np\n\ndef compute_delta_lambda(G, sigma_y0, H, Q, b, kappa_n, sigma_eq_tr):\n    \"\"\"\n    Computes the plastic multiplier increment Delta_lambda for J2 plasticity\n    with combined isotropic hardening using a safeguarded Newton-Raphson method.\n\n    Args:\n        G (float): Shear modulus (Pa).\n        sigma_y0 (float): Initial yield stress (Pa).\n        H (float): Linear hardening modulus (Pa).\n        Q (float): Voce hardening saturation stress (Pa).\n        b (float): Voce hardening exponent (dimensionless).\n        kappa_n (float): Accumulated plastic strain at step n (dimensionless).\n        sigma_eq_tr (float): Trial equivalent stress (Pa).\n\n    Returns:\n        float: The converged plastic multiplier increment Delta_lambda.\n    \"\"\"\n\n    # For better numerical stability with small arguments, use expm1.\n    # sigma_y = sigma_y0 + H*k + Q*(1 - exp(-b*k)) = sigma_y0 + H*k - Q*(exp(-b*k) - 1)\n    # The term is -Q*expm1(-b*k).\n    def get_sigma_y(kappa):\n        if b > 0 and kappa > 0:\n            return sigma_y0 + H * kappa - Q * np.expm1(-b * kappa)\n        else: # Handles b=0 or kappa=0 case without precision loss\n            return sigma_y0 + H * kappa\n\n    def get_residual(delta_lambda):\n        kappa_np1 = kappa_n + delta_lambda\n        sigma_y_np1 = get_sigma_y(kappa_np1)\n        return sigma_eq_tr - 3.0 * G * delta_lambda - sigma_y_np1\n\n    def get_residual_derivative(delta_lambda):\n        kappa_np1 = kappa_n + delta_lambda\n        # Tangent hardening modulus d(sigma_y)/d(kappa)\n        d_sigma_y_d_kappa = H + Q * b * np.exp(-b * kappa_np1)\n        return -3.0 * G - d_sigma_y_d_kappa\n\n    # Step 1: Elastic-Plastic Check\n    residual_at_zero = get_residual(0.0)\n\n    if residual_at_zero = 1e-9: # Add small tolerance for floating point comparisons\n        return 0.0\n\n    # Step 2: Setup for Newton-Raphson (Plastic Step)\n    delta_lambda = 0.0  # Initial guess\n\n    # Define a robust bracket for the safeguarded method\n    lambda_min = 0.0\n    lambda_max = sigma_eq_tr / (3.0 * G)\n\n    TOL = 1.0  # Absolute tolerance on the residual in Pascals\n    MAX_ITER = 50\n\n    for _ in range(MAX_ITER):\n        res = get_residual(delta_lambda)\n\n        if abs(res) = TOL:\n            break\n\n        deriv = get_residual_derivative(delta_lambda)\n        if deriv == 0:\n            # Algorithm should not get here with physical parameters\n            # Fallback to bisection\n            delta_lambda = (lambda_min + lambda_max) / 2.0\n            continue\n        \n        # Step 3: Compute Newton-Raphson update\n        update = -res / deriv\n        delta_lambda_next = delta_lambda + update\n\n        # Step 4: Safeguard - fall back to bisection if NR step is out of bounds\n        if not (lambda_min = delta_lambda_next = lambda_max):\n            delta_lambda_next = (lambda_min + lambda_max) / 2.0\n            \n        delta_lambda = delta_lambda_next\n\n        # Step 5: Update the bracket for the next iteration\n        if get_residual(delta_lambda) > 0:\n            lambda_min = delta_lambda\n        else:\n            lambda_max = delta_lambda\n            \n    return delta_lambda\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (G, sigma_y0, H, Q, b, kappa_n, sigma_eq_tr)\n    test_cases = [\n        (80e9, 250e6, 1.0e9, 450e6, 20, 0.02, 800e6), # General nonlinear hardening\n        (80e9, 250e6, 1.0e9, 450e6, 20, 0.05, 500e6), # Elastic step boundary\n        (80e9, 250e6, 1.5e9, 0, 10, 0.0, 600e6),      # Pure linear hardening\n        (80e9, 200e6, 0.5e9, 300e6, 200, 0.005, 700e6),# Strong initial nonlinearity\n        (30e9, 150e6, 0, 350e6, 5, 0.0, 400e6),      # Lower shear modulus\n    ]\n\n    results = []\n    for params in test_cases:\n        delta_lambda_result = compute_delta_lambda(*params)\n        results.append(str(delta_lambda_result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然标准的牛顿法对许多问题都非常有效，但在面对更具挑战性的材料响应时，例如材料软化（即材料刚度随变形而降低），它可能会失效。最后一个练习  探讨了这种高级场景，要求你实现一个更为稳健的、带有线搜索的牛顿求解器。通过将其与纯牛顿法进行比较，你将深刻体会到全局化策略的重要性，这些策略即使在处理非凸和可能不稳定的材料模型时也能确保求解器的收敛性。",
            "id": "3550930",
            "problem": "考虑一个具有各向同性硬化/软化的小应变、各向同性、率无关的 von Mises 塑性模型。屈服函数定义为 $f(\\boldsymbol{\\sigma},p) = \\sigma_{\\mathrm{eq}} - \\sigma_{y}(p)$，其中 $\\sigma_{\\mathrm{eq}}$ 是 von Mises 等效应力，$\\sigma_{y}(p)$ 是作为累积等效塑性应变 $p$ 的函数的当前屈服应力。在单个载荷增量步中，标准的弹性预测-塑性修正（返回映射）过程引入一个塑性乘子增量 $\\Delta \\lambda \\ge 0$，并在该步结束时强制执行一致性条件 $f=0$。在 von Mises 塑性的径向返回假定下，一致性条件简化为关于未知量 $\\Delta \\lambda$ 的标量非线性方程：\n$$\nr(\\Delta \\lambda) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}(p_n + \\Delta \\lambda) = 0,\n$$\n其中 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$ 是根据总应变增量计算出的弹性试探等效应力，$G$ 是剪切模量，$p_n$ 是该步开始时的累积等效塑性应变。所有量均视为无量纲量。\n\n在本问题中，各向同性硬化/软化定律被选为非凸形式\n$$\n\\sigma_{y}(p) = \\sigma_{y0} + A \\, p - C \\, p^3,\n$$\n参数 $A  0$ 和 $C  0$，因此瞬时硬化模量为\n$$\nH(p) := \\frac{d \\sigma_{y}}{d p} = A - 3 C p^2,\n$$\n当 $p$ 足够大时，该模量可以为负（软化区，$H(p)  0$）。这种选择会产生非凸的储存能形貌，并可能对标准迭代求解器构成挑战。\n\n你的任务是：\n1) 从上述一致性条件 $r(\\Delta \\lambda)=0$ 和给定的 $\\sigma_{y}(p)$ 出发，推导残差 $r(\\Delta \\lambda)$ 及其关于 $\\Delta \\lambda$ 的导数 $r'(\\Delta \\lambda)$ 的表达式。\n2) 提出一个基于残差范数的评价函数 $\\phi(\\Delta \\lambda)$，并推导专门针对此一维问题的 Armijo 回溯线搜索充分下降条件。\n3) 实现并比较两种求解 $\\Delta \\lambda$ 的求解器：\n   - 一种纯牛顿法，其更新规则为 $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$，如果更新试图违反非负性，则通过将其钳位到0来强制执行 $\\Delta \\lambda \\ge 0$ 的约束。\n   - 一种线搜索增强的牛顿法，它使用相同的牛顿方向 $s_k = - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$，但通过回溯选择一个步长 $\\alpha_k \\in (0,1]$ 以满足所提出的评价函数的 Armijo 条件。通过在必要时限制步长以确保 $\\Delta \\lambda_{k} + \\alpha_k s_k \\ge 0$，来强制执行 $\\Delta \\lambda \\ge 0$ 的约束。\n两种方法都应从初始猜测 $\\Delta \\lambda_0 = 0$ 开始，并迭代直到满足 $\\lvert r(\\Delta \\lambda_k) \\rvert \\le \\text{tol}$ 或达到最大迭代次数。使用 $\\text{tol} = 10^{-10}$ 和 $\\text{max\\_iters} = 50$。对于线搜索，使用 Armijo 参数 $c = 10^{-4}$ 和回溯因子 $\\beta = 1/2$。\n\n推导必须从一致性条件和硬化定律的定义开始。除这些定义外，不要假定任何特殊的快捷公式。明确说明线搜索条件如何在一维情况下被特化。\n\n将您的解决方案实现为一个程序，为每个测试用例计算两种求解器产生的最终值以及收敛标志。如果一种方法在迭代限制内未能收敛，则返回 $\\Delta \\lambda$ 的最后一次迭代值和一个表示未收敛的布尔标志。所有量均视为无量纲量；不需要物理单位。\n\n测试套件：\n提供以下四个参数集 $(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C)$ 的结果：\n- 情况1（轻度软化的理想情况）：$(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (1000.0, \\, 350.0, \\, 250.0, \\, 0.0, \\, 150.0, \\, 500.0)$。\n- 情况2（强软化，可能出现非单调残差）：$(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (200.0, \\, 310.0, \\, 300.0, \\, 0.2, \\, 50.0, \\, 1200.0)$。\n- 情况3（接近屈服边界，非常小的超应力）：$(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (1000.0, \\, 250.0001, \\, 250.0, \\, 0.0, \\, 100.0, \\, 800.0)$。\n- 情况4（极端软化和残差的多个极值）：$(G, \\, \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}, \\, \\sigma_{y0}, \\, p_n, \\, A, \\, C) = (150.0, \\, 280.0, \\, 260.0, \\, 0.05, \\, 20.0, \\, 5000.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个条目列表，每个测试用例一个条目，每个条目是列表 $[\\Delta \\lambda_{\\mathrm{Newton}}, \\, \\Delta \\lambda_{\\mathrm{LS}}, \\, \\text{conv}_{\\mathrm{Newton}}, \\, \\text{conv}_{\\mathrm{LS}}]$。这里 $\\Delta \\lambda_{\\mathrm{Newton}}$ 是纯牛顿求解器的最终值，$\\Delta \\lambda_{\\mathrm{LS}}$ 是线搜索牛顿求解器的最终值，收敛标志是布尔值。输出必须打印为单个带方括号的列表，条目之间用逗号分隔，不含空格，例如：$[[x_1,y_1,\\mathrm{True},\\mathrm{False}],[x_2,y_2,\\mathrm{True},\\mathrm{True}],\\dots]$。确保打印的数字是标准十进制表示。",
            "solution": "该问题提出了计算固体力学中一个定义明确的任务，要求对率无关塑性中由一致性条件产生的标量非线性方程进行数值求解。该材料模型具有非凸的硬化/软化定律，这引入了数值挑战。本问题旨在通过比较标准的 Newton-Raphson 求解器与更鲁棒的线搜索增强版本来研究这些挑战。该问题具有科学依据、内容完整，并且所有参数都已明确指定。因此，它被认为是有效的。\n\n按要求，解决方案分三部分呈现：残差及其导数的推导，评价函数和线搜索条件的构建，以及所实现算法的描述。\n\n### 1. 残差及其导数的推导\n\n问题的核心是求解塑性乘子增量 $\\Delta \\lambda$ 的标量一致性条件：\n$$\nr(\\Delta \\lambda) := \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\sigma_{y}(p_n + \\Delta \\lambda) = 0\n$$\n其中 $\\Delta \\lambda \\ge 0$。仅当弹性试探状态违反屈服条件，即 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}  \\sigma_{y}(p_n)$ 时，才考虑塑性步。如果不满足此条件，则该步为弹性步，解显然为 $\\Delta \\lambda = 0$。对于所有提供的测试用例，都有 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}  \\sigma_{y}(p_n)$，因此预期会得到一个非零的 $\\Delta \\lambda$。\n\n该步结束时的累积等效塑性应变为 $p = p_{n+1} = p_n + \\Delta p$。对于率无关塑性，累积塑性应变增量与塑性乘子增量相同，即 $\\Delta p = \\Delta \\lambda$。因此，$p = p_n + \\Delta \\lambda$。\n\n指定的各向同性硬化/软化定律是：\n$$\n\\sigma_{y}(p) = \\sigma_{y0} + A \\, p - C \\, p^3\n$$\n将 $p = p_n + \\Delta \\lambda$ 代入此定律，然后再代入一致性条件，得到残差函数 $r(\\Delta \\lambda)$ 的完整表达式：\n$$\nr(\\Delta \\lambda) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - 3 G \\, \\Delta \\lambda - \\left( \\sigma_{y0} + A (p_n + \\Delta \\lambda) - C (p_n + \\Delta \\lambda)^3 \\right)\n$$\n这就是我们需要为其求解根 $\\Delta \\lambda \\ge 0$ 的函数。\n\n对于牛顿法，我们需要残差函数的导数 $r'(\\Delta \\lambda) = \\frac{d r}{d (\\Delta \\lambda)}$。我们将 $r(\\Delta \\lambda)$ 的表达式对 $\\Delta \\lambda$ 求导，并将 $\\sigma_{\\mathrm{eq}}^{\\mathrm{tr}}$、$G$、$\\sigma_{y0}$、$A$、$C$ 和 $p_n$ 视为当前增量步的常数。\n$$\nr'(\\Delta \\lambda) = \\frac{d}{d (\\Delta \\lambda)} \\left( \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} \\right) - \\frac{d}{d (\\Delta \\lambda)} \\left( 3 G \\, \\Delta \\lambda \\right) - \\frac{d}{d (\\Delta \\lambda)} \\left( \\sigma_{y}(p_n + \\Delta \\lambda) \\right)\n$$\n$$\nr'(\\Delta \\lambda) = 0 - 3 G - \\frac{d \\sigma_y}{d p} \\bigg|_{p=p_n+\\Delta \\lambda} \\cdot \\frac{d (p_n + \\Delta \\lambda)}{d (\\Delta \\lambda)}\n$$\n屈服应力关于累积塑性应变的导数是瞬时硬化模量 $H(p) = \\frac{d \\sigma_y}{d p}$。根据给定的定律：\n$$\nH(p) = \\frac{d}{d p} (\\sigma_{y0} + A \\, p - C \\, p^3) = A - 3 C p^2\n$$\n将其在 $p = p_n + \\Delta \\lambda$ 处求值，得到 $H(p_n + \\Delta \\lambda) = A - 3 C (p_n + \\Delta \\lambda)^2$。\n将此结果代回 $r'(\\Delta \\lambda)$ 的表达式中：\n$$\nr'(\\Delta \\lambda) = -3G - H(p_n + \\Delta \\lambda) = -3G - \\left( A - 3 C (p_n + \\Delta \\lambda)^2 \\right)\n$$\n$$\nr'(\\Delta \\lambda) = -3G - A + 3 C (p_n + \\Delta \\lambda)^2\n$$\n这个最终表达式是算法一致性切线，它对牛顿法的二次收敛至关重要。请注意，对于较大的 $p$，$H(p)$ 会变为负值（软化），这可能导致 $r'(\\Delta \\lambda)$ 改变符号或趋近于零，这是纯牛顿法潜在失败的一个原因。\n\n### 2. 评价函数与 Armijo 线搜索条件\n\n为了提高牛顿法的鲁棒性，特别是在处理非凸问题时，可以采用线搜索来确保每次迭代都朝着解的方向取得足够的进展。对于求根问题 $r(x)=0$，一个标准的选择是残差的范数平方，在此一维情况下为：\n$$\n\\phi(\\Delta \\lambda) = \\frac{1}{2} r(\\Delta \\lambda)^2\n$$\n在第 $k$ 次迭代时，牛顿更新为 $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\alpha_k s_k$，其中 $s_k = -r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$ 是搜索方向，$\\alpha_k \\in (0,1]$ 是由线搜索确定的步长。\n\nArmijo 充分下降条件要求评价函数的减少量至少是由一阶泰勒展开预测的减少量的一部分。其一般形式为 $\\phi(\\mathbf{x}_k + \\alpha_k \\mathbf{s}_k) \\le \\phi(\\mathbf{x}_k) + c \\, \\alpha_k \\, \\nabla \\phi(\\mathbf{x}_k)^T \\mathbf{s}_k$。\n\n对于我们的一维问题，梯度 $\\nabla \\phi$ 就是导数 $\\phi'(\\Delta \\lambda)$：\n$$\n\\phi'(\\Delta \\lambda) = \\frac{d}{d(\\Delta \\lambda)} \\left( \\frac{1}{2} r(\\Delta \\lambda)^2 \\right) = r(\\Delta \\lambda) r'(\\Delta \\lambda)\n$$\n在 $\\Delta \\lambda_k$ 处沿 $s_k$ 的方向导数为：\n$$\n\\phi'(\\Delta \\lambda_k) s_k = \\left( r(\\Delta \\lambda_k) r'(\\Delta \\lambda_k) \\right) \\left( -\\frac{r(\\Delta \\lambda_k)}{r'(\\Delta \\lambda_k)} \\right) = -r(\\Delta \\lambda_k)^2\n$$\n这表明只要 $r(\\Delta \\lambda_k) \\neq 0$，牛顿方向 $s_k$ 对于所选的评价函数 $\\phi$ 始终是一个下降方向。\n\n因此，第 $k$ 次迭代的 Armijo 条件变为：\n$$\n\\phi(\\Delta \\lambda_k + \\alpha_k s_k) \\le \\phi(\\Delta \\lambda_k) + c \\, \\alpha_k \\left( -r(\\Delta \\lambda_k)^2 \\right)\n$$\n代入 $\\phi$ 的定义：\n$$\n\\frac{1}{2} r(\\Delta \\lambda_k + \\alpha_k s_k)^2 \\le \\frac{1}{2} r(\\Delta \\lambda_k)^2 - c \\, \\alpha_k \\, r(\\Delta \\lambda_k)^2\n$$\n其中 $c=10^{-4}$ 是指定的 Armijo 参数。\n\n寻找合适 $\\alpha_k$ 的回溯算法如下：\n1. 初始化 $\\alpha_k = 1$。\n2. 在一个循环中，检查试探步是否有效：\n   a. 检查物理约束：$\\Delta\\lambda_{\\text{trial}} = \\Delta \\lambda_k + \\alpha_k s_k \\ge 0$。\n   b. 检查 Armijo 条件：$\\frac{1}{2} r(\\Delta\\lambda_{\\text{trial}})^2 \\le (\\frac{1}{2} - c \\, \\alpha_k) r(\\Delta \\lambda_k)^2$。\n3. 如果任一检查失败，则减小步长 $\\alpha_k \\leftarrow \\beta \\alpha_k$（其中 $\\beta=1/2$），然后重复。\n4. 一旦找到有效的 $\\alpha_k$，就接受该更新。\n\n### 3. 求解器实现\n\n按照问题描述实现了两个求解器。两者都从 $\\Delta \\lambda_0 = 0$ 开始，并迭代直到 $|r(\\Delta \\lambda_k)| \\le 10^{-10}$ 或达到最大迭代次数 50 次。\n\n**纯牛顿求解器：**\n在每次迭代 $k$ 中，更新量按 $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k - r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$ 计算。通过“钳位”操作 $\\Delta \\lambda_{k+1} = \\max(0, \\Delta \\lambda_{k+1})$ 来强制执行非负性约束 $\\Delta \\lambda \\ge 0$。这种特殊处理方法可能很快，但也可能导致振荡或不收敛，特别是当算法过冲到一个 $r'(\\Delta \\lambda)$ 性态不良的区域时。\n\n**线搜索增强牛顿求解器：**\n该求解器使用相同的牛顿方向 $s_k = -r(\\Delta \\lambda_k)/r'(\\Delta \\lambda_k)$，但采用上述回溯算法来寻找一个步长 $\\alpha_k$，该步长同时满足 Armijo 条件和物理约束 $\\Delta \\lambda \\ge 0$。更新规则为 $\\Delta \\lambda_{k+1} = \\Delta \\lambda_k + \\alpha_k s_k$。这种全局化策略使得该方法更加鲁棒，即使从远离解的初始点开始，或者当残差函数 $r(\\Delta \\lambda)$ 非单调时，也更有可能收敛。\n\n对于两种求解器，都会执行一个初始检查：如果 $r(0) = \\sigma_{\\mathrm{eq}}^{\\mathrm{tr}} - \\sigma_y(p_n) \\le 0$，则该步为弹性步，因此我们立即返回 $\\Delta \\lambda = 0$，并将收敛状态设为真。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the solvers on all test cases and print results.\n    \"\"\"\n    \n    # Solver parameters\n    tol = 1e-10\n    max_iters = 50\n    # Line search parameters\n    c_armijo = 1e-4\n    beta_bt = 0.5\n    \n    test_cases = [\n        # (G, sig_eq_tr, sig_y0, p_n, A, C)\n        (1000.0, 350.0, 250.0, 0.0, 150.0, 500.0),    # Case 1\n        (200.0, 310.0, 300.0, 0.2, 50.0, 1200.0),     # Case 2\n        (1000.0, 250.0001, 250.0, 0.0, 100.0, 800.0), # Case 3\n        (150.0, 280.0, 260.0, 0.05, 20.0, 5000.0),    # Case 4\n    ]\n\n    all_results = []\n    \n    for params in test_cases:\n        dl_newton, conv_newton = solve_newton(params, tol, max_iters)\n        dl_ls, conv_ls = solve_linesearch_newton(params, tol, max_iters, c_armijo, beta_bt)\n        \n        all_results.append([dl_newton, dl_ls, conv_newton, conv_ls])\n\n    # Format the output string as per requirements (no spaces)\n    formatted_results = []\n    for res_list in all_results:\n        # Correctly format booleans as 'True' or 'False'\n        f_res = f\"[{res_list[0]},{res_list[1]},{str(res_list[2])},{str(res_list[3])}]\"\n        formatted_results.append(f_res)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\n\ndef _get_residual_and_derivative(dl, G, sig_eq_tr, sig_y0, p_n, A, C):\n    \"\"\"\n    Computes the residual r(dl) and its derivative r'(dl).\n    \"\"\"\n    p = p_n + dl\n    \n    # Yield stress and its derivative (hardening modulus)\n    sig_y = sig_y0 + A * p - C * p**3\n    H = A - 3 * C * p**2\n    \n    # Residual and its derivative\n    r_val = sig_eq_tr - 3 * G * dl - sig_y\n    r_prime_val = -3 * G - H\n    \n    return r_val, r_prime_val\n\ndef solve_newton(params, tol, max_iters):\n    \"\"\"\n    Solves for dl using the pure Newton method with clamping.\n    \"\"\"\n    G, sig_eq_tr, sig_y0, p_n, A, C = params\n    \n    # Check for elastic step\n    r0, _ = _get_residual_and_derivative(0.0, *params)\n    if r0 = 0:\n        return 0.0, True\n        \n    dl = 0.0\n    converged = False\n    \n    for _ in range(max_iters):\n        r_val, r_prime_val = _get_residual_and_derivative(dl, *params)\n        \n        if np.abs(r_val) = tol:\n            converged = True\n            break\n            \n        if np.abs(r_prime_val) = 1e-12: # Avoid division by zero\n            break\n\n        # Newton update\n        update = -r_val / r_prime_val\n        dl = dl + update\n        \n        # Enforce non-negativity by clamping\n        dl = max(0.0, dl)\n        \n    # Final check\n    if not converged:\n        r_final, _ = _get_residual_and_derivative(dl, *params)\n        if np.abs(r_final) = tol:\n            converged = True\n\n    return dl, converged\n\ndef solve_linesearch_newton(params, tol, max_iters, c, beta):\n    \"\"\"\n    Solves for dl using Newton's method with an Armijo backtracking line search.\n    \"\"\"\n    G, sig_eq_tr, sig_y0, p_n, A, C = params\n    \n    # Check for elastic step\n    r0, _ = _get_residual_and_derivative(0.0, *params)\n    if r0 = 0:\n        return 0.0, True\n\n    dl = 0.0\n    converged = False\n    \n    for _ in range(max_iters):\n        r_val, r_prime_val = _get_residual_and_derivative(dl, *params)\n        \n        if np.abs(r_val) = tol:\n            converged = True\n            break\n            \n        if np.abs(r_prime_val) = 1e-12:\n            break\n\n        # Newton direction\n        s = -r_val / r_prime_val\n        \n        # Backtracking line search\n        alpha = 1.0\n        phi = 0.5 * r_val**2\n        \n        while True:\n            dl_trial = dl + alpha * s\n            \n            if dl_trial  0:\n                alpha *= beta\n                if alpha = 1e-8: # Line search failed\n                    break\n                continue\n\n            r_trial, _ = _get_residual_and_derivative(dl_trial, *params)\n            phi_trial = 0.5 * r_trial**2\n            \n            # Armijo condition\n            armijo_check = phi + c * alpha * (-r_val**2) # Directional derivative is -r^2\n            \n            if phi_trial = armijo_check:\n                dl = dl_trial\n                break\n            \n            alpha *= beta\n            if alpha = 1e-8: # Line search failed\n                dl = dl_trial # Take the last valid (but not sufficient) step\n                break\n        \n        if alpha = 1e-8: # Propagate line search failure\n             break\n\n    if not converged:\n        r_final, _ = _get_residual_and_derivative(dl, *params)\n        if np.abs(r_final) = tol:\n            converged = True\n\n    return dl, converged\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}