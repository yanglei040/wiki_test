{
    "hands_on_practices": [
        {
            "introduction": "The journey into finite element analysis begins with mastering its building blocks: the shape functions. This first practice provides a foundational, hands-on derivation of the shape functions for a one-dimensional quadratic element, a staple in modeling beams and trusses . By applying the principles of Lagrange interpolation, you will not only construct these functions but also evaluate them and their derivatives at Gauss-Legendre quadrature points, a critical skill for the numerical integration of element matrices.",
            "id": "3589622",
            "problem": "Consider the one-dimensional isoparametric quadratic bar element used in the Finite Element Method (FEM) on the parent coordinate domain $\\xi \\in [-1,1]$ with nodes at $\\xi_1 = -1$, $\\xi_2 = 0$, and $\\xi_3 = 1$. In a displacement-based formulation, the interpolated field is represented as $u(\\xi) = \\sum_{i=1}^{3} N_i(\\xi) u_i$, where $N_i(\\xi)$ are the shape functions associated with the nodes. Starting from polynomial interpolation principles consistent with the finite element method, derive the quadratic shape functions $N_i(\\xi)$ that satisfy the Kronecker delta property $N_i(\\xi_j) = \\delta_{ij}$, the partition of unity $\\sum_{i=1}^{3} N_i(\\xi) = 1$, and completeness for constant and linear fields. Then, compute $N_i(\\xi)$ and the derivatives $\\dfrac{dN_i}{d\\xi}(\\xi)$ at the Gauss–Legendre points $\\xi = \\pm \\dfrac{1}{\\sqrt{3}}$, which are used in $2$-point Gaussian quadrature. Provide the final answer as a single row matrix, with entries in the order\n$$N_1\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, N_2\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, N_3\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_1}{d\\xi}\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_2}{d\\xi}\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_3}{d\\xi}\\!\\left(-\\frac{1}{\\sqrt{3}}\\right),\\, N_1\\!\\left(\\frac{1}{\\sqrt{3}}\\right),\\, N_2\\!\\left(\\frac{1}{\\sqrt{3}}\\right),\\, N_3\\!\\left(\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_1}{d\\xi}\\!\\left(\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_2}{d\\xi}\\!\\left(\\frac{1}{\\sqrt{3}}\\right),\\, \\frac{dN_3}{d\\xi}\\!\\left(\\frac{1}{\\sqrt{3}}\\right). Express all entries in exact analytic form; no numerical rounding is required.",
            "solution": "The problem statement is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n-   Element Type: One-dimensional isoparametric quadratic bar element.\n-   Parent Coordinate Domain: $\\xi \\in [-1, 1]$.\n-   Nodal Coordinates: $\\xi_1 = -1$, $\\xi_2 = 0$, $\\xi_3 = 1$.\n-   Interpolated Field Representation: $u(\\xi) = \\sum_{i=1}^{3} N_i(\\xi) u_i$.\n-   Shape Function Properties:\n    -   Kronecker delta property: $N_i(\\xi_j) = \\delta_{ij}$.\n    -   Partition of unity: $\\sum_{i=1}^{3} N_i(\\xi) = 1$.\n    -   Completeness for constant and linear fields.\n-   Objective:\n    1.  Derive the quadratic shape functions $N_i(\\xi)$.\n    2.  Compute the values of $N_i(\\xi)$ and their derivatives $\\frac{dN_i}{d\\xi}(\\xi)$ at the $2$-point Gauss–Legendre quadrature points, which are $\\xi = \\pm \\frac{1}{\\sqrt{3}}$.\n-   Final Answer Format: A single row matrix containing $12$ specific values in a prescribed order, expressed in exact analytic form.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard, fundamental exercise in the field of computational solid mechanics, specifically within the Finite Element Method (FEM).\n-   **Scientifically Grounded:** The concepts of isoparametric mapping, parent elements, shape functions (as Lagrange polynomials), and Gaussian quadrature are all canonical, well-established principles in numerical analysis and engineering. It is scientifically and factually sound.\n-   **Well-Posed:** The problem is clearly defined and self-contained. The nodal positions and the required polynomial degree (quadratic) provide sufficient information to uniquely determine the shape functions. The task is unambiguous and has a unique, stable solution.\n-   **Objective:** The language is formal, precise, and devoid of any subjectivity, ambiguity, or opinion.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is scientifically sound, well-posed, objective, and complete. The solution process may proceed.\n\nThe shape functions $N_i(\\xi)$ for a quadratic element are second-degree polynomials. Given the nodal coordinates $\\xi_1 = -1$, $\\xi_2 = 0$, and $\\xi_3 = 1$, we can use the formula for Lagrange interpolation polynomials to derive them, as this construction inherently satisfies the Kronecker delta property $N_i(\\xi_j) = \\delta_{ij}$.\n\nFor a generic node $i$, the Lagrange shape function is given by:\n$$N_i(\\xi) = \\prod_{j=1, j\\neq i}^{3} \\frac{\\xi - \\xi_j}{\\xi_i - \\xi_j}$$\n\nFor node $1$ ($\\xi_1 = -1$):\n$$N_1(\\xi) = \\frac{\\xi - \\xi_2}{\\xi_1 - \\xi_2} \\cdot \\frac{\\xi - \\xi_3}{\\xi_1 - \\xi_3} = \\frac{\\xi - 0}{-1 - 0} \\cdot \\frac{\\xi - 1}{-1 - 1} = \\frac{\\xi}{-1} \\cdot \\frac{\\xi - 1}{-2} = \\frac{1}{2}\\xi(\\xi - 1) = \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi$$\n\nFor node $2$ ($\\xi_2 = 0$):\n$$N_2(\\xi) = \\frac{\\xi - \\xi_1}{\\xi_2 - \\xi_1} \\cdot \\frac{\\xi - \\xi_3}{\\xi_2 - \\xi_3} = \\frac{\\xi - (-1)}{0 - (-1)} \\cdot \\frac{\\xi - 1}{0 - 1} = \\frac{\\xi + 1}{1} \\cdot \\frac{\\xi - 1}{-1} = -(\\xi+1)(\\xi-1) = 1 - \\xi^2$$\n\nFor node $3$ ($\\xi_3 = 1$):\n$$N_3(\\xi) = \\frac{\\xi - \\xi_1}{\\xi_3 - \\xi_1} \\cdot \\frac{\\xi - \\xi_2}{\\xi_3 - \\xi_2} = \\frac{\\xi - (-1)}{1 - (-1)} \\cdot \\frac{\\xi - 0}{1 - 0} = \\frac{\\xi + 1}{2} \\cdot \\frac{\\xi}{1} = \\frac{1}{2}\\xi(\\xi + 1) = \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi$$\n\nThese functions satisfy the partition of unity property:\n$$\\sum_{i=1}^{3} N_i(\\xi) = \\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) + (1 - \\xi^2) + \\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = \\left(\\frac{1}{2} - 1 + \\frac{1}{2}\\right)\\xi^2 + \\left(-\\frac{1}{2} + \\frac{1}{2}\\right)\\xi + 1 = 1$$\n\nNext, we find the derivatives of the shape functions with respect to $\\xi$:\n$$\\frac{dN_1}{d\\xi} = \\frac{d}{d\\xi}\\left(\\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi\\right) = \\xi - \\frac{1}{2}$$\n$$\\frac{dN_2}{d\\xi} = \\frac{d}{d\\xi}\\left(1 - \\xi^2\\right) = -2\\xi$$\n$$\\frac{dN_3}{d\\xi} = \\frac{d}{d\\xi}\\left(\\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi\\right) = \\xi + \\frac{1}{2}$$\n\nNow we evaluate the shape functions and their derivatives at the Gauss-Legendre points $\\xi = \\pm \\frac{1}{\\sqrt{3}}$.\n\n**Evaluation at $\\xi = -\\frac{1}{\\sqrt{3}}$:**\nFor this point, $\\xi^2 = \\left(-\\frac{1}{\\sqrt{3}}\\right)^2 = \\frac{1}{3}$.\n$N_1\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{2}\\left(\\frac{1}{3} - \\left(-\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{6} + \\frac{1}{2\\sqrt{3}} = \\frac{1}{6} + \\frac{\\sqrt{3}}{6} = \\frac{1+\\sqrt{3}}{6}$.\n$N_2\\left(-\\frac{1}{\\sqrt{3}}\\right) = 1 - \\left(\\frac{1}{3}\\right) = \\frac{2}{3}$.\n$N_3\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{2}\\left(\\frac{1}{3} + \\left(-\\frac{1}{\\sqrt{3}}\\right)\\right) = \\frac{1}{6} - \\frac{1}{2\\sqrt{3}} = \\frac{1}{6} - \\frac{\\sqrt{3}}{6} = \\frac{1-\\sqrt{3}}{6}$.\n\n$\\frac{dN_1}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = -\\frac{1}{\\sqrt{3}} - \\frac{1}{2} = -\\frac{\\sqrt{3}}{3} - \\frac{1}{2} = \\frac{-2\\sqrt{3}-3}{6}$.\n$\\frac{dN_2}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = -2\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{2}{\\sqrt{3}} = \\frac{2\\sqrt{3}}{3}$.\n$\\frac{dN_3}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = -\\frac{1}{\\sqrt{3}} + \\frac{1}{2} = -\\frac{\\sqrt{3}}{3} + \\frac{1}{2} = \\frac{-2\\sqrt{3}+3}{6}$.\n\n**Evaluation at $\\xi = \\frac{1}{\\sqrt{3}}$:**\nFor this point, $\\xi^2 = \\left(\\frac{1}{\\sqrt{3}}\\right)^2 = \\frac{1}{3}$.\n$N_1\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{2}\\left(\\frac{1}{3} - \\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{6} - \\frac{1}{2\\sqrt{3}} = \\frac{1}{6} - \\frac{\\sqrt{3}}{6} = \\frac{1-\\sqrt{3}}{6}$.\n$N_2\\left(\\frac{1}{\\sqrt{3}}\\right) = 1 - \\frac{1}{3} = \\frac{2}{3}$.\n$N_3\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{2}\\left(\\frac{1}{3} + \\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{6} + \\frac{1}{2\\sqrt{3}} = \\frac{1}{6} + \\frac{\\sqrt{3}}{6} = \\frac{1+\\sqrt{3}}{6}$.\n\n$\\frac{dN_1}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{\\sqrt{3}} - \\frac{1}{2} = \\frac{\\sqrt{3}}{3} - \\frac{1}{2} = \\frac{2\\sqrt{3}-3}{6}$.\n$\\frac{dN_2}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = -2\\left(\\frac{1}{\\sqrt{3}}\\right) = -\\frac{2}{\\sqrt{3}} = -\\frac{2\\sqrt{3}}{3}$.\n$\\frac{dN_3}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1}{\\sqrt{3}} + \\frac{1}{2} = \\frac{\\sqrt{3}}{3} + \\frac{1}{2} = \\frac{2\\sqrt{3}+3}{6}$.\n\nThe $12$ values for the final answer matrix, in the specified order, are:\n1.  $N_1\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{1+\\sqrt{3}}{6}$\n2.  $N_2\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{2}{3}$\n3.  $N_3\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{1-\\sqrt{3}}{6}$\n4.  $\\frac{dN_1}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{-3-2\\sqrt{3}}{6}$\n5.  $\\frac{dN_2}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{2\\sqrt{3}}{3}$\n6.  $\\frac{dN_3}{d\\xi}\\left(-\\frac{1}{\\sqrt{3}}\\right) = \\frac{3-2\\sqrt{3}}{6}$\n7.  $N_1\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1-\\sqrt{3}}{6}$\n8.  $N_2\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{2}{3}$\n9.  $N_3\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{1+\\sqrt{3}}{6}$\n10. $\\frac{dN_1}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{-3+2\\sqrt{3}}{6}$\n11. $\\frac{dN_2}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = -\\frac{2\\sqrt{3}}{3}$\n12. $\\frac{dN_3}{d\\xi}\\left(\\frac{1}{\\sqrt{3}}\\right) = \\frac{3+2\\sqrt{3}}{6}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} \\frac{1+\\sqrt{3}}{6} & \\frac{2}{3} & \\frac{1-\\sqrt{3}}{6} & \\frac{-3-2\\sqrt{3}}{6} & \\frac{2\\sqrt{3}}{3} & \\frac{3-2\\sqrt{3}}{6} & \\frac{1-\\sqrt{3}}{6} & \\frac{2}{3} & \\frac{1+\\sqrt{3}}{6} & \\frac{-3+2\\sqrt{3}}{6} & -\\frac{2\\sqrt{3}}{3} & \\frac{3+2\\sqrt{3}}{6} \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Moving from one to two dimensions, we introduce the workhorse of many analyses: the isoparametric bilinear quadrilateral ($Q_1$) element. This exercise challenges you to implement this element and verify two of its most fundamental properties: the partition of unity and the exact reproduction of linear fields . Successfully completing this numerical verification for various element geometries builds confidence that your implementation correctly captures the essential consistency requirements for a convergent finite element formulation.",
            "id": "3589573",
            "problem": "Consider a single isoparametric first-order quadrilateral ($Q_1$) finite element used in computational solid mechanics. The reference (natural) coordinates are $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$. The physical coordinates $(x,y)$ are obtained by an isoparametric bilinear mapping using the same bilinear interpolation shape functions as those used to interpolate fields on the element. The four nodes are ordered counterclockwise as follows: node $1$ corresponds to $(\\xi,\\eta)=(-1,-1)$, node $2$ corresponds to $(\\xi,\\eta)=(+1,-1)$, node $3$ corresponds to $(\\xi,\\eta)=(+1,+1)$, and node $4$ corresponds to $(\\xi,\\eta)=(-1,+1)$. The bilinear shape functions are the unique polynomials that are equal to $1$ at their own node and $0$ at the other nodes on the reference square, and they are used both to map the geometry and to interpolate fields.\n\nStarting from the fundamental base that the isoparametric bilinear interpolation uses the same bilinear shape functions for geometry and field approximation, implement the following verification tasks for the scalar field $u(x,y)$ on a single element:\n- Partition of unity verification: the shape functions should satisfy $\\sum_{i=1}^{4}N_i(\\xi,\\eta)=1$ at all interior sampling points $(\\xi,\\eta)$.\n- Exact reproduction verification: for the linear physical-space field $u(x,y)=1+x-y$, the isoparametric interpolant constructed from the nodal values $u_i=u(x_i,y_i)$ must evaluate to $u(x(\\xi,\\eta),y(\\xi,\\eta))$ at all interior sampling points $(\\xi,\\eta)$, where $(x(\\xi,\\eta),y(\\xi,\\eta))$ is obtained via the isoparametric mapping of the element.\n\nYour program must implement from first principles the bilinear ($Q_1$) shape functions, the isoparametric mapping for the geometry, and the field interpolation. It must then compute the maximum absolute deviation from the partition of unity and the maximum absolute linear-field reproduction error over a specified set of interior sampling points for each test element described below.\n\nUse the following test suite of three elements, each defined by its four nodal physical coordinates $(x_i,y_i)$ for $i\\in\\{1,2,3,4\\}$ in the counterclockwise order described above:\n- Element A (affine parallelogram): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0)$, $(x_3,y_3)=(2,1)$, $(x_4,y_4)=(0,1)$.\n- Element B (moderately distorted convex quadrilateral): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(2,0.2)$, $(x_3,y_3)=(2.2,1.1)$, $(x_4,y_4)=(-0.2,0.9)$.\n- Element C (strongly skewed convex quadrilateral): $(x_1,y_1)=(0,0)$, $(x_2,y_2)=(1.7,-0.3)$, $(x_3,y_3)=(2.4,0.8)$, $(x_4,y_4)=(-0.4,1.2)$.\n\nUse the following interior sampling points in the reference square:\n- Center: $(\\xi,\\eta)=(0,0)$.\n- Two-point Gauss abscissae combinations: let $g=1/\\sqrt{3}$; use $(\\xi,\\eta)=(g,g)$, $(g,-g)$, $(-g,g)$, $(-g,-g)$.\n- Additional interior points near edges: $(\\xi,\\eta)=(0.8,-0.6)$, $(-0.6,0.8)$, $(0.9,0)$, $(0,-0.9)$.\n\nFor each element, compute:\n- The maximum absolute partition-of-unity defect over the sampling set, defined as $\\max|\\sum_{i=1}^{4}N_i(\\xi,\\eta)-1|$.\n- The maximum absolute linear-field reproduction error over the sampling set, defined as $\\max|u^h(\\xi,\\eta)-u(x(\\xi,\\eta),y(\\xi,\\eta))|$, where $u^h(\\xi,\\eta)=\\sum_{i=1}^{4}N_i(\\xi,\\eta)\\,u_i$ and $u_i=1+x_i-y_i$.\n\nExpress all computed errors as dimensionless floating-point numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$[\\mathrm{E\\_pu}^{(A)},\\mathrm{E\\_lin}^{(A)},\\mathrm{E\\_pu}^{(B)},\\mathrm{E\\_lin}^{(B)},\\mathrm{E\\_pu}^{(C)},\\mathrm{E\\_lin}^{(C)}]$,\nwhere $\\mathrm{E\\_pu}^{(\\cdot)}$ and $\\mathrm{E\\_lin}^{(\\cdot)}$ denote the maximum absolute partition-of-unity and linear-field reproduction errors, respectively, for the indicated element. No units are involved, and angles are not used.",
            "solution": "The problem requires the verification of two fundamental properties of first-order isoparametric quadrilateral ($Q_1$) finite elements: the partition of unity and the exact reproduction of linear polynomials. This is a standard procedure in computational mechanics to validate the implementation of element formulations. The verification will be performed numerically for three distinct element geometries over a specified set of sampling points in the reference domain.\n\n**1. Bilinear Shape Functions for the $Q_1$ Element**\n\nThe $Q_1$ element is defined on a reference domain, a square in the natural coordinate system $(\\xi,\\eta)$, where $\\xi \\in [-1, 1]$ and $\\eta \\in [-1, 1]$. The four nodes are located at the corners of this square, numbered counterclockwise:\n- Node $1$: $(\\xi_1, \\eta_1) = (-1, -1)$\n- Node $2$: $(\\xi_2, \\eta_2) = (+1, -1)$\n- Node $3$: $(\\xi_3, \\eta_3) = (+1, +1)$\n- Node $4$: $(\\xi_4, \\eta_4) = (-1, +1)$\n\nThe shape function $N_i(\\xi, \\eta)$ associated with node $i$ is a bilinear polynomial of the form $c_0 + c_1\\xi + c_2\\eta + c_3\\xi\\eta$. It is defined by the property that it equals $1$ at its own node and $0$ at the other three nodes, i.e., $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. This condition uniquely determines the four shape functions. They can be constructed by inspection using products of linear functions. For example, $N_1(\\xi, \\eta)$ must be zero when $\\xi=+1$ or $\\eta=+1$, suggesting it is proportional to $(1-\\xi)(1-\\eta)$. The constant of proportionality is found by enforcing $N_1(-1, -1) = 1$. This procedure yields the following standard set of bilinear shape functions:\n\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n\nThese functions form the basis for interpolation within the element.\n\n**2. Isoparametric Mapping and Field Interpolation**\n\nThe isoparametric concept dictates that the same shape functions are used to interpolate the element's geometry (the physical coordinates $(x,y)$) and to approximate any field variable (e.g., a scalar field $u$) over the element.\n\nThe mapping from the reference coordinates $(\\xi, \\eta)$ to the physical coordinates $(x,y)$ is given by:\n$$x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i$$\n$$y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i$$\nwhere $(x_i, y_i)$ are the known physical coordinates of the element's four nodes.\n\nSimilarly, a scalar field $u$ is approximated within the element by an interpolant $u^h$:\n$$u^h(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i$$\nwhere $u_i$ are the values of the field at the nodes.\n\n**3. Verification Properties**\n\nThe implementation will be validated against two cornerstone properties of these shape functions.\n\n**3.1. Partition of Unity**\n\nThe shape functions must sum to unity at every point within the element:\n$$\\sum_{i=1}^{4} N_i(\\xi, \\eta) = 1 \\quad \\forall (\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$$\nThis property is crucial for ensuring that rigid body motion (a constant displacement field) is represented exactly, which is a requirement for convergence. We can verify this property algebraically:\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\xi)(1-\\eta) + (1+\\xi)(1-\\eta) + (1+\\xi)(1+\\eta) + (1-\\xi)(1+\\eta) \\right] $$\nFactoring terms:\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\eta)(1-\\xi+1+\\xi) + (1+\\eta)(1+\\xi+1-\\xi) \\right] $$\n$$ \\sum_{i=1}^{4} N_i = \\frac{1}{4} \\left[ (1-\\eta)(2) + (1+\\eta)(2) \\right] = \\frac{1}{2} (1-\\eta+1+\\eta) = \\frac{1}{2}(2) = 1 $$\nNumerically, we will compute the partition-of-unity defect, defined as the maximum absolute difference from $1$ over the set of sampling points:\n$$ \\mathrm{E_{\\mathrm{pu}}} = \\max_{(\\xi, \\eta) \\in S} \\left| \\left( \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\right) - 1 \\right| $$\nwhere $S$ is the given set of sampling points. Due to finite-precision arithmetic, this error is expected to be on the order of machine epsilon, not exactly zero.\n\n**3.2. Linear Field Reproduction**\n\nA finite element formulation must be able to exactly represent a field that is a linear function of the spatial coordinates, i.e., $u(x,y) = a + bx + cy$. This is a necessary condition for the method to pass the patch test and achieve its theoretical convergence rate. The problem specifies the field $u(x,y) = 1 + x - y$.\n\nThe nodal values for this field are $u_i = u(x_i, y_i) = 1 + x_i - y_i$. The interpolated field is:\n$$ u^h(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_i = \\sum_{i=1}^{4} N_i(\\xi, \\eta) (1 + x_i - y_i) $$\nBy distributing the sum:\n$$ u^h(\\xi, \\eta) = \\left( \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\right) \\cdot 1 + \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i - \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i $$\nRecognizing the partition of unity and the isoparametric coordinate mappings:\n$$ u^h(\\xi, \\eta) = 1 + x(\\xi, \\eta) - y(\\xi, \\eta) $$\nThis shows that the interpolated field $u^h$ at a point $(\\xi, \\eta)$ is identical to the exact field $u$ evaluated at the corresponding physical point $(x(\\xi, \\eta), y(\\xi, \\eta))$.\n\nNumerically, we will compute the linear-field reproduction error, defined as the maximum absolute difference between the interpolated field and the exact field over the sampling points:\n$$ \\mathrm{E_{\\mathrm{lin}}} = \\max_{(\\xi, \\eta) \\in S} \\left| u^h(\\xi, \\eta) - u(x(\\xi, \\eta), y(\\xi, \\eta)) \\right| $$\nSimilar to the partition-of-unity defect, this error is expected to be non-zero but very small, reflecting the limits of floating-point precision.\n\n**4. Algorithmic Implementation**\n\nThe verification process is implemented as follows:\n1. Define the set of $9$ sampling points $(\\xi, \\eta)$ in the reference domain.\n2. For each of the three test elements (A, B, C), defined by their nodal coordinates $(x_i, y_i)$:\n    a. Initialize the maximum partition-of-unity defect $\\mathrm{E_{\\mathrm{pu}}}$ and maximum linear reproduction error $\\mathrm{E_{\\mathrm{lin}}}$ to $0$.\n    b. Calculate the nodal values $u_i = 1+x_i-y_i$ for the linear test field.\n    c. Iterate through each sampling point $(\\xi_s, \\eta_s)$:\n        i. Compute the four shape function values $N_i(\\xi_s, \\eta_s)$.\n        ii. Calculate the partition-of-unity sum $\\Sigma_N = \\sum_{i=1}^4 N_i$. Update $\\mathrm{E_{\\mathrm{pu}}} = \\max(\\mathrm{E_{\\mathrm{pu}}}, |\\Sigma_N - 1|)$.\n        iii. Compute the physical coordinates $(x_s, y_s)$ corresponding to $(\\xi_s, \\eta_s)$ using the isoparametric mapping: $x_s = \\sum N_i x_i$, $y_s = \\sum N_i y_i$.\n        iv. Compute the exact field value at this point: $u_{exact} = 1 + x_s - y_s$.\n        v. Compute the interpolated field value: $u_h = \\sum N_i u_i$.\n        vi. Calculate the reproduction error $|u_h - u_{exact}|$. Update $\\mathrm{E_{\\mathrm{lin}}} = \\max(\\mathrm{E_{\\mathrm{lin}}}, |u_h - u_{exact}|)$.\n3. Collect the six computed maximum error values $(\\mathrm{E_{\\mathrm{pu}}}^{(A)}, \\mathrm{E_{\\mathrm{lin}}}^{(A)}, \\dots)$ for final output.\n\nThis procedure systematically tests the implemented shape functions and interpolation scheme against their core theoretical properties.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the verification of partition of unity and linear field reproduction\n    for a Q1 isoparametric element.\n    \"\"\"\n\n    # Define the three test elements by their nodal coordinates (x, y)\n    # in the specified counterclockwise order:\n    # node 1: (xi,eta)=(-1,-1), node 2: (1,-1), node 3: (1,1), node 4: (-1,1).\n    test_cases = [\n        # Element A: Affine parallelogram (Rectangle)\n        np.array([[0.0, 0.0], [2.0, 0.0], [2.0, 1.0], [0.0, 1.0]]),\n        # Element B: Moderately distorted convex quadrilateral\n        np.array([[0.0, 0.0], [2.0, 0.2], [2.2, 1.1], [-0.2, 0.9]]),\n        # Element C: Strongly skewed convex quadrilateral\n        np.array([[0.0, 0.0], [1.7, -0.3], [2.4, 0.8], [-0.4, 1.2]]),\n    ]\n\n    # Define the interior sampling points in the reference square [-1,1]x[-1,1]\n    g = 1.0 / np.sqrt(3.0)\n    sampling_points = [\n        (0.0, 0.0),                               # Center\n        (g, g), (g, -g), (-g, g), (-g, -g),      # 2x2 Gauss points\n        (0.8, -0.6), (-0.6, 0.8), (0.9, 0.0), (0.0, -0.9) # Additional points\n    ]\n\n    def get_shape_functions(xi, eta):\n        \"\"\"\n        Computes the four bilinear shape functions for a Q1 element at a point (xi, eta).\n        Returns a numpy array of shape (4,).\n        \"\"\"\n        N1 = 0.25 * (1.0 - xi) * (1.0 - eta)\n        N2 = 0.25 * (1.0 + xi) * (1.0 - eta)\n        N3 = 0.25 * (1.0 + xi) * (1.0 + eta)\n        N4 = 0.25 * (1.0 - xi) * (1.0 + eta)\n        return np.array([N1, N2, N3, N4])\n\n    results = []\n    \n    # Process each element\n    for nodes in test_cases:\n        max_pu_defect = 0.0\n        max_lin_error = 0.0\n\n        # Nodal coordinates (x_i, y_i)\n        x_nodes = nodes[:, 0]\n        y_nodes = nodes[:, 1]\n\n        # Nodal values for the linear field u(x,y) = 1 + x - y\n        u_nodes = 1.0 + x_nodes - y_nodes\n\n        # Iterate over all sampling points\n        for xi, eta in sampling_points:\n            # 1. Compute shape functions at the sampling point\n            N = get_shape_functions(xi, eta)\n\n            # 2. Partition of Unity (PU) verification\n            pu_sum = np.sum(N)\n            pu_defect = np.abs(pu_sum - 1.0)\n            if pu_defect > max_pu_defect:\n                max_pu_defect = pu_defect\n            \n            # 3. Linear Field Reproduction verification\n            \n            # Map sampling point to physical coordinates using isoparametric mapping\n            x_s = N @ x_nodes\n            y_s = N @ y_nodes\n            \n            # Evaluate the exact field at the mapped physical point\n            u_exact = 1.0 + x_s - y_s\n            \n            # Evaluate the interpolated field using nodal values\n            u_h = N @ u_nodes\n            \n            # Calculate the reproduction error\n            lin_error = np.abs(u_h - u_exact)\n            if lin_error > max_lin_error:\n                max_lin_error = lin_error\n\n        results.append(max_pu_defect)\n        results.append(max_lin_error)\n\n    # Format the output string as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice synthesizes the preceding concepts into a core task of computational solid mechanics: assembling an element stiffness matrix, $\\mathbf{K}$. Starting with the bilinear shape functions, you will compute the strain-displacement matrix, $\\mathbf{B}$, which involves the crucial step of transforming derivatives from the reference element to the physical element via the Jacobian matrix . By integrating the product $\\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}$ and verifying the symmetry of the resulting stiffness matrix, you will confirm a property that is a direct consequence of the variational principles underlying the entire finite element method.",
            "id": "3589673",
            "problem": "You are asked to implement an isoparametric bilinear quadrilateral element with polynomial interpolation and shape functions in two-dimensional small-strain linear elasticity and to verify a structural property of the resulting element stiffness. The focus is on deriving and computing the strain-displacement matrix, often termed the $B$-matrix, at Gaussian quadrature points for a distorted element and verifying that the assembled element stiffness matrix is symmetric. Work from fundamental definitions and well-tested facts and construct your algorithm accordingly.\n\nAssume two-dimensional small-strain kinematics. The small-strain tensor is defined as $\\boldsymbol{\\varepsilon} = \\operatorname{sym}\\left(\\nabla \\mathbf{u}\\right)$, where $\\mathbf{u}$ is the displacement field. The constitutive model is linear elasticity, expressed as $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$, with $\\boldsymbol{\\sigma}$ the Cauchy stress tensor and $\\mathbf{D}$ the symmetric constitutive tensor for plane strain. Use an isoparametric mapping from the natural coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ to the physical coordinates $(x,y)$ via polynomial interpolation with bilinear shape functions that satisfy the Kronecker-delta property at the nodes. The nodes are numbered counterclockwise starting at the bottom-left corner, yielding a four-node element. The gradient transformation from natural derivatives to physical derivatives should be carried out using the Jacobian of the mapping.\n\nYour task is to:\n- Derive the bilinear shape functions for the $Q_1$ element from the polynomial interpolation conditions in natural coordinates $(\\xi,\\eta)$.\n- Derive the transformation of shape function derivatives from natural coordinates to physical coordinates using the Jacobian matrix $\\mathbf{J}(\\xi,\\eta)$ of the isoparametric mapping and its inverse.\n- Construct the strain-displacement matrix $\\mathbf{B}(\\xi,\\eta)$ for the two-dimensional small-strain case at each quadrature point.\n- Assemble the element stiffness matrix $\\mathbf{K}$ using Gaussian quadrature with $2\\times 2$ points, thickness $t$, and material parameters Young’s modulus $E$ and Poisson’s ratio $\\nu$ under plane strain conditions.\n- Verify the symmetry of $\\mathbf{K}$ by checking whether $\\mathbf{K} = \\mathbf{K}^\\top$ within a reasonable numerical tolerance.\n\nUse the following test suite of elements and material parameters. All lengths are in $\\mathrm{m}$ and all elastic moduli are in $\\mathrm{Pa}$. Thickness $t$ is in $\\mathrm{m}$.\n\nTest case $1$:\n- Nodes: $\\left[(0,0),(1,0),(1,1),(0,1)\\right]$\n- $E = 70\\times 10^{9}$, $\\nu = 0.33$, $t = 0.1$\n\nTest case $2$:\n- Nodes: $\\left[(0,0),(1.2,0),(1.2,1),(0.2,1)\\right]$\n- $E = 210\\times 10^{9}$, $\\nu = 0.3$, $t = 0.05$\n\nTest case $3$:\n- Nodes: $\\left[(0,0),(1,0),(0.9,0.8),(-0.1,0.9)\\right]$\n- $E = 120\\times 10^{9}$, $\\nu = 0.25$, $t = 0.2$\n\nTest case $4$:\n- Nodes: rotation by $30$ degrees of the rectangle with corners $\\left[(0,0),(2,0),(2,1),(0,1)\\right]$ about the origin, giving coordinates $\\left[(0,0),(1.7320508075688772,1.0),(1.2320508075688772,1.8660254037844386),(-0.5,0.8660254037844386)\\right]$\n- $E = 1\\times 10^{9}$, $\\nu = 0.4$, $t = 0.005$\n\nYour program must:\n- For each test case, compute the $\\mathbf{B}$-matrix at all four $2\\times 2$ Gaussian quadrature points, assemble the element stiffness matrix $\\mathbf{K}$, and check symmetry within a strict absolute tolerance based on the magnitude of $\\mathbf{K}$.\n- Produce a single line of output containing the symmetry check results for the four test cases as a comma-separated list enclosed in square brackets; for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$, where each entry is a boolean.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact form $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$, where each $\\text{result}_i$ is either $\\text{True}$ or $\\text{False}$.",
            "solution": "The problem is to implement a two-dimensional, four-node isoparametric quadrilateral element for linear elasticity and verify the symmetry of the resulting element stiffness matrix, $\\mathbf{K}$. This verification serves as a fundamental validation of the implementation's correctness, as the symmetry of $\\mathbf{K}$ is a direct consequence of the underlying conservative physical principles and the variational formulation of the finite element method. The derivation proceeds from first principles as follows.\n\nFirst, we establish the polynomial interpolation within the parent element domain. A four-node quadrilateral ($Q_1$) element uses bilinear shape functions, $N_i(\\xi, \\eta)$, defined over the natural coordinate system $(\\xi, \\eta)$, where $\\xi, \\eta \\in [-1, 1]$. A general bilinear polynomial is of the form $p(\\xi, \\eta) = c_1 + c_2\\xi + c_3\\eta + c_4\\xi\\eta$. The shape function for node $i$, $N_i$, must satisfy the Kronecker-delta property: $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$, where $(\\xi_j, \\eta_j)$ are the coordinates of node $j$. The nodes are numbered counter-clockwise in the parent domain: node $1$ at $(-1, -1)$, node $2$ at $(1, -1)$, node $3$ at $(1, 1)$, and node $4$ at $(-1, 1)$. By requiring $N_i$ to be $1$ at its own node and $0$ at the others, we derive the four shape functions:\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$$\n$$N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$$\n$$N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$$\n$$N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$$\n\nSecond, we define the isoparametric mapping. The physical coordinates $(x, y)$ of any point within the element are interpolated from the nodal coordinates $(x_i, y_i)$ using the same shape functions:\n$$x(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i$$\nTo relate derivatives with respect to physical coordinates $(x, y)$ to those in natural coordinates $(\\xi, \\eta)$, we use the chain rule, which defines the Jacobian matrix $\\mathbf{J}$:\n$$ \\begin{Bmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{Bmatrix} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} \\begin{Bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{Bmatrix} = \\mathbf{J} \\begin{Bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{Bmatrix} $$\nThe components of $\\mathbf{J}$ are found by differentiating the mapping equations:\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\quad J_{12} = \\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i$$\n$$J_{21} = \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} x_i, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} y_i$$\nThe required physical derivatives are obtained by inverting the relationship: $\\nabla_x f = \\mathbf{J}^{-1} \\nabla_\\xi f$.\n\nThird, we construct the strain-displacement matrix, $\\mathbf{B}$. The displacement field $\\mathbf{u} = (u_x, u_y)$ is interpolated similarly to the geometry: $u_x = \\sum N_i u_{xi}$ and $u_y = \\sum N_i u_{yi}$, where $\\mathbf{d} = [u_{x1}, u_{y1}, \\dots, u_{x4}, u_{y4}]^\\top$ is the vector of nodal displacements. For small-strain kinematics, the strain vector in Voigt notation (using engineering shear strain) is $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top$, where:\n$$\\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}$$\nSubstituting the interpolated displacements, we obtain the relationship $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$. The matrix $\\mathbf{B}$ is partitioned as $\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]$, where each sub-matrix $\\mathbf{B}_i$ relates strain to the displacements of node $i$:\n$$ \\mathbf{B}_i(\\xi, \\eta) = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{bmatrix} $$\nThe spatial derivatives of the shape functions, $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$, are computed at each point $(\\xi, \\eta)$ using the inverse Jacobian:\n$$ \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1}(\\xi, \\eta) \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} $$\n\nFourth, we assemble the element stiffness matrix $\\mathbf{K}$. From the principle of virtual work, $\\mathbf{K}$ is given by the integral over the element volume $V_e$:\n$$ \\mathbf{K} = \\int_{V_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, dV $$\nFor a two-dimensional element of constant thickness $t$, this becomes an area integral, which is transformed to the parent domain:\n$$ \\mathbf{K} = t \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}(\\xi, \\eta)^\\top \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}(\\xi, \\eta)) \\, d\\xi d\\eta $$\nThe material's constitutive behavior is described by the symmetric matrix $\\mathbf{D}$. For plane strain, it is:\n$$ \\mathbf{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{bmatrix} $$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. The integral is evaluated numerically using $2 \\times 2$ Gaussian quadrature. The quadrature points are $(\\xi_k, \\eta_k) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$, and all associated weights $w_k$ are $1$. The stiffness matrix is thus the sum:\n$$ \\mathbf{K} = t \\sum_{k=1}^{4} w_k \\mathbf{B}(\\xi_k, \\eta_k)^\\top \\mathbf{D} \\mathbf{B}(\\xi_k, \\eta_k) \\det(\\mathbf{J}(\\xi_k, \\eta_k)) $$\n\nFinally, we address the symmetry of $\\mathbf{K}$. The integrand, let's call it $\\mathbf{C}(\\xi, \\eta) = \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}$, is symmetric because $\\mathbf{D}$ is symmetric: $\\mathbf{C}^\\top = (\\mathbf{B}^\\top \\mathbf{D} \\mathbf{B})^\\top = \\mathbf{B}^\\top \\mathbf{D}^\\top (\\mathbf{B}^\\top)^\\top = \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} = \\mathbf{C}$. Since $\\mathbf{K}$ is a weighted sum of these symmetric matrices (where the weights are the scalar product of thickness, quadrature weight, and the Jacobian determinant), $\\mathbf{K}$ must also be symmetric: $\\mathbf{K} = \\mathbf{K}^\\top$. The provided task is to verify this property numerically. Due to floating-point arithmetic, the computed matrix $\\mathbf{K}$ might not be exactly equal to its transpose $\\mathbf{K}^\\top$. The verification must therefore check that the difference $\\mathbf{K} - \\mathbf{K}^\\top$ is zero within a small, strict numerical tolerance that accounts for machine precision errors. We will check if `np.allclose(K, K.T)` holds true, using an absolute tolerance that scales with the magnitude of the matrix entries, ensuring a rigorous yet practical test.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stiffness_matrix(nodes, E, nu, t):\n    \"\"\"\n    Computes the 8x8 stiffness matrix for a 4-node isoparametric\n    quadrilateral element under plane strain conditions.\n\n    Args:\n        nodes (np.ndarray): A 4x2 array of nodal coordinates, ordered counter-clockwise.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        t (float): Element thickness.\n\n    Returns:\n        np.ndarray: The 8x8 element stiffness matrix K.\n    \"\"\"\n    # Define the constitutive matrix D for plane strain\n    D_factor = E / ((1 + nu) * (1 - 2 * nu))\n    D = D_factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2.]\n    ])\n\n    # 2x2 Gaussian quadrature points and weights\n    # For a 2x2 scheme in [-1, 1], all weights are 1.0.\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-gp_val, -gp_val),\n        (gp_val, -gp_val),\n        (gp_val, gp_val),\n        (-gp_val, gp_val)\n    ]\n    \n    # Initialize the 8x8 element stiffness matrix\n    K = np.zeros((8, 8))\n\n    # Loop over the Gaussian quadrature points\n    for xi, eta in gauss_points:\n        # Derivatives of shape functions with respect to natural coordinates (xi, eta)\n        dNdxi_vec = 0.25 * np.array([\n            -(1 - eta),  # dN1/dxi\n            (1 - eta),   # dN2/dxi\n            (1 + eta),   # dN3/dxi\n            -(1 + eta)   # dN4/dxi\n        ])\n        \n        dNdeta_vec = 0.25 * np.array([\n            -(1 - xi),   # dN1/deta\n            -(1 + xi),   # dN2/deta\n            (1 + xi),    # dN3/deta\n            (1 - xi)     # dN4/deta\n        ])\n        \n        # Calculate the Jacobian matrix J\n        # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dNdxi_vec, nodes[:, 0])\n        J[0, 1] = np.dot(dNdxi_vec, nodes[:, 1])\n        J[1, 0] = np.dot(dNdeta_vec, nodes[:, 0])\n        J[1, 1] = np.dot(dNdeta_vec, nodes[:, 1])\n        \n        detJ = np.linalg.det(J)\n        \n        # The Jacobian determinant must be positive for a valid mapping.\n        if detJ <= 0:\n            raise ValueError(\"Jacobian determinant is non-positive. Element is distorted.\")\n        \n        invJ = np.linalg.inv(J)\n        \n        # Initialize the strain-displacement matrix B (3x8)\n        B = np.zeros((3, 8))\n        for i in range(4):\n            # Combine the derivatives for node i\n            dNi_dxieta = np.array([dNdxi_vec[i], dNdeta_vec[i]])\n            \n            # Transform derivatives to physical coordinates (x, y)\n            dNi_dxy = invJ @ dNi_dxieta\n            dN_dx = dNi_dxy[0]\n            dN_dy = dNi_dxy[1]\n            \n            # Populate the B matrix for node i (columns 2*i and 2*i+1)\n            B[0, 2 * i] = dN_dx\n            B[1, 2 * i + 1] = dN_dy\n            B[2, 2 * i] = dN_dy\n            B[2, 2 * i + 1] = dN_dx\n\n        # Accumulate the stiffness matrix contribution from the current Gauss point\n        # The quadrature weight is 1.0.\n        K += B.T @ D @ B * detJ * t\n        \n    return K\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and verify the symmetry\n    of the computed element stiffness matrices.\n    \"\"\"\n    test_cases = [\n        {'nodes': np.array([(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)]), \n         'E': 70e9, 'nu': 0.33, 't': 0.1},\n        {'nodes': np.array([(0.0, 0.0), (1.2, 0.0), (1.2, 1.0), (0.2, 1.0)]), \n         'E': 210e9, 'nu': 0.3, 't': 0.05},\n        {'nodes': np.array([(0.0, 0.0), (1.0, 0.0), (0.9, 0.8), (-0.1, 0.9)]), \n         'E': 120e9, 'nu': 0.25, 't': 0.2},\n        {'nodes': np.array([(0.0, 0.0), (1.7320508075688772, 1.0), \n                             (1.2320508075688772, 1.8660254037844386), \n                             (-0.5, 0.8660254037844386)]), \n         'E': 1e9, 'nu': 0.4, 't': 0.005}\n    ]\n    \n    results = []\n    for case in test_cases:\n        K = get_stiffness_matrix(case['nodes'], case['E'], case['nu'], case['t'])\n        \n        # Symmetry Check: Verify that K is equal to its transpose K.T within a\n        # strict tolerance to account for floating-point inaccuracies.\n        # The absolute tolerance is scaled by the maximum absolute value in K,\n        # as suggested by the prompt \"based on the magnitude of K\".\n        max_abs_K = np.max(np.abs(K))\n        \n        if max_abs_K == 0.0:\n            # For a zero matrix, it is symmetric, and atol can be 0.\n            dynamic_atol = 0.0\n        else:\n            # Define a strict absolute tolerance that scales with the matrix magnitude.\n            # A factor of 1e-12 is robust for double precision arithmetic.\n            dynamic_atol = 1e-12 * max_abs_K\n            \n        is_symmetric = np.allclose(K, K.T, rtol=0, atol=dynamic_atol)\n        results.append(is_symmetric)\n        \n    # Print the results in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}