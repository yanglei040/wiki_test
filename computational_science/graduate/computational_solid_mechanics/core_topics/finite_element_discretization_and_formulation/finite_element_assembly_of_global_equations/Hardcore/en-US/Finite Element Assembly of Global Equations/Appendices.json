{
    "hands_on_practices": [
        {
            "introduction": "Before assembling a global stiffness matrix, its structure can be predicted from the properties of the underlying basis functions. This practice moves beyond numerical integration to explore the topological heart of the assembly process. By analyzing an advanced isogeometric analysis (IGA) framework with tensor-product B-splines, you will learn to predict critical matrix properties like bandwidth and sparsity, a foundational skill for designing efficient solvers and understanding the computational cost of different discretizations .",
            "id": "3565259",
            "problem": "You are to implement an assembly-aware analysis program for isogeometric analysis (IGA) with tensor-product B-spline bases in the context of computational solid mechanics. The goal is to design a global degree-of-freedom mapping to exploit the tensor structure and to predict the sparsity envelope of the global stiffness matrix that would arise from a standard elliptic bilinear form as in linear elasticity, without performing any numerical integration. Your program must compute and compare structural properties that follow from the locality of B-spline basis functions with $C^{p-1}$ continuity.\n\nStart from the following well-tested modeling base. For small-strain elastostatics in the absence of body forces, conservation of linear momentum reduces to the homogeneous strong form where the divergence of the Cauchy stress tensor vanishes. In isogeometric Galerkin discretizations, using a scalar proxy for the purpose of sparsity analysis, the weak form of the Poisson model problem is to find $u \\in V$ such that\n$$\na(u,v) = \\ell(v) \\quad \\text{for all } v \\in V,\n$$\nwhere\n$$\na(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega\n\\quad \\text{and} \\quad\n\\ell(v) = \\int_{\\Omega} f\\, v \\, \\mathrm{d}\\Omega,\n$$\nwith $V$ a suitable Sobolev space. Under a Galerkin discretization with tensor-product B-spline basis functions of degree $p_d$ along each parametric direction $d$, with open uniform knot vectors yielding $C^{p_d-1}$ continuity, the global stiffness matrix inherits a sparsity pattern that is solely determined by the overlap of basis function supports.\n\nFacts to use:\n- A univariate B-spline basis function of polynomial degree $p$ has compact support spanning $p+1$ consecutive knot spans. In a uniform open knot vector, the basis exhibits $C^{p-1}$ continuity in the interior, ensuring that each basis function overlaps with up to $p$ neighbors on each side.\n- Two basis functions interact (yield a nonzero entry in the assembled stiffness matrix) if and only if their supports overlap in every parametric direction; for tensor-product bases, this condition factors across dimensions.\n\nDefine a tensor-product grid with $D$ parametric dimensions. Let $N_d$ be the number of basis functions (degrees of freedom) in dimension $d$, and let $p_d$ be the B-spline degree in dimension $d$. Index basis functions by the multi-index $\\boldsymbol{i} = (i_0,\\ldots,i_{D-1})$ with $0 \\le i_d \\le N_d - 1$. Use a lexicographic global mapping with stride factors $s_0 = 1$ and $s_d = \\prod_{k=0}^{d-1} N_k$ for $d \\ge 1$, i.e.,\n$$\nI(\\boldsymbol{i}) = \\sum_{d=0}^{D-1} i_d \\, s_d,\n$$\nwhich maps each multi-index to a single global index $I \\in \\{0,\\ldots,\\prod_{d=0}^{D-1} N_d - 1\\}$.\n\nUsing only the locality property of B-splines:\n- Two basis functions with indices $\\boldsymbol{i}$ and $\\boldsymbol{j}$ interact in the assembled matrix if and only if $|i_d - j_d| \\le p_d$ for all $d$. This defines a tensor-product interaction stencil of size $\\prod_{d=0}^{D-1} (2 p_d + 1)$ for interior basis functions, with reductions near boundaries.\n- The set of nonzero column indices in row $I(\\boldsymbol{i})$ is the image of the discrete box $\\{\\boldsymbol{j} : |i_d - j_d| \\le p_d \\ \\forall d\\}$ under $I(\\cdot)$ restricted to valid $0 \\le j_d \\le N_d - 1$.\n\nYour tasks:\n1. Implement the global index mapping $I(\\boldsymbol{i})$ and its inverse using the stride factors, and a procedure that constructs, for each global degree of freedom, the set of interacting degrees of freedom implied by the tensor-product support overlaps.\n2. Derive and implement a formula for the predicted semi-bandwidth (half-bandwidth) of the global stiffness matrix under the lexicographic mapping, defined as\n$$\n\\beta_{\\text{pred}} = \\min\\left( \\sum_{d=0}^{D-1} s_d \\, p_d, \\ \\prod_{d=0}^{D-1} N_d - 1 \\right),\n$$\nwhich is the largest possible absolute column-to-row index difference generated by the interaction stencil, clipped by the matrix size.\n3. Derive and implement a formula for the predicted maximum number of nonzeros per row,\n$$\n\\nu_{\\text{pred}} = \\prod_{d=0}^{D-1} \\min\\left( N_d, \\ 2 p_d + 1 \\right),\n$$\nwhich accounts for boundary reductions when $2 p_d + 1 > N_d$.\n4. Compute the actual semi-bandwidth $\\beta_{\\text{act}}$ from the constructed interaction sets, defined as the maximum absolute index difference $|J - I|$ over all nonzero pairs $(I,J)$ including the diagonal, and compute the actual average number of nonzeros per row,\n$$\n\\overline{\\nu}_{\\text{act}} = \\frac{1}{N} \\sum_{I=0}^{N-1} \\big|\\mathcal{N}(I)\\big|,\n$$\nwhere $N = \\prod_{d=0}^{D-1} N_d$ and $\\mathcal{N}(I)$ is the interaction set for row $I$ including the diagonal.\n\nYour program must implement this analysis for the following test suite, each specified by the list of basis counts $\\{N_d\\}$ and degrees $\\{p_d\\}$:\n- Test case A ($1\\text{D}$ happy path): $D = 1$, $N_0 = 10$, $p_0 = 3$.\n- Test case B ($2\\text{D}$ mixed degrees): $D = 2$, $(N_0,N_1) = (8,5)$, $(p_0,p_1) = (2,1)$.\n- Test case C ($2\\text{D}$ boundary-dominated): $D = 2$, $(N_0,N_1) = (4,4)$, $(p_0,p_1) = (3,3)$.\n- Test case D ($3\\text{D}$ anisotropic degrees): $D = 3$, $(N_0,N_1,N_2) = (6,4,3)$, $(p_0,p_1,p_2) = (1,2,1)$.\n\nFor each test case, your program must output a list with the following five entries:\n- The total number of degrees of freedom $N = \\prod_{d=0}^{D-1} N_d$ as an integer.\n- The predicted semi-bandwidth $\\beta_{\\text{pred}}$ as an integer.\n- The actual semi-bandwidth $\\beta_{\\text{act}}$ as an integer.\n- The predicted maximum number of nonzeros per row $\\nu_{\\text{pred}}$ as an integer.\n- The actual average number of nonzeros per row $\\overline{\\nu}_{\\text{act}}$ as a float rounded to six decimal places.\n\nFinal output format: Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, where each element is itself the comma-separated list described above. For example, a valid output format is\n```\n[[N_1,\\beta_{\\text{pred},1},\\beta_{\\text{act},1},\\nu_{\\text{pred},1},\\overline{\\nu}_{\\text{act},1}],\\ldots]\n```\nNo physical units are involved in the output; all quantities are dimensionless counts.",
            "solution": "The problem requires an analysis of the sparsity structure of a global stiffness matrix arising from an isogeometric analysis (IGA) discretization. The analysis is based on abstract properties of tensor-product B-spline basis functions rather than on numerical integration. The provided inputs for each test case are the number of basis functions $N_d$ and the polynomial degree $p_d$ for each parametric dimension $d \\in \\{0, \\ldots, D-1\\}$, where $D$ is the number of parametric dimensions.\n\nFirst, we establish the total number of degrees of freedom (DoFs), $N$, which is the product of the number of basis functions in each dimension:\n$$\nN = \\prod_{d=0}^{D-1} N_d\n$$\n\nThe core of the problem lies in the mapping between a multi-index $\\boldsymbol{i} = (i_0, \\ldots, i_{D-1})$ that identifies a basis function on the $D$-dimensional parametric grid, and a single global index $I$ that corresponds to a row/column in the global stiffness matrix. The problem specifies a lexicographic ordering, for which the mapping is:\n$$\nI(\\boldsymbol{i}) = \\sum_{d=0}^{D-1} i_d \\, s_d\n$$\nThe stride factors $s_d$ are defined as $s_0 = 1$ and $s_d = \\prod_{k=0}^{d-1} N_k$ for $d \\ge 1$.\n\nThe sparsity pattern is determined by the interaction rule: two basis functions, indexed by $\\boldsymbol{i}$ and $\\boldsymbol{j}$, have overlapping support and thus contribute a non-zero entry to the stiffness matrix if and only if their index separation is bounded by the polynomial degree in each dimension:\n$$\n|i_d - j_d| \\le p_d \\quad \\text{for all } d=0, \\ldots, D-1\n$$\nThis rule defines, for each global DoF $I(\\boldsymbol{i})$, a set of interacting DoFs $\\mathcal{N}(I) = \\{ J(\\boldsymbol{j}) \\mid |i_d - j_d| \\le p_d \\ \\forall d \\}$. When constructing this set, the indices $j_d$ must also be valid, i.e., $0 \\le j_d \\le N_d - 1$.\n\nWith this framework, we compute four key structural properties for each test case:\n\n1.  **Predicted Semi-Bandwidth ($\\beta_{\\text{pred}}$)**: This is the maximum expected difference between interacting indices, defined by the formula $\\beta_{\\text{pred}} = \\min\\left( \\sum_{d=0}^{D-1} s_d \\, p_d, \\ N - 1 \\right)$. This formula represents the largest possible jump $J-I$ created by the interaction stencil under lexicographic ordering, capped by the maximum possible index difference in a matrix of size $N \\times N$.\n\n2.  **Predicted Maximum Nonzeros per Row ($\\nu_{\\text{pred}}$)**: This is the size of the interaction stencil for an \"interior\" basis function, where boundary effects are absent. In each dimension $d$, an interior function interacts with $2p_d+1$ other functions (including itself). If the total number of functions $N_d$ is smaller than this, the interaction is limited to all $N_d$ functions. The total number of interactions is the product over all dimensions: $\\nu_{\\text{pred}} = \\prod_{d=0}^{D-1} \\min\\left( N_d, \\ 2 p_d + 1 \\right)$.\n\n3.  **Actual Semi-Bandwidth ($\\beta_{\\text{act}}$)**: To compute this, we must explicitly generate the interaction set $\\mathcal{N}(I)$ for every DoF $I \\in \\{0, \\ldots, N-1\\}$. This is accomplished by first converting the global index $I$ to its multi-index $\\boldsymbol{i}$, then generating all valid neighboring multi-indices $\\boldsymbol{j}$ that satisfy the interaction rule, and finally converting them back to global indices $J$. The actual semi-bandwidth is then the maximum observed value of $|J-I|$ over all $I$ and all $J \\in \\mathcal{N}(I)$.\n\n4.  **Actual Average Nonzeros per Row ($\\overline{\\nu}_{\\text{act}}$)**: Using the same generated interaction sets $\\mathcal{N}(I)$, we sum their sizes and divide by the total number of DoFs to find the average:\n$$\n\\overline{\\nu}_{\\text{act}} = \\frac{1}{N} \\sum_{I=0}^{N-1} |\\mathcal{N}(I)|\n$$\n\nThe implementation proceeds by iterating through each test case. For each, it first computes the predicted metrics $\\beta_{\\text{pred}}$ and $\\nu_{\\text{pred}}$ using their respective formulas. Then, it programmatically loops through every global index $I$ from $0$ to $N-1$, determines the full set of interacting indices $\\{J\\}$, and updates the running values for the actual semi-bandwidth and the total number of nonzeros, which are then used to find $\\beta_{\\text{act}}$ and $\\overline{\\nu}_{\\text{act}}$. The generation of the tensor-product interaction stencil for each DoF is handled efficiently using Python's `itertools.product`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Computes sparsity metrics for IGA stiffness matrices based on B-spline properties.\n    \"\"\"\n    test_cases = [\n        {'N_dims': [10], 'p_dims': [3]},               # Test case A\n        {'N_dims': [8, 5], 'p_dims': [2, 1]},         # Test case B\n        {'N_dims': [4, 4], 'p_dims': [3, 3]},         # Test case C\n        {'N_dims': [6, 4, 3], 'p_dims': [1, 2, 1]},     # Test case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        all_results.append(compute_metrics(case['N_dims'], case['p_dims']))\n\n    # Format the final output string as per the problem specification.\n    output_parts = []\n    for r in all_results:\n        # Separate integer parts from the final float part for formatting\n        int_parts = [str(val) for val in r[:-1]]\n        float_part = f\"{r[-1]:.6f}\"\n        \n        # Combine parts into the format [val1,val2,...,val_float]\n        formatted_r = f\"[{','.join(int_parts)},{float_part}]\"\n        output_parts.append(formatted_r)\n    \n    # Join all case results into the final [[...],[...],...] format\n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\ndef compute_metrics(N_dims, p_dims):\n    \"\"\"\n    Analyzes a single test case and computes the five required metrics.\n    \n    Args:\n        N_dims (list[int]): List of basis counts per dimension.\n        p_dims (list[int]): List of B-spline degrees per dimension.\n\n    Returns:\n        list: A list containing [N, beta_pred, beta_act, nu_pred, avg_nu_act].\n    \"\"\"\n    D = len(N_dims)\n    N = int(np.prod(N_dims))\n    p_dims_arr = np.array(p_dims)\n\n    # Calculate stride factors for lexicographic mapping\n    if D == 1:\n        strides = np.array([1], dtype=int)\n    else:\n        strides = np.concatenate(([1], np.cumprod(N_dims[:-1]))).astype(int)\n\n    # 1. Predicted semi-bandwidth (beta_pred)\n    beta_pred = int(min(np.sum(strides * p_dims_arr), N - 1))\n\n    # 2. Predicted maximum number of nonzeros per row (nu_pred)\n    nnz_per_dim = [min(N_dims[d], 2 * p_dims[d] + 1) for d in range(D)]\n    nu_pred = int(np.prod(nnz_per_dim))\n\n    # 3  4. Actual semi-bandwidth (beta_act) and average nonzeros per row (avg_nu_act)\n    actual_bandwidth = 0\n    total_nnz = 0\n\n    for I in range(N):\n        # Convert the global index I to its multi-index representation\n        i_multi = []\n        temp_I = I\n        for d in range(D - 1, -1, -1):\n            i_d = temp_I // strides[d]\n            temp_I %= strides[d]\n            i_multi.append(i_d)\n        i_multi.reverse()\n\n        # Generate interaction ranges for each dimension based on the interaction rule\n        j_ranges = []\n        for d in range(D):\n            i_d = i_multi[d]\n            p_d = p_dims[d]\n            N_d = N_dims[d]\n            j_min = max(0, i_d - p_d)\n            j_max = min(N_d - 1, i_d + p_d)\n            j_ranges.append(range(j_min, j_max + 1))\n        \n        row_nnz = 0\n        # Iterate over all interacting multi-indices using itertools.product\n        for j_multi in itertools.product(*j_ranges):\n            # Convert interacting multi-index back to global index J\n            J = int(np.sum(np.array(j_multi) * strides))\n            \n            # Update actual semi-bandwidth\n            actual_bandwidth = max(actual_bandwidth, abs(J - I))\n            row_nnz += 1\n        \n        total_nnz += row_nnz\n\n    avg_nnz_actual = total_nnz / N if N > 0 else 0.0\n\n    return [\n        N,\n        beta_pred,\n        actual_bandwidth,\n        nu_pred,\n        avg_nnz_actual\n    ]\n\n# Execute the main function to produce the result.\nsolve()\n```"
        },
        {
            "introduction": "Practical finite element models frequently require connecting subdomains with non-matching meshes, a task that cannot be handled by standard element assembly alone. This exercise focuses on enforcing kinematic continuity across such interfaces using multipoint constraints (MPCs). You will implement and contrast two canonical approaches—constraint elimination and the use of Lagrange multipliers—to understand their profound impact on the structure, symmetry, and conditioning of the final global system .",
            "id": "3565247",
            "problem": "You are tasked to implement the assembly of a global system of equations for a one-dimensional linear elastic bar with nonmatching meshes across an interface, and to enforce continuity at the interface using Multipoint Constraints (MPCs). You must implement two approaches: constraint elimination via a linear change of variables, and enforcement via Lagrange multipliers. You will compare the conditioning and symmetry of the resulting system matrices, and verify the constraint satisfaction. The final output must be produced by a complete, runnable program.\n\nThe physical setting is a one-dimensional bar occupying the interval $[0,L]$, with $L$ given in meters. The bar is uniform with Young’s modulus $E$ and cross-sectional area $A$ (both constant, with $E$ in Pascals and $A$ in $\\mathrm{m}^2$). There is no body force. A terminal traction $T$ (in Newtons) is applied at $x=L$. The left end at $x=0$ is clamped with essential boundary condition $u(0)=0$, where $u(x)$ denotes the axial displacement in meters.\n\nYou will build two independent finite element meshes on overlapping subdomains that meet at a single interface location $x=\\xi$, but do not share nodes at that interface. The left submesh spans $[0,\\xi]$ with nodes $x_{0}^{L}, x_{1}^{L}, \\dots, x_{n_{L}-1}^{L}$ such that $x_{0}^{L}=0$ and $x_{n_{L}-1}^{L}\\xi$. The right submesh spans $[\\xi,L]$ with nodes $x_{0}^{R}, x_{1}^{R}, \\dots, x_{n_{R}-1}^{R}$ such that $x_{0}^{R}=\\xi$ and $x_{n_{R}-1}^{R}=L$. The left and right meshes are assembled independently into subdomain stiffness matrices and subdomain load vectors using linear two-node elements. The global system is block diagonal in the absence of constraints. The interface continuity constraint is enforced by tying the right interface degree of freedom (the \"slave\") to an interpolation of two adjacent left side degrees of freedom (the \"masters\") bracketing $x=\\xi$, as specified below. This is a multipoint constraint because the slave displacement equals a linear combination of multiple masters.\n\nYou must derive and implement both approaches starting from first principles:\n\n1. Fundamental base: The total potential energy for one-dimensional linear elasticity is\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L),\n$$\nwith essential boundary condition $u(0)=0$. The weak form arises from the Principle of Minimum Potential Energy: find $u$ minimizing $\\Pi(u)$ over admissible displacements satisfying the essential boundary condition. For the Finite Element Method (FEM), use linear shape functions over each element and assemble the global stiffness matrix by summing elemental contributions. The elemental stiffness for an interval of length $h$ is\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix},\n$$\nand the only external load is the terminal traction $T$ applied at $x=L$, contributing to the rightmost degree of freedom of the right submesh.\n\n2. Multipoint constraint definition: Let $x=\\xi$ lie strictly inside a left mesh element with nodes at $x_{i}^{L}$ and $x_{i+1}^{L}$, or coincide with a left mesh node $x_{i}^{L}$, for some index $i$. The right interface node is $x_{0}^{R}=\\xi$ with unknown displacement $u_{0}^{R}$. Define interpolation weights from left masters such that\n$$\nu_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L},\n$$\nwhere, for the strict interior case,\n$$\nw_{1} = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}, \\quad\nw_{2} = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}},\n$$\nand for the coincidence case $\\xi = x_{i}^{L}$, take $w_{1}=1$ and $w_{2}=0$. This constraint can be written as\n$$\n\\mathbf{C}\\, \\mathbf{x} = 0,\n$$\nwhere $\\mathbf{x}$ stacks the left and right degrees of freedom after imposing $u(0)=0$ by elimination, and $\\mathbf{C}$ has the appropriate coefficients.\n\n3. Constraint elimination by change of variables: Introduce a linear transformation $\\mathbf{x} = \\mathbf{T} \\mathbf{y}$ that eliminates the slave variable in favor of the masters, with $\\mathbf{y}$ the reduced set of independent variables. Derive and assemble the modified reduced system\n$$\n\\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{K} \\mathbf{T}, \\quad\n\\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{f},\n$$\nthen solve for $\\mathbf{y}$ and recover $\\mathbf{x}$. Verify that the MPC is satisfied by computing the residual $r_{\\mathrm{elim}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$ in meters.\n\n4. Lagrange multipliers: Assemble the saddle-point system with the Lagrange multiplier (LM),\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix},\n$$\nand solve for $\\mathbf{x}$ and $\\lambda$. Verify the MPC residual $r_{\\mathrm{LM}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$ in meters.\n\nYou must compute for each approach:\n- The matrix condition number in the $2$-norm for $\\mathbf{K}_{\\mathrm{elim}}$ and for the augmented saddle-point matrix, quantified as\n$$\n\\kappa_{2}(\\mathbf{A}) = \\frac{\\sigma_{\\max}(\\mathbf{A})}{\\sigma_{\\min}(\\mathbf{A})},\n$$\nwhere $\\sigma_{\\max}$ and $\\sigma_{\\min}$ are the largest and smallest singular values of $\\mathbf{A}$.\n- A boolean indicating whether each matrix is symmetric, by checking if the maximum absolute entry of $\\mathbf{A}-\\mathbf{A}^{\\top}$ is less than a tolerance (use a numerical tolerance of $10^{-12}$).\n\nUnits:\n- Displacements $u$ and residuals $r_{\\mathrm{elim}}$ and $r_{\\mathrm{LM}}$ must be in meters.\n- Material parameters $E$ in Pascals, $A$ in $\\mathrm{m}^{2}$, traction $T$ in Newtons, and lengths in meters.\n- Condition numbers are dimensionless.\n\nImplement the above for the following test suite, each defined by $(E,A,T,L,\\xi,\\text{left nodes},\\text{right nodes})$:\n- Test case $1$ (happy path, nonmatching meshes, interior interpolation):\n  - $E = 2.10 \\times 10^{11}$, $A = 1.0 \\times 10^{-4}$, $T = 1.0 \\times 10^{3}$, $L = 1.0$, $\\xi = 0.45$,\n  - left nodes: $[0.0, 0.3, 0.6]$,\n  - right nodes: $[0.45, 0.75, 1.0]$.\n- Test case $2$ (boundary interpolation, $\\xi$ coincides with a left node):\n  - $E = 1.90 \\times 10^{11}$, $A = 1.2 \\times 10^{-4}$, $T = 5.0 \\times 10^{2}$, $L = 1.0$, $\\xi = 0.5$,\n  - left nodes: $[0.0, 0.5, 0.8]$,\n  - right nodes: $[0.5, 0.9, 1.0]$.\n- Test case $3$ (ill-conditioning via a very small left element near the interface):\n  - $E = 2.00 \\times 10^{11}$, $A = 0.8 \\times 10^{-4}$, $T = 8.0 \\times 10^{2}$, $L = 1.0$, $\\xi = 0.55$,\n  - left nodes: $[0.0, 0.49, 0.49001, 0.7]$,\n  - right nodes: $[0.55, 0.8, 1.0]$.\n\nAlgorithmic requirements:\n- Assemble subdomain stiffness matrices using the linear two-node elemental stiffness formula and standard finite element assembly from the weak form, without using shortcut formulas beyond the elemental form given above.\n- Enforce $u(0)=0$ by elimination at the global assembly level before imposing MPCs.\n- For constraint elimination, construct the explicit transformation matrix $\\mathbf{T}$ implementing the relation $u_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L}$ with appropriate mapping of degrees of freedom to reduced variables.\n- For Lagrange multipliers, assemble the augmented saddle-point system as specified.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a list with six entries:\n$[\\kappa_{2}(\\mathbf{K}_{\\mathrm{elim}}), \\kappa_{2}(\\mathbf{K}_{\\mathrm{aug}}), \\text{is\\_sym\\_elim}, \\text{is\\_sym\\_aug}, r_{\\mathrm{elim}}, r_{\\mathrm{LM}}]$,\nwhere $\\text{is\\_sym\\_elim}$ and $\\text{is\\_sym\\_aug}$ are booleans. Use floating-point numbers rounded to six decimal places for the condition numbers and to twelve decimal places for the residuals. The final output is therefore a list of three lists, one per test case, for example $[[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The present task is to implement and analyze two methods for enforcing continuity at a non-conforming interface between two one-dimensional finite element meshes: constraint elimination and Lagrange multipliers. The analysis involves assembling the system matrices for each method, solving the resulting linear systems, and evaluating the matrix properties (condition number, symmetry) and constraint satisfaction.\n\nThe physical system is a one-dimensional linear elastic bar of length $L$, Young's modulus $E$, and cross-sectional area $A$. It is fixed at $x=0$ ($u(0)=0$) and subjected to a point traction $T$ at $x=L$. The total potential energy functional is given by\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L)\n$$\nThe finite element method (FEM) discretizes this problem. We use two-node linear elements. The stiffness matrix for an element of length $h$ is\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix}\n$$\nThe domain is discretized into two submeshes that meet at an interface $x=\\xi$ without sharing nodes. A left mesh covers the domain from $x=0$ up to and beyond $\\xi$, and a right mesh starts at $x=\\xi$ and extends to $x=L$. This results in an unconstrained system of equations that is block-diagonal, of the form $\\mathbf{K}\\mathbf{x} = \\mathbf{f}$, where $\\mathbf{K} = \\text{diag}(\\mathbf{K}^L, \\mathbf{K}^R)$, after enforcing the essential boundary condition $u(0)=0$ by removing the corresponding degree of freedom (DOF).\n\nContinuity at the interface $x=\\xi$ is enforced via a Multipoint Constraint (MPC). The displacement of the first node of the right mesh, $u_0^R$ at $x_0^R = \\xi$, is constrained to be an interpolation of the displacements of the two nodes from the left mesh, $u_i^L$ and $u_{i+1}^L$, that bracket $\\xi$. The constraint equation is\n$$\nu_0^R = w_1 u_i^L + w_2 u_{i+1}^L\n$$\nwhere $w_1 = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}$ and $w_2 = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}}$ are linear interpolation weights. In the case where $\\xi$ coincides with a left-mesh node $x_i^L$, the weights are $w_1=1$ and $w_2=0$, effectively tying the slave DOF to a single master. This MPC can be expressed in matrix form as $\\mathbf{C}\\mathbf{x} = \\mathbf{0}$, where $\\mathbf{C}$ is a single-row matrix and $\\mathbf{x}$ is the vector of all active DOFs.\n\nWe will now detail the two methods for incorporating this constraint.\n\n**1. Constraint Elimination by Change of Variables**\n\nThis method eliminates the dependent (slave) DOF from the system of equations, resulting in a smaller, dense system expressed only in terms of independent DOFs. We define a linear transformation $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$, where $\\mathbf{y}$ is the reduced vector of independent DOFs and $\\mathbf{T}$ is a transformation matrix. The dimension of $\\mathbf{y}$ is one less than that of $\\mathbf{x}$.\n\nThe vector $\\mathbf{y}$ can be chosen to be the vector $\\mathbf{x}$ with the slave DOF removed. Let the slave DOF be $x_s = u_0^R$ and the master DOFs be $x_{m1} = u_i^L$ and $x_{m2} = u_{i+1}^L$. The constraint is $x_s = w_1 x_{m1} + w_2 x_{m2}$. The transformation matrix $\\mathbf{T}$ of size $N \\times (N-1)$ (where $N$ is the size of $\\mathbf{x}$) is constructed as follows:\n- The columns of $\\mathbf{T}$ map the independent DOFs in $\\mathbf{y}$ back to the full set of DOFs in $\\mathbf{x}$.\n- For an independent DOF $y_j$ that corresponds to an original DOF $x_k$ (where $k$ is not the slave index), the $j$-th column of $\\mathbf{T}$ will be an elementary vector with a $1$ at position $k$.\n- The row of $\\mathbf{T}$ corresponding to the slave DOF $x_s$ is constructed from the constraint equation. Since the master DOFs $x_{m1}$ and $x_{m2}$ are themselves independent DOFs present in $\\mathbf{y}$ (at some positions $j_{m1}$ and $j_{m2}$), the slave row of $\\mathbf{T}$ will contain entries $w_1$ and $w_2$ at columns $j_{m1}$ and $j_{m2}$, respectively.\n\nSubstituting $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$ into the potential energy functional $\\Pi(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^\\top\\mathbf{K}\\mathbf{x} - \\mathbf{x}^\\top\\mathbf{f}$ yields $\\Pi(\\mathbf{y}) = \\frac{1}{2}(\\mathbf{T}\\mathbf{y})^\\top\\mathbf{K}(\\mathbf{T}\\mathbf{y}) - (\\mathbf{T}\\mathbf{y})^\\top\\mathbf{f}$. Minimizing with respect to $\\mathbf{y}$ gives the reduced system:\n$$\n\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}, \\quad \\text{where} \\quad \\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{K}\\mathbf{T} \\quad \\text{and} \\quad \\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{f}\n$$\nThe original stiffness matrix $\\mathbf{K}$ is symmetric and positive-definite (as the rigid body mode is removed). The transformed matrix $\\mathbf{K}_{\\mathrm{elim}}$ will also be symmetric and positive-definite. After solving for $\\mathbf{y}$, the full displacement vector is recovered via $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$.\n\n**2. Lagrange Multiplier Method**\n\nThis method augments the system of equations by introducing a new variable, the Lagrange multiplier $\\lambda$, which represents the constraint force required to enforce the MPC. The stationary point of the augmented Lagrangian functional $\\mathcal{L}(\\mathbf{x}, \\lambda) = \\Pi(\\mathbf{x}) + \\lambda^\\top(\\mathbf{C}\\mathbf{x})$ is sought. Setting the variations with respect to $\\mathbf{x}$ and $\\lambda$ to zero yields the saddle-point system:\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix}\n$$\nThis augmented system is larger than the original unconstrained system. The augmented matrix, $\\mathbf{K}_{\\mathrm{aug}}$, is symmetric by construction. However, it is not positive-definite due to the zero block on the diagonal, which can lead to higher condition numbers compared to the original definite matrix $\\mathbf{K}$ or the reduced matrix $\\mathbf{K}_{\\mathrm{elim}}$. This method has the advantage of not requiring an explicit construction of a transformation matrix $\\mathbf{T}$, and it directly computes the constraint force (the Lagrange multiplier $\\lambda$).\n\n**Implementation Steps**\nFor each test case, the following procedure is executed:\n1.  **Subdomain Assembly:** For the left and right meshes, assemble the elemental stiffness matrices $k^e$ and sum their contributions into subdomain matrices $\\mathbf{K}^L_{\\text{full}}$ and $\\mathbf{K}^R_{\\text{full}}$.\n2.  **Global Assembly:** Form the block-diagonal unconstrained global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{f}$. Apply the essential boundary condition $u(0)=0$ by removing the first row and column of $\\mathbf{K}^L_{\\text{full}}$. Apply the traction load $T$ to the last entry of the global force vector $\\mathbf{f}$.\n3.  **MPC Definition:** Identify the master DOFs on the left mesh and the slave DOF on the right mesh. Calculate the interpolation weights $w_1, w_2$ and construct the constraint matrix $\\mathbf{C}$.\n4.  **Solve (Elimination):** Construct the transformation matrix $\\mathbf{T}$. Form and solve the reduced system $\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}$. Recover the full solution $\\mathbf{x}_{\\mathrm{elim}}$.\n5.  **Solve (Lagrange Multiplier):** Form and solve the augmented system for the solution vector containing both $\\mathbf{x}_{\\mathrm{LM}}$ and $\\lambda$.\n6.  **Analysis:** For both methods, compute the 2-norm condition number $\\kappa_2$ of the system matrix using its singular values ($\\kappa_2(\\mathbf{A}) = \\sigma_{\\max}/\\sigma_{\\min}$), check for symmetry, and calculate the constraint satisfaction residual $r = \\lVert \\mathbf{C}\\mathbf{x} \\rVert_{\\infty}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_subsystem(nodes, E, A):\n    \"\"\"\n    Assembles the stiffness matrix for a 1D submesh using linear elements.\n    \"\"\"\n    n_nodes = len(nodes)\n    K_sub = np.zeros((n_nodes, n_nodes))\n    \n    for i in range(n_nodes - 1):\n        h = nodes[i+1] - nodes[i]\n        if h = 0:\n            raise ValueError(\"Element length must be positive.\")\n        k_e_val = E * A / h\n        k_e = k_e_val * np.array([[1, -1], [-1, 1]])\n        \n        # Assembly (scatter-add)\n        K_sub[i:i+2, i:i+2] += k_e\n        \n    return K_sub\n\ndef solve_one_case(E, A, T, L, xi, left_nodes, right_nodes):\n    \"\"\"\n    Solves a single test case for the 1D bar problem with non-matching meshes.\n    \"\"\"\n    left_nodes = np.array(left_nodes, dtype=float)\n    right_nodes = np.array(right_nodes, dtype=float)\n\n    # 1. Assemble subdomain systems\n    K_L_full = assemble_subsystem(left_nodes, E, A)\n    K_R_full = assemble_subsystem(right_nodes, E, A)\n\n    # 2. Apply u(0)=0 and assemble global unconstrained system\n    # Eliminate the first DOF of the left mesh\n    K_L = K_L_full[1:, 1:]\n    n_L_active = K_L.shape[0]\n    n_R_active = K_R_full.shape[0]\n    N = n_L_active + n_R_active\n\n    K = np.zeros((N, N))\n    f = np.zeros(N)\n\n    K[:n_L_active, :n_L_active] = K_L\n    K[n_L_active:, n_L_active:] = K_R_full\n    \n    # Apply traction T at x=L (last DOF of the right mesh)\n    f[-1] = T\n\n    # 3. Define the Multipoint Constraint (MPC)\n    # Find master nodes bracketing xi on the left mesh\n    master_idx_i = -1\n    for i in range(len(left_nodes) - 1):\n        if left_nodes[i] = xi = left_nodes[i+1]:\n            master_idx_i = i\n            break\n    if master_idx_i == -1:\n        raise ValueError(\"xi is not within any left mesh element.\")\n\n    # Calculate interpolation weights\n    if np.isclose(xi, left_nodes[master_idx_i]):\n        w1, w2 = 1.0, 0.0\n    else:\n        h_master = left_nodes[master_idx_i+1] - left_nodes[master_idx_i]\n        w1 = (left_nodes[master_idx_i+1] - xi) / h_master\n        w2 = (xi - left_nodes[master_idx_i]) / h_master\n\n    # Identify global indices of slave and master DOFs\n    # Slave: u_0^R, which is the first DOF of the right system\n    idx_slave = n_L_active\n    \n    # Masters: u_i^L and u_{i+1}^L\n    # Remember u(0)=0 is eliminated, so global index for u_k^L is k-1\n    idx_m1 = master_idx_i - 1 if master_idx_i > 0 else -1\n    idx_m2 = master_idx_i # Corresponds to u_{i+1}^L\n\n    # Constraint matrix C for C*x = 0\n    C = np.zeros((1, N))\n    C[0, idx_slave] = 1.0\n    if idx_m1 != -1: # Master u_i^L is an active DOF\n        C[0, idx_m1] -= w1\n    # Master u_{i+1}^L is always an active DOF in our setup\n    C[0, idx_m2] -= w2\n\n    # 4. Method 1: Constraint Elimination\n    T_mat = np.zeros((N, N - 1))\n    \n    # Identity mapping for DOFs before slave\n    T_mat[:idx_slave, :idx_slave] = np.eye(idx_slave)\n    # Identity mapping for DOFs after slave\n    T_mat[idx_slave + 1:, idx_slave:] = np.eye(N - 1 - idx_slave)\n    \n    # Slave row of T\n    # y_j maps to x_j for j  idx_slave\n    # So we can use master indices directly for y\n    if idx_m1 != -1:\n        T_mat[idx_slave, idx_m1] = w1\n    T_mat[idx_slave, idx_m2] = w2\n    \n    K_elim = T_mat.T @ K @ T_mat\n    f_elim = T_mat.T @ f\n    \n    y = np.linalg.solve(K_elim, f_elim)\n    x_elim = T_mat @ y\n    \n    svd_elim = np.linalg.svd(K_elim, compute_uv=False)\n    # Handle potential singularity for ill-conditioned cases\n    kappa_elim = svd_elim[0] / svd_elim[-1] if svd_elim[-1] > 1e-15 else np.inf\n    \n    is_sym_elim = np.max(np.abs(K_elim - K_elim.T))  1e-12\n    r_elim = np.linalg.norm(C @ x_elim, ord=np.inf)\n\n    # 5. Method 2: Lagrange Multipliers\n    K_aug = np.zeros((N + 1, N + 1))\n    K_aug[:N, :N] = K\n    K_aug[:N, N] = C.T.flatten()\n    K_aug[N, :N] = C.flatten()\n\n    f_aug = np.zeros(N + 1)\n    f_aug[:N] = f\n    \n    sol_aug = np.linalg.solve(K_aug, f_aug)\n    x_lm = sol_aug[:N]\n\n    svd_aug = np.linalg.svd(K_aug, compute_uv=False)\n    kappa_aug = svd_aug[0] / svd_aug[-1] if svd_aug[-1] > 1e-15 else np.inf\n\n    is_sym_aug = np.max(np.abs(K_aug - K_aug.T))  1e-12\n    r_lm = np.linalg.norm(C @ x_lm, ord=np.inf)\n\n    return [kappa_elim, kappa_aug, is_sym_elim, is_sym_aug, r_elim, r_lm]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.10e11, 1.0e-4, 1.0e3, 1.0, 0.45, [0.0, 0.3, 0.6], [0.45, 0.75, 1.0]),\n        (1.90e11, 1.2e-4, 5.0e2, 1.0, 0.5, [0.0, 0.5, 0.8], [0.5, 0.9, 1.0]),\n        (2.00e11, 0.8e-4, 8.0e2, 1.0, 0.55, [0.0, 0.49, 0.49001, 0.7], [0.55, 0.8, 1.0])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_cases = []\n    for case_res in all_results:\n        k_elim, k_aug, s_elim, s_aug, r_elim, r_lm = case_res\n        formatted_case_str = (\n            f\"[{k_elim:.6f},\"\n            f\"{k_aug:.6f},\"\n            f\"{str(s_elim).lower()},\"\n            f\"{str(s_aug).lower()},\"\n            f\"{r_elim:.12f},\"\n            f\"{r_lm:.12f}]\"\n        )\n        formatted_cases.append(formatted_case_str)\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In nonlinear finite element analysis, the convergence of the Newton-Raphson solver hinges on the correctness of the assembled tangent matrix. This practice provides a crucial verification workflow, often called a 'Taylor test,' to ensure the consistency between the global residual and its linearization. By implementing this check for a 1D bar with material nonlinearity, you will gain experience with the definitive method for validating that a constitutive model's tangent operator has been correctly derived and integrated into the global system .",
            "id": "3560905",
            "problem": "Design and implement a verification workflow for the algorithmic elastic-plastic consistent tangent operator in a one-dimensional small-strain bar using the Finite Element Method (FEM). The goal is to verify the assembly of the global tangent matrix by comparing the directional finite-difference of the global residual with the linear prediction from the assembled tangent. All quantities are nondimensional.\n\nConsider a one-dimensional bar of length $L$, uniform cross-sectional area $A$, and $n_{e}$ linear two-node elements with nodal coordinates $x \\in [0,L]$. Let $u$ denote the global nodal displacement vector. Impose a Dirichlet boundary condition $u(0)=0$ at the left end, and apply a prescribed traction $T$ at the right end so that the total nodal force at the last node is $F = T A$. For each element $e$, the internal force contribution is\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\sigma(\\varepsilon(x))\\, A \\, \\mathrm{d}x,\n$$\nand the element tangent matrix is\n$$\nK^{\\text{tan}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\mathbb{C}^{\\text{alg}}(\\varepsilon(x))\\, B(x)\\, A \\, \\mathrm{d}x,\n$$\nwhere $B$ is the strain-displacement matrix for a linear bar, $\\varepsilon(x)$ is the axial strain, $\\sigma$ is the Cauchy stress under small strain, and $\\mathbb{C}^{\\text{alg}}$ is the one-dimensional algorithmic consistent tangent modulus supplied by the constitutive update. For a linear two-node element of length $L_e$, $B$ is constant with $B=[-1/L_{e}, \\, 1/L_{e}]$, so the above integrals reduce to element-level closed forms with a single integration point:\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\sigma(\\varepsilon_e) \\, A \\, L_e, \n\\qquad\nK^{\\text{tan}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) \\, B \\, A \\, L_e,\n$$\nwith $\\varepsilon_e = B u_e$ for the element nodal vector $u_e$.\n\nUse a uniaxial elastoplastic material with linear isotropic hardening. Let $E$ be Young’s modulus, $H$ the plastic modulus, $\\sigma_{y0}$ the initial yield stress, $\\varepsilon^{p}$ the plastic strain, and $\\alpha$ the accumulated plastic strain. The yield function is\n$$\n\\phi(\\sigma,\\alpha) \\;=\\; |\\sigma| - \\big(\\sigma_{y0} + H \\alpha\\big) \\;\\le\\; 0.\n$$\nThe flow rule is associative in one dimension with plastic strain rate $\\dot{\\varepsilon}^{p} = \\dot{\\gamma}\\, \\mathrm{sign}(\\sigma)$ and isotropic hardening $\\dot{\\alpha} = \\dot{\\gamma}$, where $\\dot{\\gamma}\\ge 0$ is the plastic multiplier rate. Use small strain kinematics and the additive strain decomposition $\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}$ with $\\sigma = E \\varepsilon^{e}$. Assume a single load increment from the zero state $\\varepsilon^{p}_n=0$, $\\alpha_n=0$ to the current state. Implement a return-mapping update that, for a given strain $\\varepsilon$, returns the updated stress $\\sigma$ and the algorithmic consistent tangent modulus $\\mathbb{C}^{\\text{alg}} = \\partial \\sigma / \\partial \\varepsilon$.\n\nDefine the global residual as\n$$\nR(u) \\;=\\; f^{\\text{int}}(u) - f^{\\text{ext}},\n$$\nwhere $f^{\\text{ext}}$ contains only the applied right-end nodal force $F$ and zeros elsewhere. Let $K(u)$ be the assembled global tangent matrix. To verify $K(u)$, compute a central finite-difference approximation of the directional change of the residual in a given direction $p$ of the free degrees of freedom:\n$$\n\\Delta R_{\\text{FD}} \\;=\\; R\\big(u + \\epsilon\\, p\\big) - R\\big(u - \\epsilon\\, p\\big),\n$$\nand compare against the linear prediction\n$$\n\\Delta R_{\\text{lin}} \\;=\\; K(u)\\, (2 \\epsilon\\, p),\n$$\nfor a small perturbation magnitude $\\epsilon$. Use the relative error\n$e \\;=\\; \\frac{\\left\\|\\Delta R_{\\text{FD}} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max\\!\\big(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau\\big)},$\nwith a tiny regularization $\\tau$ to avoid division by zero.\n\nFor each test case below, construct an equilibrium displacement field $u$ that yields a uniform axial stress $\\sigma = F/A$ while satisfying $u(0)=0$. For a homogeneous bar this corresponds to a uniform strain; for a heterogeneous bar with elementwise $\\sigma_{y0}$, the element strains may differ but the uniform stress is maintained. In all cases, use a single Gauss point per element for integration. Use the following test suite, where $n_{e} = 2$, $A = 1$, and $L = 1$ for all cases, and where elementwise $\\sigma_{y0}$ is specified as a list when heterogeneous:\n\n- Case $1$ (homogeneous elastic): $E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 100$.\n- Case $2$ (homogeneous plastic): $E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 500$.\n- Case $3$ (weakly plastic, near yield): $E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = 250$, $F = 255$.\n- Case $4$ (heterogeneous mixed response): $E = 2\\times 10^{5}$, $H = 10^{3}$, $\\sigma_{y0} = [250,\\, 1000]$, $F = 500$.\n\nImplementation requirements:\n\n- Start from the fundamental definitions above. Implement a one-dimensional return-mapping update for the constitutive model that returns $\\sigma$ and $\\mathbb{C}^{\\text{alg}}$ for a given $\\varepsilon$.\n- Assemble $R(u)$ and $K(u)$ for the free degree of freedom by eliminating the fixed displacement at $x=0$.\n- For each case, construct an equilibrium $u$ with uniform stress $\\sigma = F/A$. For a homogeneous bar, use $u(x) = \\varepsilon\\, x$ with $\\varepsilon$ determined from the constitutive relations. For a heterogeneous bar, enforce uniform $\\sigma$ across elements; for element $e$, compute the element strain $\\varepsilon_e$ consistent with the uniform stress via the constitutive relations and integrate these strains to construct continuous nodal displacements from left to right with $u(0)=0$.\n- Use a fixed perturbation magnitude $\\epsilon = 10^{-8}$ and a deterministic random direction $p$ in the space of free degrees of freedom for each case, with fixed seeds per case to make results reproducible. Use $\\tau = 10^{-14}$.\n- Angle units are not applicable. There are no physical units; all quantities are nondimensional.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the four relative errors in the order of the cases, enclosed in square brackets, for example $[e_1,e_2,e_3,e_4]$, where each $e_i$ is a floating-point number.",
            "solution": "The user requires the design and implementation of a verification procedure for an elasto-plastic algorithmic consistent tangent operator within a one-dimensional Finite Element Method (FEM) framework. The verification is based on comparing a finite-difference approximation of the change in the global residual vector with the prediction from the assembled tangent stiffness matrix.\n\nThe solution will be structured as follows:\n1.  **Constitutive Model Implementation**: A one-dimensional return-mapping algorithm for elastoplasticity with linear isotropic hardening is implemented. This function, given a total strain $\\varepsilon$, returns the updated stress $\\sigma$ and the algorithmic consistent tangent modulus $\\mathbb{C}^{\\text{alg}} = \\partial\\sigma/\\partial\\varepsilon$.\n2.  **Equilibrium State Construction**: For each test case, an equilibrium nodal displacement field $u$ is constructed. This field is designed to produce a state of uniform axial stress $\\sigma = F/A$ throughout the bar, satisfying the Dirichlet boundary condition $u(0)=0$.\n3.  **FEM Assembly**: Functions are created to compute element-level contributions to the global internal force vector and tangent stiffness matrix, and to assemble these into global system quantities. The fixed degree of freedom at $x=0$ is eliminated to work with the system of free degrees of freedom.\n4.  **Verification Workflow**: The core verification logic is implemented. This involves perturbing the equilibrium displacement field, calculating the finite difference of the residual, and comparing it against the linear prediction from the consistent tangent matrix.\n\n### Step 1: Constitutive Model (1D Return-Mapping)\nThe material model is uniaxial elastoplasticity with linear isotropic hardening. We start from a stress-free state ($\\varepsilon^{p}_n=0, \\alpha_n=0$). For a given total strain $\\varepsilon$ at step $n+1$:\n\n1.  **Trial State**: An elastic trial step is assumed. The trial stress is $\\sigma^{\\text{trial}} = E \\varepsilon$. The yield surface is evaluated using the yield stress from the previous step, which is just the initial yield stress $\\sigma_{y0}$ since $\\alpha_n=0$. The trial yield function is $\\phi^{\\text{trial}} = |\\sigma^{\\text{trial}}| - \\sigma_{y0}$.\n\n2.  **Yield Check**:\n    - If $\\phi^{\\text{trial}} \\le 0$, the step is elastic. The stress is $\\sigma = \\sigma^{\\text{trial}}$ and the tangent modulus is the elastic modulus, $\\mathbb{C}^{\\text{alg}} = E$.\n    - If $\\phi^{\\text{trial}}  0$, plastic flow occurs. A return-mapping is required to bring the stress state back to the updated yield surface.\n\n3.  **Plastic Corrector**: For this 1D model, the plastic multiplier increment, $\\Delta\\gamma$, is found from the consistency condition $\\phi_{n+1}=0$. This gives:\n    $$\n    \\Delta\\gamma = \\frac{\\phi^{\\text{trial}}}{E+H} = \\frac{|\\sigma^{\\text{trial}}| - \\sigma_{y0}}{E+H}\n    $$\n    The updated stress is then computed as:\n    $$\n    \\sigma = \\sigma^{\\text{trial}} - E\\,\\Delta\\gamma\\,\\mathrm{sign}(\\sigma^{\\text{trial}})\n    $$\n    The algorithmic consistent tangent modulus, which is the exact derivative of the updated stress with respect to the total strain, is:\n    $$\n    \\mathbb{C}^{\\text{alg}} = \\frac{\\partial\\sigma}{\\partial\\varepsilon} = \\frac{EH}{E+H}\n    $$\nThis function forms the constitutive core of the simulation.\n\n### Step 2: Construction of Equilibrium Displacement Field\nFor the verification, we analyze the system around a known equilibrium state $u$. This state is constructed to produce a uniform stress $\\sigma = F/A$ across all elements. The strain in each element, $\\varepsilon_e$, required to produce this stress is calculated from the inverse constitutive relation:\n- If $|\\sigma| \\le \\sigma_{y0,e}$ (elastic): $\\varepsilon_e = \\sigma/E$.\n- If $|\\sigma|  \\sigma_{y0,e}$ (plastic): The total strain is the sum of elastic and plastic parts, $\\varepsilon_e = \\varepsilon^e + \\varepsilon^p$. The elastic strain is $\\varepsilon^e = \\sigma/E$. The plastic strain magnitude is derived from the hardening law, $|\\varepsilon^p| = \\alpha = (|\\sigma| - \\sigma_{y0,e})/H$. Combining these gives:\n  $$\n  \\varepsilon_e = \\mathrm{sign}(\\sigma) \\left( \\frac{|\\sigma|}{E} + \\frac{|\\sigma| - \\sigma_{y0,e}}{H} \\right)\n  $$\nWith the element strains $\\{\\varepsilon_e\\}$ determined, the nodal displacements are found by integrating the strains from the fixed end $u(0)=0$:\n$$\nu_0 = 0, \\quad u_{i+1} = u_i + \\varepsilon_i L_i\n$$\nwhere $L_i$ is the length of element $i$.\n\n### Step 3: FEM Assembly and System Reduction\nThe analysis is performed on a discretized bar with $n_e=2$ linear two-node elements. The total number of nodes is $n_n = 3$.\n\n- **Element-Level Matrices**: For each element $e$ of length $L_e$ with area $A$, the strain-displacement matrix is $B = [-1/L_e, 1/L_e]$. The element internal force vector and tangent stiffness matrix are calculated at a single integration point using the strain $\\varepsilon_e = B u_e$:\n  $$\n  f^{\\text{int}}_{e} = B^{\\mathsf{T}} \\sigma(\\varepsilon_e) A L_e, \\qquad K^{\\text{tan}}_{e} = B^{\\mathsf{T}} \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) B A L_e = \\frac{\\mathbb{C}^{\\text{alg}}_e A}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n  $$\n- **Global Assembly**: Element contributions are assembled into global matrices $f^{\\text{int}}(u)$ and $K(u)$ of size $3$ and $3 \\times 3$, respectively.\n- **System Definition**: The global residual is $R(u) = f^{\\text{int}}(u) - f^{\\text{ext}}$, where $f^{\\text{ext}} = [0, 0, F]^{\\mathsf{T}}$. The Dirichlet boundary condition $u(0)=0$ is applied by eliminating the first row and column from the global system, resulting in a reduced system for the free degrees of freedom (nodes 1 and 2). Let these be $R_{\\text{free}}(u)$ and $K_{\\text{free}}(u)$.\n\n### Step 4: Verification Procedure\nThe verification confirms that $K_{\\text{free}}(u)$ is the correct tangent of $R_{\\text{free}}(u)$. A central finite-difference is used to approximate the directional derivative of $R_{\\text{free}}$ along a random direction $p$ in the space of free DOFs.\n\n1.  **Linear Prediction**: The assembled tangent matrix is used to predict the change in the residual:\n    $$\n    \\Delta R_{\\text{lin}} = K_{\\text{free}}(u) \\, (2 \\epsilon p)\n    $$\n2.  **Finite-Difference Approximation**: The residual is evaluated at perturbed displacement states $u^+ = u + \\epsilon p$ and $u^- = u - \\epsilon p$. The perturbation vector $p$ for the free DOFs is embedded into the global displacement vector (with a zero for the fixed DOF).\n    $$\n    \\Delta R_{\\text{FD}} = R_{\\text{free}}(u^+) - R_{\\text{free}}(u^-)\n    $$\n3.  **Relative Error**: The accuracy of the tangent is quantified by the relative error between the prediction and the approximation:\n    $$\n    e = \\frac{\\left\\|\\Delta R_{\\text FD} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau)}\n    $$\nA small error $e$ (near machine precision) validates that the implemented tangent modulus $\\mathbb{C}^{\\text{alg}}$ is indeed consistent with the numerical stress update rule, and that the global assembly is correct. The test cases cover elastic, plastic, near-yield, and mixed elastic-plastic responses to ensure robustness.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that designs, implements, and runs the verification \n    workflow for the elasto-plastic consistent tangent operator.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    L_TOTAL = 1.0\n    A_CROSS_SECTION = 1.0\n    N_ELEMENTS = 2\n    EPSILON = 1e-8\n    TAU = 1e-14\n\n    def update_material(strain, E, H, sigma_y0):\n        \"\"\"\n        Implements the 1D return mapping algorithm for linear isotropic hardening.\n\n        Args:\n            strain (float): Current total strain.\n            E (float): Young's modulus.\n            H (float): Plastic modulus.\n            sigma_y0 (float): Initial yield stress.\n\n        Returns:\n            tuple: (stress, algorithmic_tangent_modulus).\n        \"\"\"\n        if np.abs(strain)  1e-16: # Handle zero strain case to avoid division by zero\n            return 0.0, E\n\n        sigma_trial = E * strain\n        \n        # Previous state has alpha_n = 0, so current yield stress is sigma_y0\n        phi_trial = np.abs(sigma_trial) - sigma_y0\n\n        if phi_trial = 0:\n            # Elastic step\n            return sigma_trial, E\n        else:\n            # Plastic step\n            delta_gamma = phi_trial / (E + H)\n            stress = sigma_trial - E * delta_gamma * np.sign(sigma_trial)\n            C_alg = (E * H) / (E + H)\n            return stress, C_alg\n\n    def get_equilibrium_displacement(F, E, H, sigma_y0_list, L, A, n_e):\n        \"\"\"\n        Constructs the nodal displacement vector 'u' that corresponds to a\n        state of uniform axial stress sigma = F/A.\n        \"\"\"\n        sigma_target = F / A\n        element_strains = []\n\n        for e in range(n_e):\n            sigma_y0_e = sigma_y0_list[e]\n            \n            if np.abs(sigma_target) = sigma_y0_e:\n                strain_e = sigma_target / E\n            else:\n                strain_e = np.sign(sigma_target) * (\n                    np.abs(sigma_target) / E + (np.abs(sigma_target) - sigma_y0_e) / H\n                )\n            element_strains.append(strain_e)\n\n        n_nodes = n_e + 1\n        u_global = np.zeros(n_nodes)\n        node_coords = np.linspace(0, L, n_nodes)\n        \n        for e in range(n_e):\n            L_e = node_coords[e + 1] - node_coords[e]\n            u_global[e + 1] = u_global[e] + element_strains[e] * L_e\n            \n        return u_global\n\n    def compute_residual_and_tangent(u_global, E, H, sigma_y0_list, L, A, n_e, F):\n        \"\"\"\n        Assembles the global internal force and tangent matrix and returns the\n        components corresponding to the free degrees of freedom.\n        \"\"\"\n        n_nodes = n_e + 1\n        node_coords = np.linspace(0, L, n_nodes)\n\n        f_int_global = np.zeros(n_nodes)\n        K_tan_global = np.zeros((n_nodes, n_nodes))\n\n        for e in range(n_e):\n            i, j = e, e + 1\n            L_e = node_coords[j] - node_coords[i]\n            B = np.array([-1.0 / L_e, 1.0 / L_e])\n            u_e = u_global[[i, j]]\n            strain_e = B @ u_e\n            \n            sigma_e, C_alg_e = update_material(strain_e, E, H, sigma_y0_list[e])\n            \n            f_int_elem = B.T * sigma_e * A * L_e\n            K_tan_elem = C_alg_e * A / L_e * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n            f_int_global[i:j+1] += f_int_elem\n            K_tan_global[np.ix_([i, j], [i, j])] += K_tan_elem\n\n        f_ext_global = np.zeros(n_nodes)\n        f_ext_global[-1] = F\n        R_global = f_int_global - f_ext_global\n\n        free_dofs = slice(1, None)\n        R_free = R_global[free_dofs]\n        K_free = K_tan_global[free_dofs, free_dofs]\n        \n        return R_free, K_free\n\n    def run_verification(case_params):\n        \"\"\"\n        Runs the verification procedure for a single test case.\n        \"\"\"\n        E, H, sigma_y0_val, F, seed = case_params\n        \n        if isinstance(sigma_y0_val, list):\n            sigma_y0_list = sigma_y0_val\n        else:\n            sigma_y0_list = [sigma_y0_val] * N_ELEMENTS\n\n        u_eq = get_equilibrium_displacement(F, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS)\n        \n        n_free_dofs = N_ELEMENTS\n        rng = np.random.default_rng(seed)\n        p_free = rng.random(size=n_free_dofs)\n\n        _, K_free_eq = compute_residual_and_tangent(\n            u_eq, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        delta_R_lin = K_free_eq @ (2 * EPSILON * p_free)\n\n        p_global = np.zeros(N_ELEMENTS + 1)\n        p_global[1:] = p_free\n        \n        u_plus = u_eq + EPSILON * p_global\n        u_minus = u_eq - EPSILON * p_global\n        \n        R_free_plus, _ = compute_residual_and_tangent(\n            u_plus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        R_free_minus, _ = compute_residual_and_tangent(\n            u_minus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        \n        delta_R_fd = R_free_plus - R_free_minus\n\n        norm_diff = np.linalg.norm(delta_R_fd - delta_R_lin)\n        norm_lin = np.linalg.norm(delta_R_lin)\n        \n        error = norm_diff / max(norm_lin, TAU)\n        \n        return error\n\n    test_cases = [\n        # (E, H, sigma_y0, F, seed)\n        (2e5, 1e3, 250.0, 100.0, 1), # Case 1: Homogeneous elastic\n        (2e5, 1e3, 250.0, 500.0, 2), # Case 2: Homogeneous plastic\n        (2e5, 1e3, 250.0, 255.0, 3), # Case 3: Weakly plastic, near yield\n        (2e5, 1e3, [250.0, 1000.0], 500.0, 4), # Case 4: Heterogeneous mixed\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_verification(case)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}