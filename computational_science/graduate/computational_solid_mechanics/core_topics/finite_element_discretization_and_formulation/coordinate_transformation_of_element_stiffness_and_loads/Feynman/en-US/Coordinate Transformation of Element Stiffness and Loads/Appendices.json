{
    "hands_on_practices": [
        {
            "introduction": "Coordinate transformations are not merely mathematical operations; they are required to preserve fundamental physical principles. This exercise provides a direct application of transforming a known set of local nodal forces and moments to the global coordinate system.  You are also challenged to verify two critical outcomes of this transformation: the preservation of static equilibrium and the symmetry of the global stiffness matrix, reinforcing the theoretical integrity of the congruent transformation $K_g = T^T K_l T$.",
            "id": "3555039",
            "problem": "Consider a two-dimensional Euler–Bernoulli frame element in the Finite Element Method (FEM) with two nodes, denoted node $i$ and node $j$, and local coordinates $(x,y)$ where the local $x$-axis is aligned with the element axis. The element has length $L$ and is embedded in a global $(X,Y)$ frame by a rigid rotation about the out-of-plane $z$-axis through angle $\\theta$, with $\\theta$ measured in radians. The element orientation is specified by $\\theta = \\pi/3$ and $L = 2$, and the local nodal degrees of freedom at each node are ordered as $(u_x, u_y, \\varphi_z)$, where $u_x$ and $u_y$ are translations and $\\varphi_z$ is the in-plane rotation about $z$.\n\nA self-equilibrated system of local nodal actions is applied consisting of an end shear–moment pair at node $i$ and counter-actions at node $j$. In the local frame, the applied nodal actions are:\n- At node $i$: a shear $V_i$ along $+y$ with magnitude $V_i = 12$, and a nodal moment about $z$ with magnitude $M_i = 5$.\n- At node $j$: a shear $V_j$ along $+y$ and a nodal moment about $z$ with magnitude $M_j$, to be determined such that the element-level resultant force and resultant moment are both zero in the local frame.\n\nAssume standard sign conventions: positive shear along $+y$ and positive moment about $+z$ (counterclockwise). Let the local-to-global direction cosine rotation matrix $Q$ map local translational components to global translational components. The element-level displacement transformation matrix $T$ acts on the ordered nodal displacement vector $(u_{x,i}, u_{y,i}, \\varphi_{z,i}, u_{x,j}, u_{y,j}, \\varphi_{z,j})$ and is the block-diagonal assembly of appropriate rotation submatrices for translations and the identity for $\\varphi_z$.\n\nTasks:\n1. Enforce static equilibrium in the local frame to determine $V_j$ and $M_j$ in terms of $L$, $V_i$, and $M_i$.\n2. Starting from the invariance of virtual work and the definition of the rotation mapping by $Q$, derive the appropriate transformation for nodal force components and construct the global nodal load vector $F_g$ corresponding to the local nodal load vector $F_l$ defined by the ordered components $(f_{x,i}, f_{y,i}, m_{z,i}, f_{x,j}, f_{y,j}, m_{z,j})$.\n3. Compute the explicit global components of the nodal actions for the given numerical values of $L$, $V_i$, $M_i$, and $\\theta$.\n4. Verify, using first principles and properties of rigid rotations, that nodal equilibrium is preserved under the transformation and that the transformed global element stiffness matrix $K_g$ constructed from a symmetric local stiffness $K_l$ remains symmetric.\n\nExpress the final global nodal load vector $F_g$ components in the order $(f_{X,i}, f_{Y,i}, m_{Z,i}, f_{X,j}, f_{Y,j}, m_{Z,j})$ using Newtons for forces and Newton-meters for moments. Use radians for angles. No rounding is required; present exact values.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of computational solid mechanics and the Finite Element Method, is well-posed, objective, and contains all necessary information for a unique solution without contradictions.\n\nThe solution proceeds by addressing the four tasks in order.\n\nThe ordered degrees of freedom (DOFs) for the element are given in a local frame $(x,y)$ and a global frame $(X,Y)$.\nThe local displacement vector is $d_l = (u_{x,i}, u_{y,i}, \\varphi_{z,i}, u_{x,j}, u_{y,j}, \\varphi_{z,j})^T$.\nThe corresponding local nodal load vector is $F_l = (f_{x,i}, f_{y,i}, m_{z,i}, f_{x,j}, f_{y,j}, m_{z,j})^T$.\n\nThe element has length $L=2$ and is oriented at an angle $\\theta = \\pi/3$ with respect to the global frame.\n\n**Task 1: Enforce static equilibrium in the local frame**\n\nA self-equilibrated system of nodal actions is applied. At node $i$, the actions are a shear force of magnitude $V_i = 12$ along the $+y$ direction and a moment of magnitude $M_i = 5$ about the $+z$ axis. In the local load vector notation, this means:\n$f_{x,i} = 0$\n$f_{y,i} = V_i = 12$\n$m_{z,i} = M_i = 5$\n\nAt node $j$, there are counter-actions: a shear $V_j$ along $+y$ (so $f_{y,j} = V_j$) and a moment $M_j$ (so $m_{z,j} = M_j$). There is no specified axial force, so we assume $f_{x,j}$ is determined by equilibrium.\n\nFor the element to be in static equilibrium, the sum of forces and moments must be zero.\n1.  Sum of forces in the local $x$-direction:\n    $$ \\sum f_x = f_{x,i} + f_{x,j} = 0 $$\n    Since $f_{x,i}=0$, we have $f_{x,j}=0$.\n\n2.  Sum of forces in the local $y$-direction:\n    $$ \\sum f_y = f_{y,i} + f_{y,j} = 0 $$\n    $$ V_i + V_j = 0 \\implies V_j = -V_i = -12 $$\n    So, the shear action at node $j$ is $f_{y,j} = -12$.\n\n3.  Sum of moments about node $i$:\n    $$ \\sum M_i = m_{z,i} + m_{z,j} + (f_{y,j} \\times L) = 0 $$\n    The force $f_{y,j}$ at node $j$ has a lever arm of $L$ with respect to node $i$.\n    $$ M_i + M_j + (-V_i)L = 0 $$\n    Solving for $M_j$:\n    $$ M_j = V_i L - M_i $$\n    Substituting the given values $L=2$, $V_i=12$, and $M_i=5$:\n    $$ M_j = (12)(2) - 5 = 24 - 5 = 19 $$\n    So, the moment at node $j$ is $m_{z,j} = 19$.\n\nThe complete local nodal load vector is:\n$$ F_l = \\begin{pmatrix} f_{x,i} \\\\ f_{y,i} \\\\ m_{z,i} \\\\ f_{x,j} \\\\ f_{y,j} \\\\ m_{z,j} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 12 \\\\ 5 \\\\ 0 \\\\ -12 \\\\ 19 \\end{pmatrix} $$\n\n**Task 2: Derive the transformation for nodal forces and construct the global nodal load vector $F_g$**\n\nThe transformation of nodal forces from the local to the global frame is derived from the principle of invariance of virtual work, $\\delta W$.\n$$ \\delta W = (\\delta d_g)^T F_g = (\\delta d_l)^T F_l $$\nwhere $d_g$ and $d_l$ are the global and local nodal displacement vectors, and $F_g$ and $F_l$ are the corresponding nodal load vectors.\n\nThe local displacements $d_l$ are related to the global displacements $d_g$ by a transformation matrix $T$:\n$$ d_l = T d_g $$\nThe variation of displacements follows the same rule: $\\delta d_l = T \\delta d_g$.\nSubstituting this into the virtual work equation:\n$$ (\\delta d_g)^T F_g = (T \\delta d_g)^T F_l = (\\delta d_g)^T T^T F_l $$\nSince this equality must hold for any arbitrary non-zero virtual displacement vector $\\delta d_g$, we can conclude:\n$$ F_g = T^T F_l $$\nThe matrix $T$ transforms global DOFs to local DOFs. For a single node, the transformation relates $(u_{X}, u_{Y}, \\varphi_{Z})$ to $(u_{x}, u_{y}, \\varphi_{z})$. The translational components rotate, while the in-plane rotation $\\varphi_z$ is invariant.\nThe local coordinates are obtained by rotating the global coordinates by an angle $-\\theta$. This transformation is given by:\n$$ \\begin{pmatrix} u_x \\\\ u_y \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} u_X \\\\ u_Y \\end{pmatrix} $$\nThis $2 \\times 2$ matrix is $Q^T$, the transpose of the local-to-global rotation matrix $Q$.\n$$ Q = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix} $$\nThe nodal rotation is invariant: $\\varphi_z = \\varphi_Z$.\nThe transformation for one node's DOFs is described by a matrix $T_{node}$:\n$$ T_{node} = \\begin{pmatrix} \\cos\\theta & \\sin\\theta & 0 \\\\ -\\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\nThe full element transformation matrix $T$ is a $6 \\times 6$ block-diagonal matrix:\n$$ T = \\begin{pmatrix} T_{node} & \\mathbf{0} \\\\ \\mathbf{0} & T_{node} \\end{pmatrix} $$\nThe force transformation requires $T^T$:\n$$ T^T = \\begin{pmatrix} T_{node}^T & \\mathbf{0} \\\\ \\mathbf{0} & T_{node}^T \\end{pmatrix} \\quad \\text{where} \\quad T_{node}^T = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta & 0 \\\\ \\sin\\theta & \\cos\\theta & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\nLet $R = T_{node}^T$. The global force vector $F_g$ is obtained by transforming the nodal forces at nodes $i$ and $j$ separately using $R$:\n$$ F_{g,i} = \\begin{pmatrix} f_{X,i} \\\\ f_{Y,i} \\\\ m_{Z,i} \\end{pmatrix} = R \\begin{pmatrix} f_{x,i} \\\\ f_{y,i} \\\\ m_{z,i} \\end{pmatrix} \\quad \\text{and} \\quad F_{g,j} = \\begin{pmatrix} f_{X,j} \\\\ f_{Y,j} \\\\ m_{Z,j} \\end{pmatrix} = R \\begin{pmatrix} f_{x,j} \\\\ f_{y,j} \\\\ m_{z,j} \\end{pmatrix} $$\n\n**Task 3: Compute the explicit global components**\n\nGiven $\\theta = \\pi/3$:\n$\\cos(\\pi/3) = 1/2$\n$\\sin(\\pi/3) = \\sqrt{3}/2$\n\nThe transformation matrix $R$ is:\n$$ R = \\begin{pmatrix} 1/2 & -\\sqrt{3}/2 & 0 \\\\ \\sqrt{3}/2 & 1/2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} $$\nThe local nodal loads are $F_{l,i} = (0, 12, 5)^T$ and $F_{l,j} = (0, -12, 19)^T$.\n\nFor node $i$:\n$$ \\begin{pmatrix} f_{X,i} \\\\ f_{Y,i} \\\\ m_{Z,i} \\end{pmatrix} = \\begin{pmatrix} 1/2 & -\\sqrt{3}/2 & 0 \\\\ \\sqrt{3}/2 & 1/2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 12 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} (1/2)(0) + (-\\sqrt{3}/2)(12) + (0)(5) \\\\ (\\sqrt{3}/2)(0) + (1/2)(12) + (0)(5) \\\\ (0)(0) + (0)(12) + (1)(5) \\end{pmatrix} = \\begin{pmatrix} -6\\sqrt{3} \\\\ 6 \\\\ 5 \\end{pmatrix} $$\n\nFor node $j$:\n$$ \\begin{pmatrix} f_{X,j} \\\\ f_{Y,j} \\\\ m_{Z,j} \\end{pmatrix} = \\begin{pmatrix} 1/2 & -\\sqrt{3}/2 & 0 \\\\ \\sqrt{3}/2 & 1/2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -12 \\\\ 19 \\end{pmatrix} = \\begin{pmatrix} (1/2)(0) + (-\\sqrt{3}/2)(-12) + (0)(19) \\\\ (\\sqrt{3}/2)(0) + (1/2)(-12) + (0)(19) \\\\ (0)(0) + (0)(-12) + (1)(19) \\end{g,j} \\end{pmatrix} = \\begin{pmatrix} 6\\sqrt{3} \\\\ -6 \\\\ 19 \\end{pmatrix} $$\n\nThe final global nodal load vector $F_g$ is assembled from these components:\n$$ F_g = (f_{X,i}, f_{Y,i}, m_{Z,i}, f_{X,j}, f_{Y,j}, m_{Z,j})^T = (-6\\sqrt{3}, 6, 5, 6\\sqrt{3}, -6, 19)^T $$\n\n**Task 4: Verification of equilibrium and stiffness matrix symmetry**\n\n*   **Preservation of Nodal Equilibrium:**\n    A system of forces and moments is in equilibrium if the resultant force vector and resultant moment vector (about any point) are zero. The transformation from a local frame to a global frame is a rigid rotation, which is an affine transformation that preserves vector sums and moment properties.\n    Formally, let the total force vector in the local frame be $\\mathbf{F}_{total, l} = \\sum_{k} \\mathbf{F}_{l,k}$. The problem states the local system is in equilibrium, so $\\mathbf{F}_{total, l} = \\mathbf{0}$.\n    The total force in the global frame is $\\mathbf{F}_{total, g} = \\sum_{k} \\mathbf{F}_{g,k}$. Each force vector transforms as $\\mathbf{F}_{g,k} = Q \\mathbf{F}_{l,k}$.\n    $$ \\mathbf{F}_{total, g} = \\sum_{k} (Q \\mathbf{F}_{l,k}) = Q \\left( \\sum_{k} \\mathbf{F}_{l,k} \\right) = Q \\mathbf{F}_{total, l} = Q \\mathbf{0} = \\mathbf{0} $$\n    Thus, force equilibrium is preserved. A similar argument holds for moment equilibrium. A set of forces and moments that is self-equilibrated in one coordinate system remains self-equilibrated after a rigid transformation to another coordinate system. Our numerical result confirms this:\n    $\\sum F_X = -6\\sqrt{3} + 6\\sqrt{3} = 0$.\n    $\\sum F_Y = 6 - 6 = 0$.\n\n*   **Symmetry of Transformed Stiffness Matrix $K_g$:**\n    The transformation of the stiffness matrix from local coordinates to global coordinates is given by:\n    $$ K_g = T^T K_l T $$\n    We are given that the local stiffness matrix $K_l$ is symmetric, which means $K_l^T = K_l$. We must verify that $K_g$ is also symmetric, i.e., $K_g^T = K_g$.\n    Let's compute the transpose of $K_g$:\n    $$ K_g^T = (T^T K_l T)^T $$\n    Using the property of the transpose of a product, $(ABC)^T = C^T B^T A^T$:\n    $$ K_g^T = T^T (K_l)^T (T^T)^T $$\n    Using the property that the transpose of a transpose is the original matrix, $(A^T)^T = A$:\n    $$ K_g^T = T^T (K_l)^T T $$\n    Since $K_l$ is symmetric, we substitute $K_l^T = K_l$:\n    $$ K_g^T = T^T K_l T $$\n    This is precisely the definition of $K_g$. Therefore, $K_g^T = K_g$, proving that the global stiffness matrix is symmetric if the local one is. This property is fundamental to the congruent transformation used in FEM.",
            "answer": "$$ \\boxed{\n\\begin{pmatrix} -6\\sqrt{3} \\\\ 6 \\\\ 5 \\\\ 6\\sqrt{3} \\\\ -6 \\\\ 19 \\end{pmatrix}\n} $$"
        },
        {
            "introduction": "Building on the transformation of discrete nodal loads, this practice explores the more general case of distributed loads defined in an element's local frame.  This exercise guides you through the essential two-step procedure: first, using the principle of virtual work to derive the work-equivalent, or 'consistent,' nodal loads from a distributed force field, and then transforming these local nodal actions into the global analysis frame.",
            "id": "3555024",
            "problem": "Consider a two-dimensional Euler–Bernoulli beam (frame) finite element of length $L$ connecting node $1$ to node $2$. The element’s local coordinate system $\\{x,y\\}$ is obtained by rotating the global system $\\{X,Y\\}$ by a constant angle $\\theta$ measured counterclockwise from the global $X$-axis to the local $x$-axis. The local $y$-axis is the in-plane transverse axis, orthonormal to the local $x$-axis. The nodal degrees of freedom in the local system are ordered as $[u_1, v_1, \\varphi_1, u_2, v_2, \\varphi_2]^{T}$, where $u$ is the axial displacement, $v$ is the transverse displacement, and $\\varphi$ is the rotation.\n\nA distributed load acts only in the local transverse direction $+y$ and varies along the element as\n$$\nq_l(x) \\;=\\; q_0 \\;+\\; q_1\\,\\frac{x}{L} \\;+\\; q_2\\,\\Bigl(\\frac{x}{L}\\Bigr)^{2},\n\\quad 0 \\le x \\le L,\n$$\nwith $q_0$, $q_1$, and $q_2$ being constants. Using the principle of virtual work and the standard cubic Hermite interpolation for the Euler–Bernoulli beam’s transverse displacement,\n$$\nv(x) \\;=\\; H_1(\\xi)\\,v_1 \\;+\\; H_2(\\xi)\\,L\\,\\varphi_1 \\;+\\; H_3(\\xi)\\,v_2 \\;+\\; H_4(\\xi)\\,L\\,\\varphi_2,\n\\quad \\xi \\equiv \\frac{x}{L},\n$$\nwith\n$$\nH_1(\\xi)=1-3\\xi^{2}+2\\xi^{3},\\quad\nH_2(\\xi)=\\xi-2\\xi^{2}+\\xi^{3},\\quad\nH_3(\\xi)=3\\xi^{2}-2\\xi^{3},\\quad\nH_4(\\xi)=-\\xi^{2}+\\xi^{3},\n$$\nfirst form the consistent local equivalent nodal load vector contribution associated with the transverse displacement at node $1$, i.e., the component $F_{v1}^{(l)}$ in the local vector $[F_{u1}^{(l)},F_{v1}^{(l)},M_{1}^{(l)},F_{u2}^{(l)},F_{v2}^{(l)},M_{2}^{(l)}]^{T}$ due solely to $q_l(x)$.\n\nThen map the local equivalent nodal loads into the global system using the force transformation\n$$\n\\mathbf{f}^{(g)} \\;=\\; \\mathbf{T}^{T}\\,\\mathbf{f}^{(l)},\n$$\nwhere $\\mathbf{T}$ is the block-diagonal transformation that maps global nodal displacements to local nodal displacements, i.e.,\n$$\n\\begin{bmatrix} u \\\\ v \\\\ \\varphi \\end{bmatrix}^{(l)}\n\\;=\\;\n\\mathbf{R}\\,\n\\begin{bmatrix} U \\\\ V \\\\ \\Phi \\end{bmatrix}^{(g)},\n\\qquad\n\\mathbf{R}\n=\n\\begin{bmatrix}\n\\cos\\theta & \\sin\\theta & 0 \\\\\n-\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\n$$\napplied independently at node $1$ and node $2$.\n\nDerive, from first principles, a closed-form expression for the global $X$-component of the equivalent nodal load at node $1$, denoted $F_{X1}^{(g)}$, due solely to $q_l(x)$. Express your final answer as a single symbolic expression in terms of $q_0$, $q_1$, $q_2$, $L$, and $\\theta$. Do not include units in your final expression. No numerical evaluation or rounding is required.",
            "solution": "The problem is valid as it is a well-posed, scientifically grounded problem in computational solid mechanics that is internally consistent and contains all necessary information for a unique solution.\n\nThe derivation proceeds in two main steps: first, the determination of the consistent local equivalent nodal loads using the principle of virtual work; second, the transformation of these local loads into the global coordinate system.\n\nThe principle of virtual work states that the virtual work done by the external distributed load, $\\delta W_{\\text{ext}}$, equals the work done by the equivalent nodal loads, $\\mathbf{f}^{(l)}$, through the virtual nodal displacements, $\\delta\\mathbf{d}^{(l)}$. The distributed load $q_l(x)$ acts only in the local transverse direction, so the virtual work is given by:\n$$\n\\delta W_{\\text{ext}} = \\int_0^L q_l(x) \\, \\delta v(x) \\, dx\n$$\nThe virtual transverse displacement, $\\delta v(x)$, is interpolated from the virtual nodal degrees of freedom using the provided Hermite shape functions, $H_i(\\xi)$, where $\\xi = x/L$:\n$$\n\\delta v(x) = H_1(\\xi)\\,\\delta v_1 + H_2(\\xi)\\,L\\,\\delta \\varphi_1 + H_3(\\xi)\\,\\delta v_2 + H_4(\\xi)\\,L\\,\\delta \\varphi_2\n$$\nThe virtual work can also be expressed discretely as:\n$$\n\\delta W_{\\text{ext}} = [F_{u1}^{(l)}, F_{v1}^{(l)}, M_1^{(l)}, F_{u2}^{(l)}, F_{v2}^{(l)}, M_2^{(l)}] \\begin{bmatrix} \\delta u_1 \\\\ \\delta v_1 \\\\ \\delta \\varphi_1 \\\\ \\delta u_2 \\\\ \\delta v_2 \\\\ \\delta \\varphi_2 \\end{bmatrix}\n$$\nSince the applied load $q_l(x)$ is purely transverse, it performs no work through any virtual axial displacement $\\delta u(x)$. Consequently, the consistent nodal axial forces are zero: $F_{u1}^{(l)} = 0$ and $F_{u2}^{(l)} = 0$.\n\nTo find the local transverse force at node $1$, $F_{v1}^{(l)}$, we equate the coefficient of the virtual displacement $\\delta v_1$ in both expressions for $\\delta W_{\\text{ext}}$:\n$$\nF_{v1}^{(l)} = \\int_0^L q_l(x) H_1(\\xi) \\, dx\n$$\nWe substitute the given expressions for $q_l(x)$ and $H_1(\\xi)$ and change the integration variable from $x$ to $\\xi$ using $x = L\\xi$ and $dx = L\\,d\\xi$:\n$$\nF_{v1}^{(l)} = \\int_0^1 \\left( q_0 + q_1\\xi + q_2\\xi^2 \\right) \\left( 1 - 3\\xi^2 + 2\\xi^3 \\right) L \\, d\\xi\n$$\nWe can separate this into three integrals based on the constants $q_0$, $q_1$, and $q_2$:\n$$\nF_{v1}^{(l)} = L \\left( q_0 \\int_0^1 H_1(\\xi) \\, d\\xi + q_1 \\int_0^1 \\xi H_1(\\xi) \\, d\\xi + q_2 \\int_0^1 \\xi^2 H_1(\\xi) \\, d\\xi \\right)\n$$\nWe evaluate each integral separately:\n$$\n\\int_0^1 H_1(\\xi) \\, d\\xi = \\int_0^1 (1 - 3\\xi^2 + 2\\xi^3) \\, d\\xi = \\left[ \\xi - \\xi^3 + \\frac{2}{4}\\xi^4 \\right]_0^1 = 1 - 1 + \\frac{1}{2} = \\frac{1}{2}\n$$\n$$\n\\int_0^1 \\xi H_1(\\xi) \\, d\\xi = \\int_0^1 (\\xi - 3\\xi^3 + 2\\xi^4) \\, d\\xi = \\left[ \\frac{1}{2}\\xi^2 - \\frac{3}{4}\\xi^4 + \\frac{2}{5}\\xi^5 \\right]_0^1 = \\frac{1}{2} - \\frac{3}{4} + \\frac{2}{5} = \\frac{10-15+8}{20} = \\frac{3}{20}\n$$\n$$\n\\int_0^1 \\xi^2 H_1(\\xi) \\, d\\xi = \\int_0^1 (\\xi^2 - 3\\xi^4 + 2\\xi^5) \\, d\\xi = \\left[ \\frac{1}{3}\\xi^3 - \\frac{3}{5}\\xi^5 + \\frac{2}{6}\\xi^6 \\right]_0^1 = \\frac{1}{3} - \\frac{3}{5} + \\frac{1}{3} = \\frac{2}{3} - \\frac{3}{5} = \\frac{10-9}{15} = \\frac{1}{15}\n$$\nSubstituting these results back, we obtain the expression for $F_{v1}^{(l)}$:\n$$\nF_{v1}^{(l)} = L \\left( \\frac{1}{2} q_0 + \\frac{3}{20} q_1 + \\frac{1}{15} q_2 \\right)\n$$\nThe second step is to transform the local nodal loads to the global coordinate system. The transformation for the force/moment vectors is given by $\\mathbf{f}^{(g)} = \\mathbf{T}^T \\mathbf{f}^{(l)}$. The full transformation matrix $\\mathbf{T}$ is block-diagonal, composed of two $3 \\times 3$ rotation matrices $\\mathbf{R}$. The transformation for the nodal loads at node $1$ is thus:\n$$\n\\begin{bmatrix} F_{X1}^{(g)} \\\\ F_{Y1}^{(g)} \\\\ M_{Z1}^{(g)} \\end{bmatrix} = \\mathbf{R}^T \\begin{bmatrix} F_{u1}^{(l)} \\\\ F_{v1}^{(l)} \\\\ M_1^{(l)} \\end{bmatrix}\n$$\nThe transpose of the given rotation matrix $\\mathbf{R}$ is:\n$$\n\\mathbf{R}^T = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\nPerforming the matrix-vector multiplication, the global $X$-component of the load at node $1$, $F_{X1}^{(g)}$, is:\n$$\nF_{X1}^{(g)} = F_{u1}^{(l)} \\cos\\theta - F_{v1}^{(l)} \\sin\\theta\n$$\nAs established earlier, the local axial force component $F_{u1}^{(l)}$ is zero because the applied distributed load is purely transverse. Therefore, the expression simplifies to:\n$$\nF_{X1}^{(g)} = - F_{v1}^{(l)} \\sin\\theta\n$$\nFinally, substituting the derived expression for $F_{v1}^{(l)}$ yields the desired global load component:\n$$\nF_{X1}^{(g)} = -L \\left( \\frac{1}{2} q_0 + \\frac{3}{20} q_1 + \\frac{1}{15} q_2 \\right) \\sin\\theta\n$$\nThis expression is the final answer, given in terms of the specified constants $q_0$, $q_1$, $q_2$, $L$, and $\\theta$.",
            "answer": "$$ \\boxed{-L \\left( \\frac{1}{2} q_0 + \\frac{3}{20} q_1 + \\frac{1}{15} q_2 \\right) \\sin\\theta} $$"
        },
        {
            "introduction": "Theoretical equivalence is best cemented through practical implementation. This final exercise is a computational verification task where you will implement a simple truss analysis to confirm that different assembly strategies yield identical results.  By developing and comparing a method based on local-to-global transformation against a direct global formulation, you will gain concrete, hands-on proof of the robustness and consistency of the finite element assembly process.",
            "id": "3555027",
            "problem": "A single two-dimensional small-strain linear elastic truss verification is required to demonstrate that transforming element contributions from a local frame to the global frame via a direction-cosine mapping yields identical assembled global structural responses to directly expressing those contributions in the global frame. The foundational base is the static balance of linear momentum, the Principle of Virtual Work, and Hooke’s law for axial deformation in a bar. Consider a planar truss made of three nodes connected by three straight bar elements. Each node possesses two translational degrees of freedom (DOF), so the global structural DOF vector has six components. The problem must compare two assembly procedures under identical boundary conditions and loads: (i) assemble from local element quantities mapped to global with an orthogonal mapping constructed from direction cosines, and (ii) assemble directly in the global frame using direction cosines. The mapping must be constructed using a known planar rotation matrix, specified by an angle, to define the orientation of one element. The verification must include both stiffness and load transformations.\n\nThe physical and numerical setup is as follows. Let nodes be labeled $0$, $1$, and $2$. Node $0$ is fixed in both directions, and node $1$ is fixed only in the vertical direction; node $2$ is free. All quantities must be expressed in International System of Units: lengths in meters (m), forces in Newtons (N), and elastic moduli in Pascals (Pa). Angles must be provided in degrees. The planar rotation matrix $Q(\\theta)$ is the orthogonal matrix\n$$\nQ(\\theta) = \\begin{bmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix},\n$$\nwhere $\\theta$ is the rotation angle in radians; the angle will be specified in degrees and must be converted to radians by the program. The element connecting nodes $0$ and $1$ is defined by rotating the base vector $\\begin{bmatrix}L_{01}\\\\0\\end{bmatrix}$ by $Q(\\theta)$ to obtain node $1$’s location relative to node $0$. Node $0$ is fixed at the origin, and node $2$ is given explicitly. Each bar element $e$ has a Young’s modulus $E_e$ and a cross-sectional area $A_e$. The small-strain initial axial strain of the element between nodes $0$ and $1$ is $\\varepsilon_{0,01}$; all other elements have zero initial axial strain. The initial axial strain produces a self-equilibrated pair of axial forces in the local element frame that must be consistently included in the global assembled load vector.\n\nTwo assembly routes must be executed:\n- Route A (local-to-global transformation): For each element, form its local axial stiffness and local fixed-end load due to initial strain, then map both to the global frame using a direction-cosine mapping based on the element’s unit orientation vector.\n- Route B (direct-global formulation): For each element, directly form its global stiffness and global equivalent nodal load using the global direction cosines, without intermediate local-to-global multiplication.\n\nAfter assembling the global stiffness matrix and global load vector for both routes, apply the essential boundary conditions and solve the resulting linear systems for the nodal displacement vector. Then compute the reaction forces at the constrained DOF by substituting the displacement solution back into the full system equilibrium equation. Finally, compare the displacement vectors and the reaction force vectors between Route A and Route B; if both comparisons are within the specified numerical tolerance, the test returns true, otherwise false.\n\nThe numerical tolerance is defined as absolute tolerance $10^{-10}$ and relative tolerance $10^{-12}$. The comparison is elementwise for both the displacement vector and the reaction vector.\n\nThe Test Suite consists of three cases that exercise different geometric orientations, material combinations, and load patterns, including a general oblique case, an axis-aligned boundary case, and a near-reversal edge case. For each case, the parameters are:\n\n- Case 1 (general oblique orientation): \n  - $L_{01} = 2.0 \\,\\text{m}$, $\\theta = 37^\\circ$,\n  - Node $0$: $(0.0 \\,\\text{m}, 0.0 \\,\\text{m})$,\n  - Node $1$: obtained by $Q(\\theta)\\begin{bmatrix}L_{01}\\\\ 0\\end{bmatrix}$,\n  - Node $2$: $(1.2 \\,\\text{m}, 1.0 \\,\\text{m})$,\n  - Connectivity: elements $(0,1)$, $(1,2)$, $(0,2)$,\n  - $E_{01} = 210\\times 10^{9} \\,\\text{Pa}$, $A_{01} = 1.2\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,01} = 2.5\\times 10^{-5}$,\n  - $E_{12} = 210\\times 10^{9} \\,\\text{Pa}$, $A_{12} = 1.0\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,12} = 0$,\n  - $E_{02} = 210\\times 10^{9} \\,\\text{Pa}$, $A_{02} = 0.9\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,02} = 0$,\n  - External nodal load at node $2$: $\\begin{bmatrix}1500 \\,\\text{N}\\\\ -500 \\,\\text{N}\\end{bmatrix}$.\n\n- Case 2 (axis-aligned boundary case):\n  - $L_{01} = 3.0 \\,\\text{m}$, $\\theta = 0^\\circ$,\n  - Node $0$: $(0.0 \\,\\text{m}, 0.0 \\,\\text{m})$,\n  - Node $1$: obtained by $Q(\\theta)\\begin{bmatrix}L_{01}\\\\ 0\\end{bmatrix}$,\n  - Node $2$: $(1.5 \\,\\text{m}, 2.0 \\,\\text{m})$,\n  - Connectivity: elements $(0,1)$, $(1,2)$, $(0,2)$,\n  - $E_{01} = 70\\times 10^{9} \\,\\text{Pa}$, $A_{01} = 2.0\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,01} = 0$,\n  - $E_{12} = 70\\times 10^{9} \\,\\text{Pa}$, $A_{12} = 1.6\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,12} = 0$,\n  - $E_{02} = 70\\times 10^{9} \\,\\text{Pa}$, $A_{02} = 1.8\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,02} = 0$,\n  - External nodal load at node $2$: $\\begin{bmatrix}0 \\,\\text{N}\\\\ -2000 \\,\\text{N}\\end{bmatrix}$.\n\n- Case 3 (near-reversal edge case):\n  - $L_{01} = 2.5 \\,\\text{m}$, $\\theta = 170^\\circ$,\n  - Node $0$: $(0.0 \\,\\text{m}, 0.0 \\,\\text{m})$,\n  - Node $1$: obtained by $Q(\\theta)\\begin{bmatrix}L_{01}\\\\ 0\\end{bmatrix}$,\n  - Node $2$: $(0.8 \\,\\text{m}, 1.4 \\,\\text{m})$,\n  - Connectivity: elements $(0,1)$, $(1,2)$, $(0,2)$,\n  - $E_{01} = 200\\times 10^{9} \\,\\text{Pa}$, $A_{01} = 1.1\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,01} = -1.0\\times 10^{-5}$,\n  - $E_{12} = 150\\times 10^{9} \\,\\text{Pa}$, $A_{12} = 1.3\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,12} = 0$,\n  - $E_{02} = 180\\times 10^{9} \\,\\text{Pa}$, $A_{02} = 0.9\\times 10^{-4} \\,\\text{m}^2$, $\\varepsilon_{0,02} = 0$,\n  - External nodal load at node $2$: $\\begin{bmatrix}-1000 \\,\\text{N}\\\\ 800 \\,\\text{N}\\end{bmatrix}$.\n\nYour program must:\n- Construct the coordinates using the prescribed rotation for node $1$ via $Q(\\theta)$ and the given node $2$ coordinates.\n- For each case, assemble the global stiffness matrix and load vector twice: Route A (local-to-global transformation) and Route B (direct-global), including the fixed-end load induced by the element $(0,1)$ initial strain $\\varepsilon_{0,01}$.\n- Apply essential boundary conditions: node $0$ fixed in both directions and node $1$ fixed in the vertical direction.\n- Solve both systems for the displacement vector and compute the reaction forces.\n- Compare displacement and reaction vectors elementwise between Route A and Route B using the given tolerances, and return a boolean indicating equality for the case.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each $resultk$ is a boolean indicating whether the equivalence holds for case $k$.",
            "solution": "The problem requires the numerical verification of two distinct but theoretically equivalent assembly procedures for a two-dimensional truss structure using the Finite Element Method (FEM). The core principle to be verified is that assembling global stiffness matrices and load vectors by transforming local element quantities is identical to formulating them directly in the global coordinate system. This verification is grounded in the principles of linear elasticity, the principle of virtual work, and kinematic transformations between coordinate frames.\n\nThe static equilibrium of a discretized system is expressed by the matrix equation:\n$$\nK U = F\n$$\nwhere $K$ is the global stiffness matrix, $U$ is the global vector of nodal displacements, and $F$ is the global vector of applied nodal loads. Both $K$ and $F$ are assembled from the contributions of individual elements.\n\nA single 2-node truss element, connecting nodes $i$ and $j$, has an axial stiffness $k_{axial} = \\frac{E A}{L}$, where $E$ is the Young's modulus, $A$ is the cross-sectional area, and $L$ is the element's length. The element's orientation in the global $x-y$ plane is defined by an angle $\\alpha$, with direction cosines $c = \\cos\\alpha$ and $s = \\sin\\alpha$. These are calculated from the nodal coordinates $(x_i, y_i)$ and $(x_j, y_j)$ as $L = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}$, $c = (x_j - x_i)/L$, and $s = (y_j - y_i)/L$.\n\nThe relationship between the local axial displacements at the element's ends, $d'_e = \\begin{bmatrix} d'_{i} & d'_{j} \\end{bmatrix}^T$, and the global Cartesian displacements of its nodes, $d_e = \\begin{bmatrix} u_{ix} & u_{iy} & u_{jx} & u_{jy} \\end{bmatrix}^T$, is given by $d'_e = T_e d_e$. The transformation matrix $T_e$ is:\n$$\nT_e = \\begin{bmatrix} c & s & 0 & 0 \\\\ 0 & 0 & c & s \\end{bmatrix}\n$$\n\nThe analysis proceeds by implementing two distinct routes for computing each element's contribution to the global system.\n\n### Route A: Local-to-Global Transformation\n\nIn this approach, the element stiffness matrix and load vector are first formulated in a local coordinate system aligned with the element's axis.\n\n1.  **Local Stiffness Matrix**: The local stiffness matrix $k'_e$ relates the local axial forces to the local axial displacements. For a 2-node element, it is a $2 \\times 2$ matrix:\n    $$\n    k'_e = \\frac{E A}{L} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n    $$\n2.  **Stiffness Transformation**: The local stiffness matrix is transformed into the $4 \\times 4$ global element stiffness matrix $K_e$ using the standard congruent transformation:\n    $$\n    K_e = T_e^T k'_e T_e\n    $$\n3.  **Local Initial Strain Load**: An initial axial strain $\\varepsilon_0$ induces an initial tension force $P_0 = E A \\varepsilon_0$. The equivalent nodal forces required to hold the element ends fixed in the local frame are:\n    $$\n    f'_{e,0} = P_0 \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} = E A \\varepsilon_0 \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n    $$\n4.  **Load Transformation**: This local force vector is transformed into the global coordinate system to find the equivalent global nodal forces, $F_{e,0}$:\n    $$\n    F_{e,0} = T_e^T f'_{e,0}\n    $$\n\n### Route B: Direct Global Formulation\n\nThis route bypasses the explicit matrix multiplications by using the final, expanded forms of the global element matrices. These forms are derived by carrying out the multiplications from Route A algebraically.\n\n1.  **Global Stiffness Matrix**: The direct formulation for the $4 \\times 4$ global element stiffness matrix is:\n    $$\n    K_e = \\frac{E A}{L} \\begin{bmatrix} c^2 & cs & -c^2 & -cs \\\\ cs & s^2 & -cs & -s^2 \\\\ -c^2 & -cs & c^2 & cs \\\\ -cs & -s^2 & cs & s^2 \\end{bmatrix}\n    $$\n2.  **Global Initial Strain Load**: The direct formulation for the $4 \\times 1$ global nodal force vector due to initial strain is:\n    $$\n    F_{e,0} = E A \\varepsilon_0 \\begin{bmatrix} -c \\\\ -s \\\\ c \\\\ s \\end{bmatrix}\n    $$\n\n### System Assembly, Solution, and Verification\n\nFor both routes, the procedure is as follows:\n1.  **Assembly**: The global stiffness matrix $K$ and global load vector $F_{total}$ for the 3-node, 6-DOF system are initialized as zero matrices. The total load vector is the sum of external loads and initial strain loads, $F_{total} = F_{ext} + \\sum_e F_{e,0}$. For each of the three elements, its $4 \\times 4$ stiffness matrix $K_e$ and $4 \\times 1$ load vector $F_{e,0}$ are computed and added to the appropriate locations in the $6 \\times 6$ global matrix $K$ and $6 \\times 1$ global vector $F_{total}$.\n2.  **Boundary Conditions**: The problem specifies that node 0 is fully fixed ($u_{0x}=u_{0y}=0$, corresponding to DOFs 0 and 1) and node 1 is fixed vertically ($u_{1y}=0$, corresponding to DOF 3). The system $K U = F_{total}$ is partitioned into free ($f$) and prescribed ($p$) DOFs:\n    $$\n    \\begin{bmatrix} K_{ff} & K_{fp} \\\\ K_{pf} & K_{pp} \\end{bmatrix} \\begin{bmatrix} U_f \\\\ U_p \\end{bmatrix} = \\begin{bmatrix} F_f \\\\ F_p \\end{bmatrix}\n    $$\n    With $U_p = 0$, the system reduces to solving for the unknown displacements $U_f$:\n    $$\n    K_{ff} U_f = F_f\n    $$\n    Here, the free DOFs are $2, 4, 5$ ($u_{1x}, u_{2x}, u_{2y}$) and the prescribed DOFs are $0, 1, 3$.\n3.  **Displacement Solution**: The reduced system is solved for $U_f$. The full displacement vector $U$ is then constructed by combining $U_f$ and the known $U_p=0$.\n4.  **Reaction Forces**: Once $U$ is known, the vector of all forces (applied and reactive) is given by $K U$. The reaction forces $R$ at the constrained DOFs are found by subtracting the applied forces at those locations: $R = (K U - F_{total})_{prescribed\\_DOFs}$.\n5.  **Comparison**: The full displacement vectors $U_A, U_B$ and the reaction force vectors $R_A, R_B$ obtained from both routes are compared element-wise. The verification is successful if the differences are within the specified absolute tolerance $atol = 10^{-10}$ and relative tolerance $rtol = 10^{-12}$. This confirms the numerical equivalence of the two assembly methods.\nThe entire process is repeated for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            # Case 1 (general oblique orientation)\n            \"L01\": 2.0, \"theta_deg\": 37.0,\n            \"node2_coords\": (1.2, 1.0),\n            \"props\": {\n                (0, 1): {\"E\": 210e9, \"A\": 1.2e-4, \"eps0\": 2.5e-5},\n                (1, 2): {\"E\": 210e9, \"A\": 1.0e-4, \"eps0\": 0.0},\n                (0, 2): {\"E\": 210e9, \"A\": 0.9e-4, \"eps0\": 0.0},\n            },\n            \"ext_load_node2\": (1500.0, -500.0)\n        },\n        {\n            # Case 2 (axis-aligned boundary case)\n            \"L01\": 3.0, \"theta_deg\": 0.0,\n            \"node2_coords\": (1.5, 2.0),\n            \"props\": {\n                (0, 1): {\"E\": 70e9, \"A\": 2.0e-4, \"eps0\": 0.0},\n                (1, 2): {\"E\": 70e9, \"A\": 1.6e-4, \"eps0\": 0.0},\n                (0, 2): {\"E\": 70e9, \"A\": 1.8e-4, \"eps0\": 0.0},\n            },\n            \"ext_load_node2\": (0.0, -2000.0)\n        },\n        {\n            # Case 3 (near-reversal edge case)\n            \"L01\": 2.5, \"theta_deg\": 170.0,\n            \"node2_coords\": (0.8, 1.4),\n            \"props\": {\n                (0, 1): {\"E\": 200e9, \"A\": 1.1e-4, \"eps0\": -1.0e-5},\n                (1, 2): {\"E\": 150e9, \"A\": 1.3e-4, \"eps0\": 0.0},\n                (0, 2): {\"E\": 180e9, \"A\": 0.9e-4, \"eps0\": 0.0},\n            },\n            \"ext_load_node2\": (-1000.0, 800.0)\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        results.append(run_verification_case(case_data))\n\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\ndef run_verification_case(case):\n    \"\"\"\n    Executes the verification for a single test case.\n    \"\"\"\n    \n    # Tolerances for comparison\n    atol = 1e-10\n    rtol = 1e-12\n\n    def compute_solution(route_type):\n        \"\"\"\n        Computes displacements and reactions for a given assembly route.\n        \"\"\"\n        # 1. Setup geometry and loads\n        nodes = np.zeros((3, 2))\n        nodes[0] = [0.0, 0.0]\n        theta_rad = np.radians(case[\"theta_deg\"])\n        c01, s01 = np.cos(theta_rad), np.sin(theta_rad)\n        nodes[1] = [case[\"L01\"] * c01, case[\"L01\"] * s01]\n        nodes[2] = case[\"node2_coords\"]\n        \n        elements = [(0, 1), (1, 2), (0, 2)]\n        \n        K_global = np.zeros((6, 6))\n        F_global = np.zeros(6)\n\n        # Add external nodal load at node 2\n        F_global[4] = case[\"ext_load_node2\"][0]\n        F_global[5] = case[\"ext_load_node2\"][1]\n\n        # 2. Assemble global matrices\n        for n1, n2 in elements:\n            props = case[\"props\"][(n1, n2)]\n            E, A, eps0 = props[\"E\"], props[\"A\"], props[\"eps0\"]\n            \n            x1, y1 = nodes[n1]\n            x2, y2 = nodes[n2]\n            \n            dx, dy = x2 - x1, y2 - y1\n            L = np.sqrt(dx**2 + dy**2)\n            c, s = dx/L, dy/L\n            \n            # Get element stiffness and initial strain load\n            if route_type == 'A': # Local-to-Global Transformation\n                k_prime = (E * A / L) * np.array([[1, -1], [-1, 1]])\n                T = np.array([[c, s, 0, 0], [0, 0, c, s]])\n                Ke = T.T @ k_prime @ T\n                \n                Fe0 = np.zeros(4)\n                if eps0 != 0:\n                    f_prime_0 = E * A * eps0 * np.array([-1, 1])\n                    Fe0 = T.T @ f_prime_0\n\n            elif route_type == 'B': # Direct Global Formulation\n                k_factor = E * A / L\n                M = k_factor * np.array([[c**2, c*s], [c*s, s**2]])\n                Ke = np.block([[M, -M], [-M, M]])\n                \n                Fe0 = np.zeros(4)\n                if eps0 != 0:\n                    Fe0 = E * A * eps0 * np.array([-c, -s, c, s])\n            \n            # Assemble into global system\n            dofs = [2*n1, 2*n1+1, 2*n2, 2*n2+1]\n            K_global[np.ix_(dofs, dofs)] += Ke\n            F_global[dofs] += Fe0\n            \n        # 3. Apply BCs and solve\n        fixed_dofs = [0, 1, 3]\n        all_dofs = list(range(6))\n        free_dofs = sorted(list(set(all_dofs) - set(fixed_dofs))) # [2, 4, 5]\n        \n        K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n        F_f = F_global[free_dofs]\n        \n        try:\n            U_f = np.linalg.solve(K_ff, F_f)\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case if structure is unstable\n            return None, None\n            \n        U = np.zeros(6)\n        U[free_dofs] = U_f\n        \n        # 4. Compute reaction forces\n        R_vec = K_global @ U - F_global\n        Reactions = R_vec[fixed_dofs]\n        \n        return U, Reactions\n\n    # Run for both routes\n    U_A, R_A = compute_solution('A')\n    U_B, R_B = compute_solution('B')\n\n    if U_A is None or U_B is None:\n        return False # Indicates a solver failure\n\n    # 5. Compare results\n    disp_ok = np.allclose(U_A, U_B, rtol=rtol, atol=atol)\n    react_ok = np.allclose(R_A, R_B, rtol=rtol, atol=atol)\n    \n    return disp_ok and react_ok\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}