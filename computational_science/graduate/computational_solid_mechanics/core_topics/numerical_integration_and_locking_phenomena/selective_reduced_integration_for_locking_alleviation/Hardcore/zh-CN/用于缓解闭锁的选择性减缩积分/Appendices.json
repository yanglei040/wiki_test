{
    "hands_on_practices": [
        {
            "introduction": "选择性减缩积分（SRI）方法的核心在于对应变能进行分解，并对不同部分采用不同的数值积分方案。本练习将引导您完成一个基础但至关重要的推导：针对一个标准的双线性四边形（$Q_4$）单元，从其能量密度表达式出发，推导出其刚度矩阵的体积和偏应变贡献部分。掌握这一推导过程，是深入理解计算力学中抽象的能量原理如何转化为具体有限元实现的关键一步。",
            "id": "3599144",
            "problem": "考虑一个通过有限元法 (FEM) 离散化的二维小应变各向同性固体，使用单个双线性四边形单元 ($Q_4$)，该单元在物理坐标系中占据一个矩形区域，节点位于 $(0,0)$、$(a,0)$、$(a,b)$ 和 $(0,b)$。储存能量密度根据下式分解为体积部分和偏量部分\n$$\nW = \\tfrac{1}{2}K\\big(\\operatorname{tr}\\epsilon\\big)^{2} + \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}},\n$$\n其中 $K$ 是体积模量，$\\mu$ 是剪切模量，$\\epsilon$ 是小应变张量，而 $\\epsilon_{\\text{dev}} = \\epsilon - \\tfrac{1}{2}(\\operatorname{tr}\\epsilon)\\,\\mathbf{I}$ 是二维偏应变（$\\mathbf{I}$ 是单位张量）。母空间双线性形函数 $N_{i}(\\xi,\\eta)$，$i=1,\\dots,4$，定义在 $[-1,1]\\times[-1,1]$上，且该矩形的等参映射是仿射的，其雅可比行列式为 $|J|=ab/4$。\n\n从该能量密度和虚功原理出发，推导分解为体积和偏量贡献的单元级刚度矩阵，并实施选择性减缩积分 (SRI)：使用权重为 4 的单点高斯求积在 $(\\xi,\\eta)=(0,0)$ 处计算体积贡献，并使用权重为 1 的 $2\\times 2$ 高斯法则在 $(\\xi,\\eta)=\\big(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3}\\big)$ 处计算偏量贡献。对应变和应力使用二维 Voigt 标记法，其中应变-位移矩阵 $B(\\xi,\\eta)$ 由 $N_{i,x}(\\xi,\\eta)$ 和 $N_{i,y}(\\xi,\\eta)$ 构造，且 $N_{i,x}=(2/a)\\,N_{i,\\xi}$，$N_{i,y}=(2/b)\\,N_{i,\\eta}$，以及\n$$\nN_{1}=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\n其导数为\n$$\nN_{1,\\xi}=-\\tfrac{1}{4}(1-\\eta),\\quad\nN_{2,\\xi}=\\tfrac{1}{4}(1-\\eta),\\quad\nN_{3,\\xi}=\\tfrac{1}{4}(1+\\eta),\\quad\nN_{4,\\xi}=-\\tfrac{1}{4}(1+\\eta),\n$$\n和\n$$\nN_{1,\\eta}=-\\tfrac{1}{4}(1-\\xi),\\quad\nN_{2,\\eta}=-\\tfrac{1}{4}(1+\\xi),\\quad\nN_{3,\\eta}=\\tfrac{1}{4}(1+\\xi),\\quad\nN_{4,\\eta}=\\tfrac{1}{4}(1-\\xi).\n$$\n将最终的刚度矩阵表示为以 $a$、$b$、$K$、$\\mu$ 和应变-位移矩阵 $B(\\xi,\\eta)$ 表示的单个闭式解析表达式。您的最终答案必须是一个计算式，具体来说是通过 SRI 计算得到的单元刚度的单个解析表达式。不需要进行数值舍入。",
            "solution": "该问题要求针对一个由单个双线性四边形 ($Q_4$) 单元离散化的二维小应变各向同性固体的特定情况，推导其单元级刚度矩阵。推导过程必须采用选择性减缩积分 (SRI) 技术。\n\n在线性弹性力学的有限元法中，单元刚度矩阵 $k^e$ 的一般表达式由虚功原理得到，并由在单元体积 $\\Omega^e$ 上的积分给出：\n$$\nk^e = \\int_{\\Omega^e} B^T D B \\, d\\Omega\n$$\n其中 $B$ 是应变-位移矩阵，$D$ 是在 Voigt 标记法中关联应力和应变的本构矩阵。\n\n对于等参单元，该积分被转换到母域，即 $(\\xi, \\eta)$ 坐标系下的正方形 $[-1,1]\\times[-1,1]$。微分体积元变为 $d\\Omega = t|J|d\\xi d\\eta$，其中 $t$ 是单元厚度（我们假设 $t=1$），$|J|$ 是坐标映射的雅可比行列式。问题指明，对于给定的矩形单元，有 $|J| = ab/4$。因此，刚度矩阵积分为：\n$$\nk^e = \\int_{-1}^{1} \\int_{-1}^{1} B(\\xi, \\eta)^T D B(\\xi, \\eta) \\left(\\frac{ab}{4}\\right) d\\xi d\\eta\n$$\n\n问题指明了储存能量密度 $W$ 分解为体积部分和偏量部分：\n$$\nW = W_{vol} + W_{dev} = \\tfrac{1}{2}K\\big(\\operatorname{tr}\\epsilon\\big)^{2} + \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}}\n$$\n这种能量分解导致了本构矩阵 $D = D_{vol} + D_{dev}$ 的相应加法分解。我们针对一个二维问题，使用 Voigt 标记法推导这些矩阵，其中应变向量为 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^T$，而 $\\gamma_{xy} = 2\\epsilon_{xy}$ 是工程剪应变。\n\n体积能量项为 $W_{vol} = \\frac{1}{2}K(\\epsilon_{xx}+\\epsilon_{yy})^2$。在二次型 $\\frac{1}{2}\\boldsymbol{\\epsilon}^T D_{vol} \\boldsymbol{\\epsilon}$ 中，这对应于体积本构矩阵：\n$$\nD_{vol} = K \\begin{pmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\n\n偏量能量项为 $W_{dev} = \\mu\\,\\epsilon_{\\text{dev}}:\\epsilon_{\\text{dev}}$。对于二维应变状态，偏应变张量为 $\\epsilon_{dev} = \\epsilon - \\tfrac{1}{2}(\\operatorname{tr}\\epsilon)\\mathbf{I}$，而 $\\epsilon_{dev}:\\epsilon_{dev}$ 项变为 $\\frac{1}{2}(\\epsilon_{xx}-\\epsilon_{yy})^2 + \\frac{1}{2}\\gamma_{xy}^2$。因此，$W_{dev} = \\frac{\\mu}{2}\\left((\\epsilon_{xx}-\\epsilon_{yy})^2 + \\gamma_{xy}^2\\right)$。在二次型 $\\frac{1}{2}\\boldsymbol{\\epsilon}^T D_{dev} \\boldsymbol{\\epsilon}$ 中，这对应于偏量本构矩阵：\n$$\nD_{dev} = \\mu \\begin{pmatrix} 1  -1  0 \\\\ -1  1  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n随着本构矩阵的分解，刚度矩阵也相应分解：\n$$\nk^e = k^e_{vol} + k^e_{dev} = \\frac{ab}{4} \\int_{-1}^{1} \\int_{-1}^{1} B^T D_{vol} B \\, d\\xi d\\eta + \\frac{ab}{4} \\int_{-1}^{1} \\int_{-1}^{1} B^T D_{dev} B \\, d\\xi d\\eta\n$$\n\n选择性减缩积分 (SRI) 方法使用不同的数值求积法则来计算这两个积分。\n1.  体积部分 $k^e_{vol}$ 使用单点高斯求积法则进行积分。单个求积点为 $(\\xi_v, \\eta_v) = (0,0)$，权重为 $w_v = 4$。该积分近似为：\n$$\nk^e_{vol} \\approx \\frac{ab}{4} \\left( w_v \\cdot B^T(0,0) D_{vol} B(0,0) \\right) = \\frac{ab}{4} \\left( 4 \\cdot B^T(0,0) D_{vol} B(0,0) \\right) = ab B^T(0,0) D_{vol} B(0,0)\n$$\n\n2.  偏量部分 $k^e_{dev}$ 使用 $2\\times2$ 高斯求积法则进行积分。这涉及四个求积点，记为 $(\\xi_j, \\eta_j)$，$j=1, \\dots, 4$，它们是 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$。每个点的权重为 $w_j=1$。该积分通过对这四个点的求和来近似：\n$$\nk^e_{dev} \\approx \\frac{ab}{4} \\sum_{j=1}^{4} \\left( w_j \\cdot B^T(\\xi_j, \\eta_j) D_{dev} B(\\xi_j, \\eta_j) \\right) = \\frac{ab}{4} \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) D_{dev} B(\\xi_j, \\eta_j)\n$$\n\n将两部分组合起来，便得到通过 SRI 计算的单元刚度矩阵的最终表达式。问题要求用给定的参数和矩阵 $B(\\xi, \\eta)$ 来表示此表达式。我们将推导出的矩阵 $D_{vol}$ 和 $D_{dev}$ 代入 $k^e_{vol}$ 和 $k^e_{dev}$ 的表达式中。设四个偏量求积点的集合为 $\\mathcal{Q}_{dev} = \\{(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})\\}$。最终的刚度矩阵为：\n$$\nk^e_{SRI} = ab \\, B^T(0,0) D_{vol} B(0,0) + \\frac{ab}{4} \\sum_{(\\xi,\\eta) \\in \\mathcal{Q}_{dev}} B^T(\\xi,\\eta) D_{dev} B(\\xi,\\eta)\n$$\n代入 $D_{vol}$ 和 $D_{dev}$ 的显式形式：\n$$\nk^e_{SRI} = ab \\cdot K \\cdot B^T(0,0) \\begin{pmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  0 \\end{pmatrix} B(0,0) + \\frac{ab}{4} \\cdot \\mu \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) \\begin{pmatrix} 1  -1  0 \\\\ -1  1  0 \\\\ 0  0  1 \\end{pmatrix} B(\\xi_j, \\eta_j)\n$$\n其中求和是针对四个点 $(\\xi_j, \\eta_j) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ 进行的。这就是使用指定的 SRI 方案计算得到的刚度矩阵的单个解析表达式。",
            "answer": "$$\n\\boxed{ab K B^T(0,0) \\begin{pmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  0 \\end{pmatrix} B(0,0) + \\frac{ab\\mu}{4} \\sum_{j=1}^{4} B^T(\\xi_j, \\eta_j) \\begin{pmatrix} 1  -1  0 \\\\ -1  1  0 \\\\ 0  0  1 \\end{pmatrix} B(\\xi_j, \\eta_j) \\quad \\text{其中} \\quad (\\xi_j, \\eta_j) \\in \\{(\\pm\\frac{1}{\\sqrt{3}}, \\pm\\frac{1}{\\sqrt{3}})\\}}\n$$"
        },
        {
            "introduction": "在推导出单元级别的刚度矩阵后，下一步自然是将其应用于一个完整的边界值问题中，以检验其宏观效果。这项编程练习将要求您在一个容易引发体积锁定的典型算例中，分别使用完全积分（FI）和选择性减缩积分（SRI）进行求解。通过实现这两种方法，并将其计算结果与高精度参考解进行定量比较，您将直观地感受到SRI在缓解数值锁定、提高粗网格下解的精度方面的显著优势。",
            "id": "2592773",
            "problem": "考虑一个在矩形域 $\\Omega = [0,W] \\times [0,H]$ 上的二维小应变、线弹性平面应变边界值问题，其边界为 $\\partial \\Omega = \\Gamma_u \\cup \\Gamma_t$。其中，底边 $\\Gamma_u = \\{(x,0): 0 \\le x \\le W\\}$ 被固定，具有指定的零位移；顶边 $\\Gamma_t = \\{(x,H): 0 \\le x \\le W\\}$ 承受一个大小为 $p$、沿 $y$ 轴负方向作用的均布面力。左右两边为无面力边界。根据虚功原理推导出的控制弱形式为\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}\\Omega = \\int_{\\Gamma_t} \\boldsymbol{t} \\cdot \\boldsymbol{v} \\, \\mathrm{d}\\Gamma\n$$\n对于在 $\\Gamma_u$ 上为零的所有容许虚位移 $\\boldsymbol{v}$ 成立，其中 $\\boldsymbol{u} = (u_x,u_y)$ 是位移场，$\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$ 是小应变张量，$\\boldsymbol{t} = (0,-p)$ 是在 $\\Gamma_t$ 上的面力，$\\mathbf{C}$ 是平面应变条件下各向同性固体的四阶弹性张量，其特征由杨氏模量 $E$ 和泊松比 $\\nu$ 决定。在 Voigt 记法中，应变向量为 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$，其中 $\\gamma_{xy} = 2 \\epsilon_{xy}$，应力-应变关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\epsilon}$，其中\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix},\n\\quad\n\\mu = \\frac{E}{2(1+\\nu)}, \n\\quad\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)},\n$$\n体积模量为 $\\kappa = \\lambda + \\tfrac{2}{3}\\mu$。\n\n使用等参双线性四边形 (Q4) 有限元，其节点形函数为\n$$\nN_1 = \\tfrac{1}{4}(1-\\xi)(1-\\eta), \\quad\nN_2 = \\tfrac{1}{4}(1+\\xi)(1-\\eta), \\quad\nN_3 = \\tfrac{1}{4}(1+\\xi)(1+\\eta), \\quad\nN_4 = \\tfrac{1}{4}(1-\\xi)(1+\\eta),\n$$\n这些形函数定义在母域 $(\\xi,\\eta) \\in [-1,1]^2$ 上，并使用标准等参映射到物理单元。令 $\\mathbf{B}(\\xi,\\eta)$ 表示 $3\\times 8$ 的应变-位移矩阵，使得对于单元节点位移向量 $\\mathbf{u}_e \\in \\mathbb{R}^8$，有 $\\boldsymbol{\\epsilon} = \\mathbf{B} \\, \\mathbf{u}_e$。\n\n您必须实现两种单元积分策略：\n\n1.  完全积分 (FI)：组集单元刚度矩阵\n    $$\n    \\mathbf{K}_e^{\\mathrm{FI}} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\, \\mathbf{B} \\, \\mathrm{d}\\Omega\n    $$\n    时，使用每个母坐标方向上的张量积两点高斯求积法（即 $2 \\times 2$ 高斯点），并使用顶边上的两点高斯求积法计算精确的边载荷。\n\n2.  选择性减缩积分 (SRI)：将本构算子分解为偏量部分和体积部分，\n    $$\n    \\mathbf{D} = \\mathbf{D}_{\\mathrm{dev}} + \\mathbf{D}_{\\mathrm{vol}},\n    \\quad\n    \\mathbf{D}_{\\mathrm{vol}} = \\kappa \\, \\mathbf{P}^\\top \\mathbf{P},\n    \\quad\n    \\mathbf{P} = \n    \\begin{bmatrix}\n    1  1  0\n    \\end{bmatrix},\n    \\quad\n    \\mathbf{D}_{\\mathrm{dev}} = \\mathbf{D} - \\mathbf{D}_{\\mathrm{vol}},\n    $$\n    并组集\n    $$\n    \\mathbf{K}_e^{\\mathrm{SRI}} = \\underbrace{\\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D}_{\\mathrm{dev}} \\, \\mathbf{B} \\, \\mathrm{d}\\Omega}_{\\text{使用 } 2\\times 2 \\text{ 高斯积分}}\n    +\n    \\underbrace{\\int_{\\Omega_e} (\\mathbf{P}\\mathbf{B})^\\top \\kappa \\, (\\mathbf{P}\\mathbf{B}) \\, \\mathrm{d}\\Omega}_{\\text{在 } (\\xi,\\eta)=(0,0) \\text{ 处使用 } 1\\times 1 \\text{ 高斯积分}}。\n    $$\n    顶边上的面力向量应始终使用沿该边的两点高斯求积法进行精确积分。\n\n在矩形域 $\\Omega$ 上构建一个由 $n_x \\times n_y$ 个 Q4 单元组成的结构化网格，在底边 $\\Gamma_u$ 上施加齐次 Dirichlet 边界条件 $\\boldsymbol{u} = \\boldsymbol{0}$，组集全局线性系统，并求解节点位移向量。令 $\\bar{u}_y$ 表示顶边的平均垂直位移，定义为\n$$\n\\bar{u}_y = \\frac{1}{|\\mathcal{N}_t|}\\sum_{a \\in \\mathcal{N}_t} (u_y)_a,\n$$\n其中 $\\mathcal{N}_t$ 是位于 $y=H$ 上的节点集合。作为高保真参考，对于下面定义的每个测试用例，使用 SRI 方法在一个宽度方向有 $N_x^{\\mathrm{ref}} = 32$ 个单元、高度方向有 $N_y^{\\mathrm{ref}} = \\max\\{2, \\mathrm{round}(32 \\, H/W)\\}$ 个单元的精细网格上计算 $\\bar{u}_y^{\\mathrm{ref}}$。\n\n定义方法 $m \\in \\{\\mathrm{FI}, \\mathrm{SRI}\\}$ 的标量响应的绝对误差为\n$$\ne_m = \\left| \\bar{u}_y^{(m)} - \\bar{u}_y^{\\mathrm{ref}} \\right|.\n$$\n定义 SRI 相对于完全积分的锁定误差减小因子（无量纲）为\n$$\n\\rho = \\frac{e_{\\mathrm{FI}} - e_{\\mathrm{SRI}}}{e_{\\mathrm{FI}}}.\n$$\n$\\rho$ 的正值表示选择性减缩积分减少了由锁定引起的计算响应误差。\n\n实现一个程序，为以下四个测试用例组成的测试套件计算 $\\rho$。所有物理量必须使用国际单位制 (SI) 处理，即长度单位为米 (m)，应力（包括 $E$ 和 $p$）单位为帕斯卡 (Pa)，位移单位为米 (m)。不使用角度。\n\n测试套件：\n- 用例 1（近不可压缩，中等网格）：$W = 1\\,\\mathrm{m}$，$H = 1\\,\\mathrm{m}$，$E = 1000\\,\\mathrm{Pa}$，$\\nu = 0.4999$，$p = 1\\,\\mathrm{Pa}$，$n_x = 2$，$n_y = 2$。\n- 用例 2（近不可压缩，非常粗的网格）：$W = 1\\,\\mathrm{m}$，$H = 1\\,\\mathrm{m}$，$E = 1000\\,\\mathrm{Pa}$，$\\nu = 0.4999$，$p = 1\\,\\mathrm{Pa}$，$n_x = 1$，$n_y = 1$。\n- 用例 3（近不可压缩，矩形域）：$W = 2\\,\\mathrm{m}$，$H = 1\\,\\mathrm{m}$，$E = 1000\\,\\mathrm{Pa}$，$\\nu = 0.4999$，$p = 1\\,\\mathrm{Pa}$，$n_x = 4$，$n_y = 2$。\n- 用例 4（可压缩，中等网格）：$W = 1\\,\\mathrm{m}$，$H = 1\\,\\mathrm{m}$，$E = 1000\\,\\mathrm{Pa}$，$\\nu = 0.3$，$p = 1\\,\\mathrm{Pa}$，$n_x = 2$，$n_y = 2$。\n\n您的程序应生成单行输出，其中包含四个用例的结果，格式为方括号内的逗号分隔列表，并按上述用例顺序排列。每个条目必须是一个实数（浮点数），等于该用例的 $\\rho$ 值，并四舍五入到六位小数。例如，输出行应类似于：“[0.123456,0.234567,0.345678,0.456789]”。",
            "solution": "我们从第一性原理推导计算过程。出发点是平面应变线弹性的弱形式：\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbf{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}\\Omega = \\int_{\\Gamma_t} \\boldsymbol{t} \\cdot \\boldsymbol{v} \\, \\mathrm{d}\\Gamma.\n$$\n使用等参双线性四边形 (Q4) 单元的离散化采用以下插值：\n$$\n\\boldsymbol{u}(x,y) \\approx \\sum_{a=1}^{4} N_a(\\xi,\\eta) \\, \\boldsymbol{u}_a, \n\\quad \n\\boldsymbol{\\epsilon} = \\mathbf{B}(\\xi,\\eta)\\, \\mathbf{u}_e,\n$$\n其中 $(\\xi,\\eta)$ 是母坐标，$\\{N_a\\}$ 是 $[-1,1]^2$ 上的双线性形函数，$\\mathbf{B}$ 将节点位移映射到 Voigt 应变向量 $\\boldsymbol{\\epsilon} = [\\epsilon_{xx}, \\epsilon_{yy}, \\gamma_{xy}]^\\top$，其中 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$。从母坐标到物理坐标的等参映射为 $x(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta) x_a$，$y(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta) y_a$，其雅可比矩阵为 $\\mathbf{J} = \\begin{bmatrix}\\partial x/\\partial \\xi  \\partial y/\\partial \\xi \\\\ \\partial x/\\partial \\eta  \\partial y/\\partial \\eta \\end{bmatrix}$。梯度 $\\partial N_a/\\partial x$ 和 $\\partial N_a/\\partial y$ 可由 $\\begin{bmatrix}\\partial N_a/\\partial x  \\partial N_a/\\partial y \\end{bmatrix} = \\begin{bmatrix}\\partial N_a/\\partial \\xi  \\partial N_a/\\partial \\eta\\end{bmatrix}\\mathbf{J}^{-1}$ 得出。于是，对于平面应变各向同性弹性，单元刚度矩阵为\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D}\\, \\mathbf{B} \\, \\mathrm{d}\\Omega,\n$$\n由顶边面力产生的单元节点力为\n$$\n\\mathbf{f}_e^{\\Gamma} = \\int_{\\Gamma_{t,e}} \\mathbf{N}^\\top \\boldsymbol{t} \\, \\mathrm{d}\\Gamma,\n$$\n其中 $\\mathbf{N} = \\mathrm{diag}(N_1,N_1,N_2,N_2,N_3,N_3,N_4,N_4)$ 映射向量值形函数，$\\Gamma_{t,e}$ 是顶边与该单元相交的部分。直线边界上的边界积分通过在母边 $(\\xi\\in[-1,1], \\eta = +1)$ 上进行一维高斯求积来计算，并使用正确的边雅可比因子 $\\| \\partial \\boldsymbol{x}/\\partial \\xi \\|$。\n\n对于体积的数值积分，Q4 单元的完全积分在每个母坐标方向上使用两点高斯求积法：点集为 $\\{\\pm 1/\\sqrt{3}\\}$，权重为 $\\{1,1\\}$，从而在正方形中得到 $2\\times 2$ 个点。减缩积分使用单点 $(\\xi,\\eta)=(0,0)$，权重为 $4$（一维权重 $\\{2\\}$ 的乘积）。然而，对整个刚度矩阵使用减缩积分通常会导致秩亏（沙漏现象）。为了减轻体积锁定——即当 $\\nu \\to 1/2$（近不可压缩）时观察到的人为刚化现象——一个稳定的折衷方案是选择性减缩积分 (SRI)。SRI 利用了弹性应变能密度分解为偏量部分和体积部分的标准方法：\n$$\nW = \\mu\\, \\boldsymbol{\\varepsilon}_{\\mathrm{dev}}:\\boldsymbol{\\varepsilon}_{\\mathrm{dev}} + \\frac{\\kappa}{2} (\\mathrm{tr}\\, \\boldsymbol{\\varepsilon})^2,\n$$\n其中剪切模量为 $\\mu$，体积模量为 $\\kappa = \\lambda + \\tfrac{2}{3}\\mu$。在限于平面内分量 $(\\epsilon_{xx},\\epsilon_{yy},\\gamma_{xy})$ 的 Voigt 形式中，我们用以下方式来近似这个分解：\n$$\n\\mathbf{D}_{\\mathrm{vol}} = \\kappa \\, \\mathbf{P}^\\top \\mathbf{P}, \n\\quad \\mathbf{P} = \\begin{bmatrix}1  1  0\\end{bmatrix},\n\\quad\n\\mathbf{D}_{\\mathrm{dev}} = \\mathbf{D} - \\mathbf{D}_{\\mathrm{vol}}.\n$$\n这种选择保留了平面内子空间中正确的静水压力刚度，同时确保偏量响应由 $\\mathbf{D}_{\\mathrm{dev}}$ 处理。然后，SRI 组集过程使用 $2\\times 2$ 高斯点对偏量部分进行积分，并使用位于 $(\\xi,\\eta)=(0,0)$ 的单个高斯点对体积部分进行积分。这种策略避免了沙漏模式（因为偏量部分被完全积分），并缓解了体积锁定（因为体积刚度以降阶积分，这软化了当 $\\nu$ 接近 $1/2$ 时在完全积分下出现的伪约束）。\n\n算法设计：\n1.  在 $[0,W]\\times[0,H]$ 上生成一个由 $n_x \\times n_y$ 个 Q4 单元组成的结构化网格，节点坐标位于笛卡尔网格上。每个单元的连接性遵循局部节点顺序：$(\\xi,\\eta)=(-1,-1)$ 左下，$(+1,-1)$ 右下，$(+1,+1)$ 右上，$(-1,+1)$ 左上。\n2.  对每个单元，计算单元刚度：\n    - 完全积分：$\\mathbf{K}_e^{\\mathrm{FI}} = \\sum_{i=1}^2 \\sum_{j=1}^2 \\mathbf{B}(\\xi_i,\\eta_j)^\\top \\mathbf{D} \\, \\mathbf{B}(\\xi_i,\\eta_j) \\, \\det\\mathbf{J}(\\xi_i,\\eta_j)$。\n    - SRI：$\\mathbf{K}_e^{\\mathrm{SRI}} = \\sum_{i=1}^2 \\sum_{j=1}^2 \\mathbf{B}^\\top \\mathbf{D}_{\\mathrm{dev}} \\mathbf{B} \\, \\det\\mathbf{J} + 4 \\, (\\mathbf{P}\\mathbf{B}(0,0))^\\top \\kappa \\, (\\mathbf{P}\\mathbf{B}(0,0)) \\, \\det\\mathbf{J}(0,0)$。\n    体积项中的因子 $4$ 是对应于母正方形面积的二维减缩高斯权重。\n3.  通过将单元贡献累加到全局自由度中，以稀疏的压缩稀疏行 (CSR) 格式组集全局刚度矩阵，其中每个节点贡献两个自由度 $(u_x,u_y)$。\n4.  通过对位于 $y=H$ 上的每个单元边使用两点高斯求积法沿边积分，从顶边压力组集全局载荷向量：$\\mathbf{f}_e^\\Gamma = \\sum_{k=1}^2 \\mathbf{N}^\\top(\\xi_k,\\eta=+1) \\, \\boldsymbol{t} \\, \\|\\partial \\boldsymbol{x}/\\partial \\xi\\| \\, w_k$。\n5.  通过提取自由度子矩阵和右侧向量，并在简化系统上求解，来对底边 $\\Gamma_u$ 施加齐次 Dirichlet 边界条件。这与弱形式一致，并避免了因显式修改行和列而导致的病态问题。\n6.  计算标量响应 $\\bar{u}_y$ 作为所有 $y=H$ 节点上的平均垂直位移。\n7.  对于每个测试用例，使用 SRI 和 $N_x^{\\mathrm{ref}} = 32$ 及 $N_y^{\\mathrm{ref}} = \\max\\{2, \\mathrm{round}(32 \\, H/W)\\}$ 的精细网格计算参考值 $\\bar{u}_y^{\\mathrm{ref}}$。计算绝对误差 $e_{\\mathrm{FI}}$ 和 $e_{\\mathrm{SRI}}$，最后计算减小因子 $\\rho = (e_{\\mathrm{FI}} - e_{\\mathrm{SRI}})/e_{\\mathrm{FI}}$。\n8.  将对应于测试套件的四个 $\\rho$ 值聚合到一个列表中，并按要求格式在一行中打印出来。\n\nSRI 为何能减少锁定：随着 $\\nu \\to 1/2$，拉梅 (Lamé) 参数 $\\lambda$（以及体积模量 $\\kappa$）无界增长，这使得刚度的体积部分在完全积分下占主导地位，在离散意义上过强地强制 $\\mathrm{tr}\\, \\boldsymbol{\\epsilon} \\approx 0$，从而产生过刚的响应（锁定）。通过以降阶方式积分体积贡献，SRI 有效地降低了与体积应变相关的离散约束强度，同时保留了偏量刚度和稳定性。因此，对于近不可压缩材料，与完全积分相比，SRI 在粗网格上通常能产生更柔顺和更准确的响应。对于中等可压缩材料（例如 $\\nu = 0.3$），两种方案给出的结果几乎相同，因为体积刚度不占主导地位。\n\n下面的程序实现了此过程，求解了测试套件，并按要求将四个减小因子作为单个逗号分隔列表四舍五入到六位小数进行打印。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef constitutive_plane_strain(E, nu):\n    lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    D = np.array([[lam + 2.0 * mu, lam, 0.0],\n                  [lam, lam + 2.0 * mu, 0.0],\n                  [0.0, 0.0, mu]], dtype=float)\n    kappa = lam + 2.0 * mu / 3.0\n    return D, lam, mu, kappa\n\ndef shape_Q4(ksi, eta):\n    N = np.array([\n        0.25 * (1 - ksi) * (1 - eta),\n        0.25 * (1 + ksi) * (1 - eta),\n        0.25 * (1 + ksi) * (1 + eta),\n        0.25 * (1 - ksi) * (1 + eta)\n    ], dtype=float)\n    dN_dksi = 0.25 * np.array([\n        -(1 - eta),\n        (1 - eta),\n        (1 + eta),\n        -(1 + eta)\n    ], dtype=float)\n    dN_deta = 0.25 * np.array([\n        -(1 - ksi),\n        -(1 + ksi),\n        (1 + ksi),\n        (1 - ksi)\n    ], dtype=float)\n    return N, dN_dksi, dN_deta\n\ndef B_matrix_Q4(xe, ksi, eta):\n    # xe: 4x2 nodal coordinates of the element (in order 1..4)\n    N, dN_dksi, dN_deta = shape_Q4(ksi, eta)\n    J = np.zeros((2, 2), dtype=float)\n    # Compute Jacobian J = [dx/dksi dy/dksi; dx/deta dy/deta]\n    J[0, 0] = np.dot(dN_dksi, xe[:, 0])\n    J[0, 1] = np.dot(dN_dksi, xe[:, 1])\n    J[1, 0] = np.dot(dN_deta, xe[:, 0])\n    J[1, 1] = np.dot(dN_deta, xe[:, 1])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    # Gradients with respect to x,y: grads[i,0]=dNi/dx, grads[i,1]=dNi/dy\n    grads = np.zeros((4, 2), dtype=float)\n    for i in range(4):\n        dN_parent = np.array([dN_dksi[i], dN_deta[i]])\n        dN_xy = invJ @ dN_parent\n        grads[i, 0] = dN_xy[0]\n        grads[i, 1] = dN_xy[1]\n    # Build B matrix (3x8) for plane strain with Voigt [exx, eyy, gxy]\n    B = np.zeros((3, 8), dtype=float)\n    for i in range(4):\n        Bi = np.array([\n            [grads[i, 0], 0.0],\n            [0.0, grads[i, 1]],\n            [grads[i, 1], grads[i, 0]]\n        ], dtype=float)\n        B[:, 2 * i:2 * i + 2] = Bi\n    return B, detJ\n\ndef element_stiffness_FI(xe, D):\n    # 2x2 Gauss integration\n    gp = 1.0 / np.sqrt(3.0)\n    ksi_list = [-gp, gp]\n    eta_list = [-gp, gp]\n    Ke = np.zeros((8, 8), dtype=float)\n    for ksi in ksi_list:\n        for eta in eta_list:\n            B, detJ = B_matrix_Q4(xe, ksi, eta)\n            Ke += (B.T @ D @ B) * detJ\n    return Ke\n\ndef element_stiffness_SRI(xe, D, kappa):\n    # D_dev = D - kappa * P^T P, with P = [1,1,0]\n    P = np.array([[1.0, 1.0, 0.0]], dtype=float)\n    D_vol = kappa * (P.T @ P)\n    D_dev = D - D_vol\n    # Deviatoric part with 2x2 Gauss\n    gp = 1.0 / np.sqrt(3.0)\n    ksi_list = [-gp, gp]\n    eta_list = [-gp, gp]\n    Ke = np.zeros((8, 8), dtype=float)\n    for ksi in ksi_list:\n        for eta in eta_list:\n            B, detJ = B_matrix_Q4(xe, ksi, eta)\n            Ke += (B.T @ D_dev @ B) * detJ\n    # Volumetric part with 1x1 Gauss at (0,0), weight = 4\n    Bc, detJc = B_matrix_Q4(xe, 0.0, 0.0)\n    Bvol = P @ Bc  # shape (1,8)\n    Ke += (Bvol.T @ (kappa * Bvol)) * detJc * 4.0\n    return Ke\n\ndef edge_load_top_Q4(xe, p):\n    # Compute consistent nodal load vector (8,) for top edge (eta=+1) traction t = (0,-p)\n    # 2-point Gauss along the edge\n    gp = 1.0 / np.sqrt(3.0)\n    s_list = [-gp, gp]\n    w_list = [1.0, 1.0]\n    fe = np.zeros(8, dtype=float)\n    eta = 1.0\n    for s, w in zip(s_list, w_list):\n        N, dN_dksi, dN_deta = shape_Q4(s, eta)\n        # Edge tangent vector dx/dksi at eta=+1\n        dx_dksi = np.dot(dN_dksi, xe[:, 0])\n        dy_dksi = np.dot(dN_dksi, xe[:, 1])\n        J_edge = np.sqrt(dx_dksi ** 2 + dy_dksi ** 2)\n        # Assemble contributions: only vertical traction\n        t = np.array([0.0, -p], dtype=float)\n        for i in range(4):\n            Ni = N[i]\n            fe[2 * i:2 * i + 2] += Ni * t * J_edge * w\n    return fe\n\ndef generate_mesh(W, H, nx, ny):\n    xs = np.linspace(0.0, W, nx + 1)\n    ys = np.linspace(0.0, H, ny + 1)\n    coords = np.array([(x, y) for y in ys for x in xs], dtype=float)\n    # Node numbering: row-major (x fastest), node index = j*(nx+1)+i\n    conn = []\n    for j in range(ny):\n        for i in range(nx):\n            n1 = j * (nx + 1) + i\n            n2 = n1 + 1\n            n3 = n1 + (nx + 1) + 1\n            n4 = n1 + (nx + 1)\n            conn.append([n1, n2, n3, n4])\n    conn = np.array(conn, dtype=int)\n    return coords, conn\n\ndef assemble_system(W, H, nx, ny, E, nu, p, method):\n    coords, conn = generate_mesh(W, H, nx, ny)\n    nnode = coords.shape[0]\n    ndof = 2 * nnode\n    D, lam, mu, kappa = constitutive_plane_strain(E, nu)\n\n    rows = []\n    cols = []\n    data = []\n    f = np.zeros(ndof, dtype=float)\n\n    # Assemble stiffness and traction\n    for e, nodes in enumerate(conn):\n        xe = coords[nodes, :]\n        if method == 'FI':\n            Ke = element_stiffness_FI(xe, D)\n        elif method == 'SRI':\n            Ke = element_stiffness_SRI(xe, D, kappa)\n        else:\n            raise ValueError(\"Unknown method\")\n        # Global dof indices\n        dofs = np.zeros(8, dtype=int)\n        for a_local, a in enumerate(nodes):\n            dofs[2 * a_local] = 2 * a\n            dofs[2 * a_local + 1] = 2 * a + 1\n        # Add to global COO\n        for i_local in range(8):\n            gi = dofs[i_local]\n            for j_local in range(8):\n                gj = dofs[j_local]\n                rows.append(gi)\n                cols.append(gj)\n                data.append(Ke[i_local, j_local])\n\n        # Top edge load if this element has its top edge on y=H\n        # Local top edge nodes are 3 (index 2) and 4 (index 3)\n        y3 = xe[2, 1]\n        y4 = xe[3, 1]\n        if np.isclose(y3, H) and np.isclose(y4, H):\n            fe = edge_load_top_Q4(xe, p)\n            for a_local, a in enumerate(nodes):\n                f[2 * a] += fe[2 * a_local]\n                f[2 * a + 1] += fe[2 * a_local + 1]\n\n    K = coo_matrix((data, (rows, cols)), shape=(ndof, ndof)).tocsr()\n\n    # Apply Dirichlet BCs on bottom edge: y=0, fix both u and v\n    bottom_nodes = np.where(np.isclose(coords[:, 1], 0.0))[0]\n    fixed_dofs = []\n    for n in bottom_nodes:\n        fixed_dofs.append(2 * n)     # u_x\n        fixed_dofs.append(2 * n + 1) # u_y\n    fixed_dofs = np.array(sorted(set(fixed_dofs)), dtype=int)\n\n    all_dofs = np.arange(ndof, dtype=int)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs, assume_unique=False)\n\n    K_ff = K[free_dofs, :][:, free_dofs]\n    f_f = f[free_dofs]\n\n    u = np.zeros(ndof, dtype=float)\n    if K_ff.shape[0] > 0:\n        u_f = spsolve(K_ff, f_f)\n        u[free_dofs] = u_f\n\n    # Average vertical displacement on top edge\n    top_nodes = np.where(np.isclose(coords[:, 1], H))[0]\n    v_dofs = 2 * top_nodes + 1\n    avg_v = float(np.mean(u[v_dofs])) if v_dofs.size > 0 else 0.0\n    return avg_v\n\ndef compute_reduction_for_case(W, H, nx, ny, E, nu, p):\n    # Reference using SRI on fine mesh\n    Nx_ref = 32\n    Ny_ref = int(np.round(32.0 * H / W))\n    Ny_ref = max(2, Ny_ref)\n    uref = assemble_system(W, H, Nx_ref, Ny_ref, E, nu, p, method='SRI')\n\n    # Coarse solutions\n    u_fi = assemble_system(W, H, nx, ny, E, nu, p, method='FI')\n    u_sri = assemble_system(W, H, nx, ny, E, nu, p, method='SRI')\n\n    e_fi = abs(u_fi - uref)\n    e_sri = abs(u_sri - uref)\n    rho = (e_fi - e_sri) / e_fi if e_fi != 0.0 else 0.0\n    return rho\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Parameters: (W, H, nx, ny, E, nu, p)\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1000.0, 0.4999, 1.0),\n        (1.0, 1.0, 1, 1, 1000.0, 0.4999, 1.0),\n        (2.0, 1.0, 4, 2, 1000.0, 0.4999, 1.0),\n        (1.0, 1.0, 2, 2, 1000.0, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        W, H, nx, ny, E, nu, p = case\n        rho = compute_reduction_for_case(W, H, nx, ny, E, nu, p)\n        # Round to six decimal places\n        results.append(f\"{rho:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "标准的SRI方法对整个单元的体积能项采用固定的减缩积分。本练习将带您探索一种更为精巧和前沿的自适应策略，即积分方案本身可以根据局部响应进行调整。您将设计并实现一个自适应SRI算法，其中减缩积分的程度由局部体积应变$|\\epsilon_{\\mathrm{vol}}|$的大小动态决定，使得积分方案能够“智能地”适应材料的局部行为。这项练习不仅能加深您对SRI本质的理解，还能锻炼您针对复杂问题（如异质材料）设计高级数值算法的能力。",
            "id": "3599208",
            "problem": "考虑一个二维域的小应变、静态、线性弹性问题，位移场为 $u=(u_x,u_y)$，其控制性强形式平衡方程为 $\\nabla\\cdot\\sigma=0$（无体力），线性应变为 $\\varepsilon=\\nabla^{\\mathrm{s}}u$，其中 $\\nabla^{\\mathrm{s}}$ 表示对称梯度。在平面应变条件下，本构关系为 $\\sigma=\\mathbb{C}:\\varepsilon$。材料为各向同性、空间变化的，由杨氏模量 $E>0$ 和泊松比 $\\nu(x,y)\\in(-1/2,1/2)$ 定义，其中拉梅参数为 $\\lambda=E\\nu/((1+\\nu)(1-2\\nu))$ 和 $\\mu=E/(2(1+\\nu))$。虚功原理的线性化得到双线性形式 $a(u,v)=\\int_{\\Omega}\\varepsilon(v):\\mathbb{C}:\\varepsilon(u)\\,\\mathrm{d}\\Omega$ 以及在单元上集成的离散有限元系统 $K d = f$。\n\n对于平面应变中的双线性四边形单元，设平面内 Voigt 记法为 $[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^{\\top}$，其中 $\\gamma_{xy}=2\\varepsilon_{xy}$。使用拉梅参数形式，本构矩阵可以加性地分裂为一个偏量部分和一个体积部分 $\\mathbb{C}=\\mathbb{C}_{\\mathrm{dev}}+\\mathbb{C}_{\\mathrm{vol}}$，使得在 Voigt 记法中，\n$$\n\\mathbb{C}_{\\mathrm{dev}}=\\begin{bmatrix}2\\mu00\\\\02\\mu0\\\\00\\mu\\end{bmatrix},\\quad\n\\mathbb{C}_{\\mathrm{vol}}=\\lambda\\begin{bmatrix}110\\\\110\\\\000\\end{bmatrix}.\n$$\n选择性减缩积分 (Selective Reduced Integration, SRI) 是一种通过对体积部分进行欠积分，同时对偏量部分进行完全积分来缓解体积锁定的技术。在此任务中，设计一种自适应 SRI 策略，其中每个单元体积部分的欠积分程度由体积应变的局部指标 $\\epsilon_{\\mathrm{vol}}=\\nabla\\cdot u=\\varepsilon_{xx}+\\varepsilon_{yy}$ 驱动。具体来说，为每个单元 $e$ 定义一个混合参数 $\\alpha_e\\in[0,1]$，该参数用于权衡使用完全高斯积分与减缩单点积分组装的体积刚度。$\\alpha_e$ 的值随局部指标 $|\\epsilon_{\\mathrm{vol}}|$ 的量级增大而增大，并在近不可压缩响应（即 $|\\epsilon_{\\mathrm{vol}}|$ 很小）时 $\\alpha_e\\rightarrow 0$。使用不动点迭代：从 $\\alpha_e=1$ 开始，求解 $u$，根据当前的 $u$ 更新 $\\alpha_e$，重新构建并求解，直到收敛或达到最大迭代次数。\n\n实现以下内容：\n\n- 域和离散化：一个单位正方形 $\\Omega=[0,1]\\times[0,1]$，厚度 $t=1$，用 $n_x\\times n_y$（其中 $n_x=n_y=8$）大小的双线性四边形单元的结构化网格进行离散化。\n\n- 运动学和单元矩阵：在父空间 $(\\xi,\\eta)\\in[-1,1]^2$ 中使用标准双线性形函数，通过等参映射计算应变-位移矩阵 $B$，并组装全局刚度矩阵 $K$：\n$$\nK_e=\\underbrace{\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{dev}}B\\,\\mathrm{d}\\Omega}_{\\text{完全 }2\\times 2\\text{ 高斯}}+\\underbrace{\\alpha_e\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{vol}}B\\,\\mathrm{d}\\Omega}_{\\text{完全 }2\\times 2\\text{ 高斯}}+\\underbrace{(1-\\alpha_e)\\int_{\\Omega_e}B^{\\top}\\mathbb{C}_{\\mathrm{vol}}B\\,\\mathrm{d}\\Omega}_{\\text{减缩 }1\\times 1\\text{ 高斯}}.\n$$\n\n- 边界条件：通过将底边 $y=0$ 固定为 $u_x=0$, $u_y=0$，并在顶边 $y=1$ 上施加水平位移 $u_x=\\gamma$ 和 $u_y=0$ 来施加简单剪切，其中 $\\gamma=0.01$。左、右两边为无牵引力边界。\n\n- 自适应指标和更新：每次求解后，计算单元平均体积应变量级\n$$\n\\bar{\\epsilon}_{\\mathrm{vol},e}=\\frac{1}{A_e}\\int_{\\Omega_e}|\\varepsilon_{xx}+\\varepsilon_{yy}|\\,\\mathrm{d}\\Omega,\n$$\n并通过一个单调映射更新 $\\alpha_e$\n$$\n\\alpha_e=\\min\\left(1,\\left(\\frac{\\bar{\\epsilon}_{\\mathrm{vol},e}}{\\epsilon_0}\\right)^{\\beta}\\right),\n$$\n其中 $\\epsilon_0=10^{-4}$ 且 $\\beta=1/2$。\n\n- 泊松比场：统一设置 $E=10^3$，并定义三个具有空间变化 $\\nu(x,y)$ 的测试用例：\n  1. 非均匀区域：当 $x  0.5$ 时 $\\nu(x,y)=0.499$，当 $x\\ge 0.5$ 时 $\\nu(x,y)=0.3$。\n  2. 均匀中等：对所有 $(x,y)\\in\\Omega$，$\\nu(x,y)=0.3$。\n  3. 均匀近不可压缩：对所有 $(x,y)\\in\\Omega$，$\\nu(x,y)=0.4999$。\n\n- 停止准则：迭代自适应更新，直到 $\\max_e|\\alpha_e^{(k)}-\\alpha_e^{(k-1)}|  10^{-3}$ 或达到最大迭代次数 5 次，以先发生者为准。\n\n- 稳健性度量：对于每个测试用例，收敛后，计算体积应变的全局 $L^2$ 范数\n$$\n\\left\\|\\epsilon_{\\mathrm{vol}}\\right\\|_{L^2(\\Omega)}=\\left(\\int_{\\Omega}(\\varepsilon_{xx}+\\varepsilon_{yy})^2\\,\\mathrm{d}\\Omega\\right)^{1/2},\n$$\n通过在单元上使用 $2\\times 2$ 高斯求积进行近似。\n\n您的程序必须实现上述算法，并生成一行输出，其中包含测试用例 1、2 和 3 的三个 $L^2$ 范数，格式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$。由于 $\\epsilon_{\\mathrm{vol}}$ 是无量纲的，所以范数也是无量纲的。不需要外部输入，代码必须能按原样运行。最终输出 $r_1$、$r_2$ 和 $r_3$ 必须是程序计算出的浮点数。\n\n测试套件：\n\n- 用例 1（非均匀区域）：当 $x  0.5$ 时 $\\nu(x,y)=0.499$，否则 $\\nu(x,y)=0.3$；预期自适应参数 $\\alpha_e$ 在左半部分较小。\n- 用例 2（均匀中等）：$\\nu(x,y)=0.3$；预期 $\\alpha_e$ 保持在 1 附近。\n- 用例 3（均匀近不可压缩）：$\\nu(x,y)=0.4999$；预期 $\\alpha_e$ 会显著下降并趋近于 0。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含结果，格式为用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3]$）。",
            "solution": "本任务是为一个二维平面应变线性弹性问题实现有限元方法 (FEM)，其中包含一个自适应选择性减缩积分 (SRI) 方案以减轻体积锁定。求解过程首先对域进行离散化，然后迭代地组装和求解线性系统，同时根据局部体积应变更新积分方案。\n\n**1. 离散化和运动学**\n域 $\\Omega=[0,1]\\times[0,1]$ 被离散化为一个 $8 \\times 8$ 的双线性四边形单元结构化网格。每个节点有两个自由度 (DOF)：$u_x$ 和 $u_y$。单元内的位移场通过双线性形函数 $N_i(\\xi, \\eta)$ 从节点位移 $d_e$ 插值得到：\n$$ u(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\begin{pmatrix} u_{x,i} \\\\ u_{y,i} \\end{pmatrix} $$\n其中 $(\\xi, \\eta) \\in [-1,1]^2$ 是父坐标。\n应变-位移关系 $\\varepsilon = \\nabla^s u$ 以矩阵形式表示为 $\\varepsilon = B d_e$，其中 $B$ 是应变-位移矩阵。对于双线性单元，$B$ 的分量取决于形函数相对于物理坐标 $(x,y)$ 的导数。这些导数通过链式法则以及从父坐标到物理坐标的等参映射的雅可比矩阵获得：\n$$ J = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)} = \\begin{bmatrix} \\partial x/\\partial \\xi  \\partial y/\\partial \\xi \\\\ \\partial x/\\partial \\eta  \\partial y/\\partial \\eta \\end{bmatrix} $$\n导数则为 $\\begin{pmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\end{pmatrix}$。对于 Voigt 应变 $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$，尺寸为 $3 \\times 8$ 的 $B$ 矩阵由单元所有四个节点的这些导数构成。\n\n**2. 单元刚度矩阵与自适应 SRI**\n单元刚度矩阵 $K_e$ 是通过在单元域 $\\Omega_e$ 上对平衡方程的弱形式进行积分计算的。该积分使用高斯求积进行数值近似。\n$$ K_e = \\int_{\\Omega_e} B^T \\mathbb{C} B \\, d\\Omega = \\int_{-1}^1 \\int_{-1}^1 B^T \\mathbb{C} B \\det(J) \\, d\\xi d\\eta \\approx \\sum_{gp} w_{gp} (B^T \\mathbb{C} B \\det(J))|_{gp} $$\n问题的核心是自适应 SRI 方案。本构矩阵 $\\mathbb{C}$ 被分裂为偏量部分 ($\\mathbb{C}_{\\mathrm{dev}}$) 和体积部分 ($\\mathbb{C}_{\\mathrm{vol}}$)。与形状改变相关的偏量部分总是使用 $2 \\times 2$ 高斯求积法则进行完全积分，这对于双线性单元是足够的。与体积改变相关的体积部分则使用完全积分 ($2 \\times 2$) 和减缩积分 (单点) 的混合方式进行积分。单元刚度为：\n$$ K_e = K_{e,\\mathrm{dev}}^{\\text{full}} + \\alpha_e K_{e,\\mathrm{vol}}^{\\text{full}} + (1-\\alpha_e) K_{e,\\mathrm{vol}}^{\\text{red}} $$\n混合参数 $\\alpha_e \\in [0,1]$ 根据局部体积响应进行自适应调整。在材料表现出近不可压缩行为（即体积应变小， $|\\nabla \\cdot u| \\approx 0$）的地方，使用较小的 $\\alpha_e$ 值（趋向于减缩积分），这也是体积锁定发生的地方。在可压缩区域，为了获得更好的精度，使用较大的 $\\alpha_e$ 值（趋向于完全积分）。\n\n**3. 迭代求解与自适应**\n采用不动点迭代方案：\n1.  **初始化**：对所有单元，设置混合参数 $\\alpha_e = 1$。这对应于处处使用完全积分。\n2.  **组装与求解**：使用当前的 $\\alpha_e$ 集合组装全局刚度矩阵 $K = \\sum_e K_e$。将狄利克雷边界条件（底边 $u_x=u_y=0$；顶边 $u_x=0.01, u_y=0$）应用于线性系统 $Kd=f$。由于没有外力，向量 $f$ 是通过处理系统以强制施加非齐次边界条件而产生的。求解全局位移向量 $d$。\n3.  **指标计算**：对于每个单元 $e$，根据新计算的位移场 $d$ 计算体积应变的平均量级：\n    $$ \\bar{\\epsilon}_{\\mathrm{vol},e}=\\frac{\\int_{\\Omega_e}|\\varepsilon_{xx}+\\varepsilon_{yy}|\\,\\mathrm{d}\\Omega}{\\int_{\\Omega_e}\\,\\mathrm{d}\\Omega} $$\n    这些积分使用 $2 \\times 2$ 高斯求积进行评估。\n4.  **更新 $\\alpha_e$**：使用给定的单调映射更新每个单元的混合参数：\n    $$ \\alpha_e \\leftarrow \\min\\left(1, \\left(\\frac{\\bar{\\epsilon}_{\\mathrm{vol},e}}{\\epsilon_0}\\right)^{\\beta}\\right) $$\n    其中 $\\epsilon_0=10^{-4}$ 且 $\\beta=1/2$。\n5.  **收敛性检查**：将新计算的 $\\alpha_e$ 值与前一次迭代的值进行比较。如果最大绝对变化量 $\\max_e|\\alpha_e^{(k)}-\\alpha_e^{(k-1)}|$ 低于容差 $10^{-3}$，或者达到了最大迭代次数 (5)，则过程终止。否则，返回步骤 2。\n\n**4. 最终度量计算**\n收敛后，通过计算整个域上体积应变的全局 $L^2$ 范数来量化解的稳健性：\n$$ \\|\\epsilon_{\\mathrm{vol}}\\|_{L^2(\\Omega)} = \\left( \\sum_e \\int_{\\Omega_e} (\\varepsilon_{xx}+\\varepsilon_{yy})^2\\,\\mathrm{d}\\Omega \\right)^{1/2} $$\n该积分也通过在每个单元上使用 $2 \\times 2$ 高斯求积进行近似。对由不同泊松比 $\\nu(x,y)$ 空间分布定义的三个测试用例中的每一个重复此过程，从而产生三个最终的范数值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive selective reduced integration finite element method\n    for a 2D plane strain elasticity problem and computes a robustness metric for three test cases.\n    \"\"\"\n    \n    # GLOBAL PARAMETERS\n    NX, NY = 8, 8\n    GAMMA = 0.01\n    E_MOD = 1000.0\n    EPSILON0 = 1e-4\n    BETA = 0.5\n    MAX_ITER = 5\n    TOL = 1e-3\n\n    def get_shape_functions_and_derivs(xi, eta):\n        \"\"\"Computes bilinear shape functions and their derivatives in parent coordinates.\"\"\"\n        xi_nodes = np.array([-1, 1, 1, -1])\n        eta_nodes = np.array([-1, -1, 1, 1])\n        \n        N = 0.25 * (1 + xi_nodes * xi) * (1 + eta_nodes * eta)\n        \n        dN_dxi = 0.25 * xi_nodes * (1 + eta_nodes * eta)\n        dN_deta = 0.25 * eta_nodes * (1 + xi_nodes * xi)\n        \n        dN_dxieta = np.vstack([dN_dxi, dN_deta])\n        return N, dN_dxieta\n\n    def get_constitutive_matrices(nu, E):\n        \"\"\"Computes deviatoric and volumetric constitutive matrices for plane strain.\"\"\"\n        lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n        \n        C_dev = np.array([[2 * mu, 0, 0], [0, 2 * mu, 0], [0, 0, mu]])\n        C_vol = lam * np.array([[1, 1, 0], [1, 1, 0], [0, 0, 0]])\n        return C_dev, C_vol\n\n    def run_simulation(nu_func):\n        \"\"\"Runs the full adaptive FEM simulation for a given material law nu_func(x, y).\"\"\"\n        # 1. MESH GENERATION\n        num_nodes_x = NX + 1\n        num_nodes_y = NY + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_dofs = 2 * num_nodes\n        \n        x_coords = np.linspace(0, 1, num_nodes_x)\n        y_coords = np.linspace(0, 1, num_nodes_y)\n        node_coords = np.array([[xi, yi] for yi in y_coords for xi in x_coords])\n        \n        elements = np.array([\n            [j * num_nodes_x + i, j * num_nodes_x + i + 1, (j + 1) * num_nodes_x + i + 1, (j + 1) * num_nodes_x + i]\n            for j in range(NY) for i in range(NX)\n        ])\n        num_elements = len(elements)\n\n        # 2. GAUSS QUADRATURE\n        gp_1d = 1.0 / np.sqrt(3)\n        quad_points_2x2 = [(-gp_1d, -gp_1d, 1.0), (gp_1d, -gp_1d, 1.0), (gp_1d, gp_1d, 1.0), (-gp_1d, gp_1d, 1.0)]\n        quad_point_1x1 = [(0.0, 0.0, 4.0)]\n\n        # 3. BOUNDARY CONDITIONS\n        fixed_dofs = {}\n        for i in range(num_nodes_x):\n            # Bottom edge (y=0)\n            node_idx_bottom = i\n            fixed_dofs[2 * node_idx_bottom] = 0.0\n            fixed_dofs[2 * node_idx_bottom + 1] = 0.0\n            # Top edge (y=1)\n            node_idx_top = NY * num_nodes_x + i\n            fixed_dofs[2 * node_idx_top] = GAMMA\n            fixed_dofs[2 * node_idx_top + 1] = 0.0\n\n        all_dofs = np.arange(num_dofs)\n        fixed_dof_indices = list(fixed_dofs.keys())\n        free_dofs = np.setdiff1d(all_dofs, fixed_dof_indices)\n\n        # 4. ADAPTIVE ITERATION\n        alphas = np.ones(num_elements)\n        d = np.zeros(num_dofs)\n\n        for k in range(MAX_ITER):\n            alphas_prev = alphas.copy()\n            K = np.zeros((num_dofs, num_dofs))\n            \n            for e_idx, el_nodes in enumerate(elements):\n                el_coords = node_coords[el_nodes]\n                alpha_e = alphas[e_idx]\n\n                Ke_dev = np.zeros((8, 8))\n                Ke_vol_full = np.zeros((8, 8))\n                \n                # Full integration (2x2)\n                for xi, eta, w in quad_points_2x2:\n                    N, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                    J = dN_dxieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B = np.zeros((3, 8))\n                    dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                    B[0, 0::2] = dN_dxy[0, :]\n                    B[1, 1::2] = dN_dxy[1, :]\n                    B[2, 0::2] = dN_dxy[1, :]\n                    B[2, 1::2] = dN_dxy[0, :]\n                    \n                    gp_coords = N @ el_coords\n                    nu = nu_func(gp_coords[0], gp_coords[1])\n                    C_dev, C_vol = get_constitutive_matrices(nu, E_MOD)\n                    \n                    Ke_dev += B.T @ C_dev @ B * detJ * w\n                    Ke_vol_full += B.T @ C_vol @ B * detJ * w\n\n                # Reduced integration (1x1)\n                Ke_vol_red = np.zeros((8, 8))\n                xi, eta, w = quad_point_1x1[0]\n                N, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                J = dN_dxieta @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                B[0, 0::2] = dN_dxy[0, :]\n                B[1, 1::2] = dN_dxy[1, :]\n                B[2, 0::2] = dN_dxy[1, :]\n                B[2, 1::2] = dN_dxy[0, :]\n\n                gp_coords = N @ el_coords\n                nu = nu_func(gp_coords[0], gp_coords[1])\n                _, C_vol = get_constitutive_matrices(nu, E_MOD)\n                \n                Ke_vol_red = B.T @ C_vol @ B * detJ * w\n                \n                Ke = Ke_dev + alpha_e * Ke_vol_full + (1 - alpha_e) * Ke_vol_red\n                \n                dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n                K[np.ix_(dof_indices, dof_indices)] += Ke\n\n            F = np.zeros(num_dofs)\n            for dof_idx, val in fixed_dofs.items():\n                F[free_dofs] -= K[free_dofs, dof_idx] * val\n            \n            K_reduced = K[np.ix_(free_dofs, free_dofs)]\n            F_reduced = F[free_dofs]\n            \n            d_free = np.linalg.solve(K_reduced, F_reduced)\n            \n            d[free_dofs] = d_free\n            for dof_idx, val in fixed_dofs.items():\n                d[dof_idx] = val\n\n            for e_idx, el_nodes in enumerate(elements):\n                dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n                d_e = d[dof_indices]\n                el_coords = node_coords[el_nodes]\n                \n                vol_strain_integral, area = 0.0, 0.0\n                for xi, eta, w in quad_points_2x2:\n                    _, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                    J = dN_dxieta @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B = np.zeros((3, 8))\n                    dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                    B[0, 0::2] = dN_dxy[0, :]\n                    B[1, 1::2] = dN_dxy[1, :]\n                    B[2, 0::2] = dN_dxy[1, :]\n                    B[2, 1::2] = dN_dxy[0, :]\n                    \n                    strain = B @ d_e\n                    vol_strain = strain[0] + strain[1]\n                    \n                    vol_strain_integral += np.abs(vol_strain) * detJ * w\n                    area += detJ * w\n                \n                avg_vol_strain = vol_strain_integral / area if area > 0 else 0\n                alphas[e_idx] = min(1.0, (avg_vol_strain / EPSILON0)**BETA)\n\n            if np.max(np.abs(alphas - alphas_prev))  TOL:\n                break\n                \n        # 5. POST-PROCESSING\n        vol_strain_sq_integral = 0.0\n        for e_idx, el_nodes in enumerate(elements):\n            dof_indices = np.ravel([[2 * n, 2 * n + 1] for n in el_nodes])\n            d_e = d[dof_indices]\n            el_coords = node_coords[el_nodes]\n            \n            for xi, eta, w in quad_points_2x2:\n                _, dN_dxieta = get_shape_functions_and_derivs(xi, eta)\n                J = dN_dxieta @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                dN_dxy = np.linalg.inv(J) @ dN_dxieta\n                B[0, 0::2] = dN_dxy[0, :]\n                B[1, 1::2] = dN_dxy[1, :]\n                B[2, 0::2] = dN_dxy[1, :]\n                B[2, 1::2] = dN_dxy[0, :]\n\n                strain = B @ d_e\n                vol_strain = strain[0] + strain[1]\n                vol_strain_sq_integral += (vol_strain**2) * detJ * w\n                \n        return np.sqrt(vol_strain_sq_integral)\n\n    # --- DEFINE AND RUN TEST CASES ---\n    test_cases = [\n        lambda x, y: 0.499 if x  0.5 else 0.3,  # Case 1\n        lambda x, y: 0.3,                          # Case 2\n        lambda x, y: 0.4999                        # Case 3\n    ]\n\n    results = [run_simulation(nu_func) for nu_func in test_cases]\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}