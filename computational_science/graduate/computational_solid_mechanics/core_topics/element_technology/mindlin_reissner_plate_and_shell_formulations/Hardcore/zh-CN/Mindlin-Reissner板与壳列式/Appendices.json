{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在解决 Mindlin-Reissner 板单元实现中的一个核心问题：剪切锁定和沙漏。在薄板分析中，为了克服剪切锁定，我们常常采用选择性减缩积分 (SRI) 技术，但这会无意中引入被称为“沙漏模式”的非物理、零能量变形模式。本练习  将指导你通过分析应变-位移矩阵的零空间来识别这些伪模式，并实现一种既能惩罚这些模式又不会重新引入剪切锁定的稳定化技术。",
            "id": "3581819",
            "problem": "考虑一个四节点双线性四边形单元的 Mindlin–Reissner 板理论，每个节点有三个节点自由度：横向位移 $w$ 以及法线转角 $\\theta_x$ 和 $\\theta_y$。横向剪切应变定义为 $\\gamma_{xz} = \\theta_x + \\partial w / \\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w / \\partial y$。横向剪切应力合力遵循 $\\mathbf{Q} = k_s \\, G \\, t \\, \\boldsymbol{\\gamma}$，其中 $k_s$ 是剪切修正因子，$G$ 是剪切模量，$t$ 是板厚，$\\boldsymbol{\\gamma} = [\\gamma_{xz}, \\gamma_{yz}]^\\top$。\n\n在从父正方形 $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$ 映射到物理坐标中尺寸为 $h_x$ 和 $h_y$ 的矩形的单个等参双线性（四节点）单元的设置下进行工作。在单元中心 $(\\xi, \\eta) = (0,0)$，对于 $i=1,2,3,4$，双线性形函数为 $N_i = \\tfrac{1}{4}$。在中心点，关于物理坐标的导数通过等参映射的雅可比矩阵获得，给出 $\\partial N_i / \\partial x = (2/h_x) \\, \\partial N_i / \\partial \\xi$ 和 $\\partial N_i / \\partial y = (2/h_y) \\, \\partial N_i / \\partial \\eta$，其中 $\\partial N_i / \\partial \\xi$ 和 $\\partial N_i / \\partial \\eta$ 在 $(\\xi,\\eta)=(0,0)$ 处的计算如下：对于节点 $1$（位于 $(-1,-1)$），$\\partial N_1/\\partial \\xi = -\\tfrac{1}{4}$，$\\partial N_1/\\partial \\eta = -\\tfrac{1}{4}$；对于节点 $2$（位于 $(+1,-1)$），$\\partial N_2/\\partial \\xi = +\\tfrac{1}{4}$，$\\partial N_2/\\partial \\eta = -\\tfrac{1}{4}$；对于节点 $3$（位于 $(+1,+1)$），$\\partial N_3/\\partial \\xi = +\\tfrac{1}{4}$，$\\partial N_3/\\partial \\eta = +\\tfrac{1}{4}$；对于节点 $4$（位于 $(-1,+1)$），$\\partial N_4/\\partial \\xi = -\\tfrac{1}{4}$，$\\partial N_4/\\partial \\eta = +\\tfrac{1}{4}$。\n\n使用这些量，构建单元中心处的横向剪应变-位移算子 $\\mathbf{B}_s$，使得 $\\boldsymbol{\\gamma} = \\mathbf{B}_s \\, \\mathbf{d}$，其中 $\\mathbf{d} \\in \\mathbb{R}^{12}$ 按顺序 $[w_1,\\theta_{x1},\\theta_{y1},w_2,\\theta_{x2},\\theta_{y2},w_3,\\theta_{x3},\\theta_{y3},w_4,\\theta_{x4},\\theta_{y4}]^\\top$ 集合了节点自由度。在选择性减缩积分（SRI）下，即仅对剪切部分使用单个中心高斯点，横向剪切刚度矩阵为\n$$\n\\mathbf{K}_s = k_s \\, G \\, t \\, A \\, \\mathbf{B}_s^\\top \\mathbf{B}_s,\n$$\n其中 $A = h_x h_y$ 是单元面积。这种减缩积分在剪切部分引入了伪零能模式（沙漏模式），因为 $\\text{rank}(\\mathbf{B}_s) \\le 2$，而有 $12$ 个自由度。\n\n您的任务是：\n- 通过计算 $\\mathbf{B}_s$ 的零空间并区分物理上容许的无剪切刚体子空间与伪沙漏子空间，直接从第一性原理推导 SRI 剪切离散化引入的沙漏模式。无剪切刚体子空间由三种模式张成：恒定横向平移（所有 $w_i$ 相等且 $\\theta_{xi}=\\theta_{yi}=0$），绕 y 轴的刚性转动（$w$ 在 $x$ 方向上呈线性变化，$\\theta_x = -\\partial w/\\partial x$ 为常数且 $\\theta_y=0$），以及绕 x 轴的刚性转动（$w$ 在 $y$ 方向上呈线性变化，$\\theta_y = -\\partial w/\\partial y$ 为常数且 $\\theta_x=0$）。您使用的所有数学实体都必须用 LaTeX 书写。例如，您必须将 $\\mathbf{B}_s$ 的零空间表示为 $\\text{Null}(\\mathbf{B}_s)$，并明确使用其基向量进行操作。\n- 提出并实现一种仅惩罚沙漏子空间而不影响物理上容许的无剪切子空间的稳定化方法，从而在不重新引入剪切锁死的情况下抑制沙漏模式。构建一个稳定化矩阵\n$$\n\\mathbf{K}_{\\text{hg}} = \\eta \\, k_s \\, G \\, t \\, \\frac{A}{L} \\sum_{i=1}^{n_{\\text{hg}}} \\mathbf{h}_i \\mathbf{h}_i^\\top,\n$$\n其中 $\\{\\mathbf{h}_1,\\ldots,\\mathbf{h}_{n_{\\text{hg}}}\\}$ 是通过从 $\\text{Null}(\\mathbf{B}_s)$ 中移除刚体无剪切基底得到的沙漏子空间的一组标准正交基，$\\eta$ 是一个用户定义的无量纲稳定化参数，$L$ 是一个特征长度。取 $L = \\sqrt{A}$。您必须通过计算证明，这种稳定化方法不会改变恒定剪切状态的能量。\n- 通过计算稳定化前 $\\mathbf{K}_s$ 和稳定化后 $\\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$ 的近零特征值的数量来量化沙漏抑制效果，特征值的绝对容差定义为 $\\epsilon = 10^{-9} \\, k_s \\, G \\, t \\, A$。\n- 通过执行恒定剪切分片检验来验证稳定化不会重新引入锁死。对于给定的恒定剪切 $\\gamma_{xz} = \\gamma_0$（其中 $\\gamma_0$ 是给定的标量），为所有节点设置节点自由度为 $w_i = 0$，$\\theta_{xi} = \\gamma_0$ 和 $\\theta_{yi} = 0$。计算离散剪切能\n$$\nU_{\\text{disc}} = \\tfrac{1}{2} \\, \\mathbf{d}^\\top \\mathbf{K} \\, \\mathbf{d},\n$$\n其中 $\\mathbf{K} \\in \\{\\mathbf{K}_s, \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}\\}$，并与精确连续介质能量\n$$\nU_{\\text{exact}} = \\tfrac{1}{2} \\, k_s \\, G \\, t \\, A \\, \\gamma_0^2\n$$\n进行比较。报告相对误差 $e = \\left| U_{\\text{disc}} / U_{\\text{exact}} - 1 \\right|$，以浮点数形式表示。\n\n角度单位不适用于此计算。为此数值实验目的，所有其他量均可视为无量纲，您应输出无单位的纯数字。\n\n实现要求：\n- 从杨氏模量 $E$ 和泊松比 $\\nu$ 计算 $G = E / \\left( 2 (1+\\nu) \\right)$。\n- 使用在 $(\\xi,\\eta)=(0,0)$ 处的 $N_i$ 和 $\\partial N_i / \\partial x$、$\\partial N_i / \\partial y$ 的精确公式以及到尺寸为 $h_x \\times h_y$ 的矩形物理坐标的映射来构建 $\\mathbf{B}_s$。\n- 计算 $\\mathbf{B}_s$ 的奇异值分解以提取 $\\text{Null}(\\mathbf{B}_s)$，然后使用正交投影移除刚体无剪切子空间。将剩余的沙漏基标准正交化。\n- 组装 $\\mathbf{K}_s$、$\\mathbf{K}_{\\text{hg}}$ 和稳定化矩阵 $\\mathbf{K}_\\text{stab} = \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$。\n- 使用对称特征求解器，以指定的容差 $\\epsilon$ 计算近零特征值的数量。\n- 执行恒定剪切分片检验并计算相对误差。\n\n测试套件：\n- 情况 1：$h_x = 1$，$h_y = 1$，$t = 0.2$，$E = 1.0 \\times 10^{10}$，$\\nu = 0.3$，$k_s = 5/6$，$\\eta = 0.1$，$\\gamma_0 = 0.01$。\n- 情况 2：$h_x = 2$，$h_y = 1$，$t = 0.2$，$E = 1.0 \\times 10^{10}$，$\\nu = 0.3$，$k_s = 5/6$，$\\eta = 0.1$，$\\gamma_0 = 0.01$。\n- 情况 3（边厚变化）：$h_x = 1$，$h_y = 1$，$t = 0.01$，$E = 1.0 \\times 10^{10}$，$\\nu = 0.3$，$k_s = 5/6$，$\\eta = 0.1$，$\\gamma_0 = 0.01$。\n\n对于每种情况，产生以下输出：\n- $\\mathbf{K}_s$ 的近零特征值的整数计数。\n- $\\mathbf{K}_\\text{stab}$ 的近零特征值的整数计数。\n- 使用 $\\mathbf{K}_s$ 进行恒定剪切分片检验的浮点数相对误差 $e_s$。\n- 使用 $\\mathbf{K}_\\text{stab}$ 进行恒定剪切分片检验的浮点数相对误差 $e_\\text{stab}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序如下：\n$[$count\\_zero\\_sri\\_case1,count\\_zero\\_stab\\_case1,e\\_s\\_case1,e\\_stab\\_case1,count\\_zero\\_sri\\_case2,count\\_zero\\_stab\\_case2,e\\_s\\_case2,e\\_stab\\_case2,count\\_zero\\_sri\\_case3,count\\_zero\\_stab\\_case3,e\\_s\\_case3,e\\_stab\\_case3$]$。",
            "solution": "该问题被评估为有效。它具有科学依据，是适定的、客观且自洽的，代表了计算固体力学领域的标准练习。\n\n### 1. 理论公式\n\n该问题旨在解决选择性减缩积分（SRI）下四节点四边形 Mindlin-Reissner 板单元中的剪切锁死和伪零能模式（沙漏）问题。我们将从第一性原理推导必要的矩阵，确定伪模式的来源，并实现一种稳定化技术。\n\n### 2. 应变-位移算子 $\\mathbf{B}_s$ 的推导\n\n单元内的位移场和转角场由节点自由度 $\\mathbf{d} \\in \\mathbb{R}^{12}$ 通过双线性形函数 $N_i(\\xi, \\eta)$ 插值得到：\n$$ w(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) w_i $$\n$$ \\theta_x(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{xi} $$\n$$ \\theta_y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{yi} $$\n节点自由度向量的顺序为 $\\mathbf{d} = [w_1, \\theta_{x1}, \\theta_{y1}, \\dots, w_4, \\theta_{x4}, \\theta_{y4}]^\\top$。\n\n横向剪切应变由 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$ 给出。代入插值场，我们得到：\n$$ \\gamma_{xz} = \\sum_{i=1}^4 \\left( N_i \\theta_{xi} + \\frac{\\partial N_i}{\\partial x} w_i \\right) $$\n$$ \\gamma_{yz} = \\sum_{i=1}^4 \\left( N_i \\theta_{yi} + \\frac{\\partial N_i}{\\partial y} w_i \\right) $$\n\n我们将此关系以矩阵形式表示为 $\\boldsymbol{\\gamma} = \\mathbf{B}_s \\mathbf{d}$，其中 $\\boldsymbol{\\gamma} = [\\gamma_{xz}, \\gamma_{yz}]^\\top$。应变-位移算子 $\\mathbf{B}_s$ 是一个 $2 \\times 12$ 的矩阵，由四个 $2 \\times 3$ 的节点块组成，$\\mathbf{B}_s = [\\mathbf{B}_{s1}, \\mathbf{B}_{s2}, \\mathbf{B}_{s3}, \\mathbf{B}_{s4}]$，其中：\n$$ \\mathbf{B}_{si} = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  N_i  0 \\\\ \\frac{\\partial N_i}{\\partial y}  0  N_i \\end{bmatrix} $$\n\n对于选择性减缩积分，这些量在单元中心的单个高斯点 $(\\xi, \\eta) = (0,0)$ 处求值。在此点，对所有 $i=1, \\dots, 4$ 都有 $N_i = 1/4$。对于尺寸为 $h_x \\times h_y$ 的矩形单元，形函数关于物理坐标的导数通过 $\\partial N_i/\\partial x = (2/h_x) \\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial y = (2/h_y) \\partial N_i/\\partial \\eta$ 与父域中的导数相关联。使用在中心点给出的 $\\partial N_i/\\partial \\xi$ 和 $\\partial N_i/\\partial \\eta$ 的值，我们构建完整的 $\\mathbf{B}_s$ 矩阵：\n$$ \\mathbf{B}_s = \\frac{1}{4} \\begin{bmatrix}\n-\\frac{2}{h_x}  1  0  \\frac{2}{h_x}  1  0  \\frac{2}{h_x}  1  0  -\\frac{2}{h_x}  1  0 \\\\\n-\\frac{2}{h_y}  0  1  -\\frac{2}{h_y}  0  1  \\frac{2}{h_y}  0  1  \\frac{2}{h_y}  0  1\n\\end{bmatrix} $$\n\n### 3. 零空间分析：刚体模式和沙漏模式\n\nSRI 下的剪切刚度矩阵为 $\\mathbf{K}_s = k_s G t A \\mathbf{B}_s^\\top \\mathbf{B}_s$，其中 $A=h_x h_y$ 是单元面积。$\\mathbf{K}_s$ 的秩与 $\\mathbf{B}_s$ 的秩相同。由于 $\\mathbf{B}_s$ 是一个具有两个线性无关行的 $2 \\times 12$ 矩阵，其秩为 $2$。根据秩-零度定理，其零空间 $\\text{Null}(\\mathbf{B}_s)$ 的维度是 $12 - 2 = 10$。这 $10$ 个向量对应于在中心产生零剪切应变并因此具有零剪切能的变形模式。\n\n这个 $10$ 维的零空间由物理上有意义的刚体模式和非物理的、伪的沙漏模式组成。\n\n#### 刚体无剪切子空间 ($V_{RB}$)\n物理上容许的无剪切模式子空间的维度为 $3$。其基向量是：\n1.  **恒定横向平移**：$w_i=c$，$\\theta_{xi}=0$，$\\theta_{yi}=0$。对于 $c=1$，向量为 $\\mathbf{v}_1 = [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]^\\top$。\n2.  **绕 y 轴的刚性转动**：一个角度为 $c$ 的转动对应于位移场 $w(x) = -c x$。这意味着 $\\theta_x = -\\partial w/\\partial x = c$ 且 $\\theta_y = 0$。对于节点坐标 $x_i \\in \\{-h_x/2, h_x/2\\}$，向量（对于 $c=1$）是 $\\mathbf{v}_2 = [h_x/2, 1, 0, -h_x/2, 1, 0, -h_x/2, 1, 0, h_x/2, 1, 0]^\\top$。\n3.  **绕 x 轴的刚性转动**：一个转动对应于 $w(y) = c y$。这意味着 $\\theta_y = -\\partial w/\\partial y = -c$ 且 $\\theta_x = 0$。对于节点坐标 $y_i \\in \\{-h_y/2, h_y/2\\}$，向量（对于 $c=1$）是 $\\mathbf{v}_3 = [-h_y/2, 0, -1, -h_y/2, 0, -1, h_y/2, 0, -1, h_y/2, 0, -1]^\\top$。\n\n#### 伪沙漏子空间 ($V_{HG}$)\n$\\text{Null}(\\mathbf{B}_s)$ 的剩余 $10 - 3 = 7$ 个维度构成了沙漏子空间 $V_{HG}$。该子空间是 $V_{RB}$ 在 $\\text{Null}(\\mathbf{B}_s)$ 内的正交补，即 $V_{HG} = \\text{Null}(\\mathbf{B}_s) \\cap V_{RB}^\\perp$。$V_{HG}$ 的一组标准正交基 $\\{\\mathbf{h}_1, \\dots, \\mathbf{h}_7\\}$ 是通过计算得到的。首先，通过 $\\mathbf{B}_s$ 的奇异值分解（SVD）获得 $\\text{Null}(\\mathbf{B}_s)$ 的一组标准正交基。然后，通过正交投影移除这些基向量中位于 $V_{RB}$ 内的分量，并将张成 $V_{HG}$ 的剩余向量重新进行标准正交化。\n\n### 4. 沙漏稳定化\n\n为了抑制伪模式，一个稳定化矩阵 $\\mathbf{K}_{\\text{hg}}$ 被加到 $\\mathbf{K}_s$ 上。该矩阵必须仅惩罚沙漏模式，而使刚体运动和恒定应变状态不受影响。提议的稳定化矩阵为：\n$$ \\mathbf{K}_{\\text{hg}} = \\eta \\, k_s \\, G \\, t \\, \\frac{A}{L} \\sum_{i=1}^{7} \\mathbf{h}_i \\mathbf{h}_i^\\top $$\n其中 $L=\\sqrt{A}$，因此 $A/L = \\sqrt{A}$。项 $\\mathbf{P}_{HG} = \\sum_{i=1}^{7} \\mathbf{h}_i \\mathbf{h}_i^\\top$ 是到沙漏子空间 $V_{HG}$ 的投影矩阵。\n\n稳定化后的刚度矩阵为 $\\mathbf{K}_{\\text{stab}} = \\mathbf{K}_s + \\mathbf{K}_{\\text{hg}}$。\n- 对于任何刚体模式 $\\mathbf{v} \\in V_{RB}$，$\\mathbf{K}_{\\text{hg}} \\mathbf{v} = \\mathbf{0}$，因为 $V_{HG}$ 和 $V_{RB}$ 是正交的。\n- 对于任何沙漏模式 $\\mathbf{h} \\in V_{HG}$，$\\mathbf{K}_s \\mathbf{h} = \\mathbf{0}$，但 $\\mathbf{K}_{\\text{hg}} \\mathbf{h}$ 非零，提供了必要的稳定化能量。\n因此，$\\mathbf{K}_{\\text{stab}}$ 的零空间维度为 3，仅由刚体模式张成。近零特征值的数量因此从 $10$ 减少到 $3$。\n\n### 5. 恒定剪切分片检验\n\n该检验验证了稳定化不会为恒定剪切状态引入人为刚度（即，不会导致剪切锁死）。我们考虑一个恒定剪切状态 $\\gamma_{xz}=\\gamma_0, \\gamma_{yz}=0$。相应的节点位移向量为 $\\mathbf{d}_{\\text{patch}} = [0, \\gamma_0, 0, \\dots, 0, \\gamma_0, 0]^\\top$。该状态的精确连续介质能量为 $U_{\\text{exact}} = \\frac{1}{2} k_s G t A \\gamma_0^2$。\n\n离散能量为 $U_{\\text{disc}} = \\frac{1}{2} \\mathbf{d}_{\\text{patch}}^\\top \\mathbf{K} \\mathbf{d}_{\\text{patch}}$。\n对于未稳定化的情况，$\\mathbf{K} = \\mathbf{K}_s$。离散应变为 $\\boldsymbol{\\gamma}_{\\text{disc}} = \\mathbf{B}_s \\mathbf{d}_{\\text{patch}} = [\\gamma_0, 0]^\\top$，与连续介质应变完全匹配。离散能量 $U_s = \\frac{1}{2} k_s G t A (\\mathbf{B}_s \\mathbf{d}_{\\text{patch}})^\\top(\\mathbf{B}_s \\mathbf{d}_{\\text{patch}}) = U_{\\text{exact}}$。因此，相对误差 $e_s$ 为零。\n\n对于稳定化的情况，$U_{\\text{stab}} = U_s + \\frac{1}{2} \\mathbf{d}_{\\text{patch}}^\\top \\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}}$。如果稳定化能量为零，即 $\\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$，则分片检验通过。恒定剪切模式 $\\mathbf{d}_{\\text{patch}}$ 是一种产生能量的模式，因此位于 $\\mathbf{B}_s^\\top$ 的值域内。$\\mathbf{B}_s^\\top$ 的值域是 $\\text{Null}(\\mathbf{B}_s)$ 的正交补。由于 $V_{HG} \\subset \\text{Null}(\\mathbf{B}_s)$，向量 $\\mathbf{d}_{\\text{patch}}$ 必须与 $V_{HG}$ 中的每个向量正交。因此，$\\mathbf{P}_{HG} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$，这意味着 $\\mathbf{K}_{\\text{hg}} \\mathbf{d}_{\\text{patch}} = \\mathbf{0}$。稳定化能量确实为零，且相对误差 $e_{\\text{stab}}$ 也为零。这证实了稳定化是一致的，并且不会重新引入锁死。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(hx, hy, t, E, nu, ks, eta, gamma0):\n    \"\"\"\n    Analyzes a 4-node Mindlin-Reissner plate element with hourglass stabilization.\n    \"\"\"\n    # Derived physical and geometric constants\n    G = E / (2.0 * (1.0 + nu))\n    A = hx * hy\n    L = np.sqrt(A)\n\n    # --- Step 1: Construct the B_s matrix at the element center (xi=0, eta=0) ---\n    # At the center, Ni = 1/4 for all i=1,2,3,4\n    N_val = 1.0 / 4.0\n\n    # Derivatives of shape functions w.r.t. parent coordinates (xi, eta) at the center\n    dN_dxi = np.array([-0.25, 0.25, 0.25, -0.25])\n    dN_deta = np.array([-0.25, -0.25, 0.25, 0.25])\n\n    # Derivatives w.r.t. physical coordinates (x, y) using the Jacobian for a rectangle\n    dN_dx = (2.0 / hx) * dN_dxi\n    dN_dy = (2.0 / hy) * dN_deta\n\n    # Assemble the 2x12 B_s matrix\n    # B_s = [B_s1, B_s2, B_s3, B_s4] where Bi = [[dNi/dx, Ni, 0], [dNi/dy, 0, Ni]]\n    B_s = np.zeros((2, 12))\n    for i in range(4):\n        B_s[0, 3 * i] = dN_dx[i]\n        B_s[0, 3 * i + 1] = N_val\n        B_s[1, 3 * i] = dN_dy[i]\n        B_s[1, 3 * i + 2] = N_val\n        \n    # --- Step 2: Find the nullspace of B_s and separate RBMs from HGMs ---\n    \n    # Orthonormal basis for Null(B_s) using SVD\n    # B_s = U S Vh. The last 10 rows of Vh (for a 2x12 matrix) form the basis for the nullspace.\n    _U, _s, Vh = np.linalg.svd(B_s, full_matrices=True)\n    # The rank is 2. Nullspace dimension is 12 - 2 = 10.\n    # Q_N contains orthonormal column vectors spanning Null(B_s)\n    Q_N = Vh[2:, :].T  # Shape: (12, 10)\n\n    # Rigid Body Mode basis vectors (RBMs)\n    v1 = np.array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], dtype=float)  # Translation\n    v2 = np.array([hx/2, 1, 0, -hx/2, 1, 0, -hx/2, 1, 0, hx/2, 1, 0], dtype=float)  # Rotation about y\n    v3 = np.array([-hy/2, 0, -1, -hy/2, 0, -1, hy/2, 0, -1, hy/2, 0, -1], dtype=float)  # Rotation about x\n    \n    V_RB = np.vstack([v1, v2, v3]).T # Shape: (12, 3)\n\n    # Orthonormal basis for the RBM subspace using QR decomposition\n    Q_R, _ = np.linalg.qr(V_RB) # Shape: (12, 3)\n\n    # Project the nullspace basis onto the RBM basis to find their intersection\n    M = Q_R.T @ Q_N # Shape: (3, 10)\n    \n    # The nullspace of M gives combinations of Null(B_s) basis vectors that are orthogonal \n    # to the RBMs. These are the hourglass modes.\n    # SVD of M: M = Um Sm Vhm. Nullspace of M is spanned by last 7 rows of Vhm.\n    _Um, _sm, Vhm = np.linalg.svd(M)\n    # Rank of M is 3. Nullspace dimension is 10 - 3 = 7.\n    Alpha_T = Vhm[3:, :] # Shape: (7, 10)\n\n    # Orthonormal basis for the hourglass subspace\n    H = Q_N @ Alpha_T.T # Shape: (12, 7)\n\n    # --- Step 3: Construct stiffness and stabilization matrices ---\n    # Shear stiffness matrix (SRI)\n    K_s = ks * G * t * A * (B_s.T @ B_s)\n\n    # Hourglass stabilization matrix\n    K_hg = eta * ks * G * t * L * (H @ H.T)\n\n    # Stabilized stiffness matrix\n    K_stab = K_s + K_hg\n\n    # --- Step 4: Count near-zero eigenvalues ---\n    epsilon = 1e-9 * ks * G * t * A\n\n    eigvals_s = np.linalg.eigvalsh(K_s)\n    count_zero_sri = np.sum(np.abs(eigvals_s)  epsilon)\n\n    eigvals_stab = np.linalg.eigvalsh(K_stab)\n    count_zero_stab = np.sum(np.abs(eigvals_stab)  epsilon)\n    \n    # --- Step 5: Perform constant shear patch test ---\n    # Nodal DOFs for constant shear gamma_xz = gamma0\n    d_patch = np.zeros(12)\n    d_patch[1::3] = gamma0\n\n    # Exact continuum energy\n    U_exact = 0.5 * ks * G * t * A * gamma0**2\n\n    # Discrete energy with K_s\n    U_s_disc = 0.5 * d_patch.T @ K_s @ d_patch\n    e_s = np.abs(U_s_disc / U_exact - 1.0) if U_exact != 0 else 0.0\n\n    # Discrete energy with K_stab\n    U_stab_disc = 0.5 * d_patch.T @ K_stab @ d_patch\n    e_stab = np.abs(U_stab_disc / U_exact - 1.0) if U_exact != 0 else 0.0\n\n    return count_zero_sri, count_zero_stab, float(e_s), float(e_stab)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: hx=1, hy=1, t=0.2, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (1.0, 1.0, 0.2, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n        # Case 2: hx=2, hy=1, t=0.2, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (2.0, 1.0, 0.2, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n        # Case 3: hx=1, hy=1, t=0.01, E=1e10, nu=0.3, ks=5/6, eta=0.1, gamma0=0.01\n        (1.0, 1.0, 0.01, 1.0e10, 0.3, 5.0/6.0, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        count_sri, count_stab, err_s, err_stab = solve_case(*case)\n        results.extend([count_sri, count_stab, err_s, err_stab])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "开发出一种单元后，我们必须验证其性能。“单元检验”(patch test) 是实现此目的的基本工具，本练习  将其应用于评估不同四边形壳单元公式如何处理纯弯曲状态。你将比较一个标准的、完全积分的单元（会遭受严重的剪切锁定），一个使用选择性减缩积分的单元，以及一个基于张量分量混合插值 (MITC) 概念的更高级单元，从而证明为什么后者在模拟薄曲结构方面更为优越。",
            "id": "3581860",
            "problem": "为双线性等参映射的四边形 Mindlin–Reissner 壳单元构建一个单元素面片检验，并用它来评估在恒定弯曲曲率下的横向剪切行为。从 Mindlin–Reissner 运动学和等参映射的第一性原理出发，并要求算法基于这些基础推导，而不引用任何预先给出的单元公式。\n\n使用的基本依据和定义：\n- Mindlin–Reissner 板壳运动学，小应变和中等转动：横向剪切矢量定义为两个面内分量 $\\boldsymbol{s} = [\\gamma_{xz}, \\gamma_{yz}]^{\\mathsf{T}}$，其中 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。这里 $w$ 是中面的横向挠度，$(\\theta_x, \\theta_y)$ 分别是法线绕 $y$ 轴和 $x$ 轴的转角。角度必须以弧度处理。对于一个横向剪切为零的 Kirchhoff–Love 弯曲场，转角满足 $(\\theta_x, \\theta_y) = -\\nabla w$。\n- 恒定曲率弯曲场：规定一个精确的目标挠度 $w^\\star(x,y)$，它能在物理坐标系中产生恒定的曲率 $(\\kappa_x, \\kappa_y, \\kappa_{xy})$，例如\n$$\nw^\\star(x,y) = \\tfrac{1}{2}\\,\\kappa_x\\,x^2 + \\tfrac{1}{2}\\,\\kappa_y\\,y^2 + \\kappa_{xy}\\,x\\,y,\n$$\n并将精确转角设置为\n$$\n\\theta_x^\\star(x,y) = -\\frac{\\partial w^\\star}{\\partial x} = -(\\kappa_x x + \\kappa_{xy} y),\n$$\n$$\n\\theta_y^\\star(x,y) = -\\frac{\\partial w^\\star}{\\partial y} = -(\\kappa_y y + \\kappa_{xy} x).\n$$\n- 双线性等参四边形映射：物理坐标是母坐标 $(\\xi,\\eta)\\in[-1,1]^2$ 的双线性函数，\n$$\n\\boldsymbol{x}(\\xi,\\eta) = \\sum_{a=1}^{4} N_a(\\xi,\\eta)\\,\\boldsymbol{x}_a,\\quad\nN_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\ N_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\\ N_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\ N_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n协变基矢量为 $\\boldsymbol{a}_\\xi = \\partial \\boldsymbol{x}/\\partial \\xi$ 和 $\\boldsymbol{a}_\\eta = \\partial \\boldsymbol{x}/\\partial \\eta$。面内映射的雅可比矩阵是 $2\\times 2$ 矩阵 $\\boldsymbol{J}=\\begin{bmatrix} \\partial x/\\partial \\xi  \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi  \\partial y/\\partial \\eta \\end{bmatrix}$，并且根据链式法则有 $[\\partial w/\\partial x\\ \\ \\partial w/\\partial y]^{\\mathsf{T}} = \\boldsymbol{J}^{-\\mathsf{T}}[\\partial w/\\partial \\xi\\ \\ \\partial w/\\partial \\eta]^{\\mathsf{T}}$。\n- 对于物理单元上的积分，使用母坐标系中的标准高斯求积法，面积微元为 $dA = |\\boldsymbol{a}_\\xi \\times \\boldsymbol{a}_\\eta|\\,d\\xi\\,d\\eta$。对于平面中面，其中 $\\boldsymbol{x}=(x,y,0)$，大小 $|\\boldsymbol{a}_\\xi \\times \\boldsymbol{a}_\\eta|$ 简化为 $|\\det \\boldsymbol{J}|$。\n\n待测试的离散化方法：\n- 对未知场 $w^h(\\xi,\\eta)$ 和 $(\\theta_x^h(\\xi,\\eta),\\theta_y^h(\\xi,\\eta))$ 使用母坐标系中的双线性插值，节点值取自精确场 $w^\\star$ 和 $(\\theta_x^\\star,\\theta_y^\\star)$ 在物理节点位置的计算值。即，对于 $a\\in\\{1,2,3,4\\}$ 和任意 $(\\xi,\\eta)$，$w^h(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta)\\,w^\\star(\\boldsymbol{x}_a)$ 以及对 $i\\in\\{x,y\\}$ 有 $\\theta_i^h(\\xi,\\eta)=\\sum_a N_a(\\xi,\\eta)\\,\\theta_i^\\star(\\boldsymbol{x}_a)$。\n- 实现三种横向剪切评估策略：\n  1. 标准应变评估 (STD)：通过链式法则在求积点上逐点计算 $\\boldsymbol{s}_{\\text{STD}}(\\xi,\\eta) = [\\theta_x^h+\\partial w^h/\\partial x,\\ \\theta_y^h+\\partial w^h/\\partial y]^{\\mathsf{T}}$。\n  2. 选择性减缩积分 (SRI)：仅在单元中心 $(\\xi,\\eta)=(0,0)$ 计算 $\\boldsymbol{s}_{\\text{SRI}}$，并将其作为积分的常数值使用，代表剪切项的单点减缩积分。\n  3. 边关联假设应变 (MITC-型)，使用沿协变边切线的投影：定义单位切线 $\\boldsymbol{t}_\\xi = \\boldsymbol{a}_\\xi/||\\boldsymbol{a}_\\xi||$ 和 $\\boldsymbol{t}_\\eta = \\boldsymbol{a}_\\eta/||\\boldsymbol{a}_\\eta||$。通过将两个投影剪切分量 $\\boldsymbol{s}\\cdot \\boldsymbol{t}_\\xi$ 和 $\\boldsymbol{s}\\cdot \\boldsymbol{t}_\\eta$ 在相对边的中点（对于 $\\xi$-边在 $(\\xi,\\eta)=(0,\\pm 1)$，对于 $\\eta$-边在 $(\\xi,\\eta)=(\\pm 1,0)$）进行关联来强制执行，使用 $\\theta^h$ 的投影和 $w^h$ 沿相应参数线的方向导数。在正交母坐标方向上对每个投影分量进行线性插值，并通过求解同时匹配这两个投影的最小二乘问题，在求积点重建面内剪切矢量 $\\boldsymbol{s}_{\\text{MITC}}(\\xi,\\eta)$。\n\n性能度量和通过标准：\n- 对于任何剪切评估策略 $X\\in\\{\\text{STD},\\text{SRI},\\text{MITC}\\}$，定义伪剪切的 $L^2$-半范数平方\n$$\nE_X = \\int_{\\Omega_e} \\| \\boldsymbol{s}_X \\|_2^2\\,dA \\approx \\sum_{q} w_q\\,|\\det \\boldsymbol{J}(\\xi_q,\\eta_q)|\\,\\|\\boldsymbol{s}_X(\\xi_q,\\eta_q)\\|_2^2,\n$$\n其中 $\\{(\\xi_q,\\eta_q), w_q\\}$ 是与策略相适应的高斯点和权重（STD 和 MITC 使用 $2\\times 2$ 高斯点，SRI 使用位于 $(0,0)$ 的 $1\\times 1$ 点）。设单元面积为 $A=\\int_{\\Omega_e} dA$。设曲率尺度为 $K=\\sqrt{\\kappa_x^2+\\kappa_y^2+\\kappa_{xy}^2}$。定义无量纲剪切误差指数\n$$\n\\mathcal{M}_X = \\frac{\\sqrt{E_X}}{\\sqrt{A}\\,K\\,\\sqrt{A}} = \\frac{\\sqrt{E_X}}{K\\,A}.\n$$\n如果 $\\mathcal{M}_X \\le \\tau$，容差 $\\tau=10^{-8}$（无量纲），则认为单元通过了恒定曲率面片检验，无伪横向剪切。\n- 所有角度必须以弧度解释，所有坐标以米为单位，最终的误差指数是无量纲的。此运动学面片检验不需要载荷或本构参数。\n\n测试套件：\n对于以下每个单元素面片（节点坐标单位为米）和曲率三元组（单位为米分之一），评估这三种策略并报告通过/失败的布尔值。\n\n- 几何体 G1 (仿射正方形): 节点\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(1,0,0)$, $\\boldsymbol{x}_3=(1,1,0)$, $\\boldsymbol{x}_4=(0,1,0)$。\n  曲率集 C1: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.02,0.01,0.015)$。\n- 几何体 G2 (斜平行四边形): 节点\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(2,0.2,0)$, $\\boldsymbol{x}_3=(1.8,1.2,0)$, $\\boldsymbol{x}_4=(-0.1,0.9,0)$。\n  曲率集 C1: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.02,0.01,0.015)$。\n- 几何体 G2 的纯 x-向弯曲: 曲率集 C2: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0.05,0,0)$。\n- 几何体 G3 (强畸变双线性四边形): 节点\n  $\\boldsymbol{x}_1=(0,0,0)$, $\\boldsymbol{x}_2=(1.2,0.1,0)$, $\\boldsymbol{x}_3=(0.9,1.1,0)$, $\\boldsymbol{x}_4=(-0.2,0.8,0)$。\n  曲率集 C3: $(\\kappa_x,\\kappa_y,\\kappa_{xy})=(0,0,0.03)$。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个结果列表，每个测试用例一个结果，其中每个结果是对应于 $[\\text{STD},\\ \\text{SRI},\\ \\text{MITC}]$ 的三个布尔值的列表。该行必须严格按照 Python 列表字面量的形式打印，例如 `\"[ [True,False,True], [False,False,True], [False,True,True], [False,False,True] ]\"`，除了 Python 默认的列表和布尔值字符串表示自动产生的空格外，不含多余空格。实际的布尔值必须是为指定测试套件计算出的结果。",
            "solution": "用户要求构建并应用一个用于四边形 Mindlin-Reissner 壳单元的单元素面片检验。此检验是计算力学中的一个基本验证过程，旨在评估单元在表示恒定弯曲曲率状态时，是否会产生伪性的、非物理的横向剪切应变（一种称为剪切锁死的现象）。\n\n### 第 1 步：问题验证\n\n根据指定标准对问题陈述进行严格评估。\n\n- **已知条件提取**：\n  - **运动学**：Mindlin-Reissner 理论，剪切应变为 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。\n  - **目标场**：由 $w^\\star(x,y)$、$\\theta_x^\\star(x,y)$ 和 $\\theta_y^\\star(x,y)$ 定义的恒定曲率弯曲场，其在运动学上与零横向剪切一致（$\\boldsymbol{\\theta}^\\star = -\\nabla w^\\star$）。\n  - **离散化**：一个四节点四边形单元，对几何和未知场（$w^h, \\theta_x^h, \\theta_y^h$）均使用双线性等参插值。通过在单元的物理节点位置评估精确目标场来规定节点值。\n  - **剪切评估方法**：定义了三种不同的策略：标准 (STD) 全积分、选择性减缩积分 (SRI) 和一种基于边的张量分量混合插值 (MITC) 的格式。\n  - **性能度量**：定义了一个无量纲剪切误差指数 $\\mathcal{M}_X = \\sqrt{E_X} / (K A)$，其中 $E_X$ 是伪剪切应变平方范数的积分， $A$ 是单元面积， $K$ 是一个基于曲率的缩放因子。\n  - **通过标准**：如果 $\\mathcal{M}_X \\le 10^{-8}$，则单元通过。\n  - **测试套件**：提供了四个特定的测试用例，结合了三种不同的单元几何形状（G1, G2, G3）和三个曲率集（C1, C2, C3）。\n\n- **验证结论**：\n  - 问题在有限元方法和壳理论的既定原则上具有**科学依据**。\n  - 它是**适定的**，为计算算法提供了一套完整、自洽且明确的指令。\n  - 语言是**客观**和精确的。\n  - 任务并非无足轻重，且与指定主题直接相关，测试了单元构造和性能的核心概念。\n  - 所有定义、约束和数据都是一致且充分的，足以推导出一个唯一的数值解。\n\n问题被判定为**有效**。我们可以继续进行求解。\n\n### 第 2 步：基于第一性原理的算法设计\n\n严格遵循所提供的定义来实施解决方案。设计了一个 `PatchTester` 类来封装单个测试用例的逻辑。\n\n1.  **初始化**：用单元的节点坐标和规定的曲率 $(\\kappa_x, \\kappa_y, \\kappa_{xy})$ 创建一个实例。\n    - 定义挠度 ($w^\\star$) 和转角 ($\\theta_x^\\star, \\theta_y^\\star$) 的精确连续场，作为物理坐标 $(x,y)$ 的函数。\n    - 通过在四个节点的物理坐标处计算这些精确函数，来计算节点自由度（$w_a, \\theta_{xa}, \\theta_{ya}$，其中 $a=1,..,4$）。\n\n2.  **等参和场插值**：\n    - 实现了标准的双线性形函数 $N_a(\\xi, \\eta)$ 及其相对于母坐标的导数 $\\partial N_a/\\partial \\xi$ 和 $\\partial N_a/\\partial \\eta$。\n    - 在母域中的任意点 $(\\xi, \\eta)$，利用形函数及其导数，从节点坐标计算出物理坐标 $\\boldsymbol{x}$、雅可比矩阵 $\\boldsymbol{J}$、其行列式 $|\\boldsymbol{J}|$ 以及协变基矢量 $\\boldsymbol{a}_\\xi, \\boldsymbol{a}_\\eta$。\n    - 同样地，从节点自由度计算出插值场 $\\theta_x^h, \\theta_y^h$ 和挠度的母空间导数 $\\partial w^h/\\partial \\xi, \\partial w^h/\\partial \\eta$。\n\n3.  **剪切应变计算与积分**：对于三种策略中的每一种，计算伪剪切能 $E_X$。这涉及到在单元面积 $A$ 上对计算出的剪切矢量平方范数 $\\|\\boldsymbol{s}_X\\|^2$ 进行积分。按照规定使用高斯求积法进行数值积分。\n\n    - **标准 (STD) 策略**：\n        - 执行一个 $2 \\times 2$ 的高斯求积循环。\n        - 在每个求积点 $(\\xi_q, \\eta_q)$，使用链式法则找到挠度的物理导数 $\\nabla w^h = [\\partial w^h/\\partial x, \\partial w^h/\\partial y]^{\\mathsf{T}}$：$\\nabla w^h = \\boldsymbol{J}^{-\\mathsf{T}} [\\partial w^h/\\partial \\xi, \\partial w^h/\\partial \\eta]^{\\mathsf{T}}$。\n        - 计算剪切应变矢量 $\\boldsymbol{s}_{\\text{STD}} = [\\theta_x^h + \\partial w^h/\\partial x, \\theta_y^h + \\partial w^h/\\partial y]^{\\mathsf{T}}$。\n        - 将对能量的贡献 $w_q |\\boldsymbol{J}(\\xi_q, \\eta_q)| \\|\\boldsymbol{s}_{\\text{STD}}(\\xi_q, \\eta_q)\\|_2^2$ 加到总能量 $E_{\\text{STD}}$ 中。\n\n    - **选择性减缩积分 (SRI) 策略**：\n        - 剪切应变 $\\boldsymbol{s}_{\\text{SRI}}$ 仅在单元中心 $(\\xi, \\eta) = (0,0)$ 处计算。\n        - 能量 $E_{\\text{SRI}}$ 使用单点求积法则计算，对于域 $[-1,1]^2$ 其权重为 $4$：$E_{\\text{SRI}} = 4 \\cdot |\\boldsymbol{J}(0,0)| \\cdot \\|\\boldsymbol{s}_{\\text{SRI}}(0,0)\\|_2^2$。\n\n    - **MITC-型策略**：\n        - **关联**：在四条边的中点计算投影剪切分量。例如，在 $\\eta = -1$ 边的中点（A点），投影为 $g_{\\xi,A} = (\\boldsymbol{\\theta}^h \\cdot \\boldsymbol{t}_\\xi + (\\partial w^h/\\partial \\xi)/\\|\\boldsymbol{a}_\\xi\\|)|_A$，其中 $\\boldsymbol{t}_\\xi=\\boldsymbol{a}_\\xi/\\|\\boldsymbol{a}_\\xi\\|$ 是单位切矢量。对相对边对的两个投影都执行此操作。\n        - **插值**：定义两个假设的剪切场 $p_\\xi(\\eta)$ 和 $p_\\eta(\\xi)$，通过对相对边上的关联值进行线性插值得到。\n        - **重建**：最终的剪切矢量 $\\boldsymbol{s}_{\\text{MITC}}$ 在 $2 \\times 2$ 的求积循环内计算。在每个求积点，局部单位切线 $\\boldsymbol{t}_\\xi$ 和 $\\boldsymbol{t}_\\eta$ 构成一个 $2 \\times 2$ 的变换矩阵 $\\boldsymbol{T}$。通过求解系统 $\\boldsymbol{T} \\boldsymbol{s}_{\\text{MITC}} = [p_\\xi(\\eta_q), p_\\eta(\\xi_q)]^{\\mathsf{T}}$ 来恢复剪切矢量。\n        - **积分**：使用在每个 $2 \\times 2$ 高斯点重建的剪切矢量来累积能量 $E_{\\text{MITC}}$。\n\n4.  **度量评估**：在计算单元面积 $A$ 和总能量 $E_X$ 后，计算每种策略的无量纲误差指数 $\\mathcal{M}_X$，并与容差 $\\tau=10^{-8}$ 进行比较，以确定测试用例的通过/失败布尔值。\n\n这个系统化的过程直接源于问题的基本定义，并在以下 Python 程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# version: Python 3.12\n# libraries: numpy 1.23.5\n\nclass PatchTester:\n    \"\"\"\n    Encapsulates the logic for a one-element Mindlin-Reissner patch test for a \n    given geometry and constant curvature field.\n    \"\"\"\n    def __init__(self, nodes, curvatures, tolerance=1e-8):\n        \"\"\"\n        Initializes the test with geometry, target field, and tolerance.\n\n        Args:\n            nodes (list of tuples): A 4x3 list of nodal coordinates.\n            curvatures (tuple): A tuple (kappa_x, kappa_y, kappa_xy).\n            tolerance (float): The threshold for the pass/fail criterion.\n        \"\"\"\n        self.nodes = np.array(nodes, dtype=float)\n        self.k_x, self.k_y, self.k_xy = curvatures\n        self.tolerance = tolerance\n\n        self.x_coords = self.nodes[:, 0]\n        self.y_coords = self.nodes[:, 1]\n        \n        # Define exact kinematic fields as functions of physical coordinates (x, y)\n        self.w_star = lambda x, y: 0.5 * self.k_x * x**2 + 0.5 * self.k_y * y**2 + self.k_xy * x * y\n        self.theta_x_star = lambda x, y: -(self.k_x * x + self.k_xy * y)\n        self.theta_y_star = lambda x, y: -(self.k_y * y + self.k_xy * x)\n\n        # Evaluate nodal values of DOFs from the exact fields\n        self.w_nodes = self.w_star(self.x_coords, self.y_coords)\n        self.theta_x_nodes = self.theta_x_star(self.x_coords, self.y_coords)\n        self.theta_y_nodes = self.theta_y_star(self.x_coords, self.y_coords)\n\n        # Gaussian quadrature setup\n        gp = 1.0 / np.sqrt(3)\n        self.gauss_pts_2x2 = [(-gp, -gp), (gp, -gp), (gp, gp), (-gp, gp)]\n        self.gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # --- Core FEM functions: Shape Functions  Isoparametric Mapping ---\n    def N(self, xi, eta):\n        return 0.25 * np.array([(1 - xi) * (1 - eta), (1 + xi) * (1 - eta), (1 + xi) * (1 + eta), (1 - xi) * (1 + eta)])\n    def dN_dxi(self, xi, eta):\n        return 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    def dN_deta(self, xi, eta):\n        return 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    def get_jacobian_and_related(self, xi, eta):\n        dN_dxi_vals = self.dN_dxi(xi, eta)\n        dN_deta_vals = self.dN_deta(xi, eta)\n        dx_dxi = dN_dxi_vals @ self.x_coords\n        dy_dxi = dN_dxi_vals @ self.y_coords\n        dx_deta = dN_deta_vals @ self.x_coords\n        dy_deta = dN_deta_vals @ self.y_coords\n        J = np.array([[dx_dxi, dx_deta], [dy_dxi, dy_deta]])\n        detJ = np.linalg.det(J)\n        a_xi = np.array([dx_dxi, dy_dxi])\n        a_eta = np.array([dx_deta, dy_deta])\n        return J, detJ, a_xi, a_eta\n\n    def get_interpolated_fields(self, xi, eta):\n        N_vals = self.N(xi, eta)\n        dN_dxi_vals = self.dN_dxi(xi, eta)\n        dN_deta_vals = self.dN_deta(xi, eta)\n        return {\n            'theta_x_h': N_vals @ self.theta_x_nodes,\n            'theta_y_h': N_vals @ self.theta_y_nodes,\n            'dw_h_dxi': dN_dxi_vals @ self.w_nodes,\n            'dw_h_deta': dN_deta_vals @ self.w_nodes\n        }\n\n    # --- Main Test Execution ---\n    def run_tests(self):\n        area = self._calculate_area()\n        K_scale = np.sqrt(self.k_x**2 + self.k_y**2 + self.k_xy**2)\n        \n        if K_scale  1e-12 or area  1e-12:\n            return [True, True, True]\n\n        def get_metric(E_squared):\n            return np.sqrt(E_squared) / (K_scale * area)\n\n        E_std = self._calculate_E_std()\n        M_std = get_metric(E_std)\n\n        E_sri = self._calculate_E_sri()\n        M_sri = get_metric(E_sri)\n\n        E_mitc = self._calculate_E_mitc()\n        M_mitc = get_metric(E_mitc)\n        \n        return [M_std = self.tolerance, M_sri = self.tolerance, M_mitc = self.tolerance]\n\n    def _calculate_area(self):\n        area = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            _, detJ, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n            area += self.gauss_w_2x2[i] * np.abs(detJ)\n        return area\n\n    # --- Shear Evaluation Strategies ---\n    def _calculate_E_std(self):\n        E_squared = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            J, detJ, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n            invJT = np.linalg.inv(J).T\n            fields = self.get_interpolated_fields(xi_q, eta_q)\n            grad_w_h_parent = np.array([fields['dw_h_dxi'], fields['dw_h_deta']])\n            grad_w_h_physical = invJT @ grad_w_h_parent\n            s_std = np.array([fields['theta_x_h'] + grad_w_h_physical[0],\n                              fields['theta_y_h'] + grad_w_h_physical[1]])\n            E_squared += self.gauss_w_2x2[i] * np.abs(detJ) * (s_std @ s_std)\n        return E_squared\n\n    def _calculate_E_sri(self):\n        xi_q, eta_q = 0.0, 0.0\n        J, detJ_center, _, _ = self.get_jacobian_and_related(xi_q, eta_q)\n        invJT = np.linalg.inv(J).T\n        fields = self.get_interpolated_fields(xi_q, eta_q)\n        grad_w_h_parent = np.array([fields['dw_h_dxi'], fields['dw_h_deta']])\n        grad_w_h_physical = invJT @ grad_w_h_parent\n        s_sri_center = np.array([fields['theta_x_h'] + grad_w_h_physical[0],\n                                 fields['theta_y_h'] + grad_w_h_physical[1]])\n        # 1-point quadrature rule over [-1,1]x[-1,1] has weight 4.\n        E_squared = 4.0 * np.abs(detJ_center) * (s_sri_center @ s_sri_center)\n        return E_squared\n\n    def _calculate_E_mitc(self):\n        tying_pts = {'A': (0, -1), 'B': (1, 0), 'C': (0, 1), 'D': (-1, 0)}\n\n        def get_tied_shear(xi, eta, direction):\n            _, _, a_xi, a_eta = self.get_jacobian_and_related(xi, eta)\n            fields = self.get_interpolated_fields(xi, eta)\n            tangent_vec, deriv_w = (a_xi, fields['dw_h_dxi']) if direction == 'xi' else (a_eta, fields['dw_h_deta'])\n            norm_tangent = np.linalg.norm(tangent_vec)\n            if norm_tangent  1e-12: return 0.0\n            unit_tangent = tangent_vec / norm_tangent\n            theta_h = np.array([fields['theta_x_h'], fields['theta_y_h']])\n            return (theta_h @ unit_tangent) + deriv_w / norm_tangent\n        \n        g_xi_A = get_tied_shear(tying_pts['A'][0], tying_pts['A'][1], 'xi')\n        g_xi_C = get_tied_shear(tying_pts['C'][0], tying_pts['C'][1], 'xi')\n        g_eta_B = get_tied_shear(tying_pts['B'][0], tying_pts['B'][1], 'eta')\n        g_eta_D = get_tied_shear(tying_pts['D'][0], tying_pts['D'][1], 'eta')\n\n        E_squared = 0.0\n        for i, (xi_q, eta_q) in enumerate(self.gauss_pts_2x2):\n            p_xi = 0.5 * (1 - eta_q) * g_xi_A + 0.5 * (1 + eta_q) * g_xi_C\n            p_eta = 0.5 * (1 - xi_q) * g_eta_D + 0.5 * (1 + xi_q) * g_eta_B\n            _, detJ, a_xi, a_eta = self.get_jacobian_and_related(xi_q, eta_q)\n            norm_a_xi, norm_a_eta = np.linalg.norm(a_xi), np.linalg.norm(a_eta)\n            if norm_a_xi  1e-12 or norm_a_eta  1e-12 or abs(detJ)  1e-12: continue\n            \n            t_xi, t_eta = a_xi / norm_a_xi, a_eta / norm_a_eta\n            T_mat = np.array([t_xi, t_eta])\n            \n            if np.abs(np.linalg.det(T_mat))  1e-12: continue\n            s_mitc = np.linalg.inv(T_mat) @ np.array([p_xi, p_eta])\n            E_squared += self.gauss_w_2x2[i] * np.abs(detJ) * (s_mitc @ s_mitc)\n        return E_squared\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the patch tests.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (1,1,0), (0,1,0)],\n            \"curvatures\": (0.02, 0.01, 0.015)\n        },\n        {\n            \"nodes\": [(0,0,0), (2,0.2,0), (1.8,1.2,0), (-0.1,0.9,0)],\n            \"curvatures\": (0.02, 0.01, 0.015)\n        },\n        {\n            \"nodes\": [(0,0,0), (2,0.2,0), (1.8,1.2,0), (-0.1,0.9,0)],\n            \"curvatures\": (0.05, 0, 0)\n        },\n        {\n            \"nodes\": [(0,0,0), (1.2,0.1,0), (0.9,1.1,0), (-0.2,0.8,0)],\n            \"curvatures\": (0, 0, 0.03)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        tester = PatchTester(nodes=case[\"nodes\"], curvatures=case[\"curvatures\"])\n        result = tester.run_tests()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "前面的练习展示了剪切锁定的数值问题及其一个可行的解决方案。本练习  则深入探讨了某些公式能够“无锁定”的理论基础，即检验一个混合变分原理。通过使用半解析的里兹法，你将把剪应变作为独立变量，并弱形式地施加运动协调约束，从而从解析上证明，当厚度趋于零时，该方法能正确收敛到经典薄板理论。",
            "id": "3581855",
            "problem": "考虑一个均匀、各向同性的方形板的 Reissner-Mindlin 板模型，该板占据域 $\\Omega = (0,1)\\times(0,1)$，且边缘为简支。横向位移表示为 $w(x,y)$，导杆（中面法线）的转角表示为 $\\boldsymbol{\\beta}(x,y)=\\left[\\beta_x(x,y),\\beta_y(x,y)\\right]^T$。横向剪切应变向量为 $\\boldsymbol{\\gamma}(x,y)=\\left[\\gamma_x(x,y),\\gamma_y(x,y)\\right]^T$，Reissner-Mindlin 运动学关系为 $\\boldsymbol{\\gamma}=\\boldsymbol{\\beta}+\\nabla w$。在混合格式中，引入一个独立的类剪应力拉格朗日乘子场 $\\boldsymbol{\\lambda}(x,y)$，通过拉格朗日函数中的约束项来弱形式地施加运动学关系。材料的杨氏模量为 $E$（单位：$\\mathrm{Pa}$），泊松比为 $\\nu$（无量纲），厚度为 $t$（单位：$\\mathrm{m}$），剪切模量为 $G=E/\\left(2(1+\\nu)\\right)$（单位：$\\mathrm{Pa}$）。剪切修正因子为 $\\kappa_s$（无量纲）。板的弯曲刚度为 $D=\\dfrac{E\\,t^3}{12\\left(1-\\nu^2\\right)}$（单位：$\\mathrm{N\\,m}$）。板受到空间均匀的横向载荷 $q$（单位：$\\mathrm{N/m^2}$）。角度以弧度为单位。\n\n从静止势能原理和 Reissner-Mindlin 假设出发，构建一个单模态 Ritz 近似，其场函数为\n- $w(x,y)=W\\,\\sin(\\pi x)\\,\\sin(\\pi y)$，\n- $\\beta_x(x,y)=B_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$，\n- $\\beta_y(x,y)=B_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$，\n- $\\gamma_x(x,y)=G_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$，\n- $\\gamma_y(x,y)=G_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$，\n- $\\lambda_x(x,y)=L_x\\,\\cos(\\pi x)\\,\\sin(\\pi y)$，\n- $\\lambda_y(x,y)=L_y\\,\\sin(\\pi x)\\,\\cos(\\pi y)$，\n\n其中包含标量幅值 $W$、$B_x$、$B_y$、$G_x$、$G_y$、$L_x$、$L_y$。使用从 Kirchhoff-Love 弯曲本构矩阵导出的各向同性板弯曲能量密度，以及包含 $\\kappa_s$ 和 $G$ 的 Reissner-Mindlin 剪切能量密度。使用拉格朗日乘子 $\\boldsymbol{\\lambda}$ 弱形式地施加运动学关系 $\\boldsymbol{\\gamma}=\\boldsymbol{\\beta}+\\nabla w$，即，将约束项 $-\\int_{\\Omega}\\boldsymbol{\\lambda}\\cdot\\left(\\boldsymbol{\\gamma}-\\boldsymbol{\\beta}-\\nabla w\\right)\\,\\mathrm{d}\\Omega$ 添加到总势能中。不要添加任何罚项。通过将拉格朗日函数的一阶变分设为零，推导幅值的线性方程组。\n\n然后，对于一组给定的材料和载荷参数，求解所得的线性系统并提取位移幅值 $W$。另外，通过在无剪切的情况下最小化弯曲能，为相同的单模态 $w$-场计算 Kirchhoff-Love 薄板幅值 $W_{\\mathrm{KL}}$，其结果为\n$$\nW_{\\mathrm{KL}}=\\frac{q}{4\\,D\\,\\pi^4}.\n$$\n\n构建一个程序，对于每个测试厚度 $t$，组装并求解混合系统以获得 $W$，计算 $W_{\\mathrm{KL}}$，并返回比值 $R(t)=\\dfrac{W}{W_{\\mathrm{KL}}}$。目标是通过证明当 $t\\to 0$ 时 $R(t)\\to 1$，来数值验证其无闭锁行为。\n\n使用以下材料和载荷参数：\n- $E=210\\times 10^9\\,\\mathrm{Pa}$，\n- $\\nu=0.3$，\n- $\\kappa_s=\\dfrac{5}{6}$，\n- $q=1000\\,\\mathrm{N/m^2}$。\n\n使用以下板厚度（单位：$\\mathrm{m}$）的测试组：\n- $t=0.5$（相对较厚的情况），\n- $t=0.1$（中等厚度），\n- $t=0.01$（薄），\n- $t=0.001$（非常薄），\n- $t=10^{-5}$（接近薄板极限）。\n\n您的程序应生成单行输出，其中包含比值 $R(t)$，按上述测试组的顺序排列，形式为方括号内以逗号分隔的浮点数列表，四舍五入到六位小数（例如，$\\left[1.000000,0.999000\\right]$）。比值为无量纲量，不需要单位。",
            "solution": "用户希望分析 Reissner-Mindlin 板理论的混合格式，以验证其无闭锁行为。这涉及推导并求解一个代数方程组，以确定假定的位移、转角、剪切和拉格朗日乘子场的幅值。\n\n### 问题验证\n在计算固体力学的背景下，该问题定义明确。它涉及对 Reissner-Mindlin 板的标准 Ritz 近似，采用混合变分原理来减轻剪切闭锁。材料属性、几何形状和边界条件都已明确指定。\n\n关于载荷，问题陈述中存在一个小的歧义。使用了“空间均匀的横向载荷 $q$”这一说法，但提供的 Kirchhoff-Love 挠度公式 $W_{\\mathrm{KL}}=\\dfrac{q}{4\\,D\\,\\pi^4}$，是 $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$ 形式的正弦载荷的特征，而不是均匀载荷的特征。对于使用正弦基函数的单模态 Ritz 近似，标准做法是只考虑载荷的相应傅里叶分量。一个均匀载荷 $q$ 的第一个傅里叶分量是 $q_{11} \\sin(\\pi x)\\sin(\\pi y)$，其中 $q_{11} = 16q/\\pi^2$。如果情况如此，那么一致的 $W_{KL}$ 将是 $W_{KL} = 4q/(D\\pi^6)$。这种差异表明，问题描述中的符号 $q$ 旨在表示正弦载荷 $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$ 的幅值，并且数值 $q=1000\\,\\mathrm{N/m^2}$ 适用于此幅值。这种解释使得问题完全自洽。因此，在这种标准解释下，该问题被认为是**有效的**。\n\n### 控制方程的推导\n\n混合格式的总拉格朗日函数 $\\mathcal{L}$ 由下式给出：\n$$\n\\mathcal{L} = U_b + U_s - W_{ext} - C\n$$\n其中 $U_b$ 是弯曲应变能，$U_s$ 是剪切应变能，$W_{ext}$ 是外加载荷的势能，$C$ 是约束项。\n$$\nC = \\int_{\\Omega}\\boldsymbol{\\lambda}\\cdot\\left(\\boldsymbol{\\gamma}-\\boldsymbol{\\beta}-\\nabla w\\right)\\,\\mathrm{d}\\Omega\n$$\n\n问题在几何、边界条件和载荷（在正弦解释下）方面是对称的。因此，我们可以假设响应是对称的，这简化了 Ritz 近似：$B_x=B_y=B$、 $G_x=G_y=G$ 和 $L_x=L_y=L$。未知量是标量幅值 $W, B, G, L$。\n\n**1. 弯曲应变能 ($U_b$)**\n\n弯曲能为 $U_b = \\frac{1}{2} \\int_\\Omega \\boldsymbol{\\kappa}^T \\mathbf{C}_b \\boldsymbol{\\kappa} \\,dA$，其中 $\\mathbf{C}_b$ 是弯曲本构矩阵，$\\boldsymbol{\\kappa}$ 包含转角 $\\boldsymbol{\\beta}$ 的导数。使用 $\\beta_x = B \\cos(\\pi x) \\sin(\\pi y)$ 和 $\\beta_y = B \\sin(\\pi x) \\cos(\\pi y)$，能量积分计算结果为：\n$$\nU_b = \\frac{D \\pi^2 B^2}{2}\n$$\n\n**2. 剪切应变能 ($U_s$)**\n\n剪切能为 $U_s = \\frac{1}{2} \\int_\\Omega \\boldsymbol{\\gamma}^T \\mathbf{C}_s \\boldsymbol{\\gamma} \\,dA$，其中 $\\mathbf{C}_s = \\kappa_s G t \\mathbf{I}$。使用独立的剪切应变场 $\\gamma_x = G \\cos(\\pi x) \\sin(\\pi y)$ 和 $\\gamma_y = G \\sin(\\pi x) \\cos(\\pi y)$，积分变为：\n$$\nU_s = \\frac{1}{2} \\kappa_s G t \\left( \\int_0^1 \\int_0^1 G^2 \\cos^2(\\pi x)\\sin^2(\\pi y) + G^2 \\sin^2(\\pi x)\\cos^2(\\pi y) \\,dx\\,dy \\right) = \\frac{\\kappa_s G t G^2}{4}\n$$\n\n**3. 外加载荷势能 ($W_{ext}$)**\n\n如前所述，载荷取为 $p(x,y) = q \\sin(\\pi x) \\sin(\\pi y)$。势能为 $W_{ext} = \\int_\\Omega p(x,y) w(x,y) \\,dA$。\n$$\nW_{ext} = \\int_0^1 \\int_0^1 (q \\sin(\\pi x) \\sin(\\pi y)) (W \\sin(\\pi x) \\sin(\\pi y)) \\,dx\\,dy = \\frac{qW}{4}\n$$\n\n**4. 约束项 ($C$)**\n\n约束项弱形式地施加 $\\boldsymbol{\\gamma} = \\boldsymbol{\\beta} + \\nabla w$。\n$$\nC = \\int_\\Omega [\\lambda_x(\\gamma_x - \\beta_x - \\partial_x w) + \\lambda_y(\\gamma_y - \\beta_y - \\partial_y w)] \\,dA\n$$\n代入对称场近似：\n$$\n\\gamma_x - \\beta_x - \\partial_x w = (G-B-W\\pi) \\cos(\\pi x) \\sin(\\pi y)\n$$\n$$\n\\gamma_y - \\beta_y - \\partial_y w = (G-B-W\\pi) \\sin(\\pi x) \\cos(\\pi y)\n$$\n并使用 $\\lambda_x = L \\cos(\\pi x) \\sin(\\pi y)$ 和 $\\lambda_y = L \\sin(\\pi x) \\cos(\\pi y)$，积分变为：\n$$\nC = \\int_0^1 \\int_0^1 L(G-B-W\\pi)(\\cos^2(\\pi x)\\sin^2(\\pi y) + \\sin^2(\\pi x)\\cos^2(\\pi y)) \\,dx\\,dy = \\frac{L(G-B-W\\pi)}{2}\n$$\n\n**5. 总拉格朗日函数和方程组**\n\n最终的拉格朗日函数是四个幅值的函数：\n$$\n\\mathcal{L}(W, B, G, L) = \\frac{D \\pi^2 B^2}{2} + \\frac{\\kappa_s G t G^2}{4} - \\frac{qW}{4} - \\frac{L(G-B-W\\pi)}{2}\n$$\n静止势能原理要求将 $\\mathcal{L}$ 对每个幅值的偏导数设为零。\n\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial W} = -\\dfrac{q}{4} - \\dfrac{L(-\\pi)}{2} = 0 \\implies \\dfrac{\\pi L}{2} = \\dfrac{q}{4}$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial B} = D \\pi^2 B - \\dfrac{L(-1)}{2} = 0 \\implies D \\pi^2 B + \\dfrac{L}{2} = 0$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial G} = \\dfrac{\\kappa_s G t G}{2} - \\dfrac{L}{2} = 0 \\implies \\kappa_s G t G - L = 0$\n- $\\dfrac{\\partial \\mathcal{L}}{\\partial L} = -\\dfrac{G-B-W\\pi}{2} = 0 \\implies G - B - W\\pi = 0$\n\n**6. 幅值求解**\n\n这个关于 $(W, B, G, L)$ 的四元线性方程组可以按顺序求解。\n\n由 $\\dfrac{\\partial \\mathcal{L}}{\\partial W} = 0$ 得：\n$$\nL = \\frac{q}{2\\pi}\n$$\n由 $\\dfrac{\\partial \\mathcal{L}}{\\partial B} = 0$ 得：\n$$\nB = -\\frac{L}{2D\\pi^2} = -\\frac{q/(2\\pi)}{2D\\pi^2} = -\\frac{q}{4D\\pi^3}\n$$\n由 $\\dfrac{\\partial \\mathcal{L}}{\\partial G} = 0$ 得：\n$$\nG = \\frac{L}{\\kappa_s G t} = \\frac{q/(2\\pi)}{\\kappa_s G t} = \\frac{q}{2\\pi \\kappa_s G t}\n$$\n由 $\\dfrac{\\partial \\mathcal{L}}{\\partial L} = 0$ 得：\n$$\nW = \\frac{G-B}{\\pi} = \\frac{1}{\\pi} \\left( \\frac{q}{2\\pi \\kappa_s G t} - \\left(-\\frac{q}{4D\\pi^3}\\right) \\right) = \\frac{q}{2\\pi^2 \\kappa_s G t} + \\frac{q}{4D\\pi^4}\n$$\n\n**7. 比值计算**\n\n推导出的位移幅值为 $W = \\dfrac{q}{2\\pi^2 \\kappa_s G t} + W_{\\mathrm{KL}}$，其中 $W_{\\mathrm{KL}} = \\dfrac{q}{4D\\pi^4}$ 是问题中提供的 Kirchhoff-Love 幅值。比值 $R(t) = W/W_{\\mathrm{KL}}$ 为：\n$$\nR(t) = \\frac{\\frac{q}{2\\pi^2 \\kappa_s G t} + W_{\\mathrm{KL}}}{W_{\\mathrm{KL}}} = 1 + \\frac{q}{2\\pi^2 \\kappa_s G t} \\frac{1}{W_{\\mathrm{KL}}} = 1 + \\frac{q}{2\\pi^2 \\kappa_s G t} \\frac{4D\\pi^4}{q} = 1 + \\frac{2D\\pi^2}{\\kappa_s G t}\n$$\n为简化计算，我们代入 $D$ 和 $G$ 的表达式：\n$D = \\dfrac{E t^3}{12(1-\\nu^2)}$ 和 $G = \\dfrac{E}{2(1+\\nu)}$。\n项 $\\dfrac{D}{Gt}$ 变为：\n$$\n\\frac{D}{Gt} = \\frac{E t^3}{12(1-\\nu^2)} \\frac{1}{\\frac{E}{2(1+\\nu)} t} = \\frac{E t^3}{12(1-\\nu)(1+\\nu)} \\frac{2(1+\\nu)}{E t} = \\frac{t^2}{6(1-\\nu)}\n$$\n将此代回 $R(t)$ 的表达式中：\n$$\nR(t) = 1 + \\frac{2\\pi^2}{\\kappa_s} \\left( \\frac{t^2}{6(1-\\nu)} \\right) = 1 + \\frac{\\pi^2 t^2}{3\\kappa_s(1-\\nu)}\n$$\n这个最终表达式优雅地表明，当厚度 $t \\to 0$ 时，比值 $R(t) \\to 1$，证明了这种混合格式是无剪切闭锁的。此公式将用于实现计算结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ratio of Reissner-Mindlin to Kirchhoff-Love central displacement\n    for a simply supported square plate under a single-mode sinusoidal load.\n\n    The derivation is based on a one-mode Ritz approximation with a mixed\n    variational formulation, which is shown to be locking-free.\n    \"\"\"\n\n    # --- Given Parameters ---\n    # E = 210e9  # Young's modulus in Pa\n    nu = 0.3      # Poisson's ratio (dimensionless)\n    kappa_s = 5/6 # Shear correction factor (dimensionless)\n    # q = 1000   # Load amplitude in N/m^2\n\n    # The problem specifies E and q, but the final ratio R(t) simplifies to\n    # an expression that is independent of E and q, depending only on t, nu, and kappa_s.\n    \n    # Test suite for plate thickness t (in meters)\n    test_thicknesses = [0.5, 0.1, 0.01, 0.001, 1e-5]\n\n    results = []\n    \n    # --- Calculation Loop ---\n    for t in test_thicknesses:\n        # The ratio R(t) = W / W_KL was derived in the solution description as:\n        # R(t) = 1 + (pi^2 * t^2) / (3 * kappa_s * (1 - nu))\n        \n        numerator = np.pi**2 * t**2\n        denominator = 3 * kappa_s * (1 - nu)\n        \n        ratio = 1 + numerator / denominator\n        \n        results.append(ratio)\n        \n    # --- Format and Print Output ---\n    # The output must be a comma-separated list of floating-point numbers\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}