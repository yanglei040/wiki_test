{
    "hands_on_practices": [
        {
            "introduction": "有限元方法的基础是等参映射，它将简单的参考单元与复杂的物理单元联系起来。任何模拟的准确性都取决于在物理空间中正确计算形函数梯度。这项实践将指导您实现并验证 T10 单元的这一关键计算。通过将您的代码输出与仿射几何的精确解析解进行比较，您将对自己的实现建立信心，并更深入地理解链式法则在有限元方法中的作用。",
            "id": "3605665",
            "problem": "设计并实现一个完整的程序，该程序针对一个十节点二次四面体单元（通常记作 T10），使用等参格式计算在指定求积点处形函数的物理空间梯度。计算必须遵循从等参映射和链式法则出发的第一性原理路径。该程序还必须在仿射几何的特殊情况下，根据从重心坐标微积分推导出的解析值来验证梯度的准确性。\n\n您必须从以下基本基础出发：\n- 单元的等参映射通过单元形函数将参考坐标映射到物理坐标。如果 $\\{\\boldsymbol{X}_a\\}_{a=1}^{10}$ 是物理节点位置，$\\{N_a\\}_{a=1}^{10}$ 是形函数，则映射由下式给出\n$$\n\\boldsymbol{x}(\\boldsymbol{\\xi}) \\;=\\; \\sum_{a=1}^{10} N_a(\\boldsymbol{\\xi})\\,\\boldsymbol{X}_a,\n$$\n其中 $\\boldsymbol{\\xi} = (r,s,t)$ 是单位四面体上的参考坐标，满足 $r \\ge 0$，$s \\ge 0$，$t \\ge 0$ 且 $r+s+t \\le 1$。\n- 雅可比矩阵定义为\n$$\n\\boldsymbol{J}(\\boldsymbol{\\xi}) \\;=\\; \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}} \\;=\\; \\sum_{a=1}^{10} \\boldsymbol{X}_a \\otimes \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi}),\n$$\n链式法则给出的形函数物理空间梯度为\n$$\n\\nabla_{\\boldsymbol{x}} N_a(\\boldsymbol{\\xi}) \\;=\\; \\boldsymbol{J}(\\boldsymbol{\\xi})^{-\\mathsf{T}} \\, \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi}).\n$$\n- 对于参考四面体上的 T10 单元，其形函数可以用重心坐标 $\\{L_i\\}_{i=1}^4$ 表示，定义为 $L_1=r$，$L_2=s$，$L_3=t$，$L_4 = 1 - r - s - t$，且满足 $L_1+L_2+L_3+L_4=1$。十个二次形函数为\n$$\n\\begin{aligned}\nN_1 &= L_1\\,(2L_1-1),\\;\\; N_2 = L_2\\,(2L_2-1),\\;\\; N_3 = L_3\\,(2L_3-1),\\;\\; N_4 = L_4\\,(2L_4-1),\\\\\nN_5 &= 4\\,L_1 L_2,\\;\\; N_6 = 4\\,L_2 L_3,\\;\\; N_7 = 4\\,L_1 L_3,\\;\\; N_8 = 4\\,L_1 L_4,\\;\\; N_9 = 4\\,L_2 L_4,\\;\\; N_{10} = 4\\,L_3 L_4.\n\\end{aligned}\n$$\n- 导数 $\\nabla_{\\boldsymbol{\\xi}} N_a$ 可由乘法法则和线性关系 $\\partial L_1/\\partial r = 1$，$\\partial L_2/\\partial s = 1$，$\\partial L_3/\\partial t = 1$，$\\partial L_4/\\partial r = \\partial L_4/\\partial s = \\partial L_4/\\partial t = -1$ 推导得出，其中 $L_i$ 的所有其他偏导数均为 $0$。\n\n仿射几何的解析验证基础：\n- 如果几何是仿射的，即边中点节点位于四个顶点节点之间直线边的中点，则物理映射简化为仿射映射。在这种情况下，物理重心坐标是 $\\boldsymbol{x}$ 的线性函数并满足\n$$\n\\boldsymbol{x} \\;=\\; \\sum_{i=1}^{4} L_i(\\boldsymbol{x})\\,\\boldsymbol{X}_i,\\;\\;\\; \\sum_{i=1}^{4} L_i(\\boldsymbol{x}) = 1,\n$$\n且梯度 $\\{\\nabla_{\\boldsymbol{x}} L_i\\}_{i=1}^{4}$ 是由顶点位置决定的常数向量。定义 $3\\times 3$ 矩阵\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} \\boldsymbol{X}_1 - \\boldsymbol{X}_4 & \\boldsymbol{X}_2 - \\boldsymbol{X}_4 & \\boldsymbol{X}_3 - \\boldsymbol{X}_4 \\end{bmatrix},\n$$\n则\n$$\n\\nabla_{\\boldsymbol{x}} L_1 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_1,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_2 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_2,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_3 \\;=\\; \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_3,\\;\\;\n\\nabla_{\\boldsymbol{x}} L_4 \\;=\\; -\\sum_{i=1}^{3} \\nabla_{\\boldsymbol{x}} L_i,\n$$\n其中 $\\{\\boldsymbol{e}_i\\}$ 是笛卡尔基向量。对于任意具有重心坐标 $\\{L_i\\}$ 的点，T10 形函数的解析梯度则为\n$$\n\\begin{aligned}\n\\nabla_{\\boldsymbol{x}} N_1 = (4L_1-1)\\,\\nabla_{\\boldsymbol{x}} L_1,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_2 = (4L_2-1)\\,\\nabla_{\\boldsymbol{x}} L_2,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_3 = (4L_3-1)\\,\\nabla_{\\boldsymbol{x}} L_3,\\;\\;\n\\nabla_{\\boldsymbol{x}} N_4 = (4L_4-1)\\,\\nabla_{\\boldsymbol{x}} L_4,\\\\\n\\nabla_{\\boldsymbol{x}} N_5 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_2 + L_2\\,\\nabla_{\\boldsymbol{x}} L_1),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_6 = 4\\,(L_2\\,\\nabla_{\\boldsymbol{x}} L_3 + L_3\\,\\nabla_{\\boldsymbol{x}} L_2),\\\\\n\\nabla_{\\boldsymbol{x}} N_7 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_3 + L_3\\,\\nabla_{\\boldsymbol{x}} L_1),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_8 = 4\\,(L_1\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_1),\\\\\n\\nabla_{\\boldsymbol{x}} N_9 = 4\\,(L_2\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_2),\\;\\;\n\\nabla_{\\boldsymbol{x}} N_{10} = 4\\,(L_3\\,\\nabla_{\\boldsymbol{x}} L_4 + L_4\\,\\nabla_{\\boldsymbol{x}} L_3).\n\\end{aligned}\n$$\n\n您的程序必须：\n- 实现一个鲁棒的算法，对于每个求积点，该算法计算 $\\nabla_{\\boldsymbol{\\xi}} N_a$，组装 $\\boldsymbol{J}$，通过求解线性方程组计算 $\\boldsymbol{J}^{-\\mathsf{T}}$，并返回 $\\nabla_{\\boldsymbol{x}} N_a$。\n- 在参考四面体上使用以下以重心坐标给出的对称四点求积法则。令 $a = 0.1381966011250105$，并定义四个重心坐标为\n$$\n(L_1,L_2,L_3,L_4) \\in \\{(a,a,a,1-3a),\\;(1-3a,a,a,a),\\;(a,1-3a,a,a),\\;(a,a,1-3a,a)\\},\n$$\n的求积点，每个点的权重相等（此任务不需要权重，但必须使用这些点）。通过 $(r,s,t) = (L_1,L_2,L_3)$ 将这些重心坐标转换为参考坐标。\n\n测试套件：\n- 对于以下三个仿射 T10 单元中的每一个，通过将 4 个顶点节点放置在给定坐标处，并将 6 个边中点节点中的每一个放置在其对应直线边的中点，来构建 10 个节点的位置。对于每个单元，在四个求积点处计算梯度，并计算在所有形函数和求积点上，算法梯度与解析梯度之差的最大欧几里得范数。报告每个单元的单个最大误差。\n    1. 正常路径单元，使用直角单位四面体：\n       - 顶点节点：$\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(1,0,0)$, $\\boldsymbol{X}_3=(0,1,0)$, $\\boldsymbol{X}_4=(0,0,1)$。\n    2. 扭曲但形状良好的单元：\n       - 顶点节点：$\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(3,0.1,0)$, $\\boldsymbol{X}_3=(0.2,2.5,0.1)$, $\\boldsymbol{X}_4=(0.1,0.2,2.0)$。\n    3. 近奇异单元（边界情况）：\n       - 顶点节点：$\\boldsymbol{X}_1=(0,0,0)$, $\\boldsymbol{X}_2=(10^{-4},0,0)$, $\\boldsymbol{X}_3=(0,10^{-4},0)$, $\\boldsymbol{X}_4=(0,0,1)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[e_1,e_2,e_3]$，其中 $e_i$ 是单元 $i$ 的最大误差，以浮点数表示。不应打印其他任何文本。",
            "solution": "该问题要求设计并实现一个程序，用于计算十节点二次四面体单元（T10）的形函数在物理空间中的梯度。计算必须基于等参格式和链式法则。此外，对于仿射单元几何的特殊情况，必须根据从重心坐标微积分推导出的解析解来验证结果。\n\n解决方案包括四个主要阶段：1) 在参考坐标系中推导形函数梯度，2) 构建等参映射和雅可比矩阵以将这些梯度变换到物理坐标系，3) 构建仿射几何的解析解，以及 4) 设计一个算法流程来计算并比较指定测试用例的结果。\n\n设单位四面体上的参考坐标为 $\\boldsymbol{\\xi} = (r, s, t)^{\\mathsf{T}}$，其中 $r \\ge 0$，$s \\ge 0$，$t \\ge 0$ 且 $r+s+t \\le 1$。物理坐标记作 $\\boldsymbol{x}=(x,y,z)^{\\mathsf{T}}$。\n\n首先，我们定义重心坐标，这是定义形函数的基础。对于参考四面体中的任意点 $\\boldsymbol{\\xi}$，其重心坐标 $\\{L_i\\}_{i=1}^4$ 由下式给出：\n$$\nL_1(\\boldsymbol{\\xi}) = r, \\quad L_2(\\boldsymbol{\\xi}) = s, \\quad L_3(\\boldsymbol{\\xi}) = t, \\quad L_4(\\boldsymbol{\\xi}) = 1 - r - s - t\n$$\n这些坐标满足属性 $\\sum_{i=1}^4 L_i = 1$。T10 单元的十个形函数可以利用这些重心坐标优雅地表示。节点 1 到 4是四面体的顶点，节点 5 到 10 是六条边的中点。形函数如下：\n$$\n\\begin{aligned}\nN_1 = L_1(2L_1-1)  \\text{(顶点 1)} \\\\\nN_2 = L_2(2L_2-1)  \\text{(顶点 2)} \\\\\nN_3 = L_3(2L_3-1)  \\text{(顶点 3)} \\\\\nN_4 = L_4(2L_4-1)  \\text{(顶点 4)} \\\\\nN_5 = 4L_1 L_2  \\text{(边 1-2 的中点)} \\\\\nN_6 = 4L_2 L_3  \\text{(边 2-3 的中点)} \\\\\nN_7 = 4L_1 L_3  \\text{(边 1-3 的中点)} \\\\\nN_8 = 4L_1 L_4  \\text{(边 1-4 的中点)} \\\\\nN_9 = 4L_2 L_4  \\text{(边 2-4 的中点)} \\\\\nN_{10} = 4L_3 L_4  \\text{(边 3-4 的中点)}\n\\end{aligned}\n$$\n\n为了计算物理空间梯度 $\\nabla_{\\boldsymbol{x}} N_a$，我们首先需要参考空间梯度 $\\nabla_{\\boldsymbol{\\xi}} N_a$。这些梯度通过对形函数定义应用链式法则得到。任意形函数 $N_a$ 相对于某个参考坐标（例如 $r$）的梯度为 $\\frac{\\partial N_a}{\\partial r} = \\sum_{i=1}^4 \\frac{\\partial N_a}{\\partial L_i} \\frac{\\partial L_i}{\\partial r}$。重心坐标相对于参考坐标的导数是常数：\n$$\n\\nabla_{\\boldsymbol{\\xi}} L_1 = (1, 0, 0)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_2 = (0, 1, 0)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_3 = (0, 0, 1)^{\\mathsf{T}}, \\quad \\nabla_{\\boldsymbol{\\xi}} L_4 = (-1, -1, -1)^{\\mathsf{T}}\n$$\n这导出了 $\\nabla_{\\boldsymbol{\\xi}} N_a$ 各分量的以下表达式：\n$$\n\\frac{\\partial N_a}{\\partial r} = \\frac{\\partial N_a}{\\partial L_1} - \\frac{\\partial N_a}{\\partial L_4}, \\quad\n\\frac{\\partial N_a}{\\partial s} = \\frac{\\partial N_a}{\\partial L_2} - \\frac{\\partial N_a}{\\partial L_4}, \\quad\n\\frac{\\partial N_a}{\\partial t} = \\frac{\\partial N_a}{\\partial L_3} - \\frac{\\partial N_a}{\\partial L_4}\n$$\n导数 $\\frac{\\partial N_a}{\\partial L_i}$ 是通过对 $N_a$ 的多项式表达式求导得到的。例如，对于 $N_1 = 2L_1^2 - L_1$，$\\frac{\\partial N_1}{\\partial L_1} = 4L_1-1$，而对于 $N_5=4L_1L_2$，$\\frac{\\partial N_5}{\\partial L_1} = 4L_2$ 且 $\\frac{\\partial N_5}{\\partial L_2} = 4L_1$。所有其他导数均为零。这些导数在由其重心坐标定义的特定点上进行计算。\n\n等参格式使用相同的形函数将参考单元映射到物理单元：\n$$\n\\boldsymbol{x}(\\boldsymbol{\\xi}) \\;=\\; \\sum_{a=1}^{10} N_a(\\boldsymbol{\\xi})\\,\\boldsymbol{X}_a\n$$\n其中 $\\boldsymbol{X}_a$ 是单元十个节点的物理坐标。该映射的梯度定义了雅可比矩阵 $\\boldsymbol{J}$：\n$$\n\\boldsymbol{J}(\\boldsymbol{\\xi}) = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}} = \\sum_{a=1}^{10} \\boldsymbol{X}_a \\otimes \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi})\n$$\n其分量形式为 $J_{ij} = \\frac{\\partial x_i}{\\partial \\xi_j} = \\sum_{a=1}^{10} X_{ai} \\frac{\\partial N_a}{\\partial \\xi_j}$。这里，$i \\in \\{1,2,3\\}$ 指的是物理维度 $(x,y,z)$，$j \\in \\{1,2,3\\}$ 指的是参考维度 $(r,s,t)$。\n\n链式法则连接了物理梯度和参考梯度：$\\nabla_{\\boldsymbol{\\xi}} N_a = \\boldsymbol{J}^{\\mathsf{T}} \\nabla_{\\boldsymbol{x}} N_a$。为了求得所需的物理梯度，我们重排此关系：\n$$\n\\nabla_{\\boldsymbol{x}} N_a(\\boldsymbol{\\xi}) \\;=\\; \\boldsymbol{J}(\\boldsymbol{\\xi})^{-\\mathsf{T}} \\, \\nabla_{\\boldsymbol{\\xi}} N_a(\\boldsymbol{\\xi})\n$$\n在计算上，对每个形函数 $a$ 求解线性方程组 $\\boldsymbol{J}^{\\mathsf{T}} (\\nabla_{\\boldsymbol{x}} N_a) = \\nabla_{\\boldsymbol{\\xi}} N_a$ 比显式计算 $\\boldsymbol{J}^{\\mathsf{T}}$ 的逆矩阵更稳定、更高效。\n\n为了验证，我们使用一个对仿射单元有效的解析解，其中所有边中点节点 $\\boldsymbol{X}_{5-10}$ 精确地位于连接相应顶点节点 $\\boldsymbol{X}_{1-4}$ 的边的几何中点。在这种情况下，从物理坐标到重心坐标的映射是仿射的。重心坐标相对于物理坐标的梯度 $\\nabla_{\\boldsymbol{x}} L_i$ 是常数向量。它们可以通过首先定义矩阵 $\\boldsymbol{B}$ 来计算，该矩阵的列由从顶点 4 到顶点 1、2 和 3 的向量构成：\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} \\boldsymbol{X}_1 - \\boldsymbol{X}_4  & \\boldsymbol{X}_2 - \\boldsymbol{X}_4  & \\boldsymbol{X}_3 - \\boldsymbol{X}_4 \\end{bmatrix}\n$$\n梯度则由下式给出：\n$$\n\\nabla_{\\boldsymbol{x}} L_1 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_1, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_2 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_2, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_3 = \\boldsymbol{B}^{-\\mathsf{T}} \\boldsymbol{e}_3, \\;\\;\n\\nabla_{\\boldsymbol{x}} L_4 = -\\sum_{i=1}^{3} \\nabla_{\\boldsymbol{x}} L_i\n$$\n其中 $\\{\\boldsymbol{e}_i\\}$ 是标准笛卡尔基向量。利用这些常数梯度，任意形函数 $N_a$ 的解析物理梯度可以通过对其以 $L_i$ 表示的定义应用乘法法则来找到。例如，对于 $N_1=L_1(2L_1-1)$，梯度为 $\\nabla_{\\boldsymbol{x}} N_1 = (4L_1-1)\\nabla_{\\boldsymbol{x}} L_1$。对于 $N_5=4L_1L_2$，其梯度为 $\\nabla_{\\boldsymbol{x}} N_5 = 4(L_1 \\nabla_{\\boldsymbol{x}} L_2 + L_2 \\nabla_{\\boldsymbol{x}} L_1)$。\n\n给定单元的总体算法如下：\n1. 定义 4 个顶点节点的坐标 $\\boldsymbol{X}_{1..4}$。构建 6 个边中点节点的坐标 $\\boldsymbol{X}_{5..10}$（例如，$\\boldsymbol{X}_5 = 0.5(\\boldsymbol{X}_1 + \\boldsymbol{X}_2)$）。这就构成了所有 10 个节点坐标的矩阵。\n2. 对于以重心坐标 $(L_1, L_2, L_3, L_4)$ 给出的四个指定求积点中的每一个点：\n    a. 转换为参考坐标 $(r, s, t) = (L_1, L_2, L_3)$。\n    b. **算法梯度计算**：\n        i. 计算 $10 \\times 3$ 的参考梯度矩阵 $\\boldsymbol{D}$，其中 $D_{aj} = (\\nabla_{\\boldsymbol{\\xi}} N_a)_j$。\n        ii. 组装 $3 \\times 3$ 的雅可比矩阵 $\\boldsymbol{J}$。\n        iii. 同时对所有 10 个形函数求解线性方程组 $\\boldsymbol{J}^{\\mathsf{T}} \\boldsymbol{G}^{\\mathsf{T}} = \\boldsymbol{D}^{\\mathsf{T}}$，以找到 $10 \\times 3$ 的物理梯度矩阵 $\\boldsymbol{G}$，其中 $G_{aj} = (\\nabla_{\\boldsymbol{x}} N_a)_j$。\n    c. **解析梯度计算**：\n        i. 计算重心坐标的常数物理梯度 $\\nabla_{\\boldsymbol{x}} L_i$。\n        ii. 使用这些梯度和求积点的重心坐标来计算所有 10 个形函数的解析物理梯度。\n    d. 对每个形函数，计算其算法梯度与解析梯度之向量差的欧几里得范数。\n3. 单元的最终误差是所有 10 个形函数和所有 4 个求积点上的这些范数的最大值。\n对所提供的三个测试单元中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve, inv\n\ndef solve_problem():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It computes the maximum error between algorithmic and analytical T10 gradients\n    for three different affine tetrahedral elements.\n    \"\"\"\n\n    # Test suite: vertex coordinates for three affine T10 elements.\n    test_cases = [\n        # 1. Happy path element: right-angled unit tetrahedron\n        np.array([\n            [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]\n        ]),\n        # 2. Skewed, well-shaped element\n        np.array([\n            [0.0, 0.0, 0.0], [3.0, 0.1, 0.0], [0.2, 2.5, 0.1], [0.1, 0.2, 2.0]\n        ]),\n        # 3. Nearly singular element (edge case)\n        np.array([\n            [0.0, 0.0, 0.0], [1e-4, 0.0, 0.0], [0.0, 1e-4, 0.0], [0.0, 0.0, 1.0]\n        ]),\n    ]\n\n    # Quadrature points for a symmetric 4-point rule on the tetrahedron.\n    a = 0.1381966011250105\n    b = 1.0 - 3.0 * a\n    # Quadrature points are given in barycentric coordinates (L1, L2, L3, L4).\n    quad_points_bary = np.array([\n        [a, a, a, b],\n        [b, a, a, a],\n        [a, b, a, a],\n        [a, a, b, a],\n    ])\n\n    results = []\n    for vertices in test_cases:\n        # Construct the full 10-node coordinate matrix for the affine element.\n        # Nodes 1-4 are vertices.\n        # Nodes 5-10 are mid-edge nodes in the order: 1-2, 2-3, 1-3, 1-4, 2-4, 3-4.\n        all_nodes = np.zeros((10, 3))\n        all_nodes[0:4, :] = vertices\n        all_nodes[4, :] = 0.5 * (vertices[0] + vertices[1])  # Edge 1-2\n        all_nodes[5, :] = 0.5 * (vertices[1] + vertices[2])  # Edge 2-3\n        all_nodes[6, :] = 0.5 * (vertices[0] + vertices[2])  # Edge 1-3\n        all_nodes[7, :] = 0.5 * (vertices[0] + vertices[3])  # Edge 1-4\n        all_nodes[8, :] = 0.5 * (vertices[1] + vertices[3])  # Edge 2-4\n        all_nodes[9, :] = 0.5 * (vertices[2] + vertices[3])  # Edge 3-4\n        \n        max_error = compute_max_error(all_nodes, quad_points_bary)\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\ndef get_ref_grads(bary_coords):\n    \"\"\"\n    Computes the gradients of the 10 T10 shape functions with respect to the\n    reference coordinates (r, s, t) at a point defined by its barycentric\n    coordinates.\n\n    Args:\n        bary_coords (np.ndarray): A (4,) array of barycentric coordinates [L1, L2, L3, L4].\n\n    Returns:\n        np.ndarray: A (10, 3) matrix of reference gradients, where row 'a' is\n                    the gradient of shape function N_a.\n    \"\"\"\n    L = bary_coords\n    \n    # partial derivatives of shape functions w.r.t. barycentric coordinates (dNa/dLi)\n    dNa_dLi = np.zeros((10, 4))\n    \n    # Vertex nodes (N1 to N4)\n    dNa_dLi[0, 0] = 4 * L[0] - 1\n    dNa_dLi[1, 1] = 4 * L[1] - 1\n    dNa_dLi[2, 2] = 4 * L[2] - 1\n    dNa_dLi[3, 3] = 4 * L[3] - 1\n    \n    # Mid-edge nodes (N5 to N10)\n    dNa_dLi[4, 0], dNa_dLi[4, 1] = 4 * L[1], 4 * L[0]  # N5 = 4*L1*L2\n    dNa_dLi[5, 1], dNa_dLi[5, 2] = 4 * L[2], 4 * L[1]  # N6 = 4*L2*L3\n    dNa_dLi[6, 0], dNa_dLi[6, 2] = 4 * L[2], 4 * L[0]  # N7 = 4*L1*L3\n    dNa_dLi[7, 0], dNa_dLi[7, 3] = 4 * L[3], 4 * L[0]  # N8 = 4*L1*L4\n    dNa_dLi[8, 1], dNa_dLi[8, 3] = 4 * L[3], 4 * L[1]  # N9 = 4*L2*L4\n    dNa_dLi[9, 2], dNa_dLi[9, 3] = 4 * L[3], 4 * L[2]  # N10 = 4*L3*L4\n    \n    # Chain rule: dNa/dr = dNa/dL1 - dNa/dL4, etc.\n    dNa_dxi = np.zeros((10, 3))\n    dNa_dxi[:, 0] = dNa_dLi[:, 0] - dNa_dLi[:, 3]  # d/dr\n    dNa_dxi[:, 1] = dNa_dLi[:, 1] - dNa_dLi[:, 3]  # d/ds\n    dNa_dxi[:, 2] = dNa_dLi[:, 2] - dNa_dLi[:, 3]  # d/dt\n    \n    return dNa_dxi\n\ndef compute_gradients_isoparametric(nodes, bary_coords):\n    \"\"\"\n    Computes physical gradients using the standard isoparametric formulation.\n    \"\"\"\n    ref_grads = get_ref_grads(bary_coords)\n    # Jacobian J_ij = sum_a X_ai * dNa/dxi_j\n    # In matrix form: J = X.T @ (dNa/dxi)\n    J = nodes.T @ ref_grads\n    \n    # Physical grads G = (dNa/dxi) @ inv(J)\n    # Solved more robustly as J.T @ G.T = (dNa/dxi).T\n    phys_grads = solve(J.T, ref_grads.T).T\n    return phys_grads\n\ndef compute_gradients_analytical(nodes, bary_coords):\n    \"\"\"\n    Computes physical gradients using the analytical formulas for affine elements.\n    \"\"\"\n    vertices = nodes[0:4]\n    L = bary_coords\n\n    # Matrix B for computing barycentric coordinate gradients\n    B = np.zeros((3, 3))\n    B[:, 0] = vertices[0] - vertices[3]\n    B[:, 1] = vertices[1] - vertices[3]\n    B[:, 2] = vertices[2] - vertices[3]\n    \n    B_inv_T = inv(B).T\n    \n    # Gradients of barycentric coordinates w.r.t. physical coords (dLi/dx)\n    dL_dx = np.zeros((4, 3))\n    dL_dx[0, :] = B_inv_T[:, 0]\n    dL_dx[1, :] = B_inv_T[:, 1]\n    dL_dx[2, :] = B_inv_T[:, 2]\n    dL_dx[3, :] = -np.sum(dL_dx[0:3, :], axis=0)\n    \n    # Analytical physical gradients of shape functions\n    grad_N_an = np.zeros((10, 3))\n    grad_N_an[0, :] = (4 * L[0] - 1) * dL_dx[0]\n    grad_N_an[1, :] = (4 * L[1] - 1) * dL_dx[1]\n    grad_N_an[2, :] = (4 * L[2] - 1) * dL_dx[2]\n    grad_N_an[3, :] = (4 * L[3] - 1) * dL_dx[3]\n    \n    grad_N_an[4, :] = 4 * (L[1] * dL_dx[0] + L[0] * dL_dx[1])\n    grad_N_an[5, :] = 4 * (L[2] * dL_dx[1] + L[1] * dL_dx[2])\n    grad_N_an[6, :] = 4 * (L[2] * dL_dx[0] + L[0] * dL_dx[2])\n    grad_N_an[7, :] = 4 * (L[3] * dL_dx[0] + L[0] * dL_dx[3])\n    grad_N_an[8, :] = 4 * (L[3] * dL_dx[1] + L[1] * dL_dx[3])\n    grad_N_an[9, :] = 4 * (L[3] * dL_dx[2] + L[2] * dL_dx[3])\n\n    return grad_N_an\n\ndef compute_max_error(nodes, quad_points_bary):\n    \"\"\"\n    Computes the maximum error between algorithmic and analytical gradients\n    over all shape functions and quadrature points for a single element.\n    \"\"\"\n    max_err = 0.0\n    for qp_bary in quad_points_bary:\n        \n        # Algorithmic (isoparametric) computation\n        grad_iso = compute_gradients_isoparametric(nodes, qp_bary)\n        \n        # Analytical computation for affine case\n        grad_an = compute_gradients_analytical(nodes, qp_bary)\n        \n        # Compute error for this quadrature point\n        diff = grad_iso - grad_an\n        errors_at_qp = np.linalg.norm(diff, axis=1) # Norms for each shape function\n        \n        # Update overall maximum error\n        max_err = max(max_err, np.max(errors_at_qp))\n        \n    return max_err\n\nif __name__ == '__main__':\n    solve_problem()\n```"
        },
        {
            "introduction": "除了刚度矩阵，像一致质量矩阵这样的单元矩阵对于动态分析也至关重要。它们的构建为练习单元域上的积分提供了一个绝佳的机会。本练习要求您使用重心坐标（一种处理四面体单元的强大工具）来推导 T4 和 T10 单元的一致质量矩阵。这一过程将巩固您对形函数阶次如何决定被积函数复杂性，并进而决定精确积分所需的数值求积法则的理解。",
            "id": "3605661",
            "problem": "考虑从有限元法 (FEM) 中标量场的线性动量守恒弱形式得到的半离散形式，其中单元级的协调质量矩阵定义为\n$$\nM_{e} \\;=\\; \\int_{\\Omega_{e}} \\rho\\, N^{\\top} N \\, d\\Omega,\n$$\n其中 $N$ 是形函数的列向量，$\\rho$ 是质量密度，$\\Omega_{e}$ 是物理四面体单元域。假设 $\\rho$ 在 $\\Omega_{e}$ 上是常数，并且当等参映射为线性时，单元是直边的。在四面体上使用重心坐标 $\\{\\lambda_{i}\\}_{i=1}^{4}$，以及关于重心坐标单项式的狄利克雷积分恒等式，来推导四节点线性四面体 (T4) 和十节点二次四面体 (T10) 的协调质量矩阵表达式。将 $N$ 视为相应单元的标量拉格朗日形函数列向量，并说明你所引用的任何几何映射假设。\n\n从基本定义和成熟公式出发，完成以下任务：\n\n1. 对于 T4 单元，通过使用重心坐标单项式的狄利克雷积分计算 $\\int_{\\Omega_{e}} \\lambda_{i}\\lambda_{j}\\, d\\Omega$，推导 $M_{e}$ 的闭式解表达式（用单元体积 $V_{e}$ 和 $\\rho$ 表示）。\n\n2. 对于 T10 单元，用重心坐标写出四个顶点和六个边中点处的二次拉格朗日形函数，并确定参考四面体上被积函数 $\\rho\\,N^{\\top}N$ 的多项式次数。然后，在等参二次几何下，确定雅可比行列式 $\\det J$ 的次数以及完整被积函数 $\\rho\\,N^{\\top}N\\,\\det J$ 在参考域上的最终多项式次数。\n\n3. 根据你的发现，指出要精确积分 T4 (线性几何) 和 T10 (二次几何) 的协调质量矩阵被积函数，四面体求积法则所需的最小多项式精确度。将你的最终答案以行矩阵 $\\big(k_{\\mathrm{T4}} \\;\\; k_{\\mathrm{T10}}\\big)$ 的形式报告，该矩阵包含这两个精确度。无需四舍五-入，最终答案中不应包含任何单位。",
            "solution": "该问题提法明确，科学依据充分，并提供了推导所需量的所有必要信息。这是计算固体力学领域的一个标准问题，特别是在有限元法 (FEM) 的背景下。我们开始进行解答。\n\n根据问题陈述的要求，分析分为三个部分。\n\n### 第一部分：T4 单元的协调质量矩阵\n\n四节点线性四面体 (T4) 单元的节点位于其四个顶点处。在等参格式中，几何和未知场使用同一组形函数来表示。对于线性单元，形函数是线性的。对于四面体，表示这些函数最方便的方法是使用重心坐标 $\\{\\lambda_i\\}_{i=1}^{4}$。对于 T4 单元，节点 $i$ 的形函数，记为 $N_i$，就是第 $i$ 个重心坐标，即 $N_i = \\lambda_i$。\n\n单元级协调质量矩阵 $M_e$ 由下式给出\n$$\nM_{e} \\;=\\; \\int_{\\Omega_{e}} \\rho\\, N^{\\top} N \\, d\\Omega\n$$\n其中 $\\rho$ 是质量密度，假设在单元域 $\\Omega_e$ 上为常数，而 $N$ 是形函数的列向量，$N = \\begin{pmatrix} \\lambda_1 & \\lambda_2 & \\lambda_3 & \\lambda_4 \\end{pmatrix}^{\\top}$。这个 $4 \\times 4$ 质量矩阵的元素 $M_{ij}$ 由下式给出：\n$$\nM_{ij} \\;=\\; \\rho \\int_{\\Omega_{e}} N_i N_j \\, d\\Omega \\;=\\; \\rho \\int_{\\Omega_{e}} \\lambda_i \\lambda_j \\, d\\Omega\n$$\n为计算该积分，我们使用三维四面体域 $\\Omega_e$ 上重心坐标单项式的狄利克雷积分恒等式：\n$$\n\\int_{\\Omega_{e}} \\lambda_1^{a_1} \\lambda_2^{a_2} \\lambda_3^{a_3} \\lambda_4^{a_4} \\, d\\Omega \\;=\\; V_e \\frac{3! \\, a_1! \\, a_2! \\, a_3! \\, a_4!}{(3 + a_1 + a_2 + a_3 + a_4)!}\n$$\n其中 $V_e$ 是四面体的体积。\n\n我们区分质量矩阵的对角线元素 ($i=j$) 和非对角线元素 ($i \\neq j$)。\n\n**对角线元素 ($i=j$):**\n被积函数为 $\\lambda_i \\lambda_j = \\lambda_i^2$。在狄利克雷积分公式中，指数为 $a_i=2$ 和 $a_k=0$（对于 $k \\neq i$）。\n$$\n\\int_{\\Omega_{e}} \\lambda_i^2 \\, d\\Omega \\;=\\; V_e \\frac{3! \\, 2! \\, 0! \\, 0! \\, 0!}{(3 + 2)!} \\;=\\; V_e \\frac{6 \\cdot 2}{5!} \\;=\\; V_e \\frac{12}{120} \\;=\\; \\frac{1}{10} V_e\n$$\n因此，对角线元素为 $M_{ii} = \\rho \\frac{V_e}{10}$。\n\n**非对角线元素 ($i \\neq j$):**\n被积函数为 $\\lambda_i \\lambda_j$。指数为 $a_i=1$，$a_j=1$ 和 $a_k=0$（对于 $k \\notin \\{i, j\\}$）。\n$$\n\\int_{\\Omega_{e}} \\lambda_i \\lambda_j \\, d\\Omega \\;=\\; V_e \\frac{3! \\, 1! \\, 1! \\, 0! \\, 0!}{(3 + 1 + 1)!} \\;=\\; V_e \\frac{6 \\cdot 1 \\cdot 1}{5!} \\;=\\; V_e \\frac{6}{120} \\;=\\; \\frac{1}{20} V_e\n$$\n因此，非对角线元素为 $M_{ij} = \\rho \\frac{V_e}{20}$（对于 $i \\neq j$）。\n\nT4 单元的完整协调质量矩阵为：\n$$\nM_e \\;=\\; \\frac{\\rho V_e}{20}\n\\begin{pmatrix}\n2 & 1 & 1 & 1 \\\\\n1 & 2 & 1 & 1 \\\\\n1 & 1 & 2 & 1 \\\\\n1 & 1 & 1 & 2\n\\end{pmatrix}\n$$\n\n### 第二部分：T10 单元的多项式次数\n\n十节点二次四面体 (T10) 单元有四个节点位于顶点，六个节点位于边的中点。其形函数是关于重心坐标的二次多项式。设顶点为节点 $1, 2, 3, 4$，边中点为节点 $5, ..., 10$。形函数 $N_i$ 为：\n- 对于一个顶点节点 $i \\in \\{1,2,3,4\\}$: $N_i = \\lambda_i (2\\lambda_i - 1)$。\n- 对于连接顶点 $i$ 和 $j$ 的边上的一个中点节点 $k$：$N_k = 4\\lambda_i \\lambda_j$。\n\n物理域上质量矩阵的被积函数是 $\\rho N^{\\top}N$。其元素形式为 $\\rho N_i N_j$。由于 $\\rho$ 是常数，我们考虑乘积 $N_i N_j$ 的多项式次数。形函数 $N_i$ 是重心坐标 $\\lambda_k$ 的二次多项式（2次）。因此，乘积 $N_i N_j$ 是一个关于重心坐标的 $2+2=4$ 次多项式。\n\n问题要求在等参二次几何映射下，参考域上完整被积函数的多项式次数。从物理域 $\\Omega_e$ 到参考域 $\\hat{\\Omega}$ 的积分变换为：\n$$\n\\int_{\\Omega_e} f(x) \\,d\\Omega = \\int_{\\hat{\\Omega}} f(x(\\xi)) \\det(J) \\,d\\hat{\\Omega}\n$$\n其中 $\\xi$ 是参考单元上的坐标，$J$ 是几何映射 $x(\\xi)$ 的雅可比矩阵。\n\n对于具有二次等参映射的 T10 单元，物理坐标 $x$ 使用二次形函数进行插值：\n$$\nx(\\xi) = \\sum_{k=1}^{10} N_k(\\xi) x_k\n$$\n其中 $x_k$ 是节点坐标。形函数 $N_k(\\xi)$ 是参考坐标 $\\xi = (\\xi_1, \\xi_2, \\xi_3)$ 的二次多项式。\n\n雅可比矩阵的元素为 $J_{ab} = \\frac{\\partial x_a}{\\partial \\xi_b}$。\n$$\nJ_{ab} = \\frac{\\partial}{\\partial \\xi_b} \\left( \\sum_{k=1}^{10} N_k(\\xi) (x_k)_a \\right) = \\sum_{k=1}^{10} \\frac{\\partial N_k(\\xi)}{\\partial \\xi_b} (x_k)_a\n$$\n由于每个 $N_k(\\xi)$ 都是 $\\xi$ 的二次多项式，其偏导数 $\\frac{\\partial N_k(\\xi)}{\\partial \\xi_b}$ 是 $\\xi$ 的线性多项式。因此，雅可比矩阵的每个元素 $J_{ab}$ 都是参考坐标 $\\xi$ 的线性多项式。\n\n这个 $3 \\times 3$ 雅可比矩阵的行列式 $\\det(J)$ 是根据其线性多项式元素计算的。行列式是三个元素乘积之和，因此其多项式次数通常为 $1+1+1=3$。对于一般的曲边 T10 单元，这个三次项不会消失。因此，$\\det(J)$ 的次数为 $3$。\n\n参考域上的完整被积函数为 $\\rho N_i(\\xi) N_j(\\xi) \\det(J(\\xi))$。\n- $N_i(\\xi) N_j(\\xi)$ 的多项式次数为 $4$。\n- $\\det(J(\\xi))$ 的多项式次数为 $3$。\n\n完整被积函数的多项式次数是这些次数之和：$4 + 3 = 7$。\n\n### 第三部分：最小求积精确度\n\n如果一个数值求积法则能够精确积分所有次数不超过 $k$ 的多项式，则称其具有 $k$ 次多项式精确度。为了无误差地计算协调质量矩阵，求积法则必须对被积函数中遇到的最高多项式次数精确。\n\n**对于具有线性几何的 T4 单元：**\n问题指定了直边单元，这对应于线性等参映射。坐标变换为 $x(\\xi) = \\sum_{i=1}^{4} N_i(\\xi) x_i$，其中 $N_i$ 是线性形函数。雅可比矩阵 $J$ 是常数，因此其行列式 $\\det(J)$ 也是一个常数（0 次多项式）。参考域上的被积函数为 $N_i(\\xi) N_j(\\xi) \\det(J)$。\n- 形函数 $N_i$ 是线性的（1次）。\n- 乘积 $N_i N_j$ 是二次的（2次）。\n- 行列式 $\\det(J)$ 是常数（0次）。\n被积函数的总次数是 $2+0=2$。\n因此，T4 单元所需的最小多项式精确度为 $k_{\\mathrm{T4}} = 2$。\n\n**对于具有二次几何的 T10 单元：**\n如第二部分所推导，参考域上的被积函数是 $N_i(\\xi) N_j(\\xi) \\det(J(\\xi))$。\n- 形函数乘积 $N_i N_j$ 是一个 4 次多项式。\n- 雅可比行列式 $\\det(J)$ 是一个 3 次多项式。\n被积函数的总次数是 $4+3=7$。\n因此，T10 单元所需的最小多项式精确度为 $k_{\\mathrm{T10}} = 7$。\n\n最终答案是一个包含这两个次数的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & 7\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在计算工程中，选择正确的单元是一项关键决策，需要在精度和计算成本之间取得平衡。虽然像 T10 这样的高阶单元能提供更高的精度，但与像 T4 这样的简单线性单元相比，它们也带来了显著的计算开销。这项动手估算练习要求您通过计算为每种单元类型组装刚度矩阵所需的浮点运算次数（FLOPs）来量化这种权衡。该分析为您在单元选择时提供了关于性能影响的具体见解，并突出了与高阶列式相关的非凡成本。",
            "id": "3605651",
            "problem": "考虑用等参四面体单元离散化的三维小应变线性弹性力学问题。单元刚度矩阵由以下积分定义：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e^{\\text{ref}}} \\mathbf{B}(\\boldsymbol{\\xi})^{\\mathsf{T}} \\, \\mathbf{D} \\, \\mathbf{B}(\\boldsymbol{\\xi}) \\, \\det\\mathbf{J}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\Omega_{\\boldsymbol{\\xi}},\n$$\n其中 $\\mathbf{D}$ 是常数 $6\\times 6$ 各向同性本构矩阵，$\\mathbf{J}(\\boldsymbol{\\xi})$ 是从参考四面体到物理单元的等参映射的 $3\\times 3$ 雅可比矩阵，$\\mathbf{B}(\\boldsymbol{\\xi})$ 是一个具有 $n$ 个节点、每个节点有 $3$ 个位移自由度的单元的 $6\\times (3n)$ 应变-位移矩阵。假设为直边（仿射）几何，因此物理单元的面是平面的；$10$ 节点四面体的中边节点位于边的中点，确保了仿射映射。然而，该实现使用通用的等参公式（对所有单元节点求和）在每个求积点上计算 $\\mathbf{J}(\\boldsymbol{\\xi})$。\n\n您需要通过显式计算评估 $\\mathbf{J}$、$\\det\\mathbf{J}$、$\\mathbf{J}^{-1}$、形函数的物理梯度以及 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ 的求积累加所需的算术运算，来估算每个单元将 $\\mathbf{K}_e$ 组装到单元存储中的浮点运算次数。使用以下规则和假设：\n\n- 将每次浮点加法、乘法和除法计为成本 $1$；忽略所有内存加载/存储和分支成本。\n- 在每个求积点通过下式计算 $\\mathbf{J}$：\n$$\nJ_{ij} = \\sum_{a=1}^{n} x_{a,i} \\, \\frac{\\partial N_a}{\\partial \\xi_j},\n$$\n每个条目 $J_{ij}$ 需要 $n$ 次乘法和 $n-1$ 次加法。共有 $9$ 个条目。\n- 在每个求积点通过伴随矩阵（代数余子式）法计算 $\\det\\mathbf{J}$ 和 $\\mathbf{J}^{-1}$：形成所有 $9$ 个代数余子式，通过第一行与相应代数余子式的点积计算 $\\det\\mathbf{J}$，然后用 $1/\\det\\mathbf{J}$ 缩放伴随矩阵。每个求积点这需要 $30$ 次乘法，$11$ 次加法和 $1$ 次除法。\n- 在每个求积点通过 $\\nabla_{\\mathbf{x}} N_a = \\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} N_a$ 将参考梯度映射到物理梯度，每个节点进行一次 $3\\times 3$ 矩阵-向量乘法，成本为每个节点 $9$ 次乘法和 $6$ 次加法。\n- 在每个求积点通过以下步骤组装被积函数：\n  1. 形成一个 $6\\times (3n)$ 矩阵 $\\mathbf{M} = \\mathbf{D}\\mathbf{B}$，成本为 $(6\\cdot 3n)$ 次长度为 $6$ 的点积。\n  2. 将对称乘积 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$ 累加到单元刚度中，仅使用上三角部分，即 $(3n)(3n+1)/2$ 次长度为 $6$ 的点积，然后对每个唯一的上三角条目，通过标量求积权重乘以 $\\det\\mathbf{J}$ 进行缩放并相加。\n- 对于 $4$ 节点四面体（$\\mathrm{T}4$），使用对线性场精确的 $1$ 点求积法。对于 $10$ 节点四面体（$\\mathrm{T}10$），使用对二次被积函数精确的 $4$ 点法则。\n- 本构矩阵 $\\mathbf{D}$ 是常数且可重用；形成 $\\mathbf{D}$ 的成本不计。映射是仿射的，但如上所述在每个求积点进行计算。\n\n任务：\n\n- 根据上述规则，从第一性原理推导 $\\mathrm{T}4$ 和 $\\mathrm{T}10$ 单元每个单元的总运算次数。清晰地说明计算 $\\mathbf{J}$、$\\det\\mathbf{J}$、$\\mathbf{J}^{-1}$、转换梯度、形成 $\\mathbf{M}$、执行对称乘积以及使用求积权重和行列式进行缩放的成本。\n- 计算比率\n$$\nR \\equiv \\frac{\\text{T10 每个单元的总浮点运算次数}}{\\text{T4 每个单元的总浮点运算次数}}。\n$$\n- 另外，说明每种单元类型的唯一上三角单元刚度条目数 $(3n)(3n+1)/2$，并定性讨论这在组装后如何影响全局稀疏内存占用和矩阵带宽。\n\n仅提供 $R$ 的最终数值。将您的答案四舍五入到 $4$ 位有效数字。最终答案必须是无单位的纯数字。请勿在最终答案中包含任何额外文本。",
            "solution": "用户提供的问题是计算固体力学中一个定义明确且具有科学依据的练习。它要求推导 T4 和 T10 四面体单元刚度矩阵组装的浮点运算（FLOP）次数，计算这些次数的比率，并定性讨论矩阵存储的影响。该问题是自洽的，提供了所有必要的公式、假设和计数规则。没有科学或逻辑上的矛盾。因此，该问题被认为是有效的，并将提供解答。\n\n每个单元的总 FLOP 计数 $C_{\\text{total}}$ 是求积点数 $N_q$ 与每个求积点的 FLOP 计数 $C_{\\text{quad}}$ 的乘积。\n$$\nC_{\\text{total}} = N_q \\times C_{\\text{quad}}\n$$\n每个求积点的成本 $C_{\\text{quad}}$ 是几个连续步骤成本的总和，这些成本取决于节点数 $n$。我们将推导出一个通用表达式 $C_{\\text{quad}}(n)$。\n\n1.  **计算雅可比矩阵 $\\mathbf{J}$ 的成本**：\n    雅可比矩阵 $\\mathbf{J}$ 是一个 $3 \\times 3$ 的矩阵。其 $9$ 个条目中的每一个 $J_{ij}$ 都是通过一个包含 $n$ 个项的和来计算的。每个条目的成本被指定为 $n$ 次乘法和 $n-1$ 次加法，总计 $2n-1$ 次 FLOP。\n    $\\mathbf{J}$ 的总成本为：\n    $$\n    C_J(n) = 9 \\times (2n - 1) = 18n - 9 \\text{ FLOPs}.\n    $$\n\n2.  **计算 $\\det\\mathbf{J}$ 和 $\\mathbf{J}^{-1}$ 的成本**：\n    该成本在问题陈述中直接给出。它需要 $30$ 次乘法、$11$ 次加法和 $1$ 次除法。\n    $$\n    C_{\\text{invJ}} = 30 + 11 + 1 = 42 \\text{ FLOPs}.\n    $$\n\n3.  **将参考梯度映射到物理梯度的成本**：\n    对于 $n$ 个节点中的每一个，物理梯度 $\\nabla_{\\mathbf{x}} N_a$ 是通过 $3 \\times 3$ 矩阵-向量乘积 $\\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} N_a$ 求得的。这被指定为每个节点需要 $9$ 次乘法和 $6$ 次加法。\n    所有 $n$ 个节点的总成本是：\n    $$\n    C_{\\text{grad}}(n) = n \\times (9 + 6) = 15n \\text{ FLOPs}.\n    $$\n\n4.  **组装被积函数 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{D}\\mathbf{B}$ 并累加的成本**：\n    根据问题的规则，此过程分为几个子步骤。\n\n    a. **形成 $\\mathbf{M} = \\mathbf{D}\\mathbf{B}$**：\n    规则规定，这需要 $(6 \\cdot 3n)$ 次长度为 $6$ 的点积。长度为 $k$ 的点积需要 $k$ 次乘法和 $k-1$ 次加法，总计 $2k-1$ 次 FLOP。对于 $k=6$，成本是 $6+5=11$ 次 FLOP。\n    此步骤的总成本为：\n    $$\n    C_M(n) = (6 \\cdot 3n) \\times 11 = 18n \\times 11 = 198n \\text{ FLOPs}.\n    $$\n\n    b. **形成并累加 $\\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$**：\n    在一个求积点处的刚度矩阵贡献 $\\mathbf{K}_{qp} = \\mathbf{B}^{\\mathsf{T}}\\mathbf{M}$ 是一个对称的 $(3n) \\times (3n)$ 矩阵。我们只计算上三角条目。唯一条目的数量是 $\\frac{3n(3n+1)}{2}$。\n    每个条目都是通过长度为 $6$ 的点积计算的，成本为 $11$ 次 FLOP。\n    然后，这些条目中的每一个都被缩放并加到单元刚度矩阵中。缩放因子是 $s = w_q \\det\\mathbf{J}$，这需要 $1$ 次乘法（其中 $w_q$ 是求积权重）。累加 $(\\mathbf{K}_e)_{ij} \\leftarrow (\\mathbf{K}_e)_{ij} + s \\cdot (\\mathbf{K}_{qp})_{ij}$ 需要 $1$ 次乘法和 $1$ 次加法，总共 $2$ 次 FLOP。\n    每个条目的总成本是 $11 (\\text{点积}) + 2 (\\text{缩放-相加}) = 13$ 次 FLOP。\n    这个累加步骤的总成本，包括找到 $s$ 所需的一次乘法，是：\n    $$\n    C_{\\text{accum}}(n) = 1 + \\left( \\frac{3n(3n+1)}{2} \\right) \\times 13 = 1 + \\frac{13}{2}(9n^2 + 3n) = 1 + 58.5n^2 + 19.5n \\text{ FLOPs}.\n    $$\n\n5.  **每个求积点的总成本 $C_{\\text{quad}}(n)$**：\n    对所有步骤的成本求和：\n    $$\n    C_{\\text{quad}}(n) = C_J(n) + C_{\\text{invJ}} + C_{\\text{grad}}(n) + C_M(n) + C_{\\text{accum}}(n)\n    $$\n    $$\n    C_{\\text{quad}}(n) = (18n - 9) + 42 + 15n + 198n + (1 + 58.5n^2 + 19.5n)\n    $$\n    按 $n$ 的幂次收集项：\n    $$\n    C_{\\text{quad}}(n) = 58.5n^2 + (18 + 15 + 198 + 19.5)n + (-9 + 42 + 1)\n    $$\n    $$\n    C_{\\text{quad}}(n) = 58.5n^2 + 250.5n + 34\n    $$\n\n现在，我们将此通用公式应用于 T4 和 T10 单元。\n\n**T4 单元的总 FLOP 计数**\n对于 $4$ 节点四面体 (T4)，$n=4$ 且 $N_q=1$（$1$ 点求积）。\n$$\nC_{\\text{total}}(\\text{T4}) = 1 \\times C_{\\text{quad}}(4)\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 58.5(4^2) + 250.5(4) + 34\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 58.5(16) + 1002 + 34\n$$\n$$\nC_{\\text{total}}(\\text{T4}) = 936 + 1002 + 34 = 1972 \\text{ FLOPs}.\n$$\n\n**T10 单元的总 FLOP 计数**\n对于 $10$ 节点四面体 (T10)，$n=10$ 且 $N_q=4$（$4$ 点求积）。\n$$\nC_{\\text{total}}(\\text{T10}) = 4 \\times C_{\\text{quad}}(10)\n$$\n$$\nC_{\\text{quad}}(10) = 58.5(10^2) + 250.5(10) + 34\n$$\n$$\nC_{\\text{quad}}(10) = 58.5(100) + 2505 + 34\n$$\n$$\nC_{\\text{quad}}(10) = 5850 + 2505 + 34 = 8389 \\text{ FLOPs}.\n$$\n那么总成本是：\n$$\nC_{\\text{total}}(\\text{T10}) = 4 \\times 8389 = 33556 \\text{ FLOPs}.\n$$\n\n**比率 $R$**\n总 FLOP 计数的比率为：\n$$\nR = \\frac{C_{\\text{total}}(\\text{T10})}{C_{\\text{total}}(\\text{T4})} = \\frac{33556}{1972} \\approx 17.016227...\n$$\n四舍五入到 $4$ 位有效数字，我们得到：\n$$\nR \\approx 17.02\n$$\n\n**关于全局矩阵存储的定性讨论**\n单元刚度矩阵中唯一的上三角条目数由 $\\frac{3n(3n+1)}{2}$ 给出。\n-   对于 T4 单元（$n=4$），自由度（DOF）数量为 $3 \\times 4 = 12$。唯一条目数为 $\\frac{12(13)}{2} = 78$。\n-   对于 T10 单元（$n=10$），自由度数量为 $3 \\times 10 = 30$。唯一条目数为 $\\frac{30(31)}{2} = 465$。\n\n这对全局稀疏矩阵组装具有重要影响：\n-   **内存占用**：T10 单元为全局刚度矩阵贡献的非零条目数量*（每个单元）*是 T4 单元的 $465/78 \\approx 5.96$ 倍。虽然对于给定区域的网格划分，要达到相当的几何近似水平，所需的 T10 单元会比 T4 单元少，但每个单元非零项的增加通常会导致基于 T10 的离散化中全局矩阵的总体内存占用更大。\n-   **矩阵带宽**：全局刚度矩阵的带宽由单个单元内耦合的任意两个自由度的全局索引之间的最大差异决定。由于 T10 单元连接了 $10$ 个节点（和 $30$ 个自由度），而 T4 单元连接了 $4$ 个节点（和 $12$ 个自由度），它天生会在可能更宽的全局节点索引范围内创建连接。假设节点编号方案相似，这会导致 T10 网格的矩阵带宽显著增大。增加的带宽会对直接求解器（例如 Cholesky 分解）的计算成本和内存需求产生不利影响，并可能影响与迭代求解器一起使用的各种预条件子的性能。",
            "answer": "$$\n\\boxed{17.02}\n$$"
        }
    ]
}