{
    "hands_on_practices": [
        {
            "introduction": "The element stiffness matrix, often denoted as $\\mathbf{K}^e$, is the cornerstone of the finite element method, as it establishes the fundamental relationship between an element's nodal displacements and the corresponding nodal forces. This practice guides you through the derivation of this matrix for a bilinear quadrilateral element under plane stress, starting from the principle of virtual work. Mastering this derivation  will solidify your understanding of the isoparametric formulation and the critical role of numerical quadrature in determining the element's accuracy and computational efficiency.",
            "id": "3588803",
            "problem": "Consider a four-node bilinear isoparametric quadrilateral ($\\mathrm{Q4}$) finite element with uniform thickness $t$ modeling a homogeneous, linear elastic isotropic material under plane stress. The nodes are ordered counterclockwise, and the element occupies a rectangular region in the physical coordinate system with side length $a$ in both the $x$ and $y$ directions. The mapping from the parent space $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ to the physical space $(x,y)$ is undistorted and affine. The Poisson ratio is $\\nu$ and the Young’s modulus is $E$. Using the Finite Element Method (FEM) and starting from the principle of virtual work and the small-strain kinematics, derive the $\\mathrm{Q4}$ element stiffness matrix under plane stress, employing $2\\times 2$ Gauss quadrature in the parent space. Clearly articulate the conditions under which this $2\\times 2$ Gauss quadrature exactly integrates the stiffness matrix for an undistorted isoparametric quadrilateral.\n\nFinally, for the same undistorted square element, report the closed-form symbolic expression of the $(1,1)$ entry of the element stiffness matrix (corresponding to the $x$-displacement degree of freedom at node $1$) obtained with $2\\times 2$ Gauss quadrature. Express your final answer in terms of $E$, $\\nu$, and $t$ only. No numerical evaluation is required.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- Element type: Four-node bilinear isoparametric quadrilateral ($\\mathrm{Q4}$)\n- Geometry: Rectangular region in the physical coordinate system with side length $a$ in both the $x$ and $y$ directions.\n- Thickness: Uniform, denoted by $t$.\n- Material properties: Homogeneous, linear elastic isotropic with Young’s modulus $E$ and Poisson ratio $\\nu$.\n- Stress state: Plane stress.\n- Mapping: From parent space $(\\xi, \\eta) \\in [-1,1] \\times [-1,1]$ to physical space $(x,y)$ is undistorted and affine.\n- Node ordering: Counterclockwise.\n- Numerical integration: $2 \\times 2$ Gauss quadrature.\n- Task 1: Derive the $\\mathrm{Q4}$ element stiffness matrix under plane stress.\n- Task 2: Articulate the conditions for exact integration of the stiffness matrix for an undistorted isoparametric quadrilateral using $2 \\times 2$ Gauss quadrature.\n- Task 3: Report the closed-form symbolic expression for the $(1,1)$ entry of the element stiffness matrix, $k_{11}$, for the specified square element. The answer should be in terms of $E$, $\\nu$, and $t$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is a a standard, canonical problem in the field of computational solid mechanics and the Finite Element Method (FEM). All concepts, including plane stress, linear elasticity, isoparametric formulation, and Gauss quadrature, are fundamental and scientifically sound.\n- **Well-Posed:** The problem is well-defined. It provides all necessary material properties ($E, \\nu$), geometric parameters ($a, t$), and procedural details (plane stress, $\\mathrm{Q4}$ element, $2 \\times 2$ Gauss quadrature) to derive a unique and meaningful solution for the stiffness matrix and its specific component.\n- **Objective:** The problem is stated in precise, objective language, free of any subjective or ambiguous terminology.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, and objective. It does not violate any of the specified invalidity criteria. Therefore, a reasoned solution will be provided.\n\n***\n\nThe element stiffness matrix, $\\mathbf{K}^e$, for a two-dimensional continuum element is derived from the principle of virtual work. It is given by the integral of the product of the strain-displacement matrix $\\mathbf{B}$, the constitutive matrix $\\mathbf{D}$, and the transpose of the strain-displacement matrix $\\mathbf{B}^T$ over the volume of the element $V^e$. For an element of uniform thickness $t$, this integral becomes:\n$$ \\mathbf{K}^e = \\int_{V^e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dV = t \\int_{A^e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, dA $$\nwhere $A^e$ is the area of the element in the physical $(x,y)$ coordinate system.\n\nThe isoparametric formulation maps this integral to the parent domain $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$:\n$$ \\mathbf{K}^e = t \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} J \\, d\\xi \\, d\\eta $$\nwhere $J$ is the determinant of the Jacobian matrix $\\mathbf{J}$.\n\nThe components of this formulation are as follows:\n\n**1. Constitutive Matrix ($\\mathbf{D}$):**\nFor a linear elastic, isotropic material under plane stress conditions, the constitutive matrix relating the stress vector $\\boldsymbol{\\sigma} = \\{\\sigma_x, \\sigma_y, \\tau_{xy}\\}^T$ to the strain vector $\\boldsymbol{\\epsilon} = \\{\\epsilon_x, \\epsilon_y, \\gamma_{xy}\\}^T$ is:\n$$ \\mathbf{D} = \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{pmatrix} $$\n\n**2. Strain-Displacement Matrix ($\\mathbf{B}$):**\nThe strains are related to the nodal displacements $\\mathbf{d}^e = \\{u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4\\}^T$ through the strain-displacement matrix $\\mathbf{B}$, where $\\boldsymbol{\\epsilon} = \\mathbf{B} \\mathbf{d}^e$. The $\\mathbf{B}$ matrix is assembled from nodal contributions $\\mathbf{B}_i$:\n$$ \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4], \\quad \\text{where} \\quad \\mathbf{B}_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x} \\end{pmatrix} $$\nThe quantities $N_i$ are the bilinear shape functions for the $\\mathrm{Q4}$ element:\n$$ N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) $$\n$$ N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta) $$\n\n**3. Jacobian of the Transformation ($\\mathbf{J}$):**\nThe derivatives of the shape functions with respect to the physical coordinates $(x,y)$ are found using the chain rule, which involves the Jacobian matrix $\\mathbf{J}$:\n$$ \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} $$\nThe components of $\\mathbf{J}$ are calculated from the element geometry $x(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) x_i$ and $y(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) y_i$. For the specified square element of side length $a$, we may place its center at the origin, giving nodal coordinates: $P_1(-a/2, -a/2)$, $P_2(a/2, -a/2)$, $P_3(a/2, a/2)$, and $P_4(-a/2, a/2)$. The mapping becomes:\n$$ x = \\frac{a}{2}\\xi \\quad \\text{and} \\quad y = \\frac{a}{2}\\eta $$\nThe Jacobian matrix is therefore constant:\n$$ \\mathbf{J} = \\begin{pmatrix} a/2 & 0 \\\\ 0 & a/2 \\end{pmatrix} $$\nThe determinant of the Jacobian is $J = \\det(\\mathbf{J}) = \\frac{a^2}{4}$, which is also constant. The inverse Jacobian is:\n$$ \\mathbf{J}^{-1} = \\begin{pmatrix} 2/a & 0 \\\\ 0 & 2/a \\end{pmatrix} $$\n\n**Condition for Exact Integration:**\nThe stiffness matrix is evaluated using numerical quadrature:\n$$ \\mathbf{K}^e = t \\sum_{i=1}^{n} \\sum_{j=1}^{n} w_i w_j \\left[ \\mathbf{B}^T \\mathbf{D} \\mathbf{B} J \\right]_{(\\xi_i, \\eta_j)} $$\nwhere $(\\xi_i, \\eta_j)$ are the Gauss points and $w_i, w_j$ are the corresponding weights. A $2 \\times 2$ Gauss quadrature scheme ($n=2$) is exact for polynomials of degree up to $2n-1 = 3$ in each variable $\\xi$ and $\\eta$.\nLet us examine the integrand, $\\mathbf{F}(\\xi, \\eta) = \\mathbf{B}^T \\mathbf{D} \\mathbf{B} J$. The matrix $\\mathbf{D}$ is constant. For an element whose geometry is a parallelogram (which includes rectangles, rhombi, etc.), the mapping is affine, and the Jacobian matrix $\\mathbf{J}$ and its determinant $J$ are constant.\nThe derivatives of the shape functions with respect to parent coordinates (e.g., $\\frac{\\partial N_i}{\\partial \\xi}$) are linear functions of the other parent coordinate. Since $\\mathbf{J}^{-1}$ is constant, the derivatives with respect to physical coordinates (e.g., $\\frac{\\partial N_i}{\\partial x}$) are also linear in $\\xi$ or $\\eta$.\nThe entries of $\\mathbf{B}$ are therefore linear functions of $\\xi$ and $\\eta$. The product $\\mathbf{B}^T \\mathbf{D} \\mathbf{B}$ will thus contain entries that are polynomials of at most degree $2$ in $\\xi$ and $\\eta$ (e.g., terms like $\\xi^2, \\eta^2, \\xi\\eta, \\xi, \\eta$).\nSince the integrand is a polynomial of degree at most $2$, a $2 \\times 2$ Gauss quadrature, which is exact up to degree $3$, will integrate the stiffness matrix exactly.\n**Therefore, the condition under which $2 \\times 2$ Gauss quadrature exactly integrates the stiffness matrix for an isoparametric quadrilateral is that the element geometry must be a parallelogram in the physical coordinate system, which ensures the Jacobian matrix $\\mathbf{J}$ is constant.**\n\n**Calculation of the Stiffness Matrix Component $k_{11}$:**\nWe are asked to find the $(1,1)$ entry of the element stiffness matrix $\\mathbf{K}^e$, corresponding to the degree of freedom $u_1$ (the $x$-displacement of node 1). This is given by the $(1,1)$ entry of the submatrix $\\mathbf{k}_{11} = t \\int_{A^e} \\mathbf{B}_1^T \\mathbf{D} \\mathbf{B}_1 dA$.\nLet the columns of $\\mathbf{B}_1$ be $\\mathbf{b}_{1u}$ and $\\mathbf{b}_{1v}$. The desired term is:\n$$ k_{11} = t \\int_{A^e} \\mathbf{b}_{1u}^T \\mathbf{D} \\mathbf{b}_{1u} \\, dA = t \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{b}_{1u}^T \\mathbf{D} \\mathbf{b}_{1u} J \\, d\\xi d\\eta $$\nThe inner product is:\n$$ \\mathbf{b}_{1u}^T \\mathbf{D} \\mathbf{b}_{1u} = \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} & 0 & \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} \\frac{E}{1-\\nu^2} \\begin{pmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\frac{1-\\nu}{2} \\end{pmatrix} \\begin{pmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ 0 \\\\ \\frac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\frac{E}{1-\\nu^2} \\left[ \\left(\\frac{\\partial N_1}{\\partial x}\\right)^2 + \\frac{1-\\nu}{2}\\left(\\frac{\\partial N_1}{\\partial y}\\right)^2 \\right] $$\nWe find the derivatives of $N_1$:\n$$ \\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi) $$\n$$ \\begin{Bmatrix} \\frac{\\partial N_1}{\\partial x} \\\\ \\frac{\\partial N_1}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_1}{\\partial \\xi} \\\\ \\frac{\\partial N_1}{\\partial \\eta} \\end{Bmatrix} = \\begin{pmatrix} 2/a & 0 \\\\ 0 & 2/a \\end{pmatrix} \\begin{Bmatrix} -\\frac{1}{4}(1-\\eta) \\\\ -\\frac{1}{4}(1-\\xi) \\end{Bmatrix} = \\begin{Bmatrix} -\\frac{1}{2a}(1-\\eta) \\\\ -\\frac{1}{2a}(1-\\xi) \\end{Bmatrix} $$\nSubstituting these into the expression for $k_{11}$ along with $J=a^2/4$:\n$$ k_{11} = t \\int_{-1}^{1}\\int_{-1}^{1} \\frac{E}{1-\\nu^2} \\left[ \\left(\\frac{-(1-\\eta)}{2a}\\right)^2 + \\frac{1-\\nu}{2} \\left(\\frac{-(1-\\xi)}{2a}\\right)^2 \\right] \\frac{a^2}{4} \\, d\\xi d\\eta $$\n$$ k_{11} = \\frac{Et}{1-\\nu^2} \\frac{a^2}{4} \\frac{1}{4a^2} \\int_{-1}^{1}\\int_{-1}^{1} \\left[ (1-\\eta)^2 + \\frac{1-\\nu}{2} (1-\\xi)^2 \\right] \\, d\\xi d\\eta $$\n$$ k_{11} = \\frac{Et}{16(1-\\nu^2)} \\int_{-1}^{1}\\int_{-1}^{1} \\left[ (1-2\\eta+\\eta^2) + \\frac{1-\\nu}{2} (1-2\\xi+\\xi^2) \\right] \\, d\\xi d\\eta $$\nSince $2 \\times 2$ Gauss quadrature is exact, we can perform analytical integration. We use the standard integrals $\\int_{-1}^{1} 1\\,dz = 2$, $\\int_{-1}^{1} z\\,dz = 0$, and $\\int_{-1}^{1} z^2\\,dz = 2/3$.\n$$ \\int_{-1}^{1}\\int_{-1}^{1} (1-2\\eta+\\eta^2) \\, d\\xi d\\eta = \\int_{-1}^{1} d\\xi \\int_{-1}^{1} (1-2\\eta+\\eta^2) \\, d\\eta = (2) \\left(2-0+\\frac{2}{3}\\right) = 2 \\cdot \\frac{8}{3} = \\frac{16}{3} $$\n$$ \\int_{-1}^{1}\\int_{-1}^{1} \\frac{1-\\nu}{2} (1-2\\xi+\\xi^2) \\, d\\xi d\\eta = \\frac{1-\\nu}{2} \\int_{-1}^{1} d\\eta \\int_{-1}^{1} (1-2\\xi+\\xi^2) \\, d\\xi = \\frac{1-\\nu}{2} (2) \\left(\\frac{8}{3}\\right) = \\frac{8(1-\\nu)}{3} $$\nSumming the results:\n$$ k_{11} = \\frac{Et}{16(1-\\nu^2)} \\left[ \\frac{16}{3} + \\frac{8(1-\\nu)}{3} \\right] = \\frac{Et}{16(1-\\nu^2)} \\frac{8}{3} [2 + (1-\\nu)] $$\n$$ k_{11} = \\frac{Et}{6(1-\\nu^2)} (3-\\nu) $$\nThis is the symbolic expression for the $(1,1)$ entry of the stiffness matrix.",
            "answer": "$$\\boxed{\\frac{Et(3-\\nu)}{6(1-\\nu^2)}}$$"
        },
        {
            "introduction": "Complementing the stiffness matrix, the consistent load vector is essential for translating distributed physical loads, such as gravitational body forces or surface pressures, into a set of equivalent forces at the element's nodes. This exercise involves applying the principle of virtual work to a uniform body force, which requires integrating the product of the element's shape functions and the force field over the element's domain. By completing this task , you will learn how to ensure that the applied loads in your finite element model are energetically consistent with the continuous physical problem you are simulating.",
            "id": "3588779",
            "problem": "Consider a four-node bilinear quadrilateral finite element (Q4) used in the Finite Element Method (FEM) for a two-dimensional plane stress analysis. The element has uniform thickness $t$ and is subjected to a uniform body force field with components $b_x$ and $b_y$ (force per unit volume). The nodal coordinates of the element in the physical $(x,y)$-plane are\n$$\n(x_1,y_1)=(0,0),\\quad (x_2,y_2)=(3,1),\\quad (x_3,y_3)=(5,4),\\quad (x_4,y_4)=(2,3),\n$$\nwith the local node ordering $(1,2,3,4)$ corresponding to the standard bilinear shape functions defined on the parent square $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$.\n\nStarting from the principle of virtual work and the isoparametric finite element formulation, derive the consistent nodal body force load vector for this element. Evaluate the required integrals using an appropriate two-dimensional Gauss quadrature rule that ensures exact integration for this case, and present the final eight-component nodal load vector in the order\n$$\n[F_{1x},\\,F_{1y},\\,F_{2x},\\,F_{2y},\\,F_{3x},\\,F_{3y},\\,F_{4x},\\,F_{4y}],\n$$\nas a single closed-form expression in terms of $b_x$, $b_y$, and $t$. Express the final nodal forces in Newtons. No rounding is required.",
            "solution": "The consistent nodal body force vector for a two-dimensional element in the Finite Element Method (FEM) follows from the principle of virtual work. For a uniform body force per unit volume with components $b_x$ and $b_y$ and uniform thickness $t$, the virtual external work over the element domain $\\Omega_e$ is\n$$\n\\delta W_{\\text{ext}} \\;=\\; \\int_{\\Omega_e} t\\,\\delta \\boldsymbol{u}^{\\mathsf{T}}\\,\\boldsymbol{b}\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\boldsymbol{b}=\\begin{pmatrix}b_x\\\\ b_y\\end{pmatrix}$ and $\\delta \\boldsymbol{u}$ is the virtual displacement vector field. With the standard isoparametric interpolation, the displacement field is approximated by\n$$\n\\boldsymbol{u}(\\xi,\\eta) \\;=\\; \\boldsymbol{N}(\\xi,\\eta)\\,\\boldsymbol{d},\\quad \\delta \\boldsymbol{u}(\\xi,\\eta) \\;=\\; \\boldsymbol{N}(\\xi,\\eta)\\,\\delta \\boldsymbol{d},\n$$\nwhere $\\boldsymbol{d}$ is the vector of nodal displacement degrees of freedom, and $\\boldsymbol{N}(\\xi,\\eta)$ is the $2\\times 8$ shape function matrix constructed from the scalar shape functions $N_i(\\xi,\\eta)$ as\n$$\n\\boldsymbol{N}(\\xi,\\eta) \\;=\\;\n\\begin{pmatrix}\nN_1 & 0 & N_2 & 0 & N_3 & 0 & N_4 & 0\\\\\n0 & N_1 & 0 & N_2 & 0 & N_3 & 0 & N_4\n\\end{pmatrix}.\n$$\nSubstituting into $\\delta W_{\\text{ext}}$ and invoking arbitrariness of $\\delta \\boldsymbol{d}$ yields the consistent element body force vector\n$$\n\\boldsymbol{f}_e \\;=\\; t \\int_{\\Omega_e} \\boldsymbol{N}^{\\mathsf{T}}(\\xi,\\eta)\\,\\boldsymbol{b}\\,\\mathrm{d}\\Omega \\;=\\; t \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{N}^{\\mathsf{T}}(\\xi,\\eta)\\,\\boldsymbol{b}\\,\\det\\boldsymbol{J}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\n$$\nwhere $\\det\\boldsymbol{J}(\\xi,\\eta)$ is the determinant of the Jacobian matrix of the isoparametric mapping from $(\\xi,\\eta)$ to $(x,y)$.\n\nThe scalar bilinear shape functions on the parent domain are\n$$\n\\begin{aligned}\nN_1(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\\\\nN_2(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\\\\nN_3(\\xi,\\eta) &= \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\\\\nN_4(\\xi,\\eta) &= \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n\\end{aligned}\n$$\nWith the given nodal coordinates, the element is a parallelogram, since the edge vectors satisfy\n$$\n\\boldsymbol{a} = \\begin{pmatrix}x_2-x_1\\\\ y_2-y_1\\end{pmatrix} = \\begin{pmatrix}3\\\\1\\end{pmatrix},\\qquad\n\\boldsymbol{b} = \\begin{pmatrix}x_4-x_1\\\\ y_4-y_1\\end{pmatrix} = \\begin{pmatrix}2\\\\3\\end{pmatrix},\n$$\nand the opposite edges have the same direction vectors:\n$$\n\\begin{pmatrix}x_3-x_2\\\\ y_3-y_2\\end{pmatrix} = \\boldsymbol{b},\\qquad\n\\begin{pmatrix}x_3-x_4\\\\ y_3-y_4\\end{pmatrix} = \\boldsymbol{a}.\n$$\nFor an affine (parallelogram) mapping, the Jacobian determinant $\\det\\boldsymbol{J}$ is constant over the parent domain, and the physical area of the element is\n$$\nA_e \\;=\\; |\\boldsymbol{a}_x \\boldsymbol{b}_y - \\boldsymbol{a}_y \\boldsymbol{b}_x| \\;=\\; |(3)(3) - (1)(2)| \\;=\\; 7,\n$$\nwhile the constant Jacobian determinant equals\n$$\n\\det\\boldsymbol{J} \\;=\\; \\frac{A_e}{4} \\;=\\; \\frac{7}{4},\n$$\nbecause the area scales as $A_e = \\int_{-1}^{1}\\int_{-1}^{1} \\det\\boldsymbol{J}\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta = 4\\,\\det\\boldsymbol{J}$ for a constant $\\det\\boldsymbol{J}$.\n\nTherefore, each pair of nodal body force components is\n$$\n\\begin{pmatrix}F_{ix}\\\\ F_{iy}\\end{pmatrix}\n\\;=\\; t \\int_{-1}^{1}\\int_{-1}^{1}\n\\begin{pmatrix}N_i(\\xi,\\eta)\\,b_x\\\\ N_i(\\xi,\\eta)\\,b_y\\end{pmatrix}\n\\,\\det\\boldsymbol{J}\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n\\;=\\; t\\,\\det\\boldsymbol{J}\\,\n\\begin{pmatrix}b_x\\\\ b_y\\end{pmatrix}\n\\int_{-1}^{1}\\int_{-1}^{1} N_i(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta.\n$$\nWe now evaluate $\\int_{-1}^{1}\\int_{-1}^{1} N_i(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$ using the two-point Gauss quadrature in each direction, which is exact for integrating bilinear functions over the parent square. The one-dimensional Gauss points and weights are\n$$\n\\xi_k = \\pm \\frac{1}{\\sqrt{3}},\\quad \\eta_\\ell = \\pm \\frac{1}{\\sqrt{3}},\\qquad w_\\xi = 1,\\quad w_\\eta = 1,\n$$\nso the two-dimensional quadrature approximates (and in this case exactly equals)\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} N_i(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n\\;=\\; \\sum_{k=1}^{2}\\sum_{\\ell=1}^{2} w_\\xi w_\\eta\\,N_i(\\xi_k,\\eta_\\ell)\n\\;=\\; \\sum_{(\\xi,\\eta)\\in\\{\\pm 1/\\sqrt{3}\\}^2} N_i(\\xi,\\eta).\n$$\nA direct evaluation shows that this sum equals $1$ for each $i=1,2,3,4$. Alternatively, integrating analytically,\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} N_i(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n\\;=\\; \\frac{1}{4}\\left(\\int_{-1}^{1}(1\\pm \\xi)\\,\\mathrm{d}\\xi\\right)\n\\left(\\int_{-1}^{1}(1\\pm \\eta)\\,\\mathrm{d}\\eta\\right)\n\\;=\\; \\frac{1}{4}\\cdot 2\\cdot 2 \\;=\\; 1,\n$$\nconfirming the quadrature result. Thus, for each node $i$,\n$$\n\\begin{pmatrix}F_{ix}\\\\ F_{iy}\\end{pmatrix}\n\\;=\\; t\\,\\det\\boldsymbol{J}\\,\\begin{pmatrix}b_x\\\\ b_y\\end{pmatrix}\n\\;=\\; t\\,\\frac{A_e}{4}\\,\\begin{pmatrix}b_x\\\\ b_y\\end{pmatrix}\n\\;=\\; t\\,\\frac{7}{4}\\,\\begin{pmatrix}b_x\\\\ b_y\\end{pmatrix}.\n$$\nCollecting the components in the prescribed order yields the consistent element body force vector\n$$\n\\boldsymbol{f}_e \\;=\\; \\left[\nt\\,\\frac{7}{4}\\,b_x,\\;\\;t\\,\\frac{7}{4}\\,b_y,\\;\\;\nt\\,\\frac{7}{4}\\,b_x,\\;\\;t\\,\\frac{7}{4}\\,b_y,\\;\\;\nt\\,\\frac{7}{4}\\,b_x,\\;\\;t\\,\\frac{7}{4}\\,b_y,\\;\\;\nt\\,\\frac{7}{4}\\,b_x,\\;\\;t\\,\\frac{7}{4}\\,b_y\n\\right],\n$$\nwhich is expressed in Newtons when $b_x$ and $b_y$ are in Newtons per cubic meter and $t$ is in meters.",
            "answer": "$$\\boxed{\\begin{bmatrix}\n\\frac{7}{4}\\,t\\,b_x & \\frac{7}{4}\\,t\\,b_y & \\frac{7}{4}\\,t\\,b_x & \\frac{7}{4}\\,t\\,b_y & \\frac{7}{4}\\,t\\,b_x & \\frac{7}{4}\\,t\\,b_y & \\frac{7}{4}\\,t\\,b_x & \\frac{7}{4}\\,t\\,b_y\n\\end{bmatrix}}$$"
        },
        {
            "introduction": "A standard finite element analysis directly computes nodal displacements, but the resulting stress fields are typically discontinuous across element boundaries and less accurate than the displacements. This advanced practice challenges you to implement the Zienkiewicz-Zhu (ZZ) patch recovery, a powerful post-processing technique that creates a more accurate and continuous stress field by fitting a local polynomial to the highly accurate stress values at Gauss points. By deriving and implementing the weighted least-squares procedure , you will gain practical skills in error estimation and results enhancement, bridging the gap between fundamental FEM theory and high-fidelity computational analysis.",
            "id": "3588781",
            "problem": "You are tasked to implement the Zienkiewicz–Zhu (ZZ) patch recovery method for a plane strain finite element mesh, and to derive the local least-squares algebraic system that fits a linear stress field to Gauss point data. Start from fundamental computational solid mechanics principles. Use small-strain kinematics, linear elastic constitutive laws, and isoparametric bilinear four-node quadrilateral finite elements. The ZZ recovery constructs, for each mesh node, a polynomial stress field that best fits the sampled stress values at Gauss points over the node’s element patch in the least-squares sense.\n\nFundamental starting point:\n- Kinematics: infinitesimal strain-displacement relation $ \\boldsymbol{\\varepsilon} = \\nabla^{s} \\mathbf{u} $, where $\\nabla^{s}$ denotes the symmetric gradient. In two dimensions, with Cartesian coordinates $x$ and $y$, the strain vector in Voigt notation is $ \\boldsymbol{\\varepsilon} = [ \\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy} ]^{\\mathsf{T}} $ with $\\gamma_{xy} = \\partial u_x / \\partial y + \\partial u_y / \\partial x$.\n- Constitutive law for linear elasticity in plane strain: $ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} $, where $ \\boldsymbol{\\sigma} = [ \\sigma_{xx}, \\sigma_{yy}, \\tau_{xy} ]^{\\mathsf{T}} $ and\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n\\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} & \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} & 0 \\\\\n\\frac{E\\nu}{(1+\\nu)(1-2\\nu)} & \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} & 0 \\\\\n0 & 0 & \\frac{E}{2(1+\\nu)}\n\\end{bmatrix},\n$$\nwith Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n- Isoparametric bilinear quadrilateral element: shape functions $N_i(\\xi,\\eta)$ for nodes $i=1,\\dots,4$ on the parent domain $[-1,1]\\times[-1,1]$; the Jacobian $ \\mathbf{J} $ maps derivatives from parent coordinates $(\\xi,\\eta)$ to physical coordinates $(x,y)$; the strain-displacement matrix $\\mathbf{B}$ relates nodal displacements to strains via $ \\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e $, where $ \\mathbf{u}_e $ is the element nodal displacement vector.\n\nLocal least-squares fitting model to be derived:\n- For each stress component, assume a linear polynomial model in physical coordinates:\n$$\ns(x,y) = a_0 + a_1 x + a_2 y,\n$$\nwhere $s$ represents one of $ \\sigma_{xx}, \\sigma_{yy}, \\tau_{xy} $ and $ \\mathbf{a} = [a_0, a_1, a_2]^{\\mathsf{T}} $ are unknown coefficients for the patch. Given Gauss point data $\\{ (x_i, y_i, s_i, w_i ) \\}_{i=1}^{n}$, pose the weighted least-squares problem $ \\min_{\\mathbf{a}} \\sum_{i=1}^{n} w_i \\left( a_0 + a_1 x_i + a_2 y_i - s_i \\right)^2 $ and derive the normal equations.\n\nProgramming task:\n1. Construct a $2 \\times 2$ element mesh over the square domain $[0,2] \\times [0,2]$ with nine nodes located at integer coordinates $(x,y) \\in \\{0,1,2\\} \\times \\{0,1,2\\}$. The four bilinear quadrilateral elements connect the nodes:\n   - Element $e_0$: nodes $(0,0)\\text{-}(1,0)\\text{-}(1,1)\\text{-}(0,1)$,\n   - Element $e_1$: nodes $(1,0)\\text{-}(2,0)\\text{-}(2,1)\\text{-}(1,1)$,\n   - Element $e_2$: nodes $(0,1)\\text{-}(1,1)\\text{-}(1,2)\\text{-}(0,2)$,\n   - Element $e_3$: nodes $(1,1)\\text{-}(2,1)\\text{-}(2,2)\\text{-}(1,2)$.\n2. Use material parameters $E = 210 \\times 10^9$ (Pascals) and $\\nu = 0.3$ (dimensionless).\n3. Prescribe nodal displacements sampled from the bilinear field\n   $$\n   u_x(x,y) = a x + b y + c x y, \\quad u_y(x,y) = d x + e y + f x y,\n   $$\n   with coefficients $ a = 1.0 \\times 10^{-3}, \\ b = 2.0 \\times 10^{-3}, \\ c = 3.0 \\times 10^{-3}, \\ d = -1.0 \\times 10^{-3}, \\ e = 1.5 \\times 10^{-3}, \\ f = -2.0 \\times 10^{-3} $ in meters, using the physical coordinates of the mesh nodes.\n4. For each element, at the standard $2 \\times 2$ Gauss points $(\\xi,\\eta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$ with unit weights, compute $ \\boldsymbol{\\sigma}(\\xi,\\eta) = \\mathbf{D} \\mathbf{B}(\\xi,\\eta) \\mathbf{u}_e $, and record the physical coordinates $(x,y)$ of each Gauss point via $ (x,y) = \\sum_{i=1}^{4} N_i(\\xi,\\eta) (x_i,y_i)$.\n5. Implement the Zienkiewicz–Zhu (ZZ) patch recovery: for a given node $n$, collect the Gauss point data $(x_i, y_i, s_i, w_i)$ from all elements sharing node $n$. Fit the linear model $ s(x,y) = a_0 + a_1 x + a_2 y $ to the Gauss data for each stress component $ s \\in \\{ \\sigma_{xx}, \\sigma_{yy}, \\tau_{xy} \\} $ using weighted least-squares with weights $ w_i = \\det(\\mathbf{J}(\\xi_i,\\eta_i)) $ of the parent-to-physical mapping at each Gauss point. Solve the normal equations and evaluate the recovered stress at the node coordinate $(x_n,y_n)$ as $ s^{\\text{rec}}(x_n,y_n) = a_0 + a_1 x_n + a_2 y_n $.\n6. To test numerical robustness, inject a small deterministic noise into the Gauss point stresses of element $e_0$ only: add $\\delta$ to each Gauss point stress component in $e_0$ with $ \\delta = \\alpha \\, s $ where $ \\alpha = 5.0 \\times 10^{-3} $ for that component at that point. All other elements remain noise-free. Use the same weights $ w_i $ as in item 5.\n\nTest suite:\n- Case 1 (interior patch): Node at $(1,1)$ belongs to four elements; recover and report the three stress components $ \\sigma_{xx}, \\sigma_{yy}, \\tau_{xy} $ evaluated at $(1,1)$.\n- Case 2 (edge patch): Node at $(0,1)$ belongs to two elements; recover and report $ \\sigma_{xx} $ evaluated at $(0,1)$.\n- Case 3 (corner patch with noisy data): Node at $(0,0)$ belongs to one element ($e_0$); recover and report $ \\tau_{xy} $ evaluated at $(0,0)$.\n\nAnswer specifications:\n- All reported stresses must be expressed in Pascals $(\\text{Pa})$.\n- The final program output must be a single line containing a comma-separated list enclosed in square brackets, in the order\n$$\n[ \\sigma_{xx}(1,1), \\ \\sigma_{yy}(1,1), \\ \\tau_{xy}(1,1), \\ \\sigma_{xx}(0,1), \\ \\tau_{xy}(0,0) ].\n$$\nNo other text should be printed.\n\nYour program must be self-contained, must not read any input, and must implement the complete workflow: element stress computation at Gauss points, patch assembly, weighted least-squares recovery per node, and evaluation at the specified nodes. Use the specified execution environment and libraries exactly as described.",
            "solution": "The problem is valid. It presents a well-posed, scientifically grounded task in computational solid mechanics that is complete and verifiable. All necessary parameters, equations, and procedures are explicitly defined.\n\nThe task is to implement the Zienkiewicz–Zhu (ZZ) patch recovery method for a finite element mesh. This method is a post-processing technique used to obtain a more accurate, continuous stress field from the discontinuous, less accurate stress field typically computed by the Finite Element Method (FEM). The core idea is to fit a single, continuous polynomial function to the highly accurate stress values at Gauss quadrature points within a \"patch\" of elements surrounding a specific node.\n\n### 1. Finite Element Formulation for a Bilinear Quadrilateral Element\n\nWe begin with the standard formulation for an isoparametric four-node quadrilateral element under plane strain conditions.\n\n#### 1.1. Isoparametric Mapping and Shape Functions\nThe geometry and displacement field within the element are interpolated from nodal values using the same set of shape functions, $N_i$. For a bilinear element defined on a parent domain $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$, the shape functions are:\n$$\nN_i(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_i\\xi)(1+\\eta_i\\eta), \\quad i=1, \\dots, 4\n$$\nwhere $(\\xi_i, \\eta_i)$ are the coordinates of the element's local nodes (e.g., $(-1,-1), (1,-1), (1,1), (-1,1)$).\n\nThe physical coordinates $(x,y)$ of any point within the element are mapped from the parent coordinates $(\\xi,\\eta)$ using these shape functions and the element's nodal coordinates $(x_i, y_i)$:\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) y_i\n$$\n\n#### 1.2. Jacobian and Strain-Displacement Matrix\nTo compute strains, we need derivatives of displacements with respect to physical coordinates $(x,y)$. The chain rule of differentiation connects these to derivatives in the parent domain via the Jacobian matrix $\\mathbf{J}$:\n$$\n\\mathbf{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} \\sum_i \\frac{\\partial N_i}{\\partial \\xi} x_i & \\sum_i \\frac{\\partial N_i}{\\partial \\xi} y_i \\\\ \\sum_i \\frac{\\partial N_i}{\\partial \\eta} x_i & \\sum_i \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{bmatrix}\n$$\nThe relationship for derivatives of a function $f$ is:\n$$\n\\begin{Bmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial f}{\\partial \\xi} \\\\ \\frac{\\partial f}{\\partial \\eta} \\end{Bmatrix}\n$$\nThe displacement field $\\mathbf{u}(x,y) = [u_x(x,y), u_y(x,y)]^{\\mathsf{T}}$ is also interpolated: $\\mathbf{u}(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\mathbf{u}_i$, where $\\mathbf{u}_i = [u_{ix}, u_{iy}]^{\\mathsf{T}}$ are the nodal displacements. The strain-displacement relation $\\boldsymbol{\\varepsilon} = \\nabla^s \\mathbf{u}$ is expressed in matrix form as $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$, where $\\mathbf{u}_e$ is the vector of all element nodal displacements. The matrix $\\mathbf{B}$ is constructed from the derivatives of the shape functions with respect to physical coordinates:\n$$\n\\mathbf{B}_i = \\begin{bmatrix}\n\\frac{\\partial N_i}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_i}{\\partial y} \\\\\n\\frac{\\partial N_i}{\\partial y} & \\frac{\\partial N_i}{\\partial x}\n\\end{bmatrix}, \\quad \\text{and} \\quad \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\n$$\nThe derivatives $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ are computed using $\\mathbf{J}^{-1}$ and the derivatives $\\frac{\\partial N_i}{\\partial \\xi}$ and $\\frac{\\partial N_i}{\\partial \\eta}$.\n\n#### 1.3. Stress Calculation\nWith the strain vector $\\boldsymbol{\\varepsilon}$ computed at a Gauss point, the corresponding stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^{\\mathsf{T}}$ is found using the linear elastic constitutive law for plane strain, $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$. The matrix $\\mathbf{D}$ is given as:\n$$\n\\mathbf{D} =\n\\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{bmatrix}\n1-\\nu & \\nu & 0 \\\\\n\\nu & 1-\\nu & 0 \\\\\n0 & 0 & \\frac{1-2\\nu}{2}\n\\end{bmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. These stresses, computed at Gauss points, are the input for the recovery process.\n\n### 2. Weighted Least-Squares for Patch Recovery\n\nFor a given node, we assemble a patch of all elements connected to it. We then collect the stress values $s_i$ for one component (e.g., $\\sigma_{xx}$) at all Gauss points $i=1, \\dots, n$ within this patch. Each Gauss point is associated with its physical coordinates $(x_i, y_i)$ and a weight $w_i$.\n\n#### 2.1. Local Stress Model and Minimization\nWe assume a local, recovered stress field $s^{\\text{rec}}(x,y)$ that is a linear polynomial in the physical coordinates:\n$$\ns^{\\text{rec}}(x,y) = a_0 + a_1 x + a_2 y = \\mathbf{P}(x,y) \\mathbf{a}\n$$\nwhere $\\mathbf{P}(x,y) = [1, x, y]$ and $\\mathbf{a} = [a_0, a_1, a_2]^{\\mathsf{T}}$ is the vector of unknown coefficients. The ZZ method finds the best-fit coefficients $\\mathbf{a}$ by minimizing the weighted sum of squared residuals between the recovered field and the Gauss point stresses:\n$$\n\\min_{\\mathbf{a}} F(\\mathbf{a}) = \\min_{\\mathbf{a}} \\sum_{i=1}^{n} w_i \\left( s^{\\text{rec}}(x_i, y_i) - s_i \\right)^2 = \\min_{\\mathbf{a}} \\sum_{i=1}^{n} w_i \\left( a_0 + a_1 x_i + a_2 y_i - s_i \\right)^2\n$$\nThe problem specifies the weight $w_i$ as the determinant of the Jacobian, $w_i = \\det(\\mathbf{J}_i)$, at the corresponding Gauss point.\n\n#### 2.2. Derivation of the Normal Equations\nTo find the minimum, we take the partial derivatives of $F(\\mathbf{a})$ with respect to each coefficient $a_j$ and set them to zero:\n$$\n\\frac{\\partial F}{\\partial a_0} = \\sum_{i=1}^{n} 2 w_i (a_0 + a_1 x_i + a_2 y_i - s_i) = 0\n$$\n$$\n\\frac{\\partial F}{\\partial a_1} = \\sum_{i=1}^{n} 2 w_i (a_0 + a_1 x_i + a_2 y_i - s_i) x_i = 0\n$$\n$$\n\\frac{\\partial F}{\\partial a_2} = \\sum_{i=1}^{n} 2 w_i (a_0 + a_1 x_i + a_2 y_i - s_i) y_i = 0\n$$\nRearranging these equations yields a $3 \\times 3$ symmetric linear system of normal equations, $\\mathbf{M} \\mathbf{a} = \\mathbf{f}$:\n$$\n\\left[ \\sum_{i=1}^{n} w_i\n\\begin{bmatrix}\n1 & x_i & y_i \\\\\nx_i & x_i^2 & x_i y_i \\\\\ny_i & x_i y_i & y_i^2\n\\end{bmatrix} \\right]\n\\begin{Bmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{Bmatrix} =\n\\left[ \\sum_{i=1}^{n} w_i s_i\n\\begin{Bmatrix} 1 \\\\ x_i \\\\ y_i \\end{Bmatrix} \\right]\n$$\nThis system can be written concisely as $(\\sum_{i=1}^n w_i \\mathbf{P}_i^{\\mathsf{T}} \\mathbf{P}_i) \\mathbf{a} = (\\sum_{i=1}^n w_i \\mathbf{P}_i^{\\mathsf{T}} s_i)$. Solving this system yields the coefficients $\\mathbf{a}$. The recovered stress at any point $(x_n, y_n)$, such as the node of interest, is then simply $s^{\\text{rec}}(x_n, y_n) = a_0 + a_1 x_n + a_2 y_n$.\n\n### 3. Implementation Strategy\n\nThe solution proceeds as follows:\n1.  **Initialization**: Define material constants, mesh geometry (nodes and element connectivity), and the prescribed displacement field coefficients.\n2.  **Displacement Calculation**: Evaluate the analytical displacement functions at each of the $9$ mesh nodes to obtain the nodal displacement vectors.\n3.  **Gauss Point Data Generation**: For each of the four elements:\n    *   Iterate through the four $2 \\times 2$ Gauss points $(\\xi, \\eta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$.\n    *   Compute the shape functions $N_i$ and their derivatives $\\partial N_i/\\partial\\xi, \\partial N_i/\\partial\\eta$.\n    *   Calculate the Jacobian $\\mathbf{J}$, its determinant $\\det(\\mathbf{J})$, and its inverse $\\mathbf{J}^{-1}$.\n    *   Form the strain-displacement matrix $\\mathbf{B}$ using $\\mathbf{J}^{-1}$.\n    *   Calculate the strain vector $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$.\n    *   Calculate the stress vector $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$.\n    *   For element $e_0$, apply the multiplicative noise: $\\sigma_{ij}^{\\text{noisy}} = \\sigma_{ij}(1 + \\alpha)$.\n    *   Store the physical coordinates $(x,y)$, the (potentially noisy) stress components, and the weight $w = \\det(\\mathbf{J})$ for each Gauss point.\n4.  **Patch Recovery for Test Cases**: For each specified node:\n    *   Identify the elements forming the patch around the node.\n    *   Aggregate the stored Gauss point data from all elements in the patch.\n    *   For each required stress component, assemble and solve the $3 \\times 3$ normal equations for the coefficients $\\mathbf{a}$.\n    *   Evaluate the recovered stress $s^{\\text{rec}}$ at the node's coordinates.\n5.  **Output**: Collect the computed stress values for all test cases and print them in the specified comma-separated format.\n\nSince the specified displacement field is bilinear and the mesh consists of rectangular elements, the isoparametric mapping is linear. This implies that the strains calculated by the FEM procedure will be a linear function of $(x,y)$ within each element. As the exact stress field is also linear, and the ZZ recovery fits a linear polynomial, the recovered stresses in the noise-free cases are expected to be highly accurate, matching the analytical solution up to floating-point precision. The noisy case allows observation of the method's behavior with perturbed data.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Zienkiewicz-Zhu (ZZ) patch recovery method for a 2x2\n    plane strain finite element mesh.\n    \"\"\"\n    # Define problem parameters\n    E = 210e9  # Young's modulus in Pascals\n    nu = 0.3   # Poisson's ratio\n    \n    # Coefficients for the prescribed displacement field\n    a, b, c = 1.0e-3, 2.0e-3, 3.0e-3\n    d, e, f = -1.0e-3, 1.5e-3, -2.0e-3\n    \n    # Noise factor for element e0\n    alpha_noise = 5.0e-3\n\n    # Define mesh geometry\n    nodes = np.array([\n        [0.0, 0.0], [1.0, 0.0], [2.0, 0.0],\n        [0.0, 1.0], [1.0, 1.0], [2.0, 1.0],\n        [0.0, 2.0], [1.0, 2.0], [2.0, 2.0]\n    ])\n    \n    elements = {\n        0: [0, 1, 4, 3],  # Element e0\n        1: [1, 2, 5, 4],  # Element e1\n        2: [3, 4, 7, 6],  # Element e2\n        3: [4, 5, 8, 7]   # Element e3\n    }\n    \n    # Define a function for the analytical displacement field\n    def get_displacements(x, y):\n        ux = a * x + b * y + c * x * y\n        uy = d * x + e * y + f * x * y\n        return np.array([ux, uy])\n\n    # Calculate displacements at each node\n    nodal_displacements = np.array([get_displacements(x, y) for x, y in nodes])\n\n    # Constitutive matrix D for plane strain\n    d_factor = E / ((1 + nu) * (1 - 2 * nu))\n    D = d_factor * np.array([\n        [1 - nu, nu, 0],\n        [nu, 1 - nu, 0],\n        [0, 0, (1 - 2 * nu) / 2]\n    ])\n\n    # Define 2x2 Gauss quadrature points in parent coordinates\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_points = [\n        (-gp_val, -gp_val), (gp_val, -gp_val),\n        (gp_val, gp_val), (-gp_val, gp_val)\n    ]\n    \n    # Helper functions for Q4 element shape functions and their derivatives\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        return N\n\n    def shape_derivatives(xi, eta):\n        # Derivatives with respect to parent coordinates (xi, eta)\n        dNd_xi_eta = 0.25 * np.array([\n            [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],  # dN/d_xi\n            [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]    # dN/d_eta\n        ])\n        return dNd_xi_eta\n\n    # Store computed Gauss point data (stresses, coordinates, weights) for all elements\n    gauss_data = {}\n\n    for elem_id, node_indices in elements.items():\n        gauss_data[elem_id] = []\n        elem_coords = nodes[node_indices]\n        elem_disps_vec = nodal_displacements[node_indices].flatten()\n\n        for xi, eta in gauss_points:\n            dNd_xi_eta = shape_derivatives(xi, eta)\n            \n            # Jacobian matrix\n            J = dNd_xi_eta @ elem_coords\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n\n            # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n            dNd_xy = invJ @ dNd_xi_eta\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, 8))\n            for i in range(4):\n                B[0, 2 * i] = dNd_xy[0, i]\n                B[1, 2 * i + 1] = dNd_xy[1, i]\n                B[2, 2 * i] = dNd_xy[1, i]\n                B[2, 2 * i + 1] = dNd_xy[0, i]\n            \n            # Compute strains and then stresses at the Gauss point\n            strains = B @ elem_disps_vec\n            stresses = D @ strains\n\n            # Apply deterministic noise for element e0 as specified\n            if elem_id == 0:\n                stresses_with_noise = stresses * (1.0 + alpha_noise)\n            else:\n                stresses_with_noise = stresses\n\n            # Map Gauss point to physical coordinates\n            N_vals = shape_functions(xi, eta)\n            physical_coords = N_vals @ elem_coords\n\n            gauss_data[elem_id].append({\n                'coords': physical_coords,\n                'stresses': stresses_with_noise,\n                'weight': detJ # Weight for least-squares is det(J)\n            })\n\n    def perform_zz_recovery(patch_data, target_node_coord, stress_index):\n        \"\"\"Performs weighted least-squares fit for one stress component.\"\"\"\n        # stress_index: 0 for sigma_xx, 1 for sigma_yy, 2 for tau_xy\n\n        # Assemble the normal equations for the least-squares system M*a = f\n        M = np.zeros((3, 3))\n        f = np.zeros(3)\n\n        for gp in patch_data:\n            x, y = gp['coords']\n            s_val = gp['stresses'][stress_index]\n            w = gp['weight']\n            p = np.array([1, x, y])\n            \n            M += w * np.outer(p, p)\n            f += w * s_val * p\n\n        # Solve for coefficients a = [a0, a1, a2]\n        a_coeffs = np.linalg.solve(M, f)\n        \n        # Evaluate recovered stress at the target node coordinates\n        p_node = np.array([1, target_node_coord[0], target_node_coord[1]])\n        recovered_stress = p_node @ a_coeffs\n        \n        return recovered_stress\n\n    final_results = []\n    \n    # Case 1: Interior patch at node (1,1)\n    node_coord_1 = (1.0, 1.0)\n    patch_elements_1 = [0, 1, 2, 3] # All four elements\n    patch_data_1 = []\n    for elem_id in patch_elements_1:\n        patch_data_1.extend(gauss_data[elem_id])\n    \n    s_xx_1 = perform_zz_recovery(patch_data_1, node_coord_1, 0)\n    s_yy_1 = perform_zz_recovery(patch_data_1, node_coord_1, 1)\n    t_xy_1 = perform_zz_recovery(patch_data_1, node_coord_1, 2)\n    final_results.extend([s_xx_1, s_yy_1, t_xy_1])\n\n    # Case 2: Edge patch at node (0,1)\n    node_coord_2 = (0.0, 1.0)\n    patch_elements_2 = [0, 2] # Elements e0 and e2\n    patch_data_2 = []\n    for elem_id in patch_elements_2:\n        patch_data_2.extend(gauss_data[elem_id])\n        \n    s_xx_2 = perform_zz_recovery(patch_data_2, node_coord_2, 0)\n    final_results.append(s_xx_2)\n    \n    # Case 3: Corner patch (with noise) at node (0,0)\n    node_coord_3 = (0.0, 0.0)\n    patch_elements_3 = [0] # Only element e0\n    patch_data_3 = []\n    for elem_id in patch_elements_3:\n        patch_data_3.extend(gauss_data[elem_id])\n\n    t_xy_3 = perform_zz_recovery(patch_data_3, node_coord_3, 2)\n    final_results.append(t_xy_3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}