{
    "hands_on_practices": [
        {
            "introduction": "为了将 Nitsche 方法的理论付诸实践，我们首先从最基本的层面入手：单个有限元的计算。这项练习将抽象的边界积分项分解为具体的数值计算步骤，要求您为一个二维三角形单元推导并计算 Nitsche 方法贡献的刚度矩阵项。通过亲手处理形函数、材料本构和几何信息，您将对该方法的实际实现机制建立起直观且扎实的理解。",
            "id": "3584364",
            "problem": "考虑二维空间中的小应变、线性、各向同性弹性力学。位移场表示为 $u:\\Omega\\rightarrow\\mathbb{R}^{2}$，线性化应变为 $\\varepsilon(u)=\\frac{1}{2}\\left(\\nabla u+\\nabla u^{\\top}\\right)$，Cauchy 应力为 $\\sigma(u)=2\\mu\\,\\varepsilon(u)+\\lambda\\,\\operatorname{tr}(\\varepsilon(u))\\,I$，其中 $I$ 是单位张量，$\\mu$ 和 $\\lambda$ 是 Lamé 参数，$\\operatorname{tr}(\\cdot)$ 表示迹。在 Dirichlet 边界 $\\Gamma_{D}$ 上，面力为 $\\sigma(u)n$，其中 $n$ 是单位外法线。Nitsche 方法通过在双线性形式中增加包含 $\\sigma(u)n$、$\\sigma(v)n$ 和带参数 $\\gamma$ 的罚项的边界积分，来弱施加 Dirichlet 边界条件。\n\n您将专注于有限元法 (FEM) 中使用的单个线性（1 次）三角形有限元。设该单元的顶点为 $x_{1}=(0,0)$、$x_{2}=(1,0)$ 和 $x_{3}=(0,1)$。$\\Gamma_{D}$ 上的边是从 $x_{1}$ 到 $x_{2}$ 的线段，通过 $x(s)=(s,0)$ 参数化，其中 $s\\in[0,1]$，单位外法线为 $n=(0,-1)^{\\top}$。假设材料为各向同性，杨氏模量为 $E$，泊松比为 $\\nu=0$，因此 $\\lambda=0$ 且 $\\mu=\\frac{E}{2}$，从而 $\\sigma(u)=E\\,\\varepsilon(u)$。罚参数按 $\\gamma=\\alpha\\,\\frac{E}{h_{e}}$ 进行缩放，其中 $h_{e}$ 是边界边的长度。取 $E=210\\times 10^{9}$，$\\alpha=10$，$h_{e}=1$。Dirichlet 数据值与所求的双线性形式项无关，不应使用。\n\n将与顶点相关联的标量形函数表示为 $\\varphi_{1}$、$\\varphi_{2}$ 和 $\\varphi_{3}$，并通过将每个标量形函数与笛卡尔单位矢量 $e_{x}$ 和 $e_{y}$ 相乘来构造矢量基函数。使用在 $[0,1]$ 上的两点高斯求积，其节点为 $s_{1}=\\frac{1}{2}-\\frac{1}{2\\sqrt{3}}$ 和 $s_{2}=\\frac{1}{2}+\\frac{1}{2\\sqrt{3}}$，权重均为 $w_{k}=\\frac{1}{2}$，完成以下任务：\n\n1. 从以上定义和选定的几何形状出发，推导用于组装三个 Nitsche 贡献项\n$$\n\\int_{\\Gamma_{D}}\\sigma(u_{h})\\,n\\cdot v_{h}\\,ds,\\quad\n\\int_{\\Gamma_{D}}\\sigma(v_{h})\\,n\\cdot u_{h}\\,ds,\\quad\n\\int_{\\Gamma_{D}}\\gamma\\,u_{h}\\cdot v_{h}\\,ds,\n$$\n的单元级求积表达式。其中，矢量值有限元试探函数 $u_{h}$ 和检验函数 $v_{h}$ 是由给定三角形上的线性标量形函数构建的。\n\n2. 使用推导出的表达式，计算对应于对称 Nitsche 组合 $-\\int_{\\Gamma_{D}}\\sigma(u_{h})\\,n\\cdot v_{h}\\,ds-\\int_{\\Gamma_{D}}\\sigma(v_{h})\\,n\\cdot u_{h}\\,ds+\\int_{\\Gamma_{D}}\\gamma\\,u_{h}\\cdot v_{h}\\,ds$ 的单个标量双线性形式项。其中，试探基函数为 $\\varphi_{1}\\,e_{x}$，检验基函数为 $\\varphi_{2}\\,e_{x}$。使用指定的求积法则和给定参数计算其数值。\n\n以 $\\mathrm{N}/\\mathrm{m}$ 为单位表示最终的标量项，并将您的答案四舍五入到四位有效数字。",
            "solution": "用户希望解决一个计算固体力学问题，该问题涉及使用 Nitsche 方法施加 Dirichlet 边界条件。任务包括两部分：首先，推导特定三角形单元上 Nitsche 边界项的一般求积表达式；其次，计算所得双线性形式的特定项。\n\n### 步骤 1：问题验证\n\n#### 提取已知条件\n-   **问题类型**：二维小应变、线性、各向同性弹性力学。\n-   **单元几何**：一个顶点为 $x_{1}=(0,0)$、$x_{2}=(1,0)$ 和 $x_{3}=(0,1)$ 的线性三角形单元。\n-   **边界条件**：在 $\\Gamma_{D}$（从 $x_{1}$ 到 $x_{2}$ 的边）上的 Dirichlet 边界条件。\n-   **边界参数化**：$\\Gamma_{D}$ 上的边被参数化为 $x(s)=(s,0)$，其中 $s\\in[0,1]$。\n-   **外法线**：$\\Gamma_D$ 上的单位外法线为 $n=(0,-1)^{\\top}$。\n-   **材料属性**：杨氏模量 $E = 210 \\times 10^{9}$，泊松比 $\\nu=0$。\n-   **本构关系**：由 $\\nu=0$ 可得 Lamé 参数 $\\lambda=0$ 和 $\\mu=\\frac{E}{2}$。Cauchy 应力张量由 $\\sigma(u)=E\\,\\varepsilon(u)$ 给出，其中应变为 $\\varepsilon(u)=\\frac{1}{2}\\left(\\nabla u+\\nabla u^{\\top}\\right)$。\n-   **罚参数**：$\\gamma=\\alpha\\,\\frac{E}{h_{e}}$，其中 $\\alpha=10$，边界边长 $h_{e}=1$。因此，$\\gamma = 10E$。\n-   **有限元基**：矢量基函数由标量线性形函数 $\\varphi_{i}$ 构造成 $\\varphi_{i}e_{x}$ 和 $\\varphi_{i}e_{y}$。\n-   **数值积分**：在 $[0,1]$ 上的两点高斯求积，节点为 $s_{1}=\\frac{1}{2}-\\frac{1}{2\\sqrt{3}}$、$s_{2}=\\frac{1}{2}+\\frac{1}{2\\sqrt{3}}$，权重为 $w_{1}=w_{2}=\\frac{1}{2}$。\n-   **任务 1**：推导三个 Nitsche 积分：\n    $\\int_{\\Gamma_{D}}\\sigma(u_{h})\\,n\\cdot v_{h}\\,ds$、$\\int_{\\Gamma_{D}}\\sigma(v_{h})\\,n\\cdot u_{h}\\,ds$ 和 $\\int_{\\Gamma_{D}}\\gamma\\,u_{h}\\cdot v_{h}\\,ds$ 的单元级求积表达式。\n-   **任务 2**：计算特定的双线性形式项 $B(u_h, v_h) = -\\int_{\\Gamma_{D}}\\sigma(u_{h})\\,n\\cdot v_{h}\\,ds-\\int_{\\Gamma_{D}}\\sigma(v_{h})\\,n\\cdot u_{h}\\,ds+\\int_{\\Gamma_{D}}\\gamma\\,u_{h}\\cdot v_{h}\\,ds$，其中试探函数为 $u_{h} = \\varphi_{1}\\,e_{x}$，检验函数为 $v_{h} = \\varphi_{2}\\,e_{x}$。\n-   **输出格式**：最终答案必须是一个以 $\\mathrm{N}/\\mathrm{m}$ 为单位的数值，并四舍五入到四位有效数字。\n\n#### 使用提取的已知条件进行验证\n-   **科学依据**：该问题在线性弹性力学和有限元法的既定理论框架内被正确地表述。Nitsche 方法是一种标准且有效的技术。材料参数（$E, \\nu, \\lambda, \\mu$）之间的关系是正确的。\n-   **适定性**：问题是完全指定的。它提供了所有必要的信息：单元几何、材料属性、基函数、边界定义和数值积分方案。目标是计算一个特定的数值，这是一项明确定义的任务。\n-   **客观性**：问题使用精确、明确的技术语言陈述，没有任何主观性。\n\n该问题不违反任何无效标准。它是计算力学中一个标准的、适定的问题。\n\n#### 结论与行动\n问题有效。将提供解决方案。\n\n### 步骤 2：求解\n\n#### 准备工作：形函数及其梯度\n对于顶点为 $x_1=(0,0)$、$x_2=(1,0)$、$x_3=(0,1)$ 的三角形，其标量线性形函数 $\\varphi_i(x,y)$ 由条件 $\\varphi_i(x_j) = \\delta_{ij}$ 导出。\n-   $\\varphi_{1}(x,y) = 1-x-y$\n-   $\\varphi_{2}(x,y) = x$\n-   $\\varphi_{3}(x,y) = y$\n\n这些形函数的梯度在单元上是常数：\n-   $\\nabla \\varphi_{1} = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$\n-   $\\nabla \\varphi_{2} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$\n-   $\\nabla \\varphi_{3} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$\n\n边界 $\\Gamma_D$ 对应于连接 $x_1$ 和 $x_2$ 的边，参数化为 $x(s) = (s,0)$，其中 $s \\in [0,1]$。在此边界上，形函数取值为：\n-   $\\varphi_{1}(s,0) = 1-s$\n-   $\\varphi_{2}(s,0) = s$\n-   $\\varphi_{3}(s,0) = 0$\n\n#### 第 1 部分：求积表达式的推导\n\n设试探函数 $u_h$ 和检验函数 $v_h$ 是有限元空间中的通用基函数。我们考虑 $u_h = \\varphi_k e_d$ 和 $v_h = \\varphi_l e_{d'}$，其中 $k, l \\in \\{1,2,3\\}$ 且 $d, d' \\in \\{x,y\\}$。\n\n对于 $u_h = \\varphi_k e_d$，应变张量为 $\\varepsilon(\\varphi_k e_d) = \\frac{1}{2}(\\nabla(\\varphi_k e_d) + \\nabla(\\varphi_k e_d)^\\top) = \\frac{1}{2}(e_d \\otimes \\nabla\\varphi_k + \\nabla\\varphi_k \\otimes e_d)$。\n应力为 $\\sigma(u_h) = E\\varepsilon(\\varphi_k e_d)$。\n在 $\\Gamma_D$ 上的面力矢量（法线为 $n = (0,-1)^\\top$）为 $\\sigma(u_h)n$。\n\n积分使用两点高斯求积法则进行近似：$\\int_{0}^{1} f(s) ds \\approx \\sum_{q=1}^{2} w_q f(s_q)$，其中 $w_{1,2}=1/2$。\n\n1.  **第一个 Nitsche 项**：$\\int_{\\Gamma_{D}}\\sigma(u_{h})\\,n\\cdot v_{h}\\,ds$\n    对于 $u_h=\\varphi_k e_d$ 和 $v_h=\\varphi_l e_{d'}$，被积函数为 $(\\sigma(\\varphi_k e_d)n) \\cdot (\\varphi_l(s,0) e_{d'})$。注意 $\\sigma(\\varphi_k e_d)$ 是常数。\n    求积表达式为：\n    $$ \\int_{\\Gamma_{D}}\\sigma(\\varphi_k e_d)\\,n\\cdot (\\varphi_l e_{d'})\\,ds \\approx \\sum_{q=1}^{2} w_q \\left[ (E \\varepsilon(\\varphi_k e_d) n) \\cdot (\\varphi_l(s_q,0) e_{d'}) \\right] $$\n\n2.  **第二个 Nitsche 项（对称项）**：$\\int_{\\Gamma_{D}}\\sigma(v_{h})\\,n\\cdot u_{h}\\,ds$\n    这是通过交换试探函数和检验函数的角色得到的。\n    求积表达式为：\n    $$ \\int_{\\Gamma_{D}}\\sigma(\\varphi_l e_{d'})\\,n\\cdot (\\varphi_k e_d)\\,ds \\approx \\sum_{q=1}^{2} w_q \\left[ (E \\varepsilon(\\varphi_l e_{d'}) n) \\cdot (\\varphi_k(s_q,0) e_d) \\right] $$\n\n3.  **第三个 Nitsche 项（罚项）**：$\\int_{\\Gamma_{D}}\\gamma\\,u_{h}\\cdot v_{h}\\,ds$\n    被积函数为 $\\gamma (\\varphi_k(s,0)e_d) \\cdot (\\varphi_l(s,0)e_{d'}) = \\gamma \\varphi_k(s,0) \\varphi_l(s,0) \\delta_{dd'}$。\n    求积表达式为：\n    $$ \\int_{\\Gamma_{D}}\\gamma (\\varphi_k e_d)\\cdot (\\varphi_l e_{d'})\\,ds \\approx \\gamma \\delta_{dd'} \\sum_{q=1}^{2} w_q \\varphi_k(s_q,0) \\varphi_l(s_q,0) $$\n\n这三个表达式构成了所要求的一般单元级求积形式。\n\n#### 第 2 部分：特定双线性形式项的计算\n\n我们现在计算 $B(u_h, v_h) = -I_1 - I_2 + I_3$，其中 $I_1 = \\int_{\\Gamma_D} \\sigma(u_h)n \\cdot v_h ds$，$I_2 = \\int_{\\Gamma_D} \\sigma(v_h)n \\cdot u_h ds$，$I_3 = \\int_{\\Gamma_D} \\gamma u_h \\cdot v_h ds$。\n具体的基函数是：\n-   试探函数：$u_h = \\varphi_1 e_x = (1-x-y)e_x$\n-   检验函数：$v_h = \\varphi_2 e_x = x e_x$\n\n**计算面力：**\n\n对于 $u_h = \\varphi_1 e_x$：\n$\\nabla u_h = \\begin{pmatrix} \\partial_x u_x  \\partial_y u_x \\\\ \\partial_x u_y  \\partial_y u_y \\end{pmatrix} = \\begin{pmatrix} \\partial_x \\varphi_1  \\partial_y \\varphi_1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} -1  -1 \\\\ 0  0 \\end{pmatrix}$。\n$\\varepsilon(u_h) = \\frac{1}{2}(\\nabla u_h + \\nabla u_h^\\top) = \\frac{1}{2}\\left( \\begin{pmatrix} -1  -1 \\\\ 0  0 \\end{pmatrix} + \\begin{pmatrix} -1  0 \\\\ -1  0 \\end{pmatrix} \\right) = \\begin{pmatrix} -1  -1/2 \\\\ -1/2  0 \\end{pmatrix}$。\n$\\sigma(u_h) = E\\varepsilon(u_h)$。\n面力为 $\\sigma(u_h)n = E \\begin{pmatrix} -1  -1/2 \\\\ -1/2  0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = E \\begin{pmatrix} 1/2 \\\\ 0 \\end{pmatrix}$。\n\n对于 $v_h = \\varphi_2 e_x$：\n$\\nabla v_h = \\begin{pmatrix} \\partial_x \\varphi_2  \\partial_y \\varphi_2 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}$。\n$\\varepsilon(v_h) = \\frac{1}{2}(\\nabla v_h + \\nabla v_h^\\top) = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}$。\n$\\sigma(v_h) = E\\varepsilon(v_h)$。\n面力为 $\\sigma(v_h)n = E \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n\n**计算积分：**\n\n积分范围是 $s \\in [0,1]$。在此边界上，$u_h(s) = (1-s)e_x$ 且 $v_h(s) = s e_x$。两点求积法对于最高 $2(2)-1=3$ 次的多项式是精确的。我们所有的被积函数次数都不超过 2，因此求积是精确的。我们可以解析地计算积分。\n\n1.  **积分 $I_1$**: $\\int_0^1 (\\sigma(u_h)n) \\cdot v_h(s) ds$\n    被积函数为 $(E \\begin{pmatrix} 1/2 \\\\ 0 \\end{pmatrix}) \\cdot (s e_x) = (E/2) s$。\n    $$I_1 = \\int_0^1 \\frac{E}{2}s \\, ds = \\frac{E}{2} \\left[\\frac{s^2}{2}\\right]_0^1 = \\frac{E}{4}$$\n\n2.  **积分 $I_2$**: $\\int_0^1 (\\sigma(v_h)n) \\cdot u_h(s) ds$\n    面力 $\\sigma(v_h)n$ 是零矢量。\n    $$I_2 = \\int_0^1 0 \\cdot ((1-s)e_x) \\, ds = 0$$\n\n3.  **积分 $I_3$**: $\\int_0^1 \\gamma u_h(s) \\cdot v_h(s) ds$\n    当 $\\gamma = 10E$ 时，被积函数为 $\\gamma ((1-s)e_x) \\cdot (s e_x) = \\gamma s(1-s)$。\n    $$I_3 = \\gamma \\int_0^1 (s-s^2) \\, ds = \\gamma \\left[\\frac{s^2}{2} - \\frac{s^3}{3}\\right]_0^1 = \\gamma \\left(\\frac{1}{2} - \\frac{1}{3}\\right) = \\frac{\\gamma}{6} = \\frac{10E}{6} = \\frac{5E}{3}$$\n\n**合并各项：**\n对双线性形式的总贡献为：\n$$ B(\\varphi_1 e_x, \\varphi_2 e_x) = -I_1 - I_2 + I_3 = -\\frac{E}{4} - 0 + \\frac{5E}{3} = E\\left(-\\frac{3}{12} + \\frac{20}{12}\\right) = \\frac{17E}{12} $$\n\n**最终数值：**\n代入 $E = 210 \\times 10^{9} \\, \\mathrm{N}/\\mathrm{m}^2$。假设是单位厚度的平面问题，则刚度矩阵项的单位为 N/m。\n$$ \\text{值} = \\frac{17}{12} \\times (210 \\times 10^9) = \\frac{3570}{12} \\times 10^9 = 297.5 \\times 10^9 $$\n使用标准科学记数法并四舍五入到四位有效数字（该值已经是），其值为 $2.975 \\times 10^{11} \\, \\mathrm{N}/\\mathrm{m}$。",
            "answer": "$$\\boxed{2.975 \\times 10^{11}}$$"
        },
        {
            "introduction": "在掌握了基本实现后，我们转向一个更精细但至关重要的问题：当离散网格无法完美匹配真实几何边界时，如何保持计算精度。这项理论练习探讨了由于几何误差（即离散法向与精确法向不一致）导致的精度损失问题，并引导您推导一种修正方案来恢复方法的伴随一致性 (adjoint consistency)。这有助于深刻理解 Nitsche 方法的收敛性质，并掌握设计稳健数值格式的技巧。",
            "id": "3584380",
            "problem": "考虑一个二维小应变线性弹性体，其占据一个有界 Lipschitz 域 $\\Omega \\subset \\mathbb{R}^{2}$，边界 $\\partial \\Omega$ 上的外单位法向量为 $\\mathbf{n}$。设边界分解为一个 Dirichlet 部分 $\\Gamma_{D}$ 和一个 Neumann 部分 $\\Gamma_{N}$，且满足 $\\Gamma_{D} \\cup \\Gamma_{N} = \\partial \\Omega$ 和 $\\Gamma_{D} \\cap \\Gamma_{N} = \\emptyset$。材料是各向同性的，其拉梅参数为 $\\lambda$ 和 $\\mu$，柯西应力为 $\\boldsymbol{\\sigma}(\\mathbf{u}) = 2 \\mu \\boldsymbol{\\varepsilon}(\\mathbf{u}) + \\lambda \\, \\mathrm{tr}(\\boldsymbol{\\varepsilon}(\\mathbf{u})) \\mathbf{I}$，其中 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{T})$ 是无穷小应变张量。平衡的强形式为 $-\\nabla \\cdot \\boldsymbol{\\sigma}(\\mathbf{u}) = \\mathbf{f}$ 在 $\\Omega$ 中，且边界条件为 $\\mathbf{u} = \\mathbf{g}$ 在 $\\Gamma_{D}$ 上以及 $\\boldsymbol{\\sigma}(\\mathbf{u}) \\mathbf{n} = \\mathbf{t}$ 在 $\\Gamma_{N}$ 上。\n\n使用一个协调有限元空间来表示位移场 $\\mathbf{u}_{h}$，并采用对称 Nitsche 方法在 $\\Gamma_{D}$ 上弱施加条件 $\\mathbf{u} = \\mathbf{g}$。在 $\\Gamma_{D}$ 上的对称 Nitsche 双线性形式包含一致性项\n$$\n-\\int_{\\Gamma_{D}} (\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\mathbf{n}) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma\n\\;-\\;\n\\int_{\\Gamma_{D}} (\\boldsymbol{\\sigma}(\\mathbf{v}_{h}) \\mathbf{n}) \\cdot \\mathbf{u}_{h} \\, \\mathrm{d}\\Gamma,\n$$\n和一个罚项 $\\int_{\\Gamma_{D}} \\frac{\\gamma}{h} \\mathbf{u}_{h} \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma$，其中 $\\gamma  0$ 且 $h$ 为局部网格尺寸。\n\n假设精确几何由一个离散边界表示，其在 $\\Gamma_{D}$ 上的外单位法向量为 $\\mathbf{n}_{h}$，它沿某边界段与精确法向量 $\\mathbf{n}$ 偏离一个恒定角度 $\\theta$，即 $\\mathbf{n} \\cdot \\mathbf{n}_{h} = \\cos \\theta$ 且 $|\\theta| \\ll 1$。众所周知，在 Nitsche 一致性项中用 $\\mathbf{n}_{h}$ 替换 $\\mathbf{n}$ 会破坏伴随一致性，并可能降低收敛率。\n\n提出一种边界修正方法，该方法线性作用于离散法向量，以恢复 Nitsche 一致性项的伴随一致性，同时保持其对称结构。具体而言，考虑一个修正后的一致性项，它使用一个作用于 $\\mathbf{n}_{h}$ 的算子，该算子由到精确法向方向的投影 $P_{\\mathbf{n}} := \\mathbf{n} \\mathbf{n}^{T}$ 和一个标量因子 $\\alpha(\\theta)$ 构成：\n$$\n-\\int_{\\Gamma_{D}} \\big(\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\, \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}\\big) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma\n\\;-\\;\n\\int_{\\Gamma_{D}} \\big(\\boldsymbol{\\sigma}(\\mathbf{v}_{h}) \\, \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}\\big) \\cdot \\mathbf{u}_{h} \\, \\mathrm{d}\\Gamma.\n$$\n\n从分部积分得到的基本弱形式和上述定义出发，推导这些修正项满足伴随一致性的要求，并确定标量修正因子 $\\alpha(\\theta)$ 的闭式表达式，使得修正后的一致性项与使用精确法向量 $\\mathbf{n}$ 构建的项完全相等。分析此修正如何影响 Nitsche 一致性项，并根据算子 $P_{\\mathbf{n}}$ 和角度 $\\theta$ 解释为何最优收敛率得以恢复。\n\n你的最终答案应为 $\\alpha(\\theta)$ 的单一解析表达式，不带单位。如果你使用了近似，最终答案必须给出精确的闭式表达式。不需要进行数值取整。",
            "solution": "该问题要求推导对称 Nitsche 公式中一致性项的标量修正因子 $\\alpha(\\theta)$。此修正旨在补偿因使用离散边界法向量 $\\mathbf{n}_h$ 代替精确法向量 $\\mathbf{n}$ 而引入的几何误差，其中两个法向量由一个恒定角度 $\\theta$ 相关联，使得 $\\mathbf{n} \\cdot \\mathbf{n}_h = \\cos \\theta$。其目标是恢复一致性项的精确形式，这是确保有限元方法的伴随一致性和最优收敛率的先决条件。\n\n使用对称 Nitsche 方法对 $\\Gamma_D$ 上的 Dirichlet 边界条件 $\\mathbf{u} = \\mathbf{g}$ 进行标准弱施加，涉及到来自 $\\Gamma_D$ 的双线性形式贡献：\n$$\nb_{\\Gamma_D}(\\mathbf{u}_h, \\mathbf{v}_h) = -\\int_{\\Gamma_{D}} (\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\mathbf{n}) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma - \\int_{\\Gamma_{D}} (\\boldsymbol{\\sigma}(\\mathbf{v}_{h}) \\mathbf{n}) \\cdot \\mathbf{u}_{h} \\, \\mathrm{d}\\Gamma + \\int_{\\Gamma_{D}} \\frac{\\gamma}{h} \\mathbf{u}_{h} \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma.\n$$\n前两项是一致性项，第三项是罚项。\n\n当精确域被离散域近似，且 $\\Gamma_D$ 上的外单位法向量为 $\\mathbf{n}_h$ 而不是 $\\mathbf{n}$ 时，问题就出现了。在一致性项中直接使用 $\\mathbf{n}_h$ 会导致一致性的丧失。提出的修正将一致性项修改如下：\n$$\nb_{\\Gamma_D}^{\\text{corr}}(\\mathbf{u}_h, \\mathbf{v}_h) = -\\int_{\\Gamma_{D}} \\big(\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\, \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}\\big) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma - \\int_{\\Gamma_{D}} \\big(\\boldsymbol{\\sigma}(\\mathbf{v}_{h}) \\, \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}\\big) \\cdot \\mathbf{u}_{h} \\, \\mathrm{d}\\Gamma.\n$$\n罚项不受影响。恢复理想公式的条件是，对于有限元空间中任何容许的离散场对 $\\mathbf{u}_h$ 和 $\\mathbf{v}_h$，这些修正后的一致性项必须与原始项完全相同。\n\n由于这些项的对称结构，我们只需对其中一项强制施加相等条件。我们要求对于任何 $\\mathbf{u}_h$ 和 $\\mathbf{v}_h$：\n$$\n\\int_{\\Gamma_{D}} (\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\mathbf{n}) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma = \\int_{\\Gamma_{D}} \\big(\\boldsymbol{\\sigma}(\\mathbf{u}_{h}) \\, \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}\\big) \\cdot \\mathbf{v}_{h} \\, \\mathrm{d}\\Gamma.\n$$\n由于此等式必须对有限元空间中测试函数 $\\mathbf{v}_h$ 的任何选择都成立，因此积分内的向量项必须在 $\\Gamma_D$ 上几乎处处相等。这给出了以下条件：\n$$\n\\boldsymbol{\\sigma}(\\mathbf{u}_h) \\mathbf{n} = \\boldsymbol{\\sigma}(\\mathbf{u}_h) \\big( \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h} \\big).\n$$\n此处，$\\boldsymbol{\\sigma}(\\mathbf{u}_h)$ 是柯西应力张量，一个作用于向量的对称二阶张量。由运动学容许位移场产生的可能应力张量空间足够丰富（它张成了对称 $2 \\times 2$ 矩阵的空间）。因此，为了使等式 $\\boldsymbol{\\sigma} \\mathbf{a} = \\boldsymbol{\\sigma} \\mathbf{b}$ 对所有容许的 $\\boldsymbol{\\sigma}$ 都成立，向量必须相等，即 $\\mathbf{a} = \\mathbf{b}$。将此原理应用于我们的方程，得到对修正后法向量的核心要求：\n$$\n\\mathbf{n} = \\alpha(\\theta) \\, P_{\\mathbf{n}} \\mathbf{n}_{h}.\n$$\n这个方程直接将精确法向量 $\\mathbf{n}$ 与修正后的离散法向量联系起来。现在我们可以求解标量因子 $\\alpha(\\theta)$。\n\n问题将投影算子 $P_{\\mathbf{n}}$ 定义为 $P_{\\mathbf{n}} := \\mathbf{n} \\mathbf{n}^{T}$。它对离散法向量 $\\mathbf{n}_h$ 的作用是：\n$$\nP_{\\mathbf{n}} \\mathbf{n}_{h} = (\\mathbf{n} \\mathbf{n}^{T}) \\mathbf{n}_{h} = \\mathbf{n} (\\mathbf{n}^{T} \\mathbf{n}_{h}) = \\mathbf{n} (\\mathbf{n} \\cdot \\mathbf{n}_{h}).\n$$\n给定精确法向量与离散法向量之间的夹角为 $\\theta$，所以 $\\mathbf{n} \\cdot \\mathbf{n}_h = \\cos \\theta$。将此代入 $P_{\\mathbf{n}} \\mathbf{n}_{h}$ 的表达式中，得到：\n$$\nP_{\\mathbf{n}} \\mathbf{n}_{h} = \\mathbf{n} \\cos \\theta.\n$$\n现在，我们将这个结果代回我们的核心要求方程：\n$$\n\\mathbf{n} = \\alpha(\\theta) \\, (\\mathbf{n} \\cos \\theta).\n$$\n这可以重写为：\n$$\n\\mathbf{n} = (\\alpha(\\theta) \\cos \\theta) \\mathbf{n}.\n$$\n由于 $\\mathbf{n}$ 是一个单位向量，它非零，因此我们可以令方程两边的标量系数相等：\n$$\n1 = \\alpha(\\theta) \\cos \\theta.\n$$\n求解 $\\alpha(\\theta)$ 得到所需的闭式表达式：\n$$\n\\alpha(\\theta) = \\frac{1}{\\cos \\theta}.\n$$\n这就是使修正后的一致性项与理想项完全相等的修正因子的表达式。\n\n为了理解为什么这能恢复最优收敛率，我们必须分析修正的效果。使用不正确的法向量 $\\mathbf{n}_h$ 代替 $\\mathbf{n}$ 会引入一致性误差。Nitsche 公式的一致性依赖于边界牵引力项 $\\int_{\\Gamma_D} (\\boldsymbol{\\sigma}(\\mathbf{u})\\mathbf{n}) \\cdot \\mathbf{v}_h \\, \\mathrm{d}\\Gamma$ 的精确抵消，该项由体项分部积分产生，并与 Nitsche 公式中的相应项抵消。如果使用 $\\mathbf{n}_h$，会残留一个余项 $\\int_{\\Gamma_D} (\\boldsymbol{\\sigma}(\\mathbf{u}) (\\mathbf{n} - \\mathbf{n}_h)) \\cdot \\mathbf{v}_h \\, \\mathrm{d}\\Gamma$。这种“变分犯罪”(variational crime)污染了公式，并导致收敛阶的降低。伴随一致性（对于解的泛函的最优收敛至关重要）也丧失了，因为该方法对于原始问题不再是一致的。\n\n提出的修正分两步操作：\n1. 投影 $P_{\\mathbf{n}}$ 作用于 $\\mathbf{n}_h$ 产生 $P_{\\mathbf{n}} \\mathbf{n}_h = (\\cos\\theta)\\mathbf{n}$。这个操作在几何上分离出离散法向量 $\\mathbf{n}_h$ 在真实法向量 $\\mathbf{n}$ 方向上的分量，并消除了与真实边界相切的错误分量。\n2. 得到的向量 $(\\cos\\theta)\\mathbf{n}$ 方向正确，但大小不正确，为 $\\cos\\theta$（因为 $|\\theta| \\ll 1$，所以 $\\cos\\theta  1$）。标量因子 $\\alpha(\\theta) = 1/\\cos\\theta$ 对该向量进行重新缩放，将其大小恢复为 1。\n\n因此，组合操作 $\\alpha(\\theta) P_{\\mathbf{n}} \\mathbf{n}_h$ 精确地重构了真实的法向量 $\\mathbf{n}$。通过将这个修正后的向量代入 Nitsche 一致性项，我们使其在数学上与使用 $\\mathbf{n}$ 的理想项完全相同。这完全消除了由法向量的几何近似引起的一致性误差。通过恢复对称公式的一致性，伴随一致性也得以恢复，并且标准误差估计保证了最优收敛率的实现，就如同使用了精确几何一样。",
            "answer": "$$\n\\boxed{\\frac{1}{\\cos(\\theta)}}\n$$"
        },
        {
            "introduction": "最后一个实践项目将挑战 Nitsche 方法在实际应用中最棘手的难题之一：稳定参数 $\\gamma$ 的选择。这项编程练习将指导您实现一种先进的“无参数” (parameter-free) 策略，其中稳定参数是通过求解一个局部问题自适应地确定。这项任务不仅连接了理论与实践，更是通向开发稳健、自动化、高效的有限元仿真工具的关键一步。",
            "id": "3584398",
            "problem": "考虑一个有界域中的线性弹性平面应变问题，其材料由拉梅参数 $ \\lambda $ 和 $ \\mu $ 描述，这两个参数通过杨氏模量 $ E $ 和泊松比 $ \\nu $ 关联，关系式为 $ \\mu = \\dfrac{E}{2(1+\\nu)} $ 和 $ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)} $。在没有体力的情况下，平衡方程的强形式为 $ \\nabla \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}) = \\boldsymbol{0} $（在 $ \\Omega $ 内），边界 $ \\Gamma $ 上施加狄利克雷边界条件 $ \\boldsymbol{u} = \\boldsymbol{g} $。平面应变的柯西应力为 $ \\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) $，其中 $ \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\dfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\top}) $，弹性张量 $ \\mathbb{C} $ 在 Voigt 记法中具有标准的 $ 3 \\times 3 $ 平面应变表示，其分量为 $ [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^{\\top} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix} \\begin{bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} $，工程剪应变为 $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x$。\n\n我们使用 Nitsche 方法的对称形式来弱施加 $ \\boldsymbol{u} = \\boldsymbol{g} $。对于有限元空间中的测试函数和试探函数 $ \\boldsymbol{v}, \\boldsymbol{u} $，双线性形式为\n$$\na(\\boldsymbol{u}, \\boldsymbol{v}) = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}x - \\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u})) \\cdot \\boldsymbol{v} \\, \\mathrm{d}s - \\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{v})) \\cdot \\boldsymbol{u} \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma \\, \\boldsymbol{u} \\cdot \\boldsymbol{v} \\, \\mathrm{d}s ,\n$$\n线性形式为\n$$\n\\ell(\\boldsymbol{v}) = -\\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}_{\\mathrm{ex}})) \\cdot \\boldsymbol{v} \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma \\, \\boldsymbol{u}_{\\mathrm{ex}} \\cdot \\boldsymbol{v} \\, \\mathrm{d}s ,\n$$\n其中 $ \\boldsymbol{u}_{\\mathrm{ex}} $ 是要在 $ \\Gamma $ 上施加的已知精确位移， $ \\boldsymbol{n} $ 是指向 $ \\Gamma $ 外部的单位法向量。稳定化参数 $ \\gamma $ 的取值必须足够大，以确保 $ a(\\cdot,\\cdot) $ 的矫顽性。\n\n一种无参数策略是使用局部多项式重构和逐单元面的刚度代理来逐个单元面计算 $ \\gamma $。在一个单元 $ e $ 的边界单元面 $ f $ 上，考虑多项式向量场 $ \\mathcal{P}_1^2 $ 的局部子空间，该子空间具有非零应变（不包括刚体运动的仿射向量场）。定义逐单元面的常数\n$$\nc_f^2 = \\sup_{\\boldsymbol{w} \\in \\mathcal{P}_1^2,\\, \\boldsymbol{w}\\neq \\boldsymbol{0}} \\frac{\\left( \\int_f (\\boldsymbol{n}\\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w})) \\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right)^2}{\\left( \\int_e \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) \\, \\mathrm{d}x \\right) \\left( \\int_f \\boldsymbol{w}\\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right)} .\n$$\n那么，在单元面 $ f $ 上的一个充分稳定化条件是 $ \\gamma_f \\ge c_f^2 $。这个选择在量纲上是一致的，并且仅依赖于局部几何和材料属性。\n\n您的任务是：\n1. 从线性弹性的弱形式和对称 Nitsche 公式出发，基于柯西-施瓦茨不等式和迹不等式，对限制在一次多项式上的 $ \\boldsymbol{n}\\cdot\\boldsymbol{\\sigma}(\\cdot) $ 和 $ \\boldsymbol{u}|_f $ 推导出局部逐单元面的稳定化界 $ \\gamma_f \\ge c_f^2 $。清晰地论证用于定义 $ c_f $ 的上确界瑞利商结构。\n2. 在 $ \\Omega = [0,1]^2 $ 上实现一个使用双线性四边形单元的二维有限元法 (FEM) 求解器，该求解器：\n   - 组装内部刚度 $ \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}x $。\n   - 在每个边界单元面上组装 Nitsche 边界项，其中 $ \\gamma_f $ 通过在相邻单元上进行局部多项式重构计算为 $ c_f^2 $，并使用足以精确积分仿射场的求积法则。\n   - 通过 Nitsche 线性形式 $ \\ell(\\cdot) $ 在 $ \\Gamma $ 上施加 $ \\boldsymbol{g} = \\boldsymbol{u}_{\\mathrm{ex}} $，且体力为零。\n3. 通过使用具有恒定应变的精确仿射位移场 $ \\boldsymbol{u}_{\\mathrm{ex}} $ 进行斑块检验，来验证无参数稳定化方法。对于每种情况，计算 FEM 解在 $ \\Gamma $ 上的相对 $ L^2 $ 误差，\n$$\n\\mathrm{err}_\\Gamma = \\frac{\\left( \\int_{\\Gamma} \\lVert \\boldsymbol{u}_h - \\boldsymbol{u}_{\\mathrm{ex}} \\rVert^2 \\, \\mathrm{d}s \\right)^{1/2}}{\\left( \\int_{\\Gamma} \\lVert \\boldsymbol{u}_{\\mathrm{ex}} \\rVert^2 \\, \\mathrm{d}s \\right)^{1/2}} .\n$$\n报告一个布尔值，指示 $ \\mathrm{err}_\\Gamma  \\tau $ 是否成立，其中 $ \\tau $ 是指定的容差。\n\n使用以下测试套件来检验该方法的不同方面，包括一般情况和一个极端情况：\n- 情况 A (正常路径): $ E = 1.0\\times 10^7 $ 帕斯卡, $ \\nu = 0.30 $, 网格 $ N_x = 2 $, $ N_y = 2 $, 且 $ \\boldsymbol{u}_{\\mathrm{ex}}(x,y) = [x,\\, 0]^{\\top} $。\n- 情况 B (方向改变): $ E = 1.0\\times 10^7 $ 帕斯卡, $ \\nu = 0.30 $, 网格 $ N_x = 3 $, $ N_y = 2 $, 且 $ \\boldsymbol{u}_{\\mathrm{ex}}(x,y) = [0,\\, y]^{\\top} $。\n- 情况 C (极端情况, 近乎不可压缩): $ E = 1.0\\times 10^7 $ 帕斯卡, $ \\nu = 0.4999 $, 网格 $ N_x = 2 $, $ N_y = 2 $, 且 $ \\boldsymbol{u}_{\\mathrm{ex}}(x,y) = [y,\\, x]^{\\top} $。\n\n所有长度单位为米，应力单位为帕斯卡；但是，最终报告的值是布尔值，因此输出无需进行单位转换。\n\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，\"[true,false,true]\"），按顺序对应于情况 A、B 和 C 的结果。使用容差 $ \\tau = 1.0\\times 10^{-9} $ 进行通过/失败的判断。",
            "solution": "我们从平面应变线性弹性的标准弱形式开始。在零体力和边界 $ \\Gamma $ 上有狄利克雷边界条件 $ \\boldsymbol{u} = \\boldsymbol{g} $ 的情况下，强形式为 $ \\nabla \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}) = \\boldsymbol{0} $，其中 $ \\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) $。使用测试函数 $ \\boldsymbol{v} $ 的弱形式是\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}x - \\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u})) \\cdot \\boldsymbol{v} \\, \\mathrm{d}s = 0 .\n$$\nNitsche 方法通过增加对称一致性项和稳定化罚项来弱施加狄利克雷条件：\n$$\na(\\boldsymbol{u}, \\boldsymbol{v}) = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}) \\, \\mathrm{d}x - \\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u})) \\cdot \\boldsymbol{v} \\, \\mathrm{d}s - \\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{v})) \\cdot \\boldsymbol{u} \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma \\, \\boldsymbol{u} \\cdot \\boldsymbol{v} \\, \\mathrm{d}s ,\n$$\n$$\n\\ell(\\boldsymbol{v}) = -\\int_{\\Gamma} (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}_{\\mathrm{ex}})) \\cdot \\boldsymbol{v} \\, \\mathrm{d}s + \\int_{\\Gamma} \\gamma \\, \\boldsymbol{u}_{\\mathrm{ex}} \\cdot \\boldsymbol{v} \\, \\mathrm{d}s .\n$$\n为确保 $ a(\\cdot,\\cdot) $ 的矫顽性，我们需要用罚项来控制非正的一致性项。在一个单元 $ e $ 的边界单元面 $ f $ 上，对于任何可接受的场 $ \\boldsymbol{w} $，一致性项满足\n$$\n\\left| \\int_f (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w})) \\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right| \\le \\lVert \\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w}) \\rVert_{L^2(f)} \\, \\lVert \\boldsymbol{w} \\rVert_{L^2(f)} .\n$$\n一个局部迹不等式得出 $ \\lVert \\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w}) \\rVert_{L^2(f)} \\le c_f \\, \\left( \\int_e \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) \\, \\mathrm{d}x \\right)^{1/2} $。将这些与杨氏不等式结合，\n$$\n2 \\left| \\int_f (\\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w})) \\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right| \\le \\frac{1}{\\eta} \\int_e \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) \\, \\mathrm{d}x + \\eta c_f^2 \\int_f \\boldsymbol{w} \\cdot \\boldsymbol{w} \\, \\mathrm{d}s .\n$$\n选择单元面 $ f $ 上的稳定化参数为 $ \\gamma_f \\ge c_f^2 $ 并设 $ \\eta = 1 $，可确保单元面一致性项被内部能量和罚项之和所吸收，从而得到 Nitsche 双线性形式的矫顽性。\n\n为了创建一个可计算的、无参数的 $ \\gamma_f $，我们将其限制在单元 $ e $ 上的一个局部多项式子空间 $ \\mathcal{P}_1^2 $ 中，该子空间排除了刚体运动（纯平移和旋转），并通过上确界瑞利商定义逐单元面的常数\n$$\nc_f^2 = \\sup_{\\boldsymbol{w} \\in \\mathcal{P}_1^2, \\, \\boldsymbol{w} \\neq \\boldsymbol{0}} \\frac{\\left( \\int_f (\\boldsymbol{n}\\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w})) \\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right)^2}{\\left( \\int_e \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) \\, \\mathrm{d}x \\right) \\left( \\int_f \\boldsymbol{w}\\cdot \\boldsymbol{w} \\, \\mathrm{d}s \\right)} .\n$$\n这个量是限制在 $ \\mathcal{P}_1^2 $ 上的局部诺伊曼-狄利克雷映射的算子范数的平方，并由内部能量进行缩放。通过在一组具有非零应变的仿射向量场的有限基上最大化来计算 $ c_f^2 $，提供了一种有效的无参数稳定化方法，该方法考虑了局部单元面几何和材料刚度。\n\n算法设计：\n- 我们使用每个有四个节点的双线性四边形单元对 $ \\Omega = [0,1]^2 $ 进行离散化。有限元近似使用 $ \\boldsymbol{u}_h = \\sum_i \\boldsymbol{d}_i N_i $，每个节点具有向量自由度 $ \\boldsymbol{d}_i $。\n- 内部刚度组装采用 $ 2 \\times 2 $ 高斯求积，求积点为 $ \\xi, \\eta = \\pm 1/\\sqrt{3} $，在每个求积点计算应变-位移矩阵 $ \\mathbf{B} $，并使用等参映射的雅可比行列式 $ \\mathbf{J} $ 组装 $ \\int \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}x $。\n- 对于每个边界单元面，我们使用局部多项式重构计算 $ \\gamma_f $。我们选择仿射模式，如 $ \\boldsymbol{w}(x,y) \\in \\{ [x,0]^{\\top}, [0,y]^{\\top}, [0,x]^{\\top}, [y,0]^{\\top}, [x,y]^{\\top}, [y,x]^{\\top} \\} $，每个模式都具有恒定的应变 $ \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) $。对于每个模式，我们计算：\n  - 内部能量 $ \\int_e \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\boldsymbol{w}) \\, \\mathrm{d}x $，可以从单元面积和恒定的应变能密度精确计算。\n  - 边界功 $ \\int_f (\\boldsymbol{n}\\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w})) \\cdot \\boldsymbol{w} \\, \\mathrm{d}s $，使用沿单元面的 $ 2 $ 点高斯求积。对于仿射模式，面力 $ \\boldsymbol{t} = \\boldsymbol{n} \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{w}) $ 是恒定的；位移沿单元面线性变化。\n  - 边界范数 $ \\int_f \\boldsymbol{w}\\cdot \\boldsymbol{w} \\, \\mathrm{d}s $，使用相同的求积方法。\n  取所选集合上的最大瑞利商得到 $ c_f^2 $，我们设 $ \\gamma_f = c_f^2 $（带有一个小的正数值保护）。\n- 边界 Nitsche 项的组装在每个边界单元面上使用 $ 2 $ 点高斯求积。在每个单元面求积点，对刚度矩阵的贡献为\n  $ -\\int_f \\boldsymbol{v}^{\\top} (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u})) \\, \\mathrm{d}s $， $ -\\int_f \\boldsymbol{u}^{\\top} (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{v})) \\, \\mathrm{d}s $ 和 $ \\int_f \\gamma_f \\boldsymbol{u}\\cdot\\boldsymbol{v} \\, \\mathrm{d}s $，对载荷向量的贡献为\n  $ -\\int_f \\boldsymbol{v}^{\\top} (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma}(\\boldsymbol{u}_{\\mathrm{ex}})) \\, \\mathrm{d}s + \\int_f \\gamma_f \\boldsymbol{u}_{\\mathrm{ex}}\\cdot\\boldsymbol{v} \\, \\mathrm{d}s $。\n- 我们求解全局线性系统以获得 $ \\boldsymbol{u}_h $。\n- 斑块检验验证通过在 $ \\Gamma $ 上进行单元面求积，比较 $ \\boldsymbol{u}_h $ 和 $ \\boldsymbol{u}_{\\mathrm{ex}} $，计算相对 $ L^2 $ 边界误差 $ \\mathrm{err}_\\Gamma $。对于精确的仿射解和一致的组装，误差应接近机器精度。\n\n测试套件包括：\n- 情况 A: $ E = 1.0 \\times 10^7 $, $ \\nu = 0.30 $, $ N_x = 2 $, $ N_y = 2 $, $ \\boldsymbol{u}_{\\mathrm{ex}} = [x,\\, 0]^{\\top} $。\n- 情况 B: $ E = 1.0 \\times 10^7 $, $ \\nu = 0.30 $, $ N_x = 3 $, $ N_y = 2 $, $ \\boldsymbol{u}_{\\mathrm{ex}} = [0,\\, y]^{\\top} $。\n- 情况 C: $ E = 1.0 \\times 10^7 $, $ \\nu = 0.4999 $, $ N_x = 2 $, $ N_y = 2 $, $ \\boldsymbol{u}_{\\mathrm{ex}} = [y,\\, x]^{\\top} $。\n\n对于每种情况，我们输出一个布尔值，指示 $ \\mathrm{err}_\\Gamma  \\tau $ 是否成立，其中 $ \\tau = 1.0 \\times 10^{-9} $。最终程序将三个布尔值聚合成单行，作为方括号内的逗号分隔列表。",
            "answer": "```python\nimport numpy as np\n\n# Numpy-based FEM with symmetric Nitsche and parameter-free gamma from local polynomial reconstruction.\n\ndef lame_parameters(E, nu):\n    mu = E / (2.0 * (1.0 + nu))\n    lam = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    return lam, mu\n\ndef C_plane_strain(E, nu):\n    lam, mu = lame_parameters(E, nu)\n    C = np.array([[lam + 2*mu, lam, 0.0],\n                  [lam, lam + 2*mu, 0.0],\n                  [0.0, 0.0, mu]])\n    return C\n\ndef shape_Q1(ksi, eta):\n    # Bilinear quad on reference [-1,1]^2\n    N = np.zeros(4)\n    dN_dksi = np.zeros(4)\n    dN_deta = np.zeros(4)\n    N[0] = 0.25*(1-ksi)*(1-eta)  # lower-left\n    N[1] = 0.25*(1+ksi)*(1-eta)  # lower-right\n    N[2] = 0.25*(1+ksi)*(1+eta)  # upper-right\n    N[3] = 0.25*(1-ksi)*(1+eta)  # upper-left\n\n    dN_dksi[0] = -0.25*(1-eta)\n    dN_dksi[1] = +0.25*(1-eta)\n    dN_dksi[2] = +0.25*(1+eta)\n    dN_dksi[3] = -0.25*(1+eta)\n\n    dN_deta[0] = -0.25*(1-ksi)\n    dN_deta[1] = -0.25*(1+ksi)\n    dN_deta[2] = +0.25*(1+ksi)\n    dN_deta[3] = +0.25*(1-ksi)\n    return N, dN_dksi, dN_deta\n\ndef jacobian(xe, ye, dN_dksi, dN_deta):\n    # xe, ye: arrays of element node coordinates (length 4)\n    J = np.zeros((2,2))\n    J[0,0] = np.dot(dN_dksi, xe)\n    J[0,1] = np.dot(dN_deta, xe)\n    J[1,0] = np.dot(dN_dksi, ye)\n    J[1,1] = np.dot(dN_deta, ye)\n    detJ = np.linalg.det(J)\n    invJT = np.linalg.inv(J).T\n    return J, detJ, invJT\n\ndef grad_N_xy(dN_dksi, dN_deta, invJT):\n    dN_dx = invJT[0,0]*dN_dksi + invJT[0,1]*dN_deta\n    dN_dy = invJT[1,0]*dN_dksi + invJT[1,1]*dN_deta\n    return dN_dx, dN_dy\n\ndef B_matrix(dN_dx, dN_dy):\n    # 3 x 8 matrix for plane strain, engineering shear gamma_xy\n    B = np.zeros((3, 8))\n    for a in range(4):\n        B[0, 2*a]     = dN_dx[a]         # epsilon_xx\n        B[1, 2*a+1]   = dN_dy[a]         # epsilon_yy\n        B[2, 2*a]     = dN_dy[a]         # gamma_xy contribution from u_x\n        B[2, 2*a+1]   = dN_dx[a]         # gamma_xy contribution from u_y\n    return B\n\ndef N2_matrix(N):\n    # 2 x 8 matrix maps nodal vector dofs to vector field via scalar shape N\n    N2 = np.zeros((2, 8))\n    for a in range(4):\n        N2[0, 2*a]   = N[a]\n        N2[1, 2*a+1] = N[a]\n    return N2\n\ndef P_matrix(n):\n    # Map stress vector [sigma_xx, sigma_yy, tau_xy] to traction t = [t_x, t_y]\n    nx, ny = n\n    P = np.array([[nx, 0.0, ny],\n                  [0.0, ny, nx]])\n    return P\n\n# Exact affine modes and strains\ndef mode_strain(mode_id):\n    # Returns strain vector [epsilon_xx, epsilon_yy, gamma_xy] for affine modes\n    if mode_id == 0:   # u = [x, 0]\n        return np.array([1.0, 0.0, 0.0])\n    elif mode_id == 1: # u = [0, y]\n        return np.array([0.0, 1.0, 0.0])\n    elif mode_id == 2: # u = [0, x]\n        return np.array([0.0, 0.0, 1.0])\n    elif mode_id == 3: # u = [y, 0]\n        return np.array([0.0, 0.0, 1.0])\n    elif mode_id == 4: # u = [x, y]\n        return np.array([1.0, 1.0, 0.0])\n    elif mode_id == 5: # u = [y, x]\n        return np.array([0.0, 0.0, 2.0])\n    else:\n        raise ValueError(\"Unsupported mode\")\n\ndef u_exact_from_mode(x, y, mode_id):\n    if mode_id == 0:   # [x, 0]\n        return np.array([x, 0.0])\n    elif mode_id == 1: # [0, y]\n        return np.array([0.0, y])\n    elif mode_id == 2: # [0, x]\n        return np.array([0.0, x])\n    elif mode_id == 3: # [y, 0]\n        return np.array([y, 0.0])\n    elif mode_id == 4: # [x, y]\n        return np.array([x, y])\n    elif mode_id == 5: # [y, x]\n        return np.array([y, x])\n    else:\n        raise ValueError(\"Unsupported mode\")\n\ndef traction_from_strain(n, C, strain_vec):\n    # stress = C * strain_vec (Voigt, plane strain)\n    stress = C @ strain_vec\n    P = P_matrix(n)\n    t = P @ stress\n    return t\n\ndef compute_face_normal_and_length(xe, ye, face_id):\n    # face_id: 0=left (ksi=-1), 1=right (ksi=+1), 2=bottom (eta=-1), 3=top (eta=+1)\n    # element nodes: 0:LL,1:LR,2:UR,3:UL\n    if face_id == 0:\n        # left edge from node 0 to 3\n        p0 = np.array([xe[0], ye[0]])\n        p1 = np.array([xe[3], ye[3]])\n        tangent = p1 - p0\n        length = np.linalg.norm(tangent)\n        # outward normal for left boundary is negative x direction\n        normal = np.array([-(xe[1]-xe[0]), -(ye[1]-ye[0])])  # vector along +ksi direction\n        if np.linalg.norm(normal)  1e-16:\n            normal = np.array([-1.0, 0.0])\n        else:\n            normal = normal / np.linalg.norm(normal)\n        return normal, length\n    elif face_id == 1:\n        # right edge from node 1 to 2\n        p0 = np.array([xe[1], ye[1]])\n        p1 = np.array([xe[2], ye[2]])\n        tangent = p1 - p0\n        length = np.linalg.norm(tangent)\n        normal = np.array([+(xe[1]-xe[0]), +(ye[1]-ye[0])])\n        if np.linalg.norm(normal)  1e-16:\n            normal = np.array([1.0, 0.0])\n        else:\n            normal = normal / np.linalg.norm(normal)\n        return normal, length\n    elif face_id == 2:\n        # bottom edge from node 0 to 1\n        p0 = np.array([xe[0], ye[0]])\n        p1 = np.array([xe[1], ye[1]])\n        tangent = p1 - p0\n        length = np.linalg.norm(tangent)\n        normal = np.array([-(xe[3]-xe[0]), -(ye[3]-ye[0])])\n        if np.linalg.norm(normal)  1e-16:\n            normal = np.array([0.0, -1.0])\n        else:\n            normal = normal / np.linalg.norm(normal)\n        return normal, length\n    elif face_id == 3:\n        # top edge from node 3 to 2\n        p0 = np.array([xe[3], ye[3]])\n        p1 = np.array([xe[2], ye[2]])\n        tangent = p1 - p0\n        length = np.linalg.norm(tangent)\n        normal = np.array([+(xe[3]-xe[0]), +(ye[3]-ye[0])])\n        if np.linalg.norm(normal)  1e-16:\n            normal = np.array([0.0, +1.0])\n        else:\n            normal = normal / np.linalg.norm(normal)\n        return normal, length\n    else:\n        raise ValueError(\"Invalid face_id\")\n\ndef compute_gamma_face(xe, ye, C, face_id):\n    # Compute c_f^2 via local polynomial reconstruction over chosen affine modes (excluding rigid motions)\n    # Quadrature points on the face:\n    gp = np.array([-1.0/np.sqrt(3.0), +1.0/np.sqrt(3.0)])\n    w = np.array([1.0, 1.0])\n    # Determine constant normal and length for axis-aligned quads\n    n, length = compute_face_normal_and_length(xe, ye, face_id)\n    # Element area by 2x2 quadrature\n    gp2 = gp\n    area = 0.0\n    for ksi in gp2:\n        for eta in gp2:\n            _, dN_dksi, dN_deta = shape_Q1(ksi, eta)\n            J, detJ, _ = jacobian(xe, ye, dN_dksi, dN_deta)\n            area += detJ\n    # Maximize Rayleigh quotient over selected affine modes\n    modes = [0, 1, 2, 3, 4, 5]\n    c2_max = 0.0\n    for mode in modes:\n        strain = mode_strain(mode)\n        # Interior energy: ∫_e ε:C:ε dx (no 0.5 factor)\n        energy_density = float(strain @ (C @ strain))\n        E_int = energy_density * area\n        if E_int  1e-20:\n            continue\n        # Traction is constant for affine strain\n        t = traction_from_strain(n, C, strain)\n        # Integrals along face\n        Bf = 0.0\n        Df = 0.0\n        for i, s in enumerate(gp):\n            wi = w[i]\n            # Reference point on face\n            if face_id == 0:   # left: ksi=-1, eta=s\n                ksi, eta = -1.0, s\n            elif face_id == 1: # right: ksi=+1\n                ksi, eta = +1.0, s\n            elif face_id == 2: # bottom: eta=-1, ksi=s\n                ksi, eta = s, -1.0\n            else:              # top: eta=+1\n                ksi, eta = s, +1.0\n            N, dN_dksi, dN_deta = shape_Q1(ksi, eta)\n            # Physical coord for u_exact evaluation on face (to compute u for the mode)\n            x = np.dot(N, xe)\n            y = np.dot(N, ye)\n            u = u_exact_from_mode(x, y, mode)\n            # Line measure: for bilinear mapping of axis-aligned quad, ds = length/2 * wi\n            ds = (length * 0.5) * wi\n            Bf += np.dot(t, u) * ds\n            Df += np.dot(u, u) * ds\n        if Df  1e-20:\n            continue\n        c2 = (Bf**2) / (E_int * Df)\n        if c2  c2_max:\n            c2_max = c2\n    gamma = c2_max + 1e-16  # numerical safeguard\n    return gamma\n\ndef assemble_system(nx, ny, E, nu, mode_id):\n    # Mesh\n    # Nodes grid coordinates\n    xs = np.linspace(0.0, 1.0, nx+1)\n    ys = np.linspace(0.0, 1.0, ny+1)\n    n_nodes = (nx+1)*(ny+1)\n    coords = np.zeros((n_nodes, 2))\n    for j in range(ny+1):\n        for i in range(nx+1):\n            nid = j*(nx+1) + i\n            coords[nid, 0] = xs[i]\n            coords[nid, 1] = ys[j]\n    # Elements connectivity\n    n_elems = nx*ny\n    conn = np.zeros((n_elems, 4), dtype=int)\n    e = 0\n    for j in range(ny):\n        for i in range(nx):\n            n0 = j*(nx+1) + i\n            n1 = n0 + 1\n            n3 = n0 + (nx+1)\n            n2 = n3 + 1\n            # order: [LL, LR, UR, UL]\n            conn[e, :] = [n0, n1, n2, n3]\n            e += 1\n    ndof = 2*n_nodes\n    K = np.zeros((ndof, ndof))\n    F = np.zeros(ndof)\n    C = C_plane_strain(E, nu)\n\n    # Interior assembly\n    gp = np.array([-1.0/np.sqrt(3.0), +1.0/np.sqrt(3.0)])\n    w = np.array([1.0, 1.0])\n    for e in range(n_elems):\n        nodes = conn[e, :]\n        xe = coords[nodes, 0]\n        ye = coords[nodes, 1]\n        Ke = np.zeros((8,8))\n        Fe = np.zeros(8)\n        for i, ksi in enumerate(gp):\n            for j, eta in enumerate(gp):\n                wi = w[i]*w[j]\n                N, dN_dksi, dN_deta = shape_Q1(ksi, eta)\n                J, detJ, invJT = jacobian(xe, ye, dN_dksi, dN_deta)\n                dN_dx, dN_dy = grad_N_xy(dN_dksi, dN_deta, invJT)\n                B = B_matrix(dN_dx, dN_dy)\n                Ke += (B.T @ C @ B) * detJ * wi\n        # Scatter\n        dofs = np.zeros(8, dtype=int)\n        for a in range(4):\n            dofs[2*a]   = 2*nodes[a]\n            dofs[2*a+1] = 2*nodes[a]+1\n        # Add to global\n        K[np.ix_(dofs, dofs)] += Ke\n        F[dofs] += Fe\n\n    # Boundary Nitsche assembly\n    # For each element, process faces; only if both nodes lie on boundary\n    for e in range(n_elems):\n        nodes = conn[e, :]\n        xe = coords[nodes, 0]\n        ye = coords[nodes, 1]\n        # Face descriptors: (face_id, node pair indices, boundary condition check)\n        faces = [\n            (0, [0,3], lambda x,y: np.allclose(x, 0.0)),             # left x=0\n            (1, [1,2], lambda x,y: np.allclose(x, 1.0)),             # right x=1\n            (2, [0,1], lambda x,y: np.allclose(y, 0.0)),             # bottom y=0\n            (3, [3,2], lambda x,y: np.allclose(y, 1.0))              # top y=1\n        ]\n        for face_id, pair, is_boundary in faces:\n            # Check if both nodes lie on the boundary\n            xpair = xe[pair]\n            ypair = ye[pair]\n            if not (is_boundary(xpair[0], ypair[0]) and is_boundary(xpair[1], ypair[1])):\n                continue\n            # Compute gamma for this face\n            gamma_f = compute_gamma_face(xe, ye, C, face_id)\n            # Quadrature along face\n            gp1d = np.array([-1.0/np.sqrt(3.0), +1.0/np.sqrt(3.0)])\n            w1d = np.array([1.0, 1.0])\n            # Normal and length\n            n, length = compute_face_normal_and_length(xe, ye, face_id)\n            # Assemble boundary terms\n            for iq, s in enumerate(gp1d):\n                wi = w1d[iq]\n                # Reference coordinates at face\n                if face_id == 0:\n                    ksi, eta = -1.0, s\n                elif face_id == 1:\n                    ksi, eta = +1.0, s\n                elif face_id == 2:\n                    ksi, eta = s, -1.0\n                else:\n                    ksi, eta = s, +1.0\n                N, dN_dksi, dN_deta = shape_Q1(ksi, eta)\n                J, detJ, invJT = jacobian(xe, ye, dN_dksi, dN_deta)\n                dN_dx, dN_dy = grad_N_xy(dN_dksi, dN_deta, invJT)\n                B = B_matrix(dN_dx, dN_dy)\n                N2 = N2_matrix(N)\n                P = P_matrix(n)\n                T = P @ C @ B  # 2 x 8 mapping U_e - traction at this GP\n                # Physical coordinates of GP for u_exact\n                xgp = np.dot(N, xe)\n                ygp = np.dot(N, ye)\n                uex = u_exact_from_mode(xgp, ygp, mode_id)\n                # Exact strain and traction (constant for affine mode)\n                strain_ex = mode_strain(mode_id)\n                tex = traction_from_strain(n, C, strain_ex)\n                # Line measure\n                ds = (length * 0.5) * wi\n                # Stiffness terms\n                Ke_b1 = - (N2.T @ T) * ds\n                Ke_b2 = - (T.T @ N2) * ds\n                Ke_pen = (gamma_f * (N2.T @ N2)) * ds\n                # Load terms\n                Fe_cons = - (N2.T @ tex) * ds\n                Fe_pen  = (gamma_f * (N2.T @ uex)) * ds\n                # Scatter\n                dofs = np.zeros(8, dtype=int)\n                for a in range(4):\n                    dofs[2*a]   = 2*nodes[a]\n                    dofs[2*a+1] = 2*nodes[a]+1\n                K[np.ix_(dofs, dofs)] += Ke_b1 + Ke_b2 + Ke_pen\n                F[dofs] += Fe_cons + Fe_pen\n\n    return K, F, coords, conn\n\ndef solve_case(nx, ny, E, nu, mode_id, tol=1e-9):\n    K, F, coords, conn = assemble_system(nx, ny, E, nu, mode_id)\n    # Solve linear system\n    U = np.linalg.solve(K, F)\n    # Compute relative L2 boundary error\n    # Integrate over boundary faces only a single time\n    gp1d = np.array([-1.0/np.sqrt(3.0), +1.0/np.sqrt(3.0)])\n    w1d = np.array([1.0, 1.0])\n    num = 0.0\n    den = 0.0\n    nx_elems = nx*ny\n    for e in range(nx_elems):\n        nodes = conn[e, :]\n        xe = coords[nodes, 0]\n        ye = coords[nodes, 1]\n        Ue = np.zeros(8)\n        for a in range(4):\n            Ue[2*a]   = U[2*nodes[a]]\n            Ue[2*a+1] = U[2*nodes[a]+1]\n        faces = [\n            (0, [0,3], lambda x,y: np.allclose(x, 0.0)),\n            (1, [1,2], lambda x,y: np.allclose(x, 1.0)),\n            (2, [0,1], lambda x,y: np.allclose(y, 0.0)),\n            (3, [3,2], lambda x,y: np.allclose(y, 1.0))\n        ]\n        for face_id, pair, is_boundary in faces:\n            xpair = xe[pair]\n            ypair = ye[pair]\n            if not (is_boundary(xpair[0], ypair[0]) and is_boundary(xpair[1], ypair[1])):\n                continue\n            # Normal and length\n            n, length = compute_face_normal_and_length(xe, ye, face_id)\n            for iq, s in enumerate(gp1d):\n                wi = w1d[iq]\n                if face_id == 0:\n                    ksi, eta = -1.0, s\n                elif face_id == 1:\n                    ksi, eta = +1.0, s\n                elif face_id == 2:\n                    ksi, eta = s, -1.0\n                else:\n                    ksi, eta = s, +1.0\n                N, dN_dksi, dN_deta = shape_Q1(ksi, eta)\n                # Evaluate FE displacement at GP\n                N2 = N2_matrix(N)\n                uh = N2 @ Ue\n                # Exact displacement\n                xgp = np.dot(N, xe)\n                ygp = np.dot(N, ye)\n                uex = u_exact_from_mode(xgp, ygp, mode_id)\n                diff = uh - uex\n                ds = (length * 0.5) * wi\n                num += np.dot(diff, diff) * ds\n                den += np.dot(uex, uex) * ds\n    err_rel = np.sqrt(num) / (np.sqrt(den) + 1e-30)\n    return err_rel  tol\n\ndef solve():\n    test_cases = [\n        (2, 2, 1.0e7, 0.30, 0),  # Case A: u=[x,0]\n        (3, 2, 1.0e7, 0.30, 1),  # Case B: u=[0,y]\n        (2, 2, 1.0e7, 0.4999, 5) # Case C: u=[y,x] nearly incompressible\n    ]\n    results = []\n    for nx, ny, E, nu, mode_id in test_cases:\n        passed = solve_case(nx, ny, E, nu, mode_id, tol=1.0e-9)\n        results.append(str(passed).lower())  # print as 'true'/'false'\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}