{
    "hands_on_practices": [
        {
            "introduction": "第一个动手实践旨在巩固对库仑摩擦模型核心逻辑的理解。我们将利用经典的斜面滑块模型，编写一个程序来准确判断物体的粘滞（stick）与临界滑移（slip-threshold）状态。这个练习是掌握后续更复杂数值方法的基础。",
            "id": "3555411",
            "problem": "您的任务是为一个刚性滑块在重力作用下与刚性斜面单边接触的系统构建并验证一个计算基准。该模型使用库仑摩擦，重点关注粘滞条件和粘滑转换阈值。斜面与水平面成 $\\,\\alpha\\,$ 角（以弧度为单位）。滑块的质量为 $\\,m\\,$（单位：千克），重力加速度为 $\\,g\\,$（单位：米/秒平方），摩擦系数为 $\\,\\mu \\ge 0\\,$（无量纲）。坐标系的定义如下：切向 $\\,t\\,$ 沿斜面向下，法向 $\\,n\\,$ 垂直于斜面，从斜面指向滑块。假设接触保持闭合，法向间隙 $\\,g_n = 0\\,$，法向反作用力 $\\,R_n \\ge 0\\,$，且在任何测试用例中滑块都不会脱离斜面。\n\n使用的基本原理：\n- 牛顿第二运动定律：$\\,\\sum F = m a\\,$。\n- 根据定义的坐标系将重力分解为切向和法向分量。\n- 接触点的库仑摩擦定律：静摩擦满足 $\\,|R_t| \\le \\mu R_n\\,$，在滑动阈值时 $\\,|R_t| = \\mu R_n\\,$。这里 $\\,R_t\\,$ 是切向反作用力的大小，$\\,R_n\\,$ 是法向反作用力。\n- 粘滞条件定义为 $\\,\\tan\\alpha  \\mu\\,$，滑动阈值（开始滑动的临界点）条件在指定的数值公差内定义为 $\\,\\tan\\alpha = \\mu\\,$。\n\n您的任务是实现一个程序，对每个提供的测试用例，确定状态分类并计算反作用力分量 $\\,R_n\\,$ 和 $\\,R_t\\,$ 的大小（单位：牛顿）。使用以下状态标签：粘滞为 $\\,0\\,$，滑动阈值为 $\\,1\\,$。必须处理符号约定，使得 $\\,R_n \\ge 0\\,$ 和 $\\,R_t \\ge 0\\,$ 分别表示法向和切向接触反作用力的大小。角度必须以弧度为单位。所有反作用力分量必须以牛顿为单位表示，并四舍五入到六位小数。\n\n算法必须：\n- 使用数值公差 $\\,\\varepsilon = 10^{-12}\\,$ 来比较 $\\,\\tan\\alpha\\,$ 和 $\\,\\mu\\,$。\n- 如果 $\\,\\tan\\alpha  \\mu - \\varepsilon\\,$，则分类为粘滞。\n- 如果 $\\,|\\tan\\alpha - \\mu| \\le \\varepsilon\\,$，则分类为滑动阈值。\n- 对于粘滞状态，强制切向加速度为零，并根据上述定律计算唯一的平衡反作用力。\n- 对于滑动阈值状态，强制使用库仑摩擦的等式形式，并根据上述定律计算反作用力。\n\n测试套件：\n为以下参数集 $\\,\\{m,\\alpha,\\mu,g\\}\\,$ 提供结果，所有角度均以弧度为单位，$\\,g\\,$ 的单位为米/秒平方：\n1. $\\,\\{2.0,\\,0.3,\\,0.5,\\,9.81\\}\\,$.\n2. $\\,\\{5.0,\\,\\arctan(0.3),\\,0.3,\\,9.81\\}\\,$.\n3. $\\,\\{10.5,\\,0.0,\\,0.2,\\,9.80665\\}\\,$.\n4. $\\,\\{1.0,\\,0.0,\\,0.0,\\,9.81\\}\\,$.\n\n输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例必须生成一个列表 $\\,[s, R_n, R_t]\\,$，其中 $\\,s\\,$ 是整数状态标签（$\\,0\\,$ 代表粘滞，$\\,1\\,$ 代表滑动阈值），$\\,R_n, R_t\\,$ 是四舍五入到六位小数的浮点数。最终输出必须是这些列表的列表，按给定的测试用例顺序排列，例如 $\\,[[s_1,R_{n1},R_{t1}],\\,[s_2,R_{n2},R_{t2}],\\,[s_3,R_{n3},R_{t3}],\\,[s_4,R_{n4},R_{t4}]]\\,$。",
            "solution": "该问题被认为是有效的，因为它以经典力学为科学基础，对于给定条件是适定的，具有唯一且稳定的解，并使用客观、明确的语言和数据进行表述。所有必要的参数和约束都已提供，并且没有内部矛盾。\n\n解决方案框架建立在 Newton 第二定律 $\\sum F = m a$ 之上，应用于斜面上的一个质量为 $m$ 的刚性滑块。斜面与水平面形成一个角度 $\\alpha$。坐标系的定义为：法向 $n$ 垂直于斜面，切向 $t$ 指向斜坡下方。\n\n首先，我们将重力 $F_g = m g$ 分解为沿 $n$ 轴和 $t$ 轴的分量。重力垂直向下作用。垂直于斜面的分量沿负 $n$ 方向（指向斜面内）作用，其大小为 $m g \\cos\\alpha$。平行于斜面的分量沿正 $t$ 方向（沿斜面向下）作用，其大小为 $m g \\sin\\alpha$。\n\n斜面对滑块施加的接触力包括一个沿正 $n$ 方向作用的法向反作用力 $R_n$，以及一个大小用 $R_t$ 表示的切向摩擦力。摩擦力与运动趋势相反，该运动趋势由重力的切向分量驱动。因此，摩擦力沿负 $t$ 方向（沿斜面向上）作用。\n\n在法向（$n$）上应用 Newton 第二定律：\n$$ \\sum F_n = R_n - m g \\cos\\alpha = m a_n $$\n问题指出，滑块不脱离斜面，这意味着法向加速度 $a_n = 0$。这将方程简化为：\n$$ R_n - m g \\cos\\alpha = 0 \\implies R_n = m g \\cos\\alpha $$\n由于 $m  0$，$g  0$，并且对于任何物理斜面 $\\cos\\alpha \\ge 0$，条件 $R_n \\ge 0$ 均得到满足。这个法向反作用力大小 $R_n$ 的公式对于所考虑的所有状态都有效。\n\n接下来，我们在切向（$t$）上应用 Newton 第二定律：\n$$ \\sum F_t = m g \\sin\\alpha - R_t = m a_t $$\n这里，$R_t$ 表示沿斜面向上作用的摩擦力的大小。接下来的分析根据滑块的状态而有所不同，该状态通过比较 $\\tan\\alpha$ 和静摩擦系数 $\\mu$ 来确定。此比较使用数值公差 $\\varepsilon = 10^{-12}$。\n\n状态 1：粘滞条件 ($s = 0$)\n如果静摩擦力足以阻止运动，则此状态被激活。条件为 $\\tan\\alpha  \\mu - \\varepsilon$。在粘滞状态下，滑块保持平衡，意味着其切向加速度为零，$a_t = 0$。将此代入切向力方程得到：\n$$ m g \\sin\\alpha - R_t = 0 \\implies R_t = m g \\sin\\alpha $$\n只要所需的摩擦力 $R_t$ 不超过最大可用静摩擦力 $|R_t| \\le \\mu R_n$，此结果就有效。代入推导出的 $R_t$ 和 $R_n$ 表达式：\n$$ m g \\sin\\alpha \\le \\mu (m g \\cos\\alpha) \\implies \\tan\\alpha \\le \\mu $$\n这证实了我们的计算与物理原理和问题的标准是一致的。对于粘滞情况，反作用力为 $R_n = m g \\cos\\alpha$ 和 $R_t = m g \\sin\\alpha$。\n\n状态 2：滑动阈值条件 ($s = 1$)\n此状态表示滑块处于即将滑动的临界点。其数值条件定义为 $|\\tan\\alpha - \\mu| \\le \\varepsilon$。在此阈值下，静摩擦力达到其可能的最大值，由库仑摩擦定律的等式形式给出：\n$$ R_t = \\mu R_n $$\n由于滑动阈值是静态情况的极限，我们仍然认为滑块处于平衡状态，因此 $a_t = 0$。切向力方程 $m g \\sin\\alpha - R_t = 0$ 意味着驱动力等于摩擦力。然而，在这种状态的计算中，我们直接使用摩擦定律。代入 $R_n$ 的表达式：\n$$ R_t = \\mu (m g \\cos\\alpha) $$\n因此，对于滑动阈值情况，反作用力为 $R_n = m g \\cos\\alpha$ 和 $R_t = \\mu m g \\cos\\alpha$。\n\n对于每个测试用例 $\\{m, \\alpha, \\mu, g\\}$，计算算法按以下步骤进行：\n1. 计算 $\\tan\\alpha$。\n2. 使用公差 $\\varepsilon = 10^{-12}$ 比较 $\\tan\\alpha$ 和 $\\mu$。\n3. 如果 $\\tan\\alpha  \\mu - \\varepsilon$，将状态分类为粘滞（$s=0$），并计算 $R_n = m g \\cos\\alpha$ 和 $R_t = m g \\sin\\alpha$。\n4. 如果 $|\\tan\\alpha - \\mu| \\le \\varepsilon$，将状态分类为滑动阈值（$s=1$），并计算 $R_n = m g \\cos\\alpha$ 和 $R_t = \\mu R_n$。\n5. 将得到的反作用力分量四舍五入到六位小数作为最终输出。\n此程序为每个给定的测试用例提供了唯一且正确的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the state and reaction forces for a block on an inclined plane\n    based on Coulomb friction model for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (m, alpha, mu, g)\n    test_cases = [\n        (2.0, 0.3, 0.5, 9.81),\n        (5.0, np.arctan(0.3), 0.3, 9.81),\n        (10.5, 0.0, 0.2, 9.80665),\n        (1.0, 0.0, 0.0, 9.81),\n    ]\n\n    # Numerical tolerance\n    epsilon = 1e-12\n\n    results = []\n    \n    for m, alpha, mu, g in test_cases:\n        # State classification\n        tan_alpha = np.tan(alpha)\n        \n        state = -1 # Uninitialized state\n        Rn = 0.0\n        Rt = 0.0\n\n        if tan_alpha  mu - epsilon:\n            # Stick condition\n            state = 0\n            # From Newton's laws for equilibrium (a_n=0, a_t=0)\n            # R_n - m*g*cos(alpha) = 0\n            # m*g*sin(alpha) - R_t = 0\n            Rn = m * g * np.cos(alpha)\n            Rt = m * g * np.sin(alpha)\n        elif np.abs(tan_alpha - mu) = epsilon:\n            # Slip-threshold condition\n            state = 1\n            # R_n is the same as for stick case\n            # R_t is at its maximum value: R_t = mu * R_n\n            Rn = m * g * np.cos(alpha)\n            Rt = mu * Rn\n        \n        results.append([state, Rn, Rt])\n\n    # Format the results into the required string format.\n    # Each sublist is formatted as [s, Rn, Rt] with floats rounded to 6 decimal places.\n    formatted_results = []\n    for res in results:\n        s, Rn, Rt = res\n        formatted_results.append(f\"[{s},{Rn:.6f},{Rt:.6f}]\")\n\n    # Combine all formatted sublists into the final output string.\n    final_output = f\"[{','.join(formatted_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "高效稳健的数值求解器是解决复杂工程问题的关键。本实践将深入探讨隐式求解方法的核心，您需要为一个摩擦接触问题推导并实现一个采用*一致性雅可比矩阵*（consistent Jacobian）的牛顿法求解器。通过这个练习，您将深刻理解保证算法二次收敛的理论基础，这是现代计算固体力学的一块重要基石。",
            "id": "3555393",
            "problem": "考虑一个准静态、平面、单节点的切向接触问题，该问题发生在可变形体与具有库仑摩擦的刚性基础之间。可变形体通过一个刚度为 $k_{s}  0$ 的线性弹性切向弹簧建模，该弹簧附着于一个在平面内受约束的质点；接触界面则通过一个切向罚刚度 $k_{t}  0$ 和库仑摩擦极限 $\\tau = \\mu p  0$ 建模，其中 $\\mu$ 是摩擦系数，$p$ 是（恒定的）接触压力。设未知的切向位移为向量 $u \\in \\mathbb{R}^{2}$，外部施加的载荷为 $F \\in \\mathbb{R}^{2}$。\n\n节点处的控制平衡方程是力的平衡\n$$\nK u + t(u) = F,\n$$\n其中 $K = k_{s} I$ 是结构刚度，$I \\in \\mathbb{R}^{2 \\times 2}$ 是单位矩阵，$t(u) \\in \\mathbb{R}^{2}$ 是由界面提供的摩擦牵引力。带有切向罚分的库仑摩擦模型用于模拟粘滞，其活动集表征定义如下：\n\n- 定义试探牵引力\n$$\nt_{\\mathrm{tr}}(u) = k_{t}\\,u.\n$$\n\n- 粘滞集：如果 $\\|t_{\\mathrm{tr}}(u)\\| \\le \\tau$，则状态为粘滞，牵引力为\n$$\nt(u) = t_{\\mathrm{tr}}(u).\n$$\n\n- 滑移集：如果 $\\|t_{\\mathrm{tr}}(u)\\|  \\tau$，则状态为滑移，牵引力被径向返回到库仑盘上，\n$$\nt(u) = \\tau \\,\\frac{t_{\\mathrm{tr}}(u)}{\\|t_{\\mathrm{tr}}(u)\\|} = \\tau \\,\\frac{u}{\\|u\\|}.\n$$\n\n您需要为在每次迭代中使用活动集更新的整体牛顿法推导残差的完全一致线性化。具体来说：\n\n1. 仅从平衡方程、上述粘滞/滑移定义和微积分法则出发，推导牛顿残差\n$$\nr(u) = K u + t(u) - F,\n$$\n和一致雅可比矩阵\n$$\nJ(u) = \\frac{\\partial r(u)}{\\partial u} = K + \\frac{\\partial t(u)}{\\partial u},\n$$\n这两个表达式需分别针对粘滞集和滑移集。您的推导必须说明活动集更新如何进入算法，以及一旦确定了活动集，线性化为何保持一致。\n\n2. 根据上述粘滞/滑移准则，在每次迭代中使用活动集更新，实现一个用于非线性系统 $r(u) = 0$ 的牛顿求解器，并在当前活动集下使用推导的一致雅可比矩阵。在每次迭代 $k$ 中，计算残差范数 $\\|r(u^{(k)})\\|_{2}$，通过求解\n$$\nJ(u^{(k)})\\,\\Delta u^{(k)} = -r(u^{(k)}), \\quad u^{(k+1)} = u^{(k)} + \\Delta u^{(k)},\n$$\n来更新 $u^{(k+1)}$，并记录活动集标签（粘滞或滑移）。当 $\\|r(u^{(k)})\\|_{2} \\le \\varepsilon$ 时终止，其中 $\\varepsilon  0$ 是一个预设的容差。\n\n3. 通过检查每个载荷步迭代序列末尾附近的观测收敛阶，定量验证在重复的粘滞-滑移转换过程中是否保持了二次收敛。使用残差范数定义局部观测阶为\n$$\np_{k} = \\frac{\\ln\\left(\\dfrac{\\|r(u^{(k+1)})\\|_{2}}{\\|r(u^{(k)})\\|_{2}}\\right)}{\\ln\\left(\\dfrac{\\|r(u^{(k)})\\|_{2}}{\\|r(u^{(k-1)})\\|_{2}}\\right)},\n$$\n只要分母有定义且所有残差范数均为严格正值。为避免前渐近污染，仅在 $\\|r(u^{(k)})\\|_{2} \\le \\rho$（其中 $\\rho  0$ 为预设阈值）时评估 $p_{k}$。\n\n对于序列中的每个载荷步，确定活动集标签发生变化的最后一次迭代索引；然后，仅使用该索引之后的迭代，要求最后两个计算出的观测阶 $p_{k}$ 均大于或等于 $1.8$，以宣布该载荷步达到了持续的二次收敛。如果牛顿法在最多两次迭代内收敛，则默认宣布该步骤达到了持续的二次收敛。\n\n实现该算法并将其应用于以下测试套件。所有力必须以牛顿 (N) 表示，刚度以牛顿/米 (N/m) 表示，位移以米 (m) 表示，角度以弧度表示。\n\n所有测试的通用参数：\n- $k_{s} = 10 \\,\\text{N/m}$，\n- $k_{t} = 100 \\,\\text{N/m}$，\n- $\\tau = 1 \\,\\text{N}$，\n- 牛顿法容差 $\\varepsilon = 10^{-12} \\,\\text{N}$，\n- 渐近阈值 $\\rho = 10^{-6} \\,\\text{N}$，\n- 每载荷步的最大迭代次数 $50$。\n\n测试用例：\n\n- 用例 1（沿直线发生的粘滞-滑移-粘滞-滑移）：沿 $x$ 轴施加的一系列四个载荷 $F \\in \\mathbb{R}^{2}$，\n  1. $F = (0.5, 0.0)$,\n  2. $F = (1.2, 0.0)$,\n  3. $F = (0.8, 0.0)$,\n  4. $F = (1.5, 0.0)$,\n  顺序施加，使用上一步的收敛位移作为下一步的初始猜测值。\n\n- 用例 2（持续滑移下的方向旋转）：一系列三个大小为 $2.0 \\,\\text{N}$ 的载荷，角度分别为 $0$、$\\pi/4$ 和 $\\pi/2$ 弧度，\n  1. $F = 2.0 \\,(\\cos(0), \\sin(0))$,\n  2. $F = 2.0 \\,(\\cos(\\pi/4), \\sin(\\pi/4))$,\n  3. $F = 2.0 \\,(\\cos(\\pi/2), \\sin(\\pi/2))$,\n  顺序施加，使用上一步的收敛位移作为下一步的初始猜测值。\n\n- 用例 3（阈值附近的切换）：沿 $x$ 轴在粘滞-滑移阈值附近施加的一系列四个载荷，\n  1. $F = (1.08, 0.0)$,\n  2. $F = (1.12, 0.0)$,\n  3. $F = (1.09, 0.0)$,\n  4. $F = (1.11, 0.0)$,\n  顺序施加，使用上一步的收敛位移作为下一步的初始猜测值。\n\n对于每个用例，返回一个布尔值，指示该用例中的每个载荷步是否都观察到了按上述精确定义所指的持续二次收敛。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[true,false,true]\"，但使用您语言的布尔字面量）。角度必须以弧度解释，并且所有物理单位必须如上所述得到遵守。每个用例的最终输出必须是布尔值。",
            "solution": "用户提供了一个关于带有库仑摩擦的单节点接触模型的计算固体力学中的适定问题。任务是为活动集牛顿法推导一致雅可比矩阵，实现求解器，并在一个测试套件上验证其二次收敛特性。\n\n### 问题验证\n所提供的问题是计算力学中摩擦接触的一个标准（尽管简化了）的表示。\n\n- **给定条件**：\n    - 控制方程：$K u + t(u) = F$\n    - 结构刚度：$K = k_{s} I$，其中 $I \\in \\mathbb{R}^{2 \\times 2}$ 是单位矩阵。\n    - 摩擦牵引力 $t(u)$：\n        - 试探牵引力：$t_{\\mathrm{tr}}(u) = k_{t}\\,u$。\n        - 粘滞：如果 $\\|t_{\\mathrm{tr}}(u)\\| \\le \\tau$，则 $t(u) = t_{\\mathrm{tr}}(u)$。\n        - 滑移：如果 $\\|t_{\\mathrm{tr}}(u)\\|  \\tau$，则 $t(u) = \\tau \\frac{u}{\\|u\\|}$。\n    - 牛顿法：\n        - 残差：$r(u) = K u + t(u) - F$。\n        - 雅可比矩阵：$J(u) = \\frac{\\partial r(u)}{\\partial u}$。\n        - 更新：求解 $J(u^{(k)})\\,\\Delta u^{(k)} = -r(u^{(k)})$ 得到 $\\Delta u^{(k)}$，然后 $u^{(k+1)} = u^{(k)} + \\Delta u^{(k)}$。\n    - 收敛准则：\n        - 终止条件：$\\|r(u^{(k)})\\|_{2} \\le \\varepsilon$。\n        - 观测阶：$p_{k} = \\frac{\\ln\\left(\\|r(u^{(k+1)})\\|_{2}/\\|r(u^{(k)})\\|_{2}\\right)}{\\ln\\left(\\|r(u^{(k)})\\|_{2}/\\|r(u^{(k-1)})\\|_{2}\\right)}$。\n        - 二次收敛检验：对于每个载荷步，如果在最后的活动集变化之后且 $\\|r(u^{(k)})\\|_{2} \\le \\rho$ 的条件下，最后两个有效计算的收敛阶 $p_k$ 均 $\\ge 1.8$，或者如果求解器在 $\\le 2$ 次迭代内收敛，则宣布为持续二次收敛。\n    - 参数：$k_{s} = 10 \\,\\text{N/m}$，$k_{t} = 100 \\,\\text{N/m}$，$\\tau = 1 \\,\\text{N}$，$\\varepsilon = 10^{-12} \\,\\text{N}$，$\\rho = 10^{-6} \\,\\text{N}$，最大迭代次数 $50$。\n    - 测试用例：三组施加载荷 $F$ 的序列。\n\n- **验证结论**：问题是**有效的**。它科学上基于接触力学的既定原理，在数学上是适定的、客观的且自包含的。所有必要的方程、参数和准则都已明确提供。该任务需要严格的推导和仔细的实现，这是该领域的标准练习。\n\n### 第1部分：一致雅可比矩阵的推导\n\n求解非线性系统 $r(u) = 0$ 的牛顿法需要雅可比矩阵 $J(u)$，即残差 $r(u)$ 相对于位移向量 $u$ 的导数。\n$$\nr(u) = k_s u + t(u) - F\n$$\n残差的导数是：\n$$\nJ(u) = \\frac{\\partial r(u)}{\\partial u} = \\frac{\\partial}{\\partial u} (k_s u + t(u) - F) = k_s \\frac{\\partial u}{\\partial u} + \\frac{\\partial t(u)}{\\partial u} - \\frac{\\partial F}{\\partial u}\n$$\n由于 $F$ 是外部施加的载荷，它与 $u$ 无关，因此 $\\frac{\\partial F}{\\partial u} = 0$。项 $\\frac{\\partial u}{\\partial u}$ 是单位矩阵 $I \\in \\mathbb{R}^{2 \\times 2}$。结构刚度为 $K=k_s I$。因此，雅可比矩阵简化为：\n$$\nJ(u) = K + \\frac{\\partial t(u)}{\\partial u}\n$$\n关键部分是推导牵引力导数 $\\frac{\\partial t(u)}{\\partial u}$，它取决于位移 $u$ 处的活动集（粘滞或滑移）。\n\n**1. 粘滞集推导**\n- **条件**：粘滞条件是 $\\|t_{\\mathrm{tr}}(u)\\| \\le \\tau$，使用定义 $t_{\\mathrm{tr}}(u) = k_t u$ 后，简化为 $k_t \\|u\\| \\le \\tau$。\n- **牵引力**：在粘滞集中，牵引力是位移的线性函数：\n$$\nt(u) = k_t u\n$$\n- **雅可比矩阵**：这个线性函数的导数是一个常数张量：\n$$\n\\frac{\\partial t(u)}{\\partial u} = \\frac{\\partial}{\\partial u} (k_t u) = k_t I\n$$\n将此代入 $J(u)$ 的通用表达式，粘滞集的一致雅可比矩阵为：\n$$\nJ_{\\mathrm{stick}}(u) = K + k_t I = k_s I + k_t I = (k_s + k_t)I\n$$\n这是一个简单的对角矩阵，代表结构弹簧和接触罚弹簧的组合刚度。\n\n**2. 滑移集推导**\n- **条件**：滑移条件是 $\\|t_{\\mathrm{tr}}(u)\\|  \\tau$，简化为 $k_t \\|u\\|  \\tau$。在此情况下，$\\|u\\|$ 不能为零。\n- **牵引力**：在滑移集中，牵引力向量的大小恒为 $\\tau$，方向与滑移相反。在这里，它与位移 $u$ 对齐：\n$$\nt(u) = \\tau \\frac{u}{\\|u\\|} = \\tau \\hat{n}(u)\n$$\n其中 $\\hat{n}(u) = u/\\|u\\|$ 是归一化的位移向量。\n- **雅可比矩阵**：我们必须对 $t(u)$ 求关于 $u \\in \\mathbb{R}^2$ 的导数。这需要使用链式法则。归一化向量 $\\hat{n}(u)$ 的导数是张量微积分中的一个已知结果：\n$$\n\\frac{\\partial \\hat{n}(u)}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( \\frac{u}{\\|u\\|} \\right) = \\frac{1}{\\|u\\|} \\left( I - \\frac{u \\otimes u}{\\|u\\|^2} \\right)\n$$\n其中 $\\otimes$ 表示外积。项 $(I - \\hat{n} \\otimes \\hat{n})$ 是一个投影算子，它将向量投影到与 $\\hat{n}$ 正交的空间上。\n利用这个结果，滑移牵引力的导数为：\n$$\n\\frac{\\partial t(u)}{\\partial u} = \\tau \\frac{\\partial \\hat{n}(u)}{\\partial u} = \\frac{\\tau}{\\|u\\|} \\left( I - \\frac{u \\otimes u}{\\|u\\|^2} \\right)\n$$\n将此代入 $J(u)$ 的通用表达式，滑移集的一致雅可比矩阵为：\n$$\nJ_{\\mathrm{slip}}(u) = K + \\frac{\\tau}{\\|u\\|} \\left( I - \\frac{u \\otimes u}{\\|u\\|^2} \\right) = k_s I + \\frac{\\tau}{\\|u\\|}I - \\frac{\\tau}{\\|u\\|^3}(u \\otimes u)\n$$\n这个雅可比矩阵在径向方向上是秩亏的（它有一个对应于特征向量 $u$ 的零特征值），这反映了在滑移状态下，沿 $u$ 方向的运动阻力仅由结构刚度 $k_s$ 控制，而与 $u$ 正交方向的运动阻力则涉及 $k_s$ 和一个几何刚度项 $\\tau/\\|u\\|$。\n\n### 第2部分：算法设计与收敛性\n\n牛顿法采用活动集策略实现。在给定一个位移猜测值 $u^{(k)}$ 的每次迭代 $k$ 中：\n1.  计算试探牵引力 $t_{\\mathrm{tr}}(u^{(k)}) = k_t u^{(k)}$。\n2.  通过比较 $\\|t_{\\mathrm{tr}}(u^{(k)})\\|$ 和 $\\tau$ 来确定活动集。\n3.  根据活动集（‘stick’ 或 ‘slip’），从上述推导中选择牵引力 $t(u^{(k)})$ 和雅可比矩阵 $J(u^{(k)})$ 的相应表达式。\n4.  计算残差 $r(u^{(k)}) = k_s u^{(k)} + t(u^{(k)}) - F$。\n5.  求解线性系统 $J(u^{(k)}) \\Delta u^{(k)} = -r(u^{(k)})$ 得到位移增量 $\\Delta u^{(k)}$。\n6.  更新位移：$u^{(k+1)} = u^{(k)} + \\Delta u^{(k)}$。\n7.  重复此过程，直到残差范数 $\\|r(u^{(k+1)})\\|_2$ 低于容差 $\\varepsilon$。\n\n此过程使用*一致线性化*，因为雅可比矩阵 $J(u^{(k)})$ 是在迭代 $k$ 中所选特定活动集分支下残差函数 $r(u)$ 的精确导数。一旦迭代收敛到活动集不再改变的点，该方法就表现为求解光滑非线性系统的标准牛顿-拉夫逊求解器，已知其具有二次收敛性。\n\n收敛性的定量验证按规定进行。一个载荷步收敛后，分析其残差范数和活动集的历史记录。“持续二次收敛”准则要求最后两个计算出的渐近收敛阶 $p_k$ 均 $\\ge 1.8$，这是一个严格的检验，用以确认在由活动集切换引起的任何初始非光滑性问题得到解决后，该方法确实达到了理论上预期的性能。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the contact mechanics problem and verifies convergence.\n    \"\"\"\n\n    # Common parameters\n    ks = 10.0  # N/m\n    kt = 100.0 # N/m\n    tau = 1.0  # N\n    eps = 1e-12 # N\n    rho = 1e-6  # N\n    max_iter = 50\n\n    # Test cases\n    test_cases_loads = [\n        # Case 1: stick-slip-stick-slip along a straight line\n        [\n            np.array([0.5, 0.0]),\n            np.array([1.2, 0.0]),\n            np.array([0.8, 0.0]),\n            np.array([1.5, 0.0]),\n        ],\n        # Case 2: directional rotation under persistent slip\n        [\n            2.0 * np.array([math.cos(0.0), math.sin(0.0)]),\n            2.0 * np.array([math.cos(math.pi / 4.0), math.sin(math.pi / 4.0)]),\n            2.0 * np.array([math.cos(math.pi / 2.0), math.sin(math.pi / 2.0)]),\n        ],\n        # Case 3: near-threshold toggling\n        [\n            np.array([1.08, 0.0]),\n            np.array([1.12, 0.0]),\n            np.array([1.09, 0.0]),\n            np.array([1.11, 0.0]),\n        ],\n    ]\n\n    overall_results = []\n\n    for case_loads in test_cases_loads:\n        u_initial = np.zeros(2)\n        case_passed = True\n        for F_load in case_loads:\n            u_converged, history = newton_solver(F_load, u_initial, ks, kt, tau, eps, max_iter)\n            \n            load_step_passed = analyze_convergence(history['residual_norms'], history['active_sets'], rho)\n\n            if not load_step_passed:\n                case_passed = False\n                break\n            \n            u_initial = u_converged\n        \n        overall_results.append(case_passed)\n\n    print(f\"[{','.join(map(str, overall_results))}]\".lower())\n\ndef newton_solver(F, u_initial, ks, kt, tau, eps, max_iter):\n    \"\"\"\n    Performs the active-set Newton method for a single load step.\n    \"\"\"\n    u = np.copy(u_initial)\n    I = np.identity(2)\n    K = ks * I\n\n    history = {'residual_norms': [], 'active_sets': []}\n    \n    for k in range(max_iter + 1):\n        # Determine active set and compute traction t and its derivative dt_du\n        t_tr = kt * u\n        norm_t_tr = np.linalg.norm(t_tr)\n\n        if norm_t_tr = tau:\n            # Stick state\n            active_set = 'stick'\n            t = t_tr\n            dt_du = kt * I\n        else:\n            # Slip state\n            active_set = 'slip'\n            norm_u = np.linalg.norm(u)\n            # norm_u will not be zero in slip, as kt*||u||  tau  0\n            t = tau * u / norm_u\n            \n            u_outer_u = np.outer(u, u)\n            dt_du = (tau / norm_u) * (I - u_outer_u / (norm_u**2))\n            \n        # Compute residual r and Jacobian J\n        r = K @ u + t - F\n        J = K + dt_du\n        \n        norm_r = np.linalg.norm(r)\n        \n        history['residual_norms'].append(norm_r)\n        history['active_sets'].append(active_set)\n        \n        if norm_r = eps:\n            break\n            \n        if k == max_iter:\n            # Failed to converge\n            break\n\n        # Solve for increment and update\n        delta_u = np.linalg.solve(J, -r)\n        u = u + delta_u\n        \n    return u, history\n\ndef analyze_convergence(residual_norms, active_sets, rho):\n    \"\"\"\n    Verifies sustained quadratic convergence for a single load step.\n    \"\"\"\n    num_iterations = len(residual_norms) - 1\n    \n    # Pass by default if converged in = 2 iterations\n    if num_iterations = 2:\n        return True\n\n    # Find the index of the last iteration where the active set changed\n    last_change_idx = 0\n    for i in range(1, len(active_sets)):\n        if active_sets[i] != active_sets[i-1]:\n            last_change_idx = i\n\n    valid_p_orders = []\n    # k is the index into the residual_norms list, corresponding to u^(k)\n    # We can compute p_k for k from 1 to len-2.\n    # We only consider k > last_change_idx.\n    for k in range(last_change_idx + 1, len(residual_norms) - 1):\n        if k == 0:\n             continue # Cannot compute p_k if k=0\n        \n        norm_rk_m1 = residual_norms[k-1]\n        norm_rk = residual_norms[k]\n        norm_rk_p1 = residual_norms[k+1]\n\n        # Check conditions for computing p_k\n        if norm_rk > rho:\n            continue\n            \n        # Denominators must be defined and norms strictly positive\n        if norm_rk_m1 = 0 or norm_rk = 0:\n            continue\n        \n        # Avoid division by zero if norms are equal\n        if abs(norm_rk - norm_rk_m1)  1e-15:\n            continue\n\n        denominator = np.log(norm_rk / norm_rk_m1)\n        if abs(denominator)  1e-15:\n            continue\n\n        numerator = np.log(norm_rk_p1 / norm_rk)\n        \n        pk = numerator / denominator\n        valid_p_orders.append(pk)\n        \n    # Check if the last two valid computed orders are >= 1.8\n    if len(valid_p_orders) >= 2:\n        if valid_p_orders[-1] >= 1.8 and valid_p_orders[-2] >= 1.8:\n            return True\n    \n    return False\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "在模拟含摩擦的动力学系统时，数值模型有时会产生被称为“颤振”（chatter）的非物理高频振荡。本实践将聚焦于这一重要的工程挑战。您将通过构建一个仿真程序，研究几何噪声、离散化和数值平滑等因素如何引发伪粘滑（spurious stick-slip）现象，从而深入理解保证动态接触模拟稳定性和保真度的关键。",
            "id": "3555440",
            "problem": "考虑一个单自由度质点 $m$，代表一个在刚性平面上滑动的刚性块。该刚性块通过一个刚度为 $k$ 的线性弹簧进行切向驱动，弹簧的锚点以恒定速度 $v_0$ 移动。滑块与平面之间的接触是摩擦性的，并遵循经典的库仑摩擦模型。设全局坐标系中，预期的滑动方向为全局 $x$ 轴，平面的名义法线方向为全局 $y$ 轴。通过一个保持法向间隙为零的约束，强制质量块始终与平面保持接触。由于接触检测噪声和几何离散化，接触法线方向被允许随时间变化，其被建模为一个随时间变化的法向角 $\\theta(t)$，单位为弧度，从全局 $y$ 轴向量全局 $x$ 轴测量。单位法向量和单位切向量为\n$$\nn(t) = \\begin{bmatrix}\\sin \\theta(t) \\\\ \\cos \\theta(t)\\end{bmatrix}, \\quad\nt(t) = \\begin{bmatrix}\\cos \\theta(t) \\\\ -\\sin \\theta(t)\\end{bmatrix}.\n$$\n该仿真是由以下假设和模型驱动的：\n- 牛顿第二定律适用于切线方向：$m \\, \\dot{v}_x(t) = F_s(t) + F_f^x(t)$，其中 $v_x(t)$ 是滑块速度的全局 $x$ 分量，$F_s(t)$ 是沿全局 $x$ 方向的弹簧力，$F_f^x(t)$ 是摩擦力的全局 $x$ 分量。\n- 弹簧力为 $F_s(t) = k \\left( x_d(t) - x(t) \\right)$，其中 $x(t)$ 是滑块的位置（单位：米），$x_d(t) = v_0 t$ 是驱动位置（单位：米），以恒定速度 $v_0$ 演化。\n- 法向反作用力的大小近似为常数 $N = m g$，其中 $g$ 是重力加速度。此近似在 $\\theta(t)$ 很小时有效，确保 $N$ 保持在 $m g$ 附近。\n- 在接触切线方向上施加带滞回效应的库仑摩擦，其阈值为 $\\mu_{\\text{stick}\\rightarrow\\text{slip}} = \\mu (1 + h)$ 和 $\\mu_{\\text{slip}\\rightarrow\\text{stick}} = \\mu (1 - h)$，其中 $\\mu$ 是摩擦系数，$h \\in [0,1)$ 是滞回分数。将弹簧力的切向投影定义为 $F_s^t(t) = F_s(t) \\, t_x(t) = F_s(t) \\cos \\theta(t)$，切向滑移速度定义为 $v_t(t) = v_x(t) \\cos \\theta(t)$。粘滑切换逻辑如下：\n  - 如果接触当前处于粘滞状态且 $|F_s^t(t)|  \\mu (1 + h) N$，则切换到滑移状态。\n  - 如果接触当前处于滑移状态且 $|F_s^t(t)| \\le \\mu (1 - h) N$ 且 $|v_t(t)| \\le v_\\varepsilon$，则切换到粘滞状态。\n  在粘滞期间，在该时间步内设置 $v_x(t) = 0$ 且 $x(t)$ 为常数。在滑移期间，施加动摩擦力 $F_f^t(t) = - \\mu (1 - h) N \\, \\operatorname{sign}(v_t(t))$（如果 $v_t(t) = 0$，则使用 $\\operatorname{sign}(F_s^t(t))$），其全局 $x$ 分量为 $F_f^x(t) = F_f^t(t) \\, t_x(t) = F_f^t(t) \\cos \\theta(t)$。\n- 法向角 $\\theta(t)$ 是由几何离散化和检测噪声组合产生，并经过指数平滑处理：\n  1. 定义基准角 $\\theta_b(t) = A \\sin(\\omega t)$，其振幅为 $A$，基准频率为 $\\omega = 2 \\pi f_b$。\n  2. 通过将 $\\theta_b(t)$ 量化到区间 $[-A, A]$ 内的 $L$ 个等间距水平上，进行几何离散化，得到 $\\theta_q(t)$。\n  3. 添加检测噪声 $\\delta \\theta(t) = 0.1 A \\sin(\\omega_j t)$，其抖动频率为 $\\omega_j = 2 \\pi f_j$，产生原始角度 $\\theta_{\\text{raw}}(t) = \\theta_q(t) + \\delta \\theta(t)$。\n  4. 应用指数平滑：在离散时间 $t_n = n \\Delta t$（$n = 0,1,2,\\dots$），时间步长为 $\\Delta t$ 时，$\\theta(t_n) = (1 - \\alpha) \\, \\theta(t_{n-1}) + \\alpha \\, \\theta_{\\text{raw}}(t_n)$，平滑因子为 $\\alpha \\in [0,1]$。\n\n在滑移模式下，仿真通过显式欧拉积分进行时间步进：\n$$\na_x(t_n) = \\frac{F_s(t_n) + F_f^x(t_n)}{m}, \\quad\nv_x(t_{n+1}) = v_x(t_n) + \\Delta t \\, a_x(t_n), \\quad\nx(t_{n+1}) = x(t_n) + \\Delta t \\, v_x(t_{n+1}),\n$$\n在粘滞期间保持 $v_x(t_n) = 0$。初始条件为 $x(0) = 0$ 和 $v_x(0) = 0$，初始模式为粘滞。重力加速度为 $g = 9.81$ $\\text{m}/\\text{s}^2$。\n\n定义伪颤振分数 $\\psi$ 为：自上次转换以来的时间间隔小于或等于颤振阈值 $\\tau_c$ 的粘滑转换次数，除以仿真期间观察到的总转换次数。如果没有发生转换，则设 $\\psi = 0$。角度必须以弧度为单位，所有量均使用国际单位制（SI）：米、千克、秒和牛顿。伪颤振分数 $\\psi$ 是无量纲的，必须以小数形式报告。\n\n为给定的测试套件实现上述仿真。对于所有情况，使用相同的数值参数：时间步长 $\\Delta t = 0.001$ $\\text{s}$，总时间 $T = 3.0$ $\\text{s}$，颤振阈值 $\\tau_c = 0.005$ $\\text{s}$，基准频率 $f_b = 30$ $\\text{Hz}$，以及抖动频率 $f_j = 200$ $\\text{Hz}$。使用 $v_\\varepsilon = 10^{-4}$ $\\text{m}/\\text{s}$。\n\n测试套件：\n- 案例 1（正常路径，中等噪声，部分平滑，轻微滞回）：$m = 1.0$ $\\text{kg}$，$k = 100.0$ $\\text{N}/\\text{m}$，$\\mu = 0.3$，$v_0 = 0.05$ $\\text{m}/\\text{s}$，$A = 0.05$ $\\text{rad}$，$L = 8$，$\\alpha = 0.2$，$h = 0.1$。\n- 案例 2（大噪声振幅，粗糙几何，强平滑，无滞回）：$m = 1.0$ $\\text{kg}$，$k = 100.0$ $\\text{N}/\\text{m}$，$\\mu = 0.3$，$v_0 = 0.05$ $\\text{m}/\\text{s}$，$A = 0.2$ $\\text{rad}$，$L = 3$，$\\alpha = 0.05$，$h = 0.0$。\n- 案例 3（无平滑，中等噪声，无滞回）：$m = 1.0$ $\\text{kg}$，$k = 100.0$ $\\text{N}/\\text{m}$，$\\mu = 0.3$，$v_0 = 0.05$ $\\text{m}/\\text{s}$，$A = 0.1$ $\\text{rad}$，$L = 4$，$\\alpha = 1.0$，$h = 0.0$。\n- 案例 4（精细几何离散化，低噪声，中等平滑，较强滞回）：$m = 1.0$ $\\text{kg}$，$k = 100.0$ $\\text{N}/\\text{m}$，$\\mu = 0.3$，$v_0 = 0.05$ $\\text{m}/\\text{s}$，$A = 0.02$ $\\text{rad}$，$L = 64$，$\\alpha = 0.5$，$h = 0.2$。\n- 案例 5（中等噪声，中等平滑，强滞回）：$m = 1.0$ $\\text{kg}$，$k = 100.0$ $\\text{N}/\\text{m}$，$\\mu = 0.3$，$v_0 = 0.05$ $\\text{m}/\\text{s}$，$A = 0.1$ $\\text{rad}$，$L = 8$，$\\alpha = 0.3$，$h = 0.5$。\n\n您的程序应生成单行输出，其中包含五个案例的伪颤振分数，形式为用方括号括起来的逗号分隔列表（例如，$[\\psi_1,\\psi_2,\\psi_3,\\psi_4,\\psi_5]$）。每个 $\\psi_i$ 必须以小数形式打印。",
            "solution": "该问题要求对一个单自由度摩擦系统进行仿真，以计算伪颤振分数 $\\psi$。该仿真基于一组耦合的、随时间变化的常微分方程以及一个用于粘滑摩擦模型的状态机。解决方案是通过在时间上离散化系统并实现一个显式时间步进算法来获得的。\n\n在任何离散时间步 $t_n = n \\Delta t$，系统的状态由滑块的位置 $x(t_n)$、其速度 $v_x(t_n)$、平滑后的接触法向角 $\\theta(t_n)$ 以及接触的摩擦状态（粘滞或滑移）来描述。在 $t_0=0$ 时的初始条件为 $x(0)=0$、$v_x(0)=0$，初始模式为“粘滞” (stick)。假设在 $t  0$ 时系统处于静止状态，初始角度 $\\theta(0)$ 取为 0。仿真总时长为 $T = 3.0$ s，时间步长为 $\\Delta t=0.001$ s。\n\n解决方案的核心是一个时间步进循环，它将系统状态从 $t_n$推进到 $t_{n+1}$。在每个步骤 $n$，执行以下操作序列：\n\n1.  **更新接触法向角 $\\theta(t_n)$**：根据指定的多阶段程序计算随时间变化的法向角 $\\theta(t_n)$。\n    -   计算基准正弦角 $\\theta_b(t_n) = A \\sin(\\omega_b t_n)$，其中 $\\omega_b = 2 \\pi f_b$ 且 $f_b=30$ Hz。\n    -   将 $\\theta_b(t_n)$ 在范围 $[-A, A]$ 内量化到 $L$ 个离散水平之一。量化函数将值 $v \\in [-A, A]$ 映射到集合 $\\{-A, -A + \\frac{2A}{L-1}, \\dots, A\\}$ 中最接近的水平。\n    -   计算高频正弦噪声项 $\\delta \\theta(t_n) = 0.1 A \\sin(\\omega_j t_n)$，其中 $\\omega_j = 2 \\pi f_j$ 且 $f_j = 200$ Hz。\n    -   原始角度构成为 $\\theta_{\\text{raw}}(t_n) = \\theta_q(t_n) + \\delta \\theta(t_n)$。\n    -   最后，通过指数平滑更新平滑角度 $\\theta(t_n)$：$\\theta(t_n) = (1 - \\alpha) \\theta(t_{n-1}) + \\alpha \\theta_{\\text{raw}}(t_n)$。对于第一步 $t_0=0$，我们使用 $\\theta(t_{-1})=0$。\n\n2.  **评估力和摩擦状态**：基于在 $t_n$ 的状态，计算力以确定区间 $[t_n, t_{n+1}]$ 内的摩擦模式。\n    -   弹簧力为 $F_s(t_n) = k (v_0 t_n - x(t_n))$。\n    -   弹簧力的切向投影为 $F_s^t(t_n) = F_s(t_n) \\cos(\\theta(t_n))$。\n    -   切向滑移速度为 $v_t(t_n) = v_x(t_n) \\cos(\\theta(t_n))$。\n    -   法向力近似为常数 $N = mg$，其中 $g = 9.81 \\, \\text{m}/\\text{s}^2$。\n    -   从粘滞到滑移的转换阈值为 $F_{\\text{stick}\\rightarrow\\text{slip}} = \\mu (1 + h) N$。\n    -   从滑移到粘滞的力阈值为 $F_{\\text{slip}\\rightarrow\\text{stick}} = \\mu (1-h) N$。\n    -   应用状态机逻辑：\n        -   如果当前模式为“粘滞”(stick)，当 $|F_s^t(t_n)|  F_{\\text{stick}\\rightarrow\\text{slip}}$ 时，发生向“滑移”(slip)的转换。\n        -   如果当前模式为“滑移”(slip)，当 $|F_s^t(t_n)| \\le F_{\\text{slip}\\rightarrow\\text{stick}}$ 且 $|v_t(t_n)| \\le v_\\varepsilon$ 时，发生向“粘滞”(stick)的转换，其中 $v_\\varepsilon = 10^{-4} \\, \\text{m}/\\text{s}$。\n    -   如果发生转换，则记录时间 $t_n$。\n\n3.  **将状态推进到 $t_{n+1}$**：根据上一步确定的模式更新系统状态。\n    -   **如果在“粘滞”模式下**：滑块的速度被制动，其位置保持不变。\n        $$v_x(t_{n+1}) = 0$$\n        $$x(t_{n+1}) = x(t_n)$$\n    -   **如果在“滑移”模式下**：使用半隐式欧拉格式对运动方程进行积分。\n        -   切线方向的动摩擦力为 $F_f^t(t_n) = - \\mu (1 - h) N \\cdot \\text{sign}(v_t(t_n))$。如果 $v_t(t_n)$ 实际上为零，则改用即将发生的运动的符号，即 $\\text{sign}(F_s^t(t_n))$。\n        -   摩擦力的全局 $x$ 分量为 $F_f^x(t_n) = F_f^t(t_n) \\cos(\\theta(t_n))$。\n        -   通过牛顿第二定律计算加速度：$a_x(t_n) = (F_s(t_n) + F_f^x(t_n)) / m$。\n        -   状态更新如下：\n            $$v_x(t_{n+1}) = v_x(t_n) + \\Delta t \\cdot a_x(t_n)$$\n            $$x(t_{n+1}) = x(t_n) + \\Delta t \\cdot v_x(t_{n+1})$$\n\n4.  **计算伪颤振分数 $\\psi$**：在仿真于 $T = 3.0$ s 完成后，分析记录的转换时间列表。\n    -   设 $K$ 个转换时间的序列为 $T_1, T_2, \\ldots, T_K$。\n    -   如果 $K \\le 1$，则无法形成区间，因此 $\\psi=0$。\n    -   “颤振”转换的次数是满足以下条件的转换 $T_j$（对于 $j \\in \\{2, \\ldots, K\\}$）的计数：其前一个时间间隔小于或等于颤振阈值，即 $T_j - T_{j-1} \\le \\tau_c$，其中 $\\tau_c = 0.005$ s。设此计数为 $N_{\\text{chatter}}$。\n    -   伪颤振分数计算为颤振转换次数与总转换次数的比率：$\\psi = N_{\\text{chatter}} / K$。\n\n整个过程被封装在一个函数中，该函数接受单个测试用例的参数。对测试套件中提供的五个案例中的每一个都调用此函数，并将得到的 $\\psi$ 值收集并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Numerical parameters common to all cases\n    G = 9.81  # m/s^2\n    DT = 0.001  # s\n    T_TOTAL = 3.0  # s\n    TAU_C = 0.005  # s\n    F_B = 30.0  # Hz\n    F_J = 200.0  # Hz\n    V_EPS = 1e-4  # m/s\n\n    test_cases = [\n        # Case 1 (m, k, mu, v0, A, L, alpha, h)\n        (1.0, 100.0, 0.3, 0.05, 0.05, 8, 0.2, 0.1),\n        # Case 2\n        (1.0, 100.0, 0.3, 0.05, 0.2, 3, 0.05, 0.0),\n        # Case 3\n        (1.0, 100.0, 0.3, 0.05, 0.1, 4, 1.0, 0.0),\n        # Case 4\n        (1.0, 100.0, 0.3, 0.05, 0.02, 64, 0.5, 0.2),\n        # Case 5\n        (1.0, 100.0, 0.3, 0.05, 0.1, 8, 0.3, 0.5),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        m, k, mu, v0, A, L, alpha, h = case_params\n        \n        # Pass all parameters to the simulation runner\n        psi = run_simulation(m, k, mu, v0, A, L, alpha, h, G, DT, T_TOTAL, TAU_C, F_B, F_J, V_EPS)\n        results.append(psi)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef quantize(val, A, L):\n    \"\"\"Quantizes a value to L levels in the symmetric interval [-A, A].\"\"\"\n    if L = 1:\n        return 0.0\n    \n    interval_size = 2.0 * A / (L - 1)\n    if interval_size == 0:\n        return 0.0\n        \n    # Map val from [-A, A] to an index in [0, L-1]\n    index = np.round((val + A) / interval_size)\n    index = np.clip(index, 0, L - 1)\n    \n    # Return the quantized value corresponding to the index\n    return -A + index * interval_size\n\ndef run_simulation(m, k, mu, v0, A, L, alpha, h, G, DT, T_TOTAL, TAU_C, F_B, F_J, V_EPS):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n    \"\"\"\n    # Setup simulation time and state arrays\n    num_steps = int(T_TOTAL / DT) + 1\n    t = np.linspace(0, T_TOTAL, num_steps)\n    \n    x = np.zeros(num_steps)\n    vx = np.zeros(num_steps)\n    theta = np.zeros(num_steps)\n    \n    # Calculate constants for the simulation\n    N = m * G\n    omega_b = 2 * np.pi * F_B\n    omega_j = 2 * np.pi * F_J\n    \n    # Friction force thresholds\n    stick_slip_thresh = mu * (1 + h) * N\n    slip_stick_thresh_F = mu * (1 - h) * N\n    kinetic_friction_force_mag = slip_stick_thresh_F\n\n    # Initial state\n    mode = 'stick'\n    transition_times = []\n    \n    # theta[0] is 0 based on quiescent pre-simulation state\n    theta[0] = 0.0\n\n    # Main simulation loop\n    for n in range(num_steps - 1):\n        t_n = t[n]\n        \n        # 1. Update contact normal angle theta for current step t_n\n        if n > 0:\n            theta_b_n = A * np.sin(omega_b * t_n)\n            theta_q_n = quantize(theta_b_n, A, L)\n            delta_theta_n = 0.1 * A * np.sin(omega_j * t_n)\n            theta_raw_n = theta_q_n + delta_theta_n\n            theta[n] = (1 - alpha) * theta[n-1] + alpha * theta_raw_n\n        \n        # 2. Evaluate forces and check for state transition\n        x_d = v0 * t_n\n        F_s = k * (x_d - x[n])\n        cos_theta_n = np.cos(theta[n])\n        F_s_t = F_s * cos_theta_n\n        v_t = vx[n] * cos_theta_n\n        \n        prev_mode = mode\n        if mode == 'stick':\n            if abs(F_s_t) > stick_slip_thresh:\n                mode = 'slip'\n        else:  # mode == 'slip'\n            if abs(F_s_t) = slip_stick_thresh_F and abs(v_t) = V_EPS:\n                mode = 'stick'\n\n        if mode != prev_mode:\n            transition_times.append(t_n)\n\n        # 3. Propagate state to t_{n+1}\n        if mode == 'stick':\n            vx[n+1] = 0.0\n            x[n+1] = x[n]\n        else:  # mode == 'slip'\n            if abs(v_t) > 1e-12:\n                sign_v = np.sign(v_t)\n            else:\n                sign_v = np.sign(F_s_t)\n            \n            Ff_t = -kinetic_friction_force_mag * sign_v\n            Ff_x = Ff_t * cos_theta_n\n            \n            ax = (F_s + Ff_x) / m\n            vx[n+1] = vx[n] + DT * ax\n            x[n+1] = x[n] + DT * vx[n+1]  # Semi-implicit Euler\n\n    # 4. Calculate spurious chatter fraction psi\n    num_transitions = len(transition_times)\n    if num_transitions == 0:\n        return 0.0\n\n    chatter_count = 0\n    if num_transitions > 1:\n        intervals = np.diff(np.array(transition_times))\n        chatter_count = np.sum(intervals = TAU_C)\n        \n    psi = chatter_count / num_transitions\n    return psi\n\nsolve()\n```"
        }
    ]
}