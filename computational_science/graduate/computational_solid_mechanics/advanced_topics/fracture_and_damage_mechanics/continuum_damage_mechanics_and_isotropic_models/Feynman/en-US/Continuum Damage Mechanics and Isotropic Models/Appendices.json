{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of implementing rate-independent material models, including many damage models, is the return mapping algorithm. This exercise guides you through the process of deriving and implementing an implicit update for a simple isotropic damage model, forming the basis of a robust numerical simulation. By working through this problem , you will build a classic elastic predictor/damage corrector scheme and understand how to enforce the all-important consistency condition that keeps the material state on the yield surface during damage evolution.",
            "id": "3554745",
            "problem": "You are asked to formulate and implement an implicit time integration algorithm for a one-dimensional isotropic rate-independent continuum damage model, then apply it to a set of prescribed strain histories. The algorithm must enforce the consistency condition at each time step and produce quantified outputs for a test suite of parameter sets.\n\nAssume a linear elastic base material characterized by modulus $E$ and a scalar isotropic damage variable $d \\in [0,1)$ that reduces the stiffness uniformly. The constitutive stress-strain relation is $ \\sigma = (1 - d) E \\varepsilon $. The Helmholtz free energy per unit volume is postulated as\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2,\n$$\nwhere $H$ is a positive scalar modulus that regularizes the damage evolution and provides a well-posed driving force. The thermodynamic force conjugate to the damage variable is the damage energy release rate\n$$\nY(\\varepsilon, d) = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d.\n$$\nRate-independent damage activation is controlled by a threshold $Y_0 > 0$ through the yield function\n$$\nf(\\varepsilon, d) = Y(\\varepsilon, d) - Y_0,\n$$\nenforced with the Karush-Kuhn-Tucker (KKT) conditions\n$$\n\\dot{d} \\ge 0,\\quad f(\\varepsilon, d) \\le 0,\\quad \\dot{d}\\, f(\\varepsilon, d) = 0.\n$$\nAt each discrete time step $t_{n+1}$, given the previous damage $d_n$ and the prescribed strain $\\varepsilon_{n+1}$, construct an implicit update for $d_{n+1}$ that enforces the consistency condition when the damage mechanism is active. Begin from these fundamental definitions and laws and derive the algorithm that decides whether damage grows or stays constant based on $f(\\varepsilon_{n+1}, d_n)$, and, when active, enforces the consistency condition at $t_{n+1}$ so that the updated state satisfies the appropriate constraint. Use the constitutive stress relation $ \\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1} $ to compute the stress response.\n\nNumerical implementation requirements:\n- Use a small non-negative tolerance $\\tau$ (e.g., $\\tau = 10^{-12}$ in Pascals) for inequality checks in the KKT conditions to account for floating-point round-off.\n- Impose a cap $d_{\\max} = 0.999$ to avoid singular stiffness in the numerical update and enforce $d_{n+1} \\in [0, d_{\\max}]$.\n- Enforce the irreversibility constraint $d_{n+1} \\ge d_n$.\n- Regardless of loading or unloading, the algorithm must be implicit in the sense that all updated quantities are computed at $t_{n+1}$.\n\nPhysical units and output specification:\n- All moduli $E$, $H$, threshold $Y_0$, and stresses $\\sigma$ must be treated and reported in Pascals.\n- Strain $\\varepsilon$ is dimensionless.\n- The program must report, for each test case, a list containing three values: the final damage $d_{\\text{end}}$ (dimensionless), the final stress $\\sigma_{\\text{end}}$ in Pascals, and the integer count of the number of time steps at which the consistency condition was active (i.e., damage was updated under the enforced constraint).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$), where each $\\text{result}_i$ is itself a list $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$ for the corresponding test case.\n\nTest suite:\n- Case $1$ (increasing strain, activation occurs):\n  - $E = 200 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 800\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 0.0,\\ 8 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 1.2 \\times 10^{-4},\\ 2 \\times 10^{-4} \\,]$.\n- Case $2$ (boundary threshold and slight unloading):\n  - $E = 70 \\times 10^{9}\\ \\text{Pa}$, $H = 2 \\times 10^{4}\\ \\text{Pa}$, $Y_0 = 350\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 5 \\times 10^{-5},\\ 1 \\times 10^{-4},\\ 9 \\times 10^{-5} \\,]$.\n- Case $3$ (rapid saturation due to small $H$):\n  - $E = 30 \\times 10^{9}\\ \\text{Pa}$, $H = 500\\ \\text{Pa}$, $Y_0 = 100\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 2 \\times 10^{-4},\\ 3 \\times 10^{-4},\\ 5 \\times 10^{-4} \\,]$.\n- Case $4$ (loading then unloading):\n  - $E = 100 \\times 10^{9}\\ \\text{Pa}$, $H = 10^{4}\\ \\text{Pa}$, $Y_0 = 1000\\ \\text{Pa}$, $d_0 = 0.0$, strain sequence $\\{ \\varepsilon_k \\} = [\\, 1.5 \\times 10^{-4},\\ 2 \\times 10^{-4},\\ 1 \\times 10^{-4} \\,]$.\n\nYour program must implement the implicit algorithm derived from the fundamental definitions and output the aggregated list of $[ d_{\\text{end}}, \\sigma_{\\text{end}}, \\text{active\\_count} ]$ for these four cases on a single line, in the exact format specified above, with stresses in Pascals and damage dimensionless.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum damage mechanics, internally consistent, and provides all necessary data and constraints to formulate a unique and meaningful solution. The problem is a standard exercise in computational solid mechanics, requiring the derivation and implementation of a return mapping algorithm for a rate-independent material model.\n\nThe core of the problem is to devise a time-discrete update rule for the scalar damage variable, $d$, at a time step $t_{n+1}$, given the state at the previous step, $t_n$, and a prescribed strain, $\\varepsilon_{n+1}$. The update must be consistent with the principles of rate-independent irreversible thermodynamics, as specified by the Karush-Kuhn-Tucker (KKT) conditions.\n\nThe state of the system is described by the strain $\\varepsilon$ and the internal damage variable $d$. The model is defined by the following equations:\nThe Helmholtz free energy density:\n$$\n\\psi(\\varepsilon, d) = (1 - d)\\,\\frac{1}{2} E \\varepsilon^2 + \\frac{1}{2} H d^2\n$$\nThe constitutive law for stress:\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = (1 - d) E \\varepsilon\n$$\nThe thermodynamic force conjugate to damage, known as the damage energy release rate:\n$$\nY = - \\frac{\\partial \\psi}{\\partial d} = \\frac{1}{2} E \\varepsilon^2 - H d\n$$\nDamage evolution is governed by the yield function $f$ and a set of KKT conditions:\n$$\nf(Y) = Y - Y_0 \\le 0\n$$\n$$\n\\dot{d} \\ge 0 \\quad (\\text{Irreversibility})\n$$\n$$\n\\dot{d} f(Y) = 0 \\quad (\\text{Consistency})\n$$\nThese conditions define an elastic domain where $f  0$ and $\\dot{d}=0$, and a loading condition where $f=0$ and $\\dot{d} \\ge 0$.\n\nFor numerical implementation, we discretize in time. Given the state $d_n$ at time $t_n$ and the prescribed strain $\\varepsilon_{n+1}$ at time $t_{n+1}$, we seek to find $d_{n+1}$ and $\\sigma_{n+1}$. The algorithm structure follows a standard elastic predictor/damage corrector scheme, which is implicit as it enforces the conditions at the end of the step, $t_{n+1}$.\n\n**Step 1: Elastic Predictor**\nFirst, we make a trial assumption that the step is purely elastic, meaning there is no evolution of damage.\n$$\nd_{n+1}^{\\text{trial}} = d_n\n$$\n\n**Step 2: Check for Damage Activation**\nWe evaluate the yield function at the trial state, using the known strain $\\varepsilon_{n+1}$ and the trial damage $d_{n+1}^{\\text{trial}}$. Let's define the trial damage energy release rate as:\n$$\nY^{\\text{trial}} = Y(\\varepsilon_{n+1}, d_{n+1}^{\\text{trial}}) = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n\n$$\nThe trial yield function is then:\n$$\nf^{\\text{trial}} = Y^{\\text{trial}} - Y_0 = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0\n$$\nWe now check this value against the elastic domain requirement, accounting for a small numerical tolerance $\\tau > 0$:\n- If $f^{\\text{trial}} \\le \\tau$, the trial state is admissible. The elastic assumption holds, and no damage evolution occurs. The KKT conditions are satisfied with $\\Delta d = d_{n+1} - d_n = 0$. Thus, we accept the trial state:\n  $$\n  d_{n+1} = d_n\n  $$\n- If $f^{\\text{trial}} > \\tau$, the trial state is inadmissible as it lies outside the elastic domain. This indicates that damage must occur during the step. The KKT conditions require that the system state returns to the yield surface. This is the **consistency condition**, which must be enforced at the end of the step $t_{n+1}$:\n  $$\n  f(\\varepsilon_{n+1}, d_{n+1}) = 0\n  $$\n\n**Step 3: Damage Corrector**\nWhen the consistency condition is active, we solve for the updated damage value, $d_{n+1}$.\n$$\nf(\\varepsilon_{n+1}, d_{n+1}) = Y(\\varepsilon_{n+1}, d_{n+1}) - Y_0 = 0\n$$\nSubstituting the definition of $Y$:\n$$\n\\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_{n+1} - Y_0 = 0\n$$\nSolving this linear equation for $d_{n+1}$ gives the updated damage:\n$$\nd_{n+1} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\nThis is the \"return mapping\" part of the algorithm, as it maps the inadmissible trial state back to the yield surface.\n\n**Step 4: Enforcement of Constraints**\nThe problem specifies two additional constraints on the damage variable: irreversibility and a maximum value.\n- **Irreversibility**: Damage can only increase or stay constant, so $d_{n+1} \\ge d_n$.\n- **Saturation**: Damage cannot reach $1$, so a numerical cap is imposed: $d_{n+1} \\le d_{\\max}$.\n\nWhen the damage corrector is applied, the calculated value of $d_{n+1}$ must respect these constraints. We can combine the update into a single expression. Let $d_{\\text{candidate}}$ be the value from the consistency condition:\n$$\nd_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)\n$$\nThe final value for $d_{n+1}$ is then obtained by ensuring it is not less than the previous value, $d_n$, and not greater than the cap, $d_{\\max}$. Note that if the corrector step is active ($f^{\\text{trial}} > 0$), then $d_{\\text{candidate}} - d_n = \\frac{1}{H}(\\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 - H d_n) = \\frac{1}{H}f^{\\text{trial}} > 0$, so $d_{\\text{candidate}} > d_n$ is automatically satisfied. The irreversibility constraint $d_{n+1} \\ge d_n$ is thus inherently fulfilled by the logic of the return mapping. The only constraint to enforce explicitly in this case is the cap.\n\nThe complete algorithmic update for $d_{n+1}$ is:\n1.  Calculate $f^{\\text{trial}} = \\frac{1}{2} E \\varepsilon_{n+1}^2 - H d_n - Y_0$.\n2.  If $f^{\\text{trial}} \\le \\tau$:\n    $d_{n+1} = d_n$.\n3.  Else (if $f^{\\text{trial}} > \\tau$):\n    $d_{\\text{candidate}} = \\frac{1}{H} \\left( \\frac{1}{2} E \\varepsilon_{n+1}^2 - Y_0 \\right)$.\n    $d_{n+1} = \\min(d_{\\text{candidate}}, d_{\\max})$.\n\nThis algorithm implicitly maintains the irreversibility constraint. The case where $f^{\\text{trial}} > \\tau$ corresponds to an active consistency condition, so we increment a counter for such steps.\n\n**Step 5: Stress Update**\nOnce the final damage value $d_{n+1}$ is determined for the step, the stress at time $t_{n+1}$ is calculated using the constitutive law:\n$$\n\\sigma_{n+1} = (1 - d_{n+1}) E \\varepsilon_{n+1}\n$$\n\nThis procedure is repeated for each step in the prescribed strain history to find the final damage $d_{\\text{end}}$, final stress $\\sigma_{\\text{end}}$, and the total count of active damage steps.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem for a suite of test cases.\n    \"\"\"\n\n    # Numerical parameters specified in the problem statement.\n    tolerance = 1e-12  # Small tolerance for inequality checks.\n    d_max = 0.999      # Maximum allowable damage value.\n\n    # Test suite defined in the problem statement.\n    test_cases = [\n        # Case 1 (increasing strain, activation occurs)\n        {\n            \"E\": 200e9, \"H\": 1e4, \"Y0\": 800, \"d0\": 0.0,\n            \"strains\": [0.0, 8e-5, 1e-4, 1.2e-4, 2e-4]\n        },\n        # Case 2 (boundary threshold and slight unloading)\n        {\n            \"E\": 70e9, \"H\": 2e4, \"Y0\": 350, \"d0\": 0.0,\n            \"strains\": [5e-5, 1e-4, 9e-5]\n        },\n        # Case 3 (rapid saturation due to small H)\n        {\n            \"E\": 30e9, \"H\": 500, \"Y0\": 100, \"d0\": 0.0,\n            \"strains\": [2e-4, 3e-4, 5e-4]\n        },\n        # Case 4 (loading then unloading)\n        {\n            \"E\": 100e9, \"H\": 1e4, \"Y0\": 1000, \"d0\": 0.0,\n            \"strains\": [1.5e-4, 2e-4, 1e-4]\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E = case[\"E\"]\n        H = case[\"H\"]\n        Y0 = case[\"Y0\"]\n        \n        d_n = case[\"d0\"]\n        strains = case[\"strains\"]\n        \n        active_count = 0\n\n        # Iterate through the prescribed strain history.\n        for eps_np1 in strains:\n            # Calculate the trial yield function value.\n            # f_trial = Y_trial - Y0 = (0.5 * E * eps_np1^2 - H * d_n) - Y0\n            f_trial = 0.5 * E * eps_np1**2 - H * d_n - Y0\n\n            # Elastic predictor/damage corrector logic\n            if f_trial = tolerance:\n                # Elastic step: damage does not evolve.\n                d_np1 = d_n\n            else:\n                # Damage step: enforce consistency condition f(eps_{n+1}, d_{n+1}) = 0.\n                active_count += 1\n                \n                # Solve for d_{n+1} from the consistency condition:\n                # 0.5 * E * eps_{n+1}^2 - H * d_{n+1} - Y0 = 0\n                d_candidate = (0.5 * E * eps_np1**2 - Y0) / H\n                \n                # Enforce the maximum damage constraint. The irreversibility\n                # d_{n+1} = d_n is naturally satisfied since f_trial  0 implies\n                # d_candidate  d_n.\n                d_np1 = min(d_candidate, d_max)\n\n            # Update the damage variable for the next step.\n            d_n = d_np1\n            \n        # After the loop, d_n holds the final damage value.\n        d_end = d_n\n        \n        # Calculate the final stress using the final strain and final damage.\n        eps_end = strains[-1] if strains else 0.0\n        sigma_end = (1 - d_end) * E * eps_end\n        \n        results.append([d_end, sigma_end, active_count])\n\n    # Format the output as a single-line string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While theoretical models are formulated with ideal real numbers, their computational implementation must contend with the realities of finite-precision floating-point arithmetic. This practice  delves into the crucial topic of numerical robustness, particularly for history-dependent variables that are updated via unilateral constraints. You will explore how a naive implementation can lead to inconsistent behavior near decision thresholds and then construct a tolerance-based update rule that ensures reliable and physically consistent results.",
            "id": "3554716",
            "problem": "Consider a scalar, one-dimensional, isotropic damage model integrated in time by operator splitting. The kinematics is characterized by the small strain variable $\\,\\varepsilon\\,$, the scalar internal history variable $\\,\\kappa\\,$ that must be monotonically nondecreasing, and the scalar damage variable $\\,d\\in[0,1)\\,$. The free energy density is assumed to be\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2,\n$$\nwhere $\\,E\\,$ is the Young’s modulus. The thermodynamic force conjugate to $\\,d\\,$ is the energy release rate\n$$\nY(\\varepsilon) = -\\frac{\\partial \\psi}{\\partial d} = \\tfrac{1}{2}\\,E\\,\\varepsilon^2 \\ge 0.\n$$\nDamage is driven by a monotonically nondecreasing history variable $\\,\\kappa\\,$ through a constitutive map $\\,d=g(\\kappa)\\,$. Let\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big),\n$$\nwith parameters $\\,\\kappa_00\\,$ and $\\,m\\ge 1\\,$. The Cauchy stress in one dimension is\n$$\n\\sigma(\\varepsilon,\\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon.\n$$\nThe history update is posed as the unilateral constraint\n$$\n\\kappa_{n+1} = \\max\\big(\\kappa_{n},\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big), \\quad \\text{with} \\quad \\tilde{\\kappa}(\\varepsilon) = |\\varepsilon|.\n$$\nThis realizes the discrete form of the complementarity (Kuhn–Tucker (KT)) conditions for damage initiation and evolution: $\\,\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1} \\le 0\\,$, $\\,\\kappa_{n+1} - \\kappa_{n} \\ge 0\\,$, and $\\,(\\kappa_{n+1}-\\kappa_{n})\\big(\\tilde{\\kappa}(\\varepsilon_{n+1}) - \\kappa_{n+1}\\big)=0\\,$. Near peak strength, floating-point round-off can make $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$ numerically indistinguishable from $\\,\\kappa_n\\,$, which can cause inconsistent branching decisions unless robust tie-breaking rules are used.\n\nStarting from these principles and definitions only (no other formulas may be assumed), implement two discrete time-stepping updates for a single increment $\\,n\\to n+1\\,$:\n\n- A naive update using the exact maximum,\n$$\n\\kappa_{n+1}^{\\text{naive}} = \\max\\big(\\kappa_n,\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\big).\n$$\n\n- A robust update that replaces the exact comparison by a tolerance-aware tie-breaking rule: for user-specified $a_{\\mathrm{tol}} \\ge 0$ and $r_{\\mathrm{tol}} \\ge 0$, define\n$$\n\\mathrm{tol}(\\kappa_n,\\tilde{\\kappa}) = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max\\big(|\\kappa_n|,\\,|\\tilde{\\kappa}|\\big).\n$$\nThen set\n$$\n\\kappa_{n+1}^{\\text{rob}} =\n\\begin{cases}\n\\tilde{\\kappa}  \\text{if } \\tilde{\\kappa} \\ge \\kappa_n + \\mathrm{tol} \\\\\n\\kappa_n  \\text{if } \\tilde{\\kappa} \\le \\kappa_n - \\mathrm{tol} \\\\\n\\kappa_n  \\text{otherwise (tie region)}\n\\end{cases}\n$$\nThis tie-breaking prefers sticking in the ambiguous band to avoid chatter while preserving monotonicity. Enforce the monotonicity clamp $\\kappa_{n+1}^{\\text{rob}} \\leftarrow \\max(\\kappa_n,\\kappa_{n+1}^{\\text{rob}})$ to guarantee $\\kappa$ does not decrease.\n\nFor each update rule, compute at step $\\,n+1\\,$ the stress $\\,\\sigma_{n+1}\\,$ and the discrete damage dissipation increment\n$$\n\\Delta \\mathcal{D} \\approx Y_{n+\\theta}\\,\\Delta d, \\quad \\Delta d = d(\\kappa_{n+1})-d(\\kappa_n), \\quad Y_{n+\\theta} = \\tfrac{1}{2}\\,E\\,\\varepsilon_{n+1}^2,\n$$\nwith $\\,\\theta=\\tfrac{1}{1}\\,$ (midpoint is not required here; take $\\,Y\\,$ evaluated at $\\,n+1\\,$ for a conservative nonnegativity check since $Y\\ge 0$ and $\\Delta d\\ge 0$ should imply $\\Delta \\mathcal{D}\\ge 0$). Verify $\\Delta d \\ge 0$ numerically to within a damage tolerance $\\,t_{\\mathrm{diss}}\\,$ by checking $\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$.\n\nPeak strength sensitivity. For the given $\\,d(\\kappa)\\,$ and $\\,\\kappa=\\tilde{\\kappa}(\\varepsilon)=|\\varepsilon|\\,$ under monotone tension, the stress–strain relation reads\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\varepsilon}{\\kappa_0}\\big)^m\\Big),\n$$\nwhose peak occurs at\n$$\n\\varepsilon_{\\mathrm{p}} = \\kappa_0\\,m^{-1/m}.\n$$\nProvide a numerical study that includes cases with $\\,\\varepsilon_{n+1}\\,$ very close to $\\,\\varepsilon_{\\mathrm{p}}\\,$ so that floating-point round-off may flip the comparison outcome. Quantify the effect by reporting the discrete stress increment $\\,\\Delta \\sigma = \\sigma_{n+1}-\\sigma_{n}\\,$ for both update rules.\n\nImplementation requirements.\n\n- Use the operator-split algorithm: given $\\,(\\varepsilon_n,\\kappa_n)\\,$, compute $\\,\\tilde{\\kappa}(\\varepsilon_{n+1})\\,$, update $\\,\\kappa_{n+1}\\,$ with each rule, then compute $\\,d_{n+1}=d(\\kappa_{n+1})\\,$ and $\\,\\sigma_{n+1}\\,$.\n- Use the material parameters $E = 2.10 \\times 10^5$ pascals, $\\kappa_0 = 2.0 \\times 10^{-2}$, and $m = 2.0$.\n- Use the robust tolerances $a_{\\mathrm{tol}} = 1.0 \\times 10^{-12}$, $r_{\\mathrm{tol}} = 1.0 \\times 10^{-8}$, and damage positivity tolerance $t_{\\mathrm{diss}} = 1.0 \\times 10^{-14}$.\n- Treat strain as dimensionless and all stresses to be expressed in pascals; report $\\,\\Delta \\sigma\\,$ in pascals without any units in the output.\n\nTest suite. For each case $\\,i\\,$, the input is $\\,(\\varepsilon_n^{(i)},\\kappa_n^{(i)},\\varepsilon_{n+1}^{(i)})\\,$ and the outputs to be produced are\n$$\n\\big[\\kappa_{n+1}^{\\text{naive}},\\ \\kappa_{n+1}^{\\text{rob}},\\ \\Delta \\sigma^{\\text{naive}},\\ \\Delta \\sigma^{\\text{rob}},\\ \\mathrm{mon}^{\\text{naive}},\\ \\mathrm{mon}^{\\text{rob}},\\ \\mathrm{diss}^{\\text{naive}},\\ \\mathrm{diss}^{\\text{rob}}\\big],\n$$\nwhere $\\,\\mathrm{mon}\\,$ and $\\,\\mathrm{diss}\\,$ are boolean flags for monotonicity ($\\,\\kappa_{n+1}\\ge \\kappa_n\\,$) and discrete damage positivity ($\\,\\Delta d \\ge -t_{\\mathrm{diss}}\\,$). Use the following cases:\n\n- Case $1$ (happy path, clear increase): $\\varepsilon_n = 1.0 \\times 10^{-2}$, $\\kappa_n = 1.0 \\times 10^{-2}$, $\\varepsilon_{n+1} = 1.2 \\times 10^{-2}$.\n- Case $2$ (near peak, tiny upward difference below tolerance): Let $\\varepsilon_{\\mathrm{p}}=\\kappa_0\\,m^{-1/m}$. Use $\\varepsilon_n = 1.414213561 \\times 10^{-2}$, $\\kappa_n=\\varepsilon_n$, $\\varepsilon_{n+1} = 1.414213563 \\times 10^{-2}$.\n- Case $3$ (near peak, tiny downward difference): $\\varepsilon_n = 1.414213563 \\times 10^{-2}$, $\\kappa_n=\\varepsilon_n$, $\\varepsilon_{n+1} = 1.414213561 \\times 10^{-2}$.\n- Case $4$ (edge, near zero): $\\varepsilon_n = 0.0$, $\\kappa_n = 0.0$, $\\varepsilon_{n+1} = 1.0 \\times 10^{-16}$.\n- Case $5$ (large magnitude, relative tolerance dominant): $\\varepsilon_n = 1.0$, $\\kappa_n = 1.0$, $\\varepsilon_{n+1} = 1.000000005$.\n- Case $6$ (strong increase): $\\varepsilon_n = 5.0 \\times 10^{-1}$, $\\kappa_n = 5.0 \\times 10^{-1}$, $\\varepsilon_{n+1} = 6.0 \\times 10^{-1}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of eight entries as ordered above. For example, the output should look like\n$$\n[\\,[\\cdots 8\\ \\text{entries}\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\,].\n$$\nAll stresses must be expressed in pascals and all booleans must appear as programming-language boolean literals.",
            "solution": "The problem is well-posed and scientifically grounded. It presents a standard problem in computational damage mechanics, providing all necessary constitutive equations, parameters, and algorithms to perform a numerical study on the robustness of history variable updates. All provided information is self-contained and consistent.\n\nThe task is to implement and compare two different update schemes for the scalar history variable $\\kappa$ in a one-dimensional isotropic damage model. The model is defined within the framework of continuum mechanics, using an operator-split approach for the time integration of the internal variables.\n\nThe state of the material at time step $n$ is described by the strain $\\varepsilon_n$ and the history variable $\\kappa_n$. The history variable $\\kappa$ is a measure of the maximum strain magnitude experienced by the material and is constitutively required to be monotonically nondecreasing, i.e., $\\kappa_{n+1} \\ge \\kappa_n$.\n\nThe core constitutive relations are:\nThe Helmholtz free energy density, $\\psi$, is given by:\n$$\n\\psi(\\varepsilon, d) = \\tfrac{1}{2}\\,(1-d)\\,E\\,\\varepsilon^2\n$$\nwhere $E$ is the Young's modulus and $d$ is the scalar damage variable, $d \\in [0, 1)$.\n\nThe damage variable $d$ is a function of the history variable $\\kappa$:\n$$\nd(\\kappa) = 1 - \\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\nwith material parameters $\\kappa_0  0$ and $m \\ge 1$.\n\nThe Cauchy stress $\\sigma$ is derived from the free energy as $\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon}$:\n$$\n\\sigma(\\varepsilon, \\kappa) = (1 - d(\\kappa))\\,E\\,\\varepsilon = E\\,\\varepsilon\\,\\exp\\!\\Big(-\\big(\\tfrac{\\kappa}{\\kappa_0}\\big)^{m}\\Big)\n$$\n\nThe evolution of damage is governed by the update of $\\kappa$. A trial value for the history variable at step $n+1$ is defined based on the new strain $\\varepsilon_{n+1}$:\n$$\n\\tilde{\\kappa}(\\varepsilon_{n+1}) = |\\varepsilon_{n+1}|\n$$\nThis trial value is then used to update $\\kappa$ from its value at the previous step, $\\kappa_n$. The evolution must satisfy the Kuhn-Tucker conditions, which discretely imply $\\kappa_{n+1} = \\max(\\kappa_n, \\tilde{\\kappa}(\\varepsilon_{n+1}))$. The problem requires a comparison of a naive implementation of this update with a robust, tolerance-based version.\n\nThe algorithmic procedure for a single time increment from $n$ to $n+1$ is as follows:\n1.  Given the state $(\\varepsilon_n, \\kappa_n)$ and the new strain $\\varepsilon_{n+1}$.\n2.  Calculate the stress at the beginning of the increment: $\\sigma_n = \\sigma(\\varepsilon_n, \\kappa_n)$.\n3.  Calculate the trial history variable: $\\tilde{\\kappa}_{n+1} = |\\varepsilon_{n+1}|$.\n4.  Update the history variable to $\\kappa_{n+1}$ using two distinct rules:\n\n    a.  **Naive Update Rule**: This rule directly implements the `max` function, which is susceptible to floating-point errors when $\\tilde{\\kappa}_{n+1}$ is very close to $\\kappa_n$.\n        $$\n        \\kappa_{n+1}^{\\text{naive}} = \\max(\\kappa_n, \\tilde{\\kappa}_{n+1})\n        $$\n\n    b.  **Robust Update Rule**: This rule introduces a tolerance band around $\\kappa_n$ to handle ambiguous cases where $\\tilde{\\kappa}_{n+1} \\approx \\kappa_n$. It prevents damage evolution if the trial value is not sufficiently larger than the current history value. The tolerance is defined as:\n        $$\n        \\mathrm{tol} = a_{\\mathrm{tol}} + r_{\\mathrm{tol}}\\,\\max(|\\kappa_n|, |\\tilde{\\kappa}_{n+1}|)\n        $$\n        where $a_{\\text{tol}}$ is an absolute tolerance and $r_{\\text{tol}}$ is a relative tolerance. The update logic is specified as:\n        $$\n        \\kappa'_{n+1} =\n        \\begin{cases}\n        \\tilde{\\kappa}_{n+1}  \\text{if } \\tilde{\\kappa}_{n+1} \\ge \\kappa_n + \\mathrm{tol} \\\\\n        \\kappa_n            \\text{otherwise}\n        \\end{cases}\n        $$\n        A final monotonicity clamp is applied as requested, although the rule as defined for non-negative $\\kappa$ and $\\tilde{\\kappa}$ already ensures this:\n        $$\n        \\kappa_{n+1}^{\\text{rob}} = \\max(\\kappa_n, \\kappa'_{n+1})\n        $$\n\n5.  For each of the resulting history variables ($\\kappa_{n+1}^{\\text{naive}}$ and $\\kappa_{n+1}^{\\text{rob}}$), calculate the corresponding quantities at step $n+1$:\n    -   Damage: $d_{n+1} = d(\\kappa_{n+1})$.\n    -   Stress: $\\sigma_{n+1} = \\sigma(\\varepsilon_{n+1}, \\kappa_{n+1})$.\n    -   Stress increment: $\\Delta\\sigma = \\sigma_{n+1} - \\sigma_n$.\n\n6.  Finally, perform verification checks for each update rule:\n    -   **Monotonicity of $\\kappa$**: Check if $\\kappa_{n+1} \\ge \\kappa_n$. This is expected to be true for both rules by construction.\n    -   **Positivity of Dissipation**: The damage increment $\\Delta d = d_{n+1} - d_n$ must be non-negative. To account for floating-point inaccuracies, this is checked using a tolerance $t_{\\text{diss}}$: $\\Delta d \\ge -t_{\\text{diss}}$. This is also expected to be true since $d(\\kappa)$ is a monotonically increasing function and $\\kappa_{n+1} \\ge \\kappa_n$.\n\nThe implementation will apply this procedure to each test case provided, using the specified material parameters ($E = 2.1 \\times 10^5$, $\\kappa_0 = 2.0 \\times 10^{-2}$, $m = 2.0$) and tolerances ($a_{\\text{tol}} = 1.0 \\times 10^{-12}$, $r_{\\text{tol}} = 1.0 \\times 10^{-8}$, $t_{\\text{diss}} = 1.0 \\times 10^{-14}$). The eight specified output values will be computed for each case.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem by implementing and\n    comparing naive and robust update rules for the history variable.\n    \"\"\"\n    # Material and tolerance parameters from the problem statement\n    E = 2.10e5\n    kappa_0 = 2.0e-2\n    m = 2.0\n    a_tol = 1.0e-12\n    r_tol = 1.0e-8\n    t_diss = 1.0e-14\n\n    # --- Constitutive Functions ---\n    def damage_func(kappa):\n        if kappa  0: # kappa must be non-negative\n            return 0.0\n        return 1.0 - np.exp(-((kappa / kappa_0)**m))\n\n    def stress_func(epsilon, kappa):\n        d = damage_func(kappa)\n        return (1.0 - d) * E * epsilon\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (epsilon_n, kappa_n, epsilon_n+1)\n        (1.0e-2, 1.0e-2, 1.2e-2),\n        (1.414213561e-2, 1.414213561e-2, 1.414213563e-2),\n        (1.414213563e-2, 1.414213563e-2, 1.414213561e-2),\n        (0.0, 0.0, 1.0e-16),\n        (1.0, 1.0, 1.000000005),\n        (5.0e-1, 5.0e-1, 6.0e-1),\n    ]\n\n    results = []\n    \n    for eps_n, kappa_n, eps_n1 in test_cases:\n        \n        # --- Common calculations for the step ---\n        sigma_n = stress_func(eps_n, kappa_n)\n        d_n = damage_func(kappa_n)\n        tilde_kappa_n1 = abs(eps_n1)\n\n        # --- Naive Update ---\n        kappa_n1_naive = max(kappa_n, tilde_kappa_n1)\n        sigma_n1_naive = stress_func(eps_n1, kappa_n1_naive)\n        d_n1_naive = damage_func(kappa_n1_naive)\n        \n        delta_sigma_naive = sigma_n1_naive - sigma_n\n        mon_naive = kappa_n1_naive = kappa_n\n        delta_d_naive = d_n1_naive - d_n\n        diss_naive = delta_d_naive = -t_diss\n\n        # --- Robust Update ---\n        tol = a_tol + r_tol * max(abs(kappa_n), abs(tilde_kappa_n1))\n        \n        if tilde_kappa_n1 = kappa_n + tol:\n            kappa_n1_rob_intermediate = tilde_kappa_n1\n        else:\n            kappa_n1_rob_intermediate = kappa_n\n\n        # Apply monotonicity clamp as requested\n        kappa_n1_rob = max(kappa_n, kappa_n1_rob_intermediate)\n        \n        sigma_n1_rob = stress_func(eps_n1, kappa_n1_rob)\n        d_n1_rob = damage_func(kappa_n1_rob)\n        \n        delta_sigma_rob = sigma_n1_rob - sigma_n\n        mon_rob = kappa_n1_rob = kappa_n\n        delta_d_rob = d_n1_rob - d_n\n        diss_rob = delta_d_rob = -t_diss\n\n        # --- Assemble results for the current case ---\n        case_result = [\n            kappa_n1_naive,\n            kappa_n1_rob,\n            delta_sigma_naive,\n            delta_sigma_rob,\n            mon_naive,\n            mon_rob,\n            diss_naive,\n            diss_rob\n        ]\n        results.append(case_result)\n\n    # --- Final Output Formatting ---\n    # Create the string representation manually to match the required format\n    # `repr()` is used to get a standard string for floats and booleans.\n    outer_parts = []\n    for res_list in results:\n        inner_parts = [repr(x) for x in res_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "In computational mechanics, it is common to introduce numerical parameters, such as cutoffs, to prevent mathematical singularities and ensure stability. A key mark of a robust model is the ability to justify these parameters with physical or energetic reasoning, rather than choosing them arbitrarily. This exercise  provides a clear example of this principle by asking you to derive a maximum damage cutoff, $d_{\\max}$, based on a prescribed tolerance for the error in dissipated energy, elegantly linking a numerical necessity to a quantitative physical consequence.",
            "id": "3554731",
            "problem": "Consider a one-dimensional Representative Volume Element (RVE) of an isotropic damageable linear elastic solid with a scalar damage variable $d \\in [0,1]$. The elastic stiffness is degraded by a smooth degradation function $g(d)$ applied to the intact modulus $E0$, with Helmholtz free energy density\n$$\n\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,g(d)\\,E\\,\\varepsilon^{2},\n$$\nwhere $\\varepsilon$ is the small strain. Assume isothermal, quasi-static, rate-independent evolution and the standard definition of the thermodynamic force (energy release rate) conjugate to damage,\n$$\nY(\\varepsilon,d) := -\\frac{\\partial \\psi}{\\partial d}\\Big|_{\\varepsilon}.\n$$\nAdopt the widely used isotropic degradation $g(d) = (1-d)^{2}$ and consider a strain-controlled process where the total strain is imposed and held fixed at a level $\\bar{\\varepsilon}$ while damage progresses. In the limit $d \\to 1^{-}$ the stiffness $g(d)E \\to 0$, which leads to a loss of ellipticity and near-singular stiffness matrices in finite element computations. To prevent this, numerical implementations cap the damage variable at a cutoff $d_{\\max}  1$, thereby enforcing a residual stiffness fraction $g(d_{\\max}) > 0$.\n\nDefine the energetic error incurred by capping the damage near unity as the missed dissipated energy density\n$$\n\\Delta \\mathcal{D} = \\int_{d_{\\max}}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d,\n$$\nand define the total dissipated energy density for full damage (if allowed to reach $d=1$) as\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\int_{0}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d.\n$$\nIntroduce a user-prescribed admissible relative energetic error $0  \\alpha  1$ and require that the cutoff $d_{\\max}$ be chosen so that the relative error satisfies $\\Delta \\mathcal{D}/\\mathcal{D}_{\\mathrm{tot}} \\le \\alpha$.\n\nStarting only from the statements above, derive an explicit closed-form expression $d_{\\max}(\\alpha)$ that enforces the equality $\\Delta \\mathcal{D}/\\mathcal{D}_{\\mathrm{tot}} = \\alpha$ under the given assumptions. Your final answer must be a single analytic expression in terms of $\\alpha$ only. No rounding is required, and no units should be included in the final expression.",
            "solution": "The problem asks for an explicit closed-form expression for the damage cutoff, $d_{\\max}$, as a function of the admissible relative energetic error, $\\alpha$. The derivation begins by formalizing the quantities defined in the problem statement.\n\nThe Helmholtz free energy density is given as $\\psi(\\varepsilon,d) = \\tfrac{1}{2}\\,g(d)\\,E\\,\\varepsilon^{2}$. With the specific isotropic degradation function $g(d) = (1-d)^{2}$, the free energy density is:\n$$\n\\psi(\\varepsilon,d) = \\frac{1}{2}\\,(1-d)^{2}\\,E\\,\\varepsilon^{2}\n$$\nwhere $\\varepsilon$ is the strain, $d$ is the scalar damage variable, and $E>0$ is the intact Young's modulus.\n\nThe thermodynamic force conjugate to damage, also known as the energy release rate, is defined as $Y(\\varepsilon,d) := -\\frac{\\partial \\psi}{\\partial d}\\Big|_{\\varepsilon}$. We compute this derivative for the given free energy expression:\n$$\nY(\\varepsilon,d) = -\\frac{\\partial}{\\partial d} \\left( \\frac{1}{2}\\,(1-d)^{2}\\,E\\,\\varepsilon^{2} \\right)\n$$\nTreating $E$ and $\\varepsilon$ as constants with respect to $d$, we use the chain rule for differentiation:\n$$\nY(\\varepsilon,d) = - \\left( \\frac{1}{2}\\,E\\,\\varepsilon^{2} \\right) \\left( 2\\,(1-d) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}d}(1-d) \\right) = - \\left( \\frac{1}{2}\\,E\\,\\varepsilon^{2} \\right) \\left( 2\\,(1-d) \\cdot (-1) \\right)\n$$\nThis simplifies to:\n$$\nY(\\varepsilon,d) = E\\,\\varepsilon^{2}\\,(1-d)\n$$\nThe problem specifies a strain-controlled process where the strain is held fixed at a level $\\bar{\\varepsilon}$. Thus, the energy release rate during this process is:\n$$\nY(\\bar{\\varepsilon},d) = E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\n$$\n\nNext, we calculate the total dissipated energy density, $\\mathcal{D}_{\\mathrm{tot}}$, which is the integral of the energy release rate over the full range of damage from $d=0$ to $d=1$.\n$$\n\\mathcal{D}_{\\mathrm{tot}} = \\int_{0}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d = \\int_{0}^{1} E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\\,\\mathrm{d}d\n$$\nSince $E\\,\\bar{\\varepsilon}^{2}$ is constant with respect to the integration variable $d$, it can be moved outside the integral:\n$$\n\\mathcal{D}_{\\mathrm{tot}} = E\\,\\bar{\\varepsilon}^{2} \\int_{0}^{1} (1-d)\\,\\mathrm{d}d = E\\,\\bar{\\varepsilon}^{2} \\left[ d - \\frac{d^2}{2} \\right]_{0}^{1}\n$$\nEvaluating the definite integral at its limits:\n$$\n\\mathcal{D}_{\\mathrm{tot}} = E\\,\\bar{\\varepsilon}^{2} \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(0 - \\frac{0^2}{2}\\right) \\right) = E\\,\\bar{\\varepsilon}^{2} \\left( \\frac{1}{2} \\right) = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}\n$$\nThis result corresponds to the total strain energy density stored in the intact solid at strain $\\bar{\\varepsilon}$.\n\nNow, we calculate the missed dissipated energy density, $\\Delta \\mathcal{D}$, which is the energy not dissipated due to the damage variable being capped at $d_{\\max}$. This is the integral of the energy release rate from $d=d_{\\max}$ to $d=1$.\n$$\n\\Delta \\mathcal{D} = \\int_{d_{\\max}}^{1} Y(\\bar{\\varepsilon},d)\\,\\mathrm{d}d = \\int_{d_{\\max}}^{1} E\\,\\bar{\\varepsilon}^{2}\\,(1-d)\\,\\mathrm{d}d\n$$\nAgain, we factor out the constant term and integrate:\n$$\n\\Delta \\mathcal{D} = E\\,\\bar{\\varepsilon}^{2} \\int_{d_{\\max}}^{1} (1-d)\\,\\mathrm{d}d = E\\,\\bar{\\varepsilon}^{2} \\left[ d - \\frac{d^2}{2} \\right]_{d_{\\max}}^{1}\n$$\nEvaluating the definite integral:\n$$\n\\Delta \\mathcal{D} = E\\,\\bar{\\varepsilon}^{2} \\left( \\left(1 - \\frac{1^2}{2}\\right) - \\left(d_{\\max} - \\frac{d_{\\max}^2}{2}\\right) \\right) = E\\,\\bar{\\varepsilon}^{2} \\left( \\frac{1}{2} - d_{\\max} + \\frac{d_{\\max}^2}{2} \\right)\n$$\nThis expression can be rewritten by factoring out $\\frac{1}{2}$:\n$$\n\\Delta \\mathcal{D} = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} \\left( 1 - 2d_{\\max} + d_{\\max}^2 \\right) = \\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} (1-d_{\\max})^2\n$$\n\nFinally, we enforce the condition that the relative energetic error equals the prescribed value $\\alpha$:\n$$\n\\frac{\\Delta \\mathcal{D}}{\\mathcal{D}_{\\mathrm{tot}}} = \\alpha\n$$\nSubstituting the expressions derived for $\\Delta \\mathcal{D}$ and $\\mathcal{D}_{\\mathrm{tot}}$:\n$$\n\\frac{\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2} (1-d_{\\max})^2}{\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}} = \\alpha\n$$\nThe term $\\frac{1}{2}\\,E\\,\\bar{\\varepsilon}^{2}$ cancels, showing that the relationship is independent of the material modulus and the applied strain level. This leaves a simple algebraic equation relating $d_{\\max}$ and $\\alpha$:\n$$\n(1-d_{\\max})^2 = \\alpha\n$$\nTo solve for $d_{\\max}$, we take the square root of both sides:\n$$\n1 - d_{\\max} = \\pm\\sqrt{\\alpha}\n$$\nRearranging the equation for $d_{\\max}$ yields two potential solutions:\n$$\nd_{\\max} = 1 - \\sqrt{\\alpha} \\quad \\text{or} \\quad d_{\\max} = 1 + \\sqrt{\\alpha}\n$$\nWe use the problem's constraints to identify the physically valid solution. The damage cutoff $d_{\\max}$ must be less than $1$, and the error tolerance $\\alpha$ is in the range $0  \\alpha  1$. For $\\alpha$ in this range, its square root $\\sqrt{\\alpha}$ is a positive real number also between $0$ and $1$.\n1.  The solution $d_{\\max} = 1 + \\sqrt{\\alpha}$ would result in $d_{\\max} > 1$, which is physically inadmissible as the damage variable cannot exceed $1$.\n2.  The solution $d_{\\max} = 1 - \\sqrt{\\alpha}$ results in a value for $d_{\\max}$ such that $0  d_{\\max}  1$, which is consistent with all physical constraints of the problem.\n\nTherefore, the unique valid expression is $d_{\\max}(\\alpha) = 1 - \\sqrt{\\alpha}$.",
            "answer": "$$\n\\boxed{1 - \\sqrt{\\alpha}}\n$$"
        }
    ]
}