{
    "hands_on_practices": [
        {
            "introduction": "This foundational practice guides you through the construction of a one-dimensional finite element model for an SMA bar, starting directly from variational energy principles. You will implement a robust alternate-minimization algorithm, a common strategy for coupled field problems, providing a tangible link between thermodynamic theory and computational implementation. This hands-on exercise solidifies the understanding of how to discretize and solve the governing equations for materials with internal state variables .",
            "id": "3600550",
            "problem": "Consider a one-dimensional bar made of a Shape Memory Alloy (SMA). The bar has length $L$, constant cross-sectional area $A$, and is modeled under small strain kinematics. Let the axial displacement field be $u(x)$ with $x \\in [0,L]$, and the small strain be $\\varepsilon(x) = \\dfrac{du}{dx}$. The material has a linear elastic response with Young’s modulus $E$ in the austenitic phase and undergoes a uniaxial transformation strain of magnitude $\\varepsilon_{\\mathrm{L}}$ modulated by a martensite volume fraction $\\xi(x) \\in [0,1]$, so that the transformation strain is $\\varepsilon_{\\mathrm{tr}}(x) = \\varepsilon_{\\mathrm{L}} \\, \\xi(x)$. Include an isotropic hardening contribution with modulus $H \\ge 0$. The evolution of $\\xi$ is rate-independent with a constant transformation resistance characterized by a stress-like parameter $Y  0$.\n\nYou are tasked to derive, discretize, and implement a finite element solution based on the energetic variational formulation for a single quasi-static load increment. Use the following principle-based building blocks as the starting point (no other constitutive shortcuts are permitted in the problem statement):\n- The small-strain kinematics $\\varepsilon(x) = \\dfrac{du}{dx}$.\n- The quasi-static principle of minimum incremental potential energy for rate-independent systems: at a given load step with previous internal state $\\xi_{\\mathrm{prev}}(x)$, the pair $(u,\\xi)$ minimizes the incremental functional consisting of the Helmholtz free energy plus the rate-independent dissipation, minus the external work.\n- The Helmholtz free energy density consists of the elastic energy associated with the elastic strain $\\varepsilon - \\varepsilon_{\\mathrm{tr}}$ and an isotropic hardening energy depending on $\\xi$.\n- The rate-independent dissipation accumulated over the increment is the integral of a local dissipation density proportional to the absolute change $|\\xi - \\xi_{\\mathrm{prev}}|$.\n\nImpose essential (Dirichlet) boundary conditions $u(0) = 0$ and $u(L) = U$, with no applied tractions and no body forces. Discretize the bar with linear two-noded finite elements, using one constant internal variable $\\xi$ per element, and adopt an alternate-minimization algorithm per increment: for a fixed internal variable field $\\xi$, minimize with respect to $u$; for the updated displacement $u$, minimize locally and independently with respect to each element-wise constant $\\xi$ subject to the box constraint $\\xi \\in [0,1]$. Your implementation must:\n- Assemble the global linear system arising from the stationarity with respect to $u$ and enforce the Dirichlet boundary conditions.\n- Compute the element-averaged strain as the constant strain in each element.\n- Minimize locally the incremental functional with respect to each element’s $\\xi$ using only the principles stated above and general convex analysis ideas (in particular, treat the absolute-value dissipation consistently via subgradients), and enforce the bounds $\\xi \\in [0,1]$.\n- Iterate the two steps until convergence in both $u$ and $\\xi$ to a tight tolerance.\n\nAdopt the following data and units for all cases: $E$ in Pascals ($\\mathrm{Pa}$), $H$ in Pascals ($\\mathrm{Pa}$), $Y$ in Pascals ($\\mathrm{Pa}$), $L$ in meters ($\\mathrm{m}$), $U$ in meters ($\\mathrm{m}$), $\\varepsilon_{\\mathrm{L}}$ dimensionless, $A = 1$ in square meters ($\\mathrm{m}^2$). All computations and answers must be in the International System of Units (SI). The right-end reaction force should be reported in Newtons ($\\mathrm{N}$). Angles do not appear in this problem. The martensite fraction is dimensionless.\n\nTest suite (use these exactly as given):\n- Case A (happy path, partial transformation): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = 3.0 \\times 10^{-2}$, $A = 1.0$.\n- Case B (sub-threshold, no transformation): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = 1.0 \\times 10^{-2}$, $A = 1.0$.\n- Case C (boundary threshold): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = \\dfrac{Y}{E \\, \\varepsilon_{\\mathrm{L}}}$, $A = 1.0$.\n\nYour program must compute, for each case, the converged spatial average of the martensite fraction $\\bar{\\xi}$ over the bar (dimensionless) and the right-end reaction force $R$ (in $\\mathrm{N}$). The final output must be a single line containing a comma-separated list with results in the order\n$[\\bar{\\xi}^{\\mathrm{A}}, R^{\\mathrm{A}}, \\bar{\\xi}^{\\mathrm{B}}, R^{\\mathrm{B}}, \\bar{\\xi}^{\\mathrm{C}}, R^{\\mathrm{C}}]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$). Report all values as floating-point numbers. For $R$, the unit is $\\mathrm{N}$; for $\\bar{\\xi}$ it is dimensionless.",
            "solution": "The problem requires the derivation and implementation of a finite element solution for a one-dimensional Shape Memory Alloy (SMA) bar subjected to a quasi-static prescribed displacement. The formulation is based on the principle of minimum incremental potential energy for a rate-independent system.\n\n### **1. Theoretical Formulation**\n\nThe state of the system is described by the axial displacement field $u(x)$ and the martensite volume fraction field $\\xi(x)$. For a single quasi-static load increment starting from a virgin state ($u_{\\mathrm{prev}} = 0$, $\\xi_{\\mathrm{prev}} = 0$), we seek to find the pair $(u, \\xi)$ that minimizes the total incremental potential energy functional $\\Pi[u, \\xi]$. This functional is the sum of the Helmholtz free energy and the dissipated energy integrated over the bar's volume.\n\nThe small strain is given by the kinematic relation:\n$$ \\varepsilon(x) = \\frac{du}{dx} $$\n\nThe total strain $\\varepsilon$ is additively decomposed into an elastic part $\\varepsilon_e$ and a transformation part $\\varepsilon_{tr}$:\n$$ \\varepsilon = \\varepsilon_e + \\varepsilon_{tr} $$\nThe transformation strain is proportional to the martensite fraction $\\xi$:\n$$ \\varepsilon_{tr}(x) = \\varepsilon_{\\mathrm{L}} \\xi(x) $$\nwhere $\\varepsilon_{\\mathrm{L}}$ is the maximum transformation strain.\n\nThe Helmholtz free energy density, $\\psi$, comprises an elastic strain energy term and an isotropic hardening term:\n$$ \\psi(\\varepsilon, \\xi) = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{tr})^2 + \\frac{1}{2} H \\xi^2 = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{\\mathrm{L}} \\xi)^2 + \\frac{1}{2} H \\xi^2 $$\nwhere $E$ is the Young's modulus and $H$ is the hardening modulus.\n\nThe rate-independent dissipation density for the first load increment is given by $\\mathcal{D}(\\xi, \\xi_{\\mathrm{prev}=0}) = Y |\\xi - 0|$. Since the martensite fraction $\\xi$ is non-negative by definition ($\\xi \\in [0,1]$), this simplifies to:\n$$ \\mathcal{D}(\\xi) = Y \\xi $$\nwhere $Y$ is the constant transformation resistance.\n\nThe total incremental potential energy functional to be minimized is:\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\psi(\\varepsilon(x), \\xi(x)) + \\mathcal{D}(\\xi(x)) \\right] A \\, dx $$\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\frac{1}{2} E \\left( \\frac{du}{dx} - \\varepsilon_{\\mathrm{L}} \\xi \\right)^2 + \\frac{1}{2} H \\xi^2 + Y \\xi \\right] A \\, dx $$\nsubject to the boundary conditions $u(0) = 0$, $u(L) = U$, and the constraint $0 \\le \\xi(x) \\le 1$.\n\n### **2. Finite Element Discretization and Algorithmic Scheme**\n\nWe discretize the bar of length $L$ into $N$ linear two-noded finite elements, each of length $h=L/N$.\nThe displacement field $u(x)$ is approximated with piecewise linear functions, and the martensite fraction $\\xi(x)$ is taken to be piecewise constant, with a single value $\\xi_e$ for each element $e$.\n\nThe discretized functional is a sum over all elements:\n$$ \\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}) = \\sum_{e=1}^N \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\nwhere $\\mathbf{u}$ is the vector of nodal displacements, $\\boldsymbol{\\xi}$ is the vector of element-wise martensite fractions, and $\\varepsilon_e = (u_i - u_{i-1})/h$ is the constant strain in element $e$ (connecting nodes $i-1$ and $i$).\n\nWe employ an alternate-minimization (or staggered) algorithm to solve the coupled minimization problem. Starting with an initial guess (e.g., $\\boldsymbol{\\xi}^{(0)} = \\mathbf{0}$), we iterate two steps until convergence:\n\n#### **Step 1: Displacement Update (u-step)**\nFor a fixed martensite field $\\boldsymbol{\\xi} = \\boldsymbol{\\xi}^{(k)}$, we find the displacement field $\\mathbf{u}^{(k+1)}$ that minimizes $\\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}^{(k)})$. This is a standard linear elasticity problem with an additional force term arising from the transformation strain. Minimization leads to a linear system of equations $\\mathbf{K}\\mathbf{u} = \\mathbf{f}_{tr}$, where $\\mathbf{K}$ is the global stiffness matrix and $\\mathbf{f}_{tr}$ is the nodal force vector due to transformation strains.\n\nFor the free internal nodes $i=1, \\dots, N-1$, the equilibrium equations are:\n$$ \\frac{EA}{h} (-u_{i-1} + 2u_i - u_{i+1}) = EA\\varepsilon_{\\mathrm{L}}(\\xi_{i-1} - \\xi_i) $$\nwhere we adopt the convention that element $i$ connects nodes $i$ and $i+1$, and its martensite fraction is $\\xi_i$. After enforcing the boundary conditions $u_0=0$ and $u_N=U$, we solve the resulting linear system for the unknown internal nodal displacements $u_1, \\dots, u_{N-1}$.\n\n#### **Step 2: Internal Variable Update ($\\xi$-step)**\nFor a fixed displacement field $\\mathbf{u} = \\mathbf{u}^{(k+1)}$, the total functional decouples into $N$ independent minimization problems, one for each element's $\\xi_e$. We find $\\xi_e^{(k+1)}$ that minimizes the local energy:\n$$ \\pi_e(\\xi_e) = \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\nsubject to $0 \\le \\xi_e \\le 1$. The strain $\\varepsilon_e$ in each element is now a known quantity calculated from the updated displacement field $\\mathbf{u}^{(k+1)}$.\n\nThe function $\\pi_e(\\xi_e)$ is a convex quadratic in $\\xi_e$. Its unconstrained minimum is found by setting its derivative to zero:\n$$ \\frac{d\\pi_e}{d\\xi_e} = \\left[ E(\\varepsilon_e - \\varepsilon_L \\xi_e)(-\\varepsilon_L) + H\\xi_e + Y \\right] A h = 0 $$\n$$ (E \\varepsilon_{\\mathrm{L}}^2 + H)\\xi_e - (E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y) = 0 $$\nThe unconstrained minimizer is:\n$$ \\xi_e^* = \\frac{E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y}{E \\varepsilon_{\\mathrm{L}}^2 + H} $$\nThe solution subject to the constraint $\\xi_e \\in [0,1]$ is obtained by projecting $\\xi_e^*$ onto this interval:\n$$ \\xi_e^{(k+1)} = \\max(0, \\min(1, \\xi_e^*)) $$\n\nThe two steps are iterated until the changes in both $\\mathbf{u}$ and $\\boldsymbol{\\xi}$ fall below a chosen tolerance.\n\n### **3. Post-Processing**\n\nUpon convergence, we compute the required outputs:\n- **Average Martensite Fraction ($\\bar{\\xi}$)**: As elements have equal length, this is the arithmetic mean of the element values:\n$$ \\bar{\\xi} = \\frac{1}{N} \\sum_{e=1}^N \\xi_e $$\n- **Right-End Reaction Force ($R$)**: This is the force at the support $x=L$, which equals the axial stress $\\sigma_N$ in the last element ($e=N$) multiplied by the area $A$. The stress is given by the constitutive law:\n$$ R = A \\sigma_N = A E (\\varepsilon_N - \\varepsilon_{\\mathrm{L}} \\xi_N) $$\nwhere $\\varepsilon_N = (u_N - u_{N-1})/h$ is the strain in the last element.\n\nThis methodology provides a robust and physically-consistent framework for solving the specified problem. For the specific case of no body forces, the internal stress becomes uniform, leading to a uniform strain and martensite fraction field, simplifying the convergence behavior of the staggered scheme significantly.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(E, H, Y, eps_L, L, N, U, A):\n    \"\"\"\n    Solves the 1D SMA bar problem using an alternate minimization scheme.\n\n    Args:\n        E (float): Young's modulus [Pa]\n        H (float): Hardening modulus [Pa]\n        Y (float): Transformation resistance [Pa]\n        eps_L (float): Transformation strain magnitude [-]\n        L (float): Bar length [m]\n        N (int): Number of elements\n        U (float): Prescribed displacement at right end [m]\n        A (float): Cross-sectional area [m^2]\n\n    Returns:\n        tuple: A tuple containing:\n            - xi_avg (float): Spatially averaged martensite fraction.\n            - R (float): Reaction force at the right end [N].\n    \"\"\"\n    # Discretization parameter\n    h = L / N\n\n    # Initialize fields\n    # u: displacement vector of size N+1 for nodes 0 to N\n    u = np.linspace(0.0, U, N + 1)\n    # xi: martensite fraction vector of size N for elements 0 to N-1\n    xi = np.zeros(N)\n\n    # Alternate-Minimization (Staggered) Loop\n    max_iter = 100\n    tolerance = 1e-10\n    \n    for k in range(max_iter):\n        u_old = u.copy()\n        xi_old = xi.copy()\n\n        # Step 1: Minimize w.r.t. displacement u (for fixed xi)\n        # We solve a linear system K_free * u_free = f_eff for the free\n        # internal nodes u[1],...,u[N-1].\n        \n        num_free_dofs = N - 1\n        if num_free_dofs > 0:\n            # Stiffness matrix for free nodes (N-1 x N-1)\n            K_free = (E * A / h) * (np.diag(np.full(num_free_dofs, 2.0)) - \n                                   np.diag(np.ones(num_free_dofs - 1), 1) - \n                                   np.diag(np.ones(num_free_dofs - 1), -1))\n            \n            # Effective force vector for free nodes\n            f_eff = np.zeros(num_free_dofs)\n            const_f = E * A * eps_L\n\n            # Element indices are 0 to N-1. Node indices are 0 to N.\n            # Element e is between node e and e+1.\n            # Internal node i is between element i-1 and i.\n            # Loop for nodes 1 to N-2\n            for i in range(1, N - 1):\n                f_eff[i-1] = const_f * (xi[i-1] - xi[i])\n            \n            # Last free node (N-1) gets force from xi and BC at u[N]\n            f_eff[N-2] = const_f * (xi[N-2] - xi[N-1]) + (E * A / h) * U\n\n            # Solve for internal displacements\n            u_free = np.linalg.solve(K_free, f_eff)\n            u[1:N] = u_free\n\n        # Step 2: Minimize w.r.t. internal variable xi (for fixed u)\n        # This is a local update for each element, indexed 0 to N-1.\n        \n        xi_denom = E * eps_L**2 + H\n        if xi_denom == 0: xi_denom = 1.0 # Avoid division by zero, though unlikely with H>=0, E>0\n\n        for e in range(N):\n            strain_e = (u[e+1] - u[e]) / h\n            xi_num = E * strain_e * eps_L - Y\n            xi_star = xi_num / xi_denom\n            xi[e] = np.clip(xi_star, 0.0, 1.0)\n\n        # Step 3: Check for convergence\n        u_err = np.linalg.norm(u - u_old)\n        xi_err = np.linalg.norm(xi - xi_old)\n        \n        u_norm = np.linalg.norm(u)\n        xi_norm = np.linalg.norm(xi)\n        \n        u_rel_err = u_err / u_norm if u_norm > tolerance else u_err\n        xi_rel_err = xi_err / xi_norm if xi_norm > tolerance else xi_err\n\n        if u_rel_err  tolerance and xi_rel_err  tolerance:\n            break\n            \n    # Post-processing after convergence\n    xi_avg = np.mean(xi)\n    \n    # Reaction force R = A * sigma_N = A * E * (epsilon_N - eps_L * xi_N)\n    strain_last_elem = (u[N] - u[N-1]) / h\n    # The last element is indexed N-1\n    xi_last_elem = xi[N-1]\n    R = A * E * (strain_last_elem - eps_L * xi_last_elem)\n    \n    return xi_avg, R\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    params_A = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 3.0e-2, 'A': 1.0}\n    params_B = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 1.0e-2, 'A': 1.0}\n    \n    # For Case C, U is defined by a formula\n    E_C, Y_C, eps_L_C = 4.0e10, 5.0e7, 6.0e-2\n    U_C = Y_C / (E_C * eps_L_C)\n    params_C = {'E': E_C, 'H': 5.0e8, 'Y': Y_C, 'eps_L': eps_L_C, \n                'L': 1.0, 'N': 20, 'U': U_C, 'A': 1.0}\n    \n    test_cases = [params_A, params_B, params_C]\n    \n    results = []\n    for params in test_cases:\n        xi_avg, R = run_simulation(**params)\n        results.extend([xi_avg, R])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For implicit finite element solvers to converge rapidly, a precise linearization of the material's constitutive response is essential. This practice focuses on the derivation and implementation of the consistent algorithmic tangent modulus, $\\mathbb{C}_{\\mathrm{alg}}$, a cornerstone of modern computational inelasticity. By working through this exercise, you will understand how to ensure quadratic convergence in Newton-Raphson schemes by deriving the tangent directly from the discrete time-integration algorithm of the material's internal state .",
            "id": "3600551",
            "problem": "You are to derive and implement the one-dimensional consistent algorithmic tangent for a pseudoelastic Shape Memory Alloy (SMA) within computational solid mechanics, starting from thermodynamically consistent principles. The consistent algorithmic tangent is defined as the derivative of stress with respect to strain, computed from the exact incremental stress update algorithm when an internal variable (the martensitic volume fraction) evolves under a transformation consistency condition. Your derivation and implementation must be scientifically sound and follow fundamental thermodynamics and mechanics. The implementation must produce numerically testable results for a specified test suite.\n\nConsider a one-dimensional bar made of a pseudoelastic SMA subjected to imposed small strain increments. Let the Helmholtz free energy density be defined as\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi,\n$$\nwhere $E$ is the Young's modulus, $\\varepsilon$ is the total strain, $\\Lambda$ is the maximum transformation strain magnitude, $\\xi \\in [0,1]$ is the martensitic volume fraction, $H$ is the transformation hardening modulus, $s_0$ is a thermal coupling coefficient, $T$ is the absolute temperature, and $T_0$ is a reference temperature. The Cauchy stress is obtained from the standard thermodynamic relation\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right).\n$$\nThe thermodynamic driving force for forward transformation is defined as\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right),\n$$\nand forward transformation is activated when the consistency condition for the forward transformation function is enforced via Kuhn-Tucker conditions: the forward transformation function $f = r - R_{\\mathrm{fwd}}$ satisfies $f \\le 0$, forward transformation rate $\\dot{\\xi} \\ge 0$, and the complementarity condition $f \\, \\dot{\\xi} = 0$. When $\\dot{\\xi}  0$, consistency requires $f = 0$.\n\nYour tasks are:\n- From the given free energy, derive the stress update and the evolution of $\\xi$ under the forward transformation consistency condition when active, ensuring admissibility $\\xi \\in [0,1]$ and monotonicity for forward transformation increments. Explicitly derive the consistent algorithmic tangent, defined as $\\mathbb{C}_{\\mathrm{alg}} = \\dfrac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$, both in the elastic regime (no transformation) and in the active forward transformation regime (unsaturated).\n- Implement a robust one-dimensional update algorithm that, for a given strain $\\varepsilon$, temperature $T$, and previous martensitic fraction $\\xi^{\\mathrm{prev}}$, returns the updated stress $\\sigma$, updated fraction $\\xi$, and consistent algorithmic tangent $\\mathbb{C}_{\\mathrm{alg}}$ suitable for Newton-Raphson iterations in the Finite Element Method (FEM).\n- The update must follow:\n  - Compute a trial driving force $r$ using $\\xi^{\\mathrm{prev}}$.\n  - If $r \\le R_{\\mathrm{fwd}}$ or $\\xi^{\\mathrm{prev}} \\ge 1$, the step is elastic with $\\xi = \\xi^{\\mathrm{prev}}$, $\\sigma = E (\\varepsilon - \\Lambda \\xi)$, and $\\mathbb{C}_{\\mathrm{alg}} = E$.\n  - If $r  R_{\\mathrm{fwd}}$ and $\\xi^{\\mathrm{prev}}  1$, enforce consistency $r = R_{\\mathrm{fwd}}$ to obtain the updated $\\xi$; clamp to the admissible interval and enforce forward monotonicity $\\xi \\ge \\xi^{\\mathrm{prev}}$. If the update clamps at $\\xi=1$, set $\\mathbb{C}_{\\mathrm{alg}} = E$, otherwise use the derived active-regime $\\mathbb{C}_{\\mathrm{alg}}$.\n\nThe physical and numerical parameters to be used are:\n- $E = 70 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $\\Lambda = 0.06$,\n- $H = 0.5 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $s_0 = 5 \\times 10^{6}$ $\\,\\mathrm{Pa/K}$,\n- $R_{\\mathrm{fwd}} = 150 \\times 10^{6}$ $\\,\\mathrm{Pa}$,\n- $T_0 = 293$ $\\,\\mathrm{K}$.\n\nLet the absolute temperature unit be Kelvin and the strain be dimensionless. The stress and the algorithmic tangent must be expressed in Pascal ($\\,\\mathrm{Pa}$). The martensitic fraction $\\xi$ is dimensionless.\n\nTest suite:\n- Case $1$ (elastic regime): $\\varepsilon = 0.005$, $T = 293$, $\\xi^{\\mathrm{prev}} = 0.0$.\n- Case $2$ (active unsaturated transformation): $\\varepsilon = 0.02$, $T = 323$, $\\xi^{\\mathrm{prev}} = 0.0$.\n- Case $3$ (active with nonzero previous fraction): $\\varepsilon = 0.03$, $T = 373$, $\\xi^{\\mathrm{prev}} = 0.3$.\n- Case $4$ (saturated transformation): $\\varepsilon = 0.04$, $T = 493$, $\\xi^{\\mathrm{prev}} = 0.8$.\n\nYour program must compute, for each case, the triplet $[\\sigma, \\mathbb{C}_{\\mathrm{alg}}, \\xi]$, where $\\sigma$ and $\\mathbb{C}_{\\mathrm{alg}}$ are rounded to the nearest integer in $\\,\\mathrm{Pa}$, and $\\xi$ is rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list corresponding to one test case. For example: $[\\,[\\sigma_1, \\mathbb{C}_1, \\xi_1], [\\sigma_2, \\mathbb{C}_2, \\xi_2], [\\sigma_3, \\mathbb{C}_3, \\xi_3], [\\sigma_4, \\mathbb{C}_4, \\xi_4]\\,]$.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of continuum thermodynamics, specifically for modeling pseudoelastic Shape Memory Alloys (SMAs), and is a well-posed problem in computational solid mechanics. All necessary parameters and logical steps for the algorithm are provided, and there are no internal contradictions or factual inaccuracies.\n\nThe solution proceeds with the derivation of the necessary constitutive update equations and the consistent algorithmic tangent, followed by a summary of the numerical algorithm.\n\nThe state of the material is described by the total strain $\\varepsilon$, the martensitic volume fraction $\\xi$, and the absolute temperature $T$. The Helmholtz free energy density $\\psi$ is given by\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi\n$$\nwhere $E$ is the Young's modulus, $\\Lambda$ is the maximum transformation strain, $H$ is the transformation hardening modulus, $s_0$ is a thermomechanical coupling coefficient, and $T_0$ is a reference temperature.\n\nThe Cauchy stress $\\sigma$ and the thermodynamic driving force $r$ for phase transformation are derived from standard thermodynamic relations:\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right)\n$$\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right)\n$$\nForward transformation from austenite to martensite ($\\dot{\\xi}  0$) occurs when the driving force $r$ reaches a critical threshold $R_{\\mathrm{fwd}}$. This is governed by the Kuhn-Tucker conditions for the forward transformation function $f = r - R_{\\mathrm{fwd}}$:\n$$\nf \\le 0, \\quad \\dot{\\xi} \\ge 0, \\quad f \\dot{\\xi} = 0\n$$\nAdditionally, the martensitic fraction is physically constrained to the interval $\\xi \\in [0,1]$.\n\nThe constitutive update algorithm for a given strain increment proceeds as follows. Given the state $(\\xi^{\\mathrm{prev}})$ at the beginning of a step and the new total strain $\\varepsilon$ and temperature $T$, we first compute a trial driving force assuming no change in the martensitic fraction, i.e., with $\\xi = \\xi^{\\mathrm{prev}}$:\n$$\nr_{\\mathrm{trial}} = E \\Lambda (\\varepsilon - \\Lambda \\xi^{\\mathrm{prev}}) - H \\xi^{\\mathrm{prev}} + s_0(T - T_0)\n$$\n\nIf $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ or if the material is already fully martensitic ($\\xi^{\\mathrm{prev}} \\ge 1$), the step is elastic (no further transformation occurs). In this case, the martensitic fraction remains unchanged, $\\xi = \\xi^{\\mathrm{prev}}$.\n\nIf $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$ and $\\xi^{\\mathrm{prev}}  1$, a forward phase transformation occurs. The evolution of $\\xi$ is governed by the consistency condition, which dictates that during active transformation, the driving force must remain at the threshold value, i.e., $r = R_{\\mathrm{fwd}}$. We solve for the value of $\\xi$ that satisfies this condition:\n$$\nE \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right) = R_{\\mathrm{fwd}}\n$$\nThis is a linear equation for $\\xi$. Rearranging the terms to solve for $\\xi$ yields:\n$$\nE \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}} = (E \\Lambda^2 + H) \\xi\n$$\n$$\n\\xi_{\\mathrm{consistency}} = \\frac{E \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}}}{E \\Lambda^2 + H}\n$$\nThe final updated martensitic fraction $\\xi$ must respect the physical bounds, so we clamp the value at $\\xi=1$ if full transformation is reached. The monotonicity condition $\\xi \\ge \\xi^{\\mathrm{prev}}$ is implicitly satisfied by activating the transformation only when $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$. Thus, the updated fraction is:\n$$\n\\xi = \\min\\left(1, \\xi_{\\mathrm{consistency}}\\right)\n$$\n\nThe consistent algorithmic tangent $\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$ is required for implicit finite element solvers. It is the derivative of the stress at the end of the increment with respect to the total strain at the end of the increment.\n\n**1. Elastic and Saturated Regimes**\nIn the elastic regime, $\\xi$ is constant with respect to changes in $\\varepsilon$ (i.e., $\\xi = \\xi^{\\mathrm{prev}}$). The same holds for the saturated regime, where $\\xi$ is clamped at $1$. In both cases, $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0$.\nThe derivative of the stress is then straightforward:\n$$\n\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\left(\\varepsilon - \\Lambda \\xi\\right) \\right] = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E(1 - 0)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E\n$$\n\n**2. Active Unsaturated Transformation Regime**\nIn this regime, $\\xi$ evolves as a function of $\\varepsilon$ to maintain the consistency condition $r = R_{\\mathrm{fwd}}$. To find $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$, we differentiate the consistency condition with respect to $\\varepsilon$, treating $T$ as a fixed parameter for the differentiation:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\Lambda \\left(\\varepsilon - \\Lambda \\xi(\\varepsilon)\\right) - H \\xi(\\varepsilon) + s_0 \\left(T - T_0\\right) - R_{\\mathrm{fwd}} \\right] = 0\n$$\n$$\nE \\Lambda - E \\Lambda^2 \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} - H \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0\n$$\nSolving for $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$:\n$$\nE \\Lambda = \\left( E \\Lambda^2 + H \\right) \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} \\implies \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = \\frac{E \\Lambda}{E \\Lambda^2 + H}\n$$\nSubstituting this into the derivative of the stress equation:\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E \\left(1 - \\Lambda \\left(\\frac{E \\Lambda}{E \\Lambda^2 + H}\\right)\\right)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left( \\frac{E \\Lambda^2 + H - E \\Lambda^2}{E \\Lambda^2 + H} \\right) = \\frac{E H}{E \\Lambda^2 + H}\n$$\nThis is the consistent algorithmic tangent for the active, unsaturated transformation regime. It represents the reduced stiffness of the material during phase transformation.\n\nIn summary, the algorithm to be implemented is:\n1.  Calculate $r_{\\mathrm{trial}}$ using $\\varepsilon$, $T$, and $\\xi^{\\mathrm{prev}}$.\n2.  If $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ or $\\xi^{\\mathrm{prev}} \\ge 1$:\n    - $\\xi = \\xi^{\\mathrm{prev}}$\n    - $\\mathbb{C}_{\\mathrm{alg}} = E$\n3.  Otherwise (active transformation):\n    - Calculate $\\xi_{\\mathrm{consistency}}$ from the derived formula.\n    - Set $\\xi = \\min(1, \\xi_{\\mathrm{consistency}})$.\n    - If $\\xi = 1$ (saturated), $\\mathbb{C}_{\\mathrm{alg}} = E$.\n    - If $\\xi  1$ (unsaturated), $\\mathbb{C}_{\\mathrm{alg}} = \\frac{EH}{E \\Lambda^2 + H}$.\n4.  In all cases, calculate the final stress as $\\sigma = E(\\varepsilon - \\Lambda \\xi)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_sma_state(epsilon, T, xi_prev, params):\n    \"\"\"\n    Computes the updated stress, algorithmic tangent, and martensitic fraction for a 1D SMA.\n\n    Args:\n        epsilon (float): Total strain.\n        T (float): Absolute temperature in Kelvin.\n        xi_prev (float): Martensitic fraction from the previous step.\n        params (dict): Dictionary of material parameters.\n\n    Returns:\n        tuple: A tuple containing the updated stress (sigma, Pa), consistent\n               algorithmic tangent (C_alg, Pa), and martensitic fraction (xi).\n    \"\"\"\n    E = params['E']\n    Lambda = params['Lambda']\n    H = params['H']\n    s0 = params['s0']\n    R_fwd = params['R_fwd']\n    T0 = params['T0']\n\n    # Step 1: Compute trial driving force\n    r_trial = E * Lambda * (epsilon - Lambda * xi_prev) - H * xi_prev + s0 * (T - T0)\n    \n    # Step 2: Check for elastic response\n    if r_trial = R_fwd or xi_prev >= 1.0:\n        xi = xi_prev\n        C_alg = E\n        sigma = E * (epsilon - Lambda * xi)\n        return sigma, C_alg, xi\n    \n    # Step 3: Active transformation\n    else:\n        # Denominator for xi_consistency and C_alg calculation\n        denom = E * Lambda**2 + H\n        \n        # Calculate xi from the consistency condition\n        xi_consistency = (E * Lambda * epsilon + s0 * (T - T0) - R_fwd) / denom\n        \n        # Clamp xi to be at most 1.0. Monotonicity (xi >= xi_prev) is guaranteed\n        # by the r_trial > R_fwd condition.\n        xi = min(1.0, xi_consistency)\n        \n        # Calculate the consistent algorithmic tangent\n        if xi >= 1.0:\n            # Saturated transformation, tangent reverts to elastic modulus\n            C_alg = E\n        else:\n            # Active, unsaturated transformation\n            C_alg = (E * H) / denom\n        \n        # Calculate the final stress\n        sigma = E * (epsilon - Lambda * xi)\n        \n        return sigma, C_alg, xi\n\ndef solve():\n    \"\"\"\n    Main function to run the SMA model for the specified test suite.\n    \"\"\"\n    # Define physical and numerical parameters\n    params = {\n        'E': 70e9,       # Pa\n        'Lambda': 0.06,  # dimensionless\n        'H': 0.5e9,      # Pa\n        's0': 5e6,       # Pa/K\n        'R_fwd': 150e6,  # Pa\n        'T0': 293.0      # K\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.005, 293, 0.0), # Case 1 (elastic regime)\n        (0.02,  323, 0.0), # Case 2 (active unsaturated transformation)\n        (0.03,  373, 0.3), # Case 3 (active with nonzero previous fraction)\n        (0.04,  493, 0.8)  # Case 4 (saturated transformation)\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon_input, T_input, xi_prev_input = case\n        \n        # Get the updated state variables\n        sigma, C_alg, xi = update_sma_state(epsilon_input, T_input, xi_prev_input, params)\n        \n        # Round results to the specified precision\n        sigma_rounded = int(round(sigma))\n        C_alg_rounded = int(round(C_alg))\n        xi_rounded = round(xi, 6)\n        \n        results.append([sigma_rounded, C_alg_rounded, xi_rounded])\n\n    # Final print statement in the exact required format.\n    # The default str representation of a list includes spaces. We build the string manually.\n    results_str = ','.join([f\"[{s},{c},{x}]\" for s, c, x in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world applications often push materials into the large deformation regime, necessitating a move beyond small strain theories. This advanced practice introduces the finite strain formulation for SMAs, built upon the multiplicative decomposition of the deformation gradient, $\\mathbf{F} = \\mathbf{F}_{\\mathrm{e}} \\mathbf{F}_{\\mathrm{tr}}$. You will implement a constitutive update for a 3D model, gaining experience with non-linear kinematics, hyperelastic energy functions, and the computation of thermodynamic driving forces in a geometrically non-linear context .",
            "id": "3600572",
            "problem": "Consider a three-dimensional Shape Memory Alloy (SMA) undergoing finite strain deformations. Let the deformation gradient be denoted by $\\mathbf{F} \\in \\mathbb{R}^{3 \\times 3}$ with $\\det(\\mathbf{F})  0$. Assume a single crystallographic variant for martensitic transformation aligned with the first principal direction, and adopt a multiplicative decomposition of the deformation gradient into elastic and transformation parts:\n$$\n\\mathbf{F} = \\mathbf{F}_{\\mathrm{e}} \\, \\mathbf{F}_{\\mathrm{tr}},\n$$\nwhere $\\mathbf{F}_{\\mathrm{tr}}$ is the transformation stretch and $\\mathbf{F}_{\\mathrm{e}}$ is the elastic part. The internal variable is the martensitic volume fraction $\\xi \\in [0,1]$. The transformation stretch is prescribed to be isochoric and aligned with the first basis direction:\n$$\n\\mathbf{F}_{\\mathrm{tr}}(\\xi) = \\mathrm{diag}\\left(1 + \\beta \\, \\xi, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi}}\\right),\n$$\nwith parameter $\\beta  0$ so that $\\det\\left(\\mathbf{F}_{\\mathrm{tr}}(\\xi)\\right) = 1$ for all $\\xi \\in [0,1]$. The elastic response is modeled by a compressible Neo-Hookean free energy density per reference volume, expressed in terms of the elastic part $\\mathbf{F}_{\\mathrm{e}}$:\n$$\n\\psi_{\\mathrm{e}}(\\mathbf{F}_{\\mathrm{e}}) = \\frac{\\mu}{2}\\left(\\mathrm{tr}\\left(\\mathbf{b}_{\\mathrm{e}}\\right) - 3\\right) - \\mu \\ln J_{\\mathrm{e}} + \\frac{\\kappa}{2}\\left(\\ln J_{\\mathrm{e}}\\right)^2,\n$$\nwhere $\\mathbf{b}_{\\mathrm{e}} = \\mathbf{F}_{\\mathrm{e}} \\mathbf{F}_{\\mathrm{e}}^{\\mathsf{T}}$, $J_{\\mathrm{e}} = \\det(\\mathbf{F}_{\\mathrm{e}})$, $\\mu$ is the shear modulus, and $\\kappa$ is the bulk modulus. Assume a transformation hardening contribution to the free energy depending on temperature $T$:\n$$\n\\psi_{\\mathrm{tr}}(\\xi, T) = A \\, \\xi + \\frac{H}{2} \\, \\xi^2 + \\Theta \\, (T - T_0) \\, \\xi,\n$$\nwhere $A$ is a constant offset, $H  0$ is a hardening modulus, $\\Theta  0$ scales the thermal influence, and $T_0$ is a reference temperature. The total Helmholtz free energy is\n$$\n\\psi(\\mathbf{F}, \\xi, T) = \\psi_{\\mathrm{e}}\\!\\left(\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi)\\right) + \\psi_{\\mathrm{tr}}(\\xi, T),\n$$\nwith $\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi) = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr}}(\\xi)^{-1}$. The Clausius–Duhem inequality and Coleman–Noll procedure yield the Kirchhoff stress\n$$\n\\boldsymbol{\\tau} = \\mu\\left(\\mathbf{b}_{\\mathrm{e}} - \\mathbf{I}\\right) + \\kappa \\, \\ln J_{\\mathrm{e}} \\, \\mathbf{I},\n$$\nand the thermodynamic driving force conjugate to $\\xi$ defined by\n$$\np = -\\frac{\\partial \\psi}{\\partial \\xi}.\n$$\nAssume a rate-dependent transformation kinetics with forward and reverse thresholds:\n- Forward (austenite $\\rightarrow$ martensite): if $p  R_{\\mathrm{f}}$ then $\\dot{\\xi} = L_{\\mathrm{f}} \\left(p - R_{\\mathrm{f}}\\right)$,\n- Reverse (martensite $\\rightarrow$ austenite): if $p  -R_{\\mathrm{r}}$ then $\\dot{\\xi} = L_{\\mathrm{r}} \\left(p + R_{\\mathrm{r}}\\right)$,\nand $\\dot{\\xi} = 0$ otherwise, with $R_{\\mathrm{f}}  0$, $R_{\\mathrm{r}}  0$, $L_{\\mathrm{f}}  0$, and $L_{\\mathrm{r}}  0$. Over a discrete time step of size $\\Delta t$, the update is\n$$\n\\xi_{\\mathrm{new}} = \\mathrm{clip}\\left(\\xi_{\\mathrm{old}} + \\dot{\\xi} \\, \\Delta t, \\, 0, \\, 1\\right).\n$$\nAfter the update, compute the Cauchy stress $\\boldsymbol{\\sigma}$ from $\\boldsymbol{\\tau}$ via\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J_{\\mathrm{e}}} \\, \\boldsymbol{\\tau},\n$$\nand report the von Mises equivalent stress\n$$\n\\sigma_{\\mathrm{vM}} = \\sqrt{\\frac{3}{2} \\, \\boldsymbol{s}:\\boldsymbol{s}}, \\quad \\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3} \\, \\mathrm{tr}(\\boldsymbol{\\sigma}) \\, \\mathbf{I}.\n$$\nYour program must implement the above constitutive update in a single increment as follows:\n- Compute $\\psi(\\mathbf{F}, \\xi, T)$.\n- Approximate $p = -\\partial \\psi/\\partial \\xi$ numerically using a second-order centered finite difference with a small increment in $\\xi$:\n  $$\n  p \\approx -\\frac{\\psi(\\xi + \\varepsilon) - \\psi(\\xi - \\varepsilon)}{2 \\varepsilon},\n  $$\n  with appropriate one-sided differences near the bounds $\\xi = 0$ and $\\xi = 1$.\n- Update $\\xi$ using the kinetic law and clip to $[0,1]$.\n- Compute $\\boldsymbol{\\sigma}$ and $\\sigma_{\\mathrm{vM}}$ using the updated $\\xi$.\nAdopt the following material and kinetic parameters (use the stated physical units):\n- Shear modulus: $\\mu = 26000 \\ \\mathrm{MPa}$,\n- Bulk modulus: $\\kappa = 130000 \\ \\mathrm{MPa}$,\n- Transformation magnitude: $\\beta = 0.06$ (dimensionless),\n- Hardening modulus: $H = 75 \\ \\mathrm{MPa}$,\n- Offset: $A = 0 \\ \\mathrm{MPa}$,\n- Thermal coefficient: $\\Theta = 0.8 \\ \\mathrm{MPa/K}$,\n- Reference temperature: $T_0 = 298 \\ \\mathrm{K}$,\n- Forward threshold: $R_{\\mathrm{f}} = 5 \\ \\mathrm{MPa}$,\n- Reverse threshold: $R_{\\mathrm{r}} = 5 \\ \\mathrm{MPa}$,\n- Forward rate: $L_{\\mathrm{f}} = 0.15 \\ \\mathrm{(MPa \\cdot s)^{-1}}$,\n- Reverse rate: $L_{\\mathrm{r}} = 0.15 \\ \\mathrm{(MPa \\cdot s)^{-1}}$,\n- Time step: $\\Delta t = 1.0 \\ \\mathrm{s}$,\n- Numerical derivative increment: $\\varepsilon = 10^{-6}$ (dimensionless).\nTest Suite. For each case, the deformation gradient $\\mathbf{F}$ is prescribed (dimensionless), temperature $T$ in $\\mathrm{K}$, and initial martensitic fraction $\\xi_0$ (dimensionless):\n- Case $1$ (happy path, forward transformation likely): \n  $$\n  \\mathbf{F} = \\begin{bmatrix} 1.06  0.01  0 \\\\ 0  0.971  0 \\\\ 0  0  0.971 \\end{bmatrix}, \\quad T = 300, \\quad \\xi_0 = 0.\n  $$\n- Case $2$ (boundary, no transformation under no load at high temperature):\n  $$\n  \\mathbf{F} = \\mathbf{I}, \\quad T = 340, \\quad \\xi_0 = 0.\n  $$\n- Case $3$ (edge, strong forward tendency at low temperature):\n  $$\n  \\mathbf{F} = \\begin{bmatrix} 1.08  0  0 \\\\ 0  0.962  0 \\\\ 0  0  0.962 \\end{bmatrix}, \\quad T = 280, \\quad \\xi_0 = 0.3.\n  $$\n- Case $4$ (reverse transformation from fully transformed state at high temperature with near-unloaded configuration):\n  $$\n  \\mathbf{F} = \\begin{bmatrix} 0.995  0  0 \\\\ 0  1.005  0 \\\\ 0  0  1.0 \\end{bmatrix}, \\quad T = 360, \\quad \\xi_0 = 1.0.\n  $$\nRequired outputs. For each test case, output a pair $[\\xi_{\\mathrm{new}}, \\sigma_{\\mathrm{vM}}]$ where $\\xi_{\\mathrm{new}}$ is dimensionless and $\\sigma_{\\mathrm{vM}}$ is in $\\mathrm{MPa}$. Express $\\sigma_{\\mathrm{vM}}$ in $\\mathrm{MPa}$ and round both $\\xi_{\\mathrm{new}}$ and $\\sigma_{\\mathrm{vM}}$ to three decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\,[\\xi_1,\\sigma_{\\mathrm{vM},1}],\\,[\\xi_2,\\sigma_{\\mathrm{vM},2}],\\,\\ldots\\,]$.",
            "solution": "The user has provided a problem statement that is scientifically grounded, well-posed, and objective. It outlines a comprehensive constitutive model for a Shape Memory Alloy (SMA) undergoing finite strain, based on established principles of continuum mechanics. The model incorporates a multiplicative decomposition of the deformation gradient, a compressible Neo-Hookean elastic energy, and a phenomenological model for transformation hardening and kinetics. All necessary equations, material parameters, and boundary conditions for a single-step time increment are specified unambiguously. The provided test cases are physically plausible and serve to verify the implementation across different regimes of material behavior (forward transformation, reverse transformation, and no transformation). Therefore, the problem is deemed valid and a solution will be provided.\n\nThe solution framework is implemented as a single-step explicit constitutive update. The process begins with the initial state $(\\mathbf{F}, \\xi_0, T)$ and computes the final state $(\\xi_{\\mathrm{new}}, \\boldsymbol{\\sigma}_{\\mathrm{new}})$ over a time increment $\\Delta t$.\n\nThe total Helmholtz free energy density $\\psi$ is the sum of the elastic part $\\psi_{\\mathrm{e}}$ and the transformation part $\\psi_{\\mathrm{tr}}$:\n$$\n\\psi(\\mathbf{F}, \\xi, T) = \\psi_{\\mathrm{e}}\\!\\left(\\mathbf{F}_{\\mathrm{e}}(\\mathbf{F}, \\xi)\\right) + \\psi_{\\mathrm{tr}}(\\xi, T)\n$$\nThe elastic part depends on the elastic deformation gradient $\\mathbf{F}_{\\mathrm{e}} = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr}}(\\xi)^{-1}$, where $\\mathbf{F}_{\\mathrm{tr}}$ is the transformation stretch.\n$$\n\\psi_{\\mathrm{e}}(\\mathbf{F}_{\\mathrm{e}}) = \\frac{\\mu}{2}\\left(\\mathrm{tr}\\left(\\mathbf{b}_{\\mathrm{e}}\\right) - 3\\right) - \\mu \\ln J_{\\mathrm{e}} + \\frac{\\kappa}{2}\\left(\\ln J_{\\mathrm{e}}\\right)^2\n$$\nwith $\\mathbf{b}_{\\mathrm{e}} = \\mathbf{F}_{\\mathrm{e}} \\mathbf{F}_{\\mathrm{e}}^{\\mathsf{T}}$ and $J_{\\mathrm{e}} = \\det(\\mathbf{F}_{\\mathrm{e}})$. The transformation part is given by:\n$$\n\\psi_{\\mathrm{tr}}(\\xi, T) = A \\, \\xi + \\frac{H}{2} \\, \\xi^2 + \\Theta \\, (T - T_0) \\, \\xi\n$$\n\nThe core of the update procedure involves determining the evolution of the martensitic volume fraction $\\xi$. This is governed by the thermodynamic driving force $p$, conjugate to $\\xi$, defined as:\n$$\np = -\\frac{\\partial \\psi}{\\partial \\xi}\n$$\nThe implementation will follow the prescribed numerical algorithm to solve for the updated state.\n\n**Step 1: Compute the Thermodynamic Driving Force, $p$**\nThe driving force $p$ at the current state $(\\mathbf{F}, \\xi_0, T)$ is computed numerically. The problem specifies a finite difference approximation for the partial derivative. A second-order central difference is used for interior points, and appropriate one-sided differences are used at the boundaries $\\xi=0$ and $\\xi=1$ to maintain the physical domain of $\\xi$. Let $\\xi_{\\mathrm{old}} = \\xi_0$.\n\n- If $0  \\xi_{\\mathrm{old}}  1$:\n$$\np(\\xi_{\\mathrm{old}}) \\approx -\\frac{\\psi(\\xi_{\\mathrm{old}} + \\varepsilon) - \\psi(\\xi_{\\mathrm{old}} - \\varepsilon)}{2 \\varepsilon}\n$$\n- If $\\xi_{\\mathrm{old}} = 0$: A first-order forward difference is used.\n$$\np(0) \\approx -\\frac{\\psi(\\varepsilon) - \\psi(0)}{\\varepsilon}\n$$\n- If $\\xi_{\\mathrm{old}} = 1$: A first-order backward difference is used.\n$$\np(1) \\approx -\\frac{\\psi(1) - \\psi(1 - \\varepsilon)}{\\varepsilon}\n$$\nHere, $\\psi(\\xi)$ implies evaluation of the total free energy $\\psi(\\mathbf{F}, \\xi, T)$ for the given $\\mathbf{F}$ and $T$.\n\n**Step 2: Apply the Kinetic Law**\nThe rate of change of the martensitic volume fraction, $\\dot{\\xi}$, is determined by a rate-dependent kinetic law with specified forward ($R_{\\mathrm{f}}$) and reverse ($R_{\\mathrm{r}}$) thresholds.\n- Forward transformation (austenite to martensite): If $p  R_{\\mathrm{f}}$, then $\\dot{\\xi} = L_{\\mathrm{f}} (p - R_{\\mathrm{f}})$.\n- Reverse transformation (martensite to austenite): If $p  -R_{\\mathrm{r}}$, then $\\dot{\\xi} = L_{\\mathrm{r}} (p + R_{\\mathrm{r}})$.\n- Otherwise (within the elastic domain): $\\dot{\\xi} = 0$.\n\n**Step 3: Update the Martensitic Volume Fraction, $\\xi$**\nA forward Euler scheme is used to update $\\xi$ over the time step $\\Delta t$. The result is clipped to the physically meaningful range $[0, 1]$.\n$$\n\\xi_{\\mathrm{new}} = \\mathrm{clip}\\left(\\xi_{\\mathrm{old}} + \\dot{\\xi} \\, \\Delta t, \\, 0, \\, 1\\right)\n$$\n\n**Step 4: Compute Stress State**\nWith the updated martensitic fraction $\\xi_{\\mathrm{new}}$, the final stress state is calculated.\nFirst, the new elastic deformation gradient $\\mathbf{F}_{\\mathrm{e,new}}$ is found:\n$$\n\\mathbf{F}_{\\mathrm{tr,new}} = \\mathrm{diag}\\left(1 + \\beta \\, \\xi_{\\mathrm{new}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi_{\\mathrm{new}}}}, \\frac{1}{\\sqrt{1 + \\beta \\, \\xi_{\\mathrm{new}}}}\\right)\n$$\n$$\n\\mathbf{F}_{\\mathrm{e,new}} = \\mathbf{F}\\,\\mathbf{F}_{\\mathrm{tr,new}}^{-1}\n$$\nFrom this, the elastic left Cauchy-Green tensor $\\mathbf{b}_{\\mathrm{e,new}} = \\mathbf{F}_{\\mathrm{e,new}} \\mathbf{F}_{\\mathrm{e,new}}^{\\mathsf{T}}$ and the elastic volume change $J_{\\mathrm{e,new}} = \\det(\\mathbf{F}_{\\mathrm{e,new}})$ are computed.\n\nThe Kirchhoff stress tensor $\\boldsymbol{\\tau}$ is then calculated using the provided formula:\n$$\n\\boldsymbol{\\tau} = \\mu\\left(\\mathbf{b}_{\\mathrm{e,new}} - \\mathbf{I}\\right) + \\kappa \\, \\ln J_{\\mathrm{e,new}} \\, \\mathbf{I}\n$$\nThe Cauchy stress $\\boldsymbol{\\sigma}$ is obtained by scaling $\\boldsymbol{\\tau}$ by the determinant of the elastic deformation gradient. Since the transformation is isochoric ($\\det(\\mathbf{F}_{\\mathrm{tr}}) = 1$), we have $J = \\det(\\mathbf{F}) = \\det(\\mathbf{F}_{\\mathrm{e}}\\mathbf{F}_{\\mathrm{tr}}) = \\det(\\mathbf{F}_{\\mathrm{e}})\\det(\\mathbf{F}_{\\mathrm{tr}}) = J_{\\mathrm{e}}$. Thus, the relation is:\n$$\n\\boldsymbol{\\sigma} = \\frac{1}{J_{\\mathrm{e,new}}} \\boldsymbol{\\tau}\n$$\nFinally, the von Mises equivalent stress $\\sigma_{\\mathrm{vM}}$ is computed from the deviatoric part of the Cauchy stress, $\\boldsymbol{s}$:\n$$\n\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3} \\mathrm{tr}(\\boldsymbol{\\sigma}) \\mathbf{I}\n$$\n$$\n\\sigma_{\\mathrm{vM}} = \\sqrt{\\frac{3}{2} \\, \\boldsymbol{s}:\\boldsymbol{s}}\n$$\nwhere $\\boldsymbol{s}:\\boldsymbol{s}$ is the Frobenius inner product, equivalent to the sum of the squares of the elements of $\\boldsymbol{s}$.\n\nThis entire procedure is encapsulated in a Python script which iterates through the specified test cases, computes $[\\xi_{\\mathrm{new}}, \\sigma_{\\mathrm{vM}}]$ for each, and formats the output as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SMA constitutive update problem for the given test cases.\n    \"\"\"\n\n    # Material and kinetic parameters\n    params = {\n        'mu': 26000.0,       # Shear modulus [MPa]\n        'kappa': 130000.0,    # Bulk modulus [MPa]\n        'beta': 0.06,        # Transformation magnitude\n        'H': 75.0,           # Hardening modulus [MPa]\n        'A': 0.0,            # Offset [MPa]\n        'Theta': 0.8,        # Thermal coefficient [MPa/K]\n        'T0': 298.0,         # Reference temperature [K]\n        'R_f': 5.0,          # Forward threshold [MPa]\n        'R_r': 5.0,          # Reverse threshold [MPa]\n        'L_f': 0.15,         # Forward rate [(MPa*s)^-1]\n        'L_r': 0.15,         # Reverse rate [(MPa*s)^-1]\n        'dt': 1.0,           # Time step [s]\n        'eps': 1e-6,         # Numerical derivative increment\n    }\n\n    # Test suite\n    test_cases = [\n        # Case 1\n        (np.array([[1.06, 0.01, 0.0], [0.0, 0.971, 0.0], [0.0, 0.0, 0.971]]), 300.0, 0.0),\n        # Case 2\n        (np.identity(3), 340.0, 0.0),\n        # Case 3\n        (np.array([[1.08, 0.0, 0.0], [0.0, 0.962, 0.0], [0.0, 0.0, 0.962]]), 280.0, 0.3),\n        # Case 4\n        (np.array([[0.995, 0.0, 0.0], [0.0, 1.005, 0.0], [0.0, 0.0, 1.0]]), 360.0, 1.0),\n    ]\n\n    # --- Helper Functions ---\n\n    def get_F_tr_inv(xi, beta):\n        \"\"\"Computes the inverse of the transformation stretch tensor F_tr.\"\"\"\n        # Ensure xi is within [0, 1] to avoid math errors for sqrt\n        xi = np.clip(xi, 0, 1)\n        # Check for division by zero, although 1 + beta*xi > 0 for xi in [0,1] and beta > 0\n        term1 = 1.0 / (1.0 + beta * xi)\n        term2 = np.sqrt(1.0 + beta * xi)\n        return np.diag([term1, term2, term2])\n\n    def psi_e(F_e, mu, kappa):\n        \"\"\"Computes elastic free energy density.\"\"\"\n        J_e = np.linalg.det(F_e)\n        if J_e = 0: return np.inf # Physically inadmissible\n        b_e = F_e @ F_e.T\n        tr_be = np.trace(b_e)\n        log_Je = np.log(J_e)\n        return mu / 2.0 * (tr_be - 3.0) - mu * log_Je + kappa / 2.0 * log_Je**2\n\n    def psi_tr(xi, T, A, H, Theta, T0):\n        \"\"\"Computes transformation hardening free energy density.\"\"\"\n        return A * xi + H / 2.0 * xi**2 + Theta * (T - T0) * xi\n\n    def psi_total(xi, F, T, p):\n        \"\"\"Computes total Helmholtz free energy density.\"\"\"\n        F_tr_inv = get_F_tr_inv(xi, p['beta'])\n        F_e = F @ F_tr_inv\n        pe = psi_e(F_e, p['mu'], p['kappa'])\n        pt = psi_tr(xi, T, p['A'], p['H'], p['Theta'], p['T0'])\n        return pe + pt\n\n    def compute_update(F, T, xi_old, p):\n        \"\"\"Performs a single constitutive update.\"\"\"\n        # Step 1: Compute driving force p\n        eps = p['eps']\n        if xi_old == 0.0:\n            # Forward difference at lower bound\n            psi_eps = psi_total(xi_old + eps, F, T, p)\n            psi_0 = psi_total(xi_old, F, T, p)\n            p_force = -(psi_eps - psi_0) / eps\n        elif xi_old == 1.0:\n            # Backward difference at upper bound\n            psi_1_minus_eps = psi_total(xi_old - eps, F, T, p)\n            psi_1 = psi_total(xi_old, F, T, p)\n            p_force = -(psi_1 - psi_1_minus_eps) / eps\n        else:\n            # Central difference for interior points\n            psi_plus = psi_total(xi_old + eps, F, T, p)\n            psi_minus = psi_total(xi_old - eps, F, T, p)\n            p_force = -(psi_plus - psi_minus) / (2.0 * eps)\n\n        # Step 2: Apply kinetic law\n        xi_dot = 0.0\n        if p_force > p['R_f']:\n            xi_dot = p['L_f'] * (p_force - p['R_f'])\n        elif p_force  -p['R_r']:\n            xi_dot = p['L_r'] * (p_force + p['R_r'])\n        \n        # Step 3: Update xi\n        xi_new = xi_old + xi_dot * p['dt']\n        xi_new = np.clip(xi_new, 0.0, 1.0)\n\n        # Step 4: Compute stresses\n        F_tr_inv_new = get_F_tr_inv(xi_new, p['beta'])\n        F_e_new = F @ F_tr_inv_new\n        J_e_new = np.linalg.det(F_e_new)\n        b_e_new = F_e_new @ F_e_new.T\n        \n        tau = p['mu'] * (b_e_new - np.identity(3)) + p['kappa'] * np.log(J_e_new) * np.identity(3)\n        sigma = tau / J_e_new\n        \n        s = sigma - (np.trace(sigma) / 3.0) * np.identity(3)\n        s_colon_s = np.sum(s * s)\n        sigma_vM = np.sqrt(3.0 / 2.0 * s_colon_s)\n\n        return round(xi_new, 3), round(sigma_vM, 3)\n\n    # --- Main loop ---\n    results_str = []\n    for F_case, T_case, xi0_case in test_cases:\n        xi_new, sigma_vM = compute_update(F_case, T_case, xi0_case, params)\n        results_str.append(str([xi_new, sigma_vM]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}