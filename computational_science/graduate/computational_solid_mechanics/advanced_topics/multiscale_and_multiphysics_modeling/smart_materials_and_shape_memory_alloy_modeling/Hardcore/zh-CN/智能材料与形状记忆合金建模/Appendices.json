{
    "hands_on_practices": [
        {
            "introduction": "将热力学原理转化为可运行的有限元仿真是计算建模的核心步骤。本练习将指导您从变分原理出发，为一个一维形状记忆合金（SMA）杆构建一个完整的准静态模拟程序。通过亲手实现能量泛函的离散化和交替最小化求解算法，您将建立起理论与计算之间的坚实桥梁，并深入理解SMA相变过程中的能量最小化原则。",
            "id": "3600550",
            "problem": "考虑一根由形状记忆合金（SMA）制成的一维杆。该杆的长度为 $L$，横截面积为常数 $A$，并在小应变运动学下进行建模。设轴向位移场为 $u(x)$，其中 $x \\in [0,L]$，小应变为 $\\varepsilon(x) = \\dfrac{du}{dx}$。该材料在奥氏体相中具有线性弹性响应，杨氏模量为 $E$，并经历大小为 $\\varepsilon_{\\mathrm{L}}$ 的单轴相变应变，该应变由马氏体体积分数 $\\xi(x) \\in [0,1]$ 调制，因此相变应变为 $\\varepsilon_{\\mathrm{tr}}(x) = \\varepsilon_{\\mathrm{L}} \\, \\xi(x)$。包含一个模量为 $H \\ge 0$ 的各向同性硬化贡献。$\\xi$ 的演化是率无关的，具有一个由应力类参数 $Y  0$ 表征的恒定相变抗力。\n\n您的任务是基于能量变分法，为单个准静态载荷增量推导、离散化并实现一个有限元解。使用以下基于原理的构建模块作为起点（问题陈述中不允许使用其他本构捷径）：\n- 小应变运动学 $\\varepsilon(x) = \\dfrac{du}{dx}$。\n- 率无关系统的准静态最小增量势能原理：在给定的载荷步中，对于先前的内部状态 $\\xi_{\\mathrm{prev}}(x)$，对偶 $(u,\\xi)$ 使得由 Helmholtz 自由能加率无关耗散减去外力功组成的增量泛函最小化。\n- Helmholtz 自由能密度由与弹性应变 $\\varepsilon - \\varepsilon_{\\mathrm{tr}}$ 相关的弹性能和依赖于 $\\xi$ 的各向同性硬化能组成。\n- 在增量上累积的率无关耗散是与绝对变化量 $|\\xi - \\xi_{\\mathrm{prev}}|$ 成正比的局部耗散密度的积分。\n\n施加本质（Dirichlet）边界条件 $u(0) = 0$ 和 $u(L) = U$，无施加的面力和体力。使用线性的双节点有限元对杆进行离散化，每个单元使用一个恒定的内变量 $\\xi$，并对每个增量采用交替最小化算法：对于固定的内变量场 $\\xi$，对 $u$ 进行最小化；对于更新后的位移 $u$，在箱式约束 $\\xi \\in [0,1]$ 的条件下，对每个单元常数 $\\xi$ 进行局部和独立的最小化。您的实现必须：\n- 组装由关于 $u$ 的平稳性产生的全局线性系统，并施加 Dirichlet 边界条件。\n- 将单元应变计算为每个单元内的常数应变。\n- 仅使用上述原理和广义凸分析思想（特别是，通过次梯度一致地处理绝对值耗散），对每个单元的 $\\xi$ 局部最小化增量泛函，并强制执行边界 $\\xi \\in [0,1]$。\n- 迭代这两个步骤，直到 $u$ 和 $\\xi$ 都收敛到一个严格的容差。\n\n所有情况均采用以下数据和单位：$E$ 的单位为帕斯卡（$\\mathrm{Pa}$），$H$ 的单位为帕斯卡（$\\mathrm{Pa}$），$Y$ 的单位为帕斯卡（$\\mathrm{Pa}$），$L$ 的单位为米（$\\mathrm{m}$），$U$ 的单位为米（$\\mathrm{m}$），$\\varepsilon_{\\mathrm{L}}$ 无量纲，$A = 1$ 单位为平方米（$\\mathrm{m}^2$）。所有计算和答案必须使用国际单位制（SI）。右端反力应以牛顿（$\\mathrm{N}$）为单位报告。此问题不涉及角度。马氏体分数是无量纲的。\n\n测试套件（完全按照给定值使用）：\n- 情况 A（正常路径，部分相变）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = 3.0 \\times 10^{-2}$，$A = 1.0$。\n- 情况 B（亚阈值，无相变）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = 1.0 \\times 10^{-2}$，$A = 1.0$。\n- 情况 C（边界阈值）：$E = 4.0 \\times 10^{10}$，$H = 5.0 \\times 10^{8}$，$Y = 5.0 \\times 10^{7}$，$\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$，$L = 1.0$，$N = 20$，$U = \\dfrac{Y}{E \\, \\varepsilon_{\\mathrm{L}}}$，$A = 1.0$。\n\n您的程序必须为每种情况计算收敛后杆上的马氏体分数空间平均值 $\\bar{\\xi}$（无量纲）和右端反力 $R$（单位为 $\\mathrm{N}$）。最终输出必须是包含一个逗号分隔列表的单行，结果顺序为\n$[\\bar{\\xi}^{\\mathrm{A}}, R^{\\mathrm{A}}, \\bar{\\xi}^{\\mathrm{B}}, R^{\\mathrm{B}}, \\bar{\\xi}^{\\mathrm{C}}, R^{\\mathrm{C}}]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。所有值均以浮点数报告。对于 $R$，单位是 $\\mathrm{N}$；对于 $\\bar{\\xi}$，它是无量纲的。",
            "solution": "该问题要求为承受准静态指定位移的一维形状记忆合金（SMA）杆推导并实现一个有限元解。该公式基于率无关系统的最小增量势能原理。\n\n### **1. 理论公式**\n\n系统的状态由轴向位移场 $u(x)$ 和马氏体体积分数场 $\\xi(x)$ 描述。对于从初始状态（$u_{\\mathrm{prev}} = 0$, $\\xi_{\\mathrm{prev}} = 0$）开始的单个准静态载荷增量，我们寻求找到使总增量势能泛函 $\\Pi[u, \\xi]$ 最小化的对偶 $(u, \\xi)$。该泛函是在杆的体积上积分的 Helmholtz 自由能和耗散能之和。\n\n小应变由运动学关系给出：\n$$ \\varepsilon(x) = \\frac{du}{dx} $$\n\n总应变 $\\varepsilon$ 可加性地分解为弹性部分 $\\varepsilon_e$ 和相变部分 $\\varepsilon_{tr}$：\n$$ \\varepsilon = \\varepsilon_e + \\varepsilon_{tr} $$\n相变应变与马氏体分数 $\\xi$ 成正比：\n$$ \\varepsilon_{tr}(x) = \\varepsilon_{\\mathrm{L}} \\xi(x) $$\n其中 $\\varepsilon_{\\mathrm{L}}$ 是最大相变应变。\n\nHelmholtz 自由能密度 $\\psi$ 包括一个弹性应变能项和一个各向同性硬化项：\n$$ \\psi(\\varepsilon, \\xi) = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{tr})^2 + \\frac{1}{2} H \\xi^2 = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{\\mathrm{L}} \\xi)^2 + \\frac{1}{2} H \\xi^2 $$\n其中 $E$ 是杨氏模量，$H$ 是硬化模量。\n\n对于第一个载荷增量，率无关耗散密度由 $\\mathcal{D}(\\xi, \\xi_{\\mathrm{prev}=0}) = Y |\\xi - 0|$ 给出。由于根据定义，马氏体分数 $\\xi$ 是非负的（$\\xi \\in [0,1]$），这可以简化为：\n$$ \\mathcal{D}(\\xi) = Y \\xi $$\n其中 $Y$ 是恒定的相变抗力。\n\n待最小化的总增量势能泛函为：\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\psi(\\varepsilon(x), \\xi(x)) + \\mathcal{D}(\\xi(x)) \\right] A \\, dx $$\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\frac{1}{2} E \\left( \\frac{du}{dx} - \\varepsilon_{\\mathrm{L}} \\xi \\right)^2 + \\frac{1}{2} H \\xi^2 + Y \\xi \\right] A \\, dx $$\n受边界条件 $u(0) = 0$, $u(L) = U$ 和约束 $0 \\le \\xi(x) \\le 1$ 的限制。\n\n### **2. 有限元离散化与算法方案**\n\n我们将长度为 $L$ 的杆离散化为 $N$ 个线性的双节点有限元，每个单元的长度为 $h=L/N$。\n位移场 $u(x)$ 用分段线性函数近似，马氏体分数 $\\xi(x)$ 取为分段常数，每个单元 $e$ 对应一个单一值 $\\xi_e$。\n\n离散化后的泛函是所有单元的总和：\n$$ \\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}) = \\sum_{e=1}^N \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\n其中 $\\mathbf{u}$ 是节点位移向量，$\\boldsymbol{\\xi}$ 是单元马氏体分数向量，$\\varepsilon_e = (u_i - u_{i-1})/h$ 是单元 $e$（连接节点 $i-1$ 和 $i$）中的恒定应变。\n\n我们采用交替最小化（或交错）算法来解决这个耦合的最小化问题。从一个初始猜测（例如 $\\boldsymbol{\\xi}^{(0)} = \\mathbf{0}$）开始，我们迭代两个步骤直到收敛：\n\n#### **步骤 1：位移更新（u-步）**\n对于一个固定的马氏体场 $\\boldsymbol{\\xi} = \\boldsymbol{\\xi}^{(k)}$，我们找到使 $\\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}^{(k)})$ 最小化的位移场 $\\mathbf{u}^{(k+1)}$。这是一个标准的线性弹性问题，带有一个由相变应变产生的附加力项。最小化过程导出一个线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{f}_{tr}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{f}_{tr}$ 是由相变应变引起的节点力向量。\n\n对于自由的内部节点 $i=1, \\dots, N-1$，平衡方程为：\n$$ \\frac{EA}{h} (-u_{i-1} + 2u_i - u_{i+1}) = EA\\varepsilon_{\\mathrm{L}}(\\xi_i - \\xi_{i-1}) $$\n这里我们采用的约定是，单元 $i$ 连接节点 $i$ 和 $i+1$，其马氏体分数为 $\\xi_i$。在施加边界条件 $u_0=0$ 和 $u_N=U$ 后，我们求解得到的线性系统，以获得未知的内部节点位移 $u_1, \\dots, u_{N-1}$。\n\n#### **步骤 2：内变量更新（$\\xi$-步）**\n对于一个固定的位移场 $\\mathbf{u} = \\mathbf{u}^{(k+1)}$，总泛函解耦为 $N$ 个独立的最小化问题，每个问题对应一个单元的 $\\xi_e$。我们找到使局部能量最小化的 $\\xi_e^{(k+1)}$：\n$$ \\pi_e(\\xi_e) = \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\n受约束 $0 \\le \\xi_e \\le 1$。现在每个单元中的应变 $\\varepsilon_e$ 是一个已知量，由更新后的位移场 $\\mathbf{u}^{(k+1)}$ 计算得出。\n\n函数 $\\pi_e(\\xi_e)$ 是一个关于 $\\xi_e$ 的凸二次函数。其无约束最小值可以通过将其导数设为零来找到：\n$$ \\frac{d\\pi_e}{d\\xi_e} = \\left[ E(\\varepsilon_e - \\varepsilon_L \\xi_e)(-\\varepsilon_L) + H\\xi_e + Y \\right] A h = 0 $$\n$$ (E \\varepsilon_{\\mathrm{L}}^2 + H)\\xi_e - (E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y) = 0 $$\n无约束的最小化子是：\n$$ \\xi_e^* = \\frac{E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y}{E \\varepsilon_{\\mathrm{L}}^2 + H} $$\n受约束 $\\xi_e \\in [0,1]$ 的解是通过将 $\\xi_e^*$ 投影到这个区间上得到的：\n$$ \\xi_e^{(k+1)} = \\max(0, \\min(1, \\xi_e^*)) $$\n\n迭代这两个步骤，直到 $\\mathbf{u}$ 和 $\\boldsymbol{\\xi}$ 的变化都低于选定的容差。\n\n### **3. 后处理**\n\n收敛后，我们计算所需的输出：\n- **平均马氏体分数（$\\bar{\\xi}$）**：由于单元长度相等，这是单元值的算术平均值：\n$$ \\bar{\\xi} = \\frac{1}{N} \\sum_{e=1}^N \\xi_e $$\n- **右端反力（$R$）**：这是在支座 $x=L$ 处的力，它等于最后一个单元（$e=N$）中的轴向应力 $\\sigma_N$ 乘以面积 $A$。应力由本构定律给出：\n$$ R = A \\sigma_N = A E (\\varepsilon_N - \\varepsilon_{\\mathrm{L}} \\xi_N) $$\n其中 $\\varepsilon_N = (u_N - u_{N-1})/h$ 是最后一个单元中的应变。\n\n该方法为解决指定问题提供了一个鲁棒且物理上一致的框架。对于没有体力这种特殊情况，内部应力变得均匀，从而导致均匀的应变和马氏体分数场，这显著简化了交错格式的收敛行为。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(E, H, Y, eps_L, L, N, U, A):\n    \"\"\"\n    Solves the 1D SMA bar problem using an alternate minimization scheme.\n\n    Args:\n        E (float): Young's modulus [Pa]\n        H (float): Hardening modulus [Pa]\n        Y (float): Transformation resistance [Pa]\n        eps_L (float): Transformation strain magnitude [-]\n        L (float): Bar length [m]\n        N (int): Number of elements\n        U (float): Prescribed displacement at right end [m]\n        A (float): Cross-sectional area [m^2]\n\n    Returns:\n        tuple: A tuple containing:\n            - xi_avg (float): Spatially averaged martensite fraction.\n            - R (float): Reaction force at the right end [N].\n    \"\"\"\n    # Discretization parameter\n    h = L / N\n\n    # Initialize fields\n    # u: displacement vector of size N+1 for nodes 0 to N\n    u = np.linspace(0.0, U, N + 1)\n    # xi: martensite fraction vector of size N for elements 0 to N-1\n    xi = np.zeros(N)\n\n    # Alternate-Minimization (Staggered) Loop\n    max_iter = 100\n    tolerance = 1e-10\n    \n    for k in range(max_iter):\n        u_old = u.copy()\n        xi_old = xi.copy()\n\n        # Step 1: Minimize w.r.t. displacement u (for fixed xi)\n        # We solve a linear system K_free * u_free = f_eff for the free\n        # internal nodes u[1],...,u[N-1].\n        \n        num_free_dofs = N - 1\n        if num_free_dofs > 0:\n            # Stiffness matrix for free nodes (N-1 x N-1)\n            K_free = (E * A / h) * (np.diag(np.full(num_free_dofs, 2.0)) - \n                                   np.diag(np.ones(num_free_dofs - 1), 1) - \n                                   np.diag(np.ones(num_free_dofs - 1), -1))\n            \n            # Effective force vector for free nodes\n            f_eff = np.zeros(num_free_dofs)\n            const_f = E * A * eps_L\n\n            # Element indices are 0 to N-1. Node indices are 0 to N.\n            # Element e is between node e and e+1.\n            # Internal node i is between element i-1 and i.\n            # The force on node i is EA * eps_L * (xi_i - xi_{i-1})\n            # Loop for nodes 1 to N-2\n            for i in range(1, N - 1):\n                f_eff[i-1] = const_f * (xi[i] - xi[i-1])\n            \n            # Last free node (N-1) gets force from xi and BC at u[N]\n            f_eff[N-2] = const_f * (xi[N-1] - xi[N-2]) + (E * A / h) * U\n\n            # Solve for internal displacements\n            u_free = np.linalg.solve(K_free, f_eff)\n            u[1:N] = u_free\n\n        # Step 2: Minimize w.r.t. internal variable xi (for fixed u)\n        # This is a local update for each element, indexed 0 to N-1.\n        \n        xi_denom = E * eps_L**2 + H\n        if xi_denom == 0: xi_denom = 1.0 # Avoid division by zero, though unlikely with H>=0, E>0\n\n        for e in range(N):\n            strain_e = (u[e+1] - u[e]) / h\n            xi_num = E * strain_e * eps_L - Y\n            xi_star = xi_num / xi_denom\n            xi[e] = np.clip(xi_star, 0.0, 1.0)\n\n        # Step 3: Check for convergence\n        u_err = np.linalg.norm(u - u_old)\n        xi_err = np.linalg.norm(xi - xi_old)\n        \n        u_norm = np.linalg.norm(u)\n        xi_norm = np.linalg.norm(xi)\n        \n        u_rel_err = u_err / u_norm if u_norm > tolerance else u_err\n        xi_rel_err = xi_err / xi_norm if xi_norm > tolerance else xi_err\n\n        if u_rel_err  tolerance and xi_rel_err  tolerance:\n            break\n            \n    # Post-processing after convergence\n    xi_avg = np.mean(xi)\n    \n    # Reaction force R = A * sigma_N = A * E * (epsilon_N - eps_L * xi_N)\n    strain_last_elem = (u[N] - u[N-1]) / h\n    # The last element is indexed N-1\n    xi_last_elem = xi[N-1]\n    R = A * E * (strain_last_elem - eps_L * xi_last_elem)\n    \n    return xi_avg, R\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    params_A = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 3.0e-2, 'A': 1.0}\n    params_B = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 1.0e-2, 'A': 1.0}\n    \n    # For Case C, U is defined by a formula\n    E_C, Y_C, eps_L_C = 4.0e10, 5.0e7, 6.0e-2\n    U_C = Y_C / (E_C * eps_L_C)\n    params_C = {'E': E_C, 'H': 5.0e8, 'Y': Y_C, 'eps_L': eps_L_C, \n                'L': 1.0, 'N': 20, 'U': U_C, 'A': 1.0}\n    \n    test_cases = [params_A, params_B, params_C]\n    \n    results = []\n    for params in test_cases:\n        xi_avg, R = run_simulation(**params)\n        results.extend([xi_avg, R])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "对于复杂的隐式有限元分析，精确捕捉材料在相变过程中的刚度变化对求解器的收敛性能至关重要。本练习的核心是推导和实现“一致切线模量”，这是构建高效且具有二次收敛性的牛顿-拉弗森（Newton-Raphson）求解器的关键。通过这个实践，您将掌握在非弹性本构模型开发中的一项核心技术，这对于在高级有限元软件中开发用户材料子程序（UMAT）至关重要。",
            "id": "3600551",
            "problem": "您需要从热力学一致性原理出发，在计算固体力学框架内，推导并实现伪弹性形状记忆合金 (SMA) 的一维一致性算法切线。一致性算法切线定义为应力对应变的导数，当内变量（马氏体体积分数）在相变一致性条件下演化时，通过精确的增量应力更新算法计算得出。您的推导和实现必须在科学上是可靠的，并遵循基本的热力学和力学原理。实现必须为指定的测试套件生成可进行数值检验的结果。\n\n考虑一根由伪弹性 SMA 制成的一维杆，受到施加的小应变增量。设亥姆霍兹自由能密度定义为\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi,\n$$\n其中 $E$ 是杨氏模量，$\\varepsilon$ 是总应变，$\\Lambda$ 是最大相变应变幅值，$\\xi \\in [0,1]$ 是马氏体体积分数，$H$ 是相变硬化模量，$s_0$ 是热耦合系数，$T$ 是绝对温度，$T_0$ 是参考温度。柯西应力由标准热力学关系得到\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right).\n$$\n正向相变的热力学驱动力定义为\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right),\n$$\n当通过 Kuhn-Tucker 条件强制执行正向相变函数的一致性条件时，正向相变被激活：正向相变函数 $f = r - R_{\\mathrm{fwd}}$ 满足 $f \\le 0$，正向相变速率 $\\dot{\\xi} \\ge 0$，以及互补条件 $f \\, \\dot{\\xi} = 0$。当 $\\dot{\\xi}  0$ 时，一致性要求 $f = 0$。\n\n您的任务是：\n- 从给定的自由能出发，推导在正向相变一致性条件激活时的应力更新和 $\\xi$ 的演化，确保 $\\xi \\in [0,1]$ 的容许性以及正向相变增量的单调性。明确推导一致性算法切线，定义为 $\\mathbb{C}_{\\mathrm{alg}} = \\dfrac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$，包括在弹性区域（无相变）和激活的正向相变区域（非饱和）。\n- 实现一个稳健的一维更新算法，对于给定的应变 $\\varepsilon$、温度 $T$ 和前一步的马氏体分数 $\\xi^{\\mathrm{prev}}$，返回更新后的应力 $\\sigma$、更新后的分数 $\\xi$ 和一致性算法切线 $\\mathbb{C}_{\\mathrm{alg}}$，该切线适用于有限元法 (FEM) 中的 Newton-Raphson 迭代。\n- 更新必须遵循以下步骤：\n  - 使用 $\\xi^{\\mathrm{prev}}$ 计算试探驱动力 $r$。\n  - 如果 $r \\le R_{\\mathrm{fwd}}$ 或 $\\xi^{\\mathrm{prev}} \\ge 1$，则该步为弹性步，其中 $\\xi = \\xi^{\\mathrm{prev}}$，$\\sigma = E (\\varepsilon - \\Lambda \\xi)$，且 $\\mathbb{C}_{\\mathrm{alg}} = E$。\n  - 如果 $r  R_{\\mathrm{fwd}}$ 且 $\\xi^{\\mathrm{prev}}  1$，则强制执行一致性条件 $r = R_{\\mathrm{fwd}}$ 以获得更新后的 $\\xi$；将其限制在容许区间内，并强制执行正向单调性 $\\xi \\ge \\xi^{\\mathrm{prev}}$。如果更新值被限制在 $\\xi=1$，则设置 $\\mathbb{C}_{\\mathrm{alg}} = E$，否则使用推导出的激活区域的 $\\mathbb{C}_{\\mathrm{alg}}$。\n\n需要使用的物理和数值参数如下：\n- $E = 70 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $\\Lambda = 0.06$,\n- $H = 0.5 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $s_0 = 5 \\times 10^{6}$ $\\,\\mathrm{Pa/K}$,\n- $R_{\\mathrm{fwd}} = 150 \\times 10^{6}$ $\\,\\mathrm{Pa}$,\n- $T_0 = 293$ $\\,\\mathrm{K}$.\n\n设绝对温度单位为开尔文 (Kelvin)，应变为无量纲。应力和算法切线必须以帕斯卡 ($\\,\\mathrm{Pa}$) 表示。马氏体分数 $\\xi$ 是无量纲的。\n\n测试套件：\n- 情况 1（弹性区域）：$\\varepsilon = 0.005$, $T = 293$, $\\xi^{\\mathrm{prev}} = 0.0$。\n- 情况 2（激活的非饱和相变）：$\\varepsilon = 0.02$, $T = 323$, $\\xi^{\\mathrm{prev}} = 0.0$。\n- 情况 3（前一分数非零的激活相变）：$\\varepsilon = 0.03$, $T = 373$, $\\xi^{\\mathrm{prev}} = 0.3$。\n- 情况 4（饱和相变）：$\\varepsilon = 0.04$, $T = 493$, $\\xi^{\\mathrm{prev}} = 0.8$。\n\n您的程序必须为每种情况计算三元组 $[\\sigma, \\mathbb{C}_{\\mathrm{alg}}, \\xi]$，其中 $\\sigma$ 和 $\\mathbb{C}_{\\mathrm{alg}}$ 四舍五入到最近的整数（单位为 $\\,\\mathrm{Pa}$），$\\xi$ 四舍五入到六位小数。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素本身是对应一个测试用例的列表。例如：$[\\,[\\sigma_1, \\mathbb{C}_1, \\xi_1], [\\sigma_2, \\mathbb{C}_2, \\xi_2], [\\sigma_3, \\mathbb{C}_3, \\xi_3], [\\sigma_4, \\mathbb{C}_4, \\xi_4]\\,]$。",
            "solution": "问题陈述经评估有效。它在科学上基于连续介质热力学原理，特别是用于模拟伪弹性形状记忆合金 (SMA) 的模型，并且是计算固体力学中一个适定问题。算法所需的所有参数和逻辑步骤均已提供，不存在内部矛盾或事实错误。\n\n解决方案首先推导必要的本构更新方程和一致性算法切线，然后总结数值算法。\n\n材料的状态由总应变 $\\varepsilon$、马氏体体积分数 $\\xi$ 和绝对温度 $T$ 描述。亥姆霍兹自由能密度 $\\psi$ 由下式给出\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi\n$$\n其中 $E$ 是杨氏模量，$\\Lambda$ 是最大相变应变，$H$ 是相变硬化模量，$s_0$ 是热机耦合系数，$T_0$ 是参考温度。\n\n柯西应力 $\\sigma$ 和相变的热力学驱动力 $r$ 由标准热力学关系推导得出：\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right)\n$$\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right)\n$$\n当驱动力 $r$ 达到临界阈值 $R_{\\mathrm{fwd}}$ 时，发生从奥氏体到马氏体的正向相变 ($\\dot{\\xi}  0$)。这由正向相变函数 $f = r - R_{\\mathrm{fwd}}$ 的 Kuhn-Tucker 条件控制：\n$$\nf \\le 0, \\quad \\dot{\\xi} \\ge 0, \\quad f \\dot{\\xi} = 0\n$$\n此外，马氏体分数在物理上被限制在区间 $\\xi \\in [0,1]$ 内。\n\n对于给定的应变增量，本构更新算法按以下步骤进行。给定一个步长开始时的状态 $(\\xi^{\\mathrm{prev}})$ 以及新的总应变 $\\varepsilon$ 和温度 $T$，我们首先假设马氏体分数没有变化（即 $\\xi = \\xi^{\\mathrm{prev}}$），计算试探驱动力：\n$$\nr_{\\mathrm{trial}} = E \\Lambda (\\varepsilon - \\Lambda \\xi^{\\mathrm{prev}}) - H \\xi^{\\mathrm{prev}} + s_0(T - T_0)\n$$\n\n如果 $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ 或者材料已经完全是马氏体（$\\xi^{\\mathrm{prev}} \\ge 1$），则该步是弹性的（不发生进一步相变）。在这种情况下，马氏体分数保持不变，$\\xi = \\xi^{\\mathrm{prev}}$。\n\n如果 $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$ 且 $\\xi^{\\mathrm{prev}}  1$，则发生正向相变。$\\xi$ 的演化受一致性条件控制，该条件规定在激活相变期间，驱动力必须保持在阈值，即 $r = R_{\\mathrm{fwd}}$。我们求解满足此条件的 $\\xi$ 的值：\n$$\nE \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right) = R_{\\mathrm{fwd}}\n$$\n这是一个关于 $\\xi$ 的线性方程。重新整理各项以求解 $\\xi$ 可得：\n$$\nE \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}} = (E \\Lambda^2 + H) \\xi\n$$\n$$\n\\xi_{\\mathrm{consistency}} = \\frac{E \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}}}{E \\Lambda^2 + H}\n$$\n最终更新的马氏体分数 $\\xi$ 必须遵守物理边界，因此如果达到完全相变，我们将该值限制在 $\\xi=1$。单调性条件 $\\xi \\ge \\xi^{\\mathrm{prev}}$ 通过仅在 $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$ 时激活相变而隐式满足。因此，更新后的分数为：\n$$\n\\xi = \\min\\left(1, \\xi_{\\mathrm{consistency}}\\right)\n$$\n\n隐式有限元求解器需要一致性算法切线 $\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$。它是在增量结束时应力对增量结束时总应变的导数。\n\n**1. 弹性和饱和区域**\n在弹性区域，$\\xi$ 相对于 $\\varepsilon$ 的变化是恒定的（即 $\\xi = \\xi^{\\mathrm{prev}}$）。这同样适用于饱和区域，其中 $\\xi$ 被限制在 $1$。在这两种情况下，$\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0$。应力的导数就很直接：\n$$\n\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\left(\\varepsilon - \\Lambda \\xi\\right) \\right] = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E(1 - 0)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E\n$$\n\n**2. 激活的非饱和相变区域**\n在此区域中，$\\xi$ 作为 $\\varepsilon$ 的函数演化，以维持一致性条件 $r = R_{\\mathrm{fwd}}$。为了找到 $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$，我们对一致性条件关于 $\\varepsilon$ 求导，在求导过程中将 $T$ 视为固定参数：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\Lambda \\left(\\varepsilon - \\Lambda \\xi(\\varepsilon)\\right) - H \\xi(\\varepsilon) + s_0 \\left(T - T_0\\right) - R_{\\mathrm{fwd}} \\right] = 0\n$$\n$$\nE \\Lambda - E \\Lambda^2 \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} - H \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0\n$$\n求解 $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$：\n$$\nE \\Lambda = \\left( E \\Lambda^2 + H \\right) \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} \\implies \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = \\frac{E \\Lambda}{E \\Lambda^2 + H}\n$$\n将此代入应力方程的导数中：\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E \\left(1 - \\Lambda \\left(\\frac{E \\Lambda}{E \\Lambda^2 + H}\\right)\\right)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left( \\frac{E \\Lambda^2 + H - E \\Lambda^2}{E \\Lambda^2 + H} \\right) = \\frac{E H}{E \\Lambda^2 + H}\n$$\n这就是激活的非饱和相变区域的一致性算法切线。它代表了材料在相变期间刚度的降低。\n\n总而言之，要实现的算法如下：\n1.  使用 $\\varepsilon$、$T$ 和 $\\xi^{\\mathrm{prev}}$ 计算 $r_{\\mathrm{trial}}$。\n2.  如果 $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ 或 $\\xi^{\\mathrm{prev}} \\ge 1$：\n    - $\\xi = \\xi^{\\mathrm{prev}}$\n    - $\\mathbb{C}_{\\mathrm{alg}} = E$\n3.  否则（激活相变）：\n    - 根据推导的公式计算 $\\xi_{\\mathrm{consistency}}$。\n    - 设置 $\\xi = \\min(1, \\xi_{\\mathrm{consistency}})$。\n    - 如果 $\\xi = 1$（饱和），则 $\\mathbb{C}_{\\mathrm{alg}} = E$。\n    - 如果 $\\xi  1$（非饱和），则 $\\mathbb{C}_{\\mathrm{alg}} = \\frac{EH}{E \\Lambda^2 + H}$。\n4.  在所有情况下，计算最终应力为 $\\sigma = E(\\varepsilon - \\Lambda \\xi)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_sma_state(epsilon, T, xi_prev, params):\n    \"\"\"\n    Computes the updated stress, algorithmic tangent, and martensitic fraction for a 1D SMA.\n\n    Args:\n        epsilon (float): Total strain.\n        T (float): Absolute temperature in Kelvin.\n        xi_prev (float): Martensitic fraction from the previous step.\n        params (dict): Dictionary of material parameters.\n\n    Returns:\n        tuple: A tuple containing the updated stress (sigma, Pa), consistent\n               algorithmic tangent (C_alg, Pa), and martensitic fraction (xi).\n    \"\"\"\n    E = params['E']\n    Lambda = params['Lambda']\n    H = params['H']\n    s0 = params['s0']\n    R_fwd = params['R_fwd']\n    T0 = params['T0']\n\n    # Step 1: Compute trial driving force\n    r_trial = E * Lambda * (epsilon - Lambda * xi_prev) - H * xi_prev + s0 * (T - T0)\n    \n    # Step 2: Check for elastic response\n    if r_trial = R_fwd or xi_prev >= 1.0:\n        xi = xi_prev\n        C_alg = E\n        sigma = E * (epsilon - Lambda * xi)\n        return sigma, C_alg, xi\n    \n    # Step 3: Active transformation\n    else:\n        # Denominator for xi_consistency and C_alg calculation\n        denom = E * Lambda**2 + H\n        \n        # Calculate xi from the consistency condition\n        xi_consistency = (E * Lambda * epsilon + s0 * (T - T0) - R_fwd) / denom\n        \n        # Clamp xi to be at most 1.0. Monotonicity (xi >= xi_prev) is guaranteed\n        # by the r_trial > R_fwd condition.\n        xi = min(1.0, xi_consistency)\n        \n        # Calculate the consistent algorithmic tangent\n        if xi >= 1.0:\n            # Saturated transformation, tangent reverts to elastic modulus\n            C_alg = E\n        else:\n            # Active, unsaturated transformation\n            C_alg = (E * H) / denom\n        \n        # Calculate the final stress\n        sigma = E * (epsilon - Lambda * xi)\n        \n        return sigma, C_alg, xi\n\ndef solve():\n    \"\"\"\n    Main function to run the SMA model for the specified test suite.\n    \"\"\"\n    # Define physical and numerical parameters\n    params = {\n        'E': 70e9,       # Pa\n        'Lambda': 0.06,  # dimensionless\n        'H': 0.5e9,      # Pa\n        's0': 5e6,       # Pa/K\n        'R_fwd': 150e6,  # Pa\n        'T0': 293.0      # K\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.005, 293, 0.0), # Case 1 (elastic regime)\n        (0.02,  323, 0.0), # Case 2 (active unsaturated transformation)\n        (0.03,  373, 0.3), # Case 3 (active with nonzero previous fraction)\n        (0.04,  493, 0.8)  # Case 4 (saturated transformation)\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon_input, T_input, xi_prev_input = case\n        \n        # Get the updated state variables\n        sigma, C_alg, xi = update_sma_state(epsilon_input, T_input, xi_prev_input, params)\n        \n        # Round results to the specified precision\n        sigma_rounded = int(round(sigma))\n        C_alg_rounded = int(round(C_alg))\n        xi_rounded = round(xi, 6)\n        \n        results.append([sigma_rounded, C_alg_rounded, xi_rounded])\n\n    # Final print statement in the exact required format.\n    # The default str representation of a list includes spaces. We build the string manually.\n    results_str = ','.join([f\"[{s},{c},{x}]\" for s, c, x in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "不同的数值求解方案在实现简易性和计算精度之间存在权衡。本练习将直接比较一种相对简单的算子分裂格式与一种更精确的整体求解（Monolithic）方法在模拟SMA非比例热机耦合路径时的表现。通过量化两种算法在计算能量耗散上的“算法误差”，您将学会批判性地评估数值方法的物理保真度，这是计算科学中验证和确认模型的关键技能。",
            "id": "3600557",
            "problem": "考虑一个一维伪弹性形状记忆合金（SMA）模型，该模型包含一个代表马氏体分数的单一内部变量。目标是在非比例热机路径下，比较算子分裂策略与整体牛顿-拉夫逊（Newton–Raphson）策略，并根据耗散的时间积分来量化算法误差。此比较必须作为一个完整的、可运行的程序来实现。\n\n该模型由以下要素和约束定义，这些都必须被遵守并从第一性原理推导得出。\n\n1. 令总应变为 $\\epsilon$，柯西应力为 $\\sigma$，温度为 $T$，马氏体分数为 $\\xi \\in [0,1]$，其中 $0$ 表示完全奥氏体状态，$1$ 表示完全马氏体状态。令相变应变标度为 $\\epsilon_L  0$。\n\n2. 单位参考体积的亥姆霍兹自由能由一个二次弹性部分、一个考虑了弹性模量混合法则和线性相变应变的项，外加一个内部变量的线性硬化贡献来近似。令奥氏体相的杨氏模量为 $E_A$，马氏体相的杨氏模量为 $E_M$。模量的混合法则是 $E(\\xi) = E_A (1 - \\xi) + E_M \\xi$。在小应变下，应力为 $\\sigma = E(\\xi)\\left(\\epsilon - \\epsilon_L \\xi \\right)$。\n\n3. 正向相变的热力学驱动力由自由能对 $\\xi$ 的负偏导数推导得出。在这个简化的伪弹性设置中，采用\n$$\nY(\\sigma,\\xi) = \\sigma \\epsilon_L - H \\xi,\n$$\n其中 $H  0$ 是一个类硬化参数，单位为应力。\n\n4. 相变准则由一个与速率无关的一致性条件和一个依赖于温度的阈值给出。定义阈值为\n$$\nR(T) = R_0 + b \\left(T - T_0\\right),\n$$\n其中 $R_00$，$b$ 为常数，$T_0$ 为参考温度。当屈服函数 $F = Y(\\sigma,\\xi) - R(T)$ 满足 $F \\ge 0$ 且内部变量增加时，发生正向相变，同时受限于约束条件 $\\dot{\\xi} \\ge 0$，$\\xi \\in [0,1]$，以及库恩-塔克（Kuhn–Tucker）条件 $F \\le 0$，$\\dot{\\xi} \\ge 0$，$F \\dot{\\xi} = 0$。\n\n5. 在忽略潜热演变的等温条件下，克劳修斯-杜亥姆（Clausius–Duhem）不等式意味着机械耗散率非负。对于速率无关的相变，瞬时耗散率可以一致地取为\n$$\n\\mathcal{D}(t) = R\\!\\left(T(t)\\right)\\, \\dot{\\xi}(t),\n$$\n当正向相变激活时，而在非激活时 $\\mathcal{D}(t) = 0$。在时间区间 $[0, t_{\\mathrm{end}}]$ 上的耗散积分为\n$$\n\\int_{0}^{t_{\\mathrm{end}}} \\mathcal{D}(t)\\, dt = \\int_{0}^{t_{\\mathrm{end}}} R\\!\\left(T(t)\\right)\\, \\dot{\\xi}(t)\\, dt,\n$$\n在时间步长为 $\\Delta t$ 的有界变差离散化下，该积分计算为总和 $\\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}-\\xi_n\\right)$。\n\n6. 对于从 $t_n$ 到 $t_{n+1}$ 的每个时间步，必须在给定输入 $\\epsilon_{n+1}$ 和 $T_{n+1}$ 的情况下实现两种增量更新策略：\n- 算子分裂（OS）：使用一种序贯近似法，其中试探应力根据前一时刻的内部变量计算得出，$ \\sigma^{\\mathrm{tr}} = E(\\xi_n)\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_n\\right)$。然后评估 $F^{\\mathrm{tr}} = \\sigma^{\\mathrm{tr}} \\epsilon_L - H \\xi_n - R(T_{n+1})$。如果 $F^{\\mathrm{tr}} \\le 0$，则设置 $\\xi_{n+1} = \\xi_n$；否则，通过强制 $Y(\\sigma^{\\mathrm{tr}}, \\xi_{n+1}) = R(T_{n+1})$ 来更新 $\\xi_{n+1}$，其中 $\\sigma^{\\mathrm{tr}}$ 保持固定，即求解 $\\sigma^{\\mathrm{tr}} \\epsilon_L - H \\xi_{n+1} = R(T_{n+1})$ 以得到 $\\xi_{n+1}$，并将其限制在 $[\\xi_n,1]$ 区间内。最后，计算 $\\sigma_{n+1} = E(\\xi_{n+1})\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}\\right)$。\n- 整体牛顿-拉夫逊法（MN）：在时间步结束时求解耦合系统。首先，形成无相变的弹性预测值，$\\sigma^{E} = E(\\xi_n)\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_n\\right)$，并检验 $F^{E} = \\sigma^{E} \\epsilon_L - H \\xi_n - R(T_{n+1})$。如果 $F^{E} \\le 0$，则设置 $\\xi_{n+1} = \\xi_n$ 和 $\\sigma_{n+1} = \\sigma^{E}$。如果 $F^{E}  0$，则同时求解 $(\\sigma_{n+1},\\xi_{n+1})$，强制满足应力关系和激活的一致性条件：\n$$\n\\begin{cases}\n\\sigma_{n+1} - E(\\xi_{n+1})\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}\\right) = 0, \\\\\n\\sigma_{n+1}\\epsilon_L - H \\xi_{n+1} - R(T_{n+1}) = 0,\n\\end{cases}\n$$\n其中 $\\xi_{n+1} \\in [\\xi_n,1]$，通过对 $\\xi_{n+1}$ 使用牛顿-拉夫逊法，并利用应力关系消去 $\\sigma_{n+1}$ 来求解第二个方程。\n\n7. 需要报告的算法误差是在整个路径上由 OS 和 MN 计算的总耗散之间的绝对差值，\n$$\n\\mathrm{error} = \\left| \\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}^{\\mathrm{OS}} - \\xi_{n}^{\\mathrm{OS}}\\right) - \\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}^{\\mathrm{MN}} - \\xi_{n}^{\\mathrm{MN}}\\right) \\right|.\n$$\n\n所有量必须用以下一致的单位表示：应力和模量单位为兆帕（$\\mathrm{MPa}$），温度单位为开尔文（$\\mathrm{K}$），时间单位为秒（$\\mathrm{s}$），应变为无量纲，耗散积分单位为 $\\mathrm{MPa}$（假设小应变下，单位体积的能量，其中 $\\mathrm{MPa}$ 等同于 $\\mathrm{MJ}/\\mathrm{m}^3$）。最终程序必须将每个测试用例的算法误差打印为方括号内以逗号分隔的十进制数列表，例如 $[\\dots]$，每个数字四舍五入到六位小数，单位为 $\\mathrm{MPa}$。\n\n使用以下参数值，这些值必须嵌入在程序中：\n- $E_A = 30000~\\mathrm{MPa}$，\n- $E_M = 20000~\\mathrm{MPa}$，\n- $\\epsilon_L = 0.05$，\n- $H = 200~\\mathrm{MPa}$，\n- $R_0 = 40~\\mathrm{MPa}$，\n- $b = 0.05~\\mathrm{MPa}/\\mathrm{K}$，\n- $T_0 = 300~\\mathrm{K}$。\n\n实现一个具有均匀时间步长 $\\Delta t$ 和 $N$ 个步骤的离散时间模拟。为保证数值稳定性，将 $\\xi$ 限制在区间 $[0,1]$ 内，并强制单调性 $\\xi_{n+1} \\ge \\xi_n$。\n\n测试套件。对于以下三个非比例热机路径中的每一个，计算如上定义的算法误差。在所有情况下，取初始条件 $\\xi_0 = 0$ 和 $\\epsilon_0 = 0$，初始温度等于指定路径在 $t=0$ 时的值。使用均匀的时间步长 $\\Delta t$ 和结束时间 $t_{\\mathrm{end}}$。\n\n- 情况 A（带振荡温度的通用非比例斜坡加载）：\n  - $\\Delta t = 0.5~\\mathrm{s}$，$t_{\\mathrm{end}} = 10~\\mathrm{s}$，$N = t_{\\mathrm{end}}/\\Delta t$，\n  - 应变路径：$\\epsilon(t) = 0.01 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$，\n  - 温度路径：$T(t) = 300 + 50 \\cdot \\sin\\!\\left( \\pi t / t_{\\mathrm{end}} \\right)$。\n\n- 情况 B（高温下接近阈值的斜坡加载）：\n  - $\\Delta t = 0.5~\\mathrm{s}$，$t_{\\mathrm{end}} = 10~\\mathrm{s}$，$N = t_{\\mathrm{end}}/\\Delta t$，\n  - 应变路径：$\\epsilon(t) = 0.004 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$，\n  - 温度路径：$T(t) = 350$（恒定）。\n\n- 情况 C（随温度降低而加速的应变）：\n  - $\\Delta t = 0.5~\\mathrm{s}$，$t_{\\mathrm{end}} = 10~\\mathrm{s}$，$N = t_{\\mathrm{end}}/\\Delta t$，\n  - 应变路径：$\\epsilon(t) = 0.012 \\cdot \\left( t / t_{\\mathrm{end}} \\right)^2$，\n  - 温度路径：$T(t) = 340 - 40 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果，顺序为 $[$情况 A 结果, 情况 B 结果, 情况 C 结果$]$，例如 $[\\alpha,\\beta,\\gamma]$，其中每个条目是表示该情况下算法误差（单位为 $\\mathrm{MPa}$）并四舍五入到六位小数的十进制数。不应打印任何其他文本。",
            "solution": "该问题要求对一个一维、速率无关的伪弹性形状记忆合金（SMA）模型的两种数值积分策略进行比较。该比较通过在指定热机路径上计算出的总耗散的算法误差来量化。这两种策略分别是算子分裂（OS）方案和整体牛顿-拉夫逊（MN）方案。解决方案涉及实现这两种算法，并将它们应用于三个不同的非比例加载情况。\n\n首先，我们对本构模型进行形式化处理。在任意时刻 $t$，材料的状态由总应变 $\\epsilon(t)$、温度 $T(t)$ 和单一内部变量马氏体体积分数 $\\xi(t)$ 描述。柯西应力 $\\sigma(t)$ 是一个状态函数。\n材料属性由奥氏体（$E_A$）和马氏体（$E_M$）相的杨氏模量、相变应变标度（$\\epsilon_L$）、硬化参数（$H$）以及定义相变阈值的参数（$R_0$、$b$、$T_0$）给出。\n\n应力 $\\sigma$ 通过以下本构关系与应变 $\\epsilon$ 和马氏体分数 $\\xi$ 相关联：\n$$\n\\sigma = E(\\xi)\\left(\\epsilon - \\epsilon_L \\xi \\right)\n$$\n其中 $E(\\xi)$ 是通过混合法则得到的有效杨氏模量：\n$$\nE(\\xi) = E_A (1 - \\xi) + E_M \\xi = E_A + (E_M - E_A)\\xi\n$$\n\n从奥氏体到马氏体的相变由热力学驱动力 $Y$ 和一个与温度相关的阈值 $R(T)$ 控制。当屈服函数 $F$ 为零时，正向相变（$\\dot{\\xi}  0$）被激活。该模型由以下各项指定：\n- 驱动力：$Y(\\sigma, \\xi) = \\sigma \\epsilon_L - H \\xi$\n- 相变阈值：$R(T) = R_0 + b (T-T_0)$\n- 屈服函数：$F(\\sigma, \\xi, T) = Y(\\sigma, \\xi) - R(T)$\n$\\xi$ 的演化遵循标准库恩-塔克（Kuhn–Tucker）加载/卸载条件，用于速率无关的塑性：\n$$\n\\dot{\\xi} \\ge 0, \\quad F \\le 0, \\quad F \\dot{\\xi} = 0\n$$\n同时受物理约束 $\\xi \\in [0, 1]$ 的限制。条件 $\\dot{\\xi} \\ge 0$ 意味着只考虑正向相变（奥氏体到马氏体），而忽略逆向相变。\n\n该问题在先验已知的 $\\epsilon(t)$ 和 $T(t)$ 加载路径上增量求解，路径被离散化为从 $t_0=0$ 到 $t_{\\mathrm{end}} = N\\Delta t$ 的 $N$ 个时间步。对于从 $t_n$ 到 $t_{n+1}$ 的每一步，我们已知状态 $(\\sigma_n, \\xi_n)$，并给定控制量 $(\\epsilon_{n+1}, T_{n+1})$。我们必须计算更新后的状态 $(\\sigma_{n+1}, \\xi_{n+1})$。\n\n问题的核心在于为这种增量更新实现两种不同的算法。\n\n1.  **算子分裂（OS）算法：** 这是一种两步预测-校正方案。\n    -   **弹性预测器：** 首先，通过假设整个增量是弹性的（即 $\\xi$ 保持其上一步的值 $\\xi_n$ 不变）来计算试探状态。试探应力 $\\sigma^{\\mathrm{tr}}$ 为：\n        $$\n        \\sigma^{\\mathrm{tr}} = E(\\xi_n) (\\epsilon_{n+1} - \\epsilon_L \\xi_n)\n        $$\n    -   **相变检查：** 在此试探状态下评估屈服函数：\n        $$\n        F^{\\mathrm{tr}} = Y(\\sigma^{\\mathrm{tr}}, \\xi_n) - R(T_{n+1}) = \\sigma^{\\mathrm{tr}}\\epsilon_L - H\\xi_n - R(T_{n+1})\n        $$\n        如果 $F^{\\mathrm{tr}} \\le 0$，则假设正确，该步为弹性步，我们设置 $\\xi_{n+1} = \\xi_n$ 和 $\\sigma_{n+1} = \\sigma^{\\mathrm{tr}}$。\n    -   **塑性校正器：** 如果 $F^{\\mathrm{tr}}  0$，则发生相变。按照规定，OS方案通过使用固定的试探应力 $\\sigma^{\\mathrm{tr}}$ 强制执行一致性条件 $Y(\\sigma, \\xi) = R(T)$ 来更新内部变量 $\\xi$。这为 $\\xi_{n+1}$ 提供了一个显式更新规则：\n        $$\n        \\sigma^{\\mathrm{tr}}\\epsilon_L - H\\xi_{n+1} = R(T_{n+1}) \\implies \\xi_{n+1} = \\frac{\\sigma^{\\mathrm{tr}}\\epsilon_L - R(T_{n+1})}{H}\n        $$\n        然后将结果限制在 $[\\xi_n, 1]$ 区间内以满足约束。最后，使用更新后的 $\\xi_{n+1}$ 和完整的本构定律重新计算应力 $\\sigma_{n+1}$，确保其与最终状态变量一致。\n\n2.  **整体牛顿-拉夫逊（MN）算法：** 该方案同时求解整个方程组，确保步末状态满足所有控制方程。\n    -   **弹性预测器：** 试探步骤与 OS 情况相同。如果试探屈服函数 $F^{\\mathrm{tr}} \\le 0$，则该步为弹性步。\n    -   **非弹性校正器：** 如果 $F^{\\mathrm{tr}}  0$，则发生相变，状态 $(\\sigma_{n+1}, \\xi_{n+1})$ 必须在时间 $t_{n+1}$ 同时满足应力-应变关系和一致性条件：\n        $$\n        \\begin{cases}\n        \\sigma_{n+1} - E(\\xi_{n+1})(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}) = 0 \\\\\n        \\sigma_{n+1}\\epsilon_L - H \\xi_{n+1} - R(T_{n+1}) = 0\n        \\end{cases}\n        $$\n        将第一个方程代入第二个方程以消除 $\\sigma_{n+1}$，得到关于未知数 $\\xi_{n+1}$ 的单个非线性标量残差方程 $g(\\xi_{n+1}) = 0$：\n        $$\n        g(\\xi) = \\left[ E(\\xi)(\\epsilon_{n+1} - \\epsilon_L \\xi) \\right] \\epsilon_L - H \\xi - R(T_{n+1}) = 0\n        $$\n        此方程使用牛顿-拉夫逊法进行数值求解。迭代更新为 $\\xi^{(k+1)} = \\xi^{(k)} - g(\\xi^{(k)})/g'(\\xi^{(k)})$，初始猜测为 $\\xi^{(0)} = \\xi_n$。导数 $g'(\\xi) = dg/d\\xi$ 为：\n        $$\n        g'(\\xi) = \\left[ E'(\\xi)(\\epsilon_{n+1} - \\epsilon_L \\xi) - E(\\xi)\\epsilon_L \\right]\\epsilon_L - H\n        $$\n        其中 $E'(\\xi) = E_M-E_A$。迭代持续进行，直到残差 $|g(\\xi^{(k)})|$ 低于规定的容差。然后将得到的根限制在区间 $[\\xi_n, 1]$ 内。\n\n路径上的总耗散通过对每一步的增量耗散求和来计算：\n$$\n\\text{Dissipation} = \\sum_{n=0}^{N-1} R(T_{n+1}) (\\xi_{n+1} - \\xi_n)\n$$\n这个值为 OS 和 MN 解都进行计算，分别表示为 $D^{\\mathrm{OS}}$ 和 $D^{\\mathrm{MN}}$。算法误差是这两个总和之间的绝对差：\n$$\n\\mathrm{error} = | D^{\\mathrm{OS}} - D^{\\mathrm{MN}} |\n$$\n\n实现将包含一个主循环，该循环遍历指定的测试用例。对于每个用例，一个仿真驱动函数将按时间步进，在每一步施加规定的应变和温度。在此循环内，调用 OS 和 MN 更新例程，以根据各自的方案演化状态。计算并累积各自的耗散增量。最后，计算总累积耗散的绝对差值并存储。所有三个用例的结果被收集并以指定格式打印出来。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SMA modeling problem for all test cases.\n    \"\"\"\n    # Material and model parameters\n    params = {\n        'E_A': 30000.0,   # MPa\n        'E_M': 20000.0,   # MPa\n        'eps_L': 0.05,    # dimensionless\n        'H': 200.0,       # MPa\n        'R_0': 40.0,      # MPa\n        'b': 0.05,        # MPa/K\n        'T_0': 300.0,     # K\n    }\n\n    t_end = 10.0\n    dt = 0.5\n    N_steps = int(t_end / dt)\n    time_points = np.linspace(0, t_end, N_steps + 1)\n\n    # Test Case Definitions\n    test_cases = [\n        {\n            'name': 'A',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.01 * (t / t_end),\n            'T_path': lambda t: 300.0 + 50.0 * np.sin(np.pi * t / t_end)\n        },\n        {\n            'name': 'B',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.004 * (t / t_end),\n            'T_path': lambda t: 350.0\n        },\n        {\n            'name': 'C',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.012 * (t / t_end)**2,\n            'T_path': lambda t: 340.0 - 40.0 * (t / t_end)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_simulation(case, params)\n        results.append(error)\n    \n    # Format and print the final output\n    print(f\"[{','.join(['{:.6f}'.format(r) for r in results])}]\")\n\ndef E_mod(xi, params):\n    \"\"\"Calculates Young's modulus E(xi).\"\"\"\n    return params['E_A'] * (1 - xi) + params['E_M'] * xi\n\ndef R_thresh(T, params):\n    \"\"\"Calculates transformation threshold R(T).\"\"\"\n    return params['R_0'] + params['b'] * (T - params['T_0'])\n\ndef os_update(xi_n, eps_np1, T_np1, params):\n    \"\"\"Performs one update step using Operator Splitting (OS).\"\"\"\n    # Elastic predictor step\n    E_n = E_mod(xi_n, params)\n    sigma_tr = E_n * (eps_np1 - params['eps_L'] * xi_n)\n    \n    # Check for transformation\n    R_np1 = R_thresh(T_np1, params)\n    F_tr = sigma_tr * params['eps_L'] - params['H'] * xi_n - R_np1\n\n    if F_tr = 0:\n        # Elastic step\n        return xi_n\n    else:\n        # Plastic corrector step\n        xi_cand = (sigma_tr * params['eps_L'] - R_np1) / params['H']\n        # Enforce constraints\n        xi_np1 = max(xi_n, min(1.0, xi_cand))\n        return xi_np1\n\ndef mn_update(xi_n, eps_np1, T_np1, params):\n    \"\"\"Performs one update step using Monolithic Newton-Raphson (MN).\"\"\"\n    # Elastic predictor step\n    E_n = E_mod(xi_n, params)\n    sigma_E = E_n * (eps_np1 - params['eps_L'] * xi_n)\n    \n    # Check for transformation\n    R_np1 = R_thresh(T_np1, params)\n    F_E = sigma_E * params['eps_L'] - params['H'] * xi_n - R_np1\n\n    if F_E = 0:\n        # Elastic step\n        return xi_n\n    else:\n        # Inelastic step: solve g(xi) = 0 via Newton-Raphson\n        \n        # Define residual and its derivative\n        dE = params['E_M'] - params['E_A']\n        \n        def g(xi):\n            E_xi = params['E_A'] + dE * xi\n            sigma_xi = E_xi * (eps_np1 - params['eps_L'] * xi)\n            return sigma_xi * params['eps_L'] - params['H'] * xi - R_np1\n\n        def g_prime(xi):\n            E_xi = params['E_A'] + dE * xi\n            # d(sigma)/d(xi) = E'(xi)*(eps-eps_L*xi) - E(xi)*eps_L\n            d_sigma_d_xi = dE * (eps_np1 - params['eps_L'] * xi) - E_xi * params['eps_L']\n            return d_sigma_d_xi * params['eps_L'] - params['H']\n\n        # Newton-Raphson iteration\n        xi_k = xi_n  # Initial guess\n        max_iter = 20\n        tolerance = 1e-9\n        \n        for _ in range(max_iter):\n            res = g(xi_k)\n            if abs(res)  tolerance:\n                break\n            grad = g_prime(xi_k)\n            if abs(grad)  1e-9: # Avoid division by zero\n                break\n            xi_k -= res / grad\n\n        # Enforce constraints\n        xi_np1 = max(xi_n, min(1.0, xi_k))\n        return xi_np1\n\ndef run_simulation(case, params):\n    \"\"\"\n    Runs a full simulation for a given test case and returns the algorithmic error.\n    \"\"\"\n    time = case['time_points']\n    N_steps = len(time) - 1\n\n    # Initial conditions\n    xi_0 = 0.0\n    \n    xi_os = np.zeros(N_steps + 1)\n    xi_mn = np.zeros(N_steps + 1)\n    xi_os[0] = xi_mn[0] = xi_0\n    \n    dissipation_os = 0.0\n    dissipation_mn = 0.0\n    \n    for n in range(N_steps):\n        t_np1 = time[n+1]\n        eps_np1 = case['eps_path'](t_np1)\n        T_np1 = case['T_path'](t_np1)\n        \n        # Operator Splitting update\n        xi_np1_os = os_update(xi_os[n], eps_np1, T_np1, params)\n        xi_os[n+1] = xi_np1_os\n        \n        # Monolithic Newton-Raphson update\n        xi_np1_mn = mn_update(xi_mn[n], eps_np1, T_np1, params)\n        xi_mn[n+1] = xi_np1_mn\n        \n        # Calculate incremental dissipation\n        R_np1 = R_thresh(T_np1, params)\n        dissipation_os += R_np1 * (xi_os[n+1] - xi_os[n])\n        dissipation_mn += R_np1 * (xi_mn[n+1] - xi_mn[n])\n        \n    # Calculate final algorithmic error\n    error = abs(dissipation_os - dissipation_mn)\n    return error\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}