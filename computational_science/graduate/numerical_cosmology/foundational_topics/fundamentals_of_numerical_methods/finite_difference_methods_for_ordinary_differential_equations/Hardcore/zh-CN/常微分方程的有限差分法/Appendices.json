{
    "hands_on_practices": [
        {
            "introduction": "在数值宇宙学中，有限差分是构建微分方程求解器的基本工具。然而，在计算机上实现这些方法需要巧妙地权衡两个相互竞争的误差来源：由近似公式本身导致的截断误差（truncation error），以及由计算机浮点运算精度限制产生的舍入误差（rounding error）。 这个练习将引导你分析这两种误差，并推导出一个最佳步长 $h^{\\star}$，以在二者之间取得平衡，这是获得可靠数值导数的关键一步。",
            "id": "3471898",
            "problem": "在数值宇宙学中，诸如尺度因子 $a(t)$、哈勃膨胀率 $H(t)$ 或距离度量 $D(t)$ 等平滑宇宙学可观测量的一阶导数，通常使用有限差分法通过常微分方程进行计算。设 $y(t)$ 表示任何此类的平滑可观测量，它在固定时刻 $t$ 附近是二阶连续可微的，且存在更高阶的导数。考虑一阶导数的中心差分估计量，\n$$\nD_{c}(h;t) \\equiv \\frac{y(t+h)-y(t-h)}{2h},\n$$\n该计算在遵循电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 标准的浮点算术中进行，采用四舍五入到最近值的方式，单位舍入误差为 $\\varepsilon$。\n\n从适用于该背景的基本原理出发，即平滑函数的泰勒展开和标准浮点舍入模型 $\\mathrm{fl}(z)=z(1+\\delta)$（其中对于每个基本运算，都有 $|\\delta|\\leq \\varepsilon$），执行以下任务：\n\n- 推导 $D_{c}(h;t)$ 的主阶截断误差，将其表示为 $h$ 和 $y(t)$ 的导数的函数。\n- 当 $h$ 非常小时，通过对减法 $y(t+h)-y(t-h)$ 上的浮点舍入效应进行建模，来量化产生的相消误差，并得出一个最坏情况下的绝对误差界，该界揭示了误差随 $h$ 和 $y(t)$ 的标度关系。\n- 将这些误差贡献组合成一个单一的主阶最坏情况绝对误差模型 $E(h)$，并通过最小化 $E(h)$（相对于 $h$），确定平衡截断误差和相消误差的最佳步长 $h^{\\star}$。\n\n最后，提出一种补偿差分策略，该策略使用浮点减法的无误差变换来减轻减法 $y(t+h)-y(t-h)$ 中的相消误差，并定性解释这将如何改变误差模型中舍入误差项对 $h$ 的依赖关系。您的推导必须保持通用性，不要代入宇宙学参数的具体数值。\n\n将您的最终答案表示为最佳步长 $h^{\\star}$ 的封闭形式解析表达式，用 $\\varepsilon$、$y(t)$ 和 $y(t)$ 的相应导数表示。最终答案不需要进行数值近似或舍入。",
            "solution": "问题要求对使用中心差分公式\n$$\nD_{c}(h;t) = \\frac{y(t+h)-y(t-h)}{2h},\n$$\n计算平滑函数 $y(t)$ 的一阶导数所涉及的误差进行彻底分析，并确定使总误差最小化的最佳步长 $h^{\\star}$。该分析涉及两个主要的误差来源：有限差分近似固有的截断误差和源于浮点算术的舍入误差。\n\n### 步骤 1：截断误差的推导\n\n截断误差 $E_{\\text{trunc}}(h)$ 是在假设精确算术的情况下，用有限差分公式近似真实导数 $y'(t)$ 时产生的误差。它可以通过在点 $t$ 附近对函数 $y(t)$ 进行泰勒展开来推导。由于假设 $y(t)$ 是充分可微的，我们可以写出 $y(t+h)$ 和 $y(t-h)$ 的泰勒级数：\n\n$$\ny(t+h) = y(t) + h y'(t) + \\frac{h^2}{2!} y''(t) + \\frac{h^3}{3!} y'''(t) + \\frac{h^4}{4!} y^{(4)}(t) + O(h^5)\n$$\n$$\ny(t-h) = y(t) - h y'(t) + \\frac{h^2}{2!} y''(t) - \\frac{h^3}{3!} y'''(t) + \\frac{h^4}{4!} y^{(4)}(t) - O(h^5)\n$$\n\n用第一个展开式减去第二个展开式，可以消去 $h$ 的偶次幂项：\n$$\ny(t+h) - y(t-h) = 2h y'(t) + \\frac{2h^3}{3!} y'''(t) + O(h^5)\n$$\n$$\ny(t+h) - y(t-h) = 2h y'(t) + \\frac{h^3}{3} y'''(t) + O(h^5)\n$$\n\n现在，我们除以 $2h$ 来获得中心差分估计量的表达式：\n$$\n\\frac{y(t+h) - y(t-h)}{2h} = y'(t) + \\frac{h^2}{6} y'''(t) + O(h^4)\n$$\n\n截断误差是估计值与真实值之间的差：\n$$\nE_{\\text{trunc}}(h) = D_{c}(h;t) - y'(t) = \\frac{h^2}{6} y'''(t) + O(h^4)\n$$\n\n主阶截断误差是该级数的第一项，它与步长的平方 $h^2$ 成正比。其大小由下式给出：\n$$\n|E_{\\text{trunc}}(h)| \\approx \\frac{h^2}{6} |y'''(t)|\n$$\n\n### 步骤 2：舍入误差的量化\n\n舍入误差源于浮点算术的有限精度。对值 $z$ 进行单次浮点运算的标准模型是 $\\mathrm{fl}(z) = z(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon$ 且 $\\varepsilon$ 是单位舍入误差。\n\n$D_{c}(h;t)$ 的计算涉及求值 $y(t+h)$ 和 $y(t-h)$，将它们相减，然后除以 $2h$。让我们分析分子中的误差，这是关键步骤。函数值的浮点表示为：\n$$\n\\tilde{y}_{+} = \\mathrm{fl}(y(t+h)) = y(t+h)(1+\\delta_1)\n$$\n$$\n\\tilde{y}_{-} = \\mathrm{fl}(y(t-h)) = y(t-h)(1+\\delta_2)\n$$\n其中 $|\\delta_1|, |\\delta_2| \\leq \\varepsilon$。为简单起见，我们假设 $y$ 的求值导致单个舍入误差。\n\n然后在浮点算术中执行减法：\n$$\n\\mathrm{fl}(\\tilde{y}_{+} - \\tilde{y}_{-}) = (\\tilde{y}_{+} - \\tilde{y}_{-})(1+\\delta_3)\n$$\n其中 $|\\delta_3| \\leq \\varepsilon$。\n\n分子中的绝对舍入误差是计算值与真实值 $y(t+h)-y(t-h)$ 之间的差。计算出的分子是：\n$$\n(y(t+h)(1+\\delta_1) - y(t-h)(1+\\delta_2))(1+\\delta_3)\n$$\n展开此式并只保留 $\\delta_i$ 的一阶项，得到：\n$$\n(y(t+h) - y(t-h)) + (y(t+h)-y(t-h))\\delta_3 + y(t+h)\\delta_1 - y(t-h)\\delta_2\n$$\n分子中的误差大约为 $(y(t+h)-y(t-h))\\delta_3 + y(t+h)\\delta_1 - y(t-h)\\delta_2$。\n当 $h$ 很小时，$y(t+h) \\approx y(t-h) \\approx y(t)$，且差值 $y(t+h)-y(t-h) \\approx 2hy'(t)$ 很小。这是灾难性相消的条件。$y(t\\pm h)$ 计算值的绝对误差约为 $\\varepsilon |y(t)|$。当这两个几乎相等的数相减时，它们的绝对误差大致相加。分子误差的主要部分来自继承的误差：$y(t+h)\\delta_1 - y(t-h)\\delta_2$。\n\n分子绝对误差的最坏情况界限是：\n$$\n|E_{\\text{num}}| \\le |y(t+h)\\delta_1| + |y(t-h)\\delta_2| \\approx \\varepsilon |y(t+h)| + \\varepsilon |y(t-h)|\n$$\n对于小 $h$，这大约是 $2\\varepsilon|y(t)|$。\n\n$D_c(h;t)$ 的总舍入误差是这个分子误差除以分母 $2h$（假设分母的计算误差可忽略不计）。\n$$\n|E_{\\text{round}}(h)| \\approx \\frac{2\\varepsilon|y(t)|}{2h} = \\frac{\\varepsilon|y(t)|}{h}\n$$\n随着 $h$ 变小，此误差项会增大，这是灾难性相消的标志。\n\n### 步骤 3：最佳步长\n\n总绝对误差 $E(h)$ 是主阶截断误差和舍入误差的量值之和：\n$$\nE(h) \\approx |E_{\\text{trunc}}(h)| + |E_{\\text{round}}(h)| = \\frac{h^2}{6} |y'''(t)| + \\frac{\\varepsilon|y(t)|}{h}\n$$\n为了找到使总误差最小的最佳步长 $h^{\\star}$，我们将 $E(h)$ 对 $h$ 求导，并令结果为零，假设 $y(t)$ 和 $y'''(t)$ 非零。\n$$\n\\frac{dE}{dh} = \\frac{2h}{6} |y'''(t)| - \\frac{\\varepsilon|y(t)|}{h^2} = \\frac{h}{3} |y'''(t)| - \\frac{\\varepsilon|y(t)|}{h^2}\n$$\n令 $\\frac{dE}{dh} = 0$：\n$$\n\\frac{h^{\\star}}{3} |y'''(t)| = \\frac{\\varepsilon|y(t)|}{(h^{\\star})^2}\n$$\n解出 $h^{\\star}$：\n$$\n(h^{\\star})^3 = \\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\n$$\n$$\nh^{\\star} = \\left(\\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\\right)^{1/3}\n$$\n该表达式给出了平衡递减的截断误差和递增的舍入误差的最佳步长。\n\n### 步骤 4：补偿差分策略\n\n标准中心差分公式中的灾难性相消是因为当 $h$ 很小时，减法 $\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))$ 会损失显著的相对精度。补偿差分策略可以减轻这一特定的误差来源。\n\n提议的策略是使用浮点减法的无误差变换 (EFT)，例如 Ogita、Rump 和 Oishi 的 `TwoDiff` 算法。给定两个浮点数 $x$ 和 $y$，该算法计算出一对浮点数 $(s, e)$，使得 $s = \\mathrm{fl}(x-y)$ 并且关键的是，$s+e=x-y$ 精确成立（除非发生上溢/下溢）。变量 $e$ 捕获了主减法运算的舍入误差。\n\n通过将此 EFT 应用于分子减法，我们实质上是在以更高的精度计算 $\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))$ 的值（例如，作为一个由数对 $(s,e)$ 表示的双精度数）。此过程有效地消除了减法运算本身引入的舍入误差。\n\n然而，这并不能消除所有的舍入误差。从 $y(t+h)$ 和 $y(t-h)$ 的初始浮点求值中继承的误差仍然存在。补偿后分子中的误差现在主要由 $(\\mathrm{fl}(y(t+h)) - \\mathrm{fl}(y(t-h))) - (y(t+h) - y(t-h)) = y(t+h)\\delta_1 - y(t-h)\\delta_2$ 决定。除以 $2h$，补偿方案中的舍入误差为：\n$$\nE_{\\text{round}}^{\\text{comp}}(h) \\approx \\frac{y(t+h)\\delta_1 - y(t-h)\\delta_2}{2h}\n$$\n像之前一样展开各项，得到：\n$$\nE_{\\text{round}}^{\\text{comp}}(h) \\approx \\frac{y(t)(\\delta_1 - \\delta_2)}{2h} + \\frac{y'(t)(\\delta_1 + \\delta_2)}{2} + O(h)\n$$\n定性地讲，舍入误差对 $h$ 的依赖关系因一种称为“良性相消”的现象而改变。当在两个非常接近的点 $t+h$ 和 $t-h$ 处计算平滑函数 $y$ 时，计算路径几乎是相同的。这可能导致高度相关的舍入误差，即 $\\delta_1 \\approx \\delta_2$。因此，差值 $\\delta_1 - \\delta_2$ 远小于 $\\varepsilon$。这种良性相消抑制了有问题的 $O(1/h)$ 项。于是，主导的舍入误差项变成了展开式中的下一项，它相对于 $h$ 近似为常数：\n$$\n|E_{\\text{round}}^{\\text{comp}}(h)| \\approx \\left|\\frac{y'(t)(\\delta_1 + \\delta_2)}{2}\\right| \\le \\frac{|y'(t)|(2\\varepsilon)}{2} = \\varepsilon|y'(t)|\n$$\n因此，补偿差分策略通过利用 EFT 和平滑函数舍入误差的相关性，定性地将舍入误差的标度关系从 $O(\\varepsilon/h)$ 改变为 $O(\\varepsilon)$。这允许在总误差被舍入效应主导之前使用更小的步长 $h$，从而得到更精确的导数估计。",
            "answer": "$$\n\\boxed{\\left(\\frac{3\\varepsilon|y(t)|}{|y'''(t)|}\\right)^{1/3}}\n$$"
        },
        {
            "introduction": "超越纯粹的数值准确性，我们的模拟还必须遵守物理定律。例如，能量密度 $\\rho$ 或粒子数密度等物理量本质上是非负的。 本练习将探讨如何分析显式时间积分格式，以推导出保证解的“保正性”（positivity-preserving）的步长限制，确保数值结果在物理上是有效且有意义的。",
            "id": "3471815",
            "problem": "考虑在一个空间均匀的 Friedmann–Lemaître–Robertson–Walker 背景中，由带衰变汇的协变能量守恒导出的衰变暗物质能量密度的常微分方程，其形式如下\n$$\n\\frac{d\\rho}{dt} = -3\\,H(t)\\,\\rho(t) - \\Gamma\\,\\rho(t),\n$$\n其中 $H(t)$ 是哈勃膨胀率，$\\Gamma \\ge 0$ 是一个恒定的衰变率。定义组合率\n$$\n\\Lambda(t) \\equiv 3\\,H(t) + \\Gamma,\n$$\n使得方程是线性齐次的，\n$$\n\\frac{d\\rho}{dt} = -\\Lambda(t)\\,\\rho(t).\n$$\n您将构建保正性的显式有限差分更新格式，并推导保证数值解非负性的步长限制。\n\n您的任务是：\n\n- 从守恒律和 $H(t)$ 的定义出发，形式上论证模型 $\\frac{d\\rho}{dt} = -3\\,H(t)\\,\\rho(t) - \\Gamma \\rho(t)$ 以及 $\\Lambda(t) \\ge 0$ 的线性形式 $\\frac{d\\rho}{dt} = -\\Lambda(t)\\,\\rho(t)$ 的合理性。\n- 对以下每种显式时间离散化方法，构建 $\\rho_{n+1}$ 的单步更新格式，并推导一个以 $\\Lambda(t)$ 的上界表示的充分步长限制，该限制能保证在所需的前序值为非负时，$\\rho_{n+1} \\ge 0$：\n  - Forward Euler（单步显式方法）。\n  - 二阶两阶段强稳定性保持 Runge–Kutta 法（SSP Runge–Kutta，二阶）。\n  - 二阶两步 Adams–Bashforth 法（显式多步法），假设第一步使用 Forward Euler 法，并满足其自身的保正性条件。\n您的推导必须从方法的定义更新式开始，并且只使用涉及 $\\Lambda(t)$ 和 $\\Lambda(t)$ 在一个步长内的界的不等式。不要假设 $\\Lambda(t)$ 在一个步长内是常数；您可以使用任何满足 $\\Lambda(t) \\le \\ell$ 在目标区间上的界 $\\ell$。\n- 实现一个程序，该程序：\n  - 对于下面的每个测试用例，通过使用您推导出的条件所隐含的上确界 $\\lambda_{\\max} \\equiv \\sup_{t \\in [t_0, t_0+T]} \\Lambda(t)$，为每种方法计算一个足以在整个积分区间上保持正性的均匀时间步长 $\\Delta t_{\\max}$。\n  - 从 $\\rho(t_0) = \\rho_0$ 开始，使用步长 $\\Delta t = 0.99\\,\\Delta t_{\\max}$，在 $[t_0, t_0+T]$ 上用每种方法对该方程进行数值积分，并验证所有离散密度值保持非负。\n  - 为每个测试用例报告一个列表，其中包含三个以 $\\mathrm{Gyr}$ 为单位的步长界限，随后是三个布尔值，指示相应的数值积分是否在所有网格点上保持非负。\n- 单位与格式：\n  - 时间 $t$ 的单位必须是 $\\mathrm{Gyr}$，哈勃率 $H$ 的单位必须是 $\\mathrm{Gyr}^{-1}$，衰变率 $\\Gamma$ 的单位必须是 $\\mathrm{Gyr}^{-1}$，报告的步长单位也必须是 $\\mathrm{Gyr}$。\n  - 不使用角度。\n  - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是对应一个测试用例的列表，顺序如下所述。\n\n测试套件（请严格使用以下三个用例）：\n- 用例 $1$（常数膨胀）：$H(t) = H_0$，$H_0 = 0.07\\,\\mathrm{Gyr}^{-1}$，$\\Gamma = 0.01\\,\\mathrm{Gyr}^{-1}$，$t_0 = 0.0\\,\\mathrm{Gyr}$，$T = 10.0\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n- 用例 $2$（物质主导标度）：$H(t) = \\dfrac{2}{3\\,t}$，$\\Gamma = 0.2\\,\\mathrm{Gyr}^{-1}$，$t_0 = 1.0\\,\\mathrm{Gyr}$，$T = 5.0\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n- 用例 $3$（辐射主导标度）：$H(t) = \\dfrac{1}{2\\,t}$，$\\Gamma = 0.0\\,\\mathrm{Gyr}^{-1}$，$t_0 = 0.5\\,\\mathrm{Gyr}$，$T = 0.5\\,\\mathrm{Gyr}$，$\\rho_0 = 1.0$。\n\n最终输出格式：\n- 程序必须打印单行输出，包含一个含三个元素的列表，每个元素对应一个测试用例，且每个元素本身必须是包含六个条目的列表，顺序为 $[\\Delta t_{\\max}^{\\mathrm{FE}}, \\Delta t_{\\max}^{\\mathrm{SSP2}}, \\Delta t_{\\max}^{\\mathrm{AB2}}, \\mathrm{pos}_{\\mathrm{FE}}, \\mathrm{pos}_{\\mathrm{SSP2}}, \\mathrm{pos}_{\\mathrm{AB2}}]$，其中每个 $\\Delta t_{\\max}$ 是一个以 $\\mathrm{Gyr}$ 为单位的浮点数，每个 $\\mathrm{pos}$ 是一个布尔值。",
            "solution": "该问题经评估是有效的，因为它具有科学依据、数学上适定、客观且完整。我们开始解答。\n\n### 控制方程的论证\n\n衰变暗物质能量密度 $\\rho(t)$ 的控制常微分方程(ODE)可以在宇宙学背景下从广义相对论的原理推導出来。出发点是能量-动量张量 $T^{\\mu\\nu}$ 的协变守恒，在存在能量-动量汇/源 $J^\\nu$ 的情况下，表示为 $\\nabla_\\mu T^{\\mu\\nu} = J^\\nu$。\n\n对于理想流体，能量-动量张量为 $T^{\\mu\\nu} = (\\rho+p)u^\\mu u^\\nu + p g^{\\mu\\nu}$，其中 $\\rho$ 是能量密度，$p$ 是压强，$u^\\mu$ 是流体的四维速度，$g^{\\mu\\nu}$ 是度规张量。在一个空间均匀且各向同性的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，并在一个 $u^\\mu = (1, 0, 0, 0)$ 的共动参考系里，守恒律的时间分量（$\\nu=0$）简化为流体方程：\n$$\n\\dot{\\rho} + 3H(t)(\\rho+p) = J^0,\n$$\n其中点号表示对宇宙时间 $t$ 的导数，$H(t) \\equiv \\dot{a}(t)/a(t)$ 是哈勃膨胀率，$a(t)$ 是宇宙的尺度因子。\n\n问题考虑的是暗物质，它被建模为一种非相对论性物质。对于这类物质，其组成粒子的动能远小于其静止质量能，这意味着压强与能量密度相比可以忽略不计，即 $p \\ll \\rho$。因此，我们做出标准近似 $p=0$。\n\n暗物质粒子衰变为其他粒子（例如，辐射）的过程充当了暗物质能量密度的汇。对此过程的一个常见唯象模型假设能量损失率与能量密度本身成正比。这由一个汇项 $J^0 = -\\Gamma\\rho$ 表示，其中 $\\Gamma \\ge 0$ 是恒定的衰变率。\n\n将 $p=0$ 和 $J^0 = -\\Gamma\\rho$ 代入流体方程得到：\n$$\n\\dot{\\rho} + 3H(t)\\rho = -\\Gamma\\rho.\n$$\n整理此方程得到问题陈述中给出的ODE：\n$$\n\\frac{d\\rho}{dt} = -3H(t)\\rho(t) - \\Gamma\\rho(t).\n$$\n通过定义组合率 $\\Lambda(t) \\equiv 3H(t) + \\Gamma$，方程变为简单的线性齐次形式：\n$$\n\\frac{d\\rho}{dt} = -\\Lambda(t)\\rho(t).\n$$\n对于一个膨胀的宇宙，尺度因子 $a(t)$ 是不减的，所以哈勃率 $H(t) = \\dot{a}/a$ 是非负的。由于给定的衰变率 $\\Gamma \\ge 0$，组合率 $\\Lambda(t) = 3H(t) + \\Gamma$ 保证对所有 $t$ 都是非负的。因此，如果初始密度 $\\rho(t_0)$ 是非负的，那么精确解 $\\rho(t) = \\rho(t_0) \\exp(-\\int_{t_0}^t \\Lambda(\\tau)d\\tau)$ 总是非负的。\n\n### 保正性步长限制的推导\n\n我们为三种显式数值方法推导充分的步长限制，以确保数值解 $\\rho_n$ 在所有时间步长上保持非负，前提是前序步长的值非负。设 $\\ell$ 为组合率的任意上界，即在积分区间 $[t_0, t_0+T]$ 上有 $\\Lambda(t) \\le \\ell$。\n\n#### Forward Euler (FE) 方法\n这是一种单步显式方法。对于方程 $\\dot{\\rho} = f(t, \\rho)$，其更新规则是 $\\rho_{n+1} = \\rho_n + \\Delta t f(t_n, \\rho_n)$。代入 $f(t_n, \\rho_n) = -\\Lambda(t_n)\\rho_n$，我们得到：\n$$\n\\rho_{n+1} = \\rho_n + \\Delta t (-\\Lambda(t_n)\\rho_n) = \\rho_n(1 - \\Delta t \\Lambda(t_n)).\n$$\n为确保在 $\\rho_n \\ge 0$ 的条件下 $\\rho_{n+1} \\ge 0$，我们需要 $\\rho_n$ 的系数为非负：\n$$\n1 - \\Delta t \\Lambda(t_n) \\ge 0 \\implies \\Delta t \\Lambda(t_n) \\le 1.\n$$\n为使均匀步长 $\\Delta t$ 在每一步都保持正性，此条件必须对所有 $n$ 成立。一个充分条件是 $\\Delta t \\cdot \\sup_t \\Lambda(t) \\le 1$。使用界 $\\ell$，步长必须满足：\n$$\n\\Delta t \\le \\frac{1}{\\ell}.\n$$\n\n#### 两阶段强稳定性保持 Runge–Kutta (SSP2) 法\n$2$ 阶 $2$ 阶段 SSP Runge-Kutta 方法 (SSP$2$) 的结构是 Forward Euler 式阶段的凸组合。对于 $\\dot{\\rho} = f(t, \\rho)$，更新过程如下：\n\\begin{align*}\n\\rho^{(1)} = \\rho_n + \\Delta t f(t_n, \\rho_n) \\\\\n\\rho_{n+1} = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\left(\\rho^{(1)} + \\Delta t f(t_n+\\Delta t, \\rho^{(1)})\\right)\n\\end{align*}\n代入 $f(t, \\rho) = -\\Lambda(t)\\rho$：\n\\begin{align*}\n\\rho^{(1)} = \\rho_n - \\Delta t \\Lambda(t_n)\\rho_n = \\rho_n(1 - \\Delta t \\Lambda(t_n)) \\\\\n\\rho_{n+1} = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\left(\\rho^{(1)} - \\Delta t \\Lambda(t_{n+1})\\rho^{(1)}\\right) = \\frac{1}{2}\\rho_n + \\frac{1}{2}\\rho^{(1)}(1 - \\Delta t \\Lambda(t_{n+1}))\n\\end{align*}\n假设 $\\rho_n \\ge 0$，我们要找到一个关于 $\\Delta t$ 的条件来保证 $\\rho_{n+1} \\ge 0$。\n1.  为使中间阶段值 $\\rho^{(1)}$ 非负，我们需要 $1 - \\Delta t \\Lambda(t_n) \\ge 0$。\n2.  在 $\\rho^{(1)} \\ge 0$ 和 $\\rho_n \\ge 0$ 的条件下，为使 $\\rho_{n+1}$（两项之和）非负，只需 $\\rho^{(1)}$ 的系数非负即可：$1 - \\Delta t \\Lambda(t_{n+1}) \\ge 0$。\n如果对于步长区间 $[t_n, t_{n+1}]$ 内的所有 $t$ 都有 $\\Delta t \\Lambda(t) \\le 1$，则这两个条件都满足。因此，一个足以保证正性的均匀步长限制是：\n$$\n\\Delta t \\le \\frac{1}{\\ell}.\n$$\n\n#### 两步 Adams–Bashforth (AB2) 法\n$2$ 阶 $2$ 步 Adams-Bashforth 方法 (AB$2$) 是一种显式线性多步法。其更新规则是：\n$$\n\\rho_{n+1} = \\rho_n + \\frac{\\Delta t}{2} \\left( 3f(t_n, \\rho_n) - f(t_{n-1}, \\rho_{n-1}) \\right).\n$$\n代入 $f(t, \\rho) = -\\Lambda(t)\\rho$，我们有：\n$$\n\\rho_{n+1} = \\rho_n + \\frac{\\Delta t}{2} \\left( -3\\Lambda(t_n)\\rho_n + \\Lambda(t_{n-1})\\rho_{n-1} \\right).\n$$\n按 $\\rho_n$ 和 $\\rho_{n-1}$ 分组整理各项得：\n$$\n\\rho_{n+1} = \\rho_n \\left( 1 - \\frac{3}{2}\\Delta t \\Lambda(t_n) \\right) + \\rho_{n-1} \\left( \\frac{1}{2}\\Delta t \\Lambda(t_{n-1}) \\right).\n$$\n假设前序值非负：$\\rho_n \\ge 0$ 和 $\\rho_{n-1} \\ge 0$。由于 $\\Delta t > 0$ 和 $\\Lambda(t) \\ge 0$，涉及 $\\rho_{n-1}$ 的第二项显然是非负的。为确保 $\\rho_{n+1} \\ge 0$，一个充分条件是 $\\rho_n$ 的系数也非负：\n$$\n1 - \\frac{3}{2}\\Delta t \\Lambda(t_n) \\ge 0 \\implies \\Delta t \\Lambda(t_n) \\le \\frac{2}{3}.\n$$\n这种两步法的第一步必须用单步法计算，这里指定为 Forward Euler 法。FE 步的保正性要求 $\\Delta t \\Lambda(t_0) \\le 1$。由于 $\\frac{2}{3}  1$，AB$2$ 的条件更严格，如果对所有步都强制执行此条件，将自动满足启动步的保正性要求。在整个积分过程中保证正性的一个充分的均匀步长限制是：\n$$\n\\Delta t \\le \\frac{2}{3\\ell}.\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes positivity-preserving step-size limits for three numerical methods\n    and verifies that the solutions remain non-negative when integrated with these step sizes.\n    \"\"\"\n    test_cases = [\n        {\n            \"H_func\": lambda t: 0.07,\n            \"Gamma\": 0.01,\n            \"t0\": 0.0,\n            \"T\": 10.0,\n            \"rho0\": 1.0,\n        },\n        {\n            \"H_func\": lambda t: 2.0 / (3.0 * t),\n            \"Gamma\": 0.2,\n            \"t0\": 1.0,\n            \"T\": 5.0,\n            \"rho0\": 1.0,\n        },\n        {\n            \"H_func\": lambda t: 1.0 / (2.0 * t),\n            \"Gamma\": 0.0,\n            \"t0\": 0.5,\n            \"T\": 0.5,\n            \"rho0\": 1.0,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        H_func = case[\"H_func\"]\n        Gamma = case[\"Gamma\"]\n        t0 = case[\"t0\"]\n        T = case[\"T\"]\n        rho0 = case[\"rho0\"]\n\n        Lambda_func = lambda t: 3.0 * H_func(t) + Gamma\n        \n        # For the given H(t) functions, Lambda(t) is monotonically non-increasing on t > 0.\n        # The integration intervals are [t0, t0+T] where t0 > 0 or t0=0 and H is constant.\n        # Thus, the supremum of Lambda(t) occurs at t = t0.\n        lambda_max = Lambda_func(t0)\n\n        # Calculate maximum step sizes based on derived positivity conditions\n        dt_max_fe = 1.0 / lambda_max\n        dt_max_ssp2 = 1.0 / lambda_max\n        dt_max_ab2 = (2.0 / 3.0) / lambda_max\n\n        case_results = [dt_max_fe, dt_max_ssp2, dt_max_ab2]\n\n        # --- Run simulations for each method ---\n        # The factor 0.99 is used to ensure the step size is strictly within the bound.\n        # A small negative tolerance is used for the positivity check to account for floating-point inaccuracies.\n        fp_tol = -1e-15\n\n        # Method 1: Forward Euler\n        dt = 0.99 * dt_max_fe\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        for n in range(num_steps):\n            rho[n+1] = rho[n] * (1.0 - dt * Lambda_func(t_grid[n]))\n        pos_fe = np.all(rho >= fp_tol)\n        case_results.append(pos_fe)\n\n        # Method 2: SSP Runge-Kutta 2\n        dt = 0.99 * dt_max_ssp2\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        for n in range(num_steps):\n            rho_stage1 = rho[n] * (1.0 - dt * Lambda_func(t_grid[n]))\n            rho[n+1] = 0.5 * rho[n] + 0.5 * rho_stage1 * (1.0 - dt * Lambda_func(t_grid[n+1]))\n        pos_ssp2 = np.all(rho >= fp_tol)\n        case_results.append(pos_ssp2)\n\n        # Method 3: Adams-Bashforth 2\n        dt = 0.99 * dt_max_ab2\n        num_steps = int(np.ceil(T / dt))\n        t_grid = t0 + np.arange(num_steps + 1) * dt\n        rho = np.zeros(num_steps + 1)\n        rho[0] = rho0\n        \n        # At least two points (t0, t1) are needed for the AB2 formula.\n        if num_steps > 0:\n            # Startup step using Forward Euler for rho at t1\n            rho[1] = rho[0] * (1.0 - dt * Lambda_func(t_grid[0]))\n            \n            # Main AB2 loop for subsequent steps\n            for n in range(1, num_steps):\n                f_n = -Lambda_func(t_grid[n]) * rho[n]\n                f_n_minus_1 = -Lambda_func(t_grid[n-1]) * rho[n-1]\n                rho[n+1] = rho[n] + (dt / 2.0) * (3.0 * f_n - f_n_minus_1)\n        \n        pos_ab2 = np.all(rho >= fp_tol)\n        case_results.append(pos_ab2)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists. The standard `str` representation\n    # for lists in Python is used, which includes spaces after commas and capitalized booleans.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实现了数值方法后，一个至关重要的步骤是验证其行为是否与理论预测相符。这个动手实践的编码练习将指导你构建一个测试框架，用于通过网格加密来测量数值方法的“收敛阶”（order of accuracy）。 掌握这种验证技术是开发稳健科学计算代码的基石，它能确保我们的模拟不仅在运行，而且在正确地运行。",
            "id": "3471890",
            "problem": "您需要构建一个完整的、可运行的程序，该程序实现一个测试工具，用于测量在网格加密情况下，应用于一个受宇宙学启发的常微分方程的有限差分时间积分方法的观测精度阶。从空间平坦、物质主导的 Einstein–de Sitter 宇宙的 Friedmann 方程开始，该方程得出的尺度因子 $a(t)$ 遵循 $H(a) = H_0 a^{-3/2}$，并且在宇宙时间 $t$ 下，$da/dt = a H(a)$。引入无量纲时间 $\\tau = H_0 t$，演化方程简化为\n$$\n\\frac{da}{d\\tau} = a^{-1/2}.\n$$\n该方程有精确解\n$$\na(\\tau) = \\left(\\frac{2}{3}\\,\\tau\\right)^{2/3},\n$$\n该解通过分离变量法得到，其中大爆炸发生在 $\\tau = 0$。为避免在 $\\tau = 0$ 处的奇点，从一个严格为正的起始时间 $\\tau_0  0$ 开始积分，其初始条件 $a(\\tau_0)$ 与精确解一致。\n\n您的程序必须实现一个有限差分时间步进工具，对于每种指定的方法和加密级别，该工具将无量纲 Friedmann 常微分方程从 $\\tau_0$ 积分到 $\\tau_f$，并计算最终时间的全局误差。使用此结果，通过跨加密级别的 Richardson 式比较来估计观测阶。具体来说，给定一个由 $k$ 索引的、具有特征步长 $h_k$ 的加密序列，构建误差 $E_k = \\lvert a_k(\\tau_f) - a(\\tau_f)\\rvert$，其中 $a_k(\\tau_f)$ 是在加密级别 $k$ 时 $\\tau_f$ 处的数值解。对于均匀减半的加密，两个连续级别之间的观测阶为\n$$\np_{\\mathrm{obs}} = \\log_2\\!\\left(\\frac{E_k}{E_{k+1}}\\right).\n$$\n当步长约束或自适应性导致区间内 $h$ 的非均匀变化时，将相同的公式应用于通过将参考参数减半生成的序列，并将 $p_{\\mathrm{obs}}$ 解释为一个可能偏离标称阶的经验估计值。\n\n实现以下单步法：\n- 标称阶 $p=2$ 的显式中点法。\n- 标称阶 $p=4$ 的经典 Runge–Kutta 方法。\n\n对于约束或自适应步进，基于哈勃时间建立一个受宇宙学启发的步长上限模型。在无量纲变量中，哈勃时间为 $H(\\tau)^{-1} = a(\\tau)^{3/2}$。施加一个逐点步长约束\n$$\nh(\\tau) \\le \\eta\\,a(\\tau)^{3/2},\n$$\n其中有一个固定常数 $\\eta  0$，同时尝试在不同加密级别之间将参考步长 $h_{\\mathrm{ref}}$ 减半。在积分器内部使用 $h(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)$，并通过在必要时缩短最后一步来强制最后一步正好落在 $\\tau_f$上。\n\n使用以下参数值的测试套件，该套件旨在测试一个顺利路径、一个高阶情况和一个约束/自适应场景：\n- 所有测试共享的宇宙学区间和初始条件：$\\tau_0 = 0.1$，$\\tau_f = 1.0$，其中 $a(\\tau_0) = \\left(\\frac{2}{3}\\,\\tau_0\\right)^{2/3}$。\n- 测试用例 #1（顺利路径，二阶）：在均匀网格上使用显式中点法，加密级别为 $\\{N_0, 2N_0, 4N_0\\}$，其中 $N_0 = 50$ 且 $h_k = (\\tau_f - \\tau_0)/N_k$。\n- 测试用例 #2（顺利路径，四阶）：在均匀网格上使用经典 Runge–Kutta 方法，加密级别为 $\\{N_0, 2N_0, 4N_0\\}$，其中 $N_0 = 20$ 且 $h_k = (\\tau_f - \\tau_0)/N_k$。\n- 测试用例 #3（约束下的差异）：使用带约束步长 $h(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)$ 的经典 Runge–Kutta 方法，加密级别为 $h_{\\mathrm{ref}} \\in \\{h_0, h_0/2, h_0/4\\}$，其中 $h_0 = 0.05$ 且 $\\eta = 0.1$。\n\n对于每个测试用例，仅计算最后两个加密级别之间的观测阶 $p_{\\mathrm{obs}}$（即，对于均匀网格测试，在 $\\{2N_0, 4N_0\\}$ 之间；对于约束测试，在 $\\{h_0/2, h_0/4\\}$ 之间）。您的程序应生成单行输出，其中包含三个观测阶，以逗号分隔的列表形式并用方括号括起来，例如 `\"[p_1,p_2,p_3]\"`。这些值必须打印为浮点数。所有量都是无量纲的，因此不需要物理单位，也不涉及角度。不使用百分比；任何比率都应表示为十进制数。",
            "solution": "该问题要求构建一个数值测试工具，以测量应用于一个简化的宇宙学常微分方程（ODE）的有限差分法的观测精度阶。该问题是有效的，因为它在科学上以 Friedmann 方程为基础，在数学上是适定的，并且其实现的所有规范都已完整且明确地提供。\n\n其物理基础是空间平坦、物质主导的宇宙的 Friedmann 方程，其中哈勃参数 $H$ 对尺度因子 $a$ 的依赖关系为 $H(a) = H_0 a^{-3/2}$。在宇宙时间 $t$ 中，尺度因子的演化由 ODE $\\frac{da}{dt} = a H(a)$ 给出。通过引入无量纲时间 $\\tau = H_0 t$，该方程简化为：\n$$\n\\frac{da}{d\\tau} = a^{-1/2}\n$$\n这个 ODE 描述了在这个简化模型中宇宙的膨胀。初始值取在时间 $\\tau_0 = 0.1$ 处，以避免在 $\\tau = 0$ 处的“大爆炸”奇点。该方程可以通过分离变量法解析求解，得到尺度因子的精确解：\n$$\na(\\tau) = \\left(\\frac{2}{3}\\,\\tau\\right)^{2/3}\n$$\n程序将把 ODE 从初始时间 $\\tau_0 = 0.1$ 积分到最终时间 $\\tau_f = 1.0$。初始条件 $a(\\tau_0)$ 设置为与精确解一致，$a(\\tau_0) = (\\frac{2}{3}\\tau_0)^{2/3}$。\n\n任务的核心是使用两种单步有限差分法数值求解这个初值问题（IVP），并分析其精度。一个通用的单步法通过在离散时间点 $t_n = t_0 + n h$ 生成一系列值 $y_n \\approx y(t_n)$，来近似 IVP $y'(t) = f(t, y(t))$ 的解 $y(t)$。指定的两种方法是：\n\n$1$. **显式中点法**：这是一种二阶 Runge-Kutta 方法（$p=2$）。从时间 $\\tau_n$ 的 $a_n$ 到时间 $\\tau_{n+1} = \\tau_n + h$ 的 $a_{n+1}$ 的更新规则是：\n$$\n\\begin{align*}\nk_1 = f(\\tau_n, a_n) \\\\\nk_2 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_1\\right) \\\\\na_{n+1} = a_n + h k_2\n\\end{align*}\n$$\n其中 $f(\\tau, a) = a^{-1/2}$。\n\n$2$. **经典 Runge–Kutta 方法 (RK4)**：这是一种四阶方法（$p=4$）。其更新规则是：\n$$\n\\begin{align*}\nk_1 = f(\\tau_n, a_n) \\\\\nk_2 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_1\\right) \\\\\nk_3 = f\\left(\\tau_n + \\frac{h}{2}, a_n + \\frac{h}{2} k_2\\right) \\\\\nk_4 = f\\left(\\tau_n + h, a_n + h k_3\\right) \\\\\na_{n+1} = a_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n\n这些方法的精度由最终时间的**全局误差**来量化，$E = |a_{\\text{numerical}}(\\tau_f) - a_{\\text{exact}}(\\tau_f)|$。对于一个 $p$ 阶方法，误差预计会按 $E \\propto h^p$ 的比例缩放，其中 $h$ 是特征步长。通过计算一系列加密步长的误差，我们可以估计该方法的**观测精度阶**，$p_{\\text{obs}}$。对于两个连续的加密，其误差分别为 $E_k$ 和 $E_{k+1}$，且步长减半（$h_{k+1} = h_k/2$），观测阶由 Richardson 式比较给出：\n$$\np_{\\text{obs}} = \\log_2\\left(\\frac{E_k}{E_{k+1}}\\right)\n$$\n\n该实现将测试三种场景：\n- **测试用例 1**：显式中点法，使用均匀步长 $h_k = (\\tau_f - \\tau_0) / N_k$，网格点序列为 $N_k = \\{50, 100, 200\\}$。预期的观测阶接近 $p=2$。\n- **测试用例 2**：经典 RK4 方法，使用均匀步长 $h_k = (\\tau_f - \\tau_0) / N_k$，网格点序列为 $N_k = \\{20, 40, 80\\}$。预期的观测阶接近 $p=4$。\n- **测试用例 3**：经典 RK4 方法，使用可变的、受约束的步长。这模拟了宇宙学模拟中的一种常见做法，即时间步长受系统动力学时标（此处为哈勃时间 $H^{-1} = a^{3/2}$）的限制。在每个点 $(\\tau, a)$ 的步长 $h$ 由以下公式确定：\n$$\nh(\\tau) = \\min\\!\\big(h_{\\mathrm{ref}},\\,\\eta\\,a(\\tau)^{3/2}\\big)\n$$\n其中 $\\eta = 0.1$ 是一个安全因子。加密是通过将参考步长减半来实现的，$h_{\\mathrm{ref}} \\in \\{0.05, 0.025, 0.0125\\}$。由于步长不均匀且依赖于求解路径，观测阶可能会偏离标称阶 $4$。积分器逻辑通过在必要时缩短最后一步来确保最后一步正好落在 $\\tau_f$ 上。\n\n对于这三个测试用例中的每一个，程序将使用最后两个加密级别的误差来计算观测阶。结果将是这三个计算出的阶数的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a test harness to measure the observed order of accuracy for\n    finite difference time-integration methods on a simplified Friedmann ODE.\n    \"\"\"\n    \n    # --- Problem Definition ---\n    # Global parameters, ODE, and its exact solution\n    TAU_0 = 0.1\n    TAU_F = 1.0\n\n    def ode_rhs(tau, a):\n        \"\"\" The right-hand side of the ODE: da/d(tau) = a**(-1/2) \"\"\"\n        return a**(-0.5)\n\n    def exact_solution(tau):\n        \"\"\" The exact analytical solution: a(tau) = (2/3 * tau)**(2/3) \"\"\"\n        return (2.0/3.0 * tau)**(2.0/3.0)\n\n    A_0 = exact_solution(TAU_0)\n    A_F_EXACT = exact_solution(TAU_F)\n\n    # --- Numerical Method Steppers ---\n    def step_midpoint(f, t, y, h):\n        \"\"\"\n        Performs a single step using the explicit midpoint method (p=2).\n        \"\"\"\n        k1 = f(t, y)\n        y_mid = y + 0.5 * h * k1\n        k2 = f(t + 0.5 * h, y_mid)\n        return y + h * k2\n\n    def step_rk4(f, t, y, h):\n        \"\"\"\n        Performs a single step using the classical Runge-Kutta method (p=4).\n        \"\"\"\n        k1 = f(t, y)\n        k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n        k3 = f(t + 0.5 * h, y + 0.5 * h * k2)\n        k4 = f(t + h, y + h * k3)\n        return y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    # --- Generic Integration Driver ---\n    def integrate(stepper, step_logic_func):\n        \"\"\"\n        Integrates the ODE from TAU_0 to TAU_F using a given stepper and\n        step-size logic. The final step is adjusted to land exactly on TAU_F.\n        \"\"\"\n        t = TAU_0\n        a = A_0\n        \n        while not np.isclose(t, TAU_F):\n            h = step_logic_func(t, a)\n            \n            # Ensure the final step lands exactly on the final time\n            if t + h > TAU_F:\n                h = TAU_F - t\n            \n            a = stepper(ode_rhs, t, a, h)\n            t += h\n            \n        return a\n\n    # --- Test Harness ---\n    results = []\n    \n    # Test Case #1: Explicit Midpoint, Uniform Grid\n    case1_errors = []\n    case1_N0 = 50\n    case1_refinements = [case1_N0, 2 * case1_N0, 4 * case1_N0]\n    for N in case1_refinements:\n        h_uniform = (TAU_F - TAU_0) / N\n        step_logic = lambda t, a: h_uniform\n        a_final = integrate(step_midpoint, step_logic)\n        case1_errors.append(abs(a_final - A_F_EXACT))\n    \n    p_obs1 = np.log2(case1_errors[1] / case1_errors[2])\n    results.append(p_obs1)\n\n    # Test Case #2: Classical RK4, Uniform Grid\n    case2_errors = []\n    case2_N0 = 20\n    case2_refinements = [case2_N0, 2 * case2_N0, 4 * case2_N0]\n    for N in case2_refinements:\n        h_uniform = (TAU_F - TAU_0) / N\n        step_logic = lambda t, a: h_uniform\n        a_final = integrate(step_rk4, step_logic)\n        case2_errors.append(abs(a_final - A_F_EXACT))\n        \n    p_obs2 = np.log2(case2_errors[1] / case2_errors[2])\n    results.append(p_obs2)\n\n    # Test Case #3: Classical RK4, Constrained Step Size\n    case3_errors = []\n    case3_h0 = 0.05\n    case3_eta = 0.1\n    case3_refinements = [case3_h0, case3_h0 / 2.0, case3_h0 / 4.0]\n    for h_ref in case3_refinements:\n        # The lambda captures h_ref and case3_eta from the enclosing scope\n        step_logic = lambda t, a: min(h_ref, case3_eta * a**1.5)\n        a_final = integrate(step_rk4, step_logic)\n        case3_errors.append(abs(a_final - A_F_EXACT))\n    \n    p_obs3 = np.log2(case3_errors[1] / case3_errors[2])\n    results.append(p_obs3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}