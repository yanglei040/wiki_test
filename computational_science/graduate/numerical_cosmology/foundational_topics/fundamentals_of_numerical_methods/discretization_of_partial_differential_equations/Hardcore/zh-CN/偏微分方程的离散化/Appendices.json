{
    "hands_on_practices": [
        {
            "introduction": "在宇宙学模拟中，我们经常遇到“刚性”方程，其中包含在迥异的时间尺度上运行的物理过程。例如，物质的平流可能比哈勃阻尼慢得多。隐式-显式（IMEX）方法是处理这种情况的强大工具，它对快尺度项使用稳定的隐式处理，对慢尺度项使用高效的显式处理。这个练习将引导您通过分析一个典型的IMEX格式的线性稳定性，来掌握评估这些数值方案核心性能的基础技能。",
            "id": "3470353",
            "problem": "考虑一个对共动坐标系中线性化宇宙学流体模式的半离散线方法近似，其中单个傅里叶模式的振幅 $u(t)$ 服从常微分方程 $\\partial_{t} u(t) = -\\lambda u(t) - \\mu u(t)$，其中常数率 $\\lambda \\geq 0$ 和 $\\mu \\geq 0$ 的单位为 $\\mathrm{s}^{-1}$。在此，$\\lambda$ 来自显式处理的非刚性输运算子（例如，共动平流或源耦合），而 $\\mu$ 来自隐式处理的刚性阻尼算子（例如，哈勃拖曳或碰撞项）。采用一阶隐式-显式（IMEX）方法，其中在一个大小为 $\\Delta t$ 的组合时间步长内，显式部分对 $\\lambda$ 的贡献使用前向欧拉法，隐式部分对 $\\mu$ 的贡献使用后向欧拉法。假设显式和隐式算子在此模式上是可交换的，因此它们的特征值相加，并且底层的空间离散化产生实非负谱率。\n\n从半离散演化定律和所描述的IMEX时间离散化出发，推导单步放大因子，并用它来确定此IMEX更新的组合线性稳定性要求（用 $\\lambda$、$\\mu$ 和 $\\Delta t$ 表示）。在假设 $0 \\leq \\mu  \\lambda$ 的条件下，计算允许的最大时间步长 $\\Delta t_{\\max}$，使得对于区间 $0 \\leq \\Delta t \\leq \\Delta t_{\\max}$ 内的所有 $\\Delta t$，更新都是线性稳定的。将你的最终答案表示为 $\\Delta t_{\\max}$ 的闭式解析表达式，单位为秒。不需要进行数值计算，也不应进行四舍五入。",
            "solution": "首先将验证问题的科学和数学合理性、完整性和清晰性。\n\n### 步骤 1：提取已知条件\n- 单个傅里叶模式振幅 $u(t)$ 的半离散演化方程为 $\\partial_{t} u(t) = -\\lambda u(t) - \\mu u(t)$。\n- 率 $\\lambda$ 和 $\\mu$ 是常数，满足 $\\lambda \\geq 0$ 和 $\\mu \\geq 0$，单位为 $\\mathrm{s}^{-1}$。\n- 项 $-\\lambda u(t)$ 来自一个非刚性算子，并被显式处理。\n- 项 $-\\mu u(t)$ 来自一个刚性算子，并被隐式处理。\n- 时间步进格式为一阶隐式-显式（IMEX）方法。\n- 显式部分（对于 $\\lambda$）使用前向欧拉法。\n- 隐式部分（对于 $\\mu$）使用后向欧拉法。\n- 时间步长用 $\\Delta t$ 表示。\n- 假设显式和隐式算子是可交换的。\n- 假设底层的空间离散化产生实数、非负的谱率。\n- 最终计算在 $0 \\leq \\mu  \\lambda$ 的假设下进行。\n- 目标是推导单步放大因子、线性稳定性要求以及允许的最大稳定时间步长 $\\Delta t_{\\max}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学或事实不合理性**：该问题在科学和数学上是合理的。它描述了应用于一个线性常微分方程的标准一阶IMEX（前向欧拉/后向欧拉）格式的线性稳定性分析，这是求解刚性微分方程的数值分析中的一种基本技术。这类方程是物理现象（包括线性化的宇宙学扰动）的常见模型。没有违反科学原理的地方。\n2.  **非形式化或不相关**：该问题是高度形式化的，并且与偏微分方程离散化的主题直接相关，这是数值宇宙学的核心关注点。\n3.  **不完整或矛盾的设置**：该问题是自洽的，并提供了进行推导所需的所有必要信息。常微分方程、数值方法、参数和所有必要的假设都已明确说明。没有内部矛盾。\n4.  **不切实际或不可行**：该设置是用于分析数值方法稳定性的标准简化模型（Dahlquist测试方程）。它在数学上是可行的，并代表了一个更复杂物理系统的有效理想化。\n5.  **不适定或结构不良**：该问题是适定的。它要求一个明确的数学推导，该推导会得出一个唯一且有意义的结果。所有术语在数值分析领域都是标准的。\n6.  **伪深刻、琐碎或同义反复**：该问题是数值稳定性理论中一个标准的、非琐碎的练习。它需要正确应用定义和代数操作。\n7.  **超出科学可验证性**：该推导是纯数学的，因此可以通过逻辑和代数规则进行验证。\n\n### 步骤 3：结论与行动\n问题是有效的。现在将提供完整的解答。\n\n### 解答的推导\n控制模式振幅 $u(t)$ 演化的半离散常微分方程（ODE）由下式给出：\n$$\n\\frac{d u}{d t} = -\\lambda u - \\mu u\n$$\n我们使用大小为 $\\Delta t$ 的单个步长对该方程进行时间离散化。令 $u^n$ 表示在时间 $t_n = n \\Delta t$ 时对 $u(t_n)$ 的数值近似。下一个状态是时间 $t_{n+1} = t_n + \\Delta t$ 时的 $u^{n+1}$。\n\n问题指定了一阶IMEX格式。项 $-\\lambda u$ 使用前向欧拉法进行显式处理，意味着它在时间 $t_n$ 进行评估。项 $-\\mu u$ 使用后向欧拉法进行隐式处理，意味着它在时间 $t_{n+1}$ 进行评估。结合这些，对常微分方程的有限差分近似为：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = -\\lambda u^n - \\mu u^{n+1}\n$$\n我们的第一个目标是找到单步放大因子 $g(\\lambda, \\mu, \\Delta t)$，它由关系式 $u^{n+1} = g \\cdot u^n$ 定义。为了找到 $g$，我们必须重新整理离散化方程，以 $u^n$ 的形式求解 $u^{n+1}$。\n\n从离散化方程开始：\n$$\nu^{n+1} - u^n = \\Delta t (-\\lambda u^n - \\mu u^{n+1})\n$$\n我们将所有包含 $u^{n+1}$ 的项移到左边，所有包含 $u^n$ 的项移到右边：\n$$\nu^{n+1} + \\mu \\Delta t u^{n+1} = u^n - \\lambda \\Delta t u^n\n$$\n将 $u^{n+1}$ 和 $u^n$ 提取出来：\n$$\nu^{n+1} (1 + \\mu \\Delta t) = u^n (1 - \\lambda \\Delta t)\n$$\n求解 $u^{n+1}$ 得出：\n$$\nu^{n+1} = \\left( \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t} \\right) u^n\n$$\n根据定义，括号中的表达式就是放大因子 $g$：\n$$\ng(\\lambda, \\mu, \\Delta t) = \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t}\n$$\n为了使数值方法线性稳定，放大因子的模不得超过1。也就是说，稳定性要求是：\n$$\n|g| \\leq 1\n$$\n代入 $g$ 的表达式：\n$$\n\\left| \\frac{1 - \\lambda \\Delta t}{1 + \\mu \\Delta t} \\right| \\leq 1\n$$\n问题陈述了 $\\mu \\geq 0$ 且时间步长 $\\Delta t$ 是非负的，所以 $\\Delta t \\geq 0$。因此，分母 $1 + \\mu \\Delta t$ 始终为正且大于或等于1。我们可以在不等式两边乘以 $1 + \\mu \\Delta t$ 而不改变不等式的方向：\n$$\n|1 - \\lambda \\Delta t| \\leq 1 + \\mu \\Delta t\n$$\n这个绝对值不等式等价于以下两个不等式：\n$$\n-(1 + \\mu \\Delta t) \\leq 1 - \\lambda \\Delta t \\leq 1 + \\mu \\Delta t\n$$\n我们必须同时满足这两个不等式。\n\n我们首先分析右边的那个不等式：\n$$\n1 - \\lambda \\Delta t \\leq 1 + \\mu \\Delta t\n$$\n$$\n-\\lambda \\Delta t \\leq \\mu \\Delta t\n$$\n$$\n0 \\leq (\\lambda + \\mu) \\Delta t\n$$\n因为 $\\lambda \\geq 0$，$\\mu \\geq 0$，以及 $\\Delta t \\geq 0$，这个条件总是满足的，并且没有对 $\\Delta t$ 施加任何上限。\n\n现在，我们分析左边的那个不等式：\n$$\n-(1 + \\mu \\Delta t) \\leq 1 - \\lambda \\Delta t\n$$\n$$\n-1 - \\mu \\Delta t \\leq 1 - \\lambda \\Delta t\n$$\n重新整理各项以分离出 $\\Delta t$：\n$$\n\\lambda \\Delta t - \\mu \\Delta t \\leq 1 + 1\n$$\n$$\n(\\lambda - \\mu) \\Delta t \\leq 2\n$$\n这就是该IMEX格式的一般线性稳定性要求。\n\n问题的最后一部分要求在特定假设 $0 \\leq \\mu  \\lambda$ 下，求出允许的最大时间步长 $\\Delta t_{\\max}$。这个假设意味着项 $(\\lambda - \\mu)$ 是严格为正的。由于 $(\\lambda - \\mu) > 0$，我们可以用它来除稳定性不等式而不改变不等式的方向：\n$$\n\\Delta t \\leq \\frac{2}{\\lambda - \\mu}\n$$\n为使方法稳定，这个不等式必须成立。问题要求找到最大的允许时间步长 $\\Delta t_{\\max}$，使得对于区间 $0 \\leq \\Delta t \\leq \\Delta t_{\\max}$ 内的所有 $\\Delta t$，更新都是线性稳定的。这意味着 $\\Delta t_{\\max}$ 是这个稳定区间的上限。\n因此，允许的最大时间步长是：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\lambda - \\mu}\n$$\n$\\lambda$ 和 $\\mu$ 的单位是 $\\mathrm{s}^{-1}$，所以 $\\Delta t_{\\max}$ 的单位是 $1 / (\\mathrm{s}^{-1}) = \\mathrm{s}$，这与问题的要求一致。",
            "answer": "$$\n\\boxed{\\frac{2}{\\lambda - \\mu}}\n$$"
        },
        {
            "introduction": "从时间积分的理论稳定性转向空间离散化和源项耦合的实际挑战。宇宙学模拟通常演化一个占主导地位且不断演化的背景解上的小扰动。一个被称为“良好平衡”的数值格式必须能在数值上精确地维持这个背景解，以防止虚假的数值误差污染物理演化。这个练习将指导您设计并实现一个这样的方案，它能精确地保持宇宙学扰动方程的平凡解，同时准确地解析增长和衰减模式。",
            "id": "3470311",
            "problem": "要求您设计并实现一种数值方法，该方法对于物质主导、空间平坦宇宙中的一维线性宇宙学微扰方程是良态平衡的。该方法必须能精确地维持平凡解 $ \\delta(x,\\tau)=0 $ 和 $ \\theta(x,\\tau)=0 $，同时准确地解析线性微扰的增长模和衰减模。目标是在尊重宇宙学背景的情况下，对控制性偏微分方程（PDE）进行空间和时间上的离散化，并在一组给定的初始条件下测试该格式。\n\n其基本理论基础是 Einstein–de Sitter 宇宙中无压物质在牛顿极限下的线性微扰理论。在共形时间 $ \\tau $ 下，设标度因子为 $ a(\\tau) $，共形哈勃参数为 $ \\mathcal{H}(\\tau) = a'(\\tau)/a(\\tau) $，则密度对比 $ \\delta(x,\\tau) $、本动速度 $ u(x,\\tau) $ 和引力势 $ \\phi(x,\\tau) $ 的线性化一维系统为：\n- $ \\partial_{\\tau} \\delta + \\partial_{x} u = 0 $，\n- $ \\partial_{\\tau} u + \\mathcal{H} u = - \\partial_{x} \\phi $，\n- $ \\partial_{x}^{2} \\phi = \\frac{3}{2} \\mathcal{H}^{2} \\delta $。\n\n在 Einstein–de Sitter 背景下，取单位使得 $ \\tau_{0} = 1 $ 且\n- $ a(\\tau) = \\tau^{2} $，\n- $ \\mathcal{H}(\\tau) = \\frac{2}{\\tau} $，\n- $ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $。\n\n定义速度散度 $ \\theta = \\partial_{x} u $。平凡态 $ \\delta = 0 $ 和 $ \\theta = 0 $ 是一个精确解。在傅里叶空间中，每个模式 $ \\delta_{k}(\\tau) $ 服从线性常微分方程（ODE）\n$$\n\\delta_{k}'' + \\mathcal{H} \\, \\delta_{k}' - \\frac{3}{2} \\mathcal{H}^{2} \\delta_{k} = 0,\n$$\n在此背景下，其两个独立解分别是增长模 $ \\delta_{k} \\propto \\tau^{2} $ 和衰减模 $ \\delta_{k} \\propto \\tau^{-3} $。\n\n算法设计要求：\n- 在周期性区域 $ x \\in [0, L] $（其中 $ L = 2\\pi $）上使用傅里叶伪谱方法进行空间离散化。对于任意场 $ f(x) $，通过快速傅里叶变换（FFT）微分法则 $ \\widehat{\\partial_{x} f}(k) = i k \\hat{f}(k) $ 来计算 $ \\partial_{x} f $，其中 $ k = \\frac{2\\pi n}{L} $，n 为整数。\n- 在傅里叶空间中逐模式求解泊松方程，当 $ k \\neq 0 $ 时使用 $ \\hat{\\phi}(k) = - \\frac{6}{\\tau^{2}} \\frac{\\hat{\\delta}(k)}{k^{2}} $，并设置 $ \\hat{\\phi}(0) = 0 $。\n- 为了实现能够精确维持 $ \\delta = 0 $ 和 $ \\theta = 0 $ 的良态平衡时间离散化，通过引入积分因子变量 $ w = a(\\tau) u $ 来消除线性阻尼项。系统变为\n  - $ \\partial_{\\tau} \\delta = - \\frac{1}{a(\\tau)} \\partial_{x} w $，\n  - $ \\partial_{\\tau} w = - a(\\tau) \\, \\partial_{x} \\phi $，\n  - $ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $，\n  背景为 $ a(\\tau) = \\tau^{2} $。如果对通量项和源项使用一致的空间离散化，此变换可确保 $ (\\delta, w) \\equiv (0, 0) $ 是一个精确的数值平衡态。\n- 使用两阶段显式龙格-库塔方法（休恩方法）对共形时间 $ \\tau $ 进行积分。\n\n测试套件和参数：\n- 空间区域：$ L = 2\\pi $，有 $ N = 128 $ 个等间距网格点。所有量均为无量纲；不需要物理单位。\n- 初始和最终共形时间：$ \\tau_{i} = 1 $ 和 $ \\tau_{f} = 5 $。\n- 时间步进：使用均匀时间步长，步数为 $ N_{\\text{steps}} = 2000 $。\n- 激发的波数：$ k_{\\star} = 3 $（与周期性区域兼容的整数）。\n- 良态平衡性质的容差：$ \\text{tol}_{0} = 10^{-12} $。\n- 测试用振幅：增长模振幅 $ A_{g} = 10^{-3} $，衰减模振幅 $ A_{d} = 10^{-3} $。\n- 混合模振幅：$ A_{g}^{(m)} = 7 \\times 10^{-4} $ 和 $ A_{d}^{(m)} = 3 \\times 10^{-3} $。\n\n构建以下四个测试用例：\n1. 平凡态的精确维持：设置 $ \\delta(x,\\tau_{i}) \\equiv 0 $ 和 $ u(x,\\tau_{i}) \\equiv 0 $。演化至 $ \\tau_{f} $，并计算 $ \\max\\{\\|\\delta(\\cdot,\\tau_{f})\\|_{\\infty}, \\|\\theta(\\cdot,\\tau_{f})\\|_{\\infty}\\} $。报告一个布尔值，指示该最大值是否 $ \\le \\text{tol}_{0} $。\n2. 波数为 $ k_{\\star} $ 的纯增长模：初始化 $ \\delta(x,\\tau_{i}) = A_{g} \\cos(k_{\\star} x) $，并选择 $ u(x,\\tau_{i}) $ 以确保只有增长模存在。对于增长分支，使用 $ \\delta(\\tau) = C_{1} \\tau^{2} $ 意味着 $ \\delta'(\\tau_{i}) = 2 C_{1} \\tau_{i} = 2 A_{g} $。由于 $ \\theta = -\\delta' $ 且 $ \\theta = \\partial_{x} u $，设置 $ u(x,\\tau_{i}) = \\frac{\\theta_{\\text{amp}}}{k_{\\star}} \\sin(k_{\\star} x) $，其中 $ \\theta_{\\text{amp}} = -2 A_{g} $。演化后，将数值解 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上以获得振幅 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{g} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{2} $。报告相对误差 $ \\left| A_{\\text{num}} - A_{\\text{ana}} \\right| / \\left| A_{\\text{ana}} \\right| $，结果为浮点数。\n3. 波数为 $ k_{\\star} $ 的纯衰减模：初始化 $ \\delta(x,\\tau_{i}) = A_{d} \\cos(k_{\\star} x) $，并选择 $ u(x,\\tau_{i}) $ 以确保只有衰减模存在。使用 $ \\delta(\\tau) = C_{2} \\tau^{-3} $ 意味着 $ \\delta'(\\tau_{i}) = -3 C_{2} \\tau_{i}^{-4} = -3 A_{d} $。设置 $ \\theta_{\\text{amp}} = -\\delta'(\\tau_{i}) = 3 A_{d} $ 和 $ u(x,\\tau_{i}) = \\frac{\\theta_{\\text{amp}}}{k_{\\star}} \\sin(k_{\\star} x) $。演化后，将 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上得到 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{d} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{-3} $。报告相对误差，结果为浮点数。\n4. 相同波数 $ k_{\\star} $ 的混合增长与衰减模：设置 $ \\delta(x,\\tau_{i}) = \\left(A_{g}^{(m)} + A_{d}^{(m)}\\right) \\cos(k_{\\star} x) $ 和 $ u(x,\\tau_{i}) = \\frac{-2 A_{g}^{(m)} + 3 A_{d}^{(m)}}{k_{\\star}} \\sin(k_{\\star} x) $。演化后，将 $ \\delta(x,\\tau_{f}) $ 投影到 $ \\cos(k_{\\star} x) $ 上得到 $ A_{\\text{num}} $。解析振幅为 $ A_{\\text{ana}} = A_{g}^{(m)} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{2} + A_{d}^{(m)} \\left(\\frac{\\tau_{f}}{\\tau_{i}}\\right)^{-3} $。报告相对误差，结果为浮点数。\n\n输出规格：\n- 您的程序必须运行这四个测试，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：$ [\\text{wb\\_ok}, \\text{err\\_grow}, \\text{err\\_decay}, \\text{err\\_mix}] $，其中 $ \\text{wb\\_ok} $ 是一个布尔值，而误差是浮点数。\n- 所有量均为无量纲；不需要物理单位。\n- 角度参数以弧度为单位。\n\n您的最终结果必须是一个完整且可运行的程序，实现所述的离散化和测试，无需任何用户输入或外部文件。程序必须仅使用指定的库，并严格按照描述的格式打印结果。",
            "solution": "该问题要求设计并实现一个良态平衡的数值格式，用于求解物质主导的 Einstein–de Sitter 宇宙中的一维线性宇宙学微扰方程。该格式必须通过四个特定的测试用例进行验证：平凡解的维持、纯增长模的精确演化、纯衰减模的精确演化以及混合微扰模的精确演化。\n\n在共形时间 $\\tau$ 中，密度对比 $\\delta(x,\\tau)$ 和本动速度 $u(x,\\tau)$ 的控制方程为：\n$$ \\partial_{\\tau} \\delta + \\partial_{x} u = 0 $$\n$$ \\partial_{\\tau} u + \\mathcal{H} u = - \\partial_{x} \\phi $$\n$$ \\partial_{x}^{2} \\phi = \\frac{3}{2} \\mathcal{H}^{2} \\delta $$\n在指定的 Einstein–de Sitter 背景中，标度因子为 $a(\\tau) = \\tau^2$，共形哈勃参数为 $\\mathcal{H}(\\tau) = 2/\\tau$，这使得泊松方程简化为 $\\partial_{x}^{2} \\phi = (6/\\tau^2) \\delta$。欧拉方程中的 $\\mathcal{H} u$ 项是一个阻尼项，在试图维持平衡态 $\\delta=0, u=0$ 时可能会引入数值误差。\n\n一个良态平衡的格式是指能够精确（在机器精度范围内）维持一个已知的稳态解或平衡解的格式。为实现此目的，我们遵循问题的规定并进行变量变换。我们引入 $w = a(\\tau) u$。原始变量 $(\\delta, u)$ 的时间导数与新变量 $w$ 的关系如下：\n$\\partial_{\\tau} u = \\partial_{\\tau} (w/a) = (1/a)\\partial_{\\tau} w - (a'/a^2)w = (1/a)\\partial_{\\tau}w - (\\mathcal{H}/a)w$。\n将此式代入欧拉方程：\n$$ \\frac{1}{a}\\partial_{\\tau}w - \\frac{\\mathcal{H}}{a}w + \\mathcal{H}u = -\\partial_x \\phi $$\n$$ \\frac{1}{a}\\partial_{\\tau}w - \\frac{\\mathcal{H}}{a}w + \\frac{\\mathcal{H}}{a}w = -\\partial_x \\phi $$\n$$ \\partial_{\\tau}w = -a(\\tau)\\partial_x \\phi $$\n连续性方程变为 $\\partial_{\\tau}\\delta = -\\partial_x u = -\\partial_x(w/a) = -(1/a)\\partial_x w$。\n这样就得到了待求解的变换后的系统：\n$$ \\partial_{\\tau} \\delta = - \\frac{1}{a(\\tau)} \\partial_{x} w $$\n$$ \\partial_{\\tau} w = - a(\\tau) \\, \\partial_{x} \\phi $$\n$$ \\partial_{x}^{2} \\phi = \\frac{6}{\\tau^{2}} \\delta $$\n在这种形式下，如果 $\\delta=0$ 且 $w=0$，那么 $\\phi=0$（根据泊松方程），因此 $\\delta$ 和 $w$ 的演化方程的右侧恒等于零。这确保了只要对这些方程进行一致的离散化，数值格式就能维持 $(\\delta, w) = (0,0)$ 的状态。\n\n数值实现过程如下：\n\n**1. 空间离散化：傅里叶伪谱方法**\n空间区域是周期性的，$x \\in [0, L]$，其中 $L=2\\pi$，用 $N=128$ 个点 $x_j = j L/N$（$j=0, \\dots, N-1$）进行离散化。这种选择使得傅里叶方法异常精确。空间导数 $\\partial_x f(x)$ 在傅里叶空间中计算。一个函数 $f(x)$ 通过快速傅里叶变换（FFT）得到其傅里叶系数 $\\hat{f}(k_n)$。其导数的傅里叶系数则由 $\\widehat{\\partial_x f}(k_n) = i k_n \\hat{f}(k_n)$ 给出，其中 $k_n$ 是离散波数。通过应用逆FFT，可以恢复实空间中的导数 $\\partial_x f(x)$。由于 $L=2\\pi$，波数为 $k_n = 2\\pi n / L = n$。\n\n泊松方程 $\\partial_{x}^{2} \\phi = (6/\\tau^2) \\delta$ 在傅里叶空间中变成一个代数方程：\n$$ (i k_n)^2 \\hat{\\phi}(k_n) = -k_n^2 \\hat{\\phi}(k_n) = \\frac{6}{\\tau^2} \\hat{\\delta}(k_n) $$\n对于 $k_n \\neq 0$ 的模式，势可以通过 $\\hat{\\phi}(k_n) = -\\frac{6}{\\tau^2} \\frac{\\hat{\\delta}(k_n)}{k_n^2}$ 求解。对于平均模式 $k_n=0$，按规定设置 $\\hat{\\phi}(0)=0$。\n\n**2. 时间离散化：休恩方法**\n我们使用两阶段显式龙格-库塔格式（休恩方法）将状态向量 $Y = [\\delta, w]$ 从时间 $\\tau_n$ 推进到 $\\tau_{n+1} = \\tau_n + \\Delta\\tau$。设我们系统的右侧为 $F(Y, \\tau) = [\\dot{\\delta}, \\dot{w}]$。\n更新规则是：\n1. **预测步：** $Y^* = Y_n + \\Delta\\tau F(Y_n, \\tau_n)$\n2. **校正步：** $Y_{n+1} = Y_n + \\frac{\\Delta\\tau}{2} \\left[ F(Y_n, \\tau_n) + F(Y^*, \\tau_n + \\Delta\\tau) \\right]$\n\n**3. 算法实现与测试用例**\n模拟从 $\\tau_i=1$ 运行到 $\\tau_f=5$，步数为 $N_{\\text{steps}}=2000$，时间步长为 $\\Delta\\tau = (\\tau_f - \\tau_i)/N_{\\text{steps}} = 0.002$。\n\n- **测试 1 (平凡态)：** 我们初始化 $\\delta(x, \\tau_i)=0$ 和 $u(x, \\tau_i)=0$。由于 $a(\\tau_i)=\\tau_i^2 = 1$，初始的 $w(x, \\tau_i)$ 也为 $0$。模拟演化至 $\\tau_f$。最终的速度散度 $\\theta(\\cdot, \\tau_f) = \\partial_x u(\\cdot, \\tau_f)$ 通过最终状态 $w(\\cdot, \\tau_f)$ 计算得出，即 $u_f = w_f / a(\\tau_f)$ 和谱方法微分。如果 $\\max\\{\\|\\delta_f\\|_{\\infty}, \\|\\theta_f\\|_{\\infty}\\} \\le 10^{-12}$，则结果为 `True`。\n\n- **测试 2 (增长模)：** 初始条件被设置为在波数 $k_{\\star}=3$ 下振幅为 $A_g=10^{-3}$ 的纯增长模。关系式 $\\theta = -\\partial_\\tau \\delta$ 和增长模形式 $\\delta \\propto \\tau^2$ 意味着 $\\theta(\\tau_i)=-2\\delta(\\tau_i)/\\tau_i = -2A_g$（因为 $\\tau_i=1$）。初始状态为 $\\delta(x, \\tau_i) = A_g \\cos(k_{\\star} x)$ 和 $u(x, \\tau_i) = \\frac{-2A_g}{k_{\\star}} \\sin(k_{\\star} x)$。状态演化至 $\\tau_f$。最终密度对比 $\\delta(\\cdot, \\tau_f)$ 中的数值振幅 $A_{\\text{num}}$ 通过将其投影到 $\\cos(k_{\\star}x)$ 上找到。这可以通过FFT高效完成：对于实信号，$\\cos(k_{\\star}x)$ 分量的振幅由 $\\frac{2}{N}\\text{Re}(\\hat\\delta_f[k_{\\star}])$ 给出。解析振幅为 $A_{\\text{ana}} = A_g (\\tau_f/\\tau_i)^2$。报告相对误差。\n\n- **测试 3 (衰减模)：** 此测试与测试2类似。对于衰减模 $\\delta \\propto \\tau^{-3}$，我们有 $\\theta(\\tau_i)=-(-3)\\delta(\\tau_i)/\\tau_i=3A_d$。初始条件为 $\\delta(x, \\tau_i) = A_d \\cos(k_{\\star} x)$ 和 $u(x, \\tau_i) = \\frac{3A_d}{k_{\\star}} \\sin(k_{\\star} x)$，其中 $A_d=10^{-3}$。解析的最终振幅为 $A_{\\text{ana}} = A_d (\\tau_f/\\tau_i)^{-3}$。报告相对误差。\n\n- **测试 4 (混合模)：** 初始条件是增长模和衰减模的线性叠加：$\\delta(x, \\tau_i) = (A_g^{(m)} + A_d^{(m)}) \\cos(k_{\\star}x)$，并相应地设置 $u(x, \\tau_i)$。最终的数值振幅与解析解 $A_{\\text{ana}} = A_{g}^{(m)} (\\tau_f/\\tau_i)^{2} + A_{d}^{(m)} (\\tau_f/\\tau_i)^{-3}$进行比较。报告相对误差。\n\n该实现将这些原理结合到一个单独的程序中，该程序运行所有四个测试并以指定格式输出结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear cosmological perturbation equations using a\n    well-balanced Fourier pseudo-spectral scheme and Heun's method for time integration.\n    \"\"\"\n    \n    # Define parameters from the problem statement.\n    L = 2.0 * np.pi\n    N = 128\n    tau_i = 1.0\n    tau_f = 5.0\n    N_steps = 2000\n    k_star = 3\n    tol_0 = 1e-12\n    A_g = 1e-3\n    A_d = 1e-3\n    A_g_m = 7e-4\n    A_d_m = 3e-3\n\n    # Spatial grid and wavenumbers\n    x = np.linspace(0, L, N, endpoint=False)\n    dx = L / N\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Time step\n    dt = (tau_f - tau_i) / N_steps\n\n    # Precompute the k^-2 operator for the Poisson solve\n    k_sq_inv = np.zeros_like(k)\n    nonzero_k_mask = k != 0\n    k_sq_inv[nonzero_k_mask] = 1.0 / (k[nonzero_k_mask]**2)\n\n    def get_rhs(delta, w, tau):\n        \"\"\"\n        Computes the right-hand side of the transformed system for (delta, w).\n        d(delta)/d(tau) = - (1/a) * d_x(w)\n        d(w)/d(tau)     = - a * d_x(phi)\n        \"\"\"\n        # Transform state variables to Fourier space\n        delta_hat = np.fft.fft(delta)\n        w_hat = np.fft.fft(w)\n\n        # Solve Poisson equation for phi_hat in Fourier space\n        # phi_hat(k) = - (6/tau^2) * delta_hat(k) / k^2\n        phi_hat = - (6.0 / tau**2) * delta_hat * k_sq_inv\n        \n        # Compute spatial derivatives in Fourier space\n        # d_x(f_hat) = ik * f_hat\n        dx_w_hat = 1j * k * w_hat\n        dx_phi_hat = 1j * k * phi_hat\n\n        # Transform derivatives back to real space\n        dx_w = np.fft.ifft(dx_w_hat).real\n        dx_phi = np.fft.ifft(dx_phi_hat).real\n\n        # Scale factor a(tau) = tau^2\n        a_tau = tau**2\n\n        # Compute time derivatives\n        d_delta_dt = - (1.0 / a_tau) * dx_w\n        d_w_dt = - a_tau * dx_phi\n\n        return d_delta_dt, d_w_dt\n\n    def evolve(delta_0, w_0):\n        \"\"\"\n        Evolves the system from tau_i to tau_f using Heun's method.\n        \"\"\"\n        delta = delta_0.copy()\n        w = w_0.copy()\n        tau = tau_i\n\n        for _ in range(N_steps):\n            # Stage 1 (Predictor)\n            k1_delta, k1_w = get_rhs(delta, w, tau)\n            delta_star = delta + dt * k1_delta\n            w_star = w + dt * k1_w\n            \n            # Stage 2 (Corrector)\n            k2_delta, k2_w = get_rhs(delta_star, w_star, tau + dt)\n            \n            # Update state variables\n            delta += (dt / 2.0) * (k1_delta + k2_delta)\n            w += (dt / 2.0) * (k1_w + k2_w)\n            tau += dt\n            \n        return delta, w\n\n    results = []\n\n    # --- Test 1: Exact preservation of the trivial state ---\n    delta_0_t1 = np.zeros(N)\n    u_0_t1 = np.zeros(N)\n    w_0_t1 = u_0_t1 * (tau_i**2)\n    delta_f, w_f = evolve(delta_0_t1, w_0_t1)\n    \n    # Compute final velocity divergence theta\n    u_f = w_f / (tau_f**2)\n    u_f_hat = np.fft.fft(u_f)\n    theta_f_hat = 1j * k * u_f_hat\n    theta_f = np.fft.ifft(theta_f_hat).real\n    \n    max_err = max(np.max(np.abs(delta_f)), np.max(np.abs(theta_f)))\n    results.append(max_err = tol_0)\n\n    # --- Function to run a test and compute relative error ---\n    def run_and_get_error(delta_0, u_0, A_ana):\n        w_0 = u_0 * (tau_i**2)\n        delta_f, _ = evolve(delta_0, w_0)\n        delta_f_hat = np.fft.fft(delta_f)\n        # Amplitude of cos(k*x) is (2/N) * Re(fft[k]) for real signals\n        A_num = (2.0 / N) * delta_f_hat[k_star].real\n        return np.abs(A_num - A_ana) / np.abs(A_ana)\n\n    # --- Test 2: Pure growing mode ---\n    delta_0_g = A_g * np.cos(k_star * x)\n    u_0_g = (-2.0 * A_g / k_star) * np.sin(k_star * x)\n    A_ana_g = A_g * (tau_f / tau_i)**2\n    err_grow = run_and_get_error(delta_0_g, u_0_g, A_ana_g)\n    results.append(err_grow)\n\n    # --- Test 3: Pure decaying mode ---\n    delta_0_d = A_d * np.cos(k_star * x)\n    u_0_d = (3.0 * A_d / k_star) * np.sin(k_star * x)\n    A_ana_d = A_d * (tau_f / tau_i)**(-3.0)\n    err_decay = run_and_get_error(delta_0_d, u_0_d, A_ana_d)\n    results.append(err_decay)\n    \n    # --- Test 4: Mixed growing and decaying mode ---\n    delta_0_m = (A_g_m + A_d_m) * np.cos(k_star * x)\n    u_0_m = ((-2.0 * A_g_m + 3.0 * A_d_m) / k_star) * np.sin(k_star * x)\n    A_ana_m = A_g_m * (tau_f / tau_i)**2 + A_d_m * (tau_f / tau_i)**(-3.0)\n    err_mix = run_and_get_error(delta_0_m, u_0_m, A_ana_m)\n    results.append(err_mix)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在我们将前面的概念结合起来，应用于现代宇宙学的一个核心课题：标量场的动力学。无论是在暴胀模型还是暗能量理论中，标量场的演化方程都包含一个“哈勃摩擦”项，这使其成为一个典型的刚性系统。这项实践要求您为一个实际的标量场方程实现一个IMEX积分器，将您在第一个练习中分析的理论付诸实践，并验证其关键属性，如在特定物理极限下的正确行为（渐近保持性）。",
            "id": "3470393",
            "problem": "考虑在空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 宇宙中，以共形时间表示的标量场方程，\n$$\n\\phi'' + 2\\mathcal{H}\\,\\phi' - \\nabla^2 \\phi + V'(\\phi) = 0,\n$$\n其中 $\\phi = \\phi(\\mathbf{x},\\tau)$ 是标量场，$\\tau$ 是共形时间，$\\mathcal{H} = a'(\\tau)/a(\\tau)$ 是共形哈勃率，$V(\\phi)$ 是自相互作用势。引入辅助动量场 $\\pi = \\phi'$，使得该系统可以写成\n$$\n\\phi' = \\pi, \\quad \\pi' = -2\\mathcal{H}\\,\\pi + \\nabla^2 \\phi - V'(\\phi).\n$$\n您将构建一个隐式-显式 (IMEX) 的时间步进格式，即对线性摩擦项采用隐式处理，对其余项采用显式处理，并分析其在 $\\mathcal{H} \\to 0$ 时的渐近保持行为。您的设计和分析必须从第一性原理出发，仅使用上述控制方程，不得引入简化公式。\n\n空间离散化必须在长度为 $L$ 的一维周期性区域上进行，该区域有 $N$ 个均匀间隔的网格点，网格间距为 $\\Delta x = L/N$。使用二阶中心有限差分来处理一维拉普拉斯算子 $\\nabla^2 \\phi \\to \\partial_{xx}\\phi$，并采用周期性边界条件。所有量均应按无量纲单位处理，任何三角函数参数都必须以弧度为单位。\n\n将势的导数定义为\n$$\nV'(\\phi) = m^2 \\phi + \\lambda \\phi^3,\n$$\n其中 $m$ 和 $\\lambda$ 是无量纲参数。时间步长为 $\\Delta t$，总时间步数为 $M$，对应的最终积分时间为 $T = M \\Delta t$。\n\n任务：\n- 从一阶系统出发，构建一个隐式-显式 (IMEX) 时间积分器，其中线性摩擦项 $-2\\mathcal{H}\\,\\pi$ 被隐式处理，而空间拉普拉斯算子 $\\nabla^2 \\phi$ 和非线性势项 $-V'(\\phi)$ 被显式处理。该格式必须在空间网格上将场从时间层 $n$ 更新到 $n+1$。\n- 在周期性网格上使用二阶中心有限差分算子离散化一维拉普拉斯算子，并描述其对具有整数波数 $k$ 的单个傅里叶模式 $\\phi(x) = \\cos(k x)$ 的作用。\n- 分析您的 IMEX 格式在 $\\mathcal{H} \\to 0$ 时的渐近保持极限，并解释在该极限下它会退化为何种显式时间离散格式。\n- 对于 $\\nabla^2 \\phi = 0$ 且 $V'(\\phi) = 0$ 的仅有摩擦的情况，推导由 $-2\\mathcal{H}\\,\\pi$ 的隐式处理所引起的精确每步阻尼因子。\n\n实现要求：\n- 使用数值数组和指定的空间离散化方法，在一维周期性网格上实现您的 IMEX 格式。\n- 所有量均使用无量纲单位；角度必须以弧度为单位。\n- 对于所有测试用例，将要求的结果报告为浮点数或布尔值。\n\n测试套件：\n- 测试用例 1 (渐近保持极限)：区域长度 $L = 2\\pi$，网格大小 $N = 256$，时间步长 $\\Delta t = 10^{-4}$，总步数 $M = 1000$，因此 $T = 0.1$。参数：$m = 1$，$\\lambda = 0$，整数波数 $k = 3$。初始条件：$\\phi(x,0) = A \\cos(k x)$，振幅 $A = 0.1$，以及 $\\pi(x,0) = 0$。运行两次模拟：一次使用 $\\mathcal{H} = 0$，另一次使用 $\\mathcal{H} = 10^{-12}$。返回两次运行中最终场 $\\phi(x,T)$ 之间的相对 $\\ell^2$-范数差异，定义为\n$$\n\\frac{\\left\\|\\phi_{\\mathcal{H}=10^{-12}}(\\cdot,T)-\\phi_{\\mathcal{H}=0}(\\cdot,T)\\right\\|_2}{\\left\\|\\phi_{\\mathcal{H}=0}(\\cdot,T)\\right\\|_2},\n$$\n结果为浮点数。\n- 测试用例 2 (隐式摩擦验证)：区域长度 $L = 2\\pi$，网格大小 $N = 256$，时间步长 $\\Delta t = 10^{-2}$，总步数 $M = 100$，因此 $T = 1$。参数：$m = 0$，$\\lambda = 0$，并设置空间依赖性为常数，使得在整个过程中 $\\nabla^2 \\phi = 0$。初始条件：$\\phi(x,0) = 0$ 和 $\\pi(x,0) = 1$ (常数)。使用 $\\mathcal{H} = 100$ 运行。报告数值计算得到的比率 $\\pi(\\cdot,T)/\\pi(\\cdot,0)$ 与精确离散阻尼因子 $(1 + 2 \\mathcal{H}\\Delta t)^{-M}$ 之间的绝对差，结果为浮点数。\n- 测试用例 3 (仅有摩擦情况下的离散能量单调性)：与测试用例 2 设置相同。设第 $n$ 步的离散能量为\n$$\nE^n = \\frac{1}{2} \\sum_{j=0}^{N-1} \\pi_j^2 \\Delta x,\n$$\n因为 $\\nabla^2 \\phi = 0$ 且 $V(\\phi) = 0$。报告在所有 $M$ 步中，离散能量 $E^n$ 是否单调非增，结果为布尔值。\n- 测试用例 4 (空间离散化精度)：区域长度 $L = 2\\pi$，网格大小 $N = 256$，波数 $k = 4$。在网格上构建 $\\phi(x) = \\cos(k x)$，并使用带有周期性边界条件的二阶中心有限差分计算离散拉普拉斯算子 $\\partial_{xx}^{\\text{FD}} \\phi$。报告 $\\partial_{xx}^{\\text{FD}} \\phi$ 与精确拉普拉斯算子 $-\\!k^2 \\cos(k x)$ 之间的相对 $\\ell^2$-范数误差，定义为\n$$\n\\frac{\\left\\|\\partial_{xx}^{\\text{FD}} \\phi + k^2 \\cos(k x)\\right\\|_2}{\\left\\|k^2 \\cos(k x)\\right\\|_2},\n$$\n结果为浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，以逗号分隔的列表形式包含在方括号内，顺序为 $[\\text{Test1},\\text{Test2},\\text{Test3},\\text{Test4}]$，例如 $[r_1,r_2,r_3,r_4]$，其中 $r_1$ 和 $r_4$ 是浮点数，$r_2$ 是浮点数，$r_3$ 是布尔值。",
            "solution": "该问题要求为空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 宇宙中的标量场方程构建、分析和实现一个隐式-显式 (IMEX) 数值格式。验证步骤确认该问题在科学上是合理的、适定的，并且包含足够的信息以获得唯一解。\n\n控制方程以共形时间 $\\tau$ 的一阶系统形式给出：\n$$\n\\phi' = \\pi\n$$\n$$\n\\pi' = -2\\mathcal{H}\\,\\pi + \\nabla^2 \\phi - V'(\\phi)\n$$\n其中 $\\phi$ 是标量场，$\\pi$ 是其共轭动量，$\\mathcal{H}$ 是共形哈勃率，$V'(\\phi) = m^2 \\phi + \\lambda \\phi^3$ 是势的导数。离散化将在长度为 $L$、有 $N$ 个网格点、网格间距为 $\\Delta x = L/N$、时间步长为 $\\Delta t$ 的一维周期性区域上进行。\n\n### 1. IMEX 时间积分器的构建\n\n任务是构建一个 IMEX 格式，其中线性摩擦项 $-2\\mathcal{H}\\,\\pi$ 被隐式处理，而拉普拉斯算子 $\\nabla^2 \\phi$ 和势 $V'(\\phi)$ 项被显式处理。一个一阶精确且稳定的选择是半隐式欧拉型格式。设 $\\phi_j^n$ 和 $\\pi_j^n$ 表示在网格点 $x_j$ 和时间步 $t_n = n\\Delta t$ 处的场。\n\n从时间层 $n$ 到 $n+1$ 的更新分两步进行。首先，我们更新动量场 $\\pi$。我们对 $\\pi'$ 的方程进行离散化，对刚性摩擦项使用后向欧拉法，对其他项使用前向欧拉法。这是一种经典的 IMEX-Euler 方法。\n\n$\\pi$ 的时间离散方程为：\n$$\n\\frac{\\pi_j^{n+1} - \\pi_j^n}{\\Delta t} = -2\\mathcal{H}\\,\\pi_j^{n+1} + (\\nabla^2 \\phi^n)_j - V'(\\phi_j^n)\n$$\n这里，右侧的摩擦项在未来的时间层 $n+1$ (隐式) 进行计算，而拉普拉斯算子和势项在当前的时间层 $n$ (显式) 进行计算。空间拉普拉斯算子 $(\\nabla^2 \\phi^n)_j$ 使用二阶中心有限差分算子进行近似，记为 $(\\partial_{xx}^{\\text{FD}} \\phi^n)_j$。\n\n我们可以用代数方法解出 $\\pi_j^{n+1}$：\n$$\n\\pi_j^{n+1} + 2\\mathcal{H}\\Delta t\\,\\pi_j^{n+1} = \\pi_j^n + \\Delta t \\left[ (\\partial_{xx}^{\\text{FD}} \\phi^n)_j - V'(\\phi_j^n) \\right]\n$$\n$$\n\\pi_j^{n+1} (1 + 2\\mathcal{H}\\Delta t) = \\pi_j^n + \\Delta t \\left[ (\\partial_{xx}^{\\text{FD}} \\phi^n)_j - (m^2 \\phi_j^n + \\lambda (\\phi_j^n)^3) \\right]\n$$\n这给出了 $\\pi_j^{n+1}$ 的显式更新规则：\n$$\n\\pi_j^{n+1} = \\frac{1}{1 + 2\\mathcal{H}\\Delta t} \\left( \\pi_j^n + \\Delta t \\left[ (\\partial_{xx}^{\\text{FD}} \\phi^n)_j - m^2 \\phi_j^n - \\lambda (\\phi_j^n)^3 \\right] \\right)\n$$\n接下来，我们使用方程 $\\phi' = \\pi$ 更新场 $\\phi$。为了创建一个稳定的、类似辛的结构（特别是 Euler-Cromer），我们使用新计算出的动量 $\\pi^{n+1}$：\n$$\n\\frac{\\phi_j^{n+1} - \\phi_j^n}{\\Delta t} = \\pi_j^{n+1}\n$$\n这得出了 $\\phi_j^{n+1}$ 的更新规则：\n$$\n\\phi_j^{n+1} = \\phi_j^n + \\Delta t \\, \\pi_j^{n+1}\n$$\n这个两步过程定义了完整的 IMEX 格式。\n\n### 2. 拉普拉斯算子的空间离散化\n\n一维拉普拉斯算子 $\\nabla^2 \\phi \\to \\partial_{xx}\\phi$ 在均匀网格 $x_j = j \\Delta x$ (对于 $j \\in \\{0, 1, \\dots, N-1\\}$) 上使用带有周期性边界条件 ($\\phi_{j+N} = \\phi_j$) 的二阶中心有限差分公式进行离散化：\n$$\n(\\partial_{xx}^{\\text{FD}} \\phi)_j = \\frac{\\phi_{j+1} - 2\\phi_j + \\phi_{j-1}}{(\\Delta x)^2}\n$$\n为了分析其对具有整数波数 $k$ 的单个傅里叶模式 $\\phi(x) = \\cos(kx)$ 的作用，我们计算 $\\phi_j = \\cos(kx_j)$ 的这个表达式：\n$$\n(\\partial_{xx}^{\\text{FD}} \\phi)_j = \\frac{\\cos(k(x_j+\\Delta x)) - 2\\cos(kx_j) + \\cos(k(x_j-\\Delta x))}{(\\Delta x)^2}\n$$\n使用三角恒等式 $\\cos(A \\pm B) = \\cos A \\cos B \\mp \\sin A \\sin B$，分子变为：\n$$\n(\\cos(kx_j)\\cos(k\\Delta x) - \\sin(kx_j)\\sin(k\\Delta x)) - 2\\cos(kx_j) + (\\cos(kx_j)\\cos(k\\Delta x) + \\sin(kx_j)\\sin(k\\Delta x))\n$$\n$$\n= 2\\cos(kx_j)\\cos(k\\Delta x) - 2\\cos(kx_j) = 2\\cos(kx_j)(\\cos(k\\Delta x) - 1)\n$$\n应用半角公式 $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$，这可简化为：\n$$\n= -4\\cos(kx_j)\\sin^2(k\\Delta x / 2)\n$$\n代回到有限差分表达式中：\n$$\n(\\partial_{xx}^{\\text{FD}} \\phi)_j = \\left[ -\\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{k\\Delta x}{2}\\right) \\right] \\cos(kx_j)\n$$\n精确的拉普拉斯算子是 $\\partial_{xx}\\cos(kx) = -k^2\\cos(kx)$。因此，有限差分算子的作用相当于乘以一个有效的波数平方，$k_{\\text{eff}}^2 = \\frac{4}{(\\Delta x)^2} \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)$。对于小的 $k\\Delta x$，使用泰勒展开 $\\sin(z) \\approx z - z^3/6$，我们发现 $k_{\\text{eff}}^2 \\approx k^2 (1 - \\frac{(k\\Delta x)^2}{12})$，这显示了该近似的二阶精度。\n\n### 3. 渐近保持极限分析\n\n渐近保持性质在极限 $\\mathcal{H} \\to 0$ 下进行分析。我们考察我们的 IMEX 格式的行为：\n$$\n\\pi_j^{n+1} = \\frac{1}{1 + 2\\mathcal{H}\\Delta t} \\left( \\pi_j^n + \\Delta t \\left[ (\\partial_{xx}^{\\text{FD}} \\phi^n)_j - V'(\\phi_j^n) \\right] \\right)\n$$\n$$\n\\phi_j^{n+1} = \\phi_j^n + \\Delta t \\, \\pi_j^{n+1}\n$$\n当 $\\mathcal{H} \\to 0$ 时，前置因子 $\\frac{1}{1 + 2\\mathcal{H}\\Delta t} \\to \\frac{1}{1+0} = 1$。该格式平滑地退化为：\n$$\n\\pi_j^{n+1} = \\pi_j^n + \\Delta t \\left[ (\\partial_{xx}^{\\text{FD}} \\phi^n)_j - V'(\\phi_j^n) \\right]\n$$\n$$\n\\phi_j^{n+1} = \\phi_j^n + \\Delta t \\, \\pi_j^{n+1}\n$$\n这个最终的格式是 $\\mathcal{H}=0$ 系统 ($\\phi' = \\pi, \\pi' = \\nabla^2\\phi - V'(\\phi)$) 的一个标准显式方法。它被称为半隐式欧拉法、Euler-Cromer 法或辛欧拉法。它对应于对 $\\pi$ 方程应用一个前向欧拉步，然后在对 $\\phi$ 方程的后向欧拉步中使用更新后的动量 $\\pi^{n+1}$。由于数值格式的极限是极限连续方程的一致离散化，因此该 IMEX 格式是渐近保持的。\n\n### 4. 仅有摩擦情况的阻尼因子\n\n在仅有摩擦的情况下，我们设置 $\\nabla^2 \\phi = 0$ 和 $V'(\\phi) = 0$。系统简化为 $\\phi' = \\pi$ 和 $\\pi' = -2\\mathcal{H}\\pi$。在我们的数值格式中，这些简化得到：\n$$\n\\pi_j^{n+1} = \\frac{1}{1 + 2\\mathcal{H}\\Delta t} \\pi_j^n\n$$\n$$\n\\phi_j^{n+1} = \\phi_j^n + \\Delta t \\, \\pi_j^{n+1}\n$$\n从第一个方程中，我们可以直接确定 $\\pi_j$ 在每个时间步长被乘以的因子。由摩擦项的隐式处理引起的精确每步阻尼因子是：\n$$\nD = \\frac{\\pi_j^{n+1}}{\\pi_j^n} = \\frac{1}{1 + 2\\mathcal{H}\\Delta t}\n$$\n对于 $\\mathcal{H}  0$ 和 $\\Delta t  0$，这个因子总是小于1，确保了摩擦项的数值稳定性，无论乘积 $\\mathcal{H}\\Delta t$ 的大小如何。这是隐式处理的关键优势。经过 $M$ 步后，场 $\\pi$ 将被总因子 $D^M = (1 + 2\\mathcal{H}\\Delta t)^{-M}$ 阻尼。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement.\n    \"\"\"\n\n    def run_simulation(L, N, dt, M, H, m_sq, lamb, phi0, pi0, return_energy=False):\n        \"\"\"\n        Runs a single simulation of the scalar field equation using the IMEX scheme.\n        \"\"\"\n        dx = L / N\n        \n        phi = phi0.copy()\n        pi = pi0.copy()\n\n        energies = []\n        if return_energy:\n            energy = 0.5 * np.sum(pi**2) * dx\n            energies.append(energy)\n            \n        # Pre-calculate the inverse of the implicit factor for efficiency.\n        imex_factor = 1.0 / (1.0 + 2.0 * H * dt)\n        \n        for _ in range(M):\n            # Explicit part calculation\n            # Laplacian using 2nd-order centered differences with periodic BCs\n            lap_phi = (np.roll(phi, -1) - 2 * phi + np.roll(phi, 1)) / dx**2\n            \n            # Potential derivative term V'(phi)\n            v_prime = m_sq * phi + lamb * phi**3\n            \n            explicit_part = lap_phi - v_prime\n            \n            # --- IMEX Update ---\n            # 1. Update pi (implicit on friction, explicit on the rest)\n            pi = imex_factor * (pi + dt * explicit_part)\n            \n            # 2. Update phi (using the new pi)\n            phi = phi + dt * pi\n            \n            if return_energy:\n                energy = 0.5 * np.sum(pi**2) * dx\n                energies.append(energy)\n\n        if return_energy:\n            return np.array(energies)\n        else:\n            return phi, pi\n\n    results = []\n\n    # --- Test Case 1: Asymptotic-Preserving Limit ---\n    L1, N1, dt1, M1 = 2 * np.pi, 256, 1e-4, 1000\n    m_sq1, lamb1, k1, A1 = 1.0, 0.0, 3, 0.1\n    x1 = np.linspace(0, L1, N1, endpoint=False)\n    phi0_1 = A1 * np.cos(k1 * x1)\n    pi0_1 = np.zeros(N1)\n\n    phi_final_H0, _ = run_simulation(L1, N1, dt1, M1, 0.0, m_sq1, lamb1, phi0_1, pi0_1)\n    phi_final_H_small, _ = run_simulation(L1, N1, dt1, M1, 1e-12, m_sq1, lamb1, phi0_1, pi0_1)\n\n    norm_diff = np.linalg.norm(phi_final_H_small - phi_final_H0)\n    norm_base = np.linalg.norm(phi_final_H0)\n    result1 = norm_diff / norm_base if norm_base > 0 else 0.0\n    results.append(result1)\n\n    # --- Test Case 2: Implicit Friction Verification ---\n    L2, N2, dt2, M2 = 2 * np.pi, 256, 1e-2, 100\n    m_sq2, lamb2, H2 = 0.0, 0.0, 100.0\n    phi0_2 = np.zeros(N2)\n    pi0_2_val = 1.0\n    pi0_2 = np.full(N2, pi0_2_val)\n\n    _, pi_final_2 = run_simulation(L2, N2, dt2, M2, H2, m_sq2, lamb2, phi0_2, pi0_2)\n    \n    numerical_ratio = pi_final_2[0] / pi0_2_val\n    analytical_factor = (1.0 + 2.0 * H2 * dt2)**(-M2)\n    \n    result2 = np.abs(numerical_ratio - analytical_factor)\n    results.append(result2)\n\n    # --- Test Case 3: Discrete Energy Monotonicity ---\n    # Same setup as Test Case 2\n    energies = run_simulation(L2, N2, dt2, M2, H2, m_sq2, lamb2, phi0_2, pi0_2, return_energy=True)\n    # Check if all(E_n+1 = E_n)\n    is_monotonic = np.all(np.diff(energies) = 1e-15) # Use tolerance for floating point\n    result3 = is_monotonic\n    results.append(result3)\n\n    # --- Test Case 4: Spatial Discretization Accuracy ---\n    L4, N4, k4 = 2 * np.pi, 256, 4\n    dx4 = L4 / N4\n    x4 = np.linspace(0, L4, N4, endpoint=False)\n    \n    phi4 = np.cos(k4 * x4)\n    \n    # Numerical Laplacian\n    lap_phi_fd = (np.roll(phi4, -1) - 2 * phi4 + np.roll(phi4, 1)) / dx4**2\n    \n    # Exact Laplacian\n    lap_phi_exact = -k4**2 * phi4\n    \n    norm_diff_lap = np.linalg.norm(lap_phi_fd - lap_phi_exact)\n    norm_base_lap = np.linalg.norm(lap_phi_exact)\n    result4 = norm_diff_lap / norm_base_lap if norm_base_lap > 0 else 0.0\n    results.append(result4)\n    \n    # Final print statement in the exact required format.\n    # The boolean will be converted to a string \"True\" or \"False\".\n    print(f\"[{results[0]},{str(results[1]).lower()},{str(results[2]).lower()},{results[3]}]\")\n\nsolve()\n```"
        }
    ]
}