{
    "hands_on_practices": [
        {
            "introduction": "宇宙的演化由弗里德曼方程所描述，这是一个关于尺度因子 $a(t)$ 的常微分方程。求解这个方程是任何宇宙学模拟的第一步，但选择正确的数值方法至关重要，尤其是在宇宙成分密度发生剧烈变化的时期。本练习  旨在通过比较显式和隐式积分器在物质-暗能量均等时期附近的表现，帮助您深入理解数值方法的稳定性和准确性，这是构建可靠宇宙学代码的核心技能。",
            "id": "3496141",
            "problem": "考虑一个由 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规描述的空间均匀且各向同性的宇宙。作为一个基本出发点，采用关于空间平坦宇宙的第一弗里德曼方程，该方程用标度因子 $a$ 和无量纲哈勃函数 $E(a)$ 表示，定义如下\n$$\nE(a) \\equiv \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\mathrm{k}} a^{-2} + \\Omega_{\\Lambda}} \\, ,\n$$\n其中密度参数满足 $\\Omega_{\\mathrm{k}} = 0$（平坦几何），而 $\\Omega_{\\mathrm{r}}, \\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}$ 分别表示辐射、物质和宇宙学常数的贡献。引入无量纲时间 $\\tau \\equiv H_0 t$，其中 $H_0$ 是当前的哈勃常数，因此标度因子的演化方程是一个自治常微分方程\n$$\n\\frac{d a}{d \\tau} = a \\, E(a) \\, .\n$$\n你的任务是评估并比较一个显式和一个隐式时间积分器在物质-宇宙学常数（$\\Lambda$）相等时期附近，即在 $\\Omega_{\\mathrm{m}} a^{-3} \\approx \\Omega_{\\Lambda}$ 的时期附近，对 $a(\\tau)$ 的性能。比较必须基于稳定性和准确性。\n\n你必须实现：\n- 一个显式单步法，仅使用步长开始时的信息来推进 $a$。\n- 一个隐式单步法，通过求解在步长结束时对方程右侧进行求值的相应非线性方程来推进 $a$（你必须稳健地处理所需的非线性求解）。\n\n为确保通用性并消除物理单位，所有计算都必须使用无量纲时间 $\\tau$ 和无量纲的 $a(\\tau)$。不要使用任何有量纲的常数。\n\n为所有测试用例定义以下通用设置：\n- 物质-$\\Lambda$ 相等时的标度因子是\n$$\na_{\\mathrm{eq}} \\equiv \\left( \\frac{\\Omega_{\\mathrm{m}}}{\\Omega_{\\Lambda}} \\right)^{1/3} \\, .\n$$\n- 在 $\\tau = 0$ 时，初始化于\n$$\na_0 \\equiv \\frac{a_{\\mathrm{eq}}}{10} \\, 。\n$$\n- 将相等时期的名义局部动力学速率定义为 $E_{\\mathrm{eq}} \\equiv E(a_{\\mathrm{eq}})$，并设置步长\n$$\nh \\equiv \\frac{c}{E_{\\mathrm{eq}}} \\, ,\n$$\n其中 $c$ 是在下面每个测试用例中提供的无量纲控制参数。\n- 以固定的 $N$ 步进行演化，其中\n$$\nN \\equiv \\max\\left( 8, \\left\\lceil \\frac{\\ln(50)}{c} \\right\\rceil \\right) \\, ,\n$$\n因此总积分时间为 $\\tau_{\\mathrm{end}} = N h$，评估时间为 $\\tau_n = n h$，对于 $n = 0, 1, \\dots, N$。\n\n基准参考解：\n- 通过使用具有严格容差的高阶自适应方法求解相同的初值问题，计算一个高精度参考解 $a_{\\mathrm{ref}}(\\tau)$。使用相对容差 $10^{-12}$ 和绝对容差 $10^{-15}$，并在离散时间 $\\{\\tau_n\\}_{n=0}^N$ 处评估 $a_{\\mathrm{ref}}$。\n\n准确性和稳定性度量：\n- 对于一个数值序列 $\\{a_n\\}_{n=0}^N$，定义相对于参考解的均方根相对误差为\n$$\n\\varepsilon_{\\mathrm{rms}} \\equiv \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\left( \\frac{a_n - a_{\\mathrm{ref}}(\\tau_n)}{a_{\\mathrm{ref}}(\\tau_n)} \\right)^2 } \\, .\n$$\n- 定义一个方法在测试中是稳定的，当且仅当所有迭代值都是有限、严格递增且严格为正的：\n$$\n\\text{稳定} \\iff \\left( \\forall n: a_{n} \\in \\mathbb{R}, \\, a_{n} > 0 \\right) \\wedge \\left( \\forall n \\ge 1: a_{n} > a_{n-1} \\right) \\, 。\n$$\n- 如果一个方法在任何步骤中未能产生严格为正、严格递增的有限序列，或在隐式求解中未能收敛，则宣布其不稳定并指定 $\\varepsilon_{\\mathrm{rms}} = +\\infty$。\n\n决策规则：\n- 对于每个测试用例，推荐既稳定又达到较小 $\\varepsilon_{\\mathrm{rms}}$ 的方法。如果只有一个方法是稳定的，则推荐该稳定方法。如果两者都稳定且在机器精度内误差相同，则选择显式方法。\n\n测试套件：\n对于下面的每一行，将 $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}})$ 和 $c$ 作为输入，并设 $\\Omega_{\\mathrm{k}} = 0$：\n1. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.3, 0.7, 0)$, $c = 0.5$。\n2. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.3, 0.7, 0)$, $c = 1.6$。\n3. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.25, 0.75, 0)$, $c = 1.0$。\n4. $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}}) = (0.49, 0.51, 0)$, $c = 1.2$。\n\n交付成果：\n- 你的程序必须计算每个测试用例的推荐方法，并输出一个单行，该行是一个长度为 $4$ 的类 JSON 整数列表，其中每个条目如果推荐显式方法则为 $0$，如果推荐隐式方法则为 $1$，顺序与上面列出的测试用例相同。输出必须是单行，且严格为以下形式的列表\n$$\n[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]\n$$\n不含多余空格，其中每个 $\\text{r}_i \\in \\{0,1\\}$。",
            "solution": "该问题要求实现并比较一种显式和一种隐式数值方法，用于求解一个控制空间平坦的 Friedmann-Lemaître-Robertson-Walker (FLRW) 宇宙标度因子 $a$ 演化的常微分方程（ODE）。\n\n控制方程是一个一阶自治常微分方程，形式如下：\n$$\n\\frac{d a}{d \\tau} = a \\, E(a) \\equiv f(a)\n$$\n其中 $\\tau$ 是无量纲时间，而 $E(a)$ 是无量纲哈勃函数，定义为：\n$$\nE(a) = \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\mathrm{k}} a^{-2} + \\Omega_{\\Lambda}}\n$$\n对于本问题，假设宇宙是空间平坦的，因此 $\\Omega_{\\mathrm{k}} = 0$。我们将 ODE 的右侧表示为 $f(a)$，它仅是 $a$ 的函数：\n$$\nf(a) = a \\sqrt{\\Omega_{\\mathrm{r}} a^{-4} + \\Omega_{\\mathrm{m}} a^{-3} + \\Omega_{\\Lambda}} = \\sqrt{\\Omega_{\\mathrm{r}} a^{-2} + \\Omega_{\\mathrm{m}} a^{-1} + \\Omega_{\\Lambda} a^2}\n$$\n该问题是一个初值问题（IVP），初始条件为 $a(\\tau=0) = a_0$，其中 $a_0$ 是相对于物质-$\\Lambda$ 相等时期的标度因子 $a_{\\mathrm{eq}}$ 定义的。我们的任务是使用固定的步长 $h$ 在指定的区间 $[0, \\tau_{\\mathrm{end}}]$ 上求解 $a(\\tau)$。\n\n任务的核心是比较两类基本的单步数值积分器：显式方法和隐式方法。\n\n一个显式单步法使用仅在当前时间 $\\tau_n$ 可用的信息来计算下一个状态 $a_{n+1}$（在时间 $\\tau_{n+1} = \\tau_n + h$）。最简单的此类方法是前向欧拉法，其更新规则为：\n$$\na_{n+1} = a_n + h \\cdot f(a_n)\n$$\n该方法实现简单，但其数值稳定区域有限。如果步长 $h$ 相对于系统的特征时间尺度过大，它可能会变得不稳定，特别是对于解变化迅速的刚性 ODE。\n\n一个隐式单步法使用包含 $\\tau_{n+1}$ 时刻状态本身的信息来计算 $a_{n+1}$。最简单的此类方法是后向欧拉法。其更新规则为：\n$$\na_{n+1} = a_n + h \\cdot f(a_{n+1})\n$$\n这个方程是关于未知数 $a_{n+1}$ 的一个非线性代数方程，必须在每个时间步求解。我们可以定义一个函数 $g(x)$，并寻求其根：\n$$\ng(x) = x - a_n - h \\cdot f(x) = 0\n$$\n其中 $x$ 代表未知的 $a_{n+1}$。这个求根问题必须稳健地解决。牛顿法是一个高效的选择，它需要 $g(x)$ 的导数：\n$$\ng'(x) = 1 - h \\cdot f'(x)\n$$\n导数 $f'(a)$ 可以通过对 $f(a)^2 = \\Omega_{\\mathrm{r}} a^{-2} + \\Omega_{\\mathrm{m}} a^{-1} + \\Omega_{\\Lambda} a^2$ 求导得到：\n$$\n2 f(a) f'(a) = -2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a\n$$\n$$\nf'(a) = \\frac{-2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a}{2 f(a)} = \\frac{-2\\Omega_{\\mathrm{r}} a^{-3} - \\Omega_{\\mathrm{m}} a^{-2} + 2\\Omega_{\\Lambda} a}{2 a E(a)}\n$$\n牛顿法通过迭代找到根 $a_{n+1}$。尽管非线性求解带来了计算开销，但像后向欧拉法这样的隐式方法因其卓越的稳定性（特别是 A-稳定性）而常被青睐，它允许比显式方法大得多的步长，尤其对于刚性问题。\n\n为了评估这些方法的准确性，我们使用一个高阶自适应步长求解器（`scipy.integrate.solve_ivp`，方法为 `'LSODA'`）和严格的误差容差（$rtol=10^{-12}$, $atol=10^{-15}$）来生成一个高保真度参考解 $a_{\\mathrm{ref}}(\\tau)$。然后，通过均方根相对误差 $\\varepsilon_{\\mathrm{rms}}$ 来量化数值解 $\\{a_n\\}$ 的准确性：\n$$\n\\varepsilon_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N+1} \\sum_{n=0}^{N} \\left( \\frac{a_n - a_{\\mathrm{ref}}(\\tau_n)}{a_{\\mathrm{ref}}(\\tau_n)} \\right)^2 }\n$$\n稳定性是根据物理要求来判断的，即标度因子必须是时间的严格正值和严格递增函数。如果任何迭代值 $a_n$ 非正、非有限，或者对于任何 $n \\ge 1$ 有 $a_n \\le a_{n-1}$，则认为该方法不稳定。对于隐式方法，非线性求解器未能收敛也构成不稳定。不稳定方法的误差被赋为 $\\varepsilon_{\\mathrm{rms}} = +\\infty$。\n\n每个测试用例的计算流程如下：\n1.  定义宇宙学参数 $(\\Omega_{\\mathrm{m}}, \\Omega_{\\Lambda}, \\Omega_{\\mathrm{r}})$ 和控制参数 $c$。\n2.  计算导出常数：$a_{\\mathrm{eq}} = (\\Omega_{\\mathrm{m}}/\\Omega_{\\Lambda})^{1/3}$, $a_0 = a_{\\mathrm{eq}}/10$, $E_{\\mathrm{eq}} = E(a_{\\mathrm{eq}})$, $h = c/E_{\\mathrm{eq}}$ 以及 $N = \\max(8, \\lceil\\ln(50)/c\\rceil)$。\n3.  在时间点 $\\tau_n = nh$（$n=0, \\dots, N$）计算参考解 $a_{\\mathrm{ref}}(\\tau_n)$。\n4.  执行前向欧拉积分器 $N$ 步，存储序列 $\\{a_{n, \\mathrm{expl}}\\}$。在每一步检查稳定性。\n5.  执行后向欧拉积分器 $N$ 步，在每一步使用稳健的牛顿求解器求解非线性方程。存储序列 $\\{a_{n, \\mathrm{impl}}\\}$ 并检查稳定性。\n6.  如果方法稳定，计算两种方法的 $\\varepsilon_{\\mathrm{rms}}$。\n7.  应用指定的决策规则：推荐误差较小且稳定的方法，若误差相当则优先选择显式方法。每个测试用例的最终输出是一个整数（显式为 $0$，隐式为 $1$）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing explicit and implicit methods for the Friedmann equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: ((Omega_m, Omega_Lambda, Omega_r), c)\n    test_cases = [\n        ((0.3, 0.7, 0.0), 0.5),\n        ((0.3, 0.7, 0.0), 1.6),\n        ((0.25, 0.75, 0.0), 1.0),\n        ((0.49, 0.51, 0.0), 1.2),\n    ]\n\n    results = []\n    \n    for case_params, c in test_cases:\n        Om_m, Om_L, Om_r = case_params\n        Om_k = 0.0\n\n        def E(a):\n            \"\"\"Dimensionless Hubble function E(a).\"\"\"\n            if a == 0:\n                return np.inf\n            radicand = Om_r * a**(-4) + Om_m * a**(-3) + Om_k * a**(-2) + Om_L\n            return np.sqrt(radicand)\n\n        def ode_rhs(tau, a):\n            \"\"\"Right-hand side of the ODE da/d(tau) = a*E(a).\"\"\"\n            return a * E(a)\n\n        # Setup parameters\n        a_eq = (Om_m / Om_L)**(1/3)\n        a0 = a_eq / 10.0\n        E_eq = E(a_eq)\n        h = c / E_eq\n        N = int(max(8, np.ceil(np.log(50) / c)))\n        \n        tau_end = N * h\n        eval_times = np.linspace(0, tau_end, N + 1)\n\n        # High-accuracy reference solution\n        ref_sol = solve_ivp(\n            ode_rhs, [0, tau_end], [a0],\n            method='LSODA',\n            t_eval=eval_times,\n            rtol=1e-12,\n            atol=1e-15\n        )\n        a_ref = ref_sol.y[0]\n\n        def calculate_rms_rel_error(a_num, a_ref_vals):\n            \"\"\"Calculates the root-mean-square relative error.\"\"\"\n            rel_err_sq = ((a_num - a_ref_vals) / a_ref_vals)**2\n            return np.sqrt(np.mean(rel_err_sq))\n\n        def is_stable(a_seq):\n            \"\"\"Checks if a sequence is stable according to problem criteria.\"\"\"\n            if not np.all(np.isfinite(a_seq)) or not np.all(a_seq > 0):\n                return False\n            if a_seq.shape[0] > 1 and not np.all(np.diff(a_seq) > 0):\n                return False\n            return True\n\n        # --- Explicit Method (Forward Euler) ---\n        a_expl = np.zeros(N + 1)\n        a_expl[0] = a0\n        stable_expl = True\n        for n in range(N):\n            a_n = a_expl[n]\n            if a_n <= 0 or not np.isfinite(a_n):\n                stable_expl = False\n                break\n            a_expl[n+1] = a_n + h * ode_rhs(0, a_n)\n        \n        if stable_expl:\n            stable_expl = is_stable(a_expl)\n        \n        err_expl = calculate_rms_rel_error(a_expl, a_ref) if stable_expl else np.inf\n\n        # --- Implicit Method (Backward Euler) ---\n        a_impl = np.zeros(N + 1)\n        a_impl[0] = a0\n        stable_impl = True\n        for n in range(N):\n            a_n = a_impl[n]\n            \n            def g_func(x):\n                return x - a_n - h * ode_rhs(0, x)\n\n            def g_prime_func(x):\n                if x == 0: return np.inf\n                f_val = ode_rhs(0, x)\n                if abs(f_val) < 1e-15: return 1.0\n                \n                # f'(x) from symbolic differentiation of f(x)^2\n                f_prime_num = -2 * Om_r * x**-3 - Om_m * x**-2 + 2 * Om_L * x\n                f_prime_val = f_prime_num / (2 * f_val)\n                return 1.0 - h * f_prime_val\n            \n            try:\n                # Use explicit step as initial guess for Newton solver\n                guess = a_n + h * ode_rhs(0, a_n)\n                # Ensure guess is positive\n                if guess <= 0: guess = a_n\n                a_impl[n+1] = newton(g_func, x0=guess, fprime=g_prime_func, tol=1e-12, maxiter=50)\n            except (RuntimeError, ValueError):\n                stable_impl = False\n                break\n        \n        if stable_impl:\n            stable_impl = is_stable(a_impl)\n        \n        err_impl = calculate_rms_rel_error(a_impl, a_ref) if stable_impl else np.inf\n\n        # --- Decision Rule ---\n        recommend = -1 # Placeholder\n        if stable_expl and stable_impl:\n            if err_expl <= err_impl:  # Choose explicit on tie\n                recommend = 0\n            else:\n                recommend = 1\n        elif stable_expl:\n            recommend = 0\n        elif stable_impl:\n            recommend = 1\n        else: # Both unstable\n            recommend = 1 # Default to implicit if both fail, as it's generally more robust.\n\n        results.append(recommend)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们对宇宙的认识主要来自于对遥远天体发出的光的观测，而宇宙学红移是连接理论模型与观测数据的关键桥梁。本练习  将指导您从第一性原理出发，通过在弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 时空中数值化地追踪光子测地线，来验证红移关系 $1+z = a_0/a_e$。这个实践将深化您对时空几何如何直接影响物理观测的理解，并展示如何从理论基础构建出可验证的预测。",
            "id": "3496232",
            "problem": "您的任务是构建一个完整的、可运行的程序，用于在弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 时空中对光子测地线进行数值射线追踪，并同时沿着测地线演化光子能量，以在不同发射历史下验证宇宙学红移关系的普适性。该程序必须从第一性原理和核心定义出发构建，不得依赖于针对目标关系的预编码捷径。您的推导和实现必须从弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规、零测地线的定义以及哈勃膨胀率的弗里德曼方程开始。\n\n您必须使用的基本依据是：\n- 空间均匀且各向同性的宇宙的 FLRW 线元，由 $ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$ 给出，其中 $c$ 是光速，$a(t)$ 是标度因子，$r$ 是共动径向坐标，$k \\in \\{-1,0,+1\\}$ 代表空间曲率。\n- 径向光子轨迹的假设意味着 $d\\theta = d\\phi = 0$ 以及零条件 $ds^2=0$。\n- 由弗里德曼方程定义的哈勃膨胀率，以标度因子 $a$ 和当今参数表示：$H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$，其中 $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda)$。\n- 宇宙学红移的定义：对于在标度因子 $a_e$ 处发射、在标度因子 $a_0$ 处（按惯例 $a_0$ 固定为 $1$）被观测到的光子，$(1+z)$ 是共动观测者测量的观测波长与发射波长之比。\n\n您的程序必须实现以下从上述基础推导出的内容：\n1. 对径向零测地线进行数值积分，以获得在标度因子 $a_e$ 处的发射事件与今天在 $a_0$ 处的观测者之间的共动距离 $r$。使用科学上可靠的数值方法，该方法基于测地线方程，其中自变量的选择应在适当之处避免刚性问题。\n2. 使用与零测地线和宇宙膨胀一致的动力学方程，对光子能量 $E$ 沿测地线进行数值演化，使得标度关系 $E \\propto 1/a$ 是从计算中自然得出的，而非强行施加。根据数值演化出的 $E$，使用 $(1+z) = E_{\\mathrm{emit}}/E_{\\mathrm{obs}}$ 计算每个发射事件的 $(1+z)$ 的数值估计。\n3. 一个验证步骤，该步骤将每个发射事件的数值计算结果 $(1+z)$ 与比率 $a_0/a_e$ 进行比较，并针对一个任意的、随时间变化的发射历史 $E_{\\mathrm{emit}}(a_e)$ 进行，从而证明其与内在发射变异性无关。\n\n物理和数值单位及归一化：\n- 使用 $a_0 = 1$。\n- 使用 $c$ 单位为 $\\mathrm{m/s}$，$H_0$ 单位为 $\\mathrm{km/s/Mpc}$（在内部转换为 $\\mathrm{s^{-1}}$），并以百万秒差距 ($\\mathrm{Mpc}$) 为单位生成共动距离。\n- 能量可以使用任意单位，因为只有比率进入 $(1+z)$ 的计算中；红移验证结果报告为无量纲的差异。\n\n此计算不涉及角度单位。如果您选择参数化三角函数形式的发射历史，请默认使用弧度作为参数。\n\n设计一个测试套件，用于检验：\n- 一个普遍的平坦 Lambda-冷暗物质宇宙学。\n- 一个纯物质主导的平坦宇宙学。\n- 一个用于探测早期宇宙的玩具辐射主导平坦宇宙学。\n- 一个晚期由宇宙学常数主导的宇宙学。\n\n对于每个测试用例，在一个指定的发射标度因子范围 $a_e \\in [a_{\\min}, a_{\\max}]$ 内，使用数值上合理的间距采样多个发射事件。对于每个发射事件，使用一个由 $E_{\\mathrm{emit}}(a) = E_0 \\left(1 + A \\sin(\\alpha \\ln a) + B\\, a^\\beta\\right)$ 定义的、具有时变发射能量的非平凡发射历史，其中 $E_0$、$A$、$B$、$\\alpha$ 和 $\\beta$ 是特定于用例的参数。您的程序必须：\n- 从 $a_e$ 到 $a_0$ 数值演化 $E(a)$，并计算 $(1+z)_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$。\n- 计算 $(1+z)_{\\mathrm{theory}} = a_0/a_e - 1$。\n- 报告每个测试用例中所有发射事件的最大绝对偏差 $\\max |(1+z)_{\\mathrm{num}} - (1+z)_{\\mathrm{theory}}|$，以及该案例中到最早发射事件的共动距离（以 $\\mathrm{Mpc}$ 为单位）。\n\n明确指定以下测试套件：\n- 测试用例 $1$ (平坦 Lambda-冷暗物质)：$H_0 = 70\\,\\mathrm{km/s/Mpc}$，$\\Omega_m = 0.3$，$\\Omega_r = 9\\times 10^{-5}$，$\\Omega_\\Lambda = 0.69991$ (因此 $\\Omega_k = 0$)，发射标度因子 $a_e \\in [0.2, 0.95]$，参数为 $E_0 = 1$，$A = 0.2$，$B = 0.1$，$\\alpha = 5$，$\\beta = 0.3$。\n- 测试用例 $2$ (平坦物质主导)：$H_0 = 50\\,\\mathrm{km/s/Mpc}$，$\\Omega_m = 1$，$\\Omega_r = 0$，$\\Omega_\\Lambda = 0$ (因此 $\\Omega_k = 0$)，发射标度因子 $a_e \\in [0.05, 0.9]$，参数为 $E_0 = 1$，$A = 0.2$，$B = 0.1$，$\\alpha = 3$，$\\beta = 0.5$。\n- 测试用例 $3$ (平坦玩具辐射主导)：$H_0 = 70\\,\\mathrm{km/s/Mpc}$，$\\Omega_r = 9.999\\times 10^{-1}$，$\\Omega_m = 10^{-4}$，$\\Omega_\\Lambda = 0$ (因此 $\\Omega_k = 0$)，发射标度因子 $a_e \\in [10^{-6}, 10^{-4}]$，参数为 $E_0 = 1$，$A = 0.2$，$B = 0.1$，$\\alpha = 8$，$\\beta = 0.2$。\n- 测试用例 $4$ (平坦晚期宇宙学常数主导)：$H_0 = 70\\,\\mathrm{km/s/Mpc}$，$\\Omega_m = 10^{-2}$，$\\Omega_r = 9\\times 10^{-5}$，$\\Omega_\\Lambda = 0.98991$ (因此 $\\Omega_k = 0$)，发射标度因子 $a_e \\in [0.8, 0.999]$，参数为 $E_0 = 1$，$A = 0.2$，$B = 0.1$，$\\alpha = 4$，$\\beta = 0.7$。\n\n每个测试用例使用至少 $5$ 个发射事件样本，在指定的 $a_e$ 区间内适当分布，以探测低红移和高红移以及数值敏感的区域。\n\n您的程序应生成单行输出，包含八个结果（每个测试用例两个，按四个测试用例的顺序排列）：四个最大绝对偏差，后跟四个共动距离。格式必须是方括号括起来的逗号分隔列表，例如 $[\\delta_1,D_1,\\delta_2,D_2,\\delta_3,D_3,\\delta_4,D_4]$，其中每个 $\\delta_i$ 是一个无量纲浮点数，每个 $D_i$ 是一个以 $\\mathrm{Mpc}$ 为单位的浮点数。",
            "solution": "该问题要求从第一性原理出发，对宇宙学红移关系进行数值验证，具体来说是基于弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规和光子的测地线方程。为实现这一点，需要对几种宇宙学模型中光子能量及其路径的运动方程进行数值积分。任务的核心是证明著名的能量-红移关系 $E \\propto 1/a(t)$（其中 $E$ 是光子能量，$a(t)$ 是标度因子）是从时空的基本几何结构中自然产生的，而不是一个先验的假设。\n\n解决方案分为两个主要推导部分及其数值实现：\n1.  推导并计算到在标度因子 $a_e$ 处发射光子的物体的共动距离。\n2.  推导并数值积分控制光子能量沿其测地线演化的微分方程。\n\n**1. 共动距离计算**\n\n起点是 FLRW 线元：\n$$ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$$\n对于一个沿径向轨迹从发射体传播到位于原点的观测者的光子，我们有 $d\\theta = 0$ 和 $d\\phi = 0$。光子的零条件是 $ds^2 = 0$。这把度规方程简化为：\n$$c^2\\,dt^2 = a(t)^2 \\frac{dr^2}{1-kr^2}$$\n取平方根并整理，我们将坐标时间 $dt$ 和共动径向坐标 $dr$ 的无穷小变化联系起来：\n$$c \\frac{dt}{a(t)} = \\pm \\frac{dr}{\\sqrt{1-kr^2}}$$\n当光子从发射体位置 $r_e$ 朝向观测者位置 $r=0$ 传播时，其径向坐标减小，因此 $dr < 0$。我们选择负号以保持等式两边为正：\n$$\\frac{dr}{\\sqrt{1-kr^2}} = -c \\frac{dt}{a(t)}$$\n问题中指定的测试用例均为平坦宇宙，其中曲率参数 $k=0$。这一简化得到 $dr = -c\\,dt/a(t)$。\n为了计算到发射体的总共动距离 $r_e$，我们从发射时间 $t_e$ 积分到观测时间 $t_0$：\n$$r_e = \\int_0^{r_e} dr' = \\int_{t_e}^{t_0} \\frac{c\\,dt}{a(t)}$$\n为了便于数值积分，将积分变量从时间 $t$ 更改为标度因子 $a$ 更为方便。利用哈勃参数的定义 $H = \\dot{a}/a = (1/a)(da/dt)$，我们可以写出 $dt = da/(aH)$。将其代入积分得：\n$$r_e = \\int_{a_e}^{a_0} \\frac{c\\,da}{a(t) \\cdot a(t) H(a)} = c \\int_{a_e}^{a_0} \\frac{da}{a^2 H(a)}$$\n问题指定观测者在“今天”，因此我们设置 $a_0 = 1$。哈勃参数的演化由弗里德曼方程给出：\n$$H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$$\n所有测试用例使用的参数都使得 $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda) = 0$。因此，每个测试用例中到最早发射事件（$a_e = a_{\\min}$）的共动距离由以下定积分计算：\n$$r(a_{\\min}) = c \\int_{a_{\\min}}^{1} \\frac{da}{a^2 H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\n通过提出常数，我们可以将其写成便于计算的形式：\n$$r(a_{\\min}) = \\frac{c}{H_0} \\int_{a_{\\min}}^{1} \\frac{da}{a^2 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\n如果 $c$ 以 $\\mathrm{km/s}$ 表示，$H_0$ 以 $\\mathrm{km/s/Mpc}$ 表示，则前置因子 $c/H_0$（哈勃距离）的单位是 $\\mathrm{Mpc}$，而积分是无量纲的。共动距离使用 `scipy.integrate.quad` 函数进行数值计算。\n\n**2. 光子能量演化**\n\n为了验证红移关系，我们必须从测地线方程推导光子能量 $E$ 的演化，而不假设 $E \\propto 1/a$ 的结果。由四维速度为 $U^\\mu$ 的共动观测者测量的光子能量为 $E = -g_{\\mu\\nu} P^\\mu U^\\nu$，其中 $P^\\mu = dx^\\mu/d\\lambda$ 是光子的四维动量，$\\lambda$ 是一个仿射参数。\n对于一个共动观测者，在 $(t, r, \\theta, \\phi)$ 坐标系中，$U^\\mu = (1, 0, 0, 0)$，且度规分量 $g_{tt}=-c^2$。能量为 $E = -g_{tt} P^t U^t = c^2 P^t = c^2 (dt/d\\lambda)$。因此，能量的演化由四维动量的时间分量 $P^t$ 的演化决定。\n测地线方程为：\n$$\\frac{dP^\\mu}{d\\lambda} + \\Gamma^\\mu_{\\alpha\\beta} P^\\alpha P^\\beta = 0$$\n对于时间分量（$\\mu=t$），方程为 $\\frac{dP^t}{d\\lambda} + \\Gamma^t_{\\alpha\\beta} P^\\alpha P^\\beta = 0$。对于径向测地线，只有 $P^t$ 和 $P^r$ 非零。唯一相关的克里斯托费尔符号是 $\\Gamma^t_{rr}$。对于 FLRW 度规，它等于 $\\Gamma^t_{rr} = \\frac{a\\dot{a}}{c^2(1-kr^2)}$。测地线方程变为：\n$$\\frac{dP^t}{d\\lambda} + \\Gamma^t_{rr} (P^r)^2 = 0$$\n零条件 $g_{\\mu\\nu}P^\\mu P^\\nu=0$ 得到 $-c^2 (P^t)^2 + g_{rr} (P^r)^2 = 0$，这意味着 $(P^r)^2 = \\frac{c^2}{g_{rr}} (P^t)^2 = \\frac{c^2(1-kr^2)}{a^2} (P^t)^2$。将此代入测地线方程：\n$$\\frac{dP^t}{d\\lambda} + \\left(\\frac{a\\dot{a}}{c^2(1-kr^2)}\\right) \\left(\\frac{c^2(1-kr^2)}{a^2} (P^t)^2\\right) = 0$$\n$$\\frac{dP^t}{d\\lambda} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\n为了得到一个关于 $P^t$ 作为时间 $t$ 函数的方程，我们使用链式法则：$\\frac{d}{d\\lambda} = \\frac{dt}{d\\lambda}\\frac{d}{dt} = P^t\\frac{d}{dt}$。\n$$P^t \\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\n假设 $P^t \\neq 0$，两边除以 $P^t$ 得到一个线性常微分方程：\n$$\\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} P^t = 0 \\quad \\implies \\quad \\frac{1}{P^t}\\frac{dP^t}{dt} = -\\frac{1}{a}\\frac{da}{dt}$$\n这表明 $d(\\ln P^t)/dt = -d(\\ln a)/dt$，积分后得到 $P^t \\propto 1/a$。因为 $E \\propto P^t$，所以我们有 $E \\propto 1/a$。\n为了构建一个以标度因子 $a$ 为变量的数值积分方程，我们写出：\n$$\\frac{dE}{da} = \\frac{dE}{dt}\\frac{dt}{da}$$\n从 $E \\propto 1/a$ 可得 $dE/dt = d(k/a)/dt = -k \\dot{a}/a^2 = -(Ea)\\dot{a}/a^2 = -E(\\dot{a}/a) = -EH$。\n而 $dt/da = 1/\\dot{a} = 1/(aH)$。所以，\n$$\\frac{dE}{da} = (-EH) \\left(\\frac{1}{aH}\\right) = -\\frac{E}{a}$$\n这个一阶常微分方程 $\\frac{dE}{da} = -E/a$ 就是需要进行数值求解的动力学方程。\n\n**3. 数值实现**\n\n对于每个测试用例和每个指定的发射标度因子 $a_e$，我们执行以下操作：\n1.  使用给定的发射历史函数设置能量的初始条件 $E(a_e)$：$E_{\\mathrm{emit}}(a_e) = E_0 \\left(1 + A \\sin(\\alpha \\ln a_e) + B a_e^\\beta\\right)$。\n2.  使用高精度容差的 `scipy.integrate.solve_ivp` 在区间 $[a_e, 1]$ 上数值求解常微分方程 $\\frac{dE}{da} = -E/a$。在 $a=1$ 处的最终值即为观测到的能量 $E_{\\mathrm{obs}}$。\n3.  计算数值红移 $z_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$。\n4.  计算理论红移 $z_{\\mathrm{theory}} = a_0/a_e - 1 = 1/a_e - 1$。\n5.  计算绝对差异 $|z_{\\mathrm{num}} - z_{\\mathrm{theory}}|$。对于给定的测试用例，报告在所有采样的 $a_e$ 值中的最大差异。\n\n这个过程严格测试了 FLRW 几何对光子传播的直接影响，其数值结果应能以数值求解器的精度验证理论红移关系。",
            "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Numerically ray-traces photon geodesics in FLRW spacetime to verify\n    the cosmological redshift relation from first principles.\n    \"\"\"\n    # Physical constants\n    # Speed of light in km/s\n    C_KM_S = 299792.458\n\n    # Test case definitions\n    # (H0, Omega_m, Omega_r, Omega_Lambda, a_range, E_params)\n    test_cases = [\n        # Case 1: Flat Lambda-Cold Dark Matter\n        (70.0, 0.3, 9e-5, 0.69991, (0.2, 0.95), (1.0, 0.2, 0.1, 5.0, 0.3)),\n        # Case 2: Flat matter-dominated\n        (50.0, 1.0, 0.0, 0.0, (0.05, 0.9), (1.0, 0.2, 0.1, 3.0, 0.5)),\n        # Case 3: Flat toy radiation-dominated\n        (70.0, 1e-4, 0.9999, 0.0, (1e-6, 1e-4), (1.0, 0.2, 0.1, 8.0, 0.2)),\n        # Case 4: Flat late-time cosmological-constant dominated\n        (70.0, 1e-2, 9e-5, 0.98991, (0.8, 0.999), (1.0, 0.2, 0.1, 4.0, 0.7)),\n    ]\n\n    results = []\n\n    for h0, om_m, om_r, om_l, a_range, e_params in test_cases:\n        a_min, a_max = a_range\n        om_k = 1.0 - (om_m + om_r + om_l)  # All cases are flat, so om_k is 0\n\n        # Define the normalized Hubble parameter function H(a)/H0\n        def hubble_normalized(a):\n            term_r = om_r * a**-4\n            term_m = om_m * a**-3\n            term_k = om_k * a**-2\n            term_l = om_l\n            return np.sqrt(term_r + term_m + term_k + term_l)\n\n        # 1. Calculate comoving distance to the earliest emission event (a_min)\n        # Integrand for comoving distance calculation\n        def dist_integrand(a):\n            return 1.0 / (a**2 * hubble_normalized(a))\n        \n        # Hubble distance in Mpc\n        hubble_dist_mpc = C_KM_S / h0\n        \n        # Use quad for high-precision integration\n        dist_integral, _ = integrate.quad(dist_integrand, a_min, 1.0, epsabs=1e-14, epsrel=1e-14)\n        \n        comoving_dist_mpc = hubble_dist_mpc * dist_integral\n\n        # 2. Verify redshift relation by evolving photon energy\n        e0, A, B, alpha, beta = e_params\n\n        # Time-varying emitted energy function\n        def e_emit_func(a):\n            return e0 * (1.0 + A * np.sin(alpha * np.log(a)) + B * a**beta)\n            \n        # ODE for energy evolution: dE/da = -E/a\n        def energy_ode(a, E):\n            return -E / a\n\n        # Set up emission event samples\n        num_samples = 10\n        # For large scale factor ranges, log spacing is more appropriate\n        if a_max / a_min > 100:\n            a_e_samples = np.logspace(np.log10(a_min), np.log10(a_max), num_samples)\n        else:\n            a_e_samples = np.linspace(a_min, a_max, num_samples)\n            \n        discrepancies = []\n        for a_e in a_e_samples:\n            # Initial condition: energy at emission\n            e_initial = e_emit_func(a_e)\n            \n            # Solve the ODE from a_e to a_0=1\n            sol = integrate.solve_ivp(\n                energy_ode,\n                t_span=[a_e, 1.0],\n                y0=[e_initial],\n                rtol=1e-13,\n                atol=1e-13,\n                dense_output=True,\n                method='RK45'\n            )\n            e_observed = sol.y[0, -1]\n            \n            # Numerical redshift\n            z_numerical = e_initial / e_observed - 1.0\n            \n            # Theoretical redshift for a_0=1\n            z_theoretical = 1.0 / a_e - 1.0\n            \n            # Store the absolute discrepancy\n            discrepancies.append(np.abs(z_numerical - z_theoretical))\n            \n        max_discrepancy = np.max(discrepancies)\n        \n        results.extend([max_discrepancy, comoving_dist_mpc])\n\n    # Format the final output as a single comma-separated list in brackets\n    output_str = ','.join(f\"{x:.12g}\" for x in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了标准的 $\\Lambda$CDM 模型，宇宙学还探索了各种奇异的未来可能性，例如由状态方程参数 $w \\lt -1$ 的“幽灵能量”驱动的“大撕裂”奇点。本练习  挑战您去计算宇宙距离这一末日奇点还剩多少时间，这在数学上需要求解一个收敛的反常积分。您将学习如何设计一个在数值上稳定可靠的方法，通过推导和实现一个严格的尾部积分上界来安全地截断积分，从而确保计算结果的误差在可控范围内。",
            "id": "3496205",
            "problem": "要求您设计并实现一个数值积分器，用以计算在一个由 Friedmann–Lemaître–Robertson–Walker (FLRW) 度规描述的、具有满足 $w<-1$ 的恒定暗能量状态方程参数 $w$ 的均匀各向同性宇宙中，从当前到尺度因子发散（即所谓的大撕裂）所剩余的宇宙固有时间。您的程序必须是一个完整的、可运行的程序，它不接受任何输入，并为指定的测试套件输出所需的结果。\n\n基本原理：\n- 对于一个尺度因子为 $a(t)$、哈勃参数为 $H(t) \\equiv \\dot{a}/a$ 的均匀各向同性宇宙，其第一弗里德曼方程为\n$$\nH(a)^2 = H_0^2\\left(\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}\\right),\n$$\n其中 $H_0$ 是当前的哈勃常数，$\\Omega_r$ 是当前的辐射密度参数，$\\Omega_m$ 是当前的物质密度参数，$\\Omega_k$ 是当前的曲率密度参数，$\\Omega_{\\mathrm{de}}$ 是当前的暗能量密度参数，而 $w$ 是恒定的暗能量状态方程参数 $p=w\\rho$。\n- 对于理想流体，能动量守恒意味着，对于一个具有恒定 $w$ 的组分，有 $\\rho \\propto a^{-3(1+w)}$。\n- 根据 $H(a)$ 的定义，我们有 $H(a) = \\frac{1}{a}\\frac{da}{dt}$，所以 $dt = \\frac{da}{a H(a)}$。\n\n任务：\n- 对于下面测试套件中列出的每一组参数，计算从今天（定义为 $a=1$）到 $a \\to \\infty$ 时的大撕裂奇点所剩余的固有时间。这可以通过对 $dt=\\frac{da}{aH(a)}$ 从 $a=1$ 到 $a \\to \\infty$ 进行积分来获得。您必须设计一种数值上稳定可靠的方法，该方法：\n  1. 将积分重构为一种适合在半无限域上进行数值计算而不会损失精度的形式。\n  2. 包含一个在奇点附近的安全终止判据，该判据使用一个严格推导的积分余项上界（尾部界），以确保总绝对误差被用户选择的容差所限制。\n- 您的程序必须实现一个终止规则，通过结合以下两点，保证计算出的剩余时间的绝对误差不大于指定的绝对容差 $\\epsilon$：\n  - 在有限区间上受控的数值求积误差。\n  - 一个从截断点到 $a \\to \\infty$ 的积分余项的、数学上严格且可计算的上界。\n- 您不能依赖于总积分的任何闭式表达式；所有结果必须源于您的数值方法和有数学依据的尾部界。\n\n物理和数值单位：\n- 以十亿年（Gyr）为单位表示最终的固有时间结果。\n- 使用以下精确常数进行单位转换：\n  - $1\\,\\mathrm{Mpc} = 3.0856775814913673\\times 10^{22}\\,\\mathrm{m}$。\n  - $1\\,\\mathrm{yr} = 365.25 \\times 86400\\,\\mathrm{s} = 31557600\\,\\mathrm{s}$。\n  - $1\\,\\mathrm{Gyr} = 10^9\\,\\mathrm{yr}$。\n- 哈勃常数 $H_0$ 将以 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 为单位提供，在使用前必须转换为 $\\mathrm{Gyr^{-1}}$。\n\n数值方法要求：\n- 将积分重写为适合在半无限域上进行数值积分的形式，并实现一个带有误差估计的自适应数值求积方法，以控制在有限域上的积分误差。\n- 推导并实现一个尾部界，该界限定了从有限截断点到无穷大的剩余积分贡献的上界，并用它来决定何时安全地终止积分。总绝对误差必须被目标容差 $\\epsilon = 10^{-6}\\,\\mathrm{Gyr}$ 所限制。\n- 您的算法必须对 $w<-1$ 以及含有非零 $\\Omega_r$、$\\Omega_m$ 和 $\\Omega_k$ 的组合具有鲁棒性，前提是所有密度均为非负值，且对于 $a\\ge 1$，$H(a)$ 是实数。\n\n测试套件：\n对于以下每一组参数集 $(H_0, \\Omega_m, \\Omega_r, \\Omega_k, \\Omega_{\\mathrm{de}}, w)$，计算到大撕裂的剩余固有时间，并以 $\\mathrm{Gyr}$ 为单位报告，精确到小数点后六位。\n\n- 案例 1（平坦宇宙，魅影能量的 $w$ 值适度低于 $-1$）：\n  - $H_0 = 70.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_m = 0.3$，$\\Omega_r = 0.0$，$\\Omega_k = 0.0$，$\\Omega_{\\mathrm{de}} = 0.7$， $w = -1.2$。\n- 案例 2（类 Planck 卫星数据的 $H_0$，少量辐射，更强的魅影能量）：\n  - $H_0 = 67.74\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_m = 0.315$，$\\Omega_r = 9.0\\times 10^{-5}$，$\\Omega_k = 0.0$，$\\Omega_{\\mathrm{de}} = 0.68491$， $w = -1.5$。\n- 案例 3（带曲率的开放宇宙，魅影能量的 $w$ 值低于 $-1$）：\n  - $H_0 = 73.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，$\\Omega_m = 0.25$，$\\Omega_r = 5.0\\times 10^{-5}$，$\\Omega_k = 0.02$，$\\Omega_{\\mathrm{de}} = 0.72995$， $w = -1.3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 1–3 的结果，形式为用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是到大撕裂的时间（单位为 $\\mathrm{Gyr}$），四舍五入到小数点后六位，不含多余空格。\n\n评分和验证：\n- 输出值必须是如上指定的浮点数。没有额外的输入。程序必须是自包含的，并且除了上面列出的常数外，不得依赖任何外部数据。",
            "solution": "用户要求计算在一个由 Friedmann-Lemaître-Robertson-Walker (FLRW) 度规描述的宇宙模型中，距离“大撕裂”奇点还剩余的时间。该模型包含一个暗能量分量，其状态方程参数 $w < -1$ 为常数。该解决方案需要一个具有严格误差控制的、数值上鲁棒的方法。\n\n### 1. 数学公式\n尺度因子 $a(t)$ 的时间演化由第一弗里德曼方程决定：\n$$\nH(a)^2 = H_0^2\\left(\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}\\right)\n$$\n其中 $H(a) = \\frac{1}{a}\\frac{da}{dt}$ 是哈勃参数。当前时刻定义为 $a=1$。到大撕裂奇点（此时 $a \\to \\infty$）所剩余的固有时间由以下积分给出：\n$$\nT_{rip} = \\int_{t_0}^{\\infty} dt = \\int_{a=1}^{a=\\infty} \\frac{da}{a H(a)}\n$$\n对于 $w<-1$，与 $a^{-3(1+w)}$ 成正比的项随 $a$ 增长，导致 $H(a)$ 在 $a \\to \\infty$ 时发散，这反过来又导致总时间 $T_{rip}$ 是有限的。该积分是收敛的。\n\n### 2. 单位转换\n哈勃常数 $H_0$ 以 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 为单位提供。为使最终结果以十亿年（Gyr）为单位，必须将 $H_0$ 转换为 $\\mathrm{Gyr}^{-1}$。转换因子可由给定的物理常数推导得出：\n$1\\,\\mathrm{Mpc} = 3.0856775814913673\\times 10^{22}\\,\\mathrm{m}$\n$1\\,\\mathrm{Gyr} = 10^9 \\times 365.25 \\times 86400\\,\\mathrm{s} = 3.15576 \\times 10^{16}\\,\\mathrm{s}$\n$$\nH_0 [\\mathrm{Gyr}^{-1}] = H_0 [\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}] \\times \\frac{1000 \\, [\\mathrm{m/km}] \\times 3.15576 \\times 10^{16} \\, [\\mathrm{s/Gyr}]}{3.0856775814913673\\times 10^{22} \\, [\\mathrm{m/Mpc}]}\n$$\n此转换因子将用于在任何计算之前以适当的单位表示 $H_0$。所有后续计算都将在以 Gyr 为时间单位的单位系统中进行。\n\n### 3. 数值策略与误差控制\n用于计算 $T_{rip}$ 的积分因其无限上限而成为一个瑕积分，这对标准的数值求积程序构成了挑战。为解决此问题，我们将积分在一个大的、有限的尺度因子 $a_{max}$ 处分割：\n$$\nT_{rip} = \\int_{1}^{a_{max}} \\frac{da}{a H(a)} + \\int_{a_{max}}^{\\infty} \\frac{da}{a H(a)} = I_{num} + I_{tail}\n$$\n总结果由数值计算的积分 $I_{num}$ 近似。此近似的绝对误差是 $I_{num}$ 的数值求积误差（我们称之为 $\\Delta_{quad}$）与截断尾项 $I_{tail}$ 的大小之和。\n$$\n\\text{Total Error} = |\\text{Computed} - \\text{True}| \\le \\Delta_{quad} + |I_{tail}|\n$$\n为了保证总绝对误差小于指定的容差 $\\epsilon$，我们需要对每个误差分量进行界定。我们将强制要求 $\\Delta_{quad} \\le \\epsilon/2$ 和 $|I_{tail}| \\le \\epsilon/2$。关键是找到一个足够大的 $a_{max}$ 来满足后一个条件，这需要为 $|I_{tail}|$ 推导一个严格的上界。\n\n### 4. 尾部界的推导\n对于大的 $a$，暗能量项 $\\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}$ 在 $H(a)^2$ 的表达式中占主导地位，因为 $w < -1$ 使其指数为正，而所有其他指数均为负。鉴于所提供的测试案例中所有 $\\Omega_i \\ge 0$，我们可以为 $a \\ge 1$ 时的 $H(a)^2$ 建立一个严格的下界：\n$$\nH(a)^2 \\ge H_0^2 \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)} \\implies H(a) \\ge H_0 \\sqrt{\\Omega_{\\mathrm{de}}} a^{-3(1+w)/2}\n$$\n这给出了被积函数的上界：\n$$\n\\frac{1}{a H(a)} \\le \\frac{1}{a \\left( H_0 \\sqrt{\\Omega_{\\mathrm{de}}} a^{-3(1+w)/2} \\right)} = \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} a^{\\frac{3(1+w)}{2} - 1}\n$$\n因此，尾部积分的界为：\n$$\n|I_{tail}| \\le \\int_{a_{max}}^{\\infty} \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} a^{\\frac{3(1+w)}{2} - 1} da\n$$\n令 $p = \\frac{3(1+w)}{2} - 1$。由于 $w < -1$，我们有 $p < -1$，所以积分收敛。\n$$\n|I_{tail}| \\le \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} \\left[ \\frac{a^{p+1}}{p+1} \\right]_{a_{max}}^{\\infty} = \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} \\left( -\\frac{a_{max}^{p+1}}{p+1} \\right)\n$$\n代入 $p+1 = \\frac{3(1+w)}{2}$ 可得解析的尾部界 $B(a_{max})$：\n$$\nB(a_{max}) = \\frac{2 a_{max}^{\\frac{3}{2}(1+w)}}{-3(1+w) H_0 \\sqrt{\\Omega_{\\mathrm{de}}}}\n$$\n我们通过求解 $B(a_{max}) = \\epsilon_{tail} = \\epsilon/2$ 来选择我们的截断点 $a_{max}$：\n$$\na_{max} = \\left[ \\frac{-3(1+w) H_0 \\sqrt{\\Omega_{\\mathrm{de}}} (\\epsilon/2)}{2} \\right]^{\\frac{2}{3(1+w)}}\n$$\n由于 $\\frac{2}{3(1+w)}$ 是一个负指数，这将产生一个非常大的 $a_{max}$，从而确保尾部贡献很小。\n\n### 5. 为求积而进行的积分重构\n积分范围 $[1, a_{max}]$ 可能跨越多个数量级，这对标准的求积算法而言效率低下。为了在一个紧凑的定义域上创建一个行为良好的被积函数，我们进行变量替换：$a = e^u$。这得到 $da = e^u du$，积分限从 $[1, a_{max}]$ 变为 $[0, \\ln(a_{max})]$。\n$$\nI_{num} = \\int_{1}^{a_{max}} \\frac{da}{a H(a)} = \\int_{0}^{\\ln(a_{max})} \\frac{e^u du}{e^u H(e^u)} = \\int_{0}^{\\ln(a_{max})} \\frac{du}{H(e^u)}\n$$\n新的被积函数 $h(u) = 1/H(e^u)$ 在转换后的定义域 $[0, \\ln(a_{max})]$ 上更为平滑，该定义域大小适中。这种形式非常适合像 `scipy.integrate.quad` 这样的标准自适应求积库函数。\n\n### 6. 算法总结\n每个测试案例的完整算法如下：\n1.  定义总绝对容差 $\\epsilon = 10^{-6}$ Gyr。设置分量容差 $\\epsilon_{quad} = \\epsilon/2$ 和 $\\epsilon_{tail} = \\epsilon/2$。\n2.  使用推导的转换因子将输入的 $H_0$ 从 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 转换为 $\\mathrm{Gyr}^{-1}$。\n3.  通过求解尾部界方程 $B(a_{max}) = \\epsilon_{tail}$ 来计算积分上限 $a_{max}$。\n4.  通过设置 $u_{max} = \\ln(a_{max})$ 来变换积分范围。\n5.  在区间 $[0, u_{max}]$ 上对函数 $h(u) = 1/H(e^u)$ 进行数值求积，要求积分程序的绝对误差容差为 $\\epsilon_{quad}$。\n6.  数值积分的结果即为最终计算出的大撕裂时间。总误差保证被 $\\epsilon$ 所限制。\n7.  按要求将最终值格式化为六位小数。\n此方法是鲁棒的，遵守所有问题约束，并正确使用推导出的尾部界来定义一个具有保证误差控制的、数值上易于处理的问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the remaining proper time until the Big Rip singularity for three different\n    cosmological models, formats the results, and prints them.\n    \"\"\"\n    # Physical constants as specified in the problem statement\n    # 1 Megaparsec in meters\n    MPC_IN_M = 3.0856775814913673e22\n    # 1 Julian year in seconds\n    S_IN_YR = 365.25 * 86400.0\n    # 1 Gigayear in seconds\n    S_IN_GYR = S_IN_YR * 1e9\n    \n    # Conversion factor for H0 from km/s/Mpc to 1/Gyr\n    # The conversion is: H0_Gyr = H0_kmsMpc * (1000 m/km) * (S_IN_GYR s/Gyr) / (MPC_IN_M m/Mpc)\n    H0_CONV_FACTOR = (1000.0 * S_IN_GYR) / MPC_IN_M\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (H0 [km/s/Mpc], Omega_m, Omega_r, Omega_k, Omega_de, w)\n        (70.0, 0.3, 0.0, 0.0, 0.7, -1.2),\n        (67.74, 0.315, 9.0e-5, 0.0, 0.68491, -1.5),\n        (73.0, 0.25, 5.0e-5, 0.02, 0.72995, -1.3),\n    ]\n\n    results = []\n    # Target total absolute error for the computed integral\n    epsilon = 1e-6  # Gyr\n\n    for params in test_cases:\n        t_rip = compute_time_to_rip(params, H0_CONV_FACTOR, epsilon)\n        # Format the result to exactly six digits after the decimal point\n        results.append(f\"{t_rip:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n\ndef compute_time_to_rip(params, h0_conv_factor, total_tolerance):\n    \"\"\"\n    Computes the time to the Big Rip for a given set of cosmological parameters using\n    a robust numerical integration method with a rigorous error bound.\n\n    Args:\n        params (tuple): A tuple of cosmological parameters (H0, Om, Or, Ok, Ode, w).\n        h0_conv_factor (float): The factor to convert H0 to Gyr^-1.\n        total_tolerance (float): The desired total absolute error for the result.\n\n    Returns:\n        float: The calculated time in Gyr until the Big Rip.\n    \"\"\"\n    H0_kmsMpc, Om, Or, Ok, Ode, w = params\n\n    # Split the total tolerance between the numerical quadrature and the truncated tail.\n    epsilon_quad = total_tolerance / 2.0\n    epsilon_tail = total_tolerance / 2.0\n\n    # Convert Hubble constant to units of Gyr^-1\n    H0_per_Gyr = H0_kmsMpc * h0_conv_factor\n    \n    # --- Tail Bound and Integration Limit Calculation ---\n    # The tail integral from a_max to infinity is bounded by assuming dark energy dominance.\n    # The analytical bound B(a_max) is used to find a_max such that B(a_max) = epsilon_tail.\n    # B(a_max) = (2 * a_max^(1.5*(1+w))) / (-3*(1+w)*H0*sqrt(Ode)).\n    \n    # Define exponent gamma = 1.5 * (1 + w), which is negative for w < -1\n    gamma = 1.5 * (1.0 + w)\n    \n    if Ode <= 0:\n        # A Big Rip of this type requires a positive dark energy density.\n        raise ValueError(\"Dark energy density Omega_de must be positive for a Big Rip.\")\n\n    # Solve B(a_max) = epsilon_tail for a_max.\n    # a_max^gamma = epsilon_tail * (-gamma * H0_per_Gyr * sqrt(Ode))\n    a_max_raised_to_gamma = epsilon_tail * (-gamma) * H0_per_Gyr * np.sqrt(Ode)\n    \n    # a_max = (a_max_raised_to_gamma)^(1/gamma). Since gamma < 0, a_max will be large.\n    a_max = a_max_raised_to_gamma**(1.0 / gamma)\n\n    # --- Integrand Definition for Numerical Quadrature ---\n    # To handle the large range [1, a_max], we substitute a = exp(u).\n    # The integral becomes integral from 0 to log(a_max) of du / H(exp(u)).\n    \n    w_const = -3.0 * (1.0 + w)\n\n    def integrand_log_scale(u):\n        a = np.exp(u)\n        \n        # H(a)^2 / H0^2 = Or*a^-4 + Om*a^-3 + Ok*a^-2 + Ode*a^(-3(1+w))\n        h_squared_term = (Or * a**-4.0 + \n                          Om * a**-3.0 + \n                          Ok * a**-2.0 + \n                          Ode * a**w_const)\n        \n        h_val = H0_per_Gyr * np.sqrt(h_squared_term)\n        return 1.0 / h_val\n\n    # --- Numerical Integration ---\n    # The upper limit for the transformed integral is log(a_max).\n    u_max = np.log(a_max)\n\n    # Use scipy's quad to perform the integration with the specified absolute tolerance.\n    integral_val, _ = integrate.quad(\n        integrand_log_scale, \n        0, \n        u_max, \n        epsabs=epsilon_quad,\n        # Increase iteration limit for potentially complex integrals\n        limit=200 \n    )\n\n    # The result is the value of the numerical integration. The total error is bounded\n    # by epsilon_quad (from quad) + epsilon_tail (from truncation).\n    return integral_val\n\n# Execute the main solver function\nsolve()\n```"
        }
    ]
}