{
    "hands_on_practices": [
        {
            "introduction": "要开始用数值方法探索宇宙学，第一步是直接求解弗里德曼方程本身。本练习将指导您为宇宙标度因子 $a(t)$ 构建一个基础的数值求解器。通过将您的数值结果与已知的、针对简化的单组分宇宙的解析解进行比较，您将掌握一项在构建可靠科学代码时至关重要的技能 。",
            "id": "3495819",
            "problem": "考虑一个由弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规描述、并由弗里德曼膨胀定律控制的空间均匀且各向同性的宇宙。令 $a(t)$ 表示标度因子，并通过 $H(a) = \\dot{a}/a$ 定义哈勃率 $H(a)$。$H(a)$ 的演化由弗里德曼方程决定，该方程将膨胀率与总能量密度、空间曲率和宇宙学常数联系起来。总能量密度可以建模为具有恒定状态方程参数 $w$ 的无相互作用的理想流体组分之和，对于这些组分，能量守恒意味着能量密度随标度因子变化的标度律。此外，空间曲率和宇宙学常数分别通过曲率项和常数项对等式右边产生附加贡献。\n\n你的任务是设计并实现一个数值求解器，用于计算 $H(a)$ 并积分常微分方程 (ODE)\n$$\n\\frac{da}{dt} = a \\, H(a),\n$$\n以求解特定单组分宇宙的情况。然后，你必须根据为单组分情况推导出的解析解来验证 $a(t)$ 的数值解。程序必须在无量纲归一化下运行，其中所有常数的选择都使得特征膨胀尺度为单位量级；最终的数值输出中不需要物理单位。所有输出都必须是无量纲的，并且本问题不涉及角度。\n\n使用的基本原理：\n- 弗里德曼方程，在所选的归一化中可以写为\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L,\n$$\n其中 $C_i$ 是对应于状态方程参数为 $w_i$ 的理想流体组分的非负常数，$k$ 是空间曲率参数，$L$ 是一个与宇宙学常数项成正比的常数。\n- 在膨胀的 FLRW 宇宙中，对于具有恒定 $w$ 的理想流体，能量守恒意味着\n$$\n\\rho(a) \\propto a^{-3(1+w)}.\n$$\n问题陈述中不应假设使用任何其他简化公式；用于验证的所有解析表达式都必须在你的解中从这些基本原理推导出来。\n\n算法要求：\n1. 实现一个函数，用于计算给定 $(C_i, w_i)$、 $k$ 和 $L$ 时的 $H(a)$。\n2. 从指定的初始时间 $t_0$ 和初始标度因子 $a(t_0) = a_0$ 开始，对 ODE $da/dt = a H(a)$ 进行时间上的正向积分。\n3. 推导并实现适用于单组分情况的 $a(t)$ 解析解，以验证数值积分。使用这些解析表达式在 $t_0$ 处设置一致的初始条件，并计算在指定时间点的验证目标。\n\n测试套件：\n你必须在以下三个单组分情况下运行你的程序。对于每种情况，计算在 $t_{\\text{eval}}$ 所列时间点的数值解 $a_{\\text{num}}(t)$，计算相应的解析解 $a_{\\text{ana}}(t)$，并报告在 $t_{\\text{eval}}$ 时间点上的最大相对误差，\n$$\n\\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|.\n$$\n\n- 情况 A（单辐射组分）：\n  - 一个组分，参数为 $(C, w) = (1.0, 1/3)$。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 0.0$。\n  - 初始时间 $t_0 = 0.01$。\n  - 初始标度因子 $a_0$ 必须等于你在解中推导出的在 $t_0$ 处的解析值。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n- 情况 B（单无压物质组分）：\n  - 一个组分，参数为 $(C, w) = (1.0, 0.0)$。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 0.0$。\n  - 初始时间 $t_0 = 0.01$。\n  - 初始标度因子 $a_0$ 必须等于你在解中推导出的在 $t_0$ 处的解析值。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n- 情况 C（纯宇宙学常数）：\n  - 无流体组分。\n  - 空间曲率 $k = 0.0$。\n  - 宇宙学常数项 $L = 1.0$。\n  - 初始时间 $t_0 = 0.0$。\n  - 初始标度因子 $a_0 = 1.0$。\n  - 验证时间 $t_{\\text{eval}} = [0.05, 0.1, 1.0]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三个最大相对误差，每个情况一个，格式为一个由方括号括起来的逗号分隔列表（例如，\"[e_A,e_B,e_C]\"）。每个条目必须是一个浮点数。不得打印任何其他文本。",
            "solution": "该问题要求设计并实现一个数值求解器，用于求解由弗里德曼-勒梅特-罗伯逊-沃尔克 (FLRW) 度规描述的空间均匀且各向同性的宇宙中的标度因子 $a(t)$。$a(t)$ 的演化由第一弗里德曼方程和哈勃率的定义共同决定，它们组合成一个一阶常微分方程 (ODE)。然后，必须根据为特定单组分宇宙推导出的解析解来验证数值解。\n\n基本控制方程是标度因子的 ODE，\n$$\n\\frac{da}{dt} = a(t) H(a(t))\n$$\n以及定义哈勃率 $H(a)$ 的弗里德曼方程：\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L\n$$\n这里，$C_i$ 是代表状态方程为 $w_i$ 的理想流体组分能量密度的常数，$k$ 是空间曲率参数，$L$ 代表宇宙学常数。问题指定在一个无量纲系统中进行评估。\n\n任务的核心是首先为简化的单组分宇宙推导 $a(t)$ 的解析解，然后使用这些解来验证一般 ODE 的数值积分。\n\n**1. 解析解的推导**\n\n为了找到 $a(t)$ 的解析解，我们将 ODE 重排为 $dt = \\frac{da}{a H(a)}$ 并进行积分。$H(a)$ 的形式由存在的特定宇宙学组分决定。我们考虑指定的三种单组分测试情况。\n\n**情况 A：辐射主导的宇宙**\n在这种情况下，宇宙只包含一个辐射组分，其参数为 $(C, w) = (1.0, 1/3)$，并且空间曲率为零 ($k=0$)，没有宇宙学常数 ($L=0$)。弗里德曼方程简化为：\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+1/3)} = a^{-4}\n$$\n假设宇宙正在膨胀，我们取哈勃率的正根，$H(a) = a^{-2}$。标度因子的 ODE 变为：\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-2} = a^{-1}\n$$\n我们通过分离变量法来解这个方程：\n$$\na \\, da = dt\n$$\n对两边积分，$\\int a' \\, da' = \\int dt'$，得到 $\\frac{1}{2}a^2 = t + K$，其中 $K$ 是一个积分常数。通过选择时间的原点使得 $a(0)=0$，我们设 $K=0$。这给出了解析解：\n$$\na_{\\text{ana}}(t) = \\sqrt{2t}\n$$\n对于这种情况，初始时间是 $t_0 = 0.01$。初始标度因子 $a_0$ 必须与解析解一致，所以 $a_0 = a_{\\text{ana}}(t_0) = \\sqrt{2 \\cdot 0.01} = \\sqrt{0.02}$。\n\n**情况 B：物质主导的宇宙**\n这种情况考虑一个只含无压物质的宇宙，$(C, w) = (1.0, 0.0)$，同样有 $k=0$ 和 $L=0$。弗里德曼方程是：\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+0)} = a^{-3}\n$$\n取正根，$H(a) = a^{-3/2}$。标度因子的 ODE 是：\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-3/2} = a^{-1/2}\n$$\n分离变量得到：\n$$\na^{1/2} \\, da = dt\n$$\n积分 $\\int (a')^{1/2} \\, da' = \\int dt'$ 得到 $\\frac{2}{3}a^{3/2} = t + K$。再次选择 $a(0)=0$ 将积分常数 $K$ 设为0，从而得到解析解：\n$$\na_{\\text{ana}}(t) = \\left(\\frac{3}{2} t\\right)^{2/3}\n$$\n初始时间是 $t_0 = 0.01$，所以一致的初始标度因子是 $a_0 = a_{\\text{ana}}(t_0) = (\\frac{3}{2} \\cdot 0.01)^{2/3} = (0.015)^{2/3}$。\n\n**情况 C：宇宙学常数主导的宇宙**\n这种情况没有流体组分，$k=0$，且有一个非零的宇宙学常数项 $L=1.0$。弗里德曼方程简化为：\n$$\nH(a)^2 = L = 1.0\n$$\n哈勃率是常数：$H(a) = \\sqrt{L} = 1$。标度因子的 ODE 是：\n$$\n\\frac{da}{dt} = a H(a) = a\n$$\n分离变量得到 $\\frac{da}{a} = dt$。从初始时间 $t_0$、标度因子为 $a_0$ 积分到一个稍后的时间 $t$ 得到：\n$$\n\\int_{a_0}^{a(t)} \\frac{da'}{a'} = \\int_{t_0}^{t} dt' \\implies \\ln\\left(\\frac{a(t)}{a_0}\\right) = t - t_0\n$$\n因此，解析解是指数增长：\n$$\na_{\\text{ana}}(t) = a_0 e^{t - t_0}\n$$\n对于这种情况，初始条件被明确给出为 $t_0=0.0$ 和 $a_0=1.0$。解析解简化为 $a_{\\text{ana}}(t) = e^t$，这是一致的，因为 $a_{\\text{ana}}(0)=e^0=1.0$。\n\n**2. 数值积分与验证**\n\n数值解是通过使用标准的数值求解器对 ODE $\\frac{da}{dt} = a H(a)$ 进行积分得到的。来自 SciPy 库的 `scipy.integrate.solve_ivp` 函数是一个合适的选择，它提供了高阶龙格-库塔方法的稳健实现。\n\n对于每个测试用例：\n1. 根据特定情况的参数 $(C, w, k, L)$，定义一个代表 ODE 右侧 $f(t, a) = a H(a)$ 的 Python 函数。\n2. 设置初始条件 $(t_0, a_0)$。对于情况 A 和 B， $a_0$ 由各自的解析解在 $t_0$ 处计算得出。对于情况 C，它是直接给出的。\n3. 调用 `solve_ivp` 从 $t_0$ 积分到 $t_{\\text{eval}}$ 中的最大时间，并请求在 $t_{\\text{eval}}$ 中列出的特定时间点上的解值。为确保高精度，指定了严格的误差容限（例如，相对容限 `rtol` 和绝对容限 `atol` 为 $10^{-12}$）。\n4. 从求解器的输出中获得数值解 $a_{\\text{num}}(t)$。\n5. 在相同的时间点集合 $t_{\\text{eval}}$ 上计算解析解 $a_{\\text{ana}}(t)$。\n6. 然后根据以下公式计算最大相对误差：\n$$\n\\text{error} = \\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|\n$$\n这个误差量化了数值结果与精确解析解的偏差，并作为验证指标。预期的误差应该非常小，与求解器的容限在同一数量级。\n\n该程序应用于三个指定的情况：\n- **情况 A：** $(C, w)=(1.0, 1/3), k=0, L=0$。初始条件：$t_0=0.01, a_0=a_{\\text{ana}}(0.01)$。\n- **情况 B：** $(C, w)=(1.0, 0), k=0, L=0$。初始条件：$t_0=0.01, a_0=a_{\\text{ana}}(0.01)$。\n- **情况 C：** 无流体，$k=0, L=1.0$。初始条件：$t_0=0.0, a_0=1.0$。\n\n最终输出是每个情况下的最大相对误差列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the scale factor a(t) in single-component universes,\n    validates against analytic solutions, and reports the maximum relative error.\n    \"\"\"\n\n    # Define the three test cases as specified in the problem statement.\n    # Each tuple contains:\n    # (C, w, k, L, t0, a0 (or None if derived), t_eval, analytic_func)\n    test_cases = [\n        # Case A: Radiation-dominated\n        (\n            1.0, 1.0/3.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.sqrt(2.0 * t)\n        ),\n        # Case B: Matter-dominated\n        (\n            1.0, 0.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: (1.5 * t)**(2.0/3.0)\n        ),\n        # Case C: Cosmological constant-dominated\n        (\n            0.0, 0.0, 0.0, 1.0, 0.0, 1.0,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.exp(t)\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        C, w, k, L, t0, a0_val, t_eval, a_analytic_func = case\n\n        # Set the initial scale factor a0.\n        # If a0_val is not provided, compute it from the analytic solution at t0.\n        if a0_val is None:\n            a0 = a_analytic_func(t0)\n        else:\n            a0 = a0_val\n\n        # Define the ODE: da/dt = a * H(a)\n        def dadt(t, y):\n            a = y[0]\n            \n            # Guard against non-positive scale factor due to numerical errors.\n            # a > 0 for all cases considered.\n            if a = 0:\n                return [0.0]\n\n            # Calculate H(a)^2 from the Friedmann equation.\n            # Handle potential negative values from numerical precision issues.\n            h_squared = C * a**(-3.0 * (1.0 + w)) - k * a**(-2.0) + L\n            if h_squared  0:\n                h_squared = 0.0\n\n            H = np.sqrt(h_squared)\n            return [a * H]\n\n        # Set up integration time span and initial conditions.\n        t_span = (t0, t_eval[-1])\n        y0 = [a0]\n\n        # Use a high-precision solver to integrate the ODE.\n        # rtol and atol are set to small values to minimize solver error.\n        sol = solve_ivp(\n            dadt,\n            t_span,\n            y0,\n            t_eval=t_eval,\n            method='DOP853', # A high-order accurate solver\n            rtol=1e-13,\n            atol=1e-13\n        )\n\n        # Extract the numerical solution at the evaluation times.\n        a_numerical = sol.y[0]\n\n        # Compute the analytic solution at the evaluation times for validation.\n        a_analytical = a_analytic_func(t_eval)\n\n        # Calculate the maximum relative error.\n        # Guard against division by zero if an analytic value is zero (not the case here).\n        relative_errors = np.abs((a_numerical - a_analytical) / a_analytical)\n        max_relative_error = np.max(relative_errors)\n        \n        results.append(max_relative_error)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(f'{err:.10e}' for err in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何计算宇宙的膨胀历史 $H(a)$ 之后，顺理成章的下一步是计算可观测量。本练习侧重于计算宇宙学距离，这是连接理论与观测的基石。您将学习如何处理不同的宇宙几何（平坦、开放和闭合），并解决在此过程中出现的数值挑战，尤其是在处理近乎平坦的宇宙时 。",
            "id": "3495804",
            "problem": "要求您实现横向同移距离函数 $S_k(\\chi)$ 的一个数值鲁棒的计算方法。该函数出现在一个均匀各向同性宇宙的 Friedmann–Robertson–Walker (FRW) 度规的空间部分中。请使用以下基本依据。\n\n1. Friedmann 方程通过无量纲哈勃函数 $E(z)$ 定义了宇宙的膨胀率，其中 $E(z) = H(z)/H_0$，$H_0$ 是哈勃常数。对于一个包含物质密度参数 $\\Omega_m$、宇宙学常数密度参数 $\\Omega_\\Lambda$ 和曲率密度参数 $\\Omega_k$ 的宇宙，假设 $E(z)$ 具有以下形式\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}.\n$$\n在本问题中忽略辐射。\n\n2. 视线同移距离 $\\chi(z)$ 定义为\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}.\n$$\n\n3. FRW 空间切片的空间曲率常数是 $k_\\text{geom}$，它通过以下方式与曲率密度参数相关联：\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}.\n$$\n\n4. 横向同移距离函数 $S_k(\\chi)$ 定义为以下常微分方程的唯一解：\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0,\n$$\n其初始条件为 $S_k(0) = 0$ 和 $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$。\n\n您的任务是：\n\n- 为通用的 $k_\\text{geom}$ 和 $\\chi$ 推导一个数值稳定的算法来计算 $S_k(\\chi)$，需特别注意如 $k_\\text{geom} \\to 0$、大参数和（数值）对消等边界情况。将该算法实现在一个完整的、可运行的程序中，该程序通过 $\\chi(z)$ 的积分，从给定的宇宙学参数计算出 $S_k(\\chi(z))$。\n\n- 假设使用自然单位制，其中 $c/H_0 = 1$，因此所有距离都是无量纲的，您的输出也应是无量纲数。不需要角度单位或物理单位转换。\n\n- 讨论并从算法上处理定义域和数值问题：$S_k(\\chi)$ 在 $k_\\text{geom}=0$ 处的连续性，$k_\\text{geom} > 0$ 和 $k_\\text{geom}  0$ 时的行为，当 $|k_\\text{geom}|\\chi^2$ 很小时的（数值）对消问题，以及当出现双曲函数时，对于大的 $|k_\\text{geom}|^{1/2}\\chi$ 值的溢出风险。\n\n设计一个包含以下参数集的测试套件来评估您的实现：\n\n- 情况 A（理想情况，平坦宇宙）：$(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 2.0)$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 B（闭合宇宙）：$(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.75, -0.05, 2.0)$，其中 $k_\\text{geom} > 0$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 C（开放宇宙）：$(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.65, 0.05, 2.0)$，其中 $k_\\text{geom}  0$。输出 $S_k(\\chi(z))$ 的浮点数值。\n\n- 情况 D（近乎平坦的连续性检查）：$(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 10^{-12}, 2.0)$。同时计算 $S_k(\\chi(z))$ 和 $\\chi(z)$，并输出一个布尔值，指示其相对差异是否满足 $\\left|S_k(\\chi) - \\chi\\right|/\\max(1,\\chi)  10^{-10}$。\n\n- 情况 E（零距离边界）：$(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 0.0)$。输出一个布尔值，指示 $S_k(\\chi(0)) = 0$ 是否在机器精度范围内成立。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[resultA,resultB,resultC,resultD,resultE]`）。输出必须按照上面列出的情况顺序排列。前三个条目必须是浮点数，第四和第五个条目必须是布尔值。不应打印任何其他文本。",
            "solution": "用户需要一个用于计算宇宙学中使用的横向同移距离函数 $S_k(\\chi)$ 的数值鲁棒实现。解决方案涉及通过数值积分计算视线同移距离 $\\chi(z)$，然后使用其解析形式计算 $S_k(\\chi)$，并特别注意在接近平坦时（$k_\\text{geom} \\to 0$）的数值稳定性。\n\n该问题的基本原理源自均匀各向同性宇宙的 Friedmann–Robertson–Walker (FRW) 模型。推导过程分几步进行：求解 $S_k(\\chi)$ 的定义微分方程，分析解的数值属性，并设计一个鲁棒的算法。\n\n**1. 公式化与简化**\n\n问题提供了必要的定义。无量纲哈勃函数由下式给出：\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}\n$$\n到红移 $z$ 的视线同移距离 $\\chi$ 是同移光速的积分：\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}\n$$\n横向同移距离 $S_k(\\chi)$ 由二阶常微分方程（ODE）控制：\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0\n$$\n初始条件为 $S_k(0) = 0$ 和 $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$。空间曲率常数 $k_\\text{geom}$ 通过 $k_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}$ 与曲率密度参数 $\\Omega_k$ 相关联。\n\n问题指定使用自然单位制，其中哈勃距离 $c/H_0 = 1$。这意味着 $c = H_0$。将此代入 $k_\\text{geom}$ 的表达式可得到一个显著的简化：\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{H_0^2} = -\\Omega_k\n$$\n这种直接关系使我们可以在确定几何形状时直接使用 $\\Omega_k$。\n\n**2. ODE 的解析解**\n\n$S_k(\\chi)$ 的 ODE 是一个线性、齐次、二阶方程，其系数 $k_\\text{geom} = -\\Omega_k$ 为常数。解取决于 $k_\\text{geom}$ 的符号。有 3 种不同情况：\n\n情况 1：$k_\\text{geom} > 0$（闭合宇宙，$\\Omega_k  0$）\n方程为 $S_k'' + (\\sqrt{k_\\text{geom}})^2 S_k = 0$。通解为 $S_k(\\chi) = A \\cos(\\sqrt{k_\\text{geom}}\\chi) + B \\sin(\\sqrt{k_\\text{geom}}\\chi)$。应用初始条件：\n- $S_k(0) = 0 \\implies A = 0$。\n- $S_k'(0) = 1 \\implies B\\sqrt{k_\\text{geom}}\\cos(0) = 1 \\implies B = 1/\\sqrt{k_\\text{geom}}$。\n解为：\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{k_\\text{geom}}} \\sin(\\sqrt{k_\\text{geom}}\\chi)\n$$\n\n情况 2：$k_\\text{geom}  0$（开放宇宙，$\\Omega_k > 0$）\n方程为 $S_k'' - (\\sqrt{-k_\\text{geom}})^2 S_k = 0$。通解为 $S_k(\\chi) = A \\cosh(\\sqrt{-k_\\text{geom}}\\chi) + B \\sinh(\\sqrt{-k_\\text{geom}}\\chi)$。应用初始条件：\n- $S_k(0) = 0 \\implies A = 0$。\n- $S_k'(0) = 1 \\implies B\\sqrt{-k_\\text{geom}}\\cosh(0) = 1 \\implies B = 1/\\sqrt{-k_\\text{geom}}$。\n解为：\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{-k_\\text{geom}}} \\sinh(\\sqrt{-k_\\text{geom}}\\chi)\n$$\n\n情况 3：$k_\\text{geom} = 0$（平坦宇宙，$\\Omega_k = 0$）\n方程为 $S_k'' = 0$。通解为 $S_k(\\chi) = A\\chi + B$。应用初始条件：\n- $S_k(0) = 0 \\implies B = 0$。\n- $S_k'(0) = 1 \\implies A = 1$。\n解为：\n$$\nS_k(\\chi) = \\chi\n$$\n\n**3. 数值稳定性分析与算法设计**\n\n对这些解析解的朴素实现会在 $|k_\\text{geom}|$ 非常小时面临数值问题。对于小的 $x$，$\\sin(x) \\approx x$ 且 $\\sinh(x) \\approx x$。对于小的 $k_\\text{geom}$，直接计算诸如 $\\sin(\\sqrt{k_\\text{geom}}\\chi)/\\sqrt{k_\\text{geom}}$ 的表达式会导致 $0/0$ 的形式，从而造成灾难性对消和精度损失。\n\n为了构建一个鲁棒的算法，我们使用泰勒级数展开来分析当 $k_\\text{geom} \\to 0$ 时解的行为。\n令 $y = k_\\text{geom}\\chi^2$。\n- 对于 $k_\\text{geom} > 0$，$y > 0$。解可以写为 $S_k(\\chi) = \\chi \\frac{\\sin(\\sqrt{y})}{\\sqrt{y}}$。$\\frac{\\sin(x)}{x}$ 的泰勒级数为 $\\sum_{n=0}^{\\infty} (-1)^n \\frac{x^{2n}}{(2n+1)!}$。代入 $x = \\sqrt{y}$ 可得：\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} (-1)^n \\frac{y^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\n- 对于 $k_\\text{geom}  0$，$y  0$。令 $y' = -y > 0$。解为 $S_k(\\chi) = \\chi \\frac{\\sinh(\\sqrt{y'})}{\\sqrt{y'}}$。$\\frac{\\sinh(x)}{x}$ 的泰勒级数为 $\\sum_{n=0}^{\\infty} \\frac{x^{2n}}{(2n+1)!}$。代入 $x = \\sqrt{y'}$ 可得：\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} \\frac{(y')^n}{(2n+1)!} = \\chi \\sum_{n=0}^{\\infty} \\frac{(-y)^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\n值得注意的是，两种情况在变量 $y = k_\\text{geom}\\chi^2$ 下共享相同的泰勒级数。这提供了一种统一且数值稳定的方法，用于在 $|y|$ 很小时计算 $S_k(\\chi)$。\n\n$S_k(\\chi)$ 的算法：\n1. 给定 $\\chi$ 和 $\\Omega_k$，计算 $k_\\text{geom} = -\\Omega_k$。\n2. 如果 $k_\\text{geom}$ 恰好为 $0$，返回 $\\chi$。\n3. 如果 $\\chi$ 恰好为 $0$，返回 $0$。\n4. 计算 $y = k_\\text{geom} \\chi^2$。\n5. 选择一个阈值，例如 $TOL = 10^{-8}$。如果 $|y|  TOL$，使用截断的泰勒级数计算 $S_k(\\chi)$ 以避免（数值）对消：\n   $$S_k(\\chi) \\approx \\chi \\left(1 - \\frac{y}{6}\\left(1 - \\frac{y}{20}\\left(1 - \\frac{y}{42}\\right)\\right)\\right)$$\n   这种嵌套形式（Horner 方法）对于多项式求值是高效且稳定的。\n6. 如果 $|y| \\ge TOL$，使用标准的解析公式：\n   - 如果 $k_\\text{geom} > 0$，计算 $S_k(\\chi) = \\sin(\\sqrt{k_\\text{geom}}\\chi) / \\sqrt{k_\\text{geom}}$。\n   - 如果 $k_\\text{geom}  0$，计算 $S_k(\\chi) = \\sinh(\\sqrt{-k_\\text{geom}}\\chi) / \\sqrt{-k_\\text{geom}}$。\n\n此外，对于开放宇宙的情况（$k_\\text{geom}  0$），双曲正弦函数的参数 $\\sqrt{-k_\\text{geom}}\\chi$ 可能会变得很大，有浮点溢出的风险。对于所提供的测试用例，这不是问题，因为参数值仍然很小。在一个通用库中，对于大参数可能会切换到对数表示法。\n\n**4. 实现计划**\n\n最终的程序将按以下方式构建：\n1. 一个函数 `compute_chi(z, Omega_m, Omega_Lambda, Omega_k)` 将通过使用 `scipy.integrate.quad` 对 $1/E(z')$ 从 $z'=0$ 到 $z$ 进行数值积分来计算同移距离 $\\chi(z)$。对 $z=0$ 的显式检查将立即返回 $0$。\n2. 一个函数 `compute_Sk_chi(chi, Omega_k)` 将实现上述鲁棒算法来计算 $S_k(\\chi)$。\n3. 主函数 `solve()` 将遍历问题描述中提供的 5 个测试用例。\n4. 对于每种情况，它将调用 `compute_chi` 和 `compute_Sk_chi` 来获取所需的值。\n5. 对于情况 A、B 和 C，存储 $S_k(\\chi(z))$ 的浮点数值。\n6. 对于情况 D，存储相对差异测试 $|\\frac{S_k(\\chi) - \\chi}{\\max(1, \\chi)}|  10^{-10}$ 的布尔结果。\n7. 对于情况 E，存储测试 $S_k(\\chi(0))$ 是否等于 $0$ 的布尔结果。\n8. 所有结果将被收集到一个列表中，并以指定的逗号分隔格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the transverse comoving distance S_k(chi)\n    for a set of cosmological parameters and redshifts.\n    \"\"\"\n    \n    # (Omega_m, Omega_Lambda, Omega_k, z)\n    # Omega_r is assumed to be 0.\n    # Natural units with c/H_0 = 1 are used.\n    test_cases = [\n        # Case A: Happy path, flat universe\n        (0.3, 0.7, 0.0, 2.0),\n        # Case B: Closed universe\n        (0.3, 0.75, -0.05, 2.0),\n        # Case C: Open universe\n        (0.3, 0.65, 0.05, 2.0),\n        # Case D: Near-flat continuity check\n        (0.3, 0.7, 1e-12, 2.0),\n        # Case E: Zero-distance boundary\n        (0.3, 0.7, 0.0, 0.0),\n    ]\n\n    def _integrand(z_prime, om_m, om_l, om_k):\n        \"\"\"The integrand 1/E(z') for the comoving distance integral.\"\"\"\n        e_z = np.sqrt(om_m * (1 + z_prime)**3 + om_k * (1 + z_prime)**2 + om_l)\n        return 1.0 / e_z\n\n    def compute_chi(z, om_m, om_l, om_k):\n        \"\"\"\n        Calculates the line-of-sight comoving distance chi(z).\n        \"\"\"\n        if z == 0.0:\n            return 0.0\n        \n        # scipy.integrate.quad returns a tuple (result, error_estimate)\n        chi_val, _ = quad(_integrand, 0, z, args=(om_m, om_l, om_k))\n        return chi_val\n\n    def compute_Sk_chi(chi, om_k):\n        \"\"\"\n        Calculates the transverse comoving distance S_k(chi) using a\n        numerically robust algorithm.\n        \"\"\"\n        # In natural units with c/H_0=1, k_geom = -Omega_k\n        k_geom = -om_k\n\n        # Case 1: Flat universe (k_geom = 0)\n        if k_geom == 0.0:\n            return chi\n        \n        # Handle chi=0 boundary condition\n        if chi == 0.0:\n            return 0.0\n\n        # Argument for Taylor expansion/analytical functions\n        y = k_geom * chi**2\n        \n        # Threshold for switching to Taylor series to avoid cancellation error\n        TOLERANCE = 1e-8\n        if abs(y)  TOLERANCE:\n            # S_k(chi) = chi * (1 - y/6 + y^2/120 - y^3/5040 + ...)\n            # Use Horner's method for stable polynomial evaluation\n            val = chi * (1.0 - y / 6.0 * (1.0 - y / 20.0 * (1.0 - y / 42.0)))\n            return val\n        \n        # Case 2: Closed universe (k_geom > 0)\n        if k_geom > 0:\n            sqrt_k = np.sqrt(k_geom)\n            return np.sin(sqrt_k * chi) / sqrt_k\n        # Case 3: Open universe (k_geom  0)\n        else:\n            sqrt_abs_k = np.sqrt(-k_geom)\n            return np.sinh(sqrt_abs_k * chi) / sqrt_abs_k\n\n    results = []\n    \n    # Case A\n    om_m, om_l, om_k, z = test_cases[0]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case B\n    om_m, om_l, om_k, z = test_cases[1]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case C\n    om_m, om_l, om_k, z = test_cases[2]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case D\n    om_m, om_l, om_k, z = test_cases[3]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    relative_difference = abs(Sk_chi - chi) / max(1.0, chi)\n    results.append(relative_difference  1e-10)\n\n    # Case E\n    om_m, om_l, om_k, z = test_cases[4]\n    chi = compute_chi(z, om_m, om_l, om_k)  # This will be 0.0\n    Sk_chi = compute_Sk_chi(chi, om_k)      # This will be 0.0\n    results.append(Sk_chi == 0.0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() if isinstance(r, bool) else str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基础实现之上，本练习将深入分析弗里德曼方程的物理推论。它以特殊的“滑行宇宙”($w = -1/3$) 作为解析基准，来探索宇宙膨胀率和光度距离对状态方程参数微小变化的敏感性。这项实践连接了理论参数与其可观测印记之间的鸿沟，是物理宇宙学研究的一个关键方面 。",
            "id": "3495822",
            "problem": "您需要编写一个完整、可运行的程序，用于在空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学模型中，评估与“漂移情形”的微小偏离如何检验数值精度和灵敏度。该模型包含单一的、具有恒定物态参数 $w$（由 $p = w \\rho$ 定义）的流体。请完全在 Friedmann 方程和能量守恒的框架内进行，并明确说明您使用的所有假设。\n\n起点与假设：\n\n- 考虑一个空间平坦的 FLRW 宇宙，其度规兼容的哈勃参数为 $H(t) = \\dot{a}(t)/a(t)$，标度因子 $a(t)$ 在当前时刻 $t_0$ 归一化为 $a(t_0) = 1$，且宇宙中只含有一种具有恒定物态参数 $w$ 的单一理想流体。\n- 控制定律如下：\n  1. 空间曲率为零的 Friedmann 方程：$H^2(t) \\propto \\rho(t)$。\n  2. 局域能量-动量守恒：$\\dot{\\rho}(t) + 3 H(t)\\left[\\rho(t) + p(t)\\right] = 0$，其中 $p(t) = w \\rho(t)$。\n\n您的任务：\n\n1) 基于这些原理，推导归一化膨胀率 $E(a) \\equiv H(a)/H_0$ 作为标度因子 $a$ 的函数的自治初值问题，其中 $H_0$ 是 $a=1$ 时的哈勃常数。初始条件必须为 $E(1) = 1$，且自变量必须为 $a$。不要引入任何额外的组分或曲率。\n\n2) 推导与 $w=-1/3$ 对应的精确漂移解，并证明它意味着 $a(t) \\propto t$。获得以下量的精确闭式表达式：\n   - 基准归一化膨胀率 $E_{\\mathrm{coast}}(a)$。\n   - 平坦宇宙中的基准光度距离 $D_L^{\\mathrm{coast}}(z)$，其由视线共动距离 $D_C(z)$ 定义，其中 $D_L(z) = (1+z) D_C(z)$ 且 $1+z = 1/a$。\n\n3) 对于接近 $-1/3$ 的一般常数 $w$，进行数值计算：\n   - 通过求解任务 1 中的初值问题，在区间 $a \\in [a_{\\min}, 1]$（其中 $a_{\\min} = 0.1$）上计算归一化膨胀率 $E(a)$。\n   - 通过对共动距离积分进行数值求积，计算指定红移处的光度距离 $D_L(z)$。在空间平坦的宇宙中，视线共动距离定义为\n     $$D_C(a) = \\frac{c}{H_0} \\int_{a}^{1} \\frac{da'}{a'^2 E(a')}.$$\n   然后 $D_L(z) = (1+z)\\,D_C(z)$，其中 $a = 1/(1+z)$。\n\n4) 使用您的精确漂移表达式作为基准，通过以下两个无量纲度量来量化因 $w$ 偏离 $-1/3$ 而引起的偏差：\n   - 在标度因子网格上膨胀率的最大相对偏差：\n     $$\\Delta_E^{\\max}(w) \\equiv \\max_{a \\in [a_{\\min},1]} \\left| \\frac{E_w(a)}{E_{\\mathrm{coast}}(a)} - 1 \\right|.$$\n   - 在红移集合 $\\{z_i\\}$ 上光度距离的最大相对偏差：\n     $$\\Delta_{D_L}^{\\max}(w) \\equiv \\max_{z \\in \\{z_i\\}} \\left| \\frac{D_L^{(w)}(z)}{D_L^{\\mathrm{coast}}(z)} - 1 \\right|.$$\n\n实现细节和要求：\n\n- 采用哈勃常数 $H_0 = 70 \\text{ km s}^{-1} \\text{ Mpc}^{-1}$ 和光速 $c = 299792.458 \\text{ km s}^{-1}$。即使最终报告的度量是无量纲的，您也可以在积分内部使用这些常数。\n- 在 $[a_{\\min}, 1]$（其中 $a_{\\min} = 0.1$）上使用一个包含 $N_a = 400$ 个点的均匀网格来评估 $\\Delta_E^{\\max}(w)$。\n- 在红移集合 $\\{z_i\\} = \\{0.5, 1.0, 3.0\\}$ 处评估光度距离。\n- 所有最终报告的度量必须是无单位的小数。\n\n测试套件：\n\n- 为以下每个 $w$ 值计算序对 $\\left(\\Delta_E^{\\max}(w), \\Delta_{D_L}^{\\max}(w)\\right)$：\n  $$w \\in \\left\\{-\\frac{1}{3}, \\; -\\frac{1}{3} + 10^{-3}, \\; -\\frac{1}{3} - 10^{-3}, \\; -\\frac{1}{3} + 10^{-2}, \\; -\\frac{1}{3} - 10^{-2} \\right\\}.$$\n\n数值方法指南：\n\n- 您用于求解 $E(a)$ 的数值初值问题求解器必须在 $a=1$ 处施加初始条件，并向下积分至 $a_{\\min}$；选择足够严格的容差，以便能从精确解中分辨出 $w=-1/3$ 基准。\n- 您的共动距离积分必须通过数值求积法进行评估，其精度需足够高，以确保在 $w=-1/3$ 时的偏差主要由数值误差而非模型误差主导。\n\n最终输出规范：\n\n- 您的程序应生成单行输出，包含所有 $2\\times 5 = 10$ 个结果，按上文列出的 $w$ 值顺序排列，且在每种情况下，先是 $\\Delta_E^{\\max}(w)$，然后是 $\\Delta_{D_L}^{\\max}(w)$。\n- 最终输出必须是一个用方括号括起来的逗号分隔列表。每个浮点数必须以科学记数法打印，小数点后保留六位数字，例如 $1.234567\\mathrm{e}{-04}$。\n- 结果是无单位的小数。\n\n不允许用户输入；所有参数均按上述规定固定，程序应按原样运行至完成。最后一行必须是程序打印的唯一一行。",
            "solution": "该问题经评估有效。这是一个适定的、有科学依据的物理宇宙学问题，没有矛盾、歧义和事实错误。所有必要的参数和定义均已提供。因此，我们可以着手求解。\n\n该解答将按照问题陈述的要求分为四个部分。首先，我们推导归一化膨胀率的控制微分方程。其次，我们推导特殊的“漂移”情形的精确解析解，该解将作为基准。第三，我们概述求解一般问题的数值步骤。第四，我们定义用于量化与基准偏差的度量。\n\n**1. $E(a)$ 的初值问题推导**\n\n该问题设定在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，该宇宙包含一个具有恒定物态参数 $w$ 的单一理想流体组分。控制方程为 Friedmann 方程和能量-动量守恒方程。\n\n对于空间平坦（$k=0$）的宇宙，第一个 Friedmann 方程为：\n$$\nH^2(t) = \\left(\\frac{\\dot{a}}{a}\\right)^2 = \\frac{8\\pi G}{3} \\rho(t)\n$$\n这确立了 $H^2 \\propto \\rho$ 的比例关系。\n\n能量守恒方程（或流体方程）为：\n$$\n\\dot{\\rho}(t) + 3 H(t)\\left[\\rho(t) + p(t)\\right] = 0\n$$\n其中 $\\dot{\\rho} = d\\rho/dt$。我们已知线性物态方程 $p(t) = w \\rho(t)$，其中 $w$ 为常数。将其代入守恒方程得到：\n$$\n\\dot{\\rho} + 3 H \\rho (1+w) = 0\n$$\n为了找到密度 $\\rho$ 作为标度因子 $a$ 的函数的演化规律，我们使用链式法则将自变量从时间 $t$ 变为 $a$：$\\dot{\\rho} = \\frac{d\\rho}{da} \\frac{da}{dt} = \\frac{d\\rho}{da} (aH)$。守恒方程变为：\n$$\naH \\frac{d\\rho}{da} + 3H\\rho(1+w) = 0\n$$\n假设宇宙非静态（$H \\neq 0$），我们可以除以 $H$：\n$$\na \\frac{d\\rho}{da} = -3(1+w)\\rho\n$$\n这是一个可分离的一阶常微分方程。我们可以整理并积分它：\n$$\n\\int \\frac{d\\rho}{\\rho} = -3(1+w) \\int \\frac{da}{a} \\implies \\ln \\rho = -3(1+w) \\ln a + \\text{const}\n$$\n这给出了著名的流体密度标度关系：\n$$\n\\rho(a) = \\rho_0 a^{-3(1+w)}\n$$\n其中 $\\rho_0$ 是当前宇宙（定义为 $a(t_0)=1$）的密度。\n\n现在，我们使用 Friedmann 方程 $H^2 \\propto \\rho$。这意味着 $H(a)^2 = C \\rho(a)$，其中 $C$ 是某个常数。代入 $\\rho(a)$ 的表达式：\n$$\nH(a)^2 = C \\rho_0 a^{-3(1+w)}\n$$\n我们可以通过在当前时间（$a=1$）计算此表达式来确定比例常数。根据定义，$H(1) = H_0$，即哈勃常数。\n$$\nH_0^2 = C \\rho_0\n$$\n将此代回，得到哈勃参数作为标度因子的函数的演化规律：\n$$\nH(a)^2 = H_0^2 a^{-3(1+w)}\n$$\n问题要求一个关于归一化膨胀率 $E(a) \\equiv H(a)/H_0$ 的自治初值问题。从上述方程，我们通过开方并除以 $H_0$ 来找到 $E(a)$ 的解析解：\n$$\nE(a) = a^{-3(1+w)/2}\n$$\n此解析形式满足初始条件 $E(1) = 1^{-3(1+w)/2} = 1$。为了构建初值问题本身，我们将 $E(a)$ 对 $a$ 求导：\n$$\n\\frac{dE}{da} = \\frac{d}{da} \\left( a^{-3(1+w)/2} \\right) = -\\frac{3(1+w)}{2} a^{-3(1+w)/2 - 1} = -\\frac{3(1+w)}{2} \\frac{1}{a} \\left( a^{-3(1+w)/2} \\right)\n$$\n注意到括号中的项是 $E(a)$，我们得到微分方程：\n$$\n\\frac{dE}{da} = -\\frac{3(1+w)}{2a} E(a)\n$$\n这是控制 $E(a)$ 的自治常微分方程。完整的初值问题 (IVP) 是：\n$$\n\\text{IVP}: \\quad \\frac{dE}{da} = -\\frac{3(1+w)}{2a} E(a), \\quad \\text{初始条件为} \\quad E(1) = 1.\n$$\n这就是需要进行数值求解的初值问题。\n\n**2. “漂移”解析解 ($w=-1/3$)**\n\n$w = -1/3$ 的特殊情况对应于一个“漂移”宇宙。\n首先，我们证明 $a(t) \\propto t$。对于 $w=-1/3$，密度演化的指数为 $-3(1+w) = -3(1 - 1/3) = -2$。因此，$\\rho(a) \\propto a^{-2}$。\nFriedmann 方程 $H^2 \\propto \\rho$ 意味着 $H^2 \\propto a^{-2}$，所以 $H(a) = H_0/a$。\n回顾定义 $H = \\dot{a}/a$，我们有 $\\dot{a}/a = H_0/a$，简化为 $\\dot{a} = H_0 = \\text{const}$。对时间积分得到 $a(t) = H_0 t + C$。通过适当地选择时间原点，我们可以将积分常数 $C$ 设为零，得到 $a(t) = H_0 t$，这证实了 $a(t) \\propto t$。\n\n基准归一化膨胀率 $E_{\\mathrm{coast}}(a)$，可以通过将 $w=-1/3$ 代入 $E(a)$ 的解析解得到：\n$$\nE_{\\mathrm{coast}}(a) = a^{-3(1-1/3)/2} = a^{-3(2/3)/2} = a^{-1}\n$$\n\n接下来，我们推导光度距离 $D_L^{\\mathrm{coast}}(z)$。在空间平坦的宇宙中，从位于 $a=1$ 的观测者到位于标度因子 $a$ 处的源的视线共动距离 $D_C(z)$ 由下式给出：\n$$\nD_C(a) = \\frac{c}{H_0} \\int_{a}^{1} \\frac{da'}{a'^2 E(a')}\n$$\n对于漂移情形，我们代入 $E_{\\mathrm{coast}}(a') = (a')^{-1}$：\n$$\nD_C^{\\mathrm{coast}}(a) = \\frac{c}{H_0} \\int_{a}^{1} \\frac{da'}{a'^2 (a')^{-1}} = \\frac{c}{H_0} \\int_{a}^{1} \\frac{da'}{a'} = \\frac{c}{H_0} [\\ln a']_{a}^{1} = \\frac{c}{H_0}(\\ln 1 - \\ln a) = -\\frac{c}{H_0}\\ln a\n$$\n标度因子 $a$ 和红移 $z$ 之间的关系是 $1+z = 1/a$，这意味着 $a = 1/(1+z)$。将此代入 $D_C^{\\mathrm{coast}}$ 的表达式：\n$$\nD_C^{\\mathrm{coast}}(z) = -\\frac{c}{H_0}\\ln\\left(\\frac{1}{1+z}\\right) = \\frac{c}{H_0}\\ln(1+z)\n$$\n光度距离 $D_L(z)$ 与共动距离的关系为 $D_L(z) = (1+z)D_C(z)$。因此，漂移光度距离的精确表达式为：\n$$\nD_L^{\\mathrm{coast}}(z) = \\frac{c}{H_0} (1+z) \\ln(1+z)\n$$\n\n**3. 数值计算**\n\n对于任意常数 $w$，我们必须采用数值方法。\n- **求解 $E_w(a)$**：我们将数值求解初值问题 $\\frac{dE}{da} = -\\frac{3(1+w)}{2a} E(a)$，初始条件为 $E(1)=1$。积分将对自变量 $a$ 从 $a=1$ 向下进行到 $a_{\\min}=0.1$。解将在一个包含 $N_a=400$ 个点的均匀网格上获得。我们将使用高质量的 ODE 求解器，例如 `scipy.integrate.solve_ivp`，并设置严格的容差以最小化数值误差。\n\n- **计算 $D_L^{(w)}(z)$**：首先，我们计算共动距离 $D_C^{(w)}(z)$。这涉及评估积分：\n$$\nD_C^{(w)}(a) = \\frac{c}{H_0} \\int_{a}^{1} \\frac{da'}{a'^2 E_w(a')}\n$$\n其中 $a = 1/(1+z)$。由于 $E_w(a')$ 是来自 ODE 求解器的数值解，它以一组离散点的形式存在。为了使用像 `scipy.integrate.quad` 这样的稳健求积方法，我们首先通过插值（例如，三次样条插值）从离散解创建一个连续函数。设此插值函数为 $\\tilde{E}_w(a')$。积变为：\n$$\n\\int_{a}^{1} \\frac{da'}{a'^2 \\tilde{E}_w(a')}\n$$\n对于每个所需的红移 $z_i$（以及对应的标度因子 $a_i = 1/(1+z_i)$），此积分将被数值计算。然后，光度距离计算为 $D_L^{(w)}(z_i) = (1+z_i) D_C^{(w)}(z_i)$。\n\n**4. 量化偏差**\n\n我们计算两个度量来量化 $w \\neq -1/3$ 的模型与漂移基准的偏差。\n- **膨胀率的最大相对偏差**：\n$$\n\\Delta_E^{\\max}(w) = \\max_{a \\in \\{a_j\\}} \\left| \\frac{E_w(a_j)}{E_{\\mathrm{coast}}(a_j)} - 1 \\right| = \\max_{a \\in \\{a_j\\}} \\left| a_j E_w(a_j) - 1 \\right|\n$$\n其中 $\\{a_j\\}$ 是从 $a_{\\min}=0.1$ 到 $1$ 的 $N_a=400$ 个点的网格，而 $E_w(a_j)$ 是在这些点上的数值解。\n\n- **光度距离的最大相对偏差**：\n$$\n\\Delta_{D_L}^{\\max}(w) = \\max_{z \\in \\{z_i\\}} \\left| \\frac{D_L^{(w)}(z)}{D_L^{\\mathrm{coast}}(z)} - 1 \\right|\n$$\n其中 $\\{z_i\\} = \\{0.5, 1.0, 3.0\\}$。$D_L^{(w)}(z)$ 如第 3 部分所述进行数值计算，而 $D_L^{\\mathrm{coast}}(z)$ 使用第 2 部分的解析公式计算。\n\n整个过程将对所提供的测试套件中的每个 $w$ 值执行。对于 $w=-1/3$ 的特殊情况，计算出的偏差 $\\Delta_E^{\\max}$ 和 $\\Delta_{D_L}^{\\max}$ 应该非零但极小，这对应于 ODE 求解器和求积例程的累积数值误差。这可作为对数值实现的关键内部验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the cosmology problem by calculating deviations from the coasting case.\n    \"\"\"\n    # Define constants\n    H0 = 70.0  # Hubble constant in km s^-1 Mpc^-1\n    c = 299792.458  # Speed of light in km s^-1\n    c_over_H0 = c / H0 # Hubble distance in Mpc\n\n    # Define numerical parameters\n    a_min = 0.1\n    a_max = 1.0\n    N_a = 400\n    z_points = np.array([0.5, 1.0, 3.0])\n    a_grid = np.linspace(a_min, a_max, N_a)\n\n    # Define test suite for w\n    w_values = [\n        -1.0/3.0,\n        -1.0/3.0 + 1e-3,\n        -1.0/3.0 - 1e-3,\n        -1.0/3.0 + 1e-2,\n        -1.0/3.0 - 1e-2,\n    ]\n\n    results = []\n\n    for w in w_values:\n        # --- Task 1  3.1: Solve for E(a) ---\n\n        # Define the ODE: dE/da = -1.5 * (1 + w) * E / a\n        def ode_E(a, E, w_val):\n            # The case a=0 is an issue, but we integrate from a=1 down to a=0.1\n            # so we avoid the singularity.\n            if a == 0:\n                return 0\n            return -1.5 * (1.0 + w_val) * E / a\n\n        # Solve the IVP from a=1 down to a_min\n        # We integrate from a_max to a_min, so the span is [a_max, a_min].\n        # t_eval needs to be sorted for the solver, then we reverse the results.\n        sol = solve_ivp(\n            fun=lambda a, E: ode_E(a, E, w),\n            t_span=[a_max, a_min],\n            y0=[1.0],\n            method='RK45',\n            t_eval=np.linspace(a_min, a_max, N_a)[::-1], # Integrate backwards\n            rtol=1e-12,\n            atol=1e-12\n        )\n        \n        # The solver returns results in ascending order of 't', so we must reverse\n        # them to match our a_grid which is ascending.\n        E_w_a = sol.y[0][::-1]\n        a_sol_grid = sol.t[::-1]\n\n        # --- Task 4.1: Compute Delta_E_max ---\n        E_coast_a = 1.0 / a_sol_grid\n        rel_dev_E = np.abs(E_w_a / E_coast_a - 1.0)\n        delta_E_max = np.max(rel_dev_E)\n\n        # --- Task 3.2: Compute D_L(z) ---\n        \n        # Create an interpolant for the numerical solution E_w(a)\n        # We need to allow extrapolation for values very close to 1.0 just in case\n        E_interpolant = interp1d(a_sol_grid, E_w_a, kind='cubic', fill_value=\"extrapolate\")\n\n        def integrand_DC(a_prime, E_func):\n            return 1.0 / (a_prime**2 * E_func(a_prime))\n\n        # Analytical coasting luminosity distance\n        def D_L_coast(z):\n            if z == 0: return 0.0\n            return c_over_H0 * (1.0 + z) * np.log(1.0 + z)\n\n        D_L_deviations = []\n        for z in z_points:\n            a_val = 1.0 / (1.0 + z)\n            \n            # Numerically integrate to get comoving distance for model w\n            integral_val, _ = quad(\n                lambda ap: integrand_DC(ap, E_interpolant),\n                a_val,\n                1.0,\n                epsabs=1e-13,\n                epsrel=1e-13\n            )\n            \n            D_C_w = c_over_H0 * integral_val\n            D_L_w = (1.0 + z) * D_C_w\n            \n            # Calculate the analytical coasting value\n            D_L_c = D_L_coast(z)\n            \n            # Calculate relative deviation\n            if D_L_c == 0:\n                rel_dev_DL = 0.0 if D_L_w == 0 else np.inf\n            else:\n                rel_dev_DL = np.abs(D_L_w / D_L_c - 1.0)\n            \n            D_L_deviations.append(rel_dev_DL)\n\n        # --- Task 4.2: Compute Delta_D_L_max ---\n        delta_DL_max = np.max(D_L_deviations)\n\n        results.extend([delta_E_max, delta_DL_max])\n\n    # Final output formatting\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}