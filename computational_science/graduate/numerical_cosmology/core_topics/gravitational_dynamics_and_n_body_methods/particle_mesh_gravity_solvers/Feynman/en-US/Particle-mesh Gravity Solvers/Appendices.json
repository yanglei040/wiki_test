{
    "hands_on_practices": [
        {
            "introduction": "The heart of a Particle-Mesh (PM) solver is its ability to efficiently solve Poisson's equation on a grid. This is achieved by approximating the continuous Laplacian operator, $\\nabla^2$, with a finite-difference stencil, which introduces calculable errors. This practice guides you to derive the Fourier-space representation of this discrete operator and compare its response to the true continuum solution, revealing a fundamental source of error and anisotropy in all grid-based PM simulations. ",
            "id": "3481169",
            "problem": "You are asked to build a spectral diagnostic for Particle-Mesh (PM) gravity solvers and to implement it as a complete, runnable program. The goal is to derive, implement, and evaluate a relative error measure comparing the continuum Green’s function to the discrete PM Green’s function for different Fourier mode orientations. Begin from first principles of Newtonian gravity and discretization, and do not assume any of the target formulas in advance.\n\nStart from the fundamental Newtonian Poisson equation in physical space for a gravitational potential, given by the relationship between a mass density field and its potential:\n$$\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),$$\nwhere $\\phi(\\mathbf{x})$ is the gravitational potential, $\\rho(\\mathbf{x})$ is the mass density, and $G$ is the gravitational constant. Use the properties of the spatial Fourier transform under periodic boundary conditions to obtain the continuum Fourier-space relation linking $\\phi(\\mathbf{k})$ and $\\rho(\\mathbf{k})$. Then, construct the discrete counterpart by applying a second-order central-difference approximation to the Laplacian on a uniform cubic mesh with spacing $\\Delta x$, and periodic boundary conditions, to obtain the discrete Fourier-space representation of the Laplacian. Using these, derive the continuum Green’s function and the discrete Particle-Mesh (PM) Green’s function in Fourier space for a cubic domain.\n\nDefine a dimensionless spectral diagnostic that measures the relative error between the discrete PM Green’s function and the continuum Green’s function for a Fourier mode $\\mathbf{k}$:\n$$\\varepsilon(\\mathbf{k}) = \\frac{G_{\\mathrm{PM}}(\\mathbf{k})}{G(\\mathbf{k})} - 1,$$\nwhere $G(\\mathbf{k})$ is the continuum Green’s function and $G_{\\mathrm{PM}}(\\mathbf{k})$ is the discrete PM Green’s function. Your diagnostic should expose the anisotropy introduced by the discrete operator, by quantifying errors for different orientations of $\\mathbf{k}$ that share the same continuum magnitude but distribute components differently across the axes.\n\nConsider a cubic periodic box of side length $L$ sampled on a uniform $N\\times N\\times N$ grid. The grid spacing is $\\Delta x = L/N$. Under periodic boundary conditions, the allowed Fourier modes satisfy $k_i = \\frac{2\\pi n_i}{L}$ for integers $n_i$ in the appropriate range. The gravitational constant $G$ should be taken as its value in the International System of Units (SI), $G = 6.67430 \\times 10^{-11}$ in $\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$, although the diagnostic you design must be dimensionless and independent of units. All answers in this problem must be reported as dimensionless numbers.\n\nImplement a program that:\n- Derives the necessary Fourier-space operators from first principles as described above, and formulates the diagnostic $\\varepsilon(\\mathbf{k})$.\n- Computes $\\varepsilon(\\mathbf{k})$ for each specified test case in the suite defined below.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets.\n\nUse the following fixed domain and resolution:\n- Box length $L = 100$ megaparsecs, where $1$ megaparsec $= 3.085677581491367\\times 10^{22}$ meters; convert $L$ to meters internally.\n- Grid size $N = 128$.\n\nUse the following test suite of integer wave-index triplets $(n_x,n_y,n_z)$, which define the Fourier mode components via $k_i = \\frac{2\\pi n_i}{L}$:\n1. $(n_x,n_y,n_z) = (1,0,0)$, a low-frequency axis-aligned mode.\n2. $(n_x,n_y,n_z) = (3,0,0)$, an axis-aligned mode used for orientation comparison.\n3. $(n_x,n_y,n_z) = (2,2,1)$, a mixed-orientation mode with the same continuum $k^2$ as $(3,0,0)$.\n4. $(n_x,n_y,n_z) = (10,0,0)$, a higher-frequency axis-aligned mode near the Nyquist range.\n5. $(n_x,n_y,n_z) = (8,6,0)$, a mixed-orientation mode with the same continuum $k^2$ as $(10,0,0)$.\n6. $(n_x,n_y,n_z) = (64,0,0)$, a Nyquist axis-aligned mode.\n7. $(n_x,n_y,n_z) = (64,64,64)$, a Nyquist body-diagonal mode.\n\nFor each test case, compute the diagnostic $\\varepsilon(\\mathbf{k})$ as a floating-point number. The final program output must be a single line containing a list of the seven results, in the exact format:\n$$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5,\\varepsilon_6,\\varepsilon_7],$$\nwith no units and expressed as dimensionless decimal numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`).",
            "solution": "The user has requested the derivation and implementation of a spectral diagnostic to measure the error in a Particle-Mesh (PM) gravity solver. The process begins with validating the problem statement, which is found to be scientifically sound, well-posed, and complete. We now proceed with the solution, deriving the necessary expressions from first principles.\n\nThe starting point is the Newtonian Poisson equation, which relates the gravitational potential $\\phi(\\mathbf{x})$ to the mass density distribution $\\rho(\\mathbf{x})$:\n$$\n\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x})\n$$\nwhere $G$ is the gravitational constant. We are considering a cubic domain of side length $L$ with periodic boundary conditions. In such a domain, any well-behaved function can be represented by a Fourier series. Let $\\phi_{\\mathbf{k}}$ and $\\rho_{\\mathbf{k}}$ be the Fourier series coefficients of the potential and density fields, respectively, corresponding to the wavevector $\\mathbf{k}$. The wavevectors are discrete and given by $\\mathbf{k} = (k_x, k_y, k_z) = (\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}, \\frac{2\\pi n_z}{L})$ for integer indices $(n_x, n_y, n_z)$.\n\nThe action of the Laplacian operator $\\nabla^2$ in Fourier space is equivalent to multiplication by $-|\\mathbf{k}|^2 = -k^2$. Applying this to the Poisson equation transforms the partial differential equation in real space into an algebraic equation in Fourier space for each mode $\\mathbf{k}$:\n$$\n-k^2 \\phi_{\\mathbf{k}} = 4\\pi G \\rho_{\\mathbf{k}}\n$$\nThis equation defines the relationship in the continuum limit. We can solve for the potential coefficient $\\phi_{\\mathbf{k}}$:\n$$\n\\phi_{\\mathbf{k}} = \\left( -\\frac{4\\pi G}{k^2} \\right) \\rho_{\\mathbf{k}}\n$$\nThe term in parentheses is the continuum Green's function in Fourier space, which we denote as $G(\\mathbf{k})$. It acts as a transfer function between the density and potential for a given mode.\n$$\nG(\\mathbf{k}) = -\\frac{4\\pi G}{k^2} \\quad \\text{where} \\quad k^2 = |\\mathbf{k}|^2 = k_x^2 + k_y^2 + k_z^2.\n$$\n\nNext, we consider the discrete system. The domain is sampled on a uniform $N \\times N \\times N$ grid with grid spacing $\\Delta x = L/N$. The continuous Laplacian operator $\\nabla^2$ is approximated using a second-order accurate finite-difference stencil. At a grid point indexed by $(i,j,l)$, the central-difference approximation to the Laplacian is:\n$$\n(\\nabla^2_{\\mathrm{PM}}\\phi)_{i,j,l} = \\frac{\\phi_{i+1,j,l} - 2\\phi_{i,j,l} + \\phi_{i-1,j,l}}{(\\Delta x)^2} + \\frac{\\phi_{i,j+1,l} - 2\\phi_{i,j,l} + \\phi_{i,j-1,l}}{(\\Delta x)^2} + \\frac{\\phi_{i,j,l+1} - 2\\phi_{i,j,l} + \\phi_{i,j,l-1}}{(\\Delta x)^2}\n$$\nTo find the Fourier-space representation of this discrete operator, we examine its action on a Fourier basis function $e^{i\\mathbf{k} \\cdot \\mathbf{x}}$, where $\\mathbf{x}_{i,j,l} = (i\\Delta x, j\\Delta x, l\\Delta x)$. The action of the $x$-component of the discrete Laplacian is:\n$$\n\\frac{e^{ik_x(i+1)\\Delta x} - 2e^{ik_xi\\Delta x} + e^{ik_x(i-1)\\Delta x}}{(\\Delta x)^2} = \\frac{e^{ik_xi\\Delta x} (e^{ik_x\\Delta x} - 2 + e^{-ik_x\\Delta x})}{(\\Delta x)^2} = \\frac{e^{ik_xi\\Delta x} (2\\cos(k_x\\Delta x) - 2)}{(\\Delta x)^2}\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, this simplifies to:\n$$\n- \\frac{4\\sin^2(k_x\\Delta x/2)}{(\\Delta x)^2} e^{ik_xi\\Delta x}\n$$\nSumming the contributions from all three spatial dimensions, the discrete Laplacian operator acts as a multiplicative factor in Fourier space, which we denote $-k^2_{\\mathrm{eff}}(\\mathbf{k})$:\n$$\n-k^2_{\\mathrm{eff}}(\\mathbf{k}) = -\\frac{4}{(\\Delta x)^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\nThe discrete Poisson equation in Fourier space is therefore:\n$$\n-k^2_{\\mathrm{eff}}(\\mathbf{k}) \\phi_{\\mathbf{k}} = 4\\pi G \\rho_{\\mathbf{k}}\n$$\nThis gives the discrete Particle-Mesh (PM) Green's function for the potential:\n$$\nG_{\\mathrm{PM}}(\\mathbf{k}) = -\\frac{4\\pi G}{k^2_{\\mathrm{eff}}(\\mathbf{k})}\n$$\nThe diagnostic $\\varepsilon(\\mathbf{k})$ measures the relative error between the discrete and continuum Green's functions:\n$$\n\\varepsilon(\\mathbf{k}) = \\frac{G_{\\mathrm{PM}}(\\mathbf{k})}{G(\\mathbf{k})} - 1 = \\frac{-4\\pi G / k^2_{\\mathrm{eff}}(\\mathbf{k})}{-4\\pi G / k^2} - 1 = \\frac{k^2}{k^2_{\\mathrm{eff}}(\\mathbf{k})} - 1\n$$\nNote that the factor $4\\pi G$ cancels, making the diagnostic independent of the gravitational constant's value and units.\n\nTo implement this formula, we express $k^2$ and $k^2_{\\mathrm{eff}}(\\mathbf{k})$ in terms of the integer wave indices $(n_x, n_y, n_z)$ and the grid size $N$.\nWe have $k_i = \\frac{2\\pi n_i}{L}$ and $\\Delta x = L/N$. Thus, the argument of the sine function becomes $k_i \\Delta x / 2 = (\\frac{2\\pi n_i}{L})(\\frac{L}{N}) / 2 = \\frac{\\pi n_i}{N}$.\nThe continuum squared wavenumber is:\n$$\nk^2 = \\left(\\frac{2\\pi}{L}\\right)^2 (n_x^2 + n_y^2 + n_z^2)\n$$\nThe effective discrete squared wavenumber is:\n$$\nk^2_{\\mathrm{eff}}(\\mathbf{k}) = \\frac{4}{(\\Delta x)^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right) = \\frac{4}{(L/N)^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right) = \\frac{4N^2}{L^2} \\sum_{j \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)\n$$\nSubstituting these into the expression for $\\varepsilon(\\mathbf{k})$:\n$$\n\\varepsilon(\\mathbf{k}) = \\frac{\\left(\\frac{2\\pi}{L}\\right)^2 (n_x^2 + n_y^2 + n_z^2)}{\\frac{4N^2}{L^2} \\sum_{j} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)} - 1 = \\frac{\\frac{4\\pi^2}{L^2}}{\\frac{4N^2}{L^2}} \\frac{n_x^2 + n_y^2 + n_z^2}{\\sum_{j} \\sin^2\\left(\\frac{\\pi n_j}{N}\\right)} - 1\n$$\nThe box size $L$ cancels, yielding the final dimensionless formula to be implemented:\n$$\n\\varepsilon(n_x, n_y, n_z) = \\frac{\\pi^2}{N^2} \\frac{n_x^2 + n_y^2 + n_z^2}{\\sin^2\\left(\\frac{\\pi n_x}{N}\\right) + \\sin^2\\left(\\frac{\\pi n_y}{N}\\right) + \\sin^2\\left(\\frac{\\pi n_z}{N}\\right)} - 1\n$$\nThis formula shows that the relative error depends only on the integer wave indices $(n_x, n_y, n_z)$ and the grid resolution $N$. The error is positive because for $x>0$, $\\sin(x) < x$, which implies $k^2_{\\mathrm{eff}}(\\mathbf{k}) < k^2$. This means the discrete operator systematically underestimates the magnitude of the Laplacian, leading to a weaker calculated force. The dependence on the orientation of $\\mathbf{k}$ (i.e., on the distribution of magnitude among $n_x, n_y, n_z$) arises from the non-linear nature of the sine function, causing anisotropy in the error. The problem's comparison of modes with the same value of $n_x^2 + n_y^2 + n_z^2$ but different individual components will highlight this anisotropy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a spectral diagnostic for a Particle-Mesh (PM) gravity solver.\n\n    The function calculates the relative error between the continuum and discrete\n    Green's functions in Fourier space for a set of specified wave modes.\n    \"\"\"\n\n    # Define physical constants and simulation parameters as specified in the problem.\n    # Note: L, G, and MPC_TO_M are provided for context and completeness of the\n    # physical setup, but the derived diagnostic epsilon is dimensionless and\n    # independent of these values, as shown in the derivation.\n    G_si = 6.67430e-11  # m^3 kg^-1 s^-2\n    MPC_TO_M = 3.085677581491367e22 # meters per megaparsec\n    L_mpc = 100.0  # Megaparsecs\n    L_m = L_mpc * MPC_TO_M # meters\n    N = 128  # Grid size (N x N x N)\n\n    # Test suite of integer wave-index triplets (nx, ny, nz)\n    test_cases = [\n        (1, 0, 0),    # Low-frequency axis-aligned mode\n        (3, 0, 0),    # Axis-aligned mode\n        (2, 2, 1),    # Mixed-orientation mode with same continuum k^2 as (3,0,0)\n        (10, 0, 0),   # Higher-frequency axis-aligned mode\n        (8, 6, 0),    # Mixed-orientation mode with same continuum k^2 as (10,0,0)\n        (64, 0, 0),   # Nyquist axis-aligned mode\n        (64, 64, 64)  # Nyquist body-diagonal mode\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        nx, ny, nz = case\n        \n        # The diagnostic epsilon(k) is given by the formula:\n        # epsilon = (k^2 / k_eff^2) - 1\n        # where k is the continuum wavenumber and k_eff is the effective\n        # wavenumber from the finite-difference operator.\n        #\n        # k^2 = (2*pi/L)^2 * (nx^2 + ny^2 + nz^2)\n        # k_eff^2 = (2*N/L)^2 * (sin(pi*nx/N)^2 + sin(pi*ny/N)^2 + sin(pi*nz/N)^2)\n        #\n        # The ratio k^2 / k_eff^2 simplifies to:\n        # (pi/N)^2 * (nx^2 + ny^2 + nz^2) / (sin(pi*nx/N)^2 + ...)\n        # This final form is independent of L and G.\n\n        # Numerator part related to continuum k^2\n        n_squared = float(nx**2 + ny**2 + nz**2)\n        \n        # Denominator part related to discrete k_eff^2\n        # Handle the k=0 case to avoid division by zero, although not in test suite.\n        if n_squared == 0:\n            # The k=0 mode (DC component) has an infinite Green's function\n            # and the error is undefined. We assign NaN or handle as per convention.\n            # Here, we can skip it, but the test cases avoid n=(0,0,0).\n            epsilon = np.nan\n        else:\n            sum_sin_squared = (\n                np.sin(np.pi * nx / N)**2 +\n                np.sin(np.pi * ny / N)**2 +\n                np.sin(np.pi * nz / N)**2\n            )\n            \n            # The factor (pi/N)^2 comes from the ratio of k^2 and k_eff^2 prefactors\n            factor = (np.pi / N)**2\n            \n            epsilon = factor * n_squared / sum_sin_squared - 1.0\n\n        results.append(epsilon)\n\n    # Final print statement in the exact required format.\n    # Example format: [result1,result2,result3]\n    # We use a high-precision format for the floating point numbers.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When estimating cosmological statistics like the power spectrum, assigning particle mass to a grid introduces two key effects: a smoothing of the field by the assignment window and aliasing from the act of discrete sampling. This exercise provides a theoretical framework for calculating the total aliased power measured on the mesh for a simple shot-noise field. By comparing different assignment schemes, you will quantify the residual bias after deconvolution and understand the trade-offs in suppressing these pervasive numerical artifacts. ",
            "id": "3481236",
            "problem": "Consider the standard Particle-Mesh (PM) pipeline used in numerical cosmology to estimate the matter power spectrum from particle realizations on a uniform mesh. In this pipeline, particle masses are deposited to a regular grid using a finite-extent assignment kernel before applying a Fast Fourier Transform (FFT). The mass assignment is equivalent to a convolution in real space with a compact window, which becomes a multiplication by a window function in Fourier space. For an unclustered Poisson particle process with constant mean number density $n_{\\rm bar}$, the true matter power is white and equal to $P_0 = 1/n_{\\rm bar}$. However, on a discrete mesh, spectral replication caused by sampling introduces aliasing of power from outside the first Brillouin zone into the measured band, and the assignment window suppresses modes by a known factor.\n\nYou will explore how the mass assignment windows alter the recovered matter power and how deconvolution $P_{\\rm dec}(\\boldsymbol{k}) = P_{\\rm PM}(\\boldsymbol{k})/|W(\\boldsymbol{k})|^2$ changes the result. Use the following definitions and assumptions:\n\n- Define the computational domain as a periodic cube of side length $L$ with $N^3$ grid cells, uniform grid spacing $\\Delta = L/N$, and wavenumbers on the Discrete Fourier Transform (DFT) grid given by $\\boldsymbol{k} = 2\\pi \\boldsymbol{n}/L$ with integer components $\\boldsymbol{n}$ consistent with the FFT ordering. The Nyquist wavenumber per axis is $k_{\\rm Ny} = \\pi/\\Delta$.\n- Adopt the following Fourier-space mass assignment window amplitudes (per mode), written as a product over Cartesian axes:\n  - Nearest Grid Point (NGP): $W_{\\rm NGP}(\\boldsymbol{k}) = \\prod_{j\\in\\{x,y,z\\}} \\mathrm{sinc}\\!\\left(\\tfrac{k_j \\Delta}{2}\\right)$.\n  - Cloud-In-Cell (CIC): $W_{\\rm CIC}(\\boldsymbol{k}) = \\prod_{j\\in\\{x,y,z\\}} \\mathrm{sinc}^2\\!\\left(\\tfrac{k_j \\Delta}{2}\\right)$.\n  - Triangular Shaped Cloud (TSC): $W_{\\rm TSC}(\\boldsymbol{k}) = \\prod_{j\\in\\{x,y,z\\}} \\mathrm{sinc}^3\\!\\left(\\tfrac{k_j \\Delta}{2}\\right)$.\n  Here $\\mathrm{sinc}(x) \\equiv \\sin(x)/x$ with the convention $\\mathrm{sinc}(0)=1$.\n- Assume an underlying unclustered Poisson process (shot noise only) with true power $P_0 = 1/n_{\\rm bar}$, and neglect any physical clustering. Work entirely in dimensionless units for power ratios and fractional biases, so no physical units are required in the final answers.\n\nStarting from the fundamental sampling picture that a function observed on a grid is multiplied by a Shah comb in real space and hence replicated in Fourier space, and from the definition of the mass assignment windows above, derive how the measured mesh power $P_{\\rm PM}(\\boldsymbol{k})$ is built from the true spectrum and the replicated spectra induced by sampling. Then implement a numerical evaluation that approximates the spectral replication by including only the nearest replicas whose wavevectors differ from the principal zone by shifts of $\\pm 2k_{\\rm Ny}$ along each axis (that is, integer triplets $\\boldsymbol{m} \\in \\{-1,0,1\\}^3$). Use this approximation to compute:\n1. The mesh-measured power $P_{\\rm PM}(\\boldsymbol{k})$ for each mass assignment scheme.\n2. The deconvolved estimate $P_{\\rm dec}(\\boldsymbol{k}) = P_{\\rm PM}(\\boldsymbol{k})/|W(\\boldsymbol{k})|^2$.\n3. Spherically averaged $P_{\\rm dec}(k)$ by binning modes by $k = |\\boldsymbol{k}|$.\n4. The fractional bias in specified $k$-ranges relative to the white-noise level $P_0$, defined as the average over a bin of $\\left(P_{\\rm dec}(k)/P_0\\right) - 1$.\n\nYour program must carry out the following test suite and report the requested biases as floating-point numbers, in this exact order:\n\n- Use a cubic mesh with $N=64$ and $L=1$ (so that $k$ is in radians per unit length and $k_{\\rm Ny} = \\pi N$ given $L=1$). Adopt the alias-replica approximation described above. Evaluate the mean fractional bias of $P_{\\rm dec}(k)$ in the two $k$-ranges defined by $[0.1 k_{\\rm Ny}, 0.3 k_{\\rm Ny}]$ (“low-$k$”) and $[0.7 k_{\\rm Ny}, 0.9 k_{\\rm Ny}]$ (“high-$k$”), for each of the three mass assignment schemes:\n  1. Low-$k$ bias for $W_{\\rm NGP}$.\n  2. Low-$k$ bias for $W_{\\rm CIC}$.\n  3. Low-$k$ bias for $W_{\\rm TSC}$.\n  4. High-$k$ bias for $W_{\\rm NGP}$.\n  5. High-$k$ bias for $W_{\\rm CIC}$.\n  6. High-$k$ bias for $W_{\\rm TSC}$.\n\nImportant implementation details and conventions:\n- Compute the wavenumber grid exactly as for a Discrete Fourier Transform, using integer mode indices consistent with a standard FFT implementation.\n- For deconvolution, evaluate $|W(\\boldsymbol{k})|^2$ at the unshifted modes. Avoid division by extremely small $|W|^2$ by excluding modes with $|W|^2 < 10^{-12}$ from bin averages.\n- Because the target is the fractional bias of $P_{\\rm dec}(k)$ relative to $P_0$, the specific value of $n_{\\rm bar}$ cancels out; you may fix $P_0$ to any positive constant for numerical convenience.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the exact order listed above (e.g., `[r1,r2,r3,r4,r5,r6]`). Each entry must be a floating-point number. No additional text should be printed.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of Fourier analysis and numerical methods used in cosmology, is well-posed with a complete and consistent set of definitions and parameters, and is objective in its formulation. We can therefore proceed with a solution.\n\nThe problem asks for an analysis of aliasing artifacts in the Particle-Mesh (PM) power spectrum estimation. We begin by deriving the expression for the measured power spectrum on the mesh, account for the mass assignment window, and then compute the fractional bias of the deconvolved power spectrum.\n\nA set of particles represents a sampling of an underlying continuous matter density field. When these particles are assigned to a discrete grid, two main effects alter the inferred power spectrum. First, the assignment process, which involves a finite-extent kernel, is a convolution in real space. By the convolution theorem, this corresponds to a multiplication by a window function, $W(\\boldsymbol{k})$, in Fourier space, which suppresses power, especially at high wavenumbers. Second, the evaluation of the density field on a discrete grid with spacing $\\Delta$ leads to aliasing: power from wavenumbers $|\\boldsymbol{k}| > k_{\\rm Ny}$ (where $k_{\\rm Ny} = \\pi/\\Delta$ is the Nyquist wavenumber) is folded back into the principal Brillouin zone $[ -k_{\\rm Ny}, k_{\\rm Ny} ]^3$.\n\nFor a Poisson distribution of particles with mean number density $n_{\\rm bar}$, which has a true, continuous power spectrum of white noise $P_{\\rm true}(\\boldsymbol{k}) = P_0 = 1/n_{\\rm bar}$, the power spectrum measured on the mesh, $P_{\\rm PM}(\\boldsymbol{k})$, is given by the sum of the true power at aliased wavenumbers, each weighted by the corresponding squared window function. This standard result from numerical cosmology (e.g., Hockney & Eastwood, 1988) is:\n$$\nP_{\\rm PM}(\\boldsymbol{k}) = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} |W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2 P_{\\rm true}(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})\n$$\nwhere the wavevector $\\boldsymbol{k}$ is in the principal zone, and the sum is over all integer vectors $\\boldsymbol{m}$ corresponding to all replicas of the fundamental Brillouin zone. The quantity $2k_{\\rm Ny} = 2\\pi/\\Delta$ is the spacing between zones in Fourier space.\n\nSince $P_{\\rm true}(\\boldsymbol{k}) = P_0$ is constant (white noise), it factors out of the sum:\n$$\nP_{\\rm PM}(\\boldsymbol{k}) = P_0 \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} |W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2\n$$\nThe problem specifies an approximation where we only consider the nearest replicas, i.e., $\\boldsymbol{m} \\in \\{-1, 0, 1\\}^3$. This means we sum over $3^3 = 27$ terms for each $\\boldsymbol{k}$.\n\nThe mass assignment window functions are given as:\n- Nearest Grid Point (NGP): $W_{\\rm NGP}(\\boldsymbol{k}) = \\prod_{j\\in\\{x,y,z\\}} \\mathrm{sinc}\\!\\left(\\tfrac{k_j \\Delta}{2}\\right)$\n- Cloud-In-Cell (CIC): $W_{\\rm CIC}(\\boldsymbol{k}) = \\left( W_{\\rm NGP}(\\boldsymbol{k}) \\right)^2$\n- Triangular Shaped Cloud (TSC): $W_{\\rm TSC}(\\boldsymbol{k}) = \\left( W_{\\rm NGP}(\\boldsymbol{k}) \\right)^3$\n\nHere, $\\mathrm{sinc}(x) \\equiv \\sin(x)/x$. For a discrete grid of size $N^3$ and length $L$, the wavenumbers are $k_j = 2\\pi n_j / L$, where $n_j$ are integer mode indices. The grid spacing is $\\Delta = L/N$. The argument of the sinc function becomes:\n$$\n\\frac{k_j \\Delta}{2} = \\frac{(2\\pi n_j/L)(L/N)}{2} = \\frac{\\pi n_j}{N}\n$$\nSo, the fundamental window function can be written in terms of the integer mode indices $\\boldsymbol{n}$: $W_{\\rm NGP}(\\boldsymbol{n}) = \\prod_{j} \\mathrm{sinc}(\\pi n_j/N)$. The shifted wavenumber $\\boldsymbol{k}' = \\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny}$ corresponds to an effective integer mode index $\\boldsymbol{n}' = \\boldsymbol{n} + \\boldsymbol{m}N$. The argument for the sinc function of the aliased mode is $\\pi(n_j/N + m_j)$.\n\nThe measured power is then corrected, or \"deconvolved\", by dividing out the effect of the window function in the principal zone ($\\boldsymbol{m}=\\mathbf{0}$):\n$$\nP_{\\rm dec}(\\boldsymbol{k}) = \\frac{P_{\\rm PM}(\\boldsymbol{k})}{|W(\\boldsymbol{k})|^2} = P_0 \\frac{\\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3} |W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2}{|W(\\boldsymbol{k})|^2}\n$$\nThe fractional bias relative to the true power $P_0$ is defined as $\\left(P_{\\rm dec}(\\boldsymbol{k})/P_0\\right) - 1$. Substituting the expression for $P_{\\rm dec}(\\boldsymbol{k})$:\n$$\n\\text{Bias}(\\boldsymbol{k}) = \\frac{P_{\\rm dec}(\\boldsymbol{k})}{P_0} - 1 = \\left( \\frac{|W(\\boldsymbol{k})|^2 + \\sum_{\\boldsymbol{m} \\neq \\boldsymbol{0}} |W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2}{|W(\\boldsymbol{k})|^2} \\right) - 1 = \\frac{\\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3, \\boldsymbol{m} \\neq \\boldsymbol{0}} |W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2}{|W(\\boldsymbol{k})|^2}\n$$\nThis quantity represents the fractional power aliased from other zones relative to the power in the principal zone. The final step is to average this bias over all modes $\\boldsymbol{k}$ that fall within specified spherical shells in $k$-space.\n\nThe numerical implementation will execute the following steps:\n1. Set up the computational grid parameters: $N=64$, $L=1$.\n2. Generate the 3D grid of integer mode indices $\\boldsymbol{n}$ and corresponding wavenumbers $\\boldsymbol{k}$.\n3. For each mass assignment scheme (NGP, CIC, TSC), which corresponds to a power $p \\in \\{1, 2, 3\\}$ of the base window:\n    a. Calculate the aliased power $P_{\\rm PM}(\\boldsymbol{k})$ by summing the squared window function $|W(\\boldsymbol{k} + 2\\boldsymbol{m}k_{\\rm Ny})|^2$ over $\\boldsymbol{m} \\in \\{-1,0,1\\}^3$. $P_0$ is set to $1$.\n    b. Calculate the unshifted window power $|W(\\boldsymbol{k})|^2$.\n    c. Compute the deconvolved power ratio $P_{\\rm dec}(\\boldsymbol{k})/P_0$ by dividing the results of (a) by (b), avoiding division by values smaller than $10^{-12}$.\n4. Spherically average the fractional bias, $(P_{\\rm dec}/P_0) - 1$, over modes whose magnitudes $k=|\\boldsymbol{k}|$ lie in the \"low-$k$\" range $[0.1 k_{\\rm Ny}, 0.3 k_{\\rm Ny}]$ and \"high-$k$\" range $[0.7 k_{\\rm Ny}, 0.9 k_{\\rm Ny}]$.\n5. Report the six mean bias values in the specified order.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the fractional bias in the deconvolved matter power spectrum\n    due to aliasing in a Particle-Mesh simulation.\n    \"\"\"\n    # Define parameters from the problem statement\n    N = 64\n    L = 1.0\n\n    # The problem asks for 6 specific values from a single run.\n    # We will assemble them in this list in the correct order.\n    # Order: [low_k_NGP, low_k_CIC, low_k_TSC, high_k_NGP, high_k_CIC, high_k_TSC]\n    final_results = []\n    \n    # Store intermediate results to assemble the final list correctly.\n    low_k_biases = []\n    high_k_biases = []\n\n    # Setup grid and constants\n    delta = L / N\n    k_Ny = np.pi / delta\n\n    # Integer mode indices n_j, consistent with numpy's FFT conventions\n    n_modes = np.fft.fftfreq(N) * N\n    Nx, Ny, Nz = np.meshgrid(n_modes, n_modes, n_modes, indexing='ij')\n\n    # Wavenumber grid\n    Kx = (2 * np.pi / L) * Nx\n    Ky = (2 * np.pi / L) * Ny\n    Kz = (2 * np.pi / L) * Nz\n    K_mag = np.sqrt(Kx**2 + Ky**2 + Kz**2)\n    \n    # Define k-ranges for bias calculation\n    k_low_min = 0.1 * k_Ny\n    k_low_max = 0.3 * k_Ny\n    k_high_min = 0.7 * k_Ny\n    k_high_max = 0.9 * k_Ny\n    \n    # Define masks for k-ranges based on k-magnitude\n    low_k_mask = (K_mag >= k_low_min) & (K_mag <= k_low_max)\n    high_k_mask = (K_mag >= k_high_min) & (K_mag <= k_high_max)\n    \n    # Loop over window function types (p=1 for NGP, 2 for CIC, 3 for TSC)\n    for p in [1, 2, 3]:\n        # --- Calculate P_PM from aliased window functions ---\n        P_PM_grid = np.zeros((N, N, N), dtype=float)\n        \n        # Sum over replica indices m in {-1, 0, 1}^3\n        m_indices = [-1, 0, 1]\n        for mx in m_indices:\n            for my in m_indices:\n                for mz in m_indices:\n                    # Argument for numpy's sinc function is n/N + m, as derived in the solution\n                    sinc_arg_x = Nx / N + mx\n                    sinc_arg_y = Ny / N + my\n                    sinc_arg_z = Nz / N + mz\n                    \n                    # np.sinc(x) is defined as sin(pi*x)/(pi*x)\n                    sinc_x = np.sinc(sinc_arg_x)\n                    sinc_y = np.sinc(sinc_arg_y)\n                    sinc_z = np.sinc(sinc_arg_z)\n                    \n                    # Full window function W(k') for the p-th scheme\n                    W_shifted_p = (sinc_x * sinc_y * sinc_z)**p\n                    \n                    # Add contribution to P_PM. P_0 is implicitly 1.\n                    P_PM_grid += W_shifted_p**2\n\n        # --- Calculate unshifted window function for deconvolution ---\n        sinc_x_0 = np.sinc(Nx / N)\n        sinc_y_0 = np.sinc(Ny / N)\n        sinc_z_0 = np.sinc(Nz / N)\n        \n        W_unshifted_p = (sinc_x_0 * sinc_y_0 * sinc_z_0)**p\n        W2_unshifted = W_unshifted_p**2\n        \n        # Deconvolve P_PM to get P_dec. Since P_0=1, this is the ratio P_dec/P_0.\n        # Use np.divide to handle division by zero or small numbers safely.\n        P_dec_grid = np.divide(P_PM_grid, W2_unshifted, \n                                out=np.zeros_like(P_PM_grid), \n                                where=W2_unshifted > 1e-12)\n\n        # --- Calculate Biases ---\n        # Create a mask for modes where deconvolution is valid\n        W_mask = W2_unshifted > 1e-12\n        \n        # Calculate low-k bias\n        final_low_k_mask = low_k_mask & W_mask\n        if np.any(final_low_k_mask):\n            p_dec_low_k_vals = P_dec_grid[final_low_k_mask]\n            bias_low_k = np.mean(p_dec_low_k_vals) - 1.0\n        else:\n            bias_low_k = 0.0 # Should not happen with the given k-ranges\n        low_k_biases.append(bias_low_k)\n        \n        # Calculate high-k bias\n        final_high_k_mask = high_k_mask & W_mask\n        if np.any(final_high_k_mask):\n            p_dec_high_k_vals = P_dec_grid[final_high_k_mask]\n            bias_high_k = np.mean(p_dec_high_k_vals) - 1.0\n        else:\n            bias_high_k = 0.0 # Should not happen with the given k-ranges\n        high_k_biases.append(bias_high_k)\n\n    # Assemble results in the specified order:\n    # 1-3: Low-k biases for NGP, CIC, TSC\n    final_results.extend(low_k_biases)\n    # 4-6: High-k biases for NGP, CIC, TSC\n    final_results.extend(high_k_biases)\n\n    print(f\"[{','.join(f'{r:.12f}' for r in final_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Accurate force calculation is only half the battle; we must use these forces to integrate particle trajectories faithfully through time, especially within the context of an expanding universe. This practice moves from static analysis to dynamics, challenging you to implement and compare two standard adaptive time-stepping criteria for a symplectic leapfrog integrator. By measuring phase-space errors against a high-fidelity solution, you will develop an intuition for how to maintain accuracy efficiently as particles encounter diverse physical conditions. ",
            "id": "3481172",
            "problem": "You will implement and compare two adaptive time step criteria for integrating collisionless particles under gravity in a one-dimensional Particle-Mesh (PM) setting formulated in an expanding cosmology. The goal is to quantify which criterion better preserves phase-space fidelity for a set of test cases by direct numerical experimentation, starting from fundamental laws and definitions.\n\nFundamental setup and equations:\n- Consider a spatially flat, matter-dominated Universe (Einstein–de Sitter) with scale factor $a(\\tau)$ expressed in conformal time $\\tau$, where $a(\\tau) = \\tau^{2}$. The conformal time $\\tau$ is defined by $d\\tau = dt_{\\mathrm{phys}}/a(t_{\\mathrm{phys}})$.\n- Work in comoving coordinates $x$ on a one-dimensional periodic box of length $L = 1$.\n- The gravitational potential $\\phi(x)$ is time-independent in this matter era (linear regime) and satisfies the comoving Poisson equation\n$$\n\\frac{\\partial^{2}\\phi}{\\partial x^{2}} = 4\\pi G a^{2} \\left(\\rho - \\bar{\\rho}\\right).\n$$\nTo ensure a time-independent gravitational potential in this regime, choose a single-mode potential\n$$\n\\phi(x) = \\frac{\\cos(k x)}{k^{2}},\n$$\nwith $k = 2\\pi$ (radians per unit length). Angles in trigonometric functions must be interpreted in radians.\n- The canonical momentum $p$ and comoving position $x$ evolve in conformal time according to the Hamiltonian form of the equations of motion:\n$$\nx'(\\tau) = \\frac{p(\\tau)}{a(\\tau)^{2}}, \\quad p'(\\tau) = -\\frac{\\partial \\phi}{\\partial x}\\bigg|_{x(\\tau)},\n$$\nwhere a prime denotes $d/d\\tau$.\n\nTime step criteria to compare:\n- Courant-like criterion (advection-limited): Require that in one time step the comoving displacement is a fraction $\\eta$ of the mesh spacing $\\Delta x$. The instantaneous comoving advection speed is $s = |x'| = |p|/a^{2}$. The criterion defines\n$$\n\\Delta \\tau_{\\mathrm{C}} = \\eta \\frac{\\Delta x}{|x'|} = \\eta \\frac{\\Delta x \\, a(\\tau)^{2}}{|p|}.\n$$\n- Acceleration-based criterion (curvature-limited): Bound the local truncation error by requiring that the comoving displacement induced by the gravitational curvature in one step is a fraction $\\eta$ of $\\Delta x$. Using the gravitational part of the second derivative of position $x''_{\\mathrm{grav}} = p'/a^{2} = -\\left(\\partial \\phi/\\partial x\\right)/a^{2}$, define\n$$\n\\Delta \\tau_{\\mathrm{A}} = \\eta \\sqrt{\\frac{\\Delta x}{|x''_{\\mathrm{grav}}|}} = \\eta \\sqrt{\\frac{\\Delta x \\, a(\\tau)^{2}}{\\left|\\partial \\phi/\\partial x\\right|}}.\n$$\nIn both criteria, when the denominator is zero, interpret the corresponding $\\Delta \\tau$ as unconstrained by that rule and equal to the remaining time to the final time.\n\nIntegrator specification:\n- Use a second-order, time-centered leapfrog (Kick-Drift-Kick) in conformal time $\\tau$:\n  1. Kick: $p_{n+\\frac{1}{2}} = p_{n} + \\frac{\\Delta \\tau}{2} \\, F(x_{n})$, where $F(x) = -\\partial \\phi/\\partial x$.\n  2. Drift: $x_{n+1} = x_{n} + \\Delta \\tau \\, \\frac{p_{n+\\frac{1}{2}}}{a(\\tau_{n} + \\Delta \\tau/2)^{2}}$.\n  3. Kick: $p_{n+1} = p_{n+\\frac{1}{2}} + \\frac{\\Delta \\tau}{2} \\, F(x_{n+1})$.\n- Periodic boundary conditions on $[0, L)$ must be enforced for $x$ by wrapping mod $L$ after each drift.\n- Define the mesh spacing as $\\Delta x = L/N_{\\mathrm{grid}}$.\n\nPhase-space fidelity metric:\n- For each adaptive criterion, integrate from an initial time $\\tau_{\\mathrm{i}}$ to a final time $\\tau_{\\mathrm{f}}$, starting from initial conditions $(x_{0}, p_{0})$.\n- Construct a high-accuracy reference trajectory by integrating the same equations with the same leapfrog scheme but a fixed, very small time step $\\Delta \\tau_{\\mathrm{ref}} = 10^{-4}$.\n- At $\\tau_{\\mathrm{f}}$, compute the phase-space error\n$$\n\\varepsilon = \\sqrt{\\Delta x_{\\mathrm{per}}^{2} + \\Delta p^{2}},\n$$\nwhere $\\Delta x_{\\mathrm{per}}$ is the minimum periodic distance between the two positions on the circle of length $L$, and $\\Delta p$ is the difference in $p$.\n\nExperimental protocol:\n- For each test case below, run two adaptive integrations using only one criterion at a time:\n  - Courant-like only: $\\Delta \\tau = \\Delta \\tau_{\\mathrm{C}}$ at each step (capped only by the remaining time to $\\tau_{\\mathrm{f}}$).\n  - Acceleration-based only: $\\Delta \\tau = \\Delta \\tau_{\\mathrm{A}}$ at each step (capped only by the remaining time).\n- For each test case, compute the ratio $r = \\varepsilon_{\\mathrm{C}} / \\varepsilon_{\\mathrm{A}}$, where $\\varepsilon_{\\mathrm{C}}$ is the Courant-only error and $\\varepsilon_{\\mathrm{A}}$ is the acceleration-only error.\n\nTest suite:\nUse $L = 1$ and $k = 2\\pi$. For all cases, interpret trigonometric arguments in radians.\n- Case 1 (happy path): $N_{\\mathrm{grid}} = 64$, $\\eta = 0.2$, $\\tau_{\\mathrm{i}} = 0.5$, $\\tau_{\\mathrm{f}} = 2.0$, $x_{0} = 0.1$, $p_{0} = 0.0$.\n- Case 2 (high-speed stress): $N_{\\mathrm{grid}} = 64$, $\\eta = 0.3$, $\\tau_{\\mathrm{i}} = 0.5$, $\\tau_{\\mathrm{f}} = 2.0$, $x_{0} = 0.25$, $p_{0} = 2.0$.\n- Case 3 (weak-force edge): $N_{\\mathrm{grid}} = 32$, $\\eta = 0.3$, $\\tau_{\\mathrm{i}} = 0.5$, $\\tau_{\\mathrm{f}} = 2.0$, $x_{0} = 0.0$, $p_{0} = 0.5$.\n\nRequired final output:\n- Your program must produce a single line containing a list of three floating-point numbers `[r_1, r_2, r_3]`, where $r_{i}$ is the ratio $\\varepsilon_{\\mathrm{C}} / \\varepsilon_{\\mathrm{A}}$ for test case $i$, each rounded to six decimal places.\n- No other output should be printed.\n\nAll quantities are to be treated as dimensionless code units. Angles are to be interpreted in radians. Ensure scientific realism by strictly following the equations and definitions stated above without introducing additional heuristic caps beyond limiting the time step to the remaining interval to $\\tau_{\\mathrm{f}}$ when necessary.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It presents a standard, albeit simplified, numerical experiment in computational cosmology, free of any factual or logical contradictions.\n\nThe task is to implement and compare two adaptive time-stepping criteria for integrating a particle's trajectory in a one-dimensional, expanding cosmological model. The comparison is based on phase-space fidelity, quantified by the deviation from a high-accuracy reference solution. The solution is constructed by first establishing the physical and numerical framework, then implementing the specified algorithms.\n\n**1. Physical and Mathematical Model**\n\nThe simulation is set in a spatially flat, matter-dominated (Einstein-de Sitter) universe, where the scale factor $a$ evolves with conformal time $\\tau$ as $a(\\tau) = \\tau^2$. The particle's motion is restricted to a one-dimensional periodic domain of comoving length $L=1$.\n\nThe particle's dynamics are governed by Hamilton's equations in comoving coordinates $(x, p)$, where $x$ is the position and $p$ is the canonical momentum. The equations of motion are given in terms of derivatives with respect to conformal time $\\tau$:\n$$\n\\frac{dx}{d\\tau} = x'(\\tau) = \\frac{p(\\tau)}{a(\\tau)^2}\n$$\n$$\n\\frac{dp}{d\\tau} = p'(\\tau) = -\\frac{\\partial \\phi}{\\partial x}\\bigg|_{x(\\tau)}\n$$\nThe problem specifies a time-independent, single-mode gravitational potential $\\phi(x) = \\frac{\\cos(kx)}{k^2}$ with wavenumber $k=2\\pi$. The force on the particle is therefore:\n$$\nF(x) = -\\frac{\\partial \\phi}{\\partial x} = -\\frac{d}{dx}\\left(\\frac{\\cos(kx)}{k^2}\\right) = - \\left(\\frac{-k\\sin(kx)}{k^2}\\right) = \\frac{\\sin(kx)}{k}\n$$\nThis setup provides a complete, deterministic system for the particle's evolution from a given initial state $(x_0, p_0)$ at an initial time $\\tau_{\\mathrm{i}}$.\n\n**2. Numerical Integration Scheme**\n\nA second-order, time-centered leapfrog integrator, also known as Kick-Drift-Kick (KDK), is used to numerically solve the equations of motion. This scheme is symplectic, meaning it is well-suited for preserving the geometric properties of phase space in Hamiltonian systems, which is critical for long-term orbital integrations. For a time step $\\Delta\\tau$ from time $\\tau_n$ to $\\tau_{n+1}$, the KDK algorithm proceeds in three steps:\n\n1.  **Kick (half-step):** The momentum is updated by a half-step using the force at the initial position $x_n$.\n    $$\n    p_{n+\\frac{1}{2}} = p_{n} + \\frac{\\Delta \\tau}{2} \\, F(x_{n})\n    $$\n2.  **Drift (full-step):** The position is updated by a full step using the half-step momentum $p_{n+1/2}$. For second-order accuracy in an expanding background, the scale factor in the drift term must be evaluated at the midpoint of the time interval, $\\tau_{n+\\frac{1}{2}} = \\tau_n + \\Delta\\tau/2$.\n    $$\n    x_{n+1} = x_{n} + \\Delta \\tau \\, \\frac{p_{n+\\frac{1}{2}}}{a(\\tau_{n+\\frac{1}{2}})^2}\n    $$\n    Substituting $a(\\tau)=\\tau^2$, the denominator becomes $a(\\tau_{n+\\frac{1}{2}})^2 = ((\\tau_n+\\Delta\\tau/2)^2)^2 = (\\tau_n+\\Delta\\tau/2)^4$. After the drift, periodic boundary conditions are applied: $x_{n+1} \\rightarrow x_{n+1} \\pmod L$.\n\n3.  **Kick (half-step):** The momentum is updated for the remaining half-step using the force at the new position $x_{n+1}$.\n    $$\n    p_{n+1} = p_{n+\\frac{1}{2}} + \\frac{\\Delta \\tau}{2} \\, F(x_{n+1})\n    $$\n\n**3. Adaptive Time Step Criteria**\n\nThe core of the experiment is the comparison of two adaptive time step criteria. At each step, a new $\\Delta\\tau$ is computed based on the particle's current state $(x_n, p_n, \\tau_n)$. The mesh spacing is defined as $\\Delta x = L/N_{\\mathrm{grid}}$.\n\n**Courant-like Criterion ($\\Delta\\tau_{\\mathrm{C}}$):** This criterion limits the comoving distance a particle travels in a single step to a fraction $\\eta$ of the mesh spacing $\\Delta x$. It is an advection-limited criterion, crucial for high-velocity particles. The instantaneous comoving velocity is $|x'| = |p|/a(\\tau)^2$. The condition is $\\Delta\\tau |x'| \\le \\eta \\Delta x$. Solving for $\\Delta\\tau$ gives:\n$$\n\\Delta \\tau_{\\mathrm{C}} = \\eta \\frac{\\Delta x}{|x'|} = \\eta \\frac{\\Delta x \\, a(\\tau)^2}{|p|} = \\eta \\frac{\\Delta x \\, \\tau^4}{|p|}\n$$\nIf the momentum $|p|$ is zero, this step is unconstrained by this rule, and $\\Delta\\tau$ is set to the remaining simulation time, $\\tau_{\\mathrm{f}} - \\tau$.\n\n**Acceleration-based Criterion ($\\Delta\\tau_{\\mathrm{A}}$):** This criterion bounds the local truncation error by limiting the displacement caused by gravitational acceleration. It is a curvature-limited criterion, important in regions of strong force. The gravitational part of the second derivative of position is $x''_{\\mathrm{grav}} = p'/a^2 = F(x)/a^2$. The problem defines the timestep as:\n$$\n\\Delta \\tau_{\\mathrm{A}} = \\eta \\sqrt{\\frac{\\Delta x}{|x''_{\\mathrm{grav}}|}} = \\eta \\sqrt{\\frac{\\Delta x \\, a(\\tau)^2}{|F(x)|}} = \\eta \\sqrt{\\frac{\\Delta x \\, \\tau^4}{|F(x)|}}\n$$\nwhere $|F(x)| = |\\partial \\phi/\\partial x|$. If the force $|F(x)|$ is zero, this step is also unconstrained, and $\\Delta\\tau$ is set to $\\tau_{\\mathrmf} - \\tau$.\n\nIn all cases, the calculated time step is capped to not exceed the remaining time to the end of the simulation: $\\Delta\\tau = \\min(\\Delta\\tau_{\\mathrm{calculated}}, \\tau_{\\mathrm{f}} - \\tau_n)$.\n\n**4. Fidelity Assessment and Implementation**\n\nTo quantify the accuracy of each criterion, a reference trajectory is first computed using the same KDK integrator but with a very small, fixed time step $\\Delta\\tau_{\\mathrm{ref}} = 10^{-4}$. The final state of this integration, $(x_{\\mathrm{ref}}, p_{\\mathrm{ref}})$ at $\\tau_{\\mathrm{f}}$, is considered the \"ground truth.\"\n\nFor each of the two adaptive criteria (Courant-only and Acceleration-only), a separate simulation is run, yielding final states $(x_{\\mathrm{C}}, p_{\\mathrm{C}})$ and $(x_{\\mathrm{A}}, p_{\\mathrm{A}})$. The error for each run is calculated as the Euclidean distance in phase space from the reference solution:\n$$\n\\varepsilon = \\sqrt{\\Delta x_{\\mathrm{per}}^{2} + \\Delta p^{2}}\n$$\nHere, $\\Delta p$ is the simple difference in final momenta, and $\\Delta x_{\\mathrm{per}}$ is the periodic distance on the domain of length $L=1$, calculated as $\\min(|x - x_{\\mathrm{ref}}|, L - |x - x_{\\mathrm{ref}}|)$.\n\nFinally, the relative performance is quantified by the ratio $r = \\varepsilon_{\\mathrm{C}} / \\varepsilon_{\\mathrm{A}}$. A value of $r > 1$ indicates the acceleration-based criterion was more accurate for that test case, while $r < 1$ indicates the Courant-like criterion was superior. The entire procedure is implemented in a Python script, which automates the simulations for the three specified test cases and computes the required ratios.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants and helper functions\nL = 1.0\nK = 2.0 * np.pi\nDT_REF = 1e-4\n\ndef force(x):\n    \"\"\"Calculates the force F(x) = sin(kx)/k.\"\"\"\n    return np.sin(K * x) / K\n\ndef calculate_error(state1, state2):\n    \"\"\"Calculates the phase-space error between two states.\"\"\"\n    x1, p1 = state1\n    x2, p2 = state2\n    \n    dx_abs = np.abs(x1 - x2)\n    dx_per = min(dx_abs, L - dx_abs)\n    dp = p1 - p2\n    \n    return np.sqrt(dx_per**2 + dp**2)\n\ndef integrate(tau_i, tau_f, x0, p0, N_grid, eta, criterion=None, fixed_dt=None):\n    \"\"\"\n    Integrates the particle's trajectory using a KDK leapfrog scheme.\n    Can operate with a fixed timestep (for reference) or adaptive timesteps.\n    \"\"\"\n    tau = float(tau_i)\n    x = float(x0)\n    p = float(p0)\n    delta_x = L / N_grid\n    \n    # Thresholds to check for \"zero\" denominators in floating point\n    small_p_threshold = 1e-15\n    small_force_threshold = 1e-15\n\n    while tau < tau_f:\n        if fixed_dt:\n            dt = fixed_dt\n        else:  # Adaptive step\n            # Note: a(tau)^2 = (tau^2)^2 = tau^4\n            a_tau_squared = tau**4\n            \n            # --- Courant-like timestep ---\n            if np.abs(p) < small_p_threshold:\n                dt_c = tau_f - tau\n            else:\n                dt_c = eta * delta_x * a_tau_squared / np.abs(p)\n                \n            # --- Acceleration-based timestep ---\n            F_x = force(x)\n            if np.abs(F_x) < small_force_threshold:\n                dt_a = tau_f - tau\n            else:\n                dt_a = eta * np.sqrt(delta_x * a_tau_squared / np.abs(F_x))\n            \n            if criterion == 'C':\n                dt = dt_c\n            elif criterion == 'A':\n                dt = dt_a\n            else:\n                raise ValueError(\"Invalid criterion specified for adaptive integration.\")\n\n        # Cap timestep to not overshoot tau_f\n        # This ensures the final step lands exactly at tau_f\n        dt = min(dt, tau_f - tau)\n        \n        # If dt is effectively zero, an FPU underflow might have occurred.\n        # This also prevents an infinite loop if tau is extremely close to tau_f.\n        if dt <= 0:\n            break\n\n        # KDK Leapfrog Integrator Step\n        tau_mid = tau + 0.5 * dt\n        p_half = p + 0.5 * dt * force(x)\n        \n        # Drift: using a(tau_mid)^2 = tau_mid^4 in denominator\n        drift_denom = tau_mid**4\n        x_new = x + dt * p_half / drift_denom\n        \n        # Apply periodic boundary condition\n        x_new = x_new % L\n        \n        # Second Kick\n        p_new = p_half + 0.5 * dt * force(x_new)\n        \n        # Update state for next step\n        x, p, tau = x_new, p_new, tau + dt\n        \n    return x, p\n\ndef solve():\n    \"\"\"\n    Runs the full numerical experiment for all test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        # (N_grid, eta, tau_i, tau_f, x0, p0)\n        (64, 0.2, 0.5, 2.0, 0.1, 0.0),\n        (64, 0.3, 0.5, 2.0, 0.25, 2.0),\n        (32, 0.3, 0.5, 2.0, 0.0, 0.5),\n    ]\n\n    results = []\n    \n    for N_grid, eta, tau_i, tau_f, x0, p0 in test_cases:\n        # 1. High-accuracy reference solution\n        x_ref, p_ref = integrate(tau_i, tau_f, x0, p0, N_grid, eta, fixed_dt=DT_REF)\n        \n        # 2. Courant-like criterion solution\n        x_c, p_c = integrate(tau_i, tau_f, x0, p0, N_grid, eta, criterion='C')\n        \n        # 3. Acceleration-based criterion solution\n        x_a, p_a = integrate(tau_i, tau_f, x0, p0, N_grid, eta, criterion='A')\n\n        # 4. Calculate errors by comparing to the reference trajectory\n        err_c = calculate_error((x_c, p_c), (x_ref, p_ref))\n        err_a = calculate_error((x_a, p_a), (x_ref, p_ref))\n\n        # 5. Compute the ratio of errors\n        if err_a < 1e-15:\n            if err_c < 1e-15:\n                ratio = 1.0  # Both are perfect (highly unlikely)\n            else:\n                ratio = np.inf # Acceleration criterion is \"infinitely\" better\n        else:\n            ratio = err_c / err_a\n            \n        results.append(ratio)\n        \n    # Format the final list of ratios as specified in the problem\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}