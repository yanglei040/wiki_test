{
    "hands_on_practices": [
        {
            "introduction": "线性物质功率谱的幅度并非静止不变，它随着宇宙的膨胀而演化。这种演化由线性增长因子 $D(z)$ 捕捉，它对宇宙的能量组分和几何性质非常敏感。本练习将指导您从第一性原理出发，推导并数值求解 $D(z)$ 的微分方程，从而让您能直接探究具有不同空间曲率和暗能量组分的宇宙学模型如何改变结构形成的历史 。",
            "id": "3497156",
            "problem": "要求您推导并实现一种数值方法，用以计算一类包含物质、空间曲率和宇宙学常数的 Friedmann-Robertson-Walker (FRW) 宇宙学模型中的线性增长因子 $D(z)$。您的实现必须评估在此基础上，对于三个具有相同当今物质密度参数 $\\Omega_{m,0}$ 但空间曲率和宇宙学常数不同的宇宙学模型，线性物质功率谱 $P(k)$ 的大尺度振幅所产生的相应变化。推导和算法必须从基本原理和经过检验的事实出发，不得使用问题描述中提供的简化公式。\n\n请从以下与背景相符的基本依据开始：\n- 适用于由 FRW 度规和广义相对论 (GR) 描述的、包含物质、空间曲率和宇宙学常数的均匀各向同性宇宙的 Friedmann 方程，以及哈勃膨胀率 $H(a)$ 与能量密度之间的关系。\n- 膨胀背景下无压流体的线性化连续性方程、Euler 方程和 Poisson 方程，这些方程在牛顿近似下，蕴含了膨胀 FRW 背景中物质密度衬度 $\\delta$ 所满足的二阶齐次常微分方程 (ODE)。\n- 通过线性演化过程中的 $\\delta(a) \\propto D(a)$ 定义线性增长因子 $D(a)$，以及在足够大的尺度上（远大于非线性尺度），线性物质功率谱的标度关系为 $P(k,a) \\propto D(a)^2$。\n\n您的程序必须实现一个数值稳定的 ODE 求解器，用以计算以下三个具有相同当今物质密度参数的宇宙学模型的 $D(z)$：\n- 开放宇宙：$\\Omega_{m,0} = 0.3$，$\\Omega_{\\Lambda,0} = 0.0$，$\\Omega_{k,0} = 1 - \\Omega_{m,0} - \\Omega_{\\Lambda,0}$。\n- 平坦宇宙：$\\Omega_{m,0} = 0.3$，$\\Omega_{\\Lambda,0} = 1 - \\Omega_{m,0}$，$\\Omega_{k,0} = 0$。\n- 闭合宇宙：$\\Omega_{m,0} = 0.3$，$\\Omega_{\\Lambda,0} = 0.8$，$\\Omega_{k,0} = 1 - \\Omega_{m,0} - \\Omega_{\\Lambda,0}$。\n\n假设与要求：\n- 在所考虑的所有红移处忽略辐射。\n- 使用与红移通过 $a = 1/(1+z)$ 相关的尺度因子 $a$。\n- 使用初始尺度因子 $a_{\\mathrm{init}} = 10^{-4}$，此时物质主导成立，并对所有宇宙学模型施加相同的初始条件，即 $D(a_{\\mathrm{init}}) = a_{\\mathrm{init}}$ 和 $\\frac{dD}{d\\ln a}\\big|_{a_{\\mathrm{init}}} = a_{\\mathrm{init}}$，从而确保 $D(z)$ 的差异完全源于不同的背景膨胀历史。\n- 不要在 $z = 0$ 处对 $D(z)$进行重新归一化；相反，应保持由 $a_{\\mathrm{init}}$ 处的相同初始条件所引出的归一化。\n- 哈勃膨胀率 $H(a)$ 必须根据指定的 $\\Omega_{m,0}$、$\\Omega_{\\Lambda,0}$ 和 $\\Omega_{k,0}$ 从 Friedmann 方程中一致地计算得出，并且关于 $D(a)$ 的常微分方程必须用 $a$ 或 $\\ln a$ 来表述，其系数由 $H(a)$ 推导。每个中间量都必须在数学上是良定义的。\n\n根据计算出的 $D(z)$，为每个宇宙学模型定义大尺度振幅因子 $A(z) \\equiv D(z)^2$，该因子捕捉了 $P(k)$ 在大尺度上的整体归一化变化（忽略转移函数形状的差异）。对于每个测试红移，计算比率 $A_{\\mathrm{open}}(z)/A_{\\mathrm{flat}}(z)$ 和 $A_{\\mathrm{closed}}(z)/A_{\\mathrm{flat}}(z)$ 以量化相对于平坦模型的振幅差异。\n\n测试组：\n- 使用红移集合 $\\{z\\} = \\{0, 1, 3, 10\\}$。\n- 对于集合中的每个 $z$，计算并报告上述三种宇宙学模型的以下量：\n  1. $D_{\\mathrm{open}}(z)$,\n  2. $D_{\\mathrm{flat}}(z)$,\n  3. $D_{\\mathrm{closed}}(z)$,\n  4. $A_{\\mathrm{open}}(z) = D_{\\mathrm{open}}(z)^2$,\n  5. $A_{\\mathrm{flat}}(z) = D_{\\mathrm{flat}}(z)^2$,\n  6. $A_{\\mathrm{closed}}(z) = D_{\\mathrm{closed}}(z)^2$,\n  7. $A_{\\mathrm{open}}(z)/A_{\\mathrm{flat}}(z)$,\n  8. $A_{\\mathrm{closed}}(z)/A_{\\mathrm{flat}}(z)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有红移的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是代表一个红移的列表。对于每个红移 $z$，子列表必须按以下顺序排列\n  $[z, D_{\\mathrm{open}}(z), D_{\\mathrm{flat}}(z), D_{\\mathrm{closed}}(z), A_{\\mathrm{open}}(z), A_{\\mathrm{flat}}(z), A_{\\mathrm{closed}}(z), A_{\\mathrm{open}}(z)/A_{\\mathrm{flat}}(z), A_{\\mathrm{closed}}(z)/A_{\\mathrm{flat}}(z)]$。\n- 所有数值均为无量纲；不需要物理单位。\n- 该单行必须与 Python 的数字列表的列表的精确格式相匹配，例如\n  $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$。\n\n测试组需要覆盖的边界情况：\n- $z = 0$ 测试了当今时刻的边界，并验证了在不重新归一化的情况下，由于不同的背景历史，不同的宇宙学模型会产生不同的 $D(0)$。\n- $z = 10$ 探测了早期宇宙，此时物质主导更为显著，各宇宙学模型之间的差异减小但仍可量化。\n- $z = 1$ 和 $z = 3$ 测试了中间阶段，此时曲率和宇宙学常数开始显著改变增长。\n\n您的最终答案必须是完整的、可运行的程序，该程序执行上述计算并以所描述的精确格式打印所需的单行输出。",
            "solution": "用户希望计算三种不同 Friedmann-Robertson-Walker (FRW) 宇宙学模型中的线性增长因子 $D(z)$，并分析其对物质功率谱 $P(k)$ 振幅的影响。这需要从基本原理推导 $D(z)$ 的控制微分方程，然后进行数值求解。\n\n### 1. 理论基础\n\n#### Friedmann 方程\n均匀各向同性宇宙的膨胀动力学由 Friedmann 方程描述。对于一个包含非相对论性物质（尘埃）、宇宙学常数 ($\\Lambda$) 和空间曲率的宇宙，哈勃参数 $H(a) = \\dot{a}/a$（其中 $a$ 是尺度因子，点表示对宇宙时 $t$ 的导数）的方程为：\n$$\nH^2(a) = \\frac{8\\pi G}{3}\\left(\\rho_m(a) + \\rho_\\Lambda\\right) - \\frac{k c^2}{a^2}\n$$\n在此，$G$ 是引力常数，$\\rho_m(a)$ 是物质密度，$\\rho_\\Lambda$ 是与宇宙学常数相关的恒定能量密度，$k$ 是曲率指数（$-1$, $0$, $1$ 分别对应开放、平坦、闭合几何），$c$ 是光速。\n\n标准做法是用无量纲密度参数来表示该方程，这些参数定义为能量密度与当今时刻（$a=1$）的临界密度 $\\rho_{c,0} = 3H_0^2/(8\\pi G)$ 之比，其中 $H_0$ 是哈勃常数。\n密度参数为：\n- 物质：$\\Omega_{m,0} = \\rho_{m,0}/\\rho_{c,0}$\n- 宇宙学常数：$\\Omega_{\\Lambda,0} = \\rho_\\Lambda/\\rho_{c,0}$\n- 曲率：$\\Omega_{k,0} = -kc^2/(H_0^2 a_0^2)$，其中我们设定 $a_0 = 1$。\n\n已知 $\\rho_m(a) = \\rho_{m,0} a^{-3}$，Friedmann 方程可以改写为：\n$$\nH^2(a) = H_0^2 \\left[ \\Omega_{m,0} a^{-3} + \\Omega_{k,0} a^{-2} + \\Omega_{\\Lambda,0} \\right]\n$$\n其中参数满足求和规则 $\\Omega_{m,0} + \\Omega_{\\Lambda,0} + \\Omega_{k,0} = 1$。我们定义无量纲哈勃参数 $E(a) = H(a)/H_0$，因此 $E(a)^2 = \\Omega_{m,0} a^{-3} + \\Omega_{k,0} a^{-2} + \\Omega_{\\Lambda,0}$。\n\n#### 线性增长方程\n在膨胀宇宙中，微小的物质密度扰动 $\\delta(\\mathbf{x}, t) = (\\rho_m(\\mathbf{x}, t) - \\bar{\\rho}_m(t))/\\bar{\\rho}_m(t)$ 的演化由线性化的流体方程控制。对于亚视界尺度上的无压流体（尘埃），这些方程合并后可得到一个关于密度衬度 $\\delta$ 的二阶线性常微分方程：\n$$\n\\ddot{\\delta} + 2H\\dot{\\delta} - 4\\pi G \\bar{\\rho}_m \\delta = 0\n$$\n由于此方程是线性的且不依赖于波数 $k$（在牛顿极限下），所有傅里叶模式 $\\delta_k$ 都以相同的速率增长。因此，我们可以分离其含时部分和空间部分，$\\delta(\\mathbf{x}, a) = D(a) \\delta_{\\mathrm{init}}(\\mathbf{x})$，其中 $D(a)$ 是线性增长因子。该增长因子遵循相同的常微分方程：\n$$\n\\ddot{D} + 2H\\dot{D} - 4\\pi G \\bar{\\rho}_m D = 0\n$$\n使用 $\\bar{\\rho}_m(a) = \\bar{\\rho}_{m,0} a^{-3} = \\Omega_{m,0} \\rho_{c,0} a^{-3} = \\Omega_{m,0} \\frac{3H_0^2}{8\\pi G} a^{-3}$，我们可以将该方程改写为：\n$$\n\\ddot{D} + 2H\\dot{D} - \\frac{3}{2} H_0^2 \\Omega_{m,0} a^{-3} D = 0\n$$\n\n### 2. 用于数值积分的方程\n为了对该常微分方程进行数值求解，将自变量从宇宙时 $t$ 变换为尺度因子的自然对数 $x = \\ln a$ 会很方便。导数的变换关系如下：\n$$\n\\frac{d}{dt} = \\frac{da}{dt} \\frac{d}{da} = \\dot{a} \\frac{d}{da} = aH \\frac{d}{da} = H \\frac{d}{d(\\ln a)} = H \\frac{d}{dx}\n$$\n因此，$\\dot{D} = H D'$ 且 $\\ddot{D} = \\dot{H}D' + H(HD')' = \\dot{H}D' + H^2D''$，其中撇号表示对 $x$ 的导数。可以证明 $\\dot{H} = H H'$。将这些代入增长方程得到：\n$$\n(H H' D' + H^2 D'') + 2H(H D') - \\frac{3}{2} H_0^2 \\Omega_{m,0} a^{-3} D = 0\n$$\n两边同除以 $H^2$：\n$$\nD'' + \\left(2 + \\frac{H'}{H}\\right)D' - \\frac{3}{2} \\frac{H_0^2 \\Omega_{m,0} a^{-3}}{H^2} D = 0\n$$\n其系数可以用含时的密度参数 $\\Omega_m(a) = \\frac{\\Omega_{m,0} a^{-3}}{E(a)^2}$、$\\Omega_k(a) = \\frac{\\Omega_{k,0} a^{-2}}{E(a)^2}$ 和 $\\Omega_\\Lambda(a) = \\frac{\\Omega_{\\Lambda,0}}{E(a)^2}$ 来表示。方程简化为：\n$$\n\\frac{d^2D}{dx^2} + \\left(1 - \\frac{1}{2}\\Omega_m(a) + \\Omega_\\Lambda(a)\\right)\\frac{dD}{dx} - \\frac{3}{2}\\Omega_m(a) D = 0\n$$\n其中 $a = e^x$。这是一个关于 $D(x)$ 的二阶线性齐次常微分方程，可以作为初值问题求解。\n\n### 3. 数值实现\n\n为了求解该常微分方程，我们将其转换为一个一阶方程组。设状态向量为 $\\mathbf{y} = [y_1, y_2]^T$，其中 $y_1 = D$，$y_2 = dD/dx$。该方程组为：\n$$\n\\frac{d\\mathbf{y}}{dx} = \n\\begin{pmatrix}\n\\frac{dy_1}{dx} \\\\\n\\frac{dy_2}{dx}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\n-\\left(1 - \\frac{1}{2}\\Omega_m(a) + \\Omega_\\Lambda(a)\\right)y_2 + \\frac{3}{2}\\Omega_m(a) y_1\n\\end{pmatrix}\n$$\n初始条件设定在早期的物质主导宇宙。在 $a_{\\mathrm{init}} = 10^{-4}$ 时，所有三个指定的宇宙学模型都实际上是物质主导的（$\\Omega_m(a_{\\mathrm{init}}) \\approx 1$）。在物质主导的宇宙中，增长模式解为 $D(a) \\propto a$。这意味着 $D(x) \\propto e^x$，因此 $dD/dx = D$。所以初始条件设定为 $D(a_{\\mathrm{init}}) = a_{\\mathrm{init}}$ 和 $(dD/d\\ln a)|_{a_{\\mathrm{init}}} = a_{\\mathrm{init}}$。这对应于在 $x_{\\mathrm{init}} = \\ln(a_{\\mathrm{init}})$ 时的初始状态向量 $\\mathbf{y}(x_{\\mathrm{init}}) = [a_{\\mathrm{init}}, a_{\\mathrm{init}}]$。\n\n步骤如下：\n1. 对于三种宇宙学模型（开放、平坦、闭合）中的每一种，定义参数 $\\Omega_{m,0}$ 和 $\\Omega_{\\Lambda,0}$，并计算 $\\Omega_{k,0} = 1 - \\Omega_{m,0} - \\Omega_{\\Lambda,0}$。\n2. 建立如上定义的一阶常微分方程组。\n3. 使用数值常微分方程求解器（例如 `scipy.integrate.solve_ivp` 中的 Runge-Kutta 方法）将方程组从 $x_{\\mathrm{init}} = \\ln(10^{-4})$ 积分到 $x=0$（当今时刻，$a=1$）。\n4. 求解器在对应于测试红移 $z \\in \\{0, 1, 3, 10\\}$ 的尺度因子 $a = 1/(1+z)$ 处计算解 $D(a)$。\n5. 计算出增长因子 $D_{\\mathrm{open}}(z)$、$D_{\\mathrm{flat}}(z)$ 和 $D_{\\mathrm{closed}}(z)$ 后，计算功率谱振幅因子 $A(z) = D(z)^2$。\n6. 最后，为每个红移计算比率 $A_{\\mathrm{open}}(z)/A_{\\mathrm{flat}}(z)$ 和 $A_{\\mathrm{closed}}(z)/A_{\\mathrm{flat}}(z)$，以量化增长历史的差异。然后按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes and compares the linear growth factor D(z) for three different cosmologies.\n    \"\"\"\n    # Define test cases: (name, Omega_m0, Omega_L0)\n    test_cases = [\n        (\"open\", 0.3, 0.0),\n        (\"flat\", 0.3, 0.7),\n        (\"closed\", 0.3, 0.8),\n    ]\n\n    # Redshifts for evaluation\n    test_redshifts = np.array([0.0, 1.0, 3.0, 10.0])\n\n    # Store results D(z) for each model {model_name: array_of_D_values}\n    growth_factors = {}\n\n    # Initial conditions\n    a_init = 1e-4\n    x_init = np.log(a_init)  # ln(a) as the independent variable\n    # Initial state vector [D, dD/dln(a)]\n    y_init = np.array([a_init, a_init])\n\n    # The evaluation points for the ODE solver must be sorted.\n    # We sort redshifts in descending order, so 'a' and 'x=ln(a)' are ascending.\n    z_sorted_indices = np.argsort(test_redshifts)[::-1]\n    z_sorted = test_redshifts[z_sorted_indices]\n    \n    a_eval_sorted = 1.0 / (1.0 + z_sorted)\n    x_eval_sorted = np.log(a_eval_sorted)\n\n    # Integration span from initial time to today (a=1, x=0)\n    x_span = [x_init, 0.0]\n\n    for name, omega_m0, omega_l0 in test_cases:\n        omega_k0 = 1.0 - omega_m0 - omega_l0\n\n        def growth_ode(x, y):\n            \"\"\"\n            Defines the system of ODEs for the growth factor D.\n            State vector y = [D, dD/d(ln a)], independent variable x = ln(a).\n            \"\"\"\n            a = np.exp(x)\n            \n            # Dimensionless Hubble parameter squared, E(a)^2 = H(a)^2 / H0^2\n            e2 = omega_m0 * a**-3 + omega_k0 * a**-2 + omega_l0\n            if e2 == 0:\n                # Should not be reached for the specified models\n                return np.zeros_like(y)\n            \n            # Density parameters as a function of scale factor 'a'\n            omega_m_a = (omega_m0 * a**-3) / e2\n            omega_l_a = omega_l0 / e2\n            \n            dydx = np.zeros_like(y)\n            dydx[0] = y[1]  # d(D)/dx = dD/dx\n            # d(dD/dx)/dx = -(1-0.5*Om_a+Ol_a)*(dD/dx) + 1.5*Om_a*D\n            dydx[1] = -(1.0 - 0.5 * omega_m_a + omega_l_a) * y[1] + 1.5 * omega_m_a * y[0]\n            \n            return dydx\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            growth_ode,\n            x_span,\n            y_init,\n            t_eval=x_eval_sorted,\n            method='RK45',\n            rtol=1e-9,\n            atol=1e-12\n        )\n\n        # The solution sol.y[0] corresponds to the sorted redshifts 'z_sorted'.\n        # We reorder it to match the original 'test_redshifts' order.\n        d_values_sorted = sol.y[0]\n        d_values = np.empty_like(d_values_sorted)\n        d_values[z_sorted_indices] = d_values_sorted\n        \n        growth_factors[name] = d_values\n\n    # Assemble the final results into the required format\n    output_rows = []\n    for i, z in enumerate(test_redshifts):\n        D_open = growth_factors[\"open\"][i]\n        D_flat = growth_factors[\"flat\"][i]\n        D_closed = growth_factors[\"closed\"][i]\n\n        A_open = D_open**2\n        A_flat = D_flat**2\n        A_closed = D_closed**2\n\n        if A_flat == 0:\n            ratio_open_flat = np.nan\n            ratio_closed_flat = np.nan\n        else:\n            ratio_open_flat = A_open / A_flat\n            ratio_closed_flat = A_closed / A_flat\n            \n        result_row = [\n            z,\n            D_open, D_flat, D_closed,\n            A_open, A_flat, A_closed,\n            ratio_open_flat, ratio_closed_flat\n        ]\n        output_rows.append(result_row)\n\n    # Final print statement must produce a single line in the specified format.\n    # The format f\"[{','.join(map(str, list_of_lists))}]\" correctly\n    # reproduces the string representation of a Python list of lists.\n    print(f\"[{','.join(map(str, output_rows))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然增长因子描述了结构的相对演化，但功率谱的绝对归一化必须通过将理论与观测进行比较来设定。一个关键的观测锚点是 $\\sigma_8$，即在 $8\\,h^{-1}\\,\\mathrm{Mpc}$ 尺度上物质涨落的均方根。本练习涉及宇宙学中一个常见且至关重要的任务：构建一个数值工具，将原初谱的理论幅度参数 $A_s$ 与可观测的 $\\sigma_8$ 联系起来，从而根据真实数据校准您的模型 。",
            "id": "3497194",
            "problem": "您需要编写一个完整、可运行的程序，该程序通过将枢轴波数下的振幅参数与指定半径球面内的均方根质量涨落联系起来，来校准线性物质功率谱的归一化。任务是实现一个物理上一致且数值上稳健的算法，对于固定的宇宙学背景和固定的功率谱形状，推断出能产生目标质量涨落的振幅参数，同时保持功率谱的形状不变。\n\n请使用以下基本依据和定义。线性物质功率谱被建模为形状函数和标量归一化的可分离乘积。设 $P(k;A_s)$ 表示作为共动波数 $k$ 和振幅参数 $A_s$ 的函数的物质功率谱。定义形状函数为\n$$\nS(k) \\equiv \\left(\\frac{k}{k_0}\\right)^{n_s} \\, T^2(k),\n$$\n因此\n$$\nP(k;A_s) = A_s \\, S(k).\n$$\n这里，$k$ 的单位是 $h\\,\\mathrm{Mpc}^{-1}$，$A_s$ 的单位是 $\\left(\\mathrm{Mpc}/h\\right)^3$，$k_0$ 是一个指定的枢轴（单位也是 $h\\,\\mathrm{Mpc}^{-1}$）。传递函数 $T(k)$ 采用 Bardeen–Bond–Kaiser–Szalay (BBKS) 拟合形式的冷暗物质传递函数，并带有 Sugiyama 形状参数修正，\n$$\n\\Gamma_{\\mathrm{eff}} = \\Omega_m \\, h \\, \\exp\\!\\left[-\\Omega_b\\left(1+\\frac{\\sqrt{2h}}{\\Omega_m}\\right)\\right],\n\\qquad\nq = \\frac{k}{\\Gamma_{\\mathrm{eff}}},\n$$\n$$\nT(k) = \\frac{\\ln(1+2.34 q)}{2.34 q} \\left[1 + 3.89 q + (16.1 q)^2 + (5.46 q)^3 + (6.71 q)^4 \\right]^{-1/4}.\n$$\n所有三角函数必须使用弧度制角度。\n\n在傅里叶空间中定义顶帽窗函数为\n$$\nW(x) = \\frac{3}{x^3}\\left[\\sin x - x \\cos x\\right],\n\\qquad x \\equiv k R,\n$$\n其中 $R$ 的单位是 $h^{-1}\\,\\mathrm{Mpc}$。尺度 $R$ 上的方差为\n$$\n\\sigma_R^2(A_s) = \\frac{1}{2\\pi^2}\\int_{0}^{\\infty} k^2 \\, P(k;A_s)\\, W^2(kR)\\, \\mathrm{d}k.\n$$\n设置 $R$ 为 $R_8 \\equiv 8\\,h^{-1}\\,\\mathrm{Mpc}$，并定义 $\\sigma_8(A_s) \\equiv \\sigma_{R_8}(A_s)$。在固定的形状 $S(k)$ 下，$P(k;A_s)$ 与 $A_s$ 呈线性关系，因此 $\\sigma_8^2(A_s)$ 与 $A_s$ 成正比。\n\n您的程序必须执行以下操作。\n\n- 实现一个数值稳定的 $W(x)$ 求值方法，通过使用小 $x$ 级数展开 $W(x) = 1 - x^2/10 + \\mathcal{O}(x^4)$ 来处理 $x \\to 0$ 的极限，以避免灾难性抵消。\n- 通过在 $k_{\\min} = 10^{-4}\\,h\\,\\mathrm{Mpc}^{-1}$到 $k_{\\max} = 10^{2}\\,h\\,\\mathrm{Mpc}^{-1}$ 的对数间隔网格上对定义积分进行数值积分来计算 $\\sigma_8(A_s)$。数值结果必须在网格细化方面稳定到至少四位有效数字。\n- 设计并实现一个迭代乘法重标度算法，该算法根据给定的目标 $\\sigma_8^{\\mathrm{(tar)}}$ 推断 $A_s$。从初始猜测值 $A_s^{(0)}$ 开始，生成迭代\n$$\nA_s^{(i+1)} = A_s^{(i)} \\left[\\frac{\\sigma_8^{\\mathrm{(tar)}}}{\\sigma_8\\!\\left(A_s^{(i)}\\right)}\\right]^2,\n$$\n当 $A_s$ 的相对更新满足\n$$\n\\left|\\frac{A_s^{(i+1)} - A_s^{(i)}}{A_s^{(i)}}\\right|  \\varepsilon,\n$$\n（其中 $\\varepsilon$ 为指定的容差）或达到最大迭代次数时终止。此更新保持形状 $S(k)$ 不变，仅重标度归一化。返回收敛的 $A_s$ 值。\n- 验证对于给定的 $A_s$，程序能够计算出相应的 $\\sigma_8(A_s)$。\n\n对所有测试用例采用以下固定的宇宙学和模型参数：$\\Omega_m = 0.3$，$\\Omega_b = 0.05$，$h = 0.7$，$n_s = 0.965$，$k_0 = 0.05\\,h\\,\\mathrm{Mpc}^{-1}$，$R_8 = 8\\,h^{-1}\\,\\mathrm{Mpc}$。使用数值容差 $\\varepsilon = 10^{-10}$ 和最大迭代次数 $N_{\\mathrm{it}} = 50$。使用一个在 $k_{\\min}$ 和 $k_{\\max}$ 之间有 $N_k = 5000$ 个对数间隔点的网格。\n\n实现以下测试套件。每个测试用例是一个元组；第一个元素是字符串模式，其余元素指定参数。您的程序必须按顺序执行它们并汇总标量结果。\n\n- 测试用例 1：从 $\\sigma_8^{\\mathrm{(tar)}} = 0.8$ 推断 $A_s$，初始猜测值为 $A_s^{(0)} = 2.0\\times 10^{-9}$。\n- 测试用例 2：从 $\\sigma_8^{\\mathrm{(tar)}} = 0.83$ 推断 $A_s$，初始猜测值为 $A_s^{(0)} = 2.0\\times 10^{-9}$。\n- 测试用例 3：从 $\\sigma_8^{\\mathrm{(tar)}} = 0.3$ 推断 $A_s$，初始猜测值为 $A_s^{(0)} = 2.0\\times 10^{-9}$。\n- 测试用例 4：从 $\\sigma_8^{\\mathrm{(tar)}} = 1.2$ 推断 $A_s$，初始猜测值为 $A_s^{(0)} = 1.0\\times 10^{-10}$。\n- 测试用例 5：计算 $A_s = 2.1\\times 10^{-9}$ 时的 $\\sigma_8$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试用例相同。对于逆问题（测试用例 1 到 4），输出推斷出的 $A_s$，单位为 $\\left(\\mathrm{Mpc}/h\\right)^3$，以浮点数形式表示。对于正向问题（测试用例 5），输出 $\\sigma_8$ 作为浮点数。例如，输出必须类似于\n$[x_1,x_2,x_3,x_4,x_5]$\n没有空格，其中每个 $x_i$ 是相应的标量结果。",
            "solution": "该问题已经过验证，被认为是合理的。这是一个在数值宇宙学中定义明确、科学上成立且自成体系的问题。所有必要的物理模型、参数和数值规范都已提供，没有歧义或矛盾。因此，我们可以着手解决。\n\n问题的核心是建立线性物质功率谱 $P(k)$ 的两个关键参数之间的稳健数值映射：枢轴尺度 $k_0$ 处的归一化振幅 $A_s$，以及半径为 $R_8 = 8 \\,h^{-1}\\,\\mathrm{Mpc}$ 的球面内的均方根（RMS）质量涨落 $\\sigma_8$。我们将首先详细说明物理模型，然后描述一个数值策略，以实现正向问题（从 $A_s$ 计算 $\\sigma_8$）和逆向问题（从目标 $\\sigma_8^{\\mathrm{(tar)}}$ 推断 $A_s$）。\n\n线性物质功率谱定义为：\n$$\nP(k; A_s) = A_s S(k) = A_s \\left(\\frac{k}{k_0}\\right)^{n_s} T^2(k)\n$$\n其中 $A_s$ 是振幅，单位为 $(\\mathrm{Mpc}/h)^3$，$k$ 是共动波数，单位为 $h\\,\\mathrm{Mpc}^{-1}$，$k_0 = 0.05\\,h\\,\\mathrm{Mpc}^{-1}$ 是枢轴尺度，$n_s = 0.965$ 是标量谱指数。函数 $T(k)$ 是物质传递函数。问题指定了 Bardeen–Bond–Kaiser–Szalay (BBKS) 形式，并对形状参数 $\\Gamma_{\\mathrm{eff}}$ 进行了 Sugiyama 修正：\n$$\n\\Gamma_{\\mathrm{eff}} = \\Omega_m h \\exp\\!\\left[-\\Omega_b\\left(1+\\frac{\\sqrt{2h}}{\\Omega_m}\\right)\\right]\n$$\n使用宇宙学参数 $\\Omega_m = 0.3$, $\\Omega_b = 0.05$ 和 $h = 0.7$，我们可以预先计算 $\\Gamma_{\\mathrm{eff}}$。设 $q = k/\\Gamma_{\\mathrm{eff}}$。传递函数则为：\n$$\nT(k) = \\frac{\\ln(1+2.34 q)}{2.34 q} \\left[1 + 3.89 q + (16.1 q)^2 + (5.46 q)^3 + (6.71 q)^4 \\right]^{-1/4}\n$$\n\n半径为 $R$ 的球面内质量涨落的方差由以下积分给出：\n$$\n\\sigma_R^2(A_s) = \\frac{1}{2\\pi^2}\\int_{0}^{\\infty} k^2 \\, P(k;A_s)\\, W^2(kR)\\, \\mathrm{d}k\n$$\n其中 $W(x)$是球形顶帽窗函数的傅里叶变换：\n$$\nW(x) = \\frac{3}{x^3}\\left[\\sin x - x \\cos x\\right]\n$$\n对于这个问题，我们关心的是 $\\sigma_8$，它对应于 $R = R_8 = 8 \\,h^{-1}\\,\\mathrm{Mpc}$。\n\n数值实现分为几个阶段。\n\n1.  **参数预计算与网格生成**：\n    形状参数 $\\Gamma_{\\mathrm{eff}}$ 仅依赖于固定的宇宙学参数，因此只需计算一次。用于数值积分的波数网格是一组从 $k_{\\min} = 10^{-4}\\,h\\,\\mathrm{Mpc}^{-1}$ 到 $k_{\\max} = 10^{2}\\,h\\,\\mathrm{Mpc}^{-1}$ 对数均匀分布的 $N_k = 5000$ 个点。由于功率谱形状 $S(k)$ 与振幅 $A_s$ 无关，我们可以为了效率，在该网格上预先计算 $T(k)$ 的值，并随后计算 $S(k)$。\n\n2.  **数值稳定的函数求值**：\n    对小 $x$ (即 $x \\to 0$) 直接求值 $W(x)$ 会受到灾难性抵消的影响，因为 $\\sin x \\approx x - x^3/6$ 且 $x\\cos x \\approx x(1-x^2/2) = x - x^3/2$。为确保稳定性，我们对小宗量使用泰勒级数展开：\n    $$\n    W(x) = 1 - \\frac{x^2}{10} + \\frac{x^4}{280} - \\dots\n    $$\n    选择一个阈值，例如 $x  10^{-4}$。低于此阈值时，使用展开式 $W(x) \\approx 1 - x^2/10$；否则，计算完整表达式。类似地，$T(k)$中的项 $\\frac{\\ln(1+2.34 q)}{2.34 q}$ 在 $q \\to 0$ 时趋近于 $1$。数值库通常提供像 `log1p(z)` 这样的函数来精确计算小 $z$ 的 $\\ln(1+z)$，从而避免精度损失。\n\n3.  **正向问题：从 $A_s$ 计算 $\\sigma_8$**：\n    给定一个振幅 $A_s$，完整的功率谱为 $P(k;A_s) = A_s S(k)$。然后通过对其定义表达式进行数值积分来计算方差 $\\sigma_8^2$。该积分可表示为：\n    $$\n    \\sigma_8^2(A_s) = A_s \\left[ \\frac{1}{2\\pi^2}\\int_{k_{\\min}}^{k_{\\max}} k^2 S(k) W^2(kR_8) \\mathrm{d}k \\right]\n    $$\n    对于固定的宇宙学和功率谱形状，方括号中的项是一个常数。被积函数 $I(k) = k^2 S(k) W^2(kR_8)$ 在 $k$-网格的每个点上进行求值。然后使用梯形法则计算积分，该方法适用于非均匀间隔的点，如 `scipy.integrate.trapezoid` 所提供的功能。最后，$\\sigma_8 = \\sqrt{\\sigma_8^2}$。\n\n4.  **逆向问题：从 $\\sigma_8^{\\mathrm{(tar)}}$ 推断 $A_s$**：\n    目标是找到产生指定目标值 $\\sigma_8^{\\mathrm{(tar)}}$ 的 $A_s$ 值。问题提供了一个迭代乘法重标度算法：\n    $$\n    A_s^{(i+1)} = A_s^{(i)} \\left[\\frac{\\sigma_8^{\\mathrm{(tar)}}}{\\sigma_8\\!\\left(A_s^{(i)}\\right)}\\right]^2\n    $$\n    这个算法非常高效。由于 $\\sigma_8^2(A_s)$ 与 $A_s$ 成正比，我们有 $\\sigma_8(A_s) = C \\sqrt{A_s}$，其中 $C$ 是由形状 $S(k)$ 和积分决定的常数。将此代入更新规则：\n    $$\n    A_s^{(i+1)} = A_s^{(i)} \\left[\\frac{\\sigma_8^{\\mathrm{(tar)}}}{C\\sqrt{A_s^{(i)}}}\\right]^2 = A_s^{(i)} \\frac{(\\sigma_8^{\\mathrm{(tar)}})^2}{C^2 A_s^{(i)}} = \\frac{(\\sigma_8^{\\mathrm{(tar)}})^2}{C^2}\n    $$\n    这个结果与迭代次数 $i$ 无关，这意味着该算法在一步之内就能收敛到精确的解析解，只受限于数值精度。尽管如此，实现仍遵循指定的迭代结构，从初始猜测值 $A_s^{(0)}$ 开始，迭代直到 $A_s$ 的相对变化低于容差 $\\varepsilon = 10^{-10}$ 或达到最大迭代次数 $N_{\\mathrm{it}} = 50$。\n\n整个程序被构建为处理指定的测试用例。一个主求解器函数封装了正向和逆向问题的逻辑。对每个测试用例调用此函数，并将结果汇总到一个列表中，以便按指定格式进行最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of calibrating the linear matter power spectrum normalization.\n    \"\"\"\n\n    # --- Fixed Cosmological and Model Parameters ---\n    # These are constant for all test cases as per the problem statement.\n    COSMO_PARAMS = {\n        'Omega_m': 0.3,\n        'Omega_b': 0.05,\n        'h': 0.7,\n        'n_s': 0.965,\n        'k0': 0.05,  # in h/Mpc\n        'R8': 8.0,   # in Mpc/h\n    }\n\n    # --- Numerical Integration and Iteration Parameters ---\n    NUM_PARAMS = {\n        'k_min': 1e-4, # in h/Mpc\n        'k_max': 1e2,  # in h/Mpc\n        'N_k': 5000,\n        'tol': 1e-10,\n        'max_iter': 50,\n    }\n\n    def w_tophat(x):\n        \"\"\"\n        Computes the spherical top-hat window function W(x) in Fourier space.\n        Uses a small-x Taylor expansion to avoid numerical instability.\n        x = k*R\n        \"\"\"\n        # Threshold for switching to Taylor expansion\n        small_x_thold = 1e-4\n        \n        # Condition to use Taylor expansion for small x\n        use_expansion = np.abs(x)  small_x_thold\n        \n        # Initialize result array\n        w = np.zeros_like(x, dtype=float)\n\n        # Full expression for large x\n        # Use np.logical_not to avoid re-evaluating the condition\n        # This handles both scalar and array inputs correctly\n        non_expansion_indices = np.logical_not(use_expansion)\n        x_safe = x[non_expansion_indices]\n        w[non_expansion_indices] = 3.0 * (np.sin(x_safe) - x_safe * np.cos(x_safe)) / (x_safe**3)\n\n        # Small-x expansion: W(x) = 1 - x^2/10 + O(x^4)\n        x_small = x[use_expansion]\n        w[use_expansion] = 1.0 - x_small**2 / 10.0\n        \n        return w\n\n    def bbks_transfer_function(k, gamma_eff):\n        \"\"\"\n        Computes the BBKS transfer function T(k) with Sugiyama correction.\n        k is an array of wavenumbers in h/Mpc.\n        gamma_eff is the shape parameter.\n        \"\"\"\n        q = k / gamma_eff\n        \n        # Use log1p for numerical stability when q is small\n        log_term = np.log1p(2.34 * q) / (2.34 * q)\n        # Handle the q=0 case explicitly, where log_term -> 1\n        log_term[q == 0] = 1.0\n\n        poly_term = (1.0 + 3.89 * q + (16.1 * q)**2 + (5.46 * q)**3 + (6.71 * q)**4)**(-0.25)\n        \n        return log_term * poly_term\n\n    class PowerSpectrumCalculator:\n        \"\"\"\n        A class to pre-compute shape-dependent quantities and calculate sigma8.\n        \"\"\"\n        def __init__(self, cosmo_params, num_params):\n            self.p = cosmo_params\n            self.n = num_params\n            \n            # Pre-compute fixed quantities\n            self._precompute()\n\n        def _precompute(self):\n            \"\"\"Pre-computes k-grid and power spectrum shape.\"\"\"\n            # Effective shape parameter Gamma_eff\n            self.gamma_eff = self.p['Omega_m'] * self.p['h'] * np.exp(\n                -self.p['Omega_b'] * (1 + np.sqrt(2 * self.p['h']) / self.p['Omega_m'])\n            )\n            \n            # Logarithmically spaced wavenumber grid\n            self.k = np.logspace(np.log10(self.n['k_min']), np.log10(self.n['k_max']), self.n['N_k'])\n            \n            # Transfer function T(k)\n            transfer_vals = bbks_transfer_function(self.k, self.gamma_eff)\n            \n            # Power spectrum shape function S(k)\n            self.pk_shape = (self.k / self.p['k0'])**self.p['n_s'] * transfer_vals**2\n\n        def compute_sigma8(self, As):\n            \"\"\"\n            Computes sigma_8 for a given amplitude A_s.\n            \"\"\"\n            # Full power spectrum P(k) = A_s * S(k)\n            pk_full = As * self.pk_shape\n            \n            # Window function values W(k*R8)\n            x = self.k * self.p['R8']\n            window_sq = w_tophat(x)**2\n            \n            # Integrand for sigma_8^2\n            integrand = self.k**2 * pk_full * window_sq / (2 * np.pi**2)\n            \n            # Numerical integration using trapezoidal rule for non-uniform grid\n            sigma8_sq = integrate.trapezoid(integrand, self.k)\n            \n            return np.sqrt(sigma8_sq)\n\n        def infer_As(self, sigma8_target, As_initial):\n            \"\"\"\n            Infers A_s to match a target sigma_8 using an iterative algorithm.\n            \"\"\"\n            As_current = As_initial\n            \n            for _ in range(self.n['max_iter']):\n                sigma8_current = self.compute_sigma8(As_current)\n                \n                # Multiplicative rescaling update rule\n                As_next = As_current * (sigma8_target / sigma8_current)**2\n                \n                # Check for convergence\n                if np.abs((As_next - As_current) / As_current)  self.n['tol']:\n                    return As_next\n                \n                As_current = As_next\n            \n            return As_current # Return the last value if max_iter is reached\n\n    # --- Test Case Execution ---\n    test_cases = [\n        ('infer', {'sigma8_target': 0.8, 'As_initial': 2.0e-9}),\n        ('infer', {'sigma8_target': 0.83, 'As_initial': 2.0e-9}),\n        ('infer', {'sigma8_target': 0.3, 'As_initial': 2.0e-9}),\n        ('infer', {'sigma8_target': 1.2, 'As_initial': 1.0e-10}),\n        ('compute', {'As': 2.1e-9}),\n    ]\n\n    calculator = PowerSpectrumCalculator(COSMO_PARAMS, NUM_PARAMS)\n    results = []\n\n    for mode, params in test_cases:\n        if mode == 'infer':\n            result = calculator.infer_As(**params)\n        elif mode == 'compute':\n            result = calculator.compute_sigma8(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "编写计算宇宙学量的代码只是工作的一半，确保代码的正确性至关重要。这最后一个练习侧重于一项关键的科学技能：代码验证。您将使用简化的、解析可控的玩具模型构建一个基准测试套件，以验证一个计算管线能否正确测量功率谱的关键特征，例如其基本幂律斜率、特征振荡尺度（BAO）及其在最大尺度上的行为 。",
            "id": "3497142",
            "problem": "您的任务是设计并实现一个小型、独立的基准测试套件，用以验证一个在数值宇宙学中新实现的线性物质功率谱计算流程。验证必须仅依赖于解析可控的极限情况和玩具模型，这些模型能捕捉线性机制中经过充分检验的特征。您的套件将测试三个不同方面：纯幂律谱、具有已知波数周期的重子声学振荡 (BAO) 调制，以及超视界标度极限。\n\n请使用以下在该领域中标准的物理和数学基础：\n\n- 线性物质功率谱通过傅里叶空间中密度对比的二点统计量定义，$$\\langle \\delta(\\mathbf{k}) \\,\\delta^*(\\mathbf{k}^{\\prime}) \\rangle = (2\\pi)^3 \\,\\delta_{\\mathrm{D}}(\\mathbf{k}-\\mathbf{k}^{\\prime})\\,P(k)\\,,$$ 其中 $\\delta_{\\mathrm{D}}$ 是狄拉克δ分布，$k \\equiv \\lVert \\mathbf{k} \\rVert$ 是共动波数。\n- 在红移 $z=0$ 的线性机制中，一个广泛使用的表示是 $$P(k) = A\\,k^{n_{\\mathrm{s}}}\\,T^2(k)\\,,$$ 其中 $A$ 是一个正振幅，$n_{\\mathrm{s}}$ 是谱指数，$T(k)$ 是转移函数。\n- 为生成可控的基准，请使用一个由光滑的“无摆动”部分和BAO调制组成的玩具转移函数：\n  - 光滑转折（无摆动）分量：$$T_{\\mathrm{nw}}(k;k_{\\mathrm{eq}},\\alpha) = \\left[1+\\left(\\frac{k}{k_{\\mathrm{eq}}}\\right)^2\\right]^{-\\alpha/2}\\,,$$ 该函数满足当 $k\\to 0$ 时 $T_{\\mathrm{nw}}(k)\\to 1$，并在 $k\\gg k_{\\mathrm{eq}}$ 时衰减。\n  - BAO调制分量（重子声学振荡 (BAO)）：$$M_{\\mathrm{bao}}(k;B,k_{\\mathrm{bao}},k_{\\mathrm{d}})=1 + B\\,\\sin\\!\\left(2\\pi\\,\\frac{k}{k_{\\mathrm{bao}}}\\right)\\,\\exp\\!\\left[-\\left(\\frac{k}{k_{\\mathrm{d}}}\\right)^2\\right]\\,,$$ 其中 $k_{\\mathrm{bao}}$ 是待验证的基本波数周期，$B$ 是一个小的无量纲振幅，$k_{\\mathrm{d}}$ 提供一个高斯阻尼包络。\n  - 将它们组合为 $$T(k) = T_{\\mathrm{nw}}(k;k_{\\mathrm{eq}},\\alpha)\\,M_{\\mathrm{bao}}(k;B,k_{\\mathrm{bao}},k_{\\mathrm{d}})\\,,$$ 于是 $P(k)=A\\,k^{n_{\\mathrm{s}}}\\,T^2(k)$。\n\n您的程序必须实现估计量来验证：\n- 使用 $\\ln P$ 对 $\\ln k$ 的线性回归来验证幂律斜率。\n- 通过定位 $P(k)$ 中的连续局域极大值来验证BAO周期，利用二次插值精化峰值位置，并计算连续峰间距的中位数作为周期的稳健估计。\n- 验证超视界标度 $k\\to 0$（此时 $T_{\\mathrm{nw}}(k)\\to 1$），通过在一个足够小的 $k$ 的定义域上测量 $P(k)/(A\\,k^{n_{\\mathrm{s}}})$ 与 $1$ 的最大分数偏差。\n\n单位：\n- 在整个过程中，始终将 $k$ 的单位解释为 $h\\,\\mathrm{Mpc}^{-1}$，将 $P(k)$ 的单位解释为 $(\\mathrm{Mpc}/h)^3$。\n- 当结果是波数空间中的长度时（例如，BAO周期或周期误差），请以 $h\\,\\mathrm{Mpc}^{-1}$ 为单位，以浮点数形式报告。\n- 所有角度（相位）都隐含在正弦项中，无需报告。不需要角度单位。\n- 不要报告百分比；任何分数误差必须是纯小数。\n\n请精确地按照规定实现以下四个测试用例。对于BAO估计量的所有使用，定义以下接受规则：如果可计算的连续峰间距少于三个（即找到的独立峰值少于四个），或者估计周期的相对误差超过 $0.3$（以小数表示），则声明BAO周期估计“分辨不足”，并为该BAO检测返回一个失败标志。\n\n- 测试 1（幂律斜率一致性）：\n  - 参数：$A = 10^3$, $n_{\\mathrm{s}} = 1.4$, $k_{\\mathrm{eq}} = +\\infty$, $\\alpha$ 无关, $B=0$, $k_{\\mathrm{bao}}$ 无关, $k_{\\mathrm{d}}$ 无关。\n  - 定义域：$k \\in [10^{-3}, 10^{0}]$，在 $N=600$ 个对数间隔的点上采样。\n  - 任务：对 $(\\ln k, \\ln P)$ 拟合一条直线，并获得斜率 $\\hat{s}$。如果 $\\lvert \\hat{s}-n_{\\mathrm{s}}\\rvert \\le \\tau_{\\mathrm{s}}$（其中 $\\tau_{\\mathrm{s}} = 10^{-3}$），则声明测试通过。输出一个布尔值。\n- 测试 2（在清晰设置中恢复BAO周期）：\n  - 参数：$A = 1$, $n_{\\mathrm{s}} = 0$, $k_{\\mathrm{eq}} = +\\infty$, $\\alpha$ 无关, $B=0.05$, $k_{\\mathrm{bao}} = 0.06$, $k_{\\mathrm{d}} = 0.30$。\n  - 定义域：$k \\in [10^{-2}, 5\\times 10^{-1}]$，在 $N=4000$ 个线性间隔的点上采样。\n  - 任务：如上所述，根据峰间距估计BAO周期 $\\widehat{\\Delta k}$，并以 $h\\,\\mathrm{Mpc}^{-1}$ 为单位，以浮点数形式返回绝对误差 $\\lvert \\widehat{\\Delta k} - k_{\\mathrm{bao}} \\rvert$。如果根据上述规则估计量分辨不足，仍返回一个浮点数，但要确保避免非数值(not-a-number)；只有当您能计算至少一个间距时才使用有限数值替代；否则，返回任何有限的占位符（但您的实现应旨在在此处计算多个间距）。\n- 测试 3（超视界标度）：\n  - 参数：$A = 2\\times 10^4$, $n_{\\mathrm{s}} = 0.965$, $k_{\\mathrm{eq}} = 0.015$, $\\alpha = 2.0$, $B=0$, $k_{\\mathrm{bao}}$ 无关, $k_{\\mathrm{d}}$ 无关。\n  - 定义域：$k \\in [10^{-4},10^{-2}]$，在 $N=600$ 个对数间隔的点上采样。\n  - 任务：计算 $$R(k) \\equiv \\frac{P(k)}{A\\,k^{n_{\\mathrm{s}}}}$$ 并返回在此定义域上的最大偏差 $\\max_{k}\\lvert R(k) - 1\\rvert$，作为一个无量纲浮点数。\n- 测试 4（边界情况：用于BAO检测的 $k$ 范围过短）：\n  - 参数：$A = 1$, $n_{\\mathrm{s}}=0$, $k_{\\mathrm{eq}} = +\\infty$, $\\alpha$ 无关, $B=0.05$, $k_{\\mathrm{bao}} = 0.05$, $k_{\\mathrm{d}} = 0.25$。\n  - 定义域：$k \\in [10^{-2}, 1.1\\times 10^{-1}]$，在 $N=100$ 个线性间隔的点上采样。此区间包含的完整振荡少于三个。\n  - 任务：运行您的BAO估计量，并返回一个布尔值，该值当且仅当估计量根据上述规则声明信号分辨不足时为真。\n\n算法要求与数值细节：\n- 幂律斜率必须通过对 $(\\ln k, \\ln P)$ 进行标准最小二乘法来估计。\n- 必须通过离散导数的符号变化或通过将每个样本与其邻居比较来识别局域极大值。使用三个相邻点进行二次插值，以估计顶点位置，从而改进峰值位置。对于间距为 $\\Delta k$ 的均匀网格，如果 $y_{-1},y_0,y_{+1}$ 是在 $k-\\Delta k, k, k+\\Delta k$ 处的值，则顶点偏移量（以 $\\Delta k$ 为单位）可取为 $$\\delta = \\frac{1}{2}\\,\\frac{y_{-1}-y_{+1}}{y_{-1}-2y_0+y_{+1}}\\,,$$ 精化的峰值位置是 $k+\\delta\\,\\Delta k$。\n- 稳健的BAO周期估计量必须是连续精炼峰位置间距的中位数。\n- 对于超视界测试，确保 $k$ 足够小，并报告在指定定义域上的上确界范数偏差。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序为：[测试1的结果, 测试2的结果, 测试3的结果, 测试4的结果]。第一个和最后一个条目必须是布尔值。第二个条目必须是单位为 $h\\,\\mathrm{Mpc}^{-1}$ 的浮点数。第三个条目必须是无量纲浮点数。例如，打印的行应类似于 $[\\mathrm{True},0.0123,0.0045,\\mathrm{False}]$，但使用您的程序根据上述参数实际计算出的四个值。",
            "solution": "问题陈述是有效的。它在科学上基于现代宇宙学的原理，特别是线性物质功率谱理论。该问题是良定的，对物理模型、所需的数值估计量以及四个测试用例都有清晰且数学上精确的定义。所有参数、定义域和任务都得到了无歧义、无矛盾的规定，并且所需的计算是可行的。该问题构成计算科学中的一个标准且有意义的任务：通过与解析可控的基准进行比较来验证数值计算流程。\n\n解决方案涉及实现三个不同的数值估计量，对应于线性物质功率谱 $P(k)$ 的三个验证原则。功率谱的整体模型由下式给出\n$$P(k) = A\\,k^{n_{\\mathrm{s}}}\\,T^2(k)$$\n其中转移函数 $T(k)$ 是一个由光滑部分和振荡部分组成的玩具模型：\n$$T(k) = T_{\\mathrm{nw}}(k;k_{\\mathrm{eq}},\\alpha)\\,M_{\\mathrm{bao}}(k;B,k_{\\mathrm{bao}},k_{\\mathrm{d}})$$\n其中\n$$T_{\\mathrm{nw}}(k;k_{\\mathrm{eq}},\\alpha) = \\left[1+\\left(\\frac{k}{k_{\\mathrm{eq}}}\\right)^2\\right]^{-\\alpha/2}$$\n$$M_{\\mathrm{bao}}(k;B,k_{\\mathrm{bao}},k_{\\mathrm{d}})=1 + B\\,\\sin\\!\\left(2\\pi\\,\\frac{k}{k_{\\mathrm{bao}}}\\right)\\,\\exp\\!\\left[-\\left(\\frac{k}{k_{\\mathrm{d}}}\\right)^2\\right]$$\n该实现将分为四个不同的测试函数，每个函数针对一个特定的验证案例。\n\n**测试 1：幂律斜率一致性**\n此测试验证 $P(k)$ 的原初幂律行为。参数设置使转移函数变为1：$k_{\\mathrm{eq}} \\to +\\infty$ 意味着 $T_{\\mathrm{nw}}(k) \\to 1$，而 $B=0$ 意味着 $M_{\\mathrm{bao}}(k)=1$。因此，对于所有 $k$，$T(k)=1$。功率谱简化为纯幂律：\n$$P(k) = A\\,k^{n_{\\mathrm{s}}}$$\n对此方程取自然对数，得到一个线性关系：\n$$\\ln P(k) = \\ln A + n_{\\mathrm{s}} \\ln k$$\n此方程的形式为 $y = c + s x$，其中 $y = \\ln P(k)$，$x = \\ln k$，截距为 $c = \\ln A$，斜率为 $s = n_{\\mathrm{s}}$。算法为给定参数（$A=10^3$, $n_{\\mathrm{s}}=1.4$）在 $k \\in [10^{-3}, 10^{0}]\\,h\\,\\mathrm{Mpc}^{-1}$ 范围内的 $N=600$ 个对数间隔点上生成 $P(k)$。对 $(\\ln k, \\ln P)$ 数据点执行线性最小二乘回归以估计斜率 $\\hat{s}$。如果估计斜率与真实斜率之间的绝对差在指定容差范围内，即 $\\lvert \\hat{s}-n_{\\mathrm{s}}\\rvert \\le \\tau_{\\mathrm{s}} = 10^{-3}$，则测试通过。该函数返回一个布尔值，指示结果。\n\n**测试 2  4：重子声学振荡 (BAO) 周期恢复**\n这些测试验证计算流程从振荡特征中测量特征尺度的能力。此处，$k_{\\mathrm{eq}} \\to +\\infty$ 且 $n_s=0$，这隔离了BAO分量：\n$$P(k) = A\\, (M_{\\mathrm{bao}}(k))^2$$\n$k$ 空间中振荡的基本周期由参数 $k_{\\mathrm{bao}}$ 给出。估计此周期的算法流程如下：\n1.  **峰值识别**：识别离散 $P(k)$ 数组中的局域极大值。如果波数 $k_i$ 处的点 $P_i$ 大于其紧邻的邻居 $P_{i-1}$ 和 $P_{i+1}$，则该点被视为一个峰值。\n2.  **峰值精化**：使用围绕每个峰值的三点模板 $(P_{i-1}, P_i, P_{i+1})$ 进行二次插值，来精化离散的峰值位置。通过这些点的抛物线的真实顶点提供了峰值位置的子网格估计。对于均匀网格间距 $\\Delta k$，对离散峰值位置 $k_i$ 的修正 $\\delta_k$ 使用给定的公式计算：\n    $$\\delta_k = \\left(\\frac{1}{2}\\,\\frac{P_{i-1}-P_{i+1}}{P_{i-1}-2P_i+P_{i+1}}\\right) \\Delta k$$\n    精化后的峰值位置为 $k_{\\text{refined}} = k_i + \\delta_k$。\n3.  **周期估计**：计算连续精化峰值位置之间的间距。这些间距的中位数被作为BAO周期的稳健估计量 $\\widehat{\\Delta k}$。\n\n**测试 2** 使用参数（$B=0.05, k_{\\mathrm{bao}}=0.06\\,h\\,\\mathrm{Mpc}^{-1}, k_{\\mathrm{d}}=0.30\\,h\\,\\mathrm{Mpc}^{-1}$）和一个密集的线性间隔定义域（$k \\in [0.01, 0.5]\\,h\\,\\mathrm{Mpc}^{-1}$，$N=4000$），旨在成功恢复周期。该函数返回绝对误差 $\\lvert\\widehat{\\Delta k} - k_{\\mathrm{bao}}\\rvert$。\n\n**测试 4** 是一个旨在失败的边界情况。其定义域（$k \\in [0.01, 0.11]\\,h\\,\\mathrm{Mpc}^{-1}$）被有意选择得过短，以至于对于给定的周期 $k_{\\mathrm{bao}}=0.05\\,h\\,\\mathrm{Mpc}^{-1}$，它不足以包含足够数量的振荡。该测试必须返回一个布尔值，指示估计量是否正确地将信号识别为“分辨不足”。如果找到的峰间距少于三个（即峰值少于四个），或者估计周期的相对误差 $\\lvert\\widehat{\\Delta k} - k_{\\mathrm{bao}}\\rvert/k_{\\mathrm{bao}}$ 超过 $0.3$，则信号被声明为分辨不足。\n\n**测试 3：超视界标度**\n此测试验证功率谱在非常大尺度上的正确行为，对应于极限 $k \\to 0$。在此极限下，转移函数 $T(k)$ 应趋近于 $1$。该测试使用的参数中，BAO分量被关闭（$B=0$），因此行为由 $T_{\\mathrm{nw}}(k)$ 控制。测试计算比率：\n$$R(k) = \\frac{P(k)}{A\\,k^{n_{\\mathrm{s}}}} = T_{\\mathrm{nw}}^2(k) = \\left[1+\\left(\\frac{k}{k_{\\mathrm{eq}}}\\right)^2\\right]^{-\\alpha}$$\n对于 $k \\ll k_{\\mathrm{eq}}$，此比率应接近 $1$。测试通过计算在指定的超视界定义域 $k \\in [10^{-4}, 10^{-2}]\\,h\\,\\mathrm{Mpc}^{-1}$ 上，最大绝对差 $\\max_k \\lvert R(k) - 1\\rvert$ 来量化与理想行为的偏差，参数为 $A=2\\times 10^4, n_{\\mathrm{s}} = 0.965, k_{\\mathrm{eq}} = 0.015\\,h\\,\\mathrm{Mpc}^{-1}, \\alpha=2.0$。该函数返回这个最大偏差，作为一个浮点数。\n\n最终的程序集成了这四个测试，按顺序执行它们，并以指定的格式打印收集到的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_power_spectrum(k, A, n_s, k_eq, alpha, B, k_bao, k_d):\n    \"\"\"\n    Computes the toy model linear matter power spectrum P(k).\n    \"\"\"\n    if np.isinf(k_eq):\n        # Simplification for infinite k_eq (no turnover)\n        T_nw_sq = 1.0\n    else:\n        T_nw = (1.0 + (k / k_eq)**2)**(-alpha / 2.0)\n        T_nw_sq = T_nw**2\n\n    if B == 0:\n        # Simplification for no BAO wiggles\n        T_sq = T_nw_sq\n    else:\n        M_bao = 1.0 + B * np.sin(2.0 * np.pi * k / k_bao) * np.exp(-(k / k_d)**2)\n        T_sq = T_nw_sq * (M_bao**2)\n\n    P_k = A * (k**n_s) * T_sq\n    return P_k\n\ndef estimate_bao_period(k, P_k):\n    \"\"\"\n    Estimates the BAO period from a given power spectrum.\n    \n    This function finds peaks, refines their locations using quadratic interpolation,\n    and returns the calculated spacings and refined peak locations.\n    Assumes k is linearly spaced.\n    \"\"\"\n    # Find peak indices by comparing each point to its neighbours.\n    # We add 1 to the resulting indices because the slice P_k[1:-1] starts at index 1.\n    peak_indices = np.where((P_k[1:-1] > P_k[:-2])  (P_k[1:-1] > P_k[2:]))[0] + 1\n\n    if len(peak_indices)  2:\n        return np.array([]), np.array([]) # Not enough peaks for any spacing\n\n    refined_peaks_k = []\n    delta_k = k[1] - k[0] # Grid spacing for linear grid\n\n    for i in peak_indices:\n        # Cannot interpolate if the peak is at the very edge of the array\n        if i == 0 or i == len(P_k) - 1:\n            continue\n\n        y_minus_1, y_0, y_plus_1 = P_k[i-1], P_k[i], P_k[i+1]\n        \n        # Denominator of the quadratic interpolation formula\n        denominator = y_minus_1 - 2.0 * y_0 + y_plus_1\n        \n        # Avoid division by zero if the peak is flat or not quadratic\n        if np.abs(denominator)  1e-12:\n            refined_k = k[i]\n        else:\n            offset_in_grid_units = 0.5 * (y_minus_1 - y_plus_1) / denominator\n            refined_k = k[i] + offset_in_grid_units * delta_k\n        \n        refined_peaks_k.append(refined_k)\n\n    if len(refined_peaks_k)  2:\n        return np.array([]), np.array(refined_peaks_k)\n\n    spacings = np.diff(refined_peaks_k)\n    return spacings, np.array(refined_peaks_k)\n\ndef run_test1():\n    \"\"\"Test 1: Power-law slope consistency.\"\"\"\n    A, n_s, k_eq, B = 1000.0, 1.4, np.inf, 0.0\n    k_min, k_max, N = 1e-3, 1.0, 600\n    k = np.logspace(np.log10(k_min), np.log10(k_max), N)\n    \n    P_k = get_power_spectrum(k, A, n_s, k_eq, alpha=0, B=B, k_bao=1, k_d=1)\n    \n    # Perform linear regression on log-log data\n    log_k, log_P = np.log(k), np.log(P_k)\n    slope, _ = np.polyfit(log_k, log_P, 1)\n    \n    tau_s = 1e-3\n    return np.abs(slope - n_s) = tau_s\n\ndef run_test2():\n    \"\"\"Test 2: BAO period recovery in a clean setting.\"\"\"\n    A, n_s, k_eq = 1.0, 0.0, np.inf\n    B, k_bao, k_d = 0.05, 0.06, 0.30\n    k_min, k_max, N = 1e-2, 5e-1, 4000\n    k = np.linspace(k_min, k_max, N)\n\n    P_k = get_power_spectrum(k, A, n_s, k_eq, alpha=0, B=B, k_bao=k_bao, k_d=k_d)\n    \n    spacings, _ = estimate_bao_period(k, P_k)\n\n    if len(spacings) == 0:\n        # Return a placeholder if no spacings could be computed.\n        # This case is not expected for Test 2's parameters.\n        estimated_period = -1.0\n    else:\n        estimated_period = np.median(spacings)\n\n    return np.abs(estimated_period - k_bao)\n\ndef run_test3():\n    \"\"\"Test 3: Super-horizon scaling.\"\"\"\n    A, n_s, k_eq, alpha, B = 2e4, 0.965, 0.015, 2.0, 0.0\n    k_min, k_max, N = 1e-4, 1e-2, 600\n    k = np.logspace(np.log10(k_min), np.log10(k_max), N)\n\n    P_k = get_power_spectrum(k, A, n_s, k_eq, alpha, B, k_bao=1, k_d=1)\n    \n    R_k = P_k / (A * k**n_s)\n    \n    max_deviation = np.max(np.abs(R_k - 1.0))\n    return max_deviation\n\ndef run_test4():\n    \"\"\"Test 4: Edge case for BAO detection (under-resolved).\"\"\"\n    A, n_s, k_eq = 1.0, 0.0, np.inf\n    B, k_bao, k_d = 0.05, 0.05, 0.25\n    k_min, k_max, N = 1e-2, 1.1e-1, 100\n    k = np.linspace(k_min, k_max, N)\n    \n    P_k = get_power_spectrum(k, A, n_s, k_eq, alpha=0, B=B, k_bao=k_bao, k_d=k_d)\n    \n    spacings, _ = estimate_bao_period(k, P_k)\n\n    # Condition 1: Not enough peaks to compute 3 spacings\n    if len(spacings)  3:\n        return True\n    \n    # Condition 2: High relative error in the estimated period\n    estimated_period = np.median(spacings)\n    relative_error = np.abs(estimated_period - k_bao) / k_bao\n    if relative_error > 0.3:\n        return True\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Each test is self-contained with its parameters defined inside.\n    test_cases = [\n        run_test1,\n        run_test2,\n        run_test3,\n        run_test4,\n    ]\n\n    results = []\n    for test_func in test_cases:\n        result = test_func()\n        results.append(result)\n\n    # The final print statement must produce the exact required format.\n    # Python's str() of a boolean is capitalized ('True', 'False'), which is\n    # consistent with the problem's example format `[\\mathrm{True}, ...]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}