{
    "hands_on_practices": [
        {
            "introduction": "The presence of baryons in the primordial photon-baryon fluid acts as an inertial drag, slowing the propagation of acoustic waves. This practice provides a direct, analytical look at this fundamental mechanism by calculating the phase shift induced by \"baryon loading.\" By working through this simplified model , you will gain a clear physical intuition for how the baryon-to-photon ratio, $R \\equiv 3 \\rho_{b}/(4 \\rho_{\\gamma})$, directly impacts the characteristics of the BAO feature.",
            "id": "3465623",
            "problem": "Consider a Fourier mode with comoving wavenumber $k$ in the tightly coupled photon–baryon fluid before the baryon drag epoch. In the tight-coupling limit and neglecting anisotropic stress, photon diffusion (Silk damping), and any time variation of the gravitational potential, the combined photon–baryon fluid obeys an acoustic wave equation with an effective sound speed $c_{s}$ that depends on the baryon loading parameter $R$, where $R \\equiv 3 \\rho_{b}/(4 \\rho_{\\gamma})$ and $\\rho_{b}$ and $\\rho_{\\gamma}$ denote the baryon and photon energy densities, respectively. In units where the speed of light is $c=1$, the sound speed satisfies $c_{s}^{2} = 1/\\big(3(1+R)\\big)$.\n\nAssume the following scientifically realistic scenario:\n- For conformal times $\\eta  \\eta_{1}$, the baryon loading is negligible, so $R \\approx 0$ and $c_{s} = 1/\\sqrt{3}$.\n- For conformal times $\\eta \\in [\\eta_{1}, \\eta_{d}]$, the baryon loading $R$ can be treated as constant and nonzero ($R>0$), such that $c_{s} = 1/\\sqrt{3(1+R)}$ over this interval.\n- The acoustic phase of the mode is well described by the Wentzel–Kramers–Brillouin (WKB) form, with phase accumulation given by the integral of the instantaneous frequency $k c_{s}$ over conformal time.\n\nDefine the acoustic phase $\\varphi(k,\\eta)$ by the argument of the oscillatory solution and consider the phase at the end of the interval, $\\eta=\\eta_{d}$. Let $\\Delta \\varphi(k)$ denote the difference between the acoustic phase accumulated in the baryon-loaded model and the baryon-free reference computed over the same interval $[\\eta_{1}, \\eta_{d}]$:\n$$\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big].$$\n\nStarting from the tight-coupling acoustic dynamics and the definition of $c_{s}$ given above, derive a closed-form analytic expression for $\\Delta \\varphi(k)$ under the assumptions stated. Express your final answer in radians as a function of $k$, $R$, and the conformal time interval $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$. The final answer must be a single analytical expression, not an inequality or an equation to be solved.",
            "solution": "The problem statement is scientifically grounded, well-posed, and internally consistent under the stated assumptions. It presents a standard, albeit simplified, scenario in the study of baryon acoustic oscillations. All required definitions and conditions are provided, allowing for a direct and unambiguous derivation. Therefore, the problem is valid.\n\nThe central task is to calculate the phase difference $\\Delta \\varphi(k)$ for a comoving Fourier mode with wavenumber $k$. The problem defines $\\Delta \\varphi(k)$ as the difference in accumulated acoustic phase between a baryon-loaded universe and a baryon-free universe over the conformal time interval $[\\eta_{1}, \\eta_{d}]$.\n$$\n\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big]\n$$\n\nAccording to the Wentzel–Kramers–Brillouin (WKB) approximation specified, the acoustic phase $\\varphi(k, \\eta)$ accumulates over conformal time as the integral of the instantaneous frequency, which is given by $k c_{s}(\\eta)$. Therefore, the phase accumulated over the interval $[\\eta_{1}, \\eta_{d}]$ is given by the integral:\n$$\n\\varphi(k, \\eta_{d}) - \\varphi(k, \\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k c_{s}(\\eta') \\, d\\eta'\n$$\n\nWe must evaluate this integral for the two scenarios described: one with baryon loading ($R>0$) and a reference scenario without it ($R=0$).\n\nFirst, consider the baryon-loaded case ($R>0$). The problem states that for $\\eta \\in [\\eta_{1}, \\eta_{d}]$, the baryon loading parameter $R$ is a non-zero constant. The effective sound speed $c_{s}$ is thus also constant over this interval and is given by:\n$$\nc_{s, R>0} = \\frac{1}{\\sqrt{3(1+R)}}\n$$\nThe phase accumulated in this case, which is the first term in the definition of $\\Delta \\varphi(k)$, is:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R>0} \\, d\\eta'\n$$\nSince $k$ and $c_{s, R>0}$ are constant with respect to the integration variable $\\eta'$, we can take them outside the integral:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = k \\, c_{s, R>0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3(1+R)}} (\\eta_{d} - \\eta_{1})\n$$\nUsing the definition $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$, this becomes:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}}\n$$\n\nNext, we consider the baryon-free reference case ($R=0$). This corresponds to a fluid of photons only. The sound speed is found by setting $R=0$ in the general formula:\n$$\nc_{s, R=0} = \\frac{1}{\\sqrt{3(1+0)}} = \\frac{1}{\\sqrt{3}}\n$$\nThis sound speed is also constant. The phase accumulated in this reference case, which is the second term in the definition of $\\Delta \\varphi(k)$, is:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R=0} \\, d\\eta'\n$$\nSimilarly, we take the constants outside the integral:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = k \\, c_{s, R=0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3}} (\\eta_{d} - \\eta_{1})\n$$\nIn terms of $\\Delta \\eta$, this is:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3}}\n$$\n\nFinally, we substitute these two results into the defining expression for $\\Delta \\varphi(k)$:\n$$\n\\Delta \\varphi(k) = \\left( \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}} \\right) - \\left( \\frac{k \\Delta \\eta}{\\sqrt{3}} \\right)\n$$\nWe can factor out the common terms $k$, $\\Delta \\eta$, and $1/\\sqrt{3}$ to obtain the final closed-form expression:\n$$\n\\Delta \\varphi(k) = \\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)\n$$\nThis expression represents the phase shift, which is negative as expected since baryon loading reduces the sound speed and thus retards the phase accumulation of the acoustic wave. It is a function of $k$, $R$, and $\\Delta \\eta$ as required.",
            "answer": "$$\n\\boxed{\\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)}\n$$"
        },
        {
            "introduction": "The comoving sound horizon at the baryon drag epoch, $r_d$, is the physical scale imprinted in the cosmos by acoustic waves, serving as our \"standard ruler.\" This hands-on coding exercise  moves from theory to practice, guiding you to implement a high-precision numerical computation of $r_d$ for various cosmological models. You will tackle the numerical challenges of the integral definition and validate your results, a foundational skill for any quantitative BAO analysis.",
            "id": "3465692",
            "problem": "Implement a program that computes the baryon-drag sound horizon scale $r_d$ in megaparsecs for several cosmological models and stress-tests numerical stability against rapidly varying effective sound speed by comparing two adaptive numerical methods and cross-checking with a standard approximate formula.\n\nBegin from the following foundations.\n\n1. The baryon-drag sound horizon at the drag epoch is defined as the conformal distance traveled by coupled baryon-photon acoustic waves up to the drag scale factor $a_d$, which is given by\n$$\nr_d \\equiv \\int_{0}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a,\n$$\nwhere $c_s(a)$ is the effective sound speed of the photon-baryon fluid, and $H(a)$ is the Hubble expansion rate.\n\n2. The effective sound speed is\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}},\n$$\nwith\n$$\nR(a) \\equiv \\frac{3 \\rho_b(a)}{4 \\rho_\\gamma(a)} = \\frac{3}{4}\\frac{\\Omega_b}{\\Omega_\\gamma} a.\n$$\nHere $c$ is the speed of light in vacuum in $\\mathrm{km/s}$, $\\rho_b$ and $\\rho_\\gamma$ are the baryon and photon energy densities, respectively, and $\\Omega_b$ and $\\Omega_\\gamma$ are their present-day density parameters.\n\n3. The Hubble rate as a function of scale factor $a$ in a spatially flat Universe is\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda},\n$$\nwith $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$, and $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. The present-day radiation density parameter is\n$$\n\\Omega_r = \\Omega_\\gamma \\left( 1 + 0.2271\\, N_{\\mathrm{eff}} \\right),\n$$\nwhere $N_{\\mathrm{eff}}$ is the Effective Number of Relativistic Species (commonly $N_{\\mathrm{eff}} \\approx 3.046$). The photon density parameter satisfies\n$$\n\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} \\left(\\frac{T_{\\mathrm{CMB}}}{2.7255\\,\\mathrm{K}}\\right)^4,\n$$\nwhere $T_{\\mathrm{CMB}}$ is the temperature of the Cosmic Microwave Background (CMB).\n\n4. The drag redshift $z_d$ is to be computed from the Eisenstein–Hu fitting formula,\n$$\nz_d = \\frac{1291 (\\Omega_m h^2)^{0.251}}{1 + 0.659 (\\Omega_m h^2)^{0.828}}\\left[ 1 + b_1 (\\Omega_b h^2)^{b_2} \\right],\n$$\nwhere\n$$\nb_1 = 0.313 (\\Omega_m h^2)^{-0.419}\\left[1 + 0.607 (\\Omega_m h^2)^{0.674} \\right],\\quad\nb_2 = 0.238 (\\Omega_m h^2)^{0.223}.\n$$\nThen $a_d = 1/(1+z_d)$.\n\n5. For cross-checking purposes, use the Eisenstein–Hu analytic approximation for the sound horizon at the drag epoch,\n$$\nr_d^{\\mathrm{EH}} = \\frac{2}{3 k_{\\mathrm{eq}}} \\sqrt{\\frac{6}{R_{\\mathrm{eq}}}} \\,\n\\ln\\!\\left(\\frac{\\sqrt{1 + R_d} + \\sqrt{R_d + R_{\\mathrm{eq}}}}{1 + \\sqrt{R_{\\mathrm{eq}}}}\\right),\n$$\nwhere $R_d = R(a_d)$, $a_{\\mathrm{eq}} = \\Omega_r / \\Omega_m$, $R_{\\mathrm{eq}} = R(a_{\\mathrm{eq}})$, and\n$$\nk_{\\mathrm{eq}} \\equiv \\frac{a_{\\mathrm{eq}} H(a_{\\mathrm{eq}})}{c},\n$$\nexpressed in $\\mathrm{Mpc}^{-1}$ when $H$ is in $\\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$ and $c$ in $\\mathrm{km\\, s^{-1}}$. The value $r_d^{\\mathrm{EH}}$ is in $\\mathrm{Mpc}$.\n\nTask requirements.\n\nA. Implement two independent adaptive numerical methods to evaluate $r_d$:\n- Method 1: Adaptive quadrature of the integral over $a \\in [0, a_d]$. Because the integrand is finite but approaches a constant as $a \\to 0$ in the radiation-dominated regime, you must start the numerical integral at a small $a_{\\min} > 0$ and add the analytic early-time contribution\n$$\n\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3}\\, H_0 \\sqrt{\\Omega_r}}\\, a_{\\min},\n$$\nso that $r_d \\approx \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)}\\, \\mathrm{d}a$.\n- Method 2: Adaptive integration of the ordinary differential equation\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}, \\quad r(a_{\\min}) = \\Delta r(a_{\\min}),\n$$\nfrom $a_{\\min}$ to $a_d$ with stepsize control.\n\nBoth methods must use tight absolute and relative tolerances to probe numerical stability under rapidly varying $c_s(a)$ induced by the baryon loading term $R(a)$.\n\nB. For each cosmological parameter set, compute:\n- The value $r_d$ in $\\mathrm{Mpc}$ by Method 1 (adaptive quadrature).\n- The value $r_d$ in $\\mathrm{Mpc}$ by Method 2 (adaptive ODE).\n- The approximate $r_d^{\\mathrm{EH}}$ in $\\mathrm{Mpc}$ from the Eisenstein–Hu approximation.\n\nFrom these, form two dimensionless diagnostics:\n- The relative difference between the two numerical methods,\n$$\n\\delta_{\\mathrm{num}} = \\frac{\\left| r_d^{(1)} - r_d^{(2)} \\right|}{\\tfrac{1}{2}\\left( r_d^{(1)} + r_d^{(2)} \\right)}.\n$$\n- The relative deviation from the Eisenstein–Hu approximation using Method 1,\n$$\n\\delta_{\\mathrm{EH}} = \\frac{\\left| r_d^{(1)} - r_d^{\\mathrm{EH}} \\right|}{r_d^{\\mathrm{EH}}}.\n$$\n\nC. Use the following test suite of five cosmological models, each specified by $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$:\n- Case 1 (Planck-like baseline): $(0.315, 0.049, 0.674, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 2 (high baryon loading): $(0.35, 0.08, 0.70, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 3 (enhanced relativistic species): $(0.315, 0.049, 0.674, 4.0, 2.7255\\,\\mathrm{K})$.\n- Case 4 (low baryon fraction): $(0.30, 0.02, 0.67, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 5 (extremely low baryon fraction): $(0.27, 0.005, 0.67, 3.046, 2.7255\\,\\mathrm{K})$.\n\nOutput specification.\n\n- Internal computations of $r_d$ must be performed and treated in $\\mathrm{Mpc}$.\n- For each case, compute $\\delta_{\\mathrm{num}}$ and $\\delta_{\\mathrm{EH}}$ as defined above (dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list of $10$ floating-point numbers enclosed in square brackets, in the order\n$$\n[\\delta_{\\mathrm{num}}^{(1)}, \\delta_{\\mathrm{EH}}^{(1)}, \\delta_{\\mathrm{num}}^{(2)}, \\delta_{\\mathrm{EH}}^{(2)}, \\ldots, \\delta_{\\mathrm{num}}^{(5)}, \\delta_{\\mathrm{EH}}^{(5)}].\n$$\nRound nothing; print the full precision produced by standard Python string conversion of floats.",
            "solution": "The problem is valid as it is well-posed, scientifically grounded in established cosmological principles, and provides a complete, consistent set of definitions and parameters. All provided equations are standard in the field of cosmology or come from widely used fitting formulae. The test cases are physically plausible. The task is a well-defined numerical problem.\n\nThe solution computes the baryon-drag sound horizon, $r_d$, a fundamental scale in cosmology related to Baryon Acoustic Oscillations (BAOs). This scale is the maximum distance a sound wave in the primordial baryon-photon plasma could travel from the Big Bang until the epoch when baryons decoupled from photons (the drag epoch, at scale factor $a_d$). The computation is performed for several cosmological models, each defined by a set of parameters $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$.\n\nFirst, for each model, we establish the cosmological background. The input parameters are the present-day matter density parameter $\\Omega_m$, baryon density parameter $\\Omega_b$, reduced Hubble constant $h$, effective number of relativistic species $N_{\\mathrm{eff}}$, and CMB temperature $T_{\\mathrm{CMB}}$. From these, we derive other essential quantities. The Hubble constant is $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$. The present photon density parameter $\\Omega_\\gamma$ is calculated from $T_{\\mathrm{CMB}}$ via the Stefan-Boltzmann law, using the relation $\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} (T_{\\mathrm{CMB}} / 2.7255\\,\\mathrm{K})^4$. The total radiation density $\\Omega_r$ includes photons and relativistic neutrinos, given by $\\Omega_r = \\Omega_\\gamma ( 1 + 0.2271\\, N_{\\mathrm{eff}} )$. In a spatially flat universe, the dark energy density is $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. With these parameters, the Hubble expansion rate at any scale factor $a$ is given by the Friedmann equation:\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}\n$$\n\nThe sound horizon $r_d$ is defined by the integral of the sound speed $c_s(a)$ over conformal time up to the drag epoch $a_d$:\n$$\nr_d = \\int_0^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\nThe sound speed of the photon-baryon fluid depends on the ratio of baryon to photon energy densities, $R(a) = (3\\rho_b/4\\rho_\\gamma) = (3/4)(\\Omega_b/\\Omega_\\gamma)a$:\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}}\n$$\nwhere $c$ is the speed of light. The upper limit of integration, $a_d$, is the scale factor at the drag epoch, calculated from the drag redshift $z_d$ as $a_d = 1/(1+z_d)$. We compute $z_d$ using the accurate Eisenstein-Hu fitting formula, which depends on the physical matter and baryon densities, $\\Omega_m h^2$ and $\\Omega_b h^2$.\n\nThe integral for $r_d$ runs from $a=0$. The term $a^2$ in the denominator creates a potential numerical singularity. However, in the early universe ($a \\to 0$), the universe is radiation-dominated, so $H(a) \\approx H_0 \\sqrt{\\Omega_r} a^{-2}$, and the baryon loading $R(a) \\to 0$, so $c_s(a) \\to c/\\sqrt{3}$. The integrand thus approaches a constant, $\\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}}$. To handle the integral, we split it at a small scale factor $a_{\\min} > 0$:\n$$\nr_d = \\int_0^{a_{\\min}} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\nThe first term is well-approximated by $\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}} a_{\\min}$. The second term is computed numerically.\n\nWe implement two high-precision numerical methods for this task:\n1.  **Method 1 (Adaptive Quadrature)**: We directly compute the definite integral from $a_{\\min}$ to $a_d$ using `scipy.integrate.quad`, a robust adaptive quadrature routine. The final result is $r_d^{(1)} = \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a$.\n2.  **Method 2 (Adaptive ODE Integration)**: We recast the problem as a first-order ordinary differential equation for $r(a)$, $\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}$, with the initial condition $r(a_{\\min}) = \\Delta r(a_{\\min})$. We solve this initial value problem from $a = a_{\\min}$ to $a = a_d$ using `scipy.integrate.solve_ivp` with a high-order adaptive step-size solver. The value of the solution at $a_d$ gives $r_d^{(2)}$.\n\nFor cross-checking, we also compute the Eisenstein-Hu analytic approximation, $r_d^{\\mathrm{EH}}$, which provides a quick and fairly accurate estimate of the sound horizon without numerical integration.\n\nFinally, for each cosmological model, we compute two dimensionless diagnostics. The first, $\\delta_{\\mathrm{num}} = |r_d^{(1)} - r_d^{(2)}| / (\\frac{1}{2}(r_d^{(1)} + r_d^{(2)}))$, measures the numerical stability and agreement between the two independent high-precision methods. The second, $\\delta_{\\mathrm{EH}} = |r_d^{(1)} - r_d^{\\mathrm{EH}}| / r_d^{\\mathrm{EH}}$, quantifies the accuracy of the Eisenstein-Hu fitting formula against a precise numerical integration. These diagnostics are calculated for all five test cases and presented in the required output format. Extremely tight tolerances ($10^{-13}$) are used for the numerical solvers to ensure that $\\delta_{\\mathrm{num}}$ is a robust measure of method consistency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad, solve_ivp\n\nC_KM_S = 299792.458  # Speed of light in km/s\n\ndef calculate_diagnostics(params):\n    \"\"\"\n    Computes diagnostic quantities for a given cosmological model.\n    \n    For a given set of cosmological parameters, this function calculates the \n    baryon-drag sound horizon r_d using two numerical methods and one analytic \n    approximation. It then computes the relative differences between these results.\n    \n    Args:\n        params (tuple): A tuple of cosmological parameters \n                        (Omega_m, Omega_b, h, N_eff, T_CMB).\n\n    Returns:\n        tuple: A tuple containing two floats: (delta_num, delta_eh).\n    \"\"\"\n    Omega_m, Omega_b, h, N_eff, T_CMB = params\n\n    # Constants and Derived Parameters\n    H0 = 100.0 * h  # Hubble constant in km/s/Mpc\n    omega_mh2 = Omega_m * h**2\n    omega_bh2 = Omega_b * h**2\n\n    # Photon and radiation densities\n    omega_gamma_h2 = 2.469e-5 * (T_CMB / 2.7255)**4\n    Omega_gamma = omega_gamma_h2 / h**2\n    omega_r_h2 = omega_gamma_h2 * (1.0 + 0.2271 * N_eff)\n    Omega_r = omega_r_h2 / h**2\n\n    # Dark energy density for a flat universe\n    Omega_Lambda = 1.0 - Omega_m - Omega_r\n\n    # Cosmological functions of scale factor 'a'\n    def H(a):\n        return H0 * np.sqrt(Omega_r * a**-4 + Omega_m * a**-3 + Omega_Lambda)\n\n    def R(a):\n        return (3.0 / 4.0) * (Omega_b / Omega_gamma) * a\n    \n    def cs(a):\n        return C_KM_S / np.sqrt(3.0 * (1.0 + R(a)))\n\n    # Drag epoch redshift (z_d) and scale factor (a_d) from Eisenstein-Hu formula\n    b1 = 0.313 * (omega_mh2)**-0.419 * (1.0 + 0.607 * (omega_mh2)**0.674)\n    b2 = 0.238 * (omega_mh2)**0.223\n    z_d = 1291. * (omega_mh2)**0.251 / (1.0 + 0.659 * (omega_mh2)**0.828) * (1.0 + b1 * (omega_bh2)**b2)\n    a_d = 1.0 / (1.0 + z_d)\n\n    # Integrand for sound horizon r_d\n    def integrand(a):\n        if a == 0:\n            # The limit as a - 0 is finite\n            return C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n        return cs(a) / (a**2 * H(a))\n\n    # Handle the integral from a=0 by splitting at a_min\n    a_min = 1e-10\n    integrand_early = C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n    dr_amin = integrand_early * a_min\n\n    # --- Method 1: Adaptive Quadrature ---\n    # Using scipy.integrate.quad with tight tolerances\n    integral_val, _ = quad(integrand, a_min, a_d, epsabs=1e-13, epsrel=1e-13)\n    r_d1 = dr_amin + integral_val\n\n    # --- Method 2: Adaptive ODE Integration ---\n    # dr/da = integrand(a), solved with scipy.integrate.solve_ivp\n    sol = solve_ivp(\n        lambda a, r: integrand(a),\n        (a_min, a_d),\n        [dr_amin],\n        method='DOP853',  # High-order accurate solver\n        rtol=1e-13,\n        atol=1e-13\n    )\n    r_d2 = sol.y[0, -1]\n\n    # --- Eisenstein-Hu Analytic Approximation ---\n    a_eq = Omega_r / Omega_m\n    R_d = R(a_d)\n    R_eq = R(a_eq)\n    k_eq = a_eq * H(a_eq) / C_KM_S  # in 1/Mpc\n\n    log_arg_num = np.sqrt(1.0 + R_d) + np.sqrt(R_d + R_eq)\n    log_arg_den = 1.0 + np.sqrt(R_eq)\n    r_d_eh = (2.0 / (3.0 * k_eq)) * np.sqrt(6.0 / R_eq) * np.log(log_arg_num / log_arg_den)\n\n    # --- Diagnostics ---\n    delta_num = abs(r_d1 - r_d2) / (0.5 * (r_d1 + r_d2))\n    delta_eh = abs(r_d1 - r_d_eh) / r_d_eh\n\n    return delta_num, delta_eh\n\ndef solve():\n    \"\"\"\n    Main function to run the cosmological calculations for all test cases.\n    \"\"\"\n    # Test suite of cosmological models\n    test_cases = [\n        (0.315, 0.049, 0.674, 3.046, 2.7255),  # Case 1 (Planck-like)\n        (0.35, 0.08, 0.70, 3.046, 2.7255),    # Case 2 (high baryon)\n        (0.315, 0.049, 0.674, 4.0, 2.7255),    # Case 3 (high N_eff)\n        (0.30, 0.02, 0.67, 3.046, 2.7255),    # Case 4 (low baryon fraction)\n        (0.27, 0.005, 0.67, 3.046, 2.7255),   # Case 5 (very low baryon)\n    ]\n\n    all_results = []\n    for params in test_cases:\n        delta_num, delta_eh = calculate_diagnostics(params)\n        all_results.extend([delta_num, delta_eh])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Extracting the faint BAO signal from a measured power spectrum, $P(k)$, requires separating the oscillations from the smooth broadband shape and any systematic contaminants. This advanced practice  addresses this real-world data analysis challenge by having you design an estimator for the BAO phase that is robust against smooth, polynomial-like systematic errors. You will implement a powerful \"nulling\" technique to ensure your measurement is insensitive to such instrumental or modeling uncertainties.",
            "id": "3465639",
            "problem": "You are asked to design and implement a numerical estimator for the phase of the baryon acoustic oscillation feature in the linear matter power spectrum that is invariant, by construction, to low-order multiplicative calibration tilts. The scientific starting point is that, in linear theory, the matter power spectrum $P(k)$ can be decomposed into a smooth broadband component and an oscillatory component produced by baryon acoustic oscillations. On a finite wavenumber interval relevant for baryon acoustic oscillations, the oscillatory component can be modeled as a sinusoid of argument $k r_s + \\phi_0$ multiplied by a damping envelope, where $r_s$ is the sound horizon scale and $\\phi_0$ is the true phase. Multiplicative calibration errors that are smooth functions of $k$ can be approximated to leading order by low-degree polynomials in $k$.\n\nYour task is to build a phase estimator that remains stable when the observed spectrum is contaminated by multiplicative calibration errors of the form $P(k) \\to \\left(1 + \\epsilon \\left(k/k_\\star\\right)^n\\right) P(k)$, for integer $n \\ge 0$ and small but finite $\\epsilon$, by ensuring the estimator is insensitive to any smooth polynomial tilt up to degree $m$.\n\nUse the following modeling choices, constants, and computational design:\n\n- Construct a synthetic linear power spectrum on a uniformly spaced grid in wavenumber $k \\in [k_{\\min}, k_{\\max}]$ with $N_k$ points, measured in units of $h\\,\\mathrm{Mpc}^{-1}$:\n  - Choose $k_{\\min} = 0.02$, $k_{\\max} = 0.30$, and $N_k = 2048$.\n  - Use a smooth baseline of the form\n    $$\n    P_{\\mathrm{sm}}(k) = P_0 \\,\\frac{k^{n_s}}{\\left[1 + \\left(k/k_p\\right)^\\beta\\right]^2},\n    $$\n    with $P_0 = 10^4$, $n_s = 1.0$, $k_p = 0.2$, and $\\beta = 3.0$.\n  - Superimpose a baryon acoustic oscillation feature modeled as\n    $$\n    P(k) = P_{\\mathrm{sm}}(k)\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right],\n    $$\n    with $A_w = 0.05$, $k_d = 0.12$, $r_s = 105.0$, and $\\phi_0 = 0.35$. All numbers are in $h\\,\\mathrm{Mpc}^{-1}$ where applicable, and angles are in radians.\n\n- Apply multiplicative calibration errors parameterized by $(\\epsilon, n)$ relative to a pivot $k_\\star$:\n  $$\n  P_{\\mathrm{obs}}(k) = \\left(1 + \\epsilon \\left(\\frac{k}{k_\\star}\\right)^n\\right) P(k),\n  $$\n  with $k_\\star = 0.20$.\n\n- Design a two-stage estimator for the baryon acoustic oscillation phase:\n  - Stage $1$ (smooth normalization): Fit a smooth baseline $\\widehat{S}(k)$ to $P_{\\mathrm{obs}}(k)$ that captures the broadband shape and the multiplicative tilt, by regressing $\\ln P_{\\mathrm{obs}}(k)$ against a polynomial in $k$ of degree $d_s$. Use $d_s = 7$, and define $\\widehat{S}(k) = \\exp\\left[\\sum_{j=0}^{d_s} a_j k^j\\right]$ from the best-fit coefficients $a_j$. Then form the residual ratio\n    $$\n    R(k) \\equiv \\frac{P_{\\mathrm{obs}}(k)}{\\widehat{S}(k)} - 1.\n    $$\n  - Stage $2$ (polynomial-tilt nulling and matched filtering): Build damped oscillatory templates\n    $$\n    t_s(k) = e^{-\\left(k/k_d\\right)^2} \\sin(k r_s),\\quad t_c(k) = e^{-\\left(k/k_d\\right)^2} \\cos(k r_s).\n    $$\n    Construct the polynomial nuisance subspace $\\mathcal{P}_m = \\mathrm{span}\\{1, k, k^2, \\dots, k^m\\}$ with $m = 3$. Orthogonalize both templates against $\\mathcal{P}_m$ by projecting them into the orthogonal complement of $\\mathcal{P}_m$ under the discrete inner product $\\langle f, g\\rangle = \\sum_i f(k_i) g(k_i)$ on the $k$ grid. Denote the orthogonalized templates by $\\tilde{t}_s$ and $\\tilde{t}_c$.\n    Estimate the phase by matched filtering:\n    $$\n    a \\equiv \\langle R, \\tilde{t}_s\\rangle,\\quad b \\equiv \\langle R, \\tilde{t}_c\\rangle,\\quad \\widehat{\\phi} \\equiv \\mathrm{atan2}(b, a).\n    $$\n\n- Test suite. Evaluate the absolute phase error $|\\Delta \\phi| \\equiv \\mathrm{wrap}\\left(\\widehat{\\phi} - \\phi_0\\right)$, wrapped into $[-\\pi, \\pi]$ and reported as a nonnegative number in radians, for the following $(\\epsilon, n)$ cases in the specified order, with $k_\\star$ as defined above:\n  - Case $1$: $(\\epsilon, n) = (0.00, 0)$.\n  - Case $2$: $(\\epsilon, n) = (0.30, 0)$.\n  - Case $3$: $(\\epsilon, n) = (0.30, 1)$.\n  - Case $4$: $(\\epsilon, n) = (0.50, 2)$.\n  - Case $5$: $(\\epsilon, n) = (0.50, 3)$.\n  - Case $6$: $(\\epsilon, n) = (0.50, 4)$.\n\n- Output specification. Your program must compute $|\\Delta \\phi|$ in radians for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example $[x_1,x_2,x_3,x_4,x_5,x_6]$, where each $x_i$ is a floating-point number.\n\nAll angles must be expressed in radians. All wavenumbers must be in units of $h\\,\\mathrm{Mpc}^{-1}$. The final output must be a single line in exactly the specified format.",
            "solution": "The problem requires the design and implementation of a numerical estimator for the phase of the baryon acoustic oscillation (BAO) feature in the linear matter power spectrum. A critical requirement is that this estimator must be robust against low-order multiplicative calibration errors, often referred to as \"tilts,\" which are smooth functions of the wavenumber $k$. The solution involves synthesizing a mock power spectrum, applying a specified calibration error, and then processing this \"observed\" spectrum through a two-stage algorithm to recover the BAO phase.\n\nThe underlying scientific principle is that the matter power spectrum, $P(k)$, can be modeled as a product of a smooth, broadband component, $P_{\\mathrm{sm}}(k)$, and an oscillatory component representing the BAO feature. The specific model provided is:\n$$\nP(k) = P_{\\mathrm{sm}}(k)\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right]\n$$\nHere, $P_{\\mathrm{sm}}(k)$ is the smooth part, $A_w = 0.05$ is the BAO amplitude, $e^{-\\left(k/k_d\\right)^2}$ with $k_d = 0.12 \\,h\\,\\mathrm{Mpc}^{-1}$ is a damping envelope, $r_s = 105.0 \\,h\\,\\mathrm{Mpc}^{-1}$ is the sound horizon scale, and $\\phi_0 = 0.35$ radians is the true phase we aim to estimate. The data is generated on a uniform grid in $k$ from $k_{\\min} = 0.02$ to $k_{\\max} = 0.30 \\,h\\,\\mathrm{Mpc}^{-1}$ with $N_k = 2048$ points.\n\nAn observed spectrum, $P_{\\mathrm{obs}}(k)$, is contaminated by a multiplicative systematic error:\n$$\nP_{\\mathrm{obs}}(k) = C(k) P(k) = \\left(1 + \\epsilon \\left(\\frac{k}{k_\\star}\\right)^n\\right) P(k)\n$$\nwhere $C(k)$ is the calibration tilt, parameterized by its amplitude $\\epsilon$ and power-law index $n$, relative to a pivot scale $k_\\star = 0.20 \\,h\\,\\mathrm{Mpc}^{-1}$.\n\nThe two-stage estimation procedure is designed to isolate the BAO phase $\\phi_0$ while nullifying the effect of the unknown tilt $C(k)$ and the broadband shape $P_{\\mathrm{sm}}(k)$.\n\n**Stage 1: Smooth Normalization**\n\nThe first stage aims to remove the overall smooth shape of the power spectrum, including the multiplicative tilt. This is achieved by fitting a smooth function $\\widehat{S}(k)$ to $P_{\\mathrm{obs}}(k)$ and normalizing by it. By taking the logarithm, the multiplicative components become additive:\n$$\n\\ln P_{\\mathrm{obs}}(k) = \\ln P_{\\mathrm{sm}}(k) + \\ln C(k) + \\ln\\left[1 + A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)\\right]\n$$\nSince $A_w \\ll 1$, the last term is approximately $A_w e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right)$. The first two terms, $\\ln P_{\\mathrm{sm}}(k)$ and $\\ln C(k)$, are smooth functions of $k$. Their sum can be effectively approximated by a polynomial in $k$. We perform a least-squares regression of $\\ln P_{\\mathrm{obs}}(k)$ against a polynomial of degree $d_s = 7$, yielding coefficients $a_j$. The fitted smooth component is $\\widehat{S}(k) = \\exp\\left(\\sum_{j=0}^{d_s} a_j k^j\\right)$.\n\nThe oscillatory part of the signal is then isolated by computing the residual ratio:\n$$\nR(k) = \\frac{P_{\\mathrm{obs}}(k)}{\\widehat{S}(k)} - 1 \\approx A_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right) + \\text{Residual Smooth Term}\n$$\nThe residual smooth term arises from imperfections in the polynomial fit. The core challenge is that this residual term can bias an estimate of $\\phi_0$.\n\n**Stage 2: Polynomial-Tilt Nulling and Matched Filtering**\n\nThe second stage is designed to estimate $\\phi_0$ from $R(k)$ in a way that is insensitive to this residual smooth contamination. The BAO signal within $R(k)$ can be expressed as a linear combination of sine and cosine templates:\n$$\nA_w \\, e^{-\\left(k/k_d\\right)^2} \\sin\\left(k r_s + \\phi_0\\right) = A_w \\cos(\\phi_0) \\, t_s(k) + A_w \\sin(\\phi_0) \\, t_c(k)\n$$\nwhere the templates are $t_s(k) = e^{-\\left(k/k_d\\right)^2} \\sin(k r_s)$ and $t_c(k) = e^{-\\left(k/k_d\\right)^2} \\cos(k r_s)$.\n\nThe residual smooth contamination in $R(k)$ can be locally approximated by a low-degree polynomial. We model this nuisance component as lying in the vector space $\\mathcal{P}_m = \\mathrm{span}\\{1, k, k^2, \\dots, k^m\\}$, with $m=3$. To make the phase estimate immune to any component in $\\mathcal{P}_m$, we project our templates $t_s$ and $t_c$ into the orthogonal complement of $\\mathcal{P}_m$. This procedure, known as nulling, ensures that the resulting templates have zero correlation with any polynomial of degree up to $m$.\n\nLet the discrete inner product be defined as $\\langle f, g\\rangle = \\sum_{i=1}^{N_k} f(k_i)g(k_i)$. Let $\\{q_j(k)\\}_{j=0}^m$ be an orthonormal basis for $\\mathcal{P}_m$ with respect to this inner product. This basis can be constructed from the monomial basis $\\{k^j\\}_{j=0}^m$ using the Gram-Schmidt process or, more robustly, a QR decomposition.\n\nThe projection of a template, say $t_s$, onto the nuisance space $\\mathcal{P}_m$ is given by $\\mathrm{proj}_{\\mathcal{P}_m}(t_s) = \\sum_{j=0}^{m} \\langle t_s, q_j \\rangle q_j$. The new template, orthogonal to $\\mathcal{P}_m$, is:\n$$\n\\tilde{t}_s = t_s - \\mathrm{proj}_{\\mathcal{P}_m}(t_s)\n$$\nSimilarly, we construct $\\tilde{t}_c$. By construction, $\\langle \\tilde{t}_s, p \\rangle = 0$ and $\\langle \\tilde{t}_c, p \\rangle = 0$ for any $p \\in \\mathcal{P}_m$.\n\nFinally, we perform matched filtering by projecting the residual data $R(k)$ onto these nulled templates:\n$$\na \\equiv \\langle R, \\tilde{t}_s\\rangle, \\quad b \\equiv \\langle R, \\tilde{t}_c\\rangle\n$$\nSince any polynomial component in $R(k)$ is orthogonal to $\\tilde{t}_s$ and $\\tilde{t}_c$, it does not contribute to $a$ and $b$. Thus, $a$ and $b$ isolate the amplitudes of the $\\cos(\\phi_0)$ and $\\sin(\\phi_0)$ components, respectively. The phase is estimated as:\n$$\n\\widehat{\\phi} = \\mathrm{atan2}(b, a)\n$$\nThe error is then calculated as $|\\Delta \\phi| = |\\mathrm{wrap}(\\widehat{\\phi} - \\phi_0)|$, where the wrapping function maps the angle to $[-\\pi, \\pi]$. This estimator is robust by construction to polynomial contamination up to degree $m=3$. For calibration tilts with power-law index $n \\le m$, the residual smooth term is well-approximated by a polynomial in $\\mathcal{P}_m$, and we expect the phase error to be small. For $n > m$, the method's protection fails, and a larger error is anticipated.\n\nThe algorithmic implementation proceeds as follows:\n1.  Define all physical and numerical parameters.\n2.  Create the discrete wavenumber grid $k_i$.\n3.  For each test case $(\\epsilon, n)$:\n    a.  Generate $P_{\\mathrm{obs}}(k_i)$.\n    b.  Fit $\\ln(P_{\\mathrm{obs}})$ with a $7^{\\mathrm{th}}$-degree polynomial to get $\\widehat{S}(k_i)$ and compute the residual $R(k_i)$.\n    c.  Construct a matrix whose columns are the monomial basis vectors $k_i^j$ for $j \\in \\{0, 1, 2, 3\\}$.\n    d.  Perform QR decomposition on this matrix to obtain an orthonormal basis for $\\mathcal{P}_3$.\n    e.  Generate templates $t_s(k_i)$ and $t_c(k_i)$.\n    f.  Project out the polynomial components from $t_s$ and $t_c$ to obtain $\\tilde{t}_s$ and $\\tilde{t}_c$.\n    g.  Compute the inner products $a = \\langle R, \\tilde{t}_s \\rangle$ and $b = \\langle R, \\tilde{t}_c \\rangle$.\n    h.  Calculate the phase estimate $\\widehat{\\phi}$ and its absolute error $|\\Delta \\phi|$.\n4.  Collect and print the results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical estimator for the BAO phase\n    in the linear matter power spectrum, robust to calibration tilts.\n    \"\"\"\n\n    # Define constants and model parameters\n    k_min = 0.02\n    k_max = 0.30\n    N_k = 2048\n    \n    P0 = 10000.0\n    n_s = 1.0\n    k_p = 0.2\n    beta = 3.0\n    \n    A_w = 0.05\n    k_d = 0.12\n    r_s = 105.0\n    phi_0 = 0.35\n    \n    k_star = 0.20\n    d_s = 7 # Degree for smooth log-polynomial fit\n    m = 3   # Degree of polynomial nuisance space\n\n    # Create the uniformly spaced wavenumber grid\n    k_grid = np.linspace(k_min, k_max, N_k)\n\n    def generate_power_spectrum(k, eps, n, phi):\n        \"\"\"Generates the observed power spectrum with a given tilt.\"\"\"\n        # Smooth baseline power spectrum\n        P_sm = P0 * (k**n_s) / (1 + (k / k_p)**beta)**2\n        \n        # Power spectrum with BAO feature\n        bao_term = A_w * np.exp(-(k / k_d)**2) * np.sin(k * r_s + phi)\n        P_true = P_sm * (1 + bao_term)\n        \n        # Apply multiplicative calibration error (tilt)\n        tilt_factor = 1 + eps * (k / k_star)**n\n        P_obs = P_true * tilt_factor\n        \n        return P_obs\n\n    def wrap_angle(angle):\n        \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n        return (angle + np.pi) % (2 * np.pi) - np.pi\n\n    # Define the test cases\n    test_cases = [\n        (0.00, 0),\n        (0.30, 0),\n        (0.30, 1),\n        (0.50, 2),\n        (0.50, 3),\n        (0.50, 4),\n    ]\n\n    results = []\n\n    # Main loop over test cases\n    for epsilon, n_tilt in test_cases:\n        # --- Data Generation ---\n        P_obs = generate_power_spectrum(k_grid, epsilon, n_tilt, phi_0)\n\n        # --- Stage 1: Smooth Normalization ---\n        # Regress ln(P_obs) against a polynomial in k\n        log_P_obs = np.log(P_obs)\n        poly_coeffs = np.polyfit(k_grid, log_P_obs, d_s)\n        \n        # Construct the smooth model fit\n        S_hat = np.exp(np.polyval(poly_coeffs, k_grid))\n        \n        # Compute the residual ratio\n        R = P_obs / S_hat - 1\n\n        # --- Stage 2: Polynomial-Tilt Nulling and Matched Filtering ---\n        # Construct the polynomial nuisance basis matrix\n        # Columns are k^0, k^1, ..., k^m\n        poly_basis_matrix = np.vander(k_grid, m + 1, increasing=True)\n        \n        # Orthonormalize the basis using QR decomposition for numerical stability\n        Q, _ = np.linalg.qr(poly_basis_matrix)\n\n        # Generate damped oscillatory templates\n        damping = np.exp(-(k_grid / k_d)**2)\n        t_s = damping * np.sin(k_grid * r_s)\n        t_c = damping * np.cos(k_grid * r_s)\n        \n        # Orthogonalize templates against the nuisance space\n        # Projection operator onto nuisance space is Q @ Q.T\n        # We subtract the projection from the original vector.\n        t_s_tilde = t_s - Q @ (Q.T @ t_s)\n        t_c_tilde = t_c - Q @ (Q.T @ t_c)\n        \n        # Estimate phase by matched filtering with orthogonalized templates\n        # Inner product is the dot product for discrete vectors\n        a = np.dot(R, t_s_tilde)\n        b = np.dot(R, t_c_tilde)\n        \n        phi_hat = np.arctan2(b, a)\n        \n        # Calculate the absolute phase error\n        delta_phi = wrap_angle(phi_hat - phi_0)\n        abs_delta_phi = np.abs(delta_phi)\n        \n        results.append(abs_delta_phi)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}