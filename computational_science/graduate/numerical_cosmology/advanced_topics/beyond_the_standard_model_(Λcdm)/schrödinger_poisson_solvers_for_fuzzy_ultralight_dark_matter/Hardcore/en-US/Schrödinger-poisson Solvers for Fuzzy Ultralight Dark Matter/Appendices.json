{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of any wave simulation depends critically on how well the numerical scheme reproduces the wave's dispersion relation, which connects its frequency to its wavenumber. This foundational exercise guides you through a pen-and-paper analysis comparing different numerical approximations of the Laplacian operator. By deriving the numerical dispersion error for each method, you will gain a deep appreciation for the exceptional accuracy of the pseudospectral method, justifying its widespread use in high-fidelity Schrödinger-Poisson solvers. ",
            "id": "3485474",
            "problem": "Consider the free Schrödinger equation for fuzzy (ultralight) dark matter,\n$$\ni \\hbar \\,\\frac{\\partial \\psi}{\\partial t} \\;=\\; -\\,\\frac{\\hbar^{2}}{2 m}\\,\\nabla^{2}\\psi \\,,\n$$\non a one-dimensional periodic domain of length $L$ discretized by $N$ uniformly spaced grid points with spacing $h = L/N$. Neglect the gravitational potential to isolate dispersive behavior. For a plane-wave mode consistent with the periodic domain, let $k = 2\\pi n/L$ with integer $n$, and define the grid-phase $\\theta = k h$ (use radians for all trigonometric functions). The exact dispersion relation is\n$$\n\\omega_{\\text{exact}}(k) \\;=\\; \\frac{\\hbar k^{2}}{2 m} \\,.\n$$\nThree spatial discretizations of the Laplacian are considered:\n\n1. Centered second-order finite difference:\n$$\n\\left[\\nabla^{2}\\psi\\right]_{j} \\;=\\; \\frac{\\psi_{j+1} - 2 \\psi_{j} + \\psi_{j-1}}{h^{2}} \\,.\n$$\n\n2. Tridiagonal compact fourth-order finite difference for the second derivative (Padé-type), defined implicitly by\n$$\n\\alpha\\, \\psi^{\\prime\\prime}_{j-1} \\;+\\; \\psi^{\\prime\\prime}_{j} \\;+\\; \\alpha\\, \\psi^{\\prime\\prime}_{j+1}\n\\;=\\;\n\\frac{a}{h^{2}}\\left(\\psi_{j-1} - 2 \\psi_{j} + \\psi_{j+1}\\right)\n\\quad\\text{with}\\quad \\alpha = \\frac{1}{10},\\;\\; a = \\frac{6}{5}\\,,\n$$\nso that $\\psi^{\\prime\\prime}_{j}$ approximates $\\left[\\nabla^{2}\\psi\\right]_{j}$.\n\n3. Pseudospectral Fourier Laplacian on the periodic grid, which yields the exact eigenvalue $-k^{2}$ for any grid-resolved Fourier mode.\n\nFor each discretization, define the discrete modified wavenumber $k_{\\text{num}}$ via the discrete Laplacian eigenvalue acting on the plane wave $\\psi_{j} = \\exp(i j \\theta)$ as $-\\left(k_{\\text{num}}\\right)^{2}$. The corresponding numerical angular frequency is\n$$\n\\omega_{\\text{num}}(k) \\;=\\; \\frac{\\hbar \\left(k_{\\text{num}}\\right)^{2}}{2 m} \\,,\n$$\nand the numerical phase velocity is $v_{p,\\text{num}}(k) = \\omega_{\\text{num}}(k)/k$.\n\nStarting from these definitions and the discrete operators above, derive the closed-form expressions for the relative dispersion error\n$$\n\\varepsilon(\\theta) \\;=\\; \\frac{\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)}{\\omega_{\\text{exact}}(k)} \\;=\\; \\frac{\\left(k_{\\text{num}}\\right)^{2} - k^{2}}{k^{2}}\n$$\nfor the three schemes in terms of the grid-phase $\\theta$. Express your final answer as a single row matrix containing $\\varepsilon_{\\text{cen}}(\\theta)$, $\\varepsilon_{\\text{comp}}(\\theta)$, and $\\varepsilon_{\\text{spec}}(\\theta)$, respectively, in simplified closed form. No numerical evaluation is required, and no units should be included in the final expressions.",
            "solution": "The user has provided a problem statement that requires formal validation before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Governing Equation**: Free Schrödinger equation, $i \\hbar \\,\\frac{\\partial \\psi}{\\partial t} = -\\,\\frac{\\hbar^{2}}{2 m}\\,\\nabla^{2}\\psi$.\n- **Domain**: One-dimensional periodic domain of length $L$, discretized with $N$ points, grid spacing $h = L/N$.\n- **Test Function**: Plane-wave mode, $\\psi_j = \\exp(i j \\theta)$, where $k = 2\\pi n/L$ (integer $n$) and $\\theta = k h$.\n- **Exact Dispersion Relation**: $\\omega_{\\text{exact}}(k) = \\frac{\\hbar k^{2}}{2 m}$.\n- **Numerical Dispersion Relation**: $\\omega_{\\text{num}}(k) = \\frac{\\hbar \\left(k_{\\text{num}}\\right)^{2}}{2 m}$. The quantity $-\\left(k_{\\text{num}}\\right)^{2}$ is the eigenvalue of the discrete Laplacian operator for the mode $\\exp(i j \\theta)$.\n- **Dispersion Error**: $\\varepsilon(\\theta) = \\frac{\\left(k_{\\text{num}}\\right)^{2} - k^{2}}{k^{2}}$.\n- **Scheme 1 (Centered 2nd-order)**: $\\left[\\nabla^{2}\\psi\\right]_{j} = \\frac{\\psi_{j+1} - 2 \\psi_{j} + \\psi_{j-1}}{h^{2}}$.\n- **Scheme 2 (Compact 4th-order)**: $\\alpha\\, \\psi^{\\prime\\prime}_{j-1} + \\psi^{\\prime\\prime}_{j} + \\alpha\\, \\psi^{\\prime\\prime}_{j+1} = \\frac{a}{h^{2}}\\left(\\psi_{j-1} - 2 \\psi_{j} + \\psi_{j+1}\\right)$, with $\\alpha = \\frac{1}{10}$ and $a = \\frac{6}{5}$.\n- **Scheme 3 (Pseudospectral)**: Yields the exact eigenvalue $-k^{2}$ for any grid-resolved Fourier mode.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria:\n- **Scientifically Grounded**: The problem is rooted in the standard numerical analysis of partial differential equations, specifically the Schrödinger equation. The methods described (finite difference, compact finite difference, pseudospectral) are canonical techniques in computational physics. The application to fuzzy dark matter is a recognized topic in numerical cosmology. The problem is scientifically and mathematically sound.\n- **Well-Posed**: All necessary definitions, equations, and parameters are provided. The task is to derive specific analytical expressions, for which a unique solution exists based on the givens.\n- **Objective**: The problem is stated using precise, unambiguous mathematical and technical language. It is free from subjective or opinion-based content.\n\nThe problem statement does not exhibit any of the flaws listed in the invalidity checklist. It is a complete, consistent, and formalizable problem in applied mathematics and computational physics.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nThe central task is to determine the relative dispersion error, $\\varepsilon(\\theta)$, for each of the three numerical schemes. The definition of the error is given by:\n$$\n\\varepsilon(\\theta) = \\frac{\\omega_{\\text{num}}(k) - \\omega_{\\text{exact}}(k)}{\\omega_{\\text{exact}}(k)} = \\frac{\\left(k_{\\text{num}}\\right)^{2} - k^{2}}{k^{2}} = \\frac{\\left(k_{\\text{num}}\\right)^{2}}{k^{2}} - 1\n$$\nTo find $\\varepsilon(\\theta)$, we must find the expression for the squared modified wavenumber, $\\left(k_{\\text{num}}\\right)^{2}$, for each scheme. By definition, $-\\left(k_{\\text{num}}\\right)^{2}$ is the eigenvalue of the discrete Laplacian operator when acting on a plane wave. Let the discrete Laplacian operator be denoted by $\\hat{\\nabla}^{2}$. For a plane-wave mode $\\psi_{j} = \\exp(i j k h) = \\exp(i j \\theta)$, its action is given by:\n$$\n\\hat{\\nabla}^{2} \\psi_{j} = -\\left(k_{\\text{num}}\\right)^{2} \\psi_{j}\n$$\nWe will analyze the action of each discrete operator on $\\psi_{j} = \\exp(i j \\theta)$, noting that $\\psi_{j\\pm 1} = \\psi_{j} \\exp(\\pm i \\theta)$. We also use the relation $k = \\theta/h$.\n\n**1. Centered Second-Order Finite Difference ($\\varepsilon_{\\text{cen}}(\\theta)$)**\n\nThe discrete Laplacian is given by:\n$$\n\\left[\\hat{\\nabla}^{2}\\psi\\right]_{j} = \\frac{\\psi_{j+1} - 2 \\psi_{j} + \\psi_{j-1}}{h^{2}}\n$$\nApplying this operator to $\\psi_j = \\exp(i j \\theta)$:\n$$\n\\left[\\hat{\\nabla}^{2}\\psi\\right]_{j} = \\frac{\\exp(i \\theta) \\psi_{j} - 2 \\psi_{j} + \\exp(-i \\theta) \\psi_{j}}{h^{2}} = \\frac{\\psi_j}{h^2} \\left( \\exp(i \\theta) + \\exp(-i \\theta) - 2 \\right)\n$$\nUsing the identity $2\\cos(\\theta) = \\exp(i \\theta) + \\exp(-i \\theta)$, we get:\n$$\n\\left[\\hat{\\nabla}^{2}\\psi\\right]_{j} = \\frac{\\psi_j}{h^2} \\left( 2\\cos(\\theta) - 2 \\right) = \\frac{2\\left(\\cos(\\theta) - 1\\right)}{h^2} \\psi_j\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$:\n$$\n\\left[\\hat{\\nabla}^{2}\\psi\\right]_{j} = \\frac{-4\\sin^{2}(\\theta/2)}{h^{2}} \\psi_j\n$$\nThe eigenvalue is $-\\frac{4\\sin^{2}(\\theta/2)}{h^{2}}$. By definition, this is $-\\left(k_{\\text{num, cen}}\\right)^{2}$.\n$$\n\\left(k_{\\text{num, cen}}\\right)^{2} = \\frac{4\\sin^{2}(\\theta/2)}{h^{2}}\n$$\nThe relative dispersion error is then:\n$$\n\\varepsilon_{\\text{cen}}(\\theta) = \\frac{\\left(k_{\\text{num, cen}}\\right)^{2}}{k^{2}} - 1 = \\frac{4\\sin^{2}(\\theta/2)/h^{2}}{(\\theta/h)^{2}} - 1 = \\frac{4\\sin^{2}(\\theta/2)}{\\theta^{2}} - 1\n$$\n\n**2. Compact Fourth-Order Finite Difference ($\\varepsilon_{\\text{comp}}(\\theta)$)**\n\nThe scheme is defined implicitly:\n$$\n\\alpha\\, \\psi^{\\prime\\prime}_{j-1} \\;+\\; \\psi^{\\prime\\prime}_{j} \\;+\\; \\alpha\\, \\psi^{\\prime\\prime}_{j+1} \\;=\\; \\frac{a}{h^{2}}\\left(\\psi_{j-1} - 2 \\psi_{j} + \\psi_{j+1}\\right)\n$$\nwhere $\\psi^{\\prime\\prime}_{j}$ is the numerical approximation to the second derivative. For a plane wave, $\\psi^{\\prime\\prime}_{j} = -\\left(k_{\\text{num, comp}}\\right)^{2} \\psi_j$. Therefore, $\\psi^{\\prime\\prime}_{j\\pm 1} = -\\left(k_{\\text{num, comp}}\\right)^{2} \\psi_{j\\pm 1} = -\\left(k_{\\text{num, comp}}\\right)^{2} \\psi_j \\exp(\\pm i\\theta)$.\nSubstituting into the left-hand side (LHS):\n$$\n\\text{LHS} = -\\left(k_{\\text{num, comp}}\\right)^{2} \\psi_j \\left( \\alpha \\exp(-i\\theta) + 1 + \\alpha \\exp(i\\theta) \\right) = -\\left(k_{\\text{num, comp}}\\right)^{2} \\psi_j \\left( 1 + 2\\alpha\\cos(\\theta) \\right)\n$$\nThe right-hand side (RHS) is identical in form to the centered difference operator, scaled by $a$:\n$$\n\\text{RHS} = \\frac{a}{h^{2}}\\left(\\psi_j \\exp(-i\\theta) - 2\\psi_j + \\psi_j \\exp(i\\theta) \\right) = \\frac{a\\psi_j}{h^2}\\left(2\\cos(\\theta)-2\\right)\n$$\nEquating LHS and RHS and canceling $\\psi_j$:\n$$\n-\\left(k_{\\text{num, comp}}\\right)^{2} \\left( 1 + 2\\alpha\\cos(\\theta) \\right) = \\frac{a}{h^{2}} \\left(2\\cos(\\theta)-2\\right)\n$$\nSolving for $\\left(k_{\\text{num, comp}}\\right)^{2}$:\n$$\n\\left(k_{\\text{num, comp}}\\right)^{2} = - \\frac{2a\\left(\\cos(\\theta)-1\\right)}{h^{2}\\left(1 + 2\\alpha\\cos(\\theta)\\right)} = \\frac{2a\\left(1-\\cos(\\theta)\\right)}{h^{2}\\left(1 + 2\\alpha\\cos(\\theta)\\right)}\n$$\nSubstitute the given values $\\alpha = 1/10$ and $a = 6/5$:\n$$\n\\left(k_{\\text{num, comp}}\\right)^{2} = \\frac{2(6/5)\\left(1-\\cos(\\theta)\\right)}{h^{2}\\left(1 + 2(1/10)\\cos(\\theta)\\right)} = \\frac{(12/5)\\left(1-\\cos(\\theta)\\right)}{h^{2}\\left(1 + (1/5)\\cos(\\theta)\\right)} = \\frac{12\\left(1-\\cos(\\theta)\\right)}{h^{2}\\left(5 + \\cos(\\theta)\\right)}\n$$\nUsing the identity $1-\\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$\n\\left(k_{\\text{num, comp}}\\right)^{2} = \\frac{24\\sin^{2}(\\theta/2)}{h^{2}\\left(5 + \\cos(\\theta)\\right)}\n$$\nThe relative dispersion error is:\n$$\n\\varepsilon_{\\text{comp}}(\\theta) = \\frac{\\left(k_{\\text{num, comp}}\\right)^{2}}{k^{2}} - 1 = \\frac{24\\sin^{2}(\\theta/2)}{h^{2}\\left(5 + \\cos(\\theta)\\right)} \\frac{1}{(\\theta/h)^2} - 1 = \\frac{24\\sin^{2}(\\theta/2)}{\\theta^{2}\\left(5 + \\cos(\\theta)\\right)} - 1\n$$\n\n**3. Pseudospectral Fourier Laplacian ($\\varepsilon_{\\text{spec}}(\\theta)$)**\n\nThe problem states that for a grid-resolved Fourier mode, the pseudospectral Laplacian yields the exact eigenvalue, which is $-k^{2}$. A plane wave $\\psi_j = \\exp(ijkh)$ with $k=2\\pi n/L$ is such a mode.\nTherefore, the action of the pseudospectral operator $\\hat{\\nabla}^2_{\\text{spec}}$ on $\\psi_j$ is:\n$$\n\\hat{\\nabla}^2_{\\text{spec}} \\psi_j = -k^2 \\psi_j\n$$\nBy definition, the eigenvalue is also $-\\left(k_{\\text{num, spec}}\\right)^2$. Thus, we have:\n$$\n-\\left(k_{\\text{num, spec}}\\right)^2 = -k^2 \\quad \\implies \\quad \\left(k_{\\text{num, spec}}\\right)^2 = k^2\n$$\nThe relative dispersion error is:\n$$\n\\varepsilon_{\\text{spec}}(\\theta) = \\frac{\\left(k_{\\text{num, spec}}\\right)^{2} - k^{2}}{k^{2}} = \\frac{k^{2} - k^{2}}{k^{2}} = 0\n$$\nThis holds for any non-zero wavenumber $k$. If $k=0$, the mode is constant, and both $\\omega_{\\text{exact}}$ and $\\omega_{\\text{num}}$ are zero, making the relative error undefined as $0/0$. However, the limit is $0$, and for any dispersive analysis, we consider $k \\neq 0$.\n\n**Conclusion**\n\nThe closed-form expressions for the relative dispersion error for the three schemes are:\n- $\\varepsilon_{\\text{cen}}(\\theta) = \\frac{4\\sin^{2}(\\theta/2)}{\\theta^{2}} - 1$\n- $\\varepsilon_{\\text{comp}}(\\theta) = \\frac{24\\sin^{2}(\\theta/2)}{\\theta^{2}(5+\\cos\\theta)} - 1$\n- $\\varepsilon_{\\text{spec}}(\\theta) = 0$\n\nThese results are to be provided in a single row matrix.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{4\\sin^{2}(\\theta/2)}{\\theta^{2}} - 1  \\frac{24\\sin^{2}(\\theta/2)}{\\theta^{2}(5+\\cos\\theta)} - 1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "A robust numerical code must respect the fundamental symmetries of the physics it models, and verifying these symmetries is a powerful way to debug your implementation. This practice provides a crucial \"sanity check\" by testing the global U(1) gauge invariance of the Schrödinger-Poisson system. You will implement core diagnostic tools and confirm numerically that physical observables, namely the mass density $\\rho$ and total energy $E$, remain unchanged by a global phase rotation of the wavefunction $\\psi$. ",
            "id": "3485499",
            "problem": "You are tasked with verifying the global phase invariance of a two-dimensional periodic Schrödinger–Poisson diagnostic used for modeling fuzzy or ultralight dark matter. Work entirely in dimensionless code units where the reduced Planck constant $\\,\\hbar\\,$, particle mass $\\,m\\,$, gravitational constant $\\,G\\,$, and box side length $\\,L\\,$ are all set to $\\,1\\,$. Angles must be specified in radians.\n\nFundamental base and definitions to use:\n- The Schrödinger–Poisson system couples a complex scalar field $\\,\\psi(\\mathbf{x},t)\\,$ to the Newtonian gravitational potential $\\,\\Phi(\\mathbf{x},t)\\,$ through the mass density $\\,\\rho(\\mathbf{x},t) = m|\\psi(\\mathbf{x},t)|^2\\,$ and the Poisson equation.\n- The density is $\\,\\rho = m|\\psi|^2\\,$.\n- The gravitational potential $\\,\\Phi\\,$ satisfies the Poisson equation $\\,\\nabla^2 \\Phi = 4\\pi G (\\rho - \\overline{\\rho})\\,$ on a periodic domain of side length $\\,L\\,$, where $\\,\\overline{\\rho}\\,$ denotes the spatial mean of $\\,\\rho\\,$. The subtraction of $\\,\\overline{\\rho}\\,$ enforces zero mean to make the Fourier solution well-defined under periodic boundary conditions.\n- The kinetic energy functional is $\\,T = \\dfrac{\\hbar^2}{2m} \\int |\\nabla \\psi|^2 \\, d^2x\\,$.\n- The gravitational potential energy is $\\,U = \\dfrac{1}{2}\\int \\rho \\, \\Phi \\, d^2x\\,$.\n- The total energy is $\\,E = T + U\\,$.\n\nGlobal phase invariance states that applying the transformation $\\,\\psi \\to e^{i\\theta}\\psi\\,$ with constant $\\,\\theta\\,$ leaves all physical diagnostics unchanged, including $\\,\\rho\\,$ and $\\,E\\,$.\n\nImplementation requirements:\n- Use a two-dimensional periodic square domain of side length $\\,L=1\\,$ with a uniform grid of $\\,N\\times N\\,$ points for some integer $\\,N\\,$. Use $\\,N=64\\,$.\n- Construct a deterministic initial complex field $\\,\\psi(x,y)\\,$ on the grid by superposing smooth, nontrivial components so that $\\,\\psi\\,$ is neither purely real nor spatially uniform. For instance, combine a localized Gaussian envelope with a plane-wave phase and an additional plane wave plus a small constant offset; ensure that the field varies in both $\\,x\\,$ and $\\,y\\,$ and has nonzero complex phase everywhere.\n- Compute spatial derivatives and the solution to the Poisson equation spectrally using Fourier transforms. For the Poisson equation, set the zero mode of the potential to zero and use $\\,\\Phi_{\\mathbf{k}} = -\\dfrac{4\\pi G}{|\\mathbf{k}|^2}\\,\\rho_{\\mathbf{k}}\\,$ for nonzero wavevectors $\\,\\mathbf{k}\\,$, with $\\,\\rho\\,$ replaced by $\\,\\rho - \\overline{\\rho}\\,$ before transforming. For gradients, use $\\,\\partial_x \\psi \\leftrightarrow i k_x \\hat{\\psi}\\,$ and $\\,\\partial_y \\psi \\leftrightarrow i k_y \\hat{\\psi}\\,$ in Fourier space.\n- Compute diagnostics for the original field and for the globally phase-rotated field $\\,\\psi' = e^{i\\theta}\\psi\\,$: the density $\\,\\rho\\,$ and the total energy $\\,E\\,$.\n- Use the absolute maximum norm for field comparisons, i.e., check $\\,\\max_{x,y}|\\rho'(x,y)-\\rho(x,y)|\\,$.\n- Use a uniform numerical tolerance of $\\,10^{-11}\\,$ for both the density comparison and the total energy comparison.\n\nTest suite:\nApply five different angles $\\,\\theta\\,$ to test different facets of invariance and numerical behavior. Angles must be in radians.\n1. $\\,\\theta = 0\\,$ (boundary case).\n2. $\\,\\theta = \\pi/3\\,$ (generic case).\n3. $\\,\\theta = \\pi\\,$ (sign flip of the complex field).\n4. $\\,\\theta = 2\\pi\\,$ (periodicity of the phase).\n5. $\\,\\theta = 10^{-8}\\,$ (small-angle edge case).\n\nFor each test case, return a boolean indicating whether both conditions hold within tolerance:\n- $\\,\\max_{x,y}|\\rho'(x,y)-\\rho(x,y)| \\le 10^{-11}\\,$.\n- $\\,|E' - E| \\le 10^{-11}\\,$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, \"[True,True,False,True,True]\". The order must correspond to the test suite angles listed above. No external input is allowed, and all computations must be performed in dimensionless units as specified.",
            "solution": "The problem requires the verification of the global phase invariance of physical diagnostics derived from the two-dimensional Schrödinger-Poisson system. This principle, a cornerstone of quantum mechanics, posits that a global phase transformation of the wavefunction, $\\psi \\to \\psi' = e^{i\\theta}\\psi$ for a real constant phase angle $\\theta$, leaves all physical observables unchanged. We will first demonstrate this invariance analytically for the specified diagnostics and then outline the numerical procedure to verify it within a given tolerance.\n\nThe dimensionless units are $\\hbar=1$, $m=1$, $G=1$, and the side length of the periodic domain is $L=1$.\n\n**1. Analytical Invariance**\n\nWe must show that the mass density $\\rho$ and the total energy $E$ are invariant under the transformation $\\psi' = e^{i\\theta}\\psi$.\n\n**a. Mass Density ($\\rho$)**\nThe mass density is defined as $\\rho = m|\\psi|^2$. For the transformed wavefunction $\\psi'$, the new density $\\rho'$ is:\n$$\n\\rho' = m|\\psi'|^2 = m|e^{i\\theta}\\psi|^2\n$$\nUsing the property of complex numbers $|z_1 z_2| = |z_1| |z_2|$, we have:\n$$\n\\rho' = m|e^{i\\theta}|^2 |\\psi|^2\n$$\nSince $\\theta$ is a real number, $|e^{i\\theta}|^2 = |\\cos\\theta + i\\sin\\theta|^2 = \\cos^2\\theta + \\sin^2\\theta = 1$. Therefore,\n$$\n\\rho' = m(1)|\\psi|^2 = m|\\psi|^2 = \\rho\n$$\nThe mass density $\\rho$ is analytically invariant under a global phase rotation.\n\n**b. Total Energy ($E$)**\nThe total energy is the sum of the kinetic energy $T$ and the gravitational potential energy $U$, i.e., $E = T + U$. We examine each term separately.\n\n**i. Gravitational Potential Energy ($U$)**\nThe potential energy is $U = \\frac{1}{2}\\int \\rho \\Phi \\, d^2x$. The potential $\\Phi$ is determined by the Poisson equation on a periodic domain: $\\nabla^2 \\Phi = 4\\pi G (\\rho - \\overline{\\rho})$, where $\\overline{\\rho}$ is the spatial average of $\\rho$. As shown above, $\\rho'=\\rho$. Consequently, the spatial average is also unchanged: $\\overline{\\rho'} = \\overline{\\rho}$. The source term for the Poisson equation, $(\\rho - \\overline{\\rho})$, remains the same. With identical source terms and boundary conditions (here, handled by setting the zero-frequency mode $\\Phi_{\\mathbf{k}=0}$ to zero), the solution for the potential must also be the same. Thus, $\\Phi' = \\Phi$.\n\nThe potential energy for the transformed system is:\n$$\nU' = \\frac{1}{2}\\int \\rho' \\Phi' \\, d^2x = \\frac{1}{2}\\int \\rho \\Phi \\, d^2x = U\n$$\nThe gravitational potential energy is therefore invariant.\n\n**ii. Kinetic Energy ($T$)**\nThe kinetic energy is defined as $T = \\frac{\\hbar^2}{2m} \\int |\\nabla \\psi|^2 \\, d^2x$. For the transformed field $\\psi'$, the gradient is:\n$$\n\\nabla \\psi' = \\nabla (e^{i\\theta}\\psi)\n$$\nSince $\\theta$ is a spatial constant, the exponential factor can be pulled out of the derivative:\n$$\n\\nabla \\psi' = e^{i\\theta} (\\nabla \\psi)\n$$\nThe squared magnitude of the gradient is then:\n$$\n|\\nabla \\psi'|^2 = |e^{i\\theta} (\\nabla \\psi)|^2 = |e^{i\\theta}|^2 |\\nabla \\psi|^2 = (1) |\\nabla \\psi|^2 = |\\nabla \\psi|^2\n$$\nThe integrand of the kinetic energy functional is identical. Thus, the kinetic energy is invariant:\n$$\nT' = \\frac{\\hbar^2}{2m} \\int |\\nabla \\psi'|^2 \\, d^2x = \\frac{\\hbar^2}{2m} \\int |\\nabla \\psi|^2 \\, d^2x = T\n$$\n\n**iii. Total Energy ($E$)**\nSince both kinetic and potential energy components are invariant ($T'=T$ and $U'=U$), their sum, the total energy, must also be invariant:\n$$\nE' = T' + U' = T + U = E\n$$\nThis completes the analytical proof of invariance. The numerical task is to verify that a correct implementation of the diagnostic tools respects this fundamental symmetry up to floating-point precision.\n\n**2. Numerical Implementation Strategy**\n\nThe verification will be performed on a uniform Cartesian grid of size $N \\times N$ with $N=64$ on a domain of side length $L=1$. The grid spacing is $\\Delta x = \\Delta y = L/N$.\n\n**a. Initial State Construction**\nAn initial complex field $\\psi(x, y)$ is constructed to be non-trivial, ensuring it is not purely real or spatially uniform, thereby providing a robust test case. A superposition of a localized Gaussian, plane waves, and a constant offset is suitable:\n$$\n\\psi(x,y) = A_1 e^{-r^2/(2\\sigma^2)} e^{i(k_{x1}x + k_{y1}y)} + A_2 e^{i(k_{x2}x + k_{y2}y)} + C\n$$\nwhere $r^2 = (x-x_c)^2 + (y-y_c)^2$ for some center $(x_c, y_c)$. This form ensures the field has varying amplitude and phase across the domain.\n\n**b. Diagnostic Computations (Spectral Methods)**\nAll spatial derivatives and the Poisson equation are handled in Fourier space for accuracy and to correctly implement periodic boundary conditions.\n\n- **Grid and Frequencies**: We define spatial coordinates $x_j=j\\Delta x, y_l=l\\Delta y$ and the corresponding angular wavevectors $k_x, k_y$ using the `fftfreq` function, scaled by $2\\pi$: $k_{x,n} = 2\\pi n / L$ for integer mode numbers $n$.\n- **Density $\\rho$**: Computed directly in real space: $\\rho_{j,l} = m|\\psi_{j,l}|^2$.\n- **Potential $\\Phi$**:\n    1. Compute the source term $S(x,y) = \\rho(x,y) - \\overline{\\rho}$, where $\\overline{\\rho} = \\frac{1}{N^2}\\sum_{j,l} \\rho_{j,l}$.\n    2. Compute the 2D Fast Fourier Transform (FFT) of the source term: $S_{\\mathbf{k}} = \\mathcal{F}[S]$.\n    3. Solve for the potential in Fourier space: $\\Phi_{\\mathbf{k}} = -\\frac{4\\pi G}{|\\mathbf{k}|^2} S_{\\mathbf{k}}$ for $\\mathbf{k} \\neq \\mathbf{0}$. The $|\\mathbf{k}|^2$ term is $k_x^2 + k_y^2$. The zero-frequency mode is set to zero, $\\Phi_{\\mathbf{k}=\\mathbf{0}}=0$, to satisfy the problem's requirements and resolve the singularity.\n    4. Compute the inverse 2D FFT to obtain the real-space potential: $\\Phi(x,y) = \\mathcal{F}^{-1}[\\Phi_{\\mathbf{k}}]$.\n- **Kinetic Energy $T$**:\n    1. Compute the FFT of the wavefunction: $\\psi_{\\mathbf{k}} = \\mathcal{F}[\\psi]$.\n    2. Compute the Fourier transforms of the spatial derivatives by multiplying by $i\\mathbf{k}$: $(\\partial_x\\psi)_{\\mathbf{k}} = ik_x \\psi_{\\mathbf{k}}$ and $(\\partial_y\\psi)_{\\mathbf{k}} = ik_y \\psi_{\\mathbf{k}}$.\n    3. Compute the inverse FFTs to get the real-space gradients: $\\partial_x\\psi = \\mathcal{F}^{-1}[ik_x \\psi_{\\mathbf{k}}]$ and $\\partial_y\\psi = \\mathcal{F}^{-1}[ik_y \\psi_{\\mathbf{k}}]$.\n    4. Calculate the kinetic energy integrand in real space: $|\\nabla\\psi|^2 = |\\partial_x\\psi|^2 + |\\partial_y\\psi|^2$.\n    5. Numerically integrate over the domain: $T = \\frac{\\hbar^2}{2m} \\sum_{j,l} |\\nabla\\psi|^2_{j,l} (\\Delta x)^2$.\n- **Potential Energy $U$**: Numerically integrate in real space: $U = \\frac{1}{2} \\sum_{j,l} \\rho_{j,l} \\Phi_{j,l} (\\Delta x)^2$.\n- **Total Energy $E$**: $E=T+U$.\n\n**c. Verification Procedure**\nFor each angle $\\theta$ in the test suite, we perform the following steps:\n1.  Calculate the reference diagnostics $(\\rho, E)$ for the initial field $\\psi$.\n2.  Construct the rotated field $\\psi' = \\psi \\cdot e^{i\\theta}$.\n3.  Calculate the new diagnostics $(\\rho', E')$ for the field $\\psi'$.\n4.  Compute the maximum absolute difference for the density field: $\\Delta\\rho = \\max|\\rho' - \\rho|$.\n5.  Compute the absolute difference for the total energy: $\\Delta E = |E' - E|$.\n6.  A test case passes if both $\\Delta\\rho \\le 10^{-11}$ and $\\Delta E \\le 10^{-11}$.\n\nThis procedure rigorously tests whether the numerical implementation of the diagnostics adheres to the fundamental physical principle of global phase invariance, with differences only arising from finite-precision floating-point arithmetic. The choice of angles, including $0$, $2\\pi$, a small value, and a generic value, ensures the test is robust.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the global phase invariance of Schrödinger-Poisson diagnostics.\n    \"\"\"\n    # Define constants in dimensionless code units\n    N = 64\n    L = 1.0\n    hbar = 1.0\n    m = 1.0\n    G = 1.0\n    TOLERANCE = 1e-11\n\n    # Define spatial grid and Fourier space wavenumbers\n    x = np.linspace(0, L, N, endpoint=False)\n    dx = L / N\n    \n    # Angular wavenumbers\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    \n    X, Y = np.meshgrid(x, x, indexing='ij')\n    Kx, Ky = np.meshgrid(k, k, indexing='ij')\n    K_squared = Kx**2 + Ky**2\n\n    # Construct a non-trivial initial wavefunction psi(x, y)\n    # This combines a localized Gaussian, two plane waves, and a constant offset.\n    r_squared = (X - L / 4)**2 + (Y - L / 4)**2\n    sigma = L / 10\n    gaussian_component = 0.5 * np.exp(-r_squared / (2 * sigma**2))\n    \n    # Plane waves with integer mode numbers (nx, ny)\n    # exp(i * (k_x*x + k_y*y)) = exp(i * 2*pi/L * (nx*x + ny*y))\n    plane_wave_1 = np.exp(1j * 2 * np.pi / L * (1 * X + 2 * Y))\n    plane_wave_2 = 0.2 * np.exp(1j * 2 * np.pi / L * (4 * X - 3 * Y))\n    \n    psi_initial = gaussian_component * plane_wave_1 + plane_wave_2 + 0.01\n\n    def compute_diagnostics(psi):\n        \"\"\"\n        Computes the density (rho) and total energy (E) for a given wavefunction.\n        \"\"\"\n        # Mass density\n        rho = m * np.abs(psi)**2\n        \n        # --- Gravitational Potential Energy (U) ---\n        # Source for Poisson equation: rho - rho_mean\n        rho_mean = np.mean(rho)\n        rho_src = rho - rho_mean\n        \n        # Solve Poisson equation in Fourier space\n        rho_src_k = np.fft.fftn(rho_src)\n        \n        # Avoid division by zero at k=0\n        # The value at this index does not matter as rho_src_k[0, 0] is zero\n        # but we set it to 1 for numerical stability.\n        K_squared_no_zero = K_squared.copy()\n        if K_squared_no_zero[0, 0] == 0:\n            K_squared_no_zero[0, 0] = 1.0\n\n        phi_k = -4 * np.pi * G * rho_src_k / K_squared_no_zero\n        # Explicitly set the zero-mode of the potential to zero\n        phi_k[0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space. It must be real.\n        phi = np.fft.ifftn(phi_k).real\n\n        # Potential energy\n        dV = dx**2\n        potential_energy_U = 0.5 * np.sum(rho * phi) * dV\n\n        # --- Kinetic Energy (T) ---\n        psi_k = np.fft.fftn(psi)\n        \n        # Gradients in Fourier space\n        grad_psi_x_k = 1j * Kx * psi_k\n        grad_psi_y_k = 1j * Ky * psi_k\n        \n        # Gradients in real space\n        grad_psi_x = np.fft.ifftn(grad_psi_x_k)\n        grad_psi_y = np.fft.ifftn(grad_psi_y_k)\n        \n        # Kinetic energy integrand\n        grad_psi_sq = np.abs(grad_psi_x)**2 + np.abs(grad_psi_y)**2\n        \n        # Kinetic energy\n        kinetic_energy_T = (hbar**2 / (2 * m)) * np.sum(grad_psi_sq) * dV\n        \n        # Total energy\n        total_energy_E = kinetic_energy_T + potential_energy_U\n        \n        return rho, total_energy_E\n\n    # Compute reference diagnostics for the original field\n    rho_ref, E_ref = compute_diagnostics(psi_initial)\n\n    # Test suite angles in radians\n    test_angles = [\n        0.0,\n        np.pi / 3,\n        np.pi,\n        2 * np.pi,\n        1e-8\n    ]\n\n    results = []\n    for theta in test_angles:\n        # Apply global phase rotation\n        psi_prime = psi_initial * np.exp(1j * theta)\n        \n        # Compute diagnostics for the rotated field\n        rho_prime, E_prime = compute_diagnostics(psi_prime)\n        \n        # Compare diagnostics against the reference\n        max_rho_diff = np.max(np.abs(rho_prime - rho_ref))\n        abs_E_diff = np.abs(E_prime - E_ref)\n        \n        # Check if both differences are within tolerance\n        is_invariant = (max_rho_diff = TOLERANCE) and (abs_E_diff = TOLERANCE)\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After verifying static properties, the next step is to validate the full dynamics of the solver. A correct implementation of the Schrödinger equation must be independent of the observer's inertial frame of reference, a principle known as Galilean invariance. This exercise challenges you to implement a full time-stepping solver and test this symmetry by showing that a boosted wavepacket propagates at the theoretically predicted velocity without changing its internal structure, providing a non-trivial validation of the entire evolution algorithm. ",
            "id": "3485529",
            "problem": "Consider the one-dimensional Schrödinger–Poisson system for fuzzy or ultralight dark matter in a periodic domain of length $L$:\n$$\ni\\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; m\\,\\phi(x,t)\\,\\psi(x,t),\n$$\ncoupled to the Poisson equation for the Newtonian gravitational potential,\n$$\n\\frac{\\partial^2 \\phi(x,t)}{\\partial x^2} \\;=\\; 4\\pi G\\left(\\rho(x,t) - \\overline{\\rho}\\right),\n$$\nwith mass density $\\rho(x,t)=|\\psi(x,t)|^2$ and spatial mean $\\overline{\\rho}=\\frac{1}{L}\\int_0^L \\rho(x,t)\\,dx$. Assume periodic boundary conditions and adopt dimensionless code units such that $\\hbar=1$, $m=1$, and write $4\\pi G$ as a dimensionless coupling constant $\\gamma$.\n\nThe Galilean boost symmetry of the Schrödinger equation implies that multiplying an initial wavefunction by a plane-wave phase factor $e^{i k x}$ adds a uniform velocity field, without changing the initial density. In the Madelung representation, writing $\\psi(x,t)=\\sqrt{\\rho(x,t)}\\,e^{i S(x,t)}$, the velocity field is $v(x,t)=\\frac{\\hbar}{m}\\,\\frac{\\partial S}{\\partial x}$ and the local current is $j(x,t)=\\frac{\\hbar}{m}\\,\\mathrm{Im}\\left(\\psi^*(x,t)\\,\\frac{\\partial \\psi(x,t)}{\\partial x}\\right)$. When applying the boost $\\psi\\to e^{i k x}\\psi$ to an initially real and positive $\\psi$, the expected uniform velocity is $v=\\frac{\\hbar}{m}k$.\n\nYour task is to implement a numerical solver for the above system on a uniform grid using a Strang split-step method:\n- Advance the wavefunction by a half time-step using the potential term $e^{-i(m/\\hbar)\\phi\\,\\Delta t/2}$ in configuration space.\n- Advance by a full time-step using the kinetic term $e^{-i(\\hbar k^2/2m)\\,\\Delta t}$ in Fourier space, where $k$ is the wavenumber.\n- Advance again by a half time-step with the updated potential.\nAt each step, compute $\\phi$ by solving the Poisson equation in Fourier space:\n$$\n\\widehat{\\phi}(k) \\;=\\; -\\frac{\\gamma}{k^2}\\,\\widehat{\\rho - \\overline{\\rho}}\\,(k) \\quad \\text{for } k\\neq 0, \\quad \\widehat{\\phi}(0)=0,\n$$\nwhere hats denote Fourier transforms. Use the periodic Fourier derivative $\\frac{\\partial \\psi}{\\partial x}$ computed spectrally for velocity extraction.\n\nYou must test the Galilean boost numerically by:\n1. Initializing a normalized Gaussian wavefunction,\n$$\n\\psi_0(x) = A\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right),\n$$\nwith $A$ chosen so that $\\int_0^L |\\psi_0(x)|^2\\,dx = 1$, and $x_0=L/2$.\n2. Creating a boosted initial condition $\\psi_b(x,0) = e^{i k x}\\,\\psi_0(x)$ with $k=\\frac{2\\pi n}{L}$ for integer $n$.\n3. Evolving both the unboosted and boosted initial conditions to a common final time $T$ using the same parameters.\n4. Computing the mass-weighted mean velocity extracted from the boosted initial condition,\n$$\n\\overline{v} \\;=\\; \\frac{\\int_0^L \\rho(x,0)\\,v(x,0)\\,dx}{\\int_0^L \\rho(x,0)\\,dx} \\;=\\; \\frac{\\int_0^L j(x,0)\\,dx}{\\int_0^L \\rho(x,0)\\,dx},\n$$\nand comparing it to the theoretical $v=\\frac{\\hbar}{m}k$.\n5. Verifying frame invariance of the dynamics by comparing the boosted density $\\rho_b(x,t)$ to a spatially shifted version of the unboosted density $\\rho_0(x-vt,t)$, where the shift is taken modulo $L$ using the Fourier shift theorem. Quantify the discrepancy using the relative $L^2$ error:\n$$\n\\epsilon(t) \\;=\\; \\frac{\\left\\|\\rho_b(x,t) - \\rho_0(x-vt,t)\\right\\|_{L^2}}{\\left\\|\\rho_0(x,t)\\right\\|_{L^2}}.\n$$\nReport the maximum error over several snapshots in time.\n\nAll quantities are dimensionless in these code units, so no physical units are required in the output. Angles are implicitly in radians due to the use of Fourier transforms.\n\nImplement your program to run the following test suite, where each test case is a tuple specifying $(N, L, \\Delta t, \\text{steps}, n, \\sigma, \\gamma)$:\n- Case 1 (baseline, zero boost): $(256, 1.0, 1\\times 10^{-4}, 800, 0, 0.08, 1.0)$.\n- Case 2 (moderate boost): $(256, 1.0, 1\\times 10^{-4}, 800, 1, 0.08, 1.0)$.\n- Case 3 (coarser grid, stronger boost): $(128, 1.0, 1\\times 10^{-4}, 800, 3, 0.12, 1.0)$.\n- Case 4 (fine grid, high boost): $(512, 1.0, 1\\times 10^{-4}, 800, 10, 0.05, 1.0)$.\n\nFor each test case, output two floats:\n- The mass-weighted mean velocity $\\overline{v}$ extracted at $t=0$ from the boosted initial condition.\n- The maximum relative $L^2$ error $\\max_t \\epsilon(t)$ over the snapshot times $t\\in\\{0, T/4, T/2, 3T/4, T\\}$, where $T = \\text{steps}\\times \\Delta t$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test cases, with each test case contributing its two floats in sequence. For example, the output must look like\n\"[v1,e1,v2,e2,v3,e3,v4,e4]\".",
            "solution": "The user has provided a well-defined computational problem in the field of numerical cosmology, specifically concerning the simulation of the Schrödinger-Poisson equations for fuzzy or ultralight dark matter. I will first formally validate the problem statement and then proceed to a detailed, principle-based solution.\n\n### Step 1: Extract Givens\n\n- **Governing Equations:**\n    1.  Time-dependent Schrödinger equation:\n        $$\n        i\\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{\\hbar^2}{2m}\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; m\\,\\phi(x,t)\\,\\psi(x,t)\n        $$\n    2.  Poisson equation for the gravitational potential $\\phi$:\n        $$\n        \\frac{\\partial^2 \\phi(x,t)}{\\partial x^2} \\;=\\; 4\\pi G\\left(\\rho(x,t) - \\overline{\\rho}\\right)\n        $$\n- **Definitions:**\n    - Mass density: $\\rho(x,t)=|\\psi(x,t)|^2$\n    - Spatial mean density: $\\overline{\\rho}=\\frac{1}{L}\\int_0^L \\rho(x,t)\\,dx$\n    - Current: $j(x,t)=\\frac{\\hbar}{m}\\,\\mathrm{Im}\\left(\\psi^*(x,t)\\,\\frac{\\partial \\psi(x,t)}{\\partial x}\\right)$\n    - Galilean boost: $\\psi \\to e^{i k x}\\psi$\n    - Theoretical velocity from boost: $v=\\frac{\\hbar}{m}k$\n- **Boundary Conditions:** Periodic on a domain of length $L$.\n- **Code Units:** $\\hbar=1$, $m=1$, and $\\gamma = 4\\pi G$.\n- **Numerical Method:**\n    - **Time Integration:** Strang split-step method.\n        - Potential step: Advance by $\\Delta t/2$ using $e^{-i(m/\\hbar)\\phi\\,\\Delta t/2}$.\n        - Kinetic step: Advance by $\\Delta t$ using $e^{-i(\\hbar k_{wave}^2/2m)\\,\\Delta t}$ in Fourier space.\n    - **Poisson Solver:** In Fourier space, $\\widehat{\\phi}(k) = -\\frac{\\gamma}{k_{wave}^2}\\,\\widehat{\\rho - \\overline{\\rho}}\\,(k)$ for $k_{wave}\\neq 0$, and $\\widehat{\\phi}(0)=0$.\n    - **Derivative:** Compute $\\frac{\\partial \\psi}{\\partial x}$ spectrally.\n- **Initial Conditions:**\n    - Unboosted: $\\psi_0(x) = A\\,\\exp\\!\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)$, normalized such that $\\int_0^L |\\psi_0(x)|^2\\,dx = 1$, with $x_0=L/2$.\n    - Boosted: $\\psi_b(x,0) = e^{i k x}\\,\\psi_0(x)$ with $k=\\frac{2\\pi n}{L}$ for an integer $n$.\n- **Tasks  Outputs:**\n    1.  Compute the mass-weighted mean velocity at $t=0$: $\\overline{v} = \\frac{\\int_0^L j(x,0)\\,dx}{\\int_0^L \\rho(x,0)\\,dx}$.\n    2.  Compute the maximum relative $L^2$ error $\\max_t \\epsilon(t)$ over snapshot times $t\\in\\{0, T/4, T/2, 3T/4, T\\}$, where $T = \\text{steps}\\times \\Delta t$ and\n        $$\n        \\epsilon(t) = \\frac{\\left\\|\\rho_b(x,t) - \\rho_0(x-vt,t)\\right\\|_{L^2}}{\\left\\|\\rho_0(x,t)\\right\\|_{L^2}}\n        $$\n- **Test Cases:** A suite of four tuples $(N, L, \\Delta t, \\text{steps}, n, \\sigma, \\gamma)$:\n    - Case 1: $(256, 1.0, 1\\times 10^{-4}, 800, 0, 0.08, 1.0)$\n    - Case 2: $(256, 1.0, 1\\times 10^{-4}, 800, 1, 0.08, 1.0)$\n    - Case 3: $(128, 1.0, 1\\times 10^{-4}, 800, 3, 0.12, 1.0)$\n    - Case 4: $(512, 1.0, 1\\times 10^{-4}, 800, 10, 0.05, 1.0)$\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem describes the Schrödinger-Poisson system, a standard and widely used model in astrophysics for studying ultralight or fuzzy dark matter. The numerical approach (split-step Fourier method) is a canonical technique for this class of problems. The test of Galilean invariance is a fundamental physics verification. The problem is scientifically sound.\n- **Well-Posed:** The problem is a well-defined initial value problem for a system of partial differential equations. All necessary parameters, initial conditions, constants, and algorithmic specifications are provided, rendering the problem well-posed and solvable.\n- **Objective:** The problem is stated using precise, formal mathematical and computational language, free of any subjectivity or ambiguity.\n- **Completeness and Consistency:** The problem is self-contained. The specification for handling the $k_{wave}=0$ mode in the Poisson solver, $\\widehat{\\phi}(0)=0$, is consistent with the subtraction of the mean density $\\overline{\\rho}$, which ensures mass conservation on a periodic domain.\n- **Feasibility:** The specified parameters for the grid size, time step, and number of steps are all within a reasonable range for modern computational hardware, making the simulation feasible.\n- **Structure:** The problem is clearly structured with a specific set of tasks and a well-defined output format, leaving no room for interpretation.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid** based on all validation criteria. A solution will be developed and implemented.\n\n### Principle-Based Design of the Solution\n\nThe solution will be structured around a numerical solver that implements the specified algorithm. All calculations will be performed in dimensionless code units where $\\hbar=1$ and $m=1$.\n\n**1. Discretization:**\nThe one-dimensional periodic domain of length $L$ is discretized into a uniform grid of $N$ points, $x_j = j \\Delta x$ for $j=0, \\dots, N-1$, where $\\Delta x = L/N$. The corresponding wavenumbers for the discrete Fourier transform are $k_q = \\frac{2\\pi q}{L}$, where $q$ are the discrete frequencies provided by a Fast Fourier Transform (FFT) routine.\n\n**2. Time Evolution (Strang Splitting):**\nThe Schrödinger equation is of the form $i\\frac{\\partial\\psi}{\\partial t} = (\\hat{T} + \\hat{V})\\psi$, where $\\hat{T} = -\\frac{\\hbar^2}{2m}\\nabla^2$ is the kinetic operator and $\\hat{V} = m\\phi$ is the potential operator. The Strang splitting method provides a second-order accurate approximation for the time-evolution operator:\n$$\n\\psi(t+\\Delta t) \\approx e^{-i\\hat{V}(t+\\Delta t/2)\\Delta t/2} \\, e^{-i\\hat{T}\\Delta t} \\, e^{-i\\hat{V}(t)\\Delta t/2} \\, \\psi(t)\n$$\nBecause the potential $\\hat{V}$ is non-linear (it depends on $\\psi$ through $\\phi$), we re-calculate it at each half-step. The numerical implementation follows a \"kick-drift-kick\" scheme:\n- **Kick (Potential Half-Step):** The potential $\\phi$ is calculated from the current wavefunction $\\psi$. The wavefunction is then updated by multiplying it with the phase factor $e^{-i\\phi \\Delta t/2}$ (since $m=1$). This step is performed in position space.\n- **Drift (Kinetic Full-Step):** The kinetic evolution is most easily performed in Fourier space, where the second derivative operator $\\frac{\\partial^2}{\\partial x^2}$ becomes multiplication by $-k_{wave}^2$. The wavefunction $\\psi$ is transformed to Fourier space ($\\hat{\\psi}$), multiplied by the phase factor $e^{-i(k_{wave}^2/2) \\Delta t}$ (since $\\hbar=1, m=1$), and then transformed back to position space.\n- **Kick (Potential Half-Step):** The potential step is repeated with the new wavefunction obtained from the kinetic step.\n\n**3. Poisson Solver:**\nAt each potential step, the gravitational potential $\\phi$ must be determined. This is done by solving the Poisson equation in Fourier space:\n1.  Compute the density $\\rho(x) = |\\psi(x)|^2$ and its spatial mean $\\overline{\\rho}$.\n2.  Compute the Fourier transform of the density fluctuation, $\\widehat{\\rho-\\overline{\\rho}}(k_{wave})$.\n3.  Solve for the Fourier modes of the potential: $\\widehat{\\phi}(k_{wave}) = -\\frac{\\gamma}{k_{wave}^2} \\widehat{\\rho-\\overline{\\rho}}(k_{wave})$. The case $k_{wave}=0$ is handled by setting $\\widehat{\\phi}(0)=0$, which avoids division by zero and is physically consistent with the problem setup.\n4.  Compute the inverse Fourier transform of $\\widehat{\\phi}(k_{wave})$ to obtain $\\phi(x)$. Small imaginary parts arising from numerical noise are discarded, as the potential must be real.\n\n**4. Observable Calculation:**\n- **Mean Velocity:** The mass-weighted mean velocity $\\overline{v}$ is computed from the initial boosted wavefunction $\\psi_b(x,0)$. The current $j(x,0)$ is found using a spectral derivative: $\\frac{\\partial \\psi_b}{\\partial x} = \\mathcal{F}^{-1}\\{i k_{wave} \\mathcal{F}\\{\\psi_b\\}\\}$. Then $j = \\mathrm{Im}(\\psi_b^* \\frac{\\partial \\psi_b}{\\partial x})$ is calculated, and its integral over the domain gives $\\overline{v}$ (since total mass is normalized to $1$). The analytical result $\\overline{v} = (\\hbar/m)k = k$ serves as a validation of this numerical calculation.\n- **Frame Invariance Error:** To compute the error $\\epsilon(t)$, the unboosted density $\\rho_0(x,t)$ is evolved and snapshots are stored. For each snapshot, the density is spatially shifted by an amount $v \\cdot t$, where $v$ is the theoretical boost velocity $k$. This shift is performed accurately in Fourier space using the shift theorem: $\\mathcal{F}\\{f(x-a)\\} = e^{-ik_{wave}a}\\mathcal{F}\\{f(x)\\}$. The $L^2$-norm of the difference between the boosted density $\\rho_b(x,t)$ and the shifted unboosted density $\\rho_0(x-vt, t)$ is computed and normalized by the $L^2$-norm of $\\rho_0(x,t)$. The maximum of these relative errors over all snapshots is reported. The numerical representation of the $L^2$ norm is $\\|\\cdot\\|_{L^2} \\approx \\sqrt{\\sum (\\cdot)^2 \\Delta x}$.\n\nA Python implementation encapsulating this logic in a solver class will be used to run the specified test cases and generate the final output in the required format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Schrödinger-Poisson simulation test suite.\n    \"\"\"\n\n    class SchrodingerPoissonSolver:\n        \"\"\"\n        Solves the 1D Schrödinger-Poisson system using a Strang split-step Fourier method.\n        \"\"\"\n        def __init__(self, N, L, dt, gamma):\n            self.N = N\n            self.L = L\n            self.dt = dt\n            self.gamma = gamma\n\n            self.dx = L / N\n            self.x = np.linspace(0, L, N, endpoint=False)\n            \n            # Wavenumbers (k) for Fourier transforms\n            freq = np.fft.fftfreq(N, d=self.dx)\n            self.k_wave = 2 * np.pi * freq\n            \n            # Pre-calculate the kinetic evolution operator for a full time step.\n            # The operator is exp(-i * T * dt), where T is the kinetic energy operator.\n            # In Fourier space, T becomes hbar^2*k^2/(2m). With hbar=m=1, T_k = k^2/2.\n            self.kinetic_op = np.exp(-1j * (self.k_wave**2) / 2.0 * self.dt)\n\n            # Pre-calculate the inverse of k^2 for the Poisson solver.\n            # The operator in k-space is -gamma/k^2 for k != 0.\n            self.poisson_k_op = np.zeros_like(self.k_wave)\n            nonzero_k_indices = self.k_wave != 0\n            self.poisson_k_op[nonzero_k_indices] = -self.gamma / (self.k_wave[nonzero_k_indices]**2)\n\n        def _solve_poisson(self, rho):\n            \"\"\"Solves the Poisson equation in Fourier space.\"\"\"\n            rho_mean = np.mean(rho)\n            rho_minus_mean = rho - rho_mean\n            \n            rho_k = np.fft.fft(rho_minus_mean)\n            phi_k = self.poisson_k_op * rho_k\n            \n            phi = np.fft.ifft(phi_k)\n            return phi.real\n\n        def _potential_step(self, psi):\n            \"\"\"Applies the potential operator for half a time step.\"\"\"\n            rho = np.abs(psi)**2\n            phi = self._solve_poisson(rho)\n            potential_op_half_step = np.exp(-1j * phi * self.dt / 2.0)\n            return psi * potential_op_half_step\n\n        def _kinetic_step(self, psi):\n            \"\"\"Applies the kinetic operator for a full time step.\"\"\"\n            psi_k = np.fft.fft(psi)\n            psi_k_evolved = psi_k * self.kinetic_op\n            return np.fft.ifft(psi_k_evolved)\n\n        def evolve_step(self, psi):\n            \"\"\"Performs one full time step using Strang splitting (kick-drift-kick).\"\"\"\n            psi = self._potential_step(psi)\n            psi = self._kinetic_step(psi)\n            psi = self._potential_step(psi)\n            return psi\n\n    def run_case(params):\n        \"\"\"\n        Runs a single test case for the Schrödinger-Poisson simulation.\n        \"\"\"\n        N, L, dt, steps, n, sigma, gamma = params\n        \n        solver = SchrodingerPoissonSolver(N, L, dt, gamma)\n        x, dx, k_wave = solver.x, solver.dx, solver.k_wave\n\n        # 1. Initialize unboosted wavefunction (normalized Gaussian)\n        psi0_unnormalized = np.exp(-(x - L / 2.0)**2 / (2 * sigma**2))\n        norm = np.sqrt(np.sum(np.abs(psi0_unnormalized)**2) * dx)\n        psi0 = psi0_unnormalized / norm\n\n        # 2. Create boosted initial condition\n        boost_k = (2.0 * np.pi * n) / L\n        psi_b_t0 = psi0 * np.exp(1j * boost_k * x)\n        \n        # 4. Compute mass-weighted mean velocity at t=0\n        psi_b_t0_k = np.fft.fft(psi_b_t0)\n        d_psi_b_dx = np.fft.ifft(1j * k_wave * psi_b_t0_k)\n        j_b_t0 = np.imag(np.conj(psi_b_t0) * d_psi_b_dx)\n        v_mean = np.sum(j_b_t0) * dx\n        \n        v_theory = boost_k\n\n        # 3/5. Evolve both ICs and compute discrepancy\n        snapshot_steps = sorted(list(set([0, steps // 4, steps // 2, 3 * steps // 4, steps])))\n        \n        sim_results = {}\n        for sim_type, psi_initial in [('unboosted', psi0), ('boosted', psi_b_t0)]:\n            snapshots = {}\n            psi = np.copy(psi_initial)\n            \n            if 0 in snapshot_steps:\n                snapshots[0] = np.abs(psi)**2\n                \n            for step in range(1, steps + 1):\n                psi = solver.evolve_step(psi)\n                if step in snapshot_steps:\n                    snapshots[step] = np.abs(psi)**2\n            sim_results[sim_type] = snapshots\n\n        rho0_snapshots = sim_results['unboosted']\n        rhob_snapshots = sim_results['boosted']\n        \n        errors = []\n        for step_num in snapshot_steps:\n            t = step_num * dt\n            rho_b = rhob_snapshots[step_num]\n            rho_0 = rho0_snapshots[step_num]\n            \n            shift = (v_theory * t) % L\n            rho_0_k = np.fft.fft(rho_0)\n            shift_phase = np.exp(-1j * k_wave * shift)\n            rho_0_shifted = np.fft.ifft(rho_0_k * shift_phase).real\n            \n            diff_rho_sq = (rho_b - rho_0_shifted)**2\n            numerator = np.sqrt(np.sum(diff_rho_sq) * dx)\n            \n            rho_0_sq = rho_0**2\n            denominator = np.sqrt(np.sum(rho_0_sq) * dx)\n            \n            error = numerator / denominator if denominator != 0 else (0.0 if numerator == 0.0 else np.inf)\n            errors.append(error)\n            \n        max_error = np.max(errors)\n        \n        return v_mean, max_error\n\n    test_cases = [\n        (256, 1.0, 1e-4, 800, 0, 0.08, 1.0),\n        (256, 1.0, 1e-4, 800, 1, 0.08, 1.0),\n        (128, 1.0, 1e-4, 800, 3, 0.12, 1.0),\n        (512, 1.0, 1e-4, 800, 10, 0.05, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        v_mean, max_error = run_case(case)\n        results.extend([v_mean, max_error])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}