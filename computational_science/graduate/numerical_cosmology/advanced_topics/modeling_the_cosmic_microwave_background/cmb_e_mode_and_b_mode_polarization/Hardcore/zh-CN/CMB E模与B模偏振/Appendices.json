{
    "hands_on_practices": [
        {
            "introduction": "宇宙微波背景（CMB）功率谱的理论预测是连接早期宇宙物理和现代宇宙学观测的桥梁。通过从第一性原理出发，利用视线积分方法，我们可以将关于复合时期物理过程的简化模型转化为可观测的角功率谱 $C_{\\ell}^{EE}$。这个实践练习将指导你构建一个简化的数值代码，将初始标量扰动演化为CMB E模偏振信号，从而让你深入理解CMB各向异性的物理来源。",
            "id": "3467172",
            "problem": "要求您设计并实现一个完整的、自包含的数值程序，该程序使用视线积分方法计算标量初始条件下的宇宙微波背景（CMB）$E$模偏振角功率谱$C_{\\ell}^{EE}$。您的实现必须从清晰、基于原理的基础开始，不使用任何预封装的CMB求解器。计算必须以纯数学术语进行框架，使用物理上一致但简化的成分，以使程序不依赖于外部数据或代码。该场景必须是科学上真实且自洽的。\n\n从以下基本基础开始：\n\n- CMB偏振源于Thomson散射，其微分截面取决于入射辐射场的各向异性。光子分布中的局部四极各向异性产生线性偏振，由斯托克斯参数$Q$和$U$描述。\n- 光子分布的线性微扰理论被编码在玻尔兹曼方程中。在标量初始条件下，天空上的偏振场可以分解为梯度型和旋度型分量，分别称为$E$模和$B$模。在没有张量微扰和引力透镜效应的情况下，标量初始条件只产生$E$模。\n- 视线形式主义将辐射场的多极矩表示为源项乘以球贝塞尔函数后对共形时间的积分，这反映了光子从最后散射面到观测者的自由传播。\n\n您的算法必须按以下步骤进行：\n\n1. 定义一个有物理动机但在数值上易于处理的可见性函数，以将最后散射建模为一个有限宽度的过程：\n   - 使用一个归一化的高斯可见性函数$g(\\eta)$，该函数以复合共形时间$\\,\\eta_{\\star}\\,$为中心，宽度为$\\,\\sigma_{\\eta}\\,$，并满足$\\int g(\\eta) \\, d\\eta = 1$。在本文中，共形时间单位必须是百万秒差距（Mpc）。\n2. 将偏振源振幅建模为一个尺度依赖因子$Q(k)$，以捕捉偏振产生的效率和微观物理阻尼：\n   - 使用$Q(k) = q_{0}\\,\\exp\\!\\big( - (k/k_{d})^{m} \\big)$，其中$k$的单位是逆百万秒差距$\\,\\mathrm{Mpc}^{-1}\\,$，$q_{0}$是一个无量纲效率因子，$k_{d}$是一个阻尼尺度，$m$是一个正整数指数。所有波数的单位必须是$\\,\\mathrm{Mpc}^{-1}\\,$。\n3. 实现$E$模传递函数的视线积分，并在共形时间上进行离散化：\n   - 令$D(\\eta) = \\eta_{0} - \\eta$，其中$\\eta_{0}$是今天的共形时间，单位为$\\,\\mathrm{Mpc}\\,$。\n   - 通过源项$S_{E}(k,\\eta)$乘以球贝塞尔函数$j_{\\ell}(k D(\\eta))$后对$\\eta$的积分来定义传递函数$\\Delta_{\\ell}^{E}(k)$。\n   - 在这个简化模型中，设$S_{E}(k,\\eta) = Q(k)\\,g(\\eta)$，因此$\\Delta_{\\ell}^{E}(k)$简化为$j_{\\ell}$与$g(\\eta)$的卷积，并由$Q(k)$加权。\n4. 通过对波数进行积分，并使用原初曲率功率谱$P_{\\mathcal{R}}(k)$来计算角功率谱$C_{\\ell}^{EE}$：\n   - 使用$P_{\\mathcal{R}}(k) = A_{s}\\,(k/k_{0})^{n_{s} - 1}$，其中$A_{s}$是标量振幅，$n_{s}$是谱指数，$k_{0}$是枢轴尺度。所有波数的单位均为$\\,\\mathrm{Mpc}^{-1}\\,$。\n   - 在$\\ln k$中对$k$积分进行离散化，并通过对$P_{\\mathcal{R}}(k)\\big(\\Delta_{\\ell}^{E}(k)\\big)^{2}$的积分来计算$C_{\\ell}^{EE}$。\n\n科学和数值要求：\n\n- 单位：\n  - 共形时间$\\,\\eta\\,$和$\\eta_{0}$必须以$\\,\\mathrm{Mpc}\\,$为单位指定。\n  - 波数$\\,k\\,$必须以$\\,\\mathrm{Mpc}^{-1}\\,$为单位指定。\n  - 角度隐含在球贝塞尔函数$j_{\\ell}(\\cdot)$的参数中，并且是无量纲的弧度。\n  - 最终的$C_{\\ell}^{EE}$值必须报告为无单位的浮点数（不附加单位），因为在此简化模型中，归一化由$P_{\\mathcal{R}}(k)$设定。\n- 数值积分：\n  - 在$\\,\\eta_{\\star}\\,$周围的对称区间上离散化$\\eta$，该区间需能捕捉宽度$\\,\\sigma_{\\eta}\\,$（例如，在两侧各有几个$\\,\\sigma_{\\eta}\\,$）。\n  - 在物理上合理的范围$[k_{\\min}, k_{\\max}]$内对$k$进行对数离散化，该范围需足以捕捉所选多极矩的$j_{\\ell}(kD)$的支撑集。\n  - 对$\\eta$和$\\ln k$的积分均使用数值稳定且收敛的求积法（例如，梯形法则）。\n- 标量初始条件：\n  - 仅限于无引力透镜或张量模的标量初始条件；$B$模偏振被忽略。\n\n验证要求：\n\n- 尽管与诸如宇宙线性各向异性求解系统（CLASS）等公开的玻尔兹曼求解器进行全面验证超出了这个自包含程序的范围，但应包含一个诊断程序，用于将有限宽度复合的结果与瞬时复合极限进行比较，后者通过将$g(\\eta)$替换为在$\\,\\eta_{\\star}\\,$处的狄拉克δ函数来建模。构造相应的参考$C_{\\ell}^{EE,\\mathrm{inst}}$，使用$\\,\\Delta_{\\ell}^{E,\\mathrm{inst}}(k) = Q(k)\\,j_{\\ell}(k D(\\eta_{\\star}))\\,$。报告一个布尔值，指示对于一个小的$\\,\\sigma_{\\eta}\\,$，两个$C_{\\ell}^{EE}$数组之间的相关性是否超过所选阈值，这表明与瞬时极限的一致性。\n\n测试套件：\n\n实现该程序，以计算并报告以下参数集的结果。每个测试用例必须为指定的多极矩生成一个与$C_{\\ell}^{EE}$对应的浮点数列表：\n\n- 测试用例1（正常路径）：\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$，$\\eta_{\\star} = 280\\,\\mathrm{Mpc}$，$\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$，$q_{0} = 0.17$，$k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$，$m = 2$，$A_{s} = 2.1\\times 10^{-9}$，$n_{s} = 0.965$，$k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$，多极矩$\\ell \\in \\{2, 10, 100, 500\\}$，$k$范围$[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$。\n- 测试用例2（近瞬时复合边界）：\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$，$\\eta_{\\star} = 280\\,\\mathrm{Mpc}$，$\\sigma_{\\eta} = 2\\,\\mathrm{Mpc}$，$q_{0} = 0.17$，$k_{d} = 0.35\\,\\mathrm{Mpc}^{-1}$，$m = 2$，$A_{s} = 2.1\\times 10^{-9}$，$n_{s} = 0.965$，$k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$，多极矩$\\ell \\in \\{20, 80, 200\\}$，$k$范围$[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$。\n- 测试用例3（边界情况：谱指数变化）：\n  - $\\eta_{0} = 14000\\,\\mathrm{Mpc}$，$\\eta_{\\star} = 280\\,\\mathrm{Mpc}$，$\\sigma_{\\eta} = 18\\,\\mathrm{Mpc}$，$q_{0} = 0.17$，$k_{d} = 0.14\\,\\mathrm{Mpc}^{-1}$，$m = 2$，$A_{s} = 2.1\\times 10^{-9}$，$n_{s} = 1.0$，$k_{0} = 0.05\\,\\mathrm{Mpc}^{-1}$，多极矩$\\ell \\in \\{2\\}$，$k$范围$[10^{-4}, 2]\\,\\mathrm{Mpc}^{-1}$。\n- 验证诊断（布尔值）：\n  - 使用测试用例2的参数，为同一组$\\ell$值计算上述的有限宽度结果和瞬时参考结果。报告一个布尔值，指示两个$C_{\\ell}^{EE}$数组之间的皮尔逊相关系数是否超过$\\,0.995\\,$，且其均值之比是否在$[0.8,\\,1.2]$范围内。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。前三个条目必须分别是测试用例1、2和3的$C_{\\ell}^{EE}$值列表。第四个条目必须是验证诊断布尔值。例如，输出必须具有以下形式：\n  - $[\\,[c_{1,\\ell_{1}}, c_{1,\\ell_{2}}, \\dots],\\,[c_{2,\\ell_{1}}, c_{2,\\ell_{2}}, \\dots],\\,[c_{3,\\ell_{1}}, \\dots],\\,\\mathrm{true}\\,]$\n  - 浮点数必须无单位打印。",
            "solution": "问题陈述已得到严格验证，并被视为有效。它在科学上基于物理宇宙学原理，数学上是适定的，并且所有提供的参数和函数形式对于一个简化模型来说都是自洽和物理上真实的。任务是使用视线积分方法，从第一性原理出发，实现CMB $E$模偏振角功率谱$C_{\\ell}^{EE}$的数值计算。\n\n该计算的理论基础在于将角功率谱$C_{\\ell}^{EE}$表示为对所有原初涨落傅里叶模式贡献的积分。每个波数为$k$的模式的贡献由原初功率谱$P_{\\mathcal{R}}(k)$加权，并由一个传递函数$\\Delta_{\\ell}^{E}(k)$调制，该函数编码了从早期宇宙到今天的微扰演化。公式为：\n$$\nC_{\\ell}^{EE} = \\int_{0}^{\\infty} P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2 \\frac{dk}{k}\n$$\n积分是针对波数$k$的对数进行的，这对于宇宙学功率谱是标准做法。\n\n原初功率谱$P_{\\mathcal{R}}(k)$描述了初始标量曲率微扰的振幅，并被建模为一个简单的幂律，这与暴胀理论一致：\n$$\nP_{\\mathcal{R}}(k) = A_{s} \\left( \\frac{k}{k_{0}} \\right)^{n_{s} - 1}\n$$\n这里，$A_{s}$是标量振幅，$n_{s}$是衡量尺度依赖性的标量谱指数，$k_{0}$是一个任意的枢轴尺度。\n\n$E$模传递函数$\\Delta_{\\ell}^{E}(k)$量化了波数为$k$的单个原初傅里叶模式如何对在角多极矩$\\ell$处观测到的偏振各向异性作出贡献。它由视线积分给出，该积分将宇宙历史中每个点（由共形时间$\\eta$参数化）的偏振源项$S_{E}(k, \\eta)$投影到今天的观测者（在$\\eta_{0}$处）：\n$$\n\\Delta_{\\ell}^{E}(k) = \\int_{0}^{\\eta_{0}} S_{E}(k, \\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\n函数$j_{\\ell}(x)$是$\\ell$阶球贝塞尔函数，它源于平面波到球谐函数的分解。参数$k(\\eta_{0} - \\eta)$表示波数与从时间$\\eta$处的源到观测者的共动距离的乘积。\n\n问题为源项$S_{E}(k, \\eta)$提供了简化的、有物理动机的模型：\n$$\nS_{E}(k, \\eta) = Q(k) g(\\eta)\n$$\n这种因式分解将时间依赖性与尺度依赖性分离开来。\n\n1. 可见性函数$g(\\eta)$模拟了复合过程，在此期间光子最后一次与自由电子发生散射。它被建模为一个以复合共形时间$\\eta_{\\star}$为中心、特征宽度为$\\sigma_{\\eta}$的归一化高斯函数：\n$$\ng(\\eta) = \\frac{1}{\\sigma_{\\eta}\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\eta - \\eta_{\\star})^2}{2\\sigma_{\\eta}^2}\\right)\n$$\n这个函数充当一个时间窗口，确保偏振仅在复合的有限时间间隔内产生。\n\n2. 源振幅$Q(k)$模拟了偏振产生的效率和微观物理阻尼效应。它由以下公式给出：\n$$\nQ(k) = q_{0}\\,\\exp\\left( - (k/k_{d})^{m} \\right)\n$$\n其中$q_{0}$是一个无量纲效率因子。指数项模拟了由于光子扩散而在小尺度（大$k$）上对各向异性的抑制，这种效应被称为Silk阻尼，其中$k_{d}$是特征阻尼尺度，$m$是一个正整数。\n\n结合这些元素，传递函数变为：\n$$\n\\Delta_{\\ell}^{E}(k) = Q(k) \\int_{0}^{\\eta_{0}} g(\\eta) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta\n$$\n\n计算$C_{\\ell}^{EE}$的算法方法是通过离散化和数值计算嵌套积分来进行的。\n\n**步骤1：数值积分网格**\n-   在波数上建立一个对数网格$k_j$，覆盖范围$[k_{\\min}, k_{\\max}]$，适用于谱的宽动态范围和幂律性质。积分变量变为$\\ln k$。\n-   在共形时间上建立一个线性网格$\\eta_i$，覆盖$\\eta_{\\star}$周围的对称区间（例如$[\\eta_{\\star} - 6\\sigma_{\\eta}, \\eta_{\\star} + 6\\sigma_{\\eta}]$），以完全捕捉高斯可见性函数的支撑域。\n\n**步骤2：计算传递函数$\\Delta_{\\ell}^{E}(k_j)$**\n对于网格上的每个多极矩$\\ell$和每个波数$k_j$，使用梯形法则对$\\eta$的积分进行数值计算：\n$$\n\\int g(\\eta) j_{\\ell}\\big(k_j(\\eta_{0} - \\eta)\\big) d\\eta \\approx \\sum_{i} \\frac{g(\\eta_{i+1})j_{\\ell,i+1} + g(\\eta_i)j_{\\ell,i}}{2} (\\eta_{i+1} - \\eta_i)\n$$\n其中$j_{\\ell,i} = j_{\\ell}\\big(k_j(\\eta_0 - \\eta_i)\\big)$。该值乘以$Q(k_j)$后，得到$\\Delta_{\\ell}^{E}(k_j)$。\n\n**步骤3：计算角功率谱$C_{\\ell}^{EE}$**\n在网格上为所有$k_j$计算出传递函数值$\\Delta_{\\ell}^{E}(k_j)$后，再次使用梯形法则在对数$k$网格上计算$C_{\\ell}^{EE}$的最终积分：\n$$\nC_{\\ell}^{EE} \\approx \\sum_{j} \\frac{F(k_{j+1}) + F(k_j)}{2} (\\ln k_{j+1} - \\ln k_j)\n$$\n其中被积函数为$F(k) = P_{\\mathcal{R}}(k) \\left( \\Delta_{\\ell}^{E}(k) \\right)^2$。对指定的每个$\\ell$多极矩重复此过程。\n\n**步骤4：通过瞬时复合极限进行验证**\n一个关键的验证步骤涉及将结果与瞬时复合的理想化极限进行比较，其中$\\sigma_{\\eta} \\to 0$。在此极限下，可见性函数$g(\\eta)$趋近于一个狄拉克δ函数，$g(\\eta) \\to \\delta(\\eta - \\eta_{\\star})$。传递函数的积分变得很简单：\n$$\n\\Delta_{\\ell}^{E, \\mathrm{inst}}(k) = Q(k) \\int_{0}^{\\eta_{0}} \\delta(\\eta - \\eta_{\\star}) j_{\\ell}\\big(k(\\eta_{0} - \\eta)\\big) d\\eta = Q(k) j_{\\ell}\\big(k(\\eta_{0} - \\eta_{\\star})\\big)\n$$\n使用这个简化的传递函数计算相应的功率谱$C_{\\ell}^{EE, \\mathrm{inst}}$。对于一个小的但有限的$\\sigma_{\\eta}$，完整的数值结果应该紧密地跟踪这个瞬时近似。两个计算出的谱之间的相关性和均值比是验证实现正确性的有力诊断工具。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef compute_cl_ee(\n    multipoles, eta0, eta_star, sigma_eta, q0, kd, m, As, ns, k0, k_range,\n    num_k_pts=500, num_eta_pts=200, eta_width_factor=6.0\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for a finite-width recombination.\n\n    Args:\n        multipoles (list): List of multipole moments l to compute.\n        eta0, eta_star, sigma_eta (float): Cosmological time parameters in Mpc.\n        q0, kd, m (float): Parameters for the polarization source amplitude Q(k).\n        As, ns, k0 (float): Parameters for the primordial power spectrum P_R(k).\n        k_range (list): [k_min, k_max] for the wavenumber integration in Mpc^-1.\n        num_k_pts (int): Number of points for the log-spaced k-grid.\n        num_eta_pts (int): Number of points for the linear eta-grid.\n        eta_width_factor (float): The eta-grid spans eta_star +/- factor * sigma_eta.\n\n    Returns:\n        list: A list of C_l^EE values for the given multipoles.\n    \"\"\"\n    # 1. Define numerical integration grids\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n    eta_min = eta_star - eta_width_factor * sigma_eta\n    eta_max = eta_star + eta_width_factor * sigma_eta\n    eta_grid = np.linspace(eta_min, eta_max, num_eta_pts)\n\n    # 2. Evaluate physics functions on their respective grids\n    # Primordial power spectrum P_R(k)\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    # Polarization source amplitude Q(k)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n    # Normalized Gaussian visibility function g(eta)\n    g_eta = (1.0 / (sigma_eta * np.sqrt(2 * np.pi))) * \\\n            np.exp(-0.5 * ((eta_grid - eta_star) / sigma_eta)**2)\n\n    # 3. Compute the E-mode transfer functions Delta_l^E(k)\n    delta_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_from_source = eta0 - eta_grid\n\n    for j, l_val in enumerate(multipoles):\n        for i, k_val in enumerate(k_grid):\n            # Evaluate j_l(k * (eta0 - eta)) on the eta grid\n            bessel_arg = k_val * comoving_dist_from_source\n            j_l_values = spherical_jn(l_val, bessel_arg)\n            \n            # Integrand for the eta-integral\n            integrand_eta = g_eta * j_l_values\n            \n            # Perform integral numerically using the trapezoidal rule\n            integral_val = np.trapz(integrand_eta, eta_grid)\n            \n            delta_matrix[j, i] = Q_k[i] * integral_val\n\n    # 4. Compute the angular power spectrum C_l^EE\n    # Integrand for the k-integral: P_R(k) * (Delta_l^E(k))^2\n    k_integrand = P_R_k[np.newaxis, :] * (delta_matrix**2)\n    \n    # Perform integral over ln(k) using trapezoidal rule\n    log_k_grid = np.log(k_grid)\n    cl_ee_array = np.trapz(k_integrand, log_k_grid, axis=1)\n    \n    return cl_ee_array.tolist()\n\n\ndef compute_cl_ee_instantaneous(\n    multipoles, eta0, eta_star, q0, kd, m, As, ns, k0, k_range, num_k_pts=500\n):\n    \"\"\"\n    Computes the C_l^EE power spectrum for instantaneous recombination.\n\n    Args:\n        (Same as compute_cl_ee, but without sigma_eta and related parameters)\n\n    Returns:\n        np.array: An array of C_l^EE values.\n    \"\"\"\n    # 1. Define numerical integration grid for k\n    k_grid = np.logspace(np.log10(k_range[0]), np.log10(k_range[1]), num_k_pts)\n\n    # 2. Evaluate physics functions on the k-grid\n    P_R_k = As * (k_grid / k0)**(ns - 1)\n    Q_k = q0 * np.exp(-(k_grid / kd)**m)\n\n    # 3. Compute the transfer functions Delta_l^E,inst(k)\n    delta_inst_matrix = np.zeros((len(multipoles), num_k_pts))\n    comoving_dist_recomb = eta0 - eta_star\n    \n    bessel_arg = k_grid * comoving_dist_recomb\n    for j, l_val in enumerate(multipoles):\n        j_l_values = spherical_jn(l_val, bessel_arg)\n        delta_inst_matrix[j, :] = Q_k * j_l_values\n        \n    # 4. Compute C_l^EE,inst\n    k_integrand = P_R_k[np.newaxis, :] * (delta_inst_matrix**2)\n    log_k_grid = np.log(k_grid)\n    cl_ee_inst_array = np.trapz(k_integrand, log_k_grid, axis=1)\n\n    return cl_ee_inst_array\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Happy path\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [2, 10, 100, 500], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 2: Near-instantaneous recombination\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 2.0,\n            \"q0\": 0.17, \"kd\": 0.35, \"m\": 2, \"As\": 2.1e-9, \"ns\": 0.965, \"k0\": 0.05,\n            \"multipoles\": [20, 80, 200], \"k_range\": [1e-4, 2.0]\n        },\n        # Test Case 3: Edge case (scale-invariant spectrum)\n        {\n            \"eta0\": 14000.0, \"eta_star\": 280.0, \"sigma_eta\": 18.0,\n            \"q0\": 0.17, \"kd\": 0.14, \"m\": 2, \"As\": 2.1e-9, \"ns\": 1.0, \"k0\": 0.05,\n            \"multipoles\": [2], \"k_range\": [1e-4, 2.0]\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        cls = compute_cl_ee(**params)\n        results.append(cls)\n\n    # Perform the validation diagnostic using parameters from Test Case 2\n    validation_params = test_cases[1]\n    cls_finite = np.array(compute_cl_ee(**validation_params))\n    \n    params_inst = {\n        key: val for key, val in validation_params.items() if key != 'sigma_eta'\n    }\n    cls_inst = compute_cl_ee_instantaneous(**params_inst)\n\n    # Compute Pearson correlation coefficient\n    # r = cov(X, Y) / (std(X) * std(Y))\n    corr_matrix = np.corrcoef(cls_finite, cls_inst)\n    correlation = corr_matrix[0, 1] if corr_matrix.shape == (2,2) else 1.0\n    \n    # Compute ratio of means\n    mean_ratio = np.mean(cls_finite) / np.mean(cls_inst) if np.mean(cls_inst) != 0 else 0\n\n    validation_bool = (correlation > 0.995) and (0.8  mean_ratio  1.2)\n    results.append(validation_bool)\n    \n    # Format the final output string\n    result_strs = []\n    for item in results:\n        if isinstance(item, bool):\n            result_strs.append(str(item).lower())\n        else:\n            result_strs.append(str(item))\n            \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在标准宇宙学模型中，标量扰动仅产生E模偏振，B模的缺失是汤姆逊散射各向同性性质的一个直接后果。这个实践练习通过引入一个非物理的、具有优先方向的“玩具”散射核，来刻意破坏这种对称性。通过计算这个模型产生的伪B模信号，你可以直观地理解对称性在E/B模分离中的关键作用，并学会如何设计数值诊断工具来验证代码的物理保真度。",
            "id": "3478286",
            "problem": "在数值宇宙学中，考虑宇宙微波背景 (CMB) 偏振的平天模型，重点关注视线 (LOS) 积分。在标准的各向同性汤姆孙散射中，标量微扰只产生电性 (E) 偏振模，而不产生磁性 (B) 偏振模。为了诊断数值代码的正确性，我们将引入一个带有优选方向的玩具各向异性散射核，该散射核故意破坏方位对称性，并能通过 LOS 积分产生伪 B 模。\n\n您必须实现一个完整的程序，该程序在一个方形角斑块上从单个平面波标量微扰构建基准纯 E 模偏振图样，然后应用一个经过 LOS 积分的各向异性核，该核会根据平面波方向和优选方向之间的失准情况，引起均匀的偏振旋转。您必须根据此旋转后的图样，计算 E 模和 B 模，并量化伪 B 模的生成。\n\n程序必须遵循以下规范：\n\n- 在一个边长为 $L$ 弧度的方形角斑块上使用平天近似，该斑块在 $N \\times N$ 网格上离散化。角度必须以弧度为单位。\n- 从产生基准纯 E 模偏振图样的单模标量微扰开始。从一个傅里叶空间 E 模场构建基准斯托克斯参数 $Q(\\boldsymbol{\\theta})$ 和 $U(\\boldsymbol{\\theta})$ 图，该 E 模场的非零振幅仅存在于单个波矢 $\\boldsymbol{k}_0$ 及其负值 $-\\boldsymbol{k}_0$ 处，以确保实空间图为实数。生成的基准必须仅为 E 模（即，B 模在数值精度范围内消失）。\n- 引入一个玩具各向异性散射核，该核在整个图上产生一个角度为 $\\alpha$ 的均匀斯托克斯旋转，此旋转由一个归一化可见性函数的 LOS 积分定义，该函数具有优选方向依赖性。沿 LOS 共动距离 $0 \\le \\chi \\le 1$ 的可见性函数是一个归一化高斯函数\n$$\ng(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right),\n$$\n其中心为 $\\chi_\\star = 0.5$，宽度为 $\\sigma  0$。各向异性参数 $\\varepsilon$ 控制核的强度，优选方向与 $x$ 轴的夹角为 $\\varphi_p$。设平面波模的方向为 $\\varphi_k$。均匀旋转角为\n$$\n\\alpha = \\varepsilon\\,\\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right)\\,\\sin\\left(2(\\varphi_k-\\varphi_p)\\right).\n$$\n- 通过数值 LOS 积分（而非解析计算）计算出 $\\alpha$ 后，将均匀偏振旋转应用于基准 $Q$ 和 $U$ 图，以获得旋转后的图 $Q'(\\boldsymbol{\\theta})$ 和 $U'(\\boldsymbol{\\theta})$。\n- 使用标准的平天 E/B 分解，从旋转后的斯托克斯参数 $Q$ 和 $U$ 图计算傅里叶空间 E 模和 B 模（不要硬编码目标结果；应实现由傅里叶空间斯托克斯参数和 E/B 标量场之间的平天关系所蕴含的正确变换定义）。\n- 计算 E 和 B 的总傅里叶空间功率，\n$$\nP_E = \\sum_{\\boldsymbol{k}} \\left|E(\\boldsymbol{k})\\right|^2,\\quad P_B = \\sum_{\\boldsymbol{k}} \\left|B(\\boldsymbol{k})\\right|^2,\n$$\n并报告伪 B 模功率分数\n$$\nR = \\frac{P_B}{P_E}.\n$$\n\n除非测试套件另有规定，否则您必须使用以下固定的数值设置：\n- 斑块边长 $L = 1.0$（弧度）。\n- 网格大小 $N = 64$。\n- 基准 E 模振幅 $A = 1.0$（无量纲）。\n- 单个非零傅里叶模索引 $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$，给出 $\\varphi_k = 0$。\n\n使用足够精细的一维网格，在 $\\chi \\in [0,1]$ 上实现 LOS 数值积分，以计算 $\\int_0^1 g(\\chi)\\,d\\chi$。\n\n测试套件：\n对于每个测试用例，计算伪 B 模分数 $R$（浮点数）。使用以下参数集 $(\\varepsilon, \\varphi_p, \\sigma)$：\n- 情况 1：$(0.0, \\pi/4, 0.05)$ — 各向同性基准，预期 $R$ 接近 0。\n- 情况 2：$(0.05, \\pi/4, 0.05)$ — 小的各向异性，失准 45°。\n- 情况 3：$(0.2, \\pi/4, 0.05)$ — 更强的各向异性，失准 45°。\n- 情况 4：$(0.2, 0.0, 0.05)$ — 优选方向与模式方向平行，对称性应抑制旋转，使 $R$ 接近 0。\n- 情况 5：$(0.2, \\pi/8, 10^{-3})$ — 窄可见性，以测试在非平凡失准情况下的 LOS 积分稳定性。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例计算出的伪 B 模分数 $R$，表示为浮点数（无量纲）。不应打印任何其他文本。",
            "solution": "我们的物理基础是，在各向同性汤姆孙散射中，由于宇称和方位对称性，标量微扰产生的偏振图样其磁性 (B) 模为零，而电性 (E) 模不为零。斯托克斯参数 $Q$ 和 $U$ 描述了天空中的线偏振。在平天近似下，标准的做法是通过傅里叶变换 $\\tilde{Q}(\\boldsymbol{k})$ 和 $\\tilde{U}(\\boldsymbol{k})$ 的线性组合，将偏振分解为傅里叶空间中的标量 E 场和 B 场，这种组合依赖于波矢方向 $\\varphi_{\\boldsymbol{k}}$ 的角度。算法的目标是构建一个受控的基准纯 E 模图，然后应用一个玩具各向异性核，以引起斯托克斯场的均匀旋转，从而将 E 模混入 B 模。这提供了一种诊断方法：各向同性的情况产生 $B \\approx 0$，而各向异性的情况则产生与控制参数成比例的 $B \\neq 0$。\n\n逐步推导与算法设计：\n\n1. 平天设置与傅里叶约定：\n   - 考虑一个边长为 $L$ 弧度的方形角斑块，在 $N \\times N$ 网格上离散化。用 $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$ 表示实空间角坐标，用 $\\boldsymbol{k} = (k_x, k_y)$ 表示傅里叶空间波矢，其角度为 $\\varphi_{\\boldsymbol{k}} = \\arctan2(k_y, k_x)$。\n   - 使用离散傅里叶变换在实空间图 $Q(\\boldsymbol{\\theta}), U(\\boldsymbol{\\theta})$ 和它们的傅里叶变换 $\\tilde{Q}(\\boldsymbol{k}), \\tilde{U}(\\boldsymbol{k})$ 之间进行转换。对于实数图，傅里叶模必须满足厄米对称性，即对于任何场 $\\tilde{F}$，都有 $\\tilde{F}(-\\boldsymbol{k}) = \\tilde{F}(\\boldsymbol{k})^\\ast$。\n\n2. 构建基准纯 E 模场：\n   - 选择索引为 $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$ 的单个非零傅里叶模及其在 $(-4, 0)$ 的共轭对应项来生成实数图。分配一个对称分布的 E 模振幅 $A  0$，使得这对模的和在实空间中产生一个余弦函数。\n   - 对于傅里叶空间中的纯 E 模，每个 $\\boldsymbol{k}$ 处的斯托克斯参数由\n     $$\n     \\tilde{Q}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\cos\\left(2\\varphi_{\\boldsymbol{k}}\\right), \\quad\n     \\tilde{U}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\sin\\left(2\\varphi_{\\boldsymbol{k}}\\right),\n     $$\n     给出，其中 $\\tilde{B}(\\boldsymbol{k}) = 0$。通过仅在 $\\pm \\boldsymbol{k}_0$ 处构造 $\\tilde{E}(\\boldsymbol{k})$ 并在其他地方为零，逆变换得到的实空间图 $Q(\\boldsymbol{\\theta})$ 和 $U(\\boldsymbol{\\theta})$ 在分解回 E/B 模时，其 B 模在数值精度范围内为零。\n\n3. 定义玩具各向异性散射核与 LOS 积分：\n   - 各向异性核引入一个角度为 $\\varphi_p$ 的优选方向，并产生一个均匀的偏振旋转，旋转角 $\\alpha$ 由归一化高斯可见性函数的 LOS 积分导出：\n     $$\n     g(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right), \\quad \\chi_\\star = 0.5,\\quad \\sigma  0,\\quad 0 \\le \\chi \\le 1.\n     $$\n   - 核的强度由 $\\varepsilon$ 控制，平面波方向与优选方向之间的相对失准为 $\\Delta = \\varphi_k - \\varphi_p$，其中 $\\varphi_k$ 是非零模 $\\boldsymbol{k}_0$ 的角度。\n   - 旋转角建模为\n     $$\n     \\alpha = \\varepsilon \\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right) \\sin(2\\Delta),\n     $$\n     当 $\\Delta = 0$ 或 $\\Delta = \\pi/2$ 时该式为零，这捕捉了各向异性不产生净旋转的对称情况。该积分必须使用足够精细的网格进行数值计算以确保稳定性。\n\n4. 偏振旋转与 E/B 混合：\n   - 在偏振参考系旋转角度 $\\alpha$ 的情况下，斯托克斯参数变换如下：\n     $$\n     Q'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\cos(2\\alpha) - U(\\boldsymbol{\\theta})\\sin(2\\alpha), \\quad\n     U'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\sin(2\\alpha) + U(\\boldsymbol{\\theta})\\cos(2\\alpha).\n     $$\n   - 在傅里叶空间中，平天 E/B 分解通过依赖于 $\\varphi_{\\boldsymbol{k}}$ 的角度因子将 $(\\tilde{Q}, \\tilde{U})$ 与 $(\\tilde{E}, \\tilde{B})$ 联系起来。实现这些标准关系，以从 $\\tilde{Q}'(\\boldsymbol{k})$ 和 $\\tilde{U}'(\\boldsymbol{k})$ 计算 $\\tilde{E}(\\boldsymbol{k})$ 和 $\\tilde{B}(\\boldsymbol{k})$。\n   - 从 $\\tilde{B} = 0$ 的纯 E 模开始，一个均匀的 $\\alpha$ 旋转会将 E 模混入 B 模。可以逐模证明：\n     $$\n     \\tilde{E}'(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k})\\cos(2\\alpha),\\quad\n     \\tilde{B}'(\\boldsymbol{k}) = -\\tilde{E}(\\boldsymbol{k})\\sin(2\\alpha),\n     $$\n     因此对于单模，功率比为\n     $$\n     R = \\frac{P_B}{P_E} = \\frac{\\sum_{\\boldsymbol{k}}|\\tilde{B}'(\\boldsymbol{k})|^2}{\\sum_{\\boldsymbol{k}}|\\tilde{E}'(\\boldsymbol{k})|^2} = \\tan^2(2\\alpha).\n     $$\n   - 在使用离散变换和对所有模式求和的数值方案中，数值精度和有限网格效应可能会引入微小偏差，但定性标度关系保持不变。\n\n5. 数值实现细节：\n   - 使用快速傅里叶变换 (FFT) 频率约定，从离散频率 $\\left(\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}\\right)$（其中 $n_x, n_y \\in \\mathbb{Z}$）生成傅里叶空间网格波矢。\n   - 构建 $\\tilde{E}(\\boldsymbol{k})$，使其非零项仅存在于 $(k_{x,\\text{ind}}, k_{y,\\text{ind}})$ 及其厄米共轭对应项处，确保 $\\tilde{Q}$ 和 $\\tilde{U}$ 继承厄米对称性，从而使逆 FFT 产生实数 $Q$ 和 $U$。\n   - 在精细采样的 $\\chi$ 网格上使用辛普森法则数值计算 LOS 积分 $\\int_0^1 g(\\chi)\\,d\\chi$；计算 $\\alpha$；旋转 $Q$ 和 $U$；变换回傅里叶空间；计算 $\\tilde{E}$ 和 $\\tilde{B}$；然后计算 $P_E$ 和 $P_B$，最后计算 $R$。\n\n6. 测试套件覆盖与边界情况：\n   - 情况 1 验证各向同性基准（$\\varepsilon = 0$），应得出 $R \\approx 0$。\n   - 情况 2 和 3 探索了在 $\\varphi_p = \\pi/4$ 时增加各向异性的情况，得出随 $\\varepsilon$ 增长的非零 $R$。\n   - 情况 4 设置 $\\varphi_p = 0$，与 $\\varphi_k = 0$ 平行，因此 $\\Delta = 0$，对称性抑制了旋转：尽管 $\\varepsilon$ 非零，仍有 $R \\approx 0$。\n   - 情况 5 使用非常窄的可见性（$\\sigma = 10^{-3}$）和 $\\varphi_p = \\pi/8$ 来测试 LOS 积分的稳定性以及非平凡的失准情况。\n\n程序必须以精确格式 $[r_1,r_2,r_3,r_4,r_5]$ 输出包含五个计算出的 $R$ 值的单行列表，不含任何其他文本。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind):\n    \"\"\"\n    Construct baseline pure E-mode Stokes Q and U maps on an NxN grid with side length L (radians),\n    using a single Fourier mode at indices (kx_ind, ky_ind) and its Hermitian counterpart.\n    \"\"\"\n    # Fourier-space wave numbers\n    kx = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    ky = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    KX, KY = np.meshgrid(kx, ky, indexing='xy')\n    # Angle of each wavevector\n    phi = np.arctan2(KY, KX)\n    # Handle k=0 angle gracefully\n    phi[np.isnan(phi)] = 0.0\n\n    # Initialize Fourier-space E field and ensure Hermitian symmetry\n    E_k = np.zeros((N, N), dtype=np.complex128)\n\n    # Positive index\n    pos = (ky_ind % N, kx_ind % N)\n    # Negative (Hermitian counterpart) index\n    neg = ((-ky_ind) % N, (-kx_ind) % N)\n\n    if pos == neg:\n        # If the mode is its own counterpart (only possible if both indices are 0, which we avoid),\n        # assign full amplitude to avoid double-counting.\n        E_k[pos] = amplitude\n    else:\n        # Split amplitude equally to produce a real cosine in real space\n        E_k[pos] = amplitude / 2.0\n        E_k[neg] = amplitude / 2.0\n\n    # Build Q_k and U_k from E_k using flat-sky relations for a pure E-mode\n    Q_k = E_k * np.cos(2.0 * phi)\n    U_k = E_k * np.sin(2.0 * phi)\n\n    # Inverse FFT to get real-space maps\n    Q = np.fft.ifft2(Q_k).real\n    U = np.fft.ifft2(U_k).real\n\n    return Q, U, KX, KY, phi\n\ndef rotate_stokes(Q, U, alpha):\n    \"\"\"\n    Apply uniform polarization rotation by angle alpha (radians) to Stokes Q, U.\n    Rotation acts as (Q', U') = R(2 alpha) (Q, U).\n    \"\"\"\n    ca = np.cos(2.0 * alpha)\n    sa = np.sin(2.0 * alpha)\n    Qp = Q * ca - U * sa\n    Up = Q * sa + U * ca\n    return Qp, Up\n\ndef eb_from_qu(Q, U, KX, KY):\n    \"\"\"\n    Compute Fourier-space E and B modes from Stokes Q and U maps via flat-sky relations.\n    \"\"\"\n    # Forward FFTs\n    Q_k = np.fft.fft2(Q)\n    U_k = np.fft.fft2(U)\n\n    # Wavevector angle\n    phi = np.arctan2(KY, KX)\n    phi[np.isnan(phi)] = 0.0\n\n    # E(k) and B(k) in Fourier space\n    E_k = Q_k * np.cos(2.0 * phi) + U_k * np.sin(2.0 * phi)\n    B_k = -Q_k * np.sin(2.0 * phi) + U_k * np.cos(2.0 * phi)\n    return E_k, B_k\n\ndef visibility_integral(sigma, chi_star=0.5, n_steps=4097):\n    \"\"\"\n    Numerically evaluate the integral of a normalized Gaussian visibility g(chi)\n    over chi in [0, 1] using Simpson's rule.\n    g(chi) = (1 / (sqrt(2*pi)*sigma)) * exp( - (chi - chi_star)^2 / (2*sigma^2) )\n    \"\"\"\n    chi = np.linspace(0.0, 1.0, n_steps)\n    g = (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-0.5 * ((chi - chi_star) / sigma) ** 2)\n    integral = simpson(g, chi)\n    return integral\n\ndef spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma):\n    \"\"\"\n    Compute the spurious B-mode power fraction R = P_B / P_E for given anisotropy parameters.\n    \"\"\"\n    # Build baseline pure E-mode Stokes maps\n    Q, U, KX, KY, phi_grid = build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind)\n\n    # Determine the angle of the single mode k0\n    kx0 = (2.0 * np.pi) * (kx_ind / L)\n    ky0 = (2.0 * np.pi) * (ky_ind / L)\n    phi_k = np.arctan2(ky0, kx0)\n\n    # LOS integral (normalized Gaussian visibility over [0,1])\n    G = visibility_integral(sigma=sigma, chi_star=0.5, n_steps=4097)\n\n    # Rotation angle alpha from anisotropic kernel\n    delta = phi_k - phi_p\n    alpha = epsilon * G * np.sin(2.0 * delta)\n\n    # Rotate Stokes parameters\n    Qp, Up = rotate_stokes(Q, U, alpha)\n\n    # Compute E and B modes after rotation\n    E_k, B_k = eb_from_qu(Qp, Up, KX, KY)\n\n    # Compute power sums (exclude k=0 if desired; here we include all modes uniformly)\n    P_E = np.sum(np.abs(E_k) ** 2)\n    P_B = np.sum(np.abs(B_k) ** 2)\n\n    # Avoid divide-by-zero: if P_E is tiny due to numerical issues, handle gracefully\n    if P_E == 0.0:\n        return 0.0\n    R = (P_B / P_E).real  # ratio is real-valued\n    return float(R)\n\ndef solve():\n    # Fixed grid and baseline parameters per problem statement\n    N = 64\n    L = 1.0  # radians\n    amplitude = 1.0\n    kx_ind, ky_ind = 4, 0  # single nonzero mode - phi_k = 0\n\n    # Define the test cases (epsilon, phi_p, sigma)\n    test_cases = [\n        (0.0, np.pi / 4.0, 0.05),         # Case 1\n        (0.05, np.pi / 4.0, 0.05),        # Case 2\n        (0.2, np.pi / 4.0, 0.05),         # Case 3\n        (0.2, 0.0, 0.05),                 # Case 4\n        (0.2, np.pi / 8.0, 1e-3),         # Case 5\n    ]\n\n    results = []\n    for epsilon, phi_p, sigma in test_cases:\n        r = spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "尽管在全天上E模和B模是正交的，但任何实际的CMB观测都只能覆盖部分天空，这导致了所谓的E-B混合问题。在有限的天区上，部分E模信号会“泄漏”并被误认为B模，这对探测极其微弱的原始B模信号构成了重大挑战。这个练习将让你通过数值线性代数的方法，精确量化在给定天区边界下，有多少“纯B模”能够与E模泄漏完全区分开来，从而揭示观测几何形状对B模测量的基本限制。",
            "id": "3467210",
            "problem": "考虑在有限像素化区域上对宇宙微波背景（CMB）线性偏振进行平天近似离散化。设网格有 $N_x \\times N_y$ 个像素，单位间距。令 $f[i,j]$ 表示在整数像素坐标 $0 \\le i  N_x$，$0 \\le j  N_y$ 处的一个标量场。使用网格外的零延拓定义离散二阶导数算子：\n- $D_{xx} f[i,j] = f[i+1,j] - 2 f[i,j] + f[i-1,j]$，约定在网格之外求值的 $f$ 为 $0$，\n- $D_{yy} f[i,j] = f[i,j+1] - 2 f[i,j] + f[i,j-1]$，约定同上，\n- $D_{xy} f[i,j] = \\dfrac{1}{4}\\left(f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1]\\right)$，约定同上。\n\n定义从一个标量势到每个像素的斯托克斯参数 $(Q,U)$ 的两个线性映射：\n- $E$ 模映射产生\n$$Q_E = D_{xx}\\,\\phi_E - D_{yy}\\,\\phi_E,\\quad U_E = 2\\,D_{xy}\\,\\phi_E.$$\n- $B$ 模映射产生\n$$Q_B = -2\\,D_{xy}\\,\\phi_B,\\quad U_B = D_{xx}\\,\\phi_B - D_{yy}\\,\\phi_B.$$\n\n令 $\\mathcal{M}$ 是一个选择有限区域（一组像素）的二元掩模。掩模后的偏振数据向量仅拼接掩模内像素的 $Q$ 和 $U$ 值，形成一个 $2N_{\\text{mask}}$ 维的观测空间，其中 $N_{\\text{mask}}$ 是掩模内像素的数量。令 $M_E$ 和 $M_B$ 分别是线性映射 $\\phi_E \\mapsto (Q_E,U_E)$ 和 $\\phi_B \\mapsto (Q_B,U_B)$ 在限制于掩模内像素时的矩阵表示（相对于标准基）。因此 $M_E$ 和 $M_B$ 是大小为 $2N_{\\text{mask}} \\times (N_x N_y)$ 的实数矩阵。\n\n我们定义子空间 $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$ 和 $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$。纯 $B$ 偏振模空间是 $T \\cap S^{\\perp}$，相对于掩模观测空间上的标准欧几里得内积。我们感兴趣的量是纯 $B$ 模空间的维度，即与所有掩模内 $E$ 模模式正交的、线性无关的掩模内 $B$ 模偏振模式的数量。\n\n任务：实现一个程序，对于网格上每个指定的区域几何形状（掩模），使用上述定义构造 $M_E$ 和 $M_B$，使用奇异值分解（SVD）计算 $S$ 和 $T$ 的标准正交基，并为每个测试用例输出 $T \\cap S^{\\perp}$ 的维度。使用基于奇异值的数值稳健的秩判定规则来确定：\n- $S$ 和 $T$ 的维度，以及\n- $S$ 和 $T$ 基之间的交叉格拉姆矩阵的秩。\n\n您不得假定周期性；请使用上面描述的零延拓边界约定。所有计算都是无量纲的，不涉及物理单位。\n\n测试套件（每个用例定义 $(N_x,N_y)$ 和掩模几何形状）：\n1. 用例 1（完整正方形）：$N_x = 8$，$N_y = 8$，掩模包含所有像素。\n2. 用例 2（薄矩形）：$N_x = 12$，$N_y = 4$，掩模包含所有像素。\n3. 用例 3（L 形）：$N_x = 10$，$N_y = 10$，掩模包含满足 $(i \\le 4)$ 或 $(j \\le 4)$（零索引）的像素，即一个垂直条和一个水平条的并集。\n4. 用例 4（离散圆盘）：$N_x = 11$，$N_y = 11$，掩模包含所有满足 $(i - c_x)^2 + (j - c_y)^2 \\le r^2$ 的像素，其中 $c_x = 5$，$c_y = 5$，$r = 5$。\n5. 用例 5（小区域）：$N_x = 3$，$N_y = 3$，掩模包含所有像素。\n\n算法要求：\n- 将线性算子 $D_{xx}$、$D_{yy}$、$D_{xy}$ 构造为 $\\mathbb{R}^{N_x N_y}$ 上的矩阵，并与零延拓规则保持一致。\n- 通过堆叠与掩模内像素处的 $Q$ 和 $U$ 对应的行来组装 $M_E$ 和 $M_B$。\n- 通过保留与高于数值容差的奇异值对应的左奇异向量，从 $M_E$ 和 $M_B$ 的 SVD 中计算 $S$ 和 $T$ 的标准正交基 $U_E$ 和 $U_B$。\n- 计算交叉格拉姆矩阵 $C = U_E^\\top U_B$ 并确定其数值秩。\n- 为每个用例返回 $T \\cap S^{\\perp}$ 的维度（整数）。\n\n数值容差：\n- 对于一个奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots$ 的矩阵 $A$，将其数值秩定义为满足 $\\sigma_k  \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$ 的 $\\sigma_k$ 的数量，其中 $\\varepsilon_{\\text{abs}} = 10^{-10}$ 且 $\\varepsilon_{\\text{rel}} = 10^{-9}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与上述五个用例相同。例如，输出格式为 $[n_1,n_2,n_3,n_4,n_5]$，其中每个 $n_k$ 是用例 $k$ 的纯 $B$ 模空间的整数维度。",
            "solution": "核心任务是为一组离散采样的宇宙微波背景（CMB）偏振图确定纯 $B$ 模子空间的维度。这个子空间表示为 $T \\cap S^{\\perp}$，由所有与每个可能的掩模内 $E$ 模模式正交的掩模内 $B$ 模偏振模式组成。其维度量化了因天空覆盖不完全而导致的 $E$ 模泄漏（一种称为 E-B 混合的现象）无法产生的独特 $B$ 模信号的数量。因此，该问题是一个定义明确的数值线性代数练习，其基础是 CMB 偏振分析的原理。\n\n解决方案通过一系列逻辑和算法步骤进行，从问题的抽象定义到具体的数值结果。\n\n首先，我们对空间和感兴趣的量进行形式化定义。掩模网格上所有可能的 $E$ 模模式构成一个子空间 $S = \\mathrm{range}(M_E) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$，其中 $M_E$ 是将 $E$ 模势 $\\phi_E$ 映射到掩模内斯托克斯参数 $(Q_E, U_E)$ 的线性算子。类似地，$B$ 模模式构成一个子空间 $T = \\mathrm{range}(M_B) \\subset \\mathbb{R}^{2N_{\\text{mask}}}$。我们旨在计算 $\\mathrm{dim}(T \\cap S^{\\perp})$。\n\n令 $U_E$ 和 $U_B$ 为矩阵，其列分别构成子空间 $S$ 和 $T$ 的标准正交基。$U_E$ 的列数为 $r_E = \\mathrm{dim}(S) = \\mathrm{rank}(M_E)$，$U_B$ 的列数为 $r_B = \\mathrm{dim}(T) = \\mathrm{rank}(M_B)$。任何向量 $v \\in T$ 都可以表示为 $T$ 的基向量的线性组合：$v = U_B c$，其中 $c \\in \\mathbb{R}^{r_B}$ 是某个系数向量。要使该向量 $v$ 属于 $S$ 的正交补空间（记为 $S^{\\perp}$），它必须与 $S$ 的所有基向量正交。此条件表示为 $U_E^\\top v = 0$。代入 $v$ 的表达式，我们得到关于系数向量 $c$ 的条件：\n$$\nU_E^\\top (U_B c) = (U_E^\\top U_B)c = 0\n$$\n令 $C = U_E^\\top U_B$ 为 $S$ 和 $T$ 的基向量之间的内积的交叉格拉姆矩阵。该条件简化为 $C c = 0$。这意味着与 $T \\cap S^{\\perp}$ 中的模式对应的系数向量 $c$ 必须位于 $C$ 的零空间（核）中，即 $c \\in \\ker(C)$。\n由于 $U_B$ 的列是标准正交的，从 $c$ 到 $U_B c$ 的映射是一个等距映射。因此，纯 $B$ 模空间的维度等于 $C$ 的零空间的维度：\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = \\mathrm{dim}(\\ker(C))\n$$\n根据应用于由 $C: \\mathbb{R}^{r_B} \\to \\mathbb{R}^{r_E}$ 表示的线性映射的秩-零度定理，我们有：\n$$\n\\mathrm{dim}(\\ker(C)) + \\mathrm{rank}(C) = \\mathrm{dim}(\\mathbb{R}^{r_B}) = r_B\n$$\n因此，纯 $B$ 模空间的维度由下式给出：\n$$\n\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - \\mathrm{rank}(C) = \\mathrm{rank}(M_B) - \\mathrm{rank}(U_E^\\top U_B)\n$$\n\n计算此维度的算法如下：\n1.  **离散化与算子构造**：对于大小为 $N_x \\times N_y$ 的网格，我们将任何标量场 $f[i,j]$ 向量化为 $\\mathbb{R}^{N_{\\text{pix}}}$ 中的一个向量，其中 $N_{\\text{pix}} = N_x N_y$。我们使用行主序，其中位于 $(i,j)$ 的像素的一维索引为 $k = i \\cdot N_y + j$。离散微分算子 $D_{xx}$、$D_{yy}$ 和 $D_{xy}$ 被构造为 $N_{\\text{pix}} \\times N_{\\text{pix}}$ 的矩阵。每个算子的定义，包括零延拓边界条件，决定了其矩阵表示中的非零元素。例如，$D_{xx}$ 对像素 $(i,j)$ 的作用涉及其邻居 $(i\\pm 1, j)$。这转化为在矩阵 $D_{xx}$ 的第 $k$ 行中，设置列 $k$（对应 $-2f[i,j]$ 项）和列 $k \\pm N_y$（对应 $f[i \\pm 1, j]$ 项）的元素值，并需在邻居会超出网格的边界处小心处理。\n\n2.  **观测矩阵组装**：构造从势到掩模内斯托克斯参数的线性映射 $M_E$ 和 $M_B$。这些是大小为 $(2N_{\\text{mask}}) \\times N_{\\text{pix}}$ 的矩阵。$M_E$ 通过垂直堆叠两个块构成：第一个块包含算子 $D_{xx} - D_{yy}$ 中对应于 $N_{\\text{mask}}$ 个掩模内像素的 $Q$ 测量值的行，第二个块包含 $2D_{xy}$ 中对应于 $U$ 测量值的行。$M_B$ 以类似方式从算子 $-2D_{xy}$ 和 $D_{xx} - D_{yy}$ 构造。\n\n3.  **标准正交基计算**：使用奇异值分解（SVD）求出 $M_E$ 和 $M_B$ 值域的标准正交基 $U_E$ 和 $U_B$。对于一个矩阵 $M$，其 SVD 为 $M = U\\Sigma V^\\top$。$U$ 的列（左奇异向量）中对应于 $\\Sigma$ 中非零奇异值的部分构成了 $\\mathrm{range}(M)$ 的一个标准正交基。\n\n4.  **数值秩**：在有限精度算术中，我们使用一个数值标准来判断一个奇异值是否有效非零。一个矩阵的数值秩是其奇异值 $\\sigma_k$ 中满足 $\\sigma_k  \\max\\{ \\varepsilon_{\\text{abs}}, \\varepsilon_{\\text{rel}} \\,\\sigma_1 \\}$ 的数量，其中 $\\sigma_1$ 是最大的奇异值，$\\varepsilon_{\\text{abs}} = 10^{-10}$，且 $\\varepsilon_{\\text{rel}} = 10^{-9}$。此规则用于确定 $r_E = \\mathrm{rank}(M_E)$、$r_B = \\mathrm{rank}(M_B)$，以及最终的 $r_C = \\mathrm{rank}(C)$。\n\n5.  **最终计算**：一旦确定了标准正交基 $U_E$（一个 $2N_{\\text{mask}} \\times r_E$ 矩阵）和 $U_B$（一个 $2N_{\\text{mask}} \\times r_B$ 矩阵），就计算交叉格拉姆矩阵 $C = U_E^\\top U_B$。通过 SVD 求出其数值秩 $r_C$。每个测试用例的最终答案是整数 $\\mathrm{dim}(T \\cap S^{\\perp}) = r_B - r_C$。此过程系统地应用于每个指定的网格几何形状和掩模。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the E/B mode separation problem for all specified test cases.\n    \"\"\"\n    \n    # Numerical tolerances for rank determination\n    eps_abs = 1e-10\n    eps_rel = 1e-9\n\n    test_cases = [\n        {'name': 'Case 1 (full square)', 'Nx': 8, 'Ny': 8, 'mask_type': 'full'},\n        {'name': 'Case 2 (thin rectangle)', 'Nx': 12, 'Ny': 4, 'mask_type': 'full'},\n        {'name': 'Case 3 (L-shape)', 'Nx': 10, 'Ny': 10, 'mask_type': 'L-shape'},\n        {'name': 'Case 4 (discrete disk)', 'Nx': 11, 'Ny': 11, 'mask_type': 'disk'},\n        {'name': 'Case 5 (tiny patch)', 'Nx': 3, 'Ny': 3, 'mask_type': 'full'},\n    ]\n\n    results = []\n\n    def get_numerical_rank(s, eps_abs, eps_rel):\n        \"\"\"Computes the numerical rank from a list of singular values.\"\"\"\n        if s.size == 0:\n            return 0\n        s_max = s[0]\n        # s_max can be 0 for a zero matrix.\n        if s_max  eps_abs: # Effectively zero matrix\n            return 0\n        tolerance = max(eps_abs, eps_rel * s_max)\n        return np.sum(s > tolerance)\n\n    def create_derivative_matrices(Nx, Ny):\n        \"\"\"Creates matrix representations of D_xx, D_yy, D_xy operators.\"\"\"\n        N_pix = Nx * Ny\n        D_xx = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_yy = np.zeros((N_pix, N_pix), dtype=np.float64)\n        D_xy = np.zeros((N_pix, N_pix), dtype=np.float64)\n\n        for i in range(Nx):\n            for j in range(Ny):\n                k = i * Ny + j\n                \n                # D_xx: f[i+1,j] - 2f[i,j] + f[i-1,j]\n                D_xx[k, k] = -2.0\n                if i > 0:\n                    D_xx[k, k - Ny] = 1.0\n                if i  Nx - 1:\n                    D_xx[k, k + Ny] = 1.0\n\n                # D_yy: f[i,j+1] - 2f[i,j] + f[i,j-1]\n                D_yy[k, k] = -2.0\n                if j > 0:\n                    D_yy[k, k - 1] = 1.0\n                if j  Ny - 1:\n                    D_yy[k, k + 1] = 1.0\n                    \n                # D_xy: 1/4 * (f[i+1,j+1] - f[i+1,j-1] - f[i-1,j+1] + f[i-1,j-1])\n                if i  Nx - 1 and j  Ny - 1:\n                    D_xy[k, k + Ny + 1] = 0.25\n                if i  Nx - 1 and j > 0:\n                    D_xy[k, k + Ny - 1] = -0.25\n                if i > 0 and j  Ny - 1:\n                    D_xy[k, k - Ny + 1] = -0.25\n                if i > 0 and j > 0:\n                    D_xy[k, k - Ny - 1] = 0.25\n                    \n        return D_xx, D_yy, D_xy\n\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        \n        # Define mask for each case\n        if case['mask_type'] == 'full':\n            mask = np.ones((Nx, Ny), dtype=bool)\n        elif case['mask_type'] == 'L-shape':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            for i in range(Nx):\n                for j in range(Ny):\n                    if i = 4 or j = 4:\n                        mask[i, j] = True\n        elif case['mask_type'] == 'disk':\n            mask = np.zeros((Nx, Ny), dtype=bool)\n            cx, cy, r = 5.0, 5.0, 5.0\n            for i in range(Nx):\n                for j in range(Ny):\n                    if (i - cx)**2 + (j - cy)**2 = r**2:\n                        mask[i, j] = True\n        \n        N_pix = Nx * Ny\n        masked_indices = np.where(mask.flatten())[0]\n        N_mask = len(masked_indices)\n\n        if N_mask == 0:\n            results.append(0)\n            continue\n\n        D_xx, D_yy, D_xy = create_derivative_matrices(Nx, Ny)\n        \n        # Assemble E-mode and B-mode operators\n        L1 = D_xx - D_yy\n        L2 = 2 * D_xy\n\n        # Construct masked observation matrices M_E and M_B\n        Q_rows_E = L1[masked_indices, :]\n        U_rows_E = L2[masked_indices, :]\n        M_E = np.vstack([Q_rows_E, U_rows_E])\n\n        Q_rows_B = -L2[masked_indices, :]\n        U_rows_B = L1[masked_indices, :]\n        M_B = np.vstack([Q_rows_B, U_rows_B])\n\n        # Compute orthonormal basis for S = range(M_E) via SVD\n        U_svd_E, s_E, _ = np.linalg.svd(M_E, full_matrices=False)\n        rank_E = get_numerical_rank(s_E, eps_abs, eps_rel)\n        U_E = U_svd_E[:, :rank_E]\n        \n        # Compute orthonormal basis for T = range(M_B) via SVD\n        U_svd_B, s_B, _ = np.linalg.svd(M_B, full_matrices=False)\n        rank_B = get_numerical_rank(s_B, eps_abs, eps_rel)\n        U_B = U_svd_B[:, :rank_B]\n        \n        # Compute rank of cross-gram matrix C = U_E^T @ U_B\n        if rank_E == 0 or rank_B == 0:\n            rank_C = 0\n        else:\n            C = U_E.T @ U_B\n            s_C = np.linalg.svd(C, compute_uv=False)\n            rank_C = get_numerical_rank(s_C, eps_abs, eps_rel)\n\n        # Dimension of pure-B space is rank(M_B) - rank(C)\n        dim_pure_B = rank_B - rank_C\n        results.append(dim_pure_B)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}