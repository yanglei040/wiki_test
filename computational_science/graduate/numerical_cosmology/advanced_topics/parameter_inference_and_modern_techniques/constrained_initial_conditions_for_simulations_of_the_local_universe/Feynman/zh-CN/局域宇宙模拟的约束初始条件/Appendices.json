{
    "hands_on_practices": [
        {
            "introduction": "在运行任何模拟之前，一个关键的初始步骤是确定起始红移 $z_i$。如果起始红移太晚，用于设置初始粒子位移的线性或低阶微扰理论将失效。这个练习  将指导您基于拉格朗日微扰理论（Lagrangian Perturbation Theory）推导基本准则，以确保您的模拟在初始条件物理上可靠且数值上稳定的状态下启动。您将得出一个实用的 $z_i$ 公式，该公式在数值精度和计算成本之间取得了平衡。",
            "id": "3468236",
            "problem": "您正在为本域宇宙的宇宙学$N$体模拟准备约束初始条件，其中位移场是通过维纳滤波器从观测到的本动速度重构，并增加了小尺度模式。为确保可靠的初始化，必须选择初始红移$z_i$，使得在模拟开始时同时满足两个要求。\n\n分析基于拉格朗日微扰理论 (LPT)，该理论将在尺度因子$a$时从拉格朗日坐标$\\boldsymbol{q}$到欧拉坐标$\\boldsymbol{x}$的共动映射建模为位移场的微扰级数，其中一阶 (Zel’dovich) 和二阶修正由增长因子表征。假设早期膨胀可由Einstein–de Sitter (EdS) 宇宙很好地描述，并进行归一化，使得一阶增长因子为$D_1(1)=1$，二阶增长因子为$D_2(1)=-\\frac{3}{7}$（标准EdS归一化）。将均方根 (RMS) 定义为在模拟体积上的均方根 (RMS) 范数。\n\n在与初始红移$z_i$对应的尺度因子$a_i$处，施加以下两个判据：\n\n1. 在$a_i$处，最大的一阶 (1LPT) 粒子位移是网格间距的一个小部分，即：\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta,\n$$\n其中，$s_{\\max}$是在$z=0$时重构的1LPT位移场的最大值，$\\Delta$是共动网格间距，$\\epsilon$是所选的比例。\n\n2. 在$a_i$处，二阶 (2LPT) 修正的均方根振幅相对于一阶 (1LPT) 项的均方根振幅是次主导的，\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s,\n$$\n其中，$\\sigma_s$和$\\sigma_t$分别是$z=0$时1LPT和2LPT位移场的均方根值，$\\eta$是量化初始时所需次主导程度的一个所选小量。\n\n假设早期为EdS增长，并采用上述归一化下$D_1(a)$和$D_2(a)$的标准EdS标度关系。从第一性原理出发，推导同时满足这两个判据的最小$z_i$的闭式表达式。然后，使用以下适用于本域宇宙约束设置的科学上合理的参数来计算该表达式的值：\n- 网格间距 $\\Delta = 0.5\\,h^{-1}\\,\\mathrm{Mpc}$,\n- 比例 $\\epsilon = 0.2$,\n- $z=0$时的最大1LPT位移 $s_{\\max} = 5.0\\,h^{-1}\\,\\mathrm{Mpc}$,\n- $z=0$时的RMS 1LPT位移 $\\sigma_s = 1.5\\,h^{-1}\\,\\mathrm{Mpc}$,\n- $z=0$时的RMS 2LPT位移 $\\sigma_t = 3.0\\,h^{-1}\\,\\mathrm{Mpc}$,\n- 次主导参数 $\\eta = 0.1$.\n\n将最终答案表示为无量纲数$z_i$，并四舍五入到三位有效数字。最终答案中不应包含任何单位。",
            "solution": "问题陈述经评估有效。它在科学上基于标准的宇宙学微扰理论，问题设定良好，目标明确，数据充分，并且没有内部矛盾或歧义。所提供的参数对于本域宇宙的模拟是物理上合理的。\n\n目标是确定$N$体模拟的最小初始红移$z_i$，这对应于最大的初始尺度因子$a_i = (1+z_i)^{-1}$，使得两个判据同时得到满足。该分析基于早期宇宙的Einstein–de Sitter (EdS) 模型。\n\n在EdS宇宙中，一阶 (1LPT) 和二阶 (2LPT) 增长因子随尺度因子$a$的标度关系为$D_1(a) \\propto a$和$D_2(a) \\propto a^2$。问题给出了在今天 ($z=0$，对应于$a=1$) 的归一化：$D_1(1)=1$和$D_2(1)=-3/7$。使用此归一化，我们可以写出在任意尺度因子$a$处的增长因子的显式表达式：\n$$\nD_1(a) = D_1(1) \\left(\\frac{a}{1}\\right) = a\n$$\n$$\nD_2(a) = D_2(1) \\left(\\frac{a}{1}\\right)^2 = -\\frac{3}{7}a^2\n$$\n因此，这些增长因子在初始尺度因子$a_i$处的绝对值为：\n$$\n|D_1(a_i)| = a_i\n$$\n$$\n|D_2(a_i)| = \\left|-\\frac{3}{7}a_i^2\\right| = \\frac{3}{7}a_i^2\n$$\n因为$a_i$是正数。\n\n我们现在将这两个判据应用于初始尺度因子$a_i$。\n\n**判据1：最大1LPT位移**\n第一个判据限制了模拟开始时的最大粒子位移：\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\n代入$|D_1(a_i)| = a_i$，我们得到：\n$$\na_i\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\n这给初始尺度因子$a_i$施加了一个上限：\n$$\na_i \\le \\frac{\\epsilon \\Delta}{s_{\\max}}\n$$\n\n**判据2：2LPT修正的次主导性**\n第二个判据确保位移场的二阶修正在均方根意义上次主导于一阶项：\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s\n$$\n代入$|D_1(a_i)|$和$|D_2(a_i)|$的表达式：\n$$\n\\left(\\frac{3}{7}a_i^2\\right) \\sigma_t \\le \\eta\\, a_i\\, \\sigma_s\n$$\n由于$a_i > 0$，我们可以在不等式两边同时除以$a_i$而不改变不等号方向：\n$$\n\\frac{3}{7}a_i\\, \\sigma_t \\le \\eta\\, \\sigma_s\n$$\n这得出了$a_i$的第二个上限：\n$$\na_i \\le \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\n$$\n\n**组合约束与最小红移**\n为了使模拟能够有效初始化，两个判据必须同时满足。这意味着$a_i$必须小于或等于两个导出的上限。最严格的约束决定了$a_i$的最大允许值：\n$$\na_{i, \\text{max}} = \\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)\n$$\n红移$z$和尺度因子$a$之间的关系是$z = a^{-1} - 1$。这是一个单调递减函数。因此，最小初始红移$z_i$对应于最大初始尺度因子$a_{i, \\text{max}}$。\n$$\nz_i = \\frac{1}{a_{i, \\text{max}}} - 1 = \\frac{1}{\\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)} - 1\n$$\n此表达式可使用性质$1/\\min(x,y) = \\max(1/x, 1/y)$重写为：\n$$\nz_i = \\max\\left(\\frac{s_{\\max}}{\\epsilon \\Delta}, \\frac{3 \\sigma_t}{7 \\eta \\sigma_s}\\right) - 1\n$$\n这就是所求的最小初始红移$z_i$的闭式表达式。\n\n**数值计算**\n我们现在将给定的参数值代入此表达式。参数如下：\n- $\\Delta = 0.5\\,h^{-1}\\,\\mathrm{Mpc}$\n- $\\epsilon = 0.2$\n- $s_{\\max} = 5.0\\,h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_s = 1.5\\,h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_t = 3.0\\,h^{-1}\\,\\mathrm{Mpc}$\n- $\\eta = 0.1$\n\n所有长度单位 ($h^{-1}\\,\\mathrm{Mpc}$) 在比率中被消去，剩下所需的无量纲量。\n我们来计算$\\max$函数的两个参数。\n\n第一个参数（来自判据1）：\n$$\n\\frac{s_{\\max}}{\\epsilon \\Delta} = \\frac{5.0}{0.2 \\times 0.5} = \\frac{5.0}{0.1} = 50\n$$\n\n第二个参数（来自判据2）：\n$$\n\\frac{3 \\sigma_t}{7 \\eta \\sigma_s} = \\frac{3 \\times 3.0}{7 \\times 0.1 \\times 1.5} = \\frac{9.0}{1.05} = \\frac{900}{105} = \\frac{180}{21} = \\frac{60}{7} \\approx 8.5714\n$$\n\n现在我们取这两个值的最大值：\n$$\n\\max\\left(50, \\frac{60}{7}\\right) = 50\n$$\n第一个判据是更严格的约束。因此，$1+z_i$的最小值为$50$。\n最小初始红移是：\n$$\nz_i = 50 - 1 = 49\n$$\n问题要求答案四舍五入到三位有效数字。精确值为$49$。表示为三位有效数字即为$49.0$。",
            "answer": "$$\n\\boxed{49.0}\n$$"
        },
        {
            "introduction": "构建约束性模拟的本质是从晚期观测数据（例如星系本动速度）中重建初始密度场。这个练习  深入探讨了这一过程的核心算法，要求您实现一个连接观测到的视向速度与潜在密度场的交叉协方差算符。通过使用快速傅里叶变换（FFT），您将构建一个强大的工具，它构成了维纳滤波及其他重建方法的核心。",
            "id": "3468238",
            "problem": "考虑一个边长为 $L$ 的周期性立方体盒子中，在具有 $N^3$ 个点的均匀 $\\mathbb{Z}^3$ 网格上离散化的统计均匀且各向同性的高斯初始密度对比场 $\\delta(\\mathbf{x})$。在宇宙学微扰理论的线性区域，本动速度场 $\\mathbf{v}(\\mathbf{x})$ 通过连续性方程与 $\\delta(\\mathbf{x})$ 相关。在平面平行近似下，固定视线方向与 $\\hat{\\mathbf{z}}$ 轴对齐，观测响应算子 $\\mathbf{C}$ 通过 $v_r(\\mathbf{x}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})$ 将 $\\mathbf{v}(\\mathbf{x})$ 映射到径向速度标量场 $v_r(\\mathbf{x})$。令增长前因子 $g$ 表示组合 $g \\equiv a f H$，其中 $a$ 是尺度因子，$f$ 是对数增长率，$H$ 是哈勃参数，所有这些都在同一时刻进行评估。\n\n假设线性理论、周期性边界条件以及与数值库实现的离散傅里叶变换一致的快速傅里叶变换（FFT）约定。在傅里叶空间中，本动速度和密度对比度之间的关系在大尺度上得到了很好的检验，可以写成 $\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})$，其中 $\\mathbf{k}$ 是波矢量，$k = \\|\\mathbf{k}\\|$，$i$ 是虚数单位。密度场的信号协方差在傅里叶空间中是对角的，其功率谱为 $P(k)$，因此 $S(\\mathbf{k}) = P(k)$。作用于实空间径向速度场 $d(\\mathbf{x})$ 的交叉协方差算子 $\\mathbf{S}\\mathbf{C}^{\\top}$ 可以实现为一个卷积，其傅里叶空间核与 $i \\mathbf{k}/k^2$ 乘以功率谱成正比。使用平面平行近似 $\\hat{\\mathbf{r}} = \\hat{\\mathbf{z}}$，相关的标量核变为\n$$\nK(\\mathbf{k}) = g \\, P(k) \\left(-i\\right)\\,\\frac{k_z}{k^2},\n$$\n并采用约定 $K(\\mathbf{k} = \\mathbf{0}) = 0$ 以避免在零波数处的奇异性。\n\n从包含以下内容的基础出发：\n- 连续性方程和线性理论关系 $\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})$。\n- 统计均匀性和各向同性，具有对角信号协方差 $S(\\mathbf{k}) = P(k)$。\n- 通过 $v_r(\\mathbf{x}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})$ 的观测响应 $\\mathbf{C}$ 的定义。\n\n推导并实现一个算法，该算法使用 FFT 在网格上构建 $\\mathbf{S}\\mathbf{C}^{\\top}$ 并将其应用于给定的实空间径向速度场 $d(\\mathbf{x})$。您的实现必须：\n- 使用计算为 $k_\\alpha = \\frac{2\\pi}{L} n_\\alpha$（其中 $n_\\alpha \\in \\{-\\lfloor N/2 \\rfloor, \\dots, \\lfloor (N-1)/2 \\rfloor\\}$ 且 $\\alpha \\in \\{x,y,z\\}$）的离散波数，这与标准 FFT 频率约定一致。\n- 当 $k^2 = 0$ 时，将核 $K(\\mathbf{k})$ 设置为零。\n- 使用各向同性功率谱模型 $P(k) = A \\exp\\left[-\\left(\\frac{k}{k_c}\\right)^2\\right]$，其中 $A$ 和 $k_c$ 是常数。\n\n定义以下输入参数集和场的测试套件（在此问题中所有量都是无量纲的；不要附加物理单位）：\n- 测试用例 1：$N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$。输入场为 $d(\\mathbf{x}) = \\sin\\left(\\frac{2\\pi}{L} z\\right)$，与 $x$ 和 $y$ 无关。\n- 测试用例 2：$N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$。输入场恒为零，$d(\\mathbf{x}) = 0$。\n- 测试用例 3：$N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$。输入场为 $d(\\mathbf{x}) = \\sin\\left(\\frac{2\\pi}{L} x\\right)$，与 $y$ 和 $z$ 无关。\n- 测试用例 4：$N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$。输入场是在原点索引处的单个网格单元脉冲，$d(\\mathbf{x}) = 1$ 在 $(0,0,0)$ 处，其他地方 $d(\\mathbf{x}) = 0$。\n\n对于每个测试用例，通过以下步骤计算实空间输出场 $\\delta_{\\text{out}}(\\mathbf{x}) = \\left(\\mathbf{S}\\mathbf{C}^{\\top}\\right) d(\\mathbf{x})$：\n- 对 $d(\\mathbf{x})$ 进行正向 FFT 以获得 $D(\\mathbf{k})$。\n- 乘以核以获得 $\\Delta(\\mathbf{k}) = K(\\mathbf{k}) D(\\mathbf{k})$。\n- 进行逆 FFT 到实空间，取实部，以获得 $\\delta_{\\text{out}}(\\mathbf{x})$。\n\n对于每个测试用例，报告一个等于 $\\delta_{\\text{out}}(\\mathbf{x})$ 的均方根振幅的标量结果，定义为\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N^3} \\sum_{\\mathbf{x}} \\left[\\delta_{\\text{out}}(\\mathbf{x})\\right]^2 }。\n$$\n\n您的程序应生成单行输出，其中包含按测试用例 1 到 4 的顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$。不需要物理单位；所有输出都是纯数字。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于线性宇宙学微扰理论的框架，在数学上是适定的，并为数值实现提供了一套完整且一致的参数和指令。问题是客观的，没有歧义。我现在将着手提供一个完整的解决方案。\n\n### 理论基础与算法设计\n\n该问题要求实现一个线性算子 $\\mathbf{S}\\mathbf{C}^{\\top}$，它作用于实空间径向速度场 $d(\\mathbf{x})$，以产生一个实空间密度场 $\\delta_{\\text{out}}(\\mathbf{x})$。在为宇宙学模拟生成受约束的初始条件的背景下，此操作是基础性的，其目标是构建一个与观测数据（例如，星系的径向速度）一致的密度场。算子 $\\mathbf{S}\\mathbf{C}^{\\top}$ 表示我们希望估计的信号（密度场 $\\delta$）与可观测量（径向速度场 $v_r$）之间的交叉协方差。\n\n让我们正式推导这个算子的结构。\n信号是密度对比场 $\\delta(\\mathbf{x})$。\n本动速度场 $\\mathbf{v}(\\mathbf{x})$ 在线性区域通过连续性方程与密度场相关。在傅里叶空间中，这种关系表示为：\n$$\n\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})\n$$\n其中 $\\mathbf{k}$ 是波矢量，$k = \\|\\mathbf{k}\\|$，$i$ 是虚数单位，$g$ 是增长前因子。\n\n观测响应算子 $\\mathbf{C}$ 将矢量速度场映射到标量径向速度场。在视线与 $\\hat{\\mathbf{z}}$ 轴对齐的平面平行近似下，这是一个简单的投影：\n$$\nv_r(\\mathbf{x}) = \\mathbf{C}[\\mathbf{v}(\\mathbf{x})] = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})\n$$\n在傅里叶空间中，这个投影变为：\n$$\nv_r(\\mathbf{k}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{k}) = \\hat{\\mathbf{z}} \\cdot \\left( g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k}) \\right) = g \\, i \\, \\frac{k_z}{k^2} \\, \\delta(\\mathbf{k})\n$$\n这个方程将可观测量 $v_r$ 的傅里叶模式与基础信号 $\\delta$ 的傅里叶模式联系起来。\n\n算子 $\\mathbf{S}\\mathbf{C}^{\\top}$ 是信号 $\\delta$ 和数据 $v_r$ 之间的交叉协方差，表示为 $\\langle \\delta v_r^\\top \\rangle$。对于统计均匀场，在傅里叶空间中工作最为方便。实空间中的卷积算子作用等效于傅里叶空间中的乘法。这种乘法的核是两个场之间的交叉功率谱。\n\n我们来计算交叉功率谱，它是交叉协方差算子的傅里叶变换。我们通过关系 $\\langle \\delta(\\mathbf{k}) v_r^*(\\mathbf{k'}) \\rangle = \\delta_{\\mathbf{k},\\mathbf{k'}} P_{\\delta, v_r}(\\mathbf{k})$ （对于离散傅里叶变换，相差一个体积因子）来定义交叉功率谱 $P_{\\delta, v_r}(\\mathbf{k})$。\n使用 $v_r(\\mathbf{k})$ 的关系，我们得到：\n$$\nv_r^*(\\mathbf{k}) = \\left( g \\, i \\, \\frac{k_z}{k^2} \\, \\delta(\\mathbf{k}) \\right)^* = g \\, (-i) \\, \\frac{k_z}{k^2} \\, \\delta^*(\\mathbf{k})\n$$\n期望值变为：\n$$\n\\langle \\delta(\\mathbf{k}) v_r^*(\\mathbf{k}) \\rangle = \\left\\langle \\delta(\\mathbf{k}) \\left( g \\, (-i) \\, \\frac{k_z}{k^2} \\, \\delta^*(\\mathbf{k}) \\right) \\right\\rangle = g \\, (-i) \\, \\frac{k_z}{k^2} \\langle \\delta(\\mathbf{k}) \\delta^*(\\mathbf{k}) \\rangle\n$$\n项 $\\langle \\delta(\\mathbf{k}) \\delta^*(\\mathbf{k}) \\rangle$ 是密度场的功率谱，给定为 $S(\\mathbf{k}) = P(k)$。因此，交叉功率谱核为：\n$$\nK(\\mathbf{k}) \\equiv P_{\\delta, v_r}(\\mathbf{k}) = g \\, P(k) \\, (-i) \\, \\frac{k_z}{k^2}\n$$\n这与问题陈述中提供的核相匹配。操作 $\\delta_{\\text{out}} = (\\mathbf{S}\\mathbf{C}^{\\top}) d$ 是实空间中的一个卷积。根据卷积定理，其傅里叶变换 $\\Delta_{\\text{out}}(\\mathbf{k})$ 是核的傅里叶变换 $K(\\mathbf{k})$ 与输入数据傅里叶变换 $D(\\mathbf{k})$ 的乘积。\n\n因此，计算 $\\delta_{\\text{out}}(\\mathbf{x})$ 的算法如下：\n1.  **构建 k 空间网格**：离散波矢量 $\\mathbf{k} = (k_x, k_y, k_z)$ 定义在一个 $N \\times N \\times N$ 的网格上。对于 $\\alpha \\in \\{x,y,z\\}$，分量 $k_\\alpha$ 由 $k_\\alpha = 2\\pi f_\\alpha$ 给出，其中 $f_\\alpha$ 是来自快速傅里叶变换（FFT）例程的离散频率。对于大小为 $N$、物理长度为 $L$ 的网格，频率通过 `numpy.fft.fftfreq(N, d=L/N)` 获得，其中 $d=L/N$ 是实空间网格间距。\n2.  **构建傅里叶核**：使用 k 空间网格，我们在每个点计算核 $K(\\mathbf{k})$。这涉及到计算 $k^2 = k_x^2+k_y^2+k_z^2$，$k = \\sqrt{k^2}$，功率谱 $P(k) = A \\exp[-(k/k_c)^2]$，以及最终的 $K(\\mathbf{k})$。通过按规定设置 $K(\\mathbf{0})=\\mathbf{0}$ 来处理在 $\\mathbf{k}=\\mathbf{0}$（即 $k^2=0$）处的奇异性。\n3.  **定义输入场**：对于每个测试用例，在 $N \\times N \\times N$ 网格上构建实空间输入数据场 $d(\\mathbf{x})$。\n4.  **应用算子**：\n    a.  计算输入数据的离散傅里叶变换：$D(\\mathbf{k}) = \\text{FFT}[d(\\mathbf{x})]$。标准库将其实现为 `numpy.fft.fftn`。\n    b.  将变换后的数据与核相乘：$\\Delta_{\\text{out}}(\\mathbf{k}) = K(\\mathbf{k}) \\cdot D(\\mathbf{k})$。\n    c.  计算逆傅里叶变换以在实空间中获得结果：$\\delta_{\\text{out}}(\\mathbf{x}) = \\text{IFFT}[\\Delta_{\\text{out}}(\\mathbf{k})]$。这由 `numpy.fft.ifftn` 实现。根据对称性 $K(-\\mathbf{k}) = K^*(\\mathbf{k})$ 可证明，结果应该是一个实数场（在数值精度范围内）。我们取结果的实部，以丢弃由浮点不精确性产生的任何微小虚部。\n5.  **计算 RMS**：最终要求的输出是结果场 $\\delta_{\\text{out}}(\\mathbf{x})$ 的均方根（RMS）振幅，定义为 $\\mathrm{RMS} = \\sqrt{\\frac{1}{N^3} \\sum_{\\mathbf{x}} [\\delta_{\\text{out}}(\\mathbf{x})]^2}$。这等效于 `numpy.sqrt(numpy.mean(numpy.square(output_field)))`。\n\n对提供的四个测试用例中的每一个都实施此过程。\n- **情况 1**：$d(\\mathbf{x}) = \\sin(\\frac{2\\pi}{L} z)$。输入是沿视线方向的单一平面波。其傅里叶变换仅在波矢量 $\\mathbf{k}=(0,0, \\pm 2\\pi/L)$ 处有功率。由于这些模式的 $k_z \\neq 0$，核 $K(\\mathbf{k})$ 非零，我们期望得到一个非零输出。\n- **情况 2**：$d(\\mathbf{x}) = 0$。这是一个线性度检查。零的 FFT 是零，所以输出必须为零。\n- **情况 3**：$d(\\mathbf{x}) = \\sin(\\frac{2\\pi}{L} x)$。输入是一个垂直于视线方向的平面波。其傅里叶变换仅在 $\\mathbf{k}=(\\pm 2\\pi/L, 0, 0)$ 处有功率。对于这些模式，$k_z=0$，这使得核 $K(\\mathbf{k})=0$。输出必须为零，这表明在此模型中，没有径向分量的模式不会引起密度涨落。\n- **情况 4**：$d(\\mathbf{x})$ 是原点处的 delta 函数。其傅里叶变换是常数，$D(\\mathbf{k})=1$。因此输出场是核本身在实空间的表示，即 $\\delta_{\\text{out}}(\\mathbf{x}) = \\text{IFFT}[K(\\mathbf{k})]$。这测试了对点状源的响应。\n\n实现将精确地遵循此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_sc_transpose(d_field, N, L, g, A, k_c):\n    \"\"\"\n    Constructs and applies the operator S*C^T to a real-space field.\n\n    Args:\n        d_field (np.ndarray): The input real-space 3D field d(x).\n        N (int): Grid dimension.\n        L (float): Box side length.\n        g (float): Growth prefactor.\n        A (float): Power spectrum amplitude.\n        k_c (float): Power spectrum characteristic scale.\n\n    Returns:\n        np.ndarray: The output real-space 3D field delta_out(x).\n    \"\"\"\n    # 1. Construct the k-space grid\n    # The sample spacing in real space is dx = L/N.\n    # The frequencies from fftfreq are in cycles per unit distance.\n    # Wavenumbers k are 2*pi times the frequency.\n    freq = np.fft.fftfreq(N, d=L / N)\n    k_vals = 2.0 * np.pi * freq\n    \n    # Create a 3D grid of wavevectors (kx, ky, kz)\n    # 'ij' indexing ensures the axes correspond to (z, y, x) if we consider\n    # numpy array indices [i, j, k] as mapping to (z, y, x).\n    # d_field is (N,N,N), numpy default is Z,Y,X access.\n    # We want kz to align with the first axis, ky with the second, kx with the third.\n    # np.meshgrid with 'ij' will make kz vary along axis 0.\n    kz, ky, kx = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n\n    # 2. Construct the Fourier Kernel K(k)\n    k_sq = kx**2 + ky**2 + kz**2\n\n    # Avoid division by zero warnings for k=0.\n    # Create a mask for non-zero k vectors.\n    k_sq_nonzero = k_sq > 0\n    k = np.zeros_like(k_sq)\n    k[k_sq_nonzero] = np.sqrt(k_sq[k_sq_nonzero])\n\n    # Power spectrum P(k) = A * exp(-(k/k_c)^2)\n    P_k = A * np.exp(- (k / k_c)**2)\n\n    # Kernel K(k) = g * P(k) * (-i) * k_z / k^2\n    Kernel = np.zeros_like(k_sq, dtype=np.complex128)\n    \n    # Apply kernel formula only where k_sq is not zero\n    Kernel[k_sq_nonzero] = g * P_k[k_sq_nonzero] * (-1j) * kz[k_sq_nonzero] / k_sq[k_sq_nonzero]\n    \n    # The problem specifies K(k=0) = 0, which is handled by the masking.\n\n    # 3. Apply the operator using FFTs\n    # a. Forward FFT of d(x)\n    D_k = np.fft.fftn(d_field)\n    \n    # b. Multiply by the kernel\n    Delta_out_k = Kernel * D_k\n    \n    # c. Inverse FFT to get delta_out(x)\n    delta_out = np.fft.ifftn(Delta_out_k)\n    \n    # The result should be real. Take the real part to discard numerical noise.\n    return np.real(delta_out)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 1},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 2},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 3},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 4},\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        N = params['N']\n        L = params['L']\n        \n        # Create the grid coordinates for defining input fields\n        coords = np.arange(N) * (L / N)\n        z, y, x = np.meshgrid(coords, coords, coords, indexing='ij')\n\n        # Define the input field d(x) for each test case\n        d_field = np.zeros((N, N, N), dtype=float)\n        case_id = params['id']\n        \n        if case_id == 1:\n            # d(x) = sin(2*pi/L * z)\n            d_field = np.sin(2 * np.pi / L * z)\n        elif case_id == 2:\n            # d(x) = 0\n            d_field = np.zeros((N, N, N), dtype=float)\n        elif case_id == 3:\n            # d(x) = sin(2*pi/L * x)\n            d_field = np.sin(2 * np.pi / L * x)\n        elif case_id == 4:\n            # d(x) is an impulse at the origin index (0,0,0)\n            d_field[0, 0, 0] = 1.0\n\n        # Apply the operator to get the output field\n        delta_out = apply_sc_transpose(d_field, N, L, params['g'], params['A'], params['k_c'])\n        \n        # Calculate the RMS amplitude of the output field\n        # RMS = sqrt(  delta_out^2 > )\n        rms_val = np.sqrt(np.mean(np.square(delta_out)))\n        \n        results.append(rms_val)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的观测数据（例如星系巡天）并不直接追踪物质场，而是追踪其有偏（biased）的版本，这给重建过程带来了显著的不确定性和简并性。最后一个练习  将分析提升到分层贝叶斯框架（Hierarchical Bayesian framework），让您能够定量地探究星系偏置与您希望约束的初始密度场之间的简并性。掌握这一概念对于理解本域宇宙约束性模拟中的真实不确定性至关重要。",
            "id": "3468245",
            "problem": "考虑一个简化的、但科学上真实的层级贝叶斯模型（Hierarchical Bayesian Model, HBM），该模型用于为本地宇宙的模拟设置约束性初始条件。其目标是评估星系偏置与初始密度约束之间的简并性，重点关注本地宇宙体积内的离散傅里叶空间模式。\n\n假设以下具有物理动机的设置。\n\n- 在傅里叶空间中，每个模式的观测星系过密度被建模为一个高斯随机变量，其均值由对初始物质过密度的线性响应给出，并带有独立的高斯噪声。具体来说，对于每个波数模式 $k$，数据模型为\n$$\ng(k) \\sim \\mathcal{N}\\big(b(k)\\,T(k,z)\\,\\delta_0(k),\\,N_g(k)\\big),\n$$\n其中 $g(k)$ 是观测到的星系过密度， $b(k)$ 是红移 $z$ 处与尺度相关的星系偏置， $T(k,z)$ 是在本地体积内将初始场转移到晚期场的线性响应， $\\delta_0(k)$ 是初始物质过密度模式， $N_g(k)$ 是噪声功率。在整个问题中，将 $z$ 设置为一个固定的晚期时刻，以便线性理论对于所选的波数是适用的。\n\n- 线性响应建模为\n$$\nT(k,z) = D(z)\\,W(k;R),\n$$\n其中 $D(z)$ 是线性增长因子（无量纲）， $W(k;R)$ 是一个有效的窗口函数，编码了本地体积内的有限体积和掩模效应。使用科学上合理的有效高斯窗口函数，\n$$\nW(k;R) = \\exp\\left(-\\frac{(kR)^2}{2}\\right),\n$$\n其中 $R$ 是有效高斯半径，单位为 $h^{-1}\\,\\mathrm{Mpc}$ ， $k$ 的单位为 $h\\,\\mathrm{Mpc}^{-1}$。\n\n- 分层贝叶斯模型的组成部分是：\n  - 初始过密度模式的先验：\n    $$\n    \\delta_0(k) \\sim \\mathcal{N}\\big(0,\\,P_0(k)\\big), \\quad P_0(k) = A\\,k^{n_s},\n    $$\n    其中 $A$ 和 $n_s$ 分别是指定类原初谱振幅和斜率的常数（无量纲）。\n  - 每个模式偏置的先验：\n    $$\n    b(k) \\sim \\mathcal{N}\\big(b_\\star,\\,\\sigma_b^2\\big),\n    $$\n    其中 $b_\\star$ 是先验平均偏置（无量纲）， $\\sigma_b$ 是先验标准差（无量纲）。\n\n- 星系噪声功率谱参数化为\n$$\nN_g(k) = N_0\\left(1 + \\left(\\frac{k}{k_0}\\right)^2\\right),\n$$\n其中 $N_0$ 和 $k_0$ 是常数（ $N_0$ 无量纲， $k_0$ 的单位为 $h\\,\\mathrm{Mpc}^{-1}$ ）。假设模式间的噪声是独立的。\n\n- HBM中 $b(k)$ 和 $\\delta_0(k)$ 之间的简并性将通过这些潜变量在联合后验最大值附近的高斯近似下的后验相关系数来量化。具体而言，对于每个 $k$，构建参数对 $\\big(\\delta_0(k),\\,b(k)\\big)$ 在一个基准点下高斯近似的 $2\\times 2$ 费雪信息矩阵，并将其求逆以获得协方差矩阵。从该协方差矩阵计算相关系数\n$$\n\\rho(k) = \\frac{\\mathrm{Cov}\\big(\\delta_0(k),\\,b(k)\\big)}{\\sqrt{\\mathrm{Var}\\big(\\delta_0(k)\\big)\\,\\mathrm{Var}\\big(b(k)\\big)}}.\n$$\n使用一个科学上可辩护的基准点，对于每个模式 $k$，该点由 $b(k)=b_\\star$ 和 $\\delta_0(k)=\\sqrt{P_0(k)}$ 给出。这一选择代表了与先验一致的典型实现振幅和以先验均值为中心的偏置，它产生了一个良定义的局域高斯近似。\n\n- 通过平均绝对相关性来总结一组离散模式上的简并性，\n$$\n\\overline{\\rho} = \\frac{1}{N_k}\\sum_{i=1}^{N_k}\\big|\\rho(k_i)\\big|,\n$$\n其中 $N_k$ 是集合中模式的数量。这个标量 $\\overline{\\rho}$ 是每个测试用例所需的输出。\n\n您的任务是实现一个程序，针对以下每个测试用例，使用上述模型计算 $\\overline{\\rho}$。\n\n使用公共波数集合\n$$\n\\{k_i\\}_{i=1}^{N_k} = [0.05,\\,0.10,\\,0.20,\\,0.30] \\quad \\text{单位为 } h\\,\\mathrm{Mpc}^{-1},\n$$\n所以 $N_k=4$。\n\n对于以下所有计算， $D(z)$ 是无量纲的， $R$ 的单位是 $h^{-1}\\,\\mathrm{Mpc}$ ， $A$ 和 $n_s$ 是无量纲的， $b_\\star$ 和 $\\sigma_b$ 是无量纲的， $N_0$ 是无量纲的， $k_0$ 的单位是 $h\\,\\mathrm{Mpc}^{-1}$ 。该问题不涉及角度。所有输出都是无量纲的标量值，并且必须以浮点数形式生成。\n\n测试套件参数集（每行一个案例）：\n- 案例1（基准线，信息丰富的数据）：$D(z)=0.95$, $R=5$, $A=0.02$, $n_s=1.0$, $b_\\star=1.4$, $\\sigma_b=0.3$, $N_0=10^{-3}$, $k_0=0.15$。\n- 案例2（高噪声边界）：$D(z)=0.95$, $R=5$, $A=0.02$, $n_s=1.0$, $b_\\star=1.4$, $\\sigma_b=0.3$, $N_0=10^{-1}$, $k_0=0.15$。\n- 案例3（偏置的弱先验，预期更强的简并性）：$D(z)=0.95$, $R=5$, $A=0.02$, $n_s=1.0$, $b_\\star=1.4$, $\\sigma_b=3.0$, $N_0=10^{-3}$, $k_0=0.15$。\n- 案例4（强窗口效应，局部信息有限）：$D(z)=0.95$, $R=15$, $A=0.02$, $n_s=1.0$, $b_\\star=1.4$, $\\sigma_b=0.3$, $N_0=10^{-3}$, $k_0=0.15$。\n\n算法要求：\n- 对于每个案例和每个 $k$：\n  - 计算 $W(k;R)=\\exp\\big(-\\frac{(kR)^2}{2}\\big)$ 然后计算 $T(k,z)=D(z)\\,W(k;R)$。\n  - 计算 $P_0(k)=A\\,k^{n_s}$ 并设置基准点 $\\delta_0(k)=\\sqrt{P_0(k)}$ 和 $b(k)=b_\\star$。\n  - 计算 $N_g(k)=N_0\\left(1 + \\left(\\frac{k}{k_0}\\right)^2\\right)$。\n  - 围绕基准点构建 $\\big(\\delta_0(k),\\,b(k)\\big)$ 的高斯近似费雪矩阵，将其求逆得到协方差矩阵，然后计算 $\\rho(k)$。\n- 对四个模式的 $\\big|\\rho(k)\\big|$ 进行平均，得出该案例的 $\\overline{\\rho}$。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应包含四个 $\\overline{\\rho}$ 值，按案例1到4的顺序排列，例如 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]$。",
            "solution": "问题陈述经评估有效。它在科学上基于数值宇宙学和分层贝叶斯建模的原理，在数学上是良定的，具有清晰和完整的一组给定条件，并以客观、正式的语言表达。该模型虽然经过简化，但真实地代表了用于为本地宇宙模拟生成约束初始条件的方法。该问题没有指定的缺陷，如科学上不健全、模糊或不完整。\n\n任务是为一组傅里叶模式 $k$ 计算初始物质过密度 $\\delta_0(k)$ 和星系偏置 $b(k)$ 之间的平均绝对后验相关系数 $\\overline{\\rho}$。这量化了在指定的分层贝叶斯模型中这两个潜变量之间的简并性。计算依赖于后验分布的高斯近似，其中协方差矩阵通过反演费雪信息矩阵得到。\n\n该分层模型由观测到的星系过密度 $g(k)$ 的似然以及 $\\delta_0(k)$ 和 $b(k)$ 的先验定义。对于给定的模式 $k$，对数后验概率（相差一个可加常数）是对数似然和对数先验之和：\n$$\n\\ln P\\big(\\delta_0(k), b(k) | g(k)\\big) = \\ln P\\big(g(k) | \\delta_0(k), b(k)\\big) + \\ln P\\big(\\delta_0(k)\\big) + \\ln P\\big(b(k)\\big) + \\text{const.}\n$$\n各组成部分如下：\n-   **似然**： $g(k) \\sim \\mathcal{N}\\big(b(k) T(k,z) \\delta_0(k), N_g(k)\\big)$\n-   **$\\delta_0(k)$ 的先验**： $\\delta_0(k) \\sim \\mathcal{N}\\big(0, P_0(k)\\big)$\n-   **$b(k)$ 的先验**： $b(k) \\sim \\mathcal{N}\\big(b_\\star, \\sigma_b^2\\big)$\n\n代入高斯形式，负对数后验正比于：\n$$\n-\\ln P\\big(\\delta_0(k), b(k) | g(k)\\big) \\propto \\frac{1}{2} \\left[ \\frac{\\big(g(k) - b(k)T(k,z)\\delta_0(k)\\big)^2}{N_g(k)} + \\frac{\\delta_0(k)^2}{P_0(k)} + \\frac{\\big(b(k) - b_\\star\\big)^2}{\\sigma_b^2} \\right]\n$$\n在高斯近似下，后验协方差矩阵 $\\Sigma(k)$ 是费雪信息矩阵 $F(k)$ 的逆。费雪矩阵是对数后验的海森矩阵的负期望。在此贝叶斯背景下，它是来自似然的费雪信息 $F^{\\text{like}}(k)$ 和负对数先验曲率 $H^{\\text{prior}}(k)$ 的和。\n$$\nF(k) = F^{\\text{like}}(k) + H^{\\text{prior}}(k)\n$$\n$F^{\\text{like}}(k)$ 的元素对于参数 $\\theta = (\\delta_0(k), b(k))$ 由 $F^{\\text{like}}_{ij} = \\mathbb{E}_{g(k)} \\left[ -\\frac{\\partial^2 \\ln P(g(k)|\\theta)}{\\partial \\theta_i \\partial \\theta_j} \\right]$ 给出，其中期望是关于数据 $g(k)$ 的。\n负对数似然 $-\\ln P(g|\\theta) = \\frac{1}{2N_g}(g - bT\\delta_0)^2 + \\text{const.}$ 的导数是：\n$$\n-\\frac{\\partial^2 \\ln P(g|\\theta)}{\\partial \\delta_0^2} = \\frac{(bT)^2}{N_g}, \\quad -\\frac{\\partial^2 \\ln P(g|\\theta)}{\\partial b^2} = \\frac{(T\\delta_0)^2}{N_g}, \\quad -\\frac{\\partial^2 \\ln P(g|\\theta)}{\\partial \\delta_0 \\partial b} = \\frac{T}{N_g} (bT\\delta_0 - (g - bT\\delta_0))\n$$\n使用 $\\mathbb{E}[g] = bT\\delta_0$ 取期望可简化交叉项。来自似然的费雪矩阵为：\n$$\nF^{\\text{like}}(k) = \\frac{1}{N_g(k)} \\begin{pmatrix} (b(k)T(k,z))^2  b(k)T(k,z)^2\\delta_0(k) \\\\ b(k)T(k,z)^2\\delta_0(k)  (T(k,z)\\delta_0(k))^2 \\end{pmatrix}\n$$\n$\\delta_0(k)$ 和 $b(k)$ 的先验是独立的，因此它们对费雪矩阵的贡献是对角的。负对数先验的海森矩阵是：\n$$\nH^{\\text{prior}}(k) = \\begin{pmatrix} -\\frac{\\partial^2 \\ln P(\\delta_0)}{\\partial \\delta_0^2}  0 \\\\ 0  -\\frac{\\partial^2 \\ln P(b)}{\\partial b^2} \\end{pmatrix} = \\begin{pmatrix} 1/P_0(k)  0 \\\\ 0  1/\\sigma_b^2 \\end{pmatrix}\n$$\n总费雪矩阵 $F(k)$ 是 $F^{\\text{like}}(k) + H^{\\text{prior}}(k)$ 的和。我们在指定的基准点评估其分量：$b(k)=b_\\star$ 和 $\\delta_0(k)=\\sqrt{P_0(k)}$。为简洁起见，我们省略对 $k$ 和 $z$ 的显式依赖。设 $\\theta_1 = \\delta_0$ 和 $\\theta_2 = b$。\n$$\nF_{11} = F_{\\delta_0 \\delta_0} = \\frac{(b_\\star T)^2}{N_g} + \\frac{1}{P_0}\n$$\n$$\nF_{22} = F_{bb} = \\frac{(T \\sqrt{P_0})^2}{N_g} + \\frac{1}{\\sigma_b^2} = \\frac{T^2 P_0}{N_g} + \\frac{1}{\\sigma_b^2}\n$$\n$$\nF_{12} = F_{\\delta_0 b} = \\frac{b_\\star T^2 \\sqrt{P_0}}{N_g}\n$$\n后验协方差矩阵是 $\\Sigma(k) = F(k)^{-1}$。$\\delta_0(k)$ 和 $b(k)$ 之间的相关系数 $\\rho(k)$ 由下式给出：\n$$\n\\rho(k) = \\frac{\\Sigma_{12}}{\\sqrt{\\Sigma_{11} \\Sigma_{22}}}\n$$\n对于一个 $2 \\times 2$ 矩阵，其逆矩阵为 $F^{-1} = \\frac{1}{\\det(F)} \\begin{pmatrix} F_{22}  -F_{12} \\\\ -F_{12}  F_{11} \\end{pmatrix}$。因此，$\\Sigma_{12} = -F_{12}/\\det(F)$，$\\Sigma_{11} = F_{22}/\\det(F)$，以及 $\\Sigma_{22} = F_{11}/\\det(F)$。相关系数简化为：\n$$\n\\rho(k) = \\frac{-F_{12}}{\\sqrt{F_{11} F_{22}}}\n$$\n每个测试用例的最终结果是在给定的波数集合 $\\{k_i\\}$ 上对 $\\rho(k)$ 的绝对值取平均：\n$$\n\\overline{\\rho} = \\frac{1}{N_k} \\sum_{i=1}^{N_k} |\\rho(k_i)|\n$$\n每个测试用例的算法如下：\n1.  初始化一个列表以存储每个模式的相关系数。\n2.  对于集合 $\\{0.05, 0.10, 0.20, 0.30\\}\\,h\\,\\mathrm{Mpc}^{-1}$ 中的每个波数 $k_i$：\n    a. 根据案例参数（$D_z, R, A, n_s, N_0, k_0$）计算辅助量：\n       -   $W(k_i;R) = \\exp\\left(-\\frac{(k_iR)^2}{2}\\right)$\n       -   $T(k_i,z) = D(z) W(k_i;R)$\n       -   $P_0(k_i) = A k_i^{n_s}$\n       -   $N_g(k_i) = N_0\\left(1 + \\left(\\frac{k_i}{k_0}\\right)^2\\right)$\n    b. 使用基准值 $b(k_i)=b_\\star$ 和 $\\delta_0(k_i)=\\sqrt{P_0(k_i)}$ 计算费雪矩阵元素 $F_{11}$、$F_{22}$ 和 $F_{12}$。\n    c. 计算相关系数 $\\rho(k_i) = -F_{12} / \\sqrt{F_{11} F_{22}}$。\n    d. 存储绝对值 $|\\rho(k_i)|$。\n3.  计算存储的绝对相关值的均值以获得 $\\overline{\\rho}$。\n对四个测试用例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the average absolute posterior correlation between galaxy bias\n    and initial density for a hierarchical Bayesian model in cosmology.\n    \"\"\"\n    # Wavenumber set in h/Mpc\n    k_modes = np.array([0.05, 0.10, 0.20, 0.30])\n    \n    # Test suite parameter sets: (D(z), R, A, n_s, b_star, sigma_b, N0, k0)\n    test_cases = [\n        # Case 1 (baseline, informative data)\n        (0.95, 5.0, 0.02, 1.0, 1.4, 0.3, 1e-3, 0.15),\n        # Case 2 (high-noise boundary)\n        (0.95, 5.0, 0.02, 1.0, 1.4, 0.3, 1e-1, 0.15),\n        # Case 3 (weak prior on bias, stronger degeneracy expected)\n        (0.95, 5.0, 0.02, 1.0, 1.4, 3.0, 1e-3, 0.15),\n        # Case 4 (strong windowing, limited local information)\n        (0.95, 15.0, 0.02, 1.0, 1.4, 0.3, 1e-3, 0.15),\n    ]\n\n    all_results = []\n\n    for case_params in test_cases:\n        D_z, R, A, n_s, b_star, sigma_b, N0, k0 = case_params\n        \n        rho_k_values = []\n        \n        for k in k_modes:\n            # Step a: Compute ancillary quantities\n            # Effective window function\n            W_k = np.exp(-0.5 * (k * R)**2)\n            # Linear response transfer function\n            T_k = D_z * W_k\n            # Prior power spectrum for initial density\n            P0_k = A * k**n_s\n            # Galaxy noise power spectrum\n            Ng_k = N0 * (1.0 + (k / k0)**2)\n\n            # Step b: Compute Fisher matrix elements at the fiducial point\n            # Fiducial point is b(k) = b_star, delta_0(k) = sqrt(P0_k)\n            \n            # F_11 element (for delta_0)\n            F_11 = (b_star * T_k)**2 / Ng_k + 1.0 / P0_k\n            \n            # F_22 element (for b)\n            F_22 = (T_k**2 * P0_k) / Ng_k + 1.0 / sigma_b**2\n            \n            # F_12 element (cross term)\n            F_12 = (b_star * T_k**2 * np.sqrt(P0_k)) / Ng_k\n            \n            # Step c: Compute the correlation coefficient\n            # rho(k) = -F_12 / sqrt(F_11 * F_22)\n            denominator = np.sqrt(F_11 * F_22)\n            if denominator == 0:\n                # This case should not happen with the given positive parameters\n                rho_k = 0.0\n            else:\n                rho_k = -F_12 / denominator\n            \n            # Step d: Store the absolute value\n            rho_k_values.append(np.abs(rho_k))\n\n        # Step 3: Calculate the mean of the absolute correlations\n        mean_abs_rho = np.mean(rho_k_values)\n        all_results.append(mean_abs_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}