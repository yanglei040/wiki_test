{
    "hands_on_practices": [
        {
            "introduction": "Understanding complex numerical simulations often begins with mastering their simplest analytic counterparts. The Singular Isothermal Sphere (SIS) model is a foundational benchmark in gravitational lensing, providing a rare case where key quantities like the deflection angle can be derived in a closed form. This exercise will guide you through this classic calculation, reinforcing the fundamental link between a three-dimensional mass distribution and its observable lensing effects under the thin-lens approximation. ",
            "id": "3483295",
            "problem": "In numerical cosmology, ray tracing through N-body simulations is often benchmarked against analytic models. A widely used example is the singular isothermal sphere (SIS). Consider a spherically symmetric lens with a $3$-dimensional mass density profile $\\rho(r) = \\sigma_v^2 \\big/ \\left(2 \\pi G r^2\\right)$, where $r$ is the spherical radius, $\\sigma_v$ is the one-dimensional velocity dispersion, and $G$ is Newton's gravitational constant. A source lies at redshift $z_s$ and the lens at redshift $z_l$. Let $D_l$, $D_s$, and $D_{ls}$ denote the angular diameter distances from observer to lens, observer to source, and lens to source, respectively, in an arbitrary Friedmann–Lemaître–Robertson–Walker cosmology. Adopt the thin-lens approximation and axisymmetry.\n\nStarting from fundamental gravitational lensing definitions and the Newtonian-limit light deflection by a localized mass distribution, carry out the following steps:\n\n- Compute the projected surface mass density $\\Sigma(\\xi)$ by integrating $\\rho(r)$ along the line of sight, where $\\xi$ is the projected radius in the lens plane.\n- Using axisymmetry, obtain the enclosed projected mass $M(\\xi)$ and the corresponding physical deflection magnitude in the lens plane $\\hat{\\alpha}(\\xi)$ for a light ray with impact parameter $\\xi$.\n- Relate the reduced deflection angle on the sky, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$, to $\\hat{\\alpha}(\\xi)$ using angular diameter distances, with $\\boldsymbol{\\xi} = D_l \\boldsymbol{\\theta}$.\n- Determine the Einstein radius $\\theta_E$ by imposing perfect alignment of source, lens, and observer.\n\nExpress $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ as a vector in the direction of $\\boldsymbol{\\theta}$ and $\\theta_E$ as a scalar, both in terms of $\\sigma_v$, $c$, $D_l$, $D_s$, and $D_{ls}$, where $c$ is the speed of light. Express all angular quantities in radians. Provide your final answer as a single row matrix with two entries in the order $\\left(\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}), \\theta_E\\right)$. No numerical evaluation is required, and no rounding is needed. Do not include units in the final boxed answer; use radians implicitly for angles.",
            "solution": "The user has provided a well-posed and scientifically grounded problem in astrophysics, specifically in the domain of gravitational lensing. The problem requires the derivation of the deflection angle and Einstein radius for a singular isothermal sphere (SIS) lens model. The validation process confirms that the problem is complete, consistent, and solvable using established principles of physics and mathematics. I will now proceed with a systematic derivation following the steps outlined in the problem statement.\n\nThe $3$-dimensional mass density profile of the singular isothermal sphere is given by\n$$ \\rho(r) = \\frac{\\sigma_v^2}{2 \\pi G r^2} $$\nwhere $r$ is the spherical radius, $\\sigma_v$ is the one-dimensional velocity dispersion, and $G$ is the gravitational constant.\n\nStep 1: Compute the projected surface mass density $\\Sigma(\\xi)$.\nThe surface mass density, $\\Sigma(\\xi)$, is obtained by integrating the volume mass density, $\\rho(r)$, along the line of sight. Let the line-of-sight coordinate be $z$, and the projected radius in the lens plane be $\\xi$. The spherical radius $r$ is related to these coordinates by $r^2 = \\xi^2 + z^2$.\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\rho(r) \\, dz = \\int_{-\\infty}^{\\infty} \\rho\\left(\\sqrt{\\xi^2 + z^2}\\right) \\, dz $$\nSubstituting the expression for $\\rho(r)$:\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\frac{\\sigma_v^2}{2 \\pi G (\\xi^2 + z^2)} \\, dz $$\nWe can factor out the constants and evaluate the standard integral:\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G} \\int_{-\\infty}^{\\infty} \\frac{1}{\\xi^2 + z^2} \\, dz = \\frac{\\sigma_v^2}{2 \\pi G} \\left[ \\frac{1}{\\xi} \\arctan\\left(\\frac{z}{\\xi}\\right) \\right]_{z=-\\infty}^{z=\\infty} $$\nEvaluating the limits:\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} \\left( \\frac{\\pi}{2} - \\left(-\\frac{\\pi}{2}\\right) \\right) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} (\\pi) = \\frac{\\sigma_v^2}{2 G \\xi} $$\n\nStep 2: Obtain the enclosed projected mass $M(\\xi)$ and the physical deflection magnitude $\\hat{\\alpha}(\\xi)$.\nDue to the specified axisymmetry, the mass enclosed within a projected radius $\\xi$ is found by integrating the surface mass density over a circular area of radius $\\xi$.\n$$ M(\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\Sigma(\\xi') \\, d\\xi' $$\nSubstituting the expression for $\\Sigma(\\xi')$:\n$$ M(\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\left( \\frac{\\sigma_v^2}{2 G \\xi'} \\right) \\, d\\xi' = \\int_{0}^{\\xi} \\frac{\\pi \\sigma_v^2}{G} \\, d\\xi' = \\frac{\\pi \\sigma_v^2}{G} \\xi $$\nThe physical deflection angle $\\hat{\\alpha}$ for a light ray with impact parameter $\\xi$ is given by the weak-field gravitational lensing formula. For a circularly symmetric projected mass distribution, this is analogous to the deflection by a point mass, where the mass $M$ is replaced by the enclosed projected mass $M(\\xi)$.\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G M(\\xi)}{c^2 \\xi} $$\nwhere $c$ is the speed of light. Substituting the expression for $M(\\xi)$:\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G}{c^2 \\xi} \\left( \\frac{\\pi \\sigma_v^2}{G} \\xi \\right) = \\frac{4 \\pi \\sigma_v^2}{c^2} $$\nA key result for the SIS model is that the physical deflection angle $\\hat{\\alpha}$ is constant, independent of the impact parameter $\\xi$.\n\nStep 3: Relate the reduced deflection angle $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ to $\\hat{\\alpha}(\\xi)$.\nThe lens equation relates the true angular position of the source, $\\boldsymbol{\\beta}$, to the observed angular position of the image, $\\boldsymbol{\\theta}$, via the reduced deflection angle, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$:\n$$ \\boldsymbol{\\beta} = \\boldsymbol{\\theta} - \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\nThe reduced deflection angle $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ is related to the physical deflection angle in the lens plane, $\\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$, by the ratio of angular diameter distances $D_{ls}$ (lens to source) and $D_s$ (observer to source):\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\frac{D_{ls}}{D_s} \\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) $$\nFor a spherically symmetric lens, the deflection is radial. The vector $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ points away from the lens center, in the same direction as the image position vector $\\boldsymbol{\\theta}$. Thus, the direction of $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ is parallel to $\\boldsymbol{\\theta}$. The magnitude of the reduced deflection angle, which we denote as $\\alpha(\\theta)$, is:\n$$ \\alpha(\\theta) = \\frac{D_{ls}}{D_s} \\hat{\\alpha}(\\xi) $$\nwhere $\\theta = |\\boldsymbol{\\theta}|$ is the magnitude of the angular position vector. The physical impact parameter $\\xi$ is related to the angle $\\theta$ by $\\xi = D_l \\theta$, where $D_l$ is the angular diameter distance to the lens. Since $\\hat{\\alpha}$ is constant for an SIS lens, $\\alpha(\\theta)$ is also a constant, independent of $\\theta$:\n$$ \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\nThe vector expression for the reduced deflection angle is its magnitude multiplied by the unit vector in the direction of $\\boldsymbol{\\theta}$:\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\alpha \\frac{\\boldsymbol{\\theta}}{\\theta} = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{\\theta} $$\n\nStep 4: Determine the Einstein radius $\\theta_E$.\nThe Einstein radius, $\\theta_E$, is the angular radius of the ring-shaped image formed when the source, lens, and observer are perfectly aligned. This alignment corresponds to the source being on the optical axis, i.e., $\\boldsymbol{\\beta} = \\mathbf{0}$.\nSetting $\\boldsymbol{\\beta} = \\mathbf{0}$ in the lens equation gives:\n$$ \\boldsymbol{\\theta} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\nThe solution to this equation, denoted $\\boldsymbol{\\theta}_E$, represents the position of the Einstein ring. Taking the magnitude of both sides:\n$$ |\\boldsymbol{\\theta}_E| = |\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}_E)| $$\nLetting $\\theta_E = |\\boldsymbol{\\theta}_E|$, and using the result for the magnitude of the deflection angle $\\alpha$:\n$$ \\theta_E = \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\nThus, for the singular isothermal sphere, the Einstein radius is a constant equal to the magnitude of the reduced deflection angle.\n\nThe two requested quantities are the vector expression for the reduced deflection angle, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$, and the scalar expression for the Einstein radius, $\\theta_E$. They are given by:\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|} \\quad \\text{and} \\quad \\theta_E = \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} $$\nNote that the results do not depend on the lens distance $D_l$, which is a characteristic feature of the SIS model. All angular quantities are in radians, as specified.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|}  \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While analytic models provide crucial intuition, modern cosmology relies on simulating more realistic structures like the Navarro-Frenk-White (NFW) halo, the standard profile for dark matter halos. This numerical practice bridges the gap between theory and application by tasking you with embedding an analytic NFW profile onto a pixelized grid, a core step in preparing N-body simulation data for ray tracing. By comparing your interpolated results to the exact solution, you will directly confront and quantify the numerical biases inherent in discretization, a critical skill for any computational cosmologist. ",
            "id": "3483287",
            "problem": "Consider a single lens plane populated by an analytic Navarro–Frenk–White (NFW) halo defined by mass and concentration parameters $(M_{200},c)$. Work in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) cosmology with matter density parameter $\\Omega_{\\mathrm{m}}$, dark energy density parameter $\\Omega_{\\Lambda}$, and Hubble parameter $H_0$. Place the lens at redshift $z_{\\mathrm{d}}$ and sources at redshift $z_{\\mathrm{s}}$. You are to embed the analytic NFW profile into a pixelized density field, perform ray tracing on the resulting convergence map using bilinear interpolation, and quantify interpolation-induced biases by comparing to the exact analytic convergence evaluated at the same ray positions.\n\nUse the following fundamental laws and well-tested formulas as the base:\n- The angular diameter distance in a flat Universe is $D_{\\mathrm{A}}(z) = \\chi(z)/(1+z)$, where $\\chi(z) = \\int_0^z \\frac{c}{H(z')} \\, \\mathrm{d}z'$ is the comoving distance, $c$ is the speed of light, and $H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$.\n- The critical surface density is $\\Sigma_{\\mathrm{crit}} = \\frac{c^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$, where $D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}})$, $D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}})$, and $D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$.\n- The NFW three-dimensional mass profile defines $r_{200}$ via $M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3$, where $\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$, and $r_{\\mathrm{s}} = r_{200}/c$. The characteristic density is $\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 [\\ln(1+c) - c/(1+c)]}$.\n- The projected NFW surface density $\\Sigma(R)$ at projected radius $R$ can be written as $\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x)$ with $x=R/r_{\\mathrm{s}}$ and\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0  x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1,\n\\end{cases}\n$$\nand the convergence (dimensionless surface mass density) is $\\kappa(R) = \\Sigma(R)/\\Sigma_{\\mathrm{crit}}$.\n\nYour task:\n1. Derive the expressions required to compute $D_{\\mathrm{d}}$, $D_{\\mathrm{s}}$, $D_{\\mathrm{ds}}$, $\\Sigma_{\\mathrm{crit}}$, $r_{200}$, $r_{\\mathrm{s}}$, $\\rho_{\\mathrm{s}}$, and the analytic $\\kappa(R)$ for an NFW halo using the base formulas above.\n2. Construct a square, uniformly spaced, two-dimensional grid that covers a box of side length $L = 4 r_{200}$ centered on the halo. The grid resolution is $N \\times N$ pixels, with pixel width $\\Delta = L/N$. At each pixel center $(x_i,y_j)$, compute the projected radius $R_{ij} = \\sqrt{x_i^2 + y_j^2}$ and assign the analytic $\\Sigma(R_{ij})$ to the grid to create a surface density map. Then compute the convergence map $\\kappa_{ij} = \\Sigma(R_{ij})/\\Sigma_{\\mathrm{crit}}$. To maintain numerical stability, define a softening scale $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$ and evaluate $\\Sigma(R)$ at $R' = \\max(R,R_{\\mathrm{soft}})$ to avoid the logarithmic divergence at $R \\to 0$.\n3. Emulate ray tracing by sampling $N_{\\mathrm{ray}}$ ray positions $(x,y)$ in the lens plane. Use $N_{\\mathrm{ray}}=3000$ ray positions with radii $R$ drawn logarithmically from $R_{\\min} = 2\\Delta$ to $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$, and angles $\\phi$ uniformly from $[0, 2\\pi)$ (in radians). For each ray, compute:\n   - The analytic convergence $\\kappa_{\\mathrm{true}} = \\kappa(R)$.\n   - The interpolated convergence $\\kappa_{\\mathrm{interp}}$ by bilinear interpolation of the pixelized $\\kappa$ map at $(x,y)$.\n4. For each test case, compute the root-mean-square (RMS) relative bias\n$$\nb_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }.\n$$\n\nCosmological parameters and units:\n- Use $\\Omega_{\\mathrm{m}} = 0.3$, $\\Omega_{\\Lambda} = 0.7$, $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$, $c = 299{,}792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$, and $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$.\n- Place the lens at $z_{\\mathrm{d}} = 0.3$ and source at $z_{\\mathrm{s}} = 1.0$.\n- Express all distances in $\\mathrm{Mpc}$, masses in $M_{\\odot}$, and surface densities in $M_{\\odot}/\\mathrm{Mpc}^2$. The final RMS relative bias $b_{\\mathrm{RMS}}$ is dimensionless.\n\nTest suite:\nEvaluate $b_{\\mathrm{RMS}}$ for the following four cases:\n- Case A (happy path): $(M_{200}, c, N) = (1.0\\times 10^{14}\\,M_{\\odot}, 6, 256)$.\n- Case B (high concentration, moderate grid): $(M_{200}, c, N) = (1.0\\times 10^{12}\\,M_{\\odot}, 12, 128)$.\n- Case C (coarse resolution edge case): $(M_{200}, c, N) = (5.0\\times 10^{14}\\,M_{\\odot}, 4, 64)$.\n- Case D (massive halo, fine grid): $(M_{200}, c, N) = (2.0\\times 10^{15}\\,M_{\\odot}, 3, 512)$.\n\nFinal output specification:\nYour program should produce a single line of output containing the four $b_{\\mathrm{RMS}}$ values for Cases A–D, as a comma-separated list enclosed in square brackets, in the order [A,B,C,D]. For example: \"[0.00123,0.00456,0.01234,0.00078]\". Angles must be in radians for all computations.",
            "solution": "The user has provided a scientifically sound and well-posed problem. The task is to calculate the root-mean-square (RMS) relative bias introduced by bilinear interpolation when ray tracing through a pixelized convergence map of an analytic Navarro–Frenk–White (NFW) halo.\n\nThis solution will proceed in a structured manner, first detailing the calculation of all necessary physical quantities and then outlining the numerical algorithm designed to compute the specified bias.\n\n### 1. Cosmological Framework and Lensing Quantities\n\nThe problem is set in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) cosmology. The evolution of the Hubble parameter $H(z)$ with redshift $z$ is given by:\n$$H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$$\nwhere $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$ is the Hubble constant, $\\Omega_{\\mathrm{m}} = 0.3$ is the matter density parameter, and $\\Omega_{\\Lambda} = 0.7$ is the dark energy density parameter.\n\nThe comoving distance $\\chi(z)$ from an observer at $z=0$ to an object at redshift $z$ is calculated by integrating the Hubble distance:\n$$\\chi(z) = \\int_0^z \\frac{c_{light}}{H(z')} \\, \\mathrm{d}z'$$\nwhere $c_{light} = 299792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$ is the speed of light. This integral will be computed numerically.\n\nThe angular diameter distances to the lens ($D_{\\mathrm{d}}$), to the source ($D_{\\mathrm{s}}$), and from the lens to the source ($D_{\\mathrm{ds}}$) are essential for lensing calculations. For a flat universe, they are:\n$$D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}}) = \\frac{\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{d}}}$$\n$$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}}) = \\frac{\\chi(z_{\\mathrm{s}})}{1+z_{\\mathrm{s}}}$$\n$$D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$$\nwith the lens at redshift $z_{\\mathrm{d}} = 0.3$ and the source at $z_{\\mathrm{s}} = 1.0$.\n\nThe critical surface mass density, $\\Sigma_{\\mathrm{crit}}$, is the threshold surface density required for strong lensing. It depends on the geometry of the lens system:\n$$\\Sigma_{\\mathrm{crit}} = \\frac{c_{light}^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$$\nwhere $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$ is the gravitational constant.\n\n### 2. NFW Halo Model\n\nThe lens is modeled as an NFW dark matter halo, defined by its mass $M_{200}$ and concentration parameter $c_{conc}$.\nThe radius $r_{200}$ encloses a mean density equal to $200$ times the critical density of the universe at the lens redshift, $\\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})$. The critical density is:\n$$\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$$\nFrom the definition of $M_{200}$, we can solve for $r_{200}$:\n$$M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3 \\implies r_{200} = \\left( \\frac{3 M_{200}}{800\\pi \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})} \\right)^{1/3}$$\nThe NFW profile has two parameters: a scale radius $r_{\\mathrm{s}}$ and a characteristic density $\\rho_{\\mathrm{s}}$. They are related to $M_{200}$ and $c_{conc}$ by:\n$$r_{\\mathrm{s}} = \\frac{r_{200}}{c_{conc}}$$\n$$\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 \\left[\\ln(1+c_{conc}) - \\frac{c_{conc}}{1+c_{conc}}\\right]}$$\n\n### 3. Projected Density and Convergence\n\nThe three-dimensional NFW density profile, when projected onto the lens plane, results in a surface mass density $\\Sigma(R)$ at a projected radius $R$:\n$$\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x), \\quad \\text{where } x = R/r_{\\mathrm{s}}$$\nThe dimensionless function $f(x)$ is given by:\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0  x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1.\n\\end{cases}\n$$\nThe NFW profile has a cusp at $R=0$, leading to a logarithmic divergence in $\\Sigma(R)$. To ensure numerical stability, a softening length $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$ is introduced, where $\\Delta$ is the grid pixel width. The surface density is evaluated at a softened radius $R' = \\max(R, R_{\\mathrm{soft}})$.\n\nThe convergence, $\\kappa(R)$, is the surface mass density normalized by the critical density:\n$$\\kappa(R) = \\frac{\\Sigma(R)}{\\Sigma_{\\mathrm{crit}}}$$\n\n### 4. Numerical Algorithm\n\n#### Grid Generation\nA two-dimensional convergence map is created on a square grid.\n- Grid side length: $L = 4 r_{200}$, centered on the halo.\n- Grid resolution: $N \\times N$ pixels.\n- Pixel width: $\\Delta = L/N$.\n- The grid consists of pixel values $\\kappa_{ij}$, computed by evaluating the analytic (softened) convergence $\\kappa(R_{ij})$ at the center of each pixel $(i,j)$ with projected radius $R_{ij}$.\n\n#### Ray Sampling\n$N_{\\mathrm{ray}}=3000$ light rays are traced through the lens plane. Their positions $(x,y)$ are generated as follows:\n- Radii $R$ are drawn from a logarithmic distribution between $R_{\\min} = 2\\Delta$ and $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$. For all test cases, this simplifies to $R_{\\max} = 1.5 r_{200}$.\n- Azimuthal angles $\\phi$ are drawn from a uniform distribution in $[0, 2\\pi)$.\n\n#### Interpolation and Comparison\nFor each sampled ray at position $(x,y)$:\n- The true convergence, $\\kappa_{\\mathrm{true}}$, is calculated using the analytic formula $\\kappa(R)$, where $R=\\sqrt{x^2+y^2}$. To isolate interpolation error, $\\kappa_{\\mathrm{true}}$ is computed using the same softening rule applied to the grid, i.e., at radius $R' = \\max(R, R_{\\mathrm{soft}})$.\n- The interpolated convergence, $\\kappa_{\\mathrm{interp}}$, is obtained by performing bilinear interpolation on the four nearest pixel values of the $\\kappa_{ij}$ map.\n\n### 5. Quantifying Interpolation Bias\n\nThe RMS relative bias $b_{\\mathrm{RMS}}$ is computed to quantify the average discrepancy between the interpolated and true convergence values over all sampled rays:\n$$b_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }$$\n\nThis procedure is repeated for each of the four test cases specified in the problem statement. The implementation will be vectorized for efficient computation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing interpolation bias problem.\n    This function encapsulates the entire logic to compute the RMS relative bias\n    for four different NFW halo and grid configurations.\n    \"\"\"\n\n    # Cosmological parameters and physical constants\n    C_LIGHT = 299792.458  # Speed of light in km/s\n    G_CONST = 4.30091e-9  # Gravitational constant in Mpc*(km/s)^2/M_sun\n    H0 = 70.0  # Hubble constant in km/s/Mpc\n    OMEGA_M = 0.3  # Matter density parameter\n    OMEGA_L = 0.7  # Dark energy density parameter\n    Z_D = 0.3  # Lens redshift\n    Z_S = 1.0  # Source redshift\n\n    # Simulation parameters\n    N_RAY = 3000\n\n    # Set a random seed for reproducible ray sampling\n    np.random.seed(42)\n\n    # --- Cosmological Calculations ---\n    memoized_chi = {}\n    def H_z(z):\n        return H0 * np.sqrt(OMEGA_M * (1 + z)**3 + OMEGA_L)\n\n    def H_inv(z):\n        return 1.0 / H_z(z)\n\n    def chi_z(z):\n        if z not in memoized_chi:\n            result, _ = quad(H_inv, 0, z)\n            memoized_chi[z] = C_LIGHT * result\n        return memoized_chi[z]\n\n    chi_d = chi_z(Z_D)\n    chi_s = chi_z(Z_S)\n    \n    D_d = chi_d / (1.0 + Z_D)\n    D_s = chi_s / (1.0 + Z_S)\n    D_ds = (chi_s - chi_d) / (1.0 + Z_S)\n\n    Sigma_crit = (C_LIGHT**2 / (4 * np.pi * G_CONST)) * (D_s / (D_d * D_ds))\n    \n    # --- NFW Profile Functions ---\n    def nfw_f(x):\n        \"\"\"\n        Computes the NFW dimensionless projected density function f(x) for x = R/r_s.\n        This function is vectorized to handle numpy arrays.\n        \"\"\"\n        x = np.atleast_1d(x)\n        out = np.zeros_like(x, dtype=float)\n        \n        # Case 1: 0  x  1\n        mask_lt1 = (x  1.0)  ~np.isclose(x, 1.0)\n        if np.any(mask_lt1):\n            x_lt1 = x[mask_lt1]\n            term = np.arctanh(np.sqrt((1.0 - x_lt1) / (1.0 + x_lt1)))\n            out[mask_lt1] = (1.0 - (2.0 / np.sqrt(1.0 - x_lt1**2)) * term) / (x_lt1**2 - 1.0)\n\n        # Case 2: x = 1\n        mask_eq1 = np.isclose(x, 1.0)\n        if np.any(mask_eq1):\n            out[mask_eq1] = 1.0 / 3.0\n\n        # Case 3: x  1\n        mask_gt1 = x  1.0\n        if np.any(mask_gt1):\n            x_gt1 = x[mask_gt1]\n            term = np.arctan(np.sqrt((x_gt1 - 1.0) / (x_gt1 + 1.0)))\n            out[mask_gt1] = (1.0 - (2.0 / np.sqrt(x_gt1**2 - 1.0)) * term) / (x_gt1**2 - 1.0)\n        \n        return out if x.size  1 else out.item()\n\n\n    def calculate_rms_bias(M200, c_conc, N):\n        \"\"\"\n        Main function to compute RMS bias for a given set of parameters.\n        \n        Args:\n            M200 (float): Halo mass in solar masses.\n            c_conc (float): Halo concentration.\n            N (int): Grid resolution (N x N).\n        \n        Returns:\n            float: The calculated RMS relative bias.\n        \"\"\"\n        # 1. Calculate NFW halo parameters\n        H_zd = H_z(Z_D)\n        rho_crit_zd = (3.0 * H_zd**2) / (8.0 * np.pi * G_CONST)\n        r200 = ((3.0 * M200) / (4.0 * np.pi * 200.0 * rho_crit_zd))**(1.0/3.0)\n        r_s = r200 / c_conc\n        \n        denominator = 4.0 * np.pi * r_s**3 * (np.log(1.0 + c_conc) - c_conc / (1.0 + c_conc))\n        rho_s = M200 / denominator\n\n        # 2. Set up the pixelized convergence map\n        L = 4.0 * r200\n        delta = L / N\n        R_soft = max(1e-4 * r_s, delta / 2.0)\n\n        grid_coords_1d = np.linspace(-L/2.0 + delta/2.0, L/2.0 - delta/2.0, N)\n        xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        R_grid = np.sqrt(xx**2 + yy**2)\n\n        def kappa_analytic(R):\n            R_eff = np.maximum(R, R_soft)\n            x = R_eff / r_s\n            Sigma = 2.0 * rho_s * r_s * nfw_f(x)\n            return Sigma / Sigma_crit\n        \n        kappa_map = kappa_analytic(R_grid)\n\n        # 3. Sample ray positions\n        R_min = 2.0 * delta\n        R_max = 1.5 * r200\n        \n        radii = np.logspace(np.log10(R_min), np.log10(R_max), N_RAY)\n        angles = np.random.uniform(0, 2.0 * np.pi, N_RAY)\n        \n        ray_x = radii * np.cos(angles)\n        ray_y = radii * np.sin(angles)\n        ray_R = np.sqrt(ray_x**2 + ray_y**2)\n\n        # 4. Compute true and interpolated convergence values\n        kappa_true = kappa_analytic(ray_R)\n\n        # Vectorized bilinear interpolation\n        i_f = (ray_x + L/2.0) / delta - 0.5\n        j_f = (ray_y + L/2.0) / delta - 0.5\n        \n        i1 = np.floor(i_f).astype(int)\n        j1 = np.floor(j_f).astype(int)\n        \n        i1 = np.clip(i1, 0, N - 2)\n        j1 = np.clip(j1, 0, N - 2)\n        i2, j2 = i1 + 1, j1 + 1\n\n        dx, dy = i_f - i1, j_f - j1\n        \n        Q11 = kappa_map[i1, j1] # val at (i1, j1)\n        Q21 = kappa_map[i2, j1] # val at (i2, j1)\n        Q12 = kappa_map[i1, j2] # val at (i1, j2)\n        Q22 = kappa_map[i2, j2] # val at (i2, j2)\n\n        kappa_interp = (Q11 * (1 - dx) * (1 - dy) +\n                        Q21 * dx * (1 - dy) +\n                        Q12 * (1 - dx) * dy +\n                        Q22 * dx * dy)\n\n        # 5. Calculate RMS relative bias\n        relative_errors = (kappa_interp - kappa_true) / kappa_true\n        valid_mask = np.isfinite(relative_errors)  (kappa_true != 0)\n        b_rms = np.sqrt(np.mean(relative_errors[valid_mask]**2))\n        \n        return b_rms\n\n    # --- Test Suite Execution ---\n    test_cases = [\n        # Case A: happy path\n        {'M200': 1.0e14, 'c_conc': 6.0, 'N': 256},\n        # Case B: high concentration, moderate grid\n        {'M200': 1.0e12, 'c_conc': 12.0, 'N': 128},\n        # Case C: coarse resolution edge case\n        {'M200': 5.0e14, 'c_conc': 4.0, 'N': 64},\n        # Case D: massive halo, fine grid\n        {'M200': 2.0e15, 'c_conc': 3.0, 'N': 512},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rms_bias(case['M200'], case['c_conc'], case['N'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A light ray's journey through the cosmos is influenced by structures at many different distances, not just a single lens. The multi-plane lensing formalism provides the mathematical machinery to accumulate these effects. This exercise demystifies this process by reducing it to a tractable two-plane system, allowing you to focus on the core mechanic: the propagation of the Jacobian matrix, which describes image distortion. By computing the final magnification, you will gain hands-on experience with how lensing effects from sequential planes are combined. ",
            "id": "3483328",
            "problem": "Consider a two-plane gravitational lensing configuration in numerical cosmology ray tracing. You will implement the Jacobian propagation through two lens planes using the small-angle approximation and the standard multi-plane formalism in angular coordinates. Assume a flat Universe so that the angular diameter distance between planes satisfies $D_{ij} = D_j - D_i$ for $i  j$. The source is at plane $s$. Plane $1$ has a uniform convergence $\\,\\kappa_1\\,$ and zero shear. Plane $2$ has zero convergence and a pure shear aligned with the coordinate axes, with components $\\,\\gamma_1 = \\gamma\\,$ and $\\,\\gamma_2 = 0\\,$. The task is to compute the final Jacobian matrix $\\,\\mathbf{A}_s\\,$ at the source plane and the magnification $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$.\n\nFundamental base to use:\n- The multi-plane lens equation in angular variables for plane $\\,j\\,$ is\n$$\\boldsymbol{\\theta}_j = \\boldsymbol{\\theta} - \\sum_{i=1}^{j-1} \\frac{D_{ij}}{D_j}\\,\\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\nand for the source plane,\n$$\\boldsymbol{\\theta}_s = \\boldsymbol{\\theta} - \\sum_{i=1}^{2} \\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\nwhere $\\,\\boldsymbol{\\alpha}_i\\,$ is the reduced deflection for plane $\\,i\\,$.\n- The Jacobian propagation is defined by $\\,\\mathbf{A}_j = \\partial \\boldsymbol{\\theta}_j / \\partial \\boldsymbol{\\theta}\\,$, and the deflection-gradient (tidal) matrix on plane $\\,i\\,$ is $\\,\\mathbf{U}_i = \\partial \\boldsymbol{\\alpha}_i / \\partial \\boldsymbol{\\theta}_i\\,$.\n- For a single plane with convergence $\\,\\kappa\\,$ and shear components $\\,\\gamma_1\\,$ and $\\,\\gamma_2\\,$, the tidal matrix is\n$$\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}.$$\n- In the chosen reduced-deflection normalization with a fixed source plane, the inter-plane geometry factor to be used in the recursion is\n$$\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}, \\quad \\text{with} \\quad D_{ij} = D_j - D_i, \\quad D_{is} = D_s - D_i,$$\nwhich ensures $\\,\\beta_{is} = 1\\,$ when $\\,j = s\\,$.\n\nImplement the following steps:\n1. Construct $\\,\\mathbf{U}_1\\,$ for plane $\\,1\\,$ with uniform convergence $\\,\\kappa_1\\,$ and zero shear.\n2. Construct $\\,\\mathbf{U}_2\\,$ for plane $\\,2\\,$ with zero convergence and shear components $\\gamma_1 = \\gamma$ and $\\gamma_2=0$.\n3. Compute $\\,\\beta_{12}\\,$ using angular diameter distances $\\,D_1\\,$, $\\,D_2\\,$, and $\\,D_s\\,$ (in megaparsecs).\n4. Propagate the Jacobian:\n   - $\\,\\mathbf{A}_1 = \\mathbf{I}\\,$,\n   - $\\,\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1\\,$,\n   - $\\,\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2\\,$.\n5. Compute the determinant $\\,\\det \\mathbf{A}_s\\,$ and magnification $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$.\n\nPhysical units:\n- Distances $\\,D_1\\,$, $\\,D_2\\,$, $\\,D_s\\,$, and inter-plane distances $\\,D_{ij}\\,$ must be treated in megaparsecs ($\\mathrm{Mpc}$). The magnification $\\,\\mu\\,$ is dimensionless.\n\nTest suite:\nUse the following parameter sets, each given as $\\,\\{D_1, D_2, D_s, \\kappa_1, \\gamma\\}\\,$ with distances in $\\mathrm{Mpc}$:\n- Case $\\,1\\,$ (general happy path): $\\,\\{1000, 1500, 2000, 0.1, 0.05\\}\\,$.\n- Case $\\,2\\,$ (boundary, no shear): $\\,\\{900, 1200, 1800, 0.2, 0.0\\}\\,$.\n- Case $\\,3\\,$ (edge, no convergence): $\\,\\{1000, 1600, 2000, 0.0, 0.1\\}\\,$.\n- Case $\\,4\\,$ (edge, minimal inter-plane separation): $\\,\\{1000, 1001, 3000, 0.4, 0.2\\}\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case must yield a list $\\,\\big[A_{11},A_{12},A_{21},A_{22},\\det(\\mathbf{A}_s),\\mu\\big]\\,$, with all numbers rounded to six decimal places. The overall output should thus be a single list of these per-case lists, for example, $\\,\\big[[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\big]\\,$.",
            "solution": "The user-provided problem has been analyzed and validated. It is found to be scientifically sound, well-posed, and objective. The problem provides a clear, self-contained set of definitions and an explicit algorithm for computing the Jacobian matrix of a two-plane gravitational lens system. I will now proceed with the solution.\n\nThe objective is to compute the source-plane Jacobian matrix $\\mathbf{A}_s$ and the corresponding magnification $\\mu$ for a two-plane gravitational lensing scenario. The solution will follow the specific algorithmic steps prescribed in the problem statement.\n\nThe fundamental quantities are the tidal matrices $\\mathbf{U}_i$ for each lens plane $i$, the inter-plane geometry factor $\\beta_{12}$, and the Jacobian matrices $\\mathbf{A}_j$ at each plane $j$.\n\n**Step 1: Construct the Tidal Matrix for Plane 1 ($\\mathbf{U}_1$)**\nPlane $1$ is characterized by a uniform convergence $\\kappa_1$ and zero shear ($\\gamma_1 = 0$, $\\gamma_2 = 0$). The general form of the tidal matrix is given as:\n$$\n\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}\n$$\nSubstituting the properties of plane $1$, we get:\n$$\n\\mathbf{U}_1 = \\begin{pmatrix} \\kappa_1 + 0  0 \\\\ 0  \\kappa_1 - 0 \\end{pmatrix} = \\begin{pmatrix} \\kappa_1  0 \\\\ 0  \\kappa_1 \\end{pmatrix} = \\kappa_1 \\mathbf{I}\n$$\nwhere $\\mathbf{I}$ is the $2 \\times 2$ identity matrix.\n\n**Step 2: Construct the Tidal Matrix for Plane 2 ($\\mathbf{U}_2$)**\nPlane $2$ has zero convergence ($\\kappa_2 = 0$) and shear components $\\gamma_1 = \\gamma$ and $\\gamma_2 = 0$. We substitute these into the general formula for the tidal matrix:\n$$\n\\mathbf{U}_2 = \\begin{pmatrix} 0 + \\gamma  0 \\\\ 0  0 - \\gamma \\end{pmatrix} = \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n\n**Step 3: Compute the Geometry Factor $\\beta_{12}$**\nThe inter-plane geometry factor is given by the formula:\n$$\n\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}\n$$\nWith the flat-universe distance relation $D_{ij} = D_j - D_i$, the factor $\\beta_{12}$ becomes:\n$$\n\\beta_{12} = \\frac{(D_2 - D_1) D_s}{D_2 (D_s - D_1)}\n$$\nwhere $D_1$, $D_2$, and $D_s$ are the angular diameter distances to plane $1$, plane $2$, and the source plane, respectively.\n\n**Step 4: Propagate the Jacobian to the Source Plane ($\\mathbf{A}_s$)**\nThe problem specifies the following propagation relations for the Jacobian matrix $\\mathbf{A}_j = \\partial\\boldsymbol{\\theta}_j/\\partial\\boldsymbol{\\theta}$:\n1.  $\\mathbf{A}_1 = \\mathbf{I}$\n2.  $\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1$\n3.  $\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2$\n\nFirst, we compute $\\mathbf{A}_2$. Substituting the expression for $\\mathbf{U}_1$:\n$$\n\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12} (\\kappa_1 \\mathbf{I}) = (1 - \\beta_{12} \\kappa_1) \\mathbf{I}\n$$\nNext, we substitute $\\mathbf{U}_1$, $\\mathbf{U}_2$, and the derived $\\mathbf{A}_2$ into the expression for $\\mathbf{A}_s$:\n$$\n\\mathbf{A}_s = \\mathbf{I} - \\kappa_1 \\mathbf{I} - \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix} \\left( (1 - \\beta_{12} \\kappa_1) \\mathbf{I} \\right)\n$$\n$$\n\\mathbf{A}_s = (1 - \\kappa_1) \\mathbf{I} - (1 - \\beta_{12} \\kappa_1) \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1  0 \\\\ 0  1 - \\kappa_1 \\end{pmatrix} - \\begin{pmatrix} \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  -\\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\nCombining the matrices, we obtain the final form of the source-plane Jacobian:\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\nThe matrix is diagonal. Let its components be $A_{ij}$. Then $A_{12} = A_{21} = 0$.\n\n**Step 5: Compute the Determinant and Magnification ($\\mu$)**\nThe determinant of a diagonal matrix is the product of its diagonal elements:\n$$\n\\det \\mathbf{A}_s = A_{11} \\times A_{22} = \\left( 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1) \\right) \\left( 1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\right)\n$$\nThis expression has the form $(X - Y)(X + Y) = X^2 - Y^2$, with $X = 1 - \\kappa_1$ and $Y = \\gamma(1 - \\beta_{12} \\kappa_1)$. Therefore, a more compact expression for the determinant is:\n$$\n\\det \\mathbf{A}_s = (1 - \\kappa_1)^2 - \\gamma^2(1 - \\beta_{12} \\kappa_1)^2\n$$\nThe gravitational lensing magnification, $\\mu$, is defined as the inverse of the Jacobian determinant:\n$$\n\\mu = \\frac{1}{\\det \\mathbf{A}_s}\n$$\nThese derived expressions will be implemented to compute the results for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobian matrix and magnification for a two-plane gravitational lens system.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is {D1, D2, Ds, kappa1, gamma}\n    test_cases = [\n        (1000, 1500, 2000, 0.1, 0.05),\n        (900, 1200, 1800, 0.2, 0.0),\n        (1000, 1600, 2000, 0.0, 0.1),\n        (1000, 1001, 3000, 0.4, 0.2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        D1, D2, Ds, kappa1, gamma = case\n        \n        # Ensure distances are floats for division\n        D1, D2, Ds = float(D1), float(D2), float(Ds)\n\n        # Step 3: Compute the geometry factor beta_12\n        # beta_12 = (D_12 * D_s) / (D_2 * D_1s)\n        # where D_ij = D_j - D_i\n        # Note: Added a check for D2 and (Ds - D1) being non-zero to avoid division by zero.\n        # Although not present in test cases, it's good practice.\n        if D2 == 0 or Ds == D1:\n            # This case is physically ill-defined in this formalism\n            # The problem's test cases avoid this.\n            # Propagate an error or handle as per a more detailed model.\n            # For this problem, we can assume valid inputs.\n            beta_12 = np.inf \n        else:\n            beta_12 = ((D2 - D1) * Ds) / (D2 * (Ds - D1))\n\n        # Steps 1, 2, 4 combined: Calculate the components of the final Jacobian A_s\n        # A_s = [[A11, 0], [0, A22]]\n        # A11 = 1 - kappa1 - gamma * (1 - beta_12 * kappa1)\n        # A22 = 1 - kappa1 + gamma * (1 - beta_12 * kappa1)\n        \n        term_common = 1 - beta_12 * kappa1\n        \n        A11 = 1 - kappa1 - gamma * term_common\n        A12 = 0.0\n        A21 = 0.0\n        A22 = 1 - kappa1 + gamma * term_common\n        \n        # Step 5: Compute the determinant and magnification\n        # det(A_s) = (1 - kappa1)^2 - (gamma * (1 - beta_12 * kappa1))^2\n        det_A_s = A11 * A22\n        \n        # Avoid division by zero for magnification calculation\n        mu = 1.0 / det_A_s if det_A_s != 0 else np.inf\n\n        # Store the formatted results for the current case\n        case_result = [\n            round(A11, 6),\n            round(A12, 6),\n            round(A21, 6),\n            round(A22, 6),\n            round(det_A_s, 6),\n            round(mu, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # Example: [[res1_1, res1_2, ...], [res2_1, res2_2, ...]]\n    output_str = f\"[{','.join([f'[{\",\".join([f\"{val:.6f}\" for val in res])}]' for res in results])}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}