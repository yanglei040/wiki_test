{
    "hands_on_practices": [
        {
            "introduction": "任何复杂的数值模拟都需要可靠的解析基准进行检验。本练习将引导您完整推导奇异等温球（Singular Isothermal Sphere, SIS）模型的引力透镜属性，这是一个在星系和星系团尺度上广泛应用的经典模型。掌握其从三维密度分布到二维偏转角和爱因斯坦半径的推导过程，是理解引力透镜物理本质的基石。",
            "id": "3483295",
            "problem": "在数值宇宙学中通过N体引力模拟进行射线追踪时，一个广泛使用的解析基准是奇异等温球（SIS）。考虑一个球对称透镜，其三维质量密度分布为 $\\rho(r) = \\sigma_v^2 \\big/ \\left(2 \\pi G r^2\\right)$，其中 $r$ 是球半径，$\\sigma_v$ 是一维速度弥散，而 $G$ 是牛顿引力常数。一个源位于红移 $z_s$ 处，透镜位于红移 $z_l$ 处。设 $D_l$、$D_s$ 和 $D_{ls}$ 分别表示在任意的弗里德曼-勒梅特-罗伯逊-沃尔克宇宙学中，从观测者到透镜、从观测者到源以及从透镜到源的角直径距离。采用薄透镜近似和轴对称性。\n\n从引力透镜的基本定义和局域质量分布在牛顿极限下的光线偏折出发，执行以下步骤：\n\n- 通过沿视线方向对 $\\rho(r)$ 进行积分，计算投影表面质量密度 $\\Sigma(\\xi)$，其中 $\\xi$ 是透镜平面中的投影半径。\n- 利用轴对称性，对于碰撞参数为 $\\xi$ 的光线，求出包围的投影质量 $M(<\\xi)$ 以及透镜平面中相应的物理偏折角大小 $\\hat{\\alpha}(\\xi)$。\n- 使用角直径距离，将天空中的约化偏折角 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 与 $\\hat{\\alpha}(\\xi)$ 联系起来，其中 $\\boldsymbol{\\xi} = D_l \\boldsymbol{\\theta}$。\n- 通过假设源、透镜和观测者完全对齐，确定爱因斯坦半径 $\\theta_E$。\n\n将 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 表示为 $\\boldsymbol{\\theta}$ 方向上的矢量，将 $\\theta_E$ 表示为标量，两者均用 $\\sigma_v$、$c$、$D_l$、$D_s$ 和 $D_{ls}$ 表示，其中 $c$ 是光速。所有角度量均以弧度表示。请将您的最终答案以一个单行矩阵的形式给出，该矩阵包含两个条目，顺序为 $\\left(\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}), \\theta_E\\right)$。不需要进行数值计算，也无需四舍五入。在最终的方框答案中不要包含单位；角度默认使用弧度。",
            "solution": "用户提供了一个在天体物理学领域，特别是在引力透镜范畴内，叙述清晰且有科学依据的问题。该问题要求推导奇异等温球（SIS）透镜模型的偏折角和爱因斯坦半径。验证过程确认了该问题是完整的、一致的，并且可以使用已有的物理学和数学原理来解决。我现在将按照问题陈述中概述的步骤进行系统推导。\n\n奇异等温球的三维质量密度分布由下式给出\n$$ \\rho(r) = \\frac{\\sigma_v^2}{2 \\pi G r^2} $$\n其中 $r$ 是球半径，$\\sigma_v$ 是一维速度弥散，而 $G$ 是引力常数。\n\n步骤 1：计算投影表面质量密度 $\\Sigma(\\xi)$。\n表面质量密度 $\\Sigma(\\xi)$ 是通过沿视线方向对体质量密度 $\\rho(r)$ 进行积分得到的。设视线坐标为 $z$，透镜平面中的投影半径为 $\\xi$。球半径 $r$ 通过 $r^2 = \\xi^2 + z^2$ 与这些坐标相关联。\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\rho(r) \\, dz = \\int_{-\\infty}^{\\infty} \\rho\\left(\\sqrt{\\xi^2 + z^2}\\right) \\, dz $$\n代入 $\\rho(r)$ 的表达式：\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\frac{\\sigma_v^2}{2 \\pi G (\\xi^2 + z^2)} \\, dz $$\n我们可以提出常数并计算这个标准积分：\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G} \\int_{-\\infty}^{\\infty} \\frac{1}{\\xi^2 + z^2} \\, dz = \\frac{\\sigma_v^2}{2 \\pi G} \\left[ \\frac{1}{\\xi} \\arctan\\left(\\frac{z}{\\xi}\\right) \\right]_{z=-\\infty}^{z=\\infty} $$\n计算极限：\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} \\left( \\frac{\\pi}{2} - \\left(-\\frac{\\pi}{2}\\right) \\right) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} (\\pi) = \\frac{\\sigma_v^2}{2 G \\xi} $$\n\n步骤 2：求出包围的投影质量 $M(<\\xi)$ 和物理偏折角的大小 $\\hat{\\alpha}(\\xi)$。\n由于指定的轴对称性，投影半径 $\\xi$ 内包围的质量可以通过对表面质量密度在一个半径为 $\\xi$ 的圆形区域上积分得到。\n$$ M(<\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\Sigma(\\xi') \\, d\\xi' $$\n代入 $\\Sigma(\\xi')$ 的表达式：\n$$ M(<\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\left( \\frac{\\sigma_v^2}{2 G \\xi'} \\right) \\, d\\xi' = \\int_{0}^{\\xi} \\frac{\\pi \\sigma_v^2}{G} \\, d\\xi' = \\frac{\\pi \\sigma_v^2}{G} \\xi $$\n对于碰撞参数为 $\\xi$ 的光线，其物理偏折角 $\\hat{\\alpha}$ 由弱引力场透镜公式给出。对于一个圆对称的投影质量分布，这类似于点质量引起的偏折，只是质量 $M$ 被替换为包围的投影质量 $M(<\\xi)$。\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G M(<\\xi)}{c^2 \\xi} $$\n其中 $c$ 是光速。代入 $M(<\\xi)$ 的表达式：\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G}{c^2 \\xi} \\left( \\frac{\\pi \\sigma_v^2}{G} \\xi \\right) = \\frac{4 \\pi \\sigma_v^2}{c^2} $$\nSIS 模型的一个关键结果是，物理偏折角 $\\hat{\\alpha}$ 是一个常数，与碰撞参数 $\\xi$ 无关。\n\n步骤 3：将约化偏折角 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 与 $\\hat{\\alpha}(\\xi)$ 联系起来。\n透镜方程通过约化偏折角 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$，将源的真实角位置 $\\boldsymbol{\\beta}$ 与像的观测角位置 $\\boldsymbol{\\theta}$ 联系起来：\n$$ \\boldsymbol{\\beta} = \\boldsymbol{\\theta} - \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\n约化偏折角 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 与透镜平面中的物理偏折角 $\\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$ 通过角直径距离之比 $D_{ls}$ (透镜到源) 和 $D_s$ (观测者到源) 相关联：\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\frac{D_{ls}}{D_s} \\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) $$\n对于球对称透镜，偏折是径向的。按照标准约定，像比源离光轴更远，矢量 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 从透镜中心指向像的位置 $\\boldsymbol{\\theta}$。因此，$\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 的方向与 $\\boldsymbol{\\theta}$ 平行。我们记约化偏折角的大小为 $\\alpha(\\theta)$，则：\n$$ \\alpha(\\theta) = \\frac{D_{ls}}{D_s} \\hat{\\alpha}(\\xi) $$\n其中 $\\theta = |\\boldsymbol{\\theta}|$ 是角位置矢量的大小。物理碰撞参数 $\\xi$ 与角度 $\\theta$ 的关系为 $\\xi = D_l \\theta$，其中 $D_l$ 是到透镜的角直径距离。由于对于 SIS 透镜，$\\hat{\\alpha}$ 是常数，所以 $\\alpha(\\theta)$ 也是一个与 $\\theta$ 无关的常数：\n$$ \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\n约化偏折角的矢量表达式是其大小乘以 $\\boldsymbol{\\theta}$ 方向上的单位矢量：\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\alpha \\frac{\\boldsymbol{\\theta}}{\\theta} = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{\\theta} $$\n\n步骤 4：确定爱因斯坦半径 $\\theta_E$。\n爱因斯坦半径 $\\theta_E$ 是当源、透镜和观测者完全对齐时形成的环状像的角半径。这种对齐对应于源位于光轴上，即 $\\boldsymbol{\\beta} = \\mathbf{0}$。\n在透镜方程中令 $\\boldsymbol{\\beta} = \\mathbf{0}$，可得：\n$$ \\boldsymbol{\\theta} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\n此方程的解，记为 $\\boldsymbol{\\theta}_E$，表示爱因斯坦环的位置。对两边取大小：\n$$ |\\boldsymbol{\\theta}_E| = |\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}_E)| $$\n令 $\\theta_E = |\\boldsymbol{\\theta}_E|$，并使用偏折角大小 $\\alpha$ 的结果：\n$$ \\theta_E = \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\n因此，对于奇异等温球，爱因斯坦半径是一个常数，等于约化偏折角的大小。\n\n所要求的两个量是约化偏折角的矢量表达式 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ 和爱因斯坦半径的标量表达式 $\\theta_E$。它们由下式给出：\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|} \\quad \\text{和} \\quad \\theta_E = \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} $$\n注意，结果不依赖于透镜距离 $D_l$，这是 SIS 模型的一个特征。如指定，所有角度量均以弧度为单位。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|}  \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "将连续的物理模型离散化是数值宇宙学的核心挑战之一。本练习将带您亲手实现一个重要的实践任务：将一个解析的Navarro-Frenk-White（NFW）暗晕“嵌入”到一个像素化网格中，并通过射线追踪来量化插值算法引入的系统偏差。这项技能对于评估和改进大规模N-body模拟中的引力透镜效应计算至关重要。",
            "id": "3483287",
            "problem": "考虑一个单一透镜平面，该平面上分布着一个由质量和聚集度参数 $(M_{200},c)$ 定义的解析 Navarro–Frenk–White (NFW) 暗晕。计算在空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学框架下进行，其中物质密度参数为 $\\Omega_{\\mathrm{m}}$，暗能量密度参数为 $\\Omega_{\\Lambda}$，哈勃参数为 $H_0$。将透镜置于红移 $z_{\\mathrm{d}}$ 处，源置于红移 $z_{\\mathrm{s}}$ 处。你需要将解析 NFW 剖面嵌入到一个像素化的密度场中，使用双线性插值对得到的会聚图进行光线追踪，并通过与在相同光线位置上计算的精确解析会聚值进行比较，来量化插值引起的偏差。\n\n使用以下基本定律和经过充分检验的公式作为基础：\n- 在平坦宇宙中，角直径距离为 $D_{\\mathrm{A}}(z) = \\chi(z)/(1+z)$，其中 $\\chi(z) = \\int_0^z \\frac{c}{H(z')} \\, \\mathrm{d}z'$ 是共动距离， $c$ 是光速，且 $H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$。\n- 临界表面密度为 $\\Sigma_{\\mathrm{crit}} = \\frac{c^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$，其中 $D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}})$，$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}})$，且 $D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$。\n- NFW 三维质量剖面通过 $M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3$ 定义 $r_{200}$，其中 $\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$，且 $r_{\\mathrm{s}} = r_{200}/c$。特征密度为 $\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 [\\ln(1+c) - c/(1+c)]}$。\n- 在投影半径 $R$ 处的 NFW 投影表面密度 $\\Sigma(R)$ 可以写为 $\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x)$，其中 $x=R/r_{\\mathrm{s}}$ 且\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0 \\le x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1,\n\\end{cases}\n$$\n而会聚（无量纲表面质量密度）为 $\\kappa(R) = \\Sigma(R)/\\Sigma_{\\mathrm{crit}}$。\n\n你的任务：\n1. 使用上述基础公式，推导计算 $D_{\\mathrm{d}}$, $D_{\\mathrm{s}}$, $D_{\\mathrm{ds}}$, $\\Sigma_{\\mathrm{crit}}$, $r_{200}$, $r_{\\mathrm{s}}$, $\\rho_{\\mathrm{s}}$ 以及 NFW 暗晕的解析 $\\kappa(R)$ 所需的表达式。\n2. 构建一个正方形、均匀间隔的二维网格，覆盖以暗晕为中心、边长为 $L = 4 r_{200}$ 的区域。网格分辨率为 $N \\times N$ 像素，像素宽度为 $\\Delta = L/N$。在每个像素中心 $(x_i,y_j)$，计算投影半径 $R_{ij} = \\sqrt{x_i^2 + y_j^2}$，并将解析 $\\Sigma(R_{ij})$ 赋予网格以创建表面密度图。然后计算会聚图 $\\kappa_{ij} = \\Sigma(R_{ij})/\\Sigma_{\\mathrm{crit}}$。为保持数值稳定性，定义一个软化尺度 $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$，并在 $R' = \\max(R,R_{\\mathrm{soft}})$ 处计算 $\\Sigma(R)$，以避免在 $R \\to 0$ 时的对数发散。\n3. 通过在透镜平面上采样 $N_{\\mathrm{ray}}$ 个光线位置 $(x,y)$ 来模拟光线追踪。使用 $N_{\\mathrm{ray}}=3000$ 个光线位置，其半径 $R$ 从 $R_{\\min} = 2\\Delta$到 $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$ 对数均匀抽取，角度 $\\phi$ 从 $[0, 2\\pi)$（弧度）均匀抽取。对于每条光线，计算：\n   - 解析会聚 $\\kappa_{\\mathrm{true}} = \\kappa(R)$。\n   - 通过对像素化 $\\kappa$ 图在 $(x,y)$ 位置进行双线性插值得到的插值会聚 $\\kappa_{\\mathrm{interp}}$。\n4. 对每个测试案例，计算均方根（RMS）相对偏差\n$$\nb_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }.\n$$\n\n宇宙学参数和单位：\n- 使用 $\\Omega_{\\mathrm{m}} = 0.3$, $\\Omega_{\\Lambda} = 0.7$, $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$, $c = 299{,}792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$，以及 $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$。\n- 将透镜置于 $z_{\\mathrm{d}} = 0.3$ 处，源置于 $z_{\\mathrm{s}} = 1.0$ 处。\n- 所有距离以 $\\mathrm{Mpc}$ 为单位，质量以 $M_{\\odot}$ 为单位，表面密度以 $M_{\\odot}/\\mathrm{Mpc}^2$ 为单位。最终的 RMS 相对偏差 $b_{\\mathrm{RMS}}$ 是无量纲的。\n\n测试套件：\n评估以下四种情况的 $b_{\\mathrm{RMS}}$：\n- 情况 A（理想情况）：$(M_{200}, c, N) = (1.0\\times 10^{14}\\,M_{\\odot}, 6, 256)$。\n- 情况 B（高聚集度，中等网格）：$(M_{200}, c, N) = (1.0\\times 10^{12}\\,M_{\\odot}, 12, 128)$。\n- 情况 C（粗分辨率边缘情况）：$(M_{200}, c, N) = (5.0\\times 10^{14}\\,M_{\\odot}, 4, 64)$。\n- 情况 D（大质量暗暈，精细网格）：$(M_{200}, c, N) = (2.0\\times 10^{15}\\,M_{\\odot}, 3, 512)$。\n\n最终输出规格：\n你的程序应生成一行输出，其中包含案例 A–D 的四个 $b_{\\mathrm{RMS}}$ 值，形式为用方括号括起来的逗号分隔列表，顺序为 [A,B,C,D]。例如：“[0.00123,0.00456,0.01234,0.00078]”。所有计算中的角度必须使用弧度。",
            "solution": "用户提供了一个科学上合理且定义明确的问题。任务是计算在通过解析 Navarro–Frenk–White (NFW) 暗晕的像素化会聚图进行光线追踪时，由双线性插值引入的均方根（RMS）相对偏差。\n\n本解答将以结构化方式进行，首先详细说明所有必要物理量的计算，然后概述为计算指定偏差而设计的数值算法。\n\n### 1. 宇宙学框架与引力透镜物理量\n\n该问题设定在空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学框架下。哈勃参数 $H(z)$ 随红移 $z$ 的演化由下式给出：\n$$H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$$\n其中 $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$ 是哈勃常数，$\\Omega_{\\mathrm{m}} = 0.3$ 是物质密度参数，$\\Omega_{\\Lambda} = 0.7$ 是暗能量密度参数。\n\n从红移 $z=0$ 的观测者到红移为 $z$ 的物体的共动距离 $\\chi(z)$ 通过对哈勃距离积分计算得出：\n$$\\chi(z) = \\int_0^z \\frac{c_{light}}{H(z')} \\, \\mathrm{d}z'$$\n其中 $c_{light} = 299792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$ 是光速。该积分将进行数值计算。\n\n到透镜的角直径距离 ($D_{\\mathrm{d}}$)、到源的角直径距离 ($D_{\\mathrm{s}}$) 以及从透镜到源的角直径距离 ($D_{\\mathrm{ds}}$) 对引力透镜计算至关重要。对于平坦宇宙，它们是：\n$$D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}}) = \\frac{\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{d}}}$$\n$$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}}) = \\frac{\\chi(z_{\\mathrm{s}})}{1+z_{\\mathrm{s}}}$$\n$$D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$$\n其中透镜红移为 $z_{\\mathrm{d}} = 0.3$，源红移为 $z_{\\mathrm{s}} = 1.0$。\n\n临界表面质量密度 $\\Sigma_{\\mathrm{crit}}$ 是产生强引力透镜效应所需的阈值表面密度。它取决于透镜系统的几何结构：\n$$\\Sigma_{\\mathrm{crit}} = \\frac{c_{light}^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$$\n其中 $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$ 是引力常数。\n\n### 2. NFW 暗晕模型\n\n透镜被建模为一个 NFW 暗物质暗晕，由其质量 $M_{200}$ 和聚集度参数 $c_{conc}$ 定义。\n半径 $r_{200}$ 所包围的平均密度等于宇宙在透镜红移处临界密度 $\\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})$ 的200倍。临界密度为：\n$$\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$$\n根据 $M_{200}$ 的定义，我们可以解出 $r_{200}$：\n$$M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3 \\implies r_{200} = \\left( \\frac{3 M_{200}}{800\\pi \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})} \\right)^{1/3}$$\nNFW 剖面有两个参数：一个尺度半径 $r_{\\mathrm{s}}$ 和一个特征密度 $\\rho_{\\mathrm{s}}$。它们通过以下方式与 $M_{200}$ 和 $c_{conc}$ 相关联：\n$$r_{\\mathrm{s}} = \\frac{r_{200}}{c_{conc}}$$\n$$\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 \\left[\\ln(1+c_{conc}) - \\frac{c_{conc}}{1+c_{conc}}\\right]}$$\n\n### 3. 投影密度与会聚\n\n三维 NFW 密度剖面投影到透镜平面上时，在投影半径 $R$ 处产生一个表面质量密度 $\\Sigma(R)$：\n$$\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x), \\quad \\text{其中 } x = R/r_{\\mathrm{s}}$$\n无量纲函数 $f(x)$ 由下式给出：\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0 \\le x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1.\n\\end{cases}\n$$\nNFW 剖面在 $R=0$ 处有一个尖点（cusp），导致 $\\Sigma(R)$ 出现对数发散。为确保数值稳定性，引入了一个软化长度 $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$，其中 $\\Delta$ 是网格像素宽度。表面密度在一个软化后的半径 $R' = \\max(R, R_{\\mathrm{soft}})$ 处进行计算。\n\n会聚 $\\kappa(R)$ 是由临界密度归一化的表面质量密度：\n$$\\kappa(R) = \\frac{\\Sigma(R)}{\\Sigma_{\\mathrm{crit}}}$$\n\n### 4. 数值算法\n\n#### 网格生成\n在正方形网格上创建二维会聚图。\n- 网格边长： $L = 4 r_{200}$，以暗晕为中心。\n- 网格分辨率：$N \\times N$ 像素。\n- 像素宽度： $\\Delta = L/N$。\n- 网格由像素值 $\\kappa_{ij}$ 组成，这些值是通过在每个像素 $(i,j)$ 中心处的投影半径 $R_{ij}$ 上计算解析（软化后）的会聚 $\\kappa(R_{ij})$ 得到的。\n\n#### 光线采样\n$N_{\\mathrm{ray}}=3000$ 条光线通过透镜平面进行追踪。它们的位置 $(x,y)$ 生成如下：\n- 半径 $R$ 从 $R_{\\min} = 2\\Delta$ 和 $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$ 之间的对数分布中抽取。对于所有测试案例，这可以简化为 $R_{\\max} = 1.5 r_{200}$。\n- 方位角 $\\phi$ 从 $[0, 2\\pi)$ 的均匀分布中抽取。\n\n#### 插值与比较\n对于每个采样的光线位置 $(x,y)$：\n- 真实会聚值 $\\kappa_{\\mathrm{true}}$ 使用解析公式 $\\kappa(R)$ 计算，其中 $R=\\sqrt{x^2+y^2}$。为了分离出插值误差，$\\kappa_{\\mathrm{true}}$ 使用与网格相同的软化规则进行计算，即在半径 $R' = \\max(R, R_{\\mathrm{soft}})$ 处。\n- 插值会聚值 $\\kappa_{\\mathrm{interp}}$ 是通过对 $\\kappa_{ij}$ 图上最近的四个像素值进行双线性插值得到的。\n\n### 5. 量化插值偏差\n\n计算 RMS 相对偏差 $b_{\\mathrm{RMS}}$ 以量化所有采样光线的插值会聚值与真实会聚值之间的平均差异：\n$$b_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }$$\n\n对问题陈述中指定的四个测试案例中的每一个都重复此过程。该实现将进行矢量化以实现高效计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing interpolation bias problem.\n    This function encapsulates the entire logic to compute the RMS relative bias\n    for four different NFW halo and grid configurations.\n    \"\"\"\n\n    # Cosmological parameters and physical constants\n    C_LIGHT = 299792.458  # Speed of light in km/s\n    G_CONST = 4.30091e-9  # Gravitational constant in Mpc*(km/s)^2/M_sun\n    H0 = 70.0  # Hubble constant in km/s/Mpc\n    OMEGA_M = 0.3  # Matter density parameter\n    OMEGA_L = 0.7  # Dark energy density parameter\n    Z_D = 0.3  # Lens redshift\n    Z_S = 1.0  # Source redshift\n\n    # Simulation parameters\n    N_RAY = 3000\n\n    # Set a random seed for reproducible ray sampling\n    np.random.seed(42)\n\n    # --- Cosmological Calculations ---\n    memoized_chi = {}\n    def H_z(z):\n        return H0 * np.sqrt(OMEGA_M * (1 + z)**3 + OMEGA_L)\n\n    def H_inv(z):\n        return 1.0 / H_z(z)\n\n    def chi_z(z):\n        if z not in memoized_chi:\n            result, _ = quad(H_inv, 0, z)\n            memoized_chi[z] = C_LIGHT * result\n        return memoized_chi[z]\n\n    chi_d = chi_z(Z_D)\n    chi_s = chi_z(Z_S)\n    \n    D_d = chi_d / (1.0 + Z_D)\n    D_s = chi_s / (1.0 + Z_S)\n    D_ds = (chi_s - chi_d) / (1.0 + Z_S)\n\n    Sigma_crit = (C_LIGHT**2 / (4 * np.pi * G_CONST)) * (D_s / (D_d * D_ds))\n    \n    # --- NFW Profile Functions ---\n    def nfw_f(x):\n        \"\"\"\n        Computes the NFW dimensionless projected density function f(x) for x = R/r_s.\n        This function is vectorized to handle numpy arrays.\n        \"\"\"\n        x = np.atleast_1d(x)\n        out = np.zeros_like(x, dtype=float)\n        \n        # Case 1: 0 = x  1\n        mask_lt1 = (x  1.0)  ~np.isclose(x, 1.0)\n        if np.any(mask_lt1):\n            x_lt1 = x[mask_lt1]\n            term = np.arctanh(np.sqrt((1.0 - x_lt1) / (1.0 + x_lt1)))\n            out[mask_lt1] = (1.0 - (2.0 / np.sqrt(1.0 - x_lt1**2)) * term) / (x_lt1**2 - 1.0)\n\n        # Case 2: x = 1\n        mask_eq1 = np.isclose(x, 1.0)\n        if np.any(mask_eq1):\n            out[mask_eq1] = 1.0 / 3.0\n\n        # Case 3: x > 1\n        mask_gt1 = x > 1.0\n        if np.any(mask_gt1):\n            x_gt1 = x[mask_gt1]\n            term = np.arctan(np.sqrt((x_gt1 - 1.0) / (x_gt1 + 1.0)))\n            out[mask_gt1] = (1.0 - (2.0 / np.sqrt(x_gt1**2 - 1.0)) * term) / (x_gt1**2 - 1.0)\n        \n        return out if x.size > 1 else out.item()\n\n\n    def calculate_rms_bias(M200, c_conc, N):\n        \"\"\"\n        Main function to compute RMS bias for a given set of parameters.\n        \n        Args:\n            M200 (float): Halo mass in solar masses.\n            c_conc (float): Halo concentration.\n            N (int): Grid resolution (N x N).\n        \n        Returns:\n            float: The calculated RMS relative bias.\n        \"\"\"\n        # 1. Calculate NFW halo parameters\n        H_zd = H_z(Z_D)\n        rho_crit_zd = (3.0 * H_zd**2) / (8.0 * np.pi * G_CONST)\n        r200 = ((3.0 * M200) / (4.0 * np.pi * 200.0 * rho_crit_zd))**(1.0/3.0)\n        r_s = r200 / c_conc\n        \n        denominator = 4.0 * np.pi * r_s**3 * (np.log(1.0 + c_conc) - c_conc / (1.0 + c_conc))\n        rho_s = M200 / denominator\n\n        # 2. Set up the pixelized convergence map\n        L = 4.0 * r200\n        delta = L / N\n        R_soft = max(1e-4 * r_s, delta / 2.0)\n\n        grid_coords_1d = np.linspace(-L/2.0 + delta/2.0, L/2.0 - delta/2.0, N)\n        xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        R_grid = np.sqrt(xx**2 + yy**2)\n\n        def kappa_analytic(R):\n            R_eff = np.maximum(R, R_soft)\n            x = R_eff / r_s\n            Sigma = 2.0 * rho_s * r_s * nfw_f(x)\n            return Sigma / Sigma_crit\n        \n        kappa_map = kappa_analytic(R_grid)\n\n        # 3. Sample ray positions\n        R_min = 2.0 * delta\n        R_max = 1.5 * r200\n        \n        radii = np.logspace(np.log10(R_min), np.log10(R_max), N_RAY)\n        angles = np.random.uniform(0, 2.0 * np.pi, N_RAY)\n        \n        ray_x = radii * np.cos(angles)\n        ray_y = radii * np.sin(angles)\n        ray_R = np.sqrt(ray_x**2 + ray_y**2)\n\n        # 4. Compute true and interpolated convergence values\n        kappa_true = kappa_analytic(ray_R)\n\n        # Vectorized bilinear interpolation\n        i_f = (ray_x + L/2.0) / delta - 0.5\n        j_f = (ray_y + L/2.0) / delta - 0.5\n        \n        i1 = np.floor(i_f).astype(int)\n        j1 = np.floor(j_f).astype(int)\n        \n        i1 = np.clip(i1, 0, N - 2)\n        j1 = np.clip(j1, 0, N - 2)\n        i2, j2 = i1 + 1, j1 + 1\n\n        dx, dy = i_f - i1, j_f - j1\n        \n        Q11 = kappa_map[i1, j1] # val at (i1, j1)\n        Q21 = kappa_map[i2, j1] # val at (i2, j1)\n        Q12 = kappa_map[i1, j2] # val at (i1, j2)\n        Q22 = kappa_map[i2, j2] # val at (i2, j2)\n\n        kappa_interp = (Q11 * (1 - dx) * (1 - dy) +\n                        Q21 * dx * (1 - dy) +\n                        Q12 * (1 - dx) * dy +\n                        Q22 * dx * dy)\n\n        # 5. Calculate RMS relative bias\n        relative_errors = (kappa_interp - kappa_true) / kappa_true\n        valid_mask = np.isfinite(relative_errors)  (kappa_true != 0)\n        b_rms = np.sqrt(np.mean(relative_errors[valid_mask]**2))\n        \n        return b_rms\n\n    # --- Test Suite Execution ---\n    test_cases = [\n        # Case A: happy path\n        {'M200': 1.0e14, 'c_conc': 6.0, 'N': 256},\n        # Case B: high concentration, moderate grid\n        {'M200': 1.0e12, 'c_conc': 12.0, 'N': 128},\n        # Case C: coarse resolution edge case\n        {'M200': 5.0e14, 'c_conc': 4.0, 'N': 64},\n        # Case D: massive halo, fine grid\n        {'M200': 2.0e15, 'c_conc': 3.0, 'N': 512},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rms_bias(case['M200'], case['c_conc'], case['N'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在宇宙的大尺度结构中，光线并非只被单个透镜偏转，而是穿过一系列的物质“薄片”。本练习简化了这一复杂情景，通过一个双平面透镜系统，让您掌握多平面引力透镜理论的核心——雅可比矩阵的递推关系。理解效应如何沿视线累积，是连接N-body模拟中的物质分布与最终观测图像的桥梁。",
            "id": "3483328",
            "problem": "考虑一个数值宇宙学光线追踪中的双平面引力透镜构型。您将使用小角度近似和角坐标下的标准多平面形式，实现通过两个透镜平面的雅可比矩阵传播。假设宇宙是平坦的，因此平面之间的角直径距离满足 $D_{ij} = D_j - D_i$（其中 $i  j$）。源位于平面 $s$。平面 $1$ 具有均匀的汇聚度 $\\,\\kappa_1\\,$ 和零剪切。平面 $2$ 具有纯剪切，其主分量为 $\\,\\gamma_{2,1} = \\gamma\\,$ 和 $\\,\\gamma_{2,2} = -\\gamma\\,$，且汇聚度为零。任务是计算源平面上的最终雅可比矩阵 $\\,\\mathbf{A}_s\\,$ 和放大率 $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$。\n\n使用的基本原理：\n- 对于平面 $\\,j\\,$，角变量下的多平面透镜方程为\n$$\\boldsymbol{\\theta}_j = \\boldsymbol{\\theta} - \\sum_{i=1}^{j-1} \\frac{D_{ij}}{D_j}\\,\\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\n对于源平面，\n$$\\boldsymbol{\\theta}_s = \\boldsymbol{\\theta} - \\sum_{i=1}^{2} \\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\n其中 $\\,\\boldsymbol{\\alpha}_i\\,$ 是平面 $\\,i\\,$ 的约化偏折角。\n- 雅可比矩阵的传播定义为 $\\,\\mathbf{A}_j = \\partial \\boldsymbol{\\theta}_j / \\partial \\boldsymbol{\\theta}\\,$，平面 $\\,i\\,$ 上的偏折梯度（潮汐）矩阵为 $\\,\\mathbf{U}_i = \\partial \\boldsymbol{\\alpha}_i / \\partial \\boldsymbol{\\theta}_i\\,$。\n- 对于具有汇聚度 $\\,\\kappa\\,$ 和剪切分量 $\\,\\gamma_1\\,$、$\\,\\gamma_2\\,$ 的单个平面，其潮汐矩阵为\n$$\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}.$$\n- 在源平面固定的约化偏折归一化选择下，递归中使用的平面间几何因子为\n$$\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}, \\quad \\text{with} \\quad D_{ij} = D_j - D_i, \\quad D_{is} = D_s - D_i,$$\n这确保了当 $\\,j = s\\,$ 时，$\\,\\beta_{is} = 1\\,$。\n\n实现以下步骤：\n1. 为具有均匀汇聚度 $\\,\\kappa_1\\,$ 和零剪切的平面 $\\,1\\,$ 构建 $\\,\\mathbf{U}_1\\,$。\n2. 为具有纯剪切主分量 $\\,\\gamma_{2,1} = \\gamma\\,$、$\\,\\gamma_{2,2} = -\\gamma\\,$ 和零汇聚度的平面 $\\,2\\,$ 构建 $\\,\\mathbf{U}_2\\,$。\n3. 使用角直径距离 $\\,D_1\\,$, $\\,D_2\\,$ 和 $\\,D_s\\,$ (单位为百万秒差距) 计算 $\\,\\beta_{12}\\,$。\n4. 传播雅可比矩阵：\n   - $\\,\\mathbf{A}_1 = \\mathbf{I}\\,$，\n   - $\\,\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1\\,$，\n   - $\\,\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2\\,$。\n5. 计算行列式 $\\,\\det \\mathbf{A}_s\\,$ 和放大率 $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$。\n\n物理单位：\n- 距离 $\\,D_1\\,$, $\\,D_2\\,$, $\\,D_s\\,$ 以及平面间距离 $\\,D_{ij}\\,$ 必须以百万秒差距 ($\\mathrm{Mpc}$) 为单位处理。放大率 $\\,\\mu\\,$ 是无量纲的。\n\n测试套件：\n使用以下参数集，每组以 $\\,\\{D_1, D_2, D_s, \\kappa_1, \\gamma\\}\\,$ 的形式给出，其中距离单位为 $\\mathrm{Mpc}$：\n- 情况 $\\,1\\,$ (一般正常路径): $\\,\\{1000, 1500, 2000, 0.1, 0.05\\}\\,$。\n- 情况 $\\,2\\,$ (边界，无剪切): $\\,\\{900, 1200, 1800, 0.2, 0.0\\}\\,$。\n- 情况 $\\,3\\,$ (边缘，无汇聚度): $\\,\\{1000, 1600, 2000, 0.0, 0.1\\}\\,$。\n- 情况 $\\,4\\,$ (边缘，最小平面间距): $\\,\\{1000, 1001, 3000, 0.4, 0.2\\}\\,$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例必须产生一个列表 $\\,\\big[A_{11},A_{12},A_{21},A_{22},\\det(\\mathbf{A}_s),\\mu\\big]\\,$，所有数字四舍五入到小数点后六位。因此，总输出应为这些按用例排列的列表的单个列表，例如 $\\,\\big[[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\big]\\,$。",
            "solution": "用户提供的问题已经过分析和验证。该问题在科学上是合理的、适定的和客观的。问题提供了一套清晰、自洽的定义和一个用于计算双平面引力透镜系统雅可比矩阵的显式算法。我现在将开始求解。\n\n目标是计算双平面引力透镜场景下源平面雅可比矩阵 $\\mathbf{A}_s$ 和相应的放大率 $\\mu$。求解过程将遵循问题陈述中规定的具体算法步骤。\n\n基本量是每个透镜平面 $i$ 的潮汐矩阵 $\\mathbf{U}_i$、平面间几何因子 $\\beta_{12}$ 以及每个平面 $j$ 上的雅可比矩阵 $\\mathbf{A}_j$。\n\n**步骤 1：构建平面 1 的潮汐矩阵 ($\\mathbf{U}_1$)**\n平面 $1$ 的特征是均匀汇聚度 $\\kappa_1$ 和零剪切 ($\\gamma_1 = 0$, $\\gamma_2 = 0$)。潮汐矩阵的一般形式如下：\n$$\n\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}\n$$\n代入平面 $1$ 的属性，我们得到：\n$$\n\\mathbf{U}_1 = \\begin{pmatrix} \\kappa_1 + 0  0 \\\\ 0  \\kappa_1 - 0 \\end{pmatrix} = \\begin{pmatrix} \\kappa_1  0 \\\\ 0  \\kappa_1 \\end{pmatrix} = \\kappa_1 \\mathbf{I}\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。\n\n**步骤 2：构建平面 2 的潮汐矩阵 ($\\mathbf{U}_2$)**\n平面 $2$ 具有零汇聚度 ($\\kappa_2 = 0$) 和纯剪切。问题指出剪切具有“主分量 $\\gamma_{2,1} = \\gamma$ 和 $\\gamma_{2,2} = -\\gamma$”。这意味着在所选坐标系中，剪切场与坐标轴对齐。通常，这对应于将剪切分量设置为 $\\gamma_1 = \\gamma$ 和 $\\gamma_2 = 0$。使用潮汐矩阵的一般公式，并代入 $\\kappa=0$、$\\gamma_1=\\gamma$ 和 $\\gamma_2=0$，我们得到：\n$$\n\\mathbf{U}_2 = \\begin{pmatrix} 0 + \\gamma  0 \\\\ 0  0 - \\gamma \\end{pmatrix} = \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n\n**步骤 3：计算几何因子 $\\beta_{12}$**\n平面间几何因子由以下公式给出：\n$$\n\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}\n$$\n利用平坦宇宙的距离关系 $D_{ij} = D_j - D_i$，因子 $\\beta_{12}$ 变为：\n$$\n\\beta_{12} = \\frac{(D_2 - D_1) D_s}{D_2 (D_s - D_1)}\n$$\n其中 $D_1$、$D_2$ 和 $D_s$ 分别是到平面 $1$、平面 $2$ 和源平面的角直径距离。\n\n**步骤 4：将雅可比矩阵传播到源平面 ($\\mathbf{A}_s$)**\n问题为雅可比矩阵 $\\mathbf{A}_j = \\partial\\boldsymbol{\\theta}_j/\\partial\\boldsymbol{\\theta}$ 指定了以下传播关系：\n1.  $\\mathbf{A}_1 = \\mathbf{I}$\n2.  $\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1$\n3.  $\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2$\n\n首先，我们计算 $\\mathbf{A}_2$。代入 $\\mathbf{U}_1$ 的表达式：\n$$\n\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12} (\\kappa_1 \\mathbf{I}) = (1 - \\beta_{12} \\kappa_1) \\mathbf{I}\n$$\n接下来，我们将 $\\mathbf{U}_1$、$\\mathbf{U}_2$ 和推导出的 $\\mathbf{A}_2$ 代入 $\\mathbf{A}_s$ 的表达式中：\n$$\n\\mathbf{A}_s = \\mathbf{I} - \\kappa_1 \\mathbf{I} - \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix} \\left( (1 - \\beta_{12} \\kappa_1) \\mathbf{I} \\right)\n$$\n$$\n\\mathbf{A}_s = (1 - \\kappa_1) \\mathbf{I} - (1 - \\beta_{12} \\kappa_1) \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1  0 \\\\ 0  1 - \\kappa_1 \\end{pmatrix} - \\begin{pmatrix} \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  -\\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\n合并矩阵，我们得到源平面雅可比矩阵的最终形式：\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\n该矩阵是对角矩阵。设其分量为 $A_{ij}$。则 $A_{12} = A_{21} = 0$。\n\n**步骤 5：计算行列式和放大率 ($\\mu$)**\n对角矩阵的行列式是其对角元素的乘积：\n$$\n\\det \\mathbf{A}_s = A_{11} \\times A_{22} = \\left( 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1) \\right) \\left( 1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\right)\n$$\n这个表达式具有 $(X - Y)(X + Y) = X^2 - Y^2$ 的形式，其中 $X = 1 - \\kappa_1$ 且 $Y = \\gamma(1 - \\beta_{12} \\kappa_1)$。因此，行列式的一个更紧凑的表达式是：\n$$\n\\det \\mathbf{A}_s = (1 - \\kappa_1)^2 - \\gamma^2(1 - \\beta_{12} \\kappa_1)^2\n$$\n引力透镜放大率 $\\mu$ 定义为雅可比矩阵行列式的倒数：\n$$\n\\mu = \\frac{1}{\\det \\mathbf{A}_s}\n$$\n这些推导出的表达式将被实现以计算每个测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobian matrix and magnification for a two-plane gravitational lens system.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is {D1, D2, Ds, kappa1, gamma}\n    test_cases = [\n        (1000, 1500, 2000, 0.1, 0.05),\n        (900, 1200, 1800, 0.2, 0.0),\n        (1000, 1600, 2000, 0.0, 0.1),\n        (1000, 1001, 3000, 0.4, 0.2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        D1, D2, Ds, kappa1, gamma = case\n        \n        # Ensure distances are floats for division\n        D1, D2, Ds = float(D1), float(D2), float(Ds)\n\n        # Step 3: Compute the geometry factor beta_12\n        # beta_12 = (D_12 * D_s) / (D_2 * D_1s)\n        # where D_ij = D_j - D_i\n        # Note: Added a check for D2 and (Ds - D1) being non-zero to avoid division by zero.\n        # Although not present in test cases, it's good practice.\n        if D2 == 0 or Ds == D1:\n            # This case is physically ill-defined in this formalism\n            # The problem's test cases avoid this.\n            # Propagate an error or handle as per a more detailed model.\n            # For this problem, we can assume valid inputs.\n            beta_12 = np.inf \n        else:\n            beta_12 = ((D2 - D1) * Ds) / (D2 * (Ds - D1))\n\n        # Steps 1, 2, 4 combined: Calculate the components of the final Jacobian A_s\n        # A_s = [[A11, 0], [0, A22]]\n        # A11 = 1 - kappa1 - gamma * (1 - beta_12 * kappa1)\n        # A22 = 1 - kappa1 + gamma * (1 - beta_12 * kappa1)\n        \n        term_common = 1 - beta_12 * kappa1\n        \n        A11 = 1 - kappa1 - gamma * term_common\n        A12 = 0.0\n        A21 = 0.0\n        A22 = 1 - kappa1 + gamma * term_common\n        \n        # Step 5: Compute the determinant and magnification\n        # det(A_s) = (1 - kappa1)^2 - (gamma * (1 - beta_12 * kappa1))^2\n        det_A_s = A11 * A22\n        \n        # Avoid division by zero for magnification calculation\n        mu = 1.0 / det_A_s if det_A_s != 0 else np.inf\n\n        # Store the formatted results for the current case\n        case_result = [\n            round(A11, 6),\n            round(A12, 6),\n            round(A21, 6),\n            round(A22, 6),\n            round(det_A_s, 6),\n            round(mu, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # Example: [[res1_1, res1_2, ...], [res2_1, res2_2, ...]]\n    output_str = f\"[{','.join([f'[{\",\".join([f\"{val:.6f}\" for val in res])}]' for res in results])}]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}