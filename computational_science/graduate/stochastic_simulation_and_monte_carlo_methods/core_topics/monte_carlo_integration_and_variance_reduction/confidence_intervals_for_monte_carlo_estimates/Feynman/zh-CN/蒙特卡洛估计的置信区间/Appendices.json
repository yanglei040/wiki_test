{
    "hands_on_practices": [
        {
            "introduction": "虽然中心极限定理（CLT）为构建置信区间提供了一个通用框架，但其应用并非万无一失，尤其是在处理更复杂的估计量时。一个常见的例子是比率估计，例如在自归一化重要性抽样中，当天文分母的估计值噪声较大且接近于零时，基于标准增量法（delta method）的置信区间可能会产生严重误导。本练习  将通过一个具体的计算案例，引导您比较增量法和更为稳健的费勒方法（Fieller's method），从而深刻理解前者在何种情况下会失效，并学会使用后者作为一种可靠的替代方案。",
            "id": "3298323",
            "problem": "考虑一个期望比率的自归一化重要性抽样估计。设 $\\{(Y_i,Z_i)\\}_{i=1}^n$ 是独立同分布的，其中 $Y_i = h(X_i) w(X_i)$ 且 $Z_i = w(X_i)$，这里 $w(X_i)  0$ 几乎必然成立，且 $h$ 是一个实值函数。目标参数是比率 $\\rho = \\mu_Y / \\mu_Z$，其中 $\\mu_Y = \\mathbb{E}[Y_i]$ 且 $\\mu_Z = \\mathbb{E}[Z_i]$。一次 $n = $ $400$ 次抽样的蒙特卡洛运行产生了以下汇总统计量：\n- 样本均值：$\\bar{Y} = $ $0.6$ 和 $\\bar{Z} = $ $0.02$。\n- 样本方差和协方差（以通常的无偏方式计算）：$s_{YY} = $ $1.0$，$s_{ZZ} = $ $0.09$，$s_{YZ} = $ $0.02$。\n\n假设联合中心极限定理（CLT）适用，因此 $\\sqrt{n}\\big((\\bar{Y},\\bar{Z}) - (\\mu_Y,\\mu_Z)\\big)$ 近似服从二元正态分布，其协方差矩阵等于总体协方差矩阵，我们用样本协方差矩阵来估计它。使用大样本正态理论，在 $95\\%$ 置信水平下，临界值为 $z_{0.975} = $ $1.96$，基于这些数据比较 $\\rho$ 的 Fieller 置信区间（CI）和 delta 方法置信区间（CI），并找出以下正确的陈述。特别地，分析分母的变异性如何影响 delta 方法置信区间的可靠性。\n\n选择所有适用的选项。\n\nA. $95\\%$ 的 Fieller 置信区间近似为 $(-\\infty,\\,-63.0] \\cup [12.0,\\,\\infty)$，而 delta 方法置信区间近似为 $[-14.0,\\,74.0]$。在这种情况下，delta 方法置信区间可能会产生误导，因为分母与零没有显著差异。\n\nB. Fieller 和 delta 方法的置信区间都是有限的且几乎相同，大约为 $[28.0,\\,32.0]$；因此 delta 方法在这里是可靠的。\n\nC. Fieller 置信区间在 $95\\%$ 置信水平下是整个实数轴，因为相关的二次判别式为负。\n\nD. 如果所有的 $Y_i$ 和 $Z_i$ 都乘以一个共同的正数常数，那么 $\\rho$ 的 Fieller 和 delta 方法置信区间都保持不变。",
            "solution": "该问题要求基于蒙特卡洛模拟提供的样本统计数据，比较期望比率的 Fieller 置信区间（CI）和 delta 方法置信区间（CI）。我们必须首先验证问题的陈述。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 数据来源：`n = 400` 次 `(Y_i, Z_i)` 的独立同分布抽样。\n- 定义：`Y_i = h(X_i) w(X_i)`，`Z_i = w(X_i)`，其中 `w(X_i)  0` 几乎必然成立。\n- 目标参数：`\\rho = \\mu_Y / \\mu_Z`，其中 `\\mu_Y = \\mathbb{E}[Y_i]` 且 `\\mu_Z = \\mathbb{E}[Z_i]`。\n- 样本统计量：\n    - 样本均值：`\\bar{Y} = 0.6`，`\\bar{Z} = 0.02`。\n    - 样本方差和协方差（无偏）：`s_{YY} = 1.0`，`s_{ZZ} = 0.09`，`s_{YZ} = 0.02`。\n- 假设：\n    - 联合中心极限定理（CLT）适用：`\\sqrt{n}\\big((\\bar{Y},\\bar{Z}) - (\\mu_Y,\\mu_Z)\\big)` 近似服从二元正态分布。\n    - 总体协方差矩阵由样本协方差矩阵估计。\n- 置信水平：`95\\%`。\n- 临界值：`z_{0.975} = 1.96`。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在大样本统计理论和蒙特卡洛方法的领域内是良定义的。\n- **科学依据：** 自归一化重要性抽样、delta 方法以及用于比率估计的 Fieller 方法都是统计学中标准的、数学上严谨的课题。\n- **适定性：** 问题提供了一套完整的数值数据（`n`、`\\bar{Y}`、`\\bar{Z}`、`s_{YY}`、`s_{ZZ}`、`s_{YZ}`）和一个明确定义的统计框架（CLT，`95\\%` 置信度），足以构建所需的置信区间。\n- **客观性：** 问题陈述由客观、量化的信息和公认的统计术语组成。\n- **一致性检查：** 我们验证所提供的样本协方差矩阵是有效的（半正定）。样本协方差矩阵为 `S = \\begin{pmatrix} s_{YY}  s_{YZ} \\\\ s_{YZ}  s_{ZZ} \\end{pmatrix} = \\begin{pmatrix} 1.0  0.02 \\\\ 0.02  0.09 \\end{pmatrix}`。其行列式为 `(1.0)(0.09) - (0.02)^2 = 0.09 - 0.0004 = 0.0896  0`。由于主子式均为正（`1.0  0` 且 `0.0896  0`），该矩阵是正定的，因此代表了一个有效的样本协方差结构。\n\n**步骤 3：结论与行动**\n问题陈述内部一致、科学合理且适定。我们可以继续进行求解。\n\n### 求解推导\n\n我们感兴趣的参数是 `\\rho = \\mu_Y / \\mu_Z`，其估计量为 `\\hat{\\rho} = \\bar{Y} / \\bar{Z}`。\n根据给定数据：\n`\\hat{\\rho} = 0.6 / 0.02 = 30`。\n`n = 400`，`z \\equiv z_{0.975} = 1.96`。\n给出的样本方差为 `s_{YY} = s_Y^2 = 1.0`，`s_{ZZ} = s_Z^2 = 0.09`，样本协方差为 `s_{YZ} = 0.02`。\n\n**1. Delta 方法置信区间**\n\nDelta 方法为随机变量函数的方差提供了一个近似值。对于 `\\hat{\\rho} = g(\\bar{Y}, \\bar{Z}) = \\bar{Y} / \\bar{Z}`，其大样本方差近似为：\n$$ \\text{Var}(\\hat{\\rho}) \\approx \\frac{1}{n} (\\nabla g)^T \\Sigma (\\nabla g) \\Big|_{(\\mu_Y, \\mu_Z)} $$\n其中 `\\Sigma` 是 `(Y_i, Z_i)` 的协方差矩阵。我们通过代入所有未知量的样本估计值来估计该方差：\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{n\\bar{Z}^2} (s_{YY} - 2\\hat{\\rho}s_{YZ} + \\hat{\\rho}^2 s_{ZZ}) $$\n代入给定值：\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{400(0.02)^2} (1.0 - 2(30)(0.02) + (30)^2(0.09)) $$\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{400(0.0004)} (1.0 - 1.2 + 900(0.09)) $$\n$$ \\hat{\\text{Var}}(\\hat{\\rho}) = \\frac{1}{0.16} (1.0 - 1.2 + 81) = \\frac{80.8}{0.16} = 505 $$\n估计的标准误是 `SE(\\hat{\\rho}) = \\sqrt{505} \\approx 22.472`。\n`95\\%` 的 delta 方法置信区间为 `\\hat{\\rho} \\pm z \\cdot SE(\\hat{\\rho})`：\n$$ CI_{\\text{delta}} = 30 \\pm 1.96 \\times 22.472 $$\n$$ CI_{\\text{delta}} = 30 \\pm 44.045 $$\n$$ CI_{\\text{delta}} \\approx [-14.0, 74.0] $$\n\n**2. Fieller 置信区间**\n\nFieller 方法通过找到所有使得假设 `H_0: \\rho = \\rho_0` 不被拒绝的 `\\rho_0` 值集合来构建置信区间。这基于统计量 `\\bar{Y} - \\rho\\bar{Z}`，该统计量近似服从正态分布，其均值为 `\\mu_Y - \\rho\\mu_Z = 0`，方差为 `\\frac{1}{n} (\\sigma_Y^2 - 2\\rho\\sigma_{YZ} + \\rho^2\\sigma_Z^2)`。\n`\\rho` 的 `(1-\\alpha)` 置信区间是解出以下不等式的值的集合：\n$$ \\frac{(\\bar{Y} - \\rho\\bar{Z})^2}{\\frac{1}{n} (s_{YY} - 2\\rho s_{YZ} + \\rho^2 s_{ZZ})} \\le z^2 $$\n整理后得到一个二次不等式 `A\\rho^2 + B\\rho + C \\le 0`，其中：\n- `A = n\\bar{Z}^2 - z^2 s_{ZZ}`\n- `B = -2(n\\bar{Y}\\bar{Z} - z^2 s_{YZ})`\n- `C = n\\bar{Y}^2 - z^2 s_{YY}`\n\n我们使用 `z^2 = (1.96)^2 = 3.8416` 来计算系数：\n- `A = 400(0.02)^2 - 3.8416(0.09) = 0.16 - 0.345744 = -0.185744`\n- `B = -2(400(0.6)(0.02) - 3.8416(0.02)) = -2(4.8 - 0.076832) = -9.446336`\n- `C = 400(0.6)^2 - 3.8416(1.0) = 144 - 3.8416 = 140.1584`\n\n`A` 的符号至关重要。一个负的 `A` 值表明分母的样本均值 `\\bar{Z}` 与零没有显著差异。具体来说，对于 `H_0: \\mu_Z = 0` 的检验统计量是 `t_Z = \\sqrt{n}\\bar{Z}/s_Z`，而 `A` 可以写成 `s_{ZZ}(t_Z^2 - z^2)`。在这里，`t_Z^2 = 400(0.02)^2/0.09 = 0.16/0.09 \\approx 1.778`，这小于 `z^2 = 3.8416`，证实了 `A  0`。这意味着抛物线 `f(\\rho) = A\\rho^2 + B\\rho + C` 的开口向下。\n\n接下来，我们通过计算判别式 `D = B^2 - 4AC` 来找到 `A\\rho^2 + B\\rho + C = 0` 的根：\n$$ D = (-9.446336)^2 - 4(-0.185744)(140.1584) $$\n$$ D = 89.233 + 104.149 = 193.382 $$\n由于 `D  0`，存在两个不同的实根。因为抛物线开口向下（`A  0`），不等式 `A\\rho^2 + B\\rho + C \\le 0` 在根的外部得到满足。\n根是：\n$$ \\rho = \\frac{-B \\pm \\sqrt{D}}{2A} = \\frac{9.446336 \\pm \\sqrt{193.382}}{2(-0.185744)} = \\frac{9.446336 \\pm 13.906186}{-0.371488} $$\n$$ \\rho_1 = \\frac{9.446336 - 13.906186}{-0.371488} = \\frac{-4.45985}{-0.371488} \\approx 12.005 $$\n$$ \\rho_2 = \\frac{9.446336 + 13.906186}{-0.371488} = \\frac{23.352522}{-0.371488} \\approx -62.862 $$\n`95\\%` 的 Fieller 置信区间是集合 `(-\\infty, \\rho_2] \\cup [\\rho_1, \\infty)`，近似为 `(-\\infty, -62.9] \\cup [12.0, \\infty)`。\n\n### 选项评估\n\n**A. $95\\%$ 的 Fieller 置信区间近似为 $(-\\infty,\\,-63.0] \\cup [12.0,\\,\\infty)$，而 delta 方法置信区间近似为 $[-14.0,\\,74.0]$。在这种情况下，delta 方法置信区间可能会产生误导，因为分母与零没有显著差异。**\n我们推导出的 Fieller 置信区间是 `(-\\infty, -62.9] \\cup [12.0, \\infty)`，与所给区间相符。我们推导出的 delta 方法置信区间是 `[-14.0, 74.0]`，也相符。Fieller 置信区间不相交的原因确实是分母的均值 `\\mu_Z` 在 `5\\%` 水平上与零没有统计学上的显著差异，如 `A  0` 所示。这正是 delta 方法所依赖的线性近似失效的精确场景，导致其产生一个具有误导性的紧凑且有限的置信区间。因此，这个陈述完全正确。\n**结论：正确。**\n\n**B. Fieller 和 delta 方法的置信区间都是有限的且几乎相同，大约为 $[28.0,\\,32.0]$；因此 delta 方法在这里是可靠的。**\n这是错误的。我们的计算表明，这两个置信区间在形式和大小上都截然不同。Fieller 置信区间不是有限的，而 delta 方法置信区间是 `[-14.0, 74.0]`，非常宽。区间 `[28.0, 32.0]` 是围绕点估计 `30` 的一个窄区间，并未反映数据中的巨大不确定性。\n**结论：不正确。**\n\n**C. Fieller 置信区间在 $95\\%$ 置信水平下是整个实数轴，因为相关的二次判别式为负。**\n要使 Fieller 置信区间为整个实数轴，条件是 `A  0` 且 `D \\le 0`。虽然 `A` 确实是负的，但我们计算出判别式 `D \\approx 193.38`，是正的。正判别式意味着二次方程有实根，这些实根界定了一个有限区域或其补集。因此，前提（负判别式）和结论（整个实数轴）都是错误的。\n**结论：不正确。**\n\n**D. 如果所有的 $Y_i$ 和 $Z_i$ 都乘以一个共同的正数常数，那么 $\\rho$ 的 Fieller 和 delta 方法置信区间都保持不变。**\n让我们分析变换 `Y'_i = c Y_i` 和 `Z'_i = c Z_i`（其中 `c  0`）的影响。参数 `\\rho' = \\mathbb{E}[Y'_i] / \\mathbb{E}[Z'_i] = c\\mu_Y / (c\\mu_Z) = \\rho` 是不变的。样本统计量的变换如下：`\\bar{Y}' = c\\bar{Y}`，`\\bar{Z}' = c\\bar{Z}`，`s'_{YY} = c^2 s_{YY}`，`s'_{ZZ} = c^2 s_{ZZ}`，以及 `s'_{YZ} = c^2 s_{YZ}`。\n- **Delta 方法：** 点估计 `\\hat{\\rho}' = \\bar{Y}'/\\bar{Z}' = (c\\bar{Y})/(c\\bar{Z}) = \\hat{\\rho}` 是不变的。新的方差是 `\\hat{\\text{Var}}(\\hat{\\rho}') = \\frac{1}{n(\\bar{Z}')^2} (s'_{YY} - 2\\hat{\\rho}'s'_{YZ} + (\\hat{\\rho}')^2 s'_{ZZ}) = \\frac{1}{n(c\\bar{Z})^2} (c^2 s_{YY} - 2\\hat{\\rho}c^2 s_{YZ} + \\hat{\\rho}^2 c^2 s_{ZZ}) = \\frac{c^2}{c^2} \\hat{\\text{Var}}(\\hat{\\rho}) = \\hat{\\text{Var}}(\\hat{\\rho})`。由于 `\\hat{\\rho}` 及其标准误都是不变的，置信区间也保持不变。\n- **Fieller 方法：** 二次不等式 `A'\\rho^2 + B'\\rho + C' \\le 0` 的系数变为 `A' = c^2 A`，`B' = c^2 B`，和 `C' = c^2 C`。不等式变为 `c^2(A\\rho^2 + B\\rho + C) \\le 0`。由于 `c^2  0`，这等价于原不等式 `A\\rho^2 + B\\rho + C \\le 0`。因此，`\\rho` 的解集是相同的。\n两个置信区间都对这种缩放保持不变。\n**结论：正确。**",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "除了选择稳健的置信区间构建方法外，我们还可以通过主动设计更高效的蒙特卡洛实验来从根本上提高估计精度，即减小估计量的方差，从而获得更窄的置信区间。分层抽样是实现这一目标的关键方差缩减技术。本练习  将指导您推导著名的奈曼分配（Neyman allocation）法则，该法则展示了如何在固定的计算预算约束下，最优地将样本分配到各个层中，以最小化分层均值估计量的方差，进而得到最紧凑的置信区间。",
            "id": "3298330",
            "problem": "一位计算科学家试图在分层蒙特卡洛设计下估计一个目标总量的总体均值。总体被划分为 $H \\geq 2$ 个互不相交的层，由 $h \\in \\{1,\\dots,H\\}$ 索引。层权重已知，由 $\\{p_h\\}_{h=1}^{H}$ 给出，其中 $\\sum_{h=1}^{H} p_h = 1$ 且对于每个 $h$ 都有 $p_h \\in (0,1)$。在层 $h$ 内，抽取独立同分布的随机变量 $\\{X_{h,i}\\}_{i=1}^{n_h}$，其方差为有限值 $\\sigma_h^2 \\in (0,\\infty)$。目标是使用分层蒙特卡洛估计量 $\\hat{\\mu} = \\sum_{h=1}^{H} p_h \\bar{X}_h$ 来估计总体均值 $\\mu = \\sum_{h=1}^{H} p_h \\mu_h$，其中 $\\mu_h = \\mathbb{E}[X_{h,1}]$ 且 $\\bar{X}_h = n_h^{-1} \\sum_{i=1}^{n_h} X_{h,i}$。样本分配 $\\{n_h\\}$ 是设计变量，由科学家在抽样前选定。\n\n在层 $h$ 中抽取的每个样本都会产生一个已知的、为正的单位成本 $c_h \\in (0,\\infty)$。总可用预算是一个固定值 $C \\in (0,\\infty)$，并且设计必须满足确定性预算约束 $\\sum_{h=1}^{H} c_h n_h = C$。假设为优化的目的，$n_h$ 被视为实值设计变量，并且 $\\{X_{h,i}\\}$ 在 $h$ 和 $i$ 之间是独立的。\n\n仅使用基本原理，即：(i) 在每层内独立同分布的条件下，层样本均值的方差为 $\\sigma_h^2 / n_h$，以及 (ii) $\\hat{\\mu}$ 的渐近正态性可由中心极限定理 (CLT) 得出，因此对于固定的 $\\alpha \\in (0,1)$，双边 $(1-\\alpha)$ 置信区间的半宽与 $\\sqrt{\\operatorname{Var}(\\hat{\\mu})}$ 成正比，请推导在预算约束下最小化渐近置信区间半宽的分配规则 $\\{n_h\\}$。然后，将得到的最小方差 $\\operatorname{Var}(\\hat{\\mu})$ 表示为 $C$, $\\{p_h\\}$, $\\{\\sigma_h\\}$ 和 $\\{c_h\\}$ 的闭式函数。\n\n请提供一个单一的闭式解析表达式作为最终答案，该表达式同时指明：(i) 每个层 $h$ 的最优分配 $n_h$，以及 (ii) $\\hat{\\mu}$ 的最小化方差。不需要进行数值评估，也不需要四舍五入。最终答案仅用 $C$, $\\{p_h\\}$, $\\{\\sigma_h\\}$ 和 $\\{c_h\\}$ 表示。",
            "solution": "问题是在分层蒙特卡洛设置中，确定样本的最优分配 $\\{n_h\\}_{h=1}^H$，以便在总预算约束下，最小化总体均值估计量的方差。如问题所述，最小化方差等同于最小化渐近置信区间的半宽。\n\n首先，我们将该优化问题形式化。总体均值 $\\mu = \\sum_{h=1}^{H} p_h \\mu_h$ 的估计量由 $\\hat{\\mu} = \\sum_{h=1}^{H} p_h \\bar{X}_h$ 给出。这个估计量的方差是我们要最小化的目标函数。\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\operatorname{Var}\\left( \\sum_{h=1}^{H} p_h \\bar{X}_h \\right) $$\n鉴于样本 $\\{X_{h,i}\\}$ 在不同层 $h$ 之间是独立的，和的方差等于方差的和：\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\sum_{h=1}^{H} \\operatorname{Var}(p_h \\bar{X}_h) = \\sum_{h=1}^{H} p_h^2 \\operatorname{Var}(\\bar{X}_h) $$\n问题中给出，在层 $h$ 内样本均值的方差为 $\\operatorname{Var}(\\bar{X}_h) = \\frac{\\sigma_h^2}{n_h}$。代入此表达式，我们得到目标函数 $V(\\{n_h\\})$：\n$$ V(\\{n_h\\}) = \\sum_{h=1}^{H} \\frac{p_h^2 \\sigma_h^2}{n_h} $$\n该目标函数需要相对于分配向量 $\\{n_1, n_2, \\dots, n_H\\}$ 进行最小化，并受预算约束：\n$$ \\sum_{h=1}^{H} c_h n_h = C $$\n为了进行此优化，我们将样本量 $n_h$ 视为连续的正实数变量。\n\n这是一个约束优化问题，可以使用拉格朗日乘子法求解。拉格朗日函数 $\\mathcal{L}$ 定义为：\n$$ \\mathcal{L}(\\{n_h\\}, \\lambda) = \\sum_{h=1}^{H} \\frac{p_h^2 \\sigma_h^2}{n_h} + \\lambda \\left( \\sum_{h=1}^{H} c_h n_h - C \\right) $$\n其中 $\\lambda$ 是拉格朗日乘子。为了找到最小值，我们将 $\\mathcal{L}$ 对每个 $n_k$（对于 $k \\in \\{1,\\dots,H\\}$）的偏导数设为零：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial n_k} = -\\frac{p_k^2 \\sigma_k^2}{n_k^2} + \\lambda c_k = 0 $$\n由于所有 $p_k, \\sigma_k, c_k$ 均为正数，$\\lambda$ 也必须为正。重新整理此方程以求解 $n_k$：\n$$ n_k^2 = \\frac{p_k^2 \\sigma_k^2}{\\lambda c_k} $$\n由于样本量 $n_k$ 必须为正，我们取正平方根：\n$$ n_k = \\frac{p_k \\sigma_k}{\\sqrt{\\lambda} \\sqrt{c_k}} $$\n该关系表明，一个层的最优样本量与其权重 $p_k$ 和标准差 $\\sigma_k$ 成正比，与其抽样成本的平方根 $\\sqrt{c_k}$ 成反比。\n\n为了找到比例常数（其取决于 $\\lambda$），我们将 $n_k$ 的这个表达式代入预算约束方程：\n$$ \\sum_{k=1}^{H} c_k \\left( \\frac{p_k \\sigma_k}{\\sqrt{\\lambda} \\sqrt{c_k}} \\right) = C $$\n$$ \\frac{1}{\\sqrt{\\lambda}} \\sum_{k=1}^{H} p_k \\sigma_k \\sqrt{c_k} = C $$\n现在我们可以解出项 $1/\\sqrt{\\lambda}$：\n$$ \\frac{1}{\\sqrt{\\lambda}} = \\frac{C}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} $$\n将其代回 $n_k$ 的表达式，得到每个层 $k$ 的显式最优分配规则：\n$$ n_k = \\left( \\frac{C}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} \\right) \\frac{p_k \\sigma_k}{\\sqrt{c_k}} = C \\frac{p_k \\sigma_k / \\sqrt{c_k}}{\\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j}} $$\n\n接下来，我们通过将最优分配代回方差公式来推导最小化方差 $\\operatorname{Var}(\\hat{\\mu})_{min}$。一个更直接的方法是使用拉格朗日函数的一阶条件：\n从 $\\lambda c_k = \\frac{p_k^2 \\sigma_k^2}{n_k^2}$，我们可以两边乘以 $n_k$ 得到 $\\lambda c_k n_k = \\frac{p_k^2 \\sigma_k^2}{n_k}$。\n总方差是这些项在所有层上的总和：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\sum_{k=1}^{H} \\frac{p_k^2 \\sigma_k^2}{n_k} = \\sum_{k=1}^{H} \\lambda c_k n_k = \\lambda \\sum_{k=1}^{H} c_k n_k $$\n使用预算约束 $\\sum_{k=1}^{H} c_k n_k = C$，我们发现一个简单的关系：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\lambda C $$\n为了得到最终表达式，我们需要 $\\lambda$。从我们之前得到的 $1/\\sqrt{\\lambda}$ 的结果，我们将两边平方以求得 $1/\\lambda$：\n$$ \\frac{1}{\\lambda} = \\frac{C^2}{\\left( \\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j} \\right)^2} \\implies \\lambda = \\frac{1}{C^2} \\left( \\sum_{j=1}^{H} p_j \\sigma_j \\sqrt{c_j} \\right)^2 $$\n将 $\\lambda$ 的这个表达式代入最小方差的方程中：\n$$ \\operatorname{Var}(\\hat{\\mu})_{min} = \\left( \\frac{1}{C^2} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 \\right) C = \\frac{1}{C} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 $$\n这就给出了最优分配下的最小方差的闭式表达式。\n\n最终答案包含两部分：任意层 $h$ 的最优分配 $n_h$ 的公式，以及由此产生的估计量 $\\hat{\\mu}$ 的最小方差的公式。这些都按要求进行了表达。",
            "answer": "$$ \\boxed{\\begin{pmatrix} n_h = C \\frac{p_h \\sigma_h / \\sqrt{c_h}}{\\sum_{k=1}^{H} p_k \\sigma_k \\sqrt{c_k}}  \\operatorname{Var}(\\hat{\\mu}) = \\frac{1}{C} \\left( \\sum_{h=1}^{H} p_h \\sigma_h \\sqrt{c_h} \\right)^2 \\end{pmatrix}} $$"
        },
        {
            "introduction": "在理论推导之外，通过计算模拟来凭经验比较不同方法的性能，是建立实践直觉的关键一步。在实践中，我们常常面临在不同类型的置信区间之间做出选择。这个编程练习  将对比我们熟悉的基于中心极限定理的区间和源于集中不等式（如霍夫丁不等式和伯恩斯坦不等式）的非渐近区间。通过模拟它们在不同样本量和分布形态下的表现，您将深入理解在保证覆盖率和追求区间宽度之间的权衡，并学会在具体问题中选择最合适的方法。",
            "id": "3298410",
            "problem": "给定一个有界独立同分布序列 $\\{X_i\\}_{i=1}^n$，其中 $X_i \\in [a,b]$ 且具有有限均值 $\\mu = \\mathbb{E}[X_i]$。均值的蒙特卡洛估计量是样本均值 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。一个 $(1-\\alpha)$ 置信区间是任何以 $\\bar{X}_n$ 为中心，且在数据生成机制下，包含真实均值 $\\mu$ 的概率至少为 $1-\\alpha$ 的随机区间。\n\n目标是在有界设定下，比较三种针对 $\\mu$ 的置信区间的经验覆盖属性和平均半宽度。这三种置信区间各自基于不同的基本原理构建：一种基于 Hoeffding 不等式，一种基于带有数据驱动方差代理的 Bernstein 不等式，以及一种基于中心极限定理（CLT）并使用正态近似。你必须从蒙特卡洛估计量、有界随机变量的基本概率不等式以及中心极限定理的基础定义出发；为每个区间推导出合适的半宽度；然后通过模拟来估计覆盖概率和平均半宽度。\n\n你的程序必须：\n- 实现三个针对 $\\mu$ 的双边 $(1-\\alpha)$ 置信区间，每个区间都以 $\\bar{X}_n$ 为中心，分别通过以下方式获得：\n  1. 从适用于 $[a,b]$ 内有界随机变量的 Hoeffding 不等式推导出的界。\n  2. 从 Bernstein 不等式推导出的界，该不等式包含一个方差项，并通过使用样本方差作为插入式代理来操作。\n  3. 基于 CLT 的区间，使用正态分位数和样本标准差。\n- 对于每种区间构造方法，根据经验估计其覆盖概率（定义为区间包含真实均值 $\\mu$ 的蒙特卡洛重复实验的比例），并计算其在所有重复实验中的平均半宽度。\n- 为了可复现性，使用固定的随机种子。\n\n你必须通过从有界分布中模拟来创建具有不同范围、方差、偏度和样本大小的多种情况。使用以下测试套件，其中每个测试用例指定了分布、其参数、界 $[a,b]$、样本大小 $n$、名义水平 $\\alpha$ 以及蒙特卡洛重复实验次数 $R$。对于下面的每个案例，真实均值 $\\mu$ 由分布和参数确定，并应用于覆盖率检查。\n\n测试套件（四个案例）：\n1. 案例 U-small：在 $[a,b]$ 上的均匀分布，其中 $a=0, b=1, n=20, \\alpha=0.05, R=5000$。\n2. 案例 T-skew：在 $[a,b]$ 上的三角分布，其中 $a=0, b=1$, 众数 $m=0.9, n=40, \\alpha=0.05, R=5000$。三角分布的密度函数支撑集在 $[a,b]$ 上，众数在 $m \\in [a,b]$；其均值为 $(a+b+m)/3$。\n3. 案例 B-wide：在 $[0,1]$ 上的 Beta 分布，形状参数为 $(\\alpha_{\\text{B}},\\beta_{\\text{B}})=(0.5,3)$，线性缩放到 $[a,b]$，其中 $a=-1, b=2, n=100, \\alpha=0.05, R=5000$。在 $[0,1]$ 上的均值为 $\\alpha_{\\text{B}}/(\\alpha_{\\text{B}}+\\beta_{\\text{B}})$；缩放到 $[a,b]$ 后变为 $a + (b-a)\\, \\alpha_{\\text{B}}/(\\alpha_{\\text{B}}+\\beta_{\\text{B}})$。\n4. 案例 B-large-n：在 $[0,1]$ 上的 Beta 分布，形状参数为 $(\\alpha_{\\text{B}},\\beta_{\\text{B}})=(2,2)$，缩放到 $[a,b]$，其中 $a=-0.5, b=0.5, n=1000, \\alpha=0.05, R=2000$。\n\n实现要求：\n- 对于每次重复实验，根据指定案例抽取 $n$ 个独立样本 $X_1,\\dots,X_n$，计算 $\\bar{X}_n$，计算自由度为 $n-1$ 的样本方差 $s^2$，并按上述方法构建三个区间。\n- 在所有模拟中使用固定的随机种子。\n- 对于基于 Bernstein 的区间，在不等式中使用样本方差的插入式方法来确定半宽度。对于基于 CLT 的区间，使用 $(1-\\alpha/2)$ 标准正态分位数和样本标准差。\n- 对于每个案例，返回：\n  - Hoeffding、Bernstein 和 CLT 区间的经验覆盖概率，为三个浮点数。\n  - Hoeffding、Bernstein 和 CLT 区间的平均半宽度，为三个浮点数。\n  - 一个整数代码，表示根据以下规则选择的“更优”方法：在经验覆盖率至少为 $1-\\alpha$ 的区间中，选择平均半宽度最小的方法；如果没有一个区间的覆盖率达到 $1-\\alpha$，则选择经验覆盖率最高的方法，若有平局则选择平均半宽度最小的方法。将 Hoeffding 编码为 $0$，Bernstein 编码为 $1$，CLT 编码为 $2$。\n\n最终输出格式：\n- 你的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表。其中每个元素对应一个测试案例，其本身是一个形如以下形式的列表：\n  - $[\\,[\\text{cov}_{\\text{H}},\\text{cov}_{\\text{B}},\\text{cov}_{\\text{C}}],\\,[\\text{hw}_{\\text{H}},\\text{hw}_{\\text{B}},\\text{hw}_{\\text{C}}],\\,\\text{pref}\\,]$\n  - 此处，$\\text{cov}_{\\text{H}}$, $\\text{cov}_{\\text{B}}$, $\\text{cov}_{\\text{C}}$ 是 Hoeffding、Bernstein 和 CLT 区间经验覆盖率的浮点数；$\\text{hw}_{\\text{H}}$, $\\text{hw}_{\\text{B}}$, $\\text{hw}_{\\text{C}}$ 是平均半宽度的浮点数；$\\text{pref}$ 是偏好代码，为整数 $\\{0,1,2\\}$。\n你的程序必须精确地打印一行此格式的输出，并且不能读取任何输入。",
            "solution": "该问题要求比较三种为有界随机变量的均值 $\\mu$ 构建 $(1-\\alpha)$ 置信区间的不同方法。该均值通过蒙特卡洛样本均值 $\\bar{X}_n$ 进行估计。这些方法分别基于 Hoeffding 不等式、Bernstein 不等式和中心极限定理（CLT）。置信区间的形式为 $[\\bar{X}_n - \\epsilon, \\bar{X}_n + \\epsilon]$，其中 $\\epsilon$ 是半宽度。任务的核心是为每种方法推导出 $\\epsilon$ 的表达式，然后通过模拟从经验上评估其性能（覆盖概率和平均半宽度）。\n\n设 $\\{X_i\\}_{i=1}^n$ 是一个独立同分布（i.i.d.）随机变量序列，对于已知的界 $a$ 和 $b$，有 $X_i \\in [a, b]$。均值 $\\mu = \\mathbb{E}[X_i]$ 的估计量是样本均值 $\\bar{X}_n = \\frac{1}{n}\\sum_{i=1}^n X_i$。一个双边 $(1-\\alpha)$ 置信区间必须满足 $\\mathbb{P}(\\mu \\in [\\bar{X}_n - \\epsilon, \\bar{X}_n + \\epsilon]) \\ge 1-\\alpha$，这等价于控制尾部概率 $\\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le \\alpha$。\n\n### 1. 置信区间推导\n\n#### 1.1. Hoeffding 区间\nHoeffding 不等式为有界随机变量的样本均值与其期望值之间的偏差提供了一个无分布界。对于独立同分布的 $X_i \\in [a, b]$，该不等式为：\n$$ \\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le 2 \\exp\\left(-\\frac{2n\\epsilon^2}{(b-a)^2}\\right) $$\n为了构建一个 $(1-\\alpha)$ 置信区间，我们将右侧设为 $\\alpha$ 并求解半宽度，我们将其表示为 $\\epsilon_H$：\n$$ 2 \\exp\\left(-\\frac{2n\\epsilon_H^2}{(b-a)^2}\\right) = \\alpha $$\n$$ \\exp\\left(-\\frac{2n\\epsilon_H^2}{(b-a)^2}\\right) = \\frac{\\alpha}{2} $$\n取两边的自然对数：\n$$ -\\frac{2n\\epsilon_H^2}{(b-a)^2} = \\ln\\left(\\frac{\\alpha}{2}\\right) = -\\ln\\left(\\frac{2}{\\alpha}\\right) $$\n求解 $\\epsilon_H$：\n$$ \\epsilon_H^2 = \\frac{(b-a)^2}{2n}\\ln\\left(\\frac{2}{\\alpha}\\right) $$\n$$ \\epsilon_H = (b-a) \\sqrt{\\frac{\\ln(2/\\alpha)}{2n}} $$\n这个半宽度是确定性的，仅取决于问题参数 $n$、$\\alpha$ 和范围 $(b-a)$，而不取决于观测数据。它保证了至少 $(1-\\alpha)$ 的覆盖率，但通常比较保守（即比必要的更宽）。\n\n#### 1.2. Bernstein 区间\nBernstein 不等式是一个更精细的集中不等式，它包含了随机变量的方差，当方差较小时，能提供更紧的界。针对样本均值的一种常见形式的 Bernstein 不等式是：\n$$ \\mathbb{P}(|\\bar{X}_n - \\mu| \\ge \\epsilon) \\le 2 \\exp\\left(-\\frac{n\\epsilon^2}{2(\\sigma^2 + C\\epsilon/3)}\\right) $$\n其中 $\\sigma^2 = \\text{Var}(X_i)$，$C$ 是 $|X_i - \\mu|$ 的一个上界。一个安全但可能宽松的选择是数据范围 $C = b-a$。\n\n由于真实方差 $\\sigma^2$ 未知，问题指定使用样本方差 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^n(X_i - \\bar{X}_n)^2$ 作为“插入式代理”。这使得最终的半宽度 $\\epsilon_B$ 依赖于数据。我们将界设为 $\\alpha$ 并求解 $\\epsilon_B$：\n$$ 2 \\exp\\left(-\\frac{n\\epsilon_B^2}{2(s^2 + (b-a)\\epsilon_B/3)}\\right) = \\alpha $$\n令 $K = \\ln(2/\\alpha)$，上式简化为：\n$$ \\frac{n\\epsilon_B^2}{2(s^2 + (b-a)\\epsilon_B/3)} = K $$\n$$ n\\epsilon_B^2 = 2K(s^2 + (b-a)\\epsilon_B/3) $$\n整理后得到一个关于 $\\epsilon_B$ 的二次方程：\n$$ n\\epsilon_B^2 - \\left(\\frac{2K(b-a)}{3}\\right)\\epsilon_B - 2Ks^2 = 0 $$\n使用二次公式求得该方程的正根，即为半宽度：\n$$ \\epsilon_B = \\frac{\\frac{2K(b-a)}{3} + \\sqrt{\\left(\\frac{2K(b-a)}{3}\\right)^2 + 8nKs^2}}{2n} $$\n这个“经验 Bernstein”区间预计会比 Hoeffding 区间更紧，因为它能适应观测到的样本方差。\n\n#### 1.3. 中心极限定理 (CLT) 区间\n中心极限定理指出，对于大样本 $n$，标准化样本均值的分布收敛于标准正态分布：\n$$ \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} \\mathcal{N}(0, 1) $$\n这为以下近似提供了理论依据：\n$$ \\mathbb{P}\\left(-z_{1-\\alpha/2} \\le \\frac{\\bar{X}_n - \\mu}{\\sigma/\\sqrt{n}} \\le z_{1-\\alpha/2}\\right) \\approx 1-\\alpha $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。根据 Slutsky 定理，我们可以用样本标准差 $s = \\sqrt{s^2}$ 替换未知的总体标准差 $\\sigma$，而不会改变其渐近分布。整理不等式得到我们熟悉的基于 CLT 的置信区间，其半宽度为 $\\epsilon_C$：\n$$ \\epsilon_C = z_{1-\\alpha/2} \\frac{s}{\\sqrt{n}} $$\n这个区间是渐近精确的，意味着当 $n \\to \\infty$ 时，其覆盖概率收敛于 $(1-\\alpha)$。然而，对于有限的 $n$，特别是在分布有偏或重尾的情况下，其实际覆盖率可能偏离名义水平。\n\n### 2. 模拟与评估\n\n该程序实现了一个蒙特卡洛模拟，用以评估这一系列测试案例中这三种区间的性能。对于每个案例，模拟过程如下：\n1.  总共执行 $R$ 次重复实验。\n2.  在每次重复实验中，从指定的分布中抽取一个大小为 $n$ 的随机样本。\n3.  计算样本均值 $\\bar{X}_n$ 和样本方差 $s^2$（自由度为 $n-1$）。\n4.  计算三种半宽度——$\\epsilon_H$（常数）、$\\epsilon_B$（依赖于 $s^2$）和 $\\epsilon_C$（依赖于 $s$）。\n5.  对于这三种区间中的每一种，检查它是否包含真实均值 $\\mu$（即，是否 $|\\bar{X}_n - \\mu| \\le \\epsilon$）。\n6.  在所有重复实验结束后，每种方法的经验覆盖概率是区间包含 $\\mu$ 的次数所占的比例。平均半宽度是所有重复实验中计算出的半宽度的均值。\n\n最后，根据一个双层规则选择一个“更优”的方法：在达到至少名义覆盖率 $(1-\\alpha)$ 的方法中，选择平均半宽度最小的那个。如果没有方法达到此覆盖率，则选择经验覆盖率最高的方法，并以最小的平均半宽度打破平局。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation study and print results.\n    \"\"\"\n    # Use a fixed random seed for all simulations for reproducibility.\n    # The RNG is created once and passed to the simulation function.\n    rng = np.random.default_rng(12345)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Uniform distribution, small sample size\n        {'dist': 'uniform', 'params': {}, 'a': 0.0, 'b': 1.0, 'n': 20, 'alpha': 0.05, 'R': 5000},\n        # Case 2: Skewed triangular distribution\n        {'dist': 'triangular', 'params': {'mode': 0.9}, 'a': 0.0, 'b': 1.0, 'n': 40, 'alpha': 0.05, 'R': 5000},\n        # Case 3: Scaled and skewed Beta distribution\n        {'dist': 'beta', 'params': {'alpha_B': 0.5, 'beta_B': 3.0}, 'a': -1.0, 'b': 2.0, 'n': 100, 'alpha': 0.05, 'R': 5000},\n        # Case 4: Scaled symmetric Beta distribution, large sample size\n        {'dist': 'beta', 'params': {'alpha_B': 2.0, 'beta_B': 2.0}, 'a': -0.5, 'b': 0.5, 'n': 1000, 'alpha': 0.05, 'R': 2000},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_for_case(case, rng)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation_for_case(case, rng):\n    \"\"\"\n    Runs the simulation for a single test case.\n    \"\"\"\n    dist, params, a, b, n, alpha, R = case['dist'], case['params'], case['a'], case['b'], case['n'], case['alpha'], case['R']\n    \n    # Calculate the true mean (mu) for the distribution\n    if dist == 'uniform':\n        mu = (a + b) / 2.0\n    elif dist == 'triangular':\n        mu = (a + b + params['mode']) / 3.0\n    elif dist == 'beta':\n        mu_01 = params['alpha_B'] / (params['alpha_B'] + params['beta_B'])\n        mu = a + (b - a) * mu_01\n\n    # Pre-calculate constants for interval calculations\n    z_quantile = norm.ppf(1.0 - alpha / 2.0)\n    hoeffding_hw = (b - a) * np.sqrt(np.log(2.0 / alpha) / (2.0 * n))\n    bernstein_K = np.log(2.0 / alpha)\n    bernstein_C_param = b - a\n\n    # Initialize accumulators for metrics\n    coverage_counts = np.zeros(3)  # [Hoeffding, Bernstein, CLT]\n    hw_sums = np.zeros(3)          # [Hoeffding, Bernstein, CLT]\n\n    for _ in range(R):\n        # 1. Generate a sample of size n from the specified distribution\n        if dist == 'uniform':\n            samples = rng.uniform(low=a, high=b, size=n)\n        elif dist == 'triangular':\n            samples = rng.triangular(left=a, mode=params['mode'], right=b, size=n)\n        elif dist == 'beta':\n            samples_01 = rng.beta(a=params['alpha_B'], b=params['beta_B'], size=n)\n            samples = a + (b - a) * samples_01\n\n        # 2. Compute sample statistics\n        x_bar = np.mean(samples)\n        s_squared = np.var(samples, ddof=1)\n        # Ensure variance is non-negative for robustness\n        s_squared = max(0.0, s_squared)\n        s = np.sqrt(s_squared)\n\n        # 3. Calculate interval half-widths for this sample\n        # Hoeffding half-width is constant\n        \n        # Bernstein half-width\n        quad_A = float(n)\n        quad_B = -2.0 * bernstein_C_param * bernstein_K / 3.0\n        quad_C = -2.0 * s_squared * bernstein_K\n        discriminant = quad_B**2 - 4.0 * quad_A * quad_C\n        bernstein_hw = (-quad_B + np.sqrt(discriminant)) / (2.0 * quad_A)\n\n        # CLT half-width\n        clt_hw = z_quantile * s / np.sqrt(n)\n        \n        half_widths = [hoeffding_hw, bernstein_hw, clt_hw]\n        hw_sums += half_widths\n\n        # 4. Check coverage for each method\n        deviation = np.abs(x_bar - mu)\n        if deviation = half_widths[0]:\n            coverage_counts[0] += 1\n        if deviation = half_widths[1]:\n            coverage_counts[1] += 1\n        if deviation = half_widths[2]:\n            coverage_counts[2] += 1\n\n    # 5. Calculate final empirical metrics\n    empirical_coverages = (coverage_counts / R).tolist()\n    average_half_widths = (hw_sums / R).tolist()\n\n    # 6. Apply the preference rule\n    methods = [\n        (empirical_coverages[0], average_half_widths[0], 0), # Hoeffding\n        (empirical_coverages[1], average_half_widths[1], 1), # Bernstein\n        (empirical_coverages[2], average_half_widths[2], 2)  # CLT\n    ]\n\n    target_coverage = 1.0 - alpha\n    valid_methods = [m for m in methods if m[0] >= target_coverage]\n    \n    if valid_methods:\n        # Among methods with sufficient coverage, choose the one with the smallest half-width\n        best_method = min(valid_methods, key=lambda x: x[1])\n    else:\n        # If no method has sufficient coverage, choose the one with the highest coverage\n        # Break ties using the smallest half-width.\n        best_method = max(methods, key=lambda x: (x[0], -x[1]))\n\n    pref_code = best_method[2]\n\n    # Format result for this case\n    return [empirical_coverages, average_half_widths, pref_code]\n\nsolve()\n```"
        }
    ]
}