{
    "hands_on_practices": [
        {
            "introduction": "这项实践提供了分层抽样核心优势——方差缩减——的一个基础练习。通过专注于估计重尾帕累托分布的尾部期望（这是金融和风险分析等领域的常见挑战），你将从第一性原理出发推导最优的Neyman分配。 这个结合了编码和分析的动手问题将具体展示一个精心设计的分层方案如何能比原始蒙特卡洛方法显著提高估计效率。",
            "id": "3349482",
            "problem": "考虑一个重尾随机变量 $X$，其帕累托分布由尺度参数 $x_m>0$ 和形状参数 $\\alpha>2$ 表征，其概率密度函数（PDF）为 $f_X(x)=\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$，适用于 $x\\ge x_m$。定义由指示函数加权的尾部被积函数 $g(x)=x\\mathbf{1}\\{xx_0\\}$，其中阈值 $x_0x_m$。目标是使用蒙特卡洛（MC）方法估计尾部期望 $\\mu=E[g(X)]$，并证明采用奈曼分配的双层分层抽样设计相比于原始蒙特卡洛方法能降低变异系数。\n\n仅从期望、方差和分层抽样的基本定义出发，不使用预先指定的快捷公式，执行以下操作：\n\n1. 定义两个层：主体层 $h=0$ 为 $[x_m,x_0]$，尾部层 $h=1$ 为 $(x_0,\\infty)$。设层权重为 $w_h=P(X\\in\\text{stratum }h)$，被积函数的层内标准差为 $\\sigma_h=\\sqrt{\\mathrm{Var}(g(X)\\mid X\\in\\text{stratum }h)}$。使用第一性原理，为帕累托模型推导计算 $\\mu$、$\\mathrm{Var}(g(X))$ 和 $\\mathrm{Var}(g(X)\\mid Xx_0)$ 所需的符号表达式。\n\n2. 构建分层估计量 $\\hat{\\mu}_{\\text{strat}}=\\sum_{h=0}^1 w_h \\bar{g}_h$，其中 $\\bar{g}_h$ 是从限制在第 $h$ 层的 $X$ 的条件分布中抽取的 $n_h$ 个独立样本计算出的 $g(X)$ 的样本均值。从 $\\hat{\\mu}_{\\text{strat}}$ 在独立性下的方差出发，推导在固定总样本量 $N=\\sum_{h=0}^1 n_h$ 的约束下使方差最小化的奈曼分配法则 $n_h\\propto w_h \\sigma_h$。解释此法则如何应用于当前的 $g(x)$，并注意任何零方差的贡献。\n\n3. 定义无偏估计量 $\\hat{\\mu}$ 的变异系数（CV）为 $\\mathrm{CV}=\\sqrt{\\mathrm{Var}(\\hat{\\mu})}/\\mu$。对于从 $X$ 中抽取 $N$ 个独立样本的原始蒙特卡洛方法，用 $\\mathrm{Var}(g(X))$、$\\mu$ 和 $N$ 表示 $\\mathrm{CV}_{\\text{crude}}$。对于采用奈曼分配的双层设计，用尾部层的量和 $N$ 表示 $\\mathrm{CV}_{\\text{strat}}$。\n\n4. 实现一个程序，使用您推导的解析表达式计算 $\\mathrm{CV}_{\\text{crude}}$、$\\mathrm{CV}_{\\text{strat}}$ 及其比率 $r=\\mathrm{CV}_{\\text{strat}}/\\mathrm{CV}_{\\text{crude}}$。使用以下参数值测试套件来评估和比较变异系数：\n   - 测试用例 1：$(\\alpha,x_m,x_0,N)=(3.0,1.0,2.0,10000)$\n   - 测试用例 2：$(\\alpha,x_m,x_0,N)=(2.1,1.0,5.0,10000)$\n   - 测试用例 3：$(\\alpha,x_m,x_0,N)=(5.0,1.0,10.0,10000)$\n   - 测试用例 4：$(\\alpha,x_m,x_0,N)=(3.0,1.0,1.1,10000)$\n\n5. 对于每个测试用例，还需计算表示是否改进的布尔值 $b$，定义为 $b = (\\mathrm{CV}_{\\text{strat}}  \\mathrm{CV}_{\\text{crude}})$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试用例展平顺序排列：$[\\mathrm{CV}_{\\text{crude}}^{(1)},\\mathrm{CV}_{\\text{strat}}^{(1)},r^{(1)},b^{(1)},\\mathrm{CV}_{\\text{crude}}^{(2)},\\mathrm{CV}_{\\text{strat}}^{(2)},r^{(2)},b^{(2)},\\mathrm{CV}_{\\text{crude}}^{(3)},\\mathrm{CV}_{\\text{strat}}^{(3)},r^{(3)},b^{(3)},\\mathrm{CV}_{\\text{crude}}^{(4)},\\mathrm{CV}_{\\text{strat}}^{(4)},r^{(4)},b^{(4)}]$。所有数值答案必须是无量纲实数（浮点数）或布尔值。此问题不涉及物理单位。",
            "solution": "所述问题具有科学依据，提法恰当，客观，并包含足够的信息以得出唯一解。这是蒙特卡洛积分中方差缩减技术的标准应用，没有矛盾或谬误。因此，该问题被认为是有效的。我们从第一性原理出发，给出一个完整的解。\n\n该解答需要推导与帕累托分布随机变量 $X$ 相关的几个统计量的符号表达式。概率密度函数（PDF）由 $f_X(x) = \\alpha x_m^{\\alpha} x^{-(\\alpha+1)}$ 给出，适用于 $x \\ge x_m$，参数为 $\\alpha  2$ 和 $x_m  0$。我们感兴趣的被积函数是 $g(x) = x\\mathbf{1}\\{xx_0\\}$，其中 $x_0  x_m$。\n\n### 第1部分：基本量的推导\n\n首先，我们推导 $X$ 的累积分布函数（CDF），记为 $F_X(x) = P(X \\le x)$，这对于计算层权重至关重要。对于 $x \\ge x_m$：\n$$\nF_X(x) = \\int_{x_m}^{x} f_X(t) dt = \\int_{x_m}^{x} \\alpha x_m^{\\alpha} t^{-(\\alpha+1)} dt = \\alpha x_m^{\\alpha} \\left[ \\frac{t^{-\\alpha}}{-\\alpha} \\right]_{x_m}^{x} = -x_m^{\\alpha} (x^{-\\alpha} - x_m^{-\\alpha}) = 1 - \\left(\\frac{x_m}{x}\\right)^{\\alpha}\n$$\n\n两个层分别是对应于区间 $[x_m, x_0]$ 的主体层 $h=0$ 和对应于 $(x_0, \\infty)$ 的尾部层 $h=1$。层权重 $w_h = P(X \\in \\text{stratum } h)$ 为：\n$$\nw_0 = P(x_m \\le X \\le x_0) = F_X(x_0) - F_X(x_m) = \\left(1 - \\left(\\frac{x_m}{x_0}\\right)^{\\alpha}\\right) - 0 = 1 - \\left(\\frac{x_m}{x_0}\\right)^{\\alpha}\n$$\n$$\nw_1 = P(X  x_0) = 1 - F_X(x_0) = 1 - \\left(1 - \\left(\\frac{x_m}{x_0}\\right)^{\\alpha}\\right) = \\left(\\frac{x_m}{x_0}\\right)^{\\alpha}\n$$\n可以很容易地验证 $w_0 + w_1 = 1$。\n\n现在，我们推导被积函数 $g(X) = X\\mathbf{1}\\{Xx_0\\}$ 的矩。\n期望 $\\mu = \\mathrm{E}[g(X)]$ 由以下公式给出：\n$$\n\\mu = \\int_{x_m}^{\\infty} g(x) f_X(x) dx = \\int_{x_m}^{\\infty} x\\mathbf{1}\\{xx_0\\} (\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}) dx\n$$\n指示函数 $\\mathbf{1}\\{xx_0\\}$ 将积分域限制在 $(x_0, \\infty)$：\n$$\n\\mu = \\int_{x_0}^{\\infty} x (\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}) dx = \\alpha x_m^{\\alpha} \\int_{x_0}^{\\infty} x^{-\\alpha} dx = \\alpha x_m^{\\alpha} \\left[ \\frac{x^{-\\alpha+1}}{1-\\alpha} \\right]_{x_0}^{\\infty}\n$$\n由于 $\\alpha  2$，上限处的项为 $0$。\n$$\n\\mu = \\alpha x_m^{\\alpha} \\left(0 - \\frac{x_0^{1-\\alpha}}{1-\\alpha}\\right) = \\frac{\\alpha}{\\alpha-1} x_m^{\\alpha} x_0^{1-\\alpha}\n$$\n为了求方差 $\\mathrm{Var}(g(X)) = \\mathrm{E}[g(X)^2] - \\mu^2$，我们首先计算二阶矩 $\\mathrm{E}[g(X)^2]$：\n$$\n\\mathrm{E}[g(X)^2] = \\int_{x_0}^{\\infty} x^2 (\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}) dx = \\alpha x_m^{\\alpha} \\int_{x_0}^{\\infty} x^{1-\\alpha} dx = \\alpha x_m^{\\alpha} \\left[ \\frac{x^{2-\\alpha}}{2-\\alpha} \\right]_{x_0}^{\\infty}\n$$\n由于 $\\alpha  2$，上限处的项同样为 $0$。\n$$\n\\mathrm{E}[g(X)^2] = \\alpha x_m^{\\alpha} \\left(0 - \\frac{x_0^{2-\\alpha}}{2-\\alpha}\\right) = \\frac{\\alpha}{\\alpha-2} x_m^{\\alpha} x_0^{2-\\alpha}\n$$\n因此，方差为：\n$$\n\\mathrm{Var}(g(X)) = \\frac{\\alpha}{\\alpha-2} x_m^{\\alpha} x_0^{2-\\alpha} - \\left(\\frac{\\alpha}{\\alpha-1} x_m^{\\alpha} x_0^{1-\\alpha}\\right)^2\n$$\n接下来，我们确定层内方差 $\\sigma_h^2 = \\mathrm{Var}(g(X) \\mid X \\in \\text{stratum } h)$。\n对于层 $h=0$ ($[x_m, x_0]$)：被积函数 $g(X) = X\\mathbf{1}\\{Xx_0\\}$ 对于此层中的任何 $X$ 都恒等于 $0$。常数的方差为 $0$。\n$$\n\\sigma_0^2 = \\mathrm{Var}(g(X) \\mid X \\in [x_m, x_0]) = 0 \\implies \\sigma_0 = 0\n$$\n对于层 $h=1$ ($(x_0, \\infty)$)：此处，$g(X) = X$。我们需要计算 $\\sigma_1^2 = \\mathrm{Var}(X \\mid X  x_0)$。条件PDF为 $f_{X|Xx_0}(x) = f_X(x)/P(Xx_0) = f_X(x)/w_1$，适用于 $x  x_0$。\n$$\nf_{X|Xx_0}(x) = \\frac{\\alpha x_m^{\\alpha} x^{-(\\alpha+1)}}{(x_m/x_0)^{\\alpha}} = \\alpha x_0^{\\alpha} x^{-(\\alpha+1)}\n$$\n这是一个形状为 $\\alpha$、尺度为 $x_0$ 的帕累托分布的PDF。我们需要它的方差。条件均值为：\n$$\n\\mathrm{E}[X \\mid X  x_0] = \\int_{x_0}^{\\infty} x (\\alpha x_0^{\\alpha} x^{-(\\alpha+1)}) dx = \\frac{\\alpha}{\\alpha-1} x_0\n$$\n条件二阶矩为：\n$$\n\\mathrm{E}[X^2 \\mid X  x_0] = \\int_{x_0}^{\\infty} x^2 (\\alpha x_0^{\\alpha} x^{-(\\alpha+1)}) dx = \\frac{\\alpha}{\\alpha-2} x_0^2\n$$\n条件方差为：\n$$\n\\sigma_1^2 = \\mathrm{Var}(X \\mid X  x_0) = \\mathrm{E}[X^2 \\mid X  x_0] - (\\mathrm{E}[X \\mid X  x_0])^2 = \\frac{\\alpha}{\\alpha-2} x_0^2 - \\left(\\frac{\\alpha}{\\alpha-1} x_0\\right)^2\n$$\n$$\n\\sigma_1^2 = x_0^2 \\alpha \\left(\\frac{1}{\\alpha-2} - \\frac{\\alpha}{(\\alpha-1)^2}\\right) = x_0^2 \\alpha \\left(\\frac{(\\alpha-1)^2 - \\alpha(\\alpha-2)}{(\\alpha-2)(\\alpha-1)^2}\\right) = x_0^2 \\alpha \\left(\\frac{\\alpha^2 - 2\\alpha + 1 - \\alpha^2 + 2\\alpha}{(\\alpha-2)(\\alpha-1)^2}\\right)\n$$\n$$\n\\sigma_1^2 = \\frac{\\alpha x_0^2}{(\\alpha-2)(\\alpha-1)^2}\n$$\n\n### 第2部分：奈曼分配\n\n分层估计量为 $\\hat{\\mu}_{\\text{strat}} = \\sum_{h=0}^1 w_h \\bar{g}_h$，其中 $\\bar{g}_h$ 是从第 $h$ 层抽取的 $n_h$ 个样本的均值。此估计量的方差为：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = \\sum_{h=0}^1 w_h^2 \\mathrm{Var}(\\bar{g}_h) = \\sum_{h=0}^1 w_h^2 \\frac{\\sigma_h^2}{n_h} = \\frac{w_0^2 \\sigma_0^2}{n_0} + \\frac{w_1^2 \\sigma_1^2}{n_1}\n$$\n奈曼分配在固定总样本量 $N=n_0+n_1$ 的约束下最小化此方差。我们使用拉格朗日乘子法。设 $L(n_0, n_1, \\lambda) = \\frac{w_0^2 \\sigma_0^2}{n_0} + \\frac{w_1^2 \\sigma_1^2}{n_1} + \\lambda(n_0+n_1-N)$。\n将偏导数设为零，$\\frac{\\partial L}{\\partial n_h} = -\\frac{w_h^2 \\sigma_h^2}{n_h^2} + \\lambda = 0$，得到 $n_h = \\frac{w_h \\sigma_h}{\\sqrt{\\lambda}}$。这表明 $n_h \\propto w_h \\sigma_h$。确切的分配是 $n_h = N \\frac{w_h \\sigma_h}{\\sum_k w_k \\sigma_k}$。\n\n在我们具体的问题中，$\\sigma_0 = 0$。分配公式规定：\n$$\nn_0 = N \\frac{w_0 \\sigma_0}{w_0 \\sigma_0 + w_1 \\sigma_1} = 0\n$$\n$$\nn_1 = N \\frac{w_1 \\sigma_1}{w_0 \\sigma_0 + w_1 \\sigma_1} = N \\frac{w_1 \\sigma_1}{w_1 \\sigma_1} = N\n$$\n该规则指示所有抽样工作都应集中在层1，因为层0的方差为零，其对积分的贡献确定为零。在奈曼分配下，总方差通常可以表示为 $\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = \\frac{1}{N}(\\sum_h w_h \\sigma_h)^2$。在我们的情况下，这简化为：\n$$\n\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = \\frac{1}{N}(w_0 \\sigma_0 + w_1 \\sigma_1)^2 = \\frac{(w_1 \\sigma_1)^2}{N}\n$$\n\n### 第3部分：变异系数\n\n无偏估计量 $\\hat{\\mu}$ 的变异系数（CV）为 $\\mathrm{CV} = \\sqrt{\\mathrm{Var}(\\hat{\\mu})}/\\mu$。\n对于有 $N$ 个样本的原始蒙特卡洛方法，$\\hat{\\mu}_{\\text{crude}}$ 是无偏的，其方差为 $\\mathrm{Var}(\\hat{\\mu}_{\\text{crude}}) = \\mathrm{Var}(g(X))/N$。\n$$\n\\mathrm{CV}_{\\text{crude}} = \\frac{\\sqrt{\\mathrm{Var}(g(X))/N}}{\\mu} = \\frac{\\sqrt{\\mathrm{Var}(g(X))}}{\\mu \\sqrt{N}}\n$$\n对于采用奈曼分配的分层抽样，$\\hat{\\mu}_{\\text{strat}}$ 也是无偏的，其方差为 $\\mathrm{Var}(\\hat{\\mu}_{\\text{strat}}) = (w_1 \\sigma_1)^2/N$。\n$$\n\\mathrm{CV}_{\\text{strat}} = \\frac{\\sqrt{(w_1 \\sigma_1)^2/N}}{\\mu} = \\frac{w_1 \\sigma_1}{\\mu \\sqrt{N}}\n$$\n\n### 第4和第5部分：实现公式\n\n程序将为每个测试用例 $(\\alpha, x_m, x_0, N)$ 实现上述推导的以下公式：\n1.  均值：$\\mu = \\frac{\\alpha}{\\alpha-1} x_m^{\\alpha} x_0^{1-\\alpha}$\n2.  $g(X)$ 的方差：$\\mathrm{Var}(g(X)) = \\left(\\frac{\\alpha}{\\alpha-2} x_m^{\\alpha} x_0^{2-\\alpha}\\right) - \\mu^2$\n3.  $\\mathrm{CV}_{\\text{crude}} = \\frac{\\sqrt{\\mathrm{Var}(g(X))}}{\\mu \\sqrt{N}}$\n4.  尾部权重：$w_1 = (x_m/x_0)^{\\alpha}$\n5.  尾部标准差：$\\sigma_1 = \\sqrt{\\frac{\\alpha x_0^2}{(\\alpha-2)(\\alpha-1)^2}} = \\frac{x_0}{\\alpha-1}\\sqrt{\\frac{\\alpha}{\\alpha-2}}$\n6.  $\\mathrm{CV}_{\\text{strat}} = \\frac{w_1 \\sigma_1}{\\mu \\sqrt{N}}$\n7.  比率：$r = \\mathrm{CV}_{\\text{strat}} / \\mathrm{CV}_{\\text{crude}} = \\frac{w_1 \\sigma_1}{\\sqrt{\\mathrm{Var}(g(X))}}$\n8.  改进：$b = (\\mathrm{CV}_{\\text{strat}}  \\mathrm{CV}_{\\text{crude}})$。如全方差公式所示，$\\mathrm{Var}(g(X)) = w_1 \\sigma_1^2 + w_0 w_1 (\\mu/w_1)^2 = w_1\\sigma_1^2 + w_0/w_1 \\mu^2$。比率的平方为 $r^2 = \\frac{w_1^2 \\sigma_1^2}{\\mathrm{Var}(g(X))} = \\frac{w_1^2 \\sigma_1^2}{w_1 \\sigma_1^2 + w_0 w_1 (\\mu/w_1)^2}  1$，只要 $w_0>0$（这由 $x_0>x_m$ 保证）。因此，$b$ 将始终为真。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares coefficients of variation for crude Monte Carlo\n    and stratified sampling estimators of a tail expectation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, x_m, x_0, N)\n        (3.0, 1.0, 2.0, 10000),\n        (2.1, 1.0, 5.0, 10000),\n        (5.0, 1.0, 10.0, 10000),\n        (3.0, 1.0, 1.1, 10000),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, x_m, x_0, N = case\n\n        # 1. Calculate the true mean mu = E[g(X)]\n        mu = (alpha / (alpha - 1)) * (x_m**alpha) * (x_0**(1 - alpha))\n\n        # 2. Calculate the variance of g(X) for crude MC\n        # E[g(X)^2]\n        E_g_sq = (alpha / (alpha - 2)) * (x_m**alpha) * (x_0**(2 - alpha))\n        var_g = E_g_sq - mu**2\n\n        # 3. Calculate CV_crude\n        cv_crude = np.sqrt(var_g) / (mu * np.sqrt(N))\n\n        # 4. Calculate quantities for stratified sampling\n        # Stratum 1 (tail) weight w_1\n        w_1 = (x_m / x_0)**alpha\n        \n        # Stratum 1 (tail) standard deviation sigma_1\n        sigma_1_sq = (alpha * x_0**2) / ((alpha - 2) * (alpha - 1)**2)\n        sigma_1 = np.sqrt(sigma_1_sq)\n\n        # 5. Calculate CV_strat\n        cv_strat = (w_1 * sigma_1) / (mu * np.sqrt(N))\n\n        # 6. Calculate the ratio and improvement boolean\n        ratio = cv_strat / cv_crude\n        improvement = cv_strat  cv_crude\n\n        # Append results in the specified order\n        results.append(cv_crude)\n        results.append(cv_strat)\n        results.append(ratio)\n        results.append(improvement)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了提高效率，分层抽样还是一个修正由混淆变量引起的偏差的强大工具。本实践使用经典的辛普森悖论作为例子，来阐明这一关键作用。 你将构建一个蒙特卡洛模拟，在其中，一个幼稚的、未分层的分析会得出一个与事实完全相反的结论，然后你将展示分层抽样如何通过恢复正确的处理效应来解决这个悖论。这个练习凸显了分层在确保因果推断的准确性和有效性方面的重要性。",
            "id": "3349495",
            "problem": "构建一个完整的 Monte Carlo 实验，在分层抽样的背景下展示 Simpson 悖论。在以下具有两个或更多个层的完全指定、纯概率性的数据生成过程中进行操作。对于每个单元，层标签 $S \\in \\{0,1,\\dots,K-1\\}$ 从具有层概率 $\\pi_s$ 的分类分布中独立抽取，处理 $T \\in \\{0,1\\}$ 在单元间独立分配，但具有依赖于层的概率 $\\tau_s = \\mathbb{P}(T=1 \\mid S=s)$，结果由以下公式生成\n$$\nY = \\mu_s + \\delta_s \\, T + \\varepsilon_s, \\quad \\varepsilon_s \\sim \\mathcal{N}(0,\\sigma_s^2) \\text{ independently across units, with } \\sigma_s \\ge 0.\n$$\n这里，$\\mu_s$ 是特定于层的基线均值，$\\delta_s$ 是特定于层的处理效应，$\\sigma_s^2$ 是特定于层的方差。平均处理效应 (ATE) 定义为 $\\sum_{s=0}^{K-1} \\pi_s \\, \\delta_s$。考虑两种处理效应的估计量：\n- 忽略 $S$ 的朴素均值差估计量，即处理组中 $Y$ 的样本均值减去对照组中 $Y$ 的样本均值，即 $\\bar{Y}_{T=1} - \\bar{Y}_{T=0}$。\n- 分层均值差估计量，它首先计算层内差异 $\\bar{Y}_{1,s} - \\bar{Y}_{0,s}$，然后使用等于总体层概率 $\\pi_s$ 的预先指定的权重对这些差异进行聚合，即 $\\sum_{s=0}^{K-1} \\pi_s \\, (\\bar{Y}_{1,s} - \\bar{Y}_{0,s})$。\n\n您的程序必须对下面的每个测试用例执行以下所有操作：\n1) 使用提供的参数和随机种子，从上述模型中模拟一个大小为 $n$ 的独立同分布样本。从此模拟样本中计算朴素估计量和分层估计量。这两个值是 Monte Carlo 的输出。\n2) 根据条件期望和贝叶斯法则的定义，从第一性原理推导在所述数据生成过程中朴素估计量和分层估计量的解析期望（不要使用任何预先推导的估计量公式）。为提供的参数数值计算这些解析期望。\n3) 判断 Simpson 悖论是否在期望上发生，这里定义为朴素估计量的解析期望与 ATE（等于分层估计量的解析期望）符号相反的事件，即它们的乘积是否为负。\n4) 对于朴素估计量和分层估计量，检查模拟的 Monte Carlo 估计值是否在其解析期望的 $0.02$ 绝对容差内。\n\n测试套件。对于每个测试用例，您将得到元组 $\\left(K,\\ \\boldsymbol{\\pi},\\ \\boldsymbol{\\tau},\\ \\boldsymbol{\\mu},\\ \\boldsymbol{\\delta},\\ \\boldsymbol{\\sigma},\\ n,\\ \\text{seed}\\right)$，其语义如下：\n- $K$：层的数量。\n- $\\boldsymbol{\\pi} = (\\pi_0,\\dots,\\pi_{K-1})$，层概率，满足 $\\sum_s \\pi_s = 1$。\n- $\\boldsymbol{\\tau} = (\\tau_0,\\dots,\\tau_{K-1})$，处理分配概率。\n- $\\boldsymbol{\\mu} = (\\mu_0,\\dots,\\mu_{K-1})$，基线均值。\n- $\\boldsymbol{\\delta} = (\\delta_0,\\dots,\\delta_{K-1})$，处理效应。\n- $\\boldsymbol{\\sigma} = (\\sigma_0,\\dots,\\sigma_{K-1})$，标准差。\n- $n$：样本量。\n- $\\text{seed}$：用于可复现性的整数种子。\n\n使用以下四个测试用例：\n- 案例 A（两个层；在层内效应为正的情况下出现 Simpson 悖论）：$K = 2$，$\\boldsymbol{\\pi} = (0.3, 0.7)$，$\\boldsymbol{\\tau} = (0.9, 0.1)$，$\\boldsymbol{\\mu} = (0.0, 2.0)$，$\\boldsymbol{\\delta} = (1.0, 1.0)$，$\\boldsymbol{\\sigma} = (1.0, 1.0)$，$n = 200000$，$\\text{seed} = 202701$。\n- 案例 B（两个层；无混淆，因此无悖论）：$K = 2$，$\\boldsymbol{\\pi} = (0.3, 0.7)$，$\\boldsymbol{\\tau} = (0.5, 0.5)$，$\\boldsymbol{\\mu} = (0.0, 2.0)$，$\\boldsymbol{\\delta} = (1.0, 0.5)$，$\\boldsymbol{\\sigma} = (1.0, 1.0)$，$n = 200000$，$\\text{seed} = 202702$。\n- 案例 C（两个层；结果噪声为零且存在强混淆）：$K = 2$，$\\boldsymbol{\\pi} = (0.2, 0.8)$，$\\boldsymbol{\\tau} = (0.95, 0.05)$，$\\boldsymbol{\\mu} = (1.0, 4.0)$，$\\boldsymbol{\\delta} = (0.4, 0.4)$，$\\boldsymbol{\\sigma} = (0.0, 0.0)$，$n = 200000$，$\\text{seed} = 202703$。\n- 案例 D（三个层；处理效应恒定但分配存在混淆）：$K = 3$，$\\boldsymbol{\\pi} = (0.1, 0.2, 0.7)$，$\\boldsymbol{\\tau} = (0.9, 0.5, 0.1)$，$\\boldsymbol{\\mu} = (0.0, 1.0, 3.0)$，$\\boldsymbol{\\delta} = (0.5, 0.5, 0.5)$，$\\boldsymbol{\\sigma} = (1.0, 1.0, 1.0)$，$n = 300000$，$\\text{seed} = 202704$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个 Python 风格的列表，该列表包含四个内部列表，每个测试用例一个，顺序与上面相同。每个内部列表必须按此顺序包含七个条目：\n$[$ Monte Carlo 朴素估计量（四舍五入到六位小数），Monte Carlo 分层估计量（四舍五入到六位小数），朴素估计量的解析期望（四舍五入到六位小数），分层估计量的解析期望（四舍五入到六位小数），Monte Carlo 朴素估计值与其解析期望在 $0.02$ 内是否接近的布尔值，Monte Carlo 分层估计值与其解析期望在 $0.02$ 内是否接近的布尔值，指示 Simpson 悖论是否在期望上发生的布尔值 $]$。\n例如，您的程序应打印类似以下形式的内容\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\n在单行上，不带任何其他字符。本问题不涉及百分比或物理单位。",
            "solution": "## 问题验证\n该问题陈述是随机模拟和因果推断领域中一个有效、适定且具有科学依据的练习。\n\n### 步骤 1：提取已知条件\n- **数据生成过程**：对于每个单元，从具有概率 $\\boldsymbol{\\pi} = (\\pi_s)$ 的分类分布中抽取一个层标签 $S \\in \\{0, 1, \\dots, K-1\\}$。处理 $T \\in \\{0, 1\\}$ 以依赖于层的概率 $\\tau_s = \\mathbb{P}(T=1 \\mid S=s)$ 进行分配。结果 $Y$ 由 $Y = \\mu_s + \\delta_s T + \\varepsilon_s$ 生成，其中 $\\varepsilon_s \\sim \\mathcal{N}(0, \\sigma_s^2)$。\n- **平均处理效应 (ATE)**：目标参数是 $ATE = \\sum_{s=0}^{K-1} \\pi_s \\delta_s$。\n- **朴素估计量**：$\\hat{\\delta}_{naive} = \\bar{Y}_{T=1} - \\bar{Y}_{T=0}$，即未调整的均值差。\n- **分层估计量**：$\\hat{\\delta}_{strat} = \\sum_{s=0}^{K-1} \\pi_s (\\bar{Y}_{1,s} - \\bar{Y}_{0,s})$，其中 $\\bar{Y}_{t,s}$ 是 $T=t$ 和 $S=s$ 的单元的 $Y$ 的样本均值。\n- **模拟任务**：对于每个测试用例，模拟一个大小为 $n$ 的样本，计算 $\\hat{\\delta}_{naive}$ 和 $\\hat{\\delta}_{strat}$ 的 Monte Carlo 估计值。\n- **解析任务**：推导两个估计量的解析期望并计算它们的数值。\n- **Simpson 悖论定义**：如果在期望上 $\\mathbb{E}[\\hat{\\delta}_{naive}] \\times ATE  0$，则悖论发生。\n- **接近性检查**：如果绝对差小于 $0.02$，则 Monte Carlo 估计值“接近”其解析期望。\n- **测试用例**：提供了四个特定的参数集 $(K, \\boldsymbol{\\pi}, \\boldsymbol{\\tau}, \\boldsymbol{\\mu}, \\boldsymbol{\\delta}, \\boldsymbol{\\sigma}, n, \\text{seed})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题使用标准的潜在结果框架和结果的线性模型，这是因果推断和计量经济学的基石。混淆、分层和 Simpson 悖论的概念是统计学的基础。整个设置在科学上和数学上都是合理的。\n- **适定性**：问题是完全指定的。模拟和解析计算所需的所有参数都已提供。目标清晰明确，为每个测试用例导出一组唯一且有意义的结果。\n- **客观性**：问题以精确的数学语言陈述，没有主观性或歧义。\n\n### 步骤 3：结论与行动\n问题是有效的。我们继续进行解答。\n\n---\n\n## 估计量期望的解析推导\n\n我们从第一性原理推导分层估计量和朴素估计量的解析期望。\n\n### 分层估计量的期望\n分层估计量定义为 $\\hat{\\delta}_{strat} = \\sum_{s=0}^{K-1} \\pi_s (\\bar{Y}_{1,s} - \\bar{Y}_{0,s})$。\n根据期望的线性性质，其期望值为：\n$$\n\\mathbb{E}[\\hat{\\delta}_{strat}] = \\mathbb{E}\\left[\\sum_{s=0}^{K-1} \\pi_s (\\bar{Y}_{1,s} - \\bar{Y}_{0,s})\\right] = \\sum_{s=0}^{K-1} \\pi_s \\mathbb{E}[\\bar{Y}_{1,s} - \\bar{Y}_{0,s}]\n$$\n为了评估内部的期望，我们考虑在给定层 $s$ 和处理状态 $t$ 的条件下的期望结果。对于层 $s$ 中接受处理 $T=1$ 的单元：\n$$\n\\mathbb{E}[Y | S=s, T=1] = \\mathbb{E}[\\mu_s + \\delta_s \\cdot 1 + \\varepsilon_s] = \\mu_s + \\delta_s\n$$\n因为 $\\mathbb{E}[\\varepsilon_s] = 0$。由于样本均值 $\\bar{Y}_{1,s}$ 是条件总体均值的无偏估计量，我们有 $\\mathbb{E}[\\bar{Y}_{1,s}] = \\mu_s + \\delta_s$。\n类似地，对于层 $s$ 中的对照单元 ($T=0$)：\n$$\n\\mathbb{E}[Y | S=s, T=0] = \\mathbb{E}[\\mu_s + \\delta_s \\cdot 0 + \\varepsilon_s] = \\mu_s\n$$\n因此，$\\mathbb{E}[\\bar{Y}_{0,s}] = \\mu_s$。\n层内均值差的期望是：\n$$\n\\mathbb{E}[\\bar{Y}_{1,s} - \\bar{Y}_{0,s}] = \\mathbb{E}[\\bar{Y}_{1,s}] - \\mathbb{E}[\\bar{Y}_{0,s}] = (\\mu_s + \\delta_s) - \\mu_s = \\delta_s\n$$\n将此代回 $\\mathbb{E}[\\hat{\\delta}_{strat}]$ 的表达式中：\n$$\n\\mathbb{E}[\\hat{\\delta}_{strat}] = \\sum_{s=0}^{K-1} \\pi_s \\delta_s\n$$\n这正是平均处理效应 (ATE) 的定义。因此，分层估计量是 ATE 的无偏估计量。\n\n### 朴素估计量的期望\n朴素估计量为 $\\hat{\\delta}_{naive} = \\bar{Y}_{T=1} - \\bar{Y}_{T=0}$。其期望为 $\\mathbb{E}[\\hat{\\delta}_{naive}] = \\mathbb{E}[\\bar{Y}_{T=1}] - \\mathbb{E}[\\bar{Y}_{T=0}]$。根据大数定律，$\\mathbb{E}[\\bar{Y}_{T=t}] = \\mathbb{E}[Y | T=t]$。我们使用全期望定律，以层 $S$ 为条件。\n对于处理组：\n$$\n\\mathbb{E}[Y | T=1] = \\sum_{s=0}^{K-1} \\mathbb{E}[Y | S=s, T=1] \\mathbb{P}(S=s | T=1)\n$$\n我们有 $\\mathbb{E}[Y | S=s, T=1] = \\mu_s + \\delta_s$。我们使用贝叶斯法则来找到条件概率 $\\mathbb{P}(S=s | T=1)$：\n$$\n\\mathbb{P}(S=s | T=1) = \\frac{\\mathbb{P}(T=1 | S=s) \\mathbb{P}(S=s)}{\\mathbb{P}(T=1)} = \\frac{\\tau_s \\pi_s}{\\sum_{s'=0}^{K-1} \\mathbb{P}(T=1 | S=s') \\mathbb{P}(S=s')} = \\frac{\\tau_s \\pi_s}{\\sum_{s'=0}^{K-1} \\tau_{s'} \\pi_{s'}}\n$$\n因此，处理组的期望结果是：\n$$\n\\mathbb{E}[Y | T=1] = \\sum_{s=0}^{K-1} (\\mu_s + \\delta_s) \\frac{\\tau_s \\pi_s}{\\sum_{s'} \\tau_{s'} \\pi_{s'}} = \\frac{\\sum_{s=0}^{K-1} \\pi_s \\tau_s (\\mu_s + \\delta_s)}{\\sum_{s'} \\pi_{s'} \\tau_{s'}}\n$$\n对于对照组，通过类似的逻辑：\n$$\n\\mathbb{E}[Y | T=0] = \\sum_{s=0}^{K-1} \\mathbb{E}[Y | S=s, T=0] \\mathbb{P}(S=s | T=0)\n$$\n其中 $\\mathbb{E}[Y | S=s, T=0] = \\mu_s$ 且 $\\mathbb{P}(S=s | T=0) = \\frac{(1-\\tau_s) \\pi_s}{\\sum_{s'} (1-\\tau_{s'}) \\pi_{s'}}$，我们得到：\n$$\n\\mathbb{E}[Y | T=0] = \\frac{\\sum_{s=0}^{K-1} \\pi_s (1-\\tau_s) \\mu_s}{\\sum_{s'} \\pi_{s'} (1-\\tau_{s'})}\n$$\n朴素估计量的期望是这两个量的差：\n$$\n\\mathbb{E}[\\hat{\\delta}_{naive}] = \\frac{\\sum_{s=0}^{K-1} \\pi_s \\tau_s (\\mu_s + \\delta_s)}{\\sum_{s'} \\pi_{s'} \\tau_{s'}} - \\frac{\\sum_{s=0}^{K-1} \\pi_s (1-\\tau_s) \\mu_s}{\\sum_{s'} \\pi_{s'} (1-\\tau_{s'})}\n$$\n这个表达式揭示了 $\\mathbb{E}[\\hat{\\delta}_{naive}]$ 由真实效应 $\\delta_s$ 的加权平均和由混淆产生的偏差项组成。如果处理概率 $\\tau_s$ 与各层间的基线均值 $\\mu_s$ 相关，则偏差项非零。如果对于所有 $s$，$\\tau_s$ 都是常数，则没有混淆，偏差项消失，使得 $\\mathbb{E}[\\hat{\\delta}_{naive}] = ATE$。当这种偏差足够强以至于改变了估计量在期望上的符号时，即 $\\mathbb{E}[\\hat{\\delta}_{naive}] \\times ATE  0$，就会出现 Simpson 悖论。\n\n## 计算策略\n对于每个测试用例，程序将执行以下步骤：\n\n1.  **解析计算**：\n    - 使用 $ATE = \\sum_{s} \\pi_s \\delta_s$ 计算 ATE，即分层估计量的解析期望。\n    - 使用上面推导的公式计算朴素估计量的解析期望。\n    - 通过检查 $ATE \\times \\mathbb{E}[\\hat{\\delta}_{naive}]  0$ 来判断是否发生 Simpson 悖论。\n\n2.  **Monte Carlo 模拟**：\n    - 使用指定的种子初始化随机数生成器以确保可复现性。\n    - 从由 $\\boldsymbol{\\pi}$ 定义的分类分布中抽取一个大小为 $n$ 的层标签 $S$ 样本。\n    - 对于层 $S_i=s$ 中的每个模拟单元 $i$，通过从参数为 $\\tau_s$ 的伯努利分布中抽样来分配处理 $T_i$。\n    - 对于每个单元 $i$，结果 $Y_i$ 生成为 $Y_i = \\mu_{S_i} + \\delta_{S_i} T_i + \\varepsilon_i$，其中 $\\varepsilon_i$ 从 $\\mathcal{N}(0, \\sigma_{S_i}^2)$ 中抽取。\n\n3.  **Monte Carlo 估计量**：\n    - 朴素估计量 $\\hat{\\delta}_{naive}$，通过计算所有处理单元的样本均值结果与所有对照单元的样本均值结果之间的差值来计算。\n    - 分层估计量 $\\hat{\\delta}_{strat}$，通过首先计算每个层 $s$ 内的均值差，然后对这些差异进行加权平均来计算，权重由 $\\pi_s$ 给出。\n\n4.  **最终评估**：\n    - 将模拟的估计量 $\\hat{\\delta}_{naive}$ 和 $\\hat{\\delta}_{strat}$ 与它们各自的解析期望进行比较。通过检查绝对差值是否在 $0.02$ 的容差范围内来确定接近程度。\n    - 将结果，包括两个 Monte Carlo 估计值、两个解析期望、两个布尔接近性检查和布尔悖论指示符，收集并按规定格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo experiments for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: two strata; Simpson’s paradox with positive within-stratum effects\n        (2, np.array([0.3, 0.7]), np.array([0.9, 0.1]), np.array([0.0, 2.0]), np.array([1.0, 1.0]), np.array([1.0, 1.0]), 200000, 202701),\n        # Case B: two strata; no confounding so no paradox\n        (2, np.array([0.3, 0.7]), np.array([0.5, 0.5]), np.array([0.0, 2.0]), np.array([1.0, 0.5]), np.array([1.0, 1.0]), 200000, 202702),\n        # Case C: two strata; zero outcome noise and strong confounding\n        (2, np.array([0.2, 0.8]), np.array([0.95, 0.05]), np.array([1.0, 4.0]), np.array([0.4, 0.4]), np.array([0.0, 0.0]), 200000, 202703),\n        # Case D: three strata; constant treatment effect but confounded assignment\n        (3, np.array([0.1, 0.2, 0.7]), np.array([0.9, 0.5, 0.1]), np.array([0.0, 1.0, 3.0]), np.array([0.5, 0.5, 0.5]), np.array([1.0, 1.0, 1.0]), 300000, 202704),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = process_case(*case_params)\n        all_results.append(result)\n\n    # Format the final output as a Python-style list of lists.\n    output_str = \"[\"\n    for i, res in enumerate(all_results):\n        # Unpack results and format them\n        mc_naive, mc_strat, an_naive, an_strat, close_naive, close_strat, paradox = res\n        \n        # Format list elements\n        res_str = f\"[{mc_naive:.6f},{mc_strat:.6f},{an_naive:.6f},{an_strat:.6f},{close_naive},{close_strat},{paradox}]\"\n        \n        output_str += res_str\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\n\ndef process_case(K, pi, tau, mu, delta, sigma, n, seed):\n    \"\"\"\n    Processes a single test case: performs analytical calculations, \n    runs the simulation, and computes the required outputs.\n    \"\"\"\n    \n    # --- 1. Analytical Computations ---\n    \n    # The ATE is the analytical expectation of the stratified estimator.\n    analytical_strat_exp = np.sum(pi * delta)\n\n    # Calculate the analytical expectation of the naive estimator.\n    tau_overall = np.sum(pi * tau)\n    \n    # Handle edge cases where tau_overall is 0 or 1.\n    if tau_overall > 0:\n        exp_Y_T1 = np.sum(pi * tau * (mu + delta)) / tau_overall\n    else:\n        exp_Y_T1 = 0\n    \n    if tau_overall  1:\n        exp_Y_T0 = np.sum(pi * (1 - tau) * mu) / (1 - tau_overall)\n    else:\n        exp_Y_T0 = 0\n\n    analytical_naive_exp = exp_Y_T1 - exp_Y_T0\n\n    # Determine if Simpson's paradox occurs in expectation.\n    simpson_paradox_occurs = (analytical_naive_exp * analytical_strat_exp)  0\n\n    # --- 2. Monte Carlo Simulation ---\n    rng = np.random.default_rng(seed)\n\n    # a. Generate strata S\n    S = rng.choice(K, size=n, p=pi)\n\n    # b. Generate treatment T\n    # Vectorized assignment: create an array of treatment probabilities based on stratum\n    tau_by_unit = tau[S]\n    T = (rng.random(size=n)  tau_by_unit).astype(int)\n\n    # c. Generate outcome Y\n    mu_by_unit = mu[S]\n    delta_by_unit = delta[S]\n    sigma_by_unit = sigma[S]\n    epsilon = rng.normal(loc=0.0, scale=sigma_by_unit, size=n)\n    Y = mu_by_unit + delta_by_unit * T + epsilon\n\n    # --- 3. Compute Monte Carlo Estimators ---\n    \n    # a. Naive difference-in-means estimator\n    mask_treated = T == 1\n    mask_control = T == 0\n    \n    # Ensure no division by zero if a group is empty (unlikely with large n)\n    mc_naive_est = 0\n    if np.any(mask_treated) and np.any(mask_control):\n        mc_naive_est = np.mean(Y[mask_treated]) - np.mean(Y[mask_control])\n\n    # b. Stratified difference-in-means estimator\n    strat_diffs = np.zeros(K)\n    for s in range(K):\n        mask_s = (S == s)\n        Y_s_treated = Y[(mask_s)  (mask_treated)]\n        Y_s_control = Y[(mask_s)  (mask_control)]\n\n        # Calculate within-stratum difference, handling potentially empty cells\n        if Y_s_treated.size > 0 and Y_s_control.size > 0:\n            strat_diffs[s] = np.mean(Y_s_treated) - np.mean(Y_s_control)\n        else:\n            # If a cell is empty, its contribution to the effect is undefined.\n            # We treat it as 0, which is reasonable if n is large and this event is rare.\n            # For this problem's parameters, cells will be populated.\n            strat_diffs[s] = 0.0\n\n    mc_strat_est = np.sum(pi * strat_diffs)\n    \n    # --- 4. Closeness Checks ---\n    tolerance = 0.02\n    naive_is_close = np.abs(mc_naive_est - analytical_naive_exp)  tolerance\n    strat_is_close = np.abs(mc_strat_est - analytical_strat_exp)  tolerance\n\n    return [\n        mc_naive_est,\n        mc_strat_est,\n        analytical_naive_exp,\n        analytical_strat_exp,\n        naive_is_close,\n        strat_is_close,\n        simpson_paradox_occurs,\n    ]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "现实世界中的蒙特卡洛模拟，特别是针对稀有事件的模拟，经常面临数据稀疏的问题，即某些层中可能没有观测到任何事件。这会使得简单的基于频率的估计变得不稳定或具有误导性。 本实践引入了一种稳健的贝叶斯方法来应对这一挑战，使用共轭贝塔先验分布来“平滑”各层的估计。你将推导整体事件概率的后验均值和方差，从而在数据稀缺的情况下提供一个更稳定、更有原则的估计。",
            "id": "3349500",
            "problem": "考虑一个分层蒙特卡洛（MC）模拟，用于估计跨越 $H$ 个不相交分层的稀有事件概率。设特定分层的事件概率为 $p_{h} \\in (0,1)$（对于 $h \\in \\{1,\\dots,H\\}$），并假设我们关心的总体事件概率是总体加权量 $\\theta = \\sum_{h=1}^{H} w_{h} p_{h}$，其中已知的分层权重满足 $w_{h} \\geq 0$ 和 $\\sum_{h=1}^{H} w_{h} = 1$。在每个分层 $h$ 内，您观察到 $n_{h}$ 次独立的伯努利($p_{h}$)试验，其中有 $y_{h}$ 次观测到的事件。在稀有事件情景下，即使 $p_{h}  0$，某些分层也可能没有观测到事件（$y_{h} = 0$），这为贝叶斯平滑提供了动机。假设每个分层都有独立的贝塔先验分布 $p_{h} \\sim \\mathrm{Beta}(a_{h}, b_{h})$。\n\n从贝叶斯定理和 $\\theta$ 作为 $p_{h}$ 的加权平均的定义出发，在给定分层二项观测值和贝塔先验分布的情况下，推导每个 $p_{h}$ 的后验分布。然后，利用期望和方差的基本性质，在假设各分层在给定数据下条件独立的条件下，推导后验均值 $\\mathbb{E}[\\theta \\mid \\text{data}]$ 和后验方差 $\\mathrm{Var}(\\theta \\mid \\text{data})$。\n\n最后，为以下具有潜在零计数的科学真实、小样本、稀有事件场景计算这两个后验摘要：\n- 分层数：$H = 4$。\n- 分层权重：$(w_{1}, w_{2}, w_{3}, w_{4}) = (0.4, 0.3, 0.2, 0.1)$。\n- 观测计数和试验次数：$(y_{1}, n_{1}) = (0, 25)$，$(y_{2}, n_{2}) = (1, 10)$，$(y_{3}, n_{3}) = (0, 15)$，$(y_{4}, n_{4}) = (0, 5)$。\n- 独立的贝塔先验分布：对所有 $h$，$(a_{h}, b_{h}) = (0.2, 3.8)$。\n\n将数对 $\\big(\\mathbb{E}[\\theta \\mid \\text{data}], \\mathrm{Var}(\\theta \\mid \\text{data})\\big)$ 作为您的最终答案报告。将两个数值均四舍五入到五位有效数字。此概率和方差无需单位。",
            "solution": "经评估，问题陈述有效。它在科学上基于标准的贝叶斯统计理论，特别是对二项式似然使用共轭贝塔先验。问题提法严谨，提供了计算唯一解所需的所有数据和定义。语言客观且数学上精确。没有矛盾、歧义或事实错误。\n\n我们的任务是推导复合参数 $\\theta = \\sum_{h=1}^{H} w_{h} p_{h}$ 的后验均值和方差，其中每个 $p_{h}$ 是一个特定分层的概率。推导过程主要分两步：首先，确定每个 $p_{h}$ 的后验分布；其次，使用这些后验分布来求 $\\theta$ 的矩。\n\n**步骤1：推导 $p_{h}$ 的后验分布**\n\n对于每个分层 $h \\in \\{1,\\dots,H\\}$，我们给定了概率 $p_{h}$ 的先验分布和基于观测数据的似然函数。\n\n$p_{h}$ 的先验分布为贝塔分布：\n$$p(p_{h}) \\sim \\mathrm{Beta}(a_{h}, b_{h})$$\n其概率密度函数（PDF）与 $p_{h}^{a_{h}-1} (1-p_{h})^{b_{h}-1}$ 成正比。\n$$p(p_{h}) \\propto p_{h}^{a_{h}-1} (1-p_{h})^{b_{h}-1}$$\n\n分层 $h$ 的数据包括在 $n_{h}$ 次独立伯努利试验中观测到 $y_{h}$ 次事件。给定此数据，特定 $p_{h}$ 值的似然由二项式概率质量函数描述：\n$$L(p_{h} \\mid y_{h}, n_{h}) = \\binom{n_{h}}{y_{h}} p_{h}^{y_{h}} (1-p_{h})^{n_{h}-y_{h}}$$\n\n根据贝叶斯定理，$p_{h}$ 的后验分布与似然和先验的乘积成正比：\n$$p(p_{h} \\mid y_{h}, n_{h}) \\propto L(p_{h} \\mid y_{h}, n_{h}) \\cdot p(p_{h})$$\n代入表达式并舍去常数二项式系数 $\\binom{n_{h}}{y_{h}}$：\n$$p(p_{h} \\mid y_{h}, n_{h}) \\propto \\left( p_{h}^{y_{h}} (1-p_{h})^{n_{h}-y_{h}} \\right) \\cdot \\left( p_{h}^{a_{h}-1} (1-p_{h})^{b_{h}-1} \\right)$$\n合并具有相同底数的项：\n$$p(p_{h} \\mid y_{h}, n_{h}) \\propto p_{h}^{y_{h} + a_{h} - 1} (1-p_{h})^{n_{h} - y_{h} + b_{h} - 1}$$\n\n这个函数形式是贝塔分布的核。这证明了贝塔先验与二项式似然的共轭性。因此，给定数据的 $p_{h}$ 的后验分布为：\n$$p_{h} \\mid y_{h}, n_{h} \\sim \\mathrm{Beta}(a_{h} + y_{h}, b_{h} + n_{h} - y_{h})$$\n让我们将后验参数表示为 $a'_{h} = a_{h} + y_{h}$ 和 $b'_{h} = b_{h} + n_{h} - y_{h}$。\n\n**步骤2：推导 $\\theta$ 的后验均值和方差**\n\n总体事件概率 $\\theta$ 是特定分层概率 $p_{h}$ 的线性组合：\n$$\\theta = \\sum_{h=1}^{H} w_{h} p_{h}$$\n\n为了求 $\\theta$ 的后验均值 $\\mathbb{E}[\\theta \\mid \\text{data}]$，我们使用期望的线性性质。期望是基于完整数据集的条件期望，该数据集包含所有分层的观测值。\n$$\\mathbb{E}[\\theta \\mid \\text{data}] = \\mathbb{E}\\left[\\sum_{h=1}^{H} w_{h} p_{h} \\mid \\text{data}\\right] = \\sum_{h=1}^{H} w_{h} \\mathbb{E}[p_{h} \\mid \\text{data}]$$\n由于一个分层中的观测值 $(y_h, n_h)$ 与其他分层中的观测值无关，因此 $p_h$ 的后验分布仅取决于其自身的数据：$\\mathbb{E}[p_{h} \\mid \\text{data}] = \\mathbb{E}[p_{h} \\mid y_{h}, n_{h}]$。\n\n$\\mathrm{Beta}(\\alpha, \\beta)$ 分布的均值为 $\\frac{\\alpha}{\\alpha + \\beta}$。使用后验参数 $a'_{h}$ 和 $b'_{h}$：\n$$\\mathbb{E}[p_{h} \\mid y_{h}, n_{h}] = \\frac{a'_{h}}{a'_{h} + b'_{h}} = \\frac{a_{h} + y_{h}}{(a_{h} + y_{h}) + (b_{h} + n_{h} - y_{h})} = \\frac{a_{h} + y_{h}}{a_{h} + b_{h} + n_{h}}$$\n因此，$\\theta$ 的后验均值为：\n$$\\mathbb{E}[\\theta \\mid \\text{data}] = \\sum_{h=1}^{H} w_{h} \\left( \\frac{a_{h} + y_{h}}{a_{h} + b_{h} + n_{h}} \\right)$$\n\n为了求 $\\theta$ 的后验方差 $\\mathrm{Var}(\\theta \\mid \\text{data})$，我们使用独立随机变量之和的方差等于方差之和的性质。问题陈述要求假设各分层在给定数据下是条件独立的，这意味着 $p_h$ 的后验分布是相互独立的。\n$$\\mathrm{Var}(\\theta \\mid \\text{data}) = \\mathrm{Var}\\left(\\sum_{h=1}^{H} w_{h} p_{h} \\mid \\text{data}\\right) = \\sum_{h=1}^{H} \\mathrm{Var}(w_{h} p_{h} \\mid \\text{data}) = \\sum_{h=1}^{H} w_{h}^{2} \\mathrm{Var}(p_{h} \\mid \\text{data})$$\n\n$\\mathrm{Beta}(\\alpha, \\beta)$ 分布的方差为 $\\frac{\\alpha \\beta}{(\\alpha+\\beta)^{2}(\\alpha+\\beta+1)}$。使用后验参数：\n$$\\mathrm{Var}(p_{h} \\mid y_{h}, n_{h}) = \\frac{a'_{h} b'_{h}}{(a'_{h} + b'_{h})^{2}(a'_{h} + b'_{h} + 1)} = \\frac{(a_{h} + y_{h})(b_{h} + n_{h} - y_{h})}{(a_{h} + b_{h} + n_{h})^{2}(a_{h} + b_{h} + n_{h} + 1)}$$\n因此，$\\theta$ 的后验方差为：\n$$\\mathrm{Var}(\\theta \\mid \\text{data}) = \\sum_{h=1}^{H} w_{h}^{2} \\left( \\frac{(a_{h} + y_{h})(b_{h} + n_{h} - y_{h})}{(a_{h} + b_{h} + n_{h})^{2}(a_{h} + b_{h} + n_{h} + 1)} \\right)$$\n\n**步骤3：数值计算**\n\n我们有以下给定值：\n- $H = 4$\n- $(w_{1}, w_{2}, w_{3}, w_{4}) = (0.4, 0.3, 0.2, 0.1)$\n- $(y_{1}, n_{1}) = (0, 25)$，$(y_{2}, n_{2}) = (1, 10)$，$(y_{3}, n_{3}) = (0, 15)$，$(y_{4}, n_{4}) = (0, 5)$\n- 对所有 $h$，$(a_{h}, b_{h}) = (0.2, 3.8)$，因此对所有 $h$，$a_{h} + b_{h} = 4.0$。\n\n我们计算每个分层的后验均值和方差：\n\n**分层1：** $w_1 = 0.4$, $y_1 = 0$, $n_1 = 25$\n- $\\mathbb{E}[p_{1} \\mid \\text{data}] = \\frac{0.2+0}{4.0+25} = \\frac{0.2}{29}$\n- $\\mathrm{Var}(p_{1} \\mid \\text{data}) = \\frac{(0.2+0)(3.8+25-0)}{(4.0+25)^{2}(4.0+25+1)} = \\frac{0.2 \\times 28.8}{29^{2} \\times 30} = \\frac{5.76}{25230}$\n\n**分层2：** $w_2 = 0.3$, $y_2 = 1$, $n_2 = 10$\n- $\\mathbb{E}[p_{2} \\mid \\text{data}] = \\frac{0.2+1}{4.0+10} = \\frac{1.2}{14}$\n- $\\mathrm{Var}(p_{2} \\mid \\text{data}) = \\frac{(0.2+1)(3.8+10-1)}{(4.0+10)^{2}(4.0+10+1)} = \\frac{1.2 \\times 12.8}{14^{2} \\times 15} = \\frac{15.36}{2940}$\n\n**分层3：** $w_3 = 0.2$, $y_3 = 0$, $n_3 = 15$\n- $\\mathbb{E}[p_{3} \\mid \\text{data}] = \\frac{0.2+0}{4.0+15} = \\frac{0.2}{19}$\n- $\\mathrm{Var}(p_{3} \\mid \\text{data}) = \\frac{(0.2+0)(3.8+15-0)}{(4.0+15)^{2}(4.0+15+1)} = \\frac{0.2 \\times 18.8}{19^{2} \\times 20} = \\frac{3.76}{7220}$\n\n**分层4：** $w_4 = 0.1$, $y_4 = 0$, $n_4 = 5$\n- $\\mathbb{E}[p_{4} \\mid \\text{data}] = \\frac{0.2+0}{4.0+5} = \\frac{0.2}{9}$\n- $\\mathrm{Var}(p_{4} \\mid \\text{data}) = \\frac{(0.2+0)(3.8+5-0)}{(4.0+5)^{2}(4.0+5+1)} = \\frac{0.2 \\times 8.8}{9^{2} \\times 10} = \\frac{1.76}{810}$\n\n现在，我们计算 $\\theta$ 的最终摘要：\n\n**后验均值 $\\mathbb{E}[\\theta \\mid \\text{data}]$：**\n$$\\mathbb{E}[\\theta \\mid \\text{data}] = (0.4)\\frac{0.2}{29} + (0.3)\\frac{1.2}{14} + (0.2)\\frac{0.2}{19} + (0.1)\\frac{0.2}{9}$$\n$$= \\frac{0.08}{29} + \\frac{0.36}{14} + \\frac{0.04}{19} + \\frac{0.02}{9}$$\n$$\\approx 0.00275862 + 0.02571429 + 0.00210526 + 0.00222222$$\n$$\\approx 0.03280039$$\n四舍五入到五位有效数字，$\\mathbb{E}[\\theta \\mid \\text{data}] \\approx 0.032800$。\n\n**后验方差 $\\mathrm{Var}(\\theta \\mid \\text{data})$：**\n$$\\mathrm{Var}(\\theta \\mid \\text{data}) = (0.4)^{2} \\frac{5.76}{25230} + (0.3)^{2} \\frac{15.36}{2940} + (0.2)^{2} \\frac{3.76}{7220} + (0.1)^{2} \\frac{1.76}{810}$$\n$$= (0.16) \\frac{5.76}{25230} + (0.09) \\frac{15.36}{2940} + (0.04) \\frac{3.76}{7220} + (0.01) \\frac{1.76}{810}$$\n$$\\approx 0.16(0.00022830) + 0.09(0.00522449) + 0.04(0.00052078) + 0.01(0.00217284)$$\n$$\\approx 0.000036528 + 0.000470204 + 0.000020831 + 0.000021728$$\n$$\\approx 0.000549291$$\n四舍五入到五位有效数字，$\\mathrm{Var}(\\theta \\mid \\text{data}) \\approx 0.00054929$。\n\n最终的数值对为 $(0.032800, 0.00054929)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.032800  0.00054929 \\end{pmatrix}}$$"
        }
    ]
}