{
    "hands_on_practices": [
        {
            "introduction": "虽然样本间的自相关性通常被视为降低有效样本量（ESS）的麻烦因素，但深刻理解其结构有时能让我们反过来利用它。本练习将探讨如何通过巧妙地应用控制变量技术，主动地消除自回归过程中的相关性，从而显著提升估计效率。这个练习将向你展示，对相关性结构的认识不仅能用于分析，还能用于设计更优的估计器 。",
            "id": "3304651",
            "problem": "考虑一个平稳的一阶高斯自回归 (AR(1)) 过程 $\\{X_t\\}_{t \\geq 0}$，其均值为零，边际方差为 $\\operatorname{Var}(X_t)=\\sigma^{2}$，自相关函数为 $\\rho_{X}(k)=\\rho^{k}$ (对于滞后 $k \\geq 0$)，其中 $|\\rho|  1$。在第 $t$ 次迭代中，一个蒙特卡洛估计量是标量 $X_t$。现在，你应用一个控制变量，使用滞后值 $X_{t-1}$ 来构造一个新的估计量序列\n$$\nY_t \\;=\\; s\\,\\big(X_t - \\lambda X_{t-1}\\big),\n$$\n其中选择 $s \\in \\mathbb{R}$，使得对于所有 $\\lambda \\in \\mathbb{R}$ 的选择，都有 $\\operatorname{Var}(Y_t)=\\operatorname{Var}(X_t)=\\sigma^{2}$。这个控制变量不改变边际方差，但通过 $\\lambda$ 在连续的估计值之间引入相关性，从而改变了时间上的依赖结构。\n\n从自协方差函数和积分自相关时间 (IAT) 的定义出发，并仅使用平稳性和 AR(1) 依赖结构，推导当 $\\lambda$ 被选择为等于 AR(1) 系数 $\\rho$ 时，有效样本量 (ESS) 改善的闭式因子。将你的最终答案表示为 $\\rho$ 的单个解析函数，记作 $\\mathcal{F}(\\rho)=\\mathcal{E}_{\\text{new}}/\\mathcal{E}_{\\text{old}}$，其中 $\\mathcal{E}_{\\text{old}}$ 是原始序列 $\\{X_t\\}$ 的 ESS，而 $\\mathcal{E}_{\\text{new}}$ 是当 $\\lambda=\\rho$ 时转换后序列 $\\{Y_t\\}$ 的 ESS。",
            "solution": "问题要求推导当一个特定的控制变量应用于平稳 AR(1) 过程时，有效样本量 (ESS) 的改善因子。该改善因子定义为比率 $\\mathcal{F}(\\rho) = \\mathcal{E}_{\\text{new}}/\\mathcal{E}_{\\text{old}}$。\n\n对于一个包含 $N$ 个相关样本的序列，有效样本量 $\\mathcal{E}$ 由 $\\mathcal{E} = N / \\tau$ 给出，其中 $\\tau$ 是积分自相关时间 (IAT)。IAT 用自相关函数 (ACF) $\\rho(k)$ 定义为：\n$$\n\\tau = 1 + 2 \\sum_{k=1}^{\\infty} \\rho(k)\n$$\n因此，改善因子可以表示为原始序列和转换后序列的 IAT 之比：\n$$\n\\mathcal{F}(\\rho) = \\frac{\\mathcal{E}_{\\text{new}}}{\\mathcal{E}_{\\text{old}}} = \\frac{N / \\tau_{\\text{new}}}{N / \\tau_{\\text{old}}} = \\frac{\\tau_{\\text{old}}}{\\tau_{\\text{new}}}\n$$\n我们的任务简化为计算序列 $\\{X_t\\}$ 的 $\\tau_{\\text{old}}$ 和序列 $\\{Y_t\\}$ 的 $\\tau_{\\text{new}}$。\n\n首先，我们计算原始 AR(1) 序列 $\\{X_t\\}$ 的 IAT。问题陈述其 ACF 为 $\\rho_X(k) = \\rho^k$ (对于 $k \\geq 0$)。使用 IAT 的定义，我们有：\n$$\n\\tau_{\\text{old}} = \\tau_X = 1 + 2 \\sum_{k=1}^{\\infty} \\rho_X(k) = 1 + 2 \\sum_{k=1}^{\\infty} \\rho^k\n$$\n这个和是一个几何级数。由于 $|\\rho|  1$，该级数收敛：\n$$\n\\sum_{k=1}^{\\infty} \\rho^k = \\frac{\\rho}{1-\\rho}\n$$\n将此代回 $\\tau_{\\text{old}}$ 的表达式，得到：\n$$\n\\tau_{\\text{old}} = 1 + 2 \\frac{\\rho}{1-\\rho} = \\frac{1-\\rho + 2\\rho}{1-\\rho} = \\frac{1+\\rho}{1-\\rho}\n$$\n接下来，我们分析转换后的序列 $\\{Y_t\\}$ 以找到其 IAT $\\tau_{\\text{new}}$。该序列定义为 $Y_t = s(X_t - \\lambda X_{t-1})$，并作出特定选择 $\\lambda = \\rho$。\n$$\nY_t = s(X_t - \\rho X_{t-1})\n$$\n一个均值为零、ACF 为 $\\rho_X(k)=\\rho^k$ 的平稳 AR(1) 过程 $\\{X_t\\}$ 由随机差分方程定义：\n$$\nX_t = \\rho X_{t-1} + \\epsilon_t\n$$\n其中 $\\{\\epsilon_t\\}$ 是一个均值为零 $\\mathbb{E}[\\epsilon_t]=0$、方差恒为 $\\operatorname{Var}(\\epsilon_t) = \\sigma_\\epsilon^2$ 的不相关（白噪声）随机变量序列。变量 $\\epsilon_t$ 也与该过程的过去值不相关，即对于 $j>0$，有 $\\operatorname{Cov}(\\epsilon_t, X_{t-j})=0$。\n\n$X_t$ 的方差是 $\\sigma^2$。根据定义方程，我们有：\n$$\n\\operatorname{Var}(X_t) = \\operatorname{Var}(\\rho X_{t-1} + \\epsilon_t) = \\rho^2 \\operatorname{Var}(X_{t-1}) + \\operatorname{Var}(\\epsilon_t)\n$$\n由于过程是平稳的，$\\operatorname{Var}(X_t) = \\operatorname{Var}(X_{t-1}) = \\sigma^2$。这得出：\n$$\n\\sigma^2 = \\rho^2 \\sigma^2 + \\sigma_\\epsilon^2 \\implies \\sigma_\\epsilon^2 = \\sigma^2(1-\\rho^2)\n$$\n现在，我们将 AR(1) 过程的定义代入 $Y_t$ 的表达式中：\n$$\nY_t = s(X_t - \\rho X_{t-1}) = s((\\rho X_{t-1} + \\epsilon_t) - \\rho X_{t-1}) = s \\epsilon_t\n$$\n这揭示了转换后的序列 $\\{Y_t\\}$ 只是白噪声新息过程 $\\{\\epsilon_t\\}$ 的一个缩放版本。问题陈述要求 $\\operatorname{Var}(Y_t) = \\sigma^2$。我们来验证缩放因子 $s$：\n$$\n\\operatorname{Var}(Y_t) = \\operatorname{Var}(s \\epsilon_t) = s^2 \\operatorname{Var}(\\epsilon_t) = s^2 \\sigma^2 (1-\\rho^2)\n$$\n设 $\\operatorname{Var}(Y_t) = \\sigma^2$，我们得到 $s^2 \\sigma^2 (1-\\rho^2) = \\sigma^2$，这意味着 $s^2 = \\frac{1}{1-\\rho^2}$。这证实了这样一个缩放因子 $s$ 的存在。\n\n为了计算 $\\tau_{\\text{new}}$，我们需要序列 $\\{Y_t\\}$ 的 ACF，即 $\\rho_Y(k)$。ACF 定义为 $\\rho_Y(k) = \\frac{\\operatorname{Cov}(Y_t, Y_{t-k})}{\\operatorname{Var}(Y_t)}$。我们先验地知道 $\\operatorname{Var}(Y_t)=\\sigma^2$。对于滞后 $k \\geq 1$ 的自协方差是：\n$$\n\\operatorname{Cov}(Y_t, Y_{t-k}) = \\operatorname{Cov}(s \\epsilon_t, s \\epsilon_{t-k}) = s^2 \\operatorname{Cov}(\\epsilon_t, \\epsilon_{t-k})\n$$\n由于 $\\{\\epsilon_t\\}$ 是一个白噪声过程，其元素在时间上是不相关的。因此，对于任何 $k \\geq 1$：\n$$\n\\operatorname{Cov}(\\epsilon_t, \\epsilon_{t-k}) = 0\n$$\n这意味着对于所有 $k \\geq 1$，$\\operatorname{Cov}(Y_t, Y_{t-k})=0$。因此，序列 $\\{Y_t\\}$ 的 ACF 是：\n$$\n\\rho_Y(k) = \\frac{0}{\\sigma^2} = 0 \\quad \\text{对于所有 } k \\geq 1\n$$\n序列 $\\{Y_t\\}$ 是不相关的。现在我们可以计算其 IAT $\\tau_{\\text{new}}$：\n$$\n\\tau_{\\text{new}} = \\tau_Y = 1 + 2 \\sum_{k=1}^{\\infty} \\rho_Y(k) = 1 + 2 \\sum_{k=1}^{\\infty} 0 = 1\n$$\n新序列的 IAT 是 $1$，这是理论上的最小值，对应于一个由独立样本组成的序列。\n\n最后，我们计算改善因子 $\\mathcal{F}(\\rho)$：\n$$\n\\mathcal{F}(\\rho) = \\frac{\\tau_{\\text{old}}}{\\tau_{\\text{new}}} = \\frac{\\frac{1+\\rho}{1-\\rho}}{1} = \\frac{1+\\rho}{1-\\rho}\n$$\n这就是有效样本量改善的闭式因子。通过将相关序列 $\\{X_t\\}$ 转换为不相关序列 $\\{Y_t\\}$，使用 $\\lambda=\\rho$ 的控制变量技术在固定样本数量 $N$ 的情况下最大化了有效样本量。",
            "answer": "$$\n\\boxed{\\frac{1+\\rho}{1-\\rho}}\n$$"
        },
        {
            "introduction": "在实际的蒙特卡洛模拟中，我们关心的量往往比单个均值更复杂，例如估计两个参数的均值之比。本练习将指导你处理这类更为现实的自归一化估计器，将其中的有效样本量概念进行推广。你将学习如何运用多元delta方法来分析估计量的方差，并理解分子、分母序列的自相关与互相关如何共同影响最终的统计效率 。",
            "id": "3304593",
            "problem": "考虑一个具有有限二阶矩和均值 $\\mu_A$ 及 $\\mu_B > 0$ 的严格平稳、遍历的二元时间序列 $\\{(A_t, B_t)\\}_{t=1}^{N}$。定义比率参数 $\\theta = \\mu_A/\\mu_B$ 的自归一化估计量为嵌入式估计 $\\hat{\\theta}_N = \\bar{A}_N / \\bar{B}_N$，其中 $\\bar{A}_N = N^{-1}\\sum_{t=1}^{N} A_t$ 且 $\\bar{B}_N = N^{-1}\\sum_{t=1}^{N} B_t$。假设样本均值满足一个联合中心极限定理 (CLT)，并且强混合条件足以使多元 delta 方法成立。\n\n令 $\\gamma_{XY}(k) = \\operatorname{Cov}(X_t, Y_{t+k})$ (对于 $X,Y \\in \\{A,B\\}$)，并定义长期协方差矩阵 $\\Gamma$ 为\n$$\n\\Gamma = \\sum_{k=-\\infty}^{\\infty} \\begin{pmatrix}\n\\gamma_{AA}(k)  \\gamma_{AB}(k) \\\\\n\\gamma_{BA}(k)  \\gamma_{BB}(k)\n\\end{pmatrix},\n$$\n以及滞后为零的协方差矩阵 $\\Gamma_0$ 为\n$$\n\\Gamma_0 = \\begin{pmatrix}\n\\gamma_{AA}(0)  \\gamma_{AB}(0) \\\\\n\\gamma_{BA}(0)  \\gamma_{BB}(0)\n\\end{pmatrix}.\n$$\n\n1. 从 $(\\bar{A}_N, \\bar{B}_N)$ 的联合 CLT 出发，并对光滑映射 $f(x,y)=x/y$ 应用多元 delta 方法，推导 $\\hat{\\theta}_N$ 在大样本 $N$ 下的方差近似表达式，用 $\\mu_A$, $\\mu_B$ 和 $\\Gamma$ 表示。然后定义有效样本量 (ESS)，记为 $N_{\\mathrm{eff}}$，它是在相依和独立情况下大样本 $N$ 方差近似相等的唯一数值：相依情况下方差的 $N^{-1}$ 倍等于独立情况下方差的 $N_{\\mathrm{eff}}^{-1}$ 倍（后者通过将 $\\Gamma$ 替换为 $\\Gamma_0$ 得到）。\n\n2. 对于一个 $N=40000$ 的具体实例，假设以下矩特征成立：\n- 均值：$\\mu_A=2$ 和 $\\mu_B=5$。\n- 滞后为零的协方差：$\\gamma_{AA}(0)=3$, $\\gamma_{BB}(0)=4$, $\\gamma_{AB}(0)=1$。\n- 对于 $k\\geq 1$ 的协方差和：$\\sum_{k=1}^{\\infty}\\gamma_{AA}(k)=1.5$, $\\sum_{k=1}^{\\infty}\\gamma_{BB}(k)=2.0$, $\\sum_{k=1}^{\\infty}\\gamma_{AB}(k)=0.6$, 和 $\\sum_{k=1}^{\\infty}\\gamma_{BA}(k)=0.4$。\n\n根据你推导的表达式计算 $N_{\\mathrm{eff}}$。将你的答案四舍五入到四位有效数字。最终答案中不要包含任何单位。",
            "solution": "该问题陈述经确认为具有科学依据、提法恰当且客观。它在渐近时间序列分析的既定框架内提供了一套完整且一致的给定条件，从而允许得出唯一且有意义的解。因此，我们可以进行推导和计算。\n\n问题分为两部分。首先，我们必须为比率估计量 $\\hat{\\theta}_N$ 推导有效样本量 ($N_{\\mathrm{eff}}$) 的通用表达式。其次，我们必须根据给定的参数计算其数值。\n\n**第 1 部分：有效样本量公式的推导**\n\n设二元时间序列为 $\\{(A_t, B_t)\\}_{t=1}^{N}$。我们感兴趣的参数是均值之比 $\\theta = \\frac{\\mu_A}{\\mu_B}$，其中 $\\mu_A = E[A_t]$ 且 $\\mu_B = E[B_t]$。$\\theta$ 的估计量是嵌入式估计量 $\\hat{\\theta}_N = \\frac{\\bar{A}_N}{\\bar{B}_N}$，其中 $\\bar{A}_N = N^{-1}\\sum_{t=1}^{N} A_t$ 且 $\\bar{B}_N = N^{-1}\\sum_{t=1}^{N} B_t$。\n\n问题假设样本均值向量满足联合中心极限定理 (CLT)。对于满足充分混合条件的严格平稳和遍历的时间序列，该 CLT 表述为：\n$$\n\\sqrt{N} \\left( \\begin{pmatrix} \\bar{A}_N \\\\ \\bar{B}_N \\end{pmatrix} - \\begin{pmatrix} \\mu_A \\\\ \\mu_B \\end{pmatrix} \\right) \\xrightarrow{d} \\mathcal{N} \\left( \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}, \\Gamma \\right)\n$$\n其中 $\\xrightarrow{d}$ 表示依分布收敛，而 $\\Gamma$ 是定义如下的长期协方差矩阵：\n$$\n\\Gamma = \\sum_{k=-\\infty}^{\\infty} \\begin{pmatrix} \\gamma_{AA}(k)  \\gamma_{AB}(k) \\\\ \\gamma_{BA}(k)  \\gamma_{BB}(k) \\end{pmatrix} = \\begin{pmatrix} \\Gamma_{11}  \\Gamma_{12} \\\\ \\Gamma_{21}  \\Gamma_{22} \\end{pmatrix}\n$$\n这意味着对于大样本 $N$，样本均值的渐近方差-协方差矩阵为 $\\operatorname{Var} \\left( \\begin{pmatrix} \\bar{A}_N \\\\ \\bar{B}_N \\end{pmatrix} \\right) \\approx \\frac{1}{N}\\Gamma$。\n\n我们使用多元 delta 方法来求出 $\\hat{\\theta}_N = g(\\bar{A}_N, \\bar{B}_N)$ 的渐近分布，其中 $g(x,y) = x/y$。由于给定 $\\mu_B > 0$，函数 $g$ 在 $(\\mu_A, \\mu_B)$ 的邻域内是连续可微的。$g$ 在 $(\\mu_A, \\mu_B)$ 处的梯度为：\n$$\n\\nabla g(\\mu_A, \\mu_B) = \\left. \\begin{pmatrix} \\frac{\\partial g}{\\partial x} \\\\ \\frac{\\partial g}{\\partial y} \\end{pmatrix} \\right|_{(x,y)=(\\mu_A, \\mu_B)} = \\begin{pmatrix} 1/\\mu_B \\\\ -\\mu_A/\\mu_B^2 \\end{pmatrix}\n$$\ndelta 方法指出，$\\sqrt{N}(\\hat{\\theta}_N - \\theta)$ 是渐近正态的，其均值为 0，方差 $\\sigma_{\\theta}^2$ 由下式给出：\n$$\n\\sigma_{\\theta}^2 = [\\nabla g(\\mu_A, \\mu_B)]^T \\Gamma [\\nabla g(\\mu_A, \\mu_B)]\n$$\n代入梯度和矩阵 $\\Gamma$：\n$$\n\\sigma_{\\theta}^2 = \\begin{pmatrix} \\frac{1}{\\mu_B}  -\\frac{\\mu_A}{\\mu_B^2} \\end{pmatrix} \\begin{pmatrix} \\Gamma_{11}  \\Gamma_{12} \\\\ \\Gamma_{21}  \\Gamma_{22} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\mu_B} \\\\ -\\frac{\\mu_A}{\\mu_B^2} \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\sigma_{\\theta}^2 = \\frac{1}{\\mu_B^2} \\Gamma_{11} - \\frac{\\mu_A}{\\mu_B^3} \\Gamma_{12} - \\frac{\\mu_A}{\\mu_B^3} \\Gamma_{21} + \\frac{\\mu_A^2}{\\mu_B^4} \\Gamma_{22}\n$$\n提出因子 $\\frac{1}{\\mu_B^2}$ 并代入 $\\theta = \\mu_A/\\mu_B$：\n$$\n\\sigma_{\\theta}^2 = \\frac{1}{\\mu_B^2} \\left[ \\Gamma_{11} - \\frac{\\mu_A}{\\mu_B}(\\Gamma_{12} + \\Gamma_{21}) + \\left(\\frac{\\mu_A}{\\mu_B}\\right)^2 \\Gamma_{22} \\right]\n$$\n$$\n\\sigma_{\\theta}^2 = \\frac{1}{\\mu_B^2} \\left[ \\Gamma_{11} - \\theta(\\Gamma_{12} + \\Gamma_{21}) + \\theta^2 \\Gamma_{22} \\right]\n$$\n这个量 $\\sigma_{\\theta}^2$ 是在相依情况下 $\\sqrt{N}(\\hat{\\theta}_N - \\theta)$ 的渐近方差。因此，估计量 $\\hat{\\theta}_N$ 在大样本 $N$ 下的方差为 $\\operatorname{Var}_{\\mathrm{dep}}(\\hat{\\theta}_N) \\approx \\frac{1}{N}\\sigma_{\\theta}^2$。\n\n独立情况下的方差通过将长期协方差矩阵 $\\Gamma$ 替换为滞后为零的协方差矩阵 $\\Gamma_0$ 来获得。因此，在独立同分布 (i.i.d.) 的情况下，$\\sqrt{N}(\\hat{\\theta}_N - \\theta)$ 的渐近方差（我们称之为 $\\sigma_{\\theta,0}^2$）为：\n$$\n\\sigma_{\\theta,0}^2 = \\frac{1}{\\mu_B^2} \\left[ \\gamma_{AA}(0) - \\theta(\\gamma_{AB}(0) + \\gamma_{BA}(0)) + \\theta^2 \\gamma_{BB}(0) \\right]\n$$\n由于 $\\gamma_{AB}(0) = \\operatorname{Cov}(A_t, B_t) = \\operatorname{Cov}(B_t, A_t) = \\gamma_{BA}(0)$，上式简化为：\n$$\n\\sigma_{\\theta,0}^2 = \\frac{1}{\\mu_B^2} \\left[ \\gamma_{AA}(0) - 2\\theta\\gamma_{AB}(0) + \\theta^2 \\gamma_{BB}(0) \\right]\n$$\n有效样本量 $N_{\\mathrm{eff}}$ 的定义是，将在相依情况下样本量为 $N$ 时的估计量方差，与在独立情况下样本量为 $N_{\\mathrm{eff}}$ 时的估计量方差相等：\n$$\n\\operatorname{Var}_{\\mathrm{dep}}(\\hat{\\theta}_N) \\approx \\operatorname{Var}_{\\mathrm{indep}}(\\hat{\\theta}_{N_{\\mathrm{eff}}})\n$$\n$$\n\\frac{1}{N}\\sigma_{\\theta}^2 = \\frac{1}{N_{\\mathrm{eff}}}\\sigma_{\\theta,0}^2\n$$\n对 $N_{\\mathrm{eff}}$ 进行整理可得：\n$$\nN_{\\mathrm{eff}} = N \\frac{\\sigma_{\\theta,0}^2}{\\sigma_{\\theta}^2} = N \\frac{\\frac{1}{\\mu_B^2} \\left[ \\gamma_{AA}(0) - 2\\theta\\gamma_{AB}(0) + \\theta^2 \\gamma_{BB}(0) \\right]}{\\frac{1}{\\mu_B^2} \\left[ \\Gamma_{11} - \\theta(\\Gamma_{12} + \\Gamma_{21}) + \\theta^2 \\Gamma_{22} \\right]}\n$$\n因子 $1/\\mu_B^2$ 被消去，得到 $N_{\\mathrm{eff}}$ 的最终表达式：\n$$\nN_{\\mathrm{eff}} = N \\frac{\\gamma_{AA}(0) - 2\\theta\\gamma_{AB}(0) + \\theta^2 \\gamma_{BB}(0)}{\\Gamma_{11} - \\theta(\\Gamma_{12} + \\Gamma_{21}) + \\theta^2 \\Gamma_{22}}\n$$\n这就完成了问题的第一部分。\n\n**第 2 部分：$N_{\\mathrm{eff}}$ 的数值计算**\n\n我们已知以下数值：\n- $N = 40000$\n- $\\mu_A = 2$, $\\mu_B = 5$, 这意味着 $\\theta = \\mu_A/\\mu_B = 2/5 = 0.4$\n- $\\gamma_{AA}(0) = 3$, $\\gamma_{BB}(0) = 4$, $\\gamma_{AB}(0) = 1$\n- $\\sum_{k=1}^{\\infty}\\gamma_{AA}(k) = 1.5$\n- $\\sum_{k=1}^{\\infty}\\gamma_{BB}(k) = 2.0$\n- $\\sum_{k=1}^{\\infty}\\gamma_{AB}(k) = 0.6$\n- $\\sum_{k=1}^{\\infty}\\gamma_{BA}(k) = 0.4$\n\n首先，我们计算长期协方差矩阵 $\\Gamma$ 的分量。\n对于一个平稳过程，有 $\\gamma_{XY}(k) = \\gamma_{YX}(-k)$。\n$$\n\\Gamma_{11} = \\sum_{k=-\\infty}^{\\infty} \\gamma_{AA}(k) = \\gamma_{AA}(0) + \\sum_{k=1}^{\\infty}\\gamma_{AA}(k) + \\sum_{k=-\\infty}^{-1}\\gamma_{AA}(k) = \\gamma_{AA}(0) + 2\\sum_{k=1}^{\\infty}\\gamma_{AA}(k)\n$$\n$$\n\\Gamma_{11} = 3 + 2(1.5) = 6\n$$\n$$\n\\Gamma_{22} = \\sum_{k=-\\infty}^{\\infty} \\gamma_{BB}(k) = \\gamma_{BB}(0) + 2\\sum_{k=1}^{\\infty}\\gamma_{BB}(k)\n$$\n$$\n\\Gamma_{22} = 4 + 2(2.0) = 8\n$$\n非对角项为：\n$$\n\\Gamma_{12} = \\sum_{k=-\\infty}^{\\infty} \\gamma_{AB}(k) = \\gamma_{AB}(0) + \\sum_{k=1}^{\\infty}\\gamma_{AB}(k) + \\sum_{k=-\\infty}^{-1}\\gamma_{AB}(k) = \\gamma_{AB}(0) + \\sum_{k=1}^{\\infty}\\gamma_{AB}(k) + \\sum_{k=1}^{\\infty}\\gamma_{BA}(k)\n$$\n$$\n\\Gamma_{12} = 1 + 0.6 + 0.4 = 2\n$$\n通过类似的计算，或注意到 $\\Gamma$ 必须是对称的，可得 $\\Gamma_{21} = \\Gamma_{12} = 2$。\n\n现在，我们计算 $N_{\\mathrm{eff}}$ 表达式中分数的分子和分母。\n分子对应于 i.i.d. 情况下的方差项（已乘以 $\\mu_B^2$）：\n$$\n\\text{分子} = \\gamma_{AA}(0) - 2\\theta\\gamma_{AB}(0) + \\theta^2\\gamma_{BB}(0)\n$$\n$$\n\\text{分子} = 3 - 2(0.4)(1) + (0.4)^2(4) = 3 - 0.8 + (0.16)(4) = 2.2 + 0.64 = 2.84\n$$\n分母对应于相依情况下的方差项（已乘以 $\\mu_B^2$）：\n$$\n\\text{分母} = \\Gamma_{11} - \\theta(\\Gamma_{12} + \\Gamma_{21}) + \\theta^2\\Gamma_{22}\n$$\n$$\n\\text{分母} = 6 - (0.4)(2 + 2) + (0.4)^2(8) = 6 - (0.4)(4) + (0.16)(8) = 6 - 1.6 + 1.28 = 4.4 + 1.28 = 5.68\n$$\n最后，我们计算 $N_{\\mathrm{eff}}$：\n$$\nN_{\\mathrm{eff}} = N \\frac{\\text{分子}}{\\text{分母}} = 40000 \\times \\frac{2.84}{5.68}\n$$\n注意到 $5.68 = 2 \\times 2.84$，该分数简化为 $1/2$。\n$$\nN_{\\mathrm{eff}} = 40000 \\times \\frac{1}{2} = 20000\n$$\n问题要求答案四舍五入到四位有效数字。确切答案是 $20000$。要用四位有效数字表示，可以写成 $2.000 \\times 10^4$。其数值本身是 $20000$。",
            "answer": "$$\n\\boxed{20000}\n$$"
        },
        {
            "introduction": "统计效率（高ESS）只是故事的一半，计算成本是另一半。这个综合性练习将让你从全局视角思考模拟效率，即如何在单位计算时间内获得尽可能多的有效样本。你将建立一个包含算法参数（如步长）和硬件利用（如并行链数）的成本模型，并通过编程求解一个优化问题，从而找到在统计效率和计算速度之间的最佳平衡点 。",
            "id": "3304672",
            "problem": "考虑一类会产生自相关样本的马尔可夫链蒙特卡洛 (MCMC) 算法。对于给定的算法配置，定义一个参数向量 $\\theta$，它由算法步长 $\\varepsilon$ 和在计算硬件上并发执行的并行链数 $p$ 组成。假设每条链都是平稳的，均值为 $0$，方差为 $\\sigma^2$，且其滞后 $k$ 阶自相关用 $r(k)$ 表示。再进一步假设，每条链的动力学可以由一阶自回归过程很好地近似，因此存在一个相关参数 $\\rho(\\varepsilon)$，对于所有整数 $k \\geq 0$ 满足 $r(k) = \\rho(\\varepsilon)^k$，且 $0  \\rho(\\varepsilon)  1$。\n\n定义每条链的总迭代次数为 $N$，并考虑并行运行 $p$ 条独立的链，以便每次全局迭代（每条链前进一步）产生的总样本数为 $p$。硬件并发执行这 $p$ 条链的更新，其扩展性并非完美。将每条链的计算时间建模为步长的增函数\n$$\nt_{\\text{chain}}(\\varepsilon) = t_0 + t_1 \\varepsilon^2,\n$$\n其中 $t_0$ 和 $t_1$ 是以秒为单位的正实数常量。通过一个 Amdahl 型表达式对并行加速比进行建模\n$$\nS(p) = \\frac{p}{1 + \\kappa (p - 1)},\n$$\n其中 $\\kappa > 0$ 量化了不可并行化工作的比例。将额外的开销建模为\n$$\n\\text{overhead}(p) = \\eta (p - 1)^2,\n$$\n其中 $\\eta > 0$，单位为每次全局迭代的秒数。那么，每次全局迭代（每条链并行地前进一步）的总墙上时间成本为\n$$\nc(\\varepsilon,p) = \\frac{t_{\\text{chain}}(\\varepsilon)\\, p}{S(p)} + \\text{overhead}(p),\n$$\n以秒表示。\n\n从时间序列中自协方差和自相关的基本原理和核心定义出发，推导单条链在 $N$ 次迭代后获得的有效样本量 (ESS) 作为 $\\rho(\\varepsilon)$ 的函数，并将其扩展到 $p$ 条独立的链。推导必须从以自协方差函数和自相关函数表示的样本均值方差的定义开始，并逻辑地进行，以确定积分自相关时间和由此产生的有效样本量。利用该推导构建一个程序，为下述每个测试用例评估目标函数\n$$\n\\max_{\\varepsilon \\in \\mathcal{E},\\, p \\in \\mathcal{P}} \\frac{\\text{ESS}(\\varepsilon,p)}{c(\\varepsilon,p)},\n$$\n其中 $\\mathcal{E}$ 是候选步长的有限集合，$\\mathcal{P}$ 是候选线程数的有限集合。$\\rho(\\varepsilon)$ 的参数化由下式给出\n$$\n\\rho(\\varepsilon) = \\exp(-\\alpha \\varepsilon),\n$$\n其中每个测试用例会提供 $\\alpha > 0$。\n\n你的程序必须：\n- 使用自相关结构 $r(k) = \\rho(\\varepsilon)^k$ 实现基于推导的 $\\text{ESS}(\\varepsilon,p)$ 公式。\n- 对所提供的测试套件中的每一对 $(\\varepsilon,p)$，计算 $\\text{ESS}(\\varepsilon,p) / c(\\varepsilon,p)$。\n- 选择能获得最大比率的最大化器 $(\\varepsilon^\\star, p^\\star)$。如果有多对参数达到相同的最大值（在 $10^{-12}$ 的数值容差范围内），则选择 $p$ 值最小的一对；如果仍然持平，则选择 $\\varepsilon$ 值最小的一对。\n- 对于每个测试用例，输出一个包含 $[\\varepsilon^\\star, p^\\star, \\text{ESS-per-second}^\\star]$ 的列表，其中 $\\text{ESS-per-second}^\\star = \\text{ESS}(\\varepsilon^\\star,p^\\star) / c(\\varepsilon^\\star,p^\\star)$ 以“样本/秒”为单位。报告 $\\varepsilon^\\star$ 时四舍五入到 3 位小数，$\\text{ESS-per-second}^\\star$ 四舍五入到 6 位小数。线程数 $p^\\star$ 是一个整数。\n\n物理和数值单位：\n- 时间量 $t_0$、$t_1$ 和 $\\eta$ 的单位是秒。\n- 目标比率 $\\text{ESS}(\\varepsilon,p) / c(\\varepsilon,p)$ 必须以“样本/秒”（浮点数）为单位报告。\n\n角度单位不适用。最终答案中不出现百分比。\n\n测试套件：\n- 案例 1（理想情况）：\n    - $N = 10000$, $\\alpha = 3.0$, $t_0 = 1\\times 10^{-4}$, $t_1 = 5\\times 10^{-4}$, $\\kappa = 0.15$, $\\eta = 2\\times 10^{-5}$,\n    - $\\mathcal{E} = \\{0.02, 0.05, 0.10, 0.20, 0.40\\}$,\n    - $\\mathcal{P} = \\{1, 2, 4, 8, 16\\}$。\n- 案例 2（受限的扩展性和高开销）：\n    - $N = 10000$, $\\alpha = 1.0$, $t_0 = 5\\times 10^{-4}$, $t_1 = 1\\times 10^{-4}$, $\\kappa = 0.5$, $\\eta = 1\\times 10^{-4}$,\n    - $\\mathcal{E} = \\{0.01, 0.03, 0.05, 0.10, 0.20, 0.30\\}$,\n    - $\\mathcal{P} = \\{1, 2, 3, 4, 6, 8\\}$。\n- 案例 3（近乎理想的扩展性和快速去相关）：\n    - $N = 20000$, $\\alpha = 5.0$, $t_0 = 1\\times 10^{-4}$, $t_1 = 1\\times 10^{-4}$, $\\kappa = 0.05$, $\\eta = 5\\times 10^{-6}$,\n    - $\\mathcal{E} = \\{0.05, 0.10, 0.20, 0.40, 0.80\\}$,\n    - $\\mathcal{P} = \\{1, 2, 4, 8, 16, 32\\}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表，且无多余空格。例如，输出应如下所示：\n$$\n[\\,[\\varepsilon_1^\\star,p_1^\\star,\\text{ESSperSec}_1^\\star],\\,[\\varepsilon_2^\\star,p_2^\\star,\\text{ESSperSec}_2^\\star],\\,[\\varepsilon_3^\\star,p_3^\\star,\\text{ESSperSec}_3^\\star]\\,],\n$$\n其中每个内部列表对应一个测试用例，按案例 1、案例 2、案例 3 的顺序排列。",
            "solution": "**问题验证**\n\n问题陈述已经过评估，并被确定为**有效**。它在科学上基于马尔可夫链蒙特卡洛 (MCMC) 方法、统计时间序列分析和计算性能建模的原理。该问题是适定的，具有明确定义的目标函数，需在有限的参数集上进行最大化，并包含一个特定的打破平局规则以确保唯一解。所有必要的参数和模型都已明确提供，问题不存在歧义、矛盾或主观内容。\n\n**推导与求解方法**\n\n目标是最大化有效样本量 (ESS) 与计算成本之比。我们首先按要求从第一性原理推导 ESS 的公式。\n\n设 $\\{X_i\\}_{i=1}^N$ 是来自单条平稳马尔可夫链的 $N$ 个样本序列，其均值为 $\\mathbb{E}[X_i] = 0$，方差为 $\\text{Var}(X_i) = \\sigma^2$。样本均值为 $\\hat{\\mu}_N = \\frac{1}{N}\\sum_{i=1}^N X_i$。\n\n样本均值的方差由下式给出：\n$$ \\text{Var}(\\hat{\\mu}_N) = \\text{Var}\\left(\\frac{1}{N}\\sum_{i=1}^N X_i\\right) = \\frac{1}{N^2} \\sum_{i=1}^N \\sum_{j=1}^N \\text{Cov}(X_i, X_j) $$\n对于平稳过程，自协方差 $\\gamma(k) = \\text{Cov}(X_i, X_{i+k})$ 仅取决于滞后量 $k$。此外，$\\gamma(k) = \\gamma(-k)$ 且 $\\gamma(0) = \\sigma^2$。双重求和可以通过令 $k=j-i$ 来重新索引：\n$$ \\text{Var}(\\hat{\\mu}_N) = \\frac{1}{N^2} \\sum_{k=-(N-1)}^{N-1} (N-|k|) \\gamma(k) $$\n利用 $\\gamma(k)$ 的对称性并用自相关函数 $r(k) = \\gamma(k)/\\gamma(0)$ 表示，我们得到：\n$$ \\text{Var}(\\hat{\\mu}_N) = \\frac{\\sigma^2}{N} \\left[ 1 + 2 \\sum_{k=1}^{N-1} \\left(1-\\frac{k}{N}\\right) r(k) \\right] $$\n当样本数量 $N$ 远大于链的相关长度时，该表达式可以通过将有限和替换为无限和并舍去 $(1-k/N)$ 项来很好地近似：\n$$ \\text{Var}(\\hat{\\mu}_N) \\approx \\frac{\\sigma^2}{N} \\left[ 1 + 2 \\sum_{k=1}^{\\infty} r(k) \\right] $$\n有效样本量 $N_{\\text{eff}}$ 定义为能产生相同样本均值方差的独立同分布 (i.i.d.) 样本的大小，即 $\\text{Var}(\\hat{\\mu}_{N_{\\text{eff}}}^{\\text{iid}}) = \\sigma^2/N_{\\text{eff}}$。将其与自相关链的方差相等可得：\n$$ \\frac{\\sigma^2}{N_{\\text{eff}}} = \\frac{\\sigma^2}{N} \\left[ 1 + 2 \\sum_{k=1}^{\\infty} r(k) \\right] $$\n这给出了单条链的 ESS 定义：\n$$ N_{\\text{eff}} = \\frac{N}{1 + 2 \\sum_{k=1}^{\\infty} r(k)} = \\frac{N}{\\tau} $$\n其中 $\\tau = 1 + 2 \\sum_{k=1}^{\\infty} r(k)$ 是积分自相关时间 (IACT)。\n\n问题为链的自相关结构指定了一个 AR(1) 过程，$r(k) = \\rho(\\varepsilon)^k$ 对 $k \\geq 0$ 成立，其中 $\\rho(\\varepsilon)$ 是依赖于步长 $\\varepsilon$ 的滞后-1自相关。给定 $0  \\rho(\\varepsilon)  1$，该无穷级数是一个收敛的几何级数：\n$$ \\sum_{k=1}^{\\infty} \\rho(\\varepsilon)^k = \\frac{\\rho(\\varepsilon)}{1-\\rho(\\varepsilon)} $$\n将此代入 $\\tau$ 的表达式：\n$$ \\tau(\\varepsilon) = 1 + 2 \\frac{\\rho(\\varepsilon)}{1-\\rho(\\varepsilon)} = \\frac{1-\\rho(\\varepsilon) + 2\\rho(\\varepsilon)}{1-\\rho(\\varepsilon)} = \\frac{1+\\rho(\\varepsilon)}{1-\\rho(\\varepsilon)} $$\n因此，长度为 $N$ 的单条链的 ESS 为：\n$$ \\text{ESS}_{\\text{single}}(N, \\varepsilon) = \\frac{N}{\\tau(\\varepsilon)} = N \\frac{1-\\rho(\\varepsilon)}{1+\\rho(\\varepsilon)} $$\n由于我们运行 $p$ 条独立的链，总 ESS 是每条链 ESS 的总和。假设所有链具有相同的统计特性，总 ESS 为：\n$$ \\text{ESS}(\\varepsilon, p) = p \\times \\text{ESS}_{\\text{single}}(N, \\varepsilon) = p N \\frac{1-\\rho(\\varepsilon)}{1+\\rho(\\varepsilon)} $$\n\n目标是最大化总 ESS 与每次全局迭代的计算成本之比，记为 $c(\\varepsilon,p)$。问题指出，目标是最大化 $\\text{ESS}(\\varepsilon,p) / c(\\varepsilon,p)$。尽管 $\\text{ESS}$ 是 $N$ 次迭代的总和，而 $c$ 是每次迭代的成本，但最大化此量等同于最大化 ESS 的生成率，因为对于给定的测试用例，因子 $N$ 是一个常数。\n\n需要最大化的完整目标函数是：\n$$ f(\\varepsilon, p) = \\frac{\\text{ESS}(\\varepsilon,p)}{c(\\varepsilon,p)} $$\n其中各组成部分由以下公式给出：\n1.  **相关参数**：$\\rho(\\varepsilon) = \\exp(-\\alpha \\varepsilon)$\n2.  **有效样本量**：$\\text{ESS}(\\varepsilon, p) = p N \\frac{1 - \\exp(-\\alpha \\varepsilon)}{1 + \\exp(-\\alpha \\varepsilon)}$\n3.  **每次全局迭代的成本**：$c(\\varepsilon,p) = \\frac{t_{\\text{chain}}(\\varepsilon)\\, p}{S(p)} + \\text{overhead}(p)$，可简化为：\n    $$ c(\\varepsilon, p) = (t_0 + t_1 \\varepsilon^2) (1 + \\kappa(p-1)) + \\eta(p-1)^2 $$\n\n程序必须找到使 $f(\\varepsilon, p)$ 最大化的参数对 $(\\varepsilon^\\star, p^\\star)$，其中 $\\varepsilon \\in \\mathcal{E}$ 且 $p \\in \\mathcal{P}$，而 $\\mathcal{E}$ 和 $\\mathcal{P}$ 是为每个测试用例提供的步长和线程数的有限集合。\n\n优化是通过在笛卡尔积 $\\mathcal{E} \\times \\mathcal{P}$ 上的所有对 $(\\varepsilon, p)$ 进行网格搜索来执行的。对于每一对，我们计算目标函数 $f(\\varepsilon, p)$。在开始搜索前，候选集 $\\mathcal{E}$ 和 $\\mathcal{P}$ 按升序排序。我们维护当前找到的最佳参数 $(\\varepsilon^\\star, p^\\star)$ 和相应的最大值 $f^\\star$。如果一对新的 $(\\varepsilon,p)$ 的目标值严格大于 $f^\\star$（超过 $10^{-12}$ 的数值容差），它将取代当前的最佳值。由于排序后的迭代顺序，第一次找到最大值时，将是具有最小可能 $p$ 值的对，对于该 $p$ 值，则是最小可能的 $\\varepsilon$。任何后续达到相同值的对都将具有更大的 $p$ 或 $\\varepsilon$，因此将被正确忽略，从而满足打破平局的规则。\n\n每个测试用例的最终输出是一个列表，其中包含最佳步长 $\\varepsilon^\\star$（四舍五入到3位小数）、最佳链数 $p^\\star$（作为整数）和最大目标函数值 $f(\\varepsilon^\\star, p^\\star)$（四舍五入到6位小数）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the MCMC optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": 10000, \"alpha\": 3.0, \"t0\": 1e-4, \"t1\": 5e-4, \"kappa\": 0.15, \"eta\": 2e-5,\n            \"E_set\": [0.02, 0.05, 0.10, 0.20, 0.40],\n            \"P_set\": [1, 2, 4, 8, 16]\n        },\n        # Case 2 (limited scaling and high overhead)\n        {\n            \"N\": 10000, \"alpha\": 1.0, \"t0\": 5e-4, \"t1\": 1e-4, \"kappa\": 0.5, \"eta\": 1e-4,\n            \"E_set\": [0.01, 0.03, 0.05, 0.10, 0.20, 0.30],\n            \"P_set\": [1, 2, 3, 4, 6, 8]\n        },\n        # Case 3 (near-ideal scaling and fast decorrelation)\n        {\n            \"N\": 20000, \"alpha\": 5.0, \"t0\": 1e-4, \"t1\": 1e-4, \"kappa\": 0.05, \"eta\": 5e-6,\n            \"E_set\": [0.05, 0.10, 0.20, 0.40, 0.80],\n            \"P_set\": [1, 2, 4, 8, 16, 32]\n        }\n    ]\n\n    results = []\n    \n    TOL = 1e-12\n\n    for case in test_cases:\n        N = case[\"N\"]\n        alpha = case[\"alpha\"]\n        t0 = case[\"t0\"]\n        t1 = case[\"t1\"]\n        kappa = case[\"kappa\"]\n        eta = case[\"eta\"]\n        E_set = sorted(case[\"E_set\"])\n        P_set = sorted(case[\"P_set\"])\n\n        best_eps_star = -1.0\n        best_p_star = -1\n        max_ratio = -1.0\n\n        for p in P_set:\n            for eps in E_set:\n                # Calculate the correlation parameter rho\n                rho = np.exp(-alpha * eps)\n                \n                # Calculate the total Effective Sample Size (ESS)\n                # ESS is calculated for p independent chains, each of length N\n                if abs(1.0 + rho) > 1e-15: # Avoid division by zero\n                    ess_factor = (1.0 - rho) / (1.0 + rho)\n                    ess = p * N * ess_factor\n                else: \n                    ess = 0.0\n\n                # Calculate the total wall-time cost per global iteration, c(eps, p)\n                cost_per_iter = (t0 + t1 * eps**2) * (1.0 + kappa * (p - 1.0)) + eta * (p - 1.0)**2\n                \n                # Calculate the objective function: ESS-per-cost-unit\n                if cost_per_iter > 1e-15: # Avoid division by zero\n                    current_ratio = ess / cost_per_iter\n                else:\n                    current_ratio = 0.0\n\n                # Apply maximization and tie-breaking rules.\n                # By iterating through p and eps in sorted order, the first time we\n                # find a new maximum, it will be at the combination with the smallest\n                # p, and for that p, the smallest eps. Subsequent ties will be ignored.\n                if current_ratio > max_ratio + TOL:\n                    max_ratio = current_ratio\n                    best_eps_star = eps\n                    best_p_star = p\n        \n        # Format results as specified for the final output\n        # Round eps_star to 3 decimal places\n        # Round ess_per_second_star to 6 decimal places\n        # p_star is an integer\n        formatted_eps = round(best_eps_star, 3)\n        formatted_ratio = round(max_ratio, 6)\n        \n        results.append([formatted_eps, best_p_star, formatted_ratio])\n\n    # Construct the final output string exactly as specified.\n    inner_lists = [f\"[{e},{p},{r}]\" for e, p, r in results]\n    print(f\"[{','.join(inner_lists)}]\")\n\nsolve()\n```"
        }
    ]
}