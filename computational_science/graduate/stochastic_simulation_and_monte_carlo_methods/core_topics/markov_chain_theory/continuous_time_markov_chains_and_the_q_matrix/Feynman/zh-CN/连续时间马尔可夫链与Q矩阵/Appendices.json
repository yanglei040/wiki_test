{
    "hands_on_practices": [
        {
            "introduction": "在随机过程的分析中，一个基本问题是计算过程最终达到某个特定状态的概率，这在金融（破产概率）和生物学（种群灭绝）等领域都有应用。$Q$-矩阵本身就蕴含了回答这类问题的全部信息。本练习将指导你运用第一步分析法，为一类重要的连续时间马尔可夫链——生灭过程，推导并求解命中概率所满足的方程，这是掌握随机系统分析的一项核心技能。",
            "id": "3298791",
            "problem": "考虑一个在有限状态空间 $\\{0,1,2,\\dots,j\\}$ 上的生灭连续时间马尔可夫链 (CTMC)，其生成元（也称为 $Q$-矩阵）的元素由 $q_{i,i+1}=\\lambda_{i}$、$q_{i,i-1}=\\mu_{i}$ 和 $q_{i,i}=-(\\lambda_{i}+\\mu_{i})$ 给出（对于 $1 \\leq i \\leq j-1$），而 $q_{0,0}=0$ 和 $q_{j,j}=0$，因此状态 $0$ 和 $j$ 是吸收态。假设对于所有 $1 \\leq i \\leq j-1$，都有 $\\lambda_{i} > 0$ 和 $\\mu_{i} > 0$，并且该链是非爆炸的。\n\n令 $T_{A}$ 表示首次到达集合 $A \\subseteq \\{0,1,\\dots,j\\}$ 的时间。对于每个 $i \\in \\{0,1,\\dots,j\\}$，定义\n$$\nh_{i} \\equiv \\mathbb{P}_{i}\\big(T_{\\{j\\}}  T_{\\{0\\}}\\big),\n$$\n表示从状态 $i$ 出发，链在到达状态 $0$ 之前先到达目标状态 $j$ 的概率。\n\n任务：\n- 仅从 CTMC 的生成元（$Q$-矩阵）定义和第一步分析出发，推导 $h_{i}$（对于 $1 \\leq i \\leq j-1$）必须满足的后向差分方程，以及在 $i=0$ 和 $i=j$ 处的边界条件。\n- 求解这些方程，以出生率与死亡率之比的形式，得到 $h_{i}$ 的一个闭式解。您的解必须用这些比率的乘积和总和明确表示。\n- 最后，将问题特殊化到齐次情况，即 $\\lambda_{i} \\equiv \\lambda > 0$ 和 $\\mu_{i} \\equiv \\mu > 0$ 且 $\\mu \\neq \\lambda$。定义死亡率与出生率之比 $\\rho \\equiv \\mu/\\lambda$，并用 $i$、$j$ 和 $\\rho$ 表示 $h_{i}$（对于 $1 \\leq i \\leq j-1$）。\n\n将您的最终答案表示为齐次情况下 $h_{i}$ 的单个闭式解析表达式，作为 $i$、$j$ 和 $\\rho$ 的函数。不需要进行数值舍入。",
            "solution": "所述问题是连续时间马尔可夫链理论中的一个标准的、适定的问题，在数学和科学上都是合理的。因此，我们可以进行完整的推导。\n\n该问题涉及一个在有限状态空间 $S = \\{0, 1, 2, \\dots, j\\}$ 上的生灭连续时间马尔可夫链。状态 $0$ 和 $j$ 是吸收态，这反映在生成元矩阵的元素 $q_{0,0}=0$ 和 $q_{j,j}=0$ 中。对于暂留态 $i \\in \\{1, 2, \\dots, j-1\\}$，转移速率由 $q_{i, i+1} = \\lambda_i > 0$ 和 $q_{i, i-1} = \\mu_i > 0$ 给出。对角线元素为 $q_{i,i} = -(\\lambda_i + \\mu_i)$，表示离开状态 $i$ 的总速率。\n\n我们需要求解 $h_i \\equiv \\mathbb{P}_{i}(T_{\\{j\\}}  T_{\\{0\\}})$，即过程从状态 $i$ 开始，在状态 $j$ 被吸收而不是在状态 $0$ 被吸收的概率。\n\n**第一部分：后向方程的推导**\n\n吸收概率 $h_i$ 在暂留态集合 $\\{1, 2, \\dots, j-1\\}$ 上关于生成元 $Q$ 是调和的。这意味着对于此集合中的任何 $i$，都有 $(Qh)(i) = 0$。算子 $(Qh)(i)$ 定义为 $\\sum_{k \\in S} q_{i,k} h_k$。对于状态 $i \\in \\{1, 2, \\dots, j-1\\}$，唯一非零的非对角线速率是转移到状态 $i-1$ 和 $i+1$ 的速率。\n\n条件 $(Qh)(i) = 0$ 可转换为：\n$$ q_{i, i-1} h_{i-1} + q_{i, i} h_i + q_{i, i+1} h_{i+1} = 0 $$\n代入给定的生成元元素：\n$$ \\mu_i h_{i-1} - (\\lambda_i + \\mu_i)h_i + \\lambda_i h_{i+1} = 0 $$\n此方程对 $i \\in \\{1, 2, \\dots, j-1\\}$ 成立。我们可以重新整理它以得到一个后向差分方程。\n$$ \\lambda_i (h_{i+1} - h_i) = \\mu_i (h_i - h_{i-1}) $$\n\n接下来，我们建立 $i=0$ 和 $i=j$ 的边界条件。\n如果过程从状态 $i=0$ 开始，由于该状态是吸收态，过程将永远停留在 $0$。因此，到达状态 $0$ 的时间为 $T_{\\{0\\}} = 0$。因为 $j \\neq 0$，到达状态 $j$ 的时间必然为 $T_{\\{j\\}} > 0$（或无穷大）。所以，事件 $T_{\\{j\\}}  T_{\\{0\\}}$ 是不可能发生的。其概率为 $0$。\n$$ h_0 = \\mathbb{P}_0(T_{\\{j\\}}  T_{\\{0\\}}) = 0 $$\n如果过程从状态 $i=j$ 开始，它已经处于目标吸收态。到达时间为 $T_{\\{j\\}} = 0$。因为 $j \\neq 0$，$T_{\\{0\\}} > 0$。事件 $T_{\\{j\\}}  T_{\\{0\\}}$ 是必然发生的。其概率为 $1$。\n$$ h_j = \\mathbb{P}_j(T_{\\{j\\}}  T_{\\{0\\}}) = 1 $$\n\n**第二部分：一般速率情况下的解**\n\n令 $\\Delta_i = h_i - h_{i-1}$，其中 $i \\in \\{1, 2, \\dots, j\\}$。差分方程变为：\n$$ \\lambda_i \\Delta_{i+1} = \\mu_i \\Delta_i $$\n这给出了差分的递推关系：\n$$ \\Delta_{i+1} = \\frac{\\mu_i}{\\lambda_i} \\Delta_i \\quad \\text{for } 1 \\le i \\le j-1 $$\n我们可以通过迭代来求解：\n$$ \\Delta_i = \\left( \\prod_{k=1}^{i-1} \\frac{\\mu_k}{\\lambda_k} \\right) \\Delta_1 \\quad \\text{for } i \\ge 2 $$\n我们定义 $\\pi_0 = 1$ 以及对于 $k \\ge 1$，$\\pi_k = \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l}$。那么该关系可以写成 $\\Delta_i = \\pi_{i-1} \\Delta_1$，其中 $i \\ge 1$。\n\n现在，我们将 $h_i$ 表示为这些差分的和（一个裂项求和）：\n$$ h_i = h_0 + \\sum_{k=1}^{i} (h_k - h_{k-1}) = h_0 + \\sum_{k=1}^{i} \\Delta_k $$\n使用边界条件 $h_0=0$：\n$$ h_i = \\sum_{k=1}^{i} \\Delta_k = \\sum_{k=1}^{i} \\pi_{k-1} \\Delta_1 = \\Delta_1 \\sum_{k=0}^{i-1} \\pi_k $$\n为了求出常数 $\\Delta_1 = h_1 - h_0 = h_1$，我们应用第二个边界条件 $h_j=1$：\n$$ h_j = 1 = \\Delta_1 \\sum_{k=0}^{j-1} \\pi_k $$\n这意味着：\n$$ \\Delta_1 = \\frac{1}{\\sum_{k=0}^{j-1} \\pi_k} $$\n将此代回 $h_i$ 的表达式中：\n$$ h_i = \\frac{\\sum_{k=0}^{i-1} \\pi_k}{\\sum_{k=0}^{j-1} \\pi_k} = \\frac{\\sum_{k=0}^{i-1} \\left( \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l} \\right)}{\\sum_{k=0}^{j-1} \\left( \\prod_{l=1}^{k} \\frac{\\mu_l}{\\lambda_l} \\right)} $$\n其中，连乘积 $\\prod_{l=1}^{0} (\\cdot)$ 被理解为 $1$。这就是一般情况下的闭式解。\n\n**第三部分：齐次情况的特殊化**\n\n我们给定齐次情况，其中对于所有有效的 $i$，都有 $\\lambda_i \\equiv \\lambda > 0$ 和 $\\mu_i \\equiv \\mu > 0$，且 $\\mu \\neq \\lambda$。死亡率与出生率之比为常数：\n$$ \\rho \\equiv \\frac{\\mu}{\\lambda} $$\n$\\pi_k$ 项变为：\n$$ \\pi_k = \\prod_{l=1}^{k} \\frac{\\mu}{\\lambda} = \\rho^k $$\n$h_i$ 的表达式简化为两个几何级数之比：\n$$ h_i = \\frac{\\sum_{k=0}^{i-1} \\rho^k}{\\sum_{k=0}^{j-1} \\rho^k} $$\n由于问题陈述 $\\mu \\neq \\lambda$，我们有 $\\rho \\neq 1$。我们可以使用有限几何级数的求和公式，$\\sum_{k=0}^{n-1} r^k = \\frac{r^n - 1}{r-1}$。\n将此公式应用于分子和分母：\n$$ \\sum_{k=0}^{i-1} \\rho^k = \\frac{\\rho^i - 1}{\\rho - 1} $$\n$$ \\sum_{k=0}^{j-1} \\rho^k = \\frac{\\rho^j - 1}{\\rho - 1} $$\n将它们代入 $h_i$ 的表达式中：\n$$ h_i = \\frac{\\frac{\\rho^i - 1}{\\rho - 1}}{\\frac{\\rho^j - 1}{\\rho - 1}} = \\frac{\\rho^i - 1}{\\rho^j - 1} $$\n该表达式对 $i \\in \\{1, 2, \\dots, j-1\\}$ 有效。这就是齐次情况下 $h_i$ 所需的闭式解，作为 $i$、$j$ 和 $\\rho$ 的函数。\n为了检验，我们可以验证边界条件。对于 $i=0$，$h_0 = (\\rho^0 - 1)/(\\rho^j - 1) = (1-1)/(\\rho^j-1) = 0$。对于 $i=j$，$h_j = (\\rho^j-1)/(\\rho^j-1)=1$。该公式也适用于边界。",
            "answer": "$$\n\\boxed{\\frac{\\rho^{i} - 1}{\\rho^{j} - 1}}\n$$"
        },
        {
            "introduction": "从判断事件“是否”发生，我们更进一步，探究事件“何时”发生。计算吸收时间（即过程首次进入吸收状态所需的时间）的分布，在可靠性工程、化学动力学和生存分析等领域至关重要。本练习将展示如何通过划分 $Q$-矩阵并利用线性代数工具，特别是对暂态子生成元 $T$ 的谱分析，来精确地推导出吸收时间的概率密度函数。",
            "id": "3298780",
            "problem": "考虑一个定义在状态空间 $\\{1,2,3,4\\}$ 上的有限连续时间马尔可夫链 (CTMC)，其生成元（也称为 $Q$ 矩阵）如下，其中状态 $4$ 是一个吸收态。生成元为\n$$\nQ \\;=\\;\n\\begin{pmatrix}\n-2  2  0  0 \\\\\n0  -3  3  0 \\\\\n0  0  -5  5 \\\\\n0  0  0  0\n\\end{pmatrix}.\n$$\n设初始分布集中在状态 $1$，即在 $\\{1,2,3\\}$ 上的初始瞬时态分布为 $\\alpha = (1,0,0)$。令 $\\tau$ 表示吸收时间，即 CTMC 首次进入状态 $4$ 的时间。\n\n从生成元 $Q$ 的基本定义、瞬时块和吸收块的划分、以及通过将 $Q$ 限制在 $\\{1,2,3\\}$ 上得到的瞬时子生成元 $T$ 出发，使用谱分析（$T$ 的对角化）或一致化方法，推导出吸收时间 $\\tau$ 的分布。将你的结果解释为连续时间下的指数分布混合。\n\n你的任务是：提供 $\\tau$ 的概率密度函数 $f_{\\tau}(t)$ 在 $t \\ge 0$ 时的精确解析表达式。不要对答案进行四舍五入。",
            "solution": "该问题提法恰当，在连续时间马尔可夫链 (CTMC) 理论中有坚实的科学基础。所有必要信息都已提供，目标也已明确说明。因此，我们可以开始求解。\n\n该 CTMC 的状态空间为 $S = \\{1, 2, 3, 4\\}$。瞬时态集合为 $\\mathcal{T} = \\{1, 2, 3\\}$，吸收态集合为 $\\mathcal{A} = \\{4\\}$。生成元矩阵 $Q$ 可以划分为\n$$\nQ = \\begin{pmatrix} T  R \\\\ 0  0 \\end{pmatrix}\n$$\n其中 $T$ 是瞬时态之间转移的子生成元，$R$ 是从瞬时态到吸收态的转移率矩阵。根据给定的 $Q$ 矩阵，我们确定\n$$\nT \\;=\\;\n\\begin{pmatrix}\n-2  2  0 \\\\\n0  -3  3 \\\\\n0  0  -5\n\\end{pmatrix}\n\\quad \\text{和} \\quad\nR \\;=\\;\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n5\n\\end{pmatrix}.\n$$\n吸收时间 $\\tau$ 是过程首次进入吸收态 $4$ 的时间。$\\tau$ 的生存函数 $S_{\\tau}(t) = P(\\tau > t)$ 是指在时间 $t$ 之前过程尚未被吸收的概率。给定瞬时态上的初始分布 $\\alpha$，该概率由下式给出\n$$\nS_{\\tau}(t) = \\alpha P_{\\mathcal{T}}(t) \\mathbf{1}\n$$\n其中 $P_{\\mathcal{T}}(t) = \\exp(Tt)$ 是瞬时态的转移概率矩阵，$\\mathbf{1}$ 是一个相应维度的全 1 列向量。\n问题说明过程从状态 $1$ 开始，这对应于初始瞬时态分布 $\\alpha = (1, 0, 0)$。因此，$S_{\\tau}(t)$ 是矩阵 $\\exp(Tt)$ 第一行元素的和：\n$$\nS_{\\tau}(t) = \\begin{pmatrix} 1  0  0 \\end{pmatrix} \\exp(Tt) \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\sum_{j \\in \\mathcal{T}} [\\exp(Tt)]_{1j}.\n$$\n为了计算 $\\exp(Tt)$，我们使用谱分析。我们求 $T$ 的特征值和特征向量。由于 $T$ 是一个上三角矩阵，其特征值即为对角线元素：$\\lambda_1 = -2$, $\\lambda_2 = -3$ 和 $\\lambda_3 = -5$。这些特征值互不相同，因此 $T$ 是可对角化的。\n\n我们求出对应于每个 $\\lambda_i$ 的右特征向量 $u_i$，满足 $T u_i = \\lambda_i u_i$。\n对于 $\\lambda_1 = -2$：$(T+2I)u_1=0 \\implies \\begin{pmatrix} 0  2  0 \\\\ 0  -1  3 \\\\ 0  0  -3 \\end{pmatrix} u_1 = 0 \\implies u_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_2 = -3$：$(T+3I)u_2=0 \\implies \\begin{pmatrix} 1  2  0 \\\\ 0  0  3 \\\\ 0  0  -2 \\end{pmatrix} u_2 = 0 \\implies u_2 = \\begin{pmatrix} -2 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_3 = -5$：$(T+5I)u_3=0 \\implies \\begin{pmatrix} 3  2  0 \\\\ 0  2  3 \\\\ 0  0  0 \\end{pmatrix} u_3 = 0 \\implies u_3 = \\begin{pmatrix} 2 \\\\ -3 \\\\ 2 \\end{pmatrix}$。\n\n我们将这些特征向量作为列，构成矩阵 $P$：\n$$\nP = \\begin{pmatrix} 1  -2  2 \\\\ 0  1  -3 \\\\ 0  0  2 \\end{pmatrix}.\n$$\n$T$ 的对角化形式为 $T = PDP^{-1}$，其中 $D = \\text{diag}(-2, -3, -5)$。矩阵指数则为 $\\exp(Tt) = P\\exp(Dt)P^{-1}$。首先，我们计算 $P$ 的逆矩阵：\n$$\nP^{-1} = \\begin{pmatrix} 1  2  2 \\\\ 0  1  3/2 \\\\ 0  0  1/2 \\end{pmatrix}.\n$$\n现在我们可以计算 $\\exp(Tt)$:\n$$\n\\exp(Tt) = P \\begin{pmatrix} \\exp(-2t)  0  0 \\\\ 0  \\exp(-3t)  0 \\\\ 0  0  \\exp(-5t) \\end{pmatrix} P^{-1}.\n$$\n如前所述，我们需要 $\\exp(Tt)$ 第一行元素的和。第一行由 $e_1^T \\exp(Tt)$ 给出，其中 $e_1^T = (1, 0, 0)$。\n$$\ne_1^T \\exp(Tt) = e_1^T P \\exp(Dt) P^{-1} = \\begin{pmatrix} 1  -2  2 \\end{pmatrix} \\begin{pmatrix} \\exp(-2t)  0  0 \\\\ 0  \\exp(-3t)  0 \\\\ 0  0  \\exp(-5t) \\end{pmatrix} P^{-1}\n$$\n$$\n= \\begin{pmatrix} \\exp(-2t)  -2\\exp(-3t)  2\\exp(-5t) \\end{pmatrix} \\begin{pmatrix} 1  2  2 \\\\ 0  1  3/2 \\\\ 0  0  1/2 \\end{pmatrix}\n$$\n这得到行向量 $( [\\exp(Tt)]_{11}, [\\exp(Tt)]_{12}, [\\exp(Tt)]_{13} )$：\n$$\n\\begin{align*}\n[\\exp(Tt)]_{11} = \\exp(-2t) \\\\\n[\\exp(Tt)]_{12} = 2\\exp(-2t) - 2\\exp(-3t) \\\\\n[\\exp(Tt)]_{13} = 2\\exp(-2t) - 3\\exp(-3t) + \\exp(-5t)\n\\end{align*}\n$$\n生存函数 $S_{\\tau}(t)$ 是这些概率的和：\n$$\nS_{\\tau}(t) = \\exp(-2t) + (2\\exp(-2t) - 2\\exp(-3t)) + (2\\exp(-2t) - 3\\exp(-3t) + \\exp(-5t))\n$$\n$$\nS_{\\tau}(t) = 5\\exp(-2t) - 5\\exp(-3t) + \\exp(-5t)\n$$\n吸收时间 $\\tau$ 的概率密度函数 (PDF) $f_{\\tau}(t)$ 是生存函数的负导数（对于 $t \\ge 0$）：\n$$\nf_{\\tau}(t) = -\\frac{d}{dt} S_{\\tau}(t) = -\\frac{d}{dt} (5\\exp(-2t) - 5\\exp(-3t) + \\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = - (5(-2)\\exp(-2t) - 5(-3)\\exp(-3t) + (-5)\\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = - (-10\\exp(-2t) + 15\\exp(-3t) - 5\\exp(-5t))\n$$\n$$\nf_{\\tau}(t) = 10\\exp(-2t) - 15\\exp(-3t) + 5\\exp(-5t)\n$$\n该表达式给出了 $t \\ge 0$ 时的概率密度函数。这一结果可以通过观察 CTMC 的结构 $1 \\to 2 \\to 3 \\to 4$ 来解释，它意味着吸收时间 $\\tau$ 是在状态 $1$、$2$ 和 $3$ 中停留时间之和。这些停留时间是独立的指数随机变量，$T_1 \\sim \\text{Exp}(2)$、$T_2 \\sim \\text{Exp}(3)$ 和 $T_3 \\sim \\text{Exp}(5)$。它们的和 $\\tau = T_1 + T_2 + T_3$ 的分布是一个亚指数分布。其概率密度函数是指数项的线性组合，可以看作是一种广义混合。推导出的表达式正是该分布的精确形式。",
            "answer": "$$\\boxed{10\\exp(-2t) - 15\\exp(-3t) + 5\\exp(-5t)}$$"
        },
        {
            "introduction": "在实际建模中，我们分析的模型参数（如转移速率）往往是不确定的，或者需要根据数据进行校准。因此，理解模型输出对参数变化的敏感度就显得尤为重要，这被称为敏感度分析。本练习提供了一个将理论与实践相结合的综合性动手项目，你将学习并应用强大的似然比方法，通过理论推导、实施蒙特卡洛模拟，并最终将估计结果与精确解进行比较，从而全面掌握评估模型参数敏感度的流程。",
            "id": "3298796",
            "problem": "考虑一个参数化的连续时间马尔可夫链 (CTMC) 族，其状态空间为有限集 $\\{0,1\\}$，其生成元（也称为 $Q$-矩阵）由下式给出\n$$\nQ^\\theta \\;=\\; \\begin{pmatrix}\n-\\theta  \\theta \\\\\n\\beta  -\\beta\n\\end{pmatrix},\n$$\n其中 $\\theta \\in (0,\\infty)$ 是我们感兴趣的参数，而 $\\beta \\in (0,\\infty)$ 是一个固定的常数。令 $\\{X_t^\\theta\\}_{t \\ge 0}$ 表示初始状态为 $X_0^\\theta = x_0 \\in \\{0,1\\}$ 的 CTMC，其构建遵循标准的 CTMC 构造：以当前状态 $i \\in \\{0,1\\}$ 为条件，其停留时间服从速率为 $\\lambda_i^\\theta = -q_{ii}^\\theta$ 的指数分布，并且下一个状态 $j \\ne i$ 以转移概率 $q_{ij}^\\theta / \\lambda_i^\\theta$ 被选择。\n\n令 $T > 0$ 为一个固定的时间范围，并定义可观测量 $g(X_T^\\theta) = \\mathbf{1}\\{X_T^\\theta = 1\\}$。目标是使用基于由 $Q^\\theta$ 诱导的路径测度之间的 Radon–Nikodym 导数的似然比（也称为得分函数）方法来估计路径导数 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$。\n\n使用的基本原理：\n- 由生成元 $Q^\\theta$ 诱导的在 $[0,T]$ 上的 CTMC 路径密度具有通常的乘法形式，即所有跳跃的 $q_{X_{t^-},X_t}^\\theta$ 的乘积，再乘以迁出率 $\\lambda_{X_t}^\\theta = -q_{X_t,X_t}^\\theta$ 的时间积分的负指数。\n- 路径测度的 Radon–Nikodym 导数得出了在参数 $\\theta$ 下路径的对数似然，其关于 $\\theta$ 的导数即为得分。\n- 得分函数恒等式（在标准正则性条件下）指出，对于任意可积泛函 $H$，有 $\\partial_\\theta \\mathbb{E}_\\theta[H] = \\mathbb{E}_\\theta[H \\cdot S_T(\\theta)]$，其中 $S_T(\\theta)$ 是在 $[0,T]$ 上观测到的路径的对数似然关于 $\\theta$ 的导数。\n\n任务：\n- 从上述基本原理出发，不假设任何快捷公式，推导适用于上述具有 $Q^\\theta$ 的双状态模型的得分 $S_T(\\theta)$ 的显式表达式。您的推导必须用以下项表示：\n  - 到时间 $T$ 为止在状态 0 中停留的总时间，记为 $\\int_0^T \\mathbf{1}\\{X_t^\\theta=0\\} \\, dt$。\n  - 到时间 $T$ 为止从状态 0 跳跃到状态 1 的次数，记为 $N_{01}(T)$。\n- 使用得分函数恒等式，为 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$ 获得一个似然比估计量，形式为 $\\widehat{\\Delta}_{\\mathrm{LR}} = \\frac{1}{M} \\sum_{m=1}^M g(X_T^{\\theta,(m)}) S_T^{(m)}(\\theta)$，其中样本路径由 $m \\in \\{1,\\dots,M\\}$ 索引且相互独立。\n- 考虑通过使用基线 $c \\in \\mathbb{R}$ 进行中心化来减少方差，从而形成中心化估计量 $\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)} = \\frac{1}{M} \\sum_{m=1}^M \\bigl(g(X_T^{\\theta,(m)}) - c\\bigr) S_T^{(m)}(\\theta)$。解释为什么中心化能保持无偏性，并实现一个两阶段过程，其中使用一个引导运行来近似最优常数基线 $c^\\star = \\mathrm{Cov}(g(X_T^\\theta), S_T(\\theta))/\\mathrm{Var}(S_T(\\theta))$。\n- 仅使用边际概率 $p_\\theta(t) = \\mathbb{P}(X_t^\\theta=1)$ 的前向方程和初等微积分，推导双状态模型精确敏感度 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$ 的闭式解。结果需用 $\\theta$、$\\beta$、$T$ 和 $x_0$ 显式表示。\n\n实现要求：\n- 实现一个在时间范围 $[0,T]$ 上，针对给定 $Q^\\theta$ 的 $\\{0,1\\}$ 上的 CTMC 样本路径的精确模拟器，对于每次复制，累积 $N_{01}(T)$ 和 $\\int_0^T \\mathbf{1}\\{X_t^\\theta=0\\}\\,dt$ 以及最终状态 $X_T^\\theta$。在各次复制中使用独立同分布的样本。\n- 对下面的每个测试用例，使用两阶段蒙特卡罗计算：\n  - 一个包含 $M_{\\text{pilot}}$ 个样本的引导阶段，用于估计基线 $\\widehat{c}$，公式为 $\\widehat{c} = \\widehat{\\mathrm{Cov}}(g,S)/\\widehat{\\mathrm{Var}}(S)$。\n  - 一个包含 $M_{\\text{main}}$ 个样本的主阶段，用于估计：\n    - 未中心化的 LR 均值 $\\widehat{\\Delta}_{\\mathrm{LR}}$ 和样本方差 $\\widehat{\\mathrm{Var}}(\\text{uncentered})$。\n    - 中心化的 LR 均值 $\\widehat{\\Delta}_{\\mathrm{LR}}^{(\\widehat{c})}$ 和样本方差 $\\widehat{\\mathrm{Var}}(\\text{centered})$。\n- 使用您的闭式公式独立计算精确敏感度 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]$，并将其与蒙特卡罗均值进行比较。使用绝对容差 $\\varepsilon = 0.02$ 来判断是否一致。\n\n测试套件：\n- 用例 $\\mathrm{A}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 1.0$，$x_0 = 0$。\n- 用例 $\\mathrm{B}$：$\\theta = 0.2$，$\\beta = 3.0$，$T = 2.0$，$x_0 = 0$。\n- 用例 $\\mathrm{C}$：$\\theta = 1.0$，$\\beta = 1.0$，$T = 0.0$，$x_0 = 1$。\n- 用例 $\\mathrm{D}$：$\\theta = 4.0$，$\\beta = 0.5$，$T = 5.0$，$x_0 = 0$。\n- 方差增长检查（在两个时间范围上使用相同参数）：\n  - 用例 $\\mathrm{E1}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 0.5$，$x_0 = 0$。\n  - 用例 $\\mathrm{E2}$：$\\theta = 1.5$，$\\beta = 2.0$，$T = 3.0$，$x_0 = 0$。\n\n可量化输出：\n- 对于用例 A–D 中的每一个，输出两个布尔值：\n  - $b_1$：主阶段 LR 估计（未中心化）与精确敏感度之间的绝对误差是否最多为 $\\varepsilon$。\n  - $b_2$：主阶段中心化方差是否小于或等于主阶段未中心化方差。\n- 对于使用用例 E1 和 E2 的方差增长检查，输出一个布尔值：\n  - $b_3$：$T=3.0$ 时的未中心化 LR 方差是否大于或等于 $T=0.5$ 时的方差。\n\n蒙特卡罗样本大小和可复现性：\n- 每个用例使用 $M_{\\text{pilot}} = 20000$ 和 $M_{\\text{main}} = 120000$，并固定随机种子以确保可复现性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。列表必须按以下顺序排列\n$$\n[b_{\\mathrm{A},1}, b_{\\mathrm{A},2}, b_{\\mathrm{B},1}, b_{\\mathrm{B},2}, b_{\\mathrm{C},1}, b_{\\mathrm{C},2}, b_{\\mathrm{D},1}, b_{\\mathrm{D},2}, b_{\\mathrm{E},3}],\n$$\n其中每个 $b_{\\cdot,\\cdot}$ 都是如上定义的布尔值。不应打印任何其他文本。",
            "solution": "用户提供的问题经评估和验证，是计算随机建模领域中一个定义明确且科学合理​​的练习。所有必要的参数和定义都已提供，理论基础是标准的，目标清晰且可形式化。因此，我们可以着手提供完整的解决方案。\n\n### 第 1 部分：得分函数 $S_T(\\theta)$ 的推导\n\n得分函数是样本路径的对数似然函数关于感兴趣参数 $\\theta$ 的导数。一个在有限状态空间上的连续时间马尔可夫链 (CTMC) 在区间 $[0, T]$ 上观测到的路径，由初始状态 $X_0$、访问过的状态序列以及它们之间的跳跃时间所表征。\n\n特定路径实现 $\\omega = (X_s)_{s \\in [0,T]}$ 的似然由每次跳跃的转移率的乘积与每个状态中停留时间的生存概率给出。这可以表示为：\n$$\nL_T(\\theta; \\omega) = \\left( \\prod_{k=1}^{N(T)} q_{X_{t_k^-}, X_{t_k}}^\\theta \\right) \\exp\\left( -\\int_0^T \\lambda_{X_s}^\\theta \\, ds \\right)\n$$\n其中 $N(T)$ 是在 $[0, T]$ 内于时间 $t_k$ 发生的跳跃次数，$q_{ij}^\\theta$ 是从状态 $i$ 到 $j$ 的转移率，而 $\\lambda_i^\\theta = -q_{ii}^\\theta$ 是从状态 $i$ 的总迁出率。\n\n对数似然 $\\log L_T(\\theta)$ 为：\n$$\n\\log L_T(\\theta; \\omega) = \\sum_{k=1}^{N(T)} \\log q_{X_{t_k^-}, X_{t_k}}^\\theta - \\int_0^T \\lambda_{X_s}^\\theta \\, ds\n$$\n对于给定的生成元为 $Q^\\theta = \\begin{pmatrix} -\\theta  \\theta \\\\ \\beta  -\\beta \\end{pmatrix}$ 的双状态模型，我们有：\n-   转移率：$q_{01}^\\theta = \\theta$ 和 $q_{10}^\\theta = \\beta$。只有 $q_{01}^\\theta$ 依赖于 $\\theta$。\n-   迁出率：$\\lambda_0^\\theta = \\theta$ 和 $\\lambda_1^\\theta = \\beta$。只有 $\\lambda_0^\\theta$ 依赖于 $\\theta$。\n\n令 $N_{01}(T)$ 为在 $[0, T]$ 内从状态 0 到 1 的跳跃次数， $N_{10}(T)$ 为从 1 到 0 的跳跃次数。令 $T_0 = \\int_0^T \\mathbf{1}\\{X_s=0\\} \\, ds$ 和 $T_1 = \\int_0^T \\mathbf{1}\\{X_s=1\\} \\, ds$ 分别为在状态 0 和 1 中停留的总时间。\n\n这个特定模型的对数似然变为：\n$$\n\\log L_T(\\theta) = N_{01}(T) \\log(q_{01}^\\theta) + N_{10}(T) \\log(q_{10}^\\theta) - (T_0 \\lambda_0^\\theta + T_1 \\lambda_1^\\theta)\n$$\n代入具体的速率：\n$$\n\\log L_T(\\theta) = N_{01}(T) \\log(\\theta) + N_{10}(T) \\log(\\beta) - T_0 \\theta - T_1 \\beta\n$$\n得分函数 $S_T(\\theta)$ 是 $\\log L_T(\\theta)$ 关于 $\\theta$ 的导数。对于一个固定的样本路径，量 $N_{01}(T)$、$N_{10}(T)$、$T_0$ 和 $T_1$ 都是常数。\n$$\nS_T(\\theta) = \\frac{\\partial}{\\partial \\theta} \\left( N_{01}(T) \\log(\\theta) + N_{10}(T) \\log(\\beta) - T_0 \\theta - T_1 \\beta \\right)\n$$\n求导后，我们发现只有涉及 $\\theta$ 的项有贡献：\n$$\nS_T(\\theta) = \\frac{N_{01}(T)}{\\theta} - T_0\n$$\n这就是用所要求的路径统计量表示的得分的显式表达式。\n\n### 第 2 部分：似然比估计与中心化\n\n得分函数恒等式指出，对于一个适当正则的可观测量 $H$，有 $\\partial_\\theta \\mathbb{E}_\\theta[H] = \\mathbb{E}_\\theta[H \\cdot S_T(\\theta)]$。将此应用于我们的可观测量 $g(X_T^\\theta) = \\mathbf{1}\\{X_T^\\theta = 1\\}$，敏感度为 $\\partial_\\theta \\mathbb{E}[g(X_T^\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)]$。一个基于 $M$ 条独立路径的蒙特卡罗估计量是：\n$$\n\\widehat{\\Delta}_{\\mathrm{LR}} = \\frac{1}{M} \\sum_{m=1}^M g(X_T^{\\theta,(m)}) S_T^{(m)}(\\theta)\n$$\n为了减少该估计量的方差，可以引入一个基线 $c \\in \\mathbb{R}$，形成中心化估计量：\n$$\n\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)} = \\frac{1}{M} \\sum_{m=1}^M \\bigl(g(X_T^{\\theta,(m)}) - c\\bigr) S_T^{(m)}(\\theta)\n$$\n对于任何常数 $c$，此估计量都保持无偏，因为得分函数的期望为零，即 $\\mathbb{E}[S_T(\\theta)] = 0$。此性质在允许交换微分和积分的正则性条件下成立，而这些条件在此处是满足的。\n中心化估计量的期望是：\n$$\n\\mathbb{E}[\\widehat{\\Delta}_{\\mathrm{LR}}^{(c)}] = \\mathbb{E}[(g(X_T^\\theta) - c) S_T(\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)] - c \\mathbb{E}[S_T(\\theta)] = \\mathbb{E}[g(X_T^\\theta) S_T(\\theta)] - c \\cdot 0 = \\partial_\\theta \\mathbb{E}[g(X_T^\\theta)]\n$$\n问题指定使用两阶段方法来估计基线 $c^\\star = \\mathrm{Cov}(g(X_T^\\theta), S_T(\\theta))/\\mathrm{Var}(S_T(\\theta))$。这是通过使用 $M_{\\text{pilot}}$ 个样本的引导运行来计算样本估计值 $\\widehat{\\mathrm{Cov}}(g,S)$ 和 $\\widehat{\\mathrm{Var}}(S)$，从而获得估计值 $\\widehat{c}$，然后在 $M_{\\text{main}}$ 个样本的主运行中使用该值。\n\n### 第 3 部分：通过前向方程计算精确敏感度\n\n精确敏感度可以解析推导。令 $p_1(t) = \\mathbb{P}(X_t^\\theta=1)$。状态概率根据 Kolmogorov 前向方程 $\\frac{d\\vec{p}}{dt} = \\vec{p} Q^\\theta$ 演化。对于 $p_1(t)$，这会产生以下常微分方程：\n$$\n\\frac{dp_1(t)}{dt} = p_0(t)q_{01}^\\theta + p_1(t)q_{11}^\\theta = (1-p_1(t))\\theta + p_1(t)(-\\beta) = \\theta - (\\theta+\\beta)p_1(t)\n$$\n这是一个一阶线性常微分方程。在初始条件 $p_1(0) = \\mathbf{1}\\{x_0=1\\}$下，在时间 $T$ 的解是：\n$$\np_1(T) = \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T} + \\frac{\\theta}{\\theta+\\beta}\n$$\n我们求 $p_1(T)$ 关于 $\\theta$ 的导数：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} \\left[ \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T} + \\frac{\\theta}{\\theta+\\beta} \\right]\n$$\n使用乘法和除法求导法则，我们得到：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\left(-\\frac{\\beta}{(\\theta+\\beta)^2}\\right)e^{-(\\theta+\\beta)T} + \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right)\\left(-T e^{-(\\theta+\\beta)T}\\right) + \\frac{\\beta}{(\\theta+\\beta)^2}\n$$\n这个表达式可以简化为：\n$$\n\\frac{\\partial p_1(T)}{\\partial \\theta} = \\frac{\\beta}{(\\theta+\\beta)^2} \\left(1 - e^{-(\\theta+\\beta)T}\\right) - T \\left(p_1(0) - \\frac{\\theta}{\\theta+\\beta}\\right) e^{-(\\theta+\\beta)T}\n$$\n这个闭式公式提供了精确值，蒙特卡罗估计将以此为基准进行比较。\n实现将遵循这些推导，模拟 CTMC 路径以收集统计数据，计算 LR 估计值（包括未中心化和中心化的），将它们与精确值进行比较，并评估所需的布尔条件。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CTMC sensitivity analysis problem as specified.\n    \n    This function encapsulates all logic, including simulation, analytical calculations,\n    and result aggregation, to produce the final output in the required format.\n    It adheres to the specified Python version and library constraints.\n    \"\"\"\n\n    # Fixed random seed for reproducibility as per problem statement\n    SEED = 42\n    \n    # Monte Carlo simulation parameters\n    M_PILOT = 20000\n    M_MAIN = 120000\n    EPSILON = 0.02\n\n    # Global RNG instance for the entire run\n    RNG = np.random.default_rng(SEED)\n\n    def ctmc_simulator(theta, beta, T, x0):\n        \"\"\"Simulates one path of the 2-state CTMC.\"\"\"\n        current_time = 0.0\n        current_state = x0\n        \n        time_in_state_0 = 0.0\n        jumps_0_to_1 = 0\n\n        if T == 0.0:\n            return x0, 0.0, 0\n        \n        while current_time  T:\n            is_state_0 = (current_state == 0)\n            \n            rate = theta if is_state_0 else beta\n            \n            holding_time = RNG.exponential(1.0 / rate)\n            \n            time_spent_in_state = min(holding_time, T - current_time)\n            \n            if is_state_0:\n                time_in_state_0 += time_spent_in_state\n                \n            current_time += time_spent_in_state\n            \n            if current_time  T: # A jump occurred before T\n                if is_state_0:\n                    jumps_0_to_1 += 1\n                current_state = 1 - current_state\n            # else: process terminates at T, state doesn't change\n            \n        return current_state, time_in_state_0, jumps_0_to_1\n\n    def exact_sensitivity(theta, beta, T, x0):\n        \"\"\"Computes the exact sensitivity using the derived analytical formula.\"\"\"\n        p1_0 = 1.0 if x0 == 1 else 0.0\n        \n        if T == 0.0:\n            return 0.0\n\n        s = theta + beta\n        exp_term = np.exp(-s * T)\n        \n        deriv = (beta / s**2) * (1 - exp_term) - T * (p1_0 - theta / s) * exp_term\n        return deriv\n    \n    def run_simulation_for_case(params):\n        \"\"\"Executes the two-stage MC simulation for a given test case.\"\"\"\n        theta, beta, T, x0 = params\n\n        # Pilot Stage to estimate the baseline c\n        pilot_g = np.zeros(M_PILOT)\n        pilot_S = np.zeros(M_PILOT)\n        \n        for i in range(M_PILOT):\n            final_state, time_in_0, n_01 = ctmc_simulator(theta, beta, T, x0)\n            pilot_g[i] = 1.0 if final_state == 1 else 0.0\n            pilot_S[i] = n_01 / theta - time_in_0\n\n        var_S = np.var(pilot_S, ddof=1)\n        if var_S > 1e-15:\n            # np.cov uses N-1 denominator by default, which is sample covariance\n            cov_matrix = np.cov(pilot_g, pilot_S)\n            cov_g_S = cov_matrix[0, 1]\n            c_hat = cov_g_S / var_S\n        else:\n            # If Score has no variance (e.g., T=0), any baseline works as S=0.\n            c_hat = 0.0\n\n        # Main Stage for estimation\n        uncentered_lr_samples = np.zeros(M_MAIN)\n        centered_lr_samples = np.zeros(M_MAIN)\n\n        for i in range(M_MAIN):\n            final_state, time_in_0, n_01 = ctmc_simulator(theta, beta, T, x0)\n            g = 1.0 if final_state == 1 else 0.0\n            S = n_01 / theta - time_in_0\n\n            uncentered_lr_samples[i] = g * S\n            centered_lr_samples[i] = (g - c_hat) * S\n\n        uncentered_mean = np.mean(uncentered_lr_samples)\n        uncentered_var = np.var(uncentered_lr_samples, ddof=1)\n        \n        centered_var = np.var(centered_lr_samples, ddof=1)\n\n        exact_val = exact_sensitivity(theta, beta, T, x0)\n\n        b1 = np.abs(uncentered_mean - exact_val) = EPSILON\n        b2 = centered_var = uncentered_var\n\n        return b1, b2, uncentered_var\n\n    test_cases = {\n        \"A\": (1.5, 2.0, 1.0, 0),\n        \"B\": (0.2, 3.0, 2.0, 0),\n        \"C\": (1.0, 1.0, 0.0, 1),\n        \"D\": (4.0, 0.5, 5.0, 0),\n        \"E1\": (1.5, 2.0, 0.5, 0),\n        \"E2\": (1.5, 2.0, 3.0, 0)\n    }\n\n    final_results = []\n    \n    # Cases A, B, C, D\n    for case_name in [\"A\", \"B\", \"C\", \"D\"]:\n        params = test_cases[case_name]\n        b1, b2, _ = run_simulation_for_case(params)\n        final_results.extend([b1, b2])\n\n    # Case E for variance growth check\n    _, _, var_e1 = run_simulation_for_case(test_cases[\"E1\"])\n    _, _, var_e2 = run_simulation_for_case(test_cases[\"E2\"])\n    bE3 = var_e2 >= var_e1\n    final_results.append(bE3)\n    \n    # Format the final output as a single line string\n    # Python's str(True) is 'True', which is a standard boolean representation.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}