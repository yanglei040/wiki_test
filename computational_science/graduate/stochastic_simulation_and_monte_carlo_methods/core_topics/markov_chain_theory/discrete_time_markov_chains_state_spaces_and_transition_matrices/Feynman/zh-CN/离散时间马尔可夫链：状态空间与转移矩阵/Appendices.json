{
    "hands_on_practices": [
        {
            "introduction": "应用马尔可夫链理论的第一步，也是最关键的一步，是将一个随机系统的动态转化为一个转移概率矩阵。这个练习提供了一个基础但至关重要的实践，要求你为一个受随机错误影响的内存比特构建转移矩阵。掌握这项技能是将现实世界问题抽象为数学模型的基础，为所有后续的分析和模拟奠定了基石。",
            "id": "1345199",
            "problem": "卫星控制系统中的一个内存比特位会因宇宙射线相互作用而产生错误。我们可以将该比特位的状态建模为一个随机过程。该比特位可以处于两种状态之一：状态 0（表示二进制值 '0'）或状态 1（表示二进制值 '1'）。\n\n在每个离散时间步长（对应于星上计算机的一个时钟周期），由于辐射环境，可能发生以下状态转换：\n- 如果比特位当前处于状态 0，它有 $p_{01}$ 的概率翻转到状态 1。\n- 如果比特位当前处于状态 1，它有 $p_{10}$ 的概率翻转到状态 0。\n\n假设在单个时间步长内，这些是唯一可能发生的状态变化类型。如果未发生翻转，则比特位保持其当前状态。为这个双状态系统构建一步转移概率矩阵 $P$。矩阵中的状态应按（状态 0，状态 1）的顺序排列，使得第一行/列对应于状态 0，第二行/列对应于状态 1。",
            "solution": "我们将该比特位的状态演化建模为一个离散时间马尔可夫链，其状态空间按 $(0,1)$ 排序。一步转移概率矩阵 $P$ 的元素为 $P_{ij}=\\Pr(X_{t+1}=j \\mid X_{t}=i)$，因此每行的和必须为 $1$。\n\n根据题目描述：\n- 如果当前状态为 $0$，翻转到 $1$ 的概率是 $p_{01}$，因此保持在 $0$ 的概率是 $1-p_{01}$。这得出 $P_{00}=1-p_{01}$ 和 $P_{01}=p_{01}$。\n- 如果当前状态为 $1$，翻转到 $0$ 的概率是 $p_{10}$，因此保持在 $1$ 的概率是 $1-p_{10}$。这得出 $P_{10}=p_{10}$ 和 $P_{11}=1-p_{10}$。\n\n因此，当行和列按 $(0,1) $ 排序时，转移矩阵为\n$$\nP=\\begin{pmatrix}\n1-p_{01} & p_{01} \\\\\np_{10} & 1-p_{10}\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix}1-p_{01} & p_{01} \\\\ p_{10} & 1-p_{10}\\end{pmatrix}}$$"
        },
        {
            "introduction": "在构建了转移矩阵之后，我们自然会想了解系统的长期演化行为。这个练习将带你实践一种强大的分析技术——矩阵对角化——来推导$n$步转移概率的闭式表达式。这项练习不仅连接了马尔可夫链的抽象理论与线性代数的具体工具，还让你能够深刻洞察链的收敛性质及其稳态行为。",
            "id": "3303948",
            "problem": "考虑一个离散时间马尔可夫链 (DTMC)，其有限状态空间为 $\\{1,2,3\\}$，转移矩阵 $P \\in \\mathbb{R}^{3 \\times 3}$ 由下式给出\n$$\nP \\;=\\; \\begin{pmatrix}\n0 & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & 0 & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & 0\n\\end{pmatrix}.\n$$\n所有元素均为非负，且每行之和为 $1$，因此 $P$ 是一个行随机矩阵。根据 DTMC 中 $n$ 步转移概率的定义，$P^{n}$ 的 $(i,j)$ 元素等于在 $n$ 步内从状态 $i$ 转移到状态 $j$ 的概率。仅使用基本事实——即 DTMC 转移矩阵的定义、将矩阵幂 $P^{n}$ 解释为 $n$ 步转移概率，以及对称矩阵的线性代数对角化方法——通过对角化（如果需要，可使用若尔当分解）推导 $P^{n}$ 的闭式表达式，并将其元素解释为 $n$ 步转移概率。你的推导过程必须识别出与 $P$ 的特征结构相关联的不变子空间，并论证该结构如何蕴含了当 $n \\to \\infty$ 时 $P^{n}$ 的极限行为。\n\n将你的最终答案表示为 $P^{n}$ 的 $(1,3)$ 元素关于正整数 $n$ 的精确符号表达式。无需四舍五入。不包含单位。最终答案必须是单一的闭式解析表达式。",
            "solution": "目标是为给定的离散时间马尔可夫链找到其 $n$ 步转移矩阵 $P^n$ 的闭式表达式。该转移矩阵为\n$$\nP = \\begin{pmatrix}\n0 & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & 0 & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & 0\n\\end{pmatrix}.\n$$\n由于 $P$ 是一个实对称矩阵，保证其可被一个正交矩阵对角化。我们将使用 $P$ 的谱分解来计算 $P^n$。这涉及到求 $P$ 的特征值和相应的特征空间。\n\n首先，我们通过求解特征方程 $\\det(P - \\lambda I) = 0$ 来找到特征值，其中 $I$ 是 $3 \\times 3$ 的单位矩阵。\n$$\n\\det \\begin{pmatrix}\n-\\lambda & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & -\\lambda & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & -\\lambda\n\\end{pmatrix} = 0\n$$\n$$\n-\\lambda \\left( \\lambda^2 - \\frac{1}{4} \\right) - \\frac{1}{2} \\left( -\\frac{\\lambda}{2} - \\frac{1}{4} \\right) + \\frac{1}{2} \\left( \\frac{1}{4} + \\frac{\\lambda}{2} \\right) = 0\n$$\n$$\n-\\lambda^3 + \\frac{\\lambda}{4} + \\frac{\\lambda}{4} + \\frac{1}{8} + \\frac{1}{8} + \\frac{\\lambda}{4} = 0\n$$\n$$\n-\\lambda^3 + \\frac{3}{4}\\lambda + \\frac{1}{4} = 0\n$$\n两边乘以 $-4$ 得到一个首一多项式：\n$$\n4\\lambda^3 - 3\\lambda - 1 = 0\n$$\n由于 $P$ 是一个随机矩阵，$\\lambda_1 = 1$ 必定是一个特征值。我们验证：$4(1)^3 - 3(1) - 1 = 4 - 3 - 1 = 0$。\n因式分解出 $(\\lambda - 1)$，我们进行多项式除法，得到：\n$$\n(\\lambda - 1)(4\\lambda^2 + 4\\lambda + 1) = 0\n$$\n这个二次因子是一个完全平方：$4\\lambda^2 + 4\\lambda + 1 = (2\\lambda + 1)^2$。\n因此，特征方程为 $(\\lambda - 1)(2\\lambda + 1)^2 = 0$。\n特征值为 $\\lambda_1 = 1$（代数重数为 $1$）和 $\\lambda_2 = -\\frac{1}{2}$（代数重数为 $2$）。\n\n接下来，我们求每个特征值对应的特征空间。\n对于 $\\lambda_1 = 1$，我们求 $(P - I)$ 的零空间：\n$$\nP - I = \\begin{pmatrix}\n-1 & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & -1 & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & -1\n\\end{pmatrix}\n$$\n行化简得到方程组 $x_1 = x_2 = x_3$。特征空间 $E_1$ 由向量 $v_1 = \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix}^T$ 张成。这是与马尔可夫链的平稳分布相关联的不变子空间。\n\n对于 $\\lambda_2 = -\\frac{1}{2}$，我们求 $(P + \\frac{1}{2}I)$ 的零空间：\n$$\nP + \\frac{1}{2}I = \\begin{pmatrix}\n\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2} \\\\\n\\frac{1}{2} & \\frac{1}{2} & \\frac{1}{2}\n\\end{pmatrix}\n$$\n这可以化简为单个方程 $x_1 + x_2 + x_3 = 0$。这定义了一个过原点的平面，即特征空间 $E_2$。$\\lambda_2 = -\\frac{1}{2}$ 的几何重数为 $2$，与其代数重数相等。例如，可以用向量 $v_2 = \\begin{pmatrix} 1 & -1 & 0 \\end{pmatrix}^T$ 和 $v_3 = \\begin{pmatrix} 1 & 1 & -2 \\end{pmatrix}^T$ 找到该子空间的一组正交基。这是瞬态子空间；初始分布在此子空间中的任何分量当 $n \\to \\infty$ 时都会衰减至零。\n\n由于 $P$ 是可对角化的，它可以写成其谱分解形式 $P = \\sum_k \\lambda_k \\Pi_k$，其中 $\\Pi_k$ 是到特征空间 $E_k$ 上的投影矩阵。那么，$P^n$ 由 $P^n = \\sum_k \\lambda_k^n \\Pi_k$ 给出。\n$$\nP^n = (1)^n \\Pi_1 + \\left(-\\frac{1}{2}\\right)^n \\Pi_2 = \\Pi_1 + \\left(-\\frac{1}{2}\\right)^n \\Pi_2\n$$\n到特征空间 $E_1$（由 $v_1$ 张成）上的投影矩阵 $\\Pi_1$ 由 $\\Pi_1 = \\frac{v_1 v_1^T}{v_1^T v_1}$ 给出：\n$$\n\\Pi_1 = \\frac{1}{1^2+1^2+1^2} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} 1 & 1 & 1 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}\n$$\n由于特征空间是正交的并且张成了 $\\mathbb{R}^3$，我们有 $\\Pi_1 + \\Pi_2 = I$。因此，到特征空间 $E_2$ 上的投影矩阵是 $\\Pi_2 = I - \\Pi_1$：\n$$\n\\Pi_2 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix}\n$$\n现在我们可以构建 $P^n$：\n$$\nP^n = \\frac{1}{3} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} + \\left(-\\frac{1}{2}\\right)^n \\frac{1}{3} \\begin{pmatrix} 2 & -1 & -1 \\\\ -1 & 2 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix}\n$$\n合并这些矩阵，得到 $P^n$ 的通用闭式表达式：\n$$\nP^n = \\frac{1}{3} \\begin{pmatrix}\n1 + 2\\left(-\\frac{1}{2}\\right)^n & 1 - \\left(-\\frac{1}{2}\\right)^n & 1 - \\left(-\\frac{1}{2}\\right)^n \\\\\n1 - \\left(-\\frac{1}{2}\\right)^n & 1 + 2\\left(-\\frac{1}{2}\\right)^n & 1 - \\left(-\\frac{1}{2}\\right)^n \\\\\n1 - \\left(-\\frac{1}{2}\\right)^n & 1 - \\left(-\\frac{1}{2}\\right)^n & 1 + 2\\left(-\\frac{1}{2}\\right)^n\n\\end{pmatrix}\n$$\n当 $n \\to \\infty$ 时，项 $\\left(-\\frac{1}{2}\\right)^n \\to 0$。转移矩阵的极限是：\n$$\n\\lim_{n \\to \\infty} P^n = \\Pi_1 = \\frac{1}{3} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}\n$$\n这表明，无论初始状态如何，处于任何状态的长期概率都是 $\\frac{1}{3}$。极限矩阵的行对应于唯一的平稳分布 $\\pi = \\begin{pmatrix} \\frac{1}{3} & \\frac{1}{3} & \\frac{1}{3} \\end{pmatrix}$。对于一个不可约的有限状态链，这个极限的存在性和唯一性由 Perron-Frobenius 定理保证，该定理指出，对于这样的链，特征值 $1$ 的重数为 $1$，所有其他特征值的模都严格小于 $1$。我们的分析证实了这一点，因为 $|\\lambda_2|=|-\\frac{1}{2}|  1$。\n\n问题要求的是特定的元素 $(P^n)_{1,3}$，即在 $n$ 步内从状态 $1$ 转移到状态 $3$ 的概率。根据我们推导出的矩阵 $P^n$，该元素为：\n$$\n(P^n)_{1,3} = \\frac{1}{3} \\left(1 - \\left(-\\frac{1}{2}\\right)^n\\right)\n$$\n这就是所要求的闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{1}{3} \\left(1 - \\left(-\\frac{1}{2}\\right)^{n}\\right)}\n$$"
        },
        {
            "introduction": "理论分析与实际模拟相辅相成，是随机过程研究的两个核心方面。这个练习完美地架起了理论与应用之间的桥梁，指导你如何通过一个标准的均匀随机变量，从算法上实现一个由转移矩阵定义的离散时间马尔可夫链。掌握这种基于逆变换采样的构造方法，对于在实践中实现基于马尔可夫链的蒙特卡洛模拟至关重要。",
            "id": "3303994",
            "problem": "考虑一个状态空间为有限集 $S=\\{0,1,\\dots,m-1\\}$ 的离散时间马尔可夫链 (DTMC)，其转移矩阵为 $P=\\bigl(p_{ij}\\bigr)_{0\\leq i,j\\leq m-1}$，其中 $P$ 的每一行都是一个概率分布，即对于每个 $i\\in S$，都有 $p_{ij}\\geq 0$ 且 $\\sum_{j=0}^{m-1} p_{ij}=1$。设 $\\{U_n\\}_{n\\geq 0}$ 是独立同分布 (i.i.d.) 的随机变量序列，其中 $U_n\\sim \\mathrm{Uniform}(0,1)$ 并且与该马尔可夫链独立。请从第一性原理出发，不假设任何预先存在的构造，证明存在一个可测函数 $F:S\\times[0,1)\\to S$，使得随机递归关系 $X_{n+1}=F(X_n,U_n)$ 可以实现一个转移矩阵为 $P$ 的 DTMC，即对于所有 $i,j\\in S$，满足：\n$$\\mathbb{P}\\bigl(X_{n+1}=j\\mid X_n=i\\bigr)=p_{ij}.$$\n请利用 $P$ 的行累积和，并遵循一个能正确处理边界值和零概率的、在 $[0,1)$ 上一致的半开区间约定，来显式地构造 $F$。\n\n然后，用算法实现该构造。你的程序必须：\n- 不接受任何输入，仅使用提供的测试套件。\n- 将状态表示为 $\\{0,1,\\dots,m-1\\}$ 中的整数。\n- 预计算 $P$ 的行累积和，并通过以下规则定义 $F$：对于给定的当前状态 $i$ 和值 $u\\in[0,1)$，$F(i,u)$ 是使得 $u$ 严格小于第 $i$ 行截至索引 $j$ 的累积和的最小索引 $j$。\n- 对每个测试用例，使用给定的初始状态和确定性序列 $\\{u_k\\}$ 来模拟 DTMC，生成状态序列 $\\{X_1,\\dots,X_T\\}$，其中 $T$ 是所提供 $\\{u_k\\}$ 的长度。\n\n测试套件：\n1. 一般情况，三个状态：\n   - 转移矩阵\n     $$\n     P_1=\\begin{bmatrix}\n     0.3  0.4  0.3 \\\\\n     0.1  0.2  0.7 \\\\\n     0.0  0.5  0.5\n     \\end{bmatrix}.\n     $$\n   - 初始状态 $X_0=0$。\n   - 均匀序列 $\\{u_k\\}=\\{0.25,\\,0.65,\\,0.05,\\,0.9,\\,0.5\\}$。\n\n2. 边界处理和确定性行，两个状态：\n   - 转移矩阵\n     $$\n     P_2=\\begin{bmatrix}\n     1.0  0.0 \\\\\n     0.0  1.0\n     \\end{bmatrix}.\n     $$\n   - 初始状态 $X_0=1$。\n   - 均匀序列 $\\{u_k\\}=\\{0.0,\\,0.999999,\\,0.1\\}$。\n\n3. 混合概率、零条目和精确边界值，四个状态：\n   - 转移矩阵\n     $$\n     P_3=\\begin{bmatrix}\n     0.3  0.4  0.0  0.3 \\\\\n     0.0  0.0  1.0  0.0 \\\\\n     0.25  0.25  0.25  0.25 \\\\\n     0.5  0.5  0.0  0.0\n     \\end{bmatrix}.\n     $$\n   - 初始状态 $X_0=0$。\n   - 均匀序列 $\\{u_k\\}=\\{0.3,\\,0.7,\\,0.25,\\,0.5\\}$。\n\n输出规范：\n- 对每个测试用例，将模拟的状态序列 $\\{X_1,\\dots,X_T\\}$ 以整数列表的形式输出。\n- 你的程序应生成单行输出，包含所有结果，格式为一个由方括号列表组成的逗号分隔列表，例如 $\\bigl[[x_{1,1},\\dots,x_{1,T_1}],\\,[x_{2,1},\\dots,x_{2,T_2}],\\,[x_{3,1},\\dots,x_{3,T_3}]\\bigr]$。",
            "solution": "该问题要求从第一性原理出发，证明用于实现离散时间马尔可夫链 (DTMC) 的函数 $F$ 的存在性并进行构造，然后通过算法实现来模拟 DTMC 的样本路径。\n\n### 第 1 部分：$F$ 的存在性证明与显式构造\n\n设有限状态空间为 $S = \\{0, 1, \\dots, m-1\\}$，转移矩阵为 $P = (p_{ij})$，其中 $p_{ij} = \\mathbb{P}(X_{n+1}=j \\mid X_n=i)$。对每个状态 $i \\in S$，$P$ 的第 $i$ 行 $(p_{i0}, p_{i1}, \\dots, p_{i,m-1})$ 是一个离散概率分布，因为对所有 $j \\in S$ 都有 $p_{ij} \\geq 0$，且 $\\sum_{j=0}^{m-1} p_{ij} = 1$。\n\n我们的目标是构造一个可测函数 $F: S \\times [0,1) \\to S$，使得由递归关系 $X_{n+1} = F(X_n, U_n)$ 定义的随机过程满足具有给定转移概率的马尔可夫性质，其中 $\\{U_n\\}_{n \\geq 0}$ 是独立同分布 (i.i.d.) 的随机变量，且 $U_n \\sim \\mathrm{Uniform}(0,1)$。\n\n所用方法是逆变换采样法的一种形式，专为离散分布定制。对于每个状态 $i \\in S$，我们定义一组累积概率。设 $c_{i,j}$ 为第 $i$ 行到状态 $j$ 为止的概率累积和：\n$$c_{i,j} = \\sum_{k=0}^{j} p_{ik} \\quad \\text{for } j \\in \\{0, 1, \\dots, m-1\\}.$$\n为方便表示，我们定义 $c_{i,-1} = 0$。这样，对于 $j \\in S$，我们有 $p_{ij} = c_{i,j} - c_{i,j-1}$。$P$ 的性质保证了对于任何固定的 $i$，序列 $(c_{i,0}, c_{i,1}, \\dots, c_{i,m-1})$ 是非递减的，以 $c_{i,0} \\geq 0$ 开始，并以 $c_{i,m-1} = 1$ 结束。\n\n这些累积概率将区间 $[0,1)$ 划分为 $m$ 个子区间：\n$$ I_{i,j} = [c_{i,j-1}, c_{i,j}) \\quad \\text{for } j \\in \\{0, 1, \\dots, m-1\\}.$$\n每个子区间 $I_{i,j}$ 的长度，记为 $\\lambda(I_{i,j})$，是：\n$$ \\lambda(I_{i,j}) = c_{i,j} - c_{i,j-1} = p_{ij}. $$\n区间集合 $\\{I_{i,j}\\}_{j=0}^{m-1}$ 构成 $[0,1)$ 的一个划分，即它们不相交且其并集为 $[0,1)$。如果 $p_{ij}=0$，则区间 $I_{i,j}$ 为空。\n\n现在，我们按照规定构造函数 $F(i,u)$。对于给定的状态 $i \\in S$ 和值 $u \\in [0,1)$，$F(i,u)$ 被定义为下一个状态 $j$。规则是，$F(i,u) = j$ 当且仅当 $u$ 落在区间 $I_{i,j}$ 内。一个等价且明确的定义，如问题中所给出的，是：\n$$ F(i, u) = \\min \\{j \\in S \\mid u  c_{i,j}\\} $$\n这个定义是良构的，因为 $u \\in [0,1)$ 且 $c_{i,m-1}=1$，所以集合 $\\{j \\in S \\mid u  c_{i,j}\\}$ 永不为空（它总包含 $m-1$）。\n\n现在我们必须从第一性原理出发，证明这个构造正确地模拟了 DTMC。我们需要证明 $\\mathbb{P}(X_{n+1} = j \\mid X_n = i) = p_{ij}$。\n根据递归定义 $X_{n+1} = F(X_n, U_n)$，我们有：\n$$ \\mathbb{P}(X_{n+1} = j \\mid X_n = i) = \\mathbb{P}(F(X_n, U_n) = j \\mid X_n = i). $$\n在事件 $X_n=i$ 的条件下，该表达式变为：\n$$ \\mathbb{P}(F(i, U_n) = j \\mid X_n = i). $$\n由于序列 $\\{U_n\\}$ 与链 $\\{X_n\\}$ 独立，事件 $X_n=i$ 不提供关于 $U_n$ 值的任何信息。因此，我们可以去掉对 $X_n=i$ 的条件：\n$$ \\mathbb{P}(X_{n+1} = j \\mid X_n = i) = \\mathbb{P}(F(i, U_n) = j). $$\n根据我们对 $F$ 的构造，事件 $F(i, U_n) = j$ 等价于事件 $U_n$ 落在特定区间 $I_{i,j}$ 内：\n$$ F(i, U_n) = j \\iff c_{i,j-1} \\le U_n  c_{i,j}. $$\n因此，概率为：\n$$ \\mathbb{P}(X_{n+1} = j \\mid X_n = i) = \\mathbb{P}(c_{i,j-1} \\le U_n  c_{i,j}). $$\n由于 $U_n$ 服从 Uniform$(0,1)$ 分布，它落在任何子区间 $[a,b) \\subseteq [0,1)$ 内的概率等于该区间的长度 $b-a$。在我们的例子中，区间 $[c_{i,j-1}, c_{i,j})$ 的长度是 $\\lambda(I_{i,j}) = c_{i,j} - c_{i,j-1} = p_{ij}$。\n$$ \\mathbb{P}(X_{n+1} = j \\mid X_n = i) = p_{ij}. $$\n这证实了随机递归关系 $X_{n+1}=F(X_n, U_n)$ 和我们构造的 $F$ 正确地实现了转移矩阵为 $P$ 的 DTMC。\n\n最后，函数 $F$ 是一个可测函数。对于任何 $j \\in S$，其原像 $F^{-1}(\\{j\\})$ 是集合 $\\bigcup_{i \\in S} (\\{i\\} \\times I_{i,j})$。每个集合 $\\{i\\}$ 在 $S$ 上的离散 $\\sigma$-代数中是可测的，每个区间 $I_{i,j}$ 是一个波莱尔集，因而在 $[0,1)$ 中是可测的。积 $\\{i\\} \\times I_{i,j}$ 是积空间 $S \\times [0,1)$ 中的一个可测矩形，而这种集合的有限并集是可测的。因此，$F$ 是一个可测函数。\n\n### 第 2 部分：算法设计\n\n这个构造性证明直接为模拟算法提供了依据。\n1.  **预处理**：对于给定的 $m \\times m$ 转移矩阵 $P$，我们首先计算累积和矩阵 $C$。元素 $C_{ij}$ 是 $P$ 的第 $i$ 行截至第 $j$ 列的累积和，即 $C_{ij} = \\sum_{k=0}^{j} P_{ik}$。这可以对所有行同时进行高效计算。\n2.  **状态转移函数**：模拟的核心是 $F(i,u)$ 的实现。给定当前状态 $i$ 和一个均匀采样的值 $u \\in [0,1)$，下一个状态 $j$ 通过应用规则 $j = \\min \\{k \\in S \\mid u  C_{ik}\\}$ 来找到。在算法上，这意味着我们在 $C$ 的第 $i$ 行中搜索第一个索引 $k$，使得其值 $C_{ik}$ 严格大于 $u$。\n3.  **模拟循环**：\n    -   初始化当前状态，$X_{current} \\leftarrow X_0$。\n    -   初始化一个空列表 `results` 来存储生成的状态序列。\n    -   对于确定性序列 $\\{u_k\\}$ 中提供的每个值 $u_k$：\n        a.  识别与当前状态相对应的累积概率行：`cum_probs = C[X_current, :]`。\n        b.  通过找到满足 $u_k  \\text{cum\\_probs}[j]$ 的最小索引 $j$ 来确定下一个状态 $X_{next}$。这可以高效实现，例如，通过找到比较 $u_k  \\text{cum\\_probs}$ 所产生的布尔数组中第一个 `True` 值的索引。\n        c.  将 $X_{next}$ 追加到 `results` 列表中。\n        d.  更新当前状态：$X_{current} \\leftarrow X_{next}$。\n4.  **输出格式化**：将所有测试用例生成的序列收集起来，并格式化为指定的单行字符串格式。\n\n该设计是已证实方法的直接转换，确保了正确性，并利用高效的数组操作来进行搜索步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DTMC simulation problem for a given set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"P\": np.array([\n                [0.3, 0.4, 0.3],\n                [0.1, 0.2, 0.7],\n                [0.0, 0.5, 0.5]\n            ]),\n            \"X0\": 0,\n            \"u_seq\": [0.25, 0.65, 0.05, 0.9, 0.5]\n        },\n        {\n            \"P\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0]\n            ]),\n            \"X0\": 1,\n            \"u_seq\": [0.0, 0.999999, 0.1]\n        },\n        {\n            \"P\": np.array([\n                [0.3, 0.4, 0.0, 0.3],\n                [0.0, 0.0, 1.0, 0.0],\n                [0.25, 0.25, 0.25, 0.25],\n                [0.5, 0.5, 0.0, 0.0]\n            ]),\n            \"X0\": 0,\n            \"u_seq\": [0.3, 0.7, 0.25, 0.5]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        P = case[\"P\"]\n        current_state = case[\"X0\"]\n        u_seq = case[\"u_seq\"]\n        \n        # Precompute row-wise cumulative sums of the transition matrix P.\n        # This creates the matrix C where C[i,j] = sum_{k=0 to j} P[i,k].\n        C = np.cumsum(P, axis=1)\n        \n        state_sequence = []\n        for u in u_seq:\n            # Get the cumulative probabilities for the current state.\n            cum_probs_row = C[current_state, :]\n            \n            # Find the next state. The rule is to find the smallest index j such that\n            # u is strictly less than the cumulative sum up to j.\n            # np.argmax(u  cum_probs_row) finds the index of the first True\n            # value, which corresponds to the smallest j satisfying the condition.\n            next_state = np.argmax(u  cum_probs_row)\n            \n            state_sequence.append(next_state)\n            current_state = next_state\n            \n        all_results.append(state_sequence)\n\n    # Format the final output string to be exactly as specified, without spaces.\n    # E.g., [[0,1,0,2,2],[1,1,1],[1,2,1,2]]\n    result_str_parts = []\n    for res_list in all_results:\n        # Format each inner list like '[0,1,2]'\n        part = '[' + ','.join(map(str, res_list)) + ']'\n        result_str_parts.append(part)\n    \n    # Join the parts and wrap in outer brackets\n    final_output_str = '[' + ','.join(result_str_parts) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}