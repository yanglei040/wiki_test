{
    "hands_on_practices": [
        {
            "introduction": "The journey from a mathematical recurrence to a stream of high-quality random numbers involves two crucial steps: implementation and validation. This first practice focuses on these fundamentals by guiding you through the implementation of a subtractive Lagged Fibonacci Generator (LFG), a significant step up from simpler methods. You will compare its performance against a standard Linear Congruential Generator (LCG) by applying a suite of statistical tests , providing direct, hands-on experience in the empirical evaluation of pseudorandomness.",
            "id": "2408853",
            "problem": "You are to implement and compare two pseudo-random number generators that are widely discussed in computational physics: a standard linear congruential generator (LCG) and a subtractive generator (a specific case of a lagged Fibonacci generator). Your task is to design a program that generates sequences from both generators under specified parameter sets, evaluates basic statistical properties of the generated sequences, and reports which generator performs better under each test case with respect to the chosen metrics.\n\nBegin from the following fundamental bases:\n\n1. The definition of congruence modulo: integers $a$ and $b$ are congruent modulo $m$ if and only if $m$ divides $a-b$, denoted $a \\equiv b \\pmod m$. Arithmetic operations in the recurrence relations below are to be interpreted modulo $m$.\n2. The concept of a pseudo-random number generator as a deterministic recurrence producing integers $X_n$ which are normalized to real values $U_n = X_n/m$ intended to approximate independent draws from the continuous uniform distribution on $[0,1)$.\n3. The standard empirical statistics for a sequence $\\{U_n\\}_{n=1}^N$: \n   - empirical mean $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$,\n   - empirical variance $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$,\n   - lag-$1$ empirical autocorrelation coefficient $r_1$ computed from the covariance of $(U_n,U_{n+1})$ divided by $v$,\n   - a simple chi-square uniformity statistic using $K$ equally spaced bins on $[0,1)$ with observed counts $\\{O_k\\}_{k=1}^K$ and expected count $E = N/K$, defined as $\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$. The continuous uniform distribution on $[0,1)$ has theoretical mean $1/2$ and variance $1/12$.\n\nImplement the following, strictly from these definitions:\n\nA. Linear congruential generator (LCG). Generate a sequence $\\{X_n\\}$ by the recurrence\n$$X_{n+1} \\equiv a X_n + c \\pmod m,$$\nwith given integers $m \\ge 2$, $0 \\le a < m$, $0 \\le c < m$, and initial $X_0$. Convert to $U_n = X_n/m$.\n\nB. Subtractive generator (lagged Fibonacci type). Maintain a state vector of length $L = \\max\\{i,j\\}$ with elements in $\\{0,1,\\dots,m-1\\}$, and generate\n$$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m,$$\nfor given lags $i,j$ with $1 \\le i,j \\le L$ and $i \\ne j$. Convert to $U_n = X_n/m$. Initialize the state deterministically using the following rule: given a seed $s_0$, define $V_0 \\equiv s_0 \\pmod m$ and for $k=0,1,\\dots,L-1$ set\n$$V_{k+1} \\equiv a_s V_k + c_s \\pmod m,$$\nwith fixed seeding constants $a_s = 1664525$ and $c_s = 1013904223$, and take the initial state $(X_0,X_1,\\dots,X_{L-1}) = (V_1,V_2,\\dots,V_L)$.\n\nFor each generator and parameter set below, do the following procedural steps:\n\n1. Discard the first $W$ outputs (warm-up) to mitigate initialization bias.\n2. Then generate $N$ values $U_n$ in $[0,1)$.\n3. Compute the four metrics: absolute mean error $|\\mu - 1/2|$, absolute variance error $|v - 1/12|$, absolute lag-$1$ autocorrelation $|r_1|$, and the chi-square statistic $\\chi^2$ with $K$ equally spaced bins.\n\nCompare the two generators by declaring the subtractive generator to be better on a metric if and only if its value for that metric is strictly smaller than the corresponding value for the LCG (for $\\chi^2$, smaller indicates closer to uniformity in this test). No other thresholds are to be used.\n\nUse these fixed evaluation parameters for all test cases: warm-up $W=1000$, sequence length $N=50000$, and number of bins $K=10$.\n\nTest suite (three cases), each specifying $m$, the LCG parameters $(a,c,X_0)$, and the subtractive parameters $(i,j,s_0)$:\n\n- Case $1$ (large prime-like modulus, widely used LCG and well-spaced lags):\n  - $m = 2147483647$, LCG $(a,c,X_0) = (16807,0,12345)$, subtractive $(i,j,s_0) = (24,55,67890)$.\n- Case $2$ (small modulus, poor LCG and small lags stressing edge behavior):\n  - $m = 65536$, LCG $(a,c,X_0) = (5,1,7)$, subtractive $(i,j,s_0) = (1,2,11)$.\n- Case $3$ (power-of-two modulus with commonly used LCG parameters and well-spaced lags):\n  - $m = 4294967296$, LCG $(a,c,X_0) = (1664525,1013904223,42)$, subtractive $(i,j,s_0) = (24,55,13579)$.\n\nFinal output specification:\n\n- For each case, compute four booleans indicating whether the subtractive generator is better than the LCG on, respectively, absolute mean error, absolute variance error, absolute lag-$1$ autocorrelation, and chi-square statistic.\n- Aggregate the booleans for all cases into a single flat list of length $12$ in the order: Case $1$ mean, Case $1$ variance, Case $1$ autocorrelation, Case $1$ chi-square, Case $2$ mean, Case $2$ variance, Case $2$ autocorrelation, Case $2$ chi-square, Case $3$ mean, Case $3$ variance, Case $3$ autocorrelation, Case $3$ chi-square.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, for example, \"[True,False,True,...]\".\n\nNo physical units or angles are involved in this task. All results are unitless real-valued computations reduced to boolean comparisons as specified. The program must be fully deterministic and self-contained, using only the specified libraries, and must not read any input.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, and provides a complete and unambiguous specification for implementation and evaluation. It is a standard exercise in computational physics concerning the properties of pseudo-random number generators.\n\nThe task is to implement and compare a Linear Congruential Generator (LCG) and a Subtractive Generator. For three distinct parameter sets, sequences of random numbers are generated, evaluated against four statistical metrics, and a comparison is made to determine which generator performs better on each metric. The solution is thus constructed by first implementing the generators and statistical tests, then executing the specified procedure for all test cases.\n\n**Generator Implementation**\n\n1.  **Linear Congruential Generator (LCG)**: This generator produces a sequence of integers $\\{X_n\\}$ via the recurrence relation:\n    $$X_{n+1} \\equiv a X_n + c \\pmod m$$\n    where $m$ is the modulus, $a$ is the multiplier, $c$ is the increment, and $X_0$ is the initial seed. The implementation involves a loop that iteratively applies this formula. Given an initial state $X_0$, the first $W$ values are generated and discarded for warm-up. Subsequently, $N$ values are generated and stored. Each integer $X_n$ is normalized to a real number $U_n \\in [0, 1)$ by the transformation $U_n = X_n / m$.\n\n2.  **Subtractive Generator**: This generator, a form of a lagged Fibonacci generator, produces a sequence $\\{X_n\\}$ using the recurrence:\n    $$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m$$\n    where $i$ and $j$ are the lags. This requires maintaining a state of the previous $L = \\max\\{i, j\\}$ values. The implementation uses a circular buffer (a deque of fixed size $L$) to efficiently manage this state.\n    \n    The initial state $(X_0, X_1, \\dots, X_{L-1})$ is itself generated deterministically using an auxiliary LCG. Starting with a seed $s_0$, we define $V_0 \\equiv s_0 \\pmod m$. Then, for $k=0, 1, \\dots, L-1$, we compute:\n    $$V_{k+1} \\equiv a_s V_k + c_s \\pmod m$$\n    with fixed seeding constants $a_s = 1664525$ and $c_s = 1013904223$. The initial state for the subtractive generator is set to $(X_0, \\dots, X_{L-1}) = (V_1, \\dots, V_L)$.\n    \n    The generation process begins by populating the circular buffer with this initial state. The warm-up and generation loops then proceed. In each step, the new value $X_n$ is computed from the elements at positions corresponding to lags $i$ and $j$ in the buffer. The result of the subtraction $X_{n-i} - X_{n-j}$ can be negative; the modulo operation $x \\pmod m$ is defined consistent with number theory, mapping any integer $x$ to the unique remainder in the set $\\{0, 1, \\dots, m-1\\}$. The newly generated value replaces the oldest value in the circular buffer. As with the LCG, the generated integers are normalized to $U_n = X_n / m$.\n\n**Statistical Evaluation**\n\nFor each generated sequence $\\{U_n\\}_{n=1}^N$ of length $N = 50000$, four performance metrics are computed. These metrics quantify the deviation of the sequence from the properties of a true uniform distribution on $[0,1)$, which has a theoretical mean of $1/2$ and variance of $1/12$. The computations are performed using the `numpy` library for efficiency.\n\n1.  **Absolute Mean Error**: The empirical mean is $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$. The metric is $|\\mu - 1/2|$.\n2.  **Absolute Variance Error**: The empirical variance is $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$. The metric is $|v - 1/12|$.\n3.  **Absolute Lag-1 Autocorrelation**: The lag-$1$ autocorrelation coefficient $r_1$ measures the correlation between successive values. It is computed as:\n    $$r_1 = \\frac{\\sum_{n=1}^{N-1} (U_n - \\mu)(U_{n+1} - \\mu)}{\\sum_{n=1}^N (U_n - \\mu)^2}$$\n    The metric is the absolute value, $|r_1|$.\n4.  **Chi-Square Uniformity Statistic**: This statistic tests the goodness-of-fit to a uniform distribution. The interval $[0,1)$ is divided into $K=10$ equal bins. The number of values $O_k$ falling into each bin $k$ is counted. The expected count for each bin is $E = N/K$. The statistic is calculated as:\n    $$\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$$\n    A smaller $\\chi^2$ value suggests a better fit to the uniform distribution.\n\n**Procedural Logic**\n\nFor each of the three test cases, the following procedure is executed:\n1.  Both the LCG and the Subtractive Generator are initialized with the specified parameters for the case.\n2.  Each generator discards $W = 1000$ warm-up values.\n3.  Each generator then produces a sequence of $N = 50000$ values.\n4.  The four statistical metrics are computed for both sequences.\n5.  A comparison is made for each metric: the subtractive generator is deemed 'better' if and only if its metric value is strictly smaller than the LCG's corresponding metric value. This yields four boolean results per test case.\n6.  The boolean results from all three cases are aggregated into a single list of $12$ values in the specified order and formatted for the final output. The entire process is deterministic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef calculate_metrics(sequence, m, N, K):\n    \"\"\"\n    Calculates the four statistical metrics for a given sequence of random numbers.\n    \n    Args:\n        sequence (list): A list of integers X_n generated by a PRNG.\n        m (int): The modulus used for normalization.\n        N (int): The length of the sequence.\n        K (int): The number of bins for the chi-square test.\n\n    Returns:\n        dict: A dictionary containing the four computed metric values.\n    \"\"\"\n    # Normalize sequence to [0, 1)\n    U = np.array(sequence, dtype=np.float64) / m\n\n    # 1. Mean\n    mu = np.mean(U)\n    mean_err = abs(mu - 0.5)\n\n    # 2. Variance\n    v = np.var(U)  # numpy.var uses N in denominator by default (ddof=0)\n    var_err = abs(v - 1.0/12.0)\n\n    # 3. Lag-1 Autocorrelation\n    # r_1 = sum{(U_n - mu)(U_{n+1} - mu)} / sum{(U_n - mu)^2}\n    numerator = np.sum((U[:-1] - mu) * (U[1:] - mu))\n    denominator = N * v\n    r1 = numerator / denominator if denominator != 0 else 0.0\n    abs_r1 = abs(r1)\n\n    # 4. Chi-Square Statistic\n    expected_count = N / K\n    observed_counts, _ = np.histogram(U, bins=K, range=(0.0, 1.0))\n    chi2 = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    return {\n        'mean_err': mean_err,\n        'var_err': var_err,\n        'abs_r1': abs_r1,\n        'chi2': chi2,\n    }\n\ndef generate_lcg_sequence(m, a, c, x0, N, W):\n    \"\"\"Generates a sequence using the Linear Congruential Generator.\"\"\"\n    sequence = []\n    x = x0\n    # Warm-up phase\n    for _ in range(W):\n        x = (a * x + c) % m\n    # Generation phase\n    for _ in range(N):\n        x = (a * x + c) % m\n        sequence.append(x)\n    return sequence\n\ndef generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W):\n    \"\"\"Generates a sequence using the Subtractive Generator.\"\"\"\n    L = max(i, j)\n    \n    # Initialize state vector V\n    V = [0] * (L + 1)\n    V[0] = s0 % m\n    for k in range(L):\n        V[k+1] = (a_s * V[k] + c_s) % m\n        \n    # Initial state buffer for the generator\n    state_buffer = deque(V[1:], maxlen=L)\n    \n    # Warm-up phase\n    for _ in range(W):\n        # NOTE: Python's % operator handles negative results correctly for modulo arithmetic.\n        # x % m gives a result in [0, m-1] for positive m.\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n\n    # Generation phase\n    sequence = []\n    for _ in range(N):\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n        sequence.append(new_x)\n        \n    return sequence\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation, evaluate generators, and print results.\n    \"\"\"\n    \n    # Define fixed evaluation parameters from the problem statement.\n    W = 1000\n    N = 50000\n    K = 10\n    a_s = 1664525\n    c_s = 1013904223\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"m\": 2147483647,\n            \"lcg_params\": (16807, 0, 12345),\n            \"sub_params\": (24, 55, 67890)\n        },\n        # Case 2\n        {\n            \"m\": 65536,\n            \"lcg_params\": (5, 1, 7),\n            \"sub_params\": (1, 2, 11)\n        },\n        # Case 3\n        {\n            \"m\": 4294967296,\n            \"lcg_params\": (1664525, 1013904223, 42),\n            \"sub_params\": (24, 55, 13579)\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        a, c, x0 = case[\"lcg_params\"]\n        i, j, s0 = case[\"sub_params\"]\n\n        # 1. Generate LCG sequence and compute its metrics\n        lcg_sequence = generate_lcg_sequence(m, a, c, x0, N, W)\n        lcg_metrics = calculate_metrics(lcg_sequence, m, N, K)\n        \n        # 2. Generate Subtractive sequence and compute its metrics\n        sub_sequence = generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W)\n        sub_metrics = calculate_metrics(sub_sequence, m, N, K)\n        \n        # 3. Compare metrics and store boolean results\n        # The subtractive generator is better if its metric value is strictly smaller.\n        is_sub_better_mean = sub_metrics['mean_err'] < lcg_metrics['mean_err']\n        is_sub_better_var = sub_metrics['var_err'] < lcg_metrics['var_err']\n        is_sub_better_corr = sub_metrics['abs_r1'] < lcg_metrics['abs_r1']\n        is_sub_better_chi2 = sub_metrics['chi2'] < lcg_metrics['chi2']\n        \n        all_results.extend([\n            is_sub_better_mean,\n            is_sub_better_var,\n            is_sub_better_corr,\n            is_sub_better_chi2\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While empirical tests provide evidence of a generator's quality, theoretical guarantees offer deeper confidence, especially concerning the period length. This practice delves into the number theory that underpins high-quality Lagged Fibonacci Generators, revealing the connection between the generator's recurrence and its characteristic polynomial over the finite field $\\mathrm{GF}(2)$. By implementing advanced algorithms to test for primitivity , you will learn how to verify that the chosen lags yield the maximal possible period, a critical step in designing robust generators.",
            "id": "3316679",
            "problem": "Consider an additive Lagged Fibonacci Generator (LFG) defined over the ring of integers modulo $m$ by the linear recurrence $x_{n} \\equiv x_{n-j} + x_{n-k} \\pmod{m}$ with lags $(j,k)$ and modulus $m$. The behavior of the least significant bit (that is, the sequence reduced modulo $2$) is governed by a linear recurrence over the Galois Field of two elements $\\mathrm{GF}(2)$ whose characteristic polynomial takes the form $f(x) = x^{k} + x^{j} + 1$. The period of the binary sequence generated by the least significant bit equals the multiplicative order of the residue class of $x$ in the finite field extension defined by $f(x)$ when $f(x)$ is irreducible, and otherwise is constrained by the decomposition of $f(x)$ over $\\mathrm{GF}(2)$.\n\nStarting from the following core facts:\n- The finite field $\\mathrm{GF}(2)$ is the field with two elements where addition and subtraction coincide, and polynomial arithmetic over $\\mathrm{GF}(2)$ is performed coefficient-wise modulo $2$.\n- For a monic polynomial $f(x) \\in \\mathrm{GF}(2)[x]$ of degree $n$, the polynomial is irreducible over $\\mathrm{GF}(2)$ if and only if $x^{2^{n}} \\equiv x \\pmod{f(x)}$ and for every prime divisor $p$ of $n$, $\\gcd\\!\\left(x^{2^{n/p}} - x, f(x)\\right) = 1$ (Rabin’s irreducibility test).\n- If $f(x)$ is irreducible of degree $n$, then $\\mathrm{GF}(2)[x]/\\langle f(x)\\rangle$ is a finite field of size $2^{n}$ whose multiplicative group of nonzero elements has order $2^{n} - 1$. In that group, the residue class of $x$ has multiplicative order dividing $2^{n} - 1$ and is primitive if and only if its order equals $2^{n} - 1$. A necessary and sufficient computational criterion is: for each prime $q$ dividing $2^{n} - 1$, one must have $x^{(2^{n}-1)/q} \\not\\equiv 1 \\pmod{f(x)}$.\n- For an additive LFG modulo $m = 2^{w}$, the least significant bit sequence period equals the multiplicative order of the residue class of $x$ modulo $f(x)$ in the field $\\mathrm{GF}(2^n)$ when $f(x)$ is irreducible, and cannot exceed $2^{n} - 1$ for that bit. In practice, primitivity of $f(x)$ ensures that the least significant bit achieves the maximal period $2^{n} - 1$, which strongly influences the achievable period and equidistribution properties of the full-word generator modulo $2^{w}$.\n\nYour task is to write a complete program that:\n1. Implements polynomial arithmetic over $\\mathrm{GF}(2)$ using integers as bitsets (the coefficient of $x^{i}$ is the $i$th bit).\n2. Uses Rabin’s test to verify irreducibility of a given characteristic polynomial $f(x)$.\n3. Factors the integer $2^{n} - 1$ using an algorithm suitable for $64$-bit integers (for example, a deterministic Miller–Rabin primality test combined with Pollard’s Rho factorization) to obtain its prime divisors.\n4. Tests primitivity by checking that the multiplicative order of the residue class of $x$ modulo $f(x)$ is $2^{n} - 1$.\n5. If $f(x)$ is irreducible, computes the exact multiplicative order of the residue class of $x$ modulo $f(x)$ by successively stripping prime factors from $2^{n} - 1$.\n\nYou must apply your program to the following test suite of parameter sets:\n- Case A (happy path): lags $(24,55)$, modulus $m = 2^{32}$, polynomial $f(x) = x^{55} + x^{24} + 1$, degree $n = 55$.\n- Case B (edge case: obvious reducibility): lags $(24,55)$, modulus $m = 2^{32}$, polynomial $f(x) = x^{55} + x^{24} + x + 1$, degree $n = 55$.\n- Case C (boundary case: small degree sanity check): lags $(2,5)$, modulus $m = 2^{8}$, polynomial $f(x) = x^{5} + x^{2} + 1$, degree $n = 5$.\n\nFor each case, output a list of three values:\n- A boolean indicating whether $f(x)$ is irreducible over $\\mathrm{GF}(2)$.\n- A boolean indicating whether $f(x)$ is primitive over $\\mathrm{GF}(2)$ (only meaningful if irreducible; if not irreducible, this must be reported as false).\n- An integer giving the multiplicative order of the residue class of $x$ modulo $f(x)$ if $f(x)$ is irreducible, and $0$ otherwise.\n\nYour program should produce a single line of output containing the results for all three cases as a comma-separated list of lists in the format $[ [b_{A},p_{A},o_{A}], [b_{B},p_{B},o_{B}], [b_{C},p_{C},o_{C}] ]$, where $b$ denotes irreducibility, $p$ denotes primitivity, and $o$ denotes the multiplicative order. No physical units are involved. Angles are not involved. Percentages are not involved. The program must run without any user input and must not access external files or networks.",
            "solution": "The problem requires an analysis of specific trinomials and a quadrinomial over the Galois Field of two elements, $\\mathrm{GF}(2)$, to determine their properties related to their use in Lagged Fibonacci Generators (LFGs). The core task is to determine if each given polynomial $f(x)$ is irreducible and, if so, whether it is primitive, and to compute the multiplicative order of the residue class of $x$ modulo $f(x)$. This analysis hinges on implementing algorithms for polynomial arithmetic over $\\mathrm{GF}(2)$ and integer factorization.\n\nThe overall methodology comprises three main components:\n1.  **Polynomial Arithmetic over $\\mathrm{GF}(2)$**: Implementation of fundamental operations for polynomials whose coefficients are in $\\{0, 1\\}$.\n2.  **Integer Factorization**: An algorithm to find the prime factors of large integers of the form $2^n - 1$.\n3.  **Analysis Protocol**: A step-by-step procedure using the tools from (1) and (2) to test for irreducibility and primitivity, and to compute the order.\n\n### 1. Polynomial Arithmetic over $\\mathrm{GF}(2)$\n\nA polynomial $f(x) = c_{k}x^k + \\dots + c_1x + c_0$ with coefficients $c_i \\in \\{0, 1\\}$ can be efficiently represented by an integer, where the $i$-th bit of the integer corresponds to the coefficient $c_i$. For example, $f(x) = x^5 + x^2 + 1$ is represented by the binary string `100101`, which is the integer $2^5 + 2^2 + 2^0 = 32 + 4 + 1 = 37$.\n\nWith this representation, the required arithmetic operations are defined as follows:\n\n*   **Addition and Subtraction**: In $\\mathrm{GF}(2)$, addition and subtraction are identical. For two polynomials $f(x)$ and $g(x)$, their sum $f(x) + g(x)$ corresponds to the bitwise XOR of their integer representations.\n*   **Multiplication**: The product of two polynomials $f(x)$ and $g(x)$ corresponds to carry-less multiplication of their integer representations. This can be implemented by iterating through the bits of one operand and, for each set bit, XORing a shifted version of the other operand into an accumulator.\n*   **Modular Reduction**: The remainder of $a(x)$ divided by $f(x)$, denoted $a(x) \\pmod{f(x)}$, is computed using an algorithm analogous to long division for integers. The divisor $f(x)$ is repeatedly shifted and XORed with the dividend $a(x)$ to cancel out the highest-degree term until the degree of the remainder is less than the degree of $f(x)$.\n*   **Modular Exponentiation**: To compute $g(x)^e \\pmod{f(x)}$ for a very large exponent $e$, the standard square-and-multiply algorithm (also known as binary exponentiation) is used. This reduces the problem to a sequence of polynomial squarings and multiplications, all performed modulo $f(x)$. This is crucial for handling exponents on the order of $2^n$.\n*   **Greatest Common Divisor (GCD)**: The GCD of two polynomials, $\\gcd(a(x), b(x))$, is found using the Euclidean algorithm, where the division-with-remainder step is replaced by the polynomial modular reduction described above. The algorithm terminates when the remainder is $0$; the last non-zero remainder is the GCD.\n\n### 2. Integer Factorization\n\nTo test for primitivity and compute the multiplicative order, it is necessary to find the prime factors of $M = 2^n - 1$. For the given values of $n$ (up to $55$), $M$ can be a large integer (up to $55$ bits), requiring a sophisticated factorization strategy. The chosen method is a hybrid approach:\n\n1.  **Trial Division**: Small prime factors are efficiently found by trial division up to a reasonable bound (e.g., $1000$).\n2.  **Primality Testing**: For any remaining factor $N$, its primality is determined using a deterministic Miller-Rabin test. For numbers up to $2^{64}$, a fixed set of bases (witnesses) is sufficient to prove primality deterministically.\n3.  **Pollard's Rho Algorithm**: If a number $N$ is found to be composite by the Miller-Rabin test, a non-trivial factor is found using Pollard's Rho algorithm. This is a probabilistic algorithm effective for numbers of this magnitude. Once a factor $d$ is found, the problem is recursively applied to $d$ and $N/d$.\n\nThis combination provides a robust method for factoring the numbers $2^n - 1$ required by the problem.\n\n### 3. The Analysis Protocol\n\nFor a given polynomial $f(x)$ of degree $n$, the analysis proceeds as follows:\n\n**Step A: Test for Irreducibility using Rabin’s Test**\nA monic polynomial $f(x)$ of degree $n$ is irreducible over $\\mathrm{GF}(2)$ if and only if two conditions are met:\n1.  $x^{2^n} \\equiv x \\pmod{f(x)}$. This is checked using modular exponentiation.\n2.  For every prime divisor $p$ of the degree $n$, $\\gcd(x^{2^{n/p}} - x, f(x)) = 1$. The prime factors of $n$ are found, and for each factor $p$, the exponent $d = n/p$ is computed. Then, $g(x) = x^{2^d} - x \\pmod{f(x)}$ is calculated (which is $x^{2^d} + x \\pmod{f(x)}$ in $\\mathrm{GF}(2)$), followed by $\\gcd(g(x), f(x))$. If this GCD is not $1$ for any $p$, $f(x)$ is reducible.\n\nIf $f(x)$ fails this test, it is reducible, and the result is `[False, False, 0]`.\n\n**Step B: Test for Primitivity and Compute Order**\nIf $f(x)$ is irreducible, it generates the finite field $\\mathrm{GF}(2^n) = \\mathrm{GF}(2)[x]/\\langle f(x)\\rangle$. The multiplicative group of this field has order $M = 2^n - 1$. The multiplicative order of the residue class of $x$ must be a divisor of $M$.\n*   **Primitivity**: The polynomial $f(x)$ is primitive if the order of $x$ is exactly $M$. This is the maximum possible order.\n*   **Order Calculation**: To find the exact order, we start with a candidate order equal to $M$. We then use the prime factorization of $M = q_1^{a_1} q_2^{a_2} \\dots q_k^{a_k}$. For each distinct prime factor $q_i$, we check if the order is divisible by $q_i$. We test if $x^{\\text{order}/q_i} \\equiv 1 \\pmod{f(x)}$. If it is, we update the order by dividing it by $q_i$ and repeat the check with the same prime $q_i$. This process continues until $x^{\\text{order}/q_i} \\not\\equiv 1 \\pmod{f(x)}$. After checking all prime factors $q_i$, the final value of the order is the true multiplicative order of $x$.\n\nThe boolean for primitivity is true if and only if the computed order equals $2^n - 1$.\n\n**Application to Test Cases**\n\n*   **Case A ($f(x) = x^{55} + x^{24} + 1$, $n=55$):** The degree $n=55$ has prime factors $5$ and $11$. Rabin's test is applied. Upon confirmation of irreducibility, the number $M = 2^{55}-1$ is factored. Primitivity is then checked by verifying that $x^{M/q} \\not\\equiv 1 \\pmod{f(x)}$ for all prime factors $q$ of $M$. This polynomial is known to be primitive.\n*   **Case B ($f(x) = x^{55} + x^{24} + x + 1$, $n=55$):** This polynomial has four terms (an even number). Over $\\mathrm{GF}(2)$, any polynomial with an even number of terms has $x=1$ as a root, since $f(1) = 1+1+\\dots+1 = 0$. Therefore, $f(x)$ is divisible by $x+1$ and is reducible. The analysis will immediately return `[False, False, 0]`.\n*   **Case C ($f(x) = x^5 + x^2 + 1$, $n=5$):** The degree $n=5$ is prime. Rabin's test simplifies to checking $x^{2^5} \\equiv x \\pmod{f(x)}$ and $\\gcd(x^2-x, f(x))=1$. As $f(0)\\neq 0$ and $f(1)\\neq 0$, the gcd condition holds. The polynomial is found to be irreducible. The order of the multiplicative group is $2^5 - 1 = 31$, which is a prime number. Since the order of $x$ must divide $31$ and is not $1$, it must be $31$. Therefore, the polynomial is primitive.\n\nThis structured, principle-based approach ensures a correct and verifiable analysis for each case as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Per problem spec, though not used in the logic.\nimport math\n\n# PART 1: Polynomial Arithmetic over GF(2)\n# Polynomials are represented as integers (bitsets).\n\ndef poly_mul_gf2(p1, p2):\n    \"\"\"Carry-less multiplication of two integers (polynomials over GF(2)).\"\"\"\n    res = 0\n    while p2 > 0:\n        if p2 & 1:\n            res ^= p1\n        p1 <<= 1\n        p2 >>= 1\n    return res\n\ndef poly_mod_gf2(num, mod):\n    \"\"\"Modular reduction for polynomials over GF(2).\"\"\"\n    if mod == 0:\n        raise ZeroDivisionError(\"Polynomial division by zero\")\n    deg_mod = mod.bit_length() - 1\n    while num.bit_length() - 1 >= deg_mod:\n        shift = num.bit_length() - mod.bit_length()\n        num ^= (mod << shift)\n    return num\n\ndef poly_mod_pow_gf2(base, exp, mod):\n    \"\"\"Modular exponentiation for polynomials over GF(2).\"\"\"\n    res = 1\n    base = poly_mod_gf2(base, mod)\n    \n    # Efficient handling of exp = 2**k\n    if exp & (exp - 1) == 0 and exp > 0:\n        k = exp.bit_length() - 1\n        for _ in range(k):\n            base = poly_mod_gf2(poly_mul_gf2(base, base), mod)\n        return base\n        \n    while exp > 0:\n        if exp & 1:\n            res = poly_mul_gf2(res, base)\n            res = poly_mod_gf2(res, mod)\n        base = poly_mul_gf2(base, base)\n        base = poly_mod_gf2(base, mod)\n        exp >>= 1\n    return res\n\ndef poly_gcd_gf2(a, b):\n    \"\"\"Euclidean algorithm for GCD of polynomials over GF(2).\"\"\"\n    while b:\n        a, b = b, poly_mod_gf2(a, b)\n    return a\n\n# PART 2: Integer Factorization\n\ndef is_prime(n):\n    \"\"\"Deterministic Miller-Rabin primality test for n < 2^64.\"\"\"\n    if n < 2: return False\n    if n in (2, 3): return True\n    if n % 2 == 0 or n % 3 == 0: return False\n    if n < 25: return True\n    \n    d, s = n - 1, 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n        \n    # Witnesses for n < 2^64\n    witnesses = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n    \n    for a in witnesses:\n        if a >= n: break\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\ndef pollard_rho(n):\n    \"\"\"Pollard's Rho algorithm to find a non-trivial factor.\"\"\"\n    if n % 2 == 0: return 2\n    \n    x = 2\n    c = 1\n    while True:\n        y = x\n        for _ in range(1 << c.bit_length()):\n            x = (pow(x, 2, n) + 1) % n\n            factor = math.gcd(abs(x - y), n)\n            if factor > 1:\n                return factor\n        c += 1\n\n\ndef get_prime_factors(n):\n    \"\"\"Factorizes an integer n and returns a set of unique prime factors.\"\"\"\n    factors = set()\n    \n    # Trial division for small primes\n    for p in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]:\n        if p * p > n:\n            break\n        if n % p == 0:\n            factors.add(p)\n            while n % p == 0:\n                n //= p\n    \n    if n == 1:\n        return factors\n    \n    # Use Pollard's Rho for remaining number\n    num_stack = [n]\n    while num_stack:\n        current_n = num_stack.pop()\n        if current_n == 1:\n            continue\n        if is_prime(current_n):\n            factors.add(current_n)\n            continue\n        factor = pollard_rho(current_n)\n        while factor == current_n: # Retry if it fails\n             factor = pollard_rho(current_n)\n        num_stack.append(factor)\n        num_stack.append(current_n // factor)\n        \n    return factors\n\n# PART 3: Analysis Protocol\n\ndef analyze_polynomial(poly_int, n):\n    \"\"\"\n    Analyzes a polynomial f(x) of degree n for irreducibility and primitivity.\n    Returns [is_irreducible, is_primitive, order].\n    \"\"\"\n    # 0. Quick check for reducibility: even number of terms means (x+1) is a factor.\n    if bin(poly_int).count('1') % 2 == 0:\n        return [False, False, 0]\n\n    # 1. Rabin's Irreducibility Test\n    # Condition 1: x^(2^n) = x (mod f(x))\n    x_poly = 2\n    res = poly_mod_pow_gf2(x_poly, 2**n, poly_int)\n    if res != x_poly:\n        return [False, False, 0]\n\n    # Condition 2: gcd(x^(2^(n/p)) - x, f(x)) = 1 for all prime factors p of n\n    n_factors = get_prime_factors(n)\n    for p in n_factors:\n        d = n // p\n        exp = 2**d\n        term = poly_mod_pow_gf2(x_poly, exp, poly_int)\n        term_minus_x = term ^ x_poly\n        \n        if poly_gcd_gf2(term_minus_x, poly_int) != 1:\n            return [False, False, 0]\n\n    is_irreducible = True\n\n    # 2. Primitivity Test and Order Calculation\n    m = (1 << n) - 1\n    if m == 0: # n=0 case\n        return [is_irreducible, True, 0] # or 1 based on convention\n    \n    m_factors = get_prime_factors(m)\n    order = m\n\n    for q in m_factors:\n        # Repeatedly divide order by q as long as x^(order/q) == 1\n        test_order = order // q\n        while poly_mod_pow_gf2(x_poly, test_order, poly_int) == 1:\n            order = test_order\n            if order % q != 0:\n                break\n            test_order = order // q\n            \n    is_primitive = (order == m)\n    \n    return [is_irreducible, is_primitive, order]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Polynomials f(x) are represented by integers (bitsets).\n    # f(x) = x^k + ... + 1 is (1 << k) | ... | 1\n    test_cases = [\n        # Case A: f(x) = x^55 + x^24 + 1, n = 55\n        {'poly_int': (1 << 55) | (1 << 24) | 1, 'n': 55},\n        # Case B: f(x) = x^55 + x^24 + x + 1, n = 55\n        {'poly_int': (1 << 55) | (1 << 24) | (1 << 1) | 1, 'n': 55},\n        # Case C: f(x) = x^5 + x^2 + 1, n = 5\n        {'poly_int': (1 << 5) | (1 << 2) | 1, 'n': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_polynomial(case['poly_int'], case['n'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nsolve()\n```"
        },
        {
            "introduction": "A long period does not preclude a generator from having other structural flaws. This final exercise is a powerful analytical demonstration that even seemingly random sequences can contain hidden deterministic patterns. You will use first-principles reasoning to expose the rigid lattice structure inherent in additive LFGs , showing how the generator's output is constrained to a small number of hyperplanes and calculating the exact bias this introduces, a lesson in why no generator should be trusted without rigorous scrutiny.",
            "id": "3316692",
            "problem": "Consider a Lagged Fibonacci Generator (LFG) defined over the modulus $2^{w}$ by the additive recurrence\n$$\nX_n \\equiv (X_{n-j} + X_{n-k}) \\pmod{2^w}\n$$\nwith fixed lags $j>k\\geq 1$, integer word size $w\\geq 2$, and normalized outputs $U_n = X_n/2^w \\in [0,1)$ used in Monte Carlo (MC) simulation. Work under the usual stochastic simulation convention that an ideal random number source would provide independent and identically distributed (i.i.d.) samples uniformly distributed on $[0,1)$ in every dimension.\n\nStarting from the recurrence and the definition of the modulo operation, use first-principles reasoning in modular arithmetic to identify the deterministic geometric constraint satisfied by the triples $(U_{n},U_{n-j},U_{n-k})$ generated by the LFG. Then, construct a three-dimensional lattice test function $f(U_{n},U_{n-j},U_{n-k})$ that is sensitive to this constraint and produces a deterministic bias when evaluated on the LFG outputs, while having zero expectation under the i.i.d. uniform model.\n\nFor concreteness and to ensure a uniquely defined quantity, take your lattice test function to be the nontrivial Fourier character\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big),\n$$\nwhere $i$ denotes the imaginary unit. Define the bias $B$ to be the difference between the expectation of $f$ under the LFG and its expectation under three i.i.d. $\\mathrm{Uniform}(0,1)$ variables:\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big].\n$$\n\nDerive $B$ exactly from the recurrence and modular arithmetic alone, and explain the mechanism that causes the deterministic bias. Your final answer must be the exact value of $B$. No rounding is required.",
            "solution": "The problem requires the derivation of the bias $B$ for a specific statistical test function applied to a Lagged Fibonacci Generator (LFG). The bias $B$ is defined as the difference between the expectation of the test function under the LFG's output distribution and its expectation under an ideal distribution of independent and identically distributed (i.i.d.) uniform random variables.\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big]\n$$\nwhere the test function is\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big)\n$$\nWe will compute each expectation term separately.\n\nFirst, let us calculate the expectation under the ideal stochastic model, where the generator produces i.i.d. samples from a $\\mathrm{Uniform}(0,1)$ distribution. Let $V_{1}$, $V_{2}$, and $V_{3}$ be three independent random variables, each with a $\\mathrm{Uniform}(0,1)$ distribution. The expectation $\\mathbb{E}_{\\text{iid}}[f]$ is then given by:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\Big[\\exp\\big(2\\pi i (V_{1} - V_{2} - V_{3})\\big)\\Big]\n$$\nDue to the independence of $V_{1}$, $V_{2}$, and $V_{3}$, the expectation of the product of functions of these variables is the product of their individual expectations:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\big[\\exp(2\\pi i V_{1})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{2})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{3})\\big]\n$$\nEach term in this product is an instance of the characteristic function of a $\\mathrm{Uniform}(0,1)$ variable, $\\phi_{V}(t) = \\mathbb{E}[\\exp(itV)]$, evaluated at $t = \\pm 2\\pi$. For a general non-zero integer $s$, let's compute $\\mathbb{E}[\\exp(2\\pi i s V)]$ where $V \\sim \\mathrm{Uniform}(0,1)$:\n$$\n\\mathbb{E}[\\exp(2\\pi i s V)] = \\int_{0}^{1} \\exp(2\\pi i s v) \\, dv = \\left[ \\frac{\\exp(2\\pi i s v)}{2\\pi i s} \\right]_{v=0}^{v=1}\n$$\n$$\n= \\frac{\\exp(2\\pi i s) - \\exp(0)}{2\\pi i s}\n$$\nBy Euler's identity, $\\exp(2\\pi i s) = \\cos(2\\pi s) + i\\sin(2\\pi s)$. Since $s$ is a non-zero integer, $\\cos(2\\pi s) = 1$ and $\\sin(2\\pi s) = 0$, so $\\exp(2\\pi i s) = 1$. The expression becomes:\n$$\n= \\frac{1 - 1}{2\\pi i s} = 0\n$$\nIn our case, the terms correspond to $s=1$, $s=-1$, and $s=-1$, all of which are non-zero integers. Therefore, each expectation is $0$.\n$$\n\\mathbb{E}[\\exp(2\\pi i V_{1})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{2})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{3})] = 0\n$$\nConsequently, the expectation under the i.i.d. model is:\n$$\n\\mathbb{E}_{\\text{iid}}[f] = 0 \\cdot 0 \\cdot 0 = 0\n$$\nThis result is expected, as the test function is a Fourier character designed to have zero mean for a truly uniform distribution in the unit hypercube.\n\nNext, we calculate the expectation under the LFG model. The LFG is defined by the integer recurrence:\n$$\nX_{n} = \\big(X_{n-j} + X_{n-k}\\big)\\bmod 2^{w}\n$$\nwhere each $X_{m}$ is an integer in the set $\\{0, 1, \\dots, 2^w-1\\}$. The definition of the modulo operator implies that there exists an integer, let's call it $m_{n}$, such that:\n$$\nX_{n-j} + X_{n-k} = m_{n} \\cdot 2^{w} + X_{n}\n$$\nSince $0 \\leq X_{n-j} < 2^w$ and $0 \\leq X_{n-k} < 2^w$, the sum $X_{n-j} + X_{n-k}$ satisfies $0 \\leq X_{n-j} + X_{n-k} \\leq 2(2^w-1) = 2^{w+1}-2$. The term $m_n$ accounts for the \"wrap-around\" effect of the modular arithmetic. From the equation $m_n 2^w = (X_{n-j} + X_{n-k}) - X_n$, and given the ranges of the $X$ variables, the integer $m_n$ can only take the values $0$ or $1$. Specifically, $m_n=0$ if $X_{n-j} + X_{n-k} < 2^w$ and $m_n=1$ if $X_{n-j} + X_{n-k} \\geq 2^w$.\n\nThe normalized outputs $U_n$ are defined as $U_n = X_n / 2^w$. We can translate the integer recurrence into a relation for the normalized outputs by dividing the equation by $2^w$:\n$$\n\\frac{X_{n-j}}{2^{w}} + \\frac{X_{n-k}}{2^{w}} = m_{n} \\cdot \\frac{2^{w}}{2^{w}} + \\frac{X_{n}}{2^{w}}\n$$\nSubstituting the definitions of $U_n$, this becomes:\n$$\nU_{n-j} + U_{n-k} = m_{n} + U_{n}\n$$\nThis equation reveals the deterministic geometric constraint satisfied by any triple $(U_n, U_{n-j}, U_{n-k})$ generated by the LFG. Rearranging the terms, we find:\n$$\nU_{n} - U_{n-j} - U_{n-k} = -m_{n}\n$$\nThis expression is precisely the argument of the complex exponential in the test function $f$. We can now evaluate $f$ for any output of the LFG:\n$$\nf(U_{n},U_{n-j},U_{n-k}) = \\exp\\Big(2\\pi i \\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big) = \\exp\\big(2\\pi i (-m_{n})\\big)\n$$\nSince $m_{n}$ is always an integer ($0$ or $1$), the value of $\\exp(-2\\pi i m_{n})$ is always $1$, because $\\exp(-2\\pi i \\cdot 0) = 1$ and $\\exp(-2\\pi i \\cdot 1) = 1$.\nThis means that for every triple of values generated by the LFG, the test function deterministically evaluates to exactly $1$.\n$$\nf(U_{n},U_{n-j},U_{n-k}) = 1\n$$\nThe expectation of a constant value is that constant itself. Therefore, the expectation under the LFG model is:\n$$\n\\mathbb{E}_{\\text{LFG}}[f] = \\mathbb{E}_{\\text{LFG}}[1] = 1\n$$\nThe mechanism for the bias is thus the rigid algebraic structure of the LFG. The additive recurrence over integers forces the normalized outputs to lie on a small set of parallel hyperplanes (in this case, two planes defined by $u_n-u_{n-j}-u_{n-k}=0$ and $u_n-u_{n-j}-u_{n-k}=-1$). The chosen test function, being a Fourier character corresponding to this planar structure, is maximally sensitive to this deviation from uniformity and produces a constant, non-random output.\n\nFinally, we can compute the bias $B$:\n$$\nB = \\mathbb{E}_{\\text{LFG}}[f] - \\mathbb{E}_{\\text{iid}}[f] = 1 - 0 = 1\n$$\nThe bias is $1$, which signifies a complete failure of the LFG under this test and a total breakdown of the assumption of independence and uniformity for the triples $(U_n, U_{n-j}, U_{n-k})$.",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}