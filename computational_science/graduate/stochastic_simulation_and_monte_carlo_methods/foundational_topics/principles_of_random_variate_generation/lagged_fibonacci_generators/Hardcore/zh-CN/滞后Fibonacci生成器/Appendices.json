{
    "hands_on_practices": [
        {
            "introduction": "理解任何伪随机数生成器的第一步是亲手实现它并观察其性能。这项练习将指导您实现一个基本的减法滞后斐波那契生成器，并使用标准的经验统计测试，将其质量与一个众所周知的基准——线性同余生成器（LCG）进行比较。通过这项实践，您将在算法实现和经验评估方面建立起核心技能 。",
            "id": "2408853",
            "problem": "您需要实现并比较两种在计算物理学中广泛讨论的伪随机数生成器：一种是标准的线性同余生成器 (LCG)，另一种是减法生成器（一种滞后斐波那契生成器的特例）。您的任务是设计一个程序，该程序在指定的参数集下，使用这两种生成器生成序列，评估所生成序列的基本统计特性，并根据所选指标报告在每个测试用例下哪个生成器表现更优。\n\n从以下基本概念开始：\n\n1. 模同余的定义：整数 $a$ 和 $b$ 模 $m$ 同余，当且仅当 $m$ 整除 $a-b$，记作 $a \\equiv b \\pmod m$。下文递推关系中的算术运算均应在模 $m$ 的意义下进行。\n2. 伪随机数生成器的概念：它是一个确定性递推过程，产生整数序列 $X_n$，这些整数通过 $U_n = X_n/m$ 被归一化为实数值，旨在近似模拟从 $[0,1)$ 上的连续均匀分布中进行的独立抽样。\n3. 对于序列 $\\{U_n\\}_{n=1}^N$ 的标准经验统计量：\n   - 经验均值 $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$，\n   - 经验方差 $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$，\n   - 滞后-1 经验自相关系数 $r_1$，由 $(U_n,U_{n+1})$ 的协方差除以方差 $v$ 计算得出，\n   - 一个简单的卡方均匀性统计量，它使用 $[0,1)$ 上的 $K$ 个等宽区间，观测频数为 $\\{O_k\\}_{k=1}^K$，期望频数为 $E = N/K$，定义为 $\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$。$[0,1)$ 上的连续均匀分布的理论均值为 $1/2$，理论方差为 $1/12$。\n\n严格按照这些定义实现以下内容：\n\nA. 线性同余生成器 (LCG)。通过递推关系式生成序列 $\\{X_n\\}$：\n$$X_{n+1} \\equiv a X_n + c \\pmod m,$$\n其中给定整数 $m \\ge 2$，$0 \\le a  m$，$0 \\le c  m$ 以及初始值 $X_0$。将结果转换为 $U_n = X_n/m$。\n\nB. 减法生成器（滞后斐波那契类型）。维护一个长度为 $L = \\max\\{i,j\\}$ 的状态向量，其元素在 $\\{0,1,\\dots,m-1\\}$ 范围内，并生成序列：\n$$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m,$$\n其中给定滞后量 $i,j$ 满足 $1 \\le i,j \\le L$ 且 $i \\ne j$。将结果转换为 $U_n = X_n/m$。使用以下规则确定性地初始化状态：给定一个种子 $s_0$，定义 $V_0 \\equiv s_0 \\pmod m$，然后对 $k=0,1,\\dots,L-1$ 设置：\n$$V_{k+1} \\equiv a_s V_k + c_s \\pmod m,$$\n其中使用固定的种子生成常数 $a_s = 1664525$ 和 $c_s = 1013904223$，并将初始状态设为 $(X_0,X_1,\\dots,X_{L-1}) = (V_1,V_2,\\dots,V_L)$。\n\n对于下面的每个生成器和参数集，执行以下程序步骤：\n\n1. 丢弃前 $W$ 个输出（预热阶段），以减轻初始化偏差。\n2. 然后在 $[0,1)$ 范围内生成 $N$ 个值 $U_n$。\n3. 计算四个指标：绝对均值误差 $|\\mu - 1/2|$、绝对方差误差 $|v - 1/12|$、滞后-1 自相关绝对值 $|r_1|$，以及使用 $K$ 个等宽区间的卡方统计量 $\\chi^2$。\n\n比较这两个生成器时，当且仅当减法生成器在某个指标上的值严格小于 LCG 的相应值时，才判定减法生成器在该指标上更优（对于 $\\chi^2$，值越小表示在此测试中越接近均匀性）。不得使用任何其他阈值。\n\n对所有测试用例使用以下固定的评估参数：预热 $W = 1000$，序列长度 $N = 50000$，区间数量 $K = 10$。\n\n测试套件（三个用例），每个用例指定了模数 $m$、LCG 参数 $(a,c,X_0)$ 和减法生成器参数 $(i,j,s_0)$：\n\n- 用例 1（大素数模数，广泛使用的 LCG 和间隔良好的滞后量）：\n  - $m = 2147483647$, LCG $(a,c,X_0) = (16807,0,12345)$, 减法生成器 $(i,j,s_0) = (24,55,67890)$。\n- 用例 2（小模数，性能较差的 LCG 和强调边缘行为的小滞后量）：\n  - $m = 65536$, LCG $(a,c,X_0) = (5,1,7)$, 减法生成器 $(i,j,s_0) = (1,2,11)$。\n- 用例 3（2的幂次模数，常用的 LCG 参数和间隔良好的滞后量）：\n  - $m = 4294967296$, LCG $(a,c,X_0) = (1664525,1013904223,42)$, 减法生成器 $(i,j,s_0) = (24,55,13579)$。\n\n最终输出规范：\n\n- 对于每个用例，计算四个布尔值，分别表示减法生成器是否在绝对均值误差、绝对方差误差、滞后-1 自相关绝对值和卡方统计量上优于 LCG。\n- 将所有用例的布尔值按以下顺序聚合为一个长度为 12 的扁平列表：用例 1 均值，用例 1 方差，用例 1 自相关，用例 1 卡方；用例 2 均值，用例 2 方差，用例 2 自相关，用例 2 卡方；用例 3 均值，用例 3 方差，用例 3 自相关，用例 3 卡方。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔且不含空格的列表，例如：“[True,False,True,...]”。\n\n本任务不涉及物理单位或角度。所有结果都是无单位的实值计算，并按规定简化为布尔比较。程序必须是完全确定和自包含的，仅使用指定的库，并且不得读取任何输入。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据，提法得当，并为实现和评估提供了完整且明确的规范。这是计算物理学中一个关于伪随机数生成器性质的标准练习。\n\n任务是实现并比较线性同余生成器 (LCG) 和减法生成器。对于三个不同的参数集，生成随机数序列，根据四个统计指标进行评估，并进行比较以确定哪个生成器在每个指标上表现更优。因此，解决方案的构建首先要实现生成器和统计检验，然后对所有测试用例执行指定的流程。\n\n**生成器实现**\n\n1.  **线性同余生成器 (LCG)**：该生成器通过以下递推关系生成整数序列 $\\{X_n\\}$：\n    $$X_{n+1} \\equiv a X_n + c \\pmod m$$\n    其中 $m$ 是模数，$a$ 是乘数，$c$ 是增量，$X_0$ 是初始种子。实现过程包含一个循环，迭代地应用此公式。给定初始状态 $X_0$，生成的前 $W$ 个值作为预热阶段被丢弃。随后，生成并存储 $N$ 个值。每个整数 $X_n$ 通过变换 $U_n = X_n / m$ 被归一化为 $[0, 1)$ 区间内的实数 $U_n$。\n\n2.  **减法生成器**：该生成器是滞后斐波那契生成器的一种形式，使用以下递推关系生成序列 $\\{X_n\\}$：\n    $$X_{n} \\equiv X_{n-i} - X_{n-j} \\pmod m$$\n    其中 $i$ 和 $j$ 是滞后量。这需要维护先前 $L = \\max\\{i, j\\}$ 个值的状态。实现中使用一个循环缓冲区（一个固定大小为 $L$ 的双端队列）来高效地管理这个状态。\n    \n    初始状态 $(X_0, X_1, \\dots, X_{L-1})$ 本身是使用一个辅助 LCG 确定性地生成的。从一个种子 $s_0$ 开始，我们定义 $V_0 \\equiv s_0 \\pmod m$。然后，对于 $k=0, 1, \\dots, L-1$，我们计算：\n    $$V_{k+1} \\equiv a_s V_k + c_s \\pmod m$$\n    其中使用固定的种子生成常数 $a_s = 1664525$ 和 $c_s = 1013904223$。减法生成器的初始状态被设置为 $(X_0, \\dots, X_{L-1}) = (V_1, \\dots, V_L)$。\n    \n    生成过程始于用这个初始状态填充循环缓冲区。然后进行预热和生成循环。在每一步中，新的值 $X_n$ 是根据缓冲区中对应于滞后量 $i$ 和 $j$ 的位置上的元素计算出来的。减法 $X_{n-i} - X_{n-j}$ 的结果可能是负数；模运算 $x \\pmod m$ 的定义与数论一致，将任何整数 $x$ 映射到集合 $\\{0, 1, \\dots, m-1\\}$ 中的唯一余数。新生成的值会替换循环缓冲区中最旧的值。与 LCG 一样，生成的整数被归一化为 $U_n = X_n / m$。\n\n**统计评估**\n\n对于每个生成的长度为 $N = 50000$ 的序列 $\\{U_n\\}_{n=1}^N$，会计算四个性能指标。这些指标量化了序列与 $[0,1)$ 上真实均匀分布（其理论均值为 $1/2$，方差为 $1/12$）性质的偏差。为了提高效率，计算使用 `numpy` 库进行。\n\n1.  **绝对均值误差**：经验均值为 $\\mu = \\frac{1}{N}\\sum_{n=1}^N U_n$。指标为 $|\\mu - 1/2|$。\n2.  **绝对方差误差**：经验方差为 $v = \\frac{1}{N}\\sum_{n=1}^N (U_n - \\mu)^2$。指标为 $|v - 1/12|$。\n3.  **绝对滞后-1 自相关**：滞后-1 自相关系数 $r_1$ 衡量连续值之间的相关性。其计算公式为：\n    $$r_1 = \\frac{\\sum_{n=1}^{N-1} (U_n - \\mu)(U_{n+1} - \\mu)}{\\sum_{n=1}^N (U_n - \\mu)^2}$$\n    指标是其绝对值 $|r_1|$。\n4.  **卡方均匀性统计量**：该统计量检验序列对均匀分布的拟合优度。区间 $[0,1)$ 被划分为 $K=10$ 个等宽的区间。统计落入每个区间 $k$ 的值的数量 $O_k$。每个区间的期望数量为 $E = N/K$。该统计量计算如下：\n    $$\\chi^2 = \\sum_{k=1}^K \\frac{(O_k - E)^2}{E}$$\n    较小的 $\\chi^2$ 值表明对均匀分布的拟合更好。\n\n**程序逻辑**\n\n对于三个测试用例中的每一个，都执行以下流程：\n1.  使用用例指定的参数初始化 LCG 和减法生成器。\n2.  每个生成器丢弃 $W = 1000$ 个预热值。\n3.  然后每个生成器生成一个长度为 $N = 50000$ 的序列。\n4.  为两个序列计算四个统计指标。\n5.  对每个指标进行比较：当且仅当减法生成器的指标值严格小于 LCG 的相应指标值时，它才被视为“更优”。每个测试用例因此产生四个布尔结果。\n6.  将所有三个用例的布尔结果按指定顺序聚合到一个包含 12 个值的列表中，并为最终输出进行格式化。整个过程是确定性的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef calculate_metrics(sequence, m, N, K):\n    \"\"\"\n    Calculates the four statistical metrics for a given sequence of random numbers.\n    \n    Args:\n        sequence (list): A list of integers X_n generated by a PRNG.\n        m (int): The modulus used for normalization.\n        N (int): The length of the sequence.\n        K (int): The number of bins for the chi-square test.\n\n    Returns:\n        dict: A dictionary containing the four computed metric values.\n    \"\"\"\n    # Normalize sequence to [0, 1)\n    U = np.array(sequence, dtype=np.float64) / m\n\n    # 1. Mean\n    mu = np.mean(U)\n    mean_err = abs(mu - 0.5)\n\n    # 2. Variance\n    v = np.var(U)  # numpy.var uses N in denominator by default (ddof=0)\n    var_err = abs(v - 1.0/12.0)\n\n    # 3. Lag-1 Autocorrelation\n    # r_1 = sum{(U_n - mu)(U_{n+1} - mu)} / sum{(U_n - mu)^2}\n    numerator = np.sum((U[:-1] - mu) * (U[1:] - mu))\n    denominator = N * v\n    r1 = numerator / denominator if denominator != 0 else 0.0\n    abs_r1 = abs(r1)\n\n    # 4. Chi-Square Statistic\n    expected_count = N / K\n    observed_counts, _ = np.histogram(U, bins=K, range=(0.0, 1.0))\n    chi2 = np.sum((observed_counts - expected_count)**2 / expected_count)\n\n    return {\n        'mean_err': mean_err,\n        'var_err': var_err,\n        'abs_r1': abs_r1,\n        'chi2': chi2,\n    }\n\ndef generate_lcg_sequence(m, a, c, x0, N, W):\n    \"\"\"Generates a sequence using the Linear Congruential Generator.\"\"\"\n    sequence = []\n    x = x0\n    # Warm-up phase\n    for _ in range(W):\n        x = (a * x + c) % m\n    # Generation phase\n    for _ in range(N):\n        x = (a * x + c) % m\n        sequence.append(x)\n    return sequence\n\ndef generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W):\n    \"\"\"Generates a sequence using the Subtractive Generator.\"\"\"\n    L = max(i, j)\n    \n    # Initialize state vector V\n    V = [0] * (L + 1)\n    V[0] = s0 % m\n    for k in range(L):\n        V[k+1] = (a_s * V[k] + c_s) % m\n        \n    # Initial state buffer for the generator\n    state_buffer = deque(V[1:], maxlen=L)\n    \n    # Warm-up phase\n    for _ in range(W):\n        # NOTE: Python's % operator handles negative results correctly for modulo arithmetic.\n        # x % m gives a result in [0, m-1] for positive m.\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n\n    # Generation phase\n    sequence = []\n    for _ in range(N):\n        val_i = state_buffer[L - i]\n        val_j = state_buffer[L - j]\n        new_x = (val_i - val_j) % m\n        state_buffer.append(new_x)\n        sequence.append(new_x)\n        \n    return sequence\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation, evaluate generators, and print results.\n    \"\"\"\n    \n    # Define fixed evaluation parameters from the problem statement.\n    W = 1000\n    N = 50000\n    K = 10\n    a_s = 1664525\n    c_s = 1013904223\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"m\": 2147483647,\n            \"lcg_params\": (16807, 0, 12345),\n            \"sub_params\": (24, 55, 67890)\n        },\n        # Case 2\n        {\n            \"m\": 65536,\n            \"lcg_params\": (5, 1, 7),\n            \"sub_params\": (1, 2, 11)\n        },\n        # Case 3\n        {\n            \"m\": 4294967296,\n            \"lcg_params\": (1664525, 1013904223, 42),\n            \"sub_params\": (24, 55, 13579)\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        a, c, x0 = case[\"lcg_params\"]\n        i, j, s0 = case[\"sub_params\"]\n\n        # 1. Generate LCG sequence and compute its metrics\n        lcg_sequence = generate_lcg_sequence(m, a, c, x0, N, W)\n        lcg_metrics = calculate_metrics(lcg_sequence, m, N, K)\n        \n        # 2. Generate Subtractive sequence and compute its metrics\n        sub_sequence = generate_subtractive_sequence(m, i, j, s0, a_s, c_s, N, W)\n        sub_metrics = calculate_metrics(sub_sequence, m, N, K)\n        \n        # 3. Compare metrics and store boolean results\n        # The subtractive generator is better if its metric value is strictly smaller.\n        is_sub_better_mean = sub_metrics['mean_err']  lcg_metrics['mean_err']\n        is_sub_better_var = sub_metrics['var_err']  lcg_metrics['var_err']\n        is_sub_better_corr = sub_metrics['abs_r1']  lcg_metrics['abs_r1']\n        is_sub_better_chi2 = sub_metrics['chi2']  lcg_metrics['chi2']\n        \n        all_results.extend([\n            is_sub_better_mean,\n            is_sub_better_var,\n            is_sub_better_corr,\n            is_sub_better_chi2\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然简单的加法或减法生成器在概念上很直观，但更高质量的变体，如带借位减法（Subtract-with-Borrow, SWB）生成器，则要求更精细的实现。此练习专注于 SWB 递推关系中的精确算术，挑战您正确地管理“借位”比特以确保数学上的完整性和鲁棒性。通过验证一个核心不变量，您将学会如何编写和测试不仅功能正确而且可被证明是正确的代码 。",
            "id": "3316652",
            "problem": "您的任务是在随机模拟和蒙特卡洛方法的框架内，设计、实现并验证一个用于生成单位区间上均匀分布随机数的带借位减法滞后斐波那契生成器。您的实现必须基于以下核心定义和事实：随机数生成被建模为在固定基数下的整数模运算的确定性递推关系，而滞后斐波那契生成器使用状态的延迟项来定义下一个项。具体来说，对于基数 $b \\in \\mathbb{N}$（$b \\ge 2$）、滞后量 $r,s \\in \\mathbb{N}$（$r  s \\ge 1$）、状态向量 $(x_0,\\dots,x_{r-1})$（其中每个 $x_i \\in \\{0,1,\\dots,b-1\\}$）以及一个借位比特 $c_0 \\in \\{0,1\\}$，带借位减法方案通过以下要求定义序列 $(x_n)$ 和 $(c_n)$：对于每个 $n \\ge r$，存在唯一的 $x_n \\in \\{0,1,\\dots,b-1\\}$ 和 $c_n \\in \\{0,1\\}$ 满足以下整数恒等式\n$$\nx_n - b \\, c_n \\;=\\; x_{n-r} \\;-\\; x_{n-s} \\;-\\; c_{n-1}.\n$$\n第 $n$ 步的输出是浮点数 $u_n = x_n / b \\in [0,1)$。\n\n您的任务是：\n- 实现一个单步更新函数，该函数给定整数 $a \\in \\{0,\\dots,b-1\\}$、$d \\in \\{0,\\dots,b-1\\}$ 和 $c \\in \\{0,1\\}$，计算出数对 $(x,c')$，使得 $x \\in \\{0,\\dots,b-1\\}$，$c' \\in \\{0,1\\}$，并且 $x - b c' = a - d - c$ 作为精确的整数恒等式成立。通过维护一个借位比特并避免任何在约减前数学值为负的操作，该设计必须在定宽整数机器上也能正确工作；不要使用任何下溢时的未定义行为。\n- 实现一个使用长度为 $r$ 的循环存储器的高效生成器，该生成器为给定的参数 $(r,s,b)$ 和初始状态 $(x_0,\\dots,x_{r-1},c_0)$ 产生连续的输出 $u_n$。\n- 演示并测试一个可以作为正确性“神谕”（oracle）的非平凡不变量：对于每次更新，精确的整数恒等式 $x - b c' = a - d - c$ 必须成立，同时范围不变量 $x \\in \\{0,\\dots,b-1\\}$ 和 $c' \\in \\{0,1\\}$ 也必须成立。\n\n从上述定义和基本整数算术出发推导您的算法。特别地，要从 $x$ 是在范围 $\\{0,1,\\dots,b-1\\}$ 内的唯一代表，并与一个关联的借位比特 $c' \\in \\{0,1\\}$ 一起恢复整数环中等式的要求进行推理。您的代码应反映一种在具有定宽有符号整数的语言中能够稳健抵抗下溢的方法，方法是确保所有中间操作都在非负整数上定义。您不能假定生成器除了递推关系所暗示的之外具有任何概率分布属性，并且除了标准库之外，您不能依赖外部库来生成伪随机数。\n\n测试套件和答案规范：\n实现以下测试用例，并严格按照下述顺序汇总它们的结果。所有参数、输入和输出均为纯数值，不适用任何物理单位。\n\n- 测试 A（小基数下的边界借位更新）。令 $b_e = 97$。对于以下四个三元组 $(a,d,c)$ 中的每一个，计算更新后的 $(x,c')$ 并检查预期结果：\n  1. $(a,d,c) = (0, b_e - 1, 1)$ 应得出 $(x,c') = (0,1)$。\n  2. $(a,d,c) = (b_e - 1, 0, 0)$ 应得出 $(x,c') = (b_e - 1,0)$。\n  3. $(a,d,c) = (b_e - 1, b_e - 1, 1)$ 应得出 $(x,c') = (b_e - 1,1)$。\n  4. $(a,d,c) = (0, 0, 0)$ 应得出 $(x,c') = (0,0)$。\n  对于每种情况，生成一个布尔值，指示计算出的 $(x,c')$ 是否等于预期的数对。\n\n- 测试 B（随机化恒等式检查）。固定 $b = 2^{24}$。使用一个种子为 $42$ 的确定性伪随机源，抽取 $N = 1000$ 个独立的三元组 $(A_i,D_i,C_i)$，其中 $A_i$ 和 $D_i$ 从 $\\{0,\\dots,b-1\\}$ 中均匀抽取，$C_i$ 从 $\\{0,1\\}$ 中均匀抽取。对于每个三元组，通过您的更新函数计算 $(X_i,C_i')$，并验证恒等式 $X_i - b C_i' = A_i - D_i - C_i$。报告两个量：一个布尔值，当且仅当所有 $N$ 次检查都通过时为真；以及通过检查的整数计数。\n\n- 测试 C（使用经典参数的完整生成器及不变量验证）。使用 $b = 2^{24}$，$r = 24$，$s = 10$。通过一个线性同余生成器的输出来初始化状态 $(x_0,\\dots,x_{r-1})$，该生成器模数为 $2^{32}$，乘数为 $1664525$，增量为 $1013904223$，初始种子为 $123456789$：令 $Y_0 = 123456789$，对于 $i \\in \\{0,1,\\dots,r-1\\}$，更新 $Y_{i+1} = (1664525 \\cdot Y_i + 1013904223) \\bmod 2^{32}$ 并设置 $x_i = \\left\\lfloor \\dfrac{Y_{i+1} \\, b}{2^{32}} \\right\\rfloor$。设置 $c_0 = 0$。运行生成器 $N = 10000$ 步，以产生 $n \\in \\{r,\\dots,r+N-1\\}$ 的 $u_n = x_n / b$。在运行期间，每次更新时都验证精确恒等式 $x_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}$ 和范围不变量 $x_n \\in \\{0,\\dots,b-1\\}$ 及 $c_n \\in \\{0,1\\}$。报告两个结果：一个布尔值，当且仅当所有 $N$ 次更新的所有不变量都成立时为真；以及经验均值 $\\frac{1}{N} \\sum_{k=0}^{N-1} u_{r+k}$，作为一个浮点数。\n\n- 测试 D（小参数压力测试）。使用 $b = 7$，$r = 5$，$s = 2$。通过 $x_i = (i^3 + 1) \\bmod b$（对于 $i \\in \\{0,1,2,3,4\\}$）初始化，并设置 $c_0 = 0$。像测试 C 一样运行 $N = 2000$ 步。报告两个结果：一个布尔值，当且仅当所有 $N$ 次更新的不变量都成立时为真；以及经验均值 $\\frac{1}{N} \\sum_{k=0}^{N-1} u_{r+k}$，作为一个浮点数。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序排列：\n- 测试 A 的四个布尔值，按上述顺序列出。\n- 测试 B 的一个布尔值，指示所有检查是否都已通过。\n- 测试 B 中通过检查的计数的整数。\n- 测试 C 的一个布尔值，指示所有不变量是否都成立。\n- 测试 C 中的经验均值的浮点数。\n- 测试 D 的一个布尔值，指示所有不变量是否都成立。\n- 测试 D 中的经验均值的浮点数。\n\n为清晰起见，输出必须是一个包含 $10$ 个条目的列表：$[A_1,A_2,A_3,A_4,B_{\\mathrm{all}},B_{\\mathrm{count}},C_{\\mathrm{ok}},C_{\\mathrm{mean}},D_{\\mathrm{ok}},D_{\\mathrm{mean}}]$。程序必须是自包含的，不接受任何输入，并且不使用外部文件或网络访问。",
            "solution": "问题陈述已经过验证，被认为是一项健全、适定且客观的计算科学练习。它准确地描述了带借位减法（SWB）滞后斐波那契生成器这一标准的伪随机数生成算法，并指定了一套精确、可验证的测试用例。该问题具有科学依据，内容完整，且没有歧义。我现在将着手提供一个完整的解决方案。\n\n问题的核心是实现 SWB 生成器的递推关系。给定一个基数 $b \\in \\mathbb{N}$ ($b \\ge 2$)、滞后量 $r, s \\in \\mathbb{N}$ ($r  s \\ge 1$)、一个状态向量 $(x_0, \\dots, x_{r-1})$ 其中 $x_i \\in \\{0, \\dots, b-1\\}$，以及一个初始借位比特 $c_0 \\in \\{0, 1\\}$，该生成器产生序列 $(x_n)_{n \\ge r}$ 和 $(c_n)_{n \\ge r}$，其定义为对每个 $n \\ge r$ 满足以下整数恒等式：\n$$\nx_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}\n$$\n其中 $x_n \\in \\{0, \\dots, b-1\\}$ 和 $c_n \\in \\{0, 1\\}$ 是唯一的。输出的随机变量为 $u_n = x_n/b$。\n\n我们的任务分解为三个部分：推导一个稳健的单步更新函数，设计一个使用此函数的高效生成器，以及实现指定的测试套件以验证该实现。\n\n**1. 单步更新函数的推导**\n\n基本操作是单步更新。设输入为 $a, d \\in \\{0, \\dots, b-1\\}$ 和 $c \\in \\{0, 1\\}$，分别对应于 $x_{n-r}$、$x_{n-s}$ 和 $c_{n-1}$。我们必须找到唯一的数对 $(x, c')$，其中 $x \\in \\{0, \\dots, b-1\\}$ 且 $c' \\in \\{0, 1\\}$，满足恒等式：\n$$\nx - b c' = a - d - c\n$$\n令 $T = a - d - c$。问题在于找到整数 $T$ 的一个 $x - b c'$ 形式的表示。这类似于求余数和商，但对“商”$c'$ 有特定约束。输入的范围意味着 $T$ 在 $[0 - (b-1) - 1, (b-1) - 0 - 0]$ 区间内，即 $[-b, b-1]$。\n\n我们根据 $T$ 的符号分两种情况进行分析：\n- **情况 1：$T \\ge 0$**。由于 $T$ 的最大值为 $b-1$，所以 $T$ 已经处于 $x$ 所要求的范围内。我们可以选择 $c' = 0$，得到 $x = T = a - d - c$。这满足 $x \\in \\{0, \\dots, b-1\\}$ 和 $c' \\in \\{0, 1\\}$。\n- **情况 2：$T  0$**。为了将值带入 $\\{0, \\dots, b-1\\}$ 范围，我们必须加上 $b$ 的倍数。选择 $c'=0$ 会导致 $x=T0$，这是无效的。我们必须选择 $c'=1$。这给出 $x - b(1) = T$，因此 $x = T+b$。由于 $T$ 的最小值为 $-b$，得到的 $x$ 在 $[-b+b, -1+b] = [0, b-1]$ 范围内，这正是所要求的范围。\n\n这个案例分析提供了一个完整且正确的数学规则：\n$$\n(x, c') =\n\\begin{cases}\n(a-d-c, 0)  \\text{如果 } a - d - c \\ge 0 \\\\\n(a-d-c+b, 1)  \\text{如果 } a - d - c  0\n\\end{cases}\n$$\n问题要求实现一个在定宽整数机器上稳健的实现，避免产生数学上为负值的操作。条件 $a - d - c  0$ 等价于 $a  d+c$。直接计算 $d+c$ 可能会溢出，例如，如果 $d$ 是其整数类型的最大值。评估此条件的一个更安全的方法是将其拆分：`if (c == 0) { return a  d; } else { return a = d; }`。\n\n同样，$x$ 的计算也必须小心处理。如果发生借位（$a-d-c0$），$x$ 是 $a-d-c+b$。这可以重排为 $(a+b)-d-c$。这避免了负的中间值，但必须注意 $a+b$ 不要溢出整数类型。在支持任意精度整数的 Python 中，这些定宽问题无关紧要。我们可以直接且正确地实现逻辑为 `val = a - d - c`，然后检查 `val  0`。这是对底层数学最透明的表达。\n\n**2. 生成器的设计**\n\n生成器必须维护最后 $r$ 个值的状态，即 $(x_{n-r}, \\dots, x_{n-1})$。一个大小为 $r$ 的循环缓冲区是实现此目的的高效数据结构。我们使用一个标准数组（或 `numpy` 数组）和两个循环遍历数组的指针 $i$ 和 $j$ 来实现这一点。\n- 状态数组 `state` 初始化为 $(x_0, \\dots, x_{r-1})$。\n- 指针 $i$ 跟踪 $x_{n-r}$（最旧的值）的位置。\n- 指针 $j$ 跟踪 $x_{n-s}$ 的位置。\n- 最初，对于第一步（$n=r$），我们需要 $x_0$ 和 $x_{r-s}$。因此，我们初始化 $i=0$ 和 $j=r-s$。\n- 在每一步中：\n    1. 检索 $a = \\text{state}[i]$ 和 $d = \\text{state}[j]$。\n    2. 使用当前的借位比特 $c$ 并应用 `update` 函数来获得新值 $x_{\\text{new}}$ 和新的借位比特 $c_{\\text{new}}$。\n    3. 用新值覆盖状态中的最旧值：$\\text{state}[i] = x_{\\text{new}}$。\n    4. 将生成器的借位比特更新为 $c_{\\text{new}}$。\n    5. 为下一步推进指针：$i = (i+1) \\pmod r$ 和 $j = (j+1) \\pmod r$。\n这种双指针机制正确地循环遍历状态，确保每个新项都使用正确的历史值。\n\n**3. 测试套件的实现**\n\n提供的测试用例如下实现：\n- **测试 A：** 使用基数 $b_e=97$ 在四个特定的边界情况下验证 `update` 函数。每个案例都是对更新函数的直接调用，并将结果与预期输出进行比较。\n- **测试 B：** 对 `update` 函数正确性不变量的随机化压力测试。对于 $b=2^{24}$，生成 $N=1000$ 个随机三元组 $(A_i, D_i, C_i)$。对每个三元组，计算更新 $(X_i, C'_i)$，并使用精确整数算术检查基本恒等式 $X_i - b C'_i = A_i - D_i - C_i$。\n- **测试 C：** 使用经典参数 $b=2^{24}$、$r=24$、$s=10$ 进行生成器的完整运行。初始状态由线性同余生成器（LCG）播种。LCG 的递推关系是 $Y_{k+1} = (1664525 \\cdot Y_k + 1013904223) \\pmod{2^{32}}$。状态值为 $x_k = \\lfloor Y_{k+1} \\cdot b / 2^{32} \\rfloor$。由于 $b=2^{24}$ 且模数为 $2^{32}$，这可以简化为一个计算上高效的位移操作：$x_k = Y_{k+1} \\gg 8$。生成器运行 $N=10000$ 步，并且在每一步都检查正确性不变量（$x_n - b c_n = x_{n-r} - x_{n-s} - c_{n-1}$）和范围不变量（$x_n \\in \\{0, \\dots, b-1\\}, c_n \\in \\{0, 1\\}$）。计算输出随机变量的经验均值。\n- **测试 D：** 使用小基数（$b=7$）和小滞后量（$r=5, s=2$）进行的压力测试，这可以揭示在大参数下不明显的周期性行为或缺陷。初始化通过一个简单的多项式规则 $x_i = (i^3+1) \\pmod b$。该过程在其他方面与测试 C 相同，运行 $N=2000$ 步。\n\n该实现将这些组件组合成一个单一的、自包含的程序，产生指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a subtract-with-borrow lagged Fibonacci generator.\n    \"\"\"\n\n    def update(a, d, c, b):\n        \"\"\"\n        Computes a single step of the subtract-with-borrow recurrence.\n\n        Given a, d in {0..b-1} and c in {0,1}, computes (x, c') such that\n        x in {0..b-1}, c' in {0,1}, and the integer identity x - b*c' = a - d - c holds.\n\n        This implementation is directly based on the mathematical definition and is\n        safe in Python due to its arbitrary-precision integers. For fixed-width\n        integer architectures, care would be needed to check for borrow conditions\n        and perform calculations without causing underflow/overflow, as discussed\n        in the solution text.\n        \"\"\"\n        val = a - d - c\n        if val  0:\n            c_prime = 1\n            x = val + b\n        else:\n            c_prime = 0\n            x = val\n        return int(x), int(c_prime)\n\n    # --- Test A ---\n    b_e = 97\n    test_cases_A = [\n        ((0, b_e - 1, 1), (0, 1)),\n        ((b_e - 1, 0, 0), (b_e - 1, 0)),\n        ((b_e - 1, b_e - 1, 1), (b_e - 1, 1)),\n        ((0, 0, 0), (0, 0)),\n    ]\n    results_A = []\n    for params, expected in test_cases_A:\n        computed = update(params[0], params[1], params[2], b_e)\n        results_A.append(computed == expected)\n    \n    # --- Test B ---\n    b_B = 2**24\n    N_B = 1000\n    seed_B = 42\n    \n    rand_state = np.random.RandomState(seed_B)\n    A_vals = rand_state.randint(0, b_B, size=N_B, dtype=np.int64)\n    D_vals = rand_state.randint(0, b_B, size=N_B, dtype=np.int64)\n    C_vals = rand_state.randint(0, 2, size=N_B, dtype=np.int64)\n\n    passing_checks_B = 0\n    for i in range(N_B):\n        A, D, C = A_vals[i], D_vals[i], C_vals[i]\n        X, C_prime = update(A, D, C, b_B)\n        if (X - b_B * C_prime) == (A - D - C):\n            passing_checks_B += 1\n            \n    all_passed_B = (passing_checks_B == N_B)\n    results_B = [all_passed_B, passing_checks_B]\n\n    class SWBGenerator:\n        \"\"\"Subtract-with-borrow lagged Fibonacci generator.\"\"\"\n        def __init__(self, r, s, b, x_initial, c_initial):\n            if not (r > s >= 1):\n                raise ValueError(\"Lags must satisfy r > s >= 1\")\n            \n            self.r, self.s, self.b = r, s, b\n            # Use np.int64 to be safe with b=2^24, though Python's default int is sufficient.\n            self.state = np.array(x_initial, dtype=np.int64)\n            self.c = c_initial\n            \n            # Pointers for circular buffer access\n            self.p_i = 0  # Pointer for x_{n-r}\n            self.p_j = r - s  # Pointer for x_{n-s}\n\n        def step(self):\n            \"\"\"Performs one step of the generator and returns values for verification.\"\"\"\n            a = self.state[self.p_i]\n            d = self.state[self.p_j]\n            c_prev = self.c\n            \n            x_new, c_new = update(a, d, c_prev, self.b)\n            \n            self.state[self.p_i] = x_new\n            self.c = c_new\n            \n            self.p_i = (self.p_i + 1) % self.r\n            self.p_j = (self.p_j + 1) % self.r\n\n            u_new = x_new / self.b\n            \n            return u_new, x_new, c_new, a, d, c_prev\n\n    # --- Test C ---\n    b_C, r_C, s_C = 2**24, 24, 10\n    N_C = 10000\n    \n    # Initialize state with LCG\n    lcg_mod = 2**32\n    lcg_mult = 1664525\n    lcg_inc = 1013904223\n    y = 123456789\n    \n    x_initial_C = []\n    for _ in range(r_C):\n        y = (lcg_mult * y + lcg_inc)  (lcg_mod - 1)\n        # x_i = floor(y * b / 2^32) = y >> 8\n        x_i = y >> 8\n        x_initial_C.append(x_i)\n        \n    gen_C = SWBGenerator(r_C, s_C, b_C, x_initial_C, c_initial=0)\n    \n    sum_u_C = 0.0\n    invariants_hold_C = True\n    for _ in range(N_C):\n        u, x, c_new, a, d, c_prev = gen_C.step()\n        sum_u_C += u\n        \n        # Invariant checks\n        identity_holds = (x - b_C * c_new) == (a - d - c_prev)\n        range_holds = (0 = x  b_C) and (c_new in [0, 1])\n        if not (identity_holds and range_holds):\n            invariants_hold_C = False\n            \n    mean_C = sum_u_C / N_C\n    results_C = [invariants_hold_C, mean_C]\n\n    # --- Test D ---\n    b_D, r_D, s_D = 7, 5, 2\n    N_D = 2000\n\n    x_initial_D = [(i**3 + 1) % b_D for i in range(r_D)]\n    gen_D = SWBGenerator(r_D, s_D, b_D, x_initial_D, c_initial=0)\n    \n    sum_u_D = 0.0\n    invariants_hold_D = True\n    for _ in range(N_D):\n        u, x, c_new, a, d, c_prev = gen_D.step()\n        sum_u_D += u\n\n        # Invariant checks\n        identity_holds = (x - b_D * c_new) == (a - d - c_prev)\n        range_holds = (0 = x  b_D) and (c_new in [0, 1])\n        if not (identity_holds and range_holds):\n            invariants_hold_D = False\n\n    mean_D = sum_u_D / N_D\n    results_D = [invariants_hold_D, mean_D]\n\n    # Combine all results and format output\n    final_results = results_A + results_B + results_C + results_D\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "即使一个生成器通过了初步的经验测试，它也可能隐藏着深层的结构性缺陷。这项理论练习将引导您通过推导一个加法 LFG 输出之间的精确关系，来揭示其固有的确定性晶格结构。您将构造一个专门的测试函数，使这种非随机性变得显而易见，从而展示数学分析在揭示统计测试可能忽略的弱点方面的强大力量 。",
            "id": "3316692",
            "problem": "考虑一个滞后斐波那契生成器 (LFG)，它在模 $2^{w}$ 上由加法递推关系\n$$\nX_{n} = \\big(X_{n-j} + X_{n-k}\\big)\\bmod 2^{w}\n$$,\n定义，其中滞后量 $jk\\geq 1$ 为固定值，整数词长 $w\\geq 2$，归一化输出 $U_{n} = X_{n}/2^{w}\\in [0,1)$ 用于蒙特卡洛 (MC) 模拟。我们遵循随机模拟的常规约定，即一个理想的随机数源应在所有维度上提供在 $[0,1)$ 上均匀分布的独立同分布 (i.i.d.) 样本。\n\n从递推关系和模运算的定义出发，运用模算术的第一性原理推导，找出由 LFG 生成的三元组 $(U_{n},U_{n-j},U_{n-k})$ 所满足的确定性几何约束。然后，构建一个三维格点检验函数 $f(U_{n},U_{n-j},U_{n-k})$，该函数对此约束敏感，并且在 LFG 输出上求值时会产生确定性偏差，而在独立同分布均匀模型下其期望为零。\n\n为具体起见并确保量的唯一定义，将您的格点检验函数取为非平凡傅里叶特征标：\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big),\n$$\n其中 $i$ 表示虚数单位。将偏差 $B$ 定义为 $f$ 在 LFG 模型下的期望与在三个独立同分布的 $\\mathrm{Uniform}(0,1)$ 变量下的期望之差：\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big].\n$$\n\n仅从递推关系和模算术精确推导出 $B$，并解释导致此确定性偏差的机制。您的最终答案必须是 $B$ 的精确值。不需要四舍五入。",
            "solution": "该问题要求推导应用于滞后斐波那契生成器 (LFG) 的特定统计检验函数的偏差 $B$。偏差 $B$ 定义为检验函数在 LFG 输出分布下的期望与在独立同分布 (i.i.d.) 均匀随机变量的理想分布下的期望之差。\n$$\nB \\;=\\; \\mathbb{E}_{\\text{LFG}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big] \\;-\\; \\mathbb{E}_{\\text{iid}}\\!\\big[f(U_{n},U_{n-j},U_{n-k})\\big]\n$$\n其中检验函数为\n$$\nf(U_{n},U_{n-j},U_{n-k}) \\;=\\; \\exp\\!\\Big(2\\pi i\\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big)\n$$\n我们将分别计算每个期望项。\n\n首先，我们计算在理想随机模型下的期望，其中生成器产生来自 $\\mathrm{Uniform}(0,1)$ 分布的 i.i.d. 样本。设 $V_{1}$、$V_{2}$ 和 $V_{3}$ 是三个独立的随机变量，每个都服从 $\\mathrm{Uniform}(0,1)$ 分布。那么期望 $\\mathbb{E}_{\\text{iid}}[f]$ 由下式给出：\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\Big[\\exp\\big(2\\pi i (V_{1} - V_{2} - V_{3})\\big)\\Big]\n$$\n由于 $V_{1}$、$V_{2}$ 和 $V_{3}$ 的独立性，这些变量的函数乘积的期望是它们各自期望的乘积：\n$$\n\\mathbb{E}_{\\text{iid}}[f] = \\mathbb{E}\\big[\\exp(2\\pi i V_{1})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{2})\\big] \\cdot \\mathbb{E}\\big[\\exp(-2\\pi i V_{3})\\big]\n$$\n此乘积中的每一项都是一个 $\\mathrm{Uniform}(0,1)$ 变量的特征函数 $\\phi_{V}(t) = \\mathbb{E}[\\exp(itV)]$ 在 $t = \\pm 2\\pi$ 处的一个实例。对于一个一般的非零整数 $s$，我们来计算 $\\mathbb{E}[\\exp(2\\pi i s V)]$，其中 $V \\sim \\mathrm{Uniform}(0,1)$：\n$$\n\\mathbb{E}[\\exp(2\\pi i s V)] = \\int_{0}^{1} \\exp(2\\pi i s v) \\, dv = \\left[ \\frac{\\exp(2\\pi i s v)}{2\\pi i s} \\right]_{v=0}^{v=1}\n$$\n$$\n= \\frac{\\exp(2\\pi i s) - \\exp(0)}{2\\pi i s}\n$$\n根据欧拉恒等式，$\\exp(2\\pi i s) = \\cos(2\\pi s) + i\\sin(2\\pi s)$。因为 $s$ 是一个非零整数，所以 $\\cos(2\\pi s) = 1$ 且 $\\sin(2\\pi s) = 0$，因此 $\\exp(2\\pi i s) = 1$。该表达式变为：\n$$\n= \\frac{1 - 1}{2\\pi i s} = 0\n$$\n在我们的例子中，这些项对应于 $s=1$、$s=-1$ 和 $s=-1$，它们都是非零整数。因此，每个期望都是 $0$。\n$$\n\\mathbb{E}[\\exp(2\\pi i V_{1})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{2})] = 0, \\quad \\mathbb{E}[\\exp(-2\\pi i V_{3})] = 0\n$$\n因此，在 i.i.d. 模型下的期望是：\n$$\n\\mathbb{E}_{\\text{iid}}[f] = 0 \\cdot 0 \\cdot 0 = 0\n$$\n这个结果是符合预期的，因为该检验函数是一个傅里葉特征标，其设计目的是对于单位超立方体中的真正均匀分布具有零均值。\n\n接下来，我们计算在 LFG 模型下的期望。LFG 由整数递推关系定义：\n$$\nX_{n} = \\big(X_{n-j} + X_{n-k}\\big)\\bmod 2^{w}\n$$\n其中每个 $X_{m}$ 是集合 $\\{0, 1, \\dots, 2^w-1\\}$ 中的一个整数。模运算符的定义意味着存在一个整数（我们称之为 $m_{n}$），使得：\n$$\nX_{n-j} + X_{n-k} = m_{n} \\cdot 2^{w} + X_{n}\n$$\n由于 $0 \\leq X_{n-j}  2^w$ 和 $0 \\leq X_{n-k}  2^w$，和 $X_{n-j} + X_{n-k}$ 满足 $0 \\leq X_{n-j} + X_{n-k} \\leq 2(2^w-1) = 2^{w+1}-2$。项 $m_n$ 解释了模算术的“回绕”效应。从方程 $m_n 2^w = (X_{n-j} + X_{n-k}) - X_n$ 以及 $X$ 变量的取值范围可知，整数 $m_n$ 只能取 $0$ 或 $1$。具体来说，如果 $X_{n-j} + X_{n-k}  2^w$，则 $m_n=0$；如果 $X_{n-j} + X_{n-k} \\geq 2^w$，则 $m_n=1$。\n\n归一化输出 $U_n$ 定义为 $U_n = X_n / 2^w$。我们可以通过将方程两边除以 $2^w$ 来将整数递推关系转换为归一化输出的关系式：\n$$\n\\frac{X_{n-j}}{2^{w}} + \\frac{X_{n-k}}{2^{w}} = m_{n} \\cdot \\frac{2^{w}}{2^{w}} + \\frac{X_{n}}{2^{w}}\n$$\n代入 $U_n$ 的定义，上式变为：\n$$\nU_{n-j} + U_{n-k} = m_{n} + U_{n}\n$$\n这个方程揭示了由 LFG 生成的任何三元组 $(U_n, U_{n-j}, U_{n-k})$ 所满足的确定性几何约束。重新整理各项，我们得到：\n$$\nU_{n} - U_{n-j} - U_{n-k} = -m_{n}\n$$\n这个表达式恰好是检验函数 $f$ 中复指數的宗量。我们现在可以对 LFG 的任何输出计算 $f$ 的值：\n$$\nf(U_{n},U_{n-j},U_{n-k}) = \\exp\\Big(2\\pi i \\big(U_{n} - U_{n-j} - U_{n-k}\\big)\\Big) = \\exp\\big(2\\pi i (-m_{n})\\big)\n$$\n由于 $m_{n}$ 始终是整数（$0$ 或 $1$），$\\exp(-2\\pi i m_{n})$ 的值始终为 $1$，因为 $\\exp(-2\\pi i \\cdot 0) = 1$ 且 $\\exp(-2\\pi i \\cdot 1) = 1$。\n这意味着对于由 LFG 生成的每一组三元值，检验函数都确定性地计算出结果恰好为 $1$。\n$$\nf(U_{n},U_{n-j},U_{n-k}) = 1\n$$\n一个常数的期望就是该常数本身。因此，在 LFG 模型下的期望是：\n$$\n\\mathbb{E}_{\\text{LFG}}[f] = \\mathbb{E}_{\\text{LFG}}[1] = 1\n$$\n因此，产生偏差的机制是 LFG 的刚性代数结构。整数上的加法递推迫使归一化输出落在少数几个平行超平面上（在本例中，是由 $u_n-u_{n-j}-u_{n-k}=0$ 和 $u_n-u_{n-j}-u_{n-k}=-1$ 定义的两个平面）。所选的检验函数作为一个对应于此平面结构的傅里葉特征标，对這種偏离均匀性的情况最为敏感，并产生一个恒定的、非随机的输出。\n\n最后，我们可以计算偏差 $B$：\n$$\nB = \\mathbb{E}_{\\text{LFG}}[f] - \\mathbb{E}_{\\text{iid}}[f] = 1 - 0 = 1\n$$\n偏差为 $1$，这表明 LFG 在此检验下完全失效，并且对于三元组 $(U_n, U_{n-j}, U_{n-k})$ 的独立性和均匀性假设完全不成立。",
            "answer": "$$\n\\boxed{1}\n$$"
        }
    ]
}