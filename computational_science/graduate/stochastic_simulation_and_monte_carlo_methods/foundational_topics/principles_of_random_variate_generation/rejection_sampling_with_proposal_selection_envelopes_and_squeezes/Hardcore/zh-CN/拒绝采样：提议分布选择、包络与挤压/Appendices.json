{
    "hands_on_practices": [
        {
            "introduction": "本章节的第一个练习将带你深入了解高效拒绝抽样的核心原理：封套设计。通过为对数凹目标函数构建一个分段指数封套，你将推导出封套结构与采样器接受率之间的关系。这个练习  提供了一个具体的、基于第一性原理的分析，让你掌握如何优化封套以最大化效率。",
            "id": "3335755",
            "problem": "考虑一个定义在 $\\mathbb{R}$ 上的目标概率密度函数 $f(x)$，该函数是对数凹的，即 $\\log f(x)$ 是一个凹函数。在拒绝采样中，我们构造一个包络函数 $g(x)$，使得对所有 $x$ 都有 $g(x) \\geq f(x)$，然后从归一化的包络中抽取样本 $X$，并以概率 $f(X)/g(X)$ 接受该样本。平均接受率 $\\alpha$ 等于 $f$ 的积分与 $g$ 的积分之比。为对数凹目标函数构造高效包络的一种标准方法是，利用 $\\log f$ 的切线来构建一个分段线性的上包络 $u(x)$，然后取包络 $g(x) = \\exp(u(x))$。这是自适应拒绝采样（Adaptive Rejection Sampling, ARS）背后的核心思想。\n\n您将使用拒绝采样的基本原理，为一个特定的、经过充分研究的对数凹目标和一类受限的包络，分析支撑点（即切线所在的点）的数量和位置与最终接受率 $\\alpha$ 之间的权衡关系。\n\n设目标为标准正态密度函数 $f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{x^{2}}{2}\\right)$，该函数满足对数凹性。考虑通过在两个对称支撑点 $\\{-a, +a\\}$（其中 $a > 0$）处对 $\\log f(x)$ 取切线来构造一个分段指数包络 $g(x)$。令 $l(x) = \\log f(x)$，并令 $u_{-a}(x)$ 和 $u_{+a}(x)$ 分别为 $l$ 在 $x = -a$ 和 $x = +a$ 处的切线。定义上包络 $u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\}$ 并设 $g(x) = \\exp(u(x))$。因为 $l$ 是凹函数，所以 $u(x) \\geq l(x)$，因此 $g(x) \\geq f(x)$。\n\n从拒绝采样的基本事实出发——即平均接受率等于目标函数和包络函数积分之比——并且仅使用上述定义（不引入任何快捷公式），完成以下任务：\n\n1. 对于由两个对称支撑点 $\\{-a, +a\\}$ 定义的包络 $g$，推导接受率 $\\alpha(a)$ 作为 $a$ 的函数的闭式表达式。\n2. 使用接受率作为积分比的原理，将每个接受的样本所需的目标函数评估次数期望值定义为 $J(a) = 1/\\alpha(a)$。这里做一个简化假设：与评估 $f(x)$ 相比，从分段指数包络中采样和确定活动段的开销可以忽略不计；这突出了由包络紧度驱动的核心权衡。\n3. 在此类双支撑点包络中，确定使 $J(a)$ 最小化的值 $a^{\\star} > 0$，以及相应的最优接受率 $\\alpha^{\\star} = \\alpha(a^{\\star})$。请提供 $a^{\\star}$ 和 $\\alpha^{\\star}$ 的精确表达式。\n\n你的最终答案必须是一个包含 $a^{\\star}$ 和 $\\alpha^{\\star}$ 的单行矩阵。不需要进行数值四舍五入，最终表达式中也不应包含单位。根据你的推导，解释支撑点的位置如何影响 $\\alpha$ 以及评估成本 $J$，从而量化这种受限的双点设计中的权衡。并从概念上简要评论，对于通过切线包络构造的对数凹目标，增加支撑点的数量通常如何影响 $\\alpha$ 和 $J$，以及一个“挤压函数”（squeeze function）如何在不改变 $\\alpha$ 的情况下进一步影响评估成本。",
            "solution": "首先验证问题，以确保其科学上合理、内容独立且定义明确。\n\n**第1步：提取已知条件**\n-   目标概率密度函数：$f(x) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{x^{2}}{2}\\right)$，定义于 $\\mathbb{R}$。\n-   性质：$f(x)$ 是对数凹函数。\n-   包络构造：包络 $g(x)$ 由 $l(x) = \\log f(x)$ 在两个对称支撑点 $\\{-a, +a\\}$ (其中 $a > 0$) 处的切线构成。\n-   函数定义：\n    -   $l(x) = \\log f(x)$。\n    -   $u_{-a}(x)$ 和 $u_{+a}(x)$ 分别是 $l(x)$ 在 $x=-a$ 和 $x=+a$ 处的切线。\n    -   $u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\}$。\n    -   $g(x) = \\exp(u(x))$。\n-   核心原理：平均接受率为 $\\alpha = \\frac{\\int_{-\\infty}^{\\infty} f(x) \\,dx}{\\int_{-\\infty}^{\\infty} g(x) \\,dx}$。\n-   成本函数：每个接受的样本所需的目标函数评估次数期望值为 $J(a) = 1/\\alpha(a)$。\n-   目标：\n    1.  推导接受率 $\\alpha(a)$ 的闭式表达式。\n    2.  定义 $J(a)$。\n    3.  找到使 $J(a)$ 最小化的最优值 $a^{\\star} > 0$ 和相应的最优接受率 $\\alpha^{\\star} = \\alpha(a^{\\star})$。\n\n**第2步：使用提取的已知条件进行验证**\n问题是有效的。这是一个定义明确的数学练习，其理论基础是拒绝采样和自适应拒绝采样（ARS）。目标函数是标准正态密度，其对数凹性是一个已知性质。通过切线构造包络是处理对数凹密度的标准技术。所有术语都定义清晰，目标明确，不存在科学或逻辑上的缺陷。关于成本 $J(a)$ 的简化假设被明确说明，其目的是为了分离出与包络紧度相关的主要权衡。\n\n**第3步：结论与行动**\n问题有效，将提供完整解答。\n\n**求解过程**\n\n求解过程首先构造包络函数 $g(x)$，然后计算其积分以求得接受率 $\\alpha(a)$，最后针对支撑点参数 $a$ 优化此接受率。\n\n首先，我们定义目标密度的对数 $l(x)$：\n$$l(x) = \\ln(f(x)) = \\ln\\left(\\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{x^2}{2}\\right)\\right) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{x^2}{2}$$\n需要导数 $l'(x)$ 来定义切线：\n$$l'(x) = -x$$\n在点 $x_0$ 处，$l(x)$ 的切线方程为 $y(x) = l(x_0) + l'(x_0)(x - x_0)$。我们在支撑点 $x_0 = a$ 和 $x_0 = -a$ 处求两条切线。\n\n对于支撑点 $x_0 = a$：\n$l(a) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}$\n$l'(a) = -a$\n切线 $u_{+a}(x)$ 为：\n$$u_{+a}(x) = \\left(-\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}\\right) - a(x-a) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - ax$$\n\n对于支撑点 $x_0 = -a$：\n$l(-a) = -\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}$\n$l'(-a) = -(-a) = a$\n切线 $u_{-a}(x)$ 为：\n$$u_{-a}(x) = \\left(-\\frac{1}{2}\\ln(2\\pi) - \\frac{a^2}{2}\\right) + a(x-(-a)) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} + ax$$\n\n上包络 $u(x)$ 是这两条线的最小值：\n$$u(x) = \\min\\{u_{-a}(x), u_{+a}(x)\\} = \\min\\left\\{-\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} + ax, -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - ax\\right\\}$$\n简化后为：\n$$u(x) = -\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - a|x|$$\n两条切线在 $u_{-a}(x) = u_{+a}(x)$ 时相交，这意味着 $ax = -ax$，即 $2ax=0$。因为 $a>0$，所以相交点为 $x=0$。当 $x  0$ 时，$u_{-a}(x)  u_{+a}(x)$；当 $x > 0$ 时，$u_{+a}(x)  u_{-a}(x)$。\n\n包络函数 $g(x)$ 是上包络 $u(x)$ 的指数：\n$$g(x) = \\exp(u(x)) = \\exp\\left(-\\frac{1}{2}\\ln(2\\pi) + \\frac{a^2}{2} - a|x|\\right) = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right)\\exp(-a|x|)$$\n\n平均接受率 $\\alpha(a)$ 由 $f(x)$ 和 $g(x)$ 的积分之比给出。根据定义，目标密度函数 $f(x)$ 在 $\\mathbb{R}$ 上的积分为 $1$：\n$$\\int_{-\\infty}^{\\infty} f(x) \\,dx = 1$$\n接下来，我们计算包络函数 $g(x)$ 的积分：\n$$\\int_{-\\infty}^{\\infty} g(x) \\,dx = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right) \\int_{-\\infty}^{\\infty} \\exp(-a|x|) \\,dx$$\n$\\exp(-a|x|)$ 的积分可以通过利用对称性计算：\n$$\\int_{-\\infty}^{\\infty} \\exp(-a|x|) \\,dx = 2 \\int_{0}^{\\infty} \\exp(-ax) \\,dx = 2 \\left[-\\frac{1}{a}\\exp(-ax)\\right]_{0}^{\\infty} = 2\\left(0 - \\left(-\\frac{1}{a}\\right)\\right) = \\frac{2}{a}$$\n将此结果代回，包络的积分为：\n$$I_g(a) = \\int_{-\\infty}^{\\infty} g(x) \\,dx = \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right) \\frac{2}{a} = \\frac{2}{a\\sqrt{2\\pi}}\\exp\\left(\\frac{a^2}{2}\\right)$$\n\n现在我们可以写出接受率 $\\alpha(a)$ 的表达式：\n$$\\alpha(a) = \\frac{\\int f(x) \\,dx}{\\int g(x) \\,dx} = \\frac{1}{I_g(a)} = \\frac{a\\sqrt{2\\pi}}{2\\exp\\left(\\frac{a^2}{2}\\right)} = \\frac{a\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{a^2}{2}\\right)$$\n这就是接受率作为 $a$ 的函数的闭式表达式。成本函数为 $J(a) = 1/\\alpha(a)$。\n\n为了找到最优的支撑点位置 $a^{\\star}$，我们必须最小化 $J(a)$，这等价于在 $a > 0$ 的条件下最大化 $\\alpha(a)$。我们计算 $\\alpha(a)$ 关于 $a$ 的导数并将其设为零。\n$$\\frac{d\\alpha}{da} = \\frac{d}{da}\\left[\\frac{\\sqrt{2\\pi}}{2} \\left(a \\exp\\left(-\\frac{a^2}{2}\\right)\\right)\\right]$$\n使用乘法法则：\n$$\\frac{d\\alpha}{da} = \\frac{\\sqrt{2\\pi}}{2} \\left[1 \\cdot \\exp\\left(-\\frac{a^2}{2}\\right) + a \\cdot \\exp\\left(-\\frac{a^2}{2}\\right) \\cdot (-a)\\right] = \\frac{\\sqrt{2\\pi}}{2} (1-a^2) \\exp\\left(-\\frac{a^2}{2}\\right)$$\n将导数设为零：\n$$\\frac{d\\alpha}{da} = 0 \\implies (1-a^2) = 0$$\n因为我们要求 $a>0$，唯一的临界点是 $a=1$。为确认这是一个最大值，我们检查一阶导数的符号。对于 $0  a  1$，$1-a^2 > 0$ 且 $\\frac{d\\alpha}{da} > 0$，因此 $\\alpha(a)$ 是递增的。对于 $a > 1$，$1-a^2  0$ 且 $\\frac{d\\alpha}{da}  0$，因此 $\\alpha(a)$ 是递减的。所以，$a=1$ 在 $a>0$ 的范围内给出了 $\\alpha(a)$ 的全局最大值。\n\n因此，最优的支撑点参数是：\n$$a^{\\star} = 1$$\n相应的最优接受率 $\\alpha^{\\star}$，可以通过将 $a^{\\star}=1$ 代入 $\\alpha(a)$ 的表达式中求得：\n$$\\alpha^{\\star} = \\alpha(1) = \\frac{1 \\cdot \\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{1^2}{2}\\right) = \\frac{\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{1}{2}\\right) = \\frac{\\sqrt{2\\pi}}{2\\sqrt{e}} = \\sqrt{\\frac{2\\pi}{4e}} = \\sqrt{\\frac{\\pi}{2e}}$$\n\n**权衡与扩展分析**\n\n参数 $a$ 控制支撑点的位置。表达式 $\\alpha(a) = \\frac{a\\sqrt{2\\pi}}{2} \\exp\\left(-\\frac{a^2}{2}\\right)$ 量化了这种权衡关系。如果 $a$ 非常小（接近 $0$），支撑点会靠近众数。此时切线近乎水平，形成一个宽松的包络，其面积很大，导致接受率很低（当 $a \\to 0$ 时 $\\alpha(a) \\to 0$）。相反，如果 $a$ 非常大，支撑点会远在尾部。此时切线非常陡峭，在尾部拟合得很好，但在 $x=0$ 处形成一个极高且窄的峰。包络的面积主要由这个峰主导，会再次变得很大，接受率也趋于零（当 $a \\to \\infty$ 时 $\\alpha(a) \\to 0$）。最优值 $a^{\\star}=1$ 代表了一种最佳平衡，将支撑点放置在距离均值一个标准差的位置，这使得包络 $g(x)$ 下的总面积最小化，从而最大化了接受率 $\\alpha$。这也最小化了获得一个被接受样本所需的期望抽取次数 $J(a)$。\n\n增加支撑点的数量可以得到一个更精细的分段线性上包络 $u(x)$。由于新的上包络是一组更多切线的最小值，它必定位于双点上包络的下方或与之重合：对所有 $x$ 都有 $u_{\\text{new}}(x) \\leq u(x)$。这会产生一个更紧的包络 $g_{\\text{new}}(x) \\leq g(x)$，一个更小的包络积分 $\\int g_{\\text{new}}(x)dx$，从而得到更高的接受率 $\\alpha$。这降低了成本 $J$。这就是自适应拒绝采样的原理，通过迭代添加点来改善包络。\n\n挤压函数（squeeze function）$s(x)$ 是一个满足对所有 $x$ 都有 $0 \\le s(x) \\le f(x)$ 的函数。在拒绝采样器中，可以执行一个廉价的预测试：如果一个均匀分布的随机数 $U$ 满足 $U \\cdot g(X) \\le s(X)$，那么样本 $X$ 将被接受，而无需评估 $f(X)$。这是可行的，因为 $s(X) \\le f(X)$ 保证了 $U \\cdot g(X) \\le f(X)$ 也成立。总接受率 $\\alpha$ 保持不变，因为它最终由 $f(x)$ 和 $g(x)$ 曲线下的面积之比决定。然而，挤压函数减少了每个被接受样本*对目标函数 $f(x)$ 的平均评估次数*。通过让一些样本被“免费”接受，一个高效的挤压函数（其积分接近于 $f(x)$ 的积分）可以显著降低总计算成本，特别是当 $f(x)$ 计算成本高昂时，而不会改变基本的接受概率 $\\alpha$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1  \\sqrt{\\frac{\\pi}{2e}} \\end{pmatrix} } $$"
        },
        {
            "introduction": "从数学理论转向稳健的实现，这个练习旨在解决一个关键但常被忽视的问题：数值精度。浮点运算可能导致微小的误差，从而违反基本的封套条件，最终影响采样器的正确性。这个练习  将挑战你设计一种策略，以在存在舍入误差的情况下保证封套的有效性，这是任何严谨的计算科学实践者都必须掌握的关键技能。",
            "id": "3335791",
            "problem": "考虑经典的拒绝采样设置，用于从目标分布中进行模拟。该目标分布的未归一化密度为 $f(x)$，定义在可测域 $\\mathcal{X}$ 上。采样使用一个提议密度 $g(x)$ 和一个包络常数 $M  0$，使得精确包络条件 $f(x) \\le M g(x)$ 对所有 $x \\in \\mathcal{X}$ 成立。当 $f$ 是概率密度且 $g$ 是概率密度时，每次抽样的接受概率为 $1/M$。在符合电气和电子工程师协会754标准（IEEE 754）的浮点运算中，如果天真地实现，数值舍入误差可能导致对 $f(x) \\le M g(x)$ 的直接测试不可靠。因此，一个鲁棒的数值验证必须考虑 $f$ 和 $g$ 求值过程中的舍入误差，以避免违反包络条件和损害正确性。\n\n假设以下基本前提：\n- 在 IEEE 754 中，对于实数 $a$ 和 $b$ 上的任何基本算术运算 $\\circ \\in \\{+, -, \\times, \\div\\}$，浮点结果 $\\operatorname{fl}(a \\circ b)$ 满足 $\\operatorname{fl}(a \\circ b) = (a \\circ b)(1 + \\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入（机器精度）。对于具有后向误差保证的基本函数，情况类似。\n- 对于 $f$ 和 $g$ 的复合求值，假设先验分析提供了依赖于数据的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$，使得计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$ 满足 $\\hat{f}(x) = f(x)(1 + \\delta_f(x))$ 和 $\\hat{g}(x) = g(x)(1 + \\delta_g(x))$，其中对所有 $x \\in \\mathcal{X}$，都有 $|\\delta_f(x)| \\le \\varepsilon_f(x)$ 和 $|\\delta_g(x)| \\le \\varepsilon_g(x)$。这些界限源于经过充分测试的后向误差分析，该分析结合了用于计算 $f$ 和 $g$ 的所有运算的单位舍入 $u$。\n- 挤压函数（squeeze function）$s(x)$ 是满足对所有 $x \\in \\mathcal{X}$ 都有 $0 \\le s(x) \\le f(x)$ 的任意可计算函数。如果 $U \\sim \\mathrm{Uniform}(0, 1)$ 且 $X \\sim g$，那么只要 $U \\le s(X)/(M g(X))$，就可以接受该点而无需计算 $f(X)$，这可以降低计算成本并减轻因保守包络导致的效率损失。\n\n您的实现必须在运行时仅使用 $\\hat{f}(x)$、$\\hat{g}(x)$ 以及误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$ 来鲁棒地验证条件 $f(x) \\le M g(x)$。此外，您必须提出一种安全的方法来膨胀 $M$ 至一个新的包络常数，以防范舍入误差，同时最小化接受率的下降。\n\n在所述假设下，以下哪个选项正确地构建了一个鲁棒的浮点验证测试和一个能最小化效率损失的安全膨胀策略？\n\nA. 使用误差界构造 $f(x)$ 的最坏情况上界和 $M g(x)$ 的最坏情况下界。通过检查以下条件来验证包络：\n$$\\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\;\\le\\; M \\,\\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}.$$\n如果不想进行每次求值的验证，则将包络膨胀为一个依赖于数据的局部常数\n$$M'(x) \\;=\\; M \\,\\frac{1 + \\varepsilon_f(x)}{1 - \\varepsilon_g(x)},$$\n或保守地膨胀为一个全局常数\n$$M' \\;=\\; M \\,\\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star},$$\n其中 $\\varepsilon_f^\\star \\ge \\sup_{x \\in \\mathcal{X}} \\varepsilon_f(x)$ 且 $\\varepsilon_g^\\star \\ge \\sup_{x \\in \\mathcal{X}} \\varepsilon_g(x)$。这种膨胀是安全的，因为它补偿了 $f$ 的最坏情况下的向上拉动和 $g$ 的最坏情况下的向下拉动，并且其对接受率的影响仅限于一个乘法因子 $\\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star}$。为了进一步减少效率损失，可以引入一个通过向下舍入计算的挤压函数 $s(x)$，使得 $\\hat{s}(x) \\le s(x)$，从而在 $U \\le \\hat{s}(x)/(M' \\hat{g}(x))$ 时无需计算 $f(x)$ 即可接受样本。\n\nB. 通过检查以下条件进行验证\n$$\\hat{f}(x) \\;\\le\\; M \\,\\hat{g}(x)\\,\\bigl(1 + \\varepsilon_f(x) + \\varepsilon_g(x)\\bigr),$$\n并使用以下公式进行膨胀\n$$M' \\;=\\; M \\,\\bigl(1 + \\varepsilon_f^\\star + \\varepsilon_g^\\star\\bigr).$$\n这种相对误差的加性聚合是充分的，因为误差很小，并且它能最小化接受率的降低。\n\nC. 使用加性容差。通过以下条件进行验证\n$$\\hat{f}(x) \\;\\le\\; M \\,\\hat{g}(x) \\;+\\; \\tau(x), \\quad \\text{其中} \\quad \\tau(x) \\;=\\; u \\,\\max\\{\\hat{f}(x),\\,M \\hat{g}(x)\\}.$$\n通过以下方式膨胀 $M$\n$$M' \\;=\\; M \\;+\\; \\frac{\\tau^\\star}{\\inf_{x \\in \\mathcal{X}} g(x)}, \\quad \\tau^\\star \\;\\ge\\; \\sup_{x \\in \\mathcal{X}} \\tau(x),$$\n以全局性地恢复包络。\n\nD. 使用定向舍入，在向 $+\\infty$ 舍入模式下计算 $\\hat{f}^\\uparrow(x)$，在向 $-\\infty$ 舍入模式下计算 $\\hat{g}^\\downarrow(x)$，然后通过以下条件进行验证\n$$\\hat{f}^\\uparrow(x) \\;\\le\\; M \\,\\hat{g}^\\downarrow(x).$$\n按如下方式膨胀 $M$\n$$M' \\;=\\; M \\,(1 + u)^k,$$\n其中 $k$ 是用于计算 $g$ 的浮点运算次数，这可以安全地覆盖舍入误差，同时保持接受率几乎不变。",
            "solution": "该问题是有效的，可以通过将浮点误差分析的原理应用于控制拒绝采样的不等式来解决。\n\n### I. 鲁棒验证测试的推导\n\n拒绝采样的核心理论条件是对于所有 $x \\in \\mathcal{X}$ 都有 $f(x) \\le M g(x)$。我们已知计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$ 以及已知的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$。它们的关系如下：\n$$\n\\hat{f}(x) = f(x)(1 + \\delta_f(x)), \\quad |\\delta_f(x)| \\le \\varepsilon_f(x) \\\\\n\\hat{g}(x) = g(x)(1 + \\delta_g(x)), \\quad |\\delta_g(x)| \\le \\varepsilon_g(x)\n$$\n由此，我们可以用计算值来表示真实值 $f(x)$ 和 $g(x)$：\n$$\nf(x) = \\frac{\\hat{f}(x)}{1 + \\delta_f(x)} \\quad \\text{和} \\quad g(x) = \\frac{\\hat{g}(x)}{1 + \\delta_g(x)}\n$$\n假设 $\\varepsilon_f(x)  1$ 和 $\\varepsilon_g(x)  1$（这是有意义计算的必要条件），我们可以为真实值建立严格的区间：\n$$\n\\frac{\\hat{f}(x)}{1 + \\varepsilon_f(x)} \\le f(x) \\le \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\\\\n\\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)} \\le g(x) \\le \\frac{\\hat{g}(x)}{1 - \\varepsilon_g(x)}\n$$\n为了鲁棒地验证 $f(x) \\le M g(x)$ 成立，我们必须证明 $f(x)$ 的最坏情况值不大于 $M g(x)$ 的最坏情况值。最坏情况对应于 $f(x)$ 的上界和 $M g(x)$ 的下界。\n$$\nf_{\\text{upper}}(x) = \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\\\\n(M g)_{\\text{lower}}(x) = M g_{\\text{lower}}(x) = M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}\n$$\n因此，为保证条件 $f(x) \\le M g(x)$ 成立，必须为真的鲁棒验证测试是：\n$$\nf_{\\text{upper}}(x) \\le (M g)_{\\text{lower}}(x) \\implies \\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\le M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}\n$$\n\n### II. 安全膨胀策略的推导\n\n如果我们不希望对每次求值都执行验证测试，可以改用一个能保证正确性的膨胀常数 $M' > M$。为防止错误接受，我们必须确保任何被浮点算法接受的点也会被精确算法接受。实现的接受条件是，对于抽取的 $X \\sim g$ 和 $U \\sim \\mathrm{Uniform}(0,1)$，有 $U \\le \\frac{\\hat{f}(X)}{M' \\hat{g}(X)}$。而真实的条件是 $U \\le \\frac{f(X)}{M g(X)}$。为了保证正确性，实现的接受比率必须是真实比率的下界：\n$$\n\\frac{\\hat{f}(x)}{M' \\hat{g}(x)} \\le \\frac{f(x)}{M g(x)}\n$$\n代入关系式 $\\hat{f}(x) = f(x)(1+\\delta_f)$ 和 $\\hat{g}(x) = g(x)(1+\\delta_g)$：\n$$\n\\frac{f(x)(1+\\delta_f)}{M' g(x)(1+\\delta_g)} \\le \\frac{f(x)}{M g(x)}\n$$\n$$\n\\frac{1+\\delta_f}{M'(1+\\delta_g)} \\le \\frac{1}{M} \\implies M(1+\\delta_f) \\le M'(1+\\delta_g)\n$$\n为确保此不等式对所有可能的误差都成立，我们必须找到一个在最坏情况下满足该不等式的 $M'$。当分子 $1+\\delta_f$ 最大化且分母 $1+\\delta_g$ 最小化时，项 $\\frac{1+\\delta_f}{1+\\delta_g}$ 达到最大值：\n$$\n\\max(\\text{numerator}) = 1 + \\varepsilon_f(x) \\\\\n\\min(\\text{denominator}) = 1 - \\varepsilon_g(x)\n$$\n所以，我们必须选择 $M'$ 使得：\n$$\nM' \\ge M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)}\n$$\n为了最小化对接受率（即 $1/M'$）的影响，我们应该选择最小的可能 $M'$。这给出了一个局部膨胀策略：\n$$\nM'(x) = M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)}\n$$\n对于一个全局常数 $M'$，我们必须取其在所有 $x \\in \\mathcal{X}$ 上的上确界：\n$$\nM' = \\sup_{x \\in \\mathcal{X}} \\left( M \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)} \\right) = M \\sup_{x \\in \\mathcal{X}} \\left( \\frac{1+\\varepsilon_f(x)}{1-\\varepsilon_g(x)} \\right)\n$$\n使用保守的全局界限 $\\varepsilon_f^\\star \\ge \\sup_x \\varepsilon_f(x)$ 和 $\\varepsilon_g^\\star \\ge \\sup_x \\varepsilon_g(x)$，一个安全的全局常数是：\n$$\nM' = M \\frac{1+\\varepsilon_f^\\star}{1-\\varepsilon_g^\\star}\n$$\n\n### III. 逐项分析\n\n*   **A.** 此选项提出的验证测试 $\\frac{\\hat{f}(x)}{1 - \\varepsilon_f(x)} \\le M \\frac{\\hat{g}(x)}{1 + \\varepsilon_g(x)}$ 和膨胀策略 $M' = M \\frac{1 + \\varepsilon_f^\\star}{1 - \\varepsilon_g^\\star}$ 与我们的推导完全吻合。它正确地指出对接受率的影响是一个乘法因子。它还正确地说明，对于一个安全的挤压测试，应该使用一个保证为 $s(x)$ 下界的计算值 $\\hat{s}(x)$（例如，通过向下舍入），并与膨胀后的包络 $M'\\hat{g}(x)$ 进行比较。该选项的每个部分都与严谨的数值分析一致。**正确**。\n\n*   **B.** 此选项提出的验证测试和膨胀策略基于加性误差聚合，例如 $M' = M (1 + \\varepsilon_f^\\star + \\varepsilon_g^\\star)$。这来自一阶近似：$\\frac{1+\\varepsilon_f}{1-\\varepsilon_g} \\approx (1+\\varepsilon_f)(1+\\varepsilon_g) \\approx 1+\\varepsilon_f+\\varepsilon_g$。这不是一个严格的界。“安全”和“鲁棒”的验证需要严格的不等式，而不是近似。高阶项被忽略，这可能导致不安全的包络常数 $M'$ 过小。此外，所提出的验证测试也基于错误的近似。**不正确**。\n\n*   **C.** 此选项引入了一个加性容差 $\\tau(x)$，它并非从给定的相对误差界 $\\varepsilon_f(x)$ 和 $\\varepsilon_g(x)$ 推导出来的。其形式 $\\tau(x) = u \\max\\{\\dots\\}$ 是启发式的，只考虑了单个运算的误差，而不是复合函数 $f$ 和 $g$ 的误差。加性膨胀策略 $M' = M + \\tau^\\star/\\inf g(x)$ 在量纲上不一致（如果 $g$ 是密度，其单位为 $1/\\text{volume}$），并且如果 $\\inf g(x)$ 接近于零，可能导致病态的大幅膨胀。该方法与问题的前提不一致。**不正确**。\n\n*   **D.** 此选项建议使用定向舍入，即计算 $f(x)$ 的上界 $\\hat{f}^\\uparrow(x)$ 和 $g(x)$ 的下界 $\\hat{g}^\\downarrow(x)$。测试 $\\hat{f}^\\uparrow(x) \\le M \\hat{g}^\\downarrow(x)$ 是鲁棒验证的有效方法。然而，问题陈述的前提是可获得带有后验误差界 $\\varepsilon_f, \\varepsilon_g$ 的计算值 $\\hat{f}(x)$ 和 $\\hat{g}(x)$，这意味着使用标准（例如，四舍五入到最近）算术，而不是特殊的定向舍入模式。因此，该选项提出了一种不同的实现方法，而不是基于给定工具的解决方案。此外，其膨胀策略 $M' = M(1+u)^k$ 是有缺陷的，因为它只考虑了 $g$ 中的前向误差传播，而完全忽略了 $f$ 中的误差。**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "为了满足大规模模拟的需求，算法必须适应现代并行硬件（如 GPU）。最后一个练习探讨了“硬件感知”采样器的设计，特别关注于如何最小化 GPU 的 SIMD 执行模型中的线程束发散（warp divergence）。通过设计量化的封套和挤压函数，你将学习如何分析和优化统计效率（接受率）与硬件效率（SIMD 利用率）之间的权衡 。",
            "id": "3335770",
            "problem": "你的任务是设计和分析一种带有提议选择、包络和挤压的拒绝采样方法，使其适用于图形处理器（GPU）的单指令多数据（SIMD）执行。设定如下。在 $[0,1]$ 上的目标概率密度函数 $f_{\\alpha}(x)$ 由贝塔分布族 $f_{\\alpha}(x) = \\alpha x^{\\alpha - 1}$ 给出，参数 $\\alpha \\ge 1$。选择 $[0,1]$ 上的均匀密度作为提议分布 $g(x)$。设 $M$ 为一个有限常数，满足对于所有 $x \\in [0,1]$ 都有 $f_{\\alpha}(x) \\le M g(x)$。考虑以下形式的拒绝采样：从 $g$ 采样 $x$，从 $\\mathrm{Uniform}(0,1)$ 采样 $u$，如果 $u \\le f_{\\alpha}(x)/(M g(x))$ 则接受 $x$，否则拒绝。为了降低评估成本并在线程间对齐分支决策，为 $f_{\\alpha}(x)$ 定义一个下界挤压函数 $s(x)$ 和一个上界包络函数 $e(x)$，使得对所有 $x \\in [0,1]$ 都有 $s(x) \\le f_{\\alpha}(x) \\le e(x)$。然后实现以下分支结构，这是加速拒绝采样中的标准做法：\n- 如果 $u \\le s(x)/(M g(x))$，则接受 $x$ 而无需评估 $f_{\\alpha}(x)$。\n- 否则，如果 $u  e(x)/(M g(x))$，则拒绝 $x$ 而无需评估 $f_{\\alpha}(x)$。\n- 否则，评估 $f_{\\alpha}(x)$，如果 $u \\le f_{\\alpha}(x)/(M g(x))$ 则接受 $x$。\n\n设计 $s(x)$ 和 $e(x)$，通过量化定义域来对齐线程间的分支决策并减少分歧。具体来说，将 $[0,1]$ 划分为 $K$ 个等宽的区间 $B_k = [\\frac{k-1}{K}, \\frac{k}{K}]$（其中 $k \\in \\{1,2,\\dots,K\\}$），并定义 $s(x)$ 和 $e(x)$ 在每个区间上为分段常数，使用 $f_{\\alpha}(x)$ 在各区间内的极值作为挤压和包络函数。也就是说，对于 $x \\in B_k$，令 $s(x)$ 等于 $f_{\\alpha}(x)$ 在 $B_k$ 上的最小值，令 $e(x)$ 等于 $f_{\\alpha}(x)$ 在 $B_k$ 上的最大值。在 $g(x)$ 为 $[0,1]$ 上的均匀分布的情况下，这种构造产生的分支概率仅取决于区间端点和 $\\alpha$。\n\n定义一个大小为 $W$ 的线程束（warp），其中的线程按照单指令多数据（SIMD）的方式同步执行。设执行每个分支的单线程成本分别为：提早接受分支为 $\\tau_a$，提早拒绝分支为 $\\tau_r$，以及评估 $f_{\\alpha}(x)$ 的中间分支为 $\\tau_m$。各线程独立抽取其 $(x,u)$ 对。将 SIMD 效率定义为“每个线程的预期总工作量”与“预期线程束时间工作量”之比，其中线程束时间工作量聚合了线程束中至少有一个线程执行的每个分支所贡献的成本。效率应为 $[0,1]$ 内的一个数字，并且必须从第一性原理出发，基于线程的独立性、拒绝采样的定义以及包络和挤压函数的定义进行推导。\n\n你的任务是：\n- 从上述形式化定义出发，在均匀提议分布 $g(x)$ 和分段常数 $s(x)$、$e(x)$ 的构造下，推导出以 $\\alpha$ 和 $K$ 表示的提早接受概率、提早拒绝概率和中间区域概率的表达式。\n- 在线程独立和所述分支结构的条件下，推导预期 SIMD 效率作为 $\\alpha$、$K$、$W$、$\\tau_a$、$\\tau_r$ 和 $\\tau_m$ 的函数的解析表达式。推导必须从核心定义开始，不得假设任何预先指定的快捷公式。\n- 实现一个完整、可运行的程序，为指定的测试用例计算 SIMD 效率。该程序必须只执行确定性计算，不得使用任何随机性。\n\n使用以下测试套件，每个用例指定为 $(\\alpha, K, W, \\tau_a, \\tau_r, \\tau_m)$：\n- 用例 1：$(1, 64, 32, 1.0, 1.0, 8.0)$，目标分布为均匀分布的边界情况。\n- 用例 2：$(2, 32, 32, 1.0, 1.0, 8.0)$，中等形状和中等区间数量。\n- 用例 3：$(64, 32, 32, 1.0, 1.0, 8.0)$，目标分布急剧递增，区间数量中等。\n- 用例 4：$(4, 1, 32, 1.0, 1.0, 8.0)$，只有一个区间的边缘情况。\n- 用例 5：$(4, 64, 64, 1.0, 1.0, 8.0)$，更大的线程束大小和与之对齐的区间数量。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的浮点数列表，按上述用例的顺序排列（例如，$[r_1,r_2,r_3,r_4,r_5]$）。此问题不涉及任何物理单位或角度单位；所有输出均为无量纲的浮点数。",
            "solution": "该问题是推导并计算一种加速拒绝采样算法的单指令多数据（SIMD）效率。推导必须从第一性原理出发。\n\n首先，我们形式化拒绝采样算法的各个组成部分。\n目标概率密度函数（PDF）来自贝塔分布族，由 $f_{\\alpha}(x) = \\alpha x^{\\alpha - 1}$ 给出，其中 $x \\in [0,1]$ 且参数 $\\alpha \\ge 1$。\n提议 PDF 是 $[0,1]$ 上的均匀密度，$g(x) = 1$。\n拒绝采样方法需要一个常数 $M$，使得对所有 $x \\in [0,1]$ 都有 $f_{\\alpha}(x) \\le M g(x)$。给定 $g(x)=1$，此不等式为 $f_{\\alpha}(x) \\le M$。为了找到满足条件的最小 $M$，我们求 $f_{\\alpha}(x)$ 的最大值。其导数为 $f'_{\\alpha}(x) = \\alpha(\\alpha-1)x^{\\alpha-2}$。由于 $\\alpha \\ge 1$，对于 $x \\in [0,1]$，$f'_{\\alpha}(x) \\ge 0$，这意味着 $f_{\\alpha}(x)$ 是一个非递减函数。它在 $[0,1]$ 上的最大值出现在 $x=1$处，此时 $f_{\\alpha}(1) = \\alpha(1)^{\\alpha-1} = \\alpha$。我们选择最优常数 $M = \\alpha$。\n核心拒绝条件为 $u \\le \\frac{f_{\\alpha}(x)}{M g(x)}$，其中 $u \\sim \\mathrm{Uniform}(0,1)$。代入我们的函数，该条件变为 $u \\le \\frac{\\alpha x^{\\alpha-1}}{\\alpha \\cdot 1} = x^{\\alpha-1}$。\n\n接下来，我们定义挤压函数 $s(x)$ 和包络函数 $e(x)$。定义域 $[0,1]$ 被划分为 $K$ 个等宽的区间，$B_k = [\\frac{k-1}{K}, \\frac{k}{K}]$，其中 $k \\in \\{1, 2, \\dots, K\\}$。对于任何 $x \\in B_k$，$s(x)$ 和 $e(x)$ 分别定义为 $f_{\\alpha}(x)$ 在 $B_k$ 上的最小值和最大值。由于 $f_{\\alpha}(x)$ 是非递减的，这些极值出现在区间的端点处：\n对于 $x \\in B_k$：\n$s(x) = \\min_{z \\in B_k} f_{\\alpha}(z) = f_{\\alpha}\\left(\\frac{k-1}{K}\\right) = \\alpha \\left(\\frac{k-1}{K}\\right)^{\\alpha-1}$\n$e(x) = \\max_{z \\in B_k} f_{\\alpha}(z) = f_{\\alpha}\\left(\\frac{k}{K}\\right) = \\alpha \\left(\\frac{k}{K}\\right)^{\\alpha-1}$\n\n加速拒绝采样算法使用一个三阶段分支结构。抽取一个样本对 $(x, u)$，其中 $x \\sim g$，$u \\sim \\mathrm{Uniform}(0,1)$。\n$1$. 如果 $u \\le \\frac{s(x)}{M g(x)} = \\frac{s(x)}{\\alpha}$，则提早接受。\n$2$. 如果 $u  \\frac{e(x)}{M g(x)} = \\frac{e(x)}{\\alpha}$，则提早拒绝。\n$3$. 否则进入中间分支，在此评估 $f_{\\alpha}(x)$。\n\n单个线程进入每个分支的概率（$p_a, p_r, p_m$）由 $(x, u)$ 的联合分布决定，该分布在单位正方形 $[0,1] \\times [0,1]$ 上是均匀的。这些概率是相应区域的面积。\n提早接受概率 $p_a$ 为：\n$$p_a = P\\left(u \\le \\frac{s(x)}{\\alpha}\\right) = \\int_0^1 \\frac{s(x)}{\\alpha} dx$$\n由于 $s(x)$ 是分段常数，我们将每个区间上的积分相加：\n$$p_a = \\sum_{k=1}^K \\int_{\\frac{k-1}{K}}^{\\frac{k}{K}} \\frac{1}{\\alpha} \\left(\\alpha \\left(\\frac{k-1}{K}\\right)^{\\alpha-1}\\right) dx = \\sum_{k=1}^K \\frac{1}{K} \\left(\\frac{k-1}{K}\\right)^{\\alpha-1} = \\frac{1}{K^\\alpha} \\sum_{k=1}^K (k-1)^{\\alpha-1}$$\n通过使用 $j=k-1$ 重新索引，我们得到 $p_a = \\frac{1}{K^\\alpha} \\sum_{j=0}^{K-1} j^{\\alpha-1}$。注意，当 $\\alpha=1$ 时，$0^0=1$。\n\n提早拒绝概率 $p_r$ 为：\n$$p_r = P\\left(u  \\frac{e(x)}{\\alpha}\\right) = \\int_0^1 \\left(1 - \\frac{e(x)}{\\alpha}\\right) dx$$\n$$p_r = \\sum_{k=1}^K \\int_{\\frac{k-1}{K}}^{\\frac{k}{K}} \\left(1 - \\frac{1}{\\alpha} \\alpha \\left(\\frac{k}{K}\\right)^{\\alpha-1}\\right) dx = \\sum_{k=1}^K \\frac{1}{K} \\left(1 - \\left(\\frac{k}{K}\\right)^{\\alpha-1}\\right) = 1 - \\frac{1}{K^\\alpha} \\sum_{k=1}^K k^{\\alpha-1}$$\n\n中间分支概率 $p_m$ 对应于挤压函数和包络函数之间的区域。由于这些分支是互斥的并且涵盖了所有可能性，所以 $p_m = 1 - p_a - p_r$。\n$$p_m = 1 - \\left(\\frac{1}{K^\\alpha} \\sum_{j=0}^{K-1} j^{\\alpha-1}\\right) - \\left(1 - \\frac{1}{K^\\alpha} \\sum_{k=1}^K k^{\\alpha-1}\\right) = \\frac{1}{K^\\alpha} \\left(\\sum_{k=1}^K k^{\\alpha-1} - \\sum_{j=0}^{K-1} j^{\\alpha-1}\\right)$$\n这两个和的差是 $(1^{\\alpha-1} + \\dots + K^{\\alpha-1}) - (0^{\\alpha-1} + \\dots + (K-1)^{\\alpha-1}) = K^{\\alpha-1} - 0^{\\alpha-1}$。\n因此，$p_m = \\frac{K^{\\alpha-1} - 0^{\\alpha-1}}{K^\\alpha} = \\frac{1}{K} - \\frac{0^{\\alpha-1}}{K^\\alpha}$。对于 $\\alpha1$，$p_m=1/K$。对于 $\\alpha=1$，$0^{\\alpha-1}=0^0=1$，所以 $p_m=0$。\n\n现在，我们推导 SIMD 效率。\n设 $C_i$ 是线程 $i$ 的执行成本，这是一个从 $\\{\\tau_a, \\tau_r, \\tau_m\\}$ 中取值的随机变量。每个线程的预期工作量为：\n$$E_{thread} = E[C_i] = \\tau_a p_a + \\tau_r p_r + \\tau_m p_m$$\n根据定义，线程束时间工作量聚合了大小为 $W$ 的线程束中至少有一个线程执行的所有分支的成本。设 $A_W$、$R_W$ 和 $M_W$ 为指示变量，如果至少有一个线程分别进入提早接受、提早拒绝或中间分支，则值为 1。线程束时间工作量为 $C_{warp} = \\tau_a A_W + \\tau_r R_W + \\tau_m M_W$。预期的线程束时间工作量为 $E_{warp} = E[C_{warp}] = \\tau_a E[A_W] + \\tau_r E[R_W] + \\tau_m E[M_W]$。\n指示变量的期望是事件发生的概率。由于线程是独立的：\n$E[A_W] = P(A_W=1) = 1 - P(\\text{没有线程进入提早接受分支}) = 1 - (1 - p_a)^W$。\n类似地，$E[R_W] = 1 - (1-p_r)^W$，$E[M_W] = 1 - (1-p_m)^W$。\n所以，预期的线程束时间工作量是：\n$$E_{warp} = \\tau_a(1 - (1-p_a)^W) + \\tau_r(1 - (1-p_r)^W) + \\tau_m(1 - (1-p_m)^W)$$\nSIMD 效率 $\\eta$ 定义为每个线程的预期总工作量与预期线程束时间工作量之比。\n$$\\eta = \\frac{E_{thread}}{E_{warp}} = \\frac{\\tau_a p_a + \\tau_r p_r + \\tau_m p_m}{\\tau_a(1 - (1-p_a)^W) + \\tau_r(1 - (1-p_r)^W) + \\tau_m(1 - (1-p_m)^W)}$$\n这些推导出的表达式被实现用于解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the SIMD efficiency for rejection sampling based on a derived analytical formula.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, K, W, tau_a, tau_r, tau_m)\n    test_cases = [\n        (1.0, 64, 32, 1.0, 1.0, 8.0),   # Case 1\n        (2.0, 32, 32, 1.0, 1.0, 8.0),   # Case 2\n        (64.0, 32, 32, 1.0, 1.0, 8.0),  # Case 3\n        (4.0, 1, 32, 1.0, 1.0, 8.0),    # Case 4\n        (4.0, 64, 64, 1.0, 1.0, 8.0)    # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, K, W, tau_a, tau_r, tau_m = case\n        K = int(K)\n        W = int(W)\n\n        # The derivation of probabilities is robust for alpha >= 1, including alpha = 1\n        # where 0^0 is handled as 1 by numpy.power, which is the correct convention here.\n        # No special case for alpha=1 is needed.\n        \n        # Calculate branch probabilities p_a, p_r, p_m\n        \n        # p_a = (1/K^alpha) * sum_{j=0}^{K-1} j^(alpha-1)\n        j = np.arange(K, dtype=np.float64)\n        alpha_minus_1 = alpha - 1.0\n        \n        # Use np.power for robust handling of 0^0\n        sum_for_pa = np.sum(np.power(j, alpha_minus_1))\n        K_to_alpha = np.power(float(K), alpha)\n        \n        p_a = sum_for_pa / K_to_alpha\n\n        # p_r = 1 - (1/K^alpha) * sum_{k=1}^{K} k^(alpha-1)\n        k = np.arange(1, K + 1, dtype=np.float64)\n        sum_for_pr = np.sum(np.power(k, alpha_minus_1))\n        \n        p_r = 1.0 - (sum_for_pr / K_to_alpha)\n        \n        # p_m = 1 - p_a - p_r for numerical stability\n        p_m = 1.0 - p_a - p_r\n        \n        # If K=1, then p_a=0, p_r=0, p_m=1. Correct small numerical errors.\n        if K == 1:\n            p_a, p_r, p_m = 0.0, 0.0, 1.0\n        \n        # Calculate expected per-thread work\n        E_thread = tau_a * p_a + tau_r * p_r + tau_m * p_m\n        \n        # If E_thread is zero, efficiency is zero (unless E_warp is also zero)\n        if E_thread == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate expected warp-time work\n        # E_warp = tau_a(1-(1-p_a)^W) + tau_r(1-(1-p_r)^W) + tau_m(1-(1-p_m)^W)\n        prob_no_a = np.power(1.0 - p_a, float(W))\n        prob_no_r = np.power(1.0 - p_r, float(W))\n        prob_no_m = np.power(1.0 - p_m, float(W))\n        \n        E_warp = tau_a * (1.0 - prob_no_a) + tau_r * (1.0 - prob_no_r) + tau_m * (1.0 - prob_no_m)\n        \n        # Calculate SIMD efficiency\n        if E_warp == 0.0:\n            # This case occurs if all costs are 0, or if all probabilities are 0.\n            # If E_thread is also 0, efficiency is indeterminate. Let's define it as 1.0.\n            eta = 1.0\n        else:\n            eta = E_thread / E_warp\n        \n        results.append(eta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}