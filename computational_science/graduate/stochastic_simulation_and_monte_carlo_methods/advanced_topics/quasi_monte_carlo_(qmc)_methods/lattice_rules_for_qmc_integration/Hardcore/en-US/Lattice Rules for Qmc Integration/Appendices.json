{
    "hands_on_practices": [
        {
            "introduction": "The power of lattice rules for quasi-Monte Carlo integration stems from a deep connection between the geometry of the lattice and the integration error, which is elegantly described in the Fourier domain. This exercise provides a foundational workout, tasking you with identifying the specific dual lattice vectors that dictate the error for a given rule . By explicitly calculating their contribution for a function with a typical Fourier decay, you will build a concrete understanding of how the structure of the dual lattice directly controls the accuracy of the QMC estimate.",
            "id": "3317421",
            "problem": "Consider a rank-one lattice rule for Quasi-Monte Carlo (QMC) integration on the two-dimensional torus with generator vector $g=(1,4)$ and number of points $N=13$. The lattice point set is defined by $x_{n}=\\{\\frac{n g}{N}\\}$ for $n=0,1,\\dots,12$, where $\\{\\cdot\\}$ denotes the component-wise fractional part. Let $f:[0,1]^{2}\\rightarrow \\mathbb{C}$ be a periodic function (period $1$ in each coordinate) with Fourier expansion $f(x)=\\sum_{h\\in\\mathbb{Z}^{2}} \\hat{f}(h) \\exp(2\\pi i\\, h\\cdot x)$, where $h\\cdot x=h_{1}x_{1}+h_{2}x_{2}$. The rank-one lattice rule approximation to $\\int_{[0,1]^{2}} f(x)\\,dx$ is $Q_{N}(f)=\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_{n})$.\n\nStarting from the foundational identity that the discrete exponential sum $\\frac{1}{N}\\sum_{n=0}^{N-1}\\exp\\!\\big(2\\pi i\\, n\\, t\\big)$ equals $1$ if $t\\in \\mathbb{Z}$ and $0$ otherwise, derive the condition under which a Fourier mode $\\exp(2\\pi i\\, h\\cdot x)$ aliases under the lattice rule, and show how the quadrature error $Q_{N}(f)-\\int_{[0,1]^2} f(x)\\, dx$ depends on the subset of Fourier coefficients that satisfy the aliasing condition.\n\nThen, explicitly enumerate all nonzero integer vectors $h=(h_{1},h_{2})$ satisfying the dual congruence $h\\cdot g\\equiv 0 \\pmod{N}$ with $\\|h\\|_{\\infty}\\leq 3$, where $\\|h\\|_{\\infty}=\\max\\{|h_{1}|,|h_{2}|\\}$. Finally, assume a Fourier decay model $|\\hat{f}(h)|=c\\, \\|h\\|_{2}^{-2}$ for all $h\\neq 0$, where $c>0$ is a constant and $\\|h\\|_{2}=\\sqrt{h_{1}^{2}+h_{2}^{2}}$. Compute the sum of absolute contributions to the magnitude of the quadrature error coming from the enumerated dual vectors with $\\|h\\|_{\\infty}\\leq 3$, and provide your final answer as a simplified analytic expression in terms of $c$. No rounding is required.",
            "solution": "The analysis proceeds in three stages: deriving the quadrature error formula, enumerating the relevant dual lattice vectors, and calculating their contribution to the error.\n\nFirst, we derive the error formula. The true integral of a periodic function $f$ is its zeroth Fourier coefficient, $I(f) = \\int_{[0,1]^2} f(x) dx = \\hat{f}(\\boldsymbol{0})$. The lattice rule approximation is $Q_N(f) = \\frac{1}{N}\\sum_{n=0}^{N-1} f(\\boldsymbol{x}_n)$. Substituting the Fourier series for $f$ gives:\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{\\boldsymbol{h} \\in \\mathbb{Z}^2} \\hat{f}(\\boldsymbol{h}) \\exp(2\\pi i \\boldsymbol{h} \\cdot \\boldsymbol{x}_n) = \\sum_{\\boldsymbol{h} \\in \\mathbb{Z}^2} \\hat{f}(\\boldsymbol{h}) \\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\exp\\left(2\\pi i n \\frac{\\boldsymbol{h} \\cdot \\boldsymbol{g}}{N}\\right) \\right)\n$$\nThe inner sum over $n$ is a geometric series. Based on the provided identity, this sum evaluates to $1$ if $\\boldsymbol{h} \\cdot \\boldsymbol{g}$ is an integer multiple of $N$ (i.e., $\\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\pmod N$), and $0$ otherwise. This condition defines the **dual lattice**, $L^\\perp = \\{ \\boldsymbol{h} \\in \\mathbb{Z}^2 \\mid \\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\pmod N \\}$.\nThus, the QMC approximation simplifies to a sum over the dual lattice:\n$$\nQ_N(f) = \\sum_{\\boldsymbol{h} \\in L^\\perp} \\hat{f}(\\boldsymbol{h})\n$$\nThe quadrature error $E_N(f) = Q_N(f) - I(f)$ is the difference between this sum and $\\hat{f}(\\boldsymbol{0})$. Since the zero vector $\\boldsymbol{h}=\\boldsymbol{0}$ is always in the dual lattice, the error is the sum over all *non-zero* vectors in the dual lattice:\n$$\nE_N(f) = \\sum_{\\boldsymbol{h} \\in L^\\perp \\setminus \\{\\boldsymbol{0}\\}} \\hat{f}(\\boldsymbol{h})\n$$\n\nNext, we find all non-zero integer vectors $\\boldsymbol{h}=(h_1, h_2)$ that satisfy the dual congruence for $\\boldsymbol{g}=(1,4)$ and $N=13$, with the constraint $\\|h\\|_{\\infty} \\leq 3$. This means $h_1, h_2 \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$. The congruence is:\n$$\nh_1 \\cdot 1 + h_2 \\cdot 4 \\equiv 0 \\pmod{13}\n$$\nGiven the range of $h_1$ and $h_2$, the expression $h_1 + 4h_2$ is bounded between $-3 + 4(-3) = -15$ and $3 + 4(3) = 15$. The integer multiples of $13$ in this interval are $-13, 0, 13$.\n- Case 1: $h_1 + 4h_2 = 13$. If $h_2=3$, then $h_1 = 1$. This is a valid solution, $\\boldsymbol{h}=(1,3)$. If $h_2=2$, $h_1=5$, which is out of range.\n- Case 2: $h_1 + 4h_2 = 0$. This only has the solution $\\boldsymbol{h}=(0,0)$ within the box, which we exclude.\n- Case 3: $h_1 + 4h_2 = -13$. If $h_2=-3$, then $h_1 = -1$. This is a valid solution, $\\boldsymbol{h}=(-1,-3)$. If $h_2=-2$, $h_1=-5$, which is out of range.\n\nThe set of non-zero dual vectors satisfying the conditions is $\\{ (1,3), (-1,-3) \\}$.\n\nFinally, we compute the sum of the absolute values of the Fourier coefficients for these vectors, using the model $|\\hat{f}(\\boldsymbol{h})| = c / \\|\\boldsymbol{h}\\|_2^2$.\nFor $\\boldsymbol{h}=(1,3)$:\n$\\|\\boldsymbol{h}\\|_2^2 = 1^2 + 3^2 = 10$.\n$|\\hat{f}((1,3))| = \\frac{c}{10}$.\n\nFor $\\boldsymbol{h}=(-1,-3)$:\n$\\|\\boldsymbol{h}\\|_2^2 = (-1)^2 + (-3)^2 = 10$.\n$|\\hat{f}((-1,-3))| = \\frac{c}{10}$.\n\nThe total contribution to the error magnitude from these vectors is the sum:\n$$\n\\frac{c}{10} + \\frac{c}{10} = \\frac{2c}{10} = \\frac{c}{5}\n$$",
            "answer": "$$\n\\boxed{\\frac{c}{5}}\n$$"
        },
        {
            "introduction": "Theory becomes vivid when we examine not just successes, but also failures. This practice presents a carefully crafted 'worst-case' scenario to illustrate the critical importance of choosing a good generating vector . You will analyze a lattice rule whose dual contains a very short, non-zero vector and see how this structural flaw causes a specific periodic function to be aliased to a constant, leading to a maximal integration error. This hands-on diagnosis will solidify your intuition for why the search for long dual vectors is paramount in QMC.",
            "id": "3317438",
            "problem": "Consider a rank-$1$ Quasi-Monte Carlo (QMC) lattice rule in dimension $s=3$ with $N=8$ points and generating vector $z=(1,2,4)$. The node set is given by $x_{j}=\\{j z / N\\}$ for $j=0,\\dots,N-1$, where the braces denote reduction modulo $1$ componentwise. Define the linear map $g:[0,1)^{3}\\to[0,1)^{3}$ by $g(u)=G u \\bmod 1$ with the integer matrix\n$$\nG=\\begin{pmatrix}\n0 & 0 & 2\\\\\n1 & 0 & 0\\\\\n0 & 1 & 0\n\\end{pmatrix},\n$$\nand consider the periodic integrand\n$$\nf(u)=\\cos\\!\\big(2\\pi\\, e_{1}^{\\top} g(u)\\big),\\quad u\\in[0,1)^{3},\n$$\nwhere $e_{1}=(1,0,0)^{\\top}$. The lattice rule estimator is $Q_{N}(f)=\\frac{1}{N}\\sum_{j=0}^{N-1} f(x_{j})$ and the true integral is $I(f)=\\int_{[0,1)^{3}} f(u)\\,du$.\n\nUsing only the core definitions of rank-$1$ lattice rules, the dual lattice $L^{\\perp}=\\{h\\in\\mathbb{Z}^{3}: h\\cdot z\\equiv 0 \\,(\\mathrm{mod}\\, N)\\}$, basic trigonometric-exponential identities, and orthogonality of roots of unity, do the following:\n- Determine the shortest nonzero vector in $L^{\\perp}$ with respect to the Euclidean norm and explain how the chosen $g$ aligns $f$ along the corresponding low-dimensional subspace.\n- Compute $Q_{N}(f)$ and $I(f)$ from first principles, and hence the bias $Q_{N}(f)-I(f)$.\n\nReport the bias $Q_{N}(f)-I(f)$ as your final answer. Express your final answer exactly (no rounding).",
            "solution": "The solution proceeds by first analyzing the dual lattice and the function, then computing the true integral and the QMC estimate, and finally calculating the bias.\n\n**1. Dual Lattice and Function Analysis**\n\nThe dual lattice $L^\\perp$ for $N=8$ and $z=(1,2,4)^\\top$ is the set of integer vectors $h=(h_1, h_2, h_3)^\\top$ such that $h_1 + 2h_2 + 4h_3 \\equiv 0 \\pmod 8$. By testing integer vectors with increasing norm, we find that the shortest non-zero vector in $L^\\perp$ is $h^* = (0,0,2)^\\top$, since $0\\cdot1 + 0\\cdot2 + 2\\cdot4 = 8 \\equiv 0 \\pmod 8$. The squared Euclidean norm is $\\|h^*\\|^2 = 4$.\n\nNext, we analyze the integrand $f(u) = \\cos(2\\pi\\, e_{1}^{\\top} g(u))$. The argument of the cosine is determined by the linear transformation:\n$$\ne_1^\\top G u = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 2 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix} = 2u_3\n$$\nThe vector of coefficients $(0,0,2)$ is precisely the shortest non-zero dual lattice vector $h^*$. Therefore, the integrand is $f(u) = \\cos(2\\pi (2u_3)) = \\cos(4\\pi u_3)$. This is equivalent to $\\cos(2\\pi h^* \\cdot u)$, which shows the function has been deliberately constructed to oscillate only in the direction of a short vector in the dual lattice.\n\n**2. Computation of the True Integral $I(f)$**\n\nThe true integral of $f(u)$ over the unit cube $[0,1)^3$ is:\n$$\nI(f) = \\int_0^1 \\int_0^1 \\int_0^1 \\cos(4\\pi u_3) \\, du_1 \\, du_2 \\, du_3\n$$\nSince the integrand is independent of $u_1$ and $u_2$, integrating with respect to them yields a factor of $1$. The remaining integral is:\n$$\nI(f) = \\int_0^1 \\cos(4\\pi u_3) \\, du_3 = \\left[ \\frac{\\sin(4\\pi u_3)}{4\\pi} \\right]_0^1 = \\frac{\\sin(4\\pi) - \\sin(0)}{4\\pi} = 0\n$$\nThe true integral is $0$.\n\n**3. Computation of the QMC Estimator $Q_N(f)$ and Bias**\n\nThe QMC estimator is $Q_N(f) = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_j)$. The value of the function at a lattice point $x_j=\\{jz/N\\}$ is:\n$$\nf(x_j) = \\cos(2\\pi h^* \\cdot x_j) = \\cos\\left(2\\pi h^* \\cdot \\frac{jz}{N}\\right)\n$$\nThe argument of the cosine is $2\\pi j \\frac{h^* \\cdot z}{N}$. We calculate the dot product $h^* \\cdot z$:\n$$\nh^* \\cdot z = (0,0,2) \\cdot (1,2,4) = 8\n$$\nSince $N=8$, the argument becomes $2\\pi j \\frac{8}{8} = 2\\pi j$. For any integer $j$, $\\cos(2\\pi j) = 1$. Therefore, $f(x_j) = 1$ for all lattice points $j=0, \\dots, N-1$.\n\nThe QMC estimator is the average of these values:\n$$\nQ_N(f) = \\frac{1}{8} \\sum_{j=0}^{7} 1 = \\frac{1}{8} \\cdot 8 = 1\n$$\nThe bias (integration error) is the difference between the estimate and the true integral:\n$$\n\\text{Bias} = Q_N(f) - I(f) = 1 - 0 = 1\n$$\nThis maximal error occurs because the lattice rule samples the function only at its peaks, completely missing its oscillatory nature. This is a classic example of aliasing, where the frequency $h^*$ is aliased to the zero frequency by the lattice.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "After understanding how to analyze a lattice rule, the natural next step is to synthesize one. This exercise transitions from analysis to construction, introducing two standard methods for finding effective generating vectors: the Korobov construction and the more sophisticated component-by-component (CBC) search . You will implement these algorithms to search for generators that maximize a key figure of merit—the squared length of the shortest non-zero dual vector—gaining practical experience in building high-quality point sets for multidimensional integration.",
            "id": "3317409",
            "problem": "Consider a rank-1 lattice rule with modulus $N \\in \\mathbb{N}$ and a generator vector $\\boldsymbol{g} \\in \\{1,2,\\dots,N-1\\}^s$ in $s$ dimensions. The corresponding point set is $\\{\\{n \\boldsymbol{g} / N\\} : n = 0,1,\\dots,N-1\\}$, where the braces denote the fractional part applied componentwise. For a prime modulus $N$, define the dual constraint on integer vectors $\\boldsymbol{h} \\in \\mathbb{Z}^s$ by the congruence\n$$\n\\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\pmod{N}.\n$$\nDefine the symmetric representative set for each coordinate as $\\{-\\lfloor N/2 \\rfloor, \\dots, 0, \\dots, \\lfloor N/2 \\rfloor\\}$. Because adding or subtracting multiples of $N$ in any coordinate preserves the congruence modulo $N$, every dual vector has a representative in this set with minimal absolute value per coordinate. The minimal Euclidean norm of a nonzero dual vector is then well-defined by\n$$\nm_2(\\boldsymbol{g}; N, s) \\;=\\; \\min_{\\substack{\\boldsymbol{h} \\in \\mathbb{Z}^s \\setminus \\{\\boldsymbol{0}\\} \\\\ \\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\; (\\mathrm{mod}\\; N)}} \\left\\{ \\|\\boldsymbol{h}\\|_2 \\;:\\; h_j \\in \\left[-\\frac{N-1}{2}, \\frac{N-1}{2}\\right] \\cap \\mathbb{Z} \\text{ for all } j \\right\\}.\n$$\nWe use the squared minimal norm $m_2^2(\\boldsymbol{g}; N, s)$ as an integer-valued figure of merit, with larger values indicating better uniformity as motivated by the spectral test in quasi-Monte Carlo analysis.\n\nYou are asked to implement and compare two generator constructions:\n\n1. Korobov construction: for a given base $a \\in \\{1,2,\\dots,N-1\\}$, define\n$$\n\\boldsymbol{g}(a) \\;=\\; \\left( a^0 \\bmod N, \\; a^1 \\bmod N, \\; \\dots, \\; a^{s-1} \\bmod N \\right).\n$$\n\n2. Component-by-component (CBC) construction using the spectral figure of merit: fix $g_1 = 1$, and for $d = 2,3,\\dots,s$ choose $g_d \\in \\{1,2,\\dots,N-1\\}$ to maximize $m_2^2\\big((g_1,\\dots,g_{d-1}, g_d); N, d\\big)$. Break ties by the smallest $g_d$.\n\nAlgorithmic base to derive and implement:\n\n- The dual constraint for a fixed choice of the first $s-1$ coordinates $h_1,\\dots,h_{s-1}$ uniquely determines $h_s$ modulo $N$ when $g_s \\not\\equiv 0 \\pmod{N}$:\n$$\nh_s \\equiv - \\left(\\sum_{j=1}^{s-1} h_j g_j\\right) \\cdot g_s^{-1} \\pmod{N},\n$$\nwhere $g_s^{-1}$ is the multiplicative inverse modulo $N$ (which exists since $N$ is prime and $g_s \\not\\equiv 0 \\pmod{N}$). The representative of $h_s$ is then chosen in the symmetric range $\\left[-\\frac{N-1}{2}, \\frac{N-1}{2}\\right] \\cap \\mathbb{Z}$ to minimize $|h_s|$. It suffices to search over all $(h_1,\\dots,h_{s-1})$ in this symmetric range and exclude the all-zero vector.\n\n- For the CBC construction in dimension $d$, evaluate the squared minimal norm $m_2^2$ for each candidate $g_d$ using the same search with dimension $d$, solving for the $d$-th coordinate from the first $d-1$.\n\nTask:\n\n- For each specified test case, compute:\n  1. The best Korobov squared minimal dual norm $m_{2,\\mathrm{Kor}}^2 = \\max_{a \\in \\mathcal{A}} m_2^2(\\boldsymbol{g}(a); N, s)$ over the given candidate set of bases $\\mathcal{A}$.\n  2. The CBC generator $\\boldsymbol{g}_{\\mathrm{CBC}}$ as described and its squared minimal dual norm $m_{2,\\mathrm{CBC}}^2 = m_2^2(\\boldsymbol{g}_{\\mathrm{CBC}}; N, s)$.\n  3. A comparison indicator $I$ defined by $I = 1$ if $m_{2,\\mathrm{CBC}}^2 \\ge m_{2,\\mathrm{Kor}}^2$ and $I = 0$ otherwise.\n\n- Your program must output the results for all test cases on a single line as a comma-separated Python-style list containing one sublist per test case in the order given. Each sublist must be of the form $[m_{2,\\mathrm{Kor}}^2, m_{2,\\mathrm{CBC}}^2, I]$ with all entries as integers.\n\nTest suite:\n\n- Case 1: $N = 29$, $s = 3$, $\\mathcal{A} = \\{2,3,5,7\\}$.\n- Case 2: $N = 29$, $s = 4$, $\\mathcal{A} = \\{2,3,8\\}$.\n- Case 3: $N = 29$, $s = 3$, $\\mathcal{A} = \\{11,12,13,14,15\\}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a Python-style list of three sublists, one per test case, in the exact form\n$[[m_{2,\\mathrm{Kor},1}^2, m_{2,\\mathrm{CBC},1}^2, I_1],[m_{2,\\mathrm{Kor},2}^2, m_{2,\\mathrm{CBC},2}^2, I_2],[m_{2,\\mathrm{Kor},3}^2, m_{2,\\mathrm{CBC},3}^2, I_3]]$,\nwith no additional text. All entries must be integers and there are no physical units involved.",
            "solution": "The solution is provided as a Python script that implements the logic described in the problem statement. The script contains a core function to calculate the figure of merit, $m_2^2(\\boldsymbol{g}; N, s)$, for any given generator $\\boldsymbol{g}$. This function implements the search strategy outlined: for a given $s$-dimensional generator, it iterates through all $(s-1)$-dimensional integer vector prefixes $\\boldsymbol{h}'=(h_1, \\dots, h_{s-1})$ in the specified symmetric range. For each non-zero prefix, it solves the dual congruence to find the corresponding last component $h_s$ and calculates the squared Euclidean norm of the full vector $\\boldsymbol{h}$. The function returns the minimum squared norm found.\n\nThis core quality assessment function is then used to implement and compare the two construction methods:\n1.  **Korobov Construction**: The script iterates through each base $a$ from the given candidate set $\\mathcal{A}$, constructs the corresponding Korobov generator $\\boldsymbol{g}(a) = (1, a, a^2, \\dots, a^{s-1}) \\pmod N$, and uses the assessment function to find its quality. It records the maximum quality found among all candidates in $\\mathcal{A}$.\n2.  **Component-by-Component (CBC) Construction**: The script builds the generator one component at a time, starting with $g_1 = 1$. For each subsequent dimension $d=2, \\dots, s$, it performs an exhaustive search for the best next component $g_d \\in \\{1, \\dots, N-1\\}$ that maximizes the figure of merit for the resulting $d$-dimensional generator.\n\nFinally, for each test case, the script compares the best Korobov quality with the final CBC quality to determine the indicator $I$ and formats the results into a single list as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the lattice rule problem by implementing and comparing\n    Korobov and Component-by-Component (CBC) generator constructions.\n    \"\"\"\n\n    class LatticeQualityAssessor:\n        \"\"\"\n        A helper class to compute the figure of merit for a rank-1 lattice rule.\n        \"\"\"\n        def __init__(self, N):\n            self.N = N\n            self.half_N = (self.N - 1) // 2\n            self.h_range = range(-self.half_N, self.half_N + 1)\n            # Memoization cache: g_tuple -> m2_sq\n            self.memo_m2 = {}\n\n        def _get_symmetric_rep(self, h_mod_N):\n            \"\"\"\n            Maps an integer modulo N to its representative in [-floor(N/2), floor(N/2)].\n            \"\"\"\n            if h_mod_N > self.half_N:\n                return h_mod_N - self.N\n            return h_mod_N\n\n        def calculate_m2_sq(self, g):\n            \"\"\"\n            Calculates the squared minimal norm m_2^2 for a given generator g.\n            \"\"\"\n            s = len(g)\n            g_tuple = tuple(g)\n            if g_tuple in self.memo_m2:\n                return self.memo_m2[g_tuple]\n\n            if s == 1:\n                # The set of non-zero dual vectors in the symmetric box is empty.\n                # The minimum over an empty set is +infinity.\n                return np.inf\n\n            min_sq_norm = np.inf\n            g_inv_s = pow(g[s - 1], -1, self.N)\n\n            # Iterate over h_0, ..., h_{s-2}\n            h_prefixes = itertools.product(self.h_range, repeat=s - 1)\n\n            for h_prefix in h_prefixes:\n                if all(h == 0 for h in h_prefix):\n                    # Skip the all-zero prefix, which leads to the h = 0 vector.\n                    continue\n\n                # Calculate dot product for h_prefix . g_prefix\n                h_dot_g_prefix = sum(h_j * g[j] for j, h_j in enumerate(h_prefix))\n                \n                # Solve for h_{s-1}\n                h_s_mod_N = (-h_dot_g_prefix * g_inv_s) % self.N\n                h_s = self._get_symmetric_rep(h_s_mod_N)\n\n                # Calculate and update the minimum squared norm\n                sq_norm_prefix = sum(h_j**2 for h_j in h_prefix)\n                current_sq_norm = sq_norm_prefix + h_s**2\n                \n                min_sq_norm = min(min_sq_norm, current_sq_norm)\n\n            result = int(min_sq_norm)\n            self.memo_m2[g_tuple] = result\n            return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 29, 's': 3, 'A': [2, 3, 5, 7]},\n        {'N': 29, 's': 4, 'A': [2, 3, 8]},\n        {'N': 29, 's': 3, 'A': [11, 12, 13, 14, 15]},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, s, A = case['N'], case['s'], case['A']\n        assessor = LatticeQualityAssessor(N)\n\n        # 1. Korobov construction\n        max_kor_m2_sq = 0\n        for a in A:\n            g = tuple(pow(a, j, N) for j in range(s))\n            current_m2_sq = assessor.calculate_m2_sq(g)\n            if current_m2_sq > max_kor_m2_sq:\n                max_kor_m2_sq = current_m2_sq\n        \n        m_2_kor_sq_final = max_kor_m2_sq\n\n        # 2. Component-by-component construction\n        g_cbc = [1]\n        m_2_cbc_sq_final = 0\n\n        for d in range(2, s + 1):\n            best_gd_for_d = -1\n            max_m2_sq_in_d = -1\n            \n            for gd_candidate in range(1, N):\n                current_g_d = tuple(g_cbc + [gd_candidate])\n                current_m2_sq = assessor.calculate_m2_sq(current_g_d)\n                \n                if current_m2_sq > max_m2_sq_in_d:\n                    max_m2_sq_in_d = current_m2_sq\n                    best_gd_for_d = gd_candidate\n            \n            g_cbc.append(best_gd_for_d)\n            m_2_cbc_sq_final = max_m2_sq_in_d\n\n        # 3. Comparison\n        I = 1 if m_2_cbc_sq_final >= m_2_kor_sq_final else 0\n        \n        all_results.append([m_2_kor_sq_final, m_2_cbc_sq_final, I])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}