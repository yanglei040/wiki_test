{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的低差异点集之前，我们必须首先对差异度这一核心度量有一个扎实的理解。本练习通过计算一维中最简单、最直观的均匀间隔点集的星差异度 (star discrepancy)，为这一概念提供了坚实的基础。通过这个计算，您将推导出著名的一维差异度下界，其数量级为 $1/N$ ，从而深刻体会到为何需要更高级的构造方法。",
            "id": "3318540",
            "problem": "设 $N \\in \\mathbb{N}$，考虑单位区间中的一维点集 $P_N=\\{u_i\\}_{i=1}^{N}$，其中 $u_i = i/N$。对于维度 $s=1$ 的有限点集 $P \\subset [0,1]$，其星偏差 $D_N^{*}(P)$ 定义为\n$$\nD_N^{*}(P) \\;=\\; \\sup_{t \\in [0,1]} \\left| \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{1}\\{u_i \\in [0,t)\\} \\;-\\; t \\right|,\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 表示指示函数。从该定义和经验分布函数的基本性质出发，计算给定等距点集 $P_N$ 的星偏差 $D_N^{*}(P_N)$ 的精确值。然后，仅使用关于分段常数经验分布函数的基本原理以及函数 $t \\mapsto t$ 是连续的这一事实，通过证明一个形式为 $c/N$（其中 $c0$ 是一个不依赖于 $P$ 的常数）的普适下界，来解释为何在一维情况下 $D_N^{*}(P)$ 的量级衰减速度不会快于 $N^{-1}$ 阶。你的最终数值答案必须是 $D_N^{*}(P_N)$ 的精确值，表示为关于 $N$ 的单个闭式表达式。不要四舍五入。",
            "solution": "该问题要求两个不同的结果：首先，计算特定一维等距点集 $P_N=\\{u_i\\}_{i=1}^{N}$（其中 $u_i = i/N$）的精确星偏差 $D_N^{*}(P_N)$；其次，证明对于任何一维点集，星偏差存在一个普适下界，从而表明其收敛速度不会快于 $N^{-1}$。\n\n让我们从定义主要对象开始。对于点集 $P = \\{u_i\\}_{i=1}^{N} \\subset [0,1]$，其经验分布函数由下式给出\n$$F_N(t) = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{1}\\{u_i \\in [0,t)\\}$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。星偏差是经验分布函数与均匀分布函数 $F(t) = t$ 之差的上确界范数：\n$$D_N^{*}(P) = \\sup_{t \\in [0,1]} |F_N(t) - t|$$\n我们将偏差函数记为 $D(t) = F_N(t) - t$。\n\n**第一部分：计算等距点集的 $D_N^{*}(P_N)$**\n\n给定的点集是 $P_N = \\{1/N, 2/N, \\dots, N/N=1\\}$。这些点已经排好序。注意，$F_N(t)$ 的定义涉及计算半开区间 $[0,t)$ 内的点 $u_i$ 的数量，即 $u_i  t$。\n\n我们分析函数 $F_N(t)$ 在 $t \\in [0,1]$ 上的行为。函数 $F_N(t)$ 是一个阶梯函数，其值仅在 $t$ 穿过其中一个点 $u_i = i/N$ 时发生变化。让我们在由这些点定义的区间上分析 $F_N(t)$。\n\n设 $k$ 为从 $0$ 到 $N$ 的整数。\n对于 $t$ 在区间 $[k/N, (k+1)/N)$ 内，其中 $k \\in \\{0, 1, \\dots, N-1\\}$：\n点集 $P_N$ 中满足 $u_i  t$ 的点 $u_i = i/N$ 恰好是 $\\{1/N, 2/N, \\dots, k/N\\}$。共有 $k$ 个这样的点。对于 $k=0$，没有这样的点。\n因此，对于 $t \\in [k/N, (k+1)/N)$，经验分布函数为 $F_N(t) = k/N$。\n\n现在我们计算这些区间上的偏差函数 $D(t) = F_N(t) - t$：\n对于 $t \\in [k/N, (k+1)/N)$，我们有 $D(t) = k/N - t$。\n由于 $k/N \\le t  (k+1)/N$，可推得 $k/N - (k+1)/N  D(t) \\le k/N - k/N$，化简为 $-1/N  D(t) \\le 0$。\n在该区间上，偏差函数的绝对值为 $|D(t)| = |k/N - t| = t - k/N$。\n这是区间 $[k/N, (k+1)/N)$ 上关于 $t$ 的单调递增函数。因此，它在该区间上的上确界在 $t$ 趋近于右端点时达到：\n$$\\sup_{t \\in [k/N, (k+1)/N)} |D(t)| = \\lim_{t \\to ((k+1)/N)^-} (t - k/N) = \\frac{k+1}{N} - \\frac{k}{N} = \\frac{1}{N}$$\n这个结果对每个 $k \\in \\{0, 1, \\dots, N-1\\}$ 都成立。\n\n最后，我们必须考虑点 $t=1$。在 $t=1$ 处，区间是 $[0,1)$，所以我们计算 $u_i  1$ 的点。这些点是 $\\{1/N, 2/N, \\dots, (N-1)/N\\}$。共有 $N-1$ 个这样的点。\n所以，$F_N(1) = (N-1)/N$。\n在 $t=1$ 处的偏差为 $|D(1)| = |F_N(1) - 1| = |\\frac{N-1}{N} - 1| = |-\\frac{1}{N}| = \\frac{1}{N}$。\n\n星偏差 $D_N^{*}(P_N)$ 是 $|D(t)|$ 在整个区间 $[0,1]$ 上的上确界。由于在每个子区间 $[k/N, (k+1)/N)$ 上， $|D(t)|$ 的上确界是 $1/N$，并且在 $t=1$ 处的值也是 $1/N$，所以总的上确界是\n$$D_N^{*}(P_N) = \\frac{1}{N}$$\n\n**第二部分：$D_N^{*}(P)$ 的普适下界**\n\n接下来，我们证明对于任何一维点集 $P = \\{u_1, u_2, \\dots, u_N\\} \\subset [0,1]$，其星偏差 $D_N^*(P)$ 有一个形如 $c/N$ 的下界，其中 $c > 0$ 是一个普适常数。我们将使用有关所涉函数性质的基本原理。\n\n设点集 $P$ 的点已排序，$0 \\le u_1 \\le u_2 \\le \\dots \\le u_N \\le 1$。我们添加辅助点 $u_0 = 0$ 和 $u_{N+1}=1$。\n函数 $F_N(t)$ 是一个右连续的阶梯函数。为简化符号，假设点是互不相同的，它在任何区间 $[u_i, u_{i+1})$ 上是常数（$i=0, \\dots, N$）。该论证在一般情况下也成立。\n在点集 $P$ 中的每个点 $u_i$ 处，函数 $F_N(t)$ 表现出一个跳跃。让我们分析偏差函数 $D(t) = F_N(t) - t$ 在某个点 $u_i$ 附近的行为。\n\n让我们考虑在点 $u_i$ 前后 $D(t)$ 的值。为了处理位于同一位置的多个点，设 $m_i = \\#\\{j : u_j  u_i\\}$ 为严格位于 $u_i$ 左侧的点的数量，而 $m'_i = \\#\\{j : u_j \\le u_i\\}$ 为小于或等于 $u_i$ 的点的数量。恰好位于 $u_i$ 的点的数量是 $j_i = m'_i - m_i \\ge 1$。\n\n在 $u_i$ 左侧的微小区间内，例如对于 $t \\in (u_i-\\epsilon, u_i)$，$F_N(t)$ 等于 $m_i/N$。当 $t \\to u_i^-$ 时，偏差函数趋近于：\n$$D(u_i^-) = \\lim_{t \\to u_i^-} D(t) = \\frac{m_i}{N} - u_i$$\n在 $u_i$ 右侧的微小区间内，例如对于 $t \\in (u_i, u_i+\\epsilon)$，$F_N(t)$ 等于 $m'_i/N$。当 $t \\to u_i^+$ 时，偏差函数趋近于：\n$$D(u_i^+) = \\lim_{t \\to u_i^+} D(t) = \\frac{m'_i}{N} - u_i = \\frac{m_i + j_i}{N} - u_i$$\n这两个极限值之差为\n$$D(u_i^+) - D(u_i^-) = \\frac{j_i}{N}$$\n\n设 $K = D_N^*(P) = \\sup_{t \\in [0,1]} |D(t)|$。根据上确界的定义，对于所有 $t$，$|D(t)|$ 的值（包括在不连续点处的左极限和右极限）必须小于或等于 $K$。\n因此，我们必须有：\n$$|D(u_i^-)| \\le K \\quad \\text{和} \\quad |D(u_i^+)| \\le K$$\n设 $x = D(u_i^-)$。那么 $D(u_i^+) = x + j_i/N$。条件是 $|x| \\le K$ 和 $|x + j_i/N| \\le K$。\n\n使用三角不等式，我们可以写出：\n$$ \\frac{j_i}{N} = \\left| \\frac{j_i}{N} \\right| = \\left| (x + \\frac{j_i}{N}) - x \\right| \\le \\left| x + \\frac{j_i}{N} \\right| + |-x| = \\left| x + \\frac{j_i}{N} \\right| + |x| $$\n应用 $K$ 定义中的界限：\n$$ \\frac{j_i}{N} \\le K + K = 2K$$\n因为点集 $P$ 中至少有一个点，所以至少存在一个位置 $u_i$ 发生跳跃，即存在一个 $i$ 使得 $j_i \\ge 1$。对于那个跳跃，我们有：\n$$ \\frac{1}{N} \\le \\frac{j_i}{N} \\le 2K$$\n这导出了不等式 $K \\ge 1/(2N)$。\n\n因此，对于任何一维 $N$ 点集 $P$，其星偏差有下界：\n$$D_N^*(P) \\ge \\frac{1}{2N}$$\n这表明偏差衰减至零的速度不会快于 $N^{-1}$ 阶。问题描述中的常数 $c$ 是 $1/2$。\n这完成了所要求的解释。\n\n所要求的最终答案是在第一部分中计算出的 $D_N^*(P_N)$ 的精确值。",
            "answer": "$$\\boxed{\\frac{1}{N}}$$"
        },
        {
            "introduction": "理解了如何度量均匀性之后，下一步是学习如何系统地构造低差异点集，尤其是在高维空间中。本练习将引导您深入现代构造方法的核心——数字网 (digital net) 。您将使用有限域上的生成矩阵，从零开始构建一个小型数字网，从而将抽象的代数理论转化为一组具体的点。",
            "id": "3318561",
            "problem": "考虑为准蒙特卡罗 (QMC) 方法构建一个基 $2$ 的数字网格，使用在含两个元素的伽罗瓦域 (GF)（记为 $\\mathrm{GF}(2)$）上定义的数字 $(t,m,s)$-网格的基本定义。一个基 $2$ 的数字 $(t,m,s)$-网格由 $s$ 个大小为 $m \\times m$ 的二进制生成矩阵 $C_{1},\\dots,C_{s}$ 指定。对于每个整数 $n \\in \\{0,1,\\dots,2^{m}-1\\}$，其二进制展开为 $n = a_{0} + a_{1} 2 + \\cdots + a_{m-1} 2^{m-1}$，点 $\\boldsymbol{x}_{n} \\in [0,1)^{s}$ 的坐标为 $x_{j} = \\sum_{r=1}^{m} y_{j,r} 2^{-r}$，其中 $y_{j} = C_{j} a$ 是在 $\\mathrm{GF}(2)$ 上计算的，且 $a = (a_{0},\\dots,a_{m-1})^{\\top}$。$(t,m,s)$-网格性质由生成矩阵初始行块的线性无关条件决定，这确保了基本区间的覆盖均匀性。\n\n仅使用这些原理：\n- 通过选择满足 $t=1$ 所需线性无关条件的、在 $\\mathrm{GF}(2)$ 上的显式 $3 \\times 3$ 二进制生成矩阵 $C_{1}$ 和 $C_{2}$，构建一个参数为 $b=2$、$s=2$、$m=3$ 和 $t=1$ 的特定数字 $(t,m,s)$-网格。\n- 使用你的矩阵，列出对于 $n=0,1,\\dots,7$ 的 $2^{m} = 8$ 个点 $\\boldsymbol{x}_{n} \\in [0,1)^{2}$。\n- 最后，确定落在基本区间 $[0,\\tfrac{1}{2}) \\times [0,\\tfrac{1}{2})$ 内的点的确切数量。\n\n提供在 $[0,\\tfrac{1}{2}) \\times [0,\\tfrac{1}{2})$ 内的点的数量作为最终答案。无需四舍五入，不涉及单位。",
            "solution": "该问题要求构建一个特定的数字 $(t,m,s)$-网格，生成其点集，并随后计算落在单位超立方体指定子区间内的点的数量。网格的参数给定为基 $b=2$，维度 $s=2$，分辨率 $m=3$，以及质量参数 $t=1$。\n\n首先，我们形式化一个点集成为数字 $(t,m,s)$-网格的条件。如果 $[0,1)^s$中的一个包含 $b^m$ 个点的集合，其每个体积为 $b^{t-m}$ 的基本区间都恰好包含 $b^t$ 个点，那么它就构成一个基为 $b$ 的数字 $(t,m,s)$-网格。如果 $s$ 个大小为 $m \\times m$ 的生成矩阵 $C_1, \\dots, C_s$（在伽罗瓦域 $\\mathrm{GF}(b)$ 上）满足一个特定的线性无关条件，则此性质得到保证。\n\n对于给定的参数 $b=2$、$s=2$、$m=3$ 和 $t=1$，所讨论的基本区间的体积为 $b^{t-m} = 2^{1-3} = 2^{-2} = \\frac{1}{4}$。每个这样的区间内点的数量必须是 $b^t = 2^1 = 2$。\n生成矩阵必须满足的线性无关条件如下：对于任何满足 $d_1 + d_2 = m-t = 3-1=2$ 的非负整数对 $(d_1, d_2)$，由矩阵 $C_1$ 的前 $d_1$ 行和矩阵 $C_2$ 的前 $d_2$ 行组成的向量集合必须在 $\\mathrm{GF}(2)$ 上线性无关。满足 $d_1+d_2=2$ 的可能配对有 $(2,0)$、$(1,1)$ 和 $(0,2)$。\n\n我们的首要任务是构建两个满足这些标准的 $3 \\times 3$ 二进制矩阵 $C_1$ 和 $C_2$。一个标准且有效的选择是为 $C_1$ 选择单位矩阵，然后构建一个合适的 $C_2$。我们定义：\n$$\nC_1 = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}, \\quad C_2 = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}\n$$\n我们必须验证这个选择是否满足线性无关条件：\n1.  对于 $(d_1, d_2) = (2,0)$：我们考虑 $C_1$ 的前 2 行。这些向量是 $(1,0,0)$ 和 $(0,1,0)$。它们在 $\\mathrm{GF}(2)$ 上是线性无关的。\n2.  对于 $(d_1, d_2) = (1,1)$：我们考虑 $C_1$ 的第一行 $(1,0,0)$ 和 $C_2$ 的第一行 $(0,1,0)$。这两个向量在 $\\mathrm{GF}(2)$ 上是线性无关的。\n3.  对于 $(d_1, d_2) = (0,2)$：我们考虑 $C_2$ 的前 2 行。这些向量是 $(0,1,0)$ 和 $(0,0,1)$。它们在 $\\mathrm{GF}(2)$ 上是线性无关的。\n由于所有条件都得到满足，这个 $C_1$ 和 $C_2$ 的选择生成了一个有效的 $(1,3,2)$-网格。\n\n接下来，我们生成该网格的 $2^m=2^3=8$ 个点。对于每个整数 $n \\in \\{0, 1, \\dots, 7\\}$，我们首先找到其二进制展开式 $n = a_0 + a_1 2^1 + a_2 2^2$，这给出了输入向量 $a = (a_0, a_1, a_2)^\\top$。点 $\\boldsymbol{x}_n = (x_1, x_2)$ 的坐标由向量 $y_1=C_1 a$ 和 $y_2=C_2 a$ 决定，其中的算术运算是在 $\\mathrm{GF}(2)$ 中进行的。\n对于 $y_j = (y_{j,1}, y_{j,2}, y_{j,3})^\\top$，坐标为 $x_j = \\sum_{r=1}^3 y_{j,r} 2^{-r}$。\n使用我们选择的矩阵：\n$y_1 = C_1 a = I a = (a_0, a_1, a_2)^\\top$\n$y_2 = C_2 a = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_0 \\end{pmatrix}$\n\n现在我们可以列出这 8 个点：\n-   $n=0$：$a=(0,0,0)^\\top$。$y_1=(0,0,0)^\\top \\implies x_1=0$。$y_2=(0,0,0)^\\top \\implies x_2=0$。点：$(0,0)$。\n-   $n=1$：$a=(1,0,0)^\\top$。$y_1=(1,0,0)^\\top \\implies x_1=\\frac{1}{2}$。$y_2=(0,0,1)^\\top \\implies x_2=\\frac{1}{8}$。点：$(\\frac{1}{2}, \\frac{1}{8})$。\n-   $n=2$：$a=(0,1,0)^\\top$。$y_1=(0,1,0)^\\top \\implies x_1=\\frac{1}{4}$。$y_2=(1,0,0)^\\top \\implies x_2=\\frac{1}{2}$。点：$(\\frac{1}{4}, \\frac{1}{2})$。\n-   $n=3$：$a=(1,1,0)^\\top$。$y_1=(1,1,0)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{4}=\\frac{3}{4}$。$y_2=(1,0,1)^\\top \\implies x_2=\\frac{1}{2}+\\frac{1}{8}=\\frac{5}{8}$。点：$(\\frac{3}{4}, \\frac{5}{8})$。\n-   $n=4$：$a=(0,0,1)^\\top$。$y_1=(0,0,1)^\\top \\implies x_1=\\frac{1}{8}$。$y_2=(0,1,0)^\\top \\implies x_2=\\frac{1}{4}$。点：$(\\frac{1}{8}, \\frac{1}{4})$。\n-   $n=5$：$a=(1,0,1)^\\top$。$y_1=(1,0,1)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{8}=\\frac{5}{8}$。$y_2=(0,1,1)^\\top \\implies x_2=\\frac{1}{4}+\\frac{1}{8}=\\frac{3}{8}$。点：$(\\frac{5}{8}, \\frac{3}{8})$。\n-   $n=6$：$a=(0,1,1)^\\top$。$y_1=(0,1,1)^\\top \\implies x_1=\\frac{1}{4}+\\frac{1}{8}=\\frac{3}{8}$。$y_2=(1,1,0)^\\top \\implies x_2=\\frac{1}{2}+\\frac{1}{4}=\\frac{3}{4}$。点：$(\\frac{3}{8}, \\frac{3}{4})$。\n-   $n=7$：$a=(1,1,1)^\\top$。$y_1=(1,1,1)^\\top \\implies x_1=\\frac{1}{2}+\\frac{1}{4}+\\frac{1}{8}=\\frac{7}{8}$。$y_2=(1,1,1)^\\top \\implies x_2=\\frac{7}{8}$。点：$(\\frac{7}{8}, \\frac{7}{8})$。\n\n最后，我们必须确定落在基本区间 $[0,\\frac{1}{2}) \\times [0,\\frac{1}{2})$ 内的点的数量。一个点 $(x_1, x_2)$ 在此区间内，当且仅当 $0 \\le x_1  \\frac{1}{2}$ 且 $0 \\le x_2  \\frac{1}{2}$。\n条件 $x_j  \\frac{1}{2}$ 等价于 $x_j$ 的第一个二进制小数位为 $0$。这个第一位是 $y_{j,1}$。因此，我们是在计算满足 $y_{1,1}=0$ 和 $y_{2,1}=0$ 的点的数量。\n根据我们的生成公式，这转化为以下条件：\n$y_{1,1} = a_0 = 0$\n$y_{2,1} = a_1 = 0$\n输入向量的第三个分量 $a_2$ 不受约束，可以是 $0$ 或 $1$。这给了我们两种可能的输入向量 $a$：\n1.  $a=(0,0,0)^\\top$：这对应于 $n=0$，点为 $\\boldsymbol{x}_0 = (0,0)$。\n2.  $a=(0,0,1)^\\top$：这对应于 $n=4$，点为 $\\boldsymbol{x}_4 = (\\frac{1}{8},\\frac{1}{4})$。\n\n$\\boldsymbol{x}_0=(0,0)$ 和 $\\boldsymbol{x}_4=(\\frac{1}{8},\\frac{1}{4})$ 这两个点都满足条件 $x_1  \\frac{1}{2}$ 和 $x_2  \\frac{1}{2}$。其他六个点对应于 $a_0=1$ 或 $a_1=1$（或两者都为1）的情况，导致 $x_1 \\ge \\frac{1}{2}$ 或 $x_2 \\ge \\frac{1}{2}$。\n因此，在构建的点集中，恰好有两个点位于指定区间内。这个结果证实了对于 $(1,3,2)$-网格的理论预期，因为该区间的体积为 $2^{t-m}$，因此必须包含 $2^t=2$ 个点。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "理论上的优质特性在实际应用中可能会受到微妙因素的影响。本计算实验旨在揭示拟蒙特卡洛 (Quasi-Monte Carlo) 方法在处理边界奇异性积分时的重要陷阱 。通过比较不同点集映射方案对积分误差的影响，您将认识到采样点与被积函数奇点之间的相互作用至关重要，这对于任何严谨的数值计算都是一个宝贵的教训。",
            "id": "3318589",
            "problem": "考虑在单位区间上使用低差异序列进行拟蒙特卡罗积分。设 $f_{\\alpha,0}(x) = x^{-\\alpha}$ 和 $f_{\\alpha,1}(x) = (1-x)^{-\\alpha}$，其中 $x \\in (0,1)$ 且 $\\alpha \\in (0,1)$，每个函数都包含一个可积的边界奇点。任一函数在 $[0,1]$ 上的积分由 $\\int_{0}^{1} x^{-\\alpha} \\, dx = \\int_{0}^{1} (1-x)^{-\\alpha} \\, dx = \\frac{1}{1-\\alpha}$ 给出（对于 $0  \\alpha  1$），该积分是有限的。低差异序列可以通过差异度的概念以及拟蒙特卡罗误差界来理解，该误差界取决于被积函数的变化（在 Hardy 和 Krause 的意义上）以及点集的星差异度。当被积函数具有边界奇点时，其变化是无界的，常规的误差界会退化，使得估计量的定性行为对边界点的处理方式变得敏感。特别是，将样本点映射到包含或排除奇异边界会改变观测到的误差。\n\n从这些定义和事实出发，设计一个小型的计算实验，以证明将样本从 $(0,1)$ 映射到 $(0,1]$ 或 $[0,1)$ 如何对具有边界奇点的被积函数的拟蒙特卡罗误差产生实质性影响。该实验必须使用一维的确定性低差异序列和两种映射约定：\n- $[0,1)$ 映射：按点在 $[0,1)$ 中生成的方式使用它们，可能精确地包含 $x=0$。\n- $(0,1]$ 映射：使用变换 $x \\mapsto 1 - x$，它将 $[0,1)$ 映射到 $(0,1]$，可能精确地包含 $x=1$。\n\n为确保数值稳定性，当求值因精确触及奇异边界而可能未定义时，您必须通过 $x \\leftarrow \\max(x,\\varepsilon)$ 来计算 $f_{\\alpha,0}$ 在 $x$ 处的值，并通过 $(1-x) \\leftarrow \\max(1-x,\\varepsilon)$ 来计算 $f_{\\alpha,1}$ 在 $x$ 处的值，其中 $\\varepsilon$ 是双精度可表示的最小正浮点数。此截断纯粹是为了计算安全，并不会改变解析积分，其值仍为 $\\frac{1}{1-\\alpha}$。\n\n将估计量实现为在低差异点上函数值的算术平均值。使用以下确定性低差异序列：\n- 一维 Sobol 序列，无加扰，样本大小为 $N = 2^{m}$（2的幂），通过以2为基的构造生成。对于每个指定的 $N$，应精确生成 $2^{m}$ 个点。\n\n对于每个测试用例，计算绝对误差 $E = \\left|\\hat{I} - \\frac{1}{1-\\alpha}\\right|$，其中 $\\hat{I}$ 是拟蒙特卡罗估计量。\n\n您的程序必须为以下测试套件实现并报告误差，该套件旨在涵盖不同的奇点位置、奇点强度、样本大小和映射：\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.25$，$N = 2^{5} = 32$，映射 $[0,1)$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.25$，$N = 2^{5} = 32$，映射 $(0,1]$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.25$，$N = 2^{10} = 1024$，映射 $[0,1)$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.25$，$N = 2^{10} = 1024$，映射 $(0,1]$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.75$，$N = 2^{5} = 32$，映射 $[0,1)$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.75$，$N = 2^{5} = 32$，映射 $(0,1]$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.75$，$N = 2^{10} = 1024$，映射 $[0,1)$。\n- 奇点在 $x=0$ ($f_{\\alpha,0}$)，$\\alpha = 0.75$，$N = 2^{10} = 1024$，映射 $(0,1]$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.25$，$N = 2^{5} = 32$，映射 $[0,1)$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.25$，$N = 2^{5} = 32$，映射 $(0,1]$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.25$，$N = 2^{10} = 1024$，映射 $[0,1)$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.25$，$N = 2^{10} = 1024$，映射 $(0,1]$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.75$，$N = 2^{5} = 32$，映射 $[0,1)$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.75$，$N = 2^{5} = 32$，映射 $(0,1]$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.75$，$N = 2^{10} = 1024$，映射 $[0,1)$。\n- 奇点在 $x=1$ ($f_{\\alpha,1}$)，$\\alpha = 0.75$，$N = 2^{10} = 1024$，映射 $(0,1]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上面列出的完全一致（从第一个项目符号到最后一个）。每个条目必须是一个浮点数，表示该测试用例的绝对误差 $E$，如上文所定义。不涉及物理单位；所有量均为无量纲。程序必须是自包含的，且不需要用户输入。",
            "solution": "用户希望一位严谨细致的STEM领域教授来解决一个问题。这位教授必须首先验证问题的陈述，如果有效，则提供完整的解决方案。\n\n**问题验证**\n\n**步骤1：提取给定条件**\n\n- **被积函数**：$f_{\\alpha,0}(x) = x^{-\\alpha}$ 和 $f_{\\alpha,1}(x) = (1-x)^{-\\alpha}$，其中 $x \\in (0,1)$ 且 $\\alpha \\in (0,1)$。\n- **积分值**：$\\int_{0}^{1} x^{-\\alpha} \\, dx = \\int_{0}^{1} (1-x)^{-\\alpha} \\, dx = \\frac{1}{1-\\alpha}$，其中 $0  \\alpha  1$。\n- **序列**：一维、无加扰的 Sobol 序列，大小为 $N = 2^m$。\n- **映射**：\n    - $[0,1)$ 映射：使用生成的点 $x_i$。\n    - $(0,1]$ 映射：使用变换后的点 $x'_i = 1 - x_i$。\n- **数值稳定性**：当求值点 $z$ 使得幂项的底为零时（即对于 $f_{\\alpha,0}$，$z \\to 0$；或对于 $f_{\\alpha,1}$，$(1-z) \\to 0$），将底替换为 $\\max(\\text{底}, \\varepsilon)$，其中 $\\varepsilon$ 是最小的正双精度浮点数。\n- **估计量**：$\\hat{I} = \\frac{1}{N} \\sum_{i=0}^{N-1} f(x_i)$。\n- **误差度量**：绝对误差 $E = \\left|\\hat{I} - \\frac{1}{1-\\alpha}\\right|$。\n- **测试套件**：16个指定的用例，组合了两种函数、两个 $\\alpha$ 值（$0.25, 0.75$）、两个样本大小 $N$（$32, 1024$）以及两种映射。\n\n**步骤2：使用提取的给定条件进行验证**\n\n1.  **科学或事实上的不健全性**：问题在科学上是健全的。它基于拟蒙特卡罗（QMC）积分和数值分析的既定原则。所涉及的函数、积分值以及针对奇异被积函数的QMC误差概念都是标准的。所描述的 Sobol 序列的属性是正确的。\n2.  **非形式化或不相关**：问题是形式化的，并且与低差异序列及其在数值积分中的应用这一主题直接相关。\n3.  **不完整或矛盾的设置**：问题是自包含的，并提供了确定性地执行计算实验所需的所有信息。没有矛盾之处。\n4.  **不现实或不可行**：所需的计算很简单，在任何现代计算机上都是可行的。参数都在现实范围内。\n5.  **不适定或结构不良**：问题是适定的。每个测试用例都有一个唯一、可计算的解。所有术语都定义清晰。\n6.  **伪深刻、琐碎或同义反复**：问题并非琐碎。这是一个精心设计的实验，用以说明QMC方法的一个关键且不明显的方面：对求值点相对于奇点位置的敏感性。\n7.  **超出科学可验证性**：结果是可通过计算验证的。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将提供一个解决方案。\n\n---\n**解决方案**\n\n该问题要求进行一个计算演示，说明当被积函数具有边界奇点时，低差异点集的映射约定如何影响拟蒙特卡罗（QMC）估计量的误差。\n\n**1. 拟蒙特卡罗积分原理**\nQMC方法通过对函数在一组确定性的、$N$个选择得高度均匀的点 $\\{x_0, x_1, \\dots, x_{N-1}\\}$ 上的值进行平均，来近似函数 $f$ 在单位超立方体 $[0,1)^s$ 上的定积分。对于在 $[0,1]$ 上的一维积分，估计量为：\n$$\n\\hat{I}_N(f) = \\frac{1}{N} \\sum_{i=0}^{N-1} f(x_i)\n$$\n该估计量的误差取决于函数 $f$ 和点集的性质。Koksma-Hlawka 不等式提供了一个形式为 $E \\le V(f) D_N^*$ 的误差界，其中 $V(f)$ 是函数在 Hardy 和 Krause 意义上的变化，而 $D_N^*$ 是点集的星差异度。\n\n**2. 具有边界奇点的被积函数**\n指定的被积函数是 $f_{\\alpha,0}(x) = x^{-\\alpha}$ 和 $f_{\\alpha,1}(x) = (1-x)^{-\\alpha}$，其中 $\\alpha \\in (0,1)$。这些函数在 $[0,1]$ 上是可积的，其积分真值为：\n$$\nI(\\alpha) = \\int_{0}^{1} x^{-\\alpha} \\, dx = \\int_{0}^{1} (1-x)^{-\\alpha} \\, dx = \\left[ \\frac{x^{1-\\alpha}}{1-\\alpha} \\right]_0^1 = \\frac{1}{1-\\alpha}\n$$\n然而，由于在 $x=0$ 和 $x=1$ 处的奇点，这些函数具有无限的变化，即 $V(f) = \\infty$。因此，标准的 Koksma-Hlawka 误差界在此处无效，QMC估计量的收敛行为变得更加复杂，并且对点 $x_i$ 的位置（尤其是在奇点附近）非常敏感。\n\n**3. Sobol 序列及其关键属性**\n该实验使用一维 Sobol 序列。该序列标准以2为基的构造的一个基本属性是，对于一组 $N=2^m$ 个点，第一个点始终是 $x_0 = 0$。这个属性是本实验的关键。\n\n**4. 映射约定分析**\n实验比较了 Sobol 点 $x_i \\in [0,1)$ 的两种映射：\n- **$[0,1)$ 映射**：求值点为 $p_i = x_i$。\n- **$(0,1]$ 映射**：求值点为 $p_i = 1 - x_i$。\n\n让我们分析这些映射对每个被积函数的影响。\n\n**情况A：奇点在 $x=0$ ($f_{\\alpha,0}(x) = x^{-\\alpha}$)**\n- **$[0,1)$ 映射**：使用的点是 Sobol 点 $x_i$ 本身。第一个点是 $p_0 = x_0 = 0$。求值 $f_{\\alpha,0}(p_0)$ 直接触及奇点。问题指定了一个数值截断规则：$0^{-\\alpha}$ 的计算结果为 $\\varepsilon^{-\\alpha}$，其中 $\\varepsilon$ 是最小的正双精度浮点数。这将产生一个巨大的值，它将在总和 $\\sum f(p_i)$ 中占主导地位，并使估计量 $\\hat{I}_N$ 变得极大，从而导致非常高的绝对误差 $E = |\\hat{I}_N - I(\\alpha)|$。\n- **$(0,1]$ 映射**：使用的点是 $p_i = 1 - x_i$。第一个点变为 $p_0 = 1 - x_0 = 1$。函数值为 $f_{\\alpha,0}(1) = 1^{-\\alpha} = 1$。所有其他的点 $p_i$ 都在 $(0, 1)$ 内，远离位于 $0$ 的奇点。没有求值点会病态地接近奇点，因此预期QMC估计量会表现良好，并产生相对较小的误差。\n\n**情况B：奇点在 $x=1$ ($f_{\\alpha,1}(x) = (1-x)^{-\\alpha}$)**\n- **$[0,1)$ 映射**：使用的点是 $p_i = x_i \\in [0,1)$。所有点都严格小于 $1$（除了 $N \\to \\infty$ 这种不存在的情况）。因此，没有点会直接触及 $x=1$ 处的奇点。我们预期估计量表现良好，误差较小。\n- **$(0,1]$ 映射**：使用的点是 $p_i = 1 - x_i$。第一个点变为 $p_0 = 1 - x_0 = 1$。求值 $f_{\\alpha,1}(p_0) = (1-1)^{-\\alpha} = 0^{-\\alpha}$ 触及奇点。与情况A一样，截断规则将产生值 $\\varepsilon^{-\\alpha}$，导致巨大的估计误差。\n\n**5. 算法设计**\n每个测试用例的计算流程如下：\n1.  定义测试用例参数：函数类型（$f_{\\alpha,0}$ 或 $f_{\\alpha,1}$）、奇点强度 $\\alpha$、点数 $N$ 以及映射（$[0,1)$ 或 $(0,1]$）。\n2.  使用标准库函数生成一维无加扰 Sobol 序列的前 $N$ 个点 $\\{x_i\\}_{i=0}^{N-1}$。\n3.  应用所选的映射，生成求值点 $\\{p_i\\}$。\n4.  确定构成幂函数底的向量 $\\{v_i\\}$。对于 $f_{\\alpha,0}(p_i)$，此值为 $v_i = p_i$。对于 $f_{\\alpha,1}(p_i)$，此值为 $v_i = 1 - p_i$。\n5.  应用数值稳定性截断：将任何 $v_i=0$ 替换为 $\\varepsilon$。这实现为 $v'_i = \\max(v_i, \\varepsilon)$。\n6.  计算函数值 $f_i = (v'_i)^{-\\alpha}$。\n7.  计算QMC估计值 $\\hat{I}_N = \\frac{1}{N} \\sum_{i=0}^{N-1} f_i$。\n8.  计算积分真值 $I(\\alpha) = \\frac{1}{1-\\alpha}$。\n9.  计算绝对误差 $E = |\\hat{I}_N - I(\\alpha)|$。\n10. 存储误差 $E$。\n\n此过程系统地执行了所描述的实验，并将产生一组误差值，这些值将展示预测的行为：导致求值点与奇点重合的映射将产生比避免它的映射大得多的误差。提供的 Python 代码精确地实现了此算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef solve():\n    \"\"\"\n    Performs a computational experiment to demonstrate the effect of point set\n    mapping on QMC integration error for functions with boundary singularities.\n    \"\"\"\n    # Define the smallest positive double-precision float for numerical stability.\n    EPSILON = np.finfo(float).tiny\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Singularity at x=0 (f_alpha_0)\n        {'func': 'f_alpha_0', 'alpha': 0.25, 'N': 32, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_0', 'alpha': 0.25, 'N': 32, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_0', 'alpha': 0.25, 'N': 1024, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_0', 'alpha': 0.25, 'N': 1024, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_0', 'alpha': 0.75, 'N': 32, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_0', 'alpha': 0.75, 'N': 32, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_0', 'alpha': 0.75, 'N': 1024, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_0', 'alpha': 0.75, 'N': 1024, 'mapping': '(0,1]'},\n        # Singularity at x=1 (f_alpha_1)\n        {'func': 'f_alpha_1', 'alpha': 0.25, 'N': 32, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_1', 'alpha': 0.25, 'N': 32, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_1', 'alpha': 0.25, 'N': 1024, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_1', 'alpha': 0.25, 'N': 1024, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_1', 'alpha': 0.75, 'N': 32, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_1', 'alpha': 0.75, 'N': 32, 'mapping': '(0,1]'},\n        {'func': 'f_alpha_1', 'alpha': 0.75, 'N': 1024, 'mapping': '[0,1)'},\n        {'func': 'f_alpha_1', 'alpha': 0.75, 'N': 1024, 'mapping': '(0,1]'},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        alpha = case['alpha']\n        mapping = case['mapping']\n        func_type = case['func']\n\n        # Generate the first N points of the 1D Sobol sequence.\n        # Per the problem, N is a power of 2. The first point will be 0.\n        sampler = qmc.Sobol(d=1, scramble=False)\n        base_points = sampler.random(n=N).flatten()\n\n        # Apply the specified mapping to get the evaluation points.\n        if mapping == '[0,1)':\n            eval_points = base_points\n        elif mapping == '(0,1]':\n            eval_points = 1 - base_points\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown mapping type: {mapping}\")\n\n        # Determine the argument to the power function based on integrand type.\n        # For f_alpha_0(x) = x**(-alpha), the argument is the point itself.\n        # For f_alpha_1(x) = (1-x)**(-alpha), the argument is (1 - point).\n        if func_type == 'f_alpha_0':\n            values_to_power = eval_points\n        else: # func_type == 'f_alpha_1'\n            values_to_power = 1 - eval_points\n\n        # Apply clipping for numerical stability before exponentiation.\n        # This handles cases where values_to_power contains a 0.\n        clipped_values = np.maximum(values_to_power, EPSILON)\n        \n        # Evaluate the function at the points.\n        f_values = clipped_values**(-alpha)\n\n        # Compute the QMC estimate (arithmetic mean).\n        qmc_estimate = np.mean(f_values)\n\n        # Compute the true integral value.\n        true_integral = 1 / (1 - alpha)\n\n        # Compute and store the absolute error.\n        error = np.abs(qmc_estimate - true_integral)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}