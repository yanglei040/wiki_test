{
    "hands_on_practices": [
        {
            "introduction": "第一个动手实践是构建排队仿真的基础。你将为一个带有容量限制和顾客拒绝行为的$M/M/1/b$系统实现一个事件驱动的仿真程序，这是许多现实世界系统（如呼叫中心或网络路由器）的经典模型。通过这个练习，你将掌握管理仿真时钟、事件和系统状态的核心技术，并学会如何计算各种关键性能指标，为分析更复杂的系统打下坚实的基础。",
            "id": "3343632",
            "problem": "考虑一个具有指数分布的到达间隔和服务时间以及望门兴叹行为的单服务台排队系统。令 $Q(t)$ 表示在时间 $t$ 系统中的顾客总数（包括正在接受服务的顾客）。到达形成速率为 $\\lambda$（单位：$\\mathrm{s}^{-1}$）的泊松过程，服务时间独立且服从速率为 $\\mu$（单位：$\\mathrm{s}^{-1}$）的指数分布，服务台一次只能处理一名顾客。望门兴叹行为遵循以下规则：到达的顾客仅在 $Q(t) < b$ 时被接纳，其中 $b$ 是一个有限容量阈值；否则，顾客会望门兴叹并立即离开，不进入系统。当 $b = \\infty$ 时，不存在望门兴叹行为，系统是标准的 $M/M/1$ 排队。当 $b$ 为有限值时，系统是 $M/M/1/b$ 损失/有限容量系统。\n\n基于以下基本事实：(i) 泊松过程具有独立平稳增量和指数分布的到达间隔时间，以及 (ii) 指数分布的服务时间具有无记忆性且独立于到达，请在长度为 $T$ 秒的有限时间范围内，对此系统实现一个事件驱动的随机模拟。对于每个测试用例，使用以 $s$ 为种子的伪随机数生成器，并为从 $i=0$ 开始的每个案例索引 $i$ 使用 $s+i$ 重新设定种子，以确保结果可复现。\n\n您的模拟必须在模拟时间范围内计算以下性能指标：\n- 估计的有效接纳到达率 $\\hat{\\lambda}_{\\mathrm{eff}}$（单位：$\\mathrm{s}^{-1}$），定义为接纳的到达人数除以 $T$。\n- 估计的望门兴叹分数 $\\hat{p}_{\\mathrm{balk}}$，定义为望门兴叹的到达人数除以总尝试到达人数（接纳的加上望门兴叹的）。必须以小数形式报告。\n- 估计的服务台利用率 $\\hat{\\rho}$，定义为在 $[0,T]$ 时间内服务台繁忙的时间比例。\n- 估计的系统内时间平均顾客数 $\\widehat{E}[Q]$，计算为 $Q(t)$ 在 $[0,T]$ 上的积分除以 $T$。\n- 估计的队列中平均等待时间 $\\widehat{E}[W]$（单位：秒），定义为 $W_i$ 的平均值，其中 $W_i$ 是在 $[0,T]$ 内开始服务的被接纳顾客的等待时间（从到达至服务开始）。\n- 估计的平均逗留时间 $\\widehat{E}[S]$（单位：秒），定义为 $S_i$ 的平均值，其中 $S_i$ 是在 $[0,T]$ 内离开的顾客在系统中的时间（从到达至离开）。\n- 估计的吞吐量 $\\widehat{\\theta}$（单位：$\\mathrm{s}^{-1}$），定义为在 $[0,T]$ 内的离开人数除以 $T$。\n- 稳定性指标 $\\mathrm{stable}$（布尔值），如果 $b$ 是有限的（由于有限状态空间，连续时间马尔可夫链是正常返的），或者当 $b=\\infty$ 时，如果 $\\lambda < \\mu$（标准 $M/M/1$ 稳定性条件），则定义为 $True$，否则为 $False$。\n\n所有时间都必须以秒为单位报告，所有速率都以 $\\mathrm{s}^{-1}$ 为单位。角度不适用。请将望门兴叹分数表示为小数，而不是百分比。您的算法必须是事件驱动的：将下一个到达时间生成为参数为 $\\lambda$ 的指数增量，并在服务台繁忙的条件下，将下一个服务完成时间生成为参数为 $\\mu$ 的指数增量。通过对事件之间的分段常数轨迹进行积分来更新时间平均量。不要使用稳态分布的简便公式；应通过模拟凭经验推导出各项指标。\n\n测试套件：\n使用以下参数集和时间范围，公共基础种子为 $s=314159$：\n1. 案例 A (理想路径，稳定的 $M/M/1$)：$\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$。\n2. 案例 B (无望门兴叹时过载，通过有限容量稳定)：$\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$。\n3. 案例 C (纯损失系统)：$\\lambda = 2.0$, $\\mu = 1.0$, $b = 1$, $T = 20000$。\n4. 案例 D (退化的零容量)：$\\lambda = 1.0$, $\\mu = 1.0$, $b = 0$, $T = 20000$。\n5. 案例 E (快速服务，大但有限的容量)：$\\lambda = 5.0$, $\\mu = 10.0$, $b = 50$, $T = 20000$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按以下顺序排列的有序列表：\n$[\\hat{\\lambda}_{\\mathrm{eff}}, \\hat{p}_{\\mathrm{balk}}, \\hat{\\rho}, \\widehat{E}[Q], \\widehat{E}[W], \\widehat{E}[S], \\widehat{\\theta}, \\mathrm{stable}]$。\n将所有五个测试用例列表聚合到一个列表中，因此最终输出为\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$\n打印在单行上。",
            "solution": "用户希望解决此问题。我将首先验证问题陈述。\n\n### 第 1 步：提取已知信息\n- **系统模型**：带望门兴叹的单服务台排队系统。\n- **到达过程**：速率为 $\\lambda$ ($\\mathrm{s}^{-1}$) 的泊松过程。到达间隔时间独立且服从指数分布。\n- **服务过程**：服务时间独立且服从速率为 $\\mu$ ($\\mathrm{s}^{-1}$) 的指数分布。单服务台。\n- **状态变量**：$Q(t)$ 是在时间 $t$ 系统中的顾客总数。\n- **望门兴叹规则**：到达的顾客仅在 $Q(t) < b$ 时被接纳，其中 $b$ 是有限容量阈值。如果 $Q(t) \\ge b$，顾客会望门兴叹。\n- **特殊情况**：如果 $b = \\infty$，系统是标准的 $M/M/1$ 排队。如果 $b$ 是有限的，则为 $M/M/1/b$ 排队。\n- **模拟参数**：\n    - 模拟时间范围：$T$ 秒。\n    - 伪随机数生成器基础种子：$s=314159$。\n    - 播种规则：对于测试用例索引 $i$（从 $i=0$ 开始），使用种子 $s+i$。\n- **要计算的性能指标**：\n    1.  $\\hat{\\lambda}_{\\mathrm{eff}}$：估计的有效接纳到达率 ($\\mathrm{s}^{-1}$) = (接纳的到达人数) / $T$。\n    2.  $\\hat{p}_{\\mathrm{balk}}$：估计的望门兴叹分数 = (望门兴叹的到达人数) / (总尝试到达人数)。\n    3.  $\\hat{\\rho}$：估计的服务台利用率 = (在 $[0,T]$ 期间服务台繁忙的时间比例)。\n    4.  $\\widehat{E}[Q]$：估计的系统内时间平均顾客数 = $(\\int_0^T Q(t) dt) / T$。\n    5.  $\\widehat{E}[W]$：估计的队列中平均等待时间 (s) = 在 $[0,T]$ 内开始服务的被接纳顾客的 $W_i$ 的平均值。\n    6.  $\\widehat{E}[S]$：估计的平均逗留时间 (s) = 在 $[0,T]$ 内离开的顾客的 $S_i$ 的平均值。\n    7.  $\\widehat{\\theta}$：估计的吞吐量 ($\\mathrm{s}^{-1}$) = (在 $[0,T]$ 内的离开人数) / $T$。\n    8.  $\\mathrm{stable}$：稳定性指标 (布尔值) = 如果 $b$ 是有限的或（$\\lambda < \\mu$ 且 $b=\\infty$）则为 $True$，否则为 $False$。\n- **方法论**：事件驱动模拟。不使用稳态分布的解析公式。\n- **测试套件**：\n    1.  案例 A: $\\lambda = 0.8$, $\\mu = 1.0$, $b = \\infty$, $T = 20000$。\n    2.  案例 B: $\\lambda = 1.2$, $\\mu = 1.0$, $b = 5$, $T = 20000$。\n    3.  案例 C: $\\lambda = 2.0, \\mu = 1.0, b = 1, T = 20000$。\n    4.  案例 D: $\\lambda = 1.0, \\mu = 1.0, b = 0, T = 20000$。\n    5.  案例 E: $\\lambda = 5.0, \\mu = 10.0, b = 50, T = 20000$。\n\n### 第 2 步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题描述了 $M/M/1/b$ 排队的模拟，这是排队论中的一个典型模型，而排队论是应用概率和运筹学中一个成熟的领域。事件驱动模拟的方法是分析此类随机系统的标准且正确的方法。所有概念都牢固地建立在公认的科学和数学原理之上。\n2.  **适定性**：问题的规定信息完整且明确。为每个测试用例提供了所有必要的参数（$\\lambda$、$\\mu$、$b$、$T$）和随机数生成器的播种协议。性能指标的定义是精确的。这种结构确保对于指定的随机数生成器的给定实现，可以获得一组唯一且有意义的结果。\n3.  **客观性**：问题陈述以正式、客观的语言编写，不含任何主观或基于意见的主张。所有术语都是标准的且定义严谨。\n4.  **无缺陷**：该问题没有说明中列出的缺陷。它在科学上是合理的，完全可以形式化，信息完整且结构良好。这是一个非凡的计算任务，准确地反映了随机模拟中的一个标准问题。\n\n### 第 3 步：结论和行动\n**问题是有效的。将提供一个完整、合理的解决方案。**\n\n---\n\n该问题要求为一个带望门兴叹的单服务台排队系统（称为 $M/M/1/b$ 排队）实现事件驱动模拟。该模拟将用于在有限时间范围 $T$ 内估计几个关键性能指标。\n\n**1. 系统建模与模拟方法**\n\n系统状态由 $Q(t)$（系统中的顾客数量）来表征。状态仅在对应两类事件的离散时间点发生变化：顾客到达和服务完成（离开）。这使得事件驱动模拟成为自然而高效的方法。我们维护一个模拟时钟和一个包含下一次计划到达和离开时间的事件日历。模拟通过将时钟推进到下一个即时事件的时间来进行。\n\n泊松到达过程和指数服务时间的基本特性至关重要。\n- 到达间隔时间是独立同分布 (i.i.d.) 的指数随机变量，均值为 $1/\\lambda$。这使我们能够将下一个到达事件安排在时间 $t_{current} + \\Delta t_A$，其中 $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$。\n- 服务时间是均值为 $1/\\mu$ 的独立同分布指数随机变量。指数分布的无记忆性简化了逻辑：正在接受服务的顾客的剩余服务时间与他们已经接受服务的时间无关。因此，当一个顾客在时间 $t_{start}$ 开始服务时，我们可以将其离开时间安排在 $t_{start} + S$，其中 $S \\sim \\text{Exponential}(\\mu)$。\n\n**2. 模拟算法**\n\n模拟算法的结构如下：\n\n**初始化：**\n1.  初始化模拟时钟 $t_{clock}$ 为 $0$。\n2.  初始化系统状态：系统中的顾客数量 $N$ 为 $0$。\n3.  初始化统计累加器为 $0$：尝试、接纳、望门兴叹的到达人数，离开人数，服务台总繁忙时间，$Q(t)$ 曲线下面积，总等待时间，以及总逗留时间。\n4.  初始化一个空的先进先出 (FIFO) 队列 `customer_arrivals`，用于存储当前在系统中的顾客的到达时间。这对于计算等待时间和逗留时间至关重要。\n5.  安排第一次到达：生成到达间隔时间 $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$，并将下一次到达时间 $t_{arrival}$ 设置为 $t_{clock} + \\Delta t_A$。\n6.  将下一次离开时间 $t_{departure}$ 设置为无穷大，因为系统初始为空且服务台空闲。\n\n**主模拟循环：**\n只要下一个事件时间小于模拟时间范围 $T$，循环就继续。\n\n1.  确定下一个事件：$t_{next\\_event} = \\min(t_{arrival}, t_{departure})$。\n2.  如果 $t_{next\\_event} \\ge T$，退出循环。\n3.  更新时间平均统计数据：在区间 $[t_{last\\_event}, t_{next\\_event}]$ 内，状态 $N$ 保持不变。\n    - 更新 $Q(t)$ 下的面积：$\\text{Area}[Q] \\leftarrow \\text{Area}[Q] + N \\times (t_{next\\_event} - t_{clock})$。\n    - 更新服务台繁忙时间：如果 $N > 0$，$\\text{BusyTime} \\leftarrow \\text{BusyTime} + (t_{next\\_event} - t_{clock})$。\n4.  推进时钟：$t_{clock} \\leftarrow t_{next\\_event}$。\n5.  处理事件：\n    - **如果 $t_{clock} = t_{arrival}$ (到达事件)：**\n        a. 增加总尝试到达次数计数器。\n        b. 检查望门兴叹条件：如果 $N < b$，顾客被接纳。\n            i. 增加接纳的到达人数计数器。\n            ii. 将当前时间 $t_{clock}$ 添加到 `customer_arrivals` 队列中。\n            iii. 系统内人数加一：$N \\leftarrow N + 1$。\n            iv. 如果服务台空闲（$N$ 原为 $0$），顾客立即开始服务。其等待时间为 $0$。增加开始服务顾客的计数，并安排离开事件：生成服务时间 $S \\sim \\text{Exponential}(\\mu)$ 并设置 $t_{departure} = t_{clock} + S$。\n        c. 如果 $N \\ge b$，顾客望门兴叹。增加望门兴叹的到达人数计数器。$N$ 保持不变。\n        d. 安排下一次到达：生成 $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$ 并设置 $t_{arrival} = t_{clock} + \\Delta t_A$。\n    - **如果 $t_{clock} = t_{departure}$ (离开事件)：**\n        a. 增加离开人数计数器。\n        b. 从 `customer_arrivals` 队列头部移除并检索离开顾客的到达时间。计算其逗留时间 $S_i = t_{clock} - (\\text{到达时间})$。将 $S_i$ 加到总逗留时间累加器中，并增加已离开顾客的计数。\n        c. 系统内人数减一：$N \\leftarrow N - 1$。\n        d. 如果系统现在为空 ($N=0$)，服务台变为空闲。设置 $t_{departure} = \\infty$。\n        e. 如果系统不为空 ($N>0$)，队列中的下一个顾客开始服务。\n            i. 其等待时间为 $W_i = t_{clock} - (\\text{新服务顾客的到达时间})$。将 $W_i$ 加到总等待时间累加器中，并增加开始服务顾客的计数。\n            ii. 安排其离开：生成 $S \\sim \\text{Exponential}(\\mu)$ 并设置 $t_{departure} = t_{clock} + S$。\n\n**终止与最终计算：**\n1.  循环终止后，最后一个事件发生在 $t_{clock} \\le T$。我们必须考虑从 $t_{clock}$ 到 $T$ 的最后一个区间，在此期间状态 $N$ 保持不变。更新此最后持续时间的 $\\text{Area}[Q]$ 和 $\\text{BusyTime}$。\n2.  根据累积的统计数据和时间范围 $T$，基于它们的定义计算最终指标：\n    - $\\hat{\\lambda}_{\\mathrm{eff}} = (\\text{接纳的到达人数}) / T$\n    - $\\hat{p}_{\\mathrm{balk}} = (\\text{望门兴叹的到达人数}) / (\\text{总到达人数})$\n    - $\\hat{\\rho} = (\\text{总繁忙时间}) / T$\n    - $\\widehat{E}[Q] = (\\text{Area}[Q]) / T$\n    - $\\widehat{E}[W] = (\\text{总等待时间}) / (\\text{开始服务的顾客数})$\n    - $\\widehat{E}[S] = (\\text{总逗留时间}) / (\\text{已离开的顾客数})$\n    - $\\widehat{\\theta} = (\\text{离开人数}) / T$\n    - $\\mathrm{stable} = (b \\neq \\infty) \\lor (\\lambda < \\mu)$\n    对于分母为零的情况（例如，没有顾客离开），需要特别小心处理，在这种情况下，相应的平均值报告为 $0$。\n\n这种严谨的、逐个事件的模拟方法正确地模拟了 $M/M/1/b$ 系统的随机动态，并允许根据要求，凭经验估计所需的性能指标，而无需依赖解析的稳态公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    def simulate(lambda_, mu, b, T, seed):\n        \"\"\"\n        Performs an event-driven simulation of an M/M/1/b queue.\n\n        Args:\n            lambda_ (float): Arrival rate.\n            mu (float): Service rate.\n            b (float or int): System capacity threshold for balking.\n            T (int): Simulation horizon time.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            list: A list containing the eight calculated performance metrics.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n\n        # State variables\n        clock = 0.0\n        num_in_system = 0\n        time_next_arrival = rng.exponential(scale=1.0/lambda_) if lambda_ > 0 else float('inf')\n        time_next_departure = float('inf')\n        \n        # FIFO queue for customers in system, storing their arrival times\n        customer_arrival_times = collections.deque()\n\n        # Statistical accumulators\n        last_event_time = 0.0\n        total_arrivals_attempted = 0\n        num_admitted = 0\n        num_balked = 0\n        num_departures = 0\n        \n        total_busy_time = 0.0\n        area_num_in_system = 0.0\n        \n        total_sojourn_time = 0.0\n        num_customers_sojourned = 0\n        \n        total_wait_time = 0.0\n        num_customers_waited = 0\n\n        # Main simulation loop\n        while time_next_arrival  T or time_next_departure  T:\n            \n            next_event_time = min(time_next_arrival, time_next_departure)\n            if next_event_time >= T:\n                break\n            \n            # Update time-averaged statistics for the interval since the last event\n            time_since_last_event = next_event_time - last_event_time\n            area_num_in_system += num_in_system * time_since_last_event\n            if num_in_system > 0:\n                total_busy_time += time_since_last_event\n\n            clock = next_event_time\n\n            # Process the next event\n            if clock == time_next_arrival:  # Arrival Event\n                total_arrivals_attempted += 1\n                \n                if num_in_system  b:\n                    # Customer is admitted\n                    num_admitted += 1\n                    customer_arrival_times.append(clock)\n                    num_in_system += 1\n                    \n                    if num_in_system == 1:  # Server was idle\n                        # Customer starts service immediately, waiting time is 0\n                        total_wait_time += 0.0\n                        num_customers_waited += 1\n                        \n                        service_time = rng.exponential(scale=1.0/mu) if mu > 0 else float('inf')\n                        time_next_departure = clock + service_time\n                else:\n                    # Customer balks\n                    num_balked += 1\n                \n                # Schedule next arrival\n                inter_arrival_time = rng.exponential(scale=1.0/lambda_) if lambda_ > 0 else float('inf')\n                time_next_arrival = clock + inter_arrival_time\n                \n            else:  # Departure Event (clock == time_next_departure)\n                num_departures += 1\n                num_in_system -= 1\n                \n                # Record sojourn time for the departing customer\n                arrival_time_of_departed = customer_arrival_times.popleft()\n                sojourn_time = clock - arrival_time_of_departed\n                total_sojourn_time += sojourn_time\n                num_customers_sojourned += 1\n                \n                if num_in_system > 0: # A customer from the queue starts service\n                    # Record waiting time for the customer starting service\n                    arrival_time_new_service = customer_arrival_times[0]\n                    wait_time = clock - arrival_time_new_service\n                    total_wait_time += wait_time\n                    num_customers_waited += 1\n                    \n                    # Schedule new departure\n                    service_time = rng.exponential(scale=1.0/mu) if mu > 0 else float('inf')\n                    time_next_departure = clock + service_time\n                else: # System becomes empty\n                    time_next_departure = float('inf')\n\n            last_event_time = clock\n            \n        # Account for the final interval from the last event time to T\n        final_interval = T - last_event_time\n        if final_interval > 0:\n            area_num_in_system += num_in_system * final_interval\n            if num_in_system > 0:\n                total_busy_time += final_interval\n\n        # Calculate final performance metrics\n        eff_arrival_rate = num_admitted / T\n        balk_fraction = num_balked / total_arrivals_attempted if total_arrivals_attempted > 0 else 0.0\n        utilization = total_busy_time / T\n        avg_num_in_system = area_num_in_system / T\n        avg_wait_time = total_wait_time / num_customers_waited if num_customers_waited > 0 else 0.0\n        avg_sojourn_time = total_sojourn_time / num_customers_sojourned if num_customers_sojourned > 0 else 0.0\n        throughput = num_departures / T\n        \n        is_stable = (b != float('inf')) or (lambda_  mu)\n\n        return [\n            eff_arrival_rate, balk_fraction, utilization,\n            avg_num_in_system, avg_wait_time, avg_sojourn_time,\n            throughput, is_stable\n        ]\n\n    # Define the test cases from the problem statement.\n    base_seed = 314159\n    test_cases = [\n        (0.8, 1.0, float('inf'), 20000), # Case A\n        (1.2, 1.0, 5, 20000),          # Case B\n        (2.0, 1.0, 1, 20000),          # Case C\n        (1.0, 1.0, 0, 20000),          # Case D\n        (5.0, 10.0, 50, 20000),         # Case E\n    ]\n    \n    all_results = []\n    for i, (lambda_val, mu_val, b_val, T_val) in enumerate(test_cases):\n        case_seed = base_seed + i\n        result = simulate(lambda_val, mu_val, b_val, T_val, case_seed)\n        all_results.append(result)\n        \n    formatted_results = []\n    for res in all_results:\n        # Format each inner list as a string without spaces\n        formatted_res = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(formatted_res)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "第二个实践将带你探索排队论中一个深刻而精妙的性质：泊松到达见时间平均（Poisson Arrivals See Time Averages, PASTA）。这个性质揭示了当到达过程为泊松过程时，到达顾客所看到的系统状态分布与一个随机时刻的外部观察者所看到的完全相同。你将设计一个仿真实验，通过收集和比较到达时刻与时间平均两种状态分布，来经验性地验证PASTA性质，并展示其在非泊松到达情况下的失效。这个练习将加深你对泊松过程独特性的理解，并训练你使用仿真作为验证理论和探索其边界的工具。",
            "id": "3343617",
            "problem": "考虑一个在先到先服务（FCFS）原则下运行的单服务器排队系统。令系统状态为时间 $t$ 时系统中的顾客数（包括正在接受服务的和在队列中等待的），记为 $Q(t)$。服务时间是独立同分布的指数随机变量，其速率参数为 $\\mu$（单位：$1/\\mathrm{s}$），并且与到达过程及所有历史记录无关。到达过程可以是速率为 $\\lambda$（单位：$1/\\mathrm{s}$）的泊松过程，也可以是具有指定到达间隔时间分布的更新过程，其平均到达间隔时间为 $1/\\lambda$ 秒。\n\n任务1（泊松到达见时间平均（PASTA）的陈述）：针对泊松到达，请用 $Q(t)$ 和在到达时刻观测到的分布，正式陈述泊松到达见时间平均（PASTA）属性。请明确定义到达时刻的观测值为 $Q(T_n^-)$，其中 $T_n$ 是第 $n$ 个到达的时刻，$Q(T_n^-)$ 表示在第 $n$ 个到达进入系统前的左极限。\n\n任务2（设计并实现一个仿真以经验性地验证PASTA）：设计并实现一个事件驱动的随机仿真，该仿真应能：\n- 仿真一个单服务器FCFS排队系统中 $Q(t)$ 的连续时间演化，其服务时间为速率为 $\\mu$（单位：$1/\\mathrm{s}$）的指数分布。\n- 对于到达过程，支持三种模式：速率为 $\\lambda$（单位：$1/\\mathrm{s}$）的泊松过程、等于 $1/\\lambda$ 秒的确定性到达间隔时间，以及Erlang-2到达间隔时间（形状参数为2的Gamma分布，其速率参数经调整以使平均到达间隔时间为 $1/\\lambda$ 秒）。\n- 使用 $N_{\\mathrm{warm}}$ 次到达作为预热期以减少瞬态偏差，然后在接下来的 $N$ 次到达期间收集统计数据。\n\n将经验时间平均分布和经验到达时刻分布定义如下。对于任意整数状态 $k \\ge 0$：\n- 经验时间平均概率为\n$$\n\\hat{p}_k^{\\mathrm{time}} = \\frac{1}{T_{\\mathrm{obs}}} \\int_{t_0}^{t_0 + T_{\\mathrm{obs}}} \\mathbf{1}\\{Q(t) = k\\}\\, dt,\n$$\n其中 $t_0$ 是数据收集开始的时刻（紧随预热期结束之后），$T_{\\mathrm{obs}}$ 是在用于数据收集的 $N$ 次到达期间累积的总观测时间（单位：秒）。\n- 经验到达时刻概率为\n$$\n\\hat{p}_k^{\\mathrm{arr}} = \\frac{1}{N} \\sum_{n=1}^{N} \\mathbf{1}\\{Q(T_{n,\\mathrm{obs}}^-) = k\\},\n$$\n其中 $T_{n,\\mathrm{obs}}$ 是在观测窗口内（即预热期后）计数的第 $n$ 次到达的时刻。\n\n为量化两个经验分布之间的一致性，计算定义为以下形式的 $\\ell_1$ 距离\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|,\n$$\n其中 $\\mathcal{K}$ 是在观测窗口内通过时间平均测量或在到达时刻观测到的所有状态的并集。$D$ 是无量纲的。\n\n任务3（解释失效条件）：根据基本的随机过程原理，解释对于非泊松到达过程，PASTA何时以及为何会失效。\n\n物理和数值单位：时间必须以秒为单位处理，到达率 $\\lambda$ 和服务率 $\\mu$ 以 $1/\\mathrm{s}$ 为单位。所有输出值必须是无量纲的实数。\n\n测试套件和要求输出：\n使用以下三个测试用例，每个用例由 $(\\text{到达类型}, \\lambda, \\mu, N_{\\mathrm{warm}}, N, \\text{seed})$ 指定，其中时间以秒表示，速率以 $1/\\mathrm{s}$ 表示：\n1. 用例1：$(\\text{Poisson}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 12345)$。\n2. 用例2：$(\\text{Poisson}, \\lambda = 0.95, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 54321)$。\n3. 用例3：$(\\text{Deterministic}, \\lambda = 0.8, \\mu = 1.0, N_{\\mathrm{warm}} = 10000, N = 100000, \\text{seed} = 67890)$。\n\n对于Erlang-2到达间隔选项，形状参数为2，速率参数的选择应使平均到达间隔时间为 $1/\\lambda$ 秒；然而，此选项未在测试套件中使用，提供它是为了使您的实现更具通用性。\n\n您的程序应生成单行输出，其中包含按给定顺序排列的三个用例的 $\\ell_1$ 距离 $D$，格式为方括号内以逗号分隔的列表，例如 $[d_1,d_2,d_3]$。每个 $d_i$ 都必须是浮点数。不应打印任何其他文本。",
            "solution": "用户提供了一个关于排队论中泊松到达见时间平均（PASTA）属性的多部分问题。这些任务涉及该属性的正式陈述、为经验性验证而设计和实现的随机仿真，以及对其在非泊松到达条件下失效的解释。该问题定义明确、科学合理且内部一致。\n\n### 任务1：PASTA属性的正式陈述\n\nPASTA属性是排队论中的一个基本结果，它将在随机时刻观察系统的外部观察者视角与到达系统的顾客视角联系起来。它特别适用于具有泊松到达过程的系统。\n\n形式上，令 $Q(t)$ 为时间 $t$ 时系统中的顾客数。系统处于状态 $k$ 的长期时间平均（或稳态）概率由下式给出：\n$$\n\\pi_k = \\lim_{t \\to \\infty} P(Q(t) = k)\n$$\n假定此极限存在。\n\n现在，考虑到达时间序列 $\\{T_n\\}_{n \\ge 1}$。令 $Q(T_n^-)$ 为第 $n$ 个到达者所看到的系统中的顾客数，该值在到达发生前的左极限处计算。到达顾客发现系统处于状态 $k$ 的长期到达时刻概率由下式给出：\n$$\na_k = \\lim_{n \\to \\infty} P(Q(T_n^-) = k)\n$$\n假定此极限存在。\n\nPASTA属性指出，如果到达过程是泊松过程，那么这两个分布是相同的：\n$$\na_k = \\pi_k \\quad \\text{for all states } k \\ge 0\n$$\n本质上，即**P**oisson **A**rrivals **S**ee **T**ime **A**verages（泊松到达见时间平均）。这种等价性源于泊松过程的无记忆性。在微小区间 $(t, t+dt]$ 内发生一次到达的概率是 $\\lambda dt$，这与过程的历史无关，并且关键地，与系统的当前状态 $Q(t)$ 无关。因此，到达并不会“选择”时机以迎合系统拥堵或空闲的时期；它们实际上是在真正随机的时刻对系统状态进行抽样，从而产生与连续时间观察者相同的统计分布。\n\n### 任务2：仿真设计与实现\n\n为了经验性地研究PASTA属性，我们将构建一个单服务器排队系统的事件驱动仿真。\n\n**仿真的核心组件：**\n1.  **仿真时钟 ($t_{sim}$):** 一个跟踪仿真当前时间的变量。它不是连续推进的，而是从一个事件时间跳到下一个。\n2.  **系统状态 ($N_{sys}$):** 一个表示系统中顾客数 $Q(t)$ 的整型变量。\n3.  **事件列表 (EL):** 一个存储未来事件的优先队列，按预定发生时间排序。每个事件是一个元组 `(event_time, event_type)`，例如 $(1.23, \\text{ARRIVAL})$。\n\n**事件驱动算法：**\n仿真通过重复执行以下步骤进行：\n1.  从事件列表中提取按时间顺序的下一个事件。\n2.  将仿真时钟 $t_{sim}$ 推进到该事件的时刻。\n3.  根据自上一个事件以来经过的时间更新统计数据。\n4.  处理事件，这涉及更改系统状态 $N_{sys}$ 并调度新的未来事件。\n\n**事件处理逻辑：**\n-   **ARRIVAL（到达）事件：**\n    1.  如果处于观测窗口内，则收集到达时刻统计数据：记录此新到达被添加前进的系统状态 $N_{sys}$。\n    2.  增加系统状态：$N_{sys} \\leftarrow N_{sys} + 1$。\n    3.  如果系统之前是空的（$N_{sys}$ 原为 $0$），则到达的顾客立即进入服务。调度一个新的DEPARTURE事件，其发生时间为 $t_{sim} + \\text{service_time}$，其中服务时间是从速率为 $\\mu$ 的指数分布中抽取的随机变量。\n    4.  调度下一个ARRIVAL事件，其发生时间为 $t_{sim} + \\text{interarrival_time}$。到达间隔时间是从指定的到达过程分布（泊松过程为指数分布，确定性过程为常数，Erlang过程为Gamma分布）中抽取的随机变量。\n\n-   **DEPARTURE（离开）事件：**\n    1.  减少系统状态：$N_{sys} \\leftarrow N_{sys} - 1$。\n    2.  如果队列中仍有顾客在等待（$N_{sys}  0$），则队列中的下一个顾客立即进入服务。调度一个新的DEPARTURE事件，其发生时间为 $t_{sim} + \\text{service_time}$。\n\n**统计数据收集：**\n仿真运行 $N_{\\mathrm{warm}}$ 次到达（预热阶段）以减轻瞬态偏差，然后是 $N$ 次到达（观测阶段）。\n-   **预热阶段：** 仿真运行，但不收集统计数据。\n-   **观测阶段：** 此阶段从第 $(N_{\\mathrm{warm}}+1)$ 次到达的时刻（称之为 $t_0$）开始，到第 $(N_{\\mathrm{warm}}+N)$ 次到达的时刻（称之为 $t_f$）结束。总观测时间为 $T_{\\mathrm{obs}} = t_f - t_0$。\n    -   **经验到达时刻概率 ($\\hat{p}_k^{\\mathrm{arr}}$):** 对于观测阶段内的 $N$ 次到达中的每一次，我们记录到达瞬间的系统状态 $N_{sys}$。我们为每个状态 $k$ 维护一个计数 $C_k^{\\mathrm{arr}}$。仿真结束后，$\\hat{p}_k^{\\mathrm{arr}} = C_k^{\\mathrm{arr}} / N$。\n    -   **经验时间平均概率 ($\\hat{p}_k^{\\mathrm{time}}$):** 我们维护一个数组或字典 $T_k^{\\mathrm{state}}$，用于存储系统在每个状态 $k$ 下所花费的总时间。每当一个事件在时间 $t_{new}$ 发生时，自上一个事件在 $t_{old}$ 发生以来经过的时间 $\\Delta t = t_{new} - t_{old}$，会被加到该时间间隔内所处状态的条目上。仿真结束后，$\\hat{p}_k^{\\mathrm{time}} = T_k^{\\mathrm{state}} / T_{\\mathrm{obs}}$。\n\n**量化一致性：**\n两个经验分布之间的差异通过 $\\ell_1$ 距离来衡量：\n$$\nD = \\sum_{k \\in \\mathcal{K}} \\left| \\hat{p}_k^{\\mathrm{time}} - \\hat{p}_k^{\\mathrm{arr}} \\right|\n$$\n其中 $\\mathcal{K}$ 是仿真观测阶段期间观测到的所有唯一状态的集合。接近于0的 $D$ 值表示强一致性，从而经验性地证实了PASTA属性。\n\n### 任务3：非泊松到达下PASTA的失效\n\nPASTA属性对于非泊松到达过程会失效，因为这类过程具有“记忆性”，这在到达时刻和排队系统状态之间产生了统计相关性。到达顾客的视角不再是系统演化的“随机样本”。\n\n**失效机制：**\n关键在于到达间隔时间的分布。对于泊松过程，到达间隔时间服从指数分布，该分布是无记忆的。对于任何其他更新过程，到达间隔时间分布都不是无记忆的。正是这种无记忆性的缺失导致了PASTA的失效。我们可以通过到达间隔时间的变异系数平方 $c_A^2$ 来分析这一点。\n-   **泊松过程：** 指数分布的 $c_A^2 = 1$。这是PASTA成立的情况。\n-   **变异性较小的到达 ($c_A^2  1$):** 这包括**确定性**（Deterministic）到达 ($c_A^2=0$) 和**Erlang**到达 ($c_A^2 = 1/k  1$，对于Erlang-$k$)。这些过程比泊松过程更“规则”或“有序”。这种规律性倾向于将到达间隔开，使服务器有更多机会完成服务并减少连续到达之间的队列长度。因此，与一个在随机时刻到达的观察者相比，一次到达更有可能发现系统处于一个较不拥挤的状态（或空闲状态）。这导致了一种“到达时间偏差”，即到达时刻的分布偏向于较短的队列长度：对于小的 $k$，$a_k  \\pi_k$；对于大的 $k$，$a_k  \\pi_k$。因此，$a_k \\ne \\pi_k$。\n-   **变异性较大的到达 ($c_A^2  1$):** 这包括超指数（hyperexponential）到达。这些过程比泊松过程更具“突发性”。到达倾向于成簇出现。一次到达很可能在前一次到达之后不久发生，此时服务器还没有时间清理工作。这意味着一次到达比随机时间观察者更有可能发现系统处于一个更拥挤的状态。在这种情况下，到达时刻的分布偏向于更长的队列长度：对于小的 $k$，$a_k  \\pi_k$；对于大的 $k$，$a_k  \\pi_k$。同样，$a_k \\ne \\pi_k$。\n\n总而言之，任何偏离泊松过程无记忆性的情况（可用 $c_A^2 \\ne 1$ 量化）都会在到达流和系统状态之间引入依赖性，导致PASTA失效。确定性情况（用例3）的仿真预计会产生一个不可忽略的 $\\ell_1$ 距离 $D$，从而证明这种失效。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\n\ndef simulate_queue(arrival_type, lam, mu, n_warm, n_obs, seed):\n    \"\"\"\n    Simulates a single-server FCFS queue and calculates the L1 distance\n    between time-average and arrival-epoch state distributions.\n    \n    Args:\n        arrival_type (str): 'poisson', 'deterministic', or 'erlang2'.\n        lam (float): Arrival rate.\n        mu (float): Service rate.\n        n_warm (int): Number of warm-up arrivals.\n        n_obs (int): Number of observation arrivals.\n        seed (int): Seed for the random number generator.\n        \n    Returns:\n        float: The L1 distance D.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    def generate_interarrival_time():\n        if arrival_type == 'poisson':\n            return rng.exponential(scale=1.0 / lam)\n        elif arrival_type == 'deterministic':\n            return 1.0 / lam\n        elif arrival_type == 'erlang2':\n            # Erlang-2 is Gamma with shape=2. Mean = shape/rate.\n            # We want mean = 1/lam, so 2/rate = 1/lam -> rate = 2*lam.\n            # Numpy's scale is 1/rate.\n            return rng.gamma(shape=2, scale=1.0 / (2.0 * lam))\n        else:\n            raise ValueError(\"Unknown arrival type\")\n\n    def generate_service_time():\n        return rng.exponential(scale=1.0 / mu)\n\n    # Simulation state variables\n    current_time = 0.0\n    last_event_time = 0.0\n    num_in_system = 0\n    event_list = []\n\n    # Statistics collectors\n    time_in_state = defaultdict(float)\n    arrivals_at_state = defaultdict(int)\n    \n    # Simulation control\n    num_arrivals_processed = 0\n    total_arrivals_to_process = n_warm + n_obs\n    \n    t_start_obs = 0.0\n    t_end_obs = 0.0\n\n    # Schedule the first arrival\n    heapq.heappush(event_list, (generate_interarrival_time(), 'ARRIVAL'))\n\n    while event_list:\n        event_time, event_type = heapq.heappop(event_list)\n        \n        # Calculate time delta since last event\n        dt = event_time - last_event_time\n        \n        # If in observation phase, update time-in-state statistics\n        # The check `num_arrivals_processed >= n_warm` ensures we only collect\n        # stats after the warmup phase is completed.\n        if num_arrivals_processed >= n_warm and dt > 0:\n            time_in_state[num_in_system] += dt\n\n        current_time = event_time\n        last_event_time = event_time\n        \n        # --- Event Processing ---\n        if event_type == 'ARRIVAL':\n            # Collect arrival-epoch stats if in observation period\n            if num_arrivals_processed >= n_warm:\n                arrivals_at_state[num_in_system] += 1\n\n            # Update state\n            num_in_system += 1\n            \n            # If server was idle, start service and schedule a departure\n            if num_in_system == 1:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n            \n            num_arrivals_processed += 1\n            \n            # Start of observation period\n            if num_arrivals_processed == n_warm:\n                t_start_obs = current_time\n            \n            # End of simulation run\n            if num_arrivals_processed == total_arrivals_to_process:\n                t_end_obs = current_time\n                break\n\n            # Schedule next arrival\n            next_arrival_time = current_time + generate_interarrival_time()\n            heapq.heappush(event_list, (next_arrival_time, 'ARRIVAL'))\n\n        elif event_type == 'DEPARTURE':\n            # Update state\n            num_in_system -= 1\n            \n            # If queue is not empty, start serving next customer\n            if num_in_system > 0:\n                departure_time = current_time + generate_service_time()\n                heapq.heappush(event_list, (departure_time, 'DEPARTURE'))\n\n    # --- Post-Processing and Calculation of D ---\n    total_obs_time = t_end_obs - t_start_obs\n    \n    # Time-average probabilities\n    p_time = defaultdict(float)\n    if total_obs_time > 0:\n        for k, T_k in time_in_state.items():\n            p_time[k] = T_k / total_obs_time\n            \n    # Arrival-epoch probabilities\n    p_arr = defaultdict(float)\n    if n_obs > 0:\n        for k, C_k in arrivals_at_state.items():\n            p_arr[k] = C_k / n_obs\n            \n    # Calculate L1 distance\n    all_states = set(p_time.keys()) | set(p_arr.keys())\n    dist = 0.0\n    for k in all_states:\n        dist += abs(p_time[k] - p_arr[k])\n        \n    return dist\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'arrival_type': 'poisson', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 12345},\n        {'arrival_type': 'poisson', 'lam': 0.95, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 54321},\n        {'arrival_type': 'deterministic', 'lam': 0.8, 'mu': 1.0, 'n_warm': 10000, 'n_obs': 100000, 'seed': 67890},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = simulate_queue(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "稳态仿真的一个核心挑战是确保用于统计分析的数据是有效的。最后一个实践聚焦于再生法（regenerative method），这是一种从单次长仿真运行中获取独立同分布（i.i.d.）样本的强大技术，从而保证了经典统计推断的有效性。你将学习如何在一个仿真中识别再生循环（如此处的繁忙期），并利用自相关分析等统计检验来验证这些循环的独立性假设。掌握再生法对于构建稳态性能指标的可靠置信区间至关重要，是严谨仿真分析的关键一步。",
            "id": "3343660",
            "problem": "实现一个单服务器队列的事件驱动模拟器，该模拟器能够检测再生，并为到达和服务使用独立的随机数流。一个再生周期定义为一个繁忙期，它始于一次到达发现系统为空的时刻，止于系统再次变为空的时刻。对于每次运行，收集一系列繁忙期长度，并通过估计滞后为1的样本互相关（在此情况下等同于滞后为1的样本自相关）来检验这些周期长度是否独立。独立性通过在独立性原假设下，对滞后为1的自相关使用大样本正态近似来进行评估。\n\n从以下基本设定开始：\n- 到达过程是速率为 $\\lambda$ 的泊松过程，因此到达间隔时间是均值为 $1/\\lambda$ 的独立同分布（i.i.d.）指数随机变量。\n- 服务在单个服务器上遵循先到先服务（FCFS）准则。\n- 对于假设周期独立的测试用例，服务时间是速率为 $\\mu$ 的独立同分布指数随机变量，并且与到达过程独立。\n- 再生发生在发现系统为空的到达时刻；连续两次此类再生之间的时间间隔即为一个繁忙期。\n- 在基本随机变量独立同分布且到达流与服务流相互独立的条件下，繁忙期构成一个独立同分布序列。\n- 为经验性地评估独立性，使用繁忙期长度序列 $\\{X_i\\}_{i=1}^n$ 的滞后为1的样本自相关：\n$$\nr_1 \\equiv \\frac{\\sum_{i=2}^{n} \\left(X_i - \\bar{X}\\right)\\left(X_{i-1} - \\bar{X}\\right)}{\\sum_{i=1}^{n} \\left(X_i - \\bar{X}\\right)^2},\n$$\n其中 $\\bar{X}$ 是样本均值。在具有有限方差的独立性原假设下，当 $n$ 很大时，\n$$\n\\sqrt{n}\\, r_1 \\approx \\mathcal{N}(0,1),\n$$\n因此，一个双边水平为 $\\alpha$ 的检验在 $\\left|r_1\\right|  z_{1-\\alpha/2}/\\sqrt{n}$ 时拒绝独立性假设，其中 $z_{1-\\alpha/2}$ 是标准正态分位数。\n\n你的程序必须：\n1. 实现一个事件驱动模拟，该模拟能够检测再生并记录每个繁忙期的长度。\n2. 使用两个统计上独立的随机数流：一个用于到达，一个用于服务。为保证可复现性，必须为每个流显式且独立地设置种子。\n3. 对于第三个测试用例，使用对数尺度上的自回归模型，有意地在不同任务的服务时间之间引入序列相关性：令 $Z_k$ 服从由 $Z_k = \\phi Z_{k-1} + \\sqrt{1-\\phi^2}\\,\\varepsilon_k$ 给出的平稳一阶自回归（AR(1)）模型，其中 $\\varepsilon_k \\sim \\mathcal{N}(0,1)$ 独立同分布，并通过 $S_k = \\exp\\left(m + s Z_k\\right)$ 定义服务时间，其中 $m$ 的选择要使 $\\mathbb{E}[S_k] = 1/\\mu$，即 $m = \\log(1/\\mu) - s^2/2$。这会产生跨周期的依赖性，并且应能被相关性检验所检测到。\n4. 对每个测试用例，计算 $r_1$、周期数 $n$，并使用决策规则 $\\left|r_1\\right| \\le z_{1-\\alpha/2}/\\sqrt{n}$（其中 $z_{1-\\alpha/2} \\approx 3.290526731$）在显著性水平 $\\alpha = 0.001$ 下判断是否接受独立性假设。\n5. 对每个测试用例，返回一个布尔值，该值指示是否接受独立性假设（True 表示不拒绝独立周期的假设）。\n\n无需物理单位；时间采用任意一致的单位处理，并报告无量纲的统计数据。不使用角度。不使用百分比。\n\n测试套件参数：\n- 测试用例1（理想情况，稳定且充分混合）：指数服务。使用 $\\lambda = 0.8$, $\\mu = 1.5$, 目标周期数 $n = 5000$, 到达流种子 $101$, 服务流种子 $202$。\n- 测试用例2（边界条件，高负载但仍稳定）：指数服务。使用 $\\lambda = 0.95$, $\\mu = 1.0$, 目标周期数 $n = 2000$, 到达流种子 $303$, 服务流种子 $404$。\n- 测试用例3（阴性对照，具有跨任务的强相关性）：采用对数尺度上AR(1)模型的对数正态服务。使用 $\\lambda = 0.8$, $\\mu = 1.5$, AR参数 $\\phi = 0.99$, 对数尺度标准差 $s = 0.6$, 目标周期数 $n = 3000$, 到达流种子 $505$, 服务流种子 $606$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按测试套件的顺序为每个测试用例包含一个布尔值，指示在 $\\alpha = 0.001$ 水平下是否接受独立性。例如，一个有效的输出行如下所示：\"[True,True,False]\"。",
            "solution": "问题陈述是有效的。这是一个在随机模拟领域，特别是排队系统模拟领域中，提法恰当且有科学依据的问题。它提供了所有必要的参数、定义和明确的目标，没有歧义或矛盾。\n\n该任务是为单服务器排队系统构建一个事件驱动模拟，收集连续繁忙期长度的数据，并对这些繁忙期长度的独立性进行统计检验。一个繁忙期构成一个再生周期。模拟和分析必须针对三个不同的测试用例进行，这些用例在流量强度和服务时间特征上有所不同。\n\n该解决方案的实现遵循了离散事件模拟和统计假设检验的原则。\n\n**1. 模拟模型与事件驱动逻辑**\n\n事件驱动模拟模型通过将时间从一个事件推进到下一个事件来发展。对于单服务器队列，唯一关心的事件是顾客到达和服务完成（离开）。系统状态由一个最小变量集来刻画：\n- 当前模拟时间 $t$。\n- 系统中的顾客数量（正在服务或在队列中），$N_{sys}$。\n\n模拟由一个事件日历控制，对于这个简单系统，该日历可以用两个变量来维护：\n- 下一个计划到达的时间，$T_{arr}$。\n- 下一个计划离开的时间，$T_{dep}$。如果服务器空闲，$T_{dep}$ 则设为无穷大。\n\n模拟按以下步骤进行：\n1.  在 $t=0$ 时将系统初始化为空闲状态，$N_{sys}=0$。安排第一次到达。\n2.  通过选择 $T_{arr}$ 和 $T_{dep}$ 的最小值来确定下一个事件。将模拟时钟 $t$ 推进到该时间。\n3.  处理事件：\n    -   如果事件是**到达**：增加 $N_{sys}$。通过从速率为 $\\lambda$ 的指数分布中抽取一个到达间隔时间来安排下一次到达。如果到达的顾客发现系统为空（之前的 $N_{sys}$ 为 $0$），则服务器是空闲的，因此为该顾客安排一次服务完成事件。此事件也标志着一个新繁忙期的开始。\n    -   如果事件是**离开**：减少 $N_{sys}$。如果系统中仍有顾客（$N_{sys}  0$），队列中的下一个顾客立即进入服务，并安排一个新的离开事件。如果系统变为空（$N_{sys}=0$），服务器变为空闲，$T_{dep}$ 设为无穷大。此事件标志着繁忙期的结束。\n\n**2. 随机数生成**\n\n问题正确地强制要求为到达过程和服务过程使用独立的、独立设置种子的随机数流。这是模拟中的一个关键实践，以确保一个随机过程的变化不会混淆对另一个过程的分析，并且它有助于方差缩减技术。初始化两个独立的伪随机数生成器，一个用于到达（$RNG_{arr}$），一个用于服务（$RNG_{serv}$）。\n\n**3. 服务时间模型与再生**\n\n再生周期定义为一个繁忙期，它始于一次到达发现系统为空的时刻，止于系统下一次变为空的时刻。每个这样的繁忙期的长度 $X_i$ 被记录下来。\n\n-   **案例1和2（指数服务时间）**：服务时间是独立同分布的（i.i.d.），从速率为 $\\mu$ 的指数分布中抽取。在一个稳定的 $M/M/1$ 队列（$\\rho = \\lambda/\\mu  1$）中，再生过程理论保证了繁忙期长度序列 $\\{X_i\\}$ 是独立同分布的。这些案例用作对照，以证明我们的检验能够正确地不拒绝为真的独立性假设。服务时间通过逆变换法生成：$S = -\\frac{1}{\\mu} \\log(U)$，其中 $U$ 是从 $RNG_{serv}$ 生成的均匀分布随机变量。\n\n-   **案例3（相关的对数正态服务时间）**：为测试我们方法的检测能力，生成具有序列相关性的服务时间。服务时间的对数被建模为一个平稳的一阶自回归（AR(1)）过程：\n    $$\n    Z_k = \\phi Z_{k-1} + \\sqrt{1-\\phi^2}\\,\\varepsilon_k\n    $$\n    其中 $k$ 是任务索引，$\\{\\varepsilon_k\\}$ 是使用 $RNG_{serv}$ 抽取的标准正态随机变量（$\\mathcal{N}(0,1)$）的独立同分布序列，且 $|\\phi|  1$。状态变量 $Z_k$ 是平稳的，均值为0，方差为1。第 $k$ 个任务的服务时间 $S_k$ 则由一个对数正态分布给出：\n    $$\n    S_k = \\exp(m + s Z_k)\n    $$\n    参数 $m$ 的选择是为了确保期望服务时间 $\\mathbb{E}[S_k]$ 等于目标值 $1/\\mu$。由于对于 $Z_k \\sim \\mathcal{N}(0,1)$，有 $\\mathbb{E}[\\exp(sZ_k)] = \\exp(s^2/2)$，因此均值为 $\\mathbb{E}[S_k] = \\exp(m) \\mathbb{E}[\\exp(sZ_k)] = \\exp(m+s^2/2)$。将其设为 $1/\\mu$ 可得 $m = \\log(1/\\mu) - s^2/2$。AR(1)过程的状态 $Z_k$ 在所有任务中都得以保持，这有意地引入了跨越繁忙期的相关性。这应该会导致在繁忙期长度序列 $\\{X_i\\}$ 中出现可检测的依赖性。\n\n**4. 独立性统计检验**\n\n为经验性地检验独立性，我们为收集到的 $n$ 个繁忙期长度序列 $\\{X_i\\}_{i=1}^n$ 计算滞后为1的样本自相关 $r_1$。\n原假设为 $H_0$：序列 $\\{X_i\\}$ 是独立同分布的。\n检验统计量为：\n$$\nr_1 = \\frac{\\sum_{i=2}^{n} (X_i - \\bar{X})(X_{i-1} - \\bar{X})}{\\sum_{i=1}^{n} (X_i - \\bar{X})^2}\n$$\n其中 $\\bar{X} = \\frac{1}{n} \\sum_{i=1}^n X_i$ 是样本均值。在 $H_0$ 下，对于大的 $n$，统计量 $\\sqrt{n} r_1$ 近似服从标准正态分布 $\\mathcal{N}(0,1)$。\n\n在显著性水平 $\\alpha$ 下的双边假设检验，如果检验统计量落入分布的尾部，则拒绝 $H_0$。决策规则是，如果不等式 $|r_1| \\le z_{1-\\alpha/2}/\\sqrt{n}$ 成立，则不拒绝独立性，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。对于指定的 $\\alpha = 0.001$，临界值为 $z_{0.9995} \\approx 3.290526731$。每个测试用例的最终输出是一个布尔值，指示独立性假设是否被接受（不被拒绝）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single-server queue simulation to test for independence of busy periods.\n\n    Args:\n        params (dict): A dictionary containing simulation parameters.\n\n    Returns:\n        bool: True if the independence hypothesis is accepted, False otherwise.\n    \"\"\"\n    # Unpack parameters\n    lambda_rate = params['lambda']\n    mu_rate = params['mu']\n    target_cycles = params['n']\n    arrival_seed = params['arrival_seed']\n    service_seed = params['service_seed']\n    service_model = params.get('service_model', 'exponential')\n    \n    # Initialize separate random number generators for arrivals and services\n    rng_arrival = np.random.default_rng(arrival_seed)\n    rng_service = np.random.default_rng(service_seed)\n    \n    # Simulation state variables\n    sim_time = 0.0\n    num_in_system = 0\n    \n    # Event calendar variables\n    time_next_arrival = rng_arrival.exponential(scale=1.0/lambda_rate)\n    time_next_departure = float('inf')\n    \n    # Data collection variables for regenerative analysis\n    busy_periods = []\n    num_cycles_completed = 0\n    start_busy_period_time = 0.0\n    \n    # State for AR(1) correlated service time model\n    z_prev = 0.0\n    if service_model == 'ar1_lognormal':\n        phi = params['phi']\n        s_log = params['s']\n        # Set m such that E[S_k] = 1/mu\n        m_log = np.log(1.0 / mu_rate) - (s_log**2) / 2.0\n    \n    # Main simulation loop\n    while num_cycles_completed  target_cycles:\n        if time_next_arrival  time_next_departure:\n            # --- PROCESS ARRIVAL EVENT ---\n            sim_time = time_next_arrival\n            \n            # Schedule the next arrival\n            time_next_arrival = sim_time + rng_arrival.exponential(scale=1.0/lambda_rate)\n            \n            if num_in_system == 0:\n                # Arrival to an empty system marks the start of a regeneration (busy) period\n                start_busy_period_time = sim_time\n            \n            num_in_system += 1\n            \n            if num_in_system == 1:\n                # The arrival is served immediately as the server was idle\n                if service_model == 'exponential':\n                    service_time = rng_service.exponential(scale=1.0/mu_rate)\n                else:  # 'ar1_lognormal'\n                    epsilon = rng_service.standard_normal()\n                    z_curr = phi * z_prev + np.sqrt(1.0 - phi**2) * epsilon\n                    service_time = np.exp(m_log + s_log * z_curr)\n                    z_prev = z_curr\n                \n                time_next_departure = sim_time + service_time\n                \n        else:\n            # --- PROCESS DEPARTURE EVENT ---\n            sim_time = time_next_departure\n            num_in_system -= 1\n            \n            if num_in_system > 0:\n                # The queue is not empty, so start serving the next customer\n                if service_model == 'exponential':\n                    service_time = rng_service.exponential(scale=1.0/mu_rate)\n                else:  # 'ar1_lognormal'\n                    epsilon = rng_service.standard_normal()\n                    z_curr = phi * z_prev + np.sqrt(1.0 - phi**2) * epsilon\n                    service_time = np.exp(m_log + s_log * z_curr)\n                    z_prev = z_curr\n\n                time_next_departure = sim_time + service_time\n            else:\n                # The system has become empty, ending the busy period\n                time_next_departure = float('inf')\n                busy_period_length = sim_time - start_busy_period_time\n                busy_periods.append(busy_period_length)\n                num_cycles_completed += 1\n                \n    # --- POST-SIMULATION ANALYSIS ---\n    X = np.array(busy_periods)\n    n = len(X)\n    if n  2:\n        return True # Not enough data to test, accept by default\n    X_bar = np.mean(X)\n    \n    # Calculate lag-1 sample autocorrelation (r_1)\n    # r_1 = sum_{i=2 to n}(X_i - X_bar)(X_{i-1} - X_bar) / sum_{i=1 to n}(X_i - X_bar)^2\n    deviations = X - X_bar\n    numerator = np.sum(deviations[1:] * deviations[:-1])\n    denominator = np.sum(deviations**2)\n    \n    r_1 = 0.0 if denominator == 0 else numerator / denominator\n        \n    # Perform the hypothesis test for independence\n    # H_0: The busy period lengths are independent.\n    # Accept H_0 if |r_1| = z_{1-alpha/2} / sqrt(n)\n    z_quantile = 3.290526731  # Given for alpha = 0.001\n    \n    critical_value = z_quantile / np.sqrt(n)\n    \n    accept_independence = np.abs(r_1) = critical_value\n    \n    return accept_independence\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: M/M/1, stable and well-mixed\n        {\n            'lambda': 0.8, 'mu': 1.5, 'n': 5000, \n            'arrival_seed': 101, 'service_seed': 202,\n            'service_model': 'exponential'\n        },\n        # Case 2: M/M/1, heavy traffic but stable\n        {\n            'lambda': 0.95, 'mu': 1.0, 'n': 2000, \n            'arrival_seed': 303, 'service_seed': 404,\n            'service_model': 'exponential'\n        },\n        # Case 3: M/G/1, dependent lognormal services\n        {\n            'lambda': 0.8, 'mu': 1.5, 'n': 3000,\n            'arrival_seed': 505, 'service_seed': 606,\n            'service_model': 'ar1_lognormal',\n            'phi': 0.99, 's': 0.6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}