{
    "hands_on_practices": [
        {
            "introduction": "在处理复杂系统之前，巩固我们对“从过去耦合”（Coupling From The Past, CFTP）核心机制的理解至关重要。第一个练习提供了一个关于简单生灭链的可解“纸笔”练习。通过显式分析耦合的上下界链的演化，你将推导出合并的确切概率，从而对CFTP算法如何实现收敛获得深刻的、定量的直觉。",
            "id": "3356322",
            "problem": "考虑一个在有限偏序状态空间 $\\{0,1,2\\}$ 上的时间齐次生灭马尔可夫链，其在每个离散时间步的转移概率如下：\n- 从状态 $0$：以 $1/2$ 的概率转移到 $1$，以 $1/2$ 的概率停留在 $0$。\n- 从状态 $1$：以 $1/4$ 的概率转移到 $0$，以 $1/4$ 的概率停留在 $1$，以 $1/2$ 的概率转移到 $2$。\n- 从状态 $2$：以 $1/2$ 的概率转移到 $1$，以 $1/2$ 的概率停留在 $2$。\n\n假设更新规则由一组独立的同分布随机输入实现：在每个时间 $n$，从 $\\text{Uniform}(0,1)$ 分布中抽取一个输入 $U_{n}$，下一状态由为每个当前状态 $i \\in \\{0,1,2\\}$ 定义的阈值映射 $F(i,U_{n})$ 给出，具体如下：\n$$\nF(0,u) = \\begin{cases}\n0, & 0 \\le u  \\tfrac{1}{2},\\\\\n1,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(1,u) = \\begin{cases}\n0,  0 \\le u  \\tfrac{1}{4},\\\\\n1,  \\tfrac{1}{4} \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(2,u) = \\begin{cases}\n1,  0 \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1.\n\\end{cases}\n$$\n\n此更新函数相对于 $\\{0,1,2\\}$ 上的自然序是单调的，因此 Propp-Wilson 过去耦合 (CFTP) 方法可以使用夹逼法实现：给定一个时间范围 $t \\in \\mathbb{N}$，从时间 $-t$ 开始，下界和上界状态分别为 $L_{0}=0$ 和 $U_{0}=2$，并将相同的更新输入 $U_{-t}, U_{-(t-1)}, \\dots, U_{-1}$ 向前应用到时间 $0$，以获得边界像 $L_{t}$ 和 $U_{t}$。到时间 $t$ 时的耦合发生当且仅当 $L_{t} = U_{t}$。\n\n仅使用单调马尔可夫链、Propp-Wilson CFTP 和上述更新规则的基本定义，从第一性原理推导在此夹逼方案下到时间 $t$ 时发生耦合的概率的精确闭式表达式（作为 $t$ 的函数）。你的最终答案必须是单个解析表达式。无需四舍五入，也不应包含任何单位。",
            "solution": "问题要求计算一个 Propp-Wilson 过去耦合 (CFTP) 过程在时间 $t$ 内发生耦合的概率。该过程定义在状态空间 $S = \\{0, 1, 2\\}$ 上，其自然序为 $0 \\le 1 \\le 2$。CFTP 算法使用夹逼法实现，从极值状态开始，分别设为下链 $L$ 和上链 $U$。模拟运行一个时间范围为 $t$ 的步数，从时间 $-t$ 到时间 $0$。\n\n设在给定时间下链的状态用 $l$ 表示，上链的状态用 $u$ 表示。模拟从时间 $-t$ 开始，此时 $l_{-t} = 0$ 且 $u_{-t} = 2$。在从 $-t$ 到 $-1$ 的每一步 $k$，两条链都使用相同的随机数 $U_k \\sim \\text{Uniform}(0,1)$ 和单调更新函数 $F(i,u)$ 进行更新。设模拟经过 $n$ 步后（即在时间 $-t+n$ 时）链的状态为 $(l_n, u_n)$。这个状态对过程的初始状态是 $(l_0, u_0) = (0,2)$。经过 $n$ 步后的状态是 $(l_n, u_n) = (F(l_{n-1}, U_{n-1}), F(u_{n-1}, U_{n-1}))$。我们感兴趣的是链在 $t$ 步后耦合的概率，即 $P(l_t = u_t)$。\n\n由于 $F$ 的单调性，我们保证对所有 $n \\ge 0$ 都有 $l_n \\le u_n$。状态对过程 $(l_n, u_n)$ 的状态是集合 $\\{(i,j) \\in S \\times S \\mid i \\le j\\}$ 中的一个元素。当 $l_n = u_n$ 时发生耦合。因此，状态 $(0,0)$、$(1,1)$ 和 $(2,2)$ 是该状态对过程的吸收态。一旦达到一个状态对 $(i,i)$，所有后续状态都将是 $(F(i,U), F(i,U))$，这意味着两条链保持耦合状态。\n\n该状态对过程的未耦合状态，即瞬态，是 $(0,1)$、$(0,2)$ 和 $(1,2)$。让我们分析这些瞬态之间的转移。设随机变量 $U$ 从 $\\text{Uniform}(0,1)$ 分布中抽取。下一个状态 $(l', u')$ 由 $(F(l,U), F(u,U))$ 给出。\n\n为了分析未耦合的动力学，我们定义三个状态：\n- 状态 $A$：状态对为 $(0,2)$。\n- 状态 $B$：状态对为 $(0,1)$。\n- 状态 $C$：状态对为 $(1,2)$。\n- 状态 $D$：链已耦合（状态对在 $\\{(0,0), (1,1), (2,2)\\}$ 中）。状态 $D$ 是吸收态。\n\n模拟的初始状态是 $(l_0, u_0) = (0,2)$，即状态 $A$。\n\n我们现在计算状态 $A, B, C$ 的单步转移概率。\n1.  从状态 $A = (0,2)$：\n    - 若 $U \\in [0, \\frac{1}{2})$：$l' = F(0,U)=0$，$u' = F(2,U)=1$。新状态为 $(0,1)$，即 $B$。$P(U  \\frac{1}{2}) = \\frac{1}{2}$。\n    - 若 $U \\in [\\frac{1}{2}, 1]$：$l' = F(0,U)=1$，$u' = F(2,U)=2$。新状态为 $(1,2)$，即 $C$。$P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(A \\to A) = 0$，$P(A \\to B) = \\frac{1}{2}$，$P(A \\to C) = \\frac{1}{2}$，$P(A \\to D) = 0$。\n\n2.  从状态 $B = (0,1)$：\n    - 若 $U \\in [0, \\frac{1}{4})$：$l' = F(0,U)=0$，$u' = F(1,U)=0$。新状态为 $(0,0)$，即 $D$（耦合）。$P(U  \\frac{1}{4}) = \\frac{1}{4}$。\n    - 若 $U \\in [\\frac{1}{4}, \\frac{1}{2})$：$l' = F(0,U)=0$，$u' = F(1,U)=1$。新状态为 $(0,1)$，即 $B$。$P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$。\n    - 若 $U \\in [\\frac{1}{2}, 1]$：$l' = F(0,U)=1$，$u' = F(1,U)=2$。新状态为 $(1,2)$，即 $C$。$P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(B \\to B) = \\frac{1}{4}$，$P(B \\to C) = \\frac{1}{2}$，$P(B \\to D) = \\frac{1}{4}$。\n\n3.  从状态 $C = (1,2)$：\n    - 若 $U \\in [0, \\frac{1}{4})$：$l' = F(1,U)=0$，$u' = F(2,U)=1$。新状态为 $(0,1)$，即 $B$。$P(U  \\frac{1}{4}) = \\frac{1}{4}$。\n    - 若 $U \\in [\\frac{1}{4}, \\frac{1}{2})$：$l' = F(1,U)=1$，$u' = F(2,U)=1$。新状态为 $(1,1)$，即 $D$（耦合）。$P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$。\n    - 若 $U \\in [\\frac{1}{2}, 1]$：$l' = F(1,U)=2$，$u' = F(2,U)=2$。新状态为 $(2,2)$，即 $D$（耦合）。$P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(C \\to B) = \\frac{1}{4}$，$P(C \\to D) = \\frac{1}{4} + \\frac{1}{2} = \\frac{3}{4}$。\n\n设 $p_n(S)$ 为经过 $n$ 步后处于瞬态 $S \\in \\{A, B, C\\}$ 的概率。设 $v_n = [p_n(A), p_n(B), p_n(C)]^T$ 为这些概率的列向量。该向量的演化由 $v_{n+1} = T v_n$ 给出，其中 $T$ 是瞬态的转移矩阵。\n$$\nT = \\begin{pmatrix}\nP(A \\to A)  P(B \\to A)  P(C \\to A) \\\\\nP(A \\to B)  P(B \\to B)  P(C \\to B) \\\\\nP(A \\to C)  P(B \\to C)  P(C \\to C)\n\\end{pmatrix} = \\begin{pmatrix}\n0  0  0 \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4} \\\\\n\\frac{1}{2}  \\frac{1}{2}  0\n\\end{pmatrix}\n$$\n模拟从状态 $A$ 开始，所以初始概率向量为 $v_0 = [1, 0, 0]^T$。经过 $t$ 步后，概率向量为 $v_t = T^t v_0$。到时间 $t$ 仍未耦合的概率 $S_t$ 是 $v_t$ 各分量之和。所求的耦合概率为 $P_c(t) = 1 - S_t$。\n\n为了计算 $T^t$，我们求 $T$ 的特征值和特征向量。特征方程为 $\\det(T - \\lambda I) = 0$：\n$$ \\det \\begin{pmatrix} -\\lambda  0  0 \\\\ \\frac{1}{2}  \\frac{1}{4}-\\lambda  \\frac{1}{4} \\\\ \\frac{1}{2}  \\frac{1}{2}  -\\lambda \\end{pmatrix} = -\\lambda \\left( \\left(\\frac{1}{4}-\\lambda\\right)(-\\lambda) - \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) \\right) = -\\lambda \\left( \\lambda^2 - \\frac{1}{4}\\lambda - \\frac{1}{8} \\right) = 0 $$\n特征值为 $\\lambda_3 = 0$ 以及 $8\\lambda^2 - 2\\lambda - 1 = 0$ 的根，即 $\\lambda = \\frac{2 \\pm \\sqrt{4 - 4(8)(-1)}}{16} = \\frac{2 \\pm 6}{16}$。\n所以，特征值为 $\\lambda_1 = \\frac{8}{16} = \\frac{1}{2}$，$\\lambda_2 = \\frac{-4}{16} = -\\frac{1}{4}$ 和 $\\lambda_3 = 0$。\n\n接下来，我们求对应的特征向量：\n- 对于 $\\lambda_1 = \\frac{1}{2}$：$(T - \\frac{1}{2}I)x = 0$ 得到特征向量 $e_1 = [0, 1, 1]^T$。\n- 对于 $\\lambda_2 = -\\frac{1}{4}$：$(T + \\frac{1}{4}I)x = 0$ 得到特征向量 $e_2 = [0, 1, -2]^T$。\n- 对于 $\\lambda_3 = 0$：$Tx = 0$ 得到特征向量 $e_3 = [1, -1, -1]^T$。\n\n我们将初始向量 $v_0$ 表示为特征向量的线性组合：$v_0 = c_1 e_1 + c_2 e_2 + c_3 e_3$。\n$$ \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = c_1 \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} + c_2 \\begin{pmatrix} 0 \\\\ 1 \\\\ -2 \\end{pmatrix} + c_3 \\begin{pmatrix} 1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} c_3 \\\\ c_1 + c_2 - c_3 \\\\ c_1 - 2c_2 - c_3 \\end{pmatrix} $$\n这给出了一个关于 $(c_1, c_2, c_3)$ 的线性方程组，解得 $c_1=1$，$c_2=0$，$c_3=1$。\n因此，$v_0 = e_1 + e_3$。\n\n现在我们可以计算 $v_t = T^t v_0$：\n$$ v_t = T^t(e_1 + e_3) = T^t e_1 + T^t e_3 = \\lambda_1^t e_1 + \\lambda_3^t e_3 $$\n问题指定 $t \\in \\mathbb{N}$，这通常被解释为 $t \\ge 1$。对于 $t \\ge 1$，有 $\\lambda_3^t = 0^t = 0$。\n$$ v_t = \\left(\\frac{1}{2}\\right)^t e_1 = \\left(\\frac{1}{2}\\right)^t \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ (\\frac{1}{2})^t \\\\ (\\frac{1}{2})^t \\end{pmatrix} $$\n该向量给出了经过 $t$ 步后处于状态 $A, B, C$ 的概率。\n$p_t(A) = 0$，$p_t(B) = (\\frac{1}{2})^t$，$p_t(C) = (\\frac{1}{2})^t$。\n\n到时间 $t$ 仍未耦合的概率 $S_t$ 是这些概率之和：\n$$ S_t = p_t(A) + p_t(B) + p_t(C) = 0 + \\left(\\frac{1}{2}\\right)^t + \\left(\\frac{1}{2}\\right)^t = 2 \\left(\\frac{1}{2}\\right)^t = \\left(\\frac{1}{2}\\right)^{t-1} $$\n这个结果对 $t \\ge 1$ 有效。\n\n最后，到时间 $t$ 发生耦合的概率 $P_c(t)$ 等于 $1$ 减去未耦合的概率：\n$$ P_c(t) = 1 - S_t = 1 - \\left(\\frac{1}{2}\\right)^{t-1} $$\n这可以改写为 $1 - 2^{1-t}$。这就是耦合概率作为时间范围 $t$ 的函数的闭式表达式。\n对于 $t=1$，$P_c(1) = 1 - 2^0 = 0$。这是正确的，因为第一步只能导致未耦合的状态 $(0,1)$ 或 $(1,2)$。\n对于 $t \\to \\infty$，$P_c(t) \\to 1$，这对于一个不可约且非周期的有限状态马尔可夫链是符合预期的。",
            "answer": "$$\n\\boxed{1 - 2^{1-t}}\n$$"
        },
        {
            "introduction": "标准的Propp-Wilson算法依赖于单调性，但并非所有系统都具备此性质。本练习使用非二分图上的反铁磁伊辛模型这一经典例子来探讨这一局限性，该系统表现出“几何阻挫”（frustration）现象。这个思想实验将引导你理解为何简单的单调CFTP在此处会失效，并阐明为何需要像“受控从过去耦合”（Dominated Coupling From The Past, DCFTP）这样更通用的技术，它可以在特定条件下处理非单调系统。",
            "id": "3356306",
            "problem": "考虑一个无向有限图 $G=(V,E)$ 及其上的伊辛模型，其中自旋 $\\sigma_i \\in \\{-1,+1\\}$ 定义在顶点 $i \\in V$ 上，其吉布斯分布正比于 $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j + \\sum_{i\\in V} h_i \\sigma_i\\big)$，并采用单点热浴格劳伯动力学。回顾以下基本概念。\n\n- 如果对于任意两个按坐标满足 $\\sigma \\le \\tau$ 的位形，在任意位点 $i$ 的更新映射都可以被耦合，使得更新后的自旋也几乎必然地满足 $\\sigma' \\le \\tau'$，那么我们称该马尔可夫链更新相对于 $\\{-1,+1\\}^V$ 上的乘积偏序是单调的。对于位点 $i$ 处的伊辛模型热浴更新，其条件概率 $p_i(\\sigma_{-i}) := \\mathbb{P}(\\sigma_i=+1 \\mid \\sigma_{-i})$ 对每个邻居自旋 $\\sigma_j$ 都是非减的，当且仅当所有耦合常数 $\\{J_{ij}\\}_{j\\sim i}$ 都是非负的。\n\n- 逐点符号变换是一个映射 $\\tau_i = s_i \\sigma_i$，其中对每个 $i \\in V$ 都有 $s_i \\in \\{-1,+1\\}$。该变换将耦合常数变为 $J'_{ij} = J_{ij} s_i s_j$，将场变为 $h'_i = h_i s_i$。\n\n- 一个图 $G$ 是二分图，当且仅当其顶点集允许进行2-着色，即 $V = U \\cup W$，使得每条边的两个端点分别位于 $U$ 和 $W$ 中。等价地，$G$ 不包含奇圈。\n\n- Propp-Wilson 的“从过去耦合”（Coupling From The Past, CFTP）算法的单调形式需要一个带有最大元和最小元的偏序，以及一个单调的更新映射，以确保从极端的初始状态出发的链能够合并。“受控从过去耦合”（Dominated Coupling From The Past, DCFTP）算法则构建一个由随机占优过程控制的时间回溯依赖图；如果这个回溯探索几乎必然终止，那么即使没有单调性，也可以生成一个精确样本。\n\n考虑三角图 $C_3$ 上的反铁磁情况，其中对所有 $\\{i,j\\}\\in E$ 都有均匀的对耦合 $J_{ij} = -\\beta$，对所有 $i\\in V$ 都有外场 $h_i=0$，且 $\\beta0$ 是一个固定的常数。分析非二分性对单调变换的存在性以及对完美抽样可行性的影响。\n\n下列哪个陈述是正确的？\n\nA. 存在一组符号 $\\{s_i\\}_{i\\in V}$，使得逐点符号变换 $\\tau_i = s_i \\sigma_i$ 能将 $C_3$ 上的反铁磁伊辛模型转换为一个对所有 $\\{i,j\\}\\in E$ 都满足 $J'_{ij} \\ge 0$ 的铁磁模型，从而可以使用从最大元和最小元开始的单调 Propp-Wilson CFTP 算法。\n\nB. 在任何非二分图上（特别是在 $C_3$ 上），当所有原始耦合常数 $J_{ij}0$ 时，没有任何逐点符号变换能使所有变换后的耦合常数 $J'_{ij}$ 变为非负。因此，热浴更新在任何乘积偏序下都不具有吸引性（单调性），标准的、使用最大和最小界链的单调 Propp-Wilson CFTP 算法无法应用。\n\nC. 即使不具备吸引性（单调性），对于足够小的 $\\beta$（即高温情况），也存在基于“受控从过去耦合”（DCFTP）的完美模拟方案。这些方案构建一个由亚临界分支过程主导的回溯依赖图，该过程保证几乎必然会消亡，从而可以为 $C_3$ 上的反铁磁伊辛模型生成精确样本。\n\nD. 由于单调性是完美抽样的必要条件，因此非二分性意味着对于 $C_3$ 上的模型不存在任何完美抽样算法。\n\nE. 通过修改动力学，使用热浴规则一次性地对两个相邻自旋进行块更新，总能恢复 $C_3$ 上的单调更新映射，因此单调 Propp-Wilson CFTP 算法变得适用，且与 $\\beta$ 的取值无关。",
            "solution": "问题要求分析三角图 $C_3$ 上的反铁磁伊辛模型，特别是关于“从过去耦合”（CFTP）等完美抽样算法的适用性。\n\n该模型定义在图 $G=(V,E)$ 上，其中 $V=\\{1,2,3\\}$，$E=\\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}\\}$。吉布斯分布正比于 $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j\\big)$，其中耦合常数 $J_{ij} = -\\beta$（常数 $\\beta0$），外场 $h_i=0$。哈密顿量为 $H(\\sigma) = -\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$。系统倾向于最小化该能量，这有利于相邻自旋的反向排列，这是反铁磁体的典型特征。\n\n用于单点热浴动力学的标准单调 Propp-Wilson CFTP 算法要求更新规则是单调的。这当且仅当所有耦合常数 $J_{ij}$ 都是非负的（铁磁模型）。问题探讨的是，给定的反铁磁模型是否可以通过逐点符号变换 $\\tau_i = s_i \\sigma_i$（其中 $s_i \\in \\{-1, +1\\}$）变为铁磁模型。这样的变换将耦合常数变为 $J'_{ij} = J_{ij} s_i s_j$。对于我们的模型，$J'_{ij} = (-\\beta) s_i s_j$。为了使这些值非负，我们需要对所有相邻对 $\\{i,j\\}$ 都有 $s_i s_j = -1$。这意味着相邻的顶点必须有不同的符号。这等价于为图 $G$ 找到一个2-着色。一个图是可2-着色的，当且仅当它是二分图（不包含奇数长度的圈）。图 $C_3$ 是一个长度为3的圈，这是奇数，因此它不是二分图。所以，不可能找到一组符号 $\\{s_i\\}$ 使得所有变换后的耦合常数 $J'_{ij}$ 都非负。这种在非二分图上的反铁磁相互作用无法全部同时被满足的现象被称为“阻挫”。\n\n现在我们来评估每个陈述。\n\n**A. 存在一组符号 $\\{s_i\\}_{i\\in V}$，使得逐点符号变换 $\\tau_i = s_i \\sigma_i$ 能将 $C_3$ 上的反铁磁伊辛模型转换为一个对所有 $\\{i,j\\}\\in E$ 都满足 $J'_{ij} \\ge 0$ 的铁磁模型，从而可以使用从最大元和最小元开始的单调 Propp-Wilson CFTP 算法。**\n\n如前所述，这样的符号变换等价于为图 $C_3$ 找一个2-着色。由于 $C_3$ 是一个奇圈，它不是二分图，因此不是可2-着色的。不存在这样的符号选择 $\\{s_i\\}$。沿着圈将所需的符号关系相乘得到 $(s_1 s_2)(s_2 s_3)(s_3 s_1) = (-1)^3 = -1$，而代数上该表达式为 $s_1^2 s_2^2 s_3^2=1$，这是一个矛盾。因此，该模型无法转换为铁磁模型，应用单调 CFTP 的这条途径是行不通的。\n**结论：错误。**\n\n**B. 在任何非二分图上（特别是在 $C_3$ 上），当所有原始耦合常数 $J_{ij}0$ 时，没有任何逐点符号变换能使所有变换后的耦合常数 $J'_{ij}$ 变为非负。因此，热浴更新在任何乘积偏序下都不具有吸引性（单调性），标准的、使用最大和最小界链的单调 Propp-Wilson CFTP 算法无法应用。**\n\n该陈述是正确的。第一部分是上面讨论的阻挫的一般原理：非二分图上的反铁磁模型无法通过规范变换转换为铁磁模型。第二部分是其直接推论。单点热浴动力学相对于 $\\{-1,+1\\}^V$ 上的标准乘积偏序的吸引性（单调性）要求所有耦合常数 $J_{ij}$ 都为非负。相对于另一个乘积偏序（通过符号 $\\{s_i\\}$ 相关联）的吸引性等价于变换后的变量 $\\{\\tau_i\\}$ 相对于标准偏序的吸引性，这要求所有 $J'_{ij}$ 都为非负。由于这一点无法实现，该动力学在任何乘积偏序下都不具有吸引性。标准的单调 Propp-Wilson CFTP 算法的机制，即从极端状态（全为+1和全为-1）开始耦合链，从根本上依赖于这种吸引性。没有它，该算法的标准形式便不适用。\n**结论：正确。**\n\n**C. 即使不具备吸引性（单调性），对于足够小的 $\\beta$（即高温情况），也存在基于“受控从过去耦合”（DCFTP）的完美模拟方案。这些方案构建一个由亚临界分支过程主导的回溯依赖图，该过程保证几乎必然会消亡，从而可以为 $C_3$ 上的反铁磁伊辛模型生成精确样本。**\n\n该陈述正确地描述了另一种完美抽样方法，即 DCFTP，它不需要单调性。其收敛性取决于系统中依赖关系的强度足够弱。对于伊辛模型，这对应于高温区域（小 $\\beta$）。在此区域内，系统满足像 Dobrushin 唯一性条件这样的条件，这意味着任何单个自旋对另一个自旋的影响会迅速衰减。DCFTP 的回溯依赖探索可以被一个简单的过程（如 Galton-Watson 分支过程）随机占优。如果这个占优过程中的期望“后代”数量小于1（即它是亚临界的），那么该过程几乎必然会消亡，这意味着 DCFTP 算法会终止并产生一个精确样本。对于任何有限图上的有限程伊辛模型，包括我们在 $C_3$ 上的情况，对于足够小的 $\\beta$，这样的高温区域总是存在的。\n**结论：正确。**\n\n**D. 由于单调性是完美抽样的必要条件，因此非二分性意味着对于 $C_3$ 上的模型不存在任何完美抽样算法。**\n\n这个陈述在事实上是错误的。单调性是完美抽样的充分条件，但不是必要条件。正如在对选项C的分析中所确立的，DCFTP 算法是一种有效的完美抽样方法，它不需要单调性，并且可以应用于高温区域下的 $C_3$ 上的反铁磁伊辛模型。DCFTP 的存在为“不存在任何完美抽样算法”这一说法提供了一个直接的反例。\n**结论：错误。**\n\n**E. 通过修改动力学，使用热浴规则一次性地对两个相邻自旋进行块更新，总能恢复 $C_3$ 上的单调更新映射，因此单调 Propp-Wilson CFTP 算法变得适用，且与 $\\beta$ 的取值无关。**\n\n该陈述提议通过使用块更新来恢复单调性。让我们分析在自旋 $\\sigma_3$ 状态给定的条件下，自旋块 $\\{\\sigma_1, \\sigma_2\\}$ 的更新。该块的热浴规则意味着从条件吉布斯分布 $\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3) \\propto \\exp(-H(\\sigma_1,\\sigma_2|\\sigma_3))$ 中抽样，其中 $H$ 是哈密顿量。哈密顿量的相关部分是 $H = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$。条件概率正比于 $\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta\\sigma_3(\\sigma_1+\\sigma_2))$。为了检查单调性，我们分析当 $\\sigma_3$ 从 $-1$ 翻转到 $+1$ 时，这个分布如何变化。概率比为：\n$$ \\frac{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=+1)}{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=-1)} = \\frac{\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta(\\sigma_1+\\sigma_2))}{\\exp(-\\beta\\sigma_1\\sigma_2 + \\beta(\\sigma_1+\\sigma_2))} = \\exp(-2\\beta(\\sigma_1+\\sigma_2)) $$\n这个比率随着和 $\\sigma_1+\\sigma_2$ 的增加而减小。例如，当 $\\sigma_3$ 从 $-1$ 翻转到 $+1$ 时，状态 $(\\sigma_1, \\sigma_2) = (+1,+1)$（和为2）相对于状态 $(-1,-1)$（和为-2）变得更不可能出现。这正是相对于块上标准乘积偏序的反单调性的定义。该更新并未恢复单调性，而是将其逆转了。声称这“总是”有效且“与 $\\beta$ 无关”是错误的。\n**结论：错误。**",
            "answer": "$$\\boxed{\\text{B, C}}$$"
        },
        {
            "introduction": "现在，让我们将这些概念应用于一个来自计算统计物理学的强大算法。这个编程练习要求你为Fortuin-Kasteleyn（FK）随机簇模型实现单调CFTP，该模型是高效模拟Potts模型的核心。你将在一个更抽象的键构型空间上定义一个偏序，并亲眼见证“宏大耦合”（grand coupling）和倍增策略在一个实际的、非平凡的实现中如何工作。",
            "id": "3356348",
            "problem": "您的任务是设计、分析并实现一个程序，通过 Fortuin–Kasteleyn (FK) 表示法，探索在铁磁 Potts 模型中使用“过去耦合”(Coupling From The Past, CFTP) 和“受控 CFTP”(dominated CFTP) 思想进行精确采样的方法。重点是通过在键构型上定义一个偏序，研究 Swendsen–Wang 动力学的单调 CFTP 可行性，并评估在该序下检测合并的实用性。\n\n必须使用以下基本设定，不得简化：\n- 一个有限无向图由顶点集 $V$ (其中 $\\lvert V \\rvert = n$) 和边集 $E \\subseteq \\{ \\{u,v\\} : u,v \\in V, u \\neq v \\}$ (其中 $\\lvert E \\rvert = m$) 给出。\n- 图 $G=(V,E)$ 上的 $q$-态铁磁 Potts 模型的自旋构型为 $\\sigma \\in \\{1,2,\\dots,q\\}^{V}$，其概率与 $\\exp\\left(\\beta \\sum_{\\{u,v\\}\\in E} \\mathbf{1}\\{\\sigma(u)=\\sigma(v)\\}\\right)$ 成正比，其中 $\\beta \\ge 0$ 为逆温度。\n- Edwards–Sokal (ES) 耦合将 Potts 模型与参数为 $(p,q)$ 的 FK 随机簇测度联系起来，其中 $p = 1 - e^{-\\beta}$；键构型 $\\omega \\in \\{0,1\\}^{E}$ 上的 FK 测度的概率与 $p^{\\lvert \\omega \\rvert} (1-p)^{m - \\lvert \\omega \\rvert} q^{k(\\omega)}$ 成正比，其中 $k(\\omega)$ 是由开边 $\\{e \\in E : \\omega(e)=1\\}$ 诱导的子图中的连通分量数。\n- Swendsen–Wang (SW) 动力学使用 ES 耦合：给定一个自旋构型 $\\sigma_t$，当且仅当 $\\sigma_t(u)=\\sigma_t(v)$ 时，边 $\\{u,v\\}$ 上的键 $B_t$ 以概率 $p$ 独立地打开；然后，$(V, B_t)$ 的每个连通分量被独立地从 $\\{1,\\dots,q\\}$ 中均匀随机赋予一个新的自旋。\n- 键构型上的一个偏序是逐坐标包含关系：对于 $\\omega, \\omega' \\in \\{0,1\\}^{E}$，定义 $\\omega \\preceq \\omega'$ 当且仅当 $\\{e \\in E : \\omega(e)=1\\} \\subseteq \\{e \\in E : \\omega'(e)=1\\}$。\n\n您的程序必须执行两项实验，并报告在 CFTP 式构造下的合并可行性：\n1. 针对 FK 随机簇单边热浴动力学的单调 CFTP：\n   - 考虑对从 $E$ 中均匀选择的单条边 $e = \\{u,v\\}$ 进行热浴更新。给定当前的键构型 $\\omega$，令 $\\omega^{\\setminus e}$ 表示移除边 $e$ 后的构型。$\\omega(e)$ 的条件开放概率为：\n     - 如果 $u$ 和 $v$ 在由 $\\omega^{\\setminus e}$ 的开边诱导的图中是连通的，则设 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = p$。\n     - 否则，设 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \\dfrac{p}{p + (1-p) q}$。\n   - 已知对于 $q \\ge 1$，此马尔可夫链在包含序下是吸引的 (attractive)。使用一个由固定的边选择序列和独立的均匀变量驱动的宏大耦合 (grand coupling)，以实现带有包含序的单调 CFTP。使用倍增调度：使用相同的驱动随机性，先模拟从时间 $-1$ 到 $0$ 的链，然后是从 $-2$ 到 $0$，再是从 $-4$ 到 $0$，依此类推。将下界链和上界链分别从最小和最大键构型（即所有边都闭合和所有边都打开）开始。当时间 $0$ 时下界和上界构型一致时，声明合并。\n   - 您必须为测试用例报告的合并时间是产生合并的最小倍增窗口中的单边更新次数。如果在指定的最大窗口大小内未检测到合并，则报告 $-1$。\n\n2. 尝试通过键序控制为 Swendsen–Wang 实现单调 CFTP：\n   - 如上定义键序偏序 $\\preceq$。对于 SW，时间 $t$ 的键形成使用每条边的均匀随机变量 $U_{t,e} \\sim \\mathrm{Uniform}(0,1)$，当且仅当 $U_{t,e}  p$ 且自旋相等时打开边 $\\{u,v\\}$。一种在键空间中的朴素受控边界方法忽略了自旋，并在每个时间 $t$ 提出了一个上界键集 $U_t^{\\mathrm{up}} = \\{ e \\in E : U_{t,e}  p \\}$ 和一个下界键集 $U_t^{\\mathrm{low}} = \\varnothing$。\n   - 实现一个与 FK 情况类似的倍增调度，但使用上述朴素的键序边界；您的每个时间步的“上界”和“下界”键集仅由均匀随机变量 $U_{t,e}$ 驱动。在这种朴素方案下，仅当对于所有可能的自旋路径，上界和下界过程在时间 $0$ 必然重合时，才声明合并。此朴素方案中的一个必要条件是，在模拟窗口的每个时间步，对所有 $e \\in E$ 都有 $U_{t,e} \\ge p$。在这种情况下，两个边界都强制键构型为 $\\varnothing$，使得 SW 自旋重着色变得无关紧要。如果在达到最大窗口前此条件未被满足，则报告 $-1$ 表示未能检测到合并。\n   - 该构造旨在评估实用性：预计仅在平凡或近乎平凡的情况下（例如 $p=0$）才能检测到合并。\n\n您的实现约束：\n- 所有图都必须被视为抽象的有限无向图，顶点索引为 $0,1,\\dots,n-1$，边指定为无序对 $\\{u,v\\}$，其中 $u \\neq v$。\n- 对于 FK 热浴动力学，您必须使用逻辑上正确的图搜索算法，在当前开边子图中（不包括正在更新的边）计算端点的“连通性”。\n- 对于 CFTP，您必须实现一个倍增调度。驱动随机性（边的选择和均匀随机变量）对于一个测试用例必须是固定的，并且可按时间可复现地索引，以确保单调耦合在各个倍增窗口间有效。\n- 所有随机变量必须使用每个测试用例中指定的固定种子生成，以确保可复现性。不允许使用外部数据或用户输入。\n\n测试用例：\n对于下面的每个测试用例，您的程序必须按要求计算并返回一个整数。程序必须生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的整数列表。\n\n- 案例 1 (FK 热浴，“理想路径”)：$n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}, \\{3,0\\}\\}$, $q=2$, $p=0.5$, 最大倍增次数 $=12$, 种子 $=123$。\n- 案例 2 (FK 热浴，强耦合)：$n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}\\}$, $q=3$, $p=0.9$, 最大倍增次数 $=12$, 种子 $=456$。\n- 案例 3 (SW 朴素键序尝试，不切实际的机制)：$n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.5$, 最大倍增次数 $=12$, 种子 $=789$。\n- 案例 4 (SW 朴素键序尝试，边界情况)：$n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.0$, 最大倍增次数 $=12$, 种子 $=42$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表（例如，“[r1,r2,r3,r4]”），其中 $r_i$ 是案例 $i$ 的整数结果。\n- 不涉及物理单位。所有数字都是纯整数。\n\n您的实现必须是完整的、可直接运行的，并严格遵守最终输出格式和上述约束。",
            "solution": "用户提供的问题陈述已经过分析，并被确定为有效。它具有科学依据，问题定义明确且客观。为实现一个完整且无歧义的程序，所有必需的参数、定义和条件均已提供。该问题正确地描述了统计力学和计算物理学中的既定概念，即 Potts 模型和 Fortuin-Kasteleyn (FK) 模型、Swendsen-Wang 动力学以及“过去耦合”(CFTP) 精确采样算法。所提出的两项实验是对单调 CFTP 方法在不同动力学下的适用性进行的明确界定的研究，并带有清晰的成功和失败标准。因此，我们可以着手提供一个完整的解决方案。\n\n核心任务是实现两个基于 CFTP 范式的不同模拟实验，两者都采用倍增窗口调度来寻找合并时间。第一个实验将标准的单调 CFTP 算法应用于 FK 随机簇模型，而第二个实验则分析了一种用于 Swendsen-Wang 算法的朴素类 CFTP 构造的可行性。\n\n### 实验 1：FK 热浴动力学的单调 CFTP\n\n**理论基础**\n“过去耦合”(CFTP) 算法，特别是其单调变体，提供了一种从马尔可夫链的平稳分布中生成精确样本的方法。其有效性依赖于三个关键组成部分：\n$1$. 一个具有偏序 $\\preceq$ 的状态空间 $\\mathcal{S}$。\n$2$. $\\mathcal{S}$ 中的一个最小元 $\\omega_{\\min}$ 和一个最大元 $\\omega_{\\max}$，使得对于任何 $\\omega \\in \\mathcal{S}$，都有 $\\omega_{\\min} \\preceq \\omega \\preceq \\omega_{\\max}$。\n$3$. 一族关于偏序单调的更新函数 $\\{f(\\cdot, U)\\}$，由随机性 $U$ 参数化。也就是说，对于任意两个状态 $\\omega_1, \\omega_2 \\in \\mathcal{S}$，如果 $\\omega_1 \\preceq \\omega_2$，那么对于相同的随机性 $U$ 的实现，有 $f(\\omega_1, U) \\preceq f(\\omega_2, U)$。\n\n在此问题中，状态空间 $\\mathcal{S}$ 是图 $G=(V,E)$ 上所有键构型的集合，即 $\\mathcal{S} = \\{0,1\\}^E$。偏序是逐坐标包含关系：$\\omega \\preceq \\omega'$ 当且仅当 $\\omega$ 中的开边集合是 $\\omega'$ 中开边集合的子集。最小元 $\\omega_{\\min}$ 是所有边都闭合的构型 ($0$)，最大元 $\\omega_{\\max}$ 是所有边都打开的构型 ($1$)。\n\n更新函数对应于 FK 随机簇测度的单边热浴吉布斯采样器。选择一条边 $e=\\{u,v\\}$，并根据所有其他边 $\\omega^{\\setminus e}$ 的状态，从条件分布中重新采样其状态。边 $e$ 为开的条件概率由下式给出：\n$$\n\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \n\\begin{cases} \np  \\text{如果 } u \\text{ 和 } v \\text{ 在 } (V, \\omega^{\\setminus e}) \\text{ 中是连通的} \\\\\n\\frac{p}{p + (1-p)q}  \\text{否则} \n\\end{cases}\n$$\n对于 $q \\ge 1$，此更新确实是单调的。要理解这一点，设 $\\omega_1 \\preceq \\omega_2$。在 $\\omega^{\\setminus e}$ 中端点 $\\{u,v\\}$ 的连通性是一个单调属性：如果 $u$ 和 $v$ 在 $\\omega_1^{\\setminus e}$ 中是连通的，那么它们在 $\\omega_2^{\\setminus e}$ 中也必定是连通的。因为 $q \\ge 1$，我们有 $p + (1-p)q \\ge p + (1-p) = 1$，这意味着 $\\frac{p}{p + (1-p)q} \\le p$。因此，概率 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e})$ 是 $\\omega^{\\setminus e}$ 在包含序下的一个非减函数。当使用一个共同的均匀随机变量 $U$ 来决定更新（即，如果 $U  \\mathbb{P}(\\omega(e)=1 | \\omega^{\\setminus e})$ 则设置 $\\omega(e)=1$）时，生成的更新后构型将保持偏序关系。\n\n**算法设计**\n该算法实现了一个倍增调度。我们寻找一个时间窗口 $[-T, 0)$，使得如果我们分别在时间 $-T$ 从 $\\omega_{\\min}$ 和 $\\omega_{\\max}$ 开始两条链，并使用*完全相同的随机数序列*将它们演化到时间 $0$，它们在时间 $0$ 的状态是相同的。\n$1$. 初始化窗口大小 $T=1$。\n$2$. 开始一个循环，直到合并或达到最大倍增次数。\n$3$. 设置 $\\omega_{\\text{low}}( -T ) = \\omega_{\\min}$（所有边都闭合）和 $\\omega_{\\text{high}}( -T ) = \\omega_{\\max}$（所有边都打开）。\n$4$. 对于从 $-T$ 到 $-1$ 的每个时间步 $t$：\n    a. 为该时间步生成随机性：一个均匀选择的边索引 $i_t \\in \\{0, \\dots, m-1\\}$ 和一个均匀随机数 $U_t \\in [0,1)$。为确保有效的宏大耦合，此随机性必须是时间索引 $t$ 的一个确定性函数，可在不同的倍增窗口中复现。\n    b. 更新 $\\omega_{\\text{low}}$：令 $e = E[i_t]$。在由 $\\omega_{\\text{low}}$ 的开边（不包括 $e$）定义的图中检查 $e$ 的端点的连通性。这通过广度优先搜索（BFS）或深度优先搜索（DFS）完成。根据连通性，计算 $e$ 为开的概率 $P_{\\text{low}}$。如果 $U_t  P_{\\text{low}}$，则将 $\\omega_{\\text{low}}$ 中边 $e$ 的新状态设置为 $1$，否则为 $0$。\n    c. 使用相同的边 $e$ 和均匀变量 $U_t$，按照与 $\\omega_{\\text{low}}$ 相同的过程更新 $\\omega_{\\text{high}}$。\n$5$. 在时间 $0$，检查是否 $\\omega_{\\text{low}}(0) = \\omega_{\\text{high}}(0)$。\n$6$. 如果它们相同（合并），算法终止。所需的合并时间是窗口大小 $T$。\n$7$. 如果它们不同，将窗口大小加倍 $T \\leftarrow 2T$ 并从步骤 3 重复。如果超过了允许的最大窗口大小，则报告 $-1$。\n\n### 实验 2：为 Swendsen-Wang 尝试单调 CFTP\n\n**理论基础**\nSwendsen-Wang (SW) 动力学是自旋构型空间 $\\{1, \\dots, q\\}^V$ 上的一个马尔可夫链。单个更新步骤 $\\sigma_t \\to \\sigma_{t+1}$ 通过一个辅助键构型 $\\omega_t$ 进行：\n$1$. 给定 $\\sigma_t$，对于每个边 $e=\\{u,v\\}$，如果 $\\sigma_t(u)=\\sigma_t(v)$，则键 $\\omega_t(e)$ 以概率 $p$ 设置为 $1$。如果 $\\sigma_t(u) \\neq \\sigma_t(v)$，则 $\\omega_t(e)$ 设置为 $0$。这可以写成 $\\omega_t(e) = 1$ 当且仅当 $U_{t,e}  p$ 且 $\\sigma_t(u) = \\sigma_t(v)$，其中 $U_{t,e}$ 是独立同分布的 $\\mathrm{Uniform}(0,1)$ 变量。\n$2$. 通过识别图 $(V, \\omega_t)$ 中的连通分量，并为每个分量从 $\\{1, \\dots, q\\}$ 中独立均匀地选择一个新自旋，生成一个新的自旋构型 $\\sigma_{t+1}$。\n\n该问题要求评估键空间中的一种朴素控制方案。在每个时间 $t$，独立于自旋构型 $\\sigma_t$，我们可以为生成的键构型 $\\omega_t$ 定义一个下界和一个上界。\n- **下界：** $\\omega_{\\text{low}, t} = \\varnothing$（所有边都闭合）。这是一个有效的下界，因为只有当自旋匹配时边才可能被激活，因此没有任何边是保证被激活的。\n- **上界：** $\\omega_{\\text{up}, t} = \\{e \\in E : U_{t,e}  p\\}$。这是一个有效的上界，因为只有当 $U_{t,e}  p$ 时边才可能被激活。\n\n**算法设计**\n该实验旨在寻找键构型 $\\omega_t$ 对于所有可能的自旋路径都唯一确定的条件。这发生当且仅当在模拟窗口内的所有时间步，下界和上界都重合，即对于 $t \\in [-T, -1)$ 都有 $\\omega_{\\text{low}, t} = \\omega_{\\text{up}, t}$。这个条件简化为在窗口中的所有 $t$ 都有 $\\varnothing = \\{e \\in E : U_{t,e}  p\\}$。这等价于要求在窗口中的每个时间步 $t$ 和所有边 $e$ 上，都有 $U_{t,e} \\ge p$。该算法是对这一条件的直接检查。\n\n$1$. 初始化窗口大小 $T=1$。\n$2$. 开始一个循环，直到条件满足或达到最大倍增次数。\n$3$. 对于窗口 $[-T, 0)$：\n    a. 假设条件成立 (`coalesced = True`)。\n    b. 对于从 $-T$ 到 $-1$ 的每个时间步 $t$：\n        i. 为此步骤生成随机性：一组 $m$ 个均匀随机数 $\\{U_{t,e}\\}_{e \\in E}$。\n        ii. 检查是否对所有 $e \\in E$ 都有 $U_{t,e} \\ge p$。\n        iii. 如果对任何边此检查失败，则此窗口不满足条件。设置 `coalesced = False` 并中断内循环。\n$4$. 如果在检查完窗口中的所有时间步后 `coalesced` 仍然为 `True`，则算法终止。结果是窗口大小 $T$。\n$5$. 如果 `coalesced` 为 `False`，将窗口大小加倍 $T \\leftarrow 2T$ 并重复。如果超过了允许的最大窗口大小，则报告 $-1$。\n该实验旨在显示这种朴素方法的非实用性。所有 $m$ 条边同时满足 $U_{t,e} \\ge p$ 的概率是 $(1-p)^m$。要使此条件在大小为 $T$ 的窗口内持续成立，概率是 $((1-p)^m)^T$，它呈指数级衰减，使得对于任何非平凡的 $p  0$ 和 $m0$，合并都极不可能发生。对于 $p=0$ 的特殊情况，条件 $U_{t,e} \\ge 0$ 总是成立，因此立即以 $T=1$ 找到合并。\n\n### 实现策略\n\n解决方案将使用 Python 实现，借助 `numpy` 库进行数值运算和随机数生成。每个测试用例使用一个单独的、有种子的 `numpy.random.Generator` 实例以确保可复现性。对于宏大耦合，预先生成一个对应于最大可能模拟窗口的大量随机数缓冲（用于边选择和均匀变量）。大小为 $T$ 的窗口的模拟随后确定性地使用此缓冲区的最后 $T$ 个条目，确保时间 $t$ 的随机性在各个倍增窗口中保持不变。FK 情况下的图连通性将使用标准的 BFS 算法和 `collections.deque` 来实现。",
            "answer": "```python\nimport numpy as np\nimport collections\n\ndef is_connected(u, v, n, edges, omega):\n    \"\"\"\n    Checks if nodes u and v are connected in the subgraph induced by open edges.\n    Uses Breadth-First Search (BFS).\n    \n    Args:\n        u (int): The first vertex.\n        v (int): The second vertex.\n        n (int): The number of vertices in the graph.\n        edges (list): The list of all edges in the graph.\n        omega (np.ndarray): The bond configuration (1 for open, 0 for closed).\n    \n    Returns:\n        bool: True if u and v are connected, False otherwise.\n    \"\"\"\n    if u == v:\n        return True\n    \n    adj = collections.defaultdict(list)\n    open_edges_indices = np.where(omega)[0]\n    for edge_idx in open_edges_indices:\n        n1, n2 = edges[edge_idx]\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n        \n    q = collections.deque([u])\n    visited = {u}\n    \n    while q:\n        curr = q.popleft()\n        if curr == v:\n            return True\n        for neighbor in adj.get(curr, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                q.append(neighbor)\n    return False\n\ndef solve_fk_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    Solves Experiment 1: Monotone CFTP for FK heat-bath dynamics.\n    \"\"\"\n    m = len(E)\n    edges = [tuple(e) for e in E]\n    max_window_size = 2**(max_doublings)\n\n    # Pre-generate randomness to ensure grand coupling\n    rng = np.random.default_rng(seed)\n    random_edge_indices = rng.integers(0, m, size=max_window_size)\n    random_uniforms = rng.uniform(size=max_window_size)\n\n    window_size = 1\n    for d in range(max_doublings):\n        # The evolution happens from time -window_size to -1\n        # which corresponds to indices max_window_size - window_size to max_window_size - 1\n        start_idx = max_window_size - window_size\n        \n        # Lower chain starts with all edges closed\n        omega_low = np.zeros(m, dtype=bool)\n        # Upper chain starts with all edges open\n        omega_high = np.ones(m, dtype=bool)\n\n        for i in range(window_size):\n            t_idx = start_idx + i\n            edge_idx = random_edge_indices[t_idx]\n            U = random_uniforms[t_idx]\n            u, v = edges[edge_idx]\n\n            # Update lower chain\n            omega_low_temp = np.copy(omega_low)\n            omega_low_temp[edge_idx] = False\n            conn_low = is_connected(u, v, n, edges, omega_low_temp)\n            prob_open_low = p if conn_low else p / (p + (1 - p) * q)\n            omega_low[edge_idx] = U  prob_open_low\n\n            # Update upper chain with the same randomness\n            omega_high_temp = np.copy(omega_high)\n            omega_high_temp[edge_idx] = False\n            conn_high = is_connected(u, v, n, edges, omega_high_temp)\n            prob_open_high = p if conn_high else p / (p + (1 - p) * q)\n            omega_high[edge_idx] = U  prob_open_high\n        \n        if np.array_equal(omega_low, omega_high):\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve_sw_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    Solves Experiment 2: Attempted monotone CFTP for Swendsen-Wang.\n    \"\"\"\n    m = len(E)\n    max_window_size = 2**(max_doublings)\n    \n    # Pre-generate randomness. Each time step needs m uniform numbers.\n    rng = np.random.default_rng(seed)\n    random_uniforms = rng.uniform(size=(max_window_size, m))\n\n    window_size = 1\n    for d in range(max_doublings):\n        start_idx = max_window_size - window_size\n        \n        coalesced_in_window = True\n        for i in range(window_size):\n            t_idx = start_idx + i\n            uniforms_t = random_uniforms[t_idx]\n            \n            # The condition for the naive bound to coalesce at step t is\n            # that U_{t,e} = p for all edges e.\n            if not np.all(uniforms_t >= p):\n                coalesced_in_window = False\n                break\n        \n        if coalesced_in_window:\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve():\n    test_cases = [\n        # Case 1 (FK heat-bath, “happy path”)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3], [3,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 123},\n        # Case 2 (FK heat-bath, strong coupling)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3]], 'q': 3, 'p': 0.9, 'max_doublings': 12, 'seed': 456},\n        # Case 3 (SW naive bond-order attempt, impractical regime)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 789},\n        # Case 4 (SW naive bond-order attempt, boundary case)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.0, 'max_doublings': 12, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'fk':\n            result = solve_fk_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        elif case['type'] == 'sw':\n            result = solve_sw_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        else:\n            raise ValueError(\"Unknown test case type\")\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}