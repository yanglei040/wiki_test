{
    "hands_on_practices": [
        {
            "introduction": "在黎曼流形上实现几何MCMC方法时，一个首要的实际问题是如何选择一个合适的积分步长$h$。与欧几里得空间不同，在弯曲的流形上，过大的步长可能会导致数值积分“跳出”一个局部坐标卡明确定义的区域，或者越过割迹（cut locus），使得指数映射失效。这个练习  将指导你如何通过将步长$h$与流形的内蕴几何性质——具体来说是其截面曲率$K$和单射半径$\\mathrm{inj}(M)$——联系起来，从而推导出一个安全的步长界限。通过这个实践，你将理解抽象的几何概念是如何直接为稳健的算法设计提供依据的。",
            "id": "3310543",
            "problem": "考虑为几何马尔可夫链蒙特卡洛（Markov chain Monte Carlo (MCMC)）选择一个积分器步长的任务，该选择基于比较几何，以确保黎曼流形上的离散哈密顿动力学保持在法邻域内，在该邻域中指数映射是微分同胚。工作环境设定为具有有界截面曲率和已知单射半径的黎曼流形，并特化到嵌入在 $\\mathbb{R}^3$ 中半径为 $R$ 的二维球面。\n\n您需要仅使用核心几何事实推导蛙跳步长的保守界，然后实现并数值验证该界足以使每个位置更新都保持在法邻域内。角度必须以弧度为单位。\n\n基本定义和事实：\n- 截面曲率上界为 $K_{\\max}$。\n- 单射半径为 $\\mathrm{inj}(M)$。\n- 沿着初速度为 $v$ 的测地线，在时间 $t$ 内行进的测地距离为 $v t$。\n- 对于截面曲率有上界 $K_{\\max} > 0$ 的流形，比较几何表明，沿任何测地线的第一个共轭点出现的位置不早于距离 $\\pi / \\sqrt{K_{\\max}}$ 处。\n- 一个点周围的法邻域包含在该点为中心、半径为 $\\min\\{\\mathrm{inj}(M), \\pi/\\sqrt{K_{\\max}}\\}$ 的测地球内。\n\n对球面的特化：\n- 考虑半径为 $R$ 的二维球面，记作 $\\mathbb{S}^2_R$，其常截面曲率为 $K = 1/R^2$，单射半径为 $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$。\n- 对于势能为零的测地哈密顿量，其连续时间流即为测地流；时长为 $h$ 的蛙跳位置更新与沿当前切速度（速率为 $v$）作用时间 $h$ 的指数映射重合。\n- 一次大小为 $h$ 的蛙跳位置更新使点从当前位置移动了测地距离 $s = v h$。\n\n您的任务：\n1) 从上述事实出发，不借助任何未引入的特殊公式，推导出一个关于时间步长 $h$ 的保守不等式。该不等式用 $K_{\\max}$、$\\mathrm{inj}(M)$、轨迹上的速度上界 $v_{\\max}$（即 $v \\le v_{\\max}$）以及用户选择的安全因子 $\\alpha \\in (0,1]$ 表示，并保证每次大小为 $h$ 的位置更新都保持在当前点的法邻域内。\n\n2) 将任务1中得到的界特化到二维球面 $\\mathbb{S}^2_R$ 上，使用 $K_{\\max} = 1/R^2$ 和 $\\mathrm{inj}(M) = \\pi R$。\n\n3) 实现一个独立完整的程序，该程序：\n- 使用任务2中的界为给定的 $(R, v_{\\max}, \\alpha)$ 计算步长 $h$。\n- 使用精确测地更新，在零势能的 $\\mathbb{S}^2_R$ 上模拟 $N$ 条独立轨迹。对于每条轨迹：\n  - 通过将高斯向量归一化至半径 $R$，在 $\\mathbb{S}^2_R$ 上均匀采样一个随机初始点 $q_0$。\n  - 在 $q_0$ 处采样一个随机初始切速度 $u_0$，方法是将一个高斯向量投影到切平面，归一化为单位范数，然后缩放使其范数为 $v_{\\max}$，从而在每一步都实现最坏情况下的界。\n  - 进行 $L$ 步，通过在 $\\mathbb{S}^2_R$ 上对精确测地流积分时间 $h$ 来更新状态 $(q,u)$，并记录每步所行进的测地距离 $s = v h$。\n  - 验证每步的测地距离都满足 $s < \\mathrm{inj}(\\mathbb{S}^2_R)$，以确保更新保持在当前点的法邻域内。\n- 如果所有轨迹的所有步骤都满足严格不等式 $s < \\mathrm{inj}(\\mathbb{S}^2_R)$，则宣布测试用例成功，否则为不成功。\n\n在 $\\mathbb{S}^2_R$ 上的测地更新：\n- 如果当前位置为 $q \\in \\mathbb{R}^3$（范数 $\\lVert q \\rVert = R$），切速度为 $u \\in \\mathbb{R}^3$（满足 $q^\\top u = 0$，范数 $\\lVert u \\rVert = v$），则时间 $h$ 内的精确测地流由在 $q$ 和 $u$ 张成的平面中旋转角度 $\\theta = (v/R) h$ 给出：\n  - $q_{\\text{next}} = \\cos(\\theta)\\, q + \\sin(\\theta)\\, R \\, \\frac{u}{v}$，\n  - $u_{\\text{next}} = - \\frac{v}{R} \\sin(\\theta)\\, q + \\cos(\\theta)\\, u$。\n\n测试套件：\n提供以下测试用例。每个测试用例是一个元组 $(R, \\alpha, v_{\\max}, L, N, \\text{seed})$：\n- 情况 A (正常路径): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 0.9, 1.0, 10, 50, 42)$。\n- 情况 B (边界条件，预期失败): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 1.0, 1.0, 1, 10, 0)$。\n- 情况 C (更小的球面，更高的曲率): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (0.5, 0.9, 2.0, 8, 30, 7)$。\n- 情况 D (更大的球面，更低的曲率): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (3.0, 0.99, 0.5, 20, 60, 123)$。\n- 情况 E (近乎平坦的大球面): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (100.0, 0.5, 5.0, 3, 20, 2024)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列结果，每个条目都是一个布尔值，表示测试是通过 (true) 还是失败 (false)。例如，输出格式如 `[true,false,...]`。\n\n您的实现必须是完全独立且无需用户输入即可运行的。角度必须以弧度为单位。除了指定角度以弧度为单位外，不涉及任何物理单位。",
            "solution": "该问题是有效的。这是一个定义明确且科学上合理的练习，涉及将黎曼几何应用于为几何马尔可夫链蒙特卡洛方法设计数值积分器。所有必要的定义、常数和公式都已提供，并且没有内部矛盾。\n\n解决方案按要求分三部分进行：首先，推导积分器步长 $h$ 的一个通用保守界；其次，将此界特化到二维球面 $\\mathbb{S}^2_R$；第三，描述数值验证过程。\n\n### 任务1：推导通用步长界\n\n主要目标是选择一个蛙跳积分器步长 $h$，使得每次位置更新都保持在黎曼流形 $M$ 上当前点的法邻域内。点 $q \\in M$ 周围的法邻域是指指数映射 $\\exp_q$ 是一个微分同胚的区域。问题指出，该邻域被包含在半径为 $r_{\\text{normal}}$ 的测地球内，其中：\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\n这里，$\\mathrm{inj}(M)$ 是流形的单射半径，$K_{\\max} > 0$ 是其截面曲率的上界。$\\pi/\\sqrt{K_{\\max}}$ 这一项源自 Rauch 比较定理，该定理给出了到第一个共轭点距离的界。\n\n为使积分步骤严格落在此邻域内，该步骤行进的测地距离 $s$ 必须满足不等式：\n$$s < r_{\\text{normal}}$$\n一次大小为 $h$、瞬时速率为 $v$ 的蛙跳位置更新会行进测地距离 $s = vh$。为保守地确保满足该条件，我们引入一个安全因子 $\\alpha \\in (0, 1]$ 并要求：\n$$s \\le \\alpha \\cdot r_{\\text{normal}}$$\n代入 $s = vh$，我们得到 $vh \\le \\alpha \\cdot r_{\\text{normal}}$。\n\n速率 $v$ 可能沿轨迹变化。问题提供了一个上界 $v_{\\max}$，使得在任何时候都有 $v \\le v_{\\max}$。为保证该条件对任何一步都成立，我们必须考虑速率达到最大的最坏情况。因此，条件变为：\n$$v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$$\n对此不等式求解步长 $h$ 即可得到所需的保守界：\n$$h \\le \\frac{\\alpha}{v_{\\max}} \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\n任何满足此不等式的步长 $h$ 都能确保测地线位移 $s = vh \\le v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$。如果 $\\alpha < 1$，则保证 $s < r_{\\text{normal}}$，从而确保更新严格保持在法邻域内。如果 $\\alpha=1$，该步骤可能会落在邻域的边界上。\n\n### 任务2：特化到二维球面\n\n我们现在将推导出的界特化到半径为 $R$ 的二维球面（记为 $\\mathbb{S}^2_R$）的情况。球面的几何性质如下：\n- 常截面曲率 $K = 1/R^2$。这意味着上界为 $K_{\\max} = 1/R^2$。\n- 单射半径 $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$。\n\n我们使用这些值计算法邻域的半径 $r_{\\text{normal}}$：\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm{inj}(\\mathbb{S}^2_R), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\} = \\min\\left\\{\\pi R, \\frac{\\pi}{\\sqrt{1/R^2}}\\right\\} = \\min\\{\\pi R, \\pi R\\} = \\pi R$$\n这个结果在几何上是直观的：在球面上，单射半径（到对径点的距离）恰好是共轭点首次出现的距离。\n\n将 $r_{\\text{normal}} = \\pi R$ 代入关于 $h$ 的一般不等式，得到二维球面的特化界：\n$$h \\le \\frac{\\alpha \\pi R}{v_{\\max}}$$\n对于数值模拟，我们将选择此界允许的最大步长来测试其极限：\n$$h = \\frac{\\alpha \\pi R}{v_{\\max}}$$\n\n### 任务3：数值验证与实现\n\n最后的任务是实现一个程序来数值验证推导出的界。模拟将使用上面计算的步长 $h$，并验证每一步都满足所需条件。\n\n对于给定的问题，哈密顿量具有零势能，这对应于测地流。在这种情况下，动能以及速率 $v$ 是守恒的。模拟的设置使得初始速率为 $v_{\\max}$，因此在整个轨迹中速率保持为 $v = v_{\\max}$。\n\n因此，每步所行进的测地距离是恒定的：\n$$s = vh = v_{\\max} \\cdot \\left(\\frac{\\alpha \\pi R}{v_{\\max}}\\right) = \\alpha \\pi R$$\n问题所要求的验证检查是确认此距离严格小于球面的单射半径：\n$$s < \\mathrm{inj}(\\mathbb{S}^2_R)$$\n代入 $s$ 和 $\\mathrm{inj}(\\mathbb{S}^2_R)$ 的表达式，条件变为：\n$$\\alpha \\pi R < \\pi R$$\n这个不等式简化为 $\\alpha < 1$。\n\n因此，当且仅当一个测试用例的安全因子 $\\alpha$ 严格小于 $1$ 时，模拟预期会通过。当 $\\alpha=1$ 时，步长距离 $s$ 将等于单射半径，违反了严格不等式。提供的测试用例旨在确认这一点：情况 B 使用 $\\alpha=1$，预期会失败，而所有其他情况使用 $\\alpha < 1$，预期会通过。\n\n实现将遵循指定的流程：对于每个测试用例，计算 $h$，然后模拟 $N$ 条各有 $L$ 步的轨迹。在每一步中，计算测地距离 $s$ 并检查是否 $s < \\mathrm{inj}(\\mathbb{S}^2_R)$。如果此检查在任何时候失败，该测试用例将被标记为不成功。程序将以指定格式报告每个测试用例的成功或失败。测地更新使用提供的精确旋转公式进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a leapfrog step size bound for geometric MCMC on the 2-sphere.\n    \"\"\"\n    test_cases = [\n        # (R, alpha, vmax, L, N, seed)\n        (1.0, 0.9, 1.0, 10, 50, 42),      # Case A: Happy path\n        (1.0, 1.0, 1.0, 1, 10, 0),        # Case B: Boundary condition, should fail\n        (0.5, 0.9, 2.0, 8, 30, 7),        # Case C: Smaller sphere, higher curvature\n        (3.0, 0.99, 0.5, 20, 60, 123),    # Case D: Larger sphere, lower curvature\n        (100.0, 0.5, 5.0, 3, 20, 2024),   # Case E: Near-flat large sphere\n    ]\n\n    results = []\n\n    for R, alpha, vmax, L, N, seed in test_cases:\n        np.random.seed(seed)\n        \n        # Derived step size from Task 2 in the problem description.\n        # This is the largest step size that satisfies the conservative bound.\n        h = (alpha * np.pi * R) / vmax\n        \n        # The injectivity radius for the sphere S^2_R is the radius of the normal neighborhood.\n        inj_radius = np.pi * R\n        \n        test_case_passed = True\n        \n        # The problem requires simulating trajectories to validate the bound.\n        # This simulation implements the procedure described in Task 3.\n        for _ in range(N):\n            # 1. Sample initial position q0 uniformly on the sphere of radius R.\n            z = np.random.randn(3)\n            q = R * z / np.linalg.norm(z)\n            \n            # 2. Sample initial velocity u0 tangent to q0 with norm vmax.\n            # This is done by projecting a random vector onto the tangent plane at q.\n            w = np.random.randn(3)\n            q_unit = q / R # q is guaranteed to be non-zero\n            w_proj = w - np.dot(w, q_unit) * q_unit\n\n            # Handle the unlikely case where w is parallel to q.\n            norm_w_proj = np.linalg.norm(w_proj)\n            if norm_w_proj < 1e-12:\n                # Find an orthogonal vector to q_unit if w is nearly parallel.\n                basis_vec = np.array([1.0, 0.0, 0.0])\n                if np.abs(np.dot(q_unit, basis_vec)) > 0.99:\n                    basis_vec = np.array([0.0, 1.0, 0.0])\n                w_proj = basis_vec - np.dot(basis_vec, q_unit) * q_unit\n                norm_w_proj = np.linalg.norm(w_proj)\n\n            u = vmax * w_proj / norm_w_proj\n\n            # 3. Simulate L steps of the geodesic flow.\n            for _ in range(L):\n                # For geodesic flow (zero potential), velocity magnitude is conserved.\n                v = np.linalg.norm(u)\n                \n                # Geodesic distance traveled in this step.\n                s = v * h\n                \n                # 4. Verify that the step remains strictly within the normal neighborhood.\n                # The radius of the normal neighborhood is the injectivity radius here.\n                if not (s < inj_radius):\n                    test_case_passed = False\n                    break\n                \n                # 5. Update state using the exact geodesic flow on the sphere.\n                theta = (v / R) * h\n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n                \n                q_next = cos_theta * q + sin_theta * R * (u / v)\n                u_next = - (v / R) * sin_theta * q + cos_theta * u\n                \n                q, u = q_next, u_next\n            \n            if not test_case_passed:\n                break\n                \n        results.append(test_case_passed)\n        \n    # Final print statement in the exact required format.\n    # The boolean values are converted to lowercase strings 'true'/'false'.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在确定了稳定的积分步长之后，下一个核心问题便是评估我们所用积分器的性能。尽管沿着测地线的精确哈密顿流是理论上的“黄金标准”，但它在计算上往往是难以处理或成本高昂的。这个练习  探讨了一种常见的实用折衷方案：使用计算成本较低的“收缩”（retraction）和“向量输运”（vector transport）来替代指数映射和平行输运。你将亲手实现这种近似积分器，并通过测量哈密顿量的漂移来量化其主要缺点——能量不守恒的程度，从而将数值误差与流形的曲率直接联系起来。",
            "id": "3310525",
            "problem": "考虑一个黎曼流形上的单位速率测地哈密顿流，其中位置处于一个半径为 $r$ 的球面 $S^2_r \\subset \\mathbb{R}^3$ 上，该球面赋予了由环境欧几里得空间导出的圆度量。本题旨在量化一个几何哈密顿蒙特卡洛（HMC）积分器中，当分别使用收缩 $R_x$ 和向量移动 $T_x$ 替代真实的指数映射 $\\exp_x$ 和沿测地线的平行移动时，所引入的经验能量漂移。在零势能情况下进行计算，因此哈密顿量是纯动能的，即 $H(x,p) = \\tfrac{1}{2}\\langle p,p\\rangle$，其中 $p \\in T_x S^2_r$，$\\langle\\cdot,\\cdot\\rangle$ 是黎曼度量（在此与限制在切空间上的环境欧几里得内积一致）。经验误差将通过使用收缩与移动积分器遍历指定的测地路径长度 $L$ 后，哈密顿量的绝对偏差来衡量。\n\n推导和实现应基于以下基本事实和定义：\n- 黎曼流形 $(\\mathcal{M},g)$ 允许存在局部最小化距离的测地线，这些测地线在 Levi-Civita 联络下满足测地线方程，并且指数映射 $\\exp_x: T_x\\mathcal{M}\\to\\mathcal{M}$ 会沿着初始切向量为 $v\\in T_x\\mathcal{M}$ 的测地线前进。\n- 在 $S^2_r$ 上，测地线是大圆，并且沿测地线对切向量进行平行移动会保持内积和范数不变。\n- 对于圆球面 $S^2_r$，其截面曲率是常数，等于 $K = 1/r^2$，这在此设定中作为曲率范数 $\\|R\\|$。\n- 收缩 $R_x: T_x\\mathcal{M} \\to \\mathcal{M}$ 是一个光滑的局部映射，满足 $R_x(0_x) = x$ 和 $\\mathrm{D}R_x(0_x) = \\mathrm{id}_{T_x\\mathcal{M}}$，通常用作 $\\exp_x$ 的计算上更简单的替代品。\n- 向量移动 $T_x: T_x\\mathcal{M} \\to T_{R_x(v)}\\mathcal{M}$ 是平行移动的一种计算替代方法；在嵌入子流形上，最简单的选择是将环境向量投影到新的切空间上。\n\n问题要求：\n- 在点 $x_0 \\in S^2_r$ 和具有单位范数的切动量 $p_0 \\in T_{x_0}S^2_r$ 处进行初始化，以确保单位速率遍历，从而使得长度为 $h$ 的步长对应于测地弧长 $h$。\n- 概念上实现两种位置更新机制：用于分析的真实指数映射和平行移动，以及用于经验误差测量的近似收缩 $R_x$ 与简单的基于投影的向量移动 $T_x$。然而，最终报告的数值误差仅基于收缩与移动积分器。\n- 使用以下具体选择以使场景完全确定：\n  - 选择 $x_0 = (r,0,0) \\in \\mathbb{R}^3$ 和 $p_0 = (0,1,0) \\in \\mathbb{R}^3$，该向量在 $x_0$ 处是切向量，并且在圆度量下具有单位范数。\n  - 使用收缩 $R_x(v) = \\dfrac{r(x+v)}{\\|x+v\\|}$，它将环境更新归一化回到 $S^2_r$ 上。\n  - 使用向量移动 $T_x(w) = w - \\dfrac{\\langle w,x'\\rangle}{r^2}x'$，其中 $x'$ 是收缩后的新位置，即，将环境向量简单正交投影到新的切空间中。\n- 将总路径长度为 $L$ 的遍历离散化为 $N$ 个大小为 $h = L/N$ 的相等步长，其中 $N$ 在所有测试用例中是固定的且相同的。在每一步：\n  - 计算单位切线方向 $u = p/\\|p\\|$。\n  - 通过 $x \\leftarrow R_x(h\\,u)$ 更新位置。\n  - 通过 $p \\leftarrow T_x(p)$ 移动动量。\n- 在 $N$ 步之后，计算经验哈密顿误差为 $|H(x_N,p_N) - H(x_0,p_0)|$，其中 $H(x,p) = \\tfrac{1}{2}\\|p\\|^2$。\n- 报告曲率范数为 $\\|R\\| = 1/r^2$。尽管 $\\|R\\|$ 不会直接打印，但它会在测试套件中变化，并应用于分析中以解释结果。\n\n测试套件：\n- 所有情况均使用 $N=200$ 步，以及以下 $(r,L)$ 对，这些对检验了不同的曲率和路径长度范围，包括一个边界条件：\n  1. $(r,L) = (1.0, 0.0)$，曲率范数 $\\|R\\| = 1.0$，路径长度为零（边界情况）。\n  2. $(r,L) = (1.0, 0.1)$，曲率范数 $\\|R\\| = 1.0$，路径长度短（小步长范围）。\n  3. $(r,L) = (0.5, 0.5)$，曲率范数 $\\|R\\| = 4.0$，路径长度中等（高曲率范围）。\n  4. $(r,L) = (2.0, 1.0)$，曲率范数 $\\|R\\| = 0.25$，路径长度中等（低曲率范围）。\n  5. $(r,L) = (1.0, \\pi)$，曲率范数 $\\|R\\| = 1.0$，路径长度长（接近半周长）。\n\n您的程序应生成单行输出，其中包含上述测试用例的经验哈密顿误差，按顺序排列，形式为方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3,e_4,e_5]$）。不涉及物理单位，角度由几何结构隐含为弧度，数字应以普通十进制浮点数形式打印。",
            "solution": "问题陈述已经过严格验证，并被确定为黎曼流形上数值分析领域中一个有效、适定且科学合理的问题。它没有矛盾，提供了所有必要的定义和参数，并要求计算一个定义明确的量——特定数值积分器的能量误差。\n\n该问题研究了在半径为 $r$ 的 2-球面（记为 $S^2_r$）上，一个数值积分器的能量守恒性质。该系统是一个自由粒子，由动能哈密顿量 $H(x, p) = \\frac{1}{2} \\langle p, p \\rangle = \\frac{1}{2} \\|p\\|^2$ 描述，其中 $x \\in S^2_r$ 是位置， $p \\in T_x S^2_r$ 是动量。对于真实的测地流，该哈密顿量是一个守恒量。问题要求量化当真实流被一个基于收缩和向量移动的数值方案近似时，该守恒量的误差或漂移。\n\n流形是球面 $S^2_r = \\{x \\in \\mathbb{R}^3 \\mid \\|x\\|_2 = r\\}$。在点 $x$ 处的切空间是 $T_x S^2_r = \\{v \\in \\mathbb{R}^3 \\mid \\langle x, v \\rangle = 0\\}$。黎曼度量 $\\langle \\cdot, \\cdot \\rangle$ 是 $\\mathbb{R}^3$ 中标准欧几里得内积的限制。\n\n初始条件指定为位置 $x_0 = (r, 0, 0)$ 和动量 $p_0 = (0, 1, 0)$。向量 $p_0$ 在 $x_0$ 处与球面相切，因为 $\\langle x_0, p_0 \\rangle = 0$。初始动量的范数为 $\\|p_0\\| = 1$，对应于单位速率遍历。哈密顿量的初始值为 $H(x_0, p_0) = \\frac{1}{2} \\|p_0\\|^2 = \\frac{1}{2}(1)^2 = 0.5$。\n\n数值积分方案模拟了总路径长度为 $L$ 的动力学过程，离散为 $N$ 个大小相等的步长 $h = L/N$。第 $k$ 步（$k \\in \\{0, 1, \\dots, N-1\\}$）的状态是 $(x_k, p_k)$。状态根据以下算法更新为 $(x_{k+1}, p_{k+1})$：\n1. 通过对当前动量进行归一化来确定步长方向：$u_k = p_k / \\|p_k\\|$。\n2. 用于位置更新的切向量是 $v_k = h u_k$。\n3. 使用指定的收缩更新位置：$x_{k+1} = R_{x_k}(v_k) = \\frac{r(x_k + v_k)}{\\|x_k + v_k\\|}$。\n4. 使用指定的向量移动更新动量，该移动将环境向量 $p_k$ 投影到新的切空间 $T_{x_{k+1}}S^2_r$ 中：$p_{k+1} = T_{x_k \\to x_{k+1}}(p_k) = p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}$。\n\n在 $N$ 步之后，经验哈密顿误差计算为与初始值的绝对偏差：$\\Delta H = |H(x_N, p_N) - H(x_0, p_0)| = \\left| \\frac{1}{2}\\|p_N\\|^2 - 0.5 \\right|$。\n\n这个问题的关键在于分析单步如何影响哈密顿量。哈密顿量的变化与动量向量范数平方的变化直接相关。让我们分析向量移动对 $\\|p\\|^2$ 的影响：\n$$ \\|p_{k+1}\\|^2 = \\left\\| p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\right\\|^2 $$\n展开范数的平方可得：\n$$ \\|p_{k+1}\\|^2 = \\langle p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}, p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\rangle $$\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}\\|x_{k+1}\\|^2 $$\n由于 $x_{k+1} \\in S^2_r$，其范数为 $\\|x_{k+1}\\| = r$，因此 $\\|x_{k+1}\\|^2 = r^2$。代入此式，我们得到：\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}r^2 = \\|p_k\\|^2 - \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} $$\n这个结果表明 $\\|p_{k+1}\\|^2 \\le \\|p_k\\|^2$。等号仅在 $\\langle p_k, x_{k+1} \\rangle = 0$ 时成立，这意味着 $p_k$ 已经位于 $x_{k+1}$ 的切空间中。通常情况下，这并不成立。向量移动作为一种正交投影，不是等距同构，并会系统性地减小动量向量的范数。这导致哈密顿量单调递减，积分器是耗散的。这种效应的大小取决于几何形状（曲率 $K=1/r^2$）和步长 $h$。\n\n通过对 $5$ 个测试用例（$N=200$）中的每一个实施所述的迭代算法来获得解。\n- 对于情况 $(r, L) = (1.0, 0.0)$，路径长度 $L=0$，因此步长 $h=0$。不执行任何步骤，因此 $(x_N, p_N) = (x_0, p_0)$，误差为 $0$。\n- 对于其他四种情况，模拟运行 $N=200$ 步。初始状态 $(x_0, p_0)$ 被迭代更新以找到最终状态 $(x_N, p_N)$。然后根据 $\\|p_N\\|^2$ 计算最终误差。预计结果会显示，对于更高的曲率（更小的 $r$）和更长的路径长度 $L$，误差会更大。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical Hamiltonian error for a retraction-based integrator\n    on a sphere for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, L)\n        (1.0, 0.0),\n        (1.0, 0.1),\n        (0.5, 0.5),\n        (2.0, 1.0),\n        (1.0, np.pi),\n    ]\n\n    N = 200\n    results = []\n\n    for r, L in test_cases:\n        # Initial conditions\n        # Position x0 is on the sphere S^2_r\n        x = np.array([r, 0.0, 0.0], dtype=np.float64)\n        # Momentum p0 is in the tangent space T_x0 S^2_r and has unit norm\n        p = np.array([0.0, 1.0, 0.0], dtype=np.float64)\n\n        # Initial Hamiltonian H(x0, p0)\n        p0_norm_sq = np.dot(p, p)\n        H0 = 0.5 * p0_norm_sq\n\n        # If path length is zero, no steps are taken, so error is zero.\n        if L == 0.0:\n            error = 0.0\n            results.append(error)\n            continue\n        \n        h = L / N\n\n        for _ in range(N):\n            # Compute the unit tangent direction u = p/||p||\n            p_norm = np.linalg.norm(p)\n            # This check prevents division by zero, though unlikely in this problem.\n            if p_norm == 0.0:\n                break\n            u = p / p_norm\n\n            # Construct the tangent vector for the position update\n            v = h * u\n            \n            # Update position using the retraction R_x(v)\n            x_plus_v = x + v\n            x = r * x_plus_v / np.linalg.norm(x_plus_v)\n            \n            # Update momentum using the vector transport T_x(p)\n            # This is an orthogonal projection of the old momentum p onto the new tangent space at x.\n            p = p - (np.dot(p, x) / (r**2)) * x\n            \n        # Final Hamiltonian H(x_N, p_N)\n        pN_norm_sq = np.dot(p, p)\n        H_N = 0.5 * pN_norm_sq\n        \n        # Compute the absolute error\n        error = abs(H_N - H0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}