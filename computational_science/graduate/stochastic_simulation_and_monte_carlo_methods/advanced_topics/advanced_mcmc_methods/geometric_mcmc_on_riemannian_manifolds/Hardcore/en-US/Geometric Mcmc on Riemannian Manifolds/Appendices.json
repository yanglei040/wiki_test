{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any numerical simulation is choosing a stable integration step size, a choice deeply tied to the manifold's geometry in geometric MCMC. This practice  guides you to derive a step size bound from first principles—sectional curvature and injectivity radius—to ensure your integrator remains in a well-behaved region. You will then validate this theoretical bound through numerical simulation, connecting abstract geometric concepts to practical implementation.",
            "id": "3310543",
            "problem": "Consider the task of choosing an integrator step size for geometric Markov chain Monte Carlo (MCMC) based on comparison geometry so that the discrete Hamiltonian dynamics on a Riemannian manifold remain in a normal neighborhood, where the exponential map is a diffeomorphism. Work in the setting of a Riemannian manifold with bounded sectional curvature and known injectivity radius, and specialize to the two-dimensional sphere of radius $R$ embedded in $\\mathbb{R}^3$.\n\nYou are to derive a conservative bound on the leapfrog step size using only core geometric facts, then implement and numerically validate that the bound suffices to keep each position update inside a normal neighborhood. Angles must be measured in radians.\n\nBase definitions and facts:\n- The sectional curvature upper bound is $K_{\\max}$.\n- The injectivity radius is $\\mathrm{inj}(M)$.\n- Along a geodesic with initial speed $v$, the geodesic distance traveled in time $t$ is $v t$.\n- For a manifold with sectional curvature bounded above by $K_{\\max} > 0$, comparison geometry implies the first conjugate point along any geodesic appears no earlier than at distance $\\pi / \\sqrt{K_{\\max}}$.\n- The normal neighborhood about a point is contained in the geodesic ball of radius $\\min\\{\\mathrm{inj}(M), \\pi/\\sqrt{K_{\\max}}\\}$ centered at that point.\n\nSpecialization to the sphere:\n- Consider the $2$-sphere of radius $R$, denoted $\\mathbb{S}^2_R$, with constant sectional curvature $K = 1/R^2$ and injectivity radius $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$.\n- For the geodesic Hamiltonian with zero potential, the continuous-time flow is exactly the geodesic flow; the leapfrog position update of duration $h$ coincides with the exponential map along the current tangent velocity with speed $v$ applied for time $h$.\n- A single leapfrog position update of size $h$ moves the point a geodesic distance $s = v h$ from the current point.\n\nYour tasks:\n1) Starting from the facts above and without appealing to any unintroduced special formulas, derive a conservative inequality for the time step $h$ in terms of $K_{\\max}$, $\\mathrm{inj}(M)$, a bound $v_{\\max}$ such that $v \\le v_{\\max}$ along the trajectory, and a user-chosen safety factor $\\alpha \\in (0,1]$, that guarantees that each single position update of size $h$ remains within the normal neighborhood of the current point.\n\n2) Specialize your bound from Task $1$ to the $2$-sphere $\\mathbb{S}^2_R$, using $K_{\\max} = 1/R^2$ and $\\mathrm{inj}(M) = \\pi R$.\n\n3) Implement a self-contained program that:\n- Uses the bound from Task $2$ to compute a step size $h$ for given $(R, v_{\\max}, \\alpha)$.\n- Simulates $N$ independent trajectories on $\\mathbb{S}^2_R$ with zero potential using exact geodesic updates. For each trajectory:\n  - Sample a random initial point $q_0$ uniformly on $\\mathbb{S}^2_R$ by normalizing a Gaussian vector to radius $R$.\n  - Sample a random initial tangent velocity $u_0$ at $q_0$ by projecting a Gaussian vector to the tangent plane, normalizing to unit norm, and scaling to have norm $v_{\\max}$ so that the worst-case bound is realized at every step.\n  - For $L$ steps, update the state $(q,u)$ by integrating the exact geodesic flow for time $h$ on $\\mathbb{S}^2_R$ and record the per-step geodesic distance traveled $s = v h$.\n  - Verify that each per-step geodesic distance satisfies $s < \\mathrm{inj}(\\mathbb{S}^2_R)$ so that the update is within the normal neighborhood of the current point.\n- Declares a test case successful if all steps of all trajectories satisfy the strict inequality $s < \\mathrm{inj}(\\mathbb{S}^2_R)$, otherwise unsuccessful.\n\nGeodesic update on $\\mathbb{S}^2_R$:\n- If the current position is $q \\in \\mathbb{R}^3$ with $\\lVert q \\rVert = R$ and tangent velocity is $u \\in \\mathbb{R}^3$ with $q^\\top u = 0$ and norm $\\lVert u \\rVert = v$, then the exact geodesic flow for time $h$ is given by rotation through angle $\\theta = (v/R) h$ in the plane spanned by $q$ and $u$:\n  - $q_{\\text{next}} = \\cos(\\theta)\\, q + \\sin(\\theta)\\, R \\, \\frac{u}{v}$,\n  - $u_{\\text{next}} = - \\frac{v}{R} \\sin(\\theta)\\, q + \\cos(\\theta)\\, u$.\n\nTest suite:\nProvide the following test cases. Each test case is a tuple $(R, \\alpha, v_{\\max}, L, N, \\text{seed})$:\n- Case A (happy path): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 0.9, 1.0, 10, 50, 42)$.\n- Case B (boundary condition, expected to fail): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 1.0, 1.0, 1, 10, 0)$.\n- Case C (smaller sphere, higher curvature): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (0.5, 0.9, 2.0, 8, 30, 7)$.\n- Case D (larger sphere, lower curvature): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (3.0, 0.99, 0.5, 20, 60, 123)$.\n- Case E (near-flat large sphere): $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (100.0, 0.5, 5.0, 3, 20, 2024)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above, with each entry being a boolean indicating whether the test passed (true) or failed (false). For example, an output like $[{\\rm True},{\\rm False},\\dots]$.\n\nYour implementation must be entirely self-contained and runnable without user input. Angles must be in radians. No physical units are involved beyond the specification that angles are in radians.",
            "solution": "The problem is valid. It is a well-defined and scientifically sound exercise in the application of Riemannian geometry to the design of numerical integrators for geometric Markov Chain Monte Carlo methods. All necessary definitions, constants, and formulas are provided, and there are no internal contradictions.\n\nThe solution proceeds in three parts as requested: first, a derivation of a general conservative bound on the integrator step size $h$; second, the specialization of this bound to the $2$-sphere $\\mathbb{S}^2_R$; and third, a description of the numerical validation procedure.\n\n### Task $1$: Derivation of a General Step Size Bound\n\nThe primary objective is to choose a leapfrog integrator step size $h$ such that each position update remains within a normal neighborhood of the current point on the Riemannian manifold $M$. A normal neighborhood around a point $q \\in M$ is a region where the exponential map $\\exp_q$ is a diffeomorphism. The problem states that this neighborhood is contained within a geodesic ball of radius $r_{\\text{normal}}$ where:\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\nHere, $\\mathrm{inj}(M)$ is the injectivity radius of the manifold and $K_{\\max} > 0$ is an upper bound on its sectional curvature. The term $\\pi/\\sqrt{K_{\\max}}$ arises from the Rauch comparison theorem, which bounds the distance to the first conjugate point.\n\nFor an integrator step to land strictly inside this neighborhood, the geodesic distance $s$ traveled during the step must satisfy the inequality:\n$$s < r_{\\text{normal}}$$\nA single leapfrog position update of size $h$ with instantaneous speed $v$ traverses a geodesic distance $s = vh$. To ensure the condition is met conservatively, we introduce a safety factor $\\alpha \\in (0, 1]$ and require:\n$$s \\le \\alpha \\cdot r_{\\text{normal}}$$\nSubstituting $s = vh$, we have $vh \\le \\alpha \\cdot r_{\\text{normal}}$.\n\nThe speed $v$ may vary along the trajectory. The problem provides an upper bound $v_{\\max}$ such that $v \\le v_{\\max}$ at all times. To guarantee the condition holds for any step, we must account for the worst-case scenario where the speed is maximal. The condition thus becomes:\n$$v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$$\nSolving this inequality for the step size $h$ provides the desired conservative bound:\n$$h \\le \\frac{\\alpha}{v_{\\max}} \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\nAny step size $h$ satisfying this inequality ensures that the geodesic displacement $s = vh \\le v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$. If $\\alpha < 1$, this guarantees $s < r_{\\text{normal}}$, ensuring the update remains strictly within the normal neighborhood. If $\\alpha=1$, the step might land on the boundary of the neighborhood.\n\n### Task $2$: Specialization to the $2$-Sphere\n\nWe now specialize the derived bound to the case of a $2$-sphere of radius $R$, denoted $\\mathbb{S}^2_R$. The geometric properties for the sphere are provided:\n- Constant sectional curvature $K = 1/R^2$. This implies the upper bound is $K_{\\max} = 1/R^2$.\n- Injectivity radius $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$.\n\nWe compute the radius of the normal neighborhood, $r_{\\text{normal}}$, using these values:\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm.inj}(\\mathbb{S}^2_R), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\} = \\min\\left\\{\\pi R, \\frac{\\pi}{\\sqrt{1/R^2}}\\right\\} = \\min\\{\\pi R, \\pi R\\} = \\pi R$$\nThis result is geometrically intuitive: on a sphere, the injectivity radius (distance to the antipode) is precisely the distance at which conjugate points first appear.\n\nSubstituting $r_{\\text{normal}} = \\pi R$ into the general inequality for $h$ yields the specialized bound for the $2$-sphere:\n$$h \\le \\frac{\\alpha \\pi R}{v_{\\max}}$$\nFor the numerical simulation, we will choose the largest possible step size allowed by this bound to test its limits:\n$$h = \\frac{\\alpha \\pi R}{v_{\\max}}$$\n\n### Task $3$: Numerical Validation and Implementation\n\nThe final task is to implement a program to numerically validate the derived bound. The simulation will use the step size $h$ computed above and verify that each step satisfies the required condition.\n\nFor the given problem, the Hamiltonian has zero potential, which corresponds to geodesic flow. In this case, the kinetic energy, and thus the speed $v$, is conserved. The simulation is set up such that the initial speed is $v_{\\max}$, so the speed remains $v = v_{\\max}$ for the entire trajectory.\n\nThe geodesic distance traveled in each step is therefore constant:\n$$s = vh = v_{\\max} \\cdot \\left(\\frac{\\alpha \\pi R}{v_{\\max}}\\right) = \\alpha \\pi R$$\nThe validation check required by the problem is to confirm that this distance is strictly less than the injectivity radius of the sphere:\n$$s < \\mathrm{inj}(\\mathbb{S}^2_R)$$\nSubstituting the expressions for $s$ and $\\mathrm{inj}(\\mathbb{S}^2_R)$, the condition becomes:\n$$\\alpha \\pi R < \\pi R$$\nThis inequality simplifies to $\\alpha < 1$.\n\nThe simulation is therefore expected to pass a test case if and only if its safety factor $\\alpha$ is strictly less than $1$. When $\\alpha=1$, the step distance $s$ will be equal to the injectivity radius, violating the strict inequality. The provided test cases are designed to confirm this: Case B uses $\\alpha=1$ and is expected to fail, while all other cases use $\\alpha < 1$ and are expected to pass.\n\nThe implementation will follow the specified procedure: for each test case, it calculates $h$, then simulates $N$ trajectories of $L$ steps each. In each step, it calculates the geodesic distance $s$ and checks if $s < \\mathrm{inj}(\\mathbb{S}^2_R)$. If this check ever fails, the test case is marked as unsuccessful. The program will report the success or failure for each test case in the specified format. The geodesic updates are performed using the exact rotation formulas provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a leapfrog step size bound for geometric MCMC on the 2-sphere.\n    \"\"\"\n    test_cases = [\n        # (R, alpha, vmax, L, N, seed)\n        (1.0, 0.9, 1.0, 10, 50, 42),      # Case A: Happy path\n        (1.0, 1.0, 1.0, 1, 10, 0),        # Case B: Boundary condition, should fail\n        (0.5, 0.9, 2.0, 8, 30, 7),        # Case C: Smaller sphere, higher curvature\n        (3.0, 0.99, 0.5, 20, 60, 123),    # Case D: Larger sphere, lower curvature\n        (100.0, 0.5, 5.0, 3, 20, 2024),   # Case E: Near-flat large sphere\n    ]\n\n    results = []\n\n    for R, alpha, vmax, L, N, seed in test_cases:\n        np.random.seed(seed)\n        \n        # Derived step size from Task 2 in the problem description.\n        # This is the largest step size that satisfies the conservative bound.\n        h = (alpha * np.pi * R) / vmax\n        \n        # The injectivity radius for the sphere S^2_R is the radius of the normal neighborhood.\n        inj_radius = np.pi * R\n        \n        test_case_passed = True\n        \n        # The problem requires simulating trajectories to validate the bound.\n        # This simulation implements the procedure described in Task 3.\n        for _ in range(N):\n            # 1. Sample initial position q0 uniformly on the sphere of radius R.\n            z = np.random.randn(3)\n            q = R * z / np.linalg.norm(z)\n            \n            # 2. Sample initial velocity u0 tangent to q0 with norm vmax.\n            # This is done by projecting a random vector onto the tangent plane at q.\n            w = np.random.randn(3)\n            q_unit = q / R # q is guaranteed to be non-zero\n            w_proj = w - np.dot(w, q_unit) * q_unit\n\n            # Handle the unlikely case where w is parallel to q.\n            norm_w_proj = np.linalg.norm(w_proj)\n            if norm_w_proj < 1e-12:\n                # Find an orthogonal vector to q_unit if w is nearly parallel.\n                basis_vec = np.array([1.0, 0.0, 0.0])\n                if np.abs(np.dot(q_unit, basis_vec)) > 0.99:\n                    basis_vec = np.array([0.0, 1.0, 0.0])\n                w_proj = basis_vec - np.dot(basis_vec, q_unit) * q_unit\n                norm_w_proj = np.linalg.norm(w_proj)\n\n            u = vmax * w_proj / norm_w_proj\n\n            # 3. Simulate L steps of the geodesic flow.\n            for _ in range(L):\n                # For geodesic flow (zero potential), velocity magnitude is conserved.\n                v = np.linalg.norm(u)\n                \n                # Geodesic distance traveled in this step.\n                s = v * h\n                \n                # 4. Verify that the step remains strictly within the normal neighborhood.\n                # The radius of the normal neighborhood is the injectivity radius here.\n                if not (s < inj_radius):\n                    test_case_passed = False\n                    break\n                \n                # 5. Update state using the exact geodesic flow on the sphere.\n                theta = (v / R) * h\n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n                \n                q_next = cos_theta * q + sin_theta * R * (u / v)\n                u_next = - (v / R) * sin_theta * q + cos_theta * u\n                \n                q, u = q_next, u_next\n            \n            if not test_case_passed:\n                break\n                \n        results.append(test_case_passed)\n        \n    # Final print statement in the exact required format.\n    # The boolean values are converted to lowercase strings 'true'/'false'.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Exact geodesic flows conserve energy, but their computational cost often leads to the use of approximations like retractions and vector transports. This practice  provides a hands-on analysis of the consequences, asking you to quantify the energy drift introduced by a common approximate integrator on the sphere. By completing this exercise, you will gain a concrete understanding of the numerical dissipation inherent in these methods and how it relates to the manifold's geometry.",
            "id": "3310525",
            "problem": "Consider the unit-speed geodesic Hamiltonian flow on a Riemannian manifold where the position lies on a sphere of radius $r$, denoted $S^2_r \\subset \\mathbb{R}^3$, endowed with the round metric induced by the ambient Euclidean space. The aim is to quantify the empirical energy drift introduced when replacing the true exponential map $\\exp_x$ and parallel transport along geodesics by a retraction $R_x$ and a vector transport $T_x$, respectively, in a geometric Hamiltonian Monte Carlo (HMC) integrator. Work in the zero-potential case, so the Hamiltonian is purely kinetic, i.e., $H(x,p) = \\tfrac{1}{2}\\langle p,p\\rangle$ with $p \\in T_x S^2_r$ and $\\langle\\cdot,\\cdot\\rangle$ the Riemannian metric (here coinciding with the ambient Euclidean inner product restricted to the tangent space). The empirical error will be measured as the absolute deviation in the Hamiltonian after traversing a prescribed geodesic path length $L$ using the retraction-and-transport integrator.\n\nBase the derivation and implementation on the following foundational facts and definitions:\n- A Riemannian manifold $(\\mathcal{M},g)$ admits geodesics that locally minimize distance and satisfy the geodesic equation under the Levi-Civita connection, and the exponential map $\\exp_x: T_x\\mathcal{M}\\to\\mathcal{M}$ advances along geodesics with initial tangent $v\\in T_x\\mathcal{M}$.\n- On $S^2_r$, geodesics are great circles, and parallel transport of tangent vectors along a geodesic preserves inner products and norms.\n- For the round sphere $S^2_r$, the sectional curvature is constant and equal to $K = 1/r^2$, which serves as the curvature norm $\\|R\\|$ in this setting.\n- A retraction $R_x: T_x\\mathcal{M} \\to \\mathcal{M}$ is a smooth local map satisfying $R_x(0_x) = x$ and $\\mathrm{D}R_x(0_x) = \\mathrm{id}_{T_x\\mathcal{M}}$, often used as a computationally simpler surrogate for $\\exp_x$.\n- A vector transport $T_x: T_x\\mathcal{M} \\to T_{R_x(v)}\\mathcal{M}$ is a computational replacement for parallel transport; on embedded submanifolds, the simplest choice projects the ambient vector onto the new tangent space.\n\nProblem requirements:\n- Initialize at a point $x_0 \\in S^2_r$ and a tangent momentum $p_0 \\in T_{x_0}S^2_r$ with unit norm to ensure unit-speed traversal, so that a step of length $h$ corresponds to geodesic arc length $h$.\n- Implement two position update mechanisms conceptually: the true exponential and parallel transport (for analysis), and the approximate retraction $R_x$ with simple projection-based vector transport $T_x$ used for the empirical error measurement. However, the final numerical error to be reported is based only on the retraction-and-transport integrator.\n- Use the following concrete choices to make the scenario fully specified:\n  - Choose $x_0 = (r,0,0) \\in \\mathbb{R}^3$ and $p_0 = (0,1,0) \\in \\mathbb{R}^3$, which is tangent at $x_0$ and has unit norm under the round metric.\n  - Use the retraction $R_x(v) = \\dfrac{r(x+v)}{\\|x+v\\|}$, which normalizes the ambient update back onto $S^2_r$.\n  - Use the vector transport $T_x(w) = w - \\dfrac{\\langle w,x'\\rangle}{r^2}x'$, where $x'$ is the new position after retraction, i.e., simple orthogonal projection of the ambient vector into the new tangent space.\n- Discretize a traversal of total path length $L$ into $N$ equal steps of size $h = L/N$, with $N$ fixed and common across test cases. At each step:\n  - Compute the unit tangent direction $u = p/\\|p\\|$.\n  - Advance position by $x \\leftarrow R_x(h\\,u)$.\n  - Transport the momentum by $p \\leftarrow T_x(p)$.\n- Compute the empirical Hamiltonian error as $|H(x_N,p_N) - H(x_0,p_0)|$ after $N$ steps, where $H(x,p) = \\tfrac{1}{2}\\|p\\|^2$.\n- Report the curvature norm as $\\|R\\| = 1/r^2$. Although $\\|R\\|$ is not directly printed, it is varied through the test suite and should be used in the analysis to interpret the results.\n\nTest suite:\n- Use $N = 200$ steps for all cases, and the following $(r,L)$ pairs, which exercise different curvature and path-length regimes including a boundary condition:\n  1. $(r,L) = (1.0, 0.0)$ with $\\|R\\| = 1.0$ and zero path length (boundary case).\n  2. $(r,L) = (1.0, 0.1)$ with $\\|R\\| = 1.0$ and short path length (small-step regime).\n  3. $(r,L) = (0.5, 0.5)$ with $\\|R\\| = 4.0$ and moderate path length (high-curvature regime).\n  4. $(r,L) = (2.0, 1.0)$ with $\\|R\\| = 0.25$ and moderate path length (low-curvature regime).\n  5. $(r,L) = (1.0, \\pi)$ with $\\|R\\| = 1.0$ and long path length (near half-circumference).\n\nYour program should produce a single line of output containing the empirical Hamiltonian errors for the above test cases, in order, as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3,e_4,e_5]$). No physical units are involved, angles are in radians implicitly by the geometry, and the numbers should be printed as plain decimal floats.",
            "solution": "The problem statement has been rigorously validated and is determined to be a valid, well-posed, and scientifically sound problem in the domain of numerical analysis on Riemannian manifolds. It is free of contradictions, provides all necessary definitions and parameters, and requests the computation of a well-defined quantity—the energy error of a specific numerical integrator.\n\nThe problem investigates the energy conservation properties of a numerical integrator on the $2$-sphere of radius $r$, denoted $S^2_r$. The system is a free particle, described by the kinetic energy Hamiltonian $H(x, p) = \\frac{1}{2} \\langle p, p \\rangle = \\frac{1}{2} \\|p\\|^2$, where $x \\in S^2_r$ is the position and $p \\in T_x S^2_r$ is the momentum. For the true geodesic flow, this Hamiltonian is a conserved quantity. The problem asks to quantify the error, or drift, in this quantity when the true flow is approximated by a numerical scheme based on a retraction and a vector transport.\n\nThe manifold is the sphere $S^2_r = \\{x \\in \\mathbb{R}^3 \\mid \\|x\\|_2 = r\\}$. The tangent space at a point $x$ is $T_x S^2_r = \\{v \\in \\mathbb{R}^3 \\mid \\langle x, v \\rangle = 0\\}$. The Riemannian metric $\\langle \\cdot, \\cdot \\rangle$ is the restriction of the standard Euclidean inner product in $\\mathbb{R}^3$.\n\nThe initial conditions are specified as position $x_0 = (r, 0, 0)$ and momentum $p_0 = (0, 1, 0)$. The vector $p_0$ is tangent to the sphere at $x_0$ since $\\langle x_0, p_0 \\rangle = 0$. The initial momentum has norm $\\|p_0\\| = 1$, which corresponds to a unit-speed traversal. The initial value of the Hamiltonian is $H(x_0, p_0) = \\frac{1}{2} \\|p_0\\|^2 = \\frac{1}{2}(1)^2 = 0.5$.\n\nThe numerical integration scheme simulates the dynamics over a total path length $L$, discretized into $N$ steps of equal size $h = L/N$. The state at step $k \\in \\{0, 1, \\dots, N-1\\}$ is $(x_k, p_k)$. The state is updated to $(x_{k+1}, p_{k+1})$ according to the following algorithm:\n$1$. The step direction is determined by normalizing the current momentum: $u_k = p_k / \\|p_k\\|$.\n$2$. The tangent vector for the position update is $v_k = h u_k$.\n$3$. The position is updated using the specified retraction: $x_{k+1} = R_{x_k}(v_k) = \\frac{r(x_k + v_k)}{\\|x_k + v_k\\|}$.\n$4$. The momentum is updated using the specified vector transport, which projects the ambient vector $p_k$ into the new tangent space $T_{x_{k+1}}S^2_r$: $p_{k+1} = T_{x_k \\to x_{k+1}}(p_k) = p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}$.\n\nThe empirical Hamiltonian error is computed after $N$ steps as the absolute deviation from the initial value: $\\Delta H = |H(x_N, p_N) - H(x_0, p_0)| = \\left| \\frac{1}{2}\\|p_N\\|^2 - 0.5 \\right|$.\n\nA key aspect of this problem is analyzing how a single step affects the Hamiltonian. The change in the Hamiltonian is directly related to the change in the squared norm of the momentum vector. Let's analyze the effect of the vector transport on $\\|p\\|^2$:\n$$ \\|p_{k+1}\\|^2 = \\left\\| p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\right\\|^2 $$\nExpanding the squared norm gives:\n$$ \\|p_{k+1}\\|^2 = \\langle p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}, p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\rangle $$\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}\\|x_{k+1}\\|^2 $$\nSince $x_{k+1} \\in S^2_r$, its norm is $\\|x_{k+1}\\| = r$, so $\\|x_{k+1}\\|^2 = r^2$. Substituting this in, we get:\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}r^2 = \\|p_k\\|^2 - \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} $$\nThis result shows that $\\|p_{k+1}\\|^2 \\le \\|p_k\\|^2$. The equality holds only if $\\langle p_k, x_{k+1} \\rangle = 0$, which means $p_k$ is already in the tangent space at $x_{k+1}$. In general, this is not true. The vector transport, being an orthogonal projection, is not an isometry and systematically reduces the norm of the momentum vector. This leads to a monotonic decrease in the Hamiltonian, and the integrator is dissipative. The magnitude of this effect depends on the geometry (curvature $K=1/r^2$) and the step size $h$.\n\nThe solution is obtained by implementing the described iterative algorithm for each of the $5$ test cases with $N=200$.\n- For the case $(r, L) = (1.0, 0.0)$, the path length $L=0$, so a step size $h=0$. No steps are performed, thus $(x_N, p_N) = (x_0, p_0)$ and the error is $0$.\n- For the other four cases, the simulation is run for $N=200$ steps. The initial state $(x_0, p_0)$ is iteratively updated to find the final state $(x_N, p_N)$. The final error is then calculated from $\\|p_N\\|^2$. The results are expected to show larger errors for higher curvature (smaller $r$) and longer path lengths $L$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical Hamiltonian error for a retraction-based integrator\n    on a sphere for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, L)\n        (1.0, 0.0),\n        (1.0, 0.1),\n        (0.5, 0.5),\n        (2.0, 1.0),\n        (1.0, np.pi),\n    ]\n\n    N = 200\n    results = []\n\n    for r, L in test_cases:\n        # Initial conditions\n        # Position x0 is on the sphere S^2_r\n        x = np.array([r, 0.0, 0.0], dtype=np.float64)\n        # Momentum p0 is in the tangent space T_x0 S^2_r and has unit norm\n        p = np.array([0.0, 1.0, 0.0], dtype=np.float64)\n\n        # Initial Hamiltonian H(x0, p0)\n        p0_norm_sq = np.dot(p, p)\n        H0 = 0.5 * p0_norm_sq\n\n        # If path length is zero, no steps are taken, so error is zero.\n        if L == 0.0:\n            error = 0.0\n            results.append(error)\n            continue\n        \n        h = L / N\n\n        for _ in range(N):\n            # Compute the unit tangent direction u = p/||p||\n            p_norm = np.linalg.norm(p)\n            # This check prevents division by zero, though unlikely in this problem.\n            if p_norm == 0.0:\n                break\n            u = p / p_norm\n\n            # Construct the tangent vector for the position update\n            v = h * u\n            \n            # Update position using the retraction R_x(v)\n            x_plus_v = x + v\n            x = r * x_plus_v / np.linalg.norm(x_plus_v)\n            \n            # Update momentum using the vector transport T_x(p)\n            # This is an orthogonal projection of the old momentum p onto the new tangent space at x.\n            p = p - (np.dot(p, x) / (r**2)) * x\n            \n        # Final Hamiltonian H(x_N, p_N)\n        pN_norm_sq = np.dot(p, p)\n        H_N = 0.5 * pN_norm_sq\n        \n        # Compute the absolute error\n        error = abs(H_N - H0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}