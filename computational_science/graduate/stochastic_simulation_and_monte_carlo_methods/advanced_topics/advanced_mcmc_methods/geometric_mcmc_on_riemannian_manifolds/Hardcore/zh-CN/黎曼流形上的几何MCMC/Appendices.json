{
    "hands_on_practices": [
        {
            "introduction": "第一个实践练习解决了一个在实现任何几何积分器时都会遇到的基本挑战：选择一个稳定的步长。通过应用比较几何的原理，你将推导出一个关于步长 $h$ 的保守界限，以保证数值轨迹停留在流形上一个性质良好的区域，即正规邻域内。这个练习  搭建了一座桥梁，将截面曲率和单射半径等抽象的几何理论与确保模拟在数值上稳定且几何上有效的实际需求联系起来。",
            "id": "3310543",
            "problem": "考虑一个任务：基于比较几何学为几何马尔可夫链蒙特卡洛（MCMC）选择一个积分器步长，以确保黎曼流形上的离散哈密顿动力学保持在法坐标邻域内，在该邻域中指数映射是微分同胚。在具有有界截面曲率和已知单射半径的黎曼流形设定下进行研究，并特化到嵌入在 $\\mathbb{R}^3$ 中半径为 $R$ 的二维球面上。\n\n你需要仅使用核心几何事实推导出一个关于蛙跳（leapfrog）步长的保守界限，然后实现并数值验证该界限足以将每个位置更新保持在法坐标邻域内。角度必须以弧度为单位。\n\n基本定义与事实：\n- 截面曲率上界为 $K_{\\max}$。\n- 单射半径为 $\\mathrm{inj}(M)$。\n- 沿着一条初始速率为 $v$ 的测地线，在时间 $t$ 内行进的测地距离为 $v t$。\n- 对于截面曲率有上界 $K_{\\max} > 0$ 的流形，比较几何学表明，沿任何测地线的第一个共轭点出现的距离不早于 $\\pi / \\sqrt{K_{\\max}}$。\n- 一个点周围的法坐标邻域包含在以该点为中心、半径为 $\\min\\{\\mathrm{inj}(M), \\pi/\\sqrt{K_{\\max}}\\}$ 的测地线球内。\n\n对球面的特化：\n- 考虑半径为 $R$ 的二维球面，记为 $\\mathbb{S}^2_R$，其具有常截面曲率 $K = 1/R^2$ 和单射半径 $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$。\n- 对于零势能的测地哈密顿量，连续时间流即为测地流；持续时间为 $h$ 的蛙跳位置更新，与沿着当前切向速度（速率为 $v$）作用时间 $h$ 的指数映射相吻合。\n- 单个大小为 $h$ 的蛙跳位置更新将点从当前位置移动了测地距离 $s = v h$。\n\n你的任务：\n1) 从上述事实出发，不借助任何未引入的特殊公式，推导出一个关于时间步长 $h$ 的保守不等式。该不等式用 $K_{\\max}$、$\\mathrm{inj}(M)$、轨迹上的速率上界 $v_{\\max}$（满足 $v \\le v_{\\max}$）以及用户选择的安全因子 $\\alpha \\in (0,1]$ 表示，并保证大小为 $h$ 的每个单步位置更新都保持在当前点的法坐标邻域内。\n\n2) 使用 $K_{\\max} = 1/R^2$ 和 $\\mathrm{inj}(M) = \\pi R$，将任务1中得到的界限特化到二维球面 $\\mathbb{S}^2_R$ 上。\n\n3) 实现一个独立的程序，该程序：\n- 使用任务2中的界限，根据给定的 $(R, v_{\\max}, \\alpha)$ 计算步长 $h$。\n- 使用精确的测地线更新，在零势能的 $\\mathbb{S}^2_R$ 上模拟 $N$ 条独立的轨迹。对每条轨迹：\n  - 通过将高斯向量归一化到半径 $R$，在 $\\mathbb{S}^2_R$ 上均匀采样一个随机初始点 $q_0$。\n  - 在 $q_0$ 处采样一个随机初始切向速度 $u_0$，方法是将一个高斯向量投影到切平面上，归一化为单位范数，然后缩放至范数为 $v_{\\max}$，以使最坏情况的界限在每一步都得以实现。\n  - 进行 $L$ 步，通过在 $\\mathbb{S}^2_R$ 上对精确的测地流积分时间 $h$ 来更新状态 $(q,u)$，并记录每步所行进的测地距离 $s = v h$。\n  - 验证每一步的测地距离都满足 $s  \\mathrm{inj}(\\mathbb{S}^2_R)$，从而确保更新保持在当前点的法坐标邻域内。\n- 如果所有轨迹的所有步骤都满足严格不等式 $s  \\mathrm{inj}(\\mathbb{S}^2_R)$，则宣布测试用例成功，否则为不成功。\n\n$\\mathbb{S}^2_R$ 上的测地线更新：\n- 如果当前位置为 $q \\in \\mathbb{R}^3$（满足 $\\lVert q \\rVert = R$），切向速度为 $u \\in \\mathbb{R}^3$（满足 $q^\\top u = 0$ 和范数 $\\lVert u \\rVert = v$），那么时间为 $h$ 的精确测地流由在 $q$ 和 $u$ 张成的平面中旋转角度 $\\theta = (v/R) h$ 给出：\n  - $q_{\\text{next}} = \\cos(\\theta)\\, q + \\sin(\\theta)\\, R \\, \\frac{u}{v}$，\n  - $u_{\\text{next}} = - \\frac{v}{R} \\sin(\\theta)\\, q + \\cos(\\theta)\\, u$。\n\n测试套件：\n提供以下测试用例。每个测试用例是一个元组 $(R, \\alpha, v_{\\max}, L, N, \\text{seed})$：\n- 情况A（正常路径）： $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 0.9, 1.0, 10, 50, 42)$。\n- 情况B（边界条件，预期失败）： $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (1.0, 1.0, 1.0, 1, 10, 0)$。\n- 情况C（较小球面，较高曲率）： $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (0.5, 0.9, 2.0, 8, 30, 7)$。\n- 情况D（较大球面，较低曲率）： $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (3.0, 0.99, 0.5, 20, 60, 123)$。\n- 情况E（近乎平坦的大球面）： $(R, \\alpha, v_{\\max}, L, N, \\text{seed}) = (100.0, 0.5, 5.0, 3, 20, 2024)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试套件顺序排列的结果。每个条目都是一个布尔值，表示测试是通过（true）还是失败（false）。例如，输出格式如 $[{\\rm True},{\\rm False},\\dots]$。\n\n你的实现必须是完全独立的，并且无需用户输入即可运行。角度必须以弧度为单位。除了规定角度以弧度为单位外，不涉及任何物理单位。",
            "solution": "该问题是有效的。它是在将黎曼几何应用于几何马尔可夫链蒙特卡洛方法数值积分器设计方面一个定义明确且科学严谨的练习。所有必要的定义、常数和公式均已提供，且没有内部矛盾。\n\n解答按要求分为三部分进行：首先，推导积分器步长 $h$ 的一个通用保守界限；其次，将此界限特化到二维球面 $\\mathbb{S}^2_R$ 上；第三，描述数值验证过程。\n\n### 任务1：通用步长界限的推导\n\n主要目标是选择一个蛙跳积分器步长 $h$，以使每个位置更新都保持在黎曼流形 $M$ 上当前点的法坐标邻域内。点 $q \\in M$ 周围的法坐标邻域是指数映射 $\\exp_q$ 为微分同胚的一个区域。问题指出，该邻域包含在半径为 $r_{\\text{normal}}$ 的测地线球内，其中：\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\n此处，$\\mathrm{inj}(M)$ 是流形的单射半径，$K_{\\max} > 0$ 是其截面曲率的上界。项 $\\pi/\\sqrt{K_{\\max}}$ 源于 Rauch 比较定理，该定理给出了到第一个共轭点距离的界限。\n\n为使积分步骤严格落在此邻域内部，该步骤中行进的测地距离 $s$ 必须满足不等式：\n$s  r_{\\text{normal}}$\n单个大小为 $h$、瞬时速率为 $v$ 的蛙跳位置更新会行进测地距离 $s = vh$。为保守地确保满足该条件，我们引入一个安全因子 $\\alpha \\in (0, 1]$ 并要求：\n$s \\le \\alpha \\cdot r_{\\text{normal}}$\n代入 $s = vh$，我们得到 $vh \\le \\alpha \\cdot r_{\\text{normal}}$。\n\n速率 $v$ 可能沿轨迹变化。问题提供了一个上界 $v_{\\max}$，使得在任何时候都有 $v \\le v_{\\max}$。为保证该条件对任何步骤都成立，我们必须考虑速率达到最大的最坏情况。因此，条件变为：\n$v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$\n对该不等式求解步长 $h$，可得到所需的保守界限：\n$$h \\le \\frac{\\alpha}{v_{\\max}} \\min\\left\\{\\mathrm{inj}(M), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\}$$\n任何满足此不等式的步长 $h$ 都能确保测地线位移 $s = vh \\le v_{\\max}h \\le \\alpha \\cdot r_{\\text{normal}}$。如果 $\\alpha  1$，则保证 $s  r_{\\text{normal}}$，从而确保更新严格保持在法坐标邻域内。如果 $\\alpha=1$，则步骤可能落在邻域的边界上。\n\n### 任务2：对二维球面的特化\n\n现在我们将推导出的界限特化到半径为 $R$ 的二维球面（记为 $\\mathbb{S}^2_R$）的情况。球面的几何性质已给出：\n- 常截面曲率 $K = 1/R^2$。这意味着上界为 $K_{\\max} = 1/R^2$。\n- 单射半径 $\\mathrm{inj}(\\mathbb{S}^2_R) = \\pi R$。\n\n我们使用这些值计算法坐标邻域的半径 $r_{\\text{normal}}$：\n$$r_{\\text{normal}} = \\min\\left\\{\\mathrm{inj}(\\mathbb{S}^2_R), \\frac{\\pi}{\\sqrt{K_{\\max}}}\\right\\} = \\min\\left\\{\\pi R, \\frac{\\pi}{\\sqrt{1/R^2}}\\right\\} = \\min\\{\\pi R, \\pi R\\} = \\pi R$$\n这个结果在几何上是直观的：在球面上，单射半径（到对跖点的距离）恰好是第一个共轭点出现的距离。\n\n将 $r_{\\text{normal}} = \\pi R$ 代入关于 $h$ 的通用不等式，得到针对二维球面的特化界限：\n$$h \\le \\frac{\\alpha \\pi R}{v_{\\max}}$$\n对于数值模拟，我们将选择此界限允许的最大可能步长来测试其极限：\n$$h = \\frac{\\alpha \\pi R}{v_{\\max}}$$\n\n### 任务3：数值验证与实现\n\n最后的任务是实现一个程序来数值验证所推导的界限。模拟将使用上面计算出的步长 $h$，并验证每一步都满足所需条件。\n\n对于给定的问题，哈密顿量具有零势能，这对应于测地流。在这种情况下，动能以及速率 $v$ 是守恒的。模拟的设置使得初始速率为 $v_{\\max}$，因此在整个轨迹中速率保持为 $v = v_{\\max}$。\n\n因此，每一步行进的测地距离是恒定的：\n$$s = vh = v_{\\max} \\cdot \\left(\\frac{\\alpha \\pi R}{v_{\\max}}\\right) = \\alpha \\pi R$$\n问题所要求的验证检查是确认该距离严格小于球面的单射半径：\n$s  \\mathrm{inj}(\\mathbb{S}^2_R)$\n代入 $s$ 和 $\\mathrm{inj}(\\mathbb{S}^2_R)$ 的表达式，条件变为：\n$\\alpha \\pi R  \\pi R$\n这个不等式简化为 $\\alpha  1$。\n\n因此，当且仅当其安全因子 $\\alpha$ 严格小于 $1$ 时，模拟预期会通过测试用例。当 $\\alpha=1$ 时，步长距离 $s$ 将等于单射半径，违反了严格不等式。所提供的测试用例旨在确认这一点：情况 B 使用 $\\alpha=1$，预期会失败，而所有其他情况使用 $\\alpha  1$，预期会通过。\n\n实现将遵循指定的流程：对于每个测试用例，计算 $h$，然后模拟 $N$ 条各有 $L$ 步的轨迹。在每一步中，计算测地距离 $s$ 并检查是否 $s  \\mathrm{inj}(\\mathbb{S}^2_R)$。如果此检查有任何一次失败，则该测试用例被标记为不成功。程序将以指定格式报告每个测试用例的成功或失败。测地线更新使用所提供的精确旋转公式进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a leapfrog step size bound for geometric MCMC on the 2-sphere.\n    \"\"\"\n    test_cases = [\n        # (R, alpha, vmax, L, N, seed)\n        (1.0, 0.9, 1.0, 10, 50, 42),      # Case A: Happy path\n        (1.0, 1.0, 1.0, 1, 10, 0),        # Case B: Boundary condition, should fail\n        (0.5, 0.9, 2.0, 8, 30, 7),        # Case C: Smaller sphere, higher curvature\n        (3.0, 0.99, 0.5, 20, 60, 123),    # Case D: Larger sphere, lower curvature\n        (100.0, 0.5, 5.0, 3, 20, 2024),   # Case E: Near-flat large sphere\n    ]\n\n    results = []\n\n    for R, alpha, vmax, L, N, seed in test_cases:\n        np.random.seed(seed)\n        \n        # Derived step size from Task 2 in the problem description.\n        # This is the largest step size that satisfies the conservative bound.\n        h = (alpha * np.pi * R) / vmax\n        \n        # The injectivity radius for the sphere S^2_R is the radius of the normal neighborhood.\n        inj_radius = np.pi * R\n        \n        test_case_passed = True\n        \n        # The problem requires simulating trajectories to validate the bound.\n        # This simulation implements the procedure described in Task 3.\n        for _ in range(N):\n            # 1. Sample initial position q0 uniformly on the sphere of radius R.\n            z = np.random.randn(3)\n            q = R * z / np.linalg.norm(z)\n            \n            # 2. Sample initial velocity u0 tangent to q0 with norm vmax.\n            # This is done by projecting a random vector onto the tangent plane at q.\n            w = np.random.randn(3)\n            q_unit = q / R # q is guaranteed to be non-zero\n            w_proj = w - np.dot(w, q_unit) * q_unit\n\n            # Handle the unlikely case where w is parallel to q.\n            norm_w_proj = np.linalg.norm(w_proj)\n            if norm_w_proj  1e-12:\n                # Find an orthogonal vector to q_unit if w is nearly parallel.\n                basis_vec = np.array([1.0, 0.0, 0.0])\n                if np.abs(np.dot(q_unit, basis_vec))  0.99:\n                    basis_vec = np.array([0.0, 1.0, 0.0])\n                w_proj = basis_vec - np.dot(basis_vec, q_unit) * q_unit\n                norm_w_proj = np.linalg.norm(w_proj)\n\n            u = vmax * w_proj / norm_w_proj\n\n            # 3. Simulate L steps of the geodesic flow.\n            for _ in range(L):\n                # For geodesic flow (zero potential), velocity magnitude is conserved.\n                v = np.linalg.norm(u)\n                \n                # Geodesic distance traveled in this step.\n                s = v * h\n                \n                # 4. Verify that the step remains strictly within the normal neighborhood.\n                # The radius of the normal neighborhood is the injectivity radius here.\n                if not (s  inj_radius):\n                    test_case_passed = False\n                    break\n                \n                # 5. Update state using the exact geodesic flow on the sphere.\n                theta = (v / R) * h\n                cos_theta = np.cos(theta)\n                sin_theta = np.sin(theta)\n                \n                q_next = cos_theta * q + sin_theta * R * (u / v)\n                u_next = - (v / R) * sin_theta * q + cos_theta * u\n                \n                q, u = q_next, u_next\n            \n            if not test_case_passed:\n                break\n                \n        results.append(test_case_passed)\n        \n    # Final print statement in the exact required format.\n    # The boolean values are converted to lowercase strings 'true'/'false'.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "尽管精确的测地流能够保持能量守恒，但实际的几何MCMC算法常常依赖于计算成本更低的近似方法，例如回缩（retraction）和向量输运（vector transport）。本练习旨在探究这类近似所带来的后果，要求你在2维球面上测量一个特定积分器的能量漂移。通过实现并分析这个系统 ，你将直观地理解流形曲率和路径长度等因素如何导致数值误差，这对于任何模拟的长期准确性都是一个至关重要的考量。",
            "id": "3310525",
            "problem": "考虑一个黎曼流形上的单位速率测地哈密顿流，其位置位于半径为$r$的球面上，记为$S^2_r \\subset \\mathbb{R}^3$，该球面被赋予了由环境欧几里得空间诱导的圆形度量。目标是量化当在几何哈密顿蒙特卡洛（Hamiltonian Monte Carlo (HMC)）积分器中，分别使用收缩$R_x$和向量输运$T_x$来替代真实的指数映射$\\exp_x$和沿测地线的平行输运时所引入的经验能量漂移。在零势能情况下进行研究，因此哈密顿量纯为动能，即$H(x,p) = \\tfrac{1}{2}\\langle p,p\\rangle$，其中$p \\in T_x S^2_r$，$\\langle\\cdot,\\cdot\\rangle$是黎曼度量（此处与限制在切空间上的环境欧几里得内积一致）。经验误差将通过使用收缩与输运积分器遍历预定测地路径长度$L$后哈密顿量的绝对偏差来衡量。\n\n推导和实现基于以下基本事实和定义：\n- 一个黎曼流形$(\\mathcal{M},g)$拥有局部最小化距离并在Levi-Civita联络下满足测地线方程的测地线，而指数映射$\\exp_x: T_x\\mathcal{M}\\to\\mathcal{M}$则以初始切向量$v\\in T_x\\mathcal{M}$沿测地线前进。\n- 在$S^2_r$上，测地线是大圆，沿测地线对切向量的平行输运保持内积和范数。\n- 对于圆形球面$S^2_r$，其截面曲率是常数，等于$K = 1/r^2$，在此设置中作为曲率范数$\\|R\\|$使用。\n- 收缩$R_x: T_x\\mathcal{M} \\to \\mathcal{M}$是一个光滑的局部映射，满足$R_x(0_x) = x$和$\\mathrm{D}R_x(0_x) = \\mathrm{id}_{T_x\\mathcal{M}}$，通常用作$\\exp_x$的计算上更简单的替代品。\n- 向量输运$T_x: T_x\\mathcal{M} \\to T_{R_x(v)}\\mathcal{M}$是平行输运的计算替代品；在嵌入子流形上，最简单的选择是将环境向量投影到新的切空间上。\n\n问题要求：\n- 在一个点$x_0 \\in S^2_r$和一个切动量$p_0 \\in T_{x_0}S^2_r$处初始化，动量具有单位范数以确保单位速率遍历，从而使得步长为$h$的步对应于测地弧长$h$。\n- 概念上实现两种位置更新机制：真实的指数映射和平行输运（用于分析），以及用于经验误差测量的、带有简单的基于投影的向量输运$T_x$的近似收缩$R_x$。然而，最终要报告的数值误差仅基于收缩与输运积分器。\n- 使用以下具体选择使场景完全明确：\n  - 选择$x_0 = (r,0,0) \\in \\mathbb{R}^3$和$p_0 = (0,1,0) \\in \\mathbb{R}^3$，该向量在$x_0$处相切，并且在圆形度量下具有单位范数。\n  - 使用收缩$R_x(v) = \\dfrac{r(x+v)}{\\|x+v\\|}$，它将环境更新重新归一化到$S^2_r$上。\n  - 使用向量输运$T_x(w) = w - \\dfrac{\\langle w,x'\\rangle}{r^2}x'$，其中$x'$是收缩后的新位置，即简单地将环境向量正交投影到新的切空间中。\n- 将总路径长度为$L$的遍历离散化为$N$个大小为$h = L/N$的相等步长，其中$N$固定且在所有测试用例中通用。在每一步中：\n  - 计算单位切线方向$u = p/\\|p\\|$。\n  - 通过$x \\leftarrow R_x(h\\,u)$推进位置。\n  - 通过$p \\leftarrow T_x(p)$输运动量。\n- 在$N$步之后，计算经验哈密顿误差为$|H(x_N,p_N) - H(x_0,p_0)|$，其中$H(x,p) = \\tfrac{1}{2}\\|p\\|^2$。\n- 将曲率范数报告为$\\|R\\| = 1/r^2$。尽管$\\|R\\|$不会被直接打印，但它会在测试套件中变化，并应用于分析以解释结果。\n\n测试套件：\n- 对所有情况使用$N = 200$步，以及以下$(r,L)$对，这些情况涵盖了不同的曲率和路径长度范围，包括一个边界条件：\n  1. $(r,L) = (1.0, 0.0)$，其中$\\|R\\| = 1.0$，零路径长度（边界情况）。\n  2. $(r,L) = (1.0, 0.1)$，其中$\\|R\\| = 1.0$，短路径长度（小步长范围）。\n  3. $(r,L) = (0.5, 0.5)$，其中$\\|R\\| = 4.0$，中等路径长度（高曲率范围）。\n  4. $(r,L) = (2.0, 1.0)$，其中$\\|R\\| = 0.25$，中等路径长度（低曲率范围）。\n  5. $(r,L) = (1.0, \\pi)$，其中$\\|R\\| = 1.0$，长路径长度（接近半周长）。\n\n你的程序应生成单行输出，其中包含上述测试用例的经验哈密顿误差，按顺序排列，以逗号分隔并用方括号括起来（例如$[e_1,e_2,e_3,e_4,e_5]$）。不涉及物理单位，根据几何结构，角度默认为弧度，数字应打印为普通十进制浮点数。",
            "solution": "问题陈述已经过严格验证，被确定为黎曼流形上数值分析领域中一个有效、适定且科学合理的问题。它没有矛盾，提供了所有必要的定义和参数，并要求计算一个明确定义的量——特定数值积分器的能量误差。\n\n该问题研究了在半径为$r$的2维球面（记为$S^2_r$）上，一个数值积分器的能量守恒性质。该系统是一个自由粒子，由动能哈密顿量$H(x, p) = \\frac{1}{2} \\langle p, p \\rangle = \\frac{1}{2} \\|p\\|^2$描述，其中$x \\in S^2_r$是位置，$p \\in T_x S^2_r$是动量。对于真实的测地流，此哈密顿量是一个守恒量。问题要求量化当真实流被一个基于收缩和向量输运的数值格式近似时，该量的误差或漂移。\n\n流形是球面$S^2_r = \\{x \\in \\mathbb{R}^3 \\mid \\|x\\|_2 = r\\}$。在点$x$处的切空间是$T_x S^2_r = \\{v \\in \\mathbb{R}^3 \\mid \\langle x, v \\rangle = 0\\}$。黎曼度量$\\langle \\cdot, \\cdot \\rangle$是$\\mathbb{R}^3$中标准欧几里得内积的限制。\n\n初始条件指定为位置$x_0 = (r, 0, 0)$和动量$p_0 = (0, 1, 0)$。向量$p_0$在$x_0$处与球面相切，因为$\\langle x_0, p_0 \\rangle = 0$。初始动量的范数为$\\|p_0\\| = 1$，这对应于单位速率遍历。哈密顿量的初始值为$H(x_0, p_0) = \\frac{1}{2} \\|p_0\\|^2 = \\frac{1}{2}(1)^2 = 0.5$。\n\n数值积分格式模拟了总路径长度为$L$的动力学过程，离散为$N$个等大小的步长$h = L/N$。在第$k \\in \\{0, 1, \\dots, N-1\\}$步的状态为$(x_k, p_k)$。状态根据以下算法更新为$(x_{k+1}, p_{k+1})$：\n$1$. 步长方向通过对当前动量归一化来确定：$u_k = p_k / \\|p_k\\|$。\n$2$. 用于位置更新的切向量是$v_k = h u_k$。\n$3$. 使用指定的收缩更新位置：$x_{k+1} = R_{x_k}(v_k) = \\frac{r(x_k + v_k)}{\\|x_k + v_k\\|}$。\n$4$. 使用指定的向量输运更新动量，该输运将环境向量$p_k$投影到新的切空间$T_{x_{k+1}}S^2_r$上：$p_{k+1} = T_{x_k \\to x_{k+1}}(p_k) = p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}$。\n\n在$N$步之后，经验哈密顿误差计算为与初始值的绝对偏差：$\\Delta H = |H(x_N, p_N) - H(x_0, p_0)| = \\left| \\frac{1}{2}\\|p_N\\|^2 - 0.5 \\right|$。\n\n这个问题的关键在于分析单步如何影响哈密顿量。哈密顿量的变化与动量向量范数平方的变化直接相关。让我们分析向量输运对$\\|p\\|^2$的影响：\n$$ \\|p_{k+1}\\|^2 = \\left\\| p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\right\\|^2 $$\n展开范数的平方得到：\n$$ \\|p_{k+1}\\|^2 = \\langle p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1}, p_k - \\frac{\\langle p_k, x_{k+1} \\rangle}{r^2} x_{k+1} \\rangle $$\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}\\|x_{k+1}\\|^2 $$\n因为$x_{k+1} \\in S^2_r$，其范数为$\\|x_{k+1}\\| = r$，所以$\\|x_{k+1}\\|^2 = r^2$。代入此式，我们得到：\n$$ \\|p_{k+1}\\|^2 = \\|p_k\\|^2 - 2\\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} + \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^4}r^2 = \\|p_k\\|^2 - \\frac{\\langle p_k, x_{k+1} \\rangle^2}{r^2} $$\n这个结果表明$\\|p_{k+1}\\|^2 \\le \\|p_k\\|^2$。等式仅在$\\langle p_k, x_{k+1} \\rangle = 0$时成立，这意味着$p_k$已经位于$x_{k+1}$的切空间中。通常情况下，这不成立。向量输运作为一种正交投影，不是等距映射，它会系统性地减小动量向量的范数。这导致哈密顿量的单调递减，并且积分器是耗散的。这种效应的大小取决于几何形状（曲率$K=1/r^2$）和步长$h$。\n\n通过对$5$个测试用例（$N=200$）实施所述的迭代算法来获得解。\n- 对于情况$(r, L) = (1.0, 0.0)$，路径长度$L=0$，因此步长$h=0$。不执行任何步骤，因此$(x_N, p_N) = (x_0, p_0)$且误差为$0$。\n- 对于其他四种情况，模拟运行$N=200$步。初始状态$(x_0, p_0)$被迭代更新以找到最终状态$(x_N, p_N)$。然后根据$\\|p_N\\|^2$计算最终误差。预期结果将显示，对于更高的曲率（更小的$r$）和更长的路径长度$L$，误差会更大。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical Hamiltonian error for a retraction-based integrator\n    on a sphere for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, L)\n        (1.0, 0.0),\n        (1.0, 0.1),\n        (0.5, 0.5),\n        (2.0, 1.0),\n        (1.0, np.pi),\n    ]\n\n    N = 200\n    results = []\n\n    for r, L in test_cases:\n        # Initial conditions\n        # Position x0 is on the sphere S^2_r\n        x = np.array([r, 0.0, 0.0], dtype=np.float64)\n        # Momentum p0 is in the tangent space T_x0 S^2_r and has unit norm\n        p = np.array([0.0, 1.0, 0.0], dtype=np.float64)\n\n        # Initial Hamiltonian H(x0, p0)\n        p0_norm_sq = np.dot(p, p)\n        H0 = 0.5 * p0_norm_sq\n\n        # If path length is zero, no steps are taken, so error is zero.\n        if L == 0.0:\n            error = 0.0\n            results.append(error)\n            continue\n        \n        h = L / N\n\n        for _ in range(N):\n            # Compute the unit tangent direction u = p/||p||\n            p_norm = np.linalg.norm(p)\n            # This check prevents division by zero, though unlikely in this problem.\n            if p_norm == 0.0:\n                break\n            u = p / p_norm\n\n            # Construct the tangent vector for the position update\n            v = h * u\n            \n            # Update position using the retraction R_x(v)\n            x_plus_v = x + v\n            x = r * x_plus_v / np.linalg.norm(x_plus_v)\n            \n            # Update momentum using the vector transport T_x(p)\n            # This is an orthogonal projection of the old momentum p onto the new tangent space at x.\n            p = p - (np.dot(p, x) / (r**2)) * x\n            \n        # Final Hamiltonian H(x_N, p_N)\n        pN_norm_sq = np.dot(p, p)\n        H_N = 0.5 * pN_norm_sq\n        \n        # Compute the absolute error\n        error = abs(H_N - H0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}