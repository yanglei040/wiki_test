{
    "hands_on_practices": [
        {
            "introduction": "从理论到实践的第一步是将连续的边界积分方程转化为可解的离散线性系统。这是一个核心的数值实现问题，其中搭配法 (Collocation) 和伽辽金法 (Galerkin) 是两种最基本且广泛使用的离散化方案。通过这个练习，您将亲手为拉普拉斯方程构建这两种方案下的边界元矩阵，并系统地分析它们的关键数值特性，如对称性和收敛性。这不仅能加深您对边界元方法基本原理的理解，也为解决更复杂的地球物理问题奠定坚实的编程与分析基础。",
            "id": "3616082",
            "problem": "考虑二维拉普拉斯方程及其在光滑闭合曲线上的边界积分表示。设 $\\Gamma$ 是 $\\mathbb{R}^2$ 中一个单连通域的边界，并设 $G(x,y) = -\\frac{1}{2\\pi}\\ln\\|x-y\\|$ 为拉普拉斯算子的基本解。单层边界积分算子 $V$ 作用于标量密度 $\\phi$ 的形式为 $(V\\phi)(x) = \\int_{\\Gamma} G(x,y)\\phi(y)\\,ds_y$。在边界元法（BEM）中，需要对该算子进行离散化。两种常见的方法是配置法和伽辽金法。在配置法中，通过在离散边界点上计算积分来构建系统；而在伽辽金法中，则使用带有测试函数和基函数的变分形式。\n\n您的任务是，在单位圆的多边形近似上，为单层算子 $V$ 在相同网格上构建这两种离散系统，并分析它们在网格细化下的对称性和收敛性。使用定义在直边界段上的分段常数基函数，这些边界段通过 $N$ 个等距点来近似单位圆。角度以弧度处理。\n\n几何和代数设置如下：\n\n- 网格：设 $N$ 是一个正整数（$N \\in \\{8,16,32\\}$）。定义边界节点 $x_k = (\\cos(2\\pi k/N), \\sin(2\\pi k/N))$，其中 $k=0,\\dots,N-1$，以及连接 $x_i$ 和 $x_{i+1}$ 的直边界段 $\\Gamma_i$，索引模 $N$。令 $L_i$ 表示边界段 $\\Gamma_i$ 的长度，并通过 $x_i(t) = x_i + \\hat{u}_i t$ 对 $\\Gamma_i$ 进行参数化，其中 $t \\in [0,L_i]$，$\\hat{u}_i$ 是沿 $\\Gamma_i$ 的单位方向向量。\n\n- 基函数：使用分段常数基函数 $b_j$，其中在 $\\Gamma_j$ 上 $b_j = 1$，在其他地方 $b_j = 0$。\n\n- 伽辽金系统：定义矩阵 $A \\in \\mathbb{R}^{N\\times N}$，其元素为\n$$\nA_{ij} = \\int_{\\Gamma_i}\\int_{\\Gamma_j} G(x,y)\\,ds_x\\,ds_y.\n$$\n对于 $i=j$ 的情况，使用直边界段自作用的精确对角公式，\n$$\nA_{ii} = -\\frac{1}{2\\pi}\\left(L_i^2\\ln L_i - \\frac{3}{2}L_i^2\\right).\n$$\n对于 $i\\neq j$ 的情况，通过张量积高斯-勒让德求积法计算 $A_{ij}$，每个边界段参数使用 $4$ 个点，即在 $[0,L_i]\\times[0,L_j]$ 上使用 $4\\times 4$ 个点。\n\n- 配置系统：选择每个边界段 $\\Gamma_i$ 的中点 $x_i^{\\text{mid}} = x_i + \\hat{u}_i L_i/2$ 作为配置点。定义矩阵 $B \\in \\mathbb{R}^{N\\times N}$，其元素为\n$$\nB_{ij} = \\int_{\\Gamma_j} G(x_i^{\\text{mid}},y)\\,ds_y,\n$$\n使用在 $[0,L_j]$ 上的 $16$ 点高斯-勒让德求积法进行计算。对于 $j=i$ 的情况，积分核在配置点处具有对数奇异性，但它是可积的；请使用指定的求积法，无需进行特殊的奇异处理。\n\n- 对称性分析：计算相对不对称性度量\n$$\n\\sigma_{\\text{gal}} = \\frac{\\|A - A^\\top\\|_F}{\\|A\\|_F}, \\quad \\sigma_{\\text{col}} = \\frac{\\|B - B^\\top\\|_F}{\\|B\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。\n\n- 使用已知密度的收敛性分析：考虑常数密度 $\\phi(y) \\equiv 1$。对于单位圆，单层势的精确边界迹满足 $(V\\phi)(x) = 0$ 对所有 $x\\in\\Gamma$ 成立，因为\n$$\n\\int_0^{2\\pi} \\ln\\left(2\\sin\\frac{\\vartheta}{2}\\right)\\,d\\vartheta = 0\n$$\n并且在圆上 $G(x,y)$ 仅依赖于角度差。对于配置离散化，定义 $v^{\\text{col}} = B\\mathbf{1}$，其中 $\\mathbf{1}\\in\\mathbb{R}^N$ 是全一向量。对于伽辽金离散化，定义 $v^{\\text{gal}} = A\\mathbf{1}$。估计误差\n$$\ne_{\\text{col}}(N) = \\max_{i} |v^{\\text{col}}_i|, \\quad e_{\\text{gal}}(N) = \\max_{i} |v^{\\text{gal}}_i|.\n$$\n使用网格尺寸 $h(N) = \\frac{2\\pi}{N}$ 计算连续细化之间的经验收敛率：\n$$\nr_{\\text{col}}(N_1\\to N_2) = \\frac{\\ln\\left(e_{\\text{col}}(N_1)/e_{\\text{col}}(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)},\\quad\nr_{\\text{gal}}(N_1\\to N_2) = \\frac{\\ln\\left(e_{\\text{gal}}(N_1)/e_{\\text{gal}}(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)}.\n$$\n\n实现要求：\n\n- 数值计算：使用双精度算术。按规定使用高斯-勒让德求积法。角度必须以弧度处理。\n\n- 测试套件：对 $N\\in\\{8,16,32\\}$ 评估指标。对于每个 $N$，计算 $(\\sigma_{\\text{col}}, \\sigma_{\\text{gal}}, e_{\\text{col}}(N), e_{\\text{gal}}(N))$。此外，计算收敛率 $r_{\\text{col}}(8\\to 16)$、$r_{\\text{col}}(16\\to 32)$、$r_{\\text{gal}}(8\\to 16)$ 和 $r_{\\text{gal}}(16\\to 32)$。\n\n- 输出规范：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $12$ 个浮点数：\n$$\n[\\sigma_{\\text{col}}(8),\\sigma_{\\text{gal}}(8),e_{\\text{col}}(8),e_{\\text{gal}}(8),\\sigma_{\\text{col}}(16),\\sigma_{\\text{gal}}(16),e_{\\text{col}}(16),e_{\\text{gal}}(16),\\sigma_{\\text{col}}(32),\\sigma_{\\text{gal}}(32),e_{\\text{col}}(32),e_{\\text{gal}}(32)]\n$$\n随后是 $4$ 个收敛率：\n$$\n[r_{\\text{col}}(8\\to 16),r_{\\text{col}}(16\\to 32),r_{\\text{gal}}(8\\to 16),r_{\\text{gal}}(16\\to 32)],\n$$\n拼接成一个包含 $16$ 个数字的扁平列表。最终输出格式必须严格为\n$$\n[\\text{val}_1,\\text{val}_2,\\dots,\\text{val}_{16}],\n$$\n其中每个 $\\text{val}_k$ 都以标准浮点数格式打印。",
            "solution": "用户在边界元法（BEM）领域提供了一个定义明确的计算问题。任务是为与二维拉普拉斯方程相关的单层势算子实现并分析两种离散化方案：伽辽金法和配置法。分析涉及在一个特定测试案例上评估矩阵对称性和经验收敛率。\n\n### 问题验证\n\n1.  **提取已知条件**：问题陈述指定了以下内容：\n    *   **控制方程**：二维拉普拉斯方程，$\\Delta u = 0$。\n    *   **基本解**：$G(x,y) = -\\frac{1}{2\\pi}\\ln\\|x-y\\|$。\n    *   **单层算子**：$(V\\phi)(x) = \\int_{\\Gamma} G(x,y)\\phi(y)\\,ds_y$。\n    *   **几何形状**：内接于单位圆的正 $N$ 边形，其中 $N \\in \\{8, 16, 32\\}$。\n    *   **基函数**：多边形每条边上的分段常数函数。\n    *   **伽辽金系统**：一个 $N \\times N$ 矩阵 $A$，其元素为 $A_{ij} = \\int_{\\Gamma_i}\\int_{\\Gamma_j} G(x,y)\\,ds_x\\,ds_y$。\n        *   对角元素 $A_{ii}$ 由解析公式 $-\\frac{1}{2\\pi}\\left(L_i^2\\ln L_i - \\frac{3}{2}L_i^2\\right)$ 给出。\n        *   非对角元素 $A_{ij}$ 通过 $4 \\times 4$ 张量积高斯-勒让德求积法计算。\n    *   **配置系统**：一个 $N \\times N$ 矩阵 $B$，其元素为 $B_{ij} = \\int_{\\Gamma_j} G(x_i^{\\text{mid}},y)\\,ds_y$，其中 $x_i^{\\text{mid}}$ 是边界段 $\\Gamma_i$ 的中点。\n        *   元素通过 $16$ 点高斯-勒让德求积法计算，包括奇异情况 $i=j$。\n    *   **分析指标**：\n        *   相对不对称性：$\\sigma = \\frac{\\|M - M^\\top\\|_F}{\\|M\\|_F}$，对于 $M=A, B$。\n        *   误差估计：$e(N) = \\max_i |(M\\mathbf{1})_i|$，针对常数密度 $\\phi=1$ 的测试案例，其中 $\\mathbf{1}$ 是全一向量。\n        *   收敛率：$r(N_1\\to N_2) = \\frac{\\ln\\left(e(N_1)/e(N_2)\\right)}{\\ln\\left(h(N_1)/h(N_2)\\right)}$，网格尺寸为 $h(N) = 2\\pi/N$。\n    *   **输出**：一个包含 $16$ 个浮点数的特定列表，包括计算出的指标和收敛率。\n\n2.  **使用提取的已知条件进行验证**：\n    *   **科学依据**：该问题植根于势理论和数值分析的标准原理，特别是用于椭圆偏微分方程的边界元法。所有定义和公式在该领域都是标准的。\n    *   **适定性**：问题规定得很清楚。几何形状、基函数、求积规则和解析公式为构建矩阵 $A$ 和 $B$ 提供了一套完整且无歧义的指令。分析指标也得到了精确定义。\n    *   **客观性**：问题以客观的数学术语陈述，没有任何主观或带有偏见的语言。\n\n3.  **结论**：该问题是有效的。它是一个适定的、科学上合理的、客观的任务，可以按照描述进行计算求解。\n\n### 求解设计\n\n解决方案将使用 `numpy` 和 `scipy` 库在 Python 中实现。解决方案的核心是一个函数，对于给定的边界元数量 $N$，该函数执行以下步骤：\n\n1.  **几何离散化**：计算内接于单位圆的正 $N$ 边形的顶点。根据这些顶点，确定每个线性边界段 $\\Gamma_i$ 的属性：其起点和终点、长度 $L$、中点 $x_i^{\\text{mid}}$ 及其单位方向向量 $\\hat{u}_i$。\n\n2.  **求积设置**：使用 `scipy.special.roots_legendre` 为 $4$ 点和 $16$ 点预先计算高斯-勒让德求积的节点和权重。这些节点和权重从标准区间 $[-1, 1]$ 缩放到边界段长度区间 $[0, L]$。\n\n3.  **矩阵构建**：组装伽辽金矩阵 $A$ 和配置矩阵 $B$。\n    *   对于**伽辽金矩阵 $A$**：\n        *   对角元素 $A_{ii}$ 使用提供的自作用解析公式计算。\n        *   非对角元素 $A_{ij}$ 通过在边界段 $\\Gamma_i$ 和 $\\Gamma_j$ 上使用 $4 \\times 4$ 张量积高斯-勒让德求积规则进行双重数值积分来计算。这涉及为所有 $16$ 对求积点计算核函数 $G(x,y)$。\n    *   对于**配置矩阵 $B$**：\n        *   每个元素 $B_{ij}$ 通过在边界段 $\\Gamma_j$ 上的单重数值积分计算。核函数 $G(x_i^{\\text{mid}}, y)$ 在 $\\Gamma_j$ 上的 $16$ 个高斯-勒让德求积点处进行求值。严格遵循即使在 $i=j$ 的情况下（此时核函数在积分区间的中点是奇异的）也使用此数值求积的指令。\n\n4.  **对称性与收敛性分析**：\n    *   **对称性**：按照规定使用弗罗贝尼乌斯范数计算相对不对称性度量 $\\sigma_{\\text{gal}}$ 和 $\\sigma_{\\text{col}}$。理论上，对于正多边形这种高度对称的几何形状，两个矩阵都应是对称的（且是循环矩阵），因此任何不对称性都将归因于浮点表示和求积误差。\n    *   **收敛性**：对于常数密度 $\\phi=1$ 的测试案例，计算离散势 $v^{\\text{gal}} = A\\mathbf{1}$ 和 $v^{\\text{col}} = B\\mathbf{1}$。这些向量中元素的最大绝对值分别作为误差估计 $e_{\\text{gal}}(N)$ 和 $e_{\\text{col}}(N)$。\n\n主脚本将对每个所需的 $N$ 值（$N \\in \\{8, 16, 32\\}$）执行此过程，并为每个 $N$ 存储四个指标 $(\\sigma_{\\text{col}}, \\sigma_{\\text{gal}}, e_{\\text{col}}, e_{\\text{gal}})$。随后，根据连续细化得到的误差值计算经验收敛率。最后，将所有 $16$ 个计算值收集到一个列表中，并以指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to solve the BEM problem, including matrix construction,\n    symmetry analysis, and convergence analysis.\n    \"\"\"\n\n    def compute_metrics_for_N(N: int):\n        \"\"\"\n        Constructs BEM matrices and computes analysis metrics for a polygon with N segments.\n        \n        Args:\n            N (int): The number of segments in the polygonal approximation of the unit circle.\n\n        Returns:\n            A tuple containing:\n            - sigma_col (float): Relative asymmetry of the collocation matrix.\n            - sigma_gal (float): Relative asymmetry of the Galerkin matrix.\n            - e_col (float): Error for the collocation method.\n            - e_gal (float): Error for the Galerkin method.\n        \"\"\"\n        # 1. Geometric Setup\n        # Generate nodes for a regular N-gon inscribed in a unit circle.\n        angles = 2.0 * np.pi * np.arange(N, dtype=np.float64) / N\n        nodes = np.array([np.cos(angles), np.sin(angles)]).T\n\n        # For a regular polygon, all segments have the same length.\n        segment_len = np.linalg.norm(nodes[1] - nodes[0])\n        \n        # Define segment properties\n        start_points = nodes\n        end_points = np.roll(nodes, -1, axis=0)\n        midpoints = (start_points + end_points) / 2.0\n        u_vectors = (end_points - start_points) / (segment_len + 1e-30)\n\n        # 2. Quadrature Setup\n        # Galerkin (off-diagonal): 4 points\n        q_nodes_4, q_weights_4 = roots_legendre(4)\n        q_points_gal = segment_len / 2.0 * (q_nodes_4 + 1.0)\n        q_weights_gal = segment_len / 2.0 * q_weights_4\n\n        # Collocation: 16 points\n        q_nodes_16, q_weights_16 = roots_legendre(16)\n        q_points_col = segment_len / 2.0 * (q_nodes_16 + 1.0)\n        q_weights_col = segment_len / 2.0 * q_weights_16\n\n        # 3. Matrix Assembly\n        A = np.zeros((N, N), dtype=np.float64) # Galerkin matrix\n        B = np.zeros((N, N), dtype=np.float64) # Collocation matrix\n\n        for i in range(N):\n            for j in range(N):\n                # Collocation Matrix B entry B_ij\n                quad_pts_on_j_col = start_points[j] + np.outer(q_points_col, u_vectors[j])\n                dists_col = np.linalg.norm(midpoints[i] - quad_pts_on_j_col, axis=1)\n                kernel_vals_col = -1.0 / (2.0 * np.pi) * np.log(dists_col)\n                B[i, j] = np.sum(kernel_vals_col * q_weights_col)\n\n                # Galerkin Matrix A entry A_ij\n                if i == j:\n                    A[i, i] = -1.0 / (2.0 * np.pi) * (segment_len**2 * np.log(segment_len) - 1.5 * segment_len**2)\n                else:\n                    quad_pts_on_i_gal = start_points[i] + np.outer(q_points_gal, u_vectors[i])\n                    quad_pts_on_j_gal = start_points[j] + np.outer(q_points_gal, u_vectors[j])\n                    dists_gal = np.linalg.norm(quad_pts_on_i_gal[:, None, :] - quad_pts_on_j_gal[None, :, :], axis=2)\n                    kernel_vals_gal = -1.0 / (2.0 * np.pi) * np.log(dists_gal)\n                    weights_prod_gal = np.outer(q_weights_gal, q_weights_gal)\n                    A[i, j] = np.sum(kernel_vals_gal * weights_prod_gal)\n        \n        # 4. Analysis\n        norm_A = np.linalg.norm(A, 'fro')\n        norm_B = np.linalg.norm(B, 'fro')\n        sigma_gal = np.linalg.norm(A - A.T, 'fro') / norm_A if norm_A > 0 else 0.0\n        sigma_col = np.linalg.norm(B - B.T, 'fro') / norm_B if norm_B > 0 else 0.0\n        \n        v_gal = A.sum(axis=1) # Corresponds to A @ ones(N)\n        v_col = B.sum(axis=1) # Corresponds to B @ ones(N)\n        \n        e_gal = np.max(np.abs(v_gal))\n        e_col = np.max(np.abs(v_col))\n\n        return sigma_col, sigma_gal, e_col, e_gal\n\n    # Define the test cases from the problem statement.\n    test_cases_N = [8, 16, 32]\n\n    metrics_results = []\n    error_results_for_rates = {}\n\n    for N in test_cases_N:\n        # Main logic to calculate the result for one case goes here.\n        sig_c, sig_g, e_c, e_g = compute_metrics_for_N(N)\n        metrics_results.extend([sig_c, sig_g, e_c, e_g])\n        error_results_for_rates[N] = {'col': e_c, 'gal': e_g}\n\n    # Post-processing to calculate rates\n    log_h_ratio = np.log(2.0)\n    \n    r_col_8_16 = np.log(error_results_for_rates[8]['col'] / error_results_for_rates[16]['col']) / log_h_ratio\n    r_col_16_32 = np.log(error_results_for_rates[16]['col'] / error_results_for_rates[32]['col']) / log_h_ratio\n    \n    r_gal_8_16 = np.log(error_results_for_rates[8]['gal'] / error_results_for_rates[16]['gal']) / log_h_ratio\n    r_gal_16_32 = np.log(error_results_for_rates[16]['gal'] / error_results_for_rates[32]['gal']) / log_h_ratio\n    \n    rate_results = [r_col_8_16, r_col_16_32, r_gal_8_16, r_gal_16_32]\n    \n    final_output = metrics_results + rate_results\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在模拟地壳形变等弹性静力学问题时，边界元法构建的线性系统常常是奇异的。这种奇异性并非数值错误，而是反映了物理现实：物体可以在不产生内力的情况下进行平移或旋转，即所谓的“刚体运动模态”。这个练习将引导您直面这一挑战，通过构建一个代数上完备且物理上一致的合成模型，您将学习如何通过施加拉格朗日乘子约束来消除这些导致解不唯一的刚体运动模态。掌握这一技术对于任何静态或准静态边界元分析都是至关重要的，它也是弗雷德霍姆择一性原理 (Fredholm alternative) 在有限维空间中的一个深刻体现。",
            "id": "3616146",
            "problem": "考虑一个用于线性弹性静力学的二维边界元离散化，该离se化建立在一个具有 $N$ 个边界节点的光滑闭合边界上，并在单位圆上进行参数化。在二维情况下，刚体运动空间是三维的（两个平移和一个平面内旋转）。在离散层面，这表现为边界积分算子的一个非平凡零空间，因此组装后的线性系统会表现出与这些刚体模态相对应的秩亏。对于相关的有限维算子，Fredholm 择一性定理指出，对于一个由紧算子经有限秩算子扰动而产生的线性系统 $A x = b$（在此离散设定中，即为一个具有非平凡零空间的对称半正定矩阵），其可解性要求 $b$ 与 $A^{\\top}$ 的零空间正交。当系统因刚体模态而欠定或存在非唯一解时，可以通过拉格朗日乘子施加辅助约束来消除这些模态并恢复解的唯一性。\n\n您将实现一个完全确定性的、人工合成但物理上一致的代数模型来模拟这种情况。目标是构造一个对称半正定矩阵 $A \\in \\mathbb{R}^{(2N)\\times(2N)}$，其零空间由离散刚体模态张成；通过拉格朗日乘子施加边界约束以消除这些模态；并在完全和有限边界测量的条件下测试可解性。构造过程必须如下：\n\n- 几何与刚体模态：\n  - 令 $N$ 为边界节点数，取 $N = 12$。将节点放置在单位圆上角度为 $\\theta_i = \\frac{2\\pi i}{N}$ ($i = 0,1,\\dots,N-1$) 的位置，其坐标为 $x_i = \\cos(\\theta_i)$ 和 $y_i = \\sin(\\theta_i)$。\n  - 按节点堆叠位移分量，形成 $\\mathbb{R}^{2N}$ 中的向量，排序为 $(u_{x,0},u_{y,0},u_{x,1},u_{y,1},\\dots,u_{x,N-1},u_{y,N-1})^{\\top}$。\n  - 定义三个离散刚体模态向量 $v_1, v_2, v_3 \\in \\mathbb{R}^{2N}$：\n    - $v_1$ 对应于 $x$ 方向的平移：对所有 $i$，有 $u_{x,i} = 1$, $u_{y,i} = 0$。\n    - $v_2$ 对应于 $y$ 方向的平移：对所有 $i$，有 $u_{x,i} = 0$, $u_{y,i} = 1$。\n    - $v_3$ 对应于绕原点的平面内旋转：对所有 $i$，有 $u_{x,i} = -y_i$, $u_{y,i} = x_i$。\n  - 令 $V = [v_1\\ v_2\\ v_3] \\in \\mathbb{R}^{(2N)\\times 3}$。\n\n- 通过拉格朗日乘子施加约束：\n  - 对每个节点使用恒定的边界元权重 $w_i = \\frac{2\\pi}{N}$。构造一个对角权重矩阵 $W \\in \\mathbb{R}^{(2N)\\times(2N)}$，该矩阵为 $u_{x,i}$ 和 $u_{y,i}$ 重复每个 $w_i$。\n  - 定义约束矩阵 $C \\in \\mathbb{R}^{3\\times(2N)}$ 为 $C = V^{\\top} W$。施加 $C x = 0$ 可以消除 $x$ 沿刚体模态的加权平均分量。\n\n- 人工合成的边界积分算子：\n  - 令 $n = 2N$。使用一个固定的伪随机数生成器种子，构造一个随机矩阵 $R \\in \\mathbb{R}^{(n-3)\\times n}$，并将其投影到 $\\operatorname{span}(V)$ 的正交补上得到 $\\widetilde{R} = R (I - P)$，其中 $P = V (V^{\\top} V)^{-1} V^{\\top}$ 是到 $\\operatorname{span}(V)$ 上的欧几里得投影算子，$I$ 是 $\\mathbb{R}^{n\\times n}$ 中的单位矩阵。然后构造\n  $$\n  A = \\widetilde{R}^{\\top} \\widetilde{R} + \\gamma (I - P),\n  $$\n  其中 $\\gamma = 10^{-1}$。根据构造，$A$ 是对称半正定的，且其零空间为 $\\operatorname{Null}(A) = \\operatorname{span}(V)$。\n\n- 右端项与测量：\n  - 通过生成一个随机向量并将其投影到 $C$ 的零空间上以满足 $C x_{\\mathrm{true}} = 0$ 的方式，来生成一个真值位移 $x_{\\mathrm{true}} \\in \\mathbb{R}^{n}$。定义完整的右端项为 $b_{\\mathrm{full}} = A x_{\\mathrm{true}}$。\n  - 考虑选择 $A x = b$ 方程组（行）的一个子集的测量掩码。如果 $S \\subset \\{0,1,\\dots,n-1\\}$ 是被测方程的索引集，定义 $A_S$ 为由 $A$ 中索引在 $S$ 内的行构成的子矩阵，而 $b_S$ 为 $b$ 中对应的项。\n  - 为了施加约束 $C x = 0$，将可行解参数化为 $x = N y$，其中矩阵 $N \\in \\mathbb{R}^{n\\times(n-3)}$ 的列构成了 $\\operatorname{Null}(C)$ 的一个标准正交基。求解约束最小二乘系统\n    $$\n    \\min_{y \\in \\mathbb{R}^{n-3}} \\|A_S N y - b_S\\|_2^2,\n    $$\n    当且仅当 $b_S$ 位于 $A_S N$ 的值域中时，该系统是一致的。\n  - 通过将相对残差 $\\|A_S N \\hat{y} - b_S\\|_2 / \\max(\\|b_S\\|_2, \\varepsilon)$ 与容差 $\\tau$ 进行比较来报告可解性，其中 $\\varepsilon = 10^{-16}$ 是一个安全下限，$\\tau = 10^{-8}$。\n\n您的程序必须使用以下固定参数实现上述构造，以确保可复现性：\n- 边界节点数 $N = 12$。\n- 算子构造的随机种子 $= 2025$。\n- 真值位移的随机种子 $= 7$。\n- 权重参数 $\\gamma = 10^{-1}$。\n- 容差 $\\tau = 10^{-8}$。\n\n定义四个测试案例如下：\n- 测试 $1$（完整，一致）：$S = \\{0,1,\\dots,n-1\\}$ 且 $b = b_{\\mathrm{full}}$。\n- 测试 $2$（完整，不相容）：$S = \\{0,1,\\dots,n-1\\}$ 且 $b = b_{\\mathrm{full}} + \\alpha \\,\\hat{v}_3$，其中 $\\hat{v}_3 = v_3 / \\|v_3\\|_2$ 且 $\\alpha = \\|b_{\\mathrm{full}}\\|_2$。\n- 测试 $3$（有限，一致）：$S = \\{0,2,4,\\dots,n-2\\}$（所有偶数索引）且 $b$ 为 $b_{\\mathrm{full}}$ 限制在 $S$ 上的部分。\n- 测试 $4$（无测量）：$S = \\varnothing$ 且 $b$ 为空，这在约束下是无意义可解的。\n\n对于每个测试，计算一个布尔结果，指示约束最小二乘残差是否低于 $\\tau$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，`[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]`）。不涉及物理单位；所有量均为无量纲。角度以弧度为单位。",
            "solution": "该问题要求实现并分析一个人工合成的代数系统，该系统模拟了线性弹性静力学的二维边界元法 (BEM) 公式。此类系统的一个关键特征是系统矩阵中存在一个非平凡零空间，它对应于刚体运动 (RBMs)。解决方案通过构建一个具有预定义零空间的系统，施加约束以确保唯一解，并在各种测量场景下评估可解性来解决此问题。\n\n边界节点数给定为 $N=12$。节点位于单位圆上的坐标 $(x_i, y_i)$ 处，由 $x_i = \\cos(\\theta_i)$ 和 $y_i = \\sin(\\theta_i)$ 定义，其中角度为 $\\theta_i = \\frac{2\\pi i}{N}$，$i \\in \\{0, 1, \\dots, N-1\\}$。位移向量 $x \\in \\mathbb{R}^{n}$，其中 $n=2N=24$，是通过堆叠每个节点的位移的 $x$ 和 $y$ 分量形成的：$x = (u_{x,0}, u_{y,0}, u_{x,1}, u_{y,1}, \\dots, u_{x,N-1}, u_{y,N-1})^{\\top}$。\n\n在二维弹性静力学中，存在三种刚体模态：两个平移和一个平面内旋转。这些由三个向量 $v_1, v_2, v_3 \\in \\mathbb{R}^{n}$ 表示：\n-   $x$方向平移，$v_1$：每个节点的位移是 $(1, 0)$，因此 $v_1$ 的分量为对所有 $i$ 都有 $u_{x,i}=1$ 和 $u_{y,i}=0$。\n-   $y$方向平移，$v_2$：每个节点的位移是 $(0, 1)$，因此 $v_2$ 的分量为对所有 $i$ 都有 $u_{x,i}=0$ 和 $u_{y,i}=1$。\n-   绕原点旋转，$v_3$：一个点 $(x_i, y_i)$ 绕原点微小旋转角度 $\\phi$ 后，其位置近似变为 $(x_i - \\phi y_i, y_i + \\phi x_i)$。因此，位移向量为 $(-y_i, x_i)$。向量 $v_3$ 的分量为对所有 $i$ 都有 $u_{x,i}=-y_i$ 和 $u_{y,i}=x_i$。\n\n这三个向量被组装成一个矩阵 $V = [v_1, v_2, v_3] \\in \\mathbb{R}^{n \\times 3}$。$V$ 的列空间 $\\operatorname{span}(V)$ 代表了离散化边界所有可能的刚体運動空间。\n\n为了获得弹性静力学问题 $Ax=b$ 的唯一解，必须消除由刚体运动引入的不确定性。这可以通过对解向量 $x$ 施加约束来实现。指定的约束是 $Cx = 0$，其中约束矩阵 $C \\in \\mathbb{R}^{3 \\times n}$ 由 $C = V^{\\top}W$ 给出。这里，$W \\in \\mathbb{R}^{n \\times n}$ 是一个对角求積权重矩阵。对于恒定的边界元权重 $w_i = \\frac{2\\pi}{N}$，$W$ 就是 $\\frac{2\\pi}{N}$ 乘以单位矩阵。条件 $Cx=0$ 强制解 $x$ 沿三种刚体模态的加权平均分量为零，从而有效地“钉住”物体并阻止刚体运动。因此，容许解空间是 $C$ 的零空间 $\\operatorname{Null}(C)$。\n\n问题的核心是构造一个人工合成的系统矩阵 $A \\in \\mathbb{R}^{n \\times n}$，该矩阵是对稱半正定的 (SPSD)，并且其零空间恰好是刚体模态空间，即 $\\operatorname{Null}(A) = \\operatorname{span}(V)$。构造过程如下：\n首先，我们定义到 $\\operatorname{span}(V)$ 上的欧几里得投影算子 $P$：\n$$P = V (V^{\\top} V)^{-1} V^{\\top}$$\n矩阵 $I-P$ 则是到 $\\operatorname{span}(V)$ 的正交补上的投影算子。使用固定的种子生成一个随机矩阵 $R \\in \\mathbb{R}^{(n-3) \\times n}$ 以保证可复现性。该矩阵被投影以使其与刚体运动空间正交：\n$$\\widetilde{R} = R (I - P)$$\n最后，系统矩阵 $A$ 被组装为：\n$$A = \\widetilde{R}^{\\top} \\widetilde{R} + \\gamma (I - P)$$\n给定常数 $\\gamma = 10^{-1}$。让我们验证一下 $A$ 的性质。\n-   对称性：$A^{\\top} = (\\widetilde{R}^{\\top} \\widetilde{R})^{\\top} + \\gamma (I - P)^{\\top} = \\widetilde{R}^{\\top} \\widetilde{R}^{\\top\\top} + \\gamma(I-P) = A$，因为 $P$ 是一个对称投影算子。\n-   半正定性：对任意向量 $z \\in \\mathbb{R}^n$，$z^{\\top}Az = z^{\\top}\\widetilde{R}^{\\top}\\widetilde{R}z + \\gamma z^{\\top}(I-P)z = \\|\\widetilde{R}z\\|_2^2 + \\gamma \\|(I-P)z\\|_2^2 \\ge 0$，因为 $\\gamma > 0$ 且 $I-P$ 也是一个投影算子。\n-   零空间：$Az=0$ 当且仅当上述和中的两项都为零。$\\gamma \\|(I-P)z\\|_2^2 = 0$ 意味着 $(I-P)z=0$，即 $z=Pz$，所以 $z \\in \\operatorname{span}(V)$。如果 $z \\in \\operatorname{span}(V)$，那么 $(I-P)z = 0$，这又意味着 $\\widetilde{R}z = R(I-P)z = 0$。因此，$Az=0$ 当且仅当 $z \\in \\operatorname{span}(V)$。此构造是可靠的。\n\n问题接着要求在约束 $Cx=0$ 下求解系统 $A_S x = b_S$，其中 $S$ 是一个测量行索引的集合。该约束通过将解参数化为 $x=Ny$来处理，其中 $N \\in \\mathbb{R}^{n \\times (n-3)}$ 的列构成了 $\\operatorname{Null}(C)$ 的一个标准正交基。将其代入系统，得到关于系数向量 $y \\in \\mathbb{R}^{n-3}$ 的无约束问题：\n$$ A_S N y = b_S $$\n该系统在最小二乘意义下求解，即最小化 $\\|A_S N y - b_S\\|_2^2$。找到一个 $y$ 的解，记为 $\\hat{y}$。可解性通过检查相对残差是否低于容差 $\\tau = 10^{-8}$ 来确定：\n$$ \\frac{\\|A_S N \\hat{y} - b_S\\|_2}{\\max(\\|b_S\\|_2, \\varepsilon)}  \\tau $$\n其中 $\\varepsilon = 10^{-16}$ 是一个数值下限。\n\n四个测试案例旨在探究该系统的行为：\n1.  **完整，一致**：右端项是 $b_{\\mathrm{full}} = A x_{\\mathrm{true}}$，其中 $x_{\\mathrm{true}}$ 被构造在 $\\operatorname{Null}(C)$ 中。系统 $Ax = b_{\\mathrm{full}}$ 在 $x \\in \\operatorname{Null}(C)$ 的条件下求解。由于 $b_{\\mathrm{full}}$ 在 A 的值域内，并且我们在零空间的正交补中寻找解，因此解应该存在，残差应接近于零。\n2.  **完整，不相容**：将一个来自 $A$ 的零空间的向量 $\\hat{v}_3$ 添加到右端项。得到的向量 $b = b_{\\mathrm{full}} + \\alpha \\hat{v}_3$ 不再处于 $A$ 的值域中（因为 $\\operatorname{Range}(A) = (\\operatorname{Null}(A^{\\top}))^{\\perp} = (\\operatorname{Null}(A))^{\\perp}$）。最小二乘问题的残差将不为零，其大小对应于 $b$ 在 $A^{\\top}$ 零空间上的投影。\n3.  **有限，一致**：系统是欠定的，方程数量（$A$ 的行数）少于未知数数量（$N$ 的列数）。然而，右端项 $b_S$ 是从 $x_{\\mathrm{true}}$ 生成的，这确保了 $b_S = (A x_{\\mathrm{true}})_S = (A N y_{\\mathrm{true}})_S = (A_S N) y_{\\mathrm{true}}$。因此，$b_S$ 位于 $A_S N$ 的值域中，系统是一致的，残差应接近于零。\n4.  **无测量**：一个空的方程组是无意义一致的。残差平凡地为零。\n\n算法的流程是：构造所有矩阵，为每个测试案例生成数据，求解相应的约束最小二乘问题，并评估可解性准则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements the synthetic boundary element method model, constructs the system,\n    and tests solvability for four different cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 12\n    n = 2 * N\n    gamma = 10**-1\n    tau = 10**-8\n    epsilon = 10**-16\n    seed_op = 2025\n    seed_disp = 7\n\n    # 1. Geometry and rigid body modes\n    thetas = np.array([2 * np.pi * i / N for i in range(N)])\n    node_coords = np.array([np.cos(thetas), np.sin(thetas)]).T\n\n    # Construct rigid body mode vectors v1, v2, v3\n    v1 = np.zeros(n)\n    v1[0::2] = 1.0  # x-translation\n\n    v2 = np.zeros(n)\n    v2[1::2] = 1.0  # y-translation\n\n    v3 = np.zeros(n)\n    v3[0::2] = -node_coords[:, 1]  # -y_i for rotation\n    v3[1::2] = node_coords[:, 0]   #  x_i for rotation\n\n    V = np.vstack([v1, v2, v3]).T  # V is (n, 3)\n\n    # 2. Constraints via Lagrange multipliers\n    w_i = (2 * np.pi) / N\n    W = np.diag(np.full(n, w_i))\n    C = V.T @ W  # C is (3, n)\n\n    # 3. Synthetic boundary integral operator\n    # Orthonormal basis for Null(C)\n    N_basis = null_space(C)  # N_basis is (n, n-3)\n\n    # Projector onto span(V)\n    I_n = np.identity(n)\n    P = V @ np.linalg.inv(V.T @ V) @ V.T\n\n    # Generate random matrix R\n    rng_op = np.random.default_rng(seed_op)\n    R = rng_op.standard_normal(size=(n - 3, n))\n\n    # Project R\n    R_tilde = R @ (I_n - P)\n\n    # Construct operator A\n    A = R_tilde.T @ R_tilde + gamma * (I_n - P)\n\n    # 4. Right-hand sides and measurements\n    # Generate ground-truth displacement x_true in Null(C)\n    rng_disp = np.random.default_rng(seed_disp)\n    x_rand = rng_disp.standard_normal(size=n)\n    x_true = N_basis @ (N_basis.T @ x_rand)\n\n    # Generate full right-hand side\n    b_full = A @ x_true\n\n    # Define test cases\n    v3_hat = v3 / np.linalg.norm(v3)\n    alpha = np.linalg.norm(b_full)\n    \n    test_cases_defs = [\n        # Test 1: Full, consistent\n        {'S': np.arange(n), 'b_source': b_full},\n        # Test 2: Full, incompatible\n        {'S': np.arange(n), 'b_source': b_full + alpha * v3_hat},\n        # Test 3: Limited, consistent\n        {'S': np.arange(0, n, 2), 'b_source': b_full},\n        # Test 4: No measurements\n        {'S': np.array([], dtype=int), 'b_source': b_full}\n    ]\n\n    results = []\n    for case in test_cases_defs:\n        S = case['S']\n        b_full_source = case['b_source']\n        \n        # Sub-sample A and b\n        A_S = A[S, :]\n        b_S = b_full_source[S]\n\n        # Form the least-squares system matrix\n        M = A_S @ N_basis\n\n        # Solve the least-squares problem min||My - b_S||^2\n        y_hat, residuals, rank, s = np.linalg.lstsq(M, b_S, rcond=None)\n\n        # Calculate the residual norm from the solution y_hat\n        if M.shape[0] == 0: # Empty system\n            residual_norm = 0.0\n        else:\n            residual_norm = np.linalg.norm(M @ y_hat - b_S)\n\n        b_S_norm = np.linalg.norm(b_S)\n        \n        # Calculate relative residual\n        relative_residual = residual_norm / max(b_S_norm, epsilon)\n        \n        # Check for solvability\n        is_solvable = relative_residual  tau\n        results.append(is_solvable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当应用边界元方法解决地震波散射等波动问题时，经典的积分方程公式会在特定的“伪频率”上失效，导致数值解的崩溃。这是边界元方法在动力学应用中的一个著名陷阱，它可能使整个模拟工作付诸东流。本高级练习将让您正面应对这一难题。您将通过数值实验观察到标准双层位势公式在共振频率附近的失效过程，并亲手实现 Burton–Miller 组合场积分方程——这是一种强大的“疗法”，能够确保在所有频率下获得稳健的解。对于任何致力于将边界元法应用于动力学问题的研究者而言，这都是一项必备的核心技能。",
            "id": "3616147",
            "problem": "考虑光滑闭合边界对平面应变场的二维时谐弹性动力学散射问题。在平面应变中，位移场可以用满足亥姆霍兹方程的标量势来表示，这些标量势分别对应膨胀波（P波/主波）和旋转波（S波/次波）。设压缩波速为 $c_p$，剪切波速为 $c_s$。对于半径为 $a$ 的圆形边界，设角频率为 $\\omega$，并定义波数 $k_p = \\omega / c_p$ 和 $k_s = \\omega / c_s$。二维亥姆霍茲格林函数为 $G_k(\\mathbf{x}, \\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert)$，其中 $H_0^{(1)}$ 是0阶第一类Hankel函数。外部Dirichlet问题的经典纯双层边界积分公式使用算子 $A_D(k) = -\\frac{1}{2} I + D(k)$，其中 $D(k)$ 是双层边界积分算子，其核函数为 $\\partial G_k(\\mathbf{x}, \\mathbf{y}) / \\partial n_y$。众所周知，$A_D(k)$ 在内部共振频率处会丧失唯一性并变得病态，这些频率的特征是 $k a$ 等于内部特征值条件的零点（对于圆形边界，即为非负整数 $n$ 的第一类Bessel函数 $J_n(k a)$ 的零点）。一种广泛使用的修补方法是Burton–Miller组合场积分方程，它构成 $A_{BM}(k, \\eta) = A_D(k) + i \\eta k^{-1} N(k)$，其中 $N(k)$ 是超奇异算子，其核函数为 $\\partial^2 G_k(\\mathbf{x}, \\mathbf{y}) / (\\partial n_x \\partial n_y)$，$\\eta$ 是一个实数耦合参数。目标是通过对 $\\omega$ 进行参数延拓，数值上探究 $A_D(k)$ 的失效模式，并通过对 $\\eta$ 进行扫描来测试Burton–Miller组合场稳定化方法。\n\n从亥姆霍兹方程的边界积分表示法和弹性动力学的解耦标量势的基本原理出发，使用配置边界元法 (BEM) 在单位圆 $\\lVert \\mathbf{x} \\rVert = a$ 上对算子进行离散化，该方法使用 $N_b$ 个均匀分布的边界节点。设每个节点具有相同的求积权重 $w = 2 \\pi a / N_b$ 和单位外法向量 $\\mathbf{n}$。对于双层核，使用\n$$\n\\frac{\\partial G_k(\\mathbf{x}, \\mathbf{y})}{\\partial n_y} = \\nabla_{\\mathbf{y}} G_k(\\mathbf{x}, \\mathbf{y}) \\cdot \\mathbf{n}_y = \\frac{i k}{4} H_1^{(1)}(k r) \\, \\hat{\\mathbf{r}} \\cdot \\mathbf{n}_y,\n$$\n其中 $r = \\lVert \\mathbf{x} - \\mathbf{y} \\rVert$ 且 $\\hat{\\mathbf{r}} = (\\mathbf{x} - \\mathbf{y}) / r$。对于光滑边界上离散双层算子的对角线，包含主值项 $-\\frac{1}{2}$。通过关于观测点法向的中心差分来近似超奇异核：\n$$\n\\frac{\\partial^2 G_k(\\mathbf{x}, \\mathbf{y})}{\\partial n_x \\partial n_y} \\approx \\frac{ \\frac{\\partial G_k(\\mathbf{x} + h \\mathbf{n}_x, \\mathbf{y})}{\\partial n_y} - \\frac{\\partial G_k(\\mathbf{x} - h \\mathbf{n}_x, \\mathbf{y})}{\\partial n_y} }{2 h},\n$$\n其中 $h$ 是沿观测点边界法线的一个微小的法向偏移量（单位：米）。通过将上述核函数乘以求积权重 $w$ 进行配置，组装稠密矩阵 $D(k)$ 和 $N(k)$。对于给定的 $\\omega$，计算 $A_D(k_p)$ 和 $A_D(k_s)$ 的条件数，以及对 $\\eta$进行扫描时组合场 $A_{BM}(k_p, \\eta)$ 和 $A_{BM}(k_s, \\eta)$ 的条件数。将在给定 $\\omega$ 下跨两种模式的最坏情况纯双层条件数定义为\n$$\n\\kappa_D(\\omega) = \\max\\left\\{\\kappa\\left(A_D(k_p)\\right), \\kappa\\left(A_D(k_s)\\right)\\right\\},\n$$\n将在给定 $\\omega$ 和耦合参数 $\\eta$ 下跨两种模式的最坏情况组合场条件数定义为\n$$\n\\kappa_{BM}(\\omega, \\eta) = \\max\\left\\{\\kappa\\left(A_{BM}(k_p, \\eta)\\right), \\kappa\\left(A_{BM}(k_s, \\eta)\\right)\\right\\}.\n$$\n然后，对于频率延拓集 $\\Omega$ 和耦合集 $E$，将频率扫描中最坏情况下的纯双层条件数定义为\n$$\n\\kappa_D^{\\max} = \\max_{\\omega \\in \\Omega} \\kappa_D(\\omega),\n$$\n将在 $\\eta$ 上最优的鲁棒组合场条件数定义为\n$$\n\\kappa_{BM}^{\\star} = \\min_{\\eta \\in E} \\left( \\max_{\\omega \\in \\Omega} \\kappa_{BM}(\\omega, \\eta) \\right).\n$$\n所要求的指标是改善比率\n$$\nR = \\frac{\\kappa_D^{\\max}}{\\kappa_{BM}^{\\star}},\n$$\n该比率为无量纲。\n\n实现一个完整的程序，为每个测试用例构造离散算子，使用 $2$-范数矩阵条件数计算上述条件数指标，并返回每个测试用例的改善比率 $R$。使用以下符合科学实际的参数值和单位：\n\n边界为半径 $a = 1.0$ 米的圆。边界节点数为 $N_b = 64$。用于超奇异有限差分的法向偏移量为 $h = 1.0 \\times 10^{-3}$ 米。使用压缩波速 $c_p = 3000.0$ 米/秒和剪切波速 $c_s = 1500.0$ 米/秒。耦合参数扫描范围为 $E = \\{\\eta \\in \\{0.1, 0.5, 1.0, 2.0\\}\\}$，无单位。条件数使用 $2$-范数计算；如果最小奇异值低于绝对容差 $10^{-12}$，则将条件数视为 $10^{16}$ 以避免数值无穷大。\n\n对 $\\omega$（单位为弧度/秒）的频率延拓使用以下三个测试套件。每个测试套件定义其自己的集合 $\\Omega$：\n\n测试用例1（靠近剪切波内部共振）：$\\Omega = \\{ \\omega = c_s \\times k : k \\in \\{ 2.38, 2.4048255577, 2.43 \\} \\}$。测试用例2（靠近压缩波内部共振）：$\\Omega = \\{ \\omega = c_p \\times k : k \\in \\{ 2.38, 2.4048255577, 2.43 \\} \\}$。测试用例3（非共振）：$\\Omega = \\{ 1000.0, 2000.0 \\}$。\n\n对于每个测试用例，计算如上定义的改善比率 $R$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为测试用例1、测试用例2和测试用例3，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个浮点数。所有物理量必须使用指定的单位：$a$ 以米为单位，$c_p$ 和 $c_s$ 以米/秒为单位，$\\omega$ 以弧度/秒为单位，$h$ 以米为单位。在圆上布置点时所需的角度，必须以弧度为单位。",
            "solution": "用户提供了一个问题陈述，在尝试提供解决方案之前需要对其进行验证。\n\n### 步骤1：提取已知信息\n\n-   **物理系统**：光滑闭合边界对平面应变场的二维时谐弹性动力学散射。\n-   **位移场表示**：用于膨胀波（主波）和旋转波（次波）的标量势，满足亥姆霍兹方程。\n-   **波速**：压缩波速 $c_p$，剪切波速 $c_s$。\n-   **边界几何**：半径为 $a$ 的圆形边界。\n-   **波参数**：角频率 $\\omega$，压缩波数 $k_p = \\omega / c_p$，剪切波数 $k_s = \\omega / c_s$。\n-   **格林函数**：$G_k(\\mathbf{x}, \\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert)$，其中 $H_0^{(1)}$ 是0阶第一类Hankel函数。\n-   **双层算子**：$A_D(k) = -\\frac{1}{2} I + D(k)$，其中 $D(k)$ 是双层边界积分算子。\n-   **双层核**：$\\frac{\\partial G_k(\\mathbf{x}, \\mathbf{y})}{\\partial n_y} = \\nabla_{\\mathbf{y}} G_k(\\mathbf{x}, \\mathbf{y}) \\cdot \\mathbf{n}_y = \\frac{i k}{4} H_1^{(1)}(k r) \\, \\hat{\\mathbf{r}} \\cdot \\mathbf{n}_y$，其中 $r = \\lVert \\mathbf{x} - \\mathbf{y} \\rVert$ 且 $\\hat{\\mathbf{r}} = (\\mathbf{x} - \\mathbf{y}) / r$。\n-   **组合场算子**：$A_{BM}(k, \\eta) = A_D(k) + i \\eta k^{-1} N(k)$。\n-   **超奇异算子**：$N(k)$ 是超奇异算子，其核函数为 $\\frac{\\partial^2 G_k(\\mathbf{x}, \\mathbf{y})}{\\partial n_x \\partial n_y}$。\n-   **超奇异核近似**：$\\frac{\\partial^2 G_k(\\mathbf{x}, \\mathbf{y})}{\\partial n_x \\partial n_y} \\approx \\frac{ \\frac{\\partial G_k(\\mathbf{x} + h \\mathbf{n}_x, \\mathbf{y})}{\\partial n_y} - \\frac{\\partial G_k(\\mathbf{x} - h \\mathbf{n}_x, \\mathbf{y})}{\\partial n_y} }{2 h}$。\n-   **数值离散化**：使用 $N_b$ 个均匀分布的边界节点的配置边界元法 (BEM)。\n-   **求积权重**：$w = 2 \\pi a / N_b$。\n-   **条件数指标**：\n    -   $\\kappa_D(\\omega) = \\max\\left\\{\\kappa\\left(A_D(k_p)\\right), \\kappa\\left(A_D(k_s)\\right)\\right\\}$\n    -   $\\kappa_{BM}(\\omega, \\eta) = \\max\\left\\{\\kappa\\left(A_{BM}(k_p, \\eta)\\right), \\kappa\\left(A_{BM}(k_s, \\eta)\\right)\\right\\}$\n    -   $\\kappa_D^{\\max} = \\max_{\\omega \\in \\Omega} \\kappa_D(\\omega)$\n    -   $\\kappa_{BM}^{\\star} = \\min_{\\eta \\in E} \\left( \\max_{\\omega \\in \\Omega} \\kappa_{BM}(\\omega, \\eta) \\right)$\n-   **目标指标**：改善比率 $R = \\kappa_D^{\\max} / \\kappa_{BM}^{\\star}$。\n-   **数值参数**：\n    -   $a = 1.0$ 米\n    -   $N_b = 64$\n    -   $h = 1.0 \\times 10^{-3}$ 米\n    -   $c_p = 3000.0$ 米/秒\n    -   $c_s = 1500.0$ 米/秒\n    -   $E = \\{0.1, 0.5, 1.0, 2.0\\}$\n    -   条件数为 $2$-范数条件数。如果最小奇异值小于 $10^{-12}$，则条件数取为 $10^{16}$。\n-   **测试用例（频率集 $\\Omega$）**：\n    1.  $\\Omega = \\{ \\omega = c_s \\times k : k \\in \\{ 2.38, 2.4048255577, 2.43 \\} \\}$\n    2.  $\\Omega = \\{ \\omega = c_p \\times k : k \\in \\{ 2.38, 2.4048255577, 2.43 \\} \\}$\n    3.  $\\Omega = \\{ 1000.0, 2000.0 \\}$ 弧度/秒\n\n### 步骤2：使用提取的已知信息进行验证\n\n1.  **科学依据**：该问题在波传播、弹性动力学和计算力学理论方面有坚实的基础。使用P波和S波的亥姆霍兹方程、二维格林函数（Hankel函数）以及边界积分方程（BIEs）都是标准做法。外部问题的BIEs中的伪频率（内部共振）问题是一个经典的挑战，而Burton-Miller组合场公式是一种成熟且理论上可靠的修正方法。数值方法（配置BEM）和超奇异算子的有限差分近似是标准的数值技术。所有参数对于地球物理应用都是物理上现实的。\n2.  **适定的**：该问题是一个数值实验，具有明确定义的目标：计算改善比率 $R$。所有必要的参数、方程和数值程序都已指定。在接近奇异的情况下为条件数设置上限的指令确保了数值稳定性和一个定义明确的计算任务。\n3.  **客观性**：问题陈述使用精确、客观和技术的语言。它不含主观或基于意见的断言。\n4.  **完整且一致**：问题陈述是自洽的。它提供了唯一解所需的所有数据（$a, N_b, h, c_p, c_s$）、参数集（$E, \\Omega$）、数学公式（算子、核函数）和数值规则（求积、条件数处理）。物理单位是一致的（国际单位制单位）。数学定义，如格林函数导数的形式，是正确的。\n5.  **无其他缺陷**：该问题不是比喻性的、琐碎的或不可验证的。它代表了计算科学中的一项标准验证研究。测试用例经过精心设计，旨在探测双层公式在内部共振附近的已知失效模式，该共振对应Bessel函数 $J_0(ka) \\approx J_0(2.4048)$ 的一个零点。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。它科学上合理、适定、完整且一致。我将继续提供解决方案。\n\n### 基于原则的解决方案设计\n\n该解决方案涉及边界元法（BEM）的数值实现，以量化纯双层积分方程在特定频率下的已知病态问题，以及通过Burton-Miller组合场公式实现的稳定性。核心步骤如下：\n\n1.  **几何离散化**：将半径为 $a=1.0$ 米的圆形边界 $\\Gamma$ 离散为 $N_b=64$ 个节点。第 $j$ 个节点的位置向量为 $\\mathbf{x}_j = a(\\cos \\theta_j, \\sin \\theta_j)$，其中 $\\theta_j = 2\\pi j / N_b$，对于 $j = 0, 1, \\dots, N_b-1$。在 $\\mathbf{x}_j$ 处的单位外法向量为 $\\mathbf{n}_j = (\\cos \\theta_j, \\sin \\theta_j)$。使用一个简单的求积法则，其中每个节点都有一个权重 $w = 2\\pi a / N_b$。\n\n2.  **算子离散化**：通过配置法将连续积分算子近似为 $N_b \\times N_b$ 的矩阵。矩阵 $M$ 的一个元素 $(M)_{ij}$ 表示位于节点 $\\mathbf{y}_j = \\mathbf{x}_j$ 的源对观测（配置）点 $\\mathbf{x}_i$ 处场的影响。\n\n3.  **双层算子矩阵 ($D(k)$)**：对于给定的波数 $k$，组装矩阵 $D(k)$。其元素 $D_{ij}(k)$ 由核函数乘以求积权重配置而成。\n    对于非对角线元素（$i \\neq j$），其中 $\\mathbf{x}_i \\neq \\mathbf{y}_j$：\n    $$\n    D_{ij}(k) = w \\cdot \\frac{\\partial G_k(\\mathbf{x}_i, \\mathbf{y}_j)}{\\partial n_y} = w \\left( \\frac{ik}{4} H_1^{(1)}(k r_{ij}) \\frac{\\mathbf{x}_i - \\mathbf{y}_j}{r_{ij}} \\cdot \\mathbf{n}_j \\right)\n    $$\n    其中 $r_{ij} = \\lVert\\mathbf{x}_i - \\mathbf{y}_j\\rVert$。\n    对于对角线元素（$i = j$），对于光滑二维边界，双层核的极限为零。因此，$D_{ii}(k) = 0$。\n\n4.  **超奇异算子矩阵 ($N(k)$)**：使用提供的有限差分近似组装矩阵 $N(k)$。对于每个元素 $N_{ij}(k)$：\n    $$\n    N_{ij}(k) = w \\cdot \\frac{ \\frac{\\partial G_k(\\mathbf{x}_i + h \\mathbf{n}_i, \\mathbf{y}_j)}{\\partial n_y} - \\frac{\\partial G_k(\\mathbf{x}_i - h \\mathbf{n}_i, \\mathbf{y}_j)}{\\partial n_y} }{2h}\n    $$\n    此处，双层核函数在沿法线 $\\mathbf{n}_i$ 方向扰动一个微小距离 $h$ 的观测点处进行求值。这避免了在 $\\mathbf{x}_i = \\mathbf{y}_j$ 处直接计算强奇异核。\n\n5.  **系统矩阵构建与条件数分析**：\n    对于给定集合 $\\Omega$ 中的每个角频率 $\\omega$，我们计算波数 $k_p = \\omega/c_p$ 和 $k_s = \\omega/c_s$。\n    -   组装矩阵 $D(k_p)$、 $N(k_p)$、 $D(k_s)$ 和 $N(k_s)$。\n    -   形成纯双层公式的矩阵：\n        $$\n        A_D(k_p) = D(k_p) - \\frac{1}{2}I, \\quad A_D(k_s) = D(k_s) - \\frac{1}{2}I\n        $$\n        其中 $I$ 是 $N_b \\times N_b$ 的单位矩阵。\n    -   对于每个耦合参数 $\\eta \\in E$，形成Burton-Miller组合场公式的矩阵：\n        $$\n        A_{BM}(k_p, \\eta) = A_D(k_p) + i\\eta k_p^{-1} N(k_p)\n        $$\n        $$\n        A_{BM}(k_s, \\eta) = A_D(k_s) + i\\eta k_s^{-1} N(k_s)\n        $$\n    -   计算每个矩阵的 $2$-范数条件数 $\\kappa$。这是通过找到矩阵的奇异值 $\\sigma$ 并计算 $\\kappa = \\sigma_{\\max}/\\sigma_{\\min}$ 来完成的。如果 $\\sigma_{\\min}  10^{-12}$，则将 $\\kappa$ 设为 $10^{16}$。\n\n6.  **指标计算**：根据指定的公式汇总条件数，计算最终的改善比率 $R$。\n    -   首先，找出每种公式在每个频率下的最坏情况条件数：$\\kappa_D(\\omega)$ 和 $\\kappa_{BM}(\\omega, \\eta)$。\n    -   然后，找出在整个频率扫描中纯双层公式的最大条件数：$\\kappa_D^{\\max} = \\max_{\\omega \\in \\Omega} \\kappa_D(\\omega)$。\n    -   对于每个 $\\eta$，找出在整个频率扫描中组合场公式的最大条件数：$\\max_{\\omega \\in \\Omega} \\kappa_{BM}(\\omega, \\eta)$。\n    -   选择组合场方法中这些最坏情况结果中的最佳者：$\\kappa_{BM}^{\\star} = \\min_{\\eta \\in E} (\\max_{\\omega \\in \\Omega} \\kappa_{BM}(\\omega, \\eta))$。\n    -   最后，计算比率：$R = \\kappa_D^{\\max} / \\kappa_{BM}^{\\star}$。\n\n对定义不同频率集 $\\Omega$ 的三个测试用例中的每一个，重复此完整过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, linalg\n\ndef solve():\n    \"\"\"\n    Solves the BEM conditioning problem for the given test cases.\n    \"\"\"\n\n    # --------------------------------------------------------------------------\n    # Helper Functions\n    # --------------------------------------------------------------------------\n\n    def custom_cond(matrix, tol, cap):\n        \"\"\"\n        Computes the 2-norm condition number of a matrix with a tolerance\n        for the smallest singular value.\n        \"\"\"\n        try:\n            s_vals = linalg.svdvals(matrix)\n            # s_vals are sorted in descending order\n            if s_vals[-1]  tol:\n                return cap\n            # Handle zero matrix case\n            if s_vals[0]  1e-16: # Practically zero\n                return 1.0\n            return s_vals[0] / s_vals[-1]\n        except linalg.LinAlgError:\n            # SVD fails to converge, indicates extreme ill-conditioning\n            return cap\n\n    def eval_double_layer_kernel(x_obs, y_src, n_src, k):\n        \"\"\"\n        Evaluates the 2D time-harmonic double-layer kernel.\n        kernel = (i*k/4) * H_1^(1)(k*r) * r_hat . n_src\n        \"\"\"\n        r_vec = x_obs - y_src\n        r = np.linalg.norm(r_vec)\n        \n        # Kernel is zero for zero separation on a smooth boundary\n        if r  1e-15:\n            return 0.0 + 0.0j\n\n        r_hat = r_vec / r\n        dot_product = np.dot(r_hat, n_src)\n        \n        z = k * r\n        h1_val = special.hankel1(1, z)\n        \n        return (1j * k / 4.0) * h1_val * dot_product\n\n    def compute_ratio_for_case(Omega, Etas, a, Nb, h, cp, cs, cond_tol, cond_cap):\n        \"\"\"\n        Computes the improvement ratio R for a single test case (frequency set Omega).\n        \"\"\"\n        # 1. Setup Geometry\n        thetas = np.linspace(0, 2 * np.pi, Nb, endpoint=False)\n        nodes = a * np.array([np.cos(thetas), np.sin(thetas)]).T\n        normals = np.array([np.cos(thetas), np.sin(thetas)]).T\n        w = 2 * np.pi * a / Nb\n\n        kappas_D_omega = []\n        kappas_BM_omega_eta = {eta: [] for eta in Etas}\n\n        # 2. Loop over frequencies in the test case\n        for omega in Omega:\n            kp = omega / cp\n            ks = omega / cs\n            \n            # Assemble matrices for both P-waves and S-waves\n            Dp = np.zeros((Nb, Nb), dtype=complex)\n            Np = np.zeros((Nb, Nb), dtype=complex)\n            Ds = np.zeros((Nb, Nb), dtype=complex)\n            Ns = np.zeros((Nb, Nb), dtype=complex)\n\n            for k_val, D_mat, N_mat in [(kp, Dp, Np), (ks, Ds, Ns)]:\n                # Loop over observation points (rows)\n                for i in range(Nb):\n                    xi = nodes[i]\n                    ni = normals[i]\n                    \n                    # Loop over source points (columns)\n                    for j in range(Nb):\n                        yj = nodes[j]\n                        nj = normals[j]\n                        \n                        # Double-layer operator entry D_ij\n                        if i != j:\n                            D_mat[i, j] = w * eval_double_layer_kernel(xi, yj, nj, k_val)\n                        \n                        # Hypersingular operator entry N_ij (via finite difference)\n                        xi_plus = xi + h * ni\n                        xi_minus = xi - h * ni\n                        \n                        term_plus = eval_double_layer_kernel(xi_plus, yj, nj, k_val)\n                        term_minus = eval_double_layer_kernel(xi_minus, yj, nj, k_val)\n                        \n                        N_mat[i, j] = w * (term_plus - term_minus) / (2.0 * h)\n\n            # 3. Compute condition numbers for this frequency\n            Id = np.eye(Nb)\n            ADp = Dp - 0.5 * Id\n            ADs = Ds - 0.5 * Id\n\n            kappa_ADp = custom_cond(ADp, cond_tol, cond_cap)\n            kappa_ADs = custom_cond(ADs, cond_tol, cond_cap)\n            kappas_D_omega.append(max(kappa_ADp, kappa_ADs))\n\n            for eta in Etas:\n                # Burton-Miller formulation\n                ABM_p = ADp + (1j * eta / kp) * Np\n                ABM_s = ADs + (1j * eta / ks) * Ns\n                \n                kappa_ABM_p = custom_cond(ABM_p, cond_tol, cond_cap)\n                kappa_ABM_s = custom_cond(ABM_s, cond_tol, cond_cap)\n                kappas_BM_omega_eta[eta].append(max(kappa_ABM_p, kappa_ABM_s))\n\n        # 4. Aggregate results to find the final ratio R\n        kappa_D_max = max(kappas_D_omega)\n        \n        max_kappas_BM_per_eta = [max(kappas_BM_omega_eta[eta]) for eta in Etas]\n        kappa_BM_star = min(max_kappas_BM_per_eta)\n        \n        # Avoid division by zero if all methods perform perfectly (unlikely)\n        if kappa_BM_star  1e-16:\n             return 1.0\n\n        return kappa_D_max / kappa_BM_star\n\n    # --------------------------------------------------------------------------\n    # Main Execution\n    # --------------------------------------------------------------------------\n    \n    # Global Parameters\n    A = 1.0        # Radius in meters\n    NB = 64        # Number of boundary nodes\n    H = 1.0e-3     # Finite difference offset in meters\n    CP = 3000.0    # Compressional wave speed in m/s\n    CS = 1500.0    # Shear wave speed in m/s\n    ETAS = [0.1, 0.5, 1.0, 2.0] # Coupling parameters\n    COND_TOL = 1.0e-12\n    COND_CAP = 1.0e16\n    \n    # Test Suites\n    J0_ZERO1 = 2.4048255577\n    test_cases = [\n        {\"Omega\": [CS * k for k in [2.38, J0_ZERO1, 2.43]]},\n        {\"Omega\": [CP * k for k in [2.38, J0_ZERO1, 2.43]]},\n        {\"Omega\": [1000.0, 2000.0]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        ratio = compute_ratio_for_case(\n            case[\"Omega\"], ETAS, A, NB, H, CP, CS, COND_TOL, COND_CAP\n        )\n        results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}