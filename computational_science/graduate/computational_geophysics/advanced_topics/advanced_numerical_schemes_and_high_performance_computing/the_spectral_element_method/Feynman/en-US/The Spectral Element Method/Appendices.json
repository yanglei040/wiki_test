{
    "hands_on_practices": [
        {
            "introduction": "The accuracy of the Spectral Element Method is rooted in its use of high-order polynomial interpolation on strategically chosen nodes. This practice solidifies your understanding of this core mechanism by tasking you with evaluating a Lagrange interpolant on a reference element using Gauss-Lobatto-Legendre (GLL) points. You will also explore how small errors in nodal data can propagate, a crucial concept for assessing the stability and robustness of numerical simulations .",
            "id": "3381169",
            "problem": "In a one-dimensional spectral element discretization of a scalar field over the reference interval $[-1,1]$, consider polynomial interpolation of degree $N=4$ using the Gauss–Lobatto–Legendre (GLL) points. The GLL nodes for $N=4$ are the endpoints together with the roots of the derivative of the degree-$4$ Legendre polynomial, namely\n$$x_{0}=-1,\\quad x_{1}=-\\sqrt{\\frac{3}{7}},\\quad x_{2}=0,\\quad x_{3}=\\sqrt{\\frac{3}{7}},\\quad x_{4}=1.$$\nSuppose the nodal data (e.g., pointwise values of a conservative variable) at these nodes are\n$$u_{0}=\\frac{13}{10},\\quad u_{1}=u_{3}=\\frac{93}{98},\\quad u_{2}=\\frac{3}{5},\\quad u_{4}=\\frac{13}{10}.$$\nUsing the Lagrange interpolant built on these GLL nodes, evaluate the interpolant at the point $x=0.3$. Assume the nodal data used in the computation may be perturbed by measurement and round-off errors of absolute magnitude at most $\\varepsilon=2.0\\times 10^{-4}$. Using the degree-$4$ Lebesgue constant (the supremum over $[-1,1]$ of the Lebesgue function $\\Lambda_{4}(x)=\\sum_{i=0}^{4}|\\ell_{i}(x)|$ built from these GLL nodes), provide an upper bound for the induced interpolation error at $x=0.3$ expressed in terms of $\\Lambda_{4}$. Round the interpolant value to six significant figures. No physical units are involved in this computation.",
            "solution": "The spectral element method on the reference interval $[-1,1]$ employs polynomial interpolation at specially chosen nodes to achieve high-order accuracy. For Gauss–Lobatto–Legendre (GLL) nodes of degree $N=4$, the nodes are $x_{0}=-1$, $x_{1}=-\\sqrt{\\frac{3}{7}}$, $x_{2}=0$, $x_{3}=\\sqrt{\\frac{3}{7}}$, and $x_{4}=1$. The degree-$4$ Lagrange interpolant of data $\\{u_{i}\\}_{i=0}^{4}$ at a point $x$ is\n$$I_{4}[u](x)=\\sum_{i=0}^{4}u_{i}\\,\\ell_{i}(x),$$\nwhere the cardinal (Lagrange) basis functions are defined by\n$$\\ell_{i}(x)=\\prod_{\\substack{j=0\\\\ j\\neq i}}^{4}\\frac{x-x_{j}}{x_{i}-x_{j}}.$$\n\nWe first evaluate $I_{4}[u](x)$ at $x=0.3$. Denote $a=\\sqrt{\\frac{3}{7}}$ so that $a^{2}=\\frac{3}{7}$ and $a^{4}=\\frac{9}{49}$. The nodes are $x_{0}=-1$, $x_{1}=-a$, $x_{2}=0$, $x_{3}=a$, $x_{4}=1$, and the nodal values are $u_{0}=\\frac{13}{10}$, $u_{1}=u_{3}=\\frac{93}{98}$, $u_{2}=\\frac{3}{5}$, $u_{4}=\\frac{13}{10}$.\n\nWe compute each $\\ell_{i}(0.3)$.\n\n1. For $i=2$ (the zero node), the denominator simplifies exactly:\n$$D_{2}=\\prod_{\\substack{j=0\\\\ j\\neq 2}}^{4}(x_{2}-x_{j})=(0-(-1))(0-(-a))(0-a)(0-1)=a^{2}=\\frac{3}{7}.$$\nThe numerator at $x=0.3$ is\n$$N_{2}=(0.3-(-1))(0.3-(-a))(0.3-a)(0.3-1)=1.3\\cdot(0.3+a)\\cdot(0.3-a)\\cdot(-0.7).$$\nWith $a\\approx 0.6546536707$, this evaluates to $N_{2}\\approx 0.3081000062$. Therefore,\n$$\\ell_{2}(0.3)=\\frac{N_{2}}{D_{2}}\\approx \\frac{0.3081000062}{3/7}\\approx 0.7189000145.$$\n\n2. For $i=0$ (the left endpoint),\n$$D_{0}=\\prod_{j=1}^{4}(x_{0}-x_{j})=(-1-(-a))(-1-0)(-1-a)(-1-1)=2(1-a^{2})=\\frac{8}{7},$$\nusing $(1-a)(1+a)=1-a^{2}$. The numerator at $x=0.3$ is\n$$N_{0}=(0.3-(-a))(0.3-0)(0.3-a)(0.3-1),$$\nwhich numerically gives $N_{0}\\approx 0.0711000000$. Hence\n$$\\ell_{0}(0.3)=\\frac{N_{0}}{D_{0}}\\approx \\frac{0.0711}{8/7}\\approx 0.0622125.$$\n\n3. For $i=4$ (the right endpoint), the denominator equals $D_{4}=2(1-a^{2})=\\frac{8}{7}$ by symmetry. The numerator at $x=0.3$ is\n$$N_{4}=(0.3-(-1))(0.3-(-a))(0.3-0)(0.3-a)\\approx -0.1320423575,$$\nso\n$$\\ell_{4}(0.3)=\\frac{N_{4}}{D_{4}}\\approx -0.1155370628.$$\n\n4. For $i=1$ (the left interior node),\n$$D_{1}=\\prod_{\\substack{j=0\\\\ j\\neq 1}}^{4}(x_{1}-x_{j})=(1-a)(-a)(-2a)(-(1+a))=-2a^{2}(1-a^{2})=-\\frac{24}{49}.$$\nThe numerator at $x=0.3$ is\n$$N_{1}=(0.3-(-1))(0.3-0)(0.3-a)(0.3-1)\\approx 0.0968204521,$$\nso\n$$\\ell_{1}(0.3)=\\frac{N_{1}}{D_{1}}\\approx \\frac{0.0968204521}{-24/49}\\approx -0.1976750897.$$\n\n5. For $i=3$ (the right interior node), by symmetry,\n$$D_{3}=2a^{2}(a^{2}-1)=-2a^{2}(1-a^{2})=-\\frac{24}{49},$$\nand the numerator at $x=0.3$ is\n$$N_{3}=(0.3-(-1))(0.3-(-a))(0.3-0)(0.3-1)\\approx -0.2606204521,$$\nyielding\n$$\\ell_{3}(0.3)=\\frac{N_{3}}{D_{3}}\\approx \\frac{-0.2606204521}{-24/49}\\approx 0.5321000897.$$\n\nAs a consistency check, the partition of unity property $\\sum_{i=0}^{4}\\ell_{i}(x)=1$ holds numerically (up to round-off),\n$$\\ell_{0}+\\ell_{1}+\\ell_{2}+\\ell_{3}+\\ell_{4}\\approx 0.0622125-0.1976750897+0.7189000145+0.5321000897-0.1155370628\\approx 1.0000004517.$$\n\nNow form the interpolant value\n$$I_{4}[u](0.3)=\\sum_{i=0}^{4}u_{i}\\ell_{i}(0.3).$$\nWith $u_{0}=\\frac{13}{10}$, $u_{1}=u_{3}=\\frac{93}{98}$, $u_{2}=\\frac{3}{5}$, $u_{4}=\\frac{13}{10}$, we compute\n\\begin{align*}\nI_{4}[u](0.3)&\\approx \\left(\\frac{13}{10}\\right)\\ell_{0}+\\left(\\frac{93}{98}\\right)\\ell_{1}+\\left(\\frac{3}{5}\\right)\\ell_{2}+\\left(\\frac{93}{98}\\right)\\ell_{3}+\\left(\\frac{13}{10}\\right)\\ell_{4}\\\\\n&\\approx (1.3)(0.0622125)+(0.9489795918)(-0.1976750897)+(0.6)(0.7189000145)\\\\\n&\\quad +(0.9489795918)(0.5321000897)+(1.3)(-0.1155370628)\\\\\n&\\approx 0.08087625-0.1875896472+0.4313400087+0.5049520-0.1501981816\\\\\n&\\approx 0.6793804299.\n\\end{align*}\nRounded to six significant figures, the interpolant value at $x=0.3$ is\n$$I_{4}[u](0.3)\\approx 0.679380.$$\n\nTo bound the interpolation error induced by nodal perturbations, we use the Lebesgue function and the Lebesgue constant. If the nodal values $\\{u_{i}\\}$ are perturbed by $\\{\\delta u_{i}\\}$ with $|\\delta u_{i}|\\leq \\varepsilon$ for all $i$, then at any $x$,\n$$|I_{4}[u+\\delta u](x)-I_{4}[u](x)|=\\left|\\sum_{i=0}^{4}\\delta u_{i}\\,\\ell_{i}(x)\\right|\\leq \\varepsilon\\sum_{i=0}^{4}|\\ell_{i}(x)|=\\varepsilon\\,\\Lambda_{4}(x)\\leq \\varepsilon\\,\\Lambda_{4},$$\nwhere $\\Lambda_{4}=\\sup_{x\\in[-1,1]}\\Lambda_{4}(x)$ is the degree-$4$ Lebesgue constant for the given node set. With $\\varepsilon=2.0\\times 10^{-4}$, the requested bound expressed in terms of $\\Lambda_{4}$ is\n$$|\\,\\text{interpolation error at }x=0.3\\,|\\leq \\left(2.0\\times 10^{-4}\\right)\\Lambda_{4}.$$\nThis completes the evaluation and the error bound.",
            "answer": "$$\\boxed{\\begin{pmatrix}0.679380 & 2.0 \\times 10^{-4}\\,\\Lambda_{4}\\end{pmatrix}}$$"
        },
        {
            "introduction": "While spectral methods offer high accuracy, they face unique challenges, particularly when handling nonlinear terms in equations like the Navier-Stokes or Burgers equations. This exercise provides a hands-on look at the phenomenon of aliasing, where naive collocation of nonlinear terms can lead to errors that violate fundamental physical principles like energy conservation. By computing the exact rate of spurious energy generation for a specific case, you will gain a concrete understanding of why specialized techniques are often needed to ensure the stability of nonlinear simulations .",
            "id": "3381178",
            "problem": "Consider the one-dimensional viscous Burgers equation in conservation form on the reference element $[-1,1]$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{u^{2}}{2}\\right) = \\nu \\frac{\\partial^{2} u}{\\partial x^{2}},\n$$\nwith kinematic viscosity $\\nu$. Adopt a single-element Spectral Element Method (SEM) with polynomial degree $p=3$ using Gauss–Lobatto–Legendre (GLL) collocation. Let the GLL nodes be $x_{0}=-1$, $x_{1}=-\\frac{1}{\\sqrt{5}}$, $x_{2}=\\frac{1}{\\sqrt{5}}$, $x_{3}=1$, and the associated quadrature weights be $w_{0}=w_{3}=\\frac{1}{6}$, $w_{1}=w_{2}=\\frac{5}{6}$. Let $W=\\operatorname{diag}(w_{0},w_{1},w_{2},w_{3})$ be the diagonal mass matrix resulting from mass lumping at the GLL points, and let $D$ be the GLL differentiation matrix with entries $D_{ij}=\\ell_{j}'(x_{i})$, where $\\ell_{j}(x)$ are the Lagrange polynomials associated with the GLL nodes. The nonlinear flux is collocated naively as $f=\\frac{1}{2}u\\odot u$, where $\\odot$ denotes componentwise multiplication.\n\nAssume periodic boundaries for the convective operator such that the continuous convective energy transfer is boundary-neutral on $[-1,1]$ when $u(-1)=u(1)$. Consider the inviscid case $\\nu=0$ and initialize the nodal values by sampling the polynomial field $u(x)=x^{3}-x$ at the GLL nodes, so that $u(-1)=u(1)=0$.\n\nDefine the discrete energy as\n$$\nE_{h}(t)=\\frac{1}{2} u(t)^{\\top} W\\, u(t),\n$$\nand the semi-discrete strong-form collocation SEM as\n$$\nW\\,\\frac{d u}{dt} + W\\,D\\,f = 0,\\qquad f=\\frac{1}{2}u\\odot u.\n$$\nThus, the discrete convective contribution to the energy rate is\n$$\n\\frac{dE_{h}}{dt} = -\\,u^{\\top} W\\,D\\,f.\n$$\nTreat the difference between $\\frac{dE_{h}}{dt}$ and the exact inviscid, periodic convective energy transfer (which is zero for this field on $[-1,1]$) as the aliasing error introduced by naive collocation of the nonlinear term.\n\nCompute the exact scalar value of the aliasing error,\n$$\n\\mathcal{R} \\equiv -\\,u^{\\top} W\\,D\\,f,\n$$\nfor the specified setup. Express your final answer as a single exact number. No rounding is required and no units are needed.",
            "solution": "To compute the aliasing error $\\mathcal{R} = -u^{\\top} W D f$, we follow these steps:\n\n1.  **Compute Nodal Values**: We sample the initial field $u(x) = x^3 - x$ at the $p=3$ GLL nodes: $x_0=-1, x_1=-1/\\sqrt{5}, x_2=1/\\sqrt{5}, x_3=1$.\n    *   $u_0 = u(-1) = (-1)^3 - (-1) = 0$\n    *   $u_1 = u(-1/\\sqrt{5}) = (-1/\\sqrt{5})^3 - (-1/\\sqrt{5}) = -1/(5\\sqrt{5}) + 1/\\sqrt{5} = 4/(5\\sqrt{5})$\n    *   $u_2 = u(1/\\sqrt{5}) = (1/\\sqrt{5})^3 - (1/\\sqrt{5}) = 1/(5\\sqrt{5}) - 1/\\sqrt{5} = -4/(5\\sqrt{5})$\n    *   $u_3 = u(1) = 1^3 - 1 = 0$\n    The nodal vector is $u = \\begin{pmatrix} 0, & \\frac{4}{5\\sqrt{5}}, & -\\frac{4}{5\\sqrt{5}}, & 0 \\end{pmatrix}^{\\top}$.\n\n2.  **Compute Nodal Flux**: The nonlinear flux is $f = \\frac{1}{2} u \\odot u$.\n    *   $f_0 = \\frac{1}{2} u_0^2 = 0$\n    *   $f_1 = \\frac{1}{2} u_1^2 = \\frac{1}{2} \\left(\\frac{4}{5\\sqrt{5}}\\right)^2 = \\frac{1}{2} \\frac{16}{125} = \\frac{8}{125}$\n    *   $f_2 = \\frac{1}{2} u_2^2 = \\frac{1}{2} \\left(-\\frac{4}{5\\sqrt{5}}\\right)^2 = \\frac{8}{125}$\n    *   $f_3 = \\frac{1}{2} u_3^2 = 0$\n    The flux vector is $f = \\begin{pmatrix} 0, & \\frac{8}{125}, & \\frac{8}{125}, & 0 \\end{pmatrix}^{\\top}$.\n\n3.  **Evaluate the Expression**: The expression $\\mathcal{R} = -u^{\\top} W D f$ represents the GLL quadrature of the integral $-\\int_{-1}^{1} u_I(x) (f_I)'(x) \\, dx$, where $u_I(x)$ and $f_I(x)$ are the polynomial interpolants of the nodal vectors $u$ and $f$.\n    *   The GLL quadrature rule with $p+1=4$ nodes is exact for polynomial integrands of degree up to $2(p+1)-3 = 2(4)-3=5$.\n    *   Since $u(x)$ is a degree-3 polynomial, its interpolant is itself: $u_I(x) = x^3 - x$.\n    *   The flux data $f$ is interpolated by a polynomial $f_I(x)$ of degree at most 3. The product $u_I(x) (f_I)'(x)$ has degree at most $3 + (3-1) = 5$. Therefore, the quadrature is exact, and we can compute the integral directly.\n    *   We find $f_I(x)$. Since the data is symmetric about $x=0$, $f_I(x)$ must be an even polynomial of the form $Ax^2+B$. Using the conditions $f_I(1)=0$ and $f_I(1/\\sqrt{5}) = 8/125$, we solve for the coefficients:\n        *   $f_I(1) = A+B = 0 \\implies B=-A$.\n        *   $f_I(1/\\sqrt{5}) = A(1/5-1) = -4A/5 = 8/125 \\implies A = -10/125 = -2/25$.\n        *   So, $f_I(x) = -\\frac{2}{25}(x^2-1) = \\frac{2}{25}(1-x^2)$. Its derivative is $f_I'(x) = -\\frac{4}{25}x$.\n\n4.  **Compute the Integral**:\n    $$ \\mathcal{R} = -\\int_{-1}^{1} u_I(x) f_I'(x) \\, dx = -\\int_{-1}^{1} (x^3-x) \\left(-\\frac{4}{25}x\\right) \\, dx $$\n    $$ \\mathcal{R} = \\frac{4}{25} \\int_{-1}^{1} (x^4 - x^2) \\, dx = \\frac{4}{25} \\left[ \\frac{x^5}{5} - \\frac{x^3}{3} \\right]_{-1}^{1} $$\n    $$ \\mathcal{R} = \\frac{4}{25} \\left[ \\left(\\frac{1}{5}-\\frac{1}{3}\\right) - \\left(-\\frac{1}{5}+\\frac{1}{3}\\right) \\right] = \\frac{4}{25} \\cdot 2 \\cdot \\left(\\frac{3-5}{15}\\right) = \\frac{8}{25} \\left(-\\frac{2}{15}\\right) = -\\frac{16}{375}. $$\n    The aliasing error, which represents a spurious generation of energy, is exactly $-\\frac{16}{375}$.",
            "answer": "$$\\boxed{-\\frac{16}{375}}$$"
        },
        {
            "introduction": "Real-world geophysical problems often involve sharp interfaces between different materials, which pose a challenge for high-order methods due to the Gibbs phenomenon—spurious oscillations near discontinuities. This practical coding exercise introduces spectral filtering as a powerful technique to mitigate these artifacts. You will implement a modal filter and tackle the realistic trade-off between suppressing ringing and preserving the phase accuracy of smooth wave components, a critical skill in computational seismology and wave propagation modeling .",
            "id": "3617116",
            "problem": "Consider a one-dimensional spectral element of length normalized to the interval $[-1,1]$. The spectral element method uses Lagrange interpolation at Gauss-Lobatto-Legendre nodes and can be equivalently represented in a modal basis of Legendre polynomials. Let $\\{P_k(x)\\}_{k=0}^N$ denote the Legendre polynomials up to degree $N$, and let $\\{x_i,w_i\\}_{i=0}^N$ denote the Gauss-Lobatto-Legendre nodes and weights on $[-1,1]$. The Legendre polynomials satisfy orthogonality $\\int_{-1}^1 P_k(x) P_m(x) \\, dx = \\frac{2}{2k+1} \\delta_{km}$. In computational geophysics, Gibbs ringing arises when approximating functions with jumps (for instance, material property jumps) by high-order polynomials, and spectral filters in modal space are used to suppress high-order content that causes ringing. The filter applies a multiplicative factor in modal space, leaving low modes unchanged while attenuating higher modes.\n\nStarting from these foundations, derive a family of smooth, monotone modal filters $\\sigma_k$ for $k=0,1,\\dots,N$ that satisfy the following structural constraints:\n- $\\sigma_k \\in (0,1]$ for all $k$.\n- $\\sigma_k = 1$ for low modes up to a cutoff index $k_c$, and then decays smoothly for $k > k_c$.\n- The decay is controlled by a smoothness parameter $p$ (a positive even integer) and a strength parameter $\\alpha > 0$, which together govern how quickly $\\sigma_k$ approaches a small target attenuation at the highest mode.\n\nExplain how to compute the Legendre modal coefficients of a function $u(x)$ using Gauss-Lobatto-Legendre quadrature and orthogonality, how to apply the modal filter, and how to reconstruct the filtered field at arbitrary points. To tune the cutoff $k_c$ “to suppress Gibbs ringing near material jumps without distorting phase,” define and compute the following two quantitative metrics:\n\n1. Gibbs ringing metric near a jump at $x=0$: let $u_{\\text{step}}(x)$ be the step function defined by $u_{\\text{step}}(x)=0$ for $x<0$ and $u_{\\text{step}}(x)=1$ for $x\\ge 0$. After filtering, reconstruct $u_{\\text{step}}^{\\text{filt}}(x)$ on a fine uniform grid on $[-1,1]$. Define the ringing metric $R$ as the maximum absolute overshoot in the neighborhood of the jump,\n$$\nR = \\max\\left\\{\\max_{x \\in [0,0.25]} \\left(u_{\\text{step}}^{\\text{filt}}(x) - 1\\right), \\; \\max_{x \\in [-0.25,0]} \\left(0 - u_{\\text{step}}^{\\text{filt}}(x)\\right), \\; 0 \\right\\}.\n$$\n\n2. Phase distortion metric for a smooth harmonic: let $u_{\\text{sin}}(x)=\\cos(k x)$ for a given wavenumber $k$ in radians per unit length. After filtering and reconstruction to the same fine grid, estimate the phase $\\phi$ of the best-fit cosine at the original wavenumber by discrete inner products over $[-1,1]$ with uniform spacing,\n$$\nC = \\int_{-1}^1 u_{\\text{sin}}^{\\text{filt}}(x) \\cos(k x) \\, dx, \\quad S = \\int_{-1}^1 u_{\\text{sin}}^{\\text{filt}}(x) \\sin(k x) \\, dx,\n$$\nand compute the phase estimate $\\phi = \\arctan2(-S, C)$. Define the phase error as $E_\\phi = |\\phi|$ in radians. All angles must be expressed in radians.\n\nYou must implement a program that, for each test case, searches over integer cutoffs $k_c \\in \\{0,1,\\dots,N\\}$ to find the largest $k_c$ such that both constraints $R \\le R_{\\text{tol}}$ and $E_\\phi \\le E_{\\phi,\\text{tol}}$ are simultaneously satisfied. If no such $k_c$ exists, report $-1$. Use the following test suite, which specifies $(N, p, \\alpha, k, R_{\\text{tol}}, E_{\\phi,\\text{tol}})$:\n\n- Test case 1 (happy path): $N=16$, $p=8$, $\\alpha=18.420680744$, $k=\\frac{3\\pi}{2}$, $R_{\\text{tol}}=0.03$, $E_{\\phi,\\text{tol}}=0.01$.\n- Test case 2 (phase-priority boundary): $N=16$, $p=8$, $\\alpha=18.420680744$, $k=\\frac{3\\pi}{2}$, $R_{\\text{tol}}=0.15$, $E_{\\phi,\\text{tol}}=10^{-6}$.\n- Test case 3 (ringing-suppression edge): $N=16$, $p=8$, $\\alpha=18.420680744$, $k=\\frac{3\\pi}{2}$, $R_{\\text{tol}}=0.01$, $E_{\\phi,\\text{tol}}=0.05$.\n- Test case 4 (low-order boundary): $N=4$, $p=6$, $\\alpha=18.420680744$, $k=\\pi$, $R_{\\text{tol}}=0.10$, $E_{\\phi,\\text{tol}}=0.05$.\n- Test case 5 (high-order element): $N=32$, $p=12$, $\\alpha=30.0$, $k=2\\pi$, $R_{\\text{tol}}=0.02$, $E_{\\phi,\\text{tol}}=0.005$.\n\nYour program should produce a single line of output containing the tuned cutoffs for all test cases as a comma-separated list enclosed in square brackets (e.g., $[k_{c,1},k_{c,2},k_{c,3},k_{c,4},k_{c,5}]$). All quantities in this problem are dimensionless except for angles, which must be in radians.",
            "solution": "This problem requires designing and evaluating a modal filter to suppress Gibbs ringing in a spectral element context. The solution involves several theoretical and computational steps, which are implemented in the provided Python code.\n\n### 1. Theoretical Framework\n\n**a. Modal Representation and Transformation:**\nA function $u(x)$ defined on the reference element $[-1, 1]$ is represented by its values $u(x_j)$ at the $N+1$ Gauss-Lobatto-Legendre (GLL) nodes. This nodal representation is equivalent to a modal representation using a basis of Legendre polynomials $P_k(x)$:\n$$ u(x) \\approx \\sum_{k=0}^{N} \\hat{u}_k P_k(x) $$\nThe modal coefficients $\\hat{u}_k$ are found by projecting the function onto the basis and leveraging the orthogonality of Legendre polynomials. Using GLL quadrature for the integral, the discrete Legendre transform is:\n$$ \\hat{u}_k = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) P_k(x) \\, dx \\approx \\frac{2k+1}{2} \\sum_{j=0}^{N} u(x_j) P_k(x_j) w_j $$\nwhere $\\{x_j, w_j\\}$ are the GLL nodes and weights.\n\n**b. Spectral Filter Design:**\nTo suppress ringing caused by high-frequency modes when approximating discontinuities, we apply a filter $\\sigma_k$ to the modal coefficients. The problem requires a filter that is unity for low modes ($k \\le k_c$) and decays smoothly for higher modes. A suitable choice that satisfies all constraints is the exponential filter:\n$$ \\sigma_k(k_c, p, \\alpha) = \\begin{cases} 1 & \\text{if } k \\le k_c \\\\ \\exp\\left(-\\alpha \\left(\\frac{k - k_c}{N - k_c}\\right)^p\\right) & \\text{if } k > k_c \\end{cases} $$\nHere, $k_c$ is the cutoff mode, $p$ controls the smoothness of the decay, and $\\alpha$ sets the attenuation strength at the highest mode $k=N$. Filtering is performed by element-wise multiplication in the spectral domain: $\\hat{u}_k^{\\text{filt}} = \\sigma_k \\hat{u}_k$.\n\n**c. Reconstruction:**\nThe filtered function is reconstructed in physical space by summing the filtered modal series:\n$$ u^{\\text{filt}}(x) = \\sum_{k=0}^{N} \\hat{u}_k^{\\text{filt}} P_k(x) $$\n\n### 2. Algorithmic Implementation\n\nThe goal is to find the largest cutoff index $k_c$ that satisfies both a ringing tolerance ($R \\le R_{\\text{tol}}$) and a phase error tolerance ($E_\\phi \\le E_{\\phi,\\text{tol}}$). The general trade-off is that increasing $k_c$ (less filtering) improves phase accuracy for smooth waves but worsens Gibbs ringing for discontinuities.\n\nThe algorithm, as implemented in the provided code, is as follows for each test case:\n1.  **Initialization**: Compute the GLL nodes and weights for the given degree $N$. Pre-compute the values of Legendre polynomials $P_k(x_j)$ at these nodes.\n2.  **Modal Transform**: For both the step function ($u_{\\text{step}}$) and the harmonic function ($u_{\\text{sin}}$), sample them at the GLL nodes and compute their modal coefficients, $\\hat{u}_{\\text{step}, k}$ and $\\hat{u}_{\\text{sin}, k}$.\n3.  **Search Loop**: Iterate $k_c$ downwards from $N$ to $0$. In each iteration:\n    a.  **Define Filter**: Construct the filter array $\\sigma_k$ based on the current $k_c$ and the given parameters $p$ and $\\alpha$.\n    b.  **Apply Filter and Reconstruct**: Apply the filter to both sets of modal coefficients. Reconstruct the filtered functions $u_{\\text{step}}^{\\text{filt}}(x)$ and $u_{\\text{sin}}^{\\text{filt}}(x)$ on a fine uniform grid spanning $[-1, 1]$.\n    c.  **Compute Metrics**:\n        *   Calculate the ringing metric $R$ by finding the maximum overshoot/undershoot of $u_{\\text{step}}^{\\text{filt}}(x)$ near the jump at $x=0$.\n        *   Calculate the phase error $E_\\phi$ by performing numerical integration (e.g., trapezoidal rule) on the fine grid to find the phase shift of $u_{\\text{sin}}^{\\text{filt}}(x)$.\n    d.  **Check Condition**: If both $R \\le R_{\\text{tol}}$ and $E_\\phi \\le E_{\\phi,\\text{tol}}$ are met, the current $k_c$ is a valid solution. Since we are iterating downwards, this is the largest such $k_c$. The value is recorded, and the search for this test case terminates.\n4.  **Finalize**: If the loop completes without finding any valid $k_c$, the result for that test case is $-1$. The final output is a list of the optimal $k_c$ values for all test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\n\ndef gll_nodes_weights(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes and weights for a given polynomial degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([2.0])\n    if N == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n    \n    # Interior nodes are roots of P'_N(x), which are roots of Jacobi polynomial P_{N-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    \n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    # Weights formula: w_i = 2 / (N(N+1) * [P_N(x_i)]^2)\n    pn_at_nodes = eval_legendre(N, nodes)\n    weights = 2.0 / (N * (N + 1) * pn_at_nodes**2)\n    \n    return nodes, weights\n\ndef solve_case(N, p, alpha, k_wave, R_tol, E_phi_tol):\n    \"\"\"\n    Solves for the optimal cutoff kc for a single test case.\n    \"\"\"\n    # 1. GLL quadrature and basis properties\n    gll_x, gll_w = gll_nodes_weights(N)\n    \n    # Pre-compute Legendre polynomials at GLL nodes: P_kj = P_k(x_j)\n    P_kj = np.array([eval_legendre(k, gll_x) for k in range(N + 1)])\n    modal_basis_norm = (2 * np.arange(N + 1) + 1) / 2.0\n\n    # 2. Define functions and compute their modal coefficients\n    u_step_at_nodes = (gll_x >= 0).astype(float)\n    u_sin_at_nodes = np.cos(k_wave * gll_x)\n\n    # Transform to modal (Legendre) space\n    # u_hat_k = modal_norm_k * sum_j( u(x_j) * P_k(x_j) * w_j )\n    u_hat_step = modal_basis_norm * np.dot(P_kj, u_step_at_nodes * gll_w)\n    u_hat_sin = modal_basis_norm * np.dot(P_kj, u_sin_at_nodes * gll_w)\n    \n    # 3. Setup for reconstruction and metric evaluation\n    fine_x = np.linspace(-1, 1, 2001)\n    P_k_fine = np.array([eval_legendre(k, fine_x) for k in range(N + 1)])\n\n    # 4. Search for the largest k_c satisfying the constraints\n    for kc in range(N, -1, -1):\n        # Define the filter sigma_k\n        sigma = np.ones(N + 1)\n        if kc < N:\n            k_indices = np.arange(kc + 1, N + 1)\n            # The formula: exp(-alpha * ((k-kc)/(N-kc))^p)\n            ratio = (k_indices - kc) / (N - kc)\n            exponent = -alpha * (ratio**p)\n            sigma[kc + 1:] = np.exp(exponent)\n\n        # ----- Metric 1: Ringing (R) for the step function -----\n        u_hat_step_filt = u_hat_step * sigma\n        u_step_filt = np.dot(u_hat_step_filt, P_k_fine)\n        \n        # Calculate overshoot and undershoot\n        mask_pos = (fine_x >= 0) & (fine_x <= 0.25)\n        mask_neg = (fine_x >= -0.25) & (fine_x < 0)\n        \n        max_overshoot = np.max(u_step_filt[mask_pos] - 1.0, initial=0.0)\n        max_undershoot = np.max(-u_step_filt[mask_neg], initial=0.0)\n        \n        R = max(max_overshoot, max_undershoot)\n\n        # ----- Metric 2: Phase Error (E_phi) for the sine function -----\n        u_hat_sin_filt = u_hat_sin * sigma\n        u_sin_filt = np.dot(u_hat_sin_filt, P_k_fine)\n\n        # Calculate phase shift using discrete inner products\n        C = np.trapz(u_sin_filt * np.cos(k_wave * fine_x), fine_x)\n        S = np.trapz(u_sin_filt * np.sin(k_wave * fine_x), fine_x)\n        \n        phi = np.arctan2(-S, C)\n        E_phi = np.abs(phi)\n\n        # ----- Check constraints -----\n        if R <= R_tol and E_phi <= E_phi_tol:\n            return kc\n\n    return -1\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, p, alpha, k, R_tol, E_phi_tol)\n        (16, 8, 18.420680744, 3 * np.pi / 2, 0.03, 0.01),\n        (16, 8, 18.420680744, 3 * np.pi / 2, 0.15, 1e-6),\n        (16, 8, 18.420680744, 3 * np.pi / 2, 0.01, 0.05),\n        (4, 6, 18.420680744, np.pi, 0.10, 0.05),\n        (32, 12, 30.0, 2 * np.pi, 0.02, 0.005),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, k_wave, R_tol, E_phi_tol = case\n        result = solve_case(N, p, alpha, k_wave, R_tol, E_phi_tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}