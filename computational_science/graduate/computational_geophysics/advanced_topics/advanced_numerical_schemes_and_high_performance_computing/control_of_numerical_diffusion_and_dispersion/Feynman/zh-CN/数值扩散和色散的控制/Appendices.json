{
    "hands_on_practices": [
        {
            "introduction": "掌握数值频散和耗散的第一步，是在最简单的场景下理解如何量化它们。本练习聚焦于线性平流方程，运用傅里叶分析来剖析有限差分格式的性能。通过比较经典的高阶中心差分格式与一个现代的低频散优化格式，你将亲手实践计算相位误差和振幅误差，这是衡量格式优劣的基本指标 。",
            "id": "3581900",
            "problem": "考虑一维线性平流方程 $u_t + c\\,u_x = 0$，其中速度 $c > 0$ 为常数，方程定义在间距为 $\\Delta x$ 的均匀网格上，并采用周期性边界条件。设库朗数定义为 $\\nu = c\\,\\Delta t/\\Delta x$。您将比较两种用于一阶导数 $u_x$ 的空间离散化格式，这两种格式均与相同的显式时间积分器耦合。您需要量化它们在无量纲波数带 $k\\Delta x \\in [0,\\pi]$ 上的数值色散（相位误差）和数值耗散（振幅误差）。所有角度必须以弧度表示。\n\n分析应基于以下原理和经过充分检验的公式：\n\n- 傅里叶模态分析：对于一个傅里叶模 $u_j^n \\propto \\exp(i j \\xi)$（其中 $\\xi = k\\Delta x \\in [0,\\pi]$），任何应用于离散化空间算子的线性时间步进格式都会产生一个单步复数放大因子 $G(\\xi)$，使得 $u^{n+1} = G(\\xi) u^n$。\n- 对于精确偏微分方程，单步精确放大因子为 $\\exp(-i \\nu \\xi)$。\n- 对于采用对称模板上 $u_x$ 的有限差分近似的半离散线方法，离散空间傅里叶符号为 $i\\,\\kappa(\\xi)/\\Delta x$，其中 $\\kappa(\\xi)$ 是该模板的修正波数。对于一个反对称 $(2M+1)$ 点中心模板，其权重 $\\{b_m\\}_{m=1}^M$ 定义为\n$$\n(D u)_j \\approx \\frac{1}{\\Delta x}\\sum_{m=1}^M b_m\\left(u_{j+m} - u_{j-m}\\right),\n$$\n其修正波数为\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi).\n$$\n- 对于显式经典四阶龙格－库塔（RK4）方法，其稳定性函数为\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24},\n$$\n全离散格式的数值放大因子为 $G(\\xi) = R\\!\\left(-i\\,\\nu\\,\\kappa(\\xi)\\right)$。\n\n您将研究两种七点模板（$M=3$），两者均在 $\\nu = 0.5$ 的条件下与相同的 RK4 时间积分器耦合：\n\n- 经典六阶中心差分（基于七点对称模板）：\n$$\nb_1 = \\frac{45}{60} = 0.75,\\quad b_2 = -\\frac{9}{60} = -0.15,\\quad b_3 = \\frac{1}{60}.\n$$\n- 一种优化的低色散、非紧致、显式七点模板，其系数旨在宽频带上减小色散误差（在色散关系保持格式的文献中是一个著名的选择）：\n$$\nb_1 = 0.770882380518225,\\quad b_2 = -0.166705904414580,\\quad b_3 = 0.020843142770311.\n$$\n\n对于每种模板，将单步相位误差和振幅误差定义为 $\\xi$ 的函数：\n$$\ne_{\\mathrm{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\,\\xi\\right),\n\\qquad\ne_{\\mathrm{amp}}(\\xi) = \\left|\\;|G(\\xi)| - 1\\;\\right|,\n$$\n其中 $\\arg(\\cdot)$ 是主辐角，$\\operatorname{wrap}_{(-\\pi,\\pi]}(\\theta)$ 通过加或减 $2\\pi$ 的整数倍将任意实数角度 $\\theta$ 包裹到 $(-\\pi,\\pi]$ 区间内。\n\n定义一个组合的单步误差大小\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}.\n$$\n\n您的程序必须在 $\\nu = 0.5$ 和 $\\xi \\in [0,\\pi]$（含端点）上取 $N = 10001$ 个均匀点的条件下，计算以下量：\n\n- 测试用例 1 (浮点数)：使得优化模板的组合误差严格小于经典模板的最小 $\\xi^\\star \\in (0,\\pi]$，即满足 $E_{\\mathrm{opt}}(\\xi)  E_{\\mathrm{classical}}(\\xi)$ 的最小采样 $\\xi$。如果网格上不存在这样的 $\\xi$，则返回 $\\mathrm{NaN}$。\n- 测试用例 2 (布尔值)：在 $\\xi = \\pi/2$ 处，优化模板的绝对相位误差是否严格小于经典模板？如果 $\\left|e_{\\mathrm{phase,opt}}(\\pi/2)\\right|  \\left|e_{\\mathrm{phase,classic}}(\\pi/2)\\right|$，则返回 $True$，否则返回 $False$。\n- 测试用例 3 (布尔值)：在 $\\xi = 0$ 处，两种模板的振幅误差是否都低于 $10^{-12}$ 的容差？如果 $\\left|e_{\\mathrm{amp,opt}}(0)\\right| \\le 10^{-12}$ 且 $\\left|e_{\\mathrm{amp,classic}}(0)\\right| \\le 10^{-12}$，则返回 $True$，否则返回 $False$。\n- 测试用例 4 (浮点数)：经典模板在 $\\xi \\in [0,\\pi]$ 上的最大绝对振幅误差，即 $\\max_{\\xi} \\left|e_{\\mathrm{amp,classic}}(\\xi)\\right|$。\n- 测试用例 5 (浮点数)：优化模板在 $\\xi \\in [0,\\pi]$ 上的最大绝对振幅误差，即 $\\max_{\\xi} \\left|e_{\\mathrm{amp,opt}}(\\xi)\\right|$。\n\n角度量必须是弧度。所有浮点数输出必须四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，结果按上述顺序排列，以逗号分隔并用方括号括起：\n$[\\xi^\\star, \\text{bool\\_at\\_}\\pi/2, \\text{bool\\_at\\_}0, \\max e_{\\mathrm{amp,classic}}, \\max e_{\\mathrm{amp,opt}}]$。",
            "solution": "该问题要求对一维线性平流方程的两种数值格式进行比较分析：\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是被输运的量，$c > 0$ 是恒定的波速。分析在傅里叶域中进行，适用于间距为 $\\Delta x$ 的均匀空间网格和恒定的时间步长 $\\Delta t$。关键参数是库朗数，定义为 $\\nu = c\\Delta t / \\Delta x$。\n\n我们分析格式在单个傅里叶模态 $u_j^n = \\hat{u}^n(k) e^{i(k x_j)} = \\hat{u}^n(\\xi) e^{ij\\xi}$ 上的行为，其中 $x_j = j\\Delta x$，$\\xi = k\\Delta x$ 是无量纲波数。精确解将此模态在一个时间步长 $\\Delta t$ 内演化如下：\n$$\nu(x, t+\\Delta t) = u(x-c\\Delta t, t) \\implies \\hat{u}^{n+1} = \\hat{u}^n e^{-ikc\\Delta t} = \\hat{u}^n e^{-i\\nu\\xi}\n$$\n$G_{\\text{exact}}(\\xi) = e^{-i\\nu\\xi}$ 项是精确放大因子。其模 $|G_{\\text{exact}}(\\xi)| = 1$，表示没有振幅变化，其相位为 $\\phi_{\\text{exact}}(\\xi) = -\\nu\\xi$。\n\n数值格式通过 $u_j^{n+1} = \\mathcal{L}(u^n)_j$ 来近似此演化过程，在傅里叶域中变为 $\\hat{u}^{n+1} = G(\\xi) \\hat{u}^n$。复数量 $G(\\xi)$ 是全离散格式的数值放大因子。\n\n线方法首先对空间导数 $\\frac{\\partial u}{\\partial x}$ 进行离散化，得到一个常微分方程组（ODEs）。对于一个通用的 $(2M+1)$ 点反对称中心差分格式，这表示为：\n$$\n\\frac{du_j}{dt} = -c (D u)_j = -\\frac{c}{\\Delta x} \\sum_{m=1}^M b_m(u_{j+m} - u_{j-m})\n$$\n将此算子应用于傅里叶模态 $e^{ij\\xi}$ 得到：\n$$\nD e^{ij\\xi} = \\frac{1}{\\Delta x} \\sum_{m=1}^M b_m(e^{i(j+m)\\xi} - e^{i(j-m)\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\sum_{m=1}^M b_m(e^{im\\xi} - e^{-im\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\left( 2i \\sum_{m=1}^M b_m \\sin(m\\xi) \\right)\n$$\n这定义了空间算子的傅里叶符号为 $i\\kappa(\\xi)/\\Delta x$，其中 $\\kappa(\\xi)$ 是修正波数：\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi)\n$$\n因此，傅里叶空间中的半离散常微分方程组为 $\\frac{d\\hat{u}}{dt} = -c \\frac{i\\kappa(\\xi)}{\\Delta x} \\hat{u}$。\n\n对于所考虑的两种七点模板（$M=3$）：\n- **经典六阶**：系数为 $b_1 = 45/60$，$b_2 = -9/60$，$b_3 = 1/60$，其修正波数为：\n$$\n\\kappa_{\\text{classic}}(\\xi) = 2\\left(\\frac{45}{60}\\sin(\\xi) - \\frac{9}{60}\\sin(2\\xi) + \\frac{1}{60}\\sin(3\\xi)\\right)\n$$\n- **优化低色散**：系数为 $b_1 = 0.770882380518225$，$b_2 = -0.166705904414580$，$b_3 = 0.020843142770311$，其修正波数为：\n$$\n\\kappa_{\\text{opt}}(\\xi) = 2(b_1\\sin(\\xi) + b_2\\sin(2\\xi) + b_3\\sin(3\\xi))\n$$\n\n半离散常微分方程组 $\\frac{d\\hat{u}}{dt} = \\lambda \\hat{u}$（其中 $\\lambda = -ic\\kappa(\\xi)/\\Delta x$）使用显式四阶龙格－库塔（RK4）方法进行时间上的向前积分。对于 $y'=\\lambda y$，单步 RK4 的放大因子由其稳定性函数 $R(z)$ 给出，其中 $z = \\lambda \\Delta t$。\n$$\nz = \\left(-i\\frac{c\\kappa(\\xi)}{\\Delta x}\\right) \\Delta t = -i \\left(\\frac{c\\Delta t}{\\Delta x}\\right) \\kappa(\\xi) = -i\\nu\\kappa(\\xi)\n$$\n因此，全离散格式的数值放大因子为 $G(\\xi) = R(-i\\nu\\kappa(\\xi))$，其中 $R(z)$ 是 RK4 多项式：\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\n$$\n\n通过将数值放大因子 $G(\\xi)$ 与精确放大因子 $G_{\\text{exact}}(\\xi)$ 进行比较来量化数值误差。\n- **相位误差**衡量相速度的差异。数值相位是 $\\phi_{\\text{num}}(\\xi) = \\arg(G(\\xi))$。单步相位误差是数值相位与精确相位之差，并包裹到区间 $(-\\pi, \\pi]$ 内：\n$$\ne_{\\text{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\phi_{\\text{num}}(\\xi) - \\phi_{\\text{exact}}(\\xi)\\right) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\xi\\right)\n$$\n非零的相位误差会导致数值色散，即不同波数的波以相互之间不正确的速度传播。\n- **振幅误差**衡量一个模态每步的振幅变化。数值振幅是 $|G(\\xi)|$。单步振幅误差是：\n$$\ne_{\\text{amp}}(\\xi) = \\left|\\;|G(\\xi)| - 1\\;\\right|\n$$\n非零的振幅误差对应于数值耗散（如果 $|G(\\xi)|  1$）或不稳定性（如果 $|G(\\xi)| > 1$）。对于一个稳定的格式，此误差代表不希望出现的阻尼。\n- **组合误差**为整体误差大小提供了一个单一的度量：\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}\n$$\n\n对于给定的库朗数 $\\nu=0.5$，通过执行以下步骤获得解：\n1.  在 $[0, \\pi]$ 上定义一个由 $N=10001$ 个均匀分布的波数 $\\xi_j$ 组成的离散网格。\n2.  对每种模板（经典和优化），执行以下操作：\n    a.  使用各自的系数计算修正波数向量 $\\kappa(\\xi_j)$。\n    b.  计算复数向量 $z(\\xi_j) = -i\\nu\\kappa(\\xi_j)$。\n    c.  评估 RK4 稳定性多项式 $G(\\xi_j) = R(z(\\xi_j))$。\n    d.  计算相位误差向量 $e_{\\text{phase}}(\\xi_j)$，确保角度被正确包裹到 $(-\\pi, \\pi]$ 内。\n    e.  计算振幅误差向量 $e_{\\text{amp}}(\\xi_j)$。\n    f.  计算组合误差向量 $E(\\xi_j)$。\n3.  使用两种模板计算出的误差向量，回答五个测试问题：\n    - **测试 1**：找到第一个使 $E_{\\text{opt}}(\\xi_j)  E_{\\text{classic}}(\\xi_j)$ 成立的索引 $j > 0$，并报告相应的 $\\xi_j$。\n    - **测试 2**：在最接近 $\\xi=\\pi/2$ 的网格点上，比较相位误差的绝对值。\n    - **测试 3**：在 $\\xi_0=0$ 处，检查两种模板的振幅误差是否都低于容差 $10^{-12}$。根据理论，这是预期的结果，因为 $\\kappa(0) = 0 \\implies G(0) = 1 \\implies e_{\\text{amp}}(0) = 0$。\n    - **测试 4 和 5**：对每种模板，找出其在整个定义域 $[0, \\pi]$ 上的振幅误差向量的最大值。\n4.  根据指定的格式规则，将最终结果格式化为逗号分隔的列表。\n\n该过程为与 RK4 时间积分器耦合的两种空间离散格式的色散和耗散特性提供了严谨的定量比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and compares two finite-difference schemes for the 1D linear\n    advection equation by computing their numerical dispersion and dissipation\n    errors.\n    \"\"\"\n    # Define problem parameters and test cases from the problem statement.\n    nu = 0.5\n    N = 10001\n    b_classic = [45.0 / 60.0, -9.0 / 60.0, 1.0 / 60.0]\n    b_opt = [0.770882380518225, -0.166705904414580, 0.020843142770311]\n    \n    # Create the non-dimensional wavenumber grid\n    xi = np.linspace(0, np.pi, N, endpoint=True)\n\n    def get_errors(b_coeffs, nu_val, xi_grid):\n        \"\"\"\n        Calculates error metrics for a given stencil and Courant number.\n        \"\"\"\n        # Calculate the modified wavenumber kappa(xi)\n        # kappa(xi) = 2 * sum_{m=1}^{3} b_m * sin(m*xi)\n        kappa = (2 * b_coeffs[0] * np.sin(1 * xi_grid) +\n                 2 * b_coeffs[1] * np.sin(2 * xi_grid) +\n                 2 * b_coeffs[2] * np.sin(3 * xi_grid))\n        \n        # Argument for the RK4 stability function\n        z = -1j * nu_val * kappa\n        \n        # Numerical amplification factor G(xi) from RK4 stability function R(z)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        G = 1 + z + z**2 / 2.0 + z**3 / 6.0 + z**4 / 24.0\n\n        # Calculate phase error, e_phase = wrap(arg(G) + nu*xi)\n        e_phase_raw = np.angle(G) + nu_val * xi_grid\n        \n        # Wrap the phase error to the interval (-pi, pi]\n        # The formula is theta - 2*pi*floor((theta+pi)/(2*pi))\n        e_phase = e_phase_raw - 2 * np.pi * np.floor((e_phase_raw + np.pi) / (2 * np.pi))\n\n        # Calculate amplitude error, e_amp = ||G| - 1|\n        e_amp = np.abs(np.abs(G) - 1.0)\n        \n        # Calculate combined error magnitude E\n        E = np.sqrt(e_phase**2 + e_amp**2)\n\n        return e_phase, e_amp, E\n\n    # Calculate errors for both stencils\n    e_phase_c, e_amp_c, E_c = get_errors(b_classic, nu, xi)\n    e_phase_o, e_amp_o, E_o = get_errors(b_opt, nu, xi)\n\n    # --- Test Cases ---\n\n    # Test case 1: Smallest xi_star in (0, pi] where E_opt  E_classic\n    # We search in the slice [1:] to exclude xi=0\n    indices = np.where(E_o[1:]  E_c[1:])[0]\n    if len(indices) > 0:\n        # Add 1 to the index to map it back to the original `xi` array\n        first_index = indices[0] + 1\n        xi_star = xi[first_index]\n    else:\n        xi_star = np.nan\n\n    # Test case 2: At xi = pi/2, is |e_phase_opt|  |e_phase_classic|?\n    idx_pi_2 = np.argmin(np.abs(xi - np.pi / 2.0))\n    is_opt_better_phase = np.abs(e_phase_o[idx_pi_2])  np.abs(e_phase_c[idx_pi_2])\n\n    # Test case 3: At xi = 0, do both stencils have amplitude error = 1e-12?\n    # At xi=0, kappa=0, z=0, G=1, so e_amp should be 0. We check for numerical precision.\n    is_amp_zero_at_origin = (e_amp_c[0] = 1e-12) and (e_amp_o[0] = 1e-12)\n\n    # Test case 4: Maximum absolute amplitude error of the classical stencil\n    max_amp_c = np.max(e_amp_c)\n\n    # Test case 5: Maximum absolute amplitude error of the optimized stencil\n    max_amp_o = np.max(e_amp_o)\n\n    # --- Final Output Formatting ---\n    results = [\n        xi_star,\n        is_opt_better_phase,\n        is_amp_zero_at_origin,\n        max_amp_c,\n        max_amp_o\n    ]\n\n    def format_item(item):\n        \"\"\"Formats a result item according to the problem specification.\"\"\"\n        if isinstance(item, (bool, np.bool_)):\n            return str(item)\n        if isinstance(item, (float, np.floating)):\n            if np.isnan(item):\n                return 'NaN'\n            return f\"{item:.6f}\"\n        return str(item)\n\n    formatted_results = [format_item(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的地球物理流动常常包含激波或陡峭梯度，这需要使用非线性格式，例如MUSCL-TVD方法。本练习将你的分析技能扩展到这些更复杂的有限体积格式上。由于它们的非线性特性使得直接的解析傅里叶分析变得困难，你将学习一种强大的数值技术，使用快速傅里叶变换（FFT）来估计不同通量限制器的有效频散特性 。",
            "id": "3581892",
            "problem": "您的任务是分析三种总变差减小（TVD）通量限制器在应用于一维线性平流方程的半离散守恒律单调上游中心格式（MUSCL）空间离散时所表现出的色散和扩散特性。目标是数值估算有效修正波数，并确定哪种限制器对小振幅正弦波产生的相位误差最低。\n\n从一维线性平流方程开始，这是地球物理流体动力学中的一个基本平衡律，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中 $u(x,t)$ 是平流标量场，$a$ 是恒定的平流速度，$x$ 表示位置。考虑在一个长度为 $L$ 的域上，使用一个包含 $N$ 个点、间距为 $\\,\\Delta x = L/N\\,$ 的均匀周期性网格，并采用半离散有限体积公式。\n\n在均匀网格上，记单元中心值为 $u_i$，数值通量为 $F_{i+1/2}$。对于正平流速度 $a>0$，通过以下方式定义界面 $x_{i+1/2}$ 处的 MUSCL 左态：\n$$\nu_{i+1/2}^{-} = u_i + \\frac{1}{2}\\,\\phi(r_i)\\,(u_i - u_{i-1}),\n$$\n其中 $\\phi(r)$ 是一个通量限制器函数，$r_i$ 是光滑度比，\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i + \\varepsilon},\n$$\n其中 $\\,\\varepsilon > 0\\,$ 是一个小数，以避免除以零。数值通量为\n$$\nF_{i+1/2} = a\\,u_{i+1/2}^{-},\n$$\n半离散算子为\n$$\n\\left(\\mathcal{L}u\\right)_i = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}.\n$$\n\n您将比较三种限制器函数：\n- Minmod 限制器：\n$$\n\\phi_{\\text{minmod}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(1,\\,r\\right)\\right).\n$$\n- Superbee 限制器：\n$$\n\\phi_{\\text{superbee}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(2r,\\,1\\right),\\,\\min\\!\\left(r,\\,2\\right)\\right).\n$$\n- 单调中心（MC）限制器：\n$$\n\\phi_{\\text{MC}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(\\frac{1+r}{2},\\,2,\\,2r\\right)\\right).\n$$\n\n定义一个小的振幅正弦初始场\n$$\nu_i = A\\,\\sin\\!\\left(2\\pi\\,\\frac{m\\,i}{N}\\right),\n$$\n适用于周期性网格上的整数波数指数 $m$。令物理波数为\n$$\nk = \\frac{2\\pi m}{L}\\quad\\text{（单位：弧度/米）}.\n$$\n\n为了评估有效修正波数，计算 $u$ 和半离散算子 $\\mathcal{L}u$ 的离散傅里叶变换。设 $\\widehat{u}(k)$ 和 $\\widehat{\\mathcal{L}u}(k)$ 表示指数 $m$ 处的离散傅里叶系数。精确连续算子给出 $\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k) = -a\\, i\\, k$。使用此恒等式定义有效修正波数的数值估计：\n$$\nk_{\\text{eff}} = -\\frac{\\operatorname{Im}\\!\\left(\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)\\right)}{a}\\quad\\text{（单位：弧度/米）}.\n$$\n\n将空间算子的相位误差定义为 $k_{\\text{eff}}$ 相对于真实波数 $k$ 的相对偏差：\n$$\nE_{\\text{phase}} = \\frac{\\left|k_{\\text{eff}} - k\\right|}{k}\\quad\\text{（无量纲）}.\n$$\n\n对下面描述的一组测试用例，为每个限制器实现上述过程。对于每个测试用例，计算三个 $k_{\\text{eff}}$ 值（单位：弧度/米）以及具有最小相位误差的限制器的索引。使用以下索引约定：minmod 为 $0$，superbee 为 $1$，MC 为 $2$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个包含四个数字的子列表，顺序为 $[k_{\\text{eff,minmod}},k_{\\text{eff,superbee}},k_{\\text{eff,MC}},\\text{best}]$。其中 $k_{\\text{eff}}$ 值以弧度/米为单位，最佳限制器以整数表示。例如：“[[...,...,...,...],[...,...,...,...],...]”。\n\n使用以下测试套件，所有量均使用指定单位：\n- 案例 1：$N=512$，$L=1$ 米，$a=1$ 米/秒，$m=8$，$A=10^{-3}$。\n- 案例 2：$N=512$，$L=1$ 米，$a=1$ 米/秒，$m=1$，$A=10^{-6}$。\n- 案例 3：$N=512$，$L=1$ 米，$a=1$ 米/秒，$m=64$，$A=10^{-3}$。\n- 案例 4：$N=1024$，$L=1$ 米，$a=1$ 米/秒，$m=100$，$A=10^{-3}$。\n\n在您的离散化中确保强制执行周期性边界条件。您的程序必须是自包含的，不得读取任何输入，并且必须使用指定的运行时环境。所有 $k_{\\text{eff}}$ 值必须以弧度/米表示，最终输出必须遵循上述确切格式。",
            "solution": "所提出的问题是计算地球物理学领域中一个有效且适定的练习，特别是在守恒律数值方法的分析方面。它要求使用三种不同的总变差减小（TVD）通量限制器，实现并比较一种半离散的守恒律单调上游中心格式（MUSCL）。该分析基于修正波数的概念，这是一种量化有限差分或有限体积格式的数值色散和扩散误差的标准技术。所有参数和定义都已提供，该任务在科学上是合理的、客观的，并且在计算上是可行的。因此，我们可以着手提供完整的解决方案。\n\n问题的核心是评估一个数值格式对于单个傅里叶模式，近似空间导数算子的准确程度。一维线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n描述了标量 $u(x,t)$ 以恒定速度 $a$ 的输运过程。在傅里叶域中，空间导数算子 $\\frac{\\partial}{\\partial x}$ 对应于乘以 $i k$，其中 $k$ 是波数，$i = \\sqrt{-1}$。因此，方程空间部分 $-a \\frac{\\partial u}{\\partial x}$ 的傅里叶变换是 $-a(ik)\\widehat{u}(k)$。数值格式将近似这个运算，但会带有一些误差。该格式在傅里叶域中的作用可以用一个复数因子来描述，我们可以从中提取出该格式有效“看到”的有效或修正波数。\n\n问题指定了一个在均匀周期性网格上的半离散有限体积格式，该网格有 $N$ 个单元，宽度为 $\\Delta x = L/N$。单元平均值 $u_i$ 的变化率由数值通量 $F$ 的散度给出：\n$$\n\\frac{du_i}{dt} = \\left(\\mathcal{L}u\\right)_i = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}.\n$$\n在这里，使用 MUSCL-Hancock 方法可以实现二阶精度的空间离散。由于平流速度 $a$ 为正，我们只需要在界面 $x_{i+1/2}$ 的“左”侧重构状态，我们将其表示为 $u_{i+1/2}^{-}$。那么数值通量就是 $F_{i+1/2} = a u_{i+1/2}^{-}$。MUSCL 重构由以下公式给出：\n$$\nu_{i+1/2}^{-} = u_i + \\frac{1}{2}\\,\\phi(r_i)\\,(u_i - u_{i-1}).\n$$\n这个公式表示从单元中心 $x_i$ 到界面 $x_{i+1/2}$ 的线性插值，其中斜率取自上游侧 $(u_i - u_{i-1})$，并由一个通量限制器函数 $\\phi(r_i)$ 进行修正。限制器的目的是通过根据解的局部光滑度调整斜率来防止伪振荡（即保持 TVD），局部光滑度通过连续梯度的比率来衡量：\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i + \\varepsilon}.\n$$\n在零梯度区域，添加了一个小参数 $\\varepsilon$ 以防止除以零。我们将比较三种著名的通量限制器函数：\n1.  **Minmod**: $\\phi_{\\text{minmod}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(1,\\,r\\right)\\right)$。这是三者中耗散性最强的。\n2.  **Superbee**: $\\phi_{\\text{superbee}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(2r,\\,1\\right),\\,\\min\\!\\left(r,\\,2\\right)\\right)$。这是一个高压缩性限制器。\n3.  **单调中心 (MC)**: $\\phi_{\\text{MC}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(\\frac{1+r}{2},\\,2,\\,2r\\right)\\right)$。该限制器在耗散性和压缩性之间提供了平衡。\n\n为了分析该格式的特性，我们将离散算子 $\\mathcal{L}$ 应用于一个具有小振幅的单一正弦模式，$u_i = A\\,\\sin(k x_i)$，其中 $x_i = i\\Delta x$ 且 $k = 2\\pi m / L$。然后我们计算输入场 $u$ 和结果场 $\\mathcal{L}u$ 的离散傅里叶变换（DFT）。设 $\\widehat{u}(k)$ 和 $\\widehat{\\mathcal{L}u}(k)$ 是对应于波数指数 $m$ 的复数 DFT 系数。这些系数的比值 $Z(k) = \\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)$ 是离散算子 $\\mathcal{L}$ 对于此特定模式的传递函数。\n\n对于精确的连续算子，该比值为 $-aik$。对于数值算子，该比值将是一个复数，$Z(k) = -a(\\alpha_{\\text{num}}(k) + i k_{\\text{eff}}(k))$。实部 $\\alpha_{\\text{num}}$ 代表数值扩散（振幅误差），虚部 $k_{\\text{eff}}$ 是决定数值解相速度的有效或修正波数。$k_{\\text{eff}}$ 与真实波数 $k$ 的偏差会导致数值色散（相位误差）。根据问题的定义，我们按如下方式估计有效波数：\n$$\nk_{\\text{eff}} = -\\frac{\\operatorname{Im}\\!\\left(\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)\\right)}{a}.\n$$\n相位误差随后通过与真实波数的相对偏差来量化：\n$$\nE_{\\text{phase}} = \\frac{\\left|k_{\\text{eff}} - k\\right|}{k}.\n$$\n\n每个测试用例的总体算法如下：\n1.  初始化网格参数（$N$, $L$, $\\Delta x$）和物理参数（$a$, $m$, $A$）。\n2.  生成离散的初始正弦波场 $u$。\n3.  对于三种指定的限制器函数中的每一种：\n    a. 根据 $u$ 计算光滑度比向量 $r$，确保为模板点 $u_{i-1}$ 和 $u_{i+1}$ 处理周期性边界条件。这可以通过数组滚动操作方便地实现。\n    b. 逐元素应用限制器函数 $\\phi(r)$。\n    c. 组装 MUSCL 左态重构 $u_{i+1/2}^{-}$ 和通量 $F_{i+1/2}$。\n    d. 使用通量散度计算半离散算子向量 $\\mathcal{L}u$，同样使用周期性边界条件。\n    e. 计算 $u$ 和 $\\mathcal{L}u$ 的 DFT，以获得系数 $\\widehat{u}[m]$ 和 $\\widehat{\\mathcal{L}u}[m]$。\n    f. 计算 $k_{\\text{eff}}$ 和相应的 $E_{\\text{phase}}$。\n4.  比较三个相位误差值，并确定产生最小误差的限制器的索引（minmod 为 $0$，superbee 为 $1$，MC 为 $2$）。\n5.  将三个 $k_{\\text{f}}$ 值和最佳限制器的索引收集到该测试用例的结果列表中。\n\n对所有测试用例重复此过程，将提供所选数值格式色散特性的定量比较。较小的相位误差表明该格式能更好地以正确的相速度传播特定波数的波。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi_minmod(r):\n    \"\"\"Minmod flux limiter function.\"\"\"\n    return np.maximum(0, np.minimum(1, r))\n\ndef phi_superbee(r):\n    \"\"\"Superbee flux limiter function.\n    \n    Formula: max(0, min(2r, 1), min(r, 2))\n    \"\"\"\n    term2 = np.minimum(2 * r, 1)\n    term3 = np.minimum(r, 2)\n    # Implement max of three arguments using nested binary max\n    return np.maximum(0, np.maximum(term2, term3))\n\ndef phi_mc(r):\n    \"\"\"Monotonized Central (MC) flux limiter function.\n    \n    Formula: max(0, min((1+r)/2, 2, 2r))\n    \"\"\"\n    # Safely implement min of three arguments using nested binary min\n    min_val = np.minimum((1 + r) / 2.0, 2.0)\n    min_val = np.minimum(min_val, 2 * r)\n    return np.maximum(0, min_val)\n\ndef apply_op_L(u, a, dx, limiter_func):\n    \"\"\"\n    Applies the semi-discrete MUSCL operator L to a field u.\n    \"\"\"\n    N = len(u)\n    # Small constant to prevent division by zero in the smoothness ratio r.\n    epsilon = 1e-15 \n\n    # Use np.roll to efficiently handle periodic boundary conditions.\n    u_prev = np.roll(u, 1)\n    u_next = np.roll(u, -1)\n\n    # Numerator of r_i: u_i - u_{i-1}\n    du_backward = u - u_prev\n    # Denominator of r_i: u_{i+1} - u_i\n    du_forward = u_next - u\n\n    # Calculate the smoothness ratio r_i vector.\n    # The small epsilon handles cases where du_forward is near zero.\n    r = du_backward / (du_forward + epsilon)\n\n    # Apply the chosen flux limiter function.\n    phi_r = limiter_func(r)\n\n    # Compute the left state at interface i+1/2 using MUSCL reconstruction.\n    # u_{i+1/2}^- = u_i + 0.5 * phi(r_i) * (u_i - u_{i-1})\n    u_left = u + 0.5 * phi_r * du_backward\n\n    # For a>0, the numerical flux is F_{i+1/2} = a * u_{i+1/2}^-.\n    F_iph = a * u_left\n\n    # Get the flux at interface i-1/2 by rolling the flux array.\n    F_imh = np.roll(F_iph, 1)\n\n    # Compute the semi-discrete operator (Lu)_i = -(F_{i+1/2} - F_{i-1/2}) / dx.\n    Lu = -(F_iph - F_imh) / dx\n    \n    return Lu\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, L, a, m, A)\n        (512, 1.0, 1.0, 8, 1e-3),\n        (512, 1.0, 1.0, 1, 1e-6),\n        (512, 1.0, 1.0, 64, 1e-3),\n        (1024, 1.0, 1.0, 100, 1e-3),\n    ]\n\n    limiters = [phi_minmod, phi_superbee, phi_mc]\n\n    all_results = []\n\n    for N, L, a, m, A in test_cases:\n        dx = L / N\n        \n        # Create the initial sinusoidal field u_i = A*sin(2*pi*m*i/N).\n        i_indices = np.arange(N)\n        u = A * np.sin(2 * np.pi * m * i_indices / N)\n\n        # Calculate the true physical wavenumber k.\n        k_true = 2 * np.pi * m / L\n\n        k_effs = []\n        phase_errors = []\n\n        # Compute the DFT of the initial condition. We only need this once.\n        u_hat = np.fft.fft(u)\n        \n        # Check if the spectral amplitude is non-zero to avoid division by zero.\n        if np.abs(u_hat[m])  1e-15:\n            # This case should not happen with the given initial condition.\n            # Handle gracefully if it does.\n            raise ValueError(f\"Zero amplitude at wavenumber m={m}\")\n\n        for limiter_func in limiters:\n            # Apply the semi-discrete operator L to the field u.\n            Lu = apply_op_L(u, a, dx, limiter_func)\n            \n            # Compute the DFT of the resulting field Lu.\n            Lu_hat = np.fft.fft(Lu)\n            \n            # Calculate the complex ratio Z(k) = Lu_hat[m] / u_hat[m].\n            ratio = Lu_hat[m] / u_hat[m]\n            \n            # Estimate the effective modified wavenumber k_eff = -Im(Z(k)) / a.\n            k_eff = -np.imag(ratio) / a\n            k_effs.append(k_eff)\n            \n            # Calculate the phase error.\n            phase_error = np.abs(k_eff - k_true) / k_true if k_true != 0 else np.abs(k_eff)\n            phase_errors.append(phase_error)\n\n        # Find the index of the limiter with the smallest phase error.\n        best_limiter_index = int(np.argmin(phase_errors))\n\n        # Assemble the results [k_eff_minmod, k_eff_superbee, k_eff_mc, best_idx].\n        case_result = k_effs + [best_limiter_index]\n        all_results.append(case_result)\n\n    # Format the final output string as specified: [[...],[...],...]\n    def format_list(lst):\n        # Format a single list of numbers into a string \"[v1,v2,v3,...]\".\n        return f\"[{','.join(f'{v:.15g}' if not isinstance(v, int) else str(v) for v in lst)}]\"\n\n    final_output = f\"[{','.join(map(format_list, all_results))}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "数值误差分析的原理不仅限于平流方程。本练习将这些概念应用于具有物理频散特性的欧拉-伯努利（Euler-Bernoulli）梁方程，这是一个模拟弯曲波的模型。你的任务是评估不同的数值格式在多大程度上能准确捕捉系统的真实本征频率——这是模拟许多地球物理波动现象的关键环节，并探索如何使用滤波器来控制高频模式的数值误差 。",
            "id": "3581957",
            "problem": "您需要使用一维欧拉-伯努利弯曲波模型构建一个色散简正模的计算基准。在计算地球物理学中，该模型是岩石圈弯曲和其他薄板现象的标准替代模型。目标是通过将离散模式的本征频率与薄弹性梁的精确解析值进行比较，来量化和控制数值色散与数值耗散。\n\n考虑由线性欧拉-伯努利梁方程控制的初边值问题\n$$\nu_{tt}(x,t) + c_b^2\\,u_{xxxx}(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\n其边界条件为简支边界条件\n$$\nu(0,t) = 0,\\quad u(L,t) = 0,\\quad u_{xx}(0,t) = 0,\\quad u_{xx}(L,t) = 0.\n$$\n这里，$u(x,t)$ 是横向位移，$L$ 是梁的长度，$c_b$ 是弯曲波速参数，单位为 $\\mathrm{m^2/s}$，因此角频率的单位是 $\\mathrm{rad/s}$。简正模解的拟设 $u(x,t) = \\phi_n(x)\\cos(\\omega_n t)$ 产生了以下特征值问题\n$$\n\\phi_n^{(4)}(x) = \\kappa_n^4\\,\\phi_n(x),\\quad \\phi_n(0) = 0,\\ \\phi_n(L)=0,\\ \\phi_n''(0)=0,\\ \\phi_n''(L)=0,\n$$\n其精确特征函数为 $\\phi_n(x) = \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)$，对应的精确波数为 $k_n = \\frac{n\\pi}{L}$，其中 $n\\ge 1$ 为整数模。精确角本征频率为\n$$\n\\omega_n^{\\mathrm{exact}} = c_b\\,k_n^2 = c_b\\,\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\n\n使用 $N$ 个内部点和均匀间距 $h = \\frac{L}{N+1}$ 对空间域进行离散化，并在端点处强制执行狄利克雷边界值 $u(0,t)=u(L,t)=0$。考虑在内部网格上对二阶导数算子 $u_{xx}$ 的两种有限差分格式，两者都表示为作用于内部值向量的对称托普利兹矩阵，并隐式地在内部模板之外使用边界值 $u=0$：\n\n- 二阶精确三点模板，系数为 $\\frac{1}{h^2}\\{1,-2,1\\}$，偏移量为 $\\{-1,0,1\\}$。\n- 四阶精确五点模板，系数为 $\\frac{1}{h^2}\\left\\{-\\frac{1}{12},\\frac{4}{3},-\\frac{5}{2},\\frac{4}{3},-\\frac{1}{12}\\right\\}$，偏移量为 $\\{-2,-1,0,1,2\\}$。\n\n令 $\\theta_n = \\frac{n\\pi}{N+1}$。对于离散正弦特征向量 $v^{(n)}_j = \\sin(j\\theta_n)$（其中 $j=1,\\dots,N$），这些托普利兹模板对应的离散二阶导数特征值为\n$$\n\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2} = -\\frac{4\\sin^2(\\theta/2)}{h^2},\n$$\n和\n$$\n\\lambda^{(4)}(\\theta) = \\frac{-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)}{h^2}.\n$$\n离散四阶导数特征值由 $\\mu(\\theta) = \\left(\\lambda(\\theta)\\right)^2$ 建模，相应的半离散角频率满足\n$$\n\\omega_n^{\\mathrm{num}} = c_b\\,\\left|\\lambda(\\theta_n)\\right|.\n$$\n\n为了探索对数值色散和耗散的控制，通过一个尺度选择性平滑（滤波器）来增强空间算子，该滤波器减少高波数分量，以模态形式表示为乘性衰减\n$$\n\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma\\,\\varphi(\\theta)\\right)\\lambda(\\theta),\\quad \\varphi(\\theta) = \\sin^6\\!\\left(\\frac{\\theta}{2}\\right),\n$$\n其中滤波器强度 $\\sigma\\in[0,1]$。这模仿了谱消失粘性，主要作用于网格奈奎斯特波数附近。经过滤波的离散频率模型为\n$$\n\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b\\,\\left|\\lambda_{\\sigma}(\\theta_n)\\right|.\n$$\n\n对于每个测试配置和模式索引集 $\\mathcal{M}$，定义模式 $n\\in \\mathcal{M}$ 的相对误差为\n$$\n\\varepsilon_n = \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}},\n$$\n如果 $\\max_{n\\in\\mathcal{M}} \\varepsilon_n \\le \\mathrm{tol}$，则声明该配置通过测试。\n\n您的任务是编写一个完整的程序，该程序：\n- 实现二阶和四阶离散二阶导数特征值 $\\lambda^{(2)}(\\theta)$ 和 $\\lambda^{(4)}(\\theta)$。\n- 使用上述公式为指定的模式 $n$ 计算精确和数值角本征频率，可选滤波器强度为 $\\sigma$。\n- 通过比较测试集中所有模式的相对误差，为给定的容差评估通过/失败的布尔值。\n\n物理单位要求：将 $L$ 解释为 $\\mathrm{m}$，将 $c_b$ 解释为 $\\mathrm{m^2/s}$，将角频率解释为 $\\mathrm{rad/s}$。然而，程序的最终输出是布尔值，它们是无量纲的。\n\n测试套件：\n为以下参数集提供结果，涵盖精度阶数效应、网格分辨率影响和滤波器影响。对于每种情况，模式集由一个正整数列表给出；该列表上的最大相对误差与容差进行比较。\n\n- 情况 1：$L=1.0$, $c_b=1.0$, $N=63$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=2\\times 10^{-3}$。\n- 情况 2：$L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=1\\times 10^{-2}$。\n- 情况 3：$L=1.0$, $c_b=1.0$, $N=47$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=3\\times 10^{-3}$。\n- 情况 4：$L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.2$, modes $\\mathcal{M}=[10,12,14]$, tolerance $\\mathrm{tol}=7\\times 10^{-2}$。\n- 情况 5：$L=1.0$, $c_b=1.0$, $N=127$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3]$, tolerance $\\mathrm{tol}=1\\times 10^{-3}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，按上述顺序排列，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$，其中每个 $\\mathrm{result}_i$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。程序不得读取任何输入，并且必须在内部计算这些结果。",
            "solution": "该问题陈述已经过仔细验证，并被确定为是合理的。它在科学上基于固体力学和数值分析的原理，特别是使用欧拉-伯努利梁方程作为弯曲波的模型，并分析有限差分格式的性质。该问题是适定的，提供了所有必要的方程、参数，并为每个测试用例设定了明确的目标。语言精确无歧义。因此，下面提供了一个完整的解决方案。\n\n这个问题的核心在于比较连续物理系统的解析色散关系与其离散近似的数值色散关系。\n\n该物理系统是一维弹性梁，其横向位移 $u(x,t)$ 由欧拉-伯努利方程控制：\n$$\n\\frac{\\partial^2 u}{\\partial t^2} + c_b^2 \\frac{\\partial^4 u}{\\partial x^4} = 0\n$$\n这里，$c_b$ 是弯曲波速参数。对于定义域 $x \\in [0, L]$ 上的简支边界条件，解可以表示为简正模的叠加。拟设 $u(x,t) = \\phi_n(x) \\cos(\\omega_n t)$ 将问题分离为一个关于模态形状 $\\phi_n(x)$ 及其相应角本征频率 $\\omega_n$ 的空间特征值问题。精确的模态形状为 $\\phi_n(x) = \\sin(k_n x)$，其波数为 $k_n = n\\pi/L$，其中 $n \\ge 1$ 为整数模。将此代入控制方程，得到精确的色散关系：\n$$\n\\omega_n^{\\mathrm{exact}} = c_b k_n^2 = c_b \\left(\\frac{n\\pi}{L}\\right)^2\n$$\n这种关系是色散的，意味着相速度 $v_p = \\omega_n/k_n = c_b k_n$ 取决于波数，因此不同长度的波以不同的速度传播。\n\n当空间域用 $N$ 个内部点和间距 $h = L/(N+1)$ 进行离散化时，连续导数被有限差分算子所取代。对于指定的简支边界条件，所得离散算子的特征向量是离散正弦函数 $v_j^{(n)} = \\sin(j \\theta_n)$，其中 $j=1,\\dots,N$ 是网格点索引，$\\theta_n = n\\pi/(N+1) = k_n h$ 是无量纲波数。\n\n该分析的关键步骤是，将有限差分算子应用于离散正弦特征向量，等效于将该特征向量乘以一个标量特征值。对于二阶导数算子，该标量记为 $\\lambda(\\theta_n)$，是无量纲波数 $\\theta_n$ 的函数。连续二阶导数算子 $\\frac{\\partial^2}{\\partial x^2}$ 的特征值为 $-k_n^2$。有限差分格式的精度取决于其特征值 $\\lambda(\\theta_n)$ 对 $-k_n^2 = -(\\theta_n/h)^2$ 的近似程度。\n\n问题指定了两种二阶导数格式：\n1.  二阶精确格式，其特征值为 $\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2}$。\n2.  四阶精确格式，其特征值为 $\\lambda^{(4)}(\\theta) = \\frac{1}{h^2}\\left(-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)\\right)$。\n\n问题将四阶导数算子建模为二阶导数算子的平方。因此，半离散控制方程通过将解析的 $k_n^2$ 替换为其数值对应物（实际上是 $-\\lambda(\\theta_n)$）来导出数值色散关系。因此，数值频率计算如下：\n$$\n\\omega_n^{\\mathrm{num}} = c_b \\left|-\\lambda(\\theta_n)\\right| = c_b \\left|\\lambda(\\theta_n)\\right|\n$$\n使用绝对值是因为所提供的特征值 $\\lambda(\\theta_n)$ 是非正的。$\\omega_n^{\\mathrm{num}}$ 与 $\\omega_n^{\\mathrm{exact}}$ 的偏差称为数值色散。\n\n为了控制高频数值伪影，引入了一个谱滤波器。该滤波器通过乘法修改算子的特征值：\n$$\n\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma\\,\\varphi(\\theta)\\right)\\lambda(\\theta)\n$$\n其中 $\\sigma$ 是滤波器强度，$\\varphi(\\theta) = \\sin^6(\\theta/2)$ 是一个选择性地针对高波数（即 $\\theta$ 接近 $\\pi$）的函数。这个附加项引入了数值耗散，从而衰减高频分量。滤波后的数值频率则为：\n$$\n\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b \\left|\\lambda_{\\sigma}(\\theta_n)\\right|\n$$\n流程是为每个测试配置评估指定模式集 $\\mathcal{M}$ 上的最大相对误差：\n$$\n\\varepsilon_{\\mathrm{max}} = \\max_{n\\in\\mathcal{M}} \\left( \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}} \\right)\n$$\n如果该最大误差不超过给定的容差 $\\mathrm{tol}$，则该配置被声明为“通过”（$\\mathrm{True}$），否则为“失败”（$\\mathrm{False}$）。实现将系统地将这些公式应用于每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational benchmark problem for dispersive normal modes.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 63, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 2e-3, \"case_id\": 1\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 1e-2, \"case_id\": 2\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 47, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 3e-3, \"case_id\": 3\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.2,\n            \"modes\": [10, 12, 14], \"tol\": 7e-2, \"case_id\": 4\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 127, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3], \"tol\": 1e-3, \"case_id\": 5\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        cb = case[\"cb\"]\n        N = case[\"N\"]\n        scheme = case[\"scheme\"]\n        sigma = case[\"sigma\"]\n        modes = case[\"modes\"]\n        tol = case[\"tol\"]\n\n        h = L / (N + 1)\n        \n        max_relative_error = 0.0\n\n        for n in modes:\n            # Calculate the exact angular eigenfrequency\n            kn = n * np.pi / L\n            omega_exact = cb * kn**2\n\n            # Calculate the dimensionless wavenumber\n            theta_n = n * np.pi / (N + 1)\n\n            # Calculate the unfiltered discrete second-derivative eigenvalue\n            if scheme == \"second-order\":\n                lambda_theta = (-2.0 + 2.0 * np.cos(theta_n)) / h**2\n            elif scheme == \"fourth-order\":\n                lambda_theta = (\n                    -2.5 + (8.0/3.0) * np.cos(theta_n) - (1.0/6.0) * np.cos(2.0 * theta_n)\n                ) / h**2\n            else:\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n\n            # Apply the filter if sigma is non-zero\n            if sigma > 0:\n                phi_theta = np.sin(theta_n / 2.0)**6\n                lambda_sigma_theta = (1.0 - sigma * phi_theta) * lambda_theta\n            else:\n                lambda_sigma_theta = lambda_theta\n            \n            # Calculate the numerical angular eigenfrequency\n            omega_num = cb * np.abs(lambda_sigma_theta)\n\n            # Calculate the relative error for the current mode\n            if omega_exact == 0:\n                relative_error = np.abs(omega_num)\n            else:\n                relative_error = np.abs(omega_num - omega_exact) / omega_exact\n            \n            if relative_error > max_relative_error:\n                max_relative_error = relative_error\n\n        # Check if the configuration passes the tolerance test\n        pass_fail = max_relative_error = tol\n        results.append(pass_fail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}