{
    "hands_on_practices": [
        {
            "introduction": "掌握地震后形变建模的第一步是精确求解控制粘弹性松弛的本构方程。本练习将重点介绍作为地幔和下地壳流变学一阶近似的麦克斯韦（Maxwell）模型。通过从头推导并利用高效的谱方法求解应力松弛的常微分方程，您将不仅能加深对基本物理过程的理解，还能掌握一种在计算地球物理学中用于实现高精度解的强大数值技术。",
            "id": "3613099",
            "problem": "考虑一个均匀 Maxwell 杆在一维粘弹性应力松弛作用下，于时间 $t=0$ 时受到一个施加的阶跃应变。在震后形变模拟中，Maxwell 本构模型将弹性弹簧和粘性阻尼器串联起来，这与同震应力变化后下地壳和上地幔的流变学性质相关。令 $E$ 表示弹性模量（单位为帕斯卡），$\\eta$ 表示粘度（单位为帕斯卡-秒），$\\varepsilon(t)$ 表示总应变。将应力定义为 $\\sigma(t)$，它在一维杆中空间上是均匀的，并根据标准 Maxwell 模型随时间演化。已知阶跃应变后应力松弛的精确解随时间呈指数形式，您应使用此解来验证数值精度；在您的实现中不要假定任何简化公式。\n\n仅从串联 Maxwell 元件的线性粘弹性基本定义和定律出发，推导在施加阶跃应变 $\\varepsilon(t)=\\varepsilon_0 H(t)$（其中 $H(t)$ 是 Heaviside 阶跃函数，$\\varepsilon_0$ 是一个常数）下 $\\sigma(t)$ 的控制常微分方程。然后，在闭区间 $[0,T]$ 上使用 Chebyshev-Gauss-Lobatto (CGL) 点实现一个全局谱配置法，以求解得到的关于 $\\sigma(t)$ 的初值问题，其中 $T>0$ 是一个以秒为单位的固定最终时间。使用 Chebyshev 微分矩阵来近似时间导数，并使用 tau-强制行替换方法在 $t=0$ 处施加初始条件，从而使配置解在 $t=0$ 节点上精确满足初始应力。使用仿射变换将 CGL 点从 $[-1,1]$ 映射到 $[0,T]$，并为配置点上的应力值组装并求解得到的线性系统。\n\n科学和数值要求：\n- 从串联的弹性弹簧和粘性阻尼器的本构律推导 Maxwell 常微分方程。所有公式都用 $E$、$\\eta$、$\\varepsilon(t)$ 和 $\\sigma(t)$ 表示。\n- 构建 Chebyshev-Gauss-Lobatto 节点 $x_k=\\cos\\left(\\frac{\\pi k}{N-1}\\right)$（其中 $k=0,1,\\dots,N-1$），通过 $t_k = \\frac{T}{2}(x_k+1)$ 将它们映射到时间 $t_k \\in [0,T]$，并建立在 $[-1,1]$ 上的一阶 Chebyshev 微分矩阵 $D$，该矩阵具有以下性质：对于 $i\\neq j$，$D_{ij}$ 与 CGL 节点上 Lagrange 插值多项式的精确导数值一致。使用仿射缩放得到时间微分矩阵 $\\frac{2}{T}D$。\n- 为配置未知数 $\\sigma(t_k)$ 构成线性系统，并通过将系统中对应于 $t=0$ 的行替换为单位行，并将右侧设置为指定的初始应力来施加初始条件 $\\sigma(0)$。\n- 通过计算 CGL 节点上的最大范数误差，将数值解与指数形式的精确解进行对比验证，\n$$\ne_\\infty(N) = \\max_{k} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|,\n$$\n其中应力单位为帕斯卡。",
            "solution": "该问题要求推导并数值求解一维 Maxwell 粘弹性材料在阶跃应变下的应力松弛方程。这将通过全局谱配置法来完成。\n\n### 1. 控制方程和精确解的推导\n\nMaxwell 元件由一个纯弹性弹簧和一个纯粘性阻尼器串联而成。在施加的应力 $\\sigma(t)$ 下，两个元件承受相同的应力，总应变 $\\varepsilon(t)$ 是弹性应变 $\\varepsilon_e(t)$ 和粘性应变 $\\varepsilon_v(t)$ 之和。\n\n本构关系如下：\n1.  总应变之和：$\\varepsilon(t) = \\varepsilon_e(t) + \\varepsilon_v(t)$\n2.  弹簧的 Hooke 定律：$\\sigma(t) = E \\varepsilon_e(t)$，其中 $E$ 是弹性模量。\n3.  阻尼器的 Newton 定律：$\\sigma(t) = \\eta \\dot{\\varepsilon}_v(t)$，其中 $\\eta$ 是粘度，$\\dot{\\varepsilon}_v$ 是粘性应变率。\n\n为了推导 $\\sigma(t)$ 的控制常微分方程(ODE)，我们对总应变方程关于时间 $t$ 求导：\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{d\\varepsilon_e}{dt} + \\frac{d\\varepsilon_v}{dt}\n$$\n根据本构律，我们可以用应力 $\\sigma(t)$ 表示应变率：\n-   $\\dot{\\varepsilon}_e(t) = \\frac{1}{E} \\frac{d\\sigma}{dt}$\n-   $\\dot{\\varepsilon}_v(t) = \\frac{1}{\\eta} \\sigma(t)$\n\n将这些代入微分后的应变方程，得到 Maxwell 模型的微分形式：\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t)\n$$\n该方程将总应变率 $\\dot{\\varepsilon}(t)$ 与应力 $\\sigma(t)$ 及其变化率 $\\dot{\\sigma}(t)$ 联系起来。\n\n问题指定了施加的阶跃应变 $\\varepsilon(t) = \\varepsilon_0 H(t)$，其中 $\\varepsilon_0$ 是一个恒定的应变大小，$H(t)$ 是 Heaviside 阶跃函数。在阶跃发生的瞬间 $t=0$，应变被瞬时施加。粘性阻尼器不能瞬时响应，因此初始粘性应变 $\\varepsilon_v(0^+) = 0$。因此，所有初始应变都以弹性方式存储：$\\varepsilon_e(0^+) = \\varepsilon_0$。这导致了一个初始应力：\n$$\n\\sigma(0) = \\sigma(0^+) = E \\varepsilon_e(0^+) = E\\varepsilon_0\n$$\n对于所有时间 $t > 0$，应变是恒定的，$\\varepsilon(t) = \\varepsilon_0$，因此其时间导数为零，$\\dot{\\varepsilon}(t) = 0$。对于 $t>0$ 的控制常微分方程简化为：\n$$\n0 = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t) \\quad \\implies \\quad \\frac{d\\sigma}{dt} + \\frac{E}{\\eta} \\sigma(t) = 0\n$$\n这是一个一阶线性齐次常微分方程。我们定义 Maxwell 松弛时间为 $\\tau = \\eta/E$。应力松弛的常微分方程则为：\n$$\n\\frac{d\\sigma}{dt} + \\frac{1}{\\tau} \\sigma(t) = 0, \\quad \\text{with initial condition} \\quad \\sigma(0) = E\\varepsilon_0\n$$\n这个初值问题的精确解可以通过分离变量法或使用指数衰减的标准解得到：\n$$\n\\sigma_{\\text{exact}}(t) = \\sigma(0) \\exp\\left(-\\frac{t}{\\tau}\\right) = E\\varepsilon_0 \\exp\\left(-\\frac{E}{\\eta}t\\right)\n$$\n这个解析解将用于验证数值方法的精度。\n\n### 2. 数值方法：谱配置法\n\n我们在时间区间 $[0, T]$ 上使用全局谱配置法求解该初值问题。\n\n**离散化：** 区域 $[0, T]$ 使用 $N$ 个 Chebyshev-Gauss-Lobatto (CGL) 点进行离散化。CGL 节点在标准区间 $[-1, 1]$ 上定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$，其中 $j=0, 1, \\dots, N-1$。这些节点不是单调排序的。为方便起见，我们重新索引它们，使其从 $-1$ 跑到 $1$：$x'_j = -\\cos\\left(\\frac{\\pi j}{N-1}\\right)$，其中 $j=0, \\dots, N-1$。这得到 $x'_0 = -1, \\dots, x'_{N-1} = 1$。然后我们使用仿射变换将这些节点映射到时域 $[0, T]$：\n$$\nt_j = \\frac{T}{2}(x'_j + 1)\n$$\n这确保了 $t_0=0$ 和 $t_{N-1}=T$，提供了一组单调递增的时间点。\n\n**Chebyshev 微分矩阵：** 谱方法的核心是微分矩阵 $D$，它近似一个由其在 CGL 节点上的值所表示的函数的导数。对于 CGL 节点 $x_j$（按许多常规定义从 $1$ 到 $-1$ 排序），$N \\times N$ 矩阵 $D$ 的元素为：\n$$\nD_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j} \\quad \\text{for } i \\neq j\n$$\n$$\nD_{ii} = -\\sum_{j \\neq i} D_{ij}\n$$\n其中权重为 $c_0=c_{N-1}=2$ 和 $c_i=1$（对于 $1 \\le i \\le N-2$）。在 $[-1, 1]$ 上的函数向量 $\\vec{f}$ 的导数则通过矩阵-向量乘积 $D\\vec{f}$ 来近似。对于时域 $[0,T]$，微分算子被缩放：$\\mathcal{D}_t = \\frac{2}{T}D$。我们的实现将对 $D$ 使用从 $1$ 到 $-1$ 的常规节点排序，并映射到从 $T$ 到 $0$ 的时间点。\n\n**线性系统构建：** 我们寻求在时间节点 $\\vec{t} = [t_0, t_1, \\dots, t_{N-1}]^T$ 上的数值解 $\\vec{\\sigma} = [\\sigma_0, \\sigma_1, \\dots, \\sigma_{N-1}]^T$。在 $N$ 个时间节点上对 ODE $\\dot{\\sigma} + \\frac{1}{\\tau}\\sigma = 0$ 进行配置，得到以下系统：\n$$\n\\left(\\frac{2}{T}D\\right)\\vec{\\sigma} + \\frac{1}{\\tau}I\\vec{\\sigma} = \\vec{0}\n$$\n其中 $I$ 是 $N \\times N$ 的单位矩阵。这可以写成一个线性系统 $L\\vec{\\sigma} = \\vec{0}$，其中算子矩阵为 $L = \\frac{2}{T}D + \\frac{1}{\\tau}I$。\n\n**初始条件施加：** 系统 $L\\vec{\\sigma} = \\vec{0}$ 是齐次的，需要一个边界条件才能获得唯一解。初始条件为 $\\sigma(0) = E\\varepsilon_0$。在我们的节点排序中，时间 $t=0$ 对应于最后一个节点 $t_{N-1}=0$（因为 $x_{N-1}=-1$）。我们通过行替换的 tau 方法来施加此条件。矩阵 $L$ 的最后一行和右端向量 $\\vec{b}$（初始全为零）被修改。$L$ 的最后一行被替换为一个“单位行” $[0, 0, \\dots, 1]$，而 $\\vec{b}$ 的最后一个元素被设置为初始应力值 $E\\varepsilon_0$。修改后的系统 $L'\\vec{\\sigma} = \\vec{b}$ 为：\n- $L'_{ij} = L_{ij}$ for $i=0, \\dots, N-2$.\n- $L'_{N-1, j} = 0$ for $j=0, \\dots, N-2$ and $L'_{N-1, N-1} = 1$.\n- $b_i = 0$ for $i=0, \\dots, N-2$ and $b_{N-1} = E\\varepsilon_0$.\n\n然后求解这个非奇异线性系统以得到未知的应力向量 $\\vec{\\sigma}$。\n\n### 3. 误差分析\n数值解 $\\sigma_{\\text{num}}(t_k)$ 在配置节点上与精确解 $\\sigma_{\\text{exact}}(t_k)$ 进行验证。精度由最大范数误差量化：\n$$\ne_\\infty(N) = \\max_{k=0,\\dots,N-1} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|\n$$\n对于应用于光滑解析函数的谱方法，误差预期会随 $N$呈指数衰减，即 $e_\\infty(N) \\propto a^N$，其中基底 $a \\in (0,1)$。我们使用来自两个离散化 $N_1=32$ 和 $N_2=64$ 的误差来估计这个基底因子：\n$$\na \\approx \\left(\\frac{e_\\infty(N_2)}{e_\\infty(N_1)}\\right)^{\\frac{1}{N_2 - N_1}}\n$$\n这个因子量化了谱收敛的速率。$a$ 值越小，表示收敛越快。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix for N CGL nodes.\n    \n    Args:\n        N (int): The number of collocation points (polynomial degree N-1).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (N, N) differentiation matrix.\n            - x (np.ndarray): The (N,) array of CGL nodes from 1 down to -1.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.]]), np.array([0.])\n    \n    # CGL nodes x_j = cos(j*pi/(N-1)) for j=0..N-1\n    # This creates nodes ordered from 1 down to -1.\n    j = np.arange(N)\n    x = np.cos(j * np.pi / (N - 1))\n    \n    # c_j factors\n    c = np.ones(N)\n    c[0] = 2.\n    c[N-1] = 2.\n    \n    # Compute off-diagonal entries\n    D = np.zeros((N, N))\n    x_diff = x[:, np.newaxis] - x[np.newaxis, :]\n    np.fill_diagonal(x_diff, 1.) # Avoid division by zero on diagonal\n    \n    c_ratio = c[:, np.newaxis] / c[np.newaxis, :]\n    \n    indices = np.arange(N)\n    sign = (-1)**(indices[:, np.newaxis] + indices[np.newaxis, :])\n    \n    D = c_ratio * sign / x_diff\n    \n    # Compute diagonal entries using sum rule\n    np.fill_diagonal(D, 0.)\n    D -= np.diag(np.sum(D, axis=1))\n    \n    return D, x\n\ndef solve_maxwell_spectral(E, eta, eps0, T, N_list):\n    \"\"\"\n    Solves the Maxwell stress relaxation problem using a spectral method.\n\n    Args:\n        E (float): Elastic modulus (Pa).\n        eta (float): Viscosity (Pa.s).\n        eps0 (float): Strain magnitude (dimensionless).\n        T (float): Final time (s).\n        N_list (list[int]): List of discretization sizes to evaluate.\n\n    Returns:\n        list[float]: A list containing max-norm errors for each N in N_list,\n                     followed by the empirical convergence factor 'a'.\n    \"\"\"\n    results_for_case = []\n    errors = {}\n    \n    tau = eta / E  # Maxwell relaxation time\n    sigma0 = E * eps0  # Initial stress at t=0\n\n    for N in N_list:\n        # 1. Get differentiation matrix D and nodes x in [-1, 1]\n        D_cheb, x_cheb = chebyshev_diff_matrix(N)\n        \n        # 2. Map nodes to time domain [0, T]. x_cheb runs 1 to -1, so t runs T to 0.\n        t_nodes = 0.5 * T * (x_cheb + 1)\n        \n        # 3. Form the linear operator matrix L\n        # ODE: d(sigma)/dt + (1/tau)*sigma = 0\n        # Time derivative operator on [0, T] is (2/T)*D_cheb\n        L = (2.0 / T) * D_cheb + (1.0 / tau) * np.identity(N)\n        \n        # 4. Set up RHS vector and apply initial condition via tau-enforcement\n        # The initial condition is at t=0, which is the last node (index N-1)\n        # where x = -1. We replace the last row of the system.\n        b = np.zeros(N)\n        \n        L[N-1, :] = 0.0\n        L[N-1, N-1] = 1.0\n        b[N-1] = sigma0\n        \n        # 5. Solve the linear system L * sigma_vec = b\n        sigma_num = np.linalg.solve(L, b)\n        \n        # 6. Compute exact solution for comparison\n        sigma_exact = sigma0 * np.exp(-t_nodes / tau)\n        \n        # 7. Compute max-norm error\n        e_inf = np.max(np.abs(sigma_num - sigma_exact))\n        errors[N] = e_inf\n        results_for_case.append(e_inf)\n        \n    # 8. Compute empirical convergence factor 'a'\n    e_inf_n1 = errors[32]\n    e_inf_n2 = errors[64]\n    \n    if e_inf_n1 > 0 and e_inf_n2 > 0:\n        a = (e_inf_n2 / e_inf_n1)**(1.0 / (64 - 32))\n    else:\n        # Convergence is faster than machine precision can resolve\n        a = 0.0 \n        \n    results_for_case.append(a)\n    \n    return results_for_case\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path\n        {'E': 3.0e10, 'eta': 3.0e18, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case B: fast relaxation\n        {'E': 3.0e10, 'eta': 3.0e16, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case C: slow relaxation\n        {'E': 3.0e10, 'eta': 3.0e20, 'eps0': 1.0e-5, 'T': 1.0e7},\n    ]\n    N_list = [8, 16, 32, 64]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = solve_maxwell_spectral(\n            case_params['E'], case_params['eta'], case_params['eps0'],\n            case_params['T'], N_list\n        )\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    inner_lists_str = []\n    for case_result in all_results:\n        # Format each inner list: [val1,val2,val3]\n        inner_str = f\"[{','.join(map(str, case_result))}]\"\n        inner_lists_str.append(inner_str)\n    \n    # Combine the inner lists into the final outer list format: [[...],[...]]\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在地球物理反演中，我们选择的数学模型往往是真实地球物理过程的简化。本练习通过一个计算实验，深刻揭示了这种模型不匹配（model mismatch）可能导致的后果。您将使用一个更真实的伯格斯（Burgers）流变模型生成合成的“观测”数据，然后尝试用一个简化的麦克斯韦模型来拟合这些数据，从而量化由此产生的粘度估计偏差。这项实践对于培养批判性思维至关重要，它让研究者清醒地认识到，在解释真实世界的观测数据时，模型假设的局限性可能会如何影响我们的科学结论。",
            "id": "3613161",
            "problem": "你需要实现一个独立的计算实验，用于量化在使用错误指定的 Maxwell 流变学反演由三维均匀 Burgers 粘弹性地幔产生的震后地表位移时间序列时，产生的模型不匹配偏差。几何结构是一个单一的线性八节点六面体有限元，代表一个基底固定、顶面施加均匀剪切牵引力的均匀地幔体积。通过对称性和均匀性，变形简化为均匀的简单剪切，但你的推导和实现必须从三维小应变线性粘弹性和准静态平衡出发，并与之保持一致。\n\n使用的基本原理：\n- 准静态线性动量平衡：$\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$，边界上具有指定的牵引力和位移，忽略惯性。\n- 小应变运动学：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right)$。\n- 线性粘弹性对应原理和力学模拟：一个 Maxwell 单元是一个剪切模量为 $\\mu$ 的线性弹簧与一个粘度为 $\\eta$ 的阻尼器串联；一个 Kelvin 单元是一个剪切模量为 $\\mu$ 的线性弹簧与一个粘度为 $\\eta$ 的阻尼器并联；一个 Burgers 单元是一个 Maxwell 单元与一个 Kelvin 单元串联。\n- 对于简单剪切，偏应力简化为标量剪应力 $\\tau$ 和剪应变 $\\gamma$，这与均匀状态下的三维各向同性线性粘弹性一致。\n\n物理配置：\n- 一个单一的六面体单元，在 $z$ 方向上的高度为 $H$，底面位于 $z = 0$ 处固定（$\\mathbf{u} = \\mathbf{0}$），顶面位于 $z = H$ 处在时间 $t \\ge 0$ 时承受均匀的剪切牵引力 $\\mathbf{t} = (\\tau_{0}, 0, 0)$（沿 $x$ 方向剪切）。\n- 材料具有 Burgers 流变学特性，其特征由 Maxwell 分支参数 $(\\mu_{M}, \\eta_{M})$ 和 Kelvin 分支参数 $(\\mu_{K}, \\eta_{K})$ 决定。假设材料是各向同性的，并且对于规定的纯剪切加载，体积效应是无关紧要的。\n\n任务：\n1. 从上述控制方程出发，证明在所述的均匀剪切牵引力作用下，单元经历空间上均匀的简单剪切，使得唯一的非零应力分量是 $\\sigma_{xz}(t) = \\tau_{0}$，唯一的非零应变分量是 $\\varepsilon_{xz}(t) = \\tfrac{1}{2}\\gamma(t)$。利用线性粘弹性对应关系，将三维问题简化为由串联的 Burgers 力学模拟控制的标量剪切关系（$\\tau(t)$ 和 $\\gamma(t)$ 之间）。在阶跃剪应力 $\\tau(t) = \\tau_{0} H(t)$（其中 $H(t)$ 是 Heaviside 阶跃函数）作用下，仅使用 Maxwell 和 Kelvin 单元的定义和基本微积分，仔细推导 $\\gamma(t)$ 的演化方程。不要假设任何已知的封闭形式解；你需要自己推导它。\n2. 将顶面在 $x$ 方向的水平位移表示为时间 $u(t)$ 的函数，单位为米，用均匀剪应变 $\\gamma(t)$ 和高度 $H$ 来表示。\n3. 定义一个错误指定的反演，该反演假设一个 Maxwell 流变学，其瞬时弹性柔量已知，且等于真实的 Burgers 瞬时柔量（因此截距是固定的）。具体来说，将 Maxwell 预测的位移建模为 $u_{\\text{Mx}}(t) = u_{0} + s\\, t$，其中 $u_{0}$ 是你从 Burgers 模型在 $t=0^{+}$ 时推导出的瞬时位移，$s$ 是一个常数斜率，将通过最小二乘法拟合给定时间窗口内的 Burgers 生成的 $u(t)$ 来确定。根据拟合出的斜率 $\\hat{s}$，推断 Maxwell 粘度估计值 $\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$。\n4. 对于下面的每个测试用例，量化相对粘度偏差 $b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$。\n\n数值和单位要求：\n- 时间 $t$ 单位为秒。\n- 剪切模量参数 $\\mu_{M}$ 和 $\\mu_{K}$ 单位为帕斯卡 ($\\mathrm{Pa}$)。\n- 粘度参数 $\\eta_{M}$ 和 $\\eta_{K}$ 单位为帕斯卡-秒 ($\\mathrm{Pa \\cdot s}$)。\n- 剪切牵引力 $\\tau_{0}$ 单位为帕斯卡 ($\\mathrm{Pa}$)。\n- 高度 $H$ 单位为米 ($\\mathrm{m}$)。\n- 顶部位移 $u(t)$ 必须以米 ($\\mathrm{m}$) 表示。\n- 最终报告的偏差 $b$ 是无量纲的，必须打印为小数点后保留六位的小数浮点数。\n\n实现要求：\n- 实现一个程序，该程序：\n  - 在 $t_{\\min}$ 和 $t_{\\max}$（含）之间 $N$ 个均匀间隔的时间样本 $t_{i}$ 上，计算 Burgers 生成的位移时间序列 $u(t_{i})$。\n  - 使用最小二乘法将 $u_{\\text{Mx}}(t) = u_{0} + s t$ 的斜率 $\\hat{s}$ 拟合到 Burgers 的 $u(t)$ 值（截距 $u_{0}$ 从真实的瞬时位移中固定）。\n  - 计算 $\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$ 和偏差 $b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$。\n\n测试套件：\n对于每个用例，使用指定的参数和时间窗口。所有常数必须完全按照给定的值使用。\n\n- 用例 1（平衡窗口）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{K} = 3.0 \\times 10^{18}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0\\ \\text{天} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0\\ \\text{年} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n- 用例 2（长窗口）：\n  - 材料和加载与用例 1 相同，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 50.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 100$。\n\n- 用例 3（短窗口）：\n  - 材料和加载与用例 1 相同，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 0.1 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 30$。\n\n- 用例 4（Kelvin 阻尼器有效刚性，接近纯 Maxwell 行为）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{K} = 1.0 \\times 10^{25}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n- 用例 5（软 Kelvin 弹簧与慢瞬态）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 5.0 \\times 10^{9}\\ \\mathrm{Pa}$，$\\eta_{K} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含五个相对偏差 $b$，以逗号分隔列表的形式括在方括号中，按用例 1 到 5 的顺序排列，每个偏差四舍五入到小数点后六位（例如，$[0.123456,-0.000001,0.002345,0.000000,-0.543210]$）。",
            "solution": "该问题要求在计算地球物理学背景下进行模型不匹配偏差的定量分析。具体来说，我们需要使用简化的地幔一维表示来模拟大地震后产生的震后地壳形变。真实的地球由 Burgers 流变学表示，而一个不正确、更简单的 Maxwell 模型被用于反演。我们必须推导出“真实”模型的解析解，实施一个数值实验来拟合“不正确”的模型，并量化由此产生的推断粘度偏差。\n\n### **1. 从三维粘弹性到一维简单剪切的推导**\n\n该问题在三维、准静态、小应变、线性粘弹性的框架内定义。\n\n**控制方程：**\n忽略惯性力的准静态动量平衡方程为：\n$$ \\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0} $$\n其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量。小应变运动学关系为：\n$$ \\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right) $$\n其中 $\\mathbf{u}$ 是位移矢量，$\\boldsymbol{\\varepsilon}$ 是无穷小应变张量。\n\n**问题几何和边界条件：**\n几何结构是一个高度为 $H$ 的层，其基底在 $z=0$ 处固定（$\\mathbf{u}=\\mathbf{0}$），其顶面在 $z=H$ 处在时间 $t \\ge 0$ 时受到沿 $x$ 轴方向的均匀剪切牵引力 $\\mathbf{t} = (\\tau_0, 0, 0)$。\n\n**简化为简单剪切：**\n通过对称性，我们可以假设一个位移场形式为 $\\mathbf{u} = (u_x(z, t), 0, 0)$。只要 $u_x(0,t) = 0$，这个拟设就与边界条件一致。\n应变张量 $\\boldsymbol{\\varepsilon}$ 的分量为：\n$$ \\varepsilon_{xz} = \\varepsilon_{zx} = \\frac{1}{2} \\frac{\\partial u_x}{\\partial z} $$\n$\\boldsymbol{\\varepsilon}$ 的所有其他分量都为零。对于各向同性线性粘弹性材料，在纯剪切应变作用下，产生的应力张量也将是纯剪切应力。因此，唯一的非零应力分量是 $\\sigma_{xz}$ 和 $\\sigma_{zx}$。\n\n动量平衡方程 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$ 显著简化。$y$ 和 $z$ 分量不言自明地满足（$0=0$）。$x$ 分量变为：\n$$ \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y} + \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 \\implies \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 $$\n这意味着 $\\sigma_{xz}$ 不随深度 $z$ 变化；它仅是时间的函数，$\\sigma_{xz}(t)$。\n\n在法向为 $\\mathbf{n}$ 的表面上的牵引力矢量由 $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$ 给出。在顶面 $z=H$，法向为 $\\mathbf{n}=(0,0,1)$。牵引力为：\n$$ \\mathbf{t}|_{z=H} = (\\sigma_{xz}(t), \\sigma_{yz}(t), \\sigma_{zz}(t)) $$\n给定在 $t \\ge 0$ 时规定的牵引力 $\\mathbf{t} = (\\tau_0, 0, 0)$，我们必须有 $\\sigma_{xz}(t) = \\tau_0$。由于 $\\sigma_{xz}$ 与 $z$ 无关，这个剪应力值在 $t>0$ 时适用于整个层。\n\n材料是均匀的。由于应力 $\\sigma_{xz}(t) = \\tau_0$ 在空间上是均匀的，因此产生的应变 $\\varepsilon_{xz}(t)$ 也必须在空间上是均匀的。我们定义工程剪应变 $\\gamma(t)$，使得 $\\varepsilon_{xz}(t) = \\frac{1}{2}\\gamma(t)$。因此：\n$$ \\frac{1}{2}\\frac{\\partial u_x}{\\partial z} = \\frac{1}{2}\\gamma(t) \\implies \\frac{d u_x}{d z} = \\gamma(t) $$\n对 $z$ 积分得到 $u_x(z, t) = \\gamma(t) z + C(t)$。应用固定基底边界条件 $u_x(0,t)=0$，我们发现积分常数 $C(t)=0$。这给出了位移场：\n$$ u_x(z,t) = \\gamma(t) z $$\n问题因此简化为求解在阶跃剪应力 $\\tau(t) = \\sigma_{xz}(t) = \\tau_0 H(t)$（其中 $H(t)$ 是 Heaviside 阶跃函数）作用下，均匀剪应变 $\\gamma(t)$ 的演化。这对应于对 Burgers 材料进行蠕变测试。\n\n### **2. Burgers 材料的蠕变响应**\n\n一个 Burgers 单元由一个 Maxwell 单元（弹簧 $\\mu_M$，阻尼器 $\\eta_M$）与一个 Kelvin 单元（弹簧 $\\mu_K$，阻尼器 $\\eta_K$ 并联）串联组成。\n- 对于串联的单元，总应力 $\\tau$ 在每个单元上是相同的，总应变 $\\gamma$ 是每个单元应变的总和：$\\gamma(t) = \\gamma_M(t) + \\gamma_K(t)$。\n- Maxwell 单元的应力-应变关系是 $\\dot{\\gamma}_M = \\frac{\\dot{\\tau}}{\\mu_M} + \\frac{\\tau}{\\eta_M}$。\n- Kelvin 单元的应力-应变关系是 $\\tau = \\mu_K \\gamma_K + \\eta_K \\dot{\\gamma}_K$。\n\n我们分析对阶跃应力 $\\tau(t) = \\tau_0 H(t)$ 的响应。对于 $t > 0$，$\\tau = \\tau_0$ 是常数，所以 $\\dot{\\tau}=0$。\n\n**Maxwell 单元应变 ($\\gamma_M$)：**\nMaxwell 单元上的应变是其弹簧和阻尼器应变的总和，$\\gamma_M = \\gamma_{M,s} + \\gamma_{M,d}$。\n- 弹性弹簧瞬时响应：$\\gamma_{M,s}(t) = \\tau(t) / \\mu_M = (\\tau_0/\\mu_M) H(t)$。\n- 粘性阻尼器应变率是 $\\dot{\\gamma}_{M,d} = \\tau(t) / \\eta_M$。对于 $t>0$，积分得到 $\\gamma_{M,d}(t) = (\\tau_0/\\eta_M) t$。\n因此，对于 $t>0$，Maxwell 应变贡献为 $\\gamma_{\\text{on Maxwell}}(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t$。\n\n**Kelvin 单元应变 ($\\gamma_K$)：**\n对于 $t>0$，Kelvin 单元的控制方程是一阶线性常微分方程：\n$$ \\eta_K \\dot{\\gamma}_K + \\mu_K \\gamma_K = \\tau_0 $$\n解为 $\\gamma_K(t) = \\gamma_{K,p} + \\gamma_{K,h}$，其中 $\\gamma_{K,p}$ 是特解，$\\gamma_{K,h}$ 是齐次解。\n- 特解是稳态响应，$\\gamma_{K,p} = \\tau_0 / \\mu_K$。\n- 齐次解是 $\\gamma_{K,h}(t) = C e^{-(\\mu_K/\\eta_K)t}$。\n通解是 $\\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} + C e^{-t/t_R}$，其中 $t_R = \\eta_K/\\mu_K$ 是推迟时间。\n初始条件是 Kelvin 单元由于其阻尼器不能瞬时变形，所以 $\\gamma_K(0^+) = 0$。\n$0 = \\frac{\\tau_0}{\\mu_K} + C \\implies C = -\\frac{\\tau_0}{\\mu_K}$。\nKelvin 单元在 $t>0$ 时的应变为：\n$$ \\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) $$\n\n**总 Burgers 应变和位移：**\n总应变是 Maxwell 和 Kelvin 单元应变的总和。注意，Maxwell 弹簧的弹性应变提供了 Burgers 物体的全部瞬时弹性响应。\n$$ \\gamma(t) = \\gamma_{M,s}(t) + \\gamma_{M,d}(t) + \\gamma_K(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t + \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) \\quad \\text{对于 } t > 0 $$\n顶部位移为 $u(t) = u_x(H, t) = \\gamma(t) H$：\n$$ u(t) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + \\frac{t}{\\eta_M} + \\frac{1}{\\mu_K} \\left(1 - e^{-t/(\\eta_K/\\mu_K)}\\right) \\right] $$\n\n### **3. 错误指定的 Maxwell 模型反演**\n\n我们现在用一个简化的 Maxwell 模型来拟合由 Burgers 模型生成的“真实”位移数据 $u(t)$。Maxwell 模型预测的位移是：\n$$ u_{\\text{Mx}}(t) = \\frac{\\tau_0 H}{\\mu_{\\text{Mx}}} + \\frac{\\tau_0 H}{\\eta_{\\text{Mx}}} t $$\n这是时间的线性函数。问题规定反演假设瞬时弹性响应是已知的。Burgers 模型在 $t \\to 0^+$ 时的瞬时位移是：\n$$ u_0 = u(0^+) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + 0 + \\frac{1}{\\mu_K}(1-1) \\right] = \\frac{\\tau_0 H}{\\mu_M} $$\n我们将线性模型的截距固定为这个真值，所以我们的拟合模型是 $u_{\\text{fit}}(t) = u_0 + s t$。斜率 $s$ 是 $\\frac{\\tau_0 H}{\\eta_{\\text{Mx}}}$ 的估计值。\n\n我们通过最小化真实位移 $u(t_i)$ 与模型 $u_{\\text{fit}}(t_i)$ 在一组时间样本 $\\{t_i\\}_{i=1}^N$ 上的残差平方和来确定最佳拟合斜率 $\\hat{s}$。我们正在将模型 $y(t) = st$ 拟合到数据 $d(t) = u(t) - u_0$。最小二乘泛函是：\n$$ S(s) = \\sum_{i=1}^N \\left( d(t_i) - s t_i \\right)^2 $$\n令 $\\frac{dS}{ds} = 0$ 给出最优斜率 $\\hat{s}$：\n$$ \\hat{s} = \\frac{\\sum_{i=1}^N t_i d(t_i)}{\\sum_{i=1}^N t_i^2} = \\frac{\\sum_{i=1}^N t_i (u(t_i) - u_0)}{\\sum_{i=1}^N t_i^2} $$\n从这个拟合斜率 $\\hat{s}$，我们使用关系 $\\hat{s} = \\frac{\\tau_0 H}{\\hat{\\eta}}$ 推断出表观 Maxwell 粘度 $\\hat{\\eta}$，得到：\n$$ \\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}} $$\n\n### **4. 粘度偏差和数值实现**\n\n粘度的相对偏差是推断粘度 $\\hat{\\eta}$ 与 Burgers 模型 Maxwell 分支的真实长期粘度 $\\eta_M$ 之间的归一化差异：\n$$ b = \\frac{\\hat{\\eta} - \\eta_M}{\\eta_M} $$\n\n每个测试用例的计算过程如下：\n1. 定义所有物理参数 $(\\mu_M, \\eta_M, \\mu_K, \\eta_K, \\tau_0, H)$ 和时间窗口参数 $(t_{\\min}, t_{\\max}, N)$。\n2. 生成从 $t_{\\min}$ 到 $t_{\\max}$ 的 $N$ 个均匀间隔的时间样本 $t_i$。\n3. 计算恒定的瞬时位移 $u_0 = \\frac{\\tau_0 H}{\\mu_M}$。\n4. 对于每个时间样本 $t_i$，使用推导出的解析公式计算真实的 Burgers 位移 $u(t_i)$。\n5. 计算待拟合的数据：$d_i = u(t_i) - u_0$。\n6. 使用通过原点的回归的最小二乘公式计算最佳拟合斜率 $\\hat{s}$。\n7. 计算推断的粘度 $\\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}}$。\n8. 计算并存储相对偏差 $b = (\\hat{\\eta} - \\eta_M) / \\eta_M$。\n对所有五个测试用例重复此过程。最终输出是计算出的偏差列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bias(params):\n    \"\"\"\n    Calculates the relative viscosity bias for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated relative viscosity bias.\n    \"\"\"\n    mu_M = params['mu_M']\n    eta_M = params['eta_M']\n    mu_K = params['mu_K']\n    eta_K = params['eta_K']\n    tau_0 = params['tau_0']\n    H = params['H']\n    t_min = params['t_min']\n    t_max = params['t_max']\n    N = params['N']\n\n    # 1. Generate N uniformly spaced time samples from t_min to t_max.\n    t_samples = np.linspace(t_min, t_max, N)\n\n    # 2. Calculate the true instantaneous displacement u_0.\n    # This corresponds to the instantaneous elastic response of the Maxwell spring.\n    u_0 = (tau_0 * H) / mu_M\n\n    # 3. Calculate the \"true\" displacement time series u(t) from the Burgers model.\n    # The displacement u(t) is H * gamma(t), where gamma is the total strain.\n    # gamma(t) = instantaneous_elastic + viscous_flow + transient_creep\n    #            (Maxwell spring)     (Maxwell dashpot) (Kelvin element)\n    \n    # Retardation time of the Kelvin element\n    # Guard against division by zero, although not needed for the given test cases.\n    if mu_K == 0.0:\n        # If mu_K is 0, the Kelvin element is just a dashpot. Its strain is (tau_0*t)/eta_K.\n        term_kelvin_strain = (tau_0 / eta_K) * t_samples\n    else:\n        t_R = eta_K / mu_K\n        term_kelvin_strain = (tau_0 / mu_K) * (1.0 - np.exp(-t_samples / t_R))\n    \n    # Total strain combines Maxwell and Kelvin responses\n    gamma_t = (tau_0 / mu_M) + (tau_0 / eta_M) * t_samples + term_kelvin_strain\n    \n    # Total displacement at the top surface\n    u_t = H * gamma_t\n    \n    # 4. Perform least squares to fit the slope of u_Mx(t) = u_0 + s*t.\n    # Since u_0 is fixed, we are fitting a line through the origin to the data d(t) = u(t) - u_0.\n    # The data to be fitted is the displacement minus the instantaneous part.\n    d_t = u_t - u_0\n    \n    # The least-squares solution for the slope s_hat is (t dot d) / (t dot t).\n    s_hat = np.dot(t_samples, d_t) / np.dot(t_samples, t_samples)\n    \n    # 5. Infer the apparent Maxwell viscosity eta_hat from the fitted slope s_hat.\n    # The slope of a pure Maxwell model is s = (tau_0 * H) / eta_Mx.\n    eta_hat = (tau_0 * H) / s_hat\n    \n    # 6. Calculate the relative viscosity bias.\n    bias = (eta_hat - eta_M) / eta_M\n    \n    return bias\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    S_PER_DAY = 86400.0\n    S_PER_YEAR = 365.25 * S_PER_DAY\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (balanced window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 2 (long window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 50.0 * S_PER_YEAR, 'N': 100\n        },\n        # Case 3 (short window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 0.1 * S_PER_YEAR, 'N': 30\n        },\n        # Case 4 (Kelvin dashpot effectively rigid)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 1.0e25,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 5 (soft Kelvin spring with slow transient)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 5.0e9, 'eta_K': 1.0e19,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bias = calculate_bias(case_params)\n        results.append(bias)\n\n    # Format the final results as specified in the problem statement.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the simulation.\nsolve()\n```"
        },
        {
            "introduction": "从大地测量数据（如GPS时间序列）中反演地球内部介质（如粘度）的空间分布，是计算地球物理学的核心任务之一。当模型参数数量巨大时，传统的梯度计算方法（如有限差分）变得不切实际。本练习将引导您学习并实践伴随方法（adjoint method），这是一种计算目标函数（模型与数据之间的失配）相对于大量模型参数梯度的极其高效的算法。通过从第一性原理推导和实现一个粘弹性系统的离散伴随模型，您将掌握现代地球物理反演和数据同化的前沿工具。",
            "id": "3613152",
            "problem": "考虑一个占据域 $x \\in [0,L]$ 的一维、平面剪切、准静态 Maxwell 粘弹性杆，其在剪切方向上的位移为 $u(x,t)$，剪应力为 $\\tau(t)$，剪应变为 $\\gamma(x,t) = \\partial u/\\partial x$。应力平衡简化为 $\\partial \\tau/\\partial x = 0$，因此 $\\tau$ 在空间上是均匀的。Maxwell 剪切本构关系为 $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$，其中 $\\eta(x) > 0$ 是空间可变的粘度，$G > 0$ 是剪切模量。边界条件为 $u(0,t)=0$ 和 $u(L,t) = U(t)$，其中 $U(t)$ 是给定的、光滑的，并从 $0$ 开始单调递增。\n\n基本依据。从准静态力平衡和 Maxwell 本构定律开始：\n- 力平衡：$\\nabla \\cdot \\sigma = 0$；在一维剪切中，$\\partial \\tau/\\partial x = 0$。\n- 运动学：$\\gamma = \\partial u/\\partial x$, $u(0,t)=0$, $u(L,t)=U(t)$。\n- 本构（Maxwell 剪切模型）：$\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$。\n\n证明边界条件意味着 $\\tau(t)$ 满足以下常微分方程：\n$$\n\\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t), \\quad \\alpha \\equiv \\frac{1}{L}\\int_{0}^{L} \\frac{1}{\\eta(x)}\\, dx,\n$$\n在假设 $u(x,0)=0$ 和 $\\tau(0)=0$ 的条件下。设观测算子收集在一组固定位置 $x_i$ ($i \\in \\mathcal{I}$, $0 < x_i < L$) 处的内部位移。在时间窗 $t \\in [0,T]$ 上定义失配泛函：\n$$\nJ[\\eta] = \\frac{1}{2} \\int_{0}^{T} w_t(t) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u(x_i,t) - d(x_i,t)\\right)^2 \\, dt,\n$$\n其中 $d(x_i,t)$ 是由已知的参考粘度场 $\\eta_{\\mathrm{true}}(x)$ 和相同的边界强迫 $U(t)$ 合成的观测位移；$w_t(t) \\ge 0$ 和 $w_x(x_i) \\ge 0$ 分别是在时间 $t$ 和位置上积分为 $1$ 的权重。你需要计算 $J$ 相对于参数场 $\\phi(x) = \\log \\eta(x)$ 的梯度。\n\n离散化要求。在 $[0,L]$ 上使用包含 $N_x$ 个单元的均匀空间网格，在 $[0,T]$ 上使用包含 $N_t$ 个步长的均匀时间网格。对应力演化和本构更新，使用时间上的后向欧拉法：\n- 应力更新：对于时间步长为 $\\Delta t$ 的第 $n$ 个时间步，通过以下方式定义 $\\tau_n$\n$$\n\\frac{\\tau_n - \\tau_{n-1}}{\\Delta t} + G \\alpha \\, \\tau_n = \\frac{G}{L}\\, \\dot{U}_n,\n$$\n其中 $\\dot{U}_n \\approx \\dot{U}(t_n)$，$\\alpha = \\frac{1}{L} \\sum_{j=1}^{N_x} \\Delta x \\, e^{-\\phi_j}$，$\\Delta x = L/N_x$，且 $\\phi_j = \\log \\eta_j$ 是单元中心 $x_j$ 处的值。\n- 应变更新：对于每个空间单元 $j$，\n$$\n\\gamma_j^n - \\gamma_j^{n-1} = \\Delta t \\, \\tau_n \\, e^{-\\phi_j} + \\frac{\\tau_n - \\tau_{n-1}}{G}.\n$$\n- 从应变计算位移：对于位置 $x_i$ 处的网格节点 $i$，近似为\n$$\nu_i^n = \\sum_{m=1}^{i} \\gamma_m^n \\, \\Delta x, \\quad u_0^n = 0.\n$$\n- 观测：取一个固定的索引集 $\\mathcal{I} \\subset \\{1,\\dots,N_x-1\\}$，对应于内部节点。\n\n伴随推导目标。推导与应变更新相关的乘子 $\\mu_j^n$ 和与应力更新相关的乘子 $\\lambda_n$ 的离散伴随递推关系，并展示它们如何生成梯度 $\\partial J / \\partial \\phi_j$。你的推导必须从由离散正演方程和 $J$ 构建的拉格朗日量开始。不要使用任何已知的伴随公式；通过取变分并强制平稳性，从第一性原理出发进行推导。\n\n无量纲化。在无量纲单位下进行计算。设 $L=1$，并取：\n- $G = 10$,\n- $U(t) = U_{\\max} \\left(1 - e^{-t/T_0}\\right)$，其中 $U_{\\max} = 1$ 且 $T_0 = 0.5$，\n- 时间网格参数 $N_t = 250$, $\\Delta t = 0.02$，因此 $T = N_t \\Delta t = 5$，\n- 空间网格参数 $N_x = 64$。\n\n权重。对所有时间步使用 $w_t(t_n) = 1/N_t$，对所有观测节点使用 $w_x(x_i) = 1/|\\mathcal{I}|$。\n\n观测。对于下面的每个测试用例，定义一个参考场 $\\phi_{\\mathrm{true}}(x)$，通过使用 $\\phi_{\\mathrm{true}}$ 运行一次正演模型来合成 $d(x_i,t_n)$，然后为一个单独的当前场 $\\phi(x)$ 计算失配和梯度。\n\n测试套件。实现以下三个测试用例（全部使用无量纲单位）：\n- 用例1（光滑对比度）：$\\phi_{\\mathrm{true}}(x) = \\log \\eta_0 + a \\sin(2\\pi x)$，其中 $\\eta_0 = 1$ 且 $a = \\log 3$。当前场 $\\phi(x) = \\log \\eta_0 + b \\cos(2\\pi x)$，其中 $b = \\log 2$。\n- 用例2（均匀）：$\\phi_{\\mathrm{true}}(x) = \\log 2$ 且当前场 $\\phi(x) = \\log 1$。\n- 用例3（阶跃）：对于 $x < 0.3$，$\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{low}}$；对于 $x \\ge 0.3$，$\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{high}}$，其中 $\\eta_{\\mathrm{low}} = 0.5$，$\\eta_{\\mathrm{high}} = 5$。当前场：对于 $x < 0.3$，$\\phi(x) = \\log \\eta_{\\mathrm{high}}$；对于 $x \\ge 0.3$，$\\phi(x) = \\log \\eta_{\\mathrm{low}}$。\n\n观测节点。使用最接近 $x \\in \\{0.25, 0.5, 0.75\\}$ 的内部节点，即选择这些节点的索引作为 $\\mathcal{I}$。\n\n通过方向导数进行验证。除了计算梯度向量 $g_j = \\partial J/\\partial \\phi_j$ 外，还通过计算沿方向 $v_j = \\cos(2\\pi x_j)$ 的方向有限差分检验来验证伴随方法：\n$$\n\\mathrm{FD} = \\frac{J(\\phi + \\varepsilon v) - J(\\phi)}{\\varepsilon}, \\quad \\varepsilon = 10^{-6}, \\quad \\mathrm{AD} = \\sum_{j=1}^{N_x} g_j v_j,\n$$\n并报告绝对误差 $|\\mathrm{FD} - \\mathrm{AD}|$。\n\n程序要求。你的程序必须：\n- 实现所推导的正演求解器、离散伴随求解器和梯度组装。\n- 对于三个测试用例中的每一个，输出一个包含三个浮点数的列表：失配 $J$、欧几里得范数 $\\|g\\|_2$ 和绝对伴随检验误差 $|\\mathrm{FD}-\\mathrm{AD}|$。\n- 生成单行输出，其中包含结果，格式为由逗号分隔的三个用例列表的列表，并用方括号括起来，例如 $[[J_1,\\|g\\|_1,E_1],[J_2,\\|g\\|_2,E_2],[J_3,\\|g\\|_3,E_3]]$。\n\n角度单位不适用。所有量都是无量纲的，因此答案中不需要物理单位。通过遵守指定的后向欧拉更新来确保数值稳定性。输出必须是数值计算的结果，而非符号简化的结果。最终输出必须是指定格式的单行文本。",
            "solution": "该问题要求推导离散伴随方程，以计算失配泛函 $J$ 相对于空间变化粘度场的对数 $\\phi(x) = \\log \\eta(x)$ 的梯度。物理系统是一维 Maxwell 粘弹性杆。推导必须从第一性原理出发，使用拉格朗日方法。\n\n首先，我们验证空间均匀剪应力 $\\tau(t)$ 的控制常微分方程 (ODE)。Maxwell 本构关系为 $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$。从 $0$ 到 $L$ 对 $x$ 进行积分：\n$$ \\int_0^L \\dot{\\gamma}(x,t) \\, dx = \\int_0^L \\left(\\frac{\\tau(t)}{\\eta(x)} + \\frac{\\dot{\\tau}(t)}{G}\\right) dx $$\n左侧，使用运动学关系 $\\gamma = \\partial u/\\partial x$ 并交换积分和时间导数，变为：\n$$ \\int_0^L \\frac{\\partial \\dot{u}}{\\partial x} \\, dx = \\dot{u}(L,t) - \\dot{u}(0,t) $$\n使用边界条件 $u(0,t)=0$ 和 $u(L,t)=U(t)$，上式简化为 $\\dot{U}(t)$。右侧变为：\n$$ \\tau(t) \\int_0^L \\frac{1}{\\eta(x)} \\, dx + \\frac{\\dot{\\tau}(t)}{G} \\int_0^L dx = \\tau(t) (L \\alpha) + \\frac{\\dot{\\tau}(t)}{G} L $$\n其中 $\\alpha \\equiv \\frac{1}{L}\\int_0^L \\frac{1}{\\eta(x)} \\, dx$。令两侧相等，得到 $\\dot{U}(t) = L\\alpha\\tau(t) + \\frac{L}{G}\\dot{\\tau}(t)$。重新整理并乘以 $G/L$，得到目标 ODE：\n$$ \\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t) $$\n初始条件 $u(x,0)=0$ 和 $\\tau(0)=0$ 与此模型一致。\n\n问题的核心是推导离散伴随方程。我们首先定义离散正演模型和失配泛函。令 $n=1, \\dots, N_t$ 为时间步索引，$j=0, \\dots, N_x-1$ 为空间单元索引。节点由 $i=0, \\dots, N_x$ 索引。参数场为 $\\phi_j = \\log \\eta_j$。\n\n离散正演模型方程，整理为等于零的形式后，定义了约束条件 $R=0$：\n1. 应力更新 ($n=1, \\dots, N_t$):\n   $$ R_{\\tau, n} \\equiv \\left(1+G\\alpha \\Delta t\\right)\\tau_n - \\tau_{n-1} - \\frac{G\\Delta t}{L} \\dot{U}_n = 0 $$\n   其中 $\\alpha = \\frac{\\Delta x}{L} \\sum_{j=0}^{N_x-1} e^{-\\phi_j}$。\n2. 应变更新 ($j=0, \\dots, N_x-1, n=1, \\dots, N_t$):\n   $$ R_{\\gamma, j, n} \\equiv \\gamma_j^n - \\gamma_j^{n-1} - \\Delta t \\tau_n e^{-\\phi_j} - \\frac{1}{G}(\\tau_n - \\tau_{n-1}) = 0 $$\n3. 位移计算 ($i \\in \\mathcal{I}, n=1, \\dots, N_t$):\n   $$ R_{u, i, n} \\equiv u_i^n - \\Delta x \\sum_{m=0}^{i-1} \\gamma_m^n = 0 $$\n离散失配泛函为：\n$$ J = \\frac{1}{2} \\sum_{n=1}^{N_t} w_t(t_n) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u_i^n - d_i^n\\right)^2 $$\n其中 $d_i^n$ 是合成数据。\n\n拉格朗日量 $\\mathcal{L}$ 是通过将 $J$ 与约束条件增广而构建的，约束条件由拉格朗日乘子 $\\lambda_n$（对应应力）、$\\mu_j^n$（对应应变）和 $\\nu_i^n$（对应位移）加权：\n$$ \\mathcal{L} = J + \\sum_{n=1}^{N_t} \\lambda_n R_{\\tau, n} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n R_{\\gamma, j, n} + \\sum_{n=1}^{N_t} \\sum_{i \\in \\mathcal{I}} \\nu_i^n R_{u, i, n} $$\n伴随方程是通过强制 $\\mathcal{L}$ 相对于状态变量 $u_i^n, \\gamma_j^n, \\tau_n$ 的平稳性来推导的。$J$ 相对于 $\\phi_k$ 的全变分则由 $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$ 给出。\n\n- **关于 $u_i^n$ ($i \\in \\mathcal{I}$) 的平稳性：** $\\frac{\\partial \\mathcal{L}}{\\partial u_i^n}=0$ 产生伴随源：\n$$ \\frac{\\partial J}{\\partial u_i^n} + \\nu_i^n = 0 \\implies \\nu_i^n = - w_t(t_n) w_x(x_i) (u_i^n - d_i^n) $$\n\n- **关于 $\\gamma_j^n$ 的平稳性：** 对于 $n=1,\\dots,N_t$，$\\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n}=0$。这导出了应变乘子 $\\mu_j^n$ 的后向递推关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n} = \\mu_j^n - \\mu_j^{n+1} + \\sum_{i \\in \\mathcal{I}} \\nu_i^n \\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = 0 $$\n使用 $\\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = -\\Delta x \\cdot \\mathbf{1}_{j \\le i-1}$，我们得到：\n$$ \\mu_j^n = \\mu_j^{n+1} + \\Delta x \\sum_{i \\in \\mathcal{I}, i > j} \\nu_i^n $$\n终端条件是 $\\mu_j^{N_t+1} = 0$。我们定义伴随强迫项 $f_j^n = \\Delta x \\sum_{i \\in \\mathcal{I}, i > j} \\nu_i^n$。那么，$\\mu_j^n = \\mu_j^{n+1} + f_j^n$。\n\n- **关于 $\\tau_n$ 的平稳性：** 对于 $n=1,\\dots,N_t$，$\\frac{\\partial \\mathcal{L}}{\\partial \\tau_n}=0$。这产生了应力乘子 $\\lambda_n$ 的后向递推关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\tau_n} = \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\tau_n} + \\lambda_{n+1} \\frac{\\partial R_{\\tau,n+1}}{\\partial \\tau_n} + \\sum_{j=0}^{N_x-1} \\left( \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\tau_n} + \\mu_j^{n+1} \\frac{\\partial R_{\\gamma,j,n+1}}{\\partial \\tau_n} \\right) = 0 $$\n代入约束残差的导数：\n$$ \\lambda_n (1+G\\alpha \\Delta t) - \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(-\\Delta t e^{-\\phi_j} - 1/G) + \\mu_j^{n+1}(1/G) \\right] = 0 $$\n终端条件是 $\\lambda_{N_t+1}=0$。这可以重排为 $\\lambda_n$ 的一个后向更新公式：\n$$ \\lambda_n (1+G\\alpha \\Delta t) = \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(\\Delta t e^{-\\phi_j} + 1/G) - \\mu_j^{n+1}/G \\right] $$\n使用 $\\mu_j^{n+1} = \\mu_j^n - f_j^n$，这可以简化为一个计算上更方便的形式：\n$$ \\lambda_n = (1+G\\alpha \\Delta t)^{-1} \\left( \\lambda_{n+1} + \\Delta t \\sum_{j=0}^{N_x-1} \\mu_j^n e^{-\\phi_j} + \\frac{1}{G} \\sum_{j=0}^{N_x-1} f_j^n \\right) $$\n\n- **梯度计算：** $J$ 相对于 $\\phi_k$ 的梯度是 $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$。\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} $$\n所需的导数为：\n$$ \\frac{\\partial \\alpha}{\\partial \\phi_k} = -\\frac{\\Delta x}{L}e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} = G \\Delta t \\tau_n \\frac{\\partial \\alpha}{\\partial \\phi_k} = -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} = - \\Delta t \\tau_n \\frac{\\partial e^{-\\phi_j}}{\\partial \\phi_k} = \\Delta t \\tau_n e^{-\\phi_j} \\delta_{jk} $$\n将这些代入梯度的表达式中得到：\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\left[ \\lambda_n \\left( -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} \\right) + \\mu_k^n \\left( \\Delta t \\tau_n e^{-\\phi_k} \\right) \\right] $$\n提取公因子后，得到梯度分量的最终表达式：\n$$ \\frac{\\partial J}{\\partial \\phi_k} = \\Delta t \\, e^{-\\phi_k} \\sum_{n=1}^{N_t} \\tau_n \\left( \\mu_k^n - \\lambda_n G \\frac{\\Delta x}{L} \\right) $$\n该表达式的实现方式是：首先运行正演模型以存储状态变量 $(\\tau_n, \\gamma_j^n, u_i^n)$ 的历史记录，然后按时间反向运行伴随模型以计算乘子历史 $(\\lambda_n, \\mu_j^n)$，最后在每个时间步累加梯度贡献。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n\n    class Params:\n        \"\"\"A container for simulation parameters.\"\"\"\n        def __init__(self):\n            self.L = 1.0\n            self.G = 10.0\n            self.U_max = 1.0\n            self.T0 = 0.5\n            self.Nt = 250\n            self.dt = 0.02\n            self.T = self.Nt * self.dt\n            self.Nx = 64\n            self.dx = self.L / self.Nx\n            \n            self.times = np.linspace(0, self.T, self.Nt + 1)\n            self.cell_coords = (np.arange(self.Nx) + 0.5) * self.dx\n            \n            obs_locs = [0.25, 0.5, 0.75]\n            self.obs_indices = [int(round(loc / self.dx)) for loc in obs_locs]\n            \n            self.wt = 1.0 / self.Nt\n            self.wx = 1.0 / len(self.obs_indices)\n\n            self.eps = 1e-6\n            self.pert_vec = np.cos(2 * np.pi * self.cell_coords)\n\n    def U_dot_fun(t, p):\n        \"\"\"Prescribed boundary velocity.\"\"\"\n        return (p.U_max / p.T0) * np.exp(-t / p.T0)\n\n    def run_forward(phi, p, d_hist=None):\n        \"\"\"Runs the forward model to compute state variables and, optionally, the misfit J.\"\"\"\n        tau_hist = np.zeros(p.Nt + 1)\n        gamma_hist = np.zeros((p.Nt + 1, p.Nx))\n        u_hist = np.zeros((p.Nt + 1, p.Nx + 1))\n        \n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        U_dot_hist = U_dot_fun(p.times, p)\n        tau_denom = 1.0 + p.G * alpha * p.dt\n\n        for n in range(1, p.Nt + 1):\n            tau_prev = tau_hist[n-1]\n            tau_num = tau_prev + (p.G * p.dt / p.L) * U_dot_hist[n]\n            tau_n = tau_num / tau_denom\n            tau_hist[n] = tau_n\n\n            gamma_prev = gamma_hist[n-1, :]\n            gamma_hist[n, :] = gamma_prev + p.dt * tau_n * inv_eta + (tau_n - tau_prev) / p.G\n            \n            # Efficient displacement update\n            u_hist[n, 1:] = np.cumsum(gamma_hist[n, :]) * p.dx\n        \n        J = 0.0\n        if d_hist is not None:\n            residuals = u_hist[1:, p.obs_indices] - d_hist[1:, p.obs_indices]\n            J = 0.5 * p.wt * p.wx * np.sum(residuals**2)\n\n        return J, (tau_hist, gamma_hist, u_hist)\n\n    def run_adjoint(phi, p, state_hist, d_hist):\n        \"\"\"Runs the adjoint model to compute the gradient of J w.r.t. phi.\"\"\"\n        tau_hist, _, u_hist = state_hist\n        \n        lambda_hist = np.zeros(p.Nt + 2)\n        mu_hist = np.zeros((p.Nt + 2, p.Nx))\n        grad = np.zeros(p.Nx)\n\n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        lambda_denom_inv = 1.0 / (1.0 + p.G * alpha * p.dt)\n\n        for n in range(p.Nt, 0, -1):\n            nu_n = np.zeros(p.Nx + 1)\n            res_n = u_hist[n,:] - d_hist[n,:]\n            for i_obs in p.obs_indices:\n                nu_n[i_obs] = -p.wt * p.wx * res_n[i_obs]\n\n            s = np.zeros(p.Nx)\n            s_sum_at_node = 0.0\n            for i_node in range(p.Nx, 0, -1):\n                if i_node in p.obs_indices:\n                    s_sum_at_node += nu_n[i_node]\n                \n                j_cell = i_node - 1\n                s[j_cell] = s_sum_at_node\n            \n            f_n = p.dx * s\n            \n            mu_n = mu_hist[n+1, :] + f_n\n\n            lambda_n_num = (lambda_hist[n+1] + \n                           p.dt * np.sum(mu_n * inv_eta) + \n                           (1.0/p.G) * np.sum(f_n))\n            lambda_n = lambda_n_num * lambda_denom_inv\n            \n            mu_hist[n, :] = mu_n\n            lambda_hist[n] = lambda_n\n\n            tau_n = tau_hist[n]\n            term1 = inv_eta * p.dt * tau_n\n            term2 = mu_n - lambda_n * p.G * p.dx / p.L\n            grad += term1 * term2\n\n        return grad\n\n    def run_case(p, phi_true_func, phi_current_func):\n        \"\"\"Executes one complete test case and returns results.\"\"\"\n        phi_true = phi_true_func(p.cell_coords)\n        phi_current = phi_current_func(p.cell_coords)\n\n        # Synthesize data\n        _, (_, _, d_hist) = run_forward(phi_true, p)\n        \n        # Misfit for current phi\n        J, state_hist = run_forward(phi_current, p, d_hist)\n        \n        # Gradient via adjoint\n        grad = run_adjoint(phi_current, p, state_hist, d_hist)\n        grad_norm = np.linalg.norm(grad)\n\n        # Finite difference check\n        phi_pert = phi_current + p.eps * p.pert_vec\n        J_pert, _ = run_forward(phi_pert, p, d_hist)\n        fd_deriv = (J_pert - J) / p.eps\n        ad_deriv = np.dot(grad, p.pert_vec)\n        error = abs(fd_deriv - ad_deriv)\n\n        return [J, grad_norm, error]\n\n    # --- Test Cases ---\n    p = Params()\n\n    # Case 1: Smooth contrast\n    phi_true_1 = lambda x: np.log(3) * np.sin(2 * np.pi * x)\n    phi_current_1 = lambda x: np.log(2) * np.cos(2 * np.pi * x)\n\n    # Case 2: Uniform\n    phi_true_2 = lambda x: np.full_like(x, np.log(2.0))\n    phi_current_2 = lambda x: np.full_like(x, np.log(1.0))\n\n    # Case 3: Step\n    def phi_true_3(x):\n        phi = np.full_like(x, np.log(5.0))\n        phi[x  0.3] = np.log(0.5)\n        return phi\n    def phi_current_3(x):\n        phi = np.full_like(x, np.log(0.5))\n        phi[x  0.3] = np.log(5.0)\n        return phi\n\n    test_cases = [\n        (phi_true_1, phi_current_1),\n        (phi_true_2, phi_current_2),\n        (phi_true_3, phi_current_3),\n    ]\n\n    all_results = []\n    for phi_true_f, phi_current_f in test_cases:\n        results = run_case(p, phi_true_f, phi_current_f)\n        all_results.append(results)\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}