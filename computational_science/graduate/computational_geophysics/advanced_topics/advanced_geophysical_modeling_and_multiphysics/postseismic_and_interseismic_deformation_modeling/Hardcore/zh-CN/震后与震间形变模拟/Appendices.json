{
    "hands_on_practices": [
        {
            "introduction": "掌握地震后形变建模的第一步是为基本的粘弹性流变模型建立一个精确的数值求解器。本练习旨在通过实现麦克斯韦（Maxwell）流变本构下的应力松弛过程，为后续更复杂的模型打下坚实基础。通过这个实践，你将不仅加深对粘弹性物理核心——应力松弛的理解，还将掌握一种在科学计算中实现高精度的高效工具——谱方法（spectral methods）。",
            "id": "3613099",
            "problem": "考虑在时间 $t=0$ 时，一根均匀 Maxwell 杆受到阶跃应变作用下的一维粘弹性应力松弛。在震后形变模拟中，Maxwell 本构模型将弹性弹簧和粘性阻尼器串联，这与同震应力变化后下地壳和上地幔的流变学性质相关。设 $E$ 表示弹性模量（单位为帕斯卡），$\\eta$ 表示粘度（单位为帕斯卡-秒），$\\varepsilon(t)$ 表示总应变。将应力定义为 $\\sigma(t)$，它在一维杆中空间均匀，并根据标准 Maxwell 模型随时间演化。已知阶跃应变后的应力松弛精确解随时间呈指数衰减，您应使用此解来验证数值精度；在您的实现中，请勿假定任何简化公式。\n\n仅从串联 Maxwell 单元的线性粘弹性基本定义和定律出发，推导在施加阶跃应变 $\\varepsilon(t)=\\varepsilon_0 H(t)$（其中 $H(t)$ 是 Heaviside 阶跃函数，$\\varepsilon_0$ 是一个常数）下 $\\sigma(t)$ 的控制常微分方程。然后，在闭区间 $[0,T]$ 上使用 Chebyshev-Gauss-Lobatto (CGL) 点实现一个全局谱配置法，以求解得到的 $\\sigma(t)$ 的初值问题，其中 $T>0$ 是一个以秒为单位的固定最终时间。使用 Chebyshev 微分矩阵来近似时间导数，并使用 tau 方法行替换在 $t=0$ 处施加初始条件，从而使配置解在 $t=0$ 节点处精确满足初始应力。使用仿射变换将 CGL 点从 $[-1,1]$ 映射到 $[0,T]$，然后为配置点上的应力值组装并求解得到的线性系统。\n\n科学和数值要求：\n- 从串联的弹性弹簧和粘性阻尼器的本构定律推导 Maxwell 常微分方程。所有公式均用 $E$、$\\eta$、$\\varepsilon(t)$ 和 $\\sigma(t)$ 表示。\n- 构建 Chebyshev-Gauss-Lobatto 节点 $x_k=\\cos\\left(\\frac{\\pi k}{N-1}\\right)$（对于 $k=0,1,\\dots,N-1$），通过 $t_k = \\frac{T}{2}(x_k+1)$ 将它们映射到时间 $t_k \\in [0,T]$，并在 $[-1,1]$ 上构建一阶 Chebyshev 微分矩阵 $D$，该矩阵具有以下性质：对于 $i\\neq j$，$D_{ij}$ 与 CGL 节点上 Lagrange 插值多项式的精确导数一致。使用仿射缩放获得时间微分矩阵 $\\frac{2}{T}D$。\n- 为配置点上的未知数 $\\sigma(t_k)$ 建立线性系统，并通过将对应于 $t=0$ 的系统行替换为单位行，并将右侧设置为给定的初始应力，来施加初始条件 $\\sigma(0)$。\n- 通过计算 CGL 节点上的最大范数误差，将数值解与精确指数解进行比较验证，\n$$\ne_\\infty(N) = \\max_{k} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|,\n$$\n其中应力单位为帕斯卡。通过计算两个连续离散化 $N_1$ 和 $N_2$ 的误差，并估计经验收敛因子 $a$，来验证谱方法的指数级收敛特性。",
            "solution": "该问题要求推导并数值求解一维 Maxwell 粘弹性材料在阶跃应变下的应力松弛方程。这将通过全局谱配置法来完成。\n\n### 1. 控制方程和精确解的推导\n\n一个 Maxwell 单元由一个纯弹性弹簧和一个纯粘性阻尼器串联而成。在施加的应力 $\\sigma(t)$ 作用下，两个元件承受相同的应力，总应变 $\\varepsilon(t)$ 是弹性应变 $\\varepsilon_e(t)$ 和粘性应变 $\\varepsilon_v(t)$ 之和。\n\n本构关系如下：\n1.  总应变之和：$\\varepsilon(t) = \\varepsilon_e(t) + \\varepsilon_v(t)$\n2.  弹簧的 Hooke 定律：$\\sigma(t) = E \\varepsilon_e(t)$，其中 $E$ 是弹性模量。\n3.  阻尼器的 Newton 定律：$\\sigma(t) = \\eta \\dot{\\varepsilon}_v(t)$，其中 $\\eta$ 是粘度，$\\dot{\\varepsilon}_v$ 是粘性应变率。\n\n为推导 $\\sigma(t)$ 的控制常微分方程 (ODE)，我们将总应变方程对时间 $t$ 求导：\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{d\\varepsilon_e}{dt} + \\frac{d\\varepsilon_v}{dt}\n$$\n根据本构定律，我们可以用应力 $\\sigma(t)$ 表示应变率：\n-   $\\dot{\\varepsilon}_e(t) = \\frac{1}{E} \\frac{d\\sigma}{dt}$\n-   $\\dot{\\varepsilon}_v(t) = \\frac{1}{\\eta} \\sigma(t)$\n\n将这些代入微分后的应变方程，得到 Maxwell 模型的微分形式：\n$$\n\\frac{d\\varepsilon}{dt} = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t)\n$$\n该方程将总应变率 $\\dot{\\varepsilon}(t)$ 与应力 $\\sigma(t)$ 及其变化率 $\\dot{\\sigma}(t)$ 联系起来。\n\n问题指定了施加的阶跃应变 $\\varepsilon(t) = \\varepsilon_0 H(t)$，其中 $\\varepsilon_0$ 是一个恒定的应变大小，$H(t)$ 是 Heaviside 阶跃函数。在阶跃发生的瞬间，$t=0$，应变是瞬时施加的。粘性阻尼器不能瞬时响应，因此初始粘性应变 $\\varepsilon_v(0^+) = 0$。因此，所有初始应变都以弹性方式储存：$\\varepsilon_e(0^+) = \\varepsilon_0$。这导致了初始应力：\n$$\n\\sigma(0) = \\sigma(0^+) = E \\varepsilon_e(0^+) = E\\varepsilon_0\n$$\n对于所有时间 $t  0$，应变是恒定的，$\\varepsilon(t) = \\varepsilon_0$，因此其时间导数为零，$\\dot{\\varepsilon}(t) = 0$。对于 $t0$ 的控制常微分方程简化为：\n$$\n0 = \\frac{1}{E} \\frac{d\\sigma}{dt} + \\frac{1}{\\eta} \\sigma(t) \\quad \\implies \\quad \\frac{d\\sigma}{dt} + \\frac{E}{\\eta} \\sigma(t) = 0\n$$\n这是一个一阶线性齐次常微分方程。我们定义 Maxwell 松弛时间为 $\\tau = \\eta/E$。应力松弛的常微分方程则为：\n$$\n\\frac{d\\sigma}{dt} + \\frac{1}{\\tau} \\sigma(t) = 0, \\quad \\text{with initial condition} \\quad \\sigma(0) = E\\varepsilon_0\n$$\n这个初值问题的精确解可以通过分离变量法或使用指数衰减的标准解得到：\n$$\n\\sigma_{\\text{exact}}(t) = \\sigma(0) \\exp\\left(-\\frac{t}{\\tau}\\right) = E\\varepsilon_0 \\exp\\left(-\\frac{E}{\\eta}t\\right)\n$$\n此解析解将用于验证数值方法的准确性。\n\n### 2. 数值方法：谱配置法\n\n我们在时间区间 $[0, T]$ 上使用全局谱配置法求解该初值问题。\n\n**离散化：** 域 $[0, T]$ 使用 $N$ 个 Chebyshev-Gauss-Lobatto (CGL) 点进行离散化。CGL 节点在标准区间 $[-1, 1]$ 上定义为 $x_j = \\cos\\left(\\frac{\\pi j}{N-1}\\right)$（对于 $j=0, 1, \\dots, N-1$）。这些节点不是单调顺序的。为方便起见，我们重新索引它们，使其从 -1 到 1 排列：$x'_j = -\\cos\\left(\\frac{\\pi j}{N-1}\\right)$（对于 $j=0, \\dots, N-1$）。这得到 $x'_0 = -1, \\dots, x'_{N-1} = 1$。然后我们使用仿射变换将这些节点映射到时间域 $[0, T]$：\n$$\nt_j = \\frac{T}{2}(x'_j + 1)\n$$\n这确保了 $t_0=0$ 和 $t_{N-1}=T$，从而提供了一组单调递增的时间点。\n\n**Chebyshev 微分矩阵：** 谱方法的核心是微分矩阵 $D$，它近似于一个由其在 CGL 节点上的值表示的函数的导数。对于 CGL 节点 $x_j$（按照许多常规定义，从 1 到 -1 排序），$N \\times N$ 矩阵 $D$ 的项为：\n$$\nD_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j} \\quad \\text{for } i \\neq j\n$$\n$$\nD_{ii} = -\\sum_{j \\neq i} D_{ij}\n$$\n其中权重为 $c_0=c_{N-1}=2$ 和 $c_i=1$ 对于 $1 \\le i \\le N-2$。函数向量 $\\vec{f}$ 在 $[-1, 1]$ 上的导数随后通过矩阵向量乘积 $D\\vec{f}$ 来近似。对于时间域 $[0,T]$，微分算子被缩放：$\\mathcal{D}_t = \\frac{2}{T}D$。我们的实现将对 $D$ 使用从 1 到 -1 的常规节点排序，并映射到从 $T$ 到 $0$ 的时间点。\n\n**线性系统构建：** 我们寻求在时间节点 $\\vec{t} = [t_0, t_1, \\dots, t_{N-1}]^T$ 处的数值解 $\\vec{\\sigma} = [\\sigma_0, \\sigma_1, \\dots, \\sigma_{N-1}]^T$。在 $N$ 个时间节点上对常微分方程 $\\dot{\\sigma} + \\frac{1}{\\tau}\\sigma = 0$ 进行配置，得到系统：\n$$\n\\left(\\frac{2}{T}D\\right)\\vec{\\sigma} + \\frac{1}{\\tau}I\\vec{\\sigma} = \\vec{0}\n$$\n其中 $I$ 是 $N \\times N$ 单位矩阵。这可以写成一个线性系统 $L\\vec{\\sigma} = \\vec{0}$，其中算子矩阵为 $L = \\frac{2}{T}D + \\frac{1}{\\tau}I$。\n\n**初始条件施加：** 系统 $L\\vec{\\sigma} = \\vec{0}$ 是齐次的，需要一个边界条件才能获得唯一解。初始条件是 $\\sigma(0) = E\\varepsilon_0$。在我们的节点排序中，时间 $t=0$ 对应最后一个节点，$t_{N-1}=0$（因为 $x_{N-1}=-1$）。我们通过行替换使用 tau 方法施加此条件。矩阵 $L$ 的最后一行和右侧向量 $\\vec{b}$（初始全为零）被修改。$L$ 的最后一行被替换为一个“单位行” $[0, 0, \\dots, 1]$，$\\vec{b}$ 的最后一个元素被设置为初始应力值 $E\\varepsilon_0$。\n修改后的系统 $L'\\vec{\\sigma} = \\vec{b}$ 为：\n- $L'_{ij} = L_{ij}$ 对于 $i=0, \\dots, N-2$。\n- $L'_{N-1, j} = 0$ 对于 $j=0, \\dots, N-2$ 且 $L'_{N-1, N-1} = 1$。\n- $b_i = 0$ 对于 $i=0, \\dots, N-2$ 且 $b_{N-1} = E\\varepsilon_0$。\n\n然后求解这个非奇异线性系统以获得未知的应力向量 $\\vec{\\sigma}$。\n\n### 3. 误差分析\n在配置节点处，将数值解 $\\sigma_{\\text{num}}(t_k)$ 与精确解 $\\sigma_{\\text{exact}}(t_k)$ 进行比较验证。其准确性由最大范数误差量化：\n$$\ne_\\infty(N) = \\max_{k=0,\\dots,N-1} \\left|\\sigma_{\\text{num}}(t_k) - \\sigma_{\\text{exact}}(t_k)\\right|\n$$\n对于应用于平滑解析函数的谱方法，误差预期会随 $N$ 呈指数衰减，即 $e_\\infty(N) \\propto a^N$，其中基底 $a \\in (0,1)$。我们使用两次离散化 $N_1=32$ 和 $N_2=64$ 的误差来估计这个基底因子：\n$$\na \\approx \\left(\\frac{e_\\infty(N_2)}{e_\\infty(N_1)}\\right)^{\\frac{1}{N_2 - N_1}}\n$$\n这个因子量化了谱收敛的速度。较小的 $a$ 值表示更快的收敛速度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix for N CGL nodes.\n    \n    Args:\n        N (int): The number of collocation points (polynomial degree N-1).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (N, N) differentiation matrix.\n            - x (np.ndarray): The (N,) array of CGL nodes from 1 down to -1.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.]]), np.array([0.])\n    \n    # CGL nodes x_j = cos(j*pi/(N-1)) for j=0..N-1\n    # This creates nodes ordered from 1 down to -1.\n    j = np.arange(N)\n    x = np.cos(j * np.pi / (N - 1))\n    \n    # c_j factors\n    c = np.ones(N)\n    c[0] = 2.\n    c[N-1] = 2.\n    \n    # Compute off-diagonal entries\n    D = np.zeros((N, N))\n    x_diff = x[:, np.newaxis] - x[np.newaxis, :]\n    np.fill_diagonal(x_diff, 1.) # Avoid division by zero on diagonal\n    \n    c_ratio = c[:, np.newaxis] / c[np.newaxis, :]\n    \n    indices = np.arange(N)\n    sign = (-1)**(indices[:, np.newaxis] + indices[np.newaxis, :])\n    \n    D = c_ratio * sign / x_diff\n    \n    # Compute diagonal entries using sum rule\n    np.fill_diagonal(D, 0.)\n    D -= np.diag(np.sum(D, axis=1))\n    \n    return D, x\n\ndef solve_maxwell_spectral(E, eta, eps0, T, N_list):\n    \"\"\"\n    Solves the Maxwell stress relaxation problem using a spectral method.\n\n    Args:\n        E (float): Elastic modulus (Pa).\n        eta (float): Viscosity (Pa.s).\n        eps0 (float): Strain magnitude (dimensionless).\n        T (float): Final time (s).\n        N_list (list[int]): List of discretization sizes to evaluate.\n\n    Returns:\n        list[float]: A list containing max-norm errors for each N in N_list,\n                     followed by the empirical convergence factor 'a'.\n    \"\"\"\n    results_for_case = []\n    errors = {}\n    \n    tau = eta / E  # Maxwell relaxation time\n    sigma0 = E * eps0  # Initial stress at t=0\n\n    for N in N_list:\n        # 1. Get differentiation matrix D and nodes x in [-1, 1]\n        D_cheb, x_cheb = chebyshev_diff_matrix(N)\n        \n        # 2. Map nodes to time domain [0, T]. x_cheb runs 1 to -1, so t runs T to 0.\n        t_nodes = 0.5 * T * (x_cheb + 1)\n        \n        # 3. Form the linear operator matrix L\n        # ODE: d(sigma)/dt + (1/tau)*sigma = 0\n        # Time derivative operator on [0, T] is (2/T)*D_cheb\n        L = (2.0 / T) * D_cheb + (1.0 / tau) * np.identity(N)\n        \n        # 4. Set up RHS vector and apply initial condition via tau-enforcement\n        # The initial condition is at t=0, which is the last node (index N-1)\n        # where x = -1. We replace the last row of the system.\n        b = np.zeros(N)\n        \n        L[N-1, :] = 0.0\n        L[N-1, N-1] = 1.0\n        b[N-1] = sigma0\n        \n        # 5. Solve the linear system L * sigma_vec = b\n        sigma_num = np.linalg.solve(L, b)\n        \n        # 6. Compute exact solution for comparison\n        sigma_exact = sigma0 * np.exp(-t_nodes / tau)\n        \n        # 7. Compute max-norm error\n        e_inf = np.max(np.abs(sigma_num - sigma_exact))\n        errors[N] = e_inf\n        results_for_case.append(e_inf)\n        \n    # 8. Compute empirical convergence factor 'a'\n    e_inf_n1 = errors[32]\n    e_inf_n2 = errors[64]\n    \n    if e_inf_n1 > 0 and e_inf_n2 > 0:\n        a = (e_inf_n2 / e_inf_n1)**(1.0 / (64 - 32))\n    else:\n        # Convergence is faster than machine precision can resolve\n        a = 0.0 \n        \n    results_for_case.append(a)\n    \n    return results_for_case\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: happy path\n        {'E': 3.0e10, 'eta': 3.0e18, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case B: fast relaxation\n        {'E': 3.0e10, 'eta': 3.0e16, 'eps0': 1.0e-5, 'T': 1.0e7},\n        # Case C: slow relaxation\n        {'E': 3.0e10, 'eta': 3.0e20, 'eps0': 1.0e-5, 'T': 1.0e7},\n    ]\n    N_list = [8, 16, 32, 64]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = solve_maxwell_spectral(\n            case_params['E'], case_params['eta'], case_params['eps0'],\n            case_params['T'], N_list\n        )\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    inner_lists_str = []\n    for case_result in all_results:\n        # Format each inner list: [val1,val2,val3]\n        inner_str = f\"[{','.join(map(str, case_result))}]\"\n        inner_lists_str.append(inner_str)\n    \n    # Combine the inner lists into the final outer list format: [[...],[...]]\n    final_output_str = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了正演模型之后，下一步是理解模型选择对数据解释的影响，这是计算地球物理学中的一个核心议题。这个练习设计了一个计算实验，探讨当我们使用一个简化的模型（麦克斯韦模型）来解释由一个更复杂的、“真实”的物理过程（伯格斯模型）产生的数据时会发生什么。通过量化模型不匹配所导致的粘滞系数反演偏差，本练习揭示了模型假设在科学研究中的重要性及其对最终结论的潜在影响。",
            "id": "3613161",
            "problem": "您需要实现一个独立的计算实验，该实验旨在量化在使用一个错误指定的Maxwell流变模型反演由三维均匀Burgers粘弹性地幔产生的震后地表位移时间序列时出现的模型不匹配偏差。其几何结构为一个单一的线性八节点六面体有限元，代表一个均匀的地幔体积，其底部固定，顶部表面施加均匀的剪切牵引力。根据对称性和均匀性，变形可简化为均匀的简单剪切，但您的推导和实现必须从三维小应变线性粘弹性和准静态平衡出发，并与之保持一致。\n\n使用的基本原理：\n- 准静态线性动量平衡：$\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$，边界上具有指定的牵引力和位移，忽略惯性。\n- 小应变运动学：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right)$。\n- 线性粘弹性对应原理和力学模型：一个Maxwell单元是一个剪切模量为$\\mu$的线性弹簧与一个粘度为$\\eta$的阻尼器串联；一个Kelvin单元是一个剪切模量为$\\mu$的线性弹簧与一个粘度为$\\eta$的阻尼器并联；一个Burgers单元是一个Maxwell单元与一个Kelvin单元串联。\n- 对于简单剪切，偏应力简化为标量剪切应力$\\tau$和剪切应变$\\gamma$，这与均匀状态下的三维各向同性线性粘弹性理论一致。\n\n物理配置：\n- 一个在$z$方向高度为$H$的六面体单元，其底面位于$z = 0$处固定（$\\mathbf{u} = \\mathbf{0}$），顶面位于$z = H$处在时间$t \\ge 0$时受到一个均匀的剪切牵引力$\\mathbf{t} = (\\tau_{0}, 0, 0)$（沿$x$方向剪切）。\n- 材料具有Burgers流变性，其特征由Maxwell分支参数$(\\mu_{M}, \\eta_{M})$和Kelvin分支参数$(\\mu_{K}, \\eta_{K})$描述。假设材料是各向同性的，并且对于给定的纯剪切加载，体积效应无关紧要。\n\n任务：\n1. 从上述控制方程出发，证明在所述的均匀剪切牵引力作用下，单元经历空间上均匀的简单剪切，使得唯一的非零应力分量是$\\sigma_{xz}(t) = \\tau_{0}$，唯一的非零应变分量是$\\varepsilon_{xz}(t) = \\tfrac{1}{2}\\gamma(t)$。利用线性粘弹性对应关系，将三维问题简化为由串联的Burgers力学模型控制的标量剪切关系$\\tau(t)$和$\\gamma(t)$。在阶跃剪切应力$\\tau(t) = \\tau_{0} H(t)$（其中$H(t)$是亥维赛阶跃函数）作用下，仅使用Maxwell和Kelvin单元的定义以及基础微积分，仔细推导$\\gamma(t)$的演化方程。不要假设任何已知的封闭形式解；请自行推导。\n2. 将顶面在$x$方向的水平位移表示为时间函数$u(t)$（单位：米），用均匀剪切应变$\\gamma(t)$和高度$H$表示。\n3. 定义一个错误指定的反演，该反演假设一个Maxwell流变模型，其瞬时弹性柔量已知且等于真实的Burgers瞬时柔量（因此截距是固定的）。具体来说，将Maxwell预测的位移建模为$u_{\\text{Mx}}(t) = u_{0} + s\\, t$，其中$u_{0}$是您从Burgers模型在$t=0^{+}$时推导出的瞬时位移，而$s$是一个常数斜率，通过对给定时间窗口内的Burgers生成的$u(t)$进行最小二乘拟合来确定。从拟合的斜率$\\hat{s}$，推断出Maxwell粘度估计值$\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$。\n4. 对下面的每个测试案例，量化相对粘度偏差$b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$。\n\n数值和单位要求：\n- 时间$t$的单位是秒（s）。\n- 剪切模量参数$\\mu_{M}$和$\\mu_{K}$的单位是帕斯卡（$\\mathrm{Pa}$）。\n- 粘度参数$\\eta_{M}$和$\\eta_{K}$的单位是帕斯卡-秒（$\\mathrm{Pa \\cdot s}$）。\n- 剪切牵引力$\\tau_{0}$的单位是帕斯卡（$\\mathrm{Pa}$）。\n- 高度$H$的单位是米（$\\mathrm{m}$）。\n- 顶部-位移$u(t)$必须以米（$\\mathrm{m}$）表示。\n- 最终报告的偏差$b$是无量纲的，必须打印为小数点后六位四舍五入的十进制浮点数。\n\n实现要求：\n- 实现一个程序，该程序：\n  - 在$t_{\\min}$和$t_{\\max}$（含）之间的$N$个均匀间隔的时间样本$t_{i}$上，计算Burgers生成的位移时间序列$u(t_{i})$。其中$t_{\\min}  0$。\n  - 使用最小二乘法将$u_{\\text{Mx}}(t) = u_{0} + s t$的斜率$\\hat{s}$拟合到Burgers的$u(t)$值（截距$u_{0}$从真实的瞬时位移固定）。\n  - 计算$\\hat{\\eta} = \\dfrac{\\tau_{0} H}{\\hat{s}}$和偏差$b = \\dfrac{\\hat{\\eta} - \\eta_{M}}{\\eta_{M}}$。\n\n测试套件：\n对于每个案例，使用指定的参数和时间窗口。所有常数必须完全按照给定的值使用。\n\n- 案例1（平衡窗口）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{K} = 3.0 \\times 10^{18}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0\\ \\text{天} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0\\ \\text{年} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n- 案例2（长窗口）：\n  - 材料和加载与案例1相同，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 50.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 100$。\n\n- 案例3（短窗口）：\n  - 材料和加载与案例1相同，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 0.1 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 30$。\n\n- 案例4（Kelvin阻尼器有效刚性，接近纯Maxwell行为）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{K} = 1.0 \\times 10^{25}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n- 案例5（软Kelvin弹簧，瞬态缓慢）：\n  - $\\mu_{M} = 3.0 \\times 10^{10}\\ \\mathrm{Pa}$，$\\eta_{M} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\mu_{K} = 5.0 \\times 10^{9}\\ \\mathrm{Pa}$，$\\eta_{K} = 1.0 \\times 10^{19}\\ \\mathrm{Pa \\cdot s}$，\n  - $\\tau_{0} = 1.0 \\times 10^{3}\\ \\mathrm{Pa}$，$H = 5.0 \\times 10^{4}\\ \\mathrm{m}$，\n  - $t_{\\min} = 1.0 \\times 86400\\ \\mathrm{s}$，$t_{\\max} = 5.0 \\times 365.25 \\times 86400\\ \\mathrm{s}$，$N = 50$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个相对偏差$b$，以逗号分隔的列表形式，并用方括号括起来，按案例1到5的顺序排列，每个偏差四舍五入到小数点后六位（例如，$[0.123456,-0.000001,0.002345,0.000000,-0.543210]$）。",
            "solution": "该问题要求在计算地球物理学的背景下，对模型不匹配偏差进行定量分析。具体而言，我们需要使用一个简化的粘弹性地幔一维表示来模拟大地震后产生的震后地壳形变。真实的地球由一个Burgers流变模型表示，而一个不正确、更简单的Maxwell模型被用于反演。我们必须推导出“真实”模型的解析解，实现一个数值实验来拟合“不正确”的模型，并量化由此产生的推断粘度的偏差。\n\n### **1. 从三维粘弹性到一维简单剪切的推导**\n\n该问题在三维、准静态、小应变、线性粘弹性的框架内定义。\n\n**控制方程：**\n忽略惯性力的准静态动量平衡方程为：\n$$ \\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0} $$\n其中$\\boldsymbol{\\sigma}$是柯西应力张量。小应变运动学关系为：\n$$ \\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}}\\right) $$\n其中$\\mathbf{u}$是位移矢量，$\\boldsymbol{\\varepsilon}$是无穷小应变张量。\n\n**问题几何与边界条件：**\n几何结构是一个高度为$H$的层，其底部在$z=0$处固定（$\\mathbf{u}=\\mathbf{0}$），其顶部在$z=H$处在时间$t \\ge 0$时受到一个沿$x$轴方向的均匀剪切牵引力$\\mathbf{t} = (\\tau_0, 0, 0)$。\n\n**简化为简单剪切：**\n根据对称性，我们可以假设一个形式为$\\mathbf{u} = (u_x(z, t), 0, 0)$的位移场。只要$u_x(0,t) = 0$，这个拟设就与边界条件一致。\n应变张量$\\boldsymbol{\\varepsilon}$的分量则为：\n$$ \\varepsilon_{xz} = \\varepsilon_{zx} = \\frac{1}{2} \\frac{\\partial u_x}{\\partial z} $$\n$\\boldsymbol{\\varepsilon}$的所有其他分量均为零。对于一个经受纯剪切应变的各向同性线性粘弹性材料，其产生的应力张量也将是纯剪切应力。因此，唯一的非零应力分量是$\\sigma_{xz}$和$\\sigma_{zx}$。\n\n动量平衡方程$\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$大大简化。$y$和$z$分量不言自明地满足（$0=0$）。$x$分量变为：\n$$ \\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\sigma_{xy}}{\\partial y} + \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 \\implies \\frac{\\partial \\sigma_{xz}}{\\partial z} = 0 $$\n这意味着$\\sigma_{xz}$不随深度$z$变化；它仅是时间的函数，即$\\sigma_{xz}(t)$。\n\n具有单位法向量$\\mathbf{n}$的表面上的牵引力矢量由$\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$给出。在顶面$z=H$处，法向量为$\\mathbf{n}=(0,0,1)$。牵引力为：\n$$ \\mathbf{t}|_{z=H} = (\\sigma_{xz}(t), \\sigma_{yz}(t), \\sigma_{zz}(t)) $$\n给定在$t \\ge 0$时规定的牵引力$\\mathbf{t} = (\\tau_0, 0, 0)$，我们必须有$\\sigma_{xz}(t) = \\tau_0$。由于$\\sigma_{xz}$与$z$无关，这个剪切应力值在$t0$时适用于整个层。\n\n材料是均匀的。由于应力$\\sigma_{xz}(t) = \\tau_0$在空间上是均匀的，因此产生的应变$\\varepsilon_{xz}(t)$也必须是空间上均匀的。我们定义工程剪切应变$\\gamma(t)$，使得$\\varepsilon_{xz}(t) = \\frac{1}{2}\\gamma(t)$。因此：\n$$ \\frac{1}{2}\\frac{\\partial u_x}{\\partial z} = \\frac{1}{2}\\gamma(t) \\implies \\frac{d u_x}{d z} = \\gamma(t) $$\n对$z$积分得到$u_x(z, t) = \\gamma(t) z + C(t)$。应用固定底部边界条件$u_x(0,t)=0$，我们发现积分常数$C(t)=0$。这给出了位移场：\n$$ u_x(z,t) = \\gamma(t) z $$\n因此，问题简化为求解均匀剪切应变$\\gamma(t)$在阶跃剪切应力$\\tau(t) = \\sigma_{xz}(t) = \\tau_0 H(t)$（其中$H(t)$是亥维赛阶跃函数）作用下的演化。这对应于对Burgers材料进行的蠕变试验。\n\n### **2. Burgers材料的蠕变响应**\n\n一个Burgers单元由一个Maxwell单元（弹簧$\\mu_M$，阻尼器$\\eta_M$）与一个Kelvin单元（弹簧$\\mu_K$，阻尼器$\\eta_K$并联）串联而成。\n- 对于串联的单元，总应力$\\tau$在每个单元上是相同的，总应变$\\gamma$是每个单元应变的总和：$\\gamma(t) = \\gamma_M(t) + \\gamma_K(t)$。\n- Maxwell单元的应力-应变关系是$\\dot{\\gamma}_M = \\frac{\\dot{\\tau}}{\\mu_M} + \\frac{\\tau}{\\eta_M}$。\n- Kelvin单元的应力-应变关系是$\\tau = \\mu_K \\gamma_K + \\eta_K \\dot{\\gamma}_K$。\n\n我们分析对阶跃应力$\\tau(t) = \\tau_0 H(t)$的响应。对于$t  0$，$\\tau = \\tau_0$是常数，所以$\\dot{\\tau}=0$。\n\n**Maxwell单元应变($\\gamma_M$)：**\nMaxwell单元上的应变是其弹簧和阻尼器应变之和，$\\gamma_M = \\gamma_{M,s} + \\gamma_{M,d}$。\n- 弹性弹簧瞬时响应：$\\gamma_{M,s}(t) = \\tau(t) / \\mu_M = (\\tau_0/\\mu_M) H(t)$。\n- 粘性阻尼器应变率是$\\dot{\\gamma}_{M,d} = \\tau(t) / \\eta_M$。对于$t0$，积分得到$\\gamma_{M,d}(t) = (\\tau_0/\\eta_M) t$。\n所以，对于$t0$，Maxwell应变贡献为$\\gamma_{\\text{on Maxwell}}(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t$。\n\n**Kelvin单元应变($\\gamma_K$)：**\n对于$t0$，Kelvin单元的控制方程是一个一阶线性常微分方程：\n$$ \\eta_K \\dot{\\gamma}_K + \\mu_K \\gamma_K = \\tau_0 $$\n解是$\\gamma_K(t) = \\gamma_{K,p} + \\gamma_{K,h}$，其中$\\gamma_{K,p}$是特解，$\\gamma_{K,h}$是齐次解。\n- 特解是稳态响应，$\\gamma_{K,p} = \\tau_0 / \\mu_K$。\n- 齐次解是$\\gamma_{K,h}(t) = C e^{-(\\mu_K/\\eta_K)t}$。\n通解是$\\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} + C e^{-t/t_R}$，其中$t_R = \\eta_K/\\mu_K$是推迟时间。\n初始条件是Kelvin单元由于其阻尼器不能瞬时变形，所以$\\gamma_K(0^+) = 0$。\n$0 = \\frac{\\tau_0}{\\mu_K} + C \\implies C = -\\frac{\\tau_0}{\\mu_K}$。\nKelvin单元在$t0$时的应变为：\n$$ \\gamma_K(t) = \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) $$\n\n**总Burgers应变和位移：**\n总应变是Maxwell和Kelvin单元应变之和。注意，Maxwell弹簧的弹性应变提供了Burgers体的全部瞬时弹性响应。\n$$ \\gamma(t) = \\gamma_{M,s}(t) + \\gamma_{M,d}(t) + \\gamma_K(t) = \\frac{\\tau_0}{\\mu_M} + \\frac{\\tau_0}{\\eta_M} t + \\frac{\\tau_0}{\\mu_K} \\left(1 - e^{-t/t_R}\\right) \\quad \\text{for } t  0 $$\n顶面位移是$u(t) = u_x(H, t) = \\gamma(t) H$：\n$$ u(t) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + \\frac{t}{\\eta_M} + \\frac{1}{\\mu_K} \\left(1 - e^{-t/(\\eta_K/\\mu_K)}\\right) \\right] $$\n\n### **3. 错误指定的Maxwell模型反演**\n\n我们现在用一个简化的Maxwell模型来拟合由Burgers模型生成的“真实”位移数据$u(t)$。由Maxwell模型预测的位移是：\n$$ u_{\\text{Mx}}(t) = \\frac{\\tau_0 H}{\\mu_{\\text{Mx}}} + \\frac{\\tau_0 H}{\\eta_{\\text{Mx}}} t $$\n这是一个关于时间的线性函数。问题规定反演假设瞬时弹性响应是已知的。Burgers模型在$t \\to 0^+$时的瞬时位移是：\n$$ u_0 = u(0^+) = \\tau_0 H \\left[ \\frac{1}{\\mu_M} + 0 + \\frac{1}{\\mu_K}(1-1) \\right] = \\frac{\\tau_0 H}{\\mu_M} $$\n我们将我们线性模型的截距固定为这个真值，所以我们的拟合模型是$u_{\\text{fit}}(t) = u_0 + s t$。斜率$s$是对$\\frac{\\tau_0 H}{\\eta_{\\text{Mx}}}$的估计。\n\n我们通过最小化在一组时间样本$\\{t_i\\}_{i=1}^N$上真实位移$u(t_i)$与模型$u_{\\text{fit}}(t_i)$之间的残差平方和来确定最佳拟合斜率$\\hat{s}$。我们正在用模型$y(t) = st$来拟合数据$d(t) = u(t) - u_0$。最小二乘泛函是：\n$$ S(s) = \\sum_{i=1}^N \\left( d(t_i) - s t_i \\right)^2 $$\n设$\\frac{dS}{ds} = 0$给出最优斜率$\\hat{s}$：\n$$ \\hat{s} = \\frac{\\sum_{i=1}^N t_i d(t_i)}{\\sum_{i=1}^N t_i^2} = \\frac{\\sum_{i=1}^N t_i (u(t_i) - u_0)}{\\sum_{i=1}^N t_i^2} $$\n从这个拟合的斜率$\\hat{s}$，我们使用关系$\\hat{s} = \\frac{\\tau_0 H}{\\hat{\\eta}}$来推断表观Maxwell粘度$\\hat{\\eta}$，这给出：\n$$ \\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}} $$\n\n### **4. 粘度偏差与数值实现**\n\n粘度的相对偏差是推断粘度$\\hat{\\eta}$与Burgers模型Maxwell分支的真实长期粘度$\\eta_M$之间的归一化差异：\n$$ b = \\frac{\\hat{\\eta} - \\eta_M}{\\eta_M} $$\n\n每个测试案例的计算步骤如下：\n1. 定义所有物理参数$(\\mu_M, \\eta_M, \\mu_K, \\eta_K, \\tau_0, H)$和时间窗口参数$(t_{\\min}, t_{\\max}, N)$。\n2. 从$t_{\\min}$到$t_{\\max}$生成$N$个均匀间隔的时间样本$t_i$。\n3. 计算恒定的瞬时位移$u_0 = \\frac{\\tau_0 H}{\\mu_M}$。\n4. 对每个时间样本$t_i$，使用推导的解析公式计算真实的Burgers位移$u(t_i)$。\n5. 计算待拟合的数据：$d_i = u(t_i) - u_0$。\n6. 使用通过原点的回归的最小二乘公式计算最佳拟合斜率$\\hat{s}$。\n7. 计算推断的粘度$\\hat{\\eta} = \\frac{\\tau_0 H}{\\hat{s}}$。\n8. 计算并存储相对偏差$b = (\\hat{\\eta} - \\eta_M) / \\eta_M$。\n对所有五个测试案例重复此过程。最终输出是计算出的偏差列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bias(params):\n    \"\"\"\n    Calculates the relative viscosity bias for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The calculated relative viscosity bias.\n    \"\"\"\n    mu_M = params['mu_M']\n    eta_M = params['eta_M']\n    mu_K = params['mu_K']\n    eta_K = params['eta_K']\n    tau_0 = params['tau_0']\n    H = params['H']\n    t_min = params['t_min']\n    t_max = params['t_max']\n    N = params['N']\n\n    # 1. Generate N uniformly spaced time samples from t_min to t_max.\n    t_samples = np.linspace(t_min, t_max, N)\n\n    # 2. Calculate the true instantaneous displacement u_0.\n    # This corresponds to the instantaneous elastic response of the Maxwell spring.\n    u_0 = (tau_0 * H) / mu_M\n\n    # 3. Calculate the \"true\" displacement time series u(t) from the Burgers model.\n    # The displacement u(t) is H * gamma(t), where gamma is the total strain.\n    # gamma(t) = instantaneous_elastic + viscous_flow + transient_creep\n    #            (Maxwell spring)     (Maxwell dashpot) (Kelvin element)\n    \n    # Retardation time of the Kelvin element\n    # Guard against division by zero, although not needed for the given test cases.\n    if mu_K == 0.0:\n        # If mu_K is 0, the Kelvin element is just a dashpot. Its strain is (tau_0*t)/eta_K.\n        term_kelvin_strain = (tau_0 / eta_K) * t_samples\n    else:\n        t_R = eta_K / mu_K\n        term_kelvin_strain = (tau_0 / mu_K) * (1.0 - np.exp(-t_samples / t_R))\n    \n    # Total strain combines Maxwell and Kelvin responses\n    gamma_t = (tau_0 / mu_M) + (tau_0 / eta_M) * t_samples + term_kelvin_strain\n    \n    # Total displacement at the top surface\n    u_t = H * gamma_t\n    \n    # 4. Perform least squares to fit the slope of u_Mx(t) = u_0 + s*t.\n    # Since u_0 is fixed, we are fitting a line through the origin to the data d(t) = u(t) - u_0.\n    # The data to be fitted is the displacement minus the instantaneous part.\n    d_t = u_t - u_0\n    \n    # The least-squares solution for the slope s_hat is (t dot d) / (t dot t).\n    s_hat = np.dot(t_samples, d_t) / np.dot(t_samples, t_samples)\n    \n    # 5. Infer the apparent Maxwell viscosity eta_hat from the fitted slope s_hat.\n    # The slope of a pure Maxwell model is s = (tau_0 * H) / eta_Mx.\n    eta_hat = (tau_0 * H) / s_hat\n    \n    # 6. Calculate the relative viscosity bias.\n    bias = (eta_hat - eta_M) / eta_M\n    \n    return bias\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment for all test cases.\n    \"\"\"\n    S_PER_DAY = 86400.0\n    S_PER_YEAR = 365.25 * S_PER_DAY\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (balanced window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 2 (long window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 50.0 * S_PER_YEAR, 'N': 100\n        },\n        # Case 3 (short window)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 3.0e18,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 0.1 * S_PER_YEAR, 'N': 30\n        },\n        # Case 4 (Kelvin dashpot effectively rigid)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 3.0e10, 'eta_K': 1.0e25,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        },\n        # Case 5 (soft Kelvin spring with slow transient)\n        {\n            'mu_M': 3.0e10, 'eta_M': 1.0e19, 'mu_K': 5.0e9, 'eta_K': 1.0e19,\n            'tau_0': 1.0e3, 'H': 5.0e4,\n            't_min': 1.0 * S_PER_DAY, 't_max': 5.0 * S_PER_YEAR, 'N': 50\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bias = calculate_bias(case_params)\n        results.append(bias)\n\n    # Format the final results as specified in the problem statement.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the simulation.\nsolve()\n```"
        },
        {
            "introduction": "在理解了正演建模和模型选择的重要性之后，本章的最终实践将引导你构建现代地球物理反演的核心引擎。本练习聚焦于开发一种系统而高效地寻找最佳模型参数（如此处空间变化的粘滞系数）以拟合观测数据的强大工具——伴随方法（adjoint method）。通过从第一性原理推导并实现离散伴随状态方程，你将掌握梯度优化在地球科学大规模反演问题中的应用精髓。",
            "id": "3613152",
            "problem": "考虑一个一维平面剪切准静态麦克斯韦粘弹性杆，其占据域 $x \\in [0,L]$，剪切方向位移为 $u(x,t)$，剪切应力为 $\\tau(t)$，剪切应变为 $\\gamma(x,t) = \\partial u/\\partial x$。应力平衡方程简化为 $\\partial \\tau/\\partial x = 0$，因此 $\\tau$ 在空间上是均匀的。剪切的麦克斯韦本构关系为 $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$，其中 $\\eta(x)  0$ 是空间可变的粘度，$G  0$ 是剪切模量。边界条件为 $u(0,t)=0$ 和 $u(L,t) = U(t)$，其中 $U(t)$ 是给定的、光滑的，并且从0开始单调递增。\n\n基础。从准静态力平衡和麦克斯韦本构定律开始：\n- 力平衡：$\\nabla \\cdot \\sigma = 0$；在一维剪切中，$\\partial \\tau/\\partial x = 0$。\n- 运动学：$\\gamma = \\partial u/\\partial x$，$u(0,t)=0$，$u(L,t)=U(t)$。\n- 本构（麦克斯韦剪切模型）：$\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$。\n\n证明边界条件导出了关于 $\\tau(t)$ 的常微分方程：\n$$\n\\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t), \\quad \\alpha \\equiv \\frac{1}{L}\\int_{0}^{L} \\frac{1}{\\eta(x)}\\, dx,\n$$\n在假设 $u(x,0)=0$ 和 $\\tau(0)=0$ 的条件下。设观测算子在固定的位置集 $x_i$（$i \\in \\mathcal{I}$，$0  x_i  L$）上收集内部位移。在时间窗口 $t \\in [0,T]$ 上定义失配泛函：\n$$\nJ[\\eta] = \\frac{1}{2} \\int_{0}^{T} w_t(t) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u(x_i,t) - d(x_i,t)\\right)^2 \\, dt,\n$$\n其中 $d(x_i,t)$ 是由已知的参考粘度场 $\\eta_{\\mathrm{true}}(x)$ 和相同的边界强迫 $U(t)$ 合成的观测位移；$w_t(t) \\ge 0$ 和 $w_x(x_i) \\ge 0$ 分别是权重，它们在时间 $t$ 和位置上的积分（或求和）为1。你需要计算 $J$ 关于参数场 $\\phi(x) = \\log \\eta(x)$ 的梯度。\n\n离散化要求。在 $[0,L]$ 上使用包含 $N_x$ 个单元的均匀空间网格，在 $[0,T]$ 上使用包含 $N_t$ 个时间步的均匀时间网格。对时间上的应力演化和本构更新使用后向欧拉法：\n- 应力更新：对于时间步长为 $\\Delta t$ 的第 $n$ 个时间步，$\\tau_n$ 由下式定义\n$$\n\\frac{\\tau_n - \\tau_{n-1}}{\\Delta t} + G \\alpha \\, \\tau_n = \\frac{G}{L}\\, \\dot{U}_n,\n$$\n其中 $\\dot{U}_n \\approx \\dot{U}(t_n)$，$\\alpha = \\frac{1}{L} \\sum_{j=1}^{N_x} \\Delta x \\, e^{-\\phi_j}$，$\\Delta x = L/N_x$，且 $\\phi_j = \\log \\eta_j$ 位于单元中心 $x_j$。\n- 应变更新：对于每个空间单元 $j$，\n$$\n\\gamma_j^n - \\gamma_j^{n-1} = \\Delta t \\, \\tau_n \\, e^{-\\phi_j} + \\frac{\\tau_n - \\tau_{n-1}}{G}.\n$$\n- 从应变计算位移：对于位置 $x_i$ 的网格节点 $i$，近似为\n$$\nu_i^n = \\sum_{m=1}^{i} \\gamma_m^n \\, \\Delta x, \\quad u_0^n = 0.\n$$\n- 观测：取一个固定的索引集 $\\mathcal{I} \\subset \\{1,\\dots,N_x-1\\}$，对应于内部节点。\n\n伴随推导目标。推导与应变更新相关的乘子 $\\mu_j^n$ 和与应力更新相关的乘子 $\\lambda_n$ 的离散伴随递推关系，并说明它们如何产生梯度 $\\partial J / \\partial \\phi_j$。你的推导必须从由离散正向方程和 $J$ 构建的拉格朗日量开始。不要使用任何已知的伴随公式；通过取变分并强制驻定性从第一性原理进行推导。\n\n无量纲化。在无量纲单位下进行计算。设 $L=1$，并取\n- $G = 10$，\n- $U(t) = U_{\\max} \\left(1 - e^{-t/T_0}\\right)$，其中 $U_{\\max} = 1$，$T_0 = 0.5$，\n- 时间网格参数 $N_t = 250$，$\\Delta t = 0.02$，因此 $T = N_t \\Delta t = 5$，\n- 空间网格参数 $N_x = 64$。\n\n权重。对所有时间步使用 $w_t(t_n) = 1/N_t$，对所有观测节点使用 $w_x(x_i) = 1/|\\mathcal{I}|$。\n\n观测。对于下面的每个测试用例，定义一个参考场 $\\phi_{\\mathrm{true}}(x)$，通过使用 $\\phi_{\\mathrm{true}}$ 运行一次正向模型来合成 $d(x_i,t_n)$，然后为另一个当前场 $\\phi(x)$ 计算失配和梯度。\n\n测试套件。实现以下三个测试用例（全部在无量纲单位下）：\n- 用例1（平滑对比度）：$\\phi_{\\mathrm{true}}(x) = \\log \\eta_0 + a \\sin(2\\pi x)$，其中 $\\eta_0 = 1$，$a = \\log 3$。当前场 $\\phi(x) = \\log \\eta_0 + b \\cos(2\\pi x)$，其中 $b = \\log 2$。\n- 用例2（均匀）：$\\phi_{\\mathrm{true}}(x) = \\log 2$，当前场 $\\phi(x) = \\log 1$。\n- 用例3（阶跃）：$\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{low}}$ 对于 $x  0.3$，$\\phi_{\\mathrm{true}}(x) = \\log \\eta_{\\mathrm{high}}$ 对于 $x \\ge 0.3$，其中 $\\eta_{\\mathrm{low}} = 0.5$，$\\eta_{\\mathrm{high}} = 5$。当前场 $\\phi(x) = \\log \\eta_{\\mathrm{high}}$ 对于 $x  0.3$，$\\phi(x) = \\log \\eta_{\\mathrm{low}}$ 对于 $x \\ge 0.3$。\n\n观测节点。使用最接近 $x \\in \\{0.25, 0.5, 0.75\\}$ 的内部节点，即选择这些索引作为 $\\mathcal{I}$。\n\n通过方向导数进行验证。除了计算梯度向量 $g_j = \\partial J/\\partial \\phi_j$ 外，还需通过计算沿方向 $v_j = \\cos(2\\pi x_j)$ 的方向有限差分检验来验证伴随方法：\n$$\n\\mathrm{FD} = \\frac{J(\\phi + \\varepsilon v) - J(\\phi)}{\\varepsilon}, \\quad \\varepsilon = 10^{-6}, \\quad \\mathrm{AD} = \\sum_{j=1}^{N_x} g_j v_j,\n$$\n并报告绝对误差 $|\\mathrm{FD} - \\mathrm{AD}|$。\n\n程序要求。你的程序必须：\n- 实现推导出的正向求解器、离散伴随求解器和梯度组装。\n- 对于三个测试用例中的每一个，输出一个包含三个浮点数的列表：失配 $J$、欧几里得范数 $\\|g\\|_2$ 和绝对伴随检验误差 $|\\mathrm{FD}-\\mathrm{AD}|$。\n- 生成单行输出，包含结果，格式为一个逗号分隔的列表，其中包含三个用例各自的列表，并用方括号括起来，例如 $[[J_1,\\|g\\|_1,E_1],[J_2,\\|g\\|_2,E_2],[J_3,\\|g\\|_3,E_3]]$。\n\n角度单位不适用。所有量都是无量纲的，因此你的答案中不需要物理单位。通过遵守指定的后向欧拉更新来确保数值稳定性。输出必须是数值计算的结果，而不是符号简化的结果。最终输出必须是指定格式的单行文本。",
            "solution": "该问题要求推导离散伴随方程，以计算失配泛函 $J$ 关于空间变化粘度场的对数 $\\phi(x) = \\log \\eta(x)$ 的梯度。物理系统是一个一维麦克斯韦粘弹性杆。推导必须从第一性原理出发，使用拉格朗日方法。\n\n首先，我们验证空间均匀剪切应力 $\\tau(t)$ 的控制常微分方程（ODE）。麦克斯韦本构关系由 $\\dot{\\gamma}(x,t) = \\tau(t)/\\eta(x) + \\dot{\\tau}(t)/G$ 给出。对 $x$ 从 $0$ 到 $L$ 积分：\n$$ \\int_0^L \\dot{\\gamma}(x,t) \\, dx = \\int_0^L \\left(\\frac{\\tau(t)}{\\eta(x)} + \\frac{\\dot{\\tau}(t)}{G}\\right) dx $$\n左侧，使用运动学关系 $\\gamma = \\partial u/\\partial x$ 并交换积分和时间导数的顺序，得到：\n$$ \\int_0^L \\frac{\\partial \\dot{u}}{\\partial x} \\, dx = \\dot{u}(L,t) - \\dot{u}(0,t) $$\n使用边界条件 $u(0,t)=0$ 和 $u(L,t)=U(t)$，这简化为 $\\dot{U}(t)$。右侧变为：\n$$ \\tau(t) \\int_0^L \\frac{1}{\\eta(x)} \\, dx + \\frac{\\dot{\\tau}(t)}{G} \\int_0^L dx = \\tau(t) (L \\alpha) + \\frac{\\dot{\\tau}(t)}{G} L $$\n其中 $\\alpha \\equiv \\frac{1}{L}\\int_0^L \\frac{1}{\\eta(x)} \\, dx$。令两侧相等得到 $\\dot{U}(t) = L\\alpha\\tau(t) + \\frac{L}{G}\\dot{\\tau}(t)$。整理并乘以 $G/L$ 得到目标ODE：\n$$ \\dot{\\tau}(t) + G \\alpha \\, \\tau(t) = \\frac{G}{L}\\, \\dot{U}(t) $$\n初始条件 $u(x,0)=0$ 和 $\\tau(0)=0$ 与此模型一致。\n\n问题的核心是推导离散伴随方程。我们首先定义离散正向模型和失配泛函。设 $n=1, \\dots, N_t$ 为时间步索引，$j=0, \\dots, N_x-1$ 为空间单元索引。节点由 $i=0, \\dots, N_x$ 索引。参数场为 $\\phi_j = \\log \\eta_j$。\n\n离散正向模型方程，整理为零，定义了约束 $R=0$：\n1. 应力更新（$n=1, \\dots, N_t$）：\n   $$ R_{\\tau, n} \\equiv \\left(1+G\\alpha \\Delta t\\right)\\tau_n - \\tau_{n-1} - \\frac{G\\Delta t}{L} \\dot{U}_n = 0 $$\n   其中 $\\alpha = \\frac{\\Delta x}{L} \\sum_{j=0}^{N_x-1} e^{-\\phi_j}$。\n2. 应变更新（$j=0, \\dots, N_x-1, n=1, \\dots, N_t$）：\n   $$ R_{\\gamma, j, n} \\equiv \\gamma_j^n - \\gamma_j^{n-1} - \\Delta t \\tau_n e^{-\\phi_j} - \\frac{1}{G}(\\tau_n - \\tau_{n-1}) = 0 $$\n3. 位移计算（$i \\in \\mathcal{I}, n=1, \\dots, N_t$）：\n   $$ R_{u, i, n} \\equiv u_i^n - \\Delta x \\sum_{m=0}^{i-1} \\gamma_m^n = 0 $$\n离散失配泛函为：\n$$ J = \\frac{1}{2} \\sum_{n=1}^{N_t} w_t(t_n) \\sum_{i \\in \\mathcal{I}} w_x(x_i) \\left(u_i^n - d_i^n\\right)^2 $$\n其中 $d_i^n$ 是合成数据。\n\n拉格朗日量 $\\mathcal{L}$ 是通过将 $J$ 与约束增广而构建的，约束由拉格朗日乘子 $\\lambda_n$（对应应力）、$\\mu_j^n$（对应应变）和 $\\nu_i^n$（对应位移）加权：\n$$ \\mathcal{L} = J + \\sum_{n=1}^{N_t} \\lambda_n R_{\\tau, n} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n R_{\\gamma, j, n} + \\sum_{n=1}^{N_t} \\sum_{i \\in \\mathcal{I}} \\nu_i^n R_{u, i, n} $$\n伴随方程是通过强制 $\\mathcal{L}$ 对于状态变量 $u_i^n, \\gamma_j^n, \\tau_n$ 的驻定性来推导的。$J$ 关于 $\\phi_k$ 的全变分则由 $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$ 给出。\n\n- **关于 $u_i^n$ ($i \\in \\mathcal{I}$) 的驻定性：** $\\frac{\\partial \\mathcal{L}}{\\partial u_i^n}=0$ 得到伴随源：\n$$ \\frac{\\partial J}{\\partial u_i^n} + \\nu_i^n = 0 \\implies \\nu_i^n = - w_t(t_n) w_x(x_i) (u_i^n - d_i^n) $$\n\n- **关于 $\\gamma_j^n$ 的驻定性：** $\\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n}=0$ 对于 $n=1,\\dots,N_t$。这导出了应变乘子 $\\mu_j^n$ 的反向递推关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\gamma_j^n} = \\mu_j^n - \\mu_j^{n+1} + \\sum_{i \\in \\mathcal{I}} \\nu_i^n \\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = 0 $$\n使用 $\\frac{\\partial R_{u,i,n}}{\\partial \\gamma_j^n} = -\\Delta x \\cdot \\mathbf{1}_{j \\le i-1}$，我们得到：\n$$ \\mu_j^n = \\mu_j^{n+1} + \\Delta x \\sum_{i \\in \\mathcal{I}, i  j} \\nu_i^n $$\n终端条件是 $\\mu_j^{N_t+1} = 0$。我们定义伴随强迫项 $f_j^n = \\Delta x \\sum_{i \\in \\mathcal{I}, i  j} \\nu_i^n$。则 $\\mu_j^n = \\mu_j^{n+1} + f_j^n$。\n\n- **关于 $\\tau_n$ 的驻定性：** $\\frac{\\partial \\mathcal{L}}{\\partial \\tau_n}=0$ 对于 $n=1,\\dots,N_t$。这导出了应力乘子 $\\lambda_n$ 的反向递推关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial \\tau_n} = \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\tau_n} + \\lambda_{n+1} \\frac{\\partial R_{\\tau,n+1}}{\\partial \\tau_n} + \\sum_{j=0}^{N_x-1} \\left( \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\tau_n} + \\mu_j^{n+1} \\frac{\\partial R_{\\gamma,j,n+1}}{\\partial \\tau_n} \\right) = 0 $$\n代入约束残差的导数：\n$$ \\lambda_n (1+G\\alpha \\Delta t) - \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(-\\Delta t e^{-\\phi_j} - 1/G) + \\mu_j^{n+1}(1/G) \\right] = 0 $$\n终端条件是 $\\lambda_{N_t+1}=0$。这可以重排为 $\\lambda_n$ 的反向更新：\n$$ \\lambda_n (1+G\\alpha \\Delta t) = \\lambda_{n+1} + \\sum_{j=0}^{N_x-1} \\left[ \\mu_j^n(\\Delta t e^{-\\phi_j} + 1/G) - \\mu_j^{n+1}/G \\right] $$\n使用 $\\mu_j^{n+1} = \\mu_j^n - f_j^n$，这简化为一个计算上更方便的形式：\n$$ \\lambda_n = (1+G\\alpha \\Delta t)^{-1} \\left( \\lambda_{n+1} + \\Delta t \\sum_{j=0}^{N_x-1} \\mu_j^n e^{-\\phi_j} + \\frac{1}{G} \\sum_{j=0}^{N_x-1} f_j^n \\right) $$\n\n- **梯度计算：** $J$ 关于 $\\phi_k$ 的梯度是 $\\frac{dJ}{d\\phi_k} = \\frac{\\partial \\mathcal{L}}{\\partial \\phi_k}$。\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\lambda_n \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} + \\sum_{n=1}^{N_t} \\sum_{j=0}^{N_x-1} \\mu_j^n \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} $$\n所需的导数是：\n$$ \\frac{\\partial \\alpha}{\\partial \\phi_k} = -\\frac{\\Delta x}{L}e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\tau,n}}{\\partial \\phi_k} = G \\Delta t \\tau_n \\frac{\\partial \\alpha}{\\partial \\phi_k} = -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} $$\n$$ \\frac{\\partial R_{\\gamma,j,n}}{\\partial \\phi_k} = - \\Delta t \\tau_n \\frac{\\partial e^{-\\phi_j}}{\\partial \\phi_k} = \\Delta t \\tau_n e^{-\\phi_j} \\delta_{jk} $$\n将这些代入梯度的表达式中得到：\n$$ \\frac{dJ}{d\\phi_k} = \\sum_{n=1}^{N_t} \\left[ \\lambda_n \\left( -G \\frac{\\Delta x \\Delta t}{L} \\tau_n e^{-\\phi_k} \\right) + \\mu_k^n \\left( \\Delta t \\tau_n e^{-\\phi_k} \\right) \\right] $$\n提出公因子得到梯度分量的最终表达式：\n$$ \\frac{\\partial J}{\\partial \\phi_k} = \\Delta t \\, e^{-\\phi_k} \\sum_{n=1}^{N_t} \\tau_n \\left( \\mu_k^n - \\lambda_n G \\frac{\\Delta x}{L} \\right) $$\n该表达式的实现方式是：首先运行正向模型以存储状态变量的历史 $(\\tau_n, \\gamma_j^n, u_i^n)$，然后按时间反向运行伴随模型以计算乘子的历史 $(\\lambda_n, \\mu_j^n)$，最后在每个时间步累加梯度贡献。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and produce the final output.\n    \"\"\"\n\n    class Params:\n        \"\"\"A container for simulation parameters.\"\"\"\n        def __init__(self):\n            self.L = 1.0\n            self.G = 10.0\n            self.U_max = 1.0\n            self.T0 = 0.5\n            self.Nt = 250\n            self.dt = 0.02\n            self.T = self.Nt * self.dt\n            self.Nx = 64\n            self.dx = self.L / self.Nx\n            \n            self.times = np.linspace(0, self.T, self.Nt + 1)\n            self.cell_coords = (np.arange(self.Nx) + 0.5) * self.dx\n            \n            obs_locs = [0.25, 0.5, 0.75]\n            self.obs_indices = [int(round(loc / self.dx)) for loc in obs_locs]\n            \n            self.wt = 1.0 / self.Nt\n            self.wx = 1.0 / len(self.obs_indices)\n\n            self.eps = 1e-6\n            self.pert_vec = np.cos(2 * np.pi * self.cell_coords)\n\n    def U_dot_fun(t, p):\n        \"\"\"Prescribed boundary velocity.\"\"\"\n        return (p.U_max / p.T0) * np.exp(-t / p.T0)\n\n    def run_forward(phi, p, d_hist=None):\n        \"\"\"Runs the forward model to compute state variables and, optionally, the misfit J.\"\"\"\n        tau_hist = np.zeros(p.Nt + 1)\n        gamma_hist = np.zeros((p.Nt + 1, p.Nx))\n        u_hist = np.zeros((p.Nt + 1, p.Nx + 1))\n        \n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        U_dot_hist = U_dot_fun(p.times, p)\n        tau_denom = 1.0 + p.G * alpha * p.dt\n\n        for n in range(1, p.Nt + 1):\n            tau_prev = tau_hist[n-1]\n            tau_num = tau_prev + (p.G * p.dt / p.L) * U_dot_hist[n]\n            tau_n = tau_num / tau_denom\n            tau_hist[n] = tau_n\n\n            gamma_prev = gamma_hist[n-1, :]\n            gamma_hist[n, :] = gamma_prev + p.dt * tau_n * inv_eta + (tau_n - tau_prev) / p.G\n            \n            # Efficient displacement update\n            u_hist[n, 1:] = np.cumsum(gamma_hist[n, :]) * p.dx\n        \n        J = 0.0\n        if d_hist is not None:\n            residuals = u_hist[1:, p.obs_indices] - d_hist[1:, p.obs_indices]\n            J = 0.5 * p.wt * p.wx * np.sum(residuals**2)\n\n        return J, (tau_hist, gamma_hist, u_hist)\n\n    def run_adjoint(phi, p, state_hist, d_hist):\n        \"\"\"Runs the adjoint model to compute the gradient of J w.r.t. phi.\"\"\"\n        tau_hist, _, u_hist = state_hist\n        \n        lambda_hist = np.zeros(p.Nt + 2)\n        mu_hist = np.zeros((p.Nt + 2, p.Nx))\n        grad = np.zeros(p.Nx)\n\n        inv_eta = np.exp(-phi)\n        alpha = (p.dx / p.L) * np.sum(inv_eta)\n        lambda_denom_inv = 1.0 / (1.0 + p.G * alpha * p.dt)\n\n        for n in range(p.Nt, 0, -1):\n            nu_n = np.zeros(p.Nx + 1)\n            res_n = u_hist[n,:] - d_hist[n,:]\n            for i_obs in p.obs_indices:\n                nu_n[i_obs] = -p.wt * p.wx * res_n[i_obs]\n\n            s = np.zeros(p.Nx)\n            s_sum_at_node = 0.0\n            for i_node in range(p.Nx, 0, -1):\n                if i_node in p.obs_indices:\n                    s_sum_at_node += nu_n[i_node]\n                \n                j_cell = i_node - 1\n                s[j_cell] = s_sum_at_node\n            \n            f_n = p.dx * s\n            \n            mu_n = mu_hist[n+1, :] + f_n\n\n            lambda_n_num = (lambda_hist[n+1] + \n                           p.dt * np.sum(mu_n * inv_eta) + \n                           (1.0/p.G) * np.sum(f_n))\n            lambda_n = lambda_n_num * lambda_denom_inv\n            \n            mu_hist[n, :] = mu_n\n            lambda_hist[n] = lambda_n\n\n            tau_n = tau_hist[n]\n            term1 = inv_eta * p.dt * tau_n\n            term2 = mu_n - lambda_n * p.G * p.dx / p.L\n            grad += term1 * term2\n\n        return grad\n\n    def run_case(p, phi_true_func, phi_current_func):\n        \"\"\"Executes one complete test case and returns results.\"\"\"\n        phi_true = phi_true_func(p.cell_coords)\n        phi_current = phi_current_func(p.cell_coords)\n\n        # Synthesize data\n        _, (_, _, d_hist) = run_forward(phi_true, p)\n        \n        # Misfit for current phi\n        J, state_hist = run_forward(phi_current, p, d_hist)\n        \n        # Gradient via adjoint\n        grad = run_adjoint(phi_current, p, state_hist, d_hist)\n        grad_norm = np.linalg.norm(grad)\n\n        # Finite difference check\n        phi_pert = phi_current + p.eps * p.pert_vec\n        J_pert, _ = run_forward(phi_pert, p, d_hist)\n        fd_deriv = (J_pert - J) / p.eps\n        ad_deriv = np.dot(grad, p.pert_vec)\n        error = abs(fd_deriv - ad_deriv)\n\n        return [J, grad_norm, error]\n\n    # --- Test Cases ---\n    p = Params()\n\n    # Case 1: Smooth contrast\n    phi_true_1 = lambda x: np.log(3) * np.sin(2 * np.pi * x)\n    phi_current_1 = lambda x: np.log(2) * np.cos(2 * np.pi * x)\n\n    # Case 2: Uniform\n    phi_true_2 = lambda x: np.full_like(x, np.log(2.0))\n    phi_current_2 = lambda x: np.full_like(x, np.log(1.0))\n\n    # Case 3: Step\n    def phi_true_3(x):\n        phi = np.full_like(x, np.log(5.0))\n        phi[x  0.3] = np.log(0.5)\n        return phi\n    def phi_current_3(x):\n        phi = np.full_like(x, np.log(0.5))\n        phi[x  0.3] = np.log(5.0)\n        return phi\n\n    test_cases = [\n        (phi_true_1, phi_current_1),\n        (phi_true_2, phi_current_2),\n        (phi_true_3, phi_current_3),\n    ]\n\n    all_results = []\n    for phi_true_f, phi_current_f in test_cases:\n        results = run_case(p, phi_true_f, phi_current_f)\n        all_results.append(results)\n\n    # Format output\n    output_str = '[' + ','.join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}