{
    "hands_on_practices": [
        {
            "introduction": "The shooting method elegantly transforms a two-point boundary value problem into a root-finding problem. This exercise explores the fundamental mechanics of this process by asking you to formulate the problem in terms of a residual function and its Jacobian for a simple homogeneous medium. By performing a single iteration of a Newton-type solver, you will gain a concrete understanding of how initial guesses for ray parameters are iteratively refined to hit a target receiver. ",
            "id": "3614395",
            "problem": "Consider acoustic ray tracing in a two-dimensional, isotropic medium. One seeks to solve a two-point boundary value problem using the shooting method: choose an initial-parameter vector $\\boldsymbol{\\alpha}$ so that the ray launched from a source location $\\mathbf{x}_{s} \\in \\mathbb{R}^{2}$ reaches a receiver location $\\mathbf{x}_{r} \\in \\mathbb{R}^{2}$ at an arrival time $T$. Define the residual function $\\mathbf{F}(\\boldsymbol{\\alpha})$ by $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{x}(\\boldsymbol{\\alpha},T)-\\mathbf{x}_{r}$, where $\\mathbf{x}(\\boldsymbol{\\alpha},t)$ is the solution of the ray Ordinary Differential Equation (ODE) parameterized by $\\boldsymbol{\\alpha}$ and evolved to time $t$. \n\n1. Starting from the fundamental kinematic description of rays in a homogeneous, isotropic medium of constant wavespeed $c_{0}>0$ (rays are straight lines traveling at speed $c_{0}$), construct explicitly the residual $\\mathbf{F}(\\boldsymbol{\\alpha})$ when $\\boldsymbol{\\alpha}=[\\theta,\\,T]^{\\top}$, where $\\theta$ is the takeoff angle from $\\mathbf{x}_{s}$ and $T$ is the travel time. Also derive the Jacobian matrix $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$.\n\n2. Discuss the differentiability of $\\mathbf{F}$ with respect to $\\boldsymbol{\\alpha}$ and state conditions on the medium and the ray mapping required to ensure local quadratic convergence of Newton-type solvers applied to $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$.\n\n3. For the specific case with $c_{0}=3$ (in $\\mathrm{km/s}$), $\\mathbf{x}_{s}=(0,0)$ (in $\\mathrm{km}$), $\\mathbf{x}_{r}=(3,4)$ (in $\\mathrm{km}$), and the initial guess $\\boldsymbol{\\alpha}_{0}=[\\theta_{0},\\,T_{0}]^{\\top}=\\left[\\frac{\\pi}{4},\\,1.5\\right]^{\\top}$, perform one Newton iteration \n$$\n\\boldsymbol{\\alpha}_{1}=\\boldsymbol{\\alpha}_{0}-\\left(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})\\right)^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}).\n$$\nReport $\\boldsymbol{\\alpha}_{1}$ as a $1\\times 2$ row matrix containing $\\theta_{1}$ (in radians) and $T_{1}$ (in seconds). Express your final answer in exact closed form (no numerical rounding).",
            "solution": "### Part 1: Construction of the Residual and Jacobian\n\nIn a two-dimensional, homogeneous, isotropic medium with constant wavespeed $c_{0}$, a ray originating from the source position $\\mathbf{x}_{s} = \\begin{pmatrix} x_s \\\\ z_s \\end{pmatrix}$ with a takeoff angle $\\theta$ travels along a straight line. The velocity vector is constant and given by $\\mathbf{v} = \\begin{pmatrix} c_{0} \\cos\\theta \\\\ c_{0} \\sin\\theta \\end{pmatrix}$. The position of the ray at time $t$ is therefore\n$$\n\\mathbf{x}(t) = \\mathbf{x}_{s} + t\\mathbf{v} = \\begin{pmatrix} x_s + t c_{0} \\cos\\theta \\\\ z_s + t c_{0} \\sin\\theta \\end{pmatrix}.\n$$\nThe problem defines the parameter vector as $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$. The residual function $\\mathbf{F}(\\boldsymbol{\\alpha})$ is given by the mismatch between the ray's endpoint at the candidate travel time $T$ and the receiver location $\\mathbf{x}_{r} = \\begin{pmatrix} x_r \\\\ z_r \\end{pmatrix}$.\n$$\n\\mathbf{F}(\\boldsymbol{\\alpha}) = \\mathbf{x}(\\boldsymbol{\\alpha}, T) - \\mathbf{x}_{r}\n$$\nHere, the position function $\\mathbf{x}$ depends on $\\theta$ from $\\boldsymbol{\\alpha}$, and it is evaluated at time $T$, which is the second component of $\\boldsymbol{\\alpha}$. Substituting the expression for the ray path, we obtain the explicit form of the residual:\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} F_1(\\theta, T) \\\\ F_2(\\theta, T) \\end{pmatrix} = \\begin{pmatrix} x_s + T c_{0} \\cos\\theta - x_r \\\\ z_s + T c_{0} \\sin\\theta - z_r \\end{pmatrix}.\n$$\nThe Jacobian matrix, $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$, is a $2 \\times 2$ matrix of the partial derivatives of $\\mathbf{F}$ with respect to the components of $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$:\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = J(\\theta, T) = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial \\theta} & \\frac{\\partial F_1}{\\partial T} \\\\ \\frac{\\partial F_2}{\\partial \\theta} & \\frac{\\partial F_2}{\\partial T} \\end{pmatrix}.\n$$\nWe compute each partial derivative:\n$$\n\\frac{\\partial F_1}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (x_s + T c_{0} \\cos\\theta - x_r) = -T c_{0} \\sin\\theta\n$$\n$$\n\\frac{\\partial F_1}{\\partial T} = \\frac{\\partial}{\\partial T} (x_s + T c_{0} \\cos\\theta - x_r) = c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (z_s + T c_{0} \\sin\\theta - z_r) = T c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial T} = \\frac{\\partial}{\\partial T} (z_s + T c_{0} \\sin\\theta - z_r) = c_{0} \\sin\\theta\n$$\nAssembling these components gives the Jacobian matrix:\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = \\begin{pmatrix} -T c_{0} \\sin\\theta & c_{0} \\cos\\theta \\\\ T c_{0} \\cos\\theta & c_{0} \\sin\\theta \\end{pmatrix}.\n$$\n\n### Part 2: Differentiability and Convergence Conditions\n\nFor the homogeneous medium described, the components of the residual function $\\mathbf{F}(\\theta, T)$ are combinations of trigonometric functions ($\\sin\\theta$, $\\cos\\theta$) and linear functions of $T$. These are infinitely differentiable ($C^{\\infty}$) functions over their entire domain $\\mathbb{R}^2$. Therefore, $\\mathbf{F}$ is continuously differentiable with respect to $\\boldsymbol{\\alpha}$ to any order.\n\nThe convergence of Newton-type solvers to a solution $\\boldsymbol{\\alpha}^{*}$ of $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$ is typically quadratic if the following conditions are met in a neighborhood of $\\boldsymbol{\\alpha}^{*}$:\n1.  The function $\\mathbf{F}$ is twice continuously differentiable (i.e., $C^2$).\n2.  The Jacobian matrix $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}^{*})$ is non-singular (i.e., invertible).\n\nAs established, for the homogeneous medium, $\\mathbf{F}$ is $C^{\\infty}$, so the first condition is satisfied. To check the second condition, we compute the determinant of the Jacobian matrix:\n$$\n\\det(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})) = (-T c_{0} \\sin\\theta) (c_{0} \\sin\\theta) - (c_{0} \\cos\\theta) (T c_{0} \\cos\\theta)\n$$\n$$\n= -T c_{0}^2 \\sin^2\\theta - T c_{0}^2 \\cos^2\\theta = -T c_{0}^2 (\\sin^2\\theta + \\cos^2\\theta) = -T c_{0}^2.\n$$\nThe Jacobian is invertible if and only if its determinant is non-zero. Since the wavespeed $c_0 > 0$, we have $c_0^2 > 0$. Therefore, the Jacobian is non-singular provided that the travel time $T \\neq 0$. For any physically meaningful problem where the source and receiver are distinct ($\\mathbf{x}_s \\neq \\mathbf{x}_r$), the travel time must be positive ($T>0$). Thus, for the homogeneous medium, the Jacobian is always invertible at the solution, and Newton's method will exhibit local quadratic convergence.\n\nFor a general heterogeneous, isotropic medium where the velocity $c(\\mathbf{x})$ varies with position, the ray path $\\mathbf{x}(\\boldsymbol{\\alpha}, t)$ is the solution of a system of ordinary differential equations (the ray equations). The differentiability of the ray path with respect to initial conditions (like $\\theta$) depends on the smoothness of the velocity field $c(\\mathbf{x})$. For $\\mathbf{F}$ to be $C^2$, the velocity field $c(\\mathbf{x})$ must be sufficiently smooth (e.g., $C^3$). Furthermore, the condition of an invertible Jacobian corresponds to the geometric condition that the receiver $\\mathbf{x}_r$ does not lie on a caustic of the ray family launched from $\\mathbf{x}_s$. At a caustic, infinitesimally close rays cross, leading to a singularity in the ray mapping and a singular Jacobian.\n\n### Part 3: Newton Iteration\n\nWe are given the specific values:\n- Wavespeed: $c_{0}=3$\n- Source: $\\mathbf{x}_{s}=(0,0)$\n- Receiver: $\\mathbf{x}_{r}=(3,4)$\n- Initial guess: $\\boldsymbol{\\alpha}_{0} = [\\theta_{0}, T_{0}]^{\\top} = \\left[\\frac{\\pi}{4}, 1.5\\right]^{\\top} = \\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$\n\nThe Newton iteration is $\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - (\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}))^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$.\n\n**Step 1: Evaluate $\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\nThe residual function is:\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} 3T\\cos\\theta - 3 \\\\ 3T\\sin\\theta - 4 \\end{pmatrix}\n$$\nAt $\\boldsymbol{\\alpha}_{0}=\\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$, we have $\\cos(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$ and $\\sin(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$.\n$$\nF_1(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\cos\\left(\\frac{\\pi}{4}\\right) - 3 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 3 = \\frac{9\\sqrt{2}}{4} - 3\n$$\n$$\nF_2(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\sin\\left(\\frac{\\pi}{4}\\right) - 4 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 4 = \\frac{9\\sqrt{2}}{4} - 4\n$$\nSo, $\\mathbf{F}(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}$.\n\n**Step 2: Evaluate the Jacobian $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\nThe Jacobian is:\n$$\nJ(\\theta, T) = \\begin{pmatrix} -3T\\sin\\theta & 3\\cos\\theta \\\\ 3T\\cos\\theta & 3\\sin\\theta \\end{pmatrix}\n$$\nAt $\\boldsymbol{\\alpha}_{0}$:\n$$\nJ(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} -3\\left(\\frac{3}{2}\\right)\\sin\\left(\\frac{\\pi}{4}\\right) & 3\\cos\\left(\\frac{\\pi}{4}\\right) \\\\ 3\\left(\\frac{3}{2}\\right)\\cos\\left(\\frac{\\pi}{4}\\right) & 3\\sin\\left(\\frac{\\pi}{4}\\right) \\end{pmatrix} = \\begin{pmatrix} -\\frac{9}{2}\\frac{\\sqrt{2}}{2} & 3\\frac{\\sqrt{2}}{2} \\\\ \\frac{9}{2}\\frac{\\sqrt{2}}{2} & 3\\frac{\\sqrt{2}}{2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{9\\sqrt{2}}{4} & \\frac{3\\sqrt{2}}{2} \\\\ \\frac{9\\sqrt{2}}{4} & \\frac{3\\sqrt{2}}{2} \\end{pmatrix}.\n$$\n\n**Step 3: Invert the Jacobian**\nThe determinant is $\\det(J(\\boldsymbol{\\alpha}_{0})) = -T_0 c_0^2 = -\\left(\\frac{3}{2}\\right)(3^2) = -\\frac{27}{2}$.\nThe inverse is:\n$$\nJ^{-1} = \\frac{1}{-\\frac{27}{2}} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2} & -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4} & -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = -\\frac{2}{27} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2} & -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4} & -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9} & \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6} & \\frac{\\sqrt{2}}{6} \\end{pmatrix}.\n$$\n\n**Step 4: Calculate the update $\\Delta \\boldsymbol{\\alpha}_{0} = J^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\n$$\n\\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9} & \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6} & \\frac{\\sqrt{2}}{6} \\end{pmatrix} \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}\n$$\nThe first component:\n$$\n\\Delta\\theta_0 = -\\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{9}\\left[-\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\left(\\frac{9\\sqrt{2}}{4} - 4\\right)\\right] = \\frac{\\sqrt{2}}{9}(3-4) = -\\frac{\\sqrt{2}}{9}.\n$$\nThe second component:\n$$\n\\Delta T_0 = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{6}\\left(2\\frac{9\\sqrt{2}}{4} - 7\\right) = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{2} - 7\\right) = \\frac{9 \\cdot 2}{12} - \\frac{7\\sqrt{2}}{6} = \\frac{3}{2} - \\frac{7\\sqrt{2}}{6}.\n$$\n\n**Step 5: Compute the new estimate $\\boldsymbol{\\alpha}_{1}$**\n$$\n\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - \\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\theta_0 \\\\ T_0 \\end{pmatrix} - \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix}\n$$\n$$\n\\theta_1 = \\theta_0 - \\Delta\\theta_0 = \\frac{\\pi}{4} - \\left(-\\frac{\\sqrt{2}}{9}\\right) = \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}\n$$\n$$\nT_1 = T_0 - \\Delta T_0 = \\frac{3}{2} - \\left(\\frac{3}{2} - \\frac{7\\sqrt{2}}{6}\\right) = \\frac{7\\sqrt{2}}{6}\n$$\nThe result of one Newton iteration is $\\boldsymbol{\\alpha}_{1} = \\left[\\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}, \\frac{7\\sqrt{2}}{6}\\right]^{\\top}$. The answer is requested as a $1\\times 2$ row matrix.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9} & \\frac{7\\sqrt{2}}{6} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "While simple media are useful for learning, geophysical models are characterized by layers and interfaces. This hands-on coding exercise challenges you to extend a shooting integrator to handle such complexity by implementing event detection to precisely locate a planar interface. You will apply the physics of Snell's law to correctly manage ray reflection and refraction, a fundamental capability of any practical ray-tracing code. ",
            "id": "3614361",
            "problem": "Implement a ray-shooting integrator with interface handling by event detection, including automatic reflection/refraction state switching at a planar interface and momentum updates consistent with Snell’s law in three dimensions. Use a Hamiltonian ray framework specialized to isotropic, homogeneous media on each side of a single planar interface. Represent the ray state by position $\\mathbf{x}\\in\\mathbb{R}^3$ and a unit propagation direction $\\mathbf{u}\\in\\mathbb{S}^2$ evolved with respect to arc-length $s$ by the Ordinary Differential Equation (ODE) system $d\\mathbf{x}/ds=\\mathbf{u}$ and $d\\mathbf{u}/ds=\\mathbf{0}$ within each homogeneous region. Detect interface crossings by an event function $\\phi(\\mathbf{x})=\\mathbf{n}\\cdot(\\mathbf{x}-\\mathbf{x}_\\mathrm{int})$, where $\\mathbf{x}_\\mathrm{int}\\in\\mathbb{R}^3$ is a point on the interface plane and $\\mathbf{n}\\in\\mathbb{R}^3$ is the unit normal directed from medium $1$ into medium $2$. At $\\phi(\\mathbf{x})=0$, perform either a reflection or a refraction according to Snell’s law, and update the ray’s momentum (phase slowness vector) $\\mathbf{p}$ accordingly. Assume isotropic wave speeds $c_1$ and $c_2$ on the two sides of the interface. All distances must be expressed in meters (m), wave speeds in meters per second (m/s), and arc-length $s$ in meters (m). Any angle computations must be carried out in radians.\n\nFundamental base and constraints:\n- The ODE model within a homogeneous medium is $d\\mathbf{x}/ds=\\mathbf{u}$ and $d\\mathbf{u}/ds=\\mathbf{0}$, with $\\|\\mathbf{u}\\|=1$.\n- The phase slowness vector $\\mathbf{p}$ satisfies $\\|\\mathbf{p}\\|=1/c$, where $c$ is the local wave speed (m/s), and the group direction is parallel to $\\mathbf{u}$ with $\\mathbf{u}=c\\,\\mathbf{p}$.\n- At the interface, the tangential component of $\\mathbf{p}$ is continuous and the normal component is determined by the dispersion relation $\\|\\mathbf{p}\\|=1/c$ in the outgoing medium. Let $\\mathbf{p}_n=(\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$ and $\\mathbf{p}_t=\\mathbf{p}-\\mathbf{p}_n$. For reflection, $\\mathbf{p}'=\\mathbf{p}-2\\mathbf{p}_n$. For refraction from an incident medium with speed $c_\\mathrm{in}$ to a transmitted medium with speed $c_\\mathrm{out}$, set $\\mathbf{p}_t'=\\mathbf{p}_t$ and\n$$p_n'=\\sigma\\sqrt{\\frac{1}{c_\\mathrm{out}^2}-\\|\\mathbf{p}_t\\|^2},$$\nwhere $\\sigma=+1$ if transmitting from medium $1$ to medium $2$ (i.e., increasing $\\phi$), and $\\sigma=-1$ if transmitting from medium $2$ to medium $1$ (i.e., decreasing $\\phi$). Total internal reflection occurs if $\\|\\mathbf{p}_t\\|>\\frac{1}{c_\\mathrm{out}}$. In that case, use the reflection update. After updating $\\mathbf{p}$, update the unit direction by $\\mathbf{u}=c\\,\\mathbf{p}$ using the wave speed $c$ appropriate to the post-event medium.\n- Use event detection to locate $\\phi(\\mathbf{x})=0$. Upon an event, update the medium state and momentum/direction according to the rules above, then continue integration until the prescribed arc-length $s_{\\max}$ is reached.\n\nYour program must take no input and must implement the above integrator and event logic for the following test suite. The interface is the plane defined by $\\mathbf{x}_\\mathrm{int}=(0,0,0)\\,\\mathrm{m}$ and $\\mathbf{n}=(0,0,1)$, with medium $1$ defined by $\\phi(\\mathbf{x})<0$ and medium $2$ by $\\phi(\\mathbf{x})>0$. Use wave speeds $c_1$ and $c_2$ as specified per case. For each case, integrate from the given initial state $(\\mathbf{x}_0,\\mathbf{u}_0)$ up to arc-length $s_{\\max}$, applying event detection and interface updates as needed. For numerical stability, treat the near-critical refraction regime using a robust tolerance at the decision boundary.\n\nTest suite:\n- Case A (normal-incidence refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0,0,1)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case B (oblique refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=\\frac{1}{\\sqrt{5}}(1,0,2)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case C (total internal reflection, beyond critical, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(\\sqrt{1-0.3^2},0,0.3)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case D (near-critical refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0.499,0,\\sqrt{1-0.499^2})$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case E (oblique refraction, fast to slow): $\\mathbf{x}_0=(0,0,100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0.6,0,-0.8)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n\nFor each case, define and report an integer mode indicating the last interface operation encountered during the run up to $s_{\\max}$: mode $0$ if no interface was encountered, mode $1$ if the last interface operation was a refraction, and mode $2$ if the last interface operation was a reflection. The required program output is a single line containing a JSON-like array of results, one per case, with each case reported as a flat array of $7$ numbers:\n- $[\\text{mode}, x_\\mathrm{final}, y_\\mathrm{final}, z_\\mathrm{final}, p_{x,\\mathrm{final}}, p_{y,\\mathrm{final}}, p_{z,\\mathrm{final}}]$,\nwhere $\\mathbf{x}_\\mathrm{final}$ is the final position in meters and $\\mathbf{p}_\\mathrm{final}$ is the final momentum (slowness) vector in $\\mathrm{s/m}$ at $s=s_{\\max}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is itself a bracketed, comma-separated list of $7$ floats with no additional whitespace.",
            "solution": "The problem is solved by implementing a ray-tracing algorithm that tracks a ray's state (position $\\mathbf{x}$, direction $\\mathbf{u}$, momentum $\\mathbf{p}$) through a piecewise homogeneous medium. Since the ray paths are straight lines within each homogeneous region, the integration is performed analytically rather than with a numerical ODE solver.\n\nThe core of the algorithm is a loop that advances the ray in segments. In each iteration:\n1.  **Event Prediction**: The arc-length distance to the next intersection with the interface plane ($z=0$) is calculated from the current ray position and direction.\n2.  **Propagation**: The algorithm determines if the interface will be crossed before the maximum arc-length ($s_{\\max}$) is reached.\n    *   If no interface crossing occurs within the remaining path length, the ray is propagated in a straight line to its final position, and the simulation ends.\n    *   If a crossing does occur, the ray is propagated exactly to the point of intersection on the interface. The current arc-length is updated.\n3.  **Event Handling**: At the interface, Snell's law is applied in its vector form using the phase slowness (momentum) vector $\\mathbf{p}$.\n    *   The tangential component of momentum, $\\mathbf{p}_t$, is preserved across the interface.\n    *   The condition for total internal reflection (TIR) is checked: $\\|\\mathbf{p}_t\\| > 1/c_{\\mathrm{out}}$.\n    *   If TIR occurs, the ray is reflected. The new momentum is calculated by reversing the normal component of the incident momentum ($\\mathbf{p}' = \\mathbf{p} - 2\\mathbf{p}_n$), and the ray continues in the incident medium. A mode of `2` is recorded.\n    *   If TIR does not occur, the ray is refracted. The new normal momentum component is calculated using the dispersion relation ($\\|\\mathbf{p}'\\| = 1/c_{\\mathrm{out}}$), ensuring the ray propagates into the outgoing medium. A mode of `1` is recorded.\n4.  **State Update**: The ray's momentum vector $\\mathbf{p}$ and direction vector $\\mathbf{u}$ are updated based on the outcome of the event (reflection or refraction). The loop then continues with the new state from the new position on the interface.\n\nIf the loop completes without ever encountering the interface, the final mode is `0`. The final reported state is the mode of the last interaction and the ray's position and momentum at $s = s_{\\max}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ray tracing problem for all test cases.\n    \"\"\"\n    # The interface is the plane z=0.\n    interface_point = np.array([0.0, 0.0, 0.0])\n    interface_normal = np.array([0.0, 0.0, 1.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (normal-incidence refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.0, 0.0, 1.0), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case B (oblique refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (1.0/np.sqrt(5), 0.0, 2.0/np.sqrt(5)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case C (total internal reflection is possible, but ray does not reach interface)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (np.sqrt(1 - 0.3**2), 0.0, 0.3), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case D (near-critical refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.499, 0.0, np.sqrt(1 - 0.499**2)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case E (oblique refraction, fast to slow)\n        {'x0': (0.0, 0.0, 100.0), 'u0': (0.6, 0.0, -0.8), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = trace_ray(\n            case['x0'], case['u0'], case['s_max'],\n            case['c1'], case['c2'],\n            interface_normal, interface_point\n        )\n        all_results.append(result)\n\n    # Format the output string precisely as required, without extra whitespace.\n    result_strings = []\n    for res in all_results:\n        # Format mode as int, others as floats using 'g' for general format.\n        formatted_res = [f\"{int(res[0])}\"] + [f\"{v:.15g}\" for v in res[1:]]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef trace_ray(x0, u0, s_max, c1, c2, n, x_int):\n    \"\"\"\n    Implements a ray-shooting integrator with event detection at a planar interface.\n    The ray path is piecewise linear, so the integration is done analytically.\n    \n    Args:\n        x0 (tuple): Initial position vector.\n        u0 (tuple): Initial direction unit vector.\n        s_max (float): Maximum arc-length for integration.\n        c1 (float): Wave speed in medium 1 (phi < 0).\n        c2 (float): Wave speed in medium 2 (phi > 0).\n        n (np.ndarray): Interface normal vector.\n        x_int (np.ndarray): A point on the interface plane.\n\n    Returns:\n        list: A list containing [mode, x_final, y_final, z_final, \n                                p_x_final, p_y_final, p_z_final].\n    \"\"\"\n    x = np.array(x0, dtype=float)\n    u = np.array(u0, dtype=float)\n    s = 0.0\n    mode = 0  # 0: no event, 1: refraction, 2: reflection\n\n    # Determine initial medium and momentum p\n    phi = np.dot(n, x - x_int)\n    c_current = c1 if phi < 0 else c2\n    p = u / c_current\n\n    while s < s_max:\n        phi = np.dot(n, x - x_int)\n        u_n_comp = np.dot(u, n)\n\n        # Determine incident and outgoing media properties based on current position\n        if phi < 0: # In medium 1, moving toward medium 2\n            c_in = c1\n            c_out = c2\n        else: # In medium 2, moving toward medium 1\n            c_in = c2\n            c_out = c1\n\n        # Calculate distance to event (interface crossing)\n        dist_to_event = float('inf') if np.isclose(u_n_comp, 0) else -phi / u_n_comp\n        \n        s_rem = s_max - s\n\n        # A small tolerance avoids re-triggering an event immediately after one.\n        if dist_to_event <= 1e-12 or dist_to_event >= s_rem:\n            # No event, or event is beyond s_max. Propagate to the end.\n            x += s_rem * u\n            s = s_max\n            break\n\n        # An event occurs.\n        # 1. Propagate to the interface\n        x += dist_to_event * u\n        s += dist_to_event\n        # Clamp position to the interface to prevent floating-point drift\n        x = x - np.dot(x - x_int, n) * n\n\n        # 2. Handle interface interaction\n        p_t = p - np.dot(p, n) * n\n        p_t_norm_sq = np.dot(p_t, p_t)\n        \n        sqrt_arg = 1.0/c_out**2 - p_t_norm_sq\n        \n        # Check for Total Internal Reflection (TIR)\n        if sqrt_arg < 0:\n            mode = 2\n            p = p - 2.0 * np.dot(p, n) * n\n            u = c_in * p\n        else: # Refraction\n            mode = 1\n            sigma = np.sign(u_n_comp)\n            p_n_new_mag = sigma * np.sqrt(sqrt_arg)\n            p = p_t + p_n_new_mag * n\n            u = c_out * p\n\n    return [mode, x[0], x[1], x[2], p[0], p[1], p[2]]\n\nsolve()\n```"
        },
        {
            "introduction": "In contrast to the sequential nature of shooting methods, bending methods approach ray tracing as a global optimization problem. This practice demonstrates how to handle an interface not as an \"event\" to be detected, but as a hard constraint within the optimization framework. By finding the interface point that satisfies Snell's law for an elliptically anisotropic medium, you will directly apply Fermat's principle and see how variational methods elegantly incorporate physical laws into the problem's geometry. ",
            "id": "3614355",
            "problem": "You must implement a complete, runnable program that computes stationary travel times for two-dimensional rays in piecewise homogeneous, elliptically anisotropic media using a projected-bending update at a single, flat interface. The program must work from first principles: Fermat’s principle of stationary travel time and the dispersion relation for elliptic anisotropy. The key interface constraints are the continuity of the tangential component of phase slowness and satisfaction of the medium dispersion on both sides. The projection step must enforce these constraints by mapping tentative update steps onto the manifold defined by the interface and anisotropic Snell’s condition.\n\nConsider a two-dimensional setting with coordinates $\\mathbf{x} = (x, y)$, a planar interface at $y = 0$, and a ray represented by three nodes $(x_0, x_1, x_2)$, where $x_0$ is the source, $x_2$ is the receiver, and $x_1$ is constrained to lie on the interface. The medium above the interface ($y > 0$) is homogeneous with a constant, positive-definite $2 \\times 2$ matrix $C_1$, and the medium below the interface ($y < 0$) is homogeneous with a constant, positive-definite $2 \\times 2$ matrix $C_2$. These matrices encode elliptic anisotropy and are given in terms of principal phase velocities along the coordinate axes by\n$$\nC_i = \\mathrm{diag}(v_{x,i}^2, v_{y,i}^2), \\quad i \\in \\{1,2\\},\n$$\nwhere $v_{x,i}$ and $v_{y,i}$ are strictly positive real numbers with units of $\\mathrm{m/s}$. The corresponding inverse matrices are\n$$\nW_i = C_i^{-1} = \\mathrm{diag}\\left(\\frac{1}{v_{x,i}^2}, \\frac{1}{v_{y,i}^2}\\right), \\quad i \\in \\{1,2\\}.\n$$\nIn each homogeneous region, the phase slowness vector $p$ satisfies the quadratic dispersion relation\n$p^\\top C_i \\, p = 1$,\nand the travel-time functional for a straight segment with displacement $\\Delta x$ in that region is the elliptic length\n$\\tau(\\Delta x; W_i) = \\sqrt{\\Delta x^\\top W_i \\, \\Delta x}$.\nBy Fermat’s principle, the physical ray between fixed endpoints $(x_0,x_2)$ and an unknown interface point $x_1$ is stationary with respect to variations of $x_1$ restricted to the interface. At the interface, the manifold of admissible states is defined by the constraint that the phase slowness component tangential to the interface is continuous, and that the dispersion holds on both sides. Let $\\hat{t}$ denote the unit tangent to the interface (choose $\\hat{t} = (1,0)^\\top$ for the flat interface at $y=0$). Let $p_1$ be the phase slowness associated with the segment in the upper medium and $p_2$ be the phase slowness associated with the segment in the lower medium (for refraction) or in the same upper medium (for reflection). The manifold constraint is\n$$\n\\hat{t} \\cdot p_1 = \\hat{t} \\cdot p_2, \\quad p_1^\\top C_1 p_1 = 1, \\quad p_2^\\top C_2 p_2 = 1,\n$$\nwith $x_1$ constrained to $y=0$. The group velocity is given by $g_i = C_i p_i$, and the physically admissible refraction must carry energy into the transmitted medium.\n\nYour program must:\n- Represent the path with nodes $x_0, x_1, x_2$ and perform a bending update on $x_1$’s horizontal coordinate while holding $y_1 = 0$ fixed.\n- Implement a projected update: given a tentative change to $x_1$, project it onto the manifold defined by the interface constraints by enforcing the continuity of tangential phase slowness and the dispersion relations on both sides. The projection should be carried out numerically by solving for the interface point $x_1$ on $y=0$ that satisfies the tangential slowness continuity. The dispersion relations must be respected through the definition of $p_i$ used by the update.\n- Compute the stationary total travel time\n$$\nT(x_1) = \\tau(x_1 - x_0; W_1) + \\tau(x_2 - x_1; W_j),\n$$\nwhere $j=2$ for refraction and $j=1$ for reflection, once $x_1$ has been projected onto the constraint manifold.\n- Use meters for spatial coordinates and meters per second for velocities. Express the final travel times in seconds, rounded to six digits after the decimal point.\n\nTest Suite. Implement and evaluate the following three cases, outputting the stationary travel times as specified.\n\n- Case A (Refraction across the interface):\n  - Upper medium ($y > 0$): $v_{x,1} = 2200\\,\\mathrm{m/s}$, $v_{y,1} = 1600\\,\\mathrm{m/s}$.\n  - Lower medium ($y < 0$): $v_{x,2} = 3200\\,\\mathrm{m/s}$, $v_{y,2} = 2400\\,\\mathrm{m/s}$.\n  - Source: $x_0 = (-500\\,\\mathrm{m}, 800\\,\\mathrm{m})$.\n  - Receiver: $x_2 = (600\\,\\mathrm{m}, -900\\,\\mathrm{m})$.\n  - Mode: refraction.\n\n- Case B (Reflection from the interface):\n  - Upper medium ($y > 0$), used for both segments: $v_{x,1} = 2500\\,\\mathrm{m/s}$, $v_{y,1} = 1800\\,\\mathrm{m/s}$.\n  - Source: $x_0 = (-700\\,\\mathrm{m}, 600\\,\\mathrm{m})$.\n  - Receiver: $x_2 = (500\\,\\mathrm{m}, 400\\,\\mathrm{m})$.\n  - Mode: reflection.\n\n- Case C (Refraction with shallow incidence):\n  - Upper medium ($y > 0$): $v_{x,1} = 2600\\,\\mathrm{m/s}$, $v_{y,1} = 1400\\,\\mathrm{m/s}$.\n  - Lower medium ($y < 0$): $v_{x,2} = 2000\\,\\mathrm{m/s}$, $v_{y,2} = 3000\\,\\mathrm{m/s}$.\n  - Source: $x_0 = (-100\\,\\mathrm{m}, 50\\,\\mathrm{m})$.\n  - Receiver: $x_2 = (1000\\,\\mathrm{m}, -1\\,\\mathrm{m})$.\n  - Mode: refraction.\n\nFinal Output Format. Your program should produce a single line of output containing the stationary travel times for the three cases as a comma-separated list enclosed in square brackets, for example $[t_A, t_B, t_C]$, where each entry is a floating-point number in seconds rounded to six digits after the decimal point. No other output is permitted.",
            "solution": "The problem requires the computation of stationary travel times for ray paths in two-dimensional, piecewise homogeneous, elliptically anisotropic media. A ray path consists of two straight segments connecting a source $x_0 = (x_{0,x}, y_{0,y})$ to a receiver $x_2 = (x_{2,x}, y_{2,y})$ via an interface point $x_1 = (x_{1,x}, 0)$ on the horizontal line $y=0$. The task is to find the specific horizontal coordinate $x_{1,x}$ of the interface point that makes the total travel time stationary, in accordance with Fermat's principle.\n\nThe travel time for a single ray segment with displacement vector $\\Delta x$ in a medium with anisotropy matrix $W_i$ is given by the elliptic length:\n$$\n\\tau(\\Delta x; W_i) = \\sqrt{\\Delta x^\\top W_i \\Delta x}\n$$\nwhere $W_i = \\mathrm{diag}(1/v_{x,i}^2, 1/v_{y,i}^2)$.\n\nLet the single variable parameter be the horizontal coordinate of the interface point, denoted simply as $x_1$ for $x_{1,x}$. The source is at $x_0 = (x_{0,x}, y_{0,y})$ with $y_{0,y} > 0$, and the receiver is at $x_2 = (x_{2,x}, y_{2,y})$. The displacement vector for the first segment (source to interface) is $\\Delta x_1 = (x_1 - x_{0,x}, -y_{0,y})$. The displacement vector for the second segment (interface to receiver) is $\\Delta x_2 = (x_{2,x} - x_1, y_{2,y})$.\n\nThe total travel time, $T$, is the sum of the travel times for the two segments:\n$$\nT(x_1) = \\tau_1 + \\tau_j = \\sqrt{\\Delta x_1^\\top W_1 \\Delta x_1} + \\sqrt{\\Delta x_2^\\top W_j \\Delta x_2}\n$$\nwhere $j=1$ for reflection (second segment in medium 1) and $j=2$ for refraction (second segment in medium 2). Explicitly, this is:\n$$\nT(x_1) = \\sqrt{\\frac{(x_1 - x_{0,x})^2}{v_{x,1}^2} + \\frac{y_{0,y}^2}{v_{y,1}^2}} + \\sqrt{\\frac{(x_{2,x} - x_1)^2}{v_{x,j}^2} + \\frac{y_{2,y}^2}{v_{y,j}^2}}\n$$\n\nAccording to Fermat's principle, the physical ray path corresponds to a stationary point of the travel time function. Since $x_1$ is the only degree of freedom, we seek the value of $x_1$ that satisfies $\\frac{dT}{dx_1} = 0$.\n\nThe derivative of the total travel time with respect to $x_1$ is:\n$$\n\\frac{dT}{dx_1} = \\frac{d\\tau_1}{dx_1} + \\frac{d\\tau_j}{dx_1}\n$$\nFor the first term, using the chain rule:\n$$\n\\frac{d\\tau_1}{dx_1} = \\frac{1}{2\\tau_1} \\frac{d}{dx_1}\\left(\\frac{(x_1 - x_{0,x})^2}{v_{x,1}^2} + \\frac{y_{0,y}^2}{v_{y,1}^2}\\right) = \\frac{1}{2\\tau_1} \\frac{2(x_1 - x_{0,x})}{v_{x,1}^2} = \\frac{x_1 - x_{0,x}}{\\tau_1 v_{x,1}^2}\n$$\nFor the second term:\n$$\n\\frac{d\\tau_j}{dx_1} = \\frac{1}{2\\tau_j} \\frac{d}{dx_1}\\left(\\frac{(x_{2,x} - x_1)^2}{v_{x,j}^2} + \\frac{y_{2,y}^2}{v_{y,j}^2}\\right) = \\frac{1}{2\\tau_j} \\frac{2(x_{2,x} - x_1)(-1)}{v_{x,j}^2} = -\\frac{x_{2,x} - x_1}{\\tau_j v_{x,j}^2}\n$$\nSetting the total derivative to zero yields the condition for stationarity:\n$$\n\\frac{dT}{dx_1} = \\frac{x_1 - x_{0,x}}{\\tau_1 v_{x,1}^2} - \\frac{x_{2,x} - x_1}{\\tau_j v_{x,j}^2} = 0\n$$\n\nThis condition is equivalent to the continuity of the tangential phase slowness, which is Snell's law in this context. The phase slowness vector $p$ for a ray segment with displacement $\\Delta x$ is given by $p = (W \\Delta x) / \\tau$.\nThe tangential component of phase slowness for the first segment is:\n$$\np_{1,x} = (\\hat{t} \\cdot p_1) = \\frac{1}{\\tau_1} \\left( \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\left[ \\begin{pmatrix} 1/v_{x,1}^2 & 0 \\\\ 0 & 1/v_{y,1}^2 \\end{pmatrix} \\begin{pmatrix} x_1 - x_{0,x} \\\\ -y_{0,y} \\end{pmatrix} \\right] \\right) = \\frac{x_1 - x_{0,x}}{\\tau_1 v_{x,1}^2}\n$$\nFor the second segment:\n$$\np_{j,x} = (\\hat{t} \\cdot p_j) = \\frac{1}{\\tau_j} \\left( \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} \\cdot \\left[ \\begin{pmatrix} 1/v_{x,j}^2 & 0 \\\\ 0 & 1/v_{y,j}^2 \\end{pmatrix} \\begin{pmatrix} x_{2,x} - x_1 \\\\ y_{2,y} \\end{pmatrix} \\right] \\right) = \\frac{x_{2,x} - x_1}{\\tau_j v_{x,j}^2}\n$$\nThe condition $\\frac{dT}{dx_1} = 0$ is therefore identical to $p_{1,x} = p_{j,x}$, which is the manifold constraint specified in the problem. The problem of finding the stationary path thus reduces to solving the nonlinear equation $f(x_1) = p_{1,x}(x_1) - p_{j,x}(x_1) = 0$ for $x_1$.\n\nThis equation can be solved numerically. The function $f(x_1)$ is monotonically increasing, which guarantees a unique root. A robust root-finding algorithm like the Brent-Dekker method (`scipy.optimize.brentq`) is suitable. A valid search interval (bracket) $[a, b]$ where $f(a)$ and $f(b)$ have opposite signs is required. The interval $[\\min(x_{0,x}, x_{2,x}), \\max(x_{0,x}, x_{2,x})]$ provides a reliable bracket, as the path of minimum time must cross the interface between the source and receiver x-coordinates.\n\nThe computational procedure is as follows:\n1.  For each case, define media properties $(v_{x,1}, v_{y,1}, v_{x,j}, v_{y,j})$ and geometry $(x_0, x_2)$.\n2.  Define the function $f(x_1) = p_{1,x}(x_1) - p_{j,x}(x_1)$.\n3.  Use `scipy.optimize.brentq` to find the root $x_1^*$ of $f(x_1) = 0$ within the bracket $[\\min(x_{0,x}, x_{2,x}), \\max(x_{0,x}, x_{2,x})]$.\n4.  Substitute the resulting stationary point $x_1^*$ back into the total travel time equation $T(x_1)$ to find the stationary time.\n5.  Format the results as required.\nThis process directly finds the point $x_1$ on the constraint manifold and computes the corresponding stationary travel time, fulfilling all problem requirements.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes stationary travel times for rays in elliptically anisotropic media.\n    \"\"\"\n\n    test_cases = [\n        # Case A (Refraction)\n        {\n            'v_x1': 2200.0, 'v_y1': 1600.0, 'v_x2': 3200.0, 'v_y2': 2400.0,\n            'x0': (-500.0, 800.0), 'x2': (600.0, -900.0), 'mode': 'refraction'\n        },\n        # Case B (Reflection)\n        {\n            'v_x1': 2500.0, 'v_y1': 1800.0, 'v_x2': None, 'v_y2': None,\n            'x0': (-700.0, 600.0), 'x2': (500.0, 400.0), 'mode': 'reflection'\n        },\n        # Case C (Refraction with shallow incidence)\n        {\n            'v_x1': 2600.0, 'v_y1': 1400.0, 'v_x2': 2000.0, 'v_y2': 3000.0,\n            'x0': (-100.0, 50.0), 'x2': (1000.0, -1.0), 'mode': 'refraction'\n        }\n    ]\n\n    def _travel_time(delta_x, v_x, v_y):\n        \"\"\"Calculates travel time for a single ray segment.\"\"\"\n        dx, dy = delta_x\n        tau_squared = (dx**2) / (v_x**2) + (dy**2) / (v_y**2)\n        return np.sqrt(tau_squared)\n\n    def _snell_law_residual(x1_coord, x0, x2, v_x1, v_y1, v_x_j, v_y_j):\n        \"\"\"\n        Calculates the residual of Snell's law (p1_x - p_j_x).\n        The root of this function gives the stationary point.\n        \"\"\"\n        x0_x, y0_y = x0\n        x2_x, y2_y = x2\n\n        # Segment 1: source to interface point\n        delta_x1 = np.array([x1_coord - x0_x, -y0_y])\n        tau1 = _travel_time(delta_x1, v_x1, v_y1)\n        if tau1 == 0: return np.inf\n        p1_x = (x1_coord - x0_x) / (v_x1**2 * tau1)\n\n        # Segment 2: interface point to receiver\n        delta_x2 = np.array([x2_x - x1_coord, y2_y])\n        tau_j = _travel_time(delta_x2, v_x_j, v_y_j)\n        if tau_j == 0: return np.inf\n        p_j_x = (x2_x - x1_coord) / (v_x_j**2 * tau_j)\n        \n        return p1_x - p_j_x\n\n    def solve_for_case(params):\n        \"\"\"\n        Solves for the stationary travel time for a single case.\n        \"\"\"\n        mode = params['mode']\n        x0 = params['x0']\n        x2 = params['x2']\n        v_x1, v_y1 = params['v_x1'], params['v_y1']\n        \n        if mode == 'refraction':\n            v_x_j, v_y_j = params['v_x2'], params['v_y2']\n        else:  # reflection\n            v_x_j, v_y_j = v_x1, v_y1\n\n        args_for_solver = (x0, x2, v_x1, v_y1, v_x_j, v_y_j)\n        \n        x0_x, x2_x = x0[0], x2[0]\n        bracket = sorted([x0_x, x2_x])\n\n        # Find the x-coordinate of the interface point that satisfies Snell's law\n        stationary_x1_coord = brentq(_snell_law_residual, bracket[0], bracket[1], args=args_for_solver)\n        \n        # Calculate total travel time using the found stationary point\n        delta_x1_final = np.array([stationary_x1_coord - x0[0], -x0[1]])\n        t1 = _travel_time(delta_x1_final, v_x1, v_y1)\n\n        delta_x2_final = np.array([x2[0] - stationary_x1_coord, x2[1]])\n        t_j = _travel_time(delta_x2_final, v_x_j, v_y_j)\n        \n        return t1 + t_j\n\n    results = []\n    for case in test_cases:\n        time = solve_for_case(case)\n        results.append(f\"{time:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}