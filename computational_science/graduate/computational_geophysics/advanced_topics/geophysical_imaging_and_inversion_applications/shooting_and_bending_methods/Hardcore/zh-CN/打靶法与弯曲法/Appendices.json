{
    "hands_on_practices": [
        {
            "introduction": "理论的价值在于实践。本章提供了一系列动手练习，旨在加深您对地震射线追踪中打靶法和弯曲法核心原理的理解。第一个练习将打靶法简化为其数学本质：一个非线性寻根问题。通过在一个简单的均匀介质中，为连接震源和接收点的射线构建残差函数及其雅可比矩阵，您将亲手执行一步牛顿法迭代，从而直观地理解打靶法是如何迭代求解两点边值问题的 。",
            "id": "3614395",
            "problem": "考虑在二维各向同性介质中的声线追踪。我们希望使用打靶法求解一个两点边值问题：选择一个初始参数向量 $\\boldsymbol{\\alpha}$，使得从源点位置 $\\mathbf{x}_{s} \\in \\mathbb{R}^{2}$ 发出的声线在到达时间 $T$ 抵达接收点位置 $\\mathbf{x}_{r} \\in \\mathbb{R}^{2}$。定义残差函数 $\\mathbf{F}(\\boldsymbol{\\alpha})$ 为 $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{x}(\\boldsymbol{\\alpha},T)-\\mathbf{x}_{r}$，其中 $\\mathbf{x}(\\boldsymbol{\\alpha},t)$ 是由 $\\boldsymbol{\\alpha}$ 参数化的声线常微分方程（ODE）在时间 $t$ 的解。\n\n1. 从均匀、各向同性、恒定波速 $c_{0}>0$ 的介质中声线的基本运动学描述（声线是以速度 $c_{0}$ 沿直线传播的）出发，当 $\\boldsymbol{\\alpha}=[\\theta,\\,T]^{\\top}$ 时，显式地构造残差 $\\mathbf{F}(\\boldsymbol{\\alpha})$，其中 $\\theta$ 是从 $\\mathbf{x}_{s}$ 出发的初始角，$T$ 是走时。同时，推导雅可比矩阵 $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$。\n\n2. 讨论 $\\mathbf{F}$ 关于 $\\boldsymbol{\\alpha}$ 的可微性，并陈述为确保应用于 $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$ 的牛顿类型求解器具有局部二次收敛性，介质和声线映射需要满足的条件。\n\n3. 对于 $c_{0}=3$（单位 $\\mathrm{km/s}$）、$\\mathbf{x}_{s}=(0,0)$（单位 $\\mathrm{km}$）、$\\mathbf{x}_{r}=(3,4)$（单位 $\\mathrm{km}$）以及初始猜测值 $\\boldsymbol{\\alpha}_{0}=[\\theta_{0},\\,T_{0}]^{\\top}=\\left[\\frac{\\pi}{4},\\,1.5\\right]^{\\top}$ 的具体情况，执行一次牛顿迭代\n$$\n\\boldsymbol{\\alpha}_{1}=\\boldsymbol{\\alpha}_{0}-\\left(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})\\right)^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}).\n$$\n将 $\\boldsymbol{\\alpha}_{1}$ 表示为一个包含 $\\theta_{1}$（单位为弧度）和 $T_{1}$（单位为秒）的 $1\\times 2$ 行矩阵。以精确的封闭形式（无数值舍入）表示你的最终答案。",
            "solution": "该问题陈述已经过评估并被认为是有效的。它具有科学依据，问题提法得当，客观，并包含推导唯一解所需的所有必要信息。\n\n### 第一部分：残差和雅可比矩阵的构造\n\n在一个二维、均匀、各向同性的恒定波速为 $c_{0}$ 的介质中，一条从源点位置 $\\mathbf{x}_{s} = \\begin{pmatrix} x_s \\\\ z_s \\end{pmatrix}$ 以初始角 $\\theta$ 发出的声线沿直线传播。其速度矢量是恒定的，由 $\\mathbf{v} = \\begin{pmatrix} c_{0} \\cos\\theta \\\\ c_{0} \\sin\\theta \\end{pmatrix}$ 给出。因此，声线在时间 $t$ 的位置为\n$$\n\\mathbf{x}(t) = \\mathbf{x}_{s} + t\\mathbf{v} = \\begin{pmatrix} x_s + t c_{0} \\cos\\theta \\\\ z_s + t c_{0} \\sin\\theta \\end{pmatrix}.\n$$\n问题将参数向量定义为 $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$。残差函数 $\\mathbf{F}(\\boldsymbol{\\alpha})$ 由声线在候选走时 $T$ 的终点与接收点位置 $\\mathbf{x}_{r} = \\begin{pmatrix} x_r \\\\ z_r \\end{pmatrix}$ 之间的失配给出。\n$$\n\\mathbf{F}(\\boldsymbol{\\alpha}) = \\mathbf{x}(\\boldsymbol{\\alpha}, T) - \\mathbf{x}_{r}\n$$\n在这里，位置函数 $\\mathbf{x}$ 依赖于 $\\boldsymbol{\\alpha}$ 中的 $\\theta$，并在时间 $T$（即 $\\boldsymbol{\\alpha}$ 的第二个分量）进行求值。代入声线路径的表达式，我们得到残差的显式形式：\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} F_1(\\theta, T) \\\\ F_2(\\theta, T) \\end{pmatrix} = \\begin{pmatrix} x_s + T c_{0} \\cos\\theta - x_r \\\\ z_s + T c_{0} \\sin\\theta - z_r \\end{pmatrix}.\n$$\n雅可比矩阵 $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$ 是一个 $2 \\times 2$ 矩阵，其元素是 $\\mathbf{F}$ 关于 $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$ 各分量的偏导数：\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = J(\\theta, T) = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial \\theta} & \\frac{\\partial F_1}{\\partial T} \\\\ \\frac{\\partial F_2}{\\partial \\theta} & \\frac{\\partial F_2}{\\partial T} \\end{pmatrix}.\n$$\n我们计算每个偏导数：\n$$\n\\frac{\\partial F_1}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (x_s + T c_{0} \\cos\\theta - x_r) = -T c_{0} \\sin\\theta\n$$\n$$\n\\frac{\\partial F_1}{\\partial T} = \\frac{\\partial}{\\partial T} (x_s + T c_{0} \\cos\\theta - x_r) = c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (z_s + T c_{0} \\sin\\theta - z_r) = T c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial T} = \\frac{\\partial}{\\partial T} (z_s + T c_{0} \\sin\\theta - z_r) = c_{0} \\sin\\theta\n$$\n将这些分量组合起来，得到雅可比矩阵：\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = \\begin{pmatrix} -T c_{0} \\sin\\theta & c_{0} \\cos\\theta \\\\ T c_{0} \\cos\\theta & c_{0} \\sin\\theta \\end{pmatrix}.\n$$\n\n### 第二部分：可微性与收敛条件\n\n对于所描述的均匀介质，残差函数 $\\mathbf{F}(\\theta, T)$ 的分量是三角函数（$\\sin\\theta$, $\\cos\\theta$）和 $T$ 的线性函数的组合。这些函数在其整个定义域 $\\mathbb{R}^2$ 上是无穷可微的（$C^{\\infty}$）。因此，$\\mathbf{F}$ 关于 $\\boldsymbol{\\alpha}$ 是任意阶连续可微的。\n\n牛顿类型求解器对于 $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$ 的解 $\\boldsymbol{\\alpha}^{*}$ 的收敛通常是二次的，如果在 $\\boldsymbol{\\alpha}^{*}$ 的一个邻域内满足以下条件：\n1.  函数 $\\mathbf{F}$ 是二次连续可微的（即 $C^2$）。\n2.  雅可比矩阵 $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}^{*})$ 是非奇异的（即可逆的）。\n\n如前所述，对于均匀介质，$\\mathbf{F}$ 是 $C^{\\infty}$ 的，因此第一个条件得到满足。为检验第二个条件，我们计算雅可比矩阵的行列式：\n$$\n\\det(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})) = (-T c_{0} \\sin\\theta) (c_{0} \\sin\\theta) - (c_{0} \\cos\\theta) (T c_{0} \\cos\\theta)\n$$\n$$\n= -T c_{0}^2 \\sin^2\\theta - T c_{0}^2 \\cos^2\\theta = -T c_{0}^2 (\\sin^2\\theta + \\cos^2\\theta) = -T c_{0}^2.\n$$\n雅可比矩阵可逆当且仅当其行列式非零。由于波速 $c_0 > 0$，我们有 $c_0^2 > 0$。因此，只要走时 $T \\neq 0$，雅可比矩阵就是非奇异的。对于任何物理上有意义的问题，其中源点和接收点是不同的（$\\mathbf{x}_s \\neq \\mathbf{x}_r$），走时必须为正（$T>0$）。因此，对于均匀介质，雅可比矩阵在解处总是可逆的，牛顿法将表现出局部二次收敛性。\n\n对于一个速度 $c(\\mathbf{x})$ 随位置变化的一般非均匀、各向同性介质，声线路径 $\\mathbf{x}(\\boldsymbol{\\alpha}, t)$ 是一组常微分方程（声线方程）的解。声线路径关于初始条件（如 $\\theta$）的可微性取决于速度场 $c(\\mathbf{x})$ 的光滑度。要使 $\\mathbf{F}$ 是 $C^2$ 的，速度场 $c(\\mathbf{x})$ 必须足够光滑（例如，$C^3$）。此外，雅可比矩阵可逆的条件对应于几何条件，即接收点 $\\mathbf{x}_r$ 不位于从 $\\mathbf{x}_s$ 发出的声线族的焦散线上。在焦散线上，无限接近的声线会相交，导致声线映射出现奇点和雅可比矩阵奇异。\n\n### 第三部分：牛顿迭代\n\n我们给定以下具体数值：\n- 波速: $c_{0}=3$\n- 源点: $\\mathbf{x}_{s}=(0,0)$\n- 接收点: $\\mathbf{x}_{r}=(3,4)$\n- 初始猜测值: $\\boldsymbol{\\alpha}_{0} = [\\theta_{0}, T_{0}]^{\\top} = \\left[\\frac{\\pi}{4}, 1.5\\right]^{\\top} = \\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$\n\n牛顿迭代公式为 $\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - (\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}))^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$。\n\n**第一步：计算 $\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\n残差函数为：\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} 3T\\cos\\theta - 3 \\\\ 3T\\sin\\theta - 4 \\end{pmatrix}\n$$\n在 $\\boldsymbol{\\alpha}_{0}=\\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$ 处，我们有 $\\cos(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$ 和 $\\sin(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$。\n$$\nF_1(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\cos\\left(\\frac{\\pi}{4}\\right) - 3 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 3 = \\frac{9\\sqrt{2}}{4} - 3\n$$\n$$\nF_2(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\sin\\left(\\frac{\\pi}{4}\\right) - 4 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 4 = \\frac{9\\sqrt{2}}{4} - 4\n$$\n所以，$\\mathbf{F}(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}$。\n\n**第二步：计算雅可比矩阵 $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\n雅可比矩阵为：\n$$\nJ(\\theta, T) = \\begin{pmatrix} -3T\\sin\\theta & 3\\cos\\theta \\\\ 3T\\cos\\theta & 3\\sin\\theta \\end{pmatrix}\n$$\n在 $\\boldsymbol{\\alpha}_{0}$ 处：\n$$\nJ(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} -3\\left(\\frac{3}{2}\\right)\\sin\\left(\\frac{\\pi}{4}\\right) & 3\\cos\\left(\\frac{\\pi}{4}\\right) \\\\ 3\\left(\\frac{3}{2}\\right)\\cos\\left(\\frac{\\pi}{4}\\right) & 3\\sin\\left(\\frac{\\pi}{4}\\right) \\end{pmatrix} = \\begin{pmatrix} -\\frac{9}{2}\\frac{\\sqrt{2}}{2} & 3\\frac{\\sqrt{2}}{2} \\\\ \\frac{9}{2}\\frac{\\sqrt{2}}{2} & 3\\frac{\\sqrt{2}}{2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{9\\sqrt{2}}{4} & \\frac{3\\sqrt{2}}{2} \\\\ \\frac{9\\sqrt{2}}{4} & \\frac{3\\sqrt{2}}{2} \\end{pmatrix}.\n$$\n\n**第三步：求雅可比矩阵的逆**\n行列式为 $\\det(J(\\boldsymbol{\\alpha}_{0})) = -T_0 c_0^2 = -\\left(\\frac{3}{2}\\right)(3^2) = -\\frac{27}{2}$。\n逆矩阵为：\n$$\nJ^{-1} = \\frac{1}{-\\frac{27}{2}} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2} & -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4} & -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = -\\frac{2}{27} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2} & -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4} & -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9} & \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6} & \\frac{\\sqrt{2}}{6} \\end{pmatrix}.\n$$\n\n**第四步：计算更新量 $\\Delta \\boldsymbol{\\alpha}_{0} = J^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\n$$\n\\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9} & \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6} & \\frac{\\sqrt{2}}{6} \\end{pmatrix} \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}\n$$\n第一个分量：\n$$\n\\Delta\\theta_0 = -\\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{9}\\left[-\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\left(\\frac{9\\sqrt{2}}{4} - 4\\right)\\right] = \\frac{\\sqrt{2}}{9}(3-4) = -\\frac{\\sqrt{2}}{9}.\n$$\n第二个分量：\n$$\n\\Delta T_0 = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{6}\\left(2\\frac{9\\sqrt{2}}{4} - 7\\right) = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{2} - 7\\right) = \\frac{9 \\cdot 2}{12} - \\frac{7\\sqrt{2}}{6} = \\frac{3}{2} - \\frac{7\\sqrt{2}}{6}.\n$$\n\n**第五步：计算新的估计值 $\\boldsymbol{\\alpha}_{1}$**\n$$\n\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - \\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\theta_0 \\\\ T_0 \\end{pmatrix} - \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix}\n$$\n$$\n\\theta_1 = \\theta_0 - \\Delta\\theta_0 = \\frac{\\pi}{4} - \\left(-\\frac{\\sqrt{2}}{9}\\right) = \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}\n$$\n$$\nT_1 = T_0 - \\Delta T_0 = \\frac{3}{2} - \\left(\\frac{3}{2} - \\frac{7\\sqrt{2}}{6}\\right) = \\frac{7\\sqrt{2}}{6}\n$$\n一次牛顿迭代的结果是 $\\boldsymbol{\\alpha}_{1} = \\left[\\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}, \\frac{7\\sqrt{2}}{6}\\right]^{\\top}$。答案要求以 $1\\times 2$ 行矩阵的形式给出。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9} & \\frac{7\\sqrt{2}}{6} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "真实的地球物理模型远比均匀介质复杂，它们包含速度不连续的面，如地层界面。第二个练习将带您进入更实际的场景，要求您在一个包含平面的分层介质中，通过事件检测来处理射线与界面的相互作用 。您需要根据斯涅耳定律（Snell's Law）的物理约束来更新射线的动量（即相位慢度矢量），正确处理反射和折射现象，这是将打靶法应用于实际地震成像和反演问题的关键一步。",
            "id": "3614361",
            "problem": "实现一个射线追踪积分器，通过事件检测处理界面交互，包括在平面界面上自动切换反射/折射状态，以及与三维斯涅尔定律一致的动量更新。使用一个专门为单个平面界面两侧的各向同性均匀介质设计的哈密顿射线框架。射线状态由位置 $\\mathbf{x}\\in\\mathbb{R}^3$ 和单位传播方向 $\\mathbf{u}\\in\\mathbb{S}^2$ 表示，其在每个均匀区域内随弧长 $s$ 的演化由常微分方程（ODE）系统 $d\\mathbf{x}/ds=\\mathbf{u}$ 和 $d\\mathbf{u}/ds=\\mathbf{0}$ 描述。通过事件函数 $\\phi(\\mathbf{x})=\\mathbf{n}\\cdot(\\mathbf{x}-\\mathbf{x}_\\mathrm{int})$ 来检测界面穿越，其中 $\\mathbf{x}_\\mathrm{int}\\in\\mathbb{R}^3$ 是界面平面上的一个点，$\\mathbf{n}\\in\\mathbb{R}^3$ 是从介质1指向介质2的单位法向量。在 $\\phi(\\mathbf{x})=0$ 处，根据斯涅尔定律执行反射或折射，并相应地更新射线的动量（相慢度矢量）$\\mathbf{p}$。假设界面两侧的各向同性波速分别为 $c_1$ 和 $c_2$。所有距离必须以米（m）表示，波速以米/秒（m/s）表示，弧长 $s$ 以米（m）表示。任何角度计算都必须以弧度进行。\n\n基本原理和约束：\n- 在均匀介质内的ODE模型为 $d\\mathbf{x}/ds=\\mathbf{u}$ 和 $d\\mathbf{u}/ds=\\mathbf{0}$，且 $\\|\\mathbf{u}\\|=1$。\n- 相慢度矢量 $\\mathbf{p}$ 满足 $\\|\\mathbf{p}\\|=1/c$，其中 $c$ 是局部波速（m/s），群速度方向与 $\\mathbf{u}$ 平行，且 $\\mathbf{u}=c\\,\\mathbf{p}$。\n- 在界面处，$\\mathbf{p}$ 的切向分量是连续的，法向分量由出射介质中的色散关系 $\\|\\mathbf{p}\\|=1/c$ 确定。令 $\\mathbf{p}_n=(\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$ 且 $\\mathbf{p}_t=\\mathbf{p}-\\mathbf{p}_n$。对于反射，$\\mathbf{p}'=\\mathbf{p}-2\\mathbf{p}_n$。对于从速度为 $c_\\mathrm{in}$ 的入射介质到速度为 $c_\\mathrm{out}$ 的透射介质的折射，设置 $\\mathbf{p}_t'=\\mathbf{p}_t$ 且 $$p_n'=\\sigma\\sqrt{\\frac{1}{c_\\mathrm{out}^2}-\\|\\mathbf{p}_t\\|^2},$$ 其中，如果从介质1透射到介质2（即 $\\phi$ 增加），则 $\\sigma=+1$；如果从介质2透射到介质1（即 $\\phi$ 减小），则 $\\sigma=-1$。如果 $\\|\\mathbf{p}_t\\|>\\frac{1}{c_\\mathrm{out}}$，则发生全内反射。在这种情况下，使用反射更新规则。更新 $\\mathbf{p}$ 后，使用事件后介质对应的波速 $c$ 通过 $\\mathbf{u}=c\\,\\mathbf{p}$ 更新单位方向。\n- 使用事件检测来定位 $\\phi(\\mathbf{x})=0$。发生事件时，根据上述规则更新介质状态和动量/方向，然后继续积分，直到达到规定的弧长 $s_{\\max}$。\n\n您的程序必须不接受任何输入，并为以下测试套件实现上述积分器和事件逻辑。界面是由 $\\mathbf{x}_\\mathrm{int}=(0,0,0)\\,\\mathrm{m}$ 和 $\\mathbf{n}=(0,0,1)$ 定义的平面，其中介质1由 $\\phi(\\mathbf{x})<0$ 定义，介质2由 $\\phi(\\mathbf{x})>0$ 定义。使用每个案例指定的波速 $c_1$ 和 $c_2$。对于每个案例，从给定的初始状态 $(\\mathbf{x}_0,\\mathbf{u}_0)$ 积分到最大弧长 $s_{\\max}$，并根据需要应用事件检测和界面更新。为保证数值稳定性，在决策边界处使用一个稳健的容差来处理近临界折射情况。\n\n测试套件：\n- 案例A（正入射折射，从慢介质到快介质）：$\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0,0,1)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$。\n- 案例B（斜向折射，从慢介质到快介质）：$\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=\\frac{1}{\\sqrt{5}}(1,0,2)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$。\n- 案例C（全内反射，超临界角，从慢介质到快介质）：$\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(\\sqrt{1-0.3^2},0,0.3)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$。\n- 案例D（近临界折射，从慢介质到快介质）：$\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=\\big(0.499,0,\\sqrt{1-0.499^2}\\big)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$。\n- 案例E（斜向折射，从快介质到慢介质）：$\\mathbf{x}_0=(0,0,100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0.6,0,-0.8)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$。\n\n对于每个案例，定义并报告一个整数模式 `mode`，指示在运行至 $s_{\\max}$ 过程中遇到的最后一个界面操作：如果未遇到界面，`mode` 为 $0$；如果最后一个界面操作是折射，`mode` 为 $1$；如果最后一个界面操作是反射，`mode` 为 $2$。要求的程序输出是单行，包含一个类JSON数组的结果，每个案例一个，其中每个案例报告为一个包含7个数字的扁平数组：\n- $[\\text{mode}, x_\\mathrm{final}, y_\\mathrm{final}, z_\\mathrm{final}, p_{x,\\mathrm{final}}, p_{y,\\mathrm{final}}, p_{z,\\mathrm{final}}]$，\n其中 $\\mathbf{x}_\\mathrm{final}$ 是最终位置（单位：米），$\\mathbf{p}_\\mathrm{final}$ 是在 $s=s_{\\max}$ 时的最终动量（慢度）矢量（单位：$\\mathrm{s/m}$）。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），每个 $r_i$ 本身是一个包含7个浮点数的、用方括号括起来的逗号分隔列表，不含额外空格。",
            "solution": "用户要求实现一个三维射线追踪算法，该算法适用于由两个均匀、各向同性的半空间（由一个平面界面隔开）组成的介质。该算法必须根据斯涅尔定律处理界面上的反射和折射，包括全内反射（TIR）的情况。\n\n### 问题验证\n\n首先，根据所需标准对问题陈述进行验证。\n\n*   **步骤1：提取给定条件**\n    *   **射线状态**：位置 $\\mathbf{x} \\in \\mathbb{R}^3$，单位方向矢量 $\\mathbf{u} \\in \\mathbb{S}^2$。\n    *   **ODE模型**：在每个均匀区域内，射线路径随弧长 $s$ 演化，遵循 $d\\mathbf{x}/ds=\\mathbf{u}$ 和 $d\\mathbf{u}/ds=\\mathbf{0}$。\n    *   **动量（慢度）矢量**：$\\mathbf{p}$，其中 $\\|\\mathbf{p}\\| = 1/c$，$c$ 是局部波速。群速度方向为 $\\mathbf{u} = c\\mathbf{p}$。\n    *   **界面**：由 $\\mathbf{x}_{\\mathrm{int}} \\in \\mathbb{R}^3$ 和单位法向量 $\\mathbf{n} \\in \\mathbb{R}^3$ 定义的平面。事件函数为 $\\phi(\\mathbf{x})=\\mathbf{n}\\cdot(\\mathbf{x}-\\mathbf{x}_{\\mathrm{int}})=0$。介质1位于 $\\phi(\\mathbf{x})<0$ 处，介质2位于 $\\phi(\\mathbf{x})>0$ 处。\n    *   **界面物理（斯涅尔定律）**：切向慢度 $\\mathbf{p}_t = \\mathbf{p} - (\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$ 是连续的。\n        *   **反射**：$\\mathbf{p}' = \\mathbf{p} - 2(\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$。\n        *   **折射**：$\\mathbf{p}'_t = \\mathbf{p}_t$，新的法向慢度为 $p'_n = \\sigma \\sqrt{1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2}$，其中对于 $1 \\to 2$ 的透射 $\\sigma=+1$，对于 $2 \\to 1$ 的透射 $\\sigma=-1$。\n        *   **全内反射（TIR）**：如果 $\\|\\mathbf{p}_t\\| > 1/c_{\\mathrm{out}}$，则发生全内反射，此时使用反射规则。\n    *   **测试环境**：界面位于 $z=0$（$\\mathbf{x}_{\\mathrm{int}}=(0,0,0), \\mathbf{n}=(0,0,1)$）。介质1为 $z<0$，介质2为 $z>0$。\n    *   **测试案例**：提供了五个具体案例（A-E），包括初始条件 $(\\mathbf{x}_0, \\mathbf{u}_0)$、波速 $(c_1, c_2)$ 和最大弧长 $s_{\\max}$。\n    *   **输出**：对于每个案例，报告一个模式整数（0表示无事件，1表示折射，2表示反射）和最终状态 $(\\mathbf{x}_{\\mathrm{final}}, \\mathbf{p}_{\\mathrm{final}})$。格式为一个类JSON的数组的数组。\n\n*   **步骤2：使用提取的给定条件进行验证**\n    *   **科学基础**：该问题基于几何光学/声学中成熟的哈密顿射线理论和斯涅尔定律。所有物理和数学原理都是标准且正确的。\n    *   **适定性**：该问题是一个带有明确事件处理的常微分方程初值问题。所有参数和初始条件都已提供，确保每个测试案例都有唯一解。\n    *   **目标明确**：问题使用精确、无歧义的数学语言陈述。\n    *   **一致性**：给定的条件是自洽的。所有测试案例的初始方向矢量 $\\mathbf{u}_0$ 都被正确指定为单位矢量。反射、折射和TIR的物理过程通过慢度矢量公式得到一致的描述。\n\n*   **步骤3：结论与行动**\n    *   该问题是**有效的**。它是一个定义明确、科学上合理的计算物理问题。将为其开发一个解决方案。\n\n### 算法设计\n\n由于介质在界面之间是均匀的，射线路径是直线。这允许在事件之间对射线路径进行解析“积分”，对于此特定问题，这比数值ODE求解器更高效、更准确。\n\n对于每个测试案例，算法按以下步骤进行：\n\n1.  **初始化**：\n    *   设置初始状态：位置 $\\mathbf{x} \\leftarrow \\mathbf{x}_0$，方向 $\\mathbf{u} \\leftarrow \\mathbf{u}_0$，弧长 $s \\leftarrow 0$。\n    *   初始 `mode` 设置为 $0$（无事件）。\n    *   根据 $\\mathbf{x}_0$ 确定初始波速 $c$。\n    *   计算初始动量矢量 $\\mathbf{p} = \\mathbf{u}_0/c$。\n\n2.  **积分循环**：只要当前弧长 $s$ 小于 $s_{\\max}$，算法就进行循环迭代。\n    *   **事件预测**：在每一步中，算法计算射线到达界面平面 $z=0$ 所需的弧长 `dist_to_event`。这可以通过求解直线方程 $(\\mathbf{x} + s' \\mathbf{u}) \\cdot \\mathbf{n} = 0$ 中的参数 $s'$ 来找到，得到 $s' = -(\\mathbf{x} \\cdot \\mathbf{n}) / (\\mathbf{u} \\cdot \\mathbf{n})$。如果 $\\mathbf{u} \\cdot \\mathbf{n} = 0$，则射线平行于界面，不会穿越它。如果 $s' \\le 0$，则界面在射线后方，因此不会穿越。\n    *   **路径段积分**：\n        *   如果在 $s_{\\max}$ 之前没有事件发生（即 `dist_to_event` 为负、无穷大或大于剩余弧长 $s_{\\max}-s$），则射线沿直线传播到其在 $s_{\\max}$ 的最终位置。然后循环终止。\n        *   如果发生事件，则将射线传播到界面。更新状态变量：$\\mathbf{x} \\leftarrow \\mathbf{x} + \\text{dist\\_to\\_event} \\cdot \\mathbf{u}$ 和 $s \\leftarrow s + \\text{dist\\_to\\_event}$。\n\n    *   **事件处理**：在界面处，执行以下步骤：\n        1.  根据射线当前所在的介质，确定入射波速 $c_{\\mathrm{in}}$ 和出射波速 $c_{\\mathrm{out}}$。\n        2.  将入射动量 $\\mathbf{p}$ 分解为其相对于界面法向量 $\\mathbf{n}$ 的切向分量（$\\mathbf{p}_t$）和法向分量（$\\mathbf{p}_n$）。\n        3.  通过评估折射公式中平方根下的项：$1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2$ 来检查全内反射条件。如果此项为负，则发生TIR。\n        4.  **反射**：如果发生TIR（或对于反射事件），将 `mode` 设置为 $2$。通过反转法向分量来计算新的动量 $\\mathbf{p}'$：$\\mathbf{p}' = \\mathbf{p}_t - \\mathbf{p}_n = \\mathbf{p} - 2\\mathbf{p}_n$。射线继续在入射介质中传播，因此新的方向是 $\\mathbf{u}' = c_{\\mathrm{in}}\\mathbf{p}'$。\n        5.  **折射**：如果未发生TIR，将 `mode` 设置为 $1$。新的法向动量分量的大小为 $p'_{n, \\text{mag}} = \\sqrt{1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2}$。选择符号 $\\sigma$ 以确保射线传播到新的介质中。新的动量为 $\\mathbf{p}' = \\mathbf{p}_t + \\sigma p'_{n, \\text{mag}}\\mathbf{n}$。射线现在位于出射介质中，因此新的方向是 $\\mathbf{u}' = c_{\\mathrm{out}}\\mathbf{p}'$。\n        6.  将状态变量 $\\mathbf{p}$ 和 $\\mathbf{u}$ 更新为它们的新值。然后循环继续到下一个路径段。\n\n3.  **最终处理**：循环终止后，`mode`、$\\mathbf{x}$ 和 $\\mathbf{p}$ 的最终值构成了该测试案例的结果。对所有案例重复此过程。最终输出按要求格式化为单行类JSON字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ray tracing problem for all test cases.\n    \"\"\"\n    # The interface is the plane z=0.\n    interface_point = np.array([0.0, 0.0, 0.0])\n    interface_normal = np.array([0.0, 0.0, 1.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (normal-incidence refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.0, 0.0, 1.0), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case B (oblique refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (1.0/np.sqrt(5), 0.0, 2.0/np.sqrt(5)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case C (total internal reflection is possible, but ray does not reach interface)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (np.sqrt(1 - 0.3**2), 0.0, 0.3), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case D (near-critical refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.499, 0.0, np.sqrt(1 - 0.499**2)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case E (oblique refraction, fast to slow)\n        {'x0': (0.0, 0.0, 100.0), 'u0': (0.6, 0.0, -0.8), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = trace_ray(\n            case['x0'], case['u0'], case['s_max'],\n            case['c1'], case['c2'],\n            interface_normal, interface_point\n        )\n        all_results.append(result)\n\n    # Format the output string precisely as required, without extra whitespace.\n    result_strings = []\n    for res in all_results:\n        # Format mode as int, others as floats using 'g' for general format.\n        formatted_res = [f\"{int(res[0])}\"] + [f\"{v:.15g}\" for v in res[1:]]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef trace_ray(x0, u0, s_max, c1, c2, n, x_int):\n    \"\"\"\n    Implements a ray-shooting integrator with event detection at a planar interface.\n    The ray path is piecewise linear, so the integration is done analytically.\n    \n    Args:\n        x0 (tuple): Initial position vector.\n        u0 (tuple): Initial direction unit vector.\n        s_max (float): Maximum arc-length for integration.\n        c1 (float): Wave speed in medium 1 (phi  0).\n        c2 (float): Wave speed in medium 2 (phi > 0).\n        n (np.ndarray): Interface normal vector.\n        x_int (np.ndarray): A point on the interface plane.\n\n    Returns:\n        list: A list containing [mode, x_final, y_final, z_final, \n                                p_x_final, p_y_final, p_z_final].\n    \"\"\"\n    x = np.array(x0, dtype=float)\n    u = np.array(u0, dtype=float)\n    s = 0.0\n    mode = 0  # 0: no event, 1: refraction, 2: reflection\n\n    # Determine initial medium and momentum p\n    phi = np.dot(n, x - x_int)\n    c_current = c1 if phi  0 else c2\n    p = u / c_current\n\n    while s  s_max:\n        phi = np.dot(n, x - x_int)\n        u_n_comp = np.dot(u, n)\n\n        # Determine incident and outgoing media properties based on current position\n        if phi  0: # In medium 1, moving toward medium 2\n            c_in = c1\n            c_out = c2\n        else: # In medium 2, moving toward medium 1\n            c_in = c2\n            c_out = c1\n\n        # Calculate distance to event (interface crossing)\n        dist_to_event = float('inf') if np.isclose(u_n_comp, 0) else -phi / u_n_comp\n        \n        s_rem = s_max - s\n\n        # A small tolerance avoids re-triggering an event immediately after one.\n        if dist_to_event = 1e-12 or dist_to_event >= s_rem:\n            # No event, or event is beyond s_max. Propagate to the end.\n            x += s_rem * u\n            s = s_max\n            break\n\n        # An event occurs.\n        # 1. Propagate to the interface\n        x += dist_to_event * u\n        s += dist_to_event\n        # Clamp position to the interface to prevent floating-point drift\n        x = x - np.dot(x - x_int, n) * n\n\n        # 2. Handle interface interaction\n        p_t = p - np.dot(p, n) * n\n        p_t_norm_sq = np.dot(p_t, p_t)\n        \n        sqrt_arg = 1.0/c_out**2 - p_t_norm_sq\n        \n        # Check for Total Internal Reflection (TIR)\n        if sqrt_arg  0:\n            mode = 2\n            p = p - 2.0 * np.dot(p, n) * n\n            u = c_in * p\n        else: # Refraction\n            mode = 1\n            sigma = np.sign(u_n_comp)\n            p_n_new_mag = sigma * np.sqrt(sqrt_arg)\n            p = p_t + p_n_new_mag * n\n            u = c_out * p\n\n    return [mode, x[0], x[1], x[2], p[0], p[1], p[2]]\n\nsolve()\n```"
        },
        {
            "introduction": "在计算地球物理学中，算法的选择往往需要在计算成本和内存消耗之间进行权衡。最后一个练习将引导您从计算科学家的视角，对打靶法和弯曲法这两种主流射线追踪策略进行性能分析 。通过推导两种方法单次迭代的浮点运算量表达式，并探讨其内存占用与计算效率的权衡，您将能够更深刻地理解在不同规模和复杂度的地球模型下，选择何种方法更为高效，并为设计大规模并行计算方案提供理论依据。",
            "id": "3614375",
            "problem": "考虑在一个三维各向同性声学介质中进行高频地震射线追踪，该介质的特征由定义在规则笛卡尔网格上的慢度场 $s(\\mathbf{x})$ 描述。射线被建模为源自 Fermat 原理的程函方程的特征曲线。设走时 $T(\\mathbf{x})$ 满足程函方程 $|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})$，并根据哈密顿表述，射线由位置 $\\mathbf{x}(\\tau)$ 和共轭动量 $\\mathbf{p}(\\tau)$ 参数化。慢度场 $s(\\mathbf{x})$ 及其空间梯度 $\\nabla s(\\mathbf{x})$ 在任意点的值通过对网格节点进行三线性插值来计算。\n\n要求您在运算计数的层面上，比较对 $N$ 条独立射线执行一次非线性迭代的两种射线计算策略：\n1. 打靶法，其中每个射线状态 $(\\mathbf{x}, \\mathbf{p})$ 通过一个四阶四级 Runge–Kutta 4 (RK4) 积分器的 $M$ 个显式步沿其路径推进。\n2. 弯曲法，其中每条射线路径由 $M$ 个离散节点表示，并通过组装和求解一个带状（三对角）线性系统在单次 Gauss–Newton 式迭代中更新。该线性系统强制 Fermat 积分的平稳性，并沿路径施加平滑度正则化。\n\n假设以下实现细节，这些细节定义了此估算的基本算术成本：\n- 通过三线性插值在一点计算慢度 $s(\\mathbf{x})$ 及其梯度 $\\nabla s(\\mathbf{x})$ 的成本为 $c_{\\mathrm{eval}}$ 浮点运算 (flops)。\n- 计算哈密顿射线常微分方程 (ODEs) 的右端项，即从 $s(\\mathbf{x})$ 和 $\\nabla s(\\mathbf{x})$ 构建 $\\dot{\\mathbf{x}}$ 和 $\\dot{\\mathbf{p}}$，每次计算的成本为 $c_{\\mathrm{rhs}}$ flops。\n- 对一个维度为 $d$ 的状态（这里 $d=6$，对应 $\\mathbf{x}$ 的三个分量和 $\\mathbf{p}$ 的三个分量）组合 RK4 的各个阶段，每个积分步的成本为 $c_{\\mathrm{comb}}$ flops，该成本包含形成中间阶段状态和最终的加权更新。\n- 在弯曲法中，组装三对角系统的一行贡献（包括与一个路径节点相关的残差项和雅可比项）的成本为每个节点 $c_{\\mathrm{asm}}$ flops，此成本不包括对 $s(\\mathbf{x})$ 和 $\\nabla s(\\mathbf{x})$ 的插值成本。\n- 弯曲法中的三对角系统通过 Thomas 算法对每条射线进行求解，每次求解的精确浮点运算计数为 $8M - 7$ flops。\n\n在这些假设下，推导打靶法和弯曲法每次迭代的总浮点运算计数的解析表达式，这些表达式是 $N$, $M$, $c_{\\mathrm{eval}}$, $c_{\\mathrm{rhs}}$, $c_{\\mathrm{comb}}$ 和 $c_{\\mathrm{asm}}$ 的函数。将您的最终答案表示为一对闭式表达式。此外，用文字讨论这两种方法的内存与计算权衡以及缓存友好性，并以双精度标量的数量指明每种方法中每条射线的存储需求。无需进行数值代入，也无需进行舍入。最终答案必须仅为两个解析表达式，不带单位和文本。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **领域：** 三维各向同性声学介质。\n- **模型：** 基于程函方程 $|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})$ 的哈密顿表述的高频地震射线追踪。\n- **离散化：** 慢度场 $s(\\mathbf{x})$ 定义在规则笛卡尔网格上。\n- **插值：** 使用三线性插值在任意点处寻找 $s(\\mathbf{x})$ 及其梯度 $\\nabla s(\\mathbf{x})$。\n- **任务：** 比较对 $N$ 条独立射线执行一次非线性迭代的两种方法的浮点运算 (flop) 计数。\n- **方法1 (打靶法)：**\n    - **积分器：** 四阶四级 Runge–Kutta 4 (RK4)。\n    - **状态：** $(\\mathbf{x}, \\mathbf{p})$，维度为 $d=6$。\n    - **步数：** 每条射线 $M$ 个显式步。\n- **方法2 (弯曲法)：**\n    - **表示：** 射线路径被离散为 $M$ 个节点。\n    - **迭代：** 单次 Gauss–Newton 式迭代。\n    - **线性系统：** 求解一个带状（三对角）系统。\n- **基本运算成本 (flops)：**\n    - $c_{\\mathrm{eval}}$：通过三线性插值在一点计算 $s(\\mathbf{x})$ 和 $\\nabla s(\\mathbf{x})$ 的成本。\n    - $c_{\\mathrm{rhs}}$：从已知的 $s(\\mathbf{x})$ 和 $\\nabla s(\\mathbf{x})$ 计算哈密顿常微分方程的右端项 $(\\dot{\\mathbf{x}}, \\dot{\\mathbf{p}})$ 的成本。\n    - $c_{\\mathrm{comb}}$：每个积分步组合一个 $d=6$ 状态的 RK4 各阶段的成本。\n    - $c_{\\mathrm{asm}}$：为弯曲法的线性系统组装一行贡献的成本（每个节点），不包括插值成本。\n    - **Thomas 算法成本：** 求解一个 $M \\times M$ 三对角系统的成本为 $8M - 7$ flops。\n- **射线数量：** $N$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n将问题与验证标准进行评估：\n- **科学依据：** 该问题牢固地植根于计算地震学和数值分析的既定原则。射线追踪、程函方程、哈密顿力学、打靶法、弯曲法、RK4 积分和 Gauss-Newton 优化都是该领域的标准、有效概念。\n- **适定性：** 该问题是适定的。它要求基于一组明确定义的符号化基本成本进行运算计数分析。所有必要的变量和常数都已提供，以推导唯一的解析解。\n- **客观性：** 该问题使用精确、客观、技术性的语言陈述，没有歧义或主观论断。\n\n该问题不具有任何列出的缺陷：它在科学上是合理的，可形式化的，完整的，在建模背景下是现实的，并且结构良好。\n\n**步骤3：结论与行动**\n\n问题是**有效的**。将提供完整解答。\n\n### 解答推导\n\n对每种方法，我们为 $N$ 条独立射线推导总浮点运算计数。每种方法的成本是射线数 $N$ 与每条射线成本的乘积。\n\n**1. 打靶法浮点运算计数 ($C_{\\text{shoot}}$)**\n\n打靶法通过使用一个四阶四级 RK4 积分器对哈密顿常微分方程积分 $M$ 步来推进单条射线。我们首先确定单条射线的成本，然后乘以 $N$。\n\n- **一个 RK4 步骤的成本：**\n    - 一个 RK4 积分器执行四次“阶段”评估以将解推进一个步骤。\n    - 每个阶段评估都需要计算常微分方程系统的右端项 (RHS)，即 $(\\dot{\\mathbf{x}}, \\dot{\\mathbf{p}})$。\n    - 一次 RHS 评估的成本是评估慢度场及其梯度 ($c_{\\mathrm{eval}}$) 的成本与从这些值形成常微分方程项 ($c_{\\mathrm{rhs}}$) 的成本之和。因此，一次阶段评估的成本为 $(c_{\\mathrm{eval}} + c_{\\mathrm{rhs}})$。\n    - 由于有四个阶段，一个 RK4 步骤内所有阶段评估的总成本为 $4 \\times (c_{\\mathrm{eval}} + c_{\\mathrm{rhs}})$。\n    - 在计算完四个阶段后，它们通过加权和组合以产生下一步的最终状态。此组合的成本给定为 $c_{\\mathrm{comb}}$。\n    - 因此，一个 RK4 步骤的总成本为 $4(c_{\\mathrm{eval}} + c_{\\mathrm{rhs}}) + c_{\\mathrm{comb}}$。\n\n- **每条射线的成本：**\n    - 射线路径是通过 $M$ 个这样的步骤计算出来的。\n    - 每条射线的总成本为 $M \\times [4(c_{\\mathrm{eval}} + c_{\\mathrm{rhs}}) + c_{\\mathrm{comb}}]$。\n\n- **$N$ 条射线的总成本：**\n    - 由于射线是独立的，总成本是每条射线成本的 $N$ 倍。\n    $$ C_{\\text{shoot}} = N M (4(c_{\\mathrm{eval}} + c_{\\mathrm{rhs}}) + c_{\\mathrm{comb}}) $$\n\n**2. 弯曲法浮点运算计数 ($C_{\\text{bend}}$)**\n\n弯曲法在单次迭代中更新由 $M$ 个节点表示的整个射线路径。此迭代涉及组装和求解一个线性系统。我们确定单条射线的成本，然后乘以 $N$。\n\n- **组装线性系统的成本：**\n    - 组装过程涉及为射线路径的 $M$ 个节点中的每一个计算贡献。\n    - 对于每个节点，组装成本包括评估慢度场及其梯度 ($c_{\\mathrm{eval}}$)，然后计算雅可比矩阵和残差向量相应行的条目 ($c_{\\mathrm{asm}}$)。\n    - 因此，每个节点的成本为 $(c_{\\mathrm{eval}} + c_{\\mathrm{asm}})$。\n    - 一条具有 $M$ 个节点的射线的总组装成本为 $M(c_{\\mathrm{eval}} + c_{\\mathrm{asm}})$。\n\n- **求解线性系统的成本：**\n    - 得到的线性系统是一个 $M \\times M$ 的三对角系统。\n    - 问题陈述指出，使用 Thomas 算法求解此系统的成本恰好为 $8M - 7$ flops。\n\n- **每条射线的成本：**\n    - 每条射线的总成本是组装成本和求解成本之和。\n    - 每条射线的成本 = $M(c_{\\mathrm{eval}} + c_{\\mathrm{asm}}) + (8M - 7)$。这可以简化为 $M(c_{\\mathrm{eval}} + c_{\\mathrm{asm}} + 8) - 7$。\n\n- **$N$ 条射线的总成本：**\n    - 对于 $N$ 条独立射线，总成本为：\n    $$ C_{\\text{bend}} = N (M(c_{\\mathrm{eval}} + c_{\\mathrm{asm}} + 8) - 7) $$\n\n**3. 权衡讨论**\n\n- **内存存储：**\n    - **打靶法：** 单个 RK4 步骤的工作内存是最小的，仅需要存储当前状态（$(\\mathbf{x}, \\mathbf{p})$，$6$ 个标量）和中间阶段的值。然而，为了表示问题所要求的具有 $M$ 步的路径输出，必须存储完整路径。一条连接初始点到后续 $M$ 个点的 $M$ 步路径有 $M+1$ 个节点。在每个节点存储状态向量 $(\\mathbf{x}, \\mathbf{p})$ 需要每条射线 $6(M+1)$ 个双精度标量。\n    - **弯曲法：** 必须将整个射线路径同时保存在内存中才能执行一次迭代。路径由 $M$ 个节点表示，其中每个节点是一个位置向量 $\\mathbf{x} \\in \\mathbb{R}^3$。这至少需要 $3M$ 个标量。此外，三对角线性系统需要临时存储。矩阵可以使用三个长度为 $M$ 的向量存储，残差是一个长度为 $M$ 的向量。这大约需要额外的 $4M$ 个标量。因此，每次迭代中每条射线的总存储量大约为 $7M$ 个标量。\n\n- **计算权衡：**\n    - 在现实场景中，主要成本通常是场求值 $c_{\\mathrm{eval}}$，因为它可能涉及在大型三维网格中进行内存密集型查找。打靶法每条射线需要 $4M$ 次场求值，而弯曲法只需要 $M$ 次。如果 $c_{\\mathrm{eval}}$ 很大，这将给弯曲法带来显著优势。\n    - 弯曲法的组装成本 $c_{\\mathrm{asm}}$ 可能高于打靶法的 RHS 成本 $c_{\\mathrm{rhs}}$，因为它涉及计算走时泛函的二阶导数（Hessian 分量）。然而，打靶法中 $c_{\\mathrm{eval}}$ 的 4 倍因子通常会超过其他差异。\n\n- **缓存友好性和并行性：**\n    - **并行性：** 两种方法在 $N$ 条射线上都是“易于并行”的，因为每条射线的计算都是独立的。\n    - **打靶法：** 对于单条射线，计算本质上是顺序的。第 $i+1$ 步的状态完全取决于第 $i$ 步的状态。对慢度网格 $s(\\mathbf{x})$ 的访问沿着射线的轨迹进行，该轨迹可能不规则，导致空间局部性差，如果网格很大，可能会出现缓存未命中。\n    - **弯曲法：** 对于单条射线，组装步骤会遍历 $M$ 个路径节点。如果这些节点在内存中连续存储，这种访问模式是高度规则且缓存友好的。用于求解系统的 Thomas 算法也涉及对数据的顺序扫描，这是高效的。虽然访问慢度网格仍可能导致缓存未命中，但路径数据本身的内存访问模式优于打靶法。\n\n总之，弯曲法通常以较高的内存使用（一次存储整个路径）换取较低的计算成本（由于较少昂贵的场求值）和更规则的内存访问模式。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} N M (4(c_{\\mathrm{eval}} + c_{\\mathrm{rhs}}) + c_{\\mathrm{comb}})  N (M(c_{\\mathrm{eval}} + c_{\\mathrm{asm}} + 8) - 7) \\end{pmatrix} } $$"
        }
    ]
}