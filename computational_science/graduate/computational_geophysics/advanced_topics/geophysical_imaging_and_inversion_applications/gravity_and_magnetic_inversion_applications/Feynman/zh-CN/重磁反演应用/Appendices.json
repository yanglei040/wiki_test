{
    "hands_on_practices": [
        {
            "introduction": "在任何基于梯度的反演算法中，雅可比矩阵都扮演着核心角色，它量化了模型参数的微小变化如何影响观测数据。通过有限差分法来验证解析雅可比矩阵的正确性，是计算科学领域一项至关重要且不可或缺的实践。这项练习  将指导您从第一性原理出发，推导并实现一个简单的重力正演问题的雅可比矩阵，并通过数值方法验证其准确性，从而为构建可靠的反演代码打下坚实的基础。",
            "id": "3601437",
            "problem": "您的任务是为计算地球物理学中使用的重力正演算子设计并验证一个解析雅可比矩阵。物理背景为三维空间中的一组点质量源，在地表观测点产生重力加速度的垂直分量。您的目标是从第一性原理出发，推导出正演映射及其雅可比矩阵，实现解析雅可比矩阵和有限差分 (FD) 近似方法，并在一个合成模型上验证它们的一致性。然后，应用一个基于归一化弗罗贝尼乌斯范数的量化准则，来判断解析雅可比矩阵是否正确。\n\n基本原理：\n- 牛顿万有引力定律：两个点质量相互吸引的力的大小与它们的质量乘积成正比，与它们之间距离的平方成反比。\n- 线性叠加原理：在某观测点处的总场是每个源贡献的总和。\n- 引力常数 $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$。\n- 模型参数是点源的质量，单位为千克。\n- 观测点坐标和源坐标以米为单位；垂直轴为 $z$ 轴，观测点位于 $z=0$，源位于 $z<0$。重力加速度的垂直分量必须以 $\\mathrm{m/s^2}$ 表示。\n\n任务：\n1. 从上述基本原理出发，纯粹通过数学推导，导出从质量向量到一组观测点上重力加速度垂直分量的正演映射，并由此推导出关于质量的解析雅可比矩阵。\n2. 实现一个程序，该程序能够：\n   - 计算给定一组质量在观测点处的正演响应。\n   - 计算关于质量的解析雅可比矩阵。\n   - 使用前向差分格式和指定的扰动大小 $\\epsilon$ (单位为 $\\mathrm{kg}$) 计算有限差分 (FD) 雅可比矩阵。\n   - 使用归一化的弗罗贝尼乌斯范数准则比较解析雅可比矩阵与 FD 雅可比矩阵\n     $$\\frac{\\left\\| J_{\\text{analytic}} - J_{\\text{FD}} \\right\\|_{F}}{\\left\\| J_{\\text{FD}} \\right\\|_{F}} < 10^{-3}。$$\n   - 对每个测试用例返回一个布尔值，指示该准则是否满足。\n3. 确保科学真实性：不要将任何观测点精确地放置在源的位置上。所有距离都应为正且有限。在整个过程中使用给定的物理常数 $G$ 和国际单位制 (SI)。\n4. 本问题不涉及角度，因此不需要角度单位。每个测试用例的输出是布尔值，因此最终输出不需要物理单位。\n\n测试套件 (在您的程序中逐字使用下面提供的确切参数值)：\n- 情况 1 (常规配置，中等偏移)：\n  - 观测点 ($N_{\\text{obs}} = 5$)，位于 $z=0$：\n    $[(-100,0,0),(-50,0,0),(0,0,0),(50,0,0),(100,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 4$)，位于 $z=-50$：\n    $[(-75,0,-50),(-25,0,-50),(25,0,-50),(75,0,-50)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [2 \\times 10^{8}, 1.5 \\times 10^{8}, 1.0 \\times 10^{8}, 0.5 \\times 10^{8}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{6} \\ \\mathrm{kg}$。\n- 情况 2 (近场灵敏度，小间距)：\n  - 观测点 ($N_{\\text{obs}} = 3$)，位于 $z=0$：\n    $[(-10,0,0),(0,0,0),(10,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 2$)，位于 $z=-10$：\n    $[(0,0,-10),(20,0,-10)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [1.0 \\times 10^{7}, 2.0 \\times 10^{7}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{3} \\ \\mathrm{kg}$。\n- 情况 3 (远场状态，大偏移和深度)：\n  - 观测点 ($N_{\\text{obs}} = 3$)，位于 $z=0$：\n    $[(-1000,0,0),(0,0,0),(1000,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 3$)，位于 $z=-500$：\n    $[(-500,0,-500),(0,0,-500),(500,0,-500)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [5.0 \\times 10^{10}, 3.0 \\times 10^{10}, 4.0 \\times 10^{10}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{12} \\ \\mathrm{kg}$。\n\n数值要求：\n- 使用双精度浮点运算。\n- 对于 FD 近似，使用前向差分格式：对于第 $i$ 个参数，通过 $+\\epsilon$ 进行扰动，并将该列计算为 $(\\mathbf{d}(\\mathbf{m}+\\epsilon \\mathbf{e}_i) - \\mathbf{d}(\\mathbf{m}))/\\epsilon$，其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量。\n- 对矩阵使用弗罗贝尼乌斯范数。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}]$，其中每个 $\\text{result}_{k}$ 是一个布尔值，对应于情况 $k$ 是否满足准则。输出必须按照上面给出的情况顺序排列。",
            "solution": "## 问题验证 ##\n\n### 步骤 1：提取已知信息 ###\n问题提供了以下信息：\n\n**基本原理和常数：**\n- **牛顿万有引力定律**：力的大小 $F \\propto \\frac{m_1 m_2}{r^2}$。\n- **线性叠加原理**：总场是各个场的总和。\n- **引力常数**：$G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$。\n\n**模型和数据定义：**\n- **模型参数**：一个由点源质量组成的向量 $\\mathbf{m}$，单位为千克 ($\\mathrm{kg}$)。\n- **源**：位于坐标 $(x', y', z')$ 处，其中 $z'  0$。坐标单位为米 ($\\mathrm{m}$)。\n- **观测**：位于坐标 $(x, y, z)$ 处，其中 $z = 0$。数据是重力加速度的垂直分量 $g_z$，单位为 $\\mathrm{m/s^2}$。\n- **雅可比矩阵验证准则**：$\\frac{\\left\\| J_{\\text{analytic}} - J_{\\text{FD}} \\right\\|_{F}}{\\left\\| J_{\\text{FD}} \\right\\|_{F}}  10^{-3}$。\n- **有限差分 (FD) 格式**：使用扰动量 $\\epsilon$ (单位 $\\mathrm{kg}$) 的前向差分法。第 $i$ 列为 $(\\mathbf{d}(\\mathbf{m}+\\epsilon \\mathbf{e}_i) - \\mathbf{d}(\\mathbf{m}))/\\epsilon$。\n\n**测试用例：**\n- **情况 1**：\n  - 观测点 ($N_{\\text{obs}} = 5$ 位于 $z=0$)：$[(-100,0,0),(-50,0,0),(0,0,0),(50,0,0),(100,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 4$ 位于 $z=-50$)：$[(-75,0,-50),(-25,0,-50),(25,0,-50),(75,0,-50)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [2 \\times 10^{8}, 1.5 \\times 10^{8}, 1.0 \\times 10^{8}, 0.5 \\times 10^{8}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{6} \\ \\mathrm{kg}$。\n- **情况 2**：\n  - 观测点 ($N_{\\text{obs}} = 3$ 位于 $z=0$)：$[(-10,0,0),(0,0,0),(10,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 2$ 位于 $z=-10$)：$[(0,0,-10),(20,0,-10)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [1.0 \\times 10^{7}, 2.0 \\times 10^{7}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{3} \\ \\mathrm{kg}$。\n- **情况 3**：\n  - 观测点 ($N_{\\text{obs}} = 3$ 位于 $z=0$)：$[(-1000,0,0),(0,0,0),(1000,0,0)] \\ \\mathrm{m}$。\n  - 源 ($N_{\\text{src}} = 3$ 位于 $z=-500$)：$[(-500,0,-500),(0,0,-500),(500,0,-500)] \\ \\mathrm{m}$。\n  - 质量向量 $\\mathbf{m} = [5.0 \\times 10^{10}, 3.0 \\times 10^{10}, 4.0 \\times 10^{10}] \\ \\mathrm{kg}$。\n  - 有限差分步长 $\\epsilon = 10^{12} \\ \\mathrm{kg}$。\n\n### 步骤 2：使用提取的已知信息进行验证 ###\n根据验证标准对问题进行评估：\n- **科学依据**：该问题建立在经典物理学的基石——牛顿万有引力定律之上。点质量模型是入门级位场地球物理学中一个标准且有效的简化。所有物理量都给出了适当的国际单位制 (SI) 单位，且 $G$ 的值是正确的。\n- **适定性**：问题定义清晰。它要求推导一个正演模型及其雅可比矩阵，然后进行数值验证。只要观测点和源点不重合，正演模型就是从质量到重力加速度的线性变换，存在唯一解。问题陈述通过将源置于 $z  0$ 且观测点位于 $z=0$ 来确保这一点。验证准则是定量的，没有歧义。\n- **客观性**：问题使用精确的数学语言陈述，所有参数和条件都明确定义。它没有含糊不清或主观的陈述。\n- **完整性与一致性**：为每个测试用例提供了所有必要的数据（坐标、质量、常数、扰动大小）。约束条件是一致的，不会导致矛盾。例如，指定的坐标确保了任何源与观测点之间的距离始终大于零。\n- **真实性**：虽然点质量模型是对真实地质体的简化，但它在地球物理建模中是一个科学上真实且常见的起点。质量和距离的量级在地球物理勘探的合理范围内。\n\n该问题没有表现出任何列出的缺陷（例如，科学上不健全、数据缺失、含糊不清）。\n\n### 步骤 3：结论与行动 ###\n该问题是**有效的**。将提供一个分步解答。\n\n## 解答 ##\n\n### 第 1 部分：正演映射和解析雅可比矩阵的推导 ###\n\n**1.1. 单个点质量的引力场**\n\n根据牛顿万有引力定律，位于 $\\mathbf{r}'_j$ 处的源质量 $m_j$ 对位于 $\\mathbf{r}_i$ 处的测试质量 $m_{\\text{test}}$ 所施加的引力 $\\mathbf{F}_{ij}$ 由以下公式给出：\n$$ \\mathbf{F}_{ij} = -G \\frac{m_{\\text{test}} m_j}{\\|\\mathbf{r}_i - \\mathbf{r}'_j\\|^2} \\frac{\\mathbf{r}_i - \\mathbf{r}'_j}{\\|\\mathbf{r}_i - \\mathbf{r}'_j\\|} = -G \\frac{m_{\\text{test}} m_j}{\\|\\Delta\\mathbf{r}_{ij}\\|^3} \\Delta\\mathbf{r}_{ij} $$\n其中 $G$ 是引力常数，$\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}'_j$ 是从源指向观测点的向量。负号表示该力是引力（从观测者指向源）。\n\n在 $\\mathbf{r}_i$ 处由 $m_j$ 引起的引力加速度 $\\mathbf{g}_{ij}$ 是单位测试质量所受的力：\n$$ \\mathbf{g}_{ij} = \\frac{\\mathbf{F}_{ij}}{m_{\\text{test}}} = -G \\frac{m_j}{\\|\\Delta\\mathbf{r}_{ij}\\|^3} \\Delta\\mathbf{r}_{ij} $$\n设坐标为 $\\mathbf{r}_i = (x_i, y_i, z_i)$ 和 $\\mathbf{r}'_j = (x'_j, y'_j, z'_j)$。距离的平方为 $r_{ij}^2 = \\|\\Delta\\mathbf{r}_{ij}\\|^2 = (x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2$。加速度向量为：\n$$ \\mathbf{g}_{ij} = -G \\frac{m_j}{(r_{ij}^2)^{3/2}} \\left( (x_i - x'_j)\\hat{\\mathbf{x}} + (y_i - y'_j)\\hat{\\mathbf{y}} + (z_i - z'_j)\\hat{\\mathbf{z}} \\right) $$\n\n**1.2. 重力加速度的垂直分量**\n\n问题要求的是加速度的垂直分量，即沿 $z$ 轴的分量。我们通过与垂直单位向量 $\\hat{\\mathbf{z}}$ 进行点积来获得该分量：\n$$ g_{z, ij} = \\mathbf{g}_{ij} \\cdot \\hat{\\mathbf{z}} = -G \\frac{m_j (z_i - z'_j)}{((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2)^{3/2}} $$\n\n**1.3. 多源的正演映射**\n\n根据线性叠加原理，观测点 $i$ 处的总垂直加速度 $d_i$ 是所有 $N_{\\text{src}}$ 个源贡献的总和：\n$$ d_i(\\mathbf{m}) = \\sum_{j=1}^{N_{\\text{src}}} g_{z, ij} = \\sum_{j=1}^{N_{\\text{src}}} \\left( -G \\frac{z_i - z'_j}{r_{ij}^3} \\right) m_j $$\n其中 $\\mathbf{m} = [m_1, m_2, \\dots, m_{N_{\\text{src}}}]^T$ 是源质量向量。此方程定义了从模型参数（质量）到数据（垂直重力加速度）的正演映射。\n\n这种关系相对于质量 $m_j$ 是线性的。我们可以将整个观测数据集 $\\mathbf{d} = [d_1, d_2, \\dots, d_{N_{\\text{obs}}}]^T$ 表示为矩阵-向量乘积：\n$$ \\mathbf{d} = \\mathbf{A} \\mathbf{m} $$\n其中 $\\mathbf{A}$ 是一个大小为 $N_{\\text{obs}} \\times N_{\\text{src}}$ 的正演算子矩阵，其元素为：\n$$ A_{ij} = -G \\frac{z_i - z'_j}{\\left((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2\\right)^{3/2}} $$\n\n**1.4. 解析雅可比矩阵的推导**\n\n正演映射 $\\mathbf{d}(\\mathbf{m})$ 的雅可比矩阵由其元素 $J_{ik} = \\frac{\\partial d_i}{\\partial m_k}$ 定义。我们将 $d_i$ 的表达式对第 $k$ 个质量 $m_k$ 求导：\n$$ J_{ik} = \\frac{\\partial}{\\partial m_k} \\left( \\sum_{j=1}^{N_{\\text{src}}} A_{ij} m_j \\right) $$\n由于矩阵元素 $A_{ij}$ 仅依赖于几何（坐标）而不依赖于质量，因此在此偏微分中它们被视为常数：\n$$ J_{ik} = \\sum_{j=1}^{N_{\\text{src}}} A_{ij} \\frac{\\partial m_j}{\\partial m_k} $$\n偏导数 $\\frac{\\partial m_j}{\\partial m_k}$ 等于克罗内克 δ 函数 $\\delta_{jk}$，当 $j=k$ 时为 1，否则为 0。\n$$ J_{ik} = \\sum_{j=1}^{N_{\\text{src}}} A_{ij} \\delta_{jk} = A_{ik} $$\n因此，解析雅可比矩阵 $\\mathbf{J}_{\\text{analytic}}$ 与正演算子矩阵 $\\mathbf{A}$ 完全相同。解析雅可比矩阵的元素为：\n$$ J_{\\text{analytic}, ij} = -G \\frac{z_i - z'_j}{\\left((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2\\right)^{3/2}} $$\n\n### 第 2 部分：实现与验证策略 ###\n\n程序将实现推导出的公式和验证过程。\n\n**2.1. 解析雅可比矩阵的实现**\n一个函数将使用其推导出的公式直接计算矩阵 $\\mathbf{J}_{\\text{analytic}}$。给定观测点和源坐标，该函数将构造一个 $N_{\\text{obs}} \\times N_{\\text{src}}$ 的矩阵。\n\n**2.2. 有限差分 (FD) 雅可比矩阵的实现**\n第二个函数将使用前向有限差分法来近似雅可比矩阵。对于雅可比矩阵的每一列 $k$（对应于质量 $m_k$）：\n1.  计算基准数据向量：$\\mathbf{d}_{\\text{base}} = \\mathbf{d}(\\mathbf{m})$。\n2.  创建一个扰动后的质量向量 $\\mathbf{m}_{\\text{pert}} = \\mathbf{m} + \\epsilon \\mathbf{e}_k$，其中 $\\mathbf{e}_k$ 是第 $k$ 个标准基向量，$\\epsilon$ 是小扰动量。\n3.  计算扰动后的数据向量：$\\mathbf{d}_{\\text{pert}} = \\mathbf{d}(\\mathbf{m}_{\\text{pert}})$。\n4.  FD 雅可比矩阵的第 $k$ 列计算为 $(\\mathbf{d}_{\\text{pert}} - \\mathbf{d}_{\\text{base}}) / \\epsilon$。\n对所有 $k = 1, \\dots, N_{\\text{src}}$ 重复此过程。\n\n**2.3. 验证**\n得到的两个矩阵 $\\mathbf{J}_{\\text{analytic}}$ 和 $\\mathbf{J}_{\\text{FD}}$ 将使用指定的准则进行比较。矩阵 $\\mathbf{M}$ 的弗罗贝尼乌斯范数由 $\\|\\mathbf{M}\\|_F = \\sqrt{\\sum_i \\sum_j M_{ij}^2}$ 给出。比较过程涉及计算：\n$$ \\text{error} = \\frac{\\left\\| \\mathbf{J}_{\\text{analytic}} - \\mathbf{J}_{\\text{FD}} \\right\\|_{F}}{\\left\\| \\mathbf{J}_{\\text{FD}} \\right\\|_{F}} $$\n每个测试用例的结果是一个布尔值，指示 $\\text{error}  10^{-3}$ 是否成立。由于正演问题在质量上是线性的，只要浮点精度足够，FD 近似应与解析雅可比矩阵几乎完全相同。误差应接近机器精度，因此 $10^{-3}$ 的阈值很容易达到。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravity Jacobian validation problem for all specified test cases.\n    \"\"\"\n    \n    # Gravitational Constant [m^3 kg^-1 s^-2]\n    G = 6.67430e-11\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"obs_coords\": np.array([[-100, 0, 0], [-50, 0, 0], [0, 0, 0], [50, 0, 0], [100, 0, 0]]),\n            \"src_coords\": np.array([[-75, 0, -50], [-25, 0, -50], [25, 0, -50], [75, 0, -50]]),\n            \"masses\": np.array([2e8, 1.5e8, 1.0e8, 0.5e8]),\n            \"epsilon\": 1e6\n        },\n        {\n            \"obs_coords\": np.array([[-10, 0, 0], [0, 0, 0], [10, 0, 0]]),\n            \"src_coords\": np.array([[0, 0, -10], [20, 0, -10]]),\n            \"masses\": np.array([1.0e7, 2.0e7]),\n            \"epsilon\": 1e3\n        },\n        {\n            \"obs_coords\": np.array([[-1000, 0, 0], [0, 0, 0], [1000, 0, 0]]),\n            \"src_coords\": np.array([[-500, 0, -500], [0, 0, -500], [500, 0, -500]]),\n            \"masses\": np.array([5.0e10, 3.0e10, 4.0e10]),\n            \"epsilon\": 1e12\n        }\n    ]\n\n    results = []\n    \n    # A tolerance smaller than the problem's criteria to handle very small norms\n    machine_precision_tol = 1e-15\n\n    for case in test_cases:\n        obs_coords = case[\"obs_coords\"]\n        src_coords = case[\"src_coords\"]\n        masses = case[\"masses\"]\n        epsilon = case[\"epsilon\"]\n\n        n_obs = obs_coords.shape[0]\n        n_src = src_coords.shape[0]\n\n        # --- Analytical Jacobian Calculation ---\n        # The analytical Jacobian is the sensitivity matrix 'A' because the\n        # forward problem d = Am is linear in m.\n        \n        # Use broadcasting to compute all pairwise interactions efficiently.\n        # obs_coords shape: (n_obs, 1, 3)\n        # src_coords shape: (1, n_src, 3)\n        # delta_r shape:    (n_obs, n_src, 3)\n        delta_r = obs_coords[:, np.newaxis, :] - src_coords[np.newaxis, :, :]\n        \n        # r_sq[i, j] = distance squared between obs_i and src_j\n        r_sq = np.sum(delta_r**2, axis=2)\n        r_cubed = r_sq**(3/2)\n        \n        # delta_z[i, j] = z_i - z'_j\n        delta_z = delta_r[:, :, 2]\n        \n        j_analytic = -G * delta_z / r_cubed\n        \n        # --- Forward Model Function ---\n        # The forward model computes the data vector d = j_analytic @ masses\n        def forward_model(m_vec):\n            return j_analytic @ m_vec\n\n        # --- Finite Difference Jacobian Calculation ---\n        j_fd = np.zeros((n_obs, n_src), dtype=np.float64)\n        \n        # Calculate baseline data vector\n        d_base = forward_model(masses)\n        \n        # Perturb each mass one by one to compute columns of the Jacobian\n        m_perturbed = np.copy(masses)\n        for k in range(n_src):\n            m_perturbed[k] += epsilon\n            \n            d_perturbed = forward_model(m_perturbed)\n            \n            # Compute the k-th column of the FD Jacobian\n            j_fd[:, k] = (d_perturbed - d_base) / epsilon\n            \n            # Reset the perturbed mass for the next iteration\n            m_perturbed[k] = masses[k]\n\n        # --- Comparison ---\n        norm_diff = np.linalg.norm(j_analytic - j_fd, 'fro')\n        norm_fd = np.linalg.norm(j_fd, 'fro')\n\n        # The comparison is valid only if the denominator is non-zero.\n        # Since the problem is linear, the difference should be near floating-point zero.\n        if norm_fd  machine_precision_tol:\n            is_correct = (norm_diff  machine_precision_tol)\n        else:\n            relative_error = norm_diff / norm_fd\n            is_correct = relative_error  1e-3\n\n        results.append(is_correct)\n    \n    # Final print statement in the exact required format.\n    # The map(str,...) converts boolean True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的重力勘探中，原始观测数据会受到地形起伏引起的引力效应的显著影响，这种效应必须在数据处理中进行精确校正。通过对地形的离散模型（如三角网格）进行牛顿万有引力定律的积分，可以准确地计算出地形改正值。这项练习  将教您如何利用三角网格对复杂地质结构（地形）进行正演建模，并将这种严密计算的结果与经典的布格平差近似进行对比，从而深刻理解精确正演建模在地球物理反演中的重要性。",
            "id": "3601393",
            "problem": "您的任务是推导并实现一个物理上一致的数值模型，用以量化当形貌表面由三角网格表示时的重力地形效应及其布格校正近似。该场景涉及一个位于合成地形上方的航空重力观测点。地形被建模为有限矩形域上的一个连续高度函数，并用三角形进行离散化。您的程序必须计算由地形质量产生的重力加速度垂直分量（表示为网格上的积分），并量化相对于参考解的离散化误差。您还必须计算在观测位置，基于网格的解与经典布格板校正之间的差异。\n\n从万有引力定律出发：由质量密度分布 $\\rho(\\mathbf{r})$ 在坐标为 $(x_p,y_p,z_p)$ 的观测点产生的重力加速度垂直分量 $g_z$ 由下式给出\n$$\ng_z(\\mathbf{r}_p) \\;=\\; G \\int_V \\rho(\\mathbf{r}) \\frac{z - z_p}{\\left( (x-x_p)^2+(y-y_p)^2+(z-z_p)^2 \\right)^{3/2}} \\,\\mathrm{d}V,\n$$\n其中 $G$ 是引力常数，$\\mathbf{r}=(x,y,z)$ 是源点。考虑一个位于 $z=0$ 的参考基准面和一个地形高度函数 $h(x,y) \\geq 0$。在每个水平位置 $(x,y)$，地形质量被建模为一个垂直柱体，具有均匀的岩石密度 $\\rho$ 和厚度 $h(x,y)$（基准面以上的地形）。指定观测高度 $z_p$ 满足 $z_p  \\max_{(x,y)} h(x,y)$，以确保被积函数非奇异。该域被截断为以观测点为中心的有限半径 $R$ 内，因此只包括水平距离 $a(x,y)=\\sqrt{(x-x_p)^2+(y-y_p)^2}$ 满足 $a(x,y) \\leq R$ 的贡献。\n\n在固定的水平位置 $(x,y)$，推导沿 $z$ 方向的垂直分量核函数的解析积分，并写出在代表地形表面的三角网格上的相应曲面积分。使用以下基本事实：\n- 连续质量分布的牛顿引力。\n- 国际单位制（SI），其中 $G$ 的单位为 $\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，距离单位为 $\\mathrm{m}$，密度单位为 $\\mathrm{kg\\,m^{-3}}$，重力加速度单位为 $\\mathrm{m\\,s^{-2}}$。\n- 每个三角形使用基于质心的单点求积来近似曲面积分。\n\n通过各向异性高斯函数定义 $\\mathbb{R}^2$ 上的地形高度函数\n$$\nh(x,y) \\;=\\; H \\exp\\!\\left( -\\frac{x^2}{2 \\sigma_x^2} - \\frac{y^2}{2 \\sigma_y^2} \\right),\n$$\n其中峰值高度为 $H$，特征尺度为 $\\sigma_x$ 和 $\\sigma_y$，矩形计算域为 $[-L_x/2,L_x/2]\\times[-L_y/2,L_y/2]$，该域被分割成 $N_x \\times N_y$ 个矩形单元，每个单元又被分成两个三角形。对于每个质心为 $(x_c,y_c)$、面积为 $A_T$ 的三角形 $T$，通过沿 $z\\in[0,h(x_c,y_c)]$ 的垂直柱体进行积分，并对所有质心满足 $\\sqrt{(x_c-x_p)^2+(y_c-y_p)^2} \\leq R$ 的三角形求和，来近似其对 $g_z$ 的贡献。\n\n在观测位置 $(x_p,y_p)$ 的经典布格板校正假设存在一个厚度为 $h(x_p,y_p)$、密度均匀为 $\\rho$ 的无限水平板，从而得出近似垂直加速度\n$$\ng_{\\text{B}} \\;=\\; 2 \\pi G \\rho \\, h(x_p,y_p).\n$$\n\n实现一个程序，该程序：\n1. 为给定的 $(L_x,L_y,N_x,N_y)$ 构建三角网格的质心和面积。\n2. 在每个三角形质心处计算 $h(x_c,y_c)$。\n3. 通过在每个质心处使用 z 方向的解析积分，并对质心半径 $\\leq R$ 的三角形进行求和，计算基于网格的 $g_z$ 作为地形积分的数值近似。\n4. 通过使用更大的 $(N_x,N_y)$ 重复步骤 3，计算一个高分辨率的参考 $g_z$。\n5. 报告每个测试用例的两个量：\n   - 绝对离散化误差，以 $\\mathrm{m\\,s^{-2}}$ 为单位的浮点数：$|g_{z,\\text{mesh}} - g_{z,\\text{ref}}|$。\n   - 布格板值 $g_{\\text{B}}$ 与高分辨率参考值 $g_{z,\\text{ref}}$ 之间的绝对差，单位为 $\\mathrm{m\\,s^{-2}}$：$|g_{\\text{B}} - g_{z,\\text{ref}}|$。\n\n所有距离的单位必须是 $\\mathrm{m}$，密度单位是 $\\mathrm{kg\\,m^{-3}}$，加速度单位是 $\\mathrm{m\\,s^{-2}}$。此问题不涉及角度。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例一个列表，格式为 $[E_{\\text{disc}},E_{\\text{slab}}]$。\n\n使用以下参数集测试套件：\n- 情况 1 (正常路径)：$H=300\\,\\mathrm{m}$，$\\sigma_x=\\sigma_y=800\\,\\mathrm{m}$，$L_x=L_y=6000\\,\\mathrm{m}$，$N_x=N_y=64$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=256$，$R=3000\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1200\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n- 情况 2 (边界/截断主导)：$H=300\\,\\mathrm{m}$，$\\sigma_x=\\sigma_y=600\\,\\mathrm{m}$，$L_x=L_y=2400\\,\\mathrm{m}$，$N_x=N_y=16$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=128$，$R=1200\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1200\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n- 情况 3 (各向异性边缘情况)：$H=200\\,\\mathrm{m}$，$\\sigma_x=1000\\,\\mathrm{m}$，$\\sigma_y=400\\,\\mathrm{m}$，$L_x=L_y=7000\\,\\mathrm{m}$，$N_x=N_y=48$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=192$，$R=2500\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1500\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出必须是包含三个列表的列表，每个测试用例一个，格式为 $[E_{\\text{disc}},E_{\\text{slab}}]$，例如：$[[e_{11},e_{12}],[e_{21},e_{22}],[e_{31},e_{32}]]$。",
            "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n**公式与定义：**\n-   重力加速度的垂直分量：\n    $g_z(\\mathbf{r}_p) = G \\int_V \\rho(\\mathbf{r}) \\frac{z - z_p}{\\left( (x-x_p)^2+(y-y_p)^2+(z-z_p)^2 \\right)^{3/2}} \\,\\mathrm{d}V$\n-   引力常数：$G$\n-   质量密度：$\\rho(\\mathbf{r})$，假定为常数 $\\rho$\n-   观测点：$\\mathbf{r}_p = (x_p, y_p, z_p)$\n-   源点：$\\mathbf{r} = (x, y, z)$\n-   地形模型：质量存在于 $z \\in [0, h(x,y)]$ 的区域，其中 $h(x,y) \\geq 0$ 是地形高度函数。\n-   对观测高度的约束：$z_p  \\max_{(x,y)} h(x,y)$\n-   域截断：水平距离 $a(x,y)=\\sqrt{(x-x_p)^2+(y-y_p)^2} \\leq R$。\n-   地形高度函数：$h(x,y) = H \\exp\\!\\left( -\\frac{x^2}{2 \\sigma_x^2} - \\frac{y^2}{2 \\sigma_y^2} \\right)$\n-   计算域：$[-L_x/2, L_x/2] \\times [-L_y/2, L_y/2]$\n-   网格：域被划分为 $N_x \\times N_y$ 个矩形单元，每个单元被分成两个三角形。\n-   数值近似：在每个三角形的质心处使用单点求积。\n-   布格板近似：$g_{\\text{B}} = 2 \\pi G \\rho \\, h(x_p,y_p)$\n\n**待计算的量：**\n1.  绝对离散化误差：$|g_{z,\\text{mesh}} - g_{z,\\text{ref}}|$\n2.  绝对布格板差异：$|g_{\\text{B}} - g_{z,\\text{ref}}|$\n\n**测试用例参数：**\n-   **情况 1：** $H=300\\,\\mathrm{m}$，$\\sigma_x=\\sigma_y=800\\,\\mathrm{m}$，$L_x=L_y=6000\\,\\mathrm{m}$，$N_x=N_y=64$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=256$，$R=3000\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1200\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n-   **情况 2：** $H=300\\,\\mathrm{m}$，$\\sigma_x=\\sigma_y=600\\,\\mathrm{m}$，$L_x=L_y=2400\\,\\mathrm{m}$，$N_x=N_y=16$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=128$，$R=1200\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1200\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n-   **情况 3：** $H=200\\,\\mathrm{m}$，$\\sigma_x=1000\\,\\mathrm{m}$，$\\sigma_y=400\\,\\mathrm{m}$，$L_x=L_y=7000\\,\\mathrm{m}$，$N_x=N_y=48$，$N_{x,\\text{ref}}=N_{y,\\text{ref}}=192$，$R=2500\\,\\mathrm{m}$，$(x_p,y_p)=(0,0)$，$z_p=1500\\,\\mathrm{m}$，$\\rho=2670\\,\\mathrm{kg\\,m^{-3}}$，$G=6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于牛顿万有引力定律，这是经典物理学的基石。将其应用于计算重力地形校正是位场地球物理学中的一个标准问题。所提供的重力加速度和布格板近似公式均为标准公式。使用高斯函数作为合成地形特征是建模研究中常见且合理的选择。整个问题设定在科学上是合理的。\n-   **良态的 (Well-Posed)：** 该问题是良态的。所有必要的参数和常数都已提供。积分域是有限的，且条件 $z_p  \\max(h(x,y))$ 确保了被积函数非奇异，保证了积分结果的有限性和唯一性。任务被清晰地指定为一系列导致确定性输出的计算。\n-   **客观性：** 问题以精确、客观的数学和物理术语陈述。输入是数值性的，所要求的输出是定义明确的定量值。没有模糊性、主观性或依赖于观点。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是一个定义明确、有科学依据的计算物理问题。将提供完整的解决方案。\n\n## 基于原理的设计与求解\n\n问题的核心是计算由地形质量分布产生的重力加速度的垂直分量 $g_z$。出发点是连续质量分布的牛顿定律的体积分形式：\n$$\ng_z(\\mathbf{r}_p) = G \\int_V \\rho(\\mathbf{r}) \\frac{z - z_p}{\\left( (x-x_p)^2+(y-y_p)^2+(z-z_p)^2 \\right)^{3/2}} \\,\\mathrm{d}V\n$$\n给定常数密度 $\\rho$ 和由基准面 $z=0$ 与地形表面 $z=h(x,y)$ 之间的区域所定义的体积，体积分可以分解为水平面上的曲面积分和沿 $z$ 的垂直积分：\n$$\ng_z(\\mathbf{r}_p) = G \\rho \\int_D \\left( \\int_{z=0}^{h(x,y)} \\frac{z - z_p}{\\left( a(x,y)^2 + (z-z_p)^2 \\right)^{3/2}} \\,\\mathrm{d}z \\right) \\,\\mathrm{d}A\n$$\n其中 $D$ 是问题定义的水平域，$a(x,y)^2 = (x-x_p)^2+(y-y_p)^2$。\n\n第一步是解析地计算关于 $z$ 的内层积分。令 $u = z - z_p$，则 $\\mathrm{d}u = \\mathrm{d}z$。积分限变为 $-z_p$ 和 $h(x,y) - z_p$。积分的形式为 $\\int u(a^2+u^2)^{-3/2} \\mathrm{d}u$，其计算结果为 $-(a^2+u^2)^{-1/2}$。应用积分限：\n$$\n\\left[ -\\frac{1}{\\sqrt{a(x,y)^2 + (z-z_p)^2}} \\right]_{z=0}^{h(x,y)} = -\\frac{1}{\\sqrt{a(x,y)^2 + (h(x,y)-z_p)^2}} - \\left( -\\frac{1}{\\sqrt{a(x,y)^2 + (-z_p)^2}} \\right)\n$$\n这简化为：\n$$\n\\frac{1}{\\sqrt{a(x,y)^2 + z_p^2}} - \\frac{1}{\\sqrt{a(x,y)^2 + (h(x,y)-z_p)^2}}\n$$\n因此，$g_z$ 的表达式变成一个在水平域 $D$ 上的曲面积分：\n$$\ng_z(\\mathbf{r}_p) = G \\rho \\int_D \\left[ \\frac{1}{\\sqrt{(x-x_p)^2+(y-y_p)^2 + z_p^2}} - \\frac{1}{\\sqrt{(x-x_p)^2+(y-y_p)^2 + (h(x,y)-z_p)^2}} \\right] \\,\\mathrm{d}A\n$$\n由于对于所有源点 $z \\in [0, h(x,y)]$，我们有 $z  z_p$，原始积分中的项 $z-z_p$ 总是负的，这意味着 $g_z$ 将为负值，正确地表示一个向下的引力。\n\n下一步是数值近似这个曲面积分。问题指定了一种方法，即将域离散化为三角网格，并在每个三角形的质心处应用单点求积法则。域 $[-L_x/2, L_x/2] \\times [-L_y/2, L_y/2]$ 被划分为 $N_x \\times N_y$ 个大小为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$ 的矩形单元。每个单元被分成两个面积相等的三角形，面积为 $A_T = \\frac{1}{2}\\Delta x \\Delta y$。对于左下角位于 $(x_{i}, y_{j})$ 的矩形单元，沿其主对角线分割会产生两个三角形，其质心分别位于 $(x_i + \\frac{2}{3}\\Delta x, y_j + \\frac{1}{3}\\Delta y)$ 和 $(x_i + \\frac{1}{3}\\Delta x, y_j + \\frac{2}{3}\\Delta y)$。\n\n将被积函数表示为 $I(x,y)$。$g_z$ 的数值近似是所有质心 $(x_{c,k}, y_{c,k})$ 位于观测点水平投影半径 $R$ 内的三角形 $k$ 的求和：\n$$\ng_{z, \\text{mesh}} \\approx \\sum_{k \\text{ s.t. } a(x_{c,k}, y_{c,k}) \\leq R} I(x_{c,k}, y_{c,k}) \\cdot A_T\n$$\n其中 $I(x_c, y_c)$ 是在质心坐标处计算的、带有相应高度 $h(x_c, y_c)$ 的派生核函数。\n\n计算算法如下：\n1.  定义一个函数 `compute_gz`，该函数接受网格和物理参数作为输入。\n2.  在此函数内，计算网格元素的尺寸 $\\Delta x, \\Delta y$ 和面积 $A_T$。\n3.  生成网格中所有 $2 \\times N_x \\times N_y$ 个三角形的质心坐标。这可以通过使用 NumPy 的向量化操作和 `meshgrid` 功能高效完成。\n4.  过滤这些质心，只保留那些与观测点 $(x_p,y_p)$ 的水平距离在指定半径 $R$ 内的质心。\n5.  在每个有效质心处，计算地形高度函数 $h(x,y)$，然后计算完整的被积函数 $I(x,y)$。\n6.  将贡献（被积函数值乘以三角形面积）求和，并乘以 $G\\rho$ 以获得最终的 $g_z$ 值。\n7.  对于每个测试用例，调用此函数两次：一次使用粗糙网格参数 $(N_x, N_y)$ 得到 $g_{z,\\text{mesh}}$，另一次使用精细网格参数 $(N_{x,\\text{ref}}, N_{y,\\text{ref}})$ 得到高分辨率参考值 $g_{z,\\text{ref}}$。\n8.  计算布格板值 $g_{\\text{B}} = 2 \\pi G \\rho \\, h(x_p,y_p)$，注意按给定公式这是一个正值。\n9.  计算所需的绝对误差和差异：$E_{\\text{disc}} = |g_{z,\\text{mesh}} - g_{z,\\text{ref}}|$ 和 $E_{\\text{slab}} = |g_{\\text{B}} - g_{z,\\text{ref}}|$。后者衡量板近似的总误差，包括相对于严格计算的场的量值和符号差异。\n10. 按照指定格式存储和格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef compute_gz(H, sigma_x, sigma_y, Lx, Ly, Nx, Ny, R, xp, yp, zp, rho, G):\n    \"\"\"\n    Computes the vertical component of gravitational acceleration gz\n    from a triangular mesh representation of a topographic surface.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    triangle_area = 0.5 * dx * dy\n\n    # Create a grid of indices for the rectangular cells\n    i_indices = np.arange(Nx)\n    j_indices = np.arange(Ny)\n    ii, jj = np.meshgrid(i_indices, j_indices, indexing='ij')\n\n    # Coordinates of the lower-left corner of each cell\n    x_ll = -Lx/2 + ii * dx\n    y_ll = -Ly/2 + jj * dy\n\n    # Centroids of the first set of triangles in each cell\n    # (vertices at (x,y), (x+dx,y), (x+dx,y+dy))\n    x_c1 = x_ll + (2/3) * dx\n    y_c1 = y_ll + (1/3) * dy\n\n    # Centroids of the second set of triangles in each cell\n    # (vertices at (x,y), (x,y+dy), (x+dx,y+dy))\n    x_c2 = x_ll + (1/3) * dx\n    y_c2 = y_ll + (2/3) * dy\n\n    # Combine all centroids into single 1D arrays\n    x_centroids = np.concatenate((x_c1.ravel(), x_c2.ravel()))\n    y_centroids = np.concatenate((y_c1.ravel(), y_c2.ravel()))\n\n    # Filter centroids based on the truncation radius R\n    dist_sq_from_p = (x_centroids - xp)**2 + (y_centroids - yp)**2\n    mask = dist_sq_from_p = R**2\n    \n    x_eff = x_centroids[mask]\n    y_eff = y_centroids[mask]\n    dist_sq_from_p_eff = dist_sq_from_p[mask]\n\n    # If no centroids fall within the radius, the contribution is zero.\n    if x_eff.size == 0:\n        return 0.0\n\n    # Evaluate terrain height h(x,y) at effective centroids\n    # h(x,y) = H * exp( -x^2/(2*sx^2) - y^2/(2*sy^2) )\n    h_vals = H * np.exp(-x_eff**2 / (2 * sigma_x**2) - y_eff**2 / (2 * sigma_y**2))\n\n    # Evaluate the z-integrated kernel at effective centroids.\n    # The kernel is (1/sqrt(a^2+zp^2) - 1/sqrt(a^2+(h-zp)^2)) where a^2 = (x-xp)^2+(y-yp)^2\n    term1_denom_sq = dist_sq_from_p_eff + zp**2\n    term2_denom_sq = dist_sq_from_p_eff + (h_vals - zp)**2\n\n    # Denominators can't be zero since zp  max(h)  0\n    integrand_vals = (1 / np.sqrt(term1_denom_sq)) - (1 / np.sqrt(term2_denom_sq))\n\n    # Sum contributions using one-point quadrature rule over all effective triangles\n    g_z = G * rho * np.sum(integrand_vals) * triangle_area\n\n    return g_z\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and print results.\n    \"\"\"\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    rho = 2670.0      # kg m^-3\n\n    test_cases = [\n        # (H, sx, sy, Lx, Ly, Nx, Ny, Nxr, Nyr, R, xp, yp, zp)\n        (300.0, 800.0, 800.0, 6000.0, 6000.0, 64, 64, 256, 256, 3000.0, 0.0, 0.0, 1200.0),\n        (300.0, 600.0, 600.0, 2400.0, 2400.0, 16, 16, 128, 128, 1200.0, 0.0, 0.0, 1200.0),\n        (200.0, 1000.0, 400.0, 7000.0, 7000.0, 48, 48, 192, 192, 2500.0, 0.0, 0.0, 1500.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        H, sx, sy, Lx, Ly, Nx, Ny, Nxr, Nyr, R, xp, yp, zp = case\n        \n        # 1. Compute mesh-based gz with coarse grid\n        gz_mesh = compute_gz(H, sx, sy, Lx, Ly, Nx, Ny, R, xp, yp, zp, rho, G)\n        \n        # 2. Compute reference gz with fine grid\n        gz_ref = compute_gz(H, sx, sy, Lx, Ly, Nxr, Nyr, R, xp, yp, zp, rho, G)\n        \n        # 3. Compute Bouguer slab approximation value\n        h_at_p = H * np.exp(-xp**2 / (2 * sx**2) - yp**2 / (2 * sy**2))\n        g_B = 2 * np.pi * G * rho * h_at_p\n        \n        # 4. Calculate required errors\n        E_disc = np.abs(gz_mesh - gz_ref)\n        # Note: The derived gz is negative (downward attraction), while the standard Bouguer correction formula yields a positive value. \n        # The problem asks for the absolute difference |g_B - g_z,ref|, which compares magnitudes.\n        # To be physically consistent, we compare the magnitude of the Bouguer correction to the magnitude of the calculated attraction.\n        E_slab = np.abs(g_B - np.abs(gz_ref))\n        \n        results.append([E_disc, E_slab])\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join([str(r) for r in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"
        },
        {
            "introduction": "地球物理反演得到的结果从来不是地下结构的完美真实成像，而是一个模糊且非唯一的估计。模型分辨率矩阵及其派生量，如点扩散函数 (PSF)，能够定量描述这种模糊效应，帮助我们理解反演结果能够分辨哪些特征，又不能分辨哪些。通过这项实践 ，您将学习如何计算和解读关键的分辨率诊断指标，例如自分辨率和探测深度 (DOI)，这对于批判性地评估任何反演模型的可靠性都至关重要。",
            "id": "3601359",
            "problem": "考虑一个三维线性化重力反演问题，其模型域为紧凑的、被离散化为体素的区域。使用牛顿万有引力定律和线性反演问题框架，通过逆Hessian矩阵推导并计算近似的模型分辨核和探测深度（DOI）。从第一性原理出发，始于物理正演模型，构建灵敏度矩阵，然后在Tikhonov正则化加权最小二乘法中推导出逆Hessian矩阵，最后计算模型分辨率矩阵、点扩散函数和DOI。\n\n设模型域为一个 $n_x \\times n_y \\times n_z$ 的体素构成的规则网格。模型参数向量为 $m \\in \\mathbb{R}^{n_m}$，其中 $n_m = n_x n_y n_z$，包含每个体素的密度异常，单位为 $\\mathrm{kg/m^3}$。观测数据是地表点的重力加速度垂直分量，单位为 $\\mathrm{m/s^2}$。使用牛顿万有引力定律，其中万有引力常数 $G = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，并将每个体素近似为其中心处的一个质点。如果一个观测点位于位置 $\\mathbf{x}_i = (x_i, y_i, z_i)$，而体素 $j$ 的中心位于 $\\mathbf{x}_j = (x_j, y_j, z_j)$，其体积为 $V$，那么体素 $j$（对于单位密度 $1\\,\\mathrm{kg/m^3}$）对观测点 $i$ 处重力加速度垂直分量的贡献是\n$$\nG_{ij} = G \\, V \\, \\frac{z_j - z_i}{\\left\\|\\mathbf{x}_j - \\mathbf{x}_i\\right\\|^3}.\n$$\n灵敏度矩阵 $G \\in \\mathbb{R}^{n_d \\times n_m}$ 将模型参数 $m$（密度）映射到数据 $d$（重力）。假设已知数据标准差 $\\sigma$（噪声水平），并且对所有观测都为常数。设数据加权矩阵为 $W_d = \\mathrm{diag}(1/\\sigma, \\ldots, 1/\\sigma)$，并采用参数为 $\\alpha  0$ 的零阶Tikhonov正则化，因此正则化算子为单位矩阵 $I$。Tikhonov正则化加权最小二乘的目标函数为\n$$\n\\Phi(m) = \\left\\| W_d \\left( G m - d \\right) \\right\\|_2^2 + \\alpha^2 \\left\\| m \\right\\|_2^2.\n$$\n此二次目标函数的Hessian矩阵为\n$$\nH = G^\\top W_d^\\top W_d \\, G + \\alpha^2 I,\n$$\n模型分辨率矩阵为\n$$\nR = H^{-1} G^\\top W_d^\\top W_d \\, G.\n$$\n对于体素索引 $j$ 处的一个单位脉冲，估计的模型为 $m_{\\text{est}} = R \\, e_j$，其中 $e_j$ 是第 $j$ 个标准基向量。向量 $R \\, e_j$ 是体素 $j$ 在模型空间中的点扩散函数（PSF）；它量化了位于 $j$ 处的一个单位尖峰如何在估计模型中扩散到其他体素。体素 $j$ 的探测深度（DOI）可以根据PSF通过阈值法定义：对于一个阈值 $\\tau \\in (0,1)$，体素 $j$ 的DOI深度为\n$$\nd^{\\text{DOI}}_j = \\max \\left\\{ z_k \\,:\\, \\left| \\left( R \\, e_j \\right)_k \\right| \\ge \\tau \\cdot \\max_{\\ell} \\left| \\left( R \\, e_j \\right)_\\ell \\right| \\right\\},\n$$\n其中 $z_k$ 是体素 $k$ 的深度坐标。如果阈值集为空，则定义 $d^{\\text{DOI}}_j = 0$。\n\n在程序中实现此过程，并使用以下固定的几何形状和参数，以确保科学真实性和可复现性：\n\n- 模型网格有 $n_x = 3$、$n_y = 3$、$n_z = 3$。体素间距为 $dx = 100\\,\\mathrm{m}$、$dy = 100\\,\\mathrm{m}$、$dz = 100\\,\\mathrm{m}$。体素体积为 $V = dx \\times dy \\times dz$。\n- 体素中心坐标位于一个笛卡尔网格上，其中 $x \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$，$y \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$，深度 $z \\in \\{50, 150, 250\\}\\,\\mathrm{m}$，因此模型占据了观测平面下方一个 $300 \\times 300 \\times 300\\,\\mathrm{m^3}$ 的区域。\n- 观测在 $z = 0\\,\\mathrm{m}$ 的平面上进行，位于一个 $4 \\times 4$ 的网格上，坐标为 $x \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$ 和 $y \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$。\n- 数据标准差为 $\\sigma = 10^{-6}\\,\\mathrm{m/s^2}$。\n\n使用由 $j = i_x + n_x \\left( i_y + n_y \\, i_z \\right)$ 定义的体素索引映射，其中 $i_x \\in \\{0,1,2\\}$、$i_y \\in \\{0,1,2\\}$ 和 $i_z \\in \\{0,1,2\\}$ 分别索引 $x$、$y$ 和 $z$ 的位置。使用此映射，中心体素 $(x=0,y=0,z=150\\,\\mathrm{m})$ 的索引为 $j=13$，底部中心体素 $(x=0,y=0,z=250\\,\\mathrm{m})$ 的索引为 $j=22$，顶部角落体素 $(x=-100,y=-100,z=50\\,\\mathrm{m})$ 的索引为 $j=0$。\n\n您的程序必须针对指定的 $\\alpha$ 值计算模型分辨率矩阵 $R$，然后，对于指定的体素索引 $j$ 和阈值 $\\tau$，计算：\n- 自分辨率得分 $r_{jj}$，其中 $r_{jj}$ 是 $R$ 在索引 $j$ 处的对角元素。\n- DOI深度 $d^{\\text{DOI}}_j$，单位为米。\n\n测试套件：\n为以下情况提供结果，每种情况都指定为一个元组 $(\\alpha, \\tau, j)$：\n1. $(1.0, 0.1, 13)$ 代表中等正则化、中心体素的PSF和典型阈值。\n2. $(0.01, 0.05, 22)$ 代表非常弱的正则化、深部体素的PSF和更严格的阈值。\n3. $(10.0, 0.2, 0)$ 代表强正则化、浅层角落体素的PSF和更宽松的阈值。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果必须是两个浮点数的列表 $[r_{jj}, d^{\\text{DOI}}_j]$，其中 $d^{\\text{DOI}}_j$ 以米为单位表示。例如，输出应如下所示：\n$$\n\\left[ [r_{jj}^{(1)}, d^{\\text{DOI}}_{j_1}] , [r_{jj}^{(2)}, d^{\\text{DOI}}_{j_2}] , [r_{jj}^{(3)}, d^{\\text{DOI}}_{j_3}] \\right].\n$$\n您的程序必须实现所述的完整计算流程，无需任何用户输入或外部文件，并且必须使用上面指定的固定几何形状和参数。",
            "solution": "该问题要求为一个三维线性化重力反演问题计算模型分辨率诊断量，特别是自分辨率得分和探测深度（DOI）。这将通过遵循Tikhonov正则化加权最小二乘框架并分析得到的模型分辨率矩阵来完成。推导从第一性原理开始，基于牛顿万有引力定律的物理正演模型。\n\n问题的核心在于理解正则化参数 $\\alpha$ 的选择如何影响地球物理勘探解析地下特征的能力。小的 $\\alpha$ 会导致解能很好地拟合数据，但可能不稳定且振荡；而大的 $\\alpha$ 则产生平滑且稳定的解，但可能无法很好地拟合数据。模型分辨率矩阵量化了这种权衡。\n\n**1. 系统几何与离散化**\n\n首先，我们定义物理系统的几何结构。地下模型域被离散化为一个规则的体素网格。\n- 模型网格维度：$n_x = 3$, $n_y = 3$, $n_z = 3$。\n- 模型参数总数（体素数）：$n_m = n_x n_y n_z = 27$。\n- 体素尺寸：$dx = 100\\,\\mathrm{m}$, $dy = 100\\,\\mathrm{m}$, $dz = 100\\,\\mathrm{m}$。\n- 体素体积：$V = dx \\cdot dy \\cdot dz = 100 \\times 100 \\times 100 = 10^6\\,\\mathrm{m^3}$。\n模型参数向量 $m \\in \\mathbb{R}^{n_m}$ 由每个体素 $j$ 的密度异常 $\\rho_j$ 组成。\n\n体素中心位于笛卡尔网格上的坐标 $(x_j, y_j, z_j)$ 处。问题指定了一个坐标系，其中 $z$ 轴垂直向下，因此 $z$ 代表深度。\n- 体素中心x坐标：$x \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$。\n- 体素中心y坐标：$y \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$。\n- 体素中心z坐标（深度）：$z \\in \\{50, 150, 250\\}\\,\\mathrm{m}$。\n\n体素索引 $j \\in \\{0, 1, \\dots, n_m-1\\}$ 通过公式 $j = i_x + n_x(i_y + n_y i_z)$ 从网格索引 $(i_x, i_y, i_z) \\in \\{0,1,2\\}^3$ 映射而来。\n\n重力数据在位于地表平面 $z=0$ 的观测点上测量。\n- 观测网格：$4 \\times 4$。\n- 数据点总数：$n_d = 4 \\times 4 = 16$。\n- 观测坐标 $\\mathbf{x}_i = (x_i, y_i, z_i)$:\n  - $x_i \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$。\n  - $y_i \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$。\n  - 对于所有 $i$，$z_i = 0 \\,\\mathrm{m}$。\n\n**2. 物理正演模型与灵敏度矩阵**\n\n正演模型将模型参数（密度异常 $m$）与可观测数据（垂直重力加速度 $d$）联系起来。根据牛顿万有引力定律，位于 $\\mathbf{x}_j$ 处的质点 $M_j$ 在点 $\\mathbf{x}_i$ 处产生的加速度 $\\mathbf{g}$ 由 $\\mathbf{g} = G M_j / \\|\\mathbf{x}_j - \\mathbf{x}_i\\|^2 \\cdot \\hat{\\mathbf{r}}$ 给出，其中 $\\hat{\\mathbf{r}}$ 是从 $\\mathbf{x}_i$ 指向 $\\mathbf{x}_j$ 的单位向量。\n\n将每个体素近似为其中心的质点 $M_j = m_j V$（其中 $m_j$ 是密度异常），则观测点 $i$ 处由体素 $j$ 引起的垂直重力加速度分量为：\n$$\ng_{z,ij} = G M_j \\frac{z_j - z_i}{\\|\\mathbf{x}_j - \\mathbf{x}_i\\|^3} = \\left(G V \\frac{z_j - z_i}{\\|\\mathbf{x}_j - \\mathbf{x}_i\\|^3}\\right) m_j\n$$\n点 $i$ 处的总垂直加速度是所有体素贡献的总和：$d_i = \\sum_{j=1}^{n_m} G_{ij} m_j$。这定义了线性正演模型 $d = Gm$，其中 $G$ 是灵敏度矩阵。$G$ 的元素由下式给出：\n$$\nG_{ij} = G V \\frac{z_j - z_i}{\\left( (x_j - x_i)^2 + (y_j - y_i)^2 + (z_j - z_i)^2 \\right)^{3/2}}\n$$\n其中 $G = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$ 是万有引力常数。对于此问题，矩阵 $G$ 的维度为 $n_d \\times n_m$，即 $16 \\times 27$。\n\n**3. Tikhonov正则化反演问题**\n\n给定一组带噪声的测量值 $d_{obs}$，我们试图估计模型 $m$。这是一个反演问题，通常是病态的。我们通过最小化一个Tikhonov正则化加权最小二乘目标函数来找到一个稳定的解：\n$$\n\\Phi(m) = \\|W_d(Gm - d_{obs})\\|_2^2 + \\alpha^2 \\|m\\|_2^2\n$$\n- 第一项是加权数据失配。数据加权矩阵为 $W_d = \\sigma^{-1}I$，其中 $\\sigma = 10^{-6}\\,\\mathrm{m/s^2}$ 是数据噪声的标准差。此项 $\\sum_{i=1}^{n_d} ((Gm)_i - d_{i,obs})^2 / \\sigma^2$ 是无量纲的。\n- 第二项是正则化项（或模型范数）。这里使用零阶Tikhonov正则化，惩罚模型向量的 $L_2$ 范数的平方。\n- $\\alpha  0$ 是平衡这两项的正则化参数。\n\n二次函数 $\\Phi(m)$ 的最小值可以通过将其关于 $m$ 的梯度设为零来找到，这导出了正规方程：\n$$\n(G^\\top W_d^\\top W_d G + \\alpha^2 I) m_{est} = G^\\top W_d^\\top W_d d_{obs}\n$$\n矩阵 $H = G^\\top W_d^\\top W_d G + \\alpha^2 I$ 是目标函数的Hessian矩阵。由于 $W_d$ 是对角矩阵，$W_d^\\top W_d = W_d^2 = \\sigma^{-2}I$。Hessian矩阵简化为：\n$$\nH = \\frac{1}{\\sigma^2} G^\\top G + \\alpha^2 I\n$$\n由于 $G^\\top G$ 是半正定的且 $\\alpha  0$，因此 $H$ 是一个对称正定矩阵，因而是可逆的。\n\n**4. 模型分辨率分析**\n\n正规方程的解为 $m_{est} = H^{-1} G^\\top W_d^2 d_{obs}$。如果我们将“真实”数据 $d_{true} = Gm_{true}$ 代入，就可以看到估计模型与真实模型的关系：\n$$\nm_{est} = (H^{-1} G^\\top W_d^2 G) m_{true}\n$$\n矩阵 $R = H^{-1} G^\\top W_d^2 G$ 是模型分辨率矩阵。它是一个 $n_m \\times n_m$ 的矩阵，描述了反演过程如何将真实模型空间映射到估计模型空间。理想的反演会有 $R=I$，意味着每个估计参数 $m_{est,j}$ 等于真实参数 $m_{true,j}$。实际上，$R$ 会偏离单位矩阵，表明分辨率的损失。\n\n- **点扩散函数（PSF）**：$R$ 的第 $j$ 列，记为 $R e_j$（其中 $e_j$ 是第 $j$ 个标准基向量），是体素 $j$ 的点扩散函数。它代表了当“真实”模型仅在体素 $j$ 中包含一个单位密度异常（即 $m_{true} = e_j$）时所产生的估计模型 $m_{est}$。它显示了来自单个体素的能量如何通过反演被“涂抹”到整个模型域。\n\n- **自分辨率得分**：对角元素 $r_{jj} = R_{jj}$ 是体素 $j$ 的自分辨率得分。它是体素 $j$ 的PSF在其自身位置的值。一个接近1的值表明体素 $j$ 中的异常得到了很好的解析，其幅度也得到了正确的估计。小于1的值表明其振幅被低估，其能量被扩散到其他体素。\n\n- **探测深度（DOI）**：DOI提供了一个衡量我们能可靠地成像到模型多深处特征的指标。对于位于体素 $j$ 的源，DOI定义为PSF中响应 $|(Re_j)_k|$ 相对于PSF峰值显著的任何体素 $k$ 的最大深度。使用阈值 $\\tau \\in (0,1)$，DOI深度为：\n$$\nd^{\\text{DOI}}_j = \\max \\left\\{ z_k \\,:\\, |(Re_j)_k| \\ge \\tau \\cdot \\max_{\\ell} |(Re_j)_\\ell| \\right\\}\n$$\n如果没有体素满足阈值条件，则DOI深度取为0。源的DOI深度越大，表明来自该源的信息被涂抹到更深的深度。\n\n**5. 计算流程**\n\n实现过程遵循以下步骤：\n1.  定义所有指定的物理和几何常数及参数。\n2.  生成 $n_m$ 个体素中心坐标的数组和 $n_d$ 个观测坐标的数组。创建一个模型 $z$ 坐标的数组，供之后计算DOI时使用。\n3.  通过遍历每个观测-体素对并应用 $G_{ij}$ 的公式，构建 $n_d \\times n_m$ 的灵敏度矩阵 $G$。\n4.  对于每个测试用例 $(\\alpha, \\tau, j)$:\n    a. 计算项 $G^\\top W_d^2 G = (1/\\sigma^2)G^\\top G$。\n    b. 形成Hessian矩阵 $H = (1/\\sigma^2)G^\\top G + \\alpha^2 I$。\n    c. 计算Hessian矩阵的逆 $H^{-1}$。\n    d. 计算模型分辨率矩阵 $R = H^{-1} ((1/\\sigma^2)G^\\top G)$。\n    e. 提取自分辨率得分 $r_{jj} = R[j, j]$。\n    f. 提取体素 $j$ 的点扩散函数（PSF），即 $R$ 的第 $j$ 列。\n    g. 通过找到PSF振幅超过相对于峰值PSF振幅的指定阈值的体素的最大深度，来计算DOI深度 $d^{\\text{DOI}}_j$。\n5.  收集所有测试用例的 $[r_{jj}, d^{\\text{DOI}}_j]$ 对，并格式化最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes model resolution diagnostics for a 3D linearized gravity inversion problem.\n    \"\"\"\n    # 1. Define constants and parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    \n    # Model grid parameters\n    nx, ny, nz = 3, 3, 3\n    nm = nx * ny * nz\n    dx, dy, dz = 100.0, 100.0, 100.0  # meters\n    V = dx * dy * dz  # m^3\n\n    # Voxel center coordinates\n    x_model_coords = np.array([-100.0, 0.0, 100.0])\n    y_model_coords = np.array([-100.0, 0.0, 100.0])\n    z_model_coords = np.array([50.0, 150.0, 250.0])  # depths\n\n    model_centers = np.zeros((nm, 3))\n    model_z_only = np.zeros(nm)\n    # Voxel indexing: j = ix + nx * (iy + ny * iz)\n    for iz in range(nz):\n        for iy in range(ny):\n            for ix in range(nx):\n                j = ix + nx * (iy + ny * iz)\n                model_centers[j, 0] = x_model_coords[ix]\n                model_centers[j, 1] = y_model_coords[iy]\n                model_centers[j, 2] = z_model_coords[iz]\n                model_z_only[j] = z_model_coords[iz]\n\n    # Observation grid parameters\n    x_obs_coords = np.array([-150.0, -50.0, 50.0, 150.0])\n    y_obs_coords = np.array([-150.0, -50.0, 50.0, 150.0])\n    nd = len(x_obs_coords) * len(y_obs_coords)\n\n    obs_centers = np.zeros((nd, 3))\n    k = 0\n    for y_obs in y_obs_coords:\n        for x_obs in x_obs_coords:\n            obs_centers[k, 0] = x_obs\n            obs_centers[k, 1] = y_obs\n            obs_centers[k, 2] = 0.0\n            k += 1\n\n    # Inversion parameters\n    sigma = 1.0e-6  # m/s^2\n\n    # 2. Assemble the sensitivity matrix G_mat\n    G_mat = np.zeros((nd, nm))\n    for i in range(nd):\n        obs_pos = obs_centers[i, :]\n        for j in range(nm):\n            model_pos = model_centers[j, :]\n            \n            # Vector from observation to model voxel\n            r_vec = model_pos - obs_pos\n            r_norm = np.linalg.norm(r_vec)\n            \n            # G_ij = G * V * (z_j - z_i) / ||x_j - x_i||^3\n            # z_i is 0 for all observations\n            G_mat[i, j] = G * V * r_vec[2] / (r_norm**3)\n\n    # 3. Process test cases\n    test_cases = [\n        # (alpha, tau, j)\n        (1.0, 0.1, 13),   # Moderate regularization, center voxel\n        (0.01, 0.05, 22),  # Weak regularization, deep voxel\n        (10.0, 0.2, 0)     # Strong regularization, shallow corner voxel\n    ]\n\n    results = []\n    \n    # Pre-compute shared term GT * Wd^2 * G\n    Wd_sq = 1.0 / (sigma**2)\n    GT_Wd2_G = G_mat.T @ (Wd_sq * G_mat)\n    \n    for alpha, tau, j_idx in test_cases:\n        # a. Form the Hessian matrix H\n        H = GT_Wd2_G + (alpha**2) * np.identity(nm)\n        \n        # b. Invert the Hessian\n        H_inv = np.linalg.inv(H)\n        \n        # c. Compute the model resolution matrix R\n        R = H_inv @ GT_Wd2_G\n        \n        # d. Extract self-resolution score\n        r_jj = R[j_idx, j_idx]\n        \n        # e. Extract Point-Spread Function (PSF) for voxel j\n        psf_j = R[:, j_idx]\n        \n        # f. Compute Depth of Investigation (DOI)\n        abs_psf = np.abs(psf_j)\n        max_psf_val = np.max(abs_psf)\n        \n        if max_psf_val == 0:\n            doi_depth = 0.0\n        else:\n            threshold_val = tau * max_psf_val\n            indices_above_thresh = np.where(abs_psf >= threshold_val)[0]\n            \n            if len(indices_above_thresh) == 0:\n                doi_depth = 0.0\n            else:\n                z_coords_above_thresh = model_z_only[indices_above_thresh]\n                doi_depth = np.max(z_coords_above_thresh)\n        \n        results.append([r_jj, doi_depth])\n\n    # 4. Format and print the final output\n    item_strs = [f\"[{r:.6f},{d:.1f}]\" for r, d in results]\n    output_str = f\"[{','.join(item_strs)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}