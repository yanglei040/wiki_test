{
    "hands_on_practices": [
        {
            "introduction": "The Jacobian, or sensitivity matrix, forms the core of any gradient-based geophysical inversion. An error in its implementation can doom an inversion to failure, making its validation a critical first step. This practice will guide you through the indispensable skill of verifying an analytically derived Jacobian against a numerical finite-difference approximation, a technique known as a 'Jacobian check' that ensures your inversion code is built on a solid foundation .",
            "id": "3601437",
            "problem": "You are asked to design and validate an analytical Jacobian matrix for a gravity forward operator used in computational geophysics. The physical setting is a set of point-mass sources in three-dimensional space producing the vertical component of gravitational acceleration at surface observation points. Your goal is to start from first principles, derive the forward mapping and its Jacobian, implement both the analytical Jacobian and a Finite Difference (FD) approximation, and verify their agreement on a synthetic model. Then, apply a quantitative criterion based on the normalized Frobenius norm to decide if the analytical Jacobian is correct.\n\nFundamental base:\n- Newton’s law of universal gravitation: two point masses attract each other with force magnitude proportional to the product of the masses and inversely proportional to the square of the distance between them.\n- Linear superposition: the total field at an observation point due to multiple sources is the sum of the contributions from each source.\n- The gravitational constant is given as $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$.\n- The model parameters are the point-source masses, measured in kilograms.\n- Observation coordinates and source coordinates are given in meters; the vertical axis is $z$, with observations at $z=0$ and sources at $z<0$. The vertical component of gravitational acceleration must be expressed in $\\mathrm{m/s^2}$.\n\nTasks:\n1. Starting from the above fundamental base and using purely mathematical derivations, derive the forward mapping from a vector of masses to the vertical component of gravitational acceleration at a set of observation points, and from that derive the analytical Jacobian matrix with respect to the masses.\n2. Implement a program that:\n   - Computes the forward response at the observations for a given set of masses.\n   - Computes the analytical Jacobian with respect to the masses.\n   - Computes a Finite Difference (FD) Jacobian using a forward-difference scheme with a specified perturbation size $\\epsilon$ (in $\\mathrm{kg}$).\n   - Compares the analytical Jacobian to the FD Jacobian using the normalized Frobenius norm criterion\n     $$\\frac{\\left\\| J_{\\text{analytic}} - J_{\\text{FD}} \\right\\|_{F}}{\\left\\| J_{\\text{FD}} \\right\\|_{F}} < 10^{-3}.$$\n   - Returns a boolean for each test case indicating whether the criterion is satisfied.\n3. Ensure scientific realism: do not place any observation point exactly at a source location. All distances should be positive and finite. Use the given physical constant $G$ and SI units throughout.\n4. Angles do not appear in this problem, so no angle unit is needed. The outputs for each test case are booleans, so no physical unit is required for the final outputs.\n\nTest suite (provide the exact parameter values below and use them verbatim in your program):\n- Case $1$ (general configuration, moderate offsets):\n  - Observations $\\left(N_{\\text{obs}} = 5\\right)$ at $\\left(z=0\\right)$: \n    $\\left[(-100,0,0),(-50,0,0),(0,0,0),(50,0,0),(100,0,0)\\right] \\ \\mathrm{m}$.\n  - Sources $\\left(N_{\\text{src}} = 4\\right)$ at $\\left(z=-50\\right)$:\n    $\\left[(-75,0,-50),(-25,0,-50),(25,0,-50),(75,0,-50)\\right] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = \\left[2 \\times 10^{8}, 1.5 \\times 10^{8}, 1.0 \\times 10^{8}, 0.5 \\times 10^{8}\\right] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{6} \\ \\mathrm{kg}$.\n- Case $2$ (near-field sensitivity, small separation):\n  - Observations $\\left(N_{\\text{obs}} = 3\\right)$ at $\\left(z=0\\right)$:\n    $\\left[(-10,0,0),(0,0,0),(10,0,0)\\right] \\ \\mathrm{m}$.\n  - Sources $\\left(N_{\\text{src}} = 2\\right)$ at $\\left(z=-10\\right)$:\n    $\\left[(0,0,-10),(20,0,-10)\\right] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = \\left[1.0 \\times 10^{7}, 2.0 \\times 10^{7}\\right] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{3} \\ \\mathrm{kg}$.\n- Case $3$ (far-field regime, large offsets and depths):\n  - Observations $\\left(N_{\\text{obs}} = 3\\right)$ at $\\left(z=0\\right)$:\n    $\\left[(-1000,0,0),(0,0,0),(1000,0,0)\\right] \\ \\mathrm{m}$.\n  - Sources $\\left(N_{\\text{src}} = 3\\right)$ at $\\left(z=-500\\right)$:\n    $\\left[(-500,0,-500),(0,0,-500),(500,0,-500)\\right] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = \\left[5.0 \\times 10^{10}, 3.0 \\times 10^{10}, 4.0 \\times 10^{10}\\right] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{12} \\ \\mathrm{kg}$.\n\nNumerical requirements:\n- Use double precision floating point arithmetic.\n- For the FD approximation, use a forward-difference scheme: for the $i$-th parameter, perturb by $+\\epsilon$ and compute the column as $\\left(\\mathbf{d}(\\mathbf{m}+\\epsilon \\mathbf{e}_i) - \\mathbf{d}(\\mathbf{m})\\right)/\\epsilon$ where $\\mathbf{e}_i$ is the $i$-th canonical basis vector.\n- Use the Frobenius norm for matrices.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3}\\right]$, where each $\\text{result}_{k}$ is a boolean corresponding to whether the criterion is satisfied for case $k$. The outputs must be in the order of the cases given above.",
            "solution": "## Problem Validation ##\n\n### Step 1: Extract Givens ###\nThe problem provides the following information:\n\n**Fundamental Principles and Constants:**\n- **Newton's Law of Universal Gravitation**: Force magnitude is $F \\propto \\frac{m_1 m_2}{r^2}$.\n- **Linear Superposition**: The total field is the sum of individual fields.\n- **Gravitational Constant**: $G = 6.67430 \\times 10^{-11} \\ \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$.\n\n**Model and Data Definitions:**\n- **Model Parameters**: A vector of point-source masses $\\mathbf{m}$ in kilograms ($\\mathrm{kg}$).\n- **Sources**: Located at coordinates $(x', y', z')$ with $z' < 0$. Coordinates are in meters ($\\mathrm{m}$).\n- **Observations**: Located at coordinates $(x, y, z)$ with $z = 0$. The data are the vertical component of gravitational acceleration, $g_z$, in $\\mathrm{m/s^2}$.\n- **Jacobian Verification Criterion**: $\\frac{\\left\\| J_{\\text{analytic}} - J_{\\text{FD}} \\right\\|_{F}}{\\left\\| J_{\\text{FD}} \\right\\|_{F}} < 10^{-3}$.\n- **Finite Difference (FD) Scheme**: Forward-difference with perturbation $\\epsilon$ in $\\mathrm{kg}$. The $i$-th column is $(\\mathbf{d}(\\mathbf{m}+\\epsilon \\mathbf{e}_i) - \\mathbf{d}(\\mathbf{m}))/\\epsilon$.\n\n**Test Cases:**\n- **Case 1**:\n  - Observations ($N_{\\text{obs}} = 5$ at $z=0$): $[(-100,0,0),(-50,0,0),(0,0,0),(50,0,0),(100,0,0)] \\ \\mathrm{m}$.\n  - Sources ($N_{\\text{src}} = 4$ at $z=-50$): $[(-75,0,-50),(-25,0,-50),(25,0,-50),(75,0,-50)] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = [2 \\times 10^{8}, 1.5 \\times 10^{8}, 1.0 \\times 10^{8}, 0.5 \\times 10^{8}] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{6} \\ \\mathrm{kg}$.\n- **Case 2**:\n  - Observations ($N_{\\text{obs}} = 3$ at $z=0$): $[(-10,0,0),(0,0,0),(10,0,0)] \\ \\mathrm{m}$.\n  - Sources ($N_{\\text{src}} = 2$ at $z=-10$): $[(0,0,-10),(20,0,-10)] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = [1.0 \\times 10^{7}, 2.0 \\times 10^{7}] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{3} \\ \\mathrm{kg}$.\n- **Case 3**:\n  - Observations ($N_{\\text{obs}} = 3$ at $z=0$): $[(-1000,0,0),(0,0,0),(1000,0,0)] \\ \\mathrm{m}$.\n  - Sources ($N_{\\text{src}} = 3$ at $z=-500$): $[(-500,0,-500),(0,0,-500),(500,0,-500)] \\ \\mathrm{m}$.\n  - Mass vector $\\mathbf{m} = [5.0 \\times 10^{10}, 3.0 \\times 10^{10}, 4.0 \\times 10^{10}] \\ \\mathrm{kg}$.\n  - Finite difference step $\\epsilon = 10^{12} \\ \\mathrm{kg}$.\n\n### Step 2: Validate Using Extracted Givens ###\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is built upon Newton's law of gravitation, a cornerstone of classical physics. The model of point masses is a standard and valid simplification used in introductory potential field geophysics. All physical quantities are given with appropriate SI units, and the value for $G$ is correct.\n- **Well-Posed**: The problem is clearly defined. It requests the derivation of a forward model and its Jacobian, followed by a numerical verification. The forward model is a linear transformation from mass to gravitational acceleration, for which a unique solution exists as long as observation and source points do not coincide. The problem statement ensures this by placing sources at $z < 0$ and observations at $z=0$. The verification criterion is quantitative and unambiguous.\n- **Objective**: The problem is stated using precise, mathematical language, with all parameters and conditions explicitly defined. It is free of ambiguity and subjective claims.\n- **Completeness and Consistency**: All necessary data (coordinates, masses, constants, perturbation size) are provided for each test case. The constraints are consistent and do not lead to contradictions. For instance, the specified coordinates ensure that the distance between any source and observation point is always greater than zero.\n- **Realism**: While a point-mass model is a simplification of real geological bodies, it is a scientifically realistic and common starting point in geophysical modeling. The magnitudes of masses and distances are within plausible ranges for geophysical surveys.\n\nThe problem does not exhibit any of the listed flaws (e.g., scientific unsoundness, missing data, ambiguity).\n\n### Step 3: Verdict and Action ###\nThe problem is **valid**. A step-by-step solution will be provided.\n\n## Solution ##\n\n### Part 1: Derivation of the Forward Map and Analytical Jacobian ###\n\n**1.1. Gravitational Field of a Single Point Mass**\n\nAccording to Newton's law of universal gravitation, the gravitational force $\\mathbf{F}$ exerted by a source mass $m_j$ at position $\\mathbf{r}'_j$ on a test mass $m_{\\text{test}}$ at position $\\mathbf{r}_i$ is given by:\n$$ \\mathbf{F}_{ij} = -G \\frac{m_{\\text{test}} m_j}{\\|\\mathbf{r}_i - \\mathbf{r}'_j\\|^2} \\frac{\\mathbf{r}_i - \\mathbf{r}'_j}{\\|\\mathbf{r}_i - \\mathbf{r}'_j\\|} = -G \\frac{m_{\\text{test}} m_j}{\\|\\Delta\\mathbf{r}_{ij}\\|^3} \\Delta\\mathbf{r}_{ij} $$\nwhere $G$ is the gravitational constant and $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}'_j$ is the vector from the source to the observation point. The negative sign indicates that the force is attractive (points from observer towards the source).\n\nThe gravitational acceleration $\\mathbf{g}_{ij}$ at $\\mathbf{r}_i$ due to $m_j$ is the force per unit test mass:\n$$ \\mathbf{g}_{ij} = \\frac{\\mathbf{F}_{ij}}{m_{\\text{test}}} = -G \\frac{m_j}{\\|\\Delta\\mathbf{r}_{ij}\\|^3} \\Delta\\mathbf{r}_{ij} $$\nLet the coordinates be $\\mathbf{r}_i = (x_i, y_i, z_i)$ and $\\mathbf{r}'_j = (x'_j, y'_j, z'_j)$. The squared distance is $r_{ij}^2 = \\|\\Delta\\mathbf{r}_{ij}\\|^2 = (x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2$. The acceleration vector is:\n$$ \\mathbf{g}_{ij} = -G \\frac{m_j}{(r_{ij}^2)^{3/2}} \\left( (x_i - x'_j)\\hat{\\mathbf{x}} + (y_i - y'_j)\\hat{\\mathbf{y}} + (z_i - z'_j)\\hat{\\mathbf{z}} \\right) $$\n\n**1.2. Vertical Component of Gravitational Acceleration**\n\nThe problem requires the vertical component of the acceleration, which is the component along the $z$-axis. We obtain this by taking the dot product with the vertical unit vector $\\hat{\\mathbf{z}}$:\n$$ g_{z, ij} = \\mathbf{g}_{ij} \\cdot \\hat{\\mathbf{z}} = -G \\frac{m_j (z_i - z'_j)}{((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2)^{3/2}} $$\n\n**1.3. Forward Mapping for Multiple Sources**\n\nBy the principle of linear superposition, the total vertical acceleration $d_i$ at observation point $i$ is the sum of the contributions from all $N_{\\text{src}}$ sources:\n$$ d_i(\\mathbf{m}) = \\sum_{j=1}^{N_{\\text{src}}} g_{z, ij} = \\sum_{j=1}^{N_{\\text{src}}} \\left( -G \\frac{z_i - z'_j}{r_{ij}^3} \\right) m_j $$\nwhere $\\mathbf{m} = [m_1, m_2, \\dots, m_{N_{\\text{src}}}]^T$ is the vector of source masses. This equation defines the forward mapping from the model parameters (masses) to the data (vertical gravitational acceleration).\n\nThis relationship is linear with respect to the masses $m_j$. We can express the entire set of observations $\\mathbf{d} = [d_1, d_2, \\dots, d_{N_{\\text{obs}}}]^T$ as a matrix-vector product:\n$$ \\mathbf{d} = \\mathbf{A} \\mathbf{m} $$\nwhere $\\mathbf{A}$ is the forward operator matrix of size $N_{\\text{obs}} \\times N_{\\text{src}}$, with elements:\n$$ A_{ij} = -G \\frac{z_i - z'_j}{\\left((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2\\right)^{3/2}} $$\n\n**1.4. Analytical Jacobian Derivation**\n\nThe Jacobian matrix of the forward map $\\mathbf{d}(\\mathbf{m})$ is defined by its elements $J_{ik} = \\frac{\\partial d_i}{\\partial m_k}$. We differentiate the expression for $d_i$ with respect to the $k$-th mass, $m_k$:\n$$ J_{ik} = \\frac{\\partial}{\\partial m_k} \\left( \\sum_{j=1}^{N_{\\text{src}}} A_{ij} m_j \\right) $$\nSince the matrix elements $A_{ij}$ depend only on the geometry (coordinates) and not on the masses, they are treated as constants in this partial differentiation:\n$$ J_{ik} = \\sum_{j=1}^{N_{\\text{src}}} A_{ij} \\frac{\\partial m_j}{\\partial m_k} $$\nThe partial derivative $\\frac{\\partial m_j}{\\partial m_k}$ is equal to the Kronecker delta, $\\delta_{jk}$, which is $1$ if $j=k$ and $0$ otherwise.\n$$ J_{ik} = \\sum_{j=1}^{N_{\\text{src}}} A_{ij} \\delta_{jk} = A_{ik} $$\nTherefore, the analytical Jacobian matrix $\\mathbf{J}_{\\text{analytic}}$ is identical to the forward operator matrix $\\mathbf{A}$. The elements of the analytical Jacobian are:\n$$ J_{\\text{analytic}, ij} = -G \\frac{z_i - z'_j}{\\left((x_i - x'_j)^2 + (y_i - y'_j)^2 + (z_i - z'_j)^2\\right)^{3/2}} $$\n\n### Part 2: Implementation and Verification Strategy ###\n\nThe program will implement the derived formulas and the verification procedure.\n\n**2.1. Analytical Jacobian Implementation**\nA function will compute the matrix $\\mathbf{J}_{\\text{analytic}}$ directly using its derived formula. Given the observation and source coordinates, this function will construct the $N_{\\text{obs}} \\times N_{\\text{src}}$ matrix.\n\n**2.2. Finite Difference (FD) Jacobian Implementation**\nA second function will approximate the Jacobian using the forward finite difference method. For each column $k$ of the Jacobian (corresponding to mass $m_k$):\n1.  Compute the baseline data vector: $\\mathbf{d}_{\\text{base}} = \\mathbf{d}(\\mathbf{m})$.\n2.  Create a perturbed mass vector $\\mathbf{m}_{\\text{pert}} = \\mathbf{m} + \\epsilon \\mathbf{e}_k$, where $\\mathbf{e}_k$ is the $k$-th canonical basis vector and $\\epsilon$ is the small perturbation.\n3.  Compute the perturbed data vector: $\\mathbf{d}_{\\text{pert}} = \\mathbf{d}(\\mathbf{m}_{\\text{pert}})$.\n4.  The $k$-th column of the FD Jacobian is calculated as $(\\mathbf{d}_{\\text{pert}} - \\mathbf{d}_{\\text{base}}) / \\epsilon$.\nThis process is repeated for all $k = 1, \\dots, N_{\\text{src}}$.\n\n**2.3. Verification**\nThe two resulting matrices, $\\mathbf{J}_{\\text{analytic}}$ and $\\mathbf{J}_{\\text{FD}}$, will be compared using the specified criterion. The Frobenius norm of a matrix $\\mathbf{M}$ is given by $\\|\\mathbf{M}\\|_F = \\sqrt{\\sum_i \\sum_j M_{ij}^2}$. The comparison involves computing:\n$$ \\text{error} = \\frac{\\left\\| \\mathbf{J}_{\\text{analytic}} - \\mathbf{J}_{\\text{FD}} \\right\\|_{F}}{\\left\\| \\mathbf{J}_{\\text{FD}} \\right\\|_{F}} $$\nThe result for each test case is a boolean indicating whether $\\text{error} < 10^{-3}$. Since the forward problem is linear in mass, the FD approximation with sufficient floating-point precision should be nearly identical to the analytical Jacobian. The error should be close to machine epsilon, making the threshold $10^{-3}$ easily achievable.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravity Jacobian validation problem for all specified test cases.\n    \"\"\"\n    \n    # Gravitational Constant [m^3 kg^-1 s^-2]\n    G = 6.67430e-11\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"obs_coords\": np.array([[-100, 0, 0], [-50, 0, 0], [0, 0, 0], [50, 0, 0], [100, 0, 0]]),\n            \"src_coords\": np.array([[-75, 0, -50], [-25, 0, -50], [25, 0, -50], [75, 0, -50]]),\n            \"masses\": np.array([2e8, 1.5e8, 1.0e8, 0.5e8]),\n            \"epsilon\": 1e6\n        },\n        {\n            \"obs_coords\": np.array([[-10, 0, 0], [0, 0, 0], [10, 0, 0]]),\n            \"src_coords\": np.array([[0, 0, -10], [20, 0, -10]]),\n            \"masses\": np.array([1.0e7, 2.0e7]),\n            \"epsilon\": 1e3\n        },\n        {\n            \"obs_coords\": np.array([[-1000, 0, 0], [0, 0, 0], [1000, 0, 0]]),\n            \"src_coords\": np.array([[-500, 0, -500], [0, 0, -500], [500, 0, -500]]),\n            \"masses\": np.array([5.0e10, 3.0e10, 4.0e10]),\n            \"epsilon\": 1e12\n        }\n    ]\n\n    results = []\n    \n    # A tolerance smaller than the problem's criteria to handle very small norms\n    machine_precision_tol = 1e-15\n\n    for case in test_cases:\n        obs_coords = case[\"obs_coords\"]\n        src_coords = case[\"src_coords\"]\n        masses = case[\"masses\"]\n        epsilon = case[\"epsilon\"]\n\n        n_obs = obs_coords.shape[0]\n        n_src = src_coords.shape[0]\n\n        # --- Analytical Jacobian Calculation ---\n        # The analytical Jacobian is the sensitivity matrix 'A' because the\n        # forward problem d = Am is linear in m.\n        \n        # Use broadcasting to compute all pairwise interactions efficiently.\n        # obs_coords shape: (n_obs, 1, 3)\n        # src_coords shape: (1, n_src, 3)\n        # delta_r shape:    (n_obs, n_src, 3)\n        delta_r = obs_coords[:, np.newaxis, :] - src_coords[np.newaxis, :, :]\n        \n        # r_sq[i, j] = distance squared between obs_i and src_j\n        r_sq = np.sum(delta_r**2, axis=2)\n        r_cubed = r_sq**(3/2)\n        \n        # delta_z[i, j] = z_i - z'_j\n        delta_z = delta_r[:, :, 2]\n        \n        j_analytic = -G * delta_z / r_cubed\n        \n        # --- Forward Model Function ---\n        # The forward model computes the data vector d = j_analytic @ masses\n        def forward_model(m_vec):\n            return j_analytic @ m_vec\n\n        # --- Finite Difference Jacobian Calculation ---\n        j_fd = np.zeros((n_obs, n_src), dtype=np.float64)\n        \n        # Calculate baseline data vector\n        d_base = forward_model(masses)\n        \n        # Perturb each mass one by one to compute columns of the Jacobian\n        m_perturbed = np.copy(masses)\n        for k in range(n_src):\n            m_perturbed[k] += epsilon\n            \n            d_perturbed = forward_model(m_perturbed)\n            \n            # Compute the k-th column of the FD Jacobian\n            j_fd[:, k] = (d_perturbed - d_base) / epsilon\n            \n            # Reset the perturbed mass for the next iteration\n            m_perturbed[k] = masses[k]\n\n        # --- Comparison ---\n        norm_diff = np.linalg.norm(j_analytic - j_fd, 'fro')\n        norm_fd = np.linalg.norm(j_fd, 'fro')\n\n        # The comparison is valid only if the denominator is non-zero.\n        # Given the problem's linearity, the difference should be near zero,\n        # so this check passes if norm_fd is also near zero.\n        if norm_fd  machine_precision_tol:\n            is_correct = (norm_diff  machine_precision_tol)\n        else:\n            relative_error = norm_diff / norm_fd\n            is_correct = relative_error  1e-3\n\n        results.append(is_correct)\n    \n    # Final print statement in the exact required format.\n    # The map(str,...) converts boolean True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a reliable forward operator, we can construct a complete inversion workflow. However, real-world data is often preprocessed, for example by upward continuation, to stabilize the inversion or highlight specific features. This exercise provides an end-to-end simulation to quantify how such preprocessing impacts the final inverted model, demonstrating the trade-off between resolution loss and bias that is inherent in this common geophysical practice .",
            "id": "3601439",
            "problem": "Consider a two-dimensional inversion of the vertical component of gravitational acceleration for a surface mass density field on a square grid. The governing physics starts from Newtonian gravity: two point masses exert a force proportional to the product of their masses and inversely proportional to the square of their separation, and the acceleration field produced by a localized mass is the sum over contributions from all mass elements. Potential-field components measured on a horizontal plane are harmonic, and upward continuation in the spectral domain attenuates higher spatial wavenumbers exponentially with height. In linear inversion, zero-order Tikhonov regularization stabilizes the least-squares estimate, and the resolution matrix quantifies the effective point-spread function. You are tasked to quantify bias introduced by upward continuation preprocessing by inverting original versus continued data, and to analyze resolution loss using point-spread functions, all in a self-consistent forward-inverse computational experiment.\n\nYou must implement the following scenario entirely within your program:\n\n- Define a square computational domain of side length $L = 170\\,\\mathrm{m}$, discretized into $N = 17$ cells per side, with uniform spacing $\\Delta x = \\Delta y = 10\\,\\mathrm{m}$. Let the observation plane be located at height $z_0 = 50\\,\\mathrm{m}$ above the source plane ($z=0$). Use the International System of Units (SI), and the gravitational constant $G_\\mathrm{N} = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$.\n\n- Let the true model be a single-cell surface mass density anomaly of amplitude $\\sigma_0 = 1000\\,\\mathrm{kg\\,m^{-2}}$ at the central cell $(i = (N-1)/2, j = (N-1)/2)$, with all other cells equal to zero. Denote by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{N^2}$ the discretized surface mass density vector. The discrete forward operator maps $\\boldsymbol{\\sigma}$ to the vertical gravitational acceleration $g_z$ at the observation grid points. The forward operator must be constructed from first principles by discretizing Newton’s law: for each observation point $(x_j, y_j, z)$ and each source cell $(x_i, y_i, 0)$ with differential mass $\\mathrm{d}m_i = \\sigma_i\\,\\Delta x\\,\\Delta y$, the contribution to $g_z$ is determined by the vertical projection of the inverse-square law. The total $g_z$ is the sum over all cells. Express $g_z$ in $\\mathrm{m\\,s^{-2}}$ and, for numerical stability, you may internally convert $g_z$ to milligal units via $1\\,\\mathrm{mGal} = 10^{-5}\\,\\mathrm{m\\,s^{-2}}$ if desired, but any conversion must be self-consistent.\n\n- Upward continuation must be implemented in the spectral domain using the two-dimensional Fast Fourier Transform (FFT). Specifically, for data $d(x,y,z_0)$ on the observation plane, its two-dimensional spatial Fourier transform $\\hat{d}(k_x,k_y,z_0)$ is multiplied by the exponential attenuation factor $\\exp(-k h)$, where $k = \\sqrt{k_x^2 + k_y^2}$ is the radial spatial wavenumber in radians per meter, and $h$ is the continuation height. The continued data at height $z_0 + h$ is recovered by inverse transforming back to the spatial domain. All transforms must be performed on the discrete grid with spacing $\\Delta x = \\Delta y$, using a consistent definition of discrete spatial frequencies.\n\n- Inversion must solve a zero-order Tikhonov-regularized least-squares problem to estimate $\\hat{\\boldsymbol{\\sigma}}$ from data $\\boldsymbol{d}$ at the corresponding height, using the normal equations derived from minimizing the squared data misfit plus the squared model norm. Choose the regularization parameter $\\lambda$ as a fixed fraction $\\alpha$ of the spectral norm (largest singular value) of the forward operator for the corresponding height, that is, $\\lambda = \\alpha \\,\\| \\mathbf{G} \\|_2$. Use $\\alpha = 0.05$ for all cases. The inversion must use the matched forward operator for the data height: original data at $z_0$ must be inverted with the operator at $z_0$, and upward-continued data at $z_0+h$ must be inverted with the operator at $z_0+h$.\n\n- Resolution analysis must use the resolution matrix $\\mathbf{R}$ associated with the regularized normal equations, and the point-spread function is the column of $\\mathbf{R}$ corresponding to the central model cell. Quantify resolution loss by computing the full width at half maximum (FWHM) along the central row of the point-spread function, measured in meters, using linear interpolation between grid nodes to estimate the half-maximum crossing points.\n\n- Bias quantification must use the root-mean-square error (RMSE) of the recovered model relative to the true model, computed as $\\sqrt{\\frac{1}{N^2} \\sum_{i=1}^{N^2} (\\hat{\\sigma}_i - \\sigma_i)^2}$, and expressed in $\\mathrm{kg\\,m^{-2}}$.\n\nTest suite specification:\n\n- Use three upward continuation heights $h \\in \\{0\\,\\mathrm{m}, 20\\,\\mathrm{m}, 60\\,\\mathrm{m}\\}$. For each $h$, perform the following:\n    1. Construct and invert the original data at $z_0$ once to obtain $\\hat{\\boldsymbol{\\sigma}}^{(0)}$ and baseline RMSE $E_0$ and baseline FWHM $W_0$.\n    2. Upward continue the original data from $z_0$ to $z_0+h$ to obtain $\\boldsymbol{d}^{(h)}$, invert using the matched operator at $z_0+h$ to obtain $\\hat{\\boldsymbol{\\sigma}}^{(h)}$, compute the RMSE $E_h$, and compute the FWHM $W_h$ for the point-spread function at height $z_0+h$.\n    3. Report the incremental bias $\\Delta E_h = E_h - E_0$ in $\\mathrm{kg\\,m^{-2}}$, and the FWHM $W_h$ in $\\mathrm{m}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\Delta E_{0}, W_{0}, \\Delta E_{20}, W_{20}, \\Delta E_{60}, W_{60}]$, where each entry is a floating-point number. All FWHM outputs must be in $\\mathrm{m}$, and all incremental bias outputs must be in $\\mathrm{kg\\,m^{-2}}$.\n\nThe program must be self-contained, use no external files, and must implement the forward modeling, upward continuation, inversion with zero-order Tikhonov regularization using the specified $\\lambda$ selection, and resolution analysis with FWHM computation exactly as described. Angles, if any are used, must be in radians.",
            "solution": "The problem is valid as it presents a well-posed, scientifically grounded, and self-contained computational experiment in geophysical inversion. All necessary parameters and methods are explicitly defined.\n\n### 1. Problem Formulation and Discretization\n\nThe problem requires a two-dimensional ($2$D) inversion of gravitational data to recover a subsurface mass distribution. The physical domain is a square of side length $L = 170\\,\\mathrm{m}$, discretized into an $N \\times N$ grid with $N=17$ cells. The grid spacing is uniform, with $\\Delta x = \\Delta y = 10\\,\\mathrm{m}$. The source mass is a surface density distribution $\\sigma(x,y)$ on the $z=0$ plane, represented by a discrete vector $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{N^2}$ where each component $\\sigma_i$ is the mass density of the $i$-th cell. The data, which is the vertical component of gravitational acceleration $g_z$, is measured on a parallel plane at a height $z$. The coordinates of the center of cell $(i,j)$ (where $i,j \\in \\{0, 1, \\dots, N-1\\}$) are given by $x_j = (j - (N-1)/2)\\Delta x$ and $y_i = (i - (N-1)/2)\\Delta y$. In this coordinate system, the central cell is at $(0,0)$. The true model is a point-mass approximation: a single cell at the center of the grid has a density of $\\sigma_0 = 1000\\,\\mathrm{kg\\,m^{-2}}$, while all other cells have zero density.\n\n### 2. Forward Model Construction\n\nThe forward problem consists of calculating the gravitational data $\\boldsymbol{d}$ from a given model $\\boldsymbol{\\sigma}$. The relationship is linear, $\\boldsymbol{d} = \\mathbf{G}\\boldsymbol{\\sigma}$, where $\\mathbf{G}$ is the forward operator or sensitivity matrix. The element $G_{ij}$ of this matrix represents the vertical gravity component at observation point $i$ caused by a unit mass density in source cell $j$.\n\nAccording to Newton's law of gravitation, the gravitational acceleration $\\vec{g}$ at a position $\\vec{r}_{obs}$ due to a point mass $m_{src}$ at $\\vec{r}_{src}$ is $\\vec{g} = -G_\\mathrm{N} m_{src} \\frac{\\vec{r}_{obs} - \\vec{r}_{src}}{|\\vec{r}_{obs} - \\vec{r}_{src}|^3}$. For a source cell $j$ with area $\\Delta A = \\Delta x \\Delta y$ and unit density ($\\sigma_j = 1$), the mass is $m_j = \\Delta A$. The vertical component of acceleration, $g_z$, at an observation point $i$ at $(x_i, y_i, z_{obs})$ due to this source cell $j$ at $(x_j, y_j, 0)$ is:\n$$\nG_{ij} = [g_z]_i = -G_\\mathrm{N} \\frac{\\Delta A \\cdot z_{obs}}{\\left((x_i-x_j)^2 + (y_i-y_j)^2 + z_{obs}^2\\right)^{3/2}}\n$$\nwhere $G_\\mathrm{N} = 6.67430 \\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$. We construct this $N^2 \\times N^2$ matrix for each required observation height $z_{obs}$, which will be $z_0 = 50\\,\\mathrm{m}$ and $z_0+h$ for $h \\in \\{20, 60\\}\\,\\mathrm{m}$.\n\n### 3. Spectral Upward Continuation\n\nUpward continuation is a filtering process that transforms potential field data from one measurement surface to a higher one. In the spatial frequency (or spectral) domain, this operation is a simple multiplication. The $2$D Fourier transform of the data $d(x,y)$ on the plane $z=z_0$ is denoted $\\hat{d}(k_x, k_y)$. To continue this data upward by a height $h$ to the plane $z=z_0+h$, we multiply its spectrum by an exponential decay factor:\n$$\n\\hat{d}(k_x, k_y, z_0+h) = \\hat{d}(k_x, k_y, z_0) \\cdot e^{-\\sqrt{k_x^2 + k_y^2} h}\n$$\nHere, $k_x$ and $k_y$ are the angular spatial wavenumbers. The continued data in the spatial domain, $d(x,y,z_0+h)$, is then obtained by applying the inverse $2$D Fourier transform. For our discrete grid, we use the $2$D Fast Fourier Transform (FFT). The discrete wavenumbers are calculated as $k_x = 2\\pi f_x$ and $k_y = 2\\pi f_y$, where $f_x$ and $f_y$ are the frequencies provided by `numpy.fft.fftfreq`.\n\n### 4. Tikhonov-Regularized Inversion\n\nThe inverse problem of finding $\\boldsymbol{\\sigma}$ from $\\boldsymbol{d}$ is ill-posed. We stabilize it using zero-order Tikhonov regularization, which seeks a model that minimizes a weighted sum of the data misfit and the model norm:\n$$\n\\text{minimize} \\quad \\|\\mathbf{G}\\boldsymbol{\\sigma} - \\boldsymbol{d}\\|_2^2 + \\lambda^2 \\|\\boldsymbol{\\sigma}\\|_2^2\n$$\nThe solution to this optimization problem is given by the normal equations:\n$$\n\\hat{\\boldsymbol{\\sigma}} = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\boldsymbol{d}\n$$\nwhere $\\mathbf{I}$ is the identity matrix and $\\lambda$ is the regularization parameter. The problem specifies setting $\\lambda$ as a fraction $\\alpha = 0.05$ of the spectral norm (largest singular value) of the corresponding forward operator, i.e., $\\lambda = \\alpha \\|\\mathbf{G}\\|_2$. This links the amount of regularization to the properties of the forward operator for a given height.\n\n### 5. Resolution and Bias Analysis\n\nThe quality of the inversion is assessed through bias and resolution.\n**Bias** is quantified by the Root-Mean-Square Error (RMSE) between the estimated model $\\hat{\\boldsymbol{\\sigma}}$ and the true model $\\boldsymbol{\\sigma}_{\\text{true}}$:\n$$\nE = \\text{RMSE} = \\sqrt{\\frac{1}{N^2} \\sum_{i=1}^{N^2} (\\hat{\\sigma}_i - \\sigma_{\\text{true},i})^2}\n$$\nThe incremental bias is $\\Delta E_h = E_h - E_0$, comparing the RMSE of an inversion at height $z_0+h$ to the baseline RMSE at $z_0$.\n\n**Resolution** describes how well the inversion can distinguish fine details. It is characterized by the model resolution matrix $\\mathbf{R} = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{G}$. The $j$-th column of $\\mathbf{R}$ is the point-spread function (PSF), which represents the inverted model response to a perfect impulse (unit delta function) at the $j$-th model cell. We compute the PSF for the central cell, reshape it into an $N \\times N$ grid, and analyze its central row. The resolution is quantified by the Full Width at Half Maximum (FWHM) of this row profile, calculated in meters using linear interpolation between grid points. A larger FWHM indicates poorer resolution.\n\n### 6. Computational Experiment Workflow\n\nThe analysis is performed for upward continuation heights $h \\in \\{0, 20, 60\\}\\,\\mathrm{m}$.\n1.  **Baseline ($h=0\\,\\mathrm{m}$)**:\n    *   Construct the operator $\\mathbf{G}_0$ for height $z_0 = 50\\,\\mathrm{m}$.\n    *   Generate synthetic data $\\boldsymbol{d}_0 = \\mathbf{G}_0 \\boldsymbol{\\sigma}_{\\text{true}}$.\n    *   Invert $\\boldsymbol{d}_0$ using $\\mathbf{G}_0$ to get $\\hat{\\boldsymbol{\\sigma}}^{(0)}$.\n    *   Calculate the baseline RMSE $E_0$ and the baseline FWHM $W_0$ from the resolution matrix associated with $\\mathbf{G}_0$.\n\n2.  **Upward-Continued Cases ($h \\in \\{20, 60\\}\\,\\mathrm{m}$)**:\n    *   For each $h$, construct the operator $\\mathbf{G}_h$ for height $z_0+h$.\n    *   Upward continue the original data $\\boldsymbol{d}_0$ by height $h$ to get $\\boldsymbol{d}^{(h)}$.\n    *   Invert $\\boldsymbol{d}^{(h)}$ using the matched operator $\\mathbf{G}_h$ to get $\\hat{\\boldsymbol{\\sigma}}^{(h)}$.\n    *   Calculate the RMSE $E_h$ and FWHM $W_h$ associated with the inversion at height $z_0+h$.\n    *   Compute the incremental bias $\\Delta E_h = E_h - E_0$.\n\n3.  **Final Output**: The results are collated and printed in the specified format: $[\\Delta E_{0}, W_{0}, \\Delta E_{20}, W_{20}, \\Delta E_{60}, W_{60}]$. By definition, $\\Delta E_0 = E_0 - E_0 = 0$.",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef build_forward_operator(grid_x, grid_y, z_obs, dx):\n    \"\"\"Constructs the discrete gravitational forward operator G.\"\"\"\n    G_N = 6.67430e-11\n    \n    src_x, src_y = grid_x.flatten(), grid_y.flatten()\n    obs_x, obs_y = src_x, src_y\n\n    # Use broadcasting to compute all pairs of distances efficiently\n    dx_mat = obs_x[:, np.newaxis] - src_x[np.newaxis, :]\n    dy_mat = obs_y[:, np.newaxis] - src_y[np.newaxis, :]\n    \n    r_sq = dx_mat**2 + dy_mat**2 + z_obs**2\n    \n    # Kernel for vertical gravity component due to a surface density element\n    G = -G_N * (dx * dx) * z_obs / (r_sq**1.5)\n    return G\n\ndef upward_continue(data_grid, h, dx):\n    \"\"\"Performs upward continuation on a 2D data grid using FFT.\"\"\"\n    N = data_grid.shape[0]\n    \n    # Calculate angular wavenumbers\n    freqs = np.fft.fftfreq(N, d=dx)\n    kx, ky = 2 * np.pi * freqs, 2 * np.pi * freqs\n    kx_grid, ky_grid = np.meshgrid(kx, ky)\n    k_radial = np.sqrt(kx_grid**2 + ky_grid**2)\n    \n    # Define upward continuation filter in the spectral domain\n    uc_filter = np.exp(-k_radial * h)\n    \n    # Apply filter and inverse transform\n    data_fft = np.fft.fft2(data_grid)\n    data_continued_fft = data_fft * uc_filter\n    data_continued_grid = np.fft.ifft2(data_continued_fft)\n    \n    return np.real(data_continued_grid)\n\ndef calculate_fwhm(psf_row, x_coords, center_idx):\n    \"\"\"Calculates the Full Width at Half Maximum of a 1D profile.\"\"\"\n    N = len(psf_row)\n    peak_val = psf_row[center_idx]\n    half_max = peak_val / 2.0\n    \n    x_left, x_right = None, None\n    \n    # Find left crossing point using linear interpolation\n    for i in range(center_idx, 0, -1):\n        if psf_row[i] >= half_max and psf_row[i-1]  half_max:\n            y1, y2 = psf_row[i-1], psf_row[i]\n            x1, x2 = x_coords[i-1], x_coords[i]\n            x_left = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1)\n            break\n            \n    # Find right crossing point using linear interpolation\n    for i in range(center_idx, N - 1):\n        if psf_row[i] >= half_max and psf_row[i+1]  half_max:\n            y1, y2 = psf_row[i], psf_row[i+1]\n            x1, x2 = x_coords[i], x_coords[i+1]\n            x_right = x1 + (x2 - x1) * (half_max - y1) / (y2 - y1)\n            break\n    \n    if x_left is None or x_right is None:\n        return np.nan # Error case: half-max not crossed\n\n    return x_right - x_left\n\ndef solve():\n    # Define problem parameters\n    N = 17\n    dx = 10.0\n    z0 = 50.0\n    sigma0 = 1000.0\n    alpha = 0.05\n    h_values = [0.0, 20.0, 60.0]\n\n    # Set up computational grid and model\n    x_coords = (np.arange(N) - (N - 1) / 2) * dx\n    grid_x, grid_y = np.meshgrid(x_coords, x_coords)\n    \n    center_idx_2d = (N - 1) // 2\n    center_idx_1d = center_idx_2d * N + center_idx_2d\n\n    sigma_true_grid = np.zeros((N, N))\n    sigma_true_grid[center_idx_2d, center_idx_2d] = sigma0\n    sigma_true_vec = sigma_true_grid.flatten()\n    \n    e_values = {}\n    w_values = {}\n\n    # Generate the base data at z0, which is upward continued in later steps\n    G0 = build_forward_operator(grid_x, grid_y, z0, dx)\n    data_at_z0_vec = G0 @ sigma_true_vec\n    data_at_z0_grid = data_at_z0_vec.reshape((N, N))\n\n    # Loop through each case (h=0, 20, 60)\n    for h in h_values:\n        z_obs = z0 + h\n        G_h = build_forward_operator(grid_x, grid_y, z_obs, dx)\n        \n        # Select data for inversion: original for h=0, continued for h>0\n        if h == 0.0:\n            data_to_invert_vec = data_at_z0_vec\n        else:\n            data_continued_grid = upward_continue(data_at_z0_grid, h, dx)\n            data_to_invert_vec = data_continued_grid.flatten()\n            \n        # Tikhonov-regularized inversion\n        lambda_reg = alpha * scipy.linalg.svdvals(G_h)[0]\n        GT_G = G_h.T @ G_h\n        A = GT_G + (lambda_reg**2) * np.identity(N**2)\n        b = G_h.T @ data_to_invert_vec\n        sigma_est_vec = np.linalg.solve(A, b)\n        \n        # Calculate RMSE (bias metric)\n        e_values[h] = np.sqrt(np.mean((sigma_est_vec - sigma_true_vec)**2))\n        \n        # Calculate FWHM from PSF (resolution metric)\n        v = GT_G[:, center_idx_1d]\n        psf_vec = np.linalg.solve(A, v)\n        psf_grid = psf_vec.reshape((N, N))\n        psf_row = psf_grid[center_idx_2d, :]\n        w_values[h] = calculate_fwhm(psf_row, x_coords, center_idx_2d)\n\n    # Assemble the final results as specified\n    E0 = e_values[0.0]\n    final_results = [\n        0.0,                      # Delta E_0 = E_0 - E_0\n        w_values[0.0],            # W_0\n        e_values[20.0] - E0,      # Delta E_20 = E_20 - E_0\n        w_values[20.0],           # W_20\n        e_values[60.0] - E0,      # Delta E_60 = E_60 - E_0\n        w_values[60.0]             # W_60\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An inversion algorithm will always produce a model, but how much can we trust its features? This final practice moves from model creation to model appraisal by introducing the model resolution matrix. You will learn to compute and interpret point-spread functions and the Depth of Investigation (DOI), powerful diagnostic tools that provide quantitative answers to the crucial question: 'What did my inversion actually resolve?' .",
            "id": "3601359",
            "problem": "Consider a linearized gravity inversion in three dimensions for a compact model domain discretized into voxels. Use Newton’s law of universal gravitation and the linear inverse problem framework to derive and compute approximate model resolving kernels and the Depth of Investigation (DOI) via the inverse Hessian. From first principles, start with the physical forward model and assemble the sensitivity matrix, then derive the inverse Hessian in Tikhonov-regularized weighted least squares, and finally compute the model resolution matrix, point-spread functions, and DOI.\n\nLet the model domain be a regular grid of $n_x \\times n_y \\times n_z$ voxels. The model parameter vector is $m \\in \\mathbb{R}^{n_m}$ with $n_m = n_x n_y n_z$, containing density anomalies in $\\mathrm{kg/m^3}$ per voxel. Observations are the vertical component of gravitational acceleration at surface points, measured in $\\mathrm{m/s^2}$. Use Newton’s law of universal gravitation with the universal gravitational constant $\\gamma = 6.674 \\times 10^{-11}$ in $\\mathrm{N\\,m^2/kg^2}$ and approximate each voxel as a point mass located at its center. If an observation is at position $\\mathbf{x}_i = (x_i, y_i, z_i)$ and voxel $j$ is located at center $\\mathbf{x}_j = (x_j, y_j, z_j)$ with volume $V$, then the contribution of voxel $j$ (for unit density $1\\,\\mathrm{kg/m^3}$) to the vertical component of gravitational acceleration at observation $i$ is\n$$\nG_{ij} = \\gamma \\, V \\, \\frac{z_j - z_i}{\\left\\|\\mathbf{x}_j - \\mathbf{x}_i\\right\\|^3}.\n$$\nThe sensitivity matrix $G \\in \\mathbb{R}^{n_d \\times n_m}$ maps model parameters $m$ (densities) to data $d$ (gravity). Assume a data standard deviation $\\sigma$ (noise level) is known and constant for all observations. Let the data weighting matrix be $W_d = \\mathrm{diag}(1/\\sigma, \\ldots, 1/\\sigma)$ and a zeroth-order Tikhonov regularization with parameter $\\alpha  0$, such that the regularization operator is the identity matrix $I$. The Tikhonov-regularized weighted least squares objective is\n$$\n\\Phi(m) = \\left\\| W_d \\left( G m - d \\right) \\right\\|_2^2 + \\alpha^2 \\left\\| m \\right\\|_2^2.\n$$\nThe Hessian for this quadratic objective is\n$$\nH = G^\\top W_d^\\top W_d \\, G + \\alpha^2 I,\n$$\nand the model resolution matrix is\n$$\nR = H^{-1} G^\\top W_d^\\top W_d \\, G.\n$$\nFor a unit impulse at voxel index $j$, the estimated model is $m_{\\text{est}} = R \\, e_j$, where $e_j$ is the $j$-th canonical basis vector. The vector $R \\, e_j$ is the Point-Spread Function (PSF) in model space for voxel $j$; it quantifies how a unit spike at $j$ spreads to other voxels in the estimated model. The Depth of Investigation (DOI) for voxel $j$ can be defined from the PSF by thresholding: for a threshold $\\tau \\in (0,1)$, the DOI depth for voxel $j$ is\n$$\nd^{\\text{DOI}}_j = \\max \\left\\{ z_k \\,:\\, \\left| \\left( R \\, e_j \\right)_k \\right| \\ge \\tau \\cdot \\max_{\\ell} \\left| \\left( R \\, e_j \\right)_\\ell \\right| \\right\\},\n$$\nwhere $z_k$ is the depth coordinate of voxel $k$. If the thresholded set is empty, define $d^{\\text{DOI}}_j = 0$.\n\nImplement this in a program with the following fixed geometry and parameters to ensure scientific realism and reproducibility:\n\n- The model grid has $n_x = 3$, $n_y = 3$, $n_z = 3$. The voxel spacings are $dx = 100\\,\\mathrm{m}$, $dy = 100\\,\\mathrm{m}$, $dz = 100\\,\\mathrm{m}$. The voxel volume is $V = dx \\times dy \\times dz$.\n- Voxel center coordinates are on a Cartesian grid with $x \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$, $y \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$, and depths $z \\in \\{50, 150, 250\\}\\,\\mathrm{m}$, so that the model occupies a $300 \\times 300 \\times 300\\,\\mathrm{m^3}$ region below the observation plane.\n- Observations are taken on the plane $z = 0\\,\\mathrm{m}$ at a $4 \\times 4$ grid with coordinates $x \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$ and $y \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$.\n- The data standard deviation is $\\sigma = 10^{-6}\\,\\mathrm{m/s^2}$.\n\nUse the index mapping for voxels defined by $j = i_x + n_x \\left( i_y + n_y \\, i_z \\right)$ where $i_x \\in \\{0,1,2\\}$, $i_y \\in \\{0,1,2\\}$, and $i_z \\in \\{0,1,2\\}$ index the $x$, $y$, and $z$ positions respectively. With this mapping, the center voxel $(x=0,y=0,z=150\\,\\mathrm{m})$ has index $j=13$, the bottom center voxel $(x=0,y=0,z=250\\,\\mathrm{m})$ has index $j=22$, and the top corner voxel $(x=-100,y=-100,z=50\\,\\mathrm{m})$ has index $j=0$.\n\nYour program must compute the model resolution matrix $R$ for specified values of $\\alpha$, then, for specified voxel indices $j$ and thresholds $\\tau$, compute:\n- The self-resolution score $r_{jj}$ where $r_{jj}$ is the diagonal element of $R$ at index $j$.\n- The DOI depth $d^{\\text{DOI}}_j$ in meters.\n\nTest Suite:\nProvide results for the following cases, each specified as a tuple $(\\alpha, \\tau, j)$:\n1. $(1.0, 0.1, 13)$ representing moderate regularization, a center voxel PSF, and a typical threshold.\n2. $(0.01, 0.05, 22)$ representing very weak regularization, a deep voxel PSF, and a stricter threshold.\n3. $(10.0, 0.2, 0)$ representing strong regularization, a shallow corner voxel PSF, and a more aggressive threshold.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of two floats $[r_{jj}, d^{\\text{DOI}}_j]$ where $d^{\\text{DOI}}_j$ is expressed in meters. For example, the output should look like\n$$\n\\left[ [r_{jj}^{(1)}, d^{\\text{DOI}}_{j_1}] , [r_{jj}^{(2)}, d^{\\text{DOI}}_{j_2}] , [r_{jj}^{(3)}, d^{\\text{DOI}}_{j_3}] \\right].\n$$\nYour program must implement the complete computational pipeline described, without requiring any user input or external files, and must use the fixed geometry and parameters specified above.",
            "solution": "The problem requires the computation of model resolution diagnostics, specifically the self-resolution score and the Depth of Investigation (DOI), for a linearized three-dimensional gravity inversion problem. This will be accomplished by following the framework of Tikhonov-regularized weighted least squares and analyzing the resulting model resolution matrix. The derivation begins with first principles, starting from the physical forward model based on Newton's law of universal gravitation.\n\nThe core of the problem lies in understanding how the choice of regularization parameter $\\alpha$ influences the ability of the geophysical survey to resolve features in the subsurface. A small $\\alpha$ leads to a solution that fits the data closely but can be unstable and oscillatory, while a large $\\alpha$ yields a smooth and stable solution that may not fit the data well. The model resolution matrix quantifies this trade-off.\n\n**1. System Geometry and Discretization**\n\nFirst, we define the geometry of the physical system. The subsurface model domain is discretized into a regular grid of voxels.\n- Model grid dimensions: $n_x = 3$, $n_y = 3$, $n_z = 3$.\n- Total number of model parameters (voxels): $n_m = n_x n_y n_z = 27$.\n- Voxel dimensions: $dx = 100\\,\\mathrm{m}$, $dy = 100\\,\\mathrm{m}$, $dz = 100\\,\\mathrm{m}$.\n- Voxel volume: $V = dx \\cdot dy \\cdot dz = 10^6\\,\\mathrm{m^3}$.\nThe model parameter vector $m \\in \\mathbb{R}^{n_m}$ consists of the density anomaly $\\rho_j$ for each voxel $j$.\n\nThe voxel centers are located at coordinates $(x_j, y_j, z_j)$ on a Cartesian grid. The problem specifies a coordinate system where the $z$-axis points vertically downwards, so $z$ represents depth.\n- Voxel center x-coordinates: $x \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$.\n- Voxel center y-coordinates: $y \\in \\{-100, 0, 100\\}\\,\\mathrm{m}$.\n- Voxel center z-coordinates (depths): $z \\in \\{50, 150, 250\\}\\,\\mathrm{m}$.\n\nThe voxel indices $j \\in \\{0, 1, \\dots, n_m-1\\}$ are mapped from grid indices $(i_x, i_y, i_z) \\in \\{0,1,2\\}^3$ using the formula $j = i_x + n_x(i_y + n_y i_z)$.\n\nThe gravity data are measured at observation points located on the surface plane $z=0$.\n- Observation grid: $4 \\times 4$.\n- Total number of data points: $n_d = 4 \\times 4 = 16$.\n- Observation coordinates $\\mathbf{x}_i = (x_i, y_i, z_i)$:\n  - $x_i \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$.\n  - $y_i \\in \\{-150, -50, 50, 150\\}\\,\\mathrm{m}$.\n  - $z_i = 0 \\,\\mathrm{m}$ for all $i$.\n\n**2. Physical Forward Model and Sensitivity Matrix**\n\nThe forward model relates the model parameters (density anomalies $m$) to the observable data (vertical gravitational acceleration $d$). According to Newton's law of universal gravitation, the acceleration $\\mathbf{g}$ at a point $\\mathbf{x}_i$ due to a point mass $M_j$ at $\\mathbf{x}_j$ is given by $\\mathbf{g} = \\gamma M_j / \\|\\mathbf{x}_j - \\mathbf{x}_i\\|^2 \\cdot \\hat{\\mathbf{r}}$, where $\\hat{\\mathbf{r}}$ is the unit vector pointing from $\\mathbf{x}_i$ to $\\mathbf{x}_j$.\n\nApproximating each voxel as a point mass $M_j = m_j V$ at its center (where $m_j$ is the density anomaly), the vertical component of the gravitational acceleration at observation point $i$ due to voxel $j$ is:\n$$\ng_{z,ij} = \\gamma M_j \\frac{z_j - z_i}{\\|\\mathbf{x}_j - \\mathbf{x}_i\\|^3} = \\left(\\gamma V \\frac{z_j - z_i}{\\|\\mathbf{x}_j - \\mathbf{x}_i\\|^3}\\right) m_j\n$$\nThe total vertical acceleration at point $i$ is the sum of contributions from all voxels: $d_i = \\sum_{j=1}^{n_m} G_{ij} m_j$. This defines the linear forward model $d = Gm$, where $G$ is the sensitivity matrix. The elements of $G$ are given by:\n$$\nG_{ij} = \\gamma V \\frac{z_j - z_i}{\\left( (x_j - x_i)^2 + (y_j - y_i)^2 + (z_j - z_i)^2 \\right)^{3/2}}\n$$\nwhere $\\gamma = 6.674 \\times 10^{-11} \\, \\mathrm{N\\,m^2/kg^2}$ is the gravitational constant. The matrix $G$ will have dimensions $n_d \\times n_m$, which is $16 \\times 27$ for this problem.\n\n**3. Tikhonov-Regularized Inverse Problem**\n\nGiven a set of noisy measurements $d_{obs}$, we seek to estimate the model $m$. This is an inverse problem, which is typically ill-posed. We find a stable solution by minimizing a Tikhonov-regularized weighted least-squares objective function:\n$$\n\\Phi(m) = \\|W_d(Gm - d_{obs})\\|_2^2 + \\alpha^2 \\|m\\|_2^2\n$$\n- The first term is the weighted data misfit. The data weighting matrix is $W_d = \\sigma^{-1}I$, where $\\sigma = 10^{-6}\\,\\mathrm{m/s^2}$ is the standard deviation of the data noise. This term $\\sum_{i=1}^{n_d} ((Gm)_i - d_{i,obs})^2 / \\sigma^2$ is dimensionless.\n- The second term is the regularization term (or model norm). Here, a zeroth-order Tikhonov regularization is used, penalizing the squared $L_2$-norm of the model vector.\n- $\\alpha  0$ is the regularization parameter that balances the two terms. For the two terms to be dimensionally consistent, $\\alpha$ must carry units. Based on the units of $G$ and $m$, $\\alpha$ has units of $\\mathrm{m^3/kg}$. The problem provides $\\alpha$ as a dimensionless number, a common convention where the units are implicitly assumed.\n\nThe minimum of the quadratic function $\\Phi(m)$ is found by setting its gradient with respect to $m$ to zero, which leads to the normal equations:\n$$\n(G^\\top W_d^\\top W_d G + \\alpha^2 I) m_{est} = G^\\top W_d^\\top W_d d_{obs}\n$$\nThe matrix $H = G^\\top W_d^\\top W_d G + \\alpha^2 I$ is the Hessian of the objective function. As $W_d$ is diagonal, $W_d^\\top W_d = W_d^2 = \\sigma^{-2}I$. The Hessian simplifies to:\n$$\nH = \\frac{1}{\\sigma^2} G^\\top G + \\alpha^2 I\n$$\nSince $G^\\top G$ is positive semi-definite and $\\alpha  0$, $H$ is a symmetric positive-definite matrix and is thus invertible.\n\n**4. Model Resolution Analysis**\n\nThe solution to the normal equations is $m_{est} = H^{-1} G^\\top W_d^2 d_{obs}$. If we substitute the \"true\" data $d_{true} = Gm_{true}$, we can see how the estimated model relates to the true model:\n$$\nm_{est} = (H^{-1} G^\\top W_d^2 G) m_{true}\n$$\nThe matrix $R = H^{-1} G^\\top W_d^2 G$ is the model resolution matrix. It is an $n_m \\times n_m$ matrix that describes how the inversion process maps the true model space onto the estimated model space. An ideal inversion would have $R=I$, meaning each estimated parameter $m_{est,j}$ is equal to the true parameter $m_{true,j}$. In reality, $R$ deviates from the identity, indicating a loss of resolution.\n\n- **Point-Spread Function (PSF)**: The $j$-th column of $R$, denoted by $R e_j$ (where $e_j$ is the $j$-th canonical basis vector), is the Point-Spread Function for voxel $j$. It represents the estimated model $m_{est}$ that would result from a \"true\" model consisting of a single unit-density anomaly only in voxel $j$ (i.e., $m_{true} = e_j$). It shows how the energy from a single voxel is \"smeared\" across the entire model domain by the inversion.\n\n- **Self-Resolution Score**: The diagonal element $r_{jj} = R_{jj}$ is the self-resolution score for voxel $j$. It is the value of the PSF for voxel $j$ at its own location. A value close to $1$ indicates that the anomaly in voxel $j$ is well-resolved and its magnitude is correctly estimated. A value less than $1$ indicates that its amplitude is underestimated and its energy is spread to other voxels.\n\n- **Depth of Investigation (DOI)**: The DOI provides a measure of how deep into the model we can reliably image features. For a source at voxel $j$, the DOI is defined as the maximum depth of any voxel $k$ whose response in the PSF, $|(Re_j)_k|$, is significant relative to the peak of the PSF. Using a threshold $\\tau \\in (0,1)$, the DOI depth is:\n$$\nd^{\\text{DOI}}_j = \\max \\left\\{ z_k \\,:\\, |(Re_j)_k| \\ge \\tau \\cdot \\max_{\\ell} |(Re_j)_\\ell| \\right\\}\n$$\nIf no voxel satisfies the threshold condition, the DOI depth is taken to be $0$. A larger DOI depth for a source indicates that the information from this source is smeared to greater depths.\n\n**5. Computational Procedure**\n\nThe implementation follows these steps:\n1.  Define all physical and geometrical constants and parameters as specified.\n2.  Generate the arrays of $n_m$ voxel center coordinates and $n_d$ observation coordinates. Create an array of model $z$-coordinates for later use in the DOI calculation.\n3.  Construct the $n_d \\times n_m$ sensitivity matrix $G$ by iterating through each observation-voxel pair and applying the formula for $G_{ij}$.\n4.  For each test case $(\\alpha, \\tau, j)$:\n    a. Calculate the term $G^\\top W_d^2 G = (1/\\sigma^2)G^\\top G$.\n    b. Form the Hessian matrix $H = (1/\\sigma^2)G^\\top G + \\alpha^2 I$.\n    c. Compute the inverse of the Hessian, $H^{-1}$.\n    d. Compute the model resolution matrix $R = H^{-1} ((1/\\sigma^2)G^\\top G)$.\n    e. Extract the self-resolution score $r_{jj} = R[j, j]$.\n    f. Extract the PSF for voxel $j$, which is the $j$-th column of $R$.\n    g. Calculate the DOI depth $d^{\\text{DOI}}_j$ by finding the maximum depth of voxels whose PSF amplitude exceeds the specified threshold relative to the peak PSF amplitude.\n5.  Collect the pairs $[r_{jj}, d^{\\text{DOI}}_j]$ for all test cases and format the final output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes model resolution diagnostics for a 3D linearized gravity inversion problem.\n    \"\"\"\n    # 1. Define constants and parameters\n    GAMMA = 6.674e-11  # N m^2 / kg^2\n    \n    # Model grid parameters\n    nx, ny, nz = 3, 3, 3\n    nm = nx * ny * nz\n    dx, dy, dz = 100.0, 100.0, 100.0  # meters\n    V = dx * dy * dz  # m^3\n\n    # Voxel center coordinates\n    x_model_coords = np.array([-100.0, 0.0, 100.0])\n    y_model_coords = np.array([-100.0, 0.0, 100.0])\n    z_model_coords = np.array([50.0, 150.0, 250.0])  # depths\n\n    model_centers = np.zeros((nm, 3))\n    model_z_only = np.zeros(nm)\n    # Voxel indexing: j = ix + nx * (iy + ny * iz)\n    for iz in range(nz):\n        for iy in range(ny):\n            for ix in range(nx):\n                j = ix + nx * (iy + ny * iz)\n                model_centers[j, 0] = x_model_coords[ix]\n                model_centers[j, 1] = y_model_coords[iy]\n                model_centers[j, 2] = z_model_coords[iz]\n                model_z_only[j] = z_model_coords[iz]\n\n    # Observation grid parameters\n    x_obs_coords = np.array([-150.0, -50.0, 50.0, 150.0])\n    y_obs_coords = np.array([-150.0, -50.0, 50.0, 150.0])\n    nd = len(x_obs_coords) * len(y_obs_coords)\n\n    obs_centers = np.zeros((nd, 3))\n    k = 0\n    for y_obs in y_obs_coords:\n        for x_obs in x_obs_coords:\n            obs_centers[k, 0] = x_obs\n            obs_centers[k, 1] = y_obs\n            obs_centers[k, 2] = 0.0\n            k += 1\n\n    # Inversion parameters\n    sigma = 1.0e-6  # m/s^2\n\n    # 2. Assemble the sensitivity matrix G\n    G = np.zeros((nd, nm))\n    for i in range(nd):\n        obs_pos = obs_centers[i, :]\n        for j in range(nm):\n            model_pos = model_centers[j, :]\n            \n            # Vector from observation to model voxel\n            r_vec = model_pos - obs_pos\n            r_norm = np.linalg.norm(r_vec)\n            \n            # G_ij = gamma * V * (z_j - z_i) / ||x_j - x_i||^3\n            # z_i is 0 for all observations\n            G[i, j] = GAMMA * V * r_vec[2] / (r_norm**3)\n\n    # 3. Process test cases\n    test_cases = [\n        # (alpha, tau, j)\n        (1.0, 0.1, 13),   # Moderate regularization, center voxel\n        (0.01, 0.05, 22),  # Weak regularization, deep voxel\n        (10.0, 0.2, 0)     # Strong regularization, shallow corner voxel\n    ]\n\n    results = []\n    \n    # Pre-compute shared term GT * Wd^2 * G\n    Wd_sq = 1.0 / (sigma**2)\n    GT_Wd2_G = G.T @ (Wd_sq * G)\n    \n    for alpha, tau, j_idx in test_cases:\n        # a. Form the Hessian matrix H\n        H = GT_Wd2_G + (alpha**2) * np.identity(nm)\n        \n        # b. Invert the Hessian\n        H_inv = np.linalg.inv(H)\n        \n        # c. Compute the model resolution matrix R\n        R = H_inv @ GT_Wd2_G\n        \n        # d. Extract self-resolution score\n        r_jj = R[j_idx, j_idx]\n        \n        # e. Extract Point-Spread Function (PSF) for voxel j\n        psf_j = R[:, j_idx]\n        \n        # f. Compute Depth of Investigation (DOI)\n        abs_psf = np.abs(psf_j)\n        max_psf_val = np.max(abs_psf)\n        \n        if max_psf_val == 0:\n            doi_depth = 0.0\n        else:\n            threshold_val = tau * max_psf_val\n            indices_above_thresh = np.where(abs_psf >= threshold_val)[0]\n            \n            if len(indices_above_thresh) == 0:\n                doi_depth = 0.0\n            else:\n                z_coords_above_thresh = model_z_only[indices_above_thresh]\n                doi_depth = np.max(z_coords_above_thresh)\n        \n        results.append([r_jj, doi_depth])\n\n    # 4. Format and print the final output\n    item_strs = [f\"[{r:.6f},{d:.1f}]\" for r, d in results]\n    output_str = f\"[{','.join(item_strs)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}