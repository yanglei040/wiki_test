{
    "hands_on_practices": [
        {
            "introduction": "在理解了下延的理论限制之后，下一个实际步骤是在有限的数据网格上实现延拓算法。基于快速傅里叶变换（FFT）的方法是标准技术，但它引入了由周期性边界假设引起的“环绕”误差。本练习旨在分析这些边界效应的来源，并评估如零填充和锥形化等常用缓解策略的有效性，这些都是开发稳健延拓代码的关键考虑因素。",
            "id": "3618265",
            "problem": "给定一个在平面 $z=0$ 上、大小为 $L_x \\times L_y$ 的矩形域内测得的标量势场 $u(x,y,0)$。在该平面上方的无源半空间中，该势场满足 Laplace 方程 $\\nabla^2 u = 0$。你需要使用一个基于快速傅里叶变换 (FFT) 的算法，在一个均匀网格上计算该场延拓到高度 $z=h$ (向上延拓) 或深度 $z=-h$ (向下延拓) 的结果。该算法隐含地假设在 $x$ 和 $y$ 方向上具有周期为 $L_x$ 和 $L_y$ 的周期性边界条件。\n\n从无源半空间中调和延拓的第一性原理以及有限域上离散傅里叶变换的性质出发，分析在进行向上或向下延拓时，由区域边缘附近的隐含周期性延拓所引入的偏差的来源和定性标度。然后，确定哪些提出的缓解策略是具有科学合理性且有效的。\n\n选择所有正确的选项。\n\nA. 基于FFT的延拓在物理域中等效于将 $u$ 与一个格点求和的 Green 函数进行卷积，即在周期为 $L_x$ 和 $L_y$ 的 $\\mathbb{Z}^2$ 格点上周期性复制的 Poisson 核。因此，在距离边缘 $d$ 处，主要偏差来自最近的周期性镜像，其间距 $s \\approx \\min(L_x - 2d,\\, L_y - 2d)$。对于向上延拓到高度 $h$，偏差大小的标度类似于 Poisson 核的尾部 $P(s,h) \\sim \\dfrac{h}{2\\pi (s^2 + h^2)^{3/2}}$，随着 $s$ 的增大而快速衰减。一个实际的缓解方法是在空间上进行零填充以创建一个保护区，使得 $s$ 很大（例如，为 $h$ 的几倍），在填充后的网格上进行延拓，并丢弃一个宽度与保护区相当的边界。\n\nB. 在向下延拓中，高空间频率被抑制，因此周期性回卷是可忽略不计的。因此，填充是不必要的；事实上，在原始边缘使用矩形（boxcar）窗对于保持分辨率是最佳的。\n\nC. 在进行FFT之前，应用一个平滑的切趾（例如，余弦锥形窗），使数据在边界处衰减到接近零，这样可以减少边界的不连续性，从而减少频谱泄漏和周期性镜像的影响。延拓后，将注意力限制在未锥削的内部区域可以减少边缘偏差。这对于向下延拓尤其重要，因为在向下延拓中高波数会被放大。\n\nD. 在不扩大空间范围的情况下，通过在傅里叶域中进行零填充（在 $k$ 空间中插值）来增加傅里叶模式的数量，会增加有效周期长度，从而消除边缘附近的回卷偏差。\n\nE. 在边界处对数据进行镜像填充（偶延拓）可以消除调和场的虚假镜像相互作用，因为 Laplace 方程的解是偶对称的，所以周期和不再对边缘产生偏差；因此，这是一个无需丢弃边界的完整补救措施。",
            "solution": "用户要求我分析关于使用FFT进行势场向上和向下延拓的问题陈述，并评估所提出的针对边缘效应的缓解策略。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- 一个在平面 $z=0$ 上、大小为 $L_x \\times L_y$ 的矩形域内测得的标量势场 $u(x,y,0)$。\n- 在该平面上方的无源半空间中（$z>0$），该势场满足 Laplace 方程 $\\nabla^2 u = 0$。\n- 目标是计算该场延拓到高度 $z=h$ (向上延拓) 或深度 $z=-h$ (向下延拓) 的结果。\n- 使用的方法是基于快速傅里叶变换 (FFT) 的算法，在均匀网格上进行。\n- FFT 算法隐含地假设在 $x$ 和 $y$ 方向上具有周期为 $L_x$ 和 $L_y$ 的周期性边界条件。\n- 任务是分析由周期性延拓引入的偏差的来源和标度，并评估提出的缓解策略。\n\n**第二步：使用提取的已知条件进行验证**\n问题陈述是科学上合理、适定且客观的。\n- **科学基础：** 该问题植根于势场理论（Laplace 方程）和计算地球物理与信号处理中标准数值方法（基于 FFT 的滤波）的基本原理。向上/向下延拓以及周期性边界条件产生的伪影是该领域的标准课题。\n- **适定性：** 该问题是对一种数值方法特性的概念性分析。它要求进行定性分析和技术评估，这是一个定义明确的任务，有科学上可验证的答案。\n- **客观性：** 语言技术性强且精确。它描述了一个数学和计算设置，没有任何主观或模棱两可的术语。\n\n所有有效问题的标准都已满足。未发现任何缺陷。\n\n**第三步：结论与行动**\n问题是有效的。我将继续进行推导和分析。\n\n### 从第一性原理推导\n\n在无源区域，势场 $u(x,y,z)$ 满足 Laplace 方程：\n$$ \\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{\\partial^2 u}{\\partial z^2} = 0 $$\n我们可以使用关于空间坐标 $x$ 和 $y$ 的二维傅里叶变换来表示该场。设 $\\hat{u}(k_x, k_y, z)$ 是 $u(x,y,z)$ 的傅里叶变换：\n$$ \\hat{u}(k_x, k_y, z) = \\iint u(x,y,z) e^{-i(k_x x + k_y y)} dx dy $$\n对 Laplace 方程应用傅里叶变换，得到一个关于 $z$ 的常微分方程：\n$$ (-k_x^2 - k_y^2)\\hat{u}(k_x, k_y, z) + \\frac{\\partial^2 \\hat{u}}{\\partial z^2}(k_x, k_y, z) = 0 $$\n令 $k = \\sqrt{k_x^2 + k_y^2}$ 为径向波数。方程变为：\n$$ \\frac{\\partial^2 \\hat{u}}{\\partial z^2} - k^2 \\hat{u} = 0 $$\n通解为 $\\hat{u}(k,z) = A(k)e^{kz} + B(k)e^{-kz}$。\n对于半空间 $z \\ge 0$，我们要求势在 $z \\to \\infty$ 时有界。这个物理约束意味着对于任何 $k \\ne 0$，都有 $A(k)=0$。因此，解为 $\\hat{u}(k,z) = B(k)e^{-kz}$。\n在 $z=0$ 处，我们有 $\\hat{u}(k,0) = B(k)$。因此，对于任何 $z>0$ 的解是：\n$$ \\hat{u}(k_x, k_y, z) = \\hat{u}(k_x, k_y, 0) e^{-kz} $$\n这个方程是傅里叶域延拓的核心。\n- **向上延拓**到高度 $z=h > 0$：我们将频谱乘以滤波器 $e^{-kh}$。这是一个低通滤波器，因为它指数衰减高波数 $k$ 的分量。这个过程是稳定的。\n- **向下延拓**到深度 $z=-h$ ($h>0$)：我们寻求测量平面下方的场。形式上，这对应于使用算子 $e^{-k(-h)} = e^{kh}$。这是一个高通滤波器，它指数*放大*高波数分量。这使得该过程内在不稳定，并且是一个不适定反问题，因为数据中的任何高频噪声都将被大规模放大。\n\n基于 FFT 的算法在大小为 $L_x \\times L_y$ 的离散网格上实现此过程。使用离散傅里叶变换（DFT）（由 FFT 算法计算）隐含地假设数据 $u(x,y,0)$ 以 $L_x$ 和 $L_y$ 为周期。\n根据卷积定理，傅里叶域中的乘法等效于空间域中的卷积。与滤波器 $e^{-k|z|}$ 对应的空间域算子是用于半空间延拓的 Poisson 核，$P(x,y,z) = \\frac{|z|}{2\\pi (x^2+y^2+z^2)^{3/2}}$。\n因为 FFT 隐含了周期性，所以执行的操作不是标准卷积，而是**循环卷积**。这等效于将原始数据块与核的周期化版本进行卷积：\n$$ u_{FFT}(x,y,z) = u(x,y,0) * \\left( \\sum_{m,n=-\\infty}^{\\infty} P(x-mL_x, y-nL_y, z) \\right) $$\n其中 $*$ 表示卷积。真正的解只涉及 $m=0, n=0$ 项。偏差，或称“回卷”误差，是所有其他项 $(m,n) \\neq (0,0)$ 的贡献。这种偏差在区域边界附近最大，因为在那里，数据的最近周期性镜像（例如，来自大约 $L_x$ 和 $L_y$ 的距离）的影响最强。\n\n### 逐项分析\n\n**A. 基于FFT的延拓在物理域中等效于将 $u$ 与一个格点求和的 Green 函数进行卷积，即在周期为 $L_x$ 和 $L_y$ 的 $\\mathbb{Z}^2$ 格点上周期性复制的 Poisson 核。因此，在距离边缘 $d$ 处，主要偏差来自最近的周期性镜像，其间距 $s \\approx \\min(L_x - 2d,\\, L_y - 2d)$。对于向上延拓到高度 $h$，偏差大小的标度类似于 Poisson 核的尾部 $P(s,h) \\sim \\dfrac{h}{2\\pi (s^2 + h^2)^{3/2}}$，随着 $s$ 的增大而快速衰减。一个实际的缓解方法是在空间上进行零填充以创建一个保护区，使得 $s$ 很大（例如，为 $h$ 的几倍），在填充后的网格上进行延拓，并丢弃一个宽度与保护区相当的边界。**\n\n该陈述在很大程度上是正确的。\n1. 将基于 FFT 的过程描述为与格点求和的（周期化的）Poisson 核进行卷积是准确的。\n2. 偏差随 Poisson 核尾部变化的标度是正确的。到最近周期性镜像的距离约为域的大小 $L_x$ 或 $L_y$。因此，任何一点的偏差都受到在这些距离处评估的核的影响。衰减是迅速的，对于 $s \\gg h$，其标度近似为 $h/s^3$。给出的 $s$ 的具体几何公式有些非标准，但偏差取决于到周期性镜像距离的定性观点是正确的。\n3. 提出的缓解策略——在空间域进行零填充——是标准且最有效的方法。用零的“保护区”填充数据，有效地增加了周期 $L_x$ 和 $L_y$，从而增加了与周期性镜像的间距 $s$。这极大地减少了原始数据区域内的回卷偏差。延拓后丢弃边界是必要的，以移除受填充本身引入的人为不连续性影响的区域。\n\n结论：**正确**。\n\n**B. 在向下延拓中，高空间频率被抑制，因此周期性回卷是可忽略不计的。因此，填充是不必要的；事实上，在原始边缘使用矩形（boxcar）窗对于保持分辨率是最佳的。**\n\n这个陈述在多个基本点上是错误的。\n1. 如上所述，向下延拓应用算子 $e^{kh}$，它会*放大*而非抑制高空间频率。\n2. 由于这种放大，边界处的任何不连续性（包含显著的高频功率）其影响都将被放大。这些被放大的高频伪影的周期性回卷将是严重的，而非可忽略不计。\n3. 因此，对于向下延拓来说，填充比向上延拓更关键，以控制这些被放大的伪影。使用矩形窗（即不做任何修改）是最坏的情况，因为它会产生一个尖锐的阶跃不连续性，这注定了该过程会因极端的振铃（Gibbs 现象）和回卷误差而失败。\n\n结论：**不正确**。\n\n**C. 在进行FFT之前，应用一个平滑的切趾（例如，余弦锥形窗），使数据在边界处衰减到接近零，这样可以减少边界的不连续性，从而减少频谱泄漏和周期性镜像的影响。延拓后，将注意力限制在未锥削的内部区域可以减少边缘偏差。这对于向下延拓尤其重要，因为在向下延拓中高波数会被放大。**\n\n这个陈述是正确的，并描述了一个关键的最佳实践。\n1. 应用一个平滑的锥形窗（切趾）会迫使数据在边界处平滑地趋近于零。这使得数据的周期性延拓是连续的，从而显著减少了与人为边界跳跃相关的高频功率（即，它减轻了频谱泄漏）。\n2. 减少不连续性的频谱功率可以降低可能被周期性卷积回卷的伪影的幅度。\n3. 该方法修改了锥形区域中的数据，因此为了获得准确的结果，必须丢弃此边界，只考虑域的中心、未锥削的部分。\n4. 这个过程对于向下延拓尤其重要。通过在应用不稳定的 $e^{kh}$ 放大算子*之前*抑制边界处的人为高频成分，它有助于稳定过程并防止数值伪影的灾难性放大。\n\n结论：**正确**。\n\n**D. 在不扩大空间范围的情况下，通过在傅里叶域中进行零填充（在 $k$ 空间中插值）来增加傅里叶模式的数量，会增加有效周期长度，从而消除边缘附近的回卷偏差。**\n\n这个陈述是错误的。它混淆了在空间域填充与在频率域填充的效果。\n1. 在*傅里叶域*中进行零填充（即，在现有系数之间插入零，通常在奈奎斯特频率附近）对应于在*空间域*中进行插值。其结果是在相同的原始空间范围（$L_x \\times L_y$）内获得更密集的点网格。\n2. 此操作*不*会改变基本周期 $L_x$ 和 $L_y$。因此，它不会增加到周期性镜像的距离，也无助于减轻回卷偏差。要增加周期长度，必须在正向 FFT 之前在*空间域*进行零填充。\n\n结论：**不正确**。\n\n**E. 在边界处对数据进行镜像填充（偶延拓）可以消除调和场的虚假镜像相互作用，因为 Laplace 方程的解是偶对称的，所以周期和不再对边缘产生偏差；因此，这是一个无需丢弃边界的完整补救措施。**\n\n这个陈述是错误的。\n1. “Laplace 方程的解是偶对称的”这个主要前提是错误的。一个一般的调和函数（例如，$u(x)=x$）关于任意边界并不是偶对称的。\n2. 镜像填充（偶延拓）是一种强大的技术，它可以在周期性边界上创建函数及其一阶导数的连续性（如果实现正确），这在减少频谱泄漏方面非常有效。它等效于执行离散余弦变换（DCT）。\n3. 然而，它不是一个“完整的补救措施”。它隐含地对数据施加了一个 Neumann 边界条件（$\\partial u / \\partial n = 0$，其中 $n$ 是边界的法线）。真正的势场并不保证满足这个人为的条件。虽然通常优于零填充，但它仍然会引入伪影，并且边界附近的结果会受到这种强加的对称性的偏差影响。因此，声称它是一个“无需丢弃边界的完整补救措施”是一个严重的夸大。\n\n结论：**不正确**。",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "本章的最后一个练习将分析与实现结合起来，提供了一个全面的编码实践。我们将实现标准的基于傅里叶变换的延拓方法，并将其与一种基于小波变换的替代方法进行比较。通过这个实践，您将亲身体验不同数值方法在处理边界条件、空间局部性和计算假设方面的权衡，从而深入理解这些算法的实际性能差异。",
            "id": "3618227",
            "problem": "考虑一个在$1$维均匀网格上采样的标量势场。在一个均匀无源区域中，该标量势满足拉普拉斯方程。对于相距为 $h$ 的两个水平面之间的垂直延拓，其在空间傅里叶域中的延拓算子仅取决于水平波数的模。从拉普拉斯方程和分离变量法出发，推导水平傅里叶域中的垂直传播因子，将其表示为水平波数绝对值和延拓距离 $h$ 的函数。然后，为此算子设计一个小波域近似，方法是为每个二进小波尺度指定一个代表性波数，并对每一层应用一个与尺度相关的因子。使用正交Haar小波进行小波域实现。\n\n您的任务是编写一个完整的程序，该程序：\n- 在一个以间距 $dx$ 采样的 $N$ 个点上的一维信号上，实现三个延拓算子：\n  $1)$ “参考”傅里叶域延拓，使用大量补零（以近似自由空间边界条件），\n  $2)$ “朴素”傅里叶域延拓，使用原始长度 $N$ 的离散傅里叶变换（这会强制周期性边界），\n  $3)$ 小波域延拓，使用Haar小波，并基于每层的代表性波数应用与尺度相关的因子。\n- 通过为向下延拓情况引入一个稳定化的高波数正则化项来处理向上延拓（正 $h$）和轻度向下延拓（负 $h$），该正则化项在所有三种方法中都以其各自的谱变量形式一致地应用。\n\n推导和设计的基本依据：\n- 使用拉普拉斯方程和分离变量法来证明在水平谱域中存在指數形式的垂直传播因子。\n- 对于小波域近似，通过确定该层Haar细节的代表性频带中心，为每个二进细节层 $j$ 定义一个有效波数。使用此 $k_{\\text{eff}}(j)$ 构成与层相关的因子。该近似必须将尺度（最粗）系数视为具有零有效波数的最低频带。\n\n信号和网格规格（无量纲单位）：\n- 使用一个包含 $N = 256$ 个点、间距为 $dx = 1$ 的一维网格。设域长度为 $L = N \\, dx$，位置为 $x_n = n \\, dx$，其中 $n = 0, 1, \\dots, N-1$。\n- 构造一个合成的带限信号，作为两个高斯异常的总和，其放置方式使得其中一个靠近边界，以暴露边界处理的差异：\n  $$ f(x) = A_1 \\exp\\!\\left(-\\frac{(x - x_1)^2}{2 \\sigma_1^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(x - x_2)^2}{2 \\sigma_2^2}\\right), $$\n  其中 $A_1 = 1$，$x_1 = 0.05 L$，$\\sigma_1 = 0.02 L$，$A_2 = 0.7$，$x_2 = 0.65 L$，且 $\\sigma_2 = 0.06 L$。\n\n参考傅里叶域延拓：\n- 构造一个长度为 $N_p = p \\, N$、填充因子为 $p = 8$ 的补零数组，将原始信号放置在补零数组的中心，其余位置为零，并使用间距为 $dx$ 的离散傅里叶变换在谱域中应用垂直传播因子。然后进行逆变换，并提取长度为 $N$ 的原始中心段。\n\n朴素傅里叶域延拓：\n- 在原始长度 $N$ 上应用相同的谱域传播（即周期性边界假设）。\n\n小波域延拓：\n- 实现全深度（$\\log_2 N$ 层）的正交Haar小波变换。\n- 对于细节层 $j \\in \\{1, 2, \\dots, \\log_2 N\\}$，指定一个有效波数\n  $$ k_{\\text{eff}}(j) = \\frac{\\pi}{2^j \\, dx}. $$\n  将尺度（最粗）系数视为 $k_{\\text{eff}} = 0$。\n- 将与傅里葉域推導（来自拉普拉斯方程）中相同的关于 $k_{\\text{eff}}(j)$ 和 $h$ 的函数依赖关系应用于每一层的系数。对于向下延拓（$h  0$），使用以下形式的乘法正则化因子进行稳定化\n  $$ R(k) = \\frac{1}{1 + \\left(\\frac{|k|}{k_c}\\right)^p}, $$\n  该因子应用于傅里叶域和小波域实现，在两个域中使用相同的 $k_c$ 和 $p$ 参数。正则化仅在 $h  0$ 时激活；对于 $h \\ge 0$，设置 $R(k) = 1$。\n\n需要计算的性能指标：\n- 对于每个测试用例，与“参考”（补零）傅里葉延拓结果进行以下比较：\n  $1)$ 小波域结果的相对$\\ell_2$误差，\n  $2)$ 朴素傅里叶域结果的相对$\\ell_2$误差，\n  $3)$ 改进量，定义为朴素误差减去小波误差（正数表示小波方法更接近参考结果）。\n- 对于一个特定测试，还需报告一个关注边界的指标：前 $M = 24$ 个样本的平均绝对误差，以及边界改进量，定义为朴素边界误差减去小波边界误差。\n\n测试组：\n- 使用上面定义的固定网格和信号。评估以下四种情景：\n  $1)$ 向上延拓，$h = 10$。\n  $2)$ 向上延拓，$h = 30$。\n  $3)$ 轻度向下延拓，$h = -5$，使用 $k_c = \\frac{\\pi}{6 \\, dx}$ 和 $p = 4$。\n  $4)$ 向上延拓，$h = 15$，并报告前 $M = 24$ 个样本上的关注边界的改进量，而不是全局$\\ell_2$改进量。\n\n答案规格：\n- 所有量均为无量纲。输出中不需要物理单位。\n- 您的程序必须为上述四种情景中的每一种计算一个浮点数，该浮点数等于“性能指标”部分定义的改进量。对于情景 $1$、$2$ 和 $3$，此改进量是全局$\\ell_2$改进量；对于情景 $4$，此改进量是前 $M = 24$ 个样本上关注边界的改进量。\n- 最终输出格式：您的程序应生成单行输出，其中包含四个结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$）。不应打印任何其他文本。",
            "solution": "该问题要求推导一个势场的垂直延拓算子，并使用三种不同的数值方法进行实现：一种是采用大量补零的参考傅里葉域方法，一种是假设周期性的朴素傅里叶域方法，以及一种是使用Haar基的小波域近似方法。对于几个测试用例，将根据参考方法来评估朴素方法和小波方法的性能。\n\n### 1. 垂直延拓算子的推导\n\n一个二维均匀无源区域 $(x, z)$ 中的标量势场 $\\Phi$ 满足拉普拉斯方程：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial z^2} = 0\n$$\n这里，$x$ 是水平坐标，$z$ 是垂直坐标。我们试图使用分离变量法寻找解，假设解的形式为 $\\Phi(x, z) = X(x)Z(z)$。将其代入拉普拉斯方程并重新整理后得到：\n$$\n\\frac{1}{X(x)}\\frac{d^2 X}{dx^2} = -\\frac{1}{Z(z)}\\frac{d^2 Z}{dz^2}\n$$\n由于左侧仅依赖于 $x$，右侧仅依赖于 $z$，因此两侧都必须等于一个常数，我们将其记为 $-k^2$。这产生了两个常微分方程：\n$$\n\\frac{d^2 X}{dx^2} + k^2 X(x) = 0 \\quad \\implies \\quad X(x) \\propto e^{\\pm i k x}\n$$\n$$\n\\frac{d^2 Z}{dz^2} - k^2 Z(z) = 0 \\quad \\implies \\quad Z(z) \\propto e^{\\pm k z}\n$$\n垂直依赖关系的一般解是 $Z(z) = C e^{kz} + D e^{-kz}$。然而，由于 $k$ 在分离常数中以 $k^2$ 的形式出现，因此 $z$ 的依赖关系必须是水平波数 $|k|$ 大小的函数。更普遍地，垂直依赖关系的解可以写成 $Z(z) \\propto e^{\\pm |k| z}$。\n\n我们假设势源位于 $z  0$，并且在平面 $z=0$ 上测量场。对于向上延拓，我们关心的是 $z  0$ 区域的场。势场必须保持有界，并在 $z \\to \\infty$ 时衰减到零。这一物理约束要求我们舍弃指数增长项 $e^{|k|z}$，只保留衰减项 $e^{-|k|z}$。\n\n因此，势场的单个谐波分量具有 $\\Phi_k(x, z) \\propto e^{ikx} e^{-|k|z}$ 的形式。完整的势是所有这些分量的叠加（积分）。如果我们对势场关于水平坐标 $x$ 进行空间傅里葉变换（记为 $\\mathcal{F}$），我们得到：\n$$\n\\hat{\\Phi}(k, z) = \\mathcal{F}\\{\\Phi(x,z)\\}\n$$\n从分离变量得到的解，场在两个不同高度（例如 $z=0$ 和 $z=h$）的频谱之间的关系是：\n$$\n\\hat{\\Phi}(k, h) = \\hat{\\Phi}(k, 0) e^{-|k|h}\n$$\n因子 $P(k, h) = e^{-|k|h}$ 是水平傅里叶域中的**垂直传播因子**。\n- 对于**向上延拓**（$h  0$），该因子是一个低通滤波器，衰减高波数分量。这是一个稳定的操作，反映了场的细节会随着距离的增加而被平滑掉的物理现实。\n- 对于**向下延拓**（$h  0$），因子变为 $e^{|k|(-h)}$，它会放大高波数分量。这使得该过程成为一个不适定的反问题，对噪声高度敏感。为了稳定它，需要一个正则化滤波器。按照规定，我们使用一个 Tikhonov 风格的滤波器：\n$$\nR(k) = \\frac{1}{1 + \\left(\\frac{|k|}{k_c}\\right)^p}\n$$\n其中 $k_c$ 是一个截止波数，$p$ 控制截止的陡峭程度。向下延拓的完整算子是 $P(k, h) R(k)$ 的乘积。对于向上延拓，$R(k) = 1$。\n\n### 2. 数值实现策略\n\n我们的任务是实现三种方法在离散网格上应用此算子。\n\n**参考傅里叶域方法：**\n离散傅里叶变换（DFT）内在地假设信号是周期性的。这在应用滤波器时可能导致环绕伪影（混叠），特别是如果信号在其边界处不接近于零。为了近似非周期性的自由空间情景，将信号嵌入一个大得多的零数组的中心。这种补零操作有效地将信号与其周期性镜像隔离开来。其步骤如下：\n1.  创建一个长度为 $N_p = p \\cdot N$（其中 $p=8$）的补零数组，并将长度为 $N$ 的原始信号置于其中心。\n2.  计算补零信号的DFT。\n3.  为对应于补零长度 $N_p$ 的波数 $k$ 计算传播算子 $e^{-|k|h}$。\n4.  将变换后的信号与算子相乘。\n5.  计算逆DFT。\n6.  提取结果数组的中心部分，该部分对应于原始信号的域。\n\n**朴素傅里叶域方法：**\n此方法忽略边界效应，直接对长度为 $N$ 的原始未补零信号应用DFT。步骤与参考方法相同，但 $p=1$（即不补零）。这种方法计算效率高，但会受环绕伪影的影响，特别是对于在边界附近有显著振幅的信号。\n\n**小波域方法：**\n该方法在补零傅里叶方法的准确性和朴素方法的效率之间提供了一种折衷。离散小波变换（DWT）将信号分解为在空间和尺度（频率）上都局部化的分量。该近似基于对给定尺度的所有系数应用单个延拓因子。\n1.  **分解**：对长度为 $N=2^J$ 的信号递归应用正交Haar DWT，为每个层级 $j$ 产生一组近似（尺度）系数 $a_J$（1个系数）和细节系数 $\\{d_j\\}_{j=1}^J$。层级 $d_j$ 包含 $2^{J-j}$ 个系数。\n2.  **尺度相关滤波**：为每个小波层级分配一个代表性波数。\n    - 对于层级 $j$ 的细节系数 $d_j$，其捕捉了大约 $2^j dx$ 尺度上的变化，有效波数为 $k_{\\text{eff}}(j) = \\frac{\\pi}{2^j dx}$。\n    - 对于代表信号直流分量或均值的最粗尺度系数 $a_J$，有效波数为 $k_{\\text{eff}} = 0$。\n3.  传播算子（包括 $h0$ 时的正则化）在此 $k_{\\text{eff}}(j)$ 处求值，并作为乘法因子应用于相应层级 $d_j$ 中的所有系数。尺度系数 $a_J$ 乘以在 $k=0$ 处的算子，其值为 $1$。\n4.  **重构**：使用逆DWT从修改后的系数重构信号。\n\n由于小波是空间局部化的，预计此方法能比朴素DFT更好地处理信号边界，减少环绕伪影，而无需大量补零。\n\n### 3. 性能评估\n\n比较是相对于补零傅里叶方法进行的，该方法被视为“基准真相”或参考解。关键指标是：\n- **相对 $\\ell_2$ 误差**：$\\frac{\\|\\mathbf{y}_{\\text{method}} - \\mathbf{y}_{\\text{ref}}\\|_2}{\\|\\mathbf{y}_{\\text{ref}}\\|_2}$，其中 $\\mathbf{y}$ 是延拓后的信号向量。\n- **平均绝对边界误差**：$\\frac{1}{M}\\sum_{n=0}^{M-1} |y_{\\text{method}, n} - y_{\\text{ref}, n}|$，关注前 $M$ 个样本。\n- **改进量**：主要输出是小波方法相对于朴素傅里叶方法的改进量，定义为它们各自误差的差值：$\\text{改进量} = \\text{误差}_{\\text{朴素}} - \\text{误差}_{\\text{小波}}$。正值表示小波方法是参考解的更好近似。",
            "answer": "```python\nimport numpy as np\n\ndef dwt_one_level(s):\n    \"\"\"Performs one level of the orthonormal Haar 1D DWT.\"\"\"\n    if len(s) % 2 != 0:\n        raise ValueError(\"Signal length must be a power of 2.\")\n    s_even = s[0::2]\n    s_odd = s[1::2]\n    sqrt2_inv = 1.0 / np.sqrt(2.0)\n    a = (s_even + s_odd) * sqrt2_inv\n    d = (s_even - s_odd) * sqrt2_inv\n    return a, d\n\ndef dwt_full(signal):\n    \"\"\"Performs a full multi-level orthonormal Haar 1D DWT.\"\"\"\n    coeffs = []\n    a = signal.copy()\n    num_levels = int(np.log2(len(a)))\n    for _ in range(num_levels):\n        a, d = dwt_one_level(a)\n        coeffs.insert(0, d)\n    coeffs.insert(0, a) # Final list is [a_J, d_J, d_{J-1}, ..., d_1]\n    return coeffs\n\ndef idwt_one_level(a, d):\n    \"\"\"Performs one level of the orthonormal Haar 1D IDWT.\"\"\"\n    if len(a) != len(d):\n        raise ValueError(\"Approximation and detail coeffs must have the same length.\")\n    sqrt2_inv = 1.0 / np.sqrt(2.0)\n    s = np.zeros(len(a) * 2)\n    s[0::2] = (a + d) * sqrt2_inv\n    s[1::2] = (a - d) * sqrt2_inv\n    return s\n\ndef idwt_full(coeffs):\n    \"\"\"Performs a full multi-level orthonormal Haar 1D IDWT.\"\"\"\n    # coeffs list is [a_J, d_J, ..., d_1]\n    a = coeffs[0]\n    for i in range(1, len(coeffs)):\n        d = coeffs[i]\n        a = idwt_one_level(a, d)\n    return a\n\ndef fourier_continuation(signal, h, dx, p_pad, kc, p_reg):\n    \"\"\"\n    Performs vertical continuation in the Fourier domain.\n    p_pad=1 for naive method, p_pad  1 for reference (padded) method.\n    \"\"\"\n    N = len(signal)\n    Np = N * p_pad\n\n    if p_pad  1:\n        padded_signal = np.zeros(Np, dtype=float)\n        start = (Np - N) // 2\n        padded_signal[start:start + N] = signal\n        signal_to_transform = padded_signal\n    else:\n        signal_to_transform = signal\n\n    F = np.fft.fft(signal_to_transform)\n    k = 2.0 * np.pi * np.fft.fftfreq(Np, d=dx)\n\n    # Propagation factor\n    prop_factor = np.exp(-np.abs(k) * h)\n\n    # Regularization factor (only for downward continuation)\n    if h  0:\n        # To avoid division by zero for k=0 if kc=0 (though problem has kc  0)\n        with np.errstate(divide='ignore', invalid='ignore'):\n            reg_factor = 1.0 / (1.0 + (np.abs(k) / kc)**p_reg)\n        reg_factor[np.isinf(reg_factor)] = 0 # Handle cases of large k\n        reg_factor[np.isnan(reg_factor)] = 1 # Handle k=0 case\n    else:\n        reg_factor = np.ones_like(k)\n        \n    operator = prop_factor * reg_factor\n    F_continued = F * operator\n    continued_signal_padded = np.fft.ifft(F_continued).real\n\n    if p_pad  1:\n        start = (Np - N) // 2\n        return continued_signal_padded[start:start + N]\n    else:\n        return continued_signal_padded\n\ndef wavelet_continuation(signal, h, dx, kc, p_reg):\n    \"\"\"Performs vertical continuation in the Haar wavelet domain.\"\"\"\n    N = len(signal)\n    J = int(np.log2(N))\n    \n    # Forward DWT\n    coeffs = dwt_full(signal)\n    \n    modified_coeffs = []\n    \n    # Process scaling coefficient (a_J): k_eff=0, operator=1, so no change\n    modified_coeffs.append(coeffs[0]) \n    \n    # Process detail coefficients (d_j for j=J..1)\n    # The coeffs list is [a_J, d_J, ..., d_1]\n    for i in range(1, J + 1):\n        # Level j corresponds to index i in the list. j = J - i + 1\n        j = J - i + 1\n        d_level = coeffs[i]\n        \n        k_eff = np.pi / (2**j * dx)\n        \n        # Propagation factor\n        prop_factor = np.exp(-k_eff * h)\n        \n        # Regularization factor\n        if h  0:\n            reg_factor = 1.0 / (1.0 + (k_eff / kc)**p_reg)\n        else:\n            reg_factor = 1.0\n        \n        operator = prop_factor * reg_factor\n        d_level_mod = d_level * operator\n        modified_coeffs.append(d_level_mod)\n    \n    # Inverse DWT\n    reconstructed_signal = idwt_full(modified_coeffs)\n    return reconstructed_signal\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute performance metrics.\n    \"\"\"\n    # Signal and grid specification\n    N = 256\n    dx = 1.0\n    L = N * dx\n    x = np.arange(N) * dx\n\n    # Synthetic signal parameters\n    A1 = 1.0\n    x1 = 0.05 * L\n    sigma1 = 0.02 * L\n    A2 = 0.7\n    x2 = 0.65 * L\n    sigma2 = 0.06 * L\n\n    # Construct the signal\n    signal = A1 * np.exp(-(x - x1)**2 / (2.0 * sigma1**2)) + \\\n             A2 * np.exp(-(x - x2)**2 / (2.0 * sigma2**2))\n\n    # General configuration\n    p_pad = 8\n    M_boundary = 24\n\n    # Test suite\n    test_cases = [\n        {'h': 10.0, 'kc': None, 'p_reg': None, 'metric': 'global_improvement'},\n        {'h': 30.0, 'kc': None, 'p_reg': None, 'metric': 'global_improvement'},\n        {'h': -5.0, 'kc': np.pi / (6.0 * dx), 'p_reg': 4.0, 'metric': 'global_improvement'},\n        {'h': 15.0, 'kc': None, 'p_reg': None, 'metric': 'boundary_improvement'},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        h = case['h']\n        kc = case['kc']\n        p_reg = case['p_reg']\n\n        # 1. Reference (zero-padded Fourier) continuation\n        ref_res = fourier_continuation(signal, h, dx, p_pad, kc, p_reg)\n        \n        # 2. Naive (periodic Fourier) continuation\n        nai_res = fourier_continuation(signal, h, dx, 1, kc, p_reg)\n        \n        # 3. Wavelet-domain continuation\n        wav_res = wavelet_continuation(signal, h, dx, kc, p_reg)\n\n        if case['metric'] == 'global_improvement':\n            norm_ref = np.linalg.norm(ref_res)\n            # Avoid division by zero if reference signal is all-zero\n            if norm_ref == 0:\n                err_wav = np.linalg.norm(wav_res - ref_res)\n                err_nai = np.linalg.norm(nai_res - ref_res)\n            else:\n                err_wav = np.linalg.norm(wav_res - ref_res) / norm_ref\n                err_nai = np.linalg.norm(nai_res - ref_res) / norm_ref\n            \n            improvement = err_nai - err_wav\n            results.append(improvement)\n            \n        elif case['metric'] == 'boundary_improvement':\n            err_wav_boundary = np.mean(np.abs(wav_res[:M_boundary] - ref_res[:M_boundary]))\n            err_nai_boundary = np.mean(np.abs(nai_res[:M_boundary] - ref_res[:M_boundary]))\n            \n            improvement = err_nai_boundary - err_wav_boundary\n            results.append(improvement)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}