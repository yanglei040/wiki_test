{
    "hands_on_practices": [
        {
            "introduction": "任何复杂的地球物理模型都始于其基本构建模块。此练习旨在通过实现基于体素的数值求积来计算三维质量分布产生的引力位，从而构建重力正演模拟的核心引擎。您不仅将学习如何为笛卡尔（Cartesian）网格和球楔（tesseroid）网格离散化引力积分，还将接触到一个关键的科学计算概念：使用 Lipschitz 连续性来估算数值误差 。这个实践对于理解数值解的精度和可靠性至关重要，是评估任何计算模型质量的基础。",
            "id": "3601769",
            "problem": "您需要实现一个完整的程序，该程序使用简单的基于体素的数值求积方法，计算三维质量分布在某一点产生的牛頓引力势，并通过调用密度的 Lipschitz 连续性界和核函数梯度的界来估计求积误差的上限。\n\n这个问题的基础是由以下积分定义的牛顿引力势：\n$$\nV(\\mathbf{x}) \\;=\\; G \\int_{\\Omega} \\frac{\\rho(\\mathbf{y})}{\\lVert \\mathbf{x} - \\mathbf{y} \\rVert} \\, \\mathrm{d}^3\\mathbf{y},\n$$\n其中 $G$ 是引力常数，$\\rho$ 是质量密度，$\\mathbf{x}$ 是观测点，$\\Omega$ 是质量分布的支撑域。请使用国际单位制 (SI)：$G$ 的单位为 $\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$，空间坐标单位为 $\\mathrm{m}$，质量密度单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，并以 $\\mathrm{m}^2\\,\\mathrm{s}^{-2}$ 为单位报告引力势 $V(\\mathbf{x})$ 及其误差界。\n\n您的数值求积必须使用体素（三维多面体）离散化：\n- 将域 $\\Omega$ 划分成不相交的体素 $V_j$（可以是笛卡尔长方体，也可以是球面经度-纬度-半径 tesseroid）。对每个体素 $V_j$，用其质心 $\\mathbf{c}_j$ 处的值来近似被积函数，并用 $G \\, \\rho(\\mathbf{c}_j) \\, \\lVert \\mathbf{x} - \\mathbf{c}_j \\rVert^{-1} \\, \\mathrm{Vol}(V_j)$ 来近似该体素的积分贡献，其中 $\\mathrm{Vol}(V_j)$ 是体素的体积。\n\n为估计绝对求积误差，假设：\n- 密度 $\\rho$ 是 Lipschitz 连续的，其全局 Lipschitz 常数 $L_\\rho$ 已知，即对所有 $\\mathbf{y}, \\mathbf{z} \\in \\Omega$ 都有 $\\lvert \\rho(\\mathbf{y}) - \\rho(\\mathbf{z}) \\rvert \\le L_\\rho \\lVert \\mathbf{y} - \\mathbf{z} \\rVert$。\n- 密度在 $\\Omega$ 上有一个已知的全局上确界 $\\rho_{\\max}$。\n- 牛顿核 $K(\\mathbf{x},\\mathbf{y}) = G \\, \\lVert \\mathbf{x}-\\mathbf{y} \\rVert^{-1}$ 关于 $\\mathbf{y}$ 的梯度为 $\\nabla_{\\mathbf{y}} K(\\mathbf{x},\\mathbf{y})$，其范数为 $\\lVert \\nabla_{\\mathbf{y}} K(\\mathbf{x},\\mathbf{y}) \\rVert = G \\, \\lVert \\mathbf{x}-\\mathbf{y} \\rVert^{-2}$。\n\n对每个体素 $V_j$，设 $r_{\\max,j}$ 表示 $\\mathbf{y} \\in V_j$ 时 $\\lVert \\mathbf{y} - \\mathbf{c}_j \\rVert$ 的一个上界（对于笛卡尔长方体，取 $r_{\\max,j}$ 为空间对角线长度的一半；对于 tesseroid，使用由局部弧长和径向长度构成的等效空间对角线长度的一半）。设 $d_{\\min,j}$ 为从观测点 $\\mathbf{x}$ 到 $V_j$ 中任意点的最小距离的一个保守下界（您可以使用 $d_{\\min,j} = \\max(\\lVert \\mathbf{x}-\\mathbf{c}_j \\rVert - r_{\\max,j}, \\varepsilon)$，其中 $\\varepsilon$ 是一个小的正数以避免除以零，请注意当 $\\mathbf{x}$ 在 $V_j$ 之外时这是一个保守估计）。使用这些界，定义\n$$\nK_{\\sup,j} \\;=\\; \\frac{G}{d_{\\min,j}}, \\qquad M_{K,j} \\;=\\; \\frac{G}{d_{\\min,j}^2}.\n$$\n体素 $V_j$ 贡献的绝对误差则有上界\n$$\nE_j \\;\\le\\; \\mathrm{Vol}(V_j) \\, r_{\\max,j} \\, \\big( L_\\rho \\, K_{\\sup,j} \\;+\\; \\rho_{\\max} \\, M_{K,j} \\big),\n$$\n总误差界为\n$$\nE \\;=\\; \\sum_j E_j.\n$$\n\n使用以下密度函数：\n$$\n\\rho(\\mathbf{y}) \\;=\\; \\rho_0 \\;+\\; A \\, \\sin(\\omega \\, y_x) \\, \\sin(\\omega \\, y_y) \\, \\sin(\\omega \\, y_z),\n$$\n其中 $\\mathbf{y} = (y_x, y_y, y_z)$，$\\rho_0$ 是基线密度，$A$ 是振幅，$\\omega$ 是空间角频率。对于此密度函数 $\\rho$，一个有效的全局上确界是 $\\rho_{\\max} = \\rho_0 + A$，一个有效的全局 Lipschitz 常数是 $L_\\rho = A \\, \\omega \\, \\sqrt{3}$。\n\n实现笛卡尔长方体体素和球面 tesseroid 两种情况：\n- 笛卡尔长方体：将一个矩形域沿 $x, y, z$ 方向均匀划分为 $N_x \\times N_y \\times N_z$ 个体素。每个长方体 $V_j$ 的体积为 $\\mathrm{Vol}(V_j) = \\Delta x \\, \\Delta y \\, \\Delta z$，质心位于中心，且 $r_{\\max,j} = \\tfrac{1}{2}\\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$。\n- Tesseroid：将一个由经度 $\\lambda \\in [\\lambda_{\\min}, \\lambda_{\\max}]$、纬度 $\\phi \\in [\\phi_{\\min}, \\phi_{\\max}]$ 和半径 $r \\in [r_{\\min}, r_{\\max}]$ 定义的球块，沿 $\\lambda$、$\\phi$（以弧度为单位）和 $r$ 方向均匀划分为 $N_\\lambda \\times N_\\phi \\times N_r$ 个 tesseroid。对每个 tesseroid，体积近似为 $\\mathrm{Vol}(V_j) \\approx r_{\\mathrm{mid}}^2 \\, \\cos\\phi_{\\mathrm{mid}} \\, \\Delta\\lambda \\, \\Delta\\phi \\, \\Delta r$，质心位于 $(r_{\\mathrm{mid}}, \\phi_{\\mathrm{mid}}, \\lambda_{\\mathrm{mid}})$，使用 $x = r \\cos\\phi \\cos\\lambda$, $y = r \\cos\\phi \\sin\\lambda$, $z = r \\sin\\phi$ 将质心转换为笛卡尔坐标，并用 $\\tfrac{1}{2}\\sqrt{(r_{\\mathrm{mid}} \\cos\\phi_{\\mathrm{mid}} \\Delta\\lambda)^2 + (r_{\\mathrm{mid}} \\Delta\\phi)^2 + (\\Delta r)^2}$ 近似 $r_{\\max,j}$。\n\n计算中角度必须以弧度为单位。如果参数以度为单位提供，应在内部将其转换为弧度。\n\n使用以下常量：\n- 引力常数 $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。\n- 密度参数：$\\rho_0 = 2000 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$A = 500 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\omega = \\frac{2\\pi}{1000} \\, \\mathrm{rad}\\,\\mathrm{m}^{-1}$。\n- 因此，$\\rho_{\\max} = 2500 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$，$L_\\rho = 500 \\cdot \\frac{2\\pi}{1000} \\cdot \\sqrt{3} \\, \\mathrm{kg}\\,\\mathrm{m}^{-4}$。\n\n您的程序必须针对以下四个测试用例实现求积计算，并按文末指定的精确格式生成所要求的输出。\n\n测试套件：\n- 案例 1 (笛卡尔长方体，正常路径)：$\\Omega = [0,1000] \\times [0,1000] \\times [0,1000]$ 单位为 $\\mathrm{m}$，$N_x = 10$, $N_y = 10$, $N_z = 10$，观测点 $\\mathbf{x} = (500, 500, 1500)$ 单位为 $\\mathrm{m}$。\n- 案例 2 (笛卡尔长方体，加密网格)：$\\Omega$ 与案例 1 相同，$N_x = 20$, $N_y = 20$, $N_z = 20$，观测点 $\\mathbf{x} = (500, 500, 1500)$ 单位为 $\\mathrm{m}$。\n- 案例 3 (笛卡尔长方体，近场边界情况)：$\\Omega$ 与案例 1 相同，$N_x = 10$, $N_y = 10$, $N_z = 10$，观测点 $\\mathbf{x} = (500, 500, 1010)$ 单位为 $\\mathrm{m}$。\n- 案例 4 (Tesseroid，近地表球块)：球块，地球平均半径 $R_{\\mathrm{E}} = 6.371 \\times 10^{6} \\, \\mathrm{m}$，经度区间 $[0^\\circ, 0.5^\\circ]$，纬度区间 $[0^\\circ, 0.5^\\circ]$，半径区间 $[R_{\\mathrm{E}}, R_{\\mathrm{E}} + 1000]$ 单位为 $\\mathrm{m}$，tesseroid 数量 $N_\\lambda = 10$, $N_\\phi = 10$, $N_r = 10$。观测点位于纬度 $0.25^\\circ$，经度 $0.25^\\circ$，半径 $R_{\\mathrm{E}} + 2000 \\, \\mathrm{m}$。在内部将角度从度转换为弧度。\n\n输出规格：\n- 对每个案例，计算基于体素的求积估计值 $V(\\mathbf{x})$（单位 $\\mathrm{m}^2\\,\\mathrm{s}^{-2}$）和总误差界 $E$（单位 $\\mathrm{m}^2\\,\\mathrm{s}^{-2}$）。\n- 您的程序应生成单行输出，其中包含按案例顺序排列的结果列表，每个内部列表为 $[V,E]$，两个条目均为十进制浮点数。例如：$[[v_1,e_1],[v_2,e_2],[v_3,e_3],[v_4,e_4]]$。",
            "solution": "用户在计算地球物理学领域提供了一个定义明确的问题。我的任务是实现一个程序，使用基于体素的求积方法，为两种类型的体素几何形状（笛卡尔长方体和球面tesseroid）计算牛顿引力势，并估计相关的数值误差。\n\n### 问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n**第 1 步：提取已知条件**\n\n- **基本方程**：引力势 $V(\\mathbf{x})$ 由体积积分 $V(\\mathbf{x}) = G \\int_{\\Omega} \\frac{\\rho(\\mathbf{y})}{\\lVert \\mathbf{x} - \\mathbf{y} \\rVert} \\, \\mathrm{d}^3\\mathbf{y}$ 给出。\n- **数值近似**：在一个体素 $V_j$ 上的积分近似为 $G \\, \\rho(\\mathbf{c}_j) \\, \\lVert \\mathbf{x} - \\mathbf{c}_j \\rVert^{-1} \\, \\mathrm{Vol}(V_j)$，其中 $\\mathbf{c}_j$ 是体素的质心。\n- **误差估计**：一个体素 $V_j$ 的绝对误差上界为 $E_j \\le \\mathrm{Vol}(V_j) \\, r_{\\max,j} \\, ( L_\\rho \\, K_{\\sup,j} + \\rho_{\\max} \\, M_{K,j} )$。\n  - $K_{\\sup,j} = G/d_{\\min,j}$ 且 $M_{K,j} = G/d_{\\min,j}^2$。\n  - $d_{\\min,j} = \\max(\\lVert \\mathbf{x}-\\mathbf{c}_j \\rVert - r_{\\max,j}, \\varepsilon)$，其中 $\\varepsilon$ 是一个小的正数。\n- **密度函数**：$\\rho(\\mathbf{y}) = \\rho_0 + A \\sin(\\omega y_x) \\sin(\\omega y_y) \\sin(\\omega y_z)$。\n- **常量和参数**：\n  - $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。\n  - $\\rho_0 = 2000 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$, $A = 500 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\omega = \\frac{2\\pi}{1000} \\, \\mathrm{rad}\\,\\mathrm{m}^{-1}$。\n  - $\\rho_{\\max} = \\rho_0 + A = 2500 \\, \\mathrm{kg}\\,\\mathrm{m}^{-3}$。\n  - $L_\\rho = A \\, \\omega \\, \\sqrt{3} \\, \\mathrm{kg}\\,\\mathrm{m}^{-4}$。\n- **体素几何形状**：\n  - **笛卡尔长方体**：$\\mathrm{Vol}(V_j) = \\Delta x \\Delta y \\Delta z$ 且 $r_{\\max,j} = \\frac{1}{2}\\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$。\n  - **Tesseroid**：$\\mathrm{Vol}(V_j) \\approx r_{\\mathrm{mid}}^2 \\cos\\phi_{\\mathrm{mid}} \\Delta\\lambda \\Delta\\phi \\Delta r$ 且 $r_{\\max,j} \\approx \\frac{1}{2}\\sqrt{(r_{\\mathrm{mid}} \\cos\\phi_{\\mathrm{mid}} \\Delta\\lambda)^2 + (r_{\\mathrm{mid}} \\Delta\\phi)^2 + (\\Delta r)^2}$。球坐标到笛卡尔坐标转换：$x = r \\cos\\phi \\cos\\lambda$, $y = r \\cos\\phi \\sin\\lambda$, $z = r \\sin\\phi$。\n- **测试用例**：提供了四个具体案例，两个用于笛卡尔网格，另外两个分别涉及近场观测点和 tesseroid 网格。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n- **科学依据充分**：该问题基于牛顿引力的经典理论。数值方法（求积）和误差分析（使用 Lipschitz 连续性以及核函数及其梯度的界）是数值分析和计算物理学中的标准、成熟的技术。\n- **良构的**：问题被完全指定。所有必需的常量、方程、几何定义和测试用例参数都已提供。目标——计算引力势和误差界——是精确的。所提供的公式对于每个案例都会产生唯一的结果。\n- **目标明確**：问题陈述使用清晰、无歧义的数学和物理语言来表述。\n\n**第 3 步：结论和行动**\n\n问题被判定为有效。它在科学上是合理的、良构的、目标明确的，并且包含了计算唯一解所需的足够信息。我现在将开始解决该问题。\n\n### 基于原则的解决方案设计\n\n问题的核心是对大量离散体积元素（体素）求和的数值实现。我将设计一个结构化程序，将两种不同体素几何形状的计算模块化。\n\n**1. 常量和共享函数：**\n我将首先定义问题陈述中提供的所有物理和数学常量（$G, \\rho_0, A, \\omega, \\rho_{\\max}, L_\\rho$）。密度函数 $\\rho(\\mathbf{y})$ 将被实现为一个独立的函数，它接受一个笛卡尔坐标向量。将定义一个小常量 $\\varepsilon$ 用于规范化最小距离的计算。\n\n**2. 笛卡尔长方体计算 (`compute_cartesian`)：**\n此函数将处理笛卡尔网格的情况。\n- **输入**：域边界 $(x_{\\min}, x_{\\max})$ 等，划分数 $(N_x, N_y, N_z)$，以及观测点的笛卡尔坐标 $\\mathbf{x}_{\\text{obs}}$。\n- **初始化**：总势能 $V$ 和总误差界 $E$ 初始化为 $0$。\n- **体素参数**：边长 $(\\Delta x, \\Delta y, \\Delta z)$、体积 $\\mathrm{Vol}$ 和最大内部半径 $r_{\\max}$ 将被预先计算，因为对于均匀网格中的所有体素，它们都是恒定的。\n- **迭代**：代码将使用三个嵌套循环对 $x, y, z$ 索引进行迭代，遍历每个体素。\n- **每个体素的计算**：在循环内部，对每个体素：\n    1. 计算体素质心 $\\mathbf{c}_j$ 的笛卡尔坐标。\n    2. 计算密度 $\\rho(\\mathbf{c}_j)$。\n    3. 计算欧氏距离 $d_j = \\lVert \\mathbf{x}_{\\text{obs}} - \\mathbf{c}_j \\rVert$。\n    4. 计算势能贡献 $V_j = G \\cdot \\rho(\\mathbf{c}_j) \\cdot \\mathrm{Vol} / d_j$ 并加到总势能 $V$ 中。\n    5. 确定到体素的最小距离 $d_{\\min,j} = \\max(d_j - r_{\\max}, \\varepsilon)$。\n    6. 计算核函数的界 $K_{\\sup,j} = G/d_{\\min,j}$ 及其梯度的界 $M_{K,j} = G/d_{\\min,j}^2$。\n    7. 计算误差贡献 $E_j = \\mathrm{Vol} \\cdot r_{\\max} \\cdot (L_\\rho K_{\\sup,j} + \\rho_{\\max} M_{K,j})$ 并加到总误差界 $E$ 中。\n- **输出**：函数返回一个数对 $[V, E]$。\n\n**3. Tesseroid 计算 (`compute_tesseroid`)：**\n此函数将处理球面 tesseroid 网格的情况。\n- **输入**：球面域边界 $(\\lambda_{\\min}, \\lambda_{\\max})$ 等（单位为度），划分数 $(N_\\lambda, N_\\phi, N_r)$，以及观测点的球坐标 $\\mathbf{x}_{\\text{obs, sph}}$（经纬度单位为度；半径单位为米）。\n- **坐标转换**：所有输入角度（域边界和观测点位置）都将从度转换为弧度。观测点的球坐标将转换为笛卡尔坐标 $\\mathbf{x}_{\\text{obs, cart}}$。\n- **初始化**：总势能 $V$ 和误差界 $E$ 设置为 $0$。\n- **体素参数**：计算均匀步长 $(\\Delta\\lambda, \\Delta\\phi, \\Delta r)$。\n- **迭代**：代码将使用三个嵌套循环对 $\\lambda, \\phi, r$ 索引进行迭代，遍历每个 tesseroid。\n- **每个体素的计算**：在循环内部，对每个 tesseroid：\n    1. 确定质心的球坐标 $(\\lambda_{\\mathrm{mid}}, \\phi_{\\mathrm{mid}}, r_{\\mathrm{mid}})$。\n    2. 使用提供的公式计算近似体积 $\\mathrm{Vol}_j$ 和最大内部半径 $r_{\\max,j}$，这些公式依赖于质心的位置。\n    3. 将质心的球坐标转换为笛卡尔坐标 $\\mathbf{c}_j$。\n    4. 在笛卡尔质心处计算密度 $\\rho(\\mathbf{c}_j)$。\n    5. 计算距离 $d_j = \\lVert \\mathbf{x}_{\\text{obs, cart}} - \\mathbf{c}_j \\rVert$。\n    6. 将势能贡献 $V_j = G \\cdot \\rho(\\mathbf{c}_j) \\cdot \\mathrm{Vol}_j / d_j$ 加到 $V$ 中。\n    7. 类似于笛卡尔情况，计算最小距离 $d_{\\min,j} = \\max(d_j - r_{\\max,j}, \\varepsilon)$、核函数界 $K_{\\sup,j}$、$M_{K,j}$ 和误差贡献 $E_j$，并进行累加。\n- **输出**：函数返回一个数对 $[V, E]$。\n\n**4. 主执行块：**\n主脚本将把测试用例定义为一个元组或字典的列表，其中包含所有必需的参数。然后它将遍历此列表，为每个案例调用适当的函数（`compute_cartesian` 或 `compute_tesseroid`）。结果将被收集并格式化为指定的字符串 `[[v1,e1],[v2,e2],...]` 作为最终输出。`numpy` 库将用于提高数值效率和清晰度，尤其是在向量运算和数学常量方面。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational potential and its error bound for a 3D mass\n    distribution using voxel-based numerical quadrature.\n    \"\"\"\n    #\n    # Step 1: Define Constants and Shared Functions\n    #\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    R_E = 6.371e6      # Earth mean radius in m\n\n    # Density function parameters\n    RHO_0 = 2000.0   # kg m^-3\n    A = 500.0        # kg m^-3\n    OMEGA = (2 * np.pi) / 1000.0  # rad m^-1\n\n    # Derived density bounds\n    RHO_MAX = RHO_0 + A\n    L_RHO = A * OMEGA * np.sqrt(3)\n\n    # Small epsilon to prevent division by zero\n    EPSILON = 1e-9\n\n    def rho(y):\n        \"\"\"Density function rho(y) in kg m^-3.\"\"\"\n        yx, yy, yz = y\n        return RHO_0 + A * np.sin(OMEGA * yx) * np.sin(OMEGA * yy) * np.sin(OMEGA * yz)\n\n    def spherical_to_cartesian(lon_rad, lat_rad, r):\n        \"\"\"Converts spherical coordinates (lon, lat, r) to Cartesian (x, y, z).\"\"\"\n        x = r * np.cos(lat_rad) * np.cos(lon_rad)\n        y = r * np.cos(lat_rad) * np.sin(lon_rad)\n        z = r * np.sin(lat_rad)\n        return np.array([x, y, z])\n\n    #\n    # Step 2: Implement Quadrature for Cartesian Cuboids\n    #\n    def compute_cartesian(domain, N, x_obs):\n        \"\"\"\n        Computes potential and error for a Cartesian grid.\n        \n        Args:\n            domain (dict): {'x': (min, max), 'y': (min, max), 'z': (min, max)}\n            N (tuple): (Nx, Ny, Nz) number of divisions\n            x_obs (np.ndarray): Observation point coordinates\n        \"\"\"\n        x_min, x_max = domain['x']\n        y_min, y_max = domain['y']\n        z_min, z_max = domain['z']\n        Nx, Ny, Nz = N\n\n        dx = (x_max - x_min) / Nx\n        dy = (y_max - y_min) / Ny\n        dz = (z_max - z_min) / Nz\n\n        vol = dx * dy * dz\n        r_max = 0.5 * np.sqrt(dx**2 + dy**2 + dz**2)\n\n        total_potential = 0.0\n        total_error = 0.0\n\n        for i in range(Nx):\n            cx = x_min + (i + 0.5) * dx\n            for j in range(Ny):\n                cy = y_min + (j + 0.5) * dy\n                for k in range(Nz):\n                    cz = z_min + (k + 0.5) * dz\n                    centroid = np.array([cx, cy, cz])\n                    \n                    # Potential calculation\n                    dist_to_centroid = np.linalg.norm(x_obs - centroid)\n                    total_potential += G * rho(centroid) * vol / dist_to_centroid\n\n                    # Error bound calculation\n                    d_min = max(dist_to_centroid - r_max, EPSILON)\n                    K_sup = G / d_min\n                    M_K = G / (d_min**2)\n                    \n                    error_contrib = vol * r_max * (L_RHO * K_sup + RHO_MAX * M_K)\n                    total_error += error_contrib\n        \n        return [total_potential, total_error]\n\n    #\n    # Step 3: Implement Quadrature for Tesseroids\n    #\n    def compute_tesseroid(domain_sph, N_sph, x_obs_sph):\n        \"\"\"\n        Computes potential and error for a tesseroid grid.\n        \n        Args:\n            domain_sph (dict): {'lon': (min, max), 'lat': (min, max), 'r': (min, max)} in deg/m\n            N_sph (tuple): (Nlon, Nlat, Nr) number of divisions\n            x_obs_sph (tuple): Observation point (lon, lat, r) in deg/m\n        \"\"\"\n        # Convert degrees to radians\n        lon_min_rad = np.deg2rad(domain_sph['lon'][0])\n        lon_max_rad = np.deg2rad(domain_sph['lon'][1])\n        lat_min_rad = np.deg2rad(domain_sph['lat'][0])\n        lat_max_rad = np.deg2rad(domain_sph['lat'][1])\n        \n        r_min, r_max = domain_sph['r']\n        N_lon, N_lat, N_r = N_sph\n\n        x_obs_lon_rad = np.deg2rad(x_obs_sph[0])\n        x_obs_lat_rad = np.deg2rad(x_obs_sph[1])\n        x_obs_r = x_obs_sph[2]\n        x_obs_cart = spherical_to_cartesian(x_obs_lon_rad, x_obs_lat_rad, x_obs_r)\n\n        d_lon = (lon_max_rad - lon_min_rad) / N_lon\n        d_lat = (lat_max_rad - lat_min_rad) / N_lat\n        d_r = (r_max - r_min) / N_r\n\n        total_potential = 0.0\n        total_error = 0.0\n\n        for i in range(N_lon):\n            lon_mid = lon_min_rad + (i + 0.5) * d_lon\n            for j in range(N_lat):\n                lat_mid = lat_min_rad + (j + 0.5) * d_lat\n                for k in range(N_r):\n                    r_mid = r_min + (k + 0.5) * d_r\n                    \n                    # Tesseroid-specific geometry\n                    vol = r_mid**2 * np.cos(lat_mid) * d_lon * d_lat * d_r\n                    \n                    dx_local = r_mid * np.cos(lat_mid) * d_lon\n                    dy_local = r_mid * d_lat\n                    dz_local = d_r\n                    r_max = 0.5 * np.sqrt(dx_local**2 + dy_local**2 + dz_local**2)\n\n                    centroid_cart = spherical_to_cartesian(lon_mid, lat_mid, r_mid)\n\n                    # Potential calculation\n                    dist_to_centroid = np.linalg.norm(x_obs_cart - centroid_cart)\n                    total_potential += G * rho(centroid_cart) * vol / dist_to_centroid\n\n                    # Error bound calculation\n                    d_min = max(dist_to_centroid - r_max, EPSILON)\n                    K_sup = G / d_min\n                    M_K = G / (d_min**2)\n                    \n                    error_contrib = vol * r_max * (L_RHO * K_sup + RHO_MAX * M_K)\n                    total_error += error_contrib\n\n        return [total_potential, total_error]\n\n    #\n    # Step 4: Define and Run Test Cases\n    #\n    test_cases = [\n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (10, 10, 10), 'x_obs': np.array([500, 500, 1500])},\n        \n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (20, 20, 20), 'x_obs': np.array([500, 500, 1500])},\n        \n        {'type': 'cartesian', 'domain': {'x': (0, 1000), 'y': (0, 1000), 'z': (0, 1000)},\n         'N': (10, 10, 10), 'x_obs': np.array([500, 500, 1010])},\n        \n        {'type': 'tesseroid', 'domain_sph': {'lon': (0.0, 0.5), 'lat': (0.0, 0.5), 'r': (R_E, R_E + 1000)},\n         'N_sph': (10, 10, 10), 'x_obs_sph': (0.25, 0.25, R_E + 2000)},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'cartesian':\n            result = compute_cartesian(case['domain'], case['N'], case['x_obs'])\n        elif case['type'] == 'tesseroid':\n            result = compute_tesseroid(case['domain_sph'], case['N_sph'], case['x_obs_sph'])\n        results.append(result)\n\n    # Final print statement in the exact required format\n    inner_strings = [f\"[{v},{e}]\" for v, e in results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建了数值模型之后，我们如何确信它的计算结果是正确的？答案在于通过与已知的解析解进行比较来验证模型。此练习将指导您完成一个经典的验证测试：将一个径向很薄的球载体（tesseroid）的引力场计算结果与球壳定理（Shell Theorem）得出的精确解析解进行对比 。通过这个实践，您不仅可以验证代码的正确性，还能加深对数值方法与基本物理定律之间联系的理解，这是计算科学中的一项基本技能。",
            "id": "3601790",
            "problem": "您需要实现一个完整的、可运行的程序，该程序通过将一个球形体元（tesseroid）径向塌陷以近似一个薄球壳，来验证一种引力正演建模方法，并将数值计算的引力加速度与球壳的解析解进行比较。该程序必须计算位于球壳极轴上观测点的引力加速度径向分量，其方法是对 tesseroid 的纬度、经度和径向范围，使用牛顿引力定律的体积积分进行直接数值评估，然后量化其与球壳解析解之间的差异。\n\n您的推导和算法应以下列基本原理为基础：牛顿万有引力定律指出，在观测位置 $\\mathbf{r}$ 处，由密度为 $\\rho(\\mathbf{r}')$ 的质量分布所产生的引力加速度 $\\mathbf{g}$，是由对源坐标 $\\mathbf{r}'$ 的体积积分给出的。程序必须在球坐标系 $(r',\\theta',\\phi')$ 中实现该积分，其中 $\\theta'$ 是余纬，$\\phi'$ 是经度，并使用适当的雅可比因子。使用高斯求积（高斯-勒让德求积）来近似每个坐标维度上的积分。全程声明并使用国际单位制 (SI)。\n\n定义一个在角度上完全跨越整个球体，并在径向上由内半径 $R_1$ 和外半径 $R_2$ 界定的 tesseroid。通过使 $R_2 - R_1$ 变小，将 tesseroid 径向塌陷，以使其近似一个薄球壳。计算位于极轴（连接原点和北极的线）上观测点的引力加速度径向分量 $g_r$，并与密度均匀的同心球壳的解析解进行比较。所有引力加速度都必须以 $\\mathrm{m/s^2}$ 为单位表示。\n\n使用的常数和单位：\n- 引力常数 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$。\n- 密度 $\\rho = 3000\\,\\mathrm{kg/m^3}$。\n- 角度（弧度）。\n- 半径和长度（米）。\n- 引力加速度（m/s²）。\n\n解析参考解要求：\n- 使用密度均匀的球对称壳层的精确解析引力加速度来验证数值结果。解析解必须从第一性原理推导，并在您的代码中实现。它必须能正确处理 $r  R_1$、$R_1  r  R_2$ 和 $r  R_2$ 这几种情况。\n\n数值积分要求：\n- 在每个维度上实现高斯-勒让德求积，其中 $\\theta' \\in [0,\\pi]$、$\\phi' \\in [0,2\\pi]$ 和 $r' \\in [R_1,R_2]$ 的阶数由用户指定的 $N_\\theta$、$N_\\phi$ 和 $N_r$ 决定。\n- 观测点位于极轴上，半径为 $r$，因此只需要计算径向分量 $g_r$。\n- 使用球坐标系中的 tesseroid 体积元，并将矢量场投影到极轴上以获得 $g_r$。\n\n设计一个包含四个案例的测试套件，用于探究塌陷至球壳验证的不同方面。对于每个测试案例，报告一个标量差异值，该值按下述规定进行汇总：\n- 当解析解的量值不为零时，报告定义为 $|g_{\\mathrm{num}} - g_{\\mathrm{analytic}}| / |g_{\\mathrm{analytic}}|$ 的相对误差。\n- 当解析解的量值为零时，报告绝对误差 $|g_{\\mathrm{num}}|$。\n\n使用以下测试套件参数值：\n- 测试 1（壳外的一般“理想路径”）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 1000\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 10^{6}\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 4$。\n- 测试 2（靠近边界的壳外，壳更薄）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 10\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 10\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 2$。\n- 测试 3（壳内，壳极薄）：$R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 0.1\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_1 - 10^{6}\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 2$。\n- 测试 4（中等薄度的壳外，中等距离）：$R_1 = 10^{6}\\,\\mathrm{m}$，$R_2 = R_1 + 50\\,\\mathrm{m}$，$\\rho = 3000\\,\\mathrm{kg/m^3}$，观测半径 $r = R_2 + 1\\,\\mathrm{m}$，求积阶数 $N_\\theta = 64$，$N_\\phi = 64$，$N_r = 4$。\n\n答案规范：\n- 输出必须是无量纲的差异值（根据上述说明，为相对误差或绝对误差），并以浮点数表示。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式如下：$\\texttt{[result1,result2,result3,result4]}$。",
            "solution": "我们从牛顿万有引力定律出发。对于位于源位置 $\\mathbf{r}'$ 的一个质量元和位于 $\\mathbf{r}$ 的一个测试点，其引力加速度的微分 $d\\mathbf{g}$ 为\n$$\nd\\mathbf{g}(\\mathbf{r}) = - G \\frac{\\rho(\\mathbf{r}')\\, dV' \\, (\\mathbf{r} - \\mathbf{r}')}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3}.\n$$\n对整个质量分布进行积分可得\n$$\n\\mathbf{g}(\\mathbf{r}) = - G \\int_{V} \\rho(\\mathbf{r}') \\frac{\\mathbf{r} - \\mathbf{r}'}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3} \\, dV'.\n$$\n我们在球坐标系 $\\left(r',\\theta',\\phi'\\right)$ 中对 tesseroid 的体积进行参数化，其雅可比行列式为 $dV' = r'^2 \\sin\\theta' \\, dr' \\, d\\theta' \\, d\\phi'$。该 tesseroid 在角度上跨越整个球面，其中 $\\theta' \\in [0,\\pi]$，$\\phi' \\in [0,2\\pi]$，径向范围为 $r' \\in [R_1,R_2]$。我们将观测点置于极轴上（北极方向），因此在笛卡尔坐标系中 $\\mathbf{r} = (0,0,r)$，径向单位矢量为 $\\hat{\\mathbf{e}}_r = (0,0,1)$。源元素的笛卡尔坐标为 $\\mathbf{r}' = \\left(r' \\sin\\theta' \\cos\\phi',\\, r' \\sin\\theta' \\sin\\phi',\\, r' \\cos\\theta'\\right)$。\n\n被积函数投影到径向方向上变为\n$$\n\\left(\\mathbf{r} - \\mathbf{r}'\\right) \\cdot \\hat{\\mathbf{e}}_r = r - r' \\cos\\theta',\n$$\n距离的范数为\n$$\n\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert = \\sqrt{r^2 + r'^2 - 2 r r' \\cos\\theta'}.\n$$\n因此，引力加速度的径向分量 $g_r$ 为\n$$\ng_r(r) = - G \\rho \\int_{R_1}^{R_2} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\frac{r'^2 \\sin\\theta' \\left(r - r' \\cos\\theta'\\right)}{\\left(r^2 + r'^2 - 2 r r' \\cos\\theta'\\right)^{3/2}} \\, d\\phi' \\, d\\theta' \\, dr'.\n$$\n根据对称性，对于位于极轴上的观测点，被积函数不依赖于 $\\phi'$，因此对 $\\phi'$ 的积分可简化为一个因子 $2\\pi$。但为了与类似 tesseroid 的角度离散化保持一致，我们仍保留了对 $\\phi'$ 的数值求积。\n\n我们使用高斯求积（高斯-勒让德）来近似每个积分。对于区间 $[a,b]$，高斯-勒让德求积提供了从 $[-1,1]$ 映射而来的节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$，映射关系如下\n$$\nx_i^{[a,b]} = \\frac{b-a}{2} x_i + \\frac{b+a}{2}, \\quad w_i^{[a,b]} = \\frac{b-a}{2} w_i.\n$$\n在 $r'$、$\\theta'$ 和 $\\phi'$ 方向上应用求积， $g_r$ 的数值估计值变为\n$$\ng_r^{\\text{num}}(r) = - G \\rho \\sum_{i=1}^{N_r} \\sum_{j=1}^{N_\\theta} \\sum_{k=1}^{N_\\phi}\n\\frac{ \\left(r'^2_i \\sin\\theta'_j \\left(r - r'_i \\cos\\theta'_j\\right)\\right) \\, w^{[R_1,R_2]}_i \\, w^{[0,\\pi]}_j \\, w^{[0,2\\pi]}_k }\n{\\left(r^2 + r'^2_i - 2 r r'_i \\cos\\theta'_j\\right)^{3/2}}.\n$$\n这就得出了极轴上的径向分量，单位为 $\\mathrm{m/s^2}$。\n\n为了进行解析验证，我们使用球壳定理和球对称性。对于一个内半径为 $R_1$、外半径为 $R_2$ 的密度均匀的球对称壳层，其总质量为\n$$\nM = \\frac{4\\pi \\rho}{3} \\left(R_2^3 - R_1^3\\right).\n$$\n引力加速度为：\n- 在壳层外部 ($r  R_2$)，其引力场等同于一个位于原点的点质量所产生的场：\n$$\ng_r^{\\text{analytic}}(r) = - \\frac{G M}{r^2}.\n$$\n- 在空腔内部 ($r  R_1$)，其包裹的质量为零，因此\n$$\ng_r^{\\text{analytic}}(r) = 0.\n$$\n- 在壳层物质内部 ($R_1  r  R_2$)，只有半径 $r$ 以内包裹的质量有贡献：\n$$\nM_{\\text{enc}}(r) = \\frac{4\\pi \\rho}{3}\\left(r^3 - R_1^3\\right), \\quad\ng_r^{\\text{analytic}}(r) = - \\frac{G M_{\\text{enc}}(r)}{r^2} = - \\frac{4\\pi G \\rho}{3}\\left(r - \\frac{R_1^3}{r^2}\\right).\n$$\n我们的测试套件选择的观测半径避开了 $r$ 恰好等于壳层边界的奇异情况，并包括了壳外和壳内两种情形。\n\n误差度量：\n- 对于 $g_r^{\\text{analytic}} \\neq 0$ 的测试，我们计算相对误差\n$$\n\\epsilon_{\\text{rel}} = \\frac{\\left|g_r^{\\text{num}} - g_r^{\\text{analytic}}\\right|}{\\left|g_r^{\\text{analytic}}\\right|}.\n$$\n- 对于 $g_r^{\\text{analytic}} = 0$ 的测试，我们计算绝对误差\n$$\n\\epsilon_{\\text{abs}} = \\left|g_r^{\\text{num}}\\right|.\n$$\n\n算法设计：\n- 使用勒让德多项式的节点和权重实现高斯-勒让德求积；将它们分别映射到 $[0,\\pi]$（用于 $\\theta'$）、$[0,2\\pi]$（用于 $\\phi'$）和 $[R_1,R_2]$（用于 $r'$）。\n- 为了计算效率，对 $\\theta'$ 的操作进行矢量化，并对求积权重求和。\n- 使用离散化积分和指定的求积阶数计算 $g_r^{\\text{num}}(r)$。\n- 根据具体情况，使用相应的球壳定理表达式计算 $g_r^{\\text{analytic}}(r)$。\n- 按指定顺序报告每个测试的差异。\n- 确保所有输入和输出均采用国际单位制 (SI)，角度单位为弧度，加速度单位为 $\\mathrm{m/s^2}$。\n\n这种方法验证了当 tesseroid 径向塌陷时（即 $R_2 - R_1$ 很小），数值积分场在壳层内外均收敛于球壳的解析解，从而证明了基于 tesseroid 的正演建模与经典球体解之间的一致性。",
            "answer": "```python\nimport numpy as np\n\n# Constants in SI units\nG = 6.67430e-11  # m^3 kg^-1 s^-2\n\ndef gauss_legendre_nodes_weights(a, b, n):\n    \"\"\"\n    Return Gauss-Legendre nodes and weights mapped from [-1,1] to [a,b].\n    \"\"\"\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Map nodes to [a,b]\n    nodes = 0.5 * (b - a) * xi + 0.5 * (b + a)\n    # Scale weights to [a,b]\n    weights = 0.5 * (b - a) * wi\n    return nodes, weights\n\ndef shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r):\n    \"\"\"\n    Compute the radial component of gravitational acceleration at r_obs (on polar axis)\n    due to a spherically symmetric tesseroid (full angular coverage, radial [R1, R2])\n    using Gauss-Legendre quadrature in r', theta', phi'.\n    \"\"\"\n    # Quadrature in r', theta', phi'\n    r_nodes, r_weights = gauss_legendre_nodes_weights(R1, R2, n_r)\n    th_nodes, th_weights = gauss_legendre_nodes_weights(0.0, np.pi, n_theta)\n    ph_nodes, ph_weights = gauss_legendre_nodes_weights(0.0, 2.0*np.pi, n_phi)\n\n    # Precompute angular quantities\n    cos_th = np.cos(th_nodes)\n    sin_th = np.sin(th_nodes)\n\n    # Sum of phi weights for integrand independent of phi at polar axis\n    Wphi = np.sum(ph_weights)\n\n    # Accumulate integral\n    integral_sum = 0.0\n    for ri, wri in zip(r_nodes, r_weights):\n        # Denominator term |r - r'|^3 depends on theta\n        denom = (r_obs**2 + ri**2 - 2.0*r_obs*ri*cos_th)**1.5\n        # Kernel projected onto radial direction\n        kernel = (ri**2) * sin_th * (r_obs - ri * cos_th) / denom\n        # Weighted sum over theta and phi\n        theta_sum = np.sum(th_weights * kernel)\n        integral_sum += wri * Wphi * theta_sum\n\n    # Multiply by constants and sign\n    g_r = -G * rho * integral_sum\n    return g_r  # m/s^2\n\ndef shell_gravity_radial_analytic(r_obs, R1, R2, rho):\n    \"\"\"\n    Analytic radial gravitational acceleration for a spherically symmetric shell.\n    Handles regimes r  R1, R1  r  R2, r  R2.\n    \"\"\"\n    # Total mass of shell\n    M_total = (4.0 * np.pi * rho / 3.0) * (R2**3 - R1**3)\n    if r_obs  R1:\n        return 0.0\n    elif r_obs > R2:\n        return -G * M_total / (r_obs**2)\n    else:\n        # Within shell volume: only enclosed mass contributes\n        M_enc = (4.0 * np.pi * rho / 3.0) * (r_obs**3 - R1**3)\n        return -G * M_enc / (r_obs**2)\n\ndef discrepancy(g_num, g_analytic):\n    \"\"\"\n    Compute discrepancy: relative error if analytic != 0, else absolute error.\n    \"\"\"\n    if g_analytic != 0.0:\n        return abs((g_num - g_analytic) / g_analytic)\n    else:\n        return abs(g_num)\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Test 1: happy path outside the shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 1000.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 1000.0) + 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n        # Test 2: near-boundary outside with thinner shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 10.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 10.0) + 10.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 3: inside the shell with extremely thin shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 0.1,\n            \"rho\": 3000.0,\n            \"r_obs\": 6.371e6 - 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 4: moderately thin shell outside, mid-range distance\n        {\n            \"R1\": 1.0e6,\n            \"R2\": 1.0e6 + 50.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (1.0e6 + 50.0) + 1.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R1 = case[\"R1\"]\n        R2 = case[\"R2\"]\n        rho = case[\"rho\"]\n        r_obs = case[\"r_obs\"]\n        n_theta = case[\"n_theta\"]\n        n_phi = case[\"n_phi\"]\n        n_r = case[\"n_r\"]\n\n        g_num = shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r)\n        g_ana = shell_gravity_radial_analytic(r_obs, R1, R2, rho)\n        err = discrepancy(g_num, g_ana)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个在理想条件下表现完美的算法，在面对真实世界中复杂的几何形状时可能会遇到挑战。此练习将您的注意力从理想情况转移到代码的稳健性上，重点关注如何处理“退化情况”或“边缘案例”。您将为零体积单元、或观测点恰好位于模型表面或边上的特殊几何构型设计单元测试 。掌握如何处理这些情景，是确保您的代码不仅准确，而且在各种实际应用中都稳定可靠的关键一步，体现了严谨的科学软件工程思想。",
            "id": "3601751",
            "problem": "您的任务是为两类地球模型——长方体和球台体（tesseroid）——实现并验证一个重力正演模拟程序。该实现必须对退化的几何构型以及恰好位于面或边上的观测点具有鲁棒性。您的程序必须是一个完整的、可运行的程序，它能评估一组固定的测试用例，并将结果作为单行输出。\n\n您必须使用的基本原理是牛顿万有引力定律。对于一个密度恒定的物体，由占据区域 $V$、密度为 $\\rho$ 的质量分布在观测点（位置矢量为 $\\mathbf{r}_0$）产生的重力加速度由以下公式给出：\n$$\n\\mathbf{g}(\\mathbf{r}_0) \\;=\\; G \\, \\rho \\int\\!\\!\\!\\int\\!\\!\\!\\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV,\n$$\n其中，$G$ 是牛顿引力常数，$\\mathbf{r}$ 是源内的位置，而 $dV$ 是体积元。对于一个与笛卡尔坐标轴对齐、边界为 $x \\in [x_{\\min}, x_{\\max}]$，$y \\in [y_{\\min}, y_{\\max}]$ 和 $z \\in [z_{\\min}, z_{\\max}]$ 的长方体，使用笛卡尔体积元 $dV = dx \\, dy \\, dz$。对于一个在球坐标中由半径 $r \\in [r_1, r_2]$、余纬 $\\theta \\in [\\theta_1, \\theta_2]$（$\\theta = 0$ 在北极点）和经度 $\\lambda \\in [\\lambda_1, \\lambda_2]$ 描述的球台体（tesseroid），使用球坐标体积元 $dV = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\lambda$。在所有情况下，取 $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$，重力加速度以 $\\mathrm{m/s^2}$ 表示。\n\n您的实现必须使用稳定且收敛的求积方法对体积积分进行数值计算。您必须确保：\n- 如果几何单元的体积为零（例如，任何边界区间的长度为零），则对于任何观测点和有限密度，模拟的重力加速度精确为 $\\mathbf{0}$。\n- 如果观测点位于单元的面或边上，模拟的重力加速度保持为有限值。\n- 尊重对称性，因此因对称性应相互抵消的分量在数值上应接近于零。\n\n为使其具体且可测试，请实现两个正演模拟程序：\n- 一个用于与笛卡尔坐标轴对齐的长方体（多面体的一种特例）的程序。该程序必须接受 $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}, z_{\\min}, z_{\\max})$、密度 $\\rho$ 以及观测点坐标 $(x_0, y_0, z_0)$，并且必须返回矢量 $\\mathbf{g}$。\n- 一个用于由 $(r_1, r_2, \\theta_1, \\theta_2, \\lambda_1, \\lambda_2)$、密度 $\\rho$ 和球坐标表示的观测点 $(r_0, \\theta_0, \\lambda_0)$ 定义的球台体的程序。该程序必须返回笛卡尔坐标下的重力加速度矢量 $\\mathbf{g}$，以及其在观测点位置的球坐标分量，即径向分量 $g_r$、余纬分量 $g_\\theta$ 和经向分量 $g_\\lambda$，这些分量是通过将 $\\mathbf{g}$ 投影到局部标准正交基 $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$ 上形成的。\n\n角度必须以弧度为单位。所有距离必须以米为单位，密度以 $\\mathrm{kg/m^3}$ 为单位。您的数值积分在每个维度上必须至少使用六阶高斯求积，以确保对以下测试有足够的精度。\n\n设计并运行以下测试套件。对于每个案例，计算指定的检查并生成一个布尔结果。所有与零的比较都必须在数值上进行解释，使用您选择的严格公差，以反映双精度数值精度和模拟信号的量级。\n\n测试套件：\n- 测试 $1$（零体积长方体）：设 $x \\in [0, 1000] \\, \\mathrm{m}$，$y \\in [0, 1000] \\, \\mathrm{m}$，$z \\in [2000, 2000] \\, \\mathrm{m}$，密度 $\\rho = 2670 \\, \\mathrm{kg/m^3}$，观测点 $(x_0, y_0, z_0) = (100, 100, 0) \\, \\mathrm{m}$。预期结果：模拟的 $\\mathbf{g}$ 的模长等于 $0$（在数值公差范围内），即如果 $\\lVert \\mathbf{g} \\rVert$ 在数值上为零，则返回布尔值 true。\n- 测试 $2$（观测点位于长方体的一个面心）：设 $x \\in [-500, 500] \\, \\mathrm{m}$，$y \\in [-500, 500] \\, \\mathrm{m}$，$z \\in [0, 100] \\, \\mathrm{m}$，密度 $\\rho = 2670 \\, \\mathrm{kg/m^3}$，观测点 $(x_0, y_0, z_0) = (0, 0, 0) \\, \\mathrm{m}$。预期结果：根据对称性，$g_x$ 和 $g_y$ 在数值上为零，而 $g_z$ 是有限的正值；如果这些条件都成立，则返回布尔值 true。\n- 测试 $3$（零体积球台体）：设 $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6}] \\, \\mathrm{m}$，$\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$，$\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$，密度 $\\rho = 3000 \\, \\mathrm{kg/m^3}$，观测点 $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$。预期结果：模拟的 $\\mathbf{g}$ 的模长等于 $0$（在数值公差范围内）；如果 $\\lVert \\mathbf{g} \\rVert$ 在数值上为零，则返回布尔值 true。\n- 测试 $4$（观测点位于球台体内部径向面上且处于角对称中心）：设 $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6} + 1000] \\, \\mathrm{m}$，$\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$，$\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$，密度 $\\rho = 3000 \\, \\mathrm{kg/m^3}$，观测点 $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$。预期结果：由于角对称性，切向分量在数值上为零，径向分量 $g_r$ 是有限的正值；如果 $g_r  0$ 且切向模长 $\\sqrt{g_\\theta^2 + g_\\lambda^2}$ 相对于 $g_r$ 在数值上可忽略不计，则返回布尔值 true。\n- 测试 $5$（观测点位于长方体的一个面棱中点）：使用与测试 $2$ 相同的长方体，将观测点设为 $(x_0, y_0, z_0) = (500, 0, 0) \\, \\mathrm{m}$（一个底面棱的中点）。预期结果：根据关于平面 $y = 0$ 的对称性，$g_y$ 在数值上为零，$g_z$ 是有限的正值；如果这两个条件都成立，则返回布尔值 true。\n\n您的程序必须按顺序计算测试 $1$ 到 $5$ 的布尔值，并生成单行输出，其中包含用逗号分隔并用方括号括起来的结果，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。所有角度必须以弧度为单位，所有距离以米为单位。所有重力加速度的计算和解释都必须以 $\\mathrm{m/s^2}$ 为单位。不允许用户输入；所有参数均如上所述，必须硬编码在您的程序中。",
            "solution": "该问题是有效的，因为它科学地基于牛顿物理学，其提法是适定的，具有足够的信息以获得唯一解，并且其表述是客观的。所有参数和测试条件都已明确指定。该问题将通过实现所要求的数值积分程序来解决。\n\n控制该问题的基本原理是牛顿万有引力定律。由占据体积 $V$、密度为常数 $\\rho$ 的连续质量分布在观测点 $\\mathbf{r}_0$ 产生的重力加速度矢量 $\\mathbf{g}$ 由以下体积积分给出：\n$$\n\\mathbf{g}(\\mathbf{r}_0) = G \\rho \\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV\n$$\n其中，$G$ 是引力常数（$6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$），$\\mathbf{r}$ 是体积 $V$ 内质量元的位置矢量。这个矢量积分通常通过分别计算每个笛卡尔分量 $(g_x, g_y, g_z)$ 的积分来求解。\n\n对于一些简单的几何形状，该积分可以解析求解，但对于复杂形状或通用算法，则需要使用数值方法。问题指定为此目的至少使用六阶高斯求积。高斯求积通过在积分区间内的特定点（节点）上对函数进行加权求和来近似定积分。一个 $N$ 点格式对最高 $2N-1$ 次的多项式是精确的。\n\n对于一个箱型域上的三维积分，我们采用乘积法则，创建一个三维的求积点网格和权重乘积。对于一个积分 $\\int_{c}^{d}\\int_{a}^{b}\\int_{u}^{v} f(x,y,z) \\,dx\\,dy\\,dz$，其近似值为：\n$$\n\\approx \\frac{v-u}{2}\\frac{b-a}{2}\\frac{d-c}{2} \\sum_{k}\\sum_{j}\\sum_{i} w_i w_j w_k f(x_i, y_j, z_k)\n$$\n其中 $(\\xi_i, w_i)$ 是 $[-1, 1]$ 上的标准高斯求积节点和权重，而 $x_i, y_j, z_k$ 是这些节点映射到各自积分区间上的点。\n\n该问题的一个关键方面是被积函数中的奇异性，当积分点 $\\mathbf{r}$ 与观测点 $\\mathbf{r}_0$ 重合时，分母为零，就会出现奇异性。虽然该积分是收敛的，但在奇异点进行朴素的数值计算将会失败。问题要求对位于质量模型边界上的观测点进行鲁棒处理。使用偶数个点（例如，$N=6$）的高斯求积是有利的，因为其节点对称分布，并且不包括区间的端点或中点。对于中心对称的几何形状和观测点，这有助于避免在奇异点直接求值。作为一种保障措施，我们的实现将检查求值点是否在数值上与观测点重合，如果是，则贡献赋为零，这反映了奇异点处无穷小体积的贡献本身也是无穷小的事实。\n\n**第一部分：长方体（棱柱）**\n\n对于一个与笛卡尔坐标轴对齐，由 $x \\in [x_{\\min}, x_{\\max}]$, $y \\in [y_{\\min}, y_{\\max}]$ 和 $z \\in [z_{\\min}, z_{\\max}]$ 定义的长方体，体积元为 $dV = dx\\,dy\\,dz$。观测点为 $\\mathbf{r}_0 = (x_0, y_0, z_0)$。加速度的 $x$ 分量 $g_x$ 为：\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{z_{\\min}}^{z_{\\max}} \\int_{y_{\\min}}^{y_{\\max}} \\int_{x_{\\min}}^{x_{\\max}} \\frac{x-x_0}{\\left( (x-x_0)^2 + (y-y_0)^2 + (z-z_0)^2 \\right)^{3/2}} \\,dx\\,dy\\,dz\n$$\n$g_y$ 和 $g_z$ 分量是类似的。在每个维度上独立应用 $6$ 点高斯求积。算法首先检查零体积情况（例如，$x_{\\min} = x_{\\max}$），返回一个零矢量。否则，它将继续进行三重循环的求积求和。\n\n**第二部分：球台体（Tesseroid）**\n\n球台体（tesseroid）是一个“球形棱柱”，在球坐标系中由半径 $r \\in [r_1, r_2]$、余纬 $\\theta \\in [\\theta_1, \\theta_2]$ 和经度 $\\lambda \\in [\\lambda_1, \\lambda_2]$ 定义。体积元为 $dV = r^2 \\sin\\theta \\,dr\\,d\\theta\\,d\\lambda$。矢量差 $\\mathbf{r} - \\mathbf{r}_0$ 的物理计算在统一的坐标系中最为直接。我们为此使用笛卡尔坐标系。积分点 $\\mathbf{r}(r, \\theta, \\lambda)$ 和观测点 $\\mathbf{r}_0(r_0, \\theta_0, \\lambda_0)$ 都被转换成笛卡尔坐标 $(x,y,z)$：\n$$\nx = r \\sin\\theta \\cos\\lambda, \\quad y = r \\sin\\theta \\sin\\lambda, \\quad z = r \\cos\\theta\n$$\n然后，使用关于 $r, \\theta, \\lambda$ 的三维高斯求积，对每个加速度的笛卡尔分量进行数值计算。例如，$x$ 分量为：\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{r_1}^{r_2} \\int_{\\theta_1}^{\\theta_2} \\int_{\\lambda_1}^{\\lambda_2} \\frac{x(r, \\theta, \\lambda) - x_0}{\\left\\lVert \\mathbf{r}(r, \\theta, \\lambda) - \\mathbf{r}_0 \\right\\rVert^{3}} r^2 \\sin\\theta \\,d\\lambda\\,d\\theta\\,dr\n$$\n在计算出笛卡尔加速度矢量 $\\mathbf{g} = (g_x, g_y, g_z)$ 之后，将其投影到观测点的局部球坐标基矢 $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$ 上，以求得球坐标分量 $(g_r, g_\\theta, g_\\lambda)$。基矢为：\n$$\n\\hat{\\mathbf{e}}_r = (\\sin\\theta_0 \\cos\\lambda_0, \\sin\\theta_0 \\sin\\lambda_0, \\cos\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\theta = (\\cos\\theta_0 \\cos\\lambda_0, \\cos\\theta_0 \\sin\\lambda_0, -\\sin\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\lambda = (-\\sin\\lambda_0, \\cos\\lambda_0, 0)\n$$\n这些分量即为 $g_r = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_r$，$g_\\theta = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\theta$ 和 $g_\\lambda = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\lambda$。\n\n这种双模型实现，通过对几何、坐标系和数值稳定性的仔细处理，可以验证指定的测试用例，这些测试用例探测了其在零体积、边界观测和对称性情况下的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for gravity forward modeling.\n    \"\"\"\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    N_QUAD = 6       # Order of Gaussian quadrature\n    ABS_TOL = 1e-15  # Absolute tolerance for checking against zero\n    REL_TOL = 1e-9   # Relative tolerance for symmetry checks\n\n    # Pre-calculate Gaussian quadrature nodes and weights for interval [-1, 1]\n    quad_nodes, quad_weights = roots_legendre(N_QUAD)\n\n    def gravity_polyhedron(bounds, rho, p_obs, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a rectangular prism.\n\n        Args:\n            bounds (tuple): (xmin, xmax, ymin, ymax, zmin, zmax) in meters.\n            rho (float): Density in kg/m^3.\n            p_obs (tuple): Observation point (x0, y0, z0) in meters.\n            n_quad (int): Number of quadrature points per dimension.\n\n        Returns:\n            tuple: The gravitational acceleration vector (gx, gy, gz) in m/s^2.\n        \"\"\"\n        xmin, xmax, ymin, ymax, zmin, zmax = bounds\n        x0, y0, z0 = p_obs\n\n        # Zero volume check\n        if abs(xmax - xmin)  ABS_TOL or abs(ymax - ymin)  ABS_TOL or abs(zmax - zmin)  ABS_TOL:\n            return (0.0, 0.0, 0.0)\n\n        # Map nodes and weights to integration intervals\n        x_range, y_range, z_range = xmax - xmin, ymax - ymin, zmax - zmin\n        x_nodes = 0.5 * x_range * quad_nodes + 0.5 * (xmax + xmin)\n        y_nodes = 0.5 * y_range * quad_nodes + 0.5 * (ymax + ymin)\n        z_nodes = 0.5 * z_range * quad_nodes + 0.5 * (zmax + zmin)\n\n        g_vec = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    x, y, z = x_nodes[i], y_nodes[j], z_nodes[k]\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    \n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue \n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    \n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    g_vec[0] += w * dx * inv_dist_cubed\n                    g_vec[1] += w * dy * inv_dist_cubed\n                    g_vec[2] += w * dz * inv_dist_cubed\n        \n        # Scaling factor for integration\n        scale_factor = G * rho * (x_range / 2) * (y_range / 2) * (z_range / 2)\n        g_vec *= scale_factor\n        \n        return tuple(g_vec)\n\n    def sph_to_cart(r, theta, lamb):\n        \"\"\"Converts spherical to Cartesian coordinates.\"\"\"\n        sin_theta = np.sin(theta)\n        return (\n            r * sin_theta * np.cos(lamb),\n            r * sin_theta * np.sin(lamb),\n            r * np.cos(theta)\n        )\n\n    def gravity_tesseroid(bounds, rho, p_obs_sph, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a tesseroid.\n        \n        Returns both Cartesian and local spherical components of gravity vector.\n        \"\"\"\n        r1, r2, t1, t2, l1, l2 = bounds\n        r0, t0, l0 = p_obs_sph\n\n        if abs(r2 - r1)  ABS_TOL or abs(t2 - t1)  ABS_TOL or abs(l2 - l1)  ABS_TOL:\n            return ((0.0, 0.0, 0.0), (0.0, 0.0, 0.0))\n\n        x0, y0, z0 = sph_to_cart(r0, t0, l0)\n\n        r_range, t_range, l_range = r2 - r1, t2 - t1, l2 - l1\n        r_nodes = 0.5 * r_range * quad_nodes + 0.5 * (r2 + r1)\n        t_nodes = 0.5 * t_range * quad_nodes + 0.5 * (t2 + t1)\n        l_nodes = 0.5 * l_range * quad_nodes + 0.5 * (l2 + l1)\n\n        g_vec_cart = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    r, theta, lamb = r_nodes[i], t_nodes[j], l_nodes[k]\n                    x, y, z = sph_to_cart(r, theta, lamb)\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue\n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    vol_element_factor = r**2 * np.sin(theta)\n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    \n                    g_vec_cart[0] += w * dx * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[1] += w * dy * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[2] += w * dz * inv_dist_cubed * vol_element_factor\n\n        scale_factor = G * rho * (r_range / 2) * (t_range / 2) * (l_range / 2)\n        g_vec_cart *= scale_factor\n        \n        # Project to spherical components at observation point\n        sin_t0, cos_t0 = np.sin(t0), np.cos(t0)\n        sin_l0, cos_l0 = np.sin(l0), np.cos(l0)\n        \n        e_r = np.array([sin_t0 * cos_l0, sin_t0 * sin_l0, cos_t0])\n        e_theta = np.array([cos_t0 * cos_l0, cos_t0 * sin_l0, -sin_t0])\n        e_lambda = np.array([-sin_l0, cos_l0, 0])\n        \n        g_r = np.dot(g_vec_cart, e_r)\n        g_theta = np.dot(g_vec_cart, e_theta)\n        g_lambda = np.dot(g_vec_cart, e_lambda)\n\n        return tuple(g_vec_cart), (g_r, g_theta, g_lambda)\n\n    results = []\n\n    # Test 1: Zero-volume rectangular polyhedron\n    g = gravity_polyhedron(bounds=(0, 1000, 0, 1000, 2000, 2000), rho=2670, p_obs=(100, 100, 0), n_quad=N_QUAD)\n    norm_g = np.linalg.norm(g)\n    results.append(norm_g  ABS_TOL)\n\n    # Test 2: Observation on a face center of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(0, 0, 0), n_quad=N_QUAD)\n    gx, gy, gz = g\n    results.append(abs(gx)  ABS_TOL and abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Test 3: Zero-volume tesseroid\n    g_cart, _ = gravity_tesseroid(bounds=(6.371e6, 6.371e6, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    norm_g_cart = np.linalg.norm(g_cart)\n    results.append(norm_g_cart  ABS_TOL)\n\n    # Test 4: Observation on an inner radial face at angular symmetry center of a tesseroid\n    _, g_sph = gravity_tesseroid(bounds=(6.371e6, 6.371e6 + 1000, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    gr, gtheta, glambda = g_sph\n    tangential_mag = np.sqrt(gtheta**2 + glambda**2)\n    results.append(gr > ABS_TOL and tangential_mag  REL_TOL * abs(gr))\n\n    # Test 5: Observation on a face edge of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(500, 0, 0), n_quad=N_QUAD)\n    _, gy, gz = g\n    results.append(abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}