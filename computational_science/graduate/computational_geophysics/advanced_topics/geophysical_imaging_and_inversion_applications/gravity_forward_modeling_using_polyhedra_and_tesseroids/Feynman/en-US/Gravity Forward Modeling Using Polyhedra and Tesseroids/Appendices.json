{
    "hands_on_practices": [
        {
            "introduction": "A fundamental practice in computational science is to validate numerical results against known analytical solutions. This exercise leverages the classical Shell Theorem, which provides an exact solution for the gravitational acceleration of a spherical shell. By numerically modeling a tesseroid that approximates a thin, global shell, you can directly compare your code's output to this benchmark, providing essential verification of your integration routine's accuracy .",
            "id": "3601790",
            "problem": "You are to implement a complete, runnable program that validates a gravity forward modeling approach for a spherical voxel (a tesseroid) by collapsing it radially to approximate a thin spherical shell and comparing the numerically computed gravitational acceleration to the analytic solution for a spherical shell. The program must compute the radial component of gravitational acceleration at observation points located on the polar axis of the shell, using a direct numerical evaluation of the Newtonian gravitational law as a volume integral over the tesseroid’s latitudinal, longitudinal, and radial extents, and then quantify the discrepancy against the analytic shell solution.\n\nUse the following fundamental base for your derivation and algorithm: Newton’s law of universal gravitation stating that the gravitational acceleration $\\mathbf{g}$ at an observation position $\\mathbf{r}$ due to a mass distribution with density $\\rho(\\mathbf{r}')$ is given by a volume integral over the source coordinates $\\mathbf{r}'$. The program must implement the integral in spherical coordinates $(r',\\theta',\\phi')$, where $\\theta'$ is the colatitude and $\\phi'$ is the longitude, with appropriate Jacobian factors. Use Gaussian quadrature (Gauss-Legendre quadrature) to approximate the integral in each coordinate dimension. State and use the International System of Units (SI) throughout.\n\nDefine a tesseroid that fully spans the sphere angularly and is bounded radially by an inner radius $R_1$ and an outer radius $R_2$. Collapse the tesseroid radially by making $R_2 - R_1$ small so that the tesseroid approximates a thin spherical shell. Compute the radial component of gravitational acceleration $g_r$ at observation points located on the polar axis (the line joining the origin and the north pole), and compare to the analytic solution for a concentric spherical shell of uniform density. You must express all gravitational accelerations in $\\mathrm{m/s^2}$.\n\nConstants and units to use:\n- Gravitational constant $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$.\n- Density $\\rho = 3000\\,\\mathrm{kg/m^3}$.\n- Angles in radians.\n- Radii and lengths in meters.\n- Gravitational acceleration in $\\mathrm{m/s^2}$.\n\nAnalytic reference solution requirement:\n- Use the exact analytic gravitational acceleration of a spherically symmetric shell of uniform density to validate the numerical result. The analytic solution must be derived from first principles and implemented in your code. It must correctly handle the regimes $r  R_1$, $R_1  r  R_2$, and $r > R_2$.\n\nNumerical integration requirements:\n- Implement Gauss-Legendre quadrature in each dimension with user-specified orders $N_\\theta$, $N_\\phi$, and $N_r$ for $\\theta' \\in [0,\\pi]$, $\\phi' \\in [0,2\\pi]$, and $r' \\in [R_1,R_2]$.\n- Observations are on the polar axis at radius $r$, so only the radial component $g_r$ is required.\n- Use the tesseroid volume element in spherical coordinates and project the vector field onto the polar axis to obtain $g_r$.\n\nDesign a test suite of four cases that probe different aspects of the collapse-to-shell validation. For each test case, report a single scalar discrepancy value, aggregated as specified below:\n- For cases where the analytic magnitude is nonzero, report the relative error defined as $|g_{\\text{num}} - g_{\\text{analytic}}| / |g_{\\text{analytic}}|$.\n- For cases where the analytic magnitude is zero, report the absolute error $|g_{\\text{num}}|$.\n\nUse the following test suite parameter values:\n- Test 1 (general “happy path” outside the shell): $R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$, $R_2 = R_1 + 1000\\,\\mathrm{m}$, $\\rho = 3000\\,\\mathrm{kg/m^3}$, observation radius $r = R_2 + 10^{6}\\,\\mathrm{m}$, quadrature orders $N_\\theta = 64$, $N_\\phi = 64$, $N_r = 4$.\n- Test 2 (near-boundary outside with thinner shell): $R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$, $R_2 = R_1 + 10\\,\\mathrm{m}$, $\\rho = 3000\\,\\mathrm{kg/m^3}$, observation radius $r = R_2 + 10\\,\\mathrm{m}$, quadrature orders $N_\\theta = 64$, $N_\\phi = 64$, $N_r = 2$.\n- Test 3 (inside the shell with extremely thin shell): $R_1 = 6.371\\times 10^{6}\\,\\mathrm{m}$, $R_2 = R_1 + 0.1\\,\\mathrm{m}$, $\\rho = 3000\\,\\mathrm{kg/m^3}$, observation radius $r = R_1 - 10^{6}\\,\\mathrm{m}$, quadrature orders $N_\\theta = 64$, $N_\\phi = 64$, $N_r = 2$.\n- Test 4 (moderately thin shell outside, mid-range distance): $R_1 = 10^{6}\\,\\mathrm{m}$, $R_2 = R_1 + 50\\,\\mathrm{m}$, $\\rho = 3000\\,\\mathrm{kg/m^3}$, observation radius $r = R_2 + 1\\,\\mathrm{m}$, quadrature orders $N_\\theta = 64$, $N_\\phi = 64$, $N_r = 4$.\n\nAnswer specification:\n- The outputs must be dimensionless discrepancy values (either relative or absolute as instructed above), expressed as floating-point numbers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above, for example: $\\texttt{[result1,result2,result3,result4]}$.",
            "solution": "We start from Newton’s law of universal gravitation. For a mass element at source position $\\mathbf{r}'$ and a test point at $\\mathbf{r}$, the differential gravitational acceleration $d\\mathbf{g}$ is\n$$\nd\\mathbf{g}(\\mathbf{r}) = - G \\frac{\\rho(\\mathbf{r}')\\, dV' \\, (\\mathbf{r} - \\mathbf{r}')}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3}.\n$$\nIntegrating over the mass distribution yields\n$$\n\\mathbf{g}(\\mathbf{r}) = - G \\int_{V} \\rho(\\mathbf{r}') \\frac{\\mathbf{r} - \\mathbf{r}'}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3} \\, dV'.\n$$\nWe parameterize the tesseroid volume in spherical coordinates $\\left(r',\\theta',\\phi'\\right)$ with Jacobian $dV' = r'^2 \\sin\\theta' \\, dr' \\, d\\theta' \\, d\\phi'$. The tesseroid spans the full sphere in angle, with $\\theta' \\in [0,\\pi]$, $\\phi' \\in [0,2\\pi]$, and radially $r' \\in [R_1,R_2]$. We place the observation point on the polar axis (north pole direction), so $\\mathbf{r} = (0,0,r)$ in Cartesian coordinates and the radial unit vector is $\\hat{\\mathbf{e}}_r = (0,0,1)$. The source element has Cartesian coordinates $\\mathbf{r}' = \\left(r' \\sin\\theta' \\cos\\phi',\\, r' \\sin\\theta' \\sin\\phi',\\, r' \\cos\\theta'\\right)$.\n\nThe integrand projected onto the radial direction becomes\n$$\n\\left(\\mathbf{r} - \\mathbf{r}'\\right) \\cdot \\hat{\\mathbf{e}}_r = r - r' \\cos\\theta',\n$$\nand the separation norm is\n$$\n\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert = \\sqrt{r^2 + r'^2 - 2 r r' \\cos\\theta'}.\n$$\nTherefore, the radial component of the gravitational acceleration $g_r$ is\n$$\ng_r(r) = - G \\rho \\int_{R_1}^{R_2} \\int_{0}^{\\pi} \\int_{0}^{2\\pi} \\frac{r'^2 \\sin\\theta' \\left(r - r' \\cos\\theta'\\right)}{\\left(r^2 + r'^2 - 2 r r' \\cos\\theta'\\right)^{3/2}} \\, d\\phi' \\, d\\theta' \\, dr'.\n$$\nBy symmetry, the integrand does not depend on $\\phi'$ for an observation point on the polar axis, so the $\\phi'$ integral reduces to a factor of $2\\pi$, but we retain a numerical quadrature in $\\phi'$ to stay consistent with a tesseroid-like angular discretization.\n\nWe approximate each integral using Gaussian quadrature (Gauss-Legendre). For an interval $[a,b]$, Gauss-Legendre provides nodes $\\{x_i\\}$ and weights $\\{w_i\\}$ mapped from $[-1,1]$ by\n$$\nx_i^{[a,b]} = \\frac{b-a}{2} x_i + \\frac{b+a}{2}, \\quad w_i^{[a,b]} = \\frac{b-a}{2} w_i.\n$$\nApplying quadrature in $r'$, $\\theta'$, and $\\phi'$, the numerical estimate of $g_r$ becomes\n$$\ng_r^{\\text{num}}(r) = - G \\rho \\sum_{i=1}^{N_r} \\sum_{j=1}^{N_\\theta} \\sum_{k=1}^{N_\\phi}\n\\frac{ \\left((r'_i)^2 \\sin\\theta'_j \\left(r - r'_i \\cos\\theta'_j\\right)\\right) \\, w^{[R_1,R_2]}_i \\, w^{[0,\\pi]}_j \\, w^{[0,2\\pi]}_k }\n{\\left(r^2 + (r'_i)^2 - 2 r r'_i \\cos\\theta'_j\\right)^{3/2}}.\n$$\nThis yields the radial component at the polar axis with units of $\\mathrm{m/s^2}$.\n\nFor the analytical validation, we use the shell theorem and spherical symmetry. For a spherically symmetric shell of uniform density with inner radius $R_1$ and outer radius $R_2$, the total mass is\n$$\nM = \\frac{4\\pi \\rho}{3} \\left(R_2^3 - R_1^3\\right).\n$$\nThe gravitational acceleration is:\n- Outside the shell ($r > R_2$), the field equals that of a point mass at the origin:\n$$\ng_r^{\\text{analytic}}(r) = - \\frac{G M}{r^2}.\n$$\n- Inside the cavity ($r  R_1$), the enclosed mass is zero and\n$$\ng_r^{\\text{analytic}}(r) = 0.\n$$\n- Within the shell material ($R_1  r  R_2$), only the mass enclosed by radius $r$ contributes:\n$$\nM_{\\text{enc}}(r) = \\frac{4\\pi \\rho}{3}\\left(r^3 - R_1^3\\right), \\quad\ng_r^{\\text{analytic}}(r) = - \\frac{G M_{\\text{enc}}(r)}{r^2} = - \\frac{4\\pi G \\rho}{3}\\left(r - \\frac{R_1^3}{r^2}\\right).\n$$\nOur test suite chooses observation radii that avoid the singular case at $r$ exactly equal to a shell boundary, and includes outside and inside regimes.\n\nError metrics:\n- For tests with $g_r^{\\text{analytic}} \\neq 0$, we compute the relative error\n$$\n\\epsilon_{\\text{rel}} = \\frac{\\left|g_r^{\\text{num}} - g_r^{\\text{analytic}}\\right|}{\\left|g_r^{\\text{analytic}}\\right|}.\n$$\n- For tests with $g_r^{\\text{analytic}} = 0$, we compute the absolute error\n$$\n\\epsilon_{\\text{abs}} = \\left|g_r^{\\text{num}}\\right|.\n$$\n\nAlgorithmic design:\n- Implement Gauss-Legendre quadrature using the nodes and weights from the Legendre polynomials; map them to $[0,\\pi]$ for $\\theta'$, to $[0,2\\pi]$ for $\\phi'$, and to $[R_1,R_2]$ for $r'$.\n- Vectorize operations over $\\theta'$ for computational efficiency and sum over quadrature weights.\n- Compute $g_r^{\\text{num}}(r)$ using the discretized integral and the specified quadrature orders.\n- Compute $g_r^{\\text{analytic}}(r)$ using the shell theorem expression appropriate to the regime.\n- Report the discrepancy for each test in the order specified.\n- Ensure all inputs and outputs are in International System of Units (SI), angles in radians, and accelerations in $\\mathrm{m/s^2}$.\n\nThis approach validates that as the tesseroid collapses radially (small $R_2 - R_1$), the numerically integrated field converges to the analytic spherical shell solution both outside and inside the shell, demonstrating consistency between tesseroid-based forward modeling and classical spherical solutions.",
            "answer": "```python\nimport numpy as np\n\n# Constants in SI units\nG = 6.67430e-11  # m^3 kg^-1 s^-2\n\ndef gauss_legendre_nodes_weights(a, b, n):\n    \"\"\"\n    Return Gauss-Legendre nodes and weights mapped from [-1,1] to [a,b].\n    \"\"\"\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Map nodes to [a,b]\n    nodes = 0.5 * (b - a) * xi + 0.5 * (b + a)\n    # Scale weights to [a,b]\n    weights = 0.5 * (b - a) * wi\n    return nodes, weights\n\ndef shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r):\n    \"\"\"\n    Compute the radial component of gravitational acceleration at r_obs (on polar axis)\n    due to a spherically symmetric tesseroid (full angular coverage, radial [R1, R2])\n    using Gauss-Legendre quadrature in r', theta', phi'.\n    \"\"\"\n    # Quadrature in r', theta', phi'\n    r_nodes, r_weights = gauss_legendre_nodes_weights(R1, R2, n_r)\n    th_nodes, th_weights = gauss_legendre_nodes_weights(0.0, np.pi, n_theta)\n    ph_nodes, ph_weights = gauss_legendre_nodes_weights(0.0, 2.0*np.pi, n_phi)\n\n    # Precompute angular quantities\n    cos_th = np.cos(th_nodes)\n    sin_th = np.sin(th_nodes)\n\n    # Sum of phi weights for integrand independent of phi at polar axis\n    Wphi = np.sum(ph_weights)\n\n    # Accumulate integral\n    integral_sum = 0.0\n    for ri, wri in zip(r_nodes, r_weights):\n        # Denominator term |r - r'|^3 depends on theta\n        denom = (r_obs**2 + ri**2 - 2.0*r_obs*ri*cos_th)**1.5\n        # Kernel projected onto radial direction\n        kernel = (ri**2) * sin_th * (r_obs - ri * cos_th) / denom\n        # Weighted sum over theta and phi\n        theta_sum = np.sum(th_weights * kernel)\n        integral_sum += wri * Wphi * theta_sum\n\n    # Multiply by constants and sign\n    g_r = -G * rho * integral_sum\n    return g_r  # m/s^2\n\ndef shell_gravity_radial_analytic(r_obs, R1, R2, rho):\n    \"\"\"\n    Analytic radial gravitational acceleration for a spherically symmetric shell.\n    Handles regimes r  R1, R1  r  R2, r > R2.\n    \"\"\"\n    # Total mass of shell\n    M_total = (4.0 * np.pi * rho / 3.0) * (R2**3 - R1**3)\n    if r_obs  R1:\n        return 0.0\n    elif r_obs > R2:\n        return -G * M_total / (r_obs**2)\n    else:\n        # Within shell volume: only enclosed mass contributes\n        M_enc = (4.0 * np.pi * rho / 3.0) * (r_obs**3 - R1**3)\n        return -G * M_enc / (r_obs**2)\n\ndef discrepancy(g_num, g_analytic):\n    \"\"\"\n    Compute discrepancy: relative error if analytic != 0, else absolute error.\n    \"\"\"\n    if g_analytic != 0.0:\n        return abs((g_num - g_analytic) / g_analytic)\n    else:\n        return abs(g_num)\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Test 1: happy path outside the shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 1000.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 1000.0) + 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n        # Test 2: near-boundary outside with thinner shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 10.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (6.371e6 + 10.0) + 10.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 3: inside the shell with extremely thin shell\n        {\n            \"R1\": 6.371e6,\n            \"R2\": 6.371e6 + 0.1,\n            \"rho\": 3000.0,\n            \"r_obs\": 6.371e6 - 1.0e6,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 2\n        },\n        # Test 4: moderately thin shell outside, mid-range distance\n        {\n            \"R1\": 1.0e6,\n            \"R2\": 1.0e6 + 50.0,\n            \"rho\": 3000.0,\n            \"r_obs\": (1.0e6 + 50.0) + 1.0,\n            \"n_theta\": 64,\n            \"n_phi\": 64,\n            \"n_r\": 4\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R1 = case[\"R1\"]\n        R2 = case[\"R2\"]\n        rho = case[\"rho\"]\n        r_obs = case[\"r_obs\"]\n        n_theta = case[\"n_theta\"]\n        n_phi = case[\"n_phi\"]\n        n_r = case[\"n_r\"]\n\n        g_num = shell_gravity_radial_numeric(r_obs, R1, R2, rho, n_theta, n_phi, n_r)\n        g_ana = shell_gravity_radial_analytic(r_obs, R1, R2, rho)\n        err = discrepancy(g_num, g_ana)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "While analytical solutions are powerful, they are rare for complex geometries. A more general validation technique involves testing whether the numerical model respects fundamental physical laws. This practice guides you through verifying the integral form of Gauss's law for gravity, $\\oiint_{S} \\mathbf{g}\\cdot d\\mathbf{S} = -4\\pi G M_{\\text{enc}}$, for a tesseroid source . Successfully performing this check demonstrates that your model correctly captures the field's divergence properties, a crucial test of physical consistency.",
            "id": "3601768",
            "problem": "Implement a complete numerical validation of the gravitational Gauss’s law analog for a constant-density spherical prism (tesseroid) using first principles and explicit surface and volume integrals. Use the following fundamental base:\n\n- Newtonian gravity: the gravitational acceleration field at position $\\mathbf{r}$ due to a mass density distribution $\\rho(\\mathbf{r}')$ is\n$$\n\\mathbf{g}(\\mathbf{r}) \\;=\\; -G \\int_V \\rho(\\mathbf{r}') \\frac{\\mathbf{r} - \\mathbf{r}'}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3} \\, dV',\n$$\nwhere $G$ is the gravitational constant, $V$ is the source volume, and $dV'$ is the volume element.\n- Divergence of the Newtonian gravitational field: for sufficiently smooth $\\rho$, \n$$\n\\nabla \\cdot \\mathbf{g}(\\mathbf{r}) \\;=\\; -4\\pi G\\, \\rho(\\mathbf{r}).\n$$\n- Divergence theorem (Gauss’s theorem): for a closed surface $S$ enclosing a volume $V$,\n$$\n\\oiint_{S} \\mathbf{g}\\cdot d\\mathbf{S} \\;=\\; \\iiint_{V} \\nabla\\cdot \\mathbf{g}\\, dV \\;=\\; -4\\pi G \\, M_{\\text{enc}},\n$$\nwhere $M_{\\text{enc}}$ is the total mass enclosed by $S$.\n\nYour program must:\n\n1) Model the gravitational field of a single tesseroid with constant density by numerically evaluating the Newtonian volume integral. Represent the tesseroid in spherical coordinates $(r,\\phi,\\lambda)$ where $\\phi$ is geodetic latitude and $\\lambda$ is longitude, both in radians. Use the spherical volume element $dV' = r'^2 \\cos\\phi' \\, dr'\\, d\\phi'\\, d\\lambda'$ and convert the source point coordinates $\\mathbf{r}'$ to Cartesian coordinates when computing the vector differences. The observation points will lie on a spherical surface of radius $R$.\n\n2) Numerically approximate the surface flux $\\Phi$ across the sphere of radius $R$ by discretizing the sphere into latitude-longitude patches. Use the midpoint rule in latitude $\\phi \\in [-\\pi/2,\\pi/2]$ and longitude $\\lambda \\in [-\\pi,\\pi)$ with uniform spacings $\\Delta \\phi$ and $\\Delta \\lambda$. At each patch center $(\\phi_i,\\lambda_j)$, evaluate $\\mathbf{g}$ on the sphere and approximate the contribution to the surface integral by\n$$\n\\Delta \\Phi_{ij} \\;=\\; \\big(\\mathbf{g}(R,\\phi_i,\\lambda_j)\\cdot \\hat{\\mathbf{n}}(\\phi_i,\\lambda_j)\\big) \\, R^2 \\cos\\phi_i \\, \\Delta \\phi \\, \\Delta \\lambda,\n$$\nwhere $\\hat{\\mathbf{n}}$ is the outward unit normal on the sphere at $(\\phi_i,\\lambda_j)$, equal to the radial unit vector.\n\n3) Hold the volume integral discretization fixed using Gauss–Legendre quadrature (GLQ) of order $4$ in each dimension $r$, $\\phi$, and $\\lambda$ for the tesseroid volume integral, and vary only the surface angular resolution $(N_\\phi, N_\\lambda)$ to assess the discretization error of the surface integral.\n\n4) Compute the analytical enclosed mass $M_{\\text{enc}}$ for each test case to form the theoretical flux $-4\\pi G M_{\\text{enc}}$ for comparison. For a tesseroid with constant density $\\rho$ and bounds $\\phi\\in[\\phi_1,\\phi_2]$, $\\lambda\\in[\\lambda_1,\\lambda_2]$, $r\\in[r_1,r_2]$, the total mass is\n$$\nM_{\\text{tot}} \\;=\\; \\rho \\, (\\lambda_2-\\lambda_1) \\, \\big(\\sin\\phi_2 - \\sin\\phi_1\\big) \\, \\frac{r_2^3 - r_1^3}{3}.\n$$\nThe enclosed mass by a sphere of radius $R$ is\n$$\nM_{\\text{enc}} \\;=\\;\n\\begin{cases}\n0,  R \\le r_1,\\\\\nM_{\\text{tot}},  R \\ge r_2,\\\\\nM_{\\text{tot}} \\cdot \\dfrac{R^3 - r_1^3}{r_2^3 - r_1^3},  r_1  R  r_2.\n\\end{cases}\n$$\n\n5) For each test case and each surface resolution, report a dimensionless error. If $M_{\\text{enc}} > 0$, use the relative error\n$$\n\\varepsilon \\;=\\; \\frac{\\left|\\Phi + 4\\pi G M_{\\text{enc}}\\right|}{4\\pi G M_{\\text{enc}}}.\n$$\nIf $M_{\\text{enc}} = 0$, use the scaled absolute flux\n$$\n\\varepsilon \\;=\\; \\frac{\\left|\\Phi\\right|}{4\\pi G M_{\\text{tot}}}.\n$$\n\nUse the following constants, units, and conventions:\n\n- Gravitational constant $G = 6.67430\\times 10^{-11}$ in $\\text{m}^3\\,\\text{kg}^{-1}\\,\\text{s}^{-2}$.\n- Distances in meters, density in $\\text{kg}\\,\\text{m}^{-3}$, angles in radians.\n- Convert spherical to Cartesian using $x = r \\cos\\phi \\cos\\lambda$, $y = r \\cos\\phi \\sin\\lambda$, $z = r \\sin\\phi$.\n- The outward normal on the sphere at $(R,\\phi,\\lambda)$ is the unit radial vector $\\hat{\\mathbf{n}} = \\mathbf{r}/\\lVert \\mathbf{r}\\rVert$.\n\nTest suite:\n\n- Test case $1$ (enclosed tesseroid):\n  - Sphere radius $R_1 = 4.0\\times 10^6$.\n  - Tesseroid bounds: $\\phi \\in [-0.2,\\, 0.2]$, $\\lambda \\in [0.5,\\, 0.9]$, $r \\in [3.1\\times 10^6,\\, 3.3\\times 10^6]$, density $\\rho = 3300$.\n\n- Test case $2$ (tesseroid entirely outside the sphere):\n  - Sphere radius $R_2 = 3.0\\times 10^6$.\n  - Tesseroid bounds: $\\phi \\in [0.1,\\, 0.3]$, $\\lambda \\in [-1.0,\\, -0.6]$, $r \\in [3.6\\times 10^6,\\, 3.8\\times 10^6]$, density $\\rho = 3500$.\n\n- Test case $3$ (partial radial intersection):\n  - Sphere radius $R_3 = 3.7\\times 10^6$.\n  - Tesseroid bounds: $\\phi \\in [-0.4,\\, 0.0]$, $\\lambda \\in [1.2,\\, 1.6]$, $r \\in [3.5\\times 10^6,\\, 3.9\\times 10^6]$, density $\\rho = 3000$.\n\nSurface angular resolutions to assess:\n- $(N_\\phi, N_\\lambda) \\in \\{(8,16), (16,32), (32,64)\\}$.\n\nNumerical implementation requirements:\n\n- Use Gauss–Legendre quadrature of order $4$ along each tesseroid dimension $(r,\\phi,\\lambda)$ to approximate the volume integral for $\\mathbf{g}$ at a given observation point, holding this fixed across all tests.\n- Use the midpoint rule with uniform $\\phi$ and $\\lambda$ spacings on the sphere for the surface flux integral, varying only $(N_\\phi, N_\\lambda)$ as given above.\n\nAnswer specification:\n\n- For each test case $k \\in \\{1,2,3\\}$ and for each resolution in the order $(8,16)$, $(16,32)$, $(32,64)$, compute the error $\\varepsilon_{k,m}$ as defined above. The final program output must be a single line containing a list of the $9$ floating-point errors in the following order:\n$$\n[\\varepsilon_{1,(8,16)},\\ \\varepsilon_{1,(16,32)},\\ \\varepsilon_{1,(32,64)},\\ \\varepsilon_{2,(8,16)},\\ \\varepsilon_{2,(16,32)},\\ \\varepsilon_{2,(32,64)},\\ \\varepsilon_{3,(8,16)},\\ \\varepsilon_{3,(16,32)},\\ \\varepsilon_{3,(32,64)}].\n$$\n\n- The output must be printed as a single line, in square brackets, with comma-separated decimal numbers. The errors are dimensionless as defined above. No other text should be printed.",
            "solution": "The problem requires a numerical validation of the gravitational divergence theorem, also known as Gauss's law for gravity, for a source mass in the shape of a tesseroid (a spherical prism) with constant density. The validation involves comparing the flux of the gravitational field across a closed spherical surface with the theoretical value determined by the mass enclosed within that surface.\n\nThe fundamental principles are given by Newtonian gravity and vector calculus. The gravitational field $\\mathbf{g}$ at a position $\\mathbf{r}$ created by a mass distribution with density $\\rho(\\mathbf{r}')$ over a volume $V'$ is\n$$\n\\mathbf{g}(\\mathbf{r}) = -G \\int_{V'} \\rho(\\mathbf{r}') \\frac{\\mathbf{r} - \\mathbf{r}'}{\\lVert \\mathbf{r} - \\mathbf{r}' \\rVert^3} \\, dV',\n$$\nwhere $G$ is the gravitational constant. The divergence theorem relates the flux of a vector field through a closed surface $S$ to the integral of its divergence over the enclosed volume $V$:\n$$\n\\oiint_{S} \\mathbf{g} \\cdot d\\mathbf{S} = \\iiint_{V} (\\nabla \\cdot \\mathbf{g}) \\, dV.\n$$\nFor the Newtonian gravitational field, the divergence is $\\nabla \\cdot \\mathbf{g} = -4\\pi G \\rho$. Substituting this into the divergence theorem gives Gauss's law for gravity:\n$$\n\\Phi = \\oiint_{S} \\mathbf{g} \\cdot d\\mathbf{S} = -4\\pi G \\iiint_{V} \\rho \\, dV = -4\\pi G M_{\\text{enc}},\n$$\nwhere $\\Phi$ is the gravitational flux and $M_{\\text{enc}}$ is the total mass enclosed by the surface $S$.\n\nOur task is to numerically compute both sides of this equation for a tesseroid source and a spherical enclosing surface, and then quantify the error.\n\nFirst, we address the analytical calculation of the enclosed mass, $M_{\\text{enc}}$. The tesseroid is defined in spherical coordinates $(r, \\phi, \\lambda)$ with bounds $r \\in [r_1, r_2]$, $\\phi \\in [\\phi_1, \\phi_2]$, and $\\lambda \\in [\\lambda_1, \\lambda_2]$. Its total mass $M_{\\text{tot}}$ for a constant density $\\rho$ is found by integrating the spherical volume element $dV' = r'^2 \\cos\\phi' \\, dr' d\\phi' d\\lambda'$:\n$$\nM_{\\text{tot}} = \\int_{r_1}^{r_2} \\int_{\\phi_1}^{\\phi_2} \\int_{\\lambda_1}^{\\lambda_2} \\rho \\, r'^2 \\cos\\phi' \\, d\\lambda' d\\phi' dr' = \\rho (\\lambda_2 - \\lambda_1) (\\sin\\phi_2 - \\sin\\phi_1) \\frac{r_2^3 - r_1^3}{3}.\n$$\nThe enclosing surface is a sphere of radius $R$. The mass enclosed, $M_{\\text{enc}}$, depends on the intersection of this sphere with the tesseroid. As the problem specifies, the intersection only occurs along the radial direction. Thus, $M_{\\text{enc}}$ is calculated by integrating the density over the volume of the tesseroid that lies inside the sphere of radius $R$. This yields the provided piecewise formula:\n$$\nM_{\\text{enc}} \\;=\\;\n\\begin{cases}\n0,  R \\le r_1,\\\\\nM_{\\text{tot}},  R \\ge r_2,\\\\\n\\rho \\, (\\lambda_2-\\lambda_1) \\, (\\sin\\phi_2 - \\sin\\phi_1) \\, \\frac{R^3 - r_1^3}{3},  r_1  R  r_2.\n\\end{cases}\n$$\nThe theoretical flux is then $\\Phi_{\\text{theory}} = -4\\pi G M_{\\text{enc}}$.\n\nNext, we design the numerical computation of the surface flux $\\Phi = \\oiint_S \\mathbf{g} \\cdot d\\mathbf{S}$. This requires a two-step numerical integration process.\n\nStep 1: Compute the gravitational field $\\mathbf{g}(\\mathbf{r})$ at an arbitrary observation point $\\mathbf{r}$ on the spherical surface $S$. This itself requires a volume integral over the tesseroid. We use a $4$-th order Gauss-Legendre Quadrature (GLQ) in each of the three dimensions $(r', \\phi', \\lambda')$. The integral for $\\mathbf{g}(\\mathbf{r})$ is transformed from the tesseroid's domain $[r_1, r_2] \\times [\\phi_1, \\phi_2] \\times [\\lambda_1, \\lambda_2]$ to the GLQ domain $[-1, 1]^3$. Let $(\\xi_{r}, \\xi_{\\phi}, \\xi_{\\lambda})$ be the coordinates in the GLQ domain. The coordinate transformation is:\n$$\nr'(\\xi_r) = \\frac{r_2-r_1}{2}\\xi_r + \\frac{r_2+r_1}{2}, \\quad \\phi'(\\xi_\\phi) = \\frac{\\phi_2-\\phi_1}{2}\\xi_\\phi + \\frac{\\phi_2+\\phi_1}{2}, \\quad \\lambda'(\\xi_\\lambda) = \\frac{\\lambda_2-\\lambda_1}{2}\\xi_\\lambda + \\frac{\\lambda_2+\\lambda_1}{2}.\n$$\nThe Jacobian of this transformation is $J = \\frac{r_2-r_1}{2} \\frac{\\phi_2-\\phi_1}{2} \\frac{\\lambda_2-\\lambda_1}{2}$. The integral for $\\mathbf{g}$ becomes a summation over the $4 \\times 4 \\times 4 = 64$ GLQ nodes:\n$$\n\\mathbf{g}(\\mathbf{r}) \\approx -G \\rho J \\sum_{i=1}^{4} \\sum_{j=1}^{4} \\sum_{k=1}^{4} w_i w_j w_k \\frac{\\mathbf{r} - \\mathbf{r}'_{ijk}}{\\lVert \\mathbf{r} - \\mathbf{r}'_{ijk} \\rVert^3} (r'_i)^2 \\cos(\\phi'_j).\n$$\nHere, $w_i, w_j, w_k$ are the GLQ weights. The observation point $\\mathbf{r}$ and the source points $\\mathbf{r}'_{ijk}$ (corresponding to the GLQ nodes) must be represented in Cartesian coordinates to compute the vector difference. The conversion from spherical $(r, \\phi, \\lambda)$ to Cartesian $(x, y, z)$ is $x = r \\cos\\phi \\cos\\lambda$, $y = r \\cos\\phi \\sin\\lambda$, $z = r \\sin\\phi$.\n\nStep 2: Compute the surface flux integral $\\Phi$. The spherical surface $S$ of radius $R$ is discretized into $N_\\phi \\times N_\\lambda$ patches. We use the midpoint rule. The grid spacings are $\\Delta\\phi = \\pi/N_\\phi$ and $\\Delta\\lambda = 2\\pi/N_\\lambda$. The center of each patch $(i,j)$ is $(\\phi_i, \\lambda_j)$, where $\\phi_i = -\\pi/2 + (i+0.5)\\Delta\\phi$ for $i \\in [0, N_\\phi-1]$ and $\\lambda_j = -\\pi + (j+0.5)\\Delta\\lambda$ for $j \\in [0, N_\\lambda-1]$. The surface element is $d\\mathbf{S} = \\hat{\\mathbf{n}} \\, dS$, where $dS = R^2 \\cos\\phi \\, d\\phi d\\lambda$ and $\\hat{\\mathbf{n}}$ is the outward unit normal. For a sphere, $\\hat{\\mathbf{n}}$ is simply the radial unit vector $\\mathbf{r}/R$. The flux integral is approximated by the sum:\n$$\n\\Phi \\approx \\sum_{i=0}^{N_\\phi-1} \\sum_{j=0}^{N_\\lambda-1} \\left( \\mathbf{g}(R, \\phi_i, \\lambda_j) \\cdot \\hat{\\mathbf{n}}(\\phi_i, \\lambda_j) \\right) R^2 \\cos(\\phi_i) \\Delta\\phi \\Delta\\lambda.\n$$\nFor each patch center $(\\phi_i, \\lambda_j)$, the field $\\mathbf{g}$ is computed using the GLQ method described in Step 1.\n\nFinally, the numerical error $\\varepsilon$ is computed. When $M_{\\text{enc}} > 0$, we use the relative error:\n$$\n\\varepsilon = \\frac{|\\Phi - \\Phi_{\\text{theory}}|}{|\\Phi_{\\text{theory}}|} = \\frac{|\\Phi + 4\\pi G M_{\\text{enc}}|}{4\\pi G M_{\\text{enc}}}.\n$$\nWhen $M_{\\text{enc}} = 0$, the theoretical flux is zero, so a relative error is undefined. Instead, we use a scaled absolute flux, normalized by the theoretical flux corresponding to the tesseroid's total mass $M_{\\text{tot}}$:\n$$\n\\varepsilon = \\frac{|\\Phi|}{4\\pi G M_{\\text{tot}}}.\n$$\nThis procedure is repeated for three test cases with different geometric configurations and for three different surface discretization resolutions $(N_\\phi, N_\\lambda)$, allowing us to observe the convergence of the surface integral approximation. The volume integral approximation for $\\mathbf{g}$ is held fixed with a $4$-th order GLQ throughout.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform the numerical validation of Gauss's law for gravity.\n    \"\"\"\n    # Constants\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n\n    # Test cases: (R, (phi1, phi2, lam1, lam2, r1, r2, rho))\n    test_cases = [\n        # Test case 1 (enclosed tesseroid)\n        (4.0e6, (-0.2, 0.2, 0.5, 0.9, 3.1e6, 3.3e6, 3300.0)),\n        # Test case 2 (tesseroid entirely outside the sphere)\n        (3.0e6, (0.1, 0.3, -1.0, -0.6, 3.6e6, 3.8e6, 3500.0)),\n        # Test case 3 (partial radial intersection)\n        (3.7e6, (-0.4, 0.0, 1.2, 1.6, 3.5e6, 3.9e6, 3000.0)),\n    ]\n\n    # Surface angular resolutions\n    resolutions = [(8, 16), (16, 32), (32, 64)]\n\n    # Gauss-Legendre Quadrature nodes and weights for order 4.\n    # Hardcoded to avoid reliance on numpy.polynomial.\n    glq_order = 4\n    glq_nodes = np.array([-0.8611363115940526, -0.3399810435848563, 0.3399810435848563, 0.8611363115940526])\n    glq_weights = np.array([0.3478548451374538, 0.6521451548625461, 0.6521451548625461, 0.3478548451374538])\n\n    def spherical_to_cartesian(r, phi, lam):\n        \"\"\"Converts spherical coordinates (r, lat, lon) to Cartesian (x, y, z).\"\"\"\n        x = r * np.cos(phi) * np.cos(lam)\n        y = r * np.cos(phi) * np.sin(lam)\n        z = r * np.sin(phi)\n        return np.array([x, y, z])\n\n    def calculate_g(obs_point_cart, tesseroid_params):\n        \"\"\"\n        Calculates the gravitational field g at an observation point using GLQ.\n        \"\"\"\n        phi1, phi2, lam1, lam2, r1, r2, rho = tesseroid_params\n        \n        # Transformation factors for GLQ\n        r_scale = (r2 - r1) / 2.0\n        r_offset = (r2 + r1) / 2.0\n        phi_scale = (phi2 - phi1) / 2.0\n        phi_offset = (phi2 + phi1) / 2.0\n        lam_scale = (lam2 - lam1) / 2.0\n        lam_offset = (lam2 + lam1) / 2.0\n        \n        jacobian_factor = r_scale * phi_scale * lam_scale\n        \n        g_vec = np.zeros(3)\n        \n        # 3D Gauss-Legendre Quadrature\n        for i in range(glq_order):\n            r_prime = r_scale * glq_nodes[i] + r_offset\n            for j in range(glq_order):\n                phi_prime = phi_scale * glq_nodes[j] + phi_offset\n                for k in range(glq_order):\n                    lam_prime = lam_scale * glq_nodes[k] + lam_offset\n                    \n                    src_point_cart = spherical_to_cartesian(r_prime, phi_prime, lam_prime)\n                    \n                    diff_vec = obs_point_cart - src_point_cart\n                    dist_sq = np.sum(diff_vec**2)\n                    dist = np.sqrt(dist_sq)\n                    \n                    # Kernel of the integral\n                    integrand_vec = diff_vec / (dist**3)\n                    \n                    # Volume element part and jacobian\n                    volume_factor = r_prime**2 * np.cos(phi_prime)\n                    \n                    w_ijk = glq_weights[i] * glq_weights[j] * glq_weights[k]\n                    g_vec += w_ijk * integrand_vec * volume_factor\n                    \n        return -G * rho * jacobian_factor * g_vec\n\n    def calculate_masses(tesseroid_params, R):\n        \"\"\"Calculates total mass and enclosed mass.\"\"\"\n        phi1, phi2, lam1, lam2, r1, r2, rho = tesseroid_params\n        \n        # Total mass\n        m_tot = rho * (lam2 - lam1) * (np.sin(phi2) - np.sin(phi1)) * (r2**3 - r1**3) / 3.0\n        \n        # Enclosed mass\n        if R = r1:\n            m_enc = 0.0\n        elif R >= r2:\n            m_enc = m_tot\n        else: # r1  R  r2\n            m_enc = rho * (lam2 - lam1) * (np.sin(phi2) - np.sin(phi1)) * (R**3 - r1**3) / 3.0\n            \n        return m_tot, m_enc\n\n    results = []\n    \n    for case_idx, (R, tesseroid_params) in enumerate(test_cases):\n        \n        m_tot, m_enc = calculate_masses(tesseroid_params, R)\n        \n        if m_enc > 0:\n            flux_theory = -4.0 * np.pi * G * m_enc\n        else: # m_enc == 0\n            flux_theory = 0.0\n        \n        for n_phi, n_lambda in resolutions:\n            \n            delta_phi = np.pi / n_phi\n            delta_lambda = 2.0 * np.pi / n_lambda\n            \n            total_flux = 0.0\n            \n            phi_midpoints = -np.pi / 2.0 + (np.arange(n_phi) + 0.5) * delta_phi\n            lambda_midpoints = -np.pi + (np.arange(n_lambda) + 0.5) * delta_lambda\n\n            for phi_i in phi_midpoints:\n                for lambda_j in lambda_midpoints:\n                    \n                    obs_point_cart = spherical_to_cartesian(R, phi_i, lambda_j)\n                    \n                    # Compute gravitational vector at the observation point\n                    g_at_obs = calculate_g(obs_point_cart, tesseroid_params)\n                    \n                    # Outward normal vector on the sphere\n                    n_hat = obs_point_cart / R\n                    \n                    # Differential surface area element\n                    dS = R**2 * np.cos(phi_i) * delta_phi * delta_lambda\n                    \n                    # Contribution to flux\n                    flux_element = np.dot(g_at_obs, n_hat) * dS\n                    total_flux += flux_element\n\n            # Calculate error\n            if m_enc > 0.0:\n                error = np.abs(total_flux + 4.0 * np.pi * G * m_enc) / (4.0 * np.pi * G * m_enc)\n            else: # m_enc == 0.0\n                if m_tot > 0.0:\n                    error = np.abs(total_flux) / (4.0 * np.pi * G * m_tot)\n                else:\n                    error = 0.0  # Should not happen with given test cases\n\n            results.append(error)\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A numerically accurate model must also be robust, producing physically sensible results even in degenerate or singular configurations. This practice focuses on unit testing for such edge cases, including zero-volume cells and observation points located on the faces or edges of the source body . By ensuring your code handles these scenarios correctly—for instance, by yielding finite results at surface singularities and preserving expected symmetries—you are building a reliable tool ready for complex, real-world modeling tasks.",
            "id": "3601751",
            "problem": "You are tasked with implementing and validating a gravity forward modeling routine for two classes of Earth models: a rectangular polyhedron and a spherical tesseroid. The implementation must be robust to degenerate geometric configurations and observation locations that lie exactly on faces or edges. Your program must be a complete, runnable program that evaluates a fixed test suite of cases and outputs the results as a single line.\n\nThe fundamental base that you must use is the Newtonian law of gravitation. For a body with constant density, the gravitational acceleration at an observation point with position vector $\\mathbf{r}_0$ due to a mass distribution occupying a region $V$ with density $\\rho$ is given by\n$$\n\\mathbf{g}(\\mathbf{r}_0) \\;=\\; G \\, \\rho \\int\\!\\!\\!\\int\\!\\!\\!\\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV,\n$$\nwhere $G$ is the Newtonian gravitational constant, $\\mathbf{r}$ is the position within the source, and $dV$ is the volume element. For a rectangular prism aligned with the Cartesian axes with bounds $x \\in [x_{\\min}, x_{\\max}]$, $y \\in [y_{\\min}, y_{\\max}]$, and $z \\in [z_{\\min}, z_{\\max}]$, use the Cartesian volume element $dV = dx \\, dy \\, dz$. For a spherical tesseroid described in spherical coordinates by radius $r \\in [r_1, r_2]$, colatitude $\\theta \\in [\\theta_1, \\theta_2]$ (with $\\theta = 0$ at the North Pole), and longitude $\\lambda \\in [\\lambda_1, \\lambda_2]$, use the spherical volume element $dV = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\lambda$. In all cases, take $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$ and express gravitational acceleration in $\\mathrm{m/s^2}$.\n\nYour implementation must evaluate the volume integral numerically using stable and convergent quadrature. You must ensure that:\n- If the geometric cell has zero volume (e.g., any bound interval length is zero), the modeled gravitational acceleration is exactly $\\mathbf{0}$ for any observation point and finite density.\n- If the observation point lies on a face or edge of the cell, the modeled gravitational acceleration remains finite.\n- Symmetry is respected so that components that should cancel by symmetry are numerically close to zero.\n\nTo make this concrete and testable, implement two forward-modeling routines:\n- A routine for a rectangular prism (a special case of a polyhedron) aligned with the Cartesian axes. The routine must accept $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max}, z_{\\min}, z_{\\max})$, density $\\rho$, and the observation point coordinates $(x_0, y_0, z_0)$, and must return the vector $\\mathbf{g}$.\n- A routine for a tesseroid defined by $(r_1, r_2, \\theta_1, \\theta_2, \\lambda_1, \\lambda_2)$, density $\\rho$, and an observation point given in spherical coordinates $(r_0, \\theta_0, \\lambda_0)$. The routine must return the gravitational acceleration vector in Cartesian coordinates $\\mathbf{g}$ as well as its spherical components at the observation location, i.e., the radial component $g_r$, the colatitudinal component $g_\\theta$, and the longitudinal component $g_\\lambda$ formed by projecting $\\mathbf{g}$ onto the local orthonormal basis $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$.\n\nAngles must be in radians. All distances must be in meters, and density in $\\mathrm{kg/m^3}$. Your numerical integration must use at least a sixth-order Gaussian quadrature in each dimension to ensure adequate accuracy for the tests below.\n\nDesign and run the following test suite. For each case, compute the indicated check and produce a boolean outcome. All comparisons to zero must be interpreted numerically with a tight tolerance chosen by you to reflect double-precision numerical accuracy and the modeled signal magnitudes.\n\nTest suite:\n- Test $1$ (zero-volume rectangular polyhedron): Let $x \\in [0, 1000] \\, \\mathrm{m}$, $y \\in [0, 1000] \\, \\mathrm{m}$, $z \\in [2000, 2000] \\, \\mathrm{m}$, density $\\rho = 2670 \\, \\mathrm{kg/m^3}$, and observation point $(x_0, y_0, z_0) = (100, 100, 0) \\, \\mathrm{m}$. Expected outcome: the modeled $\\mathbf{g}$ has magnitude equal to $0$ (within numerical tolerance), i.e., return boolean true if $\\|\\mathbf{g}\\|$ is numerically zero.\n- Test $2$ (observation on a face center of a rectangular polyhedron): Let $x \\in [-500, 500] \\, \\mathrm{m}$, $y \\in [-500, 500] \\, \\mathrm{m}$, $z \\in [0, 100] \\, \\mathrm{m}$, density $\\rho = 2670 \\, \\mathrm{kg/m^3}$, and observation point $(x_0, y_0, z_0) = (0, 0, 0) \\, \\mathrm{m}$. Expected outcome: by symmetry, $g_x$ and $g_y$ are numerically zero, and $g_z$ is finite and strictly positive; return boolean true if these conditions all hold.\n- Test $3$ (zero-volume tesseroid): Let $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6}] \\, \\mathrm{m}$, $\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$, $\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$, density $\\rho = 3000 \\, \\mathrm{kg/m^3}$, and observation point $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$. Expected outcome: the modeled $\\mathbf{g}$ has magnitude equal to $0$ (within numerical tolerance); return boolean true if $\\|\\mathbf{g}\\|$ is numerically zero.\n- Test $4$ (observation on an inner radial face at angular symmetry center of a tesseroid): Let $r \\in [6.371 \\times 10^{6}, 6.371 \\times 10^{6} + 1000] \\, \\mathrm{m}$, $\\theta \\in [\\frac{\\pi}{2} - 0.01, \\frac{\\pi}{2} + 0.01] \\, \\mathrm{rad}$, $\\lambda \\in [-0.01, 0.01] \\, \\mathrm{rad}$, density $\\rho = 3000 \\, \\mathrm{kg/m^3}$, and observation point $(r_0, \\theta_0, \\lambda_0) = (6.371 \\times 10^{6}, \\frac{\\pi}{2}, 0)$. Expected outcome: due to angular symmetry, the tangential components are numerically zero and the radial component $g_r$ is finite and strictly positive; return boolean true if $g_r > 0$ and the tangential magnitude $\\sqrt{g_\\theta^2 + g_\\lambda^2}$ is numerically negligible relative to $g_r$.\n- Test $5$ (observation on a face edge of a rectangular polyhedron): Using the same rectangular polyhedron as in Test $2$, set the observation point to $(x_0, y_0, z_0) = (500, 0, 0) \\, \\mathrm{m}$ (a lower-face edge midpoint). Expected outcome: by symmetry across the plane $y = 0$, $g_y$ is numerically zero, and $g_z$ is finite and strictly positive; return boolean true if these conditions both hold.\n\nYour program must compute the booleans for Tests $1$ through $5$ in order and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$. All angles must be in radians, and all distances in meters. All gravitational accelerations must be evaluated and interpreted in $\\mathrm{m/s^2}$. No user input is permitted; all parameters are as specified above and must be hard-coded in your program.",
            "solution": "The problem is valid as it is scientifically grounded in Newtonian physics, well-posed with sufficient information for a unique solution, and objective in its formulation. All parameters and test conditions are clearly specified. The problem will be solved by implementing the requested numerical integration routines.\n\nThe fundamental principle governing this problem is Newton's law of universal gravitation. The gravitational acceleration vector $\\mathbf{g}$ at an observation point $\\mathbf{r}_0$ generated by a continuous mass distribution of constant density $\\rho$ occupying a volume $V$ is given by the volume integral:\n$$\n\\mathbf{g}(\\mathbf{r}_0) = G \\rho \\int_{V} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\left\\lVert \\mathbf{r} - \\mathbf{r}_0 \\right\\rVert^{3}} \\, dV\n$$\nwhere $G$ is the gravitational constant ($6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$), and $\\mathbf{r}$ is the position vector of a mass element within the volume $V$. This vector integral is typically solved by evaluating the integral for each Cartesian component $(g_x, g_y, g_z)$ separately.\n\nThe integral is analytically solvable for a few simple geometries, but for complex shapes or for a general-purpose algorithm, numerical methods are required. The problem specifies the use of at least a sixth-order Gaussian quadrature for this purpose. Gaussian quadrature approximates a definite integral by a weighted sum of function evaluations at specific points (nodes) within the integration interval. A $N$-point scheme is exact for polynomials of degree up to $2N-1$.\n\nFor a three-dimensional integral over a box-like domain, we employ a product rule, creating a three-dimensional grid of quadrature points and a product of weights. For an integral $\\int_{c}^{d}\\int_{a}^{b}\\int_{u}^{v} f(x,y,z) \\,dx\\,dy\\,dz$, the approximation is:\n$$\n\\approx \\frac{v-u}{2}\\frac{b-a}{2}\\frac{d-c}{2} \\sum_{k}\\sum_{j}\\sum_{i} w_i w_j w_k f(x_i, y_j, z_k)\n$$\nwhere $(\\xi_i, w_i)$ are the standard Gaussian quadrature nodes and weights on $[-1, 1]$, and $x_i, y_j, z_k$ are these nodes mapped to their respective integration intervals.\n\nA critical aspect of the problem is the singularity in the integrand, which occurs when the integration point $\\mathbf{r}$ coincides with the observation point $\\mathbf{r}_0$, making the denominator zero. While the integral is convergent, a naive numerical evaluation at the singularity would fail. The problem requires robust handling for observation points on the boundary of the mass model. The use of Gaussian quadrature with an even number of points (e.g., $N=6$) is advantageous as its nodes are symmetrically distributed and do not include the interval's endpoints or midpoint. For centered geometries and observation points, this helps avoid direct evaluation at the singularity. As a safeguard, our implementation will check if an evaluation point is numerically coincident with the observation point and, if so, assign a zero contribution, reflecting the fact that the contribution of an infinitesimal volume at the singularity is itself infinitesimal.\n\n**Part 1: Rectangular Polyhedron (Prism)**\n\nFor a rectangular prism aligned with Cartesian axes, defined by $x \\in [x_{\\min}, x_{\\max}]$, $y \\in [y_{\\min}, y_{\\max}]$, and $z \\in [z_{\\min}, z_{\\max}]$, the volume element is $dV = dx\\,dy\\,dz$. The observation point is $\\mathbf{r}_0 = (x_0, y_0, z_0)$. The $x$-component of the acceleration, $g_x$, is:\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{z_{\\min}}^{z_{\\max}} \\int_{y_{\\min}}^{y_{\\max}} \\int_{x_{\\min}}^{x_{\\max}} \\frac{x-x_0}{\\left( (x-x_0)^2 + (y-y_0)^2 + (z-z_0)^2 \\right)^{3/2}} \\,dx\\,dy\\,dz\n$$\nThe components $g_y$ and $g_z$ are analogous. A $6$-point Gaussian quadrature is applied independently in each dimension. The algorithm first checks for zero-volume cases (e.g., $x_{\\min} = x_{\\max}$), returning a zero vector. Otherwise, it proceeds with the triple-loop quadrature summation.\n\n**Part 2: Spherical Tesseroid**\n\nA tesseroid is a \"spherical prism\" defined in a spherical coordinate system by $r \\in [r_1, r_2]$, colatitude $\\theta \\in [\\theta_1, \\theta_2]$, and longitude $\\lambda \\in [\\lambda_1, \\lambda_2]$. The volume element is $dV = r^2 \\sin\\theta \\,dr\\,d\\theta\\,d\\lambda$. The physical calculation of the vector difference $\\mathbf{r} - \\mathbf{r}_0$ is most straightforward in a common coordinate system. We use Cartesian coordinates for this. Both the integration point $\\mathbf{r}(r, \\theta, \\lambda)$ and the observation point $\\mathbf{r}_0(r_0, \\theta_0, \\lambda_0)$ are converted to Cartesian coordinates $(x,y,z)$:\n$$\nx = r \\sin\\theta \\cos\\lambda, \\quad y = r \\sin\\theta \\sin\\lambda, \\quad z = r \\cos\\theta\n$$\nThe integral for each Cartesian component of acceleration is then computed numerically using a 3D Gaussian quadrature over $r, \\theta, \\lambda$. For example, the $x$-component is:\n$$\ng_x(\\mathbf{r}_0) = G \\rho \\int_{r_1}^{r_2} \\int_{\\theta_1}^{\\theta_2} \\int_{\\lambda_1}^{\\lambda_2} \\frac{x(r, \\theta, \\lambda) - x_0}{\\left\\lVert \\mathbf{r}(r, \\theta, \\lambda) - \\mathbf{r}_0 \\right\\rVert^{3}} r^2 \\sin\\theta \\,d\\lambda\\,d\\theta\\,dr\n$$\nAfter computing the Cartesian acceleration vector $\\mathbf{g} = (g_x, g_y, g_z)$, it is projected onto the local spherical basis vectors $\\{\\hat{\\mathbf{e}}_r, \\hat{\\mathbf{e}}_\\theta, \\hat{\\mathbf{e}}_\\lambda\\}$ at the observation point to find the spherical components $(g_r, g_\\theta, g_\\lambda)$. The basis vectors are:\n$$\n\\hat{\\mathbf{e}}_r = (\\sin\\theta_0 \\cos\\lambda_0, \\sin\\theta_0 \\sin\\lambda_0, \\cos\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\theta = (\\cos\\theta_0 \\cos\\lambda_0, \\cos\\theta_0 \\sin\\lambda_0, -\\sin\\theta_0) \\\\\n\\hat{\\mathbf{e}}_\\lambda = (-\\sin\\lambda_0, \\cos\\lambda_0, 0)\n$$\nThe components are then $g_r = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_r$, $g_\\theta = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\theta$, and $g_\\lambda = \\mathbf{g} \\cdot \\hat{\\mathbf{e}}_\\lambda$.\n\nThis dual-model implementation, with careful handling of geometry, coordinate systems, and numerical stability, allows for the validation of the specified test cases, which probe its correctness in situations of zero volume, boundary observations, and symmetry.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for gravity forward modeling.\n    \"\"\"\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    N_QUAD = 6       # Order of Gaussian quadrature\n    ABS_TOL = 1e-15  # Absolute tolerance for checking against zero\n    REL_TOL = 1e-9   # Relative tolerance for symmetry checks\n\n    # Pre-calculate Gaussian quadrature nodes and weights for interval [-1, 1]\n    quad_nodes, quad_weights = roots_legendre(N_QUAD)\n\n    def gravity_polyhedron(bounds, rho, p_obs, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a rectangular prism.\n\n        Args:\n            bounds (tuple): (xmin, xmax, ymin, ymax, zmin, zmax) in meters.\n            rho (float): Density in kg/m^3.\n            p_obs (tuple): Observation point (x0, y0, z0) in meters.\n            n_quad (int): Number of quadrature points per dimension.\n\n        Returns:\n            tuple: The gravitational acceleration vector (gx, gy, gz) in m/s^2.\n        \"\"\"\n        xmin, xmax, ymin, ymax, zmin, zmax = bounds\n        x0, y0, z0 = p_obs\n\n        # Zero volume check\n        if abs(xmax - xmin)  ABS_TOL or abs(ymax - ymin)  ABS_TOL or abs(zmax - zmin)  ABS_TOL:\n            return (0.0, 0.0, 0.0)\n\n        # Map nodes and weights to integration intervals\n        x_range, y_range, z_range = xmax - xmin, ymax - ymin, zmax - zmin\n        x_nodes = 0.5 * x_range * quad_nodes + 0.5 * (xmax + xmin)\n        y_nodes = 0.5 * y_range * quad_nodes + 0.5 * (ymax + ymin)\n        z_nodes = 0.5 * z_range * quad_nodes + 0.5 * (zmax + zmin)\n\n        g_vec = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    x, y, z = x_nodes[i], y_nodes[j], z_nodes[k]\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    \n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue \n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    \n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    g_vec[0] += w * dx * inv_dist_cubed\n                    g_vec[1] += w * dy * inv_dist_cubed\n                    g_vec[2] += w * dz * inv_dist_cubed\n        \n        # Scaling factor for integration\n        scale_factor = G * rho * (x_range / 2) * (y_range / 2) * (z_range / 2)\n        g_vec *= scale_factor\n        \n        return tuple(g_vec)\n\n    def sph_to_cart(r, theta, lamb):\n        \"\"\"Converts spherical to Cartesian coordinates.\"\"\"\n        sin_theta = np.sin(theta)\n        return (\n            r * sin_theta * np.cos(lamb),\n            r * sin_theta * np.sin(lamb),\n            r * np.cos(theta)\n        )\n\n    def gravity_tesseroid(bounds, rho, p_obs_sph, n_quad):\n        \"\"\"\n        Calculates gravitational acceleration of a tesseroid.\n        \n        Returns both Cartesian and local spherical components of gravity vector.\n        \"\"\"\n        r1, r2, t1, t2, l1, l2 = bounds\n        r0, t0, l0 = p_obs_sph\n\n        if abs(r2 - r1)  ABS_TOL or abs(t2 - t1)  ABS_TOL or abs(l2 - l1)  ABS_TOL:\n            return ((0.0, 0.0, 0.0), (0.0, 0.0, 0.0))\n\n        x0, y0, z0 = sph_to_cart(r0, t0, l0)\n\n        r_range, t_range, l_range = r2 - r1, t2 - t1, l2 - l1\n        r_nodes = 0.5 * r_range * quad_nodes + 0.5 * (r2 + r1)\n        t_nodes = 0.5 * t_range * quad_nodes + 0.5 * (t2 + t1)\n        l_nodes = 0.5 * l_range * quad_nodes + 0.5 * (l2 + l1)\n\n        g_vec_cart = np.zeros(3)\n\n        for i in range(n_quad):\n            for j in range(n_quad):\n                for k in range(n_quad):\n                    r, theta, lamb = r_nodes[i], t_nodes[j], l_nodes[k]\n                    x, y, z = sph_to_cart(r, theta, lamb)\n                    \n                    dx, dy, dz = x - x0, y - y0, z - z0\n                    dist_sq = dx**2 + dy**2 + dz**2\n                    \n                    if dist_sq  ABS_TOL**2:\n                        continue\n                    \n                    inv_dist_cubed = dist_sq**(-1.5)\n                    vol_element_factor = r**2 * np.sin(theta)\n                    w = quad_weights[i] * quad_weights[j] * quad_weights[k]\n                    \n                    g_vec_cart[0] += w * dx * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[1] += w * dy * inv_dist_cubed * vol_element_factor\n                    g_vec_cart[2] += w * dz * inv_dist_cubed * vol_element_factor\n\n        scale_factor = G * rho * (r_range / 2) * (t_range / 2) * (l_range / 2)\n        g_vec_cart *= scale_factor\n        \n        # Project to spherical components at observation point\n        sin_t0, cos_t0 = np.sin(t0), np.cos(t0)\n        sin_l0, cos_l0 = np.sin(l0), np.cos(l0)\n        \n        e_r = np.array([sin_t0 * cos_l0, sin_t0 * sin_l0, cos_t0])\n        e_theta = np.array([cos_t0 * cos_l0, cos_t0 * sin_l0, -sin_t0])\n        e_lambda = np.array([-sin_l0, cos_l0, 0])\n        \n        g_r = np.dot(g_vec_cart, e_r)\n        g_theta = np.dot(g_vec_cart, e_theta)\n        g_lambda = np.dot(g_vec_cart, e_lambda)\n\n        return tuple(g_vec_cart), (g_r, g_theta, g_lambda)\n\n    results = []\n\n    # Test 1: Zero-volume rectangular polyhedron\n    g = gravity_polyhedron(bounds=(0, 1000, 0, 1000, 2000, 2000), rho=2670, p_obs=(100, 100, 0), n_quad=N_QUAD)\n    norm_g = np.linalg.norm(g)\n    results.append(norm_g  ABS_TOL)\n\n    # Test 2: Observation on a face center of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(0, 0, 0), n_quad=N_QUAD)\n    gx, gy, gz = g\n    results.append(abs(gx)  ABS_TOL and abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Test 3: Zero-volume tesseroid\n    g_cart, _ = gravity_tesseroid(bounds=(6.371e6, 6.371e6, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    norm_g_cart = np.linalg.norm(g_cart)\n    results.append(norm_g_cart  ABS_TOL)\n\n    # Test 4: Observation on an inner radial face at angular symmetry center of a tesseroid\n    _, g_sph = gravity_tesseroid(bounds=(6.371e6, 6.371e6 + 1000, np.pi/2 - 0.01, np.pi/2 + 0.01, -0.01, 0.01), rho=3000, p_obs_sph=(6.371e6, np.pi/2, 0), n_quad=N_QUAD)\n    gr, gtheta, glambda = g_sph\n    tangential_mag = np.sqrt(gtheta**2 + glambda**2)\n    results.append(gr > ABS_TOL and tangential_mag  REL_TOL * abs(gr))\n\n    # Test 5: Observation on a face edge of a rectangular polyhedron\n    g = gravity_polyhedron(bounds=(-500, 500, -500, 500, 0, 100), rho=2670, p_obs=(500, 0, 0), n_quad=N_QUAD)\n    _, gy, gz = g\n    results.append(abs(gy)  ABS_TOL and gz > ABS_TOL)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```"
        }
    ]
}