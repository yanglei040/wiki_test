{
    "hands_on_practices": [
        {
            "introduction": "对于高维地球物理反演问题，高效计算负对数后验概率密度函数的梯度是核心挑战。伴随状态法是解决这一问题的标准技术，它避免了直接构造巨大的雅可比矩阵。本练习旨在通过一个简化的层析成像问题，让您亲手实现伴随方法计算梯度，并使用泰勒检验（一种有限差分方法）来验证其正确性，这是开发可靠反演代码的一项关键调试技能 。",
            "id": "3577517",
            "problem": "给定一个线性化的一维走时层析成像设置，它在计算地球物理学中用作简化的正演模型。未知的地下慢度模型由向量 $m \\in \\mathbb{R}^N$ 表示，其中每个分量参数化一个单位长度的单元格。每个数据点是一次走时测量，其模型是对一个连续单元格块的求和。这产生一个线性正演算子 $A \\in \\mathbb{R}^{M \\times N}$，其中每一行选择 $m$ 的一个连续块，并以权重 $1$ 对其条目求和。观测值的生成方式为 $d = A m_{\\mathrm{true}} + \\varepsilon$，其中 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma_d^2 I_M)$。\n\n假设高斯先验为 $m \\sim \\mathcal{N}(m_0, C_m)$，其中 $m_0 \\in \\mathbb{R}^N$ 且 $C_m = \\sigma_m^2 I_N$。在给定高斯似然和先验的情况下，负对数后验（忽略一个与 $m$ 无关的加性常数）为\n$$\n\\Phi(m) = \\frac{1}{2} \\left\\| \\frac{A m - d}{\\sigma_d} \\right\\|_2^2 + \\frac{1}{2} \\left\\| \\frac{m - m_0}{\\sigma_m} \\right\\|_2^2.\n$$\n你的任务是基于第一性原理，为该目标函数 $\\Phi(m)$ 实现并验证伴随方法和梯度一致性。\n\n使用的基本原理：\n- 高斯假设下关联后验、似然和先验的贝叶斯定理。\n- 将负对数后验定义为推断的目标函数。\n- 通过 Fréchet 导数定义标量泛函的梯度。\n- 关于欧几里得内积的伴随算子 $A^\\ast$ 的定义，其特征为对于所有 $x, y$ 都有 $\\langle A x, y \\rangle = \\langle x, A^\\ast y \\rangle$。\n- 方向导数的中心差分近似：\n$$\n\\frac{\\partial \\Phi(m)}{\\partial s} \\approx \\frac{\\Phi(m + h s) - \\Phi(m - h s)}{2 h},\n$$\n其中 $s$ 是一个方向，$h$ 是一个小步长。\n\n在一个完整的、可运行的程序中实现以下内容：\n1. 根据给定的随机种子生成 $M$ 条射线来构建正演算子 $A \\in \\mathbb{R}^{M \\times N}$；每条射线对应一个连续的索引块。对于每一行 $i$，从 $\\{1, 2, \\dots, \\lfloor N/2 \\rfloor\\}$ 中均匀抽取一个块长度 $\\ell_i$，然后从 $\\{0, 1, \\dots, N - \\ell_i\\}$ 中均匀抽取一个起始索引 $b_i$，如果 $j \\in \\{b_i, b_i+1, \\dots, b_i+\\ell_i-1\\}$，则设 $A_{i,j} = 1$，否则设 $A_{i,j} = 0$。\n2. 一个函数，用于在给定 $A$、$d$、$m_0$、$\\sigma_d$ 和 $\\sigma_m$ 的情况下，对任意 $m$ 计算 $\\Phi(m)$。\n3. 一个函数，仅使用上述定义和伴随算子特性来计算梯度 $\\nabla \\Phi(m)$。你不能硬编码一个预先推导出的闭式梯度；相反，应使用链式法则和伴随概念将残差映射回参数空间。\n4. 一个伴随测试，用于验证对于随机向量 $x \\in \\mathbb{R}^N$ 和 $y \\in \\mathbb{R}^M$，属性 $\\langle A x, y \\rangle = \\langle x, A^\\ast y \\rangle$ 成立，其中使用欧几里得内积 $\\langle u, v \\rangle = u^\\top v$。报告多次随机抽样中的最大相对差异：\n$$\n\\mathrm{err}_{\\mathrm{adj}} = \\max_{k} \\frac{|\\langle A x_k, y_k \\rangle - \\langle x_k, A^\\ast y_k \\rangle|}{\\max\\{1, |\\langle A x_k, y_k \\rangle|, |\\langle x_k, A^\\ast y_k \\rangle|\\}}.\n$$\n5. 一个梯度一致性测试，用于检查对于一个随机单位范数方向 $s \\in \\mathbb{R}^N$ 和一组步长 $\\{h_j\\}$，中心差分方向导数是否与内积 $s^\\top \\nabla \\Phi(m)$ 匹配。对每个 $h_j$ 计算\n$$\n\\mathrm{err}_j = \\frac{\\left| \\frac{\\Phi(m + h_j s) - \\Phi(m - h_j s)}{2 h_j} - s^\\top \\nabla \\Phi(m) \\right|}{\\max\\{1, \\left| \\frac{\\Phi(m + h_j s) - \\Phi(m - h_j s)}{2 h_j} \\right|, |s^\\top \\nabla \\Phi(m)|\\}},\n$$\n并报告 $\\min_j \\mathrm{err}_j$ 作为梯度一致性误差。\n\n测试套件和要求的行为：\n实现三个独立的测试用例。对于每个用例，独立构建 $A$，抽取一个真实模型 $m_{\\mathrm{true}}$ 和噪声以生成 $d$，并选择一个测试点 $m$ 和一个方向 $s$。除非另有说明，设置 $m_0 = 0$。使用以下参数集：\n\n- 用例 1（一般情况）：\n  - $N = 64$, $M = 48$。\n  - 随机种子：$A$: $1$, $m_{\\mathrm{true}}$: $2$, 噪声: $3$, 梯度方向和测试点: $4$。\n  - 噪声标准差：$\\sigma_d = 0.05$。\n  - 先验标准差：$\\sigma_m = 0.5$。\n  - 中心差分步长：$[10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}]$。\n  - 容差：$\\mathrm{tol}_{\\mathrm{adj}} = 10^{-12}$, $\\mathrm{tol}_{\\mathrm{grad}} = 10^{-6}$。\n\n- 用例 2（更大规模，更强正则化）：\n  - $N = 128$, $M = 96$。\n  - 随机种子：$A$: $10$, $m_{\\mathrm{true}}$: $20$, 噪声: $30$, 梯度方向和测试点: $40$。\n  - 噪声标准差：$\\sigma_d = 0.10$。\n  - 先验标准差：$\\sigma_m = 0.2$。\n  - 中心差分步长：$[10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}]$。\n  - 容差：$\\mathrm{tol}_{\\mathrm{adj}} = 10^{-11}$, $\\mathrm{tol}_{\\mathrm{grad}} = 5 \\cdot 10^{-6}$。\n\n- 用例 3（数据量少、正则化较弱的边缘情况）：\n  - $N = 32$, $M = 8$。\n  - 随机种子：$A$: $100$, $m_{\\mathrm{true}}$: $200$, 噪声: $300$, 梯度方向和测试点: $400$。\n  - 噪声标准差：$\\sigma_d = 0.20$。\n  - 先验标准差：$\\sigma_m = 1.0$。\n  - 中心差分步长：$[10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}, 10^{-7}]$。\n  - 容差：$\\mathrm{tol}_{\\mathrm{adj}} = 10^{-12}$, $\\mathrm{tol}_{\\mathrm{grad}} = 10^{-5}$。\n\n对于每个用例：\n- 使用 $K = 5$ 次独立的 $x$ 和 $y$ 抽样（例如，标准正态分布条目）进行伴随测试。\n- 对于梯度测试，用标准正态分布条目独立抽取 $m$ 和 $s$，然后设置 $s \\leftarrow s / \\|s\\|_2$。\n\n每个用例的验收标准：\n- 如果 $\\mathrm{err}_{\\mathrm{adj}} \\le \\mathrm{tol}_{\\mathrm{adj}}$，则伴随测试通过。\n- 如果 $\\min_j \\mathrm{err}_j \\le \\mathrm{tol}_{\\mathrm{grad}}$，则梯度测试通过。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含六个布尔值：$[\\text{adj\\_pass\\_1}, \\text{grad\\_pass\\_1}, \\text{adj\\_pass\\_2}, \\text{grad\\_pass\\_2}, \\text{adj\\_pass\\_3}, \\text{grad\\_pass\\_3}]$。",
            "solution": "问题陈述已经过仔细审查，并被认为是有效的。它在科学上基于贝叶斯反演问题和数值线性代数的原理，其定义和参数完整且一致，问题适定，并且可以形式化为一个具体的计算任务。该问题要求实现和验证基本的数值方法——特别是用于梯度计算的伴随方法及其通过泰勒测试的验证——这些都是计算地球物理学领域的核心内容。\n\n解决方案首先从第一性原理推导必要的数学表达式，然后在结构化程序中实现它们，以执行指定的测试用例。\n\n**1. 理论公式**\n\n任务的核心是计算负对数后验目标函数 $\\Phi(m)$ 的梯度，并验证其正确性。目标函数由下式给出：\n$$\n\\Phi(m) = \\frac{1}{2} \\left\\| \\frac{A m - d}{\\sigma_d} \\right\\|_2^2 + \\frac{1}{2} \\left\\| \\frac{m - m_0}{\\sigma_m} \\right\\|_2^2\n$$\n该函数可以分解为两部分：一个似然项 $\\Phi_{\\text{like}}(m)$ 和一个先验项 $\\Phi_{\\text{prior}}(m)$。\n\n$\\Phi_{\\text{like}}(m) = \\frac{1}{2\\sigma_d^2} \\| A m - d \\|_2^2$\n$\\Phi_{\\text{prior}}(m) = \\frac{1}{2\\sigma_m^2} \\| m - m_0 \\|_2^2$\n\n梯度 $\\nabla \\Phi(m)$ 是这两项梯度之和：$\\nabla \\Phi(m) = \\nabla \\Phi_{\\text{like}}(m) + \\nabla \\Phi_{\\text{prior}}(m)$。\n\n**先验项的梯度**\n\n先验项是 $m$ 的一个简单二次函数。其梯度可以直接求得：\n$\\nabla \\Phi_{\\text{prior}}(m) = \\nabla_m \\left( \\frac{1}{2\\sigma_m^2} (m - m_0)^\\top(m - m_0) \\right) = \\frac{1}{2\\sigma_m^2} \\cdot 2(m-m_0) = \\frac{1}{\\sigma_m^2} (m - m_0)$。\n\n**通过伴随方法计算似然项的梯度**\n\n似然项的梯度是使用链式法则和伴随算子的定义推导出来的。$\\Phi_{\\text{like}}(m)$ 在方向 $s \\in \\mathbb{R}^N$ 上的 Fréchet 导数由方向导数给出：\n$$\nD\\Phi_{\\text{like}}(m)[s] = \\lim_{h \\to 0} \\frac{\\Phi_{\\text{like}}(m + hs) - \\Phi_{\\text{like}}(m)}{h}\n$$\n根据定义，此方向导数等于内积 $\\langle \\nabla \\Phi_{\\text{like}}(m), s \\rangle$。令数据残差为 $r(m) = Am - d$。则 $\\Phi_{\\text{like}}(m) = \\frac{1}{2\\sigma_d^2} \\langle r(m), r(m) \\rangle$。\n使用链式法则，$\\Phi_{\\text{like}}$ 的导数由范数平方函数的导数和残差函数 $r(m)$ 的导数复合而成。$r(m)$ 关于 $m$ 在方向 $s$ 上的导数是 $A s$。\n$$\nD\\Phi_{\\text{like}}(m)[s] = \\frac{1}{\\sigma_d^2} \\langle r(m), A s \\rangle = \\frac{1}{\\sigma_d^2} \\langle Am - d, A s \\rangle\n$$\n“伴随方法”包括使用伴随算子 $A^\\ast$ 的性质，将算子 $A$ 从内积的第二个参数移动到第一个参数。对于标准欧几里得内积，伴随算子 $A^\\ast$ 是转置 $A^\\top$。\n$$\n\\langle Am - d, A s \\rangle = \\langle A^\\ast (Am - d), s \\rangle = \\langle A^\\top (Am - d), s \\rangle\n$$\n因此，我们有：\n$$\n\\langle \\nabla \\Phi_{\\text{like}}(m), s \\rangle = D\\Phi_{\\text{like}}(m)[s] = \\frac{1}{\\sigma_d^2} \\langle A^\\top (Am - d), s \\rangle\n$$\n由于此等式必须对所有方向 $s$ 成立，我们可以确定梯度为：\n$$\n\\nabla \\Phi_{\\text{like}}(m) = \\frac{1}{\\sigma_d^2} A^\\top (Am - d)\n$$\n这个推导阐明了原理：为了找到梯度对参数空间（$m$）的影响，我们首先计算数据空间（$Am - d$）中的残差，然后使用伴随算子（$A^\\top$）将其映射回参数空间。\n\n**总梯度**\n\n结合这两个分量，完整的梯度是：\n$$\n\\nabla \\Phi(m) = \\frac{1}{\\sigma_d^2} A^\\top (Am - d) + \\frac{1}{\\sigma_m^2} (m - m_0)\n$$\n实现将使用函数 `apply_A(m)` 进行正演操作 $Am$，使用 `apply_A_adjoint(y)` 进行伴随操作 $A^\\top y$，遵循“伴随状态”方法论。\n\n**2. 数值验证协议**\n\n**伴随测试**\n\n此测试验证所实现的伴随算子 `apply_A_adjoint` 确实是正演算子 `apply_A` 的伴随。对于实数矩阵和欧几里得内积（$\\langle u, v \\rangle = u^\\top v$），伴随算子是转置，因此我们必须验证 $\\langle Ay, x \\rangle = \\langle y, A^\\top x \\rangle$。该测试对 $K=5$ 对随机向量 $x_k \\in \\mathbb{R}^N$ 和 $y_k \\in \\mathbb{R}^M$ 进行。如果最大相对差异低于给定的容差 $\\mathrm{tol}_{\\mathrm{adj}}$，则测试通过。\n$$\n\\mathrm{err}_{\\mathrm{adj}} = \\max_{k} \\frac{|\\langle A x_k, y_k \\rangle - \\langle x_k, A^\\top y_k \\rangle|}{\\max\\{1, |\\langle A x_k, y_k \\rangle|, |\\langle x_k, A^\\top y_k \\rangle|\\}} \\le \\mathrm{tol}_{\\mathrm{adj}}\n$$\n$\\mathrm{err}_{\\mathrm{adj}}$ 的值接近机器精度，可确认伴随实现的正确性。\n\n**梯度一致性测试（泰勒测试）**\n\n此测试验证所实现的梯度函数 `evaluate_grad_Phi` 是正确的。它将解析方向导数 $g_{\\text{analytic}} = s^\\top \\nabla \\Phi(m)$ 与通过中心有限差分获得的数值近似 $g_{\\text{fd}}$ 进行比较。\n$$\ng_{\\text{fd}}(h) = \\frac{\\Phi(m + h s) - \\Phi(m - h s)}{2 h}\n$$\n中心差分格式的截断误差为 $O(h^2)$ 阶。对于非常小的 $h$，浮点运算的舍入误差会占主导地位。该测试计算一系列步长 $h_j$ 的相对误差，并报告找到的最小误差。\n$$\n\\mathrm{err}_{\\text{grad}} = \\min_{j} \\frac{| g_{\\text{fd}}(h_j) - g_{\\text{analytic}} |}{\\max\\{1, |g_{\\text{fd}}(h_j)|, |g_{\\text{analytic}}|\\}}\n$$\n如果这个最小误差低于指定的容差 $\\mathrm{tol}_{\\mathrm{grad}}$，则测试通过。一个小的误差可以确认所推导的梯度表达式已正确实现。\n\n下面的实现遵循此协议来处理三个指定的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef construct_A(N, M, seed):\n    \"\"\"\n    Constructs the forward operator matrix A.\n    \n    Args:\n        N (int): Number of model parameters (columns).\n        M (int): Number of data points (rows).\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        np.ndarray: The MxN forward operator matrix A.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    A = np.zeros((M, N))\n    max_len = N // 2\n    for i in range(M):\n        length = rng.integers(1, max_len + 1)\n        start = rng.integers(0, N - length + 1)\n        A[i, start : start + length] = 1.0\n    return A\n\ndef apply_A(A, m):\n    \"\"\"Applies the forward operator A to a model vector m.\"\"\"\n    return A @ m\n\ndef apply_A_adjoint(A, y):\n    \"\"\"Applies the adjoint of the operator A to a data vector y.\"\"\"\n    return A.T @ y\n\ndef test_adjoint(A, K, seed):\n    \"\"\"\n    Performs the adjoint test for the operator A and its adjoint.\n\n    Args:\n        A (np.ndarray): The MxN forward operator matrix.\n        K (int): Number of random trials.\n        seed (int): Random seed for generating vectors.\n\n    Returns:\n        float: The maximum relative discrepancy found.\n    \"\"\"\n    M, N = A.shape\n    rng = np.random.default_rng(seed)\n    max_rel_err = 0.0\n    \n    for _ in range(K):\n        x = rng.standard_normal(size=N)\n        y = rng.standard_normal(size=M)\n\n        lhs = np.dot(y, apply_A(A, x))\n        rhs = np.dot(x, apply_A_adjoint(A, y))\n\n        diff = np.abs(lhs - rhs)\n        denom = max(1.0, np.abs(lhs), np.abs(rhs))\n        rel_err = diff / denom\n        \n        if rel_err > max_rel_err:\n            max_rel_err = rel_err\n            \n    return max_rel_err\n\ndef evaluate_Phi(m, A, d, m0, sigma_d, sigma_m):\n    \"\"\"\n    Evaluates the negative log-posterior objective function Phi(m).\n    \"\"\"\n    residual_data = apply_A(A, m) - d\n    term_like = 0.5 * np.sum((residual_data / sigma_d)**2)\n    \n    residual_prior = m - m0\n    term_prior = 0.5 * np.sum((residual_prior / sigma_m)**2)\n    \n    return term_like + term_prior\n\ndef evaluate_grad_Phi(m, A, d, m0, sigma_d, sigma_m):\n    \"\"\"\n    Evaluates the gradient of Phi(m) using the adjoint method.\n    \"\"\"\n    # Gradient of likelihood term\n    residual_data = apply_A(A, m) - d\n    grad_like = apply_A_adjoint(A, residual_data) / (sigma_d**2)\n    \n    # Gradient of prior term\n    residual_prior = m - m0\n    grad_prior = residual_prior / (sigma_m**2)\n    \n    return grad_like + grad_prior\n\ndef test_gradient(A, d, m0, sigma_d, sigma_m, m_test, s, h_values):\n    \"\"\"\n    Performs the gradient consistency test (Taylor test).\n\n    Returns:\n        float: The minimum relative error found.\n    \"\"\"\n    # Analytical directional derivative\n    grad_val = evaluate_grad_Phi(m_test, A, d, m0, sigma_d, sigma_m)\n    grad_proj = np.dot(s, grad_val)\n\n    min_rel_err = np.inf\n    \n    for h in h_values:\n        phi_plus = evaluate_Phi(m_test + h * s, A, d, m0, sigma_d, sigma_m)\n        phi_minus = evaluate_Phi(m_test - h * s, A, d, m0, sigma_d, sigma_m)\n        \n        fd_approx = (phi_plus - phi_minus) / (2 * h)\n        \n        diff = np.abs(fd_approx - grad_proj)\n        denom = max(1.0, np.abs(fd_approx), np.abs(grad_proj))\n        rel_err = diff / denom\n        \n        if rel_err  min_rel_err:\n            min_rel_err = rel_err\n            \n    return min_rel_err\n\ndef run_case(params):\n    \"\"\"\n    Runs a single test case with given parameters.\n    \"\"\"\n    N, M = params[\"N\"], params[\"M\"]\n    seeds = params[\"seeds\"]\n    sigma_d, sigma_m = params[\"sigma_d\"], params[\"sigma_m\"]\n    h_values = params[\"h_values\"]\n    tol_adj, tol_grad = params[\"tol_adj\"], params[\"tol_grad\"]\n\n    # 1. Construct A\n    A = construct_A(N, M, seeds[\"A\"])\n\n    # 2. Adjoint test\n    # The seed for adjoint test vectors is part of the grad/test point seed dict key\n    err_adj = test_adjoint(A, K=5, seed=seeds[\"grad\"])\n    adj_pass = err_adj = tol_adj\n\n    # 3. Generate data\n    rng_m_true = np.random.default_rng(seeds[\"m_true\"])\n    m_true = rng_m_true.standard_normal(size=N)\n    \n    rng_noise = np.random.default_rng(seeds[\"noise\"])\n    noise = rng_noise.standard_normal(size=M) * sigma_d\n\n    d = apply_A(A, m_true) + noise\n    m0 = np.zeros(N)\n\n    # 4. Gradient test\n    rng_grad = np.random.default_rng(seeds[\"grad\"])\n    m_test = rng_grad.standard_normal(size=N)\n    s = rng_grad.standard_normal(size=N)\n    s /= np.linalg.norm(s)\n\n    err_grad = test_gradient(A, d, m0, sigma_d, sigma_m, m_test, s, h_values)\n    grad_pass = err_grad = tol_grad\n    \n    return adj_pass, grad_pass\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 64, \"M\": 48,\n            \"seeds\": {\"A\": 1, \"m_true\": 2, \"noise\": 3, \"grad\": 4},\n            \"sigma_d\": 0.05, \"sigma_m\": 0.5,\n            \"h_values\": [1e-1, 1e-2, 1e-3, 1e-4, 1e-5],\n            \"tol_adj\": 1e-12, \"tol_grad\": 1e-6\n        },\n        {\n            \"N\": 128, \"M\": 96,\n            \"seeds\": {\"A\": 10, \"m_true\": 20, \"noise\": 30, \"grad\": 40},\n            \"sigma_d\": 0.10, \"sigma_m\": 0.2,\n            \"h_values\": [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6],\n            \"tol_adj\": 1e-11, \"tol_grad\": 5e-6\n        },\n        {\n            \"N\": 32, \"M\": 8,\n            \"seeds\": {\"A\": 100, \"m_true\": 200, \"noise\": 300, \"grad\": 400},\n            \"sigma_d\": 0.20, \"sigma_m\": 1.0,\n            \"h_values\": [1e-2, 1e-3, 1e-4, 1e-5, 1e-6, 1e-7],\n            \"tol_adj\": 1e-12, \"tol_grad\": 1e-5\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        adj_pass, grad_pass = run_case(case_params)\n        results.extend([adj_pass, grad_pass])\n    \n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的计算地球物理学中，我们常常需要在模型的准确性与计算成本之间做出权衡。本练习将指导您如何在一个统一的贝叶斯框架中，严谨地融合来自快速、低保真度模型和慢速、高保真度模型的数据 。其关键在于引入一个“差异项”（discrepancy term）来显式地为粗糙模型的系统误差建模，从而避免过于自信的推断，得到更可靠的不确定性量化结果。",
            "id": "3577515",
            "problem": "要求您在一个代表计算地球物理学的线性化设置中，形式化并实现一个基于数学原理的多保真度贝叶斯反演，其中包含显式保真度指标和差异先验，以避免过于自信的后验。本问题中的所有量均为无量纲。您必须从第一性原理推导后验和预测分布，并实现一个程序，为提供的测试套件计算指定的标量摘要。您的最终程序必须完全按照本问题末尾的规定输出单行。\n\n场景如下。我们考虑一个参数向量 $\\mathbf{m} \\in \\mathbb{R}^2$ 和两个正向求解器，一个精细求解器 $G_f$ 和一个粗略求解器 $G_c$，两者都与 $\\mathbf{m}$ 呈线性关系。对于 $i \\in \\{1,\\dots,n\\}$ 和保真度指标 $z_i \\in \\{0,1\\}$，定义观测模型\n$$\ny_i = \n\\begin{cases}\n\\mathbf{a}_{f,i}^\\top \\mathbf{m} + \\varepsilon_i,  \\text{若 } z_i = 1 \\,\\,(\\text{精细}),\\\\\n\\mathbf{a}_{c,i}^\\top \\mathbf{m} + b + \\varepsilon_i,  \\text{若 } z_i = 0 \\,\\,(\\text{粗略}),\n\\end{cases}\n$$\n其中 $b \\in \\mathbb{R}$ 是一个标量差异项，用于模拟粗略求解器的保真度偏差。随机噪声 $\\varepsilon_i$ 在不同 $i$ 之间是独立的，且\n$$\n\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_f^2) \\text{ 若 } z_i=1,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_c^2) \\text{ 若 } z_i=0,\n$$\n其中 $\\sigma_f^2  0$ 和 $\\sigma_c^2  0$ 是已知的超参数。\n\n先验。假设独立的高斯先验\n$$\n\\mathbf{m} \\sim \\mathcal{N}(\\mathbf{m}_0,\\mathbf{C}_0), \\qquad b \\sim \\mathcal{N}(0,s_b^2).\n$$\n\n数据和算子。使用 $n=4$ 个观测值和以下正向算子：\n- 精细正向算子矩阵 $A_f \\in \\mathbb{R}^{4\\times 2}$，其行 $\\mathbf{a}_{f,i}^\\top$ 由下式给出\n$$\nA_f = \\begin{bmatrix}\n1.0  0.5\\\\\n0.5  1.0\\\\\n1.0  -0.2\\\\\n0.3  0.8\n\\end{bmatrix}.\n$$\n- 粗略正向算子矩阵 $A_c \\in \\mathbb{R}^{4\\times 2}$，其行 $\\mathbf{a}_{c,i}^\\top$ 由下式给出\n$$\nA_c = \\begin{bmatrix}\n0.9  0.5\\\\\n0.5  0.9\\\\\n0.95  -0.15\\\\\n0.32  0.78\n\\end{bmatrix}.\n$$\n\n使用以下观测数据向量 $\\mathbf{y} \\in \\mathbb{R}^4$：\n$$\n\\mathbf{y} = \\begin{bmatrix} 1.57 \\\\ 1.29 \\\\ 1.06 \\\\ 0.935 \\end{bmatrix}.\n$$\n\n使用以下高斯先验：\n$$\n\\mathbf{m}_0 = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}, \\quad \\mathbf{C}_0 = \\mathrm{diag}(0.25, 0.25), \\quad s_b^2 = 0.09.\n$$\n\n定义用于预测的新粗略设计向量为\n$$\n\\mathbf{a}_{\\text{new},c} = \\begin{bmatrix} 0.6 \\\\ 0.4 \\end{bmatrix}.\n$$\n\n任务。\n1) 推导。从贝叶斯法则和给定的高斯假设出发，推导在给定数据 $\\mathbf{y}$、任意保真度指标向量 $\\mathbf{z} \\in \\{0,1\\}^n$ 以及已知的 $\\sigma_f^2,\\sigma_c^2$ 条件下，增广参数 $\\boldsymbol{\\theta} = [\\mathbf{m}^\\top, b]^\\top \\in \\mathbb{R}^3$ 的后验分布。您的推导必须将后验表示为多元高斯分布的闭式解，其均值和协方差需用以下各项表示：\n- $\\boldsymbol{\\theta}$ 的分块对角先验均值和协方差，\n- 结合了 $A_f$、$A_c$ 以及由 $\\mathbf{z}$ 隐含的偏差列的设计矩阵，\n- 按行编码 $\\sigma_f^2$ 和 $\\sigma_c^2$ 的对角噪声协方差矩阵。\n\n2) 后验预测。推导在新设计向量 $\\mathbf{a}_{\\text{new},c}$ 处、保真度指标 $z_{\\text{new}} = 0$ 时的新粗略保真度观测值 $y_{\\text{new}}$ 的后验预测分布。用 $\\boldsymbol{\\theta}$ 的后验均值和协方差以及已知的噪声方差 $\\sigma_c^2$ 显式表示预测均值和方差。\n\n3) 实现。实现一个程序，使用您推导的公式为下面的测试套件中的每个测试用例计算以下输出：\n- 第一个分量 $m_1$ 的后验均值（一个浮点数），\n- 在 $\\mathbf{a}_{\\text{new},c}$ 处、$z_{\\text{new}}=0$ 时，$y_{\\text{new}}$ 的后验预测方差（一个浮点数）。\n\n您的程序必须使用标准的密集运算实现所有线性代数，并且不得依赖任何随机数生成。\n\n测试套件。使用上面给出的固定的 $\\mathbf{y}$、$A_f$、$A_c$、$\\mathbf{m}_0$、$\\mathbf{C}_0$、$s_b^2$ 和 $\\mathbf{a}_{\\text{new},c}$。为以下三种情况中的每一种评估两个输出：\n- 情况 1 (混合保真度): \n  - $\\mathbf{z} = [1,0,1,0]$,\n  - $\\sigma_f^2 = 0.01$, $\\sigma_c^2 = 0.04$.\n- 情况 2 (全为粗略，粗略方差较大):\n  - $\\mathbf{z} = [0,0,0,0]$,\n  - $\\sigma_f^2 = 0.01$, $\\sigma_c^2 = 0.09$.\n- 情况 3 (全为精细，精细方差较小):\n  - $\\mathbf{z} = [1,1,1,1]$,\n  - $\\sigma_f^2 = 0.0025$, $\\sigma_c^2 = 0.04$.\n\n最终输出格式。您的程序必须生成单行输出，其中包含三个测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是按上述顺序排列的双元素列表。每个浮点数必须四舍五入到六位小数。具体来说，程序必须打印单行，格式如下\n`[[m1_case1,vpred_case1],[m1_case2,vpred_case2],[m1_case3,vpred_case3]]`,\n例如，\n`[[0.123456,0.654321],[...],[...]]`,\n除了此处显示的逗号和括号外，没有额外的空格。所有量都是无量纲的，必须报告为四舍五入到小数点后六位的普通十进制数。",
            "solution": "用户提供的问题是有效的。这是一个在计算地球物理学和不确定性量化领域中适定的问题，没有科学或数学上的不一致之处。所有需要的数据和定义都已提供。\n\n### 1. 问题形式化与贝叶斯模型建立\n\n该问题要求对一个增广参数向量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^3$ 进行贝叶斯反演，该向量包括物理参数 $\\mathbf{m} \\in \\mathbb{R}^2$ 和标量偏差项 $b \\in \\mathbb{R}$。我们将此增广向量定义为 $\\boldsymbol{\\theta} = [\\mathbf{m}^\\top, b]^\\top$。\n\n**先验分布：** 问题陈述了 $\\mathbf{m}$ 和 $b$ 的独立高斯先验：\n$$\n\\mathbf{m} \\sim \\mathcal{N}(\\mathbf{m}_0, \\mathbf{C}_0) \\quad \\text{和} \\quad b \\sim \\mathcal{N}(0, s_b^2).\n$$\n这表示增广参数向量 $\\boldsymbol{\\theta}$ 的联合高斯先验为：\n$$\np(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\theta} | \\boldsymbol{\\theta}_0, \\mathbf{C}_{\\theta,0}),\n$$\n其中先验均值 $\\boldsymbol{\\theta}_0$ 和先验协方差 $\\mathbf{C}_{\\theta,0}$ 由下式给出：\n$$\n\\boldsymbol{\\theta}_0 = \\begin{bmatrix} \\mathbf{m}_0 \\\\ 0 \\end{bmatrix}, \\qquad\n\\mathbf{C}_{\\theta,0} = \\begin{bmatrix} \\mathbf{C}_0  \\mathbf{0} \\\\ \\mathbf{0}^\\top  s_b^2 \\end{bmatrix}.\n$$\n\n**似然函数：** 观测模型取决于保真度指标 $z_i \\in \\{0, 1\\}$。我们可以为所有 $n$ 个观测值将其表示为统一的线性形式。\n令 $\\mathbf{y} = [y_1, \\dots, y_n]^\\top$ 为观测向量。第 $i$ 个观测的模型是：\n$$\ny_i =\n\\begin{cases}\n[\\mathbf{a}_{f,i}^\\top, 0] \\boldsymbol{\\theta} + \\varepsilon_i,  \\text{若 } z_i=1 \\\\\n[\\mathbf{a}_{c,i}^\\top, 1] \\boldsymbol{\\theta} + \\varepsilon_i,  \\text{若 } z_i=0\n\\end{cases}\n$$\n这可以为整个数据向量 $\\mathbf{y}$ 紧凑地写成单个线性模型：\n$$\n\\mathbf{y} = \\mathbf{G} \\boldsymbol{\\theta} + \\boldsymbol{\\varepsilon},\n$$\n其中 $\\boldsymbol{\\varepsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{C}_\\varepsilon)$ 是噪声向量，$\\mathbf{G}$ 是一个 $n \\times 3$ 的设计矩阵。\n\n$\\mathbf{G}$ 的第 $i$ 行，记作 $\\mathbf{g}_i^\\top$，根据保真度指标 $z_i$ 构建：\n$$\n\\mathbf{g}_i^\\top = z_i [\\mathbf{a}_{f,i}^\\top, 0] + (1-z_i) [\\mathbf{a}_{c,i}^\\top, 1].\n$$\n噪声协方差矩阵 $\\mathbf{C}_\\varepsilon$ 是对角矩阵，因为噪声项 $\\varepsilon_i$ 是独立的。其对角线元素由 $z_i$ 决定：\n$$\n(\\mathbf{C}_\\varepsilon)_{ii} = z_i \\sigma_f^2 + (1-z_i) \\sigma_c^2.\n$$\n因此，似然函数由多元高斯分布的概率密度函数给出：\n$$\np(\\mathbf{y}|\\boldsymbol{\\theta}) = \\mathcal{N}(\\mathbf{y} | \\mathbf{G}\\boldsymbol{\\theta}, \\mathbf{C}_\\varepsilon).\n$$\n\n### 2. 后验分布的推导\n\n我们应用贝叶斯法则来找到后验分布 $p(\\boldsymbol{\\theta}|\\mathbf{y}) \\propto p(\\mathbf{y}|\\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})$。由于先验和似然都是高斯分布，因此 $\\boldsymbol{\\theta}$ 的后验分布也是一个多元高斯分布，我们记为：\n$$\np(\\boldsymbol{\\theta}|\\mathbf{y}) = \\mathcal{N}(\\boldsymbol{\\theta} | \\boldsymbol{\\theta}_{\\text{post}}, \\mathbf{C}_{\\theta,\\text{post}}).\n$$\n后验协方差矩阵 $\\mathbf{C}_{\\theta,\\text{post}}$ 和后验均值向量 $\\boldsymbol{\\theta}_{\\text{post}}$ 由贝叶斯线性回归的标准公式给出：\n后验精度矩阵是先验精度与数据精度（来自似然）之和：\n$$\n\\mathbf{C}_{\\theta,\\text{post}}^{-1} = \\mathbf{C}_{\\theta,0}^{-1} + \\mathbf{G}^\\top \\mathbf{C}_{\\varepsilon}^{-1} \\mathbf{G}.\n$$\n后验协方差是后验精度的逆：\n$$\n\\mathbf{C}_{\\theta,\\text{post}} = (\\mathbf{C}_{\\theta,0}^{-1} + \\mathbf{G}^\\top \\mathbf{C}_{\\varepsilon}^{-1} \\mathbf{G})^{-1}.\n$$\n后验均值是先验均值和数据的精度加权平均值：\n$$\n\\boldsymbol{\\theta}_{\\text{post}} = \\mathbf{C}_{\\theta,\\text{post}} (\\mathbf{C}_{\\theta,0}^{-1} \\boldsymbol{\\theta}_0 + \\mathbf{G}^\\top \\mathbf{C}_{\\varepsilon}^{-1} \\mathbf{y}).\n$$\n这些公式为后验分布提供了闭式表达式，其项均在问题陈述中定义。向量 $\\boldsymbol{\\theta}_{\\text{post}}$ 的第一个分量是 $m_1$ 的后验均值，这是要求的输出之一。\n\n### 3. 后验预测分布的推导\n\n我们需要推导在新设计向量 $\\mathbf{a}_{\\text{new},c}$ 处（即 $z_{\\text{new}}=0$）的新粗略保真度观测值 $y_{\\text{new}}$ 的分布。这个新观测值的模型是：\n$$\ny_{\\text{new}} = \\mathbf{a}_{\\text{new},c}^\\top \\mathbf{m} + b + \\varepsilon_{\\text{new}},\n$$\n其中 $\\varepsilon_{\\text{new}} \\sim \\mathcal{N}(0, \\sigma_c^2)$。用增广参数 $\\boldsymbol{\\theta}$ 表示，即为：\n$$\ny_{\\text{new}} = \\mathbf{g}_{\\text{new}}^\\top \\boldsymbol{\\theta} + \\varepsilon_{\\text{new}}, \\quad \\text{其中} \\quad \\mathbf{g}_{\\text{new}}^\\top = [\\mathbf{a}_{\\text{new},c}^\\top, 1].\n$$\n后验预测分布 $p(y_{\\text{new}}|\\mathbf{y})$ 通过对 $\\boldsymbol{\\theta}$ 的后验进行边缘化来求得：\n$$\np(y_{\\text{new}}|\\mathbf{y}) = \\int p(y_{\\text{new}}|\\boldsymbol{\\theta}) p(\\boldsymbol{\\theta}|\\mathbf{y}) d\\boldsymbol{\\theta}.\n$$\n这是两个高斯分布的卷积，其结果是另一个高斯分布。我们可以求出其均值和方差。\n\n**预测均值：** 根据全期望定律：\n$$\n\\mathbb{E}[y_{\\text{new}}|\\mathbf{y}] = \\mathbb{E}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\mathbb{E}[y_{\\text{new}}|\\boldsymbol{\\theta}]] = \\mathbb{E}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\mathbf{g}_{\\text{new}}^\\top \\boldsymbol{\\theta}] = \\mathbf{g}_{\\text{new}}^\\top \\mathbb{E}[\\boldsymbol{\\theta}|\\mathbf{y}] = \\mathbf{g}_{\\text{new}}^\\top \\boldsymbol{\\theta}_{\\text{post}}.\n$$\n\n**预测方差：** 根据全方差定律：\n$$\n\\text{Var}(y_{\\text{new}}|\\mathbf{y}) = \\mathbb{E}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\text{Var}(y_{\\text{new}}|\\boldsymbol{\\theta})] + \\text{Var}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\mathbb{E}(y_{\\text{new}}|\\boldsymbol{\\theta})].\n$$\n第一项是期望的观测方差：$\\mathbb{E}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\sigma_c^2] = \\sigma_c^2$。\n第二项是由于 $\\boldsymbol{\\theta}$ 的不确定性导致的预测均值的方差：\n$$\n\\text{Var}_{\\boldsymbol{\\theta}|\\mathbf{y}}[\\mathbf{g}_{\\text{new}}^\\top \\boldsymbol{\\theta}] = \\mathbf{g}_{\\text{new}}^\\top \\text{Var}(\\boldsymbol{\\theta}|\\mathbf{y}) \\mathbf{g}_{\\text{new}} = \\mathbf{g}_{\\text{new}}^\\top \\mathbf{C}_{\\theta,\\text{post}} \\mathbf{g}_{\\text{new}}.\n$$\n结合这些，后验预测方差 $V_{\\text{pred}}$ 为：\n$$\nV_{\\text{pred}} = \\mathbf{g}_{\\text{new}}^\\top \\mathbf{C}_{\\theta,\\text{post}} \\mathbf{g}_{\\text{new}} + \\sigma_c^2.\n$$\n这是第二个要求的输出。\n\n### 4. 实现策略\n\n对于三个测试用例中的每一个，实现将按以下步骤进行：\n1.  初始化给定的常数矩阵和向量：$A_f, A_c, \\mathbf{y}, \\mathbf{m}_0, \\mathbf{C}_0, s_b^2, \\mathbf{a}_{\\text{new},c}$。\n2.  构建增广先验均值 $\\boldsymbol{\\theta}_0$ 和先验协方差 $\\mathbf{C}_{\\theta,0}$。\n3.  对于由 $(\\mathbf{z}, \\sigma_f^2, \\sigma_c^2)$ 指定的给定测试用例：\n    a. 根据保真度向量 $\\mathbf{z}$，通过从 $A_f$ 和 $A_c$ 中选择和增广行来构建 $4 \\times 3$ 设计矩阵 $\\mathbf{G}$。\n    b. 根据 $\\mathbf{z}$ 的指定，使用 $\\sigma_f^2$ 和 $\\sigma_c^2$ 构建 $4 \\times 4$ 对角噪声协方差矩阵 $\\mathbf{C}_\\varepsilon$。\n    c. 计算逆矩阵 $\\mathbf{C}_{\\theta,0}^{-1}$ 和 $\\mathbf{C}_\\varepsilon^{-1}$。\n    d. 使用推导的公式计算后验协方差 $\\mathbf{C}_{\\theta,\\text{post}}$。\n    e. 使用其推导的公式计算后验均值 $\\boldsymbol{\\theta}_{\\text{post}}$。\n    f. 提取 $\\boldsymbol{\\theta}_{\\text{post}}$ 的第一个元素作为 $m_1$ 的后验均值。\n    g. 构建新的设计向量 $\\mathbf{g}_{\\text{new}} = [\\mathbf{a}_{\\text{new},c}^\\top, 1]^\\top$。\n    h. 使用其推导的公式计算后验预测方差 $V_{\\text{pred}}$，其中增加的噪声方差对应于粗略模型，即 $\\sigma_c^2$。\n4.  收集并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes posterior and predictive quantities for a multi-fidelity Bayesian inversion problem.\n    \"\"\"\n    \n    # --- 1. Define constants from the problem statement ---\n    \n    # Forward operator matrices\n    A_f = np.array([\n        [1.0, 0.5],\n        [0.5, 1.0],\n        [1.0, -0.2],\n        [0.3, 0.8]\n    ])\n    A_c = np.array([\n        [0.9, 0.5],\n        [0.5, 0.9],\n        [0.95, -0.15],\n        [0.32, 0.78]\n    ])\n    \n    # Observed data vector\n    y_obs = np.array([1.57, 1.29, 1.06, 0.935])\n    \n    # Prior on m\n    m0 = np.array([1.0, 1.0])\n    C0 = np.diag([0.25, 0.25])\n    \n    # Prior on b\n    s_b_sq = 0.09\n    \n    # New design vector for prediction\n    a_new_c = np.array([0.6, 0.4])\n\n    # --- 2. Construct augmented prior for theta = [m, b] ---\n    \n    # Augmented prior mean theta_0 = [m0, 0]\n    theta_0 = np.append(m0, 0.0)\n    \n    # Augmented prior covariance C_theta_0\n    C_theta_0 = np.block([\n        [C0, np.zeros((2, 1))],\n        [np.zeros((1, 2)), s_b_sq]\n    ])\n    \n    # Pre-compute prior precision and related term for posterior mean calculation\n    C_theta_0_inv = np.linalg.inv(C_theta_0)\n    C_theta_0_inv_theta_0 = C_theta_0_inv @ theta_0\n    \n    # Define test cases\n    test_cases = [\n        # Case 1: Mixed fidelity\n        {'z': np.array([1, 0, 1, 0]), 'sigma_f_sq': 0.01, 'sigma_c_sq': 0.04},\n        # Case 2: All coarse\n        {'z': np.array([0, 0, 0, 0]), 'sigma_f_sq': 0.01, 'sigma_c_sq': 0.09},\n        # Case 3: All fine\n        {'z': np.array([1, 1, 1, 1]), 'sigma_f_sq': 0.0025, 'sigma_c_sq': 0.04},\n    ]\n\n    all_results = []\n    \n    # --- 3. Process each test case ---\n    \n    for case in test_cases:\n        z = case['z']\n        sigma_f_sq = case['sigma_f_sq']\n        sigma_c_sq = case['sigma_c_sq']\n        \n        # --- a. Construct case-specific matrices G and C_epsilon ---\n        \n        # Design matrix G (4x3)\n        G = np.zeros((4, 3))\n        for i in range(4):\n            if z[i] == 1:\n                G[i, :2] = A_f[i, :]\n                G[i, 2] = 0.0\n            else: # z[i] == 0\n                G[i, :2] = A_c[i, :]\n                G[i, 2] = 1.0\n        \n        # Noise covariance C_epsilon (diagonal)\n        diag_C_eps = z * sigma_f_sq + (1 - z) * sigma_c_sq\n        C_eps_inv = np.diag(1.0 / diag_C_eps)\n\n        # --- b. Calculate posterior distribution for theta ---\n        \n        # Posterior precision matrix for theta\n        G_T_C_eps_inv_G = G.T @ C_eps_inv @ G\n        C_theta_post_inv = C_theta_0_inv + G_T_C_eps_inv_G\n        \n        # Posterior covariance matrix for theta\n        C_theta_post = np.linalg.inv(C_theta_post_inv)\n        \n        # Posterior mean for theta\n        G_T_C_eps_inv_y = G.T @ C_eps_inv @ y_obs\n        theta_post = C_theta_post @ (C_theta_0_inv_theta_0 + G_T_C_eps_inv_y)\n        \n        # Extract posterior mean of m1\n        m1_post_mean = theta_post[0]\n        \n        # --- c. Calculate posterior predictive variance ---\n        \n        # New design vector g_new for coarse prediction\n        g_new = np.append(a_new_c, 1.0)\n        \n        # Predictive variance V_pred = g_new^T * C_theta_post * g_new + sigma_c^2\n        V_pred = g_new.T @ C_theta_post @ g_new + sigma_c_sq\n        \n        all_results.append([m1_post_mean, V_pred])\n\n    # --- 4. Format and print the final output ---\n    \n    # Format each result pair into \"[val1,val2]\"\n    formatted_results = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    \n    # Join the pairs and enclose in outer brackets\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "贝叶斯反演得到的后验分布并非总是简单的单峰高斯分布，它可能呈现出多个峰值，每个峰值对应一组不同的、同样可能解释观测数据的模型参数。本练习通过一个一维走时反演问题来探讨这种情况，并引入“温度法”（tempering）作为一种增强采样算法探索能力的策略 。理解如何处理多峰分布对于进行全面的不确定性量化至关重要，因为它可以防止我们遗漏掉重要的替选解。",
            "id": "3577524",
            "problem": "考虑一个均匀介质中直线射线走时的一维贝叶斯反演问题，这是计算地球物理学中的一个典型设定。未知量是均匀层的地震波速度 $v$。长度为 $L$ 的射线产生了带有噪声的观测走时 $t_{\\text{obs}}$。正演算子遵循基本运动学原理：走时 $t$ 满足 $t = L / v$。假设测量噪声是独立同分布的高斯噪声，其标准差 $\\sigma_t$ 已知，因此对于给定的 $v$，其似然函数为 $p(t_{\\text{obs}} \\mid v) = \\mathcal{N}\\left(t_{\\text{obs}}; L/v, \\sigma_t^2\\right)$。地质先验将相互排斥的岩性编码为速度 $v$ 的两个高斯分量的混合，其分量均值分别为 $v_1$ 和 $v_2$，标准差分别为 $s_1$ 和 $s_2$，混合权重分别为 $w_1$ 和 $w_2 = 1 - w_1$。具体而言，先验密度为\n$$\np(v) = w_1 \\, \\mathcal{N}\\left(v; v_1, s_1^2\\right) + w_2 \\, \\mathcal{N}\\left(v; v_2, s_2^2\\right),\n$$\n在 $(t_{\\text{obs}}, \\sigma_t)$ 的某些配置下，这会在后验分布中产生多峰性。\n\n为了探索处理多峰性的退火策略，我们为幂次温度参数 $\\beta \\in (0,1]$ 定义退火后验\n$$\np_{\\beta}(v \\mid t_{\\text{obs}}) \\propto p(v) \\, \\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta}.\n$$\n当 $\\beta = 1$ 时，这与常规后验一致；而较小的 $\\beta$ 值会使似然函数变得平坦，并降低后验分布的集中程度，这有助于跨越不同模态进行探索。\n\n您的任务是实现一个完整的程序，对于给定的测试用例集，计算位于低速模态区域（定义为 $v \\leq v_{\\text{mid}}$，其中 $v_{\\text{mid}} = (v_1 + v_2)/2$）的退火后验概率质量所占的比例。对于每个案例和三种温度 $\\beta \\in \\{1.0, 0.5, 0.1\\}$，程序必须在均匀网格上对速度域进行离散化，评估未归一化的退火后验 $p(v)\\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta}$，然后计算质量分数\n$$\nf_{1}(\\beta) = \\frac{\\int_{v_{\\min}}^{v_{\\text{mid}}} p(v)\\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta} \\, \\mathrm{d}v}{\\int_{v_{\\min}}^{v_{\\max}} p(v)\\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta} \\, \\mathrm{d}v},\n$$\n其中 $[v_{\\min}, v_{\\max}]$ 是一个固定的速度范围，其选择是为了包含先验概率的主体部分。将这些分数报告为无单位的小数，并四舍五入到小数点后六位。使用以下物理单位和常数：$L$ 的单位是米 (m)，$v$ 的单位是米/秒 (m/s)，$t_{\\text{obs}}$ 和 $\\sigma_t$ 的单位是秒 (s)。\n\n对于数值积分，使用均匀速度网格，其中 $v_{\\min} = 1000$ m/s，$v_{\\max} = 5000$ m/s，网格间距 $\\Delta v = 1$ m/s。必须使用其完整的归一化常数来评估高斯正态密度，以确保科学上的一致性。\n\n测试用例集：\n1. 模糊情况，似然函数宽度较大，使得两种岩性都可能是合理的：\n   - $L = 1000$ m, $t_{\\text{obs}} = 0.33$ s, $\\sigma_t = 0.08$ s,\n   - $w_1 = 0.5$, $v_1 = 2000$ m/s, $s_1 = 200$ m/s,\n   - $w_2 = 0.5$, $v_2 = 3500$ m/s, $s_2 = 300$ m/s.\n2. 强信息情况，偏向于高速岩性：\n   - $L = 1000$ m, $t_{\\text{obs}} = 0.286$ s, $\\sigma_t = 0.01$ s,\n   - $w_1 = 0.5$, $v_1 = 2000$ m/s, $s_1 = 200$ m/s,\n   - $w_2 = 0.5$, $v_2 = 3500$ m/s, $s_2 = 300$ m/s.\n3. 弥散情况，似然函数较宽，后验分布接近先验混合分布：\n   - $L = 1000$ m, $t_{\\text{obs}} = 0.40$ s, $\\sigma_t = 0.20$ s,\n   - $w_1 = 0.5$, $v_1 = 2000$ m/s, $s_1 = 200$ m/s,\n   - $w_2 = 0.5$, $v_2 = 3500$ m/s, $s_2 = 300$ m/s.\n4. 倾斜先验情况，先验偏向于低速岩性，但数据与高速岩性更一致：\n   - $L = 1000$ m, $t_{\\text{obs}} = 0.32$ s, $\\sigma_t = 0.03$ s,\n   - $w_1 = 0.7$, $v_1 = 2200$ m/s, $s_1 = 150$ m/s,\n   - $w_2 = 0.3$, $v_2 = 3800$ m/s, $s_2 = 400$ m/s.\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。\n- 对于每个测试用例，按顺序输出恰好三个数字：$f_1(1.0)$、$f_1(0.5)$ 和 $f_1(0.1)$，并四舍五入到六位小数。\n- 依次汇总所有测试用例的结果。例如，输出必须看起来像\n$[f_{1}^{(1)}(1.0),f_{1}^{(1)}(0.5),f_{1}^{(1)}(0.1),f_{1}^{(2)}(1.0),\\dots,f_{1}^{(4)}(0.1)]$，\n其中上标索引测试用例 $1$ 到 $4$。\n\n所有答案都是无单位小数。输出的任何位置都不允许使用百分号。",
            "solution": "设计始于与计算地球物理学中的贝叶斯反演和不确定性量化相关的基本原理。正演算子由均匀介质中直线射线走时的运动学关系 $t = L/v$ 定义，其中 $L$ 是已知路径长度，$v$ 是未知速度。数据模型假设噪声为标准差是 $\\sigma_t$ 的高斯噪声，因此在给定 $v$ 的情况下观测到 $t_{\\text{obs}}$ 的似然函数为\n$$\np(t_{\\text{obs}} \\mid v) = \\frac{1}{\\sqrt{2\\pi}\\sigma_t} \\exp\\left( -\\frac{\\left(t_{\\text{obs}} - L/v\\right)^2}{2\\sigma_t^2} \\right).\n$$\n我们为 $v$ 假定一个双峰先验，以反映两种相互竞争的地质假设。这被建模为高斯密度的混合，\n$$\np(v) = w_1 \\frac{1}{\\sqrt{2\\pi}s_1} \\exp\\left( -\\frac{(v - v_1)^2}{2 s_1^2} \\right) + w_2 \\frac{1}{\\sqrt{2\\pi}s_2} \\exp\\left( -\\frac{(v - v_2)^2}{2 s_2^2} \\right),\n$$\n其中 $w_2 = 1 - w_1$，$v_1, v_2$ 是模态速度，$s_1, s_2$ 是它们的标准差。根据贝叶斯定理，后验密度与乘积 $p(v) p(t_{\\text{obs}} \\mid v)$ 成正比。多峰性的出现是因为先验本身有两个分离的模态，并且如果似然函数相对于 $v_1$ 和 $v_2$ 之间的分离足够宽，或者如果 $t_{\\text{obs}}$ 与两种假设都一致，那么似然函数不一定会消除任何一个模态。\n\n退火策略通过一个应用于似然函数的幂次参数 $\\beta \\in (0,1]$ 来修改后验，从而产生退火后验密度\n$$\np_{\\beta}(v \\mid t_{\\text{obs}}) \\propto p(v) \\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta}.\n$$\n这种形式被称为幂次后验或退火后验。当 $\\beta = 1$ 时，$p_{\\beta}$ 与常规后验一致；对于较小的 $\\beta$，似然函数的影响会减弱，产生一个更平坦的分布，从而允许对多个模态进行探索。这种退火在马尔可夫链蒙特卡洛（MCMC）方法中很常见，例如平行退火，以促进模态之间的转换。\n\n为了计算与低速模态区域相关的后验质量分数，我们在中点 $v_{\\text{mid}} = (v_1 + v_2)/2$ 处划分速度空间。在一个包含先验质量主体部分的固定域 $[v_{\\min}, v_{\\max}]$ 上定义分数\n$$\nf_1(\\beta) = \\frac{\\int_{v_{\\min}}^{v_{\\text{mid}}} p(v)\\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta} \\, \\mathrm{d}v}{\\int_{v_{\\min}}^{v_{\\max}}} p(v)\\left[p(t_{\\text{obs}} \\mid v)\\right]^{\\beta} \\, \\mathrm{d}v}\n$$\n因为所有密度都是非负的，所以 $f_1(\\beta) \\in [0,1]$，其补集 $1 - f_1(\\beta)$ 代表了高速模态区域中的质量。\n\n算法方法：\n1. 选择一个均匀速度网格 $v_k = v_{\\min} + k \\Delta v$，其中 $k = 0, 1, \\dots, K$，$v_{\\min} = 1000$ m/s，$v_{\\max} = 5000$ m/s，以及 $\\Delta v = 1$ m/s。对于平滑的高斯密度，该网格足够精细。\n2. 对于每个网格点 $v_k$，计算先验密度 $p(v_k)$，其为带有适当归一化常数的加权高斯分量之和。\n3. 使用以 $L/v_k$ 为中心、标准差为 $\\sigma_t$ 的高斯公式计算似然 $p(t_{\\text{obs}} \\mid v_k)$。\n4. 对于每个温度 $\\beta \\in \\{1.0, 0.5, 0.1\\}$，计算未归一化的退火后验 $u_{\\beta}(v_k) = p(v_k)\\left[p(t_{\\text{obs}} \\mid v_k)\\right]^{\\beta}$。\n5. 计算归一化常数 $Z_{\\beta} = \\sum_k u_{\\beta}(v_k) \\Delta v$ 和低模态质量 $M_{\\beta}^{\\text{low}} = \\sum_{v_k \\leq v_{\\text{mid}}} u_{\\beta}(v_k) \\Delta v$。\n6. 分数为 $f_1(\\beta) = M_{\\beta}^{\\text{low}} / Z_{\\beta}$。由于网格是均匀的，包含 $\\Delta v$ 可确保量纲一致性；请注意，它在比率中会被约掉，但在表示数值积分时，它的存在是科学上正确的。\n\n数值和物理一致性：\n- 高斯密度使用其完整的归一化常数进行评估，这对于科学真实性很重要，尽管比率不依赖于这些常数。\n- 正演模型 $t = L/v$ 源于基本运动学，适用于均匀介质和直线射线，这是地球物理学中一个常见的参考案例。\n- 所选的测试用例确保了对多峰性处理的覆盖：\n  - 一个模糊场景，其中在 $\\beta = 1$ 或退火条件下，两个模态都可能携带显著质量。\n  - 一个强信息场景，其中似然函数选择了高速模态。\n  - 一个弥散场景，由于似然函数较宽，后验分布接近先验混合分布。\n  - 一个倾斜先验场景，测试先验权重和数据一致性之间的相互作用。\n\n实现细节：\n- 程序将测试用例定义为一个列表，为每个用例评估 $f_1(\\beta)$，并按要求打印一个单行的、四舍五入到六位小数的浮点数列表。\n- 所有输出都是无单位小数；网格积分使用 $\\Delta v = 1$ m/s 来产生一致的比率。\n\n这个从第一性原理出发的过程展示了在贝叶斯反演中，多峰性如何从混合先验中产生，以及退火如何修改后验以促进跨越相互竞争的地质假设的不确定性量化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_pdf(x, mean, std):\n    \"\"\"Compute the Gaussian density with full normalizing constant.\"\"\"\n    coef = 1.0 / (np.sqrt(2.0 * np.pi) * std)\n    return coef * np.exp(-0.5 * ((x - mean) / std) ** 2)\n\ndef prior_mixture_pdf(v, w1, v1, s1, w2, v2, s2):\n    \"\"\"Mixture of two Gaussian components in velocity.\"\"\"\n    return w1 * gaussian_pdf(v, v1, s1) + w2 * gaussian_pdf(v, v2, s2)\n\ndef likelihood_t_given_v(t_obs, L, v, sigma_t):\n    \"\"\"Gaussian likelihood in travel time given velocity via t = L / v.\"\"\"\n    mean_t = L / v\n    return gaussian_pdf(t_obs, mean_t, sigma_t)\n\ndef tempered_mass_fraction_lower_mode(L, t_obs, sigma_t, w1, v1, s1, w2, v2, s2, betas, vmin=1000.0, vmax=5000.0, dv=1.0):\n    \"\"\"\n    Compute f1(beta): fraction of tempered posterior mass in lower-velocity region v = (v1+v2)/2.\n    \"\"\"\n    # Velocity grid\n    v_grid = np.arange(vmin, vmax + dv, dv)\n    # Prior on grid\n    p_prior = prior_mixture_pdf(v_grid, w1, v1, s1, w2, v2, s2)\n    # Likelihood on grid\n    p_like = likelihood_t_given_v(t_obs, L, v_grid, sigma_t)\n    # Midpoint between modes\n    v_mid = 0.5 * (v1 + v2)\n    # Indicator for lower-mode region\n    lower_mask = v_grid = v_mid\n\n    fractions = []\n    for beta in betas:\n        # Tempered unnormalized posterior\n        u_beta = p_prior * (p_like ** beta)\n        # Integrals via Riemann sum (uniform grid)\n        Z_beta = np.sum(u_beta) * dv\n        M_beta_low = np.sum(u_beta[lower_mask]) * dv\n        f1 = M_beta_low / Z_beta if Z_beta > 0.0 else 0.0\n        fractions.append(f1)\n    return fractions\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L, t_obs, sigma_t, w1, v1, s1, w2, v2, s2)\n    test_cases = [\n        # 1. Ambiguous case\n        (1000.0, 0.33, 0.08, 0.5, 2000.0, 200.0, 0.5, 3500.0, 300.0),\n        # 2. Strongly informative case favoring higher velocity\n        (1000.0, 0.286, 0.01, 0.5, 2000.0, 200.0, 0.5, 3500.0, 300.0),\n        # 3. Diffuse case\n        (1000.0, 0.40, 0.20, 0.5, 2000.0, 200.0, 0.5, 3500.0, 300.0),\n        # 4. Skewed prior case\n        (1000.0, 0.32, 0.03, 0.7, 2200.0, 150.0, 0.3, 3800.0, 400.0),\n    ]\n\n    betas = [1.0, 0.5, 0.1]\n\n    results = []\n    for case in test_cases:\n        L, t_obs, sigma_t, w1, v1, s1, w2, v2, s2 = case\n        fractions = tempered_mass_fraction_lower_mode(\n            L=L,\n            t_obs=t_obs,\n            sigma_t=sigma_t,\n            w1=w1,\n            v1=v1,\n            s1=s1,\n            w2=w2,\n            v2=v2,\n            s2=s2,\n            betas=betas,\n            vmin=1000.0,\n            vmax=5000.0,\n            dv=1.0\n        )\n        results.extend([f\"{val:.6f}\" for val in fractions])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}