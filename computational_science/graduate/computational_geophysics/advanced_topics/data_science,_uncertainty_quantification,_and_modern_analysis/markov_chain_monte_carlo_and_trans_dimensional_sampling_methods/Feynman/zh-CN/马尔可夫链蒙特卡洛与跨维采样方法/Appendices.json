{
    "hands_on_practices": [
        {
            "introduction": "在可逆跳跃马尔可夫链蒙特卡洛（RJMCMC）中，改变模型维数的移动（例如，将一个地层分裂为两个）需要进行变量代换。为了确保细致平衡条件得到满足，接受概率必须包含一个校正因子，即变换的雅可比行列式。这项练习  将集中于计算一个常见的“分裂”移动的雅可比行列式，为实现更复杂的跨维度算法奠定坚实的数学基础。",
            "id": "3609556",
            "problem": "在用于跨维度地球物理反演的可逆跳跃马尔可夫链蒙特卡洛 (RJMCMC) 方法中，一种常见的提议是分裂移动，它通过将厚度为 $h$ 的单个地层分裂为两个厚度分别为 $h_1$ 和 $h_2$ 的子层来增加模型维度，同时也将诸如地震波速度 $v$ 的层属性扰动为两个子属性 $v_1$ 和 $v_2$。假设分裂移动是通过抽取一个辅助变量 $r \\in (0,1)$ 和一个扰动 $\\delta \\in \\mathbb{R}$ 来构建的，并定义了如下的前向维度匹配变换\n$$\n(h, r, v, \\delta) \\mapsto (h_1, h_2, v_1, v_2)\n$$\n其关系式为\n$$\nh_1 = r\\, h, \\quad h_2 = (1 - r)\\, h, \\quad v_1 = v - \\frac{\\delta}{2}, \\quad v_2 = v + \\frac{\\delta}{2}.\n$$\n假设物理约束 $h  0$ 成立。在 RJMCMC 中，变量变换下的细致平衡要求上述变换的雅可比行列式的绝对值。\n\n从可微双射的变量变换原理以及雅可比矩阵（目标变量关于源变量的一阶偏导数矩阵）的定义出发，计算从 $(h, r, v, \\delta)$ 到 $(h_1, h_2, v_1, v_2)$ 的组合映射的雅可比行列式的绝对值。将你的最终答案表示为仅含 $h$ 的闭式解析表达式。",
            "solution": "该问题要求计算在可逆跳跃马尔可夫链蒙特卡洛 (RJMCMC) 中使用的给定跨维变换的雅可比行列式的绝对值。该变换将源变量 $(h, r, v, \\delta)$ 映射到目标变量 $(h_1, h_2, v_1, v_2)$。\n\n设源变量向量为 $\\mathbf{x} = (x_1, x_2, x_3, x_4) = (h, r, v, \\delta)$，目标变量向量为 $\\mathbf{y} = (y_1, y_2, y_3, y_4) = (h_1, h_2, v_1, v_2)$。该变换由以下方程组定义：\n$$\nh_1 = r h\n$$\n$$\nh_2 = (1 - r) h\n$$\n$$\nv_1 = v - \\frac{\\delta}{2}\n$$\n$$\nv_2 = v + \\frac{\\delta}{2}\n$$\n\n雅可比矩阵，记为 $J$，是目标变量关于源变量的所有一阶偏导数构成的矩阵。$J$ 的第 $i$ 行第 $j$ 列的元素由 $J_{ij} = \\frac{\\partial y_i}{\\partial x_j}$ 给出。因此，雅可比矩阵是一个 $4 \\times 4$ 的矩阵：\n$$\nJ = \\frac{\\partial(h_1, h_2, v_1, v_2)}{\\partial(h, r, v, \\delta)} = \\begin{pmatrix}\n\\frac{\\partial h_1}{\\partial h}  \\frac{\\partial h_1}{\\partial r}  \\frac{\\partial h_1}{\\partial v}  \\frac{\\partial h_1}{\\partial \\delta} \\\\\n\\frac{\\partial h_2}{\\partial h}  \\frac{\\partial h_2}{\\partial r}  \\frac{\\partial h_2}{\\partial v}  \\frac{\\partial h_2}{\\partial \\delta} \\\\\n\\frac{\\partial v_1}{\\partial h}  \\frac{\\partial v_1}{\\partial r}  \\frac{\\partial v_1}{\\partial v}  \\frac{\\partial v_1}{\\partial \\delta} \\\\\n\\frac{\\partial v_2}{\\partial h}  \\frac{\\partial v_2}{\\partial r}  \\frac{\\partial v_2}{\\partial v}  \\frac{\\partial v_2}{\\partial \\delta}\n\\end{pmatrix}\n$$\n我们根据给定的变换方程计算每个偏导数。\n\n对于第一行（$h_1 = r h$ 的导数）：\n$\\frac{\\partial h_1}{\\partial h} = r$\n$\\frac{\\partial h_1}{\\partial r} = h$\n$\\frac{\\partial h_1}{\\partial v} = 0$\n$\\frac{\\partial h_1}{\\partial \\delta} = 0$\n\n对于第二行（$h_2 = (1 - r) h$ 的导数）：\n$\\frac{\\partial h_2}{\\partial h} = 1 - r$\n$\\frac{\\partial h_2}{\\partial r} = -h$\n$\\frac{\\partial h_2}{\\partial v} = 0$\n$\\frac{\\partial h_2}{\\partial \\delta} = 0$\n\n对于第三行（$v_1 = v - \\frac{\\delta}{2}$ 的导数）：\n$\\frac{\\partial v_1}{\\partial h} = 0$\n$\\frac{\\partial v_1}{\\partial r} = 0$\n$\\frac{\\partial v_1}{\\partial v} = 1$\n$\\frac{\\partial v_1}{\\partial \\delta} = -\\frac{1}{2}$\n\n对于第四行（$v_2 = v + \\frac{\\delta}{2}$ 的导数）：\n$\\frac{\\partial v_2}{\\partial h} = 0$\n$\\frac{\\partial v_2}{\\partial r} = 0$\n$\\frac{\\partial v_2}{\\partial v} = 1$\n$\\frac{\\partial v_2}{\\partial \\delta} = \\frac{1}{2}$\n\n将这些导数代入雅可比矩阵，得到：\n$$\nJ = \\begin{pmatrix}\nr  h  0  0 \\\\\n1 - r  -h  0  0 \\\\\n0  0  1  -\\frac{1}{2} \\\\\n0  0  1  \\frac{1}{2}\n\\end{pmatrix}\n$$\n这个矩阵具有块对角结构：\n$$\nJ = \\begin{pmatrix} A  0 \\\\ 0  B \\end{pmatrix}\n$$\n其中 $A = \\begin{pmatrix} r  h \\\\ 1 - r  -h \\end{pmatrix}$ 且 $B = \\begin{pmatrix} 1  -\\frac{1}{2} \\\\ 1  \\frac{1}{2} \\end{pmatrix}$。\n块对角矩阵的行列式是其对角块行列式的乘积。因此，$\\det(J) = \\det(A) \\det(B)$。\n\n首先，我们计算块 $A$ 的行列式：\n$$\n\\det(A) = \\det \\begin{pmatrix} r  h \\\\ 1 - r  -h \\end{pmatrix} = (r)(-h) - (h)(1 - r) = -rh - h + rh = -h\n$$\n接着，我们计算块 $B$ 的行列式：\n$$\n\\det(B) = \\det \\begin{pmatrix} 1  -\\frac{1}{2} \\\\ 1  \\frac{1}{2} \\end{pmatrix} = (1)\\left(\\frac{1}{2}\\right) - \\left(-\\frac{1}{2}\\right)(1) = \\frac{1}{2} + \\frac{1}{2} = 1\n$$\n完整的雅可比矩阵 $J$ 的行列式是这两个行列式的乘积：\n$$\n\\det(J) = \\det(A) \\det(B) = (-h)(1) = -h\n$$\n问题要求的是雅可比行列式的绝对值 $|\\det(J)|$。\n$$\n|\\det(J)| = |-h|\n$$\n考虑到层厚度必须为正的物理约束 $h  0$，绝对值可以简化为：\n$$\n|\\det(J)| = h\n$$\n结果是仅含 $h$ 的闭式表达式，符合题目要求。",
            "answer": "$$\\boxed{h}$$"
        },
        {
            "introduction": "掌握了雅可比行列式的计算后，我们便可以构建一个完整的跨维度采样器。这项练习涉及为一个层状地球模型设计“诞生”（分裂）和“消亡”（合并）移动，从而动态地改变模型中的地层数量。这项全面的编程实践  将RJMCMC的所有关键组成部分——似然比、先验比、提议比和雅可比行列式——整合在一起，让您通过为一个实际的地球物理反演问题计算接受概率，获得构建和调试跨维度采样器的宝贵经验。",
            "id": "3609577",
            "problem": "您的任务是为一个层数未知的一维分层地球模型实现一个 Metropolis–Hastings–Green 跨维度采样器组件。该模型由一系列具有正厚度和正P波速度的水平地层组成。正演模型将一个分层模型映射到一个零偏移距垂直走时，该走时是每层走时之和。\n\n您必须设计和实现“诞生”和“消亡”移动，这些移动将层数改变一，同时通过一个由辅助随机变量增强的确定性、可微且可逆的映射来保持可逆性。您的实现必须使用贝叶斯推断原理和马尔可夫链的细致平衡来计算单个提议移动的接受概率。所有计算必须基于指定的先验和提议分布，并且接受概率必须考虑模型维度的变化、层数的先验、参数的先验、似然、提议密度以及映射的雅可比行列式的绝对值。\n\n使用以下基本原理：\n\n- 用于后验概率的贝叶斯法则。\n- 确保可逆性的马尔可夫链细致平衡。\n- 可逆跳跃马尔可夫链蒙特卡洛（Reversible Jump Markov Chain Monte Carlo）中的跨维度映射的维度匹配原理和雅可比行列式的引入。\n\n模型规格：\n\n- 一个模型有 $K$ 层，其中 $K \\in \\{K_{\\min},\\ldots,K_{\\max}\\}$，$K_{\\min} = 1$ 且 $K_{\\max} = 5$。每一层 $i \\in \\{1,\\ldots,K\\}$ 的厚度为 $h_i \\in \\mathbb{R}_{+}$ (单位：米)，P波速度为 $v_i \\in \\mathbb{R}_{+}$ (单位：米/秒)。\n- 零偏移距垂直走时为\n$$\nT(m) = \\sum_{i=1}^{K} \\frac{h_i}{v_i} \\quad \\text{秒}.\n$$\n- 数据由单个观测值 $T_{\\text{obs}}$ 组成，该观测值带有标准差已知的独立高斯噪声 $\\sigma_T$ (单位：秒)。\n\n先验：\n\n- 层数的先验是在 $\\{K_{\\min},\\ldots,K_{\\max}\\}$ 上的截断泊松分布，其率为 $\\lambda$：\n$$\np(K) = \\frac{\\exp(-\\lambda)\\lambda^{K}/K!}{\\sum_{k=K_{\\min}}^{K_{\\max}} \\exp(-\\lambda)\\lambda^{k}/k!}.\n$$\n- 给定 $K$，各层厚度是独立同分布的，服从率为 $\\beta_h$ 的指数分布：\n$$\np(h_i) = \\beta_h \\exp(-\\beta_h h_i), \\quad h_i  0.\n$$\n- 给定 $K$，各层速度是独立同分布的，服从参数为 $\\mu_v$ 和 $\\sigma_v$ 的对数正态分布：\n$$\n\\ln v_i \\sim \\mathcal{N}(\\mu_v,\\sigma_v^2), \\quad v_i  0.\n$$\n\n似然：\n\n- 单个观测值的似然是高斯分布：\n$$\np(T_{\\text{obs}}\\mid m) \\propto \\exp\\!\\left(-\\frac{(T(m) - T_{\\text{obs}})^2}{2\\sigma_T^2}\\right).\n$$\n\n移动类型和提议：\n\n- 在给定的 $K$ 值下，以概率 $p_b(K)$ 选择诞生移动，以概率 $p_d(K)$ 选择消亡移动：\n  - 当 $K = K_{\\min}$ 时：$p_b(K_{\\min}) = 1$ 且 $p_d(K_{\\min}) = 0$。\n  - 当 $K = K_{\\max}$ 时：$p_b(K_{\\max}) = 0$ 且 $p_d(K_{\\max}) = 1$。\n  - 其他情况：$p_b(K) = p_d(K) = 1/2$。\n- 诞生移动 ($K \\to K+1$)：从 $\\{1,\\ldots,K\\}$ 中均匀选择一个层索引 $j$。抽取 $r \\sim \\text{Beta}(1,1)$ (即在 $(0,1)$ 上的均匀分布)，以及 $\\delta \\sim \\mathcal{N}(0,\\sigma_{\\delta}^2)$。对于选中的参数为 $(h, v)$ 的层，提议将其分裂成两层，参数为\n$$\nh_1 = r h, \\quad h_2 = (1-r) h, \\quad v_1 = v\\,\\exp(\\delta), \\quad v_2 = v\\,\\exp(-\\delta).\n$$\n将这两个新层插入以替换原始层。从 $(h,v,r,\\delta)$到 $(h_1,h_2,v_1,v_2)$ 的变换的雅可比行列式的绝对值必须被包括在内。\n- 消亡移动 ($K \\to K-1$)：从 $\\{(1,2),(2,3),\\ldots,(K-1,K)\\}$ 中均匀选择一个相邻对 $(j,j+1)$。将其合并成一个单层，参数为\n$$\nh = h_1 + h_2, \\quad v = \\sqrt{v_1 v_2}.\n$$\n逆映射产生辅助变量\n$$\nr = \\frac{h_1}{h_1 + h_2}, \\quad \\delta = \\tfrac{1}{2}\\ln\\!\\left(\\frac{v_1}{v_2}\\right),\n$$\n这些变量必须用于评估诞生移动的逆向提议密度，并包括正确的逆雅可比行列式的绝对值。\n\n提议密度：\n\n- 对于诞生移动的正向提议，密度因子包括移动类型概率 $p_b(K)$、以概率 $1/K$ 均匀选择 $j$ 的概率，以及辅助变量 $r$ 和 $\\delta$ 的密度：\n$$\nf_r(r) = 1 \\ \\text{for} \\ r \\in (0,1), \\quad f_{\\delta}(\\delta) = \\frac{1}{\\sigma_{\\delta}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{\\delta^2}{2\\sigma_{\\delta}^2}\\right).\n$$\n- 对于消亡移动的正向提议，密度因子包括移动类型概率 $p_d(K)$ 和以概率 $1/(K-1)$ 均匀选择对 $(j,j+1)$ 的概率。\n\n您的程序必须通过组合后验因子、正向和逆向提议密度以及雅可比行列式的绝对值，为下面测试套件中的每个提议移动计算 Metropolis–Hastings–Green 接受概率。如果提议的移动因违反 $K$ 的边界而无效（例如，在 $K = K_{\\min}$ 时进行消亡移动或在 $K = K_{\\max}$ 时进行诞生移动），则接受概率必须返回 $0.0$。\n\n所有测试用例的全局常量：\n\n- 使用 $\\lambda = 2.5$，$K_{\\min}=1$，$K_{\\max}=5$。\n- 使用 $\\beta_h = 1/1000$ (单位：$\\text{m}^{-1}$)。\n- 使用 $\\mu_v = \\ln(2200)$ 和 $\\sigma_v = 0.25$。\n- 使用 $\\sigma_{\\delta} = 0.2$。\n- 使用 $T_{\\text{obs}} = 0.6$ 秒和 $\\sigma_T = 0.02$ 秒。\n\n角度单位不适用。所有物理量必须使用国际单位制：厚度以米为单位，速度以米/秒为单位，时间以秒为单位。\n\n测试套件：\n\n每个测试用例指定移动类型、当前层数 $K$、当前厚度和速度列表、为移动选择的索引以及任何所需的辅助变量。选定索引的解释如下：\n- 对于诞生，选定的索引 $j$ 是要分裂的层（基于1）。\n- 对于消亡，选定的索引 $j$ 是要合并的相邻对 $(j, j+1)$ 中的第一层（基于1）。\n\n为每个用例提供一个浮点数作为接受概率。\n\n- 用例1 (顺利的诞生):\n  - 移动：诞生\n  - $K = 2$\n  - 厚度 $[500.0, 700.0]$ 米\n  - 速度 $[2000.0, 2500.0]$ 米/秒\n  - 选定索引 $j = 2$\n  - $r = 0.4$\n  - $\\delta = 0.1$\n- 用例2 (顺利的消亡):\n  - 移动：消亡\n  - $K = 3$\n  - 厚度 $[500.0, 280.0, 420.0]$ 米\n  - 速度 $[2000.0, 2762.925465, 2262.093545]$ 米/秒\n  - 选定索引 $j = 2$ (合并第2层和第3层)\n- 用例3 (边界无效消亡):\n  - 移动：消亡\n  - $K = 1$\n  - 厚度 $[1200.0]$ 米\n  - 速度 $[2300.0]$ 米/秒\n  - 选定索引 $j = 1$\n- 用例4 (边界无效诞生):\n  - 移动：诞生\n  - $K = 5$\n  - 厚度 $[300.0, 400.0, 500.0, 600.0, 700.0]$ 米\n  - 速度 $[1800.0, 2000.0, 2200.0, 2400.0, 2600.0]$ 米/秒\n  - 选定索引 $j = 3$\n  - $r = 0.5$\n  - $\\delta = 0.0$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"），顺序与测试用例相同。每个结果必须是 $[0,1]$ 内的浮点数，代表相应测试用例的接受概率。没有用户输入，程序必须使用上述指定的值确定性地运行。",
            "solution": "该问题要求在一个地球物理反演问题中，为跨维度的诞生和消亡移动计算 Metropolis–Hastings–Green 接受概率。该模型将地球次表层表示为一系列一维地层，其中层数 $K$ 是一个待推断的未知参数。该解决方案涉及应用可逆跳跃马尔可夫链蒙特卡洛 (Reversible Jump Markov Chain Monte Carlo, RJMCMC) 的原理。\n\n从当前模型状态 $m$ 移动到提议的模型状态 $m'$ 的接受概率 $\\alpha$ 由下式给出：\n$$\n\\alpha(m'|m) = \\min \\left(1, A \\right)\n$$\n其中 $A$ 是接受率。对于参数空间维度发生变化的跨维度移动，该比率由后验概率比、提议概率比以及在空间之间映射的变换的雅可比行列式的绝对值组成。\n\n后验概率 $p(m|d)$ 由贝叶斯法则给出，$p(m|d) \\propto p(d|m) p(m)$，其中 $p(d|m)$ 是似然，$p(m)$ 是先验。完整先验为 $p(m) = p(\\mathbf{h}, \\mathbf{v}, K) = p(\\mathbf{h}, \\mathbf{v}|K) p(K)$。给定 $K$，所有层参数 $(h_i, v_i)$都是独立的，因此 $p(\\mathbf{h}, \\mathbf{v}|K) = \\prod_{i=1}^K p(h_i) p(v_i)$。\n\n从 $m$ 到 $m'$ 移动的接受率的一般形式是：\n$$\nA = \\frac{p(m'|d)}{p(m|d)} \\frac{q(m|m')}{q(m'|m)} |J| = \\underbrace{\\frac{p(d|m')}{p(d|m)}}_{\\text{似然比}} \\underbrace{\\frac{p(m')}{p(m)}}_{\\text{先验比}} \\underbrace{\\frac{q(m|m')}{q(m'|m)}}_{\\text{提议比}} \\underbrace{|J|}_{\\text{雅可比行列式}}\n$$\n这里，$q(m'|m)$ 是正向提议密度，$q(m|m')$ 是逆向提议密度，$|J|$ 是维度匹配变换的雅可比项。我们将分别分析诞生和消亡移动。为避免数值下溢，所有计算都使用对数概率进行。对数接受率为 $\\log A$，且 $\\alpha = \\min(1, \\exp(\\log A))$。\n\n### 函数定义\n首先，我们根据问题规范定义各个组件的对数概率。\n- 走时：$T(m) = \\sum_{i=1}^{K} h_i/v_i$\n- 对数似然（忽略在比率中抵消的常数）：$\\log p(d|m) = -\\frac{(T(m) - T_{\\text{obs}})^2}{2\\sigma_T^2}$\n- $K$ 的对数先验：$\\log p(K) = -\\lambda + K\\log\\lambda - \\ln(K!) - \\log C$，其中 $C$ 是 $\\{K_{\\min}, ..., K_{\\max}\\}$ 上截断泊松分布的归一化常数。\n- 厚度 $h_i$ 的对数先验：$\\log p(h_i) = \\log\\beta_h - \\beta_h h_i$ for $h_i  0$。\n- 速度 $v_i$ 的对数先验：$\\log p(v_i) = -\\ln v_i - \\ln(\\sigma_v\\sqrt{2\\pi}) - \\frac{(\\ln v_i - \\mu_v)^2}{2\\sigma_v^2}$ for $v_i  0$。\n- 辅助变量 $\\delta$ 的对数提议：$\\log f_\\delta(\\delta) = -\\ln(\\sigma_\\delta\\sqrt{2\\pi}) - \\frac{\\delta^2}{2\\sigma_\\delta^2}$。$r$ 的提议是 $U(0,1)$，因此其密度为 $f_r(r)=1$，对数密度为 $\\log f_r(r)=0$。\n\n### 诞生移动 ($K \\to K+1$)\n诞生移动提议将层数从 $K$ 增加到 $K+1$。\n1.  **状态和提议**：当前模型是 $m_c$，有 $K$ 层。均匀地（以概率 $1/K$）选择一层 $j$，其参数为 $(h_j, v_j)$。抽取两个辅助变量 $r \\sim U(0,1)$ 和 $\\delta \\sim \\mathcal{N}(0, \\sigma_\\delta^2)$。提议的模型 $m_p$ 有 $K+1$ 层，其中第 $j$ 层被两个参数为 $(h_{p1}, v_{p1})$ 和 $(h_{p2}, v_{p2})$ 的新层所取代。\n2.  **变换**：确定性映射为 $(h_j, v_j, r, \\delta) \\mapsto (h_{p1}, h_{p2}, v_{p1}, v_{p2})$，其中：\n    $h_{p1} = r h_j$, $h_{p2} = (1-r) h_j$, $v_{p1} = v_j e^\\delta$, $v_{p2} = v_j e^{-\\delta}$。\n3.  **雅可比行列式**：此变换的雅可比矩阵是 $J = \\frac{\\partial(h_{p1}, h_{p2}, v_{p1}, v_{p2})}{\\partial(h_j, v_j, r, \\delta)}$。其行列式为 $\\det(J) = 2h_j v_j$。绝对值为 $|J| = 2h_j v_j$。\n4.  **提议密度**：\n    -   正向提议密度：$q(m_p|m_c) = p_b(K) \\cdot \\frac{1}{K} \\cdot f_r(r) \\cdot f_\\delta(\\delta)$。\n    -   逆向提议（从 $K+1$ 层进行消亡）：从 $K$ 个可用的相邻对中均匀选择一对进行合并。逆向提议密度为 $q(m_c|m_p) = p_d(K+1) \\cdot \\frac{1}{K}$。\n5.  **接受率**：完整的对数接受率为：\n$\\log A_{\\text{birth}} = \\log\\left(\\frac{p(d|m_p)}{p(d|m_c)}\\right) + \\log\\left(\\frac{p(m_p)}{p(m_c)}\\right) + \\log\\left(\\frac{q(m_c|m_p)}{q(m_p|m_c)}\\right) + \\log|J|$\n代入各个组成部分：\n$\\log A_{\\text{birth}} = \\left(\\log p(d|m_p) - \\log p(d|m_c)\\right) + \\left(\\log p(K+1) - \\log p(K)\\right) + \\left(\\log p(h_{p1}) + \\log p(h_{p2}) - \\log p(h_j)\\right) + \\left(\\log p(v_{p1}) + \\log p(v_{p2}) - \\log p(v_j)\\right) + \\left(\\log p_d(K+1) - \\log p_b(K)\\right) - \\log f_\\delta(\\delta) + \\log(2 h_j v_j)$。\n问题规定，如果 $K=K_{\\max}$，则该移动无效，接受概率为 $0$。\n\n### 消亡移动 ($K \\to K-1$)\n消亡移动提议将层数从 $K$ 减少到 $K-1$。它是诞生移动的逆操作。\n1.  **状态和提议**：当前模型是 $m_c$，有 $K$ 层。均匀地（以概率 $1/(K-1)$）选择一个相邻的层对 $(j, j+1)$，其参数为 $(h_j, v_j, h_{j+1}, v_{j+1})$。它们被合并成一个单层，形成具有 $K-1$ 层的提议模型 $m_p$。\n2.  **变换**：确定性合并操作为：\n    $h_p = h_j + h_{j+1}$, $v_p = \\sqrt{v_j v_{j+1}}$。\n3.  **雅可比行列式**：此移动是诞生移动的逆操作。接受率中的雅可比项是诞生移动雅可比行列式的倒数，即 $1/|J| = 1/(2h_p v_p)$。\n4.  **提议密度**：\n    -   正向提议密度：$q(m_p|m_c) = p_d(K) \\cdot \\frac{1}{K-1}$。\n    -   逆向提议（从 $K-1$ 层进行诞生）：选择合并后的层进行分裂。此逆向移动的辅助变量是确定性计算的：$r = h_j / (h_j + h_{j+1})$ 和 $\\delta = \\frac{1}{2}\\ln(v_j/v_{j+1})$。逆向提议密度为 $q(m_c|m_p) = p_b(K-1) \\cdot \\frac{1}{K-1} \\cdot f_r(r) \\cdot f_\\delta(\\delta)$。\n5.  **接受率**：对数接受率为：\n$\\log A_{\\text{death}} = \\log\\left(\\frac{p(d|m_p)}{p(d|m_c)}\\right) + \\log\\left(\\frac{p(m_p)}{p(m_c)}\\right) + \\log\\left(\\frac{q(m_c|m_p)}{q(m_p|m_c)}\\right) - \\log|J|$\n代入各个组成部分：\n$\\log A_{\\text{death}} = \\left(\\log p(d|m_p) - \\log p(d|m_c)\\right) + \\left(\\log p(K-1) - \\log p(K)\\right) + \\left(\\log p(h_{p}) - \\log p(h_j) - \\log p(h_{j+1})\\right) + \\left(\\log p(v_{p}) - \\log p(v_j) - \\log p(v_{j+1})\\right) + \\left(\\log p_b(K-1) - \\log p_d(K)\\right) + \\log f_r(r) + \\log f_\\delta(\\delta) - \\log(2 h_p v_p)$。\n问题规定，如果 $K=K_{\\min}$，则该移动无效，接受概率为 $0$。\n\n以下实现为提供的测试用例计算这些接受概率。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln, logsumexp\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints results.\n    \"\"\"\n    # Define global constants for the model\n    LAMBDA = 2.5\n    K_MIN = 1\n    K_MAX = 5\n    BETA_H = 1.0 / 1000.0\n    MU_V = np.log(2200.0)\n    SIGMA_V = 0.25\n    SIGMA_DELTA = 0.2\n    T_OBS = 0.6\n    SIGMA_T = 0.02\n    \n    # Pre-compute the normalization constant for the truncated Poisson prior on K\n    log_poisson_k_terms = [\n        k * np.log(LAMBDA) - gammaln(k + 1) for k in range(K_MIN, K_MAX + 1)\n    ]\n    log_poisson_k_norm_const = -LAMBDA + logsumexp(log_poisson_k_terms)\n\n    def log_p_k(k):\n        \"\"\"Computes the log-prior probability for the number of layers, log p(K).\"\"\"\n        if not (K_MIN = k = K_MAX):\n            return -np.inf\n        log_unnorm_prob = -LAMBDA + k * np.log(LAMBDA) - gammaln(k + 1)\n        return log_unnorm_prob - log_poisson_k_norm_const\n\n    def log_p_h(h):\n        \"\"\"Computes the log-prior probability for a layer thickness, log p(h).\"\"\"\n        if h = 0:\n            return -np.inf\n        return np.log(BETA_H) - BETA_H * h\n\n    def log_p_v(v):\n        \"\"\"Computes the log-prior probability for a layer velocity, log p(v).\"\"\"\n        if v = 0:\n            return -np.inf\n        log_v = np.log(v)\n        return -log_v - np.log(SIGMA_V * np.sqrt(2 * np.pi)) - \\\n               (log_v - MU_V)**2 / (2 * SIGMA_V**2)\n\n    def log_f_delta(delta):\n        \"\"\"Computes the log-density of the auxiliary variable delta.\"\"\"\n        return -np.log(SIGMA_DELTA * np.sqrt(2 * np.pi)) - \\\n               delta**2 / (2 * SIGMA_DELTA**2)\n\n    def travel_time(h_list, v_list):\n        \"\"\"Computes the total vertical travel time.\"\"\"\n        return np.sum(np.array(h_list) / np.array(v_list))\n\n    def get_move_prob(k, move_type):\n        \"\"\"Gets the probability of proposing a birth or death move at K layers.\"\"\"\n        if move_type == 'birth':\n            if k == K_MAX: return 0.0\n            if k == K_MIN: return 1.0\n            return 0.5\n        elif move_type == 'death':\n            if k == K_MIN: return 0.0\n            if k == K_MAX: return 1.0\n            return 0.5\n        return 0.0\n\n    def calculate_acceptance_prob(case):\n        \"\"\"Calculates the Metropolis-Hastings-Green acceptance probability for a given case.\"\"\"\n        move = case['move']\n        k_c = case['k']\n        h_c = case['h']\n        v_c = case['v']\n        j_idx = case['j'] - 1  # 1-based to 0-based index\n\n        # --- Handle BIRTH move ---\n        if move == 'birth':\n            if k_c == K_MAX:\n                return 0.0\n\n            r = case['r']\n            delta = case['delta']\n            \n            h_j_split = h_c[j_idx]\n            v_j_split = v_c[j_idx]\n            T_c = travel_time(h_c, v_c)\n\n            k_p = k_c + 1\n            h_p1, h_p2 = r * h_j_split, (1 - r) * h_j_split\n            v_p1, v_p2 = v_j_split * np.exp(delta), v_j_split * np.exp(-delta)\n            \n            h_p = h_c[:j_idx] + [h_p1, h_p2] + h_c[j_idx+1:]\n            v_p = v_c[:j_idx] + [v_p1, v_p2] + v_c[j_idx+1:]\n            T_p = travel_time(h_p, v_p)\n            \n            log_likelihood_ratio = -0.5 / SIGMA_T**2 * ((T_p - T_OBS)**2 - (T_c - T_OBS)**2)\n            log_k_prior_ratio = log_p_k(k_p) - log_p_k(k_c)\n            log_h_prior_ratio = log_p_h(h_p1) + log_p_h(h_p2) - log_p_h(h_j_split)\n            log_v_prior_ratio = log_p_v(v_p1) + log_p_v(v_p2) - log_p_v(v_j_split)\n            log_proposal_ratio = np.log(get_move_prob(k_p, 'death') / get_move_prob(k_c, 'birth'))\n            log_aux_proposal_ratio = -log_f_delta(delta) # log_f_r(r) is 0\n            log_jacobian = np.log(2 * h_j_split * v_j_split)\n            \n            # The choice probability ratio is (1/K_p_pairs) / (1/K_c_layers) = (1/k_c) / (1/k_c) = 1, so it cancels out.\n            \n            log_A = (log_likelihood_ratio + log_k_prior_ratio + log_h_prior_ratio + \n                     log_v_prior_ratio + log_proposal_ratio + log_aux_proposal_ratio + \n                     log_jacobian)\n\n            return min(1.0, np.exp(log_A))\n\n        # --- Handle DEATH move ---\n        elif move == 'death':\n            if k_c == K_MIN:\n                return 0.0\n\n            h_j1, h_j2 = h_c[j_idx], h_c[j_idx+1]\n            v_j1, v_j2 = v_c[j_idx], v_c[j_idx+1]\n            T_c = travel_time(h_c, v_c)\n            \n            k_p = k_c - 1\n            h_p_merged = h_j1 + h_j2\n            v_p_merged = np.sqrt(v_j1 * v_j2)\n\n            h_p = h_c[:j_idx] + [h_p_merged] + h_c[j_idx+2:]\n            v_p = v_c[:j_idx] + [v_p_merged] + v_c[j_idx+2:]\n            T_p = travel_time(h_p, v_p)\n            \n            r = h_j1 / h_p_merged\n            delta = 0.5 * np.log(v_j1 / v_j2)\n\n            log_likelihood_ratio = -0.5 / SIGMA_T**2 * ((T_p - T_OBS)**2 - (T_c - T_OBS)**2)\n            log_k_prior_ratio = log_p_k(k_p) - log_p_k(k_c)\n            log_h_prior_ratio = log_p_h(h_p_merged) - (log_p_h(h_j1) + log_p_h(h_j2))\n            log_v_prior_ratio = log_p_v(v_p_merged) - (log_p_v(v_j1) + log_p_v(v_j2))\n            log_proposal_ratio = np.log(get_move_prob(k_p, 'birth') / get_move_prob(k_c, 'death'))\n            log_aux_proposal_ratio = log_f_delta(delta) # log_f_r(r) is 0\n            log_inv_jacobian = -np.log(2 * h_p_merged * v_p_merged)\n            \n            # The choice probability ratio is (1/K_p_layers) / (1/K_c_pairs) = (1/(k_c-1)) / (1/(k_c-1)) = 1, so it cancels out.\n            \n            log_A = (log_likelihood_ratio + log_k_prior_ratio + log_h_prior_ratio + \n                     log_v_prior_ratio + log_proposal_ratio + log_aux_proposal_ratio +\n                     log_inv_jacobian)\n\n            return min(1.0, np.exp(log_A))\n            \n        return 0.0\n\n    test_cases = [\n        {'move': 'birth', 'k': 2, 'h': [500.0, 700.0], 'v': [2000.0, 2500.0], 'j': 2, 'r': 0.4, 'delta': 0.1},\n        {'move': 'death', 'k': 3, 'h': [500.0, 280.0, 420.0], 'v': [2000.0, 2762.925465, 2262.093545], 'j': 2},\n        {'move': 'death', 'k': 1, 'h': [1200.0], 'v': [2300.0], 'j': 1},\n        {'move': 'birth', 'k': 5, 'h': [300.0, 400.0, 500.0, 600.0, 700.0], 'v': [1800.0, 2000.0, 2200.0, 2400.0, 2600.0], 'j': 3, 'r': 0.5, 'delta': 0.0},\n    ]\n\n    results = [calculate_acceptance_prob(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "跨维度采样的威力远不止改变参数数量。它为贝叶斯模型选择提供了一个严谨的框架，允许算法在完全不同的物理模型之间进行跳跃。这项高级练习  探索了在声学和弹性两种正演模型之间的跳跃，展示了RJMCMC在比较不同科学假设时的强大功能，并突出了模型证据在计算接受概率中的关键角色。",
            "id": "3609535",
            "problem": "您的任务是构建一个程序，该程序在计算地球物理学中的地震波形反演的马尔可夫链蒙特卡洛 (MCMC) 框架内，实现一个跨模型采样步骤。该程序必须计算声学正演模型和弹性正演模型之间可逆跳跃的接受率，并像在可逆跳跃马尔可夫链蒙特卡洛 (RJMCMC) 中一样，将模型索引视为一个维度变量。您的推导必须从贝叶斯定理和 Metropolis-Hastings 算法的接受准则开始，并且必须包含高斯似然归一化作为模型证据项。\n\n假设一个观测数据向量 $y \\in \\mathbb{R}^{N}$ 和两个正演模型：\n\n1. 声学正演模型 $M=\\text{a}$，参数为 $\\theta_{\\text{a}} \\in \\mathbb{R}$：\n$$\ny_{\\text{a}}(\\theta_{\\text{a}}) = G_{\\text{a}}\\,\\theta_{\\text{a}}, \\quad G_{\\text{a}} \\in \\mathbb{R}^{N \\times 1},\n$$\n其中 $G_{\\text{a}}$ 是一个已知的列向量，源自一个源子波。\n\n2. 弹性正演模型 $M=\\text{e}$，参数为 $\\theta_{\\text{e}} \\in \\mathbb{R}^{2}$：\n$$\ny_{\\text{e}}(\\theta_{\\text{e}}) = G_{\\text{e}}\\,\\theta_{\\text{e}}, \\quad G_{\\text{e}} \\in \\mathbb{R}^{N \\times 2},\n$$\n其中 $G_{\\text{e}}$ 的两列是由不同的源子波导出的已知向量。\n\n假设模型 $M$ 下的数据似然是高斯分布，协方差为 $\\Sigma_{M} = \\sigma_M^2 I$，其中 $I$ 是单位矩阵：\n$$\np(y \\mid \\theta_{M}, M) = (2\\pi)^{-\\frac{N}{2}} \\lvert \\Sigma_M \\rvert^{-\\frac{1}{2}} \\exp\\left( -\\frac{1}{2} \\left\\| y - y_M(\\theta_M) \\right\\|_{\\Sigma_M^{-1}}^2 \\right),\n$$\n其中 $\\left\\| r \\right\\|_{\\Sigma^{-1}}^2 = r^{\\mathsf{T}} \\Sigma^{-1} r$。\n\n假设参数上存在独立的高斯先验，模型索引上存在离散先验：\n$$\n\\theta_{\\text{a}} \\sim \\mathcal{N}(\\mu_{\\text{a}}, \\sigma_{\\text{pa}}^2), \\quad \\theta_{\\text{e}} \\sim \\mathcal{N}(\\mu_{\\text{e}}, \\sigma_{\\text{pe}}^2 I), \\quad p(M=\\text{a}) = \\pi_{\\text{a}}, \\quad p(M=\\text{e}) = \\pi_{\\text{e}}.\n$$\n\n对于跨维度移动，使用以下声学和弹性参数化之间的确定性、可逆的映射，并带有一个辅助随机变量 $u \\in \\mathbb{R}$：\n$$\n\\begin{aligned}\n\\text{正向 (a}\\to\\text{e):}\\quad \\phi(\\theta_{\\text{a}}, u) = \n\\begin{bmatrix}\n\\theta_{\\text{e},1} \\\\ \\theta_{\\text{e},2}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\theta_{\\text{a}} + u \\\\ \\theta_{\\text{a}} - u\n\\end{bmatrix}, \\\\\n\\text{逆向 (e}\\to\\text{a):}\\quad \\phi^{-1}(\\theta_{\\text{e}}) =\n\\begin{bmatrix}\n\\theta_{\\text{a}} \\\\ u'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\frac{1}{2}(\\theta_{\\text{e},1} + \\theta_{\\text{e},2}) \\\\\n\\frac{1}{2}(\\theta_{\\text{e},1} - \\theta_{\\text{e},2})\n\\end{bmatrix}.\n\\end{aligned}\n$$\n设辅助变量的提议密度为 $q(u) = \\mathcal{N}(0, \\sigma_u^2)$。正向映射的雅可比行列式的绝对值为：\n$$\n\\left| J_{\\text{a}\\to\\text{e}} \\right| = \\left| \\det\\left( \\frac{\\partial \\theta_{\\text{e}}}{\\partial (\\theta_{\\text{a}}, u)} \\right) \\right| = 2,\n$$\n且逆向映射满足 $\\left| J_{\\text{e}\\to\\text{a}} \\right| = \\frac{1}{2}$。\n\n从贝叶斯定理和 Metropolis-Hastings 准则出发，推导提议的跨维度移动的接受率，明确地将高斯似然归一化 $(2\\pi)^{-\\frac{N}{2}} \\lvert \\Sigma_M \\rvert^{-\\frac{1}{2}}$ 作为模型证据项包含在内。然后实现一个程序，对于下面给出的测试套件，计算每次跨模型移动的接受概率 $A = \\min\\left(1, \\exp\\left(\\log \\alpha\\right)\\right)$。\n\n您必须使用以下子波构造来定义 $G_{\\text{a}}$ 和 $G_{\\text{e}}$。令 $t \\in \\mathbb{R}^{N}$ 在一个区间内均匀采样，并定义峰值频率为 $f_0$ 的 Ricker 子波为\n$$\nw(t; f_0) = \\left(1 - 2 \\pi^2 f_0^2 t^2\\right) \\exp\\left(-\\pi^2 f_0^2 t^2 \\right).\n$$\n将 $G_{\\text{a}}$ 设置为列向量 $w(t; f_{\\text{a}})$，将 $G_{\\text{e}}$ 的两列分别设置为 $w(t; f_{\\text{p}})$ 和 $w(t; f_{\\text{s}})$，但在测试用例 4 中，$G_{\\text{e}}$ 使用与 $G_{\\text{a}}$ 相同的列。\n\n您的程序必须计算以下四个测试用例的接受概率。所有量均为无量纲。在所有测试用例中，使用 $N=64$，$t$ 在 $[-0.05, 0.05]$ 上均匀间隔。使用 $\\mu_{\\text{a}} = 0$, $\\mu_{\\text{e}} = [0, 0]$, $\\sigma_{\\text{pa}} = 2$, $\\sigma_{\\text{pe}} = 2$, $\\pi_{\\text{a}} = 0.4$, $\\pi_{\\text{e}} = 0.6$, 以及 $\\sigma_u = 0.5$。对于每个案例，观测数据 $y$ 是确定性生成的，不添加噪声。\n\n- 测试用例 1（声学到弹性，典型情况）：$f_{\\text{a}} = 40$，$f_{\\text{p}} = 30$，$f_{\\text{s}} = 60$。观测数据 $y$ 由声学模型在 $\\theta_{\\text{a,true}} = 1.0$ 处生成。似然方差：$\\sigma_{\\text{a}} = 0.1$，$\\sigma_{\\text{e}} = 0.2$。当前声学参数为 $\\theta_{\\text{a}} = 0.8$。提议 $u = 0.1$，映射到弹性参数 $\\theta_{\\text{e}} = [\\theta_{\\text{a}} + u, \\theta_{\\text{a}} - u]$。\n\n- 测试用例 2（声学到弹性，失配情况）：$f_{\\text{a}} = 40$，$f_{\\text{p}} = 30$，$f_{\\text{s}} = 60$。观测数据 $y$ 由弹性模型在 $\\theta_{\\text{e,true}} = [1.0, -0.2]$ 处生成。似然方差：$\\sigma_{\\text{a}} = 0.1$，$\\sigma_{\\text{e}} = 0.2$。当前声学参数为 $\\theta_{\\text{a}} = 1.4$。提议 $u = -0.3$，映射到弹性参数 $\\theta_{\\text{e}} = [\\theta_{\\text{a}} + u, \\theta_{\\text{a}} - u]$。\n\n- 测试用例 3（弹性到声学，反向移动）：$f_{\\text{a}} = 40$，$f_{\\text{p}} = 30$，$f_{\\text{s}} = 60$。观测数据 $y$ 由声学模型在 $\\theta_{\\text{a,true}} = 0.9$ 处生成。似然方差：$\\sigma_{\\text{a}} = 0.1$，$\\sigma_{\\text{e}} = 0.2$。当前弹性参数为 $\\theta_{\\text{e}} = [0.9, 0.9]$。使用逆向映射和隐含的 $u' = \\frac{1}{2}(\\theta_{\\text{e},1} - \\theta_{\\text{e},2})$ 计算到声学模型的反向移动的接受率。\n\n- 测试用例 4（证据主导，相同子波）：$f_{\\text{a}} = 40$，$G_{\\text{e}}$ 的两列均等于 $G_{\\text{a}}$。观测数据 $y$ 由声学模型在 $\\theta_{\\text{a,true}} = 0.7$ 处生成。似然方差：$\\sigma_{\\text{a}} = 0.05$，$\\sigma_{\\text{e}} = 1.0$。当前声学参数为 $\\theta_{\\text{a}} = 0.7$。提议 $u = 0$，映射到弹性参数 $\\theta_{\\text{e}} = [0.7, 0.7]$。\n\n您的程序应将接受率实现为\n$$\n\\log \\alpha = \\left[ \\log p(y \\mid \\theta_{\\text{target}}, M_{\\text{target}}) + \\log p(\\theta_{\\text{target}} \\mid M_{\\text{target}}) + \\log p(M_{\\text{target}}) \\right] - \\left[ \\log p(y \\mid \\theta_{\\text{current}}, M_{\\text{current}}) + \\log p(\\theta_{\\text{current}} \\mid M_{\\text{current}}) + \\log p(M_{\\text{current}}) \\right] + \\log \\left| J \\right| + \\log q_{\\text{reverse}}(u') - \\log q_{\\text{forward}}(u),\n$$\n其中 $J$ 是移动方向对应的雅可比行列式大小，$u'$ 是隐含的反向辅助变量。接受概率为 $A = \\min\\left(1, \\exp\\left(\\log \\alpha\\right)\\right)$。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个测试用例的接受概率，格式为逗号分隔的列表，并用方括号括起。例如，“[0.123,0.456,0.789,1.0]”。每个列表元素必须是浮点数。",
            "solution": "用户要求推导并实现声学和弹性地球物理模型之间跨维度 MCMC 移动的接受概率。该解决方案必须基于可逆跳跃马尔可夫链蒙特卡洛 (RJMCMC) 的原理。\n\n### 1. 理论框架\n\n该问题是 Metropolis-Hastings 算法在可变维度状态空间上的应用，由 Green (1995) 在 RJMCMC 中提出。系统的状态由对 $(M, \\theta_M)$ 给出，其中 $M$ 是模型索引 ($M \\in \\{\\text{a}, \\text{e}\\}$)，$\\theta_M$ 是该模型的参数向量。目标是从联合后验分布 $p(M, \\theta_M \\mid y) \\propto p(y \\mid \\theta_M, M) p(\\theta_M \\mid M) p(M)$ 中采样，其中 $y$ 是观测数据。\n\n跨维度移动提议从当前状态 $(M_c, \\theta_c)$ 跳跃到目标状态 $(M_t, \\theta_t)$，其中 $\\dim(\\theta_t) \\neq \\dim(\\theta_c)$。为确保维度匹配以进行有效变换，引入了一个辅助随机变量 $u$。该变换是 $(\\theta_c, u)$ 和 $\\theta_t$ 之间（对于增维移动）或 $\\theta_c$ 和 $(\\theta_t, u')$ 之间（对于降维移动）的确定性可逆映射。\n\n从状态 $x$ 到 $x'$ 的移动的通用 Metropolis-Hastings 接受率 $\\alpha$ 为：\n$$\n\\alpha(x \\to x') = \\min \\left( 1, \\frac{\\pi(x') q(x \\mid x')}{\\pi(x) q(x' \\mid x)} \\right)\n$$\n其中 $\\pi(x) = p(x \\mid y)$ 是目标后验密度，$q(x' \\mid x)$ 是提议密度。\n\n对于跨维度跳跃，此比率必须包括变换的雅可比行列式，以解释体积元的变化。问题为接受概率的比率部分的对数提供了一个通用公式，我们将采用该公式：\n$$\n\\log \\alpha = \\log\\left(\\frac{\\pi(M_t, \\theta_t)}{\\pi(M_c, \\theta_c)}\\right) + \\log|J| + \\log q_{\\text{reverse}}(u') - \\log q_{\\text{forward}}(u)\n$$\n其中 $\\pi(M, \\theta) = p(y \\mid \\theta, M) p(\\theta \\mid M) p(M)$ 是未归一化的后验密度。各项为：\n- 对数后验比：$\\log \\pi(M_t, \\theta_t) - \\log \\pi(M_c, \\theta_c)$。\n- 变换的对数雅可比行列式 $\\log|J|$。\n- 对数提议比，其解释了提议正向和反向移动的概率密度。\n\n我们分析两种类型的移动：\n\n#### 移动 1：声学到弹性（a $\\to$ e，增维）\n当前状态为 $(M_c, \\theta_c) = (M_{\\text{a}}, \\theta_{\\text{a}})$，目标状态为 $(M_t, \\theta_t) = (M_{\\text{e}}, \\theta_{\\text{e}})$。\n- 通过抽取辅助变量 $u \\sim q(u)$ 来提议正向移动，其中 $q(u)$ 是提议密度 $\\mathcal{N}(0, \\sigma_u^2)$。\n- 目标参数向量通过确定性映射计算：$\\theta_{\\text{e}} = \\phi(\\theta_{\\text{a}}, u)$。\n- 因此，正向提议密度项为 $\\log q_{\\text{forward}}(u) = \\log q(u)$。\n- 由于从 $\\theta_{\\text{e}}$ 到 $(\\theta_{\\text{a}}, u')$ 的反向移动（e $\\to$ a）是确定性的，因此正向移动的反向部分没有抽取辅助变量。因此，我们将反向提议密度设为 1，使得 $\\log q_{\\text{reverse}}(u') = 0$。\n- 雅可比行列式是针对从 $(\\theta_{\\text{a}}, u)$ 到 $\\theta_{\\text{e}}$ 的映射，因此 $|J| = |J_{\\text{a}\\to\\text{e}}|$。\n对数接受率为：\n$$\n\\log \\alpha_{\\text{a}\\to\\text{e}} = \\log\\left(\\frac{\\pi(M_{\\text{e}}, \\theta_{\\text{e}})}{\\pi(M_{\\text{a}}, \\theta_{\\text{a}})}\\right) + \\log|J_{\\text{a}\\to\\text{e}}| - \\log q(u)\n$$\n\n#### 移动 2：弹性到声学（e $\\to$ a，降维）\n当前状态为 $(M_c, \\theta_c) = (M_{\\text{e}}, \\theta_{\\text{e}})$，目标状态为 $(M_t, \\theta_t) = (M_{\\text{a}}, \\theta_{\\text{a}})$。\n- 通过应用逆映射提议正向移动：$(\\theta_{\\text{a}}, u') = \\phi^{-1}(\\theta_{\\text{e}})$。不抽取辅助变量。因此，我们将正向提议密度设为 1，使得 $\\log q_{\\text{forward}}(u) = 0$。\n- 变量 $u'$ 是确定性的。为维持细致平衡，接受概率必须考虑在反向（a $\\to$ e）移动中将使用的提议分布 $q(u)$ 下 $u'$ 的概率密度。这是“隐含的”反向提议密度，因此 $\\log q_{\\text{reverse}}(u') = \\log q(u')$。\n- 雅可比行列式是针对从 $\\theta_{\\text{e}}$ 到 $(\\theta_{\\text{a}}, u')$ 的映射，因此 $|J| = |J_{\\text{e}\\to\\text{a}}|$。\n对数接受率为：\n$$\n\\log \\alpha_{\\text{e}\\to\\text{a}} = \\log\\left(\\frac{\\pi(M_{\\text{a}}, \\theta_{\\text{a}})}{\\pi(M_{\\text{e}}, \\theta_{\\text{e}})}\\right) + \\log|J_{\\text{e}\\to\\text{a}}| + \\log q(u')\n$$\n\n### 2. 分量推导\n\n为了实现计算，我们必须写出对数概率项的显式形式。\n\n**对数似然：** $\\log p(y \\mid \\theta_M, M)$\n给定高斯似然 $p(y \\mid \\theta_{M}, M) = (2\\pi)^{-\\frac{N}{2}} \\lvert \\Sigma_M \\rvert^{-\\frac{1}{2}} \\exp\\left( -\\frac{1}{2} \\| y - G_M\\theta_M \\|_{\\Sigma_M^{-1}}^2 \\right)$ 和 $\\Sigma_M = \\sigma_M^2 I$，我们有 $|\\Sigma_M|^{-1/2} = (\\sigma_M^{2N})^{-1/2} = \\sigma_M^{-N}$ 并且平方范数变为 $\\frac{1}{\\sigma_M^2}\\|y - G_M\\theta_M\\|_2^2$。\n$$\n\\log p(y \\mid \\theta_M, M) = -\\frac{N}{2} \\log(2\\pi) - N \\log(\\sigma_M) - \\frac{1}{2\\sigma_M^2} \\sum_{i=1}^{N} (y_i - [G_M\\theta_M]_i)^2\n$$\n\n**对数参数先验：** $\\log p(\\theta_M \\mid M)$\n- 声学模型（$M=\\text{a}$）：$\\theta_{\\text{a}} \\sim \\mathcal{N}(\\mu_{\\text{a}}, \\sigma_{\\text{pa}}^2)$。\n$$\n\\log p(\\theta_{\\text{a}} \\mid M=\\text{a}) = -\\frac{1}{2}\\log(2\\pi\\sigma_{\\text{pa}}^2) - \\frac{(\\theta_{\\text{a}} - \\mu_{\\text{a}})^2}{2\\sigma_{\\text{pa}}^2}\n$$\n- 弹性模型（$M=\\text{e}$）：$\\theta_{\\text{e}} \\sim \\mathcal{N}(\\mu_{\\text{e}}, \\sigma_{\\text{pe}}^2 I)$。$\\theta_{\\text{e}}$ 的两个分量是独立的。\n$$\n\\log p(\\theta_{\\text{e}} \\mid M=\\text{e}) = -\\log(2\\pi\\sigma_{\\text{pe}}^2) - \\frac{\\|\\theta_{\\text{e}} - \\mu_{\\text{e}}\\|_2^2}{2\\sigma_{\\text{pe}}^2}\n$$\n\n**对数模型先验：** $\\log p(M)$\n对于声学模型，这只是 $\\log(\\pi_{\\text{a}})$；对于弹性模型，是 $\\log(\\pi_{\\text{e}})$。\n\n**对数提议密度：** $\\log q(u)$\n提议为 $u \\sim \\mathcal{N}(0, \\sigma_u^2)$。\n$$\n\\log q(u) = -\\frac{1}{2}\\log(2\\pi\\sigma_u^2) - \\frac{u^2}{2\\sigma_u^2}\n$$\n\n### 3. 测试用例的实现\n\n所提供的程序将实现这些公式。对于每个测试用例，它将：\n1. 为当前模型（$M_c, \\theta_c$）和数据生成真值（用于创建向量 $y$）定义参数。\n2. 使用 Ricker 子波函数构建设计矩阵 $G_{\\text{a}}$ 和 $G_{\\text{e}}$。\n3. 生成观测数据向量 $y$。\n4. 确定移动类型（a $\\to$ e 或 e $\\to$ a）。\n5. 使用提供的映射计算目标模型的参数（$\\theta_t$）和任何隐含的辅助变量（$u'$）。\n6. 通过将对数似然、对数参数先验和对数模型先验相加，计算当前和目标状态的对数后验。\n7. 根据移动类型计算涉及雅可比行列式和提议密度的校正项。\n8. 将所有项相加得到 $\\log \\alpha$。\n9. 计算最终的接受概率 $A = \\min(1, \\exp(\\log \\alpha))$。\n\n此过程系统地应用于所有四个测试用例，并将结果汇总到最终输出中。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute acceptance probabilities for four RJMCMC test cases.\n    \"\"\"\n\n    def ricker_wavelet(t, f0):\n        \"\"\"Computes a Ricker wavelet.\"\"\"\n        t2 = t**2\n        f02 = f0**2\n        pi2 = np.pi**2\n        factor = pi2 * f02 * t2\n        return (1.0 - 2.0 * factor) * np.exp(-factor)\n\n    def log_likelihood(y, G, theta, sigma, N):\n        \"\"\"Computes the log of the Gaussian likelihood.\"\"\"\n        y_pred = G @ np.atleast_1d(theta)\n        residual = y - y_pred\n        # Normalization term contains model evidence part: (2pi)^(-N/2) |Sigma|^(-1/2)\n        # |Sigma| = (sigma^2)^N, so |Sigma|^(-1/2) = sigma^(-N)\n        log_norm = -0.5 * N * np.log(2 * np.pi) - N * np.log(sigma)\n        # Misfit term\n        log_exp = -0.5 * np.sum(residual**2) / (sigma**2)\n        return log_norm + log_exp\n\n    def log_param_prior(theta, mu, sigma_prior):\n        \"\"\"Computes the log of the Gaussian parameter prior.\"\"\"\n        theta = np.atleast_1d(theta)\n        mu = np.atleast_1d(mu)\n        dim = len(theta)\n        log_norm = -0.5 * dim * np.log(2 * np.pi * sigma_prior**2)\n        log_exp = -0.5 * np.sum((theta - mu)**2) / (sigma_prior**2)\n        return log_norm + log_exp\n\n    def log_q_u(u, sigma_u):\n        \"\"\"Computes the log of the proposal density for the auxiliary variable u.\"\"\"\n        log_norm = -0.5 * np.log(2 * np.pi * sigma_u**2)\n        log_exp = -0.5 * (u**2) / (sigma_u**2)\n        return log_norm + log_exp\n\n    def calculate_acceptance_prob(case_params):\n        \"\"\"Calculates the acceptance probability for a single test case.\"\"\"\n        \n        # Unpack global and case-specific parameters\n        move_type = case_params['move_type']\n        \n        # --- Shared parameters ---\n        N = 64\n        t = np.linspace(-0.05, 0.05, N)\n        mu_a, mu_e = 0.0, np.array([0.0, 0.0])\n        sigma_pa, sigma_pe = 2.0, 2.0\n        pi_a, pi_e = 0.4, 0.6\n        sigma_u = 0.5\n        J_a_to_e, J_e_to_a = 2.0, 0.5\n\n        # --- Wavelet and G-matrix construction ---\n        fa = case_params.get('fa')\n        fp = case_params.get('fp')\n        fs = case_params.get('fs')\n        \n        G_a = ricker_wavelet(t, fa)[:, np.newaxis]\n        if case_params.get('G_e_identical', False):\n            G_e = np.hstack([G_a, G_a])\n        else:\n            w_p = ricker_wavelet(t, fp)[:, np.newaxis]\n            w_s = ricker_wavelet(t, fs)[:, np.newaxis]\n            G_e = np.hstack([w_p, w_s])\n\n        # --- Generate observed data y ---\n        if case_params['y_source_model'] == 'acoustic':\n            y = G_a @ np.array([case_params['theta_true']])\n        else:\n            y = G_e @ np.array(case_params['theta_true'])\n        \n        # --- Calculate log alpha ---\n        if move_type == 'a_to_e':\n            # Current state (acoustic)\n            theta_c = case_params['theta_current']\n            log_like_c = log_likelihood(y, G_a, theta_c, case_params['sigma_a'], N)\n            log_prior_c = log_param_prior(theta_c, mu_a, sigma_pa)\n            log_model_prior_c = np.log(pi_a)\n            log_posterior_c = log_like_c + log_prior_c + log_model_prior_c\n            \n            # Target state (elastic)\n            u_fwd = case_params['u_proposed']\n            theta_t = np.array([theta_c + u_fwd, theta_c - u_fwd])\n            log_like_t = log_likelihood(y, G_e, theta_t, case_params['sigma_e'], N)\n            log_prior_t = log_param_prior(theta_t, mu_e, sigma_pe)\n            log_model_prior_t = np.log(pi_e)\n            log_posterior_t = log_like_t + log_prior_t + log_model_prior_t\n            \n            # Correction term\n            log_J = np.log(J_a_to_e)\n            log_q_fwd = log_q_u(u_fwd, sigma_u)\n            log_q_rev = 0  # No reverse auxiliary variable drawn\n\n            log_alpha = (log_posterior_t - log_posterior_c) + log_J + log_q_rev - log_q_fwd\n\n        elif move_type == 'e_to_a':\n            # Current state (elastic)\n            theta_c = np.array(case_params['theta_current'])\n            log_like_c = log_likelihood(y, G_e, theta_c, case_params['sigma_e'], N)\n            log_prior_c = log_param_prior(theta_c, mu_e, sigma_pe)\n            log_model_prior_c = np.log(pi_e)\n            log_posterior_c = log_like_c + log_prior_c + log_model_prior_c\n            \n            # Target state (acoustic)\n            theta_t = 0.5 * (theta_c[0] + theta_c[1])\n            u_rev_implied = 0.5 * (theta_c[0] - theta_c[1])\n            log_like_t = log_likelihood(y, G_a, theta_t, case_params['sigma_a'], N)\n            log_prior_t = log_param_prior(theta_t, mu_a, sigma_pa)\n            log_model_prior_t = np.log(pi_a)\n            log_posterior_t = log_like_t + log_prior_t + log_model_prior_t\n            \n            # Correction term\n            log_J = np.log(J_e_to_a)\n            log_q_fwd = 0  # No forward auxiliary variable drawn\n            log_q_rev = log_q_u(u_rev_implied, sigma_u)\n\n            log_alpha = (log_posterior_t - log_posterior_c) + log_J + log_q_rev - log_q_fwd\n\n        return min(1.0, np.exp(log_alpha))\n\n    test_cases = [\n        # Case 1\n        {\n            'move_type': 'a_to_e', 'fa': 40, 'fp': 30, 'fs': 60,\n            'y_source_model': 'acoustic', 'theta_true': 1.0,\n            'sigma_a': 0.1, 'sigma_e': 0.2,\n            'theta_current': 0.8, 'u_proposed': 0.1\n        },\n        # Case 2\n        {\n            'move_type': 'a_to_e', 'fa': 40, 'fp': 30, 'fs': 60,\n            'y_source_model': 'elastic', 'theta_true': [1.0, -0.2],\n            'sigma_a': 0.1, 'sigma_e': 0.2,\n            'theta_current': 1.4, 'u_proposed': -0.3\n        },\n        # Case 3\n        {\n            'move_type': 'e_to_a', 'fa': 40, 'fp': 30, 'fs': 60,\n            'y_source_model': 'acoustic', 'theta_true': 0.9,\n            'sigma_a': 0.1, 'sigma_e': 0.2,\n            'theta_current': [0.9, 0.9]\n        },\n        # Case 4\n        {\n            'move_type': 'a_to_e', 'fa': 40, 'fp': 40, 'fs': 40, 'G_e_identical': True,\n            'y_source_model': 'acoustic', 'theta_true': 0.7,\n            'sigma_a': 0.05, 'sigma_e': 1.0,\n            'theta_current': 0.7, 'u_proposed': 0.0\n        }\n    ]\n\n    results = [calculate_acceptance_prob(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}