{
    "hands_on_practices": [
        {
            "introduction": "连续小波变换（Continuous Wavelet Transform, CWT）是分析非平稳信号（如地震记录）的强大工具，能够同时提供时间和频率信息。为了正确解译小波谱图，理解其数学上的“尺度”参数与物理上的“频率”概念之间的联系至关重要。本练习  将指导你通过第一性原理，为广泛应用的 Morlet 小波推导这一基本映射关系，并解决在处理有限长度信号时由边界效应引起的关键问题——计算影响锥（cone of influence）。",
            "id": "3574571",
            "problem": "考虑一段持续时间为 $T$ 秒的有限长度地震时间序列。令 $\\psi(t)$ 为 Morlet 母小波，定义为\n$$\n\\psi(t) = \\pi^{-1/4} \\exp\\!\\big(i \\,\\omega_{0}\\, t\\big)\\,\\exp\\!\\left(-\\frac{t^{2}}{2}\\right),\n$$\n其中 $\\omega_{0}  0$ 是小波的中心角频率。尺度为 $a$ 的小波由下式给出\n$$\n\\psi_{a}(t) = \\frac{1}{\\sqrt{a}}\\,\\psi\\!\\left(\\frac{t}{a}\\right),\n$$\n信号 $x(t)$ 相对于 $\\psi(t)$ 在尺度 $a$ 和时间 $b$ 的连续小波变换 (CWT) 为\n$$\nW_{x}(a,b) = \\int_{-\\infty}^{\\infty} x(t)\\,\\frac{1}{\\sqrt{a}}\\,\\psi^{*}\\!\\left(\\frac{t-b}{a}\\right)\\,\\mathrm{d}t,\n$$\n其中 $\\psi^{*}$ 表示复共轭。假设在角频率 $\\omega$ 下使用标准傅里叶变换约定，使得时间尺度函数 $f(t/a)/\\sqrt{a}$ 的变换为 $\\sqrt{a}\\,F(a\\,\\omega)$，其中 $F(\\omega)$ 是 $f(t)$ 的傅里叶变换。\n\n从这些定义以及傅里叶变换的尺度变换和调制特性出发，推导小波尺度 $a$ 与 Morlet 小波谱响应峰值对应的物理频率 $f$（单位：周/秒）之间的映射关系。然后，利用 Morlet 小波的高斯包络，将影响锥定义为因小波的有限时间支撑，小波功率衰减至其最大值的 $\\exp(-2)$ 的轨迹，并计算对于持续时间为 $T$ 的记录，从每个边缘起的显式边界偏移 $t_{\\mathrm{COI}}(a)$。\n\n将您的最终答案表示为一个包含频率映射和影响锥边界偏移（作为 $a$ 和 $\\omega_{0}$ 的函数）的双元素行矩阵。频率以周/秒表示。不需要数值近似或四舍五入。",
            "solution": "该问题要求使用 Morlet 小波推导与连续小波变换 (CWT) 相关的两个量：小波尺度与物理频率之间的映射关系，以及影响锥的边界偏移。\n\n**第一部分：尺度-频率映射的推导**\n\n目标是找到小波尺度 $a$ 与尺度化小波 $\\psi_{a}(t)$ 的谱响应达到最大值时的物理频率 $f$（单位：周/秒）之间的关系。这需要求出 $\\psi_{a}(t)$ 的傅里叶变换。\n\n首先，我们求 Morlet 母小波 $\\psi(t)$ 的傅里叶变换，其表达式为：\n$$\n\\psi(t) = \\pi^{-1/4} \\exp(i\\omega_{0}t) \\exp\\left(-\\frac{t^{2}}{2}\\right)\n$$\n令 $\\Psi(\\omega)$ 表示 $\\psi(t)$ 的傅里叶变换。$\\psi(t)$ 的表达式是一个高斯函数和一个复指数的乘积。我们使用傅里叶变换的频移特性，即如果 $g(t)$ 的傅里叶变换是 $G(\\omega)$，那么 $g(t)\\exp(i\\omega_{0}t)$ 的傅里叶变换是 $G(\\omega - \\omega_{0})$。\n\n这里，令 $g(t) = \\pi^{-1/4} \\exp(-t^{2}/2)$。高斯函数 $\\exp(-\\alpha t^{2})$ 的标准傅里叶变换是 $\\sqrt{\\pi/\\alpha} \\exp(-\\omega^{2}/(4\\alpha))$。对于 $g(t)$，常数前置因子是 $\\pi^{-1/4}$，指数中的参数 $\\alpha$ 是 $1/2$。\n$\\exp(-t^{2}/2)$ 的傅里叶变换是：\n$$\n\\mathcal{F}\\left\\{\\exp\\left(-\\frac{t^{2}}{2}\\right)\\right\\} = \\sqrt{\\frac{\\pi}{1/2}} \\exp\\left(-\\frac{\\omega^{2}}{4(1/2)}\\right) = \\sqrt{2\\pi} \\exp\\left(-\\frac{\\omega^{2}}{2}\\right)\n$$\n因此，$g(t)$ 的傅里叶变换是：\n$$\nG(\\omega) = \\pi^{-1/4} \\left( \\sqrt{2\\pi} \\exp\\left(-\\frac{\\omega^{2}}{2}\\right) \\right) = 2^{1/2} \\pi^{1/4} \\exp\\left(-\\frac{\\omega^{2}}{2}\\right)\n$$\n应用频移特性，母小波 $\\psi(t)$ 的傅里叶变换是：\n$$\n\\Psi(\\omega) = G(\\omega - \\omega_{0}) = 2^{1/2} \\pi^{1/4} \\exp\\left(-\\frac{(\\omega - \\omega_{0})^{2}}{2}\\right)\n$$\n该谱响应的峰值出现在幅度 $|\\Psi(\\omega)|$ 最大处。这对应于指数中 $(\\omega - \\omega_{0})^{2}$ 项的最小值，该最小值在 $\\omega = \\omega_{0}$ 时出现。\n\n接下来，我们求尺度化小波 $\\psi_{a}(t) = \\frac{1}{\\sqrt{a}}\\psi(t/a)$ 的傅里叶变换。问题陈述中给出了傅里叶变换的尺度变换特性：$f(t/a)/\\sqrt{a}$ 的变换是 $\\sqrt{a}F(a\\omega)$。令 $\\Psi_{a}(\\omega)$ 为 $\\psi_{a}(t)$ 的傅里叶变换。应用此特性，我们得到：\n$$\n\\Psi_{a}(\\omega) = \\sqrt{a} \\Psi(a\\omega) = \\sqrt{a} \\left( 2^{1/2} \\pi^{1/4} \\exp\\left(-\\frac{(a\\omega - \\omega_{0})^{2}}{2}\\right) \\right)\n$$\n$$\n\\Psi_{a}(\\omega) = \\sqrt{2a} \\, \\pi^{1/4} \\exp\\left(-\\frac{(a\\omega - \\omega_{0})^{2}}{2}\\right)\n$$\n谱幅度 $|\\Psi_{a}(\\omega)|$ 的峰值出现在指数中的 $(a\\omega - \\omega_{0})^{2}$ 项最小时。这发生在 $a\\omega - \\omega_{0} = 0$ 时。令 $\\omega_{\\text{peak}}$ 表示对应于此峰值的角频率。\n$$\na\\omega_{\\text{peak}} = \\omega_{0} \\implies \\omega_{\\text{peak}} = \\frac{\\omega_{0}}{a}\n$$\n问题要求的是以周/秒 (Hz) 为单位的物理频率 $f$。角频率 $\\omega$（单位：弧度/秒）与物理频率 $f$ 之间的关系是 $\\omega = 2\\pi f$。因此，峰值物理频率 $f_{\\text{peak}}$ 为：\n$$\n2\\pi f_{\\text{peak}} = \\frac{\\omega_{0}}{a} \\implies f_{\\text{peak}} = \\frac{\\omega_{0}}{2\\pi a}\n$$\n这就是小波尺度 $a$ 与相应物理频率 $f$ 之间的映射关系。\n\n**第二部分：影响锥边界偏移的推导**\n\n影响锥 (COI) 表示时-尺度平面中，由信号有限持续时间引起的边缘效应变得显著的区域。问题将 COI 边界定义为小波功率衰减至其最大值的 $\\exp(-2)$ 的轨迹。这种衰减是由于小波的高斯包络。\n\n尺度化小波为：\n$$\n\\psi_{a}(t) = \\frac{1}{\\sqrt{a}}\\psi\\left(\\frac{t}{a}\\right) = \\frac{1}{\\sqrt{a}} \\pi^{-1/4} \\exp\\left(i\\omega_{0}\\frac{t}{a}\\right) \\exp\\left(-\\frac{(t/a)^{2}}{2}\\right) = \\frac{1}{\\sqrt{a}} \\pi^{-1/4} \\exp\\left(i\\frac{\\omega_{0}t}{a}\\right) \\exp\\left(-\\frac{t^{2}}{2a^{2}}\\right)\n$$\n在时间 $t$ 的小波功率与 $|\\psi_{a}(t)|^{2}$ 成正比。\n$$\n|\\psi_{a}(t)|^{2} = \\left|\\frac{1}{\\sqrt{a}} \\pi^{-1/4} \\exp\\left(i\\frac{\\omega_{0}t}{a}\\right) \\exp\\left(-\\frac{t^{2}}{2a^{2}}\\right)\\right|^{2}\n$$\n由于对于任意实数 $\\theta$，都有 $|\\exp(i\\theta)| = 1$，因此复指数项的幅度为 $1$。功率包络为：\n$$\n|\\psi_{a}(t)|^{2} = \\left(\\frac{1}{\\sqrt{a}} \\pi^{-1/4}\\right)^{2} \\left(\\exp\\left(-\\frac{t^{2}}{2a^{2}}\\right)\\right)^{2} = \\frac{1}{a\\sqrt{\\pi}} \\exp\\left(-\\frac{t^{2}}{a^{2}}\\right)\n$$\n功率是关于时间 $t$ 的高斯函数，中心在 $t=0$。最大功率出现在 $t=0$ 时：\n$$\n|\\psi_{a}(0)|^{2} = \\frac{1}{a\\sqrt{\\pi}}\n$$\n根据问题的定义，COI 边界偏移（我们记为 $t_{\\mathrm{COI}}(a)$）是小波功率下降到其最大值的 $\\exp(-2)$ 倍时的时间。我们建立方程：\n$$\n|\\psi_{a}(t_{\\mathrm{COI}}(a))|^{2} = |\\psi_{a}(0)|^{2} \\times \\exp(-2)\n$$\n代入功率的表达式：\n$$\n\\frac{1}{a\\sqrt{\\pi}} \\exp\\left(-\\frac{t_{\\mathrm{COI}}(a)^{2}}{a^{2}}\\right) = \\frac{1}{a\\sqrt{\\pi}} \\exp(-2)\n$$\n为使此等式成立，指数必须相等：\n$$\n-\\frac{t_{\\mathrm{COI}}(a)^{2}}{a^{2}} = -2\n$$\n求解 $t_{\\mathrm{COI}}(a)$：\n$$\nt_{\\mathrm{COI}}(a)^{2} = 2a^{2}\n$$\n由于偏移必须是代表时间持续长度的正值，我们取正根：\n$$\nt_{\\mathrm{COI}}(a) = \\sqrt{2}a\n$$\n这个时间 $t_{\\mathrm{COI}}(a)$ 是尺度 $a$ 处小波功率的 e-折叠时间。它定义了从时间序列的每个边缘（在 $t=0$ 和 $t=T$ 处）向内测量的区域宽度，在该区域内小波分析会受到边界伪影的影响。因此，从每个边缘起的显式边界偏移为 $\\sqrt{2}a$。\n\n**最终答案的构建**\n\n所要求的两个量是频率映射 $f(a)$ 和影响锥边界偏移 $t_{\\mathrm{COI}}(a)$。\n1.  频率映射：$f = \\frac{\\omega_{0}}{2\\pi a}$\n2.  COI 边界偏移：$t_{\\mathrm{COI}}(a) = \\sqrt{2}a$\n\n这些将以一个双元素行矩阵的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\omega_{0}}{2\\pi a}  \\sqrt{2}a\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在频谱分析中，获得一个谱估计本身只是第一步，准确量化其不确定性同等重要。多窗谱方法（Multitaper spectral estimation）是一种有效降低谱估计方差的先进技术，但其理论方差的计算通常依赖于背景噪声为高斯白噪声等较强的假设。本练习  将引导你通过一个计算实验，对比依赖于模型假设的解析方差估计与一种更为稳健的、由数据驱动的刀切法（Jackknife）方差估计，从而深刻理解当理论假设与实际情况不符时（例如存在有色噪声），非参数重采样方法在不确定性量化中的实践优势。",
            "id": "3574609",
            "problem": "请考虑使用带有离散扁球波函数 (DPSS) 的多窗谱方法，来估计嵌入噪声中的单个复窄带谱线分量。设离散时间复信号建模为 $x_n = A \\exp(i \\omega_0 n) + \\varepsilon_n$，其中 $n = 0, 1, \\dots, N-1$，$A \\in \\mathbb{C}$ 是谱线的复振幅，$\\omega_0$ 是真实的角频率，单位为弧度/样本，而 $\\varepsilon_n$ 是一个零均值复噪声过程。时间半带宽参数为 $NW$，并应用 $K$ 个正交归一的DPSS锥形窗 $w_k[n]$（$k = 1, \\dots, K$）。在谱线频率处解调后的加窗测量值为 $y_k = \\sum_{n=0}^{N-1} w_k[n] x_n \\exp(-i \\omega_0 n)$，相干增益为 $c_k = \\sum_{n=0}^{N-1} w_k[n]$。\n\n仅从基本定义以及关于加性噪声下的线性估计和基于重采样的不确定性量化的成熟理论出发，完成以下任务：\n\n1.  假设各锥形窗之间存在独立的加性噪声，使用 $K$ 个解调后的加窗测量值 $y_k$ 和相干增益 $c_k$ 推导复振幅 $A$ 的一个有原则的估计量 $\\hat{A}$。然后，在 $\\varepsilon_n$ 是独立同分布的复圆高斯白噪声且每样本二阶矩为 $\\mathbb{E}[|\\varepsilon_n|^2] = \\sigma^2$ 的假设下，推导 $\\hat{A}$ 方差的解析表达式，用 $\\sigma^2$ 和 $\\{c_k\\}$ 表示。\n\n2.  基于通过依次排除每个锥形窗获得的 $K$ 个留一法估计量，为 $\\hat{A}$ 构建一个刀切法方差估计量。将复振幅视为两个实数参数（实部和虚部），并将它们的刀切法方差相加，组合成复数估计量的单个标量方差。\n\n3.  实现一个蒙特卡洛实验，以评估解析方差和刀切法方差对于窄带峰的可靠性。对于下述每个测试用例，合成 $M$ 个独立的数据实现，为每个实现计算多窗谱最小二乘振幅估计量 $\\hat{A}$，从每个实现中计算刀切法方差，并估计 $\\hat{A}$ 在所有实现中的经验方差。将平均刀切法方差与经验方差进行比较，并将解析方差与经验方差进行比较。如果刀切法方差相对于经验方差的平均绝对相对误差（以小数表示）严格小于解析方差的绝对相对误差，则定义刀切法不确定性为“更可靠”。\n\n使用以下适定测试用例：\n-   用例1（通用，理想路径）：$N = 512$，$NW = 4$，$K = 7$，$\\omega_0 = 0.3\\pi$ (弧度)，$A = 0.8 + 0i$，白噪声，$\\sigma^2 = 0.2$。\n-   用例2（少量锥形窗，边界情况）：$N = 512$，$NW = 2$，$K = 3$，$\\omega_0 = 0.3\\pi$ (弧度)，$A = 0.8 + 0i$，白噪声，$\\sigma^2 = 0.2$。\n-   用例3（有色噪声，窄带峰）：$N = 512$，$NW = 4$，$K = 7$，$\\omega_0 = 0.3\\pi$ (弧度)，$A = 0.8 + 0i$，参数 $\\phi = 0.9$ 的1阶自回归（AR(1)）噪声，平稳的每样本二阶矩 $\\sigma^2 = 0.2$。\n-   用例4（边界情况，极少量锥形窗和强有色性）：$N = 512$，$NW = 1.5$，$K = 2$，$\\omega_0 = 0.3\\pi$ (弧度)，$A = 0.8 + 0i$，参数 $\\phi = 0.95$ 的AR(1)噪声，平稳的每样本二阶矩 $\\sigma^2 = 0.2$。\n\n在AR(1)用例中，复噪声为 $\\varepsilon_n = \\phi \\varepsilon_{n-1} + \\eta_n$，其中 $\\eta_n$ 是独立的复圆高斯新息，其选择应使平稳的每样本二阶矩满足 $\\mathbb{E}[|\\varepsilon_n|^2] = \\sigma^2$。所有角频率都必须以弧度为单位处理。在此纯数学设定中，振幅和方差是无量纲的。\n\n所需的实现细节：\n-   每个测试用例使用 $M = 200$ 次蒙特卡洛实现。\n-   DPSS锥形窗必须归一化为单位 $\\ell_2$ 范数，即对于每个 $k$，$\\sum_{n=0}^{N-1} |w_k[n]|^2 = 1$。\n-   估计量 $\\hat{A}$ 必须是基于由 $\\{y_k\\}$ 和 $\\{c_k\\}$ 定义的线性模型下的线性最小二乘估计量。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的四个布尔值列表，顺序与上述四个用例一致。每个布尔值表示在该用例中，刀切法方差是否比解析方差更可靠（即，刀切法的平均相对误差是否严格小于解析方差的相对误差）。例如，一个有效的输出形如“[True,False,True,False]”。",
            "solution": "该问题要求推导和比较通过多窗谱方法估计的窄带信号分量复振幅的两种方差估计量。第一个估计量是解析的，在白噪声假设下推导得出；而第二个是非参数的刀切法重采样估计量。它们的可靠性将通过在不同噪声条件下的蒙特卡洛模拟进行评估。\n\n解决方案分三部分进行：第一，最小二乘振幅估计量及其解析方差的推导；第二，刀切法方差估计量的构建；第三，用于比较二者的数值实验的设计。\n\n**第1部分：振幅估计量及其解析方差的推导**\n\n离散时间信号模型由 $x_n = A \\exp(i \\omega_0 n) + \\varepsilon_n$ 给出，其中 $n = 0, 1, \\dots, N-1$。这里，$A \\in \\mathbb{C}$ 是未知的复振幅，$\\omega_0$ 是已知的角频率，而 $\\varepsilon_n$ 是一个复噪声过程。\n\n$K$ 个解调后的加窗测量值定义为 $y_k = \\sum_{n=0}^{N-1} w_k[n] x_n \\exp(-i \\omega_0 n)$，其中 $k=1, \\dots, K$。将信号模型代入此定义可得：\n$$\ny_k = \\sum_{n=0}^{N-1} w_k[n] (A e^{i \\omega_0 n} + \\varepsilon_n) e^{-i \\omega_0 n} = A \\sum_{n=0}^{N-1} w_k[n] + \\sum_{n=0}^{N-1} w_k[n] \\varepsilon_n e^{-i \\omega_0 n}\n$$\n这可以写成一个线性模型。令 $c_k = \\sum_{n=0}^{N-1} w_k[n]$ 为第 $k$ 个锥形窗的相干增益，$\\nu_k = \\sum_{n=0}^{N-1} w_k[n] \\varepsilon_n e^{-i \\omega_0 n}$ 为对应的噪声项。这 $K$ 个测量值的模型变为：\n$$\ny_k = A c_k + \\nu_k, \\quad k = 1, \\dots, K\n$$\n我们寻求复参数 $A$ 的线性最小二乘估计量 $\\hat{A}$，它能最小化残差平方和 $J(A) = \\sum_{k=1}^K |y_k - A c_k|^2$。注意，锥形窗 $w_k[n]$ 是实数，因此它们的和 $c_k$ 也是实数。\n为求最小值，我们可以使用复变函数微积分，将关于复共轭 $A^*$ 的导数设为零：\n$$\n\\frac{\\partial J(A)}{\\partial A^*} = \\frac{\\partial}{\\partial A^*} \\sum_{k=1}^K (y_k - A c_k)(y_k^* - A^* c_k) = \\sum_{k=1}^K (y_k - A c_k)(-c_k) = 0\n$$\n$$\n- \\sum_{k=1}^K y_k c_k + A \\sum_{k=1}^K c_k^2 = 0\n$$\n对 $A$ 求解，得到最小二乘估计量 $\\hat{A}$：\n$$\n\\hat{A} = \\frac{\\sum_{k=1}^K y_k c_k}{\\sum_{k=1}^K c_k^2}\n$$\n接下来，我们推导该估计量的方差，$\\mathrm{Var}(\\hat{A}) = \\mathbb{E}[|\\hat{A} - \\mathbb{E}[\\hat{A}]|^2]$。首先，我们求 $\\hat{A}$ 的期望值。由于 $\\mathbb{E}[\\varepsilon_n] = 0$，因此 $\\mathbb{E}[\\nu_k] = 0$。\n$$\n\\mathbb{E}[\\hat{A}] = \\frac{\\sum_{k=1}^K \\mathbb{E}[y_k] c_k}{\\sum_{j=1}^K c_j^2} = \\frac{\\sum_{k=1}^K (A c_k + \\mathbb{E}[\\nu_k]) c_k}{\\sum_{j=1}^K c_j^2} = \\frac{A \\sum_{k=1}^K c_k^2}{\\sum_{j=1}^K c_j^2} = A\n$$\n该估计量是无偏的。因此，方差为 $\\mathrm{Var}(\\hat{A}) = \\mathbb{E}[|\\hat{A} - A|^2]$。\n$$\n\\hat{A} - A = \\frac{\\sum_{k=1}^K (A c_k + \\nu_k) c_k}{\\sum_{j=1}^K c_j^2} - A = \\frac{\\sum_{k=1}^K \\nu_k c_k}{\\sum_{j=1}^K c_j^2}\n$$\n$$\n\\mathrm{Var}(\\hat{A}) = \\mathbb{E}\\left[ \\left| \\frac{\\sum_k \\nu_k c_k}{\\sum_j c_j^2} \\right|^2 \\right] = \\frac{1}{\\left(\\sum_j c_j^2\\right)^2} \\mathbb{E}\\left[ \\left(\\sum_k \\nu_k c_k\\right) \\left(\\sum_l \\nu_l^* c_l\\right) \\right] = \\frac{1}{\\left(\\sum_j c_j^2\\right)^2} \\sum_{k,l} c_k c_l \\mathbb{E}[\\nu_k \\nu_l^*]\n$$\n为计算 $\\mathbb{E}[\\nu_k \\nu_l^*]$，我们使用这部分的模型假设：$\\varepsilon_n$ 是独立同分布的复圆高斯白噪声，且 $\\mathbb{E}[|\\varepsilon_n|^2] = \\sigma^2$。这意味着 $\\mathbb{E}[\\varepsilon_n \\varepsilon_m^*] = \\sigma^2 \\delta_{nm}$。\n$$\n\\mathbb{E}[\\nu_k \\nu_l^*] = \\mathbb{E}\\left[ \\left(\\sum_n w_k[n] \\varepsilon_n e^{-i \\omega_0 n}\\right) \\left(\\sum_m w_l[m] \\varepsilon_m^* e^{i \\omega_0 m}\\right) \\right] = \\sum_{n,m} w_k[n] w_l[m] e^{-i \\omega_0 (n-m)} \\mathbb{E}[\\varepsilon_n \\varepsilon_m^*]\n$$\n$$\n\\mathbb{E}[\\nu_k \\nu_l^*] = \\sum_{n,m} w_k[n] w_l[m] e^{-i \\omega_0 (n-m)} \\sigma^2 \\delta_{nm} = \\sigma^2 \\sum_n w_k[n] w_l[n]\n$$\n问题指出DPSS锥形窗 $w_k[n]$ 是正交归一的，对于实值锥形窗，这意味着 $\\sum_n w_k[n] w_l[n] = \\delta_{kl}$。因此，$\\mathbb{E}[\\nu_k \\nu_l^*] = \\sigma^2 \\delta_{kl}$。噪声项 $\\nu_k$ 是不相关的。将此代回方差表达式：\n$$\n\\mathrm{Var}(\\hat{A}) = \\frac{1}{\\left(\\sum_j c_j^2\\right)^2} \\sum_{k,l} c_k c_l (\\sigma^2 \\delta_{kl}) = \\frac{\\sigma^2}{\\left(\\sum_j c_j^2\\right)^2} \\sum_k c_k^2 = \\frac{\\sigma^2}{\\sum_{k=1}^K c_k^2}\n$$\n这便是在白噪声假设下 $\\hat{A}$ 的方差的解析表达式。\n\n**第2部分：刀切法方差估计量的构建**\n\n刀切法是一种用于估计统计量方差的重采样技术。它涉及系统地每次剔除一个观测值后重新计算该统计量。设 $\\hat{A}$ 为完整估计值。通过省略第 $j$ 个测量对 $(y_j, c_j)$ 来计算留一法估计量 $\\hat{A}_{(j)}$：\n$$\n\\hat{A}_{(j)} = \\frac{\\sum_{k \\neq j} y_k c_k}{\\sum_{k \\neq j} c_k^2}, \\quad j = 1, \\dots, K\n$$\n问题指定将复振幅 $\\hat{A} = \\hat{A}_R + i \\hat{A}_I$ 视为两个实数参数，并将其各自的刀切法方差求和。基于 $K$ 个样本的实值估计量 $\\hat{\\theta}$ 的刀切法方差为 $\\mathrm{Var}_{\\text{jack}}(\\hat{\\theta}) = \\frac{K-1}{K} \\sum_{j=1}^K (\\hat{\\theta}_{(j)} - \\bar{\\theta}_{(\\cdot)})^2$，其中 $\\bar{\\theta}_{(\\cdot)} = \\frac{1}{K}\\sum_j \\hat{\\theta}_{(j)}$。\n将此应用于 $\\hat{A}$ 的实部和虚部：\n$$\n\\mathrm{Var}_{\\text{jack}}(\\hat{A}_R) = \\frac{K-1}{K} \\sum_{j=1}^K (\\mathrm{Re}(\\hat{A}_{(j)}) - \\mathrm{Re}(\\bar{A}_{(\\cdot)}))^2\n$$\n$$\n\\mathrm{Var}_{\\text{jack}}(\\hat{A}_I) = \\frac{K-1}{K} \\sum_{j=1}^K (\\mathrm{Im}(\\hat{A}_{(j)}) - \\mathrm{Im}(\\bar{A}_{(\\cdot)}))^2\n$$\n其中 $\\bar{A}_{(\\cdot)} = \\frac{1}{K} \\sum_{j=1}^K \\hat{A}_{(j)}$。总的刀切法方差是其和：\n$$\n\\mathrm{Var}_{\\text{jack}}(\\hat{A}) = \\mathrm{Var}_{\\text{jack}}(\\hat{A}_R) + \\mathrm{Var}_{\\text{jack}}(\\hat{A}_I)\n$$\n$$\n\\mathrm{Var}_{\\text{jack}}(\\hat{A}) = \\frac{K-1}{K} \\sum_{j=1}^K \\left[ (\\mathrm{Re}(\\hat{A}_{(j)}) - \\mathrm{Re}(\\bar{A}_{(\\cdot)}))^2 + (\\mathrm{Im}(\\hat{A}_{(j)}) - \\mathrm{Im}(\\bar{A}_{(\\cdot)}))^2 \\right]\n$$\n该表达式可简化为：\n$$\n\\mathrm{Var}_{\\text{jack}}(\\hat{A}) = \\frac{K-1}{K} \\sum_{j=1}^K |\\hat{A}_{(j)} - \\bar{A}_{(\\cdot)}|^2\n$$\n该公式提供了从单次数据实现中对 $\\hat{A}$ 方差的非参数估计。与解析方差不同，其推导不假设噪声分量 $\\nu_k$ 不相关，这使得当底层噪声 $\\varepsilon_n$ 为有色噪声时，它可能更具鲁棒性。\n\n**第3部分：蒙特卡洛实验设计**\n\n为评估两种方差估计量的可靠性，我们对四个测试用例中的每一个都执行蒙特卡洛模拟。单个测试用例的步骤如下：\n\n1.  **设置**：参数 $N, NW, K, \\omega_0, A, \\sigma^2,$ 和噪声类型（白噪声或带参数 $\\phi$ 的AR(1)噪声）是固定的。$K$ 个DPSS锥形窗 $w_k[n]$ 生成一次，并计算它们的相干增益 $c_k$。计算解析方差 $\\mathrm{Var}_{\\text{an}} = \\sigma^2 / \\sum c_k^2$。该解析公式理论上仅对白噪声情况有效。对于有色噪声情况，它基于一个被违背的假设，预计会不准确。\n\n2.  **模拟循环**：生成 $M=200$ 个独立实现。对于每个实现 $m=1, \\dots, M$：\n    a.  合成一个长度为 $N$ 的噪声序列 $\\varepsilon_n$。\n        -   **白噪声**：通过从正态分布 $\\mathcal{N}(0, \\sigma^2/2)$ 生成独立的实部和虚部来产生复圆高斯噪声。\n        -   **AR(1)噪声**：过程为 $\\varepsilon_n = \\phi \\varepsilon_{n-1} + \\eta_n$。为达到 $\\mathbb{E}[|\\varepsilon_n|^2] = \\sigma^2$ 的平稳方差，复圆白噪声新息 $\\eta_n$ 必须具有方差 $\\mathbb{E}[|\\eta_n|^2] = \\sigma^2 (1-|\\phi|^2)$。序列 $\\varepsilon_n$ 是通过用分母多项式 $1 - \\phi z^{-1}$ 定义的递归滤波器对新息 $\\eta_n$ 进行滤波而生成的。\n    b.  形成完整信号 $x_n = A e^{i \\omega_0 n} + \\varepsilon_n$。\n    c.  计算 $K$ 个测量值 $y_k$，并根据这些值，使用上面推导的公式计算出完整振幅估计 $\\hat{A}^{(m)}$ 和单次实现的刀切法方差估计 $\\mathrm{Var}_{\\text{jack}}^{(m)}$。\n\n3.  **分析**：循环结束后，我们得到 $M$ 个估计值 $\\{\\hat{A}^{(m)}\\}$ 和 $M$ 个刀切法方差 $\\{\\mathrm{Var}_{\\text{jack}}^{(m)}\\}$ 的集合。\n    a.  从估计样本中计算 $\\hat{A}$ 的**经验方差**。这作为我们方差的“真实值”：$\\mathrm{Var}_{\\text{emp}} = \\frac{1}{M-1} \\sum_{m=1}^M |\\hat{A}^{(m)} - \\bar{A}|^2$，其中 $\\bar{A} = \\frac{1}{M} \\sum_m \\hat{A}^{(m)}$。\n    b.  计算**平均刀切法方差**：$\\overline{\\mathrm{Var}}_{\\text{jack}} = \\frac{1}{M} \\sum_{m=1}^M \\mathrm{Var}_{\\text{jack}}^{(m)}$。\n    c.  使用相对于经验方差的绝对相对误差来比较可靠性：\n        $$\n        E_{\\text{an}} = \\left| \\frac{\\mathrm{Var}_{\\text{an}} - \\mathrm{Var}_{\\text{emp}}}{\\mathrm{Var}_{\\text{emp}}} \\right|, \\quad E_{\\text{jack}} = \\left| \\frac{\\overline{\\mathrm{Var}}_{\\text{jack}} - \\mathrm{Var}_{\\text{emp}}}{\\mathrm{Var}_{\\text{emp}}} \\right|\n        $$\n    d.  如果 $E_{\\text{jack}}  E_{\\text{an}}$，则认为刀切法在给定测试用例中“更可靠”。记录布尔结果。\n\n对所有四个用例重复此过程，最终输出是一个包含四个布尔值的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal.windows import dpss\nfrom scipy.signal import lfilter\n\ndef run_monte_carlo(N, NW, K, omega0, A_true, sigma_sq, phi, M):\n    \"\"\"\n    Performs a Monte Carlo simulation for one test case.\n\n    Returns:\n        bool: True if the jackknife variance is more reliable than the analytical variance.\n    \"\"\"\n    # 1. Generate DPSS tapers and coherent gains\n    # The dpss function returns int(2*NW) tapers. We select the first K.\n    tapers = dpss(N, NW, K)\n    \n    # Coherent gains (c_k)\n    c = np.sum(tapers, axis=1)\n\n    # 2. Calculate analytical variance (based on white noise assumption)\n    var_analytical = sigma_sq / np.sum(c**2)\n\n    # 3. Monte Carlo loop\n    estimates_A_hat = np.zeros(M, dtype=np.complex128)\n    variances_jack = np.zeros(M)\n    \n    n_indices = np.arange(N)\n    signal_component = A_true * np.exp(1j * omega0 * n_indices)\n\n    # Set up random number generator for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    for m in range(M):\n        # a. Generate noise\n        if phi == 0:  # White noise case\n            noise_real = rng.normal(scale=np.sqrt(sigma_sq / 2), size=N)\n            noise_imag = rng.normal(scale=np.sqrt(sigma_sq / 2), size=N)\n            noise = noise_real + 1j * noise_imag\n        else:  # AR(1) colored noise case\n            var_eta = sigma_sq * (1 - phi**2)\n            eta_real = rng.normal(scale=np.sqrt(var_eta / 2), size=N)\n            eta_imag = rng.normal(scale=np.sqrt(var_eta / 2), size=N)\n            eta = eta_real + 1j * eta_imag\n            # Generate AR(1) process using a filter\n            # The filter implements eps[n] = phi * eps[n-1] + eta[n]\n            # with initial condition eps[-1] = 0\n            noise = lfilter([1], [1, -phi], eta)\n        \n        # b. Synthesize signal\n        x = signal_component + noise\n\n        # c. Compute demodulated measurements y_k\n        y_k = np.zeros(K, dtype=np.complex128)\n        demodulator = np.exp(-1j * omega0 * n_indices)\n        for k in range(K):\n            y_k[k] = np.sum(tapers[k, :] * x * demodulator)\n\n        # d. Compute full estimate A_hat\n        A_hat_m = np.sum(y_k * c) / np.sum(c**2)\n        estimates_A_hat[m] = A_hat_m\n\n        # e. Compute jackknife variance for this realization\n        A_hat_leave_one_out = np.zeros(K, dtype=np.complex128)\n        k_indices = np.arange(K)\n        for j in range(K):\n            # Indices for leave-one-out subset\n            subset_idx = k_indices != j\n            y_subset = y_k[subset_idx]\n            c_subset = c[subset_idx]\n            A_hat_leave_one_out[j] = np.sum(y_subset * c_subset) / np.sum(c_subset**2)\n        \n        A_hat_loo_mean = np.mean(A_hat_leave_one_out)\n        var_jack_m = (K - 1) / K * np.sum(np.abs(A_hat_leave_one_out - A_hat_loo_mean)**2)\n        variances_jack[m] = var_jack_m\n\n    # 4. Post-processing\n    # Empirical variance (sample variance with ddof=1)\n    var_empirical = np.var(estimates_A_hat, ddof=1)\n\n    # Average jackknife variance\n    avg_var_jack = np.mean(variances_jack)\n\n    # 5. Compare errors\n    err_analytical = np.abs((var_analytical - var_empirical) / var_empirical)\n    err_jackknife = np.abs((avg_var_jack - var_empirical) / var_empirical)\n\n    return err_jackknife  err_analytical\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: white noise, general\n        {'N': 512, 'NW': 4, 'K': 7, 'omega0': 0.3 * np.pi, 'A_true': 0.8 + 0j, 'sigma_sq': 0.2, 'phi': 0.0},\n        # Case 2: white noise, few tapers\n        {'N': 512, 'NW': 2, 'K': 3, 'omega0': 0.3 * np.pi, 'A_true': 0.8 + 0j, 'sigma_sq': 0.2, 'phi': 0.0},\n        # Case 3: colored noise, general\n        {'N': 512, 'NW': 4, 'K': 7, 'omega0': 0.3 * np.pi, 'A_true': 0.8 + 0j, 'sigma_sq': 0.2, 'phi': 0.9},\n        # Case 4: colored noise, few tapers, strong color\n        {'N': 512, 'NW': 1.5, 'K': 2, 'omega0': 0.3 * np.pi, 'A_true': 0.8 + 0j, 'sigma_sq': 0.2, 'phi': 0.95},\n    ]\n\n    M = 200  # Number of Monte Carlo realizations\n\n    results = []\n    for case in test_cases:\n        is_jackknife_more_reliable = run_monte_carlo(\n            N=case['N'],\n            NW=case['NW'],\n            K=case['K'],\n            omega0=case['omega0'],\n            A_true=case['A_true'],\n            sigma_sq=case['sigma_sq'],\n            phi=case['phi'],\n            M=M\n        )\n        results.append(is_jackknife_more_reliable)\n\n    # Final print statement in the exact required format.\n    # The output format must be a string like \"[True,False,True,False]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将频谱分析从时域扩展到空间域是地球物理勘探的基石，传感器阵列为此提供了有力的工具。Capon 方法（又称最小方差无畸变响应方法，MVDR）作为一种高分辨率谱估计算法，相比传统波束形成能提供更精细的空间波数分辨能力。然而，在存在相干多路径传播（如层状介质中的反射波）的复杂波场中，其性能会严重下降，本练习  将指导你进行严格的理论推导，以量化 Capon 估计器在此种情况下的偏差，帮助你深入理解这些先进算法在实际应用中的局限性。",
            "id": "3574574",
            "problem": "考虑一个一维均匀线性阵列，它在分层（层状）介质中观测一个窄带地震平面波，该介质引起一次相干多径返回。在固定时间频率 $f$ 下，采用窄带阵列数据模型：\n- 阵列快照向量为 $x(t) \\in \\mathbb{C}^{M}$，其中 $M$ 是传感器数量。\n- 直达波导向矢量为 $a(k_d,f) \\in \\mathbb{C}^{M}$，由水平波数 $k_d$（单位：弧度/米）参数化。\n- 相干反射波导向矢量为 $a(k_r,f) \\in \\mathbb{C}^{M}$，其水平波数为 $k_r$（单位：弧度/米）。\n- 源信号为 $s(t) \\in \\mathbb{C}$，均值为零，方差为 $\\mathbb{E}[|s(t)|^2] = P_s$，其中 $P_s$ 是源功率（无量纲）。\n- 相干反射系数为 $r \\in \\mathbb{C}$，其中 $|r|$ 是反射率幅值，$\\arg(r)$ 是以弧度为单位的相位。\n- 加性噪声为 $n(t) \\sim \\mathcal{CN}(0,\\sigma^2 I_M)$，其中 $\\sigma^2$ 是噪声功率（无量纲），$I_M$ 是 $M \\times M$ 单位矩阵。\n\n在这些假设下，接收到的阵列快照模型为\n$$\nx(t) \\;=\\; s(t)\\,a(k_d,f) \\;+\\; s(t)\\,r\\,a(k_r,f) \\;+\\; n(t).\n$$\n定义系综协方差\n$$\nR(f) \\;=\\; \\mathbb{E}\\{x(t)\\,x(t)^{\\mathrm{H}}\\} \\;=\\; \\sigma^2 I_M \\;+\\; P_s\\,u(f)\\,u(f)^{\\mathrm{H}},\n$$\n其中\n$$\nu(f) \\;=\\; a(k_d,f) \\;+\\; r\\,a(k_r,f).\n$$\n在观测波数 $k$ 处的 Capon（最小方差无畸变响应，MVDR）空间谱定义为\n$$\n\\hat S_{\\mathrm{Capon}}(k,f) \\;=\\; \\frac{1}{a(k,f)^{\\mathrm{H}}\\,R(f)^{-1}\\,a(k,f)}.\n$$\n对于已知的白噪声水平 $\\sigma^2$ 和未归一化的导向矢量，在 $k_d$ 处的标准噪声校正功率估计为\n$$\n\\hat S(k_d,f) \\;=\\; \\hat S_{\\mathrm{Capon}}(k_d,f) \\;-\\; \\frac{\\sigma^2}{\\|a(k_d,f)\\|_2^2}.\n$$\n设直达波处的目标空间谱密度定义为\n$$\nS(k_d,f) \\;=\\; P_s.\n$$\n你的任务：\n- 从上述定义和窄带阵列数据模型出发，推导偏差的显式闭式表达式\n$$\nB(k_d,f) \\;=\\; \\mathbb{E}[\\hat S(k_d,f)] \\;-\\; S(k_d,f),\n$$\n该表达式应是反射率 $r$、由 $a(k_d,f)$ 和 $a(k_r,f)$ 编码的阵列几何形状、源功率 $P_s$ 和噪声功率 $\\sigma^2$ 的函数。最终答案只使用导向矢量的内积和范数以及参数 $P_s$、$\\sigma^2$ 和 $r$ 来表示。\n- 然后，实现一个程序，计算均匀线性阵列（ULA）的此偏差。该阵列的传感器间距为 $d$（单位：米），传感器位置为 $p_m = m d$（对于 $m \\in \\{0,1,\\ldots,M-1\\}$），导向矢量为\n$$\na(k,f) \\;=\\; \\begin{bmatrix}\ne^{j k p_0}  e^{j k p_1}  \\cdots  e^{j k p_{M-1}}\n\\end{bmatrix}^{\\mathrm{T}}.\n$$\n使用弧度表示角度，使用弧度/米表示波数。程序必须计算您推导的理论系综偏差 $B(k_d,f)$，而不是通过模拟快照。\n\n测试套件和参数集：\n- 使用以下四种情况。所有角度单位为弧度，所有距离单位为米，所有波数单位为弧度/米。答案无量纲。\n    1) 情况 1：$M = 8$，$d = 10$，$k_d = 0.12$，$k_r = 0.12$，$|r| = 0$，$\\arg(r) = 0$，$P_s = 1.0$，$\\sigma^2 = 0.1$。\n    2) 情况 2：$M = 8$，$d = 10$，$k_d = 0.12$，$k_r = 0.12$，$|r| = 0.5$，$\\arg(r) = \\pi/4$，$P_s = 1.0$，$\\sigma^2 = 0.1$。\n    3) 情况 3：$M = 12$，$d = 8$，$k_d = 0.15$，$k_r = 0.21$，$|r| = 0.3$，$\\arg(r) = 0$，$P_s = 1.0$，$\\sigma^2 = 0.05$。\n    4) 情况 4：$M = 10$，$d = 9$，$k_d = 0.09$，$k_r = k_d + \\frac{2\\pi}{M d}$，$|r| = 0.8$，$\\arg(r) = \\pi/2$，$P_s = 0.7$，$\\sigma^2 = 0.2$。\n\n程序要求：\n- 如上所述，为 ULA 实现推导出的闭式偏差函数。\n- 生成单行输出，其中包含一个列表，内含四个浮点数，按顺序对应情况 1 到 4 的偏差 $B(k_d,f)$。\n- 格式：一行，形式严格为“[x1,x2,x3,x4]”，其中每个 $x_i$ 是一个四舍五入到 6 位小数的实数。\n\n注意：\n- 确保您的实现使用您推导的系综表达式，而不是样本协方差估计。\n- 明确所有角度单位为弧度，所有波数单位为弧度/米。",
            "solution": "目标是推导噪声校正 Capon 功率估计器偏差 $B(k_d,f)$ 的闭式表达式。偏差定义为\n$$\nB(k_d,f) \\;=\\; \\mathbb{E}[\\hat S(k_d,f)] \\;-\\; S(k_d,f)\n$$\n该问题是使用系综协方差矩阵 $R(f)$ 来表述的，该矩阵是确定性的。因此，估计量 $\\hat S(k_d,f)$ 也是一个确定性量，而不是随机变量。在这种情况下，期望算子是多余的，我们有 $\\mathbb{E}[\\hat S(k_d,f)] = \\hat S(k_d,f)$。因此，问题简化为计算估计器输出与目标功率之间的差值：\n$$\nB(k_d,f) \\;=\\; \\hat S(k_d,f) \\;-\\; S(k_d,f)\n$$\n已知条件如下：\n- 目标功率：$S(k_d,f) = P_s$。\n- 噪声校正功率估计：$\\hat S(k_d,f) = \\hat S_{\\mathrm{Capon}}(k_d,f) - \\frac{\\sigma^2}{\\|a(k_d,f)\\|_2^2}$。\n- Capon 谱：$\\hat S_{\\mathrm{Capon}}(k,f) = \\frac{1}{a(k,f)^{\\mathrm{H}}R(f)^{-1}a(k,f)}$。\n- 系综协方差矩阵：$R(f) = \\sigma^2 I_M + P_s u(f) u(f)^{\\mathrm{H}}$，其中 $u(f) = a(k_d,f) + r a(k_r,f)$。\n\n为了符号简洁，我们将省略对 $f$ 的显式依赖，并使用简写 $a_d = a(k_d,f)$、$a_r = a(k_r,f)$ 和 $R = R(f)$。协方差矩阵是标度单位矩阵的秩-1 更新。其逆矩阵 $R^{-1}$ 可以使用 Sherman-Morrison-Woodbury 矩阵求逆引理求得：\n$$\n(A + vw^{\\mathrm{H}})^{-1} = A^{-1} - \\frac{A^{-1}vw^{\\mathrm{H}}A^{-1}}{1 + w^{\\mathrm{H}}A^{-1}v}\n$$\n令 $A = \\sigma^2 I_M$，$v = P_s^{1/2} u$，$w = P_s^{1/2} u$。那么 $A^{-1} = \\frac{1}{\\sigma^2}I_M$。应用该引理：\n$$\nR^{-1} \\;=\\; \\left(\\sigma^2 I_M + P_s u u^{\\mathrm{H}}\\right)^{-1} \\;=\\; \\frac{1}{\\sigma^2} I_M - \\frac{\\frac{1}{\\sigma^2} (P_s u u^{\\mathrm{H}}) \\frac{1}{\\sigma^2}}{\\sigma^2 + P_s u^{\\mathrm{H}} u} \\;=\\; \\frac{1}{\\sigma^2} \\left( I_M - \\frac{P_s u u^{\\mathrm{H}}}{\\sigma^2 + P_s \\|u\\|_2^2} \\right)\n$$\n接下来，我们计算 Capon 谱定义中分母的二次型，在观测波数 $k_d$ 处求值：\n$$\na_d^{\\mathrm{H}} R^{-1} a_d \\;=\\; a_d^{\\mathrm{H}} \\left[ \\frac{1}{\\sigma^2} \\left( I_M - \\frac{P_s u u^{\\mathrm{H}}}{\\sigma^2 + P_s \\|u\\|_2^2} \\right) \\right] a_d \\;=\\; \\frac{1}{\\sigma^2} \\left( a_d^{\\mathrm{H}} a_d - \\frac{P_s a_d^{\\mathrm{H}} u u^{\\mathrm{H}} a_d}{\\sigma^2 + P_s \\|u\\|_2^2} \\right)\n$$\n这可以简化为：\n$$\na_d^{\\mathrm{H}} R^{-1} a_d \\;=\\; \\frac{1}{\\sigma^2} \\left( \\|a_d\\|_2^2 - \\frac{P_s |a_d^{\\mathrm{H}} u|^2}{\\sigma^2 + P_s \\|u\\|_2^2} \\right) \\;=\\; \\frac{\\|a_d\\|_2^2(\\sigma^2 + P_s \\|u\\|_2^2) - P_s |a_d^{\\mathrm{H}} u|^2}{\\sigma^2 (\\sigma^2 + P_s \\|u\\|_2^2)}\n$$\n$$\na_d^{\\mathrm{H}} R^{-1} a_d \\;=\\; \\frac{\\sigma^2 \\|a_d\\|_2^2 + P_s (\\|a_d\\|_2^2 \\|u\\|_2^2 - |a_d^{\\mathrm{H}} u|^2)}{\\sigma^2 (\\sigma^2 + P_s \\|u\\|_2^2)}\n$$\n让我们简化 $\\|a_d\\|_2^2 \\|u\\|_2^2 - |a_d^{\\mathrm{H}} u|^2$ 这一项。代入 $u = a_d + r a_r$：\n$$\n\\|a_d\\|_2^2 \\|u\\|_2^2 - |a_d^{\\mathrm{H}} u|^2 = \\|a_d\\|_2^2 \\|a_d + r a_r\\|_2^2 - |a_d^{\\mathrm{H}}(a_d + r a_r)|^2\n$$\n使用 $\\|x+y\\|^2 = \\|x\\|^2+\\|y\\|^2+2\\mathrm{Re}(x^{\\mathrm{H}}y)$ 和 $|z_1+z_2|^2 = |z_1|^2+|z_2|^2+2\\mathrm{Re}(z_1^*z_2)$：\n$$\n= \\|a_d\\|_2^2 (\\|a_d\\|_2^2 + |r|^2 \\|a_r\\|_2^2 + 2\\mathrm{Re}(r^* a_d^{\\mathrm{H}} a_r)) - |\\|a_d\\|_2^2 + r a_d^{\\mathrm{H}} a_r|^2\n$$\n$$\n= \\|a_d\\|_2^4 + |r|^2 \\|a_d\\|_2^2 \\|a_r\\|_2^2 + 2\\|a_d\\|_2^2 \\mathrm{Re}(r^* a_d^{\\mathrm{H}} a_r) - (\\|a_d\\|_2^4 + |r a_d^{\\mathrm{H}} a_r|^2 + 2\\mathrm{Re}(\\|a_d\\|_2^2 r^* a_d^{\\mathrm{H}} a_r))\n$$\n$$\n= |r|^2 \\|a_d\\|_2^2 \\|a_r\\|_2^2 - |r|^2 |a_d^{\\mathrm{H}} a_r|^2 = |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)\n$$\n右侧是 $|r|^2$ 乘以一个与柯西-施瓦茨不等式相关的项，仅当 $a_d$ 和 $a_r$ 共线时该项为零。\n将此代回 $a_d^{\\mathrm{H}} R^{-1} a_d$：\n$$\na_d^{\\mathrm{H}} R^{-1} a_d = \\frac{\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)}{\\sigma^2 (\\sigma^2 + P_s \\|u\\|_2^2)}\n$$\nCapon 功率是此表达式的倒数：\n$$\n\\hat S_{\\mathrm{Capon}}(k_d,f) = \\frac{\\sigma^2 (\\sigma^2 + P_s \\|u\\|_2^2)}{\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)}\n$$\n噪声校正估计为 $\\hat S(k_d,f) = \\hat S_{\\mathrm{Capon}}(k_d,f) - \\frac{\\sigma^2}{\\|a_d\\|_2^2}$。通分后得到：\n$$\n\\hat S(k_d,f) = \\frac{\\sigma^2 \\|a_d\\|_2^2 (\\sigma^2 + P_s \\|u\\|_2^2) - \\sigma^2[\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)]}{\\|a_d\\|_2^2 [\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)]}\n$$\n分子简化为：\n$$\n\\text{Num} = \\sigma^2 P_s \\left[ \\|a_d\\|_2^2 \\|u\\|_2^2 - |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2) \\right]\n$$\n在方括号内代入 $\\|u\\|_2^2 = \\|a_d\\|_2^2 + |r|^2 \\|a_r\\|_2^2 + 2\\mathrm{Re}(r^* a_d^{\\mathrm{H}} a_r)$：\n$$\n[\\dots] = \\|a_d\\|_2^2 (\\|a_d\\|_2^2 + |r|^2 \\|a_r\\|_2^2 + 2\\mathrm{Re}(r^* a_d^{\\mathrm{H}} a_r)) - |r|^2 \\|a_d\\|_2^2 \\|a_r\\|_2^2 + |r|^2 |a_d^{\\mathrm{H}} a_r|^2\n$$\n$$\n= \\|a_d\\|_2^4 + 2\\|a_d\\|_2^2 \\mathrm{Re}(r^* a_d^{\\mathrm{H}} a_r) + |r|^2 |a_d^{\\mathrm{H}} a_r|^2 = |\\|a_d\\|_2^2 + r a_d^{\\mathrm{H}} a_r|^2 = |a_d^{\\mathrm{H}} u|^2\n$$\n因此，估计的功率为：\n$$\n\\hat S(k_d,f) = \\frac{\\sigma^2 P_s |a_d^{\\mathrm{H}} u|^2}{\\|a_d\\|_2^2 \\left[\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)\\right]}\n$$\n偏差为 $B(k_d,f) = \\hat S(k_d,f) - P_s$。\n$$\nB(k_d,f) = P_s \\left( \\frac{\\sigma^2 |a_d^{\\mathrm{H}} u|^2}{\\|a_d\\|_2^2 \\left[\\sigma^2 \\|a_d\\|_2^2 + P_s |r|^2 (\\|a_d\\|_2^2 \\|a_r\\|_2^2 - |a_d^{\\mathrm{H}} a_r|^2)\\right]} - 1 \\right)\n$$\n其中 $u = a_d + r a_r$。我们可以展开 $|a_d^{\\mathrm{H}}u|^2 = |\\|a_d\\|_2^2 + r(a_d^{\\mathrm{H}}a_r)|^2$。这就是偏差的最终闭式表达式。\n\n对于具有 $M$ 个传感器的均匀线性阵列（ULA），导向矢量元素是纯复指数，因此 $\\|a(k,f)\\|_2^2 = M$。从而，$\\|a_d\\|_2^2=M$ 且 $\\|a_r\\|_2^2=M$。内积为 $\\rho_c = a_d^{\\mathrm{H}}a_r = \\sum_{m=0}^{M-1} e^{j(k_r-k_d)md}$。ULA 的偏差表达式简化为：\n$$\nB(k_d,f) = P_s \\left( \\frac{\\sigma^2 |M + r \\rho_c|^2}{M \\left[\\sigma^2 M + P_s |r|^2 (M^2 - |\\rho_c|^2)\\right]} - 1 \\right)\n$$\n这就是需要实现的公式。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the bias of a noise-corrected Capon estimator in the presence\n    of a single coherent multipath return for a uniform linear array.\n    \"\"\"\n\n    def calculate_bias(M, d, k_d, k_r, r_mag, r_arg, P_s, sigma_sq):\n        \"\"\"\n        Calculates the theoretical bias B(k_d, f) using the derived closed-form expression.\n        \n        The formula for a Uniform Linear Array (ULA) is:\n        B = P_s * ( (sigma_sq * |M + r*rho_c|^2) / (M * (sigma_sq*M + P_s*|r|^2*(M^2 - |rho_c|^2))) - 1 )\n        where rho_c = a_d^H * a_r.\n        \"\"\"\n        \n        # Calculate the complex reflection coefficient\n        r_val = r_mag * np.exp(1j * r_arg)\n\n        # For a ULA, the norm-squared of the steering vectors is M\n        norm_sq_a = M\n\n        # Calculate the inner product rho_c = a_d^H * a_r\n        # rho_c = sum_{m=0}^{M-1} exp(j*(k_r - k_d)*m*d)\n        m_arr = np.arange(M)\n        delta_k = k_r - k_d\n        rho_c = np.sum(np.exp(1j * delta_k * m_arr * d))\n\n        # Magnitudes squared\n        mag_sq_r = r_mag**2\n        mag_sq_rho_c = np.abs(rho_c)**2\n        \n        # Term |M + r*rho_c|^2 which is |a_d^H * u|^2 for a ULA\n        adh_u = norm_sq_a + r_val * rho_c\n        mag_sq_adh_u = np.abs(adh_u)**2\n        \n        # Numerator of the fraction inside the bias expression parentheses\n        numerator_frac = sigma_sq * mag_sq_adh_u\n        \n        # Denominator of the fraction\n        # The term (M^2 - |rho_c|^2) corresponds to (||a_d||^2 ||a_r||^2 - |a_d^H a_r|^2)\n        # for a ULA.\n        denominator_frac = norm_sq_a * (sigma_sq * norm_sq_a + P_s * mag_sq_r * (norm_sq_a**2 - mag_sq_rho_c))\n        \n        # Handle potential division by zero if denominator is zero\n        if np.isclose(denominator_frac, 0):\n            # This case corresponds to a very high SNR and highly correlated signals\n            # where the matrix becomes near-singular. The bias will be large.\n            # Returning a large negative number, as the estimate will be suppressed.\n            return -P_s\n            \n        # The bias is P_s * (fraction - 1)\n        bias = P_s * (numerator_frac / denominator_frac - 1.0)\n        \n        return bias\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # M, d, k_d, k_r, |r|, arg(r), P_s, sigma^2\n        (8, 10, 0.12, 0.12, 0.0, 0.0, 1.0, 0.1),\n        (8, 10, 0.12, 0.12, 0.5, np.pi/4, 1.0, 0.1),\n        (12, 8, 0.15, 0.21, 0.3, 0.0, 1.0, 0.05),\n        # For case 4, k_r is defined relative to k_d, M, and d\n        (10, 9, 0.09, 0.09 + (2 * np.pi) / (10 * 9), 0.8, np.pi/2, 0.7, 0.2)\n    ]\n\n    results = []\n    for params in test_cases:\n        M, d, k_d, k_r, r_mag, r_arg, P_s, sigma_sq = params\n        bias_val = calculate_bias(M, d, k_d, k_r, r_mag, r_arg, P_s, sigma_sq)\n        results.append(bias_val)\n\n    # Format the output as a list of floating-point numbers rounded to 6 decimal places.\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}