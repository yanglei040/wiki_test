{
    "hands_on_practices": [
        {
            "introduction": "掌握欠定系统最小长度解的第一步是精通其核心计算方法。这个练习将通过一个简单的小规模符号示例，指导你使用奇异值分解（SVD）来手动推导最小长度解 。通过这个过程，你将清晰地看到解是如何仅由矩阵 $A$ 的行空间向量构成的，并明确排除了来自零空间的任何贡献。这为你理解为何该解是唯一的且范数最小提供了坚实的实践基础。",
            "id": "3610316",
            "problem": "在计算地球物理学中，线性化正演模型通常会导致欠定系统，其中模型参数的数量超过数据观测的数量。考虑线性正演模型 $d = A m$，其中 $A \\in \\mathbb{R}^{2 \\times 3}$ 且 $\\operatorname{rank}(A) = 2$。最小长度解定义为在所有满足数据方程的向量 $m$ 中，具有最小欧几里得范数的模型向量 $m^{\\star}$。\n\n设\n$$\nA = \\begin{pmatrix}\n\\sqrt{2}  0  \\sqrt{2} \\\\\n0  1  0\n\\end{pmatrix}, \\quad d = \\begin{pmatrix} d_{1} \\\\ d_{2} \\end{pmatrix},\n$$\n其中 $d_{1} \\in \\mathbb{R}$ 和 $d_{2} \\in \\mathbb{R}$ 是给定的数据。仅使用奇异值分解 (SVD) 的定义和最小长度解的定义，按以下步骤进行：\n\n- 构建一个与给定 $A$ 一致的 SVD $A = U \\Sigma V^{\\top}$，并满足 $U \\in \\mathbb{R}^{2 \\times 2}$ 是正交的，$V \\in \\mathbb{R}^{3 \\times 3}$ 是正交的，且 $\\Sigma \\in \\mathbb{R}^{2 \\times 3}$ 是对角矩阵，其非负对角元按降序排列。\n- 使用此 SVD 和正交性，推导满足约束 $A m = d$ 的最小长度解 $m^{\\star}$ 的解析表达式。\n- 在您的推理中说明，与通解集相比，$m^{\\star}$ 中的零空间分量是如何被抑制的。\n\n以 $d_{1}$ 和 $d_{2}$ 表示的单个行矩阵形式提供 $m^{\\star}$ 的最终答案。无需数值取整。无需物理单位。",
            "solution": "问题要求解欠定线性系统 $A m = d$ 的最小长度解 $m^{\\star}$。这是在约束 $A m = d$ 下，最小化欧几里得范数 $\\|m\\|_{2}$ 的向量 $m^{\\star}$。我们将使用 $A$ 的 SVD 来解决这个问题。\n\n首先，我们构建 $A$ 的奇异值分解 (SVD)，其形式为 $A = U \\Sigma V^{\\top}$。\n\n$A$ 的奇异值 $\\sigma_i$ 是 $A A^{\\top}$ 的非零特征值的平方根。\n$$\nA A^{\\top} = \\begin{pmatrix} \\sqrt{2}  0  \\sqrt{2} \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\\\ \\sqrt{2}  0 \\end{pmatrix} = \\begin{pmatrix} 2+0+2  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 4  0 \\\\ 0  1 \\end{pmatrix}\n$$\n$A A^{\\top}$ 的特征值为 $\\lambda_1 = 4$ 和 $\\lambda_2 = 1$。奇异值是它们的平方根，按降序排列：$\\sigma_1 = \\sqrt{4} = 2$ 和 $\\sigma_2 = \\sqrt{1} = 1$。\n矩阵 $\\Sigma \\in \\mathbb{R}^{2 \\times 3}$ 由这些奇异值构成：\n$$\n\\Sigma = \\begin{pmatrix} 2  0  0 \\\\ 0  1  0 \\end{pmatrix}\n$$\n矩阵 $U \\in \\mathbb{R}^{2 \\times 2}$ 由 $A A^{\\top}$ 的归一化特征向量组成。由于 $A A^{\\top}$ 是一个对角矩阵，其特征向量是标准基向量。\n对于 $\\lambda_1 = 4$：$u_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_2 = 1$：$u_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。\n因此，$U$ 是单位矩阵 $I_2$：\n$$\nU = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n矩阵 $V \\in \\mathbb{R}^{3 \\times 3}$ 由 $A^{\\top} A$ 的归一化特征向量组成。\n$$\nA^{\\top} A = \\begin{pmatrix} \\sqrt{2}  0 \\\\ 0  1 \\\\ \\sqrt{2}  0 \\end{pmatrix} \\begin{pmatrix} \\sqrt{2}  0  \\sqrt{2} \\\\ 0  1  0 \\end{pmatrix} = \\begin{pmatrix} 2  0  2 \\\\ 0  1  0 \\\\ 2  0  2 \\end{pmatrix}\n$$\n$A^{\\top} A$ 的特征值为 $\\lambda_1 = 4$，$\\lambda_2 = 1$ 和 $\\lambda_3 = 0$。\n对于 $\\lambda_1 = 4$：$(A^{\\top} A - 4I)v_1 = 0 \\implies \\begin{pmatrix} -2  0  2 \\\\ 0  -3  0 \\\\ 2  0  -2 \\end{pmatrix} v_1 = 0$。这得到 $x=z$ 和 $y=0$。一个对应的特征向量是 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$。归一化后得到 $v_1 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n对于 $\\lambda_2 = 1$：$(A^{\\top} A - 1I)v_2 = 0 \\implies \\begin{pmatrix} 1  0  2 \\\\ 0  0  0 \\\\ 2  0  1 \\end{pmatrix} v_2 = 0$。这得到 $x=0$ 和 $z=0$。一个对应的特征向量是 $\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$。这已经归一化，所以 $v_2 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n对于 $\\lambda_3 = 0$：$(A^{\\top} A - 0I)v_3 = 0 \\implies \\begin{pmatrix} 2  0  2 \\\\ 0  1  0 \\\\ 2  0  2 \\end{pmatrix} v_3 = 0$。这得到 $x=-z$ 和 $y=0$。一个特征向量是 $\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$。归一化后得到 $v_3 = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$。\n正交矩阵 $V$ 由这些特征向量作为列构成：\n$$\nV = \\begin{pmatrix} v_1  v_2  v_3 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  0  \\frac{1}{\\sqrt{2}} \\\\ 0  1  0 \\\\ \\frac{1}{\\sqrt{2}}  0  -\\frac{1}{\\sqrt{2}} \\end{pmatrix}\n$$\n现在我们使用 SVD 来求解最小长度解 $m^{\\star}$。约束方程为 $A m = d$。代入 SVD：\n$$\nU \\Sigma V^{\\top} m = d\n$$\n由于 $U$ 是正交的（$U^{\\top} U = I$），我们可以从左侧乘以 $U^{\\top}$：\n$$\n\\Sigma V^{\\top} m = U^{\\top} d\n$$\n我们定义一个变换后的模型向量 $m' = V^{\\top} m$。由于 $V$ 是正交的，欧几里得范数保持不变：$\\|m'\\|_{2} = \\|V^{\\top} m\\|_{2} = \\|m\\|_{2}$。因此，最小化 $\\|m\\|_{2}$ 等价于最小化 $\\|m'\\|_{2}$。\n方程变为 $\\Sigma m' = U^{\\top} d$。\n由于 $U=I_2$，我们有 $U^{\\top}d = d$。设 $m' = \\begin{pmatrix} m'_1 \\\\ m'_2 \\\\ m'_3 \\end{pmatrix}$。该系统为：\n$$\n\\begin{pmatrix} 2  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} m'_1 \\\\ m'_2 \\\\ m'_3 \\end{pmatrix} = \\begin{pmatrix} d_1 \\\\ d_2 \\end{pmatrix}\n$$\n这产生了两个方程：\n$2 m'_1 = d_1 \\implies m'_1 = \\frac{d_1}{2}$\n$1 m'_2 = d_2 \\implies m'_2 = d_2$\n分量 $m'_3$ 不受数据方程的约束。$m'$ 的通解为 $m' = \\begin{pmatrix} d_1/2 \\\\ d_2 \\\\ \\alpha \\end{pmatrix}$，对于任意 $\\alpha \\in \\mathbb{R}$。\n我们想要找到范数最小的解。$m'$ 的范数平方是：\n$$\n\\|m'\\|_{2}^{2} = (m'_1)^2 + (m'_2)^2 + (m'_3)^2 = \\left(\\frac{d_1}{2}\\right)^2 + d_2^2 + \\alpha^2\n$$\n为了最小化这个范数，我们必须选择 $\\alpha=0$。因此，最小长度的变换解是：\n$$\nm'^{\\star} = \\begin{pmatrix} d_1/2 \\\\ d_2 \\\\ 0 \\end{pmatrix}\n$$\n最后，我们使用关系式 $m = V m'$ 变换回原始模型空间以找到 $m^{\\star}$，所以 $m^{\\star} = V m'^{\\star}$：\n$$\nm^{\\star} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  0  \\frac{1}{\\sqrt{2}} \\\\ 0  1  0 \\\\ \\frac{1}{\\sqrt{2}}  0  -\\frac{1}{\\sqrt{2}} \\end{pmatrix} \\begin{pmatrix} \\frac{d_1}{2} \\\\ d_2 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}\\frac{d_1}{2} + 0 + 0 \\\\ 0 + d_2 + 0 \\\\ \\frac{1}{\\sqrt{2}}\\frac{d_1}{2} + 0 + 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{d_1}{2\\sqrt{2}} \\\\ d_2 \\\\ \\frac{d_1}{2\\sqrt{2}} \\end{pmatrix}\n$$\n分母有理化后得到：\n$$\nm^{\\star} = \\begin{pmatrix} \\frac{\\sqrt{2}}{4}d_1 \\\\ d_2 \\\\ \\frac{\\sqrt{2}}{4}d_1 \\end{pmatrix}\n$$\n为了说明零空间分量是如何被抑制的，我们考虑通解 $m_{gen}$。$A$ 的零空间是所有满足 $A m_n = 0$ 的向量 $m_n$ 的集合。从 SVD 可知，零空间由 $V$ 中对应于零奇异值的列向量张成。这里，$\\sigma_3=0$，所以零空间由 $v_3 = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$ 张成。零空间中的任何向量都可以写成 $m_n = c v_3$ 的形式，其中 $c$ 是某个标量。\n$A m = d$ 的通解是任意一个特解与一个来自零空间的向量之和。我们可以用 $m^{\\star}$ 作为特解：\n$$\nm_{gen} = m^{\\star} + m_n = m^{\\star} + c v_3\n$$\n解 $m^{\\star}$ 位于 $v_1$ 和 $v_2$ 的张成空间中：$m^{\\star} = (\\frac{d_1}{2\\sqrt{2}}) \\sqrt{2} v_1 + d_2 v_2 = \\frac{d_1}{2} v_1 + d_2 v_2$。$V$ 的列是标准正交的，所以 $m^{\\star}$ 与 $m_n=c v_3$ 正交。\n通解的范数平方是：\n$$\n\\|m_{gen}\\|_{2}^{2} = \\|m^{\\star} + c v_3\\|_{2}^{2} = (m^{\\star} + c v_3)^{\\top}(m^{\\star} + c v_3) = \\|m^{\\star}\\|_{2}^{2} + 2 c (m^{\\star})^{\\top}v_3 + c^2 \\|v_3\\|_{2}^{2}\n$$\n由于 $(m^{\\star})^{\\top}v_3 = 0$（因为正交性）且 $\\|v_3\\|_{2}^{2} = 1$：\n$$\n\\|m_{gen}\\|_{2}^{2} = \\|m^{\\star}\\|_{2}^{2} + c^2\n$$\n当 $c=0$ 时，该表达式最小化。这对应于选择零空间分量为零的解。因此，最小长度解 $m^{\\star}$ 是零空间分量被完全抑制的解。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{2}}{4} d_{1}  d_{2}  \\frac{\\sqrt{2}}{4} d_{1}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然最小长度解在数学上很优雅，但它不一定符合地质上的实际情况。这个练习将带你探索更丰富的解集，通过系统地添加来自零空间的向量分量来实现 。你将学习如何构建一个既能完美拟合数据，又能满足额外地质约束（例如，强制模型某些区域的参数为零）的新解，这是通过寻找一个满足新约束条件的最小范数零空间向量来对原始解进行修正。",
            "id": "3610331",
            "problem": "考虑一个计算地球物理学中的线性反演问题，其中，一个离散化的灵敏度矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 通过 $A x = b$ 将地下模型参数 $x \\in \\mathbb{R}^{n}$（例如，网格上的密度或电阻率差异）与观测数据 $b \\in \\mathbb{R}^{m}$ 联系起来。在许多实际情况中，$m  n$，因此该系统是欠定的，并有无穷多个解。反演理论中一个普遍接受的基本原理是，通过使用 $A$ 的 Moore–Penrose 伪逆将 $b$ 投影回模型空间，可以获得最小长度（最小欧几里得范数）解 $x^\\ast$。地质先验信息可能要求额外的结构，例如 $x$ 在一个已知区域（例如，差异可忽略的沉积盆地）内应该是稀疏的或为零。探索 $A$ 的零空间提供了一种施加此类特征的方法，同时在所有与这些特征一致的解中保持最小长度属性。\n\n您的任务是形式化并实现以下步骤：\n\n1. 从零空间和最小长度解的定义出发，计算零空间 $\\ker(A)$ 的一个基 $N \\in \\mathbb{R}^{n \\times k}$，其中 $k$ 是 $A$ 的零度。使用通过奇异值分解 (SVD) 获得的正交归一列向量构成的基。\n\n2. 将 $A x = b$ 的所有解表示为 $x = x^\\ast + N \\alpha$，其中 $x^\\ast$ 是最小长度解，$\\alpha \\in \\mathbb{R}^{k}$ 参数化了在零空间中的移动。\n\n3. 设计一个选择 $\\alpha$ 的准则，该准则强制 $x$ 在一个指定的索引集 $S \\subset \\{0,1,\\dots,n-1\\}$（代表一个地质区域）上精确为零，同时在所有满足 $A x = b$ 和对所有 $i \\in S$ 都有 $x_i = 0$ 的解中保持最小长度。用纯数学术语形式化此准则，并推导出关于 $\\alpha$ 的代数系统。\n\n4. 实现一个算法，该算法：\n   - 使用 Moore–Penrose 伪逆从 $A$ 和 $b$ 计算 $x^\\ast$。\n   - 使用奇异值分解 (SVD) 计算 $\\ker(A)$ 的一个正交归一基 $N$。\n   - 构建一个选择矩阵 $C \\in \\mathbb{R}^{|S| \\times n}$，该矩阵对 $S$ 中的索引施加 $C x = 0$ 的约束。\n   - 使用推导出的准则求解 $\\alpha$。如果约束系统不可行，则检测到不可行性并且不改变 $x^\\ast$；如果可行，则返回约束最小长度解。\n\n您必须使用的数学基础包括：\n- 零空间的定义 $\\ker(A) = \\{x \\in \\mathbb{R}^n : A x = 0\\}$。\n- 通过 Moore–Penrose 伪逆 $A^+$ 对最小长度解的特征描述，其中 $x^\\ast = A^+ b$ 求解 $A x = b$ 并最小化 $\\|x\\|_2$。\n- 从奇异值分解 (SVD) 推导出的正交投影恒等式，不提供超出这些基的快捷公式。\n\n您必须实现该程序，并在以下明确的测试套件上进行评估。每个测试用例指定一个矩阵 $A$、一个数据向量 $b$ 和一个要置零的区域 $S$。所有数字都是无量纲的，没有物理单位。不涉及角度和百分比。\n\n按如下方式定义测试套件的矩阵和向量：\n\n- 情况 1 (可行路径):\n  $$\n  A_1 = \\begin{bmatrix}\n  1  0  1  2  0 \\\\\n  0  1  -1  0  1 \\\\\n  1  1  0  1  -1\n  \\end{bmatrix},\\quad\n  x^{(0)}_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ -2 \\\\ 0.5 \\end{bmatrix},\\quad\n  b_1 = A_1 x^{(0)}_1,\\quad\n  S_1 = \\{0,1\\}.\n  $$\n\n- 情况 2 (多个零空间方向，可行):\n  $$\n  A_2 = \\begin{bmatrix}\n  1  2  0  1 \\\\\n  0  1  1  -1\n  \\end{bmatrix},\\quad\n  x^{(0)}_2 = \\begin{bmatrix} 1 \\\\ -1 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  b_2 = A_2 x^{(0)}_2,\\quad\n  S_2 = \\{3\\}.\n  $$\n\n- 情况 3 (设计上不可行的约束):\n  令 $A_3$ 的列为 $c_0 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$，$c_1 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}$，$c_2 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$，$c_3 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 1 \\end{bmatrix}$，$c_4 = \\begin{bmatrix} 0 \\\\ 2 \\\\ -1 \\end{bmatrix}$，以及\n  $$\n  A_3 = \\begin{bmatrix} c_0  c_1  c_2  c_3  c_4 \\end{bmatrix}\n  = \\begin{bmatrix}\n  1  0  0  0  0 \\\\\n  0  1  0  1  2 \\\\\n  0  0  1  1  -1\n  \\end{bmatrix},\\quad\n  b_3 = \\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix},\\quad\n  S_3 = \\{0\\}.\n  $$\n  在这种情况下，$c_0$ 不在其他列的张成空间中，因此任何解在索引 $0$ 处都必须有一个固定的非零分量，这使得 $x_0 = 0$ 不可行。\n\n- 情况 4 (边界情况：空区域，无额外约束):\n  重用上面的 $A_1$ 和 $b_1$，并设置\n  $$\n  S_4 = \\varnothing.\n  $$\n\n对于每种情况，计算：\n- 无约束最小长度解 $x^\\ast$。\n- 如果可行，则通过您的准则选择 $\\alpha$ 获得的约束最小长度解 $\\hat{x}$；否则，设置 $\\hat{x} = x^\\ast$ 并标记为不可行。\n- 欧几里得范数平方的增量 $\\Delta = \\|\\hat{x}\\|_2^2 - \\|x^\\ast\\|_2^2$。\n- 一个可行性标志，指示对所有 $i \\in S$ 的约束 $x_i = 0$ 是否被精确满足。\n- 约束索引上的最大绝对值 $M = \\max_{i \\in S} | \\hat{x}_i |$（如果 $S$ 为空，则定义 $M = 0$）。\n\n您的程序必须生成一行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，每个测试用例贡献一个形式为 $[\\Delta, \\text{feasible}, M]$ 的列表。例如，格式应类似于 $[[\\Delta_1,\\text{feasible}_1,M_1],[\\Delta_2,\\text{feasible}_2,M_2],[\\Delta_3,\\text{feasible}_3,M_3],[\\Delta_4,\\text{feasible}_4,M_4]]$。",
            "solution": "该问题要求制定并实现一个算法，以找到欠定线性系统 $A x = b$ 的一个最小长度解，该解还需满足解向量 $x$ 的某些分量必须为零的附加约束。这是计算地球物理学中的一项常见任务，其中必须结合有关地下模型的先验信息。\n\n推导过程分几个步骤进行，从线性系统的基本性质开始，逐步构建到约束优化问题。\n\n首先，我们描述欠定系统 $A x = b$ 的所有解的集合，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m  n$。Moore-Penrose 伪逆 $A^+$ 提供了具有最小欧几里得范数的唯一解，记为 $x^\\ast = A^+ b$。该解完全位于 $A$ 的行空间中，记为 $\\text{range}(A^T)$。任何其他解 $x$ 都可以通过加上一个来自 $A$ 的零空间 $\\ker(A) = \\{z \\in \\mathbb{R}^n : Az = 0\\}$ 的向量来表示。因此，任何解的一般形式是 $x = x^\\ast + x_n$，其中 $x_n \\in \\ker(A)$。\n\n$A$ 的奇异值分解 (SVD) 为行空间和零空间都提供了正交归一基。设 $A$ 的 SVD 为 $A = U \\Sigma V^T$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个包含奇异值 $\\sigma_i$ 的矩形对角矩阵。如果 $A$ 的秩为 $r$，则有 $r$ 个非零奇异值。$V$ 的最后 $k = n-r$ 列构成了 $\\ker(A)$ 的一个正交归一基。我们可以将这些基向量组合成一个矩阵 $N \\in \\mathbb{R}^{n \\times k}$。于是，$\\ker(A)$ 中的任何向量 $x_n$ 都可以写成这些基向量的线性组合，$x_n = N \\alpha$，其中 $\\alpha \\in \\mathbb{R}^k$ 是某个系数向量。因此，$A x = b$ 的完整解集由 $\\alpha$ 参数化：\n$$x(\\alpha) = x^\\ast + N \\alpha$$\n\n问题引入了一个附加约束：对于给定的索引集 $S \\subset \\{0, 1, \\dots, n-1\\}$，我们要求对所有 $i \\in S$ 都有 $x_i = 0$。这可以使用一个选择矩阵 $C \\in \\mathbb{R}^{|S| \\times n}$ 来表示，其中 $C$ 的每一行是对应某个 $i \\in S$ 的标准基向量 $e_i^T$。该约束可以紧凑地写为 $C x = 0$。\n\n我们的目标是找到同时满足 $A x = b$ 和 $C x = 0$ 且具有最小可能欧几里得范数 $\\|x\\|_2$ 的解 $x$。我们将一般解形式 $x(\\alpha)$ 代入新约束中：\n$$C(x^\\ast + N \\alpha) = 0$$\n$$C N \\alpha = -C x^\\ast$$\n这是一个关于未知系数 $\\alpha$ 的线性系统。我们记 $G = CN$ 和 $d = -Cx^\\ast$。该系统为 $G \\alpha = d$。\n\n同时，我们希望最小化解的范数 $\\|x(\\alpha)\\|_2$。因为 $x^\\ast \\in \\text{range}(A^T)$ 且 $N\\alpha \\in \\ker(A)$，并且这两个子空间是正交补，所以向量 $x^\\ast$ 和 $N\\alpha$ 是正交的。根据勾股定理：\n$$\\|x(\\alpha)\\|_2^2 = \\|x^\\ast + N\\alpha\\|_2^2 = \\|x^\\ast\\|_2^2 + \\|N\\alpha\\|_2^2$$\n由于 $N$ 的列构成一个正交归一基，$\\|N\\alpha\\|_2^2 = \\alpha^T N^T N \\alpha = \\alpha^T I_k \\alpha = \\|\\alpha\\|_2^2$。因此，优化问题变为最小化 $\\|x^\\ast\\|_2^2 + \\|\\alpha\\|_2^2$。由于 $\\|x^\\ast\\|_2^2$ 是一个常数，这等价于最小化 $\\|\\alpha\\|_2^2$。\n\n问题被简化为找到满足线性系统 $G \\alpha = d$ 的最小范数向量 $\\alpha$。这是一个经典问题，其解由 $G$ 的伪逆给出：\n$$\\alpha = G^+ d = (CN)^+ (-Cx^\\ast)$$\n\n$\\alpha$ 的解存在当且仅当 $d$ 在 $G$ 的值域中。这是约束的可行性条件。我们可以通过检查计算出的 $\\alpha$ 是否满足该系统来验证此条件，即 $G\\alpha$ 是否在数值上接近 $d$。如果系统不可行，则不存在同时满足 $Ax=b$ 和 $Cx=0$ 的解。在这种情况下，根据问题陈述，我们不修改原始的最小长度解，因此约束解 $\\hat{x}$ 被设置为 $x^\\ast$。\n\n如果系统可行，则计算出最优系数向量 $\\alpha$，约束最小长度解为：\n$$\\hat{x} = x^\\ast + N \\alpha$$\n\n范数平方的增量为 $\\Delta = \\|\\hat{x}\\|_2^2 - \\|x^\\ast\\|_2^2$。由于正交性，这可以简化为 $\\Delta = \\|N\\alpha\\|_2^2 = \\|\\alpha\\|_2^2$。\n\n最终的算法如下：\n1.  给定 $A$、$b$ 和 $S$，计算无约束最小长度解 $x^\\ast = A^+ b$。\n2.  计算 $A$ 的 SVD 以找到其零空间 $\\ker(A)$ 的一个正交归一基 $N$。$N$ 的列是与数值上为零的奇异值相对应的右奇异向量。\n3.  如果约束集 $S$ 为空，则无需任何操作。解为 $\\hat{x} = x^\\ast$，且 $\\Delta = 0$。\n4.  如果 $S$ 非空，则构建线性系统 $G \\alpha = d$，其中 $G=CN$ 且 $d=-Cx^\\ast$。在实现中，这通过索引实现：$G$ 由 $N$ 中由 $S$ 索引的行组成，$d$ 由 $x^\\ast$ 中由 $S$ 索引的元素的相反数组成。\n5.  使用伪逆求解最小范数 $\\alpha$：$\\alpha = G^+ d$。\n6.  通过测试 $G \\alpha \\approx d$ 来检查可行性。\n7.  如果可行，计算约束解 $\\hat{x} = x^\\ast + N \\alpha$。计算范数增量 $\\Delta = \\|\\alpha\\|_2^2$ 和约束索引上的最大绝对值 $M$。\n8.  如果不可行，解为 $\\hat{x} = x^\\ast$。范数增量 $\\Delta$ 为 $0$，而 $M$ 根据 $x^\\ast$ 在 $S$ 中索引的分量计算得出。",
            "answer": "```python\nimport numpy as np\n\ndef solve_constrained_min_length(A, b, S):\n    \"\"\"\n    Computes the minimum-length solution to Ax=b with constraints x_i=0 for i in S.\n\n    Args:\n        A (np.ndarray): The matrix A.\n        b (np.ndarray): The vector b.\n        S (set): A set of indices to be constrained to zero.\n\n    Returns:\n        tuple: A tuple containing (delta, feasible, M), where delta is the increase\n               in squared norm, feasible is a boolean flag, and M is the max\n               absolute value on constrained indices.\n    \"\"\"\n    m, n = A.shape\n    \n    # 1. Compute the unconstrained minimum-length solution\n    x_ast = np.linalg.pinv(A) @ b\n    \n    # 2. Compute an orthonormal basis for the nullspace of A using SVD\n    try:\n        U, s, Vt = np.linalg.svd(A)\n        # Tolerance for identifying zero singular values\n        tol = s.max() * max(A.shape) * np.finfo(s.dtype).eps\n        rank = np.sum(s > tol)\n        null_space_basis = Vt.T[:, rank:]\n    except np.linalg.LinAlgError:\n        # Handle cases where SVD might fail, though unlikely with test data\n        null_space_basis = np.zeros((n, 0))\n\n    # 3. Handle empty constraint set\n    if not S:\n        hat_x = x_ast\n        delta = 0.0\n        feasible = True\n        M = 0.0\n        return [delta, feasible, M]\n    \n    S_list = sorted(list(S))\n\n    # Handle trivial nullspace\n    if null_space_basis.shape[1] == 0:\n        hat_x = x_ast\n        M = np.max(np.abs(hat_x[S_list]))\n        feasible = np.allclose(M, 0)\n        delta = 0.0\n        return [delta, feasible, M]\n\n    # 4. Form the linear system for alpha\n    G = null_space_basis[S_list, :]\n    d = -x_ast[S_list]\n    \n    # 5. Solve for the minimum-norm alpha\n    alpha = np.linalg.pinv(G) @ d\n    \n    # 6. Check feasibility\n    if np.allclose(G @ alpha, d):\n        feasible = True\n        # 7. Compute the constrained solution\n        hat_x = x_ast + null_space_basis @ alpha\n        # Calculate performance metrics\n        delta = np.sum(alpha**2)\n        M = np.max(np.abs(hat_x[S_list]))\n    else:\n        feasible = False\n        # 8. If infeasible, use the unconstrained solution\n        hat_x = x_ast\n        delta = 0.0\n        M = np.max(np.abs(hat_x[S_list]))\n\n    return [delta, feasible, M]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the solver, and prints the formatted results.\n    \"\"\"\n    # Case 1\n    A1 = np.array([\n        [1., 0., 1., 2., 0.],\n        [0., 1., -1., 0., 1.],\n        [1., 1., 0., 1., -1.]\n    ])\n    x0_1 = np.array([0., 0., 1., -2., 0.5])\n    b1 = A1 @ x0_1\n    S1 = {0, 1}\n\n    # Case 2\n    A2 = np.array([\n        [1., 2., 0., 1.],\n        [0., 1., 1., -1.]\n    ])\n    x0_2 = np.array([1., -1., 0., 0.])\n    b2 = A2 @ x0_2\n    S2 = {3}\n\n    # Case 3\n    A3 = np.array([\n        [1., 0., 0., 0., 0.],\n        [0., 1., 0., 1., 2.],\n        [0., 0., 1., 1., -1.]\n    ])\n    b3 = np.array([1., 1., 0.])\n    S3 = {0}\n\n    # Case 4\n    A4 = A1\n    b4 = b1\n    S4 = set()\n\n    test_cases = [\n        (A1, b1, S1),\n        (A2, b2, S2),\n        (A3, b3, S3),\n        (A4, b4, S4)\n    ]\n\n    results = []\n    for A, b, S in test_cases:\n        result = solve_constrained_min_length(A, b, S)\n        results.append(result)\n\n    # Format boolean as lowercase string for consistency if needed,\n    # but problem description implies standard python str() is fine.\n    # e.g., '[{r[0]}, {str(r[1]).lower()}, {r[2]}]'\n    # The asked format is `[[...], [...]]` which is naturally produced by `str()`\n    # of a list of lists. The joiner `','.join` correctly handles this.\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的地球物理问题通常要求在拟合观测数据的同时，还要遵循诸如质量守恒等物理定律。这个练习将前面的概念综合成一个通用框架，用于寻找同时满足多组线性约束的最小范数解 。你将通过Karush-Kuhn-Tucker（KKT）条件推导并实现一个求解器，从而掌握一个功能强大且通用的工具，以应对复杂的约束反演问题。",
            "id": "3610307",
            "problem": "给定一个欠定线性系统，其等式约束来自计算地球物理学中的典型离散化。考虑在满足线性等式约束的条件下，最小化模型向量的欧几里得长度。该问题的设置为：最小化向量 $x \\in \\mathbb{R}^n$ 的欧几里得范数，同时满足数据拟合约束 $A x = b$ 和物理约束 $C x = d$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $m  n$，$b \\in \\mathbb{R}^m$，$C \\in \\mathbb{R}^{p \\times n}$，$d \\in \\mathbb{R}^p$。约束 $C x = d$ 编码了地球物理学相关属性，例如质量守恒或零均值，如 $e^{\\top} x = 0$，其中 $e \\in \\mathbb{R}^n$ 是全为1的向量。所有量均为无量纲。\n\n请仅从约束优化的基础知识和 Karush–Kuhn–Tucker (KKT) 方法出发，推导最优性的必要条件，并通过适当地消元，获得一个可计算实现的系统，用以计算同时满足两组约束的最小长度解 $x^*$。然后，实现该方法，为以下每个测试用例计算 $x^*$。在您的推导中，讨论 $C$ 在塑造 $x^*$ 时的物理作用，并解释诸如质量守恒之类的约束如何改变最小长度解的结构（相对于没有 $C$ 的情况）。\n\n您的程序必须为每个测试用例计算 $x^*$，并在一行内输出解的列表。每个解向量必须四舍五入到 $6$ 位小数。最终输出格式必须是单行，包含一个用逗号分隔的 Python 风格浮点数列表的列表，并用方括号括起来，例如 $[ [x_{1,1}, x_{1,2}, \\dots], [x_{2,1}, \\dots], \\dots ]$。除了无量纲量外没有物理单位。本问题不涉及角度。\n\n测试套件，每个都有指定的矩阵和向量。对于每种情况，$n$、$m$ 和 $p$ 分别是 $x$、$A$ 和 $C$ 的维度。\n\n- 情况 $1$（理想情况；带质量守恒的欠定数据约束）：$n = 5$，$m = 2$，$p = 1$，\n  $$\n  A_1 = \\begin{bmatrix}\n  1  0  -1  2  0 \\\\\n  0  1  2  -1  1\n  \\end{bmatrix},\\quad\n  b_1 = \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix},\\quad\n  C_1 = \\begin{bmatrix} 1  1  1  1  1 \\end{bmatrix},\\quad\n  d_1 = \\begin{bmatrix} 0 \\end{bmatrix}.\n  $$\n  这强制执行质量守恒 $e^{\\top} x = 0$。\n\n- 情况 $2$（无物理约束 $C$；$A x = b$ 的经典最小长度解）：$n = 5$，$m = 3$，$p = 0$，\n  $$\n  A_2 = \\begin{bmatrix}\n  2  -1  0  1  3 \\\\\n  0  1  -2  1  0 \\\\\n  1  0  1  0  -1\n  \\end{bmatrix},\\quad\n  b_2 = \\begin{bmatrix} 4 \\\\ 0 \\\\ 1 \\end{bmatrix},\\quad\n  C_2 \\text{ 是 } p=0 \\text{ 的空矩阵},\\quad\n  d_2 \\text{ 是 } p=0 \\text{ 的空向量}。\n  $$\n\n- 情况 $3$（数据约束为齐次的，物理约束为非零的；均匀分配所需的质量）：$n = 5$，$m = 2$，$p = 1$，\n  $$\n  A_3 = \\begin{bmatrix}\n  1  -1  0  0  0 \\\\\n  0  1  -1  0  0\n  \\end{bmatrix},\\quad\n  b_3 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\\quad\n  C_3 = \\begin{bmatrix} 1  1  1  1  1 \\end{bmatrix},\\quad\n  d_3 = \\begin{bmatrix} 1 \\end{bmatrix}.\n  $$\n\n- 情况 $4$（两个物理约束，用于投影掉常数和线性模式）：$n = 5$，$m = 2$，$p = 2$，\n  $$\n  A_4 = \\begin{bmatrix}\n  1  0  -1  2  0 \\\\\n  0  1  2  -1  1\n  \\end{bmatrix},\\quad\n  b_4 = \\begin{bmatrix} 1 \\\\ -2 \\end{bmatrix},\\quad\n  C_4 = \\begin{bmatrix}\n  1  1  1  1  1 \\\\\n  0  1  2  3  4\n  \\end{bmatrix},\\quad\n  d_4 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}.\n  $$\n\n- 情况 $5$（冗余的物理约束；需要数值稳健的求解器）：$n = 4$，$m = 1$，$p = 2$，\n  $$\n  A_5 = \\begin{bmatrix}\n  1  0  -1  0\n  \\end{bmatrix},\\quad\n  b_5 = \\begin{bmatrix} 0 \\end{bmatrix},\\quad\n  C_5 = \\begin{bmatrix}\n  1  1  1  1 \\\\\n  2  2  2  2\n  \\end{bmatrix},\\quad\n  d_5 = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}.\n  $$\n  注意 $C_5$ 中的第二个约束是第一个约束的标量倍，这使得约束集是冗余的。\n\n您的程序必须通过 KKT 框架和消元法，使用数值稳定的线性代数程序计算每种情况下的最小长度解 $x^*$。最终输出必须是单行，包含四舍五入后的解，格式为逗号分隔的列表的列表，例如 $[[x^{*(1)}_1,\\dots,x^{*(1)}_n],[x^{*(2)}_1,\\dots],\\dots]$。所有量都是无量纲的。不涉及角度或百分比。在打印前，数值必须四舍五入到 6 位小数。输出必须只包含一行；不允许有额外的文本。",
            "solution": "所述问题是有效的。这是一个适定的、有科学依据的约束优化问题，是计算科学，特别是地球物理反演问题中的核心课题。为所有测试用例提供的数据都是完整且一致的。\n\n该优化问题旨在寻找一个向量 $x \\in \\mathbb{R}^n$，使其最小化欧几里得范数的平方，这等价于最小化目标函数 $f(x) = \\frac{1}{2} x^\\top x$。此最小化过程受两组线性等式约束的制约：\n1. 数据拟合约束：$A x = b$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $b \\in \\mathbb{R}^m$。\n2. 物理约束：$C x = d$，其中 $C \\in \\mathbb{R}^{p \\times n}$ 且 $d \\in \\mathbb{R}^p$。\n\n标量约束的总数为 $m+p$。问题被描述为欠定的，这意味着变量数量 $n$ 大于线性无关约束的数量。我们假设约束系统是一致的，即存在一个可行解 $x$。\n\n为解决此问题，我们首先将这些约束统一到一个系统中。我们定义一个复合矩阵 $G \\in \\mathbb{R}^{(m+p) \\times n}$ 和一个复合向量 $h \\in \\mathbb{R}^{m+p}$：\n$$\nG = \\begin{bmatrix} A \\\\ C \\end{bmatrix}, \\quad h = \\begin{bmatrix} b \\\\ d \\end{bmatrix}\n$$\n然后，优化问题可以紧凑地写为：\n$$\n\\text{最小化} \\quad \\frac{1}{2} x^\\top x \\quad \\text{约束条件为} \\quad Gx = h\n$$\n这是一个凸优化问题，其特点是具有严格凸的二次目标函数和线性等式约束。这种结构保证了存在唯一的全局最小值。我们可以使用拉格朗日乘子法来找到这个解。拉格朗日函数 $\\mathcal{L}(x, \\lambda)$ 构建如下：\n$$\n\\mathcal{L}(x, \\lambda) = \\frac{1}{2} x^\\top x + \\lambda^\\top (h - Gx)\n$$\n其中 $\\lambda \\in \\mathbb{R}^{m+p}$ 是拉格朗日乘子向量。\n\nKarush–Kuhn–Tucker (KKT) 条件对于最优性是必要的，并且对于这个凸问题也是充分的。这些条件通过将拉格朗日函数相对于原始变量 $x$ 和对偶变量 $\\lambda$ 的梯度设为零来找到。\n\n关于 $x$ 的梯度是：\n$$\n\\nabla_x \\mathcal{L}(x, \\lambda) = x - G^\\top \\lambda\n$$\n将此梯度设为零，得到第一个最优性条件，它定义了最优解 $x^*$ 的结构：\n$$\nx^* = G^\\top \\lambda \\quad (1)\n$$\n这个基本结果揭示了最小范数解 $x^*$ 必须位于约束矩阵 $G$ 的行空间中。它是 $A$ 和 $C$ 的行的线性组合。\n\n关于 $\\lambda$ 的梯度是：\n$$\n\\nabla_\\lambda \\mathcal{L}(x, \\lambda) = h - Gx\n$$\n将此梯度设为零，恢复了必须在最优点满足的原始约束方程：\n$$\nGx^* = h \\quad (2)\n$$\n为了找到一个可计算实现的系统，我们通过将方程 $(1)$ 代入方程 $(2)$ 来消去原始变量 $x^*$：\n$$\nG(G^\\top \\lambda) = h\n$$\n这导致一个关于拉格朗日乘子 $\\lambda$ 的方形线性系统：\n$$\n(G G^\\top) \\lambda = h\n$$\n矩阵 $K = G G^\\top \\in \\mathbb{R}^{(m+p) \\times (m+p)}$ 是 $G$ 的行向量的格拉姆矩阵。如果 $G$ 的行是线性无关的，则 $G$ 具有满行秩，并且 $G G^\\top$ 是可逆的。在这种情况下，我们可以直接解出 $\\lambda$：\n$$\n\\lambda = (G G^\\top)^{-1} h\n$$\n将此结果代回方程 $(1)$，得到最小长度解 $x^*$ 的显式公式：\n$$\nx^* = G^\\top (G G^\\top)^{-1} h\n$$\n矩阵 $G^\\dagger = G^\\top (G G^\\top)^{-1}$ 是 $G$ 的右摩尔-彭若斯伪逆。对于数值实现，特别是在 $G$ 的行可能线性相关的情况下（例如，像情况5中的冗余约束），$G G^\\top$ 将是奇异的。一个稳健的方法是使用最小二乘求解器求解系统 $(G G^\\top) \\lambda = h$ 来得到 $\\lambda$。这种方法等价于使用 $G G^\\top$ 的伪逆，并且即使在 $\\lambda$ 不唯一时也能找到一个有效的 $\\lambda$。由于伪逆的性质，最终得到的解 $x^* = G^\\top \\lambda$ 仍然是唯一的。\n\n为了讨论约束矩阵 $C$ 的物理作用，我们可以通过对 $G$ 和 $\\lambda = [\\lambda_A^\\top, \\lambda_C^\\top]^\\top$ 进行分块来分解方程 $(1)$：\n$$\nx^* = \\begin{bmatrix} A^\\top  C^\\top \\end{bmatrix} \\begin{bmatrix} \\lambda_A \\\\ \\lambda_C \\end{bmatrix} = A^\\top \\lambda_A + C^\\top \\lambda_C\n$$\n这表明解 $x^*$ 是两个分量的叠加：一部分 $A^\\top \\lambda_A$ 位于数据约束矩阵 $A$ 的行空间中，另一部分 $C^\\top \\lambda_C$ 位于物理约束矩阵 $C$ 的行空间中。在没有物理约束（$p=0$）的情况下，解将是 $x_{A}^* = A^\\top(AA^\\top)^{-1}b$，这是仅满足数据的最小范数解。项 $C^\\top \\lambda_C$ 是一个最小范数校正，用于调整这个纯数据解，使其也能满足 $Cx=d$ 中编码的物理定律。例如，如果 $C$ 强制执行一个像 $e^\\top x = 0$ 这样的质量守恒原理（其中 $e$ 是一个全1向量），它会迫使解位于一个与 $e$ 正交的子空间中。项 $C^\\top \\lambda_C$ 添加一个常数向量分量（因为 $C^\\top=e$），该分量平移整个解以满足这个零和要求。因此，物理约束主动地塑造了解，引导它偏离纯粹的数据拟合，进入一个与已知物理原理一致的状态，同时对解的范数产生最小的扰动。乘子 $\\lambda_A$ 和 $\\lambda_C$ 的分块系统进一步阐明了这一点：\n$$\n\\begin{bmatrix}\nA A^\\top  A C^\\top \\\\\nC A^\\top  C C^\\top\n\\end{bmatrix}\n\\begin{bmatrix}\n\\lambda_A \\\\\n\\lambda_C\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nb \\\\\nd\n\\end{bmatrix}\n$$\n非对角块 $A C^\\top$ 和 $C A^\\top$ 模型化了数据约束和物理约束之间的耦合和相互作用。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute and print solutions for all test cases.\n    \"\"\"\n\n    def solve_min_length(A, b, C, d):\n        \"\"\"\n        Computes the minimum-length solution x* for the combined linear system\n        A*x = b and C*x = d.\n\n        The solution is derived from the Karush-Kuhn-Tucker (KKT) conditions,\n        which lead to the system (G G^T) lambda = h, where G is the combined\n        constraint matrix and h is the combined right-hand side vector. The\n        final solution is x* = G^T lambda.\n\n        Args:\n            A (np.ndarray): Data constraint matrix.\n            b (np.ndarray): Data constraint vector.\n            C (np.ndarray): Physical constraint matrix.\n            d (np.ndarray): Physical constraint vector.\n\n        Returns:\n            np.ndarray: The minimum-length solution vector x*.\n        \"\"\"\n        # Determine the number of physical constraints.\n        # This handles the case where C is an empty array.\n        p = C.shape[0] if C.ndim > 1 else (1 if C.ndim == 1 and C.size > 0 else 0)\n\n        if p == 0:\n            # Case with no physical constraints (C is empty).\n            G = A\n            h = b.flatten()\n        else:\n            # Combine data and physical constraints into a single system G*x = h.\n            G = np.vstack((A, C))\n            h = np.concatenate((b.flatten(), d.flatten()))\n\n        # Form the KKT matrix K = G * G^T.\n        K = G @ G.T\n\n        # Solve K * lambda = h for the Lagrange multipliers lambda.\n        # We use np.linalg.lstsq for numerical stability, especially for\n        # cases with redundant constraints where K is singular. lstsq finds\n        # a valid (minimum-norm) solution for lambda.\n        lambda_vec, _, _, _ = np.linalg.lstsq(K, h, rcond=None)\n\n        # Compute the final minimum-length solution x* = G^T * lambda.\n        x_star = G.T @ lambda_vec\n\n        return x_star\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1.0, 0.0, -1.0, 2.0, 0.0],\n                [0.0, 1.0, 2.0, -1.0, 1.0]\n            ]),\n            \"b\": np.array([1.0, -2.0]),\n            \"C\": np.array([[1.0, 1.0, 1.0, 1.0, 1.0]]),\n            \"d\": np.array([0.0])\n        },\n        {\n            \"A\": np.array([\n                [2.0, -1.0, 0.0, 1.0, 3.0],\n                [0.0, 1.0, -2.0, 1.0, 0.0],\n                [1.0, 0.0, 1.0, 0.0, -1.0]\n            ]),\n            \"b\": np.array([4.0, 0.0, 1.0]),\n            \"C\": np.empty((0, 5)), # Case with p=0\n            \"d\": np.empty(0)\n        },\n        {\n            \"A\": np.array([\n                [1.0, -1.0, 0.0, 0.0, 0.0],\n                [0.0, 1.0, -1.0, 0.0, 0.0]\n            ]),\n            \"b\": np.array([0.0, 0.0]),\n            \"C\": np.array([[1.0, 1.0, 1.0, 1.0, 1.0]]),\n            \"d\": np.array([1.0])\n        },\n        {\n            \"A\": np.array([\n                [1.0, 0.0, -1.0, 2.0, 0.0],\n                [0.0, 1.0, 2.0, -1.0, 1.0]\n            ]),\n            \"b\": np.array([1.0, -2.0]),\n            \"C\": np.array([\n                [1.0, 1.0, 1.0, 1.0, 1.0],\n                [0.0, 1.0, 2.0, 3.0, 4.0]\n            ]),\n            \"d\": np.array([0.0, 0.0])\n        },\n        {\n            \"A\": np.array([[1.0, 0.0, -1.0, 0.0]]),\n            \"b\": np.array([0.0]),\n            \"C\": np.array([\n                [1.0, 1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0, 2.0]\n            ]),\n            \"d\": np.array([1.0, 2.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x_star = solve_min_length(case[\"A\"], case[\"b\"], case[\"C\"], case[\"d\"])\n        # Round the solution vector to 6 decimal places and convert to a list.\n        x_rounded = np.round(x_star, 6).tolist()\n        results.append(x_rounded)\n    \n    # Format the final output string as a list of Python-style lists,\n    # as required by the problem statement.\n    # `map(str, results)` converts each inner list to its string representation.\n    # Example: [1.0, -2.5] becomes '[1.0, -2.5]'\n    # `','.join(...)` concatenates these strings with commas.\n    # The outer `f\"[{...}]\"` wraps the whole thing in brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}