{
    "hands_on_practices": [
        {
            "introduction": "求解线性系统 $d = Gm$ 是许多反问题的基石。然而，在实际问题中，矩阵 $G$ 的性质千差万别，可能导致超定、欠定或病态系统。本节的第一个动手实践将要求你计算并比较这些不同情况下的普通最小二乘解，从而帮助你直观地理解实践中遇到的挑战以及现代数值方法的稳健性。",
            "id": "3608201",
            "problem": "考虑一个计算地球物理学中的线性反演问题，其中观测数据向量 $d \\in \\mathbb{R}^{m}$ 通过一个线性正演算子（设计矩阵）$G \\in \\mathbb{R}^{m \\times n}$ 与模型参数向量 $m \\in \\mathbb{R}^{n}$ 相关联。其基础是线性数据关系 $d = G m + \\varepsilon$ 和寻求一个模型 $m^{\\star}$ 以最小化残差范数的平方 $\\lVert G m - d \\rVert_{2}^{2}$ 的普通最小二乘准则。由于归一化，所有量都是无量纲的，因此没有物理单位适用。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 对于每个指定的测试用例 $(G_i, d_i)$，计算普通最小二乘解 $m_i^{\\star}$。\n- 量化残差范数 $\\lVert G_i m_i^{\\star} - d_i \\rVert_{2}$ 和模型范数 $\\lVert m_i^{\\star} \\rVert_{2}$。\n- 按照下面指定的精确格式生成最终输出。\n\n程序必须对 $G$ 可能是超定、欠定、秩亏或病态的情况具有鲁棒性，并计算一个在欧几里得意义上最小化残差范数的解。\n\n测试套件：\n1. 超定、满列秩情况：\n   $$ G_1 = \\begin{bmatrix} 1  0.5 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix}, \\quad d_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 0 \\end{bmatrix}. $$\n2. 超定、秩亏情况（第三列等于前两列之和）：\n   $$ G_2 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix}, \\quad d_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix}. $$\n3. 欠定情况：\n   $$ G_3 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad d_3 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}. $$\n4. 病态情况（列向量近似共线）：\n   $$ G_4 = \\begin{bmatrix} 1  1 \\\\ 1  1 + 10^{-8} \\\\ 1  -10^{-8} \\end{bmatrix}, \\quad d_4 = \\begin{bmatrix} 2 \\\\ 2 + 10^{-8} \\\\ 10^{-8} \\end{bmatrix}. $$\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，你的程序必须输出列表\n$$ [m_{i,1}^{\\star}, m_{i,2}^{\\star}, \\ldots, m_{i,n}^{\\star}, \\lVert G_i m_i^{\\star} - d_i \\rVert_{2}, \\lVert m_i^{\\star} \\rVert_{2}], $$\n并严格遵循此顺序。将这四个列表聚合为单行输出，形式为用方括号括起来的逗号分隔列表。你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，不含空格，例如：\n$$ [[\\cdots],[\\cdots],[\\cdots],[\\cdots]]. $$\n\n不允许外部输入；所有数据必须在程序内硬编码。最终输出为实数（浮点数）。",
            "solution": "该问题要求计算一系列形式为 $d = Gm$ 的线性反演问题的普通最小二乘解 $m^{\\star}$，该解能最小化残差的欧几里得范数 $\\lVert G m - d \\rVert_{2}$。该问题需要针对代表超定、秩亏、欠定和病态系统的四种不同情况进行求解。\n\n### 步骤1：提取给定信息\n\n基本关系由以下线性系统给出：\n$d = G m + \\varepsilon$，其中 $d \\in \\mathbb{R}^{m}$ 是数据向量，$m \\in \\mathbb{R}^{n}$ 是模型参数向量，$G \\in \\mathbb{R}^{m \\times n}$ 是正演算子（设计矩阵），$\\varepsilon$ 代表噪声或误差。\n\n目标是找到 $m^{\\star}$，以解决普通最小二乘（OLS）问题：\n$$ m^{\\star} = \\arg\\min_{m \\in \\mathbb{R}^n} \\lVert G m - d \\rVert_{2}^{2} $$\n\n测试套件提供了四个具体的实例 $(G_i, d_i)$：\n\n1.  **情况1（超定，满列秩）：**\n    $$ G_1 = \\begin{bmatrix} 1  0.5 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix}, \\quad d_1 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 0 \\end{bmatrix} $$\n\n2.  **情况2（超定，秩亏）：**\n    $$ G_2 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\end{bmatrix}, \\quad d_2 = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\end{bmatrix} $$\n\n3.  **情况3（欠定）：**\n    $$ G_3 = \\begin{bmatrix} 1  0  1 \\\\ 0  1  1 \\end{bmatrix}, \\quad d_3 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} $$\n\n4.  **情况4（病态）：**\n    $$ G_4 = \\begin{bmatrix} 1  1 \\\\ 1  1 + 10^{-8} \\\\ 1  -10^{-8} \\end{bmatrix}, \\quad d_4 = \\begin{bmatrix} 2 \\\\ 2 + 10^{-8} \\\\ 10^{-8} \\end{bmatrix} $$\n\n对于每种情况，所需的输出是解向量 $m_i^{\\star}$ 的分量、残差范数 $\\lVert G_i m_i^{\\star} - d_i \\rVert_{2}$ 和模型范数 $\\lVert m_i^{\\star} \\rVert_{2}$。\n\n### 步骤2：使用提取的信息进行验证\n\n-   **科学上合理：** 该问题是经典的线性最小二乘问题，是线性代数、数值分析、统计学以及包括计算地球物理学在内的众多STEM领域中的一个基本概念。它没有任何科学或事实上的不健全之处。\n-   **适定：** 问题要求“那个”普通最小二乘解。对于解不唯一的情况（欠定或秩亏系统），存在一个唯一的解，它不仅最小化残差范数，而且在所有可能的解中具有最小的欧几里得范数 $\\lVert m^{\\star} \\rVert_{2}$。这是标准的最小范数最小二乘解。在这种标准解释下，问题对于所有给定的情况都是适定的。\n-   **客观：** 问题使用精确的数学定义和客观的数值数据进行陈述。没有主观或含糊不清的语言。\n\n该问题是自包含的，提供了所有必要的数据。所选的不同情况能很好地测试求解方法的鲁棒性。在归一化系统内，数值是物理上合理的。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。将开发一个解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是找到一个向量 $m^{\\star}$，使目标函数 $J(m) = \\lVert G m - d \\rVert_{2}^{2}$ 最小化。这个二次函数的最小值在其梯度相对于 $m$ 为零的地方找到。\n$$ \\nabla_m J(m) = \\nabla_m \\left( (G m - d)^T (G m - d) \\right) = \\nabla_m \\left( m^T G^T G m - 2d^T G m + d^T d \\right) = 2 G^T G m - 2 G^T d $$\n令梯度为零，得到**正规方程组**：\n$$ (G^T G) m = G^T d $$\n\n如果矩阵 $G^T G \\in \\mathbb{R}^{n \\times n}$ 可逆（当且仅当 $G$ 具有满列秩，即线性无关的列时成立），则存在唯一解：\n$$ m^{\\star} = (G^T G)^{-1} G^T d $$\n这适用于超定、满秩情况（情况1）。然而，这种方法对于其他情况存在问题：\n-   如果 $G$ 是秩亏或欠定的（情况2和3），$G^T G$ 是奇异的，其逆不存在。\n-   如果 $G$ 是病态的（情况4），$G^T G$ 的病态程度更高，因为其条件数是 $G$ 条件数的平方，即 $\\kappa(G^T G) = (\\kappa(G))^2$。直接解正规方程组可能导致较大的数值误差。\n\n需要一种更通用且数值上鲁棒的方法，能够统一处理所有情况。**奇异值分解（SVD）**提供了这样一种方法。任何矩阵 $G \\in \\mathbb{R}^{m \\times n}$ 都可以分解为：\n$$ G = U \\Sigma V^T $$\n其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵（$U^T U = I_m$, $V^T V = I_n$），$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，包含非负奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_r > 0$，其中 $r = \\text{rank}(G)$。\n\n使用SVD，可以定义 $G$ 的**Moore-Penrose伪逆**：\n$$ G^{\\dagger} = V \\Sigma^{\\dagger} U^T $$\n其中 $\\Sigma^{\\dagger} \\in \\mathbb{R}^{n \\times m}$ 是通过取 $\\Sigma^T$ 对角线上非零奇异值的倒数得到的。\n\n对于任何线性系统 $Gm=d$，唯一的最小范数最小二乘解由下式给出：\n$$ m^{\\star} = G^{\\dagger} d $$\n这个解 $m^{\\star}$ 的特性是，它最小化了 $\\lVert G m - d \\rVert_{2}$，并且在所有达到该最小值的向量中，$m^{\\star}$ 是欧几里得范数 $\\lVert m \\rVert_{2}$ 最小的一个。这种方法可以正确且鲁棒地处理所有四个提供的测试用例。\n\n实现将利用一个高质量的数值库函数 `scipy.linalg.lstsq`，该函数基于SVD或类似的鲁棒分解来为每种情况计算 $m^{\\star}$。随后，将直接计算残差范数 $\\lVert G m^{\\star} - d \\rVert_{2}$ 和模型范数 $\\lVert m^{\\star} \\rVert_{2}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves a set of linear inverse problems using ordinary least squares,\n    calculates model and residual norms, and formats the output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    G1 = np.array([\n        [1.0, 0.5],\n        [0.0, 1.0],\n        [1.0, -1.0]\n    ])\n    d1 = np.array([1.0, 2.0, 0.0])\n\n    G2 = np.array([\n        [1.0, 0.0, 1.0],\n        [0.0, 1.0, 1.0],\n        [1.0, 1.0, 2.0]\n    ])\n    d2 = np.array([1.0, 2.0, 3.0])\n\n    G3 = np.array([\n        [1.0, 0.0, 1.0],\n        [0.0, 1.0, 1.0]\n    ])\n    d3 = np.array([1.0, 1.0])\n\n    h = 1e-8\n    G4 = np.array([\n        [1.0, 1.0],\n        [1.0, 1.0 + h],\n        [1.0, -h]\n    ])\n    d4 = np.array([2.0, 2.0 + h, h])\n\n    test_cases = [\n        (G1, d1),\n        (G2, d2),\n        (G3, d3),\n        (G4, d4)\n    ]\n\n    all_results = []\n    # Set a high precision for numpy printing for consistency.\n    # Note: This only affects the string conversion, not the calculations.\n    np.set_printoptions(precision=15, suppress=True)\n\n    for G, d in test_cases:\n        # Use scipy.linalg.lstsq to find the minimum-norm least-squares solution.\n        # This method is robust for all cases (over/underdetermined, rank-deficient).\n        # cond=None uses machine epsilon for cutoff, as recommended.\n        m_star = linalg.lstsq(G, d, cond=None)[0]\n\n        # Calculate the residual vector and its L2-norm.\n        residual_vector = G @ m_star - d\n        residual_norm = np.linalg.norm(residual_vector)\n\n        # Calculate the L2-norm of the model vector.\n        model_norm = np.linalg.norm(m_star)\n\n        # Combine results into a single list for this case.\n        case_result = list(m_star) + [residual_norm, model_norm]\n        all_results.append(case_result)\n\n    # Format the final output as a string representation of a list of lists.\n    # The str() function on a list automatically creates the bracketed format.\n    output_str = \"[\" + \",\".join(map(str, all_results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "找到一个解是一回事，但理解解的唯一性和不确定性在科学反演中至关重要。奇异值分解（SVD）是一个强大的工具，它能揭示模型空间的根本结构，将其分解为数据可以约束的部分（行空间）和完全无法约束的部分（零空间）。在这个练习中，你将使用 SVD 来计算这些关键子空间的正交基，并数值验证它们的基本性质，从而对模型解的模糊性建立具体的认识。",
            "id": "3608192",
            "problem": "考虑计算地球物理学中的线性正演模型，其中数据向量 $d \\in \\mathbb{R}^m$ 通过线性算子 $G \\in \\mathbb{R}^{m \\times n}$ 与模型向量 $m \\in \\mathbb{R}^n$ 相关联，关系式为 $d = G m$。在线性反演问题的分析中，理解零空间 $\\mathcal{N}(G)$ 和转置的像空间 $\\mathcal{R}(G^\\top)$ 的结构对于量化模型非唯一性和数据可分辨方向至关重要。您的任务是使用奇异值分解 (SVD) 计算 $\\mathcal{N}(G)$ 和 $\\mathcal{R}(G^\\top)$ 的标准正交基，并对几个测试用例验证秩-零度定理 $n = \\mathrm{rank}(G) + \\dim \\mathcal{N}(G)$。仅使用定义和基本结果：$\\mathcal{N}(G) = \\{ x \\in \\mathbb{R}^n : G x = 0 \\}$，$\\mathcal{R}(G^\\top)$ 是 $G^\\top$ 的列空间（等价于 $G$ 的行空间），SVD 将 $G$ 分解为 $G = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个对角（可能为矩形）矩阵，其对角线上的元素为非负奇异值。\n\n将数值秩 $\\mathrm{rank}(G)$ 定义为严格大于阈值 $t$ 的奇异值的数量，阈值 $t$ 选择为 $t = \\max(m, n) \\, \\epsilon \\, \\sigma_{\\max}$，其中 $\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是 $G$ 的最大奇异值。使用此秩，从与小于或等于 $t$ 的奇异值相关联的右奇异向量构造 $\\mathcal{N}(G)$ 的标准正交基，并从与大于 $t$ 的奇异值相关联的右奇异向量构造 $\\mathcal{R}(G^\\top)$ 的标准正交基。然后验证秩-零度定理，并通过计算这两个子空间的基向量之间内积矩阵的最大绝对值元素，来数值上检验 $\\mathcal{N}(G)$ 和 $\\mathcal{R}(G^\\top)$ 之间的正交性。\n\n使用以下矩阵 $G$ 的测试套件，每个矩阵都为探究计算的不同方面而指定：\n\n- 情况 1（秩亏矩形矩阵，通过乘积构造以强制降低秩）：设\n$$\nA_1 = \\begin{bmatrix}\n1  0  2  -1 \\\\\n0  1  1  2 \\\\\n1  1  0  0 \\\\\n2  -1  1  1 \\\\\n0  0  1  -1\n\\end{bmatrix} \\in \\mathbb{R}^{5 \\times 4}, \\quad\nB_1 = \\begin{bmatrix}\n1  2  0  -1  0  3  1 \\\\\n0  1  1  0  2  0  -2 \\\\\n2  0  -1  1  1  1  0 \\\\\n-1  1  2  0  -1  0  1\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 7},\n$$\n并定义 $G_1 = A_1 B_1 \\in \\mathbb{R}^{5 \\times 7}$。\n\n- 情况 2（方阵，满秩，良态，对角矩阵）：设\n$$\nG_2 = \\mathrm{diag}(3, 2, 1, 4, 5, 6) \\in \\mathbb{R}^{6 \\times 6}.\n$$\n\n- 情况 3（具有非平凡零空间的宽矩阵，通过乘积构造以强制秩最多为 2）：设\n$$\nA_2 = \\begin{bmatrix}\n1  2 \\\\\n-1  0 \\\\\n0  1\n\\end{bmatrix} \\in \\mathbb{R}^{3 \\times 2}, \\quad\nB_2 = \\begin{bmatrix}\n2  -1  0  1  3 \\\\\n1  0  2  -2  -1\n\\end{bmatrix} \\in \\mathbb{R}^{2 \\times 5},\n$$\n并定义 $G_3 = A_2 B_2 \\in \\mathbb{R}^{3 \\times 5}$。\n\n- 情况 4（方阵，病态，具有临界奇异值，对角矩阵）：设\n$$\nG_4 = \\mathrm{diag}(1, 10^{-8}, 10^{-17}, 0) \\in \\mathbb{R}^{4 \\times 4}.\n$$\n\n对于每种情况，计算：\n- 使用上述定义的阈值 $t$ 计算的整数 $\\mathrm{rank}(G)$。\n- 作为为零空间基选择的右奇异向量数量的整数 $\\dim \\mathcal{N}(G)$。\n- 整数 $n$（$G$ 的列数）。\n- 一个布尔值，指示 $n = \\mathrm{rank}(G) + \\dim \\mathcal{N}(G)$ 是否成立。\n- 一个浮点数，等于零空间基的列与 $\\mathcal{R}(G^\\top)$ 基的列之间的内积矩阵的最大绝对值元素（这量化了数值正交性；值越低表示正交性越好）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一项。每一项本身都是一个列表，顺序为 $[\\mathrm{rank}(G), \\dim \\mathcal{N}(G), n, \\text{valid}, \\text{orth}]$，例如 $[[r_1,k_1,n_1,\\text{valid}_1,\\text{orth}_1],[r_2,k_2,n_2,\\text{valid}_2,\\text{orth}_2],\\dots]$。此问题不涉及物理单位；所有计算都是无量纲的。",
            "solution": "该问题要求利用给定矩阵 $G$ 的奇异值分解 (SVD) 计算其零空间 $\\mathcal{N}(G)$ 和转置的像空间 $\\mathcal{R}(G^\\top)$ 的标准正交基。此外，我们必须验证秩-零度定理，并对几个测试用例评估所计算基的数值正交性。\n\n数据向量 $d \\in \\mathbb{R}^m$ 与模型向量 $m \\in \\mathbb{R}^n$ 之间的关系由线性正演模型 $d = G m$ 给出，其中 $G \\in \\mathbb{R}^{m \\times n}$ 是正演算子。该系统性质的分析依赖于对与 $G$ 相关的四个基本子空间的理解。本问题重点关注模型空间 $\\mathbb{R}^n$ 的两个子空间：零空间 $\\mathcal{N}(G)$ 和行空间，行空间等价于转置的像空间 $\\mathcal{R}(G^\\top)$。\n\n零空间定义为 $\\mathcal{N}(G) = \\{ x \\in \\mathbb{R}^n : G x = 0 \\}$。它代表了模型空间中对数据不可见的部分，导致反演问题的非唯一性。\n转置的像空间 $\\mathcal{R}(G^\\top)$ 是由 $G^\\top$ 的列（或 $G$ 的行）张成的 $\\mathbb{R}^n$ 的子空间。它代表了模型空间中可以被数据约束的部分。线性代数的一个基本结果是，这两个子空间在 $\\mathbb{R}^n$ 中是正交补，意味着 $\\mathbb{R}^n$ 中的任何向量都可以唯一地分解为一个在 $\\mathcal{R}(G^\\top)$ 中的分量和一个在 $\\mathcal{N}(G)$ 中的分量，并且任何来自 $\\mathcal{R}(G^\\top)$ 的向量与任何来自 $\\mathcal{N}(G)$ 的向量的内积为零。这意味着 $\\mathbb{R}^n = \\mathcal{R}(G^\\top) \\oplus \\mathcal{N}(G)$。秩-零度定理是一个直接推论，它指出这些子空间的维数之和等于总空间的维数：$\\dim(\\mathcal{R}(G^\\top)) + \\dim(\\mathcal{N}(G)) = n$。由于 $\\mathrm{rank}(G) = \\dim(\\mathcal{R}(G^\\top))$，该定理通常写作 $\\mathrm{rank}(G) + \\dim(\\mathcal{N}(G)) = n$。\n\n奇异值分解 (SVD) 为计算这些子空间的稳定标准正交基提供了一个强大的工具。$G$ 的 SVD 是分解 $G = U \\Sigma V^\\top$，其中：\n- $U \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，其列 $u_i$ 是左奇异向量。\n- $V \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其列 $v_i$ 是右奇异向量。\n- $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其对角线上的非负实数 $\\sigma_i$ 称为奇异值，按非递增顺序排列：$\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$。\n\n设 $G$ 的秩为 $r$。这意味着有 $r$ 个非零奇异值。SVD 如下揭示了基本子空间的基：\n- $V$ 的前 $r$ 列 $\\{v_1, \\dots, v_r\\}$ 构成了 $G^\\top$ 的像空间 $\\mathcal{R}(G^\\top)$ 的一个标准正交基。\n- $V$ 的剩余 $n-r$ 列 $\\{v_{r+1}, \\dots, v_n\\}$ 构成了 $G$ 的零空间 $\\mathcal{N}(G)$ 的一个标准正交基。这是因为对于 $i > r$，$\\sigma_i = 0$，这意味着 $G v_i = U \\Sigma V^\\top v_i = U \\Sigma e_i = \\sigma_i u_i = 0$。\n\n在数值计算中，由于浮点误差，本应为零的奇异值可能会表现为非常小的非零数。因此，必须使用阈值来定义数值秩。问题指定了一个阈值 $t = \\max(m, n) \\, \\epsilon \\, \\sigma_{\\max}$，其中 $\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是 $G$ 的最大奇异值。数值秩（我们也用 $r$ 表示）是严格大于 $t$ 的奇异值 $\\sigma_i$ 的数量。\n\n每个测试用例的步骤如下：\n1.  给定一个矩阵 $G \\in \\mathbb{R}^{m \\times n}$，计算其 SVD 以获得奇异值 $s$ 和右奇异向量矩阵 $V$。\n2.  确定最大奇异值 $\\sigma_{\\max} = s_1$。\n3.  计算阈值 $t = \\max(m, n) \\cdot \\epsilon \\cdot \\sigma_{\\max}$。\n4.  计算数值秩 $r$ 为奇异值 $s_i > t$ 的数量。\n5.  $\\mathcal{R}(G^\\top)$ 的基由 $V$ 的前 $r$ 列组成。\n6.  $\\mathcal{N}(G)$ 的基由 $V$ 的后 $n-r$ 列组成。因此，零空间的维数为 $\\dim \\mathcal{N}(G) = n-r$。\n7.  通过检查等式 $n = r + (n-r)$ 是否成立来验证秩-零度定理。根据我们的构造，这将始终评估为 `True`。\n8.  数值上验证 $\\mathcal{R}(G^\\top)$ 和 $\\mathcal{N}(G)$ 之间的正交性。这通过构建两个子空间基向量之间的内积矩阵来完成。设 $V_{\\mathcal{R}}$ 是其列为 $\\mathcal{R}(G^\\top)$ 基的矩阵，$V_{\\mathcal{N}}$ 是 $\\mathcal{N}(G)$ 的矩阵。内积矩阵是 $C = V_{\\mathcal{R}}^\\top V_{\\mathcal{N}}$。因为 $V$ 的列是标准正交的，所以理论上 $C$ 的所有元素都应为零。我们计算 $C$ 中元素的最大绝对值 $\\max(|C_{ij}|)$，作为数值正交性的度量。接近零的值表示数值正交性高。如果其中一个子空间是平凡的（即其维数为 $0$），则正交性不言自明地成立，最大内积定义为 $0$。\n\n将此过程应用于所提供的四个测试矩阵中的每一个，并汇编结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes properties of fundamental subspaces for a suite of test matrices.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [1, 0, 2, -1],\n        [0, 1, 1, 2],\n        [1, 1, 0, 0],\n        [2, -1, 1, 1],\n        [0, 0, 1, -1]\n    ], dtype=float)\n\n    B1 = np.array([\n        [1, 2, 0, -1, 0, 3, 1],\n        [0, 1, 1, 0, 2, 0, -2],\n        [2, 0, -1, 1, 1, 1, 0],\n        [-1, 1, 2, 0, -1, 0, 1]\n    ], dtype=float)\n    G1 = A1 @ B1\n\n    G2 = np.diag([3.0, 2.0, 1.0, 4.0, 5.0, 6.0])\n\n    A2 = np.array([\n        [1, 2],\n        [-1, 0],\n        [0, 1]\n    ], dtype=float)\n\n    B2 = np.array([\n        [2, -1, 0, 1, 3],\n        [1, 0, 2, -2, -1]\n    ], dtype=float)\n    G3 = A2 @ B2\n\n    G4 = np.diag([1.0, 1e-8, 1e-17, 0.0])\n\n    test_cases = [G1, G2, G3, G4]\n    \n    results = []\n    \n    for G in test_cases:\n        m, n = G.shape\n\n        if n == 0:\n            # Handle matrices with no columns, null space dim is 0, rank is 0.\n            results.append([0, 0, 0, True, 0.0])\n            continue\n        \n        # Compute SVD\n        try:\n            U, s, Vh = np.linalg.svd(G)\n        except np.linalg.LinAlgError:\n            # Handle potential SVD failures, although unlikely for these cases\n            # This path is not expected to be taken with the given inputs.\n            continue\n\n        # Get matrix of right singular vectors\n        V = Vh.T\n\n        # Machine epsilon for the data type of G\n        eps = np.finfo(G.dtype).eps\n        \n        # Determine the numerical rank\n        sigma_max = s[0] if s.size > 0 else 0\n        \n        # If the matrix is the zero matrix, rank is 0. Threshold would be 0.\n        if sigma_max == 0:\n            rank = 0\n        else:\n            threshold = max(m, n) * eps * sigma_max\n            rank = np.sum(s > threshold)\n            \n        dim_null_space = n - rank\n        \n        # Verify Rank-Nullity Theorem: n = rank(G) + dim(N(G))\n        # By construction, this will always be true.\n        rank_nullity_valid = (n == rank + dim_null_space)\n        \n        # Check orthogonality of subspaces\n        # Basis for R(G^T) are the first 'rank' columns of V\n        # Basis for N(G) are the last 'n - rank' columns of V\n        if rank == 0 or rank == n:\n            # If one subspace is trivial, orthogonality holds vacuously.\n            orthogonality_check = 0.0\n        else:\n            V_range = V[:, :rank]\n            V_null = V[:, rank:]\n            inner_products = V_range.T @ V_null\n            orthogonality_check = np.max(np.abs(inner_products))\n        \n        results.append([rank, dim_null_space, n, rank_nullity_valid, orthogonality_check])\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list of lists matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在，我们将所有概念融会贯通，应用于一个经典的地球物理问题：二维层析成像的分辨率测试。“棋盘测试”是评估特定观测几何与反演算法对地下结构解析能力的常用方法。这个综合性练习将指导你从零开始构建反演问题的各个组成部分——正演算子、正则化算子和合成数据——并最终评估正则化对恢复已知模型的实际影响。",
            "id": "3608136",
            "problem": "您的任务是构建和评估一个经典的棋盘格分辨率测试，该测试针对计算地球物理学中代表走时层析成像的二维（$2$-D）线性反演问题。正演模型是线性的，数据是沿直线射线的线积分，反演问题采用零阶和二阶吉洪诺夫（Tikhonov）正则化方法求解。您的目标是实现一个完整的程序，该程序能针对几组参数集，建立模型，通过正演算子模拟数据，求解具有指定正则化强度的反演问题，并定量地将恢复的模型与真实棋盘格模型进行比较以评估分辨率。\n\n从以下基本原理出发：数据 $d$、正演算子 $G$、模型 $m$ 和噪声 $\\epsilon$ 之间的线性正演关系 $d = G m + \\epsilon$；以及通过最小化二次型失配来选择 $m$ 的最小二乘原理。您必须使用吉洪诺夫（Tikhonov）正则化，它通过一个形式为 $\\lambda^{2} \\lVert L m \\rVert_{2}^{2}$ 的稳定项来增强失配函数，其中 $\\lambda \\ge 0$ 是一个标量权衡参数，$L$ 是一个编码先验期望的离散算子（对于二阶平滑度，请在网格上使用 $5$ 点离散拉普拉斯算子）。不要假设任何特定的解公式；相反，应系统地构建离散算子，并通过将二次型目标函数的导数设为零来推导出待解的线性系统。\n\n详细要求：\n\n- 模型网格和棋盘格：\n  - 使用一个包含 $n_{x} \\times n_{y}$ 个单元格的矩形网格，并按行主序索引为一个向量 $m \\in \\mathbb{R}^{n_{x} n_{y}}$。\n  - 构建一个振幅为 $1$、均值为零的棋盘格模型 $m_{\\mathrm{true}}$，其方形瓦片边长为 $s$ 个单元格。即，以 $s \\times s$ 的块大小交替出现 $+1$ 和 $-1$ 的块。在计算比较指标时，确保模型是均值中心化的。\n- 正演算子 $G$ (射线路径和):\n  - 模拟与选定行和列的线积分相对应的、沿坐标轴的直线射线。每条水平射线对应于沿整行对模型值求和；每条垂直射线则沿整列求和。使用步长参数 $q \\in \\mathbb{N}$，从第一行和第一列开始，包含每第 $q$ 行和每第 $q$ 列。对于行索引为 $i$ 的水平射线，$G$ 的对应行应在所有位于行 $i$ 的单元格 $j$ 处具有条目 $G_{k,j} = 1$，而在其他地方为 $G_{k,j} = 0$。对于列索引为 $j$ 的垂直射线，情况类似。\n  - 构造数据 $d = G m_{\\mathrm{true}} + \\epsilon$，其中 $\\epsilon$ 是标准差为 $\\sigma$ 的零均值高斯噪声。每个测试用例使用固定的随机种子以确保可复现性。\n- 反演问题：\n  - 求解最小化目标函数 $\\Phi(m) = \\lVert G m - d \\rVert_{2}^{2} + \\lambda^{2} \\lVert L m \\rVert_{2}^{2}$ 的吉洪诺夫正则化最小二乘问题，其中 $L$ 是 $n_{x} \\times n_{y}$ 网格上的 $5$ 点离散拉普拉斯算子，采用自然边界处理（边界上的邻居较少）。对于 $\\lambda = 0$ 的情况，求解非正则化最小二乘问题。对于 $\\lambda > 0$ 的情况，将梯度设为零，并求解得到的对称正定线性系统。\n- 分辨率评估指标：\n  - 计算恢复模型 $m_{\\mathrm{est}}$ 与真实模型 $m_{\\mathrm{true}}$ 之间的中心化余弦相似度（相关性）：$r = \\dfrac{(m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}})^{\\mathsf{T}} (m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}})}{\\lVert m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}} \\rVert_{2} \\, \\lVert m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}} \\rVert_{2}}$，其中上划线表示均值。这将产生一个在 $[-1,1]$ 区间内的标量，用以指示模式恢复的质量。\n- 单位：本练习中所有量均为无量纲；无需物理单位。\n- 角度单位：不适用。\n- 数值输出：对于每个测试用例，输出标量相关性 $r$，形式为保留三位小数的浮点数。\n\n测试套件（为以下每组参数提供结果）：\n- 案例 $1$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.5, 0.0, 2)$。\n- 案例 $2$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.0, 0.0, 2)$。\n- 案例 $3$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 5.0, 0.0, 2)$。\n- 案例 $4$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 2, 0.5, 0.0, 2)$。\n- 案例 $5$：$(n_{x}, n_{y}, s, \\lambda, \\sigma, q) = (16, 16, 4, 0.5, 0.05, 2)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_{1},r_{2},r_{3},r_{4},r_{5}]$），其中每个 $r_{i}$ 都四舍五入到三位小数。\n- 程序必须是完全自包含的，不接受任何输入，并且仅使用指定的 Python 运行时和库。",
            "solution": "该问题要求针对一个使用吉洪诺夫（Tikhonov）正则化求解的二维（$2$-D）线性反演问题，构建并评估一个棋盘格分辨率测试。这包括几个阶段：定义模型空间和真实模型、构建正演算子、模拟数据、建立并求解正则化反演问题，以及量化模型恢复的质量。\n\n控制正演问题的基本关系是线性方程：\n$$d = G m + \\epsilon$$\n其中 $d \\in \\mathbb{R}^{N_d}$ 是数据向量，$m \\in \\mathbb{R}^{N_m}$ 是模型参数向量，$G \\in \\mathbb{R}^{N_d \\times N_m}$ 是正演算子，$\\epsilon \\in \\mathbb{R}^{N_d}$ 是随机噪声向量。\n\n首先，我们定义模型空间。模型由一个包含 $n_x \\times n_y$ 个单元格的二维矩形网格构成。假设每个单元格内的物理属性是恒定的。这 $N_m = n_x n_y$ 个单元格的值使用行主序索引被展平为一个单独的向量 $m$。一个位于网格坐标 $(i, j)$（其中 $i$ 为行索引，$0 \\le i  n_y$，$j$ 为列索引，$0 \\le j  n_x$）的单元格，对应于向量 $m$ 中的索引 $k = i \\cdot n_x + j$。\n\n真实模型 $m_{\\mathrm{true}}$ 是一个棋盘格图案。对于给定的瓦片边长 $s$，位于 $(i, j)$ 处单元格的值由其瓦片坐标 $(\\lfloor i/s \\rfloor, \\lfloor j/s \\rfloor)$ 决定。该值设为 $(-1)^{p+q}$，其中 $p = \\lfloor i/s \\rfloor$ 且 $q = \\lfloor j/s \\rfloor$，从而产生交替的 $+1$ 和 $-1$ 块。对于指定的测试参数，此构造会产生一个零均值模型。\n\n接下来，我们构建正演算子 $G$。数据采集被建模为沿坐标轴的直线射线路径层析成像。每个数据点对应于沿网格特定行或列的模型参数的线积分（和）。射线以步长 $q$ 进行采样，意味着从第一行和第一列开始，每隔 $q$ 行和每隔 $q$ 列进行一次观测。穿过行 $i$ 的水平射线对应于 $G$ 中的一行，该行在对应网格行的所有模型参数位置上的条目为 $1$，其他位置为 $0$。类似地，穿过列 $j$ 的垂直射线对应于 $G$ 中的一行，该行在对应网格列的所有模型参数位置上的条目为 $1$。数据点总数 $N_d$ 是采样行数和列数之和。\n\n合成数据向量 $d$ 是通过将正演算子应用于真实模型（$d_{\\mathrm{clean}} = G m_{\\mathrm{true}}$），并加上标准差为 $\\sigma$ 的零均值高斯噪声 $\\epsilon$ 来生成的。因此，$d = G m_{\\mathrm{true}} + \\epsilon$。\n\n任务的核心是求解反演问题：给定 $d$ 和 $G$，估计模型 $m$。我们使用吉洪诺夫（Tikhonov）正则化来寻找稳定且有意义的解，尤其是在问题欠定（$N_d \\ll N_m$）的情况下。这通过最小化目标函数 $\\Phi(m)$ 来实现，该函数在数据保真度与期望的模型属性（例如平滑度）之间取得平衡：\n$$\\Phi(m) = \\lVert G m - d \\rVert_{2}^{2} + \\lambda^{2} \\lVert L m \\rVert_{2}^{2}$$\n第一项 $\\lVert G m - d \\rVert_{2}^{2}$ 是数据失配项，衡量模型预测值 $Gm$ 与观测数据 $d$ 的拟合程度。第二项 $\\lambda^{2} \\lVert L m \\rVert_{2}^{2}$ 是正则化项或稳定项。参数 $\\lambda \\ge 0$ 控制着二者之间的权衡。算子 $L$ 对偏离先验期望的模型施加惩罚。此处，$L$ 是 $5$ 点离散拉普拉斯算子，它通过惩罚大的空间二阶导数来强制平滑。\n\n对于对应于网格单元 $(i,j)$ 的模型参数 $m_k$，拉普拉斯算子的作用是 $(Lm)_k = \\sum_{p \\in N(k)} m_p - (\\deg(k)) m_k$，其中 $N(k)$ 是网格上相邻单元格的索引集合，$\\deg(k)$ 是此类邻居的数量（度）。对于内部单元格，$\\deg(k)=4$。对于边界和角落上的单元格，该数量分别为 $3$ 或 $2$。这被称为自然边界条件。矩阵 $L$ 的构造使得其每一行 $k$ 都编码了这个有限差分模板。\n\n为了找到最小化 $\\Phi(m)$ 的模型 $m_{\\mathrm{est}}$，我们计算 $\\Phi(m)$ 关于 $m$ 的梯度并将其设为零：\n$$\\nabla_m \\Phi(m) = \\frac{\\partial}{\\partial m} \\left( (Gm-d)^{\\mathsf{T}}(Gm-d) + \\lambda^2 (Lm)^{\\mathsf{T}}(Lm) \\right) = 0$$\n$$\\nabla_m \\Phi(m) = 2G^{\\mathsf{T}}(Gm-d) + 2\\lambda^2 L^{\\mathsf{T}}Lm = 0$$\n重新整理各项可得到关于 $m$ 的线性方程组，即正规方程：\n$$(G^{\\mathsf{T}}G + \\lambda^2 L^{\\mathsf{T}}L)m = G^{\\mathsf{T}}d$$\n该系统可以求解出 $m$。然而，直接计算乘积 $G^{\\mathsf{T}}G$ 和 $L^{\\mathsf{T}}L$ 可能会增加条件数并导致数值不稳定。一种更稳健的方法是求解一个等价的增广最小二乘问题。最小化 $\\Phi(m)$ 等同于在最小二乘意义下求解以下系统：\n$$ \\begin{pmatrix} G \\\\ \\lambda L \\end{pmatrix} m = \\begin{pmatrix} d \\\\ 0 \\end{pmatrix} $$\n其中向量 $0$ 的维度等于 $L$ 的行数。这种形式在数值上更优越，并且能无缝处理非正则化情况（$\\lambda=0$）。解 $m_{\\mathrm{est}}$ 是使用标准的线性最小二乘求解器找到的。\n\n最后，为了评估恢复的分辨率，我们计算估计模型 $m_{\\mathrm{est}}$ 和真实模型 $m_{\\mathrm{true}}$ 之间的中心化余弦相似度（相关系数）$r$：\n$$r = \\frac{(m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}})^{\\mathsf{T}} (m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}})}{\\lVert m_{\\mathrm{est}} - \\overline{m}_{\\mathrm{est}} \\rVert_{2} \\, \\lVert m_{\\mathrm{true}} - \\overline{m}_{\\mathrm{true}} \\rVert_{2}}$$\n其中 $\\overline{m}$ 表示向量 $m$ 的均值。一个接近 $1$ 的 $r$ 值表示极好的模式恢复效果，而接近 $0$ 或 $-1$ 的值则表示恢复效果差或呈反相关。该指标有效地量化了在给定参数下层析成像反演的成功程度。最终的算法通过对每个指定的测试用例系统地应用这些步骤来执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_checkerboard(nx, ny, s):\n    \"\"\"\n    Constructs a 2D checkerboard model and flattens it to a 1D vector.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n        s (int): Side length of the checkerboard tiles in cells.\n    \n    Returns:\n        np.ndarray: A 1D numpy array representing the true model m_true.\n    \"\"\"\n    x_coords = np.arange(nx)\n    y_coords = np.arange(ny)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    \n    # Determine tile indices for each cell\n    tile_indices_x = np.floor(xx / s)\n    tile_indices_y = np.floor(yy / s)\n    \n    # Create checkerboard pattern (+1 and -1)\n    checkerboard_2d = (-1)**(tile_indices_y + tile_indices_x)\n    \n    # Flatten to 1D vector in row-major order\n    return checkerboard_2d.ravel()\n\ndef build_forward_operator(nx, ny, q):\n    \"\"\"\n    Constructs the forward operator G for axis-aligned ray tomography.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n        q (int): Stride for sampling rows and columns.\n    \n    Returns:\n        np.ndarray: The forward operator matrix G.\n    \"\"\"\n    num_model_params = nx * ny\n    \n    # Identify which rows and columns to sample\n    rows_to_sample = np.arange(0, ny, q)\n    cols_to_sample = np.arange(0, nx, q)\n    num_data = len(rows_to_sample) + len(cols_to_sample)\n    \n    G = np.zeros((num_data, num_model_params))\n    \n    data_idx = 0\n    # Fill rows for horizontal rays\n    for i_row in rows_to_sample:\n        start_idx = i_row * nx\n        end_idx = start_idx + nx\n        G[data_idx, start_idx:end_idx] = 1.0\n        data_idx += 1\n        \n    # Fill rows for vertical rays\n    for j_col in cols_to_sample:\n        indices = j_col + np.arange(ny) * nx\n        G[data_idx, indices] = 1.0\n        data_idx += 1\n        \n    return G\n\ndef build_laplacian(nx, ny):\n    \"\"\"\n    Constructs the 5-point discrete Laplacian operator L with natural boundary conditions.\n    \n    Args:\n        nx (int): Number of cells in the x-dimension.\n        ny (int): Number of cells in the y-dimension.\n    \n    Returns:\n        np.ndarray: The discrete Laplacian matrix L.\n    \"\"\"\n    num_model_params = nx * ny\n    L = np.zeros((num_model_params, num_model_params))\n    \n    for k in range(num_model_params):\n        i = k // nx  # Row index\n        j = k % nx   # Column index\n        \n        neighbors = []\n        # Neighbor above\n        if i > 0: neighbors.append(k - nx)\n        # Neighbor below\n        if i  ny - 1: neighbors.append(k + nx)\n        # Neighbor left\n        if j > 0: neighbors.append(k - 1)\n        # Neighbor right\n        if j  nx - 1: neighbors.append(k + 1)\n            \n        # Set diagonal to - (number of neighbors)\n        L[k, k] = -len(neighbors)\n        # Set off-diagonals to 1 for each neighbor\n        for neighbor_idx in neighbors:\n            L[k, neighbor_idx] = 1.0\n            \n    return L\n\ndef compute_correlation(m_est, m_true):\n    \"\"\"\n    Computes the centered cosine similarity between two model vectors.\n    \n    Args:\n        m_est (np.ndarray): The estimated model vector.\n        m_true (np.ndarray): The true model vector.\n    \n    Returns:\n        float: The correlation coefficient r.\n    \"\"\"\n    # Center the vectors by subtracting their means\n    m_est_centered = m_est - np.mean(m_est)\n    m_true_centered = m_true - np.mean(m_true)\n    \n    # Compute norms of the centered vectors\n    norm_est = np.linalg.norm(m_est_centered)\n    norm_true = np.linalg.norm(m_true_centered)\n    \n    # Avoid division by zero if a vector is constant\n    if norm_est == 0 or norm_true == 0:\n        return 0.0\n        \n    # Compute the dot product and normalize\n    numerator = np.dot(m_est_centered, m_true_centered)\n    denominator = norm_est * norm_true\n    \n    return numerator / denominator\n\ndef run_single_case(params, seed):\n    \"\"\"\n    Runs a single checkerboard test case.\n    \"\"\"\n    nx, ny, s, lam, sig, q = params\n    \n    # 1. Construct true model, forward operator, and Laplacian\n    m_true = build_checkerboard(nx, ny, s)\n    G = build_forward_operator(nx, ny, q)\n    L = build_laplacian(nx, ny)\n    \n    # 2. Generate synthetic data\n    d_clean = G @ m_true\n    if sig > 0:\n        rng = np.random.default_rng(seed=seed)\n        noise = rng.normal(loc=0.0, scale=sig, size=d_clean.shape)\n        d = d_clean + noise\n    else:\n        d = d_clean\n    \n    # 3. Solve the regularized inverse problem\n    num_model_params = nx * ny\n    if lam > 0:\n        # Augmented system for Tikhonov regularization\n        A_aug = np.vstack([G, lam * L])\n        d_aug = np.concatenate([d, np.zeros(num_model_params)])\n        m_est = np.linalg.lstsq(A_aug, d_aug, rcond=None)[0]\n    else:\n        # Unregularized least-squares (minimum norm solution)\n        m_est = np.linalg.lstsq(G, d, rcond=None)[0]\n\n    # 4. Evaluate resolution\n    correlation = compute_correlation(m_est, m_true)\n    \n    return round(correlation, 3)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, 16, 4, 0.5, 0.0, 2),  # Case 1\n        (16, 16, 4, 0.0, 0.0, 2),  # Case 2\n        (16, 16, 4, 5.0, 0.0, 2),  # Case 3\n        (16, 16, 2, 0.5, 0.0, 2),  # Case 4\n        (16, 16, 4, 0.5, 0.05, 2)  # Case 5\n    ]\n    \n    results = []\n    for i, case_params in enumerate(test_cases):\n        # Use a different seed for each case for reproducibility\n        result = run_single_case(case_params, seed=i)\n        results.append(result)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}