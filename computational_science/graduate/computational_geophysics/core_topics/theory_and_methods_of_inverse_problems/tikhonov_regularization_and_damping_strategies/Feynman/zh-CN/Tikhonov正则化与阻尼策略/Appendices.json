{
    "hands_on_practices": [
        {
            "introduction": "这个入门练习旨在帮助您掌握吉洪诺夫正则化的核心机制。我们使用一个简单的 $2 \\times 2$ 线性系统，以便您可以专注于正则化方程本身，而不被复杂的前向算子所困扰。通过系统地改变正则化参数 $\\lambda$、正则化算子 $\\mathbf{L}$ 以及参考模型 $\\mathbf{m}_{\\mathrm{ref}}$，您将直接观察到这些参数如何影响最终解，从而对数据拟合与模型约束之间的权衡建立直观且扎实的基础 。",
            "id": "3617477",
            "problem": "考虑计算地球物理学中的线性反演问题，其中观测数据 $\\mathbf{d} \\in \\mathbb{R}^n$ 通过一个线性正演算子 $\\mathbf{G} \\in \\mathbb{R}^{n \\times p}$ 作用于模型参数 $\\mathbf{m} \\in \\mathbb{R}^p$ 来建模，并带有加性噪声 $\\boldsymbol{\\epsilon}$，即 $\\mathbf{d} = \\mathbf{G}\\mathbf{m} + \\boldsymbol{\\epsilon}$。为了稳定反演过程，引入一个 Tikhonov 正则化目标函数，该函数平衡了数据拟合差和一种阻尼策略：\n$$\nJ(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2 + \\lambda^2 \\|\\mathbf{L}(\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})\\|_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是阻尼（正则化）参数，$\\mathbf{L} \\in \\mathbb{R}^{q \\times p}$ 是一个阻尼（或粗糙度）算子，$\\mathbf{m}_{\\mathrm{ref}} \\in \\mathbb{R}^p$ 是一个参考模型。非正则化最小二乘解是通过单独最小化 $\\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2$ 得到的。\n\n你的任务是针对以下测试套件，计算 Tikhonov 正则化解 $\\mathbf{m}_{\\mathrm{Tik}}$，并将其与非正则化最小二乘解 $\\mathbf{m}_{\\mathrm{LS}}$进行比较。对于每个测试用例，使用欧几里得 $2$-范数计算差异大小 $\\|\\mathbf{m}_{\\mathrm{Tik}} - \\mathbf{m}_{\\mathrm{LS}}\\|_2$。不涉及物理单位。所有计算均以纯数值进行。\n\n测试套件：\n- 用例 1（理想情况，零阶阻尼）：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.2$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- 用例 2（边界条件，无阻尼）：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- 用例 3（强阻尼，零阶）：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 2.0$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- 用例 4（一阶平滑度阻尼）：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.5$, $\\mathbf{L} = \\begin{bmatrix}-1  1\\end{bmatrix}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- 用例 5（向非零参考模型阻尼）：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.5$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0.5\\\\ 0\\end{bmatrix}$.\n\n算法要求：\n- 对于每个用例，通过最小化上述定义的 $J(\\mathbf{m})$ 来计算 $\\mathbf{m}_{\\mathrm{Tik}}$。\n- 使用适用于任意 $\\mathbf{G}$ 的稳健数值方法（例如，Moore–Penrose 伪逆或数值稳定的最小二乘求解器），将 $\\mathbf{m}_{\\mathrm{LS}}$ 计算为非正则化最小二乘解。\n- 对于每个用例，报告 5 个数字：$\\mathbf{m}_{\\mathrm{Tik}}$ 的两个分量、$\\mathbf{m}_{\\mathrm{LS}}$ 的两个分量以及标量 $\\|\\mathbf{m}_{\\mathrm{Tik}} - \\mathbf{m}_{\\mathrm{LS}}\\|_2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例由一个包含五个浮点数的子列表表示，顺序如上所述。例如，输出应如下所示\n$$\n[\\,[m^{(1)}_{\\mathrm{Tik},1},m^{(1)}_{\\mathrm{Tik},2},m^{(1)}_{\\mathrm{LS},1},m^{(1)}_{\\mathrm{LS},2},\\Delta^{(1)}],\\,[m^{(2)}_{\\mathrm{Tik},1},m^{(2)}_{\\mathrm{Tik},2},m^{(2)}_{\\mathrm{LS},1},m^{(2)}_{\\mathrm{LS},2},\\Delta^{(2)}],\\,\\dots\\,]\n$$\n其中 $\\Delta^{(i)} = \\|\\mathbf{m}^{(i)}_{\\mathrm{Tik}} - \\mathbf{m}^{(i)}_{\\mathrm{LS}}\\|_2$。将报告的每个浮点数四舍五入到六位小数。程序不得打印任何额外文本。",
            "solution": "在进行求解之前，需要对问题进行验证。\n\n### 步骤 1：提取已知条件\n问题描述了一个线性反演问题 $\\mathbf{d} = \\mathbf{G}\\mathbf{m} + \\boldsymbol{\\epsilon}$，其中 $\\mathbf{d} \\in \\mathbb{R}^n$，$\\mathbf{G} \\in \\mathbb{R}^{n \\times p}$，$\\mathbf{m} \\in \\mathbb{R}^p$。\nTikhonov 正则化目标函数由下式给出：\n$$\nJ(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2 + \\lambda^2 \\|\\mathbf{L}(\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})\\|_2^2\n$$\n其中 $\\lambda \\ge 0$ 是阻尼参数，$\\mathbf{L} \\in \\mathbb{R}^{q \\times p}$ 是一个阻尼算子，$\\mathbf{m}_{\\mathrm{ref}} \\in \\mathbb{R}^p$ 是一个参考模型。\n\n任务是计算 Tikhonov 正则化解 $\\mathbf{m}_{\\mathrm{Tik}}$ 和非正则化最小二乘解 $\\mathbf{m}_{\\mathrm{LS}}$，以及它们之间差值的欧几里得范数 $\\|\\mathbf{m}_{\\mathrm{Tik}} - \\mathbf{m}_{\\mathrm{LS}}\\|_2$。\n\n测试套件提供以下数据：\n- **用例 1**：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.2$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- **用例 2**：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- **用例 3**：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 2.0$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- **用例 4**：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.5$, $\\mathbf{L} = \\begin{bmatrix}-1  1\\end{bmatrix}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0\\\\ 0\\end{bmatrix}$.\n- **用例 5**：$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$, $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$, $\\lambda = 0.5$, $\\mathbf{L} = \\mathbf{I}_{2 \\times 2}$, $\\mathbf{m}_{\\mathrm{ref}} = \\begin{bmatrix}0.5\\\\ 0\\end{bmatrix}$.\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是线性反演理论和正则化中的一个标准练习，这是计算地球物理学和许多其他科学领域的基石。Tikhonov 正则化框架是一种成熟的基础方法。该问题在科学上是合理的。\n2.  **适定性**：问题提供了计算正则化和非正则化情况下唯一解所需的所有矩阵、向量和参数。目标函数是凸的和二次的，确保存在唯一的极小值点，并且可以通过求解线性方程组找到。\n3.  **客观性**：问题以精确的数学语言陈述，没有歧义或主观性。\n4.  **完整性和一致性**：每个测试用例的所有参数都有明确定义。矩阵和向量的维度对于所有指定的操作都是一致的（例如，对于 $\\mathbf{G} \\in \\mathbb{R}^{2 \\times 2}$ 和 $\\mathbf{m} \\in \\mathbb{R}^2$，$\\mathbf{G}\\mathbf{m}$ 是良定义的）。对于用例 4，$\\mathbf{L} \\in \\mathbb{R}^{1 \\times 2}$ 和 $\\mathbf{m} \\in \\mathbb{R}^2$，因此 $\\mathbf{L}\\mathbf{m}$ 是一个标量，这也是良定义的。\n5.  **无其他缺陷**：该问题并非平凡、不切实际或不适定。它呈现了一个标准的计算任务。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答推导\n\n求解过程需要找到能使两个不同目标函数最小化的模型参数 $\\mathbf{m}$。\n\n**1. 非正则化最小二乘解 ($\\mathbf{m}_{\\mathrm{LS}}$)**\n\n非正则化最小二乘解 $\\mathbf{m}_{\\mathrm{LS}}$ 最小化数据拟合差：\n$$J_{\\mathrm{LS}}(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2$$\n为了找到最小值，我们计算 $J_{\\mathrm{LS}}$ 相对于 $\\mathbf{m}$ 的梯度并将其设为零。\n$$J_{\\mathrm{LS}}(\\mathbf{m}) = (\\mathbf{G}\\mathbf{m} - \\mathbf{d})^T(\\mathbf{G}\\mathbf{m} - \\mathbf{d}) = \\mathbf{m}^T\\mathbf{G}^T\\mathbf{G}\\mathbf{m} - 2\\mathbf{d}^T\\mathbf{G}\\mathbf{m} + \\mathbf{d}^T\\mathbf{d}$$\n梯度为：\n$$\\nabla_{\\mathbf{m}} J_{\\mathrm{LS}}(\\mathbf{m}) = 2\\mathbf{G}^T\\mathbf{G}\\mathbf{m} - 2\\mathbf{G}^T\\mathbf{d}$$\n将梯度设为零，我们得到正规方程组：\n$$(\\mathbf{G}^T\\mathbf{G})\\mathbf{m} = \\mathbf{G}^T\\mathbf{d}$$\n解 $\\mathbf{m}_{\\mathrm{LS}}$ 由下式给出：\n$$\\mathbf{m}_{\\mathrm{LS}} = (\\mathbf{G}^T\\mathbf{G})^{-1}\\mathbf{G}^T\\mathbf{d}$$\n这是经典的最小二乘解，可以使用 Moore-Penrose 伪逆 $\\mathbf{G}^\\dagger$ 稳健地计算，即 $\\mathbf{m}_{\\mathrm{LS}} = \\mathbf{G}^\\dagger\\mathbf{d}$。\n\n在我们的具体问题中，$\\mathbf{G} = \\begin{bmatrix}1  0\\\\ 0  0.1\\end{bmatrix}$ 且 $\\mathbf{d} = \\begin{bmatrix}1\\\\ 1\\end{bmatrix}$。\n$\\mathbf{G}$ 是可逆的，所以 $\\mathbf{m}_{\\mathrm{LS}} = \\mathbf{G}^{-1}\\mathbf{d}$。\n$\\mathbf{G}^{-1} = \\begin{bmatrix}1  0\\\\ 0  10\\end{bmatrix}$。\n$$\\mathbf{m}_{\\mathrm{LS}} = \\begin{bmatrix}1  0\\\\ 0  10\\end{bmatrix} \\begin{bmatrix}1\\\\ 1\\end{bmatrix} = \\begin{bmatrix}1\\\\ 10\\end{bmatrix}$$\n该解对所有测试用例都是相同的，因为 $\\mathbf{G}$ 和 $\\mathbf{d}$ 不变。\n\n**2. Tikhonov 正则化解 ($\\mathbf{m}_{\\mathrm{Tik}}$)**\n\nTikhonov 正则化解 $\\mathbf{m}_{\\mathrm{Tik}}$ 最小化组合目标函数：\n$$J(\\mathbf{m}) = \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2 + \\lambda^2 \\|\\mathbf{L}(\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})\\|_2^2$$\n展开此表达式：\n$$J(\\mathbf{m}) = (\\mathbf{G}\\mathbf{m} - \\mathbf{d})^T(\\mathbf{G}\\mathbf{m} - \\mathbf{d}) + \\lambda^2 (\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})^T \\mathbf{L}^T\\mathbf{L} (\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})$$\n相对于 $\\mathbf{m}$ 的梯度为：\n$$\\nabla_{\\mathbf{m}} J(\\mathbf{m}) = 2\\mathbf{G}^T(\\mathbf{G}\\mathbf{m} - \\mathbf{d}) + 2\\lambda^2 \\mathbf{L}^T\\mathbf{L}(\\mathbf{m} - \\mathbf{m}_{\\mathrm{ref}})$$\n将梯度设为零以找到最小值：\n$$\\mathbf{G}^T\\mathbf{G}\\mathbf{m} - \\mathbf{G}^T\\mathbf{d} + \\lambda^2 \\mathbf{L}^T\\mathbf{L}\\mathbf{m} - \\lambda^2 \\mathbf{L}^T\\mathbf{L}\\mathbf{m}_{\\mathrm{ref}} = 0$$\n对含 $\\mathbf{m}$ 的项进行分组：\n$$(\\mathbf{G}^T\\mathbf{G} + \\lambda^2\\mathbf{L}^T\\mathbf{L})\\mathbf{m} = \\mathbf{G}^T\\mathbf{d} + \\lambda^2\\mathbf{L}^T\\mathbf{L}\\mathbf{m}_{\\mathrm{ref}}$$\n这是一个形如 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$ 的线性方程组，其中 $\\mathbf{x} = \\mathbf{m}_{\\mathrm{Tik}}$，$\\mathbf{A} = (\\mathbf{G}^T\\mathbf{G} + \\lambda^2\\mathbf{L}^T\\mathbf{L})$，以及 $\\mathbf{b} = (\\mathbf{G}^T\\mathbf{d} + \\lambda^2\\mathbf{L}^T\\mathbf{L}\\mathbf{m}_{\\mathrm{ref}})$。解为：\n$$\\mathbf{m}_{\\mathrm{Tik}} = (\\mathbf{G}^T\\mathbf{G} + \\lambda^2\\mathbf{L}^T\\mathbf{L})^{-1} (\\mathbf{G}^T\\mathbf{d} + \\lambda^2\\mathbf{L}^T\\mathbf{L}\\mathbf{m}_{\\mathrm{ref}})$$\n对于每个测试用例，通过代入相应的 $\\lambda$、$\\mathbf{L}$ 和 $\\mathbf{m}_{\\mathrm{ref}}$ 值，可以求解此线性系统以得到 $\\mathbf{m}_{\\mathrm{Tik}}$。\n\n**3. 差异大小**\n\n对于每个用例，在计算出 $\\mathbf{m}_{\\mathrm{LS}} = \\begin{bmatrix}1\\\\ 10\\end{bmatrix}$ 和 $\\mathbf{m}_{\\mathrm{Tik}}$ 后，最终要求的值是它们差值的欧几里得 $2$-范数：\n$$\\Delta = \\|\\mathbf{m}_{\\mathrm{Tik}} - \\mathbf{m}_{\\mathrm{LS}}\\|_2 = \\sqrt{(m_{\\mathrm{Tik},1} - m_{\\mathrm{LS},1})^2 + (m_{\\mathrm{Tik},2} - m_{\\mathrm{LS},2})^2}$$\n\n### 算法规划\n对于每个测试用例：\n1.  确定参数 $\\lambda$、$\\mathbf{L}$ 和 $\\mathbf{m}_{\\mathrm{ref}}$。\n2.  计算常数向量和矩阵：$\\mathbf{G}$、$\\mathbf{d}$、$\\mathbf{G}^T\\mathbf{G}$ 和 $\\mathbf{G}^T\\mathbf{d}$。\n3.  计算特定于用例的矩阵 $\\mathbf{A} = (\\mathbf{G}^T\\mathbf{G} + \\lambda^2\\mathbf{L}^T\\mathbf{L})$ 和向量 $\\mathbf{b} = (\\mathbf{G}^T\\mathbf{d} + \\lambda^2\\mathbf{L}^T\\mathbf{L}\\mathbf{m}_{\\mathrm{ref}})$。\n4.  求解线性系统 $\\mathbf{A}\\mathbf{m}_{\\mathrm{Tik}} = \\mathbf{b}$ 以求得 $\\mathbf{m}_{\\mathrm{Tik}}$。\n5.  非正则化解为 $\\mathbf{m}_{\\mathrm{LS}} = \\begin{bmatrix}1\\\\ 10\\end{bmatrix}$。\n6.  计算差值范数 $\\Delta = \\|\\mathbf{m}_{\\mathrm{Tik}} - \\mathbf{m}_{\\mathrm{LS}}\\|_2$。\n7.  存储五个结果值：$\\mathbf{m}_{\\mathrm{Tik}}$ 的两个分量、$\\mathbf{m}_{\\mathrm{LS}}$ 的两个分量和 $\\Delta$。所有值在最终输出时四舍五入到六位小数。\n将针对提供的五个用例实施此程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Tikhonov-regularized and unregularized least-squares solutions\n    for a suite of test cases in computational geophysics.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"G\": np.array([[1.0, 0.0], [0.0, 0.1]]),\n            \"d\": np.array([1.0, 1.0]),\n            \"lambda\": 0.2,\n            \"L\": np.identity(2),\n            \"m_ref\": np.array([0.0, 0.0])\n        },\n        {\n            \"G\": np.array([[1.0, 0.0], [0.0, 0.1]]),\n            \"d\": np.array([1.0, 1.0]),\n            \"lambda\": 0.0,\n            \"L\": np.identity(2),\n            \"m_ref\": np.array([0.0, 0.0])\n        },\n        {\n            \"G\": np.array([[1.0, 0.0], [0.0, 0.1]]),\n            \"d\": np.array([1.0, 1.0]),\n            \"lambda\": 2.0,\n            \"L\": np.identity(2),\n            \"m_ref\": np.array([0.0, 0.0])\n        },\n        {\n            \"G\": np.array([[1.0, 0.0], [0.0, 0.1]]),\n            \"d\": np.array([1.0, 1.0]),\n            \"lambda\": 0.5,\n            \"L\": np.array([[-1.0, 1.0]]),\n            \"m_ref\": np.array([0.0, 0.0])\n        },\n        {\n            \"G\": np.array([[1.0, 0.0], [0.0, 0.1]]),\n            \"d\": np.array([1.0, 1.0]),\n            \"lambda\": 0.5,\n            \"L\": np.identity(2),\n            \"m_ref\": np.array([0.5, 0.0])\n        },\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        G = case[\"G\"]\n        d = case[\"d\"]\n        lam = case[\"lambda\"]\n        L = case[\"L\"]\n        m_ref = case[\"m_ref\"]\n\n        # 1. Compute m_LS (unregularized least-squares solution)\n        # For a well-posed problem, np.linalg.lstsq is a robust method.\n        m_ls, _, _, _ = np.linalg.lstsq(G, d, rcond=None)\n\n        # 2. Compute m_Tik (Tikhonov-regularized solution)\n        # m_Tik = (G^T G + lambda^2 L^T L)^{-1} (G^T d + lambda^2 L^T L m_ref)\n        \n        GTG = G.T @ G\n        GTd = G.T @ d\n        LTL = L.T @ L\n        lam2 = lam**2\n\n        A = GTG + lam2 * LTL\n        b = GTd + lam2 * (LTL @ m_ref)\n        \n        m_tik = np.linalg.solve(A, b)\n\n        # 3. Compute the difference norm\n        delta = np.linalg.norm(m_tik - m_ls)\n\n        # 4. Collate results for the current case\n        case_output = [m_tik[0], m_tik[1], m_ls[0], m_ls[1], delta]\n        \n        # Format the sub-list as a string with rounding\n        sub_list_str = f\"[{','.join([f'{val:.6f}' for val in case_output])}]\"\n        all_results_str.append(sub_list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际的地球物理问题中，模型参数通常定义在空间网格上。这个练习将引导您从抽象的代数系统过渡到更具物理意义的离散化模型。您将亲手为一个一维网格问题构建一个一阶导数（平滑）正则化算子 $\\mathbf{L}$，并将其与零阶（单位矩阵）阻尼策略进行比较 。这项实践对于学习如何将关于模型的先验知识（例如，模型应该是平滑的）转化为具体的数学矩阵至关重要。",
            "id": "3617426",
            "problem": "给定一个来自计算地球物理学的线性反演问题。令 $n=5$ 表示在间距为 $\\Delta x = 1$ 的均匀网格上定义的模型参数数量。您需要考虑由已知的正演算子 $G \\in \\mathbb{R}^{5 \\times 5}$ 应用于模型向量 $m \\in \\mathbb{R}^{5}$ 所预测的线性数据，观测数据为 $d \\in \\mathbb{R}^{5}$。目标是使用 Tikhonov 正则化来稳定反演，采用两种阻尼策略：一阶导数粗糙度惩罚和零阶单位矩阵阻尼惩罚。您必须从 Tikhonov 目标函数的定义出发，并相应地实现其最小化器。\n\n基本原理：\n- 对于一个线性反演问题，其 Tikhonov 目标泛函定义为（其中 $\\alpha \\ge 0$，L 为选定的正则化算子）：\n$$\n\\Phi(m) = \\| G m - d \\|_2^2 + \\alpha^2 \\| L m \\|_2^2,\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。\n- 在间距为 $\\Delta x$ 的均匀网格上，使用前向差分离散化的离散一阶导数算子 $L \\in \\mathbb{R}^{(n-1) \\times n}$ 由下式给出：\n$$\nL_{i,i} = -\\frac{1}{\\Delta x}, \\quad L_{i,i+1} = \\frac{1}{\\Delta x}, \\quad \\text{for } i=1,\\dots,n-1,\n$$\n所有其他元素均为零。当 $\\Delta x = 1$ 且 $n=5$ 时，这将得到一个 $(4 \\times 5)$ 的矩阵。矩阵 $L^{\\top} L \\in \\mathbb{R}^{n \\times n}$ 则是对称半正定的带状矩阵，具有反映离散梯度惩罚的三对角结构。对于零阶（单位矩阵）阻尼，使用单位矩阵 $L = I \\in \\mathbb{R}^{n \\times n}$。\n\n给定数据：\n- 令\n$$\nG = \\begin{bmatrix}\n1.0  0.9  0.0  0.0  0.0 \\\\\n0.9  1.0  0.9  0.0  0.0 \\\\\n0.0  0.9  1.0  0.9  0.0 \\\\\n0.0  0.0  0.9  1.0  0.9 \\\\\n0.0  0.0  0.0  0.9  1.0\n\\end{bmatrix}, \\quad\nd = \\begin{bmatrix}\n2.9 \\\\ 5.5 \\\\ 6.65 \\\\ 5.6 \\\\ 2.75\n\\end{bmatrix}.\n$$\n\n任务：\n1. 使用前向差分（$\\Delta x = 1$）离散化一阶导数算子 $L \\in \\mathbb{R}^{4 \\times 5}$，如上所述，并构建 $L^{\\top} L \\in \\mathbb{R}^{5 \\times 5}$。\n2. 对于下述每个测试用例，使用给定的正则化策略，在 $m \\in \\mathbb{R}^{5}$ 上最小化 Tikhonov 目标函数 $\\Phi(m)$。利用上述基本原理推导必要的平稳性条件，并生成数值解 $m_{\\alpha}$。\n\n测试套件：\n- 用例1：一阶导数正则化，$\\alpha = 0$。此处，$L$ 是 $(4 \\times 5)$ 的一阶导数算子。尽管形式上仍使用 $L$，但该情况退化为无阻尼的最小二乘拟合。报告解答 $m_{\\alpha}$。\n- 用例2：一阶导数正则化，$\\alpha = 0.5$。使用与上文相同的 $L$。报告解答 $m_{\\alpha}$。\n- 用例3：一阶导数正则化，$\\alpha = 10.0$。使用与上文相同的 $L$。报告解答 $m_{\\alpha}$。\n- 用例4：零阶阻尼，$\\alpha = 0.5$。此处，设 $L = I \\in \\mathbb{R}^{5 \\times 5}$。报告解答 $m_{\\alpha}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中按顺序包含用例1到4的拼接模型向量。每个模型向量包含5个浮点数条目。将每个条目精确到六位小数。总输出必须是包含在单对方括号中的20个数字的单个列表，使用逗号分隔且无空格。例如，句法形式必须是\n$$\n[\\text{m1\\_1},\\text{m1\\_2},\\text{m1\\_3},\\text{m1\\_4},\\text{m1\\_5},\\text{m2\\_1},\\dots,\\text{m4\\_5}],\n$$\n其中 $\\text{mK\\_j}$ 表示用例 $K$ 的解的第 $j$ 个条目。本问题无需报告物理单位。",
            "solution": "问题 R-1 是有效的。它提出了一个来自计算地球物理学的标准、适定的线性反演问题，为获得唯一解提供了所有必要的数据和定义。其表述在科学上和数学上都是合理的，目标明确。\n\n通过对模型参数 $m \\in \\mathbb{R}^5$ 最小化目标泛函 $\\Phi(m)$，可以找到 Tikhonov 正则化线性反演问题的解。目标泛函由下式给出：\n$$\n\\Phi(m) = \\| G m - d \\|_2^2 + \\alpha^2 \\| L m \\|_2^2\n$$\n其中 $G \\in \\mathbb{R}^{5 \\times 5}$ 是正演算子，$d \\in \\mathbb{R}^5$ 是观测数据向量，$L$ 是正则化算子，$\\alpha \\ge 0$ 是正则化参数。\n\n为求最小值，我们计算 $\\Phi(m)$ 的梯度并将其设为零向量。用矩阵表示法，该泛函为：\n$$\n\\Phi(m) = (G m - d)^{\\top}(G m - d) + \\alpha^2 (L m)^{\\top}(L m)\n$$\n展开此表达式可得：\n$$\n\\Phi(m) = m^{\\top}G^{\\top}G m - 2m^{\\top}G^{\\top}d + d^{\\top}d + \\alpha^2 m^{\\top}L^{\\top}L m\n$$\n关于 $m$ 的梯度是：\n$$\n\\nabla_m \\Phi(m) = 2 G^{\\top}G m - 2 G^{\\top}d + 2 \\alpha^2 L^{\\top}L m\n$$\n令 $\\nabla_m \\Phi(m) = 0$ 可得到正则化问题的正规方程：\n$$\n(G^{\\top}G + \\alpha^2 L^{\\top}L) m = G^{\\top}d\n$$\n解（记作 $m_\\alpha$）通过求解该线性方程组获得：\n$$\nm_\\alpha = (G^{\\top}G + \\alpha^2 L^{\\top}L)^{-1} G^{\\top}d\n$$\n现在，我们将此通用解应用于所提供的具体用例。给定的正演算子 $G$ 和数据向量 $d$ 为：\n$$\nG = \\begin{bmatrix}\n1.0  0.9  0.0  0.0  0.0 \\\\\n0.9  1.0  0.9  0.0  0.0 \\\\\n0.0  0.9  1.0  0.9  0.0 \\\\\n0.0  0.0  0.9  1.0  0.9 \\\\\n0.0  0.0  0.0  0.9  1.0\n\\end{bmatrix}, \\quad\nd = \\begin{bmatrix}\n2.9 \\\\ 5.5 \\\\ 6.65 \\\\ 5.6 \\\\ 2.75\n\\end{bmatrix}\n$$\n矩阵 $G$ 是对称的，因此 $G^{\\top} = G$。我们预先计算 $G^{\\top}G$ 和 $G^{\\top}d$ 这两项：\n$$\nG^{\\top}G = G^2 = \\begin{bmatrix}\n1.81  1.80  0.81  0.00  0.00 \\\\\n1.80  2.62  1.80  0.81  0.00 \\\\\n0.81  1.80  2.62  1.80  0.81 \\\\\n0.00  0.81  1.80  2.62  1.80 \\\\\n0.00  0.00  0.81  1.80  1.81\n\\end{bmatrix}, \\quad\nG^{\\top}d = Gd = \\begin{bmatrix}\n7.85 \\\\\n14.095 \\\\\n16.64 \\\\\n14.06 \\\\\n7.79\n\\end{bmatrix}\n$$\n\n**任务1：一阶导数算子**\n对于 $n=5$ 和 $\\Delta x = 1$，使用前向差分的一阶导数算子 $L \\in \\mathbb{R}^{4 \\times 5}$ 为：\n$$\nL = \\begin{bmatrix}\n-1  1  0  0  0 \\\\\n 0  -1  1  0  0 \\\\\n 0  0  -1  1  0 \\\\\n 0  0  0  -1  1\n\\end{bmatrix}\n$$\n相应的粗糙度矩阵 $L^{\\top}L \\in \\mathbb{R}^{5 \\times 5}$ 为：\n$$\nL^{\\top}L = \\begin{bmatrix}\n 1  -1  0  0  0 \\\\\n-1  2  -1  0  0 \\\\\n 0  -1  2  -1  0 \\\\\n 0  0  -1  2  -1 \\\\\n 0  0  0  -1  1\n\\end{bmatrix}\n$$\n\n**任务2：求解测试用例**\n\n**用例1：一阶导数正则化，$\\alpha = 0$**\n当 $\\alpha=0$ 时，正则化项消失，正规方程简化为标准的最小二乘问题：$G^{\\top}G m_0 = G^{\\top}d$。由于在此问题中 $G$ 是可逆的，这等价于 $m_0 = G^{-1}d$。\n求解方程组 $(G^{\\top}G) m_0 = G^{\\top}d$ 以找到模型向量：\n$$\nm_0 \\approx \\begin{bmatrix} -2.427845  5.919828  1.122423  4.975330  -1.727845 \\end{bmatrix}^{\\top}\n$$\n\n**用例2：一阶导数正则化，$\\alpha = 0.5$**\n此处，$\\alpha^2 = 0.25$。我们求解 $(G^{\\top}G + 0.25 L^{\\top}L) m_{0.5} = G^{\\top}d$。构建矩阵 $(G^{\\top}G + 0.25 L^{\\top}L)$ 并求解该方程组，得到：\n$$\nm_{0.5} \\approx \\begin{bmatrix} 1.261882  2.955779  3.791558  3.012587  1.332373 \\end{bmatrix}^{\\top}\n$$\n这个解明显比未正则化的结果更平滑，展示了一阶导数惩罚的效果。\n\n**用例3：一阶导数正则化，$\\alpha = 10.0$**\n此处，$\\alpha^2 = 100.0$。较大的 $\\alpha$ 值会重度惩罚模型的粗糙度。我们求解 $(G^{\\top}G + 100 L^{\\top}L) m_{10} = G^{\\top}d$。解为：\n$$\nm_{10} \\approx \\begin{bmatrix} 2.653457  2.653634  2.653665  2.653634  2.653457 \\end{bmatrix}^{\\top}\n$$\n如预期的那样，所得模型几乎是恒定的，这是最平滑的可能构型。\n\n**用例4：零阶阻尼，$\\alpha = 0.5$**\n对于此用例，正则化算子是单位矩阵 $L = I \\in \\mathbb{R}^{5 \\times 5}$，因此 $L^{\\top}L=I$。当 $\\alpha^2 = 0.25$ 时，我们求解 $(G^{\\top}G + 0.25 I) m_{0.5} = G^{\\top}d$。这种形式的正则化，也称为阻尼最小二乘法，它惩罚模型向量的欧几里得范数。解为：\n$$\nm_{0.5} \\approx \\begin{bmatrix} 0.852432  2.378930  3.003920  2.345869  0.941620 \\end{bmatrix}^{\\top}\n$$\n与未正则化的解相比，该解的整体幅度更小，这与零阶阻尼的性质一致。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a Tikhonov-regularized linear inverse problem for four test cases\n    and formats the output as specified.\n    \"\"\"\n    \n    # Define givens from the problem statement.\n    G = np.array([\n        [1.0, 0.9, 0.0, 0.0, 0.0],\n        [0.9, 1.0, 0.9, 0.0, 0.0],\n        [0.0, 0.9, 1.0, 0.9, 0.0],\n        [0.0, 0.0, 0.9, 1.0, 0.9],\n        [0.0, 0.0, 0.0, 0.9, 1.0]\n    ])\n    \n    d = np.array([2.9, 5.5, 6.65, 5.6, 2.75])\n    \n    n = 5  # Number of model parameters\n\n    # Define the test cases. Each tuple contains (alpha, regularization_type).\n    test_cases = [\n        (0.0, 'derivative'),   # Case 1\n        (0.5, 'derivative'),   # Case 2\n        (10.0, 'derivative'),  # Case 3\n        (0.5, 'identity')      # Case 4\n    ]\n\n    # Pre-compute components that are constant across cases\n    GtG = G.T @ G\n    Gtd = G.T @ d\n\n    # Construct the regularization operators\n    # First-derivative operator L and L^T L\n    L_deriv = np.zeros((n - 1, n))\n    for i in range(n - 1):\n        L_deriv[i, i] = -1.0\n        L_deriv[i, i+1] = 1.0\n    LtL_deriv = L_deriv.T @ L_deriv\n\n    # Zeroth-order (identity) operator L and L^T L\n    L_ident = np.identity(n)\n    LtL_ident = L_ident.T @ L_ident\n\n    all_results = []\n    \n    for alpha, reg_type in test_cases:\n        if reg_type == 'derivative':\n            LtL = LtL_deriv\n        elif reg_type == 'identity':\n            LtL = LtL_ident\n        else:\n            # This case should not be reached with the defined test_cases\n            raise ValueError(f\"Unknown regularization type: {reg_type}\")\n            \n        # Form the matrix for the linear system\n        # (G^T G + alpha^2 L^T L) m = G^T d\n        A = GtG + (alpha**2) * LtL\n        \n        # Solve the system for the model vector m\n        m_alpha = np.linalg.solve(A, Gtd)\n        \n        all_results.extend(m_alpha)\n\n    # Format the final output string\n    # Concatenated list of 20 numbers, each rounded to 6 decimal places,\n    # with comma separators and no spaces.\n    output_str = \",\".join([f\"{x:.6f}\" for x in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这项高级实践将揭示吉洪诺夫正则化在信号处理层面的深刻内涵。在一个规模更大、更接近真实场景的一维反演问题中，您将分析正则化解的频谱特性。通过计算不同正则化强度下解的功率谱，您会发现吉洪诺夫正则化本质上扮演了一个低通滤波器的角色，它能够有效抑制通常与噪声和不稳定性相关的高频成分 。这一练习有助于您从根本上理解正则化为何能稳定不适定问题。",
            "id": "3617430",
            "problem": "给定一个一维线性反演问题，该问题模拟了计算地球物理学中对地下电导率剖面的模糊观测。考虑一个离散化模型向量 $m \\in \\mathbb{R}^N$，其中 $N$ 定义为 $N = 256$。正演算子 $G \\in \\mathbb{R}^{N \\times N}$ 是一个对称循环矩阵，表示与一个高斯灵敏度核的卷积。设高斯核 $k \\in \\mathbb{R}^N$ 按分量定义如下\n$$\nk_j = \\frac{\\exp\\left(-\\frac{1}{2}\\left(\\frac{\\min\\{j,\\,N-j\\}}{\\sigma}\\right)^2\\right)}{\\sum_{q=0}^{N-1} \\exp\\left(-\\frac{1}{2}\\left(\\frac{\\min\\{q,\\,N-q\\}}{\\sigma}\\right)^2\\right)}, \\quad j = 0,1,\\dots,N-1,\n$$\n其中给定标准差 $\\sigma = 4$。$G$ 的循环结构定义为\n$$\nG_{ij} = k_{(i-j) \\bmod N}, \\quad i,j=0,1,\\dots,N-1.\n$$\n真实模型 $m_{\\text{true}} \\in \\mathbb{R}^N$ 是两个正弦波的确定性叠加：\n$$\nm_{\\text{true}}[n] = \\sin\\left(2\\pi \\frac{5 n}{N}\\right) + 0.5 \\sin\\left(2\\pi \\frac{60 n}{N}\\right), \\quad n=0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。合成无噪声数据生成如下\n$$\nd = G m_{\\text{true}}.\n$$\n\n为了从 $d$ 中恢复 $m$，考虑使用带有一阶差分稳定器的 Tikhonov 正则化。定义 $L \\in \\mathbb{R}^{(N-1)\\times N}$ 如下\n$$\n(L m)[i] = m[i+1] - m[i], \\quad i=0,1,\\dots,N-2.\n$$\n对于给定的正则化参数 $\\lambda \\ge 0$，将 Tikhonov 正则化估计 $m_\\lambda$ 定义为严格凸目标函数\n$$\nJ_\\lambda(m) = \\|G m - d\\|_2^2 + \\lambda^2 \\|L m\\|_2^2.\n$$\n的最小值点。\n\n你的任务是：\n- 通过求解相应的正规方程，为测试集 $\\{\\lambda\\} = \\{0, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}, 1, 10\\}$ 中的每个 $\\lambda$ 计算 $m_\\lambda$。\n- 对每个 $m_\\lambda$，使用快速傅里叶变换 (FFT)，更准确地说是实数输入 FFT，计算其单边功率谱。将 $m_\\lambda$ 的单边离散傅里叶变换记为 $M_\\lambda(f)$，相应的功率记为 $P_\\lambda(f) = |M_\\lambda(f)|^2$。使用单位采样间隔 $\\Delta x = 1$，因此奈奎斯特频率为 $f_N = 0.5$ 周/采样点。\n- 通过阈值 $f_{\\text{th}} = c f_N$（其中 $c = 0.35$）定义高频带。将高频衰减量化为标量比率\n$$\nA(\\lambda) = \\frac{\\sum_{f \\ge f_{\\text{th}}} P_\\lambda(f)}{\\sum_{f \\ge f_{\\text{th}}} P_{\\text{true}}(f)},\n$$\n其中 $P_{\\text{true}}(f)$ 由 $m_{\\text{true}}$ 的单边实数输入 FFT 计算得出。所有频率计算都必须使用由长度为 $N$、采样间隔为 $\\Delta x = 1$ 的单边实数输入 FFT 生成的频率网格。\n- 在指定的 $m_{\\text{true}}$ 和阈值下，参考值 $P_{\\text{true}}(f)$ 保证了分母不为零，因此无需特殊处理除以零的情况。\n\n基本约束：\n- 从线性反演问题和使用一阶差分正则化的 Tikhonov 目标函数的定义出发。不要依赖外部的谱滤波器闭式公式；通过构建并求解与 $J_\\lambda(m)$ 相关的正规方程来推导和实现数值解。\n- 单边功率谱必须由实数输入 FFT 计算，并对满足 $f \\ge f_{\\text{th}}$ 的频率仓进行求和，其中 $f_{\\text{th}}$ 的计算方式与描述完全一致。\n- 所有三角函数的参数都必须解释为弧度。\n\n测试集与输出：\n- 使用正则化参数测试集 $\\{\\lambda\\} = \\{0, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}, 1, 10\\}$。\n- 你的程序必须输出单行，其中包含按此精确顺序排列的七个衰减因子列表 $[A(0), A(10^{-4}), A(10^{-3}), A(10^{-2}), A(10^{-1}), A(1), A(10)]$。\n- 每个衰减因子必须以十进制小数形式打印，并四舍五入到 $6$ 位小数。\n- 最终输出必须是单行，不含任何额外文本，格式为方括号括起来的逗号分隔列表，例如 $[a_1,a_2,\\dots,a_7]$，其中每个 $a_i$ 是小数点后恰好有 $6$ 位数字的十进制数。",
            "solution": "所给出的问题是计算地球物理学中的一个经典线性反演问题，可以表示为一般形式 $d = G m$。在此，$m \\in \\mathbb{R}^N$ 是未知模型向量（一个离散化的地下电导率剖面），$d \\in \\mathbb{R}^N$ 代表观测数据，而 $G \\in \\mathbb{R}^{N \\times N}$ 是将模型空间映射到数据空间的正演算子。在这个具体案例中，$G$ 是一个对称循环矩阵，表示与一个高斯核的卷积。这个操作模拟了一种模糊效应，即真实信号 $m_{\\text{true}}$ 被平滑处理以生成观测数据 $d$。\n\n卷积算子，特别是带有高斯核的卷积算子，起到低通滤波器的作用。它们会衰减输入信号的高频分量。因此，矩阵 $G$ 是病态的：其对应于高频特征向量的奇异值（或特征值，因为它是对称的）非常小。试图通过 $m = G^{-1} d$ 直接对 $G$ 求逆来恢复 $m$，将导致对数据中存在的任何噪声产生爆炸性放大，或者即使对于此处给出的无噪声数据也会导致数值不稳定性。这是一个不适定问题的标志。\n\n为了获得一个稳定且有意义的解，我们采用 Tikhonov 正则化。其目标是找到一个模型 $m$，该模型既能拟合数据（即 $Gm \\approx d$），又能满足关于其结构的一些先验假设（例如，平滑性）。这通过最小化一个复合目标函数 $J_\\lambda(m)$ 来实现：\n$$\nJ_\\lambda(m) = \\|G m - d\\|_2^2 + \\lambda^2 \\|L m\\|_2^2\n$$\n第一项 $\\|G m - d\\|_2^2$ 是数据失配项，它确保了对测量值的保真度。第二项 $\\|L m\\|_2^2$ 是正则化项或稳定项，它对被认为不理想的模型进行惩罚。正则化参数 $\\lambda \\ge 0$ 控制着这两个相互竞争目标之间的权衡。小的 $\\lambda$ 会优先拟合数据，而大的 $\\lambda$ 则会更强地强制执行先验假设。\n\n在这个问题中，稳定器由一阶差分算子 $L \\in \\mathbb{R}^{(N-1)\\times N}$ 定义，其中 $(L m)[i] = m[i+1] - m[i]$。最小化 $\\|L m\\|_2^2$ 会鼓励相邻元素之间差异较小的解，从而促进平滑性。\n\n为了找到最小化严格凸目标函数 $J_\\lambda(m)$ 的正则化解 $m_\\lambda$，我们通过将其关于 $m$ 的梯度设为零来找到驻点。\n$$\n\\nabla_m J_\\lambda(m) = \\nabla_m \\left( (Gm-d)^T(Gm-d) + \\lambda^2 (Lm)^T(Lm) \\right) = 0\n$$\n使用标准矩阵微积分法则，我们得到：\n$$\n2 G^T (G m - d) + 2 \\lambda^2 L^T L m = 0\n$$\n重新整理各项，得到称为正规方程的线性方程组：\n$$\n(G^T G + \\lambda^2 L^T L) m = G^T d\n$$\n对于任何 $\\lambda > 0$，矩阵 $(G^T G + \\lambda^2 L^T L)$ 是对称正定的，这保证了存在唯一的稳定解 $m_\\lambda$。对于 $\\lambda = 0$ 的特殊情况，问题简化为标准正规方程 $(G^T G) m = G^T d$。尽管 $G^T G$ 可能是病态的，但对于指定的核来说它是可逆的，因此在这种无噪声环境下也存在唯一解。\n\n求解过程随后涉及以下计算步骤：\n1. 定义问题参数：$N=256$，$\\sigma=4$。\n2. 构造真实模型向量 $m_{\\text{true}}$，作为两个正弦波的和。\n3. 构造高斯核 $k$ 以及相应的对称循环正演矩阵 $G$。\n4. 计算合成数据向量 $d = G m_{\\text{true}}$。\n5. 构造一阶差分矩阵 $L$。\n6. 对于测试集 $\\{0, 10^{-4}, 10^{-3}, 10^{-2}, 10^{-1}, 1, 10\\}$ 中的每个 $\\lambda$ 值，构建矩阵 $A_\\lambda = G^T G + \\lambda^2 L^T L$ 和向量 $b = G^T d$。求解线性系统 $A_\\lambda m_\\lambda = b$ 以获得正则化模型 $m_\\lambda$。\n7. 最后一步是分析每个解 $m_\\lambda$ 的频率内容。我们使用针对实数值输入的快速傅里叶变换 (rFFT) 来计算单边功率谱 $P_\\lambda(f) = |M_\\lambda(f)|^2$，其中 $M_\\lambda(f)$ 是 $m_\\lambda$ 的单边离散傅里叶变换。\n8. 由正则化引起的高频分量衰减通过比率 $A(\\lambda)$ 来量化：\n$$\nA(\\lambda) = \\frac{\\sum_{f \\ge f_{\\text{th}}} P_\\lambda(f)}{\\sum_{f \\ge f_{\\text{th}}} P_{\\text{true}}(f)}\n$$\n其中 $f_{\\text{th}} = 0.35 f_N = 0.175$ 周/采样点是频率阈值，而 $P_{\\text{true}}(f)$ 是真实模型 $m_{\\text{true}}$ 的功率谱。该比率衡量了原始信号中存在的高频功率在正则化解中被保留了多少。随着 $\\lambda$ 的增加，解预期会变得更平滑，导致 $A(\\lambda)$ 减小。\n\n该实现将以数值方式执行这些步骤。矩阵 $G$ 和 $L$ 将被显式构建。正规方程的矩阵系统使用标准线性求解器求解。功率谱使用 `scipy.fft.rfft` 计算，相应的频率仓使用 `scipy.fft.rfftfreq` 计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import rfft, rfftfreq\nfrom scipy.linalg import circulant\n\ndef solve():\n    \"\"\"\n    Solves a 1D linear inverse problem using Tikhonov regularization\n    and computes the high-frequency attenuation for various regularization parameters.\n    \"\"\"\n    # 1. Define constants and parameters\n    N = 256\n    sigma = 4.0\n    c = 0.35\n    lambdas = [0.0, 1e-4, 1e-3, 1e-2, 1e-1, 1.0, 10.0]\n\n    # 2. Construct the true model m_true\n    n = np.arange(N)\n    m_true = np.sin(2 * np.pi * 5 * n / N) + 0.5 * np.sin(2 * np.pi * 60 * n / N)\n\n    # 3. Construct the forward operator G (symmetric circulant matrix)\n    j = np.arange(N)\n    # The distance on a circle of size N\n    min_dist = np.minimum(j, N - j)\n    # Unnormalized kernel\n    k_num = np.exp(-0.5 * (min_dist / sigma)**2)\n    # Normalized kernel\n    k = k_num / np.sum(k_num)\n    # G is circulant with first column k. Because k_j = k_{N-j}, G is also symmetric.\n    G = circulant(k)\n\n    # 4. Generate synthetic noise-free data d\n    d = G @ m_true\n\n    # 5. Construct the first-difference regularization operator L\n    L = np.eye(N, k=1)[:-1, :] - np.eye(N, k=0)[:-1, :]\n\n    # 6. Define power spectrum helper function and related parameters\n    # Sample interval is Delta_x = 1, so sample rate is 1.\n    freqs = rfftfreq(N, d=1.0)\n    # Nyquist frequency is 0.5 cycles/sample for a sample rate of 1.\n    f_nyquist = 0.5\n    f_th = c * f_nyquist\n\n    def get_hf_power(m_vec):\n        \"\"\"\n        Computes the sum of power in the high-frequency band for a given model vector.\n        The power is defined as the squared magnitude of the one-sided FFT components.\n        \"\"\"\n        # Compute one-sided FFT for real input\n        M = rfft(m_vec)\n        # Power spectrum is the squared modulus of the FFT components\n        P = np.abs(M)**2\n        # Find indices corresponding to frequencies >= f_th\n        hf_indices = np.where(freqs >= f_th)\n        # Sum the power over the high-frequency band\n        return np.sum(P[hf_indices])\n\n    # 7. Calculate the reference high-frequency power from m_true\n    # This serves as the denominator in the attenuation ratio A(lambda).\n    denom_A = get_hf_power(m_true)\n\n    # 8. Loop over lambdas, solve normal equations, and calculate attenuation\n    attenuation_results = []\n    \n    # Pre-compute lambda-independent parts of the normal equations\n    # G is symmetric, so G.T = G\n    GTG = G.T @ G\n    LTL = L.T @ L\n    GTd = G.T @ d\n\n    for lam in lambdas:\n        # Form the matrix for the normal equations system: (G^T G + lambda^2 L^T L) m = G^T d\n        A_mat = GTG + (lam**2) * LTL\n        \n        # Solve the linear system for the regularized model m_lambda\n        m_lambda = np.linalg.solve(A_mat, GTd)\n        \n        # Compute the high-frequency power of the regularized solution\n        num_A = get_hf_power(m_lambda)\n        \n        # Compute the attenuation ratio\n        A_lam = num_A / denom_A\n        attenuation_results.append(A_lam)\n\n    # 9. Format and print the final output as specified\n    formatted_results = [f\"{val:.6f}\" for val in attenuation_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}