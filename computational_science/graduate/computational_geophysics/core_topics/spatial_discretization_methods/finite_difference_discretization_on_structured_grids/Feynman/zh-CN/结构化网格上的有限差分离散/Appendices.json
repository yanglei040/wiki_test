{
    "hands_on_practices": [
        {
            "introduction": "要精通有限差分法，就必须将理论付诸实践。本节练习旨在通过数值实验，将泰勒级数展开这个理论工具与计算中实际产生的离散误差直接联系起来。通过将观测误差与截断误差的主导项进行比较，您将具体地理解“$O(h^2)$ 精度”在实践中的真正含义 。",
            "id": "3592019",
            "problem": "您的任务是开发一个程序，该程序针对一维均匀结构化网格，通过评估从泰勒级数推导出的有限差分算子的主截断误差项，来计算离散误差的后验估计，并在一个细化网格序列上将该估计与观测误差进行验证。其背景是一个周期性域和一个已知其导数具有闭合形式表达式的光滑函数，从而确保了适用于计算地球物理学的科学真实性。\n\n从以下基本基础开始：一个足够光滑的函数在一个点附近的泰勒级数展开。对于一个拥有直到至少6阶连续导数的函数 $u(x)$，其在网格点 $x_i$ 附近、网格间距为 $h$ 的泰勒级数可以写为\n$$\nu(x_i \\pm h) = u(x_i) \\pm h u'(x_i) + \\frac{h^2}{2} u''(x_i) \\pm \\frac{h^3}{6} u^{(3)}(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) \\pm \\frac{h^5}{120} u^{(5)}(x_i) + \\frac{h^6}{720} u^{(6)}(x_i) + \\mathcal{O}(h^7).\n$$\n使用这些展开式来推导一阶导数和二阶导数的中心有限差分近似的主截断误差项。\n\n您的程序必须执行以下步骤：\n\n- 考虑周期性域 $[0,1)$，网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N-1$，$h = 1/N$。\n- 使用人造光滑解 $u(x) = \\sin(2 \\pi x)$，其中角度必须以弧度为单位。\n- 对于每个测试用例，按如下规定选择算子和网格分辨率，并：\n  1. 构建周期性结构化网格并计算 $u(x_i)$。\n  2. 对于测试用例指定的算子：\n     - 如果算子是一阶导数的中心有限差分，\n       计算离散近似\n       $$\n       D^{(1)}_h u(x_i) = \\frac{u(x_{i+1}) - u(x_{i-1})}{2 h},\n       $$\n       以及精确导数 $u'(x_i)$。\n       基于泰勒级数和 $u^{(3)}(x_i)$，推导并计算每个网格点上的主截断误差项。\n     - 如果算子是二阶导数的中心有限差分，\n       计算离散近似\n       $$\n       D^{(2)}_h u(x_i) = \\frac{u(x_{i+1}) - 2 u(x_i) + u(x_{i-1})}{h^2},\n       $$\n       以及精确导数 $u''(x_i)$。\n       基于泰勒级数和 $u^{(4)}(x_i)$，推导并计算每个网格点上的主截断误差项。\n  3. 计算观测到的逐点离散误差场，即所选算子的离散近似与精确导数之差。\n  4. 通过仅在网格点上计算主截断误差项来计算后验逐点误差估计。\n  5. 为了验证，计算观测误差和主项估计的无穷范数（上确界范数）之比：\n     $$\n     R = \\frac{\\| \\text{观测误差} \\|_{\\infty}}{\\| \\text{主项估计} \\|_{\\infty}},\n     $$\n     然后报告由下式定义的十进制相对失配：\n     $$\n     \\delta = \\left| R - 1 \\right|.\n     $$\n     量 $\\delta$ 必须以十进制数（而非百分比）报告。随着 $N$ 的增加（细化），如果截断误差推导正确，$\\delta$ 应该减小，因为高阶项变得可以忽略不计。\n\n测试套件和覆盖范围：\n\n- 使用算子代码值 $1$ 表示一阶导数的中心有限差分，使用 $2$ 表示二阶导数的中心有限差分。\n- 使用以下测试用例，覆盖标准情况、细化网格、作为边缘情况的粗糙网格以及非2的幂次网格：\n  - $(\\text{算子} = 1, N = 8)$\n  - $(\\text{算子} = 1, N = 64)$\n  - $(\\text{算子} = 2, N = 8)$\n  - $(\\text{算子} = 2, N = 32)$\n  - $(\\text{算子} = 2, N = 128)$\n  - $(\\text{算子} = 1, N = 4)$\n  - $(\\text{算子} = 2, N = 4)$\n  - $(\\text{算子} = 1, N = 33)$\n  - $(\\text{算子} = 2, N = 33)$\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与上述测试套件中的顺序完全一致。每个条目必须是该测试用例的十进制相对失配 $\\delta$。例如，形如 $[d_1,d_2,\\dots,d_9]$ 的输出，其中每个 $d_k$ 是一个浮点数。\n\n所有角度必须以弧度为单位。不涉及物理单位。通过实现周期性边界条件并使用具有已知导数的人造光滑解来确保科学真实性。",
            "solution": "该问题是有效的，因为它在科学上基于数值分析的原理，特别是有限差分算子的泰勒级数分析。它适定、客观、完整，代表了数值方法验证的标准程序。因此，我们可以进行完整求解。\n\n核心目标是推导并数值验证一阶和二阶导数的中心有限差分近似的后验误差估计。此任务通过将观测到的离散误差与从截断误差主项推导出的理论估计进行比较来完成。此推导的基本基础是在给定均匀网格间距 $h$ 的情况下，一个足够光滑的函数 $u(x)$ 在网格点 $x_i$ 附近的泰勒级数展开。\n\n$u(x_{i} \\pm h) \\equiv u(x_i \\pm h)$ 的泰勒级数提供到 $\\mathcal{O}(h^7)$ 阶：\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u^{(3)}(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + \\frac{h^5}{120} u^{(5)}(x_i) + \\frac{h^6}{720} u^{(6)}(x_i) + \\mathcal{O}(h^7)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u^{(3)}(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) - \\frac{h^5}{120} u^{(5)}(x_i) + \\frac{h^6}{720} u^{(6)}(x_i) + \\mathcal{O}(h^7)\n$$\n\n分析将在周期性域 $[0,1)$ 上进行，使用人造解 $u(x) = \\sin(2\\pi x)$。该函数所需的导数是：\n- $u'(x) = 2\\pi \\cos(2\\pi x)$\n- $u''(x) = -(2\\pi)^2 \\sin(2\\pi x)$\n- $u^{(3)}(x) = -(2\\pi)^3 \\cos(2\\pi x)$\n- $u^{(4)}(x) = (2\\pi)^4 \\sin(2\\pi x)$\n\n**1. 一阶导数中心差分算子（$D^{(1)}_h$）的分析**\n\n一阶导数的中心差分近似定义为：\n$$\nD^{(1)}_h u(x_i) = \\frac{u(x_{i+1}) - u(x_{i-1})}{2 h}\n$$\n为确定截断误差，我们将 $u(x_{i+1})$ 和 $u(x_{i-1})$ 的泰勒级数代入公式。从 $u(x_i+h)$ 的展开式中减去 $u(x_i-h)$ 的展开式，会消去偶数阶导数项：\n$$\nu(x_{i+1}) - u(x_{i-1}) = 2 h u'(x_i) + 2 \\frac{h^3}{6} u^{(3)}(x_i) + 2 \\frac{h^5}{120} u^{(5)}(x_i) + \\mathcal{O}(h^7)\n$$\n除以算子分母中的 $2h$ 项，得到：\n$$\nD^{(1)}_h u(x_i) = u'(x_i) + \\frac{h^2}{6} u^{(3)}(x_i) + \\frac{h^4}{120} u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\n离散误差 $E^{(1)}(x_i)$ 是离散近似与精确连续算子之间的差。这也称为截断误差 $\\tau^{(1)}(x_i)$：\n$$\nE^{(1)}(x_i) = D^{(1)}_h u(x_i) - u'(x_i) = \\frac{h^2}{6} u^{(3)}(x_i) + \\frac{h^4}{120} u^{(5)}(x_i) + \\mathcal{O}(h^6)\n$$\n该误差的主项，即提供后验估计的项，是：\n$$\n\\text{Leading-term estimate for } E^{(1)}(x_i) = \\frac{h^2}{6} u^{(3)}(x_i)\n$$\n这是一个 $\\mathcal{O}(h^2)$ 精度的格式。观测误差直接计算为 $E^{(1)}(x_i) = D^{(1)}_h u(x_i) - u'(x_i)$。\n\n**2. 二阶导数中心差分算子（$D^{(2)}_h$）的分析**\n\n二阶导数的中心差分近似是：\n$$\nD^{(2)}_h u(x_i) = \\frac{u(x_{i+1}) - 2 u(x_i) + u(x_{i-1})}{h^2}\n$$\n为分析此算子，我们首先将 $u(x_{i+1})$ 和 $u(x_{i-1})$ 的泰勒展开式相加，这将消去奇数阶导数项：\n$$\nu(x_{i+1}) + u(x_{i-1}) = 2 u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + \\frac{h^6}{360} u^{(6)}(x_i) + \\mathcal{O}(h^8)\n$$\n将此代入算子定义的分子中：\n$$\nu(x_{i+1}) - 2 u(x_i) + u(x_{i-1}) = h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + \\frac{h^6}{360} u^{(6)}(x_i) + \\mathcal{O}(h^8)\n$$\n除以 $h^2$：\n$$\nD^{(2)}_h u(x_i) = u''(x_i) + \\frac{h^2}{12} u^{(4)}(x_i) + \\frac{h^4}{360} u^{(6)}(x_i) + \\mathcal{O}(h^6)\n$$\n因此，二阶导数的离散误差为：\n$$\nE^{(2)}(x_i) = D^{(2)}_h u(x_i) - u''(x_i) = \\frac{h^2}{12} u^{(4)}(x_i) + \\frac{h^4}{360} u^{(6)}(x_i) + \\mathcal{O}(h^6)\n$$\n该误差的主项，即构成我们的后验估计的项，是：\n$$\n\\text{Leading-term estimate for } E^{(2)}(x_i) = \\frac{h^2}{12} u^{(4)}(x_i)\n$$\n此格式也是 $\\mathcal{O}(h^2)$ 精度的。观测误差计算为 $E^{(2)}(x_i) = D^{(2)}_h u(x_i) - u''(x_i)$。\n\n**3. 算法验证过程**\n\n对于每个指定的测试用例（算子代码, N），算法按以下步骤进行：\n1. 在域 $[0,1)$ 上构建一个具有 $N$ 个点的均匀网格，其中 $x_i = i h$，对于 $i=0, 1, \\dots, N-1$ 且 $h = 1/N$。\n2. 在每个网格点 $x_i$ 上计算函数 $u(x) = \\sin(2\\pi x)$ 的值。\n3. 根据算子代码（1 或 2），在每个网格点上计算相应的离散近似（$D^{(1)}_h u$ 或 $D^{(2)}_h u$）和精确导数（$u'$ 或 $u''$）。周期性通过环绕索引来处理，使得当 $i=0$ 时，$u_{i-1}$ 指向 $u_{N-1}$，当 $i=N-1$ 时，$u_{i+1}$ 指向 $u_0$。\n4. 将离散近似与精确导数之差作为观测到的逐点误差场进行计算。\n5. 通过使用相应高阶导数（$u^{(3)}$ 或 $u^{(4)}$）的已知解析形式，计算推导出的主截断误差项，从而得到后验逐点误差估计。\n6. 对观测误差场和估计误差场均计算无穷范数（上确界范数）$\\|v\\|_{\\infty} = \\max_i |v_i|$。\n7. 计算比率 $R = \\frac{\\| \\text{观测误差} \\|_{\\infty}}{\\| \\text{主项估计} \\|_{\\infty}}$。\n8. 最后，计算十进制相对失配 $\\delta = | R - 1 |$。随着 $N$ 增加，$h$ 减小，导致截断误差中的高阶项变得可以忽略不计。因此，$R$ 应收敛于 $1$，$\\delta$ 应收敛于 $0$，从而验证了解析推导的正确性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an a posteriori estimate of the discretization error for finite\n    difference operators and validates it against the observed error.\n\n    The validation is performed for central difference approximations of the first\n    and second derivatives on a periodic domain with a manufactured solution.\n    The decimal relative mismatch between the norms of the observed and\n    estimated errors is calculated for a suite of test cases.\n    \"\"\"\n\n    # Test cases defined as (operator_code, N_points).\n    # operator_code=1: First derivative central difference.\n    # operator_code=2: Second derivative central difference.\n    test_cases = [\n        (1, 8),\n        (1, 64),\n        (2, 8),\n        (2, 32),\n        (2, 128),\n        (1, 4),\n        (2, 4),\n        (1, 33),\n        (2, 33),\n    ]\n\n    results = []\n    for case in test_cases:\n        operator, N = case\n        \n        # Step 1: Construct the periodic grid and evaluate the function u(x).\n        h = 1.0 / N\n        x = np.arange(N, dtype=float) * h\n        k = 2.0 * np.pi  # Angular frequency for u(x) = sin(k*x)\n        \n        u_vals = np.sin(k * x)\n\n        # To handle periodic boundaries, neighboring values u(x_{i+1}) and u(x_{i-1})\n        # are found by \"rolling\" the grid point array.\n        u_plus_1 = np.roll(u_vals, -1)\n        u_minus_1 = np.roll(u_vals, 1)\n\n        obs_error = None\n        est_error = None\n\n        # Step 2: Select operator and compute approximations.\n        if operator == 1:\n            # First derivative central difference\n            \n            # Compute discrete approximation and exact derivative\n            D1_u = (u_plus_1 - u_minus_1) / (2.0 * h)\n            u_prime_exact = k * np.cos(k * x)\n            \n            # Step 3: Compute observed pointwise discretization error\n            obs_error = D1_u - u_prime_exact\n            \n            # Step 4: Compute a posteriori pointwise error estimate\n            # Leading term is (h^2/6) * u'''(x)\n            u_3_exact = -(k**3) * np.cos(k * x)\n            est_error = (h**2 / 6.0) * u_3_exact\n            \n        elif operator == 2:\n            # Second derivative central difference\n            \n            # Compute discrete approximation and exact derivative\n            D2_u = (u_plus_1 - 2.0 * u_vals + u_minus_1) / (h**2)\n            u_2_exact = -(k**2) * np.sin(k * x)\n            \n            # Step 3: Compute observed pointwise discretization error\n            obs_error = D2_u - u_2_exact\n            \n            # Step 4: Compute a posteriori pointwise error estimate\n            # Leading term is (h^2/12) * u''''(x)\n            u_4_exact = (k**4) * np.sin(k * x)\n            est_error = (h**2 / 12.0) * u_4_exact\n\n        # Step 5: For validation, compute the ratio of the infinity norms\n        # and the decimal relative mismatch.\n        norm_obs_error = np.max(np.abs(obs_error))\n        norm_est_error = np.max(np.abs(est_error))\n        \n        # The problem is structured to ensure norm_est_error is non-zero.\n        ratio_R = norm_obs_error / norm_est_error\n        \n        delta = np.abs(ratio_R - 1.0)\n        results.append(delta)\n\n    # Print the final results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的地球物理问题往往是复杂的，通常涉及多维度和空间变化的材料属性（非均匀介质）。当复杂问题的解析解不可用时，“造解法”（Method of Manufactured Solutions）是验证代码正确性的强大技术。这项综合性练习将前面的概念整合到一个更大的项目中：为具有可变系数的二维扩散方程构建并验证一个有限差分求解器。您将通过实现一个守恒格式并执行网格收敛性研究，来验证代码是否达到了理论精度阶，这是计算科学中的标准验证流程 。",
            "id": "3592039",
            "problem": "设计并实现一个程序，在二维结构化网格上对一个非均匀扩散问题进行网格收敛性研究，使用与二阶中心有限差分一致的方法。其数学模型是具有空间变化的标量传导率的稳态扩散方程。设该有界平面域为单位正方形 $\\Omega = [0,1]^2$。考虑以下边值问题\n$$\n- \\nabla \\cdot \\left( k(x,y) \\nabla u(x,y) \\right) = f(x,y) \\quad \\text{in } \\Omega,\\qquad u(x,y) = g(x,y) \\quad \\text{on } \\partial\\Omega ,\n$$\n其中传导率 $k(x,y) > 0$ 是光滑正函数，Dirichlet 边界数据为 $g(x,y) = u_{\\text{exact}}(x,y)$。使用人工解方法：选择一个光滑的 $u_{\\text{exact}}(x,y)$ 和一个光滑的 $k(x,y)$，然后通过以下恒等式定义 $f(x,y)$\n$$\nf(x,y) = -\\nabla \\cdot \\left( k(x,y)\\nabla u_{\\text{exact}}(x,y) \\right) = -\\left(k(x,y) \\, u_{xx}(x,y) + \\frac{\\partial k}{\\partial x}(x,y)\\, u_x(x,y) + k(x,y)\\, u_{yy}(x,y) + \\frac{\\partial k}{\\partial y}(x,y)\\, u_y(x,y)\\right),\n$$\n其中下标表示偏导数。取人工精确解为\n$$\nu_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y).\n$$\n您必须在一个均匀的笛卡尔网格上离散化算子 $-\\nabla\\cdot(k\\nabla u)$，其在 $x$ 和 $y$ 方向上的网格间距分别为 $h_x$ 和 $h_y$。离散化需采用保守、对称的两点通量近似，其中界面传导率由节点传导率的调和平均给出。将未知量置于内部网格节点 $\\{(x_i,y_j)\\}_{i=1,\\dots,N_x}^{j=1,\\dots,N_y}$ 上，其中 $x_i=i\\,h_x$，$y_j=j\\,h_y$，且 $h_x=1/(N_x+1)$，$h_y=1/(N_y+1)$。通过将边界节点值设为 $u_{\\text{exact}}$ 并将其并入内部方程的右侧来施加 Dirichlet 边界条件。使用一个鲁棒的稀疏直接法组装并求解得到的线性系统。在节点网格上计算出数值解 $u_h$（包括其值等于 $u_{\\text{exact}}$ 的边界）后，在所有网格节点上评估离散误差场 $e_{i,j} = u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)$，并计算以下离散误差范数：\n$$\n\\|e\\|_{2,h} = \\left( h_x h_y \\sum_{i=0}^{N_x+1}\\sum_{j=0}^{N_y+1} e_{i,j}^2 \\right)^{1/2}, \\qquad \\|e\\|_{\\infty} = \\max_{0\\le i\\le N_x+1,\\,0\\le j\\le N_y+1} |e_{i,j}|.\n$$\n对于一系列特征网格尺寸为 $h=\\max(h_x,h_y)$ 的网格，计算误差范数，并通过最小二乘法将数据 $\\log(\\|e\\|)$ 对 $\\log(h)$ 拟合一条直线来估计观测到的精度阶 $p$；该直线的斜率即为 $p$ 的估计值。使用自然对数。\n\n您的程序必须实现并报告下面三个测试案例的观测收敛率。在所有案例中，使用上面指定的精确解，在 $\\partial\\Omega$ 上设置 $g=u_{\\text{exact}}$，并根据提供的恒等式定义 $f$。每个测试案例定义了一个传导率场和一系列网格。\n\n- 测试案例 A（光滑、缓变传导率）：$k(x,y)=1+x+y$。使用方形网格，其中 $(N_x,N_y)\\in\\{(16,16),(32,32),(64,64),(128,128)\\}$。\n- 测试案例 B（光滑、速变但解析的传导率）：$k(x,y)=\\exp(x+y)$。使用方形网格，其中 $(N_x,N_y)\\in\\{(16,16),(32,32),(64,64),(128,128)\\}$。\n- 测试案例 C（光滑、振荡传导率和各向异性网格）：$k(x,y)=1+\\tfrac{1}{2}\\sin(5\\pi x)\\sin(5\\pi y)$。使用矩形网格，其中 $(N_x,N_y)\\in\\{(12,24),(24,48),(48,96),(96,192)\\}$。\n\n对于每个测试案例，通过 $\\log(\\|e\\|_{2,h})$ 对 $\\log(h)$ 的斜率计算观测阶 $p_2$，以及通过 $\\log(\\|e\\|_{\\infty})$ 对 $\\log(h)$ 的斜率计算 $p_{\\infty}$。您的程序应生成单行输出，包含三个测试案例的六个斜率，顺序如下：$[p_2^{\\text{A}},p_{\\infty}^{\\text{A}},p_2^{\\text{B}},p_{\\infty}^{\\text{B}},p_2^{\\text{C}},p_{\\infty}^{\\text{C}}]$。每个斜率表示为一个四舍五入到3位小数的浮点数。不需要物理单位。\n\n您的离散化和求解器选择必须在科学上是合理的，并与所述模型和数值方法一致。该实现不应接受任何外部输入，并且必须按原样运行至完成。该测试套件涵盖了一个普通光滑案例、一个速变光滑案例，以及一个带有振荡光滑系数的各向异性网格案例，以探究渐近区域和对网格各向异性的潜在敏感性。如果离散化是二阶的，那么在光滑案例中，预期的观测阶接近 $2$；在最粗糙的网格层级上，振荡最强的案例可能会出现偏差，但随着 $h\\to 0$ 应趋向于 $2$。",
            "solution": "经评估，用户提供的问题是有效的。这是一个计算科学领域的适定问题，基于偏微分方程数值分析的既定原则。该问题是自洽的，所有必要的参数、方程和方法都已明确指定。不存在科学、事实或逻辑上的不一致之处。任务是为一个具有可变系数的稳态扩散方程的二阶有限差分离散化方案执行网格收敛性研究，这是一种标准的验证技术。指定的方法论，包括使用人工解、采用调和平均的保守通量近似，以及用于收敛率估计的对数-对数回归，对于该问题是科学合理且恰当的。\n\n### 1. 数学模型\n\n该物理过程由具有空间变化的标量传导率 $k(x,y)$ 的二维稳态扩散方程描述。在单位正方形域 $\\Omega = [0,1]^2$ 上的控制偏微分方程(PDE)为：\n$$\n- \\nabla \\cdot \\left( k(x,y) \\nabla u(x,y) \\right) = f(x,y) \\quad \\text{in } \\Omega\n$$\n该方程服从 Dirichlet 边界条件：\n$$\nu(x,y) = g(x,y) \\quad \\text{on } \\partial\\Omega\n$$\n该问题采用人工解方法进行验证。选择一个光滑的精确解 $u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。然后从该精确解导出源项 $f(x,y)$ 和边界条件 $g(x,y)$ 以确保一致性。边界条件被设为在 $\\partial\\Omega$ 上 $g(x,y) = u_{\\text{exact}}(x,y)$。源项 $f(x,y)$ 是通过将微分算子应用于人工解得到的：\n$$\nf(x,y) = -\\nabla \\cdot \\left( k(x,y)\\nabla u_{\\text{exact}}(x,y) \\right)\n$$\n展开散度算子可得到源项的显式形式：\n$$\nf(x,y) = -\\left(\\frac{\\partial k}{\\partial x}\\frac{\\partial u_{\\text{exact}}}{\\partial x} + k \\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2} + \\frac{\\partial k}{\\partial y}\\frac{\\partial u_{\\text{exact}}}{\\partial y} + k \\frac{\\partial^2 u_{\\text{exact}}}{\\partial y^2}\\right)\n$$\n代入 $u_{\\text{exact}}(x,y)$ 的偏导数可得：\n$$\nf(x,y) = 2\\pi^2 k(x,y) \\sin(\\pi x)\\sin(\\pi y) - \\pi \\frac{\\partial k}{\\partial x} \\cos(\\pi x)\\sin(\\pi y) - \\pi \\frac{\\partial k}{\\partial y} \\sin(\\pi x)\\cos(\\pi y)\n$$\n\n### 2. 有限差分离散化\n域 $\\Omega$ 使用均匀的笛卡尔网格进行离散化，节点为 $(x_i, y_j)$，其中 $x_i = i h_x$ ($i=0, \\dots, N_x+1$) 且 $y_j = j h_y$ ($j=0, \\dots, N_y+1$)。网格间距为 $h_x = 1/(N_x+1)$ 和 $h_y = 1/(N_y+1)$。未知量是 $N_x \\times N_y$ 个内部节点上的 $u$ 值。\n\n该偏微分方程使用基于控制体方法的保守有限差分格式进行离散化。将偏微分方程在一个以内节点 $(x_i, y_j)$ 为中心的控制体 $\\Omega_{i,j}$ 上积分，并应用散度定理，我们得到：\n$$\n- \\oint_{\\partial\\Omega_{i,j}} (k \\nabla u) \\cdot \\vec{n} \\,ds = \\iint_{\\Omega_{i,j}} f \\,dA \\approx f(x_i,y_j) h_x h_y\n$$\n左侧的通量积分通过对控制体四个面上的通量求和来近似。通过面 $x = x_{i+1/2}$ 的通量使用梯度的中心差分和传导率的特定平均值来近似。问题指定了使用调和平均计算界面传导率的对称两点通量近似：\n$$\n-k(x_{i+1/2}, y_j) \\frac{u(x_{i+1},y_j) - u(x_i,y_j)}{h_x} h_y\n$$\n界面传导率 $k_{i+1/2,j} = k(x_{i+1/2},y_j)$ 由相邻节点上传导率的调和平均值来近似：\n$$\nk_{i+1/2, j} \\approx \\frac{2 k(x_i,y_j) k(x_{i+1},y_j)}{k(x_i,y_j) + k(x_{i+1},y_j)}\n$$\n这一选择对于在非均匀介质中精确建模通量至关重要。将此近似应用于所有四个面，并除以控制体面积 $h_x h_y$，得到节点 $(i,j)$ 处的离散方程：\n$$\n-\\frac{1}{h_x^2} \\left[ k_{i+1/2, j} (u_{i+1,j} - u_{i,j}) - k_{i-1/2, j} (u_{i,j} - u_{i-1,j}) \\right] - \\frac{1}{h_y^2} \\left[ k_{i, j+1/2} (u_{i,j+1} - u_{i,j}) - k_{i, j-1/2} (u_{i,j} - u_{i,j-1}) \\right] = f_{i,j}\n$$\n该格式产生一个五点模板，对于光滑解和光滑系数是二阶精确的。\n\n### 3. 线性系统构建\n重新排列离散方程，将与每个节点未知数 $u_{i,j}$ 相关的项收集起来。这将产生一个大型稀疏线性方程组，形式为 $A\\vec{U} = \\vec{b}$，其中 $\\vec{U}$ 是由 $N=N_x N_y$ 个未知内部节点值组成的向量。\n矩阵 $A$ 是一个 $N \\times N$ 的稀疏矩阵。对于行主序的未知量排序 $k=(j-1)N_x + (i-1)$，该矩阵具有五条非零对角线的块三对角结构。节点 $(i,j)$ 处方程的对角线元素为：\n$$\nA_{k,k} = \\frac{k_{i+1/2, j} + k_{i-1/2, j}}{h_x^2} + \\frac{k_{i, j+1/2} + k_{i, j-1/2}}{h_y^2}\n$$\n与相邻节点对应的非对角线元素为：\n$$\nA_{k,k-1} = -\\frac{k_{i-1/2, j}}{h_x^2}, \\quad A_{k,k+1} = -\\frac{k_{i+1/2, j}}{h_x^2}, \\quad A_{k,k-N_x} = -\\frac{k_{i,j-1/2}}{h_y^2}, \\quad A_{k,k+N_x} = -\\frac{k_{i,j+1/2}}{h_y^2}\n$$\n矩阵 $A$ 是对称正定的，这保证了唯一解的存在。\n右端向量 $\\vec{b}$ 包含源项 $f_{i,j}$ 以及来自 Dirichlet 边界条件的贡献。对于一个与边界相邻的内部节点 $(i,j)$（例如，在 $i=1$ 处），涉及已知边界值 $u_{0,j} = g(x_0, y_j)$ 的项被移到右侧。例如，项 $-A_{k,k-1}u_{0,j}$ 变为 $+\\frac{k_{1/2,j}}{h_x^2}u_{0,j}$ 并加到 $b_k$ 上。按规定，使用稀疏直接求解器求解得到的线性系统。\n\n### 4. 误差分析与收敛率\n在求解内部节点上的数值解 $u_h$ 后，通过包含已知的边界值将解扩展到整个网格。在所有节点上，误差计算为数值解与精确解之差，即 $e_{i,j} = u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)$。误差的大小使用两种离散范数来量化：\n- 离散 $L_2$-范数：$\\|e\\|_{2,h} = \\left( h_x h_y \\sum_{i=0}^{N_x+1}\\sum_{j=0}^{N_y+1} e_{i,j}^2 \\right)^{1/2}$\n- 离散 $L_{\\infty}$-范数（最大误差）：$\\|e\\|_{\\infty} = \\max_{0\\le i\\le N_x+1,\\,0\\le j\\le N_y+1} |e_{i,j}|$\n\n对于一个精度阶为 $p$ 的方法，误差预期表现为 $\\|e\\| \\approx C h^p$，其中 $C$ 是某个常数，而 $h = \\max(h_x, h_y)$ 是特征网格尺寸。为了估计 $p$，我们对该关系式取自然对数：\n$$\n\\ln(\\|e\\|) \\approx \\ln(C) + p \\ln(h)\n$$\n这表明 $\\ln(\\|e\\|)$ 和 $\\ln(h)$ 之间存在线性关系。通过在一系列连续加密的网格上计算误差，我们得到一组数据点 $(\\ln(h_k), \\ln(\\|e\\|_k))$。观测到的精度阶 $p$ 被估计为使用最小二乘法拟合这些点的直线的斜率。对于每个测试案例，我们从 $L_2$-范数数据计算 $p_2$，从 $L_{\\infty}$-范数数据计算 $p_{\\infty}$。",
            "answer": "```python\nimport numpy as np\nimport scipy\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = {\n        'A': {\n            'grids': [(16, 16), (32, 32), (64, 64), (128, 128)],\n        },\n        'B': {\n            'grids': [(16, 16), (32, 32), (64, 64), (128, 128)],\n        },\n        'C': {\n            'grids': [(12, 24), (24, 48), (48, 96), (96, 192)],\n        },\n    }\n\n    results = []\n    \n    for case_id in ['A', 'B', 'C']:\n        grids = test_cases[case_id]['grids']\n        p2, pinf = compute_convergence_rates(case_id, grids)\n        results.extend([round(p2, 3), round(pinf, 3)])\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_problem_functions(case_id):\n    \"\"\"\n    Returns the conductivity, exact solution, and source term functions for a given case.\n    \"\"\"\n    pi = np.pi\n    if case_id == 'A':\n        k = lambda x, y: 1 + x + y\n        kx = lambda x, y: 1.0 + 0 * x  # Use 0*x to handle array inputs\n        ky = lambda x, y: 1.0 + 0 * y\n    elif case_id == 'B':\n        k = lambda x, y: np.exp(x + y)\n        kx = lambda x, y: np.exp(x + y)\n        ky = lambda x, y: np.exp(x + y)\n    elif case_id == 'C':\n        k = lambda x, y: 1 + 0.5 * np.sin(5*pi*x) * np.sin(5*pi*y)\n        kx = lambda x, y: 0.5 * 5*pi * np.cos(5*pi*x) * np.sin(5*pi*y)\n        ky = lambda x, y: 0.5 * 5*pi * np.sin(5*pi*x) * np.cos(5*pi*y)\n    \n    u_exact = lambda x, y: np.sin(pi*x) * np.sin(pi*y)\n    \n    f_source = lambda x, y: (2 * pi**2 * k(x, y) * np.sin(pi*x) * np.sin(pi*y) -\n                           pi * kx(x, y) * np.cos(pi*x) * np.sin(pi*y) -\n                           pi * ky(x, y) * np.sin(pi*x) * np.cos(pi*y))\n\n    return k, u_exact, f_source\n\ndef harmonic_mean(k1, k2):\n    \"\"\"Computes the harmonic mean of two values.\"\"\"\n    return 2 * k1 * k2 / (k1 + k2)\n\ndef compute_convergence_rates(case_id, grid_resolutions):\n    \"\"\"\n    Performs the grid convergence study for a single test case.\n    \"\"\"\n    k_func, u_exact_func, f_func = get_problem_functions(case_id)\n    \n    h_vals, e2_norms, einf_norms = [], [], []\n\n    for Nx, Ny in grid_resolutions:\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        h_vals.append(max(hx, hy))\n\n        # Set up grid and evaluate functions\n        x_nodes = np.linspace(0, 1, Nx + 2)\n        y_nodes = np.linspace(0, 1, Ny + 2)\n        xv, yv = np.meshgrid(x_nodes, y_nodes, indexing='xy')\n\n        u_exact_grid = u_exact_func(xv, yv)\n        k_grid = k_func(xv, yv)\n        \n        # Assemble linear system\n        num_unknowns = Nx * Ny\n        A = lil_matrix((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                idx = (j - 1) * Nx + (i - 1)\n                b[idx] = f_func(x_nodes[i], y_nodes[j])\n                \n                # West face\n                k_W = harmonic_mean(k_grid[j, i], k_grid[j, i-1])\n                c_W = k_W / hx**2\n                if i == 1:\n                    b[idx] += c_W * u_exact_grid[j, 0]\n                else:\n                    A[idx, idx - 1] = -c_W\n                \n                # East face\n                k_E = harmonic_mean(k_grid[j, i], k_grid[j, i+1])\n                c_E = k_E / hx**2\n                if i == Nx:\n                    b[idx] += c_E * u_exact_grid[j, Nx+1]\n                else:\n                    A[idx, idx + 1] = -c_E\n                    \n                # South face\n                k_S = harmonic_mean(k_grid[j, i], k_grid[j-1, i])\n                c_S = k_S / hy**2\n                if j == 1:\n                    b[idx] += c_S * u_exact_grid[0, i]\n                else:\n                    A[idx, idx - Nx] = -c_S\n\n                # North face\n                k_N = harmonic_mean(k_grid[j, i], k_grid[j+1, i])\n                c_N = k_N / hy**2\n                if j == Ny:\n                    b[idx] += c_N * u_exact_grid[Ny+1, i]\n                else:\n                    A[idx, idx + Nx] = -c_N\n\n                A[idx, idx] = c_W + c_E + c_S + c_N\n        \n        # Solve system and reconstruct solution\n        u_interior = spsolve(A.tocsc(), b)\n        u_h = np.copy(u_exact_grid)\n        u_h[1:-1, 1:-1] = u_interior.reshape((Ny, Nx))\n        \n        # Compute and store errors\n        error_grid = u_h - u_exact_grid\n        einf_norms.append(np.max(np.abs(error_grid)))\n        e2_norms.append(np.sqrt(hx * hy * np.sum(error_grid**2)))\n    \n    # Calculate convergence rates via linear regression on log-log data\n    log_h = np.log(np.array(h_vals))\n    p2, _ = np.polyfit(log_h, np.log(np.array(e2_norms)), 1)\n    pinf, _ = np.polyfit(log_h, np.log(np.array(einf_norms)), 1)\n    \n    return p2, pinf\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在掌握了内部网格点的离散格式后，下一个挑战是如何处理区域的边界。边界条件的正确离散化对于保证整个问题解的准确性和稳定性至关重要。本练习将聚焦于一种常见且重要的边界类型——罗宾（Robin）边界条件，您将练习如何将其从连续形式转换为离散的代数方程，并推导在边界点处的矩阵模板，这是构建全局线性系统时不可或缺的一步 。",
            "id": "3592062",
            "problem": "考虑一个在区间 $[0,L]$ 上的一维稳态扩散方程，该方程代表了计算地球物理学中的热传导或压力扩散，\n$$\n- \\frac{d^{2}u}{dx^{2}} = s(x),\n$$\n在 $x=L$ 处有一个线性的罗宾 (Robin) 边界条件，\n$$\n\\alpha\\,u(L) + \\beta\\,\\frac{du}{dx}(L) = f,\n$$\n其中 $\\alpha$、$\\beta$ 和 $f$ 是给定的常数，$s(x)$ 是一个给定的源项。假设该区域被一个均匀结构化网格离散化，其节点为 $x_{i} = i\\,h$，其中 $i=0,1,\\dots,N$，$h = L/N$。\n\n假设内部的二阶导数在结构化网格上采用标准的二阶中心有限差分进行离散化，\n$$\n\\frac{d^{2}u}{dx^{2}}(x_{i}) \\approx \\frac{u_{i-1} - 2u_{i} + u_{i+1}}{h^{2}}, \\quad i = 1,2,\\dots,N-1,\n$$\n并且在 $x=L$ 处的边界导数采用与网格拓扑一致的单边后向有限差分进行近似，\n$$\n\\frac{du}{dx}(L) \\approx \\frac{u_{N} - u_{N-1}}{h}.\n$$\n\n从这些定义和控制方程出发，构建在 $x=L$ 处的离散罗宾边界条件。该条件需与二阶内部拉普拉斯算子兼容，即全局线性系统的最后一个方程用该离散边界条件替换在 $i=N$ 处的内部模板。由此，计算矩阵方程 $A\\,\\mathbf{u}=\\mathbf{b}$ 最后一行的修改后边界模板，明确给出最后一​​行中乘以 $u_{N-1}$ 和 $u_{N}$ 的系数，以及相应的右侧项。\n\n将你的最终答案表示为一个单行向量，按顺序包含 $u_{N-1}$ 和 $u_{N}$ 的最后一行矩阵系数，以及最后一行的右侧项。最终答案不需要进行数值舍入，也不需要单位。",
            "solution": "该问题被验证为合理且适定的。任务是推导一维扩散方程的罗宾边界条件的离散形式。这个离散方程将构成由有限差分法产生的全局线性方程组的最后一行。\n\n控制该问题的连续问题由扩散方程和在 $x=L$ 处的边界条件定义：\n扩散方程为：\n$$\n- \\frac{d^{2}u}{dx^{2}} = s(x) \\quad \\text{for } x \\in [0,L]\n$$\n在 $x=L$ 处的罗宾边界条件为：\n$$\n\\alpha\\,u(L) + \\beta\\,\\frac{du}{dx}(L) = f\n$$\n区域使用均匀网格进行离散化，节点为 $x_i = i\\,h$，其中 $i=0, 1, \\dots, N$，网格间距为 $h=L/N$。函数 $u(x)$ 在网格节点上的离散近似值用 $u_i \\approx u(x_i)$ 表示。\n\n问题要求将这个连续边界条件转换为一个离散方程，该方程将构成线性系统 $A\\mathbf{u} = \\mathbf{b}$ 的最后一行。为此，我们将边界条件方程中的连续项替换为指定的离散近似值。\n\n函数 $u$ 在边界 $x=L$ 处的值对应于节点 $i=N$。因此，我们将 $u(L)$ 近似为：\n$$\nu(L) \\approx u_N\n$$\n问题为边界 $x=L$ 处的一阶导数提供了一个特定的有限差分公式。这是一个一阶精度的单边后向差分近似：\n$$\n\\frac{du}{dx}(L) \\approx \\frac{u(x_N) - u(x_{N-1})}{h} = \\frac{u_{N} - u_{N-1}}{h}\n$$\n现在我们将这些离散近似值代入连续的罗宾边界条件方程中：\n$$\n\\alpha\\,u(L) + \\beta\\,\\frac{du}{dx}(L) = f\n$$\n代入 $u(L)$ 和 $\\frac{du}{dx}(L)$ 的近似值得到：\n$$\n\\alpha\\,u_N + \\beta \\left( \\frac{u_N - u_{N-1}}{h} \\right) = f\n$$\n这个方程提供了离散值 $u_{N-1}$ 和 $u_N$ 之间的关系，从而施加了边界条件。正是这个方程将构成矩阵系统的最后一行。为了确定这一行中矩阵 $A$ 的系数和右侧向量 $\\mathbf{b}$ 的项，我们通过将包含未知变量 $u_{N-1}$ 和 $u_N$ 的项组合在左侧来重新整理方程。\n\n展开各项：\n$$\n\\alpha\\,u_N + \\frac{\\beta}{h}u_N - \\frac{\\beta}{h}u_{N-1} = f\n$$\n现在，我们收集每个未知数 $u_j$ 的系数：\n$$\n\\left(-\\frac{\\beta}{h}\\right)u_{N-1} + \\left(\\alpha + \\frac{\\beta}{h}\\right)u_N = f\n$$\n这个方程是线性系统 $\\sum_{j} A_{N,j} u_j = b_N$ 中一行的标准形式。通过比较各项，我们可以直接确定最后一行（对应于节点 $i=N$）所要求的系数：\n\n乘以 $u_{N-1}$ 的系数是矩阵项 $A_{N, N-1}$：\n$$\nA_{N, N-1} = -\\frac{\\beta}{h}\n$$\n乘以 $u_N$ 的系数是矩阵项 $A_{N, N}$：\n$$\nA_{N, N} = \\alpha + \\frac{\\beta}{h}\n$$\n这一行中所有其他系数 $A_{N,j}$（对于 $j \\neq N, N-1$）均为零。\n\n右侧向量中对应的项 $b_N$ 是：\n$$\nb_N = f\n$$\n问题要求按特定顺序列出这三个量：$u_{N-1}$ 的系数、$u_N$ 的系数和右侧项。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{\\beta}{h} & \\alpha + \\frac{\\beta}{h} & f \\end{pmatrix}}\n$$"
        }
    ]
}