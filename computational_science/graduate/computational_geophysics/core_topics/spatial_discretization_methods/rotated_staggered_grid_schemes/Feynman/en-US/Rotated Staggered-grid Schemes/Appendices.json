{
    "hands_on_practices": [
        {
            "introduction": "A primary motivation for employing rotated-grid schemes is to mitigate numerical anisotropy, ensuring that simulated waves propagate with a speed that is independent of their travel direction relative to the grid. This practice provides a direct comparison between a standard axis-aligned finite-difference stencil and a more isotropic nine-point stencil for the Laplacian operator. By numerically verifying convergence rates and quantifying directional error dependency, you will gain a practical understanding of why rotated stencils are often superior for wave propagation problems.",
            "id": "3613876",
            "problem": "Consider the two-dimensional scalar wavefield model problem commonly used in computational geophysics to assess spatial discretization accuracy and directional (angular) anisotropy. Let the scalar field be $f(x,y) = \\cos\\big(k \\big(x \\cos \\alpha + y \\sin \\alpha\\big)\\big)$ over a periodic square domain $\\Omega = [0,L]^2$, where $L$ is the domain length, $k$ is the wavenumber, and $\\alpha$ is the propagation angle of the plane wave. The exact Laplacian of this field is $\\Delta f(x,y) = -k^2 f(x,y)$.\n\nThis problem focuses on error analysis, verification, and convergence of rotated staggered-grid style stencils by comparing a standard five-point Laplacian (axis-aligned stencil) against a rotated nine-point Laplacian (including diagonal, i.e., rotated-neighbor, contributions). The goal is to quantify truncation errors, verify empirical convergence orders, and assess anisotropy as a function of propagation angle.\n\nYou are to use the following two discrete Laplacian operators on a uniform grid with spacing $h = L/N$ and periodic boundary conditions:\n\n- Standard five-point Laplacian (axis-aligned):\n$$\n\\Delta_h^{(5)} f_{i,j}\n=\n\\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4 f_{i,j}}{h^2}.\n$$\n\n- Rotated nine-point Laplacian (axis-aligned plus diagonals):\n$$\n\\Delta_h^{(9)} f_{i,j}\n=\n\\frac{1}{6 h^2}\n\\left(\n4\\left(f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1}\\right)\n+\n\\left(f_{i+1,j+1} + f_{i-1,j+1} + f_{i+1,j-1} + f_{i-1,j-1}\\right)\n- 20 f_{i,j}\n\\right).\n$$\n\nThese operators are to be evaluated at all grid nodes $\\{(x_i,y_j)\\}$, where $x_i = i h$ and $y_j = j h$ for integers $i,j \\in \\{0,1,\\dots,N-1\\}$, and indices are taken modulo $N$ to enforce periodicity. Explicitly, you must compute the discrete Laplacians on the sampled scalar field $f_{i,j} = \\cos\\big(k (x_i \\cos \\alpha + y_j \\sin \\alpha)\\big)$ and compare them with the exact Laplacian $-k^2 f_{i,j}$.\n\nDefine the discrete root-mean-square error (in the Euclidean norm) for a grid with $N \\times N$ nodes as\n$$\nE^{(s)}(N; k,\\alpha) = \\left(\n\\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1}\n\\left(\\Delta_h^{(s)} f_{i,j} + k^2 f_{i,j} \\right)^2\n\\right)^{1/2},\n$$\nwhere the superscript $(s)$ is either $(5)$ for the five-point or $(9)$ for the nine-point operator.\n\nFrom first principles, your program must:\n- Approximate the empirical convergence order using a grid-refinement sequence $N, 2N, 4N$:\n$$\np^{(s)}(N; k,\\alpha) =\n\\frac{\\log\\left( E^{(s)}(N; k,\\alpha) / E^{(s)}(2N; k,\\alpha) \\right)}{\\log(2)}.\n$$\nTo improve robustness, compute $p^{(s)}(2N; k,\\alpha)$ analogously from the pair $(2N,4N)$ and report the average of the two orders as the empirical order for the test case.\n\n- Quantify anisotropy at fixed resolution by sampling errors across multiple angles and reporting the ratio\n$$\n\\mathcal{A}^{(s)}(N;k) = \\frac{\\max_{\\alpha \\in \\mathcal{S}} E^{(s)}(N; k,\\alpha)}{\\min_{\\alpha \\in \\mathcal{S}} E^{(s)}(N; k,\\alpha)},\n$$\nwhere $\\mathcal{S}$ is a specified set of angles.\n\nUse the following scientifically consistent parameters and test suite. All lengths are in meters, wavenumbers in radians per meter, and angles in radians. The domain length is fixed to $L = 1\\,\\mathrm{m}$ in all tests.\n\n- Test case $1$ (happy path): $k = 12\\pi$, $\\alpha = \\pi/6$, base resolution $N_0 = 24$; compute empirical orders for $N \\in \\{N_0, 2N_0, 4N_0\\}$ and report a list $[p^{(5)}, p^{(9)}]$ for this case.\n- Test case $2$ (diagonal propagation): $k = 16\\pi$, $\\alpha = \\pi/4$, base resolution $N_0 = 32$; compute empirical orders as in test case $1$ and report $[p^{(5)}, p^{(9)}]$.\n- Test case $3$ (axis-aligned propagation): $k = 16\\pi$, $\\alpha = 0$, base resolution $N_0 = 32$; compute empirical orders as in test case $1$ and report $[p^{(5)}, p^{(9)}]$.\n- Test case $4$ (anisotropy assessment at fixed resolution): $k = 12\\pi$, resolution $N = 64$, and angle set $\\mathcal{S} = \\{ m \\pi/12 : m = 0,1,\\dots,11\\}$; compute and report the list $[\\mathcal{A}^{(5)}, \\mathcal{A}^{(9)}]$.\n\nProgram requirements:\n- Angles must be interpreted in radians.\n- All reported floating-point results must be printed rounded to six decimal places.\n- The final output must be a single line containing a comma-separated list with four items, where each item is a two-element list for the corresponding test case as specified above. For example, the output must have the exact format\n$[[p^{(5)}_1,p^{(9)}_1],[p^{(5)}_2,p^{(9)}_2],[p^{(5)}_3,p^{(9)}_3],[\\mathcal{A}^{(5)},\\mathcal{A}^{(9)}]]$\nwith no whitespace characters.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for instance, $[ [\\cdot,\\cdot],[\\cdot,\\cdot],[\\cdot,\\cdot],[\\cdot,\\cdot] ]$), and must contain no additional text. All numerical values in the output are unitless floats as defined above. The angle unit is radians. The domain length is $L=1\\,\\mathrm{m}$ and wavenumbers are in radians per meter. The output values must be rounded to six decimal places.",
            "solution": "The problem requires a critical comparison of two finite difference approximations of the Laplacian operator, $\\Delta = \\partial_{xx} + \\partial_{yy}$, on a two-dimensional periodic domain. The analysis will focus on their numerical accuracy, empirical order of convergence, and directional (anisotropic) error characteristics, which are fundamental topics in the verification of numerical schemes for partial differential equations, particularly in computational geophysics.\n\nFirst, we establish the theoretical properties of the two stencils. The analysis is performed in the Fourier domain, where the action of a discrete operator on a plane wave $f(x,y) = e^{i(k_x x + k_y y)}$ is represented by its symbol, $\\hat{\\Delta}_h$. The exact continuous Laplacian has the symbol $\\hat{\\Delta} = -(k_x^2+k_y^2) = -k^2$. The error of a discrete operator is given by the difference between its symbol and the exact symbol. Let $\\theta_x = k_x h$ and $\\theta_y = k_y h$, where $h$ is the grid spacing.\n\nThe five-point stencil, $\\Delta_h^{(5)}$, has the symbol:\n$$\n\\hat{\\Delta}_h^{(5)} = \\frac{2}{h^2}(\\cos(\\theta_x) + \\cos(\\theta_y) - 2)\n$$\nExpanding this symbol using the Taylor series for cosine, $\\cos\\theta = 1 - \\theta^2/2! + \\theta^4/4! - \\dots$, yields:\n$$\n\\hat{\\Delta}_h^{(5)} = -k^2 + \\frac{h^2}{12}(k_x^4 + k_y^4) + O(h^4)\n$$\nThe leading term of the truncation error is $\\frac{h^2}{12}(k_x^4 + k_y^4)$. This term is of order $O(h^2)$, so the method is second-order accurate. The error depends on the propagation direction $\\alpha$ via $k_x = k \\cos\\alpha$ and $k_y = k \\sin\\alpha$, specifically on the term $(\\cos^4\\alpha + \\sin^4\\alpha)$. This term varies from a maximum of $1$ for axis-aligned propagation ($\\alpha=0, \\pi/2, \\dots$) to a minimum of $1/2$ for diagonal propagation ($\\alpha=\\pi/4, 3\\pi/4, \\dots$), indicating significant numerical anisotropy.\n\nThe nine-point stencil, $\\Delta_h^{(9)}$, has the symbol:\n$$\n\\hat{\\Delta}_h^{(9)} = \\frac{1}{6h^2}(8\\cos(\\theta_x) + 8\\cos(\\theta_y) + 4\\cos(\\theta_x)\\cos(\\theta_y) - 20)\n$$\nA similar Taylor series expansion of this symbol reveals:\n$$\n\\hat{\\Delta}_h^{(9)} = -k^2 + \\frac{h^2}{12}(k_x^2+k_y^2)^2 + O(h^4) = -k^2 + \\frac{h^2 k^4}{12} + O(h^4)\n$$\nThe leading error term is $\\frac{h^2 k^4}{12}$. This operator is also second-order accurate, $O(h^2)$. However, its leading error term is independent of the propagation angle $\\alpha$. This indicates that the nine-point stencil is significantly more isotropic than the five-point stencil, a highly desirable property for wave propagation simulations. The numerical experiments are designed to verify these theoretical predictions.\n\nThe solution is implemented as a Python program structured as follows:\n\n1.  A function `compute_error(N, k, alpha, stencil_type)` is defined to perform the core error calculation. It takes the grid size $N$, wavenumber $k$, angle $\\alpha$, and stencil type ($5$ or $9$) as input.\n    -   It first constructs the $N \\times N$ grid over the domain $[0,L]^2$ with $L=1$.\n    -   The analytical scalar field $f_{i,j} = \\cos\\big(k (x_i \\cos \\alpha + y_j \\sin \\alpha)\\big)$ and its exact Laplacian, $-k^2 f_{i,j}$, are computed on this grid.\n    -   The discrete Laplacian, $\\Delta_h^{(s)} f_{i,j}$, is computed for the specified stencil. The periodic boundary conditions are handled efficiently using `numpy.roll`, which performs circular shifts on the grid array to access neighboring points $f_{i\\pm1, j\\pm1}$, etc.\n    -   Finally, it computes the discrete root-mean-square (RMS) error $E^{(s)}(N; k,\\alpha)$ as defined in the problem statement.\n\n2.  A function `compute_empirical_order(N0, k, alpha, stencil_type)` calculates the order of convergence.\n    -   It calls `compute_error` three times for a sequence of refining grids with sizes $N_0$, $2N_0$, and $4N_0$.\n    -   It computes two convergence rates, one from the error ratio on grids $(N_0, 2N_0)$ and another from $(2N_0, 4N_0)$, using the formula $p = \\log(E_N/E_{2N})/\\log(2)$.\n    -   It returns the average of these two rates to provide a more robust estimate of the empirical order.\n\n3.  The main `solve()` function executes the four test cases:\n    -   For test cases 1, 2, and 3, `compute_empirical_order` is called for both the $5$-point and $9$-point stencils with the specified parameters ($k, \\alpha, N_0$). The results, $[p^{(5)}, p^{(9)}]$, are stored.\n    -   For test case 4, the anisotropy is assessed. The `compute_error` function is called for a fixed resolution $N=64$ and $k=12\\pi$ across a set of angles $\\mathcal{S} = \\{m\\pi/12\\}$. The anisotropy measure $\\mathcal{A}^{(s)} = \\max(E^{(s)})/\\min(E^{(s)})$ is then computed for both stencils.\n    -   The collected results from all four test cases are formatted into a single string with the required precision and structure, and then printed. This procedure directly addresses all requirements of the problem.\n\nThis principle-based design ensures that the implementation not only produces the correct numerical values but is also grounded in a solid theoretical understanding of the underlying numerical methods being investigated. The results are expected to show convergence orders close to $2.0$ for both stencils, with a significantly lower anisotropy ratio $\\mathcal{A}^{(9)}$ compared to $\\mathcal{A}^{(5)}$, confirming the theoretical analysis.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(N, k, alpha, stencil_type):\n    \"\"\"\n    Computes the RMS error of a discrete Laplacian operator for a given plane wave.\n    \"\"\"\n    L = 1.0\n    h = L / N\n\n    # Grid generation\n    # x corresponds to columns (axis 1), y to rows (axis 0)\n    x_coords = np.arange(N) * h\n    y_coords = np.arange(N) * h\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # Scalar field\n    f = np.cos(k * (xx * np.cos(alpha) + yy * np.sin(alpha)))\n\n    # Exact Laplacian of the field\n    lap_f_exact = -k**2 * f\n\n    # Discrete Laplacian computation\n    if stencil_type == 5:\n        # Standard 5-point stencil\n        # f_{i+1,j} is f rolled left along axis=1 (x-direction)\n        f_ip1_j = np.roll(f, -1, axis=1)\n        # f_{i-1,j} is f rolled right along axis=1\n        f_im1_j = np.roll(f, 1, axis=1)\n        # f_{i,j+1} is f rolled up along axis=0 (y-direction)\n        f_i_jp1 = np.roll(f, -1, axis=0)\n        # f_{i,j-1} is f rolled down along axis=0\n        f_i_jm1 = np.roll(f, 1, axis=0)\n        \n        lap_f_discrete = (f_ip1_j + f_im1_j + f_i_jp1 + f_i_jm1 - 4 * f) / h**2\n    \n    elif stencil_type == 9:\n        # Rotated 9-point stencil\n        f_ip1_j = np.roll(f, -1, axis=1)\n        f_im1_j = np.roll(f, 1, axis=1)\n        f_i_jp1 = np.roll(f, -1, axis=0)\n        f_i_jm1 = np.roll(f, 1, axis=0)\n        \n        f_ip1_jp1 = np.roll(f, (-1, -1), axis=(0, 1))\n        f_im1_jp1 = np.roll(f, (-1, 1), axis=(0, 1))\n        f_ip1_jm1 = np.roll(f, (1, -1), axis=(0, 1))\n        f_im1_jm1 = np.roll(f, (1, 1), axis=(0, 1))\n\n        S1 = f_ip1_j + f_im1_j + f_i_jp1 + f_i_jm1\n        S2 = f_ip1_jp1 + f_im1_jp1 + f_ip1_jm1 + f_im1_jm1\n        \n        lap_f_discrete = (1 / (6 * h**2)) * (4 * S1 + S2 - 20 * f)\n    \n    else:\n        raise ValueError(\"Invalid stencil type specified. Must be 5 or 9.\")\n\n    # RMS Error calculation\n    # The term to be squared is (Delta_h f + k^2 f), which is (Delta_h f - Delta_exact f)\n    diff_sq = (lap_f_discrete - lap_f_exact)**2\n    rms_error = np.sqrt(np.mean(diff_sq))\n    return rms_error\n\ndef compute_empirical_order(N0, k, alpha, stencil_type):\n    \"\"\"\n    Computes the empirical order of convergence using a grid refinement sequence.\n    \"\"\"\n    E_N0 = compute_error(N0, k, alpha, stencil_type)\n    E_2N0 = compute_error(2 * N0, k, alpha, stencil_type)\n    E_4N0 = compute_error(4 * N0, k, alpha, stencil_type)\n    \n    # Check for non-positive errors to avoid math domain errors\n    if E_N0 = 0 or E_2N0 = 0 or E_4N0 = 0:\n        return np.nan\n\n    p1 = np.log(E_N0 / E_2N0) / np.log(2)\n    p2 = np.log(E_2N0 / E_4N0) / np.log(2)\n    \n    return (p1 + p2) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    all_results = []\n    \n    # Test Case 1: Empirical order, happy path\n    k1, alpha1, N0_1 = 12 * np.pi, np.pi / 6, 24\n    p5_1 = compute_empirical_order(N0_1, k1, alpha1, 5)\n    p9_1 = compute_empirical_order(N0_1, k1, alpha1, 9)\n    all_results.append([p5_1, p9_1])\n\n    # Test Case 2: Empirical order, diagonal propagation\n    k2, alpha2, N0_2 = 16 * np.pi, np.pi / 4, 32\n    p5_2 = compute_empirical_order(N0_2, k2, alpha2, 5)\n    p9_2 = compute_empirical_order(N0_2, k2, alpha2, 9)\n    all_results.append([p5_2, p9_2])\n\n    # Test Case 3: Empirical order, axis-aligned propagation\n    k3, alpha3, N0_3 = 16 * np.pi, 0.0, 32\n    p5_3 = compute_empirical_order(N0_3, k3, alpha3, 5)\n    p9_3 = compute_empirical_order(N0_3, k3, alpha3, 9)\n    all_results.append([p5_3, p9_3])\n\n    # Test Case 4: Anisotropy assessment\n    k4, N4 = 12 * np.pi, 64\n    angles = [m * np.pi / 12 for m in range(12)]\n    \n    errors5 = [compute_error(N4, k4, alpha, 5) for alpha in angles]\n    errors9 = [compute_error(N4, k4, alpha, 9) for alpha in angles]\n    \n    A5 = np.max(errors5) / np.min(errors5)\n    A9 = np.max(errors9) / np.min(errors9)\n    all_results.append([A5, A9])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for res_pair in all_results:\n        # Format each number to 6 decimal places and create a string like \"[val1,val2]\"\n        result_strings.append(f\"[{res_pair[0]:.6f},{res_pair[1]:.6f}]\")\n    \n    # Join the individual strings for each test case into the final output format\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The foundation of any finite-difference wave simulator lies in the accurate discretization of its spatial derivative operators. This hands-on coding exercise guides you through the implementation of second-order accurate directional derivatives on a rotated staggered grid, which are the essential building blocks for first-order systems like the acoustic wave equation. By testing your implementation against a known analytical solution, you will practice the crucial skill of code verification using the method of manufactured solutions.",
            "id": "3613900",
            "problem": "Consider a two-dimensional uniform grid used in computational geophysics with a Rotated Staggered Grid (RSG) arrangement, where a scalar field $u(x,y)$ is stored at cell centers and discrete differential operators are evaluated at staggered locations. Let the domain be periodic and rectangular with lengths $L_x$ and $L_y$ in the $x$ and $y$ directions, respectively. The grid has $N_x$ cells along $x$ and $N_y$ cells along $y$, so that the spacings are $h_x = L_x/N_x$ and $h_y = L_y/N_y$. Cell centers are located at positions $\\left((i+\\tfrac{1}{2})h_x,(j+\\tfrac{1}{2})h_y\\right)$ for integer indices $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. The $x$-faces (vertical faces) are located at positions $\\left(I h_x,(j+\\tfrac{1}{2})h_y\\right)$ with $I \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$; the $y$-faces (horizontal faces) are located at positions $\\left((i+\\tfrac{1}{2})h_x, J h_y\\right)$ with $i \\in \\{0,\\dots,N_x-1\\}$ and $J \\in \\{0,\\dots,N_y-1\\}$. All indexing is interpreted with periodic wrap-around.\n\nDefine a rotated orthonormal basis $\\{\\mathbf{e}_1,\\mathbf{e}_2\\}$ in the plane obtained by rotating the standard basis $\\{\\hat{\\mathbf{x}},\\hat{\\mathbf{y}}\\}$ by an angle $\\theta$ (in radians) such that\n$$\n\\mathbf{e}_1 = (\\cos\\theta)\\,\\hat{\\mathbf{x}} + (\\sin\\theta)\\,\\hat{\\mathbf{y}},\\qquad\n\\mathbf{e}_2 = (-\\sin\\theta)\\,\\hat{\\mathbf{x}} + (\\cos\\theta)\\,\\hat{\\mathbf{y}}.\n$$\nThe directional derivatives of a sufficiently smooth scalar field $u$ along $\\mathbf{e}_1$ and $\\mathbf{e}_2$ are\n$$\nD_{\\mathbf{e}_1} u = (\\cos\\theta)\\,\\frac{\\partial u}{\\partial x} + (\\sin\\theta)\\,\\frac{\\partial u}{\\partial y},\\qquad\nD_{\\mathbf{e}_2} u = (-\\sin\\theta)\\,\\frac{\\partial u}{\\partial x} + (\\cos\\theta)\\,\\frac{\\partial u}{\\partial y}.\n$$\nOn a staggered grid, consistent second-order accurate approximations of $\\tfrac{\\partial u}{\\partial x}$ and $\\tfrac{\\partial u}{\\partial y}$ at face locations can be defined using only cell-centered samples of $u$:\n- At an $x$-face $(I h_x,(j+\\tfrac{1}{2})h_y)$,\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x\\text{-face}} \\approx \\frac{u_{I,j} - u_{I-1,j}}{h_x},\\qquad\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{x\\text{-face}} \\approx \\frac{1}{2}\\left(\\left.\\frac{\\partial u}{\\partial y}\\right|_{i=I,j} + \\left.\\frac{\\partial u}{\\partial y}\\right|_{i=I-1,j}\\right),\n$$\nwhere the cell-centered $y$-derivative is approximated by the central difference\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{i,j} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2 h_y}.\n$$\n- At a $y$-face $\\left((i+\\tfrac{1}{2})h_x, J h_y\\right)$,\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{y\\text{-face}} \\approx \\frac{u_{i,J} - u_{i,J-1}}{h_y},\\qquad\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{y\\text{-face}} \\approx \\frac{1}{2}\\left(\\left.\\frac{\\partial u}{\\partial x}\\right|_{i,j=J} + \\left.\\frac{\\partial u}{\\partial x}\\right|_{i,j=J-1}\\right),\n$$\nwhere the cell-centered $x$-derivative is approximated by the central difference\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{i,j} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{2 h_x}.\n$$\nUsing these face-centered approximations, define rotated directional derivatives at faces as\n$$\n\\left.D_{\\mathbf{e}_1} u\\right|_{\\text{face}} \\approx (\\cos\\theta)\\,\\left.\\frac{\\partial u}{\\partial x}\\right|_{\\text{face}} + (\\sin\\theta)\\,\\left.\\frac{\\partial u}{\\partial y}\\right|_{\\text{face}},\n$$\n$$\n\\left.D_{\\mathbf{e}_2} u\\right|_{\\text{face}} \\approx (-\\sin\\theta)\\,\\left.\\frac{\\partial u}{\\partial x}\\right|_{\\text{face}} + (\\cos\\theta)\\,\\left.\\frac{\\partial u}{\\partial y}\\right|_{\\text{face}}.\n$$\n\nIn this problem, you must:\n- Derive the above discrete face-centered formulas starting from fundamental definitions of directional derivatives and Taylor expansions, ensuring they achieve second-order accuracy at the corresponding face locations.\n- Implement a program that, for a given periodic analytic scalar field\n$$\nu(x,y) = \\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\nevaluates the exact directional derivatives $D_{\\mathbf{e}_1} u$ and $D_{\\mathbf{e}_2} u$ at all face locations and compares them to the discrete rotated face-centered approximations. Use the analytic partial derivatives\n$$\n\\frac{\\partial u}{\\partial x}(x,y) = \\frac{2\\pi m_x}{L_x}\\,\\cos\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\n$$\n\\frac{\\partial u}{\\partial y}(x,y) = -\\frac{2\\pi m_y}{L_y}\\,\\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\sin\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right).\n$$\nCompute the maximum absolute pointwise error across all faces for both $\\left.D_{\\mathbf{e}_1} u\\right|_{\\text{face}}$ and $\\left.D_{\\mathbf{e}_2} u\\right|_{\\text{face}}$, and report, for each test case, the single float equal to the maximum of these two facewise maxima. Angles must be in radians. Express each reported error in $\\text{m}^{-1}$ (inverse meters), rounded by the default floating-point representation of the programming language.\n\nTest Suite:\n- Case $1$: $N_x=64$, $N_y=64$, $L_x=1.0$ $\\text{m}$, $L_y=1.0$ $\\text{m}$, $m_x=3$, $m_y=2$, $\\theta=0.0$ $\\text{rad}$.\n- Case $2$: $N_x=64$, $N_y=64$, $L_x=1.0$ $\\text{m}$, $L_y=1.0$ $\\text{m}$, $m_x=7$, $m_y=5$, $\\theta=\\pi/4$ $\\text{rad}$.\n- Case $3$: $N_x=32$, $N_y=48$, $L_x=2.0$ $\\text{m}$, $L_y=1.5$ $\\text{m}$, $m_x=4$, $m_y=1$, $\\theta=\\pi/3$ $\\text{rad}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$), where each $\\text{result}_k$ is the maximum absolute error in $\\text{m}^{-1}$ for the corresponding test case.",
            "solution": "The starting point is the definition of directional derivatives and the rotation of axes. For a scalar field $u(x,y)$, the gradient is $\\nabla u = \\left(\\tfrac{\\partial u}{\\partial x},\\tfrac{\\partial u}{\\partial y}\\right)$ and the directional derivative along a unit vector $\\mathbf{e}$ is $D_{\\mathbf{e}} u = \\nabla u \\cdot \\mathbf{e}$. If the basis $\\{\\mathbf{e}_1,\\mathbf{e}_2\\}$ is obtained by rotating the standard basis $\\{\\hat{\\mathbf{x}},\\hat{\\mathbf{y}}\\}$ by angle $\\theta$, then the rotation matrix is\n$$\n\\mathbf{R}(\\theta)=\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta\\\\\n-\\sin\\theta  \\cos\\theta\n\\end{pmatrix},\n$$\nwhich maps vector components from the rotated basis to the original basis. The unit vectors are $\\mathbf{e}_1=(\\cos\\theta,\\sin\\theta)$ and $\\mathbf{e}_2=(-\\sin\\theta,\\cos\\theta)$. Therefore,\n$$\nD_{\\mathbf{e}_1}u = \\nabla u \\cdot \\mathbf{e}_1 = (\\cos\\theta)\\,\\frac{\\partial u}{\\partial x} + (\\sin\\theta)\\,\\frac{\\partial u}{\\partial y},\n$$\n$$\nD_{\\mathbf{e}_2}u = \\nabla u \\cdot \\mathbf{e}_2 = (-\\sin\\theta)\\,\\frac{\\partial u}{\\partial x} + (\\cos\\theta)\\,\\frac{\\partial u}{\\partial y}.\n$$\n\nOn a staggered grid, $u$ is stored at cell centers $\\left((i+\\tfrac{1}{2})h_x,(j+\\tfrac{1}{2})h_y\\right)$, while derivatives are evaluated at faces. To construct second-order accurate approximations at faces, we use Taylor series expansions. Consider an $x$-face located at $(x_f,y_f)=(I h_x,(j+\\tfrac{1}{2})h_y)$, with adjacent cell centers at $(x_f-\\tfrac{h_x}{2},y_f)$ and $(x_f+\\tfrac{h_x}{2},y_f)$. A Taylor expansion of $u$ about $(x_f,y_f)$ gives:\n$$\nu\\left(x_f+\\tfrac{h_x}{2},y_f\\right) = u(x_f,y_f) + \\tfrac{h_x}{2}\\left.\\frac{\\partial u}{\\partial x}\\right|_{(x_f,y_f)} + \\tfrac{h_x^2}{8}\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_f,y_f)} + \\mathcal{O}(h_x^3),\n$$\n$$\nu\\left(x_f-\\tfrac{h_x}{2},y_f\\right) = u(x_f,y_f) - \\tfrac{h_x}{2}\\left.\\frac{\\partial u}{\\partial x}\\right|_{(x_f,y_f)} + \\tfrac{h_x^2}{8}\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_f,y_f)} + \\mathcal{O}(h_x^3).\n$$\nSubtracting the two and dividing by $h_x$ yields\n$$\n\\frac{u\\left(x_f+\\tfrac{h_x}{2},y_f\\right) - u\\left(x_f-\\tfrac{h_x}{2},y_f\\right)}{h_x} = \\left.\\frac{\\partial u}{\\partial x}\\right|_{(x_f,y_f)} + \\mathcal{O}(h_x^2),\n$$\nwhich is the standard midpoint central difference yielding second-order accuracy. Identifying $u\\left(x_f+\\tfrac{h_x}{2},y_f\\right)$ with $u_{I,j}$ and $u\\left(x_f-\\tfrac{h_x}{2},y_f\\right)$ with $u_{I-1,j}$ gives\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x\\text{-face}} \\approx \\frac{u_{I,j} - u_{I-1,j}}{h_x}.\n$$\n\nFor $\\left.\\tfrac{\\partial u}{\\partial y}\\right|_{x\\text{-face}}$ at $(x_f,y_f)$, we cannot directly apply a central difference in $y$ because $u$ is stored only at cell centers offset in $x$. Instead, we approximate $\\left.\\tfrac{\\partial u}{\\partial y}\\right|_{(x_f,y_f)}$ by averaging the central differences in $y$ at the two adjacent cell centers. Letting $y_c=y_f$ and $x_{c,\\pm}=x_f\\pm\\tfrac{h_x}{2}$, we have second-order accurate approximations at each adjacent center:\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_{c,+},y_c)} \\approx \\frac{u(x_{c,+},y_c+\\tfrac{h_y}{2}) - u(x_{c,+},y_c-\\tfrac{h_y}{2})}{h_y},\n$$\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_{c,-},y_c)} \\approx \\frac{u(x_{c,-},y_c+\\tfrac{h_y}{2}) - u(x_{c,-},y_c-\\tfrac{h_y}{2})}{h_y}.\n$$\nA Taylor expansion in $x$ around $(x_f,y_f)$ shows that\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_{c,\\pm},y_c)} = \\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_f,y_f)} \\pm \\tfrac{h_x}{2}\\left.\\frac{\\partial^2 u}{\\partial x\\,\\partial y}\\right|_{(x_f,y_f)} + \\mathcal{O}(h_x^2).\n$$\nAveraging the two cancels the first-order term and yields a second-order approximation:\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{x\\text{-face}} \\approx \\frac{1}{2}\\left(\\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_{c,+},y_c)} + \\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_{c,-},y_c)}\\right) = \\left.\\frac{\\partial u}{\\partial y}\\right|_{(x_f,y_f)} + \\mathcal{O}(h_x^2 + h_y^2).\n$$\nIn discrete terms,\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{x\\text{-face}} \\approx \\frac{1}{2}\\left(\\frac{u_{I,j+1} - u_{I,j-1}}{2 h_y} + \\frac{u_{I-1,j+1} - u_{I-1,j-1}}{2 h_y}\\right) = \\frac{(u_{I,j+1} - u_{I,j-1}) + (u_{I-1,j+1} - u_{I-1,j-1})}{4 h_y}.\n$$\n\nBy symmetry, at a $y$-face $(x_f,y_f)=((i+\\tfrac{1}{2})h_x,J h_y)$ we have\n$$\n\\left.\\frac{\\partial u}{\\partial y}\\right|_{y\\text{-face}} \\approx \\frac{u_{i,J} - u_{i,J-1}}{h_y},\n$$\nand we approximate $\\left.\\tfrac{\\partial u}{\\partial x}\\right|_{y\\text{-face}}$ by averaging the cell-centered $x$-derivative on the two adjacent cell centers above and below:\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{y\\text{-face}} \\approx \\frac{1}{2}\\left(\\frac{u_{i+1,J} - u_{i-1,J}}{2 h_x} + \\frac{u_{i+1,J-1} - u_{i-1,J-1}}{2 h_x}\\right) = \\frac{(u_{i+1,J} - u_{i-1,J}) + (u_{i+1,J-1} - u_{i-1,J-1})}{4 h_x}.\n$$\nThese constructions are consistent with second-order accuracy because they use midpoint central differences and cancellation of odd-order error terms via averaging.\n\nThe rotated face-centered directional derivatives are then formed by linear combinations with $\\cos\\theta$ and $\\sin\\theta$, which preserves second-order accuracy because linear combinations of second-order accurate approximations remain second-order accurate.\n\nFor an analytic periodic field\n$$\nu(x,y) = \\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\nthe exact partial derivatives are\n$$\n\\frac{\\partial u}{\\partial x}(x,y) = \\frac{2\\pi m_x}{L_x}\\,\\cos\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\n$$\n\\frac{\\partial u}{\\partial y}(x,y) = -\\frac{2\\pi m_y}{L_y}\\,\\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\sin\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\nso the exact directional derivatives are\n$$\nD_{\\mathbf{e}_1} u(x,y) = (\\cos\\theta)\\,\\frac{2\\pi m_x}{L_x}\\,\\cos\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right) - (\\sin\\theta)\\,\\frac{2\\pi m_y}{L_y}\\,\\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\sin\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right),\n$$\n$$\nD_{\\mathbf{e}_2} u(x,y) = -(\\sin\\theta)\\,\\frac{2\\pi m_x}{L_x}\\,\\cos\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\cos\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right) - (\\cos\\theta)\\,\\frac{2\\pi m_y}{L_y}\\,\\sin\\!\\left(\\frac{2\\pi m_x}{L_x}\\,x\\right)\\,\\sin\\!\\left(\\frac{2\\pi m_y}{L_y}\\,y\\right).\n$$\n\nAlgorithmic design:\n- Construct the cell-centered coordinate arrays and evaluate $u_{i,j}$.\n- Compute cell-centered central differences for $\\left.\\tfrac{\\partial u}{\\partial x}\\right|_{i,j}$ and $\\left.\\tfrac{\\partial u}{\\partial y}\\right|_{i,j}$ via periodic rolls.\n- Form face-centered derivatives using the above averaging formulas:\n  - At $x$-faces: $\\left.\\tfrac{\\partial u}{\\partial x}\\right|_{x\\text{-face}}$ via a midpoint difference of adjacent cell centers; $\\left.\\tfrac{\\partial u}{\\partial y}\\right|_{x\\text{-face}}$ via averaging of cell-centered $y$-derivatives at the adjacent centers.\n  - At $y$-faces: $\\left.\\tfrac{\\partial u}{\\partial y}\\right|_{y\\text{-face}}$ via a midpoint difference of adjacent cell centers; $\\left.\\tfrac{\\partial u}{\\partial x}\\right|_{y\\text{-face}}$ via averaging of cell-centered $x$-derivatives at the adjacent centers.\n- Combine to obtain discrete $\\left.D_{\\mathbf{e}_1} u\\right|_{\\text{face}}$ and $\\left.D_{\\mathbf{e}_2} u\\right|_{\\text{face}}$.\n- Evaluate exact $D_{\\mathbf{e}_1} u$ and $D_{\\mathbf{e}_2} u$ at the corresponding face coordinates.\n- Compute the pointwise absolute errors, take the maxima over all $x$-faces and $y$-faces for each rotated direction, and report the single float equal to the maximum across both directions. This float has units $\\text{m}^{-1}$ because $u$ is dimensionless and derivatives scale as inverse length.\n\nThe test suite explores:\n- A baseline rotation $\\theta=0$ $\\text{rad}$ and moderate wavenumbers ($m_x=3$, $m_y=2$) on an isotropic grid ($N_x=N_y=64$, $L_x=L_y=1.0$ $\\text{m}$).\n- A nontrivial rotation $\\theta=\\pi/4$ $\\text{rad}$ with higher wavenumbers ($m_x=7$, $m_y=5$), testing dispersion sensitivity on the same grid.\n- An anisotropic grid ($N_x=32$, $N_y=48$, $L_x=2.0$ $\\text{m}$, $L_y=1.5$ $\\text{m}$) and rotation $\\theta=\\pi/3$ $\\text{rad}$ with ($m_x=4$, $m_y=1$), testing accuracy under non-square cells.\n\nThe program outputs a single line containing the three maximum absolute errors in $\\text{m}^{-1}$ for the three cases, in the specified bracketed comma-separated format.",
            "answer": "```python\nimport numpy as np\n\ndef rotated_face_errors(Nx, Ny, Lx, Ly, mx, my, theta):\n    # Grid spacings\n    hx = Lx / Nx\n    hy = Ly / Ny\n\n    # Cell-centered coordinates\n    x_c = (np.arange(Nx) + 0.5) * hx\n    y_c = (np.arange(Ny) + 0.5) * hy\n    Xc, Yc = np.meshgrid(x_c, y_c, indexing='ij')\n\n    # Scalar field u at cell centers\n    kx = 2 * np.pi * mx / Lx\n    ky = 2 * np.pi * my / Ly\n    u = np.sin(kx * Xc) * np.cos(ky * Yc)\n\n    # Cell-centered central derivatives\n    # dudx at cell centers\n    u_ip = np.roll(u, -1, axis=0)\n    u_im = np.roll(u, 1, axis=0)\n    dudx_cc = (u_ip - u_im) / (2 * hx)\n    # dudy at cell centers\n    u_jp = np.roll(u, -1, axis=1)\n    u_jm = np.roll(u, 1, axis=1)\n    dudy_cc = (u_jp - u_jm) / (2 * hy)\n\n    # Face-centered derivatives at x-faces (shape Nx x Ny)\n    # x-face locations: (I*hx, (j+0.5)*hy)\n    # dudx at x-faces: midpoint difference of adjacent cell centers\n    dudx_xf = (u - np.roll(u, 1, axis=0)) / hx\n    # dudy at x-faces: average of cell-centered dudy at i and i-1\n    dudy_xf = 0.5 * (dudy_cc + np.roll(dudy_cc, 1, axis=0))\n\n    # Face-centered derivatives at y-faces (shape Nx x Ny)\n    # y-face locations: ((i+0.5)*hx, J*hy)\n    # dudy at y-faces: midpoint difference of adjacent cell centers\n    dudy_yf = (u - np.roll(u, 1, axis=1)) / hy\n    # dudx at y-faces: average of cell-centered dudx at j and j-1\n    dudx_yf = 0.5 * (dudx_cc + np.roll(dudx_cc, 1, axis=1))\n\n    # Rotated directional derivatives at faces: discrete approximations\n    cth = np.cos(theta)\n    sth = np.sin(theta)\n    # D_e1 at faces\n    De1_xf = cth * dudx_xf + sth * dudy_xf\n    De1_yf = cth * dudx_yf + sth * dudy_yf\n    # D_e2 at faces\n    De2_xf = -sth * dudx_xf + cth * dudy_xf\n    De2_yf = -sth * dudx_yf + cth * dudy_yf\n\n    # Exact derivatives at face coordinates\n    # x-face coordinates\n    Xx = (np.arange(Nx)) * hx\n    Yx = (np.arange(Ny) + 0.5) * hy\n    Xxg, Yxg = np.meshgrid(Xx, Yx, indexing='ij')\n    # y-face coordinates\n    Xy = (np.arange(Nx) + 0.5) * hx\n    Yy = (np.arange(Ny)) * hy\n    Xyg, Yyg = np.meshgrid(Xy, Yy, indexing='ij')\n\n    # Exact partials\n    dudx_exact_xf = (kx) * np.cos(kx * Xxg) * np.cos(ky * Yxg)\n    dudy_exact_xf = -(ky) * np.sin(kx * Xxg) * np.sin(ky * Yxg)\n\n    dudx_exact_yf = (kx) * np.cos(kx * Xyg) * np.cos(ky * Yyg)\n    dudy_exact_yf = -(ky) * np.sin(kx * Xyg) * np.sin(ky * Yyg)\n\n    # Exact rotated directional derivatives at faces\n    De1_exact_xf = cth * dudx_exact_xf + sth * dudy_exact_xf\n    De1_exact_yf = cth * dudx_exact_yf + sth * dudy_exact_yf\n\n    De2_exact_xf = -sth * dudx_exact_xf + cth * dudy_exact_xf\n    De2_exact_yf = -sth * dudx_exact_yf + cth * dudy_exact_yf\n\n    # Errors\n    err_De1_xf = np.abs(De1_xf - De1_exact_xf)\n    err_De1_yf = np.abs(De1_yf - De1_exact_yf)\n    err_De2_xf = np.abs(De2_xf - De2_exact_xf)\n    err_De2_yf = np.abs(De2_yf - De2_exact_yf)\n\n    # Max errors across all faces\n    max_err_De1 = max(err_De1_xf.max(), err_De1_yf.max())\n    max_err_De2 = max(err_De2_xf.max(), err_De2_yf.max())\n\n    # Report the maximum across both rotated directions, in 1/m\n    return float(max(max_err_De1, max_err_De2))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Nx, Ny, Lx [m], Ly [m], mx, my, theta [rad])\n    test_cases = [\n        (64, 64, 1.0, 1.0, 3, 2, 0.0),\n        (64, 64, 1.0, 1.0, 7, 5, np.pi/4),\n        (32, 48, 2.0, 1.5, 4, 1, np.pi/3),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Lx, Ly, mx, my, theta = case\n        result = rotated_face_errors(Nx, Ny, Lx, Ly, mx, my, theta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After implementing individual operators, it is essential to analyze the behavior of the complete numerical scheme. This exercise challenges you to derive the discrete dispersion relation for a full acoustic wave simulation using a second-order rotated staggered-grid finite-difference time-domain (FDTD) scheme. This type of plane-wave analysis is fundamental to understanding how the numerical phase and group velocities depend on wavenumber and propagation direction, allowing you to predict and quantify the numerical dispersion of a simulation.",
            "id": "3613907",
            "problem": "Consider a two-dimensional homogeneous, isotropic acoustic medium with constant density $\\rho$ and constant sound speed $c$. The acoustic field is governed by the first-order velocity-pressure formulation of the acoustic wave equation,\n$$\n\\partial_{t} p = -\\kappa \\nabla \\cdot \\mathbf{v}, \\qquad \\partial_{t} \\mathbf{v} = -\\frac{1}{\\rho} \\nabla p,\n$$\nwhere $p$ is pressure, $\\mathbf{v}$ is particle velocity, and $\\kappa = \\rho c^{2}$ is the bulk modulus. The domain is discretized on a uniform Cartesian grid with spacing $h$ in both $x$ and $y$, but the finite-difference operators are constructed in a rotated staggered-grid fashion: define orthonormal axes $\\mathbf{e}_{u}$ and $\\mathbf{e}_{v}$ obtained by rotating the Cartesian axes by an angle $\\alpha$, with\n$$\n\\mathbf{e}_{u} = (\\cos \\alpha, \\sin \\alpha), \\qquad \\mathbf{e}_{v} = (-\\sin \\alpha, \\cos \\alpha).\n$$\nLet $v_{u} = \\mathbf{v} \\cdot \\mathbf{e}_{u}$ and $v_{v} = \\mathbf{v} \\cdot \\mathbf{e}_{v}$. Use a standard second-order staggered-in-time and staggered-in-space Finite-Difference Time-Domain (FDTD) scheme: $p$ is located at cell centers at integer times $t^{n} = n \\Delta t$, and $v_{u}, v_{v}$ are located at appropriately staggered spatial positions and at half-integer times $t^{n+\\frac{1}{2}} = (n+\\frac{1}{2}) \\Delta t$. Spatial derivatives are approximated by centered differences consistent with the staggered layout. Denote the discrete directional derivative operators along $x$ and $y$ by $D_{x}$ and $D_{y}$, and define the rotated directional derivatives\n$$\nD_{u} = \\cos \\alpha \\, D_{x} + \\sin \\alpha \\, D_{y}, \\qquad D_{v} = -\\sin \\alpha \\, D_{x} + \\cos \\alpha \\, D_{y}.\n$$\nThe discrete update equations are\n$$\nv_{u}^{\\,n+\\frac{1}{2}} = v_{u}^{\\,n-\\frac{1}{2}} - \\frac{\\Delta t}{\\rho} \\, D_{u} p^{\\,n}, \\qquad\nv_{v}^{\\,n+\\frac{1}{2}} = v_{v}^{\\,n-\\frac{1}{2}} - \\frac{\\Delta t}{\\rho} \\, D_{v} p^{\\,n},\n$$\n$$\np^{\\,n+1} = p^{\\,n} - \\kappa \\Delta t \\left( D_{u} v_{u}^{\\,n+\\frac{1}{2}} + D_{v} v_{v}^{\\,n+\\frac{1}{2}} \\right).\n$$\nFor plane-wave analysis on the staggered grid, the centered difference acting between staggered locations has the well-tested discrete Fourier symbol: for a plane wave with wavenumber components $k_{x}$ and $k_{y}$,\n$$\nD_{x} \\;\\longleftrightarrow\\; i \\,\\hat{k}_{x}, \\quad \\hat{k}_{x} = \\frac{2}{h} \\sin\\!\\left(\\frac{k_{x} h}{2}\\right), \\qquad\nD_{y} \\;\\longleftrightarrow\\; i \\,\\hat{k}_{y}, \\quad \\hat{k}_{y} = \\frac{2}{h} \\sin\\!\\left(\\frac{k_{y} h}{2}\\right).\n$$\nAssume a monochromatic plane wave of the form $p(\\mathbf{x},t) = P \\exp\\!\\left( i (k_{x} x + k_{y} y - \\omega t) \\right)$, with propagation angle $\\theta$ defined by $k_{x} = k \\cos \\theta$ and $k_{y} = k \\sin \\theta$. Starting from the governing equations and the discrete scheme specified above, derive the exact discrete dispersion relation and solve it to obtain the numerical angular frequency $\\omega$ as an analytic function of $k$, $\\theta$, $c$, $h$, and $\\Delta t$ (keep $\\alpha$ symbolic and do not assume a particular rotation). Express the final answer for $\\omega$ in radians per second. The angle $\\theta$ must be treated in radians. Provide your final expression in closed form. No numerical evaluation is required, and no rounding is needed.",
            "solution": "The goal is to derive the discrete dispersion relation, which connects the numerical angular frequency $\\omega$ to the physical wavenumber $k$ and propagation angle $\\theta$. This is accomplished through a plane-wave (or von Neumann) analysis, where we substitute a discrete plane-wave ansatz into the FDTD update equations.\n\nLet the discrete plane-wave solutions for pressure $p$ and the rotated velocity components $v_u, v_v$ be of the form:\n$$\np_{j,l}^n = P \\, e^{i(k_x x_j + k_y y_l - \\omega t^n)}\n$$\n$$\n(v_u)_{j,l}^{n \\pm 1/2} = V_u \\, e^{i(k_x x_j' + k_y y_l' - \\omega t^{n \\pm 1/2})}\n$$\nwhere $P$ and $V_u$ are the complex amplitudes, and $(x_j', y_l')$ denote the staggered spatial locations.\n\nWhen the discrete spatial derivative operators act on these plane waves, they become multiplications by their Fourier symbols. For the rotated derivatives $D_u$ and $D_v$:\n$$\nD_u \\leftrightarrow i\\hat{k}_u = i(\\hat{k}_x \\cos\\alpha + \\hat{k}_y \\sin\\alpha)\n$$\n$$\nD_v \\leftrightarrow i\\hat{k}_v = i(-\\hat{k}_x \\sin\\alpha + \\hat{k}_y \\cos\\alpha)\n$$\nwhere $\\hat{k}_x = \\frac{2}{h} \\sin(k_x h/2)$ and $\\hat{k}_y = \\frac{2}{h} \\sin(k_y h/2)$.\n\nThe discrete time derivative (a centered difference for a leapfrog scheme) acting on a quantity $f^n$ staggered in time as $f^{n\\pm 1/2}$ becomes:\n$$\n\\frac{f^{n+1/2} - f^{n-1/2}}{\\Delta t} \\leftrightarrow \\frac{F e^{-i\\omega(n+1/2)\\Delta t} - F e^{-i\\omega(n-1/2)\\Delta t}}{\\Delta t} = \\frac{F e^{-i\\omega n \\Delta t}(e^{-i\\omega\\Delta t/2} - e^{i\\omega\\Delta t/2})}{\\Delta t} = -i \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) F e^{-i\\omega n \\Delta t}\n$$\nSo, the time derivative operator transforms as $\\partial_t \\leftrightarrow -i \\frac{2}{\\Delta t}\\sin(\\frac{\\omega\\Delta t}{2})$.\n\nApplying these transformations to the FDTD equations gives a system of algebraic equations for the amplitudes $P, V_u, V_v$:\n1. From the $v_u$ update:\n   $$ -i \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) V_u = -\\frac{1}{\\rho} (i\\hat{k}_u) P \\implies V_u = \\frac{\\Delta t \\hat{k}_u}{2\\rho\\sin(\\omega\\Delta t/2)} P $$\n2. From the $v_v$ update:\n   $$ -i \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) V_v = -\\frac{1}{\\rho} (i\\hat{k}_v) P \\implies V_v = \\frac{\\Delta t \\hat{k}_v}{2\\rho\\sin(\\omega\\Delta t/2)} P $$\n3. From the $p$ update:\n   $$ -i \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) P = -\\kappa (i\\hat{k}_u V_u + i\\hat{k}_v V_v) \\implies \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) P = \\kappa (\\hat{k}_u V_u + \\hat{k}_v V_v) $$\n\nSubstitute the expressions for $V_u$ and $V_v$ into the third equation:\n$$\n\\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) P = \\kappa \\left( \\hat{k}_u \\frac{\\Delta t \\hat{k}_u P}{2\\rho\\sin(\\omega\\Delta t/2)} + \\hat{k}_v \\frac{\\Delta t \\hat{k}_v P}{2\\rho\\sin(\\omega\\Delta t/2)} \\right)\n$$\nAssuming a non-trivial wave ($P \\neq 0$), we cancel $P$ and rearrange the terms:\n$$\n\\left( \\frac{2}{\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) \\right)^2 = \\frac{\\kappa}{\\rho} (\\hat{k}_u^2 + \\hat{k}_v^2)\n$$\nA key property of the rotated operators is that the sum of their squared symbols is invariant under rotation:\n$$\n\\hat{k}_u^2 + \\hat{k}_v^2 = (\\hat{k}_x \\cos\\alpha + \\hat{k}_y \\sin\\alpha)^2 + (-\\hat{k}_x \\sin\\alpha + \\hat{k}_y \\cos\\alpha)^2 = \\hat{k}_x^2 + \\hat{k}_y^2\n$$\nThus, the dispersion relation is independent of the grid rotation angle $\\alpha$. Using $\\kappa = \\rho c^2$, we get:\n$$\n\\frac{4}{(\\Delta t)^2}\\sin^2\\left(\\frac{\\omega\\Delta t}{2}\\right) = c^2 (\\hat{k}_x^2 + \\hat{k}_y^2)\n$$\nSubstitute the expressions for $\\hat{k}_x$ and $\\hat{k}_y$:\n$$\n\\sin^2\\left(\\frac{\\omega\\Delta t}{2}\\right) = \\frac{c^2 (\\Delta t)^2}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right]\n$$\nTaking the positive square root and solving for $\\omega$:\n$$\n\\omega = \\frac{2}{\\Delta t} \\arcsin\\left( \\frac{c \\Delta t}{h} \\sqrt{ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) } \\right)\n$$\nFinally, substituting $k_x = k \\cos\\theta$ and $k_y = k \\sin\\theta$:\n$$\n\\omega = \\frac{2}{\\Delta t} \\arcsin\\left( \\frac{c \\Delta t}{h} \\sqrt{ \\sin^2\\left(\\frac{k h \\cos\\theta}{2}\\right) + \\sin^2\\left(\\frac{k h \\sin\\theta}{2}\\right) } \\right)\n$$\nThis is the final expression for the numerical frequency, which reveals how it deviates from the ideal physical relation $\\omega = ck$ due to discretization in both space and time.",
            "answer": "$$\\boxed{\\frac{2}{\\Delta t} \\arcsin\\left( \\frac{c \\Delta t}{h} \\sqrt{ \\sin^2\\left(\\frac{k h \\cos\\theta}{2}\\right) + \\sin^2\\left(\\frac{k h \\sin\\theta}{2}\\right) } \\right)}$$"
        }
    ]
}