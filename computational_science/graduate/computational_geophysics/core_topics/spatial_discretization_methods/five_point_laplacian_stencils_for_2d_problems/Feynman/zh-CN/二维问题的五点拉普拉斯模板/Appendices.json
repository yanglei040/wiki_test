{
    "hands_on_practices": [
        {
            "introduction": "任何数值建模工作的第一步都是从基本原理出发，构建一个基础求解器，并严格验证其行为符合理论预期。本练习将指导你完成这一基本流程。你将从泰勒展开式开始，亲手推导出二维拉普拉斯算子的五点差分格式，并使用“人造解方法”（Method of Manufactured Solutions, MMS）来验证你的代码实现的正确性与收敛阶，这是计算科学家必须掌握的核心技能 。",
            "id": "3596385",
            "problem": "考虑一个定义在矩形域 $\\Omega = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$ 上的二维标量场 $u(x,y)$。其控制偏微分方程(PDE)是具有齐次椭圆性的泊松方程，\n$$\n- \\nabla^2 u(x,y) = q(x,y),\n$$\n其中 $\\nabla^2$ 是拉普拉斯算子。在人造解法（MMS）中，人们选择一个解析的 $u(x,y)$，并通过将微分算子应用于 $u(x,y)$ 来定义 $q(x,y)$，使得解析的 $u(x,y)$ 成为连续偏微分方程的精确解。通过在 $\\partial \\Omega$ 上将 $u(x,y)$ 精确设置为人造解来施加狄利克雷边界条件。所有量均为无量纲。\n\n您将推导、实现并验证在具有可能各向异性间距的一般矩形域上，结构化网格的五点拉普拉斯模板。从以下基本依据开始：\n- 笛卡尔坐标系中拉普拉斯算子的定义，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- 从网格点周围的泰勒展开式推导出的，一维二阶导数的二阶中心差分近似。\n\n任务：\n1. 在间距为 $h_x$ 和 $h_y$ 的矩形网格上，推导内部网格节点 $(x_i,y_j)$ 处 $-\\nabla^2 u$ 的五点离散近似。仅使用泰勒展开式和 $\\nabla^2$ 的定义；不要使用预先组合或记忆的模板公式。\n2. 表达由此产生的、组装了所有内部节点的线性代数系统，并描述 $\\partial \\Omega$ 上的狄利克雷边界值如何进入右侧项。\n3. 实现一个程序，对于下面的每个测试用例，该程序构建离散算子，施加与人造解一致的狄利克雷边界条件，求解内部未知数的线性系统，计算离散 $L^2$-误差范数，\n$$\n\\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2},\n$$\n并报告观察到的网格收敛率\n$$\np = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)},\n$$\n其中“粗糙”和“精细”指的是通过将 $N_x$ 和 $N_y$ 加倍而得到的两个连续加密的网格。\n\n实现细节：\n- 使用结构化网格，沿 $x$ 方向有 $N_x$ 个内部点，沿 $y$ 方向有 $N_y$ 个内部点。间距为 $h_x = \\frac{x_{\\max} - x_{\\min}}{N_x + 1}$ 和 $h_y = \\frac{y_{\\max} - y_{\\min}}{N_y + 1}$。内部节点位于 $x_i = x_{\\min} + i h_x$ 和 $y_j = y_{\\min} + j h_y$，其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_y$。\n- 仅为内部节点组装线性系统，并酌情将狄利克雷边界值计入右侧项。\n- 对于每个测试用例，使用一个粗糙网格和一个精细网格（后者在每个方向上的内部点数是前者的两倍）来计算观察到的收敛率 $p$。\n\n测试套件：\n- 测试用例 $1$（理想情况，方形域上的各向同性网格）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 源项：$q_1(x,y) = -\\nabla^2 u_1(x,y)$。\n  - 网格：$(N_x,N_y) = (16,16)$ 和 $(32,32)$。\n- 测试用例 $2$（方形域上的各向异性网格间距）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_2(x,y) = e^{x}\\sin(2\\pi y)$。\n  - 源项：$q_2(x,y) = -\\nabla^2 u_2(x,y)$。\n  - 网格：$(N_x,N_y) = (24,12)$ 和 $(48,24)$。\n- 测试用例 $3$（各向异性域和网格）：\n  - 域：$\\Omega = [0,2] \\times [0,1]$。\n  - 人造解：$u_3(x,y) = \\cos(2\\pi x)\\cos(\\pi y)$。\n  - 源项：$q_3(x,y) = -\\nabla^2 u_3(x,y)$。\n  - 网格：$(N_x,N_y) = (60,20)$ 和 $(120,40)$。\n- 测试用例 $4$（使用非常粗糙网格的边缘情况）：\n  - 域：$\\Omega = [0,1] \\times [0,1]$。\n  - 人造解：$u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n  - 源项：$q_1(x,y) = -\\nabla^2 u_1(x,y)$。\n  - 网格：$(N_x,N_y) = (4,4)$ 和 $(8,8)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的观察收敛率，形式为逗号分隔的列表并用方括号括起来，每个速率四舍五入到四位小数，例如 $[p_1,p_2,p_3,p_4]$。",
            "solution": "本回應遵循用戶的要求，首先推导了二维负拉普拉斯算子的五点有限差分模板，然后描述了相应线性系统的组装，最后详细说明了用于验证该方法收敛率的实现。\n\n### 1. 五点模板的推导\n\n任务是在一个间距为 $h_x$ 和 $h_y$ 的结构化矩形网格的内部网格节点 $(x_i, y_j)$ 处，找到算子 $-\\nabla^2 u$ 的离散近似。推导从一个足够光滑的函数 $f(z)$ 在点 $z$ 周围的泰勒级数展开开始。\n\n考虑 $u(x, y)$ 在 $x$ 方向上围绕点 $(x_i, y_j)$ 的泰勒展开：\n$$u(x_i \\pm h_x, y_j) = u(x_i, y_j) \\pm h_x \\frac{\\partial u}{\\partial x}\\bigg|_{(x_i,y_j)} + \\frac{h_x^2}{2!} \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\pm \\frac{h_x^3}{3!} \\frac{\\partial^3 u}{\\partial x^3}\\bigg|_{(x_i,y_j)} + \\frac{h_x^4}{4!} \\frac{\\partial^4 u}{\\partial x^4}\\bigg|_{(x_i,y_j)} + O(h_x^5)$$\n令 $u_{i,j}$ 表示函数 $u$ 在网格点 $(x_i, y_j)$ 处的值。$x$ 方向上相邻点的展开式为：\n$$u_{i+1,j} = u(x_i+h_x, y_j) = u_{i,j} + h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\n$$u_{i-1,j} = u(x_i-h_x, y_j) = u_{i,j} - h_x \\frac{\\partial u}{\\partial x} + \\frac{h_x^2}{2} \\frac{\\partial^2 u}{\\partial x^2} - \\frac{h_x^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + O(h_x^4)$$\n将这两个方程相加可以消除奇数阶导数项：\n$$u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h_x^2 \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h_x^4}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^6)$$\n重新整理以求解关于 $x$ 的二阶偏导数，得到二阶中心差分公式：\n$$\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} - \\frac{h_x^2}{12} \\frac{\\partial^4 u}{\\partial x^4} + O(h_x^4) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + O(h_x^2)$$\n对 $y$ 方向进行相同的推导，得到关于 $y$ 的二阶偏导数的近似值：\n$$\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} + O(h_y^2)$$\n笛卡尔坐标系中的拉普拉斯算子是 $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。通过代入有限差分近似，我们得到在 $(x_i,y_j)$ 处的离散拉普拉斯算子：\n$$\\nabla^2 u \\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}$$\n控制偏微分方程为 $-\\nabla^2 u = q$。代入离散算子，得到每个内部节点 $(i,j)$ 处的方程：\n$$-\\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} \\right) = q_{i,j}$$\n按网格位置对各项进行分组，我们得到 $-\\nabla^2 u$ 的五点模板方程：\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{i,j} - \\frac{1}{h_x^2}u_{i-1,j} - \\frac{1}{h_x^2}u_{i+1,j} - \\frac{1}{h_y^2}u_{i,j-1} - \\frac{1}{h_y^2}u_{i,j+1} = q_{i,j}$$\n该方程将中心节点 $(i,j)$ 的值与其四个直接相邻点耦合起来，形成一个五点模板。此近似的截断误差为 $O(h_x^2, h_y^2)$，表明该方法是二阶精确的。\n\n### 2. 线性系统组装\n\n离散方程必须应用于每个内部网格节点，对于 $i=1, \\dots, N_x$ 和 $j=1, \\dots, N_y$。这会产生一个包含 $N = N_x \\times N_y$ 个线性代数方程的系统。为了将此系统表示为矩阵形式 $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$，内部节点的未知值 $u_{i,j}$ 被排列成一个长度为 $N$ 的单列向量 $\\mathbf{u}_h$。一种标准方法是字典序排序，其中节点逐行（或逐列）索引。为了实现方便，使用从 0 开始的索引，节点 $(i,j)$ (其中 $i=0, \\dots, N_x-1$ and $j=0, \\dots, N_y-1$) 的全局索引 $k$ 为 $k = j \\cdot N_x + i$。\n\n矩阵 $\\mathbf{A}$ 是一个大小为 $N \\times N$ 的稀疏、对称、正定矩阵。其结构是块三对角的。$\\mathbf{A}$ 的每个条目对应于模板的系数。对于以节点 $k=(j,i)$ 为中心的方程：\n-   对角线元素 $A_{k,k}$ 是 $u_{i,j}$ 的系数：$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)$。\n-   对应于 $x$ 方向上邻居 $u_{i-1,j}$ 和 $u_{i+1,j}$ 的非对角线元素分别位于 $A_{k,k-1}$ 和 $A_{k,k+1}$ 处：$-\\frac{1}{h_x^2}$。\n-   对应于 $y$ 方向上邻居 $u_{i,j-1}$ 和 $u_{i,j+1}$ 的非对角线元素分别位于 $A_{k,k-N_x}$ 和 $A_{k,k+N_x}$ 处：$-\\frac{1}{h_y^2}$。\n\n狄利克雷边界条件指定了边界 $\\partial\\Omega$ 上 $u$ 的值。当与边界相邻的内部节点的模板涉及到边界节点时，该值是已知的。这个已知值被移到方程的右侧。\n例如，对于一个与左边界 $x=x_{\\min}$ (其中 $i=0$)相邻的内部节点 $(1, j)$，涉及 $u_{0,j}$ 的项是已知的：\n$$\\left(\\frac{2}{h_x^2} + \\frac{2}{h_y^2}\\right)u_{1,j} - \\dots = q_{1,j} + \\frac{1}{h_x^2}u_{0,j}$$\n项 $\\frac{1}{h_x^2}u_{0,j}$ 被加到右侧向量 $\\mathbf{b}$ 的相应元素上。\n因此，长度为 $N$ 的向量 $\\mathbf{b}$ 由两部分组成：\n1.  在每个内部节点 $(x_i, y_j)$ 处计算的源函数 $q(x,y)$ 的值。\n2.  从左侧转移过来的已知狄利克雷边界值的贡献。对于一个一般的内部节点 $(i,j)$，向量 $\\mathbf{b}$ 中对应的元素 $b_k$ 是：\n$$b_k = q_{i,j} + \\delta_{i,1}\\frac{u_{0,j}}{h_x^2} + \\delta_{i,N_x}\\frac{u_{N_x+1,j}}{h_x^2} + \\delta_{j,1}\\frac{u_{i,0}}{h_y^2} + \\delta_{j,N_y}\\frac{u_{i,N_y+1}}{h_y^2}$$\n其中 $\\delta_{m,n}$ 是克罗内克 δ (Kronecker delta)。\n\n### 3. 实现与验证\n\n求解线性系统 $\\mathbf{A} \\mathbf{u}_h = \\mathbf{b}$ 以得到未知向量 $\\mathbf{u}_h$。由于 $\\mathbf{A}$ 的稀疏性和结构化特性，使用了高效的稀疏矩阵存储格式（例如，压缩稀疏行格式）和专门的求解器。\n\n在计算出数值解 $u_h(x_i, y_j)$ 之后，通过将其与已知的人造解 $u_{\\text{exact}}(x_i, y_j)$ 进行比较来评估其准确性。离散 $L^2$-误差范数按规定计算：\n$$ \\|e\\|_{L^2} \\approx \\left( h_x h_y \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left[u_h(x_i,y_j) - u_{\\text{exact}}(x_i,y_j)\\right]^2 \\right)^{1/2} $$\n然后通过比较粗糙网格的误差 $\\|e\\|_{\\text{coarse}}$ 和加密网格的误差 $\\|e\\|_{\\text{fine}}$ 来确定收敛率 $p$，其中每个维度的内部点数都加倍。该速率通过以下公式计算：\n$$ p = \\frac{\\ln\\left(\\|e\\|_{\\text{coarse}} / \\|e\\|_{\\text{fine}}\\right)}{\\ln(2)} $$\n对于像推导出的这种二阶精确方法，$p$ 的期望值约为 2。下面的程序为指定的测试用例实现了这整个过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # Test Case 1 and 4: u(x,y) = sin(pi*x)*sin(pi*y)\n    def u1(x, y):\n        return np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def q1(x, y):\n        return 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    # Test Case 2: u(x,y) = exp(x)*sin(2*pi*y)\n    def u2(x, y):\n        return np.exp(x) * np.sin(2 * np.pi * y)\n    \n    def q2(x, y):\n        return (4 * np.pi**2 - 1) * np.exp(x) * np.sin(2 * np.pi * y)\n\n    # Test Case 3: u(x,y) = cos(2*pi*x)*cos(pi*y)\n    def u3(x, y):\n        return np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n    def q3(x, y):\n        return 5 * np.pi**2 * np.cos(2 * np.pi * x) * np.cos(np.pi * y)\n\n\n    def solve_poisson(domain, Nx, Ny, u_func, q_func):\n        \"\"\"\n        Solves the Poisson equation on a rectangular domain using a five-point stencil.\n\n        Args:\n            domain (tuple): (xmin, xmax, ymin, ymax).\n            Nx (int): Number of interior grid points in x.\n            Ny (int): Number of interior grid points in y.\n            u_func (callable): Manufactured solution u(x, y).\n            q_func (callable): Source term q(x, y) = -Laplacian(u).\n\n        Returns:\n            float: The discrete L2 error norm.\n        \"\"\"\n        xmin, xmax, ymin, ymax = domain\n        N = Nx * Ny\n\n        # Grid setup\n        hx = (xmax - xmin) / (Nx + 1)\n        hy = (ymax - ymin) / (Ny + 1)\n\n        x_int = np.linspace(xmin + hx, xmax - hx, Nx)\n        y_int = np.linspace(ymin + hy, ymax - hy, Ny)\n        X_int, Y_int = np.meshgrid(x_int, y_int, indexing='ij')\n\n        # Assemble the sparse matrix A\n        # The matrix A represents the negative discrete Laplacian operator.\n        # It has 5 non-zero diagonals.\n        main_diag = np.full(N, 2/hx**2 + 2/hy**2)\n        \n        # Off-diagonals for x-derivatives\n        off_diag_x = np.full(N - 1, -1/hx**2)\n        # Zero out connections between rows\n        off_diag_x[Nx-1::Nx] = 0\n\n        # Off-diagonals for y-derivatives\n        off_diag_y = np.full(N - Nx, -1/hy**2)\n        \n        diagonals = [main_diag, off_diag_x, off_diag_x, off_diag_y, off_diag_y]\n        offsets = [0, -1, 1, -Nx, Nx]\n        \n        A = sparse.diags(diagonals, offsets, shape=(N, N), format='csr')\n\n        # Assemble the right-hand side vector b\n        # Start with the source term q at interior points\n        b = q_func(X_int, Y_int).T.flatten() # Transpose to match lexicographical order\n\n        # Add contributions from Dirichlet boundary conditions\n        # Reshape b to 2D for easier indexing\n        b_grid = b.reshape((Ny, Nx))\n        \n        # Bottom boundary (y = ymin, j=0)\n        b_grid[0, :] += (1/hy**2) * u_func(x_int, ymin)\n        # Top boundary (y = ymax, j=Ny-1)\n        b_grid[-1, :] += (1/hy**2) * u_func(x_int, ymax)\n        # Left boundary (x = xmin, i=0)\n        b_grid[:, 0] += (1/hx**2) * u_func(xmin, y_int)\n        # Right boundary (x = xmax, i=Nx-1)\n        b_grid[:, -1] += (1/hx**2) * u_func(xmax, y_int)\n\n        b = b_grid.flatten()\n        \n        # Solve the linear system\n        u_h_flat = spsolve(A, b)\n\n        # Compute the error\n        u_exact_flat = u_func(X_int, Y_int).T.flatten()\n        error_sq = (u_h_flat - u_exact_flat)**2\n        l2_error = np.sqrt(hx * hy * np.sum(error_sq))\n        \n        return l2_error\n\n    test_cases = [\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((16, 16), (32, 32))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u2, \"q_func\": q2, \"grids\": ((24, 12), (48, 24))},\n        {\"domain\": (0, 2, 0, 1), \"u_func\": u3, \"q_func\": q3, \"grids\": ((60, 20), (120, 40))},\n        {\"domain\": (0, 1, 0, 1), \"u_func\": u1, \"q_func\": q1, \"grids\": ((4, 4), (8, 8))},\n    ]\n\n    results = []\n    for case in test_cases:\n        (Nx_c, Ny_c), (Nx_f, Ny_f) = case[\"grids\"]\n        \n        error_coarse = solve_poisson(case[\"domain\"], Nx_c, Ny_c, case[\"u_func\"], case[\"q_func\"])\n        error_fine = solve_poisson(case[\"domain\"], Nx_f, Ny_f, case[\"u_func\"], case[\"q_func\"])\n        \n        if error_fine > 0 and error_coarse > 0:\n            rate = np.log(error_coarse / error_fine) / np.log(2)\n        else:\n            rate = 0.0 # Or some other indicator of non-convergence\n\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然狄利克雷（Dirichlet）边界条件在教学中很常见，但许多地球物理问题，如地下水流动或地壳热传导，都涉及更为复杂的通量边界条件。本练习将引导你处理在计算地球物理学中至关重要的诺伊曼（Neumann）边界条件 。你将为一个稳态地下水流问题实现并比较两种常用的诺伊曼边界离散化方法，从而深入理解在边界上不同的数值处理方式如何影响解的精度。",
            "id": "3596436",
            "problem": "考虑一个位于坐标 $(x,y) \\in [0,L_x] \\times [0,L_y]$ 矩形域中的均质、各向同性含水层内的稳态地下水流。设导水系数为一个正常数 $K$，单位为 $\\mathrm{m/s}$。水头 $h(x,y)$ 满足由达西定律推导出的拉普拉斯方程，具体为守恒形式 $\\nabla \\cdot (K \\nabla h) = 0$。当 $K$ 在空间上为常数时，该方程简化为偏微分方程 (PDE) $\\nabla^2 h = 0$。假设三个边界具有与制造的精确解一致的狄利克雷边界条件，而位于 $x=L_x$ 的右边界具有规定的诺伊曼条件，该条件表示一个沿 $y$ 线性变化的法向通量。\n\n制造的解为 $h(x,y) = A x + B y + C x y$，对于所有常数 $A$、$B$ 和 $C$，该解都满足 $\\nabla^2 h = 0$。在 $x=0$、$y=0$ 和 $y=L_y$ 处施加狄利克雷边界条件，通过指定制造解在这些边界上的值来规定 $h(0,y)$、$h(x,0)$ 和 $h(x,L_y)$。在右边界 $x=L_x$ 处，诺伊曼边界条件通过 $-K \\, \\partial h / \\partial x \\big|_{x=L_x} = -K \\left(A + C y\\right)$ 来规定法向通量 $q_n(y)$。\n\n您的任务是使用标准的拉普拉斯五点差分格式，在 $x$ 方向有 $N_x$ 个节点、$y$ 方向有 $N_y$ 个节点的均匀笛卡尔网格上对该偏微分方程进行离散化，并为离散算子实现两种不同的右边界 $x=L_x$ 诺伊曼条件处理方法：\n\n- 单边差分 (OSD)：使用一阶单边差分来近似正 $x$ 方向上缺失的邻近点。该方法通过在 $x$ 方向的离散二阶导数中代入 $h_{i+1,j} = h_{i,j} + \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$ 来施加诺伊曼边界条件，其中 $\\Delta x = L_x/(N_x-1)$ 且 $y_j = j \\Delta y$, $\\Delta y = L_y/(N_y-1)$。这使得右边界节点上 $x$ 方向的离散贡献项为 $(h_{i-1,j} - h_{i,j})/\\Delta x^2 + (\\partial h / \\partial x)/\\Delta x$。\n- 鬼点反射 (GCR)：使用跨边界的反射值来近似缺失的邻近点，该方法通过在 $x$ 方向的离散二阶导数中代入 $h_{i+1,j} = h_{i-1,j} + 2 \\Delta x \\, \\partial h / \\partial x \\big|_{x=L_x,y_j}$ 来施加诺伊曼条件，从而保持中心差分结构。这使得右边界节点上 $x$ 方向的离散贡献项为 $(2 h_{i-1,j} - 2 h_{i,j})/\\Delta x^2 + 2 (\\partial h / \\partial x)/\\Delta x$。\n\n在这两种处理方法中，$y$ 方向的二阶导数均使用标准中心差分 $(h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2$ 进行离散化，并在需要时代入 $y=0$ 和 $y=L_y$ 处的狄利克雷边界值。对于内部节点，使用标准的拉普拉斯五点差分 $(h_{i+1,j} - 2 h_{i,j} + h_{i-1,j})/\\Delta x^2 + (h_{i,j+1} - 2 h_{i,j} + h_{i,j-1})/\\Delta y^2 = 0$，并在左侧、底部和顶部边界上应用狄利克雷值。\n\n在每种诺伊曼处理方法下求解出 $h$ 的线性系统后，通过计算离散法向通量来评估右边界上边界通量的精度。两种方法都使用单边内部差分计算离散法向通量，$q_n^{\\mathrm{num}}(y_j) = -K \\, \\left(h_{N_x-1,j} - h_{N_x-2,j}\\right)/\\Delta x$，并将其与精确边界通量 $q_n^{\\mathrm{exact}}(y_j) = -K \\left(A + C y_j\\right)$ 进行比较。对于每种情况，报告沿右边界的最大绝对通量误差 $\\max_{j} \\left| q_n^{\\mathrm{num}}(y_j) - q_n^{\\mathrm{exact}}(y_j) \\right|$，单位为 $\\mathrm{m/s}$。\n\n实现一个完整、可运行的程序，该程序：\n- 按照指定要求，为 OSD 和 GCR 两种边界处理方法构建并求解离散系统。\n- 计算每种方法的最大边界通量误差，单位为 $\\mathrm{m/s}$。\n\n使用以下参数集作为测试套件，所有长度单位为 $\\mathrm{m}$，$K$ 的单位为 $\\mathrm{m/s}$：\n- 案例 #1 (理想路径)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (41,41,1,1,1,1,0.2,0.5)$。\n- 案例 #2 (粗网格边界压力测试)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (5,5,1,1,1,1,0.3,0.8)$。\n- 案例 #3 (恒定右边界通量)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (31,31,1,1,1,1,0.1,0)$。\n- 案例 #4 (各向异性网格间距)：$(N_x,N_y,L_x,L_y,K,A,B,C) = (60,30,2,1,1,0.5,0.4,0.7)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$），其中 $r_{2k-1}$ 是案例 $k$ 中 OSD 方法的最大通量误差，$r_{2k}$ 是案例 $k$ 中 GCR 方法的最大通量误差，每个值都以浮点数形式表示，单位为 $\\mathrm{m/s}$。",
            "solution": "用户希望在一个矩形域 $[0,L_x] \\times [0,L_y]$ 上求解二维稳态地下水流方程，即拉普拉斯方程 $\\nabla^2 h = 0$。该问题使用有限差分法在均匀笛卡尔网格上进行离散化。边界条件是混合型的：在三个边界（$x=0$、$y=0$、$y=L_y$）上指定了狄利克雷条件，在第四个边界（$x=L_x$）上指定了诺伊曼条件。边界条件的值来源于一个已知的制造解 $h(x,y) = A x + B y + C x y$，该解是拉普拉斯方程的一个精确解。\n\n任务的核心是实现并比较两种不同的 $x=L_x$ 处诺伊曼边界条件的数值处理方法：一阶精度的单边差分 (OSD) 和二阶精度的鬼点反射 (GCR) 方法。对于每种方法，我们需要求解生成的线性方程组，以获得网格节点上的水头 $h$。最后，我们必须通过计算沿诺伊曼边界的法向通量计算值与从制造解导出的精确通量之间的最大绝对误差，来评估每种方法的精度。\n\n求解过程如下：\n\n1.  **网格与系统设置**：对于每个测试案例，我们定义一个包含 $N_x \\times N_y$ 个节点的均匀网格。网格间距为 $\\Delta x = L_x/(N_x-1)$ 和 $\\Delta y = L_y/(N_y-1)$。系统中的未知数是内部网格节点和诺伊曼边界上节点（不包括由狄利克雷条件固定的角点）的 $h$ 值。这总共得到 $(N_x-1) \\times (N_y-2)$ 个未知数。我们将这些未知节点的二维网格索引 $(i,j)$ 映射到单个一维索引 $k$，以构成一个未知数向量。\n\n2.  **离散化与矩阵组装**：我们构建一个稀疏线性方程组 $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$，其中 $\\mathbf{h}$ 是未知水头值的向量。对于每个未知节点 $(i,j)$，我们写出一个有限差分方程。\n    -   对于内部节点 ($1 \\le i  N_x-1$, $1 \\le j  N_y-2$)，我们使用标准的拉普拉斯五点差分格式：\n        $$\n        \\frac{h_{i+1,j} - 2h_{i,j} + h_{i-1,j}}{\\Delta x^2} + \\frac{h_{i,j+1} - 2h_{i,j} + h_{i,j-1}}{\\Delta y^2} = 0\n        $$\n        涉及狄利克雷边界上节点的项是已知的，并被移到右侧向量 $\\mathbf{b}$ 中。\n    -   对于诺伊曼边界上的节点 ($i = N_x-1$, $1 \\le j  N_y-2$)，$\\partial^2h/\\partial x^2$ 的离散化被修改以包含通量条件 $\\partial h/\\partial x \\big|_{x=L_x} = -(A + C y_j)$。\n        -   **OSD 处理**：$x$ 方向的导数项近似为：\n            $$\n            \\frac{h_{i-1,j} - h_{i,j}}{\\Delta x^2} + \\frac{1}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            将此代入偏微分方程，得到线性系统中的一行。\n        -   **GCR 处理**：$x$ 方向的导数项使用鬼点法，得到近似式：\n            $$\n            \\frac{2h_{i-1,j} - 2h_{i,j}}{\\Delta x^2} + \\frac{2}{\\Delta x}\\left(\\frac{\\partial h}{\\partial x}\\right)_{i,j}\n            $$\n            这也被代入偏微分方程，用于系统中的相应行。\n\n3.  **求解系统**：使用 `scipy.sparse.linalg` 库中的直接稀疏求解器求解得到的稀疏线性系统 $\\mathbf{M} \\mathbf{h} = \\mathbf{b}$，以得到 $\\mathbf{h}$。\n\n4.  **重构解**：将解向量 $\\mathbf{h}$ 重塑并放入一个完整的 $N_x \\times N_y$ 网格中。然后将来自狄利克雷边界条件的已知值施加到该网格上，以获得完整的数值解。\n\n5.  **通量误差计算**：通过将右边界上数值计算的通量与精确通量进行比较来评估解的精度。\n    -   边界 $x=L_x$ 上每个节点 $j$ 的数值通量使用一阶单边内部差分计算：\n        $$\n        q_{n,j}^{\\mathrm{num}} = -K \\frac{h_{N_x-1,j} - h_{N_x-2,j}}{\\Delta x}\n        $$\n    -   节点 $j$ 处的精确通量由下式给出：\n        $$\n        q_{n,j}^{\\mathrm{exact}} = -K (A + C y_j)\n        $$\n    -   误差是右边界上所有节点处数值通量与精确通量值之间最大绝对差：\n        $$\n        \\text{Error} = \\max_{j} \\left| q_{n,j}^{\\mathrm{num}} - q_{n,j}^{\\mathrm{exact}} \\right|\n        $$\n对所提供的四个测试案例，分别使用 OSD 和 GCR 方法重复整个过程，并收集得到的八个误差值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_case(params, method):\n    \"\"\"\n    Solves the 2D Laplace equation for a single test case and boundary treatment method.\n\n    Args:\n        params (tuple): A tuple containing (Nx, Ny, Lx, Ly, K, A, B, C).\n        method (str): The Neumann boundary treatment method, either 'OSD' or 'GCR'.\n\n    Returns:\n        float: The maximum absolute flux error on the right boundary.\n    \"\"\"\n    Nx, Ny, Lx, Ly, K, A, B, C = params\n\n    if Nx  3 or Ny  3:\n        # If Ny  3, there are no interior nodes in the y-direction, thus num_unknowns is 0.\n        # The flux error at the corners is analytically zero, so the max error is 0.\n        return 0.0\n\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    x = np.linspace(0, Lx, Nx, dtype=np.float64)\n    y = np.linspace(0, Ly, Ny, dtype=np.float64)\n\n    num_unknowns = (Nx - 1) * (Ny - 2)\n    M = lil_matrix((num_unknowns, num_unknowns), dtype=np.float64)\n    b = np.zeros(num_unknowns, dtype=np.float64)\n\n    # Map grid indices (i, j) of an unknown to a single vector index k.\n    # i corresponds to x-index [1, Nx-1], j to y-index [1, Ny-2].\n    def to_k(i, j):\n        # Column-major mapping\n        return (i - 1) * (Ny - 2) + (j - 1)\n\n    # Assemble the linear system M*h = b\n    for i in range(1, Nx):\n        for j in range(1, Ny - 1):\n            k = to_k(i, j)\n            \n            # Y-direction contribution (central difference)\n            M[k, k] += -2.0 / dy**2\n            if j == 1:  # Neighbor on bottom Dirichlet boundary (y=0)\n                h_bound = A * x[i]\n                b[k] -= h_bound / dy**2\n            else:\n                k_jm1 = to_k(i, j - 1)\n                M[k, k_jm1] += 1.0 / dy**2\n\n            if j == Ny - 2:  # Neighbor on top Dirichlet boundary (y=Ly)\n                h_bound = A * x[i] + B * Ly + C * x[i] * Ly\n                b[k] -= h_bound / dy**2\n            else:\n                k_jp1 = to_k(i, j + 1)\n                M[k, k_jp1] += 1.0 / dy**2\n\n            # X-direction contribution\n            if i  Nx - 1:  # Interior node in x-direction\n                M[k, k] += -2.0 / dx**2\n                if i == 1:  # Neighbor on left Dirichlet boundary (x=0)\n                    h_bound = B * y[j]\n                    b[k] -= h_bound / dx**2\n                else:\n                    k_im1 = to_k(i - 1, j)\n                    M[k, k_im1] += 1.0 / dx**2\n                \n                k_ip1 = to_k(i + 1, j)\n                M[k, k_ip1] += 1.0 / dx**2\n            \n            else:  # i == Nx - 1, node is on the right Neumann boundary\n                dhdx = A + C * y[j]\n                k_im1 = to_k(i - 1, j)\n                \n                if method == 'OSD':\n                    M[k, k] += -1.0 / dx**2\n                    M[k, k_im1] += 1.0 / dx**2\n                    b[k] -= dhdx / dx\n                elif method == 'GCR':\n                    M[k, k] += -2.0 / dx**2\n                    M[k, k_im1] += 2.0 / dx**2\n                    b[k] -= 2.0 * dhdx / dx\n\n    # Solve the sparse linear system\n    M_csr = M.tocsr()\n    h_unknown = spsolve(M_csr, b)\n\n    # Reconstruct the full solution grid h_full[i, j]\n    h_full = np.zeros((Nx, Ny), dtype=np.float64)\n\n    # Fill in the solved unknown values\n    h_unknown_grid = h_unknown.reshape((Nx - 1, Ny - 2), order='F') # Use Fortran order for column-major\n    h_full[1:Nx, 1:Ny - 1] = h_unknown_grid\n\n    # Apply Dirichlet boundary conditions to the full grid\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    h_full[0, :] = B * Y[0, :]\n    h_full[:, 0] = A * X[:, 0]\n    h_full[:, Ny - 1] = A * X[:, Ny - 1] + B * Ly + C * X[:, Ny - 1] * Ly\n\n    # Calculate numerical flux on the right boundary (x=Lx)\n    h_right_boundary = h_full[Nx - 1, 1:Ny-1]\n    h_second_to_right = h_full[Nx - 2, 1:Ny-1]\n    q_num = -K * (h_right_boundary - h_second_to_right) / dx\n\n    # Calculate exact flux on the right boundary\n    q_exact = -K * (A + C * y[1:Ny-1])\n    \n    # Compute the maximum absolute error\n    max_error = np.max(np.abs(q_num - q_exact))\n    \n    return max_error\n    \ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 41, 1.0, 1.0, 1.0, 1.0, 0.2, 0.5),\n        (5, 5, 1.0, 1.0, 1.0, 1.0, 0.3, 0.8),\n        (31, 31, 1.0, 1.0, 1.0, 1.0, 0.1, 0.0),\n        (60, 30, 2.0, 1.0, 1.0, 0.5, 0.4, 0.7)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate max flux error for One-Sided Difference (OSD)\n        error_osd = solve_case(case, 'OSD')\n        results.append(error_osd)\n\n        # Calculate max flux error for Ghost-Cell Reflection (GCR)\n        error_gcr = solve_case(case, 'GCR')\n        results.append(error_gcr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "标准的五点格式暗含一个重要假设：介质的物理属性（如渗透率或热导率）主轴与计算网格对齐。然而，在地质现实中，例如倾斜的沉积岩层或定向排列的裂缝，这一假设往往不成立。本练习将带你挑战这个高级问题：如何在标准的结构网格上精确模拟旋转各向异性扩散 。你将通过开发一种巧妙的“旋转模板”方法，利用插值计算沿介质自然主轴方向的导数，从而在不引入更复杂的九点格式的前提下，显著提升模型的物理保真度。",
            "id": "3596408",
            "problem": "考虑散度形式的二维各向异性扩散算子，对于一个足够光滑的标量场 $u(x,y)$，其定义为\n$$\n\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right),\n$$\n其中 $\\mathbf{K}$ 是一个常数、对称、正定的水力/热传导率张量，其主值为 $k_x$ 和 $k_y$。在主轴坐标系中，$\\mathbf{K}=\\mathrm{diag}(k_x,k_y)$。假设主轴相对于笛卡尔网格方向旋转了角度 $\\theta$（以弧度为单位）。在许多地球物理流中，这种各向异性扩散源于层状介质或裂缝组，其渗透率张量在旋转后的坐标系中是对角化的。\n\n您的任务是从第一性原理出发，构建、评估并修正一个五点离散化方案，该方案需保持网格对齐，但又能对旋转的各向异性具有预测能力，且不引入九点模板。计算域在 $[0,1]\\times[0,1]$ 上是周期的。角度必须以弧度为单位进行解释。本问题中没有物理单位；所有量均视为无量纲。\n\n从梯度和散度的基本定义以及坐标旋转的链式法则出发，完成以下任务：\n\n- 在连续层面上，推导全局坐标系中旋转张量算子与旋转了 $\\theta$ 的主轴张量 $\\mathrm{diag}(k_x,k_y)$ 之间的关系。将作用于形式为 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$（其中 $m$ 和 $n$ 为整数）的单个实傅里叶模上的算子表示为 $u(x,y)$ 的一个标量倍。不要假设 $(m,n)$ 与网格轴之间有任何特殊的对齐关系。\n\n- 在一个具有 $N\\times N$ 个节点和网格间距 $h=1/N$ 的均匀周期性网格上，实现一个经典的五点离散算子，该算子使通量与网格方向对齐，并使用中心二阶差分。对于在网格对齐坐标系中是对角阵的常数 $\\mathbf{K}$，该算子简化为 $x$ 和 $y$ 方向二阶差分的加权和。使用前一项中的旋转张量，定义一个基准五点离散算子，该算子忽略混合导数，并作为旋转后连续算子的一个网格对齐近似。\n\n- 通过将基准五点算子作用于 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ 的结果与上面推导的精确连续算子进行比较，量化其误差。使用相对 $\\ell^2$ 误差：\n$$\n\\varepsilon \\equiv \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}.\n$$\n\n- 提出并实现一个不引入九点模板的旋转模板修正方案。您的修正必须从第一性原理推导，并且必须保留使用五点核心来计算二阶差分，但它可以通过局部旋转来沿主方向计算这些差分。具体来说，在旋转坐标系中使用步长为 $h$ 的中心差分，计算沿两个主方向的方向二阶导数。由于主方向与网格不对齐，因此需要使用来自最近的四个网格节点的周期性双线性插值来近似所需的离网格 $u$ 样本。将两个方向二阶差分与主扩散系数 $k_x$ 和 $k_y$ 结合起来，以近似 $\\mathcal{L}[u]$。这就实现了一个旋转模板修正，而没有显式地引入一个由固定的网格对齐点组成的九点模板。\n\n- 使用上述方法，对测试函数 $u(x,y)=\\cos\\!\\left(2\\pi\\,(m\\,x+n\\,y)\\right)$ 评估基准和修正后的离散算子，并报告相对 $\\ell^2$ 误差。对每个测试用例，计算基准误差、修正后误差以及定义为基准误差与修正后误差之比的改进因子。同时报告一个布尔值，指示修正后误差是否严格小于基准误差。\n\n您的程序必须在周期性网格上实现所有计算，使用周期性环绕执行所有插值，并为以下测试套件生成结果：\n\n- 测试用例 1：$N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=0.0$, $m=3$, $n=2$。\n- 测试用例 2：$N=64$, $k_x=2.0$, $k_y=1.0$, $\\theta=\\pi/6$, $m=3$, $n=2$。\n- 测试用例 3：$N=64$, $k_x=10.0$, $k_y=1.0$, $\\theta=\\pi/4$, $m=2$, $n=1$。\n- 测试用例 4：$N=64$, $k_x=1.0$, $k_y=1.0$, $\\theta=\\pi/3$, $m=4$, $n=3$。\n\n对于每个测试用例，结果必须是一个包含四项的列表，顺序为：基准误差（浮点数）、修正后误差（浮点数）、改进因子（浮点数）、改进标志（布尔值）。所有浮点数必须四舍五入到 $8$ 位小数。最终输出格式必须是单行，其中包含一个由方括号括起来的、以逗号分隔的各测试用例结果列表。例如，输出必须看起来像\n$[ [e_{11}, e_{12}, e_{13}, b_1], [e_{21}, e_{22}, e_{23}, b_2], [e_{31}, e_{32}, e_{33}, b_3], [e_{41}, e_{42}, e_{43}, b_4] ]$\n在打印行中没有空格。将每个 $e_{ij}$ 替换为相应的四舍五入后的浮点数，将 $b_i$ 替换为相应的布尔值。",
            "solution": "该问题要求为二维各向异性扩散算子 $\\mathcal{L}[u] \\equiv \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right)$ 构建和验证两种有限差分格式。传导率张量 $\\mathbf{K}$ 是一个常数、对称、正定的张量，在一个相对于笛卡尔网格旋转了角度 $\\theta$ 的坐标系中，其主值为 $k_x$ 和 $k_y$。解决方案首先分析连续算子，然后定义一个简单的基准离散算子和一个更复杂的修正算子，最后在一个给定的测试函数上比较它们的准确性。\n\n首先，我们在标准笛卡尔网格坐标系 $(x,y)$ 中推导连续算子 $\\mathcal{L}[u]$ 的显式形式。二阶传导率张量从其主轴坐标系（用撇号表示）到网格坐标系的变换由合同变换 $\\mathbf{K} = \\mathbf{R}(\\theta) \\mathbf{K}' \\mathbf{R}(\\theta)^T$ 给出，其中 $\\mathbf{K}' = \\mathrm{diag}(k_x, k_y)$ 且 $\\mathbf{R}(\\theta)$ 是标准旋转矩阵。\n$$\n\\mathbf{R}(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}\n$$\n令 $c = \\cos\\theta$ 和 $s = \\sin\\theta$，网格坐标系中的张量 $\\mathbf{K}$ 为：\n$$\n\\mathbf{K} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} \\begin{pmatrix} k_x  0 \\\\ 0  k_y \\end{pmatrix} \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} = \\begin{pmatrix} k_x c^2 + k_y s^2  (k_x - k_y)sc \\\\ (k_x - k_y)sc  k_x s^2 + k_y c^2 \\end{pmatrix}\n$$\n设 $\\mathbf{K}$ 在网格坐标系中的分量为 $K_{11}$、$K_{12} = K_{21}$ 和 $K_{22}$。由于 $\\mathbf{K}$ 的元素是常数，算子 $\\mathcal{L}[u]$ 展开为：\n$$\n\\mathcal{L}[u] = \\nabla \\cdot (\\mathbf{K} \\nabla u) = \\partial_x(K_{11} \\partial_x u + K_{12} \\partial_y u) + \\partial_y(K_{21} \\partial_x u + K_{22} \\partial_y u) = K_{11} \\partial^2_{xx} u + 2 K_{12} \\partial^2_{xy} u + K_{22} \\partial^2_{yy} u\n$$\n我们将此算子应用于指定的测试函数，即单个傅里叶模 $u(x,y) = \\cos(2\\pi(mx+ny))$。令 $\\phi(x,y) = 2\\pi(mx+ny)$。所需的二阶偏导数为 $\\partial^2_{xx} u = -(2\\pi m)^2 u$、$\\partial^2_{yy} u = -(2\\pi n)^2 u$ 和 $\\partial^2_{xy} u = -(2\\pi)^2 mn u$。将这些代入 $\\mathcal{L}[u]$ 的表达式中，表明 $u(x,y)$ 是该连续算子的一个本征函数：\n$$\n\\mathcal{L}[u] = -(2\\pi)^2 \\left[ K_{11}m^2 + 2 K_{12} mn + K_{22}n^2 \\right] u(x,y)\n$$\n这可以使用波矢量 $\\mathbf{p} = 2\\pi(m, n)^T$ 更紧凑地表示为 $\\mathcal{L}[u] = -(\\mathbf{p}^T \\mathbf{K} \\mathbf{p}) u$。这个解析结果提供了网格上的精确参考解，离散近似将与之进行比较。\n\n第二，我们构建基准五点离散算子 $\\mathcal{L}_{h, \\text{base}}$。根据规定，该算子与网格对齐，并通过忽略由各向异性张量旋转产生的混合导数项 $2 K_{12} \\partial^2_{xy} u$ 而得到。由此得到的近似算子是：\n$$\n\\mathcal{L}_{\\text{base}}[u] \\approx K_{11} \\partial^2_{xx} u + K_{22} \\partial^2_{yy} u\n$$\n在间距为 $h=1/N$ 的均匀周期性网格上使用标准的二阶中心差分，我们得到在网格节点 $(i,j)$ 处的离散算子：\n$$\n\\mathcal{L}_{h, \\text{base}}[u]_{i,j} = K_{11} \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + K_{22} \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n其中 $u_{i,j} = u(ih, jh)$，所有索引都进行周期性处理。该算子计算效率高，但只要 $K_{12} \\neq 0$（即当 $\\theta$ 不是 $\\pi/2$ 的倍数且 $k_x \\neq k_y$ 时），它在形式上是不一致的，因为它省略了控制偏微分方程中的一项。\n\n第三，我们设计修正后的离散算子 $\\mathcal{L}_{h, \\text{corr}}$，它通过在其自然主轴坐标系中离散化算子来规避这种不一致性。在这个 $(x', y')$ 坐标系中，算子简化为：\n$$\n\\mathcal{L}[u] = k_x \\frac{\\partial^2 u}{\\partial (x')^2} + k_y \\frac{\\partial^2 u}{\\partial (y')^2}\n$$\n沿这些主轴的单位向量是 $\\mathbf{e}'_1 = (\\cos\\theta, \\sin\\theta)^T$ 和 $\\mathbf{e}'_2 = (-\\sin\\theta, \\cos\\theta)^T$。我们使用步长为 $h$ 的中心差分来近似二阶方向导数：\n$$\n\\frac{\\partial^2 u}{\\partial (x')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_1) - 2u(P) + u(P-h\\mathbf{e}'_1)}{h^2}, \\quad \\frac{\\partial^2 u}{\\partial (y')^2} \\bigg|_P \\approx \\frac{u(P+h\\mathbf{e}'_2) - 2u(P) + u(P-h\\mathbf{e}'_2)}{h^2}\n$$\n其中 $P=(x_i, y_j)$ 是一个网格节点。求值点 $P \\pm h\\mathbf{e}'_1$ 和 $P \\pm h\\mathbf{e}'_2$ 通常不位于网格上。为了在这些离网格位置上求值 $u$，我们使用周围四个网格节点的值进行周期性双线性插值。对于域 $[0,1) \\times [0,1)$ 中的一个点 $(x,y)$，我们找到其整数网格单元邻居 $(i_1, j_1), ((i_1+1)\\%N, j_1), (i_1, (j_1+1)\\%N), ((i_1+1)\\%N, (j_1+1)\\%N)$ 以及小数距离 $\\alpha$ 和 $\\beta$。那么插值 $u_{\\text{interp}}$ 为：\n$$\nu_{\\text{interp}}(x,y) = (1-\\alpha)(1-\\beta)u_{i_1,j_1} + \\alpha(1-\\beta)u_{i_2,j_1} + (1-\\alpha)\\beta u_{i_1,j_2} + \\alpha\\beta u_{i_2,j_2}\n$$\n修正后的算子将这些部分组合起来：\n$$\n\\mathcal{L}_{h, \\text{corr}}[u]_{i,j} = k_x \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_1) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_1)}{h^2} \\right) + k_y \\left( \\frac{u_{\\text{interp}}(P+h\\mathbf{e}'_2) - 2u_{i,j} + u_{\\text{interp}}(P-h\\mathbf{e}'_2)}{h^2} \\right)\n$$\n这种形式为原始算子提供了一个一致的近似，因为其误差来源是中心差分的标准截断误差和双线性插值的误差，这两者都随着 $h \\to 0$ 而减小。\n\n最后，使用相对 $\\ell^2$ 误差 $\\varepsilon$ 来量化两个离散算子的准确性。对于一个给定的离散算子 $\\mathcal{L}_h$，误差计算如下：\n$$\n\\varepsilon = \\left( \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\mathcal{L}_h[u]_{i,j}-\\mathcal{L}[u]_{i,j} \\right)^2}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\mathcal{L}[u]_{i,j}\\right)^2} \\right)^{1/2}\n$$\n其中 $\\mathcal{L}[u]_{i,j}$ 是在网格节点 $(i,j)$ 处求值的精确连续算子。对 $\\mathcal{L}_{h, \\text{base}}$ 和 $\\mathcal{L}_{h, \\text{corr}}$ 都计算此度量，并通过改进因子来比较它们的性能，改进因子定义为基准误差与修正后误差的比值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the anisotropic diffusion problem for a suite of test cases.\n    It computes errors for a baseline and a corrected finite difference scheme.\n    \"\"\"\n    test_cases = [\n        # (N, kx, ky, theta, m, n)\n        (64, 2.0, 1.0, 0.0, 3, 2),\n        (64, 2.0, 1.0, np.pi/6, 3, 2),\n        (64, 10.0, 1.0, np.pi/4, 2, 1),\n        (64, 1.0, 1.0, np.pi/3, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_single_case(*case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The default string representation for Python lists and booleans is used.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_single_case(N, kx, ky, theta, m, n):\n    \"\"\"\n    Computes numerical solutions and errors for a single test case.\n    \"\"\"\n    h = 1.0 / N\n    x = np.arange(N) * h\n    # Create a 2D grid of coordinates\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    # The test function evaluated on the grid\n    u_grid = np.cos(2 * np.pi * (m * xx + n * yy))\n\n    # --- 1. Exact Continuous Operator Evaluation ---\n    c, s = np.cos(theta), np.sin(theta)\n    \n    # Components of the conductivity tensor K in the grid-aligned frame\n    K11 = kx * c**2 + ky * s**2\n    K12 = (kx - ky) * s * c\n    K22 = kx * s**2 + ky * c**2\n    \n    # Eigenvalue of the continuous operator for the given Fourier mode\n    lambda_exact = -(2 * np.pi)**2 * (K11 * m**2 + 2 * K12 * m * n + K22 * n**2)\n    \n    # Exact operator applied to the test function on the grid\n    L_u_exact = lambda_exact * u_grid\n\n    # --- 2. Baseline Five-Point Operator ---\n    # Central difference approximation for d^2u/dx^2 (periodic)\n    uxx = (np.roll(u_grid, -1, axis=0) - 2 * u_grid + np.roll(u_grid, 1, axis=0)) / h**2\n    # Central difference approximation for d^2u/dy^2 (periodic)\n    uyy = (np.roll(u_grid, -1, axis=1) - 2 * u_grid + np.roll(u_grid, 1, axis=1)) / h**2\n    \n    # Baseline operator application (ignores mixed derivatives)\n    L_h_base_u = K11 * uxx + K22 * uyy\n\n    # --- 3. Corrected Rotated-Stencil Operator ---\n    # Principal direction vectors\n    e1 = np.array([c, s])\n    e2 = np.array([-s, c])\n\n    # Coordinates of points for directional derivatives\n    x_p1, y_p1 = xx + h * e1[0], yy + h * e1[1]\n    x_m1, y_m1 = xx - h * e1[0], yy - h * e1[1]\n    x_p2, y_p2 = xx + h * e2[0], yy + h * e2[1]\n    x_m2, y_m2 = xx - h * e2[0], yy - h * e2[1]\n    \n    # Interpolate u at off-grid points\n    u_p1 = _bilinear_interpolate(x_p1, y_p1, u_grid, h, N)\n    u_m1 = _bilinear_interpolate(x_m1, y_m1, u_grid, h, N)\n    u_p2 = _bilinear_interpolate(x_p2, y_p2, u_grid, h, N)\n    u_m2 = _bilinear_interpolate(x_m2, y_m2, u_grid, h, N)\n\n    # Directional second derivatives\n    d2u_dxprime2 = (u_p1 - 2 * u_grid + u_m1) / h**2\n    d2u_dyprime2 = (u_p2 - 2 * u_grid + u_m2) / h**2\n    \n    # Corrected operator application\n    L_h_corr_u = kx * d2u_dxprime2 + ky * d2u_dyprime2\n\n    # --- 4. Error Calculation ---\n    norm_exact = np.linalg.norm(L_u_exact)\n    \n    # The norm of the exact solution should be non-zero for the given test cases.\n    if norm_exact == 0:\n        # This case should not be reached with the problem's inputs\n        # but is handled for robustness.\n        err_base = 0.0 if np.allclose(L_h_base_u, L_u_exact) else np.inf\n        err_corr = 0.0 if np.allclose(L_h_corr_u, L_u_exact) else np.inf\n    else:\n        err_base = np.linalg.norm(L_h_base_u - L_u_exact) / norm_exact\n        err_corr = np.linalg.norm(L_h_corr_u - L_u_exact) / norm_exact\n\n    # Improvement factor\n    if err_corr > 0:\n        improvement = err_base / err_corr\n    elif err_base > 0: # err_corr is 0\n        improvement = np.inf\n    else: # Both errors are 0\n        improvement = 1.0\n\n    # Improved flag\n    improved = err_corr  err_base\n\n    # Round results and package them\n    return [\n        round(err_base, 8),\n        round(err_corr, 8),\n        round(improvement, 8),\n        improved\n    ]\n\ndef _bilinear_interpolate(x_coords, y_coords, u_grid, h, N):\n    \"\"\"\n    Performs periodic bilinear interpolation on the grid u_grid.\n    x_coords and y_coords are arrays of the same shape specifying points to interpolate.\n    \"\"\"\n    # Scale coordinates to grid index space, with periodic wrapping\n    x_scaled = (x_coords / h) % N\n    y_scaled = (y_coords / h) % N\n\n    # Get integer and fractional parts of scaled coordinates\n    i1 = np.floor(x_scaled).astype(int)\n    j1 = np.floor(y_scaled).astype(int)\n    \n    alpha = x_scaled - i1\n    beta = y_scaled - j1\n    \n    # Get indices of the 4 neighboring grid points (with periodic wrapping)\n    i2 = (i1 + 1) % N\n    j2 = (j1 + 1) % N\n    \n    # Retrieve values at the 4 corner points using advanced indexing\n    u11 = u_grid[i1, j1] # val at (i1, j1)\n    u21 = u_grid[i2, j1] # val at (i2, j1)\n    u12 = u_grid[i1, j2] # val at (i1, j2)\n    u22 = u_grid[i2, j2] # val at (i2, j2)\n\n    # Reshape weights for broadcasting\n    alpha = alpha.reshape(alpha.shape + (1,) * (u11.ndim - alpha.ndim))\n    beta = beta.reshape(beta.shape + (1,) * (u11.ndim - beta.ndim))\n\n    # Bilinear interpolation formula\n    u_interp = (1 - alpha) * (1 - beta) * u11 + \\\n               alpha * (1 - beta) * u21 + \\\n               (1 - alpha) * beta * u12 + \\\n               alpha * beta * u22\n    \n    return u_interp\n\nsolve()\n```"
        }
    ]
}