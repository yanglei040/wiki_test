{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of reliable computational modeling is rigorous verification against known analytical solutions. This practice provides a crucial test for any geophysical finite element code: verifying hydrostatic equilibrium. You will implement the consistent nodal force vectors arising from gravity in a layered medium, a prescribed hydrostatic initial stress field, and the corresponding boundary tractions, confirming that these forces are in perfect balance as dictated by physical principles . This exercise will solidify your understanding of weak-form integration and the careful handling of material interfaces within elements.",
            "id": "3588957",
            "problem": "Consider a two-dimensional vertical rectangular domain $\\Omega = [0,W] \\times [0,H]$ representing a geophysical column in plane strain with out-of-plane unit thickness. Let the vertical coordinate be $z$ measured positive downward, with the top boundary at $z=0$ and the bottom boundary at $z=H$. The material is linear elastic, homogeneous, and isotropic with Young's modulus $E$ and Poisson's ratio $\\nu$. The gravitational acceleration is $\\mathbf{g} = (0,g)$, with $g$ strictly positive and expressed in $\\mathrm{m/s^2}$. The mass density is layered, depending only on $z$, as a piecewise constant function $\\rho(z)$ defined by horizontal layers.\n\nAssume small-strain kinematics, Cauchy stress symmetry, and static equilibrium (no inertia). Starting from the linear momentum balance and the weak form of equilibrium for an arbitrary admissible virtual displacement field, derive the finite element expressions needed to:\n- Form the consistent body-force element load vector associated with gravity for a bilinear quadrilateral (four-node) element, using standard bilinear shape functions and exact area integration via suitable Gauss quadrature.\n- Form the element internal nodal force vector associated with an imposed initial stress field. The initial stress field is hydrostatic (isotropic), $\\boldsymbol{\\sigma}_0(z) = -p(z)\\,\\mathbf{I}$, with pressure $p(z)$ satisfying $dp/dz = \\rho(z)\\,g$ and $p(H)=0$. Explicitly construct $p(z)$ from the given layered $\\rho(z)$.\n- Include the boundary traction contributions consistent with the hydrostatic initial stress, i.e., $\\mathbf{t}(z) = \\boldsymbol{\\sigma}_0(z)\\,\\mathbf{n}$ on each boundary segment with outward unit normal $\\mathbf{n}$.\n\nDefine the finite element mesh by partitioning $\\Omega$ into $N_x \\times N_z$ axis-aligned bilinear quadrilateral elements, each with the standard four-node parametrization in the parent coordinates $(\\xi,\\eta)\\in[-1,1]^2$. Use plane strain with unit thickness. Assemble the global vectors:\n- The gravity load vector $\\mathbf{f}_g$ by integrating the body force $\\rho(z)\\,\\mathbf{g}$ against the shape functions over the domain.\n- The initial-stress internal force vector $\\mathbf{f}_{\\sigma_0}$ by integrating the strain-displacement matrix transpose times $\\boldsymbol{\\sigma}_0$ over the domain.\n- The boundary traction vector $\\mathbf{f}_t$ by integrating the hydrostatic tractions along all domain boundaries.\n\nUsing the assembled vectors, test hydrostatic balance at zero displacement $\\mathbf{u}_0 = \\mathbf{0}$. In the consistent weak form, equilibrium at $\\mathbf{u}_0=\\mathbf{0}$ requires the global residual\n$$\n\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t\n$$\nto be the zero vector if the hydrostatic initial stress and gravity are in exact balance. Compute the infinity norm (maximum absolute component) of $\\mathbf{r}(\\mathbf{u}_0)$ for each test case.\n\nYou must implement the complete calculation with the following requirements:\n- Use exact mass density layering in the integrals. If any element spans across a layer interface, subdivide its vertical integration into subregions aligned with the density layers and apply Gauss quadrature in each subregion.\n- Use bilinear quadrilateral elements and two-point Gauss quadrature in each parametric direction for area integrals, and two-point Gauss quadrature for the one-dimensional edge integrals.\n- Adopt plane strain with out-of-plane unit thickness.\n- Express gravitational acceleration in $\\mathrm{m/s^2}$, elastic moduli in $\\mathrm{Pa}$, dimensions in $\\mathrm{m}$, densities in $\\mathrm{kg/m^3}$, and forces in $\\mathrm{N}$. Report the residual norm in $\\mathrm{N}$.\n\nTest Suite:\nFor each of the three parameter sets below, assemble $\\mathbf{f}_g$, $\\mathbf{f}_{\\sigma_0}$, and $\\mathbf{f}_t$, compute $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$, and output the three results as a single line in the specified final format.\n\n- Case A (uniform layer, happy path):\n  - $W = 100\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 2$, $N_z = 2$.\n  - $E = 3.0 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: one layer $[0,1000]$ with $\\rho = 2200\\,\\mathrm{kg/m^3}$.\n\n- Case B (two layers, non-aligned element interfaces):\n  - $W = 80\\,\\mathrm{m}$, $H = 900\\,\\mathrm{m}$, $N_x = 3$, $N_z = 3$.\n  - $E = 2.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.30$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: $[0,500]$ with $\\rho = 2000\\,\\mathrm{kg/m^3}$ and $[500,900]$ with $\\rho = 2500\\,\\mathrm{kg/m^3}$.\n\n- Case C (thin low-density layer, edge case):\n  - $W = 120\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 4$, $N_z = 5$.\n  - $E = 3.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.20$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: $[0,300]$ with $\\rho = 1800\\,\\mathrm{kg/m^3}$, $[300,305]$ with $\\rho = 100\\,\\mathrm{kg/m^3}$, $[305,1000]$ with $\\rho = 2600\\,\\mathrm{kg/m^3}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three residual norms rounded by the default string conversion, as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\"), where each result is a float representing $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$ in $\\mathrm{N}$ for the corresponding case.",
            "solution": "The problem requires the validation of hydrostatic balance for a two-dimensional geophysical column using the finite element method. The state of equilibrium at zero displacement is verified by computing the residual force vector $\\mathbf{r}(\\mathbf{u}_0)$, which must be a zero vector for an exact solution. The problem specifies a particular numerical implementation using bilinear quadrilateral elements and Gauss quadrature. Given that the integrands are piecewise polynomials, we expect the specified quadrature scheme, when applied correctly, to be exact and yield a residual that is zero to within machine precision.\n\nThe residual vector is defined as $\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t$, where $\\mathbf{f}_g$ is the gravity load vector, $\\mathbf{f}_{\\sigma_0}$ is the internal force vector from the initial hydrostatic stress, and $\\mathbf{f}_t$ is the boundary traction vector consistent with the initial stress. We will formulate and compute each of these vectors.\n\n### 1. Theoretical Framework\n\n**Discretization**: The domain $\\Omega = [0,W] \\times [0,H]$ is discretized into a grid of $N_x \\times N_z$ bilinear quadrilateral elements. For an element $e$, the geometry and displacement field are interpolated from nodal values using an isoparametric mapping from a parent element $(\\xi, \\eta) \\in [-1,1]^2$. We adopt a standard counter-clockwise node numbering (1-2-3-4) for the physical element, starting from the top-left corner, and map it to the parent element's standard node order (bottom-left, bottom-right, top-right, top-left), which gives a positive Jacobian determinant $\\det(\\mathbf{J}) = w_e h_e / 4$, where $w_e$ and $h_e$ are the element width and height.\n\n**Hydrostatic Pressure**: The initial stress is hydrostatic, $\\boldsymbol{\\sigma}_0(z) = -p(z)\\mathbf{I}$, where $p(z)$ is the pressure. Given the condition $dp/dz = \\rho(z)g$ and $p(H)=0$, the pressure at any depth $z$ is the weight of the material column below it:\n$$\np(z) = \\int_z^H \\rho(s) g \\, ds\n$$\nSince the density $\\rho(z)$ is piecewise constant, $p(z)$ is a continuous, piecewise linear function of $z$.\n\n**Weak Form of Equilibrium**: The principle of virtual work, evaluated at zero displacement ($\\mathbf{u}=\\mathbf{0}$, thus $\\boldsymbol{\\sigma}=\\boldsymbol{\\sigma}_0$), states that the internal forces must balance the external forces:\n$$\n\\int_{\\Omega} \\mathbf{B}^T \\boldsymbol{\\sigma}_0 \\, d\\Omega = \\int_{\\Omega} \\mathbf{N}^T \\mathbf{b} \\, d\\Omega + \\int_{\\partial\\Omega} \\mathbf{N}^T \\mathbf{t} \\, d\\Gamma\n$$\nwhere $\\mathbf{N}$ is the matrix of shape functions, $\\mathbf{B}$ is the strain-displacement matrix, $\\mathbf{b}=[0, \\rho(z)g]^T$ is the body force, and $\\mathbf{t}$ are the boundary tractions. The three terms correspond to $\\mathbf{f}_{\\sigma_0}$, $\\mathbf{f}_g$, and $\\mathbf{f}_t$, respectively. While these terms are equal in the continuous sense, their numerical evaluation must be performed carefully. With exact integration, they must balance perfectly.\n\n### 2. Element Force Vector Formulation\n\nWe now formulate the element-level vectors for assembly. All integrals are performed using the specified quadrature rules. The key challenge lies in handling elements that cross boundaries between density layers. For such elements, the vertical integration over $\\eta \\in [-1, 1]$ is split into sub-intervals, and Gauss quadrature is applied to each.\n\n**A. Gravity Load Vector ($\\mathbf{f}_g^e$)**:\nThe $z$-component of the gravity force on local node $i$ of an element is:\n$$\nf_{giz}^e = \\int_{\\Omega_e} N_i(x,z) \\rho(z) g \\, d\\Omega = g \\int_{-1}^1\\int_{-1}^1 N_i(\\xi, \\eta) \\rho(z(\\eta)) \\det(\\mathbf{J}) \\, d\\xi d\\eta\n$$\nFor a bilinear element, integrating analytically with respect to $\\xi$ simplifies this to:\n$$\nf_{giz}^e = g \\frac{w_e h_e}{8} \\int_{-1}^1 (1 + \\eta_i \\eta) \\rho(z(\\eta)) \\, d\\eta\n$$\nwhere $(\\xi_i, \\eta_i)$ are the parent coordinates of node $i$. The remaining 1D integral is evaluated numerically.\n\n**B. Initial Stress Force Vector ($\\mathbf{f}_{\\sigma_0}^e$)**:\nThe internal force from initial stress on node $i$ is:\n$$\n\\mathbf{f}_{\\sigma_0,i}^e = \\int_{\\Omega_e} \\mathbf{B}_i^T \\boldsymbol{\\sigma}_0(z) \\, d\\Omega = \\int_{\\Omega_e} \\begin{bmatrix} -p(z) \\frac{\\partial N_i}{\\partial x} \\\\ -p(z) \\frac{\\partial N_i}{\\partial z} \\end{bmatrix} d\\Omega\n$$\nUsing the isoparametric mapping and integrating analytically over $\\xi$ yields:\n$$\nf_{\\sigma_0,ix}^e = -\\frac{\\xi_i h_e}{4} \\int_{-1}^1 (1 + \\eta_i \\eta) p(z(\\eta)) \\, d\\eta\n$$\n$$\nf_{\\sigma_0,iz}^e = -\\frac{\\eta_i w_e}{4} \\int_{-1}^1 p(z(\\eta)) \\, d\\eta\n$$\nThese 1D integrals are computed numerically. The integrands are products of linear or constant terms and the piecewise linear pressure function $p(z(\\eta))$, resulting in piecewise polynomials of degree at most 2. Two-point Gauss quadrature integrates polynomials of degree up to 3 exactly. Therefore, when applied to each piece of the piecewise integrand (i.e., within each density layer segment inside an element), the integration is exact.\n\n**C. Boundary Traction Vector ($\\mathbf{f}_t^e$)**:\nTractions $\\mathbf{t} = \\boldsymbol{\\sigma}_0\\mathbf{n} = -p(z)\\mathbf{n}$ are applied to the domain boundaries.\n-   **Top boundary ($z=0$):** $\\mathbf{n}=(0,-1)$, so $\\mathbf{t}=(0, p(0))$. This contributes to the $z$-component of nodal forces.\n-   **Left boundary ($x=0$):** $\\mathbf{n}=(-1,0)$, so $\\mathbf{t}=(p(z), 0)$. This contributes to the $x$-component.\n-   **Right boundary ($x=W$):** $\\mathbf{n}=(1,0)$, so $\\mathbf{t}=(-p(z), 0)$. This also contributes to the $x$-component.\n-   **Bottom boundary ($z=H$):** $p(H)=0$, so $\\mathbf{t}=\\mathbf{0}$.\nFor an element edge on a vertical boundary, the force on a node $j$ on that edge is computed via a 1D integral, e.g., on the left boundary:\n$$\nf_{tx,j}^e = \\int_{z_{edge,1}}^{z_{edge,2}} N_j^{\\text{1D}}(z) p(z) \\, dz = \\frac{h_e}{2} \\int_{-1}^1 N_j^{\\text{1D}}(\\eta) p(z(\\eta)) \\, d\\eta\n$$\nThis 1D integral, involving a piecewise quadratic integrand, is also evaluated with 2-point Gauss quadrature (split at layer boundaries), which is an exact procedure for this integrand.\n\n### 3. Implementation Details\n\nThe implementation iterates through each element, computes the three element-level force vectors ($\\mathbf{f}_g^e, \\mathbf{f}_{\\sigma_0}^e, \\mathbf{f}_t^e$), and assembles them into global vectors. The core of the computation is a robust 1D integration function that handles layered media by subdividing the integration domain and applying 2-point Gauss quadrature on each sub-interval. Finally, the global residual $\\mathbf{r}$ is calculated, and its infinity norm $\\|\\mathbf{r}\\|_\\infty$ is reported. The resulting near-zero residual validates the correct implementation of the consistent force vectors and the principle of hydrostatic balance within the FEM framework. Any deviation from zero would be attributable only to floating-point precision limits.",
            "answer": "```python\nimport numpy as np\n\n# Global constants for 2-point Gauss quadrature\nGAUSS_POINTS = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\nGAUSS_WEIGHTS = np.array([1.0, 1.0])\n\ndef solve():\n    \"\"\"\n    Main driver function to process all test cases defined in the problem.\n    \"\"\"\n    test_cases = [\n        # Case A: Uniform layer, happy path\n        {\n            \"W\": 100.0, \"H\": 1000.0, \"Nx\": 2, \"Nz\": 2, \"g\": 9.81,\n            \"layers\": [(0.0, 1000.0, 2200.0)],\n        },\n        # Case B: Two layers, non-aligned element interfaces\n        {\n            \"W\": 80.0, \"H\": 900.0, \"Nx\": 3, \"Nz\": 3, \"g\": 9.81,\n            \"layers\": [(0.0, 500.0, 2000.0), (500.0, 900.0, 2500.0)],\n        },\n        # Case C: Thin low-density layer, edge case\n        {\n            \"W\": 120.0, \"H\": 1000.0, \"Nx\": 4, \"Nz\": 5, \"g\": 9.81,\n            \"layers\": [\n                (0.0, 300.0, 1800.0),\n                (300.0, 305.0, 100.0),\n                (305.0, 1000.0, 2600.0),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        residual_norm = compute_residual(**case)\n        results.append(residual_norm)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef create_pressure_function(H, g, layers):\n    \"\"\"\n    Creates a callable function p(z) for the hydrostatic pressure.\n    The pressure is pre-calculated at layer interfaces for efficiency.\n    \"\"\"\n    p_at_interface = {H: 0.0}\n    # Integrate from bottom to top\n    for i in range(len(layers) - 1, -1, -1):\n        z_start, z_end, rho = layers[i]\n        layer_overburden = rho * g * (z_end - z_start)\n        p_at_interface[z_start] = p_at_interface.get(z_end, 0.0) + layer_overburden\n\n    def p(z):\n        if z >= H: return 0.0\n        # Find the layer containing z\n        for z_start, z_end, rho in layers:\n            if z_start = z  z_end:\n                # Pressure is from layers below plus contribution from within the layer\n                return p_at_interface.get(z_end, 0.0) + rho * g * (z_end - z)\n        return 0.0  # Should be reached only for z=H\n\n    return p\n\ndef integrate_1d_layered(integrand_func, z_min, z_max, layers):\n    \"\"\"\n    Numerically integrates a 1D function over [z_min, z_max], splitting at layer boundaries.\n    The integration is transformed to parent coordinates eta in [-1, 1].\n    \"\"\"\n    h_e = z_max - z_min\n    z_c = z_min + h_e / 2.0\n    \n    eta_splits = [-1.0, 1.0]\n    for z_start, _, _ in layers:\n        if z_min  z_start  z_max:\n            eta_split = (z_start - z_c) / (h_e / 2.0)\n            eta_splits.append(eta_split)\n    eta_splits = sorted(list(set(eta_splits)))\n\n    total_integral = 0.0\n    for i in range(len(eta_splits) - 1):\n        eta_a, eta_b = eta_splits[i], eta_splits[i+1]\n        \n        # Map [eta_a, eta_b] to [-1, 1] for Gauss quadrature\n        transform = lambda zeta: 0.5 * (eta_b - eta_a) * zeta + 0.5 * (eta_a + eta_b)\n        jacobian_1d = 0.5 * (eta_b - eta_a)\n        \n        integral_piece = 0.0\n        for k in range(len(GAUSS_POINTS)):\n            eta_val = transform(GAUSS_POINTS[k])\n            z_val = z_c + (h_e / 2.0) * eta_val\n            integrand_val = integrand_func(eta_val, z_val)\n            integral_piece += GAUSS_WEIGHTS[k] * integrand_val\n        \n        total_integral += jacobian_1d * integral_piece\n        \n    return total_integral\n\ndef compute_element_vectors(x_min, z_min, w_e, h_e, g, layers, p_func, H, W, ix, iz, Nx, Nz):\n    \"\"\"\n    Computes and returns element-level force vectors fg, f_sigma0, and f_t.\n    \"\"\"\n    fg_e_z = np.zeros(4)\n    f_sigma0_e = np.zeros(8)\n    ft_e = np.zeros(8)\n\n    xi_eta_nodes = np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]) # Local node coords\n\n    def get_rho(z):\n        if z >= H: return layers[-1][2]\n        for z_start, z_end, rho_val in layers:\n            if z_start = z = z_end:\n                 return rho_val\n        raise ValueError(f\"Density not found for z={z}\")\n\n    # ===== 1. Gravity Load Vector f_g (z-components only) =====\n    for i in range(4):\n        _, eta_i = xi_eta_nodes[i]\n        def integrand_fg(eta, z): return g * get_rho(z) * (1.0 + eta_i * eta)\n        integral_val = integrate_1d_layered(integrand_fg, z_min, z_min + h_e, layers)\n        fg_e_z[i] = (w_e * h_e / 8.0) * integral_val\n\n    # ===== 2. Initial Stress Vector f_sigma0 =====\n    for i in range(4):\n        xi_i, eta_i = xi_eta_nodes[i]\n        # X-component\n        def integrand_x(eta, z): return (1.0 + eta_i * eta) * p_func(z)\n        integral_x = integrate_1d_layered(integrand_x, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i] = - (xi_i * h_e / 4.0) * integral_x\n        \n        # Z-component\n        def integrand_z(eta, z): return p_func(z)\n        integral_z = integrate_1d_layered(integrand_z, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i + 1] = - (eta_i * w_e / 4.0) * integral_z\n\n    # ===== 3. Boundary Traction Vector f_t =====\n    if iz == 0:  # Top boundary (z=0)\n        p0 = p_func(0.0)\n        ft_e[2*0 + 1] += p0 * w_e / 2.0  # Node 1 z-comp\n        ft_e[2*1 + 1] += p0 * w_e / 2.0  # Node 2 z-comp\n\n    if ix == 0:  # Left boundary (x=0)\n        def integrand_l1(eta, z): return p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_l4(eta, z): return p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*0] += (h_e/2.0) * integrate_1d_layered(integrand_l1, z_min, z_min+h_e, layers) # Node 1 x-comp\n        ft_e[2*3] += (h_e/2.0) * integrate_1d_layered(integrand_l4, z_min, z_min+h_e, layers) # Node 4 x-comp\n\n    if ix == Nx - 1:  # Right boundary (x=W)\n        def integrand_r2(eta, z): return -p_func(z) * 0.5 * (1.0 - eta)\n        def integrand_r3(eta, z): return -p_func(z) * 0.5 * (1.0 + eta)\n        ft_e[2*1] += (h_e/2.0) * integrate_1d_layered(integrand_r2, z_min, z_min+h_e, layers) # Node 2 x-comp\n        ft_e[2*2] += (h_e/2.0) * integrate_1d_layered(integrand_r3, z_min, z_min+h_e, layers) # Node 3 x-comp\n\n    return fg_e_z, f_sigma0_e, ft_e\n\ndef compute_residual(W, H, Nx, Nz, g, layers):\n    \"\"\"\n    Assembles global vectors and computes the infinity norm of the residual.\n    \"\"\"\n    dx, dz = W / Nx, H / Nz\n    num_nodes_x, num_nodes_z = Nx + 1, Nz + 1\n    num_dofs = 2 * num_nodes_x * num_nodes_z\n\n    f_g, f_sigma0, f_t = np.zeros(num_dofs), np.zeros(num_dofs), np.zeros(num_dofs)\n    p_func = create_pressure_function(H, g, layers)\n\n    for iz in range(Nz):\n        for ix in range(Nx):\n            x_min, z_min = ix * dx, iz * dz\n            \n            fg_e_z, f_sigma0_e, ft_e = compute_element_vectors(\n                x_min, z_min, dx, dz, g, layers, p_func, H, W, ix, iz, Nx, Nz)\n            \n            # Node indices (top-left, top-right, bottom-right, bottom-left)\n            node_indices = [\n                iz * num_nodes_x + ix,\n                iz * num_nodes_x + ix + 1,\n                (iz + 1) * num_nodes_x + ix + 1,\n                (iz + 1) * num_nodes_x + ix,\n            ]\n            \n            # Assemble\n            for i in range(4):\n                glob_idx = node_indices[i]\n                dof_x, dof_z = 2 * glob_idx, 2 * glob_idx + 1\n\n                f_g[dof_z] += fg_e_z[i]\n                \n                f_sigma0[dof_x] += f_sigma0_e[2 * i]\n                f_sigma0[dof_z] += f_sigma0_e[2 * i + 1]\n                \n                f_t[dof_x] += ft_e[2 * i]\n                f_t[dof_z] += ft_e[2 * i + 1]\n\n    residual = f_sigma0 - f_g - f_t\n    return np.max(np.abs(residual))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Modeling nearly incompressible materials, such as deep Earth mantle rock, presents a significant challenge in computational geophysics. Standard finite element formulations can suffer from \"volumetric locking,\" an artificial stiffening that renders results useless. This practice guides you through investigating this issue and its common but problematic remedy, reduced integration, which in turn introduces non-physical \"hourglass\" instabilities . You will not only diagnose these issues by analyzing the stiffness matrix's spectrum but also implement a divergence-based stabilization scheme to create a robust and accurate element that overcomes both locking and hourglassing.",
            "id": "3588945",
            "problem": "Consider two-dimensional small-strain, linear elasticity under plane strain for a single isoparametric bilinear quadrilateral element with four nodes. The displacement field is interpolated by bilinear shape functions, and the material is nearly incompressible, characterized by a Poisson ratio close to $0.5$. The fundamental starting point is the principle of virtual work and the associated strain-displacement and constitutive relations. You must reason from these foundations to formulate the element stiffness and load vector, examine the effect of reduced integration on the element stiffness, and design a divergence-based stabilization that preserves load consistency.\n\nThe fundamental base to use is as follows:\n- The principle of virtual work: for any admissible virtual displacement field, the internal virtual work equals the external virtual work.\n- The small-strain kinematics: the infinitesimal strain tensor is the symmetric gradient of displacement.\n- The linear elastic constitutive law under plane strain.\n- The isoparametric bilinear interpolation and standard Gaussian quadrature for numerical integration.\n\nWork in the following setting:\n- Geometry: a single bilinear quadrilateral element with nodes at physical coordinates $(x,y)$ given by $\\{(0,0),(1,0),(1,1),(0,1)\\}$ in meters. Use unit thickness in the out-of-plane direction. The element domain is denoted by $\\Omega_e$ and its area is $|\\Omega_e|$.\n- Displacements: nodal displacement vector $d_e \\in \\mathbb{R}^8$ ordered as $[u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]^T$ in meters.\n- Material: Young’s modulus $E$ in Pascals, Poisson’s ratio $\\nu$ (dimensionless), with plane strain constitutive matrix implied by these parameters.\n- Body force: constant vector $b = (b_x,b_y)$ in Newtons per cubic meter.\n- Quadrature: use reduced integration with a single Gauss point at the element center for the reduced integration stiffness, and standard $2 \\times 2$ Gauss integration for full integration and for the stabilization term.\n- Stabilization design parameter: a positive scalar $\\tau$ chosen in proportion to the shear modulus to regularize zero-energy modes without polluting the incompressible limit.\n\nTasks to complete:\n1) Starting from the principle of virtual work and small-strain kinematics, derive the element’s reduced-integration stiffness matrix $K_e^{\\text{red}}$ obtained by evaluating the bilinear form at the single Gauss point at the element center. Ensure to construct the strain-displacement matrix $B(\\xi,\\eta)$ at the Gauss point using the isoparametric mapping and the bilinear shape functions, and the plane strain constitutive matrix $C(E,\\nu)$.\n2) Using the same foundational starting point, derive a divergence-based stabilization matrix of the form\n$$\nK_{\\text{stab}} = \\tau \\int_{\\Omega_e} H^T H \\, d\\Omega,\n$$\nwhere $H$ maps nodal displacements to the displacement divergence, that is, for nodal displacements $d_e$ the divergence of the interpolated displacement is $(\\nabla \\cdot u_h) = H d_e$. Express $H$ at a quadrature point in terms of spatial derivatives of the bilinear shape functions, and evaluate $K_{\\text{stab}}$ using standard $2 \\times 2$ Gauss integration. Specify a choice of $\\tau$ in terms of fundamental material and geometric scales that is dimensionally consistent and does not degrade the nearly incompressible limit.\n3) From the principle of virtual work’s external work term with constant body force, derive the consistent nodal body force vector\n$$\nf_e = \\int_{\\Omega_e} N^T b \\, d\\Omega,\n$$\nwhere $N$ is the matrix of bilinear shape functions mapping nodal displacements to the field. Evaluate this using standard $2 \\times 2$ Gauss integration and verify analytically what this integral must equal for a constant $b$ on this element with unit thickness and area $|\\Omega_e|$.\n4) Explain, from first principles, why adding $K_{\\text{stab}}$ does not require any modification of the consistent body force vector to preserve load consistency for constant body forces, and why the stabilization should not introduce spurious work for rigid body motions.\n5) Numerically investigate the effect of reduced integration and the proposed stabilization on the stiffness matrix’s spectrum, including the dimension of its nullspace and its conditioning once the rigid body modes are removed.\n\nImplement a program that carries out the above for the following test suite. Use the specified physical units: meters for length, Pascals for Young’s modulus, and Newtons per cubic meter for body force. Angles are not involved. When a numerical tolerance is needed for deciding if an eigenvalue is effectively zero, use a relative threshold where values below $10^{-8}$ times the largest magnitude eigenvalue are regarded as zero.\n\nParameter values and test suite:\n- Element node coordinates: $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$ in meters. Unit thickness.\n- Material parameters: $E = 10^6$ Pascals, $\\nu = 0.4999$ (dimensionless).\n- Stabilization scaling: choose $\\tau = \\beta \\, \\mu \\, h^2$, where $\\mu$ is the shear modulus implied by $(E,\\nu)$ under plane strain, and $h = \\sqrt{|\\Omega_e|}$. Use $\\beta = 1/3$ (dimensionless). For this element, $|\\Omega_e| = 1$ square meter so $h = 1$ meter.\n- Body force for load consistency check: $b = (3.2,-1.7)$ Newtons per cubic meter.\n\nYour program must:\n- Assemble and store the following element matrices:\n  - $K_e^{\\text{red}}$ using one-point reduced integration at the element center.\n  - $K_e^{\\text{full}}$ using standard $2 \\times 2$ Gauss integration.\n  - $K_{\\text{stab}}$ using standard $2 \\times 2$ Gauss integration with the chosen $\\tau$.\n  - $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$.\n- Compute the consistent body force vector $f_e$ using $2 \\times 2$ Gauss integration, and compare it to the analytic value implied by a constant $b$ over $\\Omega_e$.\n- Compute the following quantitative outputs:\n  1) An integer equal to the number of eigenvalues of $K_e^{\\text{red}}$ that are below the effective-zero threshold (the nullity).\n  2) An integer equal to the number of eigenvalues of $K_e^{\\text{tot}}$ that are below the effective-zero threshold.\n  3) A float equal to the maximum absolute component-wise difference between the numerically integrated $f_e$ and the analytic $f_e$ for the constant body force $b$.\n  4) A boolean indicating whether the sum of the nodal force components in $f_e$ equals the total body force over the element, that is, whether $\\sum_i (f_{e,ix}, f_{e,iy})$ equals $(b_x |\\Omega_e|, b_y |\\Omega_e|)$ within the same numerical tolerance.\n  5) A float equal to $\\log_{10}$ of the condition number of $K_e^{\\text{full}}$ restricted to its positive spectrum (largest positive eigenvalue divided by the smallest positive eigenvalue).\n  6) A float equal to $\\log_{10}$ of the condition number of $K_e^{\\text{tot}}$ restricted to its positive spectrum.\n\nFinal output format:\n- Your program should produce a single line of output containing the results aggregated as a comma-separated list enclosed in square brackets, in the order given above. For example, produce an output of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$ where $r_1$ and $r_2$ are integers, $r_3$, $r_5$, and $r_6$ are floats, and $r_4$ is a boolean.",
            "solution": "The problem requires a comprehensive derivation and numerical implementation for a single 4-node quadrilateral finite element under plane strain, focusing on the challenges of near-incompressibility. I will proceed by first establishing the theoretical framework and then detailing the specific derivations and analyses requested.\n\n### 1. Theoretical Foundation: Principle of Virtual Work and Finite Element Discretization\n\nThe foundation of the finite element method for solid mechanics is the principle of virtual work. For a body occupying a domain $V$ with boundary $\\Gamma$, in equilibrium under body forces $b$ and surface tractions $\\bar{t}$, the principle states that the internal virtual work equals the external virtual work for any kinematically admissible virtual displacement field $\\delta u$:\n$$\n\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}\n$$\n$$\n\\int_V \\delta\\varepsilon^T \\sigma \\, dV = \\int_V \\delta u^T b \\, dV + \\int_{\\Gamma_t} \\delta u^T \\bar{t} \\, d\\Gamma\n$$\nHere, $\\sigma$ is the Cauchy stress tensor and $\\varepsilon$ is the infinitesimal strain tensor, both in Voigt notation. The virtual strain is $\\delta\\varepsilon$. For small-strain linear elasticity, the constitutive relation is $\\sigma = C \\varepsilon$, and the strain-displacement relation is $\\varepsilon = \\mathcal{L}u$, where $\\mathcal{L}$ is a differential operator.\n\nIn the finite element method, the domain is discretized into elements. Within an element $\\Omega_e$ (with volume $V_e$), the displacement field $u$ and its variation $\\delta u$ are interpolated from nodal values, $d_e$ and $\\delta d_e$, using a matrix of shape functions $N$:\n$$\nu(x) = N(x) d_e \\quad \\text{and} \\quad \\delta u(x) = N(x) \\delta d_e\n$$\nThe strain is then related to nodal displacements via the strain-displacement matrix $B$, which contains spatial derivatives of the shape functions:\n$$\n\\varepsilon(x) = B(x) d_e \\quad \\text{and} \\quad \\delta\\varepsilon(x) = B(x) \\delta d_e\n$$\nSubstituting these into the virtual work equation for a single element (neglecting surface tractions for this problem) yields:\n$$\n\\int_{V_e} (B \\delta d_e)^T C (B d_e) \\, dV = \\int_{V_e} (N \\delta d_e)^T b \\, dV\n$$\nSince $\\delta d_e$ is arbitrary, this leads to the element system of equations $K_e d_e = f_e$, where the element stiffness matrix $K_e$ and consistent nodal force vector $f_e$ are:\n$$\nK_e = \\int_{V_e} B^T C B \\, dV \\quad \\text{and} \\quad f_e = \\int_{V_e} N^T b \\, dV\n$$\nFor a two-dimensional problem with unit thickness $t=1$, the volume integral $dV$ becomes an area integral $d\\Omega$. The integration is performed numerically over a reference element domain $(\\xi, \\eta) \\in [-1, 1]^2$ using Gaussian quadrature:\n$$\nK_e = \\int_{-1}^1 \\int_{-1}^1 B(\\xi, \\eta)^T C B(\\xi, \\eta) \\det(J(\\xi, \\eta)) \\, t \\, d\\xi d\\eta\n$$\nwhere $J$ is the Jacobian of the isoparametric mapping from reference to physical coordinates.\n\n### 2. Isoparametric Bilinear Element\n\nThe element has nodes at $\\{(0,0), (1,0), (1,1), (0,1)\\}$. The mapping from reference coordinates $(\\xi, \\eta)$ to physical coordinates $(x,y)$ is $x(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) x_i$ and $y(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) y_i$. For the given nodes, this results in the affine mapping $x = \\frac{1}{2}(1+\\xi)$ and $y = \\frac{1}{2}(1+\\eta)$. The Jacobian matrix of this mapping is constant:\n$$\nJ = \\begin{pmatrix} \\partial x / \\partial \\xi  \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta  \\partial y / \\partial \\eta \\end{pmatrix} = \\begin{pmatrix} 1/2  0 \\\\ 0  1/2 \\end{pmatrix}\n$$\nIts determinant is $\\det(J) = 1/4$. The spatial derivatives of a shape function $N_i$ are found using the inverse Jacobian: $\\begin{pmatrix} N_{i,x} \\\\ N_{i,y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} N_{i,\\xi} \\\\ N_{i,\\eta} \\end{pmatrix}$.\n\n### 3. Task 1: Reduced-Integration Stiffness Matrix $K_e^{\\text{red}}$\n\nThe stiffness matrix is $K_e = \\int_{\\Omega_e} B^T C B \\, d\\Omega$. The plane strain constitutive matrix $C$ is given by:\n$$\nC = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\nThe strain-displacement matrix $B(\\xi, \\eta)$ is a $3 \\times 8$ matrix constructed from the spatial derivatives of the shape functions. For node $i$, the corresponding columns are $B_i = [ \\begin{smallmatrix} N_{i,x}  0 \\\\ 0  N_{i,y} \\\\ N_{i,y}  N_{i,x} \\end{smallmatrix} ]$.\n\nReduced integration uses a single Gauss point at the element center $(\\xi, \\eta) = (0, 0)$ with weight $4$ (for the $[-1,1]^2$ domain). The stiffness matrix integral simplifies to a single evaluation:\n$$\nK_e^{\\text{red}} = \\left. B^T C B \\right|_{(\\xi, \\eta)=(0,0)} \\cdot |\\Omega_e|\n$$\nwhere $|\\Omega_e| = \\int_{-1}^1\\int_{-1}^1 \\det(J) \\, d\\xi d\\eta = 1/4 \\cdot 4 = 1$. At $(\\xi, \\eta) = (0,0)$, the matrix of spatial derivatives of all shape functions needed for B is:\n$$\n\\left[ \\{N_{i,x}\\}_{i=1}^4, \\{N_{i,y}\\}_{i=1}^4 \\right]_{(0,0)} = \\frac{1}{2}\\begin{bmatrix} -1  1  1  -1 \\\\ -1  -1  1  1 \\end{bmatrix}\n$$\nThis defines $B(0,0)$, which is then used with the material matrix $C$ to compute $K_e^{\\text{red}}$.\n\n### 4. Task 2: Divergence-Based Stabilization Matrix $K_{\\text{stab}}$\n\nTo counteract the spurious zero-energy (\"hourglass\") modes introduced by reduced integration, a stabilization term is added to the virtual work formulation:\n$$\n\\delta W_{\\text{stab}} = \\int_{V_e} \\tau (\\nabla \\cdot \\delta u_h) (\\nabla \\cdot u_h) \\, dV\n$$\nThe divergence of the interpolated displacement field $u_h$ is $\\nabla \\cdot u_h = \\sum_i (N_{i,x} u_{ix} + N_{i,y} u_{iy})$. This can be written as $(\\nabla \\cdot u_h) = H d_e$, where $H$ is the $1 \\times 8$ row vector:\n$$\nH(\\xi, \\eta) = [N_{1,x}, N_{1,y}, N_{2,x}, N_{2,y}, N_{3,x}, N_{3,y}, N_{4,x}, N_{4,y}]\n$$\nThe stabilization matrix is thus:\n$$\nK_{\\text{stab}} = \\int_{V_e} \\tau H^T H \\, dV = \\tau \\int_{\\Omega_e} H^T H \\, t \\, d\\Omega\n$$\nThis integral is evaluated using standard $2 \\times 2$ Gaussian quadrature.\n\nThe stabilization parameter $\\tau$ is specified as $\\tau = \\beta \\mu h^2$. Given $\\beta=1/3$, $h=\\sqrt{|\\Omega_e|}=1 \\text{ m}$, and shear modulus $\\mu = E/(2(1+\\nu))$, this yields $\\tau = \\frac{1}{3}\\mu$. It must be noted that the formula $\\tau = \\beta \\mu h^2$ as given in the problem is dimensionally inconsistent. A stabilization parameter $\\tau$ in this formulation must have units of pressure (Pascals), like the shear modulus $\\mu$. The term $h^2$ introduces an extra factor of length squared. However, since the problem specifies $h=1$ m, the numerical value used, $\\tau = \\beta \\mu$, is physically and dimensionally sound.\n\n### 5. Task 3: Consistent Body Force Vector $f_e$\n\nThe consistent nodal force vector arises from the external virtual work of the body force $b=(b_x, b_y)$:\n$$\nf_e = \\int_{V_e} N^T b \\, dV = t \\int_{\\Omega_e} N^T b \\, d\\Omega\n$$\nwhere $N$ is the $2 \\times 8$ matrix of shape functions. For a constant body force $b$, the integral for the force on node $i$, $f_{ei} = b \\cdot t \\int_{\\Omega_e} N_i \\, d\\Omega$, can be evaluated analytically. The integral of a single bilinear shape function over the element area is $\\int_{\\Omega_e} N_i d\\Omega = |\\Omega_e|/4$. Thus, for the unit square element ($|\\Omega_e|=1, t=1$), each node receives an equal share of the total force: $f_{ei} = b/4$. The total force vector is $f_e = [b_x/4, b_y/4, \\dots, b_x/4, b_y/4]^T$. The $2 \\times 2$ quadrature is sufficient to integrate the linear shape functions exactly, so the numerical result is expected to match the analytical one to machine precision.\n\n### 6. Task 4: Load Consistency and Rigid Body Motions\n\nThe stabilization term is added to the internal virtual work, modifying the stiffness part of the equilibrium equations. The external virtual work term, from which the load vector $f_e$ is derived, remains unchanged. This separation ensures that the stabilization, which is an internal penalty, does not alter the representation of the external physical load. Thus, no modification to $f_e$ is required to maintain load consistency.\n\nA valid stabilization must not penalize rigid body motions, which are strain-free deformations. The two-dimensional rigid body motions (2 translations, 1 rotation) all have zero divergence ($\\nabla \\cdot u_{RBM} = 0$). Since the stabilization term is proportional to $(\\nabla \\cdot u_h)^2$, it is identically zero for any rigid body motion. Consequently, the matrix $K_{\\text{stab}}$ does not apply any spurious forces or energy penalty to these modes, correctly leaving them in the nullspace of the element stiffness matrix. This is proven by noting that if $d_{RBM}$ is a nodal vector for a rigid body motion, then $H d_{RBM} = 0$, and thus $K_{stab} d_{RBM} = (\\tau \\int H^T H d\\Omega)d_{RBM} = 0$.\n\n### 7. Task 5: Numerical Investigation Plan\n\nThe provided Python code will computationally execute the prior theoretical steps. It will:\n1.  Assemble the fully integrated stiffness matrix $K_e^{\\text{full}}$, the reduced-integration matrix $K_e^{\\text{red}}$, and the stabilization matrix $K_{\\text{stab}}$.\n2.  Form the final stabilized stiffness matrix $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$.\n3.  Compute the consistent load vector $f_e$.\n4.  Perform eigenvalue analysis on $K_e^{\\text{red}}$ and $K_e^{\\text{tot}}$ to determine their nullities. We expect a nullity of $5$ for $K_e^{\\text{red}}$ (3 rigid body modes + 2 hourglass modes) and $3$ for $K_e^{\\text{tot}}$ (stabilization removes hourglass modes).\n5.  Calculate the condition numbers of the positive-definite parts of $K_e^{\\text{full}}$ and $K_e^{\\text{tot}}$. We expect $K_e^{\\text{full}}$ to be ill-conditioned due to volumetric locking, while $K_e^{\\text{tot}}$ should be significantly better conditioned.\n6.  Verify the accuracy of the computed load vector $f_e$ against its analytical value and check the conservation of total force.\n\nThe results of this numerical study will provide quantitative insight into the effects of reduced integration and stabilization on element performance in the near-incompressible limit.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM problem for a single bilinear quadrilateral element as specified.\n    \"\"\"\n    # Parameter values and test suite\n    E = 1.0e6  # Young's modulus in Pascals\n    nu = 0.4999  # Poisson's ratio (dimensionless)\n    b_vec = np.array([3.2, -1.7])  # Body force in N/m^3\n    beta = 1.0 / 3.0  # Stabilization coefficient\n    \n    # Element Geometry\n    thickness = 1.0  # Unit thickness in meters\n    area = 1.0  # Area in square meters\n    h = np.sqrt(area)  # Characteristic length in meters\n\n    # Material properties\n    # Plane strain constitutive matrix\n    C_factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    C = C_factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n    \n    # Shear modulus and stabilization parameter\n    mu = E / (2.0 * (1.0 + nu))\n    # Using the formula from the problem statement: tau = beta * mu * h^2\n    # Since h=1, this is numerically equivalent to tau = beta * mu.\n    tau = beta * mu * h**2\n\n    # Quadrature rules\n    # 2x2 Gauss Quadrature for [-1, 1] x [-1, 1]\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_pts_2x2 = [(-gp_val, -gp_val), (gp_val, -gp_val),\n                     (gp_val, gp_val), (-gp_val, gp_val)]\n    gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # Shape functions and their derivatives in the reference element\n    def get_shape_info(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta),\n                             (1 + xi) * (1 - eta),\n                             (1 + xi) * (1 + eta),\n                             (1 - xi) * (1 + eta)])\n        \n        dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dNdxi, dNdeta\n\n    # Jacobian is constant for this specific geometry (unit square)\n    # Mapping: x = 0.5*(1+xi), y = 0.5*(1+eta)\n    J = np.array([[0.5, 0.0], [0.0, 0.5]])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n\n    def get_B_and_H_matrices(dNdxi, dNdeta):\n        B = np.zeros((3, 8))\n        H = np.zeros(8)\n        for i in range(4):\n            dNd_phys = invJ @ np.array([dNdxi[i], dNdeta[i]])\n            dNdx_i, dNdy_i = dNd_phys[0], dNd_phys[1]\n            \n            # Strain-displacement matrix B for node i\n            B[0, 2 * i] = dNdx_i\n            B[1, 2 * i + 1] = dNdy_i\n            B[2, 2 * i] = dNdy_i\n            B[2, 2 * i + 1] = dNdx_i\n            \n            # Divergence operator H for node i\n            H[2 * i] = dNdx_i\n            H[2 * i + 1] = dNdy_i\n            \n        return B, H\n\n    # Assemble K_full, K_stab, and f_e using 2x2 quadrature\n    K_full = np.zeros((8, 8))\n    K_stab = np.zeros((8, 8))\n    f_e = np.zeros(8)\n\n    for i in range(len(gauss_pts_2x2)):\n        xi, eta = gauss_pts_2x2[i]\n        w = gauss_w_2x2[i]\n        \n        N, dNdxi, dNdeta = get_shape_info(xi, eta)\n        B, H = get_B_and_H_matrices(dNdxi, dNdeta)\n        \n        K_full += B.T @ C @ B * detJ * w * thickness\n        K_stab += tau * np.outer(H, H) * detJ * w * thickness\n        \n        # Consistent load vector contribution\n        N_mat = np.zeros((2, 8))\n        for j in range(4):\n            N_mat[0, 2 * j] = N[j]\n            N_mat[1, 2 * j + 1] = N[j]\n        f_e += N_mat.T @ b_vec * detJ * w * thickness\n\n    # Assemble K_red using 1-point quadrature\n    xi_red, eta_red = 0.0, 0.0\n    _, dNdxi_red, dNdeta_red = get_shape_info(xi_red, eta_red)\n    B_red, _ = get_B_and_H_matrices(dNdxi_red, dNdeta_red)\n    K_red = B_red.T @ C @ B_red * area * thickness\n\n    # Total stabilized stiffness matrix\n    K_tot = K_red + K_stab\n    \n    # --- Perform Numerical Analysis ---\n\n    # 1. Nullity of K_red\n    e_vals_red = np.linalg.eigvalsh(K_red)\n    lambda_max_red = np.max(np.abs(e_vals_red))\n    tol_red = 1e-8 * lambda_max_red if lambda_max_red > 1e-15 else 1e-8\n    nullity_red = np.sum(np.abs(e_vals_red)  tol_red)\n    \n    # 2. Nullity of K_tot\n    e_vals_tot = np.linalg.eigvalsh(K_tot)\n    lambda_max_tot = np.max(np.abs(e_vals_tot))\n    tol_tot = 1e-8 * lambda_max_tot if lambda_max_tot > 1e-15 else 1e-8\n    nullity_tot = np.sum(np.abs(e_vals_tot)  tol_tot)\n\n    # 3. Maximum absolute difference in force vector\n    f_analytic = np.tile(b_vec * area * thickness / 4.0, 4)\n    f_diff = np.max(np.abs(f_e - f_analytic))\n\n    # 4. Consistency of total nodal force\n    sum_f_num = np.array([np.sum(f_e[0::2]), np.sum(f_e[1::2])])\n    sum_f_analytic = b_vec * area * thickness\n    is_consistent = np.allclose(sum_f_num, sum_f_analytic, rtol=1e-8, atol=1e-9)\n\n    # Helper for condition number calculation\n    def get_log10_cond(matrix, tol_factor=1e-8):\n        e_vals = np.linalg.eigvalsh(matrix)\n        lambda_max = np.max(e_vals)\n        tol = tol_factor * lambda_max if lambda_max > 1e-15 else tol_factor\n        positive_eigs = e_vals[e_vals > tol]\n        if len(positive_eigs) == 0:\n            return np.inf\n        return np.log10(np.max(positive_eigs) / np.min(positive_eigs))\n\n    # 5. Log10 condition number of K_full\n    cond_full_log10 = get_log10_cond(K_full)\n    \n    # 6. Log10 condition number of K_tot\n    cond_tot_log10 = get_log10_cond(K_tot)\n\n    # --- Format and Print Final Output ---\n    results = [\n        int(nullity_red), \n        int(nullity_tot), \n        float(f_diff), \n        bool(is_consistent), \n        float(cond_full_log10), \n        float(cond_tot_log10)\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Enhancing the accuracy of finite element simulations often involves using more complex elements, but this can increase computational cost. Static condensation is an elegant and efficient technique to build more powerful elements without enlarging the final global system of equations. This practice focuses on implementing the algebraic procedure of static condensation, where internal \"bubble\" degrees of freedom that enrich the element's descriptive power are eliminated at the element level . This process yields a condensed, yet more accurate, element stiffness matrix and load vector, ready for standard assembly, providing you with a tool to develop advanced custom elements.",
            "id": "3588930",
            "problem": "Consider the scalar diffusion problem in two spatial dimensions, representative of steady-state groundwater flow or steady heat conduction in computational geophysics, governed by the partial differential equation $-\\nabla \\cdot (\\kappa \\nabla u) = s$ in a bounded domain. Here, $u$ is the scalar field, $\\kappa$ is the diffusivity, and $s$ is a source term. The standard finite element method approximates $u$ with shape functions and forms the element stiffness matrix and element load vector by applying the Galerkin method to the weak form. For an element with mixed approximation consisting of boundary-supported shape functions for the element boundary Degrees of Freedom (DOF) and internal bubble shape functions for internal DOF that vanish on the element boundary, the element-wise discretization yields a block system of the form\n$$\n\\begin{bmatrix}\nK_{aa}  K_{ab} \\\\\nK_{ba}  K_{bb}\n\\end{bmatrix}\n\\begin{bmatrix}\nu_a \\\\\nu_b\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_a \\\\\nf_b\n\\end{bmatrix},\n$$\nwhere $K_{aa}$ couples the boundary-supported DOF, $K_{bb}$ couples the internal bubble DOF, and $K_{ab}$ and $K_{ba}$ represent cross-couplings between boundary-supported and bubble DOF. The vectors $f_a$ and $f_b$ are the corresponding partitions of the element load vector. The matrix $K_{bb}$ is assumed to be symmetric positive definite so that the internal bubble DOF can be eliminated.\n\nStarting from the weak form definition of the element stiffness and load contributions, namely $K_{ij} = \\int_{\\Omega_e} \\kappa \\nabla N_i \\cdot \\nabla N_j \\, d\\Omega$ and $f_i = \\int_{\\Omega_e} N_i s \\, d\\Omega$ for any pair of shape functions $N_i$ and $N_j$ over an element $\\Omega_e$, derive the algebraic elimination procedure to remove the internal bubble DOF by static condensation, and express the condensed system that involves only the boundary-supported DOF. Your derivation must proceed from the block linear system written above and elementary linear algebra operations, without skipping steps. Do not introduce any quantities that have not been defined. All quantities in this problem are dimensionless, and no physical units are required in the final numerical results.\n\nThen, implement a program that takes a set of test element partitions $(K_{aa}, K_{ab}, K_{bb}, f_a, f_b)$ and computes, for each test case, the condensed element stiffness matrix and condensed element load vector involving only the boundary-supported DOF.\n\nTest Suite:\n- Case $1$ (general coupling, one internal bubble DOF):\n    - $K_{aa} = \\begin{bmatrix} 4  -1 \\\\ -1  3 \\end{bmatrix}$,\n    - $K_{ab} = \\begin{bmatrix} 0.5 \\\\ -0.2 \\end{bmatrix}$,\n    - $K_{ba} = K_{ab}^\\top$,\n    - $K_{bb} = \\begin{bmatrix} 1.5 \\end{bmatrix}$,\n    - $f_a = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$,\n    - $f_b = \\begin{bmatrix} 0.3 \\end{bmatrix}$.\n- Case $2$ (zero coupling, one internal bubble DOF):\n    - $K_{aa} = \\begin{bmatrix} 2 \\end{bmatrix}$,\n    - $K_{ab} = \\begin{bmatrix} 0 \\end{bmatrix}$,\n    - $K_{ba} = K_{ab}^\\top$,\n    - $K_{bb} = \\begin{bmatrix} 5 \\end{bmatrix}$,\n    - $f_a = \\begin{bmatrix} 0.5 \\end{bmatrix}$,\n    - $f_b = \\begin{bmatrix} 1 \\end{bmatrix}$.\n- Case $3$ (general coupling, two internal bubble DOF):\n    - $K_{aa} = \\begin{bmatrix} 6  -2  0 \\\\ -2  5  -1 \\\\ 0  -1  4 \\end{bmatrix}$,\n    - $K_{ab} = \\begin{bmatrix} 0.1  -0.3 \\\\ 0  0.2 \\\\ -0.2  0.4 \\end{bmatrix}$,\n    - $K_{ba} = K_{ab}^\\top$,\n    - $K_{bb} = \\begin{bmatrix} 3  0.1 \\\\ 0.1  2.5 \\end{bmatrix}$,\n    - $f_a = \\begin{bmatrix} 0 \\\\ 1 \\\\ -0.5 \\end{bmatrix}$,\n    - $f_b = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix}$.\n\nAlgorithmic task:\n- For each case, compute the condensed element stiffness matrix for the boundary-supported DOF and the condensed element load vector for the boundary-supported DOF obtained by exact static condensation of the internal bubble DOF.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result for one test case must itself be a list consisting of the concatenation of the condensed stiffness matrix entries (row-major order) followed by the condensed load vector entries. For example, for a case that condenses to a $2 \\times 2$ matrix and a $2$-entry vector, the sublist should contain $6$ numbers. The overall output should look like $[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list}]$, where each $\\text{caseX\\_list}$ is a Python-style list of floats.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The task is to derive the algebraic procedure for static condensation in the finite element method and then apply it to a given set of test cases.\n\nThe derivation begins with the block linear system provided, which arises from partitioning the element degrees of freedom (DOF) into boundary-supported DOF, denoted by the subscript `$a$`, and internal bubble DOF, denoted by the subscript `$b$`. The system is:\n$$\n\\begin{bmatrix}\nK_{aa}  K_{ab} \\\\\nK_{ba}  K_{bb}\n\\end{bmatrix}\n\\begin{bmatrix}\nu_a \\\\\nu_b\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_a \\\\\nf_b\n\\end{bmatrix}\n$$\nHere, $u_a$ and $u_b$ are the vectors of unknown coefficients for the boundary-supported and internal shape functions, respectively. $K_{aa}$, $K_{ab}$, $K_{ba}$, and $K_{bb}$ are the corresponding block partitions of the element stiffness matrix, and $f_a$ and $f_b$ are the partitions of the element load vector.\n\nThis block matrix equation can be expanded into two separate matrix equations:\n$$\nK_{aa} u_a + K_{ab} u_b = f_a \\quad (1)\n$$\n$$\nK_{ba} u_a + K_{bb} u_b = f_b \\quad (2)\n$$\nThe goal of static condensation is to eliminate the internal DOF vector $u_b$ to obtain a smaller system that relates only the boundary-supported DOF $u_a$. This is achieved by using one of the equations to express $u_b$ in terms of $u_a$ and then substituting this expression into the other equation.\n\nWe proceed by isolating the term involving $u_b$ in equation $(2)$:\n$$\nK_{bb} u_b = f_b - K_{ba} u_a\n$$\nThe problem states that the submatrix $K_{bb}$ is symmetric positive definite. A key property of a positive definite matrix is that it is invertible. Therefore, we can pre-multiply both sides of the equation by the inverse of $K_{bb}$, denoted as $K_{bb}^{-1}$:\n$$\nK_{bb}^{-1} (K_{bb} u_b) = K_{bb}^{-1} (f_b - K_{ba} u_a)\n$$\nBy the definition of a matrix inverse, $K_{bb}^{-1} K_{bb}$ is the identity matrix $I$. Thus, we obtain an explicit expression for the internal DOF vector $u_b$:\n$$\nu_b = K_{bb}^{-1} f_b - K_{bb}^{-1} K_{ba} u_a \\quad (3)\n$$\nThis equation shows that the internal DOF $u_b$ can be fully determined once the boundary-supported DOF $u_a$ and the element loads are known.\n\nThe next step is to substitute this expression for $u_b$ back into the first equation, equation $(1)$:\n$$\nK_{aa} u_a + K_{ab} (K_{bb}^{-1} f_b - K_{bb}^{-1} K_{ba} u_a) = f_a\n$$\nWe can distribute the matrix $K_{ab}$ over the terms in the parenthesis:\n$$\nK_{aa} u_a + K_{ab} K_{bb}^{-1} f_b - K_{ab} K_{bb}^{-1} K_{ba} u_a = f_a\n$$\nTo create a system solely in terms of $u_a$, we gather all terms involving $u_a$ on the left-hand side and all other terms, which act as an effective load, on the right-hand side:\n$$\nK_{aa} u_a - K_{ab} K_{bb}^{-1} K_{ba} u_a = f_a - K_{ab} K_{bb}^{-1} f_b\n$$\nFactoring out the vector $u_a$ from the terms on the left-hand side yields:\n$$\n(K_{aa} - K_{ab} K_{bb}^{-1} K_{ba}) u_a = f_a - K_{ab} K_{bb}^{-1} f_b\n$$\nThis is the final condensed system of equations involving only the boundary-supported DOF, $u_a$. It can be written in the compact form:\n$$\nK_c u_a = f_c\n$$\nwhere the condensed (or effective) element stiffness matrix, $K_c$, is defined as:\n$$\nK_c = K_{aa} - K_{ab} K_{bb}^{-1} K_{ba}\n$$\nAnd the condensed (or effective) element load vector, $f_c$, is defined as:\n$$\nf_c = f_a - K_{ab} K_{bb}^{-1} f_b\n$$\nThe matrix term $K_{ab} K_{bb}^{-1} K_{ba}$ is known as the Schur complement of the block $K_{bb}$ in the original element stiffness matrix. This derivation provides the precise algebraic formulas required to compute the condensed system from the partitioned blocks of the original element system. The following program implements these formulas for the specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the static condensation problem for a set of test cases.\n    \"\"\"\n\n    def static_condensation(Kaa, Kab, Kbb, fa, fb):\n        \"\"\"\n        Performs static condensation to eliminate internal bubble DOFs.\n\n        Args:\n            Kaa (np.ndarray): Stiffness matrix partition for boundary-supported DOFs.\n            Kab (np.ndarray): Coupling stiffness matrix partition.\n            Kbb (np.ndarray): Stiffness matrix partition for internal bubble DOFs.\n            fa (np.ndarray): Load vector partition for boundary-supported DOFs.\n            fb (np.ndarray): Load vector partition for internal bubble DOFs.\n\n        Returns:\n            tuple: A tuple containing the condensed stiffness matrix (Kc) and the\n                   condensed load vector (fc).\n        \"\"\"\n        # From the derivation, the condensed system is Kc * ua = fc\n        # Kc = Kaa - Kab * inv(Kbb) * Kba\n        # fc = fa - Kab * inv(Kbb) * fb\n        # The problem states Kba is the transpose of Kab.\n        Kba = Kab.T\n        \n        # Kbb is guaranteed to be invertible.\n        Kbb_inv = np.linalg.inv(Kbb)\n\n        # Calculate the condensed stiffness matrix\n        Kc = Kaa - Kab @ Kbb_inv @ Kba\n\n        # Calculate the condensed load vector\n        fc = fa - Kab @ Kbb_inv @ fb\n\n        return Kc, fc\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            np.array([[4., -1.], [-1., 3.]]),\n            np.array([[0.5], [-0.2]]),\n            np.array([[1.5]]),\n            np.array([[1.], [0.]]),\n            np.array([[0.3]])\n        ),\n        # Case 2\n        (\n            np.array([[2.]]),\n            np.array([[0.]]),\n            np.array([[5.]]),\n            np.array([[0.5]]),\n            np.array([[1.]])\n        ),\n        # Case 3\n        (\n            np.array([[6., -2., 0.], [-2., 5., -1.], [0., -1., 4.]]),\n            np.array([[0.1, -0.3], [0., 0.2], [-0.2, 0.4]]),\n            np.array([[3., 0.1], [0.1, 2.5]]),\n            np.array([[0.], [1.], [-0.5]]),\n            np.array([[0.2], [-0.1]])\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        Kaa, Kab, Kbb, fa, fb = case\n        Kc, fc = static_condensation(Kaa, Kab, Kbb, fa, fb)\n\n        # Flatten the results into a single list per case as required.\n        # Kc_flat contains row-major entries of the condensed stiffness matrix.\n        Kc_flat = Kc.flatten().tolist()\n        # fc_flat contains entries of the condensed load vector.\n        fc_flat = fc.flatten().tolist()\n        \n        # Concatenate the lists.\n        case_result = Kc_flat + fc_flat\n\n        # Format the list to a string without spaces for clean output.\n        results.append(str(case_result).replace(\" \", \"\"))\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}