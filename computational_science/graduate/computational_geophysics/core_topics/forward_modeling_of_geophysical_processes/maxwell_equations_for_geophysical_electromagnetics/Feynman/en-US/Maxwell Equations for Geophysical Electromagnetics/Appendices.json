{
    "hands_on_practices": [
        {
            "introduction": "Time-domain electromagnetic (TDEM) simulations are governed by the diffusion equation, and solving this equation numerically requires discretizing both space and time. The choice of time-stepping scheme is critical, as explicit methods like Forward Euler are simple but have strict stability limits, while implicit methods like Crank-Nicolson are stable but can introduce accuracy issues if the time step is too large. This exercise provides hands-on practice with Von Neumann stability analysis, a cornerstone of numerical PDE analysis, allowing you to gain a concrete understanding of the fundamental trade-offs between computational cost, stability, and accuracy in TDEM modeling .",
            "id": "3610044",
            "problem": "Consider Time Domain Electromagnetics (TDEM) governed by the magnetic diffusion equation for the magnetic flux density $\\mathbf{B}$,\n$$\\partial_{t}\\mathbf{B} = -\\nabla\\times\\left(\\rho\\,\\nabla\\times \\mathbf{B}\\right),$$\nwhere the magnetic diffusivity is $\\rho = \\frac{1}{\\mu \\sigma}$, with $\\mu$ the magnetic permeability and $\\sigma$ the electrical conductivity. In a homogeneous medium with constant $\\mu$ and $\\sigma$, assume $\\nabla\\cdot\\mathbf{B}=0$ is satisfied initially and is preserved.\n\nYou will analyze two time-stepping schemes applied to the semi-discrete system obtained from second-order centered finite differences on a uniform Yee staggered grid in a triply periodic cubic domain of side $L$, with grid spacings $\\Delta x = \\Delta y = \\Delta z = \\Delta$. Use Von Neumann Fourier analysis. For this grid and discretization, the discrete curl-curl operator acting on divergence-free Fourier modes with wave vector $\\mathbf{k} = (k_{x},k_{y},k_{z})$ has an eigenvalue of the form $\\rho\\,\\omega(\\mathbf{k})$, where\n$$\\omega(\\mathbf{k}) = \\sum_{i\\in\\{x,y,z\\}} \\frac{4}{\\Delta^{2}}\\sin^{2}\\left(\\frac{k_{i}\\Delta}{2}\\right).$$\nAssume periodic boundary conditions so that the discrete wavenumbers attain their maximum magnitude at $k_{i}\\Delta = \\pi$.\n\n- For the explicit forward Euler method applied to the semi-discrete system, derive the linear stability constraint on the time step $\\Delta t$ in terms of the largest-magnitude discrete eigenvalue of the right-hand side operator.\n- For the implicit Crank–Nicolson method, which is second-order accurate in time, derive an accuracy constraint on $\\Delta t$ by requiring that, for the mode with the largest $|\\lambda|$, the one-step relative amplitude error compared to the exact solution be no larger than $\\varepsilon = 0.01$.\n\nTake $\\mu = \\mu_{0} = 4\\pi\\times 10^{-7}$, $\\sigma = 1$, and $\\Delta = 25$. Using the derived constraints, compute:\n\n1. The largest stable $\\Delta t$ for explicit forward Euler.\n2. The largest $\\Delta t$ for Crank–Nicolson that satisfies the above accuracy requirement.\n\nRound your answers to four significant figures. Express both time steps in seconds.",
            "solution": "The problem requires the derivation of time step constraints for two different numerical schemes, explicit forward Euler and implicit Crank–Nicolson, applied to the semi-discretized magnetic diffusion equation.\n\nThe governing equation in the time domain is given by:\n$$ \\partial_{t}\\mathbf{B} = -\\nabla\\times\\left(\\rho\\,\\nabla\\times \\mathbf{B}\\right) $$\nIn a homogeneous medium with constant resistivity $\\rho$, this simplifies to $\\partial_{t}\\mathbf{B} = -\\rho\\,\\nabla\\times(\\nabla\\times \\mathbf{B})$.\nUsing the vector identity $\\nabla\\times(\\nabla\\times \\mathbf{B}) = \\nabla(\\nabla\\cdot\\mathbf{B}) - \\nabla^2\\mathbf{B}$ and the condition $\\nabla\\cdot\\mathbf{B}=0$, the equation becomes the vector diffusion equation:\n$$ \\partial_{t}\\mathbf{B} = \\rho\\nabla^2\\mathbf{B} $$\nUpon spatial discretization using second-order centered finite differences on a uniform Yee grid, a system of ordinary differential equations (ODEs) is obtained. For a single Fourier mode with wave vector $\\mathbf{k}$, this semi-discrete system takes the form:\n$$ \\frac{d\\hat{\\mathbf{B}}_{\\mathbf{k}}}{dt} = \\lambda(\\mathbf{k})\\hat{\\mathbf{B}}_{\\mathbf{k}} $$\nwhere $\\hat{\\mathbf{B}}_{\\mathbf{k}}$ is the amplitude of the Fourier mode and $\\lambda(\\mathbf{k})$ is the corresponding eigenvalue of the discretized spatial operator. The problem provides that the discrete operator for $-\\rho\\nabla\\times(\\nabla\\times \\cdot)$ has eigenvalues for divergence-free modes given by:\n$$ \\lambda(\\mathbf{k}) = -\\rho\\,\\omega(\\mathbf{k}) = -\\rho \\sum_{i\\in\\{x,y,z\\}} \\frac{4}{\\Delta^{2}}\\sin^{2}\\left(\\frac{k_{i}\\Delta}{2}\\right) $$\nSince $\\rho$, $\\Delta^2$, and $\\sin^2(\\cdot)$ are all non-negative, the eigenvalues $\\lambda(\\mathbf{k})$ are real and non-positive, i.e., $\\lambda(\\mathbf{k}) \\le 0$. The analysis of stability and accuracy depends on the eigenvalue with the largest magnitude, which corresponds to the most rapidly decaying physical mode. This occurs when the term $\\sin^2(k_i\\Delta/2)$ is maximized for all components $i \\in \\{x,y,z\\}$. The maximum value of $\\sin^2(\\cdot)$ is $1$, which is achieved when its argument is $\\pi/2$. The problem states that periodic boundary conditions are used and the maximum magnitude for the discrete wavenumbers corresponds to $k_i\\Delta = \\pi$, which means $k_i\\Delta/2 = \\pi/2$.\n\nThe eigenvalue with the largest magnitude, denoted $\\lambda_{\\text{max-abs}}$, is therefore:\n$$ |\\lambda|_{\\max} \\equiv \\lambda_{\\text{max-abs}} = \\rho \\sum_{i\\in\\{x,y,z\\}} \\frac{4}{\\Delta^{2}}(1) = \\rho \\left(\\frac{4}{\\Delta^2} + \\frac{4}{\\Delta^2} + \\frac{4}{\\Delta^2}\\right) = \\frac{12\\rho}{\\Delta^2} $$\nThe corresponding eigenvalue is $\\lambda_{\\min} = -|\\lambda|_{\\max} = -12\\rho/\\Delta^2$.\n\nFirst, we calculate the numerical values of $\\rho$ and $|\\lambda|_{\\max}$.\nGiven:\nMagnetic permeability $\\mu = \\mu_0 = 4\\pi \\times 10^{-7} \\, \\text{H/m}$.\nElectrical conductivity $\\sigma = 1 \\, \\text{S/m}$.\nGrid spacing $\\Delta = 25 \\, \\text{m}$.\n\nThe magnetic diffusivity $\\rho$ is:\n$$ \\rho = \\frac{1}{\\mu\\sigma} = \\frac{1}{(4\\pi \\times 10^{-7})(1)} = \\frac{10^7}{4\\pi} \\, \\frac{\\text{m}^2}{\\text{s}} $$\nNow, we compute the largest-magnitude eigenvalue:\n$$ |\\lambda|_{\\max} = \\frac{12}{\\Delta^2}\\rho = \\frac{12}{(25)^2} \\frac{10^7}{4\\pi} = \\frac{12}{625} \\frac{10^7}{4\\pi} = \\frac{3 \\times 10^7}{625\\pi} \\, \\text{s}^{-1} $$\n\n**1. Explicit Forward Euler Stability Constraint**\n\nThe forward Euler method applied to the model ODE $du/dt = \\lambda u$ is:\n$$ u^{n+1} = u^n + \\Delta t (\\lambda u^n) = (1 + \\lambda \\Delta t)u^n $$\nThe numerical amplification factor is $G_{FE}(\\lambda, \\Delta t) = 1 + \\lambda \\Delta t$. For stability, the magnitude of the amplification factor must be less than or equal to one for all eigenvalues in the system's spectrum: $|G_{FE}| \\le 1$.\nSince $\\lambda$ is real and non-positive, let $\\lambda = -|\\lambda|$. The condition becomes:\n$$ |1 - |\\lambda| \\Delta t| \\le 1 $$\nThis is equivalent to the two inequalities:\n$$ -1 \\le 1 - |\\lambda| \\Delta t \\quad \\text{and} \\quad 1 - |\\lambda| \\Delta t \\le 1 $$\nThe second inequality simplifies to $-|\\lambda|\\Delta t \\le 0$, which is always true for $\\Delta t > 0$ and $|\\lambda| \\ge 0$. The first inequality gives:\n$$ |\\lambda| \\Delta t \\le 2 $$\nThis must hold for all modes. The most restrictive condition is for the mode with the largest $|\\lambda|$, i.e., $|\\lambda|_{\\max}$:\n$$ \\Delta t \\le \\frac{2}{|\\lambda|_{\\max}} $$\nThis gives the maximum stable time step for the forward Euler method.\n$$ \\Delta t_{FE, \\max} = \\frac{2}{|\\lambda|_{\\max}} = \\frac{2}{\\frac{3 \\times 10^7}{625\\pi}} = \\frac{1250\\pi}{3 \\times 10^7} \\, \\text{s} $$\nNumerically:\n$$ \\Delta t_{FE, \\max} \\approx \\frac{1250 \\times 3.14159265}{3 \\times 10^7} \\approx 1.3089969 \\times 10^{-4} \\, \\text{s} $$\nRounding to four significant figures, the largest stable time step is $1.309 \\times 10^{-4} \\, \\text{s}$.\n\n**2. Crank–Nicolson Accuracy Constraint**\n\nThe Crank–Nicolson method applied to $du/dt = \\lambda u$ is:\n$$ u^{n+1} = u^n + \\frac{\\Delta t}{2}(\\lambda u^n + \\lambda u^{n+1}) $$\nSolving for $u^{n+1}$ yields:\n$$ u^{n+1} = \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2} u^n $$\nThe amplification factor is $G_{CN}(\\lambda, \\Delta t) = \\frac{1 + \\lambda \\Delta t/2}{1 - \\lambda \\Delta t/2}$. For $\\lambda \\le 0$, $|G_{CN}| \\le 1$, so the method is unconditionally stable. The constraint comes from accuracy, not stability.\n\nThe exact amplification factor over one time step is $G_{\\text{exact}}(\\lambda, \\Delta t) = \\exp(\\lambda \\Delta t)$.\nThe one-step relative amplitude error is defined as:\n$$ E_{\\text{rel}} = \\left| \\frac{G_{CN} - G_{\\text{exact}}}{G_{\\text{exact}}} \\right| = \\left| \\frac{G_{CN}}{G_{\\text{exact}}} - 1 \\right| $$\nWe require $E_{\\text{rel}} \\le \\varepsilon = 0.01$ for the mode with the largest eigenvalue magnitude, $\\lambda = -|\\lambda|_{\\max}$.\nLet $x = |\\lambda|_{\\max}\\Delta t$. For this mode, the argument to the functions is $\\lambda \\Delta t = -x$.\nThe constraint is:\n$$ \\left| \\frac{G_{CN}(-|\\lambda|_{\\max}, \\Delta t)}{G_{\\text{exact}}(-|\\lambda|_{\\max}, \\Delta t)} - 1 \\right| = \\left| \\frac{(1-x/2)/(1+x/2)}{\\exp(-x)} - 1 \\right| \\le \\varepsilon $$\nThe quantity inside the absolute value is $\\frac{(1-x/2)\\exp(x)}{1+x/2} - 1$. A Taylor series expansion for small $x$ shows this quantity is negative.\n$\\ln(G_{CN}) - \\ln(G_{exact}) = \\ln(\\frac{1-x/2}{1+x/2}) - (-x) = (-x - \\frac{x^3}{12} - \\dots) + x = -\\frac{x^3}{12} - \\dots$\nThus, $\\frac{G_{CN}}{G_{exact}} \\approx \\exp(-x^3/12) \\approx 1 - x^3/12$. The ratio is less than $1$.\nThe constraint becomes:\n$$ 1 - \\frac{(1-x/2)\\exp(x)}{1+x/2} \\le \\varepsilon $$\n$$ \\frac{(1-x/2)\\exp(x)}{1+x/2} \\ge 1-\\varepsilon $$\nWith $\\varepsilon = 0.01$, we must solve for the largest $x$ satisfying:\n$$ (1-x/2)\\exp(x) - 0.99(1+x/2) = 0 $$\nSolving this transcendental equation numerically (e.g., using Newton's method or a numerical solver), we find the root to be $x_{\\text{crit}} \\approx 0.487803$.\nThe accuracy constraint is $|\\lambda|_{\\max}\\Delta t \\le x_{\\text{crit}}$, so the largest permissible time step is:\n$$ \\Delta t_{CN, \\max} = \\frac{x_{\\text{crit}}}{|\\lambda|_{\\max}} = \\frac{x_{\\text{crit}}}{\\frac{3 \\times 10^7}{625\\pi}} = x_{\\text{crit}} \\frac{625\\pi}{3 \\times 10^7} \\, \\text{s} $$\nThis can also be expressed in terms of the Euler time step:\n$$ \\Delta t_{CN, \\max} = \\frac{x_{\\text{crit}}}{2} \\Delta t_{FE, \\max} $$\nNumerically:\n$$ \\Delta t_{CN, \\max} \\approx \\frac{0.487803}{2} \\times (1.3089969 \\times 10^{-4}) \\approx 3.19267 \\times 10^{-5} \\, \\text{s} $$\nRounding to four significant figures, the largest time step for Crank–Nicolson that meets the accuracy requirement is $3.193 \\times 10^{-5} \\, \\text{s}$.\n\nSummary of results:\n1.  Largest stable $\\Delta t$ for explicit forward Euler: $1.309 \\times 10^{-4} \\, \\text{s}$.\n2.  Largest accuracy-constrained $\\Delta t$ for Crank–Nicolson: $3.193 \\times 10^{-5} \\, \\text{s}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1.309 \\times 10^{-4} & 3.193 \\times 10^{-5} \\end{pmatrix} } $$"
        },
        {
            "introduction": "The transient response measured in a TDEM survey is a complex signal that encodes information about the subsurface conductivity structure, which can be understood as a superposition of fundamental diffusion modes. In many geophysical settings, the measured signal can be well-approximated by a sparse sum of decaying exponentials, where the decay rates $\\lambda_k$ are directly related to the eigenvalues of the underlying Maxwell diffusion operator. This practice bridges the gap between electromagnetic theory and practical data interpretation by having you implement a modern estimation algorithm to transform a raw time-series into a set of physical parameters, providing a first step from forward modeling towards solving an inverse problem .",
            "id": "3610019",
            "problem": "Consider the interpretation of Time-Domain Electromagnetics (TDEM) responses via sparse sums of diffusion eigenmodes arising from Maxwell's equations in the quasi-static regime. Starting from the fundamental Maxwell equations, assume a conductive, non-magnetic Earth with constant magnetic permeability $\\mu$ and electrical conductivity $\\sigma$, and neglect the displacement current. In a source-free region, the electric field $\\mathbf{E}$ and magnetic flux density $\\mathbf{B}$ satisfy\n$ \\nabla \\times \\mathbf{E} = - \\dfrac{\\partial \\mathbf{B}}{\\partial t}, \\quad \\nabla \\times \\left( \\dfrac{1}{\\mu} \\mathbf{B} \\right) = \\sigma \\mathbf{E}.$\nIn the frequency domain with angular frequency $\\omega$, the relevant operator for the conductive curl-curl formulation acting on the electric field is\n$ \\mathcal{L} = \\nabla \\times \\mu^{-1} \\nabla \\times - i \\omega \\sigma.$\nFor TDEM, work in the time domain and consider a canonical one-dimensional configuration: a homogeneous slab of thickness $L$ along the $z$-axis, with perfectly electrically conducting (PEC) plates at $z = 0$ and $z = L$ imposing tangential electric field equal to zero at the boundaries. Assume a transverse electric (TE) polarization with $\\mathbf{E}$ aligned along the $x$-direction and spatial variation only in $z$ and $t$.\n\nTask A. Using only the above fundamental equations and boundary conditions, derive the governing diffusion-type initial-boundary-value problem for a single field component (choose a consistent component and formulation), and show that the TDEM impulse response measured at a fixed location can be represented as a sparse sum of exponentially decaying diffusion eigenmodes. Conclude that the measured time trace $y(t)$ can be written in the form\n$ y(t) = \\sum_{k=1}^{K} a_k e^{-\\lambda_k t},$\nwhere $K$ is small relative to the number of observable samples, the $\\{a_k\\}$ are real amplitudes, and the $\\{\\lambda_k\\}$ are real, positive decay rates determined by the geometry, material properties, and boundary conditions. Express all decay rates in $\\mathrm{s}^{-1}$.\n\nTask B. Implement a stable estimation procedure to recover the $\\{\\lambda_k\\}$ from noisy uniformly sampled data $\\{y(t_n)\\}_{n=0}^{N-1}$ generated synthetically from the canonical slab. Your estimator must be based on a principle equivalent to Prony’s method, such as the Matrix Pencil Method (MPM) using the Singular Value Decomposition (SVD), and it must explicitly use the fact that uniform sampling implies $y_n = \\sum_{k=1}^K A_k z_k^n$ with $z_k = e^{-\\lambda_k \\Delta t}$ for sample interval $\\Delta t$ and appropriately shifted amplitudes $\\{A_k\\}$.\n\nTask C. Use the canonical slab geometry to produce analytical decay rates $\\{\\lambda_k\\}$ that are implied by the Maxwell diffusion eigenproblem under the stated assumptions and boundary conditions. Then, for each of the test cases below, synthesize a noiseless signal $y_{\\text{noiseless}}(t_n)$ from the first $K$ specified diffusion eigenmodes with given modal amplitudes $\\{a_k\\}$, add zero-mean Gaussian noise with a specified relative standard deviation (defined as a fraction of $\\max_n |y_{\\text{noiseless}}(t_n)|$), and apply your estimator to obtain $\\{\\widehat{\\lambda}_k\\}$. For each test case, compute the maximum relative error across modes,\n$ \\varepsilon_{\\max} = \\max_k \\dfrac{|\\widehat{\\lambda}_k - \\lambda_k|}{\\lambda_k},$\nwhere the modes are paired by sorting both the true and estimated $\\lambda$ in ascending order. For each test case, return a boolean indicating whether $\\varepsilon_{\\max} \\le \\tau$, where $\\tau$ is a supplied tolerance.\n\nPhysical and numerical units and constants:\n- The slab thickness must be used in meters.\n- The time variable must be in seconds.\n- The magnetic permeability must be taken as the vacuum value $\\mu_0 = 4 \\pi \\times 10^{-7}\\,\\mathrm{H/m}$.\n- The electrical conductivity must be in $\\mathrm{S/m}$.\n- All decay rates $\\lambda_k$ must be reported and internally computed in $\\mathrm{s}^{-1}$.\n- Angles are not used in this problem.\n- Any percentages mentioned are to be treated as a pure decimals.\n\nTest suite specification:\nFor each case, the parameters are: $(L, \\sigma, \\{n_k\\}_{k=1}^K, \\{a_k\\}_{k=1}^K, N, t_0, \\Delta t, \\text{noise\\_rel\\_std}, \\tau)$, where $\\{n_k\\}$ are the positive integer mode indices associated with the canonical slab eigenmodes, $\\{a_k\\}$ are the corresponding modal amplitudes, $N$ is the number of uniform samples, $t_0$ is the initial time, $\\Delta t$ is the sampling interval, $\\text{noise\\_rel\\_std}$ is the relative standard deviation for additive Gaussian noise, and $\\tau$ is the pass/fail tolerance.\n\n- Case $1$ (happy path, three separated modes, low noise):\n  - $L = 100\\,\\mathrm{m}$, $\\sigma = 0.1\\,\\mathrm{S/m}$,\n  - $\\{n_k\\} = [1, 2, 3]$, $\\{a_k\\} = [1.0, 0.5, 0.3]$,\n  - $N = 120$, $t_0 = 1.0 \\times 10^{-5}\\,\\mathrm{s}$, $\\Delta t = 2.0 \\times 10^{-5}\\,\\mathrm{s}$,\n  - $\\text{noise\\_rel\\_std} = 1.0 \\times 10^{-4}$, $\\tau = 1.0 \\times 10^{-2}$.\n\n- Case $2$ (two nearby modes, moderate noise):\n  - $L = 500\\,\\mathrm{m}$, $\\sigma = 0.01\\,\\mathrm{S/m}$,\n  - $\\{n_k\\} = [5, 6]$, $\\{a_k\\} = [1.0, 0.8]$,\n  - $N = 180$, $t_0 = 2.0 \\times 10^{-5}\\,\\mathrm{s}$, $\\Delta t = 5.0 \\times 10^{-5}\\,\\mathrm{s}$,\n  - $\\text{noise\\_rel\\_std} = 2.0 \\times 10^{-4}$, $\\tau = 2.0 \\times 10^{-2}$.\n\n- Case $3$ (single mode, very low noise):\n  - $L = 50\\,\\mathrm{m}$, $\\sigma = 1.0\\,\\mathrm{S/m}$,\n  - $\\{n_k\\} = [1]$, $\\{a_k\\} = [2.0]$,\n  - $N = 200$, $t_0 = 5.0 \\times 10^{-5}\\,\\mathrm{s}$, $\\Delta t = 3.0 \\times 10^{-4}\\,\\mathrm{s}$,\n  - $\\text{noise\\_rel\\_std} = 1.0 \\times 10^{-5}$, $\\tau = 5.0 \\times 10^{-3}$.\n\n- Case $4$ (three modes, higher noise):\n  - $L = 100\\,\\mathrm{m}$, $\\sigma = 0.1\\,\\mathrm{S/m}$,\n  - $\\{n_k\\} = [1, 2, 3]$, $\\{a_k\\} = [1.0, 0.5, 0.3]$,\n  - $N = 120$, $t_0 = 1.0 \\times 10^{-5}\\,\\mathrm{s}$, $\\Delta t = 2.0 \\times 10^{-5}\\,\\mathrm{s}$,\n  - $\\text{noise\\_rel\\_std} = 5.0 \\times 10^{-4}$, $\\tau = 5.0 \\times 10^{-2}$.\n\nYour program must:\n- Compute the analytical decay rates $\\{\\lambda_k\\}$ implied by the canonical slab Maxwell diffusion eigenproblem for the specified $\\{n_k\\}$, $L$, $\\sigma$, and $\\mu_0$, and synthesize $y_{\\text{noiseless}}(t_n)$ using the given $\\{a_k\\}$ and uniform samples $t_n = t_0 + n \\Delta t$ for $n = 0, 1, \\dots, N-1$.\n- Add zero-mean Gaussian noise with standard deviation equal to $\\text{noise\\_rel\\_std} \\times \\max_n |y_{\\text{noiseless}}(t_n)|$.\n- Estimate $\\{\\widehat{\\lambda}_k\\}$ using a Matrix Pencil Method (or an equivalent Prony-class approach) from the noisy uniform samples.\n- For each test case, compute $\\varepsilon_{\\max}$ and return a boolean indicating whether $\\varepsilon_{\\max} \\le \\tau$.\n\nFinal output format:\nYour program should produce a single line of output containing the four boolean results for the four test cases as a comma-separated list enclosed in square brackets, for example, \"[True,False,True,True]\".",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of quasi-static electromagnetism, mathematically well-posed, and all parameters and conditions are specified unambiguously. The tasks involve a standard theoretical derivation, the implementation of a well-established numerical method, and a concrete set of test cases for validation.\n\n### Task A: Derivation of the Governing IBVP and Eigenmode Representation\n\nWe begin with the provided quasi-static Maxwell's equations in a source-free, homogeneous, conductive medium with constant permeability $\\mu$ and conductivity $\\sigma$:\n$$ \\nabla \\times \\mathbf{E} = - \\frac{\\partial \\mathbf{B}}{\\partial t} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{B} = \\mu \\sigma \\mathbf{E} \\quad (2) $$\nTo derive a single governing equation for the electric field $\\mathbf{E}$, we take the curl of Faraday's Law (1) and exchange the order of spatial and temporal derivatives:\n$$ \\nabla \\times (\\nabla \\times \\mathbf{E}) = - \\nabla \\times \\left( \\frac{\\partial \\mathbf{B}}{\\partial t} \\right) = - \\frac{\\partial}{\\partial t} (\\nabla \\times \\mathbf{B}) $$\nSubstituting Ampere's Law (2) into this expression yields the vector diffusion equation for $\\mathbf{E}$:\n$$ \\nabla \\times (\\nabla \\times \\mathbf{E}) = - \\frac{\\partial}{\\partial t} (\\mu \\sigma \\mathbf{E}) $$\nGiven that $\\mu$ and $\\sigma$ are constants, we have:\n$$ \\nabla \\times (\\nabla \\times \\mathbf{E}) = - \\mu \\sigma \\frac{\\partial \\mathbf{E}}{\\partial t} $$\nThe problem specifies a one-dimensional configuration with a Transverse Electric (TE) field $\\mathbf{E} = E_x(z, t) \\hat{\\mathbf{x}}$, which varies only in the $z$-direction and time $t$. We evaluate the curl operators for this specific field structure. The first curl is:\n$$ \\nabla \\times \\mathbf{E} = \\nabla \\times (E_x(z, t) \\hat{\\mathbf{x}}) = \\frac{\\partial E_x}{\\partial z} \\hat{\\mathbf{y}} $$\nThe second curl (the curl of the curl) is:\n$$ \\nabla \\times (\\nabla \\times \\mathbf{E}) = \\nabla \\times \\left( \\frac{\\partial E_x}{\\partial z} \\hat{\\mathbf{y}} \\right) = - \\frac{\\partial}{\\partial z} \\left( \\frac{\\partial E_x}{\\partial z} \\right) \\hat{\\mathbf{x}} = - \\frac{\\partial^2 E_x}{\\partial z^2} \\hat{\\mathbf{x}} $$\nSubstituting this result into the vector diffusion equation, we obtain a scalar diffusion equation for the component $E_x(z, t)$:\n$$ - \\frac{\\partial^2 E_x}{\\partial z^2} = - \\mu \\sigma \\frac{\\partial E_x}{\\partial t} $$\n$$ \\implies \\frac{\\partial E_x}{\\partial t} = \\frac{1}{\\mu \\sigma} \\frac{\\partial^2 E_x}{\\partial z^2} $$\nThis is the governing partial differential equation (PDE). The problem defines Perfectly Electrically Conducting (PEC) boundary conditions at $z=0$ and $z=L$, which require the tangential component of the electric field to be zero. This gives the boundary conditions (BCs):\n$$ E_x(0, t) = 0 \\quad \\text{and} \\quad E_x(L, t) = 0 $$\nThe solution to this initial-boundary-value problem (IBVP) can be found using the method of separation of variables. We assume a solution of the form $E_x(z, t) = Z(z)T(t)$. Substituting into the PDE gives:\n$$ \\frac{T'(t)}{T(t)} = \\frac{1}{\\mu \\sigma} \\frac{Z''(z)}{Z(z)} = -\\lambda $$\nwhere $-\\lambda$ is the separation constant. The choice of a negative constant ensures solutions decay in time, consistent with physical diffusion processes. This leads to two ordinary differential equations:\n1.  Temporal: $T'(t) + \\lambda T(t) = 0 \\implies T(t) = e^{-\\lambda t}$\n2.  Spatial: $Z''(z) + \\lambda \\mu \\sigma Z(z) = 0$ with $Z(0)=0$ and $Z(L)=0$.\n\nThe spatial equation is a Sturm-Liouville eigenvalue problem. Its general solution is $Z(z) = C_1 \\sin(\\sqrt{\\lambda \\mu \\sigma} z) + C_2 \\cos(\\sqrt{\\lambda \\mu \\sigma} z)$. Applying the BCs:\n- $Z(0)=0 \\implies C_2=0$.\n- $Z(L)=0 \\implies C_1 \\sin(\\sqrt{\\lambda \\mu \\sigma} L) = 0$.\nFor a non-trivial solution ($C_1 \\neq 0$), we must have $\\sqrt{\\lambda \\mu \\sigma} L = n \\pi$ for any positive integer $n=1, 2, 3, \\ldots$. This quantizes the separation constant $\\lambda$ into a discrete set of eigenvalues, which are the decay rates $\\{\\lambda_n\\}$:\n$$ \\lambda_n = \\frac{1}{\\mu \\sigma} \\left(\\frac{n \\pi}{L}\\right)^2 $$\nThe corresponding spatial eigenfunctions are $Z_n(z) = \\sin\\left(\\frac{n \\pi z}{L}\\right)$.\n\nThe general solution is a linear superposition of all eigenmodes:\n$$ E_x(z, t) = \\sum_{n=1}^{\\infty} c_n Z_n(z) T_n(t) = \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n \\pi z}{L}\\right) e^{-\\lambda_n t} $$\nThe coefficients $c_n$ depend on the initial field distribution at $t=0$. A time-domain measurement $y(t)$ at a fixed depth $z_0$ is then:\n$$ y(t) = E_x(z_0, t) = \\sum_{n=1}^{\\infty} \\left(c_n \\sin\\left(\\frac{n \\pi z_0}{L}\\right)\\right) e^{-\\lambda_n t} $$\nDefining the modal amplitudes as $a_n = c_n \\sin(n \\pi z_0 / L)$, the measured signal takes the form of a sum of decaying exponentials. In practice, due to the physics of excitation and measurement, only a small number $K$ of these modes have significant amplitudes, leading to the sparse representation:\n$$ y(t) = \\sum_{k=1}^{K} a_k e^{-\\lambda_k t} $$\nThis concludes the theoretical derivation. The decay rates $\\lambda_k$ are real, positive, and given in units of $\\mathrm{s}^{-1}$.\n\n### Task B & C: Analytical Decay Rates and Numerical Estimation\n\nFor Task C, we must first compute the analytical decay rates for the specified integer mode indices $\\{n_k\\}$. Using the derived formula and substituting the vacuum permeability $\\mu_0=4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$:\n$$ \\lambda_{n_k} = \\frac{n_k^2 \\pi^2}{\\mu_0 \\sigma L^2} $$\nThese are the ground-truth values against which our estimates will be compared.\n\nFor Task B, we implement an estimator for $\\{\\lambda_k\\}$ from noisy, uniformly sampled data. The Matrix Pencil Method (MPM) is a suitable Prony-like technique.\nThe sampled signal is given by $y_n = y(t_n)$ where $t_n = t_0 + n\\Delta t$.\n$$ y_n = \\sum_{k=1}^{K} a_k e^{-\\lambda_k (t_0 + n\\Delta t)} = \\sum_{k=1}^{K} (a_k e^{-\\lambda_k t_0}) (e^{-\\lambda_k \\Delta t})^n $$\nLetting $A_k = a_k e^{-\\lambda_k t_0}$ and the \"poles\" $z_k = e^{-\\lambda_k \\Delta t}$, the model for the discrete samples is:\n$$ y_n = \\sum_{k=1}^{K} A_k z_k^n $$\nThe MPM algorithm proceeds as follows:\n1.  **Form Hankel Matrices**: From the $N$ data samples $\\{y_0, y_1, \\ldots, y_{N-1}\\}$, two $(N-L_p) \\times L_p$ Hankel matrices, $Y_0$ and $Y_1$, are constructed, where $L_p$ is the pencil parameter (chosen as $N//2$ for good noise averaging, satisfying $K \\le L_p \\le N-L_p$). These matrices are defined as:\n    $$ (Y_0)_{ij} = y_{i+j} \\quad \\text{and} \\quad (Y_1)_{ij} = y_{i+j+1} $$\n    for $i=0, \\ldots, N-L_p-1$ and $j=0, \\ldots, L_p-1$.\n\n2.  **Solve the Generalized Eigenvalue Problem**: In the noiseless case, the poles $\\{z_k\\}$ are the generalized eigenvalues of the matrix pencil $(Y_1, Y_0)$, satisfying $\\det(Y_1 - z Y_0) = 0$. In the presence of noise, this problem is ill-conditioned. A robust solution is found by computing the eigenvalues of the matrix $Y_0^+ Y_1$, where $Y_0^+$ is the Moore-Penrose pseudoinverse of $Y_0$.\n\n3.  **SVD-based Regularization**: To compute a stable pseudoinverse for the noisy matrix $Y_0$, we use its Singular Value Decomposition (SVD): $Y_0 = U S V^H$. The number of significant signal modes $K$ is known. We truncate the SVD to rank $K$, retaining only the first $K$ singular values and corresponding singular vectors: $U_K$, $S_K$, and $V_K$. The truncated pseudoinverse is then $Y_0^+ = V_K S_K^{-1} U_K^H$.\n\n4.  **Estimate Poles**: The estimated poles $\\{\\hat{z}_k\\}$ are found by computing the eigenvalues of the $K \\times K$ matrix derived from the pencil:\n    $$ \\{\\hat{z}_k\\}_{k=1}^K = \\mathrm{eig}(Y_0^+ Y_1) $$\n    Due to noise, the computed eigenvalues will be complex.\n\n5.  **Recover Decay Rates**: The decay rates $\\{\\widehat{\\lambda}_k\\}$ are recovered from the poles. For a complex pole $\\hat{z} = re^{i\\theta}$, its logarithm is $\\ln(\\hat{z}) = \\ln(r) + i\\theta$. Since $\\ln(z_k) = -\\lambda_k \\Delta t$ and our $\\lambda_k$ are real, we are interested in the real part of the logarithm, which relates to the magnitude of the pole. Thus, a robust estimator for the decay rate is:\n    $$ \\widehat{\\lambda}_k = -\\frac{\\ln(|\\hat{z}_k|)}{\\Delta t} $$\nThis procedure yields the estimated decay rates. They are then sorted and compared to the sorted analytical decay rates to compute the maximum relative error $\\varepsilon_{\\max}$ for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import hankel, svd, eigvals\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases for TDEM parameter estimation.\n    \"\"\"\n    MU_0 = 4 * np.pi * 1e-7\n\n    def calculate_analytical_lambdas(n_modes, L, sigma):\n        \"\"\"\n        Calculates analytical decay rates for the 1D slab problem.\n        lambda_n = (n^2 * pi^2) / (mu_0 * sigma * L^2)\n        \"\"\"\n        n_modes = np.array(n_modes)\n        lambdas = (n_modes**2 * np.pi**2) / (MU_0 * sigma * L**2)\n        return lambdas\n\n    def synthesize_signal(lambdas, amplitudes, N, t0, dt):\n        \"\"\"\n        Synthesizes a noiseless TDEM signal as a sum of decaying exponentials.\n        \"\"\"\n        times = t0 + np.arange(N) * dt\n        y_noiseless = np.zeros(N)\n        for lambda_k, a_k in zip(lambdas, amplitudes):\n            y_noiseless += a_k * np.exp(-lambda_k * times)\n        return times, y_noiseless\n\n    def add_noise(y_noiseless, rel_std):\n        \"\"\"\n        Adds zero-mean Gaussian noise to a signal.\n        \"\"\"\n        if rel_std == 0.0:\n            return y_noiseless\n        \n        # Guard against zero signal\n        max_abs_val = np.max(np.abs(y_noiseless))\n        if max_abs_val == 0:\n            return y_noiseless\n\n        sigma_noise = rel_std * max_abs_val\n        noise = np.random.normal(0, sigma_noise, len(y_noiseless))\n        return y_noiseless + noise\n\n    def estimate_lambdas_mpm(y_noisy, K, dt):\n        \"\"\"\n        Estimates decay rates from a noisy signal using the Matrix Pencil Method.\n        \"\"\"\n        N = len(y_noisy)\n        # Pencil parameter, chosen to be large for noise averaging\n        pencil_dim = N // 2\n        \n        if K > pencil_dim:\n            raise ValueError(\"Number of modes K is too large for the chosen pencil dimension.\")\n\n        # Construct Hankel matrices Y0 and Y1\n        # Y0[i,j] = y[i+j]\n        # Y1[i,j] = y[i+j+1]\n        Y0 = hankel(y_noisy[0 : N - pencil_dim], y_noisy[N - pencil_dim - 1 : N - 1])\n        Y1 = hankel(y_noisy[1 : N - pencil_dim + 1], y_noisy[N - pencil_dim : N])\n\n        # SVD of Y0 for truncated pseudoinverse\n        U, s, Vh = svd(Y0, full_matrices=False)\n\n        # Truncate based on the known number of modes, K\n        Uk = U[:, :K]\n        sinv_k = np.diag(1.0 / s[:K])\n        Vh_k = Vh[:K, :]\n        Vk = Vh_k.conj().T\n\n        # Compute Y0^+ * Y1\n        # Y0_plus = Vk @ sinv_k @ Uk.conj().T\n        # C = Y0_plus @ Y1\n        # A more stable computation for the eigenvalues of Y0^+ * Y1\n        # is to compute eigenvalues of U_k.conj().T @ Y1 @ V_k @ S_k^-1\n        C_prime = Uk.conj().T @ Y1 @ Vk @ sinv_k\n        \n        # Eigenvalues are the estimated poles z_k\n        z_hat = eigvals(C_prime)\n        \n        # Recover decay rates from the magnitudes of the poles\n        # lambda_k = -ln(|z_k|) / dt\n        # Filter out potential spurious poles resulting in negative logs or warnings\n        valid_z_hat = z_hat[np.abs(z_hat) > 0]\n        lambda_hat = -np.log(np.abs(valid_z_hat)) / dt\n        \n        return lambda_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, three separated modes, low noise)\n        (100.0, 0.1, [1, 2, 3], [1.0, 0.5, 0.3], 120, 1.0e-5, 2.0e-5, 1.0e-4, 1.0e-2),\n        # Case 2 (two nearby modes, moderate noise)\n        (500.0, 0.01, [5, 6], [1.0, 0.8], 180, 2.0e-5, 5.0e-5, 2.0e-4, 2.0e-2),\n        # Case 3 (single mode, very low noise)\n        (50.0, 1.0, [1], [2.0], 200, 5.0e-5, 3.0e-4, 1.0e-5, 5.0e-3),\n        # Case 4 (three modes, higher noise)\n        (100.0, 0.1, [1, 2, 3], [1.0, 0.5, 0.3], 120, 1.0e-5, 2.0e-5, 5.0e-4, 5.0e-2),\n    ]\n\n    results = []\n    # Set a seed for reproducibility of random noise\n    np.random.seed(0)\n\n    for case in test_cases:\n        L, sigma, n_modes, amplitudes, N, t0, dt, noise_rel_std, tau = case\n        K = len(n_modes)\n\n        # 1. Compute analytical ground-truth decay rates\n        true_lambdas = calculate_analytical_lambdas(n_modes, L, sigma)\n\n        # 2. Synthesize the noiseless signal\n        _, y_noiseless = synthesize_signal(true_lambdas, amplitudes, N, t0, dt)\n\n        # 3. Add Gaussian noise\n        y_noisy = add_noise(y_noiseless, noise_rel_std)\n\n        # 4. Estimate decay rates using MPM\n        estimated_lambdas = estimate_lambdas_mpm(y_noisy, K, dt)\n\n        # 5. Compare results after sorting\n        true_lambdas_sorted = np.sort(true_lambdas)\n        # Ensure we only compare real parts and sort\n        estimated_lambdas_sorted = np.sort(np.real(estimated_lambdas))\n        \n        # Handle cases where MPM might return fewer modes than K due to filtering\n        if len(estimated_lambdas_sorted) != len(true_lambdas_sorted):\n            # If the number of modes is incorrect, the estimation failed.\n            max_rel_error = np.inf\n        else:\n            relative_errors = np.abs(estimated_lambdas_sorted - true_lambdas_sorted) / true_lambdas_sorted\n            max_rel_error = np.max(relative_errors)\n\n        results.append(max_rel_error = tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Modern geophysical inversion aims to find a subsurface model (e.g., conductivity $\\sigma$) that best explains observed data, which is often framed as a large-scale optimization problem requiring the efficient computation of the gradient of a data-misfit function. The adjoint-state method is a powerful technique that allows for the computation of this gradient at a cost independent of the number of model parameters, relying on solving a single \"adjoint\" PDE system that encapsulates the sensitivity of all measurements. This advanced exercise provides direct experience with the core engine of modern gradient-based inversion, helping you gain a deep understanding of the mathematical and computational foundation of techniques like full-waveform inversion .",
            "id": "3610028",
            "problem": "Consider a two-dimensional transverse electric (TE) reduction of frequency-domain Maxwell's equations appropriate for geophysical electromagnetics under the quasi-static assumption in which displacement currents are negligible. Let the out-of-plane electric field be $E_z(x,y)$ and assume isotropic magnetic permeability $\\mu(x,y)$ and electrical conductivity $\\sigma(x,y)$, with no magnetic sources. Starting from Faraday's law $\\nabla \\times \\mathbf{E} = -i \\omega \\mu \\mathbf{H}$ and Ampère's law $\\nabla \\times \\mathbf{H} = \\sigma \\mathbf{E} + \\mathbf{J}_s$ (neglecting the displacement current $\\omega \\epsilon \\mathbf{E}$), under TE conditions and constant $\\mu$ one can reduce the system to the scalar partial differential equation\n$$\n-\\nabla^2 E_z(x,y) + i \\,\\omega\\, \\mu\\, \\sigma(x,y)\\, E_z(x,y) = J_z(x,y),\n$$\nwhere $J_z$ is the out-of-plane impressed current source density, $\\omega$ is angular frequency in radians per second, $\\mu$ is magnetic permeability in henries per meter, and $\\sigma$ is conductivity in siemens per meter.\n\nDefine the discrete operator $A(\\sigma,\\omega) \\in \\mathbb{C}^{N \\times N}$ from a five-point second-order Finite Difference (FD) discretization of $-\\nabla^2$ on an interior grid with homogeneous Dirichlet boundary conditions $E_z=0$ on $\\partial \\Omega$, and add the reaction term $i \\omega \\mu \\sigma$ as a diagonal matrix. Let $u \\in \\mathbb{C}^{N}$ be the discrete solution of\n$$\nA(\\sigma,\\omega)\\, u = b,\n$$\nwith $b \\in \\mathbb{C}^{N}$ a discrete source representing $J_z$. Let $P \\in \\mathbb{R}^{M \\times N}$ be a linear projection that extracts the field at $M$ receiver indices, and define the real-valued data-misfit objective\n$$\n\\Phi(\\sigma) = \\tfrac{1}{2}\\, \\| P u - d \\|_2^2 = \\tfrac{1}{2} \\sum_{k=1}^{M} |(P u)_k - d_k|^2,\n$$\nwhere $d \\in \\mathbb{C}^M$ is observed data computed from a \"true\" conductivity field $\\sigma_{\\mathrm{true}}$.\n\nYour task is to implement a differentiable Maxwell solver for the TE equation that, for specified test cases, computes the solution $u$, evaluates the objective $\\Phi$, computes its gradient with respect to conductivity $\\nabla_\\sigma \\Phi$ using the adjoint-state method, verifies reciprocity by swapping source and receiver locations, and explores gradient pathologies as $\\omega \\to 0$.\n\nStarting from the fundamental Maxwell equations and their TE reduction, derive the adjoint-state system for a complex-valued linear operator, and implement the gradient computation without using any pre-derived shortcut formulas in the code. Specifically, use the governing linear system $A(\\sigma,\\omega) u = b$ as the base and the chain rule for differentiation, treating the real-valued objective and complex fields with appropriate conjugation to ensure correct adjointness. Reciprocity should be checked using the symmetry properties of the discrete operator under transposition for reciprocal media.\n\nPhysical units and numerical setup:\n- Angular frequency $\\omega$ must be in radians per second.\n- Magnetic permeability $\\mu$ must be in henries per meter.\n- Conductivity $\\sigma$ must be in siemens per meter.\n- Spatial lengths must be in meters.\n\nDiscretization and domain specification for the test suite:\n- Square domain of side length $L_x = L_y = 1\\,\\mathrm{m}$.\n- Interior FD grid with $N_x = N_y = 30$ points; homogeneous Dirichlet boundary conditions $E_z=0$.\n- Grid spacings $h_x = L_x/(N_x+1)$ and $h_y = L_y/(N_y+1)$.\n- Magnetic permeability $\\mu = \\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}$.\n- Base trial conductivity $\\sigma_0(x,y) = 0.1\\,\\mathrm{S/m}$ (uniform).\n- True conductivity $\\sigma_{\\mathrm{true}}(x,y)$ is $0.1\\,\\mathrm{S/m}$ plus an anomaly of $0.5\\,\\mathrm{S/m}$ inside a disk of radius $0.15\\,\\mathrm{m}$ centered at $(0.6\\,\\mathrm{m},\\,0.4\\,\\mathrm{m})$.\n- Single impressed current source $b$ is a point source of unit amplitude at the interior node closest to $(0.25\\,L_x,\\,0.75\\,L_y)$.\n- Receivers are three interior nodes closest to $(0.75\\,L_x,\\,0.25\\,L_y)$, $(0.5\\,L_x,\\,0.5\\,L_y)$, and $(0.25\\,L_x,\\,0.25\\,L_y)$.\n\nAdjoint gradient and checks:\n- For each frequency, construct $d$ by solving $A(\\sigma_{\\mathrm{true}},\\omega) u_{\\mathrm{true}} = b$ and setting $d = P u_{\\mathrm{true}}$.\n- Compute the adjoint-state vector by solving the conjugate-transpose system associated with the linearized objective.\n- Compute the gradient $\\nabla_\\sigma \\Phi$ and report its Euclidean norm $\\|\\nabla_\\sigma \\Phi\\|_2$.\n- Verify reciprocity by solving the forward problem with a source at the first receiver location and measuring the field at the original source location, and comparing it to the original forward solution measured at the first receiver location. Report a boolean indicating whether the relative difference is below a specified tolerance.\n\nDirectional finite-difference gradient check:\n- Generate a reproducible random direction $v \\in \\mathbb{R}^{N}$ with unit norm.\n- For a given small perturbation amplitude $\\varepsilon = 10^{-4}$ in siemens per meter, compute the centered finite-difference directional derivative $(\\Phi(\\sigma_0 + \\varepsilon v) - \\Phi(\\sigma_0 - \\varepsilon v))/(2\\varepsilon)$ and compare it against the inner product $\\nabla_\\sigma \\Phi(\\sigma_0) \\cdot v$. Report the relative error as a float.\n\nTest suite:\n- Test 1 (Reciprocity, happy path): $\\omega = 10\\,\\mathrm{rad/s}$, uniform $\\sigma = 0.1\\,\\mathrm{S/m}$; report a boolean for reciprocity using a relative tolerance of $10^{-8}$.\n- Test 2 (Adjoint gradient check, happy path): $\\omega = 10\\,\\mathrm{rad/s}$; report the relative error between adjoint directional derivative and finite-difference directional derivative as a float.\n- Test 3 (Adjoint gradient check, low frequency): $\\omega = 10^{-6}\\,\\mathrm{rad/s}$; report the relative error between adjoint and finite-difference directional derivatives as a float.\n- Test 4 (Gradient pathology magnitude, low frequency): $\\omega = 10^{-6}\\,\\mathrm{rad/s}$; report the Euclidean norm $\\|\\nabla_\\sigma \\Phi\\|_2$ as a float.\n- Test 5 (Gradient pathology at zero frequency): $\\omega = 0\\,\\mathrm{rad/s}$; report the Euclidean norm $\\|\\nabla_\\sigma \\Phi\\|_2$ as a float, which should be exactly zero.\n\nFinal output specification:\n- Your program should produce a single line of output containing the five results for the test suite as a comma-separated list enclosed in square brackets, in the order specified above. The types must be $[\\text{boolean}, \\text{float}, \\text{float}, \\text{float}, \\text{float}]$. For example: \"[True,1e-8,2.3e-6,0.12,0.0]\".",
            "solution": "The user has provided a valid, well-posed problem in computational geophysics. The task is to implement a differentiable solver for the 2D transverse electric (TE) Maxwell's equations under the quasi-static approximation, compute the gradient of a data-misfit objective function with respect to electrical conductivity using the adjoint-state method, and perform several numerical verifications.\n\n### 1. Governing Equation and Discretization\nThe governing partial differential equation (PDE) for the out-of-plane electric field $E_z(x,y)$ is given as:\n$$\n-\\nabla^2 E_z(x,y) + i \\omega \\mu \\sigma(x,y) E_z(x,y) = J_z(x,y)\n$$\nHere, $\\omega$ is the angular frequency, $\\mu$ is the magnetic permeability (assumed constant), $\\sigma(x,y)$ is the electrical conductivity, and $J_z(x,y)$ is the source current density. We discretize this equation on a 2D uniform grid with $N_x \\times N_y$ interior points subject to homogeneous Dirichlet boundary conditions. The total number of unknowns is $N = N_x N_y$. The spatial domain is $\\Omega = [0, L_x] \\times [0, L_y]$, with grid spacings $h_x = L_x/(N_x+1)$ and $h_y = L_y/(N_y+1)$. The field values at the interior grid nodes are represented by a vector $u \\in \\mathbb{C}^N$, where $u_k$ corresponds to $E_z$ at the $k$-th node.\n\nThe Laplacian operator $-\\nabla^2$ is approximated using a second-order five-point finite-difference stencil. This discretization results in a real, symmetric, positive-definite matrix $K \\in \\mathbb{R}^{N \\times N}$. The term $i \\omega \\mu \\sigma(x,y) E_z(x,y)$ is represented by a diagonal matrix $i \\omega \\mu \\Sigma$, where $\\Sigma = \\text{diag}(\\sigma_1, \\sigma_2, \\ldots, \\sigma_N)$ is a diagonal matrix containing the conductivity values at each grid node. The discrete source $J_z$ is represented by a vector $b \\in \\mathbb{C}^N$.\n\nThe resulting discretized system is a linear system of equations:\n$$\nA(\\sigma, \\omega) u = b\n$$\nwhere the system matrix $A(\\sigma, \\omega) \\in \\mathbb{C}^{N \\times N}$ is given by:\n$$\nA(\\sigma, \\omega) = K + i \\omega \\mu \\Sigma\n$$\nThis matrix is complex, sparse, and symmetric (since both $K$ and $\\Sigma$ are symmetric). For $\\omega > 0$ and $\\sigma > 0$, it is non-singular, guaranteeing a unique solution $u = A^{-1} b$.\n\n### 2. Objective Function and Gradient Calculation via Adjoint-State Method\nThe goal is to find the gradient of the real-valued data-misfit objective function $\\Phi(\\sigma)$ with respect to the conductivity vector $\\sigma \\in \\mathbb{R}^N$:\n$$\n\\Phi(\\sigma) = \\frac{1}{2} \\| P u - d \\|_2^2 = \\frac{1}{2} (P u - d)^H (P u - d)\n$$\nHere, $P \\in \\mathbb{R}^{M \\times N}$ is a projection matrix selecting the field values at $M$ receiver locations, and $d \\in \\mathbb{C}^M$ is the vector of observed data. The solution vector $u$ is implicitly a function of $\\sigma$, i.e., $u=u(\\sigma)$.\n\nWe use the adjoint-state method to compute the gradient $\\nabla_\\sigma \\Phi$. A small perturbation $\\delta \\sigma$ in conductivity leads to a perturbation $\\delta u$ in the field and $\\delta \\Phi$ in the objective. The first-order change in $\\Phi$ is given by its Gâteaux derivative:\n$$\n\\delta \\Phi = \\text{Re} \\left[ (P u - d)^H P \\delta u \\right]\n$$\nTo find the relationship between $\\delta u$ and $\\delta \\sigma$, we differentiate the state equation $A u = b$:\n$$\n\\delta(A u) = (\\delta A) u + A (\\delta u) = 0\n$$\nThis assumes the source $b$ is independent of $\\sigma$. This yields $\\delta u = -A^{-1} (\\delta A) u$. Substituting this into the expression for $\\delta \\Phi$:\n$$\n\\delta \\Phi = -\\text{Re} \\left[ (P u - d)^H P A^{-1} (\\delta A) u \\right]\n$$\nUsing the property that $(X Y)^H = Y^H X^H$, we can rewrite this as:\n$$\n\\delta \\Phi = -\\text{Re} \\left[ \\left( (A^H)^{-1} P^T (P u - d) \\right)^H (\\delta A) u \\right]\n$$\nWe define the adjoint-state vector $\\lambda \\in \\mathbb{C}^N$ as the solution to the adjoint equation:\n$$\nA^H \\lambda = P^T (P u - d)\n$$\nwhere $A^H = \\bar{A}^T$ is the Hermitian conjugate (or conjugate transpose) of $A$. With this definition, the change in the objective function simplifies to:\n$$\n\\delta \\Phi = -\\text{Re} \\left[ \\lambda^H (\\delta A) u \\right]\n$$\nThe perturbation in the operator $A$ due to a perturbation $\\delta \\sigma$ is $\\delta A = A(\\sigma+\\delta\\sigma) - A(\\sigma) = i \\omega \\mu \\, \\text{diag}(\\delta \\sigma)$. Substituting this expression:\n$$\n\\delta \\Phi = -\\text{Re} \\left[ \\lambda^H (i \\omega \\mu \\, \\text{diag}(\\delta \\sigma)) u \\right]\n$$\nThe term inside the real part is a scalar product which can be expanded as:\n$$\n\\lambda^H (i \\omega \\mu \\, \\text{diag}(\\delta \\sigma)) u = i \\omega \\mu \\sum_{j=1}^N \\bar{\\lambda}_j \\delta \\sigma_j u_j\n$$\nSince the perturbation $\\delta \\sigma_j$ is real, taking the real part of the expression using $\\text{Re}(i z) = -\\text{Im}(z)$ yields:\n$$\n\\delta \\Phi = -\\text{Re} \\left[ i \\omega \\mu \\sum_{j=1}^N \\bar{\\lambda}_j u_j \\delta \\sigma_j \\right] = \\omega \\mu \\sum_{j=1}^N \\text{Im}(\\bar{\\lambda}_j u_j) \\delta \\sigma_j\n$$\nBy definition, the total differential is $\\delta \\Phi = (\\nabla_\\sigma \\Phi)^T \\delta \\sigma = \\sum_{j=1}^N (\\nabla_\\sigma \\Phi)_j \\delta \\sigma_j$. By comparing the two expressions, we obtain the components of the gradient. Using the identity $\\text{Im}(\\bar{\\lambda} u) = -\\text{Im}(\\lambda \\bar{u})$, we can write the gradient in a common form:\n$$\n(\\nabla_\\sigma \\Phi)_j = \\omega \\mu \\, \\text{Im}(\\bar{\\lambda}_j u_j) = -\\omega \\mu \\, \\text{Im}(\\bar{u}_j \\lambda_j)\n$$\nThe computational procedure is thus:\n1. For a given model $\\sigma$, solve the forward problem $A(\\sigma) u = b$ for the field $u$.\n2. Compute the data residual $r = P u - d$.\n3. Compute the adjoint source $q = P^T r$.\n4. Solve the adjoint problem $A(\\sigma)^H \\lambda = q$ for the adjoint field $\\lambda$.\n5. Assemble the gradient vector using the component-wise formula $(\\nabla_\\sigma \\Phi)_j = -\\omega \\mu \\, \\text{Im}(\\bar{u}_j \\lambda_j)$.\n\n### 3. Reciprocity Verification\nFor a reciprocal medium, the system matrix $A$ is symmetric ($A=A^T$), which implies its inverse is also symmetric, $(A^{-1})=(A^{-1})^T$. Let the source be a unit impulse at node $s$, $b=e_s$, and the receiver be at node $r$. The measured field is $u_r = (A^{-1} e_s)_r = (A^{-1})_{rs}$. If we swap the source and receiver, the source is $b'=e_r$ and the field is measured at node $s$, giving $u'_s = (A^{-1} e_r)_s = (A^{-1})_{sr}$. Since $A^{-1}$ is symmetric, $(A^{-1})_{rs} = (A^{-1})_{sr}$, meaning $u_r = u'_s$. This property is verified numerically.\n\n### 4. Gradient Check via Finite Differences\nThe correctness of the adjoint-state gradient is verified by comparing its directional derivative with a finite-difference approximation. The directional derivative of $\\Phi$ at $\\sigma_0$ in a random direction $v$ is given by the inner product $D_v \\Phi = \\nabla_\\sigma \\Phi(\\sigma_0) \\cdot v$. A centered finite-difference approximation provides a benchmark:\n$$\nD_v \\Phi \\approx \\frac{\\Phi(\\sigma_0 + \\varepsilon v) - \\Phi(\\sigma_0 - \\varepsilon v)}{2\\varepsilon}\n$$\nfor a small perturbation $\\varepsilon$. The relative error between the adjoint-based and finite-difference derivatives validates the implementation.\n\n### 5. Low-Frequency Gradient Pathology\nThe derived gradient expression, $(\\nabla_\\sigma \\Phi)_j = -\\omega \\mu \\, \\text{Im}(\\bar{u}_j \\lambda_j)$, contains an explicit factor of the angular frequency $\\omega$. This implies that as $\\omega \\to 0$, the gradient magnitude approaches zero. In the DC limit ($\\omega=0$), the governing equation becomes $-\\nabla^2 E_z = J_z$, which is independent of conductivity $\\sigma$. Consequently, the solution $u$ is insensitive to changes in $\\sigma$. If the true data $d$ is also generated at $\\omega=0$, then $d$ is independent of $\\sigma_{\\mathrm{true}}$. This leads to $u(\\sigma_0)$ being identical to $u_{\\text{true}}$, a zero data residual, a zero objective function value, and a zero gradient. This pathological behavior, which represents a key challenge in geophysical electromagnetic inversion, is demonstrated by computing $\\|\\nabla_\\sigma \\Phi\\|_2$ for a very small $\\omega$ and for $\\omega=0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, eye, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem and generate results for all test cases.\n    It sets up the geophysical EM problem, computes solutions and gradients\n    using the adjoint-state method, and performs specified numerical checks.\n    \"\"\"\n    # ------------------\n    # 1. Setup and Discretization\n    # ------------------\n    # Physical and domain constants\n    Lx, Ly = 1.0, 1.0\n    Nx, Ny = 30, 30\n    mu0 = 4.0 * np.pi * 1e-7  # H/m\n    \n    # Grid parameters\n    hx, hy = Lx / (Nx + 1), Ly / (Ny + 1)\n    N = Nx * Ny\n    \n    # Create grid coordinates\n    x_coords = np.linspace(hx, Lx - hx, Nx)\n    y_coords = np.linspace(hy, Ly - hy, Ny)\n    xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n    grid_coords = np.vstack([xx.ravel(), yy.ravel()]).T\n\n    def get_closest_node_idx(pos):\n        \"\"\"Finds the 1D index of the grid node closest to a given (x,y) position.\"\"\"\n        return np.argmin(np.linalg.norm(grid_coords - np.array(pos), axis=1))\n\n    # Source and Receiver locations\n    source_pos = (0.25 * Lx, 0.75 * Ly)\n    receiver_pos = [(0.75 * Lx, 0.25 * Ly), (0.5 * Lx, 0.5 * Ly), (0.25 * Lx, 0.25 * Ly)]\n    \n    source_idx = get_closest_node_idx(source_pos)\n    receiver_indices = [get_closest_node_idx(p) for p in receiver_pos]\n    \n    # Source vector b\n    b = np.zeros(N, dtype=np.complex128)\n    b[source_idx] = 1.0\n\n    # Projection operator P\n    P = eye(N, format='csr')[receiver_indices]\n\n    # Conductivity models\n    sigma0_val = 0.1  # S/m\n    sigma_true_val = 0.1 # S/m\n    anomaly_val = 0.5 # S/m\n    anomaly_center = np.array([0.6, 0.4]) # m\n    anomaly_radius = 0.15 # m\n\n    sigma0 = np.full(N, sigma0_val)\n    \n    sigma_true = np.full(N, sigma_true_val)\n    dist_from_center = np.linalg.norm(grid_coords - anomaly_center, axis=1)\n    sigma_true[dist_from_center  anomaly_radius] += anomaly_val\n\n    # Construct the discrete Laplacian K = -nabla^2\n    Dxx_1d = diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csr') / hx**2\n    Dyy_1d = diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csr') / hy**2\n    K = kron(Dxx_1d, eye(Ny)) + kron(eye(Nx), Dyy_1d)\n\n    def get_system_matrix(sigma, omega, mu):\n        \"\"\"Constructs the complex system matrix A = K + i*omega*mu*Sigma.\"\"\"\n        Sigma = diags(sigma, 0, shape=(N, N), format='csr')\n        return K + 1j * omega * mu * Sigma\n\n    # ------------------\n    # 2. Test Case Execution\n    # ------------------\n    results = []\n    \n    # Test 1: Reciprocity\n    omega_test1 = 10.0  # rad/s\n    sigma_test1 = np.full(N, 0.1)\n    \n    A_recip = get_system_matrix(sigma_test1, omega_test1, mu0)\n    \n    b_orig = np.zeros(N, dtype=np.complex128)\n    b_orig[source_idx] = 1.0\n    u_orig = spsolve(A_recip, b_orig)\n    val_at_rec = u_orig[receiver_indices[0]]\n    \n    b_swap = np.zeros(N, dtype=np.complex128)\n    b_swap[receiver_indices[0]] = 1.0\n    u_swap = spsolve(A_recip, b_swap)\n    val_at_src = u_swap[source_idx]\n    \n    reciprocity_tol = 1e-8\n    reciprocity_error = np.abs(val_at_rec - val_at_src) / np.abs(val_at_rec)\n    results.append(reciprocity_error  reciprocity_tol)\n\n    def run_gradient_calculation(omega, sigma_model, sigma_true_model, src_vec):\n        \"\"\"Calculates forward/adjoint fields and the gradient.\"\"\"\n        # Generate true data d\n        A_true = get_system_matrix(sigma_true_model, omega, mu0)\n        u_true = spsolve(A_true, src_vec, use_umfpack=False) # Use SuperLU for stability\n        d = P @ u_true\n\n        # Forward solve for the model\n        A_model = get_system_matrix(sigma_model, omega, mu0)\n        u_model = spsolve(A_model, src_vec, use_umfpack=False)\n        \n        # Adjoint solve\n        residual = P @ u_model - d\n        adjoint_source = P.T @ residual\n        \n        AH = A_model.conj().T\n        lamb = spsolve(AH, adjoint_source, use_umfpack=False)\n        \n        # Gradient (with corrected sign)\n        grad = -omega * mu0 * np.imag(np.conj(u_model) * lamb)\n        \n        return grad, u_model, d\n\n    def check_gradient_fd(omega, grad_adj, d, sigma_model, src_vec):\n        \"\"\"Performs a finite-difference check on the gradient.\"\"\"\n        np.random.seed(0) # For reproducible random direction\n        v = np.random.randn(N)\n        v /= np.linalg.norm(v)\n        \n        eps = 1e-4  # S/m\n        \n        # Perturb sigma\n        sigma_plus = sigma_model + eps * v\n        sigma_minus = sigma_model - eps * v\n        \n        # Evaluate objective function Phi at perturbed sigmas\n        A_plus = get_system_matrix(sigma_plus, omega, mu0)\n        u_plus = spsolve(A_plus, src_vec, use_umfpack=False)\n        phi_plus = 0.5 * np.linalg.norm(P @ u_plus - d)**2\n        \n        A_minus = get_system_matrix(sigma_minus, omega, mu0)\n        u_minus = spsolve(A_minus, src_vec, use_umfpack=False)\n        phi_minus = 0.5 * np.linalg.norm(P @ u_minus - d)**2\n        \n        # Compare directional derivatives\n        grad_fd_dot_v = (phi_plus - phi_minus) / (2.0 * eps)\n        grad_adj_dot_v = grad_adj.dot(v)\n        \n        if np.abs(grad_fd_dot_v)  1e-15:\n            return 0.0 if np.abs(grad_adj_dot_v)  1e-15 else np.inf\n        \n        rel_error = np.abs(grad_fd_dot_v - grad_adj_dot_v) / np.abs(grad_fd_dot_v)\n        return rel_error\n\n    # Test 2: Adjoint gradient check (happy path)\n    omega_test2 = 10.0  # rad/s\n    grad_2, u_2, d_2 = run_gradient_calculation(omega_test2, sigma0, sigma_true, b)\n    rel_error_2 = check_gradient_fd(omega_test2, grad_2, d_2, sigma0, b)\n    results.append(rel_error_2)\n    \n    # Test 3: Adjoint gradient check (low frequency)\n    omega_test3 = 1e-6  # rad/s\n    grad_3, u_3, d_3 = run_gradient_calculation(omega_test3, sigma0, sigma_true, b)\n    rel_error_3 = check_gradient_fd(omega_test3, grad_3, d_3, sigma0, b)\n    results.append(rel_error_3)\n\n    # Test 4: Gradient pathology magnitude (low frequency)\n    # The gradient was computed in Test 3\n    grad_norm_4 = np.linalg.norm(grad_3)\n    results.append(grad_norm_4)\n    \n    # Test 5: Gradient pathology at zero frequency\n    omega_test5 = 0.0  # rad/s\n    grad_5, _, _ = run_gradient_calculation(omega_test5, sigma0, sigma_true, b)\n    grad_norm_5 = np.linalg.norm(grad_5)\n    results.append(grad_norm_5)\n\n    # ------------------\n    # 3. Final Output\n    # ------------------\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}