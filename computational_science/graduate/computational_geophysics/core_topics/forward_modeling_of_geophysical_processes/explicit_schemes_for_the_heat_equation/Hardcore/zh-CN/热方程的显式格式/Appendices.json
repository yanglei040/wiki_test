{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，验证数值代码的正确性是基础性的第一步。本练习将介绍“人造解方法”（Method of Manufactured Solutions），这是一种通过设计一个具有已知精确解的问题来严格测试代码实现的强大技术。您将实现一个二维热方程的显式格式，并使用该方法来数值化地测量其收敛率，以验证代码的精度是否与理论预期相符 。",
            "id": "3590474",
            "problem": "考虑在单位正方形区域 $\\,\\Omega = [0,1]\\times[0,1]\\,$ 上的二维热方程，其热扩散系数 $\\,\\kappa\\,$ 为常数，并有一个光滑的源项 $\\,s(\\mathbf{x},t)\\,$，\n$$\n\\frac{\\partial u}{\\partial t}(\\mathbf{x},t) \\;=\\; \\kappa \\,\\Delta u(\\mathbf{x},t) \\;+\\; s(\\mathbf{x},t), \\qquad \\mathbf{x}=(x,y)\\in\\Omega,\\; t\\in[0,T],\n$$\n方程满足齐次狄利克雷边界条件 $\\,u(\\mathbf{x},t)=0\\,$ (对于 $\\,\\mathbf{x}\\in\\partial\\Omega\\,$) 和指定的初始条件 $\\,u(\\mathbf{x},0)=u_0(\\mathbf{x})\\,$。使用人造解方法构造一个光滑的非平凡函数 $\\,u(\\mathbf{x},t)\\,$，并推导出相应的源项 $\\,s(\\mathbf{x},t)\\,$，使得所构造的 $\\,u(\\mathbf{x},t)\\,$ 精确满足该偏微分方程和边界条件。然后，为此问题设计并实现一个时间上采用显式前向欧拉、空间上采用中心差分的格式，推导并强制执行其稳定性约束，并数值验证其在时间和空间上的收敛率。\n\n你的人造解必须是\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y),\n$$\n在区域 $\\,\\Omega\\,$ 上，对于 $\\,t\\in[0,T]\\,$。从控制方程和选定的 $\\,u(x,y,t)\\,$ 出发，计算使 $\\,u\\,$ 满足该方程所需的源项 $\\,s(x,y,t)\\,$。使用由 $\\,u\\,$ 导出的齐次狄利克雷边界值和初始条件 $\\,u(x,y,0)\\,$。使用均匀的笛卡尔网格对 $\\,\\Omega\\,$ 进行离散化，在 $\\,x\\,$ 方向上有 $\\,N_x+1\\,$ 个点，在 $\\,y\\,$ 方向上有 $\\,N_y+1\\,$ 个点（包括边界），间距分别为 $\\,\\Delta x=1/N_x\\,$ 和 $\\,\\Delta y=1/N_y\\,$。令 $\\,u_{i,j}^n\\,$ 表示在网格索引 $\\,i,j\\,$ 和时间层 $\\,t^n\\,$ 上的数值近似解。\n\n你的显式格式必须根据以下公式更新内部网格点 $\\,i=1,\\dots,N_x-1\\,$ 和 $\\,j=1,\\dots,N_y-1\\,$：\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\n并在每个时间层将边界值设置为零。使用二维显式格式的 Courant-Friedrichs-Lewy (CFL) 稳定性约束，\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)},\n$$\n当 $\\,\\Delta x=\\Delta y\\,$ 时，该式简化为 $\\,\\Delta t \\le \\frac{\\Delta x^2}{4\\kappa}\\,$。\n\n将最终时间 $\\,T\\,$ 的离散 $\\,L^2\\,$ 误差定义为\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2},\n$$\n其中 $\\,N_t\\,$ 表示最终时间索引，使得 $\\,N_t\\,\\Delta t \\approx T\\,$。使用调整后的 $\\,\\Delta t\\,$，使得时间网格正好落在 $\\,T\\,$ 上，即 $\\,\\Delta t_{\\mathrm{eff}} = T/N_t\\,$，其中 $\\,N_t\\,$ 为整数且 $\\,\\Delta t_{\\mathrm{eff}} \\le \\Delta t\\,$。\n\n通过固定一个精细的空间网格，并为一系列通过逐次减半关联的时间步长 $\\,\\Delta t_k\\,$ 计算误差 $\\,E(\\Delta t_k)\\,$，来数值估计时间收敛率 $\\,p_t\\,$。从 $\\,\\log E\\,$ 对 $\\,\\log \\Delta t\\,$ 的斜率估计 $\\,p_t\\,$。类似地，通过固定一个稳定的时间步长（与CFL条件一致），并为一系列通过逐次减半关联的空间网格 $\\,\\Delta x_\\ell\\,$ 计算误差 $\\,E(\\Delta x_\\ell)\\,$，来估计空间收敛率 $\\,p_x\\,$，并从 $\\,\\log E\\,$ 对 $\\,\\log \\Delta x\\,$ 的斜率估计 $\\,p_x\\,$。\n\n测试套件：\n- 情况A（时间收敛率，理想情况）：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=64\\,$，$\\,T=0.1\\,$，以及 $\\,\\Delta t\\,$ 值 $\\,\\Delta t_0=0.8\\,\\Delta t_{\\mathrm{CFL}}\\,$、$\\,\\Delta t_1=\\Delta t_0/2\\,$、$\\,\\Delta t_2=\\Delta t_1/2\\,$，其中 $\\,\\Delta t_{\\mathrm{CFL}}=\\Delta x^2/(4\\kappa)\\,$。报告测得的 $\\,p_t\\,$。\n- 情况B（空间收敛率，理想情况）：$\\,\\kappa=0.1\\,$，$\\,T=0.1\\,$，网格 $\\,N_x=N_y\\in\\{20,40,80\\}\\,$，并且对于每个网格，取 $\\,\\Delta t=0.4\\,\\Delta t_{\\mathrm{CFL}}\\,$。报告测得的 $\\,p_x\\,$。\n- 情况C（稳定性边界处的时间收敛率，边缘情况）：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=50\\,$，$\\,T=0.05\\,$，以及 $\\,\\Delta t\\,$ 值 $\\,\\Delta t_0=\\Delta t_{\\mathrm{CFL}}\\,$、$\\,\\Delta t_1=\\Delta t_0/2\\,$、$\\,\\Delta t_2=\\Delta t_1/2\\,$。报告测得的 $\\,p_t\\,$。\n\n你的程序必须：\n- 根据人造解 $\\,u(x,y,t)\\,$ 和热方程计算 $\\,s(x,y,t)\\,$。\n- 实现带有齐次狄利克雷边界和CFL约束的显式格式。\n- 对每种情况，通过对数据对 $\\,(\\log \\Delta t_k, \\log E_k)\\,$ 或 $\\,(\\log \\Delta x_\\ell, \\log E_\\ell)\\,$ 进行线性回归来估计收敛率。\n- 生成单行输出，其中包含三个结果，四舍五入到三位小数，以逗号分隔的列表形式包含在方括号中，顺序为 $[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}]$。由于这些量是无量纲的，因此不需要物理单位。\n\n所有给定测试用例的最终输出必须是浮点数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。",
            "solution": "我们从具有恒定热扩散系数 $\\,\\kappa\\,$ 的二维控制热方程开始，\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\,\\Delta u \\;+\\; s,\n$$\n该方程定义在单位正方形区域 $\\,\\Omega=[0,1]\\times[0,1]\\,$ 上，具有齐次狄利克雷边界条件，即 $\\,u|_{\\partial\\Omega}=0\\,$，以及一个给定的初始条件。在人造解方法中，我们选择一个光滑函数 $\\,u(x,y,t)\\,$，并推导出源项 $\\,s(x,y,t)\\,$，使得所选的 $\\,u\\,$ 精确满足方程和边界条件。这使我们能够通过将数值解与精确的人造解进行比较，来评估数值方法的收敛性质。\n\n我们选择\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n这个函数满足齐次狄利克雷边界条件，因为在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 上 $\\,\\sin(2\\pi x)=0\\,$，同样在 $\\,y=0\\,$ 和 $\\,y=1\\,$ 上 $\\,\\sin(2\\pi y)=0\\,$，所以对于所有 $\\,t\\,$，在 $\\,\\partial\\Omega\\,$ 上 $\\,u=0\\,$。其初始条件是 $\\,u(x,y,0)=\\sin(2\\pi x)\\sin(2\\pi y)\\,$。\n\n为了计算源项 $\\,s\\,$，我们使用时间导数和拉普拉斯算子的定义：\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;=\\; u,\n$$\n以及\n$$\n\\Delta u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2}\n\\;=\\; -\\,(2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;-\\; (2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y)\n\\;=\\; -\\,8\\pi^2\\,u.\n$$\n代入热方程得到\n$$\nu_t \\;=\\; \\kappa\\,\\Delta u \\;+\\; s \\;\\;\\Rightarrow\\;\\; s \\;=\\; u_t \\;-\\; \\kappa\\,\\Delta u \\;=\\; u \\;-\\; \\kappa\\,(-8\\pi^2\\,u) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,u.\n$$\n因此，强迫项是\n$$\ns(x,y,t) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n\n我们用均匀的笛卡尔网格对空间域进行离散化：\n$$\nx_i \\;=\\; i\\,\\Delta x,\\quad i=0,\\dots,N_x,\\qquad \\Delta x \\;=\\; \\frac{1}{N_x},\n$$\n$$\ny_j \\;=\\; j\\,\\Delta y,\\quad j=0,\\dots,N_y,\\qquad \\Delta y \\;=\\; \\frac{1}{N_y}.\n$$\n令 $\\,u_{i,j}^n\\,$ 表示在时间层 $\\,t^n=n\\,\\Delta t\\,$ 时对 $\\,u(x_i,y_j,t^n)\\,$ 的数值近似。对于内部点 $\\,i=1,\\dots,N_x-1\\,$ 和 $\\,j=1,\\dots,N_y-1\\,$，时间上采用显式前向欧拉、空间上采用二阶中心差分的格式是\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\n对于所有的 $\\,n\\,$，边界值为 $\\,u_{0,j}^n=u_{N_x,j}^n=u_{i,0}^n=u_{i,N_y}^n=0\\,$。在对 $\\,u\\,$ 的适当光滑性假设下，该格式在时间上是一阶精确的，在空间上是二阶精确的。\n\n为保证稳定性，对于具有常数 $\\,\\kappa\\,$ 的二维显式扩散格式，Courant-Friedrichs-Lewy (CFL) 约束为\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)}.\n$$\n在 $\\,\\Delta x=\\Delta y\\,$ 的特殊情况下，这简化为\n$$\n\\Delta t \\;\\le\\; \\frac{\\Delta x^2}{4\\,\\kappa}.\n$$\n我们通过计算一个候选的 $\\,\\Delta t\\,$，然后用 $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$（其中 $\\,N_t=\\left\\lceil T/\\Delta t\\right\\rceil\\,$）进行调整来强制执行此约束，这样时间网格能正好落在 $\\,T\\,$ 上，同时保持稳定性。\n\n为了量化最终时间 $\\,T\\,$ 的数值误差，我们使用离散的 $\\,L^2\\,$ 范数，\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2}.\n$$\n观测到的时间收敛率 $\\,p_t\\,$ 是通过在固定的精细网格上，为一系列通过逐次减半关联的时间步长 $\\,\\Delta t_k\\,$ 计算误差 $\\,E_k=E(\\Delta t_k)\\,$，并对 $\\,\\log E_k\\,$ 与 $\\,\\log \\Delta t_k\\,$ 进行线性回归来估计的。类似地，观测到的空间收敛率 $\\,p_x\\,$ 是通过在固定的稳定时间步长下，为一系列通过逐次减半关联的网格间距 $\\,\\Delta x_\\ell\\,$ 计算误差 $\\,E_\\ell=E(\\Delta x_\\ell)\\,$，并对 $\\,\\log E_\\ell\\,$ 与 $\\,\\log \\Delta x_\\ell\\,$ 进行线性回归来估计的。由于该格式在时间上是一阶的，在空间上是二阶的，我们期望 $\\,p_t\\approx 1\\,$ 和 $\\,p_x\\approx 2\\,$。\n\n每个测试用例的算法步骤：\n1. 设置 $\\,\\kappa\\,$、$\\,T\\,$ 以及网格尺寸 $\\,N_x,N_y\\,$。\n2. 计算 $\\,\\Delta x=1/N_x\\,$ 和 $\\,\\Delta y=1/N_y\\,$；构建网格 $\\,x_i\\,$ 和 $\\,y_j\\,$ 以及人造初始条件 $\\,u(x,y,0)\\,$。\n3. 选择与 CFL 约束一致的候选 $\\,\\Delta t\\,$ 值。对于时间研究，使用通过减半关联的 $\\,\\Delta t\\,$ 序列。对于空间研究，根据 CFL 极限的固定分数调整每个网格的 $\\,\\Delta t\\,$，以保持稳定性和合理的效率。\n4. 对于每个 $\\,\\Delta t\\,$，设置 $\\,N_t=\\lceil T/\\Delta t\\rceil\\,$ 并使用 $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$ 以精确到达 $\\,T\\,$。推进显式格式 $\\,N_t\\,$ 步：\n   - 在每一步 $\\,n\\,$，根据人造解评估 $\\,s(x_i,y_j,t^n)\\,$，并使用显式公式更新内部点；强制边界值 $\\,u=0\\,$。\n5. 在最终时间 $\\,T\\,$，计算与精确解 $\\,u(x,y,T)\\,$ 的离散 $\\,L^2\\,$ 误差 $\\,E\\,$。\n6. 整理误差与 $\\,\\Delta t\\,$ 或 $\\,\\Delta x\\,$ 的关系，并通过对 $\\,(\\log \\Delta t,\\log E)\\,$ 或 $\\,(\\log \\Delta x,\\log E)\\,$ 进行线性回归来估计 $\\,p_t\\,$ 或 $\\,p_x\\,$。\n7. 报告测得的速率，四舍五入到三位小数。\n\n测试套件详情：\n- 情况A：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=64\\,$，$\\,T=0.1\\,$；时间步长序列 $\\,\\Delta t_0=0.8\\,\\Delta x^2/(4\\kappa)\\,$，$\\,\\Delta t_1=\\Delta t_0/2\\,$，$\\,\\Delta t_2=\\Delta t_1/2\\,$；估计 $\\,p_t\\,$。\n- 情况B：$\\,\\kappa=0.1\\,$，$\\,T=0.1\\,$；网格 $\\,N_x=N_y\\in\\{20,40,80\\}\\,$；对每个网格，设置 $\\,\\Delta t=0.4\\,\\Delta x^2/(4\\kappa)\\,$；估计 $\\,p_x\\,$。\n- 情况C：$\\,\\kappa=0.1\\,$，$\\,N_x=N_y=50\\,$，$\\,T=0.05\\,$；时间步长序列 $\\,\\Delta t_0=\\Delta x^2/(4\\kappa)\\,$，$\\,\\Delta t_1=\\Delta t_0/2\\,$，$\\,\\Delta t_2=\\Delta t_1/2\\,$；估计 $\\,p_t\\,$。\n\n最终的程序输出必须是单行，包含 $\\,\\left[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}\\right]\\,$，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到三位小数。由于测量的速率是无量纲的，因此不需要物理单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_u(x, y, t):\n    \"\"\"Exact manufactured solution u(x,y,t) = exp(t) * sin(2πx) * sin(2πy).\"\"\"\n    return np.exp(t) * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y)\n\ndef source_s(x, y, t, kappa):\n    \"\"\"Source term s = (1 + 8π^2 κ) * u(x,y,t).\"\"\"\n    return (1.0 + 8.0 * (np.pi ** 2) * kappa) * manufactured_u(x, y, t)\n\ndef explicit_heat_2d(kappa, Nx, Ny, T, dt_candidate):\n    \"\"\"\n    Solve the forced heat equation using an explicit scheme on [0,1]x[0,1] with Dirichlet 0 BCs.\n    Uses dt_eff = T / Nt with Nt = ceil(T / dt_candidate) to land exactly at T.\n    Returns the discrete L2 error at time T with respect to the manufactured solution.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # CFL time step limit for explicit scheme in 2D with dx=1/Nx, dy=1/Ny:\n    dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n    # Ensure candidate dt is not larger than CFL limit\n    dt = min(dt_candidate, dt_cfl)\n    Nt = int(np.ceil(T / dt))\n    dt_eff = T / Nt  # adjust to land exactly at T, maintains stability since dt_eff = dt\n\n    # Grids\n    x = np.linspace(0.0, Lx, Nx + 1)\n    y = np.linspace(0.0, Ly, Ny + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition from manufactured solution at t=0\n    u = manufactured_u(X, Y, 0.0)\n\n    # Enforce boundary conditions (Dirichlet zero) explicitly: they are already zero by construction,\n    # but we maintain the boundary to zero at each time step.\n    u[0, :] = 0.0\n    u[-1, :] = 0.0\n    u[:, 0] = 0.0\n    u[:, -1] = 0.0\n\n    # Time stepping\n    t = 0.0\n    inv_dx2 = 1.0 / dx**2\n    inv_dy2 = 1.0 / dy**2\n    for n in range(Nt):\n        # Source term evaluated at current time\n        s = source_s(X, Y, t, kappa)\n\n        # Compute Laplacian with centered differences on interior points\n        # Vectorized update for interior\n        u_center = u[1:-1, 1:-1]\n        lap = (u[2:, 1:-1] - 2.0 * u_center + u[:-2, 1:-1]) * inv_dx2 \\\n            + (u[1:-1, 2:] - 2.0 * u_center + u[1:-1, :-2]) * inv_dy2\n\n        # Update interior\n        u[1:-1, 1:-1] = u_center + dt_eff * (kappa * lap + s[1:-1, 1:-1])\n\n        # Enforce boundary zeros each step\n        u[0, :] = 0.0\n        u[-1, :] = 0.0\n        u[:, 0] = 0.0\n        u[:, -1] = 0.0\n\n        t += dt_eff\n\n    # Exact solution at final time\n    u_exact_T = manufactured_u(X, Y, T)\n\n    # Discrete L2 error over the whole grid\n    err = u - u_exact_T\n    E = np.sqrt(np.sum(err**2) * dx * dy)\n    return E, dx, dy, dt_eff\n\ndef estimate_rate(xs, Es):\n    \"\"\"\n    Estimate convergence rate by linear regression of log(Es) vs log(xs).\n    xs: array of step sizes (Δt or Δx)\n    Es: corresponding errors\n    Returns slope (rate)\n    \"\"\"\n    logx = np.log(xs)\n    logE = np.log(Es)\n    # Fit logE = a + p * logx; p is slope (rate)\n    p, a = np.polyfit(logx, logE, 1)\n    return p\n\ndef case_temporal_convergence(kappa, Nx, Ny, T, dt0, num_levels=3):\n    \"\"\"\n    Measure temporal convergence rate by halving dt on a fixed grid.\n    \"\"\"\n    dts = [dt0 / (2**i) for i in range(num_levels)]\n    errors = []\n    dts_eff_list = []\n    for dt in dts:\n        E, _, _, dt_eff = explicit_heat_2d(kappa, Nx, Ny, T, dt)\n        errors.append(E)\n        dts_eff_list.append(dt_eff)\n    \n    rate = estimate_rate(np.array(dts_eff_list), np.array(errors))\n    return rate\n\ndef case_spatial_convergence(kappa, Ns, T, dt_fraction=0.4):\n    \"\"\"\n    Measure spatial convergence rate by halving Δx with dt set as a fixed fraction of the CFL limit.\n    Ns: list of N values for Nx=Ny.\n    \"\"\"\n    dxs = []\n    errors = []\n    for N in Ns:\n        # For each N, set dt = dt_fraction * dt_cfl\n        dx = 1.0 / N\n        dy = dx\n        dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n        dt = dt_fraction * dt_cfl\n        E, _, _, _ = explicit_heat_2d(kappa, N, N, T, dt)\n        dxs.append(dx)\n        errors.append(E)\n    rate = estimate_rate(np.array(dxs), np.array(errors))\n    return rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: Temporal convergence, happy path\n    kappa_A = 0.1\n    Nx_A = Ny_A = 64\n    T_A = 0.1\n    dx_A = 1.0 / Nx_A\n    dt_cfl_A = dx_A**2 / (4.0 * kappa_A)  # for dx=dy\n    dt0_A = 0.8 * dt_cfl_A\n    p_t_A = case_temporal_convergence(kappa_A, Nx_A, Ny_A, T_A, dt0_A, num_levels=3)\n\n    # Case B: Spatial convergence, happy path\n    kappa_B = 0.1\n    T_B = 0.1\n    Ns_B = [20, 40, 80]\n    p_x_B = case_spatial_convergence(kappa_B, Ns_B, T_B, dt_fraction=0.4)\n\n    # Case C: Temporal convergence at the stability boundary, edge case\n    kappa_C = 0.1\n    Nx_C = Ny_C = 50\n    T_C = 0.05\n    dx_C = 1.0 / Nx_C\n    dt_cfl_C = dx_C**2 / (4.0 * kappa_C)\n    dt0_C = dt_cfl_C\n    p_t_C = case_temporal_convergence(kappa_C, Nx_C, Ny_C, T_C, dt0_C, num_levels=3)\n\n    results = [p_t_A, p_x_B, p_t_C]\n\n    # Final print statement in the exact required format (rounded to three decimals).\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有限差分格式并不能完美求解目标偏微分方程，而是求解一个包含由离散化产生的非物理项的“修正方程”。本分析练习将指导您通过修正方程分析，揭示显式 FTCS 格式中隐藏的这些项。通过推导主导误差项，您将更深入地理解数值伪影，例如人工扩散及其对所选网格间距和时间步长的依赖性 。",
            "id": "3590501",
            "problem": "考虑一个均匀地球物理介质中的一维瞬态热传导，其由热方程 $u_{t} = \\kappa u_{xx}$ 建模，其中 $u(x,t)$ 是温度，$\\kappa$ 是恒定的热扩散率。使用间距为 $\\Delta x$ 的均匀空间网格和步长为 $\\Delta t$ 的均匀时间步长，通过显式时间前向中心空间 (FTCS) 格式来近似求解\n$$\nu^{n+1}_{i} = u^{n}_{i} + r \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right),\n$$\n其中 $r = \\kappa \\Delta t / \\Delta x^{2}$。从该偏微分方程和离散格式的定义出发，通过围绕连续解进行系统性的泰勒级数展开，进行修正方程分析。推导出该格式所求解的修正微分方程，并确定其引入的领头人为高阶空间项。然后，给出修正方程中乘以领头人为四阶空间导数项 $u_{xxxx}$ 的系数的解析表达式，并用 $\\kappa$、$\\Delta x$ 和 $\\Delta t$ 进行简化。请统一使用国际单位制 (SI)；如果进行数值计算，该系数的单位将是 $\\mathrm{m}^{4}\\,\\mathrm{s}^{-1}$，但最终的方框表达式中不应包含单位。最后，简要解释在岩石圈热模拟等计算地球物理学应用中，该系数的符号和大小如何影响有效物理扩散和数值解的光滑性。最终答案必须是 $u_{xxxx}$ 系数的一个闭式解析表达式。",
            "solution": "本题要求对一维热方程的显式时间前向中心空间 (FTCS) 格式进行修正方程分析，推导领头人为空间导数项的系数，并解释其影响。\n\n控制偏微分方程 (PDE) 为热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中 $u(x,t)$ 为温度，$t$ 为时间，$x$ 为空间坐标，$\\kappa$ 为恒定的热扩散率。\n\nFTCS 数值格式由下式给出：\n$$\nu^{n+1}_{i} = u^{n}_{i} + r \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right)\n$$\n其中 $u^n_i$ 表示在网格点 $x_i = i\\Delta x$ 和时间 $t_n = n\\Delta t$ 处 $u(x_i, t_n)$ 的数值近似。参数 $r$ 定义为 $r = \\kappa \\Delta t / \\Delta x^{2}$。\n\n为进行修正方程分析，我们将数值格式中每一项在点 $(x_i, t_n)$ 附近的泰勒级数展开代入。我们假设数值解 $u^n_i$ 是一个足够光滑的函数，可以由这些展开式表示。让我们将该格式两边同除以 $\\Delta t$ 进行改写：\n$$\n\\frac{u^{n+1}_{i} - u^{n}_{i}}{\\Delta t} = \\frac{\\kappa \\Delta t}{\\Delta x^{2}} \\frac{1}{\\Delta t} \\left(u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}\\right) = \\kappa \\frac{u^{n}_{i+1} - 2 u^{n}_{i} + u^{n}_{i-1}}{\\Delta x^{2}}\n$$\n\n左侧 (LHS) 是时间导数的近似。其在 $(x_i, t_n)$ 附近关于时间的泰勒级数展开为：\n$$\n\\text{LHS} = \\frac{u(x_i, t_n + \\Delta t) - u(x_i, t_n)}{\\Delta t} = \\frac{\\left(u + \\Delta t u_t + \\frac{\\Delta t^2}{2} u_{tt} + \\frac{\\Delta t^3}{6} u_{ttt} + \\dots\\right) - u}{\\Delta t}\n$$\n$$\n\\text{LHS} = u_t + \\frac{\\Delta t}{2} u_{tt} + \\frac{\\Delta t^2}{6} u_{ttt} + O(\\Delta t^3)\n$$\n其中所有偏导数均在 $(x_i, t_n)$ 处求值。\n\n右侧 (RHS) 是空间二阶导数的近似。其在 $(x_i, t_n)$ 附近关于空间的泰勒级数展开源于：\n$$\nu^{n}_{i \\pm 1} = u(x_i \\pm \\Delta x, t_n) = u \\pm \\Delta x u_x + \\frac{\\Delta x^2}{2} u_{xx} \\pm \\frac{\\Delta x^3}{6} u_{xxx} + \\frac{\\Delta x^4}{24} u_{xxxx} \\pm \\dots\n$$\n将这些组合起来形成中心差分算子：\n$$\nu^{n}_{i+1} - 2u^{n}_{i} + u^{n}_{i-1} = (\\Delta x^2 u_{xx} + \\frac{\\Delta x^4}{12} u_{xxxx} + \\frac{\\Delta x^6}{360} u_{xxxxxx} + \\dots)\n$$\n因此，该格式的右侧为：\n$$\n\\text{RHS} = \\kappa \\frac{\\Delta x^2 u_{xx} + \\frac{\\Delta x^4}{12} u_{xxxx} + \\dots}{\\Delta x^2} = \\kappa \\left( u_{xx} + \\frac{\\Delta x^2}{12} u_{xxxx} + O(\\Delta x^4) \\right)\n$$\n\n数值格式强制要求 LHS $=$ RHS。因此，数值解实际满足的微分方程是：\n$$\nu_t + \\frac{\\Delta t}{2} u_{tt} + \\frac{\\Delta t^2}{6} u_{ttt} + \\dots = \\kappa u_{xx} + \\frac{\\kappa \\Delta x^2}{12} u_{xxxx} + \\frac{\\kappa \\Delta x^4}{360} u_{xxxxxx} + \\dots\n$$\n为了得到标准形式的修正方程，我们将所有高阶时间导数用空间导数表示。为此，我们从其最低阶近似（即原始偏微分方程 $u_t = \\kappa u_{xx}$）开始，重复使用该方程本身。将其对时间求导，得到：\n$$\nu_{tt} = \\frac{\\partial}{\\partial t} (\\kappa u_{xx}) = \\kappa \\frac{\\partial^2}{\\partial x^2} (u_t)\n$$\n现在，将 $u_t = \\kappa u_{xx}$ 代入该表达式，得到：\n$$\nu_{tt} = \\kappa \\frac{\\partial^2}{\\partial x^2} (\\kappa u_{xx}) = \\kappa^2 u_{xxxx}\n$$\n我们只需要到这个阶数来找到领头的人为项。将其代入展开后的方程：\n$$\nu_t + \\frac{\\Delta t}{2} (\\kappa^2 u_{xxxx}) + O(\\Delta t^2) = \\kappa u_{xx} + \\frac{\\kappa \\Delta x^2}{12} u_{xxxx} + O(\\Delta x^4)\n$$\n整理各项以分离出 $u_t$，得到修正微分方程：\n$$\nu_t = \\kappa u_{xx} + \\left( \\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2} \\right) u_{xxxx} + \\text{h.o.t.}\n$$\n其中“h.o.t.”代表涉及 $\\Delta t^2$、$\\Delta x^4$ 及其乘积的高阶项。\n\n领头的人为高阶空间项是包含四阶空间导数 $u_{xxxx}$ 的那一项。乘以该项的系数的解析表达式为：\n$$\n\\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2}\n$$\n\n最后，我们提供所要求的解释。修正方程表明，FTCS 格式求解的是一个与原始热方程不同的偏微分方程。项 $C u_{xxxx}$，其中 $C = \\frac{\\kappa \\Delta x^2}{12} - \\frac{\\kappa^2 \\Delta t}{2}$，代表了一个人为的物理过程。系数 $C$ 的符号和大小显著影响数值解的行为。FTCS 格式的冯·诺依曼稳定性条件是 $r = \\kappa \\Delta t / \\Delta x^2 \\le 1/2$。\n- 如果 $C  0$（当 $r > 1/6$ 时发生），项 $C u_{xxxx}$ 起到人为数值扩散或超耗散的作用。该项增强了格式的耗散性质，特别是对短波特征。在岩石圈热模拟等计算地球物理学应用中，这会导致温度场过度平滑，人为地增厚热边界层并抹平尖锐梯度。\n- 如果 $C > 0$（当 $r  1/6$ 时发生），项 $C u_{xxxx}$ 是反耗散的。它抵消了物理扩散，并可能导致高波数模式的有效扩散率为负。这表现为数值解中出现虚假的高频振荡（数值频散），降低了其光滑性，并可能导致非物理行为，例如在尖锐界面或源附近出现超出预期物理范围的温度。\n$C$ 的大小决定了这些人为效应的严重程度，这些效应可以通过加密网格（减小 $\\Delta x$ 和 $\\Delta t$）来减弱。在 $r=1/6$ 时发生的特殊情况 $C=0$ 完全消除了这个领头误差项，从而得到一个更精确的格式。",
            "answer": "$$\n\\boxed{\\frac{\\kappa \\Delta x^{2}}{12} - \\frac{\\kappa^{2} \\Delta t}{2}}\n$$"
        },
        {
            "introduction": "地球物理现象很少只涉及单一的物理过程，而通常是多个过程（如平流和扩散）的组合。本练习演示了如何使用算子分裂法（一種組合單個求解器的技術）來處理這類多物理場問題。您將通過分裂問題來建立一個平流-擴散模型，并研究不同分裂策略的穩定性和準確性 。",
            "id": "3590410",
            "problem": "考虑具有常系数的一维平流-扩散形式的热方程，\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n该方程定义在长度为 $L$ 的周期性域上，具有均匀网格间距 $\\Delta x$ 和时间步长 $\\Delta t$。其中，$T(x,t)$ 是温度，$u$ 是均匀的固体速度（热的固态平流），$\\kappa$ 是热扩散率。此设定是俯冲带中沿板片热演化的简化替代模型，捕捉了固态平流与热扩散之间的相互作用。\n\n您必须设计一个显式算子分裂时间积分器，其结合了：\n- 用于平流子步骤的显式一阶迎风格式，以及\n- 用于扩散子步骤的显式前向欧拉中心差分格式，\n\n并采用周期性边界条件。实现两种分裂变体：\n- Lie 分裂：在每个完整时间步长内，先对 $\\Delta t$ 进行平流计算，然后对 $\\Delta t$ 进行扩散计算，\n- Strang 分裂：在每个完整时间步长内，先对 $\\Delta t/2$ 进行平流计算，然后对 $\\Delta t$ 进行扩散计算，最后再对 $\\Delta t/2$ 进行平流计算。\n\n从第一性原理出发，推导此显式组合的组合 Courant–Friedrichs–Lewy (CFL) 稳定性约束。通过将数值解与周期性域上常系数平流-扩散方程的精确解（通过离散傅里叶变换求得）进行比较，来量化分裂误差。对于一个有 $N$ 个点、网格间距为 $\\Delta x = L/N$、离散波数为 $k_n = 2\\pi n/L$（其中 $n \\in \\{0,1,\\dots,N-1\\}$ 映射到有符号频率）的网格，以及初始条件 $\\widehat{T}(k_n,0)$，其精确谱解由下式给出\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\n而物理空间解通过逆变换得到。使用此精确解计算相对 $\\ell^2$ 误差。\n\n采用以下初始条件\n$$\nT(x,0) = \\cos\\!\\Big(\\frac{2\\pi x}{L}\\Big) + \\frac{1}{2}\\cos\\!\\Big(\\frac{4\\pi x}{L} + \\phi\\Big),\n$$\n其中相位 $\\phi = 0.3$ 弧度。角度必须以弧度为单位。\n\n定义无量纲参数\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x}, \\qquad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\n您的程序必须：\n1. 使用显式一阶迎风平流子步骤和显式前向欧拉扩散子步骤，实现具有周期性边界的 Lie 和 Strang 分裂积分器。\n2. 使用上述谱公式计算指定最终时间 $t_{\\mathrm{end}}$ 处的精确参考解。\n3. 计算相对 $\\ell^2$ 误差\n$$\nE = \\frac{\\|T_{\\mathrm{num}}(\\cdot,t_{\\mathrm{end}}) - T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}{\\|T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}.\n$$\n4. 通过比较同一 $t_{\\mathrm{end}}$ 下 $\\Delta t$ 和 $\\Delta t/2$ 的误差，估算每种分裂方法在时间上的观测精度阶数：\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n$$\n5. 根据您推导的约束条件，计算组合的稳定性限制时间步长 $\\Delta t_{\\max}$。所有时间量均以秒为单位表示。\n\n使用以下参数集测试套件。所有长度单位必须是米，时间单位是秒，速度单位是米/秒，扩散率单位是平方米/秒，相位 $\\phi$ 单位是弧度。\n\n- 测试用例 A（扩散限制约束下的收敛指数）：\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$。\n  - 令 $\\Delta t_{\\max}$ 为您推导的组合稳定性限制时间步长。\n  - 设置 $\\Delta t = 0.4\\,\\Delta t_{\\max}$，$\\Delta t/2$ 为细化步长，以及 $t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 按上文定义计算 $p_{\\mathrm{Lie}}$ 和 $p_{\\mathrm{Strang}}$。\n\n- 测试用例 B（平流限制约束下的近边界稳定性指标）：\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$。\n  - 根据组合约束计算 $\\Delta t_{\\max}$（以秒为单位）。\n  - 使用 $\\Delta t = 0.99\\,\\Delta t_{\\max}$ 并计算 $r$ 和 $\\mu$。\n  - 报告 $\\Delta t_{\\max}$（以秒为单位）、$r$、$\\mu$ 以及一个布尔值 $S$，$S$ 为真的条件是当且仅当 $r \\le 1$ 且 $\\mu \\le 1/2$。\n\n- 测试用例 C（中等步长下的分裂误差比）：\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$。\n  - 计算 $\\Delta t_{\\max}$；使用 $\\Delta t = 0.2\\,\\Delta t_{\\max}$ 和 $t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 在相同的 $\\Delta t$ 下计算比率 $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含以下条目：\n  - 测试用例 A 的 $p_{\\mathrm{Lie}}$，\n  - 测试用例 A 的 $p_{\\mathrm{Strang}}$，\n  - 测试用例 B 的 $\\Delta t_{\\max}$（以秒为单位），\n  - 测试用例 B 的 $r$，\n  - 测试用例 B 的 $\\mu$，\n  - 测试用例 B 的 $S$（一个布尔值），\n  - 测试用例 C 的 $R$。\n例如：“[pLieA,pStrangA,dtmaxB,rB,muB,SB,Rc]”。",
            "solution": "我们从具有常系数的一维平流-扩散热方程开始，\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n该方程定义在长度为 $L$ 的周期性域上。算子分裂方法使用分解为平流算子 $A$ 和扩散算子 $D$ 的方法，\n$$\nA[T] = -u \\frac{\\partial T}{\\partial x}, \\qquad D[T] = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\n因此完整的生成算子为 $L = A + D$。\n\n稳定性约束是通过对离散子步骤应用 Von Neumann 分析得出的。对于平流子步骤，我们选择显式一阶迎风格式。在间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上，当 $u \\ge 0$ 时，更新公式为\n$$\nT_i^{n+1} = T_i^n - r\\,(T_i^n - T_{i-1}^n), \\quad r = \\frac{u\\,\\Delta t}{\\Delta x},\n$$\n其中索引是周期性的。对于傅里叶模式 $e^{\\mathrm{i} k i \\Delta x}$，其放大因子为\n$$\ng_A(k) = 1 - r\\,(1 - e^{-\\mathrm{i} k \\Delta x}).\n$$\n迎风格式的一个标准结果是，稳定性要求\n$$\n|g_A(k)| \\le 1 \\quad \\text{对所有 } k \\quad \\Longleftrightarrow \\quad 0 \\le r \\le 1,\n$$\n根据对称性，对于 $u \\le 0$，要求 $0 \\le |r| \\le 1$。因此，平流的 CFL 约束为\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x} \\le 1 \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x}{|u|}.\n$$\n\n对于扩散子步骤，我们使用显式前向欧拉中心差分格式，\n$$\nT_i^{n+1} = T_i^n + \\mu\\,\\big(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\big), \\quad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n其傅里叶放大因子为\n$$\ng_D(k) = 1 - 4\\mu \\sin^2\\!\\Big(\\frac{k \\Delta x}{2}\\Big).\n$$\n稳定性要求对所有 $k$ 都有 $|g_D(k)| \\le 1$，这当且仅当以下条件成立时才成立\n$$\n0 \\le \\mu \\le \\frac{1}{2} \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x^2}{2\\kappa}.\n$$\n\n因为我们在每个完整时间步内显式地组合子步骤，一个充分的组合稳定性条件是两个子步骤都各自稳定。因此，组合的时间步长约束为\n$$\n\\Delta t \\le \\min\\!\\left(\\frac{\\Delta x}{|u|}, \\frac{\\Delta x^2}{2\\kappa}\\right) \\equiv \\Delta t_{\\max}.\n$$\n\n接下来我们论证分裂误差的阶数。在一个时间步长上的精确解算子是半群 $e^{\\Delta t (A+D)}$。Lie 分裂先应用 $e^{\\Delta t A}$，再应用 $e^{\\Delta t D}$，这可以通过 Baker–Campbell–Hausdorff (BCH) 公式与精确算子联系起来：\n$$\ne^{\\Delta t A} e^{\\Delta t D} = e^{\\Delta t (A+D) + \\frac{\\Delta t^2}{2}[A,D] + \\mathcal{O}(\\Delta t^3)},\n$$\n其中 $[A,D] = AD - DA$ 是对易子。由于当 $u \\ne 0$ 和 $\\kappa \\ne 0$ 时 $[A,D] \\ne 0$，因此每时间步的局部误差为 $\\mathcal{O}(\\Delta t^2)$，经过 $t_{\\mathrm{end}}/\\Delta t$ 步后，全局误差累积为 $\\mathcal{O}(\\Delta t)$。因此，Lie 分裂是时间上一阶的。Strang 分裂使用对称组合 $e^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A}$，其 BCH 展开会消去主对易子项，得到\n$$\ne^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A} = e^{\\Delta t (A+D) + \\mathcal{O}(\\Delta t^3)}.\n$$\n因此，局部误差为 $\\mathcal{O}(\\Delta t^3)$，全局误差为 $\\mathcal{O}(\\Delta t^2)$，即时间上是二阶的。\n\n为了量化误差，我们将其与谱方法得到的精确周期解进行比较。令 $N = L/\\Delta x$，离散波数为 $k_n = 2\\pi n/L$，其中 $n \\in \\{0,1,\\dots,N-1\\}$ 使用标准离散傅里叶变换约定映射到有符号频率。如果 $\\widehat{T}(k_n,0)$ 是 $T(\\cdot,0)$ 的离散傅里叶变换，那么精确的演化过程为\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\n而精确解 $T(\\cdot,t)$ 是其逆变换。相对 $\\ell^2$ 误差使用\n$$\nE = \\frac{\\|T_{\\mathrm{num}} - T_{\\mathrm{exact}}\\|_2}{\\|T_{\\mathrm{exact}}\\|_2},\n$$\n观测精度阶数通过下式估算\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log 2}.\n$$\n\n程序算法设计：\n- 构建具有周期性的均匀网格 $x_j = j\\,\\Delta x$，$j = 0,1,\\dots,N-1$。\n- 初始化 $T(x,0) = \\cos(2\\pi x/L) + \\frac{1}{2}\\cos(4\\pi x/L + \\phi)$，其中 $\\phi = 0.3$ (弧度)。\n- 定义显式迎风平流子步骤。对于 $u \\ge 0$，\n$$\nT_j^{\\star} = T_j - r\\,(T_j - T_{j-1}), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\n而对于 $u  0$，\n$$\nT_j^{\\star} = T_j - r\\,(T_{j+1} - T_j), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\n其中 $j \\pm 1$ 的索引是周期性的。\n- 定义显式前向欧拉扩散子步骤，\n$$\nT_j^{\\mathrm{new}} = T_j^{\\star} + \\mu\\,(T_{j+1}^{\\star} - 2 T_j^{\\star} + T_{j-1}^{\\star}), \\quad \\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2}.\n$$\n- 对于选定的 $\\Delta t$ 和步数 $n = t_{\\mathrm{end}}/\\Delta t$，按照 Lie 和 Strang 分裂组合子步骤。\n- 使用上面的离散傅里叶变换公式计算 $t_{\\mathrm{end}}$ 处的精确解。\n- 计算相对 $\\ell^2$ 误差和观测阶数。\n- 对于稳定性指标，为选定的 $\\Delta t$ 计算 $r$ 和 $\\mu$，并返回 $r \\le 1$ 和 $\\mu \\le 1/2$ 是否成立。\n\n我们将此应用于三个指定的测试用例：\n\n- 测试用例 A：\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$。\n  - $\\Delta t_{\\max} = \\min\\!\\big(\\Delta x/|u|,\\ \\Delta x^2/(2\\kappa)\\big)$。\n  - 使用 $\\Delta t = 0.4\\,\\Delta t_{\\max}$，$t_{\\mathrm{end}} = 100\\,\\Delta t$。\n  - 计算 $p_{\\mathrm{Lie}}$ 和 $p_{\\mathrm{Strang}}$。\n\n- 测试用例 B：\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$。\n  - 计算 $\\Delta t_{\\max}$，然后使用 $\\Delta t = 0.99\\,\\Delta t_{\\max}$ 报告 $\\Delta t_{\\max}$、$r$、$\\mu$ 以及 $S = (r \\le 1)\\wedge(\\mu \\le 1/2)$。\n\n- 测试用例 C：\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$。\n  - 使用 $\\Delta t = 0.2\\,\\Delta t_{\\max}$ 和 $t_{\\mathrm{end}} = 100\\,\\Delta t$，计算 $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$。\n\n所有时间量必须以秒表示。最终打印的输出必须是以下格式的单行：\n$$\n[\\ p_{\\mathrm{Lie}}^{(A)},\\ p_{\\mathrm{Strang}}^{(A)},\\ \\Delta t_{\\max}^{(B)},\\ r^{(B)},\\ \\mu^{(B)},\\ S^{(B)},\\ R^{(C)}\\ ].\n$$",
            "answer": "```python\nimport numpy as np\n\ndef upwind_advection_step(T, u, dx, dt):\n    \"\"\"First-order upwind advection with periodic boundaries.\"\"\"\n    r = u * dt / dx\n    if u >= 0.0:\n        return T - r * (T - np.roll(T, 1))\n    else:\n        return T - r * (np.roll(T, -1) - T)\n\ndef diffusion_step(T, kappa, dx, dt):\n    \"\"\"Explicit forward Euler diffusion (FTCS) with periodic boundaries.\"\"\"\n    mu = kappa * dt / (dx * dx)\n    return T + mu * (np.roll(T, -1) - 2.0 * T + np.roll(T, 1))\n\ndef lie_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Lie splitting: A(dt) then D(dt).\"\"\"\n    T = T0.copy()\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, dt)\n        T = diffusion_step(T, kappa, dx, dt)\n    return T\n\ndef strang_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Strang splitting: A(dt/2), D(dt), A(dt/2).\"\"\"\n    T = T0.copy()\n    half_dt = 0.5 * dt\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, half_dt)\n        T = diffusion_step(T, kappa, dx, dt)\n        T = upwind_advection_step(T, u, dx, half_dt)\n    return T\n\ndef exact_solution_fft(T0, u, kappa, L, dx, t):\n    \"\"\"Exact periodic solution via discrete Fourier transform.\"\"\"\n    N = T0.size\n    # Wavenumbers in radians per meter\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    T0_hat = np.fft.fft(T0)\n    phase = np.exp(-(kappa * (k ** 2)) * t) * np.exp(-1j * k * u * t)\n    T_hat_t = T0_hat * phase\n    T_t = np.fft.ifft(T_hat_t).real\n    return T_t\n\ndef initial_condition(x, L, phi):\n    \"\"\"Initial condition: cos(2π x/L) + 0.5 cos(4π x/L + phi).\"\"\"\n    return np.cos(2.0 * np.pi * x / L) + 0.5 * np.cos(4.0 * np.pi * x / L + phi)\n\ndef rel_l2_error(a, b):\n    denom = np.linalg.norm(b)\n    if denom == 0.0:\n        return np.inf\n    return np.linalg.norm(a - b) / denom\n\ndef combined_dt_max(dx, u, kappa):\n    \"\"\"Combined explicit stability limit: min(dx/|u|, dx^2/(2*kappa)).\"\"\"\n    adv = np.inf if u == 0.0 else dx / abs(u)\n    diff = (dx * dx) / (2.0 * kappa)\n    return min(adv, diff)\n\ndef observed_order(errors_dt, errors_dt2):\n    \"\"\"Compute observed order p = log(E(dt)/E(dt/2))/log(2).\"\"\"\n    if errors_dt = 0 or errors_dt2 = 0:\n        return np.nan\n    return np.log(errors_dt / errors_dt2) / np.log(2.0)\n\ndef run_test_case_A():\n    # Parameters\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.4 * dt_max\n    dt2 = 0.5 * dt\n    nsteps = 100\n    tend = nsteps * dt\n\n    # Lie splitting errors at dt and dt/2\n    T_lie_dt = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    T_exact_dt = exact_solution_fft(T0, u, kappa, L, dx, tend)\n    E_lie_dt = rel_l2_error(T_lie_dt, T_exact_dt)\n\n    nsteps2 = int(2 * nsteps)  # to keep same tend\n    tend2 = nsteps2 * dt2\n    T_lie_dt2 = lie_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    T_exact_dt2 = exact_solution_fft(T0, u, kappa, L, dx, tend2)\n    E_lie_dt2 = rel_l2_error(T_lie_dt2, T_exact_dt2)\n\n    p_lie = observed_order(E_lie_dt, E_lie_dt2)\n\n    # Strang splitting errors at dt and dt/2\n    T_strang_dt = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang_dt = rel_l2_error(T_strang_dt, T_exact_dt)\n\n    T_strang_dt2 = strang_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_strang_dt2 = rel_l2_error(T_strang_dt2, T_exact_dt2)\n\n    p_strang = observed_order(E_strang_dt, E_strang_dt2)\n\n    return float(p_lie), float(p_strang)\n\ndef run_test_case_B():\n    L = 200000.0\n    dx = 1000.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.08 / seconds_per_year  # 0.08 m/yr in m/s\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.99 * dt_max\n    r = abs(u) * dt / dx\n    mu = kappa * dt / (dx * dx)\n    stable = (r = 1.0) and (mu = 0.5)\n    return float(dt_max), float(r), float(mu), bool(stable)\n\ndef run_test_case_C():\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.2 * dt_max\n    nsteps = 100\n    tend = nsteps * dt\n\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n\n    T_lie = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_lie = rel_l2_error(T_lie, T_exact)\n\n    T_strang = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang = rel_l2_error(T_strang, T_exact)\n\n    R = E_strang / E_lie if E_lie != 0.0 else np.nan\n    return float(R)\n\ndef solve():\n    # Run all test cases and aggregate results in the specified order.\n    p_lie_A, p_strang_A = run_test_case_A()\n    dtmax_B, r_B, mu_B, S_B = run_test_case_B()\n    R_C = run_test_case_C()\n\n    results = [p_lie_A, p_strang_A, dtmax_B, r_B, mu_B, S_B, R_C]\n    \n    # Format the boolean as a lowercase string for consistency with example formats like JSON\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(str(r))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}