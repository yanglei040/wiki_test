{
    "hands_on_practices": [
        {
            "introduction": "要掌握波的运动学，首先必须理解两个核心速度：相速度与群速度。这个练习将通过一个通用的幂律频散关系，引导你从基本定义出发，推导出这两个速度的表达式。通过分析这个模型，你将亲身体会到频散关系的数学形式如何直接决定了介质的物理性质——即它是否是频散的，以及波包能量的传播速度与单个波峰的传播速度之间的关系 。",
            "id": "3585604",
            "problem": "考虑一个一维、线性、无耗散且各向同性的弹性介质，在该介质中，小振幅平面波由波场 $u(x,t)=\\Re\\{A \\exp(i[k x - \\omega t])\\}$ 描述，其中 $A$ 是一个恒定的复振幅，$k$ 是波数，$\\omega$ 是角频率。假设该介质的特征是形式为 $\\omega=\\beta k^{n}$ 的幂律色散关系，其中常数 $\\beta>0$ 且 $n>0$。一个中心波数为 $k$ 的窄带波包根据该色散关系所蕴含的运动学规律进行传播。\n\n仅使用相速度和群速度的基本定义——其中相速度 $v_{p}$ 定义为角频率与波数之比，群速度 $v_{g}$ 定义为角频率对波数的导数——推导出 $v_{p}(k)$ 和 $v_{g}(k)$ 作为 $k$、$\\beta$ 和 $n$ 的函数的闭式表达式。然后，从介质是否具有色散性以及 $v_{p}$ 和 $v_{g}$ 的相对大小方面，分析 $n=1$ 和 $n=2$ 的特殊情况。\n\n将您的最终答案表示为一个包含三个元素 $\\bigl[v_{p}(k),\\,v_{g}(k),\\,v_{g}(k)/v_{p}(k)\\bigr]$ 的行矩阵。无需进行数值计算，最终答案中也不应包含单位。不要四舍五入；请提供精确表达式。任何定性讨论都应属于您的推导过程，而不应出现在最终答案中。",
            "solution": "该问题要求推导由幂律色散关系控制的波的相速度和群速度，并随后分析特殊情况。该问题提法明确，有科学依据，并为严谨求解提供了所有必要的定义和约束。\n\n给定的色散关系为 $\\omega(k) = \\beta k^{n}$，其中 $\\omega$ 是角频率，$k$ 是波数，$\\beta$ 和 $n$ 是正常数。波场由 $u(x,t)=\\Re\\{A \\exp(i[k x - \\omega t])\\}$ 给出。\n\n首先，我们推导相速度 $v_p$。提供的定义是角频率与波数之比：\n$$v_p(k) = \\frac{\\omega(k)}{k}$$\n将给定的色散关系代入此定义，得到：\n$$v_p(k) = \\frac{\\beta k^{n}}{k}$$\n使用指数定律，上式可简化为：\n$$v_p(k) = \\beta k^{n-1}$$\n这是相速度作为 $k$、$\\beta$ 和 $n$ 的函数的闭式表达式。\n\n接下来，我们推导群速度 $v_g$。提供的定义是角频率对波数的导数：\n$$v_g(k) = \\frac{d\\omega(k)}{dk}$$\n代入色散关系并使用幂次法则进行微分，其中 $\\beta$ 和 $n$ 是常数：\n$$v_g(k) = \\frac{d}{dk} (\\beta k^{n})$$\n$$v_g(k) = \\beta \\frac{d}{dk} (k^{n})$$\n$$v_g(k) = \\beta (n k^{n-1})$$\n$$v_g(k) = n \\beta k^{n-1}$$\n这是群速度的闭式表达式。\n\n从这两个结果中，我们可以观察到群速度和相速度之间的直接关系：\n$$v_g(k) = n (\\beta k^{n-1}) = n v_p(k)$$\n因此，群速度与相速度之比就是常数指数 $n$：\n$$\\frac{v_g(k)}{v_p(k)} = n$$\n\n现在，我们分析所要求的两种特殊情况。\n\n情况1：$n=1$\n在这种情况下，色散关系是线性的：$\\omega = \\beta k$。\n相速度为：\n$$v_p(k) = \\beta k^{1-1} = \\beta k^{0} = \\beta$$\n群速度为：\n$$v_g(k) = (1) \\beta k^{1-1} = \\beta k^{0} = \\beta$$\n此处，$v_p = v_g = \\beta$。相速度是一个常数，与波数 $k$ 无关。这是非色散介质的定义性特征。在这种介质中，波包的所有频率分量都以相同的速度传播，因此波包在传播过程中形状不会失真。\n\n情况2：$n=2$\n在这种情况下，色散关系是二次的：$\\omega = \\beta k^2$。\n相速度为：\n$$v_p(k) = \\beta k^{2-1} = \\beta k$$\n群速度为：\n$$v_g(k) = (2) \\beta k^{2-1} = 2 \\beta k$$\n在这种情况下，$v_g = 2 v_p$。由于相速度 $v_p$ 是波数 $k$ 的函数（具体来说，$v_p(k) \\propto k$），因此该介质是色散的。不同的频率分量以不同的相速度传播，导致波包在传播时发生展宽或“色散”。对于这种类型的色散，更高波数（更短波长）的分量具有更高的相速度。\n\n最终答案要求以行矩阵形式给出 $v_p(k)$、$v_g(k)$ 及其比值的通用表达式。\n这三个元素是：\n1. $v_p(k) = \\beta k^{n-1}$\n2. $v_g(k) = n \\beta k^{n-1}$\n3. $\\frac{v_g(k)}{v_p(k)} = n$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\beta k^{n-1}  n \\beta k^{n-1}  n\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从连续介质的物理理论到离散的数值计算，是计算地球物理学的一大步，而这一步也带来了新的挑战。本练习将揭示一个在波场模拟中普遍存在的现象：数值频散。通过分析一个标准有限差分格式的频散关系，你将计算出数值相速度和群速度，并量化它们与真实物理速度的偏差 。理解和控制这种非物理的频散效应，是保证数值模拟准确性的关键。",
            "id": "3585666",
            "problem": "考虑一维声波方程 $u_{tt} = c^{2} u_{xx}$，其中 $c$ 是波速，单位为米/秒。在时间和空间上进行标准的显式二阶时域有限差分（FDTD）离散化，得到一个隐含在平面波拟设 $u^{n}_{j} = \\exp\\left(i (k j \\Delta x - \\omega n \\Delta t)\\right)$ 中的数值色散关系，其中 $k$ 是空间波数（单位：弧度/米），$\\omega$ 是角频率（单位：弧度/秒），$\\Delta x$ 是空间网格间距（单位：米），$\\Delta t$ 是时间步长（单位：秒）。在此拟设下，与该离散化相关的数值色散曲线 $\\omega_{h}(k)$ 由以下关系隐式定义：\n$$\n\\sin^{2}\\left(\\frac{\\omega_{h}(k)\\,\\Delta t}{2}\\right) = \\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)^{2}\\,\\sin^{2}\\left(\\frac{k\\,\\Delta x}{2}\\right).\n$$\n采用反正弦函数的主支，使得 $\\omega_{h}(k) \\in \\left[0,\\frac{\\pi}{\\Delta t}\\right]$。\n\n使用相速度 $v_{p,h}(k) = \\omega_{h}(k)/k$ 和群速度 $v_{g,h}(k) = d\\omega_{h}(k)/dk$ 的定义，计算给定参数集下的 $v_{p,h}$ 和 $v_{g,h}$，并量化它们与连续非色散目标（其中 $\\omega(k) = c\\,k$，$v_{p} = c$ 且 $v_{g} = c$）的偏差。基于上述隐式数值色散关系，使用解析微分法计算 $d\\omega_{h}/dk$。速度以米/秒表示，所有角度均使用弧度。偏差以小数形式报告（不带百分号），相速度偏差定义为 $(v_{p,h} - c)/c$，群速度偏差定义为 $(v_{g,h} - c)/c$。\n\n你的程序必须为每个测试用例计算以下内容：\n- $v_{p,h}$，单位为米/秒，\n- $v_{g,h}$，单位为米/秒，\n- $v_{p,h}$ 相对于 $c$ 的相对偏差，即 $(v_{p,h} - c)/c$，\n- $v_{g,h}$ 相对于 $c$ 的相对偏差，即 $(v_{g,h} - c)/c$。\n\n使用以下测试套件，其中所有角度均以弧度为单位，所有距离均以米为单位：\n- 测试用例 1：$c = 2500$，$\\Delta x = 10$，$\\Delta t = 0.002$，$k = \\frac{\\pi}{40}$。\n- 测试用例 2：$c = 2500$，$\\Delta x = 10$，$\\Delta t = 0.0036$，$k = \\frac{\\pi}{20}$。\n- 测试用例 3：$c = 2500$，$\\Delta x = 10$，$\\Delta t = 0.003996$，$k = 10^{-6}$。\n- 测试用例 4：$c = 2500$，$\\Delta x = 10$，$\\Delta t = 0.0036$，$k = \\frac{\\pi}{10} - 10^{-9}$。\n- 测试用例 5：$c = 2500$，$\\Delta x = 10$，$\\Delta t = 0.0004$，$k = \\frac{\\pi}{30}$。\n\n覆盖范围设计：\n- 测试用例 1 是一个中等波数、中等 Courant–Friedrichs–Lewy (CFL) 数的通用场景。\n- 测试用例 2 使用了更高的 CFL 数和更高的波数。\n- 测试用例 3 在接近 CFL 极限的条件下，探测 $k \\to 0^{+}$ 附近的小波数极限。\n- 测试用例 4 探索了奈奎斯特波数 $k_{\\text{N}} = \\frac{\\pi}{\\Delta x}$ 附近的行为，在该处数值群速度趋向于 0。\n- 测试用例 5 考察了低 CFL 数的情况。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序为\n$[v_{p,h}^{(1)}, v_{g,h}^{(1)}, \\delta v_{p}^{(1)}, \\delta v_{g}^{(1)}, v_{p,h}^{(2)}, v_{g,h}^{(2)}, \\delta v_{p}^{(2)}, \\delta v_{g}^{(2)}, \\dots, v_{p,h}^{(5)}, v_{g,h}^{(5)}, \\delta v_{p}^{(5)}, \\delta v_{g}^{(5)}]$,\n其中上标表示从 1 到 5 的测试用例索引。所有速度值必须以米/秒为单位，偏差必须是相对于 $c$ 的小数值。",
            "solution": "已根据指定标准对用户提供的问题进行了分析和验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：一维声波方程，$u_{tt} = c^{2} u_{xx}$。\n- **物理/数值参数**：波速 $c$ (米/秒)，空间波数 $k$ (弧度/米)，角频率 $\\omega$ (弧度/秒)，空间网格间距 $\\Delta x$ (米)，时间步长 $\\Delta t$ (秒)。\n- **平面波拟设**：$u^{n}_{j} = \\exp\\left(i (k j \\Delta x - \\omega n \\Delta t)\\right)$。\n- **隐式数值色散关系**：$\\sin^{2}\\left(\\frac{\\omega_{h}(k)\\,\\Delta t}{2}\\right) = \\left(\\frac{c\\,\\Delta t}{\\Delta x}\\right)^{2}\\,\\sin^{2}\\left(\\frac{k\\,\\Delta x}{2}\\right)$。\n- **分支约束**：$\\omega_{h}(k) \\in \\left[0,\\frac{\\pi}{\\Delta t}\\right]$。\n- **速度定义**：数值相速度 $v_{p,h}(k) = \\omega_{h}(k)/k$，数值群速度 $v_{g,h}(k) = d\\omega_{h}(k)/dk$。\n- **连续（目标）速度**：$v_{p} = c$, $v_{g} = c$。\n- **偏差定义**：相速度偏差 $\\delta v_{p} = (v_{p,h} - c)/c$，群速度偏差 $\\delta v_{g} = (v_{g,h} - c)/c$。\n- **计算要求**：使用解析微分法计算 $d\\omega_{h}/dk$。\n- **测试用例**：\n    1.  $c = 2500$ 米/秒，$\\Delta x = 10$ 米，$\\Delta t = 0.002$ 秒，$k = \\frac{\\pi}{40}$ 弧度/米。\n    2.  $c = 2500$ 米/秒，$\\Delta x = 10$ 米，$\\Delta t = 0.0036$ 秒，$k = \\frac{\\pi}{20}$ 弧度/米。\n    3.  $c = 2500$ 米/秒，$\\Delta x = 10$ 米，$\\Delta t = 0.003996$ 秒，$k = 10^{-6}$ 弧度/米。\n    4.  $c = 2500$ 米/秒，$\\Delta x = 10$ 米，$\\Delta t = 0.0036$ 秒，$k = \\frac{\\pi}{10} - 10^{-9}$ 弧度/米。\n    5.  $c = 2500$ 米/秒，$\\Delta x = 10$ 米，$\\Delta t = 0.0004$ 秒，$k = \\frac{\\pi}{30}$ 弧度/米。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上和数学上都是合理的。\n- **科学依据**：该问题涉及应用于声波方程的标准二阶有限差分格式的数值色散分析。这是计算地球物理学和偏微分方程数值分析中的一个典型课题。所有方程和定义都是标准的且正确的。\n- **适定性**：问题陈述清晰，并提供了所有必要的参数。要使解存在，数值格式必须是稳定的，这要求满足 Courant–Friedrichs–Lewy (CFL) 条件。CFL 数为 $S = c \\Delta t / \\Delta x$。为保证稳定性，$S \\le 1$。对测试用例的分析证实，所有用例都满足 $S \\le 1$（分别为 $0.5$、$0.9$、$0.999$、$0.9$ 和 $0.1$），这确保了色散关系中反正弦函数的参数的绝对值不超过 1，从而保证了 $\\omega_h(k)$ 有实数解。\n- **客观性**：问题使用精确、客观和定量的语言表述，没有任何主观性。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。下面提供了完整的解决方案。\n\n### 基于原理的求解推导\n目标是从给定的隐式色散关系中推导出数值相速度 $v_{p,h}(k)$ 和群速度 $v_{g,h}(k)$ 的显式表达式，然后用这些表达式计算指定测试用例所需的量。\n\n隐式色散关系为：\n$$ \\sin^{2}\\left(\\frac{\\omega_{h}(k)\\,\\Delta t}{2}\\right) = S^2\\,\\sin^{2}\\left(\\frac{k\\,\\Delta x}{2}\\right) $$\n其中 $S = \\frac{c\\,\\Delta t}{\\Delta x}$ 是 Courant 数。\n\n**1. 数值相速度 ($v_{p,h}$) 的推导**\n\n首先，我们求解色散关系以得到 $\\omega_h(k)$。对两边取平方根，得到：\n$$ \\left|\\sin\\left(\\frac{\\omega_{h}(k)\\,\\Delta t}{2}\\right)\\right| = |S|\\,\\left|\\sin\\left(\\frac{k\\,\\Delta x}{2}\\right)\\right| $$\n按照惯例，$c$、$\\Delta t$ 和 $\\Delta x$ 均为正值，因此 $S$ 为正。波数 $k$ 通常考虑在 $[0, k_{\\text{N}}]$ 范围内，其中奈奎斯特波数为 $k_{\\text{N}} = \\pi/\\Delta x$。在此范围内，$k \\Delta x / 2 \\in [0, \\pi/2]$，因此 $\\sin(k \\Delta x / 2) \\ge 0$。问题规定 $\\omega_{h}(k) \\in [0, \\pi/\\Delta t]$，这意味着 $\\omega_{h} \\Delta t / 2 \\in [0, \\pi/2]$，因此 $\\sin(\\omega_{h} \\Delta t / 2) \\ge 0$。因此我们可以去掉绝对值符号：\n$$ \\sin\\left(\\frac{\\omega_{h}(k)\\,\\Delta t}{2}\\right) = S\\,\\sin\\left(\\frac{k\\,\\Delta x}{2}\\right) $$\n应用反正弦函数（按指定，取主支）可得：\n$$ \\frac{\\omega_{h}(k)\\,\\Delta t}{2} = \\arcsin\\left(S\\,\\sin\\left(\\frac{k\\,\\Delta x}{2}\\right)\\right) $$\n求解数值角频率 $\\omega_h(k)$：\n$$ \\omega_{h}(k) = \\frac{2}{\\Delta t} \\arcsin\\left(\\frac{c\\,\\Delta t}{\\Delta x}\\,\\sin\\left(\\frac{k\\,\\Delta x}{2}\\right)\\right) $$\n数值相速度定义为 $v_{p,h}(k) = \\omega_{h}(k)/k$。代入 $\\omega_h(k)$ 的表达式，得到：\n$$ v_{p,h}(k) = \\frac{2}{k\\,\\Delta t} \\arcsin\\left(\\frac{c\\,\\Delta t}{\\Delta x}\\,\\sin\\left(\\frac{k\\,\\Delta x}{2}\\right)\\right) $$\n由于 $\\omega_h$ 和 $k$ 之间的非线性关系，$v_{p,h}$ 是 $k$ 的函数，这种现象被称为数值色散。对于此格式，可以证明 $v_{p,h}(k) \\le c$，这表明数值波滞后于真实的物理波。\n\n**2. 数值群速度 ($v_{g,h}$) 的推导**\n\n数值群速度为 $v_{g,h}(k) = d\\omega_{h}(k)/dk$。我们使用链式法则对 $\\omega_h(k)$ 的显式表达式关于 $k$ 求导。令 $u(k) = S \\sin(k \\Delta x / 2)$。则 $\\omega_h(k) = (2/\\Delta t) \\arcsin(u(k))$。\n$$ v_{g,h}(k) = \\frac{d\\omega_h}{dk} = \\frac{2}{\\Delta t} \\frac{d}{dk}\\left(\\arcsin(u)\\right) = \\frac{2}{\\Delta t} \\frac{1}{\\sqrt{1 - u^2}} \\frac{du}{dk} $$\n$u(k)$ 的导数是：\n$$ \\frac{du}{dk} = \\frac{d}{dk}\\left(S \\sin\\left(\\frac{k\\Delta x}{2}\\right)\\right) = S \\cos\\left(\\frac{k\\Delta x}{2}\\right) \\frac{\\Delta x}{2} $$\n代回到 $v_{g,h}(k)$ 的表达式中：\n$$ v_{g,h}(k) = \\frac{2}{\\Delta t} \\frac{1}{\\sqrt{1 - S^2 \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)}} \\left(S \\cos\\left(\\frac{k\\Delta x}{2}\\right) \\frac{\\Delta x}{2}\\right) $$\n化简并代入 $S = c \\Delta t / \\Delta x$，这意味着 $S \\Delta x / \\Delta t = c$：\n$$ v_{g,h}(k) = \\frac{S\\,\\Delta x}{\\Delta t} \\frac{\\cos\\left(\\frac{k\\Delta x}{2}\\right)}{\\sqrt{1 - S^2 \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)}} = c \\frac{\\cos\\left(\\frac{k\\Delta x}{2}\\right)}{\\sqrt{1 - \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 \\sin^2\\left(\\frac{k\\Delta x}{2}\\right)}} $$\n这个表达式表明 $v_{g,h}$ 也依赖于 $k$。当 $k \\to k_{\\text{N}} = \\pi/\\Delta x$ 时，项 $\\cos(k \\Delta x / 2) \\to \\cos(\\pi/2) = 0$，导致群速度消失，$v_{g,h} \\to 0$。这意味着高频波包在网格上的传播效果不佳。在低波数极限 ($k \\to 0$)下，$v_{p,h}$ 和 $v_{g,h}$ 都趋近于物理速度 $c$。\n\n**3. 偏差计算**\n\n相对偏差按规定计算：\n- 相对相速度偏差：$\\delta v_{p} = \\frac{v_{p,h}(k) - c}{c}$\n- 相对群速度偏差：$\\delta v_{g} = \\frac{v_{g,h}(k) - c}{c}$\n\n这些公式将为每个测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical phase and group velocities and their deviations\n    for a 1D FDTD scheme for the acoustic wave equation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c, delta_x, delta_t, k)\n        (2500.0, 10.0, 0.002, np.pi / 40.0),\n        (2500.0, 10.0, 0.0036, np.pi / 20.0),\n        (2500.0, 10.0, 0.003996, 1e-6),\n        (2500.0, 10.0, 0.0036, np.pi / 10.0 - 1e-9),\n        (2500.0, 10.0, 0.0004, np.pi / 30.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        c, dx, dt, k = case\n\n        # Calculate the Courant number, S\n        S = c * dt / dx\n\n        # --- Phase Velocity Calculation ---\n        # Argument for the arcsin function\n        arg_asin = S * np.sin(k * dx / 2.0)\n\n        # The problem setup ensures |arg_asin| = 1.\n        # Numerical angular frequency omega_h(k)\n        omega_h = (2.0 / dt) * np.arcsin(arg_asin)\n\n        # Numerical phase velocity v_p,h(k) = omega_h / k\n        # For k -> 0, the limit is c. Direct computation is fine for k=1e-6.\n        v_ph = omega_h / k\n\n        # --- Group Velocity Calculation ---\n        # Numerator of the group velocity expression\n        v_gh_num = c * np.cos(k * dx / 2.0)\n        \n        # Denominator of the group velocity expression\n        v_gh_den = np.sqrt(1.0 - arg_asin**2)\n        \n        # Numerical group velocity v_g,h(k)\n        v_gh = v_gh_num / v_gh_den\n        \n        # --- Deviation Calculation ---\n        # Relative deviation of phase velocity\n        dev_vph = (v_ph - c) / c\n        \n        # Relative deviation of group velocity\n        dev_vgh = (v_gh - c) / c\n        \n        results.extend([v_ph, v_gh, dev_vph, dev_vgh])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "频散关系不仅是描述波传播的理论工具，更是进行地球物理反演的有力武器。这个综合性练习将向你展示如何利用波速随频率变化的特性，来推断介质的隐藏物理参数。你将为水面重力波建立正演模型，并基于“观测”数据，通过高斯-牛顿法迭代更新模型参数（水深），从而完成一次完整的地球物理反演流程 。",
            "id": "3585654",
            "problem": "考虑在恒定深度的均质、无粘性、不可压缩流体表面传播的线性重力波。从无旋流动的控制假设以及线性化的自由表面和底部边界条件出发。利用这些原理推导色散关系，该关系通过流体深度 $h$ 和重力加速度 $g$ 将角频率 $\\omega$ 与波数 $k$联系起来。相速度定义为 $c = \\omega / k$。您的任务是为两个候选深度模型计算合成色散曲线 $c(\\omega; h)$，然后计算单步线性化Gauss-Newton迭代来更新深度参数，以减小相对于一组由已知“真实”深度生成的“观测”相速度的最小二乘失配。\n\n要求与定义：\n1. 在所述假设下，使用线性重力波理论。基于这些假设，定义 $\\omega$ 和 $k$ 之间的色散关系。相速度为 $c = \\omega / k$。\n2. 对于每个角频率 $\\omega$，通过求解色散关系方程来计算波数 $k$，给定 $\\omega$、$h$ 和 $g$。该关于 $k$ 的函数是单调的，有唯一的正根，并且必须进行数值求解。\n3. 将观测相速度与模型相速度之间的均方根（RMS）失配定义为\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(c_{\\mathrm{obs}, i} - c_{\\mathrm{mod}, i}(h)\\right)^2},\n$$\n其中 $N$ 是角频率的数量。\n4. 通过最小化残差平方和 $\\sum_i r_i^2$（其中 $r_i = c_{\\mathrm{obs}, i} - c_{\\mathrm{mod}, i}(h)$）来执行单步Gauss-Newton迭代以更新标量参数 $h$。使用线性化 $r(h_0 + \\Delta h) \\approx r(h_0) - J \\Delta h$，其中 $J_i = \\partial c_i / \\partial h$ 在当前参数 $h_0$ 处求值。对于单参数情况，更新公式为\n$$\n\\Delta h = \\left(J^\\top J\\right)^{-1} J^\\top r.\n$$\n更新后，通过将深度限制为 $h \\leftarrow \\max(h_0 + \\Delta h, \\epsilon)$ 来强制深度的物理正性，其中 $\\epsilon$ 是一个以米为单位的很小的正常数。\n5. 所有物理量必须使用明确的单位：深度 $h$ 单位为米 (m)，重力加速度 $g$ 单位为米/秒$^2$ (m/s$^2$)，角频率 $\\omega$ 单位为弧度/秒 (rad/s)，相速度 $c$ 单位为米/秒 (m/s)。输入频率以赫兹 (Hz) 提供，必须使用 $\\omega = 2\\pi f$ 转换为弧度/秒。\n6. 观测相速度 $c_{\\mathrm{obs}}$ 是通过精确求解色散关系，由“真实”深度 $h_{\\mathrm{true}}$ 合成生成的，不添加任何噪声。\n\n测试套件规范：\n对于每个测试用例，按顺序计算以下输出：\n- 更新前候选深度 $h_A$ 的 $\\mathrm{RMS}_A$（单位：m/s）。\n- 更新前候选深度 $h_B$ 的 $\\mathrm{RMS}_B$（单位：m/s）。\n- 从 $h_A$ 进行一次Gauss-Newton迭代后更新的 $h_A^{\\mathrm{updated}}$（单位：m）。\n- $h_A$ 更新后的 $\\mathrm{RMS}_A^{\\mathrm{updated}}$（单位：m/s）。\n- 从 $h_B$ 进行一次Gauss-Newton迭代后更新的 $h_B^{\\mathrm{updated}}$（单位：m）。\n- $h_B$ 更新后的 $\\mathrm{RMS}_B^{\\mathrm{updated}}$（单位：m/s）。\n\n使用重力加速度 $g = 9.81$ m/s$^2$。使用正性约束 $\\epsilon = 10^{-6}$ m。\n\n提供三个测试用例以检验不同区域：\n1. 偏浅水区：\n   - $h_{\\mathrm{true}} = 10$ m\n   - 候选深度： $h_A = 5$ m, $h_B = 15$ m\n   - 频率（赫兹）： $[0.05, 0.10, 0.20, 0.50]$\n2. 兼具浅水和深水行为的混合区：\n   - $h_{\\mathrm{true}} = 50$ m\n   - 候选深度： $h_A = 30$ m, $h_B = 80$ m\n   - 频率（赫兹）： $[0.05, 0.10, 0.20, 0.50, 1.00]$\n3. 深水主导区：\n   - $h_{\\mathrm{true}} = 4000$ m\n   - 候选深度： $h_A = 2000$ m, $h_B = 6000$ m\n   - 频率（赫兹）： $[0.20, 0.50, 1.00]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的所有结果，以逗号分隔列表的形式包含在方括号内，顺序如下：\n$$\n[\\mathrm{RMS}_A^{(1)}, \\mathrm{RMS}_B^{(1)}, h_A^{\\mathrm{updated}(1)}, \\mathrm{RMS}_A^{\\mathrm{updated}(1)}, h_B^{\\mathrm{updated}(1)}, \\mathrm{RMS}_B^{\\mathrm{updated}(1)}, \\mathrm{RMS}_A^{(2)}, \\dots, \\mathrm{RMS}_B^{\\mathrm{updated}(3)}].\n$$\n所有 RMS 条目单位为 m/s，所有深度条目单位为 m。",
            "solution": "用户提供的问题经评估在科学上是合理的、适定的和自洽的。它描述了一个基于已建立的表面重力波线性理论的地球物理反演标准练习。所有必需的常数、方程和测试参数均已提供。任务是推导控制方程并为单参数反演问题实现数值解。\n\n### 1. 理论基础：色散关系\n\n该问题涉及在恒定深度 $h$ 的均质、无粘性、不可压缩流体中的线性表面重力波。在无旋流动的假设下，存在一个速度势 $\\Phi(x, z, t)$，它满足Laplace方程：\n$$\n\\nabla^2 \\Phi = \\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial z^2} = 0\n$$\n这里，$x$ 是水平坐标，$z$ 是垂直坐标（$z=0$ 在平均自由表面，$z=-h$ 在底部），$t$ 是时间。\n\n流动受以下边界条件约束：\n1.  **底部边界条件**：在 $z = -h$ 处的平坦海床上，法向流速为零。\n    $$\n    \\frac{\\partial \\Phi}{\\partial z} = 0 \\quad \\text{at} \\quad z = -h\n    $$\n2.  **线性化运动学自由表面条件**：表面 $z = \\eta(x, t)$ 上的流体质点保持在表面上。对于小振幅波，此条件在 $z=0$ 处求值。\n    $$\n    \\frac{\\partial \\eta}{\\partial t} = \\frac{\\partial \\Phi}{\\partial z} \\quad \\text{at} \\quad z = 0\n    $$\n3.  **线性化动力学自由表面条件**：自由表面上的压力是恒定的。根据线性化的Bernoulli方程：\n    $$\n    \\frac{\\partial \\Phi}{\\partial t} + g\\eta = 0 \\quad \\text{at} \\quad z = 0\n    $$\n    其中 $g$ 是重力加速度。\n\n我们寻求形如 $\\Phi(x, z, t) = Z(z) e^{i(kx - \\omega t)}$ 的行波解，其中 $k$ 是波数，$\\omega$ 是角频率。代入Laplace方程得到关于 $Z(z)$ 的常微分方程：\n$$\nZ''(z) - k^2 Z(z) = 0\n$$\n通解为 $Z(z) = A e^{kz} + B e^{-kz}$。应用底部边界条件 $Z'(-h) = 0$，可以关联 $A$ 和 $B$，得到形如 $Z(z) = C \\cosh(k(z+h))$ 的解，其中 $C$ 是某个常数。\n\n可以通过消去 $\\eta(x,t)$ 来合并两个自由表面条件。对动力学条件关于 $t$ 求导，并代入运动学条件，得到在 $z=0$ 处的单个边界条件：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial t^2} + g \\frac{\\partial \\Phi}{\\partial z} = 0 \\quad \\text{at} \\quad z=0\n$$\n将我们的势函数形式 $\\Phi(x, z, t) \\propto \\cosh(k(z+h)) e^{i(kx - \\omega t)}$ 代入这个组合条件，得到：\n$$\n(-\\omega^2) \\cosh(kh) + g (k \\sinh(kh)) = 0\n$$\n整理后得到著名的线性表面重力波色散关系：\n$$\n\\omega^2 = gk \\tanh(kh)\n$$\n\n### 2. 正演问题：计算相速度\n\n相速度定义为 $c = \\omega / k$。为了计算给定角频率 $\\omega$ 和深度 $h$ 下的相速度 $c(\\omega; h)$，我们必须首先通过求解色散关系来找到相应的波数 $k$。需要求解的关于 $k$ 的方程是：\n$$\nF(k) = gk \\tanh(kh) - \\omega^2 = 0\n$$\n这个超越方程没有关于 $k$ 的闭式解。然而，对于给定的 $\\omega  0$, $h  0$, 和 $g  0$，$F(k)$ 函数在 $k  0$ 时是严格单调的，这保证了存在唯一的正根。此根可以通过数值方法找到，例如使用Newton-Raphson方法。迭代公式为：\n$$\nk_{n+1} = k_n - \\frac{F(k_n)}{F'(k_n)}\n$$\n其中导数为 $F'(k) = g \\tanh(kh) + gkh \\text{ sech}^2(kh)$。一个合适的初始猜测是深水近似 $k_0 = \\omega^2/g$。一旦找到 $k$，模型相速度就计算为 $c_{\\mathrm{mod}} = \\omega / k$。\n\n### 3. 反演问题：深度的Gauss-Newton更新\n\n目标是更新深度的初始估计值 $h_0$，以更好地拟合一组在不同频率 $\\omega_i$ 下观测到的相速度 $c_{\\mathrm{obs},i}$。我们的目标是最小化残差平方和 $S(h) = \\sum_i r_i^2$，其中残差为 $r_i(h) = c_{\\mathrm{obs}, i} - c_{\\mathrm{mod}, i}(h)$。\n\nGauss-Newton方法是一种迭代优化算法，它将残差函数在当前估计值 $h_0$ 附近进行线性化：\n$$\nr_i(h_0 + \\Delta h) \\approx r_i(h_0) + \\frac{\\partial c_{\\mathrm{mod}, i}}{\\partial h}\\bigg|_{h_0} (-\\Delta h)\n$$\n写成矩阵形式为 $r(h_0 + \\Delta h) \\approx r(h_0) - J \\Delta h$，其中 $J$ 是Jacobian矩阵，其元素为在 $h_0$ 处求值的 $J_i = \\partial c_i / \\partial h$。更新步长 $\\Delta h$ 的最小二乘解是：\n$$\n\\Delta h = (J^\\top J)^{-1} J^\\top r\n$$\n对于这个单参数问题，该公式简化为一个标量方程：\n$$\n\\Delta h = \\frac{\\sum_i J_i r_i}{\\sum_i J_i^2}\n$$\n为了计算Jacobian矩阵的元素 $J_i = \\partial c_i / \\partial h$，我们对色散关系 $\\omega^2 = gk \\tanh(kh)$ 进行隐式微分。由于 $\\omega$ 是一个固定的自变量，对其关于 $h$ 求导得到：\n$$\n0 = g \\frac{\\partial k}{\\partial h} \\tanh(kh) + gk \\left( \\text{sech}^2(kh) \\cdot \\left(k + h \\frac{\\partial k}{\\partial h}\\right) \\right)\n$$\n求解 $\\partial k / \\partial h$：\n$$\n\\frac{\\partial k}{\\partial h} = -\\frac{gk^2 \\text{ sech}^2(kh)}{g \\tanh(kh) + gkh \\text{ sech}^2(kh)} = - \\frac{k^2 \\text{ sech}^2(kh)}{\\tanh(kh) + kh \\text{ sech}^2(kh)}\n$$\n现在，我们求相速度 $c = \\omega/k$ 的导数：\n$$\n\\frac{\\partial c}{\\partial h} = -\\frac{\\omega}{k^2} \\frac{\\partial k}{\\partial h} = -\\frac{\\omega}{k^2} \\left( - \\frac{k^2 \\text{ sech}^2(kh)}{\\tanh(kh) + kh \\text{ sech}^2(kh)} \\right) = \\frac{\\omega \\text{ sech}^2(kh)}{\\tanh(kh) + kh \\text{ sech}^2(kh)}\n$$\n每个Jacobian元素 $J_i$ 都使用此公式计算，其中使用 $\\omega_i$ 和相应的 $k_i$（使用当前深度估计 $h_0$ 计算得出）。\n\n计算出 $\\Delta h$ 后，更新的深度为 $h_{\\mathrm{new}} = h_0 + \\Delta h$。为确保物理上的合理性，深度被限制为非负值：$h_{\\mathrm{updated}} = \\max(h_{\\mathrm{new}}, \\epsilon)$，其中 $\\epsilon$ 是一个很小的正常数。\n\n### 4. 计算算法\n\n每个测试用例的总体流程如下：\n1.  给定一组频率 $f_i$，将它们转换为角频率 $\\omega_i = 2\\pi f_i$。\n2.  使用真实深度 $h_{\\mathrm{true}}$ 对每个 $\\omega_i$ 求解正演问题，生成“观测”数据 $c_{\\mathrm{obs}, i}$。这包括从 $\\omega_i^2 = gk_i \\tanh(k_i h_{\\mathrm{true}})$ 中数值求解 $k_i$，然后计算 $c_{\\mathrm{obs}, i} = \\omega_i/k_i$。\n3.  对于每个候选初始深度 $h_0$（例如 $h_A$ 或 $h_B$）：\n    a.  计算初始的模型相速度 $c_{\\mathrm{mod}, i}(h_0)$ 和初始RMS失配 $\\sqrt{\\frac{1}{N}\\sum_i (c_{\\mathrm{obs},i} - c_{\\mathrm{mod},i}(h_0))^2}$。\n    b.  计算残差向量 $r_i = c_{\\mathrm{obs}, i} - c_{\\mathrm{mod}, i}(h_0)$。\n    c.  计算在 $h_0$ 和相应波数 $k_i(h_0)$ 处求值的Jacobian向量 $J_i = \\partial c_i / \\partial h$。\n    d.  计算深度更新 $\\Delta h = (\\sum_i J_i r_i) / (\\sum_i J_i^2)$。当分母接近于零（深水区）时，通过设置 $\\Delta h=0$ 来处理该情况。\n    e.  计算更新后的深度 $h_{\\mathrm{updated}} = \\max(h_0 + \\Delta h, \\epsilon)$。\n    f.  计算新的模型相速度 $c_{\\mathrm{mod}, i}(h_{\\mathrm{updated}})$ 和新的RMS失配。\n4.  按规定收集并报告所有计算值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Main function to run the inversion for all specified test cases.\n    \"\"\"\n    G = 9.81\n    EPSILON = 1e-6\n    # For numerical stability, to avoid division by near-zero.\n    JACOBIAN_FLOOR = 1e-20 \n    \n    test_cases = [\n        {\n            \"h_true\": 10.0, \"h_A\": 5.0, \"h_B\": 15.0, \"f_hz\": [0.05, 0.10, 0.20, 0.50]\n        },\n        {\n            \"h_true\": 50.0, \"h_A\": 30.0, \"h_B\": 80.0, \"f_hz\": [0.05, 0.10, 0.20, 0.50, 1.00]\n        },\n        {\n            \"h_true\": 4000.0, \"h_A\": 2000.0, \"h_B\": 6000.0, \"f_hz\": [0.20, 0.50, 1.00]\n        },\n    ]\n\n    def solve_k(omega, h, g):\n        \"\"\"Numerically solves the dispersion relation for wavenumber k.\"\"\"\n        if h == 0 or omega == 0:\n            return np.inf\n\n        # Function whose root is sought: F(k) = gk*tanh(kh) - omega^2\n        func = lambda k: g * k * np.tanh(k * h) - omega**2\n        \n        # Derivative of F(k) w.r.t. k\n        fprime = lambda k: g * np.tanh(k * h) + g * k * h / np.cosh(k * h)**2\n        \n        # Initial guess from deep-water approximation\n        k_guess = omega**2 / g\n        \n        try:\n            k_sol = newton(func, k_guess, fprime=fprime, tol=1e-9, maxiter=50)\n        except RuntimeError:\n            k_sol = np.inf # Newton's method might fail if guess is poor, though unlikely here\n            \n        return k_sol\n\n    def compute_c_array(omegas, h, g):\n        \"\"\"Computes phase velocities for an array of frequencies.\"\"\"\n        ks = np.array([solve_k(om, h, g) for om in omegas])\n        return omegas / ks\n\n    def compute_jacobian_entry(omega, h, g, k):\n        \"\"\"Computes a single entry of the Jacobian vector, dc/dh.\"\"\"\n        tanh_kh = np.tanh(k * h)\n        sech_kh = 1.0 / np.cosh(k * h)\n        \n        numerator = omega * sech_kh**2\n        denominator = tanh_kh + k * h * sech_kh**2\n        \n        if abs(denominator)  JACOBIAN_FLOOR:\n            return 0.0\n            \n        return numerator / denominator\n\n    def process_candidate(omegas, c_obs, h_0, g, epsilon):\n        \"\"\"\n        Performs one Gauss-Newton step for a single candidate depth.\n        Returns: initial RMS, updated h, and updated RMS.\n        \"\"\"\n        # 1. Compute initial model and misfit\n        ks_0 = np.array([solve_k(om, h_0, g) for om in omegas])\n        c_mod_0 = omegas / ks_0\n        rms_0 = np.sqrt(np.mean((c_obs - c_mod_0)**2))\n\n        # 2. Compute residuals and Jacobian\n        residuals = c_obs - c_mod_0\n        jacobian = np.array([compute_jacobian_entry(om, h_0, g, k) for om, k in zip(omegas, ks_0)])\n        \n        # 3. Compute the Gauss-Newton update step\n        JTJ = np.sum(jacobian**2)\n        if JTJ  JACOBIAN_FLOOR:\n            # Data is insensitive to the parameter (e.g., deep water)\n            delta_h = 0.0\n        else:\n            JTr = np.sum(jacobian * residuals)\n            delta_h = JTr / JTJ\n            \n        # 4. Apply update and positivity clamp\n        h_updated = max(h_0 + delta_h, epsilon)\n\n        # 5. Compute updated model and misfit\n        c_mod_updated = compute_c_array(omegas, h_updated, g)\n        rms_updated = np.sqrt(np.mean((c_obs - c_mod_updated)**2))\n\n        return rms_0, h_updated, rms_updated\n\n    all_results = []\n    for case in test_cases:\n        h_true = case[\"h_true\"]\n        freqs_hz = np.array(case[\"f_hz\"])\n        omegas = 2 * np.pi * freqs_hz\n\n        # Generate \"observed\" data from true depth\n        c_obs = compute_c_array(omegas, h_true, G)\n        \n        # Process candidate A\n        h_A = case[\"h_A\"]\n        rms_A, h_A_updated, rms_A_updated = process_candidate(omegas, c_obs, h_A, G, EPSILON)\n        \n        # Process candidate B\n        h_B = case[\"h_B\"]\n        rms_B, h_B_updated, rms_B_updated = process_candidate(omegas, c_obs, h_B, G, EPSILON)\n\n        all_results.extend([\n            rms_A,\n            rms_B,\n            h_A_updated,\n            rms_A_updated,\n            h_B_updated,\n            rms_B_updated\n        ])\n    \n    print(f\"[{','.join(f'{x:.8f}' for x in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}