{
    "hands_on_practices": [
        {
            "introduction": "将连续的物理定律转化为离散的计算机模型，是我们必须谨慎搭建的桥梁。此项实践  为任何重力正演模拟代码提供了一项基础而关键的检验：将其数值近似解（一个基于体素的球体）与已知的精确解析解进行对比。通过量化误差，我们不仅能验证代码的正确性，还能深入理解离散化方案对计算精度的影响。",
            "id": "3597417",
            "problem": "考虑一个半径为 $R$、密度差为 $\\Delta \\rho$ 的球对称均匀物体，它嵌入在一个均匀的背景介质中。设国际单位制（SI）中的引力常数为 $G$。位于球心上方垂直轴上高度为 $h$ 处的观测点的引力加速度垂直分量记为 $g_z(h)$，并约定 $g_z$ 向下为正。您的任务是通过量化作为体素大小和观测高度 $h$ 的函数的绝对误差，来验证一个基于体素的 $g_z$ 正演模型与均匀球体解析异常的一致性。\n\n从牛顿万有引力定律和由连续质量分布引起的引力加速度的定义出发，推导均匀球体 $g_z(h)$ 的解析表达式。然后设计一个算法，用一组边长为 $\\Delta$、密度差恒为 $\\Delta \\rho$ 的相同立方体素来近似该球体。每个体素由其中心的点质量表示，总的 $g_z$ 是通过对所有中心位于球体内部的体素的贡献求和得到的。位于位置 $(x_i,y_i,z_i)$、体积为 $\\Delta^3$、质量为 $\\Delta \\rho \\Delta^3$ 的体素对观测点 $(0,0,h)$ 处 $g_z$ 的贡献是根据第一性原理计算的，不使用简化公式。仅使用重力正演建模所需的定律和定义。\n\n您将为验证实现以下内容：\n1.  计算半径为 $R$、密度差为 $\\Delta \\rho$ 的均匀球体的解析解 $g_z(h)$。\n2.  按照上述方法，用边长为 $\\Delta$ 的体素对球体进行离散化，计算基于体素的 $g_z^{\\mathrm{vox}}(h,\\Delta)$。\n3.  计算绝对误差 $E(h,\\Delta) = \\left| g_z^{\\mathrm{vox}}(h,\\Delta) - g_z(h) \\right|$。\n4.  以微伽（µGal）为单位报告 $E(h,\\Delta)$，其中 $1~\\mathrm{µGal} = 10^{-8}~\\mathrm{m/s^2}$。\n\n使用以下固定的物理参数，这些参数是真实且科学合理的：\n-   引力常数 $G = 6.67430 \\times 10^{-11}~\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$\n-   球体半径 $R = 1000~\\mathrm{m}$\n-   密度差 $\\Delta \\rho = 400~\\mathrm{kg/m^3}$\n\n观测点始终位于 $(0,0,h)$，球心位于原点。在一个覆盖球体包围立方体 $[-R,R] \\times [-R,R] \\times [-R,R]$ 的规则网格上构建体素中心，间距为 $\\Delta$，沿每个轴的中心位置为 $-R + \\Delta/2, -R + 3\\Delta/2, \\ldots, R - \\Delta/2$。当且仅当体素的中心位于球体内部时，才将其计入总和，即当 $x_i^2 + y_i^2 + z_i^2 \\le R^2$ 时。\n\n将所有误差 $E(h,\\Delta)$ 以微伽（µGal）为单位表示为实值浮点数。此问题不涉及角度，因此不需要角度单位。\n\n测试套件：\n计算并报告以下四种情况的 $E(h,\\Delta)$，这些情况旨在检验不同区域：\n-   情况 1（场内，中等粗糙度体素）：$\\Delta = 500~\\mathrm{m}$，$h = 500~\\mathrm{m}$。\n-   情况 2（边界，中等体素）：$\\Delta = 250~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n-   情况 3（远场，精细体素）：$\\Delta = 100~\\mathrm{m}$，$h = 5000~\\mathrm{m}$。\n-   情况 4（边界，非常粗糙的体素）：$\\Delta = 1000~\\mathrm{m}$，$h = 1000~\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述情况顺序排列的四个绝对误差 $[E(h,\\Delta)]$，格式为用方括号括起来的逗号分隔列表，例如“[e1,e2,e3,e4]”。每个条目都应是以微伽（µGal）为单位的浮点数。",
            "solution": "### 基于原理的解决方案设计\n\n该解决方案需要两个主要组成部分：球体解析引力异常的推导和使用基于体素模型的数值近似的实现。\n\n#### 1. $g_z(h)$ 的解析解\n球对称质量分布的引力场可以使用球壳定理来确定，这是对牛顿引力定律积分的直接结果。该定理与本问题相关的部分有两点：\n1.  球体对其外部一个质点所施加的引力，与将球体的全部质量集中于其中心时所施加的引力相同。\n2.  球壳对其内部一个质点所施加的引力为零。\n\n设球体半径为 $R$，均匀密度差为 $\\Delta \\rho$。总异常质量为 $M = \\Delta \\rho \\cdot V = \\Delta \\rho \\left( \\frac{4}{3}\\pi R^3 \\right)$。观测点位于 z 轴上高度为 $h$ 的位置，因此其坐标为 $(0, 0, h)$。\n\n情况 A：观测点在球体外（$h \\ge R$）\n根据球壳定理，该球体等效于一个位于原点的质量为 $M$ 的点质量。在 $(0, 0, h)$ 处的测试质量 $m_t$ 上受到的引力指向原点。加速度矢量为 $\\vec{g} = -\\frac{GM}{h^2} \\hat{k}$，其中 $\\hat{k}$ 是 $+z$ 方向的单位矢量。垂直分量为 $g_z = \\vec{g} \\cdot \\hat{k} = -\\frac{GM}{h^2}$。问题定义 $g_z$ 向下为正，因此我们取其向下分量的大小：\n$$ g_z(h) = \\frac{GM}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi R^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2} \\quad \\text{当 } h \\ge R $$\n\n情况 B：观测点在球体内（$h  R$）\n在距离中心 $h$ 处，外部质量壳层（从半径 $h$ 到 $R$）不产生净力。引力仅由半径为 $h$ 的内部球体产生。这个内部球体的质量是 $M_{\\text{inner}} = \\Delta \\rho \\left( \\frac{4}{3}\\pi h^3 \\right)$。将球壳定理的第一部分应用于这个内部质量，引力加速度为：\n$$ g_z(h) = \\frac{G M_{\\text{inner}}}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi h^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho h \\quad \\text{当 } h  R $$\n\n结合两种情况，解析解为：\n$$ g_z(h) = \\begin{cases} \\frac{4}{3}\\pi G \\Delta \\rho h  \\text{若 } h  R \\\\ \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2}  \\text{若 } h \\ge R \\end{cases} $$\n\n#### 2. 基于体素的数值解 $g_z^{\\mathrm{vox}}(h, \\Delta)$\n球体被离散化为一组立方体素。每个体素被视为位于其中心的点质量。\n设一个体素的边长为 $\\Delta$。其体积为 $V_{\\mathrm{vox}} = \\Delta^3$，质量为 $m_{\\mathrm{vox}} = \\Delta \\rho \\Delta^3$。\n考虑一个中心位置为 $\\vec{r}_i = (x_i, y_i, z_i)$ 的单个体素。观测点位于 $\\vec{r}_{\\mathrm{obs}} = (0, 0, h)$。从体素到观测点的位移矢量是 $\\vec{d} = \\vec{r}_{\\mathrm{obs}} - \\vec{r}_i = (-x_i, -y_i, h-z_i)$。距离是 $d = |\\vec{d}| = \\sqrt{x_i^2 + y_i^2 + (h-z_i)^2}$。\n\n根据牛顿万有引力定律，该体素对观测点处的测试质量 $m_t$ 施加的引力是吸引力，即从 $\\vec{r}_{\\mathrm{obs}}$ 指向 $\\vec{r}_i$。力矢量为：\n$$ \\vec{F}_i = - \\frac{G m_{\\mathrm{vox}} m_t}{d^2} \\hat{d} = - \\frac{G m_{\\mathrm{vox}} m_t}{d^3} \\vec{d} = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (-\\vec{d}) = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (x_i, y_i, z_i-h) $$\n该体素的加速度贡献为 $\\vec{g}_i = \\vec{F}_i / m_t = \\frac{G m_{\\mathrm{vox}}}{d^3} (x_i, y_i, z_i-h)$。\n该加速度的垂直（$z$）分量是 $g_{z,i} = \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3}$。\n根据问题的符号约定（向下为正），我们寻求 $-z$ 方向上的加速度分量。这即是 $-g_{z,i}$：\n$$ g_{z,i}^{\\text{downward}} = - \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3} = \\frac{G m_{\\mathrm{vox}} (h - z_i)}{(x_i^2 + y_i^2 + (h-z_i)^2)^{3/2}} $$\n基于体素模型的总垂直重力异常是所有中心 $(x_i, y_i, z_i)$ 满足包含条件 $x_i^2 + y_i^2 + z_i^2 \\le R^2$ 的体素贡献之和：\n$$ g_z^{\\mathrm{vox}}(h, \\Delta) = \\sum_{i,j,k \\text{ s.t. } x_{ijk}^2 + y_{ijk}^2 + z_{ijk}^2 \\le R^2} \\frac{G (\\Delta\\rho \\Delta^3) (h - z_{ijk})}{\\left( x_{ijk}^2 + y_{ijk}^2 + (h-z_{ijk})^2 \\right)^{3/2}} $$\n体素中心坐标 $(x_{ijk}, y_{ijk}, z_{ijk})$ 在指定的网格上生成。对于一个轴，坐标为 $c_n = -R + (n+0.5)\\Delta$，其中 $n \\in \\{0, 1, ..., N-1\\}$ 且 $N = 2R/\\Delta$。\n\n#### 3. 误差计算\n绝对误差 $E(h, \\Delta)$ 以国际单位制（$\\mathrm{m/s^2}$）计算，然后转换为微伽（µGal）。\n$$ E(h, \\Delta) [\\mathrm{m/s^2}] = \\left| g_z^{\\mathrm{vox}}(h, \\Delta) - g_z(h) \\right| $$\n$$ E(h, \\Delta) [\\mathrm{µGal}] = E(h, \\Delta) [\\mathrm{m/s^2}] \\times 10^8 $$\n\n该算法将遍历四个测试用例，对每个用例执行这些计算，并以指定格式报告最终误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between analytic and voxel-based gravity models\n    for a homogeneous sphere for a suite of test cases.\n    \"\"\"\n    # Define physical constants and model parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    R = 1000.0  # m\n    DELTA_RHO = 400.0  # kg/m^3\n    \n    # Unit conversion factor from m/s^2 to microgal\n    M_S2_TO_UGAL = 1e8\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_m, h_m)\n    test_cases = [\n        (500.0, 500.0),    # Case 1\n        (250.0, 1000.0),   # Case 2\n        (100.0, 5000.0),   # Case 3\n        (1000.0, 1000.0)   # Case 4\n    ]\n\n    results = []\n    for delta, h in test_cases:\n        # --- 1. Compute the analytic gravity anomaly g_z(h) ---\n        if h  R:\n            # Inside the sphere: g_z = (4/3) * pi * G * delta_rho * h\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * h\n        else: # h >= R\n            # Outside or on the surface of the sphere: g_z = G * M / h^2\n            # M = delta_rho * (4/3) * pi * R^3\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * (R**3 / h**2)\n\n        # --- 2. Compute the voxel-based gravity anomaly g_z^vox(h, delta) ---\n        \n        # Number of voxels along one dimension of the bounding box\n        # Per problem spec, 2R/delta is an integer for all test cases\n        N = int(2 * R / delta)\n        \n        # Generate 1D array of voxel center coordinates for one axis\n        coords_1d = -R + (np.arange(N) + 0.5) * delta\n        \n        # Create 3D grid of voxel center coordinates (x, y, z)\n        x_grid, y_grid, z_grid = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n        # Calculate the squared distance of each voxel center from the origin\n        dist_sq_from_origin = x_grid**2 + y_grid**2 + z_grid**2\n        \n        # Create a boolean mask for voxels whose centers are inside the sphere\n        inside_sphere_mask = dist_sq_from_origin = R**2\n\n        # Filter the coordinates to get only those inside the sphere\n        x_inside = x_grid[inside_sphere_mask]\n        y_inside = y_grid[inside_sphere_mask]\n        z_inside = z_grid[inside_sphere_mask]\n        \n        # If no voxel centers are inside the sphere (e.g., very coarse grid),\n        # the voxel contribution is zero.\n        if x_inside.size == 0:\n            g_z_vox = 0.0\n        else:\n            # Mass of a single voxel\n            m_vox = DELTA_RHO * delta**3\n    \n            # Calculate the squared distance from each included voxel to the observation point (0, 0, h)\n            dist_sq_from_obs = x_inside**2 + y_inside**2 + (h - z_inside)**2\n            dist_from_obs = np.sqrt(dist_sq_from_obs)\n\n            # Calculate the downward vertical gravity contribution from each voxel\n            # g_z_i = G * m_vox * (h - z_i) / d^3\n            # Note: dist_from_obs is guaranteed to be non-zero as per analysis in the thought process.\n            g_z_contributions = G * m_vox * (h - z_inside) / (dist_from_obs**3)\n    \n            # Sum the contributions from all voxels\n            g_z_vox = np.sum(g_z_contributions)\n\n        # --- 3. Compute the absolute error E(h, delta) ---\n        error_si = np.abs(g_z_vox - g_z_analytic)\n        \n        # Convert error to microgal (µGal)\n        error_ugal = error_si * M_S2_TO_UGAL\n        \n        results.append(error_ugal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的地质环境很少由单一、简单的物体构成，其复杂性是常态。线性叠加原理是我们应对这种复杂性的核心工具，它允许我们通过简单地将单个异常源的贡献相加来计算总重力场。这项练习  不仅验证了这一基本物理原理，还揭示了计算科学中的一个关键挑战——浮点数运算的精度限制，并探索了如何通过特定的求和顺序与算法来减小这种误差。",
            "id": "3597400",
            "problem": "设计并实现一个完整的、可运行的程序，该程序构建一个数值测试工具，用于验证重力异常的线性叠加原理并量化浮点数求和误差。严格遵循第一性原理：从牛顿万有引力定律和球壳定理出发，实现由多个均匀密度球体引起的引力加速度的垂直分量，然后构建测试，以 (i) 在数值上确认线性，以及 (ii) 测量不同求和顺序下的累积误差。\n\n使用以下基本原理：\n-   牛顿万有引力定律：位于位置 $\\mathbf{r}_\\mathrm{c}$ 的质量为 $M$ 的点质量，在位置 $\\mathbf{r}_0$ 处产生的加速度为 $\\mathbf{g}(\\mathbf{r}_0) = G M \\dfrac{\\mathbf{r}_\\mathrm{c}-\\mathbf{r}_0}{\\lVert \\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0 \\rVert^3}$，其中 $G$ 是引力常数。\n-   球壳定理：对于半径为 $a$、质量为 $M$ 的均匀实心球体，其外部场（$R \\ge a$）与位于中心的点质量产生的场相同，而其内部场（$R  a$）的加速度为 $\\mathbf{g} = G M \\dfrac{\\mathbf{r}_\\mathrm{c}-\\mathbf{r}_0}{a^3}$。\n-   均匀球体的质量：$M = \\dfrac{4}{3}\\pi a^3 \\rho$，其中 $\\rho$ 是密度（在此解释为密度差）。\n\n采用右手坐标系，$x$ 指向东，$y$ 指向北，$z$ 轴正方向朝上。按照地球物理学实践中的惯例，重力的垂直分量以向下为正方向报告。根据上述基本原理，由一个中心位于 $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c},y_\\mathrm{c},z_\\mathrm{c})$、半径为 $a$、密度为 $\\rho$ 的均匀球体在点 $\\mathbf{r}_0 = (x_0,y_0,z_0)$ 处产生的垂直分量为：\n-   定义 $\\Delta x = x_0 - x_\\mathrm{c}$、$\\Delta y = y_0 - y_\\mathrm{c}$、$\\Delta z = z_0 - z_\\mathrm{c}$ 以及 $R = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$；\n-   定义 $M = \\dfrac{4}{3}\\pi a^3 \\rho$；\n-   定义向下为正的垂直分量为 $g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$\n\n使用国际单位制（SI）。将引力常数设置为 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。所有长度单位必须是米（$\\mathrm{m}$），密度单位是千克/立方米（$\\mathrm{kg/m^3}$），程序必须以微伽（microgal）为单位报告重力差，其中 $1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$。\n\n对每个球体的贡献 $\\{g_{z,i}^\\downarrow\\}_{i=1}^N$ 实现三种求和策略：\n-   朴素前向求和（从左到右）。\n-   按绝对值升序和降序重新排序后的朴素求和。\n-   使用Kahan算法的补偿求和。\n\n对于下述每个测试案例，计算：\n-   $d_\\mathrm{order}$：按 $|g_{z,i}^\\downarrow|$ 升序和降序计算的朴素和之间的绝对差，以微伽为单位；\n-   $d_\\mathrm{naive\\_kahan}$：朴素前向和（按原始物体顺序）与Kahan补偿和之间的绝对差，以微伽为单位；\n-   一个线性检查布尔值，其计算方法是：将物体集合划分为两个指定的组 $A$ 和 $B$，对每个组内部使用Kahan补偿求和计算 $S_A$ 和 $S_B$，然后测试是否满足 $| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$，其中 $S_{\\mathrm{all}}$ 是对所有物体进行的Kahan补偿和，$\\tau = 0.1\\,\\mathrm{microgal}$。\n\n测试套件和参数。对于所有案例，观测点为 $\\mathbf{r}_0 = (0,0,0)\\,\\mathrm{m}$，程序必须计算并报告上述定义的量。每个球体由一个元组 $(x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c}, a, \\rho)$ 指定，单位为 $(\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{kg/m^3})$。负的 $\\rho$ 值表示负密度差。\n\n-   案例 1（均衡、不重叠、中等对比度）：\n    -   物体（八个球体）：\n        -   $(+1500, 0, -1500, 300, +350)$,\n        -   $(-1500, 0, -1500, 300, +350)$,\n        -   $(0, +1500, -1500, 300, +350)$,\n        -   $(0, -1500, -1500, 300, +350)$,\n        -   $(+1200, +1200, -2200, 250, +200)$,\n        -   $(-1200, +1200, -2200, 250, +200)$,\n        -   $(+1200, -1200, -2200, 250, +200)$,\n        -   $(-1200, -1200, -2200, 250, +200)$.\n    -   线性检查的分区：组 $A$ 是所列出的前四个球体；组 $B$ 是后四个球体。\n\n-   案例 2（强抵消；交替对比度）：\n    -   物体：对于 $k \\in \\{1,2,\\dots,10\\}$，在同一深度定义两个球体，\n        -   $(+500k, 0, -2000, 400, +400)$,\n        -   $(-500k, 0, -2000, 400, -400)$.\n    总共产生 20 个球体。\n    -   分区：组 $A$ 是所有 $\\rho  0$ 的球体，组 $B$ 是所有 $\\rho  0$ 的球体。\n\n-   案例 3（极端动态范围；一个占主导地位的近源加上许多弱远源）：\n    -   物体：\n        -   一个占主导地位的球体：$(0, 0, -1200, 800, +500)$。\n        -   两个具有交替符号对比度的小球体环：\n            -   环 1：半径 $R_1 = 10000$，深度 $z = -8000$，球体半径 $a = 50$，密度大小 $|\\rho| = 100$，角度 $\\theta_k = k \\times 15^\\circ$，其中 $k \\in \\{0,1,\\dots,23\\}$。对于每个 $k$，在 $(R_1 \\cos\\theta_k, R_1 \\sin\\theta_k, -8000, 50, \\rho_k)$ 处放置一个球体，其中偶数 $k$ 的 $\\rho_k = (+100)$，奇数 $k$ 的 $\\rho_k = (-100)$。\n            -   环 2：半径 $R_2 = 15000$，深度 $z = -10000$，球体半径 $a = 50$，密度大小 $|\\rho| = 100$，角度 $\\phi_k = k \\times 15^\\circ$，其中 $k \\in \\{0,1,\\dots,23\\}$。对于每个 $k$，在 $(R_2 \\cos\\phi_k, R_2 \\sin\\phi_k, -10000, 50, \\rho'_k)$ 处放置一个球体，其中偶数 $k$ 的 $\\rho'_k = (-100)$，奇数 $k$ 的 $\\rho'_k = (+100)$。\n    -   分区：组 $A$ 是单个占主导地位的球体；组 $B$ 是所有小环上的球体。\n\n计算要求：\n-   在 SI 单位制中使用 $G = 6.67430 \\times 10^{-11}$。\n-   所有计算均使用双精度浮点数。\n-   对于每个案例中的三个度量，以微伽表示差异。线性检查必须精确使用 $\\tau = 0.1$ 微伽的容差。\n-   程序必须在没有输入和外部文件的情况下运行，并生成单行输出，包含一个由逗号分隔的列表，列表包含三个条目（每个案例一个），每个条目本身是包含三个值 $[d_\\mathrm{order}, d_\\mathrm{naive\\_kahan}, \\text{linearity\\_ok}]$ 的列表。例如，一个语法正确的输出形式为 $[[x_1,y_1,b_1],[x_2,y_2,b_2],[x_3,y_3,b_3]]$，其中三个 $b_i$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。所有 $x_i$ 和 $y_i$ 必须是表示微伽值的浮点数。",
            "solution": "该问题要求在Python中设计并实现一个数值测试工具，以验证重力异常的线性叠加原理并量化浮点数求和误差。这涉及到对多个球体产生的垂直引力加速度进行建模，实现多种求和算法，并运行一套已定义的测试案例。该解决方案是按照要求从第一性原理开始开发的。\n\n### 1. 引力模型公式\n\n该模型的基础是牛顿万有引力定律和球壳定理。我们关心的是由一组均匀球体在观测点 $\\mathbf{r}_0 = (x_0, y_0, z_0)$ 处产生的引力加速度的垂直分量 $g_z^\\downarrow$。坐标系定义为 $z$ 轴正方向朝上。遵循地球物理学惯例，我们定义 $g_z^\\downarrow$ 向下为正。\n\n对于一个半径为 $a$、密度差为 $\\rho$、中心位于 $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c})$ 的球体，其质量由 $M = \\frac{4}{3}\\pi a^3 \\rho$ 给出。从球体中心到观测点的矢量为 $\\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} = (\\Delta x, \\Delta y, \\Delta z)$。距离为 $R = \\lVert \\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} \\rVert$。\n\n引力加速度矢量 $\\mathbf{g}$，对于外部点（$R \\ge a$）由 $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{R^3}$ 给出，对于内部点（$R  a$）由 $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{a^3}$ 给出。对于外部情况，该矢量的垂直（$z$）分量为 $g_z = G M \\frac{z_\\mathrm{c} - z_0}{R^3} = -G M \\frac{\\Delta z}{R^3}$。因此，向下为正的分量为 $g_z^\\downarrow = -g_z = G M \\frac{\\Delta z}{R^3}$。对内部情况进行类似推导，得到 $g_z^\\downarrow = G M \\frac{\\Delta z}{a^3}$。这些表达式被合并为一个单一的函数：\n$$g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$$\n这个公式在一个名为 `calculate_gz_down` 的函数中实现，该函数接受球体的属性和观测点坐标，返回以 SI 单位（$\\mathrm{m/s^2}$）表示的垂直重力异常。引力常数设置为 $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$。\n\n### 2. 求和算法与误差量化\n\n总重力异常是所有球体贡献的总和，$g_{z, \\mathrm{total}}^\\downarrow = \\sum_{i=1}^N g_{z,i}^\\downarrow$。由于浮点数运算的精度有限，这个求和的结果可能取决于运算的顺序。该问题要求实现并比较三种求和策略。\n\n1.  **朴素求和**：这是对单个重力值 $\\{g_{z,i}^\\downarrow\\}$ 的直接从左到右求和。这为三种不同的排序方式实现：\n    a.  球体定义的原始顺序（对初始列表使用 `naive_sum`）。\n    b.  按绝对值升序，即从最小的 $|g_{z,i}^\\downarrow|$ 加到最大的。\n    c.  按绝对值降序。\n    升序和与降序和之间的差值 $d_\\mathrm{order} = |S_{\\mathrm{asc}} - S_{\\mathrm{desc}}|$，量化了朴素求和的顺序依赖性。\n\n2.  **Kahan补偿求和**：这是一种著名的算法，能显著减少浮点数求和中的数值误差。它维护一个运行中的补偿变量 $c$，用以累积每次加法中丢失的低位比特。对一个值序列 $v_i$ 求和的算法如下：\n    - 初始化和 $s = 0$ 及补偿 $c = 0$。\n    - 对于每个值 $v_i$：\n        - $y = v_i - c$\n        - $t = s + y$\n        - $c = (t - s) - y$\n        - $s = t$\n    - 最终结果是 $s$。\n    这在函数 `kahan_sum` 中实现。朴素前向和与Kahan和之间的差值 $d_\\mathrm{naive\\_kahan} = |S_{\\mathrm{forward}} - S_{\\mathrm{Kahan}}|$，衡量了最简单的求和方法相对于更精确方法的误差。\n\n### 3. 线性验证\n\n叠加原理指出，来自多个源的总场是每个独立源场的总和。在我们的情境中，这意味着如果所有物体的集合被划分为两个不相交的子集 $A$ 和 $B$，那么总异常应等于每个子集异常的和：$S_{\\mathrm{all}} = S_A + S_B$。虽然这在解析上是成立的，但浮点数误差可能会导致偏差。\n\n线性检查旨在以数值方式对此进行测试。使用高精度的Kahan求和进行所有计算，我们计算所有物体的总和 $S_{\\mathrm{all}}$，以及指定组 A 和 B 的和 $S_A$ 和 $S_B$。如果绝对差在指定的容差 $\\tau = 0.1\\,\\mathrm{microgal}$ 之内，则检查通过：\n$$| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$$\n报告一个布尔结果 `linearity_ok`。该测试主要验证分区和求和逻辑的正确性，因为Kahan求和预计足够精确，能使该恒等式以高精度成立。\n\n### 4. 实现结构\n\n一个主函数 `solve` 负责协调整个过程。它定义了三个测试案例的参数，包括为案例 2 和 3 以编程方式生成球体位置。对每个案例，调用一个 `process_case` 函数，该函数执行以下操作：\n1.  在观测点 $\\mathbf{r}_0 = (0,0,0)$ 处计算所有球体各自的 $g_{z,i}^\\downarrow$ 值。\n2.  使用各种方法（不同排序下的 `naive_sum`，`kahan_sum`）计算总和。\n3.  计算所需的度量：$d_\\mathrm{order}$ 和 $d_\\mathrm{naive\\_kahan}$。\n4.  根据指定的分区执行线性检查。\n5.  通过乘以 $10^8$ 将最终的差值从 SI 单位转换为微伽（$1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$）。\n6.  以列表形式返回三个结果：$[d_\\mathrm{order}, d_\\mathrm{naive\\_kahan}, \\mathrm{linearity\\_ok}]$。\n\n最后，`solve` 函数收集所有测试案例的结果，并以指定的单行格式打印它们。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test harness for gravity anomaly calculations.\n    \"\"\"\n\n    # --- Constants and Unit Conversions ---\n    G = 6.67430e-11  # Gravitational constant in SI units (m^3 kg^-1 s^-2)\n    MKS_TO_MICROGAL = 1e8  # Conversion factor from m/s^2 to microgal\n    LINEARITY_TOLERANCE_MICROGAL = 0.1  # Tolerance for linearity check\n\n    # --- Core Calculation and Summation Functions ---\n\n    def calculate_gz_down(sphere, r0):\n        \"\"\"\n        Calculates the downward-positive vertical gravity component from a single sphere.\n        \n        Args:\n            sphere (tuple): (xc, yc, zc, a, rho) for the sphere.\n            r0 (tuple): (x0, y0, z0) for the observation point.\n\n        Returns:\n            float: The gravity anomaly gz_down in m/s^2.\n        \"\"\"\n        xc, yc, zc, a, rho = sphere\n        x0, y0, z0 = r0\n        \n        delta_x = x0 - xc\n        delta_y = y0 - yc\n        delta_z = z0 - zc\n        \n        R2 = delta_x**2 + delta_y**2 + delta_z**2\n        \n        if R2 == 0:\n            # Observation point is at the center of the sphere.\n            # Gravitational acceleration is zero by symmetry.\n            return 0.0\n\n        R = math.sqrt(R2)\n        mass = (4.0 / 3.0) * np.pi * (a**3) * rho\n        \n        if R >= a:\n            # External field\n            factor = R**(-3)\n        else:\n            # Internal field\n            factor = a**(-3)\n            \n        gz_down = G * mass * delta_z * factor\n        return gz_down\n\n    def naive_sum(values):\n        \"\"\"Naive left-to-right summation.\"\"\"\n        s = 0.0\n        for val in values:\n            s += val\n        return s\n\n    def kahan_sum(values):\n        \"\"\"Compensated summation using Kahan's algorithm.\"\"\"\n        s = 0.0\n        c = 0.0  # A running compensation for lost low-order bits.\n        for val in values:\n            y = val - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    def process_case(spheres, partition):\n        \"\"\"\n        Processes a single test case to compute the required metrics.\n        \"\"\"\n        r0 = (0.0, 0.0, 0.0)\n        \n        # Step 1: Calculate individual gravity contributions in SI units (m/s^2)\n        gz_values = [calculate_gz_down(s, r0) for s in spheres]\n        \n        # Step 2: Perform Summations\n        s_naive_forward = naive_sum(gz_values)\n        \n        gz_sorted_asc = sorted(gz_values, key=abs)\n        s_asc = naive_sum(gz_sorted_asc)\n        \n        gz_sorted_desc = sorted(gz_values, key=abs, reverse=True)\n        s_desc = naive_sum(gz_sorted_desc)\n        \n        s_kahan_all = kahan_sum(gz_values)\n        \n        # Step 3: Calculate difference metrics\n        d_order = abs(s_asc - s_desc) * MKS_TO_MICROGAL\n        d_naive_kahan = abs(s_naive_forward - s_kahan_all) * MKS_TO_MICROGAL\n        \n        # Step 4: Linearity Check\n        group_A_indices, group_B_indices = partition\n        gz_group_A = [gz_values[i] for i in group_A_indices]\n        gz_group_B = [gz_values[i] for i in group_B_indices]\n        \n        s_kahan_A = kahan_sum(gz_group_A)\n        s_kahan_B = kahan_sum(gz_group_B)\n        \n        linearity_error = abs((s_kahan_A + s_kahan_B) - s_kahan_all) * MKS_TO_MICROGAL\n        linearity_ok = linearity_error = LINEARITY_TOLERANCE_MICROGAL\n        \n        return [d_order, d_naive_kahan, linearity_ok]\n    \n    # --- Define Test Cases ---\n\n    # Case 1: Balanced, non-overlapping, moderate contrasts\n    spheres_case1 = [\n        (1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (-1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (0.0, 1500.0, -1500.0, 300.0, 350.0),\n        (0.0, -1500.0, -1500.0, 300.0, 350.0),\n        (1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (1200.0, -1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, -1200.0, -2200.0, 250.0, 200.0),\n    ]\n    partition_case1 = (range(4), range(4, 8))\n\n    # Case 2: Strong cancellation; alternating contrasts\n    spheres_case2 = []\n    group_A_indices_c2, group_B_indices_c2 = [], []\n    for k in range(1, 11):\n        spheres_case2.append((500.0 * k, 0.0, -2000.0, 400.0, 400.0))\n        group_A_indices_c2.append(len(spheres_case2) - 1)\n        spheres_case2.append((-500.0 * k, 0.0, -2000.0, 400.0, -400.0))\n        group_B_indices_c2.append(len(spheres_case2) - 1)\n    partition_case2 = (group_A_indices_c2, group_B_indices_c2)\n\n    # Case 3: Extreme dynamic range\n    spheres_case3 = []\n    # Dominant sphere\n    spheres_case3.append((0.0, 0.0, -1200.0, 800.0, 500.0))\n    # Ring 1\n    R1, z1, a1, rho_mag1 = 10000.0, -8000.0, 50.0, 100.0\n    for k in range(24):\n        theta = k * np.pi / 12.0\n        xc, yc = R1 * np.cos(theta), R1 * np.sin(theta)\n        rho = rho_mag1 if k % 2 == 0 else -rho_mag1\n        spheres_case3.append((xc, yc, z1, a1, rho))\n    # Ring 2\n    R2, z2, a2, rho_mag2 = 15000.0, -10000.0, 50.0, 100.0\n    for k in range(24):\n        phi = k * np.pi / 12.0\n        xc, yc = R2 * np.cos(phi), R2 * np.sin(phi)\n        rho = -rho_mag2 if k % 2 == 0 else rho_mag2\n        spheres_case3.append((xc, yc, z2, a2, rho))\n    partition_case3 = ([0], range(1, 49))\n\n    test_cases = [\n        (spheres_case1, partition_case1),\n        (spheres_case2, partition_case2),\n        (spheres_case3, partition_case3),\n    ]\n\n    # --- Run Tests and Collect Results ---\n    results = [process_case(spheres, partition) for spheres, partition in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算出的重力场本身不是终点，而是需要进一步分析的数据集。向上延拓是一种基础的场变换技术，它通过模拟重力场在更高海拔平面的形态来对其进行滤波，能有效压制短波长噪声并凸显大规模的深部构造。在此项实践  中，您将从控制位场的拉普拉斯方程出发，推导向上延拓算子，并在傅里叶域中实现它，从而揭示位场的空间衰减特性与其频谱内容之间的内在联系。",
            "id": "3597422",
            "problem": "当二维表面重力异常场由完全位于观测平面下方的地下质量分布引起时，该场在观测平面上方是一个调和函数。从牛顿引力定律以及引力势在无源区域满足拉普拉斯方程的性质出发，推导重力异常场在水平波数域中的向上延拓算子。然后，实现该算子，并量化向上延拓如何衰减不同的水平波长。不要使用任何预先推导的向上延拓公式；相反，应从控制方程推导它。\n\n假设以下基本依据：\n-   牛顿引力定律：由质量密度 $\\rho(\\mathbf{r}')$ 产生的引力势 $\\Phi(\\mathbf{r})$ 满足泊松方程 $\\nabla^2 \\Phi(\\mathbf{r}) = 4 \\pi G \\rho(\\mathbf{r})$，其中 $G$ 是引力常数，$\\mathbf{r}$ 是位置。\n-   在无源区域，引力势满足拉普拉斯方程 $\\nabla^2 \\Phi(\\mathbf{r}) = 0$。\n-   在水平面上测量的重力异常与引力势的空间导数有关，并继承了在该平面上方的调和性质。\n\n根据这些原理，证明场的每个水平傅里叶模式随高度衰减，并推导其对水平波数大小的函数依赖关系。\n\n算法任务：\n1.  在一个矩形网格上构建一个合成的二维重力异常场 $g(x,y)$，该场在 $x$ 方向上是周期性的，并且不依赖于 $y$。该场是多个余弦分量的和，其波长 $\\lambda \\in \\{2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}, 10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}\\}$，每个分量的振幅均为单位振幅。网格参数如下：\n    -   $x$ 方向的采样点数：$N_x = 320$。\n    -   $y$ 方向的采样点数：$N_y = 128$。\n    -   $x$ 方向的采样间隔：$\\Delta x = 500\\,\\mathrm{m}$。\n    -   $y$ 方向的采样间隔：$\\Delta y = 500\\,\\mathrm{m}$。\n    因此，域长度为 $L_x = N_x \\Delta x = 160000\\,\\mathrm{m}$ 和 $L_y = N_y \\Delta y = 64000\\,\\mathrm{m}$。使用余弦分量 $\\cos\\left(2\\pi x / \\lambda\\right)$。\n2.  计算 $g(x,y)$ 的二维快速傅里叶变换 (FFT) $G(\\mathbf{k})$，其中 $\\mathbf{k} = (k_x, k_y)$ 且 $k_x = 2\\pi f_x$，$k_y = 2\\pi f_y$，而 $f_x$ 和 $f_y$ 是来自离散傅里叶变换频率网格的空间频率，单位为周/米。\n3.  基于拉普拉斯方程对每个傅里叶模式的解，推导并实现在波数域中的向上延拓算子。将该算子应用于 $G(\\mathbf{k})$，以获得在原始观测平面上方高度 $h$ 处的频谱。\n4.  对于指定的测试高度和目标波长，计算每个波长的衰减因子，该因子为向上延拓前后相应水平波数处谱振幅的比值。对于目标波长 $\\lambda$，确定相应的 $k_x$ 仓索引 $m = L_x / \\lambda$（一个整数），并使用在 $(k_x = +2\\pi m / L_x, k_y = 0)$ 和 $(k_x = -2\\pi m / L_x, k_y = 0)$ 处的谱系数对。一个波长的衰减因子定义为向上延拓后这两个系数的模之和与向上延拓前这两个系数的模之和的比值。该比值为无量纲。\n5.  所有高度均以米为单位。最终的衰减值为无量纲浮点数。\n\n测试套件：\n-   情况 A：高度 $h = 2000\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n-   情况 B：高度 $h = 500\\,\\mathrm{m}$，波长 $\\lambda = [2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}]$。\n-   情况 C：高度 $h = 0\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n-   情况 D：高度 $h = 20000\\,\\mathrm{m}$，波长 $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是该用例中各波长衰减因子的浮点数列表。例如，输出必须类似于：“[[a1,a2,a3],[b1,b2,b3],[c1,c2,c3],[d1,d2,d3]]”。",
            "solution": "### 向上延拓算子的推导\n\n推导从牛顿引力定律的基本原理开始。\n\n1.  **控制方程**：问题指出，源于地下质量分布的表面重力异常场，在源上方的无源区域内是一个调和函数。设重力异常场为 $g(x, y, z)$。观测平面位于 $z=0$，向上方向为正 $z$ 方向。在无源的半空间 $z \\ge 0$ 中，$g$ 满足拉普拉斯方程：\n    $$ \\nabla^2 g(x, y, z) = \\frac{\\partial^2 g}{\\partial x^2} + \\frac{\\partial^2 g}{\\partial y^2} + \\frac{\\partial^2 g}{\\partial z^2} = 0 $$\n\n2.  **傅里叶变换方法**：我们可以通过对水平空间变量 $x$ 和 $y$ 应用二维傅里叶变换来求解这个线性偏微分方程。设 $\\hat{g}(k_x, k_y, z)$ 是 $g(x, y, z)$ 的傅里叶变换：\n    $$ \\hat{g}(k_x, k_y, z) = \\mathcal{F}_{xy}[g(x, y, z)] = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} g(x, y, z) e^{-i(k_x x + k_y y)} dx dy $$\n    其中 $k_x$ 和 $k_y$ 分别是 $x$ 和 $y$ 方向的角波数。傅里叶变换的性质表明，对空间变量的求导在傅里叶域中等效于乘以相应的虚波数：\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial x^2}\\right] = (i k_x)^2 \\hat{g} = -k_x^2 \\hat{g} $$\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial y^2}\\right] = (i k_y)^2 \\hat{g} = -k_y^2 \\hat{g} $$\n    对 $z$ 的导数不受水平变换的影响。将傅里叶变换应用于拉普拉斯方程，得到：\n    $$ -k_x^2 \\hat{g}(k_x, k_y, z) - k_y^2 \\hat{g}(k_x, k_y, z) + \\frac{\\partial^2 \\hat{g}(k_x, k_y, z)}{\\partial z^2} = 0 $$\n\n3.  **常微分方程**：这将偏微分方程简化为对每个波数对 $(k_x, k_y)$ 关于变量 $z$ 的常微分方程 (ODE)：\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = (k_x^2 + k_y^2) \\hat{g} $$\n    令 $k_r = \\sqrt{k_x^2 + k_y^2}$ 为水平波数矢量的大小。该 ODE 变为：\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = k_r^2 \\hat{g} $$\n\n4.  **通解**：这个二阶线性常微分方程的通解是：\n    $$ \\hat{g}(k_x, k_y, z) = A(k_x, k_y) e^{k_r z} + B(k_x, k_y) e^{-k_r z} $$\n    其中 $A$ 和 $B$ 是依赖于波数的系数，由边界条件确定。\n\n5.  **边界条件**：\n    a.  当远离源区时，引力场必须保持有限并衰减至零。因此，我们要求当 $z \\to \\infty$ 时，$g(x, y, z)$ 是有界的。在波数域中，这意味着 $\\hat{g}(k_x, k_y, z)$ 也必须是有界的。由于 $k_r = \\sqrt{k_x^2 + k_y^2} \\ge 0$，对于任何 $k_r  0$，项 $e^{k_r z}$ 会随 $z$ 无界增长。为了满足物理边界条件，其系数必须为零：$A(k_x, k_y) = 0$。这样剩下：\n    $$ \\hat{g}(k_x, k_y, z) = B(k_x, k_y) e^{-k_r z} $$\n    b.  在观测平面 $z=0$ 处，场为 $g(x, y, 0)$，其傅里叶变换为 $\\hat{g}(k_x, k_y, 0)$。我们把这个已知的谱记为 $G(k_x, k_y)$。在我们的解中令 $z=0$：\n    $$ \\hat{g}(k_x, k_y, 0) = B(k_x, k_y) e^0 = B(k_x, k_y) $$\n    因此，系数 $B$ 就是地表重力异常的傅里叶谱 $G(k_x, k_y)$。\n\n6.  **向上延拓算子**：将 $B$ 代入解中，我们得到在任意高度 $h > 0$ 处的场谱：\n    $$ \\hat{g}(k_x, k_y, h) \\equiv G_h(k_x, k_y) = G(k_x, k_y) e^{-k_r h} = G(k_x, k_y) e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n    将 $z=0$ 处的谱变换为 $z=h$ 处的谱的算子，即为波数域中的**向上延拓算子**：\n    $$ U(k_x, k_y, h) = e^{-k_r h} = e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n\n7.  **解释与衰减**：算子 $U$ 是一个实值指数函数，依赖于高度 $h$ 和径向波数 $k_r$。由于 $h>0$ 且 $k_r \\ge 0$，算子的值总是在 $0$ 和 $1$ 之间。它起到一个低通滤波器的作用。对于高波数（短波长，对应小而尖锐的特征），$k_r$ 很大，指数项 $e^{-k_r h}$ 变得非常小，从而强烈衰减这些分量。对于低波数（长波长，对应大而宽广的特征），$k_r$ 很小，$e^{-k_r h}$ 接近于 $1$，因此这些分量只受到微弱衰减。给定波数的衰减因子是延拓前后振幅的比值：\n    $$ \\text{衰减因子} = \\frac{|G_h(k_x, k_y)|}{|G(k_x, ky)|} = \\frac{|G(k_x, k_y) e^{-k_r h}|}{|G(k_x, k_y)|} = |e^{-k_r h}| = e^{-k_r h} $$\n\n### 算法实现\n\n算法任务涉及对此原理进行数值实现。\n\n1.  **场合成**：在一个大小为 $N_x \\times N_y$、采样间隔为 $\\Delta x, \\Delta y$ 的网格上合成一个二维重力异常场 $g(x,y)$。该场是指定波长 $\\lambda$ 的余弦函数的和，在 $x$ 方向上是周期的，在 $y$ 方向上是恒定的。\n    $$ g(x,y) = \\sum_{\\lambda} \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right) $$\n\n2.  **FFT**：使用 `numpy.fft.fft2` 计算该场 $G(k_x, k_y)$ 的二维快速傅里叶变换 (FFT)。\n\n3.  **算子构建**：从 `numpy.fft.fftfreq` 提供的离散频率构建相应的二维角波数网格 $k_x$ 和 $k_y$。由此计算出径向波数网格 $k_r = \\sqrt{k_x^2 + k_y^2}$。然后为给定高度 $h$ 构建向上延拓算子 $U(k_x, k_y, h) = e^{-k_r h}$。\n\n4.  **应用与分析**：通过逐元素相乘将算子应用于谱 $G(k_x, k_y)$，得到向上延拓后的谱 $G_h(k_x, k_y) = G(k_x, k_y) \\cdot U(k_x, k_y, h)$。\n\n5.  **衰减计算**：对于每个目标波长 $\\lambda$，找到相应的离散波数索引 $m = L_x / \\lambda$。由于输入信号是余弦的实数和，其谱是共轭对称的，能量集中在正负频率对上。衰减因子按照问题中的定义计算：延拓后与延拓前在 $(k_x(\\pm m), k_y(0))$ 处的谱系数模之和的比值。\n    $$ \\text{衰减}(\\lambda) = \\frac{|\\hat{g}_h(m,0)| + |\\hat{g}_h(N_x-m,0)|}{|\\hat{g}(m,0)| + |\\hat{g}(N_x-m,0)|} $$\n    对所有测试用例重复此过程。对于 $h=0$ 的情况，算子为单位矩阵，衰减因子为 $1.0$，符合预期。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies the upward continuation operator for a gravity anomaly field.\n    \"\"\"\n\n    #\n    # Part 1: Define grid and synthetic gravity field\n    #\n    Nx = 320         # Number of samples in x\n    Ny = 128         # Number of samples in y\n    dx = 500.0       # Sampling interval in x (m)\n    dy = 500.0       # Sampling interval in y (m)\n    Lx = Nx * dx     # Domain length in x (m)\n\n    # Wavelengths for the synthetic signal\n    signal_lambdas = [2000.0, 4000.0, 8000.0, 10000.0, 20000.0, 40000.0]\n\n    # Create the 1D x-coordinate vector\n    x = np.arange(Nx) * dx\n\n    # Create the 1D signal as a sum of cosine components\n    g_1d = np.zeros(Nx, dtype=float)\n    for lam in signal_lambdas:\n        g_1d += np.cos(2 * np.pi * x / lam)\n\n    # Tile the 1D signal to create the 2D field g(x,y)\n    g_xy = np.tile(g_1d, (Ny, 1))\n\n    #\n    # Part 2: Compute the 2D Fast Fourier Transform of the field\n    #\n    G_k = np.fft.fft2(g_xy)\n\n    #\n    # Part 3: Construct wavenumber grids for the operator\n    #\n    # Spatial frequencies (cycles/meter)\n    fx = np.fft.fftfreq(Nx, dx)\n    fy = np.fft.fftfreq(Ny, dy)\n\n    # Angular wavenumbers (radians/meter)\n    kx = 2 * np.pi * fx\n    ky = 2 * np.pi * fy\n\n    # Create 2D wavenumber grids\n    kxx, kyy = np.meshgrid(kx, ky)\n\n    # Radial wavenumber grid\n    kr = np.sqrt(kxx**2 + kyy**2)\n\n    #\n    # Part 4  5: Process test cases and compute attenuation factors\n    #\n    test_cases = [\n        # Case A: h=2000, lambdas=[10000, 20000, 40000]\n        (2000.0, [10000.0, 20000.0, 40000.0]),\n        # Case B: h=500, lambdas=[2000, 4000, 8000]\n        (500.0, [2000.0, 4000.0, 8000.0]),\n        # Case C: h=0, lambdas=[10000, 20000, 40000]\n        (0.0, [10000.0, 20000.0, 40000.0]),\n        # Case D: h=20000, lambdas=[10000, 20000, 40000]\n        (20000.0, [10000.0, 20000.0, 40000.0]),\n    ]\n\n    all_results = []\n\n    for h, target_lambdas in test_cases:\n        # Construct the upward continuation operator for the current height h\n        upward_continuation_operator = np.exp(-kr * h)\n\n        # Apply the operator to get the upward-continued spectrum\n        Gh_k = G_k * upward_continuation_operator\n\n        case_results = []\n        for lam in target_lambdas:\n            # The problem guarantees Lx / lam is an integer\n            m = int(round(Lx / lam))\n\n            # Indices for kx = +2*pi/lambda and kx = -2*pi/lambda\n            idx_pos_k = m\n            idx_neg_k = Nx - m\n\n            # The field is y-independent, so spectral energy is on the ky=0 axis (index 0)\n            ky_idx = 0\n\n            # Get the sum of magnitudes of the two spectral coefficients before continuation\n            sum_mag_before = np.abs(G_k[ky_idx, idx_pos_k]) + np.abs(G_k[ky_idx, idx_neg_k])\n\n            # Get the sum of magnitudes of the two spectral coefficients after continuation\n            sum_mag_after = np.abs(Gh_k[ky_idx, idx_pos_k]) + np.abs(Gh_k[ky_idx, idx_neg_k])\n\n            # The attenuation factor is the ratio of these sums.\n            # A check for sum_mag_before being near zero is good practice, but not\n            # strictly necessary here as the input signal guarantees energy at these wavelengths.\n            if sum_mag_before  1e-9:\n                attenuation = 1.0 if h == 0.0 else 0.0\n            else:\n                attenuation = sum_mag_after / sum_mag_before\n            \n            case_results.append(attenuation)\n\n        all_results.append(case_results)\n\n    # The final print statement must produce a single-line string representation\n    # of the list of lists, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}