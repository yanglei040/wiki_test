{
    "hands_on_practices": [
        {
            "introduction": "编写了数值代码后，我们如何确定它是正确的？此练习介绍了一种强大而通用的代码验证技术，即“人造解法”（Method of Manufactured Solutions）。通过构建一个已知精确解的基准问题，我们可以严格地测试我们的实现是否达到了理论预期的收敛阶数。这个过程对于建立对模拟结果的信心至关重要，它将我们的关注点从单个时间步的力学扩展到了整个模拟的准确性。",
            "id": "3604151",
            "problem": "考虑均匀介质中的一维热传导方程，其热扩散系数为 $\\kappa$，定义在空间域 $x \\in [0,1]$ 和时间区间 $t \\in [0,T]$ 上，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t),\n$$\n该方程满足狄利克雷边界条件和一个通过解析解构造法选择的初始条件。定义构造的解析解\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\n并推导强迫项 $f(x,t)$，使得对于给定的 $\\kappa$，$u_{\\mathrm{exact}}(x,t)$ 能精确满足热方程。对所有 $t$ 施加狄利克雷边界条件 $u(0,t) = u(1,t) = 0$，以及初始条件 $u(x,0) = u_{\\mathrm{exact}}(x,0)$。\n\n你的任务是使用空间上的二阶中心有限差分方法，为空间离散化后的问题实现两种隐式时间步进格式：\n- 后向欧拉法（时间上一阶精度）。\n- 克兰克-尼科尔森格式（时间上二阶精度）。\n\n使用包含 $N$ 个内部点的均匀网格，网格间距为 $h = \\frac{1}{N+1}$，时间点为 $t_n = n \\Delta t$，$n=0,1,\\dots,\\lfloor T/\\Delta t \\rfloor$。组装与齐次狄利克雷边界条件下 $\\frac{\\partial^2 u}{\\partial x^2}$ 的中心有限差分近似相一致的标准二阶导数矩阵。在每个时间步，与构造的解析解一致地施加强迫项和边界条件。\n\n将最终时刻 $T$ 的离散 $\\ell^2$ 范数误差定义为\n$$\nE(h,\\Delta t;\\kappa,\\text{scheme}) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T) - u_{\\mathrm{exact}}(x_i,T) \\right)^2 \\right)^{1/2},\n$$\n其中 $x_i = i h$，$u_i^{\\text{num}}(T)$ 是在 $x_i$ 和时刻 $T$ 的数值近似解。\n\n经验收敛阶定义为\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)},\\quad\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)},\n$$\n分别对应于固定 $h$ 并细化 $\\Delta t$ 时，以及固定 $\\Delta t$ 并细化 $h$ 时的情况。\n\n实现这些格式，并为以下测试套件计算经验收敛阶。所有量均为无量纲；将所有数值结果报告为无量纲浮点数。\n\n测试套件：\n1. 后向欧拉法时间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$N = 1000$（因此 $h = \\frac{1}{1001}$ 固定），$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算后向欧拉法的 $p_{\\Delta t}$。\n2. 后向欧拉法空间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$\\Delta t = 5\\times 10^{-5}$ 固定，$N_1 = 50$，$N_2 = 100$（因此 $h_1 = \\frac{1}{51}$，$h_2 = \\frac{1}{101}$）。计算后向欧拉法的 $p_{h}$。\n3. 克兰克-尼科尔森格式时间加密（“理想情况”）：$\\kappa = 0.35$，$T = 0.2$，$N = 1000$ 固定，$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算克兰克-尼科尔森格式的 $p_{\\Delta t}$。\n4. 误差污染机制下的后向欧拉法空间加密（“边界情况”）：$\\kappa = 0.35$，$T = 0.2$，$\\Delta t = 0.05$ 固定（时间误差不可忽略），$N_1 = 20$，$N_2 = 40$。计算后向欧拉法的 $p_{h}$ 并观察其与预期空间阶的偏差。\n5. 强扩散下的后向欧拉法时间加密（“边界情况”）：$\\kappa = 5.0$，$T = 0.2$，$N = 1000$ 固定，$\\Delta t_1 = 0.1$，$\\Delta t_2 = 0.05$。计算后向欧拉法的 $p_{\\Delta t}$ 以评估在刚度增加时时间阶的稳健性。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述五个测试案例顺序排列的结果。例如：“[result1,result2,result3,result4,result5]”。",
            "solution": "该问题要求使用解析解构造法，实现并验证求解一维热传导方程的隐式有限差分格式。\n\n**1. 问题构建与强迫项推导**\n\n控制偏微分方程(PDE)是带有源项 $f(x,t)$ 的热方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\kappa \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t)\n$$\n定义在空间域 $x \\in [0,1]$ 和时间区间 $t \\in [0,T]$ 上。热扩散系数用 $\\kappa$ 表示。\n\n为验证数值格式，我们使用解析解构造法。我们假设一个精确解，并将其代入PDE以推导出相应的强迫项 $f(x,t)$。所选择的构造解为：\n$$\nu_{\\mathrm{exact}}(x,t) = e^{-t}\\sin(\\pi x)\n$$\n我们计算 $u_{\\mathrm{exact}}(x,t)$ 的偏导数：\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} = -e^{-t}\\sin(\\pi x)\n$$\n$$\n\\frac{\\partial u_{\\mathrm{exact}}}{\\partial x} = \\pi e^{-t}\\cos(\\pi x) \\implies \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -\\pi^2 e^{-t}\\sin(\\pi x)\n$$\n将这些导数代入热方程，我们求解 $f(x,t)$：\n$$\nf(x,t) = \\frac{\\partial u_{\\mathrm{exact}}}{\\partial t} - \\kappa \\frac{\\partial^2 u_{\\mathrm{exact}}}{\\partial x^2} = -e^{-t}\\sin(\\pi x) - \\kappa(-\\pi^2 e^{-t}\\sin(\\pi x))\n$$\n$$\nf(x,t) = (\\kappa \\pi^2 - 1)e^{-t}\\sin(\\pi x)\n$$\n边界条件和初始条件由 $u_{\\mathrm{exact}}(x,t)$ 推导得出：\n-   初始条件 ($t=0$): $u(x,0) = u_{\\mathrm{exact}}(x,0) = e^{-0}\\sin(\\pi x) = \\sin(\\pi x)$。\n-   边界条件 ($x=0, x=1$):\n    -   $u(0,t) = u_{\\mathrm{exact}}(0,t) = e^{-t}\\sin(0) = 0$。\n    -   $u(1,t) = u_{\\mathrm{exact}}(1,t) = e^{-t}\\sin(\\pi) = 0$。\n这些是指定的齐次狄利克雷边界条件。\n\n**2. 数值离散化**\n\n我们在均匀网格上对问题进行离散化。空间域 $[0,1]$ 被划分为 $N+1$ 个宽度为 $h = \\frac{1}{N+1}$ 的子区间，从而得到 $N$ 个内部网格点 $x_i = i h$（$i=1, 2, \\dots, N$）。时间域被离散化为大小为 $\\Delta t$ 的步长，时间点为 $t_n = n \\Delta t$。\n\n**2.1. 空间离散化**\n\n在每个内部网格点 $x_i$ 处，使用二阶精度的中心有限差分来近似二阶空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\n令 $\\mathbf{u}(t)$ 为内部网格点上的近似解向量，$\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$，其中 $u_i(t) \\approx u(x_i, t)$。将此离散化应用于PDE，得到一个包含 $N$ 个耦合常微分方程（ODEs）的方程组：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{h^2} A \\mathbf{u}(t) + \\mathbf{f}(t)\n$$\n这里，$\\mathbf{f}(t) = [f(x_1,t), f(x_2,t), \\dots, f(x_N,t)]^T$ 是在网格点上计算的强迫项向量。矩阵 $A$ 是一个 $N \\times N$ 的三对角矩阵，表示带有齐次狄利克雷边界条件的离散拉普拉斯算子：\n$$\nA = \\begin{pmatrix}\n-2  & 1  & 0  & \\dots  & 0 \\\\\n1  & -2  & 1  & \\dots  & 0 \\\\\n0  & 1  & -2  & \\ddots  & \\vdots \\\\\n\\vdots  & \\ddots  & \\ddots  & \\ddots  & 1 \\\\\n0  & \\dots  & 0  & 1  & -2\n\\end{pmatrix}\n$$\n\n**2.2. 时间离散化**\n\n令 $\\mathbf{u}^n$ 为时刻 $t_n$ 的数值解向量。\n\n**后向欧拉法（BE）：**这是一种一阶精度的隐式格式。时间导数用后向差分近似，右端项在未来的时间步 $t_{n+1}$ 进行计算：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\n$$\n重新整理以求解未知向量 $\\mathbf{u}^{n+1}$，我们得到一个线性系统：\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{h^2} A\\right) \\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\mathbf{f}^{n+1}\n$$\n其中 $I$ 是 $N \\times N$ 的单位矩阵。左端的矩阵是三对角、对称且正定的，可以使用带状线性求解器进行高效求解。\n\n**克兰克-尼科尔森格式（CN）：**这是一种二阶精度的隐式格式，它对右端项在时刻 $t_n$ 和 $t_{n+1}$ 的取值进行平均：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n+1} + \\mathbf{f}^{n+1}\\right) + \\frac{1}{2}\\left(\\frac{\\kappa}{h^2} A \\mathbf{u}^{n} + \\mathbf{f}^{n}\\right)\n$$\n将含有 $\\mathbf{u}^{n+1}$ 的项归到左边，已知项归到右边，得到线性系统：\n$$\n\\left(I - \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\kappa \\Delta t}{2h^2} A\\right) \\mathbf{u}^{n} + \\frac{\\Delta t}{2}(\\mathbf{f}^{n+1} + \\mathbf{f}^n)\n$$\n与后向欧拉法（BE）类似，左端的矩阵是三对角的，该系统可以在每个时间步高效求解。\n\n**3. 误差分析与算法流程**\n\n对于后向欧拉法（BE），总离散误差预期为 $O(\\Delta t, h^2)$；对于克兰克-尼科尔森格式（CN），总离散误差预期为 $O(\\Delta t^2, h^2)$。我们使用最终模拟时刻 $T^* = \\lfloor T/\\Delta t \\rfloor \\Delta t$ 的离散 $\\ell^2$ 范数来量化误差：\n$$\nE(h,\\Delta t) = \\left( h \\sum_{i=1}^{N} \\left( u_i^{\\text{num}}(T^*) - u_{\\mathrm{exact}}(x_i,T^*) \\right)^2 \\right)^{1/2}\n$$\n计算经验收敛阶以验证理论精度阶。对于固定 $h$ 和两个时间步长 $\\Delta t_1, \\Delta t_2$ 的时间加密：\n$$\np_{\\Delta t} = \\frac{\\log\\left( E(h,\\Delta t_1)/E(h,\\Delta t_2) \\right)}{\\log\\left( \\Delta t_1 / \\Delta t_2 \\right)}\n$$\n对于固定 $\\Delta t$ 和两个网格间距 $h_1, h_2$ 的空间加密：\n$$\np_{h} = \\frac{\\log\\left( E(h_1,\\Delta t)/E(h_2,\\Delta t) \\right)}{\\log\\left( h_1 / h_2 \\right)}\n$$\n算法流程如下：\n1.  初始化参数：$\\kappa$, $T$, $N$, $\\Delta t$。\n2.  设置空间网格（$h, x_i$）和初始解 $\\mathbf{u}^0 = \\sin(\\pi \\mathbf{x})$。\n3.  为所选格式（BE 或 CN）构建系统矩阵。由于该矩阵在所有时间步中都是恒定的，因此只需组装一次。\n4.  从 $n=0$ 迭代到 $N_t-1$，其中 $N_t = \\lfloor T/\\Delta t \\rfloor$：\n    a. 组装右端向量，该向量依赖于前一时间步的解 $\\mathbf{u}^n$ 和强迫项 $\\mathbf{f}$。\n    b. 求解所得的三对角线性系统以获得 $\\mathbf{u}^{n+1}$。\n5.  循环结束后，通过将数值解 $\\mathbf{u}^{N_t}$ 与精确解 $u_{\\mathrm{exact}}(x_i, T^*)$ 进行比较来计算最终误差 $E$。\n6.  使用不同运行中计算出的误差，为每个测试案例计算经验收敛阶 $p_{\\Delta t}$ 或 $p_h$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def exact_solution(x, t):\n        \"\"\"Computes the exact manufactured solution.\"\"\"\n        return np.exp(-t) * np.sin(np.pi * x)\n\n    def forcing_term(x, t, kappa):\n        \"\"\"Computes the forcing term for the manufactured solution.\"\"\"\n        return (kappa * np.pi**2 - 1.0) * np.exp(-t) * np.sin(np.pi * x)\n\n    def run_simulation(scheme, kappa, T, N, dt):\n        \"\"\"\n        Runs a single simulation of the 1D heat equation.\n\n        Args:\n            scheme (str): 'BE' for Backward Euler or 'CN' for Crank-Nicolson.\n            kappa (float): Thermal diffusivity.\n            T (float): Final time.\n            N (int): Number of interior spatial grid points.\n            dt (float): Time step size.\n\n        Returns:\n            float: The discrete l2-norm of the error at the final time.\n        \"\"\"\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N, dtype=np.float64)\n        \n        num_steps = int(np.floor(T / dt))\n        if num_steps == 0:\n            # If dt is larger than T, no steps are taken. The error is then computed\n            # at t=0, which is zero. This case may arise with large dt values.\n            return 0.0\n            \n        final_time = num_steps * dt\n\n        # Initial condition\n        u = exact_solution(x, 0.0)\n\n        if scheme == 'BE':\n            # System: (I - alpha * A) u_n+1 = u_n + dt * f_n+1\n            alpha = dt * kappa / h**2\n            # LHS matrix for solve_banded, shape (3, N) for (l=1, u=1)\n            M_diags = np.zeros((3, N), dtype=np.float64)\n            M_diags[0, 1:] = -alpha      # Super-diagonal\n            M_diags[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n            M_diags[2, :-1] = -alpha     # Sub-diagonal\n            \n            for n in range(num_steps):\n                t_next = (n + 1) * dt\n                f_next = forcing_term(x, t_next, kappa)\n                rhs = u + dt * f_next\n                # solve_banded solves A*x=b, where A is given by 'M_diags'\n                u = solve_banded((1, 1), M_diags, rhs)\n                \n        elif scheme == 'CN':\n            # System: (I - alpha * A) u_n+1 = (I + alpha * A) u_n + dt/2 * (f_n+1 + f_n)\n            # where alpha = dt * kappa / (2 * h^2)\n            alpha = dt * kappa / (2.0 * h**2)\n            \n            # LHS matrix M_CN\n            M_CN_diags = np.zeros((3, N), dtype=np.float64)\n            M_CN_diags[0, 1:] = -alpha\n            M_CN_diags[1, :] = 1.0 + 2.0 * alpha\n            M_CN_diags[2, :-1] = -alpha\n            \n            # Function to apply the RHS matrix N_CN = (I + alpha * A)\n            def apply_N_CN(vec):\n                res = (1.0 - 2.0 * alpha) * vec\n                res[1:] += alpha * vec[:-1]\n                res[:-1] += alpha * vec[1:]\n                return res\n\n            for n in range(num_steps):\n                t_curr = n * dt\n                t_next = (n + 1) * dt\n                \n                f_curr = forcing_term(x, t_curr, kappa)\n                f_next = forcing_term(x, t_next, kappa)\n                \n                rhs_u_part = apply_N_CN(u)\n                rhs_f_part = dt / 2.0 * (f_curr + f_next)\n                \n                rhs = rhs_u_part + rhs_f_part\n                u = solve_banded((1, 1), M_CN_diags, rhs)\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n            \n        u_exact_final = exact_solution(x, final_time)\n        \n        # Calculate discrete l2-norm of the error\n        error = np.sqrt(h * np.sum((u - u_exact_final)**2))\n        \n        return error\n\n    def compute_p_dt(err1, err2, dt1, dt2):\n        \"\"\"Computes temporal convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(dt1 / dt2)\n\n    def compute_p_h(err1, err2, h1, h2):\n        \"\"\"Computes spatial convergence rate.\"\"\"\n        if err2 == 0.0 or err1 == 0.0: return np.nan\n        return np.log(err1 / err2) / np.log(h1 / h2)\n\n    test_cases = [\n        # 1. BE time refinement\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 2. BE space refinement\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 5e-5, 'N1': 50, 'N2': 100},\n        # 3. CN time refinement\n        {'type': 'p_dt', 'scheme': 'CN', 'kappa': 0.35, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n        # 4. BE space refinement (contaminated)\n        {'type': 'p_h', 'scheme': 'BE', 'kappa': 0.35, 'T': 0.2, 'dt': 0.05, 'N1': 20, 'N2': 40},\n        # 5. BE time refinement (stiff)\n        {'type': 'p_dt', 'scheme': 'BE', 'kappa': 5.0, 'T': 0.2, 'N': 1000, 'dt1': 0.1, 'dt2': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'p_dt':\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt1'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N'], case['dt2'])\n            rate = compute_p_dt(err1, err2, case['dt1'], case['dt2'])\n            results.append(rate)\n        elif case['type'] == 'p_h':\n            h1 = 1.0 / (case['N1'] + 1)\n            h2 = 1.0 / (case['N2'] + 1)\n            err1 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N1'], case['dt'])\n            err2 = run_simulation(case['scheme'], case['kappa'], case['T'], case['N2'], case['dt'])\n            rate = compute_p_h(err1, err2, h1, h2)\n            results.append(rate)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "不同的数值格式在求解同一方程时，其表现可能大相径庭。本练习旨在通过量化分析数值耗散，来比较两种广泛使用的隐式格式：后向欧拉法和Crank-Nicolson法。通过利用离散拉普拉斯算子的特征向量（即傅立叶模式），你将能够从理论和经验两个层面精确测量每种格式如何衰减不同频率的解分量，这对于准确模拟包含多尺度结构的地球物理现象至关重要。",
            "id": "3604206",
            "problem": "考虑在有限域上具有恒定热扩散系数 $\\kappa$ 和齐次狄利克雷边界条件的一维热传导偏微分方程 (PDE)。控制方程为 $u_t=\\kappa u_{xx}$，其中 $x\\in[0,L]$，边界条件为 $u(0,t)=0$ 和 $u(L,t)=0$，初始条件 $u(x,0)$ 为单一正弦模态。使用均匀空间网格和有限差分法 (FDM) 对二阶导数进行离散，构建具有齐次狄利克雷边界条件的离散拉普拉斯算子。使用 Crank-Nicolson (CN) 和后向欧拉 (BE) 方法实现一个隐式时间步，其中 Crank-Nicolson (CN) 和后向欧拉 (BE) 是求解抛物型偏微分方程的标准隐式时间积分格式。\n\n从基本偏微分方程和边界条件出发，采用由二阶中心差分导出的离散拉普拉斯算子，利用作为离散拉普拉斯算子特征向量的离散正弦模态，来量化每种格式在单个时间步内的数值耗散。在此，单个时间步的数值耗散定义为时间步之后与时间步之前的离散 $\\ell^2$ 范数之比，即 $\\|u^{n+1}\\|_2 / \\|u^n\\|_2$，该比值为无量纲。对于索引为 $m$ 的离散特征模态，$\\|u^n\\|_2$ 表示在时间层 $n$ 的内部节点值向量的欧几里得范数。由于初始条件被选为离散拉普拉斯算子的特征向量（一个与齐次狄利克雷边界兼容的正弦模态），因此在线性隐式步进下，解的形状与该模态保持成比例，并且这个范数比等于每步放大因子的绝对值。\n\n您的程序必须：\n- 构建对应于在 $N$ 个内部点上使用二阶中心差分和齐次狄利克雷边界条件的一维离散拉普拉斯矩阵，点间距为 $\\Delta x = L/(N+1)$。\n- 将内部节点值初始化为离散正弦模态 $u_j^0=\\sin\\!\\left(\\frac{m\\pi j}{N+1}\\right)$，其中 $j=1,2,\\dots,N$。这对应于在 $[0,L]$ 上波数为 $\\frac{m\\pi}{L}$ 的正弦模态。\n- 使用时间步长 $\\Delta t$ 执行一个 BE 步和一个 CN 步，并计算经验耗散因子 $g_{\\mathrm{BE,emp}}=\\|u^{1}_{\\mathrm{BE}}\\|_2/\\|u^{0}\\|_2$ 和 $g_{\\mathrm{CN,emp}}=\\|u^{1}_{\\mathrm{CN}}\\|_2/\\|u^{0}\\|_2$。\n- 通过对离散拉普拉斯算子进行特征值分析，计算离散模态的理论耗散因子，得到用模态 $m$ 的离散特征值以及参数 $\\kappa$、$\\Delta t$ 和 $L$ 表示的 $g_{\\mathrm{BE,th}}$ 和 $g_{\\mathrm{CN,th}}$。不要使用问题陈述中给出的任何快捷公式；从该方法的第一性原理和离散拉普拉斯算子的特征结构推导出表达式。\n\n对于每个测试用例，报告一个包含四个浮点数的列表 $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$。\n\n使用以下科学一致的测试套件以确保覆盖不同区间：\n1. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=1$.\n2. $L=1$, $N=63$, $\\kappa=1$, $\\Delta t=0.01$, $m=63$.\n3. $L=1$, $N=63$, $\\kappa=0.5$, $\\Delta t=10^{-6}$, $m=32$.\n4. $L=1$, $N=3$, $\\kappa=1$, $\\Delta t=0.1$, $m=1$.\n5. $L=2$, $N=63$, $\\kappa=2$, $\\Delta t=0.5$, $m=22$.\n\n所有量都是无量纲的，因此不需要进行物理单位转换。出现在三角函数内的角度应解释为弧度。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是按 $[g_{\\mathrm{CN,emp}},g_{\\mathrm{BE,emp}},g_{\\mathrm{CN,th}},g_{\\mathrm{BE,th}}]$ 顺序排列的列表，例如 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$，其中 $a_i, b_i, c_i, d_i$ 是第 $i$ 个测试用例的浮点数。",
            "solution": "本问题要求我们推导并比较后向欧拉（BE）和Crank-Nicolson（CN）格式的理论与经验数值耗散因子。\n\n**1. 半离散化与特征分析**\n\n一维热方程为 $u_t = \\kappa u_{xx}$。在具有 $N$ 个内部点、间距为 $\\Delta x = L/(N+1)$ 的均匀网格上，使用二阶中心差分对空间导数进行离散化。这将偏微分方程（PDE）转化为一个常微分方程（ODE）组：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\kappa}{(\\Delta x)^2} A \\mathbf{u} = M \\mathbf{u}\n$$\n其中 $\\mathbf{u}(t)$ 是内部各点温度值的向量，而 $A$ 是代表离散拉普拉斯算子的 $N \\times N$ 三对角矩阵，其主对角线为-2，次对角线和超对角线为1。\n\n分析的关键在于，初始条件 $u_j^0 = \\sin\\left(\\frac{m\\pi j}{N+1}\\right)$ 是矩阵 $A$ 的一个特征向量。矩阵 $A$ 的特征向量为 $\\mathbf{v}^{(m)}$，其分量为 $v_j^{(m)} = \\sin\\left(\\frac{m \\pi j}{N+1}\\right)$，其中 $m=1, \\dots, N$。对应的特征值为 $\\lambda_m = -4 \\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)$。\n\n因此，初始条件 $\\mathbf{u}^0$ 是 $A$ 的第 $m$ 个特征向量，也同样是 $M = \\frac{\\kappa}{(\\Delta x)^2} A$ 的特征向量。对应的 $M$ 的特征值为：\n$$\n\\mu_m = \\frac{\\kappa}{(\\Delta x)^2} \\lambda_m = -\\frac{4\\kappa}{(\\Delta x)^2}\\sin^2\\left(\\frac{m \\pi}{2(N+1)}\\right)\n$$\n\n**2. 理论耗散因子**\n\n当将一个线性时间积分格式应用于一个作为特征向量的初始条件时，下一时间步的解将与该特征向量保持成比例。这个比例常数就是格式的放大因子 $g$。数值耗散因子定义为 $|g|$。\n\n**后向欧拉法 (BE):** 格式为 $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = M \\mathbf{u}^{n+1}$。\n整理可得 $(I - \\Delta t M) \\mathbf{u}^{n+1} = \\mathbf{u}^n$。\n如果 $\\mathbf{u}^n = \\mathbf{v}^{(m)}$，则 $\\mathbf{u}^{n+1} = g_{\\mathrm{BE}}(\\mu_m)\\mathbf{v}^{(m)}$，其中放大因子为：\n$$\ng_{\\mathrm{BE}}(\\mu_m) = \\frac{1}{1 - \\Delta t \\mu_m}\n$$\n由于 $\\mu_m$ 是负实数， $g_{\\mathrm{BE}}$ 是正实数。理论耗散因子为：\n$$\ng_{\\mathrm{BE,th}} = |g_{\\mathrm{BE}}(\\mu_m)| = \\frac{1}{1 - \\Delta t \\mu_m}\n$$\n\n**Crank-Nicolson (CN):** 格式为 $\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} M (\\mathbf{u}^{n+1} + \\mathbf{u}^n)$。\n整理可得 $(I - \\frac{\\Delta t}{2} M) \\mathbf{u}^{n+1} = (I + \\frac{\\Delta t}{2} M) \\mathbf{u}^n$。\n对于一个特征模态初始条件，放大因子为：\n$$\ng_{\\mathrm{CN}}(\\mu_m) = \\frac{1 + \\Delta t \\mu_m / 2}{1 - \\Delta t \\mu_m / 2}\n$$\n理论耗散因子是其绝对值：\n$$\ng_{\\mathrm{CN,th}} = |g_{\\mathrm{CN}}(\\mu_m)| = \\left| \\frac{1 + \\Delta t \\mu_m / 2}{1 - \\Delta t \\mu_m / 2} \\right|\n$$\n\n**3. 经验耗散因子**\n\n经验耗散因子直接通过模拟计算得出。\n1.  用指定的离散正弦模态初始化解向量 $\\mathbf{u}^0$。\n2.  计算其 $\\ell^2$-范数 $\\|\\mathbf{u}^0\\|_2$。\n3.  对于每种格式（BE 和 CN），建立并求解相应的线性系统，以求得下一时间步的解 $\\mathbf{u}^1$。\n4.  计算新解的 $\\ell^2$-范数 $\\|\\mathbf{u}^1\\|_2$。\n5.  经验耗散因子即为范数之比：$g_{\\mathrm{emp}} = \\|\\mathbf{u}^1\\|_2 / \\|\\mathbf{u}^0\\|_2$。\n\n此过程可以让我们直接比较理论预测的耗散与数值实验中观察到的耗散。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes theoretical and empirical numerical dissipation factors for Backward Euler\n    and Crank-Nicolson schemes for the 1D heat equation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, N, kappa, dt, m)\n        (1.0, 63, 1.0, 0.01, 1),\n        (1.0, 63, 1.0, 0.01, 63),\n        (1.0, 63, 0.5, 1e-6, 32),\n        (1.0, 3, 1.0, 0.1, 1),\n        (2.0, 63, 2.0, 0.5, 22),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, kappa, dt, m = case\n\n        # Physical and discretization parameters\n        dx = L / (N + 1)\n        j_indices = np.arange(1, N + 1)\n\n        # --- Theoretical Dissipation Factor Calculation ---\n        \n        # Eigenvalue of the scaled discrete Laplacian M = (kappa/dx^2) * A for mode m\n        # lambda_m = -4 * sin^2(m*pi/(2*(N+1))) is the eigenvalue of A.\n        sin_term_sq = np.sin(m * np.pi / (2 * (N + 1)))**2\n        mu_m = -4 * kappa / (dx**2) * sin_term_sq\n\n        # Theoretical amplification factor for Backward Euler\n        # g_be = 1 / (1 - dt * mu_m)\n        g_be_th = 1.0 / (1.0 - dt * mu_m)\n\n        # Theoretical amplification factor for Crank-Nicolson\n        # g_cn = (1 + dt * mu_m / 2) / (1 - dt * mu_m / 2)\n        # The dissipation factor is the magnitude.\n        g_cn_th = np.abs((1.0 + dt * mu_m / 2.0) / (1.0 - dt * mu_m / 2.0))\n\n        # --- Empirical Dissipation Factor Calculation ---\n        \n        # Initial condition: discrete sine mode (eigenvector of the discrete Laplacian)\n        u0 = np.sin(m * np.pi * j_indices / (N + 1))\n        norm_u0 = np.linalg.norm(u0)\n\n        # Build the discrete Laplacian matrix A for N interior points\n        # A is an N x N tridiagonal matrix with (-2, 1, 1) entries\n        main_diag = -2.0 * np.ones(N)\n        off_diag = np.ones(N - 1)\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        I = np.identity(N)\n\n        # 1. Backward Euler (BE)\n        # (I - dt * kappa / dx^2 * A) u_1 = u_0\n        c_be = kappa * dt / (dx**2)\n        M_be = I - c_be * A\n        u1_be = np.linalg.solve(M_be, u0)\n        norm_u1_be = np.linalg.norm(u1_be)\n        g_be_emp = norm_u1_be / norm_u0\n\n        # 2. Crank-Nicolson (CN)\n        # (I - dt/2 * kappa / dx^2 * A) u_1 = (I + dt/2 * kappa / dx^2 * A) u_0\n        c_cn = kappa * dt / (2 * dx**2)\n        LHS_cn = I - c_cn * A\n        RHS_cn_matrix = I + c_cn * A\n        rhs_cn_vector = RHS_cn_matrix @ u0\n        u1_cn = np.linalg.solve(LHS_cn, rhs_cn_vector)\n        norm_u1_cn = np.linalg.norm(u1_cn)\n        g_cn_emp = norm_u1_cn / norm_u0\n        \n        # Store results in the specified order\n        results.append([g_cn_emp, g_be_emp, g_cn_th, g_be_th])\n\n    # Final print statement in the exact required format.\n    # The format string ensures that nested lists are printed correctly.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}