{
    "hands_on_practices": [
        {
            "introduction": "A robust numerical simulation must not only be accurate but also stable, producing physically plausible results. This exercise delves into the Discrete Maximum Principle (DMP), a key indicator of stability for discretized potential field equations. You will analyze the conditions under which common finite difference stencils yield a special type of matrix, known as an $M$-matrix, that guarantees the DMP, and explore how factors like grid geometry and material anisotropy can compromise this crucial property. ",
            "id": "3612956",
            "problem": "In computational geophysics, potential fields governed by Poisson and Laplace equations are often computed with finite difference schemes on orthogonal rectangular grids. Let $u$ satisfy either the Poisson equation $\\nabla^{2} u = f$ or the more general heterogeneous diffusion equation $\\nabla \\cdot (\\boldsymbol{K} \\nabla u) = f$, where $\\boldsymbol{K}$ is a symmetric positive definite conductivity tensor. A discrete maximum principle is desired because it guarantees that in the discrete solution, interior extrema are bounded by boundary data when the source is of a given sign.\n\nFor a linear system $\\boldsymbol{A} \\boldsymbol{u} = \\boldsymbol{b}$ obtained from a finite difference discretization, a sufficient condition for a discrete maximum principle is that $\\boldsymbol{A}$ is an $M$-matrix, that is, a $Z$-matrix with $a_{ii}  0$, $a_{ij} \\le 0$ for all $i \\ne j$, that is (weakly) diagonally dominant by rows and irreducible, which implies $\\boldsymbol{A}^{-1} \\ge 0$ (entrywise). In this problem, you will assess when common finite difference stencils satisfy these conditions and how grid aspect ratio and coefficient contrast affect monotonicity.\n\nConsider the following settings on a rectangular grid with spacings $h_x  0$ and $h_y  0$:\n- The standard five-point stencil for the Laplacian $\\nabla^{2} u = f$ on a uniform orthogonal grid with Dirichlet boundary conditions.\n- The scalar heterogeneous isotropic case $\\nabla \\cdot (\\kappa(\\boldsymbol{x}) \\nabla u) = f$ on an orthogonal grid, where $\\kappa(\\boldsymbol{x})$ is bounded above and below by positive constants, discretized by a conservative two-point flux (harmonic averaging on faces) yielding a five-point stencil.\n- The constant anisotropic case with $\\boldsymbol{K} = \\begin{bmatrix} a  b \\\\ b  c \\end{bmatrix}$, where $a  0$, $c  0$, and $ac - b^{2}  0$, on a rectangular grid that is not rotated with respect to the coordinate axes. Two choices are considered:\n  (i) the symmetric central-difference nine-point stencil for $a u_{xx} + 2 b u_{xy} + c u_{yy}$,\n  (ii) a wide-stencil monotone construction that distributes the mixed-derivative contribution into axis-aligned and diagonal neighbors with nonnegative transmissivities, designed so that all off-diagonal coefficients are nonpositive.\n\nSelect all statements that are correct about the discrete maximum principle and monotonicity in these settings:\n\nA. For the standard five-point discretization of $\\nabla^{2} u = f$ on any orthogonal rectangular grid with $h_x  0$ and $h_y  0$ and Dirichlet boundary conditions, the stiffness matrix is an $M$-matrix; hence a discrete maximum principle holds unconditionally, independent of the grid aspect ratio $r = h_x/h_y$.\n\nB. For $\\nabla \\cdot (\\kappa(\\boldsymbol{x}) \\nabla u) = f$ on an orthogonal grid, if $\\kappa(\\boldsymbol{x})$ satisfies $0  \\kappa_{\\min} \\le \\kappa(\\boldsymbol{x}) \\le \\kappa_{\\max}  \\infty$, then the conservative two-point flux five-point discretization yields an $M$-matrix regardless of the coefficient contrast $\\kappa_{\\max}/\\kappa_{\\min}$; therefore, the discrete maximum principle holds independently of contrast.\n\nC. For a constant rotated anisotropy with $b \\ne 0$, the symmetric central-difference nine-point stencil is monotone provided that the aspect ratio satisfies $h_x/h_y = \\sqrt{a/c}$, which effectively aligns the grid with the principal axes in a metric sense and restores a discrete maximum principle.\n\nD. For a constant rotated anisotropy with $b \\ne 0$, the symmetric central-difference nine-point stencil necessarily violates monotonicity on any orthogonal rectangular grid because it produces alternating signs among the four diagonal neighbor coefficients; no choice of $h_x/h_y$ can make all off-diagonals nonpositive.\n\nE. For a constant rotated anisotropy with $b \\ne 0$, there exist wide-stencil monotone finite differences on orthogonal rectangular grids whose off-diagonals are all nonpositive provided the tensor–grid compatibility satisfies the inequalities\n$$\n|b| \\le 2 \\min\\!\\left( a \\,\\frac{h_y}{h_x},\\; c \\,\\frac{h_x}{h_y} \\right).\n$$\nThus, increasing coefficient contrast (large $|b|$ relative to $a$ and $c$) or using an extreme aspect ratio $h_x/h_y$ can destroy monotonicity by violating these bounds.\n\nChoose all that apply.",
            "solution": "The problem asks to evaluate several statements concerning the discrete maximum principle (DMP) for finite difference discretizations of elliptic partial differential equations. A sufficient condition for a DMP is that the system matrix $\\boldsymbol{A}$ is an $M$-matrix. By definition, an $M$-matrix is a $Z$-matrix ($a_{ii}  0$ and $a_{ij} \\le 0$ for $i \\ne j$) that is weakly diagonally dominant and irreducible. We analyze each statement based on whether the corresponding finite difference stencil yields an $M$-matrix. For convention, we analyze the discretization of the negative of the differential operator, e.g., $-\\nabla^2 u$, so that the resulting stiffness matrix $\\boldsymbol{A}$ is positive definite and can be an $M$-matrix.\n\n### Step 1: Extract Givens\n-   Governing Equations: $\\nabla^{2} u = f$ or $\\nabla \\cdot (\\boldsymbol{K} \\nabla u) = f$.\n-   Conductivity Tensor $\\boldsymbol{K}$: Symmetric positive definite.\n-   Grid: Orthogonal rectangular grid with spacings $h_x  0$ and $h_y  0$.\n-   M-matrix conditions: $a_{ii}  0$, $a_{ij} \\le 0$ for $i \\ne j$ ($Z$-matrix), weakly diagonally dominant, and irreducible.\n-   Case 1: Standard five-point stencil for $\\nabla^{2} u$.\n-   Case 2: Conservative two-point flux (harmonic averaging) five-point stencil for $\\nabla \\cdot (\\kappa(\\boldsymbol{x}) \\nabla u)$ with $0  \\kappa_{\\min} \\le \\kappa(\\boldsymbol{x}) \\le \\kappa_{\\max}  \\infty$.\n-   Case 3: Constant anisotropic tensor $\\boldsymbol{K} = \\begin{bmatrix} a  b \\\\ b  c \\end{bmatrix}$ with $a  0, c  0, ac - b^2  0$.\n    -   (i) Symmetric central-difference nine-point stencil.\n    -   (ii) Wide-stencil monotone construction.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is well-grounded in the theory of numerical analysis for partial differential equations, a core topic in computational science and geophysics. The concepts of potential fields, finite differences, discrete maximum principles, and $M$-matrices are standard and rigorously defined.\n-   **Well-Posed**: The problem is well-posed. It asks to verify specific mathematical properties of well-defined numerical schemes.\n-   **Objectivity**: The language is precise, technical, and objective.\n-   **Completeness and Consistency**: The problem provides all necessary definitions and context to analyze the statements. There are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. The analysis of each option will proceed.\n\n### Option-by-Option Analysis\n\n**A. For the standard five-point discretization of $\\nabla^{2} u = f$ on any orthogonal rectangular grid with $h_x  0$ and $h_y  0$ and Dirichlet boundary conditions, the stiffness matrix is an $M$-matrix; hence a discrete maximum principle holds unconditionally, independent of the grid aspect ratio $r = h_x/h_y$.**\n\nThe standard central difference approximation for the operator $-\\nabla^2 u = -u_{xx} - u_{yy}$ at a grid node $(i,j)$ is:\n$$ -(\\nabla^2 u)_{i,j} \\approx -\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} - \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} $$\nRearranging terms to form the matrix row for node $(i,j)$:\n$$ \\left( \\frac{2}{h_x^2} + \\frac{2}{h_y^2} \\right) u_{i,j} - \\frac{1}{h_x^2} u_{i+1,j} - \\frac{1}{h_x^2} u_{i-1,j} - \\frac{1}{h_y^2} u_{i,j+1} - \\frac{1}{h_y^2} u_{i,j-1} = -f_{i,j} $$\nThe coefficients of the stiffness matrix $\\boldsymbol{A}$ are:\n-   Diagonal element: $a_{ii} = \\frac{2}{h_x^2} + \\frac{2}{h_y^2}  0$.\n-   Off-diagonal elements for neighbors: The coefficients for $u_{i\\pm1,j}$ are $-\\frac{1}{h_x^2} \\le 0$, and for $u_{i,j\\pm1}$ are $-\\frac{1}{h_y^2} \\le 0$. All other off-diagonal elements are $0$.\nSince all off-diagonals are non-positive and the diagonal is positive, $\\boldsymbol{A}$ is a $Z$-matrix.\nThe row sum for an interior node is $\\left( \\frac{2}{h_x^2} + \\frac{2}{h_y^2} \\right) - 2\\left(\\frac{1}{h_x^2}\\right) - 2\\left(\\frac{1}{h_y^2}\\right) = 0$. For a node adjacent to a Dirichlet boundary, one or more neighbor terms are moved to the right-hand side, making the row sum strictly positive. Thus, the matrix is weakly diagonally dominant. The stencil connects all nodes in a connected domain, so the matrix is irreducible. Therefore, $\\boldsymbol{A}$ is an $M$-matrix. These properties hold for any $h_x  0$ and $h_y  0$, so they are independent of the aspect ratio $r = h_x/h_y$.\n\n**Verdict:** **Correct**.\n\n**B. For $\\nabla \\cdot (\\kappa(\\boldsymbol{x}) \\nabla u) = f$ on an orthogonal grid, if $\\kappa(\\boldsymbol{x})$ satisfies $0  \\kappa_{\\min} \\le \\kappa(\\boldsymbol{x}) \\le \\kappa_{\\max}  \\infty$, then the conservative two-point flux five-point discretization yields an $M$-matrix regardless of the coefficient contrast $\\kappa_{\\max}/\\kappa_{\\min}$; therefore, the discrete maximum principle holds independently of contrast.**\n\nA conservative finite difference scheme for $-\\nabla \\cdot (\\kappa \\nabla u)$ is derived by integrating over a control volume around node $(i,j)$ and approximating fluxes. For the flux in the x-direction across the face at $x_{i+1/2}$, we use $F_{x, i+1/2} = -\\kappa_{i+1/2,j} \\frac{u_{i+1,j}-u_{i,j}}{h_x}$. A robust choice for the interface conductivity $\\kappa_{i+1/2,j}$ is the harmonic mean of the conductivities at the adjacent nodes, e.g., $\\frac{2}{\\kappa_{i+1/2,j}} = \\frac{1}{\\kappa_{i,j}} + \\frac{1}{\\kappa_{i+1,j}}$. Since $\\kappa(\\boldsymbol{x})  0$, the harmonic mean is also strictly positive. The discretization at node $(i,j)$ is:\n$$ -\\frac{F_{x,i+1/2,j}-F_{x,i-1/2,j}}{h_x} - \\frac{F_{y,i,j+1/2}-F_{y,i,j-1/2}}{h_y} $$\n$$ = \\frac{\\kappa_{i+1/2,j}}{h_x^2} (u_{i+1,j}-u_{i,j}) + \\frac{\\kappa_{i-1/2,j}}{h_x^2} (u_{i,j}-u_{i-1,j}) + \\dots $$\nThe coefficients of the resulting matrix $\\boldsymbol{A}$ are:\n-   Diagonal: $a_{ii} = \\frac{\\kappa_{i+1/2,j}+\\kappa_{i-1/2,j}}{h_x^2} + \\frac{\\kappa_{i,j+1/2}+\\kappa_{i,j-1/2}}{h_y^2}  0$.\n-   Off-diagonal: e.g., for $u_{i+1,j}$, the coefficient is $-\\frac{\\kappa_{i+1/2,j}}{h_x^2} \\le 0$.\nAll off-diagonal coefficients are non-positive because the interface conductivities are positive. The matrix is a $Z$-matrix. It is also irreducibly diagonally dominant, just like the Laplacian case. The magnitudes of $\\kappa_{\\min}$ and $\\kappa_{\\max}$ (the contrast) will affect the condition number of the matrix, but not the sign structure. As long as $\\kappa(\\boldsymbol{x})$ is strictly positive, the matrix is an $M$-matrix.\n\n**Verdict:** **Correct**.\n\n**D. For a constant rotated anisotropy with $b \\ne 0$, the symmetric central-difference nine-point stencil necessarily violates monotonicity on any orthogonal rectangular grid because it produces alternating signs among the four diagonal neighbor coefficients; no choice of $h_x/h_y$ can make all off-diagonals nonpositive.**\n\nLet's analyze this statement before C. The operator is $L(u) = a u_{xx} + 2 b u_{xy} + c u_{yy}$. We consider the discretization of $-L(u)$. The mixed derivative term $-2b u_{xy}$ is approximated using a standard symmetric central difference:\n$$ -2b u_{xy} \\approx -2b \\left( \\frac{u_{i+1,j+1} - u_{i-1,j+1} - u_{i+1,j-1} + u_{i-1,j-1}}{4 h_x h_y} \\right) $$\nThe coefficients for the diagonal neighbors in the matrix row for node $(i,j)$ are:\n-   Coeff of $u_{i+1,j+1}$: $-\\frac{b}{2 h_x h_y}$\n-   Coeff of $u_{i-1,j+1}$: $+\\frac{b}{2 h_x h_y}$\n-   Coeff of $u_{i+1,j-1}$: $+\\frac{b}{2 h_x h_y}$\n-   Coeff of $u_{i-1,j-1}$: $-\\frac{b}{2 h_x h_y}$\nFor the matrix to be a $Z$-matrix, all off-diagonal coefficients must be non-positive.\n-   If $b  0$, the coefficients for $u_{i-1,j+1}$ and $u_{i+1,j-1}$ are positive.\n-   If $b  0$, the coefficients for $u_{i+1,j+1}$ and $u_{i-1,j-1}$ are positive.\nSince $b \\ne 0$, there will always be two positive off-diagonal coefficients. This violates the $Z$-matrix condition. No choice of $h_x  0$ and $h_y  0$ can alter the signs of these coefficients. Thus, this stencil cannot produce an $M$-matrix.\n\n**Verdict:** **Correct**.\n\n**C. For a constant rotated anisotropy with $b \\ne 0$, the symmetric central-difference nine-point stencil is monotone provided that the aspect ratio satisfies $h_x/h_y = \\sqrt{a/c}$, which effectively aligns the grid with the principal axes in a metric sense and restores a discrete maximum principle.**\n\nAs demonstrated in the analysis of option D, the symmetric central-difference nine-point stencil for an operator with a mixed derivative term ($b \\ne 0$) always produces positive off-diagonal coefficients. This is a fundamental flaw that prevents the matrix from being an $M$-matrix. The condition $h_x/h_y = \\sqrt{a/c}$ (or $h_x/\\sqrt{a} = h_y/\\sqrt{c}$) corresponds to using a grid that is uniform in coordinates scaled by the principal components of the diagonal part of the tensor. While this may be beneficial for accuracy in some contexts, it cannot change the sign of the off-diagonal coefficients stemming from the $u_{xy}$ term. The claim that this restores the discrete maximum principle is false.\n\n**Verdict:** **Incorrect**.\n\n**E. For a constant rotated anisotropy with $b \\ne 0$, there exist wide-stencil monotone finite differences on orthogonal rectangular grids whose off-diagonals are all nonpositive provided the tensor–grid compatibility satisfies the inequalities $|b| \\le 2 \\min\\!\\left( a \\,\\frac{h_y}{h_x},\\; c \\,\\frac{h_x}{h_y} \\right)$. Thus, increasing coefficient contrast (large $|b|$ relative to $a$ and $c$) or using an extreme aspect ratio $h_x/h_y$ can destroy monotonicity by violating these bounds.**\n\nThe failure of the standard stencil (Option D) motivates the development of alternative \"monotone\" schemes. These schemes are designed specifically to result in $M$-matrices, but often at the cost of being valid only under certain conditions. These conditions typically constrain the relationship between the anisotropy of the material ($\\boldsymbol{K}$) and the geometry of the grid ($h_x, h_y$).\nThe condition given,\n$$ |b| \\le 2a \\frac{h_y}{h_x} \\quad \\text{and} \\quad |b| \\le 2c \\frac{h_x}{h_y} $$\nis a known result for certain advanced finite volume or finite element schemes (e.g., the \"box method\" with specific quadrature, or some mixed finite element methods) to be monotone (i.e., produce an M-matrix). While the standard central difference stencil is never monotone for $b \\ne 0$, these other schemes are, provided this \"tensor-grid compatibility\" condition is met.\nThe implications described are also correct:\n-   If $|b|$ increases relative to $a$ and $c$, the inequalities may be violated.\n-   If the aspect ratio $r = h_x/h_y$ becomes very large ($r \\to \\infty$), the condition $|b| \\le 2a/r$ becomes impossible to satisfy for any $b \\ne 0$.\n-   If the aspect ratio becomes very small ($r \\to 0$), the condition $|b| \\le 2cr$ becomes impossible to satisfy for any $b \\ne 0$.\nTherefore, both large anisotropy contrast and extreme grid aspect ratios can violate the condition required for these schemes to be monotone. The statement correctly describes the existence and limitations of such methods.\n\n**Verdict:** **Correct**.",
            "answer": "$$\\boxed{ABDE}$$"
        },
        {
            "introduction": "Theory comes to life through implementation. This hands-on coding problem bridges the gap between the abstract conditions for monotonicity and their tangible effects on finite element solutions of the Laplace equation. By constructing a \"pathological\" mesh with obtuse triangles, you will directly observe the violation of the maximum principle and then implement a flux-limiting scheme to restore solution stability, a common technique in developing robust geophysical modeling software. ",
            "id": "3612912",
            "problem": "You are asked to write a complete and runnable program that constructs and analyzes discrete solutions of the Laplace equation under Dirichlet boundary conditions on triangulated two-dimensional domains, with a focus on the discrete maximum principle and numerical monotonicity. The mathematical context is potential theory in computational geophysics, where the gravitational or electrostatic potential satisfies the Laplace equation. The governing equation is the Laplace equation in two spatial dimensions,\n$$\n\\nabla^2 \\phi = 0,\n$$\nwith prescribed values of the potential on the boundary. The classical maximum principle states that for sufficiently smooth solutions of this equation on a bounded domain, the extrema of the solution occur on the boundary. In discrete settings, the preservation of this principle depends on properties of the discretization matrix, notably whether it is a Monotone matrix (M-matrix), which in practice requires nonpositive off-diagonal entries and a form of diagonal dominance when assembling the stiffness matrix from the weak form.\n\nYour task begins from the weak form of the Laplace equation and uses the standard piecewise linear finite element method on a triangulated mesh, yielding a stiffness matrix assembled from triangle contributions. For a triangle with vertices at positions $\\boldsymbol{x}_i$, $\\boldsymbol{x}_j$, $\\boldsymbol{x}_k$, the element-wise contribution can be expressed through the cotangent formula, in which the weight associated with the edge $(i,j)$ is proportional to the sum of cotangents of the angles opposite that edge. On an acute or Delaunay triangulation this weight is nonnegative, which leads to nonpositive off-diagonal entries in the global stiffness matrix and hence supports a discrete maximum principle. On non-Delaunay or highly obtuse triangulations, some cotangents become negative, off-diagonal entries become positive, and numerical oscillations can occur. In this problem, you will construct both well-behaved and pathological triangulations of the unit square and quantify violations of the discrete maximum principle. You will then implement a simple edge-based flux limiter that clips negative edge weights to zero while preserving symmetry and row-sum properties, and re-evaluate the metrics.\n\nFundamental bases you may rely on include: the weak form of the Laplace equation; the definition of the stiffness matrix for linear finite elements; the cotangent-based expression of stiffness entries for triangulations; and the characterization of the Monotone matrix (M-matrix) property for discrete operators arising from diffusion.\n\nProgram requirements:\n- Implement a generator for a structured triangular mesh of the unit square $[0,1]\\times[0,1]$ with $N_x+1$ by $N_y+1$ grid points. Each rectangular cell must be subdivided into two triangles by a consistent diagonal to create a valid triangulation.\n- Implement the assembly of the global stiffness matrix using the cotangent formula: for each triangle with vertices $(i,j,k)$ and opposite angle at vertex $k$ equal to $\\alpha_k$, accumulate the edge weight $w_{ij} \\mathrel{+}= \\tfrac{1}{2}\\cot(\\alpha_k)$, and analogously for the other two edges. The global stiffness matrix should be $K_{ii} = \\sum_{j\\neq i} w_{ij}$ and $K_{ij} = -w_{ij}$ for $i\\neq j$.\n- Implement Dirichlet boundary conditions by prescribing boundary values $g(\\boldsymbol{x})$ at nodes on the boundary $\\partial \\Omega$, eliminating boundary unknowns to form the interior system $K_{II}\\phi_I = -K_{IB}\\phi_B$ and solving it for the interior nodal values $\\phi_I$.\n- Construct a pathological triangulation by perturbing one interior node to create highly obtuse triangles in its neighborhood so that some summed edge weights $w_{ij}$ become negative. You must ensure the triangulation remains well-defined and nondegenerate.\n- Define and implement a flux limiter on the edge weights by setting $\\tilde{w}_{ij} = \\max(w_{ij},0)$ for all edges $(i,j)$, and then forming the modified stiffness matrix $\\tilde{K}$ with the same definitions $ \\tilde{K}_{ii} = \\sum_{j\\neq i} \\tilde{w}_{ij}$ and $\\tilde{K}_{ij} = -\\tilde{w}_{ij}$ for $i\\neq j$. Solve the modified discrete problem with the same Dirichlet data and compare.\n\nFor each test case, compute the following quantitative metrics:\n- A boolean indicating whether the stiffness matrix is monotone in the sense of having nonpositive off-diagonal entries (i.e., whether $K_{ij} \\le 0$ for all $i\\neq j$). This must be evaluated before applying the flux limiter.\n- A boolean indicating whether the discrete maximum principle is violated before applying the flux limiter, quantified as either an interior undershoot below the boundary minimum, or an interior overshoot above the boundary maximum. Formally, let $\\phi_I$ be the interior solution and let $m_B = \\min(\\phi_B)$ and $M_B = \\max(\\phi_B)$; declare a violation if $\\min(\\phi_I)  m_B - \\varepsilon$ or $\\max(\\phi_I)  M_B + \\varepsilon$ with a small tolerance $\\varepsilon$.\n- The magnitude of violation before applying the flux limiter, defined as $v = \\max\\{0, m_B - \\min(\\phi_I)\\} + \\max\\{0, \\max(\\phi_I) - M_B\\}$. Report this value rounded to $6$ decimal places.\n- A boolean indicating whether the discrete maximum principle is violated after applying the flux limiter, using the same criterion and tolerance.\n\nAngles must be treated in radians internally, but you are not required to report any angles. There are no physical units to report in the output.\n\nYour program must implement the following test suite. In all cases, the computational domain is the unit square and the Dirichlet boundary data are applied at nodes with $x\\in\\{0,1\\}$ or $y\\in\\{0,1\\}$:\n- Test case $1$ (well-behaved mesh): $N_x = 16$, $N_y = 16$. No perturbation. Boundary data $g(x,y) = x$. This case should have no monotonicity issue and no maximum principle violation.\n- Test case $2$ (pathological mesh, moderate distortion): $N_x = 16$, $N_y = 16$. Perturb one interior node near the mesh center in the positive $x$-direction sufficiently to create at least one negative edge weight while keeping a valid triangulation. Boundary data is piecewise constant: $g(x,y) = 1$ on the right and top edges and $g(x,y) = 0$ on the left and bottom edges. This case targets a violation before limiting and cure after limiting.\n- Test case $3$ (pathological mesh, stronger distortion on a coarser grid): $N_x = 8$, $N_y = 8$. Perturb one interior node near the mesh center with a larger displacement than in Test case $2$, constructed to produce more pronounced negativity in edge weights while keeping a valid triangulation. Boundary data is the same as in Test case $2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of per-case summaries, each summary itself being a list with four entries in the order: [monotone_before, violates_before, violates_after, violation_magnitude_before], where the booleans are represented as Python literals and the magnitude is a float rounded to $6$ decimals. For example, a valid output format is\n[\n[True,False,False,0.0],\n[False,True,False,0.123456],\n[False,True,False,0.234567]\n]\nbut with the actual values determined by your computations on the specified test suite.",
            "solution": "The problem is determined to be valid. All specified components—the governing equation, numerical method, and analysis metrics—are scientifically grounded in the theory of numerical solutions for partial differential equations, specifically potential theory. The problem is well-posed, objective, and self-contained. A minor ambiguity exists in the definition of boundary conditions for test cases 2 and 3 at the corner nodes where different value assignments overlap. This is resolved by adopting the clear and unambiguous rule that $g(x,y)=1$ for any boundary node where $x=1$ or $y=1$, and $g(x,y)=0$ for all other boundary nodes. This interpretation does not affect the overall range of boundary values and is consistent with the problem's intent. We will now proceed with the solution.\n\nThe problem requires the numerical solution of the two-dimensional Laplace equation, $\\nabla^2 \\phi = 0$, on a unit square domain $\\Omega = [0,1]\\times[0,1]$ with Dirichlet boundary conditions $\\phi = g(\\boldsymbol{x})$ on the boundary $\\partial \\Omega$. We employ the Finite Element Method (FEM) with piecewise linear basis functions on a triangular mesh.\n\nThe starting point is the weak form of the Laplace equation, obtained by multiplying by a test function $v$ and integrating over the domain $\\Omega$:\n$$\n\\int_\\Omega (\\nabla^2 \\phi) v \\, d\\boldsymbol{x} = 0\n$$\nUsing Green's first identity (integration by parts), this becomes:\n$$\n\\int_\\Omega \\nabla\\phi \\cdot \\nabla v \\, d\\boldsymbol{x} - \\int_{\\partial\\Omega} (\\nabla\\phi \\cdot \\boldsymbol{n}) v \\, d\\boldsymbol{s} = 0\n$$\nFor Dirichlet problems, the test functions $v$ corresponding to interior nodes are zero on the boundary, so the boundary integral vanishes. We approximate the potential $\\phi$ as a sum over linear basis functions $N_j(\\boldsymbol{x})$ associated with each node $j$ of the mesh: $\\phi(\\boldsymbol{x}) \\approx \\phi_h(\\boldsymbol{x}) = \\sum_j \\phi_j N_j(\\boldsymbol{x})$, where $\\phi_j$ are the unknown nodal values. Choosing the test functions to be the basis functions themselves (a Galerkin projection, $v=N_i$), we obtain a system of linear equations $K\\boldsymbol{\\phi} = \\boldsymbol{f}$. The entries of the stiffness matrix $K$ are given by $K_{ij} = \\int_\\Omega \\nabla N_i \\cdot \\nabla N_j \\, d\\boldsymbol{x}$.\n\nFor a triangular mesh, this integral is computed as a sum of contributions from each triangle element. For an edge connecting nodes $i$ and $j$, the contribution to the stiffness matrix can be calculated using the cotangent formula. If the edge $(i,j)$ is shared by two triangles, with opposite vertices $k$ and $l$ and corresponding angles $\\alpha_k$ and $\\alpha_l$, the edge weight is $w_{ij} = \\frac{1}{2}(\\cot(\\alpha_k) + \\cot(\\alpha_l))$. The stiffness matrix entries are then defined as:\n$$\nK_{ij} = \\begin{cases} -w_{ij}  \\text{if } i \\neq j \\\\ \\sum_{k \\neq i} w_{ik}  \\text{if } i = j \\end{cases}\n$$\nThis construction ensures that the row sums of $K$ are zero, i.e., $\\sum_j K_{ij} = 0$, which is a discrete analogue of the property that the Laplacian of a constant is zero.\n\nThe discrete maximum principle (DMP) states that the solution at any interior node is bounded by the minimum and maximum values on the boundary. A sufficient condition for the DMP to hold is that the stiffness matrix $K$ is a Monotone matrix (M-matrix). For our problem, this requires that all off-diagonal entries are nonpositive, $K_{ij} \\le 0$ for all $i \\neq j$. From the definition, this is equivalent to requiring that all edge weights are nonnegative, $w_{ij} \\ge 0$.\n\nThe sign of $w_{ij}$ depends on the signs of the cotangents. For an acute or right-angled triangle, all angles are less than or equal to $\\pi/2$ radians, so all cotangents are nonnegative. A triangulation where all triangles are acute is a Delaunay triangulation. On such a mesh, all $w_{ij} \\ge 0$, and the DMP is guaranteed to hold. However, if a triangle is obtuse, one angle is greater than $\\pi/2$, and its cotangent is negative. If this negative contribution is large enough to make a total edge weight $w_{ij}$ negative, the corresponding off-diagonal entry $K_{ij} = -w_{ij}$ becomes positive, the matrix is no longer an M-matrix, and the DMP may be violated, leading to non-physical oscillations where the interior potential undershoots the boundary minimum or overshoots the boundary maximum.\n\nThe algorithm to be implemented follows these steps:\n1.  **Mesh Generation**: Create a structured grid of $(N_x+1) \\times (N_y+1)$ nodes on the unit square. For pathological cases, perturb the coordinates of a designated interior node. Triangulate the grid by consistently dividing each rectangular cell.\n2.  **Stiffness Matrix Assembly**: For each triangle, calculate the cotangents of its angles. A numerically stable formula for the cotangent of the angle at vertex $P_3$ in a triangle with vertices $P_1, P_2, P_3$ is $\\cot(\\alpha_3) = \\frac{(P_1 - P_3) \\cdot (P_2 - P_3)}{| (P_1 - P_3) \\times (P_2 - P_3) |_z}$. Sum these contributions to obtain the edge weights $w_{ij}$. From these weights, construct the stiffness matrix $K$.\n3.  **Monotonicity and Violation Analysis (Before Limiter)**: Check if all $w_{ij} \\ge 0$ to determine if $K$ is monotone. Partition the nodes into interior and boundary sets. Apply the Dirichlet boundary conditions $g(\\boldsymbol{x})$ to define the known boundary potentials $\\boldsymbol{\\phi}_B$. Solve the reduced linear system $K_{II}\\boldsymbol{\\phi}_I = -K_{IB}\\boldsymbol{\\phi}_B$ for the interior potentials $\\boldsymbol{\\phi}_I$. Compare the range of $\\boldsymbol{\\phi}_I$ to that of $\\boldsymbol{\\phi}_B$ to check for DMP violations and quantify their magnitude.\n4.  **Flux Limiting and Re-analysis**: Create a new set of modified weights $\\tilde{w}_{ij} = \\max(w_{ij}, 0)$. This \"flux-limiting\" step enforces non-negativity, thereby guaranteeing that the resulting modified stiffness matrix $\\tilde{K}$ is an M-matrix. Assemble $\\tilde{K}$ and re-solve the system with the same boundary data. Check for DMP violations in this new solution. By construction, none should be found.\n\nThis procedure will be applied to the three specified test cases to demonstrate the link between mesh quality, matrix properties, and solution fidelity. Test case 1 uses a regular grid, which is Delaunay, ensuring no issues. Test cases 2 and 3 use a perturbed central node to create obtuse triangles, deliberately inducing negative weights and testing the consequences and the subsequent fix.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef process_case(Nx, Ny, perturbation, bc_func, tol=1e-9):\n    \"\"\"\n    Processes a single test case for the Laplace equation problem.\n\n    This function builds the mesh, assembles the stiffness matrix, solves the\n    FEM system, and computes the required metrics before and after applying\n    a flux limiter.\n    \"\"\"\n    # 1. Mesh Generation\n    x_coords = np.linspace(0.0, 1.0, Nx + 1)\n    y_coords = np.linspace(0.0, 1.0, Ny + 1)\n    xv, yv = np.meshgrid(x_coords, y_coords)\n    nodes = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    if perturbation:\n        p_idx, dx, dy = perturbation\n        nodes[p_idx, 0] += dx\n        nodes[p_idx, 1] += dy\n\n    triangles = []\n    for j in range(Ny):\n        for i in range(Nx):\n            # Node indices for the current quad\n            p1 = j * (Nx + 1) + i       # bottom-left\n            p2 = j * (Nx + 1) + i + 1     # bottom-right\n            p3 = (j + 1) * (Nx + 1) + i   # top-left\n            p4 = (j + 1) * (Nx + 1) + i + 1 # top-right\n            # Consistent diagonal split: bottom-left to top-right\n            triangles.append([p1, p2, p4])\n            triangles.append([p1, p4, p3])\n    triangles = np.array(triangles)\n    num_nodes = nodes.shape[0]\n\n    # 2. Assemble Edge Weights (Cotangent Formula)\n    weights = {}\n    for tri_indices in triangles:\n        p_indices = tri_indices\n        p_coords = nodes[p_indices]\n        \n        # Calculate cotangents for the three angles\n        # cot(alpha) = (v1 . v2) / |v1 x v2|_z\n        for i in range(3):\n            p1_idx, p2_idx, p3_idx = p_indices[i], p_indices[(i + 1) % 3], p_indices[(i + 2) % 3]\n            p1, p2, p3 = p_coords[i], p_coords[(i + 1) % 3], p_coords[(i + 2) % 3]\n            \n            v1, v2 = p2 - p1, p3 - p1\n            \n            dot_prod = np.dot(v1, v2)\n            cross_prod_z = v1[0] * v2[1] - v1[1] * v2[0]\n\n            if abs(cross_prod_z)  1e-14:\n                # Degenerate triangle, cotangent is infinite or undefined. Skip.\n                cot_angle = 0\n            else:\n                cot_angle = dot_prod / cross_prod_z\n\n            # Edge opposite to the angle at p1 is (p2,p3)\n            edge = tuple(sorted((p2_idx, p3_idx)))\n            weights[edge] = weights.get(edge, 0) + 0.5 * cot_angle\n\n    # 3. Analyze \"Before\" Case (Standard FEM)\n    monotone_before = all(w = -tol for w in weights.values())\n    \n    K_before = lil_matrix((num_nodes, num_nodes))\n    for (i, j), w in weights.items():\n        K_before[i, i] += w\n        K_before[j, j] += w\n        K_before[i, j] -= w\n        K_before[j, i] -= w\n    K_before = K_before.tocsc()\n    \n    is_boundary = (np.abs(nodes[:, 0] - 0.0)  tol) | (np.abs(nodes[:, 0] - 1.0)  tol) | \\\n                  (np.abs(nodes[:, 1] - 0.0)  tol) | (np.abs(nodes[:, 1] - 1.0)  tol)\n    boundary_nodes = np.where(is_boundary)[0]\n    interior_nodes = np.where(~is_boundary)[0]\n\n    phi_before = np.zeros(num_nodes)\n    phi_B = bc_func(nodes[boundary_nodes])\n    phi_before[boundary_nodes] = phi_B\n    \n    K_II = K_before[np.ix_(interior_nodes, interior_nodes)]\n    K_IB = K_before[np.ix_(interior_nodes, boundary_nodes)]\n    rhs = -K_IB.dot(phi_B)\n    \n    phi_I = spsolve(K_II, rhs)\n    phi_before[interior_nodes] = phi_I\n\n    m_B, M_B = (phi_B.min(), phi_B.max()) if phi_B.size  0 else (0.0, 0.0)\n    m_I, M_I = (phi_I.min(), phi_I.max()) if phi_I.size  0 else (0.0, 0.0)\n\n    violates_before = m_I  m_B - tol or M_I  M_B + tol\n    violation_magnitude_before = round(max(0.0, m_B - m_I) + max(0.0, M_I - M_B), 6)\n\n    # 4. Analyze \"After\" Case (with Flux Limiter)\n    limited_weights = {k: max(0.0, v) for k, v in weights.items()}\n    \n    K_after = lil_matrix((num_nodes, num_nodes))\n    for (i, j), w in limited_weights.items():\n        K_after[i, i] += w\n        K_after[j, j] += w\n        K_after[i, j] -= w\n        K_after[j, i] -= w\n    K_after = K_after.tocsc()\n\n    phi_after = np.zeros(num_nodes)\n    phi_after[boundary_nodes] = phi_B\n    K_II_after = K_after[np.ix_(interior_nodes, interior_nodes)]\n    K_IB_after = K_after[np.ix_(interior_nodes, boundary_nodes)]\n    rhs_after = -K_IB_after.dot(phi_B)\n    \n    phi_I_after = spsolve(K_II_after, rhs_after)\n    phi_after[interior_nodes] = phi_I_after\n\n    m_I_after, M_I_after = (phi_I_after.min(), phi_I_after.max()) if phi_I_after.size  0 else (0.0, 0.0)\n    violates_after = m_I_after  m_B - tol or M_I_after  M_B + tol\n\n    return [monotone_before, violates_before, violates_after, violation_magnitude_before]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    tol = 1e-9\n    \n    # Test Case 1: Well-behaved mesh\n    case1_params = {\n        'Nx': 16, 'Ny': 16,\n        'perturbation': None,\n        'bc_func': lambda p: p[:, 0]  # g(x,y)=x\n    }\n    \n    # Test Case 2: Pathological mesh, moderate distortion\n    Nx2, Ny2 = 16, 16\n    h2 = 1.0 / Nx2\n    dx2 = 0.5 * h2\n    center_node_idx2 = (Ny2 // 2) * (Nx2 + 1) + (Nx2 // 2)\n    case2_params = {\n        'Nx': Nx2, 'Ny': Ny2,\n        'perturbation': (center_node_idx2, dx2, 0.0),\n        'bc_func': lambda p: np.where((np.abs(p[:, 0] - 1.0)  tol) | (np.abs(p[:, 1] - 1.0)  tol), 1.0, 0.0)\n    }\n\n    # Test Case 3: Pathological mesh, stronger distortion\n    Nx3, Ny3 = 8, 8\n    h3 = 1.0 / Nx3\n    dx3 = 0.8 * h3\n    center_node_idx3 = (Ny3 // 2) * (Nx3 + 1) + (Nx3 // 2)\n    case3_params = {\n        'Nx': Nx3, 'Ny': Ny3,\n        'perturbation': (center_node_idx3, dx3, 0.0),\n        'bc_func': lambda p: np.where((np.abs(p[:, 0] - 1.0)  tol) | (np.abs(p[:, 1] - 1.0)  tol), 1.0, 0.0)\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    \n    results = []\n    for params in test_cases:\n        result = process_case(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond forward modeling, potential theory is the bedrock of geophysical inversion. This exercise applies your numerical modeling skills to a scenario with a multiply connected domain, mimicking a subsurface with distinct anomalous bodies. You will compute harmonic measures and use them to discover a fundamental non-uniqueness that arises when inverting gradient-only data, illustrating a core principle: the physics of potential fields dictates what properties of the subsurface we can uniquely resolve from external measurements. ",
            "id": "3612950",
            "problem": "Consider two-dimensional potential theory in a multiply connected domain. Let the computational domain be the closed square $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ with two circular holes removed, making the domain multiply connected. The holes are the open disks centered at $\\mathbf{c}_1=\\left(-0.3,0.0\\right)$ with radius $r_1=0.25$ and $\\mathbf{c}_2=\\left(0.35,0.1\\right)$ with radius $r_2=0.20$. Thus, the physical domain $\\Omega$ is the set of points in the square that are outside both disks. The outer boundary is the boundary of the square, and the two inner boundaries are the circumferences of the disks.\n\nYou will work with the Laplace equation $\\nabla^2 u = 0$ on $\\Omega$ using only the following fundamental base:\n- The superposition principle: if $u_1$ and $u_2$ solve $\\nabla^2 u = 0$ on $\\Omega$, then so does any linear combination $\\alpha u_1 + \\beta u_2$ for scalars $\\alpha$ and $\\beta$.\n- The maximum principle for harmonic functions: a non-constant harmonic function attains its extrema on the boundary.\n- The definition of harmonic measure for a boundary component: for a boundary partition $\\partial \\Omega = \\Gamma_{\\text{out}} \\cup \\Gamma_1 \\cup \\Gamma_2$, the harmonic measure $\\omega_j(\\mathbf{x})$ of $\\Gamma_j$ at $\\mathbf{x}\\in\\Omega$ is the unique harmonic function on $\\Omega$ that takes boundary value $1$ on $\\Gamma_j$ and $0$ on the other boundary components.\n- The uniqueness classes: Dirichlet boundary value problem has a unique solution, whereas the Neumann boundary value problem determines the solution only up to an additive constant.\n\nYour task is to compute discrete approximations to the harmonic measures for the three boundary components and to design and analyze a gradient-only inversion that reveals non-uniqueness. Use a finite difference discretization on a uniform Cartesian grid with $N = 129$ points per coordinate in the square. The two holes are imposed by masking grid nodes lying strictly inside the corresponding disks. For each discrete harmonic measure, impose boundary conditions as follows:\n- For the harmonic measure $\\omega_1$, impose $u=1$ on the inner hole at $\\mathbf{c}_1$ and $u=0$ on the other hole and on the outer square boundary.\n- For the harmonic measure $\\omega_2$, impose $u=1$ on the inner hole at $\\mathbf{c}_2$ and $u=0$ on the other hole and on the outer square boundary.\n- For the harmonic measure $\\omega_{\\text{out}}$, impose $u=1$ on the outer square boundary and $u=0$ on both inner holes.\n\nDiscretize $\\nabla^2 u = 0$ on the grid nodes that are not masked (i.e., nodes in $\\Omega$), using the standard five-point stencil. Treat the masked holes as embedded Dirichlet boundaries with constant values equal to the boundary data for their respective components; handle the outer square boundary as Dirichlet as well. Solve the resulting linear systems exactly to floating-point precision.\n\nDefine the following target interior points in physical coordinates for evaluation:\n- $\\mathbf{p}_0=(0.0,0.0)$,\n- $\\mathbf{p}_1=(-0.05,0.0)$,\n- $\\mathbf{p}_2=(0.65,-0.25)$,\n- $\\mathbf{p}_3=(0.15,0.15)$,\n- $\\mathbf{p}_4=(-0.6,0.4)$,\n- $\\mathbf{p}_5=(0.4,-0.5)$.\nMap each target to the nearest grid node and, if necessary, adjust to the nearest safe interior node whose four von Neumann neighbors also lie in $\\Omega$ to allow central differences.\n\nUse the computed harmonic measures to test fundamental properties and to set up an inversion problem that uses only gradient information:\n- Property test: verify that $\\omega_1(\\mathbf{p}_0)+\\omega_2(\\mathbf{p}_0)+\\omega_{\\text{out}}(\\mathbf{p}_0)$ equals $1$ within tolerance $\\varepsilon_1=10^{-6}$.\n- Proximity test: verify that at a point near the first hole (chosen as $\\mathbf{p}_1$), the value $\\omega_1$ exceeds both $\\omega_2$ and $\\omega_{\\text{out}}$.\n- Inversion design: let the true boundary constants be $\\boldsymbol{\\alpha}^{\\star} = \\left[\\alpha_1^{\\star},\\alpha_2^{\\star},\\alpha_{\\text{out}}^{\\star}\\right] = \\left[0.8,-0.4,0.2\\right]$. By linearity, the potential corresponding to these boundary constants is $u(\\mathbf{x})=\\alpha_1^{\\star}\\,\\omega_1(\\mathbf{x})+\\alpha_2^{\\star}\\,\\omega_2(\\mathbf{x})+\\alpha_{\\text{out}}^{\\star}\\,\\omega_{\\text{out}}(\\mathbf{x})$. However, suppose that only the gradient field $\\nabla u$ is observed at the $K=6$ interior points $\\mathbf{p}_k$, $k\\in\\{0,1,2,3,4,5\\}$, and consider the linear system for the unknown boundary constants:\n$$\n\\begin{bmatrix}\n\\nabla \\omega_1(\\mathbf{p}_0)  \\nabla \\omega_2(\\mathbf{p}_0)  \\nabla \\omega_{\\text{out}}(\\mathbf{p}_0) \\\\\n\\vdots  \\vdots  \\vdots \\\\\n\\nabla \\omega_1(\\mathbf{p}_5)  \\nabla \\omega_2(\\mathbf{p}_5)  \\nabla \\omega_{\\text{out}}(\\mathbf{p}_5)\n\\end{bmatrix}\n\\begin{bmatrix}\n\\alpha_1 \\\\ \\alpha_2 \\\\ \\alpha_{\\text{out}}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\nabla u(\\mathbf{p}_0) \\\\ \\vdots \\\\ \\nabla u(\\mathbf{p}_5)\n\\end{bmatrix}.\n$$\nBecause $\\nabla \\omega_1+\\nabla \\omega_2+\\nabla \\omega_{\\text{out}}=\\nabla 1=\\mathbf{0}$ at each point, this gradient-only system is rank-deficient and non-unique up to an additive constant in $\\boldsymbol{\\alpha}$. Compute the numerical rank using the singular value decomposition with a threshold $\\tau=10^{-10}$.\n\nTo illustrate the non-uniqueness and its remedy:\n- Compute the minimal-norm least-squares estimate $\\widehat{\\boldsymbol{\\alpha}}$ from the gradient-only data and verify it differs from $\\boldsymbol{\\alpha}^{\\star}$ by an additive constant vector, i.e., $\\widehat{\\boldsymbol{\\alpha}} - \\boldsymbol{\\alpha}^{\\star} = c\\,[1,1,1]^T$ for some scalar $c$, within tolerance $\\varepsilon_2=10^{-6}$.\n- Impose a gauge by fixing $\\alpha_{\\text{out}}=0$ and solve the reduced least-squares problem to obtain $\\widetilde{\\boldsymbol{\\alpha}}$ with $\\widetilde{\\alpha}_{\\text{out}}=0$. Compare $\\widetilde{\\boldsymbol{\\alpha}}$ against the gauge-fixed truth $\\boldsymbol{\\alpha}^{\\star}_{\\text{gf}}=\\boldsymbol{\\alpha}^{\\star}-\\alpha_{\\text{out}}^{\\star}\\,[1,1,1]^T$, and report the Euclidean norm of the error $\\|\\widetilde{\\boldsymbol{\\alpha}}-\\boldsymbol{\\alpha}^{\\star}_{\\text{gf}}\\|_2$ as a floating-point number.\n\nTest suite and required outputs:\n- Use $N=129$, $\\mathbf{c}_1=\\left(-0.3,0.0\\right)$, $r_1=0.25$, $\\mathbf{c}_2=\\left(0.35,0.1\\right)$, $r_2=0.20$, $\\varepsilon_1=10^{-6}$, $\\varepsilon_2=10^{-6}$, and $\\tau=10^{-10}$.\n- Your program should compute the following five results in order:\n  1. A boolean indicating whether $\\omega_1(\\mathbf{p}_0)+\\omega_2(\\mathbf{p}_0)+\\omega_{\\text{out}}(\\mathbf{p}_0)$ is within $\\varepsilon_1$ of $1$.\n  2. A boolean indicating whether $\\omega_1(\\mathbf{p}_1)\\max\\{\\omega_2(\\mathbf{p}_1),\\omega_{\\text{out}}(\\mathbf{p}_1)\\}$.\n  3. An integer equal to the numerical rank of the gradient-only design matrix with threshold $\\tau$.\n  4. A boolean indicating whether there exists an additive constant $c$ such that $\\widehat{\\boldsymbol{\\alpha}} - \\boldsymbol{\\alpha}^{\\star} \\approx c\\,[1,1,1]^T$ within $\\varepsilon_2$.\n  5. A float equal to $\\|\\widetilde{\\boldsymbol{\\alpha}}-\\boldsymbol{\\alpha}^{\\star}_{\\text{gf}}\\|_2$.\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order above, for example, $\\left[\\text{True},\\text{True},2,\\text{True},0.000001\\right]$. No additional text or formatting is allowed in the output.",
            "solution": "The user has provided a valid, well-posed, and scientifically grounded problem statement. All necessary data and conditions for a unique solution to the defined computational tasks are provided. The problem is a standard exercise in computational potential theory, involving the numerical solution of the Laplace equation using the finite difference method and the analysis of an associated inverse problem.\n\nThe problem will be solved by following these steps:\n1.  Discretize the continuous domain $\\Omega$ onto a uniform Cartesian grid and identify the interior and boundary nodes.\n2.  Formulate the finite difference approximation of the Laplace equation, leading to a sparse linear system.\n3.  Solve this linear system for three different sets of Dirichlet boundary conditions to compute the discrete harmonic measures $\\omega_1$, $\\omega_2$, and $\\omega_{\\text{out}}$.\n4.  Evaluate the computed harmonic measures and their gradients at specified interior points.\n5.  Perform the required tests: verifying the sum property of harmonic measures, checking the proximity effect, and analyzing the rank and non-uniqueness of a gradient-based inversion problem.\n6.  Demonstrate the remedy for non-uniqueness using gauge fixing and compute the final required metrics.\n\n**1. Discretization and Domain Representation**\nThe computational domain is a square $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ with two circular holes. We discretize this domain using a uniform Cartesian grid of $N \\times N$ points, where $N=129$. The grid coordinates are given by $x_j = -1 + j h$ and $y_i = -1 + i h$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$, with a grid spacing of $h = 2/(N-1)$.\n\nThe physical domain $\\Omega$ is represented by the set of grid nodes that do not fall strictly inside the open disks defined by $(\\mathbf{x}-\\mathbf{c}_1)^2  r_1^2$ and $(\\mathbf{x}-\\mathbf{c}_2)^2  r_2^2$. We create a boolean mask to identify these valid domain nodes. The boundary $\\partial\\Omega$ is partitioned into three components: the outer square boundary $\\Gamma_{\\text{out}}$ and the two inner hole boundaries, $\\Gamma_1$ and $\\Gamma_2$. On the discrete grid, these boundaries correspond to the set of domain nodes that are adjacent to either the exterior of the square or one of the masked holes. The remaining domain nodes are classified as interior nodes.\n\n**2. Finite Difference Formulation for the Laplace Equation**\nThe Laplace equation, $\\nabla^2 u = 0$, is approximated at each interior grid node $(i,j)$ using the standard five-point stencil:\n$$\n\\nabla^2 u(x_j, y_i) \\approx \\frac{u_{i,j+1} + u_{i,j-1} + u_{i+1,j} + u_{i-1,j} - 4u_{i,j}}{h^2} = 0\n$$\nThis simplifies to a linear equation for the potential $u$ at each interior node:\n$$\n4u_{i,j} - u_{i,j+1} - u_{i,j-1} - u_{i+1,j} - u_{i-1,j} = 0\n$$\nBy assembling one such equation for every interior node, we obtain a large, sparse system of linear equations of the form $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$. Here, $\\mathbf{u}_{\\text{int}}$ is a vector of the unknown potential values at all interior nodes. The matrix $A$ is the discrete Laplacian operator, containing the coefficients $4$ on the diagonal and $-1$ for each neighboring interior node. The right-hand side vector $\\mathbf{b}$ is non-zero when a neighbor of an interior node is a boundary node, incorporating the known Dirichlet boundary values into the system.\n\n**3. Computation of Harmonic Measures**\nThe harmonic measure $\\omega_k(\\mathbf{x})$ of a boundary component $\\Gamma_k$ is the harmonic function on $\\Omega$ that equals $1$ on $\\Gamma_k$ and $0$ on all other boundary components. We compute the discrete approximations to the three harmonic measures, $\\omega_1$, $\\omega_2$, and $\\omega_{\\text{out}}$, by solving the linear system $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$ three times, each with a different right-hand side $\\mathbf{b}$ corresponding to the boundary conditions:\n-   For $\\omega_1$: $u=1$ on $\\Gamma_1$, $u=0$ on $\\Gamma_2$ and $\\Gamma_{\\text{out}}$.\n-   For $\\omega_2$: $u=1$ on $\\Gamma_2$, $u=0$ on $\\Gamma_1$ and $\\Gamma_{\\text{out}}$.\n-   For $\\omega_{\\text{out}}$: $u=1$ on $\\Gamma_{\\text{out}}$, $u=0$ on $\\Gamma_1$ and $\\Gamma_2$.\nThe resulting sparse linear systems are efficiently solved using a direct solver, such as `scipy.sparse.linalg.spsolve`.\n\n**4. Analysis of the Gradient-Based Inverse Problem**\nBy the superposition principle, a harmonic function $u$ with piecewise constant boundary values $\\alpha_1, \\alpha_2, \\alpha_{\\text{out}}$ on $\\Gamma_1, \\Gamma_2, \\Gamma_{\\text{out}}$ is given by the linear combination:\n$$\nu(\\mathbf{x}) = \\alpha_1 \\omega_1(\\mathbf{x}) + \\alpha_2 \\omega_2(\\mathbf{x}) + \\alpha_{\\text{out}} \\omega_{\\text{out}}(\\mathbf{x})\n$$\nThe gradient of the potential is therefore:\n$$\n\\nabla u(\\mathbf{x}) = \\alpha_1 \\nabla\\omega_1(\\mathbf{x}) + \\alpha_2 \\nabla\\omega_2(\\mathbf{x}) + \\alpha_{\\text{out}} \\nabla\\omega_{\\text{out}}(\\mathbf{x})\n$$\nThe inverse problem attempts to recover the constants $\\boldsymbol{\\alpha} = [\\alpha_1, \\alpha_2, \\alpha_{\\text{out}}]^T$ from measurements of the gradient $\\nabla u$ at several interior points $\\mathbf{p}_k$. This sets up a linear system $G\\boldsymbol{\\alpha} = \\mathbf{d}$, where $G$ is the design matrix whose columns are the stacked gradients of the harmonic measures, and $\\mathbf{d}$ is the vector of observed gradients.\n\nA fundamental property of harmonic measures is that their sum is unity, $\\sum_k \\omega_k(\\mathbf{x}) = 1$, for any $\\mathbf{x} \\in \\Omega$. This is a consequence of the maximum principle, as the function $v(\\mathbf{x}) = \\sum_k \\omega_k(\\mathbf{x})$ is harmonic and has boundary value $1$ everywhere on $\\partial\\Omega$. By uniqueness, $v(\\mathbf{x})$ must be identically $1$. Taking the gradient of this identity yields $\\sum_k \\nabla\\omega_k(\\mathbf{x}) = \\nabla 1 = \\mathbf{0}$. This implies that the columns of the design matrix $G$ are linearly dependent, as their sum is the zero vector. Consequently, the matrix $G$ is rank-deficient (its rank is $2$, not $3$), and the inverse problem does not have a unique solution. The non-uniqueness is an additive constant: if $\\boldsymbol{\\alpha}$ is a solution, so is $\\boldsymbol{\\alpha} + c[1,1,1]^T$ for any scalar $c$.\n\nWe analyze this by:\n1.  Computing the numerical rank of $G$ via its singular values, confirming it is $2$.\n2.  Finding the minimal-norm least-squares solution $\\widehat{\\boldsymbol{\\alpha}}$ using `numpy.linalg.lstsq`. This solution is unique but differs from the true constants $\\boldsymbol{\\alpha}^{\\star}$ by a vector proportional to $[1,1,1]^T$.\n3.  Restoring uniqueness by gauge fixing. We impose the constraint $\\alpha_{\\text{out}}=0$, remove the third column from $G$, and solve the resulting (now full-rank) least-squares problem for $[\\alpha_1, \\alpha_2]^T$. The solution $\\widetilde{\\boldsymbol{\\alpha}}$ is then compared to the correspondingly gauge-fixed true vector $\\boldsymbol{\\alpha}^{\\star}_{\\text{gf}} = \\boldsymbol{\\alpha}^{\\star} - \\alpha_{\\text{out}}^{\\star}[1,1,1]^T$.\n\nGradients at the target points are computed using a second-order central difference approximation on the grid, which requires that the evaluation points and their four von Neumann neighbors are all interior nodes (i.e., \"safe\" nodes). We map each physical target point to the nearest such safe grid node.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Laplace equation for harmonic measures in a multiply connected domain\n    and performs an analysis of a gradient-based inverse problem.\n    \"\"\"\n    # 1. Define problem parameters\n    N = 129\n    c1 = np.array([-0.3, 0.0])\n    r1 = 0.25\n    c2 = np.array([0.35, 0.1])\n    r2 = 0.20\n    target_points_phys = [\n        (0.0, 0.0), (-0.05, 0.0), (0.65, -0.25),\n        (0.15, 0.15), (-0.6, 0.4), (0.4, -0.5)\n    ]\n    alpha_star = np.array([0.8, -0.4, 0.2])\n    epsilon1 = 1e-6\n    epsilon2 = 1e-6\n    tau = 1e-10\n\n    # 2. Set up grid and domain masks\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    h = x[1] - x[0]\n    X, Y = np.meshgrid(x, y)\n\n    mask_hole1 = (X - c1[0])**2 + (Y - c1[1])**2  r1**2\n    mask_hole2 = (X - c2[0])**2 + (Y - c2[1])**2  r2**2\n    is_domain = ~mask_hole1  ~mask_hole2\n\n    # 3. Identify boundary and interior nodes\n    bdy_out = np.zeros((N, N), dtype=bool)\n    bdy_out[[0, -1], :] = True\n    bdy_out[:, [0, -1]] = True\n    bdy_out[~is_domain] = False\n\n    def get_inner_boundary(hole_mask):\n        dilated_mask = np.copy(hole_mask)\n        rows, cols = np.where(hole_mask)\n        for r, c in zip(rows, cols):\n            if r  0: dilated_mask[r-1, c] = True\n            if r  N-1: dilated_mask[r+1, c] = True\n            if c  0: dilated_mask[r, c-1] = True\n            if c  N-1: dilated_mask[r, c+1] = True\n        return dilated_mask  is_domain\n\n    bdy_1 = get_inner_boundary(mask_hole1)\n    bdy_2 = get_inner_boundary(mask_hole2)\n    bdy_1[bdy_out] = False\n    bdy_2[bdy_out] = False\n    bdy_1[bdy_2] = False\n\n    bdy_all = bdy_out | bdy_1 | bdy_2\n    interior_nodes = is_domain  ~bdy_all\n\n    interior_indices = np.where(interior_nodes)\n    num_interior = len(interior_indices[0])\n    interior_map = -np.ones((N, N), dtype=int)\n    interior_map[interior_indices] = np.arange(num_interior)\n\n    # 4. Assemble the finite difference matrix A\n    A = lil_matrix((num_interior, num_interior))\n    for k in range(num_interior):\n        i, j = interior_indices[0][k], interior_indices[1][k]\n        A[k, k] = 4.0\n        for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n            if interior_nodes[ni, nj]:\n                A[k, interior_map[ni, nj]] = -1.0\n    A = A.tocsc()\n\n    # 5. Solve for harmonic measures\n    def solve_laplace(bc_out_val, bc_1_val, bc_2_val):\n        u_full = np.zeros((N, N))\n        u_full[bdy_out] = bc_out_val\n        u_full[bdy_1] = bc_1_val\n        u_full[bdy_2] = bc_2_val\n        \n        b = np.zeros(num_interior)\n        for k in range(num_interior):\n            i, j = interior_indices[0][k], interior_indices[1][k]\n            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if bdy_all[ni, nj]:\n                    b[k] += u_full[ni, nj]\n        \n        u_interior_flat = spsolve(A, b)\n        u_full[interior_indices] = u_interior_flat\n        return u_full\n\n    omega1_grid = solve_laplace(0.0, 1.0, 0.0)\n    omega2_grid = solve_laplace(0.0, 0.0, 1.0)\n    omega_out_grid = solve_laplace(1.0, 0.0, 0.0)\n\n    # 6. Find safe interior nodes for evaluation\n    padded_interior = np.pad(interior_nodes, 1, mode='constant', constant_values=False)\n    is_safe = np.zeros_like(interior_nodes)\n    for i in range(N):\n        for j in range(N):\n            if (padded_interior[i+1, j+1] and padded_interior[i, j+1] and\n                padded_interior[i+2, j+1] and padded_interior[i+1, j] and\n                padded_interior[i+1, j+2]):\n                is_safe[i, j] = True\n\n    target_indices = []\n    for p_x, p_y in target_points_phys:\n        j_approx = int(round((p_x - (-1.0)) / h))\n        i_approx = int(round((p_y - (-1.0)) / h))\n        \n        if is_safe[i_approx, j_approx]:\n            target_indices.append((i_approx, j_approx))\n            continue\n        \n        dist = 1\n        found = False\n        while not found:\n            min_dist_sq = float('inf')\n            best_idx = None\n            for i_s in range(max(0, i_approx - dist), min(N, i_approx + dist + 1)):\n                for j_s in range(max(0, j_approx - dist), min(N, j_approx + dist + 1)):\n                    if max(abs(i_s - i_approx), abs(j_s - j_approx)) == dist:\n                        if is_safe[i_s, j_s]:\n                            dist_sq = (i_s - i_approx)**2 + (j_s - j_approx)**2\n                            if dist_sq  min_dist_sq:\n                                min_dist_sq = dist_sq\n                                best_idx = (i_s, j_s)\n                                found = True\n            if found:\n                target_indices.append(best_idx)\n            dist += 1\n    \n    # 7. Perform required tests\n    results = []\n\n    # Test 1: Sum of harmonic measures\n    p0_idx = target_indices[0]\n    sum_at_p0 = omega1_grid[p0_idx] + omega2_grid[p0_idx] + omega_out_grid[p0_idx]\n    results.append(np.abs(sum_at_p0 - 1.0)  epsilon1)\n\n    # Test 2: Proximity test\n    p1_idx = target_indices[1]\n    val_w1_p1 = omega1_grid[p1_idx]\n    val_w2_p1 = omega2_grid[p1_idx]\n    val_wout_p1 = omega_out_grid[p1_idx]\n    results.append(val_w1_p1  max(val_w2_p1, val_wout_p1))\n\n    # Inversion problem setup\n    def get_grad(grid, idx):\n        i, j = idx\n        grad_x = (grid[i, j+1] - grid[i, j-1]) / (2.0 * h)\n        grad_y = (grid[i+1, j] - grid[i-1, j]) / (2.0 * h)\n        return np.array([grad_x, grad_y])\n\n    G = np.zeros((len(target_points_phys) * 2, 3))\n    for k, idx in enumerate(target_indices):\n        G[2*k:2*k+2, 0] = get_grad(omega1_grid, idx)\n        G[2*k:2*k+2, 1] = get_grad(omega2_grid, idx)\n        G[2*k:2*k+2, 2] = get_grad(omega_out_grid, idx)\n\n    # Test 3: Numerical rank\n    s = np.linalg.svd(G, compute_uv=False)\n    results.append(np.sum(s  tau))\n\n    # Test 4: Non-uniqueness check\n    d = G @ alpha_star\n    alpha_hat = np.linalg.lstsq(G, d, rcond=None)[0]\n    diff = alpha_hat - alpha_star\n    c = np.mean(diff)\n    results.append(np.allclose(diff, c, atol=epsilon2))\n\n    # Test 5: Gauge-fixed solution error\n    G_reduced = G[:, :2]\n    alpha_tilde_reduced = np.linalg.lstsq(G_reduced, d, rcond=None)[0]\n    alpha_tilde = np.array([alpha_tilde_reduced[0], alpha_tilde_reduced[1], 0.0])\n    alpha_star_gf = alpha_star - alpha_star[2]\n    results.append(np.linalg.norm(alpha_tilde - alpha_star_gf))\n\n    # 8. Final Output\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]},{results[4]}]\")\n\nsolve()\n```"
        }
    ]
}