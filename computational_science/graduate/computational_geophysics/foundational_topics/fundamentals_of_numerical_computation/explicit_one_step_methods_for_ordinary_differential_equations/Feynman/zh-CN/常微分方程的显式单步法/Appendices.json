{
    "hands_on_practices": [
        {
            "introduction": "在数值模拟中，我们使用的离散格式并不仅仅是原始偏微分方程的一个近似，它本身也满足一个“修正”的偏微分方程。通过推导此修正方程，我们可以揭示出数值格式引入的非物理效应，例如数值耗散或频散。这项实践将引导你通过泰勒展开分析一个常用的一阶迎风格式，从而揭示其内在的数值黏性，这是诊断和理解计算地球物理模拟结果的一项基本技能 。",
            "id": "3590104",
            "problem": "考虑计算地球物理学中的一维被动示踪剂输运问题，其控制方程为线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a>0$ 为常数。在间距为 $\\Delta x$ 的均匀空间网格上，对空间导数采用与 $a>0$ 一致的一阶迎风有限差分格式，然后使用时间步长为 $h$ 的显式前向欧拉单步法对得到的半离散常微分方程进行时间积分。令 $u_{i}^{n}$ 表示在网格点 $x_{i}$ 和时间层 $t_{n}$ 处对 $u(x_{i}, t_{n})$ 的数值近似。\n\n从守恒定律和给定的离散化方法出发，通过对光滑函数 $u(x,t)$ 的时间和空间离散项进行系统性展开，并利用原始偏微分方程消去时间导数以空间导数替换，推导该全离散格式满足的修正偏微分方程，要求精确到 $h$ 和 $\\Delta x$ 的领先非平凡阶。根据你推导出的修正方程，识别出领先阶人工扩散项，并仅用 $a$、$h$ 和 $\\Delta x$ 来量化其系数。\n\n以领先阶数值扩散项系数的闭式解析表达式形式给出你的最终答案。最终表达式无需四舍五入，也不应包含任何单位。",
            "solution": "该问题要求推导应用于一维线性平流方程的数值格式的领先阶人工扩散项的系数。推导过程通过分析该离散格式所满足的修正偏微分方程来进行。\n\n控制偏微分方程 (PDE) 是线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0\n$$\n其中 $u = u(x, t)$ 是输运量，$t$ 是时间，$x$ 是空间坐标，$a>0$ 是一个恒定的平流速度。\n\n该数值格式构建在空间步长为 $\\Delta x$、时间步长为 $h$ 的均匀网格上。\n空间导数 $u_x$ 使用一阶迎风有限差分进行离散。由于平流速度 $a$ 为正，所以“迎风”方向是向左（$x$ 减小的方向），因此使用一阶后向差分：\n$$\nu_{x}(x_{i}, t_{n}) \\approx \\frac{u(x_{i}, t_{n}) - u(x_{i} - \\Delta x, t_{n})}{\\Delta x} = \\frac{u_{i}^{n} - u_{i-1}^{n}}{\\Delta x}\n$$\n将此式代入控制偏微分方程，得到半离散常微分方程组 (ODEs)：\n$$\n\\frac{du_{i}(t)}{dt} + a \\left( \\frac{u_{i}(t) - u_{i-1}(t)}{\\Delta x} \\right) = 0\n$$\n然后使用显式前向欧拉法对该方程组进行时间积分。对于形如 $\\frac{dy}{dt} = f(y)$ 的常微分方程，前向欧拉法为 $\\frac{y^{n+1} - y^{n}}{h} = f(y^{n})$。将此方法应用于我们的半离散系统，我们得到：\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{h} = -a \\left( \\frac{u_{i}^{n} - u_{i-1}^{n}}{\\Delta x} \\right)\n$$\n这就是该格式的全离散有限差分方程。\n\n为了推导修正偏微分方程，我们对全离散方程中的每一项围绕网格点 $(x_{i}, t_{n})$ 进行泰勒级数展开。我们假设解 $u(x,t)$ 足够光滑。\n\n含时项 $u_{i}^{n+1}$ 的展开式为：\n$$\nu_{i}^{n+1} = u(x_{i}, t_{n}+h) = u(x_i, t_n) + h \\frac{\\partial u}{\\partial t} + \\frac{h^{2}}{2!} \\frac{\\partial^{2} u}{\\partial t^{2}} + O(h^{3})\n$$\n空间位移项 $u_{i-1}^{n}$ 的展开式为：\n$$\nu_{i-1}^{n} = u(x_{i}-\\Delta x, t_{n}) = u(x_i, t_n) - \\Delta x \\frac{\\partial u}{\\partial x} + \\frac{(\\Delta x)^{2}}{2!} \\frac{\\partial^{2} u}{\\partial x^{2}} - \\frac{(\\Delta x)^{3}}{3!} \\frac{\\partial^{3} u}{\\partial x^{3}} + O((\\Delta x)^{4})\n$$\n使用下标表示法表示偏导数（例如，$u_t = \\frac{\\partial u}{\\partial t}$），并在点 $(x_i, t_n)$ 处计算所有导数，展开式为：\n$$\nu_{i}^{n+1} = u + h u_{t} + \\frac{h^{2}}{2} u_{tt} + O(h^{3})\n$$\n$$\nu_{i-1}^{n} = u - \\Delta x u_{x} + \\frac{(\\Delta x)^{2}}{2} u_{xx} + O((\\Delta x)^{3})\n$$\n现在，将这些展开式代入离散格式。我们首先将格式重新整理为：\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{h} + a\\frac{u_{i}^{n} - u_{i-1}^{n}}{\\Delta x} = 0\n$$\n代入这两项的展开式：\n时间差分项变为：\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{h} = \\frac{1}{h} \\left( \\left( u + h u_{t} + \\frac{h^{2}}{2} u_{tt} + \\dots \\right) - u \\right) = u_{t} + \\frac{h}{2} u_{tt} + O(h^{2})\n$$\n空间差分项变为：\n$$\na\\frac{u_{i}^{n} - u_{i-1}^{n}}{\\Delta x} = \\frac{a}{\\Delta x} \\left( u - \\left( u - \\Delta x u_{x} + \\frac{(\\Delta x)^{2}}{2} u_{xx} - \\dots \\right) \\right) = \\frac{a}{\\Delta x} \\left( \\Delta x u_{x} - \\frac{(\\Delta x)^{2}}{2} u_{xx} + \\dots \\right) = a u_{x} - \\frac{a \\Delta x}{2} u_{xx} + O((\\Delta x)^{2})\n$$\n将这些展开项合并回方程中：\n$$\n\\left(u_{t} + \\frac{h}{2} u_{tt} + \\dots \\right) + \\left(a u_{x} - \\frac{a \\Delta x}{2} u_{xx} + \\dots \\right) = 0\n$$\n将各项分组，我们得到：\n$$\n(u_{t} + a u_{x}) + \\left( \\frac{h}{2} u_{tt} - \\frac{a \\Delta x}{2} u_{xx} \\right) + \\text{H.O.T.} = 0\n$$\n其中 H.O.T. 代表高阶项。对于满足原始 PDE 的光滑解 $u$，$(u_{t} + a u_{x})$ 项恰好为零。剩余的项代表了数值格式的截断误差。修正 PDE 是数值解实际求解的方程，即原始 PDE 加上领先阶截断误差项：\n$$\nu_{t} + a u_{x} = - \\left( \\frac{h}{2} u_{tt} - \\frac{a \\Delta x}{2} u_{xx} \\right) + \\text{H.O.T.} = \\frac{a \\Delta x}{2} u_{xx} - \\frac{h}{2} u_{tt} + \\text{H.O.T.}\n$$\n问题要求我们使用原始 PDE $u_t = -a u_x$ 来消去时间导数，用空间导数替换。假设 $u$ 足够光滑，我们可以对该关系式求导以找到 $u_{tt}$ 的表达式：\n$$\nu_{tt} = \\frac{\\partial}{\\partial t}(u_{t}) = \\frac{\\partial}{\\partial t}(-a u_{x})\n$$\n由于 $a$ 是常数且对于光滑函数导数可交换（$u_{tx} = u_{xt}$），我们有：\n$$\nu_{tt} = -a \\frac{\\partial}{\\partial t} \\left(\\frac{\\partial u}{\\partial x}\\right) = -a \\frac{\\partial}{\\partial x} \\left(\\frac{\\partial u}{\\partial t}\\right) = -a \\frac{\\partial}{\\partial x}(u_{t})\n$$\n再次代入 $u_t = -a u_x$：\n$$\nu_{tt} = -a \\frac{\\partial}{\\partial x}(-a u_{x}) = a^{2} \\frac{\\partial^{2} u}{\\partial x^{2}} = a^{2} u_{xx}\n$$\n现在，将 $u_{tt}$ 的这个结果代回修正方程中：\n$$\nu_{t} + a u_{x} = \\frac{a \\Delta x}{2} u_{xx} - \\frac{h}{2} (a^{2} u_{xx}) + \\text{H.O.T.}\n$$\n合并含有 $u_{xx}$ 的项：\n$$\nu_{t} + a u_{x} = \\left( \\frac{a \\Delta x}{2} - \\frac{a^{2} h}{2} \\right) u_{xx} + \\text{H.O.T.}\n$$\n这就是修正的平流-扩散方程。右侧与 $u_{xx}$ 成正比的项是领先阶人工扩散（或数值扩散）项。该项的系数就是人工扩散系数。\n经检视，$u_{xx}$ 项的系数为：\n$$\nD_{\\text{num}} = \\frac{a \\Delta x}{2} - \\frac{a^{2} h}{2}\n$$\n这就是所要求的领先阶数值扩散项的系数表达式。",
            "answer": "$$\\boxed{\\frac{a \\Delta x}{2} - \\frac{a^{2} h}{2}}$$"
        },
        {
            "introduction": "在掌握了如何分析数值格式的精度和内在行为之后，确保模拟过程的稳定性是下一个关键步骤。不稳定的数值方法会导致解随时间无限增长，从而产生无意义的结果。此实践将指导你对一个高阶强稳定保持（SSPRK）方法进行严格的线性稳定性分析，你需要推导该方法的时间步长限制，即著名的Courant-Friedrichs-Lewy (CFL) 条件，这要求你结合空间离散算子的谱特性和时间积分方法的稳定性域来进行分析 。",
            "id": "3590090",
            "problem": "考虑线性一维平流方程 $u_t + a\\,u_x = 0$，其中常数波速 $a>0$，定义在周期性域上，并在一维均匀网格上进行空间离散，网格间距为 $\\Delta x>0$，采用一阶迎风差分格式。用 $y(t) \\in \\mathbb{C}^N$ 表示收集了网格点值的半离散状态向量，半离散化形式为 $y'(t) = A\\,y(t)$，其中 $A \\in \\mathbb{C}^{N \\times N}$ 是与迎风格式相关的循环矩阵。您将使用三阶三步强稳定性保持 Runge–Kutta 方法 (SSPRK(3,3)) 对该常微分方程 (ODE) 进行时间推进。对于线性常系数系统 $y' = A\\,y$，如果由 SSPRK(3,3) 稳定性多项式 $R(z)$ 定义的单步放大因子对 $A$ 的所有特征值 $\\lambda_k$ 都满足 $\\lvert R(h\\,\\lambda_k) \\rvert \\le 1$，则称时间步长 $h>0$ 是线性稳定的。\n\n从以下基本原理出发：\n- 使用带周期性边界条件的迎风差分法对 $u_t + a\\,u_x = 0$ 进行半离散化 $y' = A\\,y$，会产生一个正规循环矩阵 $A$，该矩阵可通过离散傅里叶变换对角化，其特征值依赖于傅里叶波数。\n- 应用于线性系统 $y' = A\\,y$ 的显式单步法的稳定性要求是，该方法的稳定性多项式 $R(z)$ 对 $A$ 的所有特征值 $\\lambda_k$ 都满足 $\\lvert R(h\\,\\lambda_k) \\rvert \\le 1$。\n\n您的任务是，从第一性原理出发，不引用任何关于 $R(z)$ 或 $A$ 的特征值的预先给定的公式，推导出应用于此半离散化的 SSPRK(3,3) 方法的最大稳定时间步长 $h_{\\max}$（以秒为单位），并用 $a$ 和 $\\Delta x$ 表示。然后，实现一个程序，为下面指定的每个测试用例计算 $h_{\\max}$。将每个 $h_{\\max}$ 以秒为单位表示，并四舍五入到八位小数。\n\n要求的最终输出格式是包含在方括号中的逗号分隔列表的单行，例如，“[0.12345678,0.87654321]”。列表中不得有空格。\n\n使用以下参数值测试套件，每个参数值被解释为 $(a,\\Delta x)$，单位分别为米/秒（对于 $a$）和米（对于 $\\Delta x$）：\n1. $(1.0,\\,1.0)$\n2. $(2.0,\\,1.0)$\n3. $(0.5,\\,0.1)$\n4. $(1000.0,\\,1.0)$\n5. $(1.0,\\,10^{-3})$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其顺序与上述测试用例相对应，每个条目等于以秒为单位的 $h_{\\max}$，四舍五入到八位小数。",
            "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它提出了一个偏微分方程数值分析中的标准、可解问题。我们现在将从第一性原理开始进行形式推导。\n\n目标是找到三阶强稳定性保持 Runge-Kutta (SSPRK(3,3)) 方法应用于线性平流方程 $u_t + a u_x = 0$（常数波速 $a>0$）的半离散化时的最大稳定时间步长 $h_{\\max}$。空间离散采用一阶迎风格式，在周期性域上，网格间距为 $\\Delta x$。\n\n推导过程分为四个主要步骤：\n1.  推导 SSPRK(3,3) 方法的稳定性多项式 $R(z)$。\n2.  推导空间离散矩阵 $A$ 的特征值 $\\lambda_k$。\n3.  通过将离散化系统的特征值与时间步进法的稳定区域联系起来，建立稳定性条件。\n4.  求解最大 Courant-Friedrichs-Lewy (CFL) 数，并随后求解 $h_{\\max}$。\n\n**1. SSPRK(3,3) 稳定性多项式**\n\nSSPRK(3,3) 方法通过以下三个阶段为常微分方程 $y'(t) = f(y(t))$ 定义：\n$$ y^{(1)} = y_n + h f(y_n) $$\n$$ y^{(2)} = \\frac{3}{4} y_n + \\frac{1}{4} \\left( y^{(1)} + h f(y^{(1)}) \\right) $$\n$$ y_{n+1} = \\frac{1}{3} y_n + \\frac{2}{3} \\left( y^{(2)} + h f(y^{(2)}) \\right) $$\n为找到稳定性多项式，我们将此方法应用于线性测试方程 $y' = \\lambda y$，其中 $\\lambda \\in \\mathbb{C}$。在此背景下，$f(y) = \\lambda y$。令 $z = h\\lambda$。各阶段变为：\n$$ y^{(1)} = y_n + z y_n = (1+z) y_n $$\n$$ y^{(2)} = \\frac{3}{4} y_n + \\frac{1}{4} (y^{(1)} + z y^{(1)}) = \\frac{3}{4} y_n + \\frac{1}{4}(1+z)y^{(1)} = \\left[ \\frac{3}{4} + \\frac{1}{4}(1+z)^2 \\right] y_n $$\n展开括号中的项：\n$$ \\frac{3}{4} + \\frac{1}{4}(1 + 2z + z^2) = \\frac{3}{4} + \\frac{1}{4} + \\frac{1}{2}z + \\frac{1}{4}z^2 = 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 $$\n因此，$y^{(2)} = (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) y_n$。最后，第三阶段给出 $y_{n+1}$：\n$$ y_{n+1} = \\frac{1}{3} y_n + \\frac{2}{3}(y^{(2)} + z y^{(2)}) = \\frac{1}{3} y_n + \\frac{2}{3}(1+z)y^{(2)} $$\n代入 $y^{(2)}$ 的表达式：\n$$ y_{n+1} = \\left[ \\frac{1}{3} + \\frac{2}{3}(1+z)\\left(1 + \\frac{1}{2}z + \\frac{1}{4}z^2\\right) \\right] y_n $$\n放大因子，即稳定性多项式 $R(z)$，是括号中的表达式 $y_{n+1}/y_n$。展开此多项式：\n$$ R(z) = \\frac{1}{3} + \\frac{2}{3}\\left(1 + \\frac{1}{2}z + \\frac{1}{4}z^2 + z + \\frac{1}{2}z^2 + \\frac{1}{4}z^3\\right) $$\n$$ R(z) = \\frac{1}{3} + \\frac{2}{3}\\left(1 + \\frac{3}{2}z + \\frac{3}{4}z^2 + \\frac{1}{4}z^3\\right) $$\n$$ R(z) = \\frac{1}{3} + \\frac{2}{3} + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 $$\n因此，SSPRK(3,3) 的稳定性多项式是：\n$$ R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 $$\n这是 $e^z$ 的三阶泰勒级数展开，与一个三阶方法相符。\n\n**2. 半离散化矩阵的特征值**\n\n平流方程为 $u_t + a u_x = 0$。我们在均匀网格 $x_j = j \\Delta x$（其中 $j=0, \\dots, N-1$）上进行空间离散。由于波速 $a>0$，在网格点 $j$ 处空间导数 $u_x$ 的一阶迎风差分为：\n$$ u_x \\approx \\frac{u(x_j) - u(x_{j-1})}{\\Delta x} $$\n令 $y_j(t) \\approx u(x_j, t)$，半离散常微分方程组为：\n$$ \\frac{dy_j}{dt} + a \\frac{y_j - y_{j-1}}{\\Delta x} = 0 \\quad \\implies \\quad y_j'(t) = -\\frac{a}{\\Delta x} (y_j - y_{j-1}) $$\n该系统可以写成矩阵形式 $y'(t) = A y(t)$。对于周期性域，索引 $j-1$ 被解释为模 $N$，因此对于 $j=0$，$y_{j-1} = y_{-1} \\equiv y_{N-1}$。这会产生一个循环矩阵 $A \\in \\mathbb{C}^{N \\times N}$，其中每一行包含格式的系数。$A$ 的第 $j$ 行在第 $j$ 列的值为 $-\\frac{a}{\\Delta x}$，在第 $j-1$ 列的值为 $+\\frac{a}{\\Delta x}$（带环绕）。\n\n任何循环矩阵的特征值都可以通过将其应用于构成其特征向量的离散傅里叶模来找到。一个特征向量 $v_k$ 的分量为 $(v_k)_j = e^{i (2\\pi k j / N)}$，其中 $k, j \\in \\{0, \\dots, N-1\\}$。将算子应用于 $v_k$ 的第 $j$ 个分量：\n$$ (A v_k)_j = -\\frac{a}{\\Delta x} \\left( (v_k)_j - (v_k)_{j-1} \\right) = -\\frac{a}{\\Delta x} \\left( e^{i \\frac{2\\pi k j}{N}} - e^{i \\frac{2\\pi k (j-1)}{N}} \\right) $$\n$$ (A v_k)_j = -\\frac{a}{\\Delta x} e^{i \\frac{2\\pi k j}{N}} \\left( 1 - e^{-i \\frac{2\\pi k}{N}} \\right) = \\lambda_k (v_k)_j $$\n因此，对应于特征向量 $v_k$ 的特征值 $\\lambda_k$ 是：\n$$ \\lambda_k = -\\frac{a}{\\Delta x} \\left( 1 - e^{-i \\phi_k} \\right) $$\n其中 $\\phi_k = \\frac{2\\pi k}{N}$ 是由 $\\Delta x$ 归一化的离散波数，范围从 $\\phi_0=0$ 到接近 $2\\pi$。随着 $k$ 的变化，这些特征值在复平面上描绘出一个圆。表达式 $\\lambda_k + \\frac{a}{\\Delta x} = \\frac{a}{\\Delta x} e^{-i\\phi_k}$ 表明这是一个半径为 $\\frac{a}{\\Delta x}$、圆心在实轴上 $-\\frac{a}{\\Delta x}$ 处的圆。\n\n**3. 稳定性分析**\n\n为使数值方法稳定，对于系统中存在的所有模式，单步放大因子的模长必须不大于1。这意味着对于 $A$ 的所有特征值 $\\lambda_k$，必须满足条件 $|R(h\\lambda_k)| \\le 1$。\n\n令 $z_k = h\\lambda_k$。所有这些缩放后的特征值的集合是算子 $hA$ 的谱。\n$$ z_k = -h \\frac{a}{\\Delta x} \\left( 1 - e^{-i \\phi_k} \\right) $$\n我们将 Courant-Friedrichs-Lewy (CFL) 数定义为 $\\nu = \\frac{a h}{\\Delta x}$。由此，缩放后的特征值变为：\n$$ z_k = -\\nu \\left( 1 - e^{-i \\phi_k} \\right) $$\n这个方程描述了复平面上一个以 $-\\nu$ 为圆心、半径为 $\\nu$ 的圆。稳定性条件要求整个圆都位于 SSPRK(3,3) 方法的稳定区域内，该区域定义为集合 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$。\n\n为了找到最大稳定 CFL 数 $\\nu_{\\max}$，我们必须找到最大的 $\\nu > 0$ 使得这个圆包含在 $\\mathcal{S}$ 中。严谨的分析将涉及找到扩张的圆与 $\\mathcal{S}$ 边界的切点。然而，对于迎风差分和 RK3 方法的这种特定组合，一个常见且有效的简化是假设稳定性极限由特征值圆上位于负实轴最远的点决定。该点对应于最高频率的空间模式，其中 $\\phi_k = \\pi$。\n对于 $\\phi_k = \\pi$，$e^{-i\\pi} = -1$，所以缩放后的特征值为：\n$$ z = -\\nu(1 - (-1)) = -2\\nu $$\n我们必须找到稳定区域在负实轴上的边界。这个边界由 $|R(z)|=1$ 给出。由于对于实数 $z$，$R(z)$ 是实数，这意味着 $R(z)=1$ 或 $R(z)=-1$。对于 $z0$，$R(z)=1$ 仅在 $z=0$ 时成立。因此，稳定性极限由 $R(z)=-1$ 的第一个负根确定。\n$$ 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 = -1 $$\n$$ \\frac{1}{6}z^3 + \\frac{1}{2}z^2 + z + 2 = 0 $$\n两边乘以 6，得到负实轴上稳定性边界的多项式方程：\n$$ z^3 + 3z^2 + 6z + 12 = 0 $$\n当点 $z = -2\\nu$ 位于此边界上时，达到最大稳定时间步长。将 $z = -2\\nu_{\\max}$ 代入此方程：\n$$ (-2\\nu_{\\max})^3 + 3(-2\\nu_{\\max})^2 + 6(-2\\nu_{\\max}) + 12 = 0 $$\n$$ -8\\nu_{\\max}^3 + 12\\nu_{\\max}^2 - 12\\nu_{\\max} + 12 = 0 $$\n两边除以 -4，我们得到关于最大 CFL 数 $\\nu_{\\max}$ 的三次方程：\n$$ 2\\nu_{\\max}^3 - 3\\nu_{\\max}^2 + 3\\nu_{\\max} - 3 = 0 $$\n\n**4. 最大时间步长的计算**\n\n这个三次方程没有简单的有理根，必须进行数值求解。具有物理意义的根是唯一的实根，可以使用数值求解器找到。其值为：\n$$ \\nu_{\\max} \\approx 1.2638360341943411 $$\n根据 CFL 数的定义 $\\nu_{\\max} = \\frac{a h_{\\max}}{\\Delta x}$，我们可以将最大稳定时间步长 $h_{\\max}$ 表示为：\n$$ h_{\\max} = \\nu_{\\max} \\frac{\\Delta x}{a} $$\n使用计算出的 $\\nu_{\\max}$ 值，最终公式为：\n$$ h_{\\max} \\approx 1.26383603 \\times \\frac{\\Delta x}{a} $$\n此公式将被实现以计算给定测试用例所需的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Calculates the maximal stable time step h_max for the SSPRK(3,3) method\n    applied to the 1D advection equation with first-order upwind discretization.\n    \"\"\"\n    \n    # As derived in the solution, the maximal stable CFL number, nu_max, is the\n    # real root of the cubic equation 2*nu^3 - 3*nu^2 + 3*nu - 3 = 0.\n    # We solve this equation numerically.\n    def poly_for_nu(nu):\n        \"\"\"Cubic polynomial defining the maximal CFL number.\"\"\"\n        return 2 * nu**3 - 3 * nu**2 + 3 * nu - 3\n\n    # The root is known to be between 1.0 and 2.0. We use a bracketing method\n    # for robustness.\n    try:\n        sol = root_scalar(poly_for_nu, bracket=[1.0, 2.0], method='brentq')\n        nu_max = sol.root\n    except (ImportError, ValueError):\n        # Fallback to a hardcoded value if scipy fails, though this should not happen\n        # in the specified environment. The value is pre-calculated to high precision.\n        nu_max = 1.2638360341943411\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (a, delta_x) in units of m/s and m, respectively.\n    test_cases = [\n        (1.0, 1.0),\n        (2.0, 1.0),\n        (0.5, 0.1),\n        (1000.0, 1.0),\n        (1.0, 10**-3)\n    ]\n\n    results = []\n    for a, delta_x in test_cases:\n        # The formula for the maximal stable time step is h_max = nu_max * (delta_x / a).\n        if a = 0 or delta_x = 0:\n            raise ValueError(\"Wave speed 'a' and grid spacing 'delta_x' must be positive.\")\n        \n        h_max = nu_max * (delta_x / a)\n        \n        # Format the result to eight decimal places as required.\n        results.append(f\"{h_max:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最终实践旨在将理论应用于计算地球物理学的核心问题：三维弹性波传播。在高性能计算领域，选择“最佳”数值方法不仅要考虑其理论收敛阶，还必须权衡实际的计算性能，如内存占用和计算效率。此练习将要求你实现并比较两种不同的四阶龙格-库塔方法——经典的RK4方法和一种低存储（LSRK）方法，通过在一个真实的地震波模拟场景中评估它们的精度和内存访问成本，从而深入理解理论与实践之间的联系 。",
            "id": "3590123",
            "problem": "考虑在三维空间中使用周期性边界条件的一阶线性各向同性弹性半离散系统。设状态向量为 $u(t) = \\{v_x, v_y, v_z, \\sigma_{xx}, \\sigma_{yy}, \\sigma_{zz}, \\sigma_{xy}, \\sigma_{xz}, \\sigma_{yz}\\}(t)$，其中 $v_x$、$v_y$、$v_z$ 是质点速度分量，$\\sigma_{ij}$ 是柯西应力分量。在各向同性介质中，连续介质方程耦合了动量守恒和胡克定律：\n- 动量守恒：$\\rho \\, \\partial_t \\mathbf{v} = \\nabla \\cdot \\boldsymbol{\\sigma}$。\n- 速率形式的本构关系：$\\partial_t \\boldsymbol{\\sigma} = \\lambda \\, \\nabla \\cdot \\mathbf{v} \\, \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{v})$，\n其中 $\\rho$ 是密度，$\\lambda$ 和 $\\mu$ 是拉梅参数，$\\mathbf{I}$ 是单位张量，$\\boldsymbol{\\varepsilon}(\\mathbf{v})$ 是速度的对称梯度。\n\n在使用网格间距 $\\Delta x = \\Delta y = \\Delta z = 1$ 和中心差分进行均匀网格有限差分半离散化后，空间导数被带有周期性环绕的中心差分格式所取代。这产生了一个有限维常微分方程（ODE）初值问题\n$$\nu'(t) = L(u(t)),\n$$\n其中 $L$ 是对应于上述离散散度和梯度耦合的线性算子，在每个网格点 $(i,j,k)$ 处具有以下分量形式的结构：\n- 速度更新：\n$$\n\\partial_t v_x = \\frac{1}{\\rho}\\left(\\partial_x \\sigma_{xx} + \\partial_y \\sigma_{xy} + \\partial_z \\sigma_{xz}\\right), \\quad\n\\partial_t v_y = \\frac{1}{\\rho}\\left(\\partial_x \\sigma_{xy} + \\partial_y \\sigma_{yy} + \\partial_z \\sigma_{yz}\\right), \\quad\n\\partial_t v_z = \\frac{1}{\\rho}\\left(\\partial_x \\sigma_{xz} + \\partial_y \\sigma_{yz} + \\partial_z \\sigma_{zz}\\right),\n$$\n- 应力更新：\n$$\n\\partial_t \\sigma_{xx} = (\\lambda + 2\\mu)\\, \\partial_x v_x + \\lambda \\, \\partial_y v_y + \\lambda \\, \\partial_z v_z, \\quad\n\\partial_t \\sigma_{yy} = \\lambda\\, \\partial_x v_x + (\\lambda + 2\\mu) \\, \\partial_y v_y + \\lambda \\, \\partial_z v_z, \\quad\n\\partial_t \\sigma_{zz} = \\lambda\\, \\partial_x v_x + \\lambda \\, \\partial_y v_y + (\\lambda + 2\\mu) \\, \\partial_z v_z,\n$$\n$$\n\\partial_t \\sigma_{xy} = \\mu\\left(\\partial_x v_y + \\partial_y v_x\\right), \\quad\n\\partial_t \\sigma_{xz} = \\mu\\left(\\partial_x v_z + \\partial_z v_x\\right), \\quad\n\\partial_t \\sigma_{yz} = \\mu\\left(\\partial_y v_z + \\partial_z v_y\\right),\n$$\n使用周期性中心差分，例如 $\\partial_x f(i,j,k) \\approx \\frac{f(i+1,j,k) - f(i-1,j,k)}{2}$，其中索引根据网格大小进行模运算环绕。所有量均为无量纲。\n\n您将比较两种用于推进 $u'(t)=L(u)$ 的显式单步时间积分器：\n- 经典的四阶龙格-库塔法（RK4）。\n- 一种四阶、五级、双寄存器的低存储龙格-库塔法（LSRK(5,4)；Carpenter–Kennedy）。使用以下定义了一个经过充分测试的格式的阶段系数：\n$$\na_1 = 0,\\;\na_2 = -\\frac{567301805773}{1357537059087},\\;\na_3 = -\\frac{2404267990393}{2016746695238},\\;\na_4 = -\\frac{3550918686646}{2091501179385},\\;\na_5 = -\\frac{1275806237668}{842570457699},\n$$\n$$\nb_1 = \\frac{1432997174477}{9575080441755},\\;\nb_2 = \\frac{5161836677717}{13612068292357},\\;\nb_3 = \\frac{1720146321549}{2090206949498},\\;\nb_4 = \\frac{3134564353537}{4481467310338},\\;\nb_5 = \\frac{2277821191437}{14882151754819}.\n$$\nLSRK(5,4) 在阶段 $s$ 的更新形式为\n$$\nr \\leftarrow a_s r + L(u), \\qquad u \\leftarrow u + b_s \\, h \\, r,\n$$\n其中 $r$ 是一个与 $u$ 大小相同的寄存器，$h$ 是时间步长，$L(u)$ 在当前阶段状态下被重新计算。\n\n缓存代理度量。定义一个缓存代理内存流量度量，其值等于对状态和阶段数组的标量数组元素访问（读取加写入）次数，按算法数据访问进行计数。对于如上所述使用中心差分实现的离散算子 $L(u)$，每次在完整网格上对 $L$ 的求值会遍历所有九个场，算子在每个网格点访问：\n- $48$ 次读取（所有需要场中的相邻值）和 $9$ 次写入（写入九个时间导数分量）。\n因此，单次应用 $L$ 在每个网格点执行 $57$ 次数组元素访问。对于形成阶段数组和状态的线性组合的时间积分更新，每个源数组计为一次读取，每个目标数组元素计为一次写入。\n\n使用这些规则，每个积分器每时间步的内存流量为：\n- RK4：$4$ 次右端项求值，三次中间状态形成，以及一次最终组合，总计为\n$$\n\\left(4 \\cdot 57 + 3 \\cdot 3 \\cdot 9 + 6 \\cdot 9\\right) N = 363 N\n$$\n次数组元素访问每步，其中 $N$ 是网格点总数，$9$ 是状态场的数量。\n- LSRK(5,4)：$5$ 次右端项求值，并且对于 $5$ 个阶段中的每一个，有一次残差更新和一次状态更新，总计为\n$$\n\\left(5 \\cdot 57 + 5 \\cdot (3 \\cdot 9 + 3 \\cdot 9)\\right) N = 555 N\n$$\n次数组元素访问每步。\n\n精度度量。令最终时间 $T$ 的相对误差为数值解与使用 RK4 在更小时间步长 $h_{\\mathrm{ref}} = h/8$ 下计算的参考解之间的比率（在所有场和网格点上的欧几里得范数中）：\n$$\n\\mathrm{err} = \\frac{\\lVert u_h(T) - u_{\\mathrm{ref}}(T) \\rVert_2}{\\lVert u_{\\mathrm{ref}}(T) \\rVert_2}.\n$$\n\n实现以下任务：\n- 使用指定的周期性环绕中心差分格式构建算子 $L$，参数为 $\\rho = 1$, $\\lambda = 2$, $\\mu = 1$。\n- 为半离散 ODE 实现 RK4 和 LSRK(5,4) 时间积分器。\n- 在 $t=0$ 时，在均匀网格上使用平滑的三角函数数据初始化场：\n$$\nv_x(i,j,k) = \\sin\\left(\\frac{2\\pi i}{n_x}\\right)\\sin\\left(\\frac{2\\pi j}{n_y}\\right)\\sin\\left(\\frac{2\\pi k}{n_z}\\right), \\quad\nv_y(i,j,k) = \\sin\\left(\\frac{2\\pi (i+1/3)}{n_x}\\right)\\sin\\left(\\frac{2\\pi (j+1/3)}{n_y}\\right)\\sin\\left(\\frac{2\\pi (k+1/3)}{n_z}\\right),\n$$\n$$\nv_z(i,j,k) = \\sin\\left(\\frac{2\\pi (i+2/3)}{n_x}\\right)\\sin\\left(\\frac{2\\pi (j+2/3)}{n_y}\\right)\\sin\\left(\\frac{2\\pi (k+2/3)}{n_z}\\right),\n$$\n初始时所有 $\\sigma_{ij}(i,j,k) = 0$。\n- 对于每个测试用例，在时间 $T$ 计算相对于 $h_{\\mathrm{ref}} = h/8$ 的 RK4 参考解的相对误差 $\\mathrm{err}_{\\mathrm{RK4}}$ 和 $\\mathrm{err}_{\\mathrm{LSRK}}$，并根据每步的访问次数和时间步数计算总内存流量计数。\n\n测试套件。使用以下三个案例，全部采用无量纲单位：\n- 案例 A（理想路径）：$(n_x,n_y,n_z) = (8,8,8)$，$h = 0.001$，$T = 0.020$。\n- 案例 B（稳定裕度内的较大大步长）：$(n_x,n_y,n_z) = (8,8,8)$，$h = 0.0005$，$T = 0.020$。\n- 案例 C（单步边界）：$(n_x,n_y,n_z) = (6,6,6)$，$h = 0.005$，$T = 0.005$。\n\n输出规范。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个案例，按顺序报告：$\\mathrm{err}_{\\mathrm{RK4}}$、$\\mathrm{err}_{\\mathrm{LSRK}}$、$\\mathrm{traffic}_{\\mathrm{RK4}}$、$\\mathrm{traffic}_{\\mathrm{LSRK}}$、$\\mathrm{traffic}_{\\mathrm{LSRK}}/\\mathrm{traffic}_{\\mathrm{RK4}}$、$\\mathrm{err}_{\\mathrm{LSRK}}/\\mathrm{err}_{\\mathrm{RK4}}$。按 A、B、C 的顺序连接三个案例。因此，最终打印的行必须包含在一个方括号内的 $18$ 个逗号分隔值。无需打印单位；所有值都是无量纲的实数或整数。",
            "solution": "用户提供了一个来自计算地球物理学领域的有效且适定的问题陈述，具体涉及半离散化的线性各向同性弹性方程的数值积分。我的任务是实现两种四阶显式单步时间积分格式：经典的龙格-库塔法（RK4）和一种低存储龙格-库塔法（LSRK(5,4)），并比较它们的精度和计算成本的代理指标（内存流量）。\n\n问题陈述始于三维弹性波方程的一阶速度-应力形式。在空间和时间的每个点上定义的状态向量是 $u = \\{v_x, v_y, v_z, \\sigma_{xx}, \\sigma_{yy}, \\sigma_{zz}, \\sigma_{xy}, \\sigma_{xz}, \\sigma_{yz}\\}$，包含三个质点速度分量和六个独立的应力张量分量。控制偏微分方程（PDE）是：\n$$\n\\rho \\, \\partial_t \\mathbf{v} = \\nabla \\cdot \\boldsymbol{\\sigma} \\quad (\\text{动量守恒})\n$$\n$$\n\\partial_t \\boldsymbol{\\sigma} = \\lambda \\, (\\nabla \\cdot \\mathbf{v}) \\, \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\quad (\\text{胡克定律})\n$$\n其中 $\\rho$ 是材料密度，$\\lambda$ 和 $\\mu$ 是拉梅参数，$\\mathbf{I}$ 是单位张量，$\\boldsymbol{\\varepsilon}(\\mathbf{v}) = \\frac{1}{2}(\\nabla \\mathbf{v} + (\\nabla \\mathbf{v})^T)$ 是应变率张量。\n\n该连续系统在空间上于均匀笛卡尔网格上进行半离散化，网格间距为 $\\Delta x = \\Delta y = \\Delta z = 1$。空间导数使用带有周期性边界条件的二阶中心有限差分格式来近似。对于任何场分量 $f$ 和空间维度 $x$，在网格点 $(i, j, k)$ 的离散导数算子由 $\\partial_x f \\approx \\frac{f_{i+1,j,k} - f_{i-1,j,k}}{2}$ 给出。此过程将偏微分方程组转换为一个大型耦合线性常微分方程（ODE）系统，形式为 $u'(t) = L(u(t))$，其中 $L$ 是离散空间算子。指定的材料参数为 $\\rho = 1$、$\\lambda = 2$ 和 $\\mu = 1$。\n\n该解决方案将使用 Python 实现，并利用 NumPy 库进行高效的数组计算。\n\n**步骤 1：状态向量和算子 `L` 的实现**\n系统状态由一个形状为 $(n_x, n_y, n_z, 9)$ 的四维 NumPy 数组表示，其中 $(n_x, n_y, n_z)$ 是网格维度，最后一个轴索引状态向量 $u$ 的 $9$ 个场。算子 $L$ 实现为一个函数，它接受一个状态数组 $u$ 并返回时间导数数组 $du/dt$。周期性边界条件通过使用 `numpy.roll` 高效处理，该函数沿给定轴对数组元素执行循环移位。例如，要计算 $\\partial_x f$，我们使用 `(numpy.roll(f, -1, axis=0) - numpy.roll(f, 1, axis=0)) / 2`。\n\n**步骤 2：初始条件**\n一个函数在大小为 $(n_x, n_y, n_z)$ 的网格上生成初始状态 $u(0)$。按照规定，速度场（$v_x, v_y, v_z$）使用平滑的、相移的正弦函数进行初始化，所有应力场（$\\sigma_{ij}$）初始化为零。\n\n**步骤 3：时间积分格式**\n实现了两个时间步进函数，用于将解从时间 $t$ 推进到 $t+h$：\n\n1.  **经典的四阶龙格-库塔法（RK4）**：此方法每个时间步需要四次算子 $L$ 的求值。对于一个 ODE $u' = f(u, t)$，更新规则为：\n    $$\n    k_1 = f(u_n, t_n) \\\\\n    k_2 = f(u_n + \\frac{h}{2} k_1, t_n + \\frac{h}{2}) \\\\\n    k_3 = f(u_n + \\frac{h}{2} k_2, t_n + \\frac{h}{2}) \\\\\n    k_4 = f(u_n + h k_3, t_n + h) \\\\\n    u_{n+1} = u_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n    由于我们的算子 $L$ 是自治的（$L(u)$ 而非 $L(u,t)$），因此不需要时间参数。标准实现需要存储四个中间阶段导数数组（$k_1, k_2, k_3, k_4$），或三个中间状态数组。\n\n2.  **低存储龙格-库塔法（LSRK(5,4)）**：这是一个五级、四阶的格式，旨在最小化内存使用，对大规模模拟尤其有利。它只使用两个存储寄存器来存储状态向量 $u$ 和一个辅助寄存器 $r$。五个阶段（$s=1, ..., 5$）中每个阶段的更新由下式给出：\n    $$\n    r \\leftarrow a_s r + L(u) \\\\\n    u \\leftarrow u + b_s \\, h \\, r\n    $$\n    寄存器 $r$ 在每个时间步开始时初始化为零。系数 $a_s$ 和 $b_s$ 在问题陈述中已提供。此实现每个时间步需要五次算子 $L$ 的求值。\n\n**步骤 4：模拟与分析**\n对于提供的每个测试用例，执行以下过程：\n1.  **参考解**：通过使用 RK4 方法和一个小的时间步长 $h_{\\mathrm{ref}} = h/8$ 将系统积分到最终时间 $T$，计算一个高精度的参考解 $u_{\\mathrm{ref}}(T)$。\n2.  **测试解**：使用指定的时间步长 $h$，分别通过 RK4 和 LSRK(5,4) 方法再次将系统积分到时间 $T$，得到 $u_{\\mathrm{RK4}}(T)$ 和 $u_{\\mathrm{LSRK}}(T)$。\n3.  **误差计算**：使用欧几里得范数（对于矩阵/张量也称为弗罗贝尼乌斯范数）计算每种方法相对于参考解的相对误差：\n    $$\n    \\mathrm{err} = \\frac{\\lVert u_{\\text{numerical}}(T) - u_{\\mathrm{ref}}(T) \\rVert_2}{\\lVert u_{\\mathrm{ref}}(T) \\rVert_2}\n    $$\n4.  **内存流量计算**：基于提供的公式计算每次模拟的总内存流量，该公式考虑了网格点数 $N = n_x n_y n_z$、时间步数以及预先计算的每步访问次数：RK4 为 $363 N$，LSRK(5,4) 为 $555 N$。\n5.  **比率计算**：计算内存流量比率 $(\\mathrm{traffic}_{\\mathrm{LSRK}}/\\mathrm{traffic}_{\\mathrm{RK4}})$ 和相对误差比率 $(\\mathrm{err}_{\\mathrm{LSRK}}/\\mathrm{err}_{\\mathrm{RK4}})$，以比较这两种格式的效率和精度。\n\n然后，将所有三个测试用例的结果汇总并格式化为指定的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n\n    # --- Physical and Numerical Parameters ---\n    RHO = 1.0\n    LAM = 2.0\n    MU = 1.0\n\n    # LSRK(5,4) coefficients by Carpenter-Kennedy\n    A_LSRK = np.array([\n        0.0,\n        -567301805773.0 / 1357537059087.0,\n        -2404267990393.0 / 2016746695238.0,\n        -3550918686646.0 / 2091501179385.0,\n        -1275806237668.0 / 842570457699.0\n    ])\n    B_LSRK = np.array([\n        1432997174477.0 / 9575080441755.0,\n        5161836677717.0 / 13612068292357.0,\n        1720146321549.0 / 2090206949498.0,\n        3134564353537.0 / 4481467310338.0,\n        2277821191437.0 / 14882151754819.0\n    ])\n\n    test_cases = [\n        # Case A: (nx, ny, nz), h, T\n        ((8, 8, 8), 0.001, 0.020),\n        # Case B: (nx, ny, nz), h, T\n        ((8, 8, 8), 0.0005, 0.020),\n        # Case C: (nx, ny, nz), h, T\n        ((6, 6, 6), 0.005, 0.005),\n    ]\n\n    all_results = []\n    \n    # --- Helper functions for spatial derivatives ---\n    def d_dx(field): return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / 2.0\n    def d_dy(field): return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / 2.0\n    def d_dz(field): return (np.roll(field, -1, axis=2) - np.roll(field, 1, axis=2)) / 2.0\n\n    def L_operator(u, rho, lam, mu):\n        \"\"\"Computes the time derivative u' = L(u) of the semi-discrete system.\"\"\"\n        du_dt = np.zeros_like(u)\n        \n        # Unpack fields for clarity. These are views, not copies.\n        vx, vy, vz = u[..., 0], u[..., 1], u[..., 2]\n        s_xx, s_yy, s_zz = u[..., 3], u[..., 4], u[..., 5]\n        s_xy, s_xz, s_yz = u[..., 6], u[..., 7], u[..., 8]\n\n        # Velocity updates (Momentum balance)\n        du_dt[..., 0] = (d_dx(s_xx) + d_dy(s_xy) + d_dz(s_xz)) / rho\n        du_dt[..., 1] = (d_dx(s_xy) + d_dy(s_yy) + d_dz(s_yz)) / rho\n        du_dt[..., 2] = (d_dx(s_xz) + d_dy(s_yz) + d_dz(s_zz)) / rho\n\n        # Common derivative terms for stress updates\n        dvx_dx = d_dx(vx)\n        dvy_dy = d_dy(vy)\n        dvz_dz = d_dz(vz)\n\n        # Stress updates (Constitutive relation)\n        du_dt[..., 3] = (lam + 2 * mu) * dvx_dx + lam * dvy_dy + lam * dvz_dz\n        du_dt[..., 4] = lam * dvx_dx + (lam + 2 * mu) * dvy_dy + lam * dvz_dz\n        du_dt[..., 5] = lam * dvx_dx + lam * dvy_dy + (lam + 2 * mu) * dvz_dz\n        \n        du_dt[..., 6] = mu * (d_dx(vy) + d_dy(vx))\n        du_dt[..., 7] = mu * (d_dx(vz) + d_dz(vx))\n        du_dt[..., 8] = mu * (d_dy(vz) + d_dz(vy))\n        \n        return du_dt\n\n    def get_initial_state(nx, ny, nz):\n        \"\"\"Generates the initial state vector u(0).\"\"\"\n        i, j, k = np.mgrid[0:nx, 0:ny, 0:nz]\n        u0 = np.zeros((nx, ny, nz, 9), dtype=np.float64)\n\n        u0[..., 0] = np.sin(2 * np.pi * i / nx) * np.sin(2 * np.pi * j / ny) * np.sin(2 * np.pi * k / nz)\n        u0[..., 1] = np.sin(2 * np.pi * (i + 1/3) / nx) * np.sin(2 * np.pi * (j + 1/3) / ny) * np.sin(2 * np.pi * (k + 1/3) / nz)\n        u0[..., 2] = np.sin(2 * np.pi * (i + 2/3) / nx) * np.sin(2 * np.pi * (j + 2/3) / ny) * np.sin(2 * np.pi * (k + 2/3) / nz)\n        \n        return u0\n\n    def rk4_stepper(u, h, L_func, rho, lam, mu):\n        \"\"\"Performs one step of the classical RK4 method.\"\"\"\n        k1 = L_func(u, rho, lam, mu)\n        k2 = L_func(u + h/2 * k1, rho, lam, mu)\n        k3 = L_func(u + h/2 * k2, rho, lam, mu)\n        k4 = L_func(u + h * k3, rho, lam, mu)\n        return u + h/6 * (k1 + 2*k2 + 2*k3 + k4)\n\n    def lsrk_stepper(u, h, L_func, a_coeffs, b_coeffs, rho, lam, mu):\n        \"\"\"Performs one step of the LSRK(5,4) method.\"\"\"\n        u_new = u.copy()\n        r = np.zeros_like(u_new)\n        for s in range(5):\n            Lu = L_func(u_new, rho, lam, mu)\n            r = a_coeffs[s] * r + Lu\n            u_new += b_coeffs[s] * h * r\n        return u_new\n\n    for case in test_cases:\n        (nx, ny, nz), h, T = case\n        N = nx * ny * nz\n        \n        u0 = get_initial_state(nx, ny, nz)\n\n        # 1. Compute reference solution\n        h_ref = h / 8\n        num_steps_ref = int(round(T / h_ref))\n        u_ref = u0.copy()\n        for _ in range(num_steps_ref):\n            u_ref = rk4_stepper(u_ref, h_ref, L_operator, RHO, LAM, MU)\n        norm_ref = np.linalg.norm(u_ref)\n\n        num_steps = int(round(T/h))\n        \n        # 2. Compute RK4 solution and error\n        u_rk4 = u0.copy()\n        for _ in range(num_steps):\n            u_rk4 = rk4_stepper(u_rk4, h, L_operator, RHO, LAM, MU)\n        err_rk4 = np.linalg.norm(u_rk4 - u_ref) / norm_ref\n\n        # 3. Compute LSRK solution and error\n        u_lsrk = u0.copy()\n        for _ in range(num_steps):\n            u_lsrk = lsrk_stepper(u_lsrk, h, L_operator, A_LSRK, B_LSRK, RHO, LAM, MU)\n        err_lsrk = np.linalg.norm(u_lsrk - u_ref) / norm_ref\n        \n        # 4. Compute memory traffic\n        traffic_rk4 = 363 * N * num_steps\n        traffic_lsrk = 555 * N * num_steps\n\n        # 5. Compute ratios\n        traffic_ratio = traffic_lsrk / traffic_rk4 if traffic_rk4 != 0 else 0\n        err_ratio = err_lsrk / err_rk4 if err_rk4 != 0 else 0\n        \n        all_results.extend([err_rk4, err_lsrk, traffic_rk4, traffic_lsrk, traffic_ratio, err_ratio])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}