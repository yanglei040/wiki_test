{
    "hands_on_practices": [
        {
            "introduction": "任何龙格-库塔方法的核心是其布彻表（Butcher tableau），它以一种紧凑的方式编码了方法的所有系数。通过一个具体的计算练习来手动执行一个时间步，是理解这些系数如何转化为实际算法的基础一步。本练习  将引导您使用二阶中点法的布彻表来求解一个简单的常微分方程，从而将抽象的理论付诸实践。",
            "id": "3613997",
            "problem": "在计算地球物理学中，含时偏微分方程的半离散格式通常会产生常微分方程（ODE）。考虑一个网格点上的局部模型，该模型由标量ODE $y'(t)=t+y(t)$ 控制，其中 $y(t)$ 表示一个状态变量（例如，一个局部线性化的预报量）。令 $y_n$ 表示在时间 $t_n$ 时 $y(t_n)$ 的数值近似，并令 $\\Delta t$ 为一个正的时间步长，使得 $t_{n+1}=t_n+\\Delta t$。\n\n您需要使用一个由中点法定义的2级龙格-库塔方法将 $y_n$ 推进到 $y_{n+1}$，该方法的布彻表由节点 $c=\\left(0,\\frac{1}{2}\\right)$、严格下三角矩阵\n$$\nA=\\begin{pmatrix}\n0  0 \\\\\n\\frac{1}{2}  0\n\\end{pmatrix},\n$$\n以及权重 $b=\\left(0,1\\right)$ 指定。\n\n仅从布彻表定义了应用于 $y'(t)=f(t,y)$（其中 $f(t,y)=t+y$）的龙格-库塔积分器中的级横坐标、内部级耦合和最终权重这一解释出发，推导出从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的单步更新映射，并以 $y_n$、$t_n$ 和 $\\Delta t$ 的形式显式计算 $y_{n+1}$。\n\n请以 $y_n$、$t_n$ 和 $\\Delta t$ 表示的单个闭式解析表达式的形式提供您的最终结果。最终表达式无需四舍五入，也不包含任何单位。",
            "solution": "用户要求使用指定的2级龙格-库塔方法，对给定的常微分方程（ODE）推导其单步更新映射。\n\n首先对问题进行验证。\n**已知条件：**\n- ODE: $y'(t) = t + y(t)$，它定义了函数 $f(t, y) = t + y$。\n- 时间离散化: $t_{n+1} = t_n + \\Delta t$，时间步长 $\\Delta t > 0$。\n- $y(t_n)$ 的数值近似为 $y_n$。\n- 一个2级龙格-库塔方法由以下布彻表定义：\n  - 横坐标: $c = \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\end{pmatrix}$\n  - 矩阵: $A = \\begin{pmatrix} a_{11}  a_{12} \\\\ a_{21}  a_{22} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ \\frac{1}{2}  0 \\end{pmatrix}$\n  - 权重: $b = \\begin{pmatrix} b_1  b_2 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\end{pmatrix}$\n\n**验证：**\n- **科学依据**：该问题是一个成熟的数值方法（龙格-库塔法）在一个简单的一阶线性ODE上的标准应用。所有组成部分在数学上和计算上都是合理的。\n- **适定性**：该问题提供了推导下一时间步的唯一解析表达式所需的所有必要信息（ODE、数值方法的系数以及初始状态）。\n- **客观性**：该问题以精确、正式的语言陈述，没有歧义或主观性。\n\n该问题是有效的，因为它具有科学依据、适定且客观。没有矛盾、信息缺失或伪科学的主张。我们可以继续进行求解。\n\n对于ODE $y'(t) = f(t, y(t))$，一个 $s$ 级龙格-库塔方法的通用公式由下式给出：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^{s} b_i k_i\n$$\n其中，级导数 $k_i$ 计算如下：\n$$\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{s} a_{ij} k_j\\right)\n$$\n对于此问题，级数 $s=2$。我们可以写出级 $k_1$ 和 $k_2$ 的方程。\n\n**第1级：**\n对于 $i=1$，我们使用 $c_1=0$、$a_{11}=0$ 和 $a_{12}=0$。\n$$\nk_1 = f\\left(t_n + c_1 \\Delta t, y_n + \\Delta t (a_{11} k_1 + a_{12} k_2)\\right)\n$$\n$$\nk_1 = f\\left(t_n + 0 \\cdot \\Delta t, y_n + \\Delta t (0 \\cdot k_1 + 0 \\cdot k_2)\\right)\n$$\n$$\nk_1 = f(t_n, y_n)\n$$\n代入给定的函数 $f(t, y) = t + y$，我们得到：\n$$\nk_1 = t_n + y_n\n$$\n\n**第2级：**\n对于 $i=2$，我们使用 $c_2=\\frac{1}{2}$、$a_{21}=\\frac{1}{2}$ 和 $a_{22}=0$。矩阵 $A$ 是严格下三角矩阵，因此该方法是显式的，并且 $k_2$ 的计算仅依赖于 $k_1$。\n$$\nk_2 = f\\left(t_n + c_2 \\Delta t, y_n + \\Delta t (a_{21} k_1 + a_{22} k_2)\\right)\n$$\n$$\nk_2 = f\\left(t_n + \\frac{1}{2} \\Delta t, y_n + \\Delta t \\left(\\frac{1}{2} k_1 + 0 \\cdot k_2\\right)\\right)\n$$\n$$\nk_2 = f\\left(t_n + \\frac{1}{2} \\Delta t, y_n + \\frac{1}{2} \\Delta t \\cdot k_1\\right)\n$$\n现在，我们将 $k_1 = t_n + y_n$ 的表达式代入 $k_2$ 的公式中：\n$$\nk_2 = f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right)\n$$\n使用 $f(t,y) = t+y$，我们带入其参数来计算函数值：\n$$\nk_2 = \\left(t_n + \\frac{\\Delta t}{2}\\right) + \\left(y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right)\n$$\n展开并合并同类项：\n$$\nk_2 = t_n + y_n + \\frac{\\Delta t}{2} + \\frac{\\Delta t}{2}t_n + \\frac{\\Delta t}{2}y_n\n$$\n$$\nk_2 = (t_n + y_n)\\left(1 + \\frac{\\Delta t}{2}\\right) + \\frac{\\Delta t}{2}\n$$\n\n**最终更新：**\n使用权重 $b_1=0$ 和 $b_2=1$ 构建 $y_{n+1}$ 的更新公式：\n$$\ny_{n+1} = y_n + \\Delta t (b_1 k_1 + b_2 k_2)\n$$\n$$\ny_{n+1} = y_n + \\Delta t (0 \\cdot k_1 + 1 \\cdot k_2)\n$$\n$$\ny_{n+1} = y_n + \\Delta t \\cdot k_2\n$$\n代入推导出的 $k_2$ 表达式：\n$$\ny_{n+1} = y_n + \\Delta t \\left[ \\left(t_n + \\frac{\\Delta t}{2}\\right) + \\left(y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right) \\right]\n$$\n现在，我们展开并简化表达式，以获得用 $y_n$、$t_n$ 和 $\\Delta t$ 表示的 $y_{n+1}$。\n$$\ny_{n+1} = y_n + t_n \\Delta t + y_n \\Delta t + \\frac{(\\Delta t)^2}{2} + \\frac{t_n (\\Delta t)^2}{2} + \\frac{y_n (\\Delta t)^2}{2}\n$$\n最后，我们按 $y_n$、$t_n$ 和剩余常数项对各项进行分组，以提供一个单一的闭式表达式。\n$$\ny_{n+1} = y_n \\left(1 + \\Delta t + \\frac{(\\Delta t)^2}{2}\\right) + t_n \\left(\\Delta t + \\frac{(\\Delta t)^2}{2}\\right) + \\frac{(\\Delta t)^2}{2}\n$$\n这个表达式可以被重排，以突出其与解的泰勒级数展开的关系。\n$$\ny_{n+1} = y_n + (t_n + y_n)\\Delta t + \\frac{1}{2}(t_n + y_n + 1)(\\Delta t)^2\n$$\n两种形式是等价的。后一种形式更紧凑，并明确显示了截至 $(\\Delta t)^2$ 阶的项。这就是所要求的 $y_{n+1}$ 的闭式解析表达式。",
            "answer": "$$\n\\boxed{y_n + (t_n + y_n)\\Delta t + \\frac{1}{2}(t_n + y_n + 1)(\\Delta t)^2}\n$$"
        },
        {
            "introduction": "在地球物理模拟中，如扩散或粘弹性过程，常会遇到“刚性”（stiff）常微分方程，这对时间积分器的稳定性提出了严峻挑战。本练习  通过分析经典的Dahlquist刚性测试方程，让您定量地比较一种显式方法（RK4）和一种隐式方法（隐式中点法）的性能。通过推导和评估它们的稳定性函数，您将深刻理解为何对于刚性问题，方法的选择（而不仅仅是阶数）至关重要。",
            "id": "3613965",
            "problem": "在计算地球物理学中，当对扩散或粘弹性偏微分方程（PDE）进行半离散化时，会出现刚性常微分方程（ODE）。考虑用于刚性问题分析的标量 Dahlquist 测试方程，其形式为 $y' = -\\beta y$，其中 $\\beta \\gg 1$。假设使用两种时间积分器来对该常微分方程进行积分：经典的显式四阶龙格-库塔（RK4）方法，以及隐式中点法（即一阶高斯-勒让德龙格-库塔方法）。设时间步长固定为 $\\Delta t = \\beta^{-1}$。\n\n从龙格-库塔方法的定义及其在线性测试方程 $y'=\\lambda y$ 上的应用出发，推导每种方法的单步放大因子 $R(z)$，其中 $z = \\lambda \\Delta t$。计算当 $z=-1$ 时 $R(z)$ 的模，然后对每种方法，确定将解的幅度减小 $10^{-k}$ 倍（即达到 $\\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert$）所需的步数 $n$ 的精确解析表达式（忽略取整 ceiling 函数）。将您的最终答案表示为仅使用自然对数的关于 $k$ 的函数，并且不要进行任何数值舍入。以数对 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$ 的形式给出您的最终答案，其中下标分别表示显式RK4和隐式中点法。",
            "solution": "用户提供了一个问题陈述，在进行求解之前需要对其进行验证。\n\n### 步骤 1：提取已知条件\n- 常微分方程（ODE）是用于刚性问题分析的 Dahlquist 测试方程：$y' = -\\beta y$，条件为 $\\beta \\gg 1$。\n- 这是线性测试方程 $y' = \\lambda y$ 的一个特例，其中系数 $\\lambda = -\\beta$。\n- 积分的时间步长固定为 $\\Delta t = \\beta^{-1}$。\n- 需要分析两种时间积分方法：\n    1. 经典的显式四阶龙格-库塔（RK4）方法。\n    2. 隐式中点法（一阶高斯-勒让德龙格-库塔方法）。\n- 任务是为每种方法推导单步放大因子 $R(z)$，其中 $z = \\lambda \\Delta t$。\n- 然后，根据问题参数给定的特定 $z$ 值，计算 $R(z)$ 的模。\n- 最后，确定满足条件 $\\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert$ 所需的步数 $n$。这个数 $n$ 应该是一个关于 $k$ 的精确解析表达式，忽略任何整数取整函数。\n- 最终答案应为一个数对 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：**该问题是常微分方程数值分析中的一个标准练习。Dahlquist 测试方程、龙格-库塔方法、稳定性函数（放大因子）及其在刚性问题中的应用是该领域的基本概念。计算地球物理学的背景是合适的，因为刚性系统在该领域很常见。该问题在科学上是合理的。\n- **适定性：**该问题提供了所有必要的信息。常微分方程、时间步长和所用方法都已明确定义。目标是具体且可量化的。$z$ 的值由已知条件明确确定：$z = \\lambda \\Delta t = (-\\beta)(\\beta^{-1}) = -1$。可以推导出一个唯一的、有意义的解。\n- **客观性：**该问题以精确、客观和技术性的语言表述，没有任何主观性或偏见。\n\n### 步骤 3：结论与行动\n该问题是有效的。它具有科学依据，是适定的、客观的且自洽的。可以开始求解过程。\n\n### 求解推导\n\n使用龙格-库塔方法对测试方程 $y' = \\lambda y$ 进行数值求解，一个时间步长 $\\Delta t$ 后的解可以表示为 $y_{n+1} = R(z) y_n$，其中 $z = \\lambda \\Delta t$，$R(z)$ 是该方法的稳定性函数或放大因子。经过 $n$ 步后，解为 $y_n = (R(z))^n y_0$。\n\n问题要求找到将解的幅度减小 $10^{-k}$ 倍所需的步数 $n$。该条件在数学上表述为：\n$$ \\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n代入 $y_n$ 的表达式：\n$$ \\lvert (R(z))^n y_0 \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n$$ \\lvert R(z) \\rvert^n \\lvert y_0 \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n假设 $y_0 \\ne 0$，我们可以两边同除以 $\\lvert y_0 \\rvert$：\n$$ \\lvert R(z) \\rvert^n \\le 10^{-k} $$\n为了求解 $n$，我们对两边取自然对数：\n$$ n \\ln(\\lvert R(z) \\rvert) \\le \\ln(10^{-k}) $$\n$$ n \\ln(\\lvert R(z) \\rvert) \\le -k \\ln(10) $$\n对于一个衰减的（稳定的）解，必须有 $\\lvert R(z) \\rvert  1$，这意味着 $\\ln(\\lvert R(z) \\rvert)$ 是负数。除以这个负数会反转不等号的方向：\n$$ n \\ge \\frac{-k \\ln(10)}{\\ln(\\lvert R(z) \\rvert)} = \\frac{k \\ln(10)}{-\\ln(\\lvert R(z) \\rvert)} = \\frac{k \\ln(10)}{\\ln(\\lvert R(z) \\rvert^{-1})} = \\frac{k \\ln(10)}{\\ln(1/\\lvert R(z) \\rvert)} $$\n问题要求的是所需的步数，并忽略整数取整，因此我们取等式：\n$$ n = \\frac{k \\ln(10)}{\\ln(1/\\lvert R(z) \\rvert)} $$\n根据问题陈述，$\\lambda = -\\beta$ 且 $\\Delta t = \\beta^{-1}$，因此 $z = \\lambda \\Delta t = (-\\beta)(\\beta^{-1}) = -1$。我们将对两种方法都使用 $z=-1$。\n\n**1. 经典的显式四阶龙格-库塔（RK4）方法**\n\n经典RK4方法的稳定性函数是指数函数的四阶泰勒多项式：\n$$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n我们在 $z = -1$ 处计算该函数的值：\n$$ R_{\\mathrm{RK4}}(-1) = 1 + (-1) + \\frac{(-1)^2}{2} + \\frac{(-1)^3}{6} + \\frac{(-1)^4}{24} $$\n$$ R_{\\mathrm{RK4}}(-1) = 1 - 1 + \\frac{1}{2} - \\frac{1}{6} + \\frac{1}{24} $$\n$$ R_{\\mathrm{RK4}}(-1) = \\frac{12}{24} - \\frac{4}{24} + \\frac{1}{24} = \\frac{12 - 4 + 1}{24} = \\frac{9}{24} = \\frac{3}{8} $$\n其模为 $\\lvert R_{\\mathrm{RK4}}(-1) \\rvert = \\frac{3}{8}$。\n现在，我们求步数 $n_{\\mathrm{RK4}}$：\n$$ n_{\\mathrm{RK4}}(k) = \\frac{k \\ln(10)}{\\ln(1/\\lvert R_{\\mathrm{RK4}}(-1) \\rvert)} = \\frac{k \\ln(10)}{\\ln(1/(3/8))} = \\frac{k \\ln(10)}{\\ln(8/3)} $$\n\n**2. 隐式中点法**\n\n隐式中点法是一种单级龙格-库塔方法，其布彻表（Butcher tableau）为 $c_1 = 1/2$，$a_{11} = 1/2$ 和 $b_1 = 1$。单级隐式龙格-库塔方法的稳定性函数 $R(z)$ 推导如下：\n对于方程 $y'=\\lambda y$，级值 $k_1$ 为 $k_1 = \\lambda(y_n + \\Delta t a_{11} k_1)$。\n$k_1 = \\lambda y_n + a_{11} (\\lambda \\Delta t) k_1 = \\lambda y_n + a_{11} z k_1$。\n求解 $k_1$：$k_1(1 - a_{11} z) = \\lambda y_n \\implies k_1 = \\frac{\\lambda y_n}{1 - a_{11} z}$。\n解的更新公式为 $y_{n+1} = y_n + \\Delta t b_1 k_1 = y_n + b_1 (\\lambda \\Delta t) \\frac{y_n}{1 - a_{11} z}$。\n因此，放大因子为 $R(z) = \\frac{y_{n+1}}{y_n} = 1 + \\frac{b_1 z}{1 - a_{11} z}$。\n对于隐式中点法，有 $a_{11} = 1/2$ 和 $b_1=1$：\n$$ R_{\\mathrm{IM}}(z) = 1 + \\frac{z}{1 - z/2} = \\frac{(1 - z/2) + z}{1 - z/2} = \\frac{1 + z/2}{1 - z/2} $$\n这是对 $\\exp(z)$ 的 $[1,1]$-Padé 近似。我们在 $z=-1$ 处计算该函数的值：\n$$ R_{\\mathrm{IM}}(-1) = \\frac{1 + (-1)/2}{1 - (-1)/2} = \\frac{1 - 1/2}{1 + 1/2} = \\frac{1/2}{3/2} = \\frac{1}{3} $$\n其模为 $\\lvert R_{\\mathrm{IM}}(-1) \\rvert = \\frac{1}{3}$。\n现在，我们求步数 $n_{\\mathrm{IM}}$：\n$$ n_{\\mathrm{IM}}(k) = \\frac{k \\ln(10)}{\\ln(1/\\lvert R_{\\mathrm{IM}}(-1) \\rvert)} = \\frac{k \\ln(10)}{\\ln(1/(1/3))} = \\frac{k \\ln(10)}{\\ln(3)} $$\n\n将两个结果合并为所要求的数对格式 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$，我们得到最终表达式。",
            "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{k \\ln(10)}{\\ln(8/3)}  \\frac{k \\ln(10)}{\\ln(3)} \\end{pmatrix}} $$"
        },
        {
            "introduction": "在实际应用中，使用固定的时间步长往往效率低下：在解变化缓慢时过于保守，在解急剧变化时又可能不够精确。为了解决这个问题，现代求解器采用自适应步长控制。本练习  将指导您实现一个著名的嵌入式龙格-库塔方法——Dormand-Prince 5(4)——的单步自适应逻辑。通过这个实践，您将学会如何估计局部误差并动态调整步长，这是构建高效、稳健的数值模拟程序的关键一步。",
            "id": "3613947",
            "problem": "您的任务是为常微分方程 (ODE) $y^{\\prime}(t) = f(t,y)$（其中 $f(t,y) = -y$）给出的初值问题，从 $(t_n, y_n)$ 开始，实现 Dormand–Prince Runge–Kutta $5(4)$ 方法（下文分别简称为 Dormand–Prince (DP) 和 Runge–Kutta (RK)）的单个自适应步。该方法必须使用嵌入对来估计局部截断误差并决定是接受还是拒绝该步，并且必须根据标准控制器推荐一个新的步长。此任务必须从第一性原理解决：从 ODE 定义 $y^{\\prime} = f(t,y)$、由内部阶段计算 $k_i$ 定义的单步 Runge–Kutta 方法的概念，以及在步末提供两个不同阶数近似值以估计局部误差的嵌入对的定义开始。\n\n使用以下 Dormand–Prince $5(4)$ Butcher 表数据（这些是定义此特定 RK 方法的、经过充分检验的系数）：\n- 节点 $c_i$：\n$$\nc_1 = 0, \\quad c_2 = \\tfrac{1}{5}, \\quad c_3 = \\tfrac{3}{10}, \\quad c_4 = \\tfrac{4}{5}, \\quad c_5 = \\tfrac{8}{9}, \\quad c_6 = 1, \\quad c_7 = 1.\n$$\n- 用于计算各阶段的矩阵 $a_{ij}$：\n$$\na_{21} = \\tfrac{1}{5};\n$$\n$$\na_{31} = \\tfrac{3}{40}, \\quad a_{32} = \\tfrac{9}{40};\n$$\n$$\na_{41} = \\tfrac{44}{45}, \\quad a_{42} = -\\tfrac{56}{15}, \\quad a_{43} = \\tfrac{32}{9};\n$$\n$$\na_{51} = \\tfrac{19372}{6561}, \\quad a_{52} = -\\tfrac{25360}{2187}, \\quad a_{53} = \\tfrac{64448}{6561}, \\quad a_{54} = -\\tfrac{212}{729};\n$$\n$$\na_{61} = \\tfrac{9017}{3168}, \\quad a_{62} = -\\tfrac{355}{33}, \\quad a_{63} = \\tfrac{46732}{5247}, \\quad a_{64} = \\tfrac{49}{176}, \\quad a_{65} = -\\tfrac{5103}{18656};\n$$\n$$\na_{71} = \\tfrac{35}{384}, \\quad a_{72} = 0, \\quad a_{73} = \\tfrac{500}{1113}, \\quad a_{74} = \\tfrac{125}{192}, \\quad a_{75} = -\\tfrac{2187}{6784}, \\quad a_{76} = \\tfrac{11}{84}.\n$$\n- 用于五阶解 $y_{n+1}^{(5)}$ 的权重 $b_i$：\n$$\nb_1 = \\tfrac{35}{384}, \\quad b_2 = 0, \\quad b_3 = \\tfrac{500}{1113}, \\quad b_4 = \\tfrac{125}{192}, \\quad b_5 = -\\tfrac{2187}{6784}, \\quad b_6 = \\tfrac{11}{84}, \\quad b_7 = 0.\n$$\n- 用于嵌入的四阶解 $y_{n+1}^{(4)}$ 的权重 $\\hat{b}_i$：\n$$\n\\hat{b}_1 = \\tfrac{5179}{57600}, \\quad \\hat{b}_2 = 0, \\quad \\hat{b}_3 = \\tfrac{7571}{16695}, \\quad \\hat{b}_4 = \\tfrac{393}{640}, \\quad \\hat{b}_5 = -\\tfrac{92097}{339200}, \\quad \\hat{b}_6 = \\tfrac{187}{2100}, \\quad \\hat{b}_7 = \\tfrac{1}{40}.\n$$\n\n对于给定的试验步长 $h$，根据 RK 构造计算 $7$ 个阶段值 $k_i$：\n$$\nk_i = f\\!\\left(t_n + c_i h,\\, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right),\n$$\n然后计算两个嵌入解：\n$$\ny_{n+1}^{(5)} = y_n + h \\sum_{i=1}^{7} b_i k_i, \\qquad y_{n+1}^{(4)} = y_n + h \\sum_{i=1}^{7} \\hat{b}_i k_i.\n$$\n\n将局部误差估计定义为差值 $e = y_{n+1}^{(5)} - y_{n+1}^{(4)}$。使用适用于自适应时间步长的缩放误差范数：\n$$\n\\mathrm{err} = \\frac{|e|}{\\mathrm{atol} + \\mathrm{rtol}\\cdot \\max\\!\\left(|y_n|,\\, |y_{n+1}^{(5)}|\\right)}.\n$$\n这里 $\\mathrm{rtol}$ 和 $\\mathrm{atol}$ 分别是相对和绝对容差。对于此问题，您必须设置 $\\mathrm{rtol} = \\mathrm{atol} = \\mathrm{tol}$，其中 $\\mathrm{tol}$ 是每个测试用例中给定的容差参数。\n\n接受准则：当且仅当 $\\mathrm{err} \\le 1$ 时，接受该步。如果接受，则推进到 $t_{n+1} = t_n + h$，解为 $y_{n+1} = y_{n+1}^{(5)}$。如果拒绝，则不推进，即保持 $t_{n+1} = t_n$ 和 $y_{n+1} = y_n$。\n\n使用不带比例-积分滤波的标准控制器推荐新的步长 $h_{\\mathrm{new}}$：\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left( s \\cdot \\mathrm{err}^{-1/5},\\, f_{\\min},\\, f_{\\max}\\right),\n$$\n其中 $s$ 是一个安全因子，裁剪函数将步长乘法因子限制在区间 $[f_{\\min}, f_{\\max}]$ 内。使用 $s = 0.9$，$f_{\\min} = 0.2$ 和 $f_{\\max} = 5$。在退化情况 $\\mathrm{err} = 0$ 下，将乘法因子定义为 $f_{\\max}$。指数 $1/5$ 对应于控制五阶方法的局部误差。\n\n实现此单步自适应 RK 过程，并将其应用于 ODE $y^{\\prime} = -y$ 的以下每个测试用例。在所有情况下，均精确使用 $f(t,y) = -y$，不作近似。测试套件由元组 $(t_n, y_n, h, \\mathrm{tol})$ 组成：\n- 用例 1：$(0,\\, 1,\\, 0.1,\\, 10^{-6})$。\n- 用例 2：$(0,\\, 1,\\, 2.0,\\, 10^{-6})$。\n- 用例 3：$(5,\\, e^{-5},\\, 0.5,\\, 10^{-12})$。\n- 用例 4：$(0,\\, 1,\\, 10^{-8},\\, 10^{-6})$。\n\n对于每个用例，输出一个包含四个项目的列表：布尔类型的步长接受标志、推进后的时间 $t_{n+1}$、推进后的解 $y_{n+1}$ 以及推荐的下一步长 $h_{\\mathrm{new}}$。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为逗号分隔的列表，并用方括号括起来。例如，一个有效的格式是\n$[ [\\mathrm{True},\\, t_1,\\, y_1,\\, h_1],\\, [\\mathrm{False},\\, t_2,\\, y_2,\\, h_2],\\, \\ldots ]$\n其中每个 $t_i$、$y_i$ 和 $h_i$ 均为浮点数。",
            "solution": "该问题是有效的。它提出了一个在数值分析领域中明确定义的任务：为指定的常微分方程 (ODE) 和一组初始条件，实现 Dormand–Prince 5(4) Runge–Kutta 方法的单个自适应步。所有必要的参数、公式和条件都已提供，并且它们与关于 ODE 数值方法的既有科学文献一致。\n\n任务是为由 ODE $y'(t) = f(t,y)$ 定义的初值问题，从初始点 $(t_n, y_n)$ 和试验步长 $h$ 开始，计算一个自适应步。需要求解的具体 ODE 是 $y'(t) = -y$，因此 $f(t,y) = -y$。\n\n显式 Runge–Kutta 方法是一种用于逼近 ODE 解的单步数值程序。它由一组系数定义，这些系数组织在一个 Butcher 表中，该表包含一个节点向量 $c = (c_i)$、一个系数矩阵 $A = (a_{ij})$ 和一个权重向量 $b = (b_i)$。对于一个 $s$ 阶方法，对真解 $y(t_n+h)$ 的近似值 $y_{n+1}$ 的计算过程如下：\n首先，对 $i = 1, \\dots, s$ 顺序计算 $s$ 个中间阶段 $k_i$：\n$$k_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right)$$\n然后，将下一时间步的解构造成这些阶段的加权平均：\n$$y_{n+1} = y_n + h \\sum_{i=1}^{s} b_i k_i$$\n\n该问题指定了一个嵌入式 Runge–Kutta 对，即 Dormand–Prince $5(4)$ 方法，这是一个 $7$ 阶段方法 ($s=7$)。该方法使用同一组阶段值 $k_i$ 计算两个不同阶数的解，一个五阶精确解 $y_{n+1}^{(5)}$ 和一个四阶精确解 $y_{n+1}^{(4)}$。\n五阶解使用权重 $b_i$：\n$$y_{n+1}^{(5)} = y_n + h \\sum_{i=1}^{7} b_i k_i$$\n嵌入的四阶解使用权重 $\\hat{b}_i$：\n$$y_{n+1}^{(4)} = y_n + h \\sum_{i=1}^{7} \\hat{b}_i k_i$$\n\nDormand–Prince $5(4)$ 方法由以下 Butcher 表系数定义：\n节点 $c_i$：\n$$c = \\left[0, \\tfrac{1}{5}, \\tfrac{3}{10}, \\tfrac{4}{5}, \\tfrac{8}{9}, 1, 1\\right]^T$$\n矩阵 $A = (a_{ij})$：\n$$\n\\begin{array}{c|ccccccc}\n0        \\\\\n1/5   1/5       \\\\\n3/10   3/40   9/40      \\\\\n4/5   44/45   -56/15   32/9     \\\\\n8/9   19372/6561   -25360/2187   64448/6561   -212/729    \\\\\n1   9017/3168   -355/33   46732/5247   49/176   -5103/18656   \\\\\n1   35/384   0   500/1113   125/192   -2187/6784   11/84   0\n\\end{array}\n$$\n用于 $y_{n+1}^{(5)}$ 的权重 $b_i$：\n$$b = \\left[\\tfrac{35}{384}, 0, \\tfrac{500}{1113}, \\tfrac{125}{192}, -\\tfrac{2187}{6784}, \\tfrac{11}{84}, 0\\right]$$\n用于 $y_{n+1}^{(4)}$ 的权重 $\\hat{b}_i$：\n$$\\hat{b} = \\left[\\tfrac{5179}{57600}, 0, \\tfrac{7571}{16695}, \\tfrac{393}{640}, -\\tfrac{92097}{339200}, \\tfrac{187}{2100}, \\tfrac{1}{40}\\right]$$\n\n单个自适应步的算法流程如下：\n\n**1. 阶段计算**\n给定 $(t_n, y_n)$ 和步长 $h$，我们计算 $7$ 个阶段 $k_1, \\dots, k_7$。对于特定的 ODE $f(t,y) = -y$，这些阶段与 $t$ 无关，计算如下：\n$k_1 = f(t_n, y_n) = -y_n$\n$k_2 = f(t_n + c_2 h, y_n + h a_{21} k_1) = -(y_n + h a_{21} k_1)$\n$k_3 = f(t_n + c_3 h, y_n + h (a_{31} k_1 + a_{32} k_2)) = -(y_n + h (a_{31} k_1 + a_{32} k_2))$\n...以此类推，直到 $k_7$：\n$$k_i = -\\left(y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right) \\quad \\text{for } i=1,\\dots,7$$\n这里，当 $i=1$ 时，求和为零。\n\n**2. 误差估计**\n两个解之间的差值提供了对低阶方法局部截断误差的估计：\n$$e = y_{n+1}^{(5)} - y_{n+1}^{(4)} = h \\sum_{i=1}^{7} (b_i - \\hat{b}_i) k_i$$\n为了判断该步是否足够精确，将此误差与用户定义的容差进行比较。计算一个缩放误差范数 $\\mathrm{err}$：\n$$\\mathrm{err} = \\frac{|e|}{\\mathrm{atol} + \\mathrm{rtol}\\cdot \\max(|y_n|, |y_{n+1}^{(5)}|)}$$\n在此问题中，相对和绝对容差被设置为相等，即 $\\mathrm{rtol} = \\mathrm{atol} = \\mathrm{tol}$。因此，误差缩放项为 $\\mathrm{tol} \\cdot (1 + \\max(|y_n|, |y_{n+1}^{(5)}|))$。\n\n**3. 步长接受和状态更新**\n如果缩放误差小于或等于 1，即 $\\mathrm{err} \\le 1$，则接受该步。\n- 如果该步被接受，则推进时间和解。高阶解用于传播（这称为局部外推）：$t_{n+1} = t_n + h$ 且 $y_{n+1} = y_{n+1}^{(5)}$。\n- 如果该步被拒绝，则不推进时间和解：$t_{n+1} = t_n$ 且 $y_{n+1} = y_n$。必须用更小的步长重试该步。\n\n**4. 新步长推荐**\n无论接受与否，都会为下一次尝试提出一个新的、更合适的步长 $h_{\\mathrm{new}}$。使用一个标准的比例控制器：\n$$h_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left( s \\cdot \\mathrm{err}^{-\\frac{1}{p+1}},\\, f_{\\min},\\, f_{\\max}\\right)$$\n这里，$p=4$ 是误差估计的阶数，所以指数是 $1/5$。安全因子 $s=0.9$ 确保了保守的选择，而裁剪函数将步长的变化限制在因子 $f_{\\min}=0.2$ 和 $f_{\\max}=5$ 之间。\n在 $\\mathrm{err}$ 为零的情况下（由于浮点运算或解是精确的），乘法因子被设置为其最大值 $f_{\\max}$。\n\n该实现将把此过程应用于所提供的四个测试用例 $(t_n, y_n, h, \\mathrm{tol})$ 中的每一个，报告步长接受情况、下一个状态 $(t_{n+1}, y_{n+1})$ 以及推荐的下一步长 $h_{\\mathrm{new}}$。\n- 用例 1：$(0,\\, 1,\\, 0.1,\\, 10^{-6})$。\n- 用例 2：$(0,\\, 1,\\, 2.0,\\, 10^{-6})$。\n- 用例 3：$(5,\\, e^{-5},\\, 0.5,\\, 10^{-12})$。\n- 用例 4：$(0,\\, 1,\\, 10^{-8},\\, 10^{-6})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the Dormand-Prince step for all test cases\n    and prints the formatted results.\n    \"\"\"\n\n    def dormand_prince_step(t_n, y_n, h, tol):\n        \"\"\"\n        Performs a single adaptive step of the Dormand-Prince 5(4) method.\n\n        Args:\n            t_n (float): Initial time.\n            y_n (float): Initial solution value.\n            h (float): Trial step size.\n            tol (float): Tolerance for error control (both rtol and atol).\n\n        Returns:\n            tuple: (step_accepted, t_next, y_next, h_new)\n        \"\"\"\n        # Dormand-Prince 5(4) Butcher Tableau coefficients\n        c = np.array([0, 1/5, 3/10, 4/5, 8/9, 1, 1], dtype=np.float64)\n        \n        A = np.array([\n            [0, 0, 0, 0, 0, 0, 0],\n            [1/5, 0, 0, 0, 0, 0, 0],\n            [3/40, 9/40, 0, 0, 0, 0, 0],\n            [44/45, -56/15, 32/9, 0, 0, 0, 0],\n            [19372/6561, -25360/2187, 64448/6561, -212/729, 0, 0, 0],\n            [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656, 0, 0],\n            [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0]\n        ], dtype=np.float64)\n        \n        # Weights for the 5th order solution\n        b = np.array([35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0], dtype=np.float64)\n        \n        # Weights for the 4th order embedded solution\n        b_hat = np.array([5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40], dtype=np.float64)\n\n        # ODE function\n        def f(t, y):\n            return -y\n\n        # Step-size controller parameters\n        s = 0.9\n        f_min = 0.2\n        f_max = 5.0\n\n        # --- 1. Stage Calculation ---\n        k = np.zeros(7, dtype=np.float64)\n        for i in range(7):\n            y_stage = y_n + h * np.dot(A[i, :i], k[:i])\n            k[i] = f(t_n + c[i] * h, y_stage)\n\n        # --- 2. Compute 5th and 4th order solutions ---\n        y_n5 = y_n + h * np.dot(b, k)\n        y_n4 = y_n + h * np.dot(b_hat, k)\n\n        # --- 3. Error Estimation ---\n        e = y_n5 - y_n4  # Local error estimate\n        \n        # Scale for error norm\n        atol = tol\n        rtol = tol\n        error_scale = atol + rtol * max(np.abs(y_n), np.abs(y_n5))\n        \n        # Avoid division by zero if tolerances and solution are zero\n        if error_scale == 0.0:\n            err = 0.0\n        else:\n            err = np.abs(e) / error_scale\n\n        # --- 4. Step Acceptance ---\n        accepted = err = 1.0\n\n        if accepted:\n            t_next = t_n + h\n            y_next = y_n5\n        else:\n            t_next = t_n\n            y_next = y_n\n\n        # --- 5. New Step Size Recommendation ---\n        if err == 0.0:\n            factor = f_max\n        else:\n            factor = s * (err ** -0.2)\n        \n        factor_clipped = np.clip(factor, f_min, f_max)\n        h_new = h * factor_clipped\n\n        return [accepted, t_next, y_next, h_new]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 0.1, 1e-6),\n        (0.0, 1.0, 2.0, 1e-6),\n        (5.0, np.exp(-5), 0.5, 1e-12),\n        (0.0, 1.0, 1e-8, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        t_n, y_n, h, tol = case\n        result = dormand_prince_step(t_n, y_n, h, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() for a list gives the python list representation,\n    # which includes spaces after commas, matching the visual style of the example.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}