{
    "hands_on_practices": [
        {
            "introduction": "在地球物理建模中，尤其是在处理源点附近的势场问题时，我们经常会遇到在积分端点处具有奇异性的被积函数。标准的求积法则，如复合辛普森法则，其高阶收敛性依赖于被积函数的光滑性假设。本练习将引导您探索一种强大的分析技术——坐标变换（或称“网格分级”），通过巧妙的变量代换来消除端点奇异性对收敛阶的影响，从而恢复数值方法原有的高效率。这项实践旨在训练您识别并处理奇异积分的能力，这是计算科学中一个核心的、以巧取胜的策略 。",
            "id": "3612106",
            "problem": "在对钻孔周围的轴对称势流进行建模时，一个常见的数值任务是计算形如下式的端点奇异积分：\n$$\nI = \\int_{0}^{1} r^{\\alpha} q(r)\\,dr,\n$$\n其中 $q(r)$ 是 $[0,1]$ 上的光滑函数且 $q(0)\\neq 0$，指数 $\\alpha\\in(-1,0)$ 用于模拟核函数在源点附近一个物理上合理的代数奇异性。您计划使用复合辛普森法则来近似计算 $I$。已知当该法则应用于在积分区间上具有有界四阶导数的函数时，其全局收敛阶为四阶。\n\n由于端点奇异性破坏了原始坐标 $r$ 下的光滑性要求，考虑通过变量替换 $r = t^{p}$（加密指数 $p0$）来实现一种幂律网格加密，从而得到：\n$$\nI = \\int_{0}^{1} p\\,t^{p-1}\\,(t^{p})^{\\alpha}\\,q(t^{p})\\,dt = \\int_{0}^{1} F(t)\\,dt,\n$$\n其中 $F(t) = p\\,t^{p(\\alpha+1)-1}\\,q(t^{p})$。然后，您将复合辛普森法则应用于 $t\\in[0,1]$ 上的一个均匀划分，该划分包含 $n$ 个子区间（其中 $n$ 为偶数，且 $h = 1/n$）。\n\n从复合辛普森法则的基本误差原理以及 $F^{(4)}(t)$ 在 $t=0$ 附近的主阶行为出发，推导能够使 $I$ 在变换坐标 $t$ 中的复合辛普森近似恢复相对于 $n$ 的四阶目标全局收敛阶的最小幂律加密指数 $p$。请以关于 $\\alpha$ 的单个闭式解析表达式的形式给出最优加密指数的最终答案。无需进行数值计算，答案中也无需单位。",
            "solution": "问题要求找出最小的幂律加密指数 $p$，以恢复复合辛普森法则在处理一类特定奇异积分时的四阶收敛性。\n\n需要近似计算的积分是\n$$I = \\int_{0}^{1} r^{\\alpha} q(r)\\,dr$$\n其中 $q(r)$ 是 $[0,1]$ 上的光滑函数且 $q(0)\\neq 0$，奇异性指数为 $\\alpha \\in (-1,0)$。奇异点位于积分下限 $r=0$ 处。\n\n复合辛普森法则的理论全局收敛阶为 $O(h^4)$（其中 $h$ 是子区间宽度），前提是被积函数在积分区间上至少四次连续可微，即属于 $C^4[0,1]$ 类。对于我们原来的积分，被积函数是 $f(r) = r^{\\alpha}q(r)$。它的导数将包含形如 $r^{\\alpha-k}$ 的项，由于 $\\alpha  0$，这些项在 $r=0$ 处是无界的。因此，直接应用辛普森法则不会得到四阶收敛性。\n\n为解决此问题，引入变量替换 $r = t^p$（加密指数 $p0$）。积分变换如下：\n$$dr = p\\,t^{p-1}\\,dt$$\n$$I = \\int_{0}^{1} (t^p)^{\\alpha} q(t^p) (p\\,t^{p-1}\\,dt) = \\int_{0}^{1} p\\,t^{p\\alpha+p-1}\\,q(t^p)\\,dt$$\n这可以写成 $I = \\int_{0}^{1} F(t)\\,dt$，其中新的被积函数是\n$$F(t) = p\\,t^{p(\\alpha+1)-1}\\,q(t^{p})$$\n现在，我们在 $t$ 变量的均匀网格上对这个变换后的积分应用复合辛普森法则。为了恢复 $O(h^4)$ 的收敛性，我们必须选择合适的 $p$，使得新的被积函数 $F(t)$ 在区间 $t \\in [0,1]$ 上足够光滑。\n\n求积法则对于具有端点奇异性的被积函数的收敛阶取决于被积函数的光滑性。对于一个在 $t=0$ 附近行为类似于 $t^\\beta$ 的被积函数，复合辛普森法则（一种四阶方法）的收敛阶通常由 $O(h^{\\min(4, \\beta+1)})$ 给出。为达到四阶收敛，我们必须确保 $\\min(4, \\beta+1) = 4$，这意味着条件 $\\beta+1 \\ge 4$ 或 $\\beta \\ge 3$ 必须满足。\n\n让我们确定变换后函数 $F(t)$ 的有效指数 $\\beta$。函数 $q(r)$ 在 $[0,1]$ 上是光滑的，因此它在 $r=0$ 附近可以进行泰勒级数展开：\n$$q(r) = q(0) + q'(0)r + \\frac{q''(0)}{2!}r^2 + \\dots$$\n由于 $q(0) \\neq 0$，我们代入 $r=t^p$ 来找出当 $t$ 很小时 $q(t^p)$ 的行为：\n$$q(t^p) = q(0) + q'(0)t^p + O(t^{2p})$$\n现在，我们将此式代入 $F(t)$ 的表达式中：\n$$F(t) = p\\,t^{p(\\alpha+1)-1}\\,[q(0) + q'(0)t^p + \\dots]$$\n$$F(t) = p\\,q(0)\\,t^{p(\\alpha+1)-1} + p\\,q'(0)\\,t^{p(\\alpha+1)-1+p} + \\dots$$\n由于 $p0$，决定 $F(t)$ 在 $t=0$ 附近行为的主阶项是第一项。因此，有效奇异性指数为：\n$$\\beta_{\\text{eff}} = p(\\alpha+1)-1$$\n为了恢复四阶收敛性，我们必须满足条件 $\\beta_{\\text{eff}} \\ge 3$：\n$$p(\\alpha+1)-1 \\ge 3$$\n$$p(\\alpha+1) \\ge 4$$\n已知 $\\alpha \\in (-1,0)$，这意味着 $\\alpha+1$ 在区间 $(0,1)$ 内。由于 $\\alpha+1  0$，我们可以用它来除不等式而无需改变不等号的方向：\n$$p \\ge \\frac{4}{\\alpha+1}$$\n问题要求的是恢复目标收敛阶的*最小*幂律加密指数 $p$。这对应于满足所推导条件的最小值，通过取等号得到：\n$$p = \\frac{4}{\\alpha+1}$$\n\n让我们验证一下，正如问题前提所提示的，这个 $p$ 的选择确实使得被积函数的四阶导数有界。如果我们设 $p = 4/(\\alpha+1)$，那么 $\\beta_{\\text{eff}} = p(\\alpha+1)-1 = 4-1=3$。函数 $F(t)$ 的形式为：\n$$F(t) = p\\,q(0)\\,t^3 + p\\,q'(0)\\,t^{3+p} + \\dots$$\n这是一系列形如 $C_k t^{\\gamma_k}$ 的项，其中指数为 $\\gamma_0=3, \\gamma_1=3+p$ 等。我们来考虑四阶导数 $F^{(4)}(t)$。主项 $\\frac{d^4}{dt^4}(p\\,q(0)\\,t^3)$ 的导数为零。因此，$F^{(4)}(t)$ 的主阶行为由级数中下一项的导数决定：\n$$\\frac{d^4}{dt^4} (p\\,q'(0)\\,t^{3+p}) = p\\,q'(0)\\,(3+p)(2+p)(1+p)p\\,t^{p-1} + \\dots$$\n$F^{(4)}(t)$ 的主项行为类似于 $t^{p-1}$。为了使 $F^{(4)}(t)$ 在 $[0,1]$ 上有界，其主阶指数必须为非负：$p-1 \\ge 0$，即 $p \\ge 1$。我们选择的 $p$ 值为 $p = 4/(\\alpha+1)$。由于 $\\alpha \\in (-1,0)$，我们有 $0  \\alpha+1  1$。这意味着 $p > 4$。因此，$p \\ge 1$ 的条件被轻松满足。所以，选择 $p=4/(\\alpha+1)$ 可以确保 $F^{(4)}(t)$ 是有界的（事实上，$F^{(4)}(0)=0$），这是复合辛普森法则表现出 $O(h^4)$ 收敛性的标准条件。任何更小的 $p$ 值都会导致指数 $\\beta_{\\text{eff}}  3$，从而破坏光滑性要求并降低收敛阶。因此，这是最小值。",
            "answer": "$$\\boxed{\\frac{4}{\\alpha+1}}$$"
        },
        {
            "introduction": "从端点奇异性问题出发，我们转向另一类挑战：被积函数虽然在整个区间内光滑，但包含非常尖锐且集中的峰值。这种情况在地球物理学的谱方法和频域分析中十分常见，例如模拟共振现象。本练习是一个动手编程任务，它将对比固定步长方法（如辛普森法则）和自适应求积方法的表现。通过构建并测试一系列具有挑战性的“对抗性”被积函数，您将亲身体验到固定网格在解析局部剧变特征时的局限性，并深刻理解自适应算法如何通过智能地加密网格来保证计算的精度和鲁棒性 。",
            "id": "3612054",
            "problem": "考虑在层状介质格林函数公式和地球物理响应函数谱域表示中出现的实值积分的数值计算。这些积分通常包含位于自变量（例如波数或频率）实轴附近的复共轭极点的贡献，导致被积函数中出现尖锐的局部峰值，并对求积误差敏感。\n\n设被积函数在单位区间上定义为\n$$\nf(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{(x - c_j)^2 + \\epsilon_j^2},\n$$\n其中 $\\mathbf{c} = (c_1,\\dots,c_m)$ 是实数中心，满足 $c_j \\in [0,1]$；$\\boldsymbol{\\epsilon} = (\\epsilon_1,\\dots,\\epsilon_m)$ 是正实数，满足 $\\epsilon_j  0$，表示每个极点到积分路径的距离；$\\mathbf{A} = (A_1,\\dots,A_m)$ 是实数振幅。函数 $f$ 在 $[0,1]$ 上是光滑的，其复奇点位于 $x = c_j \\pm i \\epsilon_j$。\n\n定义精确积分\n$$\nI_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\int_0^1 f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) \\, dx.\n$$\n定义极点配置的以下对抗性特征度量：\n- 极点到积分路径的最小距离：\n$$\n\\epsilon_{\\min} = \\min_{j} \\epsilon_j.\n$$\n- 极点中心之间的最小间距：\n$$\n\\delta_{\\min} = \\min_{i \\neq j} |c_i - c_j|.\n$$\n（当 $m=1$ 时，按约定取 $\\delta_{\\min}$ 为 $1$。）\n- 最小边界邻近度（到端点的距离）：\n$$\n\\beta_{\\min} = \\min_j \\left( \\min\\{c_j, 1 - c_j\\} \\right).\n$$\n\n对每个问题实例，计算 $I_{\\text{exact}}$，然后使用以下方法计算数值近似值：\n1. 复合 Simpson 法则，将 $[0,1]$ 均匀划分为 $N$ 个相等的子区间（$N$ 为偶数）。将该近似值记为 $I_{\\text{Simpson}}$。\n2. 一种基于 Gauss–Kronrod 思想的自适应求积方法，该方法使用局部误差估计递归地划分子区间，以满足严格的绝对和相对容差。将该近似值记为 $I_{\\text{adaptive}}$。\n\n对于每种方法，计算绝对误差\n$$\nE_{\\text{abs}} = |I_{\\text{method}} - I_{\\text{exact}}|\n$$\n和相对误差\n$$\nE_{\\text{rel}} = \\frac{|I_{\\text{method}} - I_{\\text{exact}}|}{|I_{\\text{exact}}|}.\n$$\n当相对误差超过特定于方法的阈值时，即认为出现数值误差尖峰：\n- 对于自适应方法，如果 $E_{\\text{rel}}  T_{\\text{adaptive}}$，则检测到尖峰，其中 $T_{\\text{adaptive}} = 10^{-6}$。\n- 对于复合 Simpson 法则，如果 $E_{\\text{rel}}  T_{\\text{Simpson}}$，则检测到尖峰，其中 $T_{\\text{Simpson}} = 10^{-2}$。\n\n您的程序必须实现：\n- 使用积分学第一性原理对形如 $1/((x-c)^2+\\epsilon^2)$ 的有理函数进行推导，从而精确计算 $I_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A})$。\n- 针对每个测试用例，在 $[0,1]$ 上使用给定的 $N$ 实现复合 Simpson 法则。\n- 一种使用足够小的严格容差的自适应求积方法，以揭示对聚集极点的敏感性。\n\n使用这些方法，构造在积分路径附近具有聚集极点的被积函数，并评估其对误差尖峰的鲁棒性。为每个测试用例报告值 $I_{\\text{exact}}$、$I_{\\text{adaptive}}$、$E_{\\text{abs,adaptive}}$、$I_{\\text{Simpson}}$、$E_{\\text{abs,Simpson}}$，以及特征 $\\epsilon_{\\min}$、$\\delta_{\\min}$、$\\beta_{\\min}$，连同指示两种方法是否出现尖峰的布尔值。\n\n测试套件：\n在以下四个测试用例上评估程序，每个用例由 $(\\mathbf{c}, \\boldsymbol{\\epsilon}, \\mathbf{A}, N)$ 指定，$m$ 等于每个向量的长度：\n1. 理想情况（极点分离良好，距离适中）：\n   - $\\mathbf{c} = (0.30, 0.55, 0.80)$\n   - $\\boldsymbol{\\epsilon} = (5\\times 10^{-2}, 4\\times 10^{-2}, 6\\times 10^{-2})$\n   - $\\mathbf{A} = (1.0, 0.8, 0.6)$\n   - $N = 128$。\n2. 内部聚类（中心间距小，距离小）：\n   - $\\mathbf{c} = (0.620, 0.625, 0.627)$\n   - $\\boldsymbol{\\epsilon} = (1.2\\times 10^{-3}, 9\\times 10^{-4}, 1.1\\times 10^{-3})$\n   - $\\mathbf{A} = (1.0, 0.8, 0.7)$\n   - $N = 128$。\n3. 近边界聚类（极点靠近端点 $x=1$）：\n   - $\\mathbf{c} = (0.995, 0.997)$\n   - $\\boldsymbol{\\epsilon} = (2\\times 10^{-3}, 2\\times 10^{-3})$\n   - $\\mathbf{A} = (1.0, 0.9)$\n   - $N = 128$。\n4. 病态聚类（距离极小且在 $x=0$ 附近紧密聚类）：\n   - $\\mathbf{c} = (0.0500, 0.0502, 0.0504)$\n   - $\\boldsymbol{\\epsilon} = (2.0\\times 10^{-4}, 2.5\\times 10^{-4}, 2.0\\times 10^{-4})$\n   - $\\mathbf{A} = (1.0, 1.0, 1.0)$\n   - $N = 128$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表用方括号括起来，每个测试用例对应一个子列表。每个测试用例的列表必须按以下顺序排列\n$$\n\\left[ I_{\\text{exact}},\\ I_{\\text{adaptive}},\\ E_{\\text{abs,adaptive}},\\ I_{\\text{Simpson}},\\ E_{\\text{abs,Simpson}},\\ \\epsilon_{\\min},\\ \\delta_{\\min},\\ \\beta_{\\min},\\ \\sigma_{\\text{adaptive}},\\ \\sigma_{\\text{Simpson}} \\right],\n$$\n其中 $\\sigma_{\\text{adaptive}}$ 和 $\\sigma_{\\text{Simpson}}$ 是布尔值，指示相应方法是否出现尖峰。因此，最终输出的格式为\n$$\n\\left[\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\ \\right].\n$$\n不涉及物理单位；所有量均为无量纲实数，反三角函数中的角度应以弧度处理。",
            "solution": "该问题已经过验证，被确定为数值分析领域内一个适定且有科学依据的任务，具体应用于计算地球物理学中的一个问题原型。所有提供的数据和定义都是完整、一致且在数学上是合理的。该问题要求将一种固定步长的数值积分方法（复合 Simpson 法则）与一种自适应方法进行比较，用于处理一类具有尖锐、聚集峰特征的挑战性被积函数。此分析将在旨在探究不同失效模式的一组四个测试用例上进行。\n\n解决方案首先推导精确积分的解析形式。随后，定义数值方法和特征度量，并概述实现策略，为提供的 Python 代码奠定基础。\n\n### 1. 基于原理的设计：解析与数值评估\n\n问题的核心在于函数 $f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A})$ 在区间 $[0,1]$ 上的积分。\n$$\nf(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{(x - c_j)^2 + \\epsilon_j^2}\n$$\n该函数是洛伦兹函数的和。由于积分是线性算子，和的积分等于积分的和：\n$$\nI_{\\text{exact}} = \\int_0^1 f(x;\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) \\, dx = \\sum_{j=1}^{m} A_j \\int_0^1 \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx\n$$\n因此，问题简化为求取基础有理函数的定积分。\n\n#### 1.1. 精确积分的推导\n我们需要计算积分 $J_j = \\int_0^1 \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx$。\n这是一个标准积分形式。我们使用换元法，令 $u = \\frac{x-c_j}{\\epsilon_j}$，这意味着 $du = \\frac{1}{\\epsilon_j}dx$。积分变换如下：\n$$\n\\int \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx = \\int \\frac{1}{\\epsilon_j^2 \\left( \\left(\\frac{x-c_j}{\\epsilon_j}\\right)^2 + 1 \\right)} \\, dx = \\frac{1}{\\epsilon_j^2} \\int \\frac{1}{u^2+1} (\\epsilon_j \\, du) = \\frac{1}{\\epsilon_j} \\int \\frac{1}{u^2+1} \\, du\n$$\n其不定积分是众所周知的：\n$$\n\\int \\frac{1}{u^2+1} \\, du = \\arctan(u) + C\n$$\n代回 $x$，我们函数的原函数是：\n$$\n\\int \\frac{1}{(x - c_j)^2 + \\epsilon_j^2} \\, dx = \\frac{1}{\\epsilon_j} \\arctan\\left(\\frac{x-c_j}{\\epsilon_j}\\right) + C\n$$\n现在，我们计算在区间 $[0,1]$ 上的定积分：\n$$\nJ_j = \\left[ \\frac{1}{\\epsilon_j} \\arctan\\left(\\frac{x-c_j}{\\epsilon_j}\\right) \\right]_0^1 = \\frac{1}{\\epsilon_j} \\left( \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) - \\arctan\\left(\\frac{0-c_j}{\\epsilon_j}\\right) \\right)\n$$\n利用 $\\arctan(-z) = -\\arctan(z)$ 的性质，可以简化为：\n$$\nJ_j = \\frac{1}{\\epsilon_j} \\left( \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) + \\arctan\\left(\\frac{c_j}{\\epsilon_j}\\right) \\right)\n$$\n总的精确积分 $I_{\\text{exact}}$ 是通过对所有极点求和得到的，并按各自的振幅 $A_j$ 加权：\n$$\nI_{\\text{exact}}(\\mathbf{c},\\boldsymbol{\\epsilon},\\mathbf{A}) = \\sum_{j=1}^{m} \\frac{A_j}{\\epsilon_j} \\left[ \\arctan\\left(\\frac{1-c_j}{\\epsilon_j}\\right) + \\arctan\\left(\\frac{c_j}{\\epsilon_j}\\right) \\right]\n$$\n该公式提供了一种计算基准真值的方法，数值方法将以此为基准进行评估。\n\n#### 1.2. 数值求积方法\n\n**复合 Simpson 法则：**\n这是一种来自 Newton-Cotes 族的固定步长方法，它在每对子区间上用一个二次多项式来近似被积函数。对于一个积分 $\\int_a^b g(x) \\, dx$，将其划分为 $N$ 个等宽（$N$ 必须为偶数）的子区间，宽度为 $h = (b-a)/N$，其公式为：\n$$\nI_{\\text{Simpson}} \\approx \\frac{h}{3} \\left[ g(x_0) + 4\\sum_{k=1}^{N/2} g(x_{2k-1}) + 2\\sum_{k=1}^{N/2-1} g(x_{2k}) + g(x_N) \\right]\n$$\n其中 $x_k = a+kh$。对于我们的问题，$a=0$，$b=1$，且 $h=1/N$。该方法对于光滑、表现良好的被积函数简单而高效。然而，如果固定网格不能充分解析具有局部尖锐特征的函数，其精度会显著下降，而这正是本测试所要检验的场景。\n\n**自适应求积 (Gauss-Kronrod)：**\n与固定步长方法不同，自适应求积算法根据局部误差估计来细化积分区间的划分。在被积函数复杂或变化迅速的区域，区间被划分得更细；在被积函数平滑的区域，划分得更粗。该问题指定了一种基于 Gauss-Kronrod 思想的方法。这涉及到使用两个不同阶的嵌套求积规则（例如，一个 $7$ 点 Gauss 规则和一个 $15$ 点 Kronrod 规则）来估计子区间上的积分和误差。如果误差过大，则分裂该子区间，并递归地应用此过程。这种方法对于有尖峰的被积函数非常有效，因为它将计算量集中在最需要的地方。实现将使用 `scipy.integrate.quad` 函数，它是 Fortran 库 QUADPACK 的一个健壮封装，而 QUADPACK 正是这一原理的实现。为了确保基准测试的最高精度，将向 `quad` 函数请求非常严格的绝对和相对误差容差（例如，$10^{-14}$）。\n\n### 2. 对抗性度量与误差分析\n\n问题定义了三个度量来量化被积函数实例的“难度”：\n- $\\epsilon_{\\min} = \\min_{j} \\epsilon_j$：任意极点到实轴的最小距离。较小的值会导致被积函数中出现更尖锐、更高的峰。\n- $\\delta_{\\min} = \\min_{i \\neq j} |c_i - c_j|$：极点中心之间的最小间距。较小的值意味着峰更紧密地聚集在一起，使得固定网格更难单独解析它们。当 $m=1$ 时，按约定 $\\delta_{\\min}$ 为 $1$。\n- $\\beta_{\\min} = \\min_j \\left( \\min\\{c_j, 1 - c_j\\} \\right)$：任意极点到积分边界 $[0,1]$ 的最小邻近度。靠近边界的极点可能对基于多项式近似的方法构成挑战。\n\n每种数值方法的性能通过其绝对误差 $E_{\\text{abs}} = |I_{\\text{method}} - I_{\\text{exact}}|$ 和相对误差 $E_{\\text{rel}} = E_{\\text{abs}} / |I_{\\text{exact}}|$ 进行评估。如果相对误差超过预定义的阈值，则记录一个误差“尖峰”：对于自适应方法为 $T_{\\text{adaptive}} = 10^{-6}$，对于 Simpson 法则为 $T_{\\text{Simpson}} = 10^{-2}$。这些阈值反映了对复杂的自适应程序与基本的固定步长规则的不同精度期望。\n\n### 3. 实现计划\n\n整体解决方案用 Python 实现。一个主函数处理指定的四个测试用例中的每一个。对于每个用例：\n1. 使用参数 $(\\mathbf{c}, \\boldsymbol{\\epsilon}, \\mathbf{A}, N)$ 来定义特定的被积函数 $f(x)$。\n2. 使用推导出的反正切公式计算精确积分 $I_{\\text{exact}}$。\n3. 使用 `scipy.integrate.quad` 和严格的容差来找到自适应求积近似值 $I_{\\text{adaptive}}$。\n4. 使用具有 $N$ 个区间的自定义实现来计算复合 Simpson 法则近似值 $I_{\\text{Simpson}}$。\n5. 从极点参数计算对抗性度量 $\\epsilon_{\\min}$、$\\delta_{\\min}$ 和 $\\beta_{\\min}$。\n6. 通过与 $I_{\\text{exact}}$ 比较，计算绝对误差 $E_{\\text{abs,adaptive}}$ 和 $E_{\\text{abs,Simpson}}$。\n7. 计算相对误差以确定布尔尖峰指示符 $\\sigma_{\\text{adaptive}}$ 和 $\\sigma_{\\text{Simpson}}$。\n8. 将这十个结果值收集到该测试用例的列表中。\n最后，将所有四个用例的列表汇编并格式化为表示列表的列表的单个字符串，以满足最终输出的要求。这种结构有助于直接比较各种方法的性能与被积函数的对抗性特征在整个测试套件中的相关性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration problem for the given test cases.\n    \"\"\"\n    \n    # Test cases defined as (c, epsilon, A, N) tuples.\n    test_cases = [\n        (\n            np.array([0.30, 0.55, 0.80]),\n            np.array([5e-2, 4e-2, 6e-2]),\n            np.array([1.0, 0.8, 0.6]),\n            128\n        ),\n        (\n            np.array([0.620, 0.625, 0.627]),\n            np.array([1.2e-3, 9e-4, 1.1e-3]),\n            np.array([1.0, 0.8, 0.7]),\n            128\n        ),\n        (\n            np.array([0.995, 0.997]),\n            np.array([2e-3, 2e-3]),\n            np.array([1.0, 0.9]),\n            128\n        ),\n        (\n            np.array([0.0500, 0.0502, 0.0504]),\n            np.array([2.0e-4, 2.5e-4, 2.0e-4]),\n            np.array([1.0, 1.0, 1.0]),\n            128\n        )\n    ]\n\n    T_adaptive = 1e-6\n    T_simpson = 1e-2\n\n    all_results = []\n\n    for c_vec, eps_vec, A_vec, N in test_cases:\n        m = len(c_vec)\n\n        # 1. Define the integrand function f(x)\n        def f(x, c, eps, A):\n            val = 0.0\n            for j in range(len(c)):\n                val += A[j] / ((x - c[j])**2 + eps[j]**2)\n            return val\n\n        # 2. Compute the exact integral I_exact\n        def compute_I_exact(c, eps, A):\n            val = 0.0\n            for j in range(len(c)):\n                term = (A[j] / eps[j]) * (np.arctan((1 - c[j]) / eps[j]) + np.arctan(c[j] / eps[j]))\n                val += term\n            return val\n\n        I_exact = compute_I_exact(c_vec, eps_vec, A_vec)\n\n        # 3. Compute the adaptive quadrature approximation\n        # Use stringent tolerances to get a high-accuracy result.\n        f_case = lambda x: f(x, c_vec, eps_vec, A_vec)\n        I_adaptive, _ = quad(f_case, 0, 1, epsabs=1e-14, epsrel=1e-14)\n        E_abs_adaptive = np.abs(I_adaptive - I_exact)\n        E_rel_adaptive = E_abs_adaptive / np.abs(I_exact) if I_exact != 0 else 0\n        sigma_adaptive = E_rel_adaptive > T_adaptive\n\n        # 4. Compute composite Simpson's rule approximation\n        def simpson_rule(func, a, b, n):\n            if n % 2 != 0:\n                raise ValueError(\"Number of subintervals N must be even.\")\n            h = (b - a) / n\n            x = np.linspace(a, b, n + 1)\n            y = func(x)\n            \n            s = y[0] + y[-1]\n            s += 4 * np.sum(y[1:-1:2]) # Odd-indexed points\n            s += 2 * np.sum(y[2:-2:2]) # Even-indexed points\n            \n            return h / 3 * s\n\n        I_simpson = simpson_rule(f_case, 0, 1, N)\n        E_abs_simpson = np.abs(I_simpson - I_exact)\n        E_rel_simpson = E_abs_simpson / np.abs(I_exact) if I_exact != 0 else 0\n        sigma_simpson = E_rel_simpson > T_simpson\n\n        # 5. Compute adversarial feature metrics\n        eps_min = np.min(eps_vec)\n        \n        if m > 1:\n            delta_min = np.min([np.abs(c_i - c_j) for c_i, c_j in combinations(c_vec, 2)])\n        else:\n            delta_min = 1.0\n            \n        beta_min = np.min(np.minimum(c_vec, 1 - c_vec))\n        \n        # 6. Assemble the results list for the current case\n        case_results = [\n            I_exact, I_adaptive, E_abs_adaptive,\n            I_simpson, E_abs_simpson,\n            eps_min, delta_min, beta_min,\n            sigma_adaptive, sigma_simpson\n        ]\n        all_results.append(case_results)\n\n    # 7. Format the final output string\n    # str(sublist) will produce '[item1, item2, ...]'\n    # We join these strings with a comma, then wrap the whole thing in brackets.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将探讨一个更为隐蔽的数值陷阱：计算过程中的数值不稳定性。在模拟近共振模式的叠加等波动现象时，我们可能需要计算两个非常相近的大量之差，这极易引发“灾难性相消”问题，导致计算结果的有效数字大量丢失。本练习通过一个振荡积分的例子，揭示了即使问题具有精确的解析解，一种看似直接的数值计算策略也可能导致灾难性的失败。它强调了在进行数值计算之前，进行解析预处理（例如，利用三角恒等式进行重构）以将问题转化为数值稳定形式的极端重要性 。",
            "id": "3612057",
            "problem": "在为水平分层声学半空间中近共振压缩波模式的衰减叠加建模时，固定接收器偏移处时域压力轨迹的频域表示，在经过逆变换后，可以写成一个实值振荡积分。对于两个相邻共振的贡献，一个简化但科学上一致的一维代理是积分\n$$\nI(\\alpha,\\omega,\\delta) \\equiv \\int_{0}^{\\infty} \\exp(-\\alpha x)\\,\\big[\\cos(\\omega x) - \\cos((\\omega+\\delta)x)\\big]\\,\\mathrm{d}x,\n$$\n其中 $\\alpha0$ 是有效衰减系数（源于粘声损耗），$\\omega0$ 是中心角频率，而 $\\delta0$ 是一个表示两个模态频率近重合的小失谐。在数值积分中，当 $\\delta$ 很小时，一种分别计算 $\\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos(\\omega x)\\,\\mathrm{d}x$ 和 $\\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos((\\omega+\\delta)x)\\,\\mathrm{d}x$ 这两项然后相减的朴素计算方法，往往会遭受灾难性抵消的影响。\n\n从拉普拉斯变换的基本定义和基本三角恒等式出发，并且不使用任何专门的积分误差公式，完成以下任务：\n\n1. 从减法的条件数和被积函数的结构方面解释，为什么当 $\\delta$ 很小时，如果分开计算两个贡献项然后相减，预期会发生灾难性抵消。\n\n2. 提出一种对被积函数的解析预处理或重排，通过避免直接减去两个几乎相等的大贡献项，来提高当 $\\delta$ 很小时积分的数值稳定性。你的重排必须在代数上是精确的，保持 $I(\\alpha,\\omega,\\delta)$ 的值不变，并显式地提出控制小 $\\delta$ 下最终被积函数振幅的任何小因子。\n\n3. 使用所提出的预处理方法，推导出一个对所有 $\\alpha0$、$\\omega0$ 和 $\\delta0$ 都有效的 $I(\\alpha,\\omega,\\delta)$ 的精确闭式表达式。推导过程必须从基本性质（例如有界函数的拉普拉斯变换定义和标准的三角积化和差恒等式）开始，并逐步进行到最终的简化表达式。\n\n以 $\\alpha$、$\\omega$ 和 $\\delta$ 表示的单个闭式解析表达式的形式提供你的最终答案。不需要进行数值计算。",
            "solution": "该问题要求对积分 $I(\\alpha,\\omega,\\delta) \\equiv \\int_{0}^{\\infty} \\exp(-\\alpha x)\\,\\big[\\cos(\\omega x) - \\cos((\\omega+\\delta)x)\\big]\\,\\mathrm{d}x$ 进行分析，其中参数 $\\alpha0$、$\\omega0$ 和 $\\delta0$。解答按要求分为三部分呈现。\n\n第1部分：灾难性抵消的解释\n\n该积分的朴素数值计算涉及分别计算两个积分 $I_1$ 和 $I_2$，然后求它们的差：\n$$\nI_1 = \\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos(\\omega x)\\,\\mathrm{d}x\n$$\n$$\nI_2 = \\int_{0}^{\\infty} \\exp(-\\alpha x)\\cos((\\omega+\\delta)x)\\,\\mathrm{d}x\n$$\n原始积分的值则为 $I(\\alpha,\\omega,\\delta) = I_1 - I_2$。\n\n这些积分是拉普拉斯变换的实例。函数 $f(t)$ 的拉普拉斯变换定义为 $\\mathcal{L}\\{f(t)\\}(s) = \\int_0^\\infty \\exp(-st)f(t)\\,\\mathrm{d}t$。一个标准的拉普拉斯变换对是余弦函数：$\\mathcal{L}\\{\\cos(kt)\\}(s) = \\frac{s}{s^2+k^2}$。\n应用此公式，令 $s=\\alpha$，我们可以求得 $I_1$ 和 $I_2$ 的精确值：\n$$\nI_1 = \\mathcal{L}\\{\\cos(\\omega x)\\}(\\alpha) = \\frac{\\alpha}{\\alpha^2 + \\omega^2}\n$$\n$$\nI_2 = \\mathcal{L}\\{\\cos((\\omega+\\delta)x)\\}(\\alpha) = \\frac{\\alpha}{\\alpha^2 + (\\omega+\\delta)^2}\n$$\n问题指出 $\\delta$ 是一个小失谐，意味着 $\\delta \\ll \\omega$。当 $\\delta \\to 0$ 时，$(\\omega+\\delta)^2$ 项趋近于 $\\omega^2$。因此，分母 $\\alpha^2 + (\\omega+\\delta)^2$ 趋近于 $\\alpha^2 + \\omega^2$。这意味着 $I_2$ 变得非常接近 $I_1$。\n\n在有限精度算术中，当两个几乎相等的数相减时，就会发生灾难性抵消。如果 $I_1$ 和 $I_2$ 是通过数值方法（例如，使用求积法则）计算的，它们会被存储为具有有限有效数字的浮点数。当 $\\delta$ 很小时，$I_1$ 和 $I_2$ 将几乎相同。它们的差 $I_1 - I_2$ 将导致开头的、最高位的有效数字相互抵消。减法的结果将由较低位的有效数字决定，而这些数字在计算 $I_1$ 和 $I_2$ 的数值过程中受累积舍入误差的影响最大。这会导致结果的相对误差很大，并造成严重的精度损失。当操作数彼此接近时，减法运算是病态的，这正是 $\\delta$ 很小时朴素计算方案所面临的情况。\n\n第2部分：为提高数值稳定性的解析预处理\n\n为了避免减去几乎相等的量，我们可以将被积函数重排成不涉及差的形式。关键是使用三角恒等式来变换表达式 $\\cos(\\omega x) - \\cos((\\omega+\\delta)x)$。我们使用和差化积恒等式中关于两个余弦之差的公式：\n$$\n\\cos(A) - \\cos(B) = -2 \\sin\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)\n$$\n令 $A = \\omega x$ 且 $B = (\\omega+\\delta)x$。则有：\n$$\n\\frac{A+B}{2} = \\frac{\\omega x + (\\omega+\\delta)x}{2} = \\frac{(2\\omega+\\delta)x}{2} = \\left(\\omega + \\frac{\\delta}{2}\\right)x\n$$\n$$\n\\frac{A-B}{2} = \\frac{\\omega x - (\\omega+\\delta)x}{2} = \\frac{-\\delta x}{2}\n$$\n将这些代入恒等式，并利用性质 $\\sin(-z) = -\\sin(z)$，我们得到：\n$$\n\\cos(\\omega x) - \\cos((\\omega+\\delta)x) = -2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(-\\frac{\\delta x}{2}\\right) = 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(\\frac{\\delta x}{2}\\right)\n$$\n现在，这个积分可以用这个代数上精确的重排形式重写：\n$$\nI(\\alpha,\\omega,\\delta) = \\int_{0}^{\\infty} \\exp(-\\alpha x) \\left[ 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\sin\\left(\\frac{\\delta x}{2}\\right) \\right] \\mathrm{d}x\n$$\n这种形式对于小 $\\delta$ 是数值稳定的。对于小自变量 $z$，$ \\sin(z) \\approx z$。因此，对于小 $\\delta$，$\\sin(\\frac{\\delta x}{2})$ 项近似为 $\\frac{\\delta x}{2}$。因此，被积函数近似与 $\\delta$ 成正比：\n$$\n\\text{Integrand} \\approx \\exp(-\\alpha x) \\cdot 2 \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right) \\cdot \\frac{\\delta x}{2} = \\delta x \\exp(-\\alpha x) \\sin\\left(\\left(\\omega + \\frac{\\delta}{2}\\right)x\\right)\n$$\n控制小 $\\delta$ 下积分振幅的小因子 $\\delta$ 现在是作为被积函数中的一个显式乘法因子。将数值积分方案应用于这种新形式，是对一个本身就很小的函数进行积分，得到的结果将是直接计算出的小数值，从而避免了灾难性抵消。\n\n第3部分：闭式表达式的推导\n\n为了推导 $I(\\alpha,\\omega,\\delta)$ 的精确闭式表达式，我们从其定义开始，利用积分的线性和已知的拉普拉斯变换形式。尽管第2部分中的预处理对于数值稳定性至关重要，但获得最终解析形式的最直接途径是对 $I_1$ 和 $I_2$ 的精确表达式进行解析减法。\n正如在第1部分中确定的：\n$$\nI(\\alpha,\\omega,\\delta) = I_1 - I_2 = \\frac{\\alpha}{\\alpha^2 + \\omega^2} - \\frac{\\alpha}{\\alpha^2 + (\\omega+\\delta)^2}\n$$\n这个表达式是精确的，但在数值上是不稳定的。我们通过将两个分数通分来继续：\n$$\nI(\\alpha,\\omega,\\delta) = \\alpha \\left[ \\frac{1}{\\alpha^2 + \\omega^2} - \\frac{1}{\\alpha^2 + (\\omega+\\delta)^2} \\right]\n$$\n$$\nI(\\alpha,\\omega,\\delta) = \\alpha \\left[ \\frac{(\\alpha^2 + (\\omega+\\delta)^2) - (\\alpha^2 + \\omega^2)}{(\\alpha^2 + \\omega^2)(\\alpha^2 + (\\omega+\\delta)^2)} \\right]\n$$\n现在，我们通过展开 $(\\omega+\\delta)^2$ 项来简化分子：\n$$\n(\\alpha^2 + (\\omega+\\delta)^2) - (\\alpha^2 + \\omega^2) = \\alpha^2 + (\\omega^2 + 2\\omega\\delta + \\delta^2) - \\alpha^2 - \\omega^2\n$$\n$\\alpha^2$ 和 $\\omega^2$ 项相互抵消，剩下：\n$$\n2\\omega\\delta + \\delta^2 = \\delta(2\\omega + \\delta)\n$$\n将这个简化的分子代回到 $I(\\alpha,\\omega,\\delta)$ 的表达式中，我们得到最终的闭式结果：\n$$\nI(\\alpha,\\omega,\\delta) = \\frac{\\alpha \\delta (2\\omega + \\delta)}{(\\alpha^2 + \\omega^2)(\\alpha^2 + (\\omega+\\delta)^2)}\n$$\n这个表达式在代数上等价于最初的两个项之差，但对于所有有效的参数值，包括小 $\\delta$ 在内，都是数值稳定的，因为它不涉及几乎相等的量相减。当 $\\delta \\to 0$ 时，分子趋近于0，整个表达式正确且平滑地趋于0。",
            "answer": "$$\n\\boxed{\\frac{\\alpha\\delta(2\\omega+\\delta)}{(\\alpha^2+\\omega^2)(\\alpha^2+(\\omega+\\delta)^2)}}\n$$"
        }
    ]
}