{
    "hands_on_practices": [
        {
            "introduction": "卷积定理为时域卷积和频域乘法之间架起了一座优雅的桥梁。然而，在计算实践中，我们处理的是离散的、有限长度的信号。第一个练习  将引导你完成一个数值实验，以验证这一定理在离散信号上的等效性，并且更重要的是，研究采样过程的关键后果，即混叠误差。你将探索违反奈奎斯特采样准则会如何破坏计算结果，这对任何计算科学家来说都是至关重要的一课。",
            "id": "3616254",
            "problem": "设计并实现一个数值实验，用于评估直接时域线性卷积与通过快速傅里叶变换 (FFT) 实现的频域卷积在一个海洋震源去鬼波算子上的等效性，并量化当对震源子波的采样违反奈奎斯特准则时引入的混叠误差。所研究的系统是一个线性时不变算子，其脉冲响应为 $g(t)$，作用于震源子波 $s(t)$ 上产生数据道 $d(t)$，其中 $d(t)$ 等于 $g(t)$ 和 $s(t)$ 的线性卷积。该实验必须纯粹用数学术语构建如下。\n\n1. 将海洋震源鬼波算子定义为一个双抽头脉冲响应 $g(t) = \\delta(t) - \\alpha \\,\\delta(t - \\tau)$，其中 $\\delta(t)$ 表示狄拉克δ函数，$\\alpha \\in (0,1]$ 是一个反射系数，$\\tau$ 是自由表面鬼波延迟。使用 $\\alpha = 0.98$（无量纲），$\\tau = 2 z / c$，其中震源深度 $z = 6\\,\\mathrm{m}$，水中声速 $c = 1500\\,\\mathrm{m/s}$。所有时间必须以秒为单位表示。\n\n2. 将震源子波 $s(t)$ 定义为两个中心频率分别为 $f_{0}$ 和 $f_{1}$ 的 Ricker 子波之和：\n$$\ns(t) = w(t; f_{0}) + 0.5\\, w(t; f_{1}) ,\n$$\n其中 Ricker 子波由下式给出：\n$$\nw(t; f) = \\left(1 - 2 \\pi^{2} f^{2} t^{2}\\right)\\exp\\left(-\\pi^{2} f^{2} t^{2}\\right).\n$$\n频率单位为 $\\mathrm{Hz}$，时间单位为 $\\mathrm{s}$，振幅无量纲。\n\n3. 为离散时间实验，在对称区间 $[-T/2, T/2]$ 上构建一个步长为 $\\Delta t$ 的均匀时间网格，并构建一个步长为 $\\Delta t_{\\mathrm{ref}}$ 的精细参考网格，使得 $\\Delta t_{\\mathrm{ref}}$ 能被 $\\Delta t$ 整除。使用 $T = 1.0\\,\\mathrm{s}$ 和 $\\Delta t_{\\mathrm{ref}} = 0.0005\\,\\mathrm{s}$。相应采样的 $g(t)$ 和 $s(t)$ 在精细网格上的离散卷积将作为连续时间卷积的参考近似。通过整数因子 $M = \\Delta t / \\Delta t_{\\mathrm{ref}}$ 对精细网格卷积进行降采样，以获得粗糙网格上的参考。\n\n4. 在粗糙网格上实现两种计算离散线性卷积的方法：\n   - 直接时域卷积：使用在粗糙网格上采样的序列的线性卷积定义。\n   - 通过快速傅里叶变换 (FFT) 的频域卷积：通过将每个输入序列补零至长度 $L \\geq N+M-1$（其中 $N$ 和 $M$ 是两个离散序列的长度）来实现线性卷积，然后将离散傅里叶变换 (DFT) 的结果逐元素相乘，再应用逆 DFT，最后截断为前 $N+M-1$ 个样本。\n\n5. 定义两种定量误差度量：\n   - 卷积方法一致性误差：\n     $$\n     \\varepsilon_{\\mathrm{method}} = \\frac{\\lVert d_{\\mathrm{time}} - d_{\\mathrm{fft}} \\rVert_{2}}{\\lVert d_{\\mathrm{time}} \\rVert_{2}} ,\n     $$\n     其中 $d_{\\mathrm{time}}$ 和 $d_{\\mathrm{fft}}$ 分别是直接法和基于 FFT 法的线性卷积结果。\n   - 相对于降采样精细网格参考的混叠误差：\n     $$\n     \\varepsilon_{\\mathrm{alias}} = \\frac{\\lVert d_{\\mathrm{time}} - d_{\\mathrm{ref}\\downarrow} \\rVert_{2}}{\\lVert d_{\\mathrm{ref}\\downarrow} \\rVert_{2}} ,\n     $$\n     其中 $d_{\\mathrm{ref}\\downarrow}$ 是降采样的精细网格参考。两种误差均为无量纲，且必须以小数形式报告，而非百分比。\n\n6. 使用以下参数值测试套件来探究典型情况和混叠边界情况。对于每种情况，指定 $(\\Delta t, f_{0}, f_{1})$：\n   - 情况 $1$（理想情况，远低于奈奎斯特频率）：$(\\Delta t = 0.002\\,\\mathrm{s}, f_{0} = 20\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$。\n   - 情况 $2$（边界情况，高频分量接近奈奎斯特频率）：$(\\Delta t = 0.004\\,\\mathrm{s}, f_{0} = 30\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$。\n   - 情况 $3$（混叠情况，高频分量违反奈奎斯特准则）：$(\\Delta t = 0.008\\,\\mathrm{s}, f_{0} = 30\\,\\mathrm{Hz}, f_{1} = 120\\,\\mathrm{Hz})$。\n\n7. 对于每个测试用例，计算并返回两个度量 $\\varepsilon_{\\mathrm{method}}$ 和 $\\varepsilon_{\\mathrm{alias}}$。您的程序应生成单行输出，其中包含所有六个结果，以逗号分隔列表的形式包含在方括号中，顺序如下：\n$$\n[\\varepsilon_{\\mathrm{method},1}, \\varepsilon_{\\mathrm{alias},1}, \\varepsilon_{\\mathrm{method},2}, \\varepsilon_{\\mathrm{alias},2}, \\varepsilon_{\\mathrm{method},3}, \\varepsilon_{\\mathrm{alias},3}] .\n$$\n\n确保所有计算中时间使用秒，频率使用赫兹。所有最终答案必须是无量纲的小数。输出必须是完全可复现的，并且不需要用户输入。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理的、适定的、客观且完整的。所有的参数和定义都足以构建一个唯一且有意义的数值实验。该场景是将数字信号处理原理应用于一个简化但现实的地球物理问题的标准应用。指定的任务直接测试了时域和频域卷积的等效性，以及由奈奎斯特-香农采样定理决定的混叠效应。\n\n解决方案根据问题的具体要求，通过实现一个数值模拟来进行。实验的核心是计算一个地球物理数据道 $d(t)$，它是震源子波 $s(t)$ 与海洋鬼波算子 $g(t)$ 线性卷积的结果。其关系为 $d(t) = (g*s)(t)$。\n\n首先，我们定义参数和连续时间函数。模拟海面反射的海洋鬼波算子由脉冲响应 $g(t) = \\delta(t) - \\alpha \\,\\delta(t - \\tau)$ 给出。反射系数为 $\\alpha = 0.98$。鬼波延迟 $\\tau$ 由震源深度 $z=6\\,\\mathrm{m}$ 和水中声速 $c=1500\\,\\mathrm{m/s}$ 决定，得出 $\\tau = 2z/c = 2 \\times 6 / 1500 = 0.008\\,\\mathrm{s}$。震源子波 $s(t)$ 是一个由两个 Ricker 子波之和构成的复合信号：$s(t) = w(t; f_{0}) + 0.5\\, w(t; f_{1})$，其中 Ricker 子波定义为 $w(t; f) = \\left(1 - 2 \\pi^{2} f^{2} t^{2}\\right)\\exp\\left(-\\pi^{2} f^{2} t^{2}\\right)$。\n\n数值实验在离散时间网格上进行。在时间区间 $[-T/2, T/2]$ 上建立一个精细参考网格，其中 $T=1.0\\,\\mathrm{s}$，时间步长为 $\\Delta t_{\\mathrm{ref}} = 0.0005\\,\\mathrm{s}$。该网格有 $N_{\\mathrm{ref}} = T/\\Delta t_{\\mathrm{ref}} + 1 = 2001$ 个点。对于每个测试用例，定义一个相应的时间步长为 $\\Delta t$ 的粗糙网格，产生 $N_{\\mathrm{coarse}} = T/\\Delta t + 1$ 个点。连续函数 $s(t)$ 和 $g(t)$ 在这些网格上被采样，以产生离散序列 $s_{\\mathrm{ref}}$、$g_{\\mathrm{ref}}$、$s_{\\mathrm{coarse}}$ 和 $g_{\\mathrm{coarse}}$。狄拉克δ函数 $\\delta(t-t_0)$ 在数值上表示为一个克罗内克δ函数：一个在对应于时间 $t_0$ 的采样索引处值为 $1$、其他地方为 $0$ 的序列。由于鬼波延迟 $\\tau=0.008\\,\\mathrm{s}$ 是 $\\Delta t_{\\mathrm{ref}}$ 和所有粗糙网格 $\\Delta t$ 值的整数倍，克罗内克δ函数正好落在一个网格点上，这简化了离散化过程。\n\n实验需要通过三种方式计算离散线性卷积：\n\n1.  **参考卷积, $d_{\\mathrm{ref}\\downarrow}$**：通过对精细采样的序列 $s_{\\mathrm{ref}}$ 和 $g_{\\mathrm{ref}}$ 执行完全线性卷积，计算出高保真参考信号 $d_{\\mathrm{ref}}$。结果是一个长度为 $2N_{\\mathrm{ref}}-1$ 的序列。然后通过取每 $M$ 个样本的方式，以整数因子 $M = \\Delta t / \\Delta t_{\\mathrm{ref}}$ 对其进行降采样。这样就得到了降采样的参考 $d_{\\mathrm{ref}\\downarrow}$，其长度为 $2N_{\\mathrm{coarse}}-1$，可以直接与粗糙网格的结果进行比较。\n\n2.  **直接时域卷积, $d_{\\mathrm{time}}$**：这是通过在粗糙网格序列上直接应用线性卷积和来计算的，$d_{\\mathrm{time}} = \\mathrm{convolve}(s_{\\mathrm{coarse}}, g_{\\mathrm{coarse}})$。此操作使用 `numpy.convolve` 并设置 `mode='full'` 来执行，结果是一个长度为 $2N_{\\mathrm{coarse}}-1$ 的序列。\n\n3.  **频域卷积, $d_{\\mathrm{fft}}$**：卷积定理指出，时域中的卷积等效于频域中的乘法。这是通过将 $s_{\\mathrm{coarse}}$ 和 $g_{\\mathrm{coarse}}$ 补零至完全卷积的长度（$2N_{\\mathrm{coarse}}-1$），通过快速傅里叶变换 (FFT) 算法计算它们的离散傅里叶变换 (DFT)，将所得频谱逐元素相乘，最后应用逆 FFT 得到 $d_{\\mathrm{fft}}$ 来实现的。理论上，此过程产生的结果与 $d_{\\mathrm{time}}$ 相同。\n\n最后，为每个测试用例计算两个误差度量。\n卷积方法一致性误差 $\\varepsilon_{\\mathrm{method}} = \\lVert d_{\\mathrm{time}} - d_{\\mathrm{fft}} \\rVert_{2} / \\lVert d_{\\mathrm{time}} \\rVert_{2}$，量化了直接卷积法和基于 FFT 的卷积法之间的数值差异。由于 DFT 的性质，这个误差预计会接近机器精度。\n混叠误差 $\\varepsilon_{\\mathrm{alias}} = \\lVert d_{\\mathrm{time}} - d_{\\mathrm{ref}\\downarrow} \\rVert_{2} / \\lVert d_{\\mathrm{ref}\\downarrow} \\rVert_{2}$，衡量了以可能不足的速率 $\\Delta t$ 采样连续信号 $s(t)$ 所引入的误差。根据奈奎斯特准则，信号的采样率必须大于其最高频率分量的两倍才能避免混叠。\n- 对于情况 1（$\\Delta t = 0.002\\,\\mathrm{s}$），奈奎斯特频率为 $f_{\\mathrm{Nyq}} = 250\\,\\mathrm{Hz}$，远高于 $s(t)$ 中的显著频率，因此 $\\varepsilon_{\\mathrm{alias}}$ 应该很小。\n- 对于情况 2（$\\Delta t = 0.004\\,\\mathrm{s}$），$f_{\\mathrm{Nyq}} = 125\\,\\mathrm{Hz}$，非常接近较高的频率分量 $f_1=120\\,\\mathrm{Hz}$，因此预计会产生一些混叠。\n- 对于情况 3（$\\Delta t = 0.008\\,\\mathrm{s}$），$f_{\\mathrm{Nyq}} = 62.5\\,\\mathrm{Hz}$，远低于 $f_1=120\\,\\mathrm{Hz}$，导致显著的混叠和较大的 $\\varepsilon_{\\mathrm{alias}}$。\n\n代码为三个指定的测试用例中的每一个都实现了此过程，并将六个得到的误差度量格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to evaluate convolution methods\n    and quantify aliasing errors for a marine source deghosting problem.\n    \"\"\"\n    # Define physical and simulation constants\n    ALPHA = 0.98  # Reflection coefficient\n    Z = 6.0       # Source depth in meters\n    C = 1500.0    # Water sound speed in m/s\n    T = 1.0       # Total time duration in seconds\n    DT_REF = 0.0005 # Time step for fine reference grid in seconds\n\n    # Define the test suite of parameters (dt, f0, f1)\n    test_cases = [\n        (0.002, 20.0, 120.0),  # Case 1: Well-sampled\n        (0.004, 30.0, 120.0),  # Case 2: Near Nyquist boundary\n        (0.008, 30.0, 120.0),  # Case 3: Aliased\n    ]\n\n    # Calculate the free-surface ghost delay\n    tau = 2 * Z / C\n\n    def ricker_wavelet(t, f):\n        \"\"\"Computes a Ricker wavelet for a given time array and central frequency.\"\"\"\n        pi2_f2_t2 = (np.pi * f * t)**2\n        return (1.0 - 2.0 * pi2_f2_t2) * np.exp(-pi2_f2_t2)\n\n    def source_signature(t, f0, f1):\n        \"\"\"Computes the composite source signature.\"\"\"\n        return ricker_wavelet(t, f0) + 0.5 * ricker_wavelet(t, f1)\n\n    results = []\n    \n    # Process each test case\n    for dt, f0, f1 in test_cases:\n        # 1. Construct Time Grids\n        # Fine reference grid\n        n_ref = int(T / DT_REF) + 1\n        t_ref = np.linspace(-T / 2, T / 2, n_ref)\n\n        # Coarse grid for the current test case\n        n_coarse = int(T / dt) + 1\n        t_coarse = np.linspace(-T / 2, T / 2, n_coarse)\n\n        # 2. Generate Discrete-Time Signals\n        # Signals on the fine reference grid\n        s_ref = source_signature(t_ref, f0, f1)\n        g_ref = np.zeros(n_ref)\n        idx_0_ref = n_ref // 2\n        idx_tau_ref = idx_0_ref + int(round(tau / DT_REF))\n        g_ref[idx_0_ref] = 1.0\n        g_ref[idx_tau_ref] = -ALPHA\n\n        # Signals on the coarse grid\n        s_coarse = source_signature(t_coarse, f0, f1)\n        g_coarse = np.zeros(n_coarse)\n        idx_0_coarse = n_coarse // 2\n        idx_tau_coarse = idx_0_coarse + int(round(tau / dt))\n        g_coarse[idx_0_coarse] = 1.0\n        g_coarse[idx_tau_coarse] = -ALPHA\n        \n        # 3. Compute Convolutions\n        # High-fidelity reference convolution on the fine grid\n        d_ref_full = fftconvolve(s_ref, g_ref, mode='full')\n        \n        # Downsample the reference to match the coarse grid convolution length\n        M = int(dt / DT_REF)\n        d_ref_down = d_ref_full[::M]\n        \n        # Method 1: Direct time-domain convolution on the coarse grid\n        d_time = np.convolve(s_coarse, g_coarse, mode='full')\n        \n        # Method 2: Frequency-domain convolution via FFT on the coarse grid\n        d_fft = fftconvolve(s_coarse, g_coarse, mode='full')\n\n        # Ensure lengths are consistent for comparison\n        expected_len = 2 * n_coarse - 1\n        if len(d_ref_down) != expected_len:\n            # Truncate if there's a minor length mismatch from slicing\n            d_ref_down = d_ref_down[:expected_len]\n\n        # 4. Calculate Error Metrics\n        # Convolution-method consistency error\n        norm_d_time = np.linalg.norm(d_time)\n        if norm_d_time > 0:\n            eps_method = np.linalg.norm(d_time - d_fft) / norm_d_time\n        else:\n            eps_method = 0.0\n\n        # Aliasing error relative to the downsampled reference\n        norm_d_ref_down = np.linalg.norm(d_ref_down)\n        if norm_d_ref_down > 0:\n            eps_alias = np.linalg.norm(d_time - d_ref_down) / norm_d_ref_down\n        else:\n            eps_alias = 0.0 if np.linalg.norm(d_time) == 0 else 1.0\n\n        results.extend([eps_method, eps_alias])\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然使用快速傅里叶变换（FFT）执行卷积在计算上非常高效，但它也带来一个重要的警示：离散傅里叶变换（DFT）隐含地假设信号是周期性的。如果处理不当，这会导致“循环卷积”伪影。本练习  旨在让你直面这些回卷误差，对其进行量化，然后实现用于获得真实线性卷积的标准技术，包括零填充和用于处理长数据流的重叠相加法。",
            "id": "3616259",
            "problem": "考虑一个离散时间、有限长度的地震道，其模型为一个实值序列 $x[n]$，$0 \\le n \\le N-1$；以及一个实值的有限冲激响应 $h[n]$，$0 \\le n \\le M-1$。一个线性时不变系统由离散时间线性卷积定义，它产生长度为 $L = N + M - 1$ 的真实输出 $y_{\\text{true}}[n]$，计算公式为 $y_{\\text{true}}[n] = \\sum_{k=0}^{N-1} x[k] h[n-k]$，适用于所有整数 $n$，并隐式地在其支撑集之外进行零扩展。对于一个长度为 $K$ 的序列 $s[n]$，$0 \\le n \\le K-1$，其离散傅里叶变换 (DFT) 定义为 $S[k] = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$，$0 \\le k \\le K-1$；其逆离散傅里叶变换 (IDFT) 定义为 $s[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$。在计算地球物理学中，频域方法通过将变换相乘然后进行逆变换来计算系统输出。然而，DFT 表示的是周期为 $K$ 的周期性序列，因此等长 DFT 的频域相乘在时域中实现的是周期为 $K$ 的循环卷积。对于有限长度的地震道，除非使用零填充或分块处理策略，否则这会引入卷绕失真。\n\n你的任务是：\n- 根据给定的定义，推导长度为 $K$ 的循环卷积与长度为 $K$ 的 DFT 频域相乘之间的精确关系，并解释为什么使用等长 DFT 计算输出时假定了序列的周期性扩展。\n- 设计一个算法流程，用同一对 $(x[n], h[n])$ 计算三种输出：\n  1. 一个长度为 $N$ 的朴素循环卷积输出 $y_{\\text{circ}}[n]$，通过等长 DFT 相乘和 IDFT 计算。\n  2. 一个长度为 $L = N + M - 1$ 的零填充频域输出 $y_{\\text{zp}}[n]$，通过将 $x[n]$ 和 $h[n]$ 都填充到长度 $L$，将其 DFT 相乘，然后应用 IDFT 来计算。\n  3. 一个长度为 $L = N + M - 1$ 的重叠相加输出 $y_{\\text{ola}}[n]$，通过将 $x[n]$ 分割成大小为 $B$ 的数据块，对每个块进行足够的零填充以防止混叠，乘以 $h[n]$ 的零填充变换，然后将重叠的部分结果相加来计算。选择频域长度 $K_{\\text{ola}}$ 使得 $K_{\\text{ola}} \\ge B + M - 1$，并且为了效率，取 $K_{\\text{ola}}$ 为满足此边界的最小 2 的幂。\n- 量化循环卷积与真实线性卷积相比所引入的卷绕失真。定义失真误差向量为 $e_{\\text{circ}}[n] = y_{\\text{circ}}[n] - y_{\\text{true}}[n]$，$0 \\le n \\le N-1$。计算相对失真能量比 $R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$。此外，通过计算宽度为 $M-1$ 的前缘中的失真能量分数来量化卷绕的集中程度：$F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$，并约定如果分母为零，则 $F_{\\text{edge}} = 0$。\n- 通过计算 $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{zp}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ 和 $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} \\left(y_{\\text{ola}}[n] - y_{\\text{true}}[n]\\right)^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ 来量化零填充和重叠相加输出相对于真实线性卷积的准确性。\n- 在一个程序中实现所有计算，该程序为一组测试用例构建测试输入并计算指定的指标。\n\n按如下方式为每个测试用例构建 $x[n]$ 和 $h[n]$：\n- 通过在 $0 \\le n \\le N-1$ 的随机位置上放置 $K_{\\text{spk}}$ 个脉冲来创建一个稀疏反射率 $x[n]$，脉冲的振幅从 $[-1, 1]$ 均匀抽取，其他位置为零。通过特定于用例的种子来固定随机性以确保可复现性。\n- 创建一个长度为 $M$ 的子波冲激响应 $h[n]$，它是一个具有单位能量的离散雷克子波，由无量纲的峰值参数 $f_0$ 参数化。令 $t[n] = n - \\frac{M-1}{2}$，并定义 $h[n] = \\left(1 - 2 (\\pi f_0 t[n])^2 \\right) \\exp\\left( - (\\pi f_0 t[n])^2 \\right)$，并将其归一化以使 $\\sum_{n=0}^{M-1} h[n]^2 = 1$。\n\n使用以下测试套件，其中每个元组指定 $(N, M, f_0, K_{\\text{spk}}, \\text{seed}, B)$：\n- 用例 1：$(256, 51, 0.12, 12, 1, 64)$。\n- 用例 2：$(128, 65, 0.20, 8, 2, 32)$。\n- 用例 3：$(64, 63, 0.25, 6, 3, 16)$。\n- 用例 4：$(300, 41, 0.15, 15, 4, 100)$。\n\n对于每个用例，计算并返回列表 $[R_{\\text{circ}}, F_{\\text{edge}}, R_{\\text{zp}}, R_{\\text{ola}}]$，其中所有量均如上定义。你的程序应生成一行输出，其中包含结果，格式为由方括号括起来的、按用例排列的列表的逗号分隔列表，格式为 $[[r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}], [r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}], [r_{4,1}, r_{4,2}, r_{4,3}, r_{4,4}]]$. 此问题中没有物理单位，也没有出现角度；因此不需要单位转换。所有输出必须是实值浮点数。",
            "solution": "当前问题要求对基于离散傅里叶变换 (DFT) 的不同离散卷积方法进行严格比较。DFT 是地球物理学等领域中计算信号处理的基石。我们必须推导其理论基础，为几种卷积变体设计算法，并量化它们的性能和失真。\n\n### 1. 理论基础：卷积定理及其推论\n\n时域卷积和频域相乘之间的关系由卷积定理支配。我们首先为 DFT 建立这种关系，并阐明其对有限长度信号的后果。\n\n设 $x[n]$ 和 $h[n]$ 分别是长度为 $N$ 和 $M$ 的两个有限长度序列。模拟线性时不变 (LTI) 系统输出的线性卷积定义为：\n$$y_{\\text{true}}[n] = (x * h)[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]$$\n鉴于 $x[n]$ 仅在 $0 \\le n \\le N-1$ 时非零，而 $h[n]$ 仅在 $0 \\le n \\le M-1$ 时非零，所得序列 $y_{\\text{true}}[n]$ 仅在 $0 \\le n \\le N+M-2$ 时非零。因此，其总长度为 $L = N+M-1$。\n\n对于一个长度为 $K$ 的序列 $s[n]$，DFT 及其逆变换 (IDFT) 定义如下：\n$$S[k] = \\text{DFT}_K\\{s[n]\\} = \\sum_{n=0}^{K-1} s[n] e^{-i 2 \\pi k n / K}$$\n$$s[n] = \\text{IDFT}_K\\{S[k]\\} = \\frac{1}{K} \\sum_{k=0}^{K-1} S[k] e^{i 2 \\pi k n / K}$$\nDFT 的一个关键特性是，它隐式地将任何长度为 $K$ 的有限输入序列视为周期为 $K$ 的无限周期序列的一个周期。这是因为基函数 $e^{i 2 \\pi k n / K}$ 本身在 $n$ 上是周期性的，周期为 $K$。\n\n让我们推导与频域相乘对应的时域操作。设 $y[n] = \\text{IDFT}_K\\{X[k]H[k]\\}$，其中 $X[k]=\\text{DFT}_K\\{x[n]\\}$ 且 $H[k]=\\text{DFT}_K\\{h[n]\\}$（假设两个序列首先被填充或截断至长度 $K$）。\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k]H[k] e^{i 2 \\pi k n / K}$$\n代入 $H[k]$ 的定义：\n$$y[n] = \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] \\left( \\sum_{m=0}^{K-1} h[m] e^{-i 2 \\pi k m / K} \\right) e^{i 2 \\pi k n / K}$$\n重新排列各项：\n$$y[n] = \\sum_{m=0}^{K-1} h[m] \\left( \\frac{1}{K} \\sum_{k=0}^{K-1} X[k] e^{i 2 \\pi k (n-m) / K} \\right)$$\n括号中的项是在时间 $(n-m)$ 处求值的 $\\text{IDFT}_K\\{X[k]\\}$ 的定义。这正是 $x[n-m]$。然而，由于 DFT 的周期性，该索引被隐式地对 $K$ 取模。因此：\n$$y[n] = \\sum_{m=0}^{K-1} h[m] x[(n-m) \\pmod K]$$\n这是长度为 $K$ 的**循环卷积**的定义。因此，将两个序列的 DFT 相乘等同于在时域中执行循环卷积，而非线性卷积。\n\n要使用 DFT 计算线性卷积，我们必须防止循环卷积的“卷绕”效应。线性卷积的结果长度为 $L = N+M-1$。如果我们选择一个 DFT 长度 $K \\ge L$，循环卷积的结果将有足够的空间而不会发生卷绕。$K$ 点循环卷积的结果将在前 $L$ 个点上与线性卷积的结果相同，后面跟着 $K-L$ 个零。\n\n### 2. 算法设计与分析\n\n基于上述理论，我们设计所需的计算流程。\n\n**1. 真实线性卷积 ($y_{\\text{true}}[n]$)**\n这是基准真值，直接在时域中使用线性卷积的定义计算。这可以通过直接求和或标准库函数（例如 `numpy.convolve`）实现。输出长度为 $L = N+M-1$。\n\n**2. 朴素循环卷积 ($y_{\\text{circ}}[n]$)**\n此流程演示了卷绕失真。长度指定为 $N$。\n- 将冲激响应 $h[n]$ 用零填充以匹配输入信号的长度 $N$。记为 $h_N[n]$。\n- 计算长度为 $N$ 的 DFT：$X[k] = \\text{DFT}_N\\{x[n]\\}$ 和 $H_N[k] = \\text{DFT}_N\\{h_N[n]\\}$。\n- 将变换相乘：$Y_{\\text{circ}}[k] = X[k] \\cdot H_N[k]$。\n- 计算逆变换：$y_{\\text{circ}}[n] = \\text{IDFT}_N\\{Y_{\\text{circ}}[k]\\}$。\n结果是一个长度为 $N$ 的序列。线性卷积中超出索引 $N-1$ 的部分（“尾部”）会卷绕并加到序列的开头。对于 $0 \\le n \\le M-2$，有 $y_{\\text{circ}}[n] = y_{\\text{true}}[n] + y_{\\text{true}}[n+N]$，这是此范围内失真 $e_{\\text{circ}}[n]$ 的来源。\n\n**3. 零填充频域卷积 ($y_{\\text{zp}}[n]$)**\n这是通过 FFT 计算线性卷积的标准且正确的方法。\n- 确定所需的输出长度：$L = N+M-1$。\n- 将 $x[n]$ 和 $h[n]$ 都用零填充至长度 $L$。记为 $x_L[n]$ 和 $h_L[n]$。\n- 计算长度为 $L$ 的 DFT：$X_L[k] = \\text{DFT}_L\\{x_L[n]\\}$ 和 $H_L[k] = \\text{DFT}_L\\{h_L[n]\\}$。\n- 将变换相乘并求逆：$y_{\\text{zp}}[n] = \\text{IDFT}_L\\{X_L[k] \\cdot H_L[k]\\}$。\n所得序列 $y_{\\text{zp}}[n]$ 的长度为 $L$，并且在忽略浮点误差的情况下，将与 $y_{\\text{true}}[n]$ 完全相同。\n\n**4. 重叠相加分块卷积 ($y_{\\text{ola}}[n]$)**\n这是一种将长信号 $x[n]$ 与较短滤波器 $h[n]$ 进行卷积的高效方法。\n- 将输入信号 $x[n]$ 分割成大小为 $B$ 的不重叠块。\n- 确定计算数据块与 $h[n]$ 的线性卷积所需的 FFT 大小 $K_{\\text{ola}}$，以避免混叠。我们需要 $K_{\\text{ola}} \\ge B+M-1$。为了效率，选择 $K_{\\text{ola}}$ 为满足此条件的最小 2 的幂。\n- 预先计算滤波器的零填充、长度为 $K_{\\text{ola}}$ 的 DFT：将 $h[n]$ 填充到长度 $K_{\\text{ola}}$ 并变换为 $H_{\\text{ola}}[k]$。\n- 初始化一个长度为 $L = N+M-1$ 的全零输出缓冲区 $y_{\\text{ola}}[n]$。\n- 对于 $x[n]$ 的每个块 $x_i[n]$（从时间索引 $i \\cdot B$ 开始）：\n    - 将块 $x_i[n]$ 填充到长度 $K_{\\text{ola}}$。\n    - 计算其 DFT $X_i[k]$，并与存储的 $H_{\\text{ola}}[k]$ 相乘以得到 $Y_i[k]$。\n    - 计算逆 DFT，$y_i[n] = \\text{IDFT}_{K_{\\text{ola}}}\\{Y_i[k]\\}$。这是该块的线性卷积。\n    - 将此结果 $y_i[n]$ 在正确起始位置 $i \\cdot B$ 处加到主输出缓冲区 $y_{\\text{ola}}[n]$ 中。连续块的结果将重叠 $M-1$ 个样本并相加。\n与 $y_{\\text{zp}}[n]$ 类似，最终结果 $y_{\\text{ola}}[n]$ 在数值精度范围内应与 $y_{\\text{true}}[n]$ 完全相同。\n\n### 3. 失真与准确性的量化\n\n该问题需要一组指标来量化这些方法之间的差异。\n- **相对循环失真能量 ($R_{\\text{circ}}$)**：$R_{\\text{circ}} = \\frac{\\sum_{n=0}^{N-1} (y_{\\text{circ}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{N-1} y_{\\text{true}}[n]^2}$。此指标测量由循环卷绕引入的误差能量，相对于同一区间内真实信号的能量。\n- **前缘误差分数 ($F_{\\text{edge}}$)**：$F_{\\text{edge}} = \\frac{\\sum_{n=0}^{M-2} e_{\\text{circ}}[n]^2}{\\sum_{n=0}^{N-1} e_{\\text{circ}}[n]^2}$。此指标量化了总卷绕误差能量中有多少集中在输出的前 $M-1$ 个样本中，该区域直接受到尾部卷绕的影响。\n- **填充/重叠相加方法的相对准确性 ($R_{\\text{zp}}, R_{\\text{ola}}$)**：\n  $R_{\\text{zp}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{zp}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$ 和 $R_{\\text{ola}} = \\frac{\\sum_{n=0}^{L-1} (y_{\\text{ola}}[n] - y_{\\text{true}}[n])^2}{\\sum_{n=0}^{L-1} y_{\\text{true}}[n]^2}$。这些指标测量零填充和重叠相加方法与真实线性卷积相比的相对均方误差。由于这些方法在理论上是精确的，这些值应该非常小，在机器精度的数量级上，仅反映浮点运算的不精确性。\n\n实现部分将构建指定的输入信号，并为每个测试用例计算这四个指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef compute_metrics_for_case(case_params):\n    \"\"\"\n    Computes all required convolution variants and error metrics for a single test case.\n    \"\"\"\n    N, M, f0, K_spk, seed, B = case_params\n    L = N + M - 1\n\n    # --- 1. Construct input signals x[n] and h[n] ---\n    \n    # Sparse reflectivity x[n]\n    rng = np.random.default_rng(seed)\n    spike_indices = rng.choice(N, size=K_spk, replace=False)\n    spike_amplitudes = rng.uniform(-1, 1, size=K_spk)\n    x = np.zeros(N)\n    x[spike_indices] = spike_amplitudes\n\n    # Ricker wavelet h[n]\n    t = np.arange(M) - (M - 1) / 2.0\n    term = (np.pi * f0 * t)**2\n    h = (1 - 2 * term) * np.exp(-term)\n    h /= np.linalg.norm(h) # Normalize to unit energy\n\n    # --- 2. Compute convolution outputs ---\n\n    # Method 1: True Linear Convolution (ground truth)\n    y_true = np.convolve(x, h)\n\n    # Method 2: Naive Circular Convolution\n    h_N = np.zeros(N)\n    if M > 0:\n      h_N[:M] = h\n    Y_circ_k = fft(x) * fft(h_N)\n    y_circ = ifft(Y_circ_k).real\n\n    # Method 3: Zero-Padded Frequency-Domain Convolution\n    x_L = np.zeros(L)\n    x_L[:N] = x\n    h_L = np.zeros(L)\n    h_L[:M] = h\n    Y_zp_k = fft(x_L) * fft(h_L)\n    y_zp = ifft(Y_zp_k).real\n    \n    # Method 4: Overlap-Add Block Convolution\n    L_block = B + M - 1\n    # Smallest power of 2 >= L_block\n    K_ola = 1  (L_block - 1).bit_length() if L_block > 0 else 1\n    \n    h_ola = np.zeros(K_ola)\n    h_ola[:M] = h\n    H_ola_k = fft(h_ola)\n    \n    y_ola = np.zeros(L)\n    num_blocks = int(np.ceil(N / B))\n\n    for i in range(num_blocks):\n        start = i * B\n        end = min((i + 1) * B, N)\n        x_block = x[start:end]\n        \n        x_block_padded = np.zeros(K_ola)\n        x_block_padded[:len(x_block)] = x_block\n        \n        Y_block_k = fft(x_block_padded) * H_ola_k\n        y_block = ifft(Y_block_k).real\n        \n        add_len = min(K_ola, L - start)\n        y_ola[start : start + add_len] += y_block[:add_len]\n\n    # --- 3. Quantify artifacts and accuracy ---\n\n    # R_circ and F_edge\n    y_true_N = y_true[:N]\n    e_circ = y_circ - y_true_N\n    \n    den_y_true_N_sq = np.sum(y_true_N**2)\n    R_circ = np.sum(e_circ**2) / den_y_true_N_sq if den_y_true_N_sq > 0 else 0.0\n\n    err_e_circ_sq = np.sum(e_circ**2)\n    F_edge = np.sum(e_circ[:M-1]**2) / err_e_circ_sq if err_e_circ_sq > 0 else 0.0\n\n    # R_zp and R_ola\n    den_y_true_sq = np.sum(y_true**2)\n    \n    e_zp = y_zp - y_true\n    R_zp = np.sum(e_zp**2) / den_y_true_sq if den_y_true_sq > 0 else 0.0\n    \n    e_ola = y_ola - y_true\n    R_ola = np.sum(e_ola**2) / den_y_true_sq if den_y_true_sq > 0 else 0.0\n    \n    return [R_circ, F_edge, R_zp, R_ola]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, M, f0, K_spk, seed, B)\n        (256, 51, 0.12, 12, 1, 64),\n        (128, 65, 0.20, 8, 2, 32),\n        (64, 63, 0.25, 6, 3, 16),\n        (300, 41, 0.15, 15, 4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # Format the final output string\n    # str(list) automatically adds brackets, so map(str, results) and then join\n    # gives the desired \"[[...],[...]]\" structure.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了简单地应用一个已知滤波器，卷积定理及其相关原理还使我们能够从基本原理出发设计滤波器。这个高级练习  深入探讨了谱分解这一复杂技术。你将学习如何仅从期望的振幅谱出发，通过利用倒谱揭示的信号振幅与相位之间的深刻联系，构建一个因果、稳定且最小相位的子波——这是地震反褶积的基石。",
            "id": "3616247",
            "problem": "你的任务是在频域中实现谱分解，以从给定的振幅谱出发，为线性时不变 (LTI) 系统构建一个最小相位子波。你的推导和算法必须基于以下基本原理：(i) 线性系统的卷积定理，即对于一个冲激响应为 $h(t)$、输入为 $x(t)$ 的 LTI 系统，其输出 $y(t)$ 满足 $Y(\\omega)=H(\\omega)X(\\omega)$，其中 $H(\\omega)$ 是系统频率响应；(ii) 最小相位谱对数的解析性，这意味着 $\\log H(\\omega)$ 的实部和虚部构成一个希尔伯特变换对；以及 (iii) 同态信号处理框架，其中实倒谱是振幅谱对数的傅里叶逆变换。\n\n目标是执行谱分解，从一个给定的非负振幅谱 $\\lvert H(\\omega)\\rvert$ 中恢复出最小相位复数谱 $H(\\omega)$，然后通过逆变换重建时域子波 $h(t)$。\n\n你必须在离散时间下工作，处理 $N$ 个样本，索引为 $n\\in\\{0,1,\\dots,N-1\\}$。令 $h[n]$ 表示离散时间子波样本，令 $H[k]$ 表示在 $N$ 点离散傅里叶变换 (DFT) 网格上的离散谱，其角频率为 $\\omega_k=2\\pi k/N$，其中 $k\\in\\{0,1,\\dots,N-1\\}$。振幅谱以数组 $A[k]=\\lvert H[k]\\rvert\\ge 0$ 的形式给出。假设目标最小相位谱 $H[k]$ 在单位圆外没有零点，并且 $A[k]$ 在频率上是偶对称的，即对于所有 $k$，有 $A[k]=A[N-k]$。\n\n你的程序必须通过倒谱法实现谱分解，并遵循最小相位系统固有的解析关系。所需步骤如下：\n\n1. 通过对 $\\log A[k]$ 应用傅里叶逆变换 (IDFT)，从振幅谱计算实倒谱 $c[n]$，即：\n$$\nc[n]=\\frac{1}{N}\\sum_{k=0}^{N-1}\\log\\!\\big(A[k]\\big)\\exp\\!\\left(i\\frac{2\\pi nk}{N}\\right).\n$$\n使用一个小的稳定常数 $\\epsilon0$，并将 $\\log A[k]$ 替换为 $\\log\\!\\big(A[k]+\\epsilon\\big)$，以避免当 $A[k]=0$ 时出现数值问题。\n\n2. 通过保留非负倒频率并加倍正倒频率来构建最小相位倒谱 $c_{\\min}[n]$，即：\n$$\nc_{\\min}[0]=c[0],\\quad c_{\\min}[n]=2c[n]\\ \\text{for}\\ n=1,2,\\dots,\\frac{N}{2}-1,\n$$\n并将所有其余样本设置为零，但对于偶数 $N$，保留 $c_{\\min}[N/2]=c[N/2]$。\n\n3. 通过对 $c_{\\min}[n]$ 应用离散傅里叶变换 (DFT) 来恢复复对数谱：\n$$\n\\log H_{\\min}[k]=\\sum_{n=0}^{N-1}c_{\\min}[n]\\exp\\!\\left(-i\\frac{2\\pi nk}{N}\\right).\n$$\n\n4. 取指数以获得最小相位谱：\n$$\nH_{\\min}[k]=\\exp\\!\\big(\\log H_{\\min}[k]\\big),\n$$\n根据构造，该谱满足 $\\lvert H_{\\min}[k]\\rvert\\approx A[k]$，同时具有最小相位。\n\n5. 通过傅里叶逆变换 (IDFT) 重建子波：\n$$\nh[n]=\\frac{1}{N}\\sum_{k=0}^{N-1}H_{\\min}[k]\\exp\\!\\left(i\\frac{2\\pi nk}{N}\\right).\n$$\n\n你必须实现上述算法，并在一个固定的测试集上对其进行评估。为确保科学真实性，每个振幅谱都被构造成频率偶对称，以保证 $h[n]$ 为实值。不需要物理单位，所有报告的量都必须是无量纲的。\n\n测试集规范：\n- 在所有情况下，使用 $N=256$ 和 $\\epsilon=10^{-8}$。\n- 情况 1 (平坦振幅)：对于所有 $k$，$A[k]=1$。\n- 情况 2 (类 Ormsby 带通振幅)：定义角频率边界 $\\omega_1=0.2\\pi, \\omega_2=0.3\\pi, \\omega_3=0.5\\pi, \\omega_4=0.7\\pi$。当 $\\omega_k\\omega_1$ 和 $\\omega_k\\omega_4$ 时，令 $A[k]$ 为 0；当 $\\omega_1\\le \\omega_k\\le \\omega_2$ 时，从 0 线性增加到 1；当 $\\omega_2\\le \\omega_k\\le \\omega_3$ 时，为 1；当 $\\omega_3\\le \\omega_k\\le \\omega_4$ 时，从 1 线性减小到 0。然后强制偶对称性 $A[k]=A[N-k]$。\n- 情况 3 (自回归振幅)：选择 $a=0.8$ 并对所有 $k$ 设置 $A[k]=\\big\\lvert 1-\\!a\\exp(-i\\omega_k)\\big\\rvert^{-1}$。\n- 情况 4 (陷波振幅)：定义一个深度陷波带，其角频率为 $\\omega_a=0.45\\pi, \\omega_b=0.55\\pi$。在陷波带外令 $A[k]=1$，在陷波带内令 $A[k]=10^{-6}$。然后强制偶对称性 $A[k]=A[N-k]$。\n\n对于每种情况，计算：\n- 布尔值 $p$，表示重建子波的最大值是否出现在样本索引 $n=0$ 处，即 $p=\\big(\\arg\\max_n h[n]=0\\big)$。\n- 目标振幅 $A[k]$ 与重建振幅 $\\lvert H_{\\min}[k]\\rvert$ 之间的平均绝对相对误差 $E$，定义为\n$$\nE=\\frac{\\frac{1}{N}\\sum_{k=0}^{N-1}\\big\\lvert\\,\\lvert H_{\\min}[k]\\rvert-A[k]\\big\\rvert}{\\frac{1}{N}\\sum_{k=0}^{N-1}A[k]}.\n$$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为\n$$\n\\big[p_1,E_1,p_2,E_2,p_3,E_3,p_4,E_4\\big],\n$$\n其中 $p_j$ 是布尔值，$E_j$ 是情况 $j\\in\\{1,2,3,4\\}$ 的浮点数。例如，输出格式必须为 $[p_1,E_1,p_2,E_2,p_3,E_3,p_4,E_4]$。",
            "solution": "该问题要求实现一种谱分解算法，从给定的振幅谱构建最小相位子波。此过程是多个领域的核心技术，包括计算地球物理学中的地震反褶积，并依赖于线性系统和同态信号处理的基本原理。\n\n### 理论基础\n\n线性时不变 (LTI) 系统由其冲激响应 $h(t)$ 或等效地由其频率响应 $H(\\omega)$（即 $h(t)$ 的傅里叶变换）来表征。如果一个系统的传递函数 $H(z)$ 及其逆 $1/H(z)$ 都是因果且稳定的，则该系统被称为**最小相位**系统。在 z 域中，这意味着 $H(z)$ 的所有极点和零点都位于单位圆内。在时域中，最小相位子波的一个关键特性是其能量最大程度地集中在信号的起始部分，从而导致其峰值振幅出现在时间 $t=0$（或离散情况下的样本 $n=0$）处。\n\n谱分解问题旨在寻找与给定功率谱 $|H(\\omega)|^2$ 或振幅谱 $A(\\omega) = |H(\\omega)|$ 相对应的最小相位谱 $H(\\omega)$。使之成为可能的核心洞见是，对于一个最小相位系统，其频率响应的复对数 $\\log H(\\omega)$ 具有特定的解析性质。由于 $H(z)$ 在单位圆上或单位圆外没有极点或零点，$\\log H(z)$ 在单位圆上及单位圆外是解析的。在单位圆（$z = e^{i\\omega}$）上进行求值，我们得到 $\\log H(\\omega) = \\log|H(\\omega)| + i \\arg H(\\omega)$。这种解析性意味着一种因果关系，表现为其实部（$\\log|H(\\omega)|$）和虚部（相位，$\\arg H(\\omega)$）构成一个希尔伯特变换对。这意味着相位可以由振幅唯一确定，最多相差一个可以设为零的线性相位分量。\n\n**倒谱法**是同态信号处理中的一种技术，为执行这种相位重建提供了一个实用的算法。**实倒谱**，记为 $c[n]$，定义为实值对数振幅谱 $\\log A[k] = \\log|H[k]|$ 的傅里叶逆变换。\n$$\nc[n] = \\text{IDFT}\\{\\log|H[k]|\\}\n$$\n**复倒谱** $\\hat{c}[n]$ 是复对数谱 $\\log H[k]$ 的傅里叶逆变换。最小相位特性等价于复倒谱是一个因果序列（即，当 $n0$ 时 $\\hat{c}[n]=0$）。\n\n实倒谱 $c[n]$ 是复倒谱 $\\hat{c}[n]$ 的偶部。从实倒谱中，我们可以重建因果的最小相位复倒谱 $c_{\\min}[n]$，它作为 $\\hat{c}[n]$ 的离散近似。然后，$c_{\\min}[n]$ 的傅里叶正变换给出所需的最小相位复对数谱，并由此可获得子波。\n\n### 算法推导\n\n该问题指定了一个包含 $N$ 个样本的离散时间实现。设给定的振幅谱为 $A[k]$，其中 $k \\in \\{0, 1, \\dots, N-1\\}$。该算法按五个步骤进行。\n\n**步骤 1：计算实倒谱**\n我们首先计算振幅谱的对数。为避免 $\\log(0)$ 的问题，加入一个小的正常数 $\\epsilon$。实倒谱 $c[n]$ 是此对数谱的离散傅里叶逆变换 (IDFT)：\n$$\nc[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} \\log(A[k]+\\epsilon) \\exp\\left(i\\frac{2\\pi nk}{N}\\right)\n$$\n由于输入的振幅谱 $A[k]$ 被指定为偶对称（当 $k0$ 时 $A[k]=A[N-k]$），其对数也是偶对称的。一个实偶序列的 IDFT 是一个实偶序列，因此 $c[n]$ 将是实值且满足 $c[n]=c[N-n]$。\n\n**步骤 2：构建最小相位倒谱**\n最小相位特性对应于因果倒谱。我们通过仅保留“因果”部分（非负倒频率处的样本）并进行适当缩放，从实倒谱 $c[n]$ 构建最小相位倒谱 $c_{\\min}[n]$。实倒谱 $c[n]$ 代表因果部分与其时间反转部分之和。为了恢复因果部分，我们定义一个新序列 $c_{\\min}[n]$：\n$$\nc_{\\min}[n] =\n\\begin{cases}\nc[0]  n=0 \\\\\n2c[n]  1 \\le n  N/2 \\\\\nc[N/2]  n = N/2 \\quad (\\text{for even } N) \\\\\n0  N/2  n  N\n\\end{cases}\n$$\n对于 $1 \\le n  N/2$ 的因子 2，是为了将来自负倒频率样本（$c[N-n]=c[n]$）的能量折叠到正倒频率样本上。位于奈奎斯特倒频率的样本 $c[N/2]$ 是唯一的，没有负倒频率对应项，因此不加倍。\n\n**步骤 3：恢复复对数谱**\n最小相位倒谱 $c_{\\min}[n]$ 的 DFT 产生最小相位谱 $H_{\\min}[k]$ 的复对数：\n$$\n\\log H_{\\min}[k] = \\sum_{n=0}^{N-1} c_{\\min}[n] \\exp\\left(-i\\frac{2\\pi nk}{N}\\right)\n$$\n根据构造，$\\log H_{\\min}[k]$ 的实部将近似于原始的对数振幅谱 $\\log A[k]$，其虚部将是相应的最小相位。\n\n**步骤 4：获得最小相位谱**\n通过对上一步的结果取指数，可以获得最小相位复数谱 $H_{\\min}[k]$：\n$$\nH_{\\min}[k] = \\exp(\\log H_{\\min}[k])\n$$\n该谱的振幅 $|H_{\\min}[k]|$ 将约等于目标振幅谱 $A[k]$。\n\n**步骤 5：重建最小相位子波**\n最后，通过对 $H_{\\min}[k]$ 应用 IDFT 来恢复时域最小相位子波 $h[n]$：\n$$\nh[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} H_{\\min}[k] \\exp\\left(i\\frac{2\\pi nk}{N}\\right)\n$$\n因为 $c_{\\min}[n]$ 是一个实序列（但不是偶对称的），其 DFT $\\log H_{\\min}[k]$ 将表现出共轭对称性。此性质通过指数运算得以保留，确保 $H_{\\min}[k]$ 具有共轭对称性（$H_{\\min}[k] = \\overline{H_{\\min}[N-k]}$）。因此，得到的子波 $h[n]$ 将是实值的，任何残余的虚部都仅由浮点不精确性引起。子波 $h[n]$ 的最大振幅预计将出现在 $n=0$ 处。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements spectral factorization via the cepstral method to find a\n    minimum-phase wavelet from its amplitude spectrum for four test cases.\n    \"\"\"\n    N = 256\n    epsilon = 1e-8\n    \n    # --- Helper function for the main algorithm ---\n    def spectral_factorization(A, N, epsilon):\n        \"\"\"\n        Performs spectral factorization using the cepstral method.\n        \n        Args:\n            A (np.ndarray): The amplitude spectrum of size N.\n            N (int): The number of samples.\n            epsilon (float): A small constant for numerical stability.\n\n        Returns:\n            tuple: A tuple containing the reconstructed wavelet h and its\n                   complex spectrum H_min.\n        \"\"\"\n        # Step 1: Compute the real cepstrum\n        log_A = np.log(A + epsilon)\n        # IDFT of a real+even spectrum is a real+even cepstrum.\n        # .real discards negligible imaginary parts due to float precision.\n        c = np.fft.ifft(log_A).real\n\n        # Step 2: Construct the minimum-phase cepstrum\n        c_min = np.zeros(N)\n        c_min[0] = c[0]\n        c_min[1:N//2] = 2 * c[1:N//2]\n        if N % 2 == 0:\n            c_min[N//2] = c[N//2]\n        \n        # Step 3: Recover the complex logarithmic spectrum\n        log_H_min = np.fft.fft(c_min)\n        \n        # Step 4: Exponentiate to obtain the minimum-phase spectrum\n        H_min = np.exp(log_H_min)\n        \n        # Step 5: Reconstruct the wavelet\n        # The reconstructed wavelet should be real, as H_min has conjugate symmetry.\n        h = np.fft.ifft(H_min).real\n        \n        return h, H_min\n\n    results = []\n    \n    # --- Case 1: Flat amplitude spectrum ---\n    A1 = np.ones(N)\n    h1, H_min1 = spectral_factorization(A1, N, epsilon)\n    p1 = (np.argmax(h1) == 0)\n    E1_num = np.mean(np.abs(np.abs(H_min1) - A1))\n    E1_den = np.mean(A1)\n    E1 = E1_num / E1_den if E1_den != 0 else 0\n    results.extend([p1, E1])\n    \n    # --- Case 2: Ormsby-like bandpass amplitude ---\n    w1, w2, w3, w4 = [np.pi * x for x in [0.2, 0.3, 0.5, 0.7]]\n    k_half = np.arange(N // 2 + 1)\n    w_half = 2 * np.pi * k_half / N\n    A2_half = np.zeros(N // 2 + 1)\n    \n    idx_ramp_up = (w_half >= w1)  (w_half  w2)\n    A2_half[idx_ramp_up] = (w_half[idx_ramp_up] - w1) / (w2 - w1)\n    \n    idx_plateau = (w_half >= w2)  (w_half = w3)\n    A2_half[idx_plateau] = 1.0\n    \n    idx_ramp_down = (w_half >= w3)  (w_half = w4)\n    A2_half[idx_ramp_down] = 1.0 - (w_half[idx_ramp_down] - w3) / (w4 - w3)\n    \n    A2 = np.zeros(N)\n    A2[:N // 2 + 1] = A2_half\n    A2[N // 2 + 1:] = A2_half[N // 2 - 1:0:-1]\n    \n    h2, H_min2 = spectral_factorization(A2, N, epsilon)\n    p2 = (np.argmax(h2) == 0)\n    E2_num = np.mean(np.abs(np.abs(H_min2) - A2))\n    E2_den = np.mean(A2)\n    E2 = E2_num / E2_den if E2_den != 0 else 0\n    results.extend([p2, E2])\n\n    # --- Case 3: Autoregressive amplitude ---\n    a = 0.8\n    omega = 2 * np.pi * np.arange(N) / N\n    A3 = 1.0 / np.abs(1.0 - a * np.exp(-1j * omega))\n    \n    h3, H_min3 = spectral_factorization(A3, N, epsilon)\n    p3 = (np.argmax(h3) == 0)\n    E3_num = np.mean(np.abs(np.abs(H_min3) - A3))\n    E3_den = np.mean(A3)\n    E3 = E3_num / E3_den if E3_den != 0 else 0\n    results.extend([p3, E3])\n\n    # --- Case 4: Notch amplitude ---\n    wa, wb = 0.45 * np.pi, 0.55 * np.pi\n    k_half_4 = np.arange(N // 2 + 1)\n    w_half_4 = 2 * np.pi * k_half_4 / N\n    A4_half = np.ones(N // 2 + 1)\n    \n    idx_notch = (w_half_4 >= wa)  (w_half_4 = wb)\n    A4_half[idx_notch] = 1e-6\n    \n    A4 = np.zeros(N)\n    A4[:N//2 + 1] = A4_half\n    A4[N//2 + 1:] = A4_half[N//2 - 1:0:-1]\n\n    h4, H_min4 = spectral_factorization(A4, N, epsilon)\n    p4 = (np.argmax(h4) == 0)\n    E4_num = np.mean(np.abs(np.abs(H_min4) - A4))\n    E4_den = np.mean(A4)\n    E4 = E4_num / E4_den if E4_den != 0 else 0\n    results.extend([p4, E4])\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}