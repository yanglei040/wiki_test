{
    "hands_on_practices": [
        {
            "introduction": "本章的实践练习始于一个基本概念：特征值微扰理论。我们将通过一个具体的计算问题，探讨数值离散化等微小误差如何影响系统矩阵的特征值。这项练习旨在加深对系统稳定性及其特征模式敏感性的理解，这对于评估地球物理数值模型的可靠性至关重要。",
            "id": "3587795",
            "problem": "考虑在单位长度区间上的具有齐次狄利克雷边界条件的一维扩散算子，该算子通过二阶中心有限差分格式在具有三个内部点且网格间距为 $h=1$ 的均匀网格上进行离散。所得到的对称正定（SPD）刚度矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 为\n$$\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}.\n$$\n假设一个小的、对称的离散化误差将 $A$ 扰动为 $A + \\Delta A$，其中\n$$\n\\Delta A = \\epsilon \\, \\mathrm{diag}(1,-2,1),\n$$\n$\\epsilon$ 是一个代表扰动大小的无量纲小参数。\n\n仅使用对称矩阵和特征对的核心定义和性质，首先陈述适用于对称矩阵的单（代数重数为一）特征值的一阶（首项）特征值扰动结果。然后，应用此结果计算由 $\\Delta A$ 引起的 $A$ 的第二个特征值的一阶变化。将最终答案表示为关于 $\\epsilon$ 的闭式解析表达式。最终答案无需四舍五入，也无需单位。",
            "solution": "该问题被验证为具有科学依据、适定且客观。这是数值线性代数中的一个标准练习，特别是特征值扰动理论，在计算地球物理学中常见的偏微分方程数值解中有直接应用。所有必要信息均已提供，问题没有矛盾或歧义。\n\n第一步是陈述对称矩阵单特征值一阶扰动的基本结果。令 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称矩阵。令 $(\\lambda_k, \\mathbf{v}_k)$ 是 $A$ 的一个特征对，其中 $\\lambda_k$ 是一个单（非重复）特征值，$\\mathbf{v}_k$ 是对应的特征向量，我们将其归一化以满足 $\\mathbf{v}_k^T \\mathbf{v}_k = 1$。定义关系为 $A\\mathbf{v}_k = \\lambda_k \\mathbf{v}_k$。\n\n考虑一个应用于 $A$ 的小的、对称的扰动 $\\Delta A \\in \\mathbb{R}^{n \\times n}$，得到扰动矩阵 $A' = A + \\Delta A$。$A'$ 对应的特征对是 $(\\lambda'_k, \\mathbf{v}'_k)$。对于足够小的扰动（即 $\\|\\Delta A\\|$ 很小），特征值的变化量 $\\Delta\\lambda_k = \\lambda'_k - \\lambda_k$ 可以表示为扰动的幂级数。该级数的一阶（首项）项由以下公式给出：\n$$\n\\Delta\\lambda_k = \\mathbf{v}_k^T (\\Delta A) \\mathbf{v}_k + O(\\|\\Delta A\\|^2)\n$$\n一阶变化量，我们记为 $\\delta\\lambda_k$，因此为：\n$$\n\\delta\\lambda_k = \\mathbf{v}_k^T (\\Delta A) \\mathbf{v}_k\n$$\n这个结果也称为用未扰动的特征向量 $\\mathbf{v}_k$ 对扰动矩阵 $\\Delta A$ 求值的瑞利商。\n\n为了应用这个结果，我们必须求出给定矩阵的第二个特征值 $\\lambda_2$ 及其对应的归一化特征向量 $\\mathbf{v}_2$\n$$\nA = \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}\n$$\n特征值 $\\lambda$ 是特征方程 $\\det(A - \\lambda I) = 0$ 的根。\n$$\n\\det \\begin{pmatrix}\n2-\\lambda  -1  0 \\\\\n-1  2-\\lambda  -1 \\\\\n0  -1  2-\\lambda\n\\end{pmatrix} = 0\n$$\n沿第一行展开行列式可得：\n$$\n(2-\\lambda)((2-\\lambda)^2 - (-1)(-1)) - (-1)(-(2-\\lambda)) = 0\n$$\n$$\n(2-\\lambda)((2-\\lambda)^2 - 1) - (2-\\lambda) = 0\n$$\n$$\n(2-\\lambda)[(2-\\lambda)^2 - 1 - 1] = 0\n$$\n$$\n(2-\\lambda)[(2-\\lambda)^2 - 2] = 0\n$$\n该方程产生三个不同的根。\n一个根是 $2-\\lambda = 0$，得出 $\\lambda = 2$。\n另外两个根来自 $(2-\\lambda)^2 - 2 = 0$，这意味着 $2-\\lambda = \\pm\\sqrt{2}$，或 $\\lambda = 2 \\mp \\sqrt{2}$。\n$A$ 的特征值按升序排列为：\n$$\n\\lambda_1 = 2 - \\sqrt{2}\n$$\n$$\n\\lambda_2 = 2\n$$\n$$\n\\lambda_3 = 2 + \\sqrt{2}\n$$\n问题要求计算第二个特征值 $\\lambda_2 = 2$ 的变化。由于所有特征值都是不同的，所以 $\\lambda_2$ 是单特征值，一阶扰动理论适用。\n\n接下来，我们求出与 $\\lambda_2 = 2$ 对应的特征向量 $\\mathbf{v}_2$。我们必须求解方程组 $(A - \\lambda_2 I)\\mathbf{v}_2 = \\mathbf{0}$：\n$$\n(A - 2I)\\mathbf{v}_2 = \\begin{pmatrix}\n0  -1  0 \\\\\n-1  0  -1 \\\\\n0  -1  0\n\\end{pmatrix}\n\\begin{pmatrix}\nv_{2,1} \\\\\nv_{2,2} \\\\\nv_{2,3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix}\n$$\n该矩阵方程的第一行和第三行给出 $-v_{2,2} = 0$，所以 $v_{2,2} = 0$。\n第二行给出 $-v_{2,1} - v_{2,3} = 0$，所以 $v_{2,3} = -v_{2,1}$。\n选择 $v_{2,1} = 1$，我们得到一个未归一化的特征向量 $\\begin{pmatrix} 1  0  -1 \\end{pmatrix}^T$。\n为了使用扰动公式，我们必须将此特征向量归一化。其欧几里得范数为 $\\|\\begin{pmatrix} 1  0  -1 \\end{pmatrix}^T\\|_2 = \\sqrt{1^2 + 0^2 + (-1)^2} = \\sqrt{2}$。\n归一化后的特征向量是：\n$$\n\\mathbf{v}_2 = \\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n1 \\\\\n0 \\\\\n-1\n\\end{pmatrix}\n$$\n现在我们可以使用扰动矩阵 $\\Delta A = \\epsilon \\, \\mathrm{diag}(1,-2,1)$ 来计算一阶变化量 $\\delta\\lambda_2$。\n$$\n\\delta\\lambda_2 = \\mathbf{v}_2^T (\\Delta A) \\mathbf{v}_2\n$$\n代入 $\\mathbf{v}_2$ 和 $\\Delta A$ 的表达式：\n$$\n\\delta\\lambda_2 = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} \\right)^T \\left( \\epsilon \\begin{pmatrix} 1  0  0 \\\\ 0  -2  0 \\\\ 0  0  1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} \\right)\n$$\n提出标量因子：\n$$\n\\delta\\lambda_2 = \\frac{\\epsilon}{(\\sqrt{2})^2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -2  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}\n$$\n$$\n\\delta\\lambda_2 = \\frac{\\epsilon}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} (1)(1) + (0)(0) + (0)(-1) \\\\ (0)(1) + (-2)(0) + (0)(-1) \\\\ (0)(1) + (0)(0) + (1)(-1) \\end{pmatrix}\n$$\n$$\n\\delta\\lambda_2 = \\frac{\\epsilon}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}\n$$\n执行最终的点积：\n$$\n\\delta\\lambda_2 = \\frac{\\epsilon}{2} ((1)(1) + (0)(0) + (-1)(-1))\n$$\n$$\n\\delta\\lambda_2 = \\frac{\\epsilon}{2} (1 + 0 + 1) = \\frac{\\epsilon}{2} (2) = \\epsilon\n$$\n$A$ 的第二个特征值的一阶变化是 $\\epsilon$。",
            "answer": "$$\\boxed{\\epsilon}$$"
        },
        {
            "introduction": "从理论转向数据驱动的分析，本练习将谱方法应用于一个典型的地球物理学任务：对微震事件进行聚类。您将根据事件的物理属性构建一个关联图，并利用图拉普拉斯算子的特征向量将其划分到不同的裂缝组。这个实践将展示特征值分析如何揭示复杂地球物理数据集中的隐藏结构和内在联系。",
            "id": "3587801",
            "problem": "给定一个与两个裂缝组相关的合成微震事件集合。每个事件都具有空间坐标、发震时刻、矩震级和破裂持续时间。您将使用一个旨在强调破裂动力学的核函数，从这些事件构建一个亲和图，计算归一化图拉普拉斯矩阵，分析其特征值分布，并通过对第二小特征向量（Fiedler向量）进行阈值处理来执行双向谱聚类。您的目标是量化特征值分布如何决定谱聚类的质量，并设计一个更加强调破裂持续时间的核函数。所有推导必须从图、特征值和瑞利商的基本定义开始，并且您必须用这些原理来论证每个计算步骤，而不是预设任何目标公式。\n\n此问题的基础理论必须包括：带亲和权重的加权无向图的定义、度矩阵和图拉普拉斯矩阵、归一化图拉普拉斯矩阵、特征值的瑞利商表征，以及第二小特征值与松弛划分目标之间的联系。您还可以使用对称正定核的性质以及特征矩阵的奇异值分解（SVD）。\n\n数据生成必须是确定性的和纯算法的，如下所示。有 $N = 32$ 个事件，分为两个裂缝组 $\\mathcal{F}_A$ 和 $\\mathcal{F}_B$，每个组大小为 16。对于 $\\mathcal{F}_A$，用 $k \\in \\{0,1,\\ldots,15\\}$ 索引事件并定义：\n- 空间坐标（单位：米）：$\\mathbf{r}_k = (x_k,y_k,z_k)$ 其中 $x_k = 5 k$, $y_k = 2 \\sin(k)$, $z_k = 0$。\n- 发震时刻（单位：秒）：$t_k = 0.03 k$。\n- 矩震级（无量纲）：$m_k = 2.0 + 0.05\\,( (k \\bmod 4) - 1.5 )$。\n- 破裂持续时间（单位：秒）：$\\tau_k = 0.02 + 0.003\\,(k \\bmod 5)$。\n\n对于 $\\mathcal{F}_B$，用 $k \\in \\{0,1,\\ldots,15\\}$ 索引事件并定义：\n- 空间坐标（单位：米）：$\\mathbf{r}'_k = (x'_k,y'_k,z'_k)$ 其中 $x'_k = 120 + 5 k$, $y'_k = 2 \\cos(k)$, $z'_k = 5$。\n- 发震时刻（单位：秒）：$t'_k = 1.0 + 0.03 k$。\n- 矩震级（无量纲）：$m'_k = 2.0 + 0.07\\,( (k \\bmod 3) - 1.0 )$。\n- 破裂持续时间（单位：秒）：$\\tau'_k = 0.08 + 0.003\\,(k \\bmod 5)$。\n\n将这些事件连接成 $N=32$ 个事件，其真实裂缝标签为：$\\mathcal{F}_A$ 为 0，$\\mathcal{F}_B$ 为 1。\n\n使用高斯核函数对一个旨在强调破裂动力学的缩放特征向量进行处理，构建一个对称亲和矩阵 $W \\in \\mathbb{R}^{N \\times N}$。对每个事件 $i$，定义一个缩放特征向量\n$$\n\\mathbf{s}_i = \\left(\\frac{x_i}{\\ell}, \\frac{y_i}{\\ell}, \\frac{z_i}{\\ell}, \\frac{t_i}{T}, \\frac{m_i}{M}, \\sqrt{\\beta}\\,\\frac{\\tau_i}{\\Theta} \\right),\n$$\n其中 $\\ell$（米）、$T$（秒）、$M$（无量纲）、$\\Theta$（秒）是特征缩放参数，而 $\\beta$（无量纲）是强调破裂持续时间的权重参数。通过以下方式定义亲和权重\n$$\nW_{ij} = \\exp\\left(-\\left\\| \\mathbf{s}_i - \\mathbf{s}_j \\right\\|_2^2\\right), \\quad W_{ii} = 0.\n$$\n计算对角度矩阵 $D$（其元素为 $D_{ii} = \\sum_j W_{ij}$）和归一化图拉普拉斯矩阵\n$$\nL_{\\mathrm{sym}} = I - D^{-1/2} W D^{-1/2}.\n$$\n将 $L_{\\mathrm{sym}}$ 的特征值按 $0 = \\lambda_1 \\le \\lambda_2 \\le \\cdots \\le \\lambda_N$ 排序，并附上相应的标准正交特征向量。使用第二个特征向量，通过在其条目的中值处设置阈值，将节点集划分为两个不相交的簇，以执行双向谱聚类。\n\n对于每个指定的参数集，您必须：\n- 计算 $L_{\\mathrm{sym}}$ 的特征值和谱隙 $g = \\lambda_3 - \\lambda_2$。\n- 通过第二个特征向量执行双向谱聚类，通过中值阈值分配簇标签，并计算相对于真实裂缝标签的聚类纯度。纯度必须以 $[0,1]$ 区间内的小数形式报告。\n- 使用亲和矩阵 $W$ 和度矩阵 $D$ 计算所得划分的归一化切割值。\n- 构建行向量为 $\\mathbf{s}_i$ 的缩放特征矩阵 $X_s \\in \\mathbb{R}^{N \\times 6}$，通过奇异值分解（SVD）计算其奇异值，并报告最小奇异值与最大奇异值的比率。\n\n设计一个测试套件，通过改变尺度参数 $(\\ell,T,M,\\Theta)$ 和破裂强调参数 $\\beta$ 来探测不同的机制：\n- 情况 1（理想路径，强调破裂动力学）：$\\ell = 200$, $T = 0.5$, $M = 0.5$, $\\Theta = 0.02$, $\\beta = 5.0$。\n- 情况 2（边界情况，亲和度近乎同质）：$\\ell = 500$, $T = 5.0$, $M = 1.0$, $\\Theta = 0.2$, $\\beta = 1.0$。\n- 情况 3（边缘情况，几何主导）：$\\ell = 30$, $T = 100.0$, $M = 5.0$, $\\Theta = 10.0$, $\\beta = 0.2$。\n\n所有物理量必须严格按照所述单位处理：空间坐标以米为单位，时间和持续时间以秒为单位，震级无量纲。此问题中不使用角度。您的程序必须为每种情况产生以下输出：\n- 谱隙 $g$，浮点数。\n- 聚类纯度，小数。\n- 归一化切割值，浮点数。\n- 奇异值比率，浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是包含四个浮点数的列表，按 $[g,\\text{purity},\\text{ncut},\\text{svr}]$ 的顺序排列，并四舍五入到六位小数。例如，总体格式必须是\n$$\n\\big[\\,[g_1,\\text{purity}_1,\\text{ncut}_1,\\text{svr}_1],\\,[g_2,\\text{purity}_2,\\text{ncut}_2,\\text{svr}_2],\\,[g_3,\\text{purity}_3,\\text{ncut}_3,\\text{svr}_3]\\,\\big].\n$$",
            "solution": "该问题是有效的。它在科学上基于谱图理论及其在地球物理数据分析中的应用，在数学上是适定的、完全指定的和客观的。不存在矛盾或模糊之处。\n\n### 1. 理论框架\n\n任务是使用谱聚类将一组 $N=32$ 个微震事件划分为两个簇，对应两个不同的裂缝组。然后，在不同的特征缩放机制下评估此聚类的质量。该方法基于图论和线性代数的原理。\n\n#### 1.1. 图表示与亲和矩阵\n$N$ 个事件的集合被建模为一个加权无向图 $G = (V, E, W)$，其中顶点集 $V$ 代表事件，$E$ 是连接所有事件对的边集，$W \\in \\mathbb{R}^{N \\times N}$ 是对称亲和矩阵。权重 $W_{ij}$ 量化了事件 $i$ 和事件 $j$ 之间的相似性。\n\n事件首先由一组物理属性来表征：空间坐标 $\\mathbf{r}_i = (x_i, y_i, z_i)$、发震时刻 $t_i$、矩震级 $m_i$ 和破裂持续时间 $\\tau_i$。为了构建一个有意义的相似性度量，这些异构特征被映射到一个统一的、无量纲的特征空间。为每个事件 $i$ 定义一个缩放特征向量 $\\mathbf{s}_i \\in \\mathbb{R}^6$：\n$$\n\\mathbf{s}_i = \\left(\\frac{x_i}{\\ell}, \\frac{y_i}{\\ell}, \\frac{z_i}{\\ell}, \\frac{t_i}{T}, \\frac{m_i}{M}, \\sqrt{\\beta}\\,\\frac{\\tau_i}{\\Theta} \\right)\n$$\n这里，$\\ell$（长度单位）、$T$（时间单位）、$M$（无量纲）和 $\\Theta$（时间单位）是用于归一化不同物理量的缩放参数。无量纲参数 $\\beta$ 是一个权重，旨在控制破裂持续时间 $\\tau_i$ 对总亲和度的影响。\n\n两个事件 $i$ 和 $j$ 之间的亲和度 $W_{ij}$ 是使用高斯核计算的，这是一种正定核，可确保生成的亲和矩阵是对称半正定的：\n$$\nW_{ij} = \\exp\\left(-\\left\\| \\mathbf{s}_i - \\mathbf{s}_j \\right\\|_2^2\\right) \\quad \\text{for } i \\neq j\n$$\n按照惯例，对角线元素设为零，$W_{ii} = 0$，以避免自环。\n\n#### 1.2. 归一化图拉普拉斯矩阵与谱聚类\n谱聚类利用图拉普拉斯矩阵的谱（特征值和特征向量）。我们使用对称归一化拉普拉斯矩阵 $L_{\\mathrm{sym}}$，其定义如下：\n$$\nL_{\\mathrm{sym}} = I - D^{-1/2} W D^{-1/2}\n$$\n其中 $I$ 是单位矩阵，$D$ 是对角度矩阵，其元素为 $D_{ii} = \\sum_{j=1}^{N} W_{ij}$，表示节点 $i$ 的总亲和度。$D^{-1/2}$ 是一个对角矩阵，其元素为 $(D^{-1/2})_{ii} = 1/\\sqrt{D_{ii}}$。\n\n谱聚类的核心思想是找到图的顶点 $V$ 的一个划分为两个不相交的集合 $A$ 和 $\\bar{A}$，使得归一化切割（NCut）最小化：\n$$\n\\text{NCut}(A, \\bar{A}) = \\frac{\\text{cut}(A, \\bar{A})}{\\text{vol}(A)} + \\frac{\\text{cut}(A, \\bar{A})}{\\text{vol}(\\barA)}\n$$\n其中 $\\text{cut}(A, \\bar{A}) = \\sum_{i \\in A, j \\in \\bar{A}} W_{ij}$ 是跨越划分的边的权重之和，而 $\\text{vol}(A) = \\sum_{i \\in A} D_{ii}$ 是集合 $A$ 中节点的度之和。\n\n直接最小化 NCut 是一个 NP-难的组合问题。它可以被松弛为一个连续问题。设 $\\mathbf{y} \\in \\mathbb{R}^N$ 是一个编码该划分的向量。可以证明，NCut 最小化问题近似等价于最小化非归一化拉普拉斯矩阵 $L = D-W$ 的瑞利商：在约束 $\\mathbf{y}^T D \\mathbf{y} = 1$ 和 $\\mathbf{y}^T D \\mathbf{1} = 0$ 下，最小化 $\\min_{\\mathbf{y}} \\mathbf{y}^T L \\mathbf{y}$。\n\n通过变量替换 $\\mathbf{z} = D^{1/2}\\mathbf{y}$，此问题转换为：\n$$\n\\min_{\\mathbf{z}} \\mathbf{z}^T L_{\\mathrm{sym}} \\mathbf{z} \\quad \\text{subject to} \\quad \\mathbf{z}^T\\mathbf{z} = 1 \\quad \\text{and} \\quad \\mathbf{z}^T (D^{1/2}\\mathbf{1}) = 0\n$$\n根据 Rayleigh-Ritz 定理，瑞利商 $\\mathbf{z}^T L_{\\mathrm{sym}} \\mathbf{z} / \\mathbf{z}^T\\mathbf{z}$ 的最小值是 $L_{\\mathrm{sym}}$ 的最小特征值。$L_{\\mathrm{sym}}$ 的特征值按 $0 = \\lambda_1 \\le \\lambda_2 \\le \\cdots \\le \\lambda_N$ 排序。对应于 $\\lambda_1=0$ 的特征向量是 $\\mathbf{v}_1 = D^{1/2}\\mathbf{1} / \\|\\cdot\\|$，它代表一个平凡的常数解。约束条件 $\\mathbf{z}^T (D^{1/2}\\mathbf{1}) = 0$ 要求解与 $\\mathbf{v}_1$ 正交。因此，松弛问题的最优解是对应于第二小特征值 $\\lambda_2$ 的特征向量。这个特征向量 $\\mathbf{v}_2$ 被称为 Fiedler 向量。\n\nFiedler 向量 $\\mathbf{v}_2$ 的分量提供了图节点的一维嵌入。通过对这些分量进行阈值处理可以获得一个划分。在此问题中，我们在 $\\mathbf{v}_2$ 分量的中值处设置阈值，这将节点稳健地分成两个大小相等的集合（每个集合 16 个节点），这对于我们平衡的真实数据是理想的。\n\n#### 1.3. 评估指标\n聚类的有效性由四个指标来量化：\n1.  **谱隙 ($g$)**：$g = \\lambda_3 - \\lambda_2$。大的谱隙表明双簇结构很明显，基于 $\\mathbf{v}_2$ 的划分是稳定的，并且能够被图的结构很好地证明。\n2.  **聚类纯度**：此指标衡量计算出的簇在多大程度上包含来自单一真实裂缝组的事件。对于两个簇 $C_0, C_1$ 和两个真实类别 $T_A, T_B$，纯度计算为 $\\frac{1}{N} \\max(\\text{correct}_{map1}, \\text{correct}_{map2})$，其中 $\\text{correct}_{map1}$ 是假设 $C_0 \\to T_A$ 和 $C_1 \\to T_B$ 时正确分配的事件数，而 $\\text{correct}_{map2}$ 则是对应相反的分配 $C_0 \\to T_B$ 和 $C_1 \\to T_A$。\n3.  **归一化切割 (NCut)**：从 Fiedler 向量获得的划分的 NCut 目标函数的值。较小的 NCut 值表示更好的划分。\n4.  **奇异值比率 (SVR)**：缩放特征矩阵 $X_s$（其行为 $\\mathbf{s}_i$）的最小奇异值与最大奇异值之比，即 $\\sigma_{\\min}/\\sigma_{\\max}$。该比率量化了特征空间的条件数或“平坦度”。一个非常小的比率表明某些特征维度占主导地位，而接近 1 的比率则表明特征更具各向同性。\n\n### 2. 计算步骤\n\n对于三个测试用例中的每一个，执行以下步骤：\n\n1.  **数据生成**：根据提供的确定性公式生成 $N=32$ 个事件的属性。前 16 个事件属于裂缝组 $\\mathcal{F}_A$（标签 0），后 16 个属于 $\\mathcal{F}_B$（标签 1）。\n2.  **特征缩放**：使用给定情况的参数 $(\\ell, T, M, \\Theta, \\beta)$，将 $32 \\times 6$ 的原始数据特征矩阵进行缩放，以生成矩阵 $X_s$。\n3.  **图构建**：使用高斯核从 $X_s$ 计算亲和矩阵 $W$。然后构建度矩阵 $D$ 和归一化拉普拉斯矩阵 $L_{\\mathrm{sym}}$。\n4.  **特征系统与 SVD**：计算 $L_{\\mathrm{sym}}$ 的特征值和特征向量。同时计算 $X_s$ 的奇异值。\n5.  **指标计算**：\n    -   谱隙计算为 $g = \\lambda_3 - \\lambda_2$。\n    -   识别 Fiedler 向量 $\\mathbf{v}_2$。根据节点在 $\\mathbf{v}_2$ 中对应的分量是否大于 $\\mathbf{v}_2$ 的中值，将节点划分为两个簇。\n    -   根据真实标签计算此划分的纯度。\n    -   使用 $W、D$ 和该划分计算此划分的 NCut 值。\n    -   从 $X_s$ 的奇异值计算 SVR。\n6.  **输出格式化**：收集四个计算出的指标 $[g, \\text{purity}, \\text{ncut}, \\text{svr}]$ 并按规定格式化。\n\n对所有三个测试用例重复此过程，这些用例旨在探索缩放参数的选择如何影响谱聚类恢复数据底层结构的能力。情况 1 预计表现良好，因为它强调了具有区分性的破裂持续时间特征。情况 2 预计表现不佳，因为过大的缩放参数会使亲和度同质化。情况 3 预计表现良好，但其依据的主导特征（空间位置）与情况 1 不同。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the computational geophysics problem by performing spectral clustering\n    on synthetic microseismic event data for three different parameter cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, rupture-dynamics emphasis)\n        {'l': 200.0, 'T': 0.5, 'M': 0.5, 'Theta': 0.02, 'beta': 5.0},\n        # Case 2 (boundary, near-homogeneous affinities)\n        {'l': 500.0, 'T': 5.0, 'M': 1.0, 'Theta': 0.2, 'beta': 1.0},\n        # Case 3 (edge, geometry-dominated)\n        {'l': 30.0, 'T': 100.0, 'M': 5.0, 'Theta': 10.0, 'beta': 0.2},\n    ]\n\n    results = []\n\n    # --- Data Generation ---\n    N_per_set = 16\n    N = 2 * N_per_set\n\n    # Fracture Set A\n    k_a = np.arange(N_per_set)\n    x_a = 5 * k_a\n    y_a = 2 * np.sin(k_a)\n    z_a = np.zeros(N_per_set)\n    t_a = 0.03 * k_a\n    m_a = 2.0 + 0.05 * ((k_a % 4) - 1.5)\n    tau_a = 0.02 + 0.003 * (k_a % 5)\n\n    # Fracture Set B\n    k_b = np.arange(N_per_set)\n    x_b = 120 + 5 * k_b\n    y_b = 2 * np.cos(k_b)\n    z_b = 5 * np.ones(N_per_set)\n    t_b = 1.0 + 0.03 * k_b\n    m_b = 2.0 + 0.07 * ((k_b % 3) - 1.0)\n    tau_b = 0.08 + 0.003 * (k_b % 5)\n\n    # Concatenate data\n    x = np.concatenate((x_a, x_b))\n    y = np.concatenate((y_a, y_b))\n    z = np.concatenate((z_a, z_b))\n    t = np.concatenate((t_a, t_b))\n    m = np.concatenate((m_a, m_b))\n    tau = np.concatenate((tau_a, tau_b))\n\n    # Raw feature matrix\n    X_raw = np.column_stack([x, y, z, t, m, tau])\n\n    # Ground truth labels\n    ground_truth_labels = np.array([0] * N_per_set + [1] * N_per_set)\n\n    for case_params in test_cases:\n        l, T, M, Theta, beta = case_params.values()\n\n        # --- Feature Scaling ---\n        scaling_factors = np.array([1/l, 1/l, 1/l, 1/T, 1/M, np.sqrt(beta)/Theta])\n        X_s = X_raw * scaling_factors\n\n        # --- Affinity Matrix W ---\n        # Compute pairwise squared Euclidean distances\n        dist_sq = np.sum((X_s[:, np.newaxis, :] - X_s[np.newaxis, :, :])**2, axis=2)\n        W = np.exp(-dist_sq)\n        np.fill_diagonal(W, 0)\n        \n        # --- Normalized Graph Laplacian L_sym ---\n        D_diag = np.sum(W, axis=1)\n        # Handle case of isolated nodes, though unlikely with Gaussian kernel\n        D_diag[D_diag == 0] = 1e-12 \n        D_inv_sqrt_diag = 1.0 / np.sqrt(D_diag)\n        D_inv_sqrt = np.diag(D_inv_sqrt_diag)\n        \n        I = np.identity(N)\n        L_sym = I - D_inv_sqrt @ W @ D_inv_sqrt\n\n        # --- Eigen-analysis ---\n        eigenvalues, eigenvectors = np.linalg.eigh(L_sym)\n        # Eigenvalues are sorted in ascending order\n        lambda_2 = eigenvalues[1]\n        lambda_3 = eigenvalues[2]\n        g = lambda_3 - lambda_2\n        \n        fiedler_vector = eigenvectors[:, 1]\n        \n        # --- Spectral Clustering and Purity ---\n        median_val = np.median(fiedler_vector)\n        predicted_labels = (fiedler_vector  median_val).astype(int)\n        \n        # Calculate purity\n        matches_map1 = np.sum(predicted_labels == ground_truth_labels)\n        purity = max(matches_map1, N - matches_map1) / N\n\n        # --- Normalized Cut Value ---\n        A = np.where(predicted_labels == 0)[0]\n        B = np.where(predicted_labels == 1)[0]\n        \n        cut_AB = np.sum(W[np.ix_(A, B)])\n        vol_A = np.sum(D_diag[A])\n        vol_B = np.sum(D_diag[B])\n\n        if vol_A == 0 or vol_B == 0:\n            ncut = np.inf\n        else:\n            ncut = cut_AB / vol_A + cut_AB / vol_B\n            \n        # --- Singular Value Ratio ---\n        singular_values = np.linalg.svd(X_s, compute_uv=False)\n        # svd returns sorted singular values\n        svr = singular_values[-1] / singular_values[0] if singular_values[0]  0 else 0.0\n\n        results.append([g, purity, ncut, svr])\n\n    # Final print statement in the exact required format.\n    # [[g1,purity1,ncut1,svr1],[g2,purity2,ncut2,svr2],[g3,purity3,ncut3,svr3]]\n    result_str = ','.join(\n        f\"[{','.join(f'{v:.6f}' for v in r)}]\" for r in results\n    )\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们最后的练习将进入地球物理优化的前沿领域，特别是全波形反演（Full Waveform Inversion, FWI）。我们将探讨如何利用基于海森矩阵（Hessian matrix）特征向量的各向异性平滑技术，来缓解像周波跳跃（cycle skipping）这样的常见优化难题。这项练习揭示了特征值分析的强大能力——它不仅能用于理解系统，更能主动地调控系统行为，从而获得更稳健、更精确的反演结果。",
            "id": "3587829",
            "problem": "考虑一个简化的全波形反演（FWI）模型空间设置，其模型参数向量为 $\\mathbf{m} \\in \\mathbb{R}^3$。设围绕参考模型的数据残差的局部高斯-牛顿近似由一个对称正定Hessian矩阵 $\\mathbf{H} \\in \\mathbb{R}^{3 \\times 3}$ 表示。为了以可控的方式捕捉周期跳跃行为，我们沿预设方向用振荡分量来增强二次残差。定义合成残差函数\n$$\nJ(\\mathbf{m}) = \\tfrac{1}{2}\\,\\mathbf{m}^\\top \\mathbf{H}\\,\\mathbf{m} \\;+\\; \\gamma \\sum_{j=1}^{J} \\sin\\!\\big(\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{m} + \\phi_j\\,\\big),\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 控制振荡振幅，$\\omega_j \\in \\mathbb{R}$ 为角频率（单位为弧度），$\\mathbf{k}_j \\in \\mathbb{R}^3$ 为模型空间中的方向向量，$\\phi_j \\in \\mathbb{R}$ 为相位偏移（单位为弧度）。所有三角函数参数均以弧度处理。\n\n设Hessian矩阵的特征值分解为 $\\mathbf{H} = \\mathbf{Q}\\,\\mathrm{diag}(\\boldsymbol{\\lambda})\\,\\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是正交矩阵，$\\boldsymbol{\\lambda} = [\\lambda_1,\\lambda_2,\\lambda_3]^\\top$ 是正特征值。考虑一个与Hessian矩阵的特征向量对齐的各向异性平滑算子，该算子由一个阻尼函数在谱域上定义\n$$\ns(\\lambda_i; \\alpha, p) \\;=\\; \\frac{1}{1 + \\alpha\\,\\lambda_i^{\\,p}},\n$$\n其中 $\\alpha \\ge 0$ 且 $p \\ge 0$，算子为\n$$\n\\mathbf{S}(\\alpha,p) \\;=\\; \\mathbf{Q}\\,\\mathrm{diag}\\big(s(\\lambda_i; \\alpha,p)\\big)\\,\\mathbf{Q}^\\top.\n$$\n该算子选择性地阻尼高曲率方向（即大的 $\\lambda_i$）。\n\n根据基本微分法则，定义合成残差在 $\\mathbf{m}$ 处的梯度为：\n$$\n\\nabla J(\\mathbf{m}) \\;=\\; \\mathbf{H}\\,\\mathbf{m} \\;+\\; \\gamma \\sum_{j=1}^{J} \\omega_j \\cos\\!\\big(\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{m} + \\phi_j\\,\\big)\\,\\mathbf{k}_j.\n$$\n考虑使用和不使用各向异性平滑的下降方向：\n$$\n\\mathbf{d}_0 \\;=\\; -\\,\\nabla J(\\mathbf{m}), \\qquad \\mathbf{d}_\\alpha \\;=\\; -\\,\\mathbf{S}(\\alpha,p)\\,\\nabla J(\\mathbf{m}).\n$$\n对于选定的步长 $\\tau  0$，通过在单步中沿任一振荡方向引起的最大归一化相位变化来定义周期跳跃风险度量，\n$$\nR(\\mathbf{d}; \\tau) \\;=\\; \\max_{1 \\le j \\le J} \\frac{\\big|\\,\\tau\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{d}\\,\\big|}{\\pi}.\n$$\n如果 $R(\\mathbf{d}; \\tau) \\ge 1$，则该步存在周期跳跃的风险。评估平滑前的 $R(\\mathbf{d}_0; \\tau)$ 和平滑后的 $R(\\mathbf{d}_\\alpha; \\tau)$。\n\n此外，通过计算与高曲率特征方向集对齐的梯度振幅平方的分数，来量化高曲率分量的选择性阻尼。设高曲率索引集 $\\mathcal{I}_{\\mathrm{high}}$ 为那些使得 $\\lambda_i$ 处于或高于 $\\{\\lambda_1,\\lambda_2,\\lambda_3\\}$ 的第$75$百分位数的索引 $i$。在Hessian特征基中，令 $\\mathbf{c} = \\mathbf{Q}^\\top \\nabla J(\\mathbf{m})$ 和 $\\mathbf{c}' = \\mathrm{diag}\\big(s(\\lambda_i; \\alpha,p)\\big)\\,\\mathbf{c}$。定义\n$$\nF_{\\mathrm{high}}^{\\mathrm{before}} \\;=\\; \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} c_i^2}{\\sum_{i=1}^{3} c_i^2}, \\qquad\nF_{\\mathrm{high}}^{\\mathrm{after}} \\;=\\; \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} (c'_i)^2}{\\sum_{i=1}^{3} (c'_i)^2}.\n$$\n最后，通过平滑前后Hessian矩阵的谱条件数（2-范数）评估曲率的条件：\n$$\n\\kappa(\\mathbf{H}) \\;=\\; \\frac{\\sigma_{\\max}(\\mathbf{H})}{\\sigma_{\\min}(\\mathbf{H})}, \\qquad\n\\kappa\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big) \\;=\\; \\frac{\\sigma_{\\max}\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big)}{\\sigma_{\\min}\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big)},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别表示最大和最小奇异值。\n\n您的任务是实现一个程序，对于下方的每个测试用例，通过其特征值和一个由三个轴旋转的乘积指定的正交矩阵 $\\mathbf{Q}$ 来构造 $\\mathbf{H}$，在给定的 $\\mathbf{m}_0$ 处评估梯度，计算平滑前后的周期跳跃风险、平滑前后的高曲率能量分数，以及条件数 $\\kappa(\\mathbf{H})$ 和 $\\kappa(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H})$。所有角度均使用弧度。每个测试用例的最终输出必须是按以下顺序排列的七个浮点值列表\n$$\n\\big[\\,R(\\mathbf{d}_0;\\tau),\\; R(\\mathbf{d}_\\alpha;\\tau),\\; R(\\mathbf{d}_\\alpha;\\tau)/R(\\mathbf{d}_0;\\tau),\\; F_{\\mathrm{high}}^{\\mathrm{before}},\\; F_{\\mathrm{high}}^{\\mathrm{after}},\\; \\kappa(\\mathbf{H}),\\; \\kappa\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big)\\,\\big],\n$$\n并四舍五入到六位小数。\n\n将 $\\mathbf{Q}$ 构造为 $\\mathbf{Q} = \\mathbf{R}_z(\\theta_z)\\,\\mathbf{R}_y(\\theta_y)\\,\\mathbf{R}_x(\\theta_x)$，其中 $\\mathbf{R}_z(\\cdot)$、$\\mathbf{R}_y(\\cdot)$ 和 $\\mathbf{R}_x(\\cdot)$ 是分别围绕 $z$、$y$ 和 $x$ 轴按给定弧度角旋转的标准旋转矩阵。然后设置 $\\mathbf{H} = \\mathbf{Q}\\,\\mathrm{diag}(\\boldsymbol{\\lambda})\\,\\mathbf{Q}^\\top$。\n\n测试套件：\n\n- 案例 1（正常路径）：\n    - $\\boldsymbol{\\lambda} = [1.0,\\,5.0,\\,25.0]$, $(\\theta_z,\\theta_y,\\theta_x) = (0.6,\\,-0.3,\\,0.8)$,\n    - $\\mathbf{m}_0 = [0.2,\\,-0.1,\\,0.15]$, $\\gamma = 0.8$, $\\alpha = 0.5$, $p = 1$, $\\tau = 0.5$,\n    - $J = 3$ 个振荡项，参数为 $(\\mathbf{k}_1,\\omega_1,\\phi_1) = ([1.0,\\,2.0,\\,0.5],\\,12.0,\\,0.3)$，$(\\mathbf{k}_2,\\omega_2,\\phi_2) = ([-1.5,\\,0.0,\\,1.0],\\,8.0,\\,-0.4)$，$(\\mathbf{k}_3,\\omega_3,\\phi_3) = ([0.0,\\,-1.0,\\,2.0],\\,15.0,\\,0.2)$。\n\n- 案例 2（边界：近乎各向同性的曲率，无平滑）：\n    - $\\boldsymbol{\\lambda} = [2.0,\\,2.5,\\,3.0]$, $(\\theta_z,\\theta_y,\\theta_x) = (0.2,\\,0.1,\\,-0.25)$,\n    - $\\mathbf{m}_0 = [-0.05,\\,0.1,\\,0.2]$, $\\gamma = 0.6$, $\\alpha = 0.0$, $p = 1$, $\\tau = 0.5$,\n    - $J = 2$ 个振荡项，参数为 $(\\mathbf{k}_1,\\omega_1,\\phi_1) = ([0.5,\\,-1.0,\\,1.5],\\,10.0,\\,0.1)$，$(\\mathbf{k}_2,\\omega_2,\\phi_2) = ([1.0,\\,0.5,\\,-0.5],\\,7.0,\\,0.0)$。\n\n- 案例 3（边缘：强各向异性曲率，对高曲率方向强阻尼）：\n    - $\\boldsymbol{\\lambda} = [0.5,\\,10.0,\\,50.0]$, $(\\theta_z,\\theta_y,\\theta_x) = (1.0,\\,-0.5,\\,0.3)$,\n    - $\\mathbf{m}_0 = [0.3,\\,-0.25,\\,0.05]$, $\\gamma = 1.0$, $\\alpha = 10.0$, $p = 2$, $\\tau = 0.3$,\n    - $J = 3$ 个振荡项，参数为 $(\\mathbf{k}_1,\\omega_1,\\phi_1) = ([2.0,\\,0.0,\\,-1.0],\\,20.0,\\,-0.2)$，$(\\mathbf{k}_2,\\omega_2,\\phi_2) = ([-0.5,\\,1.5,\\,0.5],\\,18.0,\\,0.5)$，$(\\mathbf{k}_3,\\omega_3,\\phi_3) = ([1.0,\\,-2.0,\\,1.0],\\,25.0,\\,-0.1)$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按顺序汇总三个案例的结果，每个案例格式化为一个七元列表，数字四舍五入到六位小数。例如，输出必须如下所示\n$$\n[\\,[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6},r_{1,7}],\\,[r_{2,1},\\dots,r_{2,7}],\\,[r_{3,1},\\dots,r_{3,7}]\\,].\n$$\n不应打印任何附加文本。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n已知条件如下：\n- 模型参数向量：$\\mathbf{m} \\in \\mathbb{R}^3$。\n- Hessian矩阵：$\\mathbf{H} \\in \\mathbb{R}^{3 \\times 3}$，对称正定。\n- 合成残差函数：$J(\\mathbf{m}) = \\tfrac{1}{2}\\,\\mathbf{m}^\\top \\mathbf{H}\\,\\mathbf{m} \\;+\\; \\gamma \\sum_{j=1}^{J} \\sin\\!\\big(\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{m} + \\phi_j\\,\\big)$。\n- 参数：标量振幅 $\\gamma$、标量角频率 $\\omega_j$、方向向量 $\\mathbf{k}_j \\in \\mathbb{R}^3$、标量相位偏移 $\\phi_j$。\n- Hessian矩阵特征值分解：$\\mathbf{H} = \\mathbf{Q}\\,\\mathrm{diag}(\\boldsymbol{\\lambda})\\,\\mathbf{Q}^\\top$，其中 $\\mathbf{Q}$ 是正交矩阵，$\\boldsymbol{\\lambda} = [\\lambda_1,\\lambda_2,\\lambda_3]^\\top$ 是正特征值。\n- 各向异性平滑阻尼函数：$s(\\lambda_i; \\alpha, p) = \\frac{1}{1 + \\alpha\\,\\lambda_i^{\\,p}}$，其中 $\\alpha \\ge 0, p \\ge 0$。\n- 各向异性平滑算子：$\\mathbf{S}(\\alpha,p) = \\mathbf{Q}\\,\\mathrm{diag}\\big(s(\\lambda_i; \\alpha,p)\\big)\\,\\mathbf{Q}^\\top$。\n- 残差梯度：$\\nabla J(\\mathbf{m}) = \\mathbf{H}\\,\\mathbf{m} \\;+\\; \\gamma \\sum_{j=1}^{J} \\omega_j \\cos\\!\\big(\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{m} + \\phi_j\\,\\big)\\,\\mathbf{k}_j$。\n- 未平滑的下降方向：$\\mathbf{d}_0 = -\\,\\nabla J(\\mathbf{m})$。\n- 平滑后的下降方向：$\\mathbf{d}_\\alpha = -\\,\\mathbf{S}(\\alpha,p)\\,\\nabla J(\\mathbf{m})$。\n- 步长：$\\tau  0$。\n- 周期跳跃风险度量：$R(\\mathbf{d}; \\tau) = \\max_{1 \\le j \\le J} \\frac{\\big|\\,\\tau\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{d}\\,\\big|}{\\pi}$。\n- 高曲率索引集 $\\mathcal{I}_{\\mathrm{high}}$：使 $\\lambda_i$ 处于或高于 $\\{\\lambda_1,\\lambda_2,\\lambda_3\\}$ 的第75百分位数的索引 $i$。\n- 高曲率能量分数：$F_{\\mathrm{high}}^{\\mathrm{before}} = \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} c_i^2}{\\sum_{i=1}^{3} c_i^2}$ 和 $F_{\\mathrm{high}}^{\\mathrm{after}} = \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} (c'_i)^2}{\\sum_{i=1}^{3} (c'_i)^2}$，其中 $\\mathbf{c} = \\mathbf{Q}^\\top \\nabla J(\\mathbf{m})$ 且 $\\mathbf{c}' = \\mathrm{diag}\\big(s(\\lambda_i; \\alpha,p)\\big)\\,\\mathbf{c}$。\n- 谱条件数：$\\kappa(\\mathbf{H}) = \\frac{\\sigma_{\\max}(\\mathbf{H})}{\\sigma_{\\min}(\\mathbf{H})}$ 和 $\\kappa\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big) = \\frac{\\sigma_{\\max}\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big)}{\\sigma_{\\min}\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big)}$。\n- Hessian矩阵构造：$\\mathbf{H} = \\mathbf{Q}\\,\\mathrm{diag}(\\boldsymbol{\\lambda})\\,\\mathbf{Q}^\\top$，其中 $\\mathbf{Q} = \\mathbf{R}_z(\\theta_z)\\,\\mathbf{R}_y(\\theta_y)\\,\\mathbf{R}_x(\\theta_x)$。需使用标准旋转矩阵。\n- 提供了三个包含所有必要数值的完整测试用例。\n- 要求的输出是每个测试用例包含七个特定浮点值的列表，四舍五入到六位小数。\n\n### 步骤2：使用提取的已知条件进行验证\n根据指定标准对问题进行评估：\n- **科学基础**：该问题是计算地球物理学中一个核心问题的精心构建的简化模拟，特别是全波形反演的数值优化。Hessian矩阵、残差函数、梯度下降、周期跳跃和谱预处理（平滑）等概念都是标准的、数学上合理的。该问题遵循线性代数和多元微积分的基本原理。\n- **适定性**：该问题是确定性和完整的。对于每个测试用例，所有参数和函数都被明确定义，从而得到一组唯一且可计算的结果。\n- **客观性**：问题使用精确、无歧义的数学术语陈述。没有主观或基于意见的成分。\n- **缺陷检查**：问题没有表现出任何列出的无效性缺陷。它在数学上是合理的，与指定主题相关，是完整的，计算上可行的，并且结构良好。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将开发一个解决方案。\n\n该解决方案要求为每个测试用例计算七个度量，分析谱定义的各向异性平滑算子对基于梯度的优化的影响。步骤如下。\n\n首先，对于每个测试用例，我们构造Hessian矩阵 $\\mathbf{H}$。正交矩阵 $\\mathbf{Q}$ 由三个标准旋转矩阵的乘积形成：\n$$ \\mathbf{R}_x(\\theta_x) = \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\theta_x  -\\sin\\theta_x \\\\ 0  \\sin\\theta_x  \\cos\\theta_x \\end{pmatrix}, \\quad\n   \\mathbf{R}_y(\\theta_y) = \\begin{pmatrix} \\cos\\theta_y  0  \\sin\\theta_y \\\\ 0  1  0 \\\\ -\\sin\\theta_y  0  \\cos\\theta_y \\end{pmatrix}, \\quad\n   \\mathbf{R}_z(\\theta_z) = \\begin{pmatrix} \\cos\\theta_z  -\\sin\\theta_z  0 \\\\ \\sin\\theta_z  \\cos\\theta_z  0 \\\\ 0  0  1 \\end{pmatrix}. $$\n矩阵 $\\mathbf{Q}$ 则是 $\\mathbf{Q} = \\mathbf{R}_z(\\theta_z)\\,\\mathbf{R}_y(\\theta_y)\\,\\mathbf{R}_x(\\theta_x)$。Hessian矩阵通过其谱分解和给定的特征值 $\\boldsymbol{\\lambda}$ 来构造：$\\mathbf{H} = \\mathbf{Q}\\,\\mathrm{diag}(\\boldsymbol{\\lambda})\\,\\mathbf{Q}^\\top$。\n\n其次，我们在指定的模型点 $\\mathbf{m}_0$ 计算残差函数的梯度 $\\nabla J(\\mathbf{m})$。公式为：\n$$ \\nabla J(\\mathbf{m}_0) = \\mathbf{H}\\,\\mathbf{m}_0 + \\gamma \\sum_{j=1}^{J} \\omega_j \\cos\\big(\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{m}_0 + \\phi_j\\,\\big)\\,\\mathbf{k}_j. $$\n该向量概括了残差函数局部最陡峭上升的方向。\n\n第三，我们确定未平滑和平滑的下降方向。未平滑的方向就是负梯度，$\\mathbf{d}_0 = -\\nabla J(\\mathbf{m}_0)$。平滑后的方向 $\\mathbf{d}_\\alpha$ 需要平滑算子 $\\mathbf{S}(\\alpha, p)$。该算子在 $\\mathbf{H}$ 的特征基中定义。对于每个特征值 $\\lambda_i$，计算阻尼值 $s_i$：\n$$ s_i = s(\\lambda_i; \\alpha, p) = \\frac{1}{1 + \\alpha\\,\\lambda_i^{\\,p}}. $$\n算子是 $\\mathbf{S}(\\alpha, p) = \\mathbf{Q}\\,\\mathrm{diag}(s_1, s_2, s_3)\\,\\mathbf{Q}^\\top$。平滑后的方向是 $\\mathbf{d}_\\alpha = -\\mathbf{S}(\\alpha, p)\\,\\nabla J(\\mathbf{m}_0)$。在计算上，在特征基中应用平滑更高效：首先投影梯度 $\\mathbf{c} = \\mathbf{Q}^\\top \\nabla J(\\mathbf{m}_0)$，然后缩放分量 $c'_i = s_i c_i$，最后变换回来 $\\mathbf{d}_\\alpha = -\\mathbf{Q}\\,\\mathbf{c}'$。\n\n第四，我们评估两个方向的周期跳跃风险。使用度量定义，我们计算：\n$$ R(\\mathbf{d}_0; \\tau) = \\max_{j} \\frac{|\\tau\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{d}_0|}{\\pi} \\quad \\text{和} \\quad R(\\mathbf{d}_\\alpha; \\tau) = \\max_{j} \\frac{|\\tau\\,\\omega_j\\,\\mathbf{k}_j^\\top \\mathbf{d}_\\alpha|}{\\pi}. $$\n同时计算比率 $R(\\mathbf{d}_\\alpha; \\tau) / R(\\mathbf{d}_0; \\tau)$。\n\n第五，我们量化高曲率分量的阻尼。对于一个3元集合，第75百分位数隔离出单个最大特征值 $\\lambda_{\\max}$。因此，$\\mathcal{I}_{\\mathrm{high}}$ 包含与 $\\lambda_{\\max}$ 对应的索引。在特征基中的梯度分量 $\\mathbf{c} = \\mathbf{Q}^\\top \\nabla J(\\mathbf{m}_0)$ 及其平滑后的对应分量 $\\mathbf{c}'$（其中 $c'_i = s_i c_i$）被用来计算能量分数：\n$$ F_{\\mathrm{high}}^{\\mathrm{before}} = \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} c_i^2}{\\sum_{i=1}^{3} c_i^2}, \\qquad F_{\\mathrm{high}}^{\\mathrm{after}} = \\frac{\\sum_{i \\in \\mathcal{I}_{\\mathrm{high}}} (c'_i)^2}{\\sum_{i=1}^{3} (c'_i)^2}. $$\n这些度量衡量了高曲率特征方向在平滑前后对梯度总能量的相对贡献。\n\n第六，我们评估问题曲率的条件。计算Hessian矩阵 $\\mathbf{H}$ 的条件数。由于 $\\mathbf{H}$ 是对称正定的，其奇异值就是其特征值。因此，$\\kappa(\\mathbf{H}) = \\lambda_{\\max}/\\lambda_{\\min}$。然后我们考虑平滑后的Hessian矩阵 $\\mathbf{S}(\\alpha, p)\\mathbf{H}$。其谱分解为：\n$$ \\mathbf{S}\\mathbf{H} = \\left( \\mathbf{Q}\\,\\mathrm{diag}(s_i)\\,\\mathbf{Q}^\\top \\right) \\left( \\mathbf{Q}\\,\\mathrm{diag}(\\lambda_i)\\,\\mathbf{Q}^\\top \\right) = \\mathbf{Q}\\,\\mathrm{diag}(s_i \\lambda_i)\\,\\mathbf{Q}^\\top. $$\n$\\mathbf{S}\\mathbf{H}$ 的特征值是 $\\lambda'_i = s_i \\lambda_i = \\frac{\\lambda_i}{1 + \\alpha\\,\\lambda_i^{\\,p}}$。由于该矩阵也是对称的且其特征值 $\\lambda'_i$ 是正的，其条件数是其最大特征值与最小特征值之比：\n$$ \\kappa\\big(\\mathbf{S}(\\alpha,p)\\,\\mathbf{H}\\big) = \\frac{\\max_i(\\lambda'_i)}{\\min_i(\\lambda'_i)}. $$\n\n这六个步骤为每个测试用例提供了所有七个所需的输出值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the calculation for each case and prints the final result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"lambda_vals\": np.array([1.0, 5.0, 25.0]),\n            \"angles\": (0.6, -0.3, 0.8), # (theta_z, theta_y, theta_x)\n            \"m0\": np.array([0.2, -0.1, 0.15]),\n            \"gamma\": 0.8, \"alpha\": 0.5, \"p\": 1.0, \"tau\": 0.5,\n            \"osc_terms\": [\n                {\"k\": np.array([1.0, 2.0, 0.5]), \"omega\": 12.0, \"phi\": 0.3},\n                {\"k\": np.array([-1.5, 0.0, 1.0]), \"omega\": 8.0, \"phi\": -0.4},\n                {\"k\": np.array([0.0, -1.0, 2.0]), \"omega\": 15.0, \"phi\": 0.2},\n            ]\n        },\n        {\n            \"lambda_vals\": np.array([2.0, 2.5, 3.0]),\n            \"angles\": (0.2, 0.1, -0.25),\n            \"m0\": np.array([-0.05, 0.1, 0.2]),\n            \"gamma\": 0.6, \"alpha\": 0.0, \"p\": 1.0, \"tau\": 0.5,\n            \"osc_terms\": [\n                {\"k\": np.array([0.5, -1.0, 1.5]), \"omega\": 10.0, \"phi\": 0.1},\n                {\"k\": np.array([1.0, 0.5, -0.5]), \"omega\": 7.0, \"phi\": 0.0},\n            ]\n        },\n        {\n            \"lambda_vals\": np.array([0.5, 10.0, 50.0]),\n            \"angles\": (1.0, -0.5, 0.3),\n            \"m0\": np.array([0.3, -0.25, 0.05]),\n            \"gamma\": 1.0, \"alpha\": 10.0, \"p\": 2.0, \"tau\": 0.3,\n            \"osc_terms\": [\n                {\"k\": np.array([2.0, 0.0, -1.0]), \"omega\": 20.0, \"phi\": -0.2},\n                {\"k\": np.array([-0.5, 1.5, 0.5]), \"omega\": 18.0, \"phi\": 0.5},\n                {\"k\": np.array([1.0, -2.0, 1.0]), \"omega\": 25.0, \"phi\": -0.1},\n            ]\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = process_case(params)\n        all_results.append(results)\n\n    # Format the final output string as specified.\n    # Convert results to list of lists of rounded floats, then format to string.\n    rounded_results = np.round(np.array(all_results), 6).tolist()\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, item))}]' for item in rounded_results])}]\"\n    \n    print(output_str)\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case and returns the seven required metrics.\n    \"\"\"\n    lambda_vals = params[\"lambda_vals\"]\n    theta_z, theta_y, theta_x = params[\"angles\"]\n    m0 = params[\"m0\"]\n    gamma, alpha, p, tau = params[\"gamma\"], params[\"alpha\"], params[\"p\"], params[\"tau\"]\n    osc_terms = params[\"osc_terms\"]\n    \n    # --- Step 1: Construct Hessian H ---\n    cz, sz = np.cos(theta_z), np.sin(theta_z)\n    cy, sy = np.cos(theta_y), np.sin(theta_y)\n    cx, sx = np.cos(theta_x), np.sin(theta_x)\n    \n    Rz = np.array([[cz, -sz, 0], [sz, cz, 0], [0, 0, 1]])\n    Ry = np.array([[cy, 0, sy], [0, 1, 0], [-sy, 0, cy]])\n    Rx = np.array([[1, 0, 0], [0, cx, -sx], [0, sx, cx]])\n    \n    Q = Rz @ Ry @ Rx\n    Lambda_mat = np.diag(lambda_vals)\n    H = Q @ Lambda_mat @ Q.T\n    \n    # --- Step 2: Compute Gradient at m0 ---\n    # Quadratic part of the gradient\n    grad_J_quad = H @ m0\n    \n    # Oscillatory part of the gradient\n    grad_J_osc = np.zeros(3)\n    for term in osc_terms:\n        k, omega, phi = term[\"k\"], term[\"omega\"], term[\"phi\"]\n        arg = omega * k.T @ m0 + phi\n        grad_J_osc += omega * np.cos(arg) * k\n        \n    grad_J = grad_J_quad + gamma * grad_J_osc\n    \n    # --- Step 3  4: Compute Descent Directions ---\n    d0 = -grad_J\n    \n    s_vals = 1 / (1 + alpha * lambda_vals**p)\n    # Efficient application of S: project, scale, back-project\n    c = Q.T @ grad_J\n    c_prime = s_vals * c\n    d_alpha = -Q @ c_prime\n    \n    # --- Step 5: Evaluate Cycle-Skipping Risk R ---\n    risk_d0_vals = []\n    risk_d_alpha_vals = []\n    for term in osc_terms:\n        k, omega = term[\"k\"], term[\"omega\"]\n        risk_d0_vals.append(np.abs(tau * omega * k.T @ d0) / np.pi)\n        risk_d_alpha_vals.append(np.abs(tau * omega * k.T @ d_alpha) / np.pi)\n        \n    R_d0 = np.max(risk_d0_vals) if risk_d0_vals else 0.0\n    R_d_alpha = np.max(risk_d_alpha_vals) if risk_d_alpha_vals else 0.0\n    \n    # Ratio R_alpha / R_d0\n    # Add a small epsilon to avoid division by zero in unlikely cases\n    R_ratio = R_d_alpha / (R_d0 + 1e-12)\n\n    # --- Step 6: Analyze High-Curvature Damping F_high ---\n    # Sort eigenvalues to find high-curvature index\n    sorted_indices = np.argsort(lambda_vals)\n    i_high = sorted_indices[-1] # Index of the largest eigenvalue\n\n    # Total squared norm of gradient in eigenbasis\n    c_sq_norm = np.sum(c**2)\n    # Total squared norm of smoothed gradient in eigenbasis\n    c_prime_sq_norm = np.sum(c_prime**2)\n\n    # Add epsilon to denominators to prevent division by zero if gradient is zero\n    F_high_before = c[i_high]**2 / (c_sq_norm + 1e-12)\n    F_high_after = c_prime[i_high]**2 / (c_prime_sq_norm + 1e-12)\n    \n    # --- Step 7: Assess Conditioning kappa ---\n    kappa_H = np.max(lambda_vals) / np.min(lambda_vals)\n    \n    lambda_prime = lambda_vals / (1 + alpha * lambda_vals**p)\n    kappa_SH = np.max(lambda_prime) / np.min(lambda_prime)\n    \n    return [R_d0, R_d_alpha, R_ratio, F_high_before, F_high_after, kappa_H, kappa_SH]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}