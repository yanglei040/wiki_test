{
    "hands_on_practices": [
        {
            "introduction": "引力波信息被编码在度规微扰的横向无迹（TT）部分中。本练习将通过一个具体实例，训练你亲手操作用于从一般度规分量中分离出引力波信号的数学工具——TT投影算符。掌握这项技术是进行任何引力波解析计算的关键第一步。",
            "id": "3476552",
            "problem": "考虑闵可夫斯基时空在弱场极限下的线性化引力，其中通过对空间对称二阶张量施加横向无迹 (TT) 条件来分离出引力波内容。设传播方向为单位矢量 $\\hat{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$，并设对称空间张量为\n$$\nS_{ij}(t) \\equiv \\begin{pmatrix}\n2\\cos(\\Omega t)  \\sin(\\Omega t)  \\cos(\\Omega t) \\\\\n\\sin(\\Omega t)  -\\cos(\\Omega t) + \\sin(\\Omega t)  2\\sin(\\Omega t) \\\\\n\\cos(\\Omega t)  2\\sin(\\Omega t)  3\\cos(\\Omega t)\n\\end{pmatrix},\n$$\n其中 $\\Omega$ 是一个恒定的角频率，$t$ 是坐标时。\n\n从广义相对论 (GR) 弱场极限中平面波的 TT 条件定义出发——即 TT 部分 $S^{TT}_{ij}$ 与传播方向横向，$\\hat{n}^{i} S^{TT}_{ij} = 0$，并且相对于空间欧几里得度规是无迹的，$\\delta^{ij} S^{TT}_{ij} = 0$——使用到与 $\\hat{n}$ 正交的平面上的空间投影算符，推导将任意对称空间张量 $S_{ij}$ 映射到其 TT 部分 $S^{TT}_{ij}$ 的 TT 投影算符。然后，将你推导出的投影算符应用于上面给出的特定 $S_{ij}(t)$ 和 $\\hat{n}$，以获得 $S^{TT}_{ij}(t)$ 作为一个以 $\\sin(\\Omega t)$ 和 $\\cos(\\Omega t)$ 表示的 $3\\times 3$ 矩阵的显式闭合形式表达式。\n\n将你的最终答案表示为单个闭合形式的解析 $3\\times 3$ 矩阵。不需要数值近似或四舍五入，也不应包含任何物理单位。",
            "solution": "`\n- **引言：** 陈述目标是推导 TT 投影算符并将其应用于给定的张量 $S_{ij}$。\n- **TT 投影算符的推导：**\n    - 从一个任意的对称空间张量 $S_{ij}$ 开始。\n    - 目标是获得满足两个条件 $\\hat{n}^i S^{TT}_{ij} = 0$ 和 $\\delta^{ij} S^{TT}_{ij} = 0$ 的 $S^{TT}_{ij}$。\n    - 该投影是一个两步过程。\n    - **步骤 A：投影到与 $\\hat{n}$ 正交的平面上。**\n        - 定义到 $\\hat{n}$ 方向上的投影算符为 $\\hat{n}_i \\hat{n}_j$。\n        - 到与 $\\hat{n}$ 正交的平面上的投影算符是 $P_{ij} = \\delta_{ij} - \\hat{n}_i \\hat{n}_j$。这里，$\\delta_{ij}$ 是克罗内克 δ（或欧几里得度规）。\n        - 将此投影算符两次应用于 $S_{kl}$ 会得到一个横向张量。我们称之为 $S'_{ij}$。\n        - $S'_{ij} = P_{ik} P_{jl} S_{kl}$。根据构造，该张量是对称和横向的。\n        - 我们来验证横向性：$\\hat{n}^i S'_{ij} = \\hat{n}^i P_{ik} P_{jl} S_{kl} = (\\hat{n}^i (\\delta_{ik} - \\hat{n}_i \\hat{n}_k)) P_{jl} S_{kl} = (\\hat{n}_k - \\hat{n}_k (\\hat{n}^i\\hat{n}_i)) P_{jl} S_{kl}$。由于 $\\hat{n}^i\\hat{n}_i = 1$，这变为 $(n_k - n_k) P_{jl} S_{kl} = 0$。所以，$S'_{ij}$ 是横向的。\n    - **步骤 B：使张量无迹。**\n        - 横向张量 $S'_{ij}$ 通常不是无迹的。它的迹是 $S' = \\delta^{ij} S'_{ij}$。\n        - 我们需要从 $S'_{ij}$ 中减去一部分使其无迹，同时不破坏其横向性。\n        - 要减去的部分必须具有 $C \\cdot P_{ij}$ 的形式，其中 $C$ 是一个标量，因为 $P_{ij}$ 是横向平面上的“单位元”。$\\hat{n}^i P_{ij} = 0$。所以减去 $P_{ij}$ 的倍数可以保持横向性。\n        - 设 $S^{TT}_{ij} = S'_{ij} - C \\cdot P_{ij}$。\n        - 条件是 $\\delta^{ij} S^{TT}_{ij} = 0$。\n        - $0 = \\delta^{ij} (S'_{ij} - C P_{ij}) = \\delta^{ij} S'_{ij} - C \\delta^{ij} P_{ij}$。\n        - $0 = S' - C (\\delta^{ij} (\\delta_{ij} - \\hat{n}_i \\hat{n}_j)) = S' - C (\\delta^{ii} - \\hat{n}^j \\hat{n}_j)$。\n        - 在 3 维空间中，$\\delta^{ii} = 3$。并且 $\\hat{n}^j \\hat{n}_j = 1$。\n        - 所以，$0 = S' - C (3-1) = S' - 2C$。\n        - 这得出 $C = \\frac{1}{2} S'$。\n        - 因此，$S^{TT}_{ij} = S'_{ij} - \\frac{1}{2} S' P_{ij}$。\n    - **结合步骤：**\n        - $S^{TT}_{ij} = P_{ik} P_{jl} S_{kl} - \\frac{1}{2} (\\delta^{ab} P_{ac} P_{bd} S_{cd}) P_{ij}$。\n        - 这就是 TT 投影算符，通常表示为 $\\Lambda_{ijkl}$。所以 $S^{TT}_{ij} = \\Lambda_{ijkl} S_{kl}$。\n        - $\\Lambda_{ijkl} = P_{ik}P_{jl} - \\frac{1}{2} P_{ij} P_{kl}$。这是 TT 投影算符的标准形式。\n- **应用于具体问题：**\n    - **已知：** $\\hat{n} = \\frac{1}{\\sqrt{3}}(1, 1, 1)$。\n    - 投影算符 $P_{ij} = \\delta_{ij} - \\hat{n}_i \\hat{n}_j$。\n    - $\\hat{n}_i \\hat{n}_j = \\frac{1}{3} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix}$。\n    - $P = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix}$。\n    - 张量 $S_{ij}(t)$ 已给出。让我们将其写为 $S$。\n    - **步骤 A：计算 $S' = P S P^T$。** 由于 $P$ 是对称的，$P^T = P$。所以 $S' = P S P$。\n        - 让我们进行矩阵乘法。这会有点繁琐。\n        - $S = \\begin{pmatrix} 2c  s  c \\\\ s  -c+s  2s \\\\ c  2s  3c \\end{pmatrix}$，其中 $c = \\cos(\\Omega t)$ 且 $s = \\sin(\\Omega t)$。\n        - 首先，计算 $SP$。\n        - $SP = \\begin{pmatrix} 2c  s  c \\\\ s  -c+s  2s \\\\ c  2s  3c \\end{pmatrix} \\frac{1}{3} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix}$\n        - $(SP)_{11} = \\frac{1}{3} (4c - s - c) = \\frac{1}{3} (3c - s)$\n        - $(SP)_{12} = \\frac{1}{3} (-2c + 2s - c) = \\frac{1}{3} (-3c + 2s)$\n        - $(SP)_{13} = \\frac{1}{3} (-2c - s + 2c) = \\frac{1}{3} (-s)$\n        - $(SP)_{21} = \\frac{1}{3} (2s - (-c+s) - 2s) = \\frac{1}{3} (-s+c)$\n        - $(SP)_{22} = \\frac{1}{3} (-s + 2(-c+s) - 2s) = \\frac{1}{3} (-s - 2c + 2s - 2s) = \\frac{1}{3} (-s - 2c)$\n        - $(SP)_{23} = \\frac{1}{3} (-s - (-c+s) + 4s) = \\frac{1}{3} (-s+c-s+4s) = \\frac{1}{3} (2s+c)$\n        - $(SP)_{31} = \\frac{1}{3} (2c - 2s - 3c) = \\frac{1}{3} (-c-2s)$\n        - $(SP)_{32} = \\frac{1}{3} (-c + 4s - 3c) = \\frac{1}{3} (-4c+4s)$\n        - $(SP)_{33} = \\frac{1}{3} (-c - 2s + 6c) = \\frac{1}{3} (5c-2s)$\n        - $SP = \\frac{1}{3} \\begin{pmatrix} 3c-s  -3c+2s  -s \\\\ -s+c  -s-2c  2s+c \\\\ -c-2s  -4c+4s  5c-2s \\end{pmatrix}$\n        - 现在，计算 $S' = P(SP)$。\n        - $S' = \\frac{1}{3} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix} \\frac{1}{3} \\begin{pmatrix} 3c-s  -3c+2s  -s \\\\ -s+c  -s-2c  2s+c \\\\ -c-2s  -4c+4s  5c-2s \\end{pmatrix}$\n        - $S' = \\frac{1}{9} \\begin{pmatrix} \\dots  \\dots  \\dots \\\\ \\dots  \\dots  \\dots \\\\ \\dots  \\dots  \\dots \\end{pmatrix}$\n        - $(S')_{11} = 2(3c-s) - (-s+c) - (-c-2s) = 6c-2s+s-c+c+2s = 6c+s$\n        - $(S')_{12} = 2(-3c+2s) - (-s-2c) - (-4c+4s) = -6c+4s+s+2c+4c-4s = s$\n        - $(S')_{13} = 2(-s) - (2s+c) - (5c-2s) = -2s-2s-c-5c+2s = -6c-2s$\n        - 让我们检查对称性。$(S')_{21}$ 应等于 $(S')_{12}$。\n        - $(S')_{21} = -(3c-s) + 2(-s+c) - (-c-2s) = -3c+s-2s+2c+c+2s = s$。好的。\n        - $(S')_{22} = -(-3c+2s) + 2(-s-2c) - (-4c+4s) = 3c-2s-2s-4c+4c-4s = 3c-8s$\n        - $(S')_{23} = -(-s) + 2(2s+c) - (5c-2s) = s+4s+2c-5c+2s = 7s-3c$\n        - 让我们检查 $(S')_{31} = (S')_{13}$。\n        - $(S')_{31} = -(3c-s) - (-s+c) + 2(-c-2s) = -3c+s+s-c-2c-4s = -6c-2s$。好的。\n        - 让我们检查 $(S')_{32} = (S')_{23}$。\n        - $(S')_{32} = -(-3c+2s) - (-s-2c) + 2(-4c+4s) = 3c-2s+s+2c-8c+8s = -3c+7s$。好的。\n        - $(S')_{33} = -(-s) - (2s+c) + 2(5c-2s) = s-2s-c+10c-4s = 9c-5s$\n        - 所以，$S' = \\frac{1}{9} \\begin{pmatrix} 6c+s  s  -6c-2s \\\\ s  3c-8s  -3c+7s \\\\ -6c-2s  -3c+7s  9c-5s \\end{pmatrix}$。\n        \n    - **步骤 B：使其无迹。**\n        - 计算 $S'$ 的迹。$S' = \\delta^{ij} S'_{ij} = (S')_{11} + (S')_{22} + (S')_{33}$。\n        - $S' = \\frac{1}{9} [ (6c+s) + (3c-8s) + (9c-5s) ] = \\frac{1}{9} [ (6+3+9)c + (1-8-5)s ]$\n        - $S' = \\frac{1}{9} [ 18c - 12s ] = \\frac{6}{9} (3c - 2s) = \\frac{2}{3} (3c - 2s)$。\n        - 要减去的项是 $\\frac{1}{2} S' P$。\n        - $\\frac{1}{2} S' = \\frac{1}{3} (3c-2s)$。\n        - $\\frac{1}{2} S' P = \\frac{1}{3}(3c-2s) \\frac{1}{3} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix} = \\frac{3c-2s}{9} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix}$。\n        - 所以 $S^{TT} = S' - \\frac{1}{2} S' P$。\n        - $S^{TT} = \\frac{1}{9} \\begin{pmatrix} 6c+s  s  -6c-2s \\\\ s  3c-8s  -3c+7s \\\\ -6c-2s  -3c+7s  9c-5s \\end{pmatrix} - \\frac{1}{9} \\begin{pmatrix} 2(3c-2s)  -(3c-2s)  -(3c-2s) \\\\ -(3c-2s)  2(3c-2s)  -(3c-2s) \\\\ -(3c-2s)  -(3c-2s)  2(3c-2s) \\end{pmatrix}$\n        - $S^{TT} = \\frac{1}{9} \\begin{pmatrix} (6c+s) - (6c-4s)  s - (-3c+2s)  (-6c-2s) - (-3c+2s) \\\\ s - (-3c+2s)  (3c-8s) - (6c-4s)  (-3c+7s) - (-3c+2s) \\\\ (-6c-2s) - (-3c+2s)  (-3c+7s) - (-3c+2s)  (9c-5s) - (6c-4s) \\end{pmatrix}$\n        - 让我们计算分量。\n        - $(S^{TT})_{11} = \\frac{1}{9} (5s)$\n        - $(S^{TT})_{12} = \\frac{1}{9} (s+3c-2s) = \\frac{1}{9} (3c-s)$\n        - $(S^{TT})_{13} = \\frac{1}{9} (-6c-2s+3c-2s) = \\frac{1}{9}(-3c-4s)$\n        - $(S^{TT})_{21} = (S^{TT})_{12} = \\frac{1}{9}(3c-s)$。很好，对称性成立。\n        - $(S^{TT})_{22} = \\frac{1}{9} (3c-8s - 6c+4s) = \\frac{1}{9} (-3c-4s)$\n        - $(S^{TT})_{23} = \\frac{1}{9} (-3c+7s+3c-2s) = \\frac{1}{9}(5s)$\n        - $(S^{TT})_{31} = (S^{TT})_{13} = \\frac{1}{9}(-3c-4s)$。很好。\n        - $(S^{TT})_{32} = \\frac{1}{9}(-3c+7s - (-3c+2s)) = \\frac{1}{9}(-3c+7s+3c-2s) = \\frac{1}{9}(5s)$。\n        - $(S^{TT})_{33} = \\frac{1}{9} (9c-5s - 6c+4s) = \\frac{1}{9} (3c-s)$。\n        \n        所以得到的矩阵是：\n        $$ S^{TT} = \\frac{1}{9} \\begin{pmatrix} 5s  3c-s  -3c-4s \\\\ 3c-s  -3c-4s  5s \\\\ -3c-4s  5s  3c-s \\end{pmatrix} $$\n        我来复核一下对称性。$S^{TT}_{12}=S^{TT}_{21}$，$S^{TT}_{13}=S^{TT}_{31}$，$S^{TT}_{23}=S^{TT}_{32}$。\n        该矩阵是对称的。\n        \n- **对 $S^{TT}$ 的最终检查：**\n    - **1. 无迹条件：** $\\mathrm{Tr}(S^{TT}) = 0$?\n      $\\mathrm{Tr}(S^{TT}) = \\frac{1}{9}[ (5s) + (-3c-4s) + (3c-s) ] = \\frac{1}{9}[ 5s - 3c - 4s + 3c - s ] = \\frac{1}{9}[ (5-4-1)s + (-3+3)c ] = \\frac{1}{9}[0] = 0$。\n      无迹条件成立。这是一个非常重要的检查。\n    - **2. 横向条件：** $\\hat{n}_i S^{TT}_{ij} = 0$?\n      这等价于检查每列（或行）的分量之和是否为零，因为 $\\hat{n} = \\frac{1}{\\sqrt{3}}(1,1,1)$。\n      让我们检查第一列（乘以 $\\frac{1}{9}$）：\n      $ (5s) + (3c-s) + (-3c-4s) = 5s+3c-s-3c-4s = (5-1-4)s + (3-3)c = 0$。\n      第一列是横向的。\n      让我们检查第二列：\n      $ (3c-s) + (-3c-4s) + (5s) = 3c-s-3c-4s+5s = (-1-4+5)s + (3-3)c = 0$。\n      第二列是横向的。\n      由于对称性，我们只需要再检查一个。让我们检查第三列：\n      $ (-3c-4s) + (5s) + (3c-s) = -3c-4s+5s+3c-s = (-4+5-1)s + (-3+3)c = 0$。\n      第三列是横向的。\n      所以横向条件也成立。\n      我的计算似乎是正确的。\n`",
            "answer": "$$ \\boxed{ \\frac{1}{9} \\begin{pmatrix} 5\\sin(\\Omega t)  3\\cos(\\Omega t)-\\sin(\\Omega t)  -3\\cos(\\Omega t)-4\\sin(\\Omega t) \\\\ 3\\cos(\\Omega t)-\\sin(\\Omega t)  -3\\cos(\\Omega t)-4\\sin(\\Omega t)  5\\sin(\\Omega t) \\\\ -3\\cos(\\Omega t)-4\\sin(\\Omega t)  5\\sin(\\Omega t)  3\\cos(\\Omega t)-\\sin(\\Omega t) \\end{pmatrix} } $$"
        },
        {
            "introduction": "将理论从解析计算过渡到数值模拟。在此实践中，你将编写程序在一个离散的数值网格上构建一个引力平面波，并验证其是否满足基本的横向无迹（TT）条件。这是数值相对论中的一项基础练习，旨在确保解析波解能够在离散的计算域中被正确表示。",
            "id": "3476511",
            "problem": "考虑弱场引力波，其在平直背景上表现为一个小度规微扰 $h_{\\mu\\nu}$，其中 $|h_{\\mu\\nu}| \\ll 1$。在横向无迹 (TT) 规范中，已知真空平面波解的空间分量 $h_{ij}^{\\mathrm{TT}}$ 是无散（横向）和无迹的。空间张量场 $h_{ij}^{\\mathrm{TT}}(t,\\mathbf{x})$ 的横向性和无迹性条件分别为 $\\partial_i h_{ij}^{\\mathrm{TT}}(t,\\mathbf{x}) = 0$ 和 $h_{ii}^{\\mathrm{TT}}(t,\\mathbf{x}) = 0$，其中重复指标表示对 $i = 1,2,3$ 求和。\n\n您的任务是为一组平面波测试用例在三维笛卡尔网格上实现这些条件的数值验证。每个测试用例定义了：一个立方空间域、一个离散网格、一个单位传播方向向量、一个固定观测时间、一个角频率以及两种正交偏振模式的振幅。构建一个与横向无迹 (TT) 规范一致的平面波场 $h_{ij}^{\\mathrm{TT}}$，并数值验证散度 $\\partial_i h_{ij}^{\\mathrm{TT}}$ 和迹 $h_{ii}^{\\mathrm{TT}}$ 在整个网格上一致地处于给定的容差范围内。\n\n使用以下基本原理：\n- 在弱场极限下，线性化的爱因斯坦方程意味着，在真空中，度规微扰满足波动方程，并且横向无迹 (TT) 规范施加了 $\\partial_i h_{ij}^{\\mathrm{TT}} = 0$ 和 $h_{ii}^{\\mathrm{TT}} = 0$。\n- 角频率为 $\\omega$、波矢为 $\\mathbf{k} = k\\,\\hat{\\mathbf{n}}$ 的平面波沿着单位向量 $\\hat{\\mathbf{n}}$ 传播，其中 $k = \\omega/c$，$c$ 为光速。\n- 场 $h_{ij}^{\\mathrm{TT}}$ 是无量纲的。空间坐标以 $\\mathrm{m}$ 为单位，时间以 $\\mathrm{s}$ 为单位，频率以 $\\mathrm{rad/s}$ 为单位，三角函数中使用的角度必须是弧度。使用 $c = 2.99792458\\times 10^8\\,\\mathrm{m/s}$。\n\n数值方法要求：\n- 将域离散化为均匀网格，在每个方向上有 $N_x$、$N_y$、$N_z$ 个点，范围长度分别为 $L_x$、$L_y$、$L_z$ (单位：$\\mathrm{m}$)。设间距为 $dx = L_x/(N_x-1)$、$dy = L_y/(N_y-1)$、$dz = L_z/(N_z-1)$。\n- 在内部使用至少二阶精度的有限差分来数值计算偏导数。边界处理可以使用一阶或二阶的单边差分，前提是全局最大范数是在整个网格上进行评估。\n- 对于每个测试用例，评估所有网格点和指标上的最大绝对值 $\\max_{\\mathbf{x},j}|\\partial_i h_{ij}^{\\mathrm{TT}}|$ 和 $\\max_{\\mathbf{x}}|h_{ii}^{\\mathrm{TT}}|$，并与容差 $\\varepsilon$ 进行比较。\n\n测试套件：\n实现以下四个测试用例。对于每个用例，使用指定的参数构建一个与横向无迹 (TT) 规范一致的平面波，并验证这些条件。为每个测试用例报告一个布尔结果，指示横向性和无迹性是否都在整个域的容差范围内得到满足。\n\n- 测试用例 1：\n    - 域：$L_x = L_y = L_z = 10000\\,\\mathrm{m}$，网格：$N_x = N_y = N_z = 33$。\n    - 传播方向：$\\hat{\\mathbf{n}} = (0,0,1)$。\n    - 角频率：$\\omega = 2\\pi\\times 100\\,\\mathrm{rad/s}$。\n    - 偏振振幅：$A_{+} = 1\\times 10^{-21}$，$A_{\\times} = 0$。\n    - 时间：$t = 0\\,\\mathrm{s}$。\n    - 容差：$\\varepsilon = 1\\times 10^{-18}$。\n\n- 测试用例 2：\n    - 域：$L_x = L_y = L_z = 20000\\,\\mathrm{m}$，网格：$N_x = N_y = N_z = 41$。\n    - 传播方向：$\\hat{\\mathbf{n}} = (1,1,1)/\\sqrt{3}$。\n    - 角频率：$\\omega = 2\\pi\\times 50\\,\\mathrm{rad/s}$。\n    - 偏振振幅：$A_{+} = 0$，$A_{\\times} = 2\\times 10^{-21}$。\n    - 时间：$t = 0\\,\\mathrm{s}$。\n    - 容差：$\\varepsilon = 1\\times 10^{-18}$。\n\n- 测试用例 3：\n    - 域：$L_x = L_y = L_z = 5000\\,\\mathrm{m}$，网格：$N_x = N_y = N_z = 21$。\n    - 传播方向：$\\hat{\\mathbf{n}} = (0,1,0)$。\n    - 角频率：$\\omega = 2\\pi\\times 1000\\,\\mathrm{rad/s}$。\n    - 偏振振幅：$A_{+} = 1\\times 10^{-21}$，$A_{\\times} = 3\\times 10^{-21}$。\n    - 时间：$t = 1\\times 10^{-2}\\,\\mathrm{s}$。\n    - 容差：$\\varepsilon = 1\\times 10^{-18}$。\n\n- 测试用例 4：\n    - 域：$L_x = L_y = L_z = 1000\\,\\mathrm{m}$，网格：$N_x = N_y = N_z = 9$。\n    - 传播方向：$\\hat{\\mathbf{n}} = (0,0,1)$。\n    - 角频率：$\\omega = 2\\pi\\times 200\\,\\mathrm{rad/s}$。\n    - 偏振振幅：$A_{+} = 2\\times 10^{-21}$，$A_{\\times} = 1\\times 10^{-21}$。\n    - 时间：$t = 5\\times 10^{-3}\\,\\mathrm{s}$。\n    - 容差：$\\varepsilon = 1\\times 10^{-16}$。\n\n实现细节：\n- 构建垂直于 $\\hat{\\mathbf{n}}$ 的标准正交偏振基矢 $\\hat{\\mathbf{e}}_{1}$ 和 $\\hat{\\mathbf{e}}_{2}$，并使用它们来构建一个具有两个正交模式及振幅 $A_{+}$ 和 $A_{\\times}$ 的横向无迹 (TT) 偏振张量。\n- 形成一个与横向无迹 (TT) 规范一致并沿 $\\hat{\\mathbf{n}}$ 传播的平面波 $h_{ij}^{\\mathrm{TT}}(t,\\mathbf{x})$，其相位取决于 $\\omega$、$t$ 和 $\\mathbf{k}\\cdot\\mathbf{x}$，其中 $\\mathbf{k} = (\\omega/c)\\,\\hat{\\mathbf{n}}$。\n- 通过有限差分数值计算 $\\partial_i h_{ij}^{\\mathrm{TT}}$，并直接从场中计算 $h_{ii}^{\\mathrm{TT}}$。\n\n输出规格：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_m$ 是一个布尔值，指示对于测试用例 $m$，条件 $\\partial_i h_{ij}^{\\mathrm{TT}} = 0$ 和 $h_{ii}^{\\mathrm{TT}} = 0$ 是否在整个网格上的指定容差范围内都得到满足。",
            "solution": "该问题是有效的，因为它在科学上基于广义相对论理论，是良定的，并为数值验证任务提供了一套完整且一致的参数。该任务涉及为弱场度规微扰构建一个在横向无迹 (TT) 规范下的平面波解，并在离散网格上数值验证其定义属性。\n\n解决方案主要分两步进行：首先，引力波场 $h_{ij}^{\\mathrm{TT}}(t,\\mathbf{x})$ 的解析构造；其次，在离散网格上验证其属性的数值程序。\n\n在真空中传播的平面引力波由对平直闵可夫斯基度规 $\\eta_{\\mu\\nu}$ 的微扰 $h_{\\mu\\nu}$ 来描述。在 TT 规范中，此微扰的空间部分 $h_{ij}^{\\mathrm{TT}}$ 是真空波动方程的一个解。对于角频率为 $\\omega$、波矢为 $\\mathbf{k}$ 的单色平面波，解可以写为：\n$$\nh_{ij}^{\\mathrm{TT}}(t, \\mathbf{x}) = \\mathcal{A}_{ij} \\cos(\\phi) = \\mathcal{A}_{ij} \\cos(\\mathbf{k} \\cdot \\mathbf{x} - \\omega t)\n$$\n其中 $\\phi = \\mathbf{k} \\cdot \\mathbf{x} - \\omega t$ 是相位。波矢由 $\\mathbf{k} = (\\omega/c) \\hat{\\mathbf{n}}$ 给出，其中 $\\hat{\\mathbf{n}}$ 是传播方向上的单位向量，$c = 2.99792458 \\times 10^8 \\, \\mathrm{m/s}$ 是光速。振幅张量 $\\mathcal{A}_{ij}$ 是恒定的，并封装了偏振信息。\n\nTT 规范对空间张量 $h_{ij}^{\\mathrm{TT}}$ 施加了两个条件：\n1.  **无迹性**：张量的迹为零，$h_{ii}^{\\mathrm{TT}} = 0$（对 $i=1,2,3$ 求和）。\n2.  **横向性**：张量垂直于传播方向，对于平面波而言，这意味着 $k_i h_{ij}^{\\mathrm{TT}} = 0$。这等价于无散度条件 $\\partial_i h_{ij}^{\\mathrm{TT}} = 0$，可以通过应用链式法则看出：$\\partial_i h_{ij}^{\\mathrm{TT}} = \\mathcal{A}_{ij} (-\\sin(\\phi)) (\\partial_i \\phi) = -k_i \\mathcal{A}_{ij} \\sin(\\phi)$。\n\n为了满足这些条件，振幅張量 $\\mathcal{A}_{ij}$ 由两个基偏振张量 $\\epsilon_{ij}^{+}$ 和 $\\epsilon_{ij}^{\\times}$ 的线性组合构成：\n$$\n\\mathcal{A}_{ij} = A_{+} \\epsilon_{ij}^{+} + A_{\\times} \\epsilon_{ij}^{\\times}\n$$\n其中 $A_{+}$ 和 $A_{\\times}$ 分别是“plus”（正）和“cross”（交叉）偏振模式的振幅。\n\n偏振张量由垂直于传播方向 $\\hat{\\mathbf{n}}$ 的平面中的一个标准正交基 $\\{\\hat{\\mathbf{e}}_1, \\hat{\\mathbf{e}}_2\\}$ 构建。\n$$\n\\epsilon_{ij}^{+} = (\\hat{e}_1)_i (\\hat{e}_1)_j - (\\hat{e}_2)_i (\\hat{e}_2)_j\n$$\n$$\n\\epsilon_{ij}^{\\times} = (\\hat{e}_1)_i (\\hat{e}_2)_j + (\\hat{e}_2)_i (\\hat{e}_1)_j\n$$\n对于任何给定的 $\\hat{\\mathbf{n}}$，都可以构建这个基。一个稳健的方法是选择一个固定的、非共线的向量，例如 $\\mathbf{v} = (0,0,1)$（如果 $\\hat{\\mathbf{n}}$ 与 $(0,0,1)$ 平行，则选择 $\\mathbf{v}=(1,0,0)$），然后使用格拉姆-施密特正交化过程或叉积。一个可靠的构造方法是：\n1.  选择一个不平行于 $\\hat{\\mathbf{n}}$ 的向量 $\\mathbf{v}$。\n2.  定义 $\\hat{\\mathbf{e}}_2 = \\frac{\\hat{\\mathbf{n}} \\times \\mathbf{v}}{|\\hat{\\mathbf{n}} \\times \\mathbf{v}|}$。\n3.  定义 $\\hat{\\mathbf{e}}_1 = \\hat{\\mathbf{e}}_2 \\times \\hat{\\mathbf{n}}$。\n所得集合 $\\{\\hat{\\mathbf{e}}_1, \\hat{\\mathbf{e}}_2, \\hat{\\mathbf{n}}\\}$ 形成一个右手标准正交基。\n\n根据构造，$\\epsilon_{ij}^{+}$ 和 $\\epsilon_{ij}^{\\times}$ 都是无迹且横向于 $\\mathbf{k}$ 的，这确保了 $h_{ij}^{\\mathrm{TT}}$ 解析地满足 TT 规范条件。\n\n对于数值验证，空间域被离散化为一个均匀的笛卡尔网格，维度为 $N_x \\times N_y \\times N_z$，间距为 $dx$、$dy$、$dz$。在固定的时间 $t$，对每个网格点评估场 $h_{ij}^{\\mathrm{TT}}(t, \\mathbf{x})$。\n\n**无迹性验证：**\n在每个网格点计算迹 $T(\\mathbf{x}) = h_{ii}^{\\mathrm{TT}}(\\mathbf{x}) = h_{11}^{\\mathrm{TT}}(\\mathbf{x}) + h_{22}^{\\mathrm{TT}}(\\mathbf{x}) + h_{33}^{\\mathrm{TT}}(\\mathbf{x})$。找出整个网格上迹的最大绝对值：\n$$\n\\text{err}_{\\text{trace}} = \\max_{\\mathbf{x}} |T(\\mathbf{x})|\n$$\n将此值与容差 $\\varepsilon$ 进行比较。解析上，迹为零。数值上，此误差应在机器浮点精度的数量级。\n\n**横向性验证：**\n对每个分量 $j \\in \\{1,2,3\\}$ 计算散度向量 $D_j(\\mathbf{x}) = \\partial_i h_{ij}^{\\mathrm{TT}}(\\mathbf{x})$。这需要数值微分。我们在网格内部使用二阶精度的有限差分，在边界上使用一阶精度，如 `numpy.gradient` 中所实现的。对于每个网格点 $\\mathbf{x}$，散度的三个分量是：\n$$\nD_1(\\mathbf{x}) = \\partial_1 h_{11}^{\\mathrm{TT}} + \\partial_2 h_{21}^{\\mathrm{TT}} + \\partial_3 h_{31}^{\\mathrm{TT}}\n$$\n$$\nD_2(\\mathbf{x}) = \\partial_1 h_{12}^{\\mathrm{TT}} + \\partial_2 h_{22}^{\\mathrm{TT}} + \\partial_3 h_{32}^{\\mathrm{TT}}\n$$\n$$\nD_3(\\mathbf{x}) = \\partial_1 h_{13}^{\\mathrm{TT}} + \\partial_2 h_{23}^{\\mathrm{TT}} + \\partial_3 h_{33}^{\\mathrm{TT}}\n$$\n找出整个网格和所有三个分量上散度的最大绝对值：\n$$\n\\text{err}_{\\text{div}} = \\max_{\\mathbf{x}, j} |D_j(\\mathbf{x})|\n$$\n这个误差源于微分算子的离散化，将它与容差 $\\varepsilon$ 进行比较。\n\n对于每个测试用例，当且仅当 $\\text{err}_{\\text{trace}} \\le \\varepsilon$ 和 $\\text{err}_{\\text{div}} \\le \\varepsilon$ 这两个条件都满足时，最终结果为 `True`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"domain\": (10000.0, 10000.0, 10000.0),\n            \"grid_size\": (33, 33, 33),\n            \"n_hat\": np.array([0.0, 0.0, 1.0]),\n            \"omega\": 2.0 * np.pi * 100.0,\n            \"A_plus\": 1e-21,\n            \"A_cross\": 0.0,\n            \"time\": 0.0,\n            \"tolerance\": 1e-18,\n        },\n        # Test case 2\n        {\n            \"domain\": (20000.0, 20000.0, 20000.0),\n            \"grid_size\": (41, 41, 41),\n            \"n_hat\": np.array([1.0, 1.0, 1.0]) / np.sqrt(3),\n            \"omega\": 2.0 * np.pi * 50.0,\n            \"A_plus\": 0.0,\n            \"A_cross\": 2e-21,\n            \"time\": 0.0,\n            \"tolerance\": 1e-18,\n        },\n        # Test case 3\n        {\n            \"domain\": (5000.0, 5000.0, 5000.0),\n            \"grid_size\": (21, 21, 21),\n            \"n_hat\": np.array([0.0, 1.0, 0.0]),\n            \"omega\": 2.0 * np.pi * 1000.0,\n            \"A_plus\": 1e-21,\n            \"A_cross\": 3e-21,\n            \"time\": 1e-2,\n            \"tolerance\": 1e-18,\n        },\n        # Test case 4\n        {\n            \"domain\": (1000.0, 1000.0, 1000.0),\n            \"grid_size\": (9, 9, 9),\n            \"n_hat\": np.array([0.0, 0.0, 1.0]),\n            \"omega\": 2.0 * np.pi * 200.0,\n            \"A_plus\": 2e-21,\n            \"A_cross\": 1e-21,\n            \"time\": 5e-3,\n            \"tolerance\": 1e-16,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_tt_conditions(**case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef verify_tt_conditions(domain, grid_size, n_hat, omega, A_plus, A_cross, time, tolerance):\n    \"\"\"\n    Constructs a TT-gauge plane wave and verifies its properties numerically.\n\n    Args:\n        domain (tuple): A tuple (Lx, Ly, Lz) of domain lengths in meters.\n        grid_size (tuple): A tuple (Nx, Ny, Nz) of grid points.\n        n_hat (np.ndarray): A 3D unit vector for the propagation direction.\n        omega (float): Angular frequency in rad/s.\n        A_plus (float): Amplitude of the plus polarization.\n        A_cross (float): Amplitude of the cross polarization.\n        time (float): Observation time in seconds.\n        tolerance (float): Error tolerance for verification.\n\n    Returns:\n        bool: True if both conditions are met, False otherwise.\n    \"\"\"\n    c = 2.99792458e8  # Speed of light in m/s\n    Lx, Ly, Lz = domain\n    Nx, Ny, Nz = grid_size\n\n    # 1. Construct polarization basis vectors e1, e2 orthogonal to n_hat\n    v = np.array([0.0, 0.0, 1.0])\n    # If n_hat is parallel to v, choose a different v\n    if np.allclose(np.abs(np.dot(n_hat, v)), 1.0):\n        v = np.array([1.0, 0.0, 0.0])\n    \n    e2 = np.cross(n_hat, v)\n    e2 /= np.linalg.norm(e2)\n    e1 = np.cross(e2, n_hat)\n\n    # 2. Construct polarization tensors\n    eps_plus = np.outer(e1, e1) - np.outer(e2, e2)\n    eps_cross = np.outer(e1, e2) + np.outer(e2, e1)\n\n    # 3. Set up the grid and wave vector\n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    z = np.linspace(0, Lz, Nz)\n    xx, yy, zz = np.meshgrid(x, y, z, indexing='ij')\n\n    k_vec = (omega / c) * n_hat\n\n    # 4. Construct the h_ij field\n    phase = k_vec[0] * xx + k_vec[1] * yy + k_vec[2] * zz - omega * time\n    \n    # h_field shape: (Nx, Ny, Nz, 3, 3)\n    amplitude_tensor = A_plus * eps_plus + A_cross * eps_cross\n    h_field = amplitude_tensor[np.newaxis, np.newaxis, np.newaxis, :, :] * np.cos(phase)[..., np.newaxis, np.newaxis]\n\n    # 5. Verify tracelessness\n    trace_h = np.einsum('...ii->...', h_field)\n    max_trace_error = np.max(np.abs(trace_h))\n\n    # 6. Verify transversality (divergence-free)\n    dx = Lx / (Nx - 1) if Nx > 1 else 1.0\n    dy = Ly / (Ny - 1) if Ny > 1 else 1.0\n    dz = Lz / (Nz - 1) if Nz > 1 else 1.0\n    \n    # Calculate gradients of h field w.r.t. spatial coordinates\n    # np.gradient returns a list of arrays: [grad_x(h_ij), grad_y(h_ij), grad_z(h_ij)]\n    # axis=(0,1,2) corresponds to x,y,z grid axes\n    # The output is a list of arrays, which we stack into a single array for einsum\n    # grad_h_list has shape (3, Nx, Ny, Nz, 3, 3)\n    # The first '3' corresponds to the derivative direction (d/dx, d/dy, d/dz)\n    grad_h_list = np.stack(np.gradient(h_field, dx, dy, dz, axis=(0, 1, 2)), axis=0)\n\n    # Compute divergence D_j = sum_i(d/dx_i h_ij)\n    # einsum contracts the derivative index with the first tensor index\n    # 'i...ij->...j'\n    # i: derivative direction (0,1,2 for x,y,z) and first tensor index\n    # ...: grid dimensions (Nx, Ny, Nz)\n    # j: second tensor index\n    # The result `div_h` has shape (Nx, Ny, Nz, 3)\n    div_h = np.einsum('i...ij->...j', grad_h_list)\n    max_div_error = np.max(np.abs(div_h))\n\n    # 7. Final check\n    is_valid = (max_trace_error = tolerance) and (max_div_error = tolerance)\n    return is_valid\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "在之前数值验证的基础上，我们更进一步，从检验一个已知解升级为从源头生成一个新解。本练习将线性化爱因斯坦方程作为一个非齐次波动方程来处理，模拟动态物质源如何辐射引力波。你将运用“线方法”（Method of Lines）来演化波场，并对照由格林函数法推导出的精确解来检验数值结果的准确性，这一过程本身就是理论与计算物理结合的典范。",
            "id": "3476546",
            "problem": "考虑平直时空上洛伦兹规范 (Lorenz gauge) 下的弱场线性化爱因斯坦方程，对于迹反转度规微扰 $\\bar{h}_{\\mu\\nu}$，该方程可简化为非齐次波动方程\n$$\n\\Box \\bar{h}_{\\mu\\nu} = -16\\pi T_{\\mu\\nu},\n$$\n其中 $\\Box = -\\partial_t^2 + \\nabla^2$，单位制为光速 $c=1$ 且牛顿常数 $G=1$。将注意力限制在单个笛卡尔分量上，省略索引，并简化到一维空间，以获得由以下方程控制的标量场\n$$\n\\partial_t^2 h(x,t) - \\partial_x^2 h(x,t) = -16\\pi\\, T(x,t),\n$$\n其初始数据为零，即 $h(x,0)=0$ 和 $\\partial_t h(x,0)=0$。在长度为 $L$ 的有限区间上采用周期性边界条件，并选择最终报告时间 $t_f$，以确保源的依赖域完全位于计算区间内，即在 $t_f$ 之前没有信号环绕边界。在几何单位制下工作，其中所有量均为无量纲。\n\n任务：使用四阶精度的显式龙格-库塔 (Runge–Kutta, RK) 积分器进行时间积分，并使用四阶精度的中心有限差分近似空间二阶导数，来实现线方法 (Method of Lines, MoL)。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件 $\\Delta t \\leq \\lambda\\, \\Delta x$ 设定，其中 $\\lambda$ 是一个指定值，$\\Delta x=L/(N_x-1)$，$N_x$ 是空间网格点的数量。源项是在空间和时间上平滑的高斯函数，\n$$\nT(x,t) = A\\, \\exp\\!\\left(-\\frac{(x-x_0)^2}{2\\sigma_x^2}\\right)\\, \\exp\\!\\left(-\\frac{(t-t_0)^2}{2\\sigma_t^2}\\right),\n$$\n其参数为 $A$、$x_0$、$\\sigma_x$、$t_0$ 和 $\\sigma_t$。\n\n为了进行验证，通过与一维波动算子（具有零初始数据）的推迟格林函数 (retarded Green’s function) 进行卷积，计算在时间 $t_f$ 的精确解。该格林函数定义为满足以下条件的分布 $G_{\\text{ret}}(x,t)$\n$$\n(\\partial_t^2 - \\partial_x^2) G_{\\text{ret}}(x,t) = \\delta(t)\\,\\delta(x), \\quad G_{\\text{ret}}(x,t)=0 \\ \\text{for } t0,\n$$\n并用它来构造精确解\n$$\nh_{\\text{exact}}(x,t_f) = -16\\pi \\int_{0}^{t_f}\\!\\!\\int_{-\\infty}^{\\infty} G_{\\text{ret}}(x - \\xi, t_f - \\tau)\\, T(\\xi,\\tau)\\, d\\xi\\, d\\tau.\n$$\n将 $h_{\\text{exact}}(x,t_f)$ 表示为一种数值上易于处理的形式，并使用高精度数值积分法对其进行求值。然后，对于每个测试用例，计算在 $t_f$ 时的离散 $\\ell^2$ 误差，\n$$\n\\|e\\|_2 = \\left(\\frac{1}{N_x}\\sum_{j=0}^{N_x-1}\\left[h_{\\text{num}}(x_j,t_f) - h_{\\text{exact}}(x_j,t_f)\\right]^2\\right)^{1/2},\n$$\n其中 $h_{\\text{num}}$ 是通过您的线方法演化产生的数值解，$x_j$ 是网格点。所有输出都应以无量纲浮点数的形式提供。\n\n实现规格：\n- 空间离散化：在间距为 $\\Delta x$ 的均匀网格上，对 $\\partial_x^2 h$ 使用四阶中心有限差分。\n- 时间离散化：经典的四阶显式龙格-库塔 (RK4) 方法。\n- 稳定性：使用 $\\Delta t = t_f / N_t$ 选择 $\\Delta t$，其中 $N_t = \\lceil t_f / (\\lambda \\Delta x)\\rceil$，确保 $\\Delta t \\le \\lambda \\Delta x$。\n- 精确解求值：针对给定的高斯源 $T(x,t)$，推导一个适合高效、精确数值计算的表达式；使用高阶积分法计算剩余的积分。\n\n测试套件：\n对于以下每一组参数，演化到 $t_f$ 并报告离散 $\\ell^2$ 误差 $\\|e\\|_2$。\n\n- 情况 1（基准平滑源）：\n  - $L=100$, $N_x=513$, $\\lambda=0.4$, $t_f=10$,\n  - $A=10^{-3}$, $x_0=0$, $\\sigma_x=1.0$, $t_0=3.0$, $\\sigma_t=0.5$.\n\n- 情况 2（窄时间高斯源，更具挑战性）：\n  - $L=100$, $N_x=513$, $\\lambda=0.4$, $t_f=10$,\n  - $A=10^{-3}$, $x_0=0$, $\\sigma_x=1.0$, $t_0=1.0$, $\\sigma_t=0.1$.\n\n- 情况 3（宽空间和时间高斯源）：\n  - $L=100$, $N_x=513$, $\\lambda=0.4$, $t_f=10$,\n  - $A=10^{-3}$, $x_0=0$, $\\sigma_x=5.0$, $t_0=2.5$, $\\sigma_t=1.5$.\n\n- 情况 4（零源，一致性检查）：\n  - $L=100$, $N_x=513$, $\\lambda=0.4$, $t_f=10$,\n  - $A=0.0$, $x_0=0$, $\\sigma_x=1.0$, $t_0=2.0$, $\\sigma_t=0.5$.\n\n最终输出要求：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序与测试套件相同（例如 $[e_1,e_2,e_3,e_4]$），其中每个 $e_k$ 是为情况 $k$ 计算的离散 $\\ell^2$ 误差。不要打印任何其他文本。",
            "solution": "该问题要求对带源项的一维标量波动方程进行数值求解，该方程源自爱因斯坦方程的弱场近似。数值解将使用线方法 (Method of Lines, MoL) 获得，并与精确解析解的高精度计算结果进行比较，以计算数值误差。\n\n控制偏微分方程 (PDE) 为：\n$$\n\\partial_t^2 h(x,t) - \\partial_x^2 h(x,t) = S(x,t)\n$$\n其中源项为 $S(x,t) = -16\\pi\\, T(x,t)$。该问题设定在长度为 $L$ 的空间域上，采用周期性边界条件，并满足零初始数据：$h(x,0)=0$ 和 $\\partial_t h(x,0)=0$。\n\n### 数值解：线方法\n\n线方法 (MoL) 是一种求解瞬态偏微分方程的程序，它首先对空间导数进行离散化，将偏微分方程转换为一个大型常微分方程 (ODE) 组，然后使用标准数值积分器对该 ODE 系统进行时间上的前向积分。\n\n**1. 一阶方程组**\n\n为了应用标准的 ODE 求解器，我们首先将二阶波动方程简化为一个由两个一阶方程组成的系统。我们定义一个辅助场 $\\Pi(x,t) = \\partial_t h(x,t)$。该系统变为：\n$$\n\\partial_t h(x,t) = \\Pi(x,t) \\\\\n\\partial_t \\Pi(x,t) = \\partial_x^2 h(x,t) + S(x,t)\n$$\n初始条件现在是 $h(x,0)=0$ 和 $\\Pi(x,0)=0$。\n\n**2. 空间离散化**\n\n我们引入一个包含 $N_x$ 个点的均匀空间网格，记为 $x_j$，其中 $j=0, 1, \\dots, N_x-1$。根据问题说明，域取为 $[-L/2, L/2]$，网格点为 $x_j = -L/2 + j \\Delta x$，空间步长为 $\\Delta x = L/(N_x-1)$。场 $h(x,t)$ 和 $\\Pi(x,t)$ 由它们在网格点上的值组成的向量表示，即 $\\mathbf{h}(t) = [h(x_0,t), \\dots, h(x_{N_x-1}, t)]^T$ 和 $\\mathbf{\\Pi}(t) = [\\Pi(x_0,t), \\dots, \\Pi(x_{N_x-1}, t)]^T$。\n\n空间二阶导数 $\\partial_x^2 h$ 使用四阶精度的中心有限差分格式进行近似：\n$$\n\\frac{\\partial^2 h}{\\partial x^2}\\bigg|_{x_j} \\approx \\frac{-\\frac{1}{12}h_{j-2} + \\frac{4}{3}h_{j-1} - \\frac{5}{2}h_j + \\frac{4}{3}h_{j+1} - \\frac{1}{12}h_{j+2}}{(\\Delta x)^2}\n$$\n其中 $h_j = h(x_j, t)$。通过对索引取模 $N_x$ 来施加周期性边界条件。这种离散化将 PDE 系统转换为一个包含 $2N_x$ 个 ODE 的半离散系统：\n$$\n\\frac{d\\mathbf{h}}{dt} = \\mathbf{\\Pi} \\\\\n\\frac{d\\mathbf{\\Pi}}{dt} = \\mathbf{D_2h} + \\mathbf{S}(t)\n$$\n其中 $\\mathbf{D_2}$ 是有限差分算子的矩阵表示，$\\mathbf{S}(t)$ 是在网格点上计算的源项。\n\n**3. 时间离散化**\n\n该 ODE 系统使用经典的四阶龙格-库塔 (RK4) 方法进行时间积分。设状态向量为 $\\mathbf{y}(t) = [\\mathbf{h}(t)^T, \\mathbf{\\Pi}(t)^T]^T$。ODE 系统的形式为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}(t, \\mathbf{y})$。RK4 算法将解从时间 $t_n$推进到 $t_{n+1} = t_n + \\Delta t$ 的过程如下：\n$$\n\\begin{align*}\n\\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{F}(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2}) \\\\\n\\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{F}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2}) \\\\\n\\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{F}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n$$\n选择时间步长 $\\Delta t$ 以满足波动方程的 Courant–Friedrichs–Lewy (CFL) 稳定性条件 $\\Delta t \\le \\lambda \\Delta x$，其中 $\\lambda$ 是指定的 CFL 因子。我们设置 $N_t = \\lceil t_f / (\\lambda \\Delta x)\\rceil$ 并使用恒定的时间步长 $\\Delta t = t_f / N_t$。\n\n### 用于验证的精确解\n\n对于具有零初始数据的非齐次波动方程，其精确解由源项与推迟格林函数 $G_{\\text{ret}}(x,t)$ 的卷积给出：\n$$\nh_{\\text{exact}}(x,t_f) = \\int_0^{t_f} d\\tau \\int_{-\\infty}^{\\infty} d\\xi \\, G_{\\text{ret}}(x-\\xi, t_f-\\tau) \\, S(\\xi, \\tau)\n$$\n一维波动算子 $(\\partial_t^2-\\partial_x^2)$ 的推迟格林函数是 $G_{\\text{ret}}(x,t) = \\frac{1}{2}H(t-|x|)$，其中 $H$ 是 Heaviside 阶跃函数。代入此式以及 $S(\\xi,\\tau) = -16\\pi T(\\xi,\\tau)$ 可得：\n$$\nh_{\\text{exact}}(x,t_f) = -16\\pi \\int_0^{t_f} d\\tau \\int_{-\\infty}^{\\infty} d\\xi \\, \\frac{1}{2}H(t_f-\\tau-|x-\\xi|) \\, T(\\xi,\\tau)\n$$\nHeaviside 函数将积分域限制在点 $(x, t_f)$ 的过去光锥内。必须满足条件 $t_f-\\tau \\ge |x-\\xi|$。这将积分简化为：\n$$\nh_{\\text{exact}}(x,t_f) = -8\\pi \\int_0^{t_f} d\\tau \\int_{x-(t_f-\\tau)}^{x+(t_f-\\tau)} d\\xi \\, T(\\xi,\\tau)\n$$\n源项为 $T(\\xi,\\tau) = A \\exp\\left(-\\frac{(\\xi-x_0)^2}{2\\sigma_x^2}\\right) \\exp\\left(-\\frac{(\\tau-t_0)^2}{2\\sigma_t^2}\\right)$。关于 $\\xi$ 的内层积分可以用误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-u^2}du$ 解析地求出：\n$$\n\\int e^{-\\frac{(\\xi-x_0)^2}{2\\sigma_x^2}} d\\xi = \\sigma_x\\sqrt{\\frac{\\pi}{2}} \\, \\text{erf}\\left(\\frac{\\xi-x_0}{\\sqrt{2}\\sigma_x}\\right)\n$$\n在 $\\xi$ 的积分上下限处求值，精确解变为：\n$$\nh_{\\text{exact}}(x,t_f) = -8\\pi A \\sigma_x \\sqrt{\\frac{\\pi}{2}} \\int_{0}^{t_f} d\\tau \\, e^{-\\frac{(\\tau-t_0)^2}{2\\sigma_t^2}} \\left[ \\text{erf}\\left(\\frac{x-x_0 + t_f-\\tau}{\\sqrt{2}\\sigma_x}\\right) - \\text{erf}\\left(\\frac{x-x_0 - (t_f-\\tau)}{\\sqrt{2}\\sigma_x}\\right) \\right]\n$$\n这个最终表达式是一个关于 $\\tau$ 的一维积分，可以使用数值积分法高精度地计算。\n\n### 误差计算\n\n在最终时间 $t_f$，将网格点 $x_j$ 上的数值解 $h_{\\text{num}}(x_j, t_f)$ 与精确解 $h_{\\text{exact}}(x_j, t_f)$ 进行比较。数值解的质量由离散 $\\ell^2$ 误差范数来量化：\n$$\n\\|e\\|_2 = \\left(\\frac{1}{N_x}\\sum_{j=0}^{N_x-1}\\left[h_{\\text{num}}(x_j,t_f) - h_{\\text{exact}}(x_j,t_f)\\right]^2\\right)^{1/2}\n$$\n此过程应用于问题陈述中指定的每个测试用例。对于 $A=0$ 的情况，数值解和精确解都恒为零，因此误差为零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import erf\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation_and_get_error(L, Nx, lam, tf, A, x0, sigma_x, t0, sigma_t):\n        \"\"\"\n        Runs a single simulation case, computes the exact solution, and returns the l2 error.\n        \"\"\"\n        # Case with zero source is trivial: solution is identically zero.\n        if A == 0.0:\n            return 0.0\n\n        # Spatial grid setup\n        # The grid is defined on [-L/2, L/2] with Nx points, including endpoints.\n        # This gives dx = L/(Nx-1), as specified.\n        x_nodes = np.linspace(-L / 2, L / 2, Nx)\n        dx = L / (Nx - 1)\n\n        # Time grid setup\n        # The time step dt is chosen based on the CFL condition.\n        dt_cfl = lam * dx\n        Nt = math.ceil(tf / dt_cfl)\n        dt = tf / Nt\n\n        # Initial state: h=0, Pi=dh/dt=0\n        h = np.zeros(Nx)\n        Pi = np.zeros(Nx)\n        \n        # Source term function\n        def source(x_grid, t):\n            spatial_part = np.exp(-(x_grid - x0)**2 / (2 * sigma_x**2))\n            temporal_part = np.exp(-(t - t0)**2 / (2 * sigma_t**2))\n            return -16 * np.pi * A * spatial_part * temporal_part\n\n        # Fourth-order centered finite-difference operator for the second derivative\n        def D2_operator(f_vec, dx_val):\n            # np.roll efficiently handles periodic boundary conditions\n            f_jm2 = np.roll(f_vec, 2)\n            f_jm1 = np.roll(f_vec, 1)\n            f_jp1 = np.roll(f_vec, -1)\n            f_jp2 = np.roll(f_vec, -2)\n            \n            # Stencil coefficients\n            c_jm2, c_jm1, c_j, c_jp1, c_jp2 = -1/12, 4/3, -5/2, 4/3, -1/12\n            \n            return (c_jm2 * f_jm2 + c_jm1 * f_jm1 + c_j * f_vec + c_jp1 * f_jp1 + c_jp2 * f_jp2) / dx_val**2\n\n        # Right-hand side of the ODE system d(y)/dt = F(t, y) where y = [h, Pi]\n        def F(t, y):\n            h_vec, Pi_vec = np.split(y, 2)\n            dh_dt = Pi_vec\n            dPi_dt = D2_operator(h_vec, dx) + source(x_nodes, t)\n            return np.concatenate((dh_dt, dPi_dt))\n\n        # --- Numerical Evolution using RK4 ---\n        y = np.concatenate((h, Pi))\n        time_points = np.linspace(0, tf, Nt + 1)\n        for i in range(Nt):\n            t = time_points[i]\n            \n            k1 = dt * F(t, y)\n            k2 = dt * F(t + dt / 2, y + k1 / 2)\n            k3 = dt * F(t + dt / 2, y + k2 / 2)\n            k4 = dt * F(t + dt, y + k3)\n            \n            y += (k1 + 2 * k2 + 2 * k3 + k4) / 6\n            \n        h_num, _ = np.split(y, 2)\n\n        # --- Exact Solution Calculation ---\n        h_exact = np.zeros(Nx)\n        \n        # Integrand for the exact solution derived from Green's function convolution\n        def integrand(tau, x, tf_val, x0_val, sx, t0_val, st):\n            term_tau = np.exp(-(tau - t0_val)**2 / (2 * st**2))\n            \n            arg_erf1 = (x - x0_val + tf_val - tau) / (np.sqrt(2) * sx)\n            arg_erf2 = (x - x0_val - (tf_val - tau)) / (np.sqrt(2) * sx)\n            \n            term_erf = erf(arg_erf1) - erf(arg_erf2)\n            \n            return term_tau * term_erf\n\n        prefactor = -8 * np.pi * A * sigma_x * np.sqrt(np.pi / 2)\n\n        for i, x_i in enumerate(x_nodes):\n            integral_val, _ = quad(integrand, 0, tf, args=(x_i, tf, x0, sigma_x, t0, sigma_t), limit=200)\n            h_exact[i] = prefactor * integral_val\n\n        # --- Discrete l2 Error Calculation ---\n        error = np.sqrt(np.mean((h_num - h_exact)**2))\n        \n        return error\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        {'L': 100, 'Nx': 513, 'lam': 0.4, 'tf': 10, 'A': 1e-3, 'x0': 0, 'sigma_x': 1.0, 't0': 3.0, 'sigma_t': 0.5},\n        {'L': 100, 'Nx': 513, 'lam': 0.4, 'tf': 10, 'A': 1e-3, 'x0': 0, 'sigma_x': 1.0, 't0': 1.0, 'sigma_t': 0.1},\n        {'L': 100, 'Nx': 513, 'lam': 0.4, 'tf': 10, 'A': 1e-3, 'x0': 0, 'sigma_x': 5.0, 't0': 2.5, 'sigma_t': 1.5},\n        {'L': 100, 'Nx': 513, 'lam': 0.4, 'tf': 10, 'A': 0.0, 'x0': 0, 'sigma_x': 1.0, 't0': 2.0, 'sigma_t': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_simulation_and_get_error(**params)\n        results.append(str(error))\n\n    # Print results in the specified single-line format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}