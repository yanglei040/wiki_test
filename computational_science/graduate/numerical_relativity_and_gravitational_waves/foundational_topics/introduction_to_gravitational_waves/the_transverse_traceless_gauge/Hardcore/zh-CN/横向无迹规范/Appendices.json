{
    "hands_on_practices": [
        {
            "introduction": "横向无迹（TT）规范是研究引力波的基石。这个练习旨在验证TT规范条件的一个基本数学属性——线性。通过证明两个TT规范扰动的和仍然满足TT规范条件，我们能更好地理解为什么引力波可以线性叠加，这是分析来自多个来源的引力波信号的基础。",
            "id": "1877334",
            "problem": "在线性化引力理论中，弱引力场由对平直时空闵可夫斯基度规 $\\eta_{\\mu\\nu}$ 的一个小微扰 $h_{\\mu\\nu}$ 来描述，使得 $g_{\\mu\\nu} = \\eta_{\\mu\\nu} + h_{\\mu\\nu}$。为了分析引力波，在横向无迹 (TT) 规范下工作很方便。在笛卡尔坐标系中，TT规范下的微扰的空间分量 $h_{ij}$ 满足两个条件：\n1.  **无迹条件：** 空间迹为零，即 $\\delta^{ij} h_{ij} = 0$，其中 $\\delta^{ij}$ 是克罗内克δ，且暗含对重复指标求和。\n2.  **横向条件：** 空间散度为零，即对每个分量 $j$，都有 $\\partial_i h_{ij} = 0$，其中 $\\partial_i$ 表示对空间坐标 $x^i$ 的偏导数。\n\n假设一个引力波探测器同时观测到两个独立的引力波。第一个波由微扰 $h^{(1)}_{ij}$ 描述，第二个波由 $h^{(2)}_{ij}$ 描述。$h^{(1)}_{ij}$ 和 $h^{(2)}_{ij}$ 各自都满足横向无迹 (TT) 规范的条件。探测器测量的总微扰是两者的线性叠加，由 $h^{(\\text{total})}_{ij} = h^{(1)}_{ij} + h^{(2)}_{ij}$ 给出。\n\n下列哪个陈述正确描述了总微扰 $h^{(\\text{total})}_{ij}$ 的性质？\n\nA. $h^{(\\text{total})}_{ij}$ 是横向的，但不能保证是无迹的。\n\nB. $h^{(\\text{total})}_{ij}$ 是无迹的，但不能保证是横向的。\n\nC. $h^{(\\text{total})}_{ij}$ 保证既是横向的也是无迹的。\n\nD. $h^{(\\text{total})}_{ij}$ 保证既不是横向的也不是无迹的。\n\nE. $h^{(\\text{total})}_{ij}$ 是否是横向的或无迹的，取决于两个原始波的相对相位和振幅，通常无法确定。",
            "solution": "问题要求我们确定，两个各自处于横向无迹 (TT) 规范下的度规微扰之和，是否也保持在TT规范内。设两个单独的微扰为 $h^{(1)}_{ij}$ 和 $h^{(2)}_{ij}$。总微扰是它们的和，即 $h^{(\\text{total})}_{ij} = h^{(1)}_{ij} + h^{(2)}_{ij}$。\n\n一个微扰要处于TT规范，必须满足两个条件：无迹条件和横向条件。我们将在已知 $h^{(1)}_{ij}$ 和 $h^{(2)}_{ij}$ 满足这些条件的情况下，检查 $h^{(\\text{total})}_{ij}$ 是否也满足这些条件。\n\n首先，我们来分析无迹条件。对于一个一般的微扰 $h_{ij}$，无迹条件是 $\\delta^{ij} h_{ij} = 0$。由于 $h^{(1)}_{ij}$ 和 $h^{(2)}_{ij}$ 都处于TT规范，它们都是无迹的：\n$$\n\\delta^{ij} h^{(1)}_{ij} = 0\n$$\n$$\n\\delta^{ij} h^{(2)}_{ij} = 0\n$$\n现在，我们计算总微扰 $h^{(\\text{total})}_{ij}$ 的迹：\n$$\n\\delta^{ij} h^{(\\text{total})}_{ij} = \\delta^{ij} (h^{(1)}_{ij} + h^{(2)}_{ij})\n$$\n取迹运算是一种线性运算。因此，我们可以将其分配到和式中：\n$$\n\\delta^{ij} h^{(\\text{total})}_{ij} = \\delta^{ij} h^{(1)}_{ij} + \\delta^{ij} h^{(2)}_{ij}\n$$\n利用给定的信息，即每个单独的微扰都是无迹的，我们代入它们的迹值：\n$$\n\\delta^{ij} h^{(\\text{total})}_{ij} = 0 + 0 = 0\n$$\n因此，总微扰 $h^{(\\text{total})}_{ij}$ 是无迹的。\n\n接下来，我们来分析横向条件。对于一个一般的微扰 $h_{ij}$，横向条件是 $\\partial_i h_{ij} = 0$。由于 $h^{(1)}_{ij}$ 和 $h^{(2)}_{ij}$ 都处于TT规范，它们都是横向的：\n$$\n\\partial_i h^{(1)}_{ij} = 0\n$$\n$$\n\\partial_i h^{(2)}_{ij} = 0\n$$\n现在，我们计算总微扰 $h^{(\\text{total})}_{ij}$ 的散度：\n$$\n\\partial_i h^{(\\text{total})}_{ij} = \\partial_i (h^{(1)}_{ij} + h^{(2)}_{ij})\n$$\n偏导数算符 $\\partial_i$ 是一个线性算符。这意味着和的导数等于导数的和：\n$$\n\\partial_i h^{(\\text{total})}_{ij} = \\partial_i h^{(1)}_{ij} + \\partial_i h^{(2)}_{ij}\n$$\n利用给定的信息，即每个单独的微扰都是横向的，我们代入它们的散度值：\n$$\n\\partial_i h^{(\\text{total})}_{ij} = 0 + 0 = 0\n$$\n因此，总微扰 $h^{(\\text{total})}_{ij}$ 是横向的。\n\n由于 $h^{(\\text{total})}_{ij}$ 同时满足无迹条件和横向条件，因此它保证处于TT规范中。这个结论对应于选项C。这个结果是TT规范定义条件线性的直接推论。和的性质不依赖于原始波的振幅或相位等具体细节，只取决于它们各自遵守规范条件。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在数值相对论中，从复杂的时空几何中提取物理引力波信号是一项核心任务。这项实践练习将指导您实现一个横向无迹（TT）投影算符，并用它来数值验证一个关键的理论结果：纯标量模式的度规扰动不包含任何引力波自由度。这个练习对于理解如何从数值模拟数据中分离出真实的引力波内容至关重要。",
            "id": "3496323",
            "problem": "要求您在线性化引力的背景下，为横向无迹 (TT) 规范投影实现一个数值单元测试。在三维空间中的周期性立方体区域内进行计算，并考虑一个形式为 $h_{ij} = \\partial_i \\partial_j \\phi$ 的空间度规纯标量微扰。目标是数值上证明 TT 投影能够湮灭纯标量微扰，即在足够高的分辨率下，有 $P^{\\mathrm{TT}} h_{ij} \\approx 0$，其误差在机器精度范围内。\n\n从以下基本概念出发：\n- 在闵可夫斯基背景上的线性化引力使用小的度规微扰 $h_{\\mu\\nu}$，在傅里叶空间中，可以通过亥姆霍兹分解将场分解为纵向和横向部分。\n- 横向无迹 (TT) 规范由条件 $k^i h^{\\mathrm{TT}}_{ij}(k) = 0$ (横向性) 和 $\\delta^{ij} h^{\\mathrm{TT}}_{ij}(k) = 0$ (无迹性) 定义，其中 $k^i$ 是波矢，$\\delta^{ij}$ 是克罗内克 δ 符号。\n\n您的任务是：\n1. 构建一个边长为 $L = 2\\pi$ (坐标以弧度为单位) 的三维周期性网格，其分辨率在下文的测试套件中指定。使用坐标 $x,y,z \\in [0,2\\pi)$。\n2. 定义一个平滑标量场 $\\phi(x,y,z)$，作为三角函数的叠加，\n   $$\\phi(x,y,z) = \\cos(x) + \\sin(2y) + \\cos(3z) + \\tfrac{1}{2}\\cos(x+y+2z),$$\n   其中所有角度均以弧度为单位。\n3. 通过在傅里叶空间中进行微分来以谱方法计算 $h_{ij}$，即使用快速傅里叶变换 (FFT) 获得 $\\tilde{\\phi}(\\mathbf{k})$，然后为每个波矢 $\\mathbf{k} = (k_x,k_y,k_z)$ 定义\n   $$\\tilde{h}_{ij}(\\mathbf{k}) = -k_i k_j \\tilde{\\phi}(\\mathbf{k}),$$\n4. 从基本的 TT 条件出发，推导并实现一个傅里叶空间投影算子 $P^{\\mathrm{TT}}$，该算子将任意对称张量 $\\tilde{h}_{ij}(\\mathbf{k})$ 映射到其横向无迹部分 $\\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k})$，对于每个非零的 $\\mathbf{k}$，满足 $k^i \\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k}) = 0$ 和 $\\delta^{ij}\\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k}) = 0$。一致地处理 $\\mathbf{k}=\\mathbf{0}$ 模式（不允许除以零；为此模式分配的投影为零）。\n5. 计算相对残差\n   $$\\mathcal{R} = \\frac{\\left\\| h^{\\mathrm{TT}} \\right\\|_2}{\\left\\| h \\right\\|_2},$$\n   其中 $\\left\\| \\cdot \\right\\|_2$ 表示对所有网格点和所有张量分量的欧几里得范数，而 $h^{\\mathrm{TT}}$ 是通过将 TT 投影应用于上面计算的 $h$ 得到的。您可以在实空间或傅里叶空间中计算范数，但分子和分母必须保持一致。除了指定三角函数中的角度以弧度为单位外，不需要其他物理单位。\n6. 为以下测试套件生成输出，该套件涵盖了不同的分辨率和各向异性情况：\n   - 测试用例 1 (理想情况，小型立方体网格)：$(N_x,N_y,N_z) = (32,32,32)$。\n   - 测试用例 2 (各向异性网格)：$(N_x,N_y,N_z) = (64,48,40)$。\n   - 测试用例 3 (高分辨率立方体网格)：$(N_x,N_y,N_z) = (96,96,96)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。每个结果必须是表示相应测试用例的相对残差 $\\mathcal{R}$ 的浮点数。在所有三角函数求值中，角度必须以弧度处理。",
            "solution": "该问题要求数值验证纯标量度规微扰的横向无迹 (TT) 投影为零。这是研究引力波和线性化引力中的一个基本概念。我们将首先为 TT 投影建立理论基础，然后概述计算所需残差的数值步骤。\n\n### 理论基础\n\n我们在边长为 $L=2\\pi$ 的周期性区域内的三维欧几里得空间中工作。坐标为 $(x, y, z)$。此区域上的函数 $f(\\mathbf{x})$ 可以展开为傅里叶级数，其在具有 $N_x \\times N_y \\times N_z$ 个点的网格上的离散表示可以使用快速傅里叶变换 (FFT) 来处理。\n\n空间度规微扰以纯标量模式给出：\n$h_{ij} = \\partial_i \\partial_j \\phi(x,y,z)$\n其中索引 $i, j \\in \\{1, 2, 3\\}$ 对应于空间坐标 $(x, y, z)$。标量势 $\\phi$ 由下式给出\n$$\\phi(x,y,z) = \\cos(x) + \\sin(2y) + \\cos(3z) + \\tfrac{1}{2}\\cos(x+y+2z)$$\n在傅里叶空间中，微分变成了乘以 $i$ 和波矢分量。设 $\\tilde{f}(\\mathbf{k})$ 是 $f(\\mathbf{x})$ 的傅里叶变换。$\\partial_i f$ 的傅里叶变换是 $i k_i \\tilde{f}(\\mathbf{k})$。因此，$h_{ij}$ 的傅里叶变换是：\n$$\\tilde{h}_{ij}(\\mathbf{k}) = (i k_i)(i k_j) \\tilde{\\phi}(\\mathbf{k}) = -k_i k_j \\tilde{\\phi}(\\mathbf{k})$$\n其中 $\\mathbf{k} = (k_x, k_y, k_z)$ 是波矢。在尺寸为 $2\\pi$ 的周期性区域上，$\\mathbf{k}$ 的分量是整数。\n\n横向无迹 (TT) 规范由张量 $\\tilde{h}^{\\mathrm{TT}}_{ij}$ 的两个条件定义：\n1.  **横向条件：** $k^i \\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k}) = 0$。这意味着微扰与传播方向 $\\mathbf{k}$ 正交。\n2.  **无迹条件：** $\\delta^{ij} \\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k}) = 0$。这意味着微扰张量的迹为零。\n\n为了将任意对称张量 $\\tilde{h}_{ij}$ 投影到其 TT 部分，我们构造一个投影算子。对于任何非零波矢 $\\mathbf{k}$，我们将垂直于 $\\mathbf{k}$ 的投影算子定义为：\n$$P_{ij}(\\mathbf{k}) = \\delta_{ij} - \\frac{k_i k_j}{|\\mathbf{k}|^2}, \\quad |\\mathbf{k}|^2 = k_x^2 + k_y^2 + k_z^2 \\neq 0$$\n该算子具有 $P_{ij} k_j = 0$ 的性质。一个二阶张量 $\\tilde{h}_{mn}$ 的完全横向投影是 $\\tilde{h}^{\\mathrm{T}}_{ij} = P_{im} P_{jn} \\tilde{h}_{mn}$。\n\n为了强制执行无迹条件，我们以保持横向性的方式减去 $\\tilde{h}^{\\mathrm{T}}_{ij}$ 的迹。$\\tilde{h}^{\\mathrm{T}}_{ij}$ 的迹为：\n$\\mathrm{Tr}(\\tilde{h}^{\\mathrm{T}}) = \\delta_{ij} \\tilde{h}^{\\mathrm{T}}_{ij} = \\delta_{ij} P_{im} P_{jn} \\tilde{h}_{mn} = P_{jm} P_{jn} \\tilde{h}_{mn} = P_{mn} \\tilde{h}_{mn}$\n横向投影算子本身的迹是 $\\mathrm{Tr}(P) = \\delta_{ij}P_{ij} = 3 - 1 = 2$。因此，$\\tilde{h}_{ij}$ 的 TT 部分由下式给出：\n$\\tilde{h}^{\\mathrm{TT}}_{ij} = \\tilde{h}^{\\mathrm{T}}_{ij} - \\frac{1}{2} P_{ij} \\mathrm{Tr}(\\tilde{h}^{\\mathrm{T}})$\n作用于 $\\tilde{h}_{kl}$ 的完整 TT 投影算子可以写成：\n$$\\Lambda_{ij,kl} = P_{ik}P_{jl} - \\frac{1}{2} P_{ij} P_{kl}$$\n使得 $\\tilde{h}^{\\mathrm{TT}}_{ij} = \\Lambda_{ij,kl} \\tilde{h}_{kl}$。\n\n现在，我们将此投影算子应用于我们的纯标量微扰 $\\tilde{h}_{kl} = -k_k k_l \\tilde{\\phi}$。\n让我们分析投影算子的第一项：\n$P_{ik}P_{jl}(-k_k k_l \\tilde{\\phi}) = (-\\tilde{\\phi}) (P_{ik}k_k) (P_{jl}k_l)$\n由于 $P_{ij} k_j = 0$，对于任何 $\\mathbf{k} \\neq \\mathbf{0}$，该项恒为零。\n\n接下来，让我们分析第二项：\n$$-\\frac{1}{2} P_{ij} P_{kl} (-k_k k_l \\tilde{\\phi}) = \\frac{1}{2} P_{ij} \\tilde{\\phi} (P_{kl} k_k k_l)$$\n缩并 $P_{kl}k_k k_l$ 是：\n$$P_{kl}k_k k_l = \\sum_{k,l} \\left(\\delta_{kl} - \\frac{k_k k_l}{|\\mathbf{k}|^2}\\right) k_k k_l = \\left(\\sum_m k_m^2\\right) - \\frac{1}{|\\mathbf{k}|^2} \\left(\\sum_m k_m^2\\right)\\left(\\sum_n k_n^2\\right) = |\\mathbf{k}|^2 - \\frac{|\\mathbf{k}|^4}{|\\mathbf{k}|^2} = 0$$\n对于任何 $\\mathbf{k} \\neq \\mathbf{0}$，该项也恒为零。\n\n因此，对于纯标量微扰，其 TT 投影解析上为零：对于所有 $\\mathbf{k} \\neq \\mathbf{0}$，$\\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k}) = 0$。对于 $\\mathbf{k} = \\mathbf{0}$，由于除以 $|\\mathbf{k}|^2$，投影是病态的。按照指示，我们将 $\\mathbf{k}=\\mathbf{0}$ 模式的投影定义为零。数值实现应能证明这种抵消在机器精度范围内成立。\n\n### 数值实现策略\n\n1.  **网格和波矢**：对于给定的分辨率 $(N_x, N_y, N_z)$，我们在 $[0, 2\\pi) \\times [0, 2\\pi) \\times [0, 2\\pi)$ 上构建一个三维实空间网格。相应的整数波矢 $k_x, k_y, k_z$ 使用 `numpy.fft.fftfreq` 获得。\n\n2.  **度规微扰**：我们在实空间网格上计算 $\\phi(x,y,z)$，然后计算其三维 FFT 以获得 $\\tilde{\\phi}(\\mathbf{k})$。然后使用 $\\tilde{h}_{ij} = -k_i k_j \\tilde{\\phi}$ 计算对称张量 $\\tilde{h}_{ij}(\\mathbf{k})$ 的六个独立分量。\n\n3.  **TT 投影**：对于傅里叶空间中的每个网格点（即每个 $\\mathbf{k}$），我们应用 TT 投影。\n    -   我们首先计算横向部分 $\\tilde{h}^{\\mathrm{T}}_{ij} = P_{im}P_{jn}\\tilde{h}_{mn}$。这涉及到与横向投影算子 $P_{ij}$ 的张量缩并。\n    -   接下来，我们计算这个横向张量的迹，$\\mathrm{Tr}(\\tilde{h}^{\\mathrm{T}})=P_{mn}\\tilde{h}_{mn}$。\n    -   最后，我们减去迹部分以获得 $\\tilde{h}^{\\mathrm{TT}}_{ij}$。\n    -   特殊情况 $\\mathbf{k}=\\mathbf{0}$ 的处理方法是，将 $|\\mathbf{k}|^2$ 设为 1 以避免除以零，并确保投影分量最终为 $0$，这与问题约束和物理诠释（零模代表一个常数偏移，没有横向或无迹结构）相一致。\n\n4.  **相对残差**：目标是计算相对残差 $\\mathcal{R} = \\|h^{\\mathrm{TT}}\\|_2 / \\|h\\|_2$。根据帕塞瓦尔定理，范数可以在傅里叶空间中计算。张量场 $T_{ij}$ 的 $L_2$ 范数的平方由 $\\|T\\|^2_2 \\propto \\sum_{\\mathbf{k}, i, j} |\\tilde{T}_{ij}(\\mathbf{k})|^2$ 给出。比例常数在比率中被抵消，因此我们计算：\n    $$\\mathcal{R}^2 = \\frac{\\sum_{i,j,\\mathbf{k}} |\\tilde{h}^{\\mathrm{TT}}_{ij}(\\mathbf{k})|^2}{\\sum_{i,j,\\mathbf{k}} |\\tilde{h}_{ij}(\\mathbf{k})|^2}$$\n    对 $i,j$ 的求和覆盖了张量的所有九个分量。对于对称张量，这等价于 $\\sum_i |\\tilde{h}_{ii}|^2 + \\sum_{i",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical unit test for the Transverse-Traceless (TT) gauge projection.\n    \"\"\"\n    test_cases = [\n        (32, 32, 32),\n        (64, 48, 40),\n        (96, 96, 96),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Nz = case\n        \n        # 1. Construct grid and wavevectors\n        # Domain is [0, 2*pi) in each dimension.\n        # This setup makes the wavevectors correspond to integer mode numbers.\n        x = np.linspace(0, 2 * np.pi, Nx, endpoint=False)\n        y = np.linspace(0, 2 * np.pi, Ny, endpoint=False)\n        z = np.linspace(0, 2 * np.pi, Nz, endpoint=False)\n        X, Y, Z = np.meshgrid(x, y, z, indexing='ij')\n\n        kx = np.fft.fftfreq(Nx) * Nx\n        ky = np.fft.fftfreq(Ny) * Ny\n        kz = np.fft.fftfreq(Nz) * Nz\n        KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij')\n\n        # 2. Define scalar field and compute h_ij in Fourier space\n        # phi(x,y,z) = cos(x) + sin(2y) + cos(3z) + 0.5*cos(x+y+2z)\n        phi = np.cos(X) + np.sin(2 * Y) + np.cos(3 * Z) + 0.5 * np.cos(X + Y + 2 * Z)\n        \n        phi_tilde = np.fft.fftn(phi)\n\n        # h_ij = d_i d_j phi  =>  h_tilde_ij = -k_i k_j phi_tilde\n        h_tilde_xx = -KX * KX * phi_tilde\n        h_tilde_xy = -KX * KY * phi_tilde\n        h_tilde_xz = -KX * KZ * phi_tilde\n        h_tilde_yy = -KY * KY * phi_tilde\n        h_tilde_yz = -KY * KZ * phi_tilde\n        h_tilde_zz = -KZ * KZ * phi_tilde\n        \n        # 3. Apply the TT projection operator\n        k_sq = KX**2 + KY**2 + KZ**2\n        \n        # Handle the k=0 mode to avoid division by zero.\n        # The projection is defined to be zero for this mode.\n        # We can use a mask for safe division.\n        inv_k_sq = np.zeros_like(k_sq, dtype=float)\n        nonzero_k = k_sq != 0\n        inv_k_sq[nonzero_k] = 1.0 / k_sq[nonzero_k]\n\n        #\n        # A) Project to the transverse space: h_T_ij = P_ik P_jl h_kl\n        #\n        # Contract with one k: h_k_j = k_i * h_ij\n        h_k_x = KX * h_tilde_xx + KY * h_tilde_xy + KZ * h_tilde_xz\n        h_k_y = KX * h_tilde_xy + KY * h_tilde_yy + KZ * h_tilde_yz\n        h_k_z = KX * h_tilde_xz + KY * h_tilde_yz + KZ * h_tilde_zz\n        \n        # Contract with two k's: h_kk = k_i k_j h_ij\n        h_kk = KX * h_k_x + KY * h_k_y + KZ * h_k_z\n\n        # Use the expansion: h_T_ij = h_ij - (k_i/k^2)h_k_j - (k_j/k^2)h_k_i + (k_i k_j/k^4)h_kk\n        h_T_xx = h_tilde_xx - 2 * KX * inv_k_sq * h_k_x + KX**2 * inv_k_sq**2 * h_kk\n        h_T_xy = h_tilde_xy - (KX * inv_k_sq * h_k_y + KY * inv_k_sq * h_k_x) + KX * KY * inv_k_sq**2 * h_kk\n        h_T_xz = h_tilde_xz - (KX * inv_k_sq * h_k_z + KZ * inv_k_sq * h_k_x) + KX * KZ * inv_k_sq**2 * h_kk\n        h_T_yy = h_tilde_yy - 2 * KY * inv_k_sq * h_k_y + KY**2 * inv_k_sq**2 * h_kk\n        h_T_yz = h_tilde_yz - (KY * inv_k_sq * h_k_z + KZ * inv_k_sq * h_k_y) + KY * KZ * inv_k_sq**2 * h_kk\n        h_T_zz = h_tilde_zz - 2 * KZ * inv_k_sq * h_k_z + KZ**2 * inv_k_sq**2 * h_kk\n\n        #\n        # B) Subtract the trace to get the TT part: h_TT_ij = h_T_ij - 0.5 * P_ij * tr(h_T)\n        #\n        # tr(h_T) = P_ij h_ij = tr(h) - h_kk/k^2\n        tr_h = h_tilde_xx + h_tilde_yy + h_tilde_zz\n        tr_h_T = tr_h - h_kk * inv_k_sq\n\n        # Projector P_ij = delta_ij - k_i k_j / k^2\n        P_xx = 1.0 - KX**2 * inv_k_sq\n        P_xy = -KX * KY * inv_k_sq\n        P_xz = -KX * KZ * inv_k_sq\n        P_yy = 1.0 - KY**2 * inv_k_sq\n        P_yz = -KY * KZ * inv_k_sq\n        P_zz = 1.0 - KZ**2 * inv_k_sq\n        \n        h_TT_xx = h_T_xx - 0.5 * P_xx * tr_h_T\n        h_TT_xy = h_T_xy - 0.5 * P_xy * tr_h_T\n        h_TT_xz = h_T_xz - 0.5 * P_xz * tr_h_T\n        h_TT_yy = h_T_yy - 0.5 * P_yy * tr_h_T\n        h_TT_yz = h_T_yz - 0.5 * P_yz * tr_h_T\n        h_TT_zz = h_T_zz - 0.5 * P_zz * tr_h_T\n\n        # 4. Calculate the relative residual using norms in Fourier space\n        # Norm^2 = sum over k of ( |h_ii|^2 + 2*|h_ij|^2 for i"
        },
        {
            "introduction": "准确地模拟引力波的传播对于验证我们的物理模型和解释观测数据至关重要。这项高级练习将带您深入研究使用BSSN形式体系数值求解线性化爱因斯坦方程的过程。通过对一个纯横向无迹（TT）波的演化进行数值误差分析，您将学习如何量化数值格式（如有限差分和龙格-库塔方法）引入的耗散和色散效应，这是开发可靠数值相对论代码的一项核心技能。",
            "id": "3526839",
            "problem": "考虑真空线性化广义相对论的 Arnowitt-Deser-Misner (ADM) $3+1$分解及其 Baumgarte-Shapiro-Shibata-Nakamura (BSSN) 重新表述。在平直 Minkowski 背景上，采用横向无迹 (TT) 规范。设 lapse 函数为 $\\alpha = 1$，shift 向量为 $\\beta^i = 0$，空间度规为 $\\gamma_{ij} = \\delta_{ij} + h_{ij}$，其中小微扰 $h_{ij}$ 满足 TT 条件 $\\partial_i h^{ij} = 0$ 和 $h^i{}_i = 0$。假设在一维区域 $x \\in [0,L]$上采用周期性边界条件，并考虑一个波数为 $k = 2\\pi m/L$ 的单色平面波，以速度 $c$ 在 $x$ 方向传播，其中 $m$ 是一个正整数。\n\n从基本的真空爱因斯坦场方程 $G_{\\mu\\nu} = 0$ 以及 ADM 和 BSSN 的定义出发，推导 TT 规范下的线性化演化方程。证明在线性阶上，度规微扰的 TT 分量满足波动方程，并为右行引力波构建自洽的初始数据。然后，在空间上选择直线法离散化，并应用经典的显式四阶 Runge-Kutta 时间积分器。在空间上，使用中心有限差分对二阶导数 $\\partial_x^2$进行离散化。考虑两种模板选择：\n- 二阶中心有限差分模板 $[1,-2,1]/h^2$，以及\n- 四阶中心有限差分模板 $[-1,16,-30,16,-1]/(12h^2)$，\n其中 $h = L/N$ 是网格间距，$N$ 是网格点数。\n\n对所选的空间算子和线性化的 BSSN 系统使用离散傅里叶分析，构建单个傅里叶模式的半离散色散关系，并确定该模式的 Runge-Kutta 积分器的单步放大因子。将精确连续波的物理周期定义为 $T = 2\\pi/(c k)$。设时间步长为 $\\Delta t = \\lambda h / c$，其中 Courant 因子为 $\\lambda$。使用 $N_t = T / \\Delta t$（假定为整数）个步长，将离散模式演化整整一个物理周期 $T$。将在时间 $T$ 后的振幅误差定义为数值振幅与 1 的绝对偏差，并将相位误差定义为在时间 $T$ 时数值相位与精确相位 $2\\pi$ 之间的最小绝对差（以弧度为单位）。\n\n您的程序必须实现上述推导，以计算每个测试用例在一个物理周期 $T$ 后的振幅误差和相位误差。角度必须以弧度为单位报告。除了这些无量纲量之外，没有其他物理单位。使用 $c = 1$ 和 $L = 1$。直线法的空间算子必须是与所选模板相关联的离散二阶导数。Runge-Kutta 时间步长必须使用 Courant 因子 $\\lambda = 0.5$，以使 $N_t$ 恰好为整数，等于 $N/(m\\lambda)$。\n\n测试套件参数值：\n- 用例 1：模板阶数 $p=2$，网格点数 $N=128$，傅里叶模式指数 $m=1$。\n- 用例 2：模板阶数 $p=2$，网格点数 $N=256$，傅里叶模式指数 $m=1$。\n- 用例 3：模板阶数 $p=4$，网格点数 $N=128$，傅里叶模式指数 $m=1$。\n- 用例 4：模板阶数 $p=2$，网格点数 $N=256$，傅里叶模式指数 $m=32$。\n\n您的程序应生成单行输出，其中按顺序列出每个用例的振幅误差和相位误差，形式为用方括号括起来的逗号分隔列表（例如，$[a_1,\\phi_1,a_2,\\phi_2,a_3,\\phi_3,a_4,\\phi_4]$），其中每个 $a_i$ 是振幅误差（浮点数），每个 $\\phi_i$ 是以弧度为单位的相位误差（浮点数）。",
            "solution": "用户希望计算线性化爱因斯坦场方程的直线法解的数值误差。该解决方案涉及使用有限差分在空间上对一维波动方程进行离散化，并使用四阶 Runge-Kutta 格式在时间上进行离散化。误差将使用离散傅里叶分析进行评估。\n\n### 步骤 1：连续谱演化方程的推导\n\n我们从真空爱因斯坦场方程 $G_{\\mu\\nu} = 0$ 开始。在 $3+1$ ADM 形式体系中，时空被叶状化为空间切片。演化由 lapse 函数 $\\alpha$、shift 向量 $\\beta^i$、空间度规 $\\gamma_{ij}$ 和外在曲率 $K_{ij}$ 描述。问题指定了具有小微扰 $\\gamma_{ij} = \\delta_{ij} + h_{ij}$ 的平直 Minkowski 背景，并将规范设置为 $\\alpha=1$ 和 $\\beta^i=0$。微扰 $h_{ij}$ 处于横向无迹 (TT) 规范中，即 $\\partial_i h^{ij} = 0$（横向）和 $h^i{}_i = \\delta^{ij}h_{ij} = 0$（无迹）。\n\nADM 演化方程为：\n$$ \\partial_t \\gamma_{ij} = -2\\alpha K_{ij} + \\nabla_i \\beta_j + \\nabla_j \\beta_i $$\n$$ \\partial_t K_{ij} = -\\nabla_i \\nabla_j \\alpha + \\alpha(R_{ij} - 2K_{ik}K^k_j + K K_{ij}) + \\mathcal{L}_\\beta K_{ij} $$\n其中 $R_{ij}$ 是空间度规 $\\gamma_{ij}$ 的 Ricci 张量，$K = \\gamma^{ij}K_{ij}$ 是外在曲率的迹。\n\n在给定规范选择（$\\alpha=1, \\beta^i=0$）下，围绕平直背景（$\\gamma_{ij}=\\delta_{ij}, K_{ij}=0$）对这些方程进行线性化，得到：\n1.  从 $\\partial_t \\gamma_{ij}$ 方程，代入 $\\gamma_{ij} = \\delta_{ij} + h_{ij}$：\n    $$ \\partial_t h_{ij} = -2 K_{ij} $$\n2.  对于 $\\partial_t K_{ij}$ 方程，我们线性化每一项。$K_{ij}$ 的二次项消失。涉及 $\\alpha$ 和 $\\beta$ 导数的项为零。唯一剩下的一阶项是 $\\alpha R_{ij}^{(1)}$，其中 $R_{ij}^{(1)}$ 是线性化的空间 Ricci 张量。\n    $$ \\partial_t K_{ij} = R_{ij}^{(1)} $$\n    对于微扰 $h_{ij}$，线性化的 Ricci 张量为 $R_{ij}^{(1)} = \\frac{1}{2}(\\partial_k\\partial_i h^k_j + \\partial_k\\partial_j h^k_i - \\partial_i\\partial_j h - \\partial_k\\partial^k h_{ij})$。在 TT 规范下（$\\partial_j h^{ji} = 0, h=0$），该式可大幅简化为：\n    $$ R_{ij}^{(1)} = -\\frac{1}{2} \\partial_k\\partial^k h_{ij} = -\\frac{1}{2} \\nabla^2 h_{ij} $$\n    因此，$K_{ij}$ 的演化方程变为：\n    $$ \\partial_t K_{ij} = -\\frac{1}{2} \\nabla^2 h_{ij} $$\n\n问题指出，在 BSSN 形式体系中，TT 分量的演化方程在线性层面上是相同的。这是正确的，因为对于 TT 微扰，共形因子 $\\phi$ 在线性阶上为零，共形无迹外在曲率 $\\tilde{A}_{ij}$ 与 $K_{ij}$ 变得相同。因此，待解的系统是：\n$$ \\partial_t h_{ij} = -2 K_{ij} $$\n$$ \\partial_t K_{ij} = -\\frac{1}{2} \\nabla^2 h_{ij} $$\n对于在 $x$ 方向传播的一维平面波，$\\nabla^2$ 变为 $\\partial_x^2$。对第一个方程求时间导数，并代入第二个方程，将两个方程合并，得到 $(\\partial_t^2 - c^2\\partial_x^2)h_{ij} = 0$（其中 $c=1$），这就是标准的波动方程。\n\n### 步骤 2：半离散傅里叶分析\n\n我们使用直线法，首先对空间进行离散化。设状态向量为 $U = [h_{ij}, K_{ij}]^T$。系统为 $\\partial_t U = \\mathcal{M}U$，其中 $\\mathcal{M}$ 是矩阵算子：\n$$ \\mathcal{M} = \\begin{pmatrix} 0  & -2I \\\\ -\\frac{1}{2}\\partial_x^2 I & 0 \\end{pmatrix} $$\n我们分析单个傅里叶模式 $U(x,t) = \\hat{U}(k,t) e^{ikx}$，其中 $k=2\\pi m/L$ 是波数。算子 $\\partial_x^2$ 作用于 $e^{ikx}$ 等效于乘以 $-k^2$。矩阵 $\\begin{pmatrix} 0  & -2 \\\\ k^2/2  & 0 \\end{pmatrix}$ 的特征值为 $\\pm \\sqrt{-k^2} = \\pm ik$。这些对应于频率为 $\\omega_{phys} = ck$ 的右行波和左行波。\n\n在网格 $x_j=jh$（其中 $h=L/N$）上进行空间离散化后，连续算子 $\\partial_x^2$ 被离散有限差分算子 $D_2$ 替代。$D_2$ 对离散傅里叶模式 $e^{ikx_j}$ 的作用是乘以其符号 $\\hat{D}_2(k)$。\n- 对于二阶模板 $[1, -2, 1]/h^2$：\n  $$ \\hat{D}_2(k) = \\frac{e^{ikh} - 2 + e^{-ikh}}{h^2} = \\frac{2(\\cos(kh)-1)}{h^2} = -\\frac{4}{h^2}\\sin^2\\left(\\frac{kh}{2}\\right) $$\n- 对于四阶模板 $[-1, 16, -30, 16, -1]/(12h^2)$：\n  $$ \\hat{D}_2(k) = \\frac{-e^{i2kh} + 16e^{ikh} - 30 + 16e^{-ikh} - e^{-i2kh}}{12h^2} = \\frac{-2\\cos(2kh) + 32\\cos(kh) - 30}{12h^2} $$\n\n傅里叶模式的半离散系统具有特征值 $\\pm\\sqrt{\\hat{D}_2(k)}$，由于 $\\hat{D}_2(k)$ 为负，这些特征值是虚数。这定义了一个数值频率 $\\omega_{num} = c\\sqrt{-\\hat{D}_2(k)}$。半离散 ODE 实际上是 $\\frac{d\\hat{U}}{dt} = \\pm i\\omega_{num} \\hat{U}$。\n\n### 步骤 3：完全离散化和误差分析\n\n时间积分使用经典的显式四阶 Runge-Kutta (RK4) 方法进行。对于一个常微分方程 $y'=\\lambda y$，单步更新为 $y_{n+1} = G(\\lambda\\Delta t)y_n$，其中 $G(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!$ 是放大因子。\n对于我们的系统，特征值为 $\\lambda = \\pm i\\omega_{num}$。对于右行波，我们选择 $\\lambda = -i\\omega_{num}$。令 $q = \\omega_{num}\\Delta t$。放大因子的自变量为 $z = -iq$。\n$$ g_{step} = G(-iq) = 1 - iq - \\frac{q^2}{2} + \\frac{iq^3}{6} + \\frac{q^4}{24} = \\left(1 - \\frac{q^2}{2} + \\frac{q^4}{24}\\right) - i\\left(q - \\frac{q^3}{6}\\right) $$\n演化一个物理周期 $T = 2\\pi/(ck) = L/(cm)$（其中 $c=1, L=1$），这需要 $N_t = T/\\Delta t$ 个步长，总放大为 $G_{final} = (g_{step})^{N_t}$。\n\n**振幅误差**：精确解是纯振荡，因此其振幅是恒定的（归一化为 1）。一个周期后的数值振幅是 $|G_{final}|$。振幅误差是与 1 的绝对偏差：\n$$ A_{err} = \\big| |G_{final}| - 1 \\big| = \\big| |g_{step}|^{N_t} - 1 \\big| $$\n\n**相位误差**：右行波 $e^{ik(x-ct)}$ 在一个周期 $T$ 内的精确相位累积是 $-ckT = -k(L/m) = -(2\\pi m/L)(L/m) = -2\\pi$ 弧度。总数值相位累积为 $\\Phi_{num} = N_t \\arg(g_{step})$。相位误差是数值总相位累积与精确总相位累积之间的绝对差。\n$$ \\phi_{err} = |\\Phi_{num} - (-2\\pi)| = |N_t \\arg(g_{step}) + 2\\pi| $$\n这个定义正确地捕捉了由空间色散（$\\omega_{num} \\neq ck$）和时间积分误差（$g_{step}$ 的相位不完全是 $-q$）共同造成的累积误差。\n\n计算过程通过为每个测试用例实现这些公式来进行。\n- 给定模板阶数 $p$、网格点数 $N$ 和模式指数 $m$。\n- 计算常数：$h=L/N$, $k=2\\pi m/L$, $\\Delta t=\\lambda h/c$, $T=L/(cm)$, $N_t=T/\\Delta t$。\n- 从模板公式计算数值频率 $\\omega_{num}$。\n- 计算 $q = \\omega_{num}\\Delta t$。\n- 计算复数单步放大因子 $g_{step}$。\n- 计算总放大 $G_{final} = (g_{step})^{N_t}$ 和总数值相位 $\\Phi_{num} = N_t \\arg(g_{step})$。\n- 最后，使用推导出的公式计算振幅和相位误差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (stencil_order, grid_points, fourier_mode_index)\n        (2, 128, 1),\n        (2, 256, 1),\n        (4, 128, 1),\n        (2, 256, 32),\n    ]\n\n    results = []\n    for p, N, m in test_cases:\n        amp_err, phase_err = calculate_errors(p, N, m)\n        results.append(amp_err)\n        results.append(phase_err)\n    \n    # Format the output string as specified: [a_1,phi_1,a_2,phi_2,...]\n    # Use a reasonable precision for floating point numbers.\n    formatted_results = [f\"{r:.10e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_errors(p, N, m):\n    \"\"\"\n    Calculates the amplitude and phase error for a single gravitational wave\n    mode evolved for one physical period.\n\n    Args:\n        p (int): Stencil order for the spatial finite difference (2 or 4).\n        N (int): Number of grid points on the domain.\n        m (int): Fourier mode index of the wave.\n\n    Returns:\n        tuple[float, float]: A tuple containing the amplitude error and phase error.\n    \"\"\"\n    # Physical and numerical constants from the problem statement\n    c = 1.0\n    L = 1.0\n    lambda_courant = 0.5\n    \n    # Grid, wave, and time parameters\n    h = L / N\n    k_phys = 2.0 * np.pi * m / L\n    kh = k_phys * h\n    \n    T_phys = L / (c * m)\n    dt = lambda_courant * h / c\n    Nt = int(round(T_phys / dt))\n    \n    # Calculate the symbol of the discrete second derivative operator, D2_hat.\n    # This is equivalent to the eigenvalue of the operator for the given mode k.\n    if p == 2:\n        # 2nd-order centered difference stencil: [1, -2, 1] / h^2\n        # Symbol: -4/h^2 * sin(kh/2)^2\n        D2_hat = -4.0 / (h**2) * np.sin(kh / 2.0)**2\n    elif p == 4:\n        # 4th-order centered difference stencil: [-1, 16, -30, 16, -1] / (12h^2)\n        # Symbol: (-2*cos(2kh) + 32*cos(kh) - 30) / (12*h^2)\n        cos_kh = np.cos(kh)\n        cos_2kh = np.cos(2*kh)\n        D2_hat = (-cos_2kh + 16.0 * cos_kh - 15.0) / (6.0 * h**2) # Using another stable form derived from 2*cos^2(x)-1\n    else:\n        raise ValueError(\"Stencil order p must be 2 or 4.\")\n        \n    # The semi-discrete system's eigenvalues are purely imaginary, leading to\n    # oscillations with a numerical frequency omega_num = c * sqrt(-D2_hat).\n    omega_num = c * np.sqrt(-D2_hat)\n    \n    # The time evolution uses RK4. For an ODE y' = lam*y, the amplification\n    # factor is G(z) = 1 + z + z^2/2 + z^3/6 + z^4/24, where z = lam*dt.\n    # For a right-moving wave, lam = -i*omega_num.\n    q = omega_num * dt\n    z = -1j * q\n    \n    # Calculate the one-step complex amplification factor G(z).\n    # Using np.cdouble for high precision complex arithmetic.\n    g_step = np.cdouble(1.0 + z + z**2/2.0 + z**3/6.0 + z**4/24.0)\n\n    # --- Amplitude Error Calculation ---\n    # The total amplification after Nt steps is g_step^Nt.\n    # The exact solution has constant amplitude 1.\n    g_final = g_step**Nt\n    numerical_amplitude = np.abs(g_final)\n    amplitude_error = np.abs(numerical_amplitude - 1.0)\n    \n    # --- Phase Error Calculation ---\n    # The exact total phase change for a right-moving wave over period T\n    # is -k_phys * c * T = -2*pi.\n    exact_phase_total = -2.0 * np.pi\n    \n    # The numerical total phase is the sum of phase changes per step.\n    numerical_phase_total = Nt * np.angle(g_step)\n    \n    # The phase error is the absolute difference between numerical and exact total phase.\n    phase_error = np.abs(numerical_phase_total - exact_phase_total)\n    \n    return amplitude_error, phase_error\n\n# I corrected the 4th order stencil formula to be more direct from the problem description\n# (-2*cos(2kh) + 32*cos(kh) - 30) / (12*h^2)\n# and then re-derived a stable form from scratch to ensure correctness\n# = (-2(2cos(kh)^2-1) + 32cos(kh) - 30) / (12h^2)\n# = (-4cos(kh)^2 + 32cos(kh) - 28) / (12h^2)\n# = -(cos(kh)^2 - 8cos(kh) + 7) / (3h^2)\n# = -(cos(kh)-1)(cos(kh)-7) / (3h^2)\n# The previous version in thought was correct.\n# The version used in the original user's code `(-cos_2kh + 16.0 * cos_kh - 15.0) / (6.0 * h**2)` is also correct, just multiplying by 2/2.\n# I will use the most direct formula from the stencil for clarity.\n\ndef calculate_errors_final_version(p, N, m):\n    c = 1.0\n    L = 1.0\n    lambda_courant = 0.5\n    h = L / N\n    k_phys = 2.0 * np.pi * m / L\n    kh = k_phys * h\n    T_phys = L / (c * m)\n    dt = lambda_courant * h / c\n    Nt = int(round(T_phys / dt))\n    \n    if p == 2:\n        D2_hat = (2.0 * np.cos(kh) - 2.0) / h**2\n    elif p == 4:\n        D2_hat = (-np.cos(2*kh) + 16.0 * np.cos(kh) - 15.0) / (6.0 * h**2) * (2.0/2.0) # wait, my scratchpad is a mess\n        D2_hat = (-np.cos(2*kh) + 16 * np.cos(kh) - 15.0) / (6*h**2) # this is (-2cos^2(kh)+1 + 16cos(kh)-15) / (6h^2) wrong\n        D2_hat = (-2*np.cos(2*kh) + 32*np.cos(kh) - 30) / (12 * h**2) # The direct one is best\n    else:\n        raise ValueError(\"Stencil order p must be 2 or 4.\")\n    \n    omega_num = c * np.sqrt(-D2_hat)\n    q = omega_num * dt\n    z = -1j * q\n    g_step = np.cdouble(1.0 + z + z**2/2.0 + z**3/6.0 + z**4/24.0)\n    g_final = g_step**Nt\n    amplitude_error = np.abs(np.abs(g_final) - 1.0)\n    exact_phase_total = -2.0 * np.pi\n    numerical_phase_total = Nt * np.angle(g_step)\n    phase_error = np.abs(numerical_phase_total - exact_phase_total)\n    \n    return amplitude_error, phase_error\n\n#The code in the original answer block is fine and correct. I will just leave it. It is just a different, but equivalent, formulation of the stencil symbol.\n#Let's stick with the original code.\n\nsolve()\n```"
        }
    ]
}