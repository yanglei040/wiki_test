{
    "hands_on_practices": [
        {
            "introduction": "在数值相对论模拟中，观测到的约束违反是多种误差来源的综合体现。这项实践练习将指导你使用理查森外推法（Richardson extrapolation）——一种强大的数值分析技术——来分离和量化这些误差来源，包括空间离散、时间离散以及边界处理引入的误差 。通过精确诊断误差的构成，我们能更有针对性地优化模拟参数，提高计算结果的物理真实性。",
            "id": "3469946",
            "problem": "给定一个数值相对论和引力波中的场景，重点是在Baumgarte-Shapiro-Shibata-Nakamura (BSSN) 形式下监测约束违反。设哈密顿约束范数表示为 $H(h,\\Delta t,b)$，其中 $h$ 是空间网格间距，$\\Delta t$ 是时间步长，$b$ 是一个边界控制参数，用于缩放外边界上违反约束的反射的幅度。假设采用线方法离散化，其中主阶离散误差可分离为已知阶数的空间和时间截断项，并且由边界引起的污染与边界控制参数成反比。具体来说，假设模型为\n$$\nH(h,\\Delta t,b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b},\n$$\n其中 $\\hat{H}$ 是连续统约束范数，$A$、$B$ 和 $C$ 是系数，$p$ 是空间精度阶数，$q$ 是时间精度阶数。对于此问题，取 $p=4$，$q=2$，边界缩放为 $1/b$。此问题中的所有量都是无量纲的，并且必须以纯浮点数的形式报告。\n\n您的任务是使用理查森外推法和成对参数变分法来估计连续统约束范数 $\\hat{H}$，并为一个指定的目标配置构建一个分离了空间、时间和边界贡献的误差预算。该方法必须从一个基本基础出发，即对于足够光滑的解和稳定的格式，截断误差会按照由格式决定的 $h$ 和 $\\Delta t$ 的幂次进行缩放，而边界污染则按照反射强度控制参数的逆幂次进行缩放。推导和算法必须在一次只改变一个参数而保持其他参数固定的情况下，使用理查森外推逻辑来消除主阶误差贡献。\n\n对于每个测试用例，都提供了三个双层测量，其中只有一个参数发生变化，而其他两个参数保持固定，同时还提供了一个目标配置 $(h_\\star,\\Delta t_\\star,b_\\star)$，您必须在该配置下报告误差预算。根据这些数据，您必须：\n- 估计系数 $A$、$B$ 和 $C$。\n- 通过理查森外推法估计连续统范数 $\\hat{H}$，该方法消除了变化参数的主阶项，然后减去未变化参数的剩余贡献。\n- 计算目标配置下的误差预算贡献：$E_s = A\\,h_\\star^p$，$E_t = B\\,(\\Delta t_\\star)^q$ 和 $E_b = C/b_\\star$。\n\n请使用以下测试套件。对于每个案例，都提供了三个测量对和目标配置。在每个对中，只有指定的参数会改变；其他两个参数在整个对中是相同的。值 $H_1$ 和 $H_2$ 是针对变化参数的第一个和第二个设置所测得的范数。\n\n案例 1：\n- 空间对：$(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{256}, 16, 0.00313057559967041, 0.0031305532479286194 \\right)$\n- 时间对：$(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{128}, \\frac{1}{256}, \\frac{1}{128}, 16, 0.003139708521366119, 0.0031305532479286194 \\right)$\n- 边界对：$(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 8, 16, \\frac{1}{128}, \\frac{1}{256}, 0.006255553247928619, 0.0031305532479286194 \\right)$\n- 目标：$(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{128}, \\frac{1}{256}, 16 \\right)$\n\n案例 2：\n- 空间对：$(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{64}, 8, 0.00630135196685791, 0.006301329615241116 \\right)$\n- 时间对：$(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{64}, \\frac{1}{128}, \\frac{1}{128}, 8, 0.006301329615241116, 0.006264708521366119 \\right)$\n- 边界对：$(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 4, 8, \\frac{1}{128}, \\frac{1}{128}, 0.01251470852136612, 0.006264708521366119 \\right)$\n- 目标：$(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{64}, \\frac{1}{64}, 8 \\right)$\n\n案例 3：\n- 空间对：$(h_1,h_2,\\Delta t,b,H_1,H_2) = \\left( \\frac{1}{256}, \\frac{1}{512}, \\frac{1}{1024}, 64, 0.0007839408289955386, 0.0007839407406840473 \\right)$\n- 时间对：$(\\Delta t_1,\\Delta t_2,h,b,H_1,H_2) = \\left( \\frac{1}{1024}, \\frac{1}{2048}, \\frac{1}{512}, 64, 0.0007839407406840473, 0.0007837976895365864 \\right)$\n- 边界对：$(b_1,b_2,h,\\Delta t,H_1,H_2) = \\left( 32, 64, \\frac{1}{512}, \\frac{1}{1024}, 0.0015651907406840473, 0.0007839407406840473 \\right)$\n- 目标：$(h_\\star,\\Delta t_\\star,b_\\star) = \\left( \\frac{1}{256}, \\frac{1}{1024}, 64 \\right)$\n\n对于每个案例，您的程序必须在单行输出中生成四个浮点数，并按以下顺序汇总所有案例的结果：\n$[\\hat{H}_1, E_{s,1}, E_{t,1}, E_{b,1}, \\hat{H}_2, E_{s,2}, E_{t,2}, E_{b,2}, \\hat{H}_3, E_{s,3}, E_{t,3}, E_{b,3}]$\n其中下标索引表示案例编号。程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,...]\"）。所有输出必须是纯浮点数，不带单位。\n\n推理必须从上述核心定义和性质出发，而不是在问题陈述中提供捷径公式。您必须从由线方法离散化和光滑解的稳定格式所蕴含的标度律推导出理查森外推策略以及将贡献分离为空间、时间和边界分量的合理性。",
            "solution": "该问题要求根据一个给定的总测量范数 $H(h, \\Delta t, b)$ 模型，估计哈密顿约束范数 $\\hat{H}$ 的连续统极限，并对给定的目标配置进行误差预算分析。该模型假设总误差是空间离散化、时间离散化和边界效应贡献的总和。\n\n测量的哈密顿约束范数的基本模型如下：\n$$\nH(h, \\Delta t, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\n这里，$h$ 是空间网格间距，$\\Delta t$ 是时间步长，$b$ 是边界控制参数。$\\hat{H}$ 代表真实的连续统范数（$h \\to 0$，$\\Delta t \\to 0$，$b \\to \\infty$）。项 $A\\,h^p$、$B\\,(\\Delta t)^q$ 和 $C/b$ 分别代表来自空间离散化、时间离散化和外边界的主要误差贡献。问题指定空间格式的精度阶数为 $p=4$，时间格式的精度阶数为 $q=2$。\n\n我们的目标是通过一系列一次只改变一个参数的数值实验来确定未知系数 $A$、$B$、$C$ 以及连续统范数 $\\hat{H}$。\n\n首先，我们确定系数 $A$、$B$ 和 $C$。这是通过获取每次只改变一个参数的成对测量来实现的。\n\n为了求出空间误差系数 $A$，我们考虑在保持时间步长 $\\Delta t$ 和边界参数 $b$ 不变的情况下，在空间分辨率 $h_1$ 和 $h_2$ 下进行两次测量，$H_1$ 和 $H_2$。这两次测量的模型方程是：\n$$\nH_1 = H(h_1, \\Delta t, b) \\approx \\hat{H} + A\\,h_1^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\n$$\nH_2 = H(h_2, \\Delta t, b) \\approx \\hat{H} + A\\,h_2^p + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\n用第一个方程减去第二个方程可以消去 $\\hat{H}$、时间误差项和边界误差项，从而分离出空间误差的影响：\n$$\nH_1 - H_2 \\approx A\\,(h_1^p - h_2^p)\n$$\n由此，我们可以解出系数 $A$：\n$$\nA = \\frac{H_1 - H_2}{h_1^p - h_2^p}\n$$\n使用类似的过程来求时间误差系数 $B$。我们使用两次测量，其中只有时间步长在 $\\Delta t_1$ 和 $\\Delta t_2$ 之间变化，而 $h$ 和 $b$ 保持固定：\n$$\nH_1 = H(h, \\Delta t_1, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t_1)^q + \\frac{C}{b}\n$$\n$$\nH_2 = H(h, \\Delta t_2, b) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t_2)^q + \\frac{C}{b}\n$$\n相减得到：\n$$\nH_1 - H_2 \\approx B\\,((\\Delta t_1)^q - (\\Delta t_2)^q)\n$$\n解出 $B$：\n$$\nB = \\frac{H_1 - H_2}{(\\Delta t_1)^q - (\\Delta t_2)^q}\n$$\n同样，对于边界系数 $C$，我们在保持 $h$ 和 $\\Delta t$ 恒定的情况下，将边界参数在 $b_1$ 和 $b_2$ 之间变化：\n$$\nH_1 = H(h, \\Delta t, b_1) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b_1}\n$$\n$$\nH_2 = H(h, \\Delta t, b_2) \\approx \\hat{H} + A\\,h^p + B\\,(\\Delta t)^q + \\frac{C}{b_2}\n$$\n相减得到：\n$$\nH_1 - H_2 \\approx C\\,\\left(\\frac{1}{b_1} - \\frac{1}{b_2}\\right)\n$$\n我们解出 $C$：\n$$\nC = \\frac{H_1 - H_2}{\\frac{1}{b_1} - \\frac{1}{b_2}}\n$$\n在确定了系数 $A$、$B$ 和 $C$ 之后，我们现在可以估计连续统范数 $\\hat{H}$。问题指导我们使用基于理查森外推法的程序。让我们考虑用于求 $A$ 的测量对，其中 $h$ 发生了变化。我们可以使用这两次测量来产生一个更高阶的 $H(h=0, \\Delta t, b)$ 的估计。设 $r = h_1 / h_2$。消除 $O(h^p)$ 误差项的标准理查森外推公式为：\n$$\nH_{\\text{extrap}, h} = \\frac{H_2\\,r^p - H_1}{r^p - 1}\n$$\n这个外推值代表了在 $h \\to 0$ 极限下，但在该特定测量对中使用的固定 $\\Delta t$ 和 $b$ 值下的哈密顿范数估计值。因此，根据我们的模型，其值为：\n$$\nH_{\\text{extrap}, h} \\approx \\hat{H} + B\\,(\\Delta t)^q + \\frac{C}{b}\n$$\n由于我们已经计算出系数 $B$ 和 $C$，我们现在可以通过减去剩余的误差贡献来分离出 $\\hat{H}$：\n$$\n\\hat{H} \\approx H_{\\text{extrap}, h} - B\\,(\\Delta t)^q - \\frac{C}{b}\n$$\n其中 $\\Delta t$ 和 $b$ 是在空间变化实验中保持不变的参数。这为我们提供了连续统范数的估计值。\n\n最后，我们被要求为指定的目标配置 $(h_\\star, \\Delta t_\\star, b_\\star)$ 计算误差预算。这涉及到使用我们已经找到的系数来计算此目标配置下每个误差分量的大小：\n$$\n\\text{空间误差: } E_s = A\\,h_\\star^p\n$$\n$$\n\\text{时间误差: } E_t = B\\,(\\Delta t_\\star)^q\n$$\n$$\n\\text{边界误差: } E_b = \\frac{C}{b_\\star}\n$$\n总和 $E_s + E_t + E_b$ 代表了相对于连续统值 $\\hat{H}$ 的测量值 $H(h_\\star, \\Delta t_\\star, b_\\star)$ 的总估计误差。\n\n所述算法应用于提供的每个测试用例。阶数的具体值为 $p=4$ 和 $q=2$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the continuum Hamiltonian norm and error budget\n    for a series of numerical relativity simulations.\n    \"\"\"\n    p = 4\n    q = 2\n\n    # (spatial_pair, temporal_pair, boundary_pair, target_config)\n    test_cases = [\n        # Case 1\n        (\n            {'h1': 1/64, 'h2': 1/128, 'dt': 1/256, 'b': 16, 'H1': 0.00313057559967041, 'H2': 0.0031305532479286194},\n            {'dt1': 1/128, 'dt2': 1/256, 'h': 1/128, 'b': 16, 'H1': 0.003139708521366119, 'H2': 0.0031305532479286194},\n            {'b1': 8, 'b2': 16, 'h': 1/128, 'dt': 1/256, 'H1': 0.006255553247928619, 'H2': 0.0031305532479286194},\n            {'h_star': 1/128, 'dt_star': 1/256, 'b_star': 16}\n        ),\n        # Case 2\n        (\n            {'h1': 1/64, 'h2': 1/128, 'dt': 1/64, 'b': 8, 'H1': 0.00630135196685791, 'H2': 0.006301329615241116},\n            {'dt1': 1/64, 'dt2': 1/128, 'h': 1/128, 'b': 8, 'H1': 0.006301329615241116, 'H2': 0.006264708521366119},\n            {'b1': 4, 'b2': 8, 'h': 1/128, 'dt': 1/128, 'H1': 0.01251470852136612, 'H2': 0.006264708521366119},\n            {'h_star': 1/64, 'dt_star': 1/64, 'b_star': 8}\n        ),\n        # Case 3\n        (\n            {'h1': 1/256, 'h2': 1/512, 'dt': 1/1024, 'b': 64, 'H1': 0.0007839408289955386, 'H2': 0.0007839407406840473},\n            {'dt1': 1/1024, 'dt2': 1/2048, 'h': 1/512, 'b': 64, 'H1': 0.0007839407406840473, 'H2': 0.0007837976895365864},\n            {'b1': 32, 'b2': 64, 'h': 1/512, 'dt': 1/1024, 'H1': 0.0015651907406840473, 'H2': 0.0007839407406840473},\n            {'h_star': 1/256, 'dt_star': 1/1024, 'b_star': 64}\n        ),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        spatial_pair, temporal_pair, boundary_pair, target = case\n\n        # Calculate coefficient A from the spatial pair\n        sp = spatial_pair\n        A_numerator = sp['H1'] - sp['H2']\n        A_denominator = sp['h1']**p - sp['h2']**p\n        A = A_numerator / A_denominator\n\n        # Calculate coefficient B from the temporal pair\n        tp = temporal_pair\n        B_numerator = tp['H1'] - tp['H2']\n        B_denominator = tp['dt1']**q - tp['dt2']**q\n        B = B_numerator / B_denominator\n\n        # Calculate coefficient C from the boundary pair\n        bp = boundary_pair\n        C_numerator = bp['H1'] - bp['H2']\n        C_denominator = (1 / bp['b1']) - (1 / bp['b2'])\n        C = C_numerator / C_denominator\n\n        # Estimate H_hat using Richardson extrapolation on the spatial pair\n        # H_extrap_h is an estimate for H(h=0, dt, b) = H_hat + B*dt^q + C/b\n        r_h = sp['h1'] / sp['h2']\n        H_extrap_h = (sp['H2'] * r_h**p - sp['H1']) / (r_h**p - 1)\n\n        # Subtract the remaining error terms to find H_hat\n        # Use dt and b from the spatial pair measurement\n        dt_s = sp['dt']\n        b_s = sp['b']\n        H_hat = H_extrap_h - (B * dt_s**q + C / b_s)\n\n        # Calculate the error budget for the target configuration\n        E_s = A * target['h_star']**p\n        E_t = B * target['dt_star']**q\n        E_b = C / target['b_star']\n\n        all_results.extend([H_hat, E_s, E_t, E_b])\n\n    # Format output as a single comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在开发复杂的数值代码时，确保其实现与理论设计一致是至关重要的一步。这项实践的核心是执行收敛性测试（或称网格加密研究），这是验证代码正确性的黄金标准。你将通过一个精心设计的代理问题 ，学习如何检验数值误差是否如预期那样随着网格分辨率的提高而减小，从而建立对模拟代码可靠性的信心。",
            "id": "3470034",
            "problem": "考虑广义相对论的阿诺维特-德泽尔-米斯纳 (Arnowitt–Deser–Misner, ADM) 形式体系，其中哈密顿约束 $H$ 和动量约束 $M_i$ 在真空中必须为零。用微分几何的术语来说，对于真空初始数据 $(\\gamma_{ij}, K_{ij})$，哈密顿约束由 $H = R + K^2 - K_{ij} K^{ij}$ 给出，动量约束由 $M_i = \\nabla_j (K^j{}_i - \\delta^j{}_i K)$ 给出，其中 $R$ 是空间度规 $\\gamma_{ij}$ 的里奇标量，$K$ 是外在曲率 $K_{ij}$ 的迹，$\\nabla_j$ 是关于 $\\gamma_{ij}$ 的协变导数。在数值相对论中，通过 $L^2$ 范数等范数来监控这些约束，以评估演化的保真度和离散化的质量。对于应用于光滑数据的 $p$ 阶精度离散化，局部截断误差预计按 $\\mathcal{O}(h^p)$ 的比例缩放，其中 $h$ 是网格间距，这导致在渐近收敛区域内，残余约束的 $L^2$ 范数按 $h^p$ 比例缩放。\n\n为了设计一个可测试且自洽的预期收敛率验证方法，而无需实现完整的曲率张量，请考虑在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的以下人工构造的代理约束：\n- 设标量场 $\\phi(x,y) = x^3 - 3 x y^2$，它在二维空间中是调和的，因此对于所有 $(x,y) \\in \\Omega$，连续拉普拉斯算子满足 $\\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi = 0$。\n- 设流函数 $\\psi(x,y) = x^3 - 3 x y^2$，并定义一个向量场 $v$，其分量为 $v_x = \\partial_y \\psi$ 和 $v_y = -\\partial_x \\psi$，这确保对于所有 $(x,y) \\in \\Omega$，$\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y = 0$。\n\n这些选择产生了恒等于零的连续代理约束：\n- 代理哈密顿约束 $H := \\Delta \\phi = 0$。\n- 代理动量约束 $M := \\nabla \\cdot v = 0$。\n\n当在间距为 $h$ 的均匀网格上使用 $p$ 阶有限差分来近似这些微分算子时，由于截断误差，离散残余场 $H_h$ 和 $M_h$ 不为零，它们的 $L^2$ 范数服从\n$$\n\\|H_h\\|_{L^2(\\Omega)} \\approx C_H h^p, \\quad \\|M_h\\|_{L^2(\\Omega)} \\approx C_M h^p,\n$$\n其中常数 $C_H, C_M$ 取决于场的高阶导数。对于两个网格，其间距分别为 $h_1$ 和 $h_2$，对应的范数为 $E_1$ 和 $E_2$，观测到的收敛阶 $\\hat{p}$ 通过以下公式估算：\n$$\n\\hat{p} = \\frac{\\ln\\left(E_1 / E_2\\right)}{\\ln\\left(h_1 / h_2\\right)}.\n$$\n\n您的任务是编写一个完整、可运行的程序，该程序：\n1. 在单位正方形上为指定的 $N$ 值构造具有 $N \\times N$ 个点和间距 $h = 1/(N-1)$ 的均匀网格。\n2. 计算解析场 $\\phi(x,y)$ 和 $v(x,y)$，其中 $v_x(x,y) = -6 x y$ 和 $v_y(x,y) = -3 x^2 + 3 y^2$。\n3. 使用指定阶数 $p_H$ 的中心有限差分计算拉普拉斯算子的离散近似，使用指定阶数 $p_M$ 的中心有限差分计算散度的离散近似，从而得到代理约束。您必须实现：\n   - 对于拉普拉斯算子 $\\Delta \\phi$，沿每个轴使用二阶和四阶的标准中心有限差分模板来计算二阶导数，并将它们相加形成 $\\partial_{xx} \\phi + \\partial_{yy} \\phi$。对于 $p=2$ 阶，使用三点中心模板；对于 $p=4$ 阶，使用五点中心模板，其系数产生四阶精度。\n   - 对于散度 $\\nabla \\cdot v$，使用二阶和四阶的中心有限差分模板来计算一阶导数 $\\partial_x v_x$ 和 $\\partial_y v_y$，分别使用对应的三点或五点模板。\n4. 排除没有足够点支持所需模板的边界邻近点；在离散化有效的内部点上计算 $L^2$ 范数。$L^2$ 范数必须计算为\n$$\n\\|f\\|_{L^2(\\Omega_{\\text{int}})} = \\left( \\sum_{(i,j) \\in \\text{interior}} f_{ij}^2 \\, h^2 \\right)^{1/2},\n$$\n其中 $\\Omega_{\\text{int}}$ 表示模板有效的内部子集。\n5. 对于一系列网格尺寸 $\\{N_k\\}$，计算间距为 $h_k = 1/(N_k-1)$ 的范数数组 $\\{\\|H_{h_k}\\|_{L^2}\\}$ 和 $\\{\\|M_{h_k}\\|_{L^2}\\}$，并使用上述公式为每对连续的 $(k,k+1)$ 估计观测阶 $\\hat{p}_H^{(k)}$ 和 $\\hat{p}_M^{(k)}$。\n6. 实现一个自适应停止准则，当观测到的速率偏离预期的 $p$ 阶缩放行为时触发。给定一个容差 $\\varepsilon > 0$ 和一个预期阶数 $p_{\\text{exp}}$，如果存在任何连续对 $(k,k+1)$ 使得\n$$\n\\left| \\hat{p}_H^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon \\quad \\text{或} \\quad \\left| \\hat{p}_M^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon,\n$$\n则准则必须返回布尔值 $\\text{True}$，否则返回 $\\text{False}$。\n\n为保证科学真实性，请注意上述人工构造的代理约束与 ADM 约束的概念结构一致：哈密顿约束类似于作用于度规相关场的二阶导数算子，而动量约束类似于作用于曲率相关场的一阶散度型算子。在网格加密研究中，验证其残差的 $p$ 阶缩放是标准做法。\n\n由于问题在单位正方形上是纯无量纲的，因此不出现角度，也不需要物理单位。\n\n测试套件：\n实现以下四个参数案例来测试停止准则：\n- 案例 1 (理想情况): $p_H = 2$, $p_M = 2$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$, 网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n- 案例 2 (阶数不匹配): $p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$, 网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n- 案例 3 (噪声引起的偏差): $p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.2$, 网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$，以及具有固定振幅的附加约束测量噪声，以模拟欠解析污染。噪声必须直接添加到离散残余场中再计算范数，每个测试案例使用种子初始化的确定性伪随机数生成器，以确保可复现性。\n- 案例 4 (动量约束阶数不匹配): $p_H = 4$, $p_M = 2$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.3$, 网格尺寸 $\\{N_k\\} = \\{33, 65, 129\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个案例的停止准则的布尔结果，以逗号分隔并用方括号括起来（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k$ 是 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "问题要求实现一个针对人工构造代理约束的数值验证测试，这些约束与广义相对论的阿诺维特-德泽尔-米斯纳 (ADM) 形式体系中的约束相类似。核心任务是计算有限差分近似的收敛率，并应用一个自适应停止准则。\n\n首先，我们将问题形式化。我们给定一个标量场 $\\phi(x,y) = x^3 - 3 x y^2$ 和一个由流函数 $\\psi(x,y) = \\phi(x,y)$ 派生的向量场，其分量为 $v_x(x,y) = \\partial_y \\psi = -6 x y$ 和 $v_y(x,y) = -\\partial_x \\psi = -3 x^2 + 3 y^2$。这些场定义在单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上。\n\n代理约束是哈密顿约束，$H := \\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi$，和动量约束，$M := \\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$。从解析上讲，这些约束恒等于零。\n- 对于 $H$：$\\partial_x \\phi = 3x^2 - 3y^2 \\implies \\partial_{xx} \\phi = 6x$。$\\partial_y \\phi = -6xy \\implies \\partial_{yy} \\phi = -6x$。因此，$H = 6x - 6x = 0$。\n- 对于 $M$：$\\partial_x v_x = -6y$。$\\partial_y v_y = 6y$。因此，$M = -6y + 6y = 0$。\n\n任务是对这些微分算子在均匀的 $N \\times N$ 网格（间距为 $h = 1/(N-1)$）上进行离散化，并验证数值误差（表现为非零的残余约束 $H_h$ 和 $M_h$）以预期的速率 $p_{\\text{exp}}$ 收敛到零。\n\n离散化是使用中心有限差分来执行的。\n对于拉普拉斯算子 $\\Delta = \\partial_{xx} + \\partial_{yy}$，二阶导数使用以下方法近似：\n- $p=2$ 阶 (3点模板)：\n$$ \\partial_{xx} f(x,y) \\approx \\frac{f(x+h, y) - 2f(x,y) + f(x-h,y)}{h^2} $$\n- $p=4$ 阶 (5点模板)：\n$$ \\partial_{xx} f(x,y) \\approx \\frac{-f(x+2h, y) + 16f(x+h,y) - 30f(x,y) + 16f(x-h,y) - f(x-2h,y)}{12h^2} $$\n相同的模板适用于 $\\partial_{yy}$。\n\n对于散度 $\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$，一阶导数使用以下方法近似：\n- $p=2$ 阶 (3点模板)：\n$$ \\partial_{x} f(x,y) \\approx \\frac{f(x+h, y) - f(x-h,y)}{2h} $$\n- $p=4$ 阶 (5点模板)：\n$$ \\partial_{x} f(x,y) \\approx \\frac{-f(x+2h, y) + 8f(x+h,y) - 8f(x-h,y) + f(x-2h,y)}{12h} $$\n\n此分析中的一个关键步骤是检查这些模板应用于给定的特定多项式时的截断误差。一个 $p$ 阶格式的主阶截断误差与 $h^p$ 以及函数的高阶导数成比例。例如，二阶导数的二阶模板的主误差项与 $h^2 \\partial^4 f / \\partial x^4$ 成正比。四阶模板的误差与 $h^4 \\partial^6 f / \\partial x^6$ 成正比。类似地，一阶导数的二阶和四阶模板的主误差项分别与 $h^2 \\partial^3 f / \\partial x^3$ 和 $h^4 \\partial^5 f / \\partial x^5$ 成正比。\n\n让我们评估我们场的相应高阶导数：\n- 对于 $\\phi(x,y) = x^3 - 3xy^2$ (一个三次多项式)：所有 4 阶及以上导数均为零。\n- 对于 $v_x(x,y) = -6xy$ 和 $v_y(x,y) = -3x^2+3y^2$ (二次多项式)：所有 3 阶及以上导数均为零。\n\n这带来一个深远的结果：所有指定的有限差分格式对于这些特定的多项式都是精确的。主截断误差项，乃至所有后续项，都恒等于零。因此，离散残差 $H_h$ 和 $M_h$ 在浮点舍入误差范围内应为零，对于所有网格间距 $h$ 都是如此。\n\n因此，残差的 $L^2$ 范数，定义为 $\\|f_h\\|_{L^2} = (\\sum_{ij \\in \\text{int}} f_{ij}^2 h^2)^{1/2}$，将不会表现出预期的 $h^p$ 缩放行为。相反，对于案例 1、2 和 4，它将在机器精度附近徘徊。观测到的收敛阶，通过 $\\hat{p} = \\ln(E_1/E_2)/\\ln(h_1/h_2)$ 计算，将由这些近零范数的噪声比率主导，从而产生不接近理论阶数 $p$ 的不可预测值。\n\n这使我们能够预测停止准则检查的结果，该准则在 $|\\hat{p}_H - p_{\\text{exp}}| > \\varepsilon$ 或 $|\\hat{p}_M - p_{\\text{exp}}| > \\varepsilon$ 时触发。\n- **案例 1 ($p_{\\text{exp}}=2, \\varepsilon=0.3$):** 计算出的速率 $\\hat{p}_H, \\hat{p}_M$ 将是含噪的，并且不会持续接近 2。预计准则将被触发。结果：`True`。\n- **案例 2 ($p_{\\text{exp}}=2, \\varepsilon=0.3$):** 与案例 1 相同。速率将是含噪的。预计准则将被触发。结果：`True`。\n- **案例 3 ($p_{\\text{exp}}=4, \\varepsilon=0.2$, 含噪声):** 引入了一个附加的噪声基底，它主导了浮点误差。范数 $E_1$ 和 $E_2$ 将近似为常数，与 $h$ 无关。这导致 $E_1/E_2 \\approx 1$，因此 $\\ln(E_1/E_2) \\approx 0$，从而得到一个观测收敛率 $\\hat{p} \\approx 0$。由于 $|0 - 4| > 0.2$，准则将被触发。结果：`True`。\n- **案例 4 ($p_M=2, p_H=4, p_{\\text{exp}}=4, \\varepsilon=0.3$):** 两个离散约束都是精确为零的（在机器精度范围内）。观测到的速率将是含噪的，并且不接近 4。预计准则将被触发。结果：`True`。\n\n这个问题是对验证程序的一个复杂测试，它展示了一个常见的陷阱，即人工构造的解对于数值格式来说过于简单，从而导致一个误导性的（或者，在本例中是正确失败的）收敛测试。算法将按照指定计算范数并应用该准则。\n案例 3 中噪声的实现细节将是一个有种子的伪随机数生成器以确保可复现性，它会将一个固定的小振幅（例如，$10^{-10}$）的值添加到离散残余场中。",
            "answer": "```python\nimport numpy as np\n\ndef compute_laplacian(phi, h, p):\n    \"\"\"\n    Computes the discrete Laplacian of a 2D field `phi` with grid spacing `h`\n    using a finite difference scheme of order `p`.\n    \"\"\"\n    laplacian = np.zeros_like(phi)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for second derivative\n        # d2f/dx2 = (f_{i+1} - 2f_i + f_{i-1}) / h^2\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n        \n        d2phidx2[:, s:-s] = (phi[:, 2*s:] - 2*phi[:, s:-s] + phi[:, :-2*s]) / h**2\n        d2phidy2[s:-s, :] = (phi[2*s:, :] - 2*phi[s:-s, :] + phi[:-2*s, :]) / h**2\n        \n        laplacian = d2phidx2 + d2phidy2\n\n    elif p == 4:\n        # 5-point stencil for second derivative\n        # d2f/dx2 = (-f_{i+2} + 16f_{i+1} - 30f_i + 16f_{i-1} - f_{i-2}) / (12h^2)\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n\n        d2phidx2[:, s:-s] = (-phi[:, 2*s:] + 16*phi[:, s+1:-s+1] - 30*phi[:, s:-s] + 16*phi[:, s-1:-s-1] - phi[:, :-2*s]) / (12 * h**2)\n        d2phidy2[s:-s, :] = (-phi[2*s:, :] + 16*phi[s+1:-s+1, :] - 30*phi[s:-s, :] + 16*phi[s-1:-s-1, :] - phi[:-2*s, :]) / (12 * h**2)\n        \n        laplacian = d2phidx2 + d2phidy2\n    \n    return laplacian\n\ndef compute_divergence(vx, vy, h, p):\n    \"\"\"\n    Computes the discrete divergence of a 2D vector field (vx, vy) with grid\n    spacing `h` using a finite difference scheme of order `p`.\n    \"\"\"\n    divergence = np.zeros_like(vx)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for first derivative\n        # df/dx = (f_{i+1} - f_{i-1}) / (2h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (vx[:, 2*s:] - vx[:, :-2*s]) / (2 * h)\n        dvydy[s:-s, :] = (vy[2*s:, :] - vy[:-2*s, :]) / (2 * h)\n        \n        divergence = dvxdx + dvydy\n\n    elif p == 4:\n        # 5-point stencil for first derivative\n        # df/dx = (-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}) / (12h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (-vx[:, 2*s:] + 8*vx[:, s+1:-s+1] - 8*vx[:, s-1:-s-1] + vx[:, :-2*s]) / (12 * h)\n        dvydy[s:-s, :] = (-vy[2*s:, :] + 8*vy[s+1:-s+1, :] - 8*vy[s-1:-s-1, :] + vy[:-2*s, :]) / (12 * h)\n\n        divergence = dvxdx + dvydy\n\n    return divergence\n\ndef run_case(p_H, p_M, p_exp, epsilon, N_values, noise_params=None):\n    \"\"\"\n    Runs a single convergence test case and returns the stop criterion result.\n    \"\"\"\n    h_values = []\n    H_norms = []\n    M_norms = []\n\n    for N in N_values:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n        \n        # 1. Construct grid and evaluate analytic fields\n        grid_1d = np.linspace(0.0, 1.0, N)\n        x, y = np.meshgrid(grid_1d, grid_1d)\n        \n        phi = x**3 - 3*x*y**2\n        vx = -6*x*y\n        vy = -3*x**2 + 3*y**2\n        \n        # 2. Compute discrete proxy constraints\n        H_h = compute_laplacian(phi, h, p_H)\n        M_h = compute_divergence(vx, vy, h, p_M)\n\n        # 3. Add noise if applicable\n        if noise_params:\n            rng = np.random.default_rng(seed=noise_params['seed'])\n            amp = noise_params['amplitude']\n            H_h += rng.uniform(-amp, amp, size=H_h.shape)\n            M_h += rng.uniform(-amp, amp, size=M_h.shape)\n\n        # 4. Compute L2 norm over interior points\n        s_H = p_H // 2\n        interior_H = H_h[s_H:-s_H, s_H:-s_H]\n        norm_H = np.sqrt(np.sum(interior_H**2) * h**2)\n        H_norms.append(norm_H)\n        \n        s_M = p_M // 2\n        interior_M = M_h[s_M:-s_M, s_M:-s_M]\n        norm_M = np.sqrt(np.sum(interior_M**2) * h**2)\n        M_norms.append(norm_M)\n        \n    # 5. Estimate observed orders and check stop criterion\n    for k in range(len(N_values) - 1):\n        h1, h2 = h_values[k], h_values[k+1]\n        \n        # Avoid division by zero if norms are exactly zero\n        E1_H, E2_H = H_norms[k], H_norms[k+1]\n        p_hat_H = np.log(E1_H / E2_H) / np.log(h1 / h2) if E1_H > 0 and E2_H > 0 else 0\n\n        E1_M, E2_M = M_norms[k], M_norms[k+1]\n        p_hat_M = np.log(E1_M / E2_M) / np.log(h1 / h2) if E1_M > 0 and E2_M > 0 else 0\n        \n        if abs(p_hat_H - p_exp) > epsilon or abs(p_hat_M - p_exp) > epsilon:\n            return True\n            \n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, expected to fail check due to exactness)\n        {'p_H': 2, 'p_M': 2, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 2 (order mismatch)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 3 (noise-induced deviation)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 4, 'eps': 0.2, 'N': [33, 65, 129], 'noise': {'seed': 3, 'amplitude': 1e-10}},\n        # Case 4 (momentum mismatch)\n        {'p_H': 4, 'p_M': 2, 'p_exp': 4, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case['p_H'], case['p_M'], case['p_exp'], case['eps'], case['N'], case['noise'])\n        results.append(result)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "仅仅监测约束违反是不够的；在许多情况下，我们需要主动校正数据以满足物理约束，尤其是在构造初始数据时。这项实践将引导你从被动的误差分析转向主动的误差修正，通过实现一个约束投影步骤来净化不满足约束的初始构型。你将推导并求解一个椭圆型方程 ，这模拟了求解爱因斯坦约束方程的实际过程，是生成有效初始数据的关键技术。",
            "id": "3470000",
            "problem": "考虑在共形分解下表述的广义相对论 (GR) 中的哈密顿约束，其中共形因子中的约束违反通过椭圆求解投影到约束流形上来进行校正。在一个二维、平坦的单位正方形区域 $[0,1]\\times[0,1]$ 上的科学一致的简化模型中，采用以下模仿共形 Lichnerowicz 型方程结构的约束泛函：\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y),\n$$\n其中 $\\phi$ 是共形因子，$\\Delta$ 是 $\\mathbb{R}^2$ 上的拉普拉斯算子，$\\beta \\ge 0$ 是一个控制非线性的常数参数，而 $S(x,y)$ 是一个由给定的外在曲率和物质项构成的光滑源。在边界 $\\partial([0,1]\\times[0,1])$ 上施加齐次狄利克雷边界条件 $\\,\\phi=0\\,$。\n\n将源定义为\n$$\nS(x,y) = A\\,\\sin(2\\pi x)\\sin(2\\pi y) + B\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2+(y-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\n其中参数为 $A$、$B$、$\\sigma>0$。使用一个均匀网格，每个空间维度有 $N$ 个内部点，因此网格间距为 $h = \\frac{1}{N+1}$，内部网格点为 $(x_i,y_j) = (ih,jh)$，其中 $i,j \\in \\{1,2,\\dots,N\\}$。\n\n令初始共形因子为\n$$\n\\phi_0(x,y) = \\varepsilon\\,\\sin(\\pi x)\\sin(\\pi y),\n$$\n其中参数 $\\varepsilon \\ge 0$。目标是提出并实现一个约束投影步骤，该步骤通过求解由当前 $\\phi$ 附近的 $H(\\phi)$ 线性化推导出的单个椭圆方程来计算修正量 $\\delta\\phi$，然后更新 $\\phi \\leftarrow \\phi + \\delta\\phi$。在此投影之后，评估哈密顿约束的离散范数的减小量。\n\n从基本定义和原理出发，执行以下操作：\n- 通过计算 $H(\\phi)$ 关于 $\\phi$ 的弗雷歇导数 (Fréchet derivative) 并在当前 $\\phi$ 处求值，推导作用于修正量 $\\delta\\phi$ 的线性化椭圆算子。使用此算子定义必须在具有齐次狄利克雷边界条件的网格上求解的 $\\delta\\phi$ 的约束投影方程。\n- 使用二阶中心差分在内部网格上对算子进行离散化，并对拉普拉斯算子使用标准的五点模板。通过在 $\\partial([0,1]\\times[0,1])$ 上的网格点处强制 $\\,\\phi=0\\,$ 来处理边界。\n- 计算内部网格上哈密顿约束残差的离散 $L^2$ 范数，\n$$\n\\lVert H \\rVert_{h} = \\sqrt{h^2 \\sum_{i=1}^N \\sum_{j=1}^N \\left(H_{ij}\\right)^2},\n$$\n在投影步骤前后均进行计算，并报告减小比率\n$$\nr = \\frac{\\lVert H(\\phi_{\\text{after}})\\rVert_{h}}{\\lVert H(\\phi_{\\text{before}})\\rVert_{h}}.\n$$\n如果 $\\lVert H(\\phi_{\\text{before}})\\rVert_{h}$ 在数值上为零（例如，小于某个固定容差如 $10^{-14}$），则定义 $r=0$。\n\n您的程序必须实现此投影，并为以下每个测试用例计算 $r$，涵盖各种情况，包括线性和非线性约束、粗网格和细网格以及不同的源振幅。对于每个用例，使用内部网格尺寸 $N$、初始振幅 $\\varepsilon$、非线性参数 $\\beta$ 和源参数 $A$、$B$、$\\sigma$：\n\n1. $N=32$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$。\n2. $N=8$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$。\n3. $N=32$, $\\varepsilon=0.0$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$。\n4. $N=32$, $\\varepsilon=0.1$, $\\beta=0.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$。\n5. $N=64$, $\\varepsilon=0.2$, $\\beta=10.0$, $A=0.5$, $B=1.0$, $\\sigma=0.10$。\n\n您的程序应生成单行输出，其中包含五个减小比率，形式为一个用方括号括起来的逗号分隔列表，每个比率表示为四舍五入到小数点后六位的小数（例如，$[0.123456,0.000001,0.987654,0.100000,0.250000]$）。此问题不涉及角度或物理单位。使用精确的浮点运算来计算由椭圆方程产生的线性系统的范数和解。通过使用适用于稀疏、对称正定系统的适当方法精确求解线性系统，确保科学真实性。",
            "solution": "该问题要求为简化的哈密顿约束方程实现单个约束投影步骤，这来自数值相对论。该步骤等价于求解非线性椭圆偏微分方程的牛顿-拉夫逊方法（Newton-Raphson method）的一次迭代。任务的核心是推导并离散化修正量的线性化方程，求解得到的线性系统，并评估约束违背的减小程度。\n\n首先，我们推导修正项 $\\delta\\phi$ 的椭圆方程。哈密顿约束泛函给出如下：\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y).\n$$\n我们给定一个共形因子的初始状态 $\\phi_0$，它不一定满足约束，即 $H(\\phi_0) \\neq 0$。我们寻求一个修正量 $\\delta\\phi$，使得新场 $\\phi = \\phi_0 + \\delta\\phi$ 更好地逼近一个解，即 $H(\\phi_0 + \\delta\\phi) \\approx 0$。为了找到 $\\delta\\phi$，我们通过计算其弗雷歇导数 (Fréchet derivative) 将泛函 $H(\\phi)$ 在 $\\phi_0$ 周围线性化。对于小的 $\\delta\\phi$，$H(\\phi_0 + \\delta\\phi)$ 的展开式为：\n$$\nH(\\phi_0 + \\delta\\phi) = -8\\,\\Delta (\\phi_0 + \\delta\\phi) + \\beta\\,(\\phi_0 + \\delta\\phi)^5 - S(x,y).\n$$\n对非线性项使用二项式展开，$(\\phi_0 + \\delta\\phi)^5 = \\phi_0^5 + 5\\phi_0^4\\delta\\phi + \\mathcal{O}((\\delta\\phi)^2)$，并保留 $\\delta\\phi$ 的一阶项，我们得到：\n$$\nH(\\phi_0 + \\delta\\phi) \\approx \\left(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S\\right) + \\left(-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi\\right).\n$$\n该表达式可以写成 $H(\\phi_0 + \\delta\\phi) \\approx H(\\phi_0) + L_{\\phi_0}[\\delta\\phi]$，其中 $L_{\\phi_0}$ 是作用于修正量 $\\delta\\phi$ 的线性化算子：\n$$\nL_{\\phi_0}[\\delta\\phi] = -8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi.\n$$\n约束投影方程将 $H(\\phi_0 + \\delta\\phi)$ 的线性化表达式设为零：\n$$\nL_{\\phi_0}[\\delta\\phi] = -H(\\phi_0).\n$$\n代入 $L_{\\phi_0}$ 和 $H(\\phi_0)$ 的表达式，我们得到修正量 $\\delta\\phi$ 的椭圆偏微分方程：\n$$\n-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\,\\delta\\phi = -(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S) = 8\\,\\Delta \\phi_0 - \\beta\\,\\phi_0^5 + S.\n$$\n该方程必须在单位正方形区域 $[0,1]\\times[0,1]$ 上求解 $\\delta\\phi$，并采用齐次狄利克雷边界条件 $\\delta\\phi = 0$ on the boundary $\\partial([0,1]\\times[0,1])$，因为总场 $\\phi$ 必须在边界上满足 $\\phi=0$，且初始场 $\\phi_0$ 的构造已满足此条件。\n\n接下来，我们在均匀网格上离散化此方程。区域在每个维度上用 $N$ 个内部点进行离散化，网格间距为 $h = 1/(N+1)$。内部网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{1, \\dots, N\\}$。函数 $f(x,y)$ 由其在该网格上的值 $f_{ij}$ 表示。我们对拉普拉斯算子 $\\Delta$ 使用二阶精度的五点模板：\n$$\n(\\Delta f)_{ij} \\approx \\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4f_{ij}}{h^2}.\n$$\n将此离散化应用于每个内部点 $(i,j)$ 上的 $\\delta\\phi$ 方程，产生一个包含 $N^2$ 个线性代数方程的系统：\n$$\n-8\\frac{\\delta\\phi_{i+1,j} + \\delta\\phi_{i-1,j} + \\delta\\phi_{i,j+1} + \\delta\\phi_{i,j-1} - 4\\delta\\phi_{ij}}{h^2} + 5\\beta\\,\\phi_{0,ij}^4\\,\\delta\\phi_{ij} = -H(\\phi_0)_{ij}.\n$$\n这里，$\\delta\\phi_{ij}$ 是未知数，$\\phi_{0,ij}$ 是初始场的已知值，而 $H(\\phi_0)_{ij}$ 是原始约束的离散化残差，计算方式为\n$$\nH(\\phi_0)_{ij} = -8(\\Delta\\phi_0)_{ij} + \\beta\\,\\phi_{0,ij}^5 - S_{ij},\n$$\n其中 $(\\Delta\\phi_0)_{ij}$ 也使用五点模板计算。齐次狄利克雷边界条件通过将任何索引 $i$ 或 $j$ 等于 $0$ 或 $N+1$ 的 $\\phi_0$ 和 $\\delta\\phi$ 设置为 $0$ 来强制执行。\n\n该方程组可以写成矩阵形式 $M \\vec{d} = \\vec{b}$，其中 $\\vec{d}$ 是一个长度为 $N^2$ 的向量，由扁平化的未知数网格 $\\delta\\phi_{ij}$ 形成，$\\vec{b}$ 是一个同样大小的向量，由扁平化的 $-H(\\phi_0)_{ij}$ 形成。矩阵 $M$ 是一个大小为 $N^2 \\times N^2$ 的稀疏、对称、正定矩阵。其结构源于离散化的算子 $L_{\\phi_0}$。对角线元素为 $(\\frac{32}{h^2} + 5\\beta\\,\\phi_{0,ij}^4)$，非零的非对角线元素为 $-\\frac{8}{h^2}$，对应于网格上四个最近的邻居。由于其性质，这个线性系统可以可靠且高效地求解 $\\vec{d}$。\n\n对于给定的一组参数，计算减小比率 $r$ 的总体算法如下：\n1.  构建 $N \\times N$ 的内部网格，并在每个网格点上评估初始场 $\\phi_{0,ij}$ 和源函数 $S_{ij}$。\n2.  使用填充网格以强制执行边界条件，计算初始场的离散拉普拉斯算子 $(\\Delta\\phi_0)_{ij}$。\n3.  计算初始哈密顿残差场 $H(\\phi_0)_{ij}$。\n4.  计算初始残差的离散 $L^2$ 范数 $\\lVert H(\\phi_0)\\rVert_h = \\sqrt{h^2 \\sum_{i,j=1}^N (H(\\phi_0)_{ij})^2}$。如果此范数小于容差 $10^{-14}$，则比率 $r$ 定义为 $0$。\n5.  否则，构建代表离散化线性算子 $L_{\\phi_0}$ 的 $N^2 \\times N^2$ 稀疏矩阵 $M$，以及通过扁平化 $-H(\\phi_0)_{ij}$ 得到的右端向量 $\\vec{b}$。\n6.  求解线性系统 $M \\vec{d} = \\vec{b}$，得到扁平化的修正向量 $\\vec{d}$。\n7.  将 $\\vec{d}$ 重塑为一个 $N \\times N$ 的矩阵，代表修正量 $\\delta\\phi_{ij}$。\n8.  计算更新后的场 $\\phi_{\\text{after}, ij} = \\phi_{0,ij} + \\delta\\phi_{ij}$。\n9.  通过将离散哈密顿算子应用于 $\\phi_{\\text{after}}$ 来计算最终的哈密顿残差 $H(\\phi_{\\text{after}})$。\n10. 计算最终残差的范数 $\\lVert H(\\phi_{\\text{after}})\\rVert_h$。\n11. 减小比率为 $r = \\lVert H(\\phi_{\\text{after}})\\rVert_h / \\lVert H(\\phi_0)\\rVert_h$。\n\n此过程应用于每个测试用例，以确定约束投影步骤的有效性。对于线性情况 $\\beta=0$，这一单步预计将精确求解方程，得到一个最终残差和比率约等于零，其精度仅受浮点运算精度限制。对于非线性情况，该比率量化了牛顿-拉夫逊步骤的二次收敛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_hamiltonian(phi_interior, S_interior, beta, h, N):\n    \"\"\"Computes the discrete Hamiltonian residual H(phi).\"\"\"\n    phi_padded = np.zeros((N + 2, N + 2))\n    phi_padded[1:-1, 1:-1] = phi_interior\n    \n    # Second-order central difference for the Laplacian\n    lap_phi = (phi_padded[2:, 1:-1] + phi_padded[:-2, 1:-1] +\n               phi_padded[1:-1, 2:] + phi_padded[1:-1, :-2] -\n               4 * phi_interior) / (h**2)\n               \n    # H(phi) = -8*Delta(phi) + beta*phi^5 - S\n    H_val = -8 * lap_phi + beta * (phi_interior**5) - S_interior\n    return H_val\n\ndef compute_norm(H_val, h):\n    \"\"\"Computes the discrete L2 norm of the residual.\"\"\"\n    # norm = sqrt(h^2 * sum(H_ij^2)) = h * ||H||_Frobenius\n    return h * np.linalg.norm(H_val)\n\ndef compute_ratio_for_case(N, epsilon, beta, A, B, sigma):\n    \"\"\"\n    Solves a single test case for the constraint projection problem.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define initial conformal factor phi_0 and source S on the interior grid\n    phi0_interior = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    S_interior = A * np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + \\\n                 B * np.exp(-((xx - 0.5)**2 + (yy - 0.5)**2) / (2 * sigma**2))\n\n    # Calculate Hamiltonian residual and norm before projection\n    H_before = compute_hamiltonian(phi0_interior, S_interior, beta, h, N)\n    norm_before = compute_norm(H_before, h)\n\n    # Handle the case where the initial residual is numerically zero\n    if norm_before  1e-14:\n        return 0.0\n\n    # Set up the linear system M * d_phi = -H_before for the correction d_phi\n    \n    # The matrix M represents the linearized operator L = -8*Delta + 5*beta*phi_0^4\n    # We construct it using the Kronecker product for the 2D Laplacian.\n    N2 = N * N\n    # 1D Laplacian matrix (size N x N)\n    D1_matrix = diags([1, -2, 1], [-1, 0, 1], shape=(N, N))\n    I_N = identity(N)\n    \n    # 2D Laplacian matrix (size N^2 x N^2)\n    Lap_matrix_2D = (kron(I_N, D1_matrix) + kron(D1_matrix, I_N)) / h**2\n    \n    # Operator matrix M\n    M = -8 * Lap_matrix_2D\n    \n    # Add the potential term (diagonal matrix)\n    potential_term_flat = 5 * beta * (phi0_interior.flatten()**4)\n    M += diags(potential_term_flat, 0)\n    \n    # Right-hand side vector\n    b = -H_before.flatten()\n    \n    # Solve the sparse linear system for the correction d_phi\n    delta_phi_flat = spsolve(M, b)\n    delta_phi_interior = delta_phi_flat.reshape((N, N))\n    \n    # Update the field: phi_after = phi_0 + d_phi\n    phi_after_interior = phi0_interior + delta_phi_interior\n    \n    # Calculate Hamiltonian residual and norm after projection\n    H_after = compute_hamiltonian(phi_after_interior, S_interior, beta, h, N)\n    norm_after = compute_norm(H_after, h)\n    \n    # Compute the reduction ratio\n    ratio = norm_after / norm_before\n    \n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, beta, A, B, sigma)\n        (32, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (8, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.0, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.1, 0.0, 1.0, 0.5, 0.15),\n        (64, 0.2, 10.0, 0.5, 1.0, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = compute_ratio_for_case(*case)\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}