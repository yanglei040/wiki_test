{
    "hands_on_practices": [
        {
            "introduction": "Gravitational wave memory can arise from the anisotropic emission of any form of stress-energy, not just from gravitational waves themselves. This \"linear memory\" is sourced by outflows of massless particles like photons or neutrinos. This exercise provides analytical practice by connecting theory to a powerful astrophysical source, asking you to derive the expected memory signal from the collimated jets of a Gamma-Ray Burst (GRB) within the framework of linearized gravity .",
            "id": "3476185",
            "problem": "A Gamma-Ray Burst (GRB) central engine launches two identical, ultrarelativistic conical jets whose axes are antiparallel and aligned with the $\\hat{z}$ axis. Each jet has total (beaming-corrected) energy $E_{\\mathrm{j}}$ carried by effectively massless ejecta confined within a cone of half-opening angle $\\theta_{\\mathrm{j}} \\ll 1$, with uniform energy per unit solid angle within each cone and negligible energy outside. The emission is impulsive on timescales short compared to the light travel time across the source, so the time-domain gravitational waveform can be approximated by a step-like change (the gravitational-wave linear memory). The source is at a luminosity distance $D$, and the observer’s line of sight is taken to be along the $\\hat{x}$ axis (i.e., perpendicular to the jet axes), which maximizes the observed memory amplitude over viewing angle. Work in linearized General Relativity (GR) in the far zone, and model the outflow as null energy to future null infinity.\n\nStarting from the far-zone solution of the linearized Einstein field equations sourced by stress-energy flux to null infinity and its Transverse-Traceless (TT) projection, derive the leading small-$\\theta_{\\mathrm{j}}$ expression for the jet-induced linear memory step in the plus polarization, $\\Delta h_{+}$, as seen by this observer. Keep terms through $\\mathcal{O}(\\theta_{\\mathrm{j}}^{2})$ and assume both jets contribute additively. Then, using your expression, compute an upper bound on $|\\Delta h_{+}|$ for the following typical GRB-jet parameters:\n- $E_{\\mathrm{j}} = 1.0 \\times 10^{51}\\ \\mathrm{erg}$,\n- $\\theta_{\\mathrm{j}} = 0.10\\ \\mathrm{rad}$,\n- $D = 1.0\\ \\mathrm{Gpc}$.\n\nExpress the final amplitude as a pure number (dimensionless strain) and round your answer to three significant figures.",
            "solution": "...",
            "answer": "$$\n\\boxed{2.13 \\times 10^{-25}}\n$$"
        },
        {
            "introduction": "Beyond the linear effect, General Relativity predicts a more subtle \"nonlinear\" memory, sourced by the gravitational waves themselves. Because GWs carry energy, they act as a source of gravity, permanently altering the spacetime geometry as they propagate outwards. This exercise delves into this quintessentially nonlinear phenomenon, known as spin memory, by having you numerically compute the permanent strain from the integrated energy flux of a wave burst .",
            "id": "2399205",
            "problem": "You are asked to write a complete, runnable program that models the gravitational-wave memory effect from a compact-binary-like burst, by numerically integrating the energy flux of a prescribed gravitational wave signal to determine the permanent displacement of test masses. Begin from fundamental and well-tested bases: the Isaacson effective stress-energy tensor for far-zone gravitational waves in General Relativity (GR) and the geodesic deviation response of a free arm to a quasi-static change in plus-polarized strain. Do not assume any specialized formula for the memory a priori; derive what you need from these bases.\n\nAssumptions and fundamental bases:\n- Work in the far-field, plane-wave, transverse-traceless approximation. Let $h_+(t)$ and $h_{\\times}(t)$ denote the two metric polarization strains measured at the detector location along a normal-incidence beam.\n- Use the Isaacson energy flux (power per unit area) carried by the wave,\n$$\nF(t) \\;=\\; \\frac{c^3}{16\\pi G}\\Big(\\dot{h}_+^2(t)+\\dot{h}_{\\times}^2(t)\\Big),\n$$\nwhere $G$ is Newton’s gravitational constant and $c$ is the speed of light, and $\\dot{h}$ denotes the time derivative of $h$.\n- For a detector arm aligned with the plus polarization basis, a quasi-static net change $\\Delta h_+$ in the plus strain produces a permanent displacement $\\Delta L$ given by\n$$\n\\frac{\\Delta L}{L} \\;=\\; \\frac{1}{2}\\,\\Delta h_+,\n$$\nwhere $L$ is the arm length. Take the detector plane to be orthogonal to the propagation direction and the arm exactly aligned with the plus polarization.\n\nDerive, from the above bases and the $1/R$ amplitude scaling in the far zone together with energy conservation at null infinity, the simplest line-of-sight, plane-wave relation that connects the time-integral of the measured flux to the nonlinear spin memory in the plus polarization along the line of sight. Use that relation to compute the permanent displacement $\\Delta L$.\n\nSignal model and numerical specifications:\n- Use a uniform time grid $t \\in [-0.5,\\,0.5]$ seconds with step $\\Delta t = 10^{-4}$ seconds.\n- For a given case, define\n$$\nh_+(t) \\;=\\; A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\cos\\!\\big(2\\pi f_0 t\\big),\\qquad\nh_{\\times}(t) \\;=\\; \\epsilon\\,A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\sin\\!\\big(2\\pi f_0 t\\big),\n$$\nwhere $A$ is a strain amplitude (dimensionless), $\\sigma$ is the Gaussian width in seconds, $f_0$ is a carrier frequency in hertz, and $\\epsilon \\in \\{0,1\\}$ toggles the presence of cross polarization.\n- Compute $\\dot{h}_+$ and $\\dot{h}_{\\times}$ with respect to time $t$ in seconds. You may do this analytically from the formulae above or numerically with a stable finite-difference scheme.\n- Numerically integrate any time integrals using the trapezoidal rule.\n- Use the following constants in International System of Units (SI): $G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$, $c = 2.99792458\\times 10^8\\,\\mathrm{m\\,s^{-1}}$, $1\\,\\mathrm{pc} = 3.085677581491367\\times 10^{16}\\,\\mathrm{m}$.\n\nOutput quantity and units:\n- For each test case, output the final permanent displacement $\\Delta L$ in meters, as a floating-point number.\n\nTest suite:\nFor all cases, use arm length $L = 4000$ meters and distance $R = 100$ megaparsecs, where $1\\,\\mathrm{Mpc} = 10^6\\,\\mathrm{pc}$. The four cases are:\n1. Case A (circularly polarized burst): $A = 1.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n2. Case B (no signal): $A = 0.0$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n3. Case C (plus-only burst): $A = 1.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 0$, $R = 100$.\n4. Case D (stronger circular burst): $A = 2.0\\times 10^{-21}$, $f_0 = 150$, $\\sigma = 0.05$, $\\epsilon = 1$, $R = 100$.\n\nAll physical inputs are in SI units except distances quoted in megaparsecs, which you must convert to meters using the parsec definition above.\n\nFinal output format:\nYour program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets (for example, like $[x_1,x_2,x_3,x_4]$). Each $x_i$ must be a floating-point number giving $\\Delta L$ in meters.",
            "solution": "The problem posed is a valid exercise in computational physics, grounded in the principles of General Relativity. It requires the numerical calculation of the nonlinear gravitational-wave memory effect for a simplified burst signal. We will first establish the theoretical basis and the specific formula to be implemented, then proceed with the numerical solution as specified.\n\nThe problem asks for a derivation of the relationship between the measured gravitational wave energy flux and the permanent change in strain, $\\Delta h_+$, known as the spin memory. This effect arises from the fact that gravitational waves carry energy and momentum, and thus gravitate themselves. The stress-energy of the wave, as described by the Isaacson tensor, acts as a source in the Einstein field equations, generating a second-order, non-oscillatory component of the metric perturbation which persists after the wave has passed.\n\nThe Isaacson energy flux is given by:\n$$\nF(t) = \\frac{c^3}{16\\pi G}\\left(\\dot{h}_+^2(t)+\\dot{h}_{\\times}^2(t)\\right)\n$$\nThis represents the total energy per unit area per unit time carried by the wave. The memory effect, however, is sensitive to the anisotropy of the radiation. For an observer along the line of propagation, the permanent change in the plus-polarized strain, $\\Delta h_+$, is sourced by the anisotropic part of the wave's stress.\n\nA rigorous derivation involves solving the second-order Einstein equations with the Isaacson tensor as a source. This procedure is complex. However, the problem requests the \"simplest line-of-sight, plane-wave relation\". A well-established result from such analyses connects the spin memory to the time integral of the difference between the \"power\" in the two polarizations. This formulation correctly captures the physical expectation that a purely circularly polarized wave (which is axisymmetric about the propagation direction) should not produce this type of memory along its axis.\n\nThe appropriate relationship, expressed in terms of the strain components measured at a distance $R$ from the source, is:\n$$\n\\Delta h_+ = \\frac{R}{2c} \\int_{-\\infty}^{\\infty} \\left( \\dot{h}_+^2(t) - \\dot{h}_{\\times}^2(t) \\right) dt\n$$\nThis formula is dimensionally correct. The strain $h$ is dimensionless, so $\\dot{h}$ has units of $s^{-1}$. The integral has units of $s^{-1}$. The prefactor $R/c$ has units of $s$, rendering $\\Delta h_+$ dimensionless. The physical scaling is also correct: for a source at distance $R$, the strain amplitude $h \\propto 1/R$, so $\\dot{h}^2 \\propto 1/R^2$. The integral term thus scales as $1/R^2$, and the overall $\\Delta h_+ \\propto (R) \\cdot (1/R^2) = 1/R$, as expected for a metric perturbation from a distant source.\n\nHaving established the key formula, we proceed to the numerical implementation.\nThe signal components are:\n$$\nh_+(t) = A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\cos\\left(\\omega_0 t\\right)\n$$\n$$\nh_{\\times}(t) = \\epsilon\\,A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\sin\\left(\\omega_0 t\\right)\n$$\nwhere $\\omega_0 = 2\\pi f_0$. Let the envelope be $E(t) = A\\,\\exp(-t^2/(2\\sigma^2))$.\nTheir time derivatives are calculated analytically using the product rule:\n$$\n\\dot{h}_+(t) = \\dot{E}(t)\\cos(\\omega_0 t) - \\omega_0 E(t)\\sin(\\omega_0 t)\n$$\n$$\n\\dot{h}_{\\times}(t) = \\epsilon \\left( \\dot{E}(t)\\sin(\\omega_0 t) + \\omega_0 E(t)\\cos(\\omega_0 t) \\right)\n$$\nwhere $\\dot{E}(t) = - \\frac{t}{\\sigma^2} E(t)$.\n\nThe algorithm is as follows:\n1.  Define the physical constants $G$, $c$, and the conversion factor for parsecs to meters.\n2.  Set up the time grid $t$ from $-0.5\\,s$ to $0.5\\,s$ with step $\\Delta t = 10^{-4}\\,s$.\n3.  For each test case with parameters $(A, f_0, \\sigma, \\epsilon, R, L)$:\n    a. Convert the distance $R$ from megaparsecs to meters.\n    b. Define the envelope function $E(t)$ and its derivative $\\dot{E}(t)$ on the time grid.\n    c. Calculate the arrays for $\\dot{h}_+(t)$ and $\\dot{h}_{\\times}(t)$ using the analytical formulae above.\n    d. Compute the integrand $I(t) = \\dot{h}_+^2(t) - \\dot{h}_{\\times}^2(t)$.\n    e. Numerically integrate $I(t)$ over the time grid using the trapezoidal rule to find $\\int I(t) dt$.\n    f. Calculate the permanent strain change $\\Delta h_+ = \\frac{R}{2c} \\int I(t) dt$.\n    g. Finally, compute the permanent displacement of the detector arm: $\\Delta L = \\frac{1}{2} L \\Delta h_+$.\n4.  Collect the results for all test cases and present them in the specified format.\n\nFor Case A (circular polarization, $\\epsilon=1$), the integrand $\\dot{h}_+^2 - \\dot{h}_{\\times}^2$ becomes a sum of terms modulated by $\\cos(2\\omega_0 t)$ and $\\sin(2\\omega_0 t)$. As the carrier frequency $f_0=150\\,Hz$ is much higher than the envelope's characteristic frequency ($1/\\sigma = 20\\,Hz$), the integral over these rapidly oscillating terms is expected to be very close to zero. The same applies to Case D. For Case B, the amplitude $A=0$, so the result is trivially zero. For Case C (linear polarization, $\\epsilon=0$), $\\dot{h}_{\\times}=0$, and the integrand is simply $\\dot{h}_+^2$, which is strictly non-negative. Its integral will be non-zero, yielding a measurable memory effect.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational-wave memory effect for several test cases.\n    \"\"\"\n\n    # Physical Constants in SI units\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 2.99792458e8   # m s^-1\n    PC_TO_M = 3.085677581491367e16  # meters per parsec\n\n    # Shared parameters for all test cases\n    L_arm = 4000.0  # meters\n    R_dist_mpc = 100.0  # megaparsecs\n    R_dist_m = R_dist_mpc * 1e6 * PC_TO_M\n\n    # Numerical grid specifications\n    t_start = -0.5  # seconds\n    t_end = 0.5    # seconds\n    dt = 1e-4      # seconds\n    t = np.arange(t_start, t_end + dt, dt)\n\n    # Test suite: (A, f0, sigma, epsilon)\n    test_cases = [\n        # Case A: Circularly polarized burst\n        (1.0e-21, 150.0, 0.05, 1.0),\n        # Case B: No signal\n        (0.0, 150.0, 0.05, 1.0),\n        # Case C: Plus-only burst\n        (1.0e-21, 150.0, 0.05, 0.0),\n        # Case D: Stronger circular burst\n        (2.0e-21, 150.0, 0.05, 1.0),\n    ]\n\n    results = []\n    \n    for A, f0, sigma, epsilon in test_cases:\n        # If amplitude is zero, result is trivially zero\n        if A == 0.0:\n            results.append(0.0)\n            continue\n            \n        omega0 = 2.0 * np.pi * f0\n\n        # Define Gaussian envelope and its derivative\n        # E(t) = A * exp(-t^2 / (2*sigma^2))\n        envelope_t = A * np.exp(-t**2 / (2.0 * sigma**2))\n        \n        # dE/dt = - (t/sigma^2) * E(t)\n        envelope_dot_t = -(t / sigma**2) * envelope_t\n\n        # Calculate time derivatives of h_plus and h_cross\n        # h_plus(t) = envelope(t) * cos(omega0 * t)\n        # h_cross(t) = epsilon * envelope(t) * sin(omega0 * t)\n        \n        cos_t = np.cos(omega0 * t)\n        sin_t = np.sin(omega0 * t)\n        \n        # dh_plus/dt = dE/dt * cos(omega0*t) - omega0 * E(t) * sin(omega0*t)\n        h_plus_dot_t = envelope_dot_t * cos_t - omega0 * envelope_t * sin_t\n        \n        # dh_cross/dt = epsilon * (dE/dt * sin(omega0*t) + omega0 * E(t) * cos(omega0*t))\n        h_cross_dot_t = epsilon * (envelope_dot_t * sin_t + omega0 * envelope_t * cos_t)\n\n        # Integrand for memory calculation\n        # I(t) = (dh_plus/dt)^2 - (dh_cross/dt)^2\n        integrand = h_plus_dot_t**2 - h_cross_dot_t**2\n\n        # Numerically integrate using the trapezoidal rule\n        integral_val = np.trapz(integrand, t, dx=dt)\n        \n        # Calculate the permanent strain change (memory)\n        # Delta_h_plus = (R / (2*c)) * integral_val\n        delta_h_plus = (R_dist_m / (2.0 * c)) * integral_val\n\n        # Calculate the permanent arm displacement\n        # Delta_L = (1/2) * L * Delta_h_plus\n        delta_L = 0.5 * L_arm * delta_h_plus\n        \n        results.append(delta_L)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Extracting a clean physical signal from the output of a numerical relativity simulation is a critical skill that involves navigating various numerical artifacts. A primary challenge in recovering the gravitational wave strain $h$ is the numerical drift introduced by twice integrating the Weyl scalar $\\Psi_4$. This exercise simulates this exact workflow, providing hands-on practice in fitting and subtracting these artificial trends to reliably measure the physical memory effect hidden within the raw data .",
            "id": "3476243",
            "problem": "You are tasked with designing and implementing a numerical procedure to assess gravitational wave memory contamination arising from numerical drift when reconstructing strain from the Newman–Penrose scalar. The physical and numerical context is as follows.\n\nFundamental base and definitions:\n- At future null infinity in the Transverse–Traceless (TT) gauge, the Newman–Penrose scalar $\\,\\Psi_4(u)\\,$ equals the negative second time derivative of the complex gravitational-wave strain $\\,h(u) = h_+(u) - i h_{\\times}(u)\\,$, i.e.,\n$$\\Psi_4(u) \\;=\\; -\\,\\frac{d^2 h(u)}{du^2}.$$\n- The gravitational-wave memory is the permanent displacement characterized by the net change in the real part of the strain across the burst:\n$$\\Delta h \\;=\\; \\lim_{u\\to +\\infty} \\mathrm{Re}\\,h(u) \\;-\\; \\lim_{u\\to -\\infty} \\mathrm{Re}\\,h(u).$$\n- In numerical relativity, one reconstructs $\\,h(u)\\,$ from $\\,\\Psi_4(u)\\,$ by double time-integration, but unknown integration constants induce a linear trend (numerical drift) $\\,d_0 + d_1 u\\,$ in the reconstructed strain. A standard mitigation is to fit and subtract this drift using data outside the burst (no-signal windows).\n\nYour program must:\n1. Construct synthetic test data $\\,\\Psi_4(u)\\,$ from a physically motivated $\\,h(u)\\,$ that contains a smooth memory step and an optional oscillatory component, then add Gaussian noise to $\\,\\Psi_4(u)\\,$.\n2. Reconstruct a preliminary strain $\\,h_{\\mathrm{raw}}(u)\\,$ by double integrating $\\,\\Psi_4(u)\\,$ with zero initial conditions (i.e., causal integrals with $\\,h(u_0)=0\\,$ and $\\,\\dot{h}(u_0)=0\\,$).\n3. Fit and subtract the linear drift model $\\,d_0 + d_1 u\\,$ from $\\,h_{\\mathrm{raw}}(u)\\,$ using least squares on the union of two no-signal time windows that exclude the burst.\n4. Estimate the recovered memory as the difference between the mean corrected strain $\\,h_{\\mathrm{corr}}(u)\\,$ at late and early times, and quantify contamination as the absolute error between the recovered and the true memory amplitude.\n\nSignal model and construction details:\n- Use retarded time $\\,u\\,$ in seconds and produce dimensionless strain quantities.\n- Define the smooth memory step using the error function:\n$$S(u) \\;=\\; \\tfrac{1}{2}\\,\\Bigl[1 + \\mathrm{erf}\\Bigl(\\frac{u-u_c}{\\sqrt{2}\\,\\sigma}\\Bigr)\\Bigr].$$\nLet the true memory be $\\,\\Delta h\\,$, so the memory contribution to strain is $\\,h_{\\mathrm{mem}}(u) = \\Delta h\\,S(u)\\,$. Its second derivative is\n$$\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{d^2 S}{du^2}(u) \\;=\\; -\\,\\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr),$$\nso the memory part of $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr).$$\n- Optionally include an oscillatory contribution to the strain\n$$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr),$$\nwith Gaussian envelope of width $\\,\\tau\\,$. Denoting $\\,f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)\\,$, $\\,s(u)=\\sin(\\omega u)\\,$, one has $\\,f'(u) = -\\frac{u-u_c}{\\tau^2} f(u)\\,$ and $\\,f''(u) = \\bigl(\\frac{(u-u_c)^2}{\\tau^4}-\\frac{1}{\\tau^2}\\bigr)f(u)\\,$, as well as $\\,s''(u) = -\\omega^2 s(u)\\,$. Therefore,\n$$\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; A\\Bigl[f''(u)\\,s(u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,s(u)\\Bigr],$$\nand the oscillatory part of $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; -A\\,f''(u)\\,s(u)\\;-\\;2A\\,\\omega f'(u)\\cos(\\omega u)\\;+\\;A\\,\\omega^2 f(u)\\,s(u).$$\n- The total $\\,\\Psi_4(u)\\,$ is\n$$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u),$$\nwhere $\\,n(u)\\,$ is zero-mean Gaussian noise with standard deviation $\\,\\sigma_n\\,$ in units of $\\,\\mathrm{s}^{-2}\\,$.\n\nNumerical reconstruction and drift removal:\n- Compute $\\,v(u) = \\int_{u_0}^u \\Psi_4(u')\\,du'\\,$ by trapezoidal cumulative integration with $\\,v(u_0) = 0\\,$, then compute\n$$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_0}^u v(u')\\,du'$$\nby a second cumulative trapezoidal integration with $\\,h_{\\mathrm{raw}}(u_0) = 0\\,$. This induces an arbitrary linear trend $\\,d_0 + d_1 u\\,$ due to unknown integration constants, which must be estimated and removed.\n- For a given central time $\\,u_c\\,$ and exclusion half-width $\\,L\\,$ (seconds), define the no-signal windows as the union of $[u_{\\min},\\,u_c-L]$ and $[u_c+L,\\,u_{\\max}]$. Fit $\\,d_0 + d_1 u\\,$ to $\\,h_{\\mathrm{raw}}(u)\\,$ in these windows by least squares and subtract it to obtain $\\,h_{\\mathrm{corr}}(u)\\,$.\n- Estimate the recovered memory by\n$$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]},$$\nwhere the overline denotes the arithmetic mean over the indicated interval.\n- Define the memory contamination metric as the absolute error\n$$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|.$$\n\nImplementation requirements:\n- All times $\\,u\\,$ must be in seconds, and all outputs are dimensionless strain. Angles for trigonometric functions use radians. The final answers must be dimensionless.\n- Perform numerical integrations using trapezoidal cumulative integration. You may use a robust library routine for cumulative trapezoidal integration.\n- Use a fixed random number generator seed to make the noise reproducible.\n\nTest suite:\nImplement the procedure above for the following four cases. Each case defines a uniform time grid $\\,u \\in [u_{\\min}, u_{\\max}]\\,$ with spacing $\\,\\Delta u\\,$, and parameters for the signal model and drift fit. All quantities are real-valued.\n\n- Case $\\,1\\,$ (happy path):\n  - $\\,u_{\\min} = -0.5\\,$, $\\,u_{\\max} = 0.5\\,$, $\\,\\Delta u = 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.02\\,$, $\\,\\Delta h = 2\\times 10^{-22}\\,$.\n  - $\\,A = 5\\times 10^{-22}\\,$, $\\,\\omega = 500\\,$, $\\,\\tau = 0.05\\,$.\n  - $\\,\\sigma_n = 10^{-23}\\,$, $\\,L = 0.08\\,$.\n\n- Case $\\,2\\,$ (stronger oscillations and noise, shorter windows):\n  - $\\,u_{\\min} = -0.2\\,$, $\\,u_{\\max} = 0.2\\,$, $\\,\\Delta u = 5\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.01\\,$, $\\,\\Delta h = 1\\times 10^{-22}\\,$.\n  - $\\,A = 8\\times 10^{-22}\\,$, $\\,\\omega = 800\\,$, $\\,\\tau = 0.03\\,$.\n  - $\\,\\sigma_n = 3\\times 10^{-23}\\,$, $\\,L = 0.04\\,$.\n\n- Case $\\,3\\,$ (no oscillations, coarser sampling, wide window):\n  - $\\,u_{\\min} = -1.0\\,$, $\\,u_{\\max} = 1.0\\,$, $\\,\\Delta u = 2\\times 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.05\\,$, $\\,\\Delta h = 5\\times 10^{-22}\\,$.\n  - $\\,A = 0\\,$, $\\,\\omega = 0\\,$, $\\,\\tau = 0.1\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-24}\\,$, $\\,L = 0.2\\,$.\n\n- Case $\\,4\\,$ (narrow memory, high frequency, high noise density):\n  - $\\,u_{\\min} = -0.05\\,$, $\\,u_{\\max} = 0.05\\,$, $\\,\\Delta u = 2\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.005\\,$, $\\,\\Delta h = 5\\times 10^{-23}\\,$.\n  - $\\,A = 2\\times 10^{-22}\\,$, $\\,\\omega = 1000\\,$, $\\,\\tau = 0.01\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-23}\\,$, $\\,L = 0.015\\,$.\n\nRequired final output:\n- For each case, compute the contamination metric $\\,\\varepsilon\\,$ defined above.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets. Each number must be printed in scientific notation with six significant digits (for example, $\\,1.234560\\mathrm{e}{-22}\\,$). The output must have the form\n$$\\texttt{[}\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\texttt{]}.$$\n\nAll computations must be done in floating-point arithmetic. No user input is permitted; all parameters are as stated above. Use a fixed random seed for the Gaussian noise so that the results are deterministic.",
            "solution": "The problem statement has been validated and found to be scientifically sound, well-posed, and objective. It provides a complete and consistent set of definitions, physical models, numerical procedures, and parameters to perform a quantitative analysis of gravitational wave memory contamination. The problem is directly relevant to the field of numerical relativity and represents a standard data analysis task. Therefore, a solution will be provided.\n\nThe objective is to implement a numerical procedure to quantify the contamination of the gravitational wave memory effect, $\\Delta h$, when the strain, $h(u)$, is reconstructed from the Newman-Penrose scalar, $\\Psi_4(u)$, in the presence of numerical drift and noise. The procedure involves synthesizing a realistic gravitational wave signal, reconstructing the strain via numerical integration, correcting for artifacts, and then measuring the error in the recovered memory. This process will be executed for four distinct test cases.\n\nThe procedure is as follows:\n\n1.  **Signal Synthesis**: For each test case, we first construct a discrete time series for the Newman-Penrose scalar, $\\Psi_4(u)$.\n    The time grid, $u$, is defined over the interval $[u_{\\min}, u_{\\max}]$ with a uniform spacing $\\Delta u$.\n    The total scalar, $\\Psi_4(u)$, is the sum of three components:\n    $$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u)$$\n    -   The memory component, $\\Psi_{4,\\mathrm{mem}}(u)$, is derived from the second derivative of a smooth step in the strain of total amplitude $\\Delta h$. Its functional form is given by:\n        $$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr)$$\n        where $u_c$ is the central time and $\\sigma$ controls the duration of the transition.\n    -   The oscillatory component, $\\Psi_{4,\\mathrm{osc}}(u)$, models the radiation during a merger event. It is the negative second time derivative of a sinusoidal signal with a Gaussian envelope:\n        $$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr)$$\n        Using the product rule for differentiation and the provided definitions for the envelope $f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)$ and its derivatives $f'(u)$ and $f''(u)$, the oscillatory part of $\\Psi_4(u)$ is:\n        $$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -A\\Bigl[f''(u)\\,\\sin(\\omega u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,\\sin(\\omega u)\\Bigr]$$\n        For a given test case, if the amplitude $A$ is zero, this component is identically zero.\n    -   The noise component, $n(u)$, is modeled as a sequence of independent random variates drawn from a Gaussian (normal) distribution with a mean of $0$ and a standard deviation of $\\sigma_n$. To ensure reproducibility, a fixed seed is used for the random number generator.\n\n2.  **Strain Reconstruction**: The complex strain $h(u)$ is related to $\\Psi_4(u)$ by $\\Psi_4(u) = -d^2h/du^2$. Since the problem specifies all quantities are real, we consider a single real polarization. We reconstruct the strain from $\\Psi_4(u)$ by performing two successive indefinite integrations. With unknown integration constants, this would yield $h(u) = -\\iint \\Psi_4(u') du' du' + d_0 + d_1 u$. Numerically, we set the initial conditions to zero, corresponding to causal integration starting from $u_0 = u_{\\min}$. This yields a raw, uncorrected strain $h_{\\mathrm{raw}}(u)$. The integration is performed using the cumulative trapezoidal rule.\n    First, we compute the first integral, $v(u)$:\n    $$v(u) = \\int_{u_{\\min}}^u \\Psi_4(u')\\,du'$$\n    Then, we compute the second integral, the raw strain $h_{\\mathrm{raw}}(u)$:\n    $$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_{\\min}}^u v(u')\\,du'$$\n    These integrations are performed numerically using a cumulative trapezoidal integration routine. The zero initial conditions, $v(u_{\\min})=0$ and $h_{\\mathrm{raw}}(u_{\\min})=0$, are implicitly handled by the choice of causal integration boundaries.\n\n3.  **Drift Correction**: The raw strain $h_{\\mathrm{raw}}(u)$ is contaminated by a linear drift term, $d_0 + d_1 u$, which is an artifact of the unknown true integration constants. This drift must be estimated and removed. We perform a linear least-squares fit of the model $y(u) = d_0 + d_1 u$ to the raw strain $h_{\\mathrm{raw}}(u)$. The fit is performed only on data within the \"no-signal\" windows, which are defined as the union of the time intervals $[u_{\\min}, u_c - L]$ and $[u_c + L, u_{\\max}]$. These regions are assumed to be dominated by the drift and noise, as the primary burst signal is localized around $u_c$.\n    Let $(u_i, y_i)$ be the discrete data pairs in these windows, where $y_i = h_{\\mathrm{raw}}(u_i)$. The coefficients $d_0$ and $d_1$ are found by minimizing the sum of squared residuals $\\sum_i (y_i - (d_0 + d_1 u_i))^2$.\n    Once the optimal $d_0$ and $d_1$ are found, the drift is subtracted from the entire raw strain timeseries to obtain the corrected strain:\n    $$h_{\\mathrm{corr}}(u) \\;=\\; h_{\\mathrm{raw}}(u) - (d_0 + d_1 u)$$\n\n4.  **Memory Recovery and Contamination Measurement**: The gravitational wave memory is the permanent offset in the strain after the burst has passed. We estimate this from the corrected strain, $h_{\\mathrm{corr}}(u)$, by comparing its average value at late times to its average value at early times. These time intervals are the same no-signal windows used for the drift fit.\n    The recovered memory, $\\Delta h_{\\mathrm{rec}}$, is calculated as:\n    $$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]}$$\n    where the overline denotes the arithmetic mean.\n    Finally, the contamination metric, $\\varepsilon$, is defined as the absolute error between the recovered memory and the true memory amplitude, $\\Delta h$, that was used to generate the signal:\n    $$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|$$\n\nThis entire four-step procedure is implemented and applied to each of the four test cases provided in the problem statement, yielding a value of $\\varepsilon$ for each case. The final results are then formatted as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A fixed seed for the random number generator ensures reproducibility.\n    rng = np.random.default_rng(42)\n\n    test_cases = [\n        # Case 1\n        {\n            \"u_min\": -0.5, \"u_max\": 0.5, \"du\": 1e-3,\n            \"u_c\": 0.0, \"sigma\": 0.02, \"delta_h\": 2e-22,\n            \"A\": 5e-22, \"omega\": 500.0, \"tau\": 0.05,\n            \"sigma_n\": 1e-23, \"L\": 0.08,\n        },\n        # Case 2\n        {\n            \"u_min\": -0.2, \"u_max\": 0.2, \"du\": 5e-4,\n            \"u_c\": 0.0, \"sigma\": 0.01, \"delta_h\": 1e-22,\n            \"A\": 8e-22, \"omega\": 800.0, \"tau\": 0.03,\n            \"sigma_n\": 3e-23, \"L\": 0.04,\n        },\n        # Case 3\n        {\n            \"u_min\": -1.0, \"u_max\": 1.0, \"du\": 2e-3,\n            \"u_c\": 0.0, \"sigma\": 0.05, \"delta_h\": 5e-22,\n            \"A\": 0.0, \"omega\": 0.0, \"tau\": 0.1,\n            \"sigma_n\": 5e-24, \"L\": 0.2,\n        },\n        # Case 4\n        {\n            \"u_min\": -0.05, \"u_max\": 0.05, \"du\": 2e-4,\n            \"u_c\": 0.0, \"sigma\": 0.005, \"delta_h\": 5e-23,\n            \"A\": 2e-22, \"omega\": 1000.0, \"tau\": 0.01,\n            \"sigma_n\": 5e-23, \"L\": 0.015,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        epsilon = calculate_memory_contamination(case_params, rng)\n        results.append(epsilon)\n\n    # Format the final output string as specified.\n    output_str = \"[\" + \",\".join([f\"{res:.6e}\" for res in results]) + \"]\"\n    print(output_str)\n\ndef calculate_memory_contamination(params, rng):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    # Unpack parameters for clarity\n    u_min, u_max, du = params[\"u_min\"], params[\"u_max\"], params[\"du\"]\n    u_c, sigma, delta_h = params[\"u_c\"], params[\"sigma\"], params[\"delta_h\"]\n    A, omega, tau = params[\"A\"], params[\"omega\"], params[\"tau\"]\n    sigma_n, L = params[\"sigma_n\"], params[\"L\"]\n\n    # 1. Signal Synthesis\n    # Create time grid\n    num_points = int(round((u_max - u_min) / du)) + 1\n    u = np.linspace(u_min, u_max, num=num_points)\n\n    # Memory component of Psi_4\n    u_rel = u - u_c\n    psi4_mem_prefactor = delta_h / (np.sqrt(2 * np.pi) * sigma**3)\n    psi4_mem = psi4_mem_prefactor * u_rel * np.exp(-u_rel**2 / (2 * sigma**2))\n\n    # Oscillatory component of Psi_4\n    if A != 0:\n        f = np.exp(-u_rel**2 / (2 * tau**2))\n        f_prime = -u_rel / tau**2 * f\n        f_double_prime = (u_rel**2 / tau**4 - 1 / tau**2) * f\n        \n        s = np.sin(omega * u)\n        c = np.cos(omega * u)\n        \n        d2h_osc_du2 = A * (f_double_prime * s + 2 * f_prime * omega * c - omega**2 * f * s)\n        psi4_osc = -d2h_osc_du2\n    else:\n        psi4_osc = np.zeros_like(u)\n\n    # Noise component\n    noise = rng.normal(loc=0.0, scale=sigma_n, size=len(u))\n\n    # Total Psi_4\n    psi4 = psi4_mem + psi4_osc + noise\n\n    # 2. Strain Reconstruction\n    # Double cumulative trapezoidal integration\n    v = cumulative_trapezoid(psi4, x=u, initial=0.0)\n    h_raw = cumulative_trapezoid(v, x=u, initial=0.0)\n\n    # 3. Drift Correction\n    # Define no-signal windows for fitting\n    early_fit_mask = u <= (u_c - L)\n    late_fit_mask = u >= (u_c + L)\n    fit_mask = early_fit_mask | late_fit_mask\n\n    # Get data points for the fit\n    u_fit = u[fit_mask]\n    h_raw_fit = h_raw[fit_mask]\n\n    # Perform linear least-squares fit: h_raw = d0 + d1*u\n    # The model matrix columns correspond to d0 (ones) and d1 (u)\n    A_matrix = np.vstack([np.ones_like(u_fit), u_fit]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A_matrix, h_raw_fit, rcond=None)\n    d0, d1 = coeffs[0], coeffs[1]\n\n    # Subtract the fitted drift\n    h_corr = h_raw - (d0 + d1 * u)\n    \n    # 4. Memory Recovery and Contamination Measurement\n    # The averaging windows are the same as the fit windows\n    mean_early = np.mean(h_corr[early_fit_mask])\n    mean_late = np.mean(h_corr[late_fit_mask])\n    \n    delta_h_rec = mean_late - mean_early\n    \n    # Calculate contamination metric\n    epsilon = np.abs(delta_h_rec - delta_h)\n    \n    return epsilon\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}