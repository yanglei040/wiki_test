{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过实践来巩固。任何数值代码的第一步都是验证其正确性。本练习将指导你使用一个已知的精确解——Robinson-Trautman时空——来验证柯西特征提取（Cauchy-characteristic extraction, CCE）程序。通过将数值计算出的邦迪新闻函数（Bondi news）和质量损失与解析解进行比较，并衡量收敛速度，你可以确认你的实现是否准确地捕捉了引力波提取的基本物理原理。",
            "id": "3467458",
            "problem": "考虑使用 Robinson–Trautman 解族对柯西特征匹配（Cauchy-characteristic matching, CCM）进行简化验证，该验证限制在 Schwarzschild 背景下的小振幅轴对称微扰。在几何单位制下进行计算，其中引力常数和光速均设为1 ($G=c=1$)，所有角度量均使用弧度。目标是构建一个受控实验，其中 Bondi 新聞函数和 Bondi–Metzner–Sachs (BMS) 能量荷（Bondi 质量）是解析已知的，并量化当使用离散近似计算时间导数和球面积分时，其提取结果的数值收敛性。您将实现一个程序来计算多个分辨率下的离散误差，拟合收敛率，并评估与解析质量损失的一致性。\n\n基本出发点：\n- 在 Bondi–Sachs 框架中，Bondi 新闻函数 $N(u,\\theta,\\phi)$ 是渐近剪切 $c(u,\\theta,\\phi)$ 的推迟时间导数，即 $N(u,\\theta,\\phi) = \\partial_u c(u,\\theta,\\phi)$，其中 $u$ 是推迟时间，$(\\theta,\\phi)$ 是标准球面角坐标。\n- Bondi 质量损失公式指出，Bondi 质量 $M(u)$ 的演化由引力辐射携带的能量通量决定，\n$$\n\\frac{d M(u)}{d u} = -\\frac{1}{4\\pi}\\int_{S^2} |N(u,\\theta,\\phi)|^2 \\, d\\Omega,\n$$\n其中 $d\\Omega$ 是单位球面 $S^2$ 上的面积元。\n- 对于球谐指数 $l=2$ 和方位角数 $m=0$ 的小振幅线性化 Robinson–Trautman 微扰，剪切可以建模为\n$$\nc(u,\\theta,\\phi) = A_0 \\, e^{-\\kappa u} \\, Y_{20}(\\theta,\\phi),\n$$\n衰减率为\n$$\n\\kappa = \\frac{(l-1)l(l+1)(l+2)}{12\\,M_0},\n$$\n其中 $M_0$ 是初始 Bondi 质量，$Y_{20}(\\theta,\\phi)$ 是归一化的实球谐函数，满足 $\\int_{S^2} |Y_{20}|^2 \\, d\\Omega = 1$。对于 $l=2$，这简化为 $\\kappa = 2/M_0$。一个方便的实数归一化是\n$$\nY_{20}(\\theta,\\phi) = \\sqrt{\\frac{5}{16\\pi}}\\,(3\\cos^2\\theta - 1),\n$$\n这满足所述的归一化条件。\n\n需要实现的任务：\n1. 使用上述公式，根据指定的参数 $\\{M_0, A_0, l=2, m=0\\}$，构造解析剪切 $c(u,\\theta,\\phi)$ 和解析新闻 $N_{\\mathrm{exact}}(u,\\theta,\\phi) = \\partial_u c(u,\\theta,\\phi)$。\n2. 使用张量积网格离散化球面 $S^2$。方位角 $\\phi$ 在 $[0,2\\pi)$ 上均匀取样，余纬则通过 $\\mu=\\cos\\theta$ 表示，使用 Gauss–Legendre 求积节点和权重在 $[-1,1]$ 上取值。在这些坐标下，使用面积元 $d\\Omega = d\\phi\\,d\\mu$。在 $[0,u_{\\max}]$ 上使用均匀的时间网格 $u_n$。\n3. 使用二阶精确的中心差分在时间上对内部点进行数值近似，计算新闻函数 $N_{\\mathrm{num}}(u_n,\\theta_i,\\phi_j)$，\n$$\nN_{\\mathrm{num}}(u_n,\\theta_i,\\phi_j) \\approx \\frac{c(u_{n+1},\\theta_i,\\phi_j) - c(u_{n-1},\\theta_i,\\phi_j)}{2\\,\\Delta u},\n$$\n对于索引 $n=1,\\dots,N_t-2$，其中 $N_t$ 是时间节点数，$\\Delta u$ 是时间步长。\n4. 将新闻函数在时间和角度上的离散 $L^2$ 误差定义为\n$$\nE_N = \\left(\\frac{1}{u_f - u_1}\\sum_{n=1}^{N_t-2} \\Delta u \\int_{S^2} \\left|N_{\\mathrm{num}}(u_n,\\theta,\\phi) - N_{\\mathrm{exact}}(u_n,\\theta,\\phi)\\right|^2 d\\Omega \\right)^{1/2},\n$$\n其中 $u_1$是中心差分使用的第一个内部时间，$u_f$是最后一个内部时间。使用所述的求积方法实现球面积分。\n5. 通过对由 $N_{\\mathrm{num}}$ 构建的通量进行时间积分，计算在 $u_f$ 处的数值 Bondi 质量：\n$$\nM_{\\mathrm{num}}(u_f) = M_0 - \\sum_{n=1}^{N_t-3} \\frac{\\Delta u}{2}\\left(\\mathcal{F}_n + \\mathcal{F}_{n+1}\\right),\n$$\n其中\n$$\n\\mathcal{F}_n = \\frac{1}{4\\pi} \\int_{S^2} \\left|N_{\\mathrm{num}}(u_n,\\theta,\\phi)\\right|^2 d\\Omega.\n$$\n使用质量损失公式和已知的 $N_{\\mathrm{exact}}$ 推导出在 $u_f$ 处的解析 Bondi 质量，并定义绝对质量误差 $E_M = \\left|M_{\\mathrm{num}}(u_f) - M_{\\mathrm{exact}}(u_f)\\right|$。\n6. 对于每个测试用例，在三个连续加密的分辨率级别上运行上述计算。对于加密因子 $r\\in\\{1,2,4\\}$，让方位角节点数 $N_\\phi$、Gauss–Legendre 节点数 $N_\\mu$ 和时间节点数 $N_t$ 都从一个基础分辨率开始随 $r$ 线性缩放。定义一个组合网格尺度\n$$\nh = \\max\\left(\\frac{1}{N_\\mu},\\frac{2\\pi}{N_\\phi},\\Delta u\\right).\n$$\n使用三对 $(h,E_N)$ 和 $(h,E_M)$，通过对 $\\log E \\approx p \\log h + C$进行最小二乘拟合，计算经验收敛阶 $p_N$ 和 $p_M$。\n7. 定义一个布尔一致性标志，如果最精细级别下最终 Bondi 质量的相对误差满足\n$$\n\\frac{\\left|M_{\\mathrm{num}}(u_f) - M_{\\mathrm{exact}}(u_f)\\right|}{M_{\\mathrm{exact}}(u_f)} \\le 10^{-3},\n$$\n则该标志为真，否则为假。\n\n单位和输出要求：\n- 所有量在几何单位制（$G=c=1$）中都是无量纲的。角度必须以弧度为单位。输出的浮点数必须是纯十进制数。\n- 您的程序必须实现上述算法，并生成单行输出，其中包含方括号内以逗号分隔的所有测试用例的结果。对于每个测试用例，输出一个形式为 $[p_N, p_M, \\text{consistency}]$ 的列表，其中 $p_N$ 和 $p_M$ 是浮点数，$\\text{consistency}$ 是布尔值。\n\n测试套件：\n提供以下三个具有不同参数和基础分辨率的测试用例：\n- 案例 A (通用精度)：$M_0 = 1.0$, $A_0 = 10^{-3}$, $u_{\\max} = 5/\\kappa$，其中 $\\kappa=2/M_0$，基础分辨率 $N_\\phi^{(0)}=16$, $N_\\mu^{(0)}=8$, $N_t^{(0)}=60$。\n- 案例 B (较粗的角网格，不同质量)：$M_0 = 2.0$, $A_0 = 5\\times 10^{-4}$, $u_{\\max} = 4/\\kappa$，其中 $\\kappa=2/M_0$，基础分辨率 $N_\\phi^{(0)}=12$, $N_\\mu^{(0)}=6$, $N_t^{(0)}=48$。\n- 案例 C (更长的演化时间，更小的质量)：$M_0 = 0.5$, $A_0 = 8\\times 10^{-4}$, $u_{\\max} = 6/\\kappa$，其中 $\\kappa=2/M_0$，基础分辨率 $N_\\phi^{(0)}=20$, $N_\\mu^{(0)}=10$, $N_t^{(0)}=80$。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含方括号内以逗号分隔的结果列表，每个元素是针对一个测试用例的列表 $[p_N, p_M, \\text{consistency}]$，并保持上述测试用例的顺序。例如，输出应如下所示\n$$\n[[p_{N,A},p_{M,A},\\text{True}],[p_{N,B},p_{M,B},\\text{False}],[p_{N,C},p_{M,C},\\text{True}]]\n$$\n用实际数值替换占位符。",
            "solution": "该问题要求在一个简化设置下对引力波提取进行数值验证。该方法论涉及将数值计算的量与来自 Robinson-Trautman 时空族的已知解析解进行比较，特别是针对小振幅、轴对称（$l=2, m=0$）的微扰。任务的核心是实现指定的数值算法，测量其误差，并确定其收敛特性。\n\n### 1. 解析框架和精确解\n\n此问题的基础是 Bondi-Sachs 形式体系，该体系使用基于出射零锥面的坐标系来描述渐近平坦时空中的引力场。我们在 $G=c=1$ 的几何单位制下工作。\n\n引力辐射被编码在 Bondi 新闻函数 $N(u,\\theta,\\phi)$ 中，它是渐近剪切 $c(u,\\theta,\\phi)$ 的推迟时间导数：\n$$\nN(u,\\theta,\\phi) = \\frac{\\partial c(u,\\theta,\\phi)}{\\partial u}\n$$\n这里，$u$ 是推迟时间。对于指定的 Robinson-Trautman 解，剪切由下式给出：\n$$\nc(u,\\theta,\\phi) = A_0 \\, e^{-\\kappa u} \\, Y_{20}(\\theta,\\phi)\n$$\n其中 $A_0$ 是初始振幅，对于初始黑洞质量为 $M_0$ 和微扰模式 $l=2$ 的情况，$\\kappa = 2/M_0$ 是特征衰减率，$Y_{20}(\\theta,\\phi)$ 是实球谐函数：\n$$\nY_{20}(\\theta,\\phi) = \\sqrt{\\frac{5}{16\\pi}}\\,(3\\cos^2\\theta - 1)\n$$\n该函数被归一化，使其在单位球面上的平方积分为1，即 $\\int_{S^2} |Y_{20}|^2 \\, d\\Omega = 1$。求时间导数，我们得到精确的新闻函数：\n$$\nN_{\\mathrm{exact}}(u,\\theta,\\phi) = -A_0 \\, \\kappa \\, e^{-\\kappa u} \\, Y_{20}(\\theta,\\phi)\n$$\n引力波带走的能量导致系统的总质量，即 Bondi 质量 $M(u)$，减少。质量损失率由下式给出：\n$$\n\\frac{d M(u)}{d u} = -\\frac{1}{4\\pi}\\int_{S^2} |N(u,\\theta,\\phi)|^2 \\, d\\Omega\n$$\n代入 $N_{\\mathrm{exact}}$并使用 $Y_{20}$ 的归一化条件，我们找到解析能量通量：\n$$\n\\frac{d M(u)}{d u} = -\\frac{1}{4\\pi} | -A_0 \\, \\kappa \\, e^{-\\kappa u} |^2 \\int_{S^2} |Y_{20}|^2 \\, d\\Omega = -\\frac{A_0^2 \\kappa^2}{4\\pi} e^{-2\\kappa u}\n$$\n为了找到在最终时间 $u_f$ 处的精确质量 $M_{\\mathrm{exact}}(u_f)$，我们将此表达式从 $u=0$ 积分到 $u_f$：\n$$\nM_{\\mathrm{exact}}(u_f) = M_0 + \\int_0^{u_f} \\frac{d M}{d u} \\, du = M_0 - \\frac{A_0^2 \\kappa^2}{4\\pi} \\int_0^{u_f} e^{-2\\kappa u} \\, du\n$$\n$$\nM_{\\mathrm{exact}}(u_f) = M_0 - \\frac{A_0^2 \\kappa^2}{4\\pi} \\left[ \\frac{e^{-2\\kappa u}}{-2\\kappa} \\right]_0^{u_f} = M_0 + \\frac{A_0^2 \\kappa}{8\\pi} (e^{-2\\kappa u_f} - 1)\n$$\n此公式提供了 Bondi 质量的精确目标值，数值结果将与之进行比较。\n\n### 2. 数值离散化和求积\n\n连续问题被离散化以便进行数值计算。\n- **时间网格**：在推迟时间 $u$ 上使用均匀网格，$u_n = n \\Delta u$ 对于 $n=0, 1, \\dots, N_t-1$，其中 $\\Delta u = u_{\\max}/(N_t-1)$。\n- **空间网格**：单位球面 $S^2$ 使用张量积网格进行离散化。方位角 $\\phi$ 被均匀采样。对于余纬 $\\theta$，我们使用 $\\mu = \\cos\\theta$ 并采用 Gauss-Legendre 求积。这提供了一组在 $[-1,1]$ 中的节点 $\\mu_i$ 和相应的权重 $w_i$，对于 $i=1, \\dots, N_\\mu$。\n- **球面积分**：球面上的积分 $\\int_{S^2} f(\\theta,\\phi) d\\Omega$ 近似为：\n$$\n\\int_0^{2\\pi} d\\phi \\int_{-1}^{1} f(\\mu) d\\mu \\approx 2\\pi \\sum_{i=1}^{N_\\mu} w_i f(\\mu_i)\n$$\n这对于最高 $2N_\\mu-1$ 次的多项式是精确的。由于我们的函数是光滑的，这是一种高度精确的方法。\n\n### 3. 数值近似和误差度量\n\n数值任务的核心是近似导数和积分。\n- **数值新闻函数**：时间导数 $\\partial_u c$ 使用二阶精确的中心有限差分进行近似：\n$$\nN_{\\mathrm{num}}(u_n,\\theta_i,\\phi_j) = \\frac{c(u_{n+1},\\theta_i,\\phi_j) - c(u_{n-1},\\theta_i,\\phi_j)}{2\\,\\Delta u}\n$$\n这是针对内部时间点 $n=1, \\dots, N_t-2$ 计算的。此近似的截断误差为 $O(\\Delta u^2)$。\n- **新闻函数误差 ($E_N$)**：数值新闻函数的准确性通过均方根误差来量化，该误差在球面和相关时间区间 $[u_1, u_f]$（其中 $u_f = u_{N_t-2}$）上取平均：\n$$\nE_N = \\left(\\frac{1}{u_f - u_1}\\sum_{n=1}^{N_t-2} \\Delta u \\left( 2\\pi \\sum_{i=1}^{N_\\mu} w_i |N_{\\mathrm{num}}(u_n, \\mu_i) - N_{\\mathrm{exact}}(u_n, \\mu_i)|^2 \\right) \\right)^{1/2}\n$$\n关于 $n$ 的求和近似了时间积分。由于 $N_{num}$ 中的误差是 $O(h^2)$，我们预期 $E_N$ 将按 $O(h^2)$ 比例缩放，意味着收敛阶 $p_N=2$。\n- **数值质量损失和质量误差 ($E_M$)**：在每个时间步 $u_n$ 使用数值新闻函数计算数值通量 $\\mathcal{F}_n$：\n$$\n\\mathcal{F}_n = \\frac{1}{4\\pi} \\int_{S^2} |N_{\\mathrm{num}}(u_n,\\theta,\\phi)|^2 d\\Omega \\approx \\frac{1}{2} \\sum_{i=1}^{N_\\mu} w_i |N_{\\mathrm{num}}(u_n, \\mu_i)|^2\n$$\n总质量损失通过对该通量随时间积分得到。问题指定在区间 $[u_1, u_f]$ 上使用梯形法则：\n$$\nM_{\\mathrm{num}}(u_f) = M_0 - \\sum_{n=1}^{N_t-3} \\frac{\\Delta u}{2}\\left(\\mathcal{F}_n + \\mathcal{F}_{n+1}\\right)\n$$\n质量误差则为 $E_M = |M_{\\mathrm{num}}(u_f) - M_{\\mathrm{exact}}(u_f)|$。一个关键点是，数值积分从 $u_1$ 开始，而解析质量损失是从 $u_0=0$ 计算的。这引入了一个量级为 $\\int_0^{u_1} \\mathcal{F}_{\\mathrm{exact}} du \\approx \\mathcal{F}_{\\mathrm{exact}}(0) \\Delta u$ 的系统误差，其阶数为 $O(\\Delta u)$。尽管梯形法则和中心差分是二阶的，但预计这种边界效应将占主导地位，导致质量的收敛阶为一阶，即 $p_M \\approx 1$。\n\n### 4. 收敛性分析和一致性\n\n为验证预期的理论收敛率，该模拟在三个分辨率下运行。$\\phi$, $\\mu$ 和 $u$ 的网格分辨率通过加密因子 $r \\in \\{1, 2, 4\\}$ 进行缩放。复合网格尺度参数 $h = \\max(1/N_\\mu, 2\\pi/N_\\phi, \\Delta u)$ 表征了整体分辨率。\n收敛阶 $p$ 由关系式 $E \\propto h^p$ 决定，这意味着 $\\log E = p \\log h + C$。对于来自不同分辨率的三个数据点 $(h, E)$，斜率 $p$ 通过线性最小二乘拟合稳健地确定。\n最后，在最高分辨率（$r=4$）下执行一致性检查，以确保数值质量接近精确值，特别是检查相对误差是否低于 $10^{-3}$ 的阈值。\n$$\n\\frac{|M_{\\mathrm{num}}(u_f) - M_{\\mathrm{exact}}(u_f)|}{|M_{\\mathrm{exact}}(u_f)|} \\le 10^{-3}\n$$",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main driver function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Case A: General accuracy\n        {'M0': 1.0, 'A0': 1e-3, 'u_max_factor': 5.0, 'N_phi0': 16, 'N_mu0': 8, 'N_t0': 60},\n        # Case B: Coarser angular grid, different mass\n        {'M0': 2.0, 'A0': 5e-4, 'u_max_factor': 4.0, 'N_phi0': 12, 'N_mu0': 6, 'N_t0': 48},\n        # Case C: Longer evolution, smaller mass\n        {'M0': 0.5, 'A0': 8e-4, 'u_max_factor': 6.0, 'N_phi0': 20, 'N_mu0': 10, 'N_t0': 80},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_case(**case_params)\n        results.append(result)\n\n    # Format the output string precisely as required.\n    inner_results = []\n    for res in results:\n        # res is a list [p_N, p_M, consistency]\n        inner_str = f\"[{res[0]},{res[1]},{'True' if res[2] else 'False'}]\"\n        inner_results.append(inner_str)\n    \n    print(f\"[{','.join(inner_results)}]\")\n\n\ndef Y20(mu):\n    \"\"\"\n    Computes the real spherical harmonic Y_{20} for a given mu=cos(theta).\n    \"\"\"\n    return np.sqrt(5.0 / (16.0 * np.pi)) * (3.0 * mu**2 - 1.0)\n\ndef solve_case(M0, A0, u_max_factor, N_phi0, N_mu0, N_t0):\n    \"\"\"\n    Executes the numerical simulation and analysis for a single test case.\n    \"\"\"\n    kappa = 2.0 / M0\n    u_max = u_max_factor / kappa\n\n    refinements = [1, 2, 4]\n    h_vals, EN_vals, EM_vals = [], [], []\n    final_mass_data = {}\n\n    for r in refinements:\n        # 1. Setup grids and resolutions\n        N_phi = r * N_phi0\n        N_mu = r * N_mu0\n        N_t = r * N_t0\n\n        u = np.linspace(0, u_max, N_t)\n        Delta_u = u[1] - u[0]\n\n        mu_nodes, mu_weights = roots_legendre(N_mu)\n\n        h = max(1.0/N_mu, 2.0 * np.pi / N_phi, Delta_u)\n        h_vals.append(h)\n\n        # 2. Evaluate analytic shear on the full grid\n        # Create a grid for c(u, mu) of shape (N_t, N_mu)\n        u_grid, mu_grid = np.meshgrid(u, mu_nodes, indexing='ij')\n        # c is independent of phi, so we only need a 2D grid\n        c_analytic_grid = A0 * np.exp(-kappa * u_grid) * Y20(mu_grid)\n\n        # 3. Compute numerical news (central difference)\n        # Valid for time indices n = 1 to N_t-2\n        c_p1 = c_analytic_grid[2:N_t, :]\n        c_m1 = c_analytic_grid[0:N_t-2, :]\n        N_num_grid = (c_p1 - c_m1) / (2.0 * Delta_u)\n\n        # 4. Compute news error E_N\n        u_subgrid_vals = u[1:N_t-1]\n        u_subgrid, mu_sub_grid = np.meshgrid(u_subgrid_vals, mu_nodes, indexing='ij')\n        N_exact_grid = -A0 * kappa * np.exp(-kappa * u_subgrid) * Y20(mu_sub_grid)\n        \n        diff_sq = np.abs(N_num_grid - N_exact_grid)**2\n        # Integral over sphere for each time step in subgrid, dOmega = dphi dmu\n        sphere_integral_sq_diff = 2.0 * np.pi * np.sum(diff_sq * mu_weights, axis=1)\n\n        u_f_idx = N_t-2\n        u_1_idx = 1\n        u_f = u[u_f_idx]\n        u_1 = u[u_1_idx]\n        \n        time_duration = u_f - u_1\n        if time_duration > 0:\n            time_avg_integrand = np.sum(sphere_integral_sq_diff) * Delta_u\n            E_N_sq = (1.0 / time_duration) * time_avg_integrand\n            E_N = np.sqrt(E_N_sq)\n        else:\n            E_N = 0.0\n        EN_vals.append(E_N)\n\n        # 5. Compute mass error E_M\n        # Flux F_n from N_num\n        N_num_sq_abs = np.abs(N_num_grid)**2\n        sphere_integral_F = 2.0 * np.pi * np.sum(N_num_sq_abs * mu_weights, axis=1)\n        F_n = (1.0 / (4.0 * np.pi)) * sphere_integral_F\n        \n        # Integrate flux using trapezoidal rule (sum over n=1..N_t-3)\n        mass_loss_num = 0.0\n        if len(F_n) > 1:\n            mass_loss_num = np.sum((F_n[:-1] + F_n[1:]) / 2.0) * Delta_u\n        \n        M_num_uf = M0 - mass_loss_num\n        \n        # Analytic mass at u_f = u_{N_t-2}\n        M_exact_uf = M0 + (A0**2 * kappa) / (8.0 * np.pi) * (np.exp(-2.0 * kappa * u_f) - 1.0)\n        \n        E_M = np.abs(M_num_uf - M_exact_uf)\n        EM_vals.append(E_M)\n        \n        if r == refinements[-1]:\n            final_mass_data['num'] = M_num_uf\n            final_mass_data['exact'] = M_exact_uf\n\n    # 6. Fit convergence orders\n    log_h = np.log(np.array(h_vals))\n    # Filter out non-positive values before taking log\n    log_EN = np.log(np.array(EN_vals)[np.array(EN_vals) > 0])\n    log_EM = np.log(np.array(EM_vals)[np.array(EM_vals) > 0])\n    \n    # Check if there are enough points to fit\n    p_N = np.polyfit(log_h[:len(log_EN)], log_EN, 1)[0] if len(log_EN) > 1 else 0.0\n    p_M = np.polyfit(log_h[:len(log_EM)], log_EM, 1)[0] if len(log_EM) > 1 else 0.0\n\n    # 7. Consistency check\n    relative_mass_error = np.abs(final_mass_data['num'] - final_mass_data['exact']) / np.abs(final_mass_data['exact'])\n    consistency = (relative_mass_error = 1e-3)\n\n    # Python bools must be capitalized in the final output string, so we handle it there\n    return [p_N, p_M, consistency]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在验证了提取方法的正确性之后，下一个实际问题是如何高效地使用它。柯西特征提取涉及在有限半径$R_\\Gamma$的世界管上进行数据交换，而世界管的选择直接影响着内部柯西演化的计算成本和最终波形的精度。本练习构建了一个误差模型，旨在帮助你理解不同误差来源（有限半径效应与角向分辨率）之间的权衡，并为你提供一种方法来确定在给定精度目标下的最优世界管半径。",
            "id": "3467461",
            "problem": "您必须编写一个完整、可运行的程序，该程序用于模拟在比较有限半径抽取（FRE）和柯西特征抽取（CCE）时，Newman-Penrose Weyl标量$\\Psi_4$和Bondi新闻$N$中污染的标度行为。您的模型必须基于渐近展开和角向离散化误差标度，并且必须计算一个最优特征世界管半径 $R_\\Gamma$ 以满足目标波形精度。采用几何单位制，其中$G=c=1$，所有半径均以质量单位$M$表示。角度必须以弧度指定和使用。\n\n建模基础：\n- 在Bondi-Sachs形式体系中，渐近引力辐射由未来类光无穷远$\\mathscr{I}^+$处的Bondi新闻$N$和Newman-Penrose标量$\\Psi_4$表示。剥离行为意味着渐近场允许按$1/r$的幂次进行展开，而有限半径抽取会受到来自近区场、规范效应和有限半径截断的污染项的影响。\n- 有限半径抽取通常保留了$1/R_\\Gamma$量级的主导污染标度及更高阶项，而柯西特征抽取将数据传播至$\\mathscrI^+$并消除了主导的$1/R_\\Gamma$污染，只留下更高阶的$\\sim 1/R_\\Gamma^2$效应。\n- 球面上的角向離散化（例如，在离散网格上使用自旋权重球谐函数）会引入分辨率误差，对于FRE，该误差随角向网格间距$h$代数标度为$h^p$，对于CCE（使用适当改进的角向算子），标度为$h^q$，其中$qp$代表特征方法管道中更高阶的收敛性。\n\n待使用的污染模型：\n- 有限半径抽取污染模型：\n  - $\\text{err}_{\\Psi_4}^{\\mathrm{FRE}}(R_\\Gamma, h) = \\dfrac{C_1}{R_\\Gamma} + \\dfrac{C_2}{R_\\Gamma^2} + C_{\\mathrm{ang}}\\, h^{p}$。\n  - $\\text{err}_{N}^{\\mathrm{FRE}}(R_\\Gamma, h) = \\dfrac{\\tilde{C}_1}{R_\\Gamma} + \\dfrac{\\tilde{C}_2}{R_\\Gamma^2} + \\tilde{C}_{\\mathrm{ang}}\\, h^{p}$。\n- 柯西特征抽取污染模型：\n  - $\\text{err}_{\\Psi_4}^{\\mathrm{CCE}}(R_\\Gamma, h) = \\dfrac{D_2}{R_\\Gamma^2} + D_{\\mathrm{ang}}\\, h^{q}$。\n  - $\\text{err}_{N}^{\\mathrm{CCE}}(R_\\Gamma, h) = \\dfrac{M_2}{R_\\Gamma^2} + M_{\\mathrm{ang}}\\, h^{q}$。\n\n您的程序必须：\n1. 实现这些模型，并针对下面的每个测试用例，预测CCE达到目标精度$\\varepsilon$所需的最优世界管半径$R_\\Gamma$，该半径必须同时满足$\\Psi_4$和$N$的精度要求；即，$\\text{err}_{\\Psi_4}^{\\mathrm{CCE}}(R_\\Gamma, h) \\le \\varepsilon$和$\\text{err}_{N}^{\\mathrm{CCE}}(R_\\Gamma, h) \\le \\varepsilon$必须同时成立。\n2. 仅使用CCE污染模型来确定针对指定目标精度的最优$R_\\Gamma$。\n3. 遵守世界管半径边界$R_\\Gamma \\in [R_{\\min}, R_{\\max}]$。如果对于给定用例，在边界内不存在可行的$R_\\Gamma$，则该用例输出$-1.0$。\n\n单位：\n- 半径必须以质量单位$M$表示，并报告为四舍五入到一位小数的浮点数。\n- 角向间距$h$以弧度为单位。\n\n模型系数（所有测试用例通用）：\n- FRE系数（仅供比较，不用于选择$R_\\Gamma$）：\n  - 对于$\\Psi_4$：$C_1 = 0.5$，$C_2 = 2.0$，$C_{\\mathrm{ang}} = 0.05$，$p = 4$。\n  - 对于$N$：$\\tilde{C}_1 = 0.4$，$\\tilde{C}_2 = 1.5$，$\\tilde{C}_{\\mathrm{ang}} = 0.04$，$p = 4$。\n- 用于优化的CCE系数：\n  - 对于$\\Psi_4$：$D_2 = 1.2$，$D_{\\mathrm{ang}} = 0.02$，$q = 6$。\n  - 对于$N$：$M_2 = 0.8$，$M_{\\mathrm{ang}} = 0.015$，$q = 6$。\n\n优化准则：\n- 对于每个场$X \\in \\{\\Psi_4, N\\}$以及固定的$h$和$\\varepsilon$，可行性条件为$\\varepsilon - B_X(h)  0$，其中$B_{\\Psi_4}(h) = D_{\\mathrm{ang}} h^q$且$B_N(h) = M_{\\mathrm{ang}} h^q$。如果任一场不满足此条件，则该用例不可行。\n- 否则，场$X$的最小半径由以下条件确定：坚持$R_\\Gamma^{-2}$的贡献低于剩余的预算，并受边界$[R_{\\min}, R_{\\max}]$的约束。该用例的最优$R_\\Gamma$是在$[R_{\\min}, R_{\\max}]$内同时满足两个场的最小半径。\n\n测试套件：\n按所示确切顺序为程序提供以下五个测试用例。每个用例由$(h, \\varepsilon, R_{\\min}, R_{\\max})$指定：\n- 用例1（理想路径）：$h = 0.05$，$\\varepsilon = 10^{-4}$，$R_{\\min} = 50$，$R_{\\max} = 1000$。\n- 用例2（增加角向误差）：$h = 0.3$，$\\varepsilon = 10^{-4}$，$R_{\\min} = 50$，$R_{\\max} = 1000$。\n- 用例3（严格精度）：$h = 0.05$，$\\varepsilon = 2 \\times 10^{-6}$，$R_{\\min} = 50$，$R_{\\max} = 1000$。\n- 用例4（因角向分辨率不可行）：$h = 0.5$，$\\varepsilon = 10^{-5}$，$R_{\\min} = 50$，$R_{\\max} = 1000$。\n- 用例5（半径触及下界）：$h = 0.2$，$\\varepsilon = 10^{-3}$，$R_{\\min} = 50$，$R_{\\max} = 1000$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含这五个案例的最优世界管半径，形式为用方括号括起来的逗号分隔列表，每个半径以$M$为单位，四舍五入到一位小数。对于不可行的案例，用$-1.0$代替半径。例如：\"[R1,R2,R3,R4,R5]\"。",
            "solution": "用户提供了一个问题陈述，经验证，该陈述在科学上是合理的、良态的且客观的。该问题是数值相对论领域内一个明确定义的优化任务，具体涉及使用柯西特征抽取（CCE）技术提取引力波的精度问题。\n\n目标是确定CCE模拟所需的最优（即最小）世界管半径$R_\\Gamma$，以使Newman-Penrose标量$\\Psi_4$和Bondi新闻$N$同时达到指定的目标精度$\\varepsilon$。解决方案必须遵守给定的半径边界$R_\\Gamma \\in [R_{\\min}, R_{\\max}]$。\n\n对于量$X \\in \\{\\Psi_4, N\\}$，CCE方法中的污染被建模为有限半径截断误差和角向离散化误差之和。模型如下：\n$$\n\\text{err}_{\\Psi_4}^{\\mathrm{CCE}}(R_\\Gamma, h) = \\dfrac{D_2}{R_\\Gamma^2} + D_{\\mathrm{ang}}\\, h^{q}\n$$\n$$\n\\text{err}_{N}^{\\mathrm{CCE}}(R_\\Gamma, h) = \\dfrac{M_2}{R_\\Gamma^2} + M_{\\mathrm{ang}}\\, h^{q}\n$$\n其中$R_\\Gamma$是抽取半径，$h$是角向网格间距，$D_2, D_{\\mathrm{ang}}, M_2, M_{\\mathrm{ang}}, q$是固定系数。任务是找到最小的$R_\\Gamma$，使得以下两个不等式同时成立：\n$$\n\\text{err}_{\\Psi_4}^{\\mathrm{CCE}}(R_\\Gamma, h) \\le \\varepsilon\n$$\n$$\n\\text{err}_{N}^{\\mathrm{CCE}}(R_\\Gamma, h) \\le \\varepsilon\n$$\n\n求解方法如下：\n\n1.  **误差预算分解**：对于每个场，总容許誤差$\\varepsilon$可以看作是一个必须同时容纳角向误差和有限半径误差的预算。角向误差项$B_{\\Psi_4}(h) = D_{\\mathrm{ang}} h^q$和$B_N(h) = M_{\\mathrm{ang}} h^q$与抽取半径$R_\\Gamma$无关。它们代表了在给定角向分辨率$h$下的基线误差水平。\n\n2.  **可行性分析**：只有当每个场的角向误差本身不超过总误差容限$\\varepsilon$时，解才可能存在。这建立了一个基本的可行性条件。对于每个场$X \\in \\{\\Psi_4, N\\}$，必须满足：\n    $$\n    B_X(h)  \\varepsilon \\implies \\varepsilon - B_X(h)  0\n    $$\n    如果$\\Psi_4$或$N$中任何一个违反了此条件，那么对于给定的参数，该问题是病态的，因为无论选择多大的$R_\\Gamma$（这只会使$1/R_\\Gamma^2$项趋于零），总误差都无法降至$\\varepsilon$以下。在这种情况下，该场景被认为是不可行的。\n\n3.  **推导每个场的最小半径**：假设满足可行性条件，我们可以确定满足每个不等式所需的最小半径。\n    对于$\\Psi_4$，我们有：\n    $$\n    \\dfrac{D_2}{R_\\Gamma^2} + D_{\\mathrm{ang}}\\, h^{q} \\le \\varepsilon\n    $$\n    整理$R_\\Gamma$可得：\n    $$\n    \\dfrac{D_2}{R_\\Gamma^2} \\le \\varepsilon - D_{\\mathrm{ang}}\\, h^{q}\n    $$\n    $$\n    R_\\Gamma^2 \\ge \\dfrac{D_2}{\\varepsilon - D_{\\mathrm{ang}}\\, h^{q}}\n    $$\n    这意味着$\\Psi_4$场所需的最小半径为：\n    $$\n    R_{\\Gamma, \\Psi_4} = \\sqrt{\\dfrac{D_2}{\\varepsilon - D_{\\mathrm{ang}}\\, h^{q}}}\n    $$\n    同样，对于Bondi新闻$N$，我们找到所需的最小半径：\n    $$\n    R_{\\Gamma, N} = \\sqrt{\\dfrac{M_2}{\\varepsilon - M_{\\mathrm{ang}}\\, h^{q}}}\n    $$\n\n4.  **组合最小半径**：为同时满足两个误差约束，所选的世界管半径$R_\\Gamma$必须大于或等于$R_{\\Gamma, \\Psi_4}$和$R_{\\Gamma, N}$。这两个下界中更严格的一个决定了总体的最低要求。因此，在考虑外部约束之前的最小半径是：\n    $$\n    R_{\\Gamma, \\text{opt\\_raw}} = \\max\\left(R_{\\Gamma, \\Psi_4}, R_{\\Gamma, N}\\right)\n    $$\n\n5.  **应用世界管边界**：问题规定最终半径必须位于区间$[R_{\\min}, R_{\\max}]$内。物理上必需的半径$R_{\\Gamma, \\text{opt\\_raw}}$必须首先与下界$R_{\\min}$协调。由于模拟必须在不小于$R_{\\min}$的半径处执行，因此最优半径的实际候选值变为：\n    $$\n    R_{\\Gamma, \\text{opt}} = \\max(R_{\\Gamma, \\text{opt\\_raw}}, R_{\\min})\n    $$\n    最后，这个候选半径必须相对于上界$R_{\\max}$是可行的。如果$R_{\\Gamma, \\text{opt}}  R_{\\max}$，这意味着即使是满足精度和$R_{\\min}$约束的最小可能半径也大于所允许的最大半径。在这种情况下，给定的边界内不存在有效解，该用例是不可行的。\n\n6.  **最终结果形式**：\n    -   如果初始可行性分析失败（步骤2）或最终候选半径超过$R_{\\max}$（步骤5），则输出为$-1.0$。\n    -   否则，最优半径为$R_{\\Gamma, \\text{opt}}$，按要求四舍五入到一位小数。\n\n这种基于原理的结构化方法确保了对于每个测试用例，我们都能找到满足所有物理精度要求和外部约束的最小可能半径$R_\\Gamma$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal CCE worldtube radius R_Gamma based on error models\n    for the Newman-Penrose scalar Psi_4 and the Bondi news N.\n    \"\"\"\n\n    # Model coefficients as specified in the problem statement.\n    # CCE coefficients for optimization:\n    # For Psi_4: D2, D_ang\n    D2 = 1.2\n    D_ang = 0.02\n    \n    # For N: M2, M_ang\n    M2 = 0.8\n    M_ang = 0.015\n    \n    # Angular error convergence order\n    q = 6\n\n    # Test suite: (h, epsilon, R_min, R_max)\n    test_cases = [\n        # Case 1 (happy path)\n        (0.05, 1e-4, 50, 1000),\n        # Case 2 (increased angular error)\n        (0.3, 1e-4, 50, 1000),\n        # Case 3 (tight accuracy)\n        (0.05, 2e-6, 50, 1000),\n        # Case 4 (infeasible due to angular resolution)\n        (0.5, 1e-5, 50, 1000),\n        # Case 5 (radius hits lower bound)\n        (0.2, 1e-3, 50, 1000),\n    ]\n\n    results = []\n    for h, epsilon, r_min, r_max in test_cases:\n        # Step 1: Calculate angular error terms for Psi_4 and N.\n        B_psi4 = D_ang * (h ** q)\n        B_n = M_ang * (h ** q)\n\n        # Step 2: Feasibility Analysis. Check if angular error exceeds target accuracy.\n        if epsilon = B_psi4 or epsilon = B_n:\n            results.append(-1.0)\n            continue\n\n        # Step 3: Derive minimum radius for each field.\n        # This is the radius required to make the 1/R^2 term fit the remaining error budget.\n        \n        # Minimum radius for Psi_4\n        # R_Gamma^2 >= D2 / (epsilon - B_psi4)\n        r_gamma_psi4_sq = D2 / (epsilon - B_psi4)\n        r_gamma_psi4 = np.sqrt(r_gamma_psi4_sq)\n\n        # Minimum radius for N\n        # R_Gamma^2 >= M2 / (epsilon - B_n)\n        r_gamma_n_sq = M2 / (epsilon - B_n)\n        r_gamma_n = np.sqrt(r_gamma_n_sq)\n        \n        # Step 4: Combined Minimum Radius.\n        # To satisfy both, we must use a radius at least as large as the maximum of the two.\n        r_gamma_opt_raw = max(r_gamma_psi4, r_gamma_n)\n        \n        # Step 5: Application of Worldtube Bounds.\n        # The radius must be at least r_min.\n        r_gamma_opt = max(r_gamma_opt_raw, r_min)\n        \n        # Check against the upper bound r_max.\n        if r_gamma_opt > r_max:\n            results.append(-1.0)\n        else:\n            # Step 6: Final Result Formulation.\n            # Round the result to one decimal place.\n            results.append(round(r_gamma_opt, 1))\n\n    # Format the final output as a comma-separated list in brackets.\n    # Note: str(-1.0) correctly produces \"-1.0\".\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "数值算法的设计本身对模拟的稳定性和物理保真度至关重要。对于长时间的演化，数值格式能否在离散层面保持系统的内在物理守恒律（如能量）是一个核心问题。本练习通过一个简化的特征演化模型，对比了一种耗散格式和一种结构保持（或辛）格式，让你亲身体验更先进的几何积分方法如何在离散演化中更好地尊重物理守恒律，从而提高模拟的长期可靠性。",
            "id": "3467486",
            "problem": "您的任务是设计、实现并比较用于广义相对论 (GR) 的 Bondi-Sachs 形式体系中，剪切张量 $C_{AB}$ 和相关角向度规函数 $U^{A}$ 的特征演化的时间离散格式。在此背景下，将来零无穷远 $\\mathscr{I}^{+}$ 处的引力辐射内容被编码在新闻张量 $N_{AB} = \\partial_{u} C_{AB}$ 中，并且由引力波携带至 $\\mathscr{I}^{+}$ 的总能量流由 $N_{AB} N^{AB}$ 在球面上的积分给出，这导致了 Bondi 质量损失定律 $dM/du = -\\mathcal{F}(u)$，其中 $\\mathcal{F}(u)$ 是能量流密度。为了便于计算，您将使用一个物理上一致的、轴对称的单模简化模型，该模型捕捉了基本的守恒结构，同时对于算法探索而言仍然是易于处理的。\n\n使用的基本原理：\n- Bondi-Sachs 质量损失方程：$dM/du = -\\frac{1}{32\\pi} \\int N_{AB} N^{AB}\\, d\\Omega$。\n- 新闻张量的定义：$N_{AB} = \\partial_{u} C_{AB}$。\n- 在具有归一化角向分布的轴对称单模简化中，定义一个标量振幅 $c(u)$ 来表示 $C_{AB}$ 的主导模式，并定义一个标量振幅 $n(u)$，由 $n(u) = \\partial_{u} c(u)$ 定义，表示新闻张量的相应分量。在吸收了归一化常数后，将简化的质量损失方程写为 $dM/du = -n(u)^{2}$，使所有量都无量纲化。\n\n您的模型必须满足以下简化演化方程，这些方程在此单模近似中充当 $(C_{AB}, U^{A})$ 的特征演化：\n- $c(u)$ 通过 $d c/du = n$ 随 $n(u)$ 演化。\n- $n(u)$ 满足一个线性化真空演化方程 $d n/du = -\\omega^{2} c$，代表了在 $\\mathscr{I}^{+}$ 附近与线性化引力一致的剪切张量和角向度规函数的单个准谐振模式。\n- $M(u)$ 满足 $dM/du = -n^{2}$，代表了此简化模式下向 $\\mathscr{I}^{+}$ 的 Bondi 质量损失。\n\n您的任务：\n1. 为上述系统构建一个结构保持的、能量流守恒的离散化格式，该格式表示 $(c, n)$ 的特征演化以及 $M$ 的时间中心离散质量损失，使得离散的 $M$ 损失精确匹配从 $n$ 构建的到 $\\mathscr{I}^{+}$ 的能量流的二阶精确求积，即对 $n^{2}$ 应用梯形法则的意义上。该设计必须为 $(c, n)$ 使用辛或几何时间积分器，以保持与线性模式相对应的 $(c, n)$ 对的底层哈密顿结构。在此格式中，您不得假设任何特设的阻尼。\n2. 为同一系统构建一个耗散有限体积格式的显式格式，该格式在时间上是一阶的，并在 $n$ 方程中包含一个可调的数值耗散参数 $\\nu \\ge 0$，以模拟常见的耗散通量更新。在此格式中，使用左端点值 $n_{k}$ 通过前向欧拉通量更新 $M$，因此离散质量损失通常不匹配 $n^{2}$ 的二阶梯形求积。\n3. 对于两种格式，计算整个模拟过程中流向 $\\mathscr{I}^{+}$ 的离散通量，作为 $n^{2}$ 的二阶梯形求积，即 $\\sum_{k=0}^{N-1} \\frac{h}{2}\\left(n_{k}^{2} + n_{k+1}^{2}\\right)$，其中 $h$ 是时间步长，$N$ 是步数。计算每种格式的相对守恒误差，定义为\n$$\n\\varepsilon = \\frac{\\left| \\left(M(0) - M(Nh)\\right) - \\sum_{k=0}^{N-1} \\frac{h}{2} \\left(n_{k}^{2} + n_{k+1}^{2}\\right) \\right|}{\\left|M(0)\\right|}.\n$$\n所有量均为无量纲。以无量纲浮点数形式表示输出。\n\n实现要求：\n- 使用二阶精确的几何时间积分器设计用于 $(c, n)$ 的结构保持格式，该积分器保持线性模式的哈密顿结构，并使用时间中心的、二阶精确的表示来更新 $M$，使其离散损失与 $n^{2}$ 的梯形求积在舍入误差范围内匹配。\n- 设计带有应用于 $n$ 方程的粘性参数 $\\nu$ 的耗散显式有限体积格式，并使用左端点处的一阶显式通量 $n_{k}^{2}$ 更新 $M$。\n- 对于两种格式，从 $n$ 序列计算梯形通量和相对守恒误差 $\\varepsilon$。\n\n测试套件：\n使用以下测试用例，每个用例指定为一个元组 $(\\omega, h, N, \\nu, c_{0}, n_{0}, M_{0})$。所有量均为无量纲。\n- 用例 1 (正常情况，中等频率)：$(0.8, 0.05, 300, 0.1, 1.0, 0.0, 10.0)$。\n- 用例 2 (边界情况，零频率)：$(0.0, 0.1, 200, 0.05, 1.0, 0.5, 10.0)$。\n- 用例 3 (较高频率，中等步长)：$(1.5, 0.2, 120, 0.3, 1.0, 0.0, 10.0)$。\n- 用例 4 (高频率，较大步长，强耗散)：$(2.5, 0.35, 80, 0.5, 1.0, 0.0, 10.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。按顺序为每个测试用例输出两个浮点数：首先是结构保持格式的相对守恒误差 $\\varepsilon$，然后是耗散格式的相对守恒误差 $\\varepsilon$。因此，最后一行必须总共包含八个浮点数，顺序为\n$[\\varepsilon_{\\mathrm{SP},1}, \\varepsilon_{\\mathrm{DISS},1}, \\varepsilon_{\\mathrm{SP},2}, \\varepsilon_{\\mathrm{DISS},2}, \\varepsilon_{\\mathrm{SP},3}, \\varepsilon_{\\mathrm{DISS},3}, \\varepsilon_{\\mathrm{SP},4}, \\varepsilon_{\\mathrm{DISS},4}]$，\n并四舍五入到八位小数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于数值相对论和常微分方程的原理，具有明确的初始条件和演化方程，问题设定良好，并以客观、可形式化的语言表述。\n\n该问题要求为 Bondi-Sachs 形式体系中引力波发射的简化单模模型设计并比较两种不同的数值时间积分格式。该系统由以下无量纲常微分方程描述：\n$$\n\\frac{dc}{du} = n\n$$\n$$\n\\frac{dn}{du} = -\\omega^2 c\n$$\n$$\n\\frac{dM}{du} = -n^2\n$$\n此处，$c(u)$ 是剪切张量模式的振幅，$n(u)$ 是相应的新闻振幅，$M(u)$ 是 Bondi 质量，$u$ 是推迟时。对 $(c, n)$ 构成一个简谐振子，其能量通过引力波耗散，导致 Bondi 质量 $M$ 减少。\n\n我们现在将设计所需的两种数值格式。\n\n**1. 结构保持、能量流守恒的格式**\n\n此格式必须是二阶精确的，对 $(c, n)$ 系统使用几何积分器，并确保离散质量损失与能量流 $n^2$ 的梯形求积完全匹配。\n\n$(c, n)$ 系统等价于一个简谐振子 $\\frac{d^2c}{du^2} + \\omega^2 c = 0$。该系统拥有一个守恒量（一个哈密顿量）$H = \\frac{1}{2}(n^2 + \\omega^2 c^2)$。适用于该系统的二阶几何（辛）积分器是 Velocity-Verlet 方法。设时间步长为 $h$，在时间 $u_k = k \\cdot h$ 处的离散值为 $(c_k, n_k, M_k)$。\n\n从步骤 $k$推进到 $k+1$ 的 Velocity-Verlet 更新规则是：\n$$\nc_{k+1} = c_k + h n_k - \\frac{h^2 \\omega^2}{2} c_k\n$$\n$$\nn_{k+1} = n_k - \\frac{h \\omega^2}{2} (c_k + c_{k+1})\n$$\n这些方程为 $c$ 和 $n$ 提供了一个二阶精确的演化，该演化近似地守恒哈密顿量 $H$。\n\n对于质量演化，我们必须强制要求离散质量损失 $M_k - M_{k+1}$ 精确等于积分通量 $\\int_{u_k}^{u_{k+1}} n(u)^2 du$ 的梯形法则近似。该积分的梯形近似为 $\\frac{h}{2}(n_k^2 + n_{k+1}^2)$。因此，$M$ 的更新规则定义为：\n$$\nM_{k+1} = M_k - \\frac{h}{2} (n_k^2 + n_{k+1}^2)\n$$\n这种构造确保了整个模拟过程中的总质量损失 $M_0 - M_N$ 与通过梯形法则计算的总积分通量 $\\sum_{k=0}^{N-1} \\frac{h}{2}(n_k^2 + n_{k+1}^2)$ 完全相同。因此，该格式的相对守恒误差 $\\varepsilon$ 将为零，直到机器浮点精度为止。\n\n**2. 耗散、显式有限体积格式**\n\n此格式要求在时间上是一阶的，并包含一个可调的耗散参数 $\\nu \\ge 0$。在 $n$ 方程中引入耗散的最标准方法是添加一个线性阻尼项，将方程修改为：\n$$\n\\frac{dn}{du} = -\\omega^2 c - \\nu n\n$$\n这代表一个阻尼谐振子。对于一阶显式格式，我们采用前向欧拉方法。从步骤 $k$ 推进到 $k+1$ 的更新规则是：\n$$\nc_{k+1} = c_k + h n_k\n$$\n$$\nn_{k+1} = n_k + h (-\\omega^2 c_k - \\nu n_k)\n$$\n对于质量更新，问题指定使用左端点值 $n_k$ 的一阶显式通量。这对应于 $dM/du = -n^2$ 的前向欧拉离散化：\n$$\nM_{k+1} = M_k - h n_k^2\n$$\n在此格式中，离散质量损失 $M_0 - M_N = \\sum_{k=0}^{N-1} h n_k^2$ 基于通量的一阶（左矩形）求积。守恒误差 $\\varepsilon$ 是通过将此损失与通量的二阶梯形求积 $\\sum_{k=0}^{N-1} \\frac{h}{2}(n_k^2 + n_{k+1}^2)$ 进行比较来计算的。在一般情况下，差值非零：\n$$\n(M_0 - M_N) - \\sum_{k=0}^{N-1} \\frac{h}{2}(n_k^2 + n_{k+1}^2) = \\sum_{k=0}^{N-1} h n_k^2 - \\sum_{k=0}^{N-1} \\frac{h}{2}(n_k^2 + n_{k+1}^2) = \\frac{h}{2} \\sum_{k=0}^{N-1} (n_k^2 - n_{k+1}^2)\n$$\n这是一个裂项求和，可简化为 $\\frac{h}{2} (n_0^2 - n_N^2)$。因此，绝对误差为 $\\frac{h}{2} |n_0^2 - n_N^2|$，相对守恒误差为：\n$$\n\\varepsilon = \\frac{h |n_0^2 - n_N^2|}{2 |M_0|}\n$$\n这个解析结果证实，耗散格式根据其设计，在指定意义上不守恒通量。\n\n该实现将针对给定的测试用例模拟两种格式，并为每种格式计算相对守恒误差 $\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_structure_preserving(omega, h, N, c0, n0, M0):\n    \"\"\"\n    Implements the structure-preserving scheme using Velocity-Verlet for (c, n)\n    and a trapezoidal update for M.\n    \"\"\"\n    c = np.zeros(N + 1)\n    n = np.zeros(N + 1)\n    M = np.zeros(N + 1)\n\n    c[0], n[0], M[0] = c0, n0, M0\n    \n    omega_sq = omega**2\n    h_sq = h**2\n\n    for k in range(N):\n        c_prev = c[k]\n        n_prev = n[k]\n        M_prev = M[k]\n        \n        # Velocity-Verlet for (c, n)\n        c_next = c_prev + h * n_prev - 0.5 * h_sq * omega_sq * c_prev\n        n_next = n_prev - 0.5 * h * omega_sq * (c_prev + c_next)\n        \n        # Time-centered mass loss matching trapezoidal flux\n        M_next = M_prev - 0.5 * h * (n_prev**2 + n_next**2)\n        \n        c[k+1], n[k+1], M[k+1] = c_next, n_next, M_next\n\n    # Calculate total mass loss and trapezoidal flux\n    total_mass_loss = M[0] - M[N]\n    \n    trapezoidal_flux = 0.0\n    for k in range(N):\n        trapezoidal_flux += 0.5 * h * (n[k]**2 + n[k+1]**2)\n\n    # Calculate relative conservation error\n    error = np.abs(total_mass_loss - trapezoidal_flux) / np.abs(M[0])\n    return error\n\n\ndef run_dissipative(omega, h, N, nu, c0, n0, M0):\n    \"\"\"\n    Implements the dissipative scheme using Forward Euler for (c, n, M).\n    \"\"\"\n    c = np.zeros(N + 1)\n    n = np.zeros(N + 1)\n    M = np.zeros(N + 1)\n    \n    c[0], n[0], M[0] = c0, n0, M0\n    \n    omega_sq = omega**2\n\n    for k in range(N):\n        c_prev = c[k]\n        n_prev = n[k]\n        M_prev = M[k]\n        \n        # Forward Euler for (c, n) with dissipation\n        c_next = c_prev + h * n_prev\n        n_next = n_prev + h * (-omega_sq * c_prev - nu * n_prev)\n        \n        # Forward Euler (left-endpoint) for mass loss\n        M_next = M_prev - h * n_prev**2\n        \n        c[k+1], n[k+1], M[k+1] = c_next, n_next, M_next\n        \n    # Calculate total mass loss and trapezoidal flux\n    total_mass_loss = M[0] - M[N]\n    \n    trapezoidal_flux = 0.0\n    for k in range(N):\n        trapezoidal_flux += 0.5 * h * (n[k]**2 + n[k+1]**2)\n    \n    # Calculate relative conservation error\n    error = np.abs(total_mass_loss - trapezoidal_flux) / np.abs(M[0])\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (0.8, 0.05, 300, 0.1, 1.0, 0.0, 10.0),\n        (0.0, 0.1, 200, 0.05, 1.0, 0.5, 10.0),\n        (1.5, 0.2, 120, 0.3, 1.0, 0.0, 10.0),\n        (2.5, 0.35, 80, 0.5, 1.0, 0.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        omega, h, N, nu, c0, n0, M0 = case\n        \n        # Run structure-preserving scheme\n        err_sp = run_structure_preserving(omega, h, N, c0, n0, M0)\n        results.append(err_sp)\n        \n        # Run dissipative scheme\n        err_diss = run_dissipative(omega, h, N, nu, c0, n0, M0)\n        results.append(err_diss)\n\n    # Format and print the final output\n    output_str = \",\".join([f\"{res:.8f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}