{
    "hands_on_practices": [
        {
            "introduction": "将后牛顿（Post-Newtonian, PN）波形与数值相对论（Numerical Relativity, NR）波形拼接在一起的过程需要一个平滑的过渡，以避免引入虚假的噪声。本练习将探讨几种用于在“匹配窗口”中混合波形的不同数学函数，即所谓的“锥削函数”（tapers）。通过实现几种常见的锥削函数，您将通过测量所产生的光谱泄漏来量化评估它们的性能，这是混合波形质量的一个关键指标 。",
            "id": "3477286",
            "problem": "考虑为非自旋、准圆形双星并合构建一个后牛顿-数值相对论 (PN-NR) 混合引力波波形。此构建过程使用一个固定的匹配窗口，在该窗口中，两个时域波形通过一个单调锥削权重进行混合。设混合过程在一个简化的片段上进行，在该片段中，整个匹配窗口内的瞬时引力波频率近似恒定。其合理性在于，对于绝热旋进过程，短时间内的相对频率漂移很小。设 PN 和 NR 片段被建模为具有微小振幅和相位偏移的正弦应变：后牛顿片段为 $h_{\\mathrm{PN}}(t) = A_0 \\cos(2 \\pi f_0 t)$，数值相对论片段为 $h_{\\mathrm{NR}}(t) = A_0(1+\\delta A)\\cos(2 \\pi f_0 t + \\delta \\phi)$，其中 $A_0$ 是无量纲应变振幅，$f_0$ 是以 $\\mathrm{Hz}$ 为单位的引力波频率，$\\delta A$ 是无量纲的，$\\delta \\phi$ 以弧度为单位。\n\n定义一个从时间 $t_m$ 开始、持续时间为 $\\tau$ 的匹配窗口，两者单位均为秒(s)。混合波形 $h_{\\mathrm{hyb}}(t)$ 的构造方法如下：\n- 当 $t  t_m$ 时，$h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t)$，\n- 当 $t_m \\le t  t_m + \\tau$ 时，$h_{\\mathrm{hyb}}(t) = (1 - w(x)) h_{\\mathrm{PN}}(t) + w(x) h_{\\mathrm{NR}}(t)$，其中 $x = (t - t_m)/\\tau \\in [0,1]$，\n- 当 $t \\ge t_m + \\tau$ 时，$h_{\\mathrm{hyb}}(t) = h_{\\mathrm{NR}}(t)$。\n\n锥削权重 $w(x)$ 从以下三个选项中选择：\n- Hann 升余弦锥削：$w_{\\mathrm{Hann}}(x) = \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right)$，其中 $x \\in [0,1]$。\n- 类 Tukey 单调锥削，作为线性和升余弦轮廓的凸组合，参数为 $\\alpha \\in [0,1]$：$w_{\\mathrm{Tukey}}(x; \\alpha) = (1 - \\alpha) x + \\alpha \\, \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right)$，其中 $x \\in [0,1]$。\n- Planck 锥削，陡峭度参数为 $\\varepsilon  0$：$w_{\\mathrm{Planck}}(x; \\varepsilon) = \\left[1 + \\exp\\!\\left(\\varepsilon\\left(\\frac{1}{x} - \\frac{1}{1-x}\\right)\\right)\\right]^{-1}$，其中 $x \\in (0,1)$，且极限为 $w_{\\mathrm{Planck}}(0;\\varepsilon)=0$，$w_{\\mathrm{Planck}}(1;\\varepsilon)=1$。\n\n设时间序列在总持续时间 $T$（单位：s）内以 $f_s$（单位：Hz）的速率采样，共有 $N = \\lfloor f_s T \\rfloor$ 个样本，离散时间点为 $t_n = n/f_s$，$n=0,1,\\dots,N-1$。通过实值快速傅里叶变换定义单边离散傅里叶变换 $\\tilde{h}(f_k)$，其频率为 $f_k = k \\Delta f$，其中 $\\Delta f = f_s/N$，$k=0,1,\\dots,\\lfloor N/2 \\rfloor$。\n\n频谱泄漏是由匹配窗口中 $w(x)$ 引入的时间局域化振幅和相位调制引起的，时域中的乘法对应于频域中的频谱卷积。通过峰值旁瓣比来量化泄漏：\n$$\n\\mathcal{L} = \\frac{\\max_{k \\in \\mathcal{K}_{\\mathrm{out}}} \\left| \\tilde{h}(f_k) \\right|}{\\max_{k \\in \\mathcal{K}_{\\mathrm{main}}} \\left| \\tilde{h}(f_k) \\right|},\n$$\n其中 $\\mathcal{K}_{\\mathrm{main}}$ 是目标频率 $f_0$ 的 $\\pm K$ 个频率仓（含边界）内的索引集合，而 $\\mathcal{K}_{\\mathrm{out}}$ 是 $\\mathcal{K}_{\\mathrm{main}}$ 在单边频谱（不含 $k=0$）中的补集。使用 $K=2$。\n\n你的任务是实现一个程序，对下面的每个测试用例，使用每种锥削 $w(x)$ 构建 $h_{\\mathrm{hyb}}(t)$，计算 $\\left|\\tilde{h}(f)\\right|$，评估 $\\mathcal{L}$，并确定哪种锥削能最小化旁瓣水平（即最小化 $\\mathcal{L}$）。将锥削选项映射到整数代码：Hann $\\rightarrow 0$，Tukey $\\rightarrow 1$，Planck $\\rightarrow 2$。\n\n使用以下测试套件，所有量均使用指定单位：\n- 测试用例 1（理想路径）：$f_s = 4096\\,\\mathrm{Hz}$，$T = 1.0\\,\\mathrm{s}$，$f_0 = 128\\,\\mathrm{Hz}$，$t_m = 0.4\\,\\mathrm{s}$，$\\tau = 0.2\\,\\mathrm{s}$，$A_0 = 1.0$，$\\delta A = 0.05$，$\\delta \\phi = 0.2$ 弧度，Tukey 参数 $\\alpha = 0.5$，Planck 参数 $\\varepsilon = 0.1$。\n- 测试用例 2（边界：一个周期的极短匹配窗口）：$f_s = 2048\\,\\mathrm{Hz}$，$T = 1.0\\,\\mathrm{s}$，$f_0 = 64\\,\\mathrm{Hz}$，$t_m = 0.5\\,\\mathrm{s}$，$\\tau = 1/64\\,\\mathrm{s}$，$A_0 = 1.0$，$\\delta A = 0.05$，$\\delta \\phi = 0.4$ 弧度，$\\alpha = 0.5$，$\\varepsilon = 0.1$。\n- 测试用例 3（边缘：陡峭过渡敏感性）：$f_s = 8192\\,\\mathrm{Hz}$，$T = 1.0\\,\\mathrm{s}$，$f_0 = 256\\,\\mathrm{Hz}$，$t_m = 0.3\\,\\mathrm{s}$，$\\tau = 0.1\\,\\mathrm{s}$，$A_0 = 1.0$，$\\delta A = 0.10$，$\\delta \\phi = 0.3$ 弧度，$\\alpha = 0.1$，$\\varepsilon = 0.05$。\n\n角度单位必须是弧度。频率单位必须是赫兹 ($\\mathrm{Hz}$)。时间单位必须是秒 ($\\mathrm{s}$)。振幅是无量纲的。将所有计算出的泄漏比 $\\mathcal{L}$ 内部表示为十进制浮点数。\n\n最终输出格式：你的程序应生成单行输出，其中包含按顺序为每个测试用例最小化旁瓣水平的锥削所对应的整数代码，形式为方括号括起来的逗号分隔列表（例如 $\\left[0,1,2\\right]$）。程序必须在没有任何外部输入的情况下运行，并且必须遵守指定的运行时环境。",
            "solution": "所提出的问题是信号处理领域一个有效且适定的练习，其背景是引力波数据分析。具体而言，它涉及混合波形的构建，这是一种在数值相对论和引力波物理学中用于将解析的后牛顿 (PN) 旋进波形与双星并合及铃振的完整数值相对论 (NR) 模拟相结合的标准技术。该问题是一个简化但概念上合理的模型，用于研究此混合过程引入的频谱伪影。\n\n该解决方案按算法步骤进行：首先为每个指定的锥削函数构建时域混合波形 $h_{\\mathrm{hyb}}(t)$。随后，我们使用快速傅里叶变换 (FFT) 进行频谱分析，以量化频谱泄漏，这是一种衡量功率向信号中心频率邻近频率伪扩散的指标。对于给定的参数，导致最小泄漏的锥削被视为最优选择。\n\n**1. 波形与混合模型**\n\n问题为 PN 和 NR 波形提供了简化的单频模型。\nPN 波形由下式给出：\n$$h_{\\mathrm{PN}}(t) = A_0 \\cos(2 \\pi f_0 t)$$\nNR 波形由下式给出：\n$$h_{\\mathrm{NR}}(t) = A_0(1+\\delta A)\\cos(2 \\pi f_0 t + \\delta \\phi)$$\n此处，$A_0$ 是标称振幅，$f_0$ 是频率，$\\delta A$ 是分数振幅差，$\\delta \\phi$ 是两个模型之间的相位差。这些差异 $\\delta A$ 和 $\\delta \\phi$ 代表了混合过程旨在协调的失配。\n\n混合波形 $h_{\\mathrm{hyb}}(t)$ 在总持续时间 $T$ 内分三段构建：\n-   当 $t  t_m$ 时，波形为纯 PN：$h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t)$。\n-   当 $t \\ge t_m + \\tau$ 时，波形为纯 NR：$h_{\\mathrm{hyb}}(t) = h_{\\mathrm{NR}}(t)$。\n-   在匹配窗口 $t_m \\le t  t_m + \\tau$ 内，两者进行混合：\n    $$h_{\\mathrm{hyb}}(t) = (1 - w(x)) h_{\\mathrm{PN}}(t) + w(x) h_{\\mathrm{NR}}(t)$$\n    其中 $x = (t - t_m)/\\tau$ 是一个归一化时间变量，它将区间 $[t_m, t_m+\\tau)$ 映射到 $[0, 1)$。函数 $w(x)$ 是一个单调锥削函数（或窗口），它从 $w(0)=0$ 平滑过渡到 $w(1)=1$。\n\n**2. 锥削函数**\n\n$w(x)$ 的选择对于最小化不连续性及其频谱影响至关重要。问题指定了三个选项：\n\n-   **Hann 锥削**：一种升余弦函数，在信号处理中广泛使用。\n    $$w_{\\mathrm{Hann}}(x) = \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right), \\quad x \\in [0,1]$$\n-   **类 Tukey 锥削**：线形斜坡和 Hann 锥削的凸组合，由参数 $\\alpha \\in [0,1]$ 控制。\n    $$w_{\\mathrm{Tukey}}(x; \\alpha) = (1 - \\alpha) x + \\alpha \\, \\frac{1}{2}\\left(1 - \\cos(\\pi x)\\right), \\quad x \\in [0,1]$$\n-   **Planck 锥削**：一个带有参数 $\\varepsilon > 0$ 的函数，它允许在 $x=0$ 和 $x=1$ 处具有非常平坦的轮廓，从而提供极其平滑的过渡。\n    $$w_{\\mathrm{Planck}}(x; \\varepsilon) = \\left[1 + \\exp\\!\\left(\\varepsilon\\left(\\frac{1}{x} - \\frac{1}{1-x}\\right)\\right)\\right]^{-1}, \\quad x \\in (0,1)$$\n    其极限为 $w_{\\mathrm{Planck}}(0;\\varepsilon)=0$ 和 $w_{\\mathrm{Planck}}(1;\\varepsilon)=1$。\n\n匹配窗口中的混合过程可以重写为 $h_{\\mathrm{hyb}}(t) = h_{\\mathrm{PN}}(t) + w(x) (h_{\\mathrm{NR}}(t) - h_{\\mathrm{PN}}(t))$。这表明混合过程实际上是向 PN 波形添加了一个时间局域化的“校正”信号 $w(x) (h_{\\mathrm{NR}}(t) - h_{\\mathrm{PN}}(t))$。时域中的乘法对应于频域中的卷积。这个校正信号的频谱受到谱宽的窗函数 $w(x)$ 的影响，它与 $h_{\\mathrm{PN}}$ 和 $h_{\\mathrm{NR}}$ 的频谱进行卷积，从而将功率扩散到相邻的频率仓中。这是频谱泄漏的一个典型来源。\n\n**3. 频谱泄漏量化**\n\n为量化此效应，我们使用时间序列 $h_{\\mathrm{hyb}}(t_n)$（其中 $t_n=n/f_s$）的单边离散傅里叶变换 $\\tilde{h}(f_k)$。峰值旁瓣比 $\\mathcal{L}$ 定义为：\n$$\n\\mathcal{L} = \\frac{\\max_{k \\in \\mathcal{K}_{\\mathrm{out}}} \\left| \\tilde{h}(f_k) \\right|}{\\max_{k \\in \\mathcal{K}_{\\mathrm{main}}} \\left| \\tilde{h}(f_k) \\right|}\n$$\n主瓣 $\\mathcal{K}_{\\mathrm{main}}$ 定义为中心频率 $f_0$ 周围 $K=2$ 个频率仓内的区域。旁瓣区域 $\\mathcal{K}_{\\mathrm{out}}$ 包含单边频谱中除主瓣和直流分量（$k=0$）外的所有其他频率仓。较小的 $\\mathcal{L}$ 值表示频谱泄漏较少，混合效果更好。\n\n**4. 算法实现**\n\n对每个测试用例执行以下步骤：\n1.  离散化时间轴：生成一个包含 $N = \\lfloor f_s T \\rfloor$ 个点 $t_n = n/f_s$ 的数组。\n2.  对三种锥削函数（Hann、类 Tukey、Planck）中的每一种：\n    a.  通过识别与匹配前、匹配中和匹配后区域相对应的索引，并应用适当的公式来构建完整的混合波形 $h_{\\mathrm{hyb}}(t_n)$。对于 Planck 锥削，必须注意边界 $x=0$ 和 $x=1$ 处的情况以避免数值错误，如问题中的极限定义所规定。\n    b.  使用实数 FFT 算法计算 $h_{\\mathrm{hyb}}(t_n)$ 的单边 FFT，得到复数值频谱 $\\tilde{h}(f_k)$。\n    c.  识别与 $f_0$ 对应的频率仓 $k_0$。\n    d.  确定主瓣频率仓集合 $\\mathcal{K}_{\\mathrm{main}}$（索引从 $k_0-K$ 到 $k_0+K$）和旁瓣频率仓集合 $\\mathcal{K}_{\\mathrm{out}}$。\n    e.  计算每个区域中的最大幅值，并计算它们的比率以求得 $\\mathcal{L}$。\n3.  比较三种锥削的 $\\mathcal{L}$ 值。选择与最小 $\\mathcal{L}$ 值对应的锥削，并记录其整数代码（Hann: $0$, Tukey: $1$, Planck: $2$）。\n4.  对所有测试用例重复此过程，并格式化输出最优锥削代码的最终列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hybrid waveform spectral leakage problem for all test cases.\n    \"\"\"\n    # Test cases as provided in the problem statement.\n    test_cases = [\n        # (fs, T, f0, tm, tau, A0, deltaA, delta_phi, alpha, epsilon)\n        (4096, 1.0, 128, 0.4, 0.2, 1.0, 0.05, 0.2, 0.5, 0.1),\n        (2048, 1.0, 64, 0.5, 1/64, 1.0, 0.05, 0.4, 0.5, 0.1),\n        (8192, 1.0, 256, 0.3, 0.1, 1.0, 0.10, 0.3, 0.1, 0.05),\n    ]\n\n    # Map taper names to their integer codes for the final output.\n    TAPER_CODES = {'Hann': 0, 'Tukey': 1, 'Planck': 2}\n    TAPER_ORDER = ['Hann', 'Tukey', 'Planck']\n    \n    final_results = []\n\n    for case in test_cases:\n        fs, T, f0, tm, tau, A0, deltaA, delta_phi, alpha, epsilon = case\n        K = 2  # Width of the main lobe in bins, as per problem.\n\n        # 1. Time-Domain Waveform Construction\n        N = int(fs * T)\n        t = np.arange(N) / fs\n\n        h_pn = A0 * np.cos(2 * np.pi * f0 * t)\n        h_nr = A0 * (1 + deltaA) * np.cos(2 * np.pi * f0 * t + delta_phi)\n\n        mask_pre = t  tm\n        mask_window = (t >= tm)  (t  tm + tau)\n        mask_post = t >= tm + tau\n        \n        # Normalized time in the window\n        t_window = t[mask_window]\n        x_window = (t_window - tm) / tau\n\n        # 2. Tapering Functions\n        def hann_taper(x):\n            return 0.5 * (1 - np.cos(np.pi * x))\n\n        def tukey_like_taper(x, alpha_param):\n            return (1 - alpha_param) * x + alpha_param * hann_taper(x)\n\n        def planck_taper(x, epsilon_param):\n            w = np.zeros_like(x, dtype=float)\n            \n            # Masks for boundaries and the middle part\n            mask_mid = (x > 0)  (x  1)\n            \n            # Calculate for the middle part where x is in (0, 1)\n            x_mid = x[mask_mid]\n            # Numpy's float mechanics handle large exponents correctly:\n            # exp(large_pos) -> inf, and 1/(1+inf) -> 0.0\n            # exp(large_neg) -> 0.0, and 1/(1+0) -> 1.0\n            arg = epsilon_param * (1.0/x_mid - 1.0/(1.0 - x_mid))\n            w[mask_mid] = 1.0 / (1.0 + np.exp(arg))\n            \n            # Apply hard-coded boundary conditions from the problem statement\n            w[x == 0] = 0.0\n            w[x >= 1] = 1.0\n            \n            return w\n\n        taper_funcs = {\n            'Hann': lambda x: hann_taper(x),\n            'Tukey': lambda x: tukey_like_taper(x, alpha),\n            'Planck': lambda x: planck_taper(x, epsilon),\n        }\n\n        leakages = []\n\n        for taper_name in TAPER_ORDER:\n            # Generate the taper weight for the window\n            w = taper_funcs[taper_name](x_window)\n            \n            # Construct the hybrid waveform\n            h_hyb = np.zeros(N)\n            h_hyb[mask_pre] = h_pn[mask_pre]\n            h_hyb[mask_post] = h_nr[mask_post]\n            h_hyb[mask_window] = (1 - w) * h_pn[mask_window] + w * h_nr[mask_window]\n\n            # 3. Spectral Leakage Quantification\n            leakage = calculate_leakage(h_hyb, N, fs, f0, K)\n            leakages.append(leakage)\n\n        # 4. Determine which taper minimizes leakage\n        best_taper_index = np.argmin(leakages)\n        best_taper_name = TAPER_ORDER[best_taper_index]\n        final_results.append(TAPER_CODES[best_taper_name])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef calculate_leakage(h, N, fs, f0, K):\n    \"\"\"\n    Calculates the peak side-lobe ratio for a given time-domain signal.\n\n    Args:\n        h (np.ndarray): The time-domain signal.\n        N (int): The number of samples in the signal.\n        fs (float): The sampling rate.\n        f0 (float): The target central frequency.\n        K (int): The half-width of the main-lobe region in frequency bins.\n\n    Returns:\n        float: The calculated peak side-lobe ratio.\n    \"\"\"\n    # Compute the one-sided real FFT\n    h_fft = np.fft.rfft(h)\n    fft_mags = np.abs(h_fft)\n    freqs = np.fft.rfftfreq(N, d=1/fs)\n    N_fft = len(freqs)\n\n    # Find the index corresponding to the target frequency f0\n    k0 = np.argmin(np.abs(freqs - f0))\n\n    # Define main lobe and side lobe regions\n    main_lobe_start = max(0, k0 - K)\n    main_lobe_end = min(N_fft - 1, k0 + K)\n\n    main_lobe_max = np.max(fft_mags[main_lobe_start:main_lobe_end + 1])\n    \n    if main_lobe_max == 0:\n        return np.inf  # Avoid division by zero\n\n    # Create a mask for the side-lobe region\n    sidelobe_mask = np.ones(N_fft, dtype=bool)\n    # Exclude DC component\n    sidelobe_mask[0] = False\n    # Exclude the main lobe\n    sidelobe_mask[main_lobe_start:main_lobe_end + 1] = False\n    \n    # If no side-lobes exist (e.g., very coarse spectrum), leakage is zero\n    if not np.any(sidelobe_mask):\n        return 0.0\n\n    sidelobe_max = np.max(fft_mags[sidelobe_mask])\n\n    return sidelobe_max / main_lobe_max\n\n\nsolve()\n```"
        },
        {
            "introduction": "选择正确的频率范围来进行混合，对于最小化最终波形的整体误差至关重要。本练习将指导您建立一个简化但物理动机明确的模型，以确定这个“最佳匹配频率”。您将通过平衡后牛顿模型的理论误差（该误差在高频时会变差）与数值相对论模拟的数值误差（在对应于早期旋进的较低分辨率下误差较大）来实现这一目标 。",
            "id": "3477332",
            "problem": "您的任务是构建一个简单的、有原则的模型，通过将一个模型化的后牛顿（PN）相位截断误差与一个模型化的数值相对论（NR）相位误差相等，来估计最优的后牛顿（PN）-数值相对论（NR）混合频率。目的是分析质量比的增加如何将匹配窗口推向更低的频率。您必须实现一个程序，使用下面的模型，计算三种质量比下 PN 相位误差等于 NR 相位误差时的频率（以赫兹为单位），并检验其与质量比的单调趋势。所有物理常数和单位必须完全按照规定使用，并且最终输出格式必须与要求完全一致。\n\n基本基础和建模假设：\n- 对于准圆形旋进，轨道速度参数 $v$ 通过 $v = (\\pi M f)^{1/3}$ 与引力波频率相关，其中 $M$ 是总质量（在 $G=c=1$ 时单位为秒），$f$ 是观测频率（单位为赫兹）。这源于平衡定律和连接相位演化与速度的主阶圆形轨道关系，以及连接轨道频率和引力波频率的稳相近似。\n- 主导的后牛顿（PN）相位截断误差与 $v$ 的正幂成比例，代表截断之外缺失的主导高阶项。对于一个有效幂为 $v^{8}$ 的缺失项，将 PN 相位误差建模为\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right] \\left(\\pi M f\\right)^{8/3},\n$$\n其中 $q \\ge 1$ 是质量比，$\\eta(q) = \\frac{q}{(1+q)^2}$ 是对称质量比，$A_0$ 和 $a_1$ 是正常数。\n- 数值相对论（NR）相位误差在接近并合时增加，并随着质量比的增大而增长，这是由于更高的分辨率要求。将其建模为\n$$\n\\Delta \\Phi_{\\text{NR}}(f,q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right] \\left(M f\\right)^{\\beta},\n$$\n其中 $\\beta = 1$，$B_0$ 和 $b_1$ 是正常数。这捕捉了 NR 相位不确定性随频率和质量比单调增加的特性。\n- 为解决此问题，请使用以下固定常数：\n  - 总质量 $M = 60\\,M_\\odot$，在几何化单位制下使用 $1\\,M_\\odot = 4.92549095\\times 10^{-6}\\,\\mathrm{s}$ 转换为秒，所以 $M = 60 \\times 4.92549095\\times 10^{-6}\\,\\mathrm{s}$。\n  - 系数 $A_0 = 0.03125$, $a_1 = 6.0$, $B_0 = 0.001$, $b_1 = 0.5$, 及 $\\beta = 1$。\n- 假设为无自旋双星和准圆形旋进。\n\n任务：\n- 对于每个质量比 $q \\in \\{1,3,8\\}$，计算等式\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = \\Delta \\Phi_{\\text{NR}}(f,q)\n$$\n成立时的频率 $f_{\\text{match}}(q)$。在区间 $[f_{\\min}, f_{\\max}] = [10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 上数值求解 $f$。如果在此区间内不存在解，则对该情况返回 $\\mathrm{NaN}$。\n- 所有返回的频率以 $\\mathrm{Hz}$ 为单位表示，并四舍五入到三位小数。\n- 同时计算一个布尔值，指示最优匹配频率是否随质量比的增加而严格减小，即是否 $f_{\\text{match}}(1)  f_{\\text{match}}(3)  f_{\\text{match}}(8)$。\n- 同时计算一个布尔值，指示所有三个解是否都位于闭区间 $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 内。\n\n测试套件：\n- 使用三个质量比 $q \\in \\{1,3,8\\}$ 作为主要测试用例。\n- 单调性检查 $f_{\\text{match}}(1)  f_{\\text{match}}(3)  f_{\\text{match}}(8)$ 提供了一个覆盖率检查，用于探究增加 $q$ 的效果。\n- 带内检查，即所有 $f_{\\text{match}}(q)$ 均在 $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 内，为指定区间上的数值求根器提供了一个边界条件检查。\n\n最终输出格式：\n- 您的程序必须打印一行包含一个无空格的 Python 风格列表，按以下顺序汇总结果：\n  1. $f_{\\text{match}}(1)$，单位为 $\\mathrm{Hz}$，四舍五入到三位小数，\n  2. $f_{\\text{match}}(3)$，单位为 $\\mathrm{Hz}$，四舍五入到三位小数，\n  3. $f_{\\text{match}}(8)$，单位为 $\\mathrm{Hz}$，四舍五入到三位小数，\n  4. 一个表示随 $q$ 增加而严格单调递减的布尔值，\n  5. 一个表示所有三个频率都在 $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 区间内的带内检查的布尔值。\n- 格式示例：$[68.700,65.000,41.400,True,True]$。",
            "solution": "用户提供了一个科学上合理、定义明确且客观的问题。它模拟了引力波物理学中的一个常见任务：后牛顿（PN）波形和数值相对论（NR）波形的混合。所提供的相位误差模型虽然经过简化，但具有物理动机且在数学上是一致的。所有常数和参数都已明确定义，任务也已无歧义地指定。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n问题的核心是找到引力波频率 $f$，在该频率下，对于给定的质量比 $q$，模型化的 PN 相位误差 $\\Delta \\Phi_{\\text{PN}}(f,q)$ 等于模型化的 NR 相位误差 $\\Delta \\Phi_{\\text{NR}}(f,q)$。这个频率 $f_{\\text{match}}(q)$ 代表了从 PN 近似切换到完整 NR 解的最优点。\n\n两种误差模型给出如下：\n$$\n\\Delta \\Phi_{\\text{PN}}(f,q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right] \\left(\\pi M f\\right)^{8/3}\n$$\n$$\n\\Delta \\Phi_{\\text{NR}}(f,q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right] \\left(M f\\right)^{\\beta}\n$$\n其中 $\\beta = 1$。对称质量比为 $\\eta(q) = \\frac{q}{(1+q)^2}$，$M$ 是以几何化单位（秒）表示的总质量。\n\n为了找到 $f_{\\text{match}}(q)$，我们设 $\\Delta \\Phi_{\\text{PN}}(f,q) = \\Delta \\Phi_{\\text{NR}}(f,q)$ 并求解 $f$。为了清晰起见，我们定义依赖于 $q$ 的系数：\n$$\nC_{\\text{PN}}(q) = A_0 \\left[1 + a_1 \\bigl(1 - 4\\eta(q)\\bigr)^2\\right]\n$$\n$$\nC_{\\text{NR}}(q) = B_0 \\left[1 + b_1 \\frac{q-1}{q+1}\\right]\n$$\n等式变为：\n$$\nC_{\\text{PN}}(q) \\left(\\pi M f\\right)^{8/3} = C_{\\text{NR}}(q) \\left(M f\\right)\n$$\n该方程在 $f=0$ 处有一个平凡解。对于 $f \\neq 0$，我们可以重新排列各项来求解 $f$：\n$$\nf^{8/3 - 1} = \\frac{C_{\\text{NR}}(q) M}{C_{\\text{PN}}(q) (\\pi M)^{8/3}}\n$$\n$$\nf^{5/3} = \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\frac{M}{\\pi^{8/3} M^{8/3}} = \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\pi^{-8/3} M^{-5/3}\n$$\n这为 $f$ 产生了一个唯一的、正的解析解：\n$$\nf_{\\text{match}}(q) = \\left[ \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\pi^{-8/3} M^{-5/3} \\right]^{3/5} = \\left[ \\frac{C_{\\text{NR}}(q)}{C_{\\text{PN}}(q)} \\right]^{3/5} \\pi^{-8/5} M^{-1}\n$$\n虽然存在解析解，但问题要求在区间 $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 上进行数值求解。我们将为函数 $g(f,q) = \\Delta \\Phi_{\\text{PN}}(f,q) - \\Delta \\Phi_{\\text{NR}}(f,q) = 0$ 实现一个数值求根算法。Brent-Dekker 方法 (`scipy.optimize.brentq`) 是完成此任务的一个稳健选择，因为它保证在端点函数值异号的括号区间内找到一个根。\n\n算法流程如下：\n1.  定义所有物理和模型常数，包括以秒为单位的总质量 $M$。$M = 60\\, M_\\odot \\times 4.92549095 \\times 10^{-6}\\,\\mathrm{s}/M_\\odot$。\n2.  对于每个质量比 $q \\in \\{1, 3, 8\\}$：\n    a. 如上所述定义差分函数 $g(f,q)$。\n    b. 检查 $g(10\\,\\mathrm{Hz}, q)$ 和 $g(400\\,\\mathrm{Hz}, q)$ 的符号。由于 $\\Delta \\Phi_{\\text{PN}} \\propto f^{8/3}$ 且 $\\Delta \\Phi_{\\text{NR}} \\propto f^1$，对于小的 $f$，$g(f,q)$ 将为负，对于大的 $f$ 则为正，这保证了如果根位于区间内，则该单根被括号括住。\n    c. 使用 `scipy.optimize.brentq` 在区间 $[10, 400]$ 内找到根 $f_{\\text{match}}(q)$。如果根没有被括号括住，`brentq` 将引发一个错误，我们根据问题规范通过赋 `NaN` 来处理。\n3.  在计算完所有三个质量比的频率后，执行两个必需的布尔检查：\n    a. **单调性检查：** 验证是否 $f_{\\text{match}}(1)  f_{\\text{match}}(3)  f_{\\text{match}}(8)$。这是符合预期的，因为更高质量比的 NR 模拟的复杂性增加（由 $C_{\\text{NR}}(q)$ 项建模）以及高阶 PN 贡献的减少（由 $C_{\\text{PN}}(q)$ 项建模）倾向于将最优点推向更早的时间，从而推向更低的频率。\n    b. **带内检查：** 验证所有三个频率是否都在指定区间 $[10\\,\\mathrm{Hz}, 400\\,\\mathrm{Hz}]$ 内成功找到。当且仅当所有结果都不是 `NaN` 时，此项为 `True`。\n4.  最后，将结果格式化为单个字符串，形式为一个 Python 风格的列表：三个四舍五入到三位小数的频率，后跟两个布尔值。\n\n这种系统性的方法确保了问题的所有约束都得到满足，从而得出一个可验证且正确的解决方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the PN-NR hybridization frequency and performs validation checks.\n    \"\"\"\n    # Define physical and model constants as specified in the problem statement.\n    M_SOLAR_IN_S = 4.92549095e-6\n    M_TOTAL_SOLAR = 60.0\n    M = M_TOTAL_SOLAR * M_SOLAR_IN_S\n    A0 = 0.03125\n    a1 = 6.0\n    B0 = 0.001\n    b1 = 0.5\n    \n    # Define the mass ratios for the test suite and the frequency search interval.\n    test_cases = [1.0, 3.0, 8.0]  # Mass ratios q\n    f_min, f_max = 10.0, 400.0\n\n    # Helper function to compute the symmetric mass ratio eta.\n    def eta(q):\n        return q / (1.0 + q)**2\n\n    # Define the difference function whose root is the matching frequency.\n    # g(f, q) = ΔΦ_PN(f, q) - ΔΦ_NR(f, q)\n    def difference_function(f, q):\n        \"\"\"Calculates the difference between PN and NR phase error models.\"\"\"\n        # Calculate the PN phase error term.\n        pn_coeff = A0 * (1.0 + a1 * (1.0 - 4.0 * eta(q))**2)\n        pn_error = pn_coeff * (np.pi * M * f)**(8.0/3.0)\n        \n        # Calculate the NR phase error term.\n        nr_coeff = B0 * (1.0 + b1 * (q - 1.0) / (q + 1.0))\n        nr_error = nr_coeff * M * f\n        \n        return pn_error - nr_error\n\n    frequencies_raw = []\n    \n    for q in test_cases:\n        try:\n            # The Brent-Dekker method requires f(a) and f(b) to have opposite signs.\n            # Check if a root is bracketed within the specified interval.\n            val_min = difference_function(f_min, q)\n            val_max = difference_function(f_max, q)\n            if np.sign(val_min) == np.sign(val_max):\n                raise ValueError(\"Root not bracketed in the interval.\")\n            \n            # Find the root numerically.\n            f_match = brentq(difference_function, f_min, f_max, args=(q,))\n            frequencies_raw.append(f_match)\n        except ValueError:\n            # If no root is found in the interval, append NaN as required.\n            frequencies_raw.append(np.nan)\n\n    # Perform the two boolean checks on the computed frequencies.\n    \n    # 1. In-band check: This is true if and only if no NaN values were produced.\n    all_in_band = not any(np.isnan(f) for f in frequencies_raw)\n    \n    # 2. Monotonicity check: f_match must be strictly decreasing with 'q'.\n    # This check is only meaningful if all frequencies were successfully found.\n    is_monotonic = False\n    if all_in_band:\n        if frequencies_raw[0] > frequencies_raw[1] and frequencies_raw[1] > frequencies_raw[2]:\n            is_monotonic = True\n\n    # Assemble the final list for printing, formatting each element as required.\n    output_parts = []\n    for f in frequencies_raw:\n        if np.isnan(f):\n            output_parts.append('NaN')\n        else:\n            # Format frequencies to three decimal places.\n            output_parts.append(f\"{f:.3f}\")\n    \n    output_parts.append(str(is_monotonic))\n    output_parts.append(str(all_in_band))\n\n    # Print the final result in the exact specified format: [f1,f3,f8,mono,in_band]\n    print(f\"[{','.join(output_parts)}]\")\n\n# Execute the solver.\nsolve()\n```"
        },
        {
            "introduction": "在混合过程中所做的选择——例如使用哪个后牛顿近似以及哪个对齐窗口——并非唯一，这会导致最终波形中存在系统不确定性。这个综合性练习模拟了一项研究级别的蒙特卡罗（Monte Carlo）研究，以量化这些系统不确定性。通过在不同假设下生成大量的混合波形样本，您将测量这些选择如何传播到关键物理参数——啁啾质量 $\\mathcal{M}$ 的不确定性中 。",
            "id": "3477295",
            "problem": "实现一个完整的、确定性的蒙特卡洛研究，以量化通过将后牛顿（PN）旋进模型与简化的类数值相对论（NR）代理模型相匹配而形成的混合引力波频域波形中的系统性展宽，并报告在固定总质量 $M$ 下，啁啾质量 $\\mathcal{M}$ 的等尾置信区间。此任务必须基于以下基本原理和规范，从第一性原理出发进行求解。\n\n其物理和数学基础如下。考虑在稳相近似下的无自旋、准圆形致密双星系统，并将 PN TaylorF2 族的频域引力波相位 $\\psi(f)$ 写成特征速度 $v = (\\pi M f)^{1/3}$ 的幂级数，其中 $M$ 是以几何单位表示的总质量。设对称质量比为 $\\eta = m_1 m_2 / M^2$，其中 $m_1 \\ge m_2$，并定义啁啾质量 $\\mathcal{M} = \\eta^{3/5} M$。内部计算使用几何单位制，令 $G = c = 1$，并在适当时要求与太阳质量单位进行相互转换。太阳质量时间为 $t_{\\odot} = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$。所有频率必须以赫兹（Hz）为单位。所有报告的啁啾质量必须以太阳质量（$M_{\\odot}$）为单位。\n\n使用以下经过充分检验的 PN TaylorF2 无自旋相位的截断形式（即待研究的“PN 近似式”），其表达式中不包含外在的并合时间和相位：\n$$\n\\psi_{\\mathrm{PN}}(f; M, \\eta) \\equiv \\frac{3}{128\\,\\eta}\\,v^{-5}\\,\\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4 \\right],\n$$\n其中 $v = (\\pi M f)^{1/3}$ 且系数为\n$$\n\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9}\\eta,\\quad\n\\alpha_3 = -16\\pi,\\quad\n\\alpha_4 = \\frac{15293365}{508032} + \\frac{27145}{504}\\eta + \\frac{3085}{72}\\eta^2.\n$$\n将“近似式”定义为上述级数的截断：$0$PN 近似式仅使用首项 $1$，$1.5$PN 近似式使用 $1 + \\alpha_2 v^2 + \\alpha_3 v^3$，而 $2$PN 近似式使用 $1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4$。\n\n通过采用上述 $2$PN TaylorF2 相位并添加一个平滑、紧凑的高频修正项，来定义一个简化的频域类 NR 代理模型：\n$$\n\\psi_{\\mathrm{NR}}(f; M, \\eta) = \\psi_{\\mathrm{PN,\\,2PN}}(f; M, \\eta) + \\delta\\psi_{\\mathrm{high}}(f),\n$$\n其中\n$$\n\\delta\\psi_{\\mathrm{high}}(f) = \\kappa \\left(\\frac{f}{f_0}\\right)^2 \\exp\\!\\left(-\\frac{f}{f_{\\mathrm{d}}}\\right),\n$$\n其中 $\\kappa = 2.0$（无量纲），$f_0 = 150\\,\\mathrm{Hz}$，$f_{\\mathrm{d}} = 200\\,\\mathrm{Hz}$。使用形式为 $A(f) \\propto f^{-7/6} \\exp[-(f/f_{\\mathrm{cut}})^7]$ 的振幅模型，其中 $f_{\\mathrm{cut}} = 0.2/M$（单位为赫兹，通过 $M = M_{\\mathrm{tot}}\\,t_{\\odot}$ 将 $M$ 转换为秒），但请注意，振幅不进入下述的啁啾质量估计程序。\n\n通过在一个对齐窗口 $[f_1,f_2]$（单位为赫兹）内，对时间平移 $t_0$ 和相位平移 $\\phi_0$ 最小化最小二乘相位差，将选定的 PN 近似式 $\\psi_{\\mathrm{PN}}(f)$与 $\\psi_{\\mathrm{NR}}(f)$ 对齐，从而形成频域 PN-NR 混合波形：\n$$\n\\min_{t_0,\\phi_0}\\ \\int_{f_1}^{f_2} \\left(\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f)\\right)^2\\,\\mathrm{d}f.\n$$\n使用最优的 $(t_0,\\phi_0)$ 来定义对齐后的 PN 相位 $\\psi_{\\mathrm{PN,\\,aligned}}(f) = \\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0$。定义一个平滑的半余弦锥削函数，用于在窗口内将 PN 和 NR 相位进行融合：\n$$\nw(f) = \n\\begin{cases}\n0,  f \\le f_1, \\\\\n\\frac{1}{2}\\left[1 - \\cos\\!\\left(\\pi\\,\\frac{f-f_1}{f_2-f_1}\\right)\\right],  f_1  f  f_2, \\\\\n1,  f \\ge f_2,\n\\end{cases}\n$$\n以及混合相位\n$$\n\\psi_{\\mathrm{hyb}}(f) = \\left[1-w(f)\\right]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\,\\psi_{\\mathrm{NR}}(f).\n$$\n\n利用相位随频率的牛顿阶标度关系，同时边缘化外在时间和相位，从混合相位的低频部分估计啁啾质量。具体来说，在领头阶，\n$$\n\\psi_{\\mathrm{LO}}(f) = \\frac{3}{128}\\,(\\pi\\,\\mathcal{M}\\,f)^{-5/3} + 2\\pi f\\,t_c - \\phi_c - \\frac{\\pi}{4},\n$$\n因此，在低频段将 $\\psi_{\\mathrm{hyb}}(f)$ 拟合到形式 $\\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$，可以分离出系数 $\\alpha = \\frac{3}{128}(\\pi \\mathcal{M})^{-5/3}$，从而确定 $\\mathcal{M}$。\n\n设计一个针对对齐窗口选择和 PN 近似式的蒙特卡洛研究，以表征在固定的总质量 $M_{\\mathrm{tot}}$ 和质量比 $q = m_1/m_2 \\ge 1$（其中 $\\eta = q/(1+q)^2$）下，恢复出的 $\\mathcal{M}$ 的系统性展宽。对于每次蒙特卡洛试验：\n- 以相等的概率从集合 $\\{0\\mathrm{PN}, 1.5\\mathrm{PN}, 2\\mathrm{PN}\\}$ 中随机选择一个 PN 近似式。\n- 从 $[30,80]\\,\\mathrm{Hz}$ 中均匀随机选择一个对齐窗口宽度 $w_{\\mathrm{Hz}}$。\n- 从 $[f_{\\mathrm{low}} + 60,\\, \\min(f_{\\max} - w_{\\mathrm{Hz}} - 30,\\, f_{\\mathrm{low}}+220)]$ 中均匀随机选择一个起始频率 $f_1$，其中 $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$，$f_{\\max} = \\min(1024\\,\\mathrm{Hz},\\, 0.2/M)$；并设置 $f_2 = f_1 + w_{\\mathrm{Hz}}$。\n- 在从 $f_{\\mathrm{low}}$ 到 $f_{\\max}$、频率间隔为 $\\Delta f = 1\\,\\mathrm{Hz}$ 的频率网格上计算混合相位 $\\psi_{\\mathrm{hyb}}(f)$。\n- 在一个低频段 $[f_{\\mathrm{low}}+2,\\, \\min(f_1-2,\\, f_{\\mathrm{low}}+40,\\, f_{\\max}-5)]$ 上，使用最小二乘法将 $\\psi_{\\mathrm{hyb}}(f)$ 拟合到模型 $\\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$，解出 $\\alpha$，并推断出 $\\mathcal{M}$。\n\n对于指定的试验次数，使用固定的随机种子重复此过程以确保可复现性。根据蒙特卡洛样本的经验 $0.05$ 和 $0.95$ 分位数，计算 $\\mathcal{M}$ 的等尾 $90\\%$ 置信区间。将所有啁啾质量区间的端点以太阳质量（$M_{\\odot}$）为单位表示，并四舍五入到六位小数。\n\n您的程序必须实现上述过程，并为以下四个参数集的测试套件生成结果：\n- 案例1（质量均衡，中等质量）：$M_{\\mathrm{tot}} = 40.0\\,M_{\\odot}$，$q = 1.0$，$N_{\\mathrm{trials}} = 128$，随机种子 $= 7$。\n- 案例2（质量不等，总质量较低）：$M_{\\mathrm{tot}} = 20.0\\,M_{\\odot}$，$q = 3.0$，$N_{\\mathrm{trials}} = 128$，随机种子 $= 11$。\n- 案例3（总质量高，周期数较少）：$M_{\\mathrm{tot}} = 80.0\\,M_{\\odot}$，$q = 1.2$，$N_{\\mathrm{trials}} = 64$，随机种子 $= 13$。\n- 案例4（蒙特卡洛规模边界）：$M_{\\mathrm{tot}} = 60.0\\,M_{\\odot}$，$q = 1.0$，$N_{\\mathrm{trials}} = 16$，随机种子 $= 17$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个列表的列表形式的结果，每个测试案例对应一个列表，每个内部列表包含两个浮点数形式的区间端点 $\\left[\\mathcal{M}_{\\mathrm{low}},\\, \\mathcal{M}_{\\mathrm{high}}\\right]$，单位为太阳质量，四舍五入到六位小数，并且不打印任何额外文本。例如：[[m1_low,m1_high],[m2_low,m2_high],[m3_low,m3_high],[m4_low,m4_high]]。",
            "solution": "用户提供的问题已经过严格验证，并被确定为一项有效、适定的科学任务。\n\n### 第一步：提取已知条件\n- **物理系统**：无自旋、准圆形致密双星。\n- **近似方法**：引力波的稳相近似（SPA）。\n- **单位**：内部计算使用几何单位制（$G=c=1$）。太阳质量时间为 $t_{\\odot} = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$。频率单位为赫兹（Hz）。最终的啁啾质量值单位为太阳质量（$M_{\\odot}$）。\n- **参数**：总质量 $M$（几何单位）或 $M_{\\mathrm{tot}}$（$M_{\\odot}$），对称质量比 $\\eta = m_1 m_2 / M^2$，质量比 $q = m_1/m_2 \\ge 1$，啁啾质量 $\\mathcal{M} = \\eta^{3/5} M$，以及特征速度 $v = (\\pi M f)^{1/3}$。\n- **PN 相位模型 (TaylorF2)**：\n$$\n\\psi_{\\mathrm{PN}}(f; M, \\eta) = \\frac{3}{128\\,\\eta}\\,v^{-5}\\,\\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 + \\alpha_4 v^4 \\right]\n$$\n其中系数为 $\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9}\\eta$，$\\alpha_3 = -16\\pi$，以及 $\\alpha_4 = \\frac{15293365}{508032} + \\frac{27145}{504}\\eta + \\frac{3085}{72}\\eta^2$。\n- **PN 近似式**：$0$PN（仅领头项），$1.5$PN（到 $v^3$ 项），$2$PN（到 $v^4$ 项）。\n- **NR 代理模型**：\n$$\n\\psi_{\\mathrm{NR}}(f; M, \\eta) = \\psi_{\\mathrm{PN,\\,2PN}}(f; M, \\eta) + \\kappa \\left(\\frac{f}{f_0}\\right)^2 \\exp\\!\\left(-\\frac{f}{f_{\\mathrm{d}}}\\right),\n$$\n其中 $\\kappa = 2.0$，$f_0 = 150\\,\\mathrm{Hz}$，$f_{\\mathrm{d}} = 200\\,\\mathrm{Hz}$。\n- **混合方法**：\n    - **对齐**：在 $[f_1, f_2]$ 上最小化 $\\int_{f_1}^{f_2} \\left(\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f)\\right)^2\\,\\mathrm{d}f$ 以找到最优的 $(t_0, \\phi_0)$。\n    - **融合**：使用半余弦锥削函数 $w(f)$ 在 $[f_1, f_2]$ 上构建混合相位 $\\psi_{\\mathrm{hyb}}(f) = \\left[1-w(f)\\right]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\,\\psi_{\\mathrm{NR}}(f)$。\n- **啁啾质量估计**：\n    - 在低频段将 $\\psi_{\\mathrm{hyb}}(f)$ 拟合到模型 $\\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$。\n    - 从拟合系数 $\\alpha = \\frac{3}{128}(\\pi \\mathcal{M})^{-5/3}$ 推断 $\\mathcal{M}$。\n- **蒙特卡洛研究**：\n    - **随机变量**：从 $\\{0\\mathrm{PN}, 1.5\\mathrm{PN}, 2\\mathrm{PN}\\}$ 中选取的 PN 近似式；对齐窗口宽度 $w_{\\mathrm{Hz}} \\sim U[30, 80]\\,\\mathrm{Hz}$；起始频率 $f_1 \\sim U[f_{\\mathrm{low}} + 60,\\, \\min(f_{\\max} - w_{\\mathrm{Hz}} - 30,\\, f_{\\mathrm{low}}+220)]$。\n    - **固定参数**：$f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$，$\\Delta f = 1\\,\\mathrm{Hz}$，$f_{\\max} = \\min(1024\\,\\mathrm{Hz},\\, 0.2/M)$。\n    - **用于 $\\mathcal{M}$ 的拟合频段**：$[f_{\\mathrm{low}}+2,\\, \\min(f_1-2,\\, f_{\\mathrm{low}}+40,\\, f_{\\max}-5)]$。\n    - **输出**：$\\mathcal{M}$ 的等尾 $90\\%$ 置信区间（$[q_{0.05}, q_{0.95}]$），单位为 $M_{\\odot}$，四舍五入到6位小数。\n- **测试案例**：\n    1. $M_{\\mathrm{tot}} = 40.0\\,M_{\\odot}$，$q = 1.0$，$N_{\\mathrm{trials}} = 128$，种子 $= 7$。\n    2. $M_{\\mathrm{tot}} = 20.0\\,M_{\\odot}$，$q = 3.0$，$N_{\\mathrm{trials}} = 128$，种子 $= 11$。\n    3. $M_{\\mathrm{tot}} = 80.0\\,M_{\\odot}$，$q = 1.2$，$N_{\\mathrm{trials}} = 64$，种子 $= 13$。\n    4. $M_{\\mathrm{tot}} = 60.0\\,M_{\\odot}$，$q = 1.0$，$N_{\\mathrm{trials}} = 16$，种子 $= 17$。\n\n### 第二步：使用提取的已知条件进行验证\n该问题经过了严格验证，被判定为有效。\n- **科学基础扎实**：该问题从根本上基于广义相对论的既定原理，特别是致密双星旋进的后牛顿（PN）近似及其与数值相对论（NR）的接口。TaylorF2 相位展开、混合技术以及从低频相位中提取啁啾质量的方法都是引力波天文学领域中标准且有据可查的程序。NR 代理模型虽然经过简化，但它是一个物理上合理的玩具模型，适用于此类系统性研究。\n- **问题适定**：该问题指定了一个完整且确定性的计算过程。所有必需的常数、方程、参数范围和随机变量分布都已明确定义。使用固定的随机种子确保了蒙特卡洛模拟是完全可复现的。目标和最终输出格式都是明确的。\n- **客观性**：该问题以精确、定量和无偏见的科学语言陈述，不含任何主观或推测性内容。\n\n该问题不具备任何无效标准。它是一个自洽、一致且具有科学意义的任务，模拟了引力波源建模中的一个现实分析场景。\n\n### 第三步：结论与行动\n此问题是**有效的**。将提供完整的解决方案。\n\n### 基于原理的设计\n此问题的核心是实现一个数值实验，以评估构建混合引力波形时的系统不确定性。这些混合波形对于创建用于引力波探测和参数估计的完整旋进-并合-铃振波形模型至关重要。系统不确定性源于建模选择，例如使用哪种 PN 近似式以及使用哪个频率区间将其与数值相对论波形进行匹配。\n\n**1. 物理和数学框架**\n模型的基础是频域引力波相位 $\\psi(f)$，它源于稳相近似。所有计算都在几何单位制（$G=c=1$）中执行，其中质量、时间和长度具有相同的量纲。转换因子 $t_{\\odot} = G M_{\\odot}/c^3$ 用于将几何质量单位与太阳质量相关联。\n\n旋进相位由后牛顿（PN）TaylorF2 模型描述，这是一个关于特征轨道速度 $v = (\\pi M f)^{1/3}$ 的幂级数展开。问题指定了这个级数的三个截断版本，表示为 $0$PN、$1.5$PN 和 $2$PN，它们代表了不同层次的物理精度。\n\n“真实”波形由一个简化的数值相对论（NR）代理模型表示。这是通过采用最精确的 PN 模型（$2$PN）并添加一个唯象的高频修正项 $\\delta\\psi_{\\mathrm{high}}(f)$ 来构建的。该项模拟了晚期旋进和并合的复杂物理过程，而这些过程是 PN 展开无法捕捉的。\n\n**2. 混合波形构建**\n混合波形是通过将一个（在低频有效的）PN 模型平滑地连接到一个（在高频有效的）NR 代理模型来构建的。这个过程涉及两个主要步骤：\n\n- **对齐**：PN 相位有两个非物理的自由度：任意的时间平移（$t_0$）和相位平移（$\\phi_0$）。在融合之前，所选的 PN 近似式 $\\psi_{\\mathrm{PN}}$ 必须与 NR 代理模型 $\\psi_{\\mathrm{NR}}$ 对齐。这是通过在选定的频率区间 $[f_1, f_2]$ 上最小化两个相位之间的最小二乘差来实现的。目标函数是 $\\int_{f_1}^{f_2} (\\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0 - \\psi_{\\mathrm{NR}}(f))^2\\,\\mathrm{d}f$。对于参数 $\\phi_0$ 和 $(2\\pi t_0)$ 来说，这是一个线性最小二乘问题，可以使用标准数值线性代数技术（如多项式拟合）高效求解。\n\n- **融合**：一旦找到最优的平移量 $(t_0, \\phi_0)$，对齐后的 PN 相位为 $\\psi_{\\mathrm{PN,\\,aligned}}(f) = \\psi_{\\mathrm{PN}}(f) + 2\\pi f t_0 + \\phi_0$。使用一个锥削函数 $w(f)$ 来创建从 PN 模型到 NR 模型的平滑过渡。指定的半余弦锥削函数在对齐窗口 $[f_1, f_2]$ 上从 $0$ 平滑过渡到 $1$。最终的混合相位是一个加权平均：$\\psi_{\\mathrm{hyb}}(f) = [1-w(f)]\\psi_{\\mathrm{PN,\\,aligned}}(f) + w(f)\\psi_{\\mathrm{NR}}(f)$。\n\n**3. 啁啾质量估计**\n啁啾质量 $\\mathcal{M}$ 是一个关键的物理参数，主要决定了旋进的速率。其效应在波形相位的低频部分表现得最为清晰。在最低阶（牛顿阶），相位为 $\\psi_{\\mathrm{LO}}(f) \\approx \\frac{3}{128}(\\pi \\mathcal{M} f)^{-5/3}$。包括表现为频率线性项和常数偏移的外在参数（并合时间和相位）后，低频相位的模型变为 $\\psi(f) \\approx \\beta_0 + \\beta_1 f + \\alpha f^{-5/3}$。我们感兴趣的系数是 $\\alpha = \\frac{3}{128}(\\pi\\mathcal{M})^{-5/3}$。\n\n为了从给定的混合波形 $\\psi_{\\mathrm{hyb}}(f)$ 中估计 $\\mathcal{M}$，我们对预定义的低频段上的混合相位进行该模型的线性最小二乘拟合。通过提取最佳拟合系数 $\\alpha$，我们可以通过代数方法解出啁啾质量：\n$$\n\\mathcal{M} = \\frac{1}{\\pi} \\left( \\frac{3}{128\\alpha} \\right)^{3/5}.\n$$\n最初以几何单位制得到的结果，随后被转换为太阳质量。\n\n**4. 蒙特卡洛模拟与统计分析**\n该研究的目标是量化混合过程中所做的任意选择如何影响最终估计的啁啾质量。蒙特卡洛模拟是实现这一目标的理想工具。对于具有固定物理属性（$M_{\\mathrm{tot}}, q$）的双星系统，我们进行多次试验。在每次试验中：\n1. 我们随机选择一个 PN 近似式（模拟模型不确定性）。\n2. 我们随机选择一个对齐窗口 $[f_1, f_2]$（模拟过程不确定性）。\n3. 我们遵循上述混合和估计过程，得到一个 $\\mathcal{M}$ 的单次估计值。\n\n通过多次重复这个过程（$N_{\\mathrm{trials}}$ 次），我们生成一个估计的 $\\mathcal{M}$ 值的分布。这个分布的展宽直接衡量了由混合过程引入的系统不确定性。问题要求报告此分布的等尾 $90\\%$ 置信区间，这是通过找到收集样本的第 $5$ 和第 $95$ 百分位数获得的。使用固定的随机种子确保了整个随机过程是确定性的，其结果是可复现的。\n\n该实现将依赖 `numpy` 库来进行高效的数组计算、随机数生成以及求解相位对齐和啁啾质量估计所需的线性最小二乘系统。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo study for all specified test cases\n    and print the results in the required format.\n    \"\"\"\n    # Solar mass time in seconds (G*M_sun/c^3)\n    T_SOLAR = 4.92549095e-6\n\n    test_cases = [\n        # (M_tot_sun, q, N_trials, seed)\n        (40.0, 1.0, 128, 7),\n        (20.0, 3.0, 128, 11),\n        (80.0, 1.2, 64, 13),\n        (60.0, 1.0, 16, 17),\n    ]\n\n    all_results = []\n    for m_tot_sun, q, n_trials, seed in test_cases:\n        result = run_single_case(m_tot_sun, q, n_trials, seed, T_SOLAR)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef calculate_pn_phase(f_hz, M_sec, eta, approximant):\n    \"\"\"\n    Calculates the TaylorF2 PN phase for a given approximant.\n    \"\"\"\n    # Avoid division by zero or log of zero if f starts at 0\n    f_hz = np.maximum(f_hz, 1e-9)\n\n    v = (np.pi * M_sec * f_hz)**(1/3)\n    \n    alpha2 = 3715.0/756.0 + 55.0/9.0 * eta\n    alpha3 = -16.0 * np.pi\n    alpha4 = 15293365.0/508032.0 + 27145.0/504.0 * eta + 3085.0/72.0 * eta**2\n\n    pn_poly = 1.0\n    if approximant in ['1.5PN', '2PN']:\n        pn_poly += alpha2 * v**2 + alpha3 * v**3\n    if approximant == '2PN':\n        pn_poly += alpha4 * v**4\n\n    psi = (3.0 / (128.0 * eta)) * v**(-5) * pn_poly\n    return psi\n\ndef calculate_nr_surrogate_phase(f_hz, M_sec, eta):\n    \"\"\"\n    Calculates the NR-like surrogate phase.\n    \"\"\"\n    psi_2pn = calculate_pn_phase(f_hz, M_sec, eta, '2PN')\n    \n    kappa = 2.0\n    f0 = 150.0\n    fd = 200.0\n    \n    delta_psi_high = kappa * (f_hz/f0)**2 * np.exp(-f_hz/fd)\n    \n    return psi_2pn + delta_psi_high\n\ndef taper_window(f_hz, f1, f2):\n    \"\"\"\n    Generates a half-cosine tapering window function.\n    \"\"\"\n    w = np.zeros_like(f_hz)\n    \n    # Region f1  f  f2\n    mask = (f_hz > f1)  (f_hz  f2)\n    f_masked = f_hz[mask]\n    w[mask] = 0.5 * (1 - np.cos(np.pi * (f_masked - f1) / (f2 - f1)))\n    \n    # Region f >= f2\n    w[f_hz >= f2] = 1.0\n    \n    return w\n\ndef estimate_chirp_mass(f_fit, psi_hyb_fit, T_SOLAR):\n    \"\"\"\n    Estimates chirp mass by fitting the hybrid phase at low frequencies.\n    \"\"\"\n    # Model: psi = beta0 + beta1*f + alpha*f**(-5/3)\n    # Design matrix columns: 1, f, f**(-5/3)\n    f_fit_col = f_fit.reshape(-1, 1)\n    A = np.hstack([np.ones_like(f_fit_col), f_fit_col, f_fit_col**(-5.0/3.0)])\n    \n    # Solve the least squares problem y = A*x for x = [beta0, beta1, alpha]\n    coeffs, _, _, _ = np.linalg.lstsq(A, psi_hyb_fit, rcond=None)\n    alpha = coeffs[2]\n\n    # Infer chirp mass from alpha\n    # alpha = (3/128) * (pi*M_chirp_sec)**(-5/3)\n    # M_chirp_sec = (1/pi) * ( (3)/(128*alpha) )**(3/5)\n    m_chirp_sec = (1.0 / np.pi) * ( (3.0)/(128.0 * alpha) )**(3.0/5.0)\n    \n    # Convert from seconds to solar masses\n    m_chirp_solar = m_chirp_sec / T_SOLAR\n    return m_chirp_solar\n    \ndef run_single_case(M_tot_sun, q, N_trials, seed, T_SOLAR):\n    \"\"\"\n    Runs the full Monte Carlo simulation for a single test case.\n    \"\"\"\n    np.random.seed(seed)\n    \n    # --- Setup constants for the case ---\n    M_sec = M_tot_sun * T_SOLAR\n    eta = q / (1.0 + q)**2\n    \n    f_low = 20.0\n    f_max_unclamped = 0.2 / M_sec\n    f_max = min(1024.0, f_max_unclamped)\n    df = 1.0\n    \n    f_grid = np.arange(f_low, f_max + df, df)\n    \n    # NR surrogate phase is constant for a given case\n    psi_nr = calculate_nr_surrogate_phase(f_grid, M_sec, eta)\n    \n    m_chirp_samples = []\n    \n    # --- Monte Carlo Loop ---\n    for _ in range(N_trials):\n        # 1. Randomly select PN approximant\n        approximant = np.random.choice(['0PN', '1.5PN', '2PN'])\n        \n        # 2. Randomly choose alignment window\n        w_hz = np.random.uniform(30.0, 80.0)\n        f1_upper_bound = min(f_max - w_hz - 30.0, f_low + 220.0)\n        f1 = np.random.uniform(f_low + 60.0, f1_upper_bound)\n        f2 = f1 + w_hz\n        \n        # 3. Calculate PN phase for this trial\n        psi_pn = calculate_pn_phase(f_grid, M_sec, eta, approximant)\n        \n        # 4. Align PN to NR in the alignment window\n        align_mask = (f_grid >= f1)  (f_grid = f2)\n        f_align = f_grid[align_mask]\n        \n        # The equation to fit is: psi_nr - psi_pn = phi0 + (2*pi*t0)*f\n        # This is a 1st degree polynomial fit.\n        phase_diff_to_fit = psi_nr[align_mask] - psi_pn[align_mask]\n        poly_coeffs = np.polyfit(f_align, phase_diff_to_fit, 1)\n        two_pi_t0, phi0 = poly_coeffs\n        t0 = two_pi_t0 / (2 * np.pi)\n        \n        psi_pn_aligned = psi_pn + 2 * np.pi * f_grid * t0 + phi0\n        \n        # 5. Create hybrid waveform\n        w = taper_window(f_grid, f1, f2)\n        psi_hyb = (1 - w) * psi_pn_aligned + w * psi_nr\n        \n        # 6. Estimate chirp mass from the hybrid\n        # Define fitting band for this trial\n        fit_band_upper_trial = min(f1 - 2.0, f_low + 40.0, f_max - 5.0)\n        fit_mask = (f_grid >= f_low + 2.0)  (f_grid = fit_band_upper_trial)\n        f_for_fit = f_grid[fit_mask]\n        psi_hyb_for_fit = psi_hyb[fit_mask]\n        \n        m_chirp_est = estimate_chirp_mass(f_for_fit, psi_hyb_for_fit, T_SOLAR)\n        m_chirp_samples.append(m_chirp_est)\n        \n    # --- Statistical Analysis ---\n    m_chirp_samples = np.array(m_chirp_samples)\n    m_low = np.quantile(m_chirp_samples, 0.05)\n    m_high = np.quantile(m_chirp_samples, 0.95)\n    \n    # Return formatted results as a list of two floats\n    return [round(m_low, 6), round(m_high, 6)]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}