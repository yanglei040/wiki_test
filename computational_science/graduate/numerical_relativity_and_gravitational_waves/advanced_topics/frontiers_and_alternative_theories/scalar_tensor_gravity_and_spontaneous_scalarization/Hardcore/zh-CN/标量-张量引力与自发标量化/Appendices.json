{
    "hands_on_practices": [
        {
            "introduction": "标量-张量引力理论的一个关键特征是致密天体（如中子星）可以获得“标量荷”。本练习将指导你完成一个在数值相对论中至关重要的任务：从模拟产生的外部时空标量场数据中，通过拟合其渐近行为来精确地提取天体的标量荷及其不确定度。这个过程让你能够亲手将理论预测与具体的数值模拟输出联系起来。",
            "id": "3485574",
            "problem": "给定一个致密天体外部、标量-张量引力中的无质量标量场的离散样本，这些样本是通过对真空方程进行数值积分得到的。在远场中，该标量场表现为一个球状向外传播解，其主导多极矩为单极矩，因此源外半径 $r$ 处的渐近场形式为 $\\varphi(r) = \\varphi_{\\infty} + Q/r + \\mathcal{O}(1/r^2)$，其中 $\\varphi_{\\infty}$ 是宇宙学渐近值，$Q$ 是有效标量单极矩。在 $G=c=1$ 的几何化单位中，该天体的无量纲标量荷为 $\\alpha_A = Q/m_A$，其中 $m_A$ 是该天体的引力质量。您会收到一组有限样本 $\\{(r_i, \\varphi_i, \\sigma_i)\\}_{i=1}^N$，其中每个 $r_i$ 是一个半径，每个 $\\varphi_i$ 是在 $r_i$ 处通过数值计算得到的标量场值，每个 $\\sigma_i$ 是 $\\varphi_i$ 在该 $r_i$ 处因数值截断误差产生的一倍标准差估计不确定度。此外，您还被给予 $m_A$ 及其一倍标准差不确定度 $\\delta m_A$。假设 $\\varphi_i$ 值的误差是独立的高斯分布，并且推断出的 $Q$ 与质量不确定度之间相互独立。\n\n您的任务是实现一个基于第一性原理的数值程序，通过使用关于 $x_i = 1/r_i$ 的线性模型（即 $\\varphi_i \\approx \\varphi_{\\infty} + Q x_i$）拟合 $\\varphi(r)$ 的 $1/r$ 尾部，来估计 $\\alpha_A$ 及其一倍标准差不确定度。拟合必须在已知标准差 $\\sigma_i$ 的独立高斯误差的假设下进行，并且 $\\alpha_A$ 的不確定度必须通过传播拟合得到的参数不确定度和 $m_A$ 的不确定度来获得。请严格在 $G=c=1$ 的几何化单位下工作，因此 $r_i$ 和 $m_A$ 以相同的长度单位度量，而 $\\varphi$ 是无量纲的。所有最终数值答案都表示为无量纲的小数。\n\n在您的程序中实现以下步骤：\n\n- 建立线性模型，其设计矩阵对应于参数 $(\\varphi_{\\infty}, Q)$ 和数据 $(x_i, \\varphi_i)$，权重为 $w_i = 1/\\sigma_i^2$。\n- 在独立高斯误差的假设下，计算 $(\\varphi_{\\infty}, Q)$ 的最大似然估计及其相关的参数协方差矩阵。\n- 假设拟合出的 $Q$ 和质量 $m_A$ 的不确定度相互独立，通过标准的线性误差传播推断 $\\alpha_A = Q/m_A$ 及其一倍标准差不确定度。\n\n您的程序必须评估以下测试套件并产生所要求的输出。每个测试用例提供 $(r_i, \\varphi_i, \\sigma_i)$ 数组、$m_A$ 和 $\\delta m_A$：\n\n- 测试用例 1（理想路径，中等噪声尾部）：\n  - $r = [20.0, 30.0, 40.0, 50.0, 60.0, 80.0, 100.0]$\n  - $\\varphi = [0.01505, 0.01034, 0.00801, 0.00658, 0.00568, 0.004485, 0.00382]$\n  - $\\sigma = [1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}]$\n  - $m_A = 1.4$, $\\delta m_A = 0.02$\n- 测试用例 2（数据点最少且荷近乎为零的边界条件）：\n  - $r = [100.0, 200.0]$\n  - $\\varphi = [0.00201, 0.00199]$\n  - $\\sigma = [5.0\\times 10^{-5}, 5.0\\times 10^{-5}]$\n  - $m_A = 2.0$, $\\delta m_A = 0.1$\n- 测试用例 3（异方差不确定度和中等耦合）：\n  - $r = [25.0, 35.0, 55.0, 75.0, 95.0, 120.0]$\n  - $\\varphi = [0.0041, 0.0030357, 0.0024545, 0.0017867, 0.0017921, 0.0014667]$\n  - $\\sigma = [2.0\\times 10^{-4}, 2.0\\times 10^{-4}, 5.0\\times 10^{-4}, 3.0\\times 10^{-4}, 8.0\\times 10^{-4}, 2.0\\times 10^{-4}]$\n  - $m_A = 1.6$, $\\delta m_A = 0.03$\n- 测试用例 4（数据中存在 $1/r^2$ 污染项的有限半径系统误差；拟合仍使用 $1/r$ 模型）：\n  - $r = [15.0, 20.0, 25.0, 35.0, 50.0, 70.0, 90.0]$\n  - $\\varphi = [0.0107056, 0.00823, 0.00671, 0.0050776, 0.0039, 0.00308, 0.0026841]$\n  - $\\sigma = [1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}, 1.0\\times 10^{-4}]$\n  - $m_A = 1.3$, $\\delta m_A = 0.02$\n\n对于每个测试用例，计算估计的 $\\alpha_A$ 及其一倍标准差不确定度 $\\delta \\alpha_A$，结果为浮点数。您的程序应生成单行输出，包含一个由列表组成的逗号分隔列表，其中每个内部列表的形式为 $[\\alpha_A, \\delta \\alpha_A]$，并用方括号括起来。例如，需要形如 $[[a_1, d_1],[a_2, d_2],[a_3, d_3],[a_4, d_4]]$ 的输出，其中每个 $a_i$ 和 $d_i$ 是浮点数，分别代表第 $i$ 个测试用例的估计值 $\\alpha_A$ 及其一倍标准差不确定度。所有答案均为几何化单位下的无量纲小数。",
            "solution": "提出的问题是，如何根据一组离散的数值数据，确定一个致密天体的无量纲标量荷 $\\alpha_A$ 及其相关的一倍标准差不确定度 $\\delta \\alpha_A$。这些数据代表了外部时空中不同半径 $r$ 处的无质量标量场 $\\varphi$ 的样本。该问题具有科学依据，提法明確，并为基于统计数据分析和物理学的既定原则得出一个唯一、稳定的解提供了所有必要信息。\n\n基本物理模型是远场中标量场 $\\varphi(r)$ 的渐近行为，由下式给出：\n$$\n\\varphi(r) = \\varphi_{\\infty} + \\frac{Q}{r} + \\mathcal{O}\\left(\\frac{1}{r^2}\\right)\n$$\n在此，$\\varphi_{\\infty}$ 是标量场的宇宙学值，$Q$ 是致密天体的有效标量单极矩，或称标量荷。无量纲标量荷定义为 $\\alpha_A = Q/m_A$，其中 $m_A$ 是天体的引力质量。我们有 $N$ 个数据点 $\\{(r_i, \\varphi_i, \\sigma_i)\\}_{i=1}^N$，其中 $\\varphi_i$ 是在半径 $r_i$ 处测量的场值，其不确定度是独立的、标准差为 $\\sigma_i$ 的高斯分布。\n\n为了估计参数 $\\varphi_{\\infty}$ 和 $Q$，我们通过定义自变量 $x_i = 1/r_i$ 来线性化模型。该模型随后呈现为线性方程的形式：\n$$\n\\varphi_i = \\varphi_{\\infty} + Q x_i\n$$\n这是一个线性回归问题。鉴于测量值 $\\varphi_i$ 的不确定度 $\\sigma_i$ 已知且代表独立的的高斯误差，参数估计的适当方法是加权最小二乘法（WLS），这对应于最大似然估计。目标是找到参数矢量 $\\hat{\\beta} = [\\hat{\\varphi}_{\\infty}, \\hat{Q}]^T$，使卡方统计量最小化：\n$$\n\\chi^2(\\beta) = \\sum_{i=1}^N w_i (\\varphi_i - (\\varphi_{\\infty} + Q x_i))^2\n$$\n其中权重定义为 $w_i = 1/\\sigma_i^2$。\n\n在矩阵表示法中，问题被表述为 $y \\approx X\\beta$，其中：\n- $y = [\\varphi_1, \\varphi_2, \\dots, \\varphi_N]^T$ 是因变量测量值的向量。\n- $X$ 是 $N \\times 2$ 的设计矩阵，其第 $i$ 行为 $[1, x_i] = [1, 1/r_i]$。\n$$\nX = \\begin{pmatrix} 1  1/r_1 \\\\ 1  1/r_2 \\\\ \\vdots  \\vdots \\\\ 1  1/r_N \\end{pmatrix}\n$$\n- $\\beta = [\\varphi_{\\infty}, Q]^T$ 是待估计参数的向量。\n\nWLS解 $\\hat{\\beta}$ 通过求解正规方程组得到：\n$$\n(X^T W X) \\hat{\\beta} = X^T W y\n$$\n其中 $W$ 是对角权重矩阵，其元素为 $W_{ii} = w_i = 1/\\sigma_i^2$。估计参数的解为：\n$$\n\\hat{\\beta} = (X^T W X)^{-1} X^T W y\n$$\n估计参数 $\\hat{\\beta}$ 的协方差矩阵由 $\\chi^2$ 函数的海森矩阵（Hessian matrix）的逆给出，即：\n$$\n\\text{Cov}(\\hat{\\beta}) = (X^T W X)^{-1}\n$$\n这是一个 $2 \\times 2$ 矩阵：\n$$\n\\text{Cov}(\\hat{\\beta}) = \\begin{pmatrix} \\sigma_{\\varphi_{\\infty}}^2  \\text{Cov}(\\varphi_{\\infty}, Q) \\\\ \\text{Cov}(\\varphi_{\\infty}, Q)  \\sigma_Q^2 \\end{pmatrix}\n$$\n标量荷 $Q$ 的估计方差是第二个对角元素 $\\sigma_Q^2$。因此，其一倍标准差不确定度为 $\\delta Q = \\sqrt{\\sigma_Q^2}$。\n\n最后，我们计算所需量 $\\alpha_A = Q/m_A$ 及其不确定度。估计值即为 $\\hat{\\alpha}_A = \\hat{Q}/m_A$。为了找到不确定度 $\\delta \\alpha_A$，我们使用标准独立误差传播公式。鉴于 $\\alpha_A$ 是两个独立测量量 $Q$ 和 $m_A$ 的函数，它们的不确定度分别为 $\\delta Q$ 和 $\\delta m_A$，其方差 $\\sigma_{\\alpha_A}^2 = (\\delta \\alpha_A)^2$ 为：\n$$\n(\\delta \\alpha_A)^2 = \\left( \\frac{\\partial \\alpha_A}{\\partial Q} \\right)^2 (\\delta Q)^2 + \\left( \\frac{\\partial \\alpha_A}{\\partial m_A} \\right)^2 (\\delta m_A)^2\n$$\n偏导数分别为 $\\partial\\alpha_A/\\partial Q = 1/m_A$ 和 $\\partial\\alpha_A/\\partial m_A = -Q/m_A^2$。将它们代入公式可得：\n$$\n(\\delta \\alpha_A)^2 = \\left( \\frac{1}{m_A} \\right)^2 (\\delta Q)^2 + \\left( -\\frac{\\hat{Q}}{m_A^2} \\right)^2 (\\delta m_A)^2 = \\frac{(\\delta Q)^2}{m_A^2} + \\frac{\\hat{Q}^2 (\\delta m_A)^2}{m_A^4}\n$$\n$\\alpha_A$ 的一倍标准差不确定度是该表达式的平方根。\n\n对于提供的每个测试用例，数值实现将精确遵循这些步骤。我们使用 `numpy` 进行高效而准确的线性代数运算，以构建矩阵、求解正规方程组并计算最终的不确定度。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_alpha_A(r, phi, sigma_phi, m_A, delta_m_A):\n    \"\"\"\n    Estimates the dimensionless scalar charge alpha_A and its uncertainty.\n\n    The function performs a weighted linear least squares fit to the model\n    phi = phi_inf + Q * (1/r) to find the scalar charge Q and its\n    uncertainty delta_Q. It then propagates errors to find alpha_A = Q/m_A\n    and its uncertainty.\n\n    Args:\n        r (np.ndarray): Radii of scalar field samples.\n        phi (np.ndarray): Scalar field values at corresponding radii.\n        sigma_phi (np.ndarray): One-sigma uncertainties for phi values.\n        m_A (float): Gravitational mass of the compact object.\n        delta_m_A (float): One-sigma uncertainty of the mass.\n\n    Returns:\n        list: A list containing the estimated alpha_A and its uncertainty [alpha_A, delta_alpha_A].\n    \"\"\"\n    # Ensure inputs are numpy arrays for vector operations\n    r = np.asarray(r, dtype=float)\n    phi = np.asarray(phi, dtype=float)\n    sigma_phi = np.asarray(sigma_phi, dtype=float)\n\n    # 1. Build the linear model components\n    # Independent variable x = 1/r\n    x = 1.0 / r\n\n    # Design matrix X for model phi = beta_0 * 1 + beta_1 * x\n    # where beta_0 is phi_inf and beta_1 is Q\n    X = np.vstack((np.ones_like(x), x)).T\n\n    # Weights w_i = 1/sigma_i^2\n    weights = 1.0 / (sigma_phi**2)\n\n    # 2. Compute the maximum likelihood estimates for parameters (phi_inf, Q)\n    # The normal equations are (X.T W X) beta = X.T W y\n    # Let A = X.T W X\n    # Let b = X.T W y\n    # Here, W is a diagonal matrix, so (X.T W X) is sum(w_i * x_i_vec * x_i_vec.T)\n    # and (X.T W y) is sum(w_i * x_i_vec * y_i).\n    # A more direct computation using broadcasting:\n    A = X.T @ (X * weights[:, np.newaxis])\n    b = X.T @ (phi * weights)\n    \n    # Solve A * beta = b for beta\n    # beta_hat[0] is phi_inf, beta_hat[1] is Q\n    try:\n        beta_hat = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # This case is unlikely with the given problem constraints but is good practice.\n        return [np.nan, np.nan]\n    \n    Q_hat = beta_hat[1]\n\n    # 3. Compute the associated parameter covariance matrix\n    # Cov(beta) = (X.T W X)^-1 = A^-1\n    try:\n        cov_beta = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        return [np.nan, np.nan]\n        \n    # Variance of Q is the [1,1] element of the covariance matrix\n    var_Q = cov_beta[1, 1]\n    # One-sigma uncertainty is the square root of the variance\n    delta_Q = np.sqrt(var_Q)\n\n    # 4. Infer alpha_A and its one-sigma uncertainty\n    alpha_A_hat = Q_hat / m_A\n    \n    # Propagate uncertainties assuming independence between Q and m_A\n    # (delta_alpha_A)^2 = (delta_Q/m_A)^2 + (Q*delta_m_A / m_A^2)^2\n    var_alpha_A = (delta_Q**2 / m_A**2) + (Q_hat**2 * delta_m_A**2 / m_A**4)\n    delta_alpha_A = np.sqrt(var_alpha_A)\n    \n    return [alpha_A_hat, delta_alpha_A]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"r\": [20.0, 30.0, 40.0, 50.0, 60.0, 80.0, 100.0],\n            \"phi\": [0.01505, 0.01034, 0.00801, 0.00658, 0.00568, 0.004485, 0.00382],\n            \"sigma\": [1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4],\n            \"m_A\": 1.4,\n            \"delta_m_A\": 0.02\n        },\n        # Test case 2\n        {\n            \"r\": [100.0, 200.0],\n            \"phi\": [0.00201, 0.00199],\n            \"sigma\": [5.0e-5, 5.0e-5],\n            \"m_A\": 2.0,\n            \"delta_m_A\": 0.1\n        },\n        # Test case 3\n        {\n            \"r\": [25.0, 35.0, 55.0, 75.0, 95.0, 120.0],\n            \"phi\": [0.0041, 0.0030357, 0.0024545, 0.0017867, 0.0017921, 0.0014667],\n            \"sigma\": [2.0e-4, 2.0e-4, 5.0e-4, 3.0e-4, 8.0e-4, 2.0e-4],\n            \"m_A\": 1.6,\n            \"delta_m_A\": 0.03\n        },\n        # Test case 4\n        {\n            \"r\": [15.0, 20.0, 25.0, 35.0, 50.0, 70.0, 90.0],\n            \"phi\": [0.0107056, 0.00823, 0.00671, 0.0050776, 0.0039, 0.00308, 0.0026841],\n            \"sigma\": [1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4, 1.0e-4],\n            \"m_A\": 1.3,\n            \"delta_m_A\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_alpha_A(case[\"r\"], case[\"phi\"], case[\"sigma\"], case[\"m_A\"], case[\"delta_m_A\"])\n        results.append(result)\n\n    # Format the output as a string representation of a list of lists.\n    # str([1.2, 3.4]) -> '[1.2, 3.4]'\n    # ','.join(['[1.2, 3.4]', '[5.6, 7.8]']) -> '[1.2, 3.4],[5.6, 7.8]'\n    # Then enclose in outer brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在标量-张量引力中，双星系统等动态过程不仅会辐射引力波（张量模式），还会辐射标量波（标量模式）。本练习旨在通过处理给定的辐射模式时间序列，计算并区分这两个通道辐射的总能量，并验证全局能量守恒。这对于理解自发标量化的可观测特征和能量在不同渠道的分配至关重要。",
            "id": "3485596",
            "problem": "您必须编写一个完整、可运行的程序，该程序使用有效应力-能量张量，在标量-张量引力理论中计算张量和标量通道之间的辐射能量分配，并在指定的容差范围内验证全局能量守恒。背景是具有弱引力辐射和规范无质量标量自由度的渐近平坦时空。在几何化单位制中工作，其中 $G=c=1$，因此所有能量都是无量纲的，并以初始质量为单位进行测量。\n\n要使用的基本和建模假设：\n- 对于近乎平坦背景上的引力波，使用高频有效应力-能量张量（Isaacson 张量），其中度规被分解为一个背景加上一个小的横向无迹微扰。物理辐射内容由张量波的两种极化编码。\n- 将标量场视为一个规范的、最小耦合的、无质量的标量，因此其应力-能量是在辐射区平坦空间中自由标量的应力-能量。\n- 使用未来零无穷远处的渐近行为，其中辐射张量和标量自由度允许在球面上进行模式分解。模式函数作为辐射的随时间变化的振幅。必须使用相关球谐函数的正交归一性将球面上的积分简化为对模式指数的求和。\n- 总辐射能量是光度的时间积分，而光度是从相应有效应力-能量张量导出的径向能流通量分量的球面积分。最终的数值算法必须符合用于求导的时间上的二阶精度有限差分，以及用于时间积分的标准复合数值求积。\n\n程序任务：\n1) 对于每个测试用例，为张量和标量通道在区间 $t \\in [0,T]$ 上构造合成的、平滑的、具有紧致时间支撑的辐射模式时间序列，该序列在 $N$ 个点上均匀采样。对于每个模式，给定一个整数周期数 $n$ 和一个振幅 $A$。模式时间序列为\n$\nU_{\\ell m}(t) = A \\sin\\!\\big(2\\pi n\\, t/T\\big)\n$\n对于张量模式，以及\n$\nW_{\\ell m}(t) = A \\sin\\!\\big(2\\pi n\\, t/T\\big)\n$\n对于标量模式。测试用例中存在的多个张量或标量模式对通量有加性贡献。\n2) 在均匀网格上使用二阶精度有限差分公式计算时间导数（在端点使用单侧二阶公式，在内部点使用中心二阶公式）。\n3) 使用有效应力-能量定义和球谐函数的正交归一性，将球面积分简化为模式求和，并在时间上进行数值积分，以获得张量通道 $E_{\\mathrm{T}}$ 和标量通道 $E_{\\mathrm{S}}$ 中的总辐射能量。然后计算标量分数\n$\nf_{\\mathrm{S}} = \\frac{E_{\\mathrm{S}}}{E_{\\mathrm{T}} + E_{\\mathrm{S}}},\n$\n约定如果 $E_{\\mathrm{T}}+E_{\\mathrm{S}}=0$，则 $f_{\\mathrm{S}}=0$。\n4) 通过检查以下不等式是否成立，在相对容差 $\\tau$ 内验证全局能量守恒\n$\n\\frac{\\big|\\,M_{0} - M_{f} - (E_{\\mathrm{T}}+E_{\\mathrm{S}})\\,\\big|}{M_{0}} \\le \\tau,\n$\n并报告一个布尔值，指示该不等式是否成立。\n\n实现约束：\n- 使用 $G=c=1$。所有能量都是无量纲的，必须如此处理。\n- 在 $[0,T]$ 上使用 $N$ 个均匀间隔的样本。\n- 对时间导数使用上述二阶精度有限差分格式。\n- 使用标准复合梯形法则对 $t$ 进行时间积分。\n- 对所有情况使用下面指定的单个全局容差 $\\tau$。\n\n测试套件和参数：\n使用以下四个测试用例。在每个用例中，张量模式和标量模式的集合以 $(\\ell,m,n,A)$ 形式的元组列表给出；球面指数 $(\\ell,m)$ 标记模式，但除了枚举之外不影响算法，而 $n$ 和 $A$ 如上定义时间序列。初始质量为 $M_{0}$，提供的最终质量为 $M_{f}$。对所有用例使用相同的样本数 $N$ 和持续时间 $T$。所有数字都是无量纲的。\n\n- 所有用例的全局设置：$T=1.0$，$N=20001$，相对容差 $\\tau = 10^{-5}$。\n\n- 用例 1（正常路径，两个通道均激活）：\n  - 张量模式：$\\{(2,2,3,10^{-3}),\\ (2,-2,3,10^{-3})\\}$。\n  - 标量模式：$\\{(1,0,1,2\\times 10^{-3})\\}$。\n  - $M_{0}=1.0$。\n  - $M_{f}=0.9999866482312222$。\n\n- 用例 2（边界情况，无标量辐射）：\n  - 张量模式：$\\{(2,2,2,5\\times 10^{-4}),\\ (2,-2,2,5\\times 10^{-4})\\}$。\n  - 标量模式：$\\{\\}$。\n  - $M_{0}=1.0$。\n  - $M_{f}=0.9999992146018366$。\n\n- 用例 3（边缘情况，仅标量辐射）：\n  - 张量模式：$\\{\\}$。\n  - 标量模式：$\\{(1,0,2,1.5\\times 10^{-3})\\}$。\n  - $M_{0}=1.0$。\n  - $M_{f}=0.9999858628330589$。\n\n- 用例 4（边缘情况，能量守恒违背超出容差）：\n  - 张量模式：$\\{(2,2,3,10^{-3}),\\ (2,-2,3,10^{-3})\\}$。\n  - 标量模式：$\\{(1,0,1,2\\times 10^{-3})\\}$。\n  - $M_{0}=1.0$。\n  - $M_{f}=0.9999366482312222$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个，按顺序排列。每个结果必须是一个双元素列表 $[f_{\\mathrm{S}},\\ \\mathrm{ok}]$，其中 $f_{\\mathrm{S}}$ 是作为浮点数的标量分数，$\\mathrm{ok}$ 是来自守恒检查的布尔值。该行中任何地方都不要包含空格。例如，一个包含两个用例的输出可能看起来像 $[[0.12345,True],[0.0,False]]$。您的程序必须精确打印这样的一行。",
            "solution": "用户提供的问题已经过验证，并被认为是**有效的**。它具有科学依据、适定且客观。问题陈述包含了进行求解所需的所有必要信息，这取决于引力波物理学领域的标准物理公式的应用，这些公式已由提供的测试用例证实。\n\n### 1. 理论框架\n\n该问题要求计算一个在渐近平坦时空中同时发射张量（引力）波和标量波的系统所辐射的能量。总辐射能量 $E_{\\mathrm{rad}}$ 是通过张量通道辐射的能量 $E_{\\mathrm{T}}$ 和通过标量通道辐射的能量 $E_{\\mathrm{S}}$ 的总和。\n$$\nE_{\\mathrm{rad}} = E_{\\mathrm{T}} + E_{\\mathrm{S}}\n$$\n\n能量是通过对光度（功率）进行时间积分来计算的，而光度是通过在未来零无穷远处对径向能流在一个球面上进行积分得到的。\n\n**1.1. 张量通道能量 ($E_{\\mathrm{T}}$)**\n\n引力波的能量由 Isaacson 有效应力-能量张量描述。在几何化单位制（$G=c=1$）中，光度 $L_{\\mathrm{T}}$（单位时间的能量）由天球上的积分给出：\n$$\nL_{\\mathrm{T}}(t) = \\frac{dE_{\\mathrm{T}}}{dt} = \\frac{1}{32\\pi} \\int_{S^2} \\left[ (\\dot{h}_+)^2 + (\\dot{h}_\\times)^2 \\right] d\\Omega\n$$\n其中 $h_+$ 和 $h_\\times$ 是两种张量极化，点号表示对时间 $t$ 的导数。度规微扰可以分解为自旋为 $s=-2$ 的自旋加权球谐函数 ${}_{-2}Y_{\\ell m}$：\n$$\nh_+ - i h_\\times = \\sum_{\\ell=2}^{\\infty} \\sum_{m=-\\ell}^{\\ell} h_{\\ell m}(t) {}_{-2}Y_{\\ell m}(\\theta, \\phi)\n$$\n利用这些谐函数的正交归一性，$\\int_{S^2} {}_{-2}Y_{\\ell m} \\overline{{}_{-2}Y_{\\ell' m'}} d\\Omega = \\delta_{\\ell \\ell'} \\delta_{m m'}$，光度简化为对模式的求和。对于标准定义，光度为：\n$$\nL_{\\mathrm{T}}(t) = \\frac{1}{16\\pi} \\sum_{\\ell, m} |\\dot{h}_{\\ell m}(t)|^2\n$$\n问题为一组离散模式提供了实值时间序列振幅 $U_{\\ell m}(t)$。我们直接对它们的贡献求和：\n$$\nL_{\\mathrm{T}}(t) = \\frac{1}{16\\pi} \\sum_{\\text{modes}} \\left( \\frac{d U_{\\ell m}(t)}{dt} \\right)^2\n$$\n张量通道中的总能量是该光度的时间积分：\n$$\nE_{\\mathrm{T}} = \\int_{0}^{T} L_{\\mathrm{T}}(t) dt = \\frac{1}{16\\pi} \\int_{0}^{T} \\sum_{\\text{modes}} \\left( \\dot{U}_{\\ell m}(t) \\right)^2 dt\n$$\n\n**1.2. 标量通道能量 ($E_{\\mathrm{S}}$)**\n\n对于一个规范的、最小耦合的、无质量的标量场 $\\phi$，在平坦空间中的应力-能量张量为 $T_{\\mu\\nu}^{\\mathrm{S}} = \\partial_\\mu \\phi \\partial_\\nu \\phi - \\frac{1}{2}\\eta_{\\mu\\nu}(\\partial_\\alpha \\phi \\partial^\\alpha \\phi)$。对于以光速传播的出射辐射场，这导致径向能流为 $(\\partial_t \\phi)^2$。标量光度 $L_{\\mathrm{S}}$ 为：\n$$\nL_{\\mathrm{S}}(t) = \\frac{dE_{\\mathrm{S}}}{dt} = \\int_{S^2} (\\dot{\\phi})^2 d\\Omega\n$$\n标量场根据标准（标量）球谐函数 $Y_{\\ell m}$ 进行分解：\n$$\n\\phi(t, \\mathbf{x}) = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} \\frac{\\phi_{\\ell m}(t-r)}{r} Y_{\\ell m}(\\theta, \\phi)\n$$\n使用标量球谐函数的正交归一性，$\\int_{S^2} Y_{\\ell m} \\overline{Y_{\\ell' m'}} d\\Omega = \\delta_{\\ell \\ell'} \\delta_{m m'}$，光度变成对模式的求和。在此背景下，通常使用 $1/(4\\pi)$ 的归一化因子以确保单位一致（能量以质量为单位）。\n$$\nL_{\\mathrm{S}}(t) = \\frac{1}{4\\pi} \\sum_{\\ell, m} |\\dot{\\phi}_{\\ell m}(t)|^2\n$$\n给定实值模式振幅 $W_{\\ell m}(t)$，光度为：\n$$\nL_{\\mathrm{S}}(t) = \\frac{1}{4\\pi} \\sum_{\\text{modes}} \\left( \\frac{d W_{\\ell m}(t)}{dt} \\right)^2\n$$\n标量通道中的总能量则为：\n$$\nE_{\\mathrm{S}} = \\int_{0}^{T} L_{\\mathrm{S}}(t) dt = \\frac{1}{4\\pi} \\int_{0}^{T} \\sum_{\\text{modes}} \\left( \\dot{W}_{\\ell m}(t) \\right)^2 dt\n$$\n张量辐射的 $1/(16\\pi)$ 和标量辐射的 $1/(4\\pi)$ 的特定前置因子在文献中是标准的，并且通过分析所提供测试用例中的能量平衡被证实是正确的。\n\n### 2. 数值算法\n\n连续时间问题通过在离散网格上使用数值方法来求解。\n\n**2.1. 离散化与波形生成**\n时域 $t \\in [0, T]$ 被离散化为 $N$ 个均匀间隔的点 $t_i = i \\cdot \\Delta t$，其中 $i=0, 1, \\dots, N-1$，时间步长为 $\\Delta t = T/(N-1)$。对于每个张量模式 $(\\ell, m, n, A)_{\\mathrm{T}}$ 和标量模式 $(\\ell, m, n, A)_{\\mathrm{S}}$，在每个点 $t_i$ 生成相应的时间序列：\n$$\nU_{\\ell m}(t_i) = A_{\\mathrm{T}} \\sin\\!\\big(2\\pi n_{\\mathrm{T}}\\, t_i/T\\big)\n$$\n$$\nW_{\\ell m}(t_i) = A_{\\mathrm{S}} \\sin\\!\\big(2\\pi n_{\\mathrm{S}}\\, t_i/T\\big)\n$$\n\n**2.2. 数值微分**\n时间导数 $\\dot{U}_{\\ell m}(t_i)$ 和 $\\dot{W}_{\\ell m}(t_i)$ 使用二阶精度有限差分格式进行近似。对于采样为 $f_i = f(t_i)$ 的通用函数 $f(t)$：\n- **内部点 ($1 \\le i \\le N-2$):** 中心差分公式。\n$$\n\\dot{f}_i = \\frac{f_{i+1} - f_{i-1}}{2 \\Delta t}\n$$\n- **第一个点 ($i=0$):** 前向差分公式。\n$$\n\\dot{f}_0 = \\frac{-3f_0 + 4f_1 - f_2}{2 \\Delta t}\n$$\n- **最后一个点 ($i=N-1$):** 后向差分公式。\n$$\n\\dot{f}_{N-1} = \\frac{3f_{N-1} - 4f_{N-2} + f_{N-3}}{2 \\Delta t}\n$$\n\n**2.3. 数值积分**\n$E_{\\mathrm{T}}$ 和 $E_{\\mathrm{S}}$ 的时间积分使用复合梯形法则计算。对于采样为 $g_i = g(t_i)$ 的函数 $g(t)$，积分近似为：\n$$\n\\int_0^T g(t) dt \\approx \\Delta t \\left( \\frac{g_0 + g_{N-1}}{2} + \\sum_{i=1}^{N-2} g_i \\right)\n$$\n这被应用于离散化的光度函数 $L_{\\mathrm{T}}(t_i)$ 和 $L_{\\mathrm{S}}(t_i)$。\n\n### 3. 最终计算与验证\n\n计算出总辐射能量 $E_{\\mathrm{T}}$ 和 $E_{\\mathrm{S}}$ 后，为每个测试用例确定以下量：\n\n**3.1. 标量分数 ($f_{\\mathrm{S}}$)**\n由标量场携带的总辐射能量的分数为：\n$$\nf_{\\mathrm{S}} = \\frac{E_{\\mathrm{S}}}{E_{\\mathrm{T}} + E_{\\mathrm{S}}}\n$$\n如果总能量 $E_{\\mathrm{T}} + E_{\\mathrm{S}} = 0$，则 $f_{\\mathrm{S}}$ 定义为 $0$。\n\n**3.2. 能量守恒验证**\n全局能量守恒意味着最终质量 $M_f$ 应为初始质量 $M_0$ 减去总辐射能量。数值解在此原则下进行检查，要求其在给定的相对容差 $\\tau$ 之内。该检查通过评估布尔值 `ok` 来执行：\n$$\n\\mathrm{ok} = \\left( \\frac{\\big|\\,M_{0} - M_{f} - (E_{\\mathrm{T}}+E_{\\mathrm{S}})\\,\\big|}{M_{0}} \\le \\tau \\right)\n$$\n如果 $M_0$ 为零，则此检查无意义，但问题提供了 $M_0=1.0$。\n\n每个用例的最终输出是一个有序对 $[f_{\\mathrm{S}}, \\mathrm{ok}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef second_order_derivative(y, dt):\n    \"\"\"\n    Computes the second-order accurate derivative of a time series.\n\n    Args:\n        y (np.ndarray): The time series data.\n        dt (float): The time step.\n\n    Returns:\n        np.ndarray: The derivative of the time series.\n    \"\"\"\n    n_points = len(y)\n    dydt = np.zeros(n_points)\n\n    if n_points  3:\n        # Not enough points for a 2nd order formula; return zeros as a fallback\n        return dydt\n\n    # Central difference for interior points\n    dydt[1:-1] = (y[2:] - y[:-2]) / (2 * dt)\n\n    # One-sided (forward) difference for the first point\n    dydt[0] = (-3 * y[0] + 4 * y[1] - y[2]) / (2 * dt)\n\n    # One-sided (backward) difference for the last point\n    dydt[-1] = (3 * y[-1] - 4 * y[-2] + y[-3]) / (2 * dt)\n\n    return dydt\n\ndef compute_radiation(tensor_modes, scalar_modes, M0, Mf, T, N, tau):\n    \"\"\"\n    Computes scalar energy fraction and verifies energy conservation for one case.\n\n    Args:\n        tensor_modes (list): List of tuples (l, m, n, A) for tensor modes.\n        scalar_modes (list): List of tuples (l, m, n, A) for scalar modes.\n        M0 (float): Initial mass.\n        Mf (float): Final mass.\n        T (float): Duration.\n        N (int): Number of sample points.\n        tau (float): Relative tolerance for conservation check.\n\n    Returns:\n        list: A two-element list [f_scalar, ok].\n    \"\"\"\n    t = np.linspace(0.0, T, N)\n    dt = T / (N - 1)\n\n    # --- Tensor Channel ---\n    dudt_sq_sum = np.zeros(N)\n    for _, _, n, A in tensor_modes:\n        # Generate mode time series U(t)\n        omega = 2.0 * np.pi * n / T\n        U_lm = A * np.sin(omega * t)\n        \n        # Compute derivative and add its square to the sum\n        dU_lm_dt = second_order_derivative(U_lm, dt)\n        dudt_sq_sum += dU_lm_dt**2\n\n    # Compute tensor luminosity and total radiated tensor energy\n    # L_T = (1 / (16*pi)) * sum(dU_lm/dt)^2\n    luminosity_tensor = (1.0 / (16.0 * np.pi)) * dudt_sq_sum\n    E_tensor = np.trapz(luminosity_tensor, dx=dt)\n\n    # --- Scalar Channel ---\n    dwdt_sq_sum = np.zeros(N)\n    for _, _, n, A in scalar_modes:\n        # Generate mode time series W(t)\n        omega = 2.0 * np.pi * n / T\n        W_lm = A * np.sin(omega * t)\n        \n        # Compute derivative and add its square to the sum\n        dW_lm_dt = second_order_derivative(W_lm, dt)\n        dwdt_sq_sum += dW_lm_dt**2\n\n    # Compute scalar luminosity and total radiated scalar energy\n    # L_S = (1 / (4*pi)) * sum(dW_lm/dt)^2\n    luminosity_scalar = (1.0 / (4.0 * np.pi)) * dwdt_sq_sum\n    E_scalar = np.trapz(luminosity_scalar, dx=dt)\n\n    # --- Final Calculations ---\n    \n    # 3) Scalar Fraction\n    E_total = E_tensor + E_scalar\n    if E_total == 0.0:\n        f_scalar = 0.0\n    else:\n        f_scalar = E_scalar / E_total\n        \n    # 4) Energy Conservation Check\n    ok = False\n    if M0 != 0.0:\n        rel_error = abs(M0 - Mf - E_total) / M0\n        if rel_error = tau:\n            ok = True\n\n    return [f_scalar, ok]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Global settings from problem statement\n    T = 1.0\n    N = 20001\n    tau = 1e-5\n\n    # Test suite from problem statement\n    test_cases = [\n        {\n            \"tensor_modes\": [(2, 2, 3, 1e-3), (2, -2, 3, 1e-3)],\n            \"scalar_modes\": [(1, 0, 1, 2e-3)],\n            \"M0\": 1.0,\n            \"Mf\": 0.9999866482312222,\n        },\n        {\n            \"tensor_modes\": [(2, 2, 2, 5e-4), (2, -2, 2, 5e-4)],\n            \"scalar_modes\": [],\n            \"M0\": 1.0,\n            \"Mf\": 0.9999992146018366,\n        },\n        {\n            \"tensor_modes\": [],\n            \"scalar_modes\": [(1, 0, 2, 1.5e-3)],\n            \"M0\": 1.0,\n            \"Mf\": 0.9999858628330589,\n        },\n        {\n            \"tensor_modes\": [(2, 2, 3, 1e-3), (2, -2, 3, 1e-3)],\n            \"scalar_modes\": [(1, 0, 1, 2e-3)],\n            \"M0\": 1.0,\n            \"Mf\": 0.9999366482312222,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_radiation(\n            case[\"tensor_modes\"], case[\"scalar_modes\"], case[\"M0\"], case[\"Mf\"], T, N, tau\n        )\n        results.append(result)\n\n    # Format the final output string exactly as specified, with no spaces.\n    # e.g., [[0.123,True],[0.0,False]]\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "精确的数值模拟是研究标量-张量引力的基石，而模拟的成败取决于演化方程的稳定性和对约束违背的控制。本练习将带你深入数值相对论的核心，首先推导包含标量场的爱因斯坦场方程的约束部分，然后分析现代CCZ4方法中用于抑制约束增长的阻尼项的稳定性。通过这个练习，你将理解维持数值模拟长期稳定性的理论基础和技术细节。",
            "id": "3485631",
            "problem": "您需要将广义相对论的$3+1$分解中与最小耦合标量场相关的基本定义，与Z4系统的共形协变形式（CCZ4）中约束阻尼的数值行为联系起来。您的任务分为两部分：推导包含标量场的约束表达式，以及对简化的CCZ4模型中的约束传播进行线性稳定性分析。然后，您必须实现一个程序，对一小组测试套件评估约束残差并预测约束阻尼（或增长）。\n\nA部分（推导与离散评估）：\n- 从$3+1$分解中的爱因斯坦场方程和爱因斯坦参考系中最小耦合标量场的应力-能量张量出发。使用$G=c=1$的几何单位制。设时空度规通过lapse函数$\\alpha$、shift矢量$\\beta^{i}$和空间度规$\\gamma_{ij}$进行分解。外曲率为$K_{ij}$，其迹为$K \\equiv \\gamma^{ij} K_{ij}$。\n- 标量场为$\\phi$，其正则共轭动量为$\\Pi \\equiv - n^{\\mu} \\nabla_{\\mu} \\phi$，其中$n^{\\mu}$是空间切片的单位法向量，$D_{i}$表示与$\\gamma_{ij}$相容的空间协变导数。假设存在一个势$V(\\phi)$。\n- 仅使用$3+1$分解的定义和标量场的应力-能量张量$T_{\\mu \\nu}$，推导包含标量场贡献的哈密顿约束残差$H$和动量约束残差$M_{i}$，并用$\\gamma_{ij}$、$K_{ij}$、$\\phi$、$\\Pi$和$V(\\phi)$表示。在推导过程中不要假设任何特殊对称性。您的推导应确定标量场的能量密度$\\rho \\equiv n_{\\mu} n_{\\nu} T^{\\mu \\nu}$和动量密度$j_{i} \\equiv - \\gamma_{i \\mu} n_{\\nu} T^{\\mu \\nu}$，并说明它们如何进入约束方程。\n- 对于数值评估，请特化到平直空间度规$\\gamma_{ij}=\\delta_{ij}$、为零的shift矢量$\\beta^{i}=0$、单位lapse函数$\\alpha=1$以及为零的外曲率$K_{ij}=0$的情况。在这种特化情况下，约束完全由标量场产生。在一个各方向边长为$L = 2\\pi$的周期性立方体区域上使用均匀笛卡尔网格。根据需要，使用带周期性边界条件的中心有限差分来近似$D_{i} \\phi$。设势为$V(\\phi)=\\tfrac{1}{2} m^{2}\\phi^{2}$，并在测试套件中使用$m=0$。\n\nB部分（线性化CCZ4约束传播模型与稳定性测试）：\n- 考虑围绕闵可夫斯基时空的Z4变量$(\\Theta, Z_{i})$的线性化主部约束传播子系统，并加入CCZ4阻尼参数$\\kappa_{1}$、$\\kappa_{2}$、$\\kappa_{3}$。\n- 在傅里葉空间中，对于空间波数矢量$k_{i}$和大小$|k|$，限制在由$(\\Theta, Z_{\\parallel})$张成的耦合纵向部分，其中$Z_{\\parallel} \\equiv \\hat{k}^{i} Z_{i}$且$\\hat{k}^{i} \\equiv k^{i}/|k|$。\n- 利用Z4约束子系统的定义结构和CCZ4阻尼项，为$(\\Theta, Z_{\\parallel})$构建一个齐次线性常微分方程组，该方程组与一个阻尼波主部相一致：$\\Theta$的时间导数包含$Z_{i}$的散度和一个与$\\kappa_{1}(2+\\kappa_{2})$成正比的阻尼项，而$Z_{i}$的时间导数包含$\\Theta$的梯度和一个与$\\kappa_{1}$成正比的阻尼项；允许$\\Theta$方程中乘以散度的系数为$\\kappa_{3}$。\n- 证明对于大小为$|k|$的齐次傅里葉模，得到的$2\\times 2$线性算子具有常系数矩阵的形式，其特征值可以明确地用$\\kappa_{1}$、$\\kappa_{2}$、$\\kappa_{3}$和$|k|$表示。将谱横坐标定义为这些特征值中的最大实部。当且仅当谱横坐标严格为负时，稳定性测试应宣布该情况为阻尼的。\n\n数值设计要求：\n- 实现一个程序，该程序：\n  1. 在$[0,2\\pi]^3$上构建指定的周期性网格，每个维度有$N=32$个点。\n  2. 对于下面的每个测试用例，使用指定的振幅和波数的三角函数在网格上构建$\\phi$和$\\Pi$场，按指示计算特化后的$H$和$M_{i}$残差，并报告均方根（离散$L^{2}$）范数：$||H||_{2} \\equiv \\sqrt{\\langle H^{2} \\rangle}$和$||M||_{2} \\equiv \\sqrt{\\langle M_{i} M^{i} \\rangle}$，其中$\\langle \\cdot \\rangle$表示网格上的平均值，$M_{i}$的指标用$\\delta^{ij}$升阶。\n  3. 对于每个测试用例，使用给定的$\\kappa_{1}$、$\\kappa_{2}$、$\\kappa_{3}$和$|k|$（用于构建场的波数矢量的大小），构建B部分中的齐次纵向$(\\Theta, Z_{\\parallel})$线性算子，计算其特征值，并评估谱横坐标以判断稳定性。\n- 所有报告的量在$G=c=1$的几何单位制中都是无量纲的。\n\n测试套件：\n- 使用$N=32$, $L=2\\pi$, $m=0$。标量场和动量定义如下\n  - $\\phi(\\mathbf{x}) = A \\sin(k_{x} x + k_{y} y + k_{z} z)$,\n  - $\\Pi(\\mathbf{x}) = B \\sin(k_{x} x + k_{y} y + k_{z} z)$,\n  其中振幅$A$和$B$以及整数波数$(k_{x}, k_{y}, k_{z})$按每个用例给出。\n- 提供三个用例，涵盖一个典型的良好阻尼构型、一个无阻尼的边界构型，以及一个选择了去稳定化$\\kappa_{3}$值的高波数构型：\n  1. 用例1：$A=10^{-3}$, $B=0$, $(k_{x},k_{y},k_{z})=(1,0,0)$, $\\kappa_{1}=0.1$, $\\kappa_{2}=0$, $\\kappa_{3}=1$。\n  2. 用例2：$A=0$, $B=10^{-3}$, $(k_{x},k_{y},k_{z})=(1,0,0)$, $\\kappa_{1}=0$, $\\kappa_{2}=0$, $\\kappa_{3}=1$。\n  3. 用例3：$A=10^{-3}$, $B=10^{-3}$, $(k_{x},k_{y},k_{z})=(10,0,0)$, $\\kappa_{1}=0.02$, $\\kappa_{2}=0$, $\\kappa_{3}=-1$。\n- 三角函数的角度参数以弧度为单位。波数大小为$|k| = \\sqrt{k_{x}^{2} + k_{y}^{2} + k_{z}^{2}}$。\n\n最终输出规范：\n- 对于每个测试用例，您的程序必须生成一个包含四个条目的列表：\n  - 一个布尔值，指示谱横坐标是否严格为负（阻尼），\n  - 谱横坐标（浮点数），\n  - $H$的$L^{2}$范数（浮点数），\n  - $M$的$L^{2}$范数（浮点数）。\n- 您的程序应生成单行输出，其中包含这些按用例排列的列表，以逗号分隔，并用方括号括起来。例如，一个有效的输出形状是\n  - `[[boolean, float, float, float], [...], [...]]`,\n  并且所有浮点数在打印输出时必须精确到$6$位小数。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于广义相对论和数值分析的原理，问题阐述清晰，目标明确，并包含足够的信息以获得唯一解。\n\n### A部分：约束残差的推导与评估\n\n爱因斯坦场方程$G_{\\mu\\nu} = 8\\pi T_{\\mu\\nu}$（在$G=c=1$的几何单位制中）的$3+1$分解，在每个空间切片上产生了哈密顿约束方程和动量约束方程。这些方程关联了切片的内禀几何（3-度规$\\gamma_{ij}$及其里奇标量$R$）、其外曲率（$K_{ij}$）以及投影到该切片上的物质含量。对于一个精确解，约束残差必须为零，其形式如下：\n$$\nH \\equiv R + K^2 - K_{ij}K^{ij} - 16\\pi \\rho = 0\n$$\n$$\nM_i \\equiv D_j(K^j_i - \\delta^j_i K) - 8\\pi j_i = 0\n$$\n此处，$K \\equiv \\gamma^{ij}K_{ij}$是外曲率的迹，$D_i$是与$\\gamma_{ij}$相容的协变导数。物质项$\\rho$和$j_i$是由与空间切片正交运动的观测者测量的能量密度和动量密度。它们是通过使用未来指向的单位法向量$n^{\\mu}$投影应力-能量张量$T^{\\mu\\nu}$来定义的：\n$$\n\\rho \\equiv n_{\\mu} n_{\\nu} T^{\\mu \\nu}\n$$\n$$\nj_{i} \\equiv - \\gamma_{i \\mu} n_{\\nu} T^{\\mu \\nu}\n$$\n其中$\\gamma_{i\\mu}$是带有一个空间指标的投影张量$\\gamma_{\\mu\\nu}$。\n\n对于具有势$V(\\phi)$的最小耦合标量场$\\phi$，其应力-能量张量由下式给出：\n$$\nT_{\\mu \\nu} = \\nabla_{\\mu}\\phi \\nabla_{\\nu}\\phi - \\frac{1}{2} g_{\\mu \\nu} (\\nabla^{\\alpha}\\phi \\nabla_{\\alpha}\\phi + 2 V(\\phi))\n$$\n在$3+1$形式中，标量场的梯度被分解为其法向和空间部分。场的正则动量是$\\Pi \\equiv -n^{\\mu}\\nabla_{\\mu}\\phi$。梯度的空间投影是$D_i \\phi$。梯度的完整时空收缩变为$\\nabla^{\\alpha}\\phi \\nabla_{\\alpha}\\phi = -\\Pi^2 + D_i\\phi D^i\\phi$。\n\n我们现在可以计算$\\rho$和$j_i$：\n$$\n\\rho = n_{\\mu}n_{\\nu}T^{\\mu\\nu} = n_{\\mu}n_{\\nu} \\left( \\nabla^{\\mu}\\phi \\nabla^{\\nu}\\phi - \\frac{1}{2} g^{\\mu\\nu} (\\dots) \\right) = (n_{\\mu}\\nabla^{\\mu}\\phi)^2 - \\frac{1}{2}(n_{\\mu}n_{\\nu}g^{\\mu\\nu})(-\\Pi^2 + D_k\\phi D^k\\phi + 2V)\n$$\n使用$n_{\\mu}n^{\\mu} = -1$以及$n_{\\mu}n_{\\nu}g^{\\mu\\nu} = -1$，上式简化为：\n$$\n\\rho = (-\\Pi)^2 - \\frac{1}{2}(-1)(-\\Pi^2 + D_k\\phi D^k\\phi + 2V(\\phi)) = \\frac{1}{2}\\Pi^2 + \\frac{1}{2}D_k\\phi D^k\\phi + V(\\phi)\n$$\n对于动量密度：\n$$\nj_i = -\\gamma_{i\\mu}n_{\\nu}T^{\\mu\\nu} = -\\gamma_{i\\mu}n_{\\nu} \\left( \\nabla^{\\mu}\\phi \\nabla^{\\nu}\\phi - \\frac{1}{2}g^{\\mu\\nu}(\\dots) \\right) = -( \\gamma_{i\\mu}\\nabla^{\\mu}\\phi ) ( n_{\\nu}\\nabla^{\\nu}\\phi ) = -(D_i\\phi)(-\\Pi)\n$$\n因此，动量密度为：\n$$\nj_i = \\Pi D_i\\phi\n$$\n将$\\rho$和$j_i$的这些表达式代入约束残差，得到：\n$$\nH = R + K^2 - K_{ij}K^{ij} - 16\\pi \\left( \\frac{1}{2}\\Pi^2 + \\frac{1}{2}D_k\\phi D^k\\phi + V(\\phi) \\right) = R + K^2 - K_{ij}K^{ij} - 8\\pi (\\Pi^2 + D_k\\phi D^k\\phi + 2V(\\phi))\n$$\n$$\nM_i = D_j(K^j_i - \\delta^j_i K) - 8\\pi \\Pi D_i\\phi\n$$\n对于数值评估，我们特化到一个平直背景，其中$\\gamma_{ij}=\\delta_{ij}$，$K_{ij}=0$，且势为$V(\\phi)=\\frac{1}{2}m^2\\phi^2$并取$m=0$。在这种情况下，$R=0$，$K=0$，$V(\\phi)=0$。协变导数$D_i$变为偏导数$\\partial_i$。约束残差简化为：\n$$\nH = -8\\pi (\\Pi^2 + \\partial_k\\phi \\partial^k\\phi)\n$$\n$$\nM_i = -8\\pi \\Pi \\partial_i\\phi\n$$\n这些表达式在一个均匀笛卡尔网格上进行评估，其中偏导数使用带周期性边界条件的二阶中心有限差分计算。\n\n### B部分：线性化CCZ4约束传播分析\n\n共形协变Z4（CCZ4）形式引入了变量$\\Theta$和$Z_i$，它们分别与哈密顿约束和动量约束的违背量成正比。它们的演化方程包含由参数$\\kappa_1$和$\\kappa_2$控制的阻尼项，旨在将约束驱动至零。参数$\\kappa_3$影响约束违背量的传播速度。\n\n我们分析围绕闵可夫斯基时空的线性化约束子系统。在傅里葉空间中，具有波矢$k_i$的模式根据一个常微分方程组演化。问题指定了傅里葉振幅$(\\hat{\\Theta}, \\hat{Z}_i)$的方程结构：\n$$\n\\partial_t \\hat{\\Theta} = \\kappa_3 (i k_j \\hat{Z}^j) - \\kappa_1(2+\\kappa_2) \\hat{\\Theta}\n$$\n$$\n\\partial_t \\hat{Z}_i = i k_i \\hat{\\Theta} - \\kappa_1 \\hat{Z}_i\n$$\n我们投影到由波矢方向$\\hat{k}^i = k^i/|k|$定义的纵向部分。令$\\hat{Z}_{\\parallel} \\equiv \\hat{k}^j \\hat{Z}_j$。注意到$k_j\\hat{Z}^j = |k|\\hat{Z}_\\parallel$和$\\hat{k}^i(i k_i \\hat{\\Theta}) = i|k|\\hat{\\Theta}$，该系统仅耦合了$\\hat{\\Theta}$和$\\hat{Z}_\\parallel$：\n$$\n\\partial_t \\hat{\\Theta} = i \\kappa_3 |k| \\hat{Z}_{\\parallel} - \\kappa_1(2+\\kappa_2) \\hat{\\Theta}\n$$\n$$\n\\partial_t \\hat{Z}_\\parallel = i |k| \\hat{\\Theta} - \\kappa_1 \\hat{Z}_\\parallel\n$$\n这是一个对于向量$\\mathbf{v} = (\\hat{\\Theta}, \\hat{Z}_\\parallel)^T$的齐次线性系统$\\frac{d\\mathbf{v}}{dt} = \\mathbf{M}\\mathbf{v}$，其中矩阵$\\mathbf{M}$为：\n$$\n\\mathbf{M} = \\begin{pmatrix} -\\kappa_1(2+\\kappa_2)  i \\kappa_3 |k| \\\\ i |k|  -\\kappa_1 \\end{pmatrix}\n$$\n系统的稳定性由$\\mathbf{M}$的特征值$\\lambda$决定，可通过求解特征方程$\\det(\\mathbf{M}-\\lambda\\mathbf{I})=0$得到：\n$$\n(-\\kappa_1(2+\\kappa_2) - \\lambda)(-\\kappa_1 - \\lambda) - (i \\kappa_3 |k|)(i |k|) = 0\n$$\n$$\n\\lambda^2 + \\kappa_1(3+\\kappa_2)\\lambda + (\\kappa_1^2(2+\\kappa_2) + \\kappa_3 |k|^2) = 0\n$$\n这是一个二次方程，其解为：\n$$\n\\lambda = \\frac{-\\kappa_1(3+\\kappa_2) \\pm \\sqrt{(\\kappa_1(3+\\kappa_2))^2 - 4(\\kappa_1^2(2+\\kappa_2) + \\kappa_3 |k|^2)}}{2}\n$$\n判别式简化为$\\Delta = \\kappa_1^2(1+\\kappa_2)^2 - 4\\kappa_3 |k|^2$。谱横坐标$\\sigma \\equiv \\max(\\Re(\\lambda))$决定了稳定性。严格为负的谱横坐标（$\\sigma  0$）表明所有约束模式都是阻尼的。\n如果$\\Delta \\ge 0$，特征值为实数，谱横坐标为$\\sigma = \\frac{1}{2} \\left( -\\kappa_1(3+\\kappa_2) + \\sqrt{\\Delta} \\right)$。\n如果$\\Delta  0$，特征值为一对共轭复数，谱横坐标为$\\sigma = \\frac{1}{2} \\left( -\\kappa_1(3+\\kappa_2) \\right)$。\n\n### 数值设计\n\n该实现为每个测试用例计算所需的量。\n1. 在域$[0, 2\\pi]^3$上定义一个大小为$N \\times N \\times N$（其中$N=32$）的三维笛卡尔网格。\n2. 根据指定的三角函数，在该网格上构建标量场$\\phi$及其动量$\\Pi$。\n3. 使用二阶周期性中心有限差分格式计算空间导数$\\partial_i\\phi$，并利用`numpy.roll`高效实现。\n4. 使用A部分中的特化公式，在每个网格点上计算哈密顿残差$H$和动量残差矢量分量$M_i$。\n5. 通过对所有网格点求平均值，计算离散$L^2$范数$||H||_{2} = \\sqrt{\\langle H^{2} \\rangle}$和$||M||_{2} = \\sqrt{\\langle M_{i} M^{i} \\rangle}$。\n6. 对于B部分，根据给定的参数$\\kappa_1, \\kappa_2, \\kappa_3$和每个用例的波数大小$|k|$，使用推导出的公式计算谱横坐标。通过测试谱横坐标是否严格为负来确定稳定性。\n收集每个用例的结果，并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating constraint residuals for a scalar field\n    and analyzing the stability of a simplified CCZ4 constraint damping system.\n    \"\"\"\n    \n    # Test cases from the problem statement\n    test_cases = [\n        {'A': 1e-3, 'B': 0, 'k_vec': (1,0,0), 'kappa1': 0.1, 'kappa2': 0, 'kappa3': 1},\n        {'A': 0, 'B': 1e-3, 'k_vec': (1,0,0), 'kappa1': 0, 'kappa2': 0, 'kappa3': 1},\n        {'A': 1e-3, 'B': 1e-3, 'k_vec': (10,0,0), 'kappa1': 0.02, 'kappa2': 0, 'kappa3': -1},\n    ]\n\n    # Grid parameters\n    N = 32\n    L = 2.0 * np.pi\n    h = L / N\n\n    # Grid coordinates\n    x_1d = np.linspace(0, L, N, endpoint=False)\n    y_1d = np.linspace(0, L, N, endpoint=False)\n    z_1d = np.linspace(0, L, N, endpoint=False)\n    xx, yy, zz = np.meshgrid(x_1d, y_1d, z_1d, indexing='ij')\n\n    all_results = []\n\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        kx, ky, kz = case['k_vec']\n        kappa1 = case['kappa1']\n        kappa2 = case['kappa2']\n        kappa3 = case['kappa3']\n        k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n\n        # Part A: Constraint Residual Calculation\n        \n        # Define scalar field and its momentum on the grid\n        theta = kx * xx + ky * yy + kz * zz\n        phi = A * np.sin(theta)\n        Pi = B * np.sin(theta)\n\n        # Compute spatial derivatives using 2nd-order central finite differences\n        # with periodic boundary conditions (using np.roll).\n        dphi_dx = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * h)\n        dphi_dy = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * h)\n        dphi_dz = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * h)\n        \n        # Calculate constraint residuals H and M_i\n        H = -8.0 * np.pi * (Pi**2 + dphi_dx**2 + dphi_dy**2 + dphi_dz**2)\n        Mx = -8.0 * np.pi * Pi * dphi_dx\n        My = -8.0 * np.pi * Pi * dphi_dy\n        Mz = -8.0 * np.pi * Pi * dphi_dz\n\n        # Calculate L2 norms of the residuals\n        H_norm = np.sqrt(np.mean(H**2))\n        M_norm = np.sqrt(np.mean(Mx**2 + My**2 + Mz**2))\n\n        # Part B: Stability Analysis\n\n        # Calculate the discriminant of the characteristic equation\n        Delta = (kappa1 * (1.0 + kappa2))**2 - 4.0 * kappa3 * k_mag**2\n\n        if Delta >= 0:\n            spec_abs = (-kappa1 * (3.0 + kappa2) + np.sqrt(Delta)) / 2.0\n        else:\n            spec_abs = -kappa1 * (3.0 + kappa2) / 2.0\n        \n        is_damped = spec_abs  0.0\n\n        all_results.append([is_damped, spec_abs, H_norm, M_norm])\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        # Format boolean and floats to 6 decimal places\n        bool_str = str(res[0])\n        float_strs = [f\"{x:.6f}\" for x in res[1:]]\n        result_strings.append(f\"[{bool_str},{','.join(float_strs)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}