{
    "hands_on_practices": [
        {
            "introduction": "The fundamental task in extracting physical observables from numerical relativity is translating the raw simulation output into measurable quantities. This practice guides you through the complete computational pipeline, starting from the Newman-Penrose scalar $\\psi_4$, which encodes the gravitational wave curvature. By performing numerical integrations and spherical quadratures, you will compute the anisotropic momentum flux and ultimately determine the recoil velocity imparted to the final black hole, providing a hands-on implementation of the core principles of gravitational wave momentum conservation .",
            "id": "3485260",
            "problem": "You are given a radiative curvature scalar $\\,\\psi_4(t,\\theta,\\phi)\\,$ extracted on large coordinate spheres in a numerical relativity simulation of a compact binary coalescence. Assume that $\\,\\psi_4\\,$ is related to the complex strain $\\,h(t,\\theta,\\phi)=h_+(t,\\theta,\\phi)-i\\,h_\\times(t,\\theta,\\phi)\\,$ by the fundamental relationship $\\,\\psi_4(t,\\theta,\\phi)=\\partial_t^2 h(t,\\theta,\\phi)\\,$, and that $\\,h(t,\\theta,\\phi)\\,$ admits a spin-weighted spherical harmonic decomposition with spin weight $\\,s=-2\\,$,\n$$\nh(t,\\theta,\\phi)=\\sum_{\\ell,m} h_{\\ell m}(t)\\;{}_{-2}Y_{\\ell m}(\\theta,\\phi).\n$$\nDefine the Bondi news as $\\,\\mathcal{N}(t,\\theta,\\phi)=\\partial_t h(t,\\theta,\\phi)\\,$ and assume extraction sufficiently close to null infinity that $\\,\\mathcal{N}(t,\\theta,\\phi)\\,$ can be computed directly from the time derivatives of the modal coefficients. The total linear momentum flux carried by gravitational waves is given at leading order by\n$$\n\\frac{dP^i}{dt}=\\frac{1}{16\\pi}\\int_{S^2} n^i(\\theta,\\phi)\\,|\\mathcal{N}(t,\\theta,\\phi)|^2\\,d\\Omega,\\quad i\\in\\{x,y,z\\},\n$$\nwhere $\\,n^i\\,$ are the components of the unit radial vector $\\,\\vec{n}=(\\sin\\theta\\cos\\phi,\\sin\\theta\\sin\\phi,\\cos\\theta)\\,$ and $\\,d\\Omega=\\sin\\theta\\,d\\theta\\,d\\phi\\,$. The recoil (kick) velocity of the remnant, assuming vanishing initial net linear momentum of the system and neglecting matter outflows, is\n$$\n\\vec{v}_{\\mathrm{kick}}=-\\frac{1}{M_f}\\int_{t_0}^{t_f}\\frac{d\\vec{P}}{dt}\\,dt,\n$$\nwhere $\\,M_f\\,$ is the final mass of the remnant in geometric units with $\\,G=c=1\\,$. After computing the dimensionless $\\,\\vec{v}_{\\mathrm{kick}}\\,$, convert it to physical units by multiplying by the speed of light in $\\mathrm{km/s}$.\n\nYour task is to implement, from first principles, the following computational pipeline with clear numerical choices:\n\n1. Starting point and modal reconstruction:\n   - Work with modes $\\,\\psi_{4,\\ell m}(t)\\,$ such that\n     $$\n     \\psi_4(t,\\theta,\\phi)=\\sum_{\\ell,m}\\psi_{4,\\ell m}(t)\\;{}_{-2}Y_{\\ell m}(\\theta,\\phi).\n     $$\n   - Recover $\\,h_{\\ell m}(t)\\,$ via double time integration with vanishing integration constants at $\\,t=t_0\\,$. For numerical stability, you may compute $\\,\\partial_t h_{\\ell m}(t)\\,$ first by a single integration of $\\,\\psi_{4,\\ell m}(t)\\,$ with the initial condition $\\,\\partial_t h_{\\ell m}(t_0)=0\\,$, and then compute $\\,h_{\\ell m}(t)\\,$ by integrating $\\,\\partial_t h_{\\ell m}(t)\\,$ with $\\,h_{\\ell m}(t_0)=0\\,$. You must then construct the news\n     $$\n     \\mathcal{N}(t,\\theta,\\phi)=\\sum_{\\ell,m}\\partial_t h_{\\ell m}(t)\\;{}_{-2}Y_{\\ell m}(\\theta,\\phi).\n     $$\n2. Momentum flux and total radiated momentum:\n   - Compute $\\,dP^i/dt\\,$ using numerical quadrature on the sphere and the formula above. Use Gaussâ€“Legendre quadrature in $\\,\\cos\\theta\\in[-1,1]\\,$ with $\\,N_\\theta\\,$ nodes and uniform trapezoidal quadrature in $\\,\\phi\\in[0,2\\pi)\\,$ with $\\,N_\\phi\\,$ points. Take $\\,N_\\theta=48\\,$ and $\\,N_\\phi=96\\,$. Angles must be in radians.\n   - Integrate $\\,dP^i/dt\\,$ over the time interval $\\,t\\in[t_0,t_f]\\,$ by the trapezoidal rule to obtain $\\,P^i_{\\mathrm{rad}}\\,$.\n3. Kick velocity:\n   - Compute $\\,\\vec{v}_{\\mathrm{kick}}=-\\vec{P}_{\\mathrm{rad}}/M_f\\,$ in geometric units, and convert to $\\,\\mathrm{km/s}\\,$ by multiplying the dimensionless velocity by $\\,c_{\\mathrm{km/s}}=299\\,792.458\\,$.\n\nSpin-weighted spherical harmonics:\n- Restrict to $\\,\\ell=2\\,$ modes with $\\,m\\in\\{-2,-1,0,1,2\\}\\,$, but only the modes listed in the test suite will be nonzero. Implement explicit formulas for $\\,{}_{-2}Y_{2m}(\\theta,\\phi)\\,$:\n  $$\n  {}_{-2}Y_{2,2}=\\sqrt{\\frac{5}{64\\pi}}(1+\\cos\\theta)^2 e^{2i\\phi},\\quad\n  {}_{-2}Y_{2,1}=\\sqrt{\\frac{5}{16\\pi}}\\sin\\theta(1+\\cos\\theta)e^{i\\phi},\n  $$\n  $$\n  {}_{-2}Y_{2,0}=\\sqrt{\\frac{15}{32\\pi}}\\sin^2\\theta,\\quad\n  {}_{-2}Y_{2,-1}=\\sqrt{\\frac{5}{16\\pi}}\\sin\\theta(1-\\cos\\theta)e^{-i\\phi},\\quad\n  {}_{-2}Y_{2,-2}=\\sqrt{\\frac{5}{64\\pi}}(1-\\cos\\theta)^2 e^{-2i\\phi}.\n  $$\n\nSynthetic test suite:\n- Use a time array $\\,t_k=t_0+k\\,\\Delta t\\,$ for $\\,k=0,1,\\dots,N_t-1\\,$ with $\\,t_0=0\\,$, $\\,t_f=4\\,$, $\\,N_t=2000\\,$, and $\\,\\Delta t=(t_f-t_0)/(N_t-1)\\,$. Define a smooth envelope $\\,w(t)=\\sin^2\\!\\big(\\pi t/t_f\\big)\\,$ for $\\,t\\in[0,t_f]\\,$ and zero otherwise. Let $\\,\\omega=30\\,$.\n- For each test case, construct the nonzero $\\,\\ell=2\\,$ modes as\n  $$\n  \\psi_{4,2m}(t)=A_{2m}\\,w(t)\\,e^{i(\\omega t+\\varphi_{2m})}.\n  $$\n- Test cases (each specifies nonzero modes and final mass $\\,M_f\\,$):\n  1. Case $\\,1\\,$ (symmetry cancellation): $\\,A_{2,2}=2\\times 10^{-3}\\,$, $\\,\\varphi_{2,2}=0\\,$, $\\,A_{2,-2}=2\\times 10^{-3}\\,$, $\\,\\varphi_{2,-2}=0\\,$, $\\,M_f=1.0\\,$. All other modes zero.\n  2. Case $\\,2\\,$ (in-plane asymmetry): $\\,A_{2,2}=2\\times 10^{-3}\\,$, $\\,\\varphi_{2,2}=0\\,$, $\\,A_{2,1}=6\\times 10^{-4}\\,$, $\\,\\varphi_{2,1}=0\\,$, $\\,M_f=1.0\\,$. All other modes zero.\n  3. Case $\\,3\\,$ (phase-flipped asymmetry): same as Case $\\,2\\,$ but $\\,\\varphi_{2,1}=\\pi\\,$, $\\,M_f=1.0\\,$.\n  4. Case $\\,4\\,$ (mass scaling): same modes as Case $\\,2\\,$, but $\\,M_f=2.0\\,$.\n\nNumerical and physical requirements:\n- Angles $\\,\\theta\\,$ and $\\,\\phi\\,$ must be in radians.\n- Express the final recoil velocity components $\\,\\big(v_x,v_y,v_z\\big)\\,$ in $\\,\\mathrm{km/s}\\,$ as a list of three floating-point numbers for each case.\n- Your program must produce a single line of output containing the four case results as a list of lists, e.g., $\\,[[v_{x,1},v_{y,1},v_{z,1}],[v_{x,2},v_{y,2},v_{z,2}],\\dots]\\,$, where all $\\,v_{i,j}\\,$ are floats.\n\nYour deliverable must be a complete, runnable program that constructs the synthetic $\\,\\psi_{4,\\ell m}\\,$ data, performs the required integrations and quadratures, and outputs the recoil velocity vectors for the four test cases in the specified format, with the speed of light conversion as stated.",
            "solution": "The problem is a valid and well-posed computational exercise in gravitational wave physics, specifically concerning the calculation of the recoil velocity imparted to a final remnant object from the anisotropic emission of gravitational waves during a compact binary coalescence. All physical formulas, numerical methods, and parameters are provided, free from contradiction or ambiguity. The problem is grounded in the established principles of general relativity and numerical relativity. We proceed with the solution.\n\nThe computational pipeline is implemented in the following sequence of steps, adhering to the physical principles and numerical methods prescribed.\n\n### 1. Generation of Synthetic Waveform Modes and Integration to News\n\nThe starting point is the modal decomposition of the Newman-Penrose curvature scalar $\\psi_4(t, \\theta, \\phi)$, given by\n$$\n\\psi_4(t,\\theta,\\phi)=\\sum_{\\ell,m}\\psi_{4,\\ell m}(t)\\;{}_{-2}Y_{\\ell m}(\\theta,\\phi).\n$$\nThe problem provides synthetic time-domain modes $\\psi_{4,2m}(t)$ for $\\ell=2$. These are constructed as a complex sinusoidal oscillation with frequency $\\omega=30$, modulated by a smooth envelope function $w(t) = \\sin^2(\\pi t / t_f)$ over the time interval $t \\in [t_0, t_f] = [0, 4]$. The time domain is discretized into $N_t=2000$ points. For each non-zero mode specified in a test case, the complex time series is\n$$\n\\psi_{4,2m}(t_k) = A_{2m} \\, w(t_k) \\, e^{i(\\omega t_k + \\varphi_{2m})},\n$$\nwhere $t_k = t_0 + k \\Delta t$ for $k=0, 1, \\dots, N_t-1$, and $\\Delta t = (t_f - t_0)/(N_t-1)$.\n\nThe radiative part of the gravitational field is described by the Bondi news function, $\\mathcal{N}(t,\\theta,\\phi) = \\partial_t h(t,\\theta,\\phi)$, where $h(t,\\theta,\\phi)$ is the complex gravitational wave strain. The fundamental relation $\\psi_4 = \\partial_t^2 h = \\partial_t \\mathcal{N}$ connects the curvature scalar to the news. This implies that the modal coefficients are related by $\\psi_{4,\\ell m}(t) = \\partial_t \\mathcal{N}_{\\ell m}(t)$, where $\\mathcal{N}_{\\ell m}(t) = \\partial_t h_{\\ell m}(t)$.\n\nTo obtain the news modes $\\mathcal{N}_{\\ell m}(t)$, we must integrate the $\\psi_{4,\\ell m}(t)$ modes with respect to time:\n$$\n\\mathcal{N}_{\\ell m}(t) = \\int_{t_0}^{t} \\psi_{4,\\ell m}(t') dt'.\n$$\nThe initial condition is specified as $\\partial_t h_{\\ell m}(t_0) = \\mathcal{N}_{\\ell m}(t_0) = 0$. This time integration is performed numerically for each complex mode time series using the cumulative trapezoidal rule, as implemented in `scipy.integrate.cumulative_trapezoid`, which naturally incorporates the zero initial condition.\n\n### 2. Numerical Quadrature on the Sphere\n\nTo compute the total linear momentum flux, we must evaluate an integral over the two-sphere $S^2$. The flux in the $i$-th direction is\n$$\n\\frac{dP^i}{dt}=\\frac{1}{16\\pi}\\int_{S^2} n^i(\\theta,\\phi)\\,|\\mathcal{N}(t,\\theta,\\phi)|^2\\,d\\Omega,\n$$\nwhere $d\\Omega = \\sin\\theta d\\theta d\\phi$ and $\\vec{n}=(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)$. The integral is computationally approximated using a product rule of two one-dimensional quadratures.\n\nWith the substitution $u = \\cos\\theta$, the integral becomes\n$$\n\\int_0^{2\\pi} d\\phi \\int_{-1}^{1} du\\; f(u, \\phi).\n$$\nAs specified, we use Gauss-Legendre quadrature for the integral over $u \\in [-1, 1]$ with $N_\\theta=48$ nodes, and the uniform trapezoidal rule for the periodic integral over $\\phi \\in [0, 2\\pi)$ with $N_\\phi=96$ points. The discretized form of the integral of a function $F(\\theta, \\phi)$ is thus:\n$$\n\\int_{S^2} F(\\theta, \\phi) d\\Omega \\approx \\sum_{j=1}^{N_\\theta} w_j \\sum_{k=0}^{N_\\phi-1} F(\\arccos(u_j), \\phi_k) \\Delta\\phi,\n$$\nwhere $\\{u_j, w_j\\}$ are the Gauss-Legendre nodes and weights, $\\phi_k = k \\cdot (2\\pi/N_\\phi)$, and $\\Delta\\phi = 2\\pi/N_\\phi$. This numerical scheme is applied at each time step to compute the momentum flux.\n\n### 3. Computation of the Momentum Flux Time Series\n\nFor each time step $t_k$ in our discrete time array, we compute the vector $d\\vec{P}/dt(t_k)$. The procedure is as follows:\n1.  **Reconstruct the News Function**: The full news function $\\mathcal{N}(t_k, \\theta, \\phi)$ is synthesized on the 2D angular grid $(\\theta_j, \\phi_k)$ by summing the contributions from each mode:\n    $$\n    \\mathcal{N}(t_k, \\theta_j, \\phi_k) = \\sum_{m=-2}^{2} \\mathcal{N}_{2m}(t_k) \\; {}_{-2}Y_{2m}(\\theta_j, \\phi_k).\n    $$\n    The functions for the spin-weighted spherical harmonics ${}_{-2}Y_{2m}(\\theta, \\phi)$ are implemented directly from the provided formulas.\n2.  **Form the Integrand**: The squared magnitude of the news, $|\\mathcal{N}(t_k, \\theta_j, \\phi_k)|^2$, is computed. This real-valued function is then multiplied by each component of the unit vector, $n^i(\\theta_j, \\phi_k)$, to form the three integrands for the momentum flux components.\n3.  **Perform Spherical Integration**: The 2D numerical quadrature described above is applied to each of the three integrands to obtain the values of $dP^x/dt$, $dP^y/dt$, and $dP^z/dt$ at time $t_k$.\n\nThis process is repeated for all $N_t$ time steps, yielding three time series arrays representing the evolution of the momentum flux components.\n\n### 4. Total Radiated Momentum and Recoil Velocity\n\nThe total linear momentum radiated by the gravitational waves, $\\vec{P}_{\\mathrm{rad}}$, is the time integral of the momentum flux over the duration of the emission:\n$$\n\\vec{P}_{\\mathrm{rad}} = \\int_{t_0}^{t_f} \\frac{d\\vec{P}}{dt} dt.\n$$\nThis integral is computed for each component using the trapezoidal rule on the momentum flux time series generated in the previous step, implemented via `numpy.trapz`.\n\nBy the principle of conservation of linear momentum, the momentum gained by the remnant object must be equal and opposite to the momentum carried away by the waves, assuming the system started with zero net momentum. The final recoil velocity of the remnant is therefore:\n$$\n\\vec{v}_{\\mathrm{kick}} = -\\frac{\\vec{P}_{\\mathrm{rad}}}{M_f},\n$$\nwhere $M_f$ is the final mass of the remnant provided for each test case. This calculation yields the dimensionless kick velocity in geometric units ($c=1$).\n\nFinally, to convert this result to physical units, the dimensionless velocity vector is multiplied by the speed of light in kilometers per second, $c_{\\mathrm{km/s}} = 299\\,792.458$. The resulting velocity components $(v_x, v_y, v_z)$ in $\\mathrm{km/s}$ constitute the final answer for each test case. The overall logic is encapsulated in a function that iterates through the four test cases, performing this full calculation for each and collecting the results for final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Computes the gravitational wave recoil velocity for a set of synthetic test cases.\n    The pipeline involves:\n    1. Generating synthetic psi_4 modes.\n    2. Integrating psi_4 modes to get the news modes.\n    3. Reconstructing the news function on a spherical grid at each time step.\n    4. Calculating the momentum flux via spherical quadrature.\n    5. Integrating the momentum flux over time to get total radiated momentum.\n    6. Computing the recoil velocity and converting to physical units.\n    \"\"\"\n    \n    # Physical and numerical constants\n    C_KMS = 299792.458  # Speed of light in km/s\n\n    # Spin-weighted spherical harmonic functions for l=2, s=-2\n    def s2Y22(theta, phi):\n        return np.sqrt(5.0 / (64.0 * np.pi)) * (1 + np.cos(theta))**2 * np.exp(2j * phi)\n\n    def s2Y21(theta, phi):\n        return np.sqrt(5.0 / (16.0 * np.pi)) * np.sin(theta) * (1 + np.cos(theta)) * np.exp(1j * phi)\n\n    def s2Y20(theta, phi):\n        return np.sqrt(15.0 / (32.0 * np.pi)) * np.sin(theta)**2\n\n    def s2Y2m1(theta, phi):\n        return np.sqrt(5.0 / (16.0 * np.pi)) * np.sin(theta) * (1 - np.cos(theta)) * np.exp(-1j * phi)\n\n    def s2Y2m2(theta, phi):\n        return np.sqrt(5.0 / (64.0 * np.pi)) * (1 - np.cos(theta))**2 * np.exp(-2j * phi)\n\n    s2Y_funcs = {\n        2: s2Y22,\n        1: s2Y21,\n        0: s2Y20,\n        -1: s2Y2m1,\n        -2: s2Y2m2,\n    }\n\n    def calculate_kick(psi4_modes, Mf, t_params, grid_params):\n        \"\"\"\n        Performs the core calculation for a single test case.\n        \"\"\"\n        t0, tf, Nt, omega = t_params\n        N_theta, N_phi = grid_params\n\n        # 1. Time setup\n        t = np.linspace(t0, tf, Nt)\n        dt = t[1] - t[0]\n        \n        # Envelope function for t in [0, tf]\n        w = np.sin(np.pi * t / tf)**2\n\n        # 2. Spherical grid setup for quadrature\n        # Gauss-Legendre quadrature for theta integration\n        u, w_theta = np.polynomial.legendre.leggauss(N_theta)  # u = cos(theta)\n        theta_nodes = np.arccos(u)\n        \n        # Uniform trapezoidal rule for phi integration\n        phi_nodes = np.linspace(0, 2 * np.pi, N_phi, endpoint=False)\n        dphi = 2 * np.pi / N_phi\n        \n        phi_grid, theta_grid = np.meshgrid(phi_nodes, theta_nodes)\n        \n        # 3. Calculate News modes N_lm(t) = integral(psi_4_lm(t')) dt'\n        News_lm = {}\n        for m, (A, phase) in psi4_modes.items():\n            if A == 0:\n                continue\n            psi4_lm_t = A * w * np.exp(1j * (omega * t + phase))\n            News_lm[m] = cumulative_trapezoid(psi4_lm_t, dx=dt, initial=0)\n\n        # 4. Compute momentum flux dP/dt at each time step\n        dPx_dt, dPy_dt, dPz_dt = np.zeros(Nt), np.zeros(Nt), np.zeros(Nt)\n\n        # Pre-calculate harmonics and unit vector components on the grid\n        Y_lm_grid = {m: s2Y_funcs[m](theta_grid, phi_grid) for m in News_lm}\n        \n        nx_grid = np.sin(theta_grid) * np.cos(phi_grid)\n        ny_grid = np.sin(theta_grid) * np.sin(phi_grid)\n        nz_grid = np.cos(theta_grid)\n        \n        for k in range(Nt):  # Loop over time\n            # Construct total news function on the grid at time t_k\n            News_grid_k = np.zeros((N_theta, N_phi), dtype=np.complex128)\n            for m, news_lm_t in News_lm.items():\n                News_grid_k += news_lm_t[k] * Y_lm_grid[m]\n            \n            abs_News_sq = np.abs(News_grid_k)**2\n            \n            # Integrands for momentum flux (without constant factor)\n            integrand_x = nx_grid * abs_News_sq\n            integrand_y = ny_grid * abs_News_sq\n            integrand_z = nz_grid * abs_News_sq\n            \n            # Perform spherical integration\n            # Phi integral (trapezoidal)\n            int_phi_x = np.sum(integrand_x, axis=1) * dphi\n            int_phi_y = np.sum(integrand_y, axis=1) * dphi\n            int_phi_z = np.sum(integrand_z, axis=1) * dphi\n            \n            # Theta integral (Gauss-Legendre)\n            integral_x = np.sum(int_phi_x * w_theta)\n            integral_y = np.sum(int_phi_y * w_theta)\n            integral_z = np.sum(int_phi_z * w_theta)\n            \n            # Store flux component for time t_k, including constant factor\n            flux_factor = 1.0 / (16.0 * np.pi)\n            dPx_dt[k] = flux_factor * integral_x\n            dPy_dt[k] = flux_factor * integral_y\n            dPz_dt[k] = flux_factor * integral_z\n            \n        # 5. Integrate flux over time for total radiated momentum\n        Px_rad = np.trapz(dPx_dt, x=t)\n        Py_rad = np.trapz(dPy_dt, x=t)\n        Pz_rad = np.trapz(dPz_dt, x=t)\n        \n        # 6. Calculate kick velocity\n        vx_kms = -Px_rad / Mf * C_KMS\n        vy_kms = -Py_rad / Mf * C_KMS\n        vz_kms = -Pz_rad / Mf * C_KMS\n        \n        return [vx_kms, vy_kms, vz_kms]\n\n    # Define test cases from the problem statement.\n    t_params = (0.0, 4.0, 2000, 30.0)  # (t0, tf, Nt, omega)\n    grid_params = (48, 96)  # (N_theta, N_phi)\n\n    test_cases = [\n        # Case 1 (symmetry cancellation): A_22=2e-3, A_2,-2=2e-3, Mf=1.0\n        ({'m': {2: (2e-3, 0.0), -2: (2e-3, 0.0)}}, 1.0),\n        # Case 2 (in-plane asymmetry): A_22=2e-3, A_21=6e-4, Mf=1.0\n        ({'m': {2: (2e-3, 0.0), 1: (6e-4, 0.0)}}, 1.0),\n        # Case 3 (phase-flipped asymmetry): same as 2 but phi_21=pi\n        ({'m': {2: (2e-3, 0.0), 1: (6e-4, np.pi)}}, 1.0),\n        # Case 4 (mass scaling): same as 2 but Mf=2.0\n        ({'m': {2: (2e-3, 0.0), 1: (6e-4, 0.0)}}, 2.0),\n    ]\n\n    results = []\n    for case_def, Mf in test_cases:\n        # Construct full mode dictionary for l=2, defaulting to zero\n        psi4_modes = {m: (0.0, 0.0) for m in [-2, -1, 0, 1, 2]}\n        psi4_modes.update(case_def['m'])\n        \n        kick_velocity = calculate_kick(psi4_modes, Mf, t_params, grid_params)\n        results.append(kick_velocity)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Numerical simulations are necessarily performed on finite computational domains, yet physical gravitational wave measurements are defined at future null infinity ($r \\to \\infty$). This exercise tackles the crucial step of extrapolation, a standard procedure in high-precision numerical relativity. You will implement a robust statistical framework based on weighted least squares to extrapolate finite-radius kick velocity measurements to infinity and, just as importantly, construct a detailed error budget that accounts for statistical, model-selection, and systematic uncertainties, mirroring the rigorous analysis required for scientific publications .",
            "id": "3485253",
            "problem": "You are given a set of measurements of the recoil velocity at infinity, denoted by $v_{\\rm kick}(\\infty)$, inferred from gravitational-wave momentum fluxes extracted on finite coordinate spheres at extraction radii $r_i$ (in units of total mass $M$). At finite $r$, asymptotic expansions of the radiative fields imply that the measured, time-integrated recoil velocity $v_{\\rm kick}(r)$ can be modeled as a smooth series in the compactifying variable $x = 1/r$, to leading orders,\n$$\nv_{\\rm kick}(r) \\equiv v(x) \\approx v_0 + a x + b x^2 + \\mathcal{O}(x^3),\n$$\nwhere $v_0 = v_{\\rm kick}(\\infty)$ is the desired recoil at future null infinity, and $a,b$ encode finite-radius effects. In practice, $v(r)$ is measured with numerical uncertainty arising from time integration, finite resolution, and mode truncation; we model these as independent, Gaussian-distributed uncertainties with known standard deviations for each radius sample.\n\nStarting from:\n- The asymptotic structure of gravitational radiation in the far zone, where outgoing solutions of the linearized Einstein equations imply $1/r$ amplitude decay and smooth $1/r$ expansions of observables.\n- The linear momentum flux carried by gravitational waves, whose time integral yields a finite recoil velocity in the late-time limit when evaluated at future null infinity.\n- Weighted least squares as the maximum-likelihood estimator under independent Gaussian errors.\n\nDesign an algorithm that:\n1. Uses weighted polynomial regression in the variable $x = 1/r$ to estimate $v_0$ with two models:\n   - A linear model in $x$, namely $v(x) = v_0 + a x$.\n   - A quadratic model in $x$, namely $v(x) = v_0 + a x + b x^2$.\n2. Computes the statistical uncertainty for $v_0$ from the covariance matrix of the chosen regression, with the standard practice of rescaling the covariance by the reduced chi-squared $\\chi^2_{\\nu}$ if $\\chi^2_{\\nu} > 1$, and leaving it unscaled otherwise. If the number of data points equals the number of fit parameters, set the degrees of freedom to zero and do not rescale.\n3. Estimates a model-selection systematic by the absolute difference $|v^{(2)}_0 - v^{(1)}_0|$ between the quadratic and linear extrapolations whenever both are defined; if only one model is defined by the data, set this term to zero.\n4. Estimates a fit-range systematic by performing leave-one-out fits with the chosen regression model and taking the standard deviation of the set of leave-one-out $v_0$ values; if fewer than two leave-one-out fits are possible, set this term to zero.\n5. Reports the total uncertainty as the quadrature sum of the statistical, model-selection, and fit-range components.\n\nYour program must implement the above, using the following deterministic test suite. All radii $r_i$ are dimensionless in units of total mass $M$. All recoil velocities must be interpreted and returned in units of kilometers per second (km/s). All uncertainties are given as one standard deviation in km/s.\n\nTest suite:\n- Case A (happy path, many radii, modest heteroskedastic errors):\n  - Radii $r$: $[100,120,140,160,180,220]$\n  - Measured $v(r)$ in km/s: $[190.600,189.700,189.792,188.963,188.519,187.921]$\n  - One-sigma uncertainties in km/s: $[0.8,0.7,0.6,0.6,0.7,0.8]$\n- Case B (boundary case, minimal sample for a linear fit only):\n  - Radii $r$: $[100,150]$\n  - Measured $v(r)$ in km/s: $[190.200,188.900]$\n  - One-sigma uncertainties in km/s: $[1.0,1.0]$\n- Case C (edge case with an outlier downweighted by a large uncertainty):\n  - Radii $r$: $[80,100,130,170,220]$\n  - Measured $v(r)$ in km/s: $[373.750,360.700,353.720,348.574,342.840]$\n  - One-sigma uncertainties in km/s: $[5.0,1.0,0.8,0.9,1.2]$\n\nImplementation details and requirements:\n- Use the compactifying variable $x_i = 1/r_i$ as the regression abscissa.\n- Perform weighted least squares by minimizing\n  $$\n  \\chi^2 = \\sum_{i} \\frac{\\left(v_i - \\hat{v}(x_i)\\right)^2}{\\sigma_i^2},\n  $$\n  where $v_i$ are the measured values and $\\sigma_i$ are their one-sigma uncertainties. The covariance matrix should be computed from the inverse of the normal equations matrix. If the number of data points is $N$ and the number of fitted parameters is $p$, then the degrees of freedom is $\\nu = N - p$. If $\\nu > 0$ and the reduced chi-squared $\\chi^2_{\\nu} = \\chi^2/\\nu$ exceeds $1$, rescale the covariance matrix by $\\chi^2_{\\nu}$. If $\\nu \\le 0$, do not rescale.\n- Choose the preferred model as follows: use the quadratic model if there are at least $4$ data points; otherwise, use the linear model.\n- For the leave-one-out systematic, when the preferred model cannot be fit after removing a data point (insufficient data), skip that removal. If fewer than two successful removals are available, set this systematic to zero.\n- The total reported uncertainty must be computed as\n  $$\n  \\sigma_{\\rm tot} = \\sqrt{\\sigma_{\\rm stat}^2 + \\sigma_{\\rm model}^2 + \\sigma_{\\rm range}^2}.\n  $$\n- Express all final $v_0$ estimates and their total uncertainties in km/s. There are no angles involved. No percentages are required.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a Python-like list of lists, one inner list per test case in the order A, B, C. Each inner list must contain the estimated $v_0$ and its total uncertainty, both rounded to six decimal places, e.g.,\n  $$\n  [[v_{0,A},\\ \\sigma_{{\\rm tot},A}],\\ [v_{0,B},\\ \\sigma_{{\\rm tot},B}],\\ [v_{0,C},\\ \\sigma_{{\\rm tot},C}]].\n  $$",
            "solution": "The user has requested an algorithm to estimate the recoil velocity at infinity, $v_0 = v_{\\rm kick}(\\infty)$, from a series of measurements $v_{\\rm kick}(r_i)$ taken at finite radii $r_i$. The algorithm must also provide a robust uncertainty quantification by combining statistical, model-selection, and fit-range systematic errors.\n\n### **Problem Statement Validation**\n\n#### Step 1: Extract Givens\n\n-   **Model**: The measured recoil velocity $v(r)$ is modeled as a series in $x = 1/r$:\n    $$\n    v(x) \\approx v_0 + a x + b x^2 + \\mathcal{O}(x^3)\n    $$\n-   **Data**: For each test case, we are given a set of extraction radii $r_i$, corresponding measured velocities $v(r_i)$, and their one-sigma Gaussian uncertainties $\\sigma_i$.\n-   **Regression Models**:\n    1.  Linear: $v(x) = v_0 + a x$\n    2.  Quadratic: $v(x) = v_0 + a x + b x^2$\n-   **Fitting Method**: Weighted Least Squares (WLS) must be used, minimizing $\\chi^2 = \\sum_{i} \\left(v_i - \\hat{v}(x_i)\\right)^2/\\sigma_i^2$.\n-   **Model Selection Rule**: Use the quadratic model if the number of data points $N \\ge 4$; otherwise, use the linear model.\n-   **Uncertainty Components**:\n    1.  **Statistical Uncertainty ($\\sigma_{\\rm stat}$)**: Derived from the covariance matrix of the preferred model fit. The covariance matrix $\\mathbf{C}$ is to be rescaled by the reduced chi-squared, $\\chi^2_{\\nu} = \\chi^2/\\nu$, if $\\chi^2_{\\nu} > 1$ and the degrees of freedom $\\nu = N-p > 0$. If $\\nu \\le 0$, no rescaling is performed.\n    2.  **Model-Selection Systematic ($\\sigma_{\\rm model}$)**: The absolute difference $|v^{(2)}_0 - v^{(1)}_0|$ between the intercepts from the quadratic and linear fits, if both are possible. Otherwise, this is zero.\n    3.  **Fit-Range Systematic ($\\sigma_{\\rm range}$)**: The standard deviation of the set of $v_0$ values obtained from leave-one-out fits using the preferred model. If fewer than two such fits are possible, this is zero.\n-   **Total Uncertainty**: $\\sigma_{\\rm tot} = \\sqrt{\\sigma_{\\rm stat}^2 + \\sigma_{\\rm model}^2 + \\sigma_{\\rm range}^2}$.\n-   **Test Suite**: Three specific cases (A, B, C) are provided with data for $r_i$, $v(r_i)$, and $\\sigma_i$.\n-   **Output Format**: A single-line Python-like list of lists, e.g., `[[v_0_A, sigma_tot_A], [v_0_B, sigma_tot_B], ...]`, with all numerical values rounded to six decimal places.\n\n#### Step 2: Validate Using Extracted Givens\n\nThe problem is reviewed against the validation criteria:\n-   **Scientifically Grounded**: The problem is an accurate representation of a standard data analysis task in numerical relativity. The use of polynomial extrapolation in $x=1/r$ is derived from the asymptotic expansion of gravitational radiation fields (the peeling theorem). The statistical methods, including weighted least squares and the estimation of systematic errors, are standard and well-founded.\n-   **Well-Posed**: The problem is clearly defined with all necessary data and a deterministic set of rules for model selection and uncertainty calculation. This structure ensures a unique, stable, and meaningful solution for each test case.\n-   **Objective**: The problem is stated in precise, quantitative terms, free from any subjectivity or ambiguity.\n\nThe problem exhibits none of the invalidity flaws. It is scientifically sound, self-contained, consistent, and formalizable.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be provided.\n\n### **Principle-Based Algorithmic Design**\n\nThe core of the problem is to perform a polynomial regression on a set of data points with known uncertainties. The appropriate statistical tool for this is the method of Weighted Least Squares (WLS), which is the maximum likelihood estimator for parameters of a model with independent, normally distributed errors.\n\n**1. Weighted Least Squares (WLS) Formalism**\n\nGiven a set of $N$ data points $(x_i, y_i)$ with corresponding uncertainties $\\sigma_i$, we wish to fit a linear model of the form $y(x) = \\sum_{j=0}^{p-1} c_j X_j(x)$, where $p$ is the number of parameters $c_j$ and $X_j(x)$ are the basis functions. For a polynomial of degree $p-1$, $X_j(x) = x^j$. The problem can be cast in matrix form. Let:\n-   $\\mathbf{v}$ be the $N \\times 1$ vector of measured velocities $v_i$.\n-   $\\mathbf{p}$ be the $p \\times 1$ vector of parameters to be estimated (e.g., for a quadratic fit, $\\mathbf{p} = [v_0, a, b]^T$).\n-   $\\mathbf{A}$ be the $N \\times p$ design matrix, where $A_{ij} = X_j(x_i) = x_i^j$.\n-   $\\mathbf{W}$ be the $N \\times N$ diagonal weight matrix with entries $W_{ii} = 1/\\sigma_i^2$.\n\nThe WLS method seeks to find the parameter vector $\\mathbf{p}$ that minimizes the chi-squared statistic:\n$$\n\\chi^2 = \\sum_{i=1}^{N} w_i (v_i - \\hat{v}(x_i))^2 = (\\mathbf{v} - \\mathbf{A}\\mathbf{p})^T \\mathbf{W} (\\mathbf{v} - \\mathbf{A}\\mathbf{p})\n$$\nThe minimum is found by solving the normal equations:\n$$\n(\\mathbf{A}^T \\mathbf{W} \\mathbf{A}) \\mathbf{p} = \\mathbf{A}^T \\mathbf{W} \\mathbf{v}\n$$\nThe best-fit parameters are given by:\n$$\n\\hat{\\mathbf{p}} = (\\mathbf{A}^T \\mathbf{W} \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{W} \\mathbf{v}\n$$\nThe parameter of interest is $v_0$, which corresponds to the first element of $\\hat{\\mathbf{p}}$, $\\hat{p}_0$.\n\n**2. Uncertainty Estimation**\n\nThe total uncertainty is a composite of three distinct components, each estimated according to a specific procedure.\n\n**a. Statistical Uncertainty ($\\sigma_{\\rm stat}$)**\nThe covariance matrix of the estimated parameters $\\hat{\\mathbf{p}}$ is given by:\n$$\n\\mathbf{C} = (\\mathbf{A}^T \\mathbf{W} \\mathbf{A})^{-1}\n$$\nThe variance of the parameter $\\hat{p}_j$ is the $j$-th diagonal element, $C_{jj}$. Thus, the initial statistical variance of $v_0$ is $C_{00}$. The problem specifies that this covariance matrix may need to be rescaled. The number of degrees of freedom is $\\nu = N-p$. If $\\nu > 0$, we compute the reduced chi-squared:\n$$\n\\chi^2_{\\nu} = \\frac{\\chi^2}{\\nu}\n$$\nIf $\\chi^2_{\\nu} > 1$, it indicates that the model may be a poor fit to the data, or the error bars $\\sigma_i$ are underestimated. Following standard practice, we rescale the covariance matrix:\n$$\n\\mathbf{C}_{\\rm rescaled} = \\chi^2_{\\nu} \\mathbf{C}\n$$\nThe statistical uncertainty on $v_0$ is then the square root of the top-left element of the (possibly rescaled) covariance matrix:\n$$\n\\sigma_{\\rm stat} = \\sqrt{(\\mathbf{C}_{\\rm final})_{00}}\n$$\nThis calculation is performed using the parameters of the *preferred model* (quadratic for $N \\ge 4$, linear otherwise).\n\n**b. Model-Selection Systematic ($\\sigma_{\\rm model}$)**\nThis term quantifies the uncertainty arising from the choice of the polynomial model. It is estimated by the difference in the extrapolated value $v_0$ between the two models under consideration:\n$$\n\\sigma_{\\rm model} = |v_0^{\\rm (quadratic)} - v_0^{\\rm (linear)}|\n$$\nThis is computed only if both linear ($N \\ge 2$) and quadratic ($N \\ge 3$) fits are possible. If either is not, this systematic error is taken to be zero.\n\n**c. Fit-Range Systematic ($\\sigma_{\\rm range}$)**\nThis component estimates the uncertainty due to the limited range of the data radii $r_i$. It is assessed using a leave-one-out cross-validation technique. For the preferred model, we perform $N$ separate fits, each time omitting one data point $(x_k, v_k, \\sigma_k)$. This yields a set of $k \\le N$ extrapolated values $\\{ v_{0,(1)}, v_{0,(2)}, \\dots, v_{0,(k)} \\}$, where a fit may not be possible if removing a point leaves insufficient data (e.g., attempting a quadratic fit with fewer than $3$ points). If at least two such values are obtained ($k \\ge 2$), the systematic is the sample standard deviation of this set:\n$$\n\\sigma_{\\rm range} = \\sqrt{\\frac{1}{k-1} \\sum_{i=1}^{k} (v_{0,(i)} - \\bar{v}_0)^2}\n$$\nIf $k < 2$, this error is set to zero.\n\n**3. Final Algorithm**\nFor each test case:\n1.  Convert the radii $r_i$ to the compactified coordinate $x_i = 1/r_i$.\n2.  Perform a WLS linear fit (degree $1$) if $N \\ge 2$ to obtain $v_0^{(1)}$.\n3.  Perform a WLS quadratic fit (degree $2$) if $N \\ge 3$ to obtain $v_0^{(2)}$.\n4.  Determine the preferred model based on the rule: quadratic if $N \\ge 4$, linear otherwise.\n5.  Calculate $\\sigma_{\\rm stat}$ from the covariance matrix of the preferred model, including the specified rescaling logic.\n6.  Calculate $\\sigma_{\\rm model}$ from the difference between $v_0^{(1)}$ and $v_0^{(2)}$, if applicable.\n7.  Calculate $\\sigma_{\\rm range}$ using the leave-one-out procedure on the preferred model.\n8.  Compute the total uncertainty $\\sigma_{\\rm tot} = \\sqrt{\\sigma_{\\rm stat}^2 + \\sigma_{\\rm model}^2 + \\sigma_{\\rm range}^2}$.\n9.  The final result is the pair $[v_0, \\sigma_{\\rm tot}]$ where $v_0$ is from the preferred model.",
            "answer": "```python\nimport numpy as np\n\ndef perform_wls_fit(x, y, sigma, deg):\n    \"\"\"\n    Performs a weighted least squares polynomial fit.\n\n    Args:\n        x (np.ndarray): The independent variable.\n        y (np.ndarray): The dependent variable.\n        sigma (np.ndarray): The 1-sigma uncertainties in y.\n        deg (int): The degree of the polynomial to fit.\n\n    Returns:\n        A dictionary containing fit results, or None if the fit is not possible.\n        Keys: \"v0\", \"cov_matrix\".\n    \"\"\"\n    N = len(x)\n    p = deg + 1\n    if N < p:\n        return None\n\n    # Construct the design matrix A (Vandermonde matrix)\n    A = np.vander(x, p, increasing=True)\n    \n    # Construct the diagonal weight matrix W\n    w = 1.0 / (sigma**2)\n    W = np.diag(w)\n\n    # Normal equations: (A^T W A) params = A^T W y\n    M = A.T @ W @ A\n    z = A.T @ W @ y\n\n    try:\n        # Solve for parameters and get the unscaled covariance matrix\n        M_inv = np.linalg.inv(M)\n        params = M_inv @ z\n        cov_matrix_unscaled = M_inv\n\n        # Calculate chi-squared for potential rescaling\n        y_fit = A @ params\n        chi_sq = np.sum(((y - y_fit) / sigma)**2)\n        dof = N - p\n\n        # Rescale covariance matrix if chi_sq/dof > 1\n        final_cov_matrix = cov_matrix_unscaled.copy()\n        if dof > 0:\n            reduced_chi_sq = chi_sq / dof\n            if reduced_chi_sq > 1.0:\n                final_cov_matrix *= reduced_chi_sq\n\n        return {\n            \"v0\": params[0],\n            \"cov_matrix\": final_cov_matrix,\n        }\n    except np.linalg.LinAlgError:\n        return None\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"r\": np.array([100, 120, 140, 160, 180, 220]),\n            \"v\": np.array([190.600, 189.700, 189.792, 188.963, 188.519, 187.921]),\n            \"sigma\": np.array([0.8, 0.7, 0.6, 0.6, 0.7, 0.8]),\n        },\n        # Case B\n        {\n            \"r\": np.array([100, 150]),\n            \"v\": np.array([190.200, 188.900]),\n            \"sigma\": np.array([1.0, 1.0]),\n        },\n        # Case C\n        {\n            \"r\": np.array([80, 100, 130, 170, 220]),\n            \"v\": np.array([373.750, 360.700, 353.720, 348.574, 342.840]),\n            \"sigma\": np.array([5.0, 1.0, 0.8, 0.9, 1.2]),\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        r, v, sigma = case[\"r\"], case[\"v\"], case[\"sigma\"]\n        x = 1.0 / r\n        N = len(r)\n\n        # 1. Perform both linear and quadratic fits where possible\n        lin_fit_res = perform_wls_fit(x, v, sigma, deg=1)\n        quad_fit_res = perform_wls_fit(x, v, sigma, deg=2)\n\n        # 2. Choose the preferred model\n        preferred_deg = 2 if N >= 4 else 1\n        preferred_fit_res = quad_fit_res if preferred_deg == 2 else lin_fit_res\n        \n        final_v0 = preferred_fit_res[\"v0\"]\n\n        # 3. Calculate statistical uncertainty\n        stat_uncert_sq = preferred_fit_res[\"cov_matrix\"][0, 0]\n\n        # 4. Calculate model-selection systematic\n        model_syst_sq = 0.0\n        if lin_fit_res and quad_fit_res:\n            model_syst_sq = (lin_fit_res[\"v0\"] - quad_fit_res[\"v0\"])**2\n\n        # 5. Calculate fit-range systematic (leave-one-out)\n        range_syst_sq = 0.0\n        loo_v0s = []\n        for i in range(N):\n            x_loo = np.delete(x, i)\n            v_loo = np.delete(v, i)\n            sigma_loo = np.delete(sigma, i)\n            \n            loo_fit_res = perform_wls_fit(x_loo, v_loo, sigma_loo, deg=preferred_deg)\n            if loo_fit_res:\n                loo_v0s.append(loo_fit_res[\"v0\"])\n        \n        if len(loo_v0s) >= 2:\n            range_syst_sq = np.std(loo_v0s, ddof=1)**2\n\n        # 6. Calculate total uncertainty\n        total_uncert = np.sqrt(stat_uncert_sq + model_syst_sq + range_syst_sq)\n\n        # 7. Append rounded results\n        v0_rounded = round(final_v0, 6)\n        sigma_tot_rounded = round(total_uncert, 6)\n        final_results.append([v0_rounded, sigma_tot_rounded])\n\n    # 8. Format and print the final output\n    # The map(str, ...) converts each inner list to its string representation.\n    # The join(...) combines these strings with commas.\n    # The outer f-string adds the final brackets.\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A common feature of numerical relativity simulations is the presence of initial, non-physical transients known as \"junk radiation,\" which arise from the imperfect initial data used to start the evolution. This contamination can spoil the calculation of physical observables like the recoil velocity if not handled properly. This exercise provides a practical method to model, quantify, and subtract the contribution from this junk radiation, and to estimate the residual systematic uncertainty, offering valuable experience in a critical data-cleaning and error-analysis task .",
            "id": "3485326",
            "problem": "Consider a binary black hole merger simulated in geometrized units where the total remnant mass is $M_{\\mathrm{f}}$ and the speed of light is $c$. The linear momentum carried by gravitational waves is encoded in the Isaacson effective stress-energy tensor, and the recoil (kick) velocity $v_{\\mathrm{kick}}$ of the remnant satisfies $v_{\\mathrm{kick}} = |\\Delta \\mathbf{P}|/M_{\\mathrm{f}}$, where $\\Delta \\mathbf{P} = \\int (d\\mathbf{P}/dt)\\, dt$ is the net radiated linear momentum. Suppose the numerically extracted linear momentum flux in the $z$-direction, $F(t) \\equiv dP_{z}/dt$, contains both physical signal and initial-data junk radiation. Let the physical contribution be modeled by\n$$\nF_{\\mathrm{phys}}(t) = \\frac{A}{\\left(1 + \\left(\\frac{t}{\\tau}\\right)^{2}\\right)^{2}},\n$$\nwith $A = 8.0 \\times 10^{-5}$ and $\\tau = 50$, and let the junk radiation be approximated by a Gaussian template\n$$\ng(t) = \\exp\\left(-\\frac{t^{2}}{2\\sigma^{2}}\\right),\n$$\nwith $\\sigma = 5$. The total flux is then $F_{\\mathrm{tot}}(t) = F_{\\mathrm{phys}}(t) + B\\, g(t)$, where $B$ is the true amplitude of the junk radiation contribution. A matched-filter estimate performed on the early-time data yields an estimated amplitude $\\widehat{B} = 6.50 \\times 10^{-5}$, while the true amplitude is $B = 6.493 \\times 10^{-5}$.\n\nTo mitigate contamination from the initial-data junk, implement an early-time taper by discarding data prior to a cutoff time $T$, modeled by the Heaviside window $W_{T}(t) = H(t - T)$, where $H$ is the Heaviside step function. Define the taper-corrected recoil as\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{M_{\\mathrm{f}}} \\left[\\int_{T}^{\\infty} F_{\\mathrm{tot}}(t)\\, dt - \\widehat{B} \\int_{T}^{\\infty} g(t)\\, dt \\right].\n$$\nThus the junk is quantified by its template tail integral and subtracted using the matched-filter amplitude. Assume $M_{\\mathrm{f}} = 1$ in geometrized units and convert the final velocity to kilometers per second using $c = 2.99792458 \\times 10^{5}$ km/s.\n\nTasks:\n- Starting from the definitions above, express $v_{\\mathrm{corr}}(T)$ in closed form for general $T$ in terms of the given parameters $A$, $\\tau$, $B$, $\\widehat{B}$, and $\\sigma$.\n- Evaluate $v_{\\mathrm{corr}}(T_{1})$ and $v_{\\mathrm{corr}}(T_{2})$ for $T_{1} = 5$ and $T_{2} = 10$, respectively, and use these to estimate the residual systematic due to early-time tapering as $|\\;v_{\\mathrm{corr}}(T_{1}) - v_{\\mathrm{corr}}(T_{2})\\;|$ in kilometers per second.\n- Report the corrected recoil velocity $v_{\\mathrm{corr}}(T_{2})$ in kilometers per second. Round your answer to four significant figures.",
            "solution": "The problem statement has been validated against the specified criteria. It is scientifically grounded, well-posed, objective, and complete. It presents a standard calculation from the field of numerical relativity concerning the extraction of a physical signal, the black hole recoil velocity, from a simulation that includes initial non-physical transients, or \"junk radiation.\" The methods described, including phenomenological modeling of the signal and junk, matched filtering, and time-domain tapering, are well-established techniques. Therefore, the problem is deemed valid and a full solution will be provided.\n\nThe first task is to find a closed-form expression for the taper-corrected recoil velocity, $v_{\\mathrm{corr}}(T)$. The definition is given as:\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{M_{\\mathrm{f}}} \\left[\\int_{T}^{\\infty} F_{\\mathrm{tot}}(t)\\, dt - \\widehat{B} \\int_{T}^{\\infty} g(t)\\, dt \\right]\n$$\nThe total momentum flux is $F_{\\mathrm{tot}}(t) = F_{\\mathrm{phys}}(t) + B\\, g(t)$. Substituting this into the expression for $v_{\\mathrm{corr}}(T)$:\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{M_{\\mathrm{f}}} \\left[\\int_{T}^{\\infty} (F_{\\mathrm{phys}}(t) + B g(t))\\, dt - \\widehat{B} \\int_{T}^{\\infty} g(t)\\, dt \\right]\n$$\nWe can separate the integrals and group the terms involving $g(t)$:\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{M_{\\mathrm{f}}} \\left[ \\int_{T}^{\\infty} F_{\\mathrm{phys}}(t)\\, dt + (B - \\widehat{B}) \\int_{T}^{\\infty} g(t)\\, dt \\right]\n$$\nTo obtain the closed-form expression, we must evaluate the two definite integrals.\n\nFirst, let's evaluate the integral of the physical flux, $I_{\\mathrm{phys}}(T) = \\int_{T}^{\\infty} F_{\\mathrm{phys}}(t)\\, dt$.\n$$\nI_{\\mathrm{phys}}(T) = \\int_{T}^{\\infty} \\frac{A}{\\left(1 + \\left(\\frac{t}{\\tau}\\right)^{2}\\right)^{2}} dt\n$$\nWe perform a substitution $u = t/\\tau$, which implies $dt = \\tau \\,du$. The lower integration limit becomes $T/\\tau$ and the upper limit remains $\\infty$.\n$$\nI_{\\mathrm{phys}}(T) = A\\tau \\int_{T/\\tau}^{\\infty} \\frac{1}{(1+u^2)^2} du\n$$\nThis integral can be solved using a trigonometric substitution. Let $u = \\tan(\\theta)$, so $du = \\sec^2(\\theta) \\, d\\theta$. The term $1+u^2 = 1+\\tan^2(\\theta) = \\sec^2(\\theta)$.\nThe indefinite integral becomes:\n$$\n\\int \\frac{\\sec^2(\\theta)}{(\\sec^2(\\theta))^2} d\\theta = \\int \\frac{1}{\\sec^2(\\theta)} d\\theta = \\int \\cos^2(\\theta) \\,d\\theta\n$$\nUsing the identity $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$, the integral is:\n$$\n\\frac{1}{2} \\int (1 + \\cos(2\\theta)) \\,d\\theta = \\frac{1}{2}\\left(\\theta + \\frac{1}{2}\\sin(2\\theta)\\right) = \\frac{1}{2}\\theta + \\frac{1}{4}(2\\sin(\\theta)\\cos(\\theta)) = \\frac{1}{2}(\\theta + \\sin(\\theta)\\cos(\\theta))\n$$\nWe now substitute back in terms of $u$. Since $u = \\tan(\\theta)$, we have $\\theta = \\arctan(u)$. From a right triangle with opposite side $u$ and adjacent side $1$, the hypotenuse is $\\sqrt{1+u^2}$. Thus, $\\sin(\\theta) = u/\\sqrt{1+u^2}$ and $\\cos(\\theta) = 1/\\sqrt{1+u^2}$, which gives $\\sin(\\theta)\\cos(\\theta) = u/(1+u^2)$.\nThe indefinite integral in terms of $u$ is:\n$$\n\\int \\frac{1}{(1+u^2)^2} du = \\frac{1}{2}\\left( \\arctan(u) + \\frac{u}{1+u^2} \\right)\n$$\nNow, we evaluate the definite integral from $T/\\tau$ to $\\infty$:\n$$\n\\int_{T/\\tau}^{\\infty} \\frac{1}{(1+u^2)^2} du = \\left[ \\frac{1}{2}\\left( \\arctan(u) + \\frac{u}{1+u^2} \\right) \\right]_{T/\\tau}^{\\infty}\n$$\nAs $u \\to \\infty$, $\\arctan(u) \\to \\pi/2$ and $u/(1+u^2) \\to 0$. The expression evaluates to:\n$$\n\\frac{1}{2}\\left(\\frac{\\pi}{2} + 0\\right) - \\frac{1}{2}\\left( \\arctan\\left(\\frac{T}{\\tau}\\right) + \\frac{T/\\tau}{1+(T/\\tau)^2} \\right) = \\frac{\\pi}{4} - \\frac{1}{2}\\arctan\\left(\\frac{T}{\\tau}\\right) - \\frac{1}{2} \\frac{T\\tau}{T^2 + \\tau^2}\n$$\nTherefore, the integral of the physical flux is:\n$$\nI_{\\mathrm{phys}}(T) = A\\tau \\left[ \\frac{\\pi}{4} - \\frac{1}{2}\\arctan\\left(\\frac{T}{\\tau}\\right) - \\frac{T\\tau}{2(T^2 + \\tau^2)} \\right] = \\frac{A\\tau}{2} \\left[ \\frac{\\pi}{2} - \\arctan\\left(\\frac{T}{\\tau}\\right) - \\frac{T\\tau}{T^2 + \\tau^2} \\right]\n$$\nNext, we evaluate the integral of the junk radiation template, $I_{\\mathrm{junk}}(T) = \\int_{T}^{\\infty} g(t)\\, dt$.\n$$\nI_{\\mathrm{junk}}(T) = \\int_{T}^{\\infty} \\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right) dt\n$$\nThis integral is related to the complementary error function, $\\operatorname{erfc}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_z^\\infty \\exp(-x^2) dx$. We perform the substitution $x = t/(\\sqrt{2}\\sigma)$, so $dt = \\sqrt{2}\\sigma \\, dx$. The lower limit becomes $T/(\\sqrt{2}\\sigma)$.\n$$\nI_{\\mathrm{junk}}(T) = \\int_{T/(\\sqrt{2}\\sigma)}^{\\infty} \\exp(-x^2) (\\sqrt{2}\\sigma \\, dx) = \\sqrt{2}\\sigma \\int_{T/(\\sqrt{2}\\sigma)}^{\\infty} \\exp(-x^2) \\, dx\n$$\nUsing the definition of $\\operatorname{erfc}(z)$, we have $\\int_z^\\infty \\exp(-x^2) dx = \\frac{\\sqrt{\\pi}}{2} \\operatorname{erfc}(z)$.\n$$\nI_{\\mathrm{junk}}(T) = \\sqrt{2}\\sigma \\left( \\frac{\\sqrt{\\pi}}{2} \\operatorname{erfc}\\left( \\frac{T}{\\sqrt{2}\\sigma} \\right) \\right) = \\sigma \\sqrt{\\frac{\\pi}{2}} \\operatorname{erfc}\\left( \\frac{T}{\\sqrt{2}\\sigma} \\right)\n$$\nSubstituting $I_{\\mathrm{phys}}(T)$ and $I_{\\mathrm{junk}}(T)$ back into the expression for $v_{\\mathrm{corr}}(T)$, we obtain the final closed-form expression:\n$$\nv_{\\mathrm{corr}}(T) = \\frac{1}{M_{\\mathrm{f}}} \\left[ \\frac{A\\tau}{2} \\left( \\frac{\\pi}{2} - \\arctan\\left(\\frac{T}{\\tau}\\right) - \\frac{T\\tau}{T^2 + \\tau^2} \\right) + (B - \\widehat{B}) \\sigma \\sqrt{\\frac{\\pi}{2}} \\operatorname{erfc}\\left(\\frac{T}{\\sqrt{2}\\sigma}\\right) \\right]\n$$\nThis completes the first task.\n\nFor the second and third tasks, we evaluate this expression numerically. The given parameters are:\n$A = 8.0 \\times 10^{-5}$, $\\tau = 50$, $\\sigma = 5$, $B = 6.493 \\times 10^{-5}$, $\\widehat{B} = 6.50 \\times 10^{-5}$, $M_{\\mathrm{f}} = 1$, and $c = 2.99792458 \\times 10^{5}$ km/s.\nThe difference in junk amplitudes is $B - \\widehat{B} = 6.493 \\times 10^{-5} - 6.50 \\times 10^{-5} = -7 \\times 10^{-8}$.\n\nWe evaluate $v_{\\mathrm{corr}}(T_1)$ for $T_1 = 5$:\nThe arguments for the functions are $T_1/\\tau = 5/50 = 0.1$ and $T_1/(\\sqrt{2}\\sigma) = 5/(5\\sqrt{2}) = 1/\\sqrt{2}$.\n$$\nv_{\\mathrm{corr}}(T_1=5) = \\frac{8.0 \\times 10^{-5} \\times 50}{2} \\left( \\frac{\\pi}{2} - \\arctan(0.1) - \\frac{5 \\times 50}{5^2 + 50^2} \\right) - 7 \\times 10^{-8} \\times 5 \\sqrt{\\frac{\\pi}{2}} \\operatorname{erfc}\\left(\\frac{1}{\\sqrt{2}}\\right)\n$$\n$$\nv_{\\mathrm{corr}}(5) = 2 \\times 10^{-3} \\left( 1.570796 - 0.099669 - \\frac{250}{2525} \\right) - 3.5 \\times 10^{-7} \\sqrt{\\frac{\\pi}{2}} \\times 0.317311\n$$\n$$\nv_{\\mathrm{corr}}(5) = 2 \\times 10^{-3} (1.570796 - 0.099669 - 0.099010) - 3.5 \\times 10^{-7} \\times 1.253314 \\times 0.317311\n$$\n$$\nv_{\\mathrm{corr}}(5) = 2 \\times 10^{-3} (1.372117) - 1.3936 \\times 10^{-8} = 2.744234 \\times 10^{-3} - 0.000014 \\times 10^{-3} \\approx 2.74422 \\times 10^{-3}\n$$\nIn physical units, $v_{\\mathrm{corr}}(5) = (2.74422 \\times 10^{-3}) \\times c = (2.74422 \\times 10^{-3}) \\times (2.99792458 \\times 10^{5} \\text{ km/s}) = 822.698 \\text{ km/s}$.\n\nWe evaluate $v_{\\mathrm{corr}}(T_2)$ for $T_2 = 10$:\nThe arguments are $T_2/\\tau = 10/50 = 0.2$ and $T_2/(\\sqrt{2}\\sigma) = 10/(5\\sqrt{2}) = \\sqrt{2}$.\n$$\nv_{\\mathrm{corr}}(T_2=10) = \\frac{8.0 \\times 10^{-5} \\times 50}{2} \\left( \\frac{\\pi}{2} - \\arctan(0.2) - \\frac{10 \\times 50}{10^2 + 50^2} \\right) - 7 \\times 10^{-8} \\times 5 \\sqrt{\\frac{\\pi}{2}} \\operatorname{erfc}\\left(\\sqrt{2}\\right)\n$$\n$$\nv_{\\mathrm{corr}}(10) = 2 \\times 10^{-3} \\left( 1.570796 - 0.197396 - \\frac{500}{2600} \\right) - 3.5 \\times 10^{-7} \\sqrt{\\frac{\\pi}{2}} \\times 0.045500\n$$\n$$\nv_{\\mathrm{corr}}(10) = 2 \\times 10^{-3} (1.570796 - 0.197396 - 0.192308) - 3.5 \\times 10^{-7} \\times 1.253314 \\times 0.045500\n$$\n$$\nv_{\\mathrm{corr}}(10) = 2 \\times 10^{-3} (1.181092) - 1.996 \\times 10^{-9} = 2.362184 \\times 10^{-3} - 0.000002 \\times 10^{-3} \\approx 2.36218 \\times 10^{-3}\n$$\nIn physical units, $v_{\\mathrm{corr}}(10) = (2.36218 \\times 10^{-3}) \\times c = (2.36218 \\times 10^{-3}) \\times (2.99792458 \\times 10^{5} \\text{ km/s}) = 708.156 \\text{ km/s}$.\n\nThe residual systematic due to early-time tapering is estimated as:\n$$\n|\\;v_{\\mathrm{corr}}(T_{1}) - v_{\\mathrm{corr}}(T_{2})\\;| = |822.698 - 708.156| \\text{ km/s} = 114.542 \\text{ km/s}\n$$\nThe corrected recoil velocity $v_{\\mathrm{corr}}(T_{2})$ in kilometers per second is $708.156$ km/s. The problem asks for this value rounded to four significant figures, which is $708.2$ km/s.",
            "answer": "$$\n\\boxed{708.2}\n$$"
        }
    ]
}