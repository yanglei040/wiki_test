{
    "hands_on_practices": [
        {
            "introduction": "This practice focuses on the temporal aspect of AMR, where different grid resolutions demand different time step sizes for stability. You will apply the Courant-Friedrichs-Lewy (CFL) condition to a multi-level hierarchy to determine the maximum stable time step for each level. The core task in this exercise () is to then design a valid subcycling scheme, ensuring all levels advance stably while remaining synchronized.",
            "id": "3503472",
            "problem": "Consider a one-dimensional explicit finite-volume solver for a hyperbolic conservation law in a computational astrophysics simulation employing Adaptive Mesh Refinement (AMR). The mesh hierarchy consists of three levels: a coarse level $\\ell = 0$, a finer level $\\ell = 1$ refined by factor $r_{1} = 3$ relative to level $\\ell = 0$, and a finest level $\\ell = 2$ refined by factor $r_{2} = 2$ relative to level $\\ell = 1$. The coarse-level spatial step is $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters, so that $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$. The maximum characteristic speeds (the largest absolute values of eigenvalues of the flux Jacobian) resolved on each level are $a_{0} = 2.0 \\times 10^{7}$ meters per second on level $\\ell = 0$, $a_{1} = 3.3 \\times 10^{7}$ meters per second on level $\\ell = 1$, and $a_{2} = 4.0 \\times 10^{7}$ meters per second on level $\\ell = 2$. The Courant–Friedrichs–Lewy (CFL) number is $C_{\\mathrm{CFL}} = 0.45$.\n\nUsing the Courant–Friedrichs–Lewy stability requirement appropriate to explicit finite-volume discretizations of hyperbolic systems, first compute the allowable time step on each AMR level, denoted $\\Delta t_{\\ell}^{\\max}$ for $\\ell \\in \\{0,1,2\\}$. Then, suppose the coarse level advances by one time step of length $\\Delta t_{0} = \\Delta t_{0}^{\\max}$. Implement level-synchronous subcycling on finer levels by choosing integers $n_{1}$ and $n_{2}$ such that level $\\ell = 1$ takes $n_{1}$ substeps and level $\\ell = 2$ takes $n_{2}$ substeps over the single coarse-level advance, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ and $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$, and with $n_{2}$ being a positive integer multiple of $n_{1}$ to ensure nested synchronization. Among all admissible choices, select the minimal $n_{1}$ and the minimal multiple $n_{2}$ that satisfy these constraints.\n\nDefine the synchronization times within the interval $[0,\\Delta t_{0}]$ as the set of times at which all finer levels have simultaneously completed an integer number of their substeps and thus can perform flux correction with their parent level; under the above constraint that $n_{2}$ is a multiple of $n_{1}$, these are the level $\\ell = 1$ substep boundaries. List these times, including the start and end of the coarse-level step. Express all time quantities in seconds.\n\nProvide, in order, the triple $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$, the actual subcycled time steps $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$, and the ordered synchronization times $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$ over one coarse-level step, as a single row in your final answer. No rounding is required.",
            "solution": "The user has provided a problem in computational astrophysics concerning time-stepping in an Adaptive Mesh Refinement (AMR) simulation. The problem requires the calculation of time steps based on the Courant-Friedrichs-Lewy (CFL) stability condition and the determination of subcycling parameters and synchronization times.\n\nThe problem is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- AMR levels: $\\ell \\in \\{0, 1, 2\\}$.\n- Refinement factor from level $\\ell=0$ to $\\ell=1$: $r_{1} = 3$.\n- Refinement factor from level $\\ell=1$ to $\\ell=2$: $r_{2} = 2$.\n- Coarse-level spatial step: $\\Delta x_{0} = 9.6 \\times 10^{9}$ meters.\n- Spatial step relations: $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ and $\\Delta x_{2} = \\Delta x_{1}/r_{2}$.\n- Maximum characteristic speeds on each level: $a_{0} = 2.0 \\times 10^{7}$ m/s, $a_{1} = 3.3 \\times 10^{7}$ m/s, $a_{2} = 4.0 \\times 10^{7}$ m/s.\n- Courant-Friedrichs-Lewy (CFL) number: $C_{\\mathrm{CFL}} = 0.45$.\n- Coarse-level time step for the advance: $\\Delta t_{0} = \\Delta t_{0}^{\\max}$.\n- Subcycling constraints:\n  - Level $\\ell=1$ takes $n_{1}$ substeps, with $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$.\n  - Level $\\ell=2$ takes $n_{2}$ substeps, with $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$.\n- Synchronization constraint: $n_{2}$ is a positive integer multiple of $n_{1}$.\n- Minimality constraint: $n_{1}$ is the minimal integer satisfying its constraint, and $n_{2}$ is the minimal multiple of $n_{1}$ satisfying its constraint.\n- Synchronization times: The boundaries of the level $\\ell=1$ substeps within the coarse-level step interval $[0, \\Delta t_{0}]$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Groundedness**: The problem is based on the CFL condition, a fundamental principle for the stability of explicit numerical methods for hyperbolic equations. AMR with subcycling is a standard, scientifically valid technique in computational fluid dynamics and astrophysics. The problem is firmly grounded in established numerical analysis.\n- **Well-Posedness**: All necessary parameters ($\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$) are provided. The constraints on the subcycling integers ($n_1, n_2$) are clearly defined and lead to a unique, minimal solution. The problem is self-contained and mathematically well-posed.\n- **Objectivity**: The problem is formulated using precise, unambiguous mathematical terms and physical quantities. It is free from subjective language.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, well-posed, and objective. A complete solution will be provided.\n\n### Solution\n\nThe solution proceeds in several steps:\n1.  Compute the spatial step size $\\Delta x_{\\ell}$ for each level $\\ell$.\n2.  Compute the maximum allowable time step $\\Delta t_{\\ell}^{\\max}$ for each level using the CFL condition.\n3.  Determine the integer subcycling numbers $n_{1}$ and $n_{2}$ that satisfy the given constraints.\n4.  Calculate the actual time steps $\\Delta t_{\\ell}$ used for the subcycled advance.\n5.  List the synchronization times over one coarse-level step.\n\n**1. Spatial Step Sizes**\nThe spatial step sizes for the finer levels are determined by the given refinement factors.\n- Level $\\ell=0$: $\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=1$: $\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{m}$.\n- Level $\\ell=2$: $\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{m}$.\n\n**2. Maximum Allowable Time Steps**\nThe CFL condition for a one-dimensional explicit finite-volume scheme states that for stability, the time step $\\Delta t$ must satisfy $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$, where $a$ is the maximum characteristic speed. The maximum allowable time step on level $\\ell$ is therefore $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$.\n\n- Level $\\ell=0$:\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- Level $\\ell=1$:\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- Level $\\ell=2$:\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\nThe first requested set of values is $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$.\n\n**3. Subcycling Integers**\nThe coarse level advances by one step of size $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{s}$.\nFor level $\\ell=1$, the number of substeps $n_{1}$ must satisfy $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$. This implies:\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\nSince $n_{1}$ must be an integer, the minimal value for $n_{1}$ is $\\lceil 4.95 \\rceil = 5$.\n\nFor level $\\ell=2$, the number of substeps $n_{2}$ must satisfy $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$. This implies:\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\nAdditionally, $n_{2}$ must be a positive integer multiple of $n_{1}=5$. We must find the smallest multiple of $5$ that is greater than or equal to $12$. The relevant multiples of $5$ are $5, 10, 15, \\dots$. The smallest such multiple is $15$.\nThus, the selected subcycling integers are $n_{1} = 5$ and $n_{2} = 15$.\n\n**4. Actual Subcycled Time Steps**\nThe actual time steps for each level are calculated based on the subcycling integers.\n- Level $\\ell=0$: $\\Delta t_{0} = 216 \\, \\text{s}$.\n- Level $\\ell=1$: $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{s}$.\n- Level $\\ell=2$: $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$.\nThe second requested set of values is $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$.\n\n**5. Synchronization Times**\nThe synchronization times are the boundaries of the level $\\ell=1$ substeps. Since level $\\ell=1$ takes $n_{1}=5$ substeps of duration $\\Delta t_{1} = 43.2 \\, \\text{s}$, the synchronization times $t_j$ are given by $t_j = j \\cdot \\Delta t_{1}$ for $j=0, 1, \\dots, 5$.\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{s}$\nThe third requested set of values is $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$.\n\nThese three sets of results are combined into a single row matrix for the final answer.\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 216 & \\frac{480}{11} & 18 & 216 & 43.2 & 14.4 & 0 & 43.2 & 86.4 & 129.6 & 172.8 & 216 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "When a region is flagged for higher resolution, a new fine grid must be created and populated with data interpolated from its coarser parent grid. This process, known as prolongation, must be done carefully to maintain physical accuracy and avoid introducing numerical artifacts. This hands-on coding exercise () challenges you to implement a conservative, piecewise-linear reconstruction scheme using slope limiters, which are essential for sharply capturing features like shocks or contact discontinuities without creating spurious oscillations.",
            "id": "3503480",
            "problem": "Consider a one-dimensional finite volume representation of density for a compressible flow with a contact discontinuity in a computational astrophysics context. Adaptive Mesh Refinement (AMR) aims to construct fine-level initial data from coarse-level cell averages while preserving conservation and avoiding spurious extrema. The fundamental base is the finite volume definition of a cell average and Total Variation Diminishing (TVD) reconstruction with slope limiters.\n\nLet the coarse-level grid be uniform with cell centers at $x_i$ and width $\\Delta x$. The coarse-level cell-average density is $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$. For prolongation, each coarse cell $i$ is subdivided into $r$ fine subcells indexed by $j \\in \\{0,1,\\dots,r-1\\}$, each of width $\\Delta x / r$. Use a piecewise linear reconstruction within each coarse cell $i$,\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\nwhere $s_i$ is a limited slope computed from neighboring coarse averages to enforce the TVD property. Define backward and forward differences\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\nand the following slope limiters:\n- Minmod limiter: $\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|), & ab > 0 \\\\ 0, & \\text{otherwise.}\\end{cases}$\n- Monotonized Central (MC) limiter: $s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$ where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $ab>0$ and $ac>0$, and $0$ otherwise.\n- Van Leer limiter: $s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+}, & \\Delta_- \\Delta_+ > 0 \\\\ 0, & \\text{otherwise.}\\end{cases}$.\n\nAt domain boundaries, where a neighbor is unavailable, set $s_i = 0$ to remain conservative. The subcell-average density for subcell $j$ inside coarse cell $i$ is\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\nFor the piecewise linear $\\rho_i(x)$ above, the subcell average equals the value at the subcell midpoint, yielding\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\nTo avoid spurious extrema at contact discontinuities, impose a bound-preserving clipping for each coarse cell $i$ with local bounds\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\nusing only available neighbors at boundaries. Enforce\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\nImplement a program that:\n1. Computes limited slopes $s_i$ according to a specified limiter.\n2. Computes fine-level subcell averages $\\bar{\\rho}_{i,j}$ for a given refinement ratio $r$ using the formula above.\n3. Applies the bound-preserving clipping per coarse cell.\n4. Outputs the refined subcell averages for each test case as a list of floats.\n\nAll densities are in dimensionless code units; no physical unit conversion is required. Angles are not involved. The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of the refined cell-average densities for the corresponding test case, with no spaces. For example: $[[a_1,a_2,\\dots],[b_1,b_2,\\dots]]$.\n\nUse the following test suite, designed to cover smooth behavior, sharp contact discontinuity, oscillatory patterns, and boundary effects:\n- Test $1$ (smooth monotone increase, Minmod, $r=2$): coarse averages $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$.\n- Test $2$ (contact discontinuity, MC, $r=2$): coarse averages $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$.\n- Test $3$ (oscillatory pattern, Van Leer, $r=4$): coarse averages $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$.\n- Test $4$ (isolated jump with symmetric neighbors, Minmod, $r=2$): coarse averages $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$.\n\nFor each test case, the output should be the flattened fine-level list $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$ in the specified format. The final output must be a single line of the form $[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list},\\text{case4\\_list}]$ with no spaces anywhere.",
            "solution": "The problem statement is assessed as valid. It presents a well-defined computational task grounded in established principles of numerical methods for fluid dynamics, specifically concerning Adaptive Mesh Refinement (AMR). The provided formulas for piecewise linear reconstruction, slope limiters, and subcell averaging are standard and correct. The problem is self-contained, with all necessary data and boundary conditions specified, enabling a unique solution for each test case.\n\nThe procedure to prolong coarse-level cell-average densities, $\\bar{\\rho}_i$, to a refined grid with a refinement ratio $r$ involves three primary steps: slope calculation, subcell average computation, and bound-preserving clipping.\n\n### 1. Limited Slope Calculation\nFor each coarse cell $i$, a slope $s_i$ is computed to define a piecewise linear reconstruction, $\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$, where $x_i$ is the center of cell $i$ and $\\Delta x$ is its width. To prevent the introduction of spurious oscillations near sharp features (a property known as Total Variation Diminishing or TVD), the slope $s_i$ is limited based on the local data.\n\nThe calculation depends on the cell's position:\n-   **Boundary Cells**: For the first ($i=0$) and last ($i=N-1$) cells in the domain, a full set of neighbors is unavailable. To maintain a conservative and simple treatment, the slope is set to zero, i.e., $s_0 = 0$ and $s_{N-1} = 0$. This corresponds to a piecewise constant reconstruction at the boundaries.\n-   **Interior Cells**: For any interior cell $i$, the slope is determined by its immediate neighbors. We first compute the backward and forward differences:\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    These differences are then passed to a slope limiter function. The problem specifies three such limiters:\n\n    1.  **Minmod Limiter**: This is the most dissipative limiter, which strongly suppresses oscillations. The slope is given by:\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|), & \\Delta_- \\Delta_+ > 0 \\\\ 0, & \\text{otherwise}\\end{cases}\n        $$\n        The slope is non-zero only if the data is locally monotonic (i.e., $\\Delta_-$ and $\\Delta_+$ have the same sign). At local extrema, the slope is zero.\n\n    2.  **Monotonized Central (MC) Limiter**: This limiter is designed to be more accurate in smooth regions than Minmod. It is defined using a three-argument minmod function:\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        where $\\mathrm{mm}_3(a,b,c)$ returns $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$ if $a, b, c$ all have the same sign, and $0$ otherwise. This limiter considers the central difference slope, $(\\Delta_- + \\Delta_+)/2$, and limits it by twice the one-sided differences.\n\n    3.  **Van Leer Limiter**: This limiter offers a smooth transition between the one-sided differences and is known for providing good resolution of contact discontinuities. It is the harmonic mean of the two differences:\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+}, & \\Delta_- \\Delta_+ > 0 \\\\ 0, & \\text{otherwise}\\end{cases}\n        $$\n\n### 2. Subcell Average Prolongation\nOnce the slope $s_i$ for each coarse cell $i$ is known, we can determine the average density, $\\bar{\\rho}_{i,j}$, for each of the $r$ subcells within it. A subcell is indexed by $j \\in \\{0, 1, \\dots, r-1\\}$. The average value of a linear function over an interval is equal to the function's value at the interval's midpoint. This simplifies the integral definition to an algebraic one. The midpoint of subcell $j$ in coarse cell $i$ is offset from the coarse cell center $x_i$ by a distance factor. This leads to the formula:\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\nwhere the coefficient $c_j$ depends only on the subcell index $j$ and the refinement ratio $r$:\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\nThese coefficients represent the normalized distance of each subcell's center from the parent cell's center. For example, for $r=2$, we have $c_0 = -0.25$ and $c_1 = 0.25$.\n\n### 3. Bound-Preserving Clipping\nThe TVD slope limiters are designed to prevent the reconstructed point values at cell interfaces from creating new extrema. However, to strictly enforce that the new *cell averages* also do not create new local extrema, an additional clipping step is applied. For each coarse cell $i$, we define local bounds based on the cell average itself and its available neighbors:\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\nFor a boundary cell $i=0$, the neighborhood is $\\{0, 1\\}$. For an interior cell, it is $\\{i-1, i, i+1\\}$.\n\nEach computed subcell average $\\bar{\\rho}_{i,j}$ is then forced to lie within these bounds:\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\nThis ensures that the refined data field remains locally bounded by the original coarse data, which is crucial for stability and physical realism, especially at contact discontinuities.\n\n### Example Walkthrough: Test Case 1\n-   **Input**: Coarse averages $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$, Limiter: Minmod, $r=2$.\n-   **Slopes**:\n    -   $s_0 = 0$ (boundary).\n    -   $i=1$: $\\Delta_- = 1.1-1.0=0.1$, $\\Delta_+ = 1.2-1.1=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_1=0.1$.\n    -   $i=2$: $\\Delta_- = 1.2-1.1=0.1$, $\\Delta_+ = 1.3-1.2=0.1$. $\\mathrm{mm}(0.1, 0.1) = 0.1$. So, $s_2=0.1$.\n    -   $s_3 = 0$ (boundary).\n    -   The slope vector is $s = [0, 0.1, 0.1, 0]$.\n-   **Subcell Averages ($r=2 \\implies c_0=-0.25, c_1=0.25$)**:\n    -   $i=0$: $\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$; $\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$.\n    -   $i=1$: $\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$; $\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$.\n    -   $i=2$: $\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$; $\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$.\n    -   $i=3$: $\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$; $\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$.\n-   **Clipping**:\n    -   $i=0$: Bounds are $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$. Values $[1.0, 1.0]$ are within bounds.\n    -   $i=1$: Bounds are $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$. Values $[1.075, 1.125]$ are within bounds.\n    -   $i=2$: Bounds are $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$. Values $[1.175, 1.225]$ are within bounds.\n    -   $i=3$: Bounds are $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$. Values $[1.3, 1.3]$ are within bounds.\n    -   In this case, the clipping step does not change any values, as the Minmod limiter already ensures the reconstruction is non-oscillatory.\n-   **Final Result**: The flattened list of fine-cell averages is $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$.",
            "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The efficiency of AMR hinges on a smart strategy for deciding when to refine or derefine the grid. A naive criterion applied to noisy data can lead to 'grid thrashing'—the wasteful cycle of rapidly creating and destroying a refined patch. This advanced exercise () delves into the design of a robust adaptation trigger by analyzing the use of hysteresis, where separate thresholds for refinement and derefinement are used to filter out noise and prevent inefficient grid management.",
            "id": "3503452",
            "problem": "In an Adaptive Mesh Refinement (AMR) hydrodynamics solver for computational astrophysics, a scalar refinement indicator $I_t$ is evaluated at discrete time steps $t \\in \\mathbb{Z}$. A cell is refined if $I_t \\ge \\theta_r$ and derefined if $I_t \\le \\theta_d$, where $\\theta_r  \\theta_d$ are fixed thresholds that implement hysteresis. Let the cell’s underlying, slowly varying signal over the next $3$ time steps be modeled by a constant $S$ (representing the true smoothness or feature magnitude), and let measurement and discretization noise be modeled by a stationary, zero-mean Gaussian first-order autoregressive process (AR($1$)) $X_t$ with variance $\\sigma^2$ and lag-$1$ correlation coefficient $\\rho \\in (-1,1)$, so that\n$$\nI_t = S + X_t, \\quad X_{t+1} = \\rho\\, X_t + \\eta_{t+1}, \\quad \\eta_{t+1} \\sim \\mathcal{N}(0,(1-\\rho^2)\\sigma^2), \\quad \\eta_{t+1} \\text{ independent of } X_t.\n$$\nAssume that at time $t$ the cell is coarse (i.e., not currently refined). Define a refinement thrashing event as the occurrence of a refine decision at time $t+1$ followed immediately by a derefine decision at time $t+2$ due solely to noise fluctuations while the true signal $S$ lies between thresholds, $S \\in [\\theta_d,\\theta_r]$. For purposes of worst-case design, adopt the standard symmetry assumption that the most thrash-prone mean lies at the midpoint $S^\\star = (\\theta_r+\\theta_d)/2$.\n\nLet the hysteresis gap be $h = \\theta_r - \\theta_d  0$. For a user-prescribed tolerance $\\delta \\in (0,1/2)$, derive a sufficient condition on $h$ that guarantees that, for any correlation $\\rho \\in (-1,1)$ and with $S=S^\\star$, the probability of the two-step thrashing event\n$$\n\\{I_{t+1} \\ge \\theta_r,\\; I_{t+2} \\le \\theta_d\\}\n$$\nis at most $\\delta$. Determine the minimal hysteresis gap $h_{\\min}$ that ensures this bound uniformly over all $\\rho \\in (-1,1)$, expressed in closed form using the standard normal cumulative distribution function $\\Phi$ and its inverse $\\Phi^{-1}$. Provide your final expression for $h_{\\min}$, and do not approximate or round your result. Express the final answer symbolically with no units.",
            "solution": "The user has provided a valid problem statement. All listed givens are clear, self-contained, and scientifically sound. The problem is well-posed and objective. We may therefore proceed with a formal solution.\n\nThe problem asks for the minimal hysteresis gap $h_{\\min}$ that ensures the probability of a refinement thrashing event is no more than a given tolerance $\\delta$, under a worst-case signal assumption and uniformly over all possible temporal correlations $\\rho \\in (-1,1)$.\n\nThe thrashing event is defined as a refinement at time step $t+1$ followed by a derefinement at time step $t+2$. This corresponds to the joint event $\\{I_{t+1} \\ge \\theta_r, \\; I_{t+2} \\le \\theta_d\\}$. The indicator variable $I_t$ is given by the sum of a constant true signal $S$ and a noise term $X_t$, so $I_t = S + X_t$.\n\nThe problem specifies using the worst-case signal value $S = S^\\star = (\\theta_r+\\theta_d)/2$. Substituting this into the inequalities for the thrashing event, we get:\n$$\n\\left\\{ \\frac{\\theta_r+\\theta_d}{2} + X_{t+1} \\ge \\theta_r, \\quad \\frac{\\theta_r+\\theta_d}{2} + X_{t+2} \\le \\theta_d \\right\\}\n$$\nWe can simplify these two inequalities. The first inequality becomes:\n$$\nX_{t+1} \\ge \\theta_r - \\frac{\\theta_r+\\theta_d}{2} = \\frac{2\\theta_r - \\theta_r - \\theta_d}{2} = \\frac{\\theta_r - \\theta_d}{2}\n$$\nThe second inequality becomes:\n$$\nX_{t+2} \\le \\theta_d - \\frac{\\theta_r+\\theta_d}{2} = \\frac{2\\theta_d - \\theta_r - \\theta_d}{2} = \\frac{\\theta_d - \\theta_r}{2}\n$$\nThe hysteresis gap is defined as $h = \\theta_r - \\theta_d$. Using this definition, the event can be expressed purely in terms of the noise process $X_t$ and the gap $h$:\n$$\n\\{ X_{t+1} \\ge \\frac{h}{2}, \\quad X_{t+2} \\le -\\frac{h}{2} \\}\n$$\nWe are interested in the probability of this event, which we denote $P_{\\text{thrash}}$.\n$$\nP_{\\text{thrash}}(h, \\rho, \\sigma) = P\\left( X_{t+1} \\ge \\frac{h}{2}, \\; X_{t+2} \\le -\\frac{h}{2} \\right)\n$$\nThe noise $X_t$ is a stationary, zero-mean Gaussian AR($1$) process with variance $\\sigma^2$ and lag-$1$ correlation $\\rho$. This implies that for any time $t$, $X_t \\sim \\mathcal{N}(0, \\sigma^2)$. The joint distribution of $(X_{t+1}, X_{t+2})$ is a bivariate normal distribution. The parameters of this distribution are:\n- Mean vector: $[\\mu_1, \\mu_2] = [E[X_{t+1}], E[X_{t+2}]] = [0, 0]$.\n- Covariance matrix: The variances are $Var(X_{t+1}) = Var(X_{t+2}) = \\sigma^2$. The covariance is $Cov(X_{t+1}, X_{t+2}) = E[X_{t+1}X_{t+2}]$. From the AR($1$) definition, $X_{t+2} = \\rho X_{t+1} + \\eta_{t+2}$. Thus, $Cov(X_{t+1}, X_{t+2}) = E[X_{t+1}(\\rho X_{t+1} + \\eta_{t+2})] = \\rho E[X_{t+1}^2] + E[X_{t+1}\\eta_{t+2}]$. Since $\\eta_{t+2}$ is independent of $X_{t+1}$ and has zero mean, $E[X_{t+1}\\eta_{t+2}]=0$. Therefore, $Cov(X_{t+1}, X_{t+2}) = \\rho E[X_{t+1}^2] = \\rho \\sigma^2$.\n\nSo, $(X_{t+1}, X_{t+2})$ is drawn from a bivariate normal distribution with mean $[0, 0]$ and covariance matrix $\\Sigma_X = \\begin{pmatrix} \\sigma^2  \\rho\\sigma^2 \\\\ \\rho\\sigma^2  \\sigma^2 \\end{pmatrix}$.\n\nTo make the probability calculation independent of $\\sigma$, we standardize the random variables. Let $Z_1 = X_{t+1}/\\sigma$ and $Z_2 = X_{t+2}/\\sigma$. The vector $(Z_1, Z_2)$ follows a standard bivariate normal distribution with mean $[0, 0]$ and correlation coefficient $\\rho$. The inequalities become:\n$$\nP_{\\text{thrash}} = P\\left( \\sigma Z_1 \\ge \\frac{h}{2}, \\; \\sigma Z_2 \\le -\\frac{h}{2} \\right) = P\\left( Z_1 \\ge \\frac{h}{2\\sigma}, \\; Z_2 \\le -\\frac{h}{2\\sigma} \\right)\n$$\nLet's define a normalized hysteresis gap $k = h/(2\\sigma)$. The probability is a function of $k$ and $\\rho$:\n$$\np(k, \\rho) = P(Z_1 \\ge k, \\; Z_2 \\le -k)\n$$\nThe problem requires that this probability is at most $\\delta$ for any $\\rho \\in (-1,1)$. This means we must satisfy the condition:\n$$\n\\sup_{\\rho \\in (-1,1)} p(k, \\rho) \\le \\delta\n$$\nTo find the supremum, we analyze how $p(k, \\rho)$ changes with $\\rho$. Let's consider the new random variables $Y_1 = Z_1$ and $Y_2 = -Z_2$. The vector $(Y_1, Y_2)$ is also bivariate normal with zero mean and unit variances. Its correlation is $Cov(Y_1, Y_2) = Cov(Z_1, -Z_2) = -Cov(Z_1, Z_2) = -\\rho$. The probability can be rewritten as:\n$$\np(k, \\rho) = P(Y_1 \\ge k, \\; Y_2 \\ge k)\n$$\nAccording to Slepian's inequality for Gaussian random vectors, for given thresholds, the probability that all components exceed their respective thresholds is a monotonically increasing function of the pairwise correlations. In our case, $P(Y_1 \\ge k, \\; Y_2 \\ge k)$ is an increasing function of the correlation $Cov(Y_1, Y_2) = -\\rho$.\nSince the probability is increasing with $-\\rho$, it must be decreasing with $\\rho$.\n\nTherefore, the supremum of $p(k, \\rho)$ over $\\rho \\in (-1,1)$ is achieved as $\\rho$ approaches the lower bound of its domain, i.e., $\\rho \\to -1$.\n$$\n\\sup_{\\rho \\in (-1,1)} p(k, \\rho) = \\lim_{\\rho \\to -1^+} P(Z_1 \\ge k, \\; Z_2 \\le -k)\n$$\nAs $\\rho \\to -1$, the joint distribution of $(Z_1, Z_2)$ becomes singular and concentrates on the line $Z_2 = -Z_1$. In this limit, the event $\\{Z_1 \\ge k, \\; Z_2 \\le -k\\}$ becomes equivalent to the event $\\{Z_1 \\ge k, \\; -Z_1 \\le -k\\}$. The second inequality, $-Z_1 \\le -k$, is equivalent to $Z_1 \\ge k$. Thus, the joint event simplifies to just $\\{Z_1 \\ge k\\}$. The limiting probability is:\n$$\n\\lim_{\\rho \\to -1^+} p(k, \\rho) = P(Z_1 \\ge k)\n$$\nwhere $Z_1 \\sim \\mathcal{N}(0,1)$ is a standard normal random variable.\n\nThe condition on $k$ becomes $P(Z_1 \\ge k) \\le \\delta$. Let $\\Phi(z)$ be the cumulative distribution function (CDF) of the standard normal distribution. Then $P(Z_1 \\ge k) = 1 - P(Z_1  k) = 1 - \\Phi(k)$. The inequality is:\n$$\n1 - \\Phi(k) \\le \\delta \\implies \\Phi(k) \\ge 1 - \\delta\n$$\nSince $\\Phi$ is a monotonically increasing function, we can apply its inverse, $\\Phi^{-1}$, to both sides of the inequality:\n$$\nk \\ge \\Phi^{-1}(1 - \\delta)\n$$\nThe problem asks for the minimal hysteresis gap $h_{\\min}$ that satisfies this condition. This corresponds to the minimal value of $k$, which is $k_{\\min} = \\Phi^{-1}(1-\\delta)$. Since we are given $\\delta \\in (0, 1/2)$, we have $1-\\delta \\in (1/2, 1)$, and thus $k_{\\min} = \\Phi^{-1}(1-\\delta)  0$. This is consistent with $h  0$ and $\\sigma  0$.\n\nFinally, we translate this minimal normalized gap $k_{\\min}$ back to the minimal physical gap $h_{\\min}$ using the relation $k = h/(2\\sigma)$:\n$$\n\\frac{h_{\\min}}{2\\sigma} = k_{\\min} = \\Phi^{-1}(1 - \\delta)\n$$\nSolving for $h_{\\min}$, we obtain the final expression:\n$$\nh_{\\min} = 2\\sigma \\Phi^{-1}(1 - \\delta)\n$$\nThis is the sufficient condition on the hysteresis gap $h$ (specifically, the minimum required value) to ensure that the thrashing probability is bounded by $\\delta$, uniformly for all possible noise correlations $\\rho \\in (-1,1)$.",
            "answer": "$$\\boxed{2\\sigma \\Phi^{-1}(1 - \\delta)}$$"
        }
    ]
}