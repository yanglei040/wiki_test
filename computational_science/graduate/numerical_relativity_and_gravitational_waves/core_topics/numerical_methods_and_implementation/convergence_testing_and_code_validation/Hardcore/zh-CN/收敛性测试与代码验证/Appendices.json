{
    "hands_on_practices": [
        {
            "introduction": "一个数值代码的可靠性始于其核心算法的稳健性。这个练习将我们的注意力集中在时间演化算法上，这是任何演化方程求解器的关键组成部分。我们将通过一个简化的、但能代表广义谐和（GH）系统中约束传播行为的平流-阻尼方程，来检验强稳定性保持（SSP）龙格-库塔（RK）格式的两个基本属性：线性和稳定性和时间收敛阶 。通过确定最大允许的CFL数并验证经验收敛阶，我们可以为在更复杂的物理问题中使用这些时间积分器建立起基础的信任。",
            "id": "3470417",
            "problem": "考虑一个用于数值相对论中分析引力波时空的约束阻尼广义谐波 (GH) 演化的简化一维模型。在该模型中，规范约束的传播由周期性域上的标量平流-阻尼方程表示，该方程通过显式强稳定性保持龙格-库塔 (SSP RK) 格式进行时间演化。目标是双重的：就业已半离散化的算子的线性稳定性而言，比较不同 SSP RK 格式的容许 Courant-Friedrichs-Lewy (CFL) 数；以及在保持空间离散化固定的情况下，通过时间步长加密来验证解的时间收敛性。\n\n基本基础：\n- 模型偏微分方程 (PDE) 为\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = -\\gamma\\,u(x,t),\n$$\n其中 $u$ 是标量约束代理，$v>0$ 是平流速度，$\\gamma\\ge 0$ 是约束阻尼参数。\n- 直线法半离散化在周期性网格上对空间导数使用一阶迎风差分。对于区间 $[0,L)$ 上间距为 $\\Delta x = L/N$ 的 $N$ 个网格点，半离散算子作用于网格函数 $u_i$ 的形式为\n$$\n\\left(\\mathcal{L}u\\right)_i = -\\,v\\,\\frac{u_i - u_{i-1}}{\\Delta x} - \\gamma\\,u_i,\\quad i=0,1,\\dots,N-1,\n$$\n其中周期性索引为 $u_{-1}\\equiv u_{N-1}$。这产生一个循环矩阵，其特征值由迎风算子的离散傅里叶符号经阻尼平移后给出：\n$$\n\\lambda_m = -\\gamma - v\\,\\frac{1 - e^{-\\,\\mathrm{i}\\,\\theta_m}}{\\Delta x},\\quad \\theta_m = \\frac{2\\pi m}{N},\\quad m=0,1,\\dots,N-1.\n$$\n- 一个显式 $s$ 级强稳定性保持龙格-库塔 (SSP RK) 格式为线性测试问题 $\\dot{y}=\\lambda y$ 定义一个多项式稳定性函数 $R(z)$，使得一步推进为 $y^{n+1} = R(\\Delta t\\,\\lambda)\\,y^n$。时间步进方法对于半离散算子的线性稳定性要求为\n$$\n\\max_{m\\in\\{0,\\dots,N-1\\}} \\left| R\\left(\\Delta t\\,\\lambda_m\\right) \\right| \\le 1.\n$$\n相关的 CFL 数为 $\\nu = v\\,\\Delta t/\\Delta x$。\n\n任务：\n1. 对于给定的 $(L,v,\\gamma,N)$，实现上述指定的周期性半离散算子 $\\mathcal{L}$，并通过离散傅里叶符号计算其谱 $\\{\\lambda_m\\}$。\n2. 对于二阶二级强稳定性保持龙格-库塔方法 (SSP RK$(2,2)$) 和三阶三级强稳定性保持龙格-库塔方法 (SSP RK$(3,3)$)，数值确定最大容许 CFL 数 $\\nu_{\\max}$，使得线性稳定性要求对 $\\mathcal{L}$ 的整个谱都成立。你必须在 $\\Delta t$ 上进行搜索，并对所有模式 $m$ 验证界限 $\\left|R\\left(\\Delta t\\,\\lambda_m\\right)\\right|\\le 1$；然后报告 $\\nu_{\\max} = v\\,\\Delta t_{\\max}/\\Delta x$。\n3. 使用 SSP RK$(2,2)$ 和 SSP RK$(3,3)$，在固定空间分辨率下，通过时间步长加密来验证时间收敛性。对光滑初始数据，将 PDE 从 $t=0$ 演化到 $t=T$\n$$\nu(x,0) = \\sin\\!\\left(\\frac{2\\pi x}{L}\\right),\n$$\n并将数值解与精确解进行比较\n$$\nu(x,t) = e^{-\\gamma t}\\,\\sin\\!\\left(\\frac{2\\pi}{L}\\left(x - v\\,t\\right)\\right).\n$$\n计算 $t=T$ 时的离散 $\\ell_2$ 误差，\n$$\nE(\\Delta t) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left[ u_i^{\\mathrm{num}}(T) - u^{\\mathrm{exact}}(x_i,T) \\right]^2 \\right)^{1/2}.\n$$\n使用至少四个时间步长 $\\Delta t$（步长近似减半），并通过对关系式 $\\log E(\\Delta t) \\approx \\alpha + p\\,\\log(\\Delta t)$ 进行最小二乘拟合，来估计每个格式的经验时间阶 $p$。报告 SSP RK$(2,2)$ 和 SSP RK$(3,3)$ 的斜率 $p$。\n\n单位：\n- 使用与相对论性代码一致的无量纲单位，即设置光速 $c=1$。所有量均视为无量纲。输出中不需要物理单位。\n\n角度单位：\n- 三角函数中的所有角度均以弧度为单位。\n\n测试套件：\n- 为以下三组参数集计算 $\\nu_{\\max}$：\n  - 案例 1：$L=1$, $v=1$, $\\gamma=0$, $N=128$。\n  - 案例 2：$L=1$, $v=1$, $\\gamma=0.1$, $N=128$。\n  - 案例 3：$L=1$, $v=1$, $\\gamma=2.0$, $N=128$。\n- 为以下情况验证收敛性：\n  - 收敛性案例：$L=1$, $v=1$, $\\gamma=0.5$, $N=512$, $T=0.5$，每个格式的时间步长加密对应于 CFL 数 $\\nu\\in\\{0.1,\\,0.05,\\,0.025,\\,0.0125\\}$。\n\n答案规格：\n- 对于三个稳定性案例中的每一个，返回为 SSP RK$(2,2)$ 和 SSP RK$(3,3)$ 找到的最大 CFL 数。\n- 对于收敛性案例，以浮点数形式返回 SSP RK$(2,2)$ 和 SSP RK$(3,3)$ 的经验时间阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[\\nu_{\\max}^{(2,2)}\\text{(案例 1)},\\ \\nu_{\\max}^{(3,3)}\\text{(案例 1)},\\ \\nu_{\\max}^{(2,2)}\\text{(案例 2)},\\ \\nu_{\\max}^{(3,3)}\\text{(案例 2)},\\ \\nu_{\\max}^{(2,2)}\\text{(案例 3)},\\ \\nu_{\\max}^{(3,3)}\\text{(案例 3)},\\ p^{(2,2)},\\ p^{(3,3)}].\n$$\n所有条目必须是浮点数。您的程序不得读取任何输入，并且必须精确打印这一单行。",
            "solution": "该问题提出了偏微分方程数值分析领域中一个明确定义的任务，特别关注与数值相对论相关的模型方程的时间积分格式的稳定性和收敛性。问题陈述在科学上是合理的、内部一致的，并包含了所有必要的信息，前提是假定读者具备所指定数值方法的标准知识。我们将进行完整的求解。\n\n分析分为三个部分：首先，概述半离散系统的性质；其次，详述用于寻找最大 Courant-Friedrichs-Lewy (CFL) 数的稳定性分析；第三，描述时间收敛性的验证。\n\n**1. 半离散系统及其谱**\n\n控制偏微分方程 (PDE) 是周期性域 $[0,L)$ 上的一维线性平流-阻尼方程：\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = -\\gamma\\,u(x,t)\n$$\n这里，$u(x,t)$ 是一个标量场，$v > 0$ 是恒定平流速度，$\\gamma \\ge 0$ 是阻尼系数。\n\n采用直线法，即首先对空间导数进行离散化，从而得到一个关于时间的常微分方程 (ODE) 组。空间域被离散化为 $N$ 个网格点 $x_i = i\\Delta x$（$i=0,\\dots,N-1$），网格间距为 $\\Delta x=L/N$。空间导数 $\\partial_x u$ 使用一阶迎风有限差分格式进行近似，选择该格式是因为平流速度 $v$ 为正。这导出了半离散系统：\n$$\n\\frac{d u_i(t)}{dt} = \\left(\\mathcal{L}u\\right)_i = -v\\,\\frac{u_i(t) - u_{i-1}(t)}{\\Delta x} - \\gamma\\,u_i(t)\n$$\n其中 $u_i(t) \\approx u(x_i, t)$，且周期性边界条件意味着 $u_{-1} \\equiv u_{N-1}$。算子 $\\mathcal{L}$ 可以用一个循环矩阵表示。\n\n循环矩阵的特征值由其离散傅里叶符号给出。对于算子 $\\mathcal{L}$，其特征值明确给出为：\n$$\n\\lambda_m = -\\gamma - v\\,\\frac{1 - e^{-\\mathrm{i}\\,\\theta_m}}{\\Delta x}, \\quad \\text{for } m = 0, 1, \\dots, N-1\n$$\n其中 $\\theta_m = \\frac{2\\pi m}{N}$。这些特征值位于复平面内。我们可以重写表达式以理解它们的几何排列：\n$$\n\\lambda_m = -\\gamma - \\frac{v}{\\Delta x} + \\frac{v}{\\Delta x}e^{-\\mathrm{i}\\,\\theta_m}\n$$\n这表明特征值 $\\{\\lambda_m\\}_{m=0}^{N-1}$ 位于复平面上的一个圆上，圆心为 $C = -\\gamma - \\frac{v}{\\Delta x}$，半径为 $R = \\frac{v}{\\Delta x}$。所有特征值都位于复平面的左半部分，因为 $\\operatorname{Re}(\\lambda_m) = -\\gamma - \\frac{v}{\\Delta x}(1-\\cos\\theta_m) \\le -\\gamma \\le 0$。\n\n**2. SSP RK 方法与线性稳定性分析**\n\nODE 组 $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$ 使用显式强稳定性保持 (SSP) 龙格-库塔 (RK) 方法进行时间积分。对于线性 ODE $\\dot{y} = \\lambda y$，RK 方法的单步推进解的形式为 $y^{n+1} = R(z) y^n$，其中 $z = \\Delta t \\lambda$，$R(z)$ 是该方法的稳定性多项式。\n\n问题指定了两种方法：\n- **SSP RK(2,2)**：二阶二级方法，稳定性多项式为 $R_{(2,2)}(z) = 1 + z + \\frac{1}{2}z^2$。\n- **SSP RK(3,3)**：三阶三级方法，稳定性多项式为 $R_{(3,3)}(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$。\n\n为使整个半离散系统稳定，时间步进方法必须对每个模式都稳定，这转化为以下条件：\n$$\n\\max_{m=0,\\dots,N-1} \\left| R\\left(\\Delta t\\,\\lambda_m\\right) \\right| \\le 1\n$$\n点集 $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ 被称为绝对稳定域。稳定性条件要求算子的缩放谱 $\\{\\Delta t \\lambda_m\\}$ 必须完全位于该区域内。\n\n任务是找到最大容许 CFL 数 $\\nu_{\\max} = v\\,\\Delta t_{\\max}/\\Delta x$。这等效于找到使稳定性条件成立的最大时间步长 $\\Delta t_{\\max}$。这是一个关于 $\\Delta t_{\\max}$ 的求根问题。找到它的一个稳健方法是就 CFL 数 $\\nu = v\\,\\Delta t/\\Delta x$ 进行二分搜索。对于给定的 $\\nu$，我们计算 $\\Delta t = \\nu \\Delta x / v$ 并检查是否 $\\max_m |R(\\Delta t\\,\\lambda_m)| \\le 1$。搜索将确定满足此标准的最大 $\\nu$ (以及 $\\Delta t$)。\n\n**3. 时间收敛性验证**\n\n第二个任务是验证数值格式在时间上达到其预期的理论收敛阶。这是通过演化一个已知的平滑初始条件，并将数值结果与精确解析解进行比较来完成的。\n\nPDE 在初始条件 $u(x,0) = \\sin(2\\pi x/L)$ 下从 $t=0$ 演化到 $t=T$。精确解给出为：\n$$\nu(x,t) = e^{-\\gamma t}\\,\\sin\\left(\\frac{2\\pi}{L}(x - vt)\\right)\n$$\n数值解 $u_i^{\\mathrm{num}}(T)$ 是通过对固定的空间分辨率 $N$ 和给定的时间步长 $\\Delta t$ 应用时间步进算法来计算的。对于 SSP RK(2,2) 和 SSP RK(3,3) 方法，一个时间步 $u^n \\to u^{n+1}$ 是通过根据各自的 Butcher 表计算中间阶段来执行的。例如，对于 SSP RK(3,3)：\n1. $k_1 = \\mathcal{L}(u^n)$\n2. $k_2 = \\mathcal{L}(u^n + \\Delta t\\,k_1)$\n3. $k_3 = \\mathcal{L}(u^n + \\frac{1}{4}\\Delta t\\,k_1 + \\frac{1}{4}\\Delta t\\,k_2)$\n4. $u^{n+1} = u^n + \\Delta t\\left(\\frac{1}{6}k_1 + \\frac{1}{6}k_2 + \\frac{2}{3}k_3\\right)$\n\n数值解的误差在最终时间 $T$ 使用离散 $\\ell_2$ 范数进行度量：\n$$\nE(\\Delta t) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left[ u_i^{\\mathrm{num}}(T) - u^{\\mathrm{exact}}(x_i,T) \\right]^2 \\right)^{1/2}\n$$\n对于一个 $p$ 阶方法，误差预期行为如 $E(\\Delta t) \\propto (\\Delta t)^p$，假设时间步长足够小，以至于时间误差主导空间误差。这种关系可以表示为 $\\log E(\\Delta t) \\approx \\alpha + p\\,\\log(\\Delta t)$。经验收敛阶 $p$ 是通过计算一系列加密时间步长（本例中为四个 $\\Delta t$ 值）下的误差 $E(\\Delta t)$，并对 $(\\log(\\Delta t), \\log(E))$ 数据进行线性最小二乘拟合来估计的。所得直线的斜率即为估计的阶 $p$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem: calculates maximum CFL numbers for stability and\n    validates temporal convergence orders for two SSP RK schemes.\n    \"\"\"\n\n    # --- Part 1: Stability Analysis ---\n\n    def R_ssp_rk22(z):\n        \"\"\"Stability polynomial for SSP RK(2,2).\"\"\"\n        return 1 + z + 0.5 * z**2\n\n    def R_ssp_rk33(z):\n        \"\"\"Stability polynomial for SSP RK(3,3).\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6.0) * z**3\n\n    def is_stable(nu, L, v, gamma, N, R_func):\n        \"\"\"Checks if a given CFL number 'nu' is stable.\"\"\"\n        dx = L / N\n        dt = nu * dx / v\n        m = np.arange(N)\n        theta_m = 2 * np.pi * m / N\n        \n        # Calculate eigenvalues of the semi-discrete operator\n        lambda_m = -gamma - (v / dx) * (1 - np.exp(-1j * theta_m))\n        \n        # Scaled eigenvalues for stability function\n        z = dt * lambda_m\n        \n        # Check if all amplification factors are within the unit circle\n        amplification_factors = np.abs(R_func(z))\n        \n        # Use a small tolerance for floating-point comparisons\n        return np.max(amplification_factors) = 1.0 + 1e-9\n\n    def find_nu_max(L, v, gamma, N, R_func):\n        \"\"\"\n        Finds the maximum stable CFL number using a bisection search.\n        \"\"\"\n        nu_low = 0.0\n        nu_high = 2.5 # A safe upper bound for these methods\n\n        # Bisection search for 100 iterations for high precision\n        for _ in range(100):\n            nu_mid = (nu_low + nu_high) / 2\n            # Break if converged\n            if nu_mid == nu_low or nu_mid == nu_high:\n                break\n            \n            if is_stable(nu_mid, L, v, gamma, N, R_func):\n                nu_low = nu_mid  # This value is stable, try for a higher one\n            else:\n                nu_high = nu_mid # This value is unstable, reduce the upper bound\n        \n        return nu_low\n\n    stability_cases = [\n        (1, 1, 0.0, 128),  # Case 1\n        (1, 1, 0.1, 128),  # Case 2\n        (1, 1, 2.0, 128),  # Case 3\n    ]\n    \n    results = []\n    for L, v, gamma, N in stability_cases:\n        nu_max_22 = find_nu_max(L, v, gamma, N, R_ssp_rk22)\n        nu_max_33 = find_nu_max(L, v, gamma, N, R_ssp_rk33)\n        results.extend([nu_max_22, nu_max_33])\n\n    # --- Part 2: Convergence Analysis ---\n\n    def L_operator(u, dx, v, gamma):\n        \"\"\"Applies the semi-discrete operator L to a grid function u.\"\"\"\n        u_left_shifted = np.roll(u, 1)\n        # First-order upwind difference for positive v\n        du_dx = (u - u_left_shifted) / dx\n        return -v * du_dx - gamma * u\n\n    def rk22_step(u, dt, dx, v, gamma):\n        \"\"\"Performs one time step using SSP RK(2,2).\"\"\"\n        k1 = L_operator(u, dx, v, gamma)\n        k2 = L_operator(u + dt * k1, dx, v, gamma)\n        return u + dt * (0.5 * k1 + 0.5 * k2)\n\n    def rk33_step(u, dt, dx, v, gamma):\n        \"\"\"Performs one time step using SSP RK(3,3).\"\"\"\n        k1 = L_operator(u, dx, v, gamma)\n        k2 = L_operator(u + dt * k1, dx, v, gamma)\n        u_stage3 = u + 0.25 * dt * (k1 + k2)\n        k3 = L_operator(u_stage3, dx, v, gamma)\n        return u + dt * ((1/6.0) * k1 + (1/6.0) * k2 + (2/3.0) * k3)\n\n    def evolve(u0, T, dt, dx, v, gamma, rk_stepper):\n        \"\"\"Evolves the solution from t=0 to t=T.\"\"\"\n        u = np.copy(u0)\n        num_steps = int(round(T / dt))\n        for _ in range(num_steps):\n            u = rk_stepper(u, dt, dx, v, gamma)\n        return u\n\n    L_conv, v_conv, gamma_conv, N_conv, T_conv = 1, 1, 0.5, 512, 0.5\n    nu_vals = [0.1, 0.05, 0.025, 0.0125]\n    \n    dx_conv = L_conv / N_conv\n    x_grid = np.linspace(0, L_conv, N_conv, endpoint=False)\n    \n    # Exact solution at final time T\n    u_exact_T = np.exp(-gamma_conv * T_conv) * np.sin(2 * np.pi / L_conv * (x_grid - v_conv * T_conv))\n    \n    # Initial condition\n    u0 = np.sin(2 * np.pi * x_grid / L_conv)\n    \n    schemes = {\n        'rk22': (rk22_step, []),\n        'rk33': (rk33_step, [])\n    }\n    \n    all_dts = []\n    for nu in nu_vals:\n        dt = nu * dx_conv / v_conv\n        all_dts.append(dt)\n        for stepper_func, errors_list in schemes.values():\n            u_num = evolve(u0, T_conv, dt, dx_conv, v_conv, gamma_conv, stepper_func)\n            error = np.sqrt(dx_conv * np.sum((u_num - u_exact_T)**2))\n            errors_list.append(error)\n            \n    # Fit for convergence order p\n    log_dts = np.log(all_dts)\n    p_22 = np.polyfit(log_dts, np.log(schemes['rk22'][1]), 1)[0]\n    p_33 = np.polyfit(log_dts, np.log(schemes['rk33'][1]), 1)[0]\n    \n    results.extend([p_22, p_33])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在完成一次复杂的数值相对论模拟之后，我们得到的是在不同分辨率下计算出的离散数据点。下一步的关键是从这些原始数据中提取有意义的物理和数值信息。这个练习模拟了这样一个后处理分析过程：给定来自三个不同分辨率下黑洞并合模拟的假设数据，我们将学习如何后验地估计代码的收敛阶 $p$，并利用理查森外推法（Richardson extrapolation）得到一个更精确的连续极限估计值 。这个过程不仅验证了代码是否如预期那样收敛，还为我们提供了一种获得更高精度结果的强大技术。",
            "id": "3470456",
            "problem": "在一个由广义相对论（GR）主导的等质量、无自旋双黑洞并合的数值相对论（NR）模拟中，进行了一项三分辨率收敛性测试。该代码使用笛卡尔网格上的有限差分方法，计算了在 $(\\ell=2,m=2)$ 引力波振幅峰值处的无量纲辐射能量份额 $E_{\\mathrm{rad}}/M$。设基准网格间距为 $h$，并考虑连续的均匀加密 $h/2$ 和 $h/4$。在这些分辨率下，可观测量（observable）的测量值为 $u_h = 0.03450$、$u_{h/2} = 0.0354375$ 和 $u_{h/4} = 0.03549609375$。假设对于某个常数 $C$ 和阶数 $p$，主阶截断误差按 $C h^p$ 比例缩放，并且浮点运算采用 IEEE 754 双精度，机器精度 $\\epsilon = 2^{-52}$。将每个报告的 $u$ 值视为受到一个以 $\\epsilon$ 为界的独立相对舍入不确定性的影响。\n\n从截断误差的缩放假设和后验收敛性分析的基本原理出发，确定：\n1) 收敛阶 $p$ 的后验估计。\n2) 通过由 $(h/2,h/4)$ 对构造的理查森外推法（Richardson extrapolation）得到的可观测量的连续极限估计。\n3) 由于有限精度导致的 $p$ 的绝对不确定性，使用相对于 $p$ 估计中所涉及的差值的一阶线性化方法计算。\n4) 由于有限精度导致的外推连续值的绝对不确定性，通过对 $u_{h/4}$、$u_{h/2}$ 的独立舍入界限和 $p$ 的不确定性进行一阶传播获得。\n\n将你最终报告的数字四舍五入到四位有效数字。将所有量表示为无量纲数。",
            "solution": "在尝试任何解答之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **模拟：** 数值相对论（NR），等质量、无自旋双黑洞并合。\n- **基础理论：** 广义相对论（GR）。\n- **可观测量：** 无量纲辐射能量份额 $E_{\\mathrm{rad}}/M$，记为 $u$。\n- **数值方案：** 笛卡尔网格上的有限差分法，使用三种网格间距：$h$、$h/2$ 和 $h/4$。\n- **测量值：**\n    - $u_h = 0.03450$\n    - $u_{h/2} = 0.0354375$\n    - $u_{h/4} = 0.03549609375$\n- **误差模型：** 主阶截断误差按 $C h^p$ 比例缩放，意味着对于某个连续极限值 $u_0$、常数 $C$、阶数 $p$ 以及代表网格间距的 $k$，有 $u_k \\approx u_0 + C k^p$。\n- **精度：** IEEE 754 双精度，机器精度 $\\epsilon = 2^{-52}$。\n- **不确定性模型：** 每次测量 $u$ 都有一个以 $\\epsilon$ 为界的独立相对舍入不确定性，因此绝对不确定性为 $\\delta u \\approx |u|\\epsilon$。\n- **要求解的量：**\n    1. 收敛阶 $p$ 的后验估计。\n    2. 通过 $(h/2, h/4)$ 的理查森外推法（Richardson extrapolation）得到的连续极限估计。\n    3. 由于有限精度导致的 $p$ 的绝对不确定性 $\\delta p$。\n    4. 由于有限精度导致的外推连续值的绝对不确定性 $\\delta u_0$。\n- **报告要求：** 将最终数字四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题坚实地植根于计算科学和数值相对论。收敛性测试、理查森外推法和舍入误差分析是代码验证和从数值模拟中获得可靠结果的标准、必要程序。物理背景（BBH并合）和可观测量（$E_{\\mathrm{rad}}/M$）是该领域的标准内容。\n- **适定性：** 该问题是适定的。它提供了所有必要的数据和一个清晰的误差模型，以唯一地确定所要求的量。\n- **客观性：** 问题以精确的技术语言陈述，没有主观或含糊的术语。\n- **完整性和一致性：** 数据和假设是自洽且一致的。提供的数值收敛，参数足以进行分析。\n- **现实性：** 辐射能量份额的数值对于双黑洞并合是物理上现实的（占总质能的百分之几）。使用高阶有限差分方案可以实现 $p=4$ 的收敛阶。\n\n### 步骤 3：结论与行动\n该问题在科学上是合理的、适定的和完整的。因此，它被判定为 **有效**。将提供详细的解答。\n\n### 解答推导\n\n对于网格间距为 $k$ 的数值解 $u_k$，其基本假设是它与精确连续解 $u_0$ 的关系：\n$$u_k \\approx u_0 + C k^p$$\n其中 $C$ 是一个常数，$p$ 是收敛阶。我们被给予了在三个连续加密分辨率下的测量值：$u_h$、$u_{h/2}$ 和 $u_{h/4}$。\n\n**1) 收敛阶 $p$ 的后验估计**\n\n我们写出三个分辨率下的近似式：\n$$u_h \\approx u_0 + C h^p$$\n$$u_{h/2} \\approx u_0 + C \\left(\\frac{h}{2}\\right)^p = u_0 + \\frac{C h^p}{2^p}$$\n$$u_{h/4} \\approx u_0 + C \\left(\\frac{h}{4}\\right)^p = u_0 + \\frac{C h^p}{4^p}$$\n为了求出 $p$，我们构造差分以消去 $u_0$：\n$$u_{h/2} - u_h \\approx \\frac{C h^p}{2^p} - C h^p = C h^p \\left(\\frac{1}{2^p} - 1\\right)$$\n$$u_{h/4} - u_{h/2} \\approx \\frac{C h^p}{4^p} - \\frac{C h^p}{2^p} = \\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)$$\n取这些差值的比值可以消去 $C$ 和项 $(1/2^p - 1)$：\n$$R = \\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}} \\approx \\frac{C h^p \\left(\\frac{1}{2^p} - 1\\right)}{\\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)} = 2^p$$\n这给出了收敛阶 $p$ 的公式：\n$$p = \\log_2(R) = \\frac{\\ln(R)}{\\ln(2)} = \\frac{\\ln\\left(\\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}}\\right)}{\\ln(2)}$$\n代入给定值：\n$$u_{h/2} - u_h = 0.0354375 - 0.03450 = 0.0009375$$\n$$u_{h/4} - u_{h/2} = 0.03549609375 - 0.0354375 = 0.00005859375$$\n$$R = \\frac{0.0009375}{0.00005859375} = 16$$\n$$p = \\log_2(16) = 4$$\n估计的收敛阶恰好为 $p=4$。报告到四位有效数字，得到 $p=4.000$。\n\n**2) 通过理查森外推法进行连续极限估计**\n\n理查森外推法提供了连续极限值 $u_0$ 的一个更高阶的估计。对于加密因子 $r$，通用公式为 $u_0 \\approx u_{\\text{fine}} + \\frac{u_{\\text{fine}} - u_{\\text{coarse}}}{r^p - 1}$。问题指定使用 $(h/2, h/4)$ 对，其网格间距加密因子为 $r=2$。因此，$u_{\\text{coarse}} = u_{h/2}$ 且 $u_{\\text{fine}} = u_{h/4}$。\n设外推值为 $u_{ext}$。\n$$u_{ext} \\approx u_{h/4} + \\frac{u_{h/4} - u_{h/2}}{2^p - 1}$$\n使用 $p=4$ 和先前计算的差值：\n$$u_{ext} \\approx 0.03549609375 + \\frac{0.00005859375}{2^4 - 1} = 0.03549609375 + \\frac{0.00005859375}{15}$$\n$$u_{ext} \\approx 0.03549609375 + 0.00000390625 = 0.0355$$\n连续极限估计值恰好为 $u_{ext}=0.0355$。报告到四位有效数字，得到 $u_{ext}=0.03550$。\n\n**3) 由于有限精度导致的 $p$ 的绝对不确定性**\n\n$p$ 的公式为 $p = \\frac{\\ln(A/B)}{\\ln(2)}$，其中 $A = u_{h/2} - u_h$ 且 $B = u_{h/4} - u_{h/2}$。不确定性 $\\delta p$ 通过传播测量值的不确定性得到。\n$$(\\delta p)^2 = \\left(\\frac{1}{\\ln(2)}\\right)^2 \\left[ \\frac{(\\delta A)^2}{A^2} + \\frac{(\\delta B)^2}{B^2} \\right]$$\n不确定性 $\\delta A$ 和 $\\delta B$ 源于 $u$ 值的不确定性，给定为 $\\delta u_k = u_k \\epsilon$。由于舍入误差是独立的，它们正交相加：\n$$(\\delta A)^2 = (\\delta u_{h/2})^2 + (\\delta u_h)^2 = (u_{h/2}\\epsilon)^2 + (u_h\\epsilon)^2 = \\epsilon^2 (u_{h/2}^2 + u_h^2)$$\n$$(\\delta B)^2 = (\\delta u_{h/4})^2 + (\\delta u_{h/2})^2 = (u_{h/4}\\epsilon)^2 + (u_{h/2}\\epsilon)^2 = \\epsilon^2 (u_{h/4}^2 + u_{h/2}^2)$$\n将这些代入 $(\\delta p)^2$ 的表达式中：\n$$\\delta p = \\frac{\\epsilon}{\\ln(2)} \\sqrt{\\frac{u_{h/2}^2 + u_h^2}{(u_{h/2} - u_h)^2} + \\frac{u_{h/4}^2 + u_{h/2}^2}{(u_{h/4} - u_{h/2})^2}}$$\n我们现在代入数值：\n$$ (u_{h/2}-u_h)^2 = (0.0009375)^2 \\approx 8.78906 \\times 10^{-7} $$\n$$ (u_{h/4}-u_{h/2})^2 = (0.00005859375)^2 \\approx 3.43323 \\times 10^{-9} $$\n$$ u_{h/2}^2 + u_h^2 = (0.0354375)^2 + (0.03450)^2 \\approx 0.0012558 + 0.0011903 = 0.0024461 $$\n$$ u_{h/4}^2 + u_{h/2}^2 = (0.03549609375)^2 + (0.0354375)^2 \\approx 0.00125997 + 0.00125581 = 0.00251578 $$\n$$\\frac{0.0024461}{8.78906 \\times 10^{-7}} \\approx 2783.1$$\n$$\\frac{0.00251578}{3.43323 \\times 10^{-9}} \\approx 732779$$\n$$\\delta p \\approx \\frac{2^{-52}}{\\ln(2)} \\sqrt{2783.1 + 732779} = \\frac{2^{-52}}{\\ln(2)} \\sqrt{735562} \\approx \\frac{2.2204 \\times 10^{-16}}{0.69315} \\times 857.65$$\n$$\\delta p \\approx (3.2033 \\times 10^{-16}) \\times 857.65 \\approx 2.7473 \\times 10^{-13}$$\n保留四位有效数字，$p$ 的绝对不确定性为 $2.747 \\times 10^{-13}$。\n\n**4) 外推连续值的绝对不确定性**\n\n外推值为 $u_{ext} = \\frac{2^p u_{h/4} - u_{h/2}}{2^p - 1}$。根据问题陈述的结构，我们将 $u_{h/4}$、$u_{h/2}$ 和 $p$ 视为不确定性传播的独立变量。\n$$(\\delta u_{ext})^2 = \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/4}}\\right)^2 (\\delta u_{h/4})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/2}}\\right)^2 (\\delta u_{h/2})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2$$\n偏导数是：\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/4}} = \\frac{2^p}{2^p - 1} = \\frac{16}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/2}} = -\\frac{1}{2^p - 1} = -\\frac{1}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial p} = \\frac{(\\ln 2) 2^p (u_{h/2} - u_{h/4})}{(2^p - 1)^2} = \\frac{16 \\ln(2) (-0.00005859375)}{15^2} \\approx -2.889 \\times 10^{-6}$$\n不确定性为 $\\delta u_k = u_k \\epsilon$ 和来自第3部分的 $\\delta p$。我们来评估每一项对总方差 $(\\delta u_{ext})^2$ 的贡献。\n第1项（来自 $u_{h/4}$）：\n$$\\left(\\frac{16}{15}\\right)^2 (\\delta u_{h/4})^2 = \\left(\\frac{16}{15}\\right)^2 (u_{h/4} \\epsilon)^2 \\approx (1.1378) (0.035496 \\times 2^{-52})^2 \\approx 7.086 \\times 10^{-35}$$\n第2项（来自 $u_{h/2}$）：\n$$\\left(-\\frac{1}{15}\\right)^2 (\\delta u_{h/2})^2 = \\left(\\frac{1}{15}\\right)^2 (u_{h/2} \\epsilon)^2 \\approx (0.00444) (0.035438 \\times 2^{-52})^2 \\approx 2.757 \\times 10^{-37}$$\n第3项（来自 $p$）：\n$$\\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2 \\approx (-2.889 \\times 10^{-6})^2 (2.747 \\times 10^{-13})^2 \\approx (8.346 \\times 10^{-12}) (7.546 \\times 10^{-26}) \\approx 6.30 \\times 10^{-37}$$\n$u_{h/4}$ 不确定性的贡献是主导的。其他两项小了两个数量级以上，对于这个精度水平可以忽略不计。\n$$(\\delta u_{ext})^2 \\approx \\left(\\frac{16}{15}\\right)^2 (u_{h/4}\\epsilon)^2 + \\left(-\\frac{1}{15}\\right)^2 (u_{h/2}\\epsilon)^2 = \\frac{\\epsilon^2}{15^2} [16^2 u_{h/4}^2 + u_{h/2}^2]$$\n$$\\delta u_{ext} \\approx \\frac{\\epsilon}{15} \\sqrt{256 u_{h/4}^2 + u_{h/2}^2} = \\frac{2^{-52}}{15} \\sqrt{256(0.035496...)^2 + (0.0354375)^2}$$\n$$\\delta u_{ext} \\approx \\frac{2^{-52}}{15} \\sqrt{0.32255 + 0.001256} = \\frac{2^{-52}}{15} \\sqrt{0.32381} \\approx \\frac{2.2204 \\times 10^{-16}}{15} \\times 0.56904$$\n$$\\delta u_{ext} \\approx (1.4803 \\times 10^{-17}) \\times 0.56904 \\approx 8.4235 \\times 10^{-18}$$\n保留四位有效数字，$u_{ext}$ 的绝对不确定性为 $8.424 \\times 10^{-18}$。\n\n### 结果总结\n- 估计的收敛阶 $p = 4.000$\n- 外推连续值 $u_{ext} = 0.03550$\n- 阶数的绝对不确定性 $\\delta p = 2.747 \\times 10^{-13}$\n- 外推值的绝对不确定性 $\\delta u_{ext} = 8.424 \\times 10^{-18}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 4.000  0.03550  2.747 \\times 10^{-13}  8.424 \\times 10^{-18} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "科学计算软件在其生命周期中会不断演化，例如为了性能优化或功能扩展而进行代码重构。然而，我们必须确保这些修改不会在无意中引入破坏数值结果的细微错误。本练习建立了一个严格的验证框架，用于证明重构后的代码与原始版本在数值上是等效的 。通过在一个标准化的波方程问题上比较两个求解器的最终解、一个能量守恒的校验和（checksum）以及它们的收敛率，我们实践了回归测试中的一个核心原则，即在保持代码健康和可维护性的同时确保其结果的可靠性。",
            "id": "3470480",
            "problem": "你需要验证一个重构后的数值实现，对于数值相对论和引力波领域的标准化问题，在解值和收敛行为方面是否保持数值等效性。这些标准化问题将在无量纲单位下求解，所有报告的量均为无单位量。你的程序必须为一维线性化引力波方程（由带周期性边界条件的标量波动方程建模）构建两个功能上等效的求解器，计算指定参数集的解，并使用校验和与收敛率在指定容差范围内评估等效性。最终输出必须是单行，包含一个方括号括起来的逗号分隔的布尔值列表，其中每个布尔值对应一个测试用例，并指示该重构是否在规定的容差内保持了数值等效性。\n\n基本原理：\n- 标量波动方程 $$u_{tt} = c^2 u_{xx}$$，用于模拟平直时空中的线性化引力波。其中 $u$ 是度规扰动分量（例如，plus 极化），$c$ 是特征波速，$t$ 是时间，$x$ 是空间坐标。初始数据为 $u(x,0)$ 和 $u_t(x,0)$，解在周期性区域 $x \\in [0,L]$ 上求解。\n- 数值分析意义上的收敛性测试，旨在评估数值误差 $\\|e_h\\|$ 是否随网格间距 $h$ 以与方法的理论阶数 $p$ 一致的速率减小，其中 $$p \\approx \\frac{\\log\\left(\\|e_{h_1}\\|/\\|e_{h_2}\\|\\right)}{\\log\\left(h_1/h_2\\right)}.$$\n- 通过校验和进行验证，使用一个不变量或近似不变量的诊断量（此处为一个离散的类能量量），来检测数值行为中非预期的变化。\n\n你的程序必须：\n1. 为均匀周期性网格上的 $$u_{tt} = c^2 u_{xx}$$ 实现两个数学上等效的二阶显式有限差分解算器。两个解算器都使用空间上的二阶中心差分和二阶精度的时间步进方法来推进离散解。一个解算器代表“原始”代码，第二个代表“重构”后的代码，后者重新组织了代数运算，但旨在保持数值等效性。\n2. 对每个标准化问题，在多个网格分辨率 $N$ 上计算最终时间 $T$ 的数值解，对照解析解评估误差，并使用连续的网格细化来估计观测到的收敛阶 $p$。\n3. 在最终时间使用离散能量泛函 $$E = \\sum_i \\frac{1}{2}\\left( v_i^2 + c^2 (\\partial_x u_i)^2 \\right)\\Delta x$$ 计算一个校验和诊断量，其中 $v_i$ 是网格点 $i$ 处 $u_t$ 的离散近似，$(\\partial_x u_i)$ 是 $u_x$ 的离散近似。\n4. 如果以下所有条件均成立，则声明该重构在某个测试用例中保持了数值等效性：\n   - 在最精细分辨率下，原始解算器和重构解算器的最终数组之间的相对 $\\ell^2$ 差异满足 $$\\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2} \\le \\epsilon_{\\text{arr}},$$ 其中 $$\\epsilon_{\\text{arr}} = 10^{-12}.$$\n   - 在最精细分辨率下，校验和之间的相对差异满足 $$\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max\\left(|E^{\\text{orig}}|,|E^{\\text{ref}}|\\right)} \\le \\epsilon_{\\text{chk}},$$ 其中 $$\\epsilon_{\\text{chk}} = 10^{-10}.$$\n   - 原始解算器和重构解算器观测到的收敛阶均在目标值 $$p^\\ast = 2$$ 的 $$|p - p^\\ast| \\le 0.2$$ 范围内，且它们的差异满足 $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05.$$\n\n离散格式要求：\n- 使用均匀网格 $$x_i = i\\Delta x,$$ 其中 $$i = 0,1,\\dots,N-1,$$ $$\\Delta x = L/N.$$ 施加周期性边界条件，使得索引按模 $$N$$ 进行环绕。\n- 使用 Courant–Friedrichs–Lewy (CFL) 条件定义时间步长 $$\\Delta t$$。令 $$\\lambda = c\\Delta t/\\Delta x$$ 为测试套件中指定的 CFL 因子。为了精确到达最终时间 $$T,$$ 选择 $$n_{\\text{steps}} = \\text{round}(T/\\Delta t),$$ 然后重置 $$\\Delta t \\leftarrow T/n_{\\text{steps}}.$$\n- 初始化 $$u^0 = u(x,0),$$ $$v^0 = u_t(x,0),$$ 并使用二阶泰勒展开计算 $$u^1$$：$$u^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2\\, c^2\\, D_{xx} u^0,$$ 其中 $$D_{xx}$$ 是标准的二阶周期性离散拉普拉斯算子。然后使用显式二阶中心差分格式进行推进：$$u^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.$$\n- 在最终时间层 $$n,$$ 使用中心时间差分计算 $$v^n$$：$$v^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t},$$ 其中 $$u^{n+1}$$ 是从更新公式中代数推导得出，而不推进存储的状态。使用标准的二阶周期性中心差分计算 $$\\partial_x u^n$$。\n\n具有解析解的标准化问题：\n- 在 $$[0,L]$$ 上带周期性边界条件的单色平面波：\n  - 解析解为 $$u(x,t) = A\\sin(kx - \\omega t),$$ 其中振幅为 $$A$$, 波数为 $$k$$, 频率为 $$\\omega = ck$$。初始条件为 $$u(x,0) = A\\sin(kx)$$ 和 $$u_t(x,0) = -\\omega A\\cos(kx).$$\n- 使用 d’Alembert 解的零初始速度高斯脉冲：\n  - 令 $$f(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),$$ 其中 $$d(x,x_0)$$ 是在 $$[0,L]$$ 上的最小周期距离。解析解为 $$u(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right).$$ 初始条件为 $$u(x,0) = f(x)$$ 和 $$u_t(x,0) = 0.$$\n\n误差与收敛性：\n- 对每个测试用例中的分辨率 $$N$$，计算数值解 $$u_h(T)$$ 和解析解 $$u_{\\text{exact}}(T)$$。离散误差在 $\\ell^2$ 范数下度量：$$\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x}.$$ 通过对连续细化的结果应用对数比率公式来估计观测阶 $$p$$。\n\n测试套件：\n- 测试用例 $$1$$ (理想路径)：平面波，$$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 1,$$ $$k = 2\\pi$$, $$\\omega = c k,$$ 网格尺寸 $$N \\in \\{64,128,256\\},$$ CFL 因子 $$\\lambda = 0.9.$$\n- 测试用例 $$2$$ (近 CFL 边缘)：高斯脉冲，$$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$x_0 = 0.25L,$$ $$\\sigma = 0.05L,$$ 网格尺寸 $$N \\in \\{64,128,256\\},$$ CFL 因子 $$\\lambda = 0.999.$$\n- 测试用例 $$3$$ (粗网格边界)：平面波，$$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$k = 2\\pi,$$ $$\\omega = c k,$$ 网格尺寸 $$N \\in \\{16,32,64\\},$$ CFL 因子 $$\\lambda = 0.9.$$\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含一个逗号分隔并用方括号括起来的结果列表，具体为 $$[b_1,b_2,b_3],$$ 其中每个 $$b_j$$ 是一个布尔值，表示测试用例 $$j$$ 的数值等效性是否在指定容差内得以保持。",
            "solution": "我们从周期性区域 $$x \\in [0,L]$$ 上的标量波动方程 $$u_{tt} = c^2 u_{xx}$$ 出发。该方程是 Minkowski 时空中线性化引力波的一个经过充分检验的模型，其中度规扰动分量遵循一个特征速度为 $$c$$ 的波动方程。为了进行数值验证，我们通过检查离散解及其收敛行为是否在严格的容差内保持不变，来检验一次重构是否保持了数值等效性。\n\n离散化原理：我们使用均匀网格 $$x_i = i\\Delta x$$，其中 $$\\Delta x = L/N$$，并采用周期性边界条件，因此索引按模 $$N$$ 计算。对于时间积分，我们采用一种从泰勒展开和方程本身推导出的二阶中心差分格式。\n\n二阶精度初始化构造如下。给定初始数据 $$u(x,0) = u^0(x)$$ 和 $$u_t(x,0) = v^0(x),$$ 我们构建离散向量 $$u^0_i = u^0(x_i),$$ $$v^0_i = v^0(x_i)$$。离散拉普拉斯算子 $$D_{xx}$$ 定义为\n$$\n(D_{xx} u)_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\n并采用周期性环绕。使用时间上的泰勒展开和 $$u_{tt}(x,0) = c^2 u_{xx}(x,0),$$ 我们得到\n$$\nu^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2 c^2 D_{xx}u^0.\n$$\n对于 $$n \\ge 1,$$ 更新采用标准的二阶中心差分格式\n$$\nu^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.\n$$\n该格式与波动方程是一致的，并满足 Courant–Friedrichs–Lewy (CFL) 条件，其因子 $$\\lambda = c\\Delta t/\\Delta x \\le 1$$。为确保精确达到最终时间 $$T$$，我们计算 $$n_{\\text{steps}} = \\text{round}(T/\\Delta t)$$ 并重置 $$\\Delta t = T/n_{\\text{steps}}$$。\n\n重构与数值等效性：“原始”解算器在一个向量化表达式中计算更新。而“重构”解算器计算相同的更新，但对离散拉普拉斯算子的计算进行了代数上的重新排序，并将更新分解为中间数组。在精确算术中，这两者是相同的，因为加法和标量乘法在实数上满足结合律和交换律，且 $$D_{xx}$$ 是线性的。在浮点运算中，重新排序会在机器精度级别上改变舍入误差。因此，数值等效性不是通过完全一致来建立的，而是通过对诊断量的严格容差来确立，对于正确重构的代码，这些诊断量必须一致。\n\n诊断量：\n1. 最终状态数组的邻近度。我们测量最精细分辨率下最终数组之间的相对 $\\ell^2$ 差异：\n$$\n\\delta_{\\text{arr}} = \\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2},\n\\quad\n\\|w\\|_2 = \\sqrt{\\sum_i w_i^2 \\Delta x}.\n$$\n我们要求 $$\\delta_{\\text{arr}} \\le \\epsilon_{\\text{arr}}$$, 其中 $$\\epsilon_{\\text{arr}} = 10^{-12}$$，这个值远大于机器精度，但又足够小，可以检测到非预期的变化。\n\n2. 通过离散能量计算校验和。定义离散梯度为\n$$\n(\\partial_x u)_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}.\n$$\n在最终时间层 $$n$$，通过更新公式代数计算 $$u^{n+1}$$ 以避免改变存储状态，然后使用中心时间差分\n$$\nv^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t}.\n$$\n定义类能量校验和\n$$\nE = \\sum_i \\frac{1}{2}\\left( (v^n_i)^2 + c^2 \\left((\\partial_x u^n)_i\\right)^2 \\right)\\Delta x.\n$$\n我们要求原始代码和重构代码的能量之间的相对差异满足\n$$\n\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max(|E^{\\text{orig}}|,|E^{\\text{ref}}|)} \\le \\epsilon_{\\text{chk}},\n\\quad\n\\epsilon_{\\text{chk}} = 10^{-10}.\n$$\n\n3. 收敛行为。对于每个分辨率 $$N$$，我们计算在 $$T$$ 时的离散误差：\n$$\n\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x},\n\\quad h = \\Delta x.\n$$\n对于连续的细化 $$h_1  h_2$$，观测到的阶数通过以下公式计算：\n$$\np = \\frac{\\log(\\|e_{h_1}\\|_2/\\|e_{h_2}\\|_2)}{\\log(h_1/h_2)}.\n$$\n我们对连续的对进行聚合，为每个解算器生成一个代表性的 $$p$$。我们要求 $$p^{\\text{orig}}$$ 和 $$p^{\\text{ref}}$$ 都位于 $$p^\\ast = 2$$ 的 $$|p - p^\\ast| \\le 0.2$$ 范围内，并且它们之间的差异满足 $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05$$。\n\n标准化问题的解析解：\n- 平面波：$$u(x,t) = A\\sin(kx - \\omega t),\\quad \\omega = ck.$$\n初始数据为 $$u(x,0) = A\\sin(kx),\\quad u_t(x,0) = -\\omega A\\cos(kx).$$\n- 具有零初始速度和通过最小距离 $$d(x,x_0)$$ 实现周期性环绕的高斯脉冲：\n$$\nf(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),\n\\quad\nu(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right),\n\\quad\nu_t(x,0) = 0.\n$$\n\n第一性原理的论证：该格式直接源于波动方程在空间和时间上的一致二阶离散化。周期性离散算子是线性的，并模仿了连续导数。类能量校验和的动机是波动方程的哈密顿结构，其中 $$\\int \\tfrac{1}{2}(u_t^2 + c^2 u_x^2)\\,dx$$ 在连续情况下是守恒的；在离散情况下，它作为一个稳健的诊断量，对相移不敏感，但对系统性漂移敏感。对于光滑解，二阶方法预期会产生 $$p \\approx 2$$ 的收敛阶；平面波和高斯脉冲满足光滑性要求。因此，如果重构保持了更新和初始化的代数运算，差异必须被浮点舍入误差所限制，并且诊断量必须在严格的容差内匹配。该程序通过计算两个版本、测量差异并确认预期阶数来体现这一原则。\n\n测试套件覆盖范围：\n- 测试用例 1 验证了远离 CFL 极限的光滑周期解的理想路径。\n- 测试用例 2 在 $$\\lambda = 0.999$$ 的情况下探测了接近稳定性边界的数值行为，确保了在紧凑时间步长下等效性的稳健性。\n- 测试用例 3 强调了粗糙离散化，以验证即使在较大的 $$\\Delta x$$ 下，观测阶和校验和也能保持一致。\n\n最终输出必须是严格符合 $$[b_1,b_2,b_3]$$ 格式的单行，包含三个布尔值。每个 $$b_j$$ 为真，当且仅当测试用例 $$j$$ 满足所有三个标准（数组邻近度、校验和差异和收敛阶一致性）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dxx_periodic(u, dx):\n    # Second-order periodic discrete Laplacian\n    return (np.roll(u, -1) - 2.0*u + np.roll(u, 1)) / (dx*dx)\n\ndef dx_periodic(u, dx):\n    # Second-order periodic central difference gradient\n    return (np.roll(u, -1) - np.roll(u, 1)) / (2.0*dx)\n\ndef plane_wave_initial(x, A, k, omega):\n    u0 = A * np.sin(k * x)\n    v0 = -omega * A * np.cos(k * x)\n    return u0, v0\n\ndef plane_wave_exact(x, A, k, omega, t):\n    return A * np.sin(k * x - omega * t)\n\ndef periodic_distance(x, x0, L):\n    # Minimal periodic distance on [0,L]\n    d = (x - x0 + L/2.0) % L - L/2.0\n    return d\n\ndef gaussian_f_periodic(x, A, x0, sigma, L):\n    d = periodic_distance(x, x0, L)\n    return A * np.exp(-(d*d) / (2.0 * sigma * sigma))\n\ndef gaussian_exact_u(x, A, x0, sigma, L, c, t):\n    # d'Alembert with periodic wrap using minimal periodic distance\n    return 0.5 * (gaussian_f_periodic((x - c*t) % L, A, x0, sigma, L) +\n                  gaussian_f_periodic((x + c*t) % L, A, x0, sigma, L))\n\ndef initialize_u1(u0, v0, c, dt, dx):\n    return u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * dxx_periodic(u0, dx)\n\ndef advance_original(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    u_curr = initialize_u1(u0, v0, c, dt, dx)\n    # Time stepping\n    for _ in range(1, nsteps):\n        # Single-expression update\n        u_next = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    u_next_pred = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef advance_refactored(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    # Refactored: compute Laplacian separately and reuse\n    lap_u0 = dxx_periodic(u0, dx)\n    u_curr = u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * lap_u0\n    # Time stepping\n    for _ in range(1, nsteps):\n        lap = dxx_periodic(u_curr, dx)\n        term = (c * dt) ** 2 * lap\n        u_next = (2.0 * u_curr + term) - u_prev  # Reordered update\n        # Rotate state\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    lap_final = dxx_periodic(u_curr, dx)\n    u_next_pred = (2.0 * u_curr + (c * dt) ** 2 * lap_final) - u_prev\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef energy_checksum(u, v, c, dx):\n    grad = dx_periodic(u, dx)\n    return 0.5 * np.sum(v*v + (c*c) * grad*grad) * dx\n\ndef l2_error(u_num, u_exact, dx):\n    diff = u_num - u_exact\n    return np.sqrt(np.sum(diff*diff) * dx)\n\ndef observed_order(errors, hs):\n    # Compute p across successive pairs and average\n    ps = []\n    for i in range(len(errors) - 1):\n        e1, e2 = errors[i], errors[i+1]\n        h1, h2 = hs[i], hs[i+1]\n        if e1 > 0 and e2 > 0:\n            ps.append(np.log(e1/e2) / np.log(h1/h2))\n    if len(ps) == 0:\n        return float('nan')\n    return float(np.mean(ps))\n\ndef run_test_case_plane_wave(A, L, c, T, k, N_levels, CFL):\n    results = {}\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        omega = c * k\n        u0, v0 = plane_wave_initial(x, A, k, omega)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2) = 1e-14 and abs(dt - dt2) = 1e-14\n        u_ex = plane_wave_exact(x, A, k, omega, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef run_test_case_gaussian(A, L, c, T, x0, sigma, N_levels, CFL):\n    results = {}\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        u0 = gaussian_f_periodic(x, A, x0, sigma, L)\n        v0 = np.zeros_like(u0)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2) = 1e-14 and abs(dt - dt2) = 1e-14\n        u_ex = gaussian_exact_u(x, A, x0, sigma, L, c, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef equivalence_check(p_orig, p_ref, finest_data,\n                      p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n                      arr_tol=1e-12, chk_tol=1e-10):\n    u_orig, u_ref, E_orig, E_ref, dx = finest_data\n    # Relative L2 difference of final arrays\n    norm_orig = np.sqrt(np.sum(u_orig*u_orig) * dx)\n    rel_arr = np.sqrt(np.sum((u_orig - u_ref)**2) * dx) / (norm_orig + 1e-300)\n    arrays_close = rel_arr = arr_tol\n    # Relative checksum difference\n    denom = max(abs(E_orig), abs(E_ref)) + 1e-300\n    rel_chk = abs(E_orig - E_ref) / denom\n    checksums_close = rel_chk = chk_tol\n    # Convergence orders\n    p_ok_orig = abs(p_orig - p_target) = p_tol\n    p_ok_ref = abs(p_ref - p_target) = p_tol\n    p_match = abs(p_orig - p_ref) = p_match_tol\n    return arrays_close and checksums_close and p_ok_orig and p_ok_ref and p_match\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Plane wave happy path\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":1.0, \"k\":2.0*np.pi,\n                   \"N_levels\":[64,128,256], \"CFL\":0.9}),\n        # Test case 2: Gaussian near-CFL edge\n        (\"gaussian\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"x0\":0.25, \"sigma\":0.05,\n                      \"N_levels\":[64,128,256], \"CFL\":0.999}),\n        # Test case 3: Plane wave coarse-grid boundary\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"k\":2.0*np.pi,\n                   \"N_levels\":[16,32,64], \"CFL\":0.9}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"plane\":\n            p_orig, p_ref, finest_data = run_test_case_plane_wave(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                k=params[\"k\"], N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        else:\n            p_orig, p_ref, finest_data = run_test_case_gaussian(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                x0=params[\"x0\"], sigma=params[\"sigma\"],\n                N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        ok = equivalence_check(\n            p_orig, p_ref, finest_data,\n            p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n            arr_tol=1e-12, chk_tol=1e-10\n        )\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}