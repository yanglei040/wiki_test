{
    "hands_on_practices": [
        {
            "introduction": "The foundation of code validation lies in confirming that a numerical simulation's error decreases at the expected rate as the resolution is refined. This practice moves beyond theoretical error analysis to the essential skill of a posteriori verification, where you analyze the output from a set of simulations to measure the observed convergence order. You will apply Richardson extrapolation to a hypothetical dataset from a binary black hole merger simulation, providing a more accurate estimate of the true physical value and demonstrating a technique to systematically reduce discretization error. ",
            "id": "3470456",
            "problem": "A three-resolution convergence test is performed in a Numerical Relativity (NR) simulation of an equal-mass, non-spinning binary black hole merger governed by the General Theory of Relativity (GR). The code computes the dimensionless radiated energy fraction $E_{\\mathrm{rad}}/M$ at the peak of the $(\\ell=2,m=2)$ gravitational-wave amplitude, using a finite-difference discretization on a Cartesian mesh. Let the baseline grid spacing be $h$, and consider successive uniform refinements $h/2$ and $h/4$. The measured values of the observable at these resolutions are $u_h = 0.03450$, $u_{h/2} = 0.0354375$, and $u_{h/4} = 0.03549609375$. Assume the leading-order truncation error scales as $C h^p$ for some constant $C$ and order $p$, and that the floating-point arithmetic is IEEE 754 double precision with machine epsilon $\\epsilon = 2^{-52}$. Treat each reported $u$ as subject to an independent relative round-off uncertainty bounded by $\\epsilon$.\n\nStarting from the scaling assumption for the truncation error and first principles of a posteriori convergence analysis, determine:\n1) An a posteriori estimate of the convergence order $p$.\n2) A continuum-limit estimate of the observable via Richardson extrapolation constructed from the pair $(h/2,h/4)$.\n3) The absolute uncertainty in $p$ due to finite precision, using first-order linearization with respect to the differences involved in the $p$ estimate.\n4) The absolute uncertainty in the extrapolated continuum value from finite precision, obtained by first-order propagation of the independent round-off bounds on $u_{h/4}$, $u_{h/2}$, and the uncertainty in $p$.\n\nRound your final reported numbers to four significant figures. Express all quantities as dimensionless numbers.",
            "solution": "The problem is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n- **Simulation:** Numerical Relativity (NR), equal-mass, non-spinning binary black hole merger.\n- **Underlying Theory:** General Theory of Relativity (GR).\n- **Observable:** Dimensionless radiated energy fraction $E_{\\mathrm{rad}}/M$, denoted as $u$.\n- **Numerical Scheme:** Finite-difference on a Cartesian mesh with three grid spacings: $h$, $h/2$, and $h/4$.\n- **Measured Values:**\n    - $u_h = 0.03450$\n    - $u_{h/2} = 0.0354375$\n    - $u_{h/4} = 0.03549609375$\n- **Error Model:** The leading-order truncation error scales as $C h^p$ for some continuum value $u_0$, constant $C$, order $p$, and where $k$ represents the grid spacing.\n- **Precision:** IEEE 754 double precision with machine epsilon $\\epsilon = 2^{-52}$.\n- **Uncertainty Model:** Each measurement $u$ has an independent relative round-off uncertainty bounded by $\\epsilon$, such that the absolute uncertainty is $\\delta u \\approx |u|\\epsilon$.\n- **Required Quantities:**\n    1. A posteriori estimate of convergence order $p$.\n    2. Continuum-limit estimate via Richardson extrapolation from $(h/2, h/4)$.\n    3. Absolute uncertainty in $p$, $\\delta p$, from finite precision.\n    4. Absolute uncertainty in the extrapolated continuum value, $\\delta u_0$, from finite precision.\n- **Reporting:** Round final numbers to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The problem is firmly grounded in computational science and numerical relativity. Convergence testing, Richardson extrapolation, and round-off error analysis are standard, essential procedures for code validation and obtaining reliable results from numerical simulations. The physical context (BBH merger) and the observable ($E_{\\mathrm{rad}}/M$) are standard in the field.\n- **Well-Posedness:** The problem is well-posed. It provides all necessary data and a clear error model to determine the requested quantities uniquely.\n- **Objectivity:** The problem is stated in precise, technical language with no subjective or ambiguous terms.\n- **Completeness and Consistency:** The data and assumptions are self-contained and consistent. The provided numerical values converge, and the parameters are sufficient for the analysis.\n- **Realism:** The numerical values for the radiated energy fraction are physically realistic for a binary black hole merger (a few percent of the total mass-energy). A convergence order of $p=4$ is achievable with higher-order finite-difference schemes.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, and complete. It is therefore deemed **VALID**. A detailed solution will be provided.\n\n### Solution Derivations\n\nThe fundamental assumption for the numerical solution $u_k$ at a grid spacing $k$ is its relation to the exact continuum solution $u_0$:\n$$u_k \\approx u_0 + C k^p$$\nwhere $C$ is a constant and $p$ is the convergence order. We are given three measurements at successively refined resolutions: $u_h$, $u_{h/2}$, and $u_{h/4}$.\n\n**1) A posteriori estimate of the convergence order $p$**\n\nWe write the approximation for the three resolutions:\n$$u_h \\approx u_0 + C h^p$$\n$$u_{h/2} \\approx u_0 + C \\left(\\frac{h}{2}\\right)^p = u_0 + \\frac{C h^p}{2^p}$$\n$$u_{h/4} \\approx u_0 + C \\left(\\frac{h}{4}\\right)^p = u_0 + \\frac{C h^p}{4^p}$$\nTo find $p$, we form differences to eliminate $u_0$:\n$$u_{h/2} - u_h \\approx \\frac{C h^p}{2^p} - C h^p = C h^p \\left(\\frac{1}{2^p} - 1\\right)$$\n$$u_{h/4} - u_{h/2} \\approx \\frac{C h^p}{4^p} - \\frac{C h^p}{2^p} = \\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)$$\nTaking the ratio of these differences eliminates $C$ and the term $(1/2^p - 1)$:\n$$R = \\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}} \\approx \\frac{C h^p \\left(\\frac{1}{2^p} - 1\\right)}{\\frac{C h^p}{2^p} \\left(\\frac{1}{2^p} - 1\\right)} = 2^p$$\nThis gives the formula for the convergence order $p$:\n$$p = \\log_2(R) = \\frac{\\ln(R)}{\\ln(2)} = \\frac{\\ln\\left(\\frac{u_{h/2} - u_h}{u_{h/4} - u_{h/2}}\\right)}{\\ln(2)}$$\nSubstituting the given values:\n$$u_{h/2} - u_h = 0.0354375 - 0.03450 = 0.0009375$$\n$$u_{h/4} - u_{h/2} = 0.03549609375 - 0.0354375 = 0.00005859375$$\n$$R = \\frac{0.0009375}{0.00005859375} = 16$$\n$$p = \\log_2(16) = 4$$\nThe estimated convergence order is exactly $p=4$. Reporting to four significant figures gives $p=4.000$.\n\n**2) Continuum-limit estimate via Richardson extrapolation**\n\nRichardson extrapolation provides a higher-order estimate of the continuum value $u_0$. The general formula for a refinement factor $r$ is $u_0 \\approx u_{\\text{fine}} + \\frac{u_{\\text{fine}} - u_{\\text{coarse}}}{r^p - 1}$. The problem specifies using the pair $(h/2, h/4)$, for which the grid spacing is refined by a factor $r=2$. Thus, $u_{\\text{coarse}} = u_{h/2}$ and $u_{\\text{fine}} = u_{h/4}$.\nLet the extrapolated value be $u_{ext}$.\n$$u_{ext} \\approx u_{h/4} + \\frac{u_{h/4} - u_{h/2}}{2^p - 1}$$\nUsing $p=4$ and the previously calculated difference:\n$$u_{ext} \\approx 0.03549609375 + \\frac{0.00005859375}{2^4 - 1} = 0.03549609375 + \\frac{0.00005859375}{15}$$\n$$u_{ext} \\approx 0.03549609375 + 0.00000390625 = 0.0355$$\nThe continuum-limit estimate is exactly $u_{ext}=0.0355$. Reporting to four significant figures gives $u_{ext}=0.03550$.\n\n**3) Absolute uncertainty in $p$ due to finite precision**\n\nThe formula for $p$ is $p = \\frac{\\ln(A/B)}{\\ln(2)}$, where $A = u_{h/2} - u_h$ and $B = u_{h/4} - u_{h/2}$. The uncertainty $\\delta p$ is found by propagating the uncertainties of the measurements.\n$$(\\delta p)^2 = \\left(\\frac{1}{\\ln(2)}\\right)^2 \\left[ \\frac{(\\delta A)^2}{A^2} + \\frac{(\\delta B)^2}{B^2} \\right]$$\nThe uncertainties $\\delta A$ and $\\delta B$ arise from the uncertainties in the $u$ values, which are given as $\\delta u_k = u_k \\epsilon$. Since the round-off errors are independent, they add in quadrature:\n$$(\\delta A)^2 = (\\delta u_{h/2})^2 + (\\delta u_h)^2 = (u_{h/2}\\epsilon)^2 + (u_h\\epsilon)^2 = \\epsilon^2 (u_{h/2}^2 + u_h^2)$$\n$$(\\delta B)^2 = (\\delta u_{h/4})^2 + (\\delta u_{h/2})^2 = (u_{h/4}\\epsilon)^2 + (u_{h/2}\\epsilon)^2 = \\epsilon^2 (u_{h/4}^2 + u_{h/2}^2)$$\nSubstituting these into the expression for $(\\delta p)^2$:\n$$\\delta p = \\frac{\\epsilon}{\\ln(2)} \\sqrt{\\frac{u_{h/2}^2 + u_h^2}{(u_{h/2} - u_h)^2} + \\frac{u_{h/4}^2 + u_{h/2}^2}{(u_{h/4} - u_{h/2})^2}}$$\nWe now substitute the numerical values:\n$$ (u_{h/2}-u_h)^2 = (0.0009375)^2 \\approx 8.78906 \\times 10^{-7} $$\n$$ (u_{h/4}-u_{h/2})^2 = (0.00005859375)^2 \\approx 3.43323 \\times 10^{-9} $$\n$$ u_{h/2}^2 + u_h^2 = (0.0354375)^2 + (0.03450)^2 \\approx 0.0012558 + 0.0011903 = 0.0024461 $$\n$$ u_{h/4}^2 + u_{h/2}^2 = (0.03549609375)^2 + (0.0354375)^2 \\approx 0.00125997 + 0.00125581 = 0.00251578 $$\n$$\\frac{0.0024461}{8.78906 \\times 10^{-7}} \\approx 2783.1$$\n$$\\frac{0.00251578}{3.43323 \\times 10^{-9}} \\approx 732779$$\n$$\\delta p \\approx \\frac{2^{-52}}{\\ln(2)} \\sqrt{2783.1 + 732779} = \\frac{2^{-52}}{\\ln(2)} \\sqrt{735562} \\approx \\frac{2.2204 \\times 10^{-16}}{0.69315} \\times 857.65$$\n$$\\delta p \\approx (3.2033 \\times 10^{-16}) \\times 857.65 \\approx 2.7473 \\times 10^{-13}$$\nTo four significant figures, the absolute uncertainty in $p$ is $2.747 \\times 10^{-13}$.\n\n**4) Absolute uncertainty in the extrapolated continuum value**\n\nThe extrapolated value is $u_{ext} = \\frac{2^p u_{h/4} - u_{h/2}}{2^p - 1}$. We treat $u_{h/4}$, $u_{h/2}$, and $p$ as independent variables for the uncertainty propagation, as per the problem statement's structure.\n$$(\\delta u_{ext})^2 = \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/4}}\\right)^2 (\\delta u_{h/4})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial u_{h/2}}\\right)^2 (\\delta u_{h/2})^2 + \\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2$$\nThe partial derivatives are:\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/4}} = \\frac{2^p}{2^p - 1} = \\frac{16}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial u_{h/2}} = -\\frac{1}{2^p - 1} = -\\frac{1}{15}$$\n$$\\frac{\\partial u_{ext}}{\\partial p} = \\frac{(\\ln 2) 2^p (u_{h/2} - u_{h/4})}{(2^p - 1)^2} = \\frac{16 \\ln(2) (-0.00005859375)}{15^2} \\approx -2.889 \\times 10^{-6}$$\nThe uncertainties are $\\delta u_k = u_k \\epsilon$ and $\\delta p$ from part 3. Let's evaluate the contribution of each term to the total variance $(\\delta u_{ext})^2$.\nTerm 1 (from $u_{h/4}$):\n$$\\left(\\frac{16}{15}\\right)^2 (\\delta u_{h/4})^2 = \\left(\\frac{16}{15}\\right)^2 (u_{h/4} \\epsilon)^2 \\approx (1.1378) (0.035496 \\times 2^{-52})^2 \\approx 7.086 \\times 10^{-35}$$\nTerm 2 (from $u_{h/2}$):\n$$\\left(-\\frac{1}{15}\\right)^2 (\\delta u_{h/2})^2 = \\left(\\frac{1}{15}\\right)^2 (u_{h/2} \\epsilon)^2 \\approx (0.00444) (0.035438 \\times 2^{-52})^2 \\approx 2.757 \\times 10^{-37}$$\nTerm 3 (from $p$):\n$$\\left(\\frac{\\partial u_{ext}}{\\partial p}\\right)^2 (\\delta p)^2 \\approx (-2.889 \\times 10^{-6})^2 (2.747 \\times 10^{-13})^2 \\approx (8.346 \\times 10^{-12}) (7.546 \\times 10^{-26}) \\approx 6.30 \\times 10^{-37}$$\nThe contribution from the uncertainty in $u_{h/4}$ is dominant. The other two terms are more than two orders of magnitude smaller and can be considered negligible for this level of precision.\n$$(\\delta u_{ext})^2 \\approx \\left(\\frac{16}{15}\\right)^2 (u_{h/4}\\epsilon)^2 + \\left(-\\frac{1}{15}\\right)^2 (u_{h/2}\\epsilon)^2 = \\frac{\\epsilon^2}{15^2} [16^2 u_{h/4}^2 + u_{h/2}^2]$$\n$$\\delta u_{ext} \\approx \\frac{\\epsilon}{15} \\sqrt{256 u_{h/4}^2 + u_{h/2}^2} = \\frac{2^{-52}}{15} \\sqrt{256(0.035496...)^2 + (0.0354375)^2}$$\n$$\\delta u_{ext} \\approx \\frac{2^{-52}}{15} \\sqrt{0.32255 + 0.001256} = \\frac{2^{-52}}{15} \\sqrt{0.32381} \\approx \\frac{2.2204 \\times 10^{-16}}{15} \\times 0.56904$$\n$$\\delta u_{ext} \\approx (1.4803 \\times 10^{-17}) \\times 0.56904 \\approx 8.4235 \\times 10^{-18}$$\nTo four significant figures, the absolute uncertainty in $u_{ext}$ is $8.424 \\times 10^{-18}$.\n\n### Summary of Results\n- Estimated convergence order $p = 4.000$\n- Extrapolated continuum value $u_{ext} = 0.03550$\n- Absolute uncertainty in order $\\delta p = 2.747 \\times 10^{-13}$\n- Absolute uncertainty in extrapolated value $\\delta u_{ext} = 8.424 \\times 10^{-18}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 4.000 & 0.03550 & 2.747 \\times 10^{-13} & 8.424 \\times 10^{-18} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A stable and accurate numerical simulation depends critically on the interplay between the spatial discretization and the time integration algorithm. This exercise delves into the heart of this relationship using the Method of Lines, a standard approach for solving time-dependent partial differential equations. By analyzing a simplified model for constraint propagation in the Generalized Harmonic system, you will connect the theoretical stability regions of Runge-Kutta methods to the practical determination of the maximum stable Courant-Friedrichs-Lewy (CFL) number and verify the temporal convergence of the chosen schemes. ",
            "id": "3470417",
            "problem": "Consider a simplified one-dimensional model of the constraint-damped Generalized Harmonic (GH) evolution used in numerical relativity to analyze gravitational-wave spacetimes. In this model, the propagation of gauge constraints is represented by a scalar advection-damping equation on a periodic domain, which is evolved in time by explicit Strong-Stability-Preserving Runge-Kutta (SSP RK) schemes. The goal is two-fold: to compare the allowable Courant-Friedrichs-Lewy (CFL) numbers for different SSP RK schemes in terms of linear stability for the semi-discrete operator, and to validate the temporal convergence of the solution under timestep refinement while holding the spatial discretization fixed.\n\nFundamental base:\n- The model partial differential equation (PDE) is\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = -\\gamma\\,u(x,t),\n$$\nwhere $u$ is the scalar constraint proxy, $v>0$ is the advection speed, and $\\gamma\\ge 0$ is the constraint damping parameter.\n- The method-of-lines semi-discretization uses a first-order upwind difference for the spatial derivative on a periodic grid. For $N$ grid points on the interval $[0,L)$ with spacing $\\Delta x = L/N$, the semi-discrete operator acts on a grid function $u_i$ as\n$$\n\\left(\\mathcal{L}u\\right)_i = -\\,v\\,\\frac{u_i - u_{i-1}}{\\Delta x} - \\gamma\\,u_i,\\quad i=0,1,\\dots,N-1,\n$$\nwith periodic indexing $u_{-1}\\equiv u_{N-1}$. This yields a circulant matrix whose eigenvalues are given by the discrete Fourier symbol of the upwind operator shifted by the damping:\n$$\n\\lambda_m = -\\gamma - v\\,\\frac{1 - e^{-\\,\\mathrm{i}\\,\\theta_m}}{\\Delta x},\\quad \\theta_m = \\frac{2\\pi m}{N},\\quad m=0,1,\\dots,N-1.\n$$\n- An explicit $s$-stage Strong-Stability-Preserving Runge-Kutta (SSP RK) scheme defines a polynomial stability function $R(z)$ for the linear test problem $\\dot{y}=\\lambda y$, such that one step advances $y^{n+1} = R(\\Delta t\\,\\lambda)\\,y^n$. Linear stability of the time-stepping method for the semi-discrete operator requires\n$$\n\\max_{m\\in\\{0,\\dots,N-1\\}} \\left| R\\left(\\Delta t\\,\\lambda_m\\right) \\right| \\le 1.\n$$\nThe associated CFL number is $\\nu = v\\,\\Delta t/\\Delta x$.\n\nTasks:\n1. Implement the periodic semi-discrete operator $\\mathcal{L}$ as specified above for given $(L,v,\\gamma,N)$, and compute its spectrum $\\{\\lambda_m\\}$ via the discrete Fourier symbol.\n2. For the second-order two-stage Strong-Stability-Preserving Runge-Kutta method (SSP RK$(2,2)$) and the third-order three-stage Strong-Stability-Preserving Runge-Kutta method (SSP RK$(3,3)$), determine numerically the maximum allowable CFL numbers $\\nu_{\\max}$ such that the linear stability requirement holds for the entire spectrum of $\\mathcal{L}$. You must search over $\\Delta t$ and verify the bound $\\left|R\\left(\\Delta t\\,\\lambda_m\\right)\\right|\\le 1$ for all modes $m$; then report $\\nu_{\\max} = v\\,\\Delta t_{\\max}/\\Delta x$.\n3. Validate temporal convergence under timestep refinement at fixed spatial resolution using both SSP RK$(2,2)$ and SSP RK$(3,3)$. Evolve the PDE from $t=0$ to $t=T$ for the smooth initial data\n$$\nu(x,0) = \\sin\\!\\left(\\frac{2\\pi x}{L}\\right),\n$$\nand compare the numerical solution to the exact solution\n$$\nu(x,t) = e^{-\\gamma t}\\,\\sin\\!\\left(\\frac{2\\pi}{L}\\left(x - v\\,t\\right)\\right).\n$$\nCompute the discrete $\\ell_2$ error at $t=T$,\n$$\nE(\\Delta t) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left[ u_i^{\\mathrm{num}}(T) - u^{\\mathrm{exact}}(x_i,T) \\right]^2 \\right)^{1/2}.\n$$\nUse at least four timestep sizes $\\Delta t$ with approximately halving refinement, and estimate the empirical temporal order $p$ of each scheme by a least-squares fit to the relation $\\log E(\\Delta t) \\approx \\alpha + p\\,\\log(\\Delta t)$. Report the slope $p$ for SSP RK$(2,2)$ and SSP RK$(3,3)$.\n\nUnits:\n- Use dimensionless units consistent with relativistic codes, i.e., set the speed of light to $c=1$. All quantities are to be treated as dimensionless. No physical units are required in the output.\n\nAngle unit:\n- All angles in trigonometric functions are in radians.\n\nTest suite:\n- Compute $\\nu_{\\max}$ for the following three parameter sets:\n  - Case $1$: $L=1$, $v=1$, $\\gamma=0$, $N=128$.\n  - Case $2$: $L=1$, $v=1$, $\\gamma=0.1$, $N=128$.\n  - Case $3$: $L=1$, $v=1$, $\\gamma=2.0$, $N=128$.\n- Validate convergence for\n  - Convergence case: $L=1$, $v=1$, $\\gamma=0.5$, $N=512$, $T=0.5$, with timestep refinements corresponding to CFL numbers $\\nu\\in\\{0.1,\\,0.05,\\,0.025,\\,0.0125\\}$ for each scheme.\n\nAnswer specification:\n- For each of the three stability cases, return the maximum CFL numbers found for SSP RK$(2,2)$ and SSP RK$(3,3)$.\n- For the convergence case, return the empirical temporal orders $p$ for SSP RK$(2,2)$ and SSP RK$(3,3)$ as floating-point numbers.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$$\n[\\nu_{\\max}^{(2,2)}\\text{(Case 1)},\\ \\nu_{\\max}^{(3,3)}\\text{(Case 1)},\\ \\nu_{\\max}^{(2,2)}\\text{(Case 2)},\\ \\nu_{\\max}^{(3,3)}\\text{(Case 2)},\\ \\nu_{\\max}^{(2,2)}\\text{(Case 3)},\\ \\nu_{\\max}^{(3,3)}\\text{(Case 3)},\\ p^{(2,2)},\\ p^{(3,3)}].\n$$\nAll entries must be floats. Your program must not read any input and must print exactly this single line.",
            "solution": "The problem poses a well-defined task in the field of numerical analysis for partial differential equations, specifically focusing on the stability and convergence of time-integration schemes for a model equation relevant to numerical relativity. The problem statement is scientifically sound, internally consistent, and contains all necessary information, assuming standard knowledge of the specified numerical methods. We will proceed to a full solution.\n\nThe analysis is structured into three parts: first, outlining the properties of the semi-discrete system; second, detailing the stability analysis to find the maximum Courant-Friedrichs-Lewy (CFL) number; and third, describing the validation of temporal convergence.\n\n**1. The Semi-Discrete System and its Spectrum**\n\nThe governing partial differential equation (PDE) is the $1$D linear advection-damping equation on a periodic domain $[0,L)$:\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = -\\gamma\\,u(x,t)\n$$\nHere, $u(x,t)$ is a scalar field, $v > 0$ is the constant advection speed, and $\\gamma \\ge 0$ is the damping coefficient.\n\nThe method of lines is employed, where the spatial derivatives are discretized first, yielding a system of ordinary differential equations (ODEs) in time. The spatial domain is discretized into $N$ grid points $x_i = i\\Delta x$ for $i=0,\\dots,N-1$, with grid spacing $\\Delta x=L/N$. The spatial derivative $\\partial_x u$ is approximated using a first-order upwind finite difference scheme, chosen because the advection speed $v$ is positive. This leads to the semi-discrete system:\n$$\n\\frac{d u_i(t)}{dt} = \\left(\\mathcal{L}u\\right)_i = -v\\,\\frac{u_i(t) - u_{i-1}(t)}{\\Delta x} - \\gamma\\,u_i(t)\n$$\nwhere $u_i(t) \\approx u(x_i, t)$ and periodic boundary conditions imply $u_{-1} \\equiv u_{N-1}$. The operator $\\mathcal{L}$ can be represented by a circulant matrix.\n\nThe eigenvalues of a circulant matrix are given by its discrete Fourier symbol. For the operator $\\mathcal{L}$, the eigenvalues are explicitly given as:\n$$\n\\lambda_m = -\\gamma - v\\,\\frac{1 - e^{-\\mathrm{i}\\,\\theta_m}}{\\Delta x}, \\quad \\text{for } m = 0, 1, \\dots, N-1\n$$\nwhere $\\theta_m = \\frac{2\\pi m}{N}$. These eigenvalues lie in the complex plane. We can rewrite the expression to understand their geometric arrangement:\n$$\n\\lambda_m = -\\gamma - \\frac{v}{\\Delta x} + \\frac{v}{\\Delta x}e^{-\\mathrm{i}\\,\\theta_m}\n$$\nThis shows that the eigenvalues $\\{\\lambda_m\\}_{m=0}^{N-1}$ lie on a circle in the complex plane with center $C = -\\gamma - \\frac{v}{\\Delta x}$ and radius $R = \\frac{v}{\\Delta x}$. All eigenvalues reside in the left-half of the complex plane, as $\\operatorname{Re}(\\lambda_m) = -\\gamma - \\frac{v}{\\Delta x}(1-\\cos\\theta_m) \\le -\\gamma \\le 0$.\n\n**2. SSP RK Methods and Linear Stability Analysis**\n\nThe system of ODEs $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$ is integrated in time using explicit Strong-Stability-Preserving (SSP) Runge-Kutta (RK) methods. For a linear ODE $\\dot{y} = \\lambda y$, a single step of an RK method advances the solution as $y^{n+1} = R(z) y^n$, where $z = \\Delta t \\lambda$ and $R(z)$ is the stability polynomial of the method.\n\nThe problem specifies two methods:\n- **SSP RK(2,2)**: A second-order, two-stage method with stability polynomial $R_{(2,2)}(z) = 1 + z + \\frac{1}{2}z^2$.\n- **SSP RK(3,3)**: A third-order, three-stage method with stability polynomial $R_{(3,3)}(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$.\n\nFor the full semi-discrete system to be stable, the time-stepping method must be stable for every mode, which translates to the condition:\n$$\n\\max_{m=0,\\dots,N-1} \\left| R\\left(\\Delta t\\,\\lambda_m\\right) \\right| \\le 1\n$$\nThe set of points $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ is called the region of absolute stability. The stability condition requires that the scaled spectrum of the operator, $\\{\\Delta t \\lambda_m\\}$, must lie entirely within this region.\n\nThe task is to find the maximum allowable CFL number, $\\nu_{\\max} = v\\,\\Delta t_{\\max}/\\Delta x$. This is equivalent to finding the maximum time step $\\Delta t_{\\max}$ for which the stability condition holds. This is a root-finding problem for $\\Delta t_{\\max}$. A robust method to find it is a bisection search over the CFL number $\\nu = v\\,\\Delta t/\\Delta x$. For a given $\\nu$, we compute $\\Delta t = \\nu \\Delta x / v$ and check if $\\max_m |R(\\Delta t\\,\\lambda_m)| \\le 1$. The search identifies the largest $\\nu$ (and thus $\\Delta t$) that satisfies this criterion.\n\n**3. Temporal Convergence Validation**\n\nThe second task is to verify that the numerical schemes achieve their expected theoretical order of convergence in time. This is done by evolving a known smooth initial condition and comparing the numerical result to the exact analytical solution.\n\nThe PDE is evolved from $t=0$ to $t=T$ with the initial condition $u(x,0) = \\sin(2\\pi x/L)$. The exact solution is given as:\n$$\nu(x,t) = e^{-\\gamma t}\\,\\sin\\left(\\frac{2\\pi}{L}(x - vt)\\right)\n$$\nThe numerical solution $u_i^{\\mathrm{num}}(T)$ is computed by applying the time-stepping algorithm for a fixed spatial resolution $N$ and a given time step $\\Delta t$. For the SSP RK(2,2) and SSP RK(3,3) methods, one time step $u^n \\to u^{n+1}$ is performed by computing intermediate stages according to the respective Butcher tableaux. For instance, for SSP RK(3,3):\n1. $k_1 = \\mathcal{L}(u^n)$\n2. $k_2 = \\mathcal{L}(u^n + \\Delta t\\,k_1)$\n3. $k_3 = \\mathcal{L}(u^n + \\frac{1}{4}\\Delta t\\,k_1 + \\frac{1}{4}\\Delta t\\,k_2)$\n4. $u^{n+1} = u^n + \\Delta t\\left(\\frac{1}{6}k_1 + \\frac{1}{6}k_2 + \\frac{2}{3}k_3\\right)$\n\nThe error of the numerical solution is measured at the final time $T$ using the discrete $\\ell_2$ norm:\n$$\nE(\\Delta t) = \\left( \\Delta x \\sum_{i=0}^{N-1} \\left[ u_i^{\\mathrm{num}}(T) - u^{\\mathrm{exact}}(x_i,T) \\right]^2 \\right)^{1/2}\n$$\nFor a method of order $p$, the error is expected to behave as $E(\\Delta t) \\propto (\\Delta t)^p$, assuming the time step is small enough so that temporal error dominates spatial error. This relationship can be expressed as $\\log E(\\Delta t) \\approx \\alpha + p\\,\\log(\\Delta t)$. The empirical order of convergence $p$ is estimated by computing the error $E(\\Delta t)$ for a sequence of refining time steps (in this case, four values of $\\Delta t$) and performing a linear least-squares fit to the $(\\log(\\Delta t), \\log(E))$ data. The slope of the resulting line is the estimated order $p$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem: calculates maximum CFL numbers for stability and\n    validates temporal convergence orders for two SSP RK schemes.\n    \"\"\"\n\n    # --- Part 1: Stability Analysis ---\n\n    def R_ssp_rk22(z):\n        \"\"\"Stability polynomial for SSP RK(2,2).\"\"\"\n        return 1 + z + 0.5 * z**2\n\n    def R_ssp_rk33(z):\n        \"\"\"Stability polynomial for SSP RK(3,3).\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6.0) * z**3\n\n    def is_stable(nu, L, v, gamma, N, R_func):\n        \"\"\"Checks if a given CFL number 'nu' is stable.\"\"\"\n        dx = L / N\n        dt = nu * dx / v\n        m = np.arange(N)\n        theta_m = 2 * np.pi * m / N\n        \n        # Calculate eigenvalues of the semi-discrete operator\n        lambda_m = -gamma - (v / dx) * (1 - np.exp(-1j * theta_m))\n        \n        # Scaled eigenvalues for stability function\n        z = dt * lambda_m\n        \n        # Check if all amplification factors are within the unit circle\n        amplification_factors = np.abs(R_func(z))\n        \n        # Use a small tolerance for floating-point comparisons\n        return np.max(amplification_factors) <= 1.0 + 1e-9\n\n    def find_nu_max(L, v, gamma, N, R_func):\n        \"\"\"\n        Finds the maximum stable CFL number using a bisection search.\n        \"\"\"\n        nu_low = 0.0\n        nu_high = 2.5 # A safe upper bound for these methods\n\n        # Bisection search for 100 iterations for high precision\n        for _ in range(100):\n            nu_mid = (nu_low + nu_high) / 2\n            # Break if converged\n            if nu_mid == nu_low or nu_mid == nu_high:\n                break\n            \n            if is_stable(nu_mid, L, v, gamma, N, R_func):\n                nu_low = nu_mid  # This value is stable, try for a higher one\n            else:\n                nu_high = nu_mid # This value is unstable, reduce the upper bound\n        \n        return nu_low\n\n    stability_cases = [\n        (1, 1, 0.0, 128),  # Case 1\n        (1, 1, 0.1, 128),  # Case 2\n        (1, 1, 2.0, 128),  # Case 3\n    ]\n    \n    results = []\n    for L, v, gamma, N in stability_cases:\n        nu_max_22 = find_nu_max(L, v, gamma, N, R_ssp_rk22)\n        nu_max_33 = find_nu_max(L, v, gamma, N, R_ssp_rk33)\n        results.extend([nu_max_22, nu_max_33])\n\n    # --- Part 2: Convergence Analysis ---\n\n    def L_operator(u, dx, v, gamma):\n        \"\"\"Applies the semi-discrete operator L to a grid function u.\"\"\"\n        u_left_shifted = np.roll(u, 1)\n        # First-order upwind difference for positive v\n        du_dx = (u - u_left_shifted) / dx\n        return -v * du_dx - gamma * u\n\n    def rk22_step(u, dt, dx, v, gamma):\n        \"\"\"Performs one time step using SSP RK(2,2).\"\"\"\n        k1 = L_operator(u, dx, v, gamma)\n        k2 = L_operator(u + dt * k1, dx, v, gamma)\n        return u + dt * (0.5 * k1 + 0.5 * k2)\n\n    def rk33_step(u, dt, dx, v, gamma):\n        \"\"\"Performs one time step using SSP RK(3,3).\"\"\"\n        k1 = L_operator(u, dx, v, gamma)\n        k2 = L_operator(u + dt * k1, dx, v, gamma)\n        u_stage3 = u + 0.25 * dt * (k1 + k2)\n        k3 = L_operator(u_stage3, dx, v, gamma)\n        return u + dt * ((1/6.0) * k1 + (1/6.0) * k2 + (2/3.0) * k3)\n\n    def evolve(u0, T, dt, dx, v, gamma, rk_stepper):\n        \"\"\"Evolves the solution from t=0 to t=T.\"\"\"\n        u = np.copy(u0)\n        num_steps = int(round(T / dt))\n        for _ in range(num_steps):\n            u = rk_stepper(u, dt, dx, v, gamma)\n        return u\n\n    L_conv, v_conv, gamma_conv, N_conv, T_conv = 1, 1, 0.5, 512, 0.5\n    nu_vals = [0.1, 0.05, 0.025, 0.0125]\n    \n    dx_conv = L_conv / N_conv\n    x_grid = np.linspace(0, L_conv, N_conv, endpoint=False)\n    \n    # Exact solution at final time T\n    u_exact_T = np.exp(-gamma_conv * T_conv) * np.sin(2 * np.pi / L_conv * (x_grid - v_conv * T_conv))\n    \n    # Initial condition\n    u0 = np.sin(2 * np.pi * x_grid / L_conv)\n    \n    schemes = {\n        'rk22': (rk22_step, []),\n        'rk33': (rk33_step, [])\n    }\n    \n    all_dts = []\n    for nu in nu_vals:\n        dt = nu * dx_conv / v_conv\n        all_dts.append(dt)\n        for stepper_func, errors_list in schemes.values():\n            u_num = evolve(u0, T_conv, dt, dx_conv, v_conv, gamma_conv, stepper_func)\n            error = np.sqrt(dx_conv * np.sum((u_num - u_exact_T)**2))\n            errors_list.append(error)\n            \n    # Fit for convergence order p\n    log_dts = np.log(all_dts)\n    p_22 = np.polyfit(log_dts, np.log(schemes['rk22'][1]), 1)[0]\n    p_33 = np.polyfit(log_dts, np.log(schemes['rk33'][1]), 1)[0]\n    \n    results.extend([p_22, p_33])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the lifecycle of any large-scale scientific code, refactoring is essential for maintainability and performance, but it carries the risk of introducing subtle bugs. This practice addresses a critical task in computational science: rigorously verifying that a refactored code remains numerically equivalent to the original. You will implement and compare two solvers for a model wave equation, developing a validation suite that combines direct solution comparison, checksums of a conserved quantity, and convergence rate analysis to certify that the code's behavior is unchanged within specified tolerances. ",
            "id": "3470480",
            "problem": "You are asked to validate that a refactored numerical implementation preserves numerical equivalence with respect to both solution values and convergence behavior for standardized problems in numerical relativity and gravitational waves. The standardized problems will be solved in nondimensional units, and all reported quantities are unitless. Your program must construct two functionally equivalent solvers for the one-dimensional linearized gravitational wave equation modeled by the scalar wave equation with periodic boundary conditions, compute solutions for specified parameter sets, and assess equivalence using checksums and convergence rates with specified tolerances. The final output must be a single line containing a comma-separated list of booleans enclosed in square brackets, where each boolean corresponds to one test case and indicates whether the refactoring preserves numerical equivalence under the prescribed tolerances.\n\nFundamental base:\n- The scalar wave equation, modeling linearized gravitational waves in flat spacetime, is $$u_{tt} = c^2 u_{xx},$$ where $u$ is the metric perturbation component (for example, the plus polarization), $c$ is the characteristic wave speed, $t$ is time, and $x$ is the spatial coordinate. The initial data are $u(x,0)$ and $u_t(x,0)$, and the solution is sought on a periodic domain $x \\in [0,L]$.\n- Convergence testing in the sense of numerical analysis evaluates whether the numerical error $\\|e_h\\|$ decreases with grid spacing $h$ according to a rate consistent with the method’s formal order $p$, where $$p \\approx \\frac{\\log\\left(\\|e_{h_1}\\|/\\|e_{h_2}\\|\\right)}{\\log\\left(h_1/h_2\\right)}.$$\n- Validation by checksum uses an invariant or near-invariant diagnostic (here, a discrete energy-like quantity) to detect unintended changes in numerical behavior.\n\nYour program must:\n1. Implement two mathematically equivalent second-order explicit finite difference solvers for $$u_{tt} = c^2 u_{xx}$$ on a uniform periodic grid. Both solvers advance the discrete solution using second-order central differences in space and second-order accurate time stepping. One solver represents the \"original\" code, and the second represents a \"refactored\" code that reorganizes algebraic operations but is intended to be numerically equivalent.\n2. For each standardized problem, compute the numerical solution at the final time $T$ on multiple grid resolutions $N$, evaluate the error against the analytic solution, and estimate the observed convergence order $p$ using successive grid refinements.\n3. Compute a checksum diagnostic at the final time using a discrete energy functional $$E = \\sum_i \\frac{1}{2}\\left( v_i^2 + c^2 (\\partial_x u_i)^2 \\right)\\Delta x,$$ where $v_i$ is a discrete approximation to $u_t$ at grid point $i$ and $(\\partial_x u_i)$ is a discrete approximation to $u_x$.\n4. Declare that the refactoring preserves numerical equivalence for a test case if all of the following hold:\n   - The relative $\\ell^2$ difference between the final arrays of the original and refactored solvers at the finest resolution satisfies $$\\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2} \\le \\epsilon_{\\text{arr}},$$ with $$\\epsilon_{\\text{arr}} = 10^{-12}.$$\n   - The relative difference between the checksums at the finest resolution satisfies $$\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max\\left(|E^{\\text{orig}}|,|E^{\\text{ref}}|\\right)} \\le \\epsilon_{\\text{chk}},$$ with $$\\epsilon_{\\text{chk}} = 10^{-10}.$$\n   - The observed convergence orders for the original and refactored solvers are both within $$|p - p^\\ast| \\le 0.2$$ of the target $$p^\\ast = 2,$$ and their difference satisfies $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05.$$\n\nDiscrete scheme requirements:\n- Use a uniform grid with $$x_i = i\\Delta x,$$ for $$i = 0,1,\\dots,N-1,$$ where $$\\Delta x = L/N.$$ Impose periodic boundary conditions such that indices wrap modulo $$N.$$\n- Define a time step $$\\Delta t$$ using the Courant–Friedrichs–Lewy (CFL) condition. Let $$\\lambda = c\\Delta t/\\Delta x$$ be the CFL factor specified in the test suite. To land exactly at final time $$T,$$ choose $$n_{\\text{steps}} = \\text{round}(T/\\Delta t),$$ then reset $$\\Delta t \\leftarrow T/n_{\\text{steps}}.$$\n- Initialize $$u^0 = u(x,0),$$ $$v^0 = u_t(x,0),$$ and compute $$u^1$$ using the second-order Taylor expansion $$u^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2\\, c^2\\, D_{xx} u^0,$$ where $$D_{xx}$$ is the standard second-order periodic discrete Laplacian. Then advance using the explicit second-order centered scheme $$u^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.$$\n- At the final time level $$n,$$ compute $$v^n$$ using the centered time difference $$v^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t},$$ where $$u^{n+1}$$ is obtained algebraically from the update formula without advancing the stored state. Compute $$\\partial_x u^n$$ using the standard second-order periodic central difference.\n\nStandardized problems with analytic solutions:\n- Monochromatic plane wave on $$[0,L]$$ with periodic boundary conditions:\n  - Analytic solution with amplitude $$A$$, wavenumber $$k$$, and frequency $$\\omega = ck$$ is $$u(x,t) = A\\sin(kx - \\omega t).$$ The initial conditions are $$u(x,0) = A\\sin(kx)$$ and $$u_t(x,0) = -\\omega A\\cos(kx).$$\n- Gaussian pulse with zero initial velocity using the d’Alembert solution:\n  - Let $$f(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),$$ where $$d(x,x_0)$$ is the minimal periodic distance on $$[0,L]$$. The analytic solution is $$u(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right).$$ The initial conditions are $$u(x,0) = f(x)$$ and $$u_t(x,0) = 0.$$\n\nError and convergence:\n- For each resolution $$N$$ in a test case, compute the numerical solution $$u_h(T)$$ and the analytic solution $$u_{\\text{exact}}(T).$$ The discrete error is measured in the $\\ell^2$ norm $$\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x}.$$ Estimate the observed order $$p$$ by applying the logarithmic ratio formula across successive refinements.\n\nTest suite:\n- Test case $$1$$ (happy path): Plane wave with $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 1,$$ $$k = 2\\pi$$, $$\\omega = c k,$$ grid sizes $$N \\in \\{64,128,256\\},$$ CFL factor $$\\lambda = 0.9.$$\n- Test case $$2$$ (near-CFL edge): Gaussian pulse with $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$x_0 = 0.25L,$$ $$\\sigma = 0.05L,$$ grid sizes $$N \\in \\{64,128,256\\},$$ CFL factor $$\\lambda = 0.999.$$\n- Test case $$3$$ (coarse-grid boundary): Plane wave with $$A = 1,$$ $$L = 1,$$ $$c = 1,$$ $$T = 0.5,$$ $$k = 2\\pi,$$ $$\\omega = c k,$$ grid sizes $$N \\in \\{16,32,64\\},$$ CFL factor $$\\lambda = 0.9.$$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, specifically $$[b_1,b_2,b_3],$$ where each $$b_j$$ is a boolean indicating whether numerical equivalence is preserved for test case $$j$$ under the specified tolerances.",
            "solution": "We begin from the scalar wave equation $$u_{tt} = c^2 u_{xx}$$ on the periodic domain $$x \\in [0,L].$$ This equation is a well-tested model for linearized gravitational waves in Minkowski spacetime, where the metric perturbation component obeys a wave equation with characteristic speed $$c.$$ For numerical validation, we examine whether a refactoring preserves numerical equivalence by checking that both the discrete solution and its convergence behavior remain unchanged within tight tolerances.\n\nDiscretization principles: We use a uniform grid $$x_i = i\\Delta x$$ with $$\\Delta x = L/N$$ and periodic boundary conditions, so indexing is taken modulo $$N.$$ For time integration, we employ a second-order centered scheme derived from Taylor expansion and the equation itself.\n\nThe second-order accurate initialization is constructed as follows. Given initial data $$u(x,0) = u^0(x)$$ and $$u_t(x,0) = v^0(x),$$ we form the discrete vectors $$u^0_i = u^0(x_i),$$ $$v^0_i = v^0(x_i).$$ The discrete Laplacian $$D_{xx}$$ is defined by\n$$\n(D_{xx} u)_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\nwith periodic wrap. Using the Taylor expansion in time and $$u_{tt}(x,0) = c^2 u_{xx}(x,0),$$ we obtain\n$$\nu^1 = u^0 + \\Delta t\\, v^0 + \\tfrac{1}{2}\\Delta t^2 c^2 D_{xx}u^0.\n$$\nFor $$n \\ge 1,$$ the update is the standard second-order centered scheme\n$$\nu^{n+1} = 2u^n - u^{n-1} + (c\\Delta t)^2 D_{xx}u^n.\n$$\nThis scheme is consistent with the wave equation and satisfies a Courant–Friedrichs–Lewy (CFL) condition with factor $$\\lambda = c\\Delta t/\\Delta x \\le 1.$$ To ensure the final time $$T$$ is attained exactly, we compute $$n_{\\text{steps}} = \\text{round}(T/\\Delta t)$$ and reset $$\\Delta t = T/n_{\\text{steps}}.$$\n\nRefactoring and numerical equivalence: The \"original\" solver computes the update in one vectorized expression. The \"refactored\" solver computes the same update but algebraically reorders the computation of the discrete Laplacian and decomposes the update into intermediate arrays. In exact arithmetic, these two are identical, since addition and scalar multiplication are associative and commutative over the reals, and $$D_{xx}$$ is linear. In floating-point arithmetic, the reordering changes round-off at the level of machine precision. Therefore, numerical equivalence is established not by exact identity but by tight tolerances on diagnostics that must coincide for properly refactored code.\n\nDiagnostics:\n1. Final-state array proximity. We measure the relative $\\ell^2$ difference between the final arrays at the finest resolution:\n$$\n\\delta_{\\text{arr}} = \\frac{\\|u^{\\text{orig}} - u^{\\text{ref}}\\|_2}{\\|u^{\\text{orig}}\\|_2},\n\\quad\n\\|w\\|_2 = \\sqrt{\\sum_i w_i^2 \\Delta x}.\n$$\nWe require $$\\delta_{\\text{arr}} \\le \\epsilon_{\\text{arr}}$$ with $$\\epsilon_{\\text{arr}} = 10^{-12},$$ which is significantly larger than machine epsilon yet small enough to detect unintended changes.\n\n2. Checksum via discrete energy. Define the discrete gradient by\n$$\n(\\partial_x u)_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}.\n$$\nAt the final time level $$n,$$ compute $$u^{n+1}$$ algebraically from the update to avoid changing the stored state, then use the centered time difference\n$$\nv^n = \\frac{u^{n+1} - u^{n-1}}{2\\Delta t}.\n$$\nDefine the energy-like checksum\n$$\nE = \\sum_i \\frac{1}{2}\\left( (v^n_i)^2 + c^2 \\left((\\partial_x u^n)_i\\right)^2 \\right)\\Delta x.\n$$\nWe require the relative difference between energies from the original and refactored codes to satisfy\n$$\n\\frac{|E^{\\text{orig}} - E^{\\text{ref}}|}{\\max(|E^{\\text{orig}}|,|E^{\\text{ref}}|)} \\le \\epsilon_{\\text{chk}},\n\\quad\n\\epsilon_{\\text{chk}} = 10^{-10}.\n$$\n\n3. Convergence behavior. For each resolution $$N,$$ we compute the discrete error at $$T$$:\n$$\n\\|e_h\\|_2 = \\sqrt{\\sum_i \\left(u_h(x_i,T) - u_{\\text{exact}}(x_i,T)\\right)^2 \\Delta x},\n\\quad h = \\Delta x.\n$$\nFor successive refinements $$h_1 > h_2,$$ the observed order is computed by\n$$\np = \\frac{\\log(\\|e_{h_1}\\|_2/\\|e_{h_2}\\|_2)}{\\log(h_1/h_2)}.\n$$\nWe aggregate across successive pairs to produce a representative $$p$$ for each solver. We require both $$p^{\\text{orig}}$$ and $$p^{\\text{ref}}$$ to lie within $$|p - p^\\ast| \\le 0.2$$ of $$p^\\ast = 2,$$ and the mutual difference to satisfy $$|p^{\\text{orig}} - p^{\\text{ref}}| \\le 0.05.$$\n\nAnalytic solutions for standardized problems:\n- Plane wave: $$u(x,t) = A\\sin(kx - \\omega t),\\quad \\omega = ck.$$\nInitial data are $$u(x,0) = A\\sin(kx),\\quad u_t(x,0) = -\\omega A\\cos(kx).$$\n- Gaussian pulse with zero initial velocity and periodic wrap via minimal distance $$d(x,x_0)$$:\n$$\nf(x) = A\\exp\\left(-\\frac{d(x,x_0)^2}{2\\sigma^2}\\right),\n\\quad\nu(x,t) = \\tfrac{1}{2}\\left(f(x-ct) + f(x+ct)\\right),\n\\quad\nu_t(x,0) = 0.\n$$\n\nJustification from first principles: The scheme follows directly from the wave equation via consistent second-order discretization in both space and time. The periodic discrete operators are linear and mimic the continuum derivatives. The energy-like checksum is motivated by the Hamiltonian structure of the wave equation, where $$\\int \\tfrac{1}{2}(u_t^2 + c^2 u_x^2)\\,dx$$ is conserved in the continuum; discretely it serves as a robust diagnostic insensitive to phase shifts but sensitive to systematic drift. Convergence at order $$p \\approx 2$$ is expected from the second-order method under smooth solutions; the plane wave and Gaussian pulse satisfy the smoothness requirements. Hence, if the refactoring preserves the algebraic operations of the update and initialization, differences must be bounded by floating-point round-off, and the diagnostics must match within tight tolerances. The program embodies this principle by computing both versions, measuring discrepancies, and confirming the expected order.\n\nTest suite coverage:\n- Test case $$1$$ validates the happy path for a smooth periodic solution away from the CFL limit.\n- Test case $$2$$ probes numerical behavior near the stability boundary with $$\\lambda = 0.999,$$ ensuring robustness of equivalence under tight time stepping.\n- Test case $$3$$ stresses coarse discretization to verify that the observed order and checksums remain consistent even with larger $$\\Delta x.$$\n\nThe final output must be a single line in the exact format $$[b_1,b_2,b_3],$$ containing three booleans. Each $$b_j$$ is true if and only if all three criteria (array proximity, checksum difference, and convergence order agreement) are satisfied for test case $$j.$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dxx_periodic(u, dx):\n    # Second-order periodic discrete Laplacian\n    return (np.roll(u, -1) - 2.0*u + np.roll(u, 1)) / (dx*dx)\n\ndef dx_periodic(u, dx):\n    # Second-order periodic central difference gradient\n    return (np.roll(u, -1) - np.roll(u, 1)) / (2.0*dx)\n\ndef plane_wave_initial(x, A, k, omega):\n    u0 = A * np.sin(k * x)\n    v0 = -omega * A * np.cos(k * x)\n    return u0, v0\n\ndef plane_wave_exact(x, A, k, omega, t):\n    return A * np.sin(k * x - omega * t)\n\ndef periodic_distance(x, x0, L):\n    # Minimal periodic distance on [0,L]\n    d = (x - x0 + L/2.0) % L - L/2.0\n    return d\n\ndef gaussian_f_periodic(x, A, x0, sigma, L):\n    d = periodic_distance(x, x0, L)\n    return A * np.exp(-(d*d) / (2.0 * sigma * sigma))\n\ndef gaussian_exact_u(x, A, x0, sigma, L, c, t):\n    # d'Alembert with periodic wrap using minimal periodic distance\n    return 0.5 * (gaussian_f_periodic((x - c*t) % L, A, x0, sigma, L) +\n                  gaussian_f_periodic((x + c*t) % L, A, x0, sigma, L))\n\ndef initialize_u1(u0, v0, c, dt, dx):\n    return u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * dxx_periodic(u0, dx)\n\ndef advance_original(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    u_curr = initialize_u1(u0, v0, c, dt, dx)\n    # Time stepping\n    for _ in range(1, nsteps):\n        # Single-expression update\n        u_next = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    u_next_pred = 2.0 * u_curr - u_prev + (c * dt) ** 2 * dxx_periodic(u_curr, dx)\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef advance_refactored(u0, v0, c, L, N, CFL, T):\n    # Grid and time step\n    dx = L / N\n    dt = CFL * dx / c\n    nsteps = int(round(T / dt))\n    dt = T / nsteps  # Adjust to hit final time exactly\n    # Initialize\n    u_prev = u0.copy()\n    # Refactored: compute Laplacian separately and reuse\n    lap_u0 = dxx_periodic(u0, dx)\n    u_curr = u0 + dt * v0 + 0.5 * (c * c) * (dt * dt) * lap_u0\n    # Time stepping\n    for _ in range(1, nsteps):\n        lap = dxx_periodic(u_curr, dx)\n        term = (c * dt) ** 2 * lap\n        u_next = (2.0 * u_curr + term) - u_prev  # Reordered update\n        # Rotate state\n        u_prev, u_curr = u_curr, u_next\n    # Compute v at final time using centered time difference (predict u_next)\n    lap_final = dxx_periodic(u_curr, dx)\n    u_next_pred = (2.0 * u_curr + (c * dt) ** 2 * lap_final) - u_prev\n    v_final = (u_next_pred - u_prev) / (2.0 * dt)\n    return u_curr, v_final, dx, dt\n\ndef energy_checksum(u, v, c, dx):\n    grad = dx_periodic(u, dx)\n    return 0.5 * np.sum(v*v + (c*c) * grad*grad) * dx\n\ndef l2_error(u_num, u_exact, dx):\n    diff = u_num - u_exact\n    return np.sqrt(np.sum(diff*diff) * dx)\n\ndef observed_order(errors, hs):\n    # Compute p across successive pairs and average\n    ps = []\n    for i in range(len(errors) - 1):\n        e1, e2 = errors[i], errors[i+1]\n        h1, h2 = hs[i], hs[i+1]\n        if e1 > 0 and e2 > 0:\n            ps.append(np.log(e1/e2) / np.log(h1/h2))\n    if len(ps) == 0:\n        return float('nan')\n    return float(np.mean(ps))\n\ndef run_test_case_plane_wave(A, L, c, T, k, N_levels, CFL):\n    results = {}\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        omega = c * k\n        u0, v0 = plane_wave_initial(x, A, k, omega)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2)  1e-14 and abs(dt - dt2)  1e-14\n        u_ex = plane_wave_exact(x, A, k, omega, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef run_test_case_gaussian(A, L, c, T, x0, sigma, N_levels, CFL):\n    results = {}\n    errors_orig, errors_ref = [], []\n    hs = []\n    finest_data = None\n    for N in N_levels:\n        x = np.linspace(0.0, L, N, endpoint=False)\n        u0 = gaussian_f_periodic(x, A, x0, sigma, L)\n        v0 = np.zeros_like(u0)\n        u_orig, v_orig, dx, dt = advance_original(u0, v0, c, L, N, CFL, T)\n        u_ref, v_ref, dx2, dt2 = advance_refactored(u0, v0, c, L, N, CFL, T)\n        assert abs(dx - dx2)  1e-14 and abs(dt - dt2)  1e-14\n        u_ex = gaussian_exact_u(x, A, x0, sigma, L, c, T)\n        e_orig = l2_error(u_orig, u_ex, dx)\n        e_ref = l2_error(u_ref, u_ex, dx)\n        errors_orig.append(e_orig)\n        errors_ref.append(e_ref)\n        hs.append(dx)\n        if N == N_levels[-1]:\n            E_orig = energy_checksum(u_orig, v_orig, c, dx)\n            E_ref = energy_checksum(u_ref, v_ref, c, dx)\n            finest_data = (u_orig, u_ref, E_orig, E_ref, dx)\n    p_orig = observed_order(errors_orig, hs)\n    p_ref = observed_order(errors_ref, hs)\n    return p_orig, p_ref, finest_data\n\ndef equivalence_check(p_orig, p_ref, finest_data,\n                      p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n                      arr_tol=1e-12, chk_tol=1e-10):\n    u_orig, u_ref, E_orig, E_ref, dx = finest_data\n    # Relative L2 difference of final arrays\n    norm_orig = np.sqrt(np.sum(u_orig*u_orig) * dx)\n    rel_arr = np.sqrt(np.sum((u_orig - u_ref)**2) * dx) / (norm_orig + 1e-300)\n    arrays_close = rel_arr = arr_tol\n    # Relative checksum difference\n    denom = max(abs(E_orig), abs(E_ref)) + 1e-300\n    rel_chk = abs(E_orig - E_ref) / denom\n    checksums_close = rel_chk = chk_tol\n    # Convergence orders\n    p_ok_orig = abs(p_orig - p_target) = p_tol\n    p_ok_ref = abs(p_ref - p_target) = p_tol\n    p_match = abs(p_orig - p_ref) = p_match_tol\n    return arrays_close and checksums_close and p_ok_orig and p_ok_ref and p_match\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Plane wave happy path\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":1.0, \"k\":2.0*np.pi,\n                   \"N_levels\":[64,128,256], \"CFL\":0.9}),\n        # Test case 2: Gaussian near-CFL edge\n        (\"gaussian\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"x0\":0.25, \"sigma\":0.05,\n                      \"N_levels\":[64,128,256], \"CFL\":0.999}),\n        # Test case 3: Plane wave coarse-grid boundary\n        (\"plane\", {\"A\":1.0, \"L\":1.0, \"c\":1.0, \"T\":0.5, \"k\":2.0*np.pi,\n                   \"N_levels\":[16,32,64], \"CFL\":0.9}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"plane\":\n            p_orig, p_ref, finest_data = run_test_case_plane_wave(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                k=params[\"k\"], N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        else:\n            p_orig, p_ref, finest_data = run_test_case_gaussian(\n                A=params[\"A\"], L=params[\"L\"], c=params[\"c\"], T=params[\"T\"],\n                x0=params[\"x0\"], sigma=params[\"sigma\"],\n                N_levels=params[\"N_levels\"], CFL=params[\"CFL\"]\n            )\n        ok = equivalence_check(\n            p_orig, p_ref, finest_data,\n            p_target=2.0, p_tol=0.2, p_match_tol=0.05,\n            arr_tol=1e-12, chk_tol=1e-10\n        )\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}