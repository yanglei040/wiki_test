{
    "hands_on_practices": [
        {
            "introduction": "The equations of General Relativistic Magnetohydrodynamics (GRMHD) are evolved numerically using sophisticated techniques known as shock-capturing, finite-volume methods. The heart of these methods lies in solving the \"Riemann problem\" at the interface between two computational cells to determine the flux of conserved quantities. The Harten-Lax-van Leer (HLL) solver is a widely-used, robust approximate Riemann solver that provides this flux by estimating the fastest-moving wave speeds, and this practice  will guide you through the implementation of this fundamental building block of any modern GRMHD code.",
            "id": "3475435",
            "problem": "You are to implement a one-dimensional shock-capturing approximate Riemann solver for General Relativistic Magnetohydrodynamics (GRMHD) in the Valencia formulation, specialized to a locally inertial frame where the spacetime metric is Minkowski. The solver must use the Harten-Lax-van Leer (HLL) approximate Riemann flux and signal speeds estimated from physically consistent upper bounds to the relativistic fast magnetosonic speed. The program will compute the HLL numerical flux across a single interface for several test cases. All calculations must be carried out in units where the speed of light $c=1$, and all outputs are dimensionless.\n\nFundamental base and definitions to be used:\n\n- The ideal Magnetohydrodynamics (MHD) stress-energy tensor in Special Relativity (Special Relativity Magnetohydrodynamics (SRMHD), which is the local limit of General Relativistic Magnetohydrodynamics (GRMHD)) is\n$$\nT^{\\mu\\nu} = \\left(\\rho h + b^2\\right) u^\\mu u^\\nu + \\left(p + \\frac{b^2}{2}\\right)\\eta^{\\mu\\nu} - b^\\mu b^\\nu,\n$$\nwhere $\\rho$ is the rest-mass density, $p$ is the gas pressure, $h$ is the specific enthalpy, $u^\\mu$ is the fluid four-velocity, $b^\\mu$ is the magnetic field four-vector measured in the fluid frame, $b^2 \\equiv b^\\mu b_\\mu$ is the magnetic field invariant, and $\\eta^{\\mu\\nu}$ is the Minkowski metric.\n\n- The specific enthalpy for an ideal gas with adiabatic index $\\Gamma$ is $h = 1 + \\epsilon + p/\\rho$, with specific internal energy $\\epsilon = p/\\left[(\\Gamma - 1)\\rho\\right]$. The Lorentz factor is $W = 1/\\sqrt{1 - v^2}$ with $v^2 = v_x^2 + v_y^2 + v_z^2$.\n\n- In SRMHD, the magnetic field four-vector components in terms of the laboratory-frame magnetic field $\\mathbf{B} = (B_x,B_y,B_z)$ and velocity $\\mathbf{v} = (v_x,v_y,v_z)$ are\n$b^0 = W\\,(\\mathbf{v}\\cdot\\mathbf{B})$, $b^i = \\frac{B^i}{W} + W\\,(\\mathbf{v}\\cdot\\mathbf{B})\\,v^i$,\nand the invariant is\n$b^2 = \\frac{B^2}{W^2} + (\\mathbf{v}\\cdot\\mathbf{B})^2$,\nwith $B^2 = B_x^2 + B_y^2 + B_z^2$.\n\n- The conserved variables in the Valencia formulation in a locally Minkowski frame are\n$$\nD = \\rho W,\n$$\n$$\nS_i = \\left(\\rho h + b^2\\right)W^2 v_i - b^0 b_i,\n$$\n$$\nE = \\left(\\rho h + b^2\\right)W^2 - \\left(p + \\frac{b^2}{2}\\right) - (b^0)^2, \\quad \\tau = E - D,\n$$\nand the evolved magnetic field components transverse to the $x$-direction are $B_y$ and $B_z$. The interface normal component $B_x$ is assumed continuous across the interface in ideal MHD in one dimension.\n\n- The physical fluxes in the $x$-direction are\n$$\nF_D = D v_x,\n$$\n$$\nF_{S_x} = S_x v_x + \\left(p + \\frac{b^2}{2}\\right) - b_x b_x,\n$$\n$$\nF_{S_y} = S_y v_x - b_x b_y, \\quad F_{S_z} = S_z v_x - b_x b_z,\n$$\n$$\nF_\\tau = S_x - D v_x,\n$$\n$$\nF_{B_y} = B_y v_x - B_x v_y, \\quad F_{B_z} = B_z v_x - B_x v_z.\n$$\n\n- The HLL flux between left and right states with conserved variables $U_L$ and $U_R$, fluxes $F_L$ and $F_R$, and signal speed estimates $a^- \\le 0 \\le a^+$ is\n$$\nF_{\\mathrm{HLL}} =\n\\begin{cases}\nF_L, & \\text{if } a^- \\ge 0, \\\\\nF_R, & \\text{if } a^+ \\le 0, \\\\\n\\dfrac{a^+ F_L - a^- F_R + a^+ a^- (U_R - U_L)}{a^+ - a^-}, & \\text{otherwise}.\n\\end{cases}\n$$\n\n- The relativistic sound speed squared is\n$$\nc_s^2 = \\frac{\\Gamma p}{\\rho h},\n$$\nthe relativistic Alfvén speed squared is\n$$\nv_A^2 = \\frac{b^2}{\\rho h + b^2},\n$$\nand a physically consistent upper-bound estimate to the fast magnetosonic speed squared is\n$$\nc_f^2 = c_s^2 + v_A^2 - c_s^2 v_A^2,\n$$\nwhich satisfies $0 \\le c_f^2 \\le 1$ and reduces to proper limits. Transform the comoving signal speeds to the laboratory frame along $x$ using relativistic velocity addition:\n$$\n\\lambda^\\pm = \\frac{v_x \\pm c_f}{1 \\pm v_x c_f}.\n$$\nUse $a^- = \\min(\\lambda^-_L,\\lambda^-_R)$ and $a^+ = \\max(\\lambda^+_L,\\lambda^+_R)$, clipped to the interval $[-1,1]$.\n\nTask:\n\n- Implement the above GRMHD HLL approximate Riemann solver in Python that, for each test case described below, constructs the primitive variables for the left and right states, converts to conserved variables, computes physical fluxes, estimates wave speeds, and computes the HLL flux vector in the $x$-direction for the set of evolved quantities $[D, S_x, S_y, S_z, \\tau, B_y, B_z]$.\n\n- All calculations must assume $c=1$ and must be expressed in dimensionless units.\n\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a comma-separated list enclosed in square brackets, ordered as $[F_D, F_{S_x}, F_{S_y}, F_{S_z}, F_\\tau, F_{B_y}, F_{B_z}]$ with no spaces. For example, the output should look like\n$$\n[[f_{D,1},f_{S_x,1},\\dots,f_{B_z,1}],[f_{D,2},\\dots],\\dots]\n$$\nbut with no whitespace anywhere in the string.\n\nTest suite:\n\nProvide the following $5$ test cases, each specified by left and right primitive states $(\\rho, p, v_x, v_y, v_z, B_x, B_y, B_z)$ and a single adiabatic index $\\Gamma$ for the case. The interface normal is along the $x$-direction.\n\n- Case $1$ (hydrodynamic shock tube, classical-like): Left $(\\rho_L = 1.0, p_L = 1.0, v_{x,L} = 0.0, v_{y,L} = 0.0, v_{z,L} = 0.0, B_{x,L} = 0.0, B_{y,L} = 0.0, B_{z,L} = 0.0)$, Right $(\\rho_R = 0.125, p_R = 0.1, v_{x,R} = 0.0, v_{y,R} = 0.0, v_{z,R} = 0.0, B_{x,R} = 0.0, B_{y,R} = 0.0, B_{z,R} = 0.0)$, with $\\Gamma = 5/3$.\n\n- Case $2$ (special relativistic hydrodynamics with transverse velocity): Left $(\\rho_L = 1.0, p_L = 1.0, v_{x,L} = 0.5, v_{y,L} = 0.3, v_{z,L} = 0.0, B_{x,L} = 0.0, B_{y,L} = 0.0, B_{z,L} = 0.0)$, Right $(\\rho_R = 1.0, p_R = 1.0, v_{x,R} = 0.0, v_{y,R} = 0.0, v_{z,R} = 0.0, B_{x,R} = 0.0, B_{y,R} = 0.0, B_{z,R} = 0.0)$, with $\\Gamma = 4/3$.\n\n- Case $3$ (magnetized symmetric with strong $B_x$ and opposite transverse fields): Left $(\\rho_L = 1.0, p_L = 0.1, v_{x,L} = 0.0, v_{y,L} = 0.0, v_{z,L} = 0.0, B_{x,L} = 1.0, B_{y,L} = 0.5, B_{z,L} = 0.0)$, Right $(\\rho_R = 1.0, p_R = 0.1, v_{x,R} = 0.0, v_{y,R} = 0.0, v_{z,R} = 0.0, B_{x,R} = 1.0, B_{y,R} = -0.5, B_{z,R} = 0.0)$, with $\\Gamma = 4/3$.\n\n- Case $4$ (ultrarelativistic counter-streaming with magnetization): Left $(\\rho_L = 0.01, p_L = 0.01, v_{x,L} = 0.99, v_{y,L} = 0.0, v_{z,L} = 0.0, B_{x,L} = 0.1, B_{y,L} = 0.2, B_{z,L} = 0.0)$, Right $(\\rho_R = 0.01, p_R = 0.01, v_{x,R} = -0.99, v_{y,R} = 0.0, v_{z,R} = 0.0, B_{x,R} = 0.1, B_{y,R} = 0.2, B_{z,R} = 0.0)$, with $\\Gamma = 4/3$.\n\n- Case $5$ (equal states magnetically dominated): Left equals Right $(\\rho = 0.1, p = 1.0, v_x = 0.1, v_y = -0.2, v_z = 0.3, B_x = 0.5, B_y = 0.4, B_z = -0.3)$, with $\\Gamma = 4/3$.\n\nYour program should produce a single line of output containing the HLL flux vectors for the $5$ cases as a comma-separated list of case results enclosed in square brackets, with each case result being a comma-separated list of the $7$ flux components $[F_D, F_{S_x}, F_{S_y}, F_{S_z}, F_\\tau, F_{B_y}, F_{B_z}]$ enclosed in square brackets and with no whitespace. For example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The user requests the implementation of a one-dimensional Harten-Lax-van Leer (HLL) approximate Riemann solver for Special Relativistic Magnetohydrodynamics (SRMHD), which is the flat-spacetime limit of General Relativistic Magnetohydrodynamics (GRMHD) in the Valencia formulation. The solution requires calculating numerical fluxes at an interface between two states (left and right) for a series of test cases.\n\n### Step 1: Problem Validation\n\nFirst, I will validate the problem statement against the specified criteria.\n\n**1.1. Extracted Givens:**\n- **Physical Model**: SRMHD, described by the ideal MHD stress-energy tensor $T^{\\mu\\nu} = (\\rho h + b^2) u^\\mu u^\\nu + (p + \\frac{b^2}{2})\\eta^{\\mu\\nu} - b^\\mu b^\\nu$.\n- **Equation of State**: Ideal gas with adiabatic index $\\Gamma$. Specific enthalpy $h = 1 + \\epsilon + p/\\rho$ and specific internal energy $\\epsilon = p/[(\\Gamma - 1)\\rho]$.\n- **Kinematics**: All calculations use units where the speed of light $c=1$. The Lorentz factor is $W = 1/\\sqrt{1 - v^2}$.\n- **Field Definitions**: The magnetic field four-vector $b^\\mu$ and its invariant $b^2$ are defined in terms of the lab-frame three-velocity $\\mathbf{v}$ and three-magnetic field $\\mathbf{B}$.\n- **Conserved Variables**: The Valencia formulation conserved variables are given as $D$, $S_i$, and $\\tau=E-D$. The evolved magnetic field components are $B_y, B_z$. $B_x$ is specified as continuous.\n- **Fluxes**: The physical fluxes in the $x$-direction for all evolved variables are provided.\n- **Numerical Method**: The HLL flux formula $F_{\\mathrm{HLL}}$ is specified, depending on the left/right state vectors ($U_L, U_R$), their fluxes ($F_L, F_R$), and estimated signal speeds ($a^-, a^+$).\n- **Signal Speed Estimation**: The signal speeds are to be estimated using an upper bound for the fast magnetosonic speed $c_f$, which is derived from the sound speed $c_s$ and Alfvén speed $v_A$. These are then transformed to the lab frame to get $\\lambda^\\pm$. The final signal speeds are $a^- = \\min(\\lambda^-_L, \\lambda^-_R)$ and $a^+ = \\max(\\lambda^+_L, \\lambda^+_R)$, clipped to $[-1,1]$.\n- **Task & Test Cases**: The task is to implement this solver and apply it to five distinct test cases, each defined by left and right primitive states $(\\rho, p, \\mathbf{v}, \\mathbf{B})$ and an adiabatic index $\\Gamma$.\n- **Output Format**: A single line of text comprising a list of lists of the 7 HLL flux components, with ',' as a separator and no whitespace.\n\n**1.2. Validation Verdict:**\n- **Scientifically Grounded**: The problem is well-grounded in the established theory of computational relativistic astrophysics. All provided equations for SRMHD, the Valencia formulation, and the HLL solver are standard and correct representations found in scientific literature.\n- **Well-Posed and Self-Contained**: The problem is well-posed. It provides all necessary mathematical formulas, physical definitions, and input data (test cases) to solve for a unique result. The condition of $B_x$ being constant across the interface is physically correct for 1D ideal MHD and crucial for the problem setup.\n- **Objective and Formalizable**: The problem is stated in precise, objective, mathematical language. It is a formal computational task with no ambiguity.\n- **Consistency Check**: I have cross-verified the provided formulas for conserved variables and fluxes. The definitions are consistent with standard implementations of the Valencia formulation in a locally inertial reference frame (flat spacetime, Cartesian coordinates). For example, the flux of the energy variable $\\tau=E-D$ is correctly given as $F_\\tau = F_E - F_D = S_x - D v_x$. Similarly, the fluxes of momentum $S_i$ are consistent with the literature. All provided relations form a self-consistent and valid system.\n\nBased on this analysis, the problem is deemed **valid**. I will proceed with the solution.\n\n### Step 2: Algorithmic Design and Solution\n\nThe solution will be structured as a Python program that iterates through the provided test cases. For each case, it will perform the following steps:\n\n1.  **State Initialization**: For both the left ($L$) and right ($R$) sides of the interface, the primitive variables $(\\rho, p, v_x, v_y, v_z, B_x, B_y, B_z)$ and the adiabatic index $\\Gamma$ are used to initialize a state object. This object will compute and store all relevant physical quantities.\n2.  **Calculation of Derived Quantities**: For each state (L and R):\n    a.  Compute kinematic terms: the three-velocity squared $v^2$ and the Lorentz factor $W$.\n    b.  Compute thermodynamic terms: the specific enthalpy $h$.\n    c.  Compute magnetic field terms: The lab-frame magnetic field magnitude squared $B^2$, the scalar product $\\mathbf{v}\\cdot\\mathbf{B}$, the magnetic field four-vector components $b^\\mu$, and the magnetic invariant $b^2$.\n3.  **Calculation of Conserved Variables and Fluxes**:\n    a.  Using the quantities from the previous step, compute the vector of conserved variables $U = [D, S_x, S_y, S_z, \\tau, B_y, B_z]$.\n    b.  Compute the corresponding physical flux vector $F(U) = [F_D, F_{S_x}, F_{S_y}, F_{S_z}, F_\\tau, F_{B_y}, F_{B_z}]$.\n4.  **Signal Speed Estimation**:\n    a.  For each state, calculate the relativistic sound speed squared $c_s^2$, the Alfvén speed squared $v_A^2$, and the fast magnetosonic speed squared $c_f^2 = c_s^2 + v_A^2 - c_s^2 v_A^2$.\n    b.  Take the square root to find $c_f$, which is the characteristic speed in the comoving frame.\n    c.  Apply relativistic velocity addition to transform these into the lab-frame speeds: $\\lambda^\\pm = (v_x \\pm c_f)/(1 \\pm v_x c_f)$.\n5.  **HLL Flux Computation**:\n    a.  Determine the minimum and maximum signal speeds for the entire Riemann fan: $a^- = \\min(\\lambda^-_L, \\lambda^-_R)$ and $a^+ = \\max(\\lambda^+_L, \\lambda^+_R)$. These are clipped to the physical range $[-1, 1]$.\n    b.  Apply the HLL formula based on the values of $a^-$ and $a^+$:\n        - If $a^- \\ge 0$, the flux is $F_L$.\n        - If $a^+ \\le 0$, the flux is $F_R$.\n        - Otherwise, the flux is $F_{\\mathrm{HLL}} = \\frac{a^+ F_L - a^- F_R + a^+ a^- (U_R - U_L)}{a^+ - a^-}$. This is calculated for each of the $7$ components of the state vector.\n6.  **Output Formatting**: The resulting HLL flux vectors for all test cases are collected. They are then formatted into a single string as a list of lists, with components separated by commas and no whitespace, and printed to standard output.\n\nThis procedure will be implemented in a self-contained Python script using the NumPy library for array operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass State:\n    \"\"\"\n    A class to hold all physical quantities related to a single GRMHD state.\n    It takes primitive variables and computes derived quantities, conserved variables,\n    fluxes, and characteristic speeds.\n    \"\"\"\n    def __init__(self, rho, p, vx, vy, vz, Bx, By, Bz, gamma):\n        # Primitive variables\n        self.rho, self.p = rho, p\n        self.vx, self.vy, self.vz = vx, vy, vz\n        self.Bx, self.By, self.Bz = Bx, By, Bz\n        self.gamma = gamma\n\n        # Compute all derived quantities upon initialization\n        self._calculate_all_vars()\n\n    def _calculate_all_vars(self):\n        # Derived kinematic quantities\n        v_sq = self.vx**2 + self.vy**2 + self.vz**2\n        if v_sq >= 1.0:\n            # For robustness with floating-point arithmetic, clip v_sq just below 1.\n            # The test cases do not violate this, but it is good practice.\n            v_sq = 1.0 - 1e-12\n        \n        self.W = 1.0 / np.sqrt(1.0 - v_sq)\n\n        # Derived thermodynamic quantities\n        if self.rho > 0:\n            epsilon = self.p / ((self.gamma - 1.0) * self.rho)\n            self.h = 1.0 + epsilon + self.p / self.rho\n        else: # Cold/vacuum limit, not used in test cases\n            self.h = 1.0\n\n        # Derived magnetic field quantities\n        B_sq = self.Bx**2 + self.By**2 + self.Bz**2\n        v_dot_B = self.vx * self.Bx + self.vy * self.By + self.vz * self.Bz\n        \n        self.b_sq = B_sq / self.W**2 + v_dot_B**2\n        self.b0 = self.W * v_dot_B\n        self.bx = self.Bx / self.W + self.W * v_dot_B * self.vx\n        self.by = self.By / self.W + self.W * v_dot_B * self.vy\n        self.bz = self.Bz / self.W + self.W * v_dot_B * self.vz\n        \n        # Conserved variables\n        self.D = self.rho * self.W\n        e_tot = self.rho * self.h + self.b_sq\n        self.Sx = e_tot * self.W**2 * self.vx - self.b0 * self.bx\n        self.Sy = e_tot * self.W**2 * self.vy - self.b0 * self.by\n        self.Sz = e_tot * self.W**2 * self.vz - self.b0 * self.bz\n        \n        p_tot = self.p + self.b_sq / 2.0\n        # E is the total energy density in the lab frame\n        E = e_tot * self.W**2 - p_tot - self.b0**2\n        self.tau = E - self.D\n        \n        self.U = np.array([self.D, self.Sx, self.Sy, self.Sz, self.tau, self.By, self.Bz])\n\n        # Fluxes in x-direction\n        Fx_D = self.D * self.vx\n        Fx_Sx = self.Sx * self.vx + p_tot - self.bx**2\n        Fx_Sy = self.Sy * self.vx - self.bx * self.by\n        Fx_Sz = self.Sz * self.vx - self.bx * self.bz\n        Fx_tau = self.Sx - self.D * self.vx\n        Fx_By = self.By * self.vx - self.Bx * self.vy\n        Fx_Bz = self.Bz * self.vx - self.Bx * self.vz\n        \n        self.F = np.array([Fx_D, Fx_Sx, Fx_Sy, Fx_Sz, Fx_tau, Fx_By, Fx_Bz])\n\n        # Signal speeds\n        cs_sq = 0.0\n        if self.rho > 0 and self.h > 0:\n            cs_sq = self.gamma * self.p / (self.rho * self.h)\n        \n        va_sq = 0.0\n        if self.rho * self.h + self.b_sq > 0:\n            va_sq = self.b_sq / (self.rho * self.h + self.b_sq)\n\n        # Upper bound for fast magnetosonic speed squared\n        cf_sq = cs_sq + va_sq - cs_sq * va_sq\n        cf = np.sqrt(max(0.0, cf_sq)) # Ensure non-negative argument for sqrt\n        \n        # Lab-frame speeds lambda+/-\n        num_p, den_p = self.vx + cf, 1.0 + self.vx * cf\n        num_m, den_m = self.vx - cf, 1.0 - self.vx * cf\n        \n        self.lambda_p = num_p / den_p if abs(den_p) > 1e-15 else np.sign(num_p)\n        self.lambda_m = num_m / den_m if abs(den_m) > 1e-15 else np.sign(num_m)\n\ndef compute_hll_flux(state_L, state_R):\n    \"\"\"Computes the HLL flux vector given left and right states.\"\"\"\n    a_minus = min(state_L.lambda_m, state_R.lambda_m)\n    a_plus = max(state_L.lambda_p, state_R.lambda_p)\n\n    # Clip speeds to physical range [-1, 1] as requested\n    a_minus = max(-1.0, a_minus)\n    a_plus = min(1.0, a_plus)\n    \n    F_L, F_R = state_L.F, state_R.F\n    U_L, U_R = state_L.U, state_R.U\n\n    # HLL flux formula cases\n    if a_minus >= 0:\n        return F_L\n    elif a_plus <= 0:\n        return F_R\n    else:\n        denom = a_plus - a_minus\n        # Denominator should not be zero for the given test cases.\n        return (a_plus * F_L - a_minus * F_R + a_plus * a_minus * (U_R - U_L)) / denom\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (left_prims), (right_prims), gamma\n        ( (1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), \n          (0.125, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), \n          5.0/3.0 ),\n        # Case 2\n        ( (1.0, 1.0, 0.5, 0.3, 0.0, 0.0, 0.0, 0.0), \n          (1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), \n          4.0/3.0 ),\n        # Case 3\n        ( (1.0, 0.1, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0), \n          (1.0, 0.1, 0.0, 0.0, 0.0, 1.0, -0.5, 0.0), \n          4.0/3.0 ),\n        # Case 4\n        ( (0.01, 0.01, 0.99, 0.0, 0.0, 0.1, 0.2, 0.0), \n          (0.01, 0.01, -0.99, 0.0, 0.0, 0.1, 0.2, 0.0), \n          4.0/3.0 ),\n        # Case 5\n        ( (0.1, 1.0, 0.1, -0.2, 0.3, 0.5, 0.4, -0.3), \n          (0.1, 1.0, 0.1, -0.2, 0.3, 0.5, 0.4, -0.3), \n          4.0/3.0 )\n    ]\n\n    results_str = []\n    for prims_L, prims_R, gamma in test_cases:\n        state_L = State(*prims_L, gamma)\n        state_R = State(*prims_R, gamma)\n        \n        hll_flux = compute_hll_flux(state_L, state_R)\n        results_str.append([str(x) for x in hll_flux])\n\n    case_strings = [f\"[{','.join(res)}]\" for res in results_str]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After the Riemann solver provides the fluxes to update the conserved variables—such as the relativistic density $D$, momentum density $S_i$, and energy $\\tau$—we must recover the \"primitive\" variables like rest-mass density $\\rho$, pressure $p$, and fluid velocity $v^i$. This step is essential to \"close the loop,\" as the physical fluxes for the next time step are calculated from these primitive quantities. This conservative-to-primitive inversion is a challenging nonlinear root-finding problem, and this exercise  details how to design and implement a robust algorithm to perform this critical conversion.",
            "id": "3475443",
            "problem": "Consider the ideal fluid limit of General Relativistic Magnetohydrodynamics (GRMHD) in flat spacetime. Work in natural units where the speed of light is $c=1$ and the electromagnetic constant is absorbed ($4\\pi=1$). Adopt the $(3+1)$ decomposition in Minkowski spacetime with lapse $\\alpha=1$, shift $\\beta^i=0$, and spatial metric $\\gamma_{ij}=\\delta_{ij}$. The fluid is described by the rest-mass density $\\rho$, thermal pressure $p$, three-velocity $v^i$, and the Eulerian magnetic field $B^i$. The equation of state is a gamma-law ideal gas with adiabatic index $\\Gamma$, so that the specific enthalpy is $h=1+\\epsilon+p/\\rho$, and the internal energy density per mass $\\epsilon$ obeys $p=(\\Gamma-1)\\rho \\epsilon$, yielding $h=1+\\Gamma p / [(\\Gamma-1)\\rho]$.\n\nThe conservative variables in the Valencia formulation are the rest-mass density $D$, momentum density $S_i$, and energy density $\\tau$ (excluding rest mass). These are defined in terms of the stress-energy tensor $T^{\\mu\\nu}$ of an ideal magnetized fluid and the $3+1$ projection onto the Eulerian observer. The comoving magnetic four-vector $b^\\mu$ is related to the Eulerian magnetic field $B^i$ and fluid velocity $v^i$ through the ideal magnetohydrodynamics constraints. The Lorentz factor is $W \\equiv (1 - v^2)^{-1/2}$ with $v^2 \\equiv v^i v_i$.\n\nYour tasks are:\n1. Starting from the fundamental definition of the stress-energy tensor for a magnetized ideal fluid,\n   $$T^{\\mu\\nu} = (\\rho h + b^2) u^\\mu u^\\nu + \\left(p + \\frac{b^2}{2}\\right) g^{\\mu\\nu} - b^\\mu b^\\nu,$$\n   where $u^\\mu$ is the fluid four-velocity, $b^\\mu$ is the magnetic four-vector, $b^2 \\equiv b^\\mu b_\\mu$, and $g^{\\mu\\nu}$ is the Minkowski metric, derive the primitive-to-conservative mapping in flat spacetime. Express $D$, $S_i$, and $\\tau$ in terms of $(\\rho, p, v^i, B^i, \\Gamma)$, together with the auxiliary variables $W$, $b^\\mu$, and $b^2$.\n\n2. Design a numerical inversion algorithm that, given conservative variables $(D, S_i, \\tau)$, the magnetic field $B^i$, and the adiabatic index $\\Gamma$, recovers the primitive variables $(\\rho, p, v^i)$. Formulate this inversion as solving a system of five nonlinear equations in five unknowns. Choose a parameterization of the unknowns that enforces physical constraints ($\\rho>0$, $p>0$, and $v^2<1$) without requiring inequality constraints explicitly in the solver. Explain your choice.\n\n3. Implement both the forward mapping and the inversion algorithm in a single program. For numerical stability, construct reasonable initial guesses for the inversion. Your solver must converge for the scientifically sound test suite below.\n\n4. Validation and output format: For each test case, compute conservative variables from the provided primitive variables, then perform inversion to recover the primitive variables. Quantify the maximum relative error across the recovered primitive variables $\\rho$, $p$, and the velocity vector $v^i$ compared to the originals, using the relative error definition $|x_{\\text{rec}}-x_{\\text{true}}|/\\max(|x_{\\text{true}}|,10^{-12})$. For $v^i$, use the Euclidean norm to aggregate the three components before computing the relative error. For each test case, return a boolean indicating whether all three recovered quantities $\\rho$, $p$, and $v^i$ meet a tolerance of $10^{-9}$ in this relative-error sense.\n\nUse dimensionless units throughout.\n\nTest suite (each case is $(\\Gamma, \\rho, p, v^x, v^y, v^z, B^x, B^y, B^z)$):\n- Case A (general, magnetized, moderately relativistic): $(\\frac{4}{3}, 1.0, 0.1, 0.3, -0.2, 0.1, 0.5, 0.0, 0.3)$.\n- Case B (non-magnetized, static, low density): $(\\frac{5}{3}, 10^{-3}, 10^{-5}, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)$.\n- Case C (strong magnetization aligned with velocity): $(\\frac{4}{3}, 0.8, 0.05, 0.5, 0.0, 0.0, 5.0, 0.0, 0.0)$.\n- Case D (ultra-relativistic velocity, oblique magnetic field): $(\\frac{4}{3}, 1.0, 5.0, c, c, c, 1.0, 2.0, -1.5)$, where $c \\equiv 0.99/\\sqrt{3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD]\"), where each result is the boolean for the corresponding test case.",
            "solution": "The problem is scientifically sound, well-posed, and all necessary information is provided. It represents a standard procedure in numerical general relativistic magnetohydrodynamics (GRMHD). We may proceed with the solution.\n\n### Part 1: Primitive-to-Conservative Variable Transformation\n\nWe are asked to derive the expressions for the conservative variables $(D, S_i, \\tau)$ in terms of the primitive variables $(\\rho, p, v^i, B^i)$ and the adiabatic index $\\Gamma$. We work in flat Minkowski spacetime with metric $g_{\\mu\\nu} = \\eta_{\\mu\\nu} = \\text{diag}(-1, 1, 1, 1)$, and use a Cartesian coordinate system such that the spatial metric is the Kronecker delta, $\\gamma_{ij} = \\delta_{ij}$. The Eulerian observer has a four-velocity $n^\\mu = (1, 0, 0, 0)$ corresponding to a lapse $\\alpha=1$ and shift $\\beta^i=0$.\n\nThe fundamental variables are:\n- Rest-mass density: $\\rho$\n- Fluid pressure: $p$\n- Fluid three-velocity: $v^i$, with magnitude squared $v^2 = \\delta_{ij}v^i v^j$\n- Eulerian magnetic field: $B^i$, with magnitude squared $B^2 = \\delta_{ij}B^i B^j$\n- Adiabatic index: $\\Gamma$\n\nFrom these, we define auxiliary quantities:\n- Lorentz factor: $W = (1 - v^2)^{-1/2}$\n- Specific enthalpy: $h = 1 + \\epsilon + p/\\rho$. With the ideal gas equation of state $p=(\\Gamma-1)\\rho\\epsilon$, this becomes $h = 1 + \\frac{\\Gamma p}{(\\Gamma-1)\\rho}$.\n- Fluid four-velocity: $u^\\mu = W(1, v^i)$\n- Comoving magnetic field four-vector $b^\\mu$, which is defined to be orthogonal to the fluid four-velocity, $u_\\mu b^\\mu = 0$. In terms of the Eulerian quantities, its components are:\n  - $b^0 = W(v_k B^k)$\n  - $b^i = \\frac{B^i}{W} + W(v_k B^k)v^i$\n- The squared norm of the comoving magnetic field is $b^2 = b_\\mu b^\\mu$:\n  $$b^2 = -(b^0)^2 + \\delta_{ij}b^i b^j = -W^2(v_k B^k)^2 + \\delta_{ij}\\left(\\frac{B^i}{W} + W(v_k B^k)v^i\\right)\\left(\\frac{B^j}{W} + W(v_l B^l)v^j\\right)$$\n  $$b^2 = -W^2(v \\cdot B)^2 + \\frac{B^2}{W^2} + 2(v \\cdot B)^2 + W^2(v \\cdot B)^2 v^2$$\n  Using $W^2(1-v^2)=1 \\implies W^2v^2 = W^2-1$:\n  $$b^2 = (v \\cdot B)^2(-W^2+2+W^2-1) + \\frac{B^2}{W^2} = (v \\cdot B)^2 + \\frac{B^2}{W^2}$$\n\nThe Valencia conservative variables are defined as projections of the stress-energy tensor $T^{\\mu\\nu}$ with respect to the Eulerian observer $n^\\mu$:\n- $D = -n_\\mu (\\rho u^\\mu) = \\rho u^0 = \\rho W$\n- $S_j = n_\\mu T^{\\mu\\nu}\\gamma_{\\nu j} = T^{0j}$\n- $\\tau = n_\\mu n_\\nu T^{\\mu\\nu} - D = T^{00} - D$\n\nThe stress-energy tensor is given by:\n$$T^{\\mu\\nu} = (\\rho h + b^2) u^\\mu u^\\nu + \\left(p + \\frac{b^2}{2}\\right) g^{\\mu\\nu} - b^\\mu b^\\nu$$\n\nNow we derive the expressions for $S_j$ and $\\tau$.\n\n**Momentum Density $S_j$:**\n$$S_j = T^{0j} = (\\rho h + b^2) u^0 u^j + \\left(p + \\frac{b^2}{2}\\right) g^{0j} - b^0 b^j$$\nSince $g^{0j}=0$:\n$$S_j = (\\rho h + b^2) (W)(Wv^j) - (W(v_k B^k))\\left(\\frac{B^j}{W} + W(v_l B^l)v^j\\right)$$\n$$S_j = (\\rho h + b^2)W^2 v_j - (v \\cdot B)B_j - W^2(v \\cdot B)^2 v_j$$\nGrouping terms proportional to $v_j$:\n$$S_j = (\\rho h W^2 + b^2 W^2 - W^2(v \\cdot B)^2)v_j - (v \\cdot B)B_j$$\nSubstitute $b^2 W^2 = W^2((v \\cdot B)^2 + B^2/W^2) = W^2(v \\cdot B)^2 + B^2$:\n$$S_j = (\\rho h W^2 + W^2(v \\cdot B)^2 + B^2 - W^2(v \\cdot B)^2)v_j - (v \\cdot B)B_j$$\n$$S_j = (\\rho h W^2 + B^2)v_j - (v \\cdot B)B_j$$\n\n**Energy Density $\\tau$:**\nFirst, we find the total energy density $E = T^{00}$:\n$$T^{00} = (\\rho h + b^2) u^0 u^0 + \\left(p + \\frac{b^2}{2}\\right) g^{00} - b^0 b^0$$\nSince $g^{00}=-1$:\n$$T^{00} = (\\rho h + b^2)W^2 - \\left(p + \\frac{b^2}{2}\\right) - (W(v_k B^k))^2$$\n$$T^{00} = \\rho h W^2 - p + b^2W^2 - \\frac{b^2}{2} - W^2(v \\cdot B)^2$$\nUsing $b^2 W^2 = W^2(v \\cdot B)^2 + B^2$ again:\n$$T^{00} = \\rho h W^2 - p + (W^2(v \\cdot B)^2 + B^2) - \\frac{b^2}{2} - W^2(v \\cdot B)^2$$\n$$T^{00} = \\rho h W^2 - p + B^2 - \\frac{b^2}{2}$$\nSubstituting $b^2=(v \\cdot B)^2 + B^2/W^2$:\n$$T^{00} = \\rho h W^2 - p + B^2 - \\frac{1}{2}\\left((v \\cdot B)^2 + \\frac{B^2}{W^2}\\right)$$\nFinally, $\\tau = T^{00} - D = T^{00} - \\rho W$:\n$$\\tau = \\rho h W^2 - p - \\rho W + B^2 - \\frac{1}{2}\\left((v \\cdot B)^2 + \\frac{B^2}{W^2}\\right)$$\n\nIn summary, the primitive-to-conservative mapping is:\n1.  Compute auxiliary quantities: $v^2 = v_i v^i$, $W = (1-v^2)^{-1/2}$, $h = 1 + \\frac{\\Gamma p}{(\\Gamma-1)\\rho}$, $B^2 = B_i B^i$, $(v \\cdot B) = v_i B^i$.\n2.  Compute conservative variables:\n    $$D = \\rho W$$\n    $$S_j = (\\rho h W^2 + B^2)v_j - (v \\cdot B)B_j$$\n    $$\\tau = \\rho h W^2 - p - \\rho W + B^2 - \\frac{1}{2}\\left((v \\cdot B)^2 + \\frac{B^2}{W^2}\\right)$$\n\n### Part 2: Conservative-to-Primitive Inversion Algorithm\n\nThe inversion task is to find the primitive variables $(\\rho, p, v^i)$ given the conservative variables $(D, S_i, \\tau)$, the magnetic field $B^i$, and the adiabatic index $\\Gamma$. This requires solving the system of five non-linear equations derived above for the five primitive variables.\n\nThe system of equations to solve is:\n$$f_D(\\rho, v^k) = D - \\rho W = 0$$\n$$f_{S_j}(\\rho, p, v^k) = S_j - \\left[(\\rho h W^2 + B^2)v_j - (v_k B^k)B_j\\right] = 0 \\quad (\\text{for } j=x,y,z)$$\n$$f_{\\tau}(\\rho, p, v^k) = \\tau - \\left[\\rho h W^2 - p - \\rho W + B^2 - \\frac{1}{2}\\left((v_k B^k)^2 + \\frac{B^2}{W^2}\\right)\\right] = 0$$\n\nDirectly solving this system for $(\\rho, p, v^i)$ is challenging due to the physical constraints: $\\rho>0$, $p>0$, and $v^2<1$. Standard root-finding algorithms like Newton's method work on unconstrained variables and may stray into unphysical regions, causing numerical failures (e.g., square roots of negative numbers, division by zero).\n\nTo address this, we re-parameterize the unknowns. We introduce a vector of five solver variables $\\mathbf{q} = (q_0, q_1, q_2, q_3, q_4)$ that are unconstrained (i.e., can take any real value). These are mapped to the physical primitive variables as follows:\n\n1.  **Density and Pressure:** To enforce positivity, we solve for the natural logarithm of $\\rho$ and $p$.\n    $$\\rho = e^{q_0}, \\quad p = e^{q_1}$$\n2.  **Velocity:** To enforce the constraint $v^2 < 1$, we solve for the spatial components of the four-velocity, $\\hat{u}_i \\equiv Wv_i$. The vector $\\hat{\\mathbf{u}} = (q_2, q_3, q_4)$ is unconstrained. The three-velocity $v^i$ and Lorentz factor $W$ can be recovered from $\\hat{u}_i$:\n    $$\\hat{u}^2 = \\delta_{ij}\\hat{u}^i\\hat{u}^j$$\n    $$W = \\sqrt{1 + \\hat{u}^2}$$\n    $$v_i = \\frac{\\hat{u}_i}{W}$$\n    This transformation ensures that no matter the values of $\\hat{u}_i$, we always have $v^2 = \\hat{u}^2/W^2 = \\hat{u}^2/(1+\\hat{u}^2) < 1$.\n\nThe inversion algorithm is thus to find the root of the five-dimensional function $\\mathbf{F}(\\mathbf{q}) = 0$, where the components of $\\mathbf{F}$ are the residuals of the conservative equations. The problem is solved using a numerical root-finding algorithm, such as a Newton-Raphson-type method.\n\n### Part 3: Numerical Implementation and Initial Guess\n\nThe success of a numerical root-finder heavily depends on a good initial guess. We construct a robust initial guess for the solver variables $\\mathbf{q}$ based on the given conservative state.\n\n1.  Estimate total energy $E = \\tau + D$.\n2.  Estimate the velocity based on the relativistic relation $S_i \\approx E v_i$.\n    $$v_{0, i} = S_i / E$$\n3.  The estimated velocity magnitude $v_0^2 = v_{0,i}v_{0,i}$ can exceed $1$. We enforce the physical limit by rescaling if necessary: if $v_0^2 \\ge 1 - \\delta$ for some small $\\delta > 0$, set $v_{0,i} \\leftarrow v_{0,i} \\sqrt{(1-\\delta)/v_0^2}$.\n4.  From the capped velocity, compute an initial guess for the Lorentz factor: $W_0 = (1-v_0^2)^{-1/2}$.\n5.  With $W_0$, estimate the rest-mass density: $\\rho_0 = D/W_0$.\n6.  To estimate pressure $p_0$, we use the energy equation, rearranged to solve for $p$. Ignoring magnetic terms for simplicity in the guess, we have $\\tau \\approx \\rho h W^2 - p - \\rho W = \\rho(h-1)W^2 -p + \\rho W(W-1)$. Using the ideal gas relation, this leads to an estimate:\n    $$p_0 = \\frac{E - D W_0}{\\frac{\\Gamma W_0^2}{\\Gamma-1} - 1}$$\n    A floor is applied to ensure $p_0 > 0$.\n7.  Finally, these initial guesses for the primitive variables $(\\rho_0, p_0, v_{0,i})$ are converted into the solver variables $\\mathbf{q}_0 = (\\ln \\rho_0, \\ln p_0, W_0 v_{0,i})$.\n\nThis initial guess provides a reasonable starting point across a wide range of physical regimes, from non-relativistic to ultra-relativistic flows, which is crucial for the solver's convergence.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the GRMHD problem for the given test suite.\n    \"\"\"\n\n    # Helper function to compute norms required by the problem statement\n    def _norm(vec):\n        return np.sqrt(np.sum(np.square(vec)))\n\n    def prim_to_con(gamma, rho, p, v, B):\n        \"\"\"\n        Converts primitive variables to conservative variables in flat spacetime.\n        Args:\n            gamma (float): Adiabatic index.\n            rho (float): Rest-mass density.\n            p (float): Pressure.\n            v (np.ndarray): 3-velocity vector.\n            B (np.ndarray): 3-magnetic field vector.\n        Returns:\n            tuple: (D, S, tau) conservative variables.\n        \"\"\"\n        v_squared = np.dot(v, v)\n        if v_squared >= 1.0:\n            raise ValueError(\"Velocity must be less than c=1.\")\n        \n        W = 1.0 / np.sqrt(1.0 - v_squared)\n        h = 1.0 + gamma * p / ((gamma - 1.0) * rho)\n        \n        B_squared = np.dot(B, B)\n        v_dot_B = np.dot(v, B)\n        \n        # Conservative variables\n        D = rho * W\n        \n        S = (rho * h * W**2 + B_squared) * v - v_dot_B * B\n        \n        b_squared = B_squared / W**2 + v_dot_B**2\n        tau = rho * h * W**2 - p - rho * W + B_squared - 0.5 * b_squared\n        \n        return D, S, tau\n\n    def con_to_prim(gamma, D, S, tau, B):\n        \"\"\"\n        Inverts conservative variables to primitive variables using a 5D root-finder.\n        Args:\n            gamma (float): Adiabatic index.\n            D (float): Conservative density.\n            S (np.ndarray): Conservative momentum density vector.\n            tau (float): Conservative energy density.\n            B (np.ndarray): 3-magnetic field vector.\n        Returns:\n            tuple: (rho, p, v) primitive variables.\n        \"\"\"\n        B_squared = np.dot(B, B)\n\n        # Objective function for the root finder.\n        # The function takes a vector `q` of 5 solver variables and returns\n        # the residuals of the 5 conservative equations.\n        # q = [ln(rho), ln(p), W*v_x, W*v_y, W*v_z]\n        def F(q):\n            # 1. Decode solver variables `q` into physical primitives\n            rho = np.exp(q[0])\n            p = np.exp(q[1])\n            u_hat = q[2:5]\n            \n            u_hat_squared = np.dot(u_hat, u_hat)\n            W = np.sqrt(1.0 + u_hat_squared)\n            v = u_hat / W\n            \n            # 2. Calculate conservatives from the decoded primitives\n            try:\n                D_calc, S_calc, tau_calc = prim_to_con(gamma, rho, p, v, B)\n            except (ValueError, ZeroDivisionError):\n                # Return large residuals if calculation fails (e.g., rho=0)\n                return np.full(5, 1e100)\n\n            # 3. Return the residuals\n            residuals = np.zeros(5)\n            residuals[0] = D - D_calc\n            residuals[1:4] = S - S_calc\n            residuals[4] = tau - tau_calc\n            \n            return residuals\n\n        # Construct a robust initial guess\n        E_cons = tau + D\n        v_guess = S / E_cons if E_cons > 1e-12 else np.zeros(3)\n\n        v_guess_sq = np.dot(v_guess, v_guess)\n        if v_guess_sq >= 1.0:\n            v_guess *= np.sqrt(0.99999999) / np.sqrt(v_guess_sq)\n        \n        v_guess_sq = np.dot(v_guess, v_guess)\n        W_guess = 1.0 / np.sqrt(1.0 - v_guess_sq)\n        \n        rho_guess = D / W_guess\n\n        p_num = E_cons - D * W_guess\n        p_den = (gamma * W_guess**2) / (gamma - 1.0) - 1.0\n        p_guess = max(1e-12, p_num / p_den if p_den > 1e-12 else 1e-12)\n        \n        u_hat_guess = W_guess * v_guess\n\n        # Initial guess vector for the solver\n        q_initial = np.array([\n            np.log(rho_guess),\n            np.log(p_guess),\n            u_hat_guess[0],\n            u_hat_guess[1],\n            u_hat_guess[2]\n        ])\n\n        # Solve the system\n        sol = root(F, q_initial, method='hybr', tol=1e-12)\n        \n        if not sol.success:\n            raise RuntimeError(f\"C2P inversion failed to converge: {sol.message}\")\n\n        # Decode solution back to primitives\n        q_sol = sol.x\n        rho_rec = np.exp(q_sol[0])\n        p_rec = np.exp(q_sol[1])\n        u_hat_rec = q_sol[2:5]\n        u_hat_rec_sq = np.dot(u_hat_rec, u_hat_rec)\n        W_rec = np.sqrt(1.0 + u_hat_rec_sq)\n        v_rec = u_hat_rec / W_rec\n        \n        return rho_rec, p_rec, v_rec\n\n    c = 0.99 / np.sqrt(3.0)\n    test_cases = [\n        (4./3., 1.0, 0.1, 0.3, -0.2, 0.1, 0.5, 0.0, 0.3),\n        (5./3., 1e-3, 1e-5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0),\n        (4./3., 0.8, 0.05, 0.5, 0.0, 0.0, 5.0, 0.0, 0.0),\n        (4./3., 1.0, 5.0, c, c, c, 1.0, 2.0, -1.5)\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        gamma, rho, p, vx, vy, vz, Bx, By, Bz = case\n        v = np.array([vx, vy, vz])\n        B = np.array([Bx, By, Bz])\n        \n        # 1. Forward P2C transformation\n        D, S, tau = prim_to_con(gamma, rho, p, v, B)\n        \n        # 2. Invert C2P\n        rho_rec, p_rec, v_rec = con_to_prim(gamma, D, S, tau, B)\n        \n        # 3. Validate and check tolerance\n        err_rho = abs(rho_rec - rho) / max(abs(rho), 1e-12)\n        err_p = abs(p_rec - p) / max(abs(p), 1e-12)\n        \n        v_norm = _norm(v)\n        v_rec_norm_diff = _norm(v_rec - v)\n        err_v = v_rec_norm_diff / max(v_norm, 1e-12) if max(v_norm, 1e-12) > 0 else v_rec_norm_diff\n\n        tolerance = 1e-9\n        is_converged = (err_rho < tolerance) and (err_p < tolerance) and (err_v < tolerance)\n        results.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res).lower() for res in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The primitive variable recovery detailed in the previous practice can be fragile, especially under the extreme conditions found near black holes or in relativistic shocks. Numerical errors can lead to unphysical states, such as negative pressure, which can crash a simulation. To build a robust code, we must implement safety nets, and the \"dual-energy\" or entropy-based fallback is a standard solution. This practice  demonstrates how to use a separately advected entropy variable to repair the pressure in cases where the energy-based calculation fails, ensuring the simulation remains physically valid.",
            "id": "3475391",
            "problem": "Consider the recovery of primitive variables in General Relativistic Magnetohydrodynamics (GRMHD), which denotes the equations of magnetized fluid dynamics in curved spacetime, near the Innermost Stable Circular Orbit (ISCO) of a Schwarzschild black hole. Primitive recovery refers to reconstructing fluid primitives from conserved quantities after a numerical update. In the presence of strong shocks near $r \\sim r_{\\rm ISCO}$, finite-precision arithmetic and flux imbalances can drive the computed thermodynamic pressure $P(\\rho,\\epsilon)$ negative when recovering from the conserved internal energy, causing an unphysical state and potential code failure.\n\nTo address this, use a dual-energy formulation that augments the energy update with an advected, positivity-preserving entropy proxy. For an ideal fluid in geometrized units with $G=c=1$ and black hole mass $M=1$, assume a single-component ideal equation of state with constant adiabatic index $\\Gamma$, where the pressure satisfies\n$$\nP = (\\Gamma - 1)\\,\\rho\\,\\epsilon,\n$$\nwith $\\rho$ the rest-mass density and $\\epsilon$ the specific internal energy. Introduce the entropy tracer (sometimes called entropy constant or entropy proxy) defined as\n$$\nK \\equiv \\frac{P}{\\rho^{\\Gamma}}.\n$$\nIn smooth, adiabatic flows, $K$ is materially advected and remains approximately constant; across shocks, $K$ increases due to irreversible heating. Unlike the energy variable, $K$ can be advected to remain non-negative by construction, making it suitable to repair unphysical negative pressures arising during primitive recovery.\n\nYou are to implement a robust primitive recovery for the pressure using a dual-energy variable. Given a set of cellwise inputs $(r,\\Gamma,\\rho,\\epsilon_{\\rm cons},K)$, where $r$ is the areal radius in Schwarzschild spacetime (with $M=1$ so $r_{\\rm ISCO}=6$), $\\Gamma$ is the adiabatic index, $\\rho$ is the rest-mass density, $\\epsilon_{\\rm cons}$ is the specific internal energy estimated from conserved variables, and $K$ is the advected entropy tracer, compute the physically admissible pressure $P$ by the following logic:\n1. Compute the pressure based on the energy estimate:\n$$\nP_{\\rm cons} = (\\Gamma - 1)\\,\\rho\\,\\epsilon_{\\rm cons}.\n$$\n2. Define a minimal pressure floor to prevent negative or vanishing pressure in tenuous cells:\n$$\nP_{\\rm floor} = f_{\\rm min}\\,\\rho,\n$$\nwhere $f_{\\rm min} > 0$ is a small constant. The floor is a numerical safeguard and must be applied uniformly.\n3. If $P_{\\rm cons} \\ge P_{\\rm floor}$, accept $P = P_{\\rm cons}$.\n4. Otherwise, compute the entropy-based pressure\n$$\nP_{K} = K\\,\\rho^{\\Gamma}.\n$$\nIf $P_{K} \\ge P_{\\rm floor}$, set $P = P_{K}$; if $P_{K} < P_{\\rm floor}$, set $P = P_{\\rm floor}$.\n\nYour program must implement this recovery rule and, for each input case, additionally report whether the entropy fallback was used and whether the pressure floor was engaged. Use geometrized units with $G=c=M=1$, so all quantities are dimensionless. The output for each test case must be a list of three values: the recovered pressure $P$ (float), the entropy-fallback flag (integer $0$ or $1$), and the floor-engagement flag (integer $0$ or $1$). The entropy-fallback flag is $1$ if the entropy path was attempted (i.e., $P_{\\rm cons} < P_{\\rm floor}$), and $0$ otherwise. The floor-engagement flag is $1$ if the final pressure equals $P_{\\rm floor}$, and $0$ otherwise.\n\nTest Suite:\nUse the following test cases to assess the implementation, each specified as a tuple $(r,\\Gamma,\\rho,\\epsilon_{\\rm cons},K,f_{\\rm min})$.\n\n- Case A (happy path, away from ISCO): $(10.0,\\;4/3,\\;1.0,\\;0.3,\\;K_{\\rm A},\\;10^{-6})$, with $K_{\\rm A}$ chosen consistent with the ideal relation $K_{\\rm A} = P_{\\rm cons}/\\rho^{\\Gamma}$ for this case so that no fallback is needed.\n- Case B (strong shock near ISCO with negative $P_{\\rm cons}$): $(6.0,\\;4/3,\\;10.0,\\;-10^{-3},\\;0.5,\\;10^{-6})$, where the entropy-based pressure should be used and be well above the floor.\n- Case C (tenuous cell boundary case, entropy too small): $(6.0,\\;5/3,\\;10^{-8},\\;-10^{-2},\\;10^{-12},\\;10^{-6})$, where both $P_{\\rm cons}$ and $P_{K}$ are below the floor, so the floor must be engaged.\n- Case D (near ISCO with acceptable $P_{\\rm cons}$): $(6.0,\\;4/3,\\;0.3,\\;0.05,\\;10^{-6},\\;10^{-6})$, where $P_{\\rm cons}$ should be accepted and the entropy not used.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list in the order $[P,\\text{used\\_entropy},\\text{used\\_floor}]$. For example, the output must look like\n$$\n[\\,[P_A,\\,e_A,\\,f_A],\\,[P_B,\\,e_B,\\,f_B],\\,[P_C,\\,e_C,\\,f_C],\\,[P_D,\\,e_D,\\,f_D]\\,],\n$$\nwith each $P_X$ a float and each $e_X,f_X$ integers $0$ or $1$.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, and objective. It describes a standard numerical challenge in general relativistic magnetohydrodynamics (GRMHD)—the recovery of primitive variables from conserved quantities—and proposes a widely recognized dual-energy method to ensure the physical admissibility of the pressure. The specified algorithm is clear, complete, and logically consistent.\n\nThe objective is to implement a pressure recovery scheme for an ideal fluid, computing a physically valid pressure $P$ from a set of inputs $(\\Gamma, \\rho, \\epsilon_{\\rm cons}, K, f_{\\rm min})$. The inputs represent the adiabatic index $\\Gamma$, rest-mass density $\\rho$, specific internal energy $\\epsilon_{\\rm cons}$ (derived from conserved variables), an advected entropy tracer $K$, and a flooring coefficient $f_{\\rm min}$. The procedure must also report whether the entropy-based pressure was used and whether a numerical pressure floor was engaged.\n\nThe governing thermodynamical relations for the ideal fluid are the equation of state:\n$$\nP = (\\Gamma - 1)\\,\\rho\\,\\epsilon\n$$\nand the definition of the entropy tracer:\n$$\nK \\equiv \\frac{P}{\\rho^{\\Gamma}}\n$$\nwhere $P$ is the pressure, $\\rho$ is the rest-mass density, $\\epsilon$ is the specific internal energy, and $\\Gamma$ is the constant adiabatic index. The problem uses geometrized units where $G=c=M=1$.\n\nThe recovery algorithm is implemented as a sequence of conditional checks:\n\nStep 1: Compute the pressure from the conserved energy estimate.\nThe specific internal energy $\\epsilon_{\\rm cons}$ estimated from the evolution of conserved variables can sometimes become unphysically small or negative due to numerical errors. The corresponding pressure is calculated as:\n$$\nP_{\\rm cons} = (\\Gamma - 1)\\,\\rho\\,\\epsilon_{\\rm cons}\n$$\n\nStep 2: Define and compute the numerical pressure floor.\nTo prevent singularities in vacuum or near-vacuum regions and to handle other numerical artifacts, a minimum pressure value, or \"floor,\" is established. This floor is proportional to the rest-mass density:\n$$\nP_{\\rm floor} = f_{\\rm min}\\,\\rho\n$$\nwhere $f_{\\rm min}$ is a small, positive constant.\n\nStep 3: Apply the decision logic.\nThe core of the algorithm is a multi-stage check to select the most reliable pressure value while guaranteeing positivity.\n\nThe first condition checks if the energy-based pressure is physically acceptable and above the numerical floor:\n$$\n\\text{Is } P_{\\rm cons} \\ge P_{\\rm floor}?\n$$\n- If `True`: The energy estimate is considered reliable. The final pressure is set to $P = P_{\\rm cons}$. In this case, neither the entropy fallback nor the pressure floor is activated. The status flags are `used_entropy = 0` and `used_floor = 0`.\n\n- If `False`: The energy estimate is unreliable (either too small or negative). This triggers the entropy fallback mechanism, so the `used_entropy` flag is set to $1$. The algorithm then proceeds to the next stage.\n\nStep 4: The Entropy Fallback Path.\nWhen $P_{\\rm cons} < P_{\\rm floor}$, the pressure is recomputed using the advected entropy tracer $K$, which is evolved in a way that preserves its positivity:\n$$\nP_{K} = K\\,\\rho^{\\Gamma}\n$$\nA second condition then checks if this entropy-based pressure is sufficient to clear the numerical floor:\n$$\n\\text{Is } P_{K} \\ge P_{\\rm floor}?\n$$\n- If `True`: The entropy-based pressure is physically reasonable and above the floor. The final pressure is set to $P = P_{K}$. Since the floor value itself was not used for the final pressure, the `used_floor` flag is $0$.\n\n- If `False`: Even the entropy-based pressure is too low, indicating an extremely tenuous or numerically problematic state. In this final case, the pressure is fixed at the minimum allowed value. The final pressure is set to $P = P_{\\rm floor}$, and the `used_floor` flag is set to $1$.\n\nThis logic ensures a strictly positive pressure is always returned. We now apply this procedure to the provided test cases.\n\nCase A: $(r=10.0, \\Gamma=4/3, \\rho=1.0, \\epsilon_{\\rm cons}=0.3, K=K_A, f_{\\rm min}=10^{-6})$.\nFirst, we determine $K_A$ to be consistent with the other parameters:\n$P_{\\rm cons} = (\\frac{4}{3} - 1) \\times 1.0 \\times 0.3 = \\frac{1}{3} \\times 0.3 = 0.1$.\n$K_A = P_{\\rm cons} / \\rho^{\\Gamma} = 0.1 / (1.0)^{4/3} = 0.1$.\nNow we apply the logic:\n- $P_{\\rm floor} = 10^{-6} \\times 1.0 = 10^{-6}$.\n- The condition $P_{\\rm cons} \\ge P_{\\rm floor}$ becomes $0.1 \\ge 10^{-6}$, which is true.\n- Result: $P=0.1$, `used_entropy`=$0$, `used_floor`=$0$.\n\nCase B: $(r=6.0, \\Gamma=4/3, \\rho=10.0, \\epsilon_{\\rm cons}=-10^{-3}, K=0.5, f_{\\rm min}=10^{-6})$.\n- $P_{\\rm cons} = (\\frac{4}{3} - 1) \\times 10.0 \\times (-10^{-3}) = \\frac{1}{3} \\times (-10^{-2}) \\approx -0.00333$.\n- $P_{\\rm floor} = 10^{-6} \\times 10.0 = 10^{-5}$.\n- The condition $P_{\\rm cons} \\ge P_{\\rm floor}$ becomes $-0.00333 \\ge 10^{-5}$, which is false.\n- Entropy fallback is triggered (`used_entropy`=$1$).\n- $P_{K} = 0.5 \\times (10.0)^{4/3} = 0.5 \\times 10^{4/3} \\approx 10.77217$.\n- The condition $P_{K} \\ge P_{\\rm floor}$ becomes $10.77217 \\ge 10^{-5}$, which is true.\n- Result: $P=10.77217345...$, `used_entropy`=$1$, `used_floor`=$0$.\n\nCase C: $(r=6.0, \\Gamma=5/3, \\rho=10^{-8}, \\epsilon_{\\rm cons}=-10^{-2}, K=10^{-12}, f_{\\rm min}=10^{-6})$.\n- $P_{\\rm cons} = (\\frac{5}{3} - 1) \\times 10^{-8} \\times (-10^{-2}) = \\frac{2}{3} \\times (-10^{-10}) \\approx -6.67 \\times 10^{-11}$.\n- $P_{\\rm floor} = 10^{-6} \\times 10^{-8} = 10^{-14}$.\n- The condition $P_{\\rm cons} \\ge P_{\\rm floor}$ becomes $-6.67 \\times 10^{-11} \\ge 10^{-14}$, which is false.\n- Entropy fallback is triggered (`used_entropy`=$1$).\n- $P_{K} = 10^{-12} \\times (10^{-8})^{5/3} = 10^{-12} \\times 10^{-40/3} = 10^{-76/3} \\approx 4.64 \\times 10^{-26}$.\n- The condition $P_{K} \\ge P_{\\rm floor}$ becomes $4.64 \\times 10^{-26} \\ge 10^{-14}$, which is false.\n- The floor is engaged.\n- Result: $P=10^{-14}$, `used_entropy`=$1$, `used_floor`=$1$.\n\nCase D: $(r=6.0, \\Gamma=4/3, \\rho=0.3, \\epsilon_{\\rm cons}=0.05, K=10^{-6}, f_{\\rm min}=10^{-6})$.\n- $P_{\\rm cons} = (\\frac{4}{3} - 1) \\times 0.3 \\times 0.05 = \\frac{1}{3} \\times 0.015 = 0.005$.\n- $P_{\\rm floor} = 10^{-6} \\times 0.3 = 3 \\times 10^{-7}$.\n- The condition $P_{\\rm cons} \\ge P_{\\rm floor}$ becomes $0.005 \\ge 3 \\times 10^{-7}$, which is true.\n- Result: $P=0.005$, `used_entropy`=$0$, `used_floor`=$0$.\n\nThe following program implements this logic to compute the results for the entire test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the robust primitive recovery for pressure in GRMHD\n    and computes the results for the given test suite.\n    \"\"\"\n\n    def solve_case(r, gamma, rho, eps_cons, k_val, f_min):\n        \"\"\"\n        Applies the dual-energy pressure recovery logic for a single cell.\n\n        Args:\n            r (float): Areal radius (for context, not used in this specific logic).\n            gamma (float): Adiabatic index.\n            rho (float): Rest-mass density.\n            eps_cons (float): Specific internal energy from conserved variables.\n            k_val (float): Advected entropy tracer.\n            f_min (float): Pressure floor coefficient.\n\n        Returns:\n            list: A list containing [P, used_entropy, used_floor].\n        \"\"\"\n        p_cons = (gamma - 1.0) * rho * eps_cons\n        p_floor = f_min * rho\n\n        used_entropy = 0\n        used_floor = 0\n        p_final = 0.0\n\n        if p_cons >= p_floor:\n            p_final = p_cons\n            # used_entropy and used_floor remain 0\n        else:\n            used_entropy = 1\n            p_k = k_val * (rho**gamma)\n            \n            if p_k >= p_floor:\n                p_final = p_k\n                # used_floor remains 0\n            else:\n                p_final = p_floor\n                used_floor = 1\n        \n        return [p_final, used_entropy, used_floor]\n\n    # Define the consistent K_A for Case A\n    gamma_A = 4.0 / 3.0\n    rho_A = 1.0\n    eps_cons_A = 0.3\n    p_cons_A = (gamma_A - 1.0) * rho_A * eps_cons_A\n    k_A = p_cons_A / (rho_A**gamma_A)\n\n    # Define the test cases from the problem statement.\n    # Format: (r, Gamma, rho, epsilon_cons, K, f_min)\n    test_cases = [\n        (10.0, 4.0/3.0, 1.0, 0.3, k_A, 1e-6),  # Case A\n        (6.0, 4.0/3.0, 10.0, -1e-3, 0.5, 1e-6), # Case B\n        (6.0, 5.0/3.0, 1e-8, -1e-2, 1e-12, 1e-6),# Case C\n        (6.0, 4.0/3.0, 0.3, 0.05, 1e-6, 1e-6),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Format each inner list as '[p,e,f]' without spaces\n    inner_strings = [f\"[{p},{e},{f}]\" for p, e, f in results]\n    \n    # Final print statement in the exact required format '[[...],[...]]'\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        }
    ]
}