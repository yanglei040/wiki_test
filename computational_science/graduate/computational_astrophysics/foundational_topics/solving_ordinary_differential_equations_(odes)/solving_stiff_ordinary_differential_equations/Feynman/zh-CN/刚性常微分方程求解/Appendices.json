{
    "hands_on_practices": [
        {
            "introduction": "理解刚性问题的最好方法之一是亲手构建一个能够解决它的求解器。本练习将指导您为代表弛豫边界层的典型刚性常微分方程，从头开始推导并实现最简单的隐式方法——隐式欧拉法。通过将您的数值结果与精确解进行比较，您将亲眼见证隐式方法的一个关键优势：即使在刚性参数 $\\epsilon$ 变得极小的情况下，其全局误差对于固定步长 $h$ 仍保持稳定，这一现象被称为刚性精度。",
            "id": "3142218",
            "problem": "给定一个表示弛豫边界层的标量常微分方程(ODE)初值问题：求一个函数 $y:[0,T]\\to\\mathbb{R}$，使得\n$$\ny'(t) \\;=\\; -\\frac{1}{\\epsilon}\\bigl(y(t) - g(t)\\bigr), \\quad t\\in[0,T], \\qquad y(0)=y_0,\n$$\n其中 $g(t)=\\cos(t)$，其参数以弧度为单位，$\\epsilon0$ 是一个刚度参数，$T0$ 是终止时间，$y_0\\in\\mathbb{R}$ 是给定的初值。任务是使用隐式欧拉法进行数值研究，探讨当 $\\epsilon$ 变得很小（刚性弛豫）时，对于固定的步长 $h$，终止时间点的全局误差是否基本上与 $\\epsilon$ 无关。您的程序必须是一个完整、可运行的实现，并且：\n- 从第一性原理推导并实现隐式欧拉时间步进格式，即，通过在均匀网格 $t_n = n h$（其中 $h = T/N$）上离散化初值问题，并在 $t_{n+1}$ 处强制执行导数的后向差商定义和函数求值；在每一步中，必须精确求解一个标量线性方程以得到 $y_{n+1}$，\n- 从带有积分因子的一阶线性ODE出发，通过数学上合理的推导，计算在 $t=T$ 处的精确解，\n- 报告在 $t=T$ 处的绝对全局误差，定义为 $\\lvert y_N - y(T)\\rvert$，其中 $y_N$ 是经过 $N$ 步后的隐式欧拉近似值。\n\n您的推理应基于导数的基本定义、初值问题公式、一阶线性ODE的积分因子，以及作为右端项后向积分的隐式欧拉法定义；不要使用任何预打包的求解器程序。您必须以弧度表示所有角度。不涉及物理单位。\n\n在 $[0,T]$ 上使用步长为 $h$ 的均匀网格（因此 $N=T/h$ 是一个整数），并在此网格上实现隐式欧拉法。对于所有测试用例，强迫项为 $g(t)=\\cos(t)$。\n\n测试套件。对所有情况使用以下固定参数：$T=3$，$h=0.05$（因此 $N=60$）。定义四个测试用例，每个用例由一对 $(\\epsilon,y_0)$ 指定：\n- 用例 1（理想情况）：$(\\epsilon,y_0)=(1,\\,0)$。\n- 用例 2（刚性小参数）：$(\\epsilon,y_0)=(10^{-2},\\,0)$。\n- 用例 3（极刚性边界情况）：$(\\epsilon,y_0)=(10^{-6},\\,0)$。\n- 用例 4（无初始层边界情况）：$(\\epsilon,y_0)=(10^{-2},\\,1)$，注意 $g(0)=\\cos(0)=1$。\n\n对于每个用例，计算在 $t=T$ 处的绝对全局误差，如上定义。您的程序必须生成单行输出，其中包含这四个误差，按用例 1 到 4 的顺序排列，四舍五入到 $10$ 位小数，格式为方括号括起来的逗号分隔列表（例如，$[0.1234567890,0.2345678901,0.3456789012,0.4567890123]$）。",
            "solution": "用户提供的问题是有效的。这是一个来自数值分析领域的适定初值问题，具体涉及刚性常微分方程(ODE)数值方法的行为。所有参数和条件都定义清晰、科学合理且内部一致。\n\n任务是计算对于给定的刚性弛豫问题，隐式欧拉法在终止时间 $T$ 的全局误差。这需要两个主要部分：作为基准的ODE精确解析解，以及通过实现隐式欧拉格式获得的数值解。\n\n### 1. 精确解析解的推导\n\n给定的初值问题是\n$$\ny'(t) = -\\frac{1}{\\epsilon}\\bigl(y(t) - g(t)\\bigr), \\quad t\\in[0,T], \\qquad y(0)=y_0\n$$\n其中 $g(t)=\\cos(t)$。我们可以将这个一阶线性ODE重写为标准形式 $y'(t) + P(t)y(t) = Q(t)$：\n$$\ny'(t) + \\frac{1}{\\epsilon}y(t) = \\frac{1}{\\epsilon}\\cos(t)\n$$\n这里，$P(t) = 1/\\epsilon$ 且 $Q(t) = \\frac{1}{\\epsilon}\\cos(t)$。我们使用积分因子 $\\mu(t)$ 来求解，其定义为：\n$$\n\\mu(t) = \\exp\\left(\\int P(t) \\,dt\\right) = \\exp\\left(\\int \\frac{1}{\\epsilon} \\,dt\\right) = e^{t/\\epsilon}\n$$\n将标准形式的ODE乘以 $\\mu(t)$ 得到：\n$$\ne^{t/\\epsilon}y'(t) + \\frac{1}{\\epsilon}e^{t/\\epsilon}y(t) = \\frac{1}{\\epsilon}e^{t/\\epsilon}\\cos(t)\n$$\n左侧是导数乘积法则 $\\frac{d}{dt}\\bigl(\\mu(t)y(t)\\bigr)$ 的结果：\n$$\n\\frac{d}{dt}\\left(e^{t/\\epsilon}y(t)\\right) = \\frac{1}{\\epsilon}e^{t/\\epsilon}\\cos(t)\n$$\n两边对 $t$ 积分：\n$$\ne^{t/\\epsilon}y(t) = \\int \\frac{1}{\\epsilon}e^{t/\\epsilon}\\cos(t) \\,dt + C\n$$\n其中 $C$ 是积分常数。右侧的积分可以通过两次分部积分法求解。一个标准的积分公式是 $\\int e^{ax}\\cos(bx)dx = \\frac{e^{ax}}{a^2+b^2}(a\\cos(bx)+b\\sin(bx))$。令 $x=t$，$a = 1/\\epsilon$ 和 $b=1$，积分变为：\n\\begin{align*}\n\\int \\frac{1}{\\epsilon}e^{t/\\epsilon}\\cos(t) \\,dt = \\frac{1}{\\epsilon} \\left[ \\frac{e^{t/\\epsilon}}{(1/\\epsilon)^2 + 1^2} \\left(\\frac{1}{\\epsilon}\\cos(t) + \\sin(t)\\right) \\right] \\\\\n= \\frac{1}{\\epsilon} \\left[ \\frac{e^{t/\\epsilon}}{(1+\\epsilon^2)/\\epsilon^2} \\left(\\frac{\\cos(t) + \\epsilon\\sin(t)}{\\epsilon}\\right) \\right] \\\\\n= e^{t/\\epsilon} \\frac{\\cos(t) + \\epsilon\\sin(t)}{1+\\epsilon^2}\n\\end{align*}\n将此结果代回 $y(t)$ 的方程：\n$$\ne^{t/\\epsilon}y(t) = e^{t/\\epsilon} \\frac{\\cos(t) + \\epsilon\\sin(t)}{1+\\epsilon^2} + C\n$$\n通过除以 $e^{t/\\epsilon}$ 解出 $y(t)$：\n$$\ny(t) = \\frac{\\cos(t) + \\epsilon\\sin(t)}{1+\\epsilon^2} + C e^{-t/\\epsilon}\n$$\n我们使用初始条件 $y(0)=y_0$ 来确定常数 $C$：\n$$\ny_0 = y(0) = \\frac{\\cos(0) + \\epsilon\\sin(0)}{1+\\epsilon^2} + C e^{0} = \\frac{1}{1+\\epsilon^2} + C\n$$\n这给出 $C = y_0 - \\frac{1}{1+\\epsilon^2}$。因此，精确解析解是：\n$$\ny(t) = \\frac{\\cos(t) + \\epsilon\\sin(t)}{1+\\epsilon^2} + \\left(y_0 - \\frac{1}{1+\\epsilon^2}\\right)e^{-t/\\epsilon}\n$$\n\n### 2. 隐式欧拉格式的推导\n\n隐式欧拉法是通过将时间域离散化为均匀网格 $t_n = n h$（$n=0, 1, \\dots, N$）推导出来的，其中 $h=T/N$ 是步长。设 $y_n$ 是 $y(t_n)$ 的数值近似。\n\n隐式欧拉法的核心是使用后向差商在下一个时间步 $t_{n+1}$ 处近似导数 $y'(t)$：\n$$\ny'(t_{n+1}) \\approx \\frac{y_{n+1} - y_n}{h}\n$$\n该方法在未来的时间点 $t_{n+1}$ 处强制满足ODE：\n$$\ny'(t_{n+1}) = -\\frac{1}{\\epsilon}\\bigl(y(t_{n+1}) - g(t_{n+1})\\bigr)\n$$\n通过用其近似值 $y_{n+1}$ 替换 $y(t_{n+1})$ 并将两个导数表达式相等，我们得到：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon}(y_{n+1} - g(t_{n+1}))\n$$\n这是一个关于未知值 $y_{n+1}$ 的线性方程，我们必须在每一步中求解它。为了找到更新公式，我们重新整理各项以分离出 $y_{n+1}$：\n\\begin{align*}\ny_{n+1} - y_n = -\\frac{h}{\\epsilon}(y_{n+1} - g(t_{n+1})) \\\\\ny_{n+1} - y_n = -\\frac{h}{\\epsilon}y_{n+1} + \\frac{h}{\\epsilon}g(t_{n+1}) \\\\\ny_{n+1} + \\frac{h}{\\epsilon}y_{n+1} = y_n + \\frac{h}{\\epsilon}g(t_{n+1}) \\\\\ny_{n+1}\\left(1 + \\frac{h}{\\epsilon}\\right) = y_n + \\frac{h}{\\epsilon}g(t_{n+1})\n\\end{align*}\n解出 $y_{n+1}$ 得到隐式欧拉法的显式时间步进公式：\n$$\ny_{n+1} = \\frac{y_n + \\frac{h}{\\epsilon}g(t_{n+1})}{1 + \\frac{h}{\\epsilon}}\n$$\n这可以重写以避免分子项中可能出现的被小 $\\epsilon$ 除的情况：\n$$\ny_{n+1} = \\frac{\\epsilon y_n + h g(t_{n+1})}{\\epsilon + h}\n$$\n从初值 $y_0$ 开始，对 $n=0, 1, \\dots, N-1$ 迭代应用此公式，以求得在终止时间 $t_N = T$ 的数值解 $y_N$。\n\n### 3. 实现与误差计算\n\n该问题要求在固定步长 $h=0.05$（意味着 $N=60$ 步）下，计算终止时间 $T=3$ 处的绝对全局误差。误差定义为 $|y_N - y(T)|$。数值实验测试了四个具有不同刚度参数 $\\epsilon$ 和初值 $y_0$ 的用例。像隐式欧拉法这样的L-稳定方法的一个关键特性是，对于刚性问题（小 $\\epsilon$），在固定步长 $h$ 下，全局误差很大程度上与 $\\epsilon$ 无关，而是由近似解的光滑部分的误差主导。这是我们在比较用例 2（$\\epsilon=10^{-2}$）和用例 3（$\\epsilon=10^{-6}$）的结果时预期观察到的。用例 4 很特殊，因为初始条件 $y_0=1$ 与 $g(0)=1$ 匹配，这消除了初始刚性暂态，如系数 $C=y_0 - \\frac{1}{1+\\epsilon^2}$ 非常小所示。这通常会导致与具有较大初始暂态的用例相比，数值解的精度略高。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stiff relaxation ODE problem using the implicit Euler method\n    and compares the numerical result to the exact analytical solution to find\n    the global error at the final time T for several test cases.\n    \"\"\"\n\n    # Define the fixed parameters from the problem statement.\n    T = 3.0\n    h = 0.05\n    N = int(T / h)  # Number of steps\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (epsilon, y0).\n    test_cases = [\n        (1.0, 0.0),       # Case 1\n        (1e-2, 0.0),      # Case 2\n        (1e-6, 0.0),      # Case 3\n        (1e-2, 1.0)       # Case 4\n    ]\n\n    results = []\n\n    def g(t):\n        \"\"\"The forcing function g(t) = cos(t).\"\"\"\n        return np.cos(t)\n\n    def y_exact(t, epsilon, y0):\n        \"\"\"\n        The exact analytical solution to the ODE.\n        y(t) = (cos(t) + eps*sin(t))/(1+eps^2) + (y0 - 1/(1+eps^2))*exp(-t/eps)\n        \"\"\"\n        term1 = (np.cos(t) + epsilon * np.sin(t)) / (1.0 + epsilon**2)\n        C = y0 - 1.0 / (1.0 + epsilon**2)\n        term2 = C * np.exp(-t / epsilon)\n        return term1 + term2\n\n    # Loop through each test case\n    for epsilon, y0 in test_cases:\n        # --- Numerical Solution (Implicit Euler) ---\n        # Initialize y_n with the initial condition y0.\n        y_n = y0\n        \n        # Iterate N times to reach the final time T.\n        for n in range(N):\n            t_next = (n + 1) * h\n            g_next = g(t_next)\n            \n            # Apply the derived implicit Euler update formula:\n            # y_{n+1} = (epsilon * y_n + h * g(t_{n+1})) / (epsilon + h)\n            y_n = (epsilon * y_n + h * g_next) / (epsilon + h)\n        \n        y_N = y_n # The numerical solution at t=T\n\n        # --- Exact Solution at T ---\n        y_T = y_exact(T, epsilon, y0)\n\n        # --- Global Error Calculation ---\n        # The absolute difference between the numerical and exact solutions at t=T.\n        error = np.abs(y_N - y_T)\n        \n        # Format the result to 10 decimal places as required.\n        results.append(f\"{error:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的隐式方法后，下一步是深入探究其为何如此有效。本练习聚焦于一种更高级的隐式龙格-库塔方法 (Radau IIA)，并要求您手动进行单步计算，以分析其稳定性。通过为标准刚性测试方程 $y' = \\lambda y$ 推导放大因子 $R(z)$，您将从代数层面精确地看到该方法如何有效地抑制刚性模式（对应于 $z=h\\lambda \\ll 0$），即使时间步长远大于系统的最快时间尺度。",
            "id": "3535957",
            "problem": "在模拟与爆发性天体物理环境相关的核反应网络中嵌入的单一反应物种快速达到平衡的过程中，一个常见的线性化刚性模态由标量常微分方程 (ODE) $y'(t) = \\lambda\\, y(t)$ 表示，其中 $\\lambda \\ll 0$。考虑使用 IIA 型两阶 Radau 隐式 Runge–Kutta (IRK) 方法将此模态推进一个时间步长，这是一种在右 Radau 点进行配置的方法。该方法由以下 Butcher 系数指定\n$$\nA = \\begin{pmatrix}\n\\frac{5}{12}  -\\frac{1}{12} \\\\\n\\frac{3}{4}  \\frac{1}{4}\n\\end{pmatrix}, \n\\quad\n\\boldsymbol{b} = \\begin{pmatrix}\n\\frac{3}{4} \\\\\n\\frac{1}{4}\n\\end{pmatrix}, \n\\quad\n\\boldsymbol{c} = \\begin{pmatrix}\n\\frac{1}{3} \\\\\n1\n\\end{pmatrix}.\n$$\n从标准初值公式出发，对于一个一般的自治系统 $y'(t) = f(y)$，其 IRK 阶段方程由下式给出：\n$$\n\\boldsymbol{Y} \\;=\\; y_n \\boldsymbol{e} \\;+\\; h\\, A\\, \\boldsymbol{f}(\\boldsymbol{Y}),\n$$\n其中 $y_n$ 是当前解的值，$h$ 是时间步长，$\\boldsymbol{e}$ 是全一向量，$\\boldsymbol{f}(\\boldsymbol{Y})$ 是阶段导数向量。对于线性刚性测试问题 $f(y) = \\lambda y$，阶段系统成为一个关于阶段向量 $\\boldsymbol{Y}$ 的线性 $2 \\times 2$ 系统。\n\n仅使用这些定义和给定的 Butcher 系数，对标量 ODE $y'(t) = \\lambda y(t)$（其中 $\\lambda = -10^{4}$，步长 $h = 10^{-2}$）执行一个 Radau IIA 步。精确求解该 $2 \\times 2$ 阶段系统，并确定由 $y_{n+1} = R(z)\\, y_n$ 定义的放大因子 $R(z)$，其中 $z = h \\lambda$。将最终的放大因子表示为一个精确的有理数（不要四舍五入）。",
            "solution": "该问题是适定的，在常微分方程数值分析领域有其科学依据。所有必要信息都已提供，并且 Butcher 算表正确地表示了2阶 Radau IIA 方法。该问题是有效的。\n\n对于一个自治常微分方程 $y'(t) = f(y(t))$，隐式 Runge-Kutta (IRK) 方法由阶段方程和解的更新定义。阶段方程由下式给出：\n$$\n\\boldsymbol{Y} = y_n \\boldsymbol{e} + h A \\boldsymbol{f}(\\boldsymbol{Y})\n$$\n其中 $\\boldsymbol{Y} = (Y_1, Y_2)^T$ 是阶段值向量，$y_n$ 是在时间 $t_n$ 的解，$\\boldsymbol{e}=(1, 1)^T$ 是全一向量，$h$ 是时间步长，$A$ 是 Butcher 系数矩阵。然后通过下式更新解：\n$$\ny_{n+1} = y_n + h \\boldsymbol{b}^T \\boldsymbol{f}(\\boldsymbol{Y})\n$$\n其中 $\\boldsymbol{b}$ 是 Butcher 系数向量。\n\n对于线性标量测试问题 $y'(t) = \\lambda y(t)$，函数为 $f(y) = \\lambda y$。阶段方程成为一个关于阶段向量 $\\boldsymbol{Y}$ 的线性系统：\n$$\n\\boldsymbol{Y} = y_n \\boldsymbol{e} + h A (\\lambda \\boldsymbol{Y}) = y_n \\boldsymbol{e} + (h \\lambda) A \\boldsymbol{Y}\n$$\n令 $z = h\\lambda$。方程为：\n$$\n\\boldsymbol{Y} = y_n \\boldsymbol{e} + z A \\boldsymbol{Y}\n$$\n重新整理以求解 $\\boldsymbol{Y}$，我们得到：\n$$\n(\\boldsymbol{I} - zA) \\boldsymbol{Y} = y_n \\boldsymbol{e}\n$$\n这就是要解的 $2 \\times 2$ 阶段系统。使用给定的矩阵 $A$：\n$$\nA = \\begin{pmatrix} \\frac{5}{12}  -\\frac{1}{12} \\\\ \\frac{3}{4}  \\frac{1}{4} \\end{pmatrix}\n$$\n系统矩阵是：\n$$\n\\boldsymbol{I} - zA = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} - z \\begin{pmatrix} \\frac{5}{12}  -\\frac{1}{12} \\\\ \\frac{3}{4}  \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{5z}{12}  \\frac{z}{12} \\\\ -\\frac{3z}{4}  1 - \\frac{z}{4} \\end{pmatrix}\n$$\n为了求解 $\\boldsymbol{Y}$，我们求这个矩阵的逆。首先，我们计算它的行列式：\n$$\n\\det(\\boldsymbol{I} - zA) = \\left(1 - \\frac{5z}{12}\\right)\\left(1 - \\frac{z}{4}\\right) - \\left(\\frac{z}{12}\\right)\\left(-\\frac{3z}{4}\\right)\n$$\n$$\n\\det(\\boldsymbol{I} - zA) = 1 - \\frac{z}{4} - \\frac{5z}{12} + \\frac{5z^2}{48} + \\frac{3z^2}{48} = 1 - \\frac{3z+5z}{12} + \\frac{8z^2}{48} = 1 - \\frac{8z}{12} + \\frac{z^2}{6}\n$$\n$$\n\\det(\\boldsymbol{I} - zA) = 1 - \\frac{2z}{3} + \\frac{z^2}{6}\n$$\n阶段向量的解是 $\\boldsymbol{Y} = (\\boldsymbol{I} - zA)^{-1} y_n \\boldsymbol{e}$。其逆矩阵是：\n$$\n(\\boldsymbol{I} - zA)^{-1} = \\frac{1}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} 1 - \\frac{z}{4}  -\\frac{z}{12} \\\\ \\frac{3z}{4}  1 - \\frac{5z}{12} \\end{pmatrix}\n$$\n乘以 $y_n \\boldsymbol{e}$：\n$$\n\\boldsymbol{Y} = \\frac{y_n}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} 1 - \\frac{z}{4}  -\\frac{z}{12} \\\\ \\frac{3z}{4}  1 - \\frac{5z}{12} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\frac{y_n}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} 1 - \\frac{z}{4} - \\frac{z}{12} \\\\ \\frac{3z}{4} + 1 - \\frac{5z}{12} \\end{pmatrix}\n$$\n$$\n\\boldsymbol{Y} = \\frac{y_n}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} 1 - \\frac{4z}{12} \\\\ 1 + \\frac{4z}{12} \\end{pmatrix} = \\frac{y_n}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} 1 - \\frac{z}{3} \\\\ 1 + \\frac{z}{3} \\end{pmatrix}\n$$\n现在我们计算更新后的解 $y_{n+1}$：\n$$\ny_{n+1} = y_n + h \\boldsymbol{b}^T (\\lambda \\boldsymbol{Y}) = y_n + z \\boldsymbol{b}^T \\boldsymbol{Y}\n$$\n放大因子是 $R(z) = y_{n+1}/y_n$：\n$$\nR(z) = 1 + z \\boldsymbol{b}^T \\frac{\\boldsymbol{Y}}{y_n} = 1 + \\frac{z}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} \\begin{pmatrix} \\frac{3}{4}  \\frac{1}{4} \\end{pmatrix} \\begin{pmatrix} 1 - \\frac{z}{3} \\\\ 1 + \\frac{z}{3} \\end{pmatrix}\n$$\n内积是：\n$$\n\\frac{3}{4}\\left(1 - \\frac{z}{3}\\right) + \\frac{1}{4}\\left(1 + \\frac{z}{3}\\right) = \\frac{3}{4} - \\frac{3z}{12} + \\frac{1}{4} + \\frac{z}{12} = 1 - \\frac{2z}{12} = 1 - \\frac{z}{6}\n$$\n将此代入 $R(z)$ 的表达式中：\n$$\nR(z) = 1 + \\frac{z(1 - z/6)}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} = \\frac{(1 - \\frac{2z}{3} + \\frac{z^2}{6}) + (z - \\frac{z^2}{6})}{1 - \\frac{2z}{3} + \\frac{z^2}{6}}\n$$\n$$\nR(z) = \\frac{1 - \\frac{2z}{3} + z}{1 - \\frac{2z}{3} + \\frac{z^2}{6}} = \\frac{1 + \\frac{z}{3}}{1 - \\frac{2z}{3} + \\frac{z^2}{6}}\n$$\n给定 $\\lambda = -10^4$ 且 $h=10^{-2}$。因此：\n$$\nz = h\\lambda = (10^{-2})(-10^4) = -100\n$$\n我们将这个值代入 $R(z)$ 的表达式中：\n$$\nR(-100) = \\frac{1 + \\frac{-100}{3}}{1 - \\frac{2(-100)}{3} + \\frac{(-100)^2}{6}} = \\frac{1 - \\frac{100}{3}}{1 + \\frac{200}{3} + \\frac{10000}{6}}\n$$\n分子是：\n$$\n1 - \\frac{100}{3} = \\frac{3}{3} - \\frac{100}{3} = -\\frac{97}{3}\n$$\n分母是：\n$$\n1 + \\frac{200}{3} + \\frac{5000}{3} = \\frac{3}{3} + \\frac{200}{3} + \\frac{5000}{3} = \\frac{3+200+5000}{3} = \\frac{5203}{3}\n$$\n因此，放大因子是：\n$$\nR(-100) = \\frac{-\\frac{97}{3}}{\\frac{5203}{3}} = -\\frac{97}{5203}\n$$\n数字 $97$ 是素数。快速检查可知 $5203$ 不能被 $97$ 整除（$5203 = 53 \\times 97 + 62$），所以该分数为最简形式。",
            "answer": "$$\n\\boxed{-\\frac{97}{5203}}\n$$"
        },
        {
            "introduction": "在计算科学实践中，我们常常依赖于高度优化的库求解器。然而，成为一名合格的实践者意味着您需要具备验证这些“黑箱”工具并诊断其行为的能力。本练习模拟了这一真实场景，要求您使用一个标准的刚性求解器（BDF方法）来解决一个在天体物理学中常见的非线性幂律冷却问题。通过与您推导出的解析解进行对比，您将执行一次收敛性研究，以经验性地测量求解器的有效精度阶，并探究在极度刚性条件下可能出现的“降阶”现象。",
            "id": "3535987",
            "problem": "考虑一个关于幂律辐射冷却的无量纲初值问题，该问题被建模为常微分方程 (ODE) $dT/dt=-\\Lambda_{0} T^{\\alpha}$，初始条件为 $T(0)=T_{0}$。其中，$T$ 是无量纲温度，$t$ 是无量纲时间，$\\Lambda_{0}0$ 是一个无量纲冷却系数，$\\alpha \\ge 1$ 是一个无量纲幂律指数，当 $\\alpha$ 较大时会引起刚性。你的任务是为这个 ODE 构建一个半解析基准，用它来验证一个隐式刚性求解器的准确性，并评估当刚性增加时可能出现的阶数降低。\n\n从导数 $dT/dt$ 的基本定义和分离变量法出发，推导出适用于此类右端项的闭式解 $T(t)$（不引入任何未经检验的公式）。使用该解作为参考，以量化一个刚性求解器在指定最终时间的全局误差。使用向后差分公式 (BDF) 方法（向后差分公式 (BDF) 是一类广泛用于刚性问题的隐式线性多步法），并提供用户提供的解析雅可比矩阵，来对该 ODE 进行积分，以获得在一系列严格的相对容差下的 $T(t_{\\mathrm{f}})$。对于每个测试用例，通过对三个容差水平上的最终时间误差的对数与相对容差的对数进行最小二乘拟合，计算观测到的收敛率。将拟合的斜率解释为有效阶数的经验指标，并评估当 $\\alpha$ 较大时发生的阶数降低。\n\n所有变量和参数都是无量纲的，因此不需要物理单位。不涉及角度。\n\n实现一个程序，为每个测试用例执行以下操作：\n- 使用带有提供的解析雅可比矩阵 $\\partial f/\\partial T$ 的 BDF 求解器，将 ODE 从 $t=0$ 积分到 $t=t_{\\mathrm{f}}$。\n- 使用三个相对容差 $10^{-3}$、$10^{-5}$ 和 $10^{-7}$，以及一个固定的绝对容差 $10^{-12}$。\n- 对于每个容差，计算在 $t=t_{\\mathrm{f}}$ 时相对于通过分离变量法推导出的精确解的绝对误差。\n- 对三个容差水平上的 $(\\log(\\mathrm{rtol}), \\log(\\mathrm{error}))$ 进行直线拟合，并报告该测试用例拟合斜率的绝对值，作为一个浮点数。\n\n测试套件：\n- 用例 A (基准线性非刚性参考): $\\Lambda_{0}=1$, $\\alpha=1$, $T_{0}=2$, $t_{\\mathrm{f}}=1$。\n- 用例 B (中等刚性): $\\Lambda_{0}=1$, $\\alpha=4$, $T_{0}=2$, $t_{\\mathrm{f}}=1$。\n- 用例 C (非常刚性的瞬态): $\\Lambda_{0}=1$, $\\alpha=20$, $T_{0}=2$, $t_{\\mathrm{f}}=1$。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序包含用例 A、B 和 C 的三个拟合斜率，表示为十进制数。例如：$[s_{A},s_{B},s_{C}]$。\n\n因此，最终输出必须是严格符合以下格式的单行：$[s_{A},s_{B},s_{C}]$，其中每个 $s$ 是按上述规定计算的浮点数。",
            "solution": "该问题提出了一个来自计算天体物理学的适定的初值问题 (IVP)，适合进行严格的数值分析。它具有科学依据，使用了标准的幂律模型来描述辐射冷却；并且方法上是合理的，提出了一个标准技术来评估刚性 ODE 求解器的收敛性和阶数。问题陈述完整且明确，允许直接和可验证的求解。\n\n问题的核心是关于温度 $T$ 作为时间 $t$ 的函数的无量纲 ODE：\n$$\n\\frac{dT}{dt} = -\\Lambda_{0} T^{\\alpha}\n$$\n初始条件为 $T(0)=T_{0}$。参数为冷却系数 $\\Lambda_{0}  0$ 和幂律指数 $\\alpha \\ge 1$。\n\n第一步是推导精确的解析解 $T(t)$，它将作为评估数值求解器准确性的基准真相。该 ODE 是可分离的，可以如下积分：\n$$\n\\int_{T_{0}}^{T(t)} T'^{-\\alpha} dT' = \\int_{0}^{t} -\\Lambda_{0} dt'\n$$\n解取决于指数 $\\alpha$ 的值。\n\n对于 $\\alpha = 1$ 的情况，ODE 是线性的：\n$$\n\\int_{T_{0}}^{T(t)} \\frac{1}{T'} dT' = [\\ln T']_{T_{0}}^{T(t)} = \\ln\\left(\\frac{T(t)}{T_{0}}\\right)\n$$\n右侧计算结果为 $-\\Lambda_{0} t$。令两边相等并求解 $T(t)$，得到指数衰减解：\n$$\nT(t) = T_{0} e^{-\\Lambda_{0} t} \\quad (\\text{对于 } \\alpha=1)\n$$\n\n对于 $\\alpha  1$ 的情况，积分得到：\n$$\n\\int_{T_{0}}^{T(t)} T'^{-\\alpha} dT' = \\left[\\frac{T'^{1-\\alpha}}{1-\\alpha}\\right]_{T_{0}}^{T(t)} = \\frac{T(t)^{1-\\alpha} - T_{0}^{1-\\alpha}}{1-\\alpha}\n$$\n令此式等于 $-\\Lambda_{0} t$ 并整理以求解 $T(t)$：\n$$\nT(t)^{1-\\alpha} = T_{0}^{1-\\alpha} - (1-\\alpha)\\Lambda_{0} t = T_{0}^{1-\\alpha} + (\\alpha-1)\\Lambda_{0} t\n$$\n$$\nT(t) = \\left[ T_{0}^{1-\\alpha} + (\\alpha-1)\\Lambda_{0} t \\right]^{\\frac{1}{1-\\alpha}} \\quad (\\text{对于 } \\alpha1)\n$$\n这些闭式解为分析提供了所需的精确基准。\n\n数值解将使用向后差分公式 (BDF) 方法获得，该方法专为刚性 ODE 设计。我们将使用 `scipy.integrate.solve_ivp` 提供的实现，并设置 `method='BDF'`。对于非线性刚性问题，提供右端项函数的解析雅可比矩阵能显著提高求解器的效率和鲁棒性。对于函数 $f(t, T) = -\\Lambda_{0} T^{\\alpha}$，雅可比矩阵 $J$ 是关于 $T$ 的标量导数：\n$$\nJ = \\frac{\\partial f}{\\partial T} = -\\Lambda_{0} \\alpha T^{\\alpha-1}\n$$\n\n对求解器性能的分析基于测量其收敛率。对于一个表现良好的自适应求解器，最终时间 $t_{\\mathrm{f}}$ 的全局误差 $\\epsilon$ 预计与请求的相对容差 `rtol` 成正比。这意味着存在关系 $\\epsilon \\approx C \\cdot (\\text{rtol})$，其中容差的指数为 $1$。对此关系取对数，我们得到 $\\log(\\epsilon) \\approx \\log(\\mathrm{rtol}) + \\log(C)$，这描述了一条斜率为 $1$ 的直线。通过对经验数据点 $(\\log(\\mathrm{rtol}), \\log(\\epsilon))$ 进行线性拟合，我们可以测量有效的收敛阶数。斜率偏离 $1$ 表示非理想行为。\n\nODE 的刚性由雅可比矩阵的模 $|\\lambda| = |J| = \\Lambda_{0} \\alpha T^{\\alpha-1}$ 来表征。\n-   对于用例 A ($\\alpha=1$)，$\\lambda$ 是常数，问题非刚性。我们预计测得的斜率会接近 $1$。\n-   对于用例 B ($\\alpha=4$) 和 C ($\\alpha=20$)，在 $t=0$ 时的初始值 $|\\lambda|$ 很大，表明存在一个快速的刚性瞬态。对于极端刚性的用例 C，预计会发生一种称为*阶数降低*的现象。当高阶隐式方法在非常刚性的问题上未能达到其理论收敛阶数时，就会发生这种情况，导致测得的斜率显著小于 $1$。\n\n每个测试用例的算法如下：\n$1$. 设置参数 $\\Lambda_{0}$、$\\alpha$、$T_{0}$ 和 $t_{\\mathrm{f}}$。\n$2$. 对于集合 $\\{10^{-3}, 10^{-5}, 10^{-7}\\}$ 中的每个相对容差，使用 BDF 求解器、解析雅可比矩阵和固定的绝对容差 $10^{-12}$，将 ODE 从 $t=0$ 积分到 $t=t_{\\mathrm{f}}$。\n$3$. 在 $t=t_{\\mathrm{f}}$ 处，计算数值解与精确解析解之间的绝对误差。\n$4$. 对三个数据点 $(\\log(\\mathrm{rtol}), \\log(\\mathrm{error}))$ 进行线性最小二乘拟合。\n$5$. 该拟合的斜率的绝对值即为该测试用例的结果。\n对所有三个测试用例重复此过程以生成最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the empirical convergence rate for a stiff ODE solver\n    on a power-law cooling problem across three test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Lambda0, alpha, T0, t_final)\n    test_cases = [\n        (1.0, 1.0, 2.0, 1.0),  # Case A: Non-stiff\n        (1.0, 4.0, 2.0, 1.0),  # Case B: Moderately stiff\n        (1.0, 20.0, 2.0, 1.0) # Case C: Very stiff\n    ]\n\n    # Define the set of relative tolerances for the convergence study.\n    rtols = np.array([1e-3, 1e-5, 1e-7])\n    # Define the fixed absolute tolerance.\n    atol = 1e-12\n\n    results = []\n    for case in test_cases:\n        Lambda0, alpha, T0, tf = case\n\n        # Define the ODE function, f(t, y), where y is a vector.\n        # The problem is scalar, so we use y[0].\n        def ode_func(t, y):\n            return [-Lambda0 * y[0]**alpha]\n\n        # Define the analytical Jacobian of the ODE function, df/dy.\n        # For a scalar problem, this is a 1x1 matrix.\n        def jac_func(t, y):\n            return [[-Lambda0 * alpha * y[0]**(alpha - 1.0)]]\n\n        # Define the exact analytical solution T(t).\n        def analytic_solution(t):\n            if np.isclose(alpha, 1.0):\n                # Solution for alpha = 1\n                return T0 * np.exp(-Lambda0 * t)\n            else:\n                # Solution for alpha > 1\n                # The exponent (1.0 - alpha) is negative, so this is well-defined.\n                base = T0**(1.0 - alpha) + (alpha - 1.0) * Lambda0 * t\n                return base**(1.0 / (1.0 - alpha))\n\n        # Calculate the exact solution at the final time for error computation.\n        T_exact_f = analytic_solution(tf)\n\n        errors = []\n        for rtol in rtols:\n            # Integrate the ODE using the BDF method with the supplied Jacobian.\n            # We only need the solution at the final time t_f.\n            sol = solve_ivp(\n                fun=ode_func,\n                t_span=[0, tf],\n                y0=[T0],\n                method='BDF',\n                jac=jac_func,\n                rtol=rtol,\n                atol=atol,\n                t_eval=[tf]\n            )\n            \n            # Extract the numerical solution at t_f.\n            T_num_f = sol.y[0, -1]\n            \n            # Compute the absolute error against the exact solution.\n            error = np.abs(T_num_f - T_exact_f)\n            errors.append(error)\n        \n        # To find the convergence rate, we fit a line to log(error) vs. log(rtol).\n        # The slope of this line is the empirical order of convergence.\n        log_rtols = np.log(rtols)\n        log_errors = np.log(np.array(errors))\n        \n        # Perform a linear least-squares fit (degree 1 polynomial).\n        # np.polyfit returns coefficients [slope, intercept].\n        slope, _ = np.polyfit(log_rtols, log_errors, 1)\n        \n        # The problem asks for the absolute value of the slope.\n        results.append(abs(slope))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}