{
    "hands_on_practices": [
        {
            "introduction": "Understanding a numerical method begins with its fundamental principles. This first exercise grounds you in the construction of Newton-Cotes quadrature rules by exploring their core idea: approximating an integrand with a simpler function—a polynomial—and integrating that approximation exactly. You will derive the weights for the most basic closed Newton-Cotes formula, the trapezoidal rule, by explicitly constructing and integrating the linear Lagrange interpolating polynomials, demystifying how quadrature weights are determined.",
            "id": "3526428",
            "problem": "In radiative transfer for a plane-parallel stellar atmosphere, the emergent flux can be written as an angular integral of the specific intensity over the direction cosine. More generally, many line-of-sight integrals in computational astrophysics reduce to one-dimensional definite integrals of the form $\\int_{a}^{b} f(x) \\, dx$ that must be evaluated numerically with strict control of discretization error.\n\nConsider a closed Newton–Cotes quadrature rule on the interval $\\left[a,b\\right]$ with $n+1$ equally spaced nodes including the endpoints. Let the nodes be $x_{i} = a + i h$ for $i = 0,1,\\dots,n$, where $h = \\left(b-a\\right)/n$. The closed Newton–Cotes rule approximates the integral by a weighted sum of function values at the nodes, with weights chosen so that the rule reproduces integrals of all polynomials up to degree $n$ exactly.\n\nDefine the quadrature weights in this setting starting from the fundamental polynomial interpolation idea: represent a function by its Lagrange interpolant built on the nodes and integrate the interpolant. Then, specializing to the case $n=1$ (two nodes at the endpoints $x_{0}=a$ and $x_{1}=b$), derive the trapezoidal rule weights by explicitly integrating the first-degree Lagrange basis functions associated with these two nodes.\n\nState your final answer as a row vector containing the two trapezoidal weights $\\left[w_{0}\\;\\;w_{1}\\right]$ as a function of $a$ and $b$. Your final answer must be a single analytic expression. Do not include units. Do not round.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard derivation in numerical analysis.\n\nThe objective is to derive the weights for the $n=1$ closed Newton–Cotes quadrature rule, commonly known as the trapezoidal rule, for approximating the definite integral $\\int_{a}^{b} f(x) \\, dx$. The derivation proceeds by integrating the Lagrange interpolating polynomial that approximates the function $f(x)$ over the interval $[a, b]$.\n\nA general closed Newton–Cotes formula with $n+1$ nodes approximates the integral as a weighted sum of function values at these nodes:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\sum_{i=0}^{n} w_i f(x_i)\n$$\nThe nodes $x_i$ are equally spaced within the interval $[a, b]$, given by $x_i = a + ih$ for $i = 0, 1, \\dots, n$, where the step size is $h = \\frac{b-a}{n}$. The weights $w_i$ are determined by approximating $f(x)$ with its unique Lagrange interpolating polynomial $P_n(x)$ of degree at most $n$ that passes through the $n+1$ points $(x_i, f(x_i))$. The polynomial is given by:\n$$\nP_n(x) = \\sum_{i=0}^{n} f(x_i) L_{n,i}(x)\n$$\nwhere $L_{n,i}(x)$ are the Lagrange basis polynomials, defined as:\n$$\nL_{n,i}(x) = \\prod_{\\substack{j=0 \\\\ j \\neq i}}^{n} \\frac{x-x_j}{x_i-x_j}\n$$\nIntegrating this polynomial approximation of $f(x)$ gives the approximation for the integral:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx \\int_{a}^{b} P_n(x) \\, dx = \\int_{a}^{b} \\sum_{i=0}^{n} f(x_i) L_{n,i}(x) \\, dx\n$$\nSince the function values $f(x_i)$ are constants with respect to the integration variable $x$, we can write:\n$$\n\\int_{a}^{b} P_n(x) \\, dx = \\sum_{i=0}^{n} f(x_i) \\left( \\int_{a}^{b} L_{n,i}(x) \\, dx \\right)\n$$\nBy comparing this with the quadrature formula $\\sum_{i=0}^{n} w_i f(x_i)$, we identify the weights $w_i$ as the integrals of the corresponding Lagrange basis polynomials:\n$$\nw_i = \\int_{a}^{b} L_{n,i}(x) \\, dx\n$$\nWe now specialize to the case $n=1$, which corresponds to the trapezoidal rule. For $n=1$, we have $n+1=2$ nodes. The nodes are the endpoints of the interval:\n$x_0 = a + 0 \\cdot \\frac{b-a}{1} = a$\n$x_1 = a + 1 \\cdot \\frac{b-a}{1} = b$\n\nThe two corresponding first-degree Lagrange basis polynomials are:\n$L_{1,0}(x) = \\frac{x-x_1}{x_0-x_1} = \\frac{x-b}{a-b}$\n$L_{1,1}(x) = \\frac{x-x_0}{x_1-x_0} = \\frac{x-a}{b-a}$\n\nNow, we compute the weights $w_0$ and $w_1$ by integrating these basis polynomials over the interval $[a, b]$.\n\nFor the weight $w_0$:\n$$\nw_0 = \\int_{a}^{b} L_{1,0}(x) \\, dx = \\int_{a}^{b} \\frac{x-b}{a-b} \\, dx\n$$\nThe term $\\frac{1}{a-b}$ is a constant and can be factored out:\n$$\nw_0 = \\frac{1}{a-b} \\int_{a}^{b} (x-b) \\, dx = \\frac{1}{a-b} \\left[ \\frac{x^2}{2} - bx \\right]_{a}^{b}\n$$\nEvaluating the antiderivative at the limits of integration:\n$$\nw_0 = \\frac{1}{a-b} \\left( \\left(\\frac{b^2}{2} - b \\cdot b\\right) - \\left(\\frac{a^2}{2} - b \\cdot a\\right) \\right)\n$$\n$$\nw_0 = \\frac{1}{a-b} \\left( \\frac{b^2}{2} - b^2 - \\frac{a^2}{2} + ab \\right) = \\frac{1}{a-b} \\left( -\\frac{b^2}{2} - \\frac{a^2}{2} + ab \\right)\n$$\nFactoring out $-\\frac{1}{2}$:\n$$\nw_0 = \\frac{1}{a-b} \\left( -\\frac{1}{2} (b^2 + a^2 - 2ab) \\right) = \\frac{1}{-(b-a)} \\left( -\\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_0 = \\frac{b-a}{2}\n$$\n\nFor the weight $w_1$:\n$$\nw_1 = \\int_{a}^{b} L_{1,1}(x) \\, dx = \\int_{a}^{b} \\frac{x-a}{b-a} \\, dx\n$$\nThe term $\\frac{1}{b-a}$ is a constant:\n$$\nw_1 = \\frac{1}{b-a} \\int_{a}^{b} (x-a) \\, dx = \\frac{1}{b-a} \\left[ \\frac{x^2}{2} - ax \\right]_{a}^{b}\n$$\nEvaluating at the limits:\n$$\nw_1 = \\frac{1}{b-a} \\left( \\left(\\frac{b^2}{2} - a \\cdot b\\right) - \\left(\\frac{a^2}{2} - a \\cdot a\\right) \\right)\n$$\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab - \\frac{a^2}{2} + a^2 \\right) = \\frac{1}{b-a} \\left( \\frac{b^2}{2} - ab + \\frac{a^2}{2} \\right)\n$$\nFactoring out $\\frac{1}{2}$:\n$$\nw_1 = \\frac{1}{b-a} \\left( \\frac{1}{2} (b^2 - 2ab + a^2) \\right) = \\frac{1}{b-a} \\left( \\frac{1}{2} (b-a)^2 \\right)\n$$\n$$\nw_1 = \\frac{b-a}{2}\n$$\nThus, the weights for the trapezoidal rule ($n=1$ closed Newton-Cotes) are $w_0 = \\frac{b-a}{2}$ and $w_1 = \\frac{b-a}{2}$. The quadrature rule is:\n$$\n\\int_{a}^{b} f(x) \\, dx \\approx w_0 f(x_0) + w_1 f(x_1) = \\frac{b-a}{2} f(a) + \\frac{b-a}{2} f(b) = \\frac{b-a}{2} (f(a) + f(b))\n$$\nThe final answer is the row vector of these two weights.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{b-a}{2} & \\frac{b-a}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While Newton-Cotes rules are intuitive, they are not always the most efficient, a key consideration in computational astrophysics. Gaussian quadrature rules offer significantly higher accuracy for the same number of function evaluations by optimally choosing not only the weights but also the node locations. This practice delves into this optimization by having you derive the 3-point Gauss-Legendre nodes and weights from first principles, enforcing the condition of maximal polynomial exactness for degree up to $5$.",
            "id": "3526485",
            "problem": "In many radiative transfer computations in computational astrophysics, angular integrals over the cosine of the polar angle, denoted by $\\mu$, appear in moment closures and flux calculations. When the angular dependence of a quantity is sufficiently smooth, it can be accurately approximated by a polynomial in $\\mu$. Consider constructing a quadrature on the interval $[-1,1]$ that is exact for all polynomials in $x$ of degree up to $5$, which is the defining property of $n=3$ Gauss-Legendre quadrature. Starting from the definition of Gaussian quadrature as a quadrature with $n$ nodes and weights chosen to integrate polynomials up to degree $2n-1$ exactly, and using only fundamental facts about integrals of monomials on symmetric intervals and polynomial exactness, derive the nodes $\\{\\xi_{i}\\}_{i=1}^{3}$ and weights $\\{w_{i}\\}_{i=1}^{3}$ of the $n=3$ Gauss-Legendre rule on $[-1,1]$. Then, verify that the weights are strictly positive and that their sum equals $2$, consistent with integrating the constant function. Express the final nodes and weights in exact symbolic form. The final answer must be a single row matrix containing the three nodes followed by the three weights.",
            "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It poses a standard, solvable problem in numerical analysis with a clear context in computational astrophysics. All necessary information is provided, and the task is to derive a known result from first principles.\n\nThe goal is to determine the nodes $\\{\\xi_{i}\\}_{i=1}^{3}$ and weights $\\{w_{i}\\}_{i=1}^{3}$ for a $3$-point numerical quadrature rule on the interval $[-1, 1]$ that is exact for all polynomials of degree up to $2n-1 = 2(3)-1 = 5$. The quadrature rule has the form:\n$$\n\\int_{-1}^{1} f(x) dx \\approx \\sum_{i=1}^{3} w_i f(\\xi_i)\n$$\nFor the rule to be exact for a polynomial $P(x)$, the following equality must hold:\n$$\n\\int_{-1}^{1} P(x) dx = \\sum_{i=1}^{3} w_i P(\\xi_i)\n$$\nWe have six unknowns: three nodes $(\\xi_1, \\xi_2, \\xi_3)$ and three weights $(w_1, w_2, w_3)$. To solve for these, we require the rule to be exact for a basis of the space of polynomials of degree up to $5$. The monomial basis $\\{x^0, x^1, x^2, x^3, x^4, x^5\\}$ is a convenient choice. This yields a system of six equations:\n$$\n\\int_{-1}^{1} x^k dx = \\sum_{i=1}^{3} w_i \\xi_i^k \\quad \\text{for } k = 0, 1, 2, 3, 4, 5\n$$\nFirst, let us evaluate the integrals on the left-hand side. For a general integer $k \\ge 0$:\n$$\n\\int_{-1}^{1} x^k dx = \\left[ \\frac{x^{k+1}}{k+1} \\right]_{-1}^{1} = \\frac{1^{k+1} - (-1)^{k+1}}{k+1}\n$$\nIf $k$ is an odd integer, $k+1$ is even, and the integral is $\\frac{1-1}{k+1} = 0$.\nIf $k$ is an even integer, $k+1$ is odd, and the integral is $\\frac{1-(-1)}{k+1} = \\frac{2}{k+1}$.\nThe required integrals are:\n$k=0: \\int_{-1}^{1} 1 dx = 2$\n$k=1: \\int_{-1}^{1} x dx = 0$\n$k=2: \\int_{-1}^{1} x^2 dx = \\frac{2}{3}$\n$k=3: \\int_{-1}^{1} x^3 dx = 0$\n$k=4: \\int_{-1}^{1} x^4 dx = \\frac{2}{5}$\n$k=5: \\int_{-1}^{1} x^5 dx = 0$\n\nThe integration interval $[-1, 1]$ is symmetric about $x=0$. This property strongly suggests that the nodes and weights should also be symmetric. Let us order the nodes such that $\\xi_1 < \\xi_2 < \\xi_3$. For symmetry, we must have one node at the center, $\\xi_2 = 0$, and the other two nodes placed symmetrically around it, $\\xi_3 = -\\xi_1$. The weights corresponding to the symmetric nodes must be equal, so $w_3 = w_1$. This reduces the number of unknowns from six to three: $\\xi_3>0$, $w_1$, and $w_2$.\n\nLet's rewrite the system of equations with these symmetry assumptions. The nodes are $\\{-\\xi_3, 0, \\xi_3\\}$ and the weights are $\\{w_1, w_2, w_1\\}$.\nFor $k=0$:\n$w_1 (-\\xi_3)^0 + w_2 (0)^0 + w_1 (\\xi_3)^0 = w_1 + w_2 + w_1 = 2w_1 + w_2 = 2$\nFor $k=1$:\n$w_1 (-\\xi_3)^1 + w_2 (0)^1 + w_1 (\\xi_3)^1 = -w_1\\xi_3 + 0 + w_1\\xi_3 = 0$. This matches the integral value, so the symmetry assumption is consistent.\nFor $k=2$:\n$w_1 (-\\xi_3)^2 + w_2 (0)^2 + w_1 (\\xi_3)^2 = w_1\\xi_3^2 + 0 + w_1\\xi_3^2 = 2w_1\\xi_3^2 = \\frac{2}{3}$\nFor $k=3$:\n$w_1 (-\\xi_3)^3 + w_2 (0)^3 + w_1 (\\xi_3)^3 = -w_1\\xi_3^3 + 0 + w_1\\xi_3^3 = 0$. This is also consistent.\nFor $k=4$:\n$w_1 (-\\xi_3)^4 + w_2 (0)^4 + w_1 (\\xi_3)^4 = w_1\\xi_3^4 + 0 + w_1\\xi_3^4 = 2w_1\\xi_3^4 = \\frac{2}{5}$\nFor $k=5$:\n$w_1 (-\\xi_3)^5 + w_2 (0)^5 + w_1 (\\xi_3)^5 = -w_1\\xi_3^5 + 0 + w_1\\xi_3^5 = 0$. Also consistent.\n\nWe are left with a system of three non-linear equations for the three unknowns $\\xi_3$, $w_1$, and $w_2$:\n1. $2w_1 + w_2 = 2$\n2. $2w_1\\xi_3^2 = \\frac{2}{3} \\implies w_1\\xi_3^2 = \\frac{1}{3}$\n3. $2w_1\\xi_3^4 = \\frac{2}{5} \\implies w_1\\xi_3^4 = \\frac{1}{5}$\n\nWe can solve for $\\xi_3$ by dividing equation (3) by equation (2):\n$$\n\\frac{w_1\\xi_3^4}{w_1\\xi_3^2} = \\frac{1/5}{1/3}\n$$\n$$\n\\xi_3^2 = \\frac{3}{5}\n$$\nSince we chose $\\xi_3 > 0$, we have $\\xi_3 = \\sqrt{\\frac{3}{5}}$.\nThe nodes are therefore $\\xi_1 = -\\sqrt{\\frac{3}{5}}$, $\\xi_2 = 0$, and $\\xi_3 = \\sqrt{\\frac{3}{5}}$.\n\nNow, we solve for the weights. Substitute $\\xi_3^2 = \\frac{3}{5}$ into equation (2):\n$$\nw_1 \\left(\\frac{3}{5}\\right) = \\frac{1}{3}\n$$\n$$\nw_1 = \\frac{1}{3} \\cdot \\frac{5}{3} = \\frac{5}{9}\n$$\nSince $w_3 = w_1$, we have $w_3 = \\frac{5}{9}$.\n\nFinally, use equation (1) to find $w_2$:\n$$\n2w_1 + w_2 = 2\n$$\n$$\n2\\left(\\frac{5}{9}\\right) + w_2 = 2\n$$\n$$\n\\frac{10}{9} + w_2 = \\frac{18}{9}\n$$\n$$\nw_2 = \\frac{18}{9} - \\frac{10}{9} = \\frac{8}{9}\n$$\nSo the nodes are $\\{-\\sqrt{\\frac{3}{5}}, 0, \\sqrt{\\frac{3}{5}}\\}$ and the corresponding weights are $\\{\\frac{5}{9}, \\frac{8}{9}, \\frac{5}{9}\\}$.\n\nThe problem requires verification that the weights are strictly positive and that their sum equals $2$.\nThe weights are $w_1=w_3=\\frac{5}{9}$ and $w_2=\\frac{8}{9}$. All are clearly positive.\nThe sum of the weights is:\n$$\n\\sum_{i=1}^{3} w_i = w_1 + w_2 + w_3 = \\frac{5}{9} + \\frac{8}{9} + \\frac{5}{9} = \\frac{5+8+5}{9} = \\frac{18}{9} = 2\n$$\nThis is consistent with the exact integration of the constant function $f(x)=1$, as $\\int_{-1}^{1} 1 dx = 2$.\nThe derived nodes and weights are correct.\n\nThe final nodes and weights in exact symbolic form are:\nNodes: $\\xi_1 = -\\sqrt{\\frac{3}{5}}$, $\\xi_2 = 0$, $\\xi_3 = \\sqrt{\\frac{3}{5}}$\nWeights: $w_1 = \\frac{5}{9}$, $w_2 = \\frac{8}{9}$, $w_3 = \\frac{5}{9}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -\\sqrt{\\frac{3}{5}} & 0 & \\sqrt{\\frac{3}{5}} & \\frac{5}{9} & \\frac{8}{9} & \\frac{5}{9} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Theoretical exactness for polynomials is a useful benchmark, but real-world integrands with sharp gradients or boundary layers often defy simple polynomial approximation. This computational practice moves from theory to a stress test, comparing the performance of a high-degree Newton-Cotes rule against a composite rule and a Gauss-Legendre rule on an integrand designed to provoke the Runge phenomenon. This exercise provides a crucial lesson in numerical stability, demonstrating why high-degree interpolation on equispaced nodes can be unreliable and why other strategies are often more robust for challenging problems.",
            "id": "3526442",
            "problem": "Consider the synthetic integral that models a sharply localized contribution near the high-end of a normalized thermodynamic variable in computational astrophysics cooling models. Let the integral be $$Q=\\int_{0}^{1} f(x)\\,dx,$$ where the integrand is defined by $$f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}},$$ with parameters $\\varepsilon>0$ controlling the width of a boundary layer near $x=1$ and integer $p\\ge 1$ controlling the steepness of the transition. This family is smooth on $[0,1]$, bounded by $0\\le f\\le 1$, and for small $\\varepsilon$ has large derivatives near $x=1$, which stresses interpolatory quadrature schemes built on equispaced nodes.\n\nYour task is to implement and compare three quadrature strategies under a fixed function-evaluation budget on $[0,1]$:\n\n- A single-panel closed Newton–Cotes rule of degree $n_{\\mathrm{NC}}$ (i.e., using $n_{\\mathrm{NC}}+1$ equispaced nodes on $[0,1]$).\n- A composite low-order Newton–Cotes scheme built from Simpson’s rule on $m$ panels, using $2m+1$ equispaced nodes on $[0,1]$.\n- An $n_{\\mathrm{G}}$-point Gauss–Legendre quadrature on $[0,1]$.\n\nAll methods must use the same number of function evaluations $N_{\\mathrm{eval}}$, with $n_{\\mathrm{NC}}+1=2m+1=n_{\\mathrm{G}}=N_{\\mathrm{eval}}$. You must choose $N_{\\mathrm{eval}}=11$, hence $n_{\\mathrm{NC}}=10$, $m=5$, and $n_{\\mathrm{G}}=11$.\n\nFor verification, use exact analytic expressions for $Q$ in the special cases $p=1$ and $p=2$, which follow from the substitution $u=(1-x)/\\varepsilon$ and are given by\n$$Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right),\\qquad Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right).$$\n\nImplement the three quadrature methods from first principles of polynomial interpolation and orthogonal polynomials, without using any adaptive refinement. You may use standard numerical libraries to obtain weights and nodes for the high-degree closed Newton–Cotes rule and the Gauss–Legendre rule.\n\nTest Suite. Evaluate the absolute quadrature errors $\\left|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}\\right|$ for the following parameter sets:\n- Case A: $(\\varepsilon,p)=(0.2,1)$.\n- Case B: $(\\varepsilon,p)=(0.01,1)$.\n- Case C: $(\\varepsilon,p)=(0.05,2)$.\n- Case D: $(\\varepsilon,p)=(1.0,2)$.\n- Case E: $(\\varepsilon,p)=(0.001,1)$.\n\nFor each case, report a list with three floating-point numbers corresponding to the absolute errors produced by, in order: single-panel degree-$10$ closed Newton–Cotes, composite Simpson with $m=5$ panels, and $11$-point Gauss–Legendre.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three floats for a test case, in the order [Case A, Case B, Case C, Case D, Case E]. For example, a valid output format is\n\"[[eA1,eA2,eA3],[eB1,eB2,eB3],[eC1,eC2,eC3],[eD1,eD2,eD3],[eE1,eE2,eE3]]\"\nwhere each $e\\cdot\\cdot$ is a floating-point number.",
            "solution": "The problem requires the implementation and comparison of three numerical quadrature methods for approximating the integral $Q=\\int_{0}^{1} f(x)\\,dx$, where the integrand is given by $f(x;\\varepsilon,p)=\\frac{1}{1+\\left(\\frac{1-x}{\\varepsilon}\\right)^{p}}$. This function models a sharp transition, or boundary layer, of width controlled by $\\varepsilon>0$ near $x=1$. The steepness of this transition is governed by the integer parameter $p\\ge 1$. For small values of $\\varepsilon$, the integrand's derivatives become large near $x=1$, posing a challenge for numerical integration schemes, particularly those based on equispaced nodes.\n\nThe comparison will be performed under a fixed budget of $N_{\\mathrm{eval}}=11$ function evaluations for each method. The three methods are:\n1.  A single-panel closed Newton–Cotes rule of degree $n_{\\mathrm{NC}}=10$.\n2.  A composite Simpson’s rule over $m=5$ panels.\n3.  An $n_{\\mathrm{G}}=11$-point Gauss–Legendre quadrature.\n\nNote that the number of nodes for each method is consistent with the budget: $n_{\\mathrm{NC}}+1 = 10+1=11$, $2m+1 = 2(5)+1=11$, and $n_{\\mathrm{G}}=11$.\n\nThe accuracy of each method is assessed by computing the absolute error $|Q_{\\mathrm{approx}}-Q_{\\mathrm{exact}}|$ for several test cases. The exact value of the integral is provided for the special cases $p=1$ and $p=2$, which correspond to all test cases.\nFor $p=1$: $Q(\\varepsilon,1)=\\varepsilon\\,\\ln\\!\\left(1+\\frac{1}{\\varepsilon}\\right)$.\nFor $p=2$: $Q(\\varepsilon,2)=\\varepsilon\\,\\arctan\\!\\left(\\frac{1}{\\varepsilon}\\right)$.\n\nFor small $\\varepsilon$, the integrand $f(x)$ develops a sharp boundary layer near $x=1$. Quadrature schemes using equispaced nodes, such as the single-panel Newton-Cotes and composite Simpson's rules, are expected to perform poorly as they may not place enough sample points within this narrow region of rapid change. In contrast, Gauss-Legendre quadrature, which clusters nodes near the endpoints of the integration interval, is expected to provide a more accurate approximation by better resolving the feature at $x=1$.\n\nThe implementation of each method from first principles is detailed below.\n\n### Method 1: Single-Panel Degree-10 Closed Newton–Cotes Rule\n\nThis method approximates the integral by integrating a single interpolating polynomial of degree $n_{\\mathrm{NC}}=10$ that passes through $N_{\\mathrm{eval}}=11$ equally spaced points on the interval $[0,1]$.\nThe nodes are given by $x_i = a + i \\cdot h$ for $i=0, 1, \\dots, n_{\\mathrm{NC}}$, where the interval is $[a,b]=[0,1]$ and the step size is $h=(b-a)/n_{\\mathrm{NC}} = (1-0)/10 = 0.1$. Thus, $x_i = i/10$.\nThe quadrature formula is:\n$$ Q_{\\mathrm{NC}} = \\int_0^1 f(x) dx \\approx h \\sum_{i=0}^{n_{\\mathrm{NC}}} C_i^{(n_{\\mathrm{NC}})} f(x_i) $$\nThe Newton-Cotes coefficients, $C_i^{(n_{\\mathrm{NC}})}$, are derived from the integral of Lagrange basis polynomials. As permitted, these coefficients are obtained using a standard numerical library function, specifically `scipy.integrate.newton_cotes`. For $n_{\\mathrm{NC}}=10$ and the interval $[0,1]$, the integral approximation is calculated with $h=0.1$.\n\n### Method 2: Composite Simpson’s Rule\n\nThis method divides the integration interval $[0,1]$ into $m=5$ panels of equal width. On each panel, the function is approximated by a quadratic polynomial (Simpson's rule).\nThe total number of nodes is $N_{\\mathrm{eval}}=2m+1=11$, which are the same equispaced nodes as in the Newton-Cotes method: $x_i = i/10$ for $i=0, \\dots, 10$. The step size between adjacent nodes is $h=1/10$.\nThe composite Simpson's rule formula is:\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{j=1}^{m} f(x_{2j-1}) + 2\\sum_{j=1}^{m-1} f(x_{2j}) + f(x_{2m}) \\right] $$\nSubstituting $m=5$ and the node indices, the formula becomes:\n$$ Q_{\\mathrm{CS}} = \\frac{h}{3} \\left[ f(x_0) + 4(f(x_1)+f(x_3)+\\dots+f(x_9)) + 2(f(x_2)+f(x_4)+\\dots+f(x_8)) + f(x_{10}) \\right] $$\nThis formula is implemented directly.\n\n### Method 3: 11-Point Gauss–Legendre Quadrature\n\nGauss-Legendre quadrature provides the highest possible degree of precision for a given number of nodes by optimally placing them as the roots of Legendre polynomials. For an $n_{\\mathrm{G}}$-point rule, it exactly integrates polynomials up to degree $2n_{\\mathrm{G}}-1$.\nThe standard Gauss-Legendre rule is defined on the interval $[-1,1]$:\n$$ \\int_{-1}^1 g(\\xi) d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} w_i^{\\mathrm{std}} g(\\xi_i^{\\mathrm{std}}) $$\nwhere $\\xi_i^{\\mathrm{std}}$ are the nodes (roots of the $n_{\\mathrm{G}}$-th Legendre polynomial) and $w_i^{\\mathrm{std}}$ are the corresponding weights.\nTo apply this to the interval $[a,b]=[0,1]$, we use the linear transformation $x = \\frac{b-a}{2}\\xi + \\frac{a+b}{2}$, which for $[0,1]$ becomes $x = \\frac{1}{2}(\\xi+1)$. The differential element transforms as $dx = \\frac{1}{2}d\\xi$.\nThe integral becomes:\n$$ Q_{\\mathrm{GL}} = \\int_0^1 f(x) dx = \\int_{-1}^1 f\\left(\\frac{\\xi+1}{2}\\right) \\frac{1}{2} d\\xi \\approx \\sum_{i=1}^{n_{\\mathrm{G}}} \\left(\\frac{1}{2}w_i^{\\mathrm{std}}\\right) f\\left(\\frac{\\xi_i^{\\mathrm{std}}+1}{2}\\right) $$\nThe transformed nodes on $[0,1]$ are $x_i = (\\xi_i^{\\mathrm{std}}+1)/2$ and the transformed weights are $w_i = w_i^{\\mathrm{std}}/2$. For this problem, $n_{\\mathrm{G}}=11$. The standard nodes and weights are obtained from `numpy.polynomial.legendre.leggauss`.\n\n### Computational Strategy\n\nA Python script will be structured to perform the required calculations. For each of the five test cases defined by $(\\varepsilon,p)$:\n1. The specific integrand $f(x)$ is defined.\n2. The exact integral $Q_{\\mathrm{exact}}$ is calculated using the provided analytical formulas.\n3. The three quadrature approximations ($Q_{\\mathrm{NC}}$, $Q_{\\mathrm{CS}}$, $Q_{\\mathrm{GL}}$) are computed using $N_{\\mathrm{eval}}=11$.\n4. The absolute errors for the three methods are calculated and stored in a list.\n5. The final output is formatted as a list of these error lists, one for each test case, printed to a single line.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import newton_cotes\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements and compares three quadrature strategies on a test integral\n    from computational astrophysics, reporting the absolute errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, p), label\n        (0.2, 1, 'A'),\n        (0.01, 1, 'B'),\n        (0.05, 2, 'C'),\n        (1.0, 2, 'D'),\n        (0.001, 1, 'E'),\n    ]\n\n    # Shared parameters for all methods\n    N_eval = 11\n    a, b = 0.0, 1.0\n\n    all_results = []\n\n    for epsilon, p, _ in test_cases:\n        # 1. Define the integrand and exact solution\n        \n        # The integrand f(x; epsilon, p)\n        f = lambda x: 1.0 / (1.0 + ((1.0 - x) / epsilon)**p)\n\n        # The exact analytic solution Q(epsilon, p)\n        if p == 1:\n            Q_exact = epsilon * np.log(1.0 + 1.0 / epsilon)\n        elif p == 2:\n            Q_exact = epsilon * np.arctan(1.0 / epsilon)\n        else:\n            # This case will not be reached with the given test suite\n            raise ValueError(\"No exact solution provided for p != 1 or 2\")\n\n        # 2. Implement and apply the three quadrature methods\n\n        # Method 1: Single-panel closed Newton-Cotes of degree 10\n        n_nc = 10\n        nodes_nc = np.linspace(a, b, N_eval)\n        evals_nc = f(nodes_nc)\n        weights_nc_coeffs, _ = newton_cotes(n_nc)\n        h_nc = (b - a) / n_nc\n        Q_nc = h_nc * np.sum(weights_nc_coeffs * evals_nc)\n\n        # Method 2: Composite Simpson's rule with m=5 panels\n        m = 5\n        # Nodes are the same as for Newton-Cotes\n        nodes_cs = np.linspace(a, b, N_eval)\n        evals_cs = f(nodes_cs)\n        h_cs = (b - a) / (N_eval - 1)\n        Q_cs = (h_cs / 3.0) * (\n            evals_cs[0] + \n            4.0 * np.sum(evals_cs[1:-1:2]) + \n            2.0 * np.sum(evals_cs[2:-1:2]) + \n            evals_cs[-1]\n        )\n        # Note: evals[1:-1:2] is slightly different from problem description's sum limits\n        # but is correct for Python slicing. It selects all odd indices between 0 and N-1.\n\n        # Method 3: 11-point Gauss-Legendre quadrature\n        n_g = 11\n        nodes_gl_std, weights_gl_std = leggauss(n_g)\n        # Transform nodes and weights from [-1, 1] to [a, b] = [0, 1]\n        nodes_gl = 0.5 * (b - a) * nodes_gl_std + 0.5 * (a + b)\n        weights_gl = 0.5 * (b - a) * weights_gl_std\n        evals_gl = f(nodes_gl)\n        Q_gl = np.sum(weights_gl * evals_gl)\n\n        # 3. Calculate absolute errors\n        error_nc = abs(Q_nc - Q_exact)\n        error_cs = abs(Q_cs - Q_exact)\n        error_gl = abs(Q_gl - Q_exact)\n        \n        case_results = [error_nc, error_cs, error_gl]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Ex: \"[[eA1,eA2,eA3],[eB1,eB2,eB3],...]\"\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}