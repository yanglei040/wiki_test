{
    "hands_on_practices": [
        {
            "introduction": "Before implementing a complex reaction network, it is crucial to ensure the underlying physical data is self-consistent. The energy generated by nuclear fusion, which powers stars, arises directly from the conversion of mass to energy according to the principle of mass-energy equivalence, $E = mc^2$. This practice provides hands-on experience in verifying this principle by calculating reaction Q-values from precise nuclear masses and exploring how these fundamental energies combine in a reaction sequence . You will also clarify the distinct role of nuclear partition functions in determining reaction rate equilibria, rather than the energy release per reaction.",
            "id": "3525259",
            "problem": "A core requirement in building numerically consistent stellar nuclear reaction networks is that nuclear masses, thermally populated excited states (encoded in nuclear partition functions), and tabulated reaction energetics jointly satisfy energy conservation and detailed balance. Consider helium burning that proceeds through two radiative captures: the triple-alpha sequence and subsequent alpha capture on carbon, forming oxygen. You are asked to verify the internal consistency of the nuclear mass data and to compute a specific energy generation rate.\n\nStart from the mass–energy equivalence principle and the definition of nuclear partition functions. Assume a homogeneous zone with temperature $T = 2.0 \\times 10^{8}\\ \\mathrm{K}$ and density $\\rho = 1.00 \\times 10^{5}\\ \\mathrm{g\\,cm^{-3}}$. The network’s net volumetric progress of the composite reaction that converts four alpha particles into one oxygen nucleus is reported in molar form as $r_{\\mathrm{mol}} = 1.000 \\times 10^{-5}\\ \\mathrm{mol\\,cm^{-3}\\,s^{-1}}$. The nuclear partition functions at this temperature are $G(^{4}\\mathrm{He}) = 1.0000$, $G(^{12}\\mathrm{C}) = 1.0003$, and $G(^{16}\\mathrm{O}) = 1.0002$. Atomic masses (in unified atomic mass units) are $m(^{4}\\mathrm{He}) = 4.00260325413\\ \\mathrm{u}$, $m(^{12}\\mathrm{C}) = 12.00000000000\\ \\mathrm{u}$, and $m(^{16}\\mathrm{O}) = 15.99491461957\\ \\mathrm{u}$. Use Avogadro’s number $N_{\\!A} = 6.02214076 \\times 10^{23}\\ \\mathrm{mol^{-1}}$, the conversion $1\\ \\mathrm{u}\\,c^{2} = 931.49410242\\ \\mathrm{MeV}$, and $1\\ \\mathrm{MeV} = 1.602176634 \\times 10^{-6}\\ \\mathrm{erg}$.\n\nTasks:\n1) Using only the atomic masses and mass–energy equivalence, compute the energy release for the two-step helium burning sequence and verify additivity. Specifically, compute the energy releases for the reactions $3\\,^{4}\\mathrm{He} \\rightarrow\\, ^{12}\\mathrm{C} + \\gamma$ and $^{12}\\mathrm{C} +\\, ^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$ and show that their sum equals the direct net reaction $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$ within rounding. Do not assume any provided shortcut formula beyond fundamental principles.\n\n2) Argue from first principles whether the provided nuclear partition functions at temperature $T$ modify the energy released per reaction event, and explain how they are instead involved in detailed balance between forward and reverse rates.\n\n3) Using your deduced net energy release for $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$ and the reported molar volumetric progress $r_{\\mathrm{mol}}$, compute the specific energy generation rate $\\epsilon$ by converting molar progress to reaction events per unit volume per unit time via Avogadro’s number ($N_A$) and then dividing by the mass density $\\rho$.\n\nRound your final answer for $\\epsilon$ to four significant figures. Express the final result in $\\mathrm{erg\\,g^{-1}\\,s^{-1}}$.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\n- **Stellar Conditions**: Homogeneous zone with temperature $T = 2.0 \\times 10^{8}\\ \\mathrm{K}$ and density $\\rho = 1.00 \\times 10^{5}\\ \\mathrm{g\\,cm^{-3}}$.\n- **Nuclear Reactions**:\n  - Triple-alpha: $3\\,^{4}\\mathrm{He} \\rightarrow\\, ^{12}\\mathrm{C} + \\gamma$\n  - Alpha capture: $^{12}\\mathrm{C} +\\, ^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$\n  - Net reaction: $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$\n- **Reaction Progress**: Net molar volumetric progress for the composite reaction $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O}$ is $r_{\\mathrm{mol}} = 1.000 \\times 10^{-5}\\ \\mathrm{mol\\,cm^{-3}\\,s^{-1}}$.\n- **Nuclear Partition Functions**: $G(^{4}\\mathrm{He}) = 1.0000$, $G(^{12}\\mathrm{C}) = 1.0003$, $G(^{16}\\mathrm{O}) = 1.0002$ at the given temperature.\n- **Atomic Masses (u)**:\n  - $m(^{4}\\mathrm{He}) = 4.00260325413\\ \\mathrm{u}$\n  - $m(^{12}\\mathrm{C}) = 12.00000000000\\ \\mathrm{u}$\n  - $m(^{16}\\mathrm{O}) = 15.99491461957\\ \\mathrm{u}$\n- **Physical Constants and Conversions**:\n  - Avogadro's number: $N_{\\!A} = 6.02214076 \\times 10^{23}\\ \\mathrm{mol^{-1}}$\n  - Mass-energy conversion: $1\\ \\mathrm{u}\\,c^{2} = 931.49410242\\ \\mathrm{MeV}$\n  - Energy conversion: $1\\ \\mathrm{MeV} = 1.602176634 \\times 10^{-6}\\ \\mathrm{erg}$\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, situated within the standard framework of nuclear astrophysics. It addresses the calculation of energy release from nuclear reactions via mass-energy equivalence and the subsequent determination of stellar energy generation rates, which are core topics in computational astrophysics. The provided physical constants and nuclear masses are consistent with modern, high-precision values. The problem is well-posed, providing all necessary data for the requested calculations, and is free of contradictions, ambiguities, or subjective claims. It poses a standard, verifiable physics problem.\n\n#### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n### Solution\n\nThe solution is presented in three parts, corresponding to the tasks outlined in the problem statement.\n\n#### 1) Energy Release and Additivity Verification\nThe energy release in a nuclear reaction, known as the Q-value, is derived from the mass–energy equivalence principle, $E=mc^2$. It is the difference between the total rest mass of the reactants and the total rest mass of the products, multiplied by the speed of light squared. The mass of the emitted gamma photon ($\\gamma$) is zero.\n\nThe Q-value for a general reaction $\\sum_i \\nu_i A_i \\rightarrow \\sum_j \\nu_j B_j$ is given by:\n$$\nQ = \\left( \\sum_i \\nu_i m(A_i) - \\sum_j \\nu_j m(B_j) \\right) c^2\n$$\nWe compute the Q-values for the three reactions using the provided atomic masses and conversion factor.\n\nFor the triple-alpha reaction, $3\\,^{4}\\mathrm{He} \\rightarrow\\, ^{12}\\mathrm{C} + \\gamma$:\nThe mass difference is:\n$$\n\\Delta m_1 = 3 \\times m(^{4}\\mathrm{He}) - m(^{12}\\mathrm{C})\n$$\n$$\n\\Delta m_1 = 3 \\times (4.00260325413\\ \\mathrm{u}) - 12.00000000000\\ \\mathrm{u}\n$$\n$$\n\\Delta m_1 = 12.00780976239\\ \\mathrm{u} - 12.00000000000\\ \\mathrm{u} = 0.00780976239\\ \\mathrm{u}\n$$\nThe energy released is:\n$$\nQ_1 = \\Delta m_1 c^2 = 0.00780976239\\ \\mathrm{u} \\times c^2 \\times \\frac{931.49410242\\ \\mathrm{MeV}}{1\\ \\mathrm{u}\\,c^{2}}\n$$\n$$\nQ_1 \\approx 7.2739988\\ \\mathrm{MeV}\n$$\n\nFor the alpha capture on carbon, $^{12}\\mathrm{C} +\\, ^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$:\nThe mass difference is:\n$$\n\\Delta m_2 = m(^{12}\\mathrm{C}) + m(^{4}\\mathrm{He}) - m(^{16}\\mathrm{O})\n$$\n$$\n\\Delta m_2 = 12.00000000000\\ \\mathrm{u} + 4.00260325413\\ \\mathrm{u} - 15.99491461957\\ \\mathrm{u}\n$$\n$$\n\\Delta m_2 = 16.00260325413\\ \\mathrm{u} - 15.99491461957\\ \\mathrm{u} = 0.00768863456\\ \\mathrm{u}\n$$\nThe energy released is:\n$$\nQ_2 = \\Delta m_2 c^2 = 0.00768863456\\ \\mathrm{u} \\times c^2 \\times \\frac{931.49410242\\ \\mathrm{MeV}}{1\\ \\mathrm{u}\\,c^{2}}\n$$\n$$\nQ_2 \\approx 7.1612476\\ \\mathrm{MeV}\n$$\n\nFor the net reaction, $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O} + \\gamma$:\nThe mass difference is:\n$$\n\\Delta m_{\\text{net}} = 4 \\times m(^{4}\\mathrm{He}) - m(^{16}\\mathrm{O})\n$$\n$$\n\\Delta m_{\\text{net}} = 4 \\times (4.00260325413\\ \\mathrm{u}) - 15.99491461957\\ \\mathrm{u}\n$$\n$$\n\\Delta m_{\\text{net}} = 16.01041301652\\ \\mathrm{u} - 15.99491461957\\ \\mathrm{u} = 0.01549839695\\ \\mathrm{u}\n$$\nThe energy released is:\n$$\nQ_{\\text{net}} = \\Delta m_{\\text{net}} c^2 = 0.01549839695\\ \\mathrm{u} \\times c^2 \\times \\frac{931.49410242\\ \\mathrm{MeV}}{1\\ \\mathrm{u}\\,c^{2}}\n$$\n$$\nQ_{\\text{net}} \\approx 14.4352464\\ \\mathrm{MeV}\n$$\n\nTo verify additivity, we sum the energy releases of the two sequential steps and compare to the net reaction's energy release:\n$$\nQ_1 + Q_2 = 7.2739988\\ \\mathrm{MeV} + 7.1612476\\ \\mathrm{MeV} = 14.4352464\\ \\mathrm{MeV}\n$$\nThis sum is identical to the calculated $Q_{\\text{net}}$. The calculation confirms that the energy release is an additive state function, as expected from the conservation of energy. The path from $4$ alpha particles to $1$ oxygen nucleus releases the same total energy regardless of the intermediate $^{12}\\mathrm{C}$ step.\n\n#### 2) Role of Nuclear Partition Functions\nThe energy released per reaction event, the Q-value, is determined solely by the difference in rest masses between the ground states of the reactant and product nuclei. This value is a constant of nature for a given reaction and is independent of thermodynamic conditions such as temperature. Thus, the provided nuclear partition functions, $G(T)$, do not modify the Q-value.\n\nThe role of nuclear partition functions arises in the context of statistical mechanics for a plasma in or near thermal equilibrium. A partition function $G_k(T)$ for a nucleus $k$ is defined as a sum over its energy levels $E_i$ with spin $J_i$:\n$$\nG_k(T) = \\sum_i (2J_i+1) \\exp\\left(-\\frac{E_i}{k_B T}\\right)\n$$\nwhere $k_B$ is the Boltzmann constant. $G_k(T)$ quantifies the statistical weight of the nucleus by accounting for the thermal population of its excited states. If only the ground state (with energy $E_0=0$ and spin $J_0$) is populated, $G_k(T) \\approx 2J_0+1$. As temperature increases, higher-energy states become accessible, and $G_k(T)$ increases. The values provided, $G(^{4}\\mathrm{He}) = 1.0000$, $G(^{12}\\mathrm{C}) = 1.0003$, and $G(^{16}\\mathrm{O}) = 1.0002$, are all slightly greater than $1$, which is consistent with the ground states of these even-even nuclei having spin $J=0$ and a minor but non-zero population of excited states at $T = 2.0 \\times 10^{8}\\ \\mathrm{K}$.\n\nThe primary role of partition functions is in establishing detailed balance between forward and reverse reaction rates. For a reaction $A+B \\leftrightarrow C+D$, the ratio of the forward thermonuclear reaction rate $\\langle \\sigma v \\rangle_{AB \\to CD}$ to the reverse rate $\\langle \\sigma v \\rangle_{CD \\to AB}$ is governed by a Saha-type equation:\n$$\n\\frac{\\langle \\sigma v \\rangle_{AB \\to CD}}{\\langle \\sigma v \\rangle_{CD \\to AB}} = \\frac{G_C G_D}{G_A G_B} \\left(\\frac{m_C m_D}{m_A m_B}\\right)^{3/2} \\left(\\frac{2\\pi k_B T}{h^2}\\right)^{-3/2} \\propto \\frac{G_C G_D}{G_A G_B} \\exp\\left(\\frac{Q}{k_B T}\\right)\n$$\n(with appropriate modification for reaction type). The partition function ratio correctly accounts for the statistical weights of reactants and products, ensuring that the reaction rates drive the system towards the correct equilibrium abundances as described by statistical mechanics. They are thus crucial for modeling the reverse reactions (photodisintegration) in a stellar plasma.\n\n#### 3) Specific Energy Generation Rate\nThe specific energy generation rate, $\\epsilon$, is the energy released per unit mass per unit time. Its units are $\\mathrm{erg\\,g^{-1}\\,s^{-1}}$.\n\nFirst, we convert the net energy release per reaction, $Q_{\\text{net}}$, from $\\mathrm{MeV}$ to $\\mathrm{erg}$:\n$$\nQ_{\\text{net, erg}} = Q_{\\text{net}} \\times (1.602176634 \\times 10^{-6}\\ \\mathrm{erg\\,MeV^{-1}})\n$$\n$$\nQ_{\\text{net, erg}} = 14.4352464\\ \\mathrm{MeV} \\times (1.602176634 \\times 10^{-6}\\ \\mathrm{erg\\,MeV^{-1}}) \\approx 2.3127814 \\times 10^{-5}\\ \\mathrm{erg}\n$$\n\nNext, we convert the molar volumetric progress, $r_{\\mathrm{mol}}$, into the rate of reaction events per unit volume, $R$. This is done using Avogadro's number, $N_A$:\n$$\nR = r_{\\mathrm{mol}} \\times N_A\n$$\n$$\nR = (1.000 \\times 10^{-5}\\ \\mathrm{mol\\,cm^{-3}\\,s^{-1}}) \\times (6.02214076 \\times 10^{23}\\ \\mathrm{mol^{-1}})\n$$\n$$\nR = 6.02214076 \\times 10^{18}\\ \\mathrm{cm^{-3}\\,s^{-1}}\n$$\nThis value $R$ represents the number of net $4\\,^{4}\\mathrm{He} \\rightarrow\\, ^{16}\\mathrm{O}$ reactions occurring per cubic centimeter per second.\n\nThe volumetric energy generation rate, $\\dot{q}$, is the product of the energy per reaction and the rate of reactions per volume:\n$$\n\\dot{q} = Q_{\\text{net, erg}} \\times R\n$$\n$$\n\\dot{q} = (2.3127814 \\times 10^{-5}\\ \\mathrm{erg}) \\times (6.02214076 \\times 10^{18}\\ \\mathrm{cm^{-3}\\,s^{-1}})\n$$\n$$\n\\dot{q} \\approx 1.392900 \\times 10^{14}\\ \\mathrm{erg\\,cm^{-3}\\,s^{-1}}\n$$\n\nFinally, the specific energy generation rate, $\\epsilon$, is obtained by dividing the volumetric rate $\\dot{q}$ by the mass density $\\rho$:\n$$\n\\epsilon = \\frac{\\dot{q}}{\\rho}\n$$\n$$\n\\epsilon = \\frac{1.392900 \\times 10^{14}\\ \\mathrm{erg\\,cm^{-3}\\,s^{-1}}}{1.00 \\times 10^{5}\\ \\mathrm{g\\,cm^{-3}}}\n$$\n$$\n\\epsilon = 1.392900 \\times 10^{9}\\ \\mathrm{erg\\,g^{-1}\\,s^{-1}}\n$$\n\nRounding the result to four significant figures as requested:\n$$\n\\epsilon \\approx 1.393 \\times 10^{9}\\ \\mathrm{erg\\,g^{-1}\\,s^{-1}}\n$$",
            "answer": "$$\\boxed{1.393 \\times 10^{9}}$$"
        },
        {
            "introduction": "Stellar evolution codes rely on pre-computed tables of nuclear reaction rates, which are highly sensitive functions of temperature $T$ and density $\\rho$. A critical task is to interpolate these tables accurately and efficiently, as both the rate values and their derivatives are needed by the solver. This exercise will guide you through the implementation of a monotone cubic interpolation scheme, a technique essential for preventing unphysical oscillations and ensuring the fidelity of the physics captured by the simulation . By quantifying the interpolation error against an analytic model, you will gain a deeper appreciation for the numerical precision required in modern astrophysics.",
            "id": "3525292",
            "problem": "You are implementing a module to interpolate tabulated nuclear reaction rates used in stellar evolution and explosion simulations. The tables are given as functions of temperature $T$ (and optionally density $\\rho$), and you must use a monotone cubic Hermite scheme that preserves physical monotonicity and positivity. Your task is to implement the interpolation using the Piecewise Cubic Hermite Interpolating Polynomial (PCHIP), quantify the interpolation error relative to reference physics models, and report dimensionless error metrics. All quantities in this problem are self-consistent and plausible within the context of computational astrophysics.\n\nStart from the following fundamental base and definitions.\n\n1. Let the reference one-dimensional reaction rate per pair be modeled by an analytic, non-resonant charged-particle fusion form\n$$\nr_0(T) \\;=\\; C \\; T_9^{-2/3} \\;\\exp\\!\\big(-b \\, T_9^{-1/3}\\big),\n$$\nwhere $T_9 \\equiv T / 10^9\\,\\mathrm{K}$, $C = 4.27\\times 10^{-15}$, and $b = 3.38$. This functional form captures the Gamow peak tunneling physics for non-resonant reactions over $T \\in [10^7, 10^9]\\,\\mathrm{K}$, and is strictly positive and increasing on this interval. The corresponding logarithmic sensitivity is\n$$\n\\frac{d\\ln r_0}{d\\ln T} \\;=\\; -\\frac{2}{3} \\;+\\; \\frac{b}{3}\\,T_9^{-1/3}.\n$$\n\n2. Include Coulomb screening in a separable two-dimensional model\n$$\nr(T,\\rho) \\;=\\; r_0(T)\\;\\times\\; f_{\\mathrm{screen}}(T,\\rho),\\qquad\nf_{\\mathrm{screen}}(T,\\rho) \\;=\\; \\exp\\!\\Big(A \\,\\rho_5^{1/2}\\, T_9^{-3/2}\\Big),\n$$\nwhere $\\rho_5 \\equiv \\rho / 10^5\\,\\mathrm{g\\,cm^{-3}}$ and $A = 0.05$. The two-dimensional logarithmic temperature sensitivity is\n$$\n\\frac{d\\ln r}{d\\ln T} \\;=\\; \\left(-\\frac{2}{3} \\;+\\; \\frac{b}{3}\\,T_9^{-1/3}\\right) \\;-\\; \\frac{3}{2}\\,A\\,\\rho_5^{1/2}\\,T_9^{-3/2}.\n$$\n\n3. Define a characteristic nuclear burning timescale (up to composition factors) as\n$$\n\\tau(T,\\rho) \\;\\equiv\\; \\frac{1}{\\rho\\,r(T,\\rho)}.\n$$\nFor the special purpose of error quantification, you will report the relative error in $\\tau$ at a specified thermodynamic state.\n\nYou are provided with tabulated values sampled from the above reference models and must interpolate between tabulated nodes using a monotone cubic Hermite scheme. You must not use any non-monotone spline that can introduce overshoots. You should compute errors by comparing the interpolated result against the exact analytic model used to generate the tables.\n\nInterpolation requirements.\n\n- Use Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) along any one-dimensional axis. For two-dimensional interpolation on a tensor-product grid in $(T,\\rho)$, perform a composition of one-dimensional PCHIP operations: first along the $T$-axis at fixed $\\rho$, then along the $\\rho$-axis to combine those results. To obtain the derivative with respect to $T$ at an off-grid point, carry the $T$-derivative from the first PCHIP stage and then interpolate that derivative along $\\rho$ using PCHIP.\n\n- For any evaluation at $(T,\\rho)$, compute the interpolated value $r_{\\mathrm{interp}}(T,\\rho)$ and the interpolated logarithmic temperature sensitivity\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} \\;=\\; \\frac{T}{r_{\\mathrm{interp}}}\\,\\left(\\frac{\\partial r}{\\partial T}\\right)_{\\mathrm{interp}}.\n$$\n\n- Quantify two error metrics at any point where the exact reference values are known: (i) the relative rate error\n$$\n\\varepsilon_r \\;=\\; \\left|\\frac{r_{\\mathrm{interp}} - r_{\\mathrm{exact}}}{r_{\\mathrm{exact}}}\\right|,\n$$\nand (ii) the normalized logarithmic-slope error\n$$\n\\varepsilon_s \\;=\\; \\frac{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} - \\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right|}{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right| + 10^{-12}},\n$$\nwhere the small additive $10^{-12}$ regularizes near-zero denominators and does not affect accuracy on the given domains.\n\nTables, grids, and test suite.\n\n- One-dimensional table in $T$ only:\n  - Temperature grid in kelvin: $T_{\\mathrm{grid}} = \\{\\,10^7,\\;2\\times 10^7,\\;5\\times 10^7,\\;10^8,\\;2\\times 10^8,\\;5\\times 10^8,\\;10^9\\,\\}$.\n  - Tabulated values: $r_0(T)$ evaluated exactly at $T\\in T_{\\mathrm{grid}}$.\n  - Query set: $50$ temperatures logarithmically spaced from $10^7$ to $10^9\\,\\mathrm{K}$, inclusive of endpoints.\n  - Report the maximum values of $\\varepsilon_r$ and $\\varepsilon_s$ over this query set.\n\n- Two-dimensional table in $(T,\\rho)$:\n  - Temperature grid in kelvin: the same $T_{\\mathrm{grid}}$ as above.\n  - Density grid in $\\mathrm{g\\,cm^{-3}}$: $\\rho_{\\mathrm{grid}} = \\{\\,1,\\;10,\\;100,\\;10^3\\,\\}$.\n  - Tabulated values: $r(T,\\rho)$ evaluated exactly on the tensor product of the two grids.\n  - Query set: the Cartesian product of\n    - Temperatures in kelvin: $T_{\\mathrm{q}} = \\{\\,1.5\\times 10^7,\\;3\\times 10^7,\\;8\\times 10^7,\\;3\\times 10^8,\\;8\\times 10^8\\,\\}$,\n    - Densities in $\\mathrm{g\\,cm^{-3}}$: $\\rho_{\\mathrm{q}} = \\{\\,5,\\;50,\\;500\\,\\}$.\n  - Report the maximum values of $\\varepsilon_r$ and $\\varepsilon_s$ over this two-dimensional query set.\n\n- Nuclear timescale error at a solar-core-like state:\n  - Single state: $T_\\star = 1.57\\times 10^7\\,\\mathrm{K}$, $\\rho_\\star = 150\\,\\mathrm{g\\,cm^{-3}}$.\n  - Using the two-dimensional interpolant, compute $\\tau_{\\mathrm{interp}}(T_\\star,\\rho_\\star)$ and compare with $\\tau_{\\mathrm{exact}}(T_\\star,\\rho_\\star)$ defined using the exact $r(T,\\rho)$. Report the relative error\n  $$\n  \\varepsilon_\\tau \\;=\\; \\left|\\frac{\\tau_{\\mathrm{interp}} - \\tau_{\\mathrm{exact}}}{\\tau_{\\mathrm{exact}}}\\right|.\n  $$\n\nImplementation and output requirements.\n\n- Implement the interpolation using PCHIP as the monotone cubic Hermite method. For two-dimensional interpolation, apply PCHIP along $T$ at each $\\rho$ to obtain both interpolated values and $\\partial r/\\partial T$, then use PCHIP along $\\rho$ to get $r_{\\mathrm{interp}}$ and $(\\partial r/\\partial T)_{\\mathrm{interp}}$ at the target $\\rho$.\n\n- You must compute errors by comparing to the exact reference functions specified above. Do not use the exact functions for interpolation between tabulated nodes.\n\n- Angles do not appear in this problem. All reported error metrics are dimensionless and must be expressed as decimals.\n\n- Your program should produce a single line of output containing a comma-separated list with the following five floating-point results, each rounded to six significant digits in scientific notation: $[\\max \\varepsilon_r \\text{ (one-dimensional)},\\;\\max \\varepsilon_s \\text{ (one-dimensional)},\\;\\max \\varepsilon_r \\text{ (two-dimensional)},\\;\\max \\varepsilon_s \\text{ (two-dimensional)},\\;\\varepsilon_\\tau \\text{ at } (T_\\star,\\rho_\\star)]$. For example, a syntactically valid output looks like $[1.234567\\mathrm{e}{-06},2.345678\\mathrm{e}{-05},\\dots]$.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It presents a standard, non-trivial task in computational astrophysics: the interpolation of tabulated nuclear reaction rates and the quantification of associated errors. All provided models, constants, and procedural requirements are consistent and physically plausible. We may therefore proceed with a solution.\n\nThe core of the problem is to implement a shape-preserving interpolation scheme for functions of temperature $T$ and density $\\rho$, and to assess its accuracy against known analytic forms. The chosen method is the Piecewise Cubic Hermite Interpolating Polynomial (PCHIP), which guarantees that the interpolant will be monotonic if the underlying data is monotonic. This property is crucial for physical quantities like reaction rates, which typically exhibit monotonic behavior over relevant thermodynamic ranges, preventing the introduction of unphysical oscillations that can plague other high-order interpolation methods like standard cubic splines.\n\nFirst, we define the exact reference models that will be used both to generate the discrete data tables and to serve as the ground truth for error calculation.\n\nThe one-dimensional, non-resonant reaction rate per pair, $r_0(T)$, is given by:\n$$\nr_0(T) = C \\, T_9^{-2/3} \\exp(-b \\, T_9^{-1/3})\n$$\nwhere $T_9 \\equiv T / (10^9\\,\\mathrm{K})$, $C = 4.27 \\times 10^{-15}$, and $b = 3.38$. The logarithmic sensitivity of this rate with respect to temperature is:\n$$\n\\left(\\frac{d\\ln r_0}{d\\ln T}\\right)_{\\mathrm{exact}} = -\\frac{2}{3} + \\frac{b}{3} T_9^{-1/3}\n$$\n\nThe two-dimensional model, $r(T, \\rho)$, incorporates a Coulomb screening factor, $f_{\\mathrm{screen}}(T, \\rho)$:\n$$\nr(T,\\rho) = r_0(T) \\, f_{\\mathrm{screen}}(T,\\rho) \\quad \\text{where} \\quad f_{\\mathrm{screen}}(T,\\rho) = \\exp\\left(A \\,\\rho_5^{1/2}\\, T_9^{-3/2}\\right)\n$$\nHere, $\\rho_5 \\equiv \\rho / (10^5\\,\\mathrm{g\\,cm^{-3}})$ and $A = 0.05$. The corresponding two-dimensional logarithmic temperature sensitivity is:\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}} = \\left(-\\frac{2}{3} + \\frac{b}{3}\\,T_9^{-1/3}\\right) - \\frac{3}{2}\\,A\\,\\rho_5^{1/2}\\,T_9^{-3/2}\n$$\n\nThe interpolation accuracy is quantified by two error metrics. The relative rate error, $\\varepsilon_r$, is defined as:\n$$\n\\varepsilon_r = \\left|\\frac{r_{\\mathrm{interp}} - r_{\\mathrm{exact}}}{r_{\\mathrm{exact}}}\\right|\n$$\nThe normalized logarithmic-slope error, $\\varepsilon_s$, is defined as:\n$$\n\\varepsilon_s = \\frac{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} - \\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right|}{\\left|\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{exact}}\\right| + 10^{-12}}\n$$\nwhere the interpolated logarithmic slope is computed from the interpolated rate, $r_{\\mathrm{interp}}$, and its derivative, $(\\partial r/\\partial T)_{\\mathrm{interp}}$, as:\n$$\n\\left(\\frac{d\\ln r}{d\\ln T}\\right)_{\\mathrm{interp}} = \\frac{T}{r_{\\mathrm{interp}}} \\left(\\frac{\\partial r}{\\partial T}\\right)_{\\mathrm{interp}}\n$$\nAdditionally, a specific timescale error, $\\varepsilon_\\tau$, is calculated at a single point $(T_\\star, \\rho_\\star)$. The timescale $\\tau$ is defined as $\\tau(T,\\rho) = 1/(\\rho r(T,\\rho))$. The error is:\n$$\n\\varepsilon_\\tau = \\left|\\frac{\\tau_{\\mathrm{interp}} - \\tau_{\\mathrm{exact}}}{\\tau_{\\mathrm{exact}}}\\right| = \\left|\\frac{1/(\\rho_\\star r_{\\mathrm{interp}}) - 1/(\\rho_\\star r_{\\mathrm{exact}})}{1/(\\rho_\\star r_{\\mathrm{exact}})}\\right| = \\left|\\frac{r_{\\mathrm{exact}} - r_{\\mathrm{interp}}}{r_{\\mathrm{interp}}}\\right|\n$$\nThis is notably the relative error in the rate with respect to the interpolated value, differing slightly from the definition of $\\varepsilon_r$.\n\nThe solution proceeds in three stages:\n\n**Part 1: One-Dimensional Interpolation**\nA discrete table of data points $(T_i, r_0(T_i))$ is created by evaluating the exact function $r_0(T)$ on the given temperature grid $T_{\\mathrm{grid}}$. A PCHIP interpolator is constructed from these points. This interpolator and its derivative are then evaluated at each of the $50$ query temperatures. For each query point, we calculate $r_{\\mathrm{interp}}$, $(\\partial r/\\partial T)_{\\mathrm{interp}}$, $(\\frac{d\\ln r}{d\\ln T})_{\\mathrm{interp}}$, and compare them to the exact values to compute $\\varepsilon_r$ and $\\varepsilon_s$. The maximum values of these two error metrics over the entire query set are recorded.\n\n**Part 2: Two-Dimensional Interpolation**\nA two-dimensional table of data points $(T_i, \\rho_j, r(T_i, \\rho_j))$ is created on the tensor product of the $T_{\\mathrm{grid}}$ and $\\rho_{\\mathrm{grid}}$. To find the interpolated value and derivative at a query point $(T_q, \\rho_q)$, we follow the specified two-step procedure:\n1.  **T-Interpolation**: For each density $\\rho_j$ in the grid $\\rho_{\\mathrm{grid}}$, we construct a 1D PCHIP interpolator for the rate as a function of temperature, $r(T, \\rho_j)$, along the grid $T_{\\mathrm{grid}}$. We evaluate this interpolator and its derivative at the query temperature $T_q$. This yields a set of intermediate values, $r_{\\mathrm{interp}}(T_q, \\rho_j)$ and $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_j)$, for each grid density $\\rho_j$.\n2.  **ρ-Interpolation**: We construct two new 1D PCHIP interpolators. The first interpolates the intermediate rates, $r_{\\mathrm{interp}}(T_q, \\rho_j)$, along the $\\rho_{\\mathrm{grid}}$. The second interpolates the intermediate derivatives, $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_j)$, also along the $\\rho_{\\mathrm{grid}}$. Evaluating these two interpolators at the query density $\\rho_q$ gives the final $r_{\\mathrm{interp}}(T_q, \\rho_q)$ and $(\\partial r/\\partial T)_{\\mathrm{interp}}(T_q, \\rho_q)$.\nThis process is repeated for every query point in the 2D set. The errors $\\varepsilon_r$ and $\\varepsilon_s$ are calculated at each point, and their maximum values are recorded.\n\n**Part 3: Nuclear Timescale Error**\nThe two-dimensional interpolation procedure is applied once more for the specific state $(T_\\star, \\rho_\\star) = (1.57\\times 10^7\\,\\mathrm{K}, 150\\,\\mathrm{g\\,cm^{-3}})$ to find $r_{\\mathrm{interp}}(T_\\star,\\rho_\\star)$. Using this, we compute $\\tau_{\\mathrm{interp}}(T_\\star, \\rho_\\star) = 1/(\\rho_\\star r_{\\mathrm{interp}})$. The exact value $\\tau_{\\mathrm{exact}}(T_\\star, \\rho_\\star)$ is also calculated. The relative error $\\varepsilon_\\tau$ is then determined according to its definition.\n\nThe final output will consist of the five computed error metrics, formatted as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nimport itertools\n\n# This script implements a PCHIP interpolation scheme for nuclear reaction rates\n# and quantifies the interpolation error against analytic reference models.\n\n# Role: Meticulous STEM Professor\n# Task: Validate and solve the problem of interpolating nuclear reaction rates.\n\ndef solve():\n    \"\"\"\n    Main function to perform interpolation, calculate errors, and print the results.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 1. DEFINE CONSTANTS AND EXACT MODELS\n    # --------------------------------------------------------------------------\n    \n    # Physical and model constants\n    C = 4.27e-15  # Rate constant\n    b = 3.38      # Gamow peak exponent constant\n    A = 0.05      # Screening constant\n\n    def r0_exact(T):\n        \"\"\"Calculates the exact 1D non-resonant reaction rate.\"\"\"\n        T9 = T / 1e9\n        # Handling potential division by zero or invalid values for T=0\n        with np.errstate(divide='ignore'):\n            T9_m13 = T9**(-1/3)\n            T9_m23 = T9**(-2/3)\n        # For T=0, T9=0, exp(-inf) -> 0.\n        rate = C * T9_m23 * np.exp(-b * T9_m13)\n        rate = np.nan_to_num(rate)\n        return rate\n\n    def dlnr0_dlnT_exact(T):\n        \"\"\"Calculates the exact 1D logarithmic temperature sensitivity.\"\"\"\n        T9 = T / 1e9\n        with np.errstate(divide='ignore'):\n            T9_m13 = T9**(-1/3)\n        # The result diverges as T->0, but is well-behaved on the given grid.\n        return -2/3 + (b/3) * T9_m13\n\n    def r_exact(T, rho):\n        \"\"\"Calculates the exact 2D rate including Coulomb screening.\"\"\"\n        T9 = T / 1e9\n        rho5 = rho / 1e5\n        r0 = r0_exact(T)\n        with np.errstate(divide='ignore'):\n            f_screen = np.exp(A * rho5**(1/2) * T9**(-3/2))\n        f_screen = np.nan_to_num(f_screen, posinf=np.inf)\n        return r0 * f_screen\n\n    def dlnr_dlnT_exact(T, rho):\n        \"\"\"Calculates the exact 2D logarithmic temperature sensitivity.\"\"\"\n        T9 = T / 1e9\n        rho5 = rho / 1e5\n        dlnr0 = dlnr0_dlnT_exact(T)\n        with np.errstate(divide='ignore'):\n            screen_term = -(3/2) * A * rho5**(1/2) * T9**(-3/2)\n        return dlnr0 + screen_term\n\n    # --------------------------------------------------------------------------\n    # 2. DEFINE GRIDS AND QUERY POINTS\n    # --------------------------------------------------------------------------\n\n    # Grids for generating the interpolation tables\n    T_grid = np.array([1e7, 2e7, 5e7, 1e8, 2e8, 5e8, 1e9])\n    rho_grid = np.array([1.0, 10.0, 100.0, 1000.0])\n\n    # Query points for error analysis\n    T_q_1d = np.logspace(7, 9, 50)  # 1D query set\n\n    T_q_2d = np.array([1.5e7, 3e7, 8e7, 3e8, 8e8])\n    rho_q_2d = np.array([5.0, 50.0, 500.0])\n    query_points_2d = list(itertools.product(T_q_2d, rho_q_2d)) # 2D query set\n\n    T_star, rho_star = 1.57e7, 150.0  # Single state for timescale error\n\n    # --------------------------------------------------------------------------\n    # 3. PART 1: 1D INTERPOLATION AND ERROR ANALYSIS\n    # --------------------------------------------------------------------------\n    \n    # Generate the 1D table\n    r0_table = r0_exact(T_grid)\n\n    # Create 1D PCHIP interpolator for the rate and its derivative\n    pchip1d = PchipInterpolator(T_grid, r0_table)\n    pchip1d_deriv = pchip1d.derivative(nu=1)\n\n    errors_r_1d = []\n    errors_s_1d = []\n\n    for T_q in T_q_1d:\n        # Interpolated values\n        r_interp = pchip1d(T_q)\n        drdT_interp = pchip1d_deriv(T_q)\n        dlnr_dlnT_interp = (T_q / r_interp) * drdT_interp if r_interp > 0 else 0\n        \n        # Exact values\n        r_e = r0_exact(T_q)\n        dlnr_dlnT_e = dlnr0_dlnT_exact(T_q)\n        \n        # Calculate errors\n        err_r = np.abs((r_interp - r_e) / r_e) if r_e > 0 else 0\n        err_s = np.abs(dlnr_dlnT_interp - dlnr_dlnT_e) / (np.abs(dlnr_dlnT_e) + 1e-12)\n        \n        errors_r_1d.append(err_r)\n        errors_s_1d.append(err_s)\n\n    max_err_r_1d = np.max(errors_r_1d)\n    max_err_s_1d = np.max(errors_s_1d)\n\n    # --------------------------------------------------------------------------\n    # 4. PART 2: 2D INTERPOLATION AND ERROR ANALYSIS\n    # --------------------------------------------------------------------------\n\n    # Generate the 2D table\n    r_table_2d = r_exact(T_grid[:, np.newaxis], rho_grid[np.newaxis, :])\n\n    errors_r_2d = []\n    errors_s_2d = []\n\n    for T_q, rho_q in query_points_2d:\n        # Step A: Interpolate along T-axis for each grid density\n        r_interp_on_rhogrid = []\n        drdT_interp_on_rhogrid = []\n        for i in range(len(rho_grid)):\n            r_values_at_rho_i = r_table_2d[:, i]\n            pchip_T = PchipInterpolator(T_grid, r_values_at_rho_i)\n            r_interp_on_rhogrid.append(pchip_T(T_q))\n            drdT_interp_on_rhogrid.append(pchip_T.derivative(nu=1)(T_q))\n        \n        # Step B: Interpolate along rho-axis to get final values\n        pchip_rho_r = PchipInterpolator(rho_grid, r_interp_on_rhogrid)\n        r_interp = pchip_rho_r(rho_q)\n        \n        pchip_rho_drdT = PchipInterpolator(rho_grid, drdT_interp_on_rhogrid)\n        drdT_interp = pchip_rho_drdT(rho_q)\n        \n        dlnr_dlnT_interp = (T_q / r_interp) * drdT_interp if r_interp > 0 else 0\n        \n        # Exact values at (T_q, rho_q)\n        r_e = r_exact(T_q, rho_q)\n        dlnr_dlnT_e = dlnr_dlnT_exact(T_q, rho_q)\n\n        # Calculate errors\n        err_r = np.abs((r_interp - r_e) / r_e) if r_e > 0 else 0\n        err_s = np.abs(dlnr_dlnT_interp - dlnr_dlnT_e) / (np.abs(dlnr_dlnT_e) + 1e-12)\n\n        errors_r_2d.append(err_r)\n        errors_s_2d.append(err_s)\n\n    max_err_r_2d = np.max(errors_r_2d)\n    max_err_s_2d = np.max(errors_s_2d)\n\n    # --------------------------------------------------------------------------\n    # 5. PART 3: NUCLEAR TIMESCALE ERROR\n    # --------------------------------------------------------------------------\n\n    # Perform 2D interpolation for the specific state (T_star, rho_star)\n    r_interp_on_rhogrid_star = []\n    for i in range(len(rho_grid)):\n        r_values_at_rho_i = r_table_2d[:, i]\n        pchip_T = PchipInterpolator(T_grid, r_values_at_rho_i)\n        r_interp_on_rhogrid_star.append(pchip_T(T_star))\n\n    pchip_rho_r_star = PchipInterpolator(rho_grid, r_interp_on_rhogrid_star)\n    r_interp_star = pchip_rho_r_star(rho_star)\n\n    # Calculate timescales\n    tau_interp = 1 / (rho_star * r_interp_star) if r_interp_star > 0 else np.inf\n    \n    r_exact_star = r_exact(T_star, rho_star)\n    tau_exact = 1 / (rho_star * r_exact_star) if r_exact_star > 0 else np.inf\n    \n    # Calculate relative error in timescale as defined in the problem\n    err_tau = np.abs((tau_interp - tau_exact) / tau_exact) if tau_exact > 0 and np.isfinite(tau_exact) else 0\n\n    # --------------------------------------------------------------------------\n    # 6. FINAL OUTPUT\n    # --------------------------------------------------------------------------\n    \n    results = [\n        max_err_r_1d,\n        max_err_s_1d,\n        max_err_r_2d,\n        max_err_s_2d,\n        err_tau\n    ]\n    \n    # Format results to six significant digits in scientific notation\n    formatted_results = [\"{:.5e}\".format(res) for res in results]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "With consistent physical data and accurate rate interpolation, the core of the network calculation is solving the system of ordinary differential equations (ODEs) that governs abundance evolution. Before deploying a numerical solver on a real scientific problem, it is imperative to verify its correctness and confirm its expected convergence rate. This practice introduces the Method of Manufactured Solutions (MMS), a powerful and standard verification technique where an exact solution is prescribed, allowing you to rigorously measure your solver's error and demonstrate that it achieves its theoretical order of accuracy .",
            "id": "3525233",
            "problem": "Consider a dimensionless nuclear reaction network with three species, where the state vector is the vector of abundances $\\mathbf{Y}(t) = \\big(Y_{\\mathrm{A}}(t), Y_{\\mathrm{B}}(t), Y_{\\mathrm{C}}(t)\\big)^{\\top}$. The network consists of two reactions with constant effective rates: (i) $\\mathrm{A} \\to \\mathrm{B}$ with rate parameter $\\lambda$, and (ii) $\\mathrm{B} \\to \\mathrm{C}$ with rate parameter $\\mu$. Under the law of mass action and stoichiometry, the unforced ordinary differential equation (ODE) system is\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) \\equiv \n\\begin{bmatrix}\n-\\lambda Y_{\\mathrm{A}} \\\\\n\\lambda Y_{\\mathrm{A}} - \\mu Y_{\\mathrm{B}} \\\\\n\\mu Y_{\\mathrm{B}}\n\\end{bmatrix}.\n$$\nYou will employ the Method of Manufactured Solutions (MMS) to verify the order of accuracy of two time integration schemes used in stellar reaction network solvers. The MMS procedure prescribes a smooth, exact solution $\\mathbf{Y}_{\\mathrm{exact}}(t)$ and constructs a time-dependent forcing term $\\mathbf{Q}(t)$ such that the forced ODE\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)\n$$\nhas the exact solution $\\mathbf{Y}(t) \\equiv \\mathbf{Y}_{\\mathrm{exact}}(t)$ for all $t$ in the integration interval.\n\n1. Manufactured solution and forcing.\n   - Let the exact solution be\n     $$\n     \\begin{aligned}\n     Y_{\\mathrm{A,exact}}(t) &= 0.5 + 0.1\\cos(2\\pi t),\\\\\n     Y_{\\mathrm{B,exact}}(t) &= 0.3 + 0.05\\sin(2\\pi t),\\\\\n     Y_{\\mathrm{C,exact}}(t) &= 1 - Y_{\\mathrm{A,exact}}(t) - Y_{\\mathrm{B,exact}}(t).\n     \\end{aligned}\n     $$\n     This choice ensures $Y_{\\mathrm{A,exact}}(t) > 0$, $Y_{\\mathrm{B,exact}}(t) > 0$, $Y_{\\mathrm{C,exact}}(t) > 0$, and $Y_{\\mathrm{A,exact}}(t) + Y_{\\mathrm{B,exact}}(t) + Y_{\\mathrm{C,exact}}(t) \\equiv 1$ for all $t$.\n   - Starting from the fundamental definition $\\mathbf{Q}(t) \\equiv \\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} - \\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t))$, derive $\\mathbf{Q}(t)$ explicitly and use it to define the right-hand side $\\mathbf{G}(t,\\mathbf{Y}) \\equiv \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$ for numerical time integration.\n\n2. Time integration methods to be verified.\n   - Implement the forward (explicit) Euler method of order $p=1$: given step size $\\Delta t$, update $\\mathbf{Y}_{n+1} = \\mathbf{Y}_{n} + \\Delta t\\, \\mathbf{G}(t_n,\\mathbf{Y}_n)$.\n   - Implement the classical Runge–Kutta method of order $p=4$: with $\\mathbf{G}(t,\\mathbf{Y})$ as the right-hand side, use the standard $4$-stage scheme with stage times $t_n$, $t_n+\\frac{\\Delta t}{2}$, $t_n+\\frac{\\Delta t}{2}$, $t_n+\\Delta t$.\n\n3. Error measurement and order estimation under mesh refinement.\n   - Integrate from $t_0 = 0$ to $t_{\\mathrm{final}} = 1$ with initial condition $\\mathbf{Y}(0) = \\mathbf{Y}_{\\mathrm{exact}}(0)$.\n   - For a given base time step $\\Delta t_0$, compute the numerical solution at $t_{\\mathrm{final}}$ using three refinements: $\\Delta t_0$, $\\Delta t_0/2$, and $\\Delta t_0/4$. For each $\\Delta t$, compute the error\n     $$\n     E(\\Delta t) \\equiv \\left\\|\\mathbf{Y}_{\\mathrm{num}}(t_{\\mathrm{final}};\\Delta t) - \\mathbf{Y}_{\\mathrm{exact}}(t_{\\mathrm{final}})\\right\\|_{\\infty}.\n     $$\n   - Estimate the observed order using the refinement pair $(\\Delta t_0/2,\\ \\Delta t_0/4)$ via\n     $$\n     p_{\\mathrm{obs}} = \\log_2\\left(\\frac{E(\\Delta t_0/2)}{E(\\Delta t_0/4)}\\right).\n     $$\n     The expected values are $p_{\\mathrm{obs}} \\approx 1$ for forward Euler and $p_{\\mathrm{obs}} \\approx 4$ for classical Runge–Kutta of order $4$.\n\n4. Test suite.\n   - Use the following four test cases, each specified by $(\\lambda,\\ \\mu,\\ \\Delta t_0,\\ \\text{method})$:\n     - Case A (moderate rates, forward Euler): $(2,\\ 1,\\ 0.05,\\ \\text{\"euler\"})$.\n     - Case B (moderate rates, Runge–Kutta order $4$): $(2,\\ 1,\\ 0.1,\\ \\text{\"rk4\"})$.\n     - Case C (faster rates, Runge–Kutta order $4$): $(10,\\ 5,\\ 0.02,\\ \\text{\"rk4\"})$.\n     - Case D (faster rates, forward Euler): $(10,\\ 5,\\ 0.01,\\ \\text{\"euler\"})$.\n   - All quantities are dimensionless; no physical unit conversion is required.\n\n5. Program requirements and final output format.\n   - Your program must implement the manufactured forcing $\\mathbf{Q}(t)$ derived from the exact solution and the network $\\mathbf{F}(\\mathbf{Y})$ for each $(\\lambda,\\ \\mu)$.\n   - For each test case, compute $p_{\\mathrm{obs}}$ as defined above and round it to three decimal places.\n   - Your program should produce a single line of output containing the four rounded $p_{\\mathrm{obs}}$ values in order of the cases A, B, C, D, formatted as a comma-separated list enclosed in square brackets, for example: [x,y,z,w].",
            "solution": "The problem requires the verification of the order of accuracy for two numerical time integration schemes, Forward Euler and classical Runge-Kutta of order $4$, when applied to a simple nuclear reaction network. The verification will be performed using the Method of Manufactured Solutions (MMS). The process involves deriving a source term that forces the governing differential equations to have a chosen exact solution, implementing the numerical schemes to solve this forced system, and then measuring the convergence rate of the numerical error under grid refinement.\n\nThe state of the system is described by the vector of species abundances $\\mathbf{Y}(t) = \\big(Y_{\\mathrm{A}}(t), Y_{\\mathrm{B}}(t), Y_{\\mathrm{C}}(t)\\big)^{\\top}$. The unforced evolution is governed by the ODE system $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y})$, where the reaction term $\\mathbf{F}(\\mathbf{Y})$ for the network $\\mathrm{A} \\xrightarrow{\\lambda} \\mathrm{B} \\xrightarrow{\\mu} \\mathrm{C}$ is given by:\n$$\n\\mathbf{F}(\\mathbf{Y}) = \n\\begin{bmatrix}\n-\\lambda Y_{\\mathrm{A}} \\\\\n\\lambda Y_{\\mathrm{A}} - \\mu Y_{\\mathrm{B}} \\\\\n\\mu Y_{\\mathrm{B}}\n\\end{bmatrix}.\n$$\n\nFirst, we derive the forcing term $\\mathbf{Q}(t)$ required by the MMS. The forced ODE system is $\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$. By design, this system must have the exact solution $\\mathbf{Y}(t) \\equiv \\mathbf{Y}_{\\mathrm{exact}}(t)$. This condition defines the forcing term as:\n$$\n\\mathbf{Q}(t) \\equiv \\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} - \\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t)).\n$$\nThe prescribed manufactured solution is:\n$$\n\\begin{aligned}\nY_{\\mathrm{A,exact}}(t) &= 0.5 + 0.1\\cos(2\\pi t) \\\\\nY_{\\mathrm{B,exact}}(t) &= 0.3 + 0.05\\sin(2\\pi t) \\\\\nY_{\\mathrm{C,exact}}(t) &= 1 - Y_{\\mathrm{A,exact}}(t) - Y_{\\mathrm{B,exact}}(t) = 0.2 - 0.1\\cos(2\\pi t) - 0.05\\sin(2\\pi t)\n\\end{aligned}\n$$\nThe time derivatives of these components are:\n$$\n\\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt} = \n\\begin{bmatrix}\n-0.2\\pi \\sin(2\\pi t) \\\\\n0.1\\pi \\cos(2\\pi t) \\\\\n0.2\\pi \\sin(2\\pi t) - 0.1\\pi \\cos(2\\pi t)\n\\end{bmatrix}.\n$$\nNext, we evaluate $\\mathbf{F}$ at the exact solution:\n$$\n\\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t)) = \n\\begin{bmatrix}\n-\\lambda (0.5 + 0.1\\cos(2\\pi t)) \\\\\n\\lambda (0.5 + 0.1\\cos(2\\pi t)) - \\mu (0.3 + 0.05\\sin(2\\pi t)) \\\\\n\\mu (0.3 + 0.05\\sin(2\\pi t))\n\\end{bmatrix}.\n$$\nSubtracting $\\mathbf{F}(\\mathbf{Y}_{\\mathrm{exact}}(t))$ from $\\frac{d\\mathbf{Y}_{\\mathrm{exact}}}{dt}$ yields the components of $\\mathbf{Q}(t) = \\big(Q_{\\mathrm{A}}(t), Q_{\\mathrm{B}}(t), Q_{\\mathrm{C}}(t)\\big)^{\\top}$:\n$$\n\\begin{aligned}\nQ_{\\mathrm{A}}(t) &= -0.2\\pi \\sin(2\\pi t) + \\lambda(0.5 + 0.1\\cos(2\\pi t)) \\\\\nQ_{\\mathrm{B}}(t) &= 0.1\\pi \\cos(2\\pi t) - \\lambda(0.5 + 0.1\\cos(2\\pi t)) + \\mu(0.3 + 0.05\\sin(2\\pi t)) \\\\\nQ_{\\mathrm{C}}(t) &= 0.2\\pi \\sin(2\\pi t) - 0.1\\pi \\cos(2\\pi t) - \\mu(0.3 + 0.05\\sin(2\\pi t))\n\\end{aligned}\n$$\nThe right-hand side for numerical integration is $\\mathbf{G}(t, \\mathbf{Y}) = \\mathbf{F}(\\mathbf{Y}) + \\mathbf{Q}(t)$.\n\nThe numerical schemes to be verified are:\n1.  **Forward (explicit) Euler method (order $p=1$)**:\n    $$\n    \\mathbf{Y}_{n+1} = \\mathbf{Y}_{n} + \\Delta t\\, \\mathbf{G}(t_n, \\mathbf{Y}_n)\n    $$\n2.  **Classical Runge-Kutta method (order $p=4$)**:\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_1 &= \\mathbf{G}(t_n, \\mathbf{Y}_n) \\\\\n    \\mathbf{k}_2 &= \\mathbf{G}(t_n + \\frac{\\Delta t}{2}, \\mathbf{Y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n    \\mathbf{k}_3 &= \\mathbf{G}(t_n + \\frac{\\Delta t}{2}, \\mathbf{Y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n    \\mathbf{k}_4 &= \\mathbf{G}(t_n + \\Delta t, \\mathbf{Y}_n + \\Delta t \\mathbf{k}_3) \\\\\n    \\mathbf{Y}_{n+1} &= \\mathbf{Y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{aligned}\n    $$\nThe numerical experiment for each test case proceeds by integrating the system from $t_0=0$ to $t_{\\mathrm{final}}=1$, starting with the initial condition $\\mathbf{Y}(0) = \\mathbf{Y}_{\\mathrm{exact}}(0)$. This is done for three different time steps: $\\Delta t_0$, $\\Delta t_1 = \\Delta t_0/2$, and $\\Delta t_2 = \\Delta t_0/4$. For each step size $\\Delta t$, the error at the final time is computed using the infinity norm:\n$$\nE(\\Delta t) = \\left\\|\\mathbf{Y}_{\\mathrm{num}}(t_{\\mathrm{final}}; \\Delta t) - \\mathbf{Y}_{\\mathrm{exact}}(t_{\\mathrm{final}})\\right\\|_{\\infty}.\n$$\nThe observed order of accuracy, $p_{\\mathrm{obs}}$, is estimated from the errors corresponding to the two finest grids, $E(\\Delta t_1)$ and $E(\\Delta t_2)$. Assuming the error behaves as $E(\\Delta t) \\approx C(\\Delta t)^p$, we have:\n$$\np_{\\mathrm{obs}} = \\frac{\\log(E(\\Delta t_1)/E(\\Delta t_2))}{\\log(\\Delta t_1/\\Delta t_2)} = \\frac{\\log(E(\\Delta t_0/2)/E(\\Delta t_0/4))}{\\log(2)} = \\log_2\\left(\\frac{E(\\Delta t_0/2)}{E(\\Delta t_0/4)}\\right).\n$$\nThe expected results are $p_{\\mathrm{obs}} \\approx 1$ for the forward Euler method and $p_{\\mathrm{obs}} \\approx 4$ for the RK$4$ method. The algorithmic implementation will define functions for $\\mathbf{Y}_{\\mathrm{exact}}(t)$, $\\mathbf{G}(t,\\mathbf{Y})$, and the stepping routines. A main loop iterates through the test cases, performs the integrations for the three step sizes, computes the errors, and calculates $p_{\\mathrm{obs}}$ for each case. The final result is a list of these observed orders, rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It computes the observed order of accuracy for four test cases\n    using the Method of Manufactured Solutions.\n    \"\"\"\n    \n    # --- Part 1: Manufactured Solution and Forcing Term Implementations ---\n\n    def get_Y_exact(t):\n        \"\"\"Computes the exact manufactured solution vector Y_exact(t).\"\"\"\n        cos_term = 0.1 * np.cos(2 * np.pi * t)\n        sin_term = 0.05 * np.sin(2 * np.pi * t)\n        Y_A = 0.5 + cos_term\n        Y_B = 0.3 + sin_term\n        Y_C = 1.0 - Y_A - Y_B\n        return np.array([Y_A, Y_B, Y_C])\n\n    def get_dY_exact_dt(t):\n        \"\"\"Computes the time derivative of the exact solution vector.\"\"\"\n        dY_A_dt = -0.1 * 2 * np.pi * np.sin(2 * np.pi * t)\n        dY_B_dt = 0.05 * 2 * np.pi * np.cos(2 * np.pi * t)\n        dY_C_dt = -dY_A_dt - dY_B_dt\n        return np.array([dY_A_dt, dY_B_dt, dY_C_dt])\n\n    def F(Y, lam, mu):\n        \"\"\"Computes the unforced reaction term F(Y).\"\"\"\n        Y_A, Y_B, _ = Y\n        return np.array([\n            -lam * Y_A,\n            lam * Y_A - mu * Y_B,\n            mu * Y_B\n        ])\n\n    def get_Q(t, lam, mu):\n        \"\"\"Computes the forcing term Q(t).\"\"\"\n        Y_exact_t = get_Y_exact(t)\n        dY_exact_dt_t = get_dY_exact_dt(t)\n        F_exact_t = F(Y_exact_t, lam, mu)\n        return dY_exact_dt_t - F_exact_t\n\n    def get_G(t, Y, lam, mu, Q_t):\n        \"\"\"Computes the full forced right-hand side G(t, Y).\"\"\"\n        return F(Y, lam, mu) + Q_t\n\n    # --- Part 2: Time Integration Method Implementations ---\n\n    def forward_euler_step(Y_n, t_n, dt, lam, mu):\n        \"\"\"Performs one step of the forward Euler method.\"\"\"\n        Q_n = get_Q(t_n, lam, mu)\n        G_n = get_G(t_n, Y_n, lam, mu, Q_n)\n        return Y_n + dt * G_n\n\n    def rk4_step(Y_n, t_n, dt, lam, mu):\n        \"\"\"Performs one step of the classical RK4 method.\"\"\"\n        Q_n = get_Q(t_n, lam, mu)\n        k1 = get_G(t_n, Y_n, lam, mu, Q_n)\n        \n        t_half = t_n + dt / 2.0\n        Q_half = get_Q(t_half, lam, mu)\n        k2 = get_G(t_half, Y_n + dt / 2.0 * k1, lam, mu, Q_half)\n        \n        k3 = get_G(t_half, Y_n + dt / 2.0 * k2, lam, mu, Q_half)\n\n        t_full = t_n + dt\n        Q_full = get_Q(t_full, lam, mu)\n        k4 = get_G(t_full, Y_n + dt * k3, lam, mu, Q_full)\n        \n        return Y_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # --- Part 3: Error Measurement and Order Estimation ---\n\n    def run_one_case(lam, mu, dt0, method_str):\n        \"\"\"\n        Runs the numerical experiment for one test case and computes p_obs.\n        \"\"\"\n        t_final = 1.0\n        \n        # Select the numerical method\n        if method_str == \"euler\":\n            stepper = forward_euler_step\n        elif method_str == \"rk4\":\n            stepper = rk4_step\n        else:\n            raise ValueError(\"Unknown method\")\n\n        # Set up refinements\n        dts = [dt0 / 2.0, dt0 / 4.0]\n        errors = []\n\n        # Get the exact solution at the final time for error calculation\n        Y_final_exact = get_Y_exact(t_final)\n        \n        # Initial condition\n        Y0 = get_Y_exact(0.0)\n\n        # Loop over refinements\n        for dt in dts:\n            num_steps = int(round(t_final / dt))\n            Y = Y0.copy()\n            t = 0.0\n            \n            # Time integration loop\n            for _ in range(num_steps):\n                Y = stepper(Y, t, dt, lam, mu)\n                t += dt\n\n            # Compute and store error\n            error = np.linalg.norm(Y - Y_final_exact, ord=np.inf)\n            errors.append(error)\n        \n        # Calculate observed order of accuracy\n        # p_obs = log2(E(dt/2) / E(dt/4))\n        p_obs = np.log2(errors[0] / errors[1])\n        \n        return round(p_obs, 3)\n\n    # --- Part 4: Test Suite and Final Output ---\n\n    test_cases = [\n        (2, 1, 0.05, \"euler\"),   # Case A\n        (2, 1, 0.1, \"rk4\"),      # Case B\n        (10, 5, 0.02, \"rk4\"),    # Case C\n        (10, 5, 0.01, \"euler\"),  # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, mu, dt0, method = case\n        p_obs = run_one_case(lam, mu, dt0, method)\n        results.append(p_obs)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}