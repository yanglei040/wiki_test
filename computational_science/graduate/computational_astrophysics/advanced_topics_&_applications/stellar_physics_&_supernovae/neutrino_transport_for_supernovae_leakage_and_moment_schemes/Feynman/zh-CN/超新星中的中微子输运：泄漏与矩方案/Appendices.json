{
    "hands_on_practices": [
        {
            "introduction": "中微子泄漏方案是模拟超新星核等致密天体中能量损失的一种计算上高效的方法。然而，为了简化计算，人们常常使用“灰色”近似，即假设所有能量的中微子具有相同的平均不透明度，而非考虑每个能量的实际值。本练习旨在通过直接的数值积分，量化这种灰色近似与更精确的谱方法之间的差异，从而帮助您深入理解辐射输运中近似方法的准确性及其适用范围。",
            "id": "3524606",
            "problem": "你需要推导并实现一个用于静态均匀区域中微子能量损失的、具有物理动机的光谱漏能估计器，并将其与一个在单一代表性能量点上评估光学深度抑制的灰体近似进行比较。目标是仅使用第一性原理和经过充分检验的公式为基础，计算一个无量纲比率，以量化灰体近似在不同光学深度区域下的误差。\n\n从以下基本要素开始。\n\n1. 不透明度标度：总不透明度是能量的二次函数，由 $\\,\\kappa(E) = \\kappa_0 (E/\\mathrm{MeV})^2\\,$ 给出，其中 $\\,\\kappa_0\\,$ 是一个常数，$\\,\\mathrm{MeV}\\,$ 是兆电子伏特能量单位。沿代表性逃逸路径的光学深度可以参数化为 $\\,\\tau(E) = y\\,(E/\\mathrm{MeV})^2\\,$，其中 $\\,y \\equiv \\kappa_0 \\Sigma\\,$ 是由 $\\,\\kappa_0\\,$ 和一个有效质量柱 $\\,\\Sigma\\,$ 构成的无量纲系数。\n\n2. 发射谱：假设在温度为 $\\,T\\,$、中微子化学势为零的情况下，存在光学薄的局域发射，其谱为费米-狄拉克谱，单位能量的谱能量发射率模型为 $\\,j(E) = a\\,E^3 \\left[\\exp(E/T)+1\\right]^{-1}\\,$，其中 $\\,a\\,$ 是一个比例常数，它设定了总体尺度，但在所要求的无量纲输出中会被消去。\n\n3. 漏能抑制：使用一个桥接函数 $\\,\\phi(\\tau)\\,$ 来模拟局域发射能量中逃逸部分的比例，该函数平滑地连接自由流和扩散极限，且不超过任何一个极限。要求当 $\\,\\tau\\to 0\\,$ (透明) 时 $\\,\\phi(\\tau)\\to 1\\,$，当 $\\,\\tau\\to\\infty\\,$ (扩散限制) 时 $\\,\\phi(\\tau)\\sim \\tau^{-1}\\,$。使用有理形式 $\\,\\phi(\\tau)=1/(1+\\tau)\\,$，它满足两个渐近极限，并与基于时间尺度的自由流和扩散逃逸之间的插值相一致。\n\n将单位体积的光谱漏能能量损失率定义为经逃逸概率衰减后的能量加权发射，\n$$\n\\dot{Q}_{\\mathrm{spec}} \\equiv \\int_{0}^{\\infty} \\mathrm{d}E\\, E\\, j(E)\\, \\phi\\!\\left(\\tau(E)\\right).\n$$\n为消除单位并分离出能量依赖性，通过除以 $\\,a T^5\\,$ 进行无量纲化。通过变量替换 $\\,x\\equiv E/T\\,$，定义无量纲光谱漏能泛函\n$$\n\\tilde{Q}_{\\mathrm{spec}}(T,y) \\equiv \\frac{\\dot{Q}_{\\mathrm{spec}}}{a T^5} \\;=\\; \\int_{0}^{\\infty} \\mathrm{d}x\\, \\frac{x^4}{\\exp(x)+1}\\, \\phi\\!\\left( y\\,(T/\\mathrm{MeV})^2\\, x^2 \\right).\n$$\n灰体近似通过在单一代表性能量 $\\,\\langle E\\rangle\\,$ 处评估能量依赖的衰减来替代它。为了使比较与目标 $\\,\\dot{Q}_{\\mathrm{spec}}\\,$ 内部一致，选择 $\\,\\langle E\\rangle\\,$ 作为未衰减的能量加权谱的平均值，即在权重 $\\,W(E)\\propto E^4 \\left[\\exp(E/T)+1\\right]^{-1}\\,$ 下 $\\,E\\,$ 的平均值。这意味着\n$$\n\\langle E\\rangle \\;=\\; \\frac{\\int_{0}^{\\infty}\\mathrm{d}E\\, E\\, W(E)}{\\int_{0}^{\\infty}\\mathrm{d}E\\, W(E)}\n\\;=\\; T\\, \\frac{\\int_{0}^{\\infty}\\mathrm{d}x\\, x^5 \\left[\\exp(x)+1\\right]^{-1}}{\\int_{0}^{\\infty}\\mathrm{d}x\\, x^4 \\left[\\exp(x)+1\\right]^{-1}}.\n$$\n根据此选择，灰体漏能泛函为\n$$\n\\tilde{Q}_{\\mathrm{grey}}(T,y) \\;\\equiv\\; \\frac{\\dot{Q}_{\\mathrm{grey}}}{a T^5}\n\\;=\\; \\phi\\!\\left( y\\,(T/\\mathrm{MeV})^2\\, \\langle x\\rangle^2 \\right)\\,\n\\int_{0}^{\\infty}\\mathrm{d}x\\, \\frac{x^4}{\\exp(x)+1},\n$$\n其中 $\\,\\langle x\\rangle \\equiv \\langle E\\rangle/T\\,$.\n\n你的任务是：\n\n1. 基于以上基础，推导用于实现 $\\,\\tilde{Q}_{\\mathrm{spec}}(T,y)\\,$ 和 $\\,\\tilde{Q}_{\\mathrm{grey}}(T,y)\\,$ 的表达式，清楚地说明将计算简化为对 $\\,x\\in[0,\\infty)\\,$ 进行数值积分所需的所有变量变换。\n\n2. 实现一个程序，该程序能数值计算 $\\,\\tilde{Q}_{\\mathrm{spec}}(T,y)\\,$ 和 $\\,\\tilde{Q}_{\\mathrm{grey}}(T,y)\\,$，并对每个测试用例返回以下比率\n$$\nR(T,y) \\;\\equiv\\; \\frac{\\tilde{Q}_{\\mathrm{spec}}(T,y)}{\\tilde{Q}_{\\mathrm{grey}}(T,y)}.\n$$\n所有返回的量都是无量纲的，因此输出中不需要物理单位。\n\n3. 使用以下测试套件来评估和报告 $\\,R(T,y)\\,$：\n- 用例 A (透明)：$\\,T=\\,$$4\\,\\mathrm{MeV}$, $\\,y=\\,$$10^{-4}$.\n- 用例 B (中等)：$\\,T=\\,$$4\\,\\mathrm{MeV}$, $\\,y=\\,$$1$.\n- 用例 C (不透明)：$\\,T=\\,$$4\\,\\mathrm{MeV}$, $\\,y=\\,$$100$.\n- 用例 D (温度变化)：$\\,T=\\,$$8\\,\\mathrm{MeV}$, $\\,y=\\,$$1$.\n\n4. 数值要求：\n- 对 $\\,x\\in[0,\\infty)\\,$ 进行积分，精度需足以在给定用例中将 $\\,R(T,y)\\,$ 解析到至少 $\\,10^{-6}\\,$ 的绝对精度。\n- 在你的代码中通过数值积分来自洽地处理 $\\,\\langle x\\rangle\\,$ 和归一化积分 $\\,\\int_{0}^{\\infty} \\mathrm{d}x\\, x^4/(\\exp(x)+1)\\,$；不要代入封闭形式的常数。\n\n你的程序应生成单行输出，其中包含来自测试套件的四个比率，形式为逗号分隔的列表并用方括号括起，每个值精确到小数点后六位，例如 $\\,\\left[\\text{r}_A,\\text{r}_B,\\text{r}_C,\\text{r}_D\\right]\\,$。程序不得读取任何输入，也不得产生任何其他输出。所有要打印的量都是无量纲浮点数。",
            "solution": "所述问题在科学上是合理的，数学上是适定的，并且是自洽的。它在计算天体物理学中为模拟中微子能量输运的两种常用近似方法之间提供了一个有效且有趣的比较。因此，我们可以进行推导和求解。\n\n中心任务是计算比率 $R(T,y) \\equiv \\tilde{Q}_{\\mathrm{spec}}(T,y) / \\tilde{Q}_{\\mathrm{grey}}(T,y)$，它量化了灰体不透明度近似相对于更精确的光谱计算在中微子能量漏能方面的误差。推导过程首先是形式化分子和分母的表达式，然后建立它们的数值计算算法。\n\n让我们定义无量纲参数群 $Y(T,y) \\equiv y (T/\\mathrm{MeV})^2$，它将所有对温度 $T$ 和不透明度标度 $y$ 的依赖关系封装到一个表示系统对于典型热中微子的整体光学深度的单一变量中。利用这一点，可以对所提供的表达式进行优化以供实现。\n\n首先，我们分析分母 $\\tilde{Q}_{\\mathrm{grey}}(T,y)$，它代表灰体漏能模型。该模型由两个不同部分组成：\n1. 未衰减的总能量发射率，经过适当缩放。根据问题定义，这对应于无量纲积分 $\\int_{0}^{\\infty}\\mathrm{d}x\\, x^4/(\\exp(x)+1)$。\n2. 在单一代表性能量 $\\langle E\\rangle$ 处评估的衰减因子 $\\phi(\\tau)$。\n\n代表性的无量纲能量 $\\langle x \\rangle = \\langle E \\rangle / T$ 被定义为未衰减的能量加权谱的平均值。这需要评估两个基本的费米-狄拉克积分：\n$$\n\\langle x \\rangle = \\frac{\\int_{0}^{\\infty}\\mathrm{d}x\\, x^5 \\left[\\exp(x)+1\\right]^{-1}}{\\int_{0}^{\\infty}\\mathrm{d}x\\, x^4 \\left[\\exp(x)+1\\right]^{-1}} \\equiv \\frac{F_5}{F_4}\n$$\n问题规定，这些积分 $F_4$ 和 $F_5$ 必须通过数值计算得出，而不是代入其已知的解析值。一旦常数 $\\langle x \\rangle$ 被确定，此代表性能量下的光学深度为 $\\tau(\\langle E \\rangle) = y (T \\langle x \\rangle / \\mathrm{MeV})^2 = Y \\langle x \\rangle^2$。灰体衰减因子则为 $\\phi(Y \\langle x \\rangle^2) = 1/(1 + Y \\langle x \\rangle^2)$。\n综合这些部分，无量纲灰体漏能泛函的表达式为：\n$$\n\\tilde{Q}_{\\mathrm{grey}}(T,y) = \\phi\\left(Y \\langle x\\rangle^2 \\right) \\cdot F_4 = \\frac{1}{1 + Y \\langle x\\rangle^2} \\int_{0}^{\\infty}\\mathrm{d}x\\, \\frac{x^4}{\\exp(x)+1}\n$$\n\n接下来，我们分析分子 $\\tilde{Q}_{\\mathrm{spec}}(T,y)$，它代表光谱漏能模型。该模型对所有能量的发射进行积分，并在每个特定能量处应用衰减因子。将 $\\phi(\\tau)$ 和 $\\tau(E)$ 的定义代入 $\\tilde{Q}_{\\mathrm{spec}}$ 的定义中，得到：\n$$\n\\tilde{Q}_{\\mathrm{spec}}(T,y) = \\int_{0}^{\\infty} \\mathrm{d}x\\, \\frac{x^4}{\\exp(x)+1}\\, \\phi\\left( y\\,(T/\\mathrm{MeV})^2\\, x^2 \\right) = \\int_{0}^{\\infty} \\mathrm{d}x\\, \\frac{x^4}{\\left(\\exp(x)+1\\right)\\left(1 + Y x^2\\right)}\n$$\n这是一个单一积分，对于每一组给定的参数 $(T, y)$ 都必须进行数值计算，因为它的值依赖于 $Y$。\n\n最后，由这两个量构建比率 $R(T,y)$：\n$$\nR(T,y) = \\frac{\\tilde{Q}_{\\mathrm{spec}}(T,y)}{\\tilde{Q}_{\\mathrm{grey}}(T,y)} = \\frac{\\int_{0}^{\\infty} \\frac{x^4 \\mathrm{d}x}{(\\exp(x)+1)(1 + Y x^2)}}{\\frac{F_4}{1 + Y \\langle x \\rangle^2}} = \\left(1 + Y \\langle x \\rangle^2\\right) \\frac{\\int_{0}^{\\infty} \\frac{x^4 \\mathrm{d}x}{(\\exp(x)+1)(1 + Y x^2)}}{F_4}\n$$\n其中 $Y = y(T/\\mathrm{MeV})^2$ 且 $\\langle x \\rangle = F_5/F_4$。\n\n数值实现计划如下：\n1.  使用高精度数值积分方法（例如 `scipy.integrate` 库中提供的方法）在区域 $x \\in [0, \\infty)$ 上计算积分 $F_4$ 和 $F_5$ 的常数值。\n2.  计算常数平均无量纲能量 $\\langle x \\rangle = F_5 / F_4$。\n3.  对于由元组 $(T, y)$ 指定的每个测试用例：\n    a. 计算无量纲不透明度参数 $Y = y (T/\\mathrm{MeV})^2$。注意，由于 $T$ 以 MeV 为单位给出，$T/\\mathrm{MeV}$ 是其数值。\n    b. 使用预先计算的 $F_4$、$\\langle x \\rangle$ 和 $Y$ 的值计算分母 $\\tilde{Q}_{\\mathrm{grey}}$ 的值。\n    c. 数值计算分子 $\\tilde{Q}_{\\mathrm{spec}}$ 的积分，该积分依赖于 $Y$。\n    d. 计算比率 $R(T,y) = \\tilde{Q}_{\\mathrm{spec}} / \\tilde{Q}_{\\mathrm{grey}}$。\n4.  收集所有测试用例的结果，并按要求格式化。此系统化程序确保了光谱模型和灰体模型之间的比较是基于所提供的定义自洽地进行的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives and implements a spectral leakage estimator for neutrino energy loss,\n    compares it to a grey approximation, and computes the ratio of the two\n    for a given set of test cases.\n    \"\"\"\n    \n    # --- Step 1: Compute fundamental constants via numerical integration ---\n    # As per the problem statement, the Fermi-Dirac integrals F_4 and F_5\n    # must be computed numerically.\n\n    def fn_integrand(x, n):\n        \"\"\"\n        Integrand for F_n = integral(x^n / (exp(x)+1) dx) from 0 to inf.\n        A check for large x is included to prevent potential overflow warnings,\n        though the exponential decay makes the integrand negligible for large x.\n        \"\"\"\n        if x  709:  # np.exp(709.78) is near max float64\n            return 0.0\n        return x**n / (np.exp(x) + 1.0)\n\n    # Use scipy.integrate.quad for high-precision numerical integration\n    # over the semi-infinite interval [0, inf).\n    F4, err_F4 = quad(fn_integrand, 0, np.inf, args=(4,))\n    F5, err_F5 = quad(fn_integrand, 0, np.inf, args=(5,))\n\n    # Compute the constant average dimensionless energy\n    avg_x = F5 / F4\n\n    def calculate_ratio(T, y, F4_val, avg_x_val):\n        \"\"\"\n        Calculates the ratio R(T,y) for a single test case.\n        \"\"\"\n        # a. Calculate dimensionless opacity parameter Y\n        Y = y * (T**2) # T is already in MeV, so T/MeV is just T\n\n        # b. Calculate the grey-body leakage functional Q_grey\n        tau_grey = Y * avg_x_val**2\n        phi_grey = 1.0 / (1.0 + tau_grey)\n        Q_grey = phi_grey * F4_val\n\n        # c. Calculate the spectral leakage functional Q_spec\n        def spectral_integrand(x, Y_param):\n            if x  709:\n                return 0.0\n            return (x**4) / ((np.exp(x) + 1.0) * (1.0 + Y_param * x**2))\n        \n        Q_spec, err_Q_spec = quad(spectral_integrand, 0, np.inf, args=(Y,))\n\n        # d. Compute the ratio R\n        if Q_grey == 0:\n            return np.nan # Should not happen in these test cases\n        \n        return Q_spec / Q_grey\n\n    # --- Step 2: Evaluate the ratio for each test case ---\n    test_suite = [\n        (4.0, 1e-4),   # Case A (Transparent)\n        (4.0, 1.0),    # Case B (Intermediate)\n        (4.0, 100.0),  # Case C (Opaque)\n        (8.0, 1.0),    # Case D (Temperature change)\n    ]\n\n    ratios = []\n    for T_val, y_val in test_suite:\n        ratio = calculate_ratio(T_val, y_val, F4, avg_x)\n        ratios.append(ratio)\n        \n    # --- Step 3: Format and print the output ---\n    print(f\"[{','.join([f'{r:.6f}' for r in ratios])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了更精确地描述中微子辐射场，我们从简单的泄漏方案转向更复杂的矩方法，特别是M1闭合方案。该方法的核心在于建立一个闭合关系，用以表达埃丁顿因子 $\\chi$ 与归一化能流 $f$ 的函数关系 $\\chi(f)$，而这个关系必须保证其源于一个物理上可能的中微子分布。本练习将让您亲手实现一个重要的M1闭合模型，并验证其是否满足“可实现性”（realizability）这一基本物理约束，这对于防止在模拟中出现非物理结果至关重要。",
            "id": "3524590",
            "problem": "考虑由输运方程的前两个角矩（M1）近似的中微子辐射输运。设中微子比强度是方向上的非负函数，并定义实验室参考系下的角矩如下：能量密度 $E$、通量矢量 $\\mathbf{F}$ 和辐射压力张量 $\\mathbf{P}$。约化通量或通量因子定义为 $f(\\mathbf{x}) = \\lVert \\mathbf{F}(\\mathbf{x}) \\rVert / (c\\, E(\\mathbf{x}))$，其中 $c$ 是光速。在关于通量方向旋转对称的 M1 闭合关系中，辐射压力张量遵循 $\\mathbf{P} = \\mathbf{D} E$，其中爱丁顿张量 $\\mathbf{D}$ 取决于一个标量爱丁顿因子 $\\chi(\\mathbf{x})$ 和单位矢量 $\\hat{\\mathbf{n}}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{x})/\\lVert\\mathbf{F}(\\mathbf{x})\\rVert$。具体来说，可以写作 $\\mathbf{D} = \\frac{1-\\chi}{2}\\mathbf{I} + \\frac{3\\chi - 1}{2}\\,\\hat{\\mathbf{n}}\\otimes\\hat{\\mathbf{n}}$，其中 $\\mathbf{I}$ 是单位张量。\n\n从角矩的基本定义出发，并仅使用经过充分检验的非负函数积分不等式，可知对于任何可实现的矩集，约化通量必须满足 $0 \\le f \\le 1$，平行爱丁顿因子必须满足 $f^2 \\le \\chi \\le 1$。一个具有物理动机的闭合关系必须在 $f \\to 0$ 时恢复各向同性极限（光学厚）下的 $\\chi \\to 1/3$，在 $f \\to 1$ 时恢复自由流极限下的 $\\chi \\to 1$，并且保持 $\\chi$ 对 $f$ 的单调性。\n\n任务：给定一个离散网格上的约化通量 $f(\\mathbf{x})$ 值（无量纲），实现一个具有物理动机的 M1 闭合关系来计算相应的 $\\chi(\\mathbf{x})$ 场，并评估所得的闭合关系是否在网格上处处满足可实现性约束 $0 \\le f \\le 1$ 和 $f^2 \\le \\chi \\le 1$。如果任何网格点违反了约束条件，则该测试用例被视为不可实现；否则为可实现。光速 $c$ 仅用作定义 $f$ 的缩放因子，但由于 $f$ 是直接提供的且无量纲，因此 $c$ 无需在计算中以数值形式出现。\n\n要使用的闭合关系：实现从相对论动理学理论和最大熵考虑推导出的 Levermore-Pomraning 变量爱丁顿因子闭合关系，它满足各向同性和自由流极限，并保持可实现性。所需的函数依赖关系 $\\chi(f)$ 在解答中推导得出。\n\n数值容差：为考虑浮点舍入误差，处理与边界的比较时使用容差 $\\varepsilon = 10^{-12}$。即，接受 $f \\ge -\\varepsilon$ 和 $f \\le 1+\\varepsilon$，对于计算出的 $\\chi$，接受 $f^2 - \\varepsilon \\le \\chi \\le 1+\\varepsilon$。\n\n输入规范：无输入。您的程序必须在内部定义以下通量因子网格的测试套件：\n\n- 测试用例 1（理想情况，混合值均在界限内）：一个 $4\\times 4$ 网格\n$$\n\\begin{bmatrix}\n0.05  0.25  0.50  0.75 \\\\\n0.10  0.30  0.60  0.90 \\\\\n0.20  0.40  0.70  0.95 \\\\\n0.00  0.15  0.85  1.00\n\\end{bmatrix}\n$$\n\n- 测试用例 2（违规情况：存在负值和大于一的条目）：一个 $3\\times 3$ 网格\n$$\n\\begin{bmatrix}\n-10^{-10}  0.0  0.2 \\\\\n0.9999999999  1.0  1.0000000001 \\\\\n0.5  0.8  1.2\n\\end{bmatrix}\n$$\n\n- 测试用例 3（严格在 $[0,1]$ 内的随机但可复现的值）：一个 $5\\times 5$ 网格，通过使用种子 $42$ 对伪随机数生成器进行采样，并在 $[0,1]$ 上进行独立均匀采样形成。\n\n- 测试用例 4（接近自由流边缘）：一个所有条目均等于 $0.999999999999$ 的 $3\\times 3$ 网格。\n\n- 测试用例 5（带有微小数值噪声的近各向同性边缘）：一个 $3\\times 3$ 网格\n$$\n\\begin{bmatrix}\n-10^{-16}  10^{-16}  0.0 \\\\\n10^{-14}  10^{-12}  10^{-10} \\\\\n0.0  10^{-9}  10^{-8}\n\\end{bmatrix}\n$$\n\n输出规范：对于每个测试用例，根据上述约束，生成一个布尔值，指示闭合关系是否在网格上处处可实现。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”）。不允许有其他输出。所有量都是无量纲的，因此不需要单位换算。",
            "solution": "在尝试给出解答之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **模型**：中微子辐射输运由前两个角矩（M1）近似。\n- **定义**：\n    - 角矩：能量密度 $E$、通量矢量 $\\mathbf{F}$、辐射压力张量 $\\mathbf{P}$。\n    - 约化通量（通量因子）：$f(\\mathbf{x}) = \\lVert \\mathbf{F}(\\mathbf{x}) \\rVert / (c\\, E(\\mathbf{x}))$。\n    - 辐射压力张量形式：$\\mathbf{P} = \\mathbf{D} E$，其中 $\\mathbf{D}$ 是爱丁顿张量。\n    - 爱丁顿张量形式：$\\mathbf{D} = \\frac{1-\\chi}{2}\\mathbf{I} + \\frac{3\\chi - 1}{2}\\,\\hat{\\mathbf{n}}\\otimes\\hat{\\mathbf{n}}$，其中 $\\hat{\\mathbf{n}}(\\mathbf{x}) = \\mathbf{F}(\\mathbf{x})/\\lVert\\mathbf{F}(\\mathbf{x})\\rVert$。\n- **基本约束（可实现性）**：\n    - 对于约化通量：$0 \\le f \\le 1$。\n    - 对于爱丁顿因子：$f^2 \\le \\chi \\le 1$。\n- **具有物理动机的闭合关系的物理极限**：\n    - 各向同性极限：当 $f \\to 0$ 时，$\\chi \\to 1/3$。\n    - 自由流极限：当 $f \\to 1$ 时，$\\chi \\to 1$。\n    - 单调性：$\\chi$ 必须是 $f$ 的单调递增函数。\n- **任务**：\n    1. 实现 Levermore-Pomraning 变量爱丁顿因子闭合关系 $\\chi(f)$。\n    2. 对于几个 $f$ 值网格，计算相应的 $\\chi$ 值。\n    3. 评估闭合关系在每个网格点上是否“可实现”，这意味着使用指定的数值容差验证约束条件。\n- **数值容差**：$\\varepsilon = 10^{-12}$。\n    - $f$ 的约束：接受 $f \\ge -\\varepsilon$ 和 $f \\le 1+\\varepsilon$。\n    - $\\chi$ 的约束：接受 $f^2 - \\varepsilon \\le \\chi \\le 1+\\varepsilon$。\n- **输入数据（测试用例）**：\n    - 测试用例 $1$：一个 $4\\times 4$ 的 $f$ 值网格：\n    $$\n    \\begin{bmatrix}\n    0.05  0.25  0.50  0.75 \\\\\n    0.10  0.30  0.60  0.90 \\\\\n    0.20  0.40  0.70  0.95 \\\\\n    0.00  0.15  0.85  1.00\n    \\end{bmatrix}\n    $$\n    - 测试用例 $2$：一个 $3\\times 3$ 的 $f$ 值网格：\n    $$\n    \\begin{bmatrix}\n    -10^{-10}  0.0  0.2 \\\\\n    0.9999999999  1.0  1.0000000001 \\\\\n    0.5  0.8  1.2\n    \\end{bmatrix}\n    $$\n    - 测试用例 $3$：一个 $5\\times 5$ 的伪随机数网格，使用种子 $42$ 从 $[0,1]$ 中均匀采样。\n    - 测试用例 $4$：一个所有条目均等于 $0.999999999999$ 的 $3\\times 3$ 网格。\n    - 测试用例 $5$：一个 $3\\times 3$ 的 $f$ 值网格：\n    $$\n    \\begin{bmatrix}\n    -10^{-16}  10^{-16}  0.0 \\\\\n    10^{-14}  10^{-12}  10^{-10} \\\\\n    0.0  10^{-9}  10^{-8}\n    \\end{bmatrix}\n    $$\n\n### 步骤 2：使用提取的已知条件进行验证\n问题具有科学依据，是适定且客观的。\n- **科学依据**：M1 闭合方法、角矩、爱丁顿因子和可实现性条件是辐射输运理论和计算天体物理学中标准的、成熟的概念。Levermore-Pomraning 闭合关系是一个广泛使用的、具有物理动机的模型，源自相对论动理学的最大熵原理。\n- **适定性**：问题明确定义了任务：实现一个特定的函数 $\\chi(f)$，并对给定的输入验证一组不等式。闭合函数是唯一确定的，验证标准是精确的，包括数值容差。每个测试用例都存在唯一的解。\n- **客观性**：问题以形式化的数学语言陈述，没有歧义或主观论断。\n- **完整性和一致性**：所有必要的信息都已提供：物理模型、要使用的具体闭合关系（通过名称）、要检查的约束、数值容差以及明确的测试数据。没有内部矛盾。\n\n### 步骤 3：结论和行动\n问题被判定为**有效**。将提供解答。\n\n### 解答\n任务是实现用于中微子输运的 Levermore-Pomraning 矩闭合关系，并在几个约化通量因子 $f$ 的网格上验证其可实现性。\n\n#### Levermore-Pomraning M1 闭合关系\nM1 闭合问题旨在将爱丁顿因子 $\\chi$ 表示为约化通量 $f$ 的函数，即 $\\chi = \\chi(f)$。这使得矩方程组得以闭合。Levermore-Pomraning 闭合关系是通过最大化辐射场的熵推导出来的，这是借鉴自统计力学的原理。此过程为底层的中微子分布函数产生了一个特定的函数形式，从中可以计算出矩 $E$、$\\mathbf{F}$ 和 $\\mathbf{P}$。通过消去分布的参数以支持矩，便可得到所需的闭合关系。对于相对论气体，此关系为：\n$$\n\\chi(f) = \\frac{3 + 4f^2}{5 + 2\\sqrt{4 - 3f^2}}\n$$\n该函数定义于 $4 - 3f^2 \\ge 0$，这意味着 $f^2 \\le 4/3$，或 $|f| \\le 2/\\sqrt{3} \\approx 1.1547$。这个定义域很轻松地包含了我们感兴趣的物理范围 $f \\in [0, 1]$。\n\n#### 物理性质的验证\n一个物理上合理的闭合关系必须满足几个关键性质，我们对 Levermore-Pomraning 公式进行验证。\n\n$1$. **各向同性极限**：当介质变得光学厚时，散射使辐射场各向同性化，通量消失，因此 $f \\to 0$。压力应变为各向同性，$P_{ij} = (E/3)\\delta_{ij}$，这意味着 $\\chi \\to 1/3$。\n$$\n\\lim_{f \\to 0} \\chi(f) = \\frac{3 + 4(0)^2}{5 + 2\\sqrt{4 - 3(0)^2}} = \\frac{3}{5 + 2\\sqrt{4}} = \\frac{3}{5+4} = \\frac{3}{9} = \\frac{1}{3}\n$$\n该极限被正确地恢复了。\n\n$2$. **自由流极限**：在真空或光学薄介质中，中微子沿单一方向流动。通量大小接近其最大可能值 $cE$，因此 $f \\to 1$。在此极限下，压力张量变为 $P_{ij} = E \\hat{n}_i \\hat{n}_j$，这意味着 $\\chi \\to 1$。\n$$\n\\lim_{f \\to 1} \\chi(f) = \\frac{3 + 4(1)^2}{5 + 2\\sqrt{4 - 3(1)^2}} = \\frac{3+4}{5 + 2\\sqrt{1}} = \\frac{7}{7} = 1\n$$\n这个极限也被正确地恢复了。\n\n$3$. **可实现性**：对于所有 $f \\in [0, 1]$，闭合关系必须遵守基本约束 $f^2 \\le \\chi(f) \\le 1$。\n- **上界 ($\\chi \\le 1$)**：我们已经证明了 $\\chi(1)=1$。我们可以证明对于 $f \\in [0,1]$，$\\chi(f)$ 是单调递增的。其导数为 $\\chi'(f) = \\frac{f \\left( 48 + 8\\sqrt{4-3f^2} + \\frac{18+24f^2}{\\sqrt{4-3f^2}} \\right)}{(5+2\\sqrt{4-3f^2})^2}$。对于 $f \\in [0,1)$，所有项均为正，因此 $\\chi'(f) \\ge 0$。由于函数从 $\\chi(0)=1/3$ 增加到 $\\chi(1)=1$，因此对于 $f \\in [0,1]$，上界 $\\chi(f) \\le 1$ 得到满足。\n- **下界 ($\\chi \\ge f^2$)**：我们需要证明 $\\frac{3 + 4f^2}{5 + 2\\sqrt{4 - 3f^2}} \\ge f^2$。由于对于 $f \\in (0,1]$，两边都是正的，我们可以操作这个不等式：\n$$\n3 + 4f^2 \\ge 5f^2 + 2f^2\\sqrt{4 - 3f^2}\n$$\n$$\n3 - f^2 \\ge 2f^2\\sqrt{4 - 3f^2}\n$$\n对于 $f \\in [0,1]$，左侧的 $3-f^2$ 是正的。我们可以对两边平方：\n$$\n(3-f^2)^2 \\ge 4f^4(4-3f^2)\n$$\n$$\n9 - 6f^2 + f^4 \\ge 16f^4 - 12f^6\n$$\n$$\n12f^6 - 15f^4 - 6f^2 + 9 \\ge 0\n$$\n设 $y=f^2$，其中 $y \\in [0,1]$。不等式变为 $12y^3 - 15y^2 - 6y + 9 \\ge 0$。我们可以因式分解这个多项式。注意到 $y=1$ 是一个根：$12-15-6+9=0$。除以 $(y-1)$ 得到 $12y^2-3y-9$。再次因式分解， $y=1$ 是这个二次式的根：$12-3-9=0$。将 $12y^2-3y-9$ 除以 $(y-1)$ 得到 $12y+9$。所以，多项式是 $ (y-1)^2(12y+9) = 3(y-1)^2(4y+3) $。\n不等式是 $3(f^2-1)^2(4f^2+3) \\ge 0$。对于任何实数 $f$，项 $(f^2-1)^2$ 和 $(4f^2+3)$ 都是非负的。因此，不等式成立，下界 $\\chi(f) \\ge f^2$ 得到满足。\n\n#### 算法实现与测试用例分析\n对每个 $f$ 值网格的验证过程涉及逐点检查。设 $\\varepsilon = 10^{-12}$ 为指定的容差。对于给定网格中的每个值 $f_{ij}$：\n\n$1$. **输入验证**：检查 $f_{ij}$ 是否在允许的数值范围内。条件是 $f_{ij} \\ge -\\varepsilon$ 且 $f_{ij} \\le 1+\\varepsilon$。如果网格上的任何 $f_{ij}$ 违反了此条件，则整个测试用例被视为不可实现。\n\n$2$. **闭合关系计算**：如果 $f_{ij}$ 有效，则使用 Levermore-Pomraning 公式计算 $\\chi_{ij}$。平方根的参数 $4 - 3f_{ij}^2$ 对于所有有效输入都保证为非负，因为允许的最大 $f_{ij}$ 是 $1+\\varepsilon$，而 $4 - 3(1+\\varepsilon)^2 \\approx 4 - 3(1+2\\varepsilon) = 1-6\\varepsilon > 0$。\n\n$3$. **输出验证**：检查计算出的 $\\chi_{ij}$ 是否满足带容差的可实现性条件。条件是 $\\chi_{ij} \\ge f_{ij}^2 - \\varepsilon$ 且 $\\chi_{ij} \\le 1+\\varepsilon$。\n\n我们的分析证明，对于任何 $f \\in [0,1]$，该闭合关系会自动产生一个可实现的 $\\chi$。可以进一步证明，即使对于容差所允许的微小扰动，即对于 $f \\in [-\\varepsilon, 1+\\varepsilon]$，这也成立。因此，一个测试用例可实现的充分必要条件是其所有输入 $f$ 值都满足步骤 1 的条件。\n\n- **测试用例 1**：所有值都在 $[0.00, 1.00]$ 内。这些都是有效的。结果：**可实现**。\n- **测试用例 2**：包含几个无效值。\n    - $f = -10^{-10}$。我们检查 $-10^{-10} \\ge -\\varepsilon \\implies -10^{-10} \\ge -10^{-12}$。这是错误的，因为 $10^{-10} > 10^{-12}$。因此，这个输入是无效的。\n    - $f = 1.0000000001 = 1 + 10^{-10}$。我们检查 $1+10^{-10} \\le 1+\\varepsilon \\implies 1+10^{-10} \\le 1+10^{-12}$。这也是错误的。\n    这些无效输入的存在使得该网格不可实现。结果：**不可实现**。\n- **测试用例 3**：随机值从 $[0,1]$ 中采样，因此都是有效的。结果：**可实现**。\n- **测试用例 4**：值 $f = 0.999999999999 = 1 - 10^{-12}$ 显然在有效范围内。结果：**可实现**。\n- **测试用例 5**：包含接近零的较小值。\n    - $f = -10^{-16}$。我们检查 $-10^{-16} \\ge -\\varepsilon \\implies -10^{-16} \\ge -10^{-12}$。这是正确的，因为 $10^{-16}  10^{-12}$。这个值是有效的。\n    网格中的所有其他值，如 $10^{-16}$、$10^{-14}$ 等，也都在 $[-\\varepsilon, 1+\\varepsilon]$ 范围内。由于所有输入都有效，该测试用例是可实现的。结果：**可实现**。\n\n五个测试用例的预期布尔结果是：`[True, False, True, True, True]`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Levermore-Pomraning M1 closure and validates realizability\n    for a suite of test cases according to the problem description.\n    \"\"\"\n\n    # Define the numerical tolerance.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_case_1 = np.array([\n        [0.05, 0.25, 0.50, 0.75],\n        [0.10, 0.30, 0.60, 0.90],\n        [0.20, 0.40, 0.70, 0.95],\n        [0.00, 0.15, 0.85, 1.00]\n    ])\n\n    test_case_2 = np.array([\n        [-1e-10, 0.0, 0.2],\n        [0.9999999999, 1.0, 1.0000000001],\n        [0.5, 0.8, 1.2]\n    ])\n\n    # Generate test case 3 using the specified seed.\n    np.random.seed(42)\n    test_case_3 = np.random.rand(5, 5)\n\n    test_case_4 = np.full((3, 3), 0.999999999999)\n\n    test_case_5 = np.array([\n        [-1e-16, 1e-16, 0.0],\n        [1e-14, 1e-12, 1e-10],\n        [0.0, 1e-9, 1e-8]\n    ])\n    \n    test_cases = [\n        test_case_1,\n        test_case_2,\n        test_case_3,\n        test_case_4,\n        test_case_5,\n    ]\n\n    def check_realizability(f_grid, tol):\n        \"\"\"\n        Checks a grid of flux factors for realizability.\n\n        Args:\n            f_grid: A numpy array of reduced flux values.\n            tol: The numerical tolerance for comparisons.\n\n        Returns:\n            A boolean, True if the grid is realizable, False otherwise.\n        \"\"\"\n        for f in f_grid.flatten():\n            # 1. Validate the input flux factor f.\n            # Must satisfy f = -tol and f = 1 + tol.\n            if f  -tol or f  1.0 + tol:\n                return False\n\n            # 2. Compute the Eddington factor chi using the Levermore-Pomraning closure.\n            # The argument to the square root is guaranteed to be non-negative\n            # because the check on f ensures |f| = 1 + tol  2/sqrt(3).\n            # To be robust against any floating point issues, clip to 0.\n            sqrt_arg = max(0.0, 4.0 - 3.0 * f**2)\n            chi = (3.0 + 4.0 * f**2) / (5.0 + 2.0 * np.sqrt(sqrt_arg))\n\n            # 3. Validate the computed chi.\n            # Must satisfy f^2 - tol = chi = 1 + tol.\n            lower_bound = f**2 - tol\n            upper_bound = 1.0 + tol\n            if chi  lower_bound or chi  upper_bound:\n                return False\n        \n        # If all points in the grid pass the checks, the case is realizable.\n        return True\n\n    results = []\n    for case in test_cases:\n        is_realizable = check_realizability(case, epsilon)\n        results.append(is_realizable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在将M1这类矩方法付诸实践时，我们必须解决一个关键的数值挑战：确保模拟遵守因果律，即中微子能流的大小 $|F|$ 不能超过由光速 $c$ 和能量密度 $E$ 决定的上限 $cE$。一个朴素的数值格式可能在光学薄的区域违反此约束，导致非物理的结果。本练习旨在指导您设计并实现一个“能流限制器”（flux-capping）算法来强制满足这一物理约束，同时您还将验证该算法在保证总能量守恒方面的关键作用，这是构建可靠的守恒型数值格式的核心技能。",
            "id": "3524567",
            "problem": "考虑中微子辐射矩方程的一维周期性有限体积离散化，其中演化的量是网格单元索引为 $i$ 的中微子能量密度 $E_i$（单位为 $\\mathrm{erg}/\\mathrm{cm}^3$）和位于网格单元 $i$ 和 $i+1$ 之间界面上的面心通量 $F_{i+1/2}$（单位为 $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$）。光速为 $c$（单位为 $\\mathrm{cm}/\\mathrm{s}$）。在任何从正分布函数推导出的、传播速度受光速限制的矩公式中，因果性约束要求通量的大小不能超过由能量密度设定的自由流限制，即 $|F| \\le c\\,E$。在一个耦合相邻网格单元的、基于面的离散格式中，对该约束的一种保守的逐面强制方法使用边界 $|F_{i+1/2}| \\le c \\,\\min(E_i,E_{i+1})$。\n\n要求您设计并实现一种诊断和校正（通量限制）算法，该算法在任意时间步长下，保证离散因果性约束，同时在有限体积更新下精确守恒总能量。使用以下基本公式：能量密度的守恒型有限体积更新，\n$$\nE_i^{n+1} \\;=\\; E_i^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\,\\left( F_{i+1/2}^{\\mathrm{cap}} \\;-\\; F_{i-1/2}^{\\mathrm{cap}} \\right),\n$$\n其中 $\\Delta x$ 是网格单元宽度（单位为 $\\mathrm{cm}$），$\\Delta t$ 是时间步长（单位为 $\\mathrm{s}$），$F^{\\mathrm{cap}}$ 表示更新中使用的可能被限制过的面通量。周期性边界条件意味着面的索引根据网格单元数量取模回绕。\n\n对于每个测试用例，您的程序必须执行以下操作：\n- 执行诊断，检查限制后每个面上的因果性约束，即 $|F_{i+1/2}^{\\mathrm{cap}}| \\le c\\,\\min(E_i,E_{i+1})$。\n- 应用一种通量限制算法，对任何违反因果性的面通量进行重新缩放以满足因果性，而不改变更新前相关的能量密度。\n- 在周期性边界条件下，使用限制后的面通量通过上述守恒型有限体积公式更新所有 $E_i$，然后计算更新前后的总能量。通过检查更新前后的总能量绝对差值小于或等于 $10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$ 来验证总能量在机器精度范围内是守恒的，其中 $\\varepsilon_{\\mathrm{mach}}$ 是双精度浮点数的机器 epsilon。\n\n通量限制要求。对于每个面 $(i+1/2)$，定义 $b_{i+1/2} = c\\,\\min(E_i,E_{i+1})$ 和 $f_{i+1/2} = |F_{i+1/2}|$。如果 $f_{i+1/2} \\le b_{i+1/2}$，则保持 $F_{i+1/2}$ 不变。否则，设置\n$$\n\\alpha_{i+1/2} \\;=\\; \\frac{b_{i+1/2}}{f_{i+1/2} + \\eta}, \\qquad F_{i+1/2}^{\\mathrm{cap}} \\;=\\; \\alpha_{i+1/2}\\,F_{i+1/2},\n$$\n其中 $\\eta$ 是一个小的正则化参数（单位为 $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$），用于避免除以零，并在 $f_{i+1/2}$ 极小时保持数值鲁棒性。在限制过程中，能量密度 $E_i$ 不会改变；守恒是通过在更新中对相邻的两个网格单元使用相同的限制后面通量来实现的。在此一维公式中不出现角度。\n\n数值单位。对 $E$ 使用 $\\mathrm{erg}/\\mathrm{cm}^3$，对 $F$ 使用 $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$，对 $c$ 使用 $\\mathrm{cm}/\\mathrm{s}$，对 $\\Delta x$ 使用 $\\mathrm{cm}$，对 $\\Delta t$ 使用 $\\mathrm{s}$。\n\n测试套件。使用光速 $c = 2.99792458 \\times 10^{10}\\,\\mathrm{cm}/\\mathrm{s}$。对于每个案例，区域是周期性的，面的索引根据网格单元数量取模。程序必须评估以下五个测试用例：\n1. 亚因果通量的正常路径：$N = 4$，$\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$，$\\Delta t = 1.0 \\times 10^{-6}\\,\\mathrm{s}$，$E = [1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$（单位 $\\mathrm{erg}/\\mathrm{cm}^3$），以及面上的 $F$ 等于 $[+0.2\\,c\\,E_{\\min,0},\\,-0.1\\,c\\,E_{\\min,1},\\,+0.05\\,c\\,E_{\\min,2},\\,-0.15\\,c\\,E_{\\min,3}]$（单位 $\\mathrm{erg}/(\\mathrm{cm}^2\\,\\mathrm{s})$），其中 $E_{\\min,i} = \\min(E_i,E_{i+1})$，索引为周期性。\n2. 需要限制的超调：$N = 4$，$\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$，$\\Delta t = 3.0 \\times 10^{-6}\\,\\mathrm{s}$，$E = [1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$，以及 $F = [+1.5\\,c\\,E_{\\min,0},\\,+1.2\\,c\\,E_{\\min,1},\\,-0.9\\,c\\,E_{\\min,2},\\,+2.0\\,c\\,E_{\\min,3}]$。\n3. 零能量单元边界情况：$N = 4$，$\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$，$\\Delta t = 2.0 \\times 10^{-6}\\,\\mathrm{s}$，$E = [0.0,\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25},\\,1.0 \\times 10^{25}]$，以及 $F = [+0.5\\,c\\,E_{\\min,0},\\,+0.5\\,c\\,E_{\\min,1},\\,+0.5\\,c\\,E_{\\min,2},\\,+0.5\\,c\\,E_{\\min,3}]$。\n4. 任意大时间步长：$N = 4$，$\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$，$\\Delta t = 1.0 \\times 10^{-1}\\,\\mathrm{s}$，$E = [1.0 \\times 10^{20},\\,1.0 \\times 10^{20},\\,1.0 \\times 10^{20},\\,1.0 \\times 10^{20}]$，以及 $F = [+3.0\\,c\\,E_{\\min,0},\\,-3.0\\,c\\,E_{\\min,1},\\,+3.0\\,c\\,E_{\\min,2},\\,-3.0\\,c\\,E_{\\min,3}]$。\n5. 混合振幅和符号：$N = 4$，$\\Delta x = 1.0 \\times 10^{5}\\,\\mathrm{cm}$，$\\Delta t = 5.0 \\times 10^{-6}\\,\\mathrm{s}$，$E = [8.0 \\times 10^{24},\\,2.0 \\times 10^{25},\\,5.0 \\times 10^{24},\\,9.0 \\times 10^{25}]$，以及 $F = [+4.0\\,c\\,E_{\\min,0},\\,-0.3\\,c\\,E_{\\min,1},\\,+1.1\\,c\\,E_{\\min,2},\\,-2.3\\,c\\,E_{\\min,3}]$。\n\n所需输出格式。对于每个测试用例，返回一个布尔值，当且仅当以下两个条件都成立时，该值为 $\\,\\texttt{True}\\,$：(a) 限制后所有面都满足 $|F_{i+1/2}^{\\mathrm{cap}}| \\le c\\,\\min(E_i,E_{i+1})$，以及 (b) 在周期性边界条件下进行有限体积更新后，总能量差小于或等于 $10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[\\texttt{True},\\texttt{False},\\texttt{True},\\texttt{True},\\texttt{True}]$。",
            "solution": "该问题被评估为有效。它在科学上基于计算天体物理学和守恒律数值方法的原理。该问题是适定的，所有必要的数据和算法都已指定，从而可以得到一个唯一的、可验证的解。它是客观的，不含任何非科学主张。关于正则化参数 $\\eta$ 的唯一模糊之处，通过在问题陈述的目标背景下选择最合乎逻辑的值得以解决。\n\n任务是为中微子辐射输运的一维有限体积离散化设计并测试一个数值算法。该算法必须在中微子能量通量上强制施加物理因果性约束，同时精确守恒总中微子能量。我们将首先阐述其基本原理，然后详细说明指定算法和检查的实现。\n\n**1. 有限体积公式与守恒性**\n\n计算单元 $i$ 中中微子能量密度 $E_i$ 的演化由守恒型有限体积更新方程决定：\n$$\nE_i^{n+1} \\;=\\; E_i^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\,\\left( F_{i+1/2}^{\\mathrm{cap}} \\;-\\; F_{i-1/2}^{\\mathrm{cap}} \\right)\n$$\n此处，$E_i^n$ 和 $E_i^{n+1}$ 分别是时间层 $n$ 和 $n+1$ 的能量密度。量 $\\Delta x$ 和 $\\Delta t$ 代表恒定的单元宽度和时间步长。项 $F_{i+1/2}^{\\mathrm{cap}}$ 和 $F_{i-1/2}^{\\mathrm{cap}}$ 是单元 $i$ 左右两个面上的数值通量。这种“通量差分”形式是守恒格式的标志。\n\n为了验证能量守恒，我们将区域中所有单元的能量变化相加。时间 $n$ 的总能量为 $E_{\\text{tot}}^n = \\sum_{i=0}^{N-1} E_i^n$。一个时间步长后的总能量变化是：\n$$\n\\Delta E_{\\text{tot}} = E_{\\text{tot}}^{n+1} - E_{\\text{tot}}^{n} = \\sum_{i=0}^{N-1} (E_i^{n+1} - E_i^n) = \\sum_{i=0}^{N-1} \\left[-\\frac{\\Delta t}{\\Delta x}\\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right)\\right]\n$$\n对于具有 $N$ 个单元的周期性区域，通量的索引按模 $N$ 解释。例如，单元 $0$ 的左面是索引为 $-1/2$ 的面，等同于面 $N-1+1/2$。通量差之和变成一个伸缩求和：\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right) = \\left(F_{1/2}^{\\mathrm{cap}} - F_{N-1+1/2}^{\\mathrm{cap}}\\right) + \\left(F_{1+1/2}^{\\mathrm{cap}} - F_{1/2}^{\\mathrm{cap}}\\right) + \\dots + \\left(F_{N-1+1/2}^{\\mathrm{cap}} - F_{N-2+1/2}^{\\mathrm{cap}}\\right)\n$$\n由于周期性边界条件，每个通量项 $F_{i+1/2}^{\\mathrm{cap}}$ 都出现两次，符号相反。例如，$F_{1/2}^{\\mathrm{cap}}$ 作为 $i=0$ 的正项出现，作为 $i=1$ 的负项出现。因此，在精确算术中，该和恒为零。\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{\\mathrm{cap}} - F_{i-1/2}^{\\mathrm{cap}} \\right) = 0\n$$\n这意味着 $\\Delta E_{\\text{tot}} = 0$，即总能量守恒。在浮点运算中，我们期望这种守恒性保持在机器精度范围内。问题为此指定了一个验证容差：$|\\sum E_i^{n+1} - \\sum E_i^n| \\le 10\\,\\varepsilon_{\\mathrm{mach}} \\sum_i |E_i^{n}|$。\n\n**2. 因果性约束与通量限制**\n\n相对论物理学的一个基本原理是信息和能量的传播速度不能超过光速 $c$。对于辐射输运，这意味着能量通量的大小 $|F|$ 不能超过能量密度 $E$ 乘以 $c$：$|F| \\le cE$。这就是因果性或“自由流”限制。\n\n在离散有限体积格式中，这一原理在单元面上强制执行。通量 $F_{i+1/2}$ 在单元 $i$ 和 $i+1$ 之间传递。对于局部能量密度边界，一个保守的选择是取两个相邻单元中的最小值，从而得到离散因果性约束：\n$$\n|F_{i+1/2}| \\le c \\, \\min(E_i, E_{i+1})\n$$\n如果一个未限制的数值通量 $F_{i+1/2}$ 违反了此约束，它必须被校正或“限制”。规定的通量限制算法是：\n1. 定义面 $i+1/2$ 的因果性边界：$b_{i+1/2} = c\\,\\min(E_i, E_{i+1})$。\n2. 定义未限制通量的大小：$f_{i+1/2} = |F_{i+1/2}|$。\n3. 如果 $f_{i+1/2} > b_{i+1/2}$，则通量是超因果的，必须重新缩放。\n4. 重新缩放（限制）后的通量计算为 $F_{i+1/2}^{\\mathrm{cap}} = \\alpha_{i+1/2}\\,F_{i+1/2}$，缩放因子为 $\\alpha_{i+1/2} = \\frac{b_{i+1/2}}{f_{i+1/2} + \\eta}$。\n5. 如果 $f_{i+1/2} \\le b_{i+1/2}$，则通量已经是亚因果的，所以 $F_{i+1/2}^{\\mathrm{cap}} = F_{i+1/2}$。\n\n问题引入了一个小的正正则化参数 $\\eta$ 以防止除以零。然而，限制逻辑仅在 $f_{i+1/2} > b_{i+1/2}$ 时触发。由于能量密度是非负的，所以 $b_{i+1/2} \\ge 0$，这意味着要发生限制，$f_{i+1/2}$ 必须为严格正数。因此，除以零通量大小不是问题。最自然和最小的修正是将通量大小精确地缩放到边界，即 $|F_{i+1/2}^{\\mathrm{cap}}| = b_{i+1/2}$。这通过设置 $\\eta = 0$ 实现，得到 $\\alpha_{i+1/2} = b_{i+1/2} / f_{i+1/2}$。我们将在实现中采用这个选择，即 $\\eta=0$。\n\n**3. 每个测试用例的算法流程**\n\n对于每个提供的测试用例，执行以下操作序列：\n1.  **初始化**：设置物理常数 $c$、网格参数 $N, \\Delta x, \\Delta t$ 和初始能量密度数组 $E^n$。\n2.  **通量计算**：根据每个测试用例中给出的表达式（例如 $+1.5\\,c\\,E_{\\min,0}$），计算初始数值通量数组 $F$。这首先需要为每个面计算 $E_{\\min,i} = \\min(E_i, E_{i+1 \\pmod N})$。\n3.  **存储初始状态**：计算并存储初始总能量 $E_{\\text{tot}}^n = \\sum_i E_i^n$。\n4.  **通量限制**：\n    a. 将限制后的通量数组 $F^{\\mathrm{cap}}$ 初始化为 $F$ 的副本。\n    b. 对于每个面 $i+1/2$（从 $i=0$ 到 $N-1$）：\n       i. 计算边界 $b_{i+1/2} = c\\,\\min(E_i, E_{(i+1) \\pmod N})$。\n       ii. 计算通量大小 $f_{i+1/2} = |F_{i+1/2}|$。\n       iii. 如果 $f_{i+1/2} > b_{i+1/2}$，更新该面的限制后通量：$F_{i}^{\\mathrm{cap}} \\leftarrow (b_{i+1/2} / f_{i+1/2}) \\times F_{i}$。注意数组索引 $i$ 对应于面 $i+1/2$。\n5.  **因果性验证**：\n    a. 将布尔标志 `causality_ok` 初始化为 `True`。\n    b. 对于每个面 $i+1/2$：\n       i. 重新计算边界 $b_{i+1/2} = c\\,\\min(E_i, E_{(i+1) \\pmod N})$。\n       ii. 检查是否 $|F_{i}^{\\mathrm{cap}}| \\le b_{i+1/2} \\times (1 + 10\\varepsilon_{\\mathrm{mach}})$。此比较使用一个小的浮点容差以考虑潜在的舍入误差。如果条件不满足，则将 `causality_ok` 设置为 `False`。\n6.  **能量更新**：\n    a. 创建一个新数组 $E^{n+1}$ 来存储更新后的能量密度。\n    b. 对于每个单元 $i$（从 $0$ 到 $N-1$）：\n       i. 确定右面通量 $F_{\\text{right}} = F_{(i)}^{\\mathrm{cap}}$ 和左面通量 $F_{\\text{left}} = F_{(i-1) \\pmod N}^{\\mathrm{cap}}$。\n       ii. 应用有限体积公式：$E_i^{n+1} = E_i^n - (\\Delta t / \\Delta x) \\times (F_{\\text{right}} - F_{\\text{left}})$。\n7.  **守恒性验证**：\n    a. 计算最终总能量 $E_{\\text{tot}}^{n+1} = \\sum_i E_i^{n+1}$。\n    b. 计算初始总能量范数 $\\sum_i |E_i^n|$。\n    c. 布尔标志 `conservation_ok` 由条件 $|\\,E_{\\text{tot}}^{n+1} - E_{\\text{tot}}^n\\,| \\le 10 \\times \\varepsilon_{\\mathrm{mach}} \\times \\sum_i |E_i^n|$ 确定。如果初始能量总和为零，则必须改用绝对容差检查。\n8.  **最终结果**：测试用例的结果是两个验证标志的逻辑与：`result = causality_ok and conservation_ok`。\n\n此过程系统地应用于所有五个测试用例，以生成最终的布尔结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neutrino transport problem by applying and verifying a flux-capping algorithm.\n    \"\"\"\n    C_LIGHT = 2.99792458e10  # cm/s\n    MACHINE_EPSILON = np.finfo(np.double).eps\n\n    test_cases = [\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 1.0e-6,\n            \"E0\": np.array([1.0e25, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+0.2, -0.1, +0.05, -0.15])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 3.0e-6,\n            \"E0\": np.array([1.0e25, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+1.5, +1.2, -0.9, +2.0])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 2.0e-6,\n            \"E0\": np.array([0.0, 1.0e25, 1.0e25, 1.0e25]),\n            \"F_factors\": np.array([+0.5, +0.5, +0.5, +0.5])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 1.0e-1,\n            \"E0\": np.array([1.0e20, 1.0e20, 1.0e20, 1.0e20]),\n            \"F_factors\": np.array([+3.0, -3.0, +3.0, -3.0])\n        },\n        {\n            \"N\": 4, \"dx\": 1.0e5, \"dt\": 5.0e-6,\n            \"E0\": np.array([8.0e24, 2.0e25, 5.0e24, 9.0e25]),\n            \"F_factors\": np.array([+4.0, -0.3, +1.1, -2.3])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case, C_LIGHT, MACHINE_EPSILON)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data, c, eps):\n    \"\"\"\n    Processes a single test case.\n    \"\"\"\n    N = case_data[\"N\"]\n    dx = case_data[\"dx\"]\n    dt = case_data[\"dt\"]\n    E_n = case_data[\"E0\"].astype(np.double)\n    F_factors = case_data[\"F_factors\"].astype(np.double)\n\n    # 1. Calculate initial uncapped fluxes F\n    # F[i] is at face i+1/2, between cells i and (i+1)%N\n    E_min_face = np.zeros(N, dtype=np.double)\n    for i in range(N):\n        E_min_face[i] = min(E_n[i], E_n[(i + 1) % N])\n    \n    F_uncapped = F_factors * c * E_min_face\n\n    # 2. Store initial total energy\n    total_energy_n = np.sum(E_n)\n\n    # 3. Apply flux capping\n    F_capped = np.copy(F_uncapped)\n    bounds = c * E_min_face\n    \n    for i in range(N):\n        f_mag = np.abs(F_capped[i])\n        b_i = bounds[i]\n        \n        # Capping is applied if |F|  b. Using a small tolerance for the comparison.\n        if f_mag  b_i + eps:\n            # We choose eta=0, which corresponds to scaling to the bound.\n            # alpha = b_i / (f_mag + eta). For eta=0, alpha = b_i / f_mag.\n            # F_capped[i] = alpha * F_capped[i]\n            # This is equivalent to F_capped[i] = (b_i / f_mag) * F_capped[i]\n            # To preserve the sign:\n            F_capped[i] = np.sign(F_capped[i]) * b_i\n\n    # 4. Diagnostic 1: Check causality post-capping\n    # |F_capped[i]| = c * min(E_n[i], E_n[(i+1)%N])\n    causality_ok = True\n    f_capped_mags = np.abs(F_capped)\n    # Use a small tolerance for floating point comparison\n    # Check if f_capped_mags[i] = bounds[i] for all i\n    if not np.all(f_capped_mags = bounds + 10 * eps * (np.abs(bounds) + 1.0)):\n        causality_ok = False\n\n    # 5. Update energy densities\n    E_np1 = np.zeros(N, dtype=np.double)\n    dt_dx = dt / dx\n    for i in range(N):\n        F_right = F_capped[i]\n        F_left = F_capped[(i - 1 + N) % N]\n        E_np1[i] = E_n[i] - dt_dx * (F_right - F_left)\n\n    # 6. Diagnostic 2: Check energy conservation\n    total_energy_np1 = np.sum(E_np1)\n    energy_diff = np.abs(total_energy_np1 - total_energy_n)\n    \n    sum_abs_E_n = np.sum(np.abs(E_n))\n    # Handle case where initial total energy is zero\n    if sum_abs_E_n  0:\n        conservation_tolerance = 10 * eps * sum_abs_E_n\n    else:\n        conservation_tolerance = 10 * eps\n\n    conservation_ok = energy_diff = conservation_tolerance\n    \n    # 7. Final result for the case\n    return causality_ok and conservation_ok\n\nsolve()\n```"
        }
    ]
}