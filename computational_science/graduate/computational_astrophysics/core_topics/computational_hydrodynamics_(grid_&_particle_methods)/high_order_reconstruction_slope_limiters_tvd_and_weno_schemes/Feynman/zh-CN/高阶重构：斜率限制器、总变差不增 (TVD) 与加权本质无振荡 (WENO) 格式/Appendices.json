{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的高阶格式之前，我们首先需要建立一个坚实的基础，理解为什么“高阶”是值得追求的。本练习将引导你使用经典的泰勒级数展开方法，来量化分析从分段常数（一阶Godunov格式）到分段线性（二阶MUSCL格式）重构的精度提升。通过这个“纸笔”推导，你将亲手揭示高阶方法在光滑区域能够更快收敛到精确解的根本原因，从而为我们后续学习更复杂的TVD和WENO格式提供理论动机。",
            "id": "3514794",
            "problem": "考虑常速度 $a>0$ 的线性平流方程 $u_{t} + a u_{x} = 0$，该方程定义在具有网格中心 $x_{i}$ 和间距 $\\Delta x$ 的均匀网格上。在天体物理流体动力学中使用的有限体积离散化方法中，网格平均值 $\\bar{u}_{i}(t)$ 的半离散更新涉及每个界面 $x_{i+1/2} = x_{i} + \\tfrac{1}{2}\\Delta x$ 处的数值通量 $F_{i+1/2}$。对于 $a>0$ 的情况，使用迎风格式 $F_{i+1/2} = a\\,u^{-}_{i+1/2}$，其中 $u^{-}_{i+1/2}$ 是在 $x_{i+1/2}$ 处根据 $x_{i}$ 处的网格数据建立的左偏重构状态。在光滑区域比较以下两种重构方法：\n\n- 分段常数 (Godunov) 重构：$u^{-}_{i+1/2} = \\bar{u}_{i}$。\n\n- 分段线性守恒律单调上游中心格式 (MUSCL)，其总变差递减 (TVD) 限制器在光滑区域简化为中心斜率：$u^{-}_{i+1/2} = \\bar{u}_{i} + \\tfrac{1}{2}\\Delta x\\, s_{i}$，在光滑区域中 $s_{i} = \\dfrac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$。\n\n假设 $u(x,t)$ 足够光滑，使得关于 $x_{i}$ 的泰勒展开有效，并且 $\\bar{u}_{i}$ 表示精确的网格平均值 $\\bar{u}_{i} = \\dfrac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,\\mathrm{d}x$。仅使用这些基本定义和关于 $x_{i}$ 的展开式，推导每种重构方法在 $x_{i+1/2}$ 处的数值通量的主阶截断误差，即当 $\\Delta x \\to 0$ 时 $F_{i+1/2} - a\\,u(x_{i+1/2},t)$ 中的主项。根据这些主项，确定每种方法在光滑区域的数值通量的形式阶 $p$，其定义为 $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^{p})$。\n\n将您的最终答案表示为行向量 $\\left(p_{\\mathrm{Godunov}},\\,p_{\\mathrm{MUSCL}}\\right)$。无需四舍五入。最终答案必须按规定使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境以单个行向量的形式提供。",
            "solution": "该问题要求推导线性平流方程 $u_t + a u_x = 0$（其中平流速度 $a$ 为正常数）的两种有限体积重构方案中数值通量 $F_{i+1/2}$ 的形式精度阶 $p$。在解的光滑区域，阶数 $p$ 由截断误差 $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^p)$ 定义。分析将通过将所有量表示为泰勒级数展开来进行。\n\n对于 $a > 0$，数值通量由迎风公式 $F_{i+1/2} = a\\,u^{-}_{i+1/2}$ 给出，其中 $u^{-}_{i+1/2}$ 是在界面 $x_{i+1/2}$ 左侧的解的重构值。因此，通量的截断误差为 $a\\,(u^{-}_{i+1/2} - u(x_{i+1/2},t))$。分析的核心是确定重构的主阶误差 $u^{-}_{i+1/2} - u(x_{i+1/2},t)$。\n\n为进行此分析，我们将所有量在界面位置 $x_{i+1/2}$ 处进行泰勒级数展开。令 $z = x_{i+1/2}$，并令 $v(x) = u(x,t)$ 表示在时间 $t$ 的精确解。目标是分析 $u^{-}_{i+1/2} - v(z)$。重构基于精确的网格平均值 $\\bar{u}_{j} = \\frac{1}{\\Delta x}\\int_{x_{j-1/2}}^{x_{j+1/2}} v(x)\\,\\mathrm{d}x$。\n\n首先，我们通过将 $v(x)$ 在 $z = x_{i+1/2}$ 处展开，来建立网格平均值 $\\bar{u}_j$ 的一般表达式。对于任意网格 $j$，其平均值由下式给出：\n$$ \\bar{u}_{j} = \\frac{1}{\\Delta x} \\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( v(z) + v'(z)(x-z) + \\frac{v''(z)}{2}(x-z)^2 + \\mathcal{O}((x-z)^3) \\right) \\mathrm{d}x $$\n让我们对与 $x_{i+1/2}$ 处的重构相关的网格（即网格 $i$、$i+1$ 和 $i-1$）计算这个表达式。\n\n对于网格 $i$，积分区间为 $[x_{i-1/2}, x_{i+1/2}] = [z-\\Delta x, z]$。\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-\\Delta x}^{z} $$\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left( 0 - \\left( v(z)(-\\Delta x) + \\frac{v'(z)}{2}(-\\Delta x)^2 + \\frac{v''(z)}{6}(-\\Delta x)^3 + \\dots \\right) \\right)  $$\n$$ \\bar{u}_{i} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n对于网格 $i+1$，积分区间为 $[x_{i+1/2}, x_{i+3/2}] = [z, z+\\Delta x]$。\n$$ \\bar{u}_{i+1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z}^{z+\\Delta x} $$\n$$ \\bar{u}_{i+1} = v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n对于网格 $i-1$，积分区间为 $[x_{i-3/2}, x_{i-1/2}] = [z-2\\Delta x, z-\\Delta x]$。\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-2\\Delta x}^{z-\\Delta x} $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)((-\\Delta x) - (-2\\Delta x)) + \\frac{v'(z)}{2}((-\\Delta x)^2 - (-2\\Delta x)^2) + \\frac{v''(z)}{6}((-\\Delta x)^3 - (-2\\Delta x)^3) + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)\\Delta x - \\frac{3}{2}v'(z)\\Delta x^2 + \\frac{7}{6}v''(z)\\Delta x^3 + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\n有了这些表达式，我们现在可以分析每种重构方法。\n\n**1. 分段常数 (Godunov) 重构**\n\nGodunov 重构直接使用网格平均值：\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} $$\n重构误差为 $u^{-}_{i+1/2} - v(z) = \\bar{u}_i - v(z)$。使用我们对 $\\bar{u}_i$ 的展开式：\n$$ \\bar{u}_{i} - v(z) = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) \\right) - v(z) $$\n$$ \\bar{u}_{i} - v(z) = -\\frac{1}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n主阶误差项的阶数为 $\\Delta x$。通量的截断误差为：\n$$ F_{i+1/2} - a\\,v(z) = a(\\bar{u}_{i} - v(z)) = -\\frac{a}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n这是一个 $\\mathcal{O}(\\Delta x)$ 的误差，因此 Godunov 通量的形式阶为 $p_{\\mathrm{Godunov}} = 1$。\n\n**2. 分段线性 (MUSCL) 重构**\n\nMUSCL 重构由下式给出：\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} + \\frac{1}{2}\\Delta x\\, s_{i} $$\n其中光滑区域的斜率 $s_i$ 为 $s_{i} = \\frac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$。首先，我们使用网格平均值的表达式来找到斜率项的展开式：\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left( v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) - \\left( v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left(\\frac{1}{2} + \\frac{3}{2}\\right) v'(z)\\Delta x + \\left(\\frac{1}{6} - \\frac{7}{6}\\right) v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = 2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n现在，我们计算斜率 $s_i$：\n$$ s_{i} = \\frac{2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)}{2\\Delta x} = v'(z) - \\frac{1}{2}v''(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\n接下来，我们将 $\\bar{u}_i$ 和 $s_i$ 的展开式代入重构公式中：\n$$ u^{-}_{i+1/2} = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) + \\frac{1}{2}\\Delta x \\left( v'(z) - \\frac{1}{2}v''(z)\\Delta x \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\frac{1}{2}v'(z)\\Delta x - \\frac{1}{4}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n包含 $v'(z)\\Delta x$ 的项相互抵消：\n$$ u^{-}_{i+1/2} = v(z) + \\left(\\frac{1}{6} - \\frac{1}{4}\\right)v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n重构误差为 $u^{-}_{i+1/2} - v(z) = -\\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)$。主阶项的阶数为 $\\Delta x^2$。通量的截断误差为：\n$$ F_{i+1/2} - a\\,v(z) = a(u^{-}_{i+1/2} - v(z)) = -\\frac{a}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n这是一个 $\\mathcal{O}(\\Delta x^2)$ 的误差，因此 MUSCL 通量的形式阶为 $p_{\\mathrm{MUSCL}} = 2$。\n\nGodunov 和 MUSCL 方法的数值通量阶数分别为 1 和 2。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "我们在上一个练习中 () 看到，高阶方法在光滑流场中表现优越。然而，在处理像激波这样的尖锐特征时，未经限制的高阶重构可能会导致灾难性的非物理振荡。这个编码实践旨在通过一个生动的例子来揭示这一问题。你将实现并对比一个无限制的中心差分斜率和一个经过`minmod`函数限制的TVD斜率，亲眼见证“坏”格式如何产生伪振荡，而“好”格式如何有效抑制它们，从而深刻理解斜率限制器在确保高分辨率格式鲁棒性方面的关键作用。",
            "id": "3514787",
            "problem": "考虑标量守恒律的线性平流方程，$u_t + a\\,u_x = 0$，其中平流速度 $a > 0$ 为常数。在空间域 $[0,1]$ 上，使用一个包含 $N$ 个单元的均匀、周期性的一维网格，并采用守恒型有限体积法。单元平均值用 $u_i^n$ 表示，代表在时间层 $n$ 时单元 $i$ 上的平均值。令 $\\Delta x = 1/N$，并采用单个显式欧拉时间步，步长为 $\\Delta t = \\nu\\,\\Delta x/a$，其中 Courant 数 $\\nu \\in (0,1)$ 将在下文指定。使用单调 Godunov (迎风) 数值通量 $F_{i+1/2} = a\\,u_{i+1/2}^-$，其中左界面状态 $u_{i+1/2}^-$ 是通过单元 $i$ 内的分段线性重构计算得到的。更新格式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right).\n$$\n重构使用斜率 $s_i$ 进行，因此\n$$\nu_{i+1/2}^- = u_i + \\frac{1}{2}\\,s_i.\n$$\n您将比较两种斜率定义：\n- 一种不保持极值原理的“过冲偏置”中心斜率（称为 $\\beta$-中心斜率）：\n$$\ns_i^{(\\beta)} = \\beta\\,\\frac{u_{i+1} - u_{i-1}}{2},\n$$\n其中放大系数 $\\beta > 0$ 为固定值。这种选择可能违反局部极值原理，因为重构的界面状态可能会超出相邻单元平均值所构成的范围。\n- 一种总变差递减 (TVD) 的 minmod 限制器斜率，定义为\n$$\n\\operatorname{minmod}(a,b) = \n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  & \\text{if } ab>0,\\\\\n0,  & \\text{otherwise},\n\\end{cases}\n$$\n和\n$$\ns_i^{(\\operatorname{mm})} = \\operatorname{minmod}\\left(u_i - u_{i-1},\\,u_{i+1} - u_i\\right).\n$$\n单调迎风通量保证了通量层面的单调性；然而，违反局部极值原理的重构仍可能在间断附近产生新的下冲。\n\n从有限体积守恒更新和上述定义出发，为两种重构方法实现单步更新，并评估一个时间步后产生的任何新下冲的幅度。按如下方式定义下冲幅度。令 $L = \\inf_x u_0(x)$ 为初始数据的下界，令 $u_{\\min}^{n+1}$ 为更新后所有单元中的最小值；则下冲幅度为\n$$\n\\max\\{\\,0,\\,L - u_{\\min}^{n+1}\\,\\}.\n$$\n该值为非负数，如果没有发生下冲，则其值为零。\n\n使用以下测试套件。对于每个测试，取 $a = 1$，$N = 200$，Courant 数 $\\nu = 0.45$，并进行恰好一个前向欧拉时间步，步长为 $\\Delta t = \\nu\\,\\Delta x/a$。区域是周期性的，但最终时间仅为一个时间步，因此在这些情况下波不会到达边界。所有初始数据均为分段常数，且值在 $[0,1]$ 区间内，因此在每个测试中下界均为 $L = 0$：\n1. 向上跳跃：当 $x  x_0$ 时 $u_0(x) = 0$，当 $x \\ge x_0$ 时 $u_0(x) = 1$，其中 $x_0 = 0.30$（不适用于弧度或角度；$x$ 是 $[0,1]$ 上的无量纲坐标）。\n2. 向下跳跃：当 $x  x_0$ 时 $u_0(x) = 1$，当 $x \\ge x_0$ 时 $u_0(x) = 0$，其中 $x_0 = 0.70$。\n3. 方波：当 $|x - 0.50| \\le 0.20$ 时 $u_0(x) = 1$，否则 $u_0(x) = 0$。\n4. 在网格界面上对齐的跳跃：当 $x  x_0$ 时 $u_0(x) = 0$，当 $x \\ge x_0$ 时 $u_0(x) = 1$，其中 $x_0$ 被选择为与某个整数 $j$ 的网格界面位置 $x_{j+1/2} = (j+1/2)\\Delta x$ 精确重合。\n\n在 $\\beta$-中心斜率中设置放大系数 $\\beta = 2.0$。对于四个测试中的每一个，计算两种重构方法的下冲幅度：首先计算 $\\beta$-中心斜率的，然后计算 minmod 斜率的，按此顺序。您的程序应生成单行输出，其中包含八个结果，格式为方括号括起来的逗号分隔列表，排序如下\n$$\n[\\text{bad}_1,\\text{good}_1,\\text{bad}_2,\\text{good}_2,\\text{bad}_3,\\text{good}_3,\\text{bad}_4,\\text{good}_4],\n$$\n其中 `bad_k` 是测试 $k$ 中 $\\beta$-中心斜率的下冲幅度，而 `good_k` 是测试 $k$ 中 minmod 斜率的下冲幅度。将每个数字表示为小数，四舍五入到小数点后六位。不涉及物理单位；所有量都是无量纲的。输出必须严格遵守此指定格式的单行文本，不得包含任何其他文字。程序必须是完全自包含的，不需要用户输入或外部数据文件。",
            "solution": "用户提供了一个来自计算物理领域的有效且良定的问题陈述。任务是在求解线性平流方程的有限体积法中，比较两种不同的分段线性重构格式，并量化每种格式产生的下冲。\n\n控制偏微分方程是标量线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$a > 0$ 是恒定的平流速度。我们在一个一维周期性区域 $x \\in [0,1]$ 上，使用守恒型有限体积法求解该方程。\n\n首先，我们将空间域离散化为 $N$ 个均匀单元，每个单元宽度为 $\\Delta x = 1/N$。设单元 $i$ 为区间 $[x_{i-1/2}, x_{i+1/2}]$，其中对于 $i=0, \\ldots, N-1$，界面位置为 $x_{i+1/2} = (i+1)\\Delta x$。单元中心为 $x_i = (i+0.5)\\Delta x$。在时间 $t^n$ 时，单元 $i$ 上 $u$ 的单元平均值记为 $u_i^n$。\n$$\nu_i^n \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) \\, dx\n$$\n单元平均值 $u_i$ 变化率的半离散有限体积公式为：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。我们采用显式前向欧拉格式进行时间积分，时间步长为 $\\Delta t = \\nu \\Delta x / a$，其中 $\\nu$ 是 Courant-Friedrichs-Lewy (CFL) 数。全离散更新公式为：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n对于 $a > 0$ 的线性平流方程，信息从左向右传播。Godunov (迎风) 通量由界面左侧的状态决定，记为 $u_{i+1/2}^-$。通量为 $F_{i+1/2} = a u_{i+1/2}^-$。状态 $u_{i+1/2}^-$ 是通过在单元 $i$ 内进行分段线性重构得到的。\n$$\nu(x) = u_i^n + s_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}]\n$$\n其中 $s_i$ 是单元 $i$ 内的斜率。在右界面 $x_{i+1/2} = x_i + \\Delta x/2$ 处对此进行求值，我们得到重构状态：\n$$\nu_{i+1/2}^- = u_i^n + \\frac{1}{2} s_i\n$$\n单元 $i$ 左界面的通量 $F_{i-1/2}$ 由单元 $i-1$ 中的重构决定，因此 $F_{i-1/2} = a u_{i-1/2}^- = a (u_{i-1}^n + \\frac{1}{2}s_{i-1})$。将这些通量表达式代入更新公式，并使用 $\\nu = a \\Delta t / \\Delta x$，我们得到：\n$$\nu_i^{n+1} = u_i^n - \\nu \\left[ \\left(u_i^n + \\frac{1}{2}s_i\\right) - \\left(u_{i-1}^n + \\frac{1}{2}s_{i-1}\\right) \\right]\n$$\n该公式将用于实现单个时间步的计算。\n\n比较了两种斜率定义：\n1.  $\\beta=2.0$ 的 $\\beta$-中心斜率：这是一种无限制的中心差分斜率。\n    $$\n    s_i^{(\\beta)} = \\beta \\frac{u_{i+1}^n - u_{i-1}^n}{2} = u_{i+1}^n - u_{i-1}^n\n    $$\n    这种重构在空间上是形式二阶精度的，但已知其不保持单调性，会导致间断附近的伪振荡（下冲和过冲）。\n\n2.  minmod 限制器斜率：这是一种总变差递减 (TVD) 斜率限制器。\n    $$\n    s_i^{(\\operatorname{mm})} = \\operatorname{minmod}(u_i^n - u_{i-1}^n, u_{i+1}^n - u_i^n)\n    $$\n    其中 $\\operatorname{minmod}$ 函数定义为：\n    $$\n    \\operatorname{minmod}(a,b) = \n    \\begin{cases}\n    \\operatorname{sign}(a)\\,\\min(|a|,|b|),   \\text{if } ab0,\\\\\n    0,   \\text{otherwise}.\n    \\end{cases}\n    $$\n    如果前向和后向差分斜率符号相同，该限制器选择其中较小的一个；否则选择零斜率。这可以防止引入新的局部极值，确保格式是 TVD 且无振荡，但代价是在极值点和间断处精度降为一阶。\n\n对于每个测试用例，我们首先在 $t=0$ 初始化单元平均值 $u_i^n$。对于分段常数初始条件 $u_0(x)$，单元平均值为 $u_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u_0(x) \\, dx$。\n- 对于测试 1、2 和 3，$u_0(x)$ 的间断点位于 $x=0.30=60\\Delta x$ 和/或 $x=0.70=140\\Delta x$，这些都是单元界面。因此，初始单元平均值 $u_i^n$ 全部为 $0$ 或 $1$。\n- 对于测试 4，间断点位于 $x_0 = (j+1/2)\\Delta x$，其中 $j$ 为整数。我们选择 $j=60$，将跳跃点置于单元 60 的中心。这导致 $u_{60}^n=0.5$，而所有其他单元的初始值为 $0$ 或 $1$。\n\n在用两种斜率方法计算出所有 $i=0, \\ldots, N-1$ 的 $u_i^{n+1}$ 后，我们量化下冲。所有测试的初始数据下界均为 $L=0$。下冲幅度定义为：\n$$\n\\max\\{0, L - u_{\\min}^{n+1}\\} = \\max\\{0, -\\min_i u_i^{n+1}\\}\n$$\n只有当更新后的解中包含一个小于初始最小值 $0$ 的单元平均值时，该量才为正。\n\n数值实现过程如下：\n- 设置参数：$N=200$，$a=1$，$\\nu=0.45$，$\\beta=2.0$。\n- 对于四个测试用例中的每一个：\n    - 根据测试用例的 $u_0(x)$ 初始化数组 $u_i^n$。\n    - 对于 $\\beta$-中心斜率：\n        - 使用周期性边界条件（例如，$u_{-1}=u_{N-1}$）计算所有单元的斜率 $s_i^{(\\beta)}$。\n        - 应用更新公式求得 $u_i^{n+1}$。\n        - 计算并存储下冲幅度。\n    - 对于 minmod 斜率：\n        - 使用周期性边界条件计算所有单元的斜率 $s_i^{(\\operatorname{mm})}$。\n        - 应用更新公式求得 $u_i^{n+1}$。\n        - 计算并存储下冲幅度。\n- 将八个结果收集并格式化为逗号分隔的列表。根据 TVD 格式的理论预测，minmod 限制器应该不会产生下冲，因此在所有情况下下冲幅度都为 $0$。无限制的中心斜率预计会产生显著的下冲。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating undershoot magnitudes for two reconstruction\n    schemes in a finite volume method for linear advection.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 200\n    a = 1.0\n    nu = 0.45  # Courant number\n    beta = 2.0  # Amplification for the central slope\n\n    # --- Discretization ---\n    dx = 1.0 / N\n\n    def minmod(a, b):\n        \"\"\"\n        Vectorized minmod function.\n        \"\"\"\n        ab = a * b\n        s = np.sign(a)\n        abs_res = np.minimum(np.abs(a), np.abs(b))\n        return np.where(ab > 0, s * abs_res, 0.0)\n\n    def compute_undershoot(u_init, slope_type, N, nu, beta_val=None):\n        \"\"\"\n        Performs a single time step and computes the undershoot magnitude.\n        \"\"\"\n        u = u_init.copy()\n\n        # Get neighboring cell values using periodic boundaries\n        u_p1 = np.roll(u, -1)  # u_{i+1}\n        u_m1 = np.roll(u, 1)   # u_{i-1}\n\n        # --- 1. Slope Calculation ---\n        if slope_type == 'beta':\n            # s_i = beta * (u_{i+1} - u_{i-1}) / 2\n            s = beta_val * (u_p1 - u_m1) / 2.0\n        elif slope_type == 'minmod':\n            # s_i = minmod(u_i - u_{i-1}, u_{i+1} - u_i)\n            # Forward and backward differences\n            d_forward = u_p1 - u\n            d_backward = u - u_m1\n            s = minmod(d_backward, d_forward)\n        else:\n            raise ValueError(\"Invalid slope type specified.\")\n\n        # --- 2. Flux Calculation ---\n        # Reconstruct state at the right interface of each cell\n        # u_{i+1/2}^- = u_i + s_i / 2\n        u_interface = u + s / 2.0\n\n        # Godunov flux for a > 0 (upwind)\n        # F_{i+1/2} = a * u_{i+1/2}^-\n        F_iphalf = a * u_interface\n\n        # Flux at the left interface of cell i is the right flux of cell i-1\n        F_imhalf = np.roll(F_iphalf, 1)\n\n        # --- 3. Update Cell Averages ---\n        # u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        # Note: nu = a * dt / dx\n        u_new = u - (nu / a) * (F_iphalf - F_imhalf)\n\n        # --- 4. Calculate Undershoot ---\n        # L = 0 for all test cases\n        L = 0.0\n        u_min_new = np.min(u_new)\n        undershoot = np.maximum(L, L - u_min_new)\n\n        return undershoot\n\n    # --- Test Cases ---\n    \n    # Test Case 1: Upward jump at interface x=0.3\n    # Discontinuity is at 0.3 / dx = 60. Interface between cells 59 and 60.\n    j_jump1 = int(0.3 / dx)\n    u1 = np.zeros(N)\n    u1[j_jump1:] = 1.0\n\n    # Test Case 2: Downward jump at interface x=0.7\n    # Discontinuity is at 0.7 / dx = 140. Interface between cells 139 and 140.\n    j_jump2 = int(0.7 / dx)\n    u2 = np.ones(N)\n    u2[j_jump2:] = 0.0\n\n    # Test Case 3: Block from x=0.3 to x=0.7\n    j_left = int(0.3 / dx)\n    j_right = int(0.7 / dx)\n    u3 = np.zeros(N)\n    u3[j_left:j_right] = 1.0\n\n    # Test Case 4: Upward jump aligned at a cell center.\n    # We choose j=60, so the jump is at x_0 = (60.5)*dx = 0.3025.\n    j_center = 60\n    u4 = np.zeros(N)\n    u4[j_center + 1:] = 1.0\n    u4[j_center] = 0.5  # Averaged value in the cell containing the jump\n\n    test_initial_conditions = [u1, u2, u3, u4]\n    results = []\n\n    for u_init in test_initial_conditions:\n        # Calculate undershoot for the beta-central slope (\"bad\" scheme)\n        undershoot_beta = compute_undershoot(u_init, 'beta', N, nu, beta_val=beta)\n        results.append(f\"{undershoot_beta:.6f}\")\n        \n        # Calculate undershoot for the minmod slope (\"good\" scheme)\n        undershoot_minmod = compute_undershoot(u_init, 'minmod', N, nu)\n        results.append(f\"{undershoot_minmod:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "TVD斜率限制器，如我们在前一个练习 () 中所见，虽然能有效抑制振荡，但其精度通常被限制在二阶，并且可能在极值点过度削平（clipping）物理峰值。WENO（加权本质无振荡）格式提供了一条在保持无振荡特性的同时，实现更高阶精度的途径。本练习将聚焦于实现流行的五阶WENO格式的核心——重构步骤。通过这个实践，你将学习WENO格式如何通过非线性地组合来自不同模板的信息，来构建一个既高度精确又在间断附近保持鲁棒的重构值。",
            "id": "3514861",
            "problem": "考虑一维线性平流守恒律\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\n其平流速度 $a$ 为常数，作用在间距为 $\\Delta x$ 的均匀网格上，并采用有限体积表示法，其单元平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx$。在计算天体物理学的高分辨率激波捕捉方法中，单元界面上的数值通量是通过高阶无振荡重构来构建的。加权本质无振荡 (WENO) 格式旨在光滑区域保持高阶精度，同时避免在间断附近产生伪振荡。带有斜率限制器的总变差递减 (TVD) 格式也能实现类似目标，但仅限于较低阶精度；WENO 格式通过基于光滑度指标的非线性权推广了这一概念。\n\n从守恒型有限体积公式和适用于平流问题的迎风偏置要求出发，使用 Lax-Friedrichs 通量分裂将物理通量 $f(u)=a u$ 写为 $f(u)=f^+(u)+f^-(u)$，其中\n$$\nf^\\pm(u) = \\frac{1}{2}\\left(f(u)\\pm \\alpha u\\right),\\quad \\alpha = |a|.\n$$\n对于 $a\\ge 0$ 和均匀网格的情况，左偏置状态 $u_{i+1/2}^-$ 是从单元平均值 $\\{\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}\\}$ 中重构的，该过程使用基于三个重叠子模板和源自 Jiang–Shu 光滑度指标的非线性权的五阶 WENO 程序。用于数值正则化的小参数必须设置为 $\\varepsilon = 10^{-6}$，权指数设置为 $p=2$。假设使用适用于均匀网格的规范线性权。对于每个提供的数据集，最终目标量是重构的左界面状态 $u_{i+1/2}^-$，表示为一个浮点数。\n\n您的任务是实现一个完整的、可运行的程序，对于每个测试用例，该程序接收五个给定的单元平均值 $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2})$ 并计算出单一的重构值 $u_{i+1/2}^-$。平流速度应取为 $a=1$（无量纲），您应在概念上使用 Lax-Friedrichs 通量分裂来证明迎风偏置左重构的合理性，但要求的输出是重构的左状态 $u_{i+1/2}^-$ 本身。不涉及物理单位；所有量都是无量纲实数。不出现角度。不出现百分比。\n\n以一种普遍适用于任何现代编程语言的方式实现该算法。网格、$a$、$\\varepsilon$ 和 $p$ 的具体参数如上所述固定。使用以下离散数据集的测试套件：\n\n- 案例 1：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.1,\\,0.2,\\,0.3,\\,0.4,\\,0.5)$。\n- 案例 2：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (\\sin(-2),\\,\\sin(-1),\\,\\sin(0),\\,\\sin(1),\\,\\sin(2))$，使用标准正弦函数（弧度制），数值上为 $( -0.9092974268256817,\\,-0.8414709848078965,\\,0.0,\\,0.8414709848078965,\\,0.9092974268256817)$。\n- 案例 3：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.0)$。\n- 案例 4：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.7,\\,0.7,\\,0.7,\\,0.7,\\,0.7)$。\n- 案例 5：$(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,0.0,\\,-1.0,\\,0.0,\\,1.0)$。\n\n您的程序应生成一行输出，其中包含五个案例的重构值，以逗号分隔的列表形式包含在方括号中，顺序如上所示，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$\n所有输出都必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题要求在单元界面处计算状态变量 $u$ 的一个左偏置、五阶加权本质无振荡 (WENO) 重构，记为 $u_{i+1/2}^-$。所提供的背景是在均匀网格上的一维线性平流方程 $\\partial_t u + a\\,\\partial_x u = 0$，这是计算天体物理学中遇到的双曲守恒律的原型。对于正平流速度 $a > 0$，一个迎风偏置的有限体积格式需要重构界面 $x_{i+1/2}$ 左侧的状态来计算数值通量。问题指定 $a=1$，这证实了计算 $u_{i+1/2}^-$ 的必要性。\n\n重构将使用一个包含单元平均数据的五点模板 $\\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$ 来执行。五阶 WENO 程序，特别是 Jiang and Shu 提出的 WENO-JS 格式，通过形成几个较低阶重构的非线性组合，在光滑区域实现高精度，并防止在间断处出现伪振荡。\n\n步骤如下：\n\n1.  **子模板重构**：五点模板被分为三个重叠的三点子模板，$S_k$，$k \\in \\{0,1,2\\}$：\n    -   $S_0 = \\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}\\}$\n    -   $S_1 = \\{\\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}\\}$\n    -   $S_2 = \\{\\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$\n\n    在每个子模板 $S_k$ 上，构建一个二次多项式 $p_k(x)$，其在界面 $x_{i+1/2}$ 处的值提供了一个三阶精度的候选重构，$u_{i+1/2, k}^- = p_k(x_{i+1/2})$。在均匀网格上，这些重构的标准公式是：\n    $$\n    \\begin{aligned}\n    u_{i+1/2, 0}^- = \\frac{1}{3}\\bar{u}_{i-2} - \\frac{7}{6}\\bar{u}_{i-1} + \\frac{11}{6}\\bar{u}_{i} \\\\\n    u_{i+1/2, 1}^- = -\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_{i} + \\frac{1}{3}\\bar{u}_{i+1} \\\\\n    u_{i+1/2, 2}^- = \\frac{1}{3}\\bar{u}_{i} + \\frac{5}{6}\\bar{u}_{i+1} - \\frac{1}{6}\\bar{u}_{i+2}\n    \\end{aligned}\n    $$\n\n2.  **光滑度指标**：为衡量每个子模板中间斷的存在，需要计算光滑度指标 $IS_k$。这些指标基于重构多项式 $p_k(x)$ 的缩放导数的平方和。对于 WENO5 格式，标准的 Jiang-Shu 指标是：\n    $$\n    \\begin{aligned}\n    IS_0 = \\frac{13}{12}(\\bar{u}_{i-2} - 2\\bar{u}_{i-1} + \\bar{u}_i)^2 + \\frac{1}{4}(\\bar{u}_{i-2} - 4\\bar{u}_{i-1} + 3\\bar{u}_i)^2 \\\\\n    IS_1 = \\frac{13}{12}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})^2 + \\frac{1}{4}(\\bar{u}_{i-1} - \\bar{u}_{i+1})^2 \\\\\n    IS_2 = \\frac{13}{12}(\\bar{u}_i - 2\\bar{u}_{i+1} + \\bar{u}_{i+2})^2 + \\frac{1}{4}(3\\bar{u}_i - 4\\bar{u}_{i+1} + \\bar{u}_{i+2})^2\n    \\end{aligned}\n    $$\n\n3.  **非线性权**：最终的重构是候选重构 $u_{i+1/2, k}^-$ 的一个凸组合。权 $\\omega_k$ 的计算方式使得来自更光滑模板（即 $IS_k$ 值较小的模板）的重构具有更大的影响。首先，使用规范线性权 $d_k$、光滑度指标 $IS_k$、小正则化参数 $\\varepsilon$ 和指数 $p$ 来计算未归一化的权 $\\alpha_k$：\n    $$\n    \\alpha_k = \\frac{d_k}{(IS_k + \\varepsilon)^p}\n    $$\n    问题指定了 $\\varepsilon = 10^{-6}$ 和 $p=2$。为实现 $u_{i+1/2}^-$ 重构的五阶精度，规范线性权为 $d_0=0.1$，$d_1=0.6$ 和 $d_2=0.3$。这些权的总和为 $1$。\n\n    最终的非线性权 $\\omega_k$ 通过对 $\\alpha_k$ 进行归一化得到：\n    $$\n    \\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n    $$\n\n4.  **最终重构**：界面上的 WENO5 重构值是候选重构的加权平均值：\n    $$\n    u_{i+1/2}^- = \\sum_{k=0}^{2} \\omega_k u_{i+1/2, k}^-\n    $$\n\n该算法是确定性的，对于给定的五个输入单元平均值，它提供 $u_{i+1/2}^-$ 的唯一数值。实现过程将系统地将这些公式应用于每个提供的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the fifth-order WENO reconstruction for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Linear data\n        (0.1, 0.2, 0.3, 0.4, 0.5),\n        # Case 2: Sine function\n        (math.sin(-2.0), math.sin(-1.0), math.sin(0.0), math.sin(1.0), math.sin(2.0)),\n        # Case 3: Step function (discontinuity)\n        (1.0, 1.0, 1.0, 0.0, 0.0),\n        # Case 4: Constant data\n        (0.7, 0.7, 0.7, 0.7, 0.7),\n        # Case 5: Oscillatory data\n        (1.0, 0.0, -1.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = weno5_reconstruct(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\ndef weno5_reconstruct(u_stencil):\n    \"\"\"\n    Calculates the 5th order WENO reconstruction u_{i+1/2}^-\n    from a 5-point stencil of cell averages.\n\n    Args:\n        u_stencil: A tuple or list of 5 floating-point numbers representing\n                   (u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}).\n\n    Returns:\n        The reconstructed value at the interface u_{i+1/2}^-.\n    \"\"\"\n    u_im2, u_im1, u_i, u_ip1, u_ip2 = u_stencil\n    \n    # WENO parameters as specified in the problem\n    epsilon = 1e-6\n    p = 2\n    \n    # Canonical linear weights for u_{i+1/2}^-\n    d = np.array([0.1, 0.6, 0.3])\n\n    # Sub-stencil reconstructions (3rd order)\n    u_rec = np.array([\n        (1/3)*u_im2 - (7/6)*u_im1 + (11/6)*u_i,\n        (-1/6)*u_im1 + (5/6)*u_i + (1/3)*u_ip1,\n        (1/3)*u_i + (5/6)*u_ip1 - (1/6)*u_ip2\n    ])\n\n    # Jiang-Shu smoothness indicators\n    IS = np.array([\n        (13/12)*(u_im2 - 2*u_im1 + u_i)**2 + (1/4)*(u_im2 - 4*u_im1 + 3*u_i)**2,\n        (13/12)*(u_im1 - 2*u_i + u_ip1)**2 + (1/4)*(u_im1 - u_ip1)**2,\n        (13/12)*(u_i - 2*u_ip1 + u_ip2)**2 + (1/4)*(3*u_i - 4*u_ip1 + u_ip2)**2\n    ])\n    \n    # Un-normalized nonlinear weights\n    alpha = d / (IS + epsilon)**p\n    \n    # Normalized nonlinear weights\n    omega = alpha / np.sum(alpha)\n    \n    # Final reconstructed value\n    u_reconstructed = np.dot(omega, u_rec)\n    \n    return u_reconstructed\n\nsolve()\n```"
        }
    ]
}