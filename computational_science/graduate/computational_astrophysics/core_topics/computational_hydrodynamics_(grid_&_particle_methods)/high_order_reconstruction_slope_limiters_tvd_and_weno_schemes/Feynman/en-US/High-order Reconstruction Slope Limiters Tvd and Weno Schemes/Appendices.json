{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex implementations, it is essential to build a firm theoretical understanding of why higher-order methods are desirable. This practice guides you through a foundational pen-and-paper exercise using Taylor series analysis. By deriving the truncation error, you will quantify the jump in accuracy from a first-order Godunov-type scheme to a second-order MUSCL reconstruction in smooth regions of a flow, providing a clear mathematical justification for the pursuit of higher-order accuracy in astrophysical simulations .",
            "id": "3514794",
            "problem": "Consider the linear advection equation $u_{t} + a u_{x} = 0$ with constant speed $a0$ on a uniform grid with cell centers $x_{i}$ and spacing $\\Delta x$. In a finite-volume discretization used in astrophysical hydrodynamics, the semi-discrete update for the cell average $\\bar{u}_{i}(t)$ involves a numerical flux $F_{i+1/2}$ at each interface $x_{i+1/2} = x_{i} + \\tfrac{1}{2}\\Delta x$. For $a0$, use the upwind form $F_{i+1/2} = a\\,u^{-}_{i+1/2}$, where $u^{-}_{i+1/2}$ is the left-biased reconstructed state at $x_{i+1/2}$ built from cell data at $x_{i}$. Compare the following two reconstructions in smooth regions:\n\n- Piecewise-constant (Godunov): $u^{-}_{i+1/2} = \\bar{u}_{i}$.\n\n- Piecewise-linear Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) with a Total Variation Diminishing (TVD) limiter that reduces to a centered slope in smooth regions: $u^{-}_{i+1/2} = \\bar{u}_{i} + \\tfrac{1}{2}\\Delta x\\, s_{i}$ with $s_{i} = \\dfrac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$ in smooth regions.\n\nAssume $u(x,t)$ is sufficiently smooth so that Taylor expansions about $x_{i}$ are valid and that $\\bar{u}_{i}$ denotes the exact cell average $\\bar{u}_{i} = \\dfrac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,\\mathrm{d}x$. Using only these fundamental definitions and expansions about $x_{i}$, derive the leading-order truncation error of the numerical flux at $x_{i+1/2}$, i.e., the leading term in $F_{i+1/2} - a\\,u(x_{i+1/2},t)$ as $\\Delta x \\to 0$, for each reconstruction. From these leading terms, determine the formal order $p$ of the numerical flux in smooth regions for each method, defined by $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^{p})$.\n\nState your final answer as the row vector $\\left(p_{\\mathrm{Godunov}},\\,p_{\\mathrm{MUSCL}}\\right)$. No rounding is required. The final answer must be provided as a single row vector using the LaTeX $\\mathrm{pmatrix}$ environment as specified.",
            "solution": "The problem requires the derivation of the formal order of accuracy, $p$, for the numerical flux $F_{i+1/2}$ in two finite-volume reconstruction schemes for the linear advection equation $u_t + a u_x = 0$, where the advection speed $a$ is a positive constant. The order $p$ is defined by the truncation error $F_{i+1/2} - a\\,u(x_{i+1/2},t) = \\mathcal{O}(\\Delta x^p)$ in smooth regions of the solution. The analysis will be performed by expressing all quantities as Taylor series expansions.\n\nThe numerical flux for $a  0$ is given by the upwind formula $F_{i+1/2} = a\\,u^{-}_{i+1/2}$, where $u^{-}_{i+1/2}$ is the reconstructed value of the solution at the left side of the interface $x_{i+1/2}$. The truncation error of the flux is therefore $a\\,(u^{-}_{i+1/2} - u(x_{i+1/2},t))$. The core of the analysis is to determine the leading-order error of the reconstruction, $u^{-}_{i+1/2} - u(x_{i+1/2},t)$.\n\nFor this analysis, we will expand all quantities in a Taylor series about the interface location $x_{i+1/2}$. Let $z = x_{i+1/2}$ and let $v(x) = u(x,t)$ denote the exact solution at time $t$. The goal is to analyze $u^{-}_{i+1/2} - v(z)$. The reconstructions are based on the exact cell averages, $\\bar{u}_{j} = \\frac{1}{\\Delta x}\\int_{x_{j-1/2}}^{x_{j+1/2}} v(x)\\,\\mathrm{d}x$.\n\nFirst, we establish a general expression for a cell average $\\bar{u}_j$ by expanding $v(x)$ about $z = x_{i+1/2}$. For an arbitrary cell $j$, its average is given by:\n$$ \\bar{u}_{j} = \\frac{1}{\\Delta x} \\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( v(z) + v'(z)(x-z) + \\frac{v''(z)}{2}(x-z)^2 + \\mathcal{O}((x-z)^3) \\right) \\mathrm{d}x $$\nLet's evaluate this for the cells relevant to the reconstructions at $x_{i+1/2}$, namely cells $i$, $i+1$, and $i-1$.\n\nFor cell $i$, the integration interval is $[x_{i-1/2}, x_{i+1/2}] = [z-\\Delta x, z]$.\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-\\Delta x}^{z} $$\n$$ \\bar{u}_{i} = \\frac{1}{\\Delta x} \\left( 0 - \\left( v(z)(-\\Delta x) + \\frac{v'(z)}{2}(-\\Delta x)^2 + \\frac{v''(z)}{6}(-\\Delta x)^3 + \\dots \\right) \\right)  $$\n$$ \\bar{u}_{i} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nFor cell $i+1$, the interval is $[x_{i+1/2}, x_{i+3/2}] = [z, z+\\Delta x]$.\n$$ \\bar{u}_{i+1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z}^{z+\\Delta x} $$\n$$ \\bar{u}_{i+1} = v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nFor cell $i-1$, the interval is $[x_{i-3/2}, x_{i-1/2}] = [z-2\\Delta x, z-\\Delta x]$.\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left[ v(z)(x-z) + \\frac{v'(z)}{2}(x-z)^2 + \\frac{v''(z)}{6}(x-z)^3 + \\dots \\right]_{z-2\\Delta x}^{z-\\Delta x} $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)((-\\Delta x) - (-2\\Delta x)) + \\frac{v'(z)}{2}((-\\Delta x)^2 - (-2\\Delta x)^2) + \\frac{v''(z)}{6}((-\\Delta x)^3 - (-2\\Delta x)^3) + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = \\frac{1}{\\Delta x} \\left( v(z)\\Delta x - \\frac{3}{2}v'(z)\\Delta x^2 + \\frac{7}{6}v''(z)\\Delta x^3 + \\dots \\right) $$\n$$ \\bar{u}_{i-1} = v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n\nWith these expressions, we can now analyze each reconstruction.\n\n**1. Piecewise-constant (Godunov) Reconstruction**\n\nThe Godunov reconstruction uses the cell-average value directly:\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} $$\nThe reconstruction error is $u^{-}_{i+1/2} - v(z) = \\bar{u}_i - v(z)$. Using our expansion for $\\bar{u}_i$:\n$$ \\bar{u}_{i} - v(z) = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) \\right) - v(z) $$\n$$ \\bar{u}_{i} - v(z) = -\\frac{1}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nThe leading-order error term is of order $\\Delta x$. The truncation error of the flux is:\n$$ F_{i+1/2} - a\\,v(z) = a(\\bar{u}_{i} - v(z)) = -\\frac{a}{2}v'(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nThis is an $\\mathcal{O}(\\Delta x)$ error, so the formal order of the Godunov flux is $p_{\\mathrm{Godunov}} = 1$.\n\n**2. Piecewise-linear (MUSCL) Reconstruction**\n\nThe MUSCL reconstruction is given by:\n$$ u^{-}_{i+1/2} = \\bar{u}_{i} + \\frac{1}{2}\\Delta x\\, s_{i} $$\nwhere the slope $s_i$ in smooth regions is $s_{i} = \\frac{\\bar{u}_{i+1}-\\bar{u}_{i-1}}{2\\Delta x}$. First, we find the expansion for the slope term using our expressions for the cell averages:\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left( v(z) + \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) - \\left( v(z) - \\frac{3}{2}v'(z)\\Delta x + \\frac{7}{6}v''(z)\\Delta x^2 \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = \\left(\\frac{1}{2} + \\frac{3}{2}\\right) v'(z)\\Delta x + \\left(\\frac{1}{6} - \\frac{7}{6}\\right) v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ \\bar{u}_{i+1} - \\bar{u}_{i-1} = 2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nNow, we compute the slope $s_i$:\n$$ s_{i} = \\frac{2v'(z)\\Delta x - v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)}{2\\Delta x} = v'(z) - \\frac{1}{2}v''(z)\\Delta x + \\mathcal{O}(\\Delta x^2) $$\nNext, we substitute the expansions for $\\bar{u}_i$ and $s_i$ into the reconstruction formula:\n$$ u^{-}_{i+1/2} = \\left( v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 \\right) + \\frac{1}{2}\\Delta x \\left( v'(z) - \\frac{1}{2}v''(z)\\Delta x \\right) + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{2}v'(z)\\Delta x + \\frac{1}{6}v''(z)\\Delta x^2 + \\frac{1}{2}v'(z)\\Delta x - \\frac{1}{4}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThe terms involving $v'(z)\\Delta x$ cancel:\n$$ u^{-}_{i+1/2} = v(z) + \\left(\\frac{1}{6} - \\frac{1}{4}\\right)v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\n$$ u^{-}_{i+1/2} = v(z) - \\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThe reconstruction error is $u^{-}_{i+1/2} - v(z) = -\\frac{1}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3)$. The leading-order term is of order $\\Delta x^2$. The truncation error of the flux is:\n$$ F_{i+1/2} - a\\,v(z) = a(u^{-}_{i+1/2} - v(z)) = -\\frac{a}{12}v''(z)\\Delta x^2 + \\mathcal{O}(\\Delta x^3) $$\nThis is an $\\mathcal{O}(\\Delta x^2)$ error, so the formal order of the MUSCL flux is $p_{\\mathrm{MUSCL}} = 2$.\n\nThe orders of the numerical flux for the Godunov and MUSCL methods are $1$ and $2$, respectively.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The benefits of high-order accuracy in smooth flows come with a significant challenge: the generation of unphysical oscillations near discontinuities like shocks. This hands-on coding exercise provides a vivid demonstration of this critical trade-off. You will implement a simple finite-volume update and compare a naive, unlimited high-order reconstruction against a robust Total Variation Diminishing (TVD) scheme, directly observing how slope limiters are crucial for ensuring the physical realism of simulations in the presence of sharp features .",
            "id": "3514787",
            "problem": "Consider the scalar conservation law for linear advection, given by $u_t + a\\,u_x = 0$ with constant advection speed $a  0$. Use a conservative finite volume method on a uniform, periodic, one-dimensional mesh with $N$ cells over the spatial domain $[0,1]$. Cell averages are denoted by $u_i^n$, representing the average over cell $i$ at time level $n$. Let $\\Delta x = 1/N$, and take a single explicit Euler time step with $\\Delta t = \\nu\\,\\Delta x/a$, where the Courant number $\\nu \\in (0,1)$ is specified below. Use the monotone Godunov (upwind) numerical flux $F_{i+1/2} = a\\,u_{i+1/2}^-$, where the left interface state $u_{i+1/2}^-$ is computed by a piecewise linear reconstruction from cell $i$. The update reads\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right).\n$$\nReconstruction is performed using a slope $s_i$ so that\n$$\nu_{i+1/2}^- = u_i + \\frac{1}{2}\\,s_i.\n$$\nYou will compare two slope definitions:\n- A non-maximum-principle-preserving \"overshoot-biased\" central slope (called the $\\beta$-central slope): \n$$\ns_i^{(\\beta)} = \\beta\\,\\frac{u_{i+1} - u_{i-1}}{2},\n$$\nwith a fixed amplification $\\beta  0$. This choice can violate the local maximum principle because reconstructed interface states may exceed the range spanned by neighboring cell averages.\n- A Total Variation Diminishing (TVD) minmod-limited slope, defined by\n$$\n\\operatorname{minmod}(a,b) = \n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab0,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand\n$$\ns_i^{(\\operatorname{mm})} = \\operatorname{minmod}\\left(u_i - u_{i-1},\\,u_{i+1} - u_i\\right).\n$$\nThe monotone upwind flux guarantees monotonicity at the flux level; however, a reconstruction that violates the local maximum principle can still generate new undershoots near discontinuities.\n\nStarting from the finite volume conservation update and the definitions above, implement the single-step update for both reconstructions and evaluate the magnitude of any new undershoot produced after one time step. Define the undershoot magnitude as follows. Let $L = \\inf_x u_0(x)$ be the lower bound of the initial data, and let $u_{\\min}^{n+1}$ be the minimum over all cells after the update; the undershoot magnitude is\n$$\n\\max\\{\\,0,\\,L - u_{\\min}^{n+1}\\,\\}.\n$$\nThis quantity is nonnegative and equals zero if no undershoot occurred.\n\nUse the following test suite. For each test, take $a = 1$, $N = 200$, Courant number $\\nu = 0.45$, and exactly one forward Euler time step with $\\Delta t = \\nu\\,\\Delta x/a$. The domain is periodic, but the final time is one time step, so no wave reaches the boundary in these cases. All initial data are piecewise constant and lie in $[0,1]$, so the lower bound is $L = 0$ in every test:\n1. Upward jump: $u_0(x) = 0$ for $x  x_0$ and $u_0(x) = 1$ for $x \\ge x_0$, with $x_0 = 0.30$.\n2. Downward jump: $u_0(x) = 1$ for $x  x_0$ and $u_0(x) = 0$ for $x \\ge x_0$, with $x_0 = 0.70$.\n3. Block: $u_0(x) = 1$ for $|x - 0.50| \\le 0.20$ and $u_0(x) = 0$ otherwise.\n4. Aligned jump at a mesh interface: $u_0(x) = 0$ for $x  x_0$ and $u_0(x) = 1$ for $x \\ge x_0$, where $x_0$ is chosen to coincide exactly with a mesh interface location $x_{j+1/2} = (j+1/2)\\Delta x$ for some integer $j$.\n\nSet the amplification $\\beta = 2.0$ in the $\\beta$-central slope. For each of the four tests, compute the undershoot magnitudes for both reconstructions: first for the $\\beta$-central slope and then for the minmod slope, in that order. Your program should produce a single line of output containing the eight results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\text{bad}_1,\\text{good}_1,\\text{bad}_2,\\text{good}_2,\\text{bad}_3,\\text{good}_3,\\text{bad}_4,\\text{good}_4],\n$$\nwhere $\\text{bad}_k$ is the undershoot magnitude for the $\\beta$-central slope on test $k$, and $\\text{good}_k$ is the undershoot magnitude for the minmod slope on test $k$. Express each number as a decimal rounded to six digits after the decimal point. No physical units are involved; all quantities are unitless. The output must be exactly one line in this specified format, with no other text. The program must be fully self-contained and require no user input or external data files.",
            "solution": "The user has provided a valid, well-posed problem statement from the field of computational physics. The task is to compare two different piecewise linear reconstruction schemes within a finite volume method for the linear advection equation, and to quantify the undershoots produced by each scheme.\n\nThe governing partial differential equation is the scalar linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the conserved quantity and $a  0$ is the constant advection speed. We solve this equation on a one-dimensional periodic domain $x \\in [0,1]$ using a conservative finite volume method.\n\nFirst, we discretize the spatial domain into $N$ uniform cells, each of width $\\Delta x = 1/N$. Let cell $i$ be the interval $[x_{i-1/2}, x_{i+1/2}]$, where the interface locations are $x_{i+1/2} = (i+1)\\Delta x$ for $i=0, \\ldots, N-1$. The cell centers are $x_i = (i+0.5)\\Delta x$. The cell average of $u$ over cell $i$ at time $t^n$ is denoted by $u_i^n$.\n$$\nu_i^n \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t^n) \\, dx\n$$\nThe semi-discrete finite volume formula for the rate of change of the cell average $u_i$ is:\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. We employ an explicit forward Euler scheme for time integration with a time step $\\Delta t = \\nu \\Delta x / a$, where $\\nu$ is the Courant-Friedrichs-Lewy (CFL) number. The fully discrete update formula is:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nFor the linear advection equation with $a  0$, the information propagates from left to right. The Godunov (upwind) flux is determined by the state to the left of the interface, denoted $u_{i+1/2}^-$. The flux is $F_{i+1/2} = a u_{i+1/2}^-$. The state $u_{i+1/2}^-$ is obtained by a piecewise linear reconstruction within cell $i$.\n$$\nu(x) = u_i^n + s_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}]\n$$\nwhere $s_i$ is the slope in cell $i$. Evaluating this at the right interface $x_{i+1/2} = x_i + \\Delta x/2$, we get the reconstructed state:\n$$\nu_{i+1/2}^- = u_i^n + \\frac{1}{2} s_i\n$$\nThe flux at the left interface of cell $i$, $F_{i-1/2}$, is determined by the reconstruction in cell $i-1$, so $F_{i-1/2} = a u_{i-1/2}^- = a (u_{i-1}^n + \\frac{1}{2}s_{i-1})$. Substituting these flux expressions into the update formula and using $\\nu = a \\Delta t / \\Delta x$, we obtain:\n$$\nu_i^{n+1} = u_i^n - \\nu \\left[ \\left(u_i^n + \\frac{1}{2}s_i\\right) - \\left(u_{i-1}^n + \\frac{1}{2}s_{i-1}\\right) \\right]\n$$\nThis formula will be implemented for a single time step.\n\nTwo slope definitions are compared:\n1.  The $\\beta$-central slope with $\\beta=2.0$: This is an unlimited central-difference slope.\n    $$\n    s_i^{(\\beta)} = \\beta \\frac{u_{i+1}^n - u_{i-1}^n}{2} = u_{i+1}^n - u_{i-1}^n\n    $$\n    This reconstruction is formally second-order accurate in space but is known to not preserve monotonicity, leading to spurious oscillations (undershoots and overshoots) near discontinuities.\n\n2.  The minmod-limited slope: This is a Total Variation Diminishing (TVD) slope limiter.\n    $$\n    s_i^{(\\operatorname{mm})} = \\operatorname{minmod}(u_i^n - u_{i-1}^n, u_{i+1}^n - u_i^n)\n    $$\n    where the $\\operatorname{minmod}$ function is defined as:\n    $$\n    \\operatorname{minmod}(a,b) = \n    \\begin{cases}\n    \\operatorname{sign}(a)\\,\\min(|a|,|b|),  \\text{if } ab0,\\\\\n    0,  \\text{otherwise}.\n    \\end{cases}\n    $$\n    This limiter selects the smaller of the forward and backward difference slopes if they have the same sign, and selects a zero slope otherwise. This prevents the introduction of new local extrema, ensuring the scheme is TVD and free from oscillations, at the cost of reducing to first-order accuracy at extrema and discontinuities.\n\nFor each test case, we first initialize the cell averages $u_i^n$ at $t=0$. For a piecewise constant initial condition $u_0(x)$, the cell average is $u_i^n = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} u_0(x) \\, dx$.\n- For Tests 1, 2, and 3, the discontinuities in $u_0(x)$ are located at $x=0.30=60\\Delta x$ and/or $x=0.70=140\\Delta x$, which are cell interfaces. Thus, the initial cell averages $u_i^n$ are all either $0$ or $1$.\n- For Test 4, the discontinuity is at $x_0 = (j+1/2)\\Delta x$ for an integer $j$. We choose $j=60$, placing the jump at the center of cell $60$. This results in $u_{60}^n=0.5$, while all other cells are initialized to $0$ or $1$.\n\nAfter computing $u_i^{n+1}$ for all $i=0, \\ldots, N-1$ for both slope methods, we quantify the undershoot. The initial data for all tests are bounded below by $L=0$. The undershoot magnitude is defined as:\n$$\n\\max\\{0, L - u_{\\min}^{n+1}\\} = \\max\\{0, -\\min_i u_i^{n+1}\\}\n$$\nThis quantity will be positive only if the updated solution contains a cell average that is less than the initial minimum of $0$.\n\nThe numerical implementation proceeds as follows:\n- Set parameters: $N=200$, $a=1$, $\\nu=0.45$, $\\beta=2.0$.\n- For each of the four test cases:\n    - Initialize the array $u_i^n$ according to the test case's $u_0(x)$.\n    - For the $\\beta$-central slope:\n        - Calculate slopes $s_i^{(\\beta)}$ for all cells, using periodic boundary conditions (e.g., $u_{-1}=u_{N-1}$).\n        - Apply the update formula to find $u_i^{n+1}$.\n        - Compute and store the undershoot magnitude.\n    - For the minmod slope:\n        - Calculate slopes $s_i^{(\\operatorname{mm})}$ for all cells, using periodic boundaries.\n        - Apply the update formula to find $u_i^{n+1}$.\n        - Compute and store the undershoot magnitude.\n- The eight results are collected and formatted as a comma-separated list. As predicted by the theory of TVD schemes, the minmod limiter should produce no undershoots, resulting in an undershoot magnitude of $0$ in all cases. The unlimited central slope is expected to produce significant undershoots.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating undershoot magnitudes for two reconstruction\n    schemes in a finite volume method for linear advection.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 200\n    a = 1.0\n    nu = 0.45  # Courant number\n    beta = 2.0  # Amplification for the central slope\n\n    # --- Discretization ---\n    dx = 1.0 / N\n\n    def minmod(a, b):\n        \"\"\"\n        Vectorized minmod function.\n        \"\"\"\n        ab = a * b\n        s = np.sign(a)\n        abs_res = np.minimum(np.abs(a), np.abs(b))\n        return np.where(ab > 0, s * abs_res, 0.0)\n\n    def compute_undershoot(u_init, slope_type, N, nu, beta_val=None):\n        \"\"\"\n        Performs a single time step and computes the undershoot magnitude.\n        \"\"\"\n        u = u_init.copy()\n\n        # Get neighboring cell values using periodic boundaries\n        u_p1 = np.roll(u, -1)  # u_{i+1}\n        u_m1 = np.roll(u, 1)   # u_{i-1}\n\n        # --- 1. Slope Calculation ---\n        if slope_type == 'beta':\n            # s_i = beta * (u_{i+1} - u_{i-1}) / 2\n            s = beta_val * (u_p1 - u_m1) / 2.0\n        elif slope_type == 'minmod':\n            # s_i = minmod(u_i - u_{i-1}, u_{i+1} - u_i)\n            # Forward and backward differences\n            d_forward = u_p1 - u\n            d_backward = u - u_m1\n            s = minmod(d_backward, d_forward)\n        else:\n            raise ValueError(\"Invalid slope type specified.\")\n\n        # --- 2. Flux Calculation ---\n        # Reconstruct state at the right interface of each cell\n        # u_{i+1/2}^- = u_i + s_i / 2\n        u_interface = u + s / 2.0\n\n        # Godunov flux for a > 0 (upwind)\n        # F_{i+1/2} = a * u_{i+1/2}^-\n        F_iphalf = a * u_interface\n\n        # Flux at the left interface of cell i is the right flux of cell i-1\n        F_imhalf = np.roll(F_iphalf, 1)\n\n        # --- 3. Update Cell Averages ---\n        # u_i^{n+1} = u_i^n - (dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        # Note: nu = a * dt / dx\n        u_new = u - (nu / a) * (F_iphalf - F_imhalf)\n\n        # --- 4. Calculate Undershoot ---\n        # L = 0 for all test cases\n        L = 0.0\n        u_min_new = np.min(u_new)\n        undershoot = np.maximum(L, L - u_min_new)\n\n        return undershoot\n\n    # --- Test Cases ---\n    \n    # Test Case 1: Upward jump at interface x=0.3\n    # Discontinuity is at 0.3 / dx = 60. Interface between cells 59 and 60.\n    j_jump1 = int(0.3 / dx)\n    u1 = np.zeros(N)\n    u1[j_jump1:] = 1.0\n\n    # Test Case 2: Downward jump at interface x=0.7\n    # Discontinuity is at 0.7 / dx = 140. Interface between cells 139 and 140.\n    j_jump2 = int(0.7 / dx)\n    u2 = np.ones(N)\n    u2[j_jump2:] = 0.0\n\n    # Test Case 3: Block from x=0.3 to x=0.7\n    j_left = int(0.3 / dx)\n    j_right = int(0.7 / dx)\n    u3 = np.zeros(N)\n    u3[j_left:j_right] = 1.0\n\n    # Test Case 4: Upward jump aligned at a cell center.\n    # We choose j=60, so the jump is at x_0 = (60.5)*dx = 0.3025.\n    j_center = 60\n    u4 = np.zeros(N)\n    u4[j_center + 1:] = 1.0\n    u4[j_center] = 0.5  # Averaged value in the cell containing the jump\n\n    test_initial_conditions = [u1, u2, u3, u4]\n    results = []\n\n    for u_init in test_initial_conditions:\n        # Calculate undershoot for the beta-central slope (\"bad\" scheme)\n        undershoot_beta = compute_undershoot(u_init, 'beta', N, nu, beta_val=beta)\n        results.append(f\"{undershoot_beta:.6f}\")\n        \n        # Calculate undershoot for the minmod slope (\"good\" scheme)\n        undershoot_minmod = compute_undershoot(u_init, 'minmod', N, nu)\n        results.append(f\"{undershoot_minmod:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond the framework of second-order TVD schemes, Weighted Essentially Non-Oscillatory (WENO) methods offer a systematic path to even higher orders of accuracy. This practice introduces the core logic of the popular fifth-order WENO scheme. You will implement the algorithm that nonlinearly combines information from several stencils to construct a highly accurate and non-oscillatory state at a cell interface, gaining practical experience with a sophisticated technique at the heart of many modern shock-capturing codes .",
            "id": "3514861",
            "problem": "Consider the one-dimensional linear advection conservation law\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\nwith constant advection speed $a$ on a uniform grid of spacing $\\Delta x$, and a finite volume representation with cell averages $\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t)\\,dx$. In high-resolution shock-capturing methods for computational astrophysics, numerical fluxes at cell interfaces are constructed using high-order non-oscillatory reconstructions. Weighted Essentially Non-Oscillatory (WENO) schemes aim to retain high-order accuracy in smooth regions while avoiding spurious oscillations near discontinuities. Total Variation Diminishing (TVD) schemes with slope limiters achieve similar goals but are limited to lower orders; WENO schemes generalize the concept through nonlinear weights based on smoothness indicators.\n\nStarting from the conservative finite volume formulation and the requirement of upwind bias suitable for advection, use Lax-Friedrichs flux splitting to write the physical flux $f(u)=a u$ as $f(u)=f^+(u)+f^-(u)$ where\n$$\nf^\\pm(u) = \\frac{1}{2}\\left(f(u)\\pm \\alpha u\\right),\\quad \\alpha = |a|.\n$$\nFor the case $a\\ge 0$ and a uniform grid, the left-biased state $u_{i+1/2}^-$ is reconstructed from cell averages $\\{\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}\\}$ using a fifth-order WENO procedure based on three overlapping substencils and nonlinear weights derived from Jiangâ€“Shu smoothness indicators. The small parameter for numerical regularization must be set to $\\varepsilon = 10^{-6}$, and the weight exponent to $p=2$. Assume canonical linear weights appropriate for a uniform grid. The final target quantity for each provided dataset is the reconstructed left interface state $u_{i+1/2}^-$, expressed as a floating-point number.\n\nYour task is to implement a complete, runnable program that, for each test case, takes the five given cell averages $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2})$ and computes the single reconstructed value $u_{i+1/2}^-$. The advection speed should be taken as $a=1$ (dimensionless), and you should use the Lax-Friedrichs flux split conceptually to justify the upwind-biased left reconstruction, but the requested output is the reconstructed left state $u_{i+1/2}^-$ itself. No physical units are involved; all quantities are dimensionless real numbers. Angles do not appear. Percentages do not appear.\n\nImplement the algorithm in a way that is universally applicable to any modern programming language. The specifics of grids, $a$, $\\varepsilon$, and $p$ are fixed as above. Use the following test suite of discrete datasets:\n\n- Case $1$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.1,\\,0.2,\\,0.3,\\,0.4,\\,0.5)$.\n- Case $2$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (\\sin(-2),\\,\\sin(-1),\\,\\sin(0),\\,\\sin(1),\\,\\sin(2))$, with the standard sine function in radians, numerically $( -0.9092974268256817,\\,-0.8414709848078965,\\,0.0,\\,0.8414709848078965,\\,0.9092974268256817)$.\n- Case $3$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,1.0,\\,1.0,\\,0.0,\\,0.0)$.\n- Case $4$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (0.7,\\,0.7,\\,0.7,\\,0.7,\\,0.7)$.\n- Case $5$: $(\\bar{u}_{i-2},\\bar{u}_{i-1},\\bar{u}_{i},\\bar{u}_{i+1},\\bar{u}_{i+2}) = (1.0,\\,0.0,\\,-1.0,\\,0.0,\\,1.0)$.\n\nYour program should produce a single line of output containing the reconstructed values for the five cases as a comma-separated list enclosed in square brackets, in the order given above, for example\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5].\n$$\nAll outputs must be floating-point numbers. No other text should be printed.",
            "solution": "The problem requires the computation of a left-biased, fifth-order Weighted Essentially Non-Oscillatory (WENO) reconstruction of a state variable $u$ at a cell interface, denoted as $u_{i+1/2}^-$. The provided context is the one-dimensional linear advection equation, $\\partial_t u + a\\,\\partial_x u = 0$, on a uniform grid, which is a prototype for hyperbolic conservation laws encountered in computational astrophysics. For a positive advection speed, $a  0$, an upwind-biased finite volume scheme requires the reconstruction of the state at the left side of the interface $x_{i+1/2}$ to compute the numerical flux. The problem specifies $a=1$, which confirms the necessity of computing $u_{i+1/2}^-$.\n\nThe reconstruction will be performed using a five-point stencil of cell-averaged data, $\\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$. The fifth-order WENO procedure, specifically the WENO-JS scheme by Jiang and Shu, achieves high accuracy in smooth regions and prevents spurious oscillations at discontinuities by forming a nonlinear combination of several lower-order reconstructions.\n\nThe procedure is as follows:\n\n1.  **Substencil Reconstructions**: The five-point stencil is divided into three overlapping three-point substencils, $S_k$ for $k \\in \\{0,1,2\\}$:\n    -   $S_0 = \\{\\bar{u}_{i-2}, \\bar{u}_{i-1}, \\bar{u}_{i}\\}$\n    -   $S_1 = \\{\\bar{u}_{i-1}, \\bar{u}_{i}, \\bar{u}_{i+1}\\}$\n    -   $S_2 = \\{\\bar{u}_{i}, \\bar{u}_{i+1}, \\bar{u}_{i+2}\\}$\n\n    On each substencil $S_k$, a quadratic polynomial $p_k(x)$ is constructed, and its value at the interface $x_{i+1/2}$ provides a third-order accurate candidate reconstruction, $u_{i+1/2, k}^- = p_k(x_{i+1/2})$. The standard formulas for these reconstructions on a uniform grid are:\n    $$\n    \\begin{aligned}\n    u_{i+1/2, 0}^- = \\frac{1}{3}\\bar{u}_{i-2} - \\frac{7}{6}\\bar{u}_{i-1} + \\frac{11}{6}\\bar{u}_{i} \\\\\n    u_{i+1/2, 1}^- = -\\frac{1}{6}\\bar{u}_{i-1} + \\frac{5}{6}\\bar{u}_{i} + \\frac{1}{3}\\bar{u}_{i+1} \\\\\n    u_{i+1/2, 2}^- = \\frac{1}{3}\\bar{u}_{i} + \\frac{5}{6}\\bar{u}_{i+1} - \\frac{1}{6}\\bar{u}_{i+2}\n    \\end{aligned}\n    $$\n\n2.  **Smoothness Indicators**: To measure the presence of discontinuities in each substencil, smoothness indicators $IS_k$ are computed. These are based on the squared sums of scaled derivatives of the reconstruction polynomials $p_k(x)$. For the WENO5 scheme, the standard Jiang-Shu indicators are:\n    $$\n    \\begin{aligned}\n    IS_0 = \\frac{13}{12}(\\bar{u}_{i-2} - 2\\bar{u}_{i-1} + \\bar{u}_i)^2 + \\frac{1}{4}(\\bar{u}_{i-2} - 4\\bar{u}_{i-1} + 3\\bar{u}_i)^2 \\\\\n    IS_1 = \\frac{13}{12}(\\bar{u}_{i-1} - 2\\bar{u}_i + \\bar{u}_{i+1})^2 + \\frac{1}{4}(\\bar{u}_{i-1} - \\bar{u}_{i+1})^2 \\\\\n    IS_2 = \\frac{13}{12}(\\bar{u}_i - 2\\bar{u}_{i+1} + \\bar{u}_{i+2})^2 + \\frac{1}{4}(3\\bar{u}_i - 4\\bar{u}_{i+1} + \\bar{u}_{i+2})^2\n    \\end{aligned}\n    $$\n\n3.  **Nonlinear Weights**: The final reconstruction is a convex combination of the candidate reconstructions $u_{i+1/2, k}^-$. The weights $\\omega_k$ are computed in a way that gives more influence to reconstructions from smoother stencils (those with smaller $IS_k$). First, un-normalized weights $\\alpha_k$ are calculated using the canonical linear weights $d_k$, the smoothness indicators $IS_k$, a small regularization parameter $\\varepsilon$, and a power $p$:\n    $$\n    \\alpha_k = \\frac{d_k}{(IS_k + \\varepsilon)^p}\n    $$\n    The problem specifies $\\varepsilon = 10^{-6}$ and $p=2$. The canonical linear weights for achieveing fifth-order accuracy for the $u_{i+1/2}^-$ reconstruction are $d_0=0.1$, $d_1=0.6$, and $d_2=0.3$. These weights sum to $1$.\n\n    The final nonlinear weights $\\omega_k$ are obtained by normalizing the $\\alpha_k$:\n    $$\n    \\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n    $$\n\n4.  **Final Reconstruction**: The WENO5 reconstructed value at the interface is the weighted average of the candidate reconstructions:\n    $$\n    u_{i+1/2}^- = \\sum_{k=0}^{2} \\omega_k u_{i+1/2, k}^-\n    $$\n\nThis algorithm is determinate and provides a single numerical value for $u_{i+1/2}^-$ given the five input cell averages. The implementation will systematically apply these formulas to each of the provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the fifth-order WENO reconstruction for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Linear data\n        (0.1, 0.2, 0.3, 0.4, 0.5),\n        # Case 2: Sine function\n        (math.sin(-2.0), math.sin(-1.0), math.sin(0.0), math.sin(1.0), math.sin(2.0)),\n        # Case 3: Step function (discontinuity)\n        (1.0, 1.0, 1.0, 0.0, 0.0),\n        # Case 4: Constant data\n        (0.7, 0.7, 0.7, 0.7, 0.7),\n        # Case 5: Oscillatory data\n        (1.0, 0.0, -1.0, 0.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = weno5_reconstruct(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\ndef weno5_reconstruct(u_stencil):\n    \"\"\"\n    Calculates the 5th order WENO reconstruction u_{i+1/2}^-\n    from a 5-point stencil of cell averages.\n\n    Args:\n        u_stencil: A tuple or list of 5 floating-point numbers representing\n                   (u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}).\n\n    Returns:\n        The reconstructed value at the interface u_{i+1/2}^-.\n    \"\"\"\n    u_im2, u_im1, u_i, u_ip1, u_ip2 = u_stencil\n    \n    # WENO parameters as specified in the problem\n    epsilon = 1e-6\n    p = 2\n    \n    # Canonical linear weights for u_{i+1/2}^-\n    d = np.array([0.1, 0.6, 0.3])\n\n    # Sub-stencil reconstructions (3rd order)\n    u_rec = np.array([\n        (1/3)*u_im2 - (7/6)*u_im1 + (11/6)*u_i,\n        (-1/6)*u_im1 + (5/6)*u_i + (1/3)*u_ip1,\n        (1/3)*u_i + (5/6)*u_ip1 - (1/6)*u_ip2\n    ])\n\n    # Jiang-Shu smoothness indicators\n    IS = np.array([\n        (13/12)*(u_im2 - 2*u_im1 + u_i)**2 + (1/4)*(u_im2 - 4*u_im1 + 3*u_i)**2,\n        (13/12)*(u_im1 - 2*u_i + u_ip1)**2 + (1/4)*(u_im1 - u_ip1)**2,\n        (13/12)*(u_i - 2*u_ip1 + u_ip2)**2 + (1/4)*(3*u_i - 4*u_ip1 + u_ip2)**2\n    ])\n    \n    # Un-normalized nonlinear weights\n    alpha = d / (IS + epsilon)**p\n    \n    # Normalized nonlinear weights\n    omega = alpha / np.sum(alpha)\n    \n    # Final reconstructed value\n    u_reconstructed = np.dot(omega, u_rec)\n    \n    return u_reconstructed\n\nsolve()\n```"
        }
    ]
}