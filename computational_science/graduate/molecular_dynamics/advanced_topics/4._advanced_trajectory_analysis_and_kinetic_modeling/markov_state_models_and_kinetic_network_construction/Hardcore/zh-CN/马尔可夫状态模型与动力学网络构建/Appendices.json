{
    "hands_on_practices": [
        {
            "introduction": "在深入研究动力学之前，我们必须首先确保我们构建的马尔可夫状态网络结构合理。转移矩阵的谱（即其特征值）是诊断网络连通性和稳定性的强大工具，能够揭示采样不足或状态定义不佳等潜在问题。这项练习将教会您如何通过分析特征值来评估模型的健康状况，例如识别孤立的状态集或亚稳态陷阱。",
            "id": "3423377",
            "problem": "给定一个由行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 表示的有限状态离散时间马尔可夫链，其元素满足 $P_{ij} \\ge 0$ 且对于每个状态 $i \\in \\{1,\\dots,n\\}$ 都有 $\\sum_{j=1}^n P_{ij} = 1$。考虑由其特征值 $\\{\\lambda_i\\}_{i=1}^n$ 定义的 $P$ 的谱。已知对于任何行随机矩阵 $P$，其谱半径满足对所有 $i$ 都有 $|\\lambda_i| \\le 1$，并且至少有一个特征值等于 $1$。检测不连通分量（即可约性）和诊断近吸收陷阱（即亚稳态集）可以通过谱诊断来解决。您必须编写一个程序，实现一种谱诊断方法，以：\n- 基于特征值在 $1$ 附近的近简并性确定不连通分量的数量，\n- 基于小谱隙标记近吸收陷阱的存在，\n- 推荐一个以整数编码的修复策略。\n\n您的程序必须精确实现以下内容：\n- 设 $\\varepsilon_{\\mathrm{exact}} = 10^{-10}$，$\\varepsilon_{\\mathrm{trap}} = 10^{-2}$，以及 $\\theta_{\\mathrm{self}} = 0.99$。\n- 计算 $P$ 的所有特征值 $\\{\\lambda_i\\}_{i=1}^n$。\n- 将不连通分量的数量定义为 $c = \\#\\{i : |\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}\\}$。直观上，如果 $c > 1$，则在给定的容差下，该链可约化为 $c$ 个闭合连通类。\n- 按如下方式定义谱隙：\n  - 如果 $c > 1$，设置谱隙 $\\delta = 0$。\n  - 如果 $c = 1$，令 $S = \\{i : |\\lambda_i - 1| > \\varepsilon_{\\mathrm{exact}}\\}$ 并定义 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$；如果 $S$ 为空，则定义 $\\delta = 1$。\n- 定义一个陷阱标志 $t \\in \\{0,1\\}$，当 $c = 1$ 且 $\\delta \\le \\varepsilon_{\\mathrm{trap}}$ 时 $t = 1$，否则 $t = 0$。\n- 定义一个修复代码 $r \\in \\{0,1,2\\}$：\n  - 如果 $c > 1$，设置 $r = 2$（建议进行数据增强以观察缺失的转移并减少可约性）。\n  - 否则，如果 $t = 1$ 且 $\\max_i P_{ii} \\ge \\theta_{\\mathrm{self}}$，设置 $r = 1$（建议进行状态细化以减轻高度粘性的自转移）。\n  - 否则，如果 $t = 1$，设置 $r = 2$（建议进行数据增强以更好地采样亚稳态集之间的稀有转移）。\n  - 否则设置 $r = 0$（无操作）。\n- 您的程序在报告谱隙 $\\delta$ 之前必须将其四舍五入到六位小数。\n\n测试套件：\n您的程序必须分析以下五个转移矩阵（硬编码在您的程序中，不读取任何输入）：\n\n- 案例 1（$5 \\times 5$）：两个不连通分量，\n  - 块 $A$（$3 \\times 3$）：$A = \\begin{bmatrix} 0.8 & 0.2 & 0.0 \\\\ 0.1 & 0.8 & 0.1 \\\\ 0.0 & 0.3 & 0.7 \\end{bmatrix}$，\n  - 块 $B$（$2 \\times 2$）：$B = \\begin{bmatrix} 0.6 & 0.4 \\\\ 0.2 & 0.8 \\end{bmatrix}$，\n  - $P_1 = \\mathrm{diag}(A,B)$。\n\n- 案例 2（$4 \\times 4$）：一个具有极高自转移的近吸收陷阱，\n  - $P_2 = \\begin{bmatrix}\n  0.9995 & 0.0005 & 0.0 & 0.0 \\\\\n  0.05 & 0.3 & 0.3 & 0.35 \\\\\n  0.05 & 0.2 & 0.5 & 0.25 \\\\\n  0.05 & 0.25 & 0.25 & 0.45\n  \\end{bmatrix}$。\n\n- 案例 3（$4 \\times 4$）：混合良好的链，\n  - 对于所有 $i,j \\in \\{1,2,3,4\\}$，$P_3$ 的元素 $P_{ij} = 0.25$。\n\n- 案例 4（$6 \\times 6$）：两个弱连通簇（没有极端自环的亚稳态），索引为 $0,1,2$ 和 $3,4,5$，\n  - 对于 $i \\in \\{0,1,2\\}$，\n    - $P_{ii} = 0.7$，$P_{i,j} = 0.1485$ 对于 $\\{0,1,2\\}$ 中的另外两个索引，\n    - $P_{i,j} = 0.001$ 对于 $j \\in \\{3,4,5\\}$。\n  - 对于 $i \\in \\{3,4,5\\}$，\n    - $P_{ii} = 0.7$，$P_{i,j} = 0.1485$ 对于 $\\{3,4,5\\}$ 中的另外两个索引，\n    - $P_{i,j} = 0.001$ 对于 $j \\in \\{0,1,2\\}$。\n\n- 案例 5（$5 \\times 5$）：三个不连通分量，\n  - 块：$[1]$, $C = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.2 & 0.8 \\end{bmatrix}$, $D = \\begin{bmatrix} 0.3 & 0.7 \\\\ 0.6 & 0.4 \\end{bmatrix}$，\n  - $P_5 = \\mathrm{diag}([1],C,D)$。\n\n最终输出格式：\n- 对于每种情况，返回一个列表 $[c, t, r, \\delta]$，其中 $c$ 是一个整数，$t \\in \\{0,1\\}$，$r \\in \\{0,1,2\\}$，而 $\\delta$ 是一个四舍五入到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含五个案例的结果，形式为逗号分隔的列表，并用方括号括起来，例如，$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。\n- 此问题不涉及物理单位。",
            "solution": "用户提供的问题是有效的。它在科学上基于有限状态马尔可夫链的谱理论，这是概率论及其应用（包括计算化学和物理学中的动力学建模）的核心课题。该问题是适定的，所有必要的参数、矩阵和用于诊断算法的逻辑规则都已明确无误地给出。\n\n该问题背后的基本原理是，转移矩阵 $P$ 的特征值编码了相应马尔可夫链的关键动力学特性。对于一个行随机矩阵 $P$（其元素非负且行和为1），Perron-Frobenius 定理保证其谱半径为 $1$。也就是说，对于任何特征值 $\\lambda$，其模 $|\\lambda|$ 小于或等于 $1$。特征值 $\\lambda=1$ 总是存在并且尤为重要。\n\n1.  **不连通分量与特征值 $\\lambda=1$**：等于 $1$ 的特征值的数量对应于状态空间中闭合连通类的数量，也称为常返集或不连通分量。如果链是不可约的（即，可以从任何状态到达任何其他状态），则存在唯一的特征值 $\\lambda=1$。如果存在 $c > 1$ 个这样的特征值，则链可约化为 $c$ 个不相交的状态集。在每个集合内部，状态是连通的，但集合之间没有转移。在数值计算中，我们通过检查近似为 $1$ 的特征值来考虑浮点数的不精确性。问题通过准则 $|\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}$ 定义了这一点，其中 $\\varepsilon_{\\mathrm{exact}} = 10^{-10}$ 是一个很小的容差。满足此条件的特征值数量记为 $c$。\n\n2.  **亚稳态与谱隙**：模小于 $1$ 的特征值控制着系统的弛豫动力学。收敛到平稳分布的时间尺度由*谱隙*决定，谱隙是 $1$ 与非平稳特征值的最大模之间的差值。谱隙非常小的不可约链（$c=1$）被称为*亚稳态*或*近可约*。这表明状态空间被划分为一些状态集，这些状态集内部连接很强，但彼此之间的连接很弱。在这些亚稳态集内部的转移是频繁的，而它们之间的转移是稀有事件，导致整体弛豫非常缓慢。问题如下定义谱隙 $\\delta$：如果 $c=1$，则 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$，其中 $S$ 索引不等于 $1$ 的特征值。一个小的 $\\delta$（具体来说，$\\delta \\le \\varepsilon_{\\mathrm{trap}} = 10^{-2}$）表示存在亚稳态。如果 $c>1$，链是真正可约的，单一的系统范围弛豫速率的概念是无定义的；因此，$\\delta$ 被设置为 $0$。\n\n要实现的算法过程是这些原理的直接应用。对于一个给定的转移矩阵 $P$：\n\n1.  **特征值计算**：使用标准的数值线性代数程序计算 $n \\times n$ 矩阵 $P$ 的全部特征值谱 $\\{\\lambda_i\\}_{i=1}^n$。这些特征值可能是复数。\n\n2.  **确定分量数量 ($c$)**：我们遍历计算出的特征值，并计算满足条件 $|\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}$ 的数量。这个计数给出了 $c$ 的值。\n\n3.  **计算谱隙 ($\\delta$)**：\n    *   如果 $c > 1$，链是可约的，我们设置 $\\delta=0$。\n    *   如果 $c = 1$，链是不可约的。我们识别出非平稳特征值的集合，$S = \\{i : |\\lambda_i - 1| > \\varepsilon_{\\mathrm{exact}}\\}$。然后我们找到这些特征值中的最大模，$\\max_{i \\in S} |\\lambda_i|$，并计算 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$。如果 $S$ 为空（这只发生在平凡的 $1 \\times 1$ 矩阵 $[[1]]$ 的情况下，其所有特征值都为 $1$），$\\delta$ 定义为 $1$。\n\n4.  **设置陷阱标志 ($t$)**：陷阱标志 $t$ 用于指示近吸收陷阱或亚稳态的存在。如果链是不可约的（$c=1$）但谱隙很小（$\\delta \\le \\varepsilon_{\\mathrm{trap}}$）表明动力学缓慢，则将其设置为 $1$。否则，将 $t$ 设置为 $0$。\n\n5.  **分配修复代码 ($r$)**：根据 $c$ 和 $t$ 的值，分配一个修复代码 $r$。\n    *   如果 $c > 1$，模型是不连通的（$r=2$），这表明需要更多的模拟数据来潜在地观察连接各分量的转移。\n    *   如果 $t = 1$（亚稳态）并且存在一个具有极高自转移概率的状态（$\\max_i P_{ii} \\ge \\theta_{\\mathrm{self}} = 0.99$），这指示一个作为动力学陷阱的“粘性”状态（$r=1$）。一个建议的补救措施是细化状态定义，例如通过将该状态拆分为多个微观状态。\n    *   如果 $t = 1$ 但没有单个状态过度粘性，则亚稳态是由于状态簇之间的稀有转移引起的（$r=2$）。同样，建议使用更多数据来更好地采样这些稀有事件。\n    *   如果上述条件均不满足，则认为模型是行为良好的（不可约且混合足够快），不需要任何操作（$r=0$）。\n\n最后，谱隙 $\\delta$ 在报告时被四舍五入到六位小数，并且每个案例的结果被编译成列表 $[c, t, r, \\delta]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes a set of Markov transition matrices based on their spectral properties\n    to diagnose disconnected components and metastable traps.\n    \"\"\"\n\n    # Define the constants from the problem statement.\n    EPS_EXACT = 1e-10\n    EPS_TRAP = 1e-2\n    THETA_SELF = 0.99\n\n    # --- Define the test cases from the problem statement ---\n\n    # Case 1: 5x5, two disconnected components\n    A = np.array([\n        [0.8, 0.2, 0.0],\n        [0.1, 0.8, 0.1],\n        [0.0, 0.3, 0.7]\n    ])\n    B = np.array([\n        [0.6, 0.4],\n        [0.2, 0.8]\n    ])\n    P1 = np.zeros((5, 5))\n    P1[0:3, 0:3] = A\n    P1[3:5, 3:5] = B\n\n    # Case 2: 4x4, one nearly absorbing trap\n    P2 = np.array([\n        [0.9995, 0.0005, 0.0, 0.0],\n        [0.05, 0.3, 0.3, 0.35],\n        [0.05, 0.2, 0.5, 0.25],\n        [0.05, 0.25, 0.25, 0.45]\n    ])\n\n    # Case 3: 4x4, well-mixed chain\n    P3 = np.full((4, 4), 0.25)\n\n    # Case 4: 6x6, two weakly connected clusters\n    P4 = np.zeros((6, 6))\n    # Cluster 1: indices 0, 1, 2\n    for i in range(3):\n        P4[i, i] = 0.7\n        for j in range(3):\n            if i != j:\n                P4[i, j] = 0.1485\n        for j in range(3, 6):\n            P4[i, j] = 0.001\n    # Cluster 2: indices 3, 4, 5\n    for i in range(3, 6):\n        P4[i, i] = 0.7\n        for j in range(3, 6):\n            if i != j:\n                P4[i, j] = 0.1485\n        for j in range(3):\n            P4[i, j] = 0.001\n\n    # Case 5: 5x5, three disconnected components\n    C = np.array([\n        [0.9, 0.1],\n        [0.2, 0.8]\n    ])\n    D = np.array([\n        [0.3, 0.7],\n        [0.6, 0.4]\n    ])\n    P5 = np.zeros((5, 5))\n    P5[0, 0] = 1.0\n    P5[1:3, 1:3] = C\n    P5[3:5, 3:5] = D\n    \n    test_cases = [P1, P2, P3, P4, P5]\n    results = []\n\n    for P in test_cases:\n        # Compute all eigenvalues of P\n        eigenvalues = np.linalg.eigvals(P)\n        \n        # --- Implement the diagnostic logic ---\n\n        # 1. Determine number of disconnected components (c)\n        c = np.sum(np.abs(eigenvalues - 1.0) = EPS_EXACT)\n        \n        c = int(c) # Ensure c is a standard Python int\n\n        # 2. Define spectral gap (delta), trap flag (t), and remediation code (r)\n        if c > 1:\n            delta = 0.0\n            t = 0\n            r = 2\n        else: # c == 1 (or c == 0, though impossible for stochastic matrix)\n            # Find non-stationary eigenvalues\n            is_non_stationary = np.abs(eigenvalues - 1.0) > EPS_EXACT\n            \n            non_stationary_lambdas = eigenvalues[is_non_stationary]\n\n            if non_stationary_lambdas.size == 0:\n                # This handles the case of a 1x1 matrix [[1]]\n                delta = 1.0\n            else:\n                # Calculate spectral gap\n                max_mod_non_stat = np.max(np.abs(non_stationary_lambdas))\n                delta = 1.0 - max_mod_non_stat\n            \n            # 3. Define trap flag (t)\n            t = 1 if delta = EPS_TRAP else 0\n\n            # 4. Define remediation code (r)\n            if t == 1:\n                max_pii = np.max(np.diag(P))\n                if max_pii >= THETA_SELF:\n                    r = 1\n                else:\n                    r = 2\n            else:\n                r = 0\n\n        # Round delta to six decimal places\n        delta_rounded = round(delta, 6)\n        \n        results.append([c, t, r, delta_rounded])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string, join them by commas, and wrap in brackets.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "马尔可夫状态模型（MSM）的核心假设是“无记忆性”，即系统的未来只取决于当前状态，而与过去无关。Chapman-Kolmogorov 方程，$T(n\\tau) = T(\\tau)^n$，为检验此假设提供了严格的数学基础。这项练习将指导您亲手实现这一基本的自洽性检验，通过比较在不同时间尺度下估计的转移概率，这是选择合适的延迟时间 $\\tau$ 并建立可靠模型的关键一步。",
            "id": "3423468",
            "problem": "您的任务是为从分子动力学轨迹计数构建的离散状态、时间均匀的马尔可夫状态模型 (MSMs)，形式化并实现一个定量的Chapman–Kolmogorov一致性检验。该检验比较在延迟时间 $n\\tau$ 处转移矩阵的直接估计值（记作 $T(n\\tau)$）与在延迟时间 $\\tau$ 处估计的转移矩阵的 $n$ 次矩阵幂（记作 $T(\\tau)^n$）。您的目标是从第一性原理推导该检验，并实现一个程序，为一组给定的计数矩阵测试套件计算 $T(n\\tau)$ 和 $T(\\tau)^n$ 之间的加权差异。\n\n基本原理：\n- 时间均匀的马尔可夫链的马尔可夫性质意味着Chapman–Kolmogorov恒等式：对于任意非负时间 $s$ 和 $t$，转移核满足 $T(t+s) = T(t) T(s)$。在延迟为 $\\tau$ 的离散时间中，这意味着对于任何整数 $n \\ge 1$，都有 $T(n\\tau) = T(\\tau)^n$。\n- 给定一个计数矩阵 $C(\\tau)$，其中 $C(\\tau)_{ij}$ 表示在延迟 $\\tau$ 内从状态 $i$ 到状态 $j$ 的观测转移次数，行随机转移矩阵 $T(\\tau)$ 的最大似然估计通过行归一化获得：当 $\\sum_k C(\\tau)_{ik}  0$ 时，$T(\\tau)_{ij} = C(\\tau)_{ij} / \\sum_k C(\\tau)_{ik}$。\n- 稳态分布 $\\pi$ 由左特征向量方程 $\\pi^\\top T(\\tau) = \\pi^\\top$ 定义，并满足归一化条件 $\\sum_i \\pi_i = 1$ 和 $\\pi_i \\ge 0$。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 输入：两个大小相同（$m \\times m$）的方形计数矩阵 $C(\\tau)$ 和 $C(n\\tau)$，以及一个整数 $n \\ge 1$。\n- 通过对 $C(\\tau)$ 进行行归一化来估计 $T(\\tau)$。对于总计数 $\\sum_j C(\\tau)_{ij} = 0$ 的任意行 $i$，将 $T(\\tau)$ 的对应行定义为在 $m$ 个状态上的均匀分布，即对所有 $j$，$T(\\tau)_{ij} = 1/m$。\n- 使用与零行（均匀行）相同的规则，通过对 $C(n\\tau)$ 进行行归一化来估计 $T(n\\tau)$。\n- 计算稳态分布 $\\pi$ 的一个估计值，作为满足 $\\sum_i \\pi_i = 1$ 的方程 $\\pi^\\top T(\\tau) = \\pi^\\top$ 的任意非负解。\n- 构造差异矩阵 $\\Delta = T(n\\tau) - T(\\tau)^n$ 并计算 $\\pi$ 加权的Frobenius范数差异：\n$$\nd = \\left\\| \\Delta \\right\\|_{F,\\pi} = \\sqrt{ \\sum_{i=1}^m \\pi_i \\sum_{j=1}^m \\left( \\Delta_{ij} \\right)^2 }.\n$$\n这种加权方式强调了在频繁占据状态中的误差，并减弱了在稀有状态中误差的影响。\n\n测试套件：\n实现您的程序，按顺序处理以下四个测试用例。对于每个用例，将标量值 $d$ 报告为浮点数。\n\n- 用例1（完全一致，$m=3$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 32  32  0 \\\\ 16  32  16 \\\\ 0  32  32 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 24  32  8 \\\\ 16  32  16 \\\\ 8  32  24 \\end{bmatrix}$。\n\n- 用例2（边缘情况，C(2τ)中有一行为零，$m=3$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 32  32  0 \\\\ 16  32  16 \\\\ 0  32  32 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 24  32  8 \\\\ 16  32  16 \\\\ 0  0  0 \\end{bmatrix}$。\n\n- 用例3（带有采样噪声的近吸收双态系统，$m=2$，$n=3$）：\n  - $C(\\tau) = \\begin{bmatrix} 99  1 \\\\ 2  98 \\end{bmatrix}$。\n  - $C(3\\tau) = \\begin{bmatrix} 97  3 \\\\ 6  94 \\end{bmatrix}$。\n\n- 用例4（更高维度的完全一致情况，$m=4$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 70  30  0  0 \\\\ 10  80  10  0 \\\\ 0  20  70  10 \\\\ 0  0  30  70 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 52  45  3  0 \\\\ 15  69  15  1 \\\\ 2  30  54  14 \\\\ 0  6  42  52 \\end{bmatrix}$。\n\n最终输出格式：\n- 您的程序必须计算四个用例中每个用例的 $d$ 值，并生成一行输出，其中包含用方括号括起来的逗号分隔列表。每个值必须精确到小数点后 $8$ 位，且不含空格。例如，输出必须类似于 $\\left[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4\\right]$，其中每个 $\\text{d}_k$ 是一个小数点后恰有 $8$ 位数字的浮点数。\n\n约束与说明：\n- 所有矩阵均为实值且有限。\n- 稳态分布 $\\pi$ 必须仅从 $T(\\tau)$ 计算。\n- 如果求解方法由于数值误差在 $\\pi$ 中产生了微小的负分量，必须将它们截断为非负值，并重新归一化以使总和为 $1$。\n- 此问题不涉及角度和物理单位。",
            "solution": "目标是为一个时间均匀的马尔可夫状态模型 (MSM) 实现一个定量的Chapman–Kolmogorov一致性检验。该检验评估了在延迟时间 $n\\tau$ 处转移矩阵的两种估计之间的差异：一种是直接从延迟 $n\\tau$ 的数据估计得到的，记作 $T(n\\tau)$；另一种是通过从延迟时间 $\\tau$ 的模型传播预测得到的，记作 $T(\\tau)^n$。此差异使用加权Frobenius范数量化。\n\n流程如下：\n\n1.  **从计数数据估计转移矩阵**\n    给定一个计数矩阵 $C(t)$，其中 $C(t)_{ij}$ 是在延迟时间 $t$ 内从离散状态 $i$ 转移到状态 $j$ 的观测次数，相应的行随机转移概率矩阵 $T(t)$ 的最大似然估计通过将每行除以其总和来给出。具体来说，对于每个元素 $T(t)_{ij}$：\n    $$\n    T(t)_{ij} = \\frac{C(t)_{ij}}{\\sum_{k=1}^m C(t)_{ik}}\n    $$\n    其中 $m$ 是状态数。这仅在从状态 $i$ 出发的总转移次数 $\\sum_k C(t)_{ik}$ 大于零时有效。\n    \n    对于没有观测到出向转移的状态（即 $\\sum_k C(t)_{ik} = 0$），定义了一个特殊条件。在这种情况下，转移矩阵的相应行被定义为在所有 $m$ 个状态上的均匀分布：\n    $$\n    T(t)_{ij} = \\frac{1}{m} \\quad \\text{for all } j=1, \\dots, m.\n    $$\n    此过程应用于计数矩阵 $C(\\tau)$ 以获得转移矩阵 $T(\\tau)$，并应用于计数矩阵 $C(n\\tau)$ 以获得 $T(n\\tau)$。\n\n2.  **转移矩阵的传播**\n    时间均匀的马尔可夫过程的Chapman–Kolmogorov方程指出 $T(s+t) = T(s)T(t)$。通过归纳法，这意味着对于离散延迟时间 $\\tau$ 和整数 $n \\ge 1$：\n    $$\n    T(n\\tau) = T(\\tau)T((n-1)\\tau) = \\dots = \\underbrace{T(\\tau) T(\\tau) \\cdots T(\\tau)}_{n \\text{ times}} = T(\\tau)^n.\n    $$\n    此方程提供了基于延迟 $\\tau$ 处的模型对延迟 $n\\tau$ 处转移矩阵的理论预测。我们使用数值矩阵求幂来计算这个矩阵 $T(\\tau)^n$。\n\n3.  **稳态分布的估计**\n    稳态分布（由行向量 $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_m]$ 表示）是状态上的一个概率分布，在施加转移矩阵后保持不变。它由以下特征值方程定义：\n    $$\n    \\pi^\\top T(\\tau) = \\pi^\\top\n    $$\n    满足约束条件 $\\sum_{i=1}^m \\pi_i = 1$ 且对所有 $i$ 有 $\\pi_i \\ge 0$。该方程表明 $\\pi^\\top$ 是 $T(\\tau)$ 的一个左特征向量，其特征值为 $\\lambda = 1$。等价地，$\\pi$ 是转置矩阵 $T(\\tau)^\\top$ 对应于特征值 $\\lambda=1$ 的右特征向量。\n    \n    对于一个行为良好的MSM（即不可约且非周期的模型），Perron-Frobenius定理保证存在一个唯一且所有分量均为正的 $\\pi$。我们通过求解 $T(\\tau)^\\top$ 的特征向量来计算 $\\pi$。选择与最接近 $1$ 的特征值对应的特征向量。由于潜在的数值浮点不精确性，计算出的特征向量分量可能是复数或微小的负数。我们取特征向量的实部，将任何负值截断为 $0$，然后重新归一化该向量，使其分量总和为 $1$。\n\n4.  **差异度量的计算**\n    直接估计的矩阵 $T(n\\tau)$ 和传播得到的矩阵 $T(\\tau)^n$ 之间的差异首先由差分矩阵捕获：\n    $$\n    \\Delta = T(n\\tau) - T(\\tau)^n.\n    $$\n    为了将这个差异矩阵量化为单一标量值，我们使用 $\\pi$ 加权的Frobenius范数，其定义如下：\n    $$\n    d = \\left\\| \\Delta \\right\\|_{F,\\pi} = \\sqrt{ \\sum_{i=1}^m \\pi_i \\sum_{j=1}^m \\left( \\Delta_{ij} \\right)^2 }.\n    $$\n    该度量可以解释为均方根误差。来自每个起始状态 $i$ 的误差贡献（即 $\\Delta$ 的第 $i$ 行的欧几里得范数的平方）由其稳态概率 $\\pi_i$ 加权。这使得来自频繁访问状态的转移误差更为重要，而来自罕见访问状态的转移误差则相对不那么重要，从而为模型的自洽性提供了一个具有物理意义的度量。\n    \n    算法通过为每个提供的测试用例实现这四个步骤来继续进行。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves the Chapman-Kolmogorov consistency test problem for a suite of test cases.\n    \"\"\"\n\n    def normalize_counts(C):\n        \"\"\"\n        Estimates a transition matrix T from a count matrix C via row-normalization.\n        \n        Args:\n            C (np.ndarray): The m x m count matrix.\n\n        Returns:\n            np.ndarray: The m x m row-stochastic transition matrix.\n        \"\"\"\n        m = C.shape[0]\n        T = C.astype(float)\n        \n        row_sums = T.sum(axis=1)\n        \n        # Identify rows with non-zero counts\n        non_zero_rows = row_sums > 0\n        \n        # Normalize non-zero rows\n        if np.any(non_zero_rows):\n             T[non_zero_rows, :] /= row_sums[non_zero_rows, np.newaxis]\n        \n        # Identify rows with zero counts\n        zero_rows = ~non_zero_rows\n        \n        # Set zero-count rows to uniform distribution\n        if np.any(zero_rows):\n            T[zero_rows, :] = 1.0 / m\n            \n        return T\n\n    def compute_stationary_distribution(T):\n        \"\"\"\n        Computes the stationary distribution pi for a transition matrix T.\n\n        Args:\n            T (np.ndarray): The m x m transition matrix.\n\n        Returns:\n            np.ndarray: The m-dimensional stationary distribution vector.\n        \"\"\"\n        # We need the left eigenvector of T for eigenvalue 1,\n        # which is the right eigenvector of T.T for eigenvalue 1.\n        eigenvalues, eigenvectors = scipy.linalg.eig(T.T)\n        \n        # Find the index of the eigenvalue closest to 1.\n        # Eigenvalues of a stochastic matrix have magnitude = 1.\n        idx = np.argmin(np.abs(eigenvalues - 1.0))\n        \n        # The eigenvector is the corresponding column.\n        pi_vector = eigenvectors[:, idx]\n        \n        # Take the real part (eigenvalues/vectors can be complex due to numerical precision).\n        pi = np.real(pi_vector)\n        \n        # Clip any small negative values that might arise from numerical error.\n        pi[pi  0] = 0\n        \n        # Normalize to ensure it's a probability distribution.\n        pi_sum = pi.sum()\n        if pi_sum > 0:\n            pi /= pi_sum\n        else:\n            # Fallback for an unlikely case of a zero vector\n            m = T.shape[0]\n            pi = np.full(m, 1.0 / m)\n\n        return pi\n\n    def compute_discrepancy(C_tau, C_ntau, n):\n        \"\"\"\n        Computes the pi-weighted Frobenius norm discrepancy for a single test case.\n\n        Args:\n            C_tau (np.ndarray): The count matrix at lag tau.\n            C_ntau (np.ndarray): The count matrix at lag n*tau.\n            n (int): The lag time multiplier.\n\n        Returns:\n            float: The scalar discrepancy value d.\n        \"\"\"\n        # Step 1: Estimate Transition Matrices\n        T_tau = normalize_counts(C_tau)\n        T_ntau = normalize_counts(C_ntau)\n        \n        # Step 2: Compute the Propagated Transition Matrix\n        T_tau_n = np.linalg.matrix_power(T_tau, n)\n        \n        # Step 3: Estimate the Stationary Distribution from T(tau)\n        pi = compute_stationary_distribution(T_tau)\n\n        # Step 4: Compute the Discrepancy\n        delta = T_ntau - T_tau_n\n        \n        # sum_{j} (Delta_ij)^2 for each i\n        row_wise_sq_sum = np.sum(delta**2, axis=1)\n        \n        # sum_{i} pi_i * (sum_{j} (Delta_ij)^2)\n        weighted_sum_of_squares = np.dot(pi, row_wise_sq_sum)\n        \n        d = np.sqrt(weighted_sum_of_squares)\n        \n        return d\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[32, 32, 0], [16, 32, 16], [0, 32, 32]]), # C(tau)\n            np.array([[24, 32, 8], [16, 32, 16], [8, 32, 24]]), # C(2tau)\n            2 # n\n        ),\n        (\n            np.array([[32, 32, 0], [16, 32, 16], [0, 32, 32]]), # C(tau)\n            np.array([[24, 32, 8], [16, 32, 16], [0, 0, 0]]), # C(2tau)\n            2 # n\n        ),\n        (\n            np.array([[99, 1], [2, 98]]), # C(tau)\n            np.array([[97, 3], [6, 94]]), # C(3tau)\n            3 # n\n        ),\n        (\n            np.array([[70, 30, 0, 0], [10, 80, 10, 0], [0, 20, 70, 10], [0, 0, 30, 70]]), # C(tau)\n            np.array([[52, 45, 3, 0], [15, 69, 15, 1], [2, 30, 54, 14], [0, 6, 42, 52]]), # C(2tau)\n            2 # n\n        ),\n    ]\n\n    results = []\n    for C_tau, C_ntau, n in test_cases:\n        result = compute_discrepancy(C_tau, C_ntau, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过验证的MSM的主要用途是计算动力学可观测量，例如平均首达时间（MFPT）。然而，由于模型是基于有限数据构建的，任何计算出的数值都存在固有的不确定性。这项高级练习将引导您超越简单的点估计，通过采用贝叶斯方法和狄利克雷先验来量化模型参数的不确定性，并使用 delta 方法将其传播到MFPT，从而为您的预测计算出可信区间。",
            "id": "3423406",
            "problem": "可逆马尔可夫状态模型（MSM）是根据观测到的离散微观状态之间的跃迁计数构建的。考虑一个有限的、行随机的转移矩阵 $T \\in \\mathbb{R}^{n \\times n}$，该矩阵是根据一个计数矩阵 $N \\in \\mathbb{N}_0^{n \\times n}$ 估计得出的，并对每一行使用共轭狄利克雷先验。对于每一行 $i$，假设其狄利克雷先验的参数为 $\\alpha_{i1}, \\dots, \\alpha_{in}$，并令第 $i$ 行的后验分布为 $\\mathrm{Dirichlet}(a_{i1}, \\dots, a_{in})$，其中 $a_{ij} = N_{ij} + \\alpha_{ij}$。令后验均值转移矩阵为 $A = N + \\alpha$ 的行归一化矩阵，即 $T_{ij} = a_{ij} / A_i$，其中 $A_i = \\sum_{j=1}^n a_{ij}$。对于每一行 $i$，行随机向量 $(T_{i1}, \\dots, T_{in})$ 各元素的后验协方差由经过充分检验的狄利克雷公式给出\n$$\n\\mathbb{E}[T_{ij}] = \\frac{a_{ij}}{A_i}, \\quad \n\\mathrm{Var}(T_{ij}) = \\frac{a_{ij}(A_i - a_{ij})}{A_i^2 (A_i + 1)}, \\quad\n\\mathrm{Cov}(T_{ij}, T_{ik}) = - \\frac{a_{ij} a_{ik}}{A_i^2 (A_i + 1)} \\quad \\text{for } j \\neq k.\n$$\n令 $B \\subset \\{1,\\dots,n\\}$ 为一个非空的目标（吸收）状态集，并令 $A \\subset \\{1,\\dots,n\\}$ 为一个非空的源状态集，且 $A \\cap B = \\varnothing$。定义补集 $R = \\{1,\\dots,n\\} \\setminus B$。对于一个转移矩阵为 $T$、延迟时间为 $\\tau_{\\mathrm{lag}}$ 的马尔可夫链，从 $A$ 到 $B$ 的平均首达时间（MFPT）定义如下。令 $T_{RR}$ 为 $T$ 限制在 $R$ 中行和列的子矩阵。假设 $T_{RR}$ 的谱半径严格小于 $1$，从而确保几乎必然会发生到 $B$ 的吸收。令 $t_R \\in \\mathbb{R}^{|R|}$ 为线性方程组\n$$\n(\\mathbf{I}_{|R|} - T_{RR}) \\, t_R = \\mathbf{1}_{|R|},\n$$\n的解，该解给出了从 $R$ 中每个状态出发到达 $B$ 的期望步数。定义从 $A$ 到 $B$ 的 MFPT，在 $A$ 上的均匀分布下取平均值，为\n$$\n\\tau_{A \\to B}(T) = \\frac{1}{|A|} \\sum_{i \\in A} (t_R)_i.\n$$\n以秒为单位的物理 MFPT 为 $\\tau_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\, \\tau_{A \\to B}(T)$。\n\n使用针对行随机矩阵的一阶特征值微扰理论和 delta 方法，可以通过在后验均值 $T$（即行归一化的 $N+\\alpha$）附近对 $\\tau_{A \\to B}$ 关于 $T$ 的元素进行线性化，来近似 $\\tau_{A \\to B}(T)$ 的后验不确定性。具体来说，令 $M = (\\mathbf{I}_{|R|} - T_{RR})^{-1}$，令 $v = t_R$，并令 $s_A \\in \\mathbb{R}^{|R|}$ 为 $R$ 上的指示向量，当 $i \\in A$ 时 $(s_A)_i = 1$，否则 $(s_A)_i = 0$。$\\tau_{A \\to B}$ 对 $k,l \\in R$ 的元素 $T_{kl}$ 的一阶敏感度由梯度项表示\n$$\n\\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = \\frac{1}{|A|} \\, \\big( (M^\\top s_A)_k \\big) \\, v_l, \\quad \\text{and} \\quad \\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = 0 \\ \\text{if } k \\notin R \\ \\text{or} \\ l \\notin R,\n$$\n这是隐函数定理与可对角化时 $T_{RR}$ 的预解式谱表示 $M = \\sum_{m} \\frac{1}{1 - \\lambda_m} r_m \\ell_m^\\top$ 相结合的结果，其中 $\\lambda_m$ 是 $T_{RR}$ 的特征值，$r_m, \\ell_m$ 是满足 $\\ell_m^\\top r_m = 1$ 的相应左右特征向量。在行独立的狄利克雷后验下，$\\tau_{A \\to B}$ 的后验方差近似为\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\sum_{i=1}^n \\nabla_{T_{i*}} \\tau_{A \\to B}^\\top \\, \\mathrm{Cov}(T_{i*}) \\, \\nabla_{T_{i*}} \\tau_{A \\to B},\n$$\n其中 $\\nabla_{T_{i*}} \\tau_{A \\to B}$ 是限制在第 $i$ 行的梯度（一个长度为 $n$ 的向量，当 $l \\notin R$ 时元素为零），$\\mathrm{Cov}(T_{i*})$ 是第 $i$ 行的狄利克雷协方差矩阵。使用正态分布近似 $\\tau_{A \\to B}$ 的后验分布，一个双边 $(1 - \\gamma)$ 可信区间为\n$$\n\\left[ \\tau_{\\mathrm{phys}} - z_{1-\\gamma/2} \\, \\tau_{\\mathrm{lag}} \\, \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]}, \\ \\ \\tau_{\\mathrm{phys}} + z_{1-\\gamma/2} \\, \\tau_{\\mathrm{lag}} \\, \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]} \\right],\n$$\n其中 $z_{1-\\gamma/2}$ 是标准正态分布的分位数。\n\n任务。实现一个完整、自包含的程序以完成以下操作：\n- 通过对 $N + \\alpha$ 进行行归一化来构建后验均值转移矩阵。\n- 计算以步数为单位的 $\\tau_{A \\to B}(T)$，并使用 $\\tau_{\\mathrm{lag}}$ 将其转换为秒。\n- 通过求解 $M^\\top s_A$ 和 $t_R$，利用上述线性响应公式计算梯度。\n- 组合逐行的狄利克雷协方差矩阵，并计算 $\\tau_{A \\to B}$ 的 delta 方法方差。\n- 返回置信水平为 $0.95$（即使用 $z_{0.975}$）的双边可信区间（以秒为单位），不进行四舍五入。\n\n使用以下测试套件。对于每种情况，以列表 $[\\text{lower}, \\text{upper}]$ 的形式输出从 $A$ 到 $B$ 的 MFPT 区间（以秒为单位）：\n- 情况 1（顺利路径）：\n  - $N = \\begin{bmatrix} 90  10  5 \\\\ 5  85  10 \\\\ 1  2  97 \\end{bmatrix}$，\n  - 对每个元素应用 $\\alpha = 0.5$（即 $\\alpha_{ij} = 0.5$），\n  - $A = \\{1\\}$，$B = \\{3\\}$，$\\tau_{\\mathrm{lag}} = 1 \\times 10^{-9}$ 秒。\n- 情况 2（边界情况，从某些状态到 B 的直接计数为零）：\n  - $N = \\begin{bmatrix} 50  50  0 \\\\ 0  50  50 \\\\ 0  0  100 \\end{bmatrix}$，\n  - 对每个元素应用 $\\alpha = 0.2$，\n  - $A = \\{1\\}$，$B = \\{3\\}$，$\\tau_{\\mathrm{lag}} = 5 \\times 10^{-10}$ 秒。\n- 情况 3（近可分解，缓慢逃逸）：\n  - $N = \\begin{bmatrix} 495  495  10 \\\\ 495  495  10 \\\\ 5  5  990 \\end{bmatrix}$，\n  - 对每个元素应用 $\\alpha = 0.1$，\n  - $A = \\{1,2\\}$，$B = \\{3\\}$，$\\tau_{\\mathrm{lag}} = 1 \\times 10^{-6}$ 秒。\n\n您的程序应生成单行输出，其中包含以下格式的结果，即用方括号括起来的逗号分隔列表：\n$$\n\\text{[}[ \\text{lower}_1, \\text{upper}_1 ],[ \\text{lower}_2, \\text{upper}_2 ],[ \\text{lower}_3, \\text{upper}_3 ]\\text{]}\n$$\n所有输出必须以秒（SI 单位）为单位，不得包含额外文本。",
            "solution": "该问题是有效的。它在计算统计物理领域提出了一个适定且具有科学依据的任务，具体涉及从马尔可夫状态模型（MSM）中推导出的动力学可观测量的不确定性量化。所提供的公式和方法是标准且正确的，数值输入是完整且物理上合理的。\n\n总体目标是计算从源状态集 $A$到目标状态集 $B$ 的平均首达时间（MFPT）的 $95\\%$ 贝叶斯可信区间。该计算依赖于一阶泰勒展开（delta 方法），将转移矩阵 $T$（被视为随机变量）的不确定性传播到作为 $T$ 的函数的 MFPT。$T$ 的后验分布是从一个转移计数矩阵 $N$ 和一个狄利克雷先验中推导出来的。\n\n该过程通过以下步骤序列执行。\n\n首先，我们建立转移矩阵 $T$ 的后验分布。给定状态 $i$ 和 $j$ 之间观测到的转移计数 $N_{ij}$，以及对每一行 $i$ 使用参数为 $\\alpha_{ij}$ 的共轭狄利克雷先验，转移矩阵第 $i$ 行的后验分布是狄利克雷分布。其参数由 $a_{ij} = N_{ij} + \\alpha_{ij}$ 给出。然后，通过对后验参数矩阵 $A = [a_{ij}]$ 进行行归一化来构建转移矩阵 $T$ 的后验均值。后验均值矩阵的元素为：\n$$\nT_{ij} = \\mathbb{E}[T_{ij}] = \\frac{a_{ij}}{\\sum_{k=1}^n a_{ik}}\n$$\n其中 $n$ 是状态数。\n\n其次，我们使用后验均值转移矩阵 $T$ 计算从源状态集 $A$ 到目标状态集 $B$ 的 MFPT。我们将瞬态状态集定义为 $R = \\{1, \\dots, n\\} \\setminus B$。从任意状态 $i \\in R$ 出发，到达 $B$ 中吸收态的期望步数由向量 $t_R$ 给出。该向量是以下线性系统的解：\n$$\n(\\mathbf{I}_{|R|} - T_{RR}) \\, t_R = \\mathbf{1}_{|R|}\n$$\n其中 $T_{RR}$ 是对应于仅在 $R$ 中状态之间转移的 $T$ 的子矩阵，$\\mathbf{I}_{|R|}$ 是大小为 $|R| \\times |R|$ 的单位矩阵，$\\mathbf{1}_{|R|}$ 是长度为 $|R|$ 的全一向量。矩阵 $\\mathbf{I}_{|R|} - T_{RR}$ 是可逆的，因为次随机矩阵 $T_{RR}$ 的谱半径严格小于 $1$（这是最终被吸收到 $B$ 的一个条件）。一旦求出 $t_R$，以延迟时间为单位的 MFPT，即 $\\tau_{A \\to B}(T)$，通过对 $t_R$ 中对应于源状态 $i \\in A$ 的条目进行平均计算得出：\n$$\n\\tau_{A \\to B}(T) = \\frac{1}{|A|} \\sum_{i \\in A} (t_R)_{i'}\n$$\n其中 $i'$ 表示状态 $i$ 在集合 $R$ 内的索引。然后，通过乘以延迟时间 $\\tau_{\\mathrm{lag}}$ 得到物理 MFPT，$\\tau_{\\mathrm{phys}}$：\n$$\n\\tau_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\cdot \\tau_{A \\to B}(T)\n$$\n\n第三，为应用 delta 方法，我们计算 MFPT 相对于转移矩阵 $T$ 元素的梯度 $\\nabla \\tau_{A \\to B}$，并在其后验均值处求值。相对于元素 $T_{kl}$ 的偏导数仅在状态 $k$ 和 $l$ 都在瞬态集 $R$ 中时才非零。该公式由下式给出：\n$$\n\\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = \\frac{1}{|A|} (M^\\top s_A)_k \\, v_l \\quad \\text{for } k,l \\in R\n$$\n否则为零。这里，$v = t_R$ 是先前计算的穿越时间向量。向量 $w = M^\\top s_A$ 通过求解线性系统 $(\\mathbf{I}_{|R|} - T_{RR})^\\top w = s_A$ 计算得出，其中 $s_A$ 是 $R$ 上的一个指示向量，如果状态在 $A$ 中，其元素为 $1$，否则为 $0$。\n\n第四，我们近似计算 MFPT 的后验方差，$\\mathrm{Var}[\\tau_{A \\to B}]$。delta 方法提供了以下近似：\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\nabla \\tau_{A \\to B}^\\top \\, \\mathrm{Cov}(T) \\, \\nabla \\tau_{A \\to B}\n$$\n由于在狄利克雷模型下，转移矩阵的行被假定为后验独立的，所以完整的协方差矩阵 $\\mathrm{Cov}(T)$ 是行分块对角矩阵。总方差简化为对每一行 $i$ 贡献的总和：\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\sum_{i=1}^n (\\nabla_{T_{i*}} \\tau_{A \\to B})^\\top \\, \\mathrm{Cov}(T_{i*}) \\, (\\nabla_{T_{i*}} \\tau_{A \\to B})\n$$\n其中 $\\nabla_{T_{i*}} \\tau_{A \\to B}$ 是对应于 $T$ 第 $i$ 行的梯度向量，$\\mathrm{Cov}(T_{i*})$ 是第 $i$ 行狄利克雷后验的 $n \\times n$ 协方差矩阵。$\\mathrm{Cov}(T_{i*})$ 的元素由狄利克雷分布的标准公式给出：\n$$\n\\mathrm{Var}(T_{ij}) = \\frac{a_{ij}(A_i - a_{ij})}{A_i^2 (A_i + 1)}, \\quad \\mathrm{Cov}(T_{ij}, T_{ik}) = - \\frac{a_{ij} a_{ik}}{A_i^2 (A_i + 1)} \\quad \\text{for } j \\neq k\n$$\n其中 $A_i = \\sum_{j=1}^n a_{ij}$。方差的求和只需对行 $i \\in R$ 执行，因为所有其他行的梯度为零。\n\n最后，我们为物理 MFPT 构建双边 $(1 - \\gamma)$ 可信区间。假设 $\\tau_{A \\to B}$ 的后验分布近似为正态分布，这一点可以由大样本下的中心极限定理和 delta 方法的线性近似来证明，该区间为：\n$$\n\\left[ \\tau_{\\mathrm{phys}} - z_{1-\\gamma/2} \\, \\sigma_{\\mathrm{phys}}, \\ \\ \\tau_{\\mathrm{phys}} + z_{1-\\gamma/2} \\, \\sigma_{\\mathrm{phys}} \\right]\n$$\n其中 $\\sigma_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]}$ 是物理 MFPT 的标准差，$z_{1-\\gamma/2}$ 是标准正态分布的 $(1 - \\gamma/2)$-分位数。对于一个 $95\\%$ 的可信区间，$\\gamma=0.05$，我们使用 $z_{0.975} \\approx 1.95996$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_mfpt_interval(N, alpha, A_1based, B_1based, tau_lag):\n    \"\"\"\n    Computes the 95% credible interval for the MFPT from source set A to target set B.\n    \n    Args:\n        N (list of lists): The n x n transition count matrix.\n        alpha (float): The uniform Dirichlet prior parameter.\n        A_1based (set): The set of 1-based source state indices.\n        B_1based (set): The set of 1-based target state indices.\n        tau_lag (float): The lag time of the Markov model in seconds.\n        \n    Returns:\n        list: A list [lower_bound, upper_bound] for the credible interval in seconds.\n    \"\"\"\n    # Step 1: Setup and Index Conversion\n    N_mat = np.array(N, dtype=float)\n    n = N_mat.shape[0]\n    all_states = set(range(n))\n    A_0based = {x - 1 for x in A_1based}\n    B_0based = {x - 1 for x in B_1based}\n    R_0based = all_states - B_0based\n    R_indices = sorted(list(R_0based))\n    num_R = len(R_indices)\n    R_map = {state_idx: i for i, state_idx in enumerate(R_indices)}\n\n    # Step 2: Posterior Mean Transition Matrix\n    alpha_mat = np.full((n, n), alpha, dtype=float)\n    A_post_mat = N_mat + alpha_mat\n    A_sums = A_post_mat.sum(axis=1)\n    T = A_post_mat / A_sums[:, np.newaxis]\n\n    # Step 3: Mean First-Passage Time (MFPT)\n    T_RR = T[np.ix_(R_indices, R_indices)]\n    I_RR = np.eye(num_R)\n    M_matrix = I_RR - T_RR\n    # v = t_R in problem statement, vector of expected steps to absorption from R\n    v = np.linalg.solve(M_matrix, np.ones(num_R))\n\n    A_in_R_indices = [R_map[i] for i in A_0based]\n    tau_steps = np.mean(v[A_in_R_indices])\n    tau_phys = tau_lag * tau_steps\n\n    # Step 4: Gradient Calculation\n    s_A = np.zeros(num_R)\n    A_in_R_0based_indices = [R_map[i] for i in A_0based if i in R_map]\n    if A_in_R_0based_indices:\n        s_A[A_in_R_0based_indices] = 1.0\n    \n    # w = M^T * s_A, solved via linear system\n    w = np.linalg.solve(M_matrix.T, s_A)\n\n    grad_tau = np.zeros((n, n))\n    # grad_tau_RR = (1/|A|) * w * v^T (outer product)\n    grad_tau_RR = (1.0 / len(A_0based)) * np.outer(w, v)\n    grad_tau[np.ix_(R_indices, R_indices)] = grad_tau_RR\n\n    # Step 5: Variance Calculation via Delta Method\n    total_var_tau = 0.0\n    # Sum over rows i in R. Gradient is zero for rows i not in R.\n    for i in R_indices:\n        grad_row_i = grad_tau[i, :]\n        a_i = A_post_mat[i, :]\n        A_i_sum = A_sums[i]\n        \n        # Dirichlet covariance matrix for row i\n        const = 1.0 / (A_i_sum**2 * (A_i_sum + 1.0))\n        diag_part = np.diag(a_i * A_i_sum)\n        outer_part = np.outer(a_i, a_i)\n        Cov_i = const * (diag_part - outer_part)\n\n        row_var = grad_row_i @ Cov_i @ grad_row_i\n        total_var_tau += row_var\n\n    # Step 6: Credible Interval\n    z_val = norm.ppf(0.975)  # for 95% interval\n    std_dev_tau_steps = np.sqrt(total_var_tau)\n    # Uncertainty in physical time\n    uncertainty_phys = z_val * tau_lag * std_dev_tau_steps\n\n    lower_bound = tau_phys - uncertainty_phys\n    upper_bound = tau_phys + uncertainty_phys\n\n    return [lower_bound, upper_bound]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": [[90, 10, 5], [5, 85, 10], [1, 2, 97]],\n            \"alpha\": 0.5,\n            \"A\": {1},\n            \"B\": {3},\n            \"tau_lag\": 1e-9\n        },\n        # Case 2 (edge, zero direct counts to B)\n        {\n            \"N\": [[50, 50, 0], [0, 50, 50], [0, 0, 100]],\n            \"alpha\": 0.2,\n            \"A\": {1},\n            \"B\": {3},\n            \"tau_lag\": 5e-10\n        },\n        # Case 3 (nearly decomposable)\n        {\n            \"N\": [[495, 495, 10], [495, 495, 10], [5, 5, 990]],\n            \"alpha\": 0.1,\n            \"A\": {1, 2},\n            \"B\": {3},\n            \"tau_lag\": 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = calculate_mfpt_interval(\n            case[\"N\"], case[\"alpha\"], case[\"A\"], case[\"B\"], case[\"tau_lag\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}