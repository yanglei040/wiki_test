{
    "hands_on_practices": [
        {
            "introduction": "构建马尔可夫状态模型（MSM）后，首要任务之一是理解其所代表的动力学网络的拓扑结构。过渡矩阵的谱（即其特征值）蕴含了关于网络连通性和弛豫时间尺度的丰富信息。这项实践将指导你如何利用谱诊断方法来识别模型中可能存在的常见问题，例如不连通的组分或亚稳态陷阱，这是模型验证和优化的关键一步 ()。",
            "id": "3423377",
            "problem": "给定一个由行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 表示的有限状态离散时间马尔可夫链，其元素 $P_{ij} \\ge 0$ 且对于每个状态 $i \\in \\{1,\\dots,n\\}$ 满足 $\\sum_{j=1}^n P_{ij} = 1$。考虑由其特征值 $\\{\\lambda_i\\}_{i=1}^n$ 定义的 $P$ 的谱。已知对于任何行随机矩阵 $P$，其谱半径满足对所有 $i$ 都有 $|\\lambda_i| \\le 1$，并且至少有一个特征值等于 $1$。检测不连通分量（即可约性）和诊断近吸收陷阱（即亚稳态集）可以通过谱诊断来解决。您必须编写一个程序，实现一种谱诊断方法以：\n- 基于特征值在 $1$ 处的近简并性确定不连通分量的数量，\n- 基于一个小的谱隙标记近吸收陷阱的存在，\n- 推荐一个编码为整数的修复策略。\n\n您的程序必须精确实现以下内容：\n- 令 $\\varepsilon_{\\mathrm{exact}} = 10^{-10}$，$\\varepsilon_{\\mathrm{trap}} = 10^{-2}$，以及 $\\theta_{\\mathrm{self}} = 0.99$。\n- 计算 $P$ 的所有特征值 $\\{\\lambda_i\\}_{i=1}^n$。\n- 定义不连通分量的数量为 $c = \\#\\{i : |\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}\\}$。直观上，如果 $c > 1$，则在给定的容差下，该链可约化为 $c$ 个闭的互通类。\n- 按如下方式定义谱隙：\n  - 如果 $c > 1$，设置谱隙 $\\delta = 0$。\n  - 如果 $c = 1$，令 $S = \\{i : |\\lambda_i - 1| > \\varepsilon_{\\mathrm{exact}}\\}$ 并定义 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$；如果 $S$ 为空，则定义 $\\delta = 1$。\n- 定义陷阱标志 $t \\in \\{0,1\\}$，如果 $c = 1$ 且 $\\delta \\le \\varepsilon_{\\mathrm{trap}}$，则 $t = 1$，否则 $t = 0$。\n- 定义修复代码 $r \\in \\{0,1,2\\}$：\n  - 如果 $c > 1$，设置 $r = 2$（建议进行数据增强以观察缺失的转移并减少可约性）。\n  - 否则，如果 $t = 1$ 且 $\\max_i P_{ii} \\ge \\theta_{\\mathrm{self}}$，设置 $r = 1$（建议进行状态细化以缓解高度粘滞的自转移）。\n  - 否则，如果 $t = 1$，设置 $r = 2$（建议进行数据增强以更好地采样亚稳态集之间的稀有转移）。\n  - 否则设置 $r = 0$（无操作）。\n- 您的程序必须在报告谱隙 $\\delta$ 之前将其四舍五入到六位小数。\n\n测试套件：\n您的程序必须分析以下五个转移矩阵（硬编码在您的程序中，不读取任何输入）：\n\n- 情况 $1$ ($5 \\times 5$)：两个不连通分量，\n  - 块 $A$ ($3 \\times 3$): $$A = \\begin{bmatrix} 0.8 & 0.2 & 0.0 \\\\ 0.1 & 0.8 & 0.1 \\\\ 0.0 & 0.3 & 0.7 \\end{bmatrix}$$,\n  - 块 $B$ ($2 \\times 2$): $$B = \\begin{bmatrix} 0.6 & 0.4 \\\\ 0.2 & 0.8 \\end{bmatrix}$$,\n  - $P_1 = \\mathrm{diag}(A,B)$。\n\n- 情况 $2$ ($4 \\times 4$)：一个具有非常高自转移的近吸收陷阱，\n  - $$P_2 = \\begin{bmatrix}\n  0.9995 & 0.0005 & 0.0 & 0.0 \\\\\n  0.05 & 0.3 & 0.3 & 0.35 \\\\\n  0.05 & 0.2 & 0.5 & 0.25 \\\\\n  0.05 & 0.25 & 0.25 & 0.45\n  \\end{bmatrix}$$。\n\n- 情况 $3$ ($4 \\times 4$)：充分混合的链，\n  - 对于所有 $i,j \\in \\{1,2,3,4\\}$，$P_3$ 都有 $P_{ij} = 0.25$。\n\n- 情况 $4$ ($6 \\times 6$)：两个弱连通簇（没有极端自循环的亚稳态），索引为 $0,1,2$ 和 $3,4,5$，\n  - 对于 $i \\in \\{0,1,2\\}$，\n    - $P_{ii} = 0.7$，对于 $\\{0,1,2\\}$ 中的另外两个索引 $j$，$P_{i,j} = 0.1485$，\n    - 对于 $j \\in \\{3,4,5\\}$，$P_{i,j} = 0.001$。\n  - 对于 $i \\in \\{3,4,5\\}$，\n    - $P_{ii} = 0.7$，对于 $\\{3,4,5\\}$ 中的另外两个索引 $j$，$P_{i,j} = 0.1485$，\n    - 对于 $j \\in \\{0,1,2\\}$，$P_{i,j} = 0.001$。\n\n- 情况 $5$ ($5 \\times 5$)：三个不连通分量，\n  - 块：$[1]$, $$C = \\begin{bmatrix} 0.9 & 0.1 \\\\ 0.2 & 0.8 \\end{bmatrix}$$, $$D = \\begin{bmatrix} 0.3 & 0.7 \\\\ 0.6 & 0.4 \\end{bmatrix}$$,\n  - $P_5 = \\mathrm{diag}([1],C,D)$。\n\n最终输出格式：\n- 对于每种情况，返回一个列表 $[c, t, r, \\delta]$，其中 $c$ 是一个整数，$t \\in \\{0,1\\}$，$r \\in \\{0,1,2\\}$，$\\delta$ 是一个四舍五入到六位小数的浮点数。\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，形式为逗号分隔的列表并用方括号括起来，例如 `[[...],[...],[...],[...],[...]]`。\n- 此问题不涉及物理单位。",
            "solution": "用户提供的问题是有效的。它在科学上基于有限状态马尔可夫链的谱理论，这是概率论及其应用（包括计算化学和物理学中的动力学建模）的核心课题。该问题是良定的，为诊断算法提供了所有必要的参数、矩阵和逻辑规则，这些都给出得明确且无歧义。\n\n该问题背后的基本原理是，转移矩阵 $P$ 的特征值编码了相应马尔可夫链的关键动力学性质。对于行随机矩阵 $P$，其元素非负且行和为 $1$，Perron-Frobenius 定理保证其谱半径为 $1$。也就是说，对于任何特征值 $\\lambda$，其模 $|\\lambda|$ 小于或等于 $1$。特征值 $\\lambda=1$ 始终存在且尤为重要。\n\n1.  **不连通分量与特征值 $\\lambda=1$**：等于 $1$ 的特征值的数量对应于状态空间中闭的互通类的数量，也称为常返集或不连通分量。如果链是不可约的（即可以从任何状态到达任何其他状态），则存在唯一的特征值 $\\lambda=1$。如果存在 $c > 1$ 个这样的特征值，则链是可约的，可分解为 $c$ 个不相交的状态集。在每个集合内部，状态是互通的，但集合之间没有转移。在数值计算中，我们通过检查近似为 $1$ 的特征值来考虑浮点数的不精确性。问题通过标准 $|\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}$ 来定义这一点，其中 $\\varepsilon_{\\mathrm{exact}} = 10^{-10}$ 是一个很小的容差。这类特征值的数量用 $c$ 表示。\n\n2.  **亚稳态与谱隙**：模小于 $1$ 的特征值决定了系统的弛豫动力学。收敛到平稳分布的时间尺度由*谱隙*决定，谱隙是 $1$ 与最大模长的非平稳特征值之差。谱隙非常小的不可约链（$c=1$）被称为*亚稳态的*或*近可约的*。这表明状态空间被划分为多个状态集，这些状态集内部连接紧密，但彼此之间连接微弱。在这些亚稳态集内部的转移是频繁的，而它们之间的转移是稀有事件，导致整体弛豫非常缓慢。问题按如下方式定义谱隙 $\\delta$：如果 $c=1$，则 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$，其中 $S$ 索引不等于 $1$ 的特征值。一个小的 $\\delta$（具体来说，$\\delta \\le \\varepsilon_{\\mathrm{trap}} = 10^{-2}$）表示亚稳态。如果 $c>1$，链是真正可约的，单个全系统弛豫速率的概念是未良定义的；因此，$\\delta$ 被设为 $0$。\n\n要实现的算法流程是这些原理的直接应用。对于给定的转移矩阵 $P$：\n\n1.  **特征值计算**：使用标准的数值线性代数例程计算 $n \\times n$ 矩阵 $P$ 的全部特征值谱 $\\{\\lambda_i\\}_{i=1}^n$。这些特征值可能是复数。\n\n2.  **确定分量数 ($c$)**：我们遍历计算出的特征值，并计算满足条件 $|\\lambda_i - 1| \\le \\varepsilon_{\\mathrm{exact}}$ 的特征值数量。此计数即为 $c$ 的值。\n\n3.  **计算谱隙 ($\\delta$)**：\n    *   如果 $c > 1$，链是可约的，我们设置 $\\delta=0$。\n    *   如果 $c = 1$，链是不可约的。我们确定非平稳特征值的集合 $S = \\{i : |\\lambda_i - 1| > \\varepsilon_{\\mathrm{exact}}\\}$。然后我们找出这些特征值中的最大模 $\\max_{i \\in S} |\\lambda_i|$，并计算 $\\delta = 1 - \\max_{i \\in S} |\\lambda_i|$。如果 $S$ 为空（这只在所有特征值都为 $1$ 的平凡 $1 \\times 1$ 矩阵 $[[1]]$ 的情况下发生），则 $\\delta$ 定义为 $1$。\n\n4.  **设置陷阱标志 ($t$)**：陷阱标志 $t$ 用于指示近吸收陷阱或亚稳态的存在。如果链是不可约的（$c=1$）但谱隙很小，表明动力学缓慢（$\\delta \\le \\varepsilon_{\\mathrm{trap}}$），则将其设置为 $1$。否则，将 $t$ 设置为 $0$。\n\n5.  **分配修复代码 ($r$)**：根据 $c$ 和 $t$ 的值分配修复代码 $r$。\n    *   如果 $c > 1$，模型是不连通的（$r=2$），这表明需要更多的模拟数据来潜在地观察连接各分量的转移。\n    *   如果 $t = 1$（亚稳态）并且存在一个具有极高自转移概率的状态（$\\max_i P_{ii} \\ge \\theta_{\\mathrm{self}} = 0.99$），这表明存在一个作为动力学陷阱的“粘滞”状态（$r=1$）。建议的修复方法是细化状态定义，例如将该状态拆分为多个微观状态。\n    *   如果 $t = 1$ 但没有单个状态过度粘滞，那么亚稳态是由状态簇之间的稀有转移引起的（$r=2$）。同样，建议使用更多数据来更好地采样这些稀有事件。\n    *   如果以上条件都不满足，则认为模型行为良好（不可约且混合足够快），无需任何操作（$r=0$）。\n\n最后，谱隙 $\\delta$ 被四舍五入到六位小数以供报告，并且每个案例的结果被编译到列表 $[c, t, r, \\delta]$ 中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes a set of Markov transition matrices based on their spectral properties\n    to diagnose disconnected components and metastable traps.\n    \"\"\"\n\n    # Define the constants from the problem statement.\n    EPS_EXACT = 1e-10\n    EPS_TRAP = 1e-2\n    THETA_SELF = 0.99\n\n    # --- Define the test cases from the problem statement ---\n\n    # Case 1: 5x5, two disconnected components\n    A = np.array([\n        [0.8, 0.2, 0.0],\n        [0.1, 0.8, 0.1],\n        [0.0, 0.3, 0.7]\n    ])\n    B = np.array([\n        [0.6, 0.4],\n        [0.2, 0.8]\n    ])\n    P1 = np.zeros((5, 5))\n    P1[0:3, 0:3] = A\n    P1[3:5, 3:5] = B\n\n    # Case 2: 4x4, one nearly absorbing trap\n    P2 = np.array([\n        [0.9995, 0.0005, 0.0, 0.0],\n        [0.05, 0.3, 0.3, 0.35],\n        [0.05, 0.2, 0.5, 0.25],\n        [0.05, 0.25, 0.25, 0.45]\n    ])\n\n    # Case 3: 4x4, well-mixed chain\n    P3 = np.full((4, 4), 0.25)\n\n    # Case 4: 6x6, two weakly connected clusters\n    P4 = np.zeros((6, 6))\n    # Cluster 1: indices 0, 1, 2\n    for i in range(3):\n        P4[i, i] = 0.7\n        for j in range(3):\n            if i != j:\n                P4[i, j] = 0.1485\n        for j in range(3, 6):\n            P4[i, j] = 0.001\n    # Cluster 2: indices 3, 4, 5\n    for i in range(3, 6):\n        P4[i, i] = 0.7\n        for j in range(3, 6):\n            if i != j:\n                P4[i, j] = 0.1485\n        for j in range(3):\n            P4[i, j] = 0.001\n\n    # Case 5: 5x5, three disconnected components\n    C = np.array([\n        [0.9, 0.1],\n        [0.2, 0.8]\n    ])\n    D = np.array([\n        [0.3, 0.7],\n        [0.6, 0.4]\n    ])\n    P5 = np.zeros((5, 5))\n    P5[0, 0] = 1.0\n    P5[1:3, 1:3] = C\n    P5[3:5, 3:5] = D\n    \n    test_cases = [P1, P2, P3, P4, P5]\n    results = []\n\n    for P in test_cases:\n        # Compute all eigenvalues of P\n        eigenvalues = np.linalg.eigvals(P)\n        \n        # --- Implement the diagnostic logic ---\n\n        # 1. Determine number of disconnected components (c)\n        c = np.sum(np.abs(eigenvalues - 1.0) = EPS_EXACT)\n        \n        c = int(c) # Ensure c is a standard Python int\n\n        # 2. Define spectral gap (delta), trap flag (t), and remediation code (r)\n        if c > 1:\n            delta = 0.0\n            t = 0\n            r = 2\n        else: # c == 1 (or c == 0, though impossible for stochastic matrix)\n            # Find non-stationary eigenvalues\n            is_non_stationary = np.abs(eigenvalues - 1.0) > EPS_EXACT\n            \n            non_stationary_lambdas = eigenvalues[is_non_stationary]\n\n            if non_stationary_lambdas.size == 0:\n                # This handles the case of a 1x1 matrix [[1]]\n                delta = 1.0\n            else:\n                # Calculate spectral gap\n                max_mod_non_stat = np.max(np.abs(non_stationary_lambdas))\n                delta = 1.0 - max_mod_non_stat\n            \n            # 3. Define trap flag (t)\n            t = 1 if delta = EPS_TRAP else 0\n\n            # 4. Define remediation code (r)\n            if t == 1:\n                max_pii = np.max(np.diag(P))\n                if max_pii >= THETA_SELF:\n                    r = 1\n                else:\n                    r = 2\n            else:\n                r = 0\n\n        # Round delta to six decimal places\n        delta_rounded = round(delta, 6)\n        \n        results.append([c, t, r, delta_rounded])\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string, join them by commas, and wrap in brackets.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "马尔可夫状态模型的核心假设是系统在给定延迟时间 $\\tau$ 下的无记忆性。检验这一假设最基本的方法是查普曼-科尔莫戈罗夫（Chapman-Kolmogorov, CK）检验，它要求在不同时间尺度上估计的动力学应保持一致。通过这项实践，你将从第一性原理出发，实现一个量化的CK检验，通过比较直接从数据中估计的 $T(n\\tau)$ 与通过模型传播得到的 $T(\\tau)^n$，来评估模型的自洽性 ()。",
            "id": "3423468",
            "problem": "您的任务是为从分子动力学轨迹计数构建的离散状态、时间均匀的马尔可夫状态模型 (MSM) 形式化并实现一个定量的 Chapman–Kolmogorov 一致性检验。该检验将比较在滞后时间 $n\\tau$ 直接估计的转移矩阵（表示为 $T(n\\tau)$）与在滞后时间 $\\tau$ 估计的转移矩阵的 $n$ 次矩阵幂（表示为 $T(\\tau)^n$）。您的目标是从第一性原理推导该检验，并实现一个程序，为提供的一组计数矩阵测试套件计算 $T(n\\tau)$ 和 $T(\\tau)^n$ 之间的加权差异。\n\n基本原理：\n- 对于时间均匀的马尔可夫链，马尔可夫性质意味着 Chapman–Kolmogorov 恒等式：对于任意非负时间 $s$ 和 $t$，转移核满足 $T(t+s) = T(t) T(s)$。在离散时间中，对于滞后时间 $\\tau$，这意味着对于任何整数 $n \\ge 1$，都有 $T(n\\tau) = T(\\tau)^n$。\n- 给定一个计数矩阵 $C(\\tau)$，其中 $C(\\tau)_{ij}$ 记录了在滞后时间 $\\tau$ 内从状态 $i$ 到状态 $j$ 的观测转移次数，行随机转移矩阵 $T(\\tau)$ 的最大似然估计通过行归一化得到：当 $\\sum_k C(\\tau)_{ik}  0$ 时，$T(\\tau)_{ij} = C(\\tau)_{ij} / \\sum_k C(\\tau)_{ik}$。\n- 平稳分布 $\\pi$ 由左特征向量方程 $\\pi^\\top T(\\tau) = \\pi^\\top$ 定义，并满足归一化条件 $\\sum_i \\pi_i = 1$ 和 $\\pi_i \\ge 0$。\n\n您的程序必须为每个测试用例实现以下步骤：\n- 输入：两个大小相同（$m \\times m$）的方形计数矩阵 $C(\\tau)$ 和 $C(n\\tau)$，以及一个整数 $n \\ge 1$。\n- 通过对 $C(\\tau)$ 进行行归一化来估计 $T(\\tau)$。对于总计数为零的任何行 $i$（即 $\\sum_j C(\\tau)_{ij} = 0$），将 $T(\\tau)$ 的相应行定义为在 $m$ 个状态上的均匀分布，即对所有 $j$，$T(\\tau)_{ij} = 1/m$。\n- 使用与零行（均匀分布行）相同的规则，通过对 $C(n\\tau)$ 进行行归一化来估计 $T(n\\tau)$。\n- 计算平稳分布 $\\pi$ 的一个估计，作为 $\\pi^\\top T(\\tau) = \\pi^\\top$ 的任意非负解，并满足 $\\sum_i \\pi_i = 1$。\n- 构建差异矩阵 $\\Delta = T(n\\tau) - T(\\tau)^n$ 并计算 $\\pi$ 加权的 Frobenius 范数差异：\n$$\nd = \\left\\| \\Delta \\right\\|_{F,\\pi} = \\sqrt{ \\sum_{i=1}^m \\pi_i \\sum_{j=1}^m \\left( \\Delta_{ij} \\right)^2 }.\n$$\n这种加权方式强调了在高频占据状态中的误差，而减弱了在稀有状态中的误差。\n\n测试套件：\n实现您的程序，按顺序处理以下四个测试用例。对于每个用例，将标量值 $d$ 报告为一个浮点数。\n\n- 用例 1（完全一致，$m=3$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 32  32  0 \\\\ 16  32  16 \\\\ 0  32  32 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 24  32  8 \\\\ 16  32  16 \\\\ 8  32  24 \\end{bmatrix}$。\n\n- 用例 2（在 $C(2\\tau)$ 中有零行的边缘情况，$m=3$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 32  32  0 \\\\ 16  32  16 \\\\ 0  32  32 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 24  32  8 \\\\ 16  32  16 \\\\ 0  0  0 \\end{bmatrix}$。\n\n- 用例 3（带有采样噪声的近吸收双态系统，$m=2$，$n=3$）：\n  - $C(\\tau) = \\begin{bmatrix} 99  1 \\\\ 2  98 \\end{bmatrix}$。\n  - $C(3\\tau) = \\begin{bmatrix} 97  3 \\\\ 6  94 \\end{bmatrix}$。\n\n- 用例 4（更高维度的完全一致情况，$m=4$，$n=2$）：\n  - $C(\\tau) = \\begin{bmatrix} 70  30  0  0 \\\\ 10  80  10  0 \\\\ 0  20  70  10 \\\\ 0  0  30  70 \\end{bmatrix}$。\n  - $C(2\\tau) = \\begin{bmatrix} 52  45  3  0 \\\\ 15  69  15  1 \\\\ 2  30  54  14 \\\\ 0  6  42  52 \\end{bmatrix}$。\n\n最终输出格式：\n- 您的程序必须计算四个用例中每个用例的 $d$ 值，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个值必须四舍五入到恰好 $8$ 位小数，并且没有空格。例如，输出必须看起来像 `[d_1,d_2,d_3,d_4]`，其中每个 $\\text{d}_k$ 是一个小数点后恰好有 $8$ 位数字的浮点数。\n\n约束和说明：\n- 所有矩阵均为实值且有限。\n- 平稳分布 $\\pi$ 必须仅从 $T(\\tau)$ 计算。\n- 如果求解方法由于数值误差在 $\\pi$ 中产生了小的负分量，必须将它们截断为非负值，并重新归一化以使总和为 $1$。\n- 此问题不涉及角度和物理单位。",
            "solution": "目标是为时间均匀的马尔可夫状态模型 (MSM) 实现一个定量的 Chapman–Kolmogorov 一致性检验。该检验评估了在滞后时间 $n\\tau$ 处转移矩阵的两种估计之间的差异：一种是直接从滞后时间 $n\\tau$ 的数据估计的，表示为 $T(n\\tau)$；另一种是通过从滞后时间 $\\tau$ 的模型传播预测的，表示为 $T(\\tau)^n$。差异使用加权 Frobenius 范数进行量化。\n\n过程如下：\n\n1.  **从计数数据估计转移矩阵**\n    给定一个计数矩阵 $C(t)$，其中 $C(t)_{ij}$ 是在滞后时间 $t$ 内从离散状态 $i$ 到状态 $j$ 的观测转移次数，相应的行随机转移概率矩阵 $T(t)$ 的最大似然估计通过将每行除以其总和进行归一化得到。具体来说，对于每个元素 $T(t)_{ij}$：\n    $$\n    T(t)_{ij} = \\frac{C(t)_{ij}}{\\sum_{k=1}^m C(t)_{ik}}\n    $$\n    其中 $m$ 是状态数。这仅在从状态 $i$ 出发的总转移次数 $\\sum_k C(t)_{ik}$ 大于零时有效。\n    \n    为没有观测到出向转移的状态（即 $\\sum_k C(t)_{ik} = 0$）定义了一个特殊条件。在这种情况下，转移矩阵的相应行被定义为在所有 $m$ 个状态上的均匀分布：\n    $$\n    T(t)_{ij} = \\frac{1}{m} \\quad \\text{for all } j=1, \\dots, m.\n    $$\n    此过程应用于计数矩阵 $C(\\tau)$ 以获得转移矩阵 $T(\\tau)$，并应用于计数矩阵 $C(n\\tau)$ 以获得 $T(n\\tau)$。\n\n2.  **转移矩阵的传播**\n    时间均匀马尔可夫过程的 Chapman–Kolmogorov 方程指出 $T(s+t) = T(s)T(t)$。通过归纳法，这意味着对于离散滞后时间 $\\tau$ 和整数 $n \\ge 1$：\n    $$\n    T(n\\tau) = T(\\tau)T((n-1)\\tau) = \\dots = \\underbrace{T(\\tau) T(\\tau) \\cdots T(\\tau)}_{n \\text{ times}} = T(\\tau)^n.\n    $$\n    这个方程提供了基于滞后时间 $\\tau$ 的模型对滞后时间 $n\\tau$ 处转移矩阵的理论预测。我们使用数值矩阵幂运算来计算这个矩阵 $T(\\tau)^n$。\n\n3.  **平稳分布的估计**\n    平稳分布，用行向量 $\\pi = [\\pi_1, \\pi_2, \\dots, \\pi_m]$ 表示，是状态上的一个概率分布，在转移矩阵作用下保持不变。它由以下特征值方程定义：\n    $$\n    \\pi^\\top T(\\tau) = \\pi^\\top\n    $$\n    服从约束条件 $\\sum_{i=1}^m \\pi_i = 1$ 和对所有 $i$ 都有 $\\pi_i \\ge 0$。该方程表明 $\\pi^\\top$ 是 $T(\\tau)$ 的一个左特征向量，其特征值为 $\\lambda = 1$。等价地，$\\pi$ 是转置矩阵 $T(\\tau)^\\top$ 对应于特征值 $\\lambda=1$ 的右特征向量。\n    \n    对于一个行为良好（即不可约且非周期）的 MSM，Perron-Frobenius 定理保证存在一个唯一的、所有分量均为正的 $\\pi$。我们通过寻找 $T(\\tau)^\\top$ 的特征向量来计算 $\\pi$。选择与特征值最接近 1 的特征向量。由于潜在的数值浮点不精确性，计算出的特征向量分量可能是复数或略带负值。我们取特征向量的实部，将任何负值截断为 0，并重新归一化该向量，使其分量总和为 1。\n\n4.  **差异度量的计算**\n    直接估计的矩阵 $T(n\\tau)$ 和传播的矩阵 $T(\\tau)^n$ 之间的差异首先由差分矩阵捕获：\n    $$\n    \\Delta = T(n\\tau) - T(\\tau)^n.\n    $$\n    为了将这个差异矩阵量化为单个标量值，我们使用 $\\pi$ 加权的 Frobenius 范数，定义为：\n    $$\n    d = \\left\\| \\Delta \\right\\|_{F,\\pi} = \\sqrt{ \\sum_{i=1}^m \\pi_i \\sum_{j=1}^m \\left( \\Delta_{ij} \\right)^2 }.\n    $$\n    该度量可解释为均方根误差。来自每个起始状态 $i$ 的误差贡献（即 $\\Delta$ 的第 $i$ 行的欧几里得范数平方）由其平稳概率 $\\pi_i$ 加权。这使得来自频繁访问状态的转移误差更为重要，而来自罕见访问状态的误差则不那么重要，从而为模型的自洽性提供了一个具有物理意义的度量。\n    \n    算法通过为每个提供的测试用例实现这四个步骤来进行。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves the Chapman-Kolmogorov consistency test problem for a suite of test cases.\n    \"\"\"\n\n    def normalize_counts(C):\n        \"\"\"\n        Estimates a transition matrix T from a count matrix C via row-normalization.\n        \n        Args:\n            C (np.ndarray): The m x m count matrix.\n\n        Returns:\n            np.ndarray: The m x m row-stochastic transition matrix.\n        \"\"\"\n        m = C.shape[0]\n        T = C.astype(float)\n        \n        row_sums = T.sum(axis=1)\n        \n        # Identify rows with non-zero counts\n        non_zero_rows = row_sums > 0\n        \n        # Normalize non-zero rows\n        if np.any(non_zero_rows):\n             T[non_zero_rows, :] /= row_sums[non_zero_rows, np.newaxis]\n        \n        # Identify rows with zero counts\n        zero_rows = ~non_zero_rows\n        \n        # Set zero-count rows to uniform distribution\n        if np.any(zero_rows):\n            T[zero_rows, :] = 1.0 / m\n            \n        return T\n\n    def compute_stationary_distribution(T):\n        \"\"\"\n        Computes the stationary distribution pi for a transition matrix T.\n\n        Args:\n            T (np.ndarray): The m x m transition matrix.\n\n        Returns:\n            np.ndarray: The m-dimensional stationary distribution vector.\n        \"\"\"\n        # We need the left eigenvector of T for eigenvalue 1,\n        # which is the right eigenvector of T.T for eigenvalue 1.\n        eigenvalues, eigenvectors = scipy.linalg.eig(T.T)\n        \n        # Find the index of the eigenvalue closest to 1.\n        # Eigenvalues of a stochastic matrix have magnitude = 1.\n        idx = np.argmin(np.abs(eigenvalues - 1.0))\n        \n        # The eigenvector is the corresponding column.\n        pi_vector = eigenvectors[:, idx]\n        \n        # Take the real part (eigenvalues/vectors can be complex due to numerical precision).\n        pi = np.real(pi_vector)\n        \n        # Clip any small negative values that might arise from numerical error.\n        pi[pi  0] = 0\n        \n        # Normalize to ensure it's a probability distribution.\n        pi_sum = pi.sum()\n        if pi_sum > 0:\n            pi /= pi_sum\n        else:\n            # Fallback for an unlikely case of a zero vector\n            m = T.shape[0]\n            pi = np.full(m, 1.0 / m)\n\n        return pi\n\n    def compute_discrepancy(C_tau, C_ntau, n):\n        \"\"\"\n        Computes the pi-weighted Frobenius norm discrepancy for a single test case.\n\n        Args:\n            C_tau (np.ndarray): The count matrix at lag tau.\n            C_ntau (np.ndarray): The count matrix at lag n*tau.\n            n (int): The lag time multiplier.\n\n        Returns:\n            float: The scalar discrepancy value d.\n        \"\"\"\n        # Step 1: Estimate Transition Matrices\n        T_tau = normalize_counts(C_tau)\n        T_ntau = normalize_counts(C_ntau)\n        \n        # Step 2: Compute the Propagated Transition Matrix\n        T_tau_n = np.linalg.matrix_power(T_tau, n)\n        \n        # Step 3: Estimate the Stationary Distribution from T(tau)\n        pi = compute_stationary_distribution(T_tau)\n\n        # Step 4: Compute the Discrepancy\n        delta = T_ntau - T_tau_n\n        \n        # sum_{j} (Delta_ij)^2 for each i\n        row_wise_sq_sum = np.sum(delta**2, axis=1)\n        \n        # sum_{i} pi_i * (sum_{j} (Delta_ij)^2)\n        weighted_sum_of_squares = np.dot(pi, row_wise_sq_sum)\n        \n        d = np.sqrt(weighted_sum_of_squares)\n        \n        return d\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[32, 32, 0], [16, 32, 16], [0, 32, 32]]), # C(tau)\n            np.array([[24, 32, 8], [16, 32, 16], [8, 32, 24]]), # C(2tau)\n            2 # n\n        ),\n        (\n            np.array([[32, 32, 0], [16, 32, 16], [0, 32, 32]]), # C(tau)\n            np.array([[24, 32, 8], [16, 32, 16], [0, 0, 0]]), # C(2tau)\n            2 # n\n        ),\n        (\n            np.array([[99, 1], [2, 98]]), # C(tau)\n            np.array([[97, 3], [6, 94]]), # C(3tau)\n            3 # n\n        ),\n        (\n            np.array([[70, 30, 0, 0], [10, 80, 10, 0], [0, 20, 70, 10], [0, 0, 30, 70]]), # C(tau)\n            np.array([[52, 45, 3, 0], [15, 69, 15, 1], [2, 30, 54, 14], [0, 6, 42, 52]]), # C(2tau)\n            2 # n\n        ),\n    ]\n\n    results = []\n    for C_tau, C_ntau, n in test_cases:\n        result = compute_discrepancy(C_tau, C_ntau, n)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过验证的MSM的最终价值在于其预测能力，例如计算平均首过时间（Mean First-Passage Time, MFPT）等动力学可观测量。然而，由于这些量是从有限的数据中推断出来的，因此报告其不确定性至关重要。本练习将引导你进入贝叶斯MSM的领域，学习如何使用德尔塔方法（delta method）将源于计数的统计不确定性传播到MFPT的计算中，从而得到一个带有可信区间的、更为严谨的动力学预测结果 ()。",
            "id": "3423406",
            "problem": "一个可逆马尔可夫状态模型 (MSM) 是根据离散微观态之间观测到的转移计数构建的。考虑一个有限的、行随机的转移矩阵 $T \\in \\mathbb{R}^{n \\times n}$，它是从一个计数矩阵 $N \\in \\mathbb{N}_0^{n \\times n}$ 估计得到的，并在每一行上使用共轭狄利克雷先验。对于每一行 $i$，假设一个参数为 $\\alpha_{i1}, \\dots, \\alpha_{in}$ 的狄利克雷先验，并令第 $i$ 行的后验为 $\\mathrm{Dirichlet}(a_{i1}, \\dots, a_{in})$，其中 $a_{ij} = N_{ij} + \\alpha_{ij}$。令后验均值转移矩阵为 $A = N + \\alpha$ 的行归一化矩阵，即 $T_{ij} = a_{ij} / A_i$，其中 $A_i = \\sum_{j=1}^n a_{ij}$。对于每一行 $i$，行随机向量 $(T_{i1}, \\dots, T_{in})$ 条目的后验协方差由经过充分检验的狄利克雷公式给出\n$$\n\\mathbb{E}[T_{ij}] = \\frac{a_{ij}}{A_i}, \\quad \n\\mathrm{Var}(T_{ij}) = \\frac{a_{ij}(A_i - a_{ij})}{A_i^2 (A_i + 1)}, \\quad\n\\mathrm{Cov}(T_{ij}, T_{ik}) = - \\frac{a_{ij} a_{ik}}{A_i^2 (A_i + 1)} \\quad \\text{for } j \\neq k.\n$$\n令 $B \\subset \\{1,\\dots,n\\}$ 为一个非空的目标（吸收）态集，并令 $A \\subset \\{1,\\dots,n\\}$ 为一个非空的源态集，且 $A \\cap B = \\varnothing$。定义补集 $R = \\{1,\\dots,n\\} \\setminus B$。对于一个转移矩阵为 $T$、延迟时间为 $\\tau_{\\mathrm{lag}}$ 的马尔可夫链，从 $A$到 $B$ 的平均首过时间 (MFPT) 定义如下。令 $T_{RR}$ 为 $T$ 在 $R$ 中的行和列上的限制。假设 $T_{RR}$ 的谱半径严格小于 1，因此到 $B$ 的吸收几乎必然发生。令 $t_R \\in \\mathbb{R}^{|R|}$ 求解线性系统\n$$\n(\\mathbf{I}_{|R|} - T_{RR}) \\, t_R = \\mathbf{1}_{|R|},\n$$\n这会得出从 $R$ 中每个状态开始到达 $B$ 的期望步数。将从 $A$到 $B$ 的 MFPT 定义为在 $A$ 上的均匀分布上取平均：\n$$\n\\tau_{A \\to B}(T) = \\frac{1}{|A|} \\sum_{i \\in A} (t_R)_i.\n$$\n以秒为单位的物理 MFPT 是 $\\tau_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\, \\tau_{A \\to B}(T)$。\n\n使用针对行随机矩阵的一阶特征值微扰理论和 delta 方法，可以通过在后验均值 $T$（即行归一化的 $N+\\alpha$）附近，对 $\\tau_{A \\to B}$ 关于 $T$ 的条目进行线性化，来近似 $\\tau_{A \\to B}(T)$ 的后验不确定性。具体来说，令 $M = (\\mathbf{I}_{|R|} - T_{RR})^{-1}$，令 $v = t_R$，并令 $s_A \\in \\mathbb{R}^{|R|}$ 为 $R$ 上的指示向量，如果 $i \\in A$，则 $(s_A)_i = 1$，否则 $(s_A)_i = 0$。$\\tau_{A \\to B}$ 对 $k,l \\in R$ 的一个条目 $T_{kl}$ 的一阶灵敏度由以下梯度条目表示：\n$$\n\\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = \\frac{1}{|A|} \\, \\big( (M^\\top s_A)_k \\big) \\, v_l, \\quad \\text{and} \\quad \\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = 0 \\ \\text{if } k \\notin R \\ \\text{or} \\ l \\notin R,\n$$\n这是隐函数定理结合 $T_{RR}$ 的预解式在可对角化时的谱表示 $M = \\sum_{m} \\frac{1}{1 - \\lambda_m} r_m \\ell_m^\\top$ 的一个推论，其中 $\\lambda_m$ 是 $T_{RR}$ 的特征值，$r_m, \\ell_m$ 是满足 $\\ell_m^\\top r_m = 1$ 的相应左右特征向量。在逐行独立的狄利克雷后验下，$\\tau_{A \\to B}$ 的后验方差可近似为：\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\sum_{i=1}^n \\nabla_{T_{i*}} \\tau_{A \\to B}^\\top \\, \\mathrm{Cov}(T_{i*}) \\, \\nabla_{T_{i*}} \\tau_{A \\to B},\n$$\n其中 $\\nabla_{T_{i*}} \\tau_{A \\to B}$ 是限制在第 $i$ 行的梯度（一个长度为 $n$ 的向量，对于 $l \\notin R$ 的条目为零），而 $\\mathrm{Cov}(T_{i*})$ 是第 $i$ 行的狄利克雷协方差矩阵。使用对 $\\tau_{A \\to B}$后验分布的正态近似，一个双边 $(1 - \\gamma)$ 可信区间为：\n$$\n\\left[ \\tau_{\\mathrm{phys}} - z_{1-\\gamma/2} \\, \\tau_{\\mathrm{lag}} \\, \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]}, \\ \\ \\tau_{\\mathrm{phys}} + z_{1-\\gamma/2} \\, \\tau_{\\mathrm{lag}} \\, \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]} \\right],\n$$\n其中 $z_{1-\\gamma/2}$ 是标准正态分布的分位数。\n\n任务。实现一个完整的、自包含的程序来：\n- 通过对 $N + \\alpha$ 进行行归一化来构建后验均值转移矩阵。\n- 计算以步数为单位的 $\\tau_{A \\to B}(T)$，并使用 $\\tau_{\\mathrm{lag}}$ 将其转换为秒。\n- 通过求解 $M^\\top s_A$ 和 $t_R$，利用上述线性响应公式计算梯度。\n- 组装逐行的狄利克雷协方差矩阵，并计算 $\\tau_{A \\to B}$ 的 delta 方法方差。\n- 返回可信度水平为 $0.95$（即使用 $z_{0.975}$）的双边可信区间（以秒为单位），不进行四舍五入。\n\n使用以下测试套件。对于每种情况，以列表 $[\\text{lower}, \\text{upper}]$ 的形式输出从 $A$ 到 $B$ 的 MFPT 区间（以秒为单位）：\n- 案例 1 (正常路径): \n  - $N = \\begin{bmatrix} 90  10  5 \\\\ 5  85  10 \\\\ 1  2  97 \\end{bmatrix}$,\n  - $\\alpha = 0.5$ 应用于每个条目 (即 $\\alpha_{ij} = 0.5$),\n  - $A = \\{1\\}$, $B = \\{3\\}$, $\\tau_{\\mathrm{lag}} = 1 \\times 10^{-9}$ 秒。\n- 案例 2 (边界情况，从某些状态到 $B$ 的直接计数为零):\n  - $N = \\begin{bmatrix} 50  50  0 \\\\ 0  50  50 \\\\ 0  0  100 \\end{bmatrix}$,\n  - $\\alpha = 0.2$ 应用于每个条目,\n  - $A = \\{1\\}$, $B = \\{3\\}$, $\\tau_{\\mathrm{lag}} = 5 \\times 10^{-10}$ 秒。\n- 案例 3 (近可分解，缓慢逃逸):\n  - $N = \\begin{bmatrix} 495  495  10 \\\\ 495  495  10 \\\\ 5  5  990 \\end{bmatrix}$,\n  - $\\alpha = 0.1$ 应用于每个条目,\n  - $A = \\{1,2\\}$, $B = \\{3\\}$, $\\tau_{\\mathrm{lag}} = 1 \\times 10^{-6}$ 秒。\n\n你的程序应生成单行输出，其中包含以下格式的结果，即一个用方括号括起来的逗号分隔列表：\n`[[lower_1, upper_1],[lower_2, upper_2],[lower_3, upper_3]]`\n所有输出必须以秒（国际单位制单位）为单位，不含任何额外文本。",
            "solution": "该问题是有效的。它提出了一个在计算统计物理领域内适定的、有科学依据的任务，具体涉及从马尔可夫状态模型 (MSM) 推导出的动力学可观测量的不确定性量化。所提供的公式和方法论是标准且正确的，数值输入是完整且物理上合理的。\n\n总体目标是计算从源态集 $A$ 到目标态集 $B$ 的 MFPT 的 $95\\%$ 贝叶斯可信区间。该计算依赖于一阶泰勒展开（delta 方法），将作为随机变量处理的转移矩阵 $T$ 的不确定性，传播到作为 $T$ 的函数的 MFPT 上。$T$ 的后验分布是从转移计数矩阵 $N$ 和狄利克雷先验推导得出的。\n\n该过程通过以下步骤序列执行。\n\n首先，我们建立转移矩阵 $T$ 的后验分布。给定状态 $i$ 和 $j$ 之间观测到的转移计数 $N_{ij}$，以及对每一行 $i$ 使用参数为 $\\alpha_{ij}$ 的共轭狄利克雷先验，转移矩阵第 $i$ 行的后验分布是一个狄利克雷分布。其参数由 $a_{ij} = N_{ij} + \\alpha_{ij}$ 给出。然后，通过对后验参数矩阵 $A = [a_{ij}]$进行行归一化来构建转移矩阵 $T$ 的后验均值。后验均值矩阵的元素为：\n$$\nT_{ij} = \\mathbb{E}[T_{ij}] = \\frac{a_{ij}}{\\sum_{k=1}^n a_{ik}}\n$$\n其中 $n$ 是状态数。\n\n其次，我们使用后验均值转移矩阵 $T$ 计算从源态集 $A$ 到目标态集 $B$ 的 MFPT。我们将瞬态集定义为 $R = \\{1, \\dots, n\\} \\setminus B$。从 $R$ 中的任意状态 $i$ 开始，到达 $B$ 中一个吸收态的期望步数由向量 $t_R$ 给出。该向量是以下线性系统的解：\n$$\n(\\mathbf{I}_{|R|} - T_{RR}) \\, t_R = \\mathbf{1}_{|R|}\n$$\n其中 $T_{RR}$ 是 $T$ 中对应于仅在 $R$ 中状态之间转移的子矩阵，$\\mathbf{I}_{|R|}$ 是大小为 $|R| \\times |R|$ 的单位矩阵，而 $\\mathbf{1}_{|R|}$ 是长度为 $|R|$ 的全一向量。矩阵 $\\mathbf{I}_{|R|} - T_{RR}$ 是可逆的，因为次随机矩阵 $T_{RR}$ 的谱半径严格小于 1（这是最终吸收进 $B$ 的一个条件）。一旦求得 $t_R$，以延迟时间为单位的 MFPT $\\tau_{A \\to B}(T)$，通过对 $t_R$ 中对应于源态 $i \\in A$ 的条目求平均来计算：\n$$\n\\tau_{A \\to B}(T) = \\frac{1}{|A|} \\sum_{i \\in A} (t_R)_{i'}\n$$\n其中 $i'$ 表示状态 $i$ 在集合 $R$ 中的索引。然后通过用延迟时间 $\\tau_{\\mathrm{lag}}$进行缩放得到物理 MFPT $\\tau_{\\mathrm{phys}}$：\n$$\n\\tau_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\cdot \\tau_{A \\to B}(T)\n$$\n\n第三，为了应用 delta 方法，我们计算 MFPT 的梯度 $\\nabla \\tau_{A \\to B}$，这是关于转移矩阵 $T$ 的元素，并在其后验均值处求值的。只有当状态 $k$ 和 $l$ 都在瞬态集 $R$ 中时，关于元素 $T_{kl}$ 的偏导数才非零。该公式由以下给出：\n$$\n\\frac{\\partial \\tau_{A \\to B}}{\\partial T_{kl}} = \\frac{1}{|A|} (M^\\top s_A)_k \\, v_l \\quad \\text{for } k,l \\in R\n$$\n否则为零。这里，$v = t_R$ 是先前计算的通过时间向量。向量 $w = M^\\top s_A$ 是通过求解线性系统 $(\\mathbf{I}_{|R|} - T_{RR})^\\top w = s_A$ 计算得出的，其中 $s_A$ 是 $R$ 上的一个指示向量，如果状态在 $A$ 中，其元素为 1，否则为 0。\n\n第四，我们近似 MFPT 的后验方差 $\\mathrm{Var}[\\tau_{A \\to B}]$。delta 方法提供了以下近似：\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\nabla \\tau_{A \\to B}^\\top \\, \\mathrm{Cov}(T) \\, \\nabla \\tau_{A \\to B}\n$$\n由于在狄利克雷模型下，转移矩阵的行被假设为后验独立的，因此完整的协方差矩阵 $\\mathrm{Cov}(T)$ 在行上是块对角的。总方差简化为对每一行 $i$ 贡献的总和：\n$$\n\\mathrm{Var}[\\tau_{A \\to B}] \\approx \\sum_{i=1}^n (\\nabla_{T_{i*}} \\tau_{A \\to B})^\\top \\, \\mathrm{Cov}(T_{i*}) \\, (\\nabla_{T_{i*}} \\tau_{A \\to B})\n$$\n其中 $\\nabla_{T_{i*}} \\tau_{A \\to B}$ 是对应于 $T$ 的第 $i$ 行的梯度向量，而 $\\mathrm{Cov}(T_{i*})$ 是第 $i$ 行狄利克雷后验的 $n \\times n$ 协方差矩阵。$\\mathrm{Cov}(T_{i*})$ 的元素由狄利克雷分布的标准公式给出：\n$$\n\\mathrm{Var}(T_{ij}) = \\frac{a_{ij}(A_i - a_{ij})}{A_i^2 (A_i + 1)}, \\quad \\mathrm{Cov}(T_{ij}, T_{ik}) = - \\frac{a_{ij} a_{ik}}{A_i^2 (A_i + 1)} \\quad \\text{for } j \\neq k\n$$\n其中 $A_i = \\sum_{j=1}^n a_{ij}$。方差的求和只需对行 $i \\in R$ 执行，因为所有其他行的梯度均为零。\n\n最后，我们为物理 MFPT 构建双边 $(1 - \\gamma)$ 可信区间。假设 $\\tau_{A \\to B}$ 的后验分布近似为正态分布，这对于大计数情况下的中心极限定理和 delta 方法的线性近似是合理的，该区间为：\n$$\n\\left[ \\tau_{\\mathrm{phys}} - z_{1-\\gamma/2} \\, \\sigma_{\\mathrm{phys}}, \\ \\ \\tau_{\\mathrm{phys}} + z_{1-\\gamma/2} \\, \\sigma_{\\mathrm{phys}} \\right]\n$$\n其中 $\\sigma_{\\mathrm{phys}} = \\tau_{\\mathrm{lag}} \\sqrt{\\mathrm{Var}[\\tau_{A \\to B}]}$ 是物理 MFPT 的标准差，$z_{1-\\gamma/2}$ 是标准正态分布的 $(1 - \\gamma/2)$-分位数。对于 $95\\%$ 的可信区间，$\\gamma=0.05$，我们使用 $z_{0.975} \\approx 1.95996$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef calculate_mfpt_interval(N, alpha, A_1based, B_1based, tau_lag):\n    \"\"\"\n    Computes the 95% credible interval for the MFPT from source set A to target set B.\n    \n    Args:\n        N (list of lists): The n x n transition count matrix.\n        alpha (float): The uniform Dirichlet prior parameter.\n        A_1based (set): The set of 1-based source state indices.\n        B_1based (set): The set of 1-based target state indices.\n        tau_lag (float): The lag time of the Markov model in seconds.\n        \n    Returns:\n        list: A list [lower_bound, upper_bound] for the credible interval in seconds.\n    \"\"\"\n    # Step 1: Setup and Index Conversion\n    N_mat = np.array(N, dtype=float)\n    n = N_mat.shape[0]\n    all_states = set(range(n))\n    A_0based = {x - 1 for x in A_1based}\n    B_0based = {x - 1 for x in B_1based}\n    R_0based = all_states - B_0based\n    R_indices = sorted(list(R_0based))\n    num_R = len(R_indices)\n    R_map = {state_idx: i for i, state_idx in enumerate(R_indices)}\n\n    # Step 2: Posterior Mean Transition Matrix\n    alpha_mat = np.full((n, n), alpha, dtype=float)\n    A_post_mat = N_mat + alpha_mat\n    A_sums = A_post_mat.sum(axis=1)\n    T = A_post_mat / A_sums[:, np.newaxis]\n\n    # Step 3: Mean First-Passage Time (MFPT)\n    T_RR = T[np.ix_(R_indices, R_indices)]\n    I_RR = np.eye(num_R)\n    M_matrix = I_RR - T_RR\n    # v = t_R in problem statement, vector of expected steps to absorption from R\n    v = np.linalg.solve(M_matrix, np.ones(num_R))\n\n    A_in_R_indices = [R_map[i] for i in A_0based if i in R_map]\n    tau_steps = np.mean(v[A_in_R_indices])\n    tau_phys = tau_lag * tau_steps\n\n    # Step 4: Gradient Calculation\n    s_A = np.zeros(num_R)\n    if A_in_R_indices:\n        s_A[A_in_R_indices] = 1.0\n    # w = M^T * s_A, solved via linear system\n    w = np.linalg.solve(M_matrix.T, s_A)\n\n    grad_tau = np.zeros((n, n))\n    # grad_tau_RR = (1/|A|) * w * v^T (outer product)\n    grad_tau_RR = (1.0 / len(A_0based)) * np.outer(w, v)\n    grad_tau[np.ix_(R_indices, R_indices)] = grad_tau_RR\n\n    # Step 5: Variance Calculation via Delta Method\n    total_var_tau = 0.0\n    # Sum over rows i in R. Gradient is zero for rows i not in R.\n    for i in R_indices:\n        grad_row_i = grad_tau[i, :]\n        a_i = A_post_mat[i, :]\n        A_i_sum = A_sums[i]\n        \n        # Dirichlet covariance matrix for row i\n        const = 1.0 / (A_i_sum**2 * (A_i_sum + 1.0))\n        diag_part = np.diag(a_i * A_i_sum)\n        outer_part = np.outer(a_i, a_i)\n        Cov_i = const * (diag_part - outer_part)\n\n        row_var = grad_row_i @ Cov_i @ grad_row_i\n        total_var_tau += row_var\n\n    # Step 6: Credible Interval\n    z_val = norm.ppf(0.975)  # for 95% interval\n    std_dev_tau_steps = np.sqrt(total_var_tau)\n    # Uncertainty in physical time\n    uncertainty_phys = z_val * tau_lag * std_dev_tau_steps\n\n    lower_bound = tau_phys - uncertainty_phys\n    upper_bound = tau_phys + uncertainty_phys\n\n    return [lower_bound, upper_bound]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": [[90, 10, 5], [5, 85, 10], [1, 2, 97]],\n            \"alpha\": 0.5,\n            \"A\": {1},\n            \"B\": {3},\n            \"tau_lag\": 1e-9\n        },\n        # Case 2 (edge, zero direct counts to B)\n        {\n            \"N\": [[50, 50, 0], [0, 50, 50], [0, 0, 100]],\n            \"alpha\": 0.2,\n            \"A\": {1},\n            \"B\": {3},\n            \"tau_lag\": 5e-10\n        },\n        # Case 3 (nearly decomposable)\n        {\n            \"N\": [[495, 495, 10], [495, 495, 10], [5, 5, 990]],\n            \"alpha\": 0.1,\n            \"A\": {1, 2},\n            \"B\": {3},\n            \"tau_lag\": 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = calculate_mfpt_interval(\n            case[\"N\"], case[\"alpha\"], case[\"A\"], case[\"B\"], case[\"tau_lag\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}