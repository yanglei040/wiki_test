{
    "hands_on_practices": [
        {
            "introduction": "本章的第一个练习是基础性的。它将指导您为一个简单的线性系统，数值化地实现森-茨瓦齐格(Mori-Zwanzig)投影算符方法。通过实践，您将学习如何构建投影算符和正交动力学演化算符，并运用两种不同但相关的路径计算记忆核函数$K(t)$ ()。这个对比练习不仅能巩固您对理论核心的理解，还能揭示一个在实际应用中至关重要的理论细节。",
            "id": "3438295",
            "problem": "考虑一个微观哈密顿系统，该系统将一个粗粒化的蛋白质折叠坐标模拟为高维谐波环境中的一个线性集体变量。微观位置为 $\\mathbf{x} \\in \\mathbb{R}^N$，速度为 $\\mathbf{v} \\in \\mathbb{R}^N$，质量 $m_i$ 汇集在一个对角质量矩阵 $\\mathbf{M} = \\operatorname{diag}(m_1,\\dots,m_N)$ 中，刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 是对称正定的。势能为 $U(\\mathbf{x}) = \\tfrac{1}{2} \\mathbf{x}^\\top \\mathbf{K} \\mathbf{x}$。解析的集体坐标为 $Q = \\mathbf{c}^\\top \\mathbf{x}$，其中 $\\mathbf{c} \\in \\mathbb{R}^N$ 是一个固定的系数向量。微观动力学遵循牛顿定律：$\\dot{\\mathbf{x}} = \\mathbf{v}$ 和 $\\dot{\\mathbf{v}} = -\\mathbf{M}^{-1} \\mathbf{K} \\mathbf{x}$，并且在温度 $T$ 下的正则系综平衡具有与 $\\exp\\left(-\\beta H(\\mathbf{x},\\mathbf{v})\\right)$ 成正比的玻尔兹曼因子，其中 $H(\\mathbf{x},\\mathbf{v}) = \\tfrac{1}{2}\\mathbf{x}^\\top \\mathbf{K}\\mathbf{x} + \\tfrac{1}{2}\\mathbf{v}^\\top \\mathbf{M}\\mathbf{v}$ 且 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n定义相空间矢量 $\\mathbf{z} = [\\mathbf{x}; \\mathbf{v}] \\in \\mathbb{R}^{2N}$ 和线性系统矩阵\n$$\n\\mathbf{A}_{\\mathrm{sys}} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & \\mathbf{0}\n\\end{bmatrix},\n$$\n使得 $\\dot{\\mathbf{z}} = \\mathbf{A}_{\\mathrm{sys}} \\mathbf{z}$。$\\mathbf{z}$ 的正则协方差为\n$$\n\\boldsymbol{\\Sigma} = \\begin{bmatrix}\nk_{\\mathrm{B}} T\\, \\mathbf{K}^{-1} & \\mathbf{0} \\\\\n\\mathbf{0} & k_{\\mathrm{B}} T\\, \\mathbf{M}^{-1}\n\\end{bmatrix}.\n$$\n考虑线性可观测量 $Q(\\mathbf{z}) = \\mathbf{q}^\\top \\mathbf{z}$ 和 $\\dot{Q}(\\mathbf{z}) = \\mathbf{d}^\\top \\mathbf{z}$，其系数向量为 $\\mathbf{q} = [\\mathbf{c}; \\mathbf{0}]$ 和 $\\mathbf{d} = [\\mathbf{0}; \\mathbf{c}]$。与 $Q$ 共轭的微观广义力为 $F(\\mathbf{z}) = -\\partial U / \\partial Q = -\\mathbf{c}^\\top \\mathbf{K} \\mathbf{x}$，这也是一个线性可观测量，其系数向量为 $\\mathbf{f} = [-\\mathbf{K}\\mathbf{c}; \\mathbf{0}]$。\n\n令 $\\mathcal{V}$ 为由 $Q$ 和 $\\dot{Q}$ 张成的二维线性可观测量子空间。在平衡态下使用正则内积 $\\langle A, B \\rangle = \\mathbb{E}[A B]$，作用于可观测量系数向量的正交投影算子 $\\mathbf{P}$ 是到 $\\mathbf{q}$ 和 $\\mathbf{d}$ 所张成空间的 $\\boldsymbol{\\Sigma}$-加权投影算子：\n$$\n\\mathbf{P} = \\mathbf{V}\\left(\\mathbf{V}^\\top \\boldsymbol{\\Sigma} \\mathbf{V}\\right)^{-1}\\mathbf{V}^\\top \\boldsymbol{\\Sigma}, \\quad \\text{其中 } \\mathbf{V} = [\\mathbf{q}, \\mathbf{d}] \\in \\mathbb{R}^{2N \\times 2}.\n$$\n力的垂直分量为 $\\mathbf{f}_\\perp = (\\mathbf{I} - \\mathbf{P}) \\mathbf{f}$。\n\n实现一个程序，对每个给定的测试用例执行以下任务：\n\n1. 将 $\\mathbf{K}$ 构建为一个对角刚度与一个最近邻链式拉普拉斯算子之和，以确保矩阵是对称正定的。具体来说，令链式拉普拉斯算子为一个 $N \\times N$ 的三对角矩阵，其对角线元素为 $2$（端点处为 $1$），紧邻的次对角线元素为 $-1$。令 $\\mathbf{K} = k_{\\mathrm{main}} \\mathbf{I} + k_{\\mathrm{couple}} \\mathbf{L}_{\\mathrm{chain}}$，其中 $k_{\\mathrm{main}}$ 和 $k_{\\mathrm{couple}}$ 是给定的标量。所有刚度值必须以牛顿/米 ($\\mathrm{N}/\\mathrm{m}$) 表示。\n\n2. 按上述规定构建 $\\mathbf{M}$、$\\mathbf{A}_{\\mathrm{sys}}$、$\\boldsymbol{\\Sigma}$、$\\mathbf{P}$ 和 $\\mathbf{f}_\\perp$。所有质量必须以千克 ($\\mathrm{kg}$) 表示，温度以开尔文 ($\\mathrm{K}$) 表示，时间以秒 ($\\mathrm{s}$) 表示。\n\n3. 正交动力学路径：使用作用于可观测量（作为系数上的线性算子）的正交动力学生成元来演化垂直力系数，即使用矩阵 $\\mathbf{G}_{\\mathrm{OD}} = (\\mathbf{I} - \\mathbf{P}) \\mathbf{A}_{\\mathrm{sys}}^\\top$。对于时间 $t$，演化后的系数为 $\\mathbf{a}_{\\mathrm{OD}}(t) = \\exp\\left(\\mathbf{G}_{\\mathrm{OD}} t\\right)\\mathbf{f}_\\perp$。根据这些系数，使用与 $\\boldsymbol{\\Sigma}$ 的正则内积并按 $\\beta$ 缩放，计算记忆核的时间序列 $K_{\\mathrm{OD}}(t)$。将 $K_{\\mathrm{OD}}(t)$ 以 $\\mathrm{N}/\\mathrm{m}$ 表示。\n\n4. 力自相关估计路径：使用 $\\mathbf{G}_{\\mathrm{full}} = \\mathbf{A}_{\\mathrm{sys}}^\\top$ 在完整动力学下演化微观力系数，即 $\\mathbf{a}_{\\mathrm{full}}(t) = \\exp\\left(\\mathbf{G}_{\\mathrm{full}} t\\right)\\mathbf{f}$。将演化后的系数投影到垂直子空间，得到 $\\mathbf{a}_{\\mathrm{FAC}}(t) = (\\mathbf{I} - \\mathbf{P}) \\mathbf{a}_{\\mathrm{full}}(t)$。根据这些系数，使用与 $\\boldsymbol{\\Sigma}$ 的正则内积并按 $\\beta$ 缩放，计算时间序列 $K_{\\mathrm{FAC}}(t)$（以 $\\mathrm{N}/\\mathrm{m}$ 为单位）。\n\n5. 在一个均匀时间网格 $t \\in [0, t_{\\max}]$（有 $N_t$ 个点）上，计算网格上的最大绝对差：\n$$\n\\Delta = \\max_{t \\in \\{t_k\\}} \\left| K_{\\mathrm{OD}}(t) - K_{\\mathrm{FAC}}(t) \\right|.\n$$\n以浮点数形式返回 $\\Delta$（单位为 $\\mathrm{N}/\\mathrm{m}$）。\n\n你的程序必须为以下测试套件实现上述功能，并生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，结果顺序与测试顺序一致，例如 $[r_1,r_2,r_3]$：\n\n- 测试用例 1 (理想路径):\n  - $N = 4$\n  - 质量 $\\mathbf{m} = [2.0 \\times 10^{-26}, 3.0 \\times 10^{-26}, 2.5 \\times 10^{-26}, 2.2 \\times 10^{-26}]$ in $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 5.0$ in $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 2.0$ in $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$ in $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c}$ 为均匀权重：$c_i = 1/N$ for $i = 1,\\dots,N$\n  - 时间网格: $t_{\\max} = 5.0 \\times 10^{-12}$ in $\\mathrm{s}$, $N_t = 51$\n\n- 测试用例 2 ($Q$ 与一个坐标轴的边界对齐):\n  - $N = 3$\n  - 质量 $\\mathbf{m} = [2.0 \\times 10^{-26}, 2.0 \\times 10^{-26}, 2.0 \\times 10^{-26}]$ in $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 10.0$ in $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 0.5$ in $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$ in $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c} = [1.0, 0.0, 0.0]$\n  - 时间网格: $t_{\\max} = 5.0 \\times 10^{-12}$ in $\\mathrm{s}$, $N_t = 51$\n\n- 测试用例 3 (强耦合和非均匀质量的边缘情况):\n  - $N = 5$\n  - 质量 $\\mathbf{m} = [1.5 \\times 10^{-26}, 2.0 \\times 10^{-26}, 2.5 \\times 10^{-26}, 2.8 \\times 10^{-26}, 3.0 \\times 10^{-26}]$ in $\\mathrm{kg}$\n  - $k_{\\mathrm{main}} = 8.0$ in $\\mathrm{N}/\\mathrm{m}$\n  - $k_{\\mathrm{couple}} = 6.0$ in $\\mathrm{N}/\\mathrm{m}$\n  - 温度 $T = 300.0$ in $\\mathrm{K}$\n  - 集体坐标系数 $\\mathbf{c}$ 符号交替：$c_i = (-1)^{i-1} / \\sqrt{N}$ for $i = 1,\\dots,N$\n  - 时间网格: $t_{\\max} = 5.0 \\times 10^{-12}$ in $\\mathrm{s}$, $N_t = 51$\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表 (例如, $[r_1,r_2,r_3]$)，其中每个 $r_i$ 是相应测试用例的最大绝对差 $\\Delta$，以 $\\mathrm{N}/\\mathrm{m}$ 表示。",
            "solution": "提交审议的问题陈述是有效的。它在统计力学和分子动力学领域内提出了一个适定且具有科学依据的问题，特别关注了针对线性系统的 Mori-Zwanzig 投影算子形式体系的数值实现。该问题要求比较计算记忆核的两种路径，这是一项不平凡的任务，它探究了投影方法应用中的一个关键细微之处。所有参数和定义都已提供，确保了问题是自包含的，并允许一个唯一的、可验证的解决方案。因此，我们可以着手给出一个完整且合理的解决方案。\n\n问题的核心在于计算广义朗之万方程中粗粒化变量 $Q$ 的记忆核 $K(t)$。该核定义为“随机”或“正交”力的时间自相关，此力是微观力在正交于解析变量的子空间中演化的分量。对于线性系统，这种形式体系可以转化为对线性可观测量系数向量的矩阵代数。我们将构建必要的矩阵，实现指定的两种动力学演化方案，并计算所得记忆核之间的差异。\n\n**1. 系统和相空间矩阵构建**\n该系统由 $N$ 个粒子处于谐波势中组成。我们首先构建位形空间中的基本矩阵。\n- 质量矩阵 $\\mathbf{M} \\in \\mathbb{R}^{N \\times N}$ 是给定粒子质量的对角矩阵，$\\mathbf{M} = \\operatorname{diag}(m_1, \\dots, m_N)$。\n- 刚度矩阵 $\\mathbf{K} \\in \\mathbb{R}^{N \\times N}$ 由 $\\mathbf{K} = k_{\\mathrm{main}} \\mathbf{I} + k_{\\mathrm{couple}} \\mathbf{L}_{\\mathrm{chain}}$ 给出。链式拉普拉斯矩阵 $\\mathbf{L}_{\\mathrm{chain}}$ 是一个对称半正定矩阵。由于 $k_{\\mathrm{main}} > 0$ 且 $k_{\\mathrm{couple}} \\ge 0$，所得矩阵 $\\mathbf{K}$ 是对称且严格正定的，这保证了其逆矩阵 $\\mathbf{K}^{-1}$ 存在。\n\n动力学在一个 $2N$ 维相空间中表述，状态向量为 $\\mathbf{z} = [\\mathbf{x}; \\mathbf{v}]$。时间演化由线性常微分方程组 $\\dot{\\mathbf{z}} = \\mathbf{A}_{\\mathrm{sys}} \\mathbf{z}$ 控制，其中系统矩阵 $\\mathbf{A}_{\\mathrm{sys}} \\in \\mathbb{R}^{2N \\times 2N}$ 定义为：\n$$\n\\mathbf{A}_{\\mathrm{sys}} = \\begin{bmatrix}\n\\mathbf{0} & \\mathbf{I} \\\\\n-\\mathbf{M}^{-1}\\mathbf{K} & \\mathbf{0}\n\\end{bmatrix}\n$$\n相空间向量与其自身外积的正则系综平均定义了协方差矩阵 $\\boldsymbol{\\Sigma} = \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top]$。对于此谐波系统，它由以下公式给出：\n$$\n\\boldsymbol{\\Sigma} = \\begin{bmatrix}\nk_{\\mathrm{B}} T\\, \\mathbf{K}^{-1} & \\mathbf{0} \\\\\n\\mathbf{0} & k_{\\mathrm{B}} T\\, \\mathbf{M}^{-1}\n\\end{bmatrix}\n$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。\n\n**2. 投影算子形式体系**\n可观测量的空间被限制在由粗粒化坐标 $Q(\\mathbf{z}) = \\mathbf{q}^\\top \\mathbf{z}$ 及其时间导数 $\\dot{Q}(\\mathbf{z}) = \\mathbf{d}^\\top \\mathbf{z}$ 所张成的二维子空间。相应的系数向量为 $\\mathbf{q} = [\\mathbf{c}; \\mathbf{0}]$ 和 $\\mathbf{d} = [\\mathbf{0}; \\mathbf{c}]$。两个线性可观测量 $A = \\mathbf{a}^\\top\\mathbf{z}$ 和 $B = \\mathbf{b}^\\top\\mathbf{z}$ 之间的正则内积是 $\\langle A, B \\rangle = \\mathbb{E}[AB] = \\mathbf{a}^\\top \\boldsymbol{\\Sigma} \\mathbf{b}$。\n\n将一个可观测量的系数向量投影到由 $\\mathbf{q}$ 和 $\\mathbf{d}$ 所张成的子空间上的投影算子 $\\mathbf{P}$ 定义为：\n$$\n\\mathbf{P} = \\mathbf{V}\\left(\\mathbf{V}^\\top \\boldsymbol{\\Sigma} \\mathbf{V}\\right)^{-1}\\mathbf{V}^\\top \\boldsymbol{\\Sigma}, \\quad \\text{其中 } \\mathbf{V} = [\\mathbf{q}, \\mathbf{d}]\n$$\n这在欧几里得意义上是一个斜投影算子，但它关于 $\\boldsymbol{\\Sigma}$-加权内积是正交的（自伴的），满足 $\\mathbf{a}^\\top \\boldsymbol{\\Sigma} (\\mathbf{P}\\mathbf{b}) = (\\mathbf{P}\\mathbf{a})^\\top \\boldsymbol{\\Sigma} \\mathbf{b}$。互补的正交投影算子是 $\\mathcal{Q}_{\\text{proj}} = \\mathbf{I} - \\mathbf{P}$。\n\n微观广义力 $F = -\\mathbf{c}^\\top \\mathbf{K} \\mathbf{x}$ 对应于系数向量 $\\mathbf{f} = [-\\mathbf{K}\\mathbf{c}; \\mathbf{0}]$。在 Mori-Zwanzig 形式体系中，“随机力”是该力正交于解析子空间的分量。其在时间 $t=0$ 时的系数向量为 $\\mathbf{f}_\\perp = (\\mathbf{I} - \\mathbf{P})\\mathbf{f}$。\n\n**3. 动力学和记忆核计算**\n在海森堡绘景中，一个可观测量系数向量 $\\mathbf{a}$ 的演化由 $\\mathbf{a}(t) = \\exp(\\mathbf{A}_{\\mathrm{sys}}^\\top t) \\mathbf{a}(0)$ 给出。计算记忆核的两种路径在处理动力学的方式上有所不同。记忆核定义为 $K(t) = \\beta \\mathbb{E}[R(t) R(0)]$，其中 $R(t)$ 是时间 $t$ 时的随机力，$\\beta = (k_{\\mathrm{B}}T)^{-1}$。\n\n**路径1：正交动力学 (OD)**\n这是理论上精确的 Mori-Zwanzig 公式。随机力根据投影后的动力学进行演化，该动力学由 $\\mathcal{Q}_{\\text{proj}}\\mathbf{A}_{\\mathrm{sys}}^\\top$ 生成。\n- 演化后的随机力系数：$\\mathbf{a}_{\\mathrm{OD}}(t) = \\exp\\left( (\\mathbf{I} - \\mathbf{P})\\mathbf{A}_{\\mathrm{sys}}^\\top t \\right) \\mathbf{f}_\\perp$。\n- 记忆核：$K_{\\mathrm{OD}}(t) = \\beta \\, \\mathbf{a}_{\\mathrm{OD}}(t)^\\top \\boldsymbol{\\Sigma} \\, \\mathbf{f}_\\perp$。\n\n**路径2：力自相关估计 (FAC)**\n此路径使用另一种公式，通常是一种近似。完整的力在完整动力学下演化，其结果在演化*之后*投影到正交子空间。\n- 演化后的完整力系数：$\\mathbf{a}_{\\mathrm{full}}(t) = \\exp(\\mathbf{A}_{\\mathrm{sys}}^\\top t) \\mathbf{f}$。\n- 投影后的系数：$\\mathbf{a}_{\\mathrm{FAC}}(t) = (\\mathbf{I} - \\mathbf{P}) \\mathbf{a}_{\\mathrm{full}}(t)$。\n- 记忆核：$K_{\\mathrm{FAC}}(t) = \\beta \\, \\mathbf{a}_{\\mathrm{FAC}}(t)^\\top \\boldsymbol{\\Sigma} \\, \\mathbf{f}_\\perp$。\n\n这两种路径在数学上并不等同，因为投影算子 $\\mathbf{P}$ 和动力学生成元 $\\mathbf{A}_{\\mathrm{sys}}^\\top$ 不交换。问题要求在离散时间网格上计算最大绝对差 $\\Delta = \\max_t |K_{\\mathrm{OD}}(t) - K_{\\mathrm{FAC}}(t)|$。\n\n**4. 数值实现纲要**\n对于每个测试用例，算法流程如下：\n1. 根据给定的参数 $N$、$\\mathbf{m}$、$k_{\\mathrm{main}}$、$k_{\\mathrm{couple}}$ 和 $T$ 构建矩阵 $\\mathbf{M}$、$\\mathbf{K}$、$\\mathbf{A}_{\\mathrm{sys}}$ 和 $\\boldsymbol{\\Sigma}$。\n2. 根据向量 $\\mathbf{c}$ 构建系数向量 $\\mathbf{q}$、$\\mathbf{d}$ 和 $\\mathbf{f}$。\n3. 形成投影算子 $\\mathbf{P}$ 和初始随机力向量 $\\mathbf{f}_\\perp$。\n4. 定义动力学生成元 $\\mathbf{G}_{\\mathrm{OD}} = (\\mathbf{I} - \\mathbf{P})\\mathbf{A}_{\\mathrm{sys}}^\\top$ 和 $\\mathbf{G}_{\\mathrm{full}} = \\mathbf{A}_{\\mathrm{sys}}^\\top$。\n5. 遍历时间网格点 $t_k \\in [0, t_{\\max}]$。在每次迭代中：\n   a. 使用稳健的数值算法（`scipy.linalg.expm`）计算矩阵指数 $\\exp(\\mathbf{G}_{\\mathrm{OD}} t_k)$ 和 $\\exp(\\mathbf{G}_{\\mathrm{full}} t_k)$。\n   b. 计算 $\\mathbf{a}_{\\mathrm{OD}}(t_k)$ 和 $\\mathbf{a}_{\\mathrm{FAC}}(t_k)$。\n   c. 计算核函数值 $K_{\\mathrm{OD}}(t_k)$ 和 $K_{\\mathrm{FAC}}(t_k)$。\n6. 确定两个计算出的核函数时间序列之间的最大绝对差。该值 $\\Delta$ 即为该测试用例的结果。\n所有计算均使用浮点算术，并采用标准国际单位制（SI）中的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"N\": 4,\n            \"m_vals\": np.array([2.0e-26, 3.0e-26, 2.5e-26, 2.2e-26]),\n            \"k_main\": 5.0,\n            \"k_couple\": 2.0,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: np.ones(N) / N,\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n        {\n            \"N\": 3,\n            \"m_vals\": np.array([2.0e-26, 2.0e-26, 2.0e-26]),\n            \"k_main\": 10.0,\n            \"k_couple\": 0.5,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: np.array([1.0] + [0.0] * (N - 1)),\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n        {\n            \"N\": 5,\n            \"m_vals\": np.array([1.5e-26, 2.0e-26, 2.5e-26, 2.8e-26, 3.0e-26]),\n            \"k_main\": 8.0,\n            \"k_couple\": 6.0,\n            \"T\": 300.0,\n            \"c_rule\": lambda N: ((-1.0) ** np.arange(N)) / np.sqrt(N),\n            \"t_max\": 5.0e-12,\n            \"N_t\": 51,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        delta = calculate_delta(\n            case[\"N\"],\n            case[\"m_vals\"],\n            case[\"k_main\"],\n            case[\"k_couple\"],\n            case[\"T\"],\n            case[\"c_rule\"],\n            case[\"t_max\"],\n            case[\"N_t\"],\n            k_B,\n        )\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_delta(N, m_vals, k_main, k_couple, T, c_rule, t_max, N_t, k_B):\n    \"\"\"\n    Calculates the maximum absolute difference Delta for a single test case.\n    \"\"\"\n    # 1. Construct Basic and Phase-Space Matrices\n    # Mass matrix M and its inverse\n    M = np.diag(m_vals)\n    M_inv = np.diag(1.0 / m_vals)\n\n    # Stiffness matrix K\n    L_chain = (\n        np.diag(np.full(N, 2.0))\n        - np.diag(np.ones(N - 1), k=1)\n        - np.diag(np.ones(N - 1), k=-1)\n    )\n    if N > 0:\n        L_chain[0, 0] = 1.0\n    if N > 1:\n        L_chain[N - 1, N - 1] = 1.0\n    \n    K = k_main * np.identity(N) + k_couple * L_chain\n    K_inv = np.linalg.inv(K)\n\n    # Phase-space matrices A_sys and Sigma\n    dim = 2 * N\n    A_sys = np.zeros((dim, dim))\n    A_sys[:N, N:] = np.identity(N)\n    A_sys[N:, :N] = -M_inv @ K\n\n    Sigma = np.zeros((dim, dim))\n    Sigma[:N, :N] = k_B * T * K_inv\n    Sigma[N:, N:] = k_B * T * M_inv\n\n    # 2. Construct Vectors and Projector\n    c_vec = c_rule(N)\n    q = np.concatenate([c_vec, np.zeros(N)])\n    d = np.concatenate([np.zeros(N), c_vec])\n    f = np.concatenate([-K @ c_vec, np.zeros(N)])\n\n    V = np.vstack([q, d]).T  # Shape (2N, 2)\n    \n    # Gram matrix for projection\n    G_mat = V.T @ Sigma @ V\n    G_inv = np.linalg.inv(G_mat)\n\n    # Projection operator P\n    P = V @ G_inv @ V.T @ Sigma\n    Q_proj = np.identity(dim) - P\n\n    # Perpendicular force vector f_perp\n    f_perp = Q_proj @ f\n\n    # 3. Time Evolution and Kernel Calculation\n    t_grid = np.linspace(0, t_max, N_t)\n    beta = 1.0 / (k_B * T)\n\n    K_OD = np.zeros(N_t)\n    K_FAC = np.zeros(N_t)\n\n    G_full = A_sys.T\n    G_OD = Q_proj @ A_sys.T\n    \n    for i, t in enumerate(t_grid):\n        # Orthogonal Dynamics (OD) Route\n        exp_G_OD_t = linalg.expm(G_OD * t)\n        a_OD_t = exp_G_OD_t @ f_perp\n        K_OD[i] = beta * (a_OD_t.T @ Sigma @ f_perp)\n\n        # Force-Autocorrelation (FAC) Route\n        exp_G_full_t = linalg.expm(G_full * t)\n        a_full_t = exp_G_full_t @ f\n        a_FAC_t = Q_proj @ a_full_t\n        K_FAC[i] = beta * (a_FAC_t.T @ Sigma @ f_perp)\n\n    # 4. Calculate Final Difference\n    delta = np.max(np.abs(K_OD - K_FAC))\n    return delta\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本的实现技巧后，这个练习将引导您探索粗粒化建模中的一个关键问题：如何选择反应坐标。一个“好”的粗粒化变量能够最大程度地捕捉系统的慢自由度，从而简化记忆效应和随机力。通过为不同的粗粒化变量计算并比较其记忆核函数和残余噪音，您将定量地理解这个选择如何影响最终投影模型的“质量”和复杂性 ()。",
            "id": "3438303",
            "problem": "考虑一个状态向量 $x(t) \\in \\mathbb{R}^n$ 的确定性线性微观动力学，其由常微分方程 $ \\dot{x}(t) = A x(t) $ 控制，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个常数矩阵。假设初始条件的平衡系综是均值为零、协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 的高斯分布，该协方差矩阵是对称正定的。对于一个定义为 $ \\xi(x) = c^\\top x $（其中 $c \\in \\mathbb{R}^n$）的标量粗粒化可观测量（反应坐标），考虑在平衡分布下关于内积 $(u,v) = \\mathbb{E}[u v]$ 的一维 Mori-Zwanzig (MZ) 投影。使用 Mori-Zwanzig 形式体系以及到 $\\xi$ 的生成空间上的协方差加权正交投影，$\\xi(t)$ 的投影动力学可以表示为一个带有记忆核 $K(t)$ 和残余（随机）力 $R(t)$ 的广义朗之万方程 (GLE)。\n\n从确定性微观定律 $ \\dot{x} = A x $ 出发，作用于线性可观测量的刘维尔算符为 $ i \\mathcal{L} \\xi = c^\\top A x = d^\\top x $，其中 $ d = A^\\top c $。令到 $\\operatorname{span}(\\xi)$ 上的投影算符为 $ \\mathcal{P} b = \\frac{(b,\\xi)}{(\\xi,\\xi)} \\xi $。对于线性可观测量 $ b(x) = u^\\top x $（其中 $ u \\in \\mathbb{R}^n $），这会引导出系数空间投影 $ P u = c \\frac{u^\\top \\Sigma c}{c^\\top \\Sigma c} $，以及相应的正交投影算符 $ Q = I - P $。定义初始残余力系数 $ g = d - \\alpha c $，其中 $ \\alpha = \\frac{d^\\top \\Sigma c}{c^\\top \\Sigma c} $。系数的正交动力学演化遵循 $ u(t) = e^{t Q A^\\top} u(0) $。因此，残余力为 $ R(t) = u(t)^\\top x(t_0) $，其中 $ u(0) = g $，其在时间 $t$ 的平衡均方值为 $ \\mathbb{E}[R(t)^2] = u(t)^\\top \\Sigma u(t) $。标量投影动力学的记忆核为\n$$\nK(t) = \\frac{(R(0), R(t))}{(\\xi,\\xi)} = \\frac{g^\\top \\Sigma \\, e^{t Q A^\\top} g}{c^\\top \\Sigma c}.\n$$\n\n你的任务是实现一个程序，针对每个指定的测试用例，计算与两个不同反应坐标 $\\xi_1(x) = c_1^\\top x$ 和 $\\xi_2(x) = c_2^\\top x$ 相对应的记忆核 $K_1(t)$ 和 $K_2(t)$，并评估哪个坐标能产生更小的时间平均、协方差归一化的残余噪声\n$$\n\\langle R_j^2 \\rangle_T = \\frac{1}{T} \\int_0^T \\frac{u_j(t)^\\top \\Sigma \\, u_j(t)}{c_j^\\top \\Sigma c_j} \\, dt, \\quad j \\in \\{1,2\\},\n$$\n其中 $u_j(t) = e^{t Q_j A^\\top} g_j$，$g_j = d_j - \\alpha_j c_j$， $d_j = A^\\top c_j$， $\\alpha_j = \\frac{d_j^\\top \\Sigma c_j}{c_j^\\top \\Sigma c_j}$，以及 $Q_j = I - c_j \\frac{(\\Sigma c_j)^\\top}{c_j^\\top \\Sigma c_j}$。对于数值实现，使用矩阵指数 $e^{t Q_j A^\\top}$，通过对 $[0,T]$ 上的 $N$ 个时间点进行均匀平均来近似该积分。\n\n所有量都是无量纲的（没有物理单位）。使用以下测试套件，其中每个用例指定 $(A,\\Sigma,c_1,c_2,T,N)$：\n\n- 测试用例 1 (二维慢快耦合；混合的第二坐标):\n$$\nA = \\begin{bmatrix}\n-0.10 & 1.00 \\\\\n-4.00 & -1.00\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}, \\quad\nT = 5.0, \\quad N = 200.\n$$\n\n- 测试用例 2 (坐标相同；预计平局):\n$$\nA = \\begin{bmatrix}\n-0.10 & 1.00 \\\\\n-4.00 & -1.00\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nT = 5.0, \\quad N = 200.\n$$\n\n- 测试用例 3 (二维，第二坐标为强快变量):\n$$\nA = \\begin{bmatrix}\n-0.05 & 10.0 \\\\\n-0.10 & -2.0\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n1.0 & 0.0 \\\\\n0.0 & 1.0\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}, \\quad\nT = 4.0, \\quad N = 200.\n$$\n\n- 测试用例 4 (三维，具有非平凡协方差):\n$$\nA = \\begin{bmatrix}\n-0.20 & 0.80 & 0.00 \\\\\n-1.00 & -0.50 & 2.00 \\\\\n0.00 & -1.50 & -0.30\n\\end{bmatrix}, \\quad\n\\Sigma = \\begin{bmatrix}\n2.0 & 0.0 & 0.0 \\\\\n0.0 & 1.0 & 0.0 \\\\\n0.0 & 0.0 & 0.5\n\\end{bmatrix}, \\quad\nc_1 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}, \\quad\nc_2 = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.7 \\end{bmatrix}, \\quad\nT = 6.0, \\quad N = 300.\n$$\n\n对每个测试用例，在指定的时间网格上计算 $K_1(t)$ 和 $K_2(t)$，然后使用 $N$ 个点的算术平均值计算 $\\langle R_1^2 \\rangle_T$ 和 $\\langle R_2^2 \\rangle_T$。决定哪个坐标使归一化残余噪声最小化。如果两个平均值在 $10^{-12}$ 的数值容差内相等，则选择第一个坐标。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试用例所选坐标的索引，形式为方括号内以逗号分隔的列表（例如 $[1,2,1,2]$）。",
            "solution": "用户希望基于 Mori-Zwanzig 形式体系解决一个关于投影动力学的问题。\n\n### 第 1 步：提取已知条件\n问题为线性动力系统 $\\dot{x}(t) = A x(t)$ 提供了以下数据和定义：\n-   状态向量：$x(t) \\in \\mathbb{R}^n$\n-   动力学矩阵：$A \\in \\mathbb{R}^{n \\times n}$\n-   平衡分布：均值为零、协方差为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$ 的高斯分布，对称正定。\n-   标量可观测量（反应坐标）：$\\xi(x) = c^\\top x$，其中向量 $c \\in \\mathbb{R}^n$。\n-   内积：$(u,v) = \\mathbb{E}[u v]$。对于线性可观测量 $u=u^\\top x$ 和 $v=v^\\top x$，此内积为 $(u,v) = u^\\top \\Sigma v$。\n-   作用于线性可观测量的刘维尔算符：$i \\mathcal{L} \\xi = c^\\top A x = d^\\top x$，其中 $d = A^\\top c$。\n-   系数上的投影算符：$P u = c \\frac{u^\\top \\Sigma c}{c^\\top \\Sigma c}$。\n-   正交投影算符：$Q = I - P$。问题给出了矩阵形式 $Q_j = I - c_j \\frac{(\\Sigma c_j)^\\top}{c_j^\\top \\Sigma c_j}$。\n-   初始残余力系数：$g = d - \\alpha c$，其中 $\\alpha = \\frac{d^\\top \\Sigma c}{c^\\top \\Sigma c}$。\n-   系数的正交动力学：$u(t) = e^{t Q A^\\top} u(0)$。对于残余力，$u(0) = g$。\n-   时间平均、协方差归一化的残余噪声：$\\langle R_j^2 \\rangle_T = \\frac{1}{T} \\int_0^T \\frac{u_j(t)^\\top \\Sigma \\, u_j(t)}{c_j^\\top \\Sigma c_j} \\, dt$，其中坐标 $j \\in \\{1,2\\}$。\n-   数值近似：积分通过在区间 $[0,T]$ 上的 $N$ 个均匀间隔的时间点上取算术平均值来近似。\n-   决策规则：对于每个测试用例，选择使 $\\langle R_j^2 \\rangle_T$ 最小化的坐标 $j$。如果两个值在 $10^{-12}$ 的容差范围内相等，则选择坐标 1。\n-   测试用例：提供了四个测试用例，每个都指定了元组 $(A, \\Sigma, c_1, c_2, T, N)$。\n\n### 第 2 步：使用提取的已知条件进行验证\n这个问题在科学上基于已建立的 Mori-Zwanzig 投影动力学理论，这是统计力学中的一个标准课题。将其应用于具有高斯统计的线性系统是一种常见且易于理解的模型。所有关于投影算符、传播算符和派生量的数学定义都是标准的且自洽的。\n\n这个问题是适定的。每个用例的所有必要输入（$A, \\Sigma, c_1, c_2, T, N$）都已提供。这些定义导出了一个唯一的计算过程。使用对称正定协方差矩阵 $\\Sigma$ 确保了对于任何非零向量 $c$，分母如 $c^\\top \\Sigma c$ 都不为零，从而避免了除以零的情况。目标清晰明确：计算并比较两个值，并根据精确的规则做出决策。语言是客观和正式的。没有矛盾、信息缺失或伪科学主张。这是一个非平凡但可解的数值任务。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 算法解决方案\n问题的核心是为两个反应坐标 $\\xi_1(x) = c_1^\\top x$ 和 $\\xi_2(x) = c_2^\\top x$ 计算时间平均的归一化残余噪声 $\\langle R_j^2 \\rangle_T$。对于对应于索引 $j$ 的每个坐标 $c_j$，其过程如下：\n\n1.  **计算初步量**：\n    给定矩阵 $A$ 和 $\\Sigma$，以及向量 $c_j$：\n    -   计算可观测量时间导数的系数向量：$d_j = A^\\top c_j$。\n    -   计算归一化常数，即该可观测量 $\\xi_j$ 的方差：$\\text{var}(\\xi_j) = (\\xi_j, \\xi_j) = c_j^\\top \\Sigma c_j$。\n    -   计算频率因子 $\\alpha_j = \\frac{(i\\mathcal{L}\\xi_j, \\xi_j)}{(\\xi_j, \\xi_j)} = \\frac{d_j^\\top \\Sigma c_j}{c_j^\\top \\Sigma c_j}$。\n    -   计算正交力的初始系数：$g_j = d_j - \\alpha_j c_j$。该向量相对于 $\\Sigma$ 加权内积与 $c_j$ 正交，即 $g_j^\\top \\Sigma c_j = 0$。\n\n2.  **定义正交动力学**：\n    -   构建投影矩阵 $P_j$，它将系数向量投影到 $c_j$ 的方向上。其矩阵形式为 $P_j = \\frac{c_j c_j^\\top \\Sigma}{c_j^\\top \\Sigma c_j}$。\n    -   正交投影算符为 $Q_j = I - P_j$。\n    -   系数的正交动力学生成元是矩阵 $M_j = Q_j A^\\top$。\n\n3.  **计算时间平均噪声**：\n    -   在区间 $[0, T]$ 上定义一个包含 $N$ 个点的均匀时间网格：$t_k = k \\frac{T}{N-1}$，其中 $k=0, 1, \\dots, N-1$。\n    -   对于网格上的每个时间点 $t_k$，计算正交系数的演化：$u_j(t_k) = e^{t_k M_j} g_j$。矩阵指数 $e^{t_k M_j}$ 进行数值计算。\n    -   在每个时间点 $t_k$，计算归一化残余噪声平方的瞬时值：$f_j(t_k) = \\frac{u_j(t_k)^\\top \\Sigma \\, u_j(t_k)}{c_j^\\top \\Sigma c_j}$。\n    -   时间平均值 $\\langle R_j^2 \\rangle_T$ 通过这些值在 $N$ 个点上的算术平均值来近似：$S_j = \\frac{1}{N} \\sum_{k=0}^{N-1} f_j(t_k)$。\n\n4.  **比较与决策**：\n    -   对计算出的两个平均值 $S_1$ 和 $S_2$ 进行比较。\n    -   根据指定规则，如果 $S_1 - S_2 \\le 10^{-12}$，则选择索引为 1 的坐标。此条件在 $S_1$ 显著小于 $S_2$ 或 $S_1$ 和 $S_2$ 在给定容差内相等时满足。否则，选择坐标 2。\n\n此过程应用于每个测试用例，以确定最优坐标。最终输出是所选索引的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef calculate_average_noise(A, Sigma, c, T, N):\n    \"\"\"\n    Calculates the time-averaged, covariance-normalized residual noise for a given reaction coordinate.\n\n    Args:\n        A (np.ndarray): The dynamics matrix.\n        Sigma (np.ndarray): The covariance matrix of the equilibrium distribution.\n        c (np.ndarray): The coefficient vector defining the reaction coordinate.\n        T (float): The total integration time.\n        N (int): The number of time points for the numerical average.\n\n    Returns:\n        float: The calculated average residual noise.\n    \"\"\"\n    n = A.shape[0]\n    Id = np.identity(n)\n    At = A.T\n\n    # 1. Compute preliminary quantities\n    d = At @ c\n    denom = c.T @ Sigma @ c\n    \n    # Handle the trivial case where c is the zero vector, though not expected from problem spec.\n    if np.isclose(denom, 0):\n        return np.inf\n\n    num_alpha = d.T @ Sigma @ c\n    alpha = num_alpha / denom\n    g = d - alpha * c\n\n    # 2. Define the orthogonal dynamics\n    # The problem specifies Q_j = I - c_j * (Sigma c_j)^T / (c_j^T Sigma c_j).\n    # Since Sigma is symmetric, (Sigma c_j)^T = c_j^T Sigma.\n    # The projection matrix P_j is c_j * (c_j^T Sigma) / (c_j^T Sigma c_j).\n    # In numpy, this is np.outer(c_j, c_j @ Sigma) / denom.\n    P = np.outer(c, c @ Sigma) / denom\n    Q = Id - P\n    \n    M = Q @ At\n\n    # 3. Compute the time-averaged noise\n    time_points = np.linspace(0.0, T, N)\n    integrand_values = []\n\n    for t in time_points:\n        # Evolve the orthogonal coefficient\n        # u(t) = exp(t * M) @ g\n        exp_tM = expm(t * M)\n        u_t = exp_tM @ g\n\n        # Calculate the instantaneous normalized squared residual noise\n        # (u(t)^T * Sigma * u(t)) / (c^T * Sigma * c)\n        numerator = u_t.T @ Sigma @ u_t\n        integrand_value = numerator / denom\n        integrand_values.append(integrand_value)\n\n    # Approximate the integral by the arithmetic mean\n    avg_noise = np.mean(integrand_values)\n    \n    return avg_noise\n\ndef solve():\n    \"\"\"\n    Solves the Mori-Zwanzig problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (\n            np.array([[-0.10, 1.00], [-4.00, -1.00]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([1.0, 0.5]),\n            5.0,\n            200\n        ),\n        # Test case 2\n        (\n            np.array([[-0.10, 1.00], [-4.00, -1.00]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([1.0, 0.0]),\n            5.0,\n            200\n        ),\n        # Test case 3\n        (\n            np.array([[-0.05, 10.0], [-0.10, -2.0]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n            np.array([1.0, 0.0]),\n            np.array([0.0, 1.0]),\n            4.0,\n            200\n        ),\n        # Test case 4\n        (\n            np.array([[-0.20, 0.80, 0.00], [-1.00, -0.50, 2.00], [0.00, -1.50, -0.30]]),\n            np.array([[2.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.5]]),\n            np.array([1.0, 0.2, 0.0]),\n            np.array([0.5, 0.5, 0.7]),\n            6.0,\n            300\n        )\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for A, Sigma, c1, c2, T, N in test_cases:\n        avg_noise_1 = calculate_average_noise(A, Sigma, c1, T, N)\n        avg_noise_2 = calculate_average_noise(A, Sigma, c2, T, N)\n        \n        # Decision rule: choose 1 if S1 is smaller or if they are equal within tolerance.\n        if avg_noise_1 - avg_noise_2 = tolerance:\n            results.append(1)\n        else:\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本章的最后一个练习将理论与现代数据分析技术相结合，解决一个核心的实际问题：如何从模拟数据中确定记忆核函数。您将从第一性原理出发，推导出一个基于卷积结构的线性回归模型，并实现一个稀疏回归算法来从给定的分子动力学轨迹中估计核函数参数 ()。这项练习所涉及的技术，正处于构建预测性粗粒化模型研究的前沿。",
            "id": "3438307",
            "problem": "考虑一个高维生物分子系统中的单个分辨坐标 $q(t)$，该系统由Mori-Zwanzig投影形式描述，它为投影动力学导出了一个广义朗之万方程（GLE）。在此描述中，与未分辨自由度相关的摩擦记忆力由记忆核与分辨速度的卷积表示。在实际计算中，对记忆核的一个常用参数化近似是将其表示为基函数的稀疏组合。您的任务是从第一性原理出发，为此类核的系数推导一个离散估计器，并实现一个稀疏回归程序，从合成数据中恢复这些系数。\n\n出发点和物理背景：\n- 假设一个分辨坐标 $q(t)$ 的一维GLE，其记忆力 $F_{\\text{mem}}(t)$ 通过因果卷积依赖于分辨速度 $\\dot{q}(t)$ 的历史。\n- 设记忆核近似为因果基函数的加权和。将这些基函数表示为 $\\{\\phi_i(t)\\}_{i=1}^p$，其中每个 $\\phi_i(t)$ 在 $t0$ 时为零，而核近似是这些基函数与未知系数 $\\{c_i\\}$ 的线性组合。\n- 时间 $t$ 以皮秒（ps）表示，坐标 $q(t)$ 以纳米（nm）表示，速度 $\\dot{q}(t)$ 以 $\\text{nm}/\\text{ps}$ 表示，记忆力 $F_{\\text{mem}}(t)$ 以皮牛（pN）表示。如果涉及物理量，您的程序所请求的任何输出都必须符合这些单位。在此任务中，最终输出是无量纲的布尔值，因此输出无需单位转换。\n\n推导要求：\n- 从Mori-Zwanzig形式所蕴含的因果结构和记忆力的卷积性质出发，推导一个离散时间表示，该表示将 $F_{\\text{mem}}(t)$ 的采样值表示为未知系数 $\\{c_i\\}$ 和经过时间采样、基函数滤波的速度的线性函数。使用黎曼和近似将时间积分转换为步长为 $\\Delta t$ 的均匀网格上的离散求和。\n- 展示这如何导出一个适合回归的线性系统，其中设计矩阵编码了每个基函数 $\\phi_i(t)$ 与采样速度 $\\dot{q}(t)$ 的卷积。\n- 基于最小绝对收缩和选择算子（LASSO）构建一个稀疏回归估计器，该估计器最小化一个平衡了数据保真度和系数 $\\{c_i\\}$ 的 $\\ell_1$ 惩罚项的凸目标函数。\n- 提供一个解决LASSO的算法策略，选择一种近端梯度法，如迭代软阈值算法（ISTA），并解释如何使用梯度的Lipschitz常数选择一个稳定的步长。\n\n实现要求：\n- 实现一个程序，该程序：\n  1. 使用具有物理上合理频率和振幅的三角函数，在指定区间内为 $q(t)$ 和 $\\dot{q}(t)$ 生成合成的、确定性的时间序列。\n  2. 构建一组因果基函数 $\\phi_i(t)$，并通过在均匀时间网格上将每个基函数与采样速度进行卷积来构建离散设计矩阵。\n  3. 使用已知的、真实的稀疏系数和设计矩阵合成 $F_{\\text{mem}}(t)$，可选择不加噪声以独立评估估计精度。\n  4. 通过ISTA求解LASSO问题以估计系数，使用由设计矩阵的谱范数决定的步长。\n  5. 使用预测与真实记忆力信号之间的归一化均方根误差来评估重建质量；对于真实信号恒为零的情况，按惯例将误差视为零。报告一个布尔值，指示归一化误差是否低于指定容差。\n\n测试套件规范：\n- 对所有测试用例使用以下共同的确定性轨迹：\n  - 时间网格：$t_n = n \\Delta t$，$n=0,1,\\dots,N-1$，其中 $\\Delta t = 0.01\\,\\text{ps}$，总时长 $T = 20\\,\\text{ps}$，因此 $N = \\lfloor T/\\Delta t \\rfloor + 1$。\n  - 坐标：$q(t) = 0.5\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.05\\,\\text{ps}^{-1}\\, t) + 0.3\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.20\\,\\text{ps}^{-1}\\, t) + 0.2\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.50\\,\\text{ps}^{-1}\\, t)$。\n  - 速度：$\\dot{q}(t)$ 是 $q(t)$ 的时间导数，由上述表达式精确计算得出，单位为 $\\text{nm}/\\text{ps}$。\n- 基函数为因果指数函数，$\\phi_i(t) = e^{-t/\\tau_i}$ 对于 $t \\ge 0$，而对于 $t  0$ 为 0，时间尺度 $\\tau_i$ 以皮秒为单位。\n- 使用黎曼和因子 $\\Delta t$，通过在均匀网格上进行因果离散卷积来构建设计矩阵。\n\n定义四个涵盖不同场景的测试用例：\n1. 一般情况（稀疏、多时间尺度、良好分离）：\n   - 时间尺度：$\\tau = [0.1,\\,0.3,\\,1.0,\\,3.0,\\,7.0]\\,\\text{ps}$。\n   - 真实系数：$c = [0.0,\\,2.0,\\,-1.5,\\,0.0,\\,0.5]$（单位隐含在离散化中，使得 $F_{\\text{mem}}(t)$ 以 $\\text{pN}$ 为单位）。\n   - LASSO参数：$\\lambda = 10^{-4}$。\n   - 成功容差：归一化均方根误差小于 $10^{-3}$。\n2. 边界情况（零核）：\n   - 时间尺度：$\\tau = [1.0,\\,2.0,\\,3.0,\\,4.0]\\,\\text{ps}$。\n   - 真实系数：$c = [0.0,\\,0.0,\\,0.0,\\,0.0]$。\n   - LASSO参数：$\\lambda = 10^{-3}$。\n   - 容差：归一化误差小于 $10^{-8}$。\n3. 边缘情况（高度相关的基函数）：\n   - 时间尺度：$\\tau = [0.50,\\,0.51,\\,5.0]\\,\\text{ps}$。\n   - 真实系数：$c = [1.0,\\,0.0,\\,0.0]$。\n   - LASSO参数：$\\lambda = 10^{-3}$。\n   - 容差：归一化误差小于 $10^{-3}$。\n4. 单基情况：\n   - 时间尺度：$\\tau = [2.0]\\,\\text{ps}$。\n   - 真实系数：$c = [3.0]$。\n   - LASSO参数：$\\lambda = 10^{-4}$。\n   - 容差：归一化误差小于 $10^{-3}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，指示重建是否根据其容差成功（例如，“[True,False,True,True]”）。",
            "solution": "该问题要求推导并实现一种稀疏回归方法，用于估计广义朗之万方程（GLE）中记忆核的系数。验证和后续解答如下。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n- **系统模型：** 由Mori-Zwanzig形式产生的GLE所控制的单个分辨坐标 $q(t)$。\n- **记忆力：** $F_{\\text{mem}}(t)$ 是记忆核 $K(t)$ 和分辨速度 $\\dot{q}(t)$ 的因果卷积。\n- **核近似：** 记忆核被近似为 $p$ 个因果基函数的稀疏线性组合，$K(t) \\approx \\sum_{i=1}^{p} c_i \\phi_i(t)$，其中当 $t  0$ 时 $\\phi_i(t) = 0$。\n- **离散化：** 使用均匀时间网格 $t_n = n \\Delta t$，并通过黎曼和来近似积分。\n- **回归问题：** 使用最小绝对收缩和选择算子（LASSO）估计稀疏系数 $\\{c_i\\}$。\n- **求解器：** 使用迭代软阈值算法（ISTA）。\n- **合成数据：**\n    - 时间网格：$\\Delta t = 0.01\\,\\text{ps}$，总时长 $T = 20\\,\\text{ps}$，$N = \\lfloor T/\\Delta t \\rfloor + 1 = 2001$。\n    - 坐标：$q(t) = 0.5\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.05\\,\\text{ps}^{-1}\\, t) + 0.3\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.20\\,\\text{ps}^{-1}\\, t) + 0.2\\,\\text{nm}\\,\\sin(2\\pi \\cdot 0.50\\,\\text{ps}^{-1}\\, t)$。\n    - 速度 $\\dot{q}(t)$：$q(t)$ 的精确时间导数。\n    - 基函数：对于 $t \\ge 0$，$\\phi_i(t) = e^{-t/\\tau_i}$。\n- **测试用例：** 定义了四个特定的测试用例，它们具有不同的时间尺度集 $\\{\\tau_i\\}$、真实系数 $\\{c_i\\}$、LASSO参数 $\\lambda$ 和误差容差。\n- **评估指标：** 真实记忆力与重建记忆力之间的归一化均方根误差（NRMSE）。根据NRMSE是否低于给定容差报告一个布尔值。对于零真实信号，误差定义为零。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n- **科学基础：** 该问题牢固地植根于统计力学和计算物理的既定原理。Mori-Zwanzig形式、GLE、记忆核的概念及其使用基函数的近似方法，是研究复杂系统（尤其是在分子动力学中）的标准工具。使用像LASSO这样的稀疏回归技术从数据中识别此类模型是一个当前且有效的研究课题。\n- **适定性：** 该问题是适定的。它详细说明了一个明确的计算任务：给定一组输入（轨迹、基函数、真实系数），生成合成数据，然后应用指定算法（用于LASSO的ISTA）来估计系数。LASSO解的存在性和唯一性由其目标函数的凸性保证。\n- **客观性：** 该问题以精确、客观和定量的术语陈述。所有参数都已指定，成功标准由数值容差明确定义。\n\n**步骤 3：结论与行动**\n\n该问题陈述在科学上是合理的、自洽的且适定的。它提出了一个非平凡但可行的计算任务，与分子动力学中的指定主题直接相关。没有矛盾、歧义或事实错误。该问题被认为是**有效的**。我们可以继续进行解答。\n\n### 推导与算法设计\n\n**1. 从连续卷积到离散线性系统**\n\n记忆力 $F_{\\text{mem}}(t)$ 源于分辨坐标与未分辨自由度之间相互作用的历史。在GLE形式中，这表示为与记忆核 $K(t')$ 的卷积。鉴于物理相互作用的因果性，核对于负时间参数为零，即当 $t'0$ 时 $K(t')=0$。因此，在时间 $t$ 的力为：\n$$ F_{\\text{mem}}(t) = \\int_{0}^{\\infty} K(\\tau) \\dot{q}(t-\\tau) d\\tau $$\n给定核被近似为 $p$ 个基函数的线性组合，$K(\\tau) \\approx \\sum_{i=1}^{p} c_i \\phi_i(\\tau)$。将此代入积分并利用线性性质，我们得到：\n$$ F_{\\text{mem}}(t) = \\sum_{i=1}^{p} c_i \\left( \\int_{0}^{\\infty} \\phi_i(\\tau) \\dot{q}(t-\\tau) d\\tau \\right) $$\n括号中的每一项都是基函数 $\\phi_i$ 与速度 $\\dot{q}$ 的卷积。我们将速度表示为 $v(t) = \\dot{q}(t)$，并将第 $i$ 个基的卷积积分表示为 $X_i(t) = (\\phi_i * v)(t)$。那么表达式简化为：\n$$ F_{\\text{mem}}(t) = \\sum_{i=1}^{p} c_i X_i(t) $$\n这表明记忆力是未知系数 $\\{c_i\\}$ 的线性函数。为了将其转换为计算机可解的系统，我们在时间上进行离散化。设 $t_n = n \\Delta t$，$n = 0, 1, \\dots, N-1$。我们在每个时间点 $t_n$ 处评估该方程。卷积积分通过黎曼和近似：\n$$ X_i(t_n) = \\int_{0}^{t_n} \\phi_i(\\tau) v(t_n-\\tau) d\\tau \\approx \\sum_{k=0}^{n} \\phi_i(k\\Delta t) v(t_n - k\\Delta t) \\Delta t $$\n设 $F_{\\text{mem}, n} = F_{\\text{mem}}(t_n)$，$v_m = v(t_m)$，以及 $\\phi_{i, k} = \\phi_i(k\\Delta t)$。设离散卷积和的结果为 $(v * \\phi_i)_n = \\sum_{k=0}^{n} v_{n-k} \\phi_{i, k}$。那么特征的离散化表达式为 $X_{ni} = \\Delta t (v * \\phi_i)_n$。所有时间点的完整方程组可以写成矩阵形式：\n$$ \\mathbf{F}_{\\text{mem}} = \\mathbf{X} \\mathbf{c} $$\n其中 $\\mathbf{F}_{\\text{mem}}$ 是一个 $N$ 维的记忆力样本列向量 $[F_{\\text{mem}, 0}, \\dots, F_{\\text{mem}, N-1}]^T$，$\\mathbf{c}$ 是一个 $p$ 维的系数列向量 $[c_1, \\dots, c_p]^T$，而 $\\mathbf{X}$ 是一个 $N \\times p$ 的设计矩阵，其元素为 $X_{ni}$。$\\mathbf{X}$ 的每一列都是速度与其中一个基函数卷积后的时间序列。\n\n**2. 通过LASSO进行稀疏回归**\n\n问题指定核表示是稀疏的，意味着大多数系数 $c_i$ 为零。为了恢复这种结构，我们采用LASSO估计器，它通过最小化一个带惩罚的最小二乘目标函数来找到系数 $\\mathbf{c}$：\n$$ \\hat{\\mathbf{c}} = \\arg\\min_{\\mathbf{c}} \\left\\{ \\frac{1}{2} || \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} ||_2^2 + \\lambda ||\\mathbf{c}||_1 \\right\\} $$\n第一项 $\\frac{1}{2} || \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} ||_2^2$ 是数据保真度项，它促使解拟合观测数据。第二项 $\\lambda ||\\mathbf{c}||_1 = \\lambda \\sum_{i=1}^p |c_i|$ 是 $\\ell_1$-正则化惩罚项。这个惩罚项通过将一些系数精确地驱动到零来促进稀疏性。参数 $\\lambda \\ge 0$ 控制数据保真度和稀疏性之间的权衡。\n\n**3. 迭代软阈值算法（ISTA）**\n\nLASSO目标函数是凸的，但由于 $\\ell_1$-范数中的绝对值而并非处处可微。近端梯度法非常适合此类问题。ISTA就是这样一种方法。它迭代地对目标函数的光滑部分执行梯度下降步骤，然后执行一个考虑非光滑部分的“近端”步骤。\n\n目标函数为 $J(\\mathbf{c}) = f(\\mathbf{c}) + g(\\mathbf{c})$，其中 $f(\\mathbf{c}) = \\frac{1}{2} || \\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}} ||_2^2$ 且 $g(\\mathbf{c}) = \\lambda ||\\mathbf{c}||_1$。\n光滑部分的梯度是 $\\nabla f(\\mathbf{c}) = \\mathbf{X}^T (\\mathbf{X}\\mathbf{c} - \\mathbf{F}_{\\text{mem}})$。\n第 $(k+1)$ 次迭代的ISTA更新规则是：\n$$ \\mathbf{c}^{(k+1)} = \\text{prox}_{\\alpha g}(\\mathbf{c}^{(k)} - \\alpha \\nabla f(\\mathbf{c}^{(k)})) $$\n其中 $\\alpha$ 是步长。由 $\\alpha\\lambda$ 缩放的 $\\ell_1$-范数的近端算子是逐元素的软阈值算子，$S_{\\kappa}(z) = \\text{sgn}(z) \\max(|z| - \\kappa, 0)$。\n完整的更新规则是：\n$$ \\mathbf{c}^{(k+1)} = S_{\\alpha\\lambda} \\left( \\mathbf{c}^{(k)} - \\alpha \\mathbf{X}^T (\\mathbf{X}\\mathbf{c}^{(k)} - \\mathbf{F}_{\\text{mem}}) \\right) $$\n\n为保证收敛，步长 $\\alpha$ 的选择必须满足 $0  \\alpha  2/L$，其中 $L$ 是梯度 $\\nabla f$ 的Lipschitz常数。该Lipschitz常数是Hessian矩阵 $\\nabla^2 f(\\mathbf{c}) = \\mathbf{X}^T\\mathbf{X}$ 的最大特征值（谱范数）。它由 $L = \\lambda_{\\max}(\\mathbf{X}^T\\mathbf{X}) = ||\\mathbf{X}||_2^2$ 给出，其中 $||\\mathbf{X}||_2$ 是 $\\mathbf{X}$ 的谱范数（其最大奇异值）。一个安全且标准的选择是 $\\alpha = 1/L$。\n\n**4. 评估**\n\n从ISTA获得估计系数 $\\hat{\\mathbf{c}}$ 后，记忆力被重建为 $\\hat{\\mathbf{F}}_{\\text{mem}} = \\mathbf{X}\\hat{\\mathbf{c}}$。重建的质量通过归一化均方根误差（NRMSE）来量化：\n$$ \\text{NRMSE} = \\frac{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} (F_{\\text{mem}, n} - \\hat{F}_{\\text{mem}, n})^2}}{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} F_{\\text{mem}, n}^2}} = \\frac{||\\mathbf{F}_{\\text{mem}} - \\hat{\\mathbf{F}}_{\\text{mem}}||_2}{||\\mathbf{F}_{\\text{mem}}||_2} $$\n根据规定，如果分母为零（即 $\\mathbf{F}_{\\text{mem}} = \\mathbf{0}$），则NRMSE被视为零。如果一个测试用例的NRMSE低于指定的容差，则该用例成功。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mori-Zwanzig memory kernel reconstruction problem for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General sparse case\n        {\n            \"taus\": [0.1, 0.3, 1.0, 3.0, 7.0],\n            \"c_true\": [0.0, 2.0, -1.5, 0.0, 0.5],\n            \"lambda\": 1e-4,\n            \"tolerance\": 1e-3,\n        },\n        # Case 2: Zero kernel\n        {\n            \"taus\": [1.0, 2.0, 3.0, 4.0],\n            \"c_true\": [0.0, 0.0, 0.0, 0.0],\n            \"lambda\": 1e-3,\n            \"tolerance\": 1e-8,\n        },\n        # Case 3: Highly correlated basis functions\n        {\n            \"taus\": [0.50, 0.51, 5.0],\n            \"c_true\": [1.0, 0.0, 0.0],\n            \"lambda\": 1e-3,\n            \"tolerance\": 1e-3,\n        },\n        # Case 4: Single-basis case\n        {\n            \"taus\": [2.0],\n            \"c_true\": [3.0],\n            \"lambda\": 1e-4,\n            \"tolerance\": 1e-3,\n        },\n    ]\n\n    results = []\n\n    # Common parameters for all test cases\n    dt = 0.01  # ps\n    T = 20.0   # ps\n    N = int(T / dt) + 1\n    t = np.linspace(0, T, N)\n\n    # Generate reference trajectory q(t) and velocity v(t) = dq/dt\n    w1, w2, w3 = 2 * np.pi * 0.05, 2 * np.pi * 0.20, 2 * np.pi * 0.50\n    a1, a2, a3 = 0.5, 0.3, 0.2\n    \n    # q(t) in nm\n    q_t = a1 * np.sin(w1 * t) + a2 * np.sin(w2 * t) + a3 * np.sin(w3 * t) \n    # v(t) in nm/ps\n    v_t = a1 * w1 * np.cos(w1 * t) + a2 * w2 * np.cos(w2 * t) + a3 * w3 * np.cos(w3 * t)\n\n    def soft_threshold(z, kappa):\n        \"\"\"Soft-thresholding operator for ISTA.\"\"\"\n        return np.sign(z) * np.maximum(np.abs(z) - kappa, 0)\n\n    for case in test_cases:\n        taus = case[\"taus\"]\n        c_true = np.array(case[\"c_true\"])\n        lamb = case[\"lambda\"]\n        tolerance = case[\"tolerance\"]\n\n        p = len(taus)\n        \n        # 1. Construct the design matrix X by convolving velocity with basis functions\n        X = np.zeros((N, p))\n        for i in range(p):\n            # Causal exponential basis function\n            phi = np.exp(-t / taus[i])\n            # Discrete convolution using Riemann sum factor dt\n            # (phi * v)(t_n) approx sum_{k=0 to n} phi(k*dt)v(t_n-k*dt)dt\n            convolution_result = np.convolve(v_t, phi, mode=\"full\")[:N]\n            X[:, i] = convolution_result * dt\n\n        # 2. Synthesize the ground-truth memory force F_mem (in pN)\n        F_mem = X @ c_true\n\n        # 3. Solve for coefficients using ISTA\n        # Determine stable step size from Lipschitz constant\n        # L = ||X^T X||_2 = ||X||_2^2 (spectral norm)\n        L = np.linalg.norm(X, ord=2) ** 2\n        # A condition number check to handle the case of X being a zero matrix\n        if L == 0:\n            alpha = 1.0\n        else:\n            alpha = 1.0 / L\n\n        # ISTA implementation\n        c_est = np.zeros(p)\n        n_iterations = 10000  # Number of iterations for convergence\n        for _ in range(n_iterations):\n            gradient = X.T @ (X @ c_est - F_mem)\n            c_update = c_est - alpha * gradient\n            c_est = soft_threshold(c_update, alpha * lamb)\n            \n        # 4. Evaluate reconstruction quality\n        F_pred = X @ c_est\n        \n        # Calculate normalized root-mean-square error (NRMSE)\n        norm_F_mem = np.linalg.norm(F_mem)\n        \n        if norm_F_mem == 0:\n            # Per problem spec, if ground truth is zero, NRMSE is zero if prediction is also zero.\n            # ISTA with c_true=0 will yield c_est=0, so F_pred=0 and error is zero.\n            nrmse = 0.0\n        else:\n            error = F_pred - F_mem\n            nrmse = np.linalg.norm(error) / norm_F_mem\n            \n        # Record if the reconstruction was successful\n        results.append(nrmse = tolerance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).capitalize(), results))}]\")\n\nsolve()\n```"
        }
    ]
}