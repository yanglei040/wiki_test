{
    "hands_on_practices": [
        {
            "introduction": "在科学计算中，通过一个已知答案的简单情景来检验我们方法的正确性，是一种至关重要的“一致性检验”。本练习将引导我们思考最简单的情况：估算两个完全相同的热力学状态之间的自由能差。这个练习旨在通过第一性原理的推导，验证 Bennett 接受率 (BAR) 和多态 Bennett 接受率 (MBAR) 方法是否能在这种理想极限下，给出零自由能差的精确解，并揭示此时的统计不确定性应为零，从而加深我们对这些方法核心原理的理解 。",
            "id": "3397190",
            "problem": "考虑两个热力学状态，标记为 $0$ 和 $1$，每个状态都由逆温 $\\beta$下的正则分布定义。无量纲势为 $u_i(x) = \\beta U_i(x)$，其中 $U_i(x)$ 是状态 $i$ 的势能函数，$x$ 表示相空间中的一个构型。正则密度为 $p_i(x) = Z_i^{-1} \\exp(-u_i(x))$，配分函数为 $Z_i = \\int \\exp(-u_i(x)) \\, dx$，无量纲自由能为 $f_i = -\\ln Z_i$。自由能差为 $\\Delta f = f_1 - f_0$。\n\n给定一个平凡情况，其中势和温度均相同，即对于所有 $x$ 都有 $U_0(x) = U_1(x)$，并且两个状态都在相同的逆温 $\\beta$ 下进行采样。假设从 $p_0(x)$ 中抽取了 $N_0 = 41$ 个独立样本，从 $p_1(x)$ 中抽取了 $N_1 = 59$ 个独立样本。\n\n仅使用上述基本统计力学定义，以及 Bennett 接受率 (BAR) 和多态 Bennett 接受率 (MBAR) 估计量是 $\\Delta f$ 的一致估计量这一事实，完成以下任务：\n\n1. 从第一性原理出发，证明 $p_0(x) = p_1(x)$，因此 $Z_0 = Z_1$，并得出结论：真实的自由能差为 $\\Delta f = 0$。\n\n2. 论证为什么在这种平凡情况下，$\\Delta f$ 的 BAR 估计和 MBAR 估计都精确返回 $0$ 并且估计量方差为零，即给定数据，估计量的输出是非随机常数。\n\n3. 计算以下反映两个状态之间完美重叠的诊断量：\n   - 重叠积分 $O = \\int \\min\\{p_0(x), p_1(x)\\} \\, dx$。\n   - Kullback–Leibler 散度 $D_{\\mathrm{KL}}(p_0 \\Vert p_1) = \\int p_0(x) \\ln\\big(p_0(x)/p_1(x)\\big) \\, dx$。\n   - Bhattacharyya 系数 $B = \\int \\sqrt{p_0(x) p_1(x)} \\, dx$。\n   - 多态 Bennett 接受率 (MBAR) 的有效样本量，定义为 $N_{\\mathrm{eff}} = \\dfrac{\\left(\\sum_{n=1}^{N} w_n\\right)^{2}}{\\sum_{n=1}^{N} w_n^{2}}$，其中权重 $\\{w_n\\}_{n=1}^{N}$ 用于在对合并的 $N = N_0 + N_1$ 个样本进行重加权时估计任一状态下的期望值，并且在这种平凡场景下，权重可以取为与 MBAR 下任一状态的重要性权重成正比。\n   - MBAR 权重的变异系数，$\\mathrm{CV}_w = \\dfrac{\\sqrt{\\mathrm{Var}(w)}}{\\mathbb{E}[w]}$，针对相同的合并权重。\n\n将最终答案表示为一个行矩阵，按顺序包含 $\\Delta f$ 的 BAR 估计值、$\\Delta f$ 的 MBAR 估计值、BAR 估计量的方差、重叠积分 $O$、Kullback–Leibler 散度 $D_{\\mathrm{KL}}(p_0 \\Vert p_1)$、Bhattacharyya 系数 $B$、MBAR 有效样本量 $N_{\\mathrm{eff}}$ 以及变异系数 $\\mathrm{CV}_w$。\n\n无需四舍五入。所有量均为无量纲量，并应使用自然对数表示，因此无量纲自由能也是无量纲的。",
            "solution": "用户提供了一个需要验证和解决的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 两个热力学状态，$0$ 和 $1$。\n- 逆温：$\\beta$。\n- 无量纲势：$u_i(x) = \\beta U_i(x)$。\n- 势能函数：$U_i(x)$。\n- 正则概率密度：$p_i(x) = Z_i^{-1} \\exp(-u_i(x))$。\n- 配分函数：$Z_i = \\int \\exp(-u_i(x)) \\, dx$。\n- 无量纲自由能：$f_i = -\\ln Z_i$。\n- 自由能差：$\\Delta f = f_1 - f_0$。\n- 平凡情况的条件：对于所有构型 $x$，$U_0(x) = U_1(x)$。\n- 从状态 $0$ 抽取的独立样本数：$N_0 = 41$。\n- 从状态 $1$ 抽取的独立样本数：$N_1 = 59$。\n- Bennett 接受率 (BAR) 和多态 Bennett 接受率 (MBAR) 估计量是 $\\Delta f$ 的一致估计量。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于统计力学的基本原理（正则系综、配分函数、自由能）和计算化学中成熟的方法（BAR、MBAR）。所有定义和概念都是标准的、科学合理的。\n- **适定性：** 该问题提供了一组清晰、自洽的条件（$U_0(x)=U_1(x)$）和一系列具体的、可回答的问题。问题的所有部分都存在唯一解。\n- **客观性：** 该问题以精确、正式的语言陈述，没有歧义或主观论断。\n\n该问题不违反任何无效标准。这是一个有效的、尽管是刻意简化的、旨在测试在极限情况下对自由能估计量的理解的问题。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n### 解答\n\n解答过程根据题目要求分为三个部分。\n\n**1. 证明状态相同且自由能差为零**\n\n给定两个状态的势能函数对于所有构型 $x$ 都相同：\n$$ U_0(x) = U_1(x) $$\n状态 $i$ 的无量纲势定义为 $u_i(x) = \\beta U_i(x)$。由于两个状态都处于相同的逆温 $\\beta$ 下，直接可以得出它们的无量纲势也相同：\n$$ u_0(x) = \\beta U_0(x) = \\beta U_1(x) = u_1(x) $$\n状态 $i$ 的配分函数 $Z_i$ 定义为玻尔兹曼因子在所有构型上的积分：\n$$ Z_i = \\int \\exp(-u_i(x)) \\, dx $$\n因为 $u_0(x) = u_1(x)$，所以 $Z_0$ 和 $Z_1$ 的被积函数相同。因此，配分函数必定相等：\n$$ Z_0 = \\int \\exp(-u_0(x)) \\, dx = \\int \\exp(-u_1(x)) \\, dx = Z_1 $$\n状态 $i$ 的正则概率密度由 $p_i(x) = Z_i^{-1} \\exp(-u_i(x))$ 给出。既然我们已经证明了 $u_0(x) = u_1(x)$ 和 $Z_0 = Z_1$，那么两个状态的概率密度也必定相同：\n$$ p_0(x) = \\frac{\\exp(-u_0(x))}{Z_0} = \\frac{\\exp(-u_1(x))}{Z_1} = p_1(x) $$\n最后，无量纲自由能差 $\\Delta f$ 定义为 $\\Delta f = f_1 - f_0$。使用定义 $f_i = -\\ln Z_i$，我们得到：\n$$ \\Delta f = (-\\ln Z_1) - (-\\ln Z_0) = \\ln Z_0 - \\ln Z_1 = \\ln\\left(\\frac{Z_0}{Z_1}\\right) $$\n由于 $Z_0 = Z_1$，它们的比值为 $1$，真实的自由能差为：\n$$ \\Delta f = \\ln(1) = 0 $$\n\n**2. 平凡情况下的 BAR 和 MBAR 估计量**\n\n这部分的关键在于，因为 $u_0(x) = u_1(x)$，所以无量纲势能差 $\\Delta u(x) = u_1(x) - u_0(x)$ 对于所有 $x$ 都为零。\n\n**Bennett 接受率 (BAR)：**\n自由能差的 BAR 估计值 $\\Delta \\hat{f}$ 通过求解以下隐式方程得到：\n$$ \\sum_{n=1}^{N_1} \\frac{1}{1 + \\frac{N_1}{N_0} \\exp(\\Delta u(x_{1,n}) - \\Delta \\hat{f})} = \\sum_{m=1}^{N_0} \\frac{1}{1 + \\frac{N_0}{N_1} \\exp(-\\Delta u(x_{0,m}) + \\Delta \\hat{f})} $$\n其中 $\\{x_{1,n}\\}$ 是来自状态 $1$ 的样本，$\\{x_{0,m}\\}$ 是来自状态 $0$ 的样本。\n将所有 $x$ 的 $\\Delta u(x)=0$ 代入，方程显著简化：\n$$ \\sum_{n=1}^{N_1} \\frac{1}{1 + \\frac{N_1}{N_0} \\exp(- \\Delta \\hat{f})} = \\sum_{m=1}^{N_0} \\frac{1}{1 + \\frac{N_0}{N_1} \\exp(\\Delta \\hat{f})} $$\n求和号内部的项是常数，不依赖于抽取的具体样本。方程变为：\n$$ N_1 \\left( \\frac{1}{1 + \\frac{N_1}{N_0} \\exp(- \\Delta \\hat{f})} \\right) = N_0 \\left( \\frac{1}{1 + \\frac{N_0}{N_1} \\exp(\\Delta \\hat{f})} \\right) $$\n这个方程可以求解 $\\Delta \\hat{f}$。我们可以检验解 $\\Delta \\hat{f} = 0$。如果 $\\Delta \\hat{f} = 0$，那么 $\\exp(-\\Delta \\hat{f}) = 1$ 且 $\\exp(\\Delta \\hat{f}) = 1$。方程变为：\n$$ \\frac{N_1}{1 + \\frac{N_1}{N_0}} = \\frac{N_0}{1 + \\frac{N_0}{N_1}} \\implies \\frac{N_1 N_0}{N_0 + N_1} = \\frac{N_0 N_1}{N_1 + N_0} $$\n这是一个恒等式，确认了 $\\Delta \\hat{f} = 0$ 是唯一解。因为确定 $\\Delta \\hat{f}$ 的方程不涉及随机样本，所以最终的估计量是一个非随机常数。因此，BAR 估计值精确为 $\\Delta \\hat{f}_{\\mathrm{BAR}} = 0$，其方差也因此为 $0$。\n\n**多态 Bennett 接受率 (MBAR)：**\nMBAR 方程通过求解以下方程组来确定自由能集合 $\\{f_k\\}$：\n$$ \\exp(-f_k) = \\sum_{i=0}^{1} \\sum_{n=1}^{N_i} \\frac{\\exp(-u_k(x_{i,n}))}{\\sum_{j=0}^{1} N_j \\exp(f_j - u_j(x_{i,n}))}, \\quad k \\in \\{0, 1\\} $$\n设定参考自由能 $f_0=0$，我们求解 $f_1$。由于 $u_0(x)=u_1(x)=u(x)$，关于 $f_1$ 的方程是：\n$$ \\exp(-f_1) = \\sum_{i=0}^{1} \\sum_{n=1}^{N_i} \\frac{\\exp(-u(x_{i,n}))}{N_0 \\exp(f_0 - u(x_{i,n})) + N_1 \\exp(f_1 - u(x_{i,n}))} $$\n代入 $f_0=0$ 并从分母中提出因子 $\\exp(-u(x_{i,n}))$：\n$$ \\exp(-f_1) = \\sum_{i=0}^{1} \\sum_{n=1}^{N_i} \\frac{\\exp(-u(x_{i,n}))}{\\exp(-u(x_{i,n}))(N_0 + N_1 \\exp(f_1))} = \\sum_{i=0}^{1} \\sum_{n=1}^{N_i} \\frac{1}{N_0 + N_1 \\exp(f_1)} $$\n被加数对于所有样本都是常数。对所有 $N_0+N_1$ 个样本求和得到：\n$$ \\exp(-f_1) = \\frac{N_0 + N_1}{N_0 + N_1 \\exp(f_1)} $$\n检验解 $f_1=0$ 得到 $\\exp(-0) = \\frac{N_0+N_1}{N_0+N_1\\exp(0)}$，简化为 $1 = \\frac{N_0+N_1}{N_0+N_1} = 1$。这确认了 $\\hat{f}_1=0$ 是唯一解。\n估计的自由能差为 $\\Delta \\hat{f}_{\\mathrm{MBAR}} = \\hat{f}_1 - \\hat{f}_0 = 0 - 0 = 0$。与 BAR 的情况一样，结果与样本无关，因此估计值是一个方差为零的常数。\n\n**3. 诊断量的计算**\n\n- **重叠积分 ($O$):**\n  $O = \\int \\min\\{p_0(x), p_1(x)\\} \\, dx$。由于 $p_0(x) = p_1(x)$，我们有 $\\min\\{p_0(x), p_1(x)\\} = p_0(x)$。概率密度函数在其定义域上的积分为 $1$。\n  $$ O = \\int p_0(x) \\, dx = 1 $$\n\n- **Kullback–Leibler 散度 ($D_{\\mathrm{KL}}$):**\n  $D_{\\mathrm{KL}}(p_0 \\Vert p_1) = \\int p_0(x) \\ln\\left(\\frac{p_0(x)}{p_1(x)}\\right) \\, dx$。由于 $p_0(x) = p_1(x)$，比值为 $1$，且 $\\ln(1)=0$。\n  $$ D_{\\mathrm{KL}}(p_0 \\Vert p_1) = \\int p_0(x) \\cdot 0 \\, dx = 0 $$\n\n- **Bhattacharyya 系数 ($B$):**\n  $B = \\int \\sqrt{p_0(x) p_1(x)} \\, dx$。由于 $p_0(x) = p_1(x)$，被积函数为 $\\sqrt{p_0(x)^2} = p_0(x)$。\n  $$ B = \\int p_0(x) \\, dx = 1 $$\n\n- **MBAR 有效样本量 ($N_{\\mathrm{eff}}$):**\n  对于一个来自合并样本集（共 $N=N_0+N_1$ 个样本）的样本 $x_n$，用于估计任何状态 $k$ 下期望值的 MBAR 权重与 $w_n \\propto (\\sum_j N_j \\exp(f_j - u_j(x_n)))^{-1}$ 成正比。在本例中，$u_0=u_1=u$ 且 $f_0=f_1=0$，因此每个样本的分母简化为 $(N_0+N_1) \\exp(-u(x_n))$。用于估计状态 $k$ 中平均值的完整权重是 $w_{nk} = \\frac{\\exp(-u_k(x_n))}{\\sum_j N_j \\exp(f_j-u_j(x_n))}$。将这些权重归一化使其总和为 $1$ 以形成平均值，我们发现每个权重的实际值变成一个常数，$w_n = 1/N$，其中 $N=N_0+N_1=41+59=100$。\n  有效样本量定义为 $N_{\\mathrm{eff}} = \\left(\\sum_{n=1}^{N} w_n\\right)^{2} / \\left(\\sum_{n=1}^{N} w_n^{2}\\right)$。\n  当 $w_n = 1/N$ 时：\n  $$ \\sum_{n=1}^{N} w_n = \\sum_{n=1}^{100} \\frac{1}{100} = 100 \\times \\frac{1}{100} = 1 $$\n  $$ \\sum_{n=1}^{N} w_n^2 = \\sum_{n=1}^{100} \\left(\\frac{1}{100}\\right)^2 = 100 \\times \\frac{1}{10000} = \\frac{1}{100} $$\n  $$ N_{\\mathrm{eff}} = \\frac{(1)^2}{1/100} = 100 $$\n  这表明由于重加权没有样本损失，这与相同分布的预期相符。$N_{\\mathrm{eff}} = N_0+N_1=100$。\n\n- **权重的变异系数 ($\\mathrm{CV}_w$):**\n  $\\mathrm{CV}_w = \\sqrt{\\mathrm{Var}(w)}/\\mathbb{E}[w]$。权重 $\\{w_n\\}_{n=1}^N$ 是一组相同的常数，$w_n = 1/N$。一组常数值的方差为 $0$。\n  $$ \\mathrm{Var}(w) = 0 \\implies \\mathrm{CV}_w = 0 $$\n  这表明所有样本的权重均等，这是完美重叠的标志。\n\n**结果总结**\n- $\\Delta f$ 的 BAR 估计值：$0$\n- $\\Delta f$ 的 MBAR 估计值：$0$\n- BAR 估计量的方差：$0$\n- 重叠积分 $O$：$1$\n- Kullback–Leibler 散度 $D_{\\mathrm{KL}}(p_0 \\Vert p_1)$：$0$\n- Bhattacharyya 系数 $B$：$1$\n- MBAR 有效样本量 $N_{\\mathrm{eff}}$：$100$\n- 变异系数 $\\mathrm{CV}_w$：$0$\n这些值将被组合成最终的答案矩阵。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & 0 & 0 & 1 & 0 & 1 & 100 & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在理想情况之后，我们转向一个更实际的问题：相比于自由能微扰 (FEP) 等单向方法，BAR 的效率究竟高出多少？本练习构建了一个可以通过参数调节状态间重叠程度的人工模型。通过这个模型，你将通过数值计算来直接比较 BAR 和 FEP 估计量的渐近方差，亲眼见证 BAR，特别是在相空间重叠较差时，所表现出的卓越统计效率 。",
            "id": "3397194",
            "problem": "给定一个为分析分子动力学中自由能估计器统计效率而构建的合成双态平衡模型。该模型完全以约化单位定义，因此最终的数值答案不需要物理单位。您的任务是计算Bennett接受率（BAR）估计器的渐近方差，并将其与单边指数平均（也称为自由能微扰法，FEP）进行比较，作为可调重叠参数的函数。\n\n基本基础和构造：\n- 考虑两个约化势 $u_0(x)$ 和 $u_1(x)$，其约化势差定义为 $\\Delta u(x) = u_1(x) - u_0(x)$。\n- 在平衡统计力学（正则系综）中，从状态0和1采样时 $\\Delta u$ 的分布通过指数倾斜相关联：\n  $$ P_1(\\Delta u) = \\frac{P_0(\\Delta u)\\, e^{-(\\Delta u - \\Delta f)}}{\\int P_0(\\Delta u)\\, e^{-(\\Delta u - \\Delta f)}\\, d\\Delta u}, $$\n  其中 $\\Delta f$ 是满足以下条件的约化自由能差\n  $$ \\Delta f = -\\log \\mathbb{E}_{0}\\left[ e^{-\\Delta u} \\right], $$\n  且 $\\mathbb{E}_{0}[\\cdot]$ 表示关于 $P_0$ 的期望。\n- 定义一个由 $\\kappa > 0$ 索引的单参数模型族：\n  - 令 $P_0$ 为高斯分布 $P_0(\\Delta u) = \\mathcal{N}(m_0, s^2)$，其中 $s = \\kappa$ 且 $m_0 = s^2/2$。\n  - 利用上述指数倾斜关系和高斯分布的矩生成函数性质，此构造得出 $\\Delta f = 0$，并且 $P_1(\\Delta u)$ 变为具有相同方差 $s^2$ 和均值 $m_1 = -s^2/2$ 的高斯分布。因此 $P_1(\\Delta u) = \\mathcal{N}(m_1, s^2)$。\n\n待比较的估计器：\n- 单边指数平均（自由能微扰法，FEP），从状态 $0$ 开始的正向方向：从 $P_0$ 中独立抽取 $n_0$ 个样本 $\\{\\Delta u_i\\}_{i=1}^{n_0}$，估计器为\n  $$ \\widehat{\\Delta f}_{\\text{FEP}} = -\\log \\left( \\frac{1}{n_0} \\sum_{i=1}^{n_0} e^{-\\Delta u_i} \\right) $$\n- Bennett接受率（BAR）：通过从 $P_0$ 中抽取 $n_0$ 个样本和从 $P_1$ 中抽取 $n_1$ 个样本，BAR通过求解估计方程的唯一根 $C$ 来估计 $\\Delta f$。\n  $$ \\frac{1}{n_0}\\sum_{i=1}^{n_0} \\frac{1}{1 + e^{\\Delta u_i - C}} - \\frac{1}{n_1}\\sum_{j=1}^{n_1} \\frac{1}{1 + e^{-(\\Delta u'_j - C)}} = 0, $$\n  其中 $\\{\\Delta u'_j\\}_{j=1}^{n_1}$ 是从 $P_1$ 中抽取的独立样本，然后设置 $\\widehat{\\Delta f}_{\\text{BAR}} = C$。在当前的对称构造中，真实值为 $\\Delta f = 0$。\n\n方差分析任务：\n- 从大数定律和中心极限定理出发，并在适当情况下对样本均值的平滑变换使用delta方法，您必须：\n  1) 推导单边FEP估计器（从状态0开始的正向方向）的渐近方差。用方差 $s^2$ 和样本量 $n_0$ 来表示，给出一个仅依赖于 $s^2$ 和 $n_0$ 的公式。\n  2) 使用估计方程根的 $M$-估计器理论，推导BAR估计器的渐近方差。令 $f(u; C) = \\left(1 + e^{u - C}\\right)^{-1}$。证明在 $n_0 = n_1 = n$ 的大样本极限下，方差具有以下形式\n     $$ \\mathrm{Var}(\\widehat{\\Delta f}_{\\text{BAR}}) \\approx \\frac{ \\mathrm{Var}_0\\!\\left[f(\\Delta u; \\Delta f)\\right]/n + \\mathrm{Var}_1\\!\\left[f(\\Delta u; \\Delta f)\\right]/n }{ \\left( \\mathbb{E}_0\\!\\left[ f(\\Delta u; \\Delta f)\\left(1 - f(\\Delta u; \\Delta f)\\right) \\right] + \\mathbb{E}_1\\!\\left[ f(\\Delta u; \\Delta f)\\left(1 - f(\\Delta u; \\Delta f)\\right) \\right] \\right)^2 }, $$\n     其中带有下标0和1的期望和方差分别是对 $P_0$ 和 $P_1$ 求的，并且在真实值 $C = \\Delta f = 0$ 处进行评估。\n- 将此高斯族中的“BAR不稳定性”解释为估计方程的灵敏度消失的条件，即分母\n  $$ D(\\kappa) \\equiv \\mathbb{E}_0\\!\\left[ f(\\Delta u; 0)\\left(1 - f(\\Delta u; 0)\\right) \\right] + \\mathbb{E}_1\\!\\left[ f(\\Delta u; 0)\\left(1 - f(\\Delta u; 0)\\right) \\right] $$\n  在数值上变得可忽略不计，导致渐近方差爆炸。为进行数值计算，当 $D(\\kappa)  10^{-6}$ 时，声明BAR“不稳定”。\n\n数值计算程序约束：\n- 所有关于 $P_0$ 和 $P_1$ 对 $\\Delta u$ 的积分必须使用适用于高斯测度的求积法进行高精度数值计算。Gauss-Hermite求积是合适的：对于 $U \\sim \\mathcal{N}(m, s^2)$ 和任意函数 $g$，计算\n  $$ \\mathbb{E}[g(U)] = \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{M} w_i\\, g\\!\\left(m + s\\sqrt{2}\\, x_i\\right), $$\n  其中 $\\{x_i, w_i\\}_{i=1}^{M}$ 是 $M$ 点Gauss-Hermite节点和权重，并且必须选择足够大的 $M$ 以确保下面所有测试用例的数值稳定性。\n\n测试套件：\n- 对两个状态使用相同的样本量：$n_0 = n_1 = n = 10000$。\n- 在以下六个重叠参数 $\\kappa$ 值上进行评估：\n  - $\\kappa = 0.25$\n  - $\\kappa = 0.75$\n  - $\\kappa = 1.50$\n  - $\\kappa = 2.50$\n  - $\\kappa = 4.00$\n  - $\\kappa = 6.00$\n- 对于每个 $\\kappa$，您必须计算：\n  - BAR的渐近方差，以浮点数形式表示。\n  - 正向单边FEP的渐近方差，以浮点数形式表示。\n  - 一个布尔标志，指示在该 $\\kappa$ 值下的BAR不稳定性（如上定义）。\n\n最终输出格式：\n- 您的程序必须输出单行，其中包含一个逗号分隔的Python列表，按顺序汇总六个测试用例的结果，每个用例贡献三个条目：$[\\mathrm{Var}_{\\text{BAR}}(\\kappa), \\mathrm{Var}_{\\text{FEP}}(\\kappa), \\text{unstable}(\\kappa), \\dots]$。\n- 在这十八个条目之后，追加另外两个条目：\n  1) 第一个（来自给定测试集）使得 $\\mathrm{Var}_{\\text{BAR}}(\\kappa)  \\mathrm{Var}_{\\text{FEP}}(\\kappa)$ 成立的最小 $\\kappa$ 值；如果没有，则输出 $-1$。\n  2) 第一个（来自给定测试集）被标记为不稳定的最小 $\\kappa$ 值；如果没有，则输出 $-1$。\n- 因此，最终打印的字符串必须是一个长度为20的单行Python列表。所有浮点数都是无量纲的，并且在输出中必须四舍五入到六位小数。\n\n您的程序必须是自包含的，不得读取输入，也不得访问任何外部资源。它必须在内部实现Gauss-Hermite求积，并对所有指定的 $\\kappa$ 值遵守数值稳定性要求。输出必须是指定格式的单行（例如，“[..., ...]”）。",
            "solution": "问题陈述经过了仔细验证，被认为是**有效的**。它在科学上植根于统计力学的原理，特别是自由能估计理论。该问题是适定的、自包含的，并为在一个合成但严格定义的高斯模型中，推导和计算两个关键估计器——Bennett接受率（BAR）和自由能微扰法（FEP）的统计特性，提供了一个清晰、客观的任务。所有参数、定义和数值约束的规定都没有歧义或矛盾。\n\n解决方案分两个阶段进行：理论推导和数值实现。\n\n### 理论推导\n\n该问题要求推导单边FEP估计器和BAR估计器的渐近方差。\n\n**1. FEP估计器的渐近方差**\n\n自由能差 $\\Delta f$ 的正向FEP估计器由下式给出：\n$$ \\widehat{\\Delta f}_{\\text{FEP}} = -\\log \\left( \\frac{1}{n_0} \\sum_{i=1}^{n_0} e^{-\\Delta u_i} \\right) $$\n其中样本 $\\{\\Delta u_i\\}$ 从分布 $P_0(\\Delta u) = \\mathcal{N}(m_0, s^2)$ 中抽取。问题指定 $s = \\kappa$ 且 $m_0 = s^2/2$。\n\n令 $Y_i = e^{-\\Delta u_i}$。该估计器是样本均值 $\\bar{Y} = \\frac{1}{n_0}\\sum Y_i$ 的函数，具体为 $\\widehat{\\Delta f}_{\\text{FEP}} = g(\\bar{Y})$，其中 $g(y) = -\\log(y)$。真实的自由能是 $\\Delta f = g(\\mathbb{E}_0[Y])$。\n$Y$ 的均值为 $\\mu_Y = \\mathbb{E}_0[e^{-\\Delta u}]$。这是高斯变量 $\\Delta u \\sim \\mathcal{N}(m_0, s^2)$ 在 $t=-1$ 处评估的矩生成函数：\n$$ \\mu_Y = \\mathbb{E}_0[e^{-\\Delta u}] = \\exp\\left(m_0(-1) + \\frac{s^2(-1)^2}{2}\\right) = \\exp\\left(-m_0 + \\frac{s^2}{2}\\right) $$\n代入 $m_0 = s^2/2$，我们得到 $\\mu_Y = \\exp(-s^2/2 + s^2/2) = \\exp(0) = 1$。这证实了问题陈述中 $\\Delta f = -\\log(1) = 0$ 的说法。\n\n使用delta方法，$\\widehat{\\Delta f}_{\\text{FEP}}$ 的渐近方差为：\n$$ \\mathrm{Var}(\\widehat{\\Delta f}_{\\text{FEP}}) \\approx [g'(\\mu_Y)]^2 \\mathrm{Var}(\\bar{Y}) = [g'(\\mu_Y)]^2 \\frac{\\mathrm{Var}_0(Y)}{n_0} $$\n由于 $g'(y) = -1/y$，我们有 $g'(1) = -1$。$Y$ 的方差是 $\\mathrm{Var}_0(Y) = \\mathbb{E}_0[Y^2] - (\\mathbb{E}_0[Y])^2$。\n我们需要 $\\mathbb{E}_0[Y^2] = \\mathbb{E}_0[e^{-2\\Delta u}]$，这是在 $t=-2$ 处评估的矩生成函数：\n$$ \\mathbb{E}_0[e^{-2\\Delta u}] = \\exp\\left(m_0(-2) + \\frac{s^2(-2)^2}{2}\\right) = \\exp\\left(-2m_0 + 2s^2\\right) $$\n代入 $m_0 = s^2/2$，我们得到 $\\mathbb{E}_0[e^{-2\\Delta u}] = \\exp(-s^2 + 2s^2) = \\exp(s^2)$。\n因此，$\\mathrm{Var}_0(Y) = \\exp(s^2) - 1^2 = \\exp(s^2) - 1$。\nFEP估计器的渐近方差为：\n$$ \\mathrm{Var}(\\widehat{\\Delta f}_{\\text{FEP}}) \\approx \\frac{1}{n_0} (\\exp(s^2) - 1) = \\frac{\\exp(\\kappa^2) - 1}{n_0} $$\n对于此模型，此表达式是精确的，并且仅依赖于 $s^2 = \\kappa^2$ 和 $n_0$。\n\n**2. BAR估计器的渐近方差**\n\n问题提供了在 $n_0 = n_1 = n$ 且真实值为 $\\Delta f = 0$ 时BAR估计器的渐近方差公式：\n$$ \\mathrm{Var}(\\widehat{\\Delta f}_{\\text{BAR}}) \\approx \\frac{ \\mathrm{Var}_0[f(\\Delta u; 0)]/n + \\mathrm{Var}_1[f(\\Delta u; 0)]/n }{ \\left( \\mathbb{E}_0[f(\\Delta u; 0)(1 - f(\\Delta u; 0))] + \\mathbb{E}_1[f(\\Delta u; 0)(1 - f(\\Delta u; 0))] \\right)^2 } $$\n其中 $f(u; 0) = \\sigma(u) = (1 + e^u)^{-1}$。\n该模型由对称分布构成：$P_0 = \\mathcal{N}(m_0, s^2)$ 和 $P_1 = \\mathcal{N}(m_1, s^2)$，其中 $m_1 = -m_0 = -s^2/2$。这意味着对于任何函数 $h$，都有 $\\mathbb{E}_1[h(\\Delta u)] = \\mathbb{E}_0[h(-\\Delta u)]$。\n\n这种对称性极大地简化了方差公式的组成部分：\n- 令 $g_3(u) = \\sigma(u)(1-\\sigma(u))$。这是一个偶函数，$g_3(-u) = g_3(u)$。因此，$\\mathbb{E}_1[g_3(\\Delta u)] = \\mathbb{E}_0[g_3(-\\Delta u)] = \\mathbb{E}_0[g_3(\\Delta u)]$。\n分母的核心项 $D(\\kappa)$ 变为 $D(\\kappa) = 2 \\mathbb{E}_0[\\sigma(\\Delta u)(1 - \\sigma(\\Delta u))]$。\n- 对于分子，我们有 $\\mathrm{Var}_1[\\sigma(\\Delta u)] = \\mathbb{E}_1[\\sigma^2(\\Delta u)] - (\\mathbb{E}_1[\\sigma(\\Delta u)])^2$。利用关系式 $\\sigma(-u) = 1-\\sigma(u)$ 和 $\\sigma^2(-u) = (1-\\sigma(u))^2$，经过代数简化后，我们发现 $\\mathrm{Var}_1[\\sigma(\\Delta u)] = \\mathrm{Var}_0[\\sigma(\\Delta u)]$。\n\n因此，BAR方差公式简化为：\n$$ \\mathrm{Var}(\\widehat{\\Delta f}_{\\text{BAR}}) \\approx \\frac{ 2 \\mathrm{Var}_0[\\sigma(\\Delta u)]/n }{ \\left( 2 \\mathbb{E}_0[\\sigma(\\Delta u)(1 - \\sigma(\\Delta u))] \\right)^2 } = \\frac{ \\mathrm{Var}_0[\\sigma(\\Delta u)] }{ 2n \\left( \\mathbb{E}_0[\\sigma(\\Delta u)(1 - \\sigma(\\Delta u))] \\right)^2 } $$\n其中 $\\mathrm{Var}_0[\\sigma(\\Delta u)] = \\mathbb{E}_0[\\sigma^2(\\Delta u)] - (\\mathbb{E}_0[\\sigma(\\Delta u)])^2$。\n\n### 数值评估\n\n剩下的任务是计算关于高斯分布 $P_0 = \\mathcal{N}(m_0, s^2)$ 的期望 $\\mathbb{E}_0[\\sigma(\\Delta u)]$、$\\mathbb{E}_0[\\sigma^2(\\Delta u)]$ 和 $\\mathbb{E}_0[\\sigma(\\Delta u)(1 - \\sigma(\\Delta u))]$。这需要按照规定使用Gauss-Hermite求积法来完成。对于一个函数 $g$ 和一个随机变量 $U \\sim \\mathcal{N}(m, s^2)$，其期望计算如下：\n$$ \\mathbb{E}[g(U)] = \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{M} w_i\\, g(m + s\\sqrt{2}\\, x_i) $$\n其中 $\\{x_i, w_i\\}_{i=1}^{M}$ 是物理学家Hermite多项式的节点和权重。实现将使用 `numpy.polynomial.hermite.hermgauss` 来获取这些节点和权重。选择足够多的点数（$M=200$）以确保在所有 $\\kappa$ 值范围内的数值精度。\n\n最终的计算如下：\n- $\\mathrm{Var}_{\\text{FEP}}$ 是解析计算的。\n- $\\mathrm{Var}_{\\text{BAR}}$ 是使用简化公式和数值计算的期望来计算的。\n- 如果 $D(\\kappa) = 2 \\mathbb{E}_0[\\sigma(\\Delta u)(1 - \\sigma(\\Delta u))]  10^{-6}$，则BAR不稳定性标志设置为 `True`。\n\n一个已知的理论结果是，BAR估计器的方差小于或等于单边FEP估计器的方差。因此，对于任何 $\\kappa > 0$，条件 $\\mathrm{Var}_{\\text{BAR}}(\\kappa) > \\mathrm{Var}_{\\text{FEP}}(\\kappa)$ 预计不会满足。相应的汇总统计量将是 $-1$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the asymptotic variances of BAR and FEP estimators\n    for a synthetic Gaussian model.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    # List of overlap parameters kappa to test\n    KAPPAS = [0.25, 0.75, 1.50, 2.50, 4.00, 6.00]\n    # Number of samples from each state\n    N_SAMPLES = 10000\n    # Number of Gauss-Hermite quadrature points for numerical integration\n    N_QUAD_POINTS = 200\n    # Threshold for BAR instability\n    INSTABILITY_THRESHOLD = 1e-6\n\n    def compute_estimator_variances(kappa: float, n: int, M: int) -> tuple[float, float, bool]:\n        \"\"\"\n        Calculates the asymptotic variances for BAR and FEP for a given kappa.\n\n        Args:\n            kappa: The overlap parameter.\n            n: The number of samples (n0=n1=n).\n            M: The number of quadrature points.\n\n        Returns:\n            A tuple containing (Var_BAR, Var_FEP, is_unstable).\n        \"\"\"\n        s = kappa\n        s2 = s**2\n        \n        # --- 1. Asymptotic Variance of FEP (Analytic) ---\n        # Var(FEP_fwd) = (exp(s^2) - 1) / n\n        var_fep = (np.exp(s2) - 1) / n\n\n        # --- 2. Asymptotic Variance of BAR (Numerical Quadrature) ---\n        m0 = s2 / 2.0\n        \n        # Get Gauss-Hermite nodes (x_gh) and weights (w_gh) for the\n        # physicist's weight function exp(-x^2).\n        x_gh, w_gh = np.polynomial.hermite.hermgauss(M)\n\n        # Create the quadrature evaluation points for U ~ N(m0, s^2)\n        # using the transformation u = m0 + s*sqrt(2)*x\n        u_pts = m0 + s * np.sqrt(2.0) * x_gh\n\n        # Define integrand functions (vectorized)\n        # The fermi function f(u;0) = sigma(u)\n        sigma = 1.0 / (1.0 + np.exp(u_pts))\n        # f^2\n        sigma_sq = sigma**2\n        # f(1-f)\n        sigma_1_minus_sigma = sigma * (1.0 - sigma)\n\n        # Compute expectations with respect to P0 using the specified quadrature rule:\n        # E[g(U)] = (1/sqrt(pi)) * sum(w_i * g(m+s*sqrt(2)*x_i))\n        E0_sigma = np.sum(w_gh * sigma) / np.sqrt(np.pi)\n        E0_sigma_sq = np.sum(w_gh * sigma_sq) / np.sqrt(np.pi)\n        E0_sigma_1_minus_sigma = np.sum(w_gh * sigma_1_minus_sigma) / np.sqrt(np.pi)\n\n        # Variance of sigma(Delta u) under P0\n        var0_sigma = E0_sigma_sq - E0_sigma**2\n        \n        # Denominator term D(kappa) and instability check\n        D_kappa = 2.0 * E0_sigma_1_minus_sigma\n        is_unstable = D_kappa  INSTABILITY_THRESHOLD\n        \n        # Asymptotic variance of BAR, using the simplified formula for symmetric systems\n        # Var(BAR) = [2 * Var0(f) / n] / [D_kappa]^2\n        # Use a small epsilon to prevent division by zero for unstable cases.\n        var_bar = (2.0 * var0_sigma / n) / (D_kappa**2 + 1e-30)\n\n        return var_bar, var_fep, is_unstable\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    first_crossover_kappa = -1.0\n    first_unstable_kappa = -1.0\n\n    for kappa in KAPPAS:\n        var_bar, var_fep, is_unstable = compute_estimator_variances(\n            kappa, N_SAMPLES, N_QUAD_POINTS\n        )\n        \n        all_results.append(f\"{var_bar:.6f}\")\n        all_results.append(f\"{var_fep:.6f}\")\n        all_results.append(str(is_unstable))\n        \n        # Check for crossover (Var_BAR > Var_FEP)\n        # Based on theory, this should not happen, so first_crossover_kappa will remain -1.\n        if var_bar > var_fep and first_crossover_kappa == -1.0:\n            first_crossover_kappa = kappa\n        \n        # Check for first occurrence of instability\n        if is_unstable and first_unstable_kappa == -1.0:\n            first_unstable_kappa = kappa\n\n    # --- Final Output Formatting ---\n    all_results.append(str(first_crossover_kappa))\n    all_results.append(str(first_unstable_kappa))\n    \n    final_output_string = f\"[{','.join(all_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "最后的练习是本章的顶点：从零开始构建一个能够工作的 MBAR 求解器。理论公式虽然优雅，但在实际应用中，数值稳定性是决定成败的关键。本练习将带你直面并解决真实世界实现中的核心挑战，例如使用对数-和-指数 (log-sum-exp) 技巧来避免浮点数上溢和下溢，以及处理自由能估计中的规范自由度，最终构建出一个可应用于真实模拟数据的稳健工具 。",
            "id": "3397216",
            "problem": "为多态贝内特接受率方法（Multistate Bennett Acceptance Ratio, MBAR）实现一个数值稳定的求解器，该求解器适用于根据从分子动力学中多个热力学态抽取的汇集构象，估算无量纲的约化自由能。从以下基本原理出发：在正则系综中，一个热力学态的未归一化目标密度与玻尔兹曼因子 $e^{-u_k(x)}$ 成正比，其中 $u_k(x)$ 是约化势能。给定汇集的样本以及重要性采样下的最大似然原理，平稳条件定义了一组关于未知约化自由能的自洽方程。求解这些方程时必须满足一个约束条件，即任意加性常数不影响可观测物理量。不要假定任何针对多态贝内特接受率方法（MBAR）或贝内特接受率方法（BAR）的预先推导好的公式；相反，应从汇集数据的似然以及重要性采样的归一化要求出发进行推导。您的实现必须：\n- 将重要性权重的分母作为对数-和-指数（log-sum-exp）计算来处理，以避免浮点数运算中的下溢和上溢。\n- 强制执行一个锚定约定来固定加性规范自由度，例如，$\\hat{f}_0 = 0$。\n- 包含至少两种缩放策略，以在估计值$\\hat{f}_m$变化范围很大时提高数值稳定性：\n  - 在每次迭代中对向量$\\hat{f}$进行重新中心化（例如，通过将一个分量固定为 $0$）。\n  - 以对数形式对样本数进行归一化，以移除无关的全局尺度因子，这些因子只会将所有$\\hat{f}_k$平移一个常数，而该常数会被锚定步骤消除。\n- 使用带有收敛容差的阻尼不动点迭代，以确保稳健的收敛。\n\n测试构建的数据模型：\n- 考虑在逆温度$\\beta = 1$下的一维谐振子，其势能为$U_k(x) = \\tfrac{1}{2} K_k x^2$，其中$K_k$是态$k$的力常数。那么约化势能为$u_k(x) = \\beta U_k(x) + c_k = \\tfrac{1}{2} K_k x^2 + c_k$，其中$c_k$是一个可以随态变化的常数偏移量。\n- 对于每个热力学态$k$，从该态对应的平衡分布中抽取$N_k$个独立样本$x$。对于$\\beta = 1$的一维谐振子，$x$服从均值为$0$、方差为$\\sigma_k^2 = 1 / K_k$的正态分布。\n- 对于每个测试用例，将所有态的所有样本汇集到一个集合中，并为每个汇集构象$x$和每个态$m$计算$u_m(x)$，以获得一个形状为$K \\times N$的矩阵$u_{m i}$，其中$K$是态的数量，$N = \\sum_{k=0}^{K-1} N_k$是汇集样本的总数。\n\n算法要求：\n- 令$N_k$为从态$k$抽取的样本数。令$\\hat{f}_k$为态$k$的约化自由能的当前估计值。将汇集样本索引$i$的每个样本的分母定义为对所有$m$的项$\\log N_m + \\hat{f}_m - u_m(x_i)$的稳定 log-sum-exp 计算结果。使用此结果来评估重要性权重，并通过汇集数据似然的平稳条件所隐含的不动点方程来更新$\\hat{f}_k$。对不动点更新应用阻尼，并在每次迭代中重新中心化向量$\\hat{f}$以强制$\\hat{f}_0 = 0$。以对数形式归一化$N_k$（通过减去$\\log \\sum_m N_m$），这样样本数中的任何全局乘法因子都只会在所有$\\hat{f}_k$中引入一个加性常数，而这个常数会被锚定步骤移除。\n- 实现一个收敛检查，当所有$k$中$\\hat{f}_k$的最大绝对变化量低于一个容差时停止。使用一个合理的默认容差，如$10^{-12}$，以及阻尼因子，如$0.5$。\n\n测试套件：\n使用种子为$12345$的确定性随机数生成器构建以下$4$个测试用例，以确保所有结果都是可复现的。对于每个测试用例，按上文所述生成正态分布变量，并为所有汇集样本和态构建约化势能矩阵$u_{m i}$。然后在每个测试用例上运行您的 MBAR 求解器以估算$\\hat{f}_k$，并进行锚定以使$\\hat{f}_0 = 0$。对于每个测试用例，报告向量$[\\hat{f}_0 - \\hat{f}_0, \\ldots, \\hat{f}_{K-1} - \\hat{f}_0]$，以使第一个条目始终为$0$。\n\n- 测试用例 $1$ (理想路径): $K=3$, $(N_0, N_1, N_2)=(200, 150, 150)$, $(K_0, K_1, K_2)=(1.0, 4.0, 16.0)$, $(c_0, c_1, c_2)=(0.0, 0.0, 0.0)$。\n- 测试用例 $2$ (不平衡的样本数和中等偏移): $K=3$, $(N_0, N_1, N_2)=(400, 10, 10)$, $(K_0, K_1, K_2)=(1.0, 2.0, 8.0)$, $(c_0, c_1, c_2)=(0.0, 5.0, 10.0)$。\n- 测试用例 $3$ (极端偏移压力测试): $K=2$, $(N_0, N_1)=(100, 100)$, $(K_0, K_1)=(1.0, 1.0)$, $(c_0, c_1)=(0.0, 500.0)$。\n- 测试用例 $4$ (边界情况): $K=1$, $(N_0)=(100)$, $(K_0)=(2.0)$, $(c_0)=(0.0)$。\n\n角度或物理单位不适用；所有量均为无量纲的约化单位。对于数值报告，将每个输出条目四舍五入到$6$位小数。\n\n最终输出格式：\n- 您的程序应生成单行文本，其中包含所有测试用例的锚定自由能的串联结果。每个测试用例贡献一个列表$[\\hat{f}_0 - \\hat{f}_0, \\ldots, \\hat{f}_{K-1} - \\hat{f}_0]$，这些列表被展平并打印为单个用方括号括起来的逗号分隔列表。例如，如果测试用例 $1$ 产生 $[0.0, a, b]$，测试用例 $2$ 产生 $[0.0, c, d]$，则最终输出应为 $[0.0,a,b,0.0,c,d]$，每个数字都四舍五入到 $6$ 位小数。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于统计力学原理，特别是基于分子模拟数据计算自由能。该问题定义明确，提供了清晰的目标、所有必要的数据和可验证的结构。问题要求实现多态贝内特接受率方法（MBAR），该方法需从基本原理推导，而不是使用预先包装好的公式。\n\nMBAR方程的推导源于一个自洽性要求，即从给定热力学态观测到的样本数必须与模型对该数量的预测相匹配。假设有 $K$ 个热力学态，用 $k$ 索引。从每个态 $k$ 中，采样一组 $N_k$ 个构象。所有 $N = \\sum_{k=0}^{K-1} N_k$ 个构象 $\\{x_i\\}_{i=1}^N$ 被汇集在一起。构象 $x_i$ 在态 $k$ 中的约化势能为 $u_k(x_i)$。态 $k$ 的未知无量纲约化自由能为 $f_k$。\n\n在给定自由能集合 $\\{f_m\\}$ 的条件下，汇集集合中的一个给定构象 $x_i$ 源于态 $k$ 的概率由一个后验概率给出：\n$$ P(k | x_i, \\{f_m, N_m\\}) = \\frac{P(x_i | k) P(k)}{\\sum_{m=0}^{K-1} P(x_i | m) P(m)} $$\n在给定构象 $x_i$ 来自态 $k$ 的条件下，观测到该构象的概率与玻尔兹曼因子成正比，即 $P(x_i | k) \\propto e^{-u_k(x_i)}$。更精确地说，概率密度为 $p_k(x_i) = e^{-u_k(x_i) + f_k}$，其中 $e^{-f_k} = Z_k$ 是归一化分布的配分函数。从态 $k$ 抽取样本的先验概率与从该态抽取的样本数成正比，即 $P(k) \\propto N_k$。将这些代入后验概率可得：\n$$ P(k | x_i) = \\frac{N_k e^{-u_k(x_i) + f_k}}{\\sum_{m=0}^{K-1} N_m e^{-u_m(x_i) + f_m}} $$\n自洽性条件要求，来自态 $k$ 的总样本数 $N_k$ 必须等于整个汇集数据集中每个样本源于态 $k$ 的概率之和：\n$$ N_k = \\sum_{i=1}^N P(k | x_i) = \\sum_{i=1}^N \\frac{N_k e^{-u_k(x_i) + f_k}}{\\sum_{m=0}^{K-1} N_m e^{-u_m(x_i) + f_m}} $$\n假设 $N_k  0$，我们可以除以 $N_k$ 并重新整理，以获得关于 $f_k$ 的不动点迭代。令 $f_k^{(t)}$ 为第 $t$ 次迭代时的估计值。下一次迭代的估计值 $f_k^{(t+1)}$ 由下式给出：\n$$ e^{-f_k^{(t+1)}} = \\sum_{i=1}^N \\frac{e^{-u_k(x_i)}}{\\sum_{m=0}^{K-1} N_m e^{-u_m(x_i) + f_m^{(t)}}} $$\n对两边取自然对数，得到 $f_k$ 的更新规则：\n$$ f_k^{(t+1)} = -\\ln\\left( \\sum_{i=1}^N \\frac{e^{-u_k(x_i)}}{\\sum_{m=0}^{K-1} N_m e^{f_m^{(t)} - u_m(x_i)}} \\right) $$\n为了以数值稳定的方式实现此方程，所有指数和都使用 log-sum-exp 技巧计算。令 $A_{mi}^{(t)} = \\ln N_m + f_m^{(t)} - u_m(x_i)$。对于样本 $i$，内部求和（分母）的对数为 $L_i^{(t)} = \\text{log-sum-exp}_m(A_{mi}^{(t)})$。更新方程变为：\n$$ f_k^{(t+1)} = -\\text{log-sum-exp}_i \\left( -u_k(x_i) - L_i^{(t)} \\right) $$\n这个迭代过程受到一个任意加性常数的影响，因为给所有 $f_m$ 加上一个常数 $C$ 并不会改变方程。这个规范自由度通过锚定一个自由能来固定，例如，在迭代的每一步强制 $\\hat f_0 = 0$。这是一种重新中心化策略。\n第二个稳定性增强措施涉及归一化样本数 $N_k$。使用归一化样本数 $N_k' = N_k / N$ 等效于从所有初始的 $\\ln N_k$ 中减去一个常数 $\\ln N$。这使得计算对于所有 $N_k$ 的全局缩放保持不变，这种平移在任何情况下都会被锚定步骤所吸收。\n最后，为确保稳健收敛，使用阻尼更新。如果 $\\hat{f}_{\\text{new}}$ 是由上述方程计算并随后锚定的自由能向量，则下一个迭代值 $\\hat{f}^{(t+1)}$ 计算为新旧估计值的加权平均：\n$$ \\hat{f}^{(t+1)} = (1-\\alpha) \\hat{f}^{(t)} + \\alpha \\hat{f}_{\\text{new}} $$\n其中 $\\alpha \\in (0, 1]$ 是一个阻尼因子。迭代过程持续进行，直到 $\\hat{f}$ 的任何分量的最大绝对变化量低于指定的容差 $\\epsilon$。\n\n算法流程如下：\n1. 初始化所有 $k$ 的自由能估计值 $\\hat{f}_k$ 为 $0$。\n2. 预先计算样本数的归一化对数 $\\ln(N_k/N)$，并处理 $N_k=0$ 的情况。\n3. 进入迭代循环：\n   a. 计算分母的指数矩阵，$A_{mi} = \\ln(N_m/N) + \\hat{f}_m - u_{mi}$。\n   b. 沿状态轴（$m$）使用 log-sum-exp 找到每个样本的对数分母，$L_i = \\text{log-sum-exp}_m(A_{mi})$。\n   c. 计算外部和的指数矩阵，$B_{ki} = -u_{ki} - L_i$。\n   d. 沿样本轴（$i$）使用 log-sum-exp 找到新的未锚定自由能，$\\hat{f}_{k, \\text{raw}} = -\\text{log-sum-exp}_i(B_{ki})$。\n   e. 通过减去第一个元素来锚定新的估计值：$\\hat{f}_{k, \\text{new}} = \\hat{f}_{k, \\text{raw}} - \\hat{f}_{0, \\text{raw}}$。\n   f. 应用阻尼更新以获得新的估计值 $\\hat{f}^{(t+1)}$。\n   g. 通过比较 $\\hat{f}^{(t+1)}$ 和 $\\hat{f}^{(t)}$ 来检查收敛性。如果收敛，则退出；否则，继续。\n4. 返回最终的锚定自由能向量 $\\hat{f}$。\n该流程被实现用于求解所提供测试用例的自由能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef mbar_solver(u_kn, N_k, tol=1e-12, alpha=0.5, max_iter=10000):\n    \"\"\"\n    Solves the Multistate Bennett Acceptance Ratio (MBAR) equations for the\n    dimensionless reduced free energies.\n\n    This function implements a numerically stable, damped fixed-point iteration\n    to find the free energies f_k that satisfy the MBAR equations.\n\n    Args:\n        u_kn (np.ndarray): A matrix of shape (K, N) where u_kn[k, n] is the\n                           reduced potential energy of configuration n evaluated\n                           at the potential of state k. K is the number of states\n                           and N is the total number of configurations.\n        N_k (np.ndarray): An array of shape (K,) containing the number of\n                          configurations sampled from each state.\n        tol (float): The convergence tolerance. Iteration stops when the\n                     maximum absolute change in any f_k is less than this value.\n        alpha (float): The damping factor for the fixed-point iteration.\n        max_iter (int): The maximum number of iterations to perform.\n\n    Returns:\n        np.ndarray: An array of shape (K,) containing the estimated reduced free\n                    energies, anchored such that f_0 = 0.\n    \"\"\"\n    K = u_kn.shape[0]\n\n    # Handle trivial cases: one state or no states. The free energy difference\n    # is by definition 0.\n    if K = 1:\n        return np.zeros(K)\n\n    # Initialize free energies to zero.\n    f_k = np.zeros(K)\n\n    # Calculate normalized log sample counts. This is numerically stable and\n    # handles states with zero samples (N_k=0 -> log(N_k)=-inf).\n    log_N_k = np.full(K, -np.inf)\n    active_states = N_k > 0\n    if np.any(active_states):\n        log_N_k[active_states] = np.log(N_k[active_states])\n    \n    # Normalizing the log-counts makes the solver invariant to global scaling\n    # of sample counts.\n    log_N_norm = log_N_k - logsumexp(log_N_k[active_states])\n\n    for _ in range(max_iter):\n        f_old = f_k.copy()\n        \n        # The argument for the log-sum-exp over states (k) is:\n        # A_kn = log(N_k) + f_k - u_kn\n        # We use broadcasting to efficiently compute this matrix.\n        log_N_f_k = log_N_norm[:, np.newaxis] + f_k[:, np.newaxis]\n        A_kn = log_N_f_k - u_kn\n        \n        # The log of the denominator term, for each configuration n:\n        # log_D_n = log(sum_k exp(A_kn))\n        # This summation is performed over the state index (axis=0).\n        log_D_n = logsumexp(A_kn, axis=0)\n        \n        # The argument for the log-sum-exp over configurations (n) is:\n        # B_kn = -u_kn - log_D_n\n        B_kn = -u_kn - log_D_n[np.newaxis, :]\n        \n        # Solve for the new, un-anchored free energies:\n        # f_new_k = -log(sum_n exp(B_kn))\n        # This summation is performed over the configuration index (axis=1).\n        f_new_k = -logsumexp(B_kn, axis=1)\n        \n        # Enforce anchoring convention f_0 = 0 by re-centering.\n        f_new_anchored = f_new_k - f_new_k[0]\n        \n        # Apply damped update to improve convergence stability.\n        f_k = f_k + alpha * (f_new_anchored - f_k)\n        \n        # Check for convergence.\n        max_abs_change = np.max(np.abs(f_k - f_old))\n        if max_abs_change  tol:\n            break\n            \n    # Final anchor to ensure f_0 is exactly 0.\n    f_k -= f_k[0]\n    return f_k\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases, run the MBAR solver,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # K, (N_counts), (K_springs), (c_offsets)\n        (3, (200, 150, 150), (1.0, 4.0, 16.0), (0.0, 0.0, 0.0)),\n        (3, (400, 10, 10), (1.0, 2.0, 8.0), (0.0, 5.0, 10.0)),\n        (2, (100, 100), (1.0, 1.0), (0.0, 500.0)),\n        (1, (100,), (2.0,), (0.0,)),\n    ]\n\n    rng = np.random.default_rng(seed=12345)\n    all_results = []\n\n    for case in test_cases:\n        K, N_counts, K_springs, c_offsets = case\n        N_counts_arr = np.array(N_counts)\n        \n        # Generate configurations for each state from its equilibrium distribution.\n        x_samples = []\n        if K > 0:\n            for k in range(K):\n                Nk = N_counts_arr[k]\n                if Nk > 0:\n                    Kk = K_springs[k]\n                    # For a 1D harmonic oscillator with beta=1, distribution is\n                    # Normal(0, 1/K_k).\n                    sigma_k = np.sqrt(1.0 / Kk)\n                    samples_k = rng.normal(loc=0.0, scale=sigma_k, size=Nk)\n                    x_samples.append(samples_k)\n        \n        # Pool all configurations into a single dataset.\n        if not x_samples:\n            x_pooled = np.array([])\n        else:\n            x_pooled = np.concatenate(x_samples)\n        \n        # Construct the reduced potential energy matrix u_kn.\n        N_total = x_pooled.shape[0]\n        u_kn = np.zeros((K, N_total))\n        if K > 0 and N_total > 0:\n            for m in range(K):\n                Km = K_springs[m]\n                cm = c_offsets[m]\n                u_kn[m, :] = 0.5 * Km * x_pooled**2 + cm\n        \n        # Run the MBAR solver.\n        f_k_estimated = mbar_solver(u_kn, N_counts_arr)\n        all_results.extend(f_k_estimated)\n\n    # Format the final results as a single comma-separated list.\n    # Each number is rounded to 6 decimal places.\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}