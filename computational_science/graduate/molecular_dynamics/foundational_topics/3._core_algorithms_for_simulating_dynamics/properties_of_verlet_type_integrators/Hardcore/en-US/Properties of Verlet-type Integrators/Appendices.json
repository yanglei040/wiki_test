{
    "hands_on_practices": [
        {
            "introduction": "The harmonic oscillator serves as the canonical model system for analyzing the stability and accuracy of numerical integrators. Understanding how an algorithm performs on this simple, solvable system provides deep insights into its behavior in more complex molecular simulations. This practice  guides you through a fundamental analysis of the velocity-Verlet method, deriving its exact stability boundary and quantifying the phase error, which are essential metrics for choosing an appropriate time step.",
            "id": "3438597",
            "problem": "Consider the one-dimensional harmonic oscillator with Hamiltonian $H=\\tfrac{p^{2}}{2 m}+\\tfrac{1}{2} k q^{2}$ and angular frequency $\\omega=\\sqrt{k/m}$. In Molecular Dynamics (MD), the velocity-Verlet integrator advances position $q$ and velocity $v$ under Newton's law $m \\ddot{q}=-k q$ using the time step $h$ and the acceleration $a=-\\omega^{2} q$. Starting strictly from these foundations, derive the exact linear update map of velocity-Verlet for the harmonic oscillator, analyze its eigenvalues, and obtain the exact stability boundary in terms of $\\omega$ and $h$. From the same linear map, define the discrete frequency $\\omega_{h}$ as the per-step rotation angle divided by the time step, and express it in closed form as a function of $\\omega$ and $h$. Finally, let $\\delta \\phi$ denote the phase error accumulated over one exact continuous-time period $T=2 \\pi / \\omega$, defined as the numerical phase advance after time $T$ minus $2 \\pi$. Derive a closed-form expression for $\\delta \\phi$ in radians in terms of $\\omega$ and $h$. \n\nYour derivation must proceed from Newton’s second law and the velocity-Verlet update rules and must not assume any pre-stated properties of the integrator beyond those definitions. Provide your final answer as the row matrix $\\left(h_{\\max}, \\omega_{h}, \\delta \\phi\\right)$, where $h_{\\max}$ is the maximum stable time step expressed as a function of $\\omega$, $\\omega_{h}$ is the discrete frequency, and $\\delta \\phi$ is the phase error per period in radians. No numerical evaluation or rounding is required, and the final expressions must be exact and in closed form.",
            "solution": "The problem asks for an analysis of the velocity-Verlet integrator applied to a one-dimensional harmonic oscillator. The analysis includes deriving the linear update map, determining the stability boundary, finding the numerical frequency, and calculating the phase error. The entire derivation must be performed from first principles as defined in the problem.\n\nFirst, we state the standard velocity-Verlet algorithm. For a particle with position $q(t)$, velocity $v(t)$, and acceleration $a(t)$, the state at time $t+h$ is computed from the state at time $t$ as follows:\n1. Update position: $q(t+h) = q(t) + h v(t) + \\frac{h^2}{2} a(t)$\n2. Calculate future acceleration: $a(t+h)$ is computed from $q(t+h)$.\n3. Update velocity: $v(t+h) = v(t) + \\frac{h}{2} [a(t) + a(t+h)]$\n\nFor the one-dimensional harmonic oscillator, the Hamiltonian is $H=\\frac{p^{2}}{2 m}+\\frac{1}{2} k q^{2}$, where $p=mv$ is the momentum. The equation of motion is given by Newton's second law, $m\\ddot{q} = -kq$. The acceleration is $a(t) = \\ddot{q}(t) = -\\frac{k}{m} q(t)$. Using the given definition of the angular frequency, $\\omega = \\sqrt{k/m}$, the acceleration is $a(t) = -\\omega^2 q(t)$.\n\nLet $q_n = q(nh)$ and $v_n = v(nh)$ denote the position and velocity at the $n$-th time step. The corresponding acceleration is $a_n = -\\omega^2 q_n$. The velocity-Verlet update rules for the harmonic oscillator become:\n$q_{n+1} = q_n + h v_n + \\frac{h^2}{2} a_n = q_n + h v_n - \\frac{h^2 \\omega^2}{2} q_n$\n$v_{n+1} = v_n + \\frac{h}{2} [a_n + a_{n+1}]$\n\nTo find $v_{n+1}$, we first need $a_{n+1} = -\\omega^2 q_{n+1}$. Substituting the expression for $q_{n+1}$:\n$a_{n+1} = -\\omega^2 \\left( q_n + h v_n - \\frac{h^2 \\omega^2}{2} q_n \\right)$\n\nNow, we substitute $a_n$ and $a_{n+1}$ into the velocity update equation:\n$v_{n+1} = v_n + \\frac{h}{2} \\left[ -\\omega^2 q_n - \\omega^2 \\left( q_n + h v_n - \\frac{h^2 \\omega^2}{2} q_n \\right) \\right]$\n$v_{n+1} = v_n - \\frac{h \\omega^2}{2} \\left[ q_n + q_n + h v_n - \\frac{h^2 \\omega^2}{2} q_n \\right]$\n$v_{n+1} = v_n - \\frac{h \\omega^2}{2} \\left[ (2 - \\frac{h^2 \\omega^2}{2}) q_n + h v_n \\right]$\n$v_{n+1} = v_n - \\omega^2 h (1 - \\frac{h^2 \\omega^2}{4}) q_n - \\frac{h^2 \\omega^2}{2} v_n$\n\nWe can now write the full linear update map, which expresses the state vector $(q_{n+1}, v_{n+1})^T$ as a linear transformation of $(q_n, v_n)^T$.\n$q_{n+1} = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) q_n + h v_n$\n$v_{n+1} = -\\omega^2 h \\left(1 - \\frac{\\omega^2 h^2}{4}\\right) q_n + \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) v_n$\n\nThis can be written in matrix form as:\n$$\n\\begin{pmatrix} q_{n+1} \\\\ v_{n+1} \\end{pmatrix} = M \\begin{pmatrix} q_n \\\\ v_n \\end{pmatrix}\n$$\nwhere the update matrix $M$, also known as the transfer matrix, is:\n$$\nM = \\begin{pmatrix} 1 - \\frac{\\omega^2 h^2}{2} & h \\\\ -\\omega^2 h \\left(1 - \\frac{\\omega^2 h^2}{4}\\right) & 1 - \\frac{\\omega^2 h^2}{2} \\end{pmatrix}\n$$\n\nThe stability of the integrator is determined by the eigenvalues $\\lambda$ of the matrix $M$. The eigenvalues are solutions to the characteristic equation $\\det(M - \\lambda I) = 0$, where $I$ is the identity matrix.\n$$\n\\det \\begin{pmatrix} 1 - \\frac{\\omega^2 h^2}{2} - \\lambda & h \\\\ -\\omega^2 h \\left(1 - \\frac{\\omega^2 h^2}{4}\\right) & 1 - \\frac{\\omega^2 h^2}{2} - \\lambda \\end{pmatrix} = 0\n$$\n$$\n\\left(1 - \\frac{\\omega^2 h^2}{2} - \\lambda\\right)^2 + h^2 \\omega^2 \\left(1 - \\frac{\\omega^2 h^2}{4}\\right) = 0\n$$\n$$\n\\left(\\lambda - \\left(1 - \\frac{\\omega^2 h^2}{2}\\right)\\right)^2 = -h^2 \\omega^2 \\left(1 - \\frac{\\omega^2 h^2}{4}\\right)\n$$\n$$\n\\lambda - \\left(1 - \\frac{\\omega^2 h^2}{2}\\right) = \\pm i \\omega h \\sqrt{1 - \\frac{\\omega^2 h^2}{4}}\n$$\n$$\n\\lambda = 1 - \\frac{\\omega^2 h^2}{2} \\pm i \\omega h \\sqrt{1 - \\frac{\\omega^2 h^2}{4}}\n$$\nThe numerical integration is stable if the magnitude of the eigenvalues is less than or equal to $1$. Let's compute $|\\lambda|^2$:\n$$\n|\\lambda|^2 = \\left(1 - \\frac{\\omega^2 h^2}{2}\\right)^2 + \\left(\\omega h \\sqrt{1 - \\frac{\\omega^2 h^2}{4}}\\right)^2\n$$\n$$\n|\\lambda|^2 = \\left(1 - \\omega^2 h^2 + \\frac{\\omega^4 h^4}{4}\\right) + \\omega^2 h^2 \\left(1 - \\frac{\\omega^2 h^2}{4}\\right)\n$$\n$$\n|\\lambda|^2 = 1 - \\omega^2 h^2 + \\frac{\\omega^4 h^4}{4} + \\omega^2 h^2 - \\frac{\\omega^4 h^4}{4} = 1\n$$\nThis result $|\\lambda|^2=1$ holds if and only if the argument of the square root is non-negative, which ensures that the eigenvalues are complex conjugates on the unit circle. If the argument is negative, the eigenvalues become real, and one of them will have a magnitude greater than $1$, leading to exponential growth and instability. The stability condition is therefore:\n$1 - \\frac{\\omega^2 h^2}{4} \\geq 0 \\implies \\omega^2 h^2 \\leq 4$\nSince both $\\omega$ and $h$ are positive, this gives $\\omega h \\leq 2$. The maximum stable time step $h_{\\max}$ corresponds to the equality $\\omega h_{\\max} = 2$, which means $h_{\\max} = \\frac{2}{\\omega}$.\n\nNext, we derive the discrete frequency $\\omega_h$. In the stable regime, the eigenvalues are of the form $\\lambda = e^{\\pm i \\theta_h}$, where $\\theta_h$ is the numerical phase advance per step. We can write $\\lambda = \\cos(\\theta_h) + i \\sin(\\theta_h)$. By comparing this with the expression for $\\lambda$, we identify:\n$\\cos(\\theta_h) = \\text{Re}(\\lambda) = 1 - \\frac{\\omega^2 h^2}{2}$\nThe numerical frequency $\\omega_h$ is defined as the phase advance per unit time, so $\\omega_h = \\theta_h / h$.\n$\\theta_h = \\omega_h h = \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right)$\nThus, the discrete frequency is:\n$\\omega_h = \\frac{1}{h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right)$\n\nFinally, we derive the phase error $\\delta \\phi$ over one exact continuous-time period $T = 2\\pi / \\omega$. The number of time steps in one period is $N = T/h = \\frac{2\\pi}{\\omega h}$.\nThe total numerical phase advance over time $T$ is $N \\theta_h = N (\\omega_h h)$.\nThe total exact phase advance over the same period is $\\omega T = \\omega(\\frac{2\\pi}{\\omega}) = 2\\pi$.\nThe phase error $\\delta \\phi$ is the difference between the numerical and exact phase advances:\n$\\delta \\phi = N \\omega_h h - 2\\pi$\n$\\delta \\phi = \\left(\\frac{2\\pi}{\\omega h}\\right) \\omega_h h - 2\\pi = \\frac{2\\pi \\omega_h}{\\omega} - 2\\pi = 2\\pi \\left(\\frac{\\omega_h}{\\omega} - 1\\right)$\nSubstituting the expression for $\\omega_h$:\n$\\delta \\phi = 2\\pi \\left(\\frac{1}{\\omega h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right) - 1\\right)$\n\nThe three required quantities are $h_{\\max} = \\frac{2}{\\omega}$, $\\omega_h = \\frac{1}{h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right)$, and $\\delta \\phi = 2\\pi \\left(\\frac{1}{\\omega h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right) - 1\\right)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{2}{\\omega} & \\frac{1}{h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right) & 2\\pi \\left( \\frac{1}{\\omega h} \\arccos\\left(1 - \\frac{\\omega^2 h^2}{2}\\right) - 1 \\right) \\end{pmatrix}}$$"
        },
        {
            "introduction": "Theoretical analysis shows that Verlet-type integrators possess desirable geometric properties, but what does this mean in practice? This hands-on coding exercise  is designed to make the abstract concept of symplecticity tangible. By implementing and comparing the standard velocity-Verlet algorithm against a superficially similar but non-symplectic predictor-corrector method, you will directly observe the consequences of breaking time-reversibility and witness the long-term energy drift that plagues non-geometric integrators.",
            "id": "3438625",
            "problem": "Consider a one-dimensional Hamiltonian system in molecular dynamics governed by Newton’s second law under a smooth potential. Let the Hamiltonian be given by\n$$\nH(x,p) = \\frac{p^2}{2m} + V(x), \\quad p = m v,\n$$\nwith mass $m$ constant, position $x$, momentum $p$, velocity $v$, and a potential\n$$\nV(x) = \\frac{1}{2} k x^2 + \\frac{\\lambda}{4} x^4,\n$$\nso that the force is $F(x) = -\\frac{dV}{dx} = -k x - \\lambda x^3$ and the acceleration is $a(x) = \\frac{F(x)}{m}$. Starting from initial conditions $x(0) = x_0$, $v(0) = v_0$, consider two one-step time integration methods with step size $\\Delta t$ and exactly one force evaluation $F$ per step:\n\n- Velocity-Verlet (symmetric, kick-drift-kick form). Using the stored acceleration $a_n = a(x_n)$ at step $n$:\n  1. Half-kick: $v_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2} a_n$.\n  2. Drift: $x_{n+1} = x_n + \\Delta t\\, v_{n+\\frac{1}{2}}$.\n  3. Force: $a_{n+1} = a(x_{n+1})$.\n  4. Half-kick: $v_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2} a_{n+1}$.\n\n- Predictor–corrector Verlet with a single predicted force and no recomputation at the corrected position. Using the stored acceleration $a_n = a(x_n)$:\n  1. Predictor for position: $x_{n+1}^{(p)} = x_n + \\Delta t\\, v_n + \\frac{\\Delta t^2}{2} a_n$.\n  2. Predicted force: $a_{n+1}^{(p)} = a\\!\\left(x_{n+1}^{(p)}\\right)$.\n  3. Corrector for velocity: $v_{n+1} = v_n + \\frac{\\Delta t}{2}\\left(a_n + a_{n+1}^{(p)}\\right)$.\n  4. Corrector for position using trapezoidal velocity: $x_{n+1} = x_n + \\frac{\\Delta t}{2}\\left(v_n + v_{n+1}\\right)$.\n  5. Set $a_{n+1} \\leftarrow a_{n+1}^{(p)}$ for the next step, without recomputing the force at the corrected $x_{n+1}$.\n\nBoth methods use one evaluation of $F$ per step, ensuring matched computational cost.\n\nTask: Demonstrate, using first principles and numerical evidence, that reusing velocities from previous steps in the above “predictor–corrector Verlet” degrades symplecticity compared to pure velocity-Verlet. Quantify the resulting secular drift in the Hamiltonian $H$ over long times and compare with velocity-Verlet at matched cost. Use least-squares linear regression of $H(t) - H(0)$ versus time $t$ to estimate a constant drift rate (slope), expressed in units of energy per unit time.\n\nFundamental base you must rely on in your reasoning and implementation: Newton’s second law, the definition of the Hamiltonian, and canonical update rules as stated above. Avoid any shortcut formulas not derivable from these.\n\nYour program must:\n- Implement both integrators exactly as specified.\n- For each trajectory, compute the Hamiltonian $H(t) = \\frac{1}{2} m v(t)^2 + V(x(t))$ at each step and form $y(t) = H(t) - H(0)$.\n- Estimate the drift slope $\\beta$ via ordinary least squares as the slope of $y$ versus $t$, that is,\n  $$\n  \\beta = \\frac{\\sum_i (t_i - \\bar{t})(y_i - \\bar{y})}{\\sum_i (t_i - \\bar{t})^2},\n  $$\n  where $(t_i, y_i)$ are the sampled pairs at each step, and overbars denote arithmetic means.\n- Report one drift slope for velocity-Verlet and one for predictor–corrector Verlet for each test case, in units of energy per unit time.\n\nUse the following test suite to ensure coverage of typical, small-step, and near-boundary behaviors. Each tuple is $(m, k, \\lambda, x_0, v_0, \\Delta t, T_{\\text{total}})$, with $T_{\\text{total}}$ the total simulated physical time:\n- Case A (small step, near-conservative baseline): $(m, k, \\lambda, x_0, v_0, \\Delta t, T_{\\text{total}}) = (1.0, 1.0, 1.0, 1.0, 0.0, 0.005, 2000.0)$.\n- Case B (typical step): $(1.0, 1.0, 1.0, 1.0, 0.0, 0.020, 2000.0)$.\n- Case C (larger step): $(1.0, 1.0, 1.0, 1.0, 0.0, 0.050, 2000.0)$.\n- Case D (near-boundary larger step, shorter horizon to avoid blow-up): $(1.0, 1.0, 1.0, 1.0, 0.0, 0.080, 500.0)$.\n\nAll quantities are nondimensional; report the drift slopes in units of energy per unit time.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the two drift slopes for each case in order, velocity-Verlet followed by predictor–corrector Verlet, concatenated over all cases in the order A, B, C, D. For example, the output should look like a list such as [resultA_VV,resultA_PCV,resultB_VV,resultB_PCV,resultC_VV,resultC_PCV,resultD_VV,resultD_PCV].",
            "solution": "The problem requires a comparative analysis of two numerical integration schemes, velocity-Verlet and a specific predictor-corrector method, for a one-dimensional Hamiltonian system. The analysis focuses on the long-term conservation of the Hamiltonian, a key indicator of an integrator's quality for such systems.\n\nThe physical system is governed by the Hamiltonian $H(x,p) = \\frac{p^2}{2m} + V(x)$, where $p=mv$ is the momentum, $m$ is the mass, and $V(x) = \\frac{1}{2} k x^2 + \\frac{\\lambda}{4} x^4$ is the potential energy. This corresponds to Newton's second law, $m\\ddot{x} = F(x)$, with the force $F(x) = -\\frac{dV}{dx} = -k x - \\lambda x^3$ and acceleration $a(x) = F(x)/m$.\n\nNumerical integrators for Hamiltonian systems are ideally \"geometric,\" meaning they preserve fundamental geometric properties of the true continuous flow in phase space. The most important of these properties is symplecticity. A symplectic integrator, when applied to a Hamiltonian system, does not conserve the true Hamiltonian $H$ exactly but instead exactly conserves a nearby \"shadow\" Hamiltonian, $H_{\\Delta t}$. This implies that the numerical error in the true energy $H$ remains bounded over arbitrarily long simulation times, exhibiting oscillations but no secular drift. A necessary condition for a one-step integrator map $\\Phi_{\\Delta t}$ to be symplectic is that it must be time-reversible, i.e., executing a forward step $\\Phi_{\\Delta t}$ followed by a backward step $\\Phi_{-\\Delta t}$ must return the system to its initial state.\n\n**1. Analysis of the Velocity-Verlet (VV) Integrator**\n\nThe velocity-Verlet algorithm is defined by the following sequence of updates from step $n$ to $n+1$:\n1. $v_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2} a(x_n)$\n2. $x_{n+1} = x_n + \\Delta t\\, v_{n+\\frac{1}{2}}$\n3. $a_{n+1} = a(x_{n+1})$\n4. $v_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2} a_{n+1}$\n\nThis algorithm is a member of the family of geometric integrators. Its symplecticity can be rigorously established by showing that it is a second-order symmetric splitting method. The Hamiltonian $H = T(p) + V(x)$ is split into its kinetic ($T$) and potential ($V$) parts. The exact evolution operators for these parts can be composed to approximate the full evolution. The velocity-Verlet algorithm represents the map $\\Phi_{\\Delta t} = \\mathcal{O}_V(\\Delta t/2) \\mathcal{O}_T(\\Delta t) \\mathcal{O}_V(\\Delta t/2)$, where $\\mathcal{O}_V(\\delta t)$ is the exact evolution under $V$ for time $\\delta t$ (a \"kick\" to momentum) and $\\mathcal{O}_T(\\delta t)$ is the exact evolution under $T$ for time $\\delta t$ (a \"drift\" of position). Since each component map is symplectic, their composition is also symplectic.\n\nAs a consequence of its symplecticity, the velocity-Verlet integrator exhibits excellent long-term energy conservation. The numerical energy will oscillate around the true initial energy, but it will not systematically increase or decrease over time. The amplitude of these oscillations is dependent on the time step $\\Delta t$, but the average energy remains constant. The numerical experiment is expected to yield an energy drift slope $\\beta$ that is statistically zero.\n\n**2. Analysis of the Predictor-Corrector Verlet (PCV) Integrator**\n\nThe specific predictor-corrector scheme is defined as:\n1. Predictor for position: $x_{n+1}^{(p)} = x_n + \\Delta t\\, v_n + \\frac{\\Delta t^2}{2} a_n$\n2. Predicted force: $a_{n+1}^{(p)} = a(x_{n+1}^{(p)})$\n3. Corrector for velocity: $v_{n+1} = v_n + \\frac{\\Delta t}{2}(a_n + a_{n+1}^{(p)})$\n4. Corrector for position: $x_{n+1} = x_n + \\frac{\\Delta t}{2}(v_n + v_{n+1})$\n5. Set $a_{n+1} \\leftarrow a_{n+1}^{(p)}$ for the next step.\n\nThis algorithm, despite using only one force evaluation per step, violates the principles of geometric integration. The core flaw is a fundamental inconsistency in how the state $(x, v)$ is advanced.\n\nIn step $3$, the velocity $v_{n+1}$ is computed using the force evaluated at a temporary, a *predicted* position $x_{n+1}^{(p)}$. In step $4$, this new velocity is used to compute the final position $x_{n+1}$. This final position $x_{n+1}$ is, in general, not equal to the predicted position $x_{n+1}^{(p)}$. Crucially, the force at the final position, $F(x_{n+1})$, is never computed or used. This breaks the symmetric structure that underpins symplecticity.\n\nBy substituting step $3$ into step $4$, we can find the explicit update rule for the position:\n$$\nx_{n+1} = x_n + \\frac{\\Delta t}{2}\\left(v_n + \\left[v_n + \\frac{\\Delta t}{2}(a_n + a_{n+1}^{(p)})\\right]\\right) = x_n + \\Delta t v_n + \\frac{\\Delta t^2}{4}(a_n + a_{n+1}^{(p)})\n$$\nUnlike velocity-Verlet, where the position update has a $\\frac{\\Delta t^2}{2}a_n$ term, this method's position update depends on a future (predicted) acceleration. This asymmetric dependence breaks the time-reversibility of the map $(x_n, v_n) \\to (x_{n+1}, v_{n+1})$. Since time-reversibility is a necessary condition for symplecticity, this integrator is non-symplectic.\n\nFor a non-symplectic integrator, there is no conserved shadow Hamiltonian. Numerical errors accumulate in a biased manner, leading to a secular drift in the total energy $H$. This means the energy will systematically increase or decrease over long simulations. This drift is a genuine artifact of the algorithm, not just random error, and its rate is expected to increase with the time step $\\Delta t$.\n\n**Numerical Demonstration**\n\nThe provided code implements both integrators to generate trajectories for the given test cases. For each trajectory, the total energy $H(t_i) = \\frac{1}{2} m v_i^2 + V(x_i)$ is computed at each time step $t_i$. The energy drift rate $\\beta$ is quantified by performing an ordinary least-squares linear regression of the energy deviation $y_i = H(t_i) - H(0)$ against time $t_i$. The slope of this regression, $\\beta$, measures the average rate of energy change. We expect $\\beta \\approx 0$ for velocity-Verlet and a non-zero, $\\Delta t$-dependent $\\beta$ for the predictor-corrector scheme, thus providing numerical evidence for the degradation of symplecticity and the resulting energy drift.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity-Verlet and a Predictor-Corrector Verlet\n    integrator for a 1D nonlinear oscillator, quantifying the energy drift.\n    \"\"\"\n\n    def acceleration(x, m, k, lambda_):\n        \"\"\"Computes acceleration a = F/m.\"\"\"\n        force = -k * x - lambda_ * x**3\n        return force / m\n\n    def hamiltonian(x, v, m, k, lambda_):\n        \"\"\"Computes the Hamiltonian H = K + V.\"\"\"\n        potential_energy = 0.5 * k * x**2 + 0.25 * lambda_ * x**4\n        kinetic_energy = 0.5 * m * v**2\n        return kinetic_energy + potential_energy\n\n    def calculate_drift_slope(t_vals, H_vals):\n        \"\"\"\n        Estimates the drift slope beta via ordinary least squares, as defined\n        in the problem statement.\n        \"\"\"\n        y_vals = H_vals - H_vals[0]\n        t_mean = np.mean(t_vals)\n        y_mean = np.mean(y_vals)\n        \n        numerator = np.sum((t_vals - t_mean) * (y_vals - y_mean))\n        denominator = np.sum((t_vals - t_mean)**2)\n        \n        if denominator == 0.0:\n            return 0.0\n            \n        return numerator / denominator\n\n    def run_velocity_verlet(m, k, lambda_, x0, v0, dt, T_total):\n        \"\"\"Runs a simulation using the Velocity-Verlet integrator.\"\"\"\n        num_steps = int(round(T_total / dt))\n        t_vals = np.linspace(0, num_steps * dt, num_steps + 1)\n        H_vals = np.zeros(num_steps + 1)\n        \n        x, v = x0, v0\n        a = acceleration(x, m, k, lambda_)\n        \n        H_vals[0] = hamiltonian(x, v, m, k, lambda_)\n        \n        for i in range(num_steps):\n            # 1. Half-kick\n            v_half = v + 0.5 * dt * a\n            # 2. Drift\n            x_new = x + dt * v_half\n            # 3. Force calculation at new position\n            a_new = acceleration(x_new, m, k, lambda_)\n            # 4. Half-kick\n            v_new = v_half + 0.5 * dt * a_new\n            \n            # Update state for next iteration\n            x, v, a = x_new, v_new, a_new\n            \n            # Store Hamiltonian\n            H_vals[i + 1] = hamiltonian(x, v, m, k, lambda_)\n            \n        return t_vals, H_vals\n\n    def run_predictor_corrector_verlet(m, k, lambda_, x0, v0, dt, T_total):\n        \"\"\"Runs a simulation using the specified Predictor-Corrector integrator.\"\"\"\n        num_steps = int(round(T_total / dt))\n        t_vals = np.linspace(0, num_steps * dt, num_steps + 1)\n        H_vals = np.zeros(num_steps + 1)\n        \n        x, v = x0, v0\n        # a_n is stored from the previous step\n        a = acceleration(x, m, k, lambda_)\n        \n        H_vals[0] = hamiltonian(x, v, m, k, lambda_)\n\n        for i in range(num_steps):\n            # 1. Predictor for position\n            x_p = x + dt * v + 0.5 * dt**2 * a\n            # 2. Predicted force/acceleration\n            a_p = acceleration(x_p, m, k, lambda_)\n            # 3. Corrector for velocity\n            v_new = v + 0.5 * dt * (a + a_p)\n            # 4. Corrector for position\n            x_new = x + 0.5 * dt * (v + v_new)\n            \n            # Update state for next iteration\n            x = x_new\n            v = v_new\n            # 5. Set a_{n+1} <- a_{n+1}^{(p)} for the next step's \"a_n\"\n            a = a_p\n            \n            # Store Hamiltonian\n            H_vals[i + 1] = hamiltonian(x, v, m, k, lambda_)\n            \n        return t_vals, H_vals\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, k, lambda, x0, v0, dt, T_total)\n        (1.0, 1.0, 1.0, 1.0, 0.0, 0.005, 2000.0), # Case A\n        (1.0, 1.0, 1.0, 1.0, 0.0, 0.020, 2000.0), # Case B\n        (1.0, 1.0, 1.0, 1.0, 0.0, 0.050, 2000.0), # Case C\n        (1.0, 1.0, 1.0, 1.0, 0.0, 0.080, 500.0),  # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        m, k, lambda_, x0, v0, dt, T_total = params\n\n        # Run Velocity-Verlet simulation and calculate drift\n        t_vv, H_vv = run_velocity_verlet(m, k, lambda_, x0, v0, dt, T_total)\n        slope_vv = calculate_drift_slope(t_vv, H_vv)\n        results.append(slope_vv)\n        \n        # Run Predictor-Corrector Verlet simulation and calculate drift\n        t_pcv, H_pcv = run_predictor_corrector_verlet(m, k, lambda_, x0, v0, dt, T_total)\n        slope_pcv = calculate_drift_slope(t_pcv, H_pcv)\n        results.append(slope_pcv)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A stable long-term integration is only useful if we can extract accurate physical observables from the resulting trajectory. The staggered time-stepping inherent to leapfrog and velocity-Verlet integrators, while crucial for their stability, requires careful consideration when defining instantaneous quantities like kinetic energy. This exercise  tackles this practical challenge by analyzing different estimators for kinetic temperature, revealing how a naive approach can introduce significant systematic error and demonstrating how to derive a consistent estimator.",
            "id": "3438596",
            "problem": "Consider a single particle of mass $m$ moving in one spatial dimension under the harmonic potential $U(x) = \\frac{1}{2} m \\omega^{2} x^{2}$. Its dynamics are integrated using the leapfrog scheme, a staggered-velocity Verlet-type integrator, with fixed time step $h > 0$. Let the position samples be $x_{n} = x(t_{n})$ with $t_{n} = n h$, and the velocities be staggered at half-steps $v_{n+\\frac{1}{2}} \\approx \\dot{x}(t_{n+\\frac{1}{2}})$.\n\nIn Molecular Dynamics (MD), the kinetic temperature estimator per degree of freedom follows from the equipartition theorem: with Boltzmann constant $k_{B}$, one uses $T = \\frac{m}{k_{B}} \\langle v^{2} \\rangle$, where $\\langle \\cdot \\rangle$ denotes a long-time average under stationary sampling. Two practical estimators are often constructed:\n- A staggered estimator $T_{\\mathrm{half}}$ using the leapfrog velocities $v_{n+\\frac{1}{2}}$.\n- A naive end-step estimator $T_{\\mathrm{end}}$ using end-step velocities $\\tilde{v}_{n} = \\frac{x_{n+1} - x_{n}}{h}$.\n\nStarting from Newton’s second law $m \\ddot{x} = - m \\omega^{2} x$ and the exact harmonic motion $x(t) = A \\cos(\\omega t + \\phi)$ with amplitude $A$ and phase $\\phi$, derive the closed-form multiplicative bias factor $F(\\omega h)$ defined by\n$$\nF(\\omega h) \\equiv \\frac{T_{\\mathrm{end}}}{T_{\\mathrm{half}}},\n$$\nassuming stationary sampling over many steps so that time averages of sinusoidal functions are well-defined. Show explicitly that the leading-order deviation of $F(\\omega h)$ from unity is of order $h^{2}$ and quantify it via a series expansion, but express your final answer as a single closed-form analytic expression for $F(\\omega h)$. The factor $F(\\omega h)$ is unitless. No numerical rounding is required, and no physical units are to be reported in the final expression.",
            "solution": "The problem requires the derivation of the multiplicative bias factor $F(\\omega h)$ relating two different estimators for kinetic temperature in a molecular dynamics simulation of a one-dimensional harmonic oscillator. The factor is defined as the ratio of the temperatures, $F(\\omega h) = T_{\\mathrm{end}} / T_{\\mathrm{half}}$.\n\nAccording to the equipartition theorem, the kinetic temperature $T$ per degree of freedom is given by $T = \\frac{m}{k_{B}} \\langle v^{2} \\rangle$, where $m$ is the particle mass, $k_B$ is the Boltzmann constant, and $\\langle v^2 \\rangle$ is the time-averaged squared velocity. The bias factor $F(\\omega h)$ can therefore be expressed as the ratio of the mean squared velocities of the two estimators:\n$$\nF(\\omega h) = \\frac{T_{\\mathrm{end}}}{T_{\\mathrm{half}}} = \\frac{\\frac{m}{k_{B}} \\langle \\tilde{v}_{n}^2 \\rangle}{\\frac{m}{k_{B}} \\langle v_{n+\\frac{1}{2}}^2 \\rangle} = \\frac{\\langle \\tilde{v}_{n}^2 \\rangle}{\\langle v_{n+\\frac{1}{2}}^2 \\rangle}\n$$\nWe are instructed to evaluate these estimators by sampling the exact trajectory of the harmonic oscillator, which is given by $x(t) = A \\cos(\\omega t + \\phi)$, where $A$ is the amplitude and $\\phi$ is the phase. The discrete positions are thus $x_n = x(t_n) = x(nh) = A \\cos(\\omega n h + \\phi)$.\n\nFirst, we analyze the naive end-step velocity estimator, $\\tilde{v}_{n}$, defined as:\n$$\n\\tilde{v}_{n} = \\frac{x_{n+1} - x_{n}}{h}\n$$\nSubstituting the expressions for $x_n$ and $x_{n+1}$ from the exact trajectory:\n$$\n\\tilde{v}_{n} = \\frac{A \\cos(\\omega(n+1)h + \\phi) - A \\cos(\\omega n h + \\phi)}{h}\n$$\nUsing the trigonometric identity $\\cos B - \\cos C = -2 \\sin\\left(\\frac{B+C}{2}\\right) \\sin\\left(\\frac{B-C}{2}\\right)$, we find:\n$$\n\\tilde{v}_{n} = \\frac{A}{h} \\left[ -2 \\sin\\left(\\omega n h + \\frac{\\omega h}{2} + \\phi\\right) \\sin\\left(\\frac{\\omega h}{2}\\right) \\right] = -\\frac{2A}{h} \\sin\\left(\\frac{\\omega h}{2}\\right) \\sin\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right)\n$$\nThe square of this velocity is:\n$$\n\\tilde{v}_{n}^2 = \\frac{4A^2}{h^2} \\sin^2\\left(\\frac{\\omega h}{2}\\right) \\sin^2\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right)\n$$\nTo compute the time average $\\langle \\tilde{v}_{n}^2 \\rangle$, we average over many steps $n$. The problem assumes stationary sampling, under which the time average of a squared sinusoidal function over many periods is $\\frac{1}{2}$.\n$$\n\\langle \\sin^2\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right) \\rangle = \\frac{1}{2}\n$$\nTherefore, the mean squared end-step velocity is:\n$$\n\\langle \\tilde{v}_{n}^2 \\rangle = \\frac{4A^2}{h^2} \\sin^2\\left(\\frac{\\omega h}{2}\\right) \\cdot \\frac{1}{2} = \\frac{2A^2}{h^2} \\sin^2\\left(\\frac{\\omega h}{2}\\right)\n$$\nNext, we analyze the staggered estimator $T_{\\mathrm{half}}$, which uses the leapfrog velocities $v_{n+\\frac{1}{2}}$. The problem states $v_{n+\\frac{1}{2}} \\approx \\dot{x}(t_{n+\\frac{1}{2}})$. The staggered velocity in the leapfrog scheme is known to be a high-accuracy representation of the true velocity at the half-time step. We interpret this to mean that the reference temperature, $T_{\\mathrm{half}}$, is computed using the exact instantaneous velocity at the half-steps, $t_{n+\\frac{1}{2}} = (n+\\frac{1}{2})h$. The exact velocity is the time derivative of the position: $\\dot{x}(t) = -A\\omega \\sin(\\omega t + \\phi)$.\nSo, we define $v_{n+\\frac{1}{2}}$ as:\n$$\nv_{n+\\frac{1}{2}} = \\dot{x}(t_{n+\\frac{1}{2}}) = -A\\omega \\sin\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right)\n$$\nThe square of this velocity is:\n$$\nv_{n+\\frac{1}{2}}^2 = A^2 \\omega^2 \\sin^2\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right)\n$$\nTaking the time average, we again use $\\langle \\sin^2(\\cdot) \\rangle = \\frac{1}{2}$:\n$$\n\\langle v_{n+\\frac{1}{2}}^2 \\rangle = A^2 \\omega^2 \\langle \\sin^2\\left(\\omega\\left(n+\\frac{1}{2}\\right)h + \\phi\\right) \\rangle = \\frac{1}{2} A^2 \\omega^2\n$$\nNow we can compute the bias factor $F(\\omega h)$ by taking the ratio of the two mean squared velocities:\n$$\nF(\\omega h) = \\frac{\\langle \\tilde{v}_{n}^2 \\rangle}{\\langle v_{n+\\frac{1}{2}}^2 \\rangle} = \\frac{\\frac{2A^2}{h^2} \\sin^2\\left(\\frac{\\omega h}{2}\\right)}{\\frac{1}{2} A^2 \\omega^2} = \\frac{4 \\sin^2\\left(\\frac{\\omega h}{2}\\right)}{h^2 \\omega^2}\n$$\nThis expression can be simplified by defining a dimensionless variable $z = \\frac{\\omega h}{2}$:\n$$\nF(\\omega h) = \\frac{\\sin^2(z)}{z^2} = \\left(\\frac{\\sin(z)}{z}\\right)^2 = \\mathrm{sinc}^2(z)\n$$\nSubstituting $z$ back, the final closed-form expression is:\n$$\nF(\\omega h) = \\left( \\frac{\\sin\\left(\\frac{\\omega h}{2}\\right)}{\\frac{\\omega h}{2}} \\right)^2\n$$\nTo verify the leading-order deviation from unity, we perform a Taylor series expansion of $F(\\omega h)$ for small $h$. Let $z = \\frac{\\omega h}{2}$. The expansion of $\\sin(z)$ is $\\sin(z) = z - \\frac{z^3}{3!} + \\frac{z^5}{5!} - \\dots$.\nThen, the sinc function is:\n$$\n\\frac{\\sin(z)}{z} = 1 - \\frac{z^2}{6} + \\frac{z^4}{120} - \\dots\n$$\nSquaring this expression gives:\n$$\nF(z) = \\left(1 - \\frac{z^2}{6} + \\frac{z^4}{120} - \\dots\\right)^2 = 1 - 2\\left(\\frac{z^2}{6}\\right) + \\left(\\left(\\frac{z^2}{6}\\right)^2 + 2\\left(\\frac{z^4}{120}\\right)\\right) + \\dots\n$$\n$$\nF(z) = 1 - \\frac{z^2}{3} + \\left(\\frac{z^4}{36} + \\frac{z^4}{60}\\right) + \\dots = 1 - \\frac{z^2}{3} + \\frac{2z^4}{45} + \\dots\n$$\nSubstituting $z = \\frac{\\omega h}{2}$ back into the expansion:\n$$\nF(\\omega h) = 1 - \\frac{1}{3}\\left(\\frac{\\omega h}{2}\\right)^2 + O(h^4) = 1 - \\frac{(\\omega h)^2}{12} + O(h^4)\n$$\nThis confirms that the leading-order deviation of $F(\\omega h)$ from unity is of order $h^2$, and the specific coefficient is $-\\frac{\\omega^2}{12}$. The bias leads to an underestimation of the kinetic temperature when using the naive end-step velocity estimator.",
            "answer": "$$\n\\boxed{\\left(\\frac{\\sin\\left(\\frac{\\omega h}{2}\\right)}{\\frac{\\omega h}{2}}\\right)^2}\n$$"
        }
    ]
}