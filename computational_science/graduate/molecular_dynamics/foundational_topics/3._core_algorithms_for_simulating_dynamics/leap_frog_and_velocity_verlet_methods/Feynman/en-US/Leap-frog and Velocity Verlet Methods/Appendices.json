{
    "hands_on_practices": [
        {
            "introduction": "The leap-frog method's elegance lies in its staggered time-grid, but this creates a practical puzzle: how do we start the simulation? Given initial position and velocity at time $t=0$, we must correctly determine the half-step velocity to ensure the algorithm's second-order accuracy is not compromised from the outset. This foundational exercise () walks you through the Taylor series derivation needed to solve this essential \"bootstrap\" problem.",
            "id": "3420452",
            "problem": "Consider a single particle of mass $m$ evolving under a smooth, position-dependent force $\\mathbf{F}(\\mathbf{r})$ according to Newton's second law $m\\,\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))$. In Molecular Dynamics (MD), the leap-frog integrator advances the position by one step using the half-step velocity via $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$, while the velocity update is centered at half-steps. At time $t=0$, the initial data $\\mathbf{r}^{0}=\\mathbf{r}(0)$ and $\\mathbf{v}^{0}=\\mathbf{v}(0)$ are given. You wish to initialize the half-step velocity $\\mathbf{v}^{1/2}$ at time $t=h/2$ using only $\\mathbf{r}^{0}$, $\\mathbf{v}^{0}$, $h$, $m$, and $\\mathbf{F}(\\mathbf{r}^{0})$, so that the very first position update $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$ achieves local error $\\mathcal{O}(h^{3})$, i.e., the scheme is $2$nd-order accurate at the first step.\n\nStarting from the fundamental definitions $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ and $\\mathbf{a}(t)=\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))/m$, use a Taylor expansion about $t=0$ to derive a consistency condition that $\\mathbf{v}^{1/2}$ must satisfy so that $\\mathbf{r}^{1}$ matches the exact position $\\mathbf{r}(h)$ to within $\\mathcal{O}(h^{3})$. Then, provide an explicit formula for $\\mathbf{v}^{1/2}$ expressed only in terms of the given quantities. Your final answer must be a single closed-form analytic expression for $\\mathbf{v}^{1/2}$.",
            "solution": "The problem requires the derivation of an initialization formula for the half-step velocity, $\\mathbf{v}^{1/2}$, in a leap-frog integration scheme. This initialization must ensure that the first position update, $\\mathbf{r}^{1}$, is second-order accurate, meaning the local error relative to the exact solution $\\mathbf{r}(h)$ is of order $\\mathcal{O}(h^3)$. The formula for $\\mathbf{v}^{1/2}$ can only depend on the initial position $\\mathbf{r}^{0}$, initial velocity $\\mathbf{v}^{0}$, time step $h$, mass $m$, and the force $\\mathbf{F}(\\mathbf{r}^{0})$ evaluated at the initial position.\n\nWe begin by finding the exact position of the particle at time $t=h$ by performing a Taylor series expansion of $\\mathbf{r}(t)$ around $t=0$. The particle's motion is governed by Newton's second law, $m\\,\\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))$. We are given the definitions $\\mathbf{v}(t) = \\dot{\\mathbf{r}}(t)$ and $\\mathbf{a}(t) = \\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$. The Taylor expansion of $\\mathbf{r}(t)$ around $t=0$ is:\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0) + t\\,\\dot{\\mathbf{r}}(0) + \\frac{t^2}{2!}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(t^3)\n$$\nEvaluating at $t=h$ and using the initial conditions $\\mathbf{r}(0) = \\mathbf{r}^0$ and $\\dot{\\mathbf{r}}(0) = \\mathbf{v}^0$, we get:\n$$\n\\mathbf{r}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(h^3)\n$$\nThe acceleration at $t=0$ is $\\mathbf{a}^{0} = \\ddot{\\mathbf{r}}(0) = \\mathbf{F}(\\mathbf{r}(0))/m = \\mathbf{F}(\\mathbf{r}^0)/m$. Substituting this into the expansion gives the exact position up to order $h^2$:\n$$\n\\mathbf{r}_{exact}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^3)\n$$\nThe numerical approximation for the position at the first time step is given by the leap-frog update rule:\n$$\n\\mathbf{r}^{1} = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2}\n$$\nThe local error for this first step is the difference between the exact position $\\mathbf{r}_{exact}(h)$ and the numerical approximation $\\mathbf{r}^{1}$. The problem requires this error to be of order $\\mathcal{O}(h^3)$:\n$$\n\\mathbf{r}_{exact}(h) - \\mathbf{r}^{1} = \\mathcal{O}(h^3)\n$$\nSubstituting the expressions for $\\mathbf{r}_{exact}(h)$ and $\\mathbf{r}^{1}$:\n$$\n\\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} \\right) - \\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2} \\right) = \\mathcal{O}(h^3)\n$$\nThe term $\\mathbf{r}^{0}$ cancels out. We are left with:\n$$\nh\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} - h\\,\\mathbf{v}^{1/2} = \\mathcal{O}(h^3)\n$$\nTo isolate the condition on $\\mathbf{v}^{1/2}$, we divide the entire equation by the time step $h$:\n$$\n\\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} - \\mathbf{v}^{1/2} = \\mathcal{O}(h^2)\n$$\nRearranging this equation gives the consistency condition that $\\mathbf{v}^{1/2}$ must satisfy:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\nThis condition implies that $\\mathbf{v}^{1/2}$ must be a first-order approximation (in $h$) to the exact velocity at the half-time-step, $t=h/2$. We can verify this by Taylor expanding the exact velocity $\\mathbf{v}(t)$ around $t=0$:\n$$\n\\mathbf{v}(t) = \\mathbf{v}(0) + t\\,\\dot{\\mathbf{v}}(0) + \\mathcal{O}(t^2) = \\mathbf{v}^{0} + t\\,\\mathbf{a}^{0} + \\mathcal{O}(t^2)\n$$\nEvaluating at $t=h/2$:\n$$\n\\mathbf{v}(h/2) = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\nComparing this with the consistency condition for $\\mathbf{v}^{1/2}$, we see that $\\mathbf{v}^{1/2}$ must agree with $\\mathbf{v}(h/2)$ up to terms of order $\\mathcal{O}(h)$.\n\nTo obtain an explicit formula for $\\mathbf{v}^{1/2}$, we can satisfy the consistency condition by simply truncating the series expansion, i.e., dropping the $\\mathcal{O}(h^2)$ term. This gives:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0}\n$$\nThis choice provides the simplest explicit formula that meets the accuracy requirement. The quantities on the right-hand side are the initial velocity $\\mathbf{v}^{0}$, the time step $h$, and the initial acceleration $\\mathbf{a}^{0}$. The problem specifies that the formula must only use $\\mathbf{r}^{0}$, $\\mathbf{v}^{0}$, $h$, $m$, and $\\mathbf{F}(\\mathbf{r}^{0})$. Since $\\mathbf{a}^{0} = \\mathbf{F}(\\mathbf{r}^{0})/m$, our expression for $\\mathbf{v}^{1/2}$ satisfies this constraint.\n\nSubstituting $\\mathbf{a}^0$:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})\n$$\nThis is the required explicit formula for the initial half-step velocity to achieve second-order accuracy in the first position step of the leap-frog integration.",
            "answer": "$$\\boxed{\\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})}$$"
        },
        {
            "introduction": "While both velocity Verlet and leap-frog are celebrated as second-order accurate methods, a deeper analysis reveals subtle but important differences in their error characteristics. This practice () invites you to dissect their performance by deriving the local truncation error constants for the harmonic oscillator. This analytical exercise provides a rigorous understanding of how each algorithm's error manifests in position and velocity, clarifying their respective strengths.",
            "id": "3420490",
            "problem": "Consider the one-dimensional harmonic oscillator governed by Newton’s second law $m\\ddot{x}(t) = -k x(t)$ with angular frequency $\\omega = \\sqrt{k/m}$, as treated in Molecular Dynamics (MD). Let $h$ denote a constant time step and use the standard definitions of the leap-frog method (velocities stored at half steps) and the velocity Verlet method (positions and velocities stored at integer steps). Define the local truncation error for a method as the difference between the exact solution advanced by one step and the single-step numerical update applied to exact data at the method’s native time indices. Specifically, define the local truncation error constants $C_{x}$ and $C_{v}$ for position and velocity, respectively, by the leading-order terms\n$$\\text{LTE}_{x} = C_{x}\\,h^{3}\\,x^{(3)}(t) + \\mathcal{O}(h^{4}), \\qquad \\text{LTE}_{v} = C_{v}\\,h^{3}\\,x^{(4)}(t) + \\mathcal{O}(h^{4}),$$\nwith $x^{(3)}(t)$ and $x^{(4)}(t)$ evaluated along the exact solution. For the leap-frog method, take the velocity variable at the half step $t+h/2$ when defining $C_{v}$; for the velocity Verlet method, take the velocity at the integer step $t+h$.\n\nStarting only from Newton’s laws and the definitions $v=\\dot{x}$, $a=\\ddot{x}$, and the Taylor expansions of $x(t+h)$ and $v(t+h)$ about $t$, derive the local truncation error constants $C_{x}$ and $C_{v}$ for the velocity Verlet method applied to $m\\ddot{x}=-kx$, and then derive the corresponding constants for the leap-frog method (with velocity at the half step). Express your final answer as a single row matrix using the LaTeX `pmatrix` environment in the order\n$$\\big(C_{x}^{\\text{VV}},\\; C_{v}^{\\text{VV}},\\; C_{x}^{\\text{LF}},\\; C_{v,\\;1/2}^{\\text{LF}}\\big),$$\nwhere “VV” denotes velocity Verlet and “LF” denotes leap-frog. No rounding is required; provide exact rational numbers. The final answer has no physical units.",
            "solution": "We begin with the harmonic oscillator $m\\ddot{x}(t)=-k x(t)$ and introduce $\\omega=\\sqrt{k/m}$. Along the exact solution, the time derivatives satisfy\n$$x''(t) = -\\omega^{2} x(t), \\quad x^{(3)}(t) = \\frac{d}{dt}x''(t) = -\\omega^{2} v(t), \\quad x^{(4)}(t) = \\frac{d}{dt}x^{(3)}(t) = \\omega^{4} x(t).$$\nThe Taylor expansions of the exact solution at time $t+h$ are\n\\begin{align*}\nx(t+h) = x(t) + h v(t) + \\frac{h^{2}}{2} x''(t) + \\frac{h^{3}}{6} x^{(3)}(t) + \\frac{h^{4}}{24} x^{(4)}(t) + \\mathcal{O}(h^{5}), \\\\\nv(t+h) = v(t) + h x''(t) + \\frac{h^{2}}{2} x^{(3)}(t) + \\frac{h^{3}}{6} x^{(4)}(t) + \\frac{h^{4}}{24} x^{(5)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\nwith $x^{(5)}(t) = \\omega^{4} v(t)$, etc.\n\nVelocity Verlet method. Given exact $(x(t), v(t))$ and $a(t) = x''(t) = -\\omega^{2} x(t)$, the velocity Verlet update is\n\\begin{align*}\nx_{\\text{VV}}(t+h) = x(t) + h v(t) + \\frac{h^{2}}{2} a(t), \\\\\na(t+h) = -\\omega^{2} x_{\\text{VV}}(t+h), \\\\\nv_{\\text{VV}}(t+h) = v(t) + \\frac{h}{2}\\big(a(t) + a(t+h)\\big).\n\\end{align*}\nSubstituting $a(t)=-\\omega^{2} x(t)$ gives\n$$x_{\\text{VV}}(t+h) = x(t) + h v(t) - \\frac{h^{2}}{2}\\omega^{2} x(t).$$\nComparing to $x(t+h)$, the local truncation error for position is\n\\begin{align*}\n\\text{LTE}_{x}^{\\text{VV}} = x(t+h) - x_{\\text{VV}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{24}\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\nso the leading constant is $C_{x}^{\\text{VV}} = \\frac{1}{6}$.\n\nFor velocity, first note $x_{\\text{VV}}(t+h) = x(t) + h v(t) - \\frac{h^{2}}{2}\\omega^{2} x(t)$, so\n\\begin{align*}\na(t+h) = -\\omega^{2} x_{\\text{VV}}(t+h) \\\\\n= -\\omega^{2} x(t) - \\omega^{2} h v(t) + \\frac{h^{2}}{2} \\omega^{4} x(t).\n\\end{align*}\nThen\n\\begin{align*}\nv_{\\text{VV}}(t+h) = v(t) + \\frac{h}{2}\\left[-\\omega^{2} x(t) + \\left(-\\omega^{2} x(t) - \\omega^{2} h v(t) + \\frac{h^{2}}{2} \\omega^{4} x(t)\\right)\\right] \\\\\n= v(t) - h \\omega^{2} x(t) - \\frac{h^{2}}{2} \\omega^{2} v(t) + \\frac{h^{3}}{4} \\omega^{4} x(t) \\\\\n= v(t) + h x''(t) + \\frac{h^{2}}{2} x^{(3)}(t) + \\frac{h^{3}}{4} x^{(4)}(t).\n\\end{align*}\nComparing to the exact $v(t+h)$,\n\\begin{align*}\n\\text{LTE}_{v}^{\\text{VV}} = v(t+h) - v_{\\text{VV}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6} - \\frac{h^{3}}{4}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}) = -\\left(\\frac{h^{3}}{12}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}),\n\\end{align*}\nso $C_{v}^{\\text{VV}} = -\\frac{1}{12}$.\n\nLeap-frog method. The leap-frog scheme stores velocities at half steps. Assume exact values $x(t)$ and $v(t - h/2)$ at input. The leap-frog update is\n\\begin{align*}\nv_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) = v\\!\\left(t-\\frac{h}{2}\\right) + h\\,a(t), \\\\\nx_{\\text{LF}}(t+h) = x(t) + h\\,v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right),\n\\end{align*}\nwith $a(t) = -\\omega^{2} x(t)$. Expand $v(t \\pm h/2)$ about $t$:\n\\begin{align*}\nv\\!\\left(t+\\frac{h}{2}\\right) = v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) + \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}), \\\\\nv\\!\\left(t-\\frac{h}{2}\\right) = v(t) - \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}).\n\\end{align*}\nThen\n\\begin{align*}\nv_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) = \\left[v(t) - \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t)\\right] + h a(t) + \\mathcal{O}(h^{4}) \\\\\n= v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}).\n\\end{align*}\nComparing to $v\\!\\left(t+\\frac{h}{2}\\right)$ shows the local truncation error for the half-step velocity:\n\\begin{align*}\n\\text{LTE}_{v,\\;1/2}^{\\text{LF}} = v\\!\\left(t+\\frac{h}{2}\\right) - v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) \\\\\n= \\left(\\frac{h^{3}}{48} - \\left(-\\frac{h^{3}}{48}\\right)\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}) = \\left(\\frac{h^{3}}{24}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}),\n\\end{align*}\nso $C_{v,\\;1/2}^{\\text{LF}} = \\frac{1}{24}$.\n\nFor position,\n\\begin{align*}\nx_{\\text{LF}}(t+h) = x(t) + h\\,v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) \\\\\n= x(t) + h\\left[ v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) \\right] + \\mathcal{O}(h^{5}) \\\\\n= x(t) + h v(t) + \\frac{h^{2}}{2} a(t) + \\frac{h^{3}}{8} x^{(3)}(t) - \\frac{h^{4}}{48} x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\nso\n\\begin{align*}\n\\text{LTE}_{x}^{\\text{LF}} = x(t+h) - x_{\\text{LF}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6} - \\frac{h^{3}}{8}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{24} - \\left(-\\frac{h^{4}}{48}\\right)\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}) \\\\\n= \\left(\\frac{h^{3}}{24}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{16}\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\nand hence $C_{x}^{\\text{LF}} = \\frac{1}{24}$.\n\nSummary. The leading local truncation error constants defined by $\\text{LTE}_{x} = C_{x} h^{3} x^{(3)}(t) + \\mathcal{O}(h^{4})$ and $\\text{LTE}_{v} = C_{v} h^{3} x^{(4)}(t) + \\mathcal{O}(h^{4})$ are\n\\begin{align*}\nC_{x}^{\\text{VV}} = \\frac{1}{6}, \\\\\nC_{v}^{\\text{VV}} = -\\frac{1}{12}, \\\\\nC_{x}^{\\text{LF}} = \\frac{1}{24}, \\\\\nC_{v,\\;1/2}^{\\text{LF}} = \\frac{1}{24}.\n\\end{align*}\nThese results show both methods are second-order accurate, with leap-frog having a smaller leading constant for position than velocity Verlet, while the sign structure for velocity differs because of the distinct averaging operations in the respective updates.",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{6}  -\\frac{1}{12}  \\frac{1}{24}  \\frac{1}{24}\\end{pmatrix}}$$"
        },
        {
            "introduction": "The theoretical guarantees of energy conservation for Verlet integrators hinge on the force being a smooth function of position, a condition not always met in practical models. This hands-on coding problem () explores the consequences of violating this assumption by simulating motion in a potential with a sharp \"cusp.\" You will witness the integrator's failure to conserve energy and then implement standard regularization techniques to restore stability, gaining valuable insight into the robustness and limitations of these powerful algorithms.",
            "id": "3420474",
            "problem": "Consider a one-dimensional particle of mass $m$ moving under a time-independent potential energy function $V(q)$. The motion obeys Newton’s second law $m \\,\\mathrm{d}^{2}q/\\mathrm{d}t^{2} = F(q)$ with $F(q) = -\\mathrm{d}V/\\mathrm{d}q$. You will examine the behavior of two symplectic integrators commonly used in molecular dynamics, namely the leap-frog method and the velocity Verlet method, when the force is non-Lipschitz at a point. Specifically, consider the cusp potential $V(q) = |q|$, which induces the piecewise constant force $F(q) = -\\mathrm{sign}(q)$ that is undefined at $q=0$ and non-Lipschitz in any neighborhood of $q=0$. You will study failure modes of these integrators for this potential, and then test regularization strategies that smooth the cusp near $q=0$ to restore Lipschitz continuity of the force.\n\nYour tasks are:\n- Implement the leap-frog method and the velocity Verlet method starting from Newton’s second law, without using any pre-packaged ordinary differential equation solver.\n- Implement three potentials:\n  - The cusp potential $V(q)=|q|$, with the naive convention $F(0)=0$.\n  - A smooth regularization $V_{\\varepsilon}(q) = \\sqrt{q^{2} + \\varepsilon^{2}}$, parameterized by $\\varepsilon  0$, which yields $F_{\\varepsilon}(q) = -q/\\sqrt{q^{2} + \\varepsilon^{2}}$.\n  - A Huber-type regularization $V_{\\delta}(q)$ defined by $V_{\\delta}(q) = \\frac{q^{2}}{2\\delta}$ if $|q| \\le \\delta$ and $V_{\\delta}(q) = |q| - \\frac{\\delta}{2}$ if $|q|  \\delta$, which yields $F_{\\delta}(q) = -q/\\delta$ if $|q| \\le \\delta$ and $F_{\\delta}(q) = -\\mathrm{sign}(q)$ if $|q|  \\delta$.\n- For each simulation, compute the discrete total energy $E_{n} = \\frac{1}{2} m v_{n}^{2} + V(q_{n})$ at equally spaced times $t_{n} = n\\,\\Delta t$ for $n=0,1,\\dots,N$, with time step $\\Delta t$ and total integration time $T = N \\,\\Delta t$.\n- Quantify long-time energy drift by fitting a least-squares line $E(t) \\approx s\\,t + b$ to $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$ and reporting the fitted slope $s$. This slope $s$ is your scalar performance metric for each test. Report $s$ in dimensionless energy per unit time, since all quantities are to be treated in dimensionless units.\n\nScientific and numerical requirements:\n- Begin from Newton’s second law and standard definitions of velocity and acceleration.\n- Do not use any pre-packaged ordinary differential equation solvers.\n- Use dimensionless units with $m=1$, and report the energy-drift slope $s$ in the same dimensionless units (energy per unit time).\n- Angles are not involved; no angle units are required.\n\nTest suite:\nUse the following test cases, each defined by a tuple of parameters $(\\text{integrator}, \\text{potential}, \\Delta t, T, q_{0}, v_{0}, \\text{reg\\_param})$, where $m=1$ throughout, the integrator is either leap-frog or velocity Verlet, the potential is one of the three described above, and $\\text{reg\\_param}$ is unused for the cusp potential. For the smooth regularization use $\\varepsilon$ as $\\text{reg\\_param}$, and for the Huber regularization use $\\delta$ as $\\text{reg\\_param}$.\n\n- Case A: $(\\text{velocity\\ Verlet}, \\text{cusp}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case B: $(\\text{leap\\text{-}frog}, \\text{cusp}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case C: $(\\text{velocity\\ Verlet}, \\text{cusp}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case D: $(\\text{velocity\\ Verlet}, \\text{smooth}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\varepsilon = 10^{-2})$.\n- Case E: $(\\text{leap\\text{-}frog}, \\text{Huber}, \\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\delta = 10^{-2})$.\n- Case F: $(\\text{velocity\\ Verlet}, \\text{cusp}, \\Delta t = 0.05, T = 20.0, q_{0} = 0.0, v_{0} = 0.1, \\text{reg\\_param} = \\text{None})$.\n\nYour program should:\n- Implement both integrators and all three potentials as described.\n- For each test case, integrate up to time $T$ with step $\\Delta t$, compute the sequence $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$, and output the least-squares slope $s$ of $E$ versus $t$.\n- Aggregate the slopes for Cases A through F in that order into a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result\\_A}, \\text{result\\_B}, \\dots, \\text{result\\_F}]$.\n\nAll outputs must be reported in the specified dimensionless energy per unit time. The final output must be exactly one line in the format described above, with no additional text or lines.",
            "solution": "The problem requires the implementation and comparison of two numerical integrators, the leap-frog and velocity Verlet methods, for a one-dimensional particle of mass $m=1$ under a potential $V(q)$. The focus is on the behavior of these integrators when the force $F(q) = -\\mathrm{d}V/\\mathrm{d}q$ is non-Lipschitz, specifically for the cusp potential $V(q)=|q|$. Two regularization strategies are also investigated. The performance metric is the long-term energy drift, quantified by the slope $s$ of a linear least-squares fit to the total energy time series.\n\n1. Potential and Force Functions\nWe implement the three specified potential energy functions and their corresponding forces. All quantities are in dimensionless units.\n\n1.1. Cusp Potential\nThe potential is $V(q) = |q|$. The force is $F(q) = -\\mathrm{d}V/\\mathrm{d}q = -\\mathrm{sign}(q)$. At $q=0$, the derivative is undefined. The problem specifies the convention $F(0)=0$. This is naturally handled by numerical libraries where $\\mathrm{sign}(0)=0$.\n\n1.2. Smooth Regularization\nThe potential is $V_{\\varepsilon}(q) = \\sqrt{q^2 + \\varepsilon^2}$, parameterized by $\\varepsilon  0$. The corresponding force is $F_{\\varepsilon}(q) = -q/\\sqrt{q^2 + \\varepsilon^2}$. This force function is smooth for $\\varepsilon  0$ and approximates $-\\mathrm{sign}(q)$ for small $\\varepsilon$ and $|q| \\gg \\varepsilon$.\n\n1.3. Huber-type Regularization\nThis potential is defined piecewise:\n$$\nV_{\\delta}(q) = \n\\begin{cases} \n\\frac{q^2}{2\\delta}  \\text{if } |q| \\le \\delta \\\\\n|q| - \\frac{\\delta}{2}  \\text{if } |q|  \\delta \n\\end{cases}\n$$\nThis potential is continuously differentiable. The force is:\n$$\nF_{\\delta}(q) = \n\\begin{cases} \n-q/\\delta  \\text{if } |q| \\le \\delta \\\\\n-\\mathrm{sign}(q)  \\text{if } |q|  \\delta \n\\end{cases}\n$$\nThis force is continuous and Lipschitz, providing a different way to regularize the cusp.\n\n2. Numerical Integrators\nWe start from Newton's second law, $m\\ddot{q} = F(q)$, which is $\\ddot{q} = F(q)$ for $m=1$. Let $q_n$, $v_n$, and $a_n$ be the position, velocity, and acceleration at time $t_n = n\\Delta t$.\n\n2.1. Velocity Verlet Method\nThe velocity Verlet algorithm updates positions and velocities as follows:\n1. $q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$\n2. $a_{n+1} = F(q_{n+1})/m$\n3. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$\nThis method is time-reversible and symplectic, generally leading to good long-term energy conservation for smooth potentials. It requires one force evaluation per time step. The quantities $q_n$ and $v_n$ are synchronized at integer time steps, allowing for a direct calculation of the energy $E_n = \\frac{1}{2}mv_n^2 + V(q_n)$.\n\n2.2. Leap-frog Method\nThe term \"leap-frog\" can refer to several algebraically equivalent formulations. A common one is the \"kick-drift-kick\" (KDK) form, which is also known as the position-update form or LF2. This method is algebraically identical to the velocity Verlet method. Its steps are:\n1. (Kick) $v_{n+1/2} = v_n + \\frac{1}{2} a_n \\Delta t$\n2. (Drift) $q_{n+1} = q_n + v_{n+1/2} \\Delta t$\n3. (Kick) $v_{n+1} = v_{n+1/2} + \\frac{1}{2} a_{n+1} \\Delta t$, where $a_{n+1} = F(q_{n+1})/m$.\nBy providing positions and velocities at the same integer time steps, this form also allows for straightforward energy calculation. Given its algebraic equivalence to velocity Verlet, we expect the simulation trajectories and hence the energy drifts to be identical up to floating-point precision differences. The problem's inclusion of test cases comparing these two methods likely serves to verify this equivalence.\n\n3. Simulation and Analysis\nFor each test case, the system is integrated from $t=0$ to $T$ using a fixed time step $\\Delta t$, generating a sequence of positions and velocities. The total energy $E_n = \\frac{1}{2} m v_n^2 + V(q_n)$ is computed at each step $n=0, 1, \\dots, N$, where $N=T/\\Delta t$.\nThe long-term energy drift is quantified by the slope $s$ of a simple linear regression line fitted to the discrete energy data points $\\{(t_n, E_n)\\}_{n=0}^N$. This is computed using `numpy.polyfit(t, E, 1)`, which provides robust and standard least-squares fitting. The resulting slope $s$ represents the average rate of energy change over the simulation.\n\n4. Implementation Details\nThe simulation is implemented in Python using the `numpy` library. Dedicated functions are created for each potential and integrator. A main control loop iterates through the specified test cases, runs the appropriate simulation, computes the energy drift slope, and collects the results.\nThe number of steps $N$ is calculated as `int(round(T/dt))` to avoid floating point inaccuracies. The time array is generated using `numpy.linspace(0, T, N + 1)` to ensure the final time point is exactly $T$. \nFor the cusp potential, the convention $F(0)=0$ is handled correctly by `numpy.sign(0)`, which returns $0$.\nThe final list of slopes for test cases A through F is formatted into the specified string representation.",
            "answer": "```python\nimport numpy as np\n\ndef V_cusp(q):\n    \"\"\"Cusp potential V(q) = |q|.\"\"\"\n    return np.abs(q)\n\ndef F_cusp(q):\n    \"\"\"Force for cusp potential, F(q) = -sign(q), with F(0)=0.\"\"\"\n    return -np.sign(q)\n\ndef V_smooth(q, eps):\n    \"\"\"Smoothly regularized potential.\"\"\"\n    return np.sqrt(q**2 + eps**2)\n\ndef F_smooth(q, eps):\n    \"\"\"Force for smoothly regularized potential.\"\"\"\n    denom = np.sqrt(q**2 + eps**2)\n    return -q / denom if denom != 0 else 0.0\n\ndef V_huber(q, delta):\n    \"\"\"Huber-type regularized potential.\"\"\"\n    if np.abs(q) = delta:\n        return 0.5 * q**2 / delta\n    else:\n        return np.abs(q) - 0.5 * delta\n\ndef F_huber(q, delta):\n    \"\"\"Force for Huber-type regularized potential.\"\"\"\n    if np.abs(q) = delta:\n        return -q / delta\n    else:\n        return -np.sign(q)\n\ndef velocity_verlet(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Velocity Verlet integrator.\"\"\"\n    q = np.zeros(N + 1)\n    v = np.zeros(N + 1)\n    E = np.zeros(N + 1)\n    \n    q[0] = q0\n    v[0] = v0\n    E[0] = 0.5 * m * v[0]**2 + V_func(q[0])\n    \n    a_curr = F_func(q[0]) / m\n    \n    for n in range(N):\n        q[n+1] = q[n] + v[n] * dt + 0.5 * a_curr * dt**2\n        a_next = F_func(q[n+1]) / m\n        v[n+1] = v[n] + 0.5 * (a_curr + a_next) * dt\n        E[n+1] = 0.5 * m * v[n+1]**2 + V_func(q[n+1])\n        a_curr = a_next\n        \n    return E\n\ndef leap_frog(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Leap-frog integrator (kick-drift-kick formulation).\"\"\"\n    q_curr = q0\n    v_curr = v0\n    E = np.zeros(N + 1)\n    E[0] = 0.5 * m * v_curr**2 + V_func(q_curr)\n    \n    a_curr = F_func(q_curr) / m\n    \n    for n in range(N):\n        v_half = v_curr + 0.5 * a_curr * dt\n        q_curr = q_curr + v_half * dt\n        a_curr = F_func(q_curr) / m\n        v_curr = v_half + 0.5 * a_curr * dt\n        E[n+1] = 0.5 * m * v_curr**2 + V_func(q_curr)\n        \n    return E\n\ndef run_simulation(integrator_name, potential_name, dt, T, q0, v0, reg_param):\n    \"\"\"Runs a single simulation and returns the energy drift slope.\"\"\"\n    m = 1.0\n    N = int(round(T / dt))\n    t = np.linspace(0, T, N + 1)\n\n    if potential_name == 'cusp':\n        V_func = V_cusp\n        F_func = F_cusp\n    elif potential_name == 'smooth':\n        V_func = lambda q: V_smooth(q, reg_param)\n        F_func = lambda q: F_smooth(q, reg_param)\n    elif potential_name == 'Huber':\n        V_func = lambda q: V_huber(q, reg_param)\n        F_func = lambda q: F_huber(q, reg_param)\n    else:\n        raise ValueError(f\"Unknown potential: {potential_name}\")\n\n    if integrator_name == 'velocity Verlet':\n        integrator_func = velocity_verlet\n    elif integrator_name == 'leap-frog':\n        integrator_func = leap_frog\n    else:\n        raise ValueError(f\"Unknown integrator: {integrator_name}\")\n\n    E = integrator_func(F_func, V_func, q0, v0, dt, N, m)\n    \n    slope, _ = np.polyfit(t, E, 1)\n    \n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case B\n        ('leap-frog', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case C\n        ('velocity Verlet', 'cusp', 0.2, 20.0, 0.1, 0.0, None),\n        # Case D\n        ('velocity Verlet', 'smooth', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case E\n        ('leap-frog', 'Huber', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case F\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.0, 0.1, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        slope = run_simulation(*case)\n        results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}