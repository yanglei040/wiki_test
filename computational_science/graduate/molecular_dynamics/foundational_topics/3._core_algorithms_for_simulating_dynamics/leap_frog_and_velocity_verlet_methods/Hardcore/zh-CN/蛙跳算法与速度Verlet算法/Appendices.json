{
    "hands_on_practices": [
        {
            "introduction": "蛙跳法等交错时间积分方案以其优异的长期稳定性而闻名，但正确启动它们对于保持精度至关重要。本练习将通过泰勒展开，推导如何通过一个简单的“半步加速”来初始化半步速度，从而确保积分从第一步开始就达到二阶精度。这个基本推导是理解和正确实现这些辛积分器的关键。",
            "id": "3420452",
            "problem": "考虑一个质量为 $m$ 的单个粒子，其在一个光滑的、与位置相关的力 $\\mathbf{F}(\\mathbf{r})$ 的作用下运动，遵循 Newton 第二定律 $m\\,\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))$。在分子动力学 (MD) 中，蛙跳积分法通过半步速度将位置推进一个步长，即 $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$，而速度的更新则中心化在半步长处。在时间 $t=0$ 时，给定初始数据 $\\mathbf{r}^{0}=\\mathbf{r}(0)$ 和 $\\mathbf{v}^{0}=\\mathbf{v}(0)$。你希望仅使用 $\\mathbf{r}^{0}$、$\\mathbf{v}^{0}$、$h$、$m$ 和 $\\mathbf{F}(\\mathbf{r}^{0})$ 来初始化在时间 $t=h/2$ 的半步速度 $\\mathbf{v}^{1/2}$，从而使得第一个位置更新 $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$ 的局部误差达到 $\\mathcal{O}(h^{3})$，也就是说，该方案在第一步达到二阶精度。\n\n从基本定义 $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ 和 $\\mathbf{a}(t)=\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))/m$ 出发，使用关于 $t=0$ 的泰勒展开，推导一个 $\\mathbf{v}^{1/2}$ 必须满足的相容性条件，以使 $\\mathbf{r}^{1}$ 与精确位置 $\\mathbf{r}(h)$ 的误差在 $\\mathcal{O}(h^{3})$ 以内。然后，提供一个仅用给定物理量表示的 $\\mathbf{v}^{1/2}$ 的显式公式。你的最终答案必须是 $\\mathbf{v}^{1/2}$ 的一个单一闭式解析表达式。",
            "solution": "该问题要求在蛙跳积分方案中，为半步速度 $\\mathbf{v}^{1/2}$ 推导一个初始化公式。此初始化必须确保第一个位置更新 $\\mathbf{r}^{1}$ 具有二阶精度，即相对于精确解 $\\mathbf{r}(h)$ 的局部误差为 $\\mathcal{O}(h^3)$ 阶。$\\mathbf{v}^{1/2}$ 的公式只能依赖于初始位置 $\\mathbf{r}^{0}$、初始速度 $\\mathbf{v}^{0}$、时间步长 $h$、质量 $m$ 以及在初始位置处计算的力 $\\mathbf{F}(\\mathbf{r}^{0})$。\n\n我们首先通过对 $\\mathbf{r}(t)$ 在 $t=0$ 附近进行泰勒级数展开，来求得粒子在时间 $t=h$ 时的精确位置。粒子的运动遵循 Newton 第二定律 $m\\,\\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))$。我们已知定义 $\\mathbf{v}(t) = \\dot{\\mathbf{r}}(t)$ 和 $\\mathbf{a}(t) = \\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$。$\\mathbf{r}(t)$ 在 $t=0$ 附近的泰勒展开为：\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0) + t\\,\\dot{\\mathbf{r}}(0) + \\frac{t^2}{2!}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(t^3)\n$$\n在 $t=h$ 处求值，并使用初始条件 $\\mathbf{r}(0) = \\mathbf{r}^0$ 和 $\\dot{\\mathbf{r}}(0) = \\mathbf{v}^0$，我们得到：\n$$\n\\mathbf{r}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(h^3)\n$$\n在 $t=0$ 时的加速度为 $\\mathbf{a}^{0} = \\ddot{\\mathbf{r}}(0) = \\mathbf{F}(\\mathbf{r}(0))/m = \\mathbf{F}(\\mathbf{r}^0)/m$。将此代入展开式，得到精确到 $h^2$ 阶的精确位置：\n$$\n\\mathbf{r}_{exact}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^3)\n$$\n第一个时间步长的位置的数值近似值由蛙跳更新规则给出：\n$$\n\\mathbf{r}^{1} = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2}\n$$\n这第一步的局部误差是精确位置 $\\mathbf{r}_{exact}(h)$ 与数值近似值 $\\mathbf{r}^{1}$ 之间的差。问题要求此误差为 $\\mathcal{O}(h^3)$ 阶：\n$$\n\\mathbf{r}_{exact}(h) - \\mathbf{r}^{1} = \\mathcal{O}(h^3)\n$$\n代入 $\\mathbf{r}_{exact}(h)$ 和 $\\mathbf{r}^{1}$ 的表达式：\n$$\n\\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} \\right) - \\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2} \\right) = \\mathcal{O}(h^3)\n$$\n$\\mathbf{r}^{0}$ 项相互抵消。我们得到：\n$$\nh\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} - h\\,\\mathbf{v}^{1/2} = \\mathcal{O}(h^3)\n$$\n为了分离出关于 $\\mathbf{v}^{1/2}$ 的条件，我们将整个方程除以时间步长 $h$：\n$$\n\\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} - \\mathbf{v}^{1/2} = \\mathcal{O}(h^2)\n$$\n重新整理此方程，得到 $\\mathbf{v}^{1/2}$ 必须满足的相容性条件：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\n该条件意味着 $\\mathbf{v}^{1/2}$ 必须是在半个时间步长 $t=h/2$ 处精确速度的一个（关于 $h$ 的）一阶近似。我们可以通过将精确速度 $\\mathbf{v}(t)$ 在 $t=0$ 附近进行泰勒展开来验证这一点：\n$$\n\\mathbf{v}(t) = \\mathbf{v}(0) + t\\,\\dot{\\mathbf{v}}(0) + \\mathcal{O}(t^2) = \\mathbf{v}^{0} + t\\,\\mathbf{a}^{0} + \\mathcal{O}(t^2)\n$$\n在 $t=h/2$ 处求值：\n$$\n\\mathbf{v}(h/2) = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\n将此与 $\\mathbf{v}^{1/2}$ 的相容性条件进行比较，我们看到 $\\mathbf{v}^{1/2}$ 必须与 $\\mathbf{v}(h/2)$ 在 $\\mathcal{O}(h)$ 阶项上吻合。\n\n为了获得 $\\mathbf{v}^{1/2}$ 的一个显式公式，我们可以通过简单地截断级数展开来满足相容性条件，即舍去 $\\mathcal{O}(h^2)$ 项。这给出：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0}\n$$\n这种选择提供了满足精度要求的最简单的显式公式。等式右边的量是初始速度 $\\mathbf{v}^{0}$、时间步长 $h$ 和初始加速度 $\\mathbf{a}^{0}$。问题规定该公式只能使用 $\\mathbf{r}^{0}$、$\\mathbf{v}^{0}$、$h$、$m$ 和 $\\mathbf{F}(\\mathbf{r}^{0})$。由于 $\\mathbf{a}^{0} = \\mathbf{F}(\\mathbf{r}^{0})/m$，我们得到的 $\\mathbf{v}^{1/2}$ 表达式满足此约束。\n\n代入 $\\mathbf{a}^0$：\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})\n$$\n这就是在蛙跳积分的第一个位置步长中，为达到二阶精度所需的初始半步速度的显式公式。",
            "answer": "$$\\boxed{\\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})}$$"
        },
        {
            "introduction": "速度Verlet法和蛙跳法在代数上等价，并且都是二阶精度的，但它们的局部截断误差的具体形式存在细微差别。本练习要求您对一个简单的谐振子模型进行精确的误差分析，推导并比较两种方法的误差常数。通过这种方式，您将更深入地理解它们在数值行为上的异同。",
            "id": "3420490",
            "problem": "考虑一个一维谐振子，其运动由牛顿第二定律 $m\\ddot{x}(t) = -k x(t)$ 决定，角频率为 $\\omega = \\sqrt{k/m}$，正如在分子动力学 (MD) 中所处理的那样。令 $h$ 表示一个恒定的时间步长，并使用蛙跳法（速度存储在半步长处）和速度Verlet法（位置和速度存储在整数步长处）的标准定义。将一种方法的局部截断误差定义为：精确解推进一个步长后的值，与在该方法的原生时间索引上对精确数据应用单步数值更新后的值之间的差值。具体来说，通过以下领头项分别定义位置和速度的局部截断误差常数 $C_{x}$ 和 $C_{v}$：\n$$\\text{LTE}_{x} = C_{x}\\,h^{3}\\,x^{(3)}(t) + \\mathcal{O}(h^{4}), \\qquad \\text{LTE}_{v} = C_{v}\\,h^{3}\\,x^{(4)}(t) + \\mathcal{O}(h^{4}),$$\n其中 $x^{(3)}(t)$ 和 $x^{(4)}(t)$ 沿着精确解进行求值。对于蛙跳法，在定义 $C_{v}$ 时，取半步长 $t+h/2$ 处的速度变量；对于速度Verlet法，取整数步长 $t+h$ 处的速度。\n\n仅从牛顿定律、定义 $v=\\dot{x}$，$a=\\ddot{x}$，以及 $x(t+h)$ 和 $v(t+h)$ 关于 $t$ 的泰勒展开出发，推导应用于 $m\\ddot{x}=-kx$ 的速度Verlet法的局部截断误差常数 $C_{x}$ 和 $C_{v}$，然后推导蛙跳法（速度在半步长处）的相应常数。请将最终答案表示为单行矩阵，使用LaTeX的 $\\texttt{pmatrix}$ 环境，并按以下顺序排列：\n$$\\big(C_{x}^{\\text{VV}},\\; C_{v}^{\\text{VV}},\\; C_{x}^{\\text{LF}},\\; C_{v,\\;1/2}^{\\text{LF}}\\big),$$\n其中“VV”表示速度Verlet法，“LF”表示蛙跳法。无需四舍五入；请提供精确的有理数。最终答案没有物理单位。",
            "solution": "我们从谐振子 $m\\ddot{x}(t)=-k x(t)$ 开始，并引入 $\\omega=\\sqrt{k/m}$。沿着精确解，时间导数满足\n$$x''(t) = -\\omega^{2} x(t), \\quad x^{(3)}(t) = \\frac{d}{dt}x''(t) = -\\omega^{2} v(t), \\quad x^{(4)}(t) = \\frac{d}{dt}x^{(3)}(t) = \\omega^{4} x(t).$$\n精确解在时间 $t+h$ 的泰勒展开式为\n\\begin{align*}\nx(t+h) = x(t) + h v(t) + \\frac{h^{2}}{2} x''(t) + \\frac{h^{3}}{6} x^{(3)}(t) + \\frac{h^{4}}{24} x^{(4)}(t) + \\mathcal{O}(h^{5}), \\\\\nv(t+h) = v(t) + h x''(t) + \\frac{h^{2}}{2} x^{(3)}(t) + \\frac{h^{3}}{6} x^{(4)}(t) + \\frac{h^{4}}{24} x^{(5)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\n其中 $x^{(5)}(t) = \\omega^{4} v(t)$，依此类推。\n\n速度Verlet法。给定精确的 $(x(t), v(t))$ 和 $a(t) = x''(t) = -\\omega^{2} x(t)$，速度Verlet法的更新步骤是\n\\begin{align*}\nx_{\\text{VV}}(t+h) = x(t) + h v(t) + \\frac{h^{2}}{2} a(t), \\\\\na(t+h) = -\\omega^{2} x_{\\text{VV}}(t+h), \\\\\nv_{\\text{VV}}(t+h) = v(t) + \\frac{h}{2}\\big(a(t) + a(t+h)\\big).\n\\end{align*}\n代入 $a(t)=-\\omega^{2} x(t)$ 得到\n$$x_{\\text{VV}}(t+h) = x(t) + h v(t) - \\frac{h^{2}}{2}\\omega^{2} x(t).$$\n与 $x(t+h)$ 比较，位置的局部截断误差为\n\\begin{align*}\n\\text{LTE}_{x}^{\\text{VV}} = x(t+h) - x_{\\text{VV}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{24}\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\n所以领头常数为 $C_{x}^{\\text{VV}} = \\frac{1}{6}$。\n\n对于速度，首先注意 $x_{\\text{VV}}(t+h) = x(t) + h v(t) - \\frac{h^{2}}{2}\\omega^{2} x(t)$，所以\n\\begin{align*}\na(t+h) = -\\omega^{2} x_{\\text{VV}}(t+h) \\\\\n= -\\omega^{2} x(t) - \\omega^{2} h v(t) + \\frac{h^{2}}{2} \\omega^{4} x(t).\n\\end{align*}\n那么\n\\begin{align*}\nv_{\\text{VV}}(t+h) = v(t) + \\frac{h}{2}\\left[-\\omega^{2} x(t) + \\left(-\\omega^{2} x(t) - \\omega^{2} h v(t) + \\frac{h^{2}}{2} \\omega^{4} x(t)\\right)\\right] \\\\\n= v(t) - h \\omega^{2} x(t) - \\frac{h^{2}}{2} \\omega^{2} v(t) + \\frac{h^{3}}{4} \\omega^{4} x(t) \\\\\n= v(t) + h x''(t) + \\frac{h^{2}}{2} x^{(3)}(t) + \\frac{h^{3}}{4} x^{(4)}(t).\n\\end{align*}\n与精确的 $v(t+h)$ 比较，\n\\begin{align*}\n\\text{LTE}_{v}^{\\text{VV}} = v(t+h) - v_{\\text{VV}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6} - \\frac{h^{3}}{4}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}) = -\\left(\\frac{h^{3}}{12}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}),\n\\end{align*}\n所以 $C_{v}^{\\text{VV}} = -\\frac{1}{12}$。\n\n蛙跳法。蛙跳格式将速度存储在半步长上。假设输入为精确值 $x(t)$ 和 $v(t - h/2)$。蛙跳法的更新步骤是\n\\begin{align*}\nv_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) = v\\!\\left(t-\\frac{h}{2}\\right) + h\\,a(t), \\\\\nx_{\\text{LF}}(t+h) = x(t) + h\\,v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right),\n\\end{align*}\n其中 $a(t) = -\\omega^{2} x(t)$。将 $v(t \\pm h/2)$ 在 $t$ 处展开：\n\\begin{align*}\nv\\!\\left(t+\\frac{h}{2}\\right) = v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) + \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}), \\\\\nv\\!\\left(t-\\frac{h}{2}\\right) = v(t) - \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}).\n\\end{align*}\n那么\n\\begin{align*}\nv_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) = \\left[v(t) - \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t)\\right] + h a(t) + \\mathcal{O}(h^{4}) \\\\\n= v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) + \\mathcal{O}(h^{4}).\n\\end{align*}\n与 $v\\!\\left(t+\\frac{h}{2}\\right)$ 比较，得到半步长速度的局部截断误差：\n\\begin{align*}\n\\text{LTE}_{v,\\;1/2}^{\\text{LF}} = v\\!\\left(t+\\frac{h}{2}\\right) - v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) \\\\\n= \\left(\\frac{h^{3}}{48} - \\left(-\\frac{h^{3}}{48}\\right)\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}) = \\left(\\frac{h^{3}}{24}\\right) x^{(4)}(t) + \\mathcal{O}(h^{4}),\n\\end{align*}\n所以 $C_{v,\\;1/2}^{\\text{LF}} = \\frac{1}{24}$。\n\n对于位置，\n\\begin{align*}\nx_{\\text{LF}}(t+h) = x(t) + h\\,v_{\\text{LF}}\\!\\left(t+\\frac{h}{2}\\right) \\\\\n= x(t) + h\\left[ v(t) + \\frac{h}{2} a(t) + \\frac{h^{2}}{8} x^{(3)}(t) - \\frac{h^{3}}{48} x^{(4)}(t) \\right] + \\mathcal{O}(h^{5}) \\\\\n= x(t) + h v(t) + \\frac{h^{2}}{2} a(t) + \\frac{h^{3}}{8} x^{(3)}(t) - \\frac{h^{4}}{48} x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\n所以\n\\begin{align*}\n\\text{LTE}_{x}^{\\text{LF}} = x(t+h) - x_{\\text{LF}}(t+h) \\\\\n= \\left(\\frac{h^{3}}{6} - \\frac{h^{3}}{8}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{24} - \\left(-\\frac{h^{4}}{48}\\right)\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}) \\\\\n= \\left(\\frac{h^{3}}{24}\\right) x^{(3)}(t) + \\left(\\frac{h^{4}}{16}\\right) x^{(4)}(t) + \\mathcal{O}(h^{5}),\n\\end{align*}\n因此 $C_{x}^{\\text{LF}} = \\frac{1}{24}$。\n\n总结。由 $\\text{LTE}_{x} = C_{x} h^{3} x^{(3)}(t) + \\mathcal{O}(h^{4})$ 和 $\\text{LTE}_{v} = C_{v} h^{3} x^{(4)}(t) + \\mathcal{O}(h^{4})$ 定义的领头局部截断误差常数为\n\\begin{align*}\nC_{x}^{\\text{VV}} = \\frac{1}{6}, \\\\\nC_{v}^{\\text{VV}} = -\\frac{1}{12}, \\\\\nC_{x}^{\\text{LF}} = \\frac{1}{24}, \\\\\nC_{v,\\;1/2}^{\\text{LF}} = \\frac{1}{24}.\n\\end{align*}\n这些结果表明两种方法都是二阶精确的，其中蛙跳法的位置领头常数比速度Verlet法的小，而速度项的符号结构不同，是由于各自更新步骤中采用的不同平均操作所致。",
            "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1}{6}  -\\frac{1}{12}  \\frac{1}{24}  \\frac{1}{24}\\end{pmatrix}}$$"
        },
        {
            "introduction": "理论分析为我们提供了数值方法的精度阶数，但通过数值实验来验证这些理论预测是计算科学中的一项核心技能。在本练习中，您将在一个非简谐的双阱势中模拟粒子动力学，通过测量能量漂移随时间步长 $ \\Delta t $ 的缩放行为，来数值验证蛙跳法和速度Verlet法的二阶精度。这项实践将理论与实际的算法性能评估联系起来。",
            "id": "3420524",
            "problem": "考虑一个质量为 $m$ 的单个粒子，在非谐双阱势 $V(x)=\\alpha\\,(x^2-x_0^2)^2$ 下进行一维空间运动。其受力为 $F(x)=-\\partial V/\\partial x$。通过使用两种二阶辛算法（蛙跳法 (leap-frog method) 和速度 Verlet 法 (velocity Verlet method)）对牛顿第二定律 $m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2=F(x)$ 进行积分，生成微正则系综（粒子数、体积、能量 NVE 守恒）轨迹。从牛顿定律和速度定义 $v=\\mathrm{d}x/\\mathrm{d}t$ 出发，实现这两种积分器，并在固定的总时间 $T$ 内使用多个时间步长 $\\Delta t$ 模拟动力学过程。对于每种积分器和每个 $\\Delta t$，计算总能量 $E(t)=\\tfrac{1}{2}m\\,v(t)^2+V(x(t))$，并将时间 $T$ 后的绝对相对能量漂移定义为 $D(\\Delta t)=\\left|E(T)-E(0)\\right|/\\left|E(0)\\right|$。\n\n您的程序必须：\n- 为每个指定的 $\\Delta t$ 和积分器演化系统，如果状态的任何分量变为非有限值（非实数）或 $|x|$ 或 $|v|$ 超过边界 $10^6$，则检测不稳定性（发散），并在这种情况下将该次运行的漂移 $D(\\Delta t)$ 标记为未定义。\n- 对于每个测试用例和每种积分器，通过对所有 $D(\\Delta t)0$ 的稳定运行的 $\\log D$ 与 $\\log \\Delta t$ 进行最小二乘线性回归，估计标度律 $D(\\Delta t)\\approx C\\,\\Delta t^{n}$ 中的指数 $n$。报告 $n$ 的值，四舍五入到小数点后两位（无量纲单位）。\n- 对于每种积分器，将“最优 $\\Delta t$ 范围”定义为所提供列表中稳定且满足 $D(\\Delta t)\\le\\tau$ 的 $\\Delta t$ 值集合，其中 $\\tau$ 是特定于用例的容差。报告此范围的下限和上限，以浮点数形式表示，四舍五入到小数点后三位（无量纲单位）。如果没有时间步长满足该标准，则上下限均报告为 $\\mathrm{NaN}$。\n\n使用约化的无量纲单位，其中 $m=1$；因此，所有报告的量均为无量纲。不涉及角度。所有最终数值答案必须是浮点数。程序应以科学上真实的方式实现这两种积分器，并严格从第一性原理出发产生结果。\n\n测试套件：\n1. 用例1（基准双阱）：\n   - 参数：$\\alpha=1.0$, $x_0=1.0$, $m=1.0$, $T=20.0$。\n   - 初始条件：$x(0)=0.9$, $v(0)=0.0$。\n   - 时间步长：$\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016,\\,0.032\\}$。\n   - 容差：$\\tau=10^{-3}$。\n2. 用例2（更陡峭的双阱）：\n   - 参数：$\\alpha=5.0$, $x_0=1.0$, $m=1.0$, $T=10.0$。\n   - 初始条件：$x(0)=0.8$, $v(0)=0.0$。\n   - 时间步长：$\\Delta t\\in\\{0.001,\\,0.002,\\,0.004,\\,0.008\\}$。\n   - 容差：$\\tau=5\\times 10^{-4}$。\n3. 用例3（近势垒动力学）：\n   - 参数：$\\alpha=1.0$, $x_0=1.0$, $m=1.0$, $T=20.0$。\n   - 初始条件：$x(0)=0.0$, $v(0)=0.5$。\n   - 时间步长：$\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016\\}$。\n   - 容差：$\\tau=2\\times 10^{-3}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行文本，其中包含 3 个测试用例的汇总结果，格式为无空格、逗号分隔的列表的列表。对于每个用例，输出列表 $[n_{\\mathrm{LF}},n_{\\mathrm{VV}},\\Delta t_{\\min,\\mathrm{LF}},\\Delta t_{\\max,\\mathrm{LF}},\\Delta t_{\\min,\\mathrm{VV}},\\Delta t_{\\max,\\mathrm{VV}}]$，其中 $n_{\\mathrm{LF}}$ 是蛙跳法的漂移-标度指数，$n_{\\mathrm{VV}}$ 是速度 Verlet 法的漂移-标度指数。两个范围界限是满足上述标准的每种积分器的下限和上限 $\\Delta t$ 值。因此，汇总输出的格式必须为 $[[\\dots],[\\dots],[\\dots]]$，所有浮点数均按规定四舍五入。",
            "solution": "用户要求实现并分析两种常见的辛积分器（蛙跳法和速度 Verlet 法），用于模拟一维双阱势中粒子的动力学。主要任务是验证问题，如果问题有效，则提供一个包括 Python 程序的完整解决方案。\n\n### 问题验证\n\n根据指定标准对问题陈述进行严格评估。\n\n**步骤1：提取已知条件**\n\n- **系统定义**：一维空间中质量为 $m$ 的单个粒子。\n- **势能**：$V(x) = \\alpha(x^2 - x_0^2)^2$。\n- **力**：$F(x) = -\\partial V/\\partial x = -4\\alpha x(x^2 - x_0^2)$。\n- **运动方程**：$m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2 = F(x)$。\n- **数值积分器**：蛙跳法和速度 Verlet 法。\n- **模拟时长**：总时间 $T$。\n- **时间步长**：$\\Delta t$。\n- **总能量**：$E(t) = \\frac{1}{2}m v(t)^2 + V(x(t))$。\n- **能量漂移**：绝对相对能量漂移定义为 $D(\\Delta t) = |E(T) - E(0)|/|E(0)|$。\n- **不稳定性条件**：如果任何状态变量（$x$ 或 $v$）变为非有限值，或者 $|x|  10^6$ 或 $|v|  10^6$，则轨迹不稳定。对于不稳定的运行，$D(\\Delta t)$ 被视为未定义。\n- **标度指数 $n$**：通过对所有 $D(\\Delta t)  0$ 的稳定运行的 $\\log D$ 与 $\\log \\Delta t$ 进行最小二乘线性回归，从 $D(\\Delta t) \\approx C\\,\\Delta t^n$ 中估计。$n$ 的值必须四舍五入到小数点后两位。\n- **最优 $\\Delta t$ 范围**：稳定且 $D(\\Delta t) \\le \\tau$ 的 $\\Delta t$ 值集合，其中 $\\tau$ 是给定的容差。报告此范围的下限和上限，四舍五入到小数点后三位。如果没有 $\\Delta t$ 符合条件，则上下限均报告为 `NaN`。\n- **单位**：所有量均采用约化的无量纲单位，其中 $m=1$。\n- **测试用例**：提供了三个不同的测试用例，每个用例都具有特定的 $\\alpha$, $x_0$, $T$ 值、初始条件 $(x(0), v(0))$、一组 $\\Delta t$ 值和一个容差 $\\tau$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在根本上是合理的。它涉及牛顿第二定律、一个标准的非谐势，以及在分子动力学和计算物理学中广泛使用的典型数值积分算法（蛙跳法/速度 Verlet 法）。能量守恒分析是评估 NVE 模拟的基石。\n- **适定性**：该问题是适定的。它描述了一个二阶常微分方程的初值问题。所有必要的参数、初始条件和分析标准都已明确给出，确保可以计算出唯一且有意义的解。\n- **客观性**：问题陈述具有科学客观性和数学精确性。所有任务和要求的输出都是定量的，没有歧义或主观解释的余地。\n- **完整性和一致性**：问题是自洽的。每个测试用例都已完全指定。没有内部矛盾。\n- **无其他缺陷**：该问题不违反任何其他验证标准。它不基于错误的前提，可直接形式化，计算上可行，且并非微不足道。\n\n**步骤3：结论与行动**\n\n该问题被判定为**有效**。将提供完整的解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是求解牛顿运动方程 $\\ddot{x} = a(x)$，其中加速度 $a(x) = F(x)/m$。当 $m=1$ 时，这简化为 $a(x) = F(x) = -4\\alpha x (x^2 - x_0^2)$。我们将实现两种二阶辛积分器：速度 Verlet 和蛙跳法。\n\n**1. 速度 Verlet 积分器**\n\n该算法将时间 $t_n = n\\Delta t$ 的状态 $(x_n, v_n)$ 推进到时间 $t_{n+1}$ 的状态 $(x_{n+1}, v_{n+1})$。位置和速度在整数时间步长上是同步的。\n\n更新规则如下：\n1.  计算新位置：\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n    其中 $a_n = a(x_n)$。\n2.  计算新位置处的加速度：\n    $$a_{n+1} = a(x_{n+1})$$\n3.  计算新速度：\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n\n**2. 蛙跳积分器（时间交错格式）**\n\n该算法通常将速度在半整数时间步 $t_{n+1/2} = (n+1/2)\\Delta t$ 进行评估，而位置则在整数时间步 $t_n$ 进行评估。\n\n主循环的更新规则是：\n1.  更新位置：\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n2.  将速度更新到下一个半步：\n    $$v_{n+3/2} = v_{n+1/2} + a_{n+1} \\Delta t$$\n    其中 $a_{n+1} = a(x_{n+1})$。\n\n为了从 $(x_0, v_0)$ 初始化该方案，并在与最终位置 $x_N$ 相同的最终时间 $T=N\\Delta t$ 获得最终速度 $v_N$，需要特殊的半步操作：\n-   **初始化**：需要一个初步的速度半步推进来启动循环：\n    $$v_{1/2} = v_0 + \\frac{1}{2} a_0 \\Delta t$$\n-   **最终化**：在计算出最终位置 $x_N$ 后，一个最终的速度半步推进使速度同步：\n    $$v_N = v_{N-1/2} + \\frac{1}{2} a_N \\Delta t$$\n\n数值分析中一个已知的结论是，速度 Verlet 和这种特定的蛙跳积分器实现在数学上是等价的。假设浮点运算相同，它们将产生相同的轨迹。我们的实现将按照要求尊重它们各自不同的算法表述。\n\n**3. 模拟与分析**\n\n对于每个测试用例和每种积分器：\n1.  对每个指定的 $\\Delta t$ 运行一次模拟。总步数为 $N = \\text{round}(T/\\Delta t)$。\n2.  计算初始能量 $E_0 = E(0) = \\frac{1}{2} m v(0)^2 + V(x(0))$。\n3.  系统演化 $N$ 步。在每一步中，我们检查不稳定性（$|x|  10^6$，$|v|  10^6$，或非有限值）。如果发生不稳定性，则终止运行并将漂移标记为未定义（例如 `np.nan`）。\n4.  如果模拟完成，则计算最终能量 $E_T = E(N\\Delta t)$，并将漂移计算为 $D(\\Delta t) = |E_T - E_0|/|E_0|$。\n5.  在对所有 $\\Delta t$ 运行模拟后，找到标度指数 $n$。我们收集所有 $D  0$ 的稳定运行的配对 $(\\Delta t, D)$。然后对其对数进行线性回归：$\\log D = n \\log(\\Delta t) + \\text{const}$。此拟合的斜率即为 $n$。这至少需要两个有效数据点。\n6.  通过找到所有漂移 $D(\\Delta t)$ 小于或等于特定用例容差 $\\tau$ 的稳定 $\\Delta t$ 来确定最优 $\\Delta t$ 范围。该集合中的最小值和最大值构成了该范围的界限。\n\n这种结构化方法确保满足所有问题要求，从而得出最终的 Python 实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, process test cases, and print results.\n    \"\"\"\n    # Define test cases as per the problem statement.\n    test_cases = [\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.9, \"v_init\": 0.0,\n            \"dts\": [0.002, 0.004, 0.008, 0.016, 0.032],\n            \"tau\": 1e-3\n        },\n        {\n            \"alpha\": 5.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 10.0,\n            \"x_init\": 0.8, \"v_init\": 0.0,\n            \"dts\": [0.001, 0.002, 0.004, 0.008],\n            \"tau\": 5e-4\n        },\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.0, \"v_init\": 0.5,\n            \"dts\": [0.002, 0.004, 0.008, 0.016],\n            \"tau\": 2e-3\n        }\n    ]\n\n    # Helper functions for the physics\n    def potential(x, alpha, x0_pot):\n        return alpha * (x**2 - x0_pot**2)**2\n\n    def acceleration(x, m, alpha, x0_pot):\n        force = -4 * alpha * x * (x**2 - x0_pot**2)\n        return force / m\n\n    def total_energy(x, v, m, alpha, x0_pot):\n        return 0.5 * m * v**2 + potential(x, alpha, x0_pot)\n\n    def run_velocity_verlet(params):\n        \"\"\"\n        Runs a simulation using the velocity Verlet integrator.\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        \n        for _ in range(n_steps):\n            x = x + v * dt + 0.5 * a * dt**2\n            a_new = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v = v + 0.5 * (a + a_new) * dt\n            a = a_new\n            \n            if not (np.isfinite(x) and np.isfinite(v) and abs(x)  stability_bound and abs(v)  stability_bound):\n                return np.nan, np.nan\n        \n        return x, v\n\n    def run_leap_frog(params):\n        \"\"\"\n        Runs a simulation using the leap-frog integrator (staggered time).\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        v_half = v + 0.5 * a * dt\n        \n        for _ in range(n_steps):\n            x = x + v_half * dt\n            \n            if not (np.isfinite(x) and abs(x)  stability_bound):\n                return np.nan, np.nan\n            \n            a = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v_half = v_half + a * dt\n            \n            # Use v_half as a proxy for velocity magnitude check\n            if not (np.isfinite(v_half) and abs(v_half)  stability_bound):\n                return np.nan, np.nan\n\n        # Final half-step to synchronize velocity\n        v_final = v_half - 0.5 * a * dt\n        return x, v_final\n\n    def analyze_results(dts, drifts, tau):\n        \"\"\"\n        Analyzes simulation results to find scaling exponent and optimal regime.\n        \"\"\"\n        # Prepare data for scaling exponent calculation\n        log_dts_stable = []\n        log_drifts_stable = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift > 0:\n                log_dts_stable.append(np.log(dt))\n                log_drifts_stable.append(np.log(drift))\n        \n        # Calculate scaling exponent n\n        if len(log_dts_stable)  2:\n            n = np.nan\n        else:\n            res = linregress(log_dts_stable, log_drifts_stable)\n            n = round(res.slope, 2)\n            \n        # Find optimal dt regime\n        optimal_dts = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift = tau:\n                optimal_dts.append(dt)\n        \n        if not optimal_dts:\n            dt_min, dt_max = np.nan, np.nan\n        else:\n            dt_min = round(min(optimal_dts), 3)\n            dt_max = round(max(optimal_dts), 3)\n            \n        return n, dt_min, dt_max\n\n    all_case_results = []\n    integrators = {\"LF\": run_leap_frog, \"VV\": run_velocity_verlet}\n\n    for case in test_cases:\n        case_results = {}\n        for name, integrator_func in integrators.items():\n            drifts = []\n            for dt_val in case['dts']:\n                sim_params = case.copy()\n                sim_params['dt'] = dt_val\n                \n                e_initial = total_energy(case['x_init'], case['v_init'], case['m'], case['alpha'], case['x0'])\n                \n                x_final, v_final = integrator_func(sim_params)\n                \n                if not np.isfinite(x_final):\n                    drift = np.nan\n                else:\n                    e_final = total_energy(x_final, v_final, case['m'], case['alpha'], case['x0'])\n                    # Avoid division by zero if E(0) is zero.\n                    if abs(e_initial)  1e-15:\n                        drift = abs(e_final - e_initial)\n                    else:\n                        drift = abs(e_final - e_initial) / abs(e_initial)\n                \n                drifts.append(drift)\n            \n            n, dt_min, dt_max = analyze_results(case['dts'], drifts, case['tau'])\n            case_results[name] = [n, dt_min, dt_max]\n\n        all_case_results.append([\n            case_results[\"LF\"][0], case_results[\"VV\"][0],\n            case_results[\"LF\"][1], case_results[\"LF\"][2],\n            case_results[\"VV\"][1], case_results[\"VV\"][2]\n        ])\n\n    # Final print statement in the exact required format.\n    # Convert numpy.nan to float('nan') for string representation as 'nan'\n    formatted_results = []\n    for case_res in all_case_results:\n        formatted_case = []\n        for item in case_res:\n            if np.isnan(item):\n                formatted_case.append(float('nan'))\n            else:\n                formatted_case.append(item)\n        formatted_results.append(formatted_case)\n    \n    print(str(formatted_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}