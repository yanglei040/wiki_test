{
    "hands_on_practices": [
        {
            "introduction": "The elegance of the leap-frog method lies in its staggered time steps, but this same feature poses a challenge: how does one start the simulation correctly? This foundational exercise guides you through a Taylor series analysis to derive the proper initialization for the half-step velocity. Mastering this calculation ensures your implementation maintains its designed second-order accuracy from the very first step, a crucial detail for building a robust simulation code .",
            "id": "3420452",
            "problem": "Consider a single particle of mass $m$ evolving under a smooth, position-dependent force $\\mathbf{F}(\\mathbf{r})$ according to Newton's second law $m\\,\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))$. In Molecular Dynamics (MD), the leap-frog integrator advances the position by one step using the half-step velocity via $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$, while the velocity update is centered at half-steps. At time $t=0$, the initial data $\\mathbf{r}^{0}=\\mathbf{r}(0)$ and $\\mathbf{v}^{0}=\\mathbf{v}(0)$ are given. You wish to initialize the half-step velocity $\\mathbf{v}^{1/2}$ at time $t=h/2$ using only $\\mathbf{r}^{0}$, $\\mathbf{v}^{0}$, $h$, $m$, and $\\mathbf{F}(\\mathbf{r}^{0})$, so that the very first position update $\\mathbf{r}^{1}=\\mathbf{r}^{0}+h\\,\\mathbf{v}^{1/2}$ achieves local error $\\mathcal{O}(h^{3})$, i.e., the scheme is second-order accurate at the first step.\n\nStarting from the fundamental definitions $\\mathbf{v}(t)=\\dot{\\mathbf{r}}(t)$ and $\\mathbf{a}(t)=\\ddot{\\mathbf{r}}(t)=\\mathbf{F}(\\mathbf{r}(t))/m$, use a Taylor expansion about $t=0$ to derive a consistency condition that $\\mathbf{v}^{1/2}$ must satisfy so that $\\mathbf{r}^{1}$ matches the exact position $\\mathbf{r}(h)$ to within $\\mathcal{O}(h^{3})$. Then, provide an explicit formula for $\\mathbf{v}^{1/2}$ expressed only in terms of the given quantities. Your final answer must be a single closed-form analytic expression for $\\mathbf{v}^{1/2}$.",
            "solution": "The problem requires the derivation of an initialization formula for the half-step velocity, $\\mathbf{v}^{1/2}$, in a leap-frog integration scheme. This initialization must ensure that the first position update, $\\mathbf{r}^{1}$, is second-order accurate, meaning the local error relative to the exact solution $\\mathbf{r}(h)$ is of order $\\mathcal{O}(h^3)$. The formula for $\\mathbf{v}^{1/2}$ can only depend on the initial position $\\mathbf{r}^{0}$, initial velocity $\\mathbf{v}^{0}$, time step $h$, mass $m$, and the force $\\mathbf{F}(\\mathbf{r}^{0})$ evaluated at the initial position.\n\nWe begin by finding the exact position of the particle at time $t=h$ by performing a Taylor series expansion of $\\mathbf{r}(t)$ around $t=0$. The particle's motion is governed by Newton's second law, $m\\,\\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))$. We are given the definitions $\\mathbf{v}(t) = \\dot{\\mathbf{r}}(t)$ and $\\mathbf{a}(t) = \\ddot{\\mathbf{r}}(t) = \\mathbf{F}(\\mathbf{r}(t))/m$. The Taylor expansion of $\\mathbf{r}(t)$ around $t=0$ is:\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0) + t\\,\\dot{\\mathbf{r}}(0) + \\frac{t^2}{2!}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(t^3)\n$$\nEvaluating at $t=h$ and using the initial conditions $\\mathbf{r}(0) = \\mathbf{r}^0$ and $\\dot{\\mathbf{r}}(0) = \\mathbf{v}^0$, we get:\n$$\n\\mathbf{r}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\ddot{\\mathbf{r}}(0) + \\mathcal{O}(h^3)\n$$\nThe acceleration at $t=0$ is $\\mathbf{a}^{0} = \\ddot{\\mathbf{r}}(0) = \\mathbf{F}(\\mathbf{r}(0))/m = \\mathbf{F}(\\mathbf{r}^0)/m$. Substituting this into the expansion gives the exact position up to order $h^2$:\n$$\n\\mathbf{r}_{exact}(h) = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^3)\n$$\nThe numerical approximation for the position at the first time step is given by the leap-frog update rule:\n$$\n\\mathbf{r}^{1} = \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2}\n$$\nThe local error for this first step is the difference between the exact position $\\mathbf{r}_{exact}(h)$ and the numerical approximation $\\mathbf{r}^{1}$. The problem requires this error to be of order $\\mathcal{O}(h^3)$:\n$$\n\\mathbf{r}_{exact}(h) - \\mathbf{r}^{1} = \\mathcal{O}(h^3)\n$$\nSubstituting the expressions for $\\mathbf{r}_{exact}(h)$ and $\\mathbf{r}^{1}$:\n$$\n\\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} \\right) - \\left( \\mathbf{r}^{0} + h\\,\\mathbf{v}^{1/2} \\right) = \\mathcal{O}(h^3)\n$$\nThe term $\\mathbf{r}^{0}$ cancels out. We are left with:\n$$\nh\\,\\mathbf{v}^{0} + \\frac{h^2}{2}\\,\\mathbf{a}^{0} - h\\,\\mathbf{v}^{1/2} = \\mathcal{O}(h^3)\n$$\nTo isolate the condition on $\\mathbf{v}^{1/2}$, we divide the entire equation by the time step $h$:\n$$\n\\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} - \\mathbf{v}^{1/2} = \\mathcal{O}(h^2)\n$$\nRearranging this equation gives the consistency condition that $\\mathbf{v}^{1/2}$ must satisfy:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\nThis condition implies that $\\mathbf{v}^{1/2}$ must be a first-order approximation (in $h$) to the exact velocity at the half-time-step, $t=h/2$. We can verify this by Taylor expanding the exact velocity $\\mathbf{v}(t)$ around $t=0$:\n$$\n\\mathbf{v}(t) = \\mathbf{v}(0) + t\\,\\dot{\\mathbf{v}}(0) + \\mathcal{O}(t^2) = \\mathbf{v}^{0} + t\\,\\mathbf{a}^{0} + \\mathcal{O}(t^2)\n$$\nEvaluating at $t=h/2$:\n$$\n\\mathbf{v}(h/2) = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0} + \\mathcal{O}(h^2)\n$$\nComparing this with the consistency condition for $\\mathbf{v}^{1/2}$, we see that $\\mathbf{v}^{1/2}$ must agree with $\\mathbf{v}(h/2)$ up to terms of order $\\mathcal{O}(h)$.\n\nTo obtain an explicit formula for $\\mathbf{v}^{1/2}$, we can satisfy the consistency condition by simply truncating the series expansion, i.e., dropping the $\\mathcal{O}(h^2)$ term. This gives:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2}\\,\\mathbf{a}^{0}\n$$\nThis choice provides the simplest explicit formula that meets the accuracy requirement. The quantities on the right-hand side are the initial velocity $\\mathbf{v}^{0}$, the time step $h$, and the initial acceleration $\\mathbf{a}^{0}$. The problem specifies that the formula must only use $\\mathbf{r}^{0}$, $\\mathbf{v}^{0}$, $h$, $m$, and $\\mathbf{F}(\\mathbf{r}^{0})$. Since $\\mathbf{a}^{0} = \\mathbf{F}(\\mathbf{r}^{0})/m$, our expression for $\\mathbf{v}^{1/2}$ satisfies this constraint.\n\nSubstituting $\\mathbf{a}^0$:\n$$\n\\mathbf{v}^{1/2} = \\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})\n$$\nThis is the required explicit formula for the initial half-step velocity to achieve second-order accuracy in the first position step of the leap-frog integration.",
            "answer": "$$\\boxed{\\mathbf{v}^{0} + \\frac{h}{2m}\\mathbf{F}(\\mathbf{r}^{0})}$$"
        },
        {
            "introduction": "A core task in computational science is verifying that your code behaves as theory predicts. This practice involves a hands-on numerical experiment to test the performance of the leap-frog and velocity Verlet integrators on a classic anharmonic double-well potential. By measuring how the energy drift scales with the time step $\\Delta t$, you will empirically confirm the second-order accuracy of these symplectic methods and learn to identify the optimal balance between computational cost and precision .",
            "id": "3420524",
            "problem": "Consider a single particle of mass $m$ moving in one spatial dimension under the anharmonic double-well potential $V(x)=\\alpha\\,(x^2-x_0^2)^2$. The force is $F(x)=-\\partial V/\\partial x$. A microcanonical Number of particles, Volume, Energy (NVE) trajectory is generated by integrating Newton's second law $m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2=F(x)$ with two symplectic second-order schemes: the leap-frog method and the velocity Verlet method. Starting from Newton's laws and the definition of velocity as $v=\\mathrm{d}x/\\mathrm{d}t$, implement these two integrators and simulate the dynamics for a fixed total time $T$ with multiple time steps $\\Delta t$. For each integrator and each $\\Delta t$, compute the total energy $E(t)=\\tfrac{1}{2}m\\,v(t)^2+V(x(t))$ and define the absolute relative energy drift after time $T$ as $D(\\Delta t)=\\left|E(T)-E(0)\\right|/\\left|E(0)\\right|$.\n\nYour program must:\n- Evolve the system for each specified $\\Delta t$ and integrator, detect instability (divergence) if any component of the state becomes non-finite (not a real number) or if either $|x|$ or $|v|$ exceeds the bound $10^6$, and in that case mark the drift $D(\\Delta t)$ as undefined for that run.\n- For each test case and each integrator, estimate the exponent $n$ in the scaling law $D(\\Delta t)\\approx C\\,\\Delta t^{n}$ by performing a least-squares linear regression of $\\log D$ versus $\\log \\Delta t$ over all stable runs with $D(\\Delta t)>0$. Report $n$ rounded to two decimal places (in dimensionless units).\n- Define the \"optimal $\\Delta t$ regime\" for each integrator as the set of $\\Delta t$ values among the provided list that are stable and satisfy $D(\\Delta t)\\le\\tau$, where $\\tau$ is a case-specific tolerance. Report the lower and upper bounds of this regime as floats rounded to three decimal places (in dimensionless units). If no time step meets the criterion, report $\\mathrm{NaN}$ for both bounds.\n\nUse reduced dimensionless units with $m=1$; therefore, all reported quantities are dimensionless. No angles are involved. All final numerical answers must be floats. The program should implement both integrators in a scientifically realistic manner and produce results strictly from first principles.\n\nTest suite:\n1. Case $1$ (baseline double well):\n   - Parameters: $\\alpha=1.0$, $x_0=1.0$, $m=1.0$, $T=20.0$.\n   - Initial conditions: $x(0)=0.9$, $v(0)=0.0$.\n   - Time steps: $\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016,\\,0.032\\}$.\n   - Tolerance: $\\tau=10^{-3}$.\n2. Case $2$ (stiffer double well):\n   - Parameters: $\\alpha=5.0$, $x_0=1.0$, $m=1.0$, $T=10.0$.\n   - Initial conditions: $x(0)=0.8$, $v(0)=0.0$.\n   - Time steps: $\\Delta t\\in\\{0.001,\\,0.002,\\,0.004,\\,0.008\\}$.\n   - Tolerance: $\\tau=5\\times 10^{-4}$.\n3. Case $3$ (near-barrier dynamics):\n   - Parameters: $\\alpha=1.0$, $x_0=1.0$, $m=1.0$, $T=20.0$.\n   - Initial conditions: $x(0)=0.0$, $v(0)=0.5$.\n   - Time steps: $\\Delta t\\in\\{0.002,\\,0.004,\\,0.008,\\,0.016\\}$.\n   - Tolerance: $\\tau=2\\times 10^{-3}$.\n\nRequired final output format:\n- Your program should produce a single line containing the results aggregated over the $3$ test cases as a comma-separated list of lists without spaces. For each case, output the list $[n_{\\mathrm{LF}},n_{\\mathrm{VV}},\\Delta t_{\\min,\\mathrm{LF}},\\Delta t_{\\max,\\mathrm{LF}},\\Delta t_{\\min,\\mathrm{VV}},\\Delta t_{\\max,\\mathrm{VV}}]$, where $n_{\\mathrm{LF}}$ is the drift-scaling exponent for the leap-frog method and $n_{\\mathrm{VV}}$ is the drift-scaling exponent for the velocity Verlet method. The two regime bounds are the lower and upper $\\Delta t$ values satisfying the criterion defined above for each integrator. The aggregated output must therefore be of the form $[[\\dots],[\\dots],[\\dots]]$ with all floats rounded as specified.",
            "solution": "The user requests the implementation and analysis of two common symplectic integrators, the leap-frog and velocity Verlet methods, for simulating the dynamics of a particle in a one-dimensional double-well potential. The primary task is to validate the problem, and if valid, provide a complete solution including a Python program.\n\n### Problem Validation\n\nThe problem statement is critically evaluated against the specified criteria.\n\n**Step 1: Extract Givens**\n\n- **System Definition**: A single particle of mass $m$ in one dimension.\n- **Potential Energy**: $V(x) = \\alpha(x^2 - x_0^2)^2$.\n- **Force**: $F(x) = -\\partial V/\\partial x = -4\\alpha x(x^2 - x_0^2)$.\n- **Equation of Motion**: $m\\,\\mathrm{d}^2 x/\\mathrm{d} t^2 = F(x)$.\n- **Numerical Integrators**: Leap-frog method and velocity Verlet method.\n- **Simulation Duration**: Total time $T$.\n- **Time Step**: $\\Delta t$.\n- **Total Energy**: $E(t) = \\frac{1}{2}m v(t)^2 + V(x(t))$.\n- **Energy Drift**: The absolute relative energy drift is defined as $D(\\Delta t) = |E(T) - E(0)|/|E(0)|$.\n- **Instability Condition**: Trajectory is unstable if any state variable ($x$ or $v$) becomes non-finite or if $|x| > 10^6$ or $|v| > 10^6$. For unstable runs, $D(\\Delta t)$ is considered undefined.\n- **Scaling Exponent $n$**: To be estimated from $D(\\Delta t) \\approx C\\,\\Delta t^n$ by a least-squares linear regression of $\\log D$ vs. $\\log \\Delta t$ for all stable runs with $D(\\Delta t) > 0$. The value of $n$ must be rounded to two decimal places.\n- **Optimal $\\Delta t$ Regime**: The set of stable $\\Delta t$ values for which $D(\\Delta t) \\le \\tau$, where $\\tau$ is a given tolerance. The lower and upper bounds of this regime are to be reported, rounded to three decimal places. If no $\\Delta t$ qualifies, `NaN` should be reported for both bounds.\n- **Units**: All quantities are in reduced dimensionless units, with $m=1$.\n- **Test Cases**: Three distinct test cases are provided, each with specific values for $\\alpha$, $x_0$, $T$, initial conditions $(x(0), v(0))$, a set of $\\Delta t$ values, and a tolerance $\\tau$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is fundamentally sound. It involves Newton's second law, a standard anharmonic potential, and canonical numerical integration algorithms (leap-frog/velocity Verlet) used extensively in molecular dynamics and computational physics. The analysis of energy conservation is a cornerstone of evaluating NVE simulations.\n- **Well-Posed**: The problem is well-posed. It describes an initial value problem for a second-order ordinary differential equation. All necessary parameters, initial conditions, and analysis criteria are explicitly provided, ensuring that a unique and meaningful solution can be computed.\n- **Objective**: The problem is stated with scientific objectivity and mathematical precision. All tasks and required outputs are quantitative and free from ambiguity or subjective interpretation.\n- **Completeness and Consistency**: The problem is self-contained. Each test case is fully specified. There are no internal contradictions.\n- **No Other Flaws**: The problem does not violate any other validation criteria. It is not based on false premises, is directly formalizable, is feasible to solve computationally, and is not trivial.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. A full solution will be provided.\n\n### Principle-Based Solution Design\n\nThe core of the problem is to solve Newton's equation of motion, $\\ddot{x} = a(x)$, where the acceleration $a(x) = F(x)/m$. With $m=1$, this simplifies to $a(x) = F(x) = -4\\alpha x (x^2 - x_0^2)$. We will implement two second-order symplectic integrators: velocity Verlet and leap-frog.\n\n**1. Velocity Verlet Integrator**\n\nThis algorithm propagates the state $(x_n, v_n)$ at time $t_n = n\\Delta t$ to $(x_{n+1}, v_{n+1})$ at time $t_{n+1}$. The positions and velocities are synchronized at integer time steps.\n\nThe update rules are as follows:\n1.  Compute the new position:\n    $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n    where $a_n = a(x_n)$.\n2.  Compute the acceleration at the new position:\n    $$a_{n+1} = a(x_{n+1})$$\n3.  Compute the new velocity:\n    $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\n\n**2. Leap-Frog Integrator (Staggered-Time Formulation)**\n\nThis algorithm is often formulated with velocities evaluated at half-integer time steps, $t_{n+1/2} = (n+1/2)\\Delta t$, while positions are at integer steps, $t_n$.\n\nThe update rules for the main loop are:\n1.  Update position:\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n2.  Update velocity to the next half-step:\n    $$v_{n+3/2} = v_{n+1/2} + a_{n+1} \\Delta t$$\n    where $a_{n+1} = a(x_{n+1})$.\n\nTo initialize this scheme from $(x_0, v_0)$ and to obtain the final velocity $v_N$ at the same time $T=N\\Delta t$ as the final position $x_N$, special half-steps are required:\n-   **Initialization**: A preliminary half-step kick for the velocity is needed to start the cycle:\n    $$v_{1/2} = v_0 + \\frac{1}{2} a_0 \\Delta t$$\n-   **Finalization**: After the final position $x_N$ is computed, a final half-step kick synchronizes the velocity:\n    $$v_N = v_{N-1/2} + \\frac{1}{2} a_N \\Delta t$$\n\nIt is a known result in numerical analysis that the velocity Verlet and this specific implementation of the leap-frog integrator are mathematically equivalent. They will produce identical trajectories, assuming identical floating-point arithmetic. Our implementation will respect their distinct algorithmic formulations as requested.\n\n**3. Simulation and Analysis**\n\nFor each test case and each integrator:\n1.  A simulation is run for each specified $\\Delta t$. The total number of steps is $N = \\text{round}(T/\\Delta t)$.\n2.  Initial energy $E_0 = E(0) = \\frac{1}{2} m v(0)^2 + V(x(0))$ is calculated.\n3.  The system is evolved for $N$ steps. During each step, we check for instability ($|x| > 10^6$, $|v| > 10^6$, or non-finite values). If instability occurs, the run is terminated and the drift marked as undefined (e.g., `np.nan`).\n4.  If the simulation completes, the final energy $E_T = E(N\\Delta t)$ is computed, and the drift is calculated as $D(\\Delta t) = |E_T - E_0|/|E_0|$.\n5.  After running simulations for all $\\Delta t$, the scaling exponent $n$ is found. We collect all pairs $(\\Delta t, D)$ for stable runs with $D > 0$. We then perform a linear regression on their logarithms: $\\log D = n \\log(\\Delta t) + \\text{const}$. The slope of this fit gives $n$. This requires at least two valid data points.\n6.  The optimal $\\Delta t$ regime is determined by finding all stable $\\Delta t$ where the drift $D(\\Delta t)$ is less than or equal to the case-specific tolerance $\\tau$. The minimum and maximum values in this set form the bounds of the regime.\n\nThis structured approach ensures all problem requirements are met, leading to the final Python implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, process test cases, and print results.\n    \"\"\"\n    # Define test cases as per the problem statement.\n    test_cases = [\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.9, \"v_init\": 0.0,\n            \"dts\": [0.002, 0.004, 0.008, 0.016, 0.032],\n            \"tau\": 1e-3\n        },\n        {\n            \"alpha\": 5.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 10.0,\n            \"x_init\": 0.8, \"v_init\": 0.0,\n            \"dts\": [0.001, 0.002, 0.004, 0.008],\n            \"tau\": 5e-4\n        },\n        {\n            \"alpha\": 1.0, \"x0\": 1.0, \"m\": 1.0, \"T\": 20.0,\n            \"x_init\": 0.0, \"v_init\": 0.5,\n            \"dts\": [0.002, 0.004, 0.008, 0.016],\n            \"tau\": 2e-3\n        }\n    ]\n\n    # Helper functions for the physics\n    def potential(x, alpha, x0_pot):\n        return alpha * (x**2 - x0_pot**2)**2\n\n    def acceleration(x, m, alpha, x0_pot):\n        force = -4 * alpha * x * (x**2 - x0_pot**2)\n        return force / m\n\n    def total_energy(x, v, m, alpha, x0_pot):\n        return 0.5 * m * v**2 + potential(x, alpha, x0_pot)\n\n    def run_velocity_verlet(params):\n        \"\"\"\n        Runs a simulation using the velocity Verlet integrator.\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        \n        for _ in range(n_steps):\n            x = x + v * dt + 0.5 * a * dt**2\n            a_new = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v = v + 0.5 * (a + a_new) * dt\n            a = a_new\n            \n            if not (np.isfinite(x) and np.isfinite(v) and abs(x) < stability_bound and abs(v) < stability_bound):\n                return np.nan, np.nan\n        \n        return x, v\n\n    def run_leap_frog(params):\n        \"\"\"\n        Runs a simulation using the leap-frog integrator (staggered time).\n        \"\"\"\n        x = params['x_init']\n        v = params['v_init']\n        dt = params['dt']\n        n_steps = int(round(params['T'] / dt))\n        stability_bound = 1e6\n\n        a = acceleration(x, params['m'], params['alpha'], params['x0'])\n        v_half = v + 0.5 * a * dt\n        \n        for _ in range(n_steps):\n            x = x + v_half * dt\n            \n            if not (np.isfinite(x) and abs(x) < stability_bound):\n                return np.nan, np.nan\n            \n            a = acceleration(x, params['m'], params['alpha'], params['x0'])\n            v_half = v_half + a * dt\n            \n            # Use v_half as a proxy for velocity magnitude check\n            if not (np.isfinite(v_half) and abs(v_half) < stability_bound):\n                return np.nan, np.nan\n\n        # Final half-step to synchronize velocity\n        v_final = v_half - 0.5 * a * dt\n        return x, v_final\n\n    def analyze_results(dts, drifts, tau):\n        \"\"\"\n        Analyzes simulation results to find scaling exponent and optimal regime.\n        \"\"\"\n        # Prepare data for scaling exponent calculation\n        log_dts_stable = []\n        log_drifts_stable = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift > 0:\n                log_dts_stable.append(np.log(dt))\n                log_drifts_stable.append(np.log(drift))\n        \n        # Calculate scaling exponent n\n        if len(log_dts_stable) < 2:\n            n = np.nan\n        else:\n            res = linregress(log_dts_stable, log_drifts_stable)\n            n = round(res.slope, 2)\n            \n        # Find optimal dt regime\n        optimal_dts = []\n        for dt, drift in zip(dts, drifts):\n            if np.isfinite(drift) and drift <= tau:\n                optimal_dts.append(dt)\n        \n        if not optimal_dts:\n            dt_min, dt_max = np.nan, np.nan\n        else:\n            dt_min = round(min(optimal_dts), 3)\n            dt_max = round(max(optimal_dts), 3)\n            \n        return n, dt_min, dt_max\n\n    all_case_results = []\n    integrators = {\"LF\": run_leap_frog, \"VV\": run_velocity_verlet}\n\n    for case in test_cases:\n        case_results = {}\n        for name, integrator_func in integrators.items():\n            drifts = []\n            for dt_val in case['dts']:\n                sim_params = case.copy()\n                sim_params['dt'] = dt_val\n                \n                e_initial = total_energy(case['x_init'], case['v_init'], case['m'], case['alpha'], case['x0'])\n                \n                x_final, v_final = integrator_func(sim_params)\n                \n                if not np.isfinite(x_final):\n                    drift = np.nan\n                else:\n                    e_final = total_energy(x_final, v_final, case['m'], case['alpha'], case['x0'])\n                    # Avoid division by zero if E(0) is zero.\n                    if abs(e_initial) < 1e-15:\n                        drift = abs(e_final - e_initial)\n                    else:\n                        drift = abs(e_final - e_initial) / abs(e_initial)\n                \n                drifts.append(drift)\n            \n            n, dt_min, dt_max = analyze_results(case['dts'], drifts, case['tau'])\n            case_results[name] = [n, dt_min, dt_max]\n\n        all_case_results.append([\n            case_results[\"LF\"][0], case_results[\"VV\"][0],\n            case_results[\"LF\"][1], case_results[\"LF\"][2],\n            case_results[\"VV\"][1], case_results[\"VV\"][2]\n        ])\n\n    # Final print statement in the exact required format.\n    # Convert numpy.nan to float('nan') for string representation as 'nan'\n    formatted_results = []\n    for case_res in all_case_results:\n        formatted_case = []\n        for item in case_res:\n            if np.isnan(item):\n                formatted_case.append(float('nan'))\n            else:\n                formatted_case.append(item)\n        formatted_results.append(formatted_case)\n    \n    print(str(formatted_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "Verlet-type integrators are celebrated for their long-term stability, a property guaranteed for smooth, well-behaved potentials. This advanced problem moves beyond ideal scenarios to explore what happens when forces are non-smooth, a situation that can arise in certain coarse-grained or piecewise models. By simulating a particle in a \"cusp\" potential, you will discover the failure modes of standard integrators and learn to apply regularization techniques to restore stable and accurate dynamics .",
            "id": "3420474",
            "problem": "Consider a one-dimensional particle of mass $m$ moving under a time-independent potential energy function $V(q)$. The motion obeys Newton’s second law $m \\,\\mathrm{d}^{2}q/\\mathrm{d}t^{2} = F(q)$ with $F(q) = -\\mathrm{d}V/\\mathrm{d}q$. You will examine the behavior of two symplectic integrators commonly used in molecular dynamics, namely the leap-frog method and the velocity Verlet method, when the force is non-Lipschitz at a point. Specifically, consider the cusp potential $V(q) = |q|$, which induces the piecewise constant force $F(q) = -\\mathrm{sign}(q)$ that is undefined at $q=0$ and non-Lipschitz in any neighborhood of $q=0$. You will study failure modes of these integrators for this potential, and then test regularization strategies that smooth the cusp near $q=0$ to restore Lipschitz continuity of the force.\n\nYour tasks are:\n- Implement the leap-frog method and the velocity Verlet method starting from Newton’s second law, without using any pre-packaged ordinary differential equation solver.\n- Implement three potentials:\n  - The cusp potential $V(q)=|q|$, with the naive convention $F(0)=0$.\n  - A smooth regularization $V_{\\varepsilon}(q) = \\sqrt{q^{2} + \\varepsilon^{2}}$, parameterized by $\\varepsilon > 0$, which yields $F_{\\varepsilon}(q) = -q/\\sqrt{q^{2} + \\varepsilon^{2}}$.\n  - A Huber-type regularization $V_{\\delta}(q)$ defined by $V_{\\delta}(q) = \\frac{q^{2}}{2\\delta}$ if $|q| \\le \\delta$ and $V_{\\delta}(q) = |q| - \\frac{\\delta}{2}$ if $|q| > \\delta$, which yields $F_{\\delta}(q) = -q/\\delta$ if $|q| \\le \\delta$ and $F_{\\delta}(q) = -\\mathrm{sign}(q)$ if $|q| > \\delta$.\n- For each simulation, compute the discrete total energy $E_{n} = \\frac{1}{2} m v_{n}^{2} + V(q_{n})$ at equally spaced times $t_{n} = n\\,\\Delta t$ for $n=0,1,\\dots,N$, with time step $\\Delta t$ and total integration time $T = N \\,\\Delta t$.\n- Quantify long-time energy drift by fitting a least-squares line $E(t) \\approx s\\,t + b$ to $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$ and reporting the fitted slope $s$. This slope $s$ is your scalar performance metric for each test. Report $s$ in dimensionless energy per unit time, since all quantities are to be treated in dimensionless units.\n\nScientific and numerical requirements:\n- Begin from Newton’s second law and standard definitions of velocity and acceleration.\n- Do not use any pre-packaged ordinary differential equation solvers.\n- Use dimensionless units with $m=1$, and report the energy-drift slope $s$ in the same dimensionless units (energy per unit time).\n- Angles are not involved; no angle units are required.\n\nTest suite:\nUse the following test cases, each defined by a tuple of parameters $(\\text{integrator}, \\text{potential}, \\Delta t, T, q_{0}, v_{0}, \\text{reg\\_param})$, where $m=1$ throughout, the integrator is either leap-frog or velocity Verlet, the potential is one of the three described above, and $\\text{reg\\_param}$ is unused for the cusp potential. For the smooth regularization use $\\varepsilon$ as $\\text{reg\\_param}$, and for the Huber regularization use $\\delta$ as $\\text{reg\\_param}$.\n\n- Case A: (velocity Verlet, cusp, $\\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case B: (leap-frog, cusp, $\\Delta t = 0.05, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case C: (velocity Verlet, cusp, $\\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\text{reg\\_param} = \\text{None})$.\n- Case D: (velocity Verlet, smooth, $\\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\varepsilon = 10^{-2})$.\n- Case E: (leap-frog, Huber, $\\Delta t = 0.2, T = 20.0, q_{0} = 0.1, v_{0} = 0.0, \\delta = 10^{-2})$.\n- Case F: (velocity Verlet, cusp, $\\Delta t = 0.05, T = 20.0, q_{0} = 0.0, v_{0} = 0.1, \\text{reg\\_param} = \\text{None})$.\n\nYour program should:\n- Implement both integrators and all three potentials as described.\n- For each test case, integrate up to time $T$ with step $\\Delta t$, compute the sequence $\\{(t_{n}, E_{n})\\}_{n=0}^{N}$, and output the least-squares slope $s$ of $E$ versus $t$.\n- Aggregate the slopes for Cases A through F in that order into a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result\\_A}, \\text{result\\_B}, \\dots, \\text{result\\_F}]$.\n\nAll outputs must be reported in the specified dimensionless energy per unit time. The final output must be exactly one line in the format described above, with no additional text or lines.",
            "solution": "The problem requires the implementation and comparison of two numerical integrators, the leap-frog and velocity Verlet methods, for a one-dimensional particle of mass $m=1$ under a potential $V(q)$. The focus is on the behavior of these integrators when the force $F(q) = -\\mathrm{d}V/\\mathrm{d}q$ is non-Lipschitz, specifically for the cusp potential $V(q)=|q|$. Two regularization strategies are also investigated. The performance metric is the long-term energy drift, quantified by the slope $s$ of a linear least-squares fit to the total energy time series.\n\n1. Potential and Force Functions\nWe implement the three specified potential energy functions and their corresponding forces. All quantities are in dimensionless units.\n\n1.1. Cusp Potential\nThe potential is $V(q) = |q|$. The force is $F(q) = -\\mathrm{d}V/\\mathrm{d}q = -\\mathrm{sign}(q)$. At $q=0$, the derivative is undefined. The problem specifies the convention $F(0)=0$. This is naturally handled by numerical libraries where $\\mathrm{sign}(0)=0$.\n\n1.2. Smooth Regularization\nThe potential is $V_{\\varepsilon}(q) = \\sqrt{q^2 + \\varepsilon^2}$, parameterized by $\\varepsilon > 0$. The corresponding force is $F_{\\varepsilon}(q) = -q/\\sqrt{q^2 + \\varepsilon^2}$. This force function is smooth for $\\varepsilon > 0$ and approximates $-\\mathrm{sign}(q)$ for small $\\varepsilon$ and $|q| \\gg \\varepsilon$.\n\n1.3. Huber-type Regularization\nThis potential is defined piecewise:\n$$\nV_{\\delta}(q) = \n\\begin{cases} \n\\frac{q^2}{2\\delta} & \\text{if } |q| \\le \\delta \\\\\n|q| - \\frac{\\delta}{2} & \\text{if } |q| > \\delta \n\\end{cases}\n$$\nThis potential is continuously differentiable. The force is:\n$$\nF_{\\delta}(q) = \n\\begin{cases} \n-q/\\delta & \\text{if } |q| \\le \\delta \\\\\n-\\mathrm{sign}(q) & \\text{if } |q| > \\delta \n\\end{cases}\n$$\nThis force is continuous and Lipschitz, providing a different way to regularize the cusp.\n\n2. Numerical Integrators\nWe start from Newton's second law, $m\\ddot{q} = F(q)$, which is $\\ddot{q} = F(q)$ for $m=1$. Let $q_n$, $v_n$, and $a_n$ be the position, velocity, and acceleration at time $t_n = n\\Delta t$.\n\n2.1. Velocity Verlet Method\nThe velocity Verlet algorithm updates positions and velocities as follows:\n1. $q_{n+1} = q_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$\n2. $a_{n+1} = F(q_{n+1})/m$\n3. $v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$\nThis method is time-reversible and symplectic, generally leading to good long-term energy conservation for smooth potentials. It requires one force evaluation per time step. The quantities $q_n$ and $v_n$ are synchronized at integer time steps, allowing for a direct calculation of the energy $E_n = \\frac{1}{2}mv_n^2 + V(q_n)$.\n\n2.2. Leap-frog Method\nThe term \"leap-frog\" can refer to several algebraically equivalent formulations. A common one is the \"kick-drift-kick\" (KDK) form, which is also known as the position-update form or LF2. This method is algebraically identical to the velocity Verlet method. Its steps are:\n1. (Kick) $v_{n+1/2} = v_n + \\frac{1}{2} a_n \\Delta t$\n2. (Drift) $q_{n+1} = q_n + v_{n+1/2} \\Delta t$\n3. (Kick) $v_{n+1} = v_{n+1/2} + \\frac{1}{2} a_{n+1} \\Delta t$, where $a_{n+1} = F(q_{n+1})/m$.\nBy providing positions and velocities at the same integer time steps, this form also allows for straightforward energy calculation. Given its algebraic equivalence to velocity Verlet, we expect the simulation trajectories and hence the energy drifts to be identical up to floating-point precision differences. The problem's inclusion of test cases comparing these two methods likely serves to verify this equivalence.\n\n3. Simulation and Analysis\nFor each test case, the system is integrated from $t=0$ to $T$ using a fixed time step $\\Delta t$, generating a sequence of positions and velocities. The total energy $E_n = \\frac{1}{2} m v_n^2 + V(q_n)$ is computed at each step $n=0, 1, \\dots, N$, where $N=T/\\Delta t$.\nThe long-term energy drift is quantified by the slope $s$ of a simple linear regression line fitted to the discrete energy data points $\\{(t_n, E_n)\\}_{n=0}^N$. This is computed using `numpy.polyfit(t, E, 1)`, which provides robust and standard least-squares fitting. The resulting slope $s$ represents the average rate of energy change over the simulation.\n\n4. Implementation Details\nThe simulation is implemented in Python using the `numpy` library. Dedicated functions are created for each potential and integrator. A main control loop iterates through the specified test cases, runs the appropriate simulation, computes the energy drift slope, and collects the results.\nThe number of steps $N$ is calculated as `int(round(T/dt))` to avoid floating point inaccuracies. The time array is generated using `numpy.linspace(0, T, N + 1)` to ensure the final time point is exactly $T$. \nFor the cusp potential, the convention $F(0)=0$ is handled correctly by `numpy.sign(0)`, which returns $0$.\nThe final list of slopes for test cases A through F is formatted into the specified string representation.",
            "answer": "```python\nimport numpy as np\n\ndef V_cusp(q):\n    \"\"\"Cusp potential V(q) = |q|.\"\"\"\n    return np.abs(q)\n\ndef F_cusp(q):\n    \"\"\"Force for cusp potential, F(q) = -sign(q), with F(0)=0.\"\"\"\n    return -np.sign(q)\n\ndef V_smooth(q, eps):\n    \"\"\"Smoothly regularized potential.\"\"\"\n    return np.sqrt(q**2 + eps**2)\n\ndef F_smooth(q, eps):\n    \"\"\"Force for smoothly regularized potential.\"\"\"\n    denom = np.sqrt(q**2 + eps**2)\n    return -q / denom if denom != 0 else 0.0\n\ndef V_huber(q, delta):\n    \"\"\"Huber-type regularized potential.\"\"\"\n    if np.abs(q) <= delta:\n        return 0.5 * q**2 / delta\n    else:\n        return np.abs(q) - 0.5 * delta\n\ndef F_huber(q, delta):\n    \"\"\"Force for Huber-type regularized potential.\"\"\"\n    if np.abs(q) <= delta:\n        return -q / delta\n    else:\n        return -np.sign(q)\n\ndef velocity_verlet(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Velocity Verlet integrator.\"\"\"\n    q = np.zeros(N + 1)\n    v = np.zeros(N + 1)\n    E = np.zeros(N + 1)\n    \n    q[0] = q0\n    v[0] = v0\n    E[0] = 0.5 * m * v[0]**2 + V_func(q[0])\n    \n    a_curr = F_func(q[0]) / m\n    \n    for n in range(N):\n        q[n+1] = q[n] + v[n] * dt + 0.5 * a_curr * dt**2\n        a_next = F_func(q[n+1]) / m\n        v[n+1] = v[n] + 0.5 * (a_curr + a_next) * dt\n        E[n+1] = 0.5 * m * v[n+1]**2 + V_func(q[n+1])\n        a_curr = a_next\n        \n    return E\n\ndef leap_frog(F_func, V_func, q0, v0, dt, N, m):\n    \"\"\"Leap-frog integrator (kick-drift-kick formulation).\"\"\"\n    q_curr = q0\n    v_curr = v0\n    E = np.zeros(N + 1)\n    E[0] = 0.5 * m * v_curr**2 + V_func(q_curr)\n    \n    a_curr = F_func(q_curr) / m\n    \n    for n in range(N):\n        v_half = v_curr + 0.5 * a_curr * dt\n        q_curr = q_curr + v_half * dt\n        a_curr = F_func(q_curr) / m\n        v_curr = v_half + 0.5 * a_curr * dt\n        E[n+1] = 0.5 * m * v_curr**2 + V_func(q_curr)\n        \n    return E\n\ndef run_simulation(integrator_name, potential_name, dt, T, q0, v0, reg_param):\n    \"\"\"Runs a single simulation and returns the energy drift slope.\"\"\"\n    m = 1.0\n    N = int(round(T / dt))\n    t = np.linspace(0, T, N + 1)\n\n    if potential_name == 'cusp':\n        V_func = V_cusp\n        F_func = F_cusp\n    elif potential_name == 'smooth':\n        V_func = lambda q: V_smooth(q, reg_param)\n        F_func = lambda q: F_smooth(q, reg_param)\n    elif potential_name == 'Huber':\n        V_func = lambda q: V_huber(q, reg_param)\n        F_func = lambda q: F_huber(q, reg_param)\n    else:\n        raise ValueError(f\"Unknown potential: {potential_name}\")\n\n    if integrator_name == 'velocity Verlet':\n        integrator_func = velocity_verlet\n    elif integrator_name == 'leap-frog':\n        integrator_func = leap_frog\n    else:\n        raise ValueError(f\"Unknown integrator: {integrator_name}\")\n\n    E = integrator_func(F_func, V_func, q0, v0, dt, N, m)\n    \n    slope, _ = np.polyfit(t, E, 1)\n    \n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case B\n        ('leap-frog', 'cusp', 0.05, 20.0, 0.1, 0.0, None),\n        # Case C\n        ('velocity Verlet', 'cusp', 0.2, 20.0, 0.1, 0.0, None),\n        # Case D\n        ('velocity Verlet', 'smooth', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case E\n        ('leap-frog', 'Huber', 0.2, 20.0, 0.1, 0.0, 1e-2),\n        # Case F\n        ('velocity Verlet', 'cusp', 0.05, 20.0, 0.0, 0.1, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        slope = run_simulation(*case)\n        results.append(slope)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}