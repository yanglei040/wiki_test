{
    "hands_on_practices": [
        {
            "introduction": "The foundation of molecular dynamics lies in solving Newton's equations of motion, a task that must be performed numerically for any complex system. This practice guides you through the implementation of the velocity Verlet algorithm, the workhorse integrator for microcanonical (NVE) simulations, using the realistic Morse potential as a model system. By analyzing the relationship between the integration timestep and energy conservation, you will gain first-hand experience with the concepts of stability and accuracy that are fundamental to all molecular dynamics simulations .",
            "id": "3401300",
            "problem": "Consider a single particle of mass $m$ moving in one spatial dimension under the Morse potential, a standard model for diatomic molecular vibrations. The Morse potential $V(r)$ is defined as\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2,\n$$\nwhere $D_e$ is the well depth (in joules), $a$ is a range parameter (in meters$^{-1}$), and $r_e$ is the equilibrium bond length (in meters). The motion obeys Newton's second law, namely $m \\,\\ddot{r} = F(r)$ with $F(r) = -\\frac{dV}{dr}$, and energy $E(r, \\dot{r}) = \\frac{1}{2} m \\dot{r}^2 + V(r)$ is conserved for exact dynamics.\n\nYour task is to write a complete program that:\n- Implements the velocity Verlet integrator (without using external libraries beyond those permitted) to advance the dynamics in time for the above system.\n- Computes the fastest small-amplitude vibrational angular frequency $\\omega_{\\max}$ around the minimum of the Morse potential by using the curvature at the minimum,\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}}, \\quad k = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}.\n$$\n- Uses a set of timesteps $\\Delta t$ constructed as fractions $s$ of the fundamental period $T = \\frac{2\\pi}{\\omega_{\\max}}$, namely $\\Delta t = s\\,T$.\n- For each timestep, integrates the dynamics for a total duration equal to $N_{\\text{periods}}$ full periods, starting from initial position $r(0) = r_e + x_0$ and initial velocity $\\dot{r}(0) = 0$, with $x_0$ a small displacement to remain in the near-harmonic regime.\n- Reports, for each timestep, the maximum relative energy error attained during the integration, defined as\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le t \\le N_{\\text{periods}} T} \\frac{\\left|E(t) - E(0)\\right|}{E(0)}.\n$$\n\nUse the following parameter values (in International System of Units):\n- $D_e = 3.0 \\,\\text{eV}$ converted to joules using $1\\,\\text{eV} = 1.602176634 \\times 10^{-19}\\,\\text{J}$, so that $D_e = 3.0 \\times 1.602176634 \\times 10^{-19}\\,\\text{J}$,\n- $a = 2.0 \\times 10^{10}\\,\\text{m}^{-1}$,\n- $r_e = 1.0 \\times 10^{-10}\\,\\text{m}$,\n- $m = 1.0 \\times 10^{-26}\\,\\text{kg}$,\n- $x_0 = 2.0 \\times 10^{-12}\\,\\text{m}$,\n- $N_{\\text{periods}} = 50$.\n\nTest suite specification (each test case is one $s$ value, which defines $\\Delta t = s\\,T$):\n- $s = 0.01$ (small timestep),\n- $s = 0.05$ (moderate timestep),\n- $s = 0.10$ (larger timestep),\n- $s = 0.20$ (near the limit of practical accuracy),\n- $s = \\frac{1.9}{2\\pi}$ (a boundary case close to the harmonic stability threshold $\\Delta t \\,\\omega \\approx 2$).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, in the order of the test suite above. For example, the output should be formatted as $[x_1,x_2,x_3,x_4,x_5]$, where each $x_i$ is the maximum relative energy error $\\varepsilon_{\\max}$ for the corresponding $s$.\n- The reported values are dimensionless floats; no physical units are required in the output.",
            "solution": "The problem is valid as it is scientifically grounded in classical mechanics and computational physics, well-posed with a complete set of parameters and clear objectives, and formulated objectively. We can therefore proceed with a solution.\n\nThe motion of a particle of mass $m$ in one dimension is governed by the Morse potential $V(r)$, given by:\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2\n$$\nHere, $D_e$ is the potential well depth, $a$ is a parameter controlling the width of the potential, and $r_e$ is the equilibrium position corresponding to the potential minimum.\n\nThe force $F(r)$ acting on the particle is the negative gradient of the potential energy:\n$$\nF(r) = -\\frac{dV}{dr}\n$$\nUsing the chain rule, with $u(r) = 1 - e^{-a(r-r_e)}$, we have $\\frac{dV}{dr} = \\frac{d(D_e u^2)}{du} \\frac{du}{dr}$.\nThe derivatives are $\\frac{d(D_e u^2)}{du} = 2D_e u = 2D_e(1 - e^{-a(r-r_e)})$ and $\\frac{du}{dr} = -e^{-a(r-r_e)}(-a) = a e^{-a(r-r_e)}$.\nCombining these gives:\n$$\n\\frac{dV}{dr} = 2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)}\n$$\nThus, the force is:\n$$\nF(r) = -2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)} = -2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right)\n$$\n\nFor small displacements around the equilibrium position $r_e$, the potential can be approximated by a harmonic potential $V(r) \\approx \\frac{1}{2} k (r-r_e)^2$, where $k$ is the spring constant. The spring constant is determined by the curvature of the potential at the minimum:\n$$\nk = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}\n$$\nDifferentiating the expression for $\\frac{dV}{dr}$:\n$$\n\\frac{d^2 V}{dr^2} = \\frac{d}{dr} \\left[ 2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) \\right] = 2a D_e \\left( -a e^{-a(r-r_e)} - (-2a) e^{-2a(r-r_e)} \\right)\n$$\n$$\n\\frac{d^2 V}{dr^2} = 2a^2 D_e \\left( 2e^{-2a(r-r_e)} - e^{-a(r-r_e)} \\right)\n$$\nEvaluating this at $r=r_e$:\n$$\nk = 2a^2 D_e \\left( 2e^0 - e^0 \\right) = 2a^2 D_e (2 - 1) = 2a^2 D_e\n$$\nThe angular frequency of small-amplitude oscillations is then:\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{2a^2 D_e}{m}} = a\\sqrt{\\frac{2D_e}{m}}\n$$\nThe corresponding period of oscillation is $T = \\frac{2\\pi}{\\omega_{\\max}}$.\n\nTo simulate the dynamics, we employ the velocity Verlet integration algorithm. This is a time-reversible and symplectic integrator, which leads to good conservation of total energy over long simulation times. For a given timestep $\\Delta t$, the position $r$, velocity $v$, and acceleration $acc = F/m$ are updated as follows:\n1. Update position: $r(t + \\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2} acc(t) (\\Delta t)^2$\n2. Calculate new force and acceleration: $F(t+\\Delta t)=F(r(t+\\Delta t))$ and $acc(t+\\Delta t) = F(t+\\Delta t)/m$.\n3. Update velocity: $v(t + \\Delta t) = v(t) + \\frac{1}{2} \\left[ acc(t) + acc(t+\\Delta t) \\right] \\Delta t$\n\nThe simulation starts from the initial conditions $r(0) = r_e + x_0$ and $\\dot{r}(0) = v(0) = 0$. The initial total energy $E(0)$ is purely potential energy:\n$$\nE(0) = \\frac{1}{2} m v(0)^2 + V(r(0)) = V(r_e + x_0) = D_e \\left(1 - e^{-a x_0}\\right)^2\n$$\nThe simulation runs for a total duration of $N_{\\text{periods}}T$, using a timestep $\\Delta t = sT$. The number of integration steps is therefore $N_{\\text{steps}} = \\frac{N_{\\text{periods}} T}{sT} = \\frac{N_{\\text{periods}}}{s}$. At each step $i$, we compute the total energy $E(t_i) = \\frac{1}{2} m v(t_i)^2 + V(r(t_i))$ and the relative energy error $\\varepsilon_i = \\frac{|E(t_i) - E(0)|}{E(0)}$. The final reported quantity is the maximum relative error observed throughout the simulation:\n$$\n\\varepsilon_{\\max} = \\max_{i} \\varepsilon_i\n$$\n\nThe procedure for each given value of $s$ is:\n1. Calculate the constants $k$, $\\omega_{\\max}$, and $T$.\n2. Determine the timestep $\\Delta t = sT$ and the total number of steps $N_{\\text{steps}} = \\text{round}(N_{\\text{periods}}/s)$.\n3. Initialize position $r$, velocity $v$, and acceleration $acc$ according to the initial conditions. Compute the initial energy $E(0)$.\n4. Loop for $N_{\\text{steps}}$ iterations, applying the velocity Verlet update rules at each step.\n5. In each iteration, calculate the current energy $E(t)$ and update the maximum observed relative error $\\varepsilon_{\\max}$.\n6. After the loop, the final value of $\\varepsilon_{\\max}$ is the result for the given $s$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics problem for a particle in a Morse potential\n    using the velocity Verlet integrator and calculates the maximum relative\n    energy error for different timesteps.\n    \"\"\"\n\n    # --- Problem Parameters (SI units) ---\n    EV_TO_JOULE = 1.602176634e-19\n    D_e = 3.0 * EV_TO_JOULE  # Well depth (J)\n    a = 2.0e10               # Range parameter (m^-1)\n    r_e = 1.0e-10            # Equilibrium distance (m)\n    m = 1.0e-26              # Mass (kg)\n    x_0 = 2.0e-12            # Initial displacement (m)\n    N_periods = 50.0         # Number of periods to simulate\n\n    # --- Test Suite ---\n    # Each value 's' defines a timestep dt = s * T\n    s_values = [0.01, 0.05, 0.10, 0.20, 1.9 / (2 * np.pi)]\n\n    # --- Helper Functions for Physics ---\n    def potential(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the Morse potential energy.\"\"\"\n        return D_e_val * (1.0 - np.exp(-a_val * (r - r_e_val)))**2\n\n    def force(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the force derived from the Morse potential.\"\"\"\n        # This form is slightly more efficient as it computes exp once.\n        # F(r) = -2*a*D_e * (exp(-a(r-re)) - exp(-2a(r-re)))\n        exp_term = np.exp(-a_val * (r - r_e_val))\n        return -2.0 * a_val * D_e_val * (exp_term - exp_term**2)\n\n    def total_energy(r, v, m_val, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the total energy (kinetic + potential).\"\"\"\n        kinetic = 0.5 * m_val * v**2\n        potential_e = potential(r, D_e_val, a_val, r_e_val)\n        return kinetic + potential_e\n\n    # --- Derived Harmonic Quantities ---\n    # Stiffness k = d^2V/dr^2 at r=r_e\n    k = 2.0 * a**2 * D_e\n    # Harmonic angular frequency omega_max = sqrt(k/m)\n    omega_max = np.sqrt(k / m)\n    # Harmonic period T = 2*pi / omega_max\n    T = 2.0 * np.pi / omega_max\n\n    results = []\n\n    # --- Main Loop over Test Cases ---\n    for s in s_values:\n        # --- Simulation Setup ---\n        dt = s * T\n        num_steps = int(round(N_periods / s))\n\n        # --- Initial Conditions ---\n        r = r_e + x_0\n        v = 0.0\n        acc = force(r, D_e, a, r_e) / m\n\n        # --- Initial Energy Calculation ---\n        E0 = total_energy(r, v, m, D_e, a, r_e)\n        if E0 == 0:\n            # This case should not be reached with the given parameters\n            # but is a safeguard against division by zero.\n            max_rel_error = 0.0\n        else:\n            max_rel_error = 0.0\n\n            # --- Velocity Verlet Integration Loop ---\n            for _ in range(num_steps):\n                # 1. Update position\n                r = r + v * dt + 0.5 * acc * dt**2\n                \n                # 2. Calculate new force and acceleration\n                acc_new = force(r, D_e, a, r_e) / m\n                \n                # 3. Update velocity\n                v = v + 0.5 * (acc + acc_new) * dt\n                \n                # Update acceleration for the next step\n                acc = acc_new\n\n                # 4. Calculate energy drift\n                E_t = total_energy(r, v, m, D_e, a, r_e)\n                rel_error = np.abs((E_t - E0) / E0)\n                \n                # 5. Update maximum relative error\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n\n        results.append(max_rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While NVE simulations are fundamental, many physical and chemical processes occur at constant temperature, requiring the use of a thermostat to simulate the canonical (NVT) ensemble. However, not all thermostats are created equal; a correct thermostat must generate trajectories that sample the true Boltzmann distribution. This exercise challenges you to perform a rigorous analysis of the widely-known Berendsen thermostat, revealing through a study of phase-space compressibility why it fails to generate a proper canonical ensemble despite its intuitive appeal .",
            "id": "3401289",
            "problem": "Consider a system of $N$ particles with positions $q \\in \\mathbb{R}^{3N}$ and momenta $p \\in \\mathbb{R}^{3N}$, governed by a Hamiltonian $H(q,p) = \\sum_{i=1}^{3N} \\frac{p_i^2}{2 m_i} + U(q)$ and the deterministic Berendsen thermostat. The deterministic Berendsen thermostat modifies the equations of motion to\n$$\\dot{q}_i = \\frac{p_i}{m_i}, \\qquad \\dot{p}_i = F_i(q) - \\alpha(p)\\, p_i,$$\nwhere $F_i(q) = -\\frac{\\partial U}{\\partial q_i}$, the instantaneous kinetic energy is $K(p) = \\sum_{i=1}^{3N} \\frac{p_i^2}{2 m_i}$, the number of quadratic degrees of freedom is $f$ (typically $f = 3N$ minus any holonomic constraints), the instantaneous temperature is $T(p) = \\frac{2 K(p)}{f k_{\\mathrm{B}}}$, the target temperature is $T_0$, the relaxation time is $\\tau$, and\n$$\\alpha(p) = \\frac{1}{\\tau}\\left(1 - \\frac{T_0}{T(p)}\\right) = \\frac{1}{\\tau}\\left(1 - \\frac{T_0 f k_{\\mathrm{B}}}{2 K(p)}\\right).$$\nDefine the phase-space point $X = (q,p)$ and the phase-space flow $\\dot{X} = (\\dot{q},\\dot{p})$. The phase-space compressibility is the divergence of the flow in phase space,\n$$\\kappa(X) = \\nabla_{q} \\cdot \\dot{q} + \\nabla_{p} \\cdot \\dot{p},$$\nand an invariant measure $\\rho(X)$ for deterministic dynamics satisfies the stationary continuity equation $\\nabla_{X} \\cdot \\left(\\rho(X)\\, \\dot{X}\\right) = 0$. For stochastic dynamics, the invariant measure is characterized through the stationary solution of the corresponding Fokker–Planck equation (Fokker–Planck).\n\nIn stochastic velocity rescaling, at each infinitesimal time interval the momenta are globally rescaled by a random factor chosen so that the marginal distribution of kinetic energy is the $\\chi^2$ distribution with $f$ degrees of freedom at temperature $T_0$. In the continuous-time limit, this defines a Markov process on $p$ with drift and diffusion carefully balanced to leave the canonical Boltzmann distribution invariant.\n\nUsing only fundamental definitions and conservation laws of classical mechanics, Liouville’s theorem for Hamiltonian flows, and the continuity equation in phase space, analyze the phase-space compressibility and invariant measures for the deterministic Berendsen thermostat and for stochastic velocity rescaling. Then choose the statement that is most consistent with your derivations.\n\nA. For the deterministic Berendsen thermostat, the phase-space compressibility is $\\kappa(q,p) = - f\\, \\alpha(p) - \\dfrac{T_0 f k_{\\mathrm{B}}}{\\tau\\, K(p)}$, and the canonical Boltzmann density $\\rho_\\beta(q,p) \\propto \\exp\\!\\left(-\\beta H(q,p)\\right)$ with $\\beta = 1/(k_{\\mathrm{B}} T_0)$ is not invariant; in contrast, stochastic velocity rescaling admits the canonical Boltzmann distribution on full phase space as an invariant measure.\n\nB. Both the deterministic Berendsen thermostat and stochastic velocity rescaling are incompressible in phase space, hence both preserve the canonical Boltzmann measure.\n\nC. The deterministic Berendsen thermostat has zero phase-space compressibility whenever $K(p) = \\frac{f}{2} k_{\\mathrm{B}} T_0$, so it is canonical at steady state; stochastic velocity rescaling reproduces the Maxwell distribution for momenta but not the Boltzmann distribution in $(q,p)$.\n\nD. The deterministic Berendsen thermostat produces a stationary measure that is a delta distribution in kinetic energy at $K(p) = \\frac{f}{2} k_{\\mathrm{B}} T_0$ and uniform elsewhere in phase space; stochastic velocity rescaling produces a microcanonical invariant measure concentrated at fixed total energy.",
            "solution": "The problem asks for an analysis of the phase-space compressibility and invariant measures for two thermostatting methods: the deterministic Berendsen thermostat and stochastic velocity rescaling.\n\nOur analysis will be conducted in two parts. First, we will analyze the deterministic Berendsen thermostat by deriving its phase-space compressibility and testing whether it preserves the canonical Boltzmann distribution. Second, we will analyze the properties of stochastic velocity rescaling based on the information provided.\n\n### Analysis of the Deterministic Berendsen Thermostat\n\nThe dynamics are given by the equations:\n$$ \\dot{q}_i = \\frac{p_i}{m_i} $$\n$$ \\dot{p}_i = F_i(q) - \\alpha(p)\\, p_i $$\nwhere the phase-space point is $X = (q, p) = (q_1, \\dots, q_{3N}, p_1, \\dots, p_{3N})$. The phase-space flow is $\\dot{X} = (\\dot{q}, \\dot{p})$.\n\n**1. Phase-Space Compressibility**\n\nThe phase-space compressibility, $\\kappa(X)$, is the divergence of the phase-space flow vector $\\dot{X}$:\n$$ \\kappa(X) = \\nabla_X \\cdot \\dot{X} = \\sum_{i=1}^{3N} \\frac{\\partial \\dot{q}_i}{\\partial q_i} + \\sum_{i=1}^{3N} \\frac{\\partial \\dot{p}_i}{\\partial p_i} $$\n\nFirst, we calculate the divergence in the coordinate space part:\n$$ \\nabla_q \\cdot \\dot{q} = \\sum_{i=1}^{3N} \\frac{\\partial}{\\partial q_i} \\left(\\frac{p_i}{m_i}\\right) = 0 $$\nsince $\\dot{q}_i$ does not depend on $q_j$ for any $i,j$.\n\nNext, we calculate the divergence in the momentum space part:\n$$ \\nabla_p \\cdot \\dot{p} = \\sum_{i=1}^{3N} \\frac{\\partial \\dot{p}_i}{\\partial p_i} = \\sum_{i=1}^{3N} \\frac{\\partial}{\\partial p_i} \\left( F_i(q) - \\alpha(p)\\, p_i \\right) $$\nSince $F_i(q) = -\\frac{\\partial U}{\\partial q_i}$ depends only on the coordinates $q$, its partial derivatives with respect to momenta $p_j$ are zero. Using the product rule for differentiation:\n$$ \\nabla_p \\cdot \\dot{p} = - \\sum_{i=1}^{3N} \\frac{\\partial}{\\partial p_i} (\\alpha(p) p_i) = - \\sum_{i=1}^{3N} \\left( p_i \\frac{\\partial \\alpha(p)}{\\partial p_i} + \\alpha(p) \\frac{\\partial p_i}{\\partial p_i} \\right) $$\n$$ \\nabla_p \\cdot \\dot{p} = - \\sum_{i=1}^{3N} \\left( p_i \\frac{\\partial \\alpha(p)}{\\partial p_i} + \\alpha(p) \\right) = -3N \\alpha(p) - \\sum_{i=1}^{3N} p_i \\frac{\\partial \\alpha(p)}{\\partial p_i} $$\n\nTo evaluate the sum, we need the partial derivatives of $\\alpha(p)$. The function $\\alpha(p)$ is given as:\n$$ \\alpha(p) = \\frac{1}{\\tau}\\left(1 - \\frac{T_0 f k_{\\mathrm{B}}}{2 K(p)}\\right) $$\nwhere $K(p) = \\sum_{j=1}^{3N} \\frac{p_j^2}{2 m_j}$. The partial derivative of $K(p)$ with respect to $p_i$ is $\\frac{\\partial K(p)}{\\partial p_i} = \\frac{p_i}{m_i}$.\nNow, we differentiate $\\alpha(p)$ with respect to $p_i$:\n$$ \\frac{\\partial \\alpha(p)}{\\partial p_i} = \\frac{\\partial}{\\partial p_i} \\left[ \\frac{1}{\\tau} \\left(1 - \\frac{T_0 f k_{\\mathrm{B}}}{2} K(p)^{-1}\\right) \\right] = \\frac{1}{\\tau} \\left( \\frac{T_0 f k_{\\mathrm{B}}}{2} K(p)^{-2} \\frac{\\partial K(p)}{\\partial p_i} \\right) = \\frac{T_0 f k_{\\mathrm{B}}}{2 \\tau K(p)^2} \\frac{p_i}{m_i} $$\nSubstituting this into the sum:\n$$ \\sum_{i=1}^{3N} p_i \\frac{\\partial \\alpha(p)}{\\partial p_i} = \\sum_{i=1}^{3N} p_i \\left( \\frac{T_0 f k_{\\mathrm{B}}}{2 \\tau K(p)^2} \\frac{p_i}{m_i} \\right) = \\frac{T_0 f k_{\\mathrm{B}}}{2 \\tau K(p)^2} \\sum_{i=1}^{3N} \\frac{p_i^2}{m_i} $$\nRecognizing that $\\sum_{i=1}^{3N} \\frac{p_i^2}{m_i} = 2 K(p)$, we get:\n$$ \\sum_{i=1}^{3N} p_i \\frac{\\partial \\alpha(p)}{\\partial p_i} = \\frac{T_0 f k_{\\mathrm{B}}}{2 \\tau K(p)^2} (2 K(p)) = \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} $$\nTherefore, the divergence in momentum space is:\n$$ \\nabla_p \\cdot \\dot{p} = -3N \\alpha(p) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} $$\nThe total phase-space compressibility is $\\kappa(X) = \\nabla_q \\cdot \\dot{q} + \\nabla_p \\cdot \\dot{p} = -3N \\alpha(p) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)}$.\n\nThe problem states that $f$ is the number of degrees of freedom, which is \"typically $f = 3N$ minus any holonomic constraints\". For a system of $N$ free particles in $3$ dimensions, described by $3N$ Cartesian coordinates, we have $f=3N$. Under this typical condition, the expression for compressibility becomes:\n$$ \\kappa(X) = -f \\alpha(p) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} $$\nSince $\\kappa(X)$ is not identically zero, the dynamics are compressible, and phase-space volume is not conserved. This violates Liouville's theorem, which is expected as the dynamics are non-Hamiltonian.\n\n**2. Invariant Measure**\n\nAn invariant measure $\\rho(X)$ must satisfy the stationary continuity equation: $\\nabla_X \\cdot (\\rho(X) \\dot{X}) = 0$. This expands to:\n$$ \\dot{X} \\cdot \\nabla_X \\rho + \\rho (\\nabla_X \\cdot \\dot{X}) = 0 \\implies \\dot{X} \\cdot \\nabla_X \\rho + \\rho \\kappa(X) = 0 $$\nWe test if the canonical Boltzmann distribution $\\rho_\\beta(q,p) = C \\exp(-\\beta H(q,p))$, with $\\beta = 1/(k_{\\mathrm{B}} T_0)$ and $H(q,p) = K(p) + U(q)$, is an invariant measure.\nFirst, we compute the gradient of $\\rho_\\beta$:\n$$ \\nabla_q \\rho_\\beta = -\\beta \\rho_\\beta \\nabla_q U = \\beta \\rho_\\beta F(q) $$\n$$ \\nabla_p \\rho_\\beta = -\\beta \\rho_\\beta \\nabla_p K = -\\beta \\rho_\\beta \\left(\\frac{p}{m}\\right) = -\\beta \\rho_\\beta \\dot{q} $$\nNext, we compute the term $\\dot{X} \\cdot \\nabla_X \\rho_\\beta$:\n$$ \\dot{X} \\cdot \\nabla_X \\rho_\\beta = \\dot{q} \\cdot (\\nabla_q \\rho_\\beta) + \\dot{p} \\cdot (\\nabla_p \\rho_\\beta) = \\dot{q} \\cdot (\\beta \\rho_\\beta F) + (F - \\alpha(p)p) \\cdot (-\\beta \\rho_\\beta \\dot{q}) $$\n$$ = \\beta \\rho_\\beta (\\dot{q} \\cdot F - F \\cdot \\dot{q} + \\alpha(p) p \\cdot \\dot{q}) = \\beta \\rho_\\beta \\alpha(p) \\sum_{i=1}^{3N} p_i \\frac{p_i}{m_i} = 2 \\beta \\rho_\\beta \\alpha(p) K(p) $$\nThe continuity equation becomes:\n$$ 2 \\beta \\rho_\\beta \\alpha(p) K(p) + \\rho_\\beta \\kappa(X) = 0 $$\nThis requires $2 \\beta K(p) \\alpha(p) + \\kappa(X) = 0$ for all $(q,p)$. Substituting $\\beta = 1/(k_{\\mathrm{B}} T_0)$:\n$$ \\frac{2 K(p)}{k_{\\mathrm{B}} T_0} \\alpha(p) + \\kappa(X) = 0 $$\nUsing our expression for $\\kappa(X)$, assuming $f=3N$:\n$$ \\frac{2 K(p)}{k_{\\mathrm{B}} T_0} \\alpha(p) - f \\alpha(p) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} = 0 $$\nThe instantaneous temperature is $T(p) = \\frac{2 K(p)}{f k_{\\mathrm{B}}}$, so $\\frac{2 K(p)}{k_{\\mathrm{B}}} = f T(p)$. The condition becomes:\n$$ \\frac{f T(p)}{T_0} \\alpha(p) - f \\alpha(p) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} = 0 $$\n$$ f \\alpha(p) \\left(\\frac{T(p)}{T_0} - 1\\right) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} = 0 $$\nSubstituting $\\alpha(p) = \\frac{1}{\\tau} \\left(1 - \\frac{T_0}{T(p)}\\right) = \\frac{T(p) - T_0}{\\tau T(p)}$:\n$$ \\frac{f}{\\tau} \\frac{T(p)-T_0}{T(p)} \\frac{T(p)-T_0}{T_0} - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau K(p)} = 0 $$\nUsing $K(p) = \\frac{f k_{\\mathrm{B}} T(p)}{2}$:\n$$ \\frac{f (T(p)-T_0)^2}{\\tau T(p) T_0} - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau (f k_{\\mathrm{B}} T(p)/2)} = 0 \\implies \\frac{f (T(p)-T_0)^2}{\\tau T(p) T_0} - \\frac{2 T_0}{\\tau T(p)} = 0 $$\n$$ f (T(p)-T_0)^2 = 2 T_0^2 $$\nThis equation is not satisfied for arbitrary phase-space points (i.e., for any value of $K(p)$ or $T(p)$), but only for specific values of kinetic energy. Therefore, the canonical Boltzmann density is not an invariant measure for the deterministic Berendsen thermostat.\n\n### Analysis of Stochastic Velocity Rescaling (SVR)\nThe problem statement provides the crucial property of SVR: \"... drift and diffusion carefully balanced to leave the canonical Boltzmann distribution invariant.\" It further states that SVR is designed so that \"the marginal distribution of kinetic energy is the $\\chi^2$ distribution with $f$ degrees of freedom at temperature $T_0$.\" This is precisely the distribution of kinetic energy in the canonical ensemble. The description that this defines a Markov process on $p$ that leaves the canonical Boltzmann distribution invariant means that for the combined dynamics on $(q,p)$, the stationary probability density is indeed the canonical distribution, $\\rho(q,p) \\propto \\exp(-\\beta H(q,p))$.\n\n### Evaluation of the Options\n\n*   **A. For the deterministic Berendsen thermostat, the phase-space compressibility is $\\kappa(q,p) = - f\\, \\alpha(p) - \\dfrac{T_0 f k_{\\mathrm{B}}}{\\tau\\, K(p)}$, and the canonical Boltzmann density $\\rho_\\beta(q,p) \\propto \\exp\\!\\left(-\\beta H(q,p)\\right)$ with $\\beta = 1/(k_{\\mathrm{B}} T_0)$ is not invariant; in contrast, stochastic velocity rescaling admits the canonical Boltzmann distribution on full phase space as an invariant measure.**\n    - Our derivation of the compressibility for an unconstrained system ($f=3N$) matches the expression given.\n    - Our analysis confirms that the canonical distribution is not invariant under Berendsen dynamics.\n    - The problem's description of SVR states that it admits the canonical distribution as an invariant measure.\n    - This statement is fully consistent with our analysis. **Correct**.\n\n*   **B. Both the deterministic Berendsen thermostat and stochastic velocity rescaling are incompressible in phase space, hence both preserve the canonical Boltzmann measure.**\n    - The Berendsen thermostat is compressible ($\\kappa \\neq 0$). The premise is false.\n    - Incompressibility does not automatically imply preservation of the canonical measure for non-Hamiltonian dynamics.\n    - This statement is incorrect. **Incorrect**.\n\n*   **C. The deterministic Berendsen thermostat has zero phase-space compressibility whenever $K(p) = \\frac{f}{2} k_{\\mathrm{B}} T_0$, so it is canonical at steady state; stochastic velocity rescaling reproduces the Maxwell distribution for momenta but not the Boltzmann distribution in $(q,p)$.**\n    - When $K(p) = \\frac{f}{2} k_{\\mathrm{B}} T_0$, we have $T(p) = T_0$ and $\\alpha(p) = 0$. Our expression for compressibility gives $\\kappa(X) = -f(0) - \\frac{T_0 f k_{\\mathrm{B}}}{\\tau (f k_{\\mathrm{B}} T_0 / 2)} = -2/\\tau \\neq 0$. The compressibility is not zero.\n    - SVR is constructed to generate the full canonical ensemble in phase space $(q,p)$, not just the momentum part.\n    - This statement is incorrect. **Incorrect**.\n\n*   **D. The deterministic Berendsen thermostat produces a stationary measure that is a delta distribution in kinetic energy at $K(p) = \\frac{f}{2} k_{\\mathrm{B}} T_0$ and uniform elsewhere in phase space; stochastic velocity rescaling produces a microcanonical invariant measure concentrated at fixed total energy.**\n    - The Berendsen thermostat results in a kinetic energy distribution that is peaked around the target value but is not a delta function. The configurational distribution is also not uniform but is influenced by the potential $U(q)$.\n    - SVR generates the canonical (NVT) ensemble, which has fluctuating total energy, not the microcanonical (NVE) ensemble, which has fixed total energy.\n    - This statement is incorrect. **Incorrect**.\n\nBased on the derivations and analysis, only statement A is accurate.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Having established the formal requirements for canonical sampling, we now turn to a modern, provably correct method for simulating systems at constant temperature. This practice involves implementing the BAOAB splitting integrator for Langevin dynamics, a powerful stochastic approach that rigorously models the effects of a thermal bath. Through a sophisticated analysis of the integrator's weak order and its ability to preserve the exact configurational distribution, you will explore the cutting edge of algorithm design for statistical mechanics .",
            "id": "3401323",
            "problem": "Implement a numerical integrator based on classical mechanics for molecular dynamics that advances the one-dimensional Langevin dynamics of a particle in a harmonic potential using the BAOAB splitting. Then, quantify its weak order of accuracy for the mean of the position and its configurational sampling accuracy at finite timestep by analyzing the invariant configurational variance. Use nondimensional reduced units with Boltzmann constant equal to one, that is, set $k_{\\mathrm{B}}=1$ and treat all quantities as dimensionless. No physical unit conversion is required.\n\nThe dynamics is governed by the Langevin equations for position $x(t)$ and velocity $v(t)$ for a particle of mass $m$ in the harmonic potential $U(x)=\\tfrac{1}{2} k x^2$ with friction coefficient $\\gamma$ and temperature $T$:\n$$\nm \\,\\mathrm{d} v(t)= -\\nabla U\\bigl(x(t)\\bigr)\\,\\mathrm{d} t - \\gamma m\\, v(t)\\,\\mathrm{d} t + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T}\\,\\mathrm{d} W_t,\\qquad \\mathrm{d} x(t)= v(t)\\,\\mathrm{d} t,\n$$\nwhere $W_t$ is a standard Wiener process. In reduced units, take $k_{\\mathrm{B}}=1$ and treat $m$, $k$, $\\gamma$, $T$, and the timestep $h$ as dimensionless.\n\nThe BAOAB splitting over a single timestep $h$ consists of the sequence of substeps: a half-step momentum update by the conservative force (denoted $B$), a half-step drift of positions (denoted $A$), a full-step stochastic Ornstein–Uhlenbeck (OU) thermostat for velocities (denoted $O$), followed by another half-step $A$ and a final half-step $B$. Concretely, for the harmonic force $F(x)=-\\partial_x U(x)=-k x$, in one timestep $h$ the substeps are applied in the order $B\\to A\\to O\\to A\\to B$. You must implement this BAOAB propagator.\n\nYour tasks:\n\n$1.$ Weak order assessment for the mean position. For fixed $m$, $k$, $\\gamma$, $T$, and initial condition $(x_0,v_0)$, consider the mean position $\\mathbb{E}[x(t_f)]$ at a final time $t_f$ under BAOAB. The expectation of the stochastic OU noise is zero, so the evolution of the mean under BAOAB is obtained by replacing the stochastic OU substep by its noise-free mean map. Define the numerical weak error for a timestep $h$ as\n$$\ne(h) = \\bigl|\\mathbb{E}[x_{h}(t_f)] - x_{\\mathrm{exact}}(t_f)\\bigr|,\n$$\nwhere $\\mathbb{E}[x_{h}(t_f)]$ is the mean propagated by the BAOAB mean map over $t_f$ using steps of size $h$, and $x_{\\mathrm{exact}}(t_f)$ is the exact mean position from the continuous Langevin dynamics. Since $\\mathbb{E}[W_t]=0$, the exact mean solves the deterministic damped harmonic oscillator equation\n$$\nm \\ddot{x}(t) + \\gamma m \\dot{x}(t) + k x(t) = 0,\n$$\nwith the given initial condition $(x_0,v_0)$. Compute the error ratio\n$$\nR = \\frac{e(h)}{e(h/2)}\n$$\nfor two pairs of timesteps as specified in the test suite. A second-order weak method should produce $R\\approx 4$.\n\n$2.$ Configurational sampling accuracy at finite timestep. The BAOAB integrator defines a linear Markov chain for $(x_n,v_n)$ with an affine Gaussian noise injection originating from the OU substep. For the harmonic potential, the invariant distribution of the continuous dynamics has configurational variance $\\mathrm{Var}(x)=T/k$. The BAOAB chain has an invariant covariance matrix $\\Sigma$ that solves the discrete Lyapunov equation\n$$\n\\Sigma = M \\Sigma M^\\top + Q,\n$$\nwhere $M$ is the $2\\times 2$ deterministic mean map of one full BAOAB step for $(x,v)$ and $Q$ is the $2\\times 2$ covariance contribution from one step’s OU noise transported through the surrounding $A$ and $B$ substeps. Compute $\\Sigma$ by solving this discrete Lyapunov equation exactly in double precision using linear algebra (do not use Monte Carlo sampling for this part), and report the absolute configurational variance error\n$$\n\\varepsilon_{\\mathrm{conf}} = \\bigl|\\Sigma_{11} - T/k\\bigr|,\n$$\nfor the specified parameter sets.\n\nImplementation notes and constraints:\n\n- Use only the fundamental statement of the Langevin dynamics and the BAOAB splitting description. Do not use any pre-derived shortcut formulas in the problem statement. Any necessary formulas should be derived from first principles in your solution.\n- For the weak error, ensure that $t_f$ is an integer multiple of $h$ so that a whole number of steps is taken. Propagate the mean using the BAOAB mean map without sampling noise.\n- For the invariant covariance, construct the one-step affine Gaussian map and solve the discrete Lyapunov equation for $\\Sigma$ via vectorization using the Kronecker product approach, i.e., solve\n$$\n\\mathrm{vec}(\\Sigma) = \\bigl(I - M \\otimes M \\bigr)^{-1} \\mathrm{vec}(Q).\n$$\n\nTest suite and required outputs:\n\nYour program must compute the following eight quantities for the four test cases below and print them as a single line containing a comma-separated list enclosed in square brackets, in the order specified. The list elements are:\n\n$1.$ For Test A (underdamped weak-order check): the weak error ratio $R_A$ as a floating-point number, followed by a boolean indicating whether $R_A \\in [3.5, 4.5]$.\n\n$2.$ For Test B (configurational variance at finite timestep, moderate damping): the absolute variance error $\\varepsilon_{\\mathrm{conf},B}$ as a floating-point number, followed by a boolean indicating whether $\\varepsilon_{\\mathrm{conf},B} \\le 10^{-12}$.\n\n$3.$ For Test C (critical damping weak-order check): the weak error ratio $R_C$ as a floating-point number, followed by a boolean indicating whether $R_C \\in [3.5, 4.5]$.\n\n$4.$ For Test D (configurational variance at finite timestep, overdamped): the absolute variance error $\\varepsilon_{\\mathrm{conf},D}$ as a floating-point number, followed by a boolean indicating whether $\\varepsilon_{\\mathrm{conf},D} \\le 10^{-12}$.\n\nUse the following test parameters:\n\n- Test A (underdamped weak-order check): $m=1$, $k=1$, $\\gamma=0.5$, $T=1$, $(x_0,v_0)=(1,0)$, $t_f=10$, $h=0.08$ and $h/2=0.04$.\n\n- Test B (configurational variance at finite timestep): $m=1$, $k=3$, $\\gamma=0.5$, $T=2$, $h=0.4$.\n\n- Test C (critical damping weak-order check): $m=1$, $k=1$, $\\gamma=2$, $T=1$, $(x_0,v_0)=(1,1)$, $t_f=3$, $h=0.05$ and $h/2=0.025$.\n\n- Test D (overdamped configurational variance): $m=1$, $k=1$, $\\gamma=5$, $T=1$, $h=0.1$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in this exact order:\n$$\n\\bigl[ R_A,\\ \\text{bool}(R_A\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},B},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},B}\\le 10^{-12}),\\ R_C,\\ \\text{bool}(R_C\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},D},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},D}\\le 10^{-12}) \\bigr].\n$$",
            "solution": "The problem is valid as it is scientifically grounded in classical and statistical mechanics, well-posed with all necessary parameters and clear objectives, and objective in its formulation. We will proceed with a full solution.\n\nThe problem requires the implementation and analysis of the BAOAB splitting integrator for one-dimensional Langevin dynamics in a harmonic potential. We are tasked with two distinct analyses: assessing the weak order of accuracy for the mean position and quantifying the finite-timestep error in the invariant configurational variance. All calculations are performed in nondimensional reduced units with the Boltzmann constant $k_{\\mathrm{B}}=1$.\n\nLet the state of the particle be represented by the vector $z(t) = (x(t), v(t))^\\top$. The dynamics are governed by the Langevin equation for a particle of mass $m$ in a harmonic potential $U(x) = \\frac{1}{2} k x^2$:\n$$\n\\begin{cases}\n\\mathrm{d}x(t) &= v(t)\\,\\mathrm{d}t \\\\\nm\\,\\mathrm{d}v(t) &= -k x(t)\\,\\mathrm{d}t - \\gamma m\\, v(t)\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t\n\\end{cases}\n$$\nThe force is $F(x) = -\\nabla U(x) = -k x$. The BAOAB integrator splits the dynamics into three parts, which are solved in sequence over a timestep $h$:\n- **B**: Update velocity under the conservative force: $m\\,\\mathrm{d}v = F(x)\\,\\mathrm{d}t$.\n- **A**: Update position: $\\mathrm{d}x = v\\,\\mathrm{d}t$.\n- **O**: Update velocity under the Ornstein-Uhlenbeck (OU) process: $m\\,\\mathrm{d}v = -\\gamma m v\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t$.\n\nThe BAOAB scheme applies these steps in the symmetric sequence B(h/2), A(h/2), O(h), A(h/2), B(h/2). Since the force is linear and the OU process is linear, each substep can be represented by a matrix operator. Let $z_n = (x_n, v_n)^\\top$ be the state at time $t_n$.\n\n**1. Derivation of Substep Propagators**\n\n**Substep B (Force):** Integration of $\\dot{v} = F(x)/m = - (k/m) x$ for a duration $\\delta t = h/2$, treating $x$ as constant (Verlet scheme):\n$v_{n+1} = v_n - (k/m) x_n \\delta t$. The position $x_n$ is unchanged.\nThe operator $M_B$ is:\n$$\nz \\mapsto M_B z, \\quad M_B = \\begin{pmatrix} 1 & 0 \\\\ - \\frac{k h}{2m} & 1 \\end{pmatrix}\n$$\n\n**Substep A (Drift):** Integration of $\\dot{x} = v$ for a duration $\\delta t = h/2$, treating $v$ as constant:\n$x_{n+1} = x_n + v_n \\delta t$. The velocity $v_n$ is unchanged.\nThe operator $M_A$ is:\n$$\nz \\mapsto M_A z, \\quad M_A = \\begin{pmatrix} 1 & \\frac{h}{2} \\\\ 0 & 1 \\end{pmatrix}\n$$\n\n**Substep O (Thermostat):** The OU process $\\mathrm{d}v = -\\gamma v\\,\\mathrm{d}t + \\sqrt{2 \\gamma T/m}\\,\\mathrm{d}W_t$ is solved exactly over a duration $h$. The position $x$ is unchanged.\n$v_{n+1} = v_n e^{-\\gamma h} + \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})} R_n$, where $R_n \\sim \\mathcal{N}(0,1)$ is a standard normal random variable.\nThis is an affine transformation:\n$$\nz \\mapsto M_O z + \\xi_O, \\quad M_O = \\begin{pmatrix} 1 & 0 \\\\ 0 & e^{-\\gamma h} \\end{pmatrix}, \\quad \\xi_O = \\begin{pmatrix} 0 \\\\ \\sigma_v R_n \\end{pmatrix}\n$$\nwhere $\\sigma_v = \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})}$.\n\n**Full BAOAB Step:** The state $z_{n+1}$ is obtained by composing these operations:\n$z_{n+1} = M_B(M_A(M_O(M_A(M_B z_n)) + \\xi_O))$.\nExpanding gives the affine map for one full step:\n$$\nz_{n+1} = (M_B M_A M_O M_A M_B) z_n + (M_B M_A) \\xi_O = M z_n + \\xi\n$$\nwhere $M = M_B M_A M_O M_A M_B$ is the deterministic mean map, and $\\xi = M_B M_A \\xi_O$ is the effective noise vector for the full step.\n\n**Task 1: Weak Order Assessment**\n\nThe mean of the state, $\\bar{z}_n = \\mathbb{E}[z_n]$, evolves according to $\\bar{z}_{n+1} = M \\bar{z}_n$, since $\\mathbb{E}[\\xi_O]=0$. Starting from $z_0 = (x_0, v_0)^\\top$, the mean state after $N = t_f/h$ steps is $\\bar{z}_N = M^N z_0$. The numerical mean position is $\\mathbb{E}[x_h(t_f)] = (\\bar{z}_N)_1$.\n\nThe exact mean dynamics follows the deterministic equation $m \\ddot{x} + \\gamma m \\dot{x} + k x = 0$, or $\\ddot{x} + \\gamma \\dot{x} + \\omega_0^2 x = 0$ with $\\omega_0^2 = k/m$. The characteristic equation is $r^2 + \\gamma r + \\omega_0^2 = 0$. The solution depends on the discriminant $\\Delta = \\gamma^2 - 4\\omega_0^2$.\n- **Underdamped ($\\Delta < 0$):** Test A ($m=1, k=1, \\gamma=0.5 \\implies \\Delta = -3.75$).\n  The solution is $x(t) = e^{-\\gamma t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$, with $\\omega_d = \\sqrt{\\omega_0^2 - (\\gamma/2)^2}$.\n  Given $(x_0, v_0)$, we find $C_1 = x_0$ and $C_2 = (v_0 + \\gamma x_0/2)/\\omega_d$.\n- **Critically Damped ($\\Delta = 0$):** Test C ($m=1, k=1, \\gamma=2 \\implies \\Delta = 0$).\n  The solution is $x(t) = (C_1 + C_2 t) e^{-\\gamma t/2}$.\n  Given $(x_0, v_0)$, we find $C_1 = x_0$ and $C_2 = v_0 + \\gamma x_0/2$.\n\nThe weak error is $e(h) = |\\mathbb{E}[x_h(t_f)] - x_{\\mathrm{exact}}(t_f)|$. A method with weak order $p$ has $e(h) \\propto h^p$. Thus, the ratio $R = e(h)/e(h/2)$ should be approximately $2^p$. For BAOAB, which is second-order weak, we expect $R \\approx 4$.\n\n**Task 2: Configurational Sampling Accuracy**\n\nThe BAOAB integrator generates a linear Markov chain whose invariant distribution is Gaussian with a certain covariance matrix $\\Sigma = \\mathbb{E}[(z-\\bar{z})(z-\\bar{z})^\\top]$. This matrix is the stationary solution to the discrete Lyapunov equation:\n$$\n\\Sigma = M \\Sigma M^\\top + Q\n$$\nHere, $Q = \\mathbb{E}[\\xi \\xi^\\top]$ is the covariance matrix of the effective noise vector $\\xi = M_B M_A \\xi_O$.\nLet $C = M_B M_A$. The noise is $\\xi = C \\xi_O$.\nThe covariance of the OU noise is $Q_O = \\mathbb{E}[\\xi_O \\xi_O^\\top] = \\mathrm{diag}(0, \\sigma_v^2)$.\nThus, $Q = C Q_O C^\\top$.\nThis Lyapunov equation can be solved for $\\Sigma$ using vectorization. Let $\\sigma = \\mathrm{vec}(\\Sigma)$ and $q = \\mathrm{vec}(Q)$, where $\\mathrm{vec}(\\cdot)$ flattens a matrix into a vector column by column. The equation becomes:\n$$\n\\sigma = (M \\otimes M)\\sigma + q\n$$\nwhere $\\otimes$ is the Kronecker product. This is a standard linear system for $\\sigma$:\n$$\n(I - M \\otimes M)\\sigma = q \\implies \\sigma = (I - M \\otimes M)^{-1}q\n$$\nAfter solving for the vector $\\sigma$, it is reshaped back into the $2 \\times 2$ matrix $\\Sigma$. The configurational variance from the simulation is $\\Sigma_{11}$.\n\nFor the continuous dynamics, the invariant distribution is the Gibbs-Boltzmann distribution, whose configurational part is a Gaussian with variance $\\mathrm{Var}(x) = k_B T/k = T/k$. The BAOAB scheme is known to preserve this configurational marginal exactly for linear forces. The absolute configurational variance error, $\\varepsilon_{\\mathrm{conf}} = |\\Sigma_{11} - T/k|$, should therefore be close to machine precision, reflecting only floating-point arithmetic errors.\n\nThe following Python code implements these calculations for the specified test cases. It first defines functions to compute the BAOAB propagator matrices, the exact mean position for the damped harmonic oscillator, the numerical mean position via the propagator, and the invariant covariance matrix by solving the Lyapunov equation. These functions are then applied to the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_baoab_matrices(m, k, gamma, h):\n    \"\"\"\n    Constructs the matrix operators for the BAOAB substeps.\n    \n    Returns:\n        M_A (np.ndarray): Matrix for the A (position drift) substep.\n        M_B (np.ndarray): Matrix for the B (force) substep.\n        M_O (np.ndarray): Matrix for the O (thermostat) substep's mean map.\n    \"\"\"\n    # B step matrix for a timestep of h/2\n    M_B = np.array([[1, 0], [-k * h / (2 * m), 1]])\n    \n    # A step matrix for a timestep of h/2\n    M_A = np.array([[1, h / 2], [0, 1]])\n    \n    # O step matrix (mean map) for a timestep of h\n    M_O = np.array([[1, 0], [0, np.exp(-gamma * h)]])\n    \n    return M_A, M_B, M_O\n\ndef get_exact_mean_pos(m, k, gamma, x0, v0, tf):\n    \"\"\"\n    Computes the exact mean position for the damped harmonic oscillator.\n    \"\"\"\n    omega0_sq = k / m\n    delta = gamma**2 - 4 * omega0_sq\n\n    if np.abs(delta)  1e-15:  # Critically damped case\n        alpha = gamma / 2\n        c1 = x0\n        c2 = v0 + alpha * x0\n        x_exact = (c1 + c2 * tf) * np.exp(-alpha * tf)\n    elif delta  0:  # Underdamped case\n        alpha = gamma / 2\n        omega_d = np.sqrt(omega0_sq - alpha**2)\n        c1 = x0\n        c2 = (v0 + alpha * x0) / omega_d\n        x_exact = np.exp(-alpha * tf) * (c1 * np.cos(omega_d * tf) + c2 * np.sin(omega_d * tf))\n    else:  # Overdamped case\n        # Not needed for the specific test cases in this problem, but included for completeness.\n        sqrt_delta = np.sqrt(delta)\n        r1 = (-gamma + sqrt_delta) / 2\n        r2 = (-gamma - sqrt_delta) / 2\n        c2 = (v0 - r1 * x0) / (r2 - r1)\n        c1 = x0 - c2\n        x_exact = c1 * np.exp(r1 * tf) + c2 * np.exp(r2 * tf)\n        \n    return x_exact\n\ndef get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h):\n    \"\"\"\n    Computes the numerical mean position by propagating the mean map.\n    \"\"\"\n    if not np.isclose(tf % h, 0, atol=1e-9) and not np.isclose(tf % h, h, atol=1e-9):\n        raise ValueError(\"tf must be an integer multiple of h.\")\n    num_steps = int(round(tf / h))\n    \n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    \n    # Full BAOAB deterministic mean map M\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # Propagate for N steps\n    M_N = np.linalg.matrix_power(M, num_steps)\n    z0 = np.array([x0, v0])\n    zf = M_N @ z0\n    \n    return zf[0]\n\ndef calculate_weak_error_ratio(params):\n    \"\"\"\n    Calculates the weak error ratio R = e(h)/e(h/2).\n    \"\"\"\n    m, k, gamma, _, x0, v0, tf, h = params.values()\n    \n    x_exact = get_exact_mean_pos(m, k, gamma, x0, v0, tf)\n    \n    # Error for timestep h\n    x_num_h = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h)\n    e_h = np.abs(x_num_h - x_exact)\n    \n    # Error for timestep h/2\n    x_num_h2 = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h / 2)\n    e_h2 = np.abs(x_num_h2 - x_exact)\n    \n    if e_h2 == 0:\n        return np.inf if e_h != 0 else 1.0\n\n    return e_h / e_h2\n\ndef calculate_configurational_variance_error(params):\n    \"\"\"\n    Calculates the configurational variance error at finite timestep.\n    \"\"\"\n    m, k, gamma, T, h = params.values()\n    \n    # 1. Get the BAOAB mean map M\n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # 2. Get the noise covariance matrix Q\n    sigma_v_sq = (T / m) * (1 - np.exp(-2 * gamma * h))\n    Q_O = np.array([[0, 0], [0, sigma_v_sq]])\n    C = M_B @ M_A\n    Q = C @ Q_O @ C.T\n    \n    # 3. Solve the discrete Lyapunov equation using Kronecker product\n    dim = M.shape[0]\n    Id_kronsq = np.eye(dim**2)\n    M_kron_M = np.kron(M, M)\n    A_lyap = Id_kronsq - M_kron_M\n    \n    q_vec = Q.flatten('F') # Use Fortran order for vec operator\n    \n    sigma_vec = np.linalg.solve(A_lyap, q_vec)\n    \n    Sigma = sigma_vec.reshape((dim, dim), order='F')\n\n    # 4. Compute the error\n    Sigma_11 = Sigma[0, 0]\n    var_exact = T / k\n    error = np.abs(Sigma_11 - var_exact)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = {\n        'A': {'m': 1, 'k': 1, 'gamma': 0.5, 'T': 1, 'x0': 1, 'v0': 0, 'tf': 10, 'h': 0.08},\n        'B': {'m': 1, 'k': 3, 'gamma': 0.5, 'T': 2, 'h': 0.4},\n        'C': {'m': 1, 'k': 1, 'gamma': 2, 'T': 1, 'x0': 1, 'v0': 1, 'tf': 3, 'h': 0.05},\n        'D': {'m': 1, 'k': 1, 'gamma': 5, 'T': 1, 'h': 0.1},\n    }\n\n    results = []\n\n    # Test A: Weak order (underdamped)\n    params_A = test_cases['A']\n    R_A = calculate_weak_error_ratio(params_A)\n    results.append(R_A)\n    results.append(3.5 = R_A = 4.5)\n\n    # Test B: Configurational variance (moderate damping)\n    params_B = test_cases['B']\n    eps_conf_B = calculate_configurational_variance_error(params_B)\n    results.append(eps_conf_B)\n    results.append(eps_conf_B = 1e-12)\n\n    # Test C: Weak order (critical damping)\n    params_C = test_cases['C']\n    R_C = calculate_weak_error_ratio(params_C)\n    results.append(R_C)\n    results.append(3.5 = R_C = 4.5)\n\n    # Test D: Configurational variance (overdamped)\n    params_D = test_cases['D']\n    eps_conf_D = calculate_configurational_variance_error(params_D)\n    results.append(eps_conf_D)\n    results.append(eps_conf_D = 1e-12)\n    \n    # Format a boolean as a lowercase string \"true\" or \"false\" for printing\n    def format_bool(b):\n        return 'true' if b else 'false'\n\n    # Prepare string representations for each result item\n    str_results = []\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            str_results.append(format_bool(item))\n        else:\n            str_results.append(str(item))\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}