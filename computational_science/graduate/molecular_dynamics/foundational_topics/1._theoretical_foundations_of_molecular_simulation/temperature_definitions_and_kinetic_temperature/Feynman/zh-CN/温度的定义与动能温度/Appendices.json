{
    "hands_on_practices": [
        {
            "introduction": "运动温度的定义看似简单，它通过均分定理将系统的总动能与温度联系起来：$\\langle K \\rangle = \\frac{f}{2} k_B T_{\\mathrm{kin}}$。然而，这个公式的准确应用关键在于正确确定系统的自由度数量 $f$。在分子动力学模拟中，系统往往受到各种约束，例如维持分子刚性结构的完整约束（holonomic constraints）或移除系统整体平动和转动的全局约束，这些都会减少对动能有贡献的有效自由度。这项练习  将引导你从第一性原理出发，推导出一个通用公式来精确计算在存在多种约束时系统的真实自由度，这是准确测量和控制模拟温度的理论基石。",
            "id": "3451703",
            "problem": "考虑一个三维原子尺度分子动力学模拟，该模拟针对一个由$N$个粒子组成的通用、非简并的气相团簇，其中粒子$i \\in \\{1,\\dots,N\\}$的质量为$m_i$，位置为$\\mathbf{r}_i$，速度为$\\mathbf{v}_i$。假设有$C$个独立的完整约束$\\phi_{\\alpha}(\\mathbf{r}) = 0$，其中$\\alpha \\in \\{1,\\dots,C\\}$，这些约束通过诸如SHAKE方法的完整约束算法来始终强制执行，因此运动被限制在约束流形上。动能为$K = \\frac{1}{2}\\sum_{i=1}^{N} m_i |\\mathbf{v}_i|^2$，动理学温度$T_{\\mathrm{kin}}$通过能量均分定理定义为$\\langle K \\rangle = \\frac{f}{2} k_B T_{\\mathrm{kin}}$，其中$k_B$是玻尔兹曼常数，$f$是对$K$有贡献的活化二次自由度的数量。\n\n除了完整约束外，积分器在每个时间步强制总线性动量为零，并可能强制关于瞬时质心的总角动量为零。具体来说，可能施加以下线性速度约束：\n- 总线性动量为零：$\\mathbf{P} \\equiv \\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0}$。\n- 总角动量为零：$\\mathbf{L} \\equiv \\sum_{i=1}^{N} \\mathbf{r}_i \\times (m_i \\mathbf{v}_i) = \\mathbf{0}$。\n\n假设团簇的惯性张量是满秩的，并且完整约束独立于全局平移和旋转，因此它们本身不固定质心或整体取向。\n\n从牛顿定律出发，通过拉格朗日乘子法施加完整约束，结合能量均分定理和约束速度空间上的基本线性代数，推导在所有约束下动态可及的速度子空间的维度。由此，确定进入$T_{\\mathrm{kin}}$定义的活化二次自由度的正确计数$f$。引入指示变量$\\chi_t$和$\\chi_r$来编码是否强制执行全局速度约束：如果施加了零总线性动量约束，则$\\chi_t = 1$，否则$\\chi_t = 0$；如果施加了零总角动量约束，则$\\chi_r = 1$，否则$\\chi_r = 0$。最后，识别$d_{\\mathrm{rigid}}$，即由这些全局约束移除的刚体自由度的总数，用$\\chi_t$和$\\chi_r$表示。\n\n将最终结果报告为一个二元行向量$(f, d_{\\mathrm{rigid}})$。无需进行数值计算。将答案表示为封闭形式的解析表达式。",
            "solution": "该问题要求确定活化二次自由度的数量$f$和移除的刚体自由度的数量$d_{\\mathrm{rigid}}$，该系统由$N$个粒子组成并受到各种约束。解答通过系统地计算可及速度空间的维度来推导。\n\n系统在任何给定时间的状态可以由三维空间中$N$个粒子的位置$\\mathbf{r}_i$和速度$\\mathbf{v}_i$来描述。速度分量的总数为$3N$，这对应于无约束速度空间的维度。活化二次自由度的数量$f$是在所有施加的约束下系统动态可及的速度子空间的维度。\n\n1.  **初始自由度**：对于一个由$3$维空间中$N$个自由粒子组成的系统，存在$3N$个平移自由度，每个自由度对应于粒子速度矢量$\\mathbf{v}_i$的一个分量。总动能是这$3N$个速度分量的二次函数。在没有任何约束的情况下，我们有$f = 3N$。\n\n2.  **完整约束**：系统受到$C$个独立完整约束的影响，其形式为$\\phi_{\\alpha}(\\mathbf{r}_1, \\dots, \\mathbf{r}_N) = 0$，其中$\\alpha \\in \\{1, \\dots, C\\}$。为了使这些约束在所有时间都得到维持，它们的时间导数必须为零。这对粒子速度施加了约束：\n    $$ \\frac{d\\phi_{\\alpha}}{dt} = \\sum_{i=1}^{N} \\frac{\\partial \\phi_{\\alpha}}{\\partial \\mathbf{r}_i} \\cdot \\frac{d\\mathbf{r}_i}{dt} = \\sum_{i=1}^{N} (\\nabla_{\\mathbf{r}_i} \\phi_{\\alpha}) \\cdot \\mathbf{v}_i = 0 $$\n    这$C$个方程中的每一个都代表了对$3N$个速度分量的一个线性约束。由于问题陈述这些约束是独立的，它们在$3N$维速度空间中定义了$C$个线性无关的超平面。这些超平面的交集将可及速度子空间的维度减少了$C$。\n    施加完整约束后的自由度数量：$3N - C$。\n\n3.  **全局平移约束**：总线性动量为零的约束，$\\mathbf{P} = \\mathbf{0}$，由下式给出：\n    $$ \\mathbf{P} = \\sum_{i=1}^{N} m_i \\mathbf{v}_i = \\mathbf{0} $$\n    这是一个向量方程，等价于对速度分量的三个独立的标量线性约束：\n    $$ \\sum_{i=1}^{N} m_i v_{i,x} = 0 $$\n    $$ \\sum_{i=1}^{N} m_i v_{i,y} = 0 $$\n    $$ \\sum_{i=1}^{N} m_i v_{i,z} = 0 $$\n    这些约束移除了对应于质心集体运动的3个自由度。指示变量$\\chi_t$决定是否应用这些约束。因此，它们将自由度的数量减少了$3\\chi_t$。\n\n4.  **全局旋转约束**：关于质心的总角动量为零的约束，$\\mathbf{L} = \\mathbf{0}$，由下式给出：\n    $$ \\mathbf{L} = \\sum_{i=1}^{N} (\\mathbf{r}_i - \\mathbf{R}_{\\mathrm{CM}}) \\times (m_i \\mathbf{v}_i) = \\mathbf{0} $$\n    其中$\\mathbf{R}_{\\mathrm{CM}}$是质心的位置。（注：如问题陈述中那样直接使用$\\mathbf{r}_i$是有效的，前提是原点被选为质心，这是在移除质心运动时的常见约定）。这个向量方程等价于对速度分量的三个独立的标量线性约束，移除了对应于整个团簇刚体旋转的3个自由度。指示变量$\\chi_r$决定是否应用这些约束。因此，它们将自由度的数量减少了$3\\chi_r$。\n\n5.  **约束的独立性**：问题指出，完整约束独立于全局平移和旋转。这是一个关键条件。这意味着$C$个内部约束（例如，固定键长）与整体动量或角动量上的约束不冲突，也不会预先决定它们。此外，对于一个通用的非简并团簇（即，并非所有粒子都共线），平移和旋转约束是相互独立的。因此，独立约束的总数是各类约束数量的总和。\n\n6.  **$f$的计算**：活化二次自由度的最终数量$f$是初始总数$3N$减去独立约束的总数。\n    $$ f = 3N - C - 3\\chi_t - 3\\chi_r $$\n    这就是动态可及速度子空间的维度，也正是这个数字被正确地用于动理学温度的能量均分公式：$\\langle K \\rangle = \\frac{f}{2} k_B T_{\\mathrm{kin}}$。\n\n7.  **$d_{\\mathrm{rigid}}$的计算**：问题将$d_{\\mathrm{rigid}}$定义为由关于线性和角动量的全局约束所移除的刚体自由度的总数。\n    - 如果$\\chi_t=1$，移除的平移自由度数量为$3$；如果$\\chi_t=0$，则为$0$。即$3\\chi_t$。\n    - 如果$\\chi_r=1$，移除的旋转自由度数量为$3$；如果$\\chi_r=0$，则为$0$。即$3\\chi_r$。\n    移除的刚体自由度总数是这两个量的和：\n    $$ d_{\\mathrm{rigid}} = 3\\chi_t + 3\\chi_r $$\n    这使我们能够将$f$更紧凑地写为$f = 3N - C - d_{\\mathrm{rigid}}$，这清晰地分开了来自内部约束（$C$）和刚体约束（$d_{\\mathrm{rigid}}$）的贡献。\n\n最终结果是$f$和$d_{\\mathrm{rigid}}$的表达式对。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 3N - C - 3\\chi_t - 3\\chi_r  3\\chi_t + 3\\chi_r \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "掌握了计算自由度的通用理论后，我们通过一个具体的计算实例来深化理解其在实践中的重要性。在模拟中，尤其是在使用刚性水模型等常见力场时，错误地计算自由度是一个频发的失误，这会导致所测量的温度出现系统性偏差。这项练习  模拟了这样一个场景：一个后处理脚本忽略了刚性约束，从而得到了一个“幼稚”的温度值。通过计算该值与正确温度的偏差，你将亲身体会到精确核算自由度对获得可靠物理观测量是何等关键。",
            "id": "3451676",
            "problem": "在一个微正则系综中，对一个刚性三位点水模型进行了经典的分子动力学（MD）模拟。该系统包含 $N_{\\mathrm{mol}} = 1000$ 个水分子，每个分子有 $3$ 个原子。每个水分子的几何构型由每个分子的 $3$ 个完整约束来维持，并且系统的总线性动量被移除，从而消除了 $3$ 个全局自由度。动力学温度是通过动能和有效自由度的数量来定义的。然而，一个简陋的后处理脚本在计算动力学温度时，使用的自由度计数忽略了因约束而移除的自由度，但仍然考虑了因移除总线性动量而减少的自由度。\n\n假设该简陋脚本报告的动力学温度为 $T_{\\mathrm{kin}}^{\\mathrm{naive}} = 200 \\ \\mathrm{K}$，该温度是使用自由度计数 $f_{\\mathrm{naive}} = 3 N_{\\mathrm{atoms}} - 3$（其中 $N_{\\mathrm{atoms}} = 3 N_{\\mathrm{mol}}$）从轨迹的瞬时动能计算得出的。使用适用于经典MD和刚性约束的第一性原理推断，确定：\n- 简陋动力学温度中的有符号偏差 $\\Delta T$（定义为 $\\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}}$），以及\n- 考虑了约束自由度的校正后动力学温度 $T_{\\mathrm{kin}}^{\\mathrm{corr}}$。\n\n假设在两种动力学温度的定义中，瞬时动能是相同的，唯一的区别来自于自由度的计数。将 $\\Delta T$ 和 $T_{\\mathrm{kin}}^{\\mathrm{corr}}$ 均以开尔文表示。将您的答案四舍五入至四位有效数字。",
            "solution": "该问题要求在一个分子动力学模拟中，确定校正后的动力学温度及其与简陋计算值的偏差。验证问题陈述的有效性是必要的第一步。\n\n### 问题有效性验证\n\n**步骤1：提取已知条件**\n- 系统类型：经典分子动力学模拟，刚性三位点水模型。\n- 系综：微正则系综。\n- 分子数：$N_{\\mathrm{mol}} = 1000$。\n- 每个分子的原子数：$3$。\n- 总原子数：$N_{\\mathrm{atoms}} = 3 N_{\\mathrm{mol}}$。\n- 约束：每个分子应用 $3$ 个完整约束以维持刚性几何构型。\n- 全局自由度：移除系统的总线性动量，消除 $3$ 个全局自由度。\n- 简陋动力学温度：$T_{\\mathrm{kin}}^{\\mathrm{naive}} = 200 \\ \\mathrm{K}$。\n- 简陋自由度公式：$f_{\\mathrm{naive}} = 3 N_{\\mathrm{atoms}} - 3$。\n- 偏差定义：$\\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}}$。\n- 核心假设：在简陋和校正后的温度计算中，瞬时动能 $E_k$ 相同。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据（关键）：** 该问题牢固地植根于经典统计力学和计算物理学的原理。通过能量均分定理定义动力学温度、自由度的概念、对刚体使用完整约束以及移除质心运动，这些都是分子动力学模拟的标准和基本方面。该设定在科学上是合理的。\n- **良态问题：** 这是一个良态问题。它提供了所有必要的数值数据（$N_{\\mathrm{mol}}$, $T_{\\mathrm{kin}}^{\\mathrm{naive}}$）和清晰的定义（$f_{\\mathrm{naive}}$, $\\Delta T$），足以确定所求量（$T_{\\mathrm{kin}}^{\\mathrm{corr}}$, $\\Delta T$）的唯一解。\n- **客观性（关键）：** 该问题以精确、定量和无偏见的语言陈述，没有主观或模糊的术语。\n\n该问题未表现出任何使其无效的缺陷。它在科学上不是不合理的，也不是不完整、病态或其他有缺陷的。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将提供完整解答。\n\n### 解答\n\n将经典系统的总动能 $E_k$ 与其动力学温度 $T_{\\mathrm{kin}}$ 联系起来的基本原理源于能量均分定理。对于一个具有 $f$ 个二次自由度的系统，其关系为：\n$$ E_k = \\frac{1}{2} f k_B T_{\\mathrm{kin}} $$\n其中 $k_B$ 是玻尔兹曼常数。由此，动力学温度定义为：\n$$ T_{\\mathrm{kin}} = \\frac{2 E_k}{f k_B} $$\n问题源于对自由度 $f$ 的不正确计数。\n\n首先，我们确定系统中的分子数和原子数。\n给定 $N_{\\mathrm{mol}} = 1000$ 个分子，每个分子 $3$ 个原子，总原子数为：\n$$ N_{\\mathrm{atoms}} = 3 N_{\\mathrm{mol}} = 3 \\times 1000 = 3000 $$\n\n接下来，我们计算脚本所使用的简陋自由度数 $f_{\\mathrm{naive}}$。问题给出了所用的公式：\n$$ f_{\\mathrm{naive}} = 3 N_{\\mathrm{atoms}} - 3 $$\n这个计数正确地减去了因移除系统总线性动量而减少的 $3$ 个自由度，但错误地未能减去因刚性约束而移除的自由度。\n$$ f_{\\mathrm{naive}} = 3(3000) - 3 = 9000 - 3 = 8997 $$\n\n现在，我们必须确定正确的自由度数 $f_{\\mathrm{corr}}$。一个由 $N_{\\mathrm{atoms}}$ 个质点组成的系统最初具有 $3 N_{\\mathrm{atoms}}$ 个自由度。我们必须减去独立完整约束的数量和被移除的全局自由度的数量。\n- 系统有 $N_{\\mathrm{mol}}$ 个分子。\n- 每个分子通过 $3$ 个约束变为刚体。\n- 总约束数：$N_{\\mathrm{constraints}} = 3 N_{\\mathrm{mol}} = 3 \\times 1000 = 3000$。\n- 因总线性动量为零而移除的全局自由度：$3$。\n\n因此，校正后的自由度数为：\n$$ f_{\\mathrm{corr}} = 3 N_{\\mathrm{atoms}} - N_{\\mathrm{constraints}} - 3 = 3(3000) - 3000 - 3 = 9000 - 3000 - 3 = 5997 $$\n另外，对于一个由 $N_{\\mathrm{mol}}$ 个刚性非线性分子（三位点水模型是非线性的）组成的系统，每个分子拥有 $3$ 个平动自由度和 $3$ 个转动自由度，每个分子总共有 $6$ 个自由度。对于由独立分子组成的系统，总自由度为 $6 N_{\\mathrm{mol}}$。减去整个系统质心平动的 $3$ 个自由度，得到：\n$$ f_{\\mathrm{corr}} = 6 N_{\\mathrm{mol}} - 3 = 6(1000) - 3 = 6000 - 3 = 5997 $$\n两种方法的结果一致。\n\n问题陈述，两种温度计算中的瞬时动能 $E_k$ 是相同的。因此我们可以陈述：\n$$ T_{\\mathrm{kin}}^{\\mathrm{naive}} = \\frac{2 E_k}{f_{\\mathrm{naive}} k_B} \\quad \\implies \\quad \\frac{2 E_k}{k_B} = f_{\\mathrm{naive}} T_{\\mathrm{kin}}^{\\mathrm{naive}} $$\n$$ T_{\\mathrm{kin}}^{\\mathrm{corr}} = \\frac{2 E_k}{f_{\\mathrm{corr}} k_B} $$\n通过将 $\\frac{2 E_k}{k_B}$ 的表达式代入第二个方程，我们找到了两种温度之间的关系：\n$$ T_{\\mathrm{kin}}^{\\mathrm{corr}} = \\frac{f_{\\mathrm{naive}} T_{\\mathrm{kin}}^{\\mathrm{naive}}}{f_{\\mathrm{corr}}} = T_{\\mathrm{kin}}^{\\mathrm{naive}} \\left( \\frac{f_{\\mathrm{naive}}}{f_{\\mathrm{corr}}} \\right) $$\n使用已知值 $T_{\\mathrm{kin}}^{\\mathrm{naive}} = 200 \\ \\mathrm{K}$，$f_{\\mathrm{naive}} = 8997$ 和 $f_{\\mathrm{corr}} = 5997$：\n$$ T_{\\mathrm{kin}}^{\\mathrm{corr}} = 200 \\ \\mathrm{K} \\times \\left( \\frac{8997}{5997} \\right) \\approx 200 \\ \\mathrm{K} \\times 1.5002501... \\approx 300.050025... \\ \\mathrm{K} $$\n四舍五入至四位有效数字，校正后的动力学温度为 $T_{\\mathrm{kin}}^{\\mathrm{corr}} = 300.1 \\ \\mathrm{K}$。\n\n最后，我们计算问题中定义的有符号偏差 $\\Delta T$：\n$$ \\Delta T = T_{\\mathrm{kin}}^{\\mathrm{naive}} - T_{\\mathrm{kin}}^{\\mathrm{corr}} $$\n$$ \\Delta T = 200 \\ \\mathrm{K} - 300.050025... \\ \\mathrm{K} = -100.050025... \\ \\mathrm{K} $$\n四舍五入至四位有效数字，有符号偏差为 $\\Delta T = -100.1 \\ \\mathrm{K}$。负号表示简陋的计算低估了真实的动力学温度。这是预料之中的，因为简陋的计算错误地假设了相同的动能分布在更多的自由度上。\n\n所求的值为有符号偏差 $\\Delta T$ 和校正后的动力学温度 $T_{\\mathrm{kin}}^{\\mathrm{corr}}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}-100.1  300.1\\end{pmatrix}}$$"
        },
        {
            "introduction": "即使我们正确地计算了自由度 $f$，在分子动力学模拟中获得的温度仍然会受到一个不易察觉但至关重要的因素的影响：有限的时间步长 $h$。由于数值积分算法是对连续牛顿运动方程的离散近似，所有测量量（包括动能）都会包含一个与 $h$ 相关的系统误差。这项最终练习  将向你介绍一种强大的数值分析技术——理查森外推法（Richardson extrapolation），它能够系统地消除这种由离散化引入的主导误差。通过将不同时间步长下的测量数据进行加权拟合，你将能够估算出系统在连续时间极限（$h \\to 0$）下的真实温度，并量化其不确定性，这是计算物理学中追求高精度结果的一项高级技能。",
            "id": "3451698",
            "problem": "在分子动力学（MD）中，动力学温度根据均分定理定义为满足 $K = \\frac{f}{2} k_{\\mathrm{B}} T$ 的标量 $T$，其中 $K$ 是在一条轨迹样本上平均的动能，$f$ 是二次自由度的数量，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。当轨迹由近似牛顿定律的有限时间步长积分器生成时，有限步长离散化会使测量的时间平均动力学温度产生偏差。对于一个相容的、$p$ 阶精度的时间可逆积分器，一个公认的结论是，平滑可观测量的偏差允许以时间步长 $h$ 的幂进行渐近展开，当 $p$ 为偶数时，其首项与 $h^{p}$ 成正比。特别地，假设测量的动力学温度作为时间步长的函数，可以通过以下模型很好地建模：\n$$\nT(h) = T_0 + c\\, h^{p} + \\varepsilon(h),\n$$\n其中 $T_0$ 是连续介质（$h \\to 0$）下的动力学温度（单位为开尔文），$c$ 是一个未知系数，而 $\\varepsilon(h)$ 代表高阶截断误差项和测量噪声。对于几个测试数据集，您将获得一组测量的时间步长 $h_i$（单位为飞秒）、测量的动力学温度 $T_i$（单位为开尔文）、积分器的已知阶数 $p$，以及每个 $T_i$ 的独立单标准差不确定度 $\\sigma_i$（单位为开尔文）。假设 $\\varepsilon(h)$ 的实现是独立的、均值为零且方差为 $\\sigma_i^2$ 的高斯分布，并且在给定的 $h_i$ 下，高阶截断项可以忽略不计。\n\n任务：实现一个程序，对每个数据集执行理查森式外推法来估计 $T_0$ 并量化其单标准差不确定度。使用与模型 $T(h) = T_0 + c\\, h^p + \\text{noise}$ 一致的、基于统计学原理的方法：\n- 对于 $n \\ge 2$ 个数据点，通过加权最小二乘法拟合线性模型 $y_i = a + b x_i$，其中 $x_i = h_i^{p}$，$y_i = T_i$，权重为 $w_i = 1/\\sigma_i^2$，从而得到 $a$（$T_0$ 的估计值）及其来自估计量协方差的标准不确定度。这种多点线性拟合通过在最佳线性无偏估计的意义上消除首阶项，实现了一种多点理查森外推法。如果只给定两个点，这将简化为 $h^p$ 项的两点消除法，并产生与两点理查森公式相同的 $T_0$。\n- $(a,b)$ 的估计量为\n$$\n\\hat{\\beta} = \\begin{bmatrix} \\hat{a} \\\\ \\hat{b} \\end{bmatrix} = \\left(X^\\top W X\\right)^{-1} X^\\top W y,\n$$\n其中 $X$ 是 $n \\times 2$ 的设计矩阵，其行为 $[1, x_i]$，$W = \\mathrm{diag}(w_1,\\dots,w_n)$，$y$ 是 $y_i$ 值的向量。$\\hat{\\beta}$ 的协方差为\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = \\left(X^\\top W X\\right)^{-1},\n$$\n因此 $T_0$ 的单标准差不确定度为 $u_{T_0} = \\sqrt{\\left[\\mathrm{Cov}(\\hat{\\beta})\\right]_{11}}$（即 $(1,1)$ 条目的平方根）。\n- 报告 $T_0$ 和 $u_{T_0}$，均以开尔文为单位，并四舍五入到三位小数。\n\n输入嵌入在程序中；不需要外部输入。使用以下数据集测试套件，每个数据集由三元组 $(p,\\{h_i\\},\\{T_i\\},\\{\\sigma_i\\})$ 指定：\n- 数据集 A（二阶积分器，三点，同方差）：$p = 2$，$h = [4, 2, 1]$（飞秒），$T = [308.1, 301.8, 300.6]$（开尔文），$\\sigma = [0.2, 0.2, 0.2]$（开尔文）。\n- 数据集 B（二阶积分器，两点，同方差）：$p = 2$，$h = [3, 1.5]$（飞秒），$T = [305.0, 301.3]$（开尔文），$\\sigma = [0.1, 0.1]$（开尔文）。\n- 数据集 C（二阶积分器，三点，异方差）：$p = 2$，$h = [5, 2, 1]$（飞秒），$T = [319.4, 303.5, 301.1]$（开尔文），$\\sigma = [0.5, 0.2, 0.1]$（开尔文）。\n- 数据集 D（四阶积分器，三点，同方差）：$p = 4$，$h = [4, 2, 1]$（飞秒），$T = [302.5, 300.2, 300.0]$（开尔文），$\\sigma = [0.05, 0.05, 0.05]$（开尔文）。\n\n角度单位不适用。所有温度必须以开尔文表示。您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表包含一个数据集的 $[T_0, u_{T_0}]$，两者均四舍五入到三位小数，并按 A、B、C、D 的顺序排列。例如，输出格式必须与 $[[T_{0,A},u_{A}],[T_{0,B},u_{B}],[T_{0,C},u_{C}],[T_{0,D},u_{D}]]$ 完全一样。",
            "solution": "### 问题验证\n\n该问题是有效的。\n- **科学依据：** 所提出的模型 $T(h) = T_0 + c h^p + \\varepsilon(h)$ 是用于计算由对称 $p$ 阶数值积分器生成的轨迹的可观测量误差的标准渐近展开式。这是几何数值积分领域的一个公认结果，尤其与分子动力学（MD）相关。使用加权最小二乘法（WLS）将此模型拟合到具有已知异方差噪声的数据，是一种统计上严谨且标准的参数估计方法。在此被构建为线性拟合的理查森外推法是数值分析中的一种经典技术。整个设置完全符合物理学、数值分析和统计学的既定原则。\n- **适定性：** 问题定义清晰。数据（$h_i, T_i, \\sigma_i, p$）、模型和估计方法（WLS）都已明确提供。对于每个数据集，至少有两个数据点（$n \\ge 2$），并且自变量 $x_i = h_i^p$ 是互不相同的，这确保了矩阵 $X^\\top W X$ 是可逆的。因此，参数及其不确定度的唯一解存在。\n- **客观性：** 问题以客观的数学语言表述。所有量都有精确定义，任务是将指定的算法应用于给定的数据。没有主观因素。\n- **完整性：** 问题为计算四个数据集中的每一个都提供了所有必要的信息。\n- **一致性：** 在给定的统计假设下，所提供的 WLS 估计量及其协方差矩阵的公式是正确的。\n\n该问题被认为是有效的，并将提供完整的解决方案。\n\n### 基于原理的解决方案设计\n\n核心任务是从在不同时间步长 $h$ 下获得的一组 MD 模拟结果中，估计连续介质温度 $T_0$ 及其不确定度。问题提供了一个模型，描述了测量温度 $T(h)$ 如何依赖于时间步长：\n\n$$\nT_i = T_0 + c h_i^p + \\varepsilon_i\n$$\n\n其中 $T_i = T(h_i)$ 是在时间步长 $h_i$ 处测量的温度，$p$ 是积分器的阶数，$T_0$ 和 $c$ 是未知常数，而 $\\varepsilon_i$ 是一个随机误差项。假设误差 $\\varepsilon_i$ 是独立的，并且服从均值为零、已知方差为 $\\sigma_i^2$ 的正态分布。\n\n这个模型可以被重构为一个线性回归问题。通过定义新的自变量 $x_i = h_i^p$ 和因变量 $y_i = T_i$，模型变为：\n\n$$\ny_i = a + b x_i + \\varepsilon_i\n$$\n\n这里，截距 $a$ 对应于所求的连续介质温度 $T_0$，斜率 $b$ 对应于系数 $c$。\n\n由于测量不确定度 $\\sigma_i$ 在所有数据点上并非一致（异方差噪声），拟合此线性模型最合适的方法是加权最小二乘法（WLS）。每个数据点 $(x_i, y_i)$ 的权重选择为相应误差项方差的倒数，即 $w_i = 1/\\sigma_i^2$。这种选择给予更精确的测量更大的影响，并为参数 $(a, b)$ 产生最佳线性无偏估计（BLUE）。\n\nWLS 解是通过求解矩阵形式的正规方程组找到的。参数 $\\hat{\\beta} = \\begin{bmatrix} \\hat{a} \\\\ \\hat{b} \\end{bmatrix}$ 的估计如下：\n\n$$\n\\hat{\\beta} = \\left(X^\\top W X\\right)^{-1} X^\\top W y\n$$\n\n其中：\n- $y$ 是观测温度 $T_i$ 的列向量。\n- $X$ 是 $n \\times 2$ 的设计矩阵，其中第 $i$ 行为 $[1, x_i] = [1, h_i^p]$。\n- $W$ 是 $n \\times n$ 的对角权重矩阵，其中 $W_{ii} = w_i = 1/\\sigma_i^2$。\n\n估计参数的统计不确定度由协方差矩阵捕获，其公式为：\n\n$$\n\\mathrm{Cov}(\\hat{\\beta}) = \\left(X^\\top W X\\right)^{-1}\n$$\n\n$T_0$ 的估计值为 $\\hat{a}$，即向量 $\\hat{\\beta}$ 的第一个元素。该估计的方差 $\\mathrm{Var}(\\hat{a})$ 是协方差矩阵的左上角元素，即 $[\\mathrm{Cov}(\\hat{\\beta})]_{11}$。$T_0$ 的单标准差不确定度，记为 $u_{T_0}$，是该方差的平方根：\n\n$$\nu_{T_0} = \\sqrt{[\\mathrm{Cov}(\\hat{\\beta})]_{11}}\n$$\n\n对每个数据集的实现将按以下步骤进行：\n1.  从提供的数据构建向量 $h$、$T$ 和 $\\sigma$。\n2.  定义阶数 $p$。\n3.  计算变换后的变量 $x_i = h_i^p$。\n4.  构建设计矩阵 $X$ 和权重矩阵 $W$。\n5.  使用矩阵代数，最好借助像 `NumPy` 这样的稳健库，使用上述公式计算 $\\hat{\\beta}$ 和 $\\mathrm{Cov}(\\hat{\\beta})$。\n6.  提取 $T_0$ 的估计值 $\\hat{a}$ 并计算其不确定度 $u_{T_0}$。\n7.  按要求将最终结果四舍五入到三位小数。\n8.  收集所有数据集的结果，并根据指定格式进行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A: 2nd-order, 3 points, homoscedastic\n        {'p': 2, 'h': [4, 2, 1], 'T': [308.1, 301.8, 300.6], 'sigma': [0.2, 0.2, 0.2]},\n        # Dataset B: 2nd-order, 2 points, homoscedastic\n        {'p': 2, 'h': [3, 1.5], 'T': [305.0, 301.3], 'sigma': [0.1, 0.1]},\n        # Dataset C: 2nd-order, 3 points, heteroscedastic\n        {'p': 2, 'h': [5, 2, 1], 'T': [319.4, 303.5, 301.1], 'sigma': [0.5, 0.2, 0.1]},\n        # Dataset D: 4th-order, 3 points, homoscedastic\n        {'p': 4, 'h': [4, 2, 1], 'T': [302.5, 300.2, 300.0], 'sigma': [0.05, 0.05, 0.05]}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Pass the parameters of each case to the solver function.\n        result = calculate_extrapolation(\n            p=case['p'],\n            h_data=case['h'],\n            T_data=case['T'],\n            sigma_data=case['sigma']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is already in the correct format.\n    # We remove whitespace to make it compact as per the example.\n    print(str(results).replace(\" \", \"\"))\n\ndef calculate_extrapolation(p, h_data, T_data, sigma_data):\n    \"\"\"\n    Performs weighted least squares fitting to estimate T0 and its uncertainty.\n\n    Args:\n        p (int): The order of the integrator.\n        h_data (list of float): Measured time steps.\n        T_data (list of float): Measured kinetic temperatures.\n        sigma_data (list of float): Uncertainties for each temperature measurement.\n\n    Returns:\n        list: A list containing [T0, u_T0], rounded to three decimal places.\n    \"\"\"\n    # Convert input lists to NumPy arrays for vectorized operations.\n    # Using float64 for better precision in matrix calculations.\n    h = np.array(h_data, dtype=np.float64)\n    T = np.array(T_data, dtype=np.float64)\n    sigma = np.array(sigma_data, dtype=np.float64)\n\n    # 1. Transform variables for the linear model y = a + b*x\n    #    y = T_i, x = h_i^p, a = T0, b = c\n    x = h**p\n    y = T\n\n    # 2. Construct matrices for Weighted Least Squares (WLS).\n    # The weight matrix W is diagonal with weights w_i = 1/sigma_i^2.\n    weights = 1.0 / sigma**2\n    W = np.diag(weights)\n\n    # The design matrix X has a column of ones for the intercept and a column for x.\n    X = np.vstack([np.ones(len(x)), x]).T\n\n    # 3. Solve for the parameters using the WLS normal equations.\n    # The parameter vector beta_hat = [a, b] is given by:\n    # beta_hat = (X^T * W * X)^(-1) * (X^T * W * y)\n    \n    # Calculate the matrix (X^T * W * X)\n    XTWX = X.T @ W @ X\n    \n    # Calculate the vector (X^T * W * y)\n    XTWy = X.T @ W @ y\n\n    # The covariance matrix of the parameters is the inverse of XTWX.\n    # Using np.linalg.inv is numerically stable and robust.\n    cov_beta = np.linalg.inv(XTWX)\n\n    # The parameter estimates are found by multiplying cov_beta by XTWy.\n    beta_hat = cov_beta @ XTWy\n\n    # 4. Extract results for T0.\n    # The estimate for T0 is the intercept 'a', which is the first element of beta_hat.\n    T0_estimate = beta_hat[0]\n\n    # The uncertainty in T0 is the square root of the corresponding diagonal element\n    # of the covariance matrix, which is cov_beta[0, 0].\n    uncertainty_T0 = np.sqrt(cov_beta[0, 0])\n    \n    # 5. Round the results to three decimal places as required.\n    T0_rounded = round(T0_estimate, 3)\n    u_T0_rounded = round(uncertainty_T0, 3)\n\n    return [T0_rounded, u_T0_rounded]\n\n# Execute the main function when the script is run.\nsolve()\n```"
        }
    ]
}