{
    "hands_on_practices": [
        {
            "introduction": "本实践深入探讨了分析分子动力学模拟中时间序列数据的一个基本方面：时间相关性。模拟中收集的数据点在统计上并非独立；$t$ 时刻的状态与 $t+\\Delta t$ 时刻的状态高度相关。本练习将指导你推导并计算有效样本量（$N_{\\mathrm{eff}}$），这是一个关键指标，用于量化相关时间序列中真正独立的数据点数量。理解 $N_{\\mathrm{eff}}$ 对于正确估计统计误差和判断模拟片段是否足够长以达到平衡至关重要。",
            "id": "3405213",
            "problem": "一次分子动力学 (MD) 平衡化模拟会生成一个可观测量（例如势能）的相关时间序列，该序列以均匀时间间隔 $\\Delta t$ 进行采样。令 $X_{i}$ 表示在时间 $t_{i} = i \\Delta t$ 的样本，并假设在丢弃初始的瞬态部分后，该过程是平稳的。通过使用 $\\rho(t)$ 在非负延迟上的求和（或积分）的标准时域定义，来定义归一化自相关函数 $\\rho(t)$ 和积分自相关时间 (IAT) $\\tau_{\\mathrm{int}}$。从样本均值 $\\bar{X} = \\frac{1}{N} \\sum_{i=1}^{N} X_{i}$ 的定义以及用自协方差函数表示的相关数据的 $\\bar{X}$ 的方差出发，通过将相关序列的 $\\mathrm{Var}(\\bar{X})$ 等同于 $\\sigma^{2}/N_{\\mathrm{eff}}$（其中 $\\sigma^{2}$ 是底层平稳过程的方差），推导有效样本量 $N_{\\mathrm{eff}}$ 关于 $N$、$\\Delta t$ 和 $\\tau_{\\mathrm{int}}$ 的表达式。然后，考虑一次 MD 模拟，其归一化自相关函数能很好地用单指数模型 $\\rho(t) = \\exp\\!\\left(-t/\\tau_{c}\\right)$ 描述，对于该模型，积分自相关时间等于相关时间，即 $\\tau_{\\mathrm{int}} = \\tau_{c}$。假设采样间隔为 $\\Delta t = 2\\,\\mathrm{fs}$，当前生产阶段的长度为 $T_{\\mathrm{cur}} = 3.000\\,\\mathrm{ns}$，对平衡部分的可靠分析得出 $\\tau_{c} = 18.7\\,\\mathrm{ps}$。您希望通过使用一个停止准则来监测平衡过程中的收敛性，该准则要求达到一个目标有效样本量 $N_{\\mathrm{eff}}^{\\star} = 200$。根据您推导的表达式和该指数模型，计算在 $T_{\\mathrm{cur}}$ 之外，为达到 $N_{\\mathrm{eff}}^{\\star}$ 所需的最小额外生产时间 $\\Delta T_{\\mathrm{add}}$。将您的最终数值答案四舍五入至四位有效数字，并以纳秒 (ns) 为单位表示。在您的推导中，请从自相关和相关观测的样本均值方差的基本定义开始；不要假设任何快捷公式。",
            "solution": "问题要求完成两个主要任务：首先，从基本原理出发推导有效样本量 $N_{\\mathrm{eff}}$ 的表达式；其次，应用此表达式计算达到目标有效样本量所需的额外模拟时间。\n\n**第一部分：有效样本量 $N_{\\mathrm{eff}}$ 的推导**\n\n设 $X_i$ 为在时间 $t_i = i \\Delta t$（$i=1, 2, \\dots, N$）采样的平稳可观测量的值。样本均值 $\\bar{X}$ 定义为：\n$$\n\\bar{X} = \\frac{1}{N} \\sum_{i=1}^{N} X_{i}\n$$\n样本均值的方差由下式给出：\n$$\n\\mathrm{Var}(\\bar{X}) = \\mathrm{Var}\\left(\\frac{1}{N} \\sum_{i=1}^{N} X_{i}\\right) = \\frac{1}{N^2} \\mathrm{Var}\\left(\\sum_{i=1}^{N} X_{i}\\right)\n$$\n利用随机变量之和的方差性质，我们有：\n$$\n\\mathrm{Var}\\left(\\sum_{i=1}^{N} X_{i}\\right) = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathrm{Cov}(X_i, X_j)\n$$\n对于一个平稳过程，协方差 $\\mathrm{Cov}(X_i, X_j)$ 仅取决于时间延迟 $|t_i - t_j| = |i-j|\\Delta t$。我们定义在离散延迟 $k$ 步时的自协方差函数为 $\\gamma_k = \\mathrm{Cov}(X_i, X_{i+k})$。该过程的方差为 $\\sigma^2 = \\mathrm{Var}(X_i) = \\gamma_0$。由于平稳性，$\\gamma_k = \\gamma_{-k}$。我们可以通过将具有相同延迟 $k = |i-j|$ 的项分组来重写双重求和：\n$$\n\\sum_{i=1}^{N} \\sum_{j=1}^{N} \\mathrm{Cov}(X_i, X_j) = \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\gamma_{|i-j|} = \\sum_{k=-(N-1)}^{N-1} (N-|k|) \\gamma_k\n$$\n这可以分解为 $k=0$、$k>0$ 和 $k<0$ 的项：\n$$\n\\sum_{k=-(N-1)}^{N-1} (N-|k|) \\gamma_k = (N-0)\\gamma_0 + \\sum_{k=1}^{N-1} (N-k)\\gamma_k + \\sum_{k=-(N-1)}^{-1} (N-|k|)\\gamma_k\n$$\n使用 $\\gamma_k = \\gamma_{-k}$，表达式变为：\n$$\nN\\gamma_0 + 2\\sum_{k=1}^{N-1} (N-k)\\gamma_k\n$$\n将此代回 $\\mathrm{Var}(\\bar{X})$ 的表达式中：\n$$\n\\mathrm{Var}(\\bar{X}) = \\frac{1}{N^2} \\left[ N\\gamma_0 + 2\\sum_{k=1}^{N-1} (N-k)\\gamma_k \\right] = \\frac{\\gamma_0}{N} \\left[ 1 + \\frac{2}{N}\\sum_{k=1}^{N-1} (N-k)\\frac{\\gamma_k}{\\gamma_0} \\right]\n$$\n延迟为 $k$ 时的归一化自相关函数 (ACF) 为 $\\rho_k = \\gamma_k / \\gamma_0$。代入此式和 $\\sigma^2=\\gamma_0$：\n$$\n\\mathrm{Var}(\\bar{X}) = \\frac{\\sigma^2}{N} \\left[ 1 + 2\\sum_{k=1}^{N-1} \\left(1-\\frac{k}{N}\\right)\\rho_k \\right]\n$$\n这个表达式是精确的。对于典型的 MD 模拟，其总时间远长于相关时间，因此当 $k \\ll N$ 时，ACF $\\rho_k$ 会衰减到零。在此极限下，我们可以做两个近似：\n1.  对于 $\\rho_k$ 不可忽略的 $k$ 值，有 $k/N \\ll 1$，因此 $(1-k/N) \\approx 1$。\n2.  由于当 $k$ 很大时 $\\rho_k \\approx 0$，求和的上限可以从 $N-1$ 扩展到 $\\infty$。\n\n通过这些近似，方差变为：\n$$\n\\mathrm{Var}(\\bar{X}) \\approx \\frac{\\sigma^2}{N} \\left( 1 + 2\\sum_{k=1}^{\\infty} \\rho_k \\right)\n$$\n问题使用连续时间 ACF $\\rho(t)$ 定义了积分自相关时间 (IAT) $\\tau_{\\mathrm{int}}$：\n$$\n\\tau_{\\mathrm{int}} = \\int_0^\\infty \\rho(t) dt\n$$\n我们可以将离散和 $\\sum \\rho_k$ 与该积分联系起来。该积分可以使用步长为 $\\Delta t$ 的梯形法则通过求和来近似：\n$$\n\\tau_{\\mathrm{int}} = \\int_0^\\infty \\rho(t) dt \\approx \\Delta t \\left[ \\frac{1}{2}\\rho(0) + \\sum_{k=1}^{\\infty} \\rho(k \\Delta t) \\right]\n$$\n根据定义 $\\rho(0)=1$ 且 $\\rho_k = \\rho(k \\Delta t)$，我们得到：\n$$\n\\tau_{\\mathrm{int}} \\approx \\Delta t \\left( \\frac{1}{2} + \\sum_{k=1}^{\\infty} \\rho_k \\right)\n$$\n求解求和项：\n$$\n\\sum_{k=1}^{\\infty} \\rho_k \\approx \\frac{\\tau_{\\mathrm{int}}}{\\Delta t} - \\frac{1}{2}\n$$\n现在，将此代回我们关于 $\\mathrm{Var}(\\bar{X})$ 的近似表达式中：\n$$\n\\mathrm{Var}(\\bar{X}) \\approx \\frac{\\sigma^2}{N} \\left( 1 + 2 \\left( \\frac{\\tau_{\\mathrm{int}}}{\\Delta t} - \\frac{1}{2} \\right) \\right) = \\frac{\\sigma^2}{N} \\left( 1 + \\frac{2\\tau_{\\mathrm{int}}}{\\Delta t} - 1 \\right) = \\frac{\\sigma^2}{N} \\left( \\frac{2\\tau_{\\mathrm{int}}}{\\Delta t} \\right)\n$$\n问题通过将相关均值的方差与 $N_{\\mathrm{eff}}$ 个独立样本的均值的方差相等来定义有效样本量 $N_{\\mathrm{eff}}$：\n$$\n\\mathrm{Var}(\\bar{X}) = \\frac{\\sigma^2}{N_{\\mathrm{eff}}}\n$$\n通过比较 $\\mathrm{Var}(\\bar{X})$ 的两个表达式：\n$$\n\\frac{\\sigma^2}{N_{\\mathrm{eff}}} = \\frac{\\sigma^2}{N} \\frac{2\\tau_{\\mathrm{int}}}{\\Delta t}\n$$\n求解 $N_{\\mathrm{eff}}$ 得：\n$$\nN_{\\mathrm{eff}} = \\frac{N \\Delta t}{2\\tau_{\\mathrm{int}}}\n$$\n由于 $T = N \\Delta t$ 是总模拟时间，最终表达式为：\n$$\nN_{\\mathrm{eff}} = \\frac{T}{2\\tau_{\\mathrm{int}}}\n$$\n这就是所求的有效样本量关于 $N$、$\\Delta t$ 和 $\\tau_{\\mathrm{int}}$（或 $T$ 和 $\\tau_{\\mathrm{int}}$）的表达式。\n\n**第二部分：额外生产时间 $\\Delta T_{\\mathrm{add}}$ 的计算**\n\n我们给定了一个 ACF 的单指数模型 $\\rho(t) = \\exp(-t/\\tau_c)$，对于该模型，积分自相关时间等于相关时间，即 $\\tau_{\\mathrm{int}} = \\tau_c$。我们推导出的 $N_{\\mathrm{eff}}$ 公式变为：\n$$\nN_{\\mathrm{eff}} = \\frac{T}{2\\tau_c}\n$$\n目标是达到 $N_{\\mathrm{eff}}^{\\star} = 200$ 的目标有效样本量。设 $T_{\\mathrm{total}}$ 为实现此目标所需的总模拟时间。\n$$\nN_{\\mathrm{eff}}^{\\star} = \\frac{T_{\\mathrm{total}}}{2\\tau_c}\n$$\n我们可以求解 $T_{\\mathrm{total}}$：\n$$\nT_{\\mathrm{total}} = 2 N_{\\mathrm{eff}}^{\\star} \\tau_c\n$$\n给定的值为：\n-   $N_{\\mathrm{eff}}^{\\star} = 200$\n-   $\\tau_c = 18.7\\,\\mathrm{ps}$\n\n代入这些值：\n$$\nT_{\\mathrm{total}} = 2 \\times 200 \\times 18.7\\,\\mathrm{ps} = 400 \\times 18.7\\,\\mathrm{ps} = 7480\\,\\mathrm{ps}\n$$\n为了以纳秒表示，我们使用换算关系 $1\\,\\mathrm{ns} = 1000\\,\\mathrm{ps}$：\n$$\nT_{\\mathrm{total}} = 7480\\,\\mathrm{ps} \\times \\frac{1\\,\\mathrm{ns}}{1000\\,\\mathrm{ps}} = 7.480\\,\\mathrm{ns}\n$$\n当前生产阶段的长度为 $T_{\\mathrm{cur}} = 3.000\\,\\mathrm{ns}$。所需的最小额外生产时间 $\\Delta T_{\\mathrm{add}}$ 是所需的总时间与当前时间之差：\n$$\n\\Delta T_{\\mathrm{add}} = T_{\\mathrm{total}} - T_{\\mathrm{cur}}\n$$\n$$\n\\Delta T_{\\mathrm{add}} = 7.480\\,\\mathrm{ns} - 3.000\\,\\mathrm{ns} = 4.480\\,\\mathrm{ns}\n$$\n问题要求最终答案四舍五入至四位有效数字。我们的结果 $4.480\\,\\mathrm{ns}$ 已经是这种形式。采样间隔 $\\Delta t = 2\\,\\mathrm{fs}$ 对于理论推导是必要的，但一旦建立了公式 $N_{\\mathrm{eff}} = T/(2\\tau_{\\mathrm{int}})$，它对于最终的数值计算就不是必需的了。",
            "answer": "$$\n\\boxed{4.480}\n$$"
        },
        {
            "introduction": "虽然分析单个轨迹很有用，但它无法保证模拟已经探索了所有相关的相空间。为解决此问题，一种更稳健的方法是运行从不同初始条件开始的多个并行模拟。本实践介绍了强大的势能标度缩减因子（$\\hat{R}$），也称为 Gelman-Rubin 诊断，它将这种比较形式化。通过对比各轨迹*之间*的可观测量方差与每条轨迹*内部*的方差，你将学会计算一个量化分数，该分数表明所有模拟是否已收敛到相同的平衡分布。",
            "id": "3405203",
            "problem": "使用 $M$ 条独立的重复轨迹（从相同的构型开始，速度独立随机化）来监测分子动力学平衡过程，以评估多个可观测量的收敛情况。假设在每条轨迹的最后一段长度为 $n$ 个样本的区间内，每隔一个固定的时间间隔记录两个可观测量，从而为每个可观测量生成了 $M=3$ 条链，每条链有 $n=20$ 个样本。记 $\\boldsymbol{\\mu}_m \\in \\mathbb{R}^2$ 为第 $m$ 条链中两个可观测量的样本均值向量，$\\mathbf{S}_m \\in \\mathbb{R}^{2 \\times 2}$ 为第 $m$ 条链的无偏链内样本协方差矩阵。三条重复链在最终分析窗口内产生了以下汇总数据：\n- 链均值：\n$$\n\\boldsymbol{\\mu}_1=\\begin{pmatrix}0.50 \\\\ 1.00\\end{pmatrix},\\quad\n\\boldsymbol{\\mu}_2=\\begin{pmatrix}0.62 \\\\ 0.96\\end{pmatrix},\\quad\n\\boldsymbol{\\mu}_3=\\begin{pmatrix}0.54 \\\\ 1.06\\end{pmatrix}.\n$$\n- 链内协方差矩阵：\n$$\n\\mathbf{S}_1=\\begin{pmatrix}0.050  0.012 \\\\ 0.012  0.042\\end{pmatrix},\\quad\n\\mathbf{S}_2=\\begin{pmatrix}0.048  0.009 \\\\ 0.009  0.039\\end{pmatrix},\\quad\n\\mathbf{S}_3=\\begin{pmatrix}0.052  0.011 \\\\ 0.011  0.041\\end{pmatrix}.\n$$\n假设所有链在平衡状态下都以可观测量的相同平稳分布为目标，并且各重复轨迹相互独立。从独立重复轨迹的链间和链内方差分解以及大数定律的第一性原理出发，推导以下表达式：\n1) 对每个可观测量分别推导单变量潜在尺度缩减因子（PSRF, $\\hat{R}$），使用边缘方差的合并估计量与平均链内方差之比。\n2) 对二维可观测量推导多变量PSRF（记为 $\\hat{R}_{\\mathrm{multi}}$），其定义为合并方差估计量相对于合并链内协方差的最大广义特征值。\n\n然后，根据给定数据计算单变量和多变量 $\\hat{R}$ 的数值。基于渐近一致性论证，指定在分子动力学平衡监测期间可用于宣布收敛的、有原则的停止阈值和随时间变化的趋势要求（例如，在最后 $n$ 个样本的连续非重叠窗口上）。您指定的阈值必须是无量纲的，并能从方差比的解释中得到证明。\n\n最后，将上面数据计算出的多变量 $\\hat{R}_{\\mathrm{multi}}$ 作为您的答案报告。将最终值表示为无量纲数，并四舍五入到四位有效数字。",
            "solution": "该问题要求推导和计算单变量和多变量潜在尺度缩减因子（PSRF），记为 $\\hat{R}$，作为分子动力学模拟中收敛性的诊断指标。\n\n设 $M$ 为独立重复轨迹的数量，$n$ 为每条轨迹分析窗口中的样本数。给定 $M=3$ 和 $n=20$。对于每条轨迹 $m \\in \\{1, \\dots, M\\}$，我们有两个可观测量的样本均值向量 $\\boldsymbol{\\mu}_m$ 和样本协方差矩阵 $\\mathbf{S}_m$。\n\n**1. 单变量潜在尺度缩减因子（$\\hat{R}$）**\n\n让我们考虑一个由 $k \\in \\{1, 2\\}$ 索引的单一可观测量。均值向量 $\\boldsymbol{\\mu}_m$ 的相应分量是 $\\mu_{m,k}$，协方差矩阵 $\\mathbf{S}_m$ 的相应对角元素是 $S_{m,kk}$，即第 $m$ 条链中该可观测量的无偏样本方差。\n\n该分析基于将总方差分解为链内和链间分量。\n\n平均链内方差 $W_k$ 是各条链方差的均值：\n$$W_k = \\frac{1}{M} \\sum_{m=1}^{M} S_{m,kk}$$\n\n链间方差 $B_k$ 衡量了各链样本均值的方差，并按样本量 $n$ 进行缩放：\n$$B_k = \\frac{n}{M-1} \\sum_{m=1}^{M} (\\mu_{m,k} - \\bar{\\mu}_k)^2$$\n其中 $\\bar{\\mu}_k = \\frac{1}{M} \\sum_{m=1}^{M} \\mu_{m,k}$ 是可观测量 $k$ 在所有链上的总均值。\n\n可观测量边缘方差的合并估计量 $\\hat{V}_k$ 结合了这两个方差分量。它是链内方差和链均值方差的加权平均：\n$$\\hat{V}_k = \\frac{n-1}{n} W_k + \\frac{1}{n} B_k$$\n因子 $\\frac{n-1}{n}$ 是对 $W_k$ 是一个来自有限样本的估计这一事实的修正。当链收敛到平稳分布时，$W_k$ 和 $B_k/n$ 都估计了总方差的分量。如果存在差异（例如，链正在对不同区域进行采样），链间方差将会被放大。\n\n潜在尺度缩减因子 $\\hat{R}_k$ 是合并方差估计与平均链内方差之比的平方根：\n$$\\hat{R}_k = \\sqrt{\\frac{\\hat{V}_k}{W_k}} = \\sqrt{\\frac{\\frac{n-1}{n} W_k + \\frac{1}{n} B_k}{W_k}} = \\sqrt{\\frac{n-1}{n} + \\frac{B_k}{nW_k}}$$\n如果链已经收敛，这个比值应该接近于 $1$。\n\n**单变量 $\\hat{R}$ 的计算：**\n\n对于可观测量1：\n$\\mu_{1,1}=0.50$, $\\mu_{2,1}=0.62$, $\\mu_{3,1}=0.54$。\n$\\bar{\\mu}_1 = \\frac{0.50+0.62+0.54}{3} = \\frac{1.66}{3}$。\n$B_1 = \\frac{20}{3-1} \\left[ \\left(0.50 - \\frac{1.66}{3}\\right)^2 + \\left(0.62 - \\frac{1.66}{3}\\right)^2 + \\left(0.54 - \\frac{1.66}{3}\\right)^2 \\right] = 10 \\left[ \\left(-\\frac{0.16}{3}\\right)^2 + \\left(\\frac{0.20}{3}\\right)^2 + \\left(-\\frac{0.04}{3}\\right)^2 \\right] = \\frac{10}{9}(0.0256 + 0.0400 + 0.0016) = \\frac{0.672}{9} \\approx 0.07467$。\n$S_{1,11}=0.050$, $S_{2,11}=0.048$, $S_{3,11}=0.052$。\n$W_1 = \\frac{0.050+0.048+0.052}{3} = \\frac{0.150}{3} = 0.050$。\n$\\hat{R}_1 = \\sqrt{\\frac{19}{20} + \\frac{0.07467}{20 \\times 0.050}} = \\sqrt{0.95 + 0.07467} = \\sqrt{1.02467} \\approx 1.0122$。\n\n对于可观测量2：\n$\\mu_{1,2}=1.00$, $\\mu_{2,2}=0.96$, $\\mu_{3,2}=1.06$。\n$\\bar{\\mu}_2 = \\frac{1.00+0.96+1.06}{3} = \\frac{3.02}{3}$。\n$B_2 = \\frac{20}{3-1} \\left[ \\left(1.00 - \\frac{3.02}{3}\\right)^2 + \\left(0.96 - \\frac{3.02}{3}\\right)^2 + \\left(1.06 - \\frac{3.02}{3}\\right)^2 \\right] = 10 \\left[ \\left(-\\frac{0.02}{3}\\right)^2 + \\left(-\\frac{0.14}{3}\\right)^2 + \\left(\\frac{0.16}{3}\\right)^2 \\right] = \\frac{10}{9}(0.0004 + 0.0196 + 0.0256) = \\frac{0.456}{9} \\approx 0.05067$。\n$S_{1,22}=0.042$, $S_{2,22}=0.039$, $S_{3,22}=0.041$。\n$W_2 = \\frac{0.042+0.039+0.041}{3} = \\frac{0.122}{3}$。\n$\\hat{R}_2 = \\sqrt{\\frac{19}{20} + \\frac{0.05067}{20 \\times (0.122/3)}} = \\sqrt{0.95 + \\frac{0.15201}{2.44}} \\approx \\sqrt{0.95 + 0.0623} = \\sqrt{1.0123} \\approx 1.0061$。\n\n**2. 多变量潜在尺度缩减因子（$\\hat{R}_{\\mathrm{multi}}$）**\n\n通过将标量方差替换为协方差矩阵，将单变量分析扩展到 $p=2$ 维的情况。\n\n合并链内协方差矩阵 $\\mathbf{W}$ 是各链协方差矩阵的平均值：\n$$\\mathbf{W} = \\frac{1}{M} \\sum_{m=1}^{M} \\mathbf{S}_m$$\n\n链间协方差矩阵 $\\mathbf{B}$ 是：\n$$\\mathbf{B} = \\frac{n}{M-1} \\sum_{m=1}^{M} (\\boldsymbol{\\mu}_m - \\bar{\\boldsymbol{\\mu}})(\\boldsymbol{\\mu}_m - \\bar{\\boldsymbol{\\mu}})^T$$\n其中 $\\bar{\\boldsymbol{\\mu}} = \\frac{1}{M} \\sum_{m=1}^{M} \\boldsymbol{\\mu}_m$ 是总均值向量。\n\n边缘协方差矩阵的合并估计量 $\\hat{\\mathbf{V}}$ 是：\n$$\\hat{\\mathbf{V}} = \\frac{n-1}{n} \\mathbf{W} + \\frac{1}{n} \\mathbf{B}$$\n\n多变量PSRF $\\hat{R}_{\\mathrm{multi}}$ 是通过 $\\hat{\\mathbf{V}}$ 相对于 $\\mathbf{W}$ 的最大广义特征值 $\\lambda_{\\max}$ 定义的。该特征值是广义特征值问题 $\\hat{\\mathbf{V}}\\mathbf{v} = \\lambda\\mathbf{W}\\mathbf{v}$ 的解。\n代入 $\\hat{\\mathbf{V}}$ 的表达式：\n$$\\left(\\frac{n-1}{n} \\mathbf{W} + \\frac{1}{n} \\mathbf{B}\\right)\\mathbf{v} = \\lambda\\mathbf{W}\\mathbf{v}$$\n假设 $\\mathbf{W}$ 是可逆的，我们可以左乘 $\\mathbf{W}^{-1}$：\n$$\\left(\\frac{n-1}{n} \\mathbf{I} + \\frac{1}{n} \\mathbf{W}^{-1}\\mathbf{B}\\right)\\mathbf{v} = \\lambda\\mathbf{v}$$\n这是一个标准的特征值问题。特征值 $\\lambda$ 与矩阵 $\\mathbf{W}^{-1}\\mathbf{B}$ 的特征值 $\\eta$ 通过关系式 $\\lambda = \\frac{n-1}{n} + \\frac{\\eta}{n}$ 相关联。\n多变量PSRF是最大特征值 $\\lambda_{\\max}$ 的平方根：\n$$\\hat{R}_{\\mathrm{multi}} = \\sqrt{\\lambda_{\\max}} = \\sqrt{\\frac{n-1}{n} + \\frac{\\eta_{\\max}}{n}}$$\n其中 $\\eta_{\\max}$ 是 $\\mathbf{W}^{-1}\\mathbf{B}$ 的最大特征值。\n\n**多变量 $\\hat{R}_{\\mathrm{multi}}$ 的计算：**\n\n总均值向量：\n$\\bar{\\boldsymbol{\\mu}} = \\frac{1}{3} \\left( \\begin{pmatrix}0.50 \\\\ 1.00\\end{pmatrix} + \\begin{pmatrix}0.62 \\\\ 0.96\\end{pmatrix} + \\begin{pmatrix}0.54 \\\\ 1.06\\end{pmatrix} \\right) = \\frac{1}{3} \\begin{pmatrix}1.66 \\\\ 3.02\\end{pmatrix}$。\n\n合并链内协方差矩阵 $\\mathbf{W}$：\n$\\mathbf{W} = \\frac{1}{3} \\left( \\begin{pmatrix}0.050  0.012 \\\\ 0.012  0.042\\end{pmatrix} + \\begin{pmatrix}0.048  0.009 \\\\ 0.009  0.039\\end{pmatrix} + \\begin{pmatrix}0.052  0.011 \\\\ 0.011  0.041\\end{pmatrix} \\right) = \\frac{1}{3} \\begin{pmatrix}0.150  0.032 \\\\ 0.032  0.122\\end{pmatrix}$。\n\n链间协方差矩阵 $\\mathbf{B}$：\n偏差向量为 $\\boldsymbol{\\mu}_1 - \\bar{\\boldsymbol{\\mu}} = \\frac{1}{3}\\begin{pmatrix}-0.16 \\\\ -0.02\\end{pmatrix}$，$\\boldsymbol{\\mu}_2 - \\bar{\\boldsymbol{\\mu}} = \\frac{1}{3}\\begin{pmatrix}0.20 \\\\ -0.14\\end{pmatrix}$，$\\boldsymbol{\\mu}_3 - \\bar{\\boldsymbol{\\mu}} = \\frac{1}{3}\\begin{pmatrix}-0.04 \\\\ 0.16\\end{pmatrix}$。\n$\\mathbf{B} = \\frac{20}{3-1} \\sum_{m=1}^{3} (\\boldsymbol{\\mu}_m - \\bar{\\boldsymbol{\\mu}})(\\boldsymbol{\\mu}_m - \\bar{\\boldsymbol{\\mu}})^T = \\frac{10}{9} \\left( \\begin{pmatrix}-0.16 \\\\ -0.02\\end{pmatrix}\\begin{pmatrix}-0.16  -0.02\\end{pmatrix} + \\dots \\right)$\n$\\mathbf{B} = \\frac{10}{9} \\begin{pmatrix} 0.0672  -0.0312 \\\\ -0.0312  0.0456 \\end{pmatrix} \\approx \\begin{pmatrix} 0.07467  -0.03467 \\\\ -0.03467  0.05067 \\end{pmatrix}$。\n\n接下来，我们计算 $\\mathbf{W}^{-1}\\mathbf{B}$。\n$\\det(\\mathbf{W}) = \\frac{1}{9}(0.150 \\times 0.122 - 0.032^2) = \\frac{1}{9}(0.0183 - 0.001024) = \\frac{0.017276}{9}$。\n$\\mathbf{W}^{-1} = \\frac{9}{0.017276} \\frac{1}{3} \\begin{pmatrix} 0.122  -0.032 \\\\ -0.032  0.150 \\end{pmatrix} = \\frac{3}{0.017276} \\begin{pmatrix} 0.122  -0.032 \\\\ -0.032  0.150 \\end{pmatrix}$。\n$\\mathbf{W}^{-1}\\mathbf{B} = \\frac{3}{0.017276} \\begin{pmatrix} 0.122  -0.032 \\\\ -0.032  0.150 \\end{pmatrix} \\frac{10}{9} \\begin{pmatrix} 0.0672  -0.0312 \\\\ -0.0312  0.0456 \\end{pmatrix} = \\frac{10}{3 \\times 0.017276} \\begin{pmatrix} 0.0091968  -0.0052656 \\\\ -0.0068304  0.0078384 \\end{pmatrix}$。\n前置因子为 $\\frac{10}{0.051828} \\approx 192.943$。\n$\\mathbf{W}^{-1}\\mathbf{B} \\approx 192.943 \\begin{pmatrix} 0.0091968  -0.0052656 \\\\ -0.0068304  0.0078384 \\end{pmatrix} \\approx \\begin{pmatrix} 1.7745  -1.0159 \\\\ -1.3178  1.5123 \\end{pmatrix}$。\n该矩阵的特征值 $\\eta$ 是特征方程 $\\eta^2 - \\text{tr}(\\mathbf{W}^{-1}\\mathbf{B})\\eta + \\det(\\mathbf{W}^{-1}\\mathbf{B}) = 0$ 的根。\n$\\text{tr}(\\mathbf{W}^{-1}\\mathbf{B}) \\approx 1.7745 + 1.5123 = 3.2868$。\n$\\det(\\mathbf{W}^{-1}\\mathbf{B}) \\approx (1.7745)(1.5123) - (-1.0159)(-1.3178) \\approx 2.6835 - 1.3388 = 1.3447$。\n$\\eta^2 - 3.2868\\eta + 1.3447 = 0$。\n$\\eta = \\frac{3.2868 \\pm \\sqrt{3.2868^2 - 4(1.3447)}}{2} = \\frac{3.2868 \\pm \\sqrt{10.803 - 5.3788}}{2} = \\frac{3.2868 \\pm \\sqrt{5.4242}}{2} = \\frac{3.2868 \\pm 2.3290}{2}$。\n特征值为 $\\eta_1 \\approx 2.8079$ 和 $\\eta_2 \\approx 0.4789$。最大的是 $\\eta_{\\max} \\approx 2.8079$。\n最后，我们计算 $\\hat{R}_{\\mathrm{multi}}$：\n$\\hat{R}_{\\mathrm{multi}} = \\sqrt{\\frac{20-1}{20} + \\frac{\\eta_{\\max}}{20}} = \\sqrt{0.95 + \\frac{2.8079}{20}} = \\sqrt{0.95 + 0.140395} = \\sqrt{1.090395} \\approx 1.04422$。\n\n**3. 收敛阈值和趋势要求**\n\nPSRF，无论是单变量还是多变量，都提供了一个无量纲的收敛度量。PSRF的平方 $\\hat{R}^2$ 估计了边缘方差相对于链内方差被高估的因子。理想值为 $\\hat{R}=1.0$，表示链间和链内的变异是一致的。\n\n**停止阈值**：一个普遍接受但依赖于具体问题的宣布收敛的阈值是，当所有监测的可观测量的PSRF都低于某个值（如 $1.1$）时。更严格的应用可能要求阈值为 $1.05$ 或 $1.01$。对于多变量情况，$\\hat{R}_{\\mathrm{multi}}  1.1$ 是相应的标准。$\\hat{R}=1.1$ 的值意味着潜在的尺度缩减为 $10\\%$，因为由于不完全收敛，可观测量的估计方差被放大了约 $1.1^2 \\approx 1.21$ 倍。\n\n**趋势要求**：仅在某个时间点达到阈值是不够的。真正的收敛需要稳定性。应在模拟的连续、非重叠时间窗口上监测PSRF。一个用于停止平衡阶段的稳健标准是，在这些窗口上计算的PSRF不仅必须持续低于所选阈值，而且还不能表现出显著的增长趋势。在一个相当长的时间内，稳定或下降的PSRF值表明链正在可靠地从同一个平稳分布中采样。通过目视检查 $\\hat{R}$ 随模拟时间变化的图表是确认这种稳定性的标准做法。\n\n将所要求的最终答案四舍五入到四位有效数字，得到 $1.044$。",
            "answer": "$$\n\\boxed{1.044}\n$$"
        },
        {
            "introduction": "通过目视检查能量、压力和体积的图表来判断平衡何时结束是一种常见但主观的做法。本练习为这一关键步骤引入了一种形式化的自动方法：多变量变化点检测。你将实现一个算法，该算法将关键的热力学可观测量视为一个向量，并使用严格的统计检验（霍特林 $T^2$ 检验）来识别系统从瞬态漂移阶段过渡到稳定、静止状态的精确时刻。本实践旨在培养应用高级统计算法来自动化和提高分子动力学工作流程严谨性的技能。",
            "id": "3405260",
            "problem": "考虑一个正在进行平衡的分子动力学 (MD) 轨迹，它在由整数 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的离散时间步长上，产生总能量 $E(t)$、压力 $P(t)$ 和体积 $V(t)$ 的时间序列。其目的是通过检测联合可观测量 $(E,P,V)$ 中的最后一个显著瞬态来监测平衡过程中的收敛，以便生产阶段可以在此变点之后才开始。目标是设计并实现一个程序化的变点检测 (CPD) 流程，该流程在符合物理现实的假设下，定位向量可观测量的平稳分布中的最后一个统计显著的偏移。\n\n使用以下符合上下文的基础。MD 遵循 Newton 第二定律 $m \\, d^2 \\mathbf{r}/dt^2 = \\mathbf{F}$，其中的力来自于相互作用势 $U(\\mathbf{r})$。在固定热力学参数的平衡状态下，对平稳遍历轨迹的时间平均可估计系综平均；在数值上，这表现为热力学可观测量的大致平稳性。实际的平衡过程通常产生分段平稳的行为：早期的瞬态具有明显不同的均值水平，随后是稳定的均值。这启发我们将 $(E,P,V)$ 建模为一个在各段上具有分段常数均值和有限协方差的多元时间序列。在此模型下，最后一个显著瞬态是 $(E,P,V)$ 的均值向量相对于其协方差发生统计显著偏移的最后一个索引。\n\n设计一个有原则的 CPD 规则，用于处理具有未知协方差的多元高斯模型中的单个突发均值偏移，然后通过一个隔离后续变化的递归过程将其扩展到多个偏移。您的 CPD 必须：\n- 将联合可观测量 $\\mathbf{X}_i = [E_i, P_i, V_i]^\\top$ 视为多元数据。\n- 将显著性建立在对分割前后数据段的有效多元双样本比较之上，其中协方差未知，并从第一性原理推导出其检验统计量及其零假设下的参考分布。\n- 施加一个最小窗口大小 $w_{\\min}$，以使分割前后的样本都至少有 $w_{\\min}$ 个观测值，确保检验的自由度有效。\n- 对于多个变点，应用一个逻辑上合理的递归分割方法，从左到右产生候选变点，并返回检测到的最后一个变点。\n- 如果不存在统计显著的变点，则返回 $0$ 以表示生产可以从头开始。\n\n您的程序必须实现上述逻辑，并将其应用于下面的测试套件。对于所有测试用例，数据都是完全确定的，不需要任何随机性。每个测试用例都通过一个分段常数均值向量和一个确定性的、有界的振荡扰动来提供 $\\mathbf{X}_i$ for $i \\in \\{0,\\dots,N-1\\}$ 的构造。具体来说，可观测量构造如下：\n$$\n\\mathbf{X}_i = \\boldsymbol{\\mu}(i) + \\boldsymbol{\\eta}(i),\n$$\n其中 $\\boldsymbol{\\mu}(i)$ 在各段上是分段常数或线性漂移，而 $\\boldsymbol{\\eta}(i)$ 是每个分量的确定性振荡项。令振荡扰动为\n$$\n\\eta_d(i) = A_d \\sin\\!\\left( \\frac{2\\pi i}{p_d} \\right) + B_d \\cos\\!\\left( \\frac{2\\pi i}{q_d} \\right),\n$$\n其中每个分量 $d \\in \\{E,P,V\\}$ 的振幅 $A_d$, $B_d$ 和周期 $p_d$, $q_d$ 均已知。\n\n实现以下五个测试用例。在每个案例中，完全按照规定构造 $\\mathbf{X}_i$，应用您的 CPD，并以整数索引的形式返回最后一个变点。如果在显著性水平 $\\alpha$ 下未检测到变化，则返回 $0$。\n\n测试用例 1 (多个瞬态；理想路径):\n- $N = 1000$, $w_{\\min} = 50$, $\\alpha = 0.01$。\n- 变点位于索引 $200$ 和 $600$。\n- 段均值：\n  - $i \\in [0,199]$: $\\boldsymbol{\\mu} = [-5000.0, 100.0, 10.0]$。\n  - $i \\in [200,599]$: $\\boldsymbol{\\mu} = [-4500.0, 92.0, 10.4]$。\n  - $i \\in [600,999]$: $\\boldsymbol{\\mu} = [-4400.0, 95.0, 10.2]$。\n- 振荡扰动参数: $A = [30.0, 1.5, 0.08]$, $B = [15.0, 0.7, 0.04]$, $p = [37, 43, 71]$, $q = [41, 47, 73]$。\n\n测试用例 2 (已平衡；无变化):\n- $N = 500$, $w_{\\min} = 50$, $\\alpha = 0.01$。\n- 无变点。\n- 恒定均值: $\\boldsymbol{\\mu} = [-4400.0, 95.0, 10.2]$ 对所有 $i$。\n- 振荡扰动参数: $A = [28.0, 1.4, 0.08]$, $B = [14.0, 0.6, 0.04]$, $p = [29, 41, 67]$, $q = [31, 43, 69]$。\n\n测试用例 3 (单个晚期瞬态；边界条件):\n- $N = 400$, $w_{\\min} = 50$, $\\alpha = 0.01$。\n- 变点位于索引 $350$。\n- 段均值：\n  - $i \\in [0,349]$: $\\boldsymbol{\\mu} = [-4700.0, 110.0, 9.8]$。\n  - $i \\in [350,399]$: $\\boldsymbol{\\mu} = [-4600.0, 105.0, 10.0]$。\n- 振荡扰动参数: $A = [25.0, 2.0, 0.10]$, $B = [12.0, 0.8, 0.05]$, $p = [31, 47, 59]$, $q = [33, 49, 61]$。\n\n测试用例 4 (缓慢漂移；边界情况):\n- $N = 600$, $w_{\\min} = 50$, $\\alpha = 0.01$。\n- 均值从头到尾线性漂移：\n  - $\\boldsymbol{\\mu}(0) = [-4600.0, 100.0, 10.0]$,\n  - $\\boldsymbol{\\mu}(N-1) = [-4590.0, 102.0, 10.02]$,\n  - 对于一般的 $i$，$\\boldsymbol{\\mu}(i) = \\boldsymbol{\\mu}(0) + \\frac{i}{N-1}\\left(\\boldsymbol{\\mu}(N-1) - \\boldsymbol{\\mu}(0)\\right)$。\n- 振荡扰动参数: $A = [30.0, 5.0, 0.20]$, $B = [15.0, 2.0, 0.10]$, $p = [35, 39, 63]$, $q = [37, 41, 65]$。\n\n测试用例 5 (各分量异构变化):\n- $N = 800$, $w_{\\min} = 50$, $\\alpha = 0.01$。\n- 变点位于索引 $150$ 和 $300$。\n- 段均值：\n  - $i \\in [0,149]$: $\\boldsymbol{\\mu} = [-4800.0, 99.0, 10.1]$。\n  - $i \\in [150,299]$: $\\boldsymbol{\\mu} = [-4800.0, 104.0, 10.1]$。\n  - $i \\in [300,799]$: $\\boldsymbol{\\mu} = [-4700.0, 104.0, 10.1]$。\n- 振荡扰动参数: $A = [29.0, 1.2, 0.08]$, $B = [14.5, 0.5, 0.04]$, $p = [33, 45, 69]$, $q = [35, 47, 71]$。\n\n所需输出：\n- 对于每个测试用例，计算生产应开始的整数索引，即检测到的最后一个变点加一，或者如果约定是变化后段的第一个索引，则等效于检测到的最后一个变点。对于本问题，请直接报告检测到的最后一个变点的索引本身（作为整数），如果未检测到变化，则使用 $0$。\n- 您的程序应生成单行输出，其中包含按测试用例 1 到 5 的顺序排列的结果，格式为方括号内以逗号分隔的列表，不含空格，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_j$ 都是整数。\n\n程序必须是自包含的，不需要用户输入，并且只能依赖 Python 标准库、Numerical Python (NumPy) 和 Scientific Python (SciPy)。每个测试用例的答案都是整数。",
            "solution": "该问题要求设计一种变点检测 (CPD) 算法，以识别分子动力学 (MD) 可观测量的多元时间序列中的最后一个显著瞬态。可观测量是总能量 $E$、压力 $P$ 和体积 $V$，在每个离散时间步 $i$ 形成一个三维向量 $\\mathbf{X}_i = [E_i, P_i, V_i]^\\top$。底层的物理模型假设，在平衡过程中，系统在以这些可观测量不同均值为特征的状态之间转换，最终稳定到一个具有恒定均值向量的平稳状态。该行为被建模为均值向量有突变的分段平稳过程。任务是实现一个有原则的统计程序，以找到最后一个此类偏移的索引。\n\n解决方案分三个主要阶段进行开发：首先，建立用于单个变点的统计检验；其次，定义一个搜索过程以在数据段内定位最可能的变点；第三，构建一个递归算法以从多个潜在偏移中识别出最终的变点。\n\n1.  **单个变点的统计检验**\n\n我们解决比较多元时间序列的两个段的核心任务，以确定它们的底层均值向量是否不同。让我们考虑在一个长度为 $N$ 的数据序列中，索引为 $k$ 的一个潜在变点。这将数据分割成一个分割前段 $\\mathcal{S}_1 = \\{\\mathbf{X}_0, \\dots, \\mathbf{X}_{k-1}\\}$（大小为 $n_1 = k$）和一个分割后段 $\\mathcal{S}_2 = \\{\\mathbf{X}_k, \\dots, \\mathbf{X}_{N-1}\\}$（大小为 $n_2 = N-k$）。\n\n问题陈述我们具有未知的协方差，并将数据建模为多元高斯分布。适用于此场景的统计工具是**霍特林两样本 $T^2$ 检验 (Hotelling's two-sample $T^2$ test)**。该检验评估原假设 $H_0: \\boldsymbol{\\mu}_1 = \\boldsymbol{\\mu}_2$ 与备择假设 $H_1: \\boldsymbol{\\mu}_1 \\neq \\boldsymbol{\\mu}_2$，其中 $\\boldsymbol{\\mu}_1$ 和 $\\boldsymbol{\\mu}_2$ 是 $\\mathcal{S}_1$ 和 $\\mathcal{S}_2$ 采样来源的总体的真实均值向量。该检验假设协方差矩阵相等 ($\\boldsymbol{\\Sigma}_1 = \\boldsymbol{\\Sigma}_2 = \\boldsymbol{\\Sigma}$) 但未知。\n\n检验步骤如下：\n- 计算每个段的样本均值向量：\n$$ \\overline{\\mathbf{X}}_1 = \\frac{1}{n_1} \\sum_{i \\in \\mathcal{S}_1} \\mathbf{X}_i \\quad \\text{和} \\quad \\overline{\\mathbf{X}}_2 = \\frac{1}{n_2} \\sum_{i \\in \\mathcal{S}_2} \\mathbf{X}_i $$\n- 计算无偏样本协方差矩阵：\n$$ \\mathbf{S}_1 = \\frac{1}{n_1-1} \\sum_{i \\in \\mathcal{S}_1} (\\mathbf{X}_i - \\overline{\\mathbf{X}}_1)(\\mathbf{X}_i - \\overline{\\mathbf{X}}_1)^\\top \\quad \\text{和} \\quad \\mathbf{S}_2 = \\frac{1}{n_2-1} \\sum_{i \\in \\mathcal{S}_2} (\\mathbf{X}_i - \\overline{\\mathbf{X}}_2)(\\mathbf{X}_i - \\overline{\\mathbf{X}}_2)^\\top $$\n- 计算合并协方差矩阵，它提供了对公共协方差 $\\boldsymbol{\\Sigma}$ 的更好估计：\n$$ \\mathbf{S}_{\\text{pool}} = \\frac{(n_1-1)\\mathbf{S}_1 + (n_2-1)\\mathbf{S}_2}{n_1 + n_2 - 2} $$\n- 霍特林 $T^2$ 统计量，用于衡量样本均值之间的马氏距离 (Mahalanobis distance) 的平方，由下式给出：\n$$ T^2 = \\frac{n_1 n_2}{n_1 + n_2} (\\overline{\\mathbf{X}}_1 - \\overline{\\mathbf{X}}_2)^\\top \\mathbf{S}_{\\text{pool}}^{-1} (\\overline{\\mathbf{X}}_1 - \\overline{\\mathbf{X}}_2) $$\n- 为了进行假设检验，$T^2$ 统计量被转换为一个 $F$-统计量，在 $H_0$ 下该统计量遵循一个已知分布。令 $p=3$ 为数据维度：\n$$ F = \\frac{n_1 + n_2 - p - 1}{(n_1 + n_2 - 2) p} T^2 $$\n在 $H_0$ 下，此统计量遵循自由度为 $p$ 和 $n_1 + n_2 - p - 1$ 的 $F$-分布，即 $F \\sim F_{p, n_1+n_2-p-1}$。$F$ 值较大表示均值之間存在显著差异。\n\n2.  **在段内定位最可能的变点**\n\n要在从 `start` 到 `end` 索引的数据段内找到单个变点，我们必须确定显示出最强变化证据的分割点。我们遍历所有可能的分割点 $k$，从 `start`+$w_{\\min}$ 到 `end`-$w_{\\min}$，确保两个生成的子段都至少有最小窗口大小 $w_{\\min}$。对于每个 $k$，我们如上所述计算 $F$-统计量。候选变点 $k^*$ 是使 $F$-统计量最大化的索引 $k$。如果这个最大统计量 $F(k^*)$ 超过了在指定显著性水平 $\\alpha$ 下，来自 $F_{p, n_1+n_2-p-1}$ 分布的临界值 $F_{\\text{crit}}$，则认为该变化是统计显著的。\n\n3.  **用于寻找最后一个变点的递归分割**\n\n为了找到*最后一个*显著变化，我们采用递归分割策略。该算法对由 `start` 和 `end` 索引定义的数据段进行操作。\n\n- **基本情况：** 如果一个段太小，无法分割成两个有效的子段（即其长度小于 $2w_{\\min}$），则递归终止，返回 $0$（无变点）。\n\n- **递归步骤：**\n    1.  该过程首先通过最大化 $F$-统计量，在当前段 `[start, end]` 中找到最可能的变点 $k^*$，如上一节所述。\n    2.  然后检验该候选点的显著性。如果 $F(k^*) \\le F_{\\text{crit}}$，则当前段中不存在显著变化，函数返回 $0$。\n    3.  如果 $F(k^*) > F_{\\text{crit}}$，则确认在 $k^*$ 处有一个显著变化。但这可能不是*最后一个*。为了检查后续的变化，算法对右侧子段（从 $k^*$ 到 `end`）进行递归调用。\n    4.  设此递归调用的结果为 `last_cp_after`。如果 `last_cp_after` 大于 $0$，意味着找到了一个更晚的变点，这个更晚的索引将作为结果向上传递。如果 `last_cp_after` 为 $0$，则表示没有发现更多变化，使得 $k^*$ 成为该搜索分支中的最后一个变点。然后返回 $k^*$。\n\n这种“向右深入”的递归策略确保搜索优先考虑并报告索引最大的变点。对完整数据集 `search(0, N)` 进行此过程的初始调用，将得出整个时间序列中的最后一个显著变点，如果序列被发现是平稳的，则返回 $0$。\n\n对于提供的测试用例，首先根据指定的分段常数或线性漂移均值函数以及确定性振荡扰动生成数据。然后应用递归 CPD 算法及给定参数（$N, w_{\\min}, \\alpha$）来计算最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import f\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 1000, \"w_min\": 50, \"alpha\": 0.01,\n            \"mu_spec\": [\n                (0, np.array([-5000.0, 100.0, 10.0])),\n                (200, np.array([-4500.0, 92.0, 10.4])),\n                (600, np.array([-4400.0, 95.0, 10.2])),\n            ],\n            \"A\": [30.0, 1.5, 0.08], \"B\": [15.0, 0.7, 0.04],\n            \"p\": [37, 43, 71], \"q\": [41, 47, 73],\n        },\n        # Test case 2\n        {\n            \"N\": 500, \"w_min\": 50, \"alpha\": 0.01,\n            \"mu_spec\": [\n                (0, np.array([-4400.0, 95.0, 10.2])),\n            ],\n            \"A\": [28.0, 1.4, 0.08], \"B\": [14.0, 0.6, 0.04],\n            \"p\": [29, 41, 67], \"q\": [31, 43, 69],\n        },\n        # Test case 3\n        {\n            \"N\": 400, \"w_min\": 50, \"alpha\": 0.01,\n            \"mu_spec\": [\n                (0, np.array([-4700.0, 110.0, 9.8])),\n                (350, np.array([-4600.0, 105.0, 10.0])),\n            ],\n            \"A\": [25.0, 2.0, 0.10], \"B\": [12.0, 0.8, 0.05],\n            \"p\": [31, 47, 59], \"q\": [33, 49, 61],\n        },\n        # Test case 4\n        {\n            \"N\": 600, \"w_min\": 50, \"alpha\": 0.01,\n            \"mu_spec\": (\n                np.array([-4600.0, 100.0, 10.0]),\n                np.array([-4590.0, 102.0, 10.02]),\n            ),\n            \"A\": [30.0, 5.0, 0.20], \"B\": [15.0, 2.0, 0.10],\n            \"p\": [35, 39, 63], \"q\": [37, 41, 65],\n        },\n        # Test case 5\n        {\n            \"N\": 800, \"w_min\": 50, \"alpha\": 0.01,\n            \"mu_spec\": [\n                (0, np.array([-4800.0, 99.0, 10.1])),\n                (150, np.array([-4800.0, 104.0, 10.1])),\n                (300, np.array([-4700.0, 104.0, 10.1])),\n            ],\n            \"A\": [29.0, 1.2, 0.08], \"B\": [14.5, 0.5, 0.04],\n            \"p\": [33, 45, 69], \"q\": [35, 47, 71],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        X = _generate_data(case[\"N\"], case[\"mu_spec\"], case[\"A\"], case[\"B\"], case[\"p\"], case[\"q\"])\n        last_cp = _find_last_changepoint(X, case[\"w_min\"], case[\"alpha\"])\n        results.append(last_cp)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _generate_data(N, mu_spec, A, B, p_periods, q_periods):\n    \"\"\"\n    Generates deterministic time series data based on problem specification.\n    \"\"\"\n    dim = len(A)\n    X = np.zeros((N, dim))\n    t = np.arange(N)\n\n    # Generate oscillatory part eta\n    eta = np.zeros_like(X)\n    for d in range(dim):\n        eta[:, d] = A[d] * np.sin(2 * np.pi * t / p_periods[d]) + \\\n                    B[d] * np.cos(2 * np.pi * t / q_periods[d])\n\n    # Generate mean part mu\n    mu = np.zeros_like(X)\n    if isinstance(mu_spec, list):  # Piecewise constant\n        mu_points = sorted(mu_spec, key=lambda x: x[0])\n        mu_idx_map = np.zeros(N, dtype=int)\n        for i, (start_idx, _) in enumerate(mu_points[1:], 1):\n            mu_idx_map[start_idx:] = i\n        \n        for i in range(N):\n            mu[i, :] = mu_points[mu_idx_map[i]][1]\n\n    else:  # Linear drift\n        mu0, muN_1 = mu_spec\n        for i in range(N):\n             mu[i, :] = mu0 + (i / (N - 1)) * (muN_1 - mu0)\n\n    X = mu + eta\n    return X\n\n\ndef _find_last_changepoint(X, w_min, alpha):\n    \"\"\"\n    Finds the last significant change point in the multivariate time series X.\n    This function wraps the main recursive search logic.\n    \"\"\"\n    N, p = X.shape\n    memo = {}\n\n    def _recursive_search(start, end):\n        \"\"\"\n        Recursively searches for the last change point in the segment [start, end).\n        \"\"\"\n        if (start, end) in memo:\n            return memo[(start, end)]\n\n        # Base case: segment is too small to split\n        if end - start  2 * w_min:\n            return 0\n\n        # Define search range for the split point k\n        k_range = range(start + w_min, end - w_min + 1)\n        if not k_range:\n            return 0\n\n        best_k = -1\n        max_f_stat = -1.0\n        \n        # Find the split point k that maximizes the F-statistic\n        for k in k_range:\n            n1 = k - start\n            n2 = end - k\n            \n            X1 = X[start:k]\n            X2 = X[k:end]\n\n            mean1 = np.mean(X1, axis=0)\n            mean2 = np.mean(X2, axis=0)\n\n            # Using ddof=1 for unbiased sample covariance\n            S1 = np.cov(X1, rowvar=False, ddof=1)\n            S2 = np.cov(X2, rowvar=False, ddof=1)\n            \n            # Pooled covariance matrix\n            Spool = ((n1 - 1) * S1 + (n2 - 1) * S2) / (n1 + n2 - 2)\n\n            try:\n                Spool_inv = np.linalg.inv(Spool)\n            except np.linalg.LinAlgError:\n                # This should not happen with the given data and w_min.\n                continue\n            \n            delta_mean = mean1 - mean2\n            \n            # Hotelling's T-squared statistic\n            t2_stat = (n1 * n2) / (n1 + n2) * (delta_mean.T @ Spool_inv @ delta_mean)\n            \n            # Corresponding F-statistic\n            f_stat = t2_stat * (n1 + n2 - p - 1) / ((n1 + n2 - 2) * p)\n\n            if f_stat > max_f_stat:\n                max_f_stat = f_stat\n                best_k = k\n        \n        if best_k == -1: # No valid split was found\n             memo[(start, end)] = 0\n             return 0\n\n        # Check significance of the most likely change point\n        dfn = p\n        dfd = (end - start) - p - 1 # n1 + n2 - p - 1\n        f_crit = f.ppf(1 - alpha, dfn=dfn, dfd=dfd)\n\n        if max_f_stat > f_crit:\n            # Change is significant. Search for another one after it.\n            later_cp = _recursive_search(best_k, end)\n            if later_cp > 0:\n                result = later_cp\n            else:\n                result = best_k\n        else:\n            # No significant change found in this segment\n            result = 0\n        \n        memo[(start, end)] = result\n        return result\n\n    return _recursive_search(0, N)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}