{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of the radius of gyration, we begin with a foundational exercise that bridges the discrete definition with the continuous limit. This practice challenges you to derive the radius of gyration for an idealized one-dimensional object, a rigid rod, directly from first principles. By working through this derivation , you will solidify your grasp of the underlying calculus and explore how this intrinsic measure of size is independent of the dimensionality of the space in which the object is embedded.",
            "id": "3440358",
            "problem": "Consider a rigid, straight rod of length $L$ with negligible cross-sectional thickness and uniform mass per unit length, embedded in $d$-dimensional Euclidean space $\\mathbb{R}^{d}$. In Molecular Dynamics (MD), the mass radius of gyration $R_{g}$ of a body is defined as the square root of the mass-weighted mean of the squared Euclidean distance of all mass elements from the center of mass.\n\nStarting from this definition and first principles of continuum mechanics (treating the mass distribution as a continuous line density along the rod), compute the exact expression for the radius of gyration $R_{g}$ of the rod in terms of $L$. Then, provide a principled argument as to whether $R_{g}$ depends on the embedding dimension $d$ for such a rod, making clear the assumptions required for your conclusion.\n\nExpress your final answer symbolically in terms of $L$ only. No numerical rounding is required, and do not include units in your final expression.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and objective, presenting a standard problem in classical mechanics that requires the application of integral calculus to a continuous mass distribution. The necessary information is provided, and the terms are unambiguous.\n\nWe begin by formalizing the definition of the mass radius of gyration, $R_g$. For a continuous body of total mass $M$, the squared radius of gyration is defined as the mass-weighted average of the squared Euclidean distance of each mass element $dm$ from the body's center of mass, $\\mathbf{r}_{cm}$. Mathematically, this is expressed as:\n$$\nR_g^2 = \\frac{1}{M} \\int_{\\text{body}} |\\mathbf{r} - \\mathbf{r}_{cm}|^2 \\, dm\n$$\nwhere $\\mathbf{r}$ is the position vector of the mass element $dm$.\n\nThe problem considers a rigid, straight rod of length $L$ with a uniform mass per unit length, which we denote as $\\lambda$. The total mass of the rod is therefore $M = \\lambda L$. Since the rod is treated as a one-dimensional object with negligible thickness, the mass element $dm$ can be expressed as $\\lambda \\, ds$, where $ds$ is an element of arc length along the rod.\n\nTo facilitate the calculation, we can place the rod in a coordinate system within the $d$-dimensional Euclidean space $\\mathbb{R}^d$. Let us align the rod with the first coordinate axis, which we can call the $x$-axis. We conveniently place the center of the rod at the origin of the coordinate system. In this frame, the rod extends from $x = -L/2$ to $x = +L/2$. A point on the rod is described by the position vector $\\mathbf{r} = (x, 0, \\dots, 0)$, where $x \\in [-L/2, L/2]$.\n\nFirst, we must determine the center of mass, $\\mathbf{r}_{cm}$. For a body with uniform density, the center of mass coincides with the geometric center. By placing the center of the rod at the origin, we anticipate $\\mathbf{r}_{cm} = \\mathbf{0}$. We can verify this formally:\n$$\n\\mathbf{r}_{cm} = \\frac{1}{M} \\int_{-L/2}^{L/2} \\mathbf{r}(x) \\, dm = \\frac{1}{\\lambda L} \\int_{-L/2}^{L/2} (x, 0, \\dots, 0) (\\lambda \\, dx)\n$$\nThe integral of the vector is the vector of the integrals of its components. The only non-zero component to integrate is the first one:\n$$\n\\frac{1}{L} \\int_{-L/2}^{L/2} x \\, dx = \\frac{1}{L} \\left[ \\frac{x^2}{2} \\right]_{-L/2}^{L/2} = \\frac{1}{2L} \\left( \\left(\\frac{L}{2}\\right)^2 - \\left(-\\frac{L}{2}\\right)^2 \\right) = \\frac{1}{2L} \\left( \\frac{L^2}{4} - \\frac{L^2}{4} \\right) = 0\n$$\nAll other components are integrals of $0$, which are $0$. Thus, $\\mathbf{r}_{cm} = (0, 0, \\dots, 0) = \\mathbf{0}$, as expected.\n\nNow, we can compute $R_g^2$. The vector from the center of mass to a point on the rod is $\\mathbf{r} - \\mathbf{r}_{cm} = \\mathbf{r}(x) - \\mathbf{0} = (x, 0, \\dots, 0)$. The squared Euclidean distance is:\n$$\n|\\mathbf{r} - \\mathbf{r}_{cm}|^2 = x^2 + 0^2 + \\dots + 0^2 = x^2\n$$\nSubstituting this into the definition for $R_g^2$:\n$$\nR_g^2 = \\frac{1}{M} \\int_{-L/2}^{L/2} x^2 \\, dm = \\frac{1}{\\lambda L} \\int_{-L/2}^{L/2} x^2 (\\lambda \\, dx)\n$$\nThe constant linear density $\\lambda$ cancels out:\n$$\nR_g^2 = \\frac{1}{L} \\int_{-L/2}^{L/2} x^2 \\, dx\n$$\nWe evaluate the definite integral:\n$$\nR_g^2 = \\frac{1}{L} \\left[ \\frac{x^3}{3} \\right]_{-L/2}^{L/2} = \\frac{1}{3L} \\left[ x^3 \\right]_{-L/2}^{L/2} = \\frac{1}{3L} \\left( \\left(\\frac{L}{2}\\right)^3 - \\left(-\\frac{L}{2}\\right)^3 \\right)\n$$\n$$\nR_g^2 = \\frac{1}{3L} \\left( \\frac{L^3}{8} - \\left(-\\frac{L^3}{8}\\right) \\right) = \\frac{1}{3L} \\left( \\frac{L^3}{8} + \\frac{L^3}{8} \\right) = \\frac{1}{3L} \\left( \\frac{2L^3}{8} \\right) = \\frac{1}{3L} \\left( \\frac{L^3}{4} \\right) = \\frac{L^2}{12}\n$$\nThe radius of gyration, $R_g$, is the square root of this value:\n$$\nR_g = \\sqrt{\\frac{L^2}{12}} = \\frac{L}{\\sqrt{12}} = \\frac{L}{2\\sqrt{3}}\n$$\n\nRegarding the second part of the problem, we must provide a principled argument as to whether $R_g$ depends on the embedding dimension $d$.\n\nThe calculation above shows that the final expression for $R_g$ depends only on the length $L$. This result is independent of the dimension $d$ of the embedding space, provided $d \\ge 1$. The argument relies on the following key points, which are based on the problem statement:\n1.  **Intrinsic Dimensionality**: The object is a \"rigid, straight rod\" with \"negligible cross-sectional thickness\". This means it is fundamentally a one-dimensional object (a line segment).\n2.  **Coordinate System Invariance**: Irrespective of the value of $d$ (for $d \\ge 1$), we can always define a coordinate system where the one-dimensional rod lies entirely along a single axis. The orientation of the rod in the larger space does not affect its intrinsic properties, including the mass distribution relative to its own center.\n3.  **Euclidean Distance**: The definition of $R_g$ uses the squared Euclidean distance, $|\\mathbf{v}|^2 = \\sum_{i=1}^d v_i^2$. When we align the rod (centered at the origin) with the first axis, the position vector of any point on the rod is $\\mathbf{r} = (x, 0, \\dots, 0)$, and the center of mass is $\\mathbf{r}_{cm} = \\mathbf{0}$. The distance-squared term $|\\mathbf{r} - \\mathbf{r}_{cm}|^2$ becomes $x^2$. The other $d-1$ spatial dimensions contribute nothing to this distance calculation, because the coordinates along these dimensions are always zero for every point on the rod.\n4.  **Integration Domain**: The integration is performed over the mass distribution of the rod, which is confined to a one-dimensional interval of length $L$. The dimensionality of the embedding space does not alter the domain or the integrand.\n\nTherefore, the derivation of $R_g^2 = L^2/12$ is general. The structure of the Euclidean distance formula and the one-dimensional nature of the rod ensure that all components of the position vectors corresponding to dimensions other than the one along the rod are zero, and thus they do not contribute to the integral. The calculation depends solely on the mass distribution along the length $L$, which is an intrinsic property of the rod, not of the space it occupies. The radius of gyration $R_g$ for a rigid, straight, uniform rod is independent of the embedding dimension $d$.\n\nThe final symbolic expression for the radius of gyration is obtained by simplifying the radical.\n$$\nR_g = \\frac{L}{2\\sqrt{3}}\n$$\nThis expression can be rationalized to $\\frac{\\sqrt{3}L}{6}$, but the form $\\frac{L}{2\\sqrt{3}}$ is equally valid and directly follows from the derivation.",
            "answer": "$$\\boxed{\\frac{L}{2\\sqrt{3}}}$$"
        },
        {
            "introduction": "Moving from pure theory to computational practice, we now address a critical challenge in molecular dynamics: the correct calculation of $R_g^2$ in periodic systems. This hands-on coding exercise  requires you to implement and compare different computational strategies, empirically demonstrating the pitfalls of naively applying the minimum image convention. Successfully completing this task will equip you to avoid common systematic errors in simulation analysis and to validate your computational tools.",
            "id": "3440335",
            "problem": "Design and implement a program that constructs three finite point configurations inside a three-dimensional periodic cubic box and computes the squared radius of gyration in two mathematically equivalent ways, then assesses when periodic boundary conditions invalidate the pairwise-distance form under a minimum-image convention. The base of the derivation must be the definition of the center of mass, Euclidean norms, and the structure of periodic lattices. You must not rely on any specialized domain shortcuts beyond these foundational elements.\n\nDefinitions to be used:\n- The center of mass position is defined as $\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i$ for $N$ points with positions $\\mathbf{r}_i \\in \\mathbb{R}^3$.\n- The squared radius of gyration is defined by the centered second moment as $R_g^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2$.\n- The pairwise-distance identity to be verified is $R_g^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2$, under the condition that all $\\mathbf{r}_i$ are represented in a single Euclidean embedding.\n\nIn a cubic periodic box of side length $L$, wrapped coordinates are defined modulo $L$ in each dimension. The minimum-image convention replaces any difference vector $\\Delta \\mathbf{r}$ by $\\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$ applied componentwise, which yields the nearest periodic image separation. Under periodic boundary conditions, unwrapping a connected chain of points can be performed by integrating the minimum-image differences along the connectivity, yielding a single consistent embedding $\\{\\tilde{\\mathbf{r}}_i\\}$ for the chain.\n\nYour program must:\n- Construct three test configurations inside a periodic cubic box of side length $L$ measured in nanometers, and compute all outputs in square nanometers.\n- For each configuration, compute three quantities:\n  - $R_{g,\\mathrm{cm}}^2$ from the unwrapped coordinates via the centered definition.\n  - $R_{g,\\mathrm{pair,unwrapped}}^2$ from the unwrapped coordinates via the pairwise-distance identity.\n  - $R_{g,\\mathrm{pair,MIC}}^2$ from the wrapped coordinates by applying the minimum-image convention to each pairwise difference independently.\n- Diagnose whether the minimum-image convention preserves the pairwise form by checking a sufficient condition: the span of the unwrapped configuration in each Cartesian dimension is strictly less than $L/2$. Concretely, compute the unwrapped bounding-box edge lengths $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$ for $\\alpha \\in \\{x,y,z\\}$ and set a boolean flag $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha < L/2 - \\varepsilon)$ for a small tolerance $\\varepsilon$.\n- Report the absolute difference $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2\\rvert$.\n\nImplement the following test suite, where all positions are in nanometers and the final outputs must be expressed in square nanometers:\n- Test case $1$ (compact Gaussian random walk, “happy path”): $N=32$, $L=10.0$, Gaussian steps with standard deviation $\\sigma=0.2$ along each Cartesian component, starting at $\\mathbf{r}_0 = (1.0,2.0,3.0)$. Generate steps with a fixed pseudorandom number generator seed $\\mathrm{seed}=12345$ and wrap the resulting positions into the box by componentwise modulo $L$.\n- Test case $2$ (highly extended straight chain, failure of minimum-image pairwise form): $N=64$, $L=10.0$, straight line steps of magnitude $d=0.45$ along the $x$ axis, starting at $\\mathbf{r}_0=(0.1,0.2,0.3)$, then wrapped into the box by componentwise modulo $L$.\n- Test case $3$ (near-boundary compact bimodal cluster, boundary condition): $N=20$, $L=10.0$, two clusters of $10$ points each. The first cluster is centered at $(1.0,1.0,1.0)$, the second at $(1.0 + L/2 - \\epsilon, 1.0, 1.0)$ with $\\epsilon=0.05$, both with independent Gaussian perturbations of standard deviation $\\sigma=0.01$ applied to each component. Use $\\mathrm{seed}=4242$ for the perturbations, then wrap all positions into the box by componentwise modulo $L$. For unwrapping connectivity, order the points by their array index, thus forming a single chain whose edges connect consecutive indices.\n\nFor all cases, use the same unwrapping rule: construct unwrapped coordinates $\\tilde{\\mathbf{r}}_i$ by setting $\\tilde{\\mathbf{r}}_0$ equal to the wrapped $\\mathbf{r}_0$ and, for $i\\ge 1$, updating $\\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1})$ componentwise, where $\\mathrm{MIC}(\\cdot)$ applies the minimum-image convention using the box length $L$.\n\nNumerical details and units:\n- Express all squared radius of gyration values in $\\mathrm{nm}^2$.\n- Use a small tolerance $\\varepsilon = 10^{-9}$ in the $\\mathrm{MIC\\_valid}$ criterion.\n- For reporting, round all floating-point outputs to $6$ decimal places.\n\nRequired final output format:\n- Your program must produce a single line containing a list of per-test-case results, where each test case contributes a list of five elements in the order $[R_{g,\\mathrm{cm}}^2, R_{g,\\mathrm{pair,unwrapped}}^2, R_{g,\\mathrm{pair,MIC}}^2, \\Delta_{\\mathrm{MIC}}, \\mathrm{MIC\\_valid}]$.\n- The final printed line must therefore look like a single Python-style list of lists, for example $[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3]]$, where $a_k,b_k,c_k,d_k$ are floats in $\\mathrm{nm}^2$ rounded to $6$ decimals and $e_k$ is a boolean.",
            "solution": "The problem requires the implementation of a program to compute the squared radius of gyration, $R_g^2$, for three distinct point configurations within a three-dimensional periodic cubic box. The core of the task is to compare the results from two different computational formulas for $R_g^2$ under periodic boundary conditions (PBC) and to identify a sufficient condition under which they are equivalent.\n\n### 1. Theoretical Foundation: Radius of Gyration\n\nThe squared radius of gyration, $R_g^2$, is a measure of the spatial extent of a set of points. For a collection of $N$ points with position vectors $\\{\\mathbf{r}_i\\}_{i=1}^N$ in Euclidean space, it is defined via the second moment of the positions with respect to their center of mass, $\\mathbf{R}_{\\mathrm{cm}}$.\n\nThe center of mass is given by:\n$$\n\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i\n$$\nThe primary definition of $R_g^2$, based on the mean squared distance from the center of mass, is:\n$$\nR_{g,\\mathrm{cm}}^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2\n$$\nAn alternative, mathematically equivalent formula expresses $R_g^2$ in terms of the mean squared distance between all pairs of points:\n$$\nR_{g,\\mathrm{pair}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2\n$$\nThe equivalence of these two expressions in standard Euclidean space can be shown by expanding the terms. This equivalence serves as a crucial validation for any implementation.\n\n### 2. Periodic Boundary Conditions and the Minimum Image Convention\n\nIn computational simulations, systems are often modeled within a periodic box to approximate an infinite medium. For a cubic box of side length $L$, a point at position $\\mathbf{r}=(x,y,z)$ is equivalent to all points $\\mathbf{r} + (n_x L, n_y L, n_z L)$ for any integers $(n_x, n_y, n_z)$.\n\nThis periodicity complicates the calculation of distances. The distance between two points $\\mathbf{r}_i$ and $\\mathbf{r}_j$ is typically taken to be the distance between their closest periodic images. This is calculated using the minimum image convention (MIC). For a displacement vector $\\Delta \\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$, the minimum image displacement is found by applying the function $\\mathrm{MIC}(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$ to each Cartesian component. This maps each component of the displacement into the interval $[-L/2, L/2]$.\n\n### 3. Comparing Computational Approaches for $R_g^2$ under PBC\n\nThe problem investigates two distinct approaches to calculating $R_g^2$ in a periodic system:\n\n1.  **Reference Method (Unwrapped Coordinates)**: A connected structure (like a polymer chain) can be \"unwrapped\" to create a single, continuous representation in Euclidean space, $\\{\\tilde{\\mathbf{r}}_i\\}$. This is achieved by integrating the minimum-image displacements along the chain's connectivity, starting from a reference point. For a chain ordered by index $i$, the unwrapped coordinates $\\tilde{\\mathbf{r}}_i$ are reconstructed as:\n    $$\n    \\tilde{\\mathbf{r}}_0 = \\mathbf{r}_0 \\quad (\\text{the wrapped coordinate})\n    $$\n    $$\n    \\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1}) \\quad \\text{for } i \\ge 1\n    $$\n    Once these unwrapped coordinates $\\{\\tilde{\\mathbf{r}}_i\\}$ are obtained, we can compute the true $R_g^2$ using either the center-of-mass formula ($R_{g,\\mathrm{cm}}^2$) or the pairwise formula ($R_{g,\\mathrm{pair,unwrapped}}^2$). These two must agree, providing a self-consistency check.\n\n2.  **Approximate Method (Pairwise MIC)**: A computationally simpler but potentially incorrect approach is to use the wrapped coordinates $\\{\\mathbf{r}_i\\}$ directly in the pairwise formula, but apply the MIC to every pairwise difference:\n    $$\n    R_{g,\\mathrm{pair,MIC}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_j)\\rVert^2\n    $$\n\nThe key question is under what conditions $R_{g,\\mathrm{cm}}^2 = R_{g,\\mathrm{pair,MIC}}^2$. The equality holds if and only if for every pair $(i, j)$, the true displacement vector $\\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ is identical to its minimum image. This is true if every component of the true displacement vector has a magnitude less than $L/2$. A sufficient (but not necessary) condition for this is that the entire object is contained within a volume smaller than the primary simulation cell. Specifically, the span of the unwrapped object in each Cartesian dimension $\\alpha \\in \\{x,y,z\\}$, defined as $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$, must be less than $L/2$. The program will test the condition $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha < L/2 - \\varepsilon)$ for a small tolerance $\\varepsilon$.\n\n### 4. Algorithmic Design and Test Cases\n\nThe program proceeds by first generating coordinates for three specific test cases. For each case, it obtains a set of \"ideal\" coordinates in Euclidean space, which are then wrapped into the periodic box to yield the input coordinates $\\{\\mathbf{r}_i\\}$. Then, the full analysis is performed.\n\n*   **Test Case 1 (Compact Gaussian Walk)**: A $32$-particle random walk with small steps ($\\sigma=0.2$ nm) inside a $L=10.0$ nm box. The resulting structure is expected to be compact, satisfying the validity condition ($s_\\alpha < L/2$). Thus, we predict $R_{g,\\mathrm{cm}}^2 \\approx R_{g,\\mathrm{pair,MIC}}^2$.\n*   **Test Case 2 (Extended Straight Chain)**: A $64$-particle straight line with step size $d=0.45$ nm. The total length is $(64-1) \\times 0.45 \\approx 28.35$ nm, which is much larger than $L/2=5.0$ nm. This case is designed to violate the validity condition, and we predict $R_{g,\\mathrm{cm}}^2 \\neq R_{g,\\mathrm{pair,MIC}}^2$.\n*   **Test Case 3 (Bimodal Cluster on Boundary)**: Two $10$-particle clusters are placed such that their centers are separated by $L/2-\\epsilon$ along one axis. The total span will be very close to, but slightly less than, $L/2$. This case tests the boundary of the validity condition, where we expect the MIC-based pairwise calculation to remain valid.\n\nFor each case, the program executes the following steps:\n1.  Generate the set of wrapped coordinates $\\{\\mathbf{r}_i\\}$ according to the case specification.\n2.  Construct the unwrapped coordinates $\\{\\tilde{\\mathbf{r}}_i\\}$ using the iterative unwrapping algorithm.\n3.  Calculate $R_{g,\\mathrm{cm}}^2$ from $\\{\\tilde{\\mathbf{r}}_i\\}$ using the center-of-mass definition. This is the ground truth.\n4.  Calculate $R_{g,\\mathrm{pair,unwrapped}}^2$ from $\\{\\tilde{\\mathbf{r}}_i\\}$ using the pairwise definition, as a cross-check.\n5.  Calculate $R_{g,\\mathrm{pair,MIC}}^2$ from the wrapped coordinates $\\{\\mathbf{r}_i\\}$ and the pairwise MIC formula.\n6.  Compute the absolute difference $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2 \\rvert$.\n7.  Evaluate the boolean flag $\\mathrm{MIC\\_valid}$ based on the span of the unwrapped coordinates.\n8.  Report the five final quantities, with floating-point values rounded to $6$ decimal places.\n\nThis structured analysis will empirically demonstrate the principles governing the use of different $R_g^2$ formulae in periodic systems.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs three point configurations, computes the squared radius of gyration\n    in multiple ways under periodic boundary conditions, and assesses the validity\n    of the minimum-image convention pairwise shortcut.\n    \"\"\"\n    \n    # Define parameters for the three test cases as specified in the problem.\n    test_cases_params = [\n        {'case': 1, 'N': 32, 'L': 10.0, 'sigma': 0.2, 'r0': np.array([1.0, 2.0, 3.0]), 'seed': 12345},\n        {'case': 2, 'N': 64, 'L': 10.0, 'd': 0.45, 'r0': np.array([0.1, 0.2, 0.3])},\n        {'case': 3, 'N': 20, 'L': 10.0, 'sigma': 0.01, 'epsilon': 0.05, 'seed': 4242}\n    ]\n\n    all_results = []\n    \n    for params in test_cases_params:\n        L = params['L']\n        N = params['N']\n        \n        # --- 1. Generate Ideal and Wrapped Coordinates ---\n        if params['case'] == 1:\n            # Case 1: Compact Gaussian random walk\n            rng = np.random.default_rng(params['seed'])\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = rng.normal(loc=0.0, scale=params['sigma'], size=(N - 1, 3))\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n        \n        elif params['case'] == 2:\n            # Case 2: Highly extended straight chain\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = np.zeros((N - 1, 3))\n            steps[:, 0] = params['d']\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n\n        elif params['case'] == 3:\n            # Case 3: Near-boundary compact bimodal cluster\n            rng = np.random.default_rng(params['seed'])\n            N1 = 10\n            N2 = 10\n            c1 = np.array([1.0, 1.0, 1.0])\n            c2 = np.array([1.0 + L / 2.0 - params['epsilon'], 1.0, 1.0])\n            cluster1 = c1 + rng.normal(loc=0.0, scale=params['sigma'], size=(N1, 3))\n            cluster2 = c2 + rng.normal(loc=0.0, scale=params['sigma'], size=(N2, 3))\n            ideal_coords = np.vstack((cluster1, cluster2))\n\n        # Wrap the ideal coordinates into the periodic box [0, L)\n        coords_wrapped = ideal_coords % L\n\n        # --- 2. Unwrap Chain from Wrapped Coordinates ---\n        # This reconstructs a single connected image of the chain.\n        coords_unwrapped = np.zeros_like(coords_wrapped)\n        coords_unwrapped[0] = coords_wrapped[0]\n        for i in range(1, N):\n            dr_wrapped = coords_wrapped[i] - coords_wrapped[i-1]\n            # Minimum Image Convention (MIC) for the displacement vector\n            dr_mic = dr_wrapped - L * np.round(dr_wrapped / L)\n            coords_unwrapped[i] = coords_unwrapped[i-1] + dr_mic\n\n        # --- 3. Compute Rg^2 values ---\n        \n        # Rg_cm^2: From unwrapped coordinates via centered definition (the ground truth)\n        R_cm = np.mean(coords_unwrapped, axis=0)\n        rg2_cm = np.mean(np.sum((coords_unwrapped - R_cm)**2, axis=1))\n\n        # Rg_pair_unwrapped^2: From unwrapped coordinates via pairwise identity\n        # Using broadcasting for an efficient O(N^2) calculation.\n        diffs = coords_unwrapped[:, np.newaxis, :] - coords_unwrapped[np.newaxis, :, :]\n        sum_sq_dist = np.sum(diffs**2)\n        rg2_pair_unwrapped = sum_sq_dist / (2 * N**2)\n\n        # Rg_pair_MIC^2: From wrapped coordinates applying MIC to each pairwise difference\n        diffs_wrapped = coords_wrapped[:, np.newaxis, :] - coords_wrapped[np.newaxis, :, :]\n        mic_diffs = diffs_wrapped - L * np.round(diffs_wrapped / L)\n        sum_sq_dist_mic = np.sum(mic_diffs**2)\n        rg2_pair_mic = sum_sq_dist_mic / (2 * N**2)\n\n        # --- 4. Diagnose and Compare ---\n        \n        # Absolute difference between ground truth and MIC-shortcut\n        delta_mic = np.abs(rg2_cm - rg2_pair_mic)\n        \n        # Check the sufficient condition for MIC validity\n        span = np.max(coords_unwrapped, axis=0) - np.min(coords_unwrapped, axis=0)\n        epsilon = 1e-9\n        mic_valid = np.all(span  (L / 2.0 - epsilon))\n        \n        # --- 5. Collect results for this case ---\n        all_results.append([rg2_cm, rg2_pair_unwrapped, rg2_pair_mic, delta_mic, bool(mic_valid)])\n\n    # --- 6. Format and Print Final Output ---\n    # Construct the final output string exactly as specified.\n    final_output_str_list = []\n    for res in all_results:\n        # Format the four float values to 6 decimal places and get the string for the boolean.\n        formatted_res = [f\"{v:.6f}\" for v in res[:4]] + [str(res[4])]\n        s = f\"[{','.join(formatted_res)}]\"\n        final_output_str_list.append(s)\n\n    # Print the single line containing the list of lists.\n    print(f\"[{','.join(final_output_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In the final practice, we tackle a problem of significant practical importance in analyzing large-scale simulation data: computational efficiency and numerical stability. This exercise  guides you through the derivation and implementation of a 'single-pass' online algorithm for computing $R_g^2$, analogous to the renowned Welford's algorithm for variance. Mastering this technique allows for the robust analysis of data streams that are too large to fit into memory, a common scenario in modern molecular dynamics.",
            "id": "3440388",
            "problem": "You are given a stream of particle data, where each particle is specified by a nonnegative mass and a position in three-dimensional space. Using only a single pass over the stream, derive from first principles an online update scheme to compute both the mass-weighted center of mass and the mass-weighted radius of gyration squared. Your derivation must start from the fundamental definitions of center of mass and radius of gyration in classical mechanics, and proceed by algebraic manipulation that avoids forming large intermediate sums that would be numerically unstable for sequences with large dynamic range in masses or coordinates. The online scheme must be analogous in spirit to Welford’s method for variance but generalized to vector-valued, mass-weighted data in three dimensions.\n\nDefinitions to start from:\n- For particles indexed by $i \\in \\{1,\\dots,n\\}$ with masses $m_i \\ge 0$ and positions $\\mathbf{r}_i \\in \\mathbb{R}^3$, the total mass is $M_n = \\sum_{i=1}^{n} m_i$ and the mass-weighted center of mass (COM) is $\\mathbf{R}_n = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\mathbf{r}_i$ when $M_n \\gt 0$.\n- The mass-weighted radius of gyration squared is $R_{g,n}^2 = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2$ when $M_n \\gt 0$.\n\nYour task has two parts:\n1. Derive, using only the definitions above and general algebra, a one-pass update for a new particle of mass $m$ at position $\\mathbf{r}$ that updates the current total mass $M$, the current COM $\\mathbf{R}$, and an auxiliary scalar accumulator $S$ such that after processing all particles, $R_g^2 = S/M$ holds exactly in exact arithmetic when $M \\gt 0$. Your update must be well-defined for $m = 0$ and must avoid subtractive cancellation paths that would degrade numerical stability for large $M$ or large dynamic range in $\\mathbf{r}$.\n2. Implement the derived update in a program that processes the following test suite. Each test case is a sequence of $(m_i,\\mathbf{r}_i)$ values. Input units: positions are in nanometers (nm) and masses are in any consistent mass unit. Output units: report $R_g^2$ in square nanometers (nm$^2$).\n\nTest suite to implement:\n- Case A (happy path, symmetry): $[(1.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0))]$.\n- Case B (asymmetric masses in a plane): $[(2.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0)),(1.0,(0.0,1.0,0.0))]$.\n- Case C (degenerate geometry, large dynamic range): $[(1.0\\times 10^{6},(2.0,2.0,2.0)),(2.0\\times 10^{-6},(2.0,2.0,2.0)),(3.0,(2.0,2.0,2.0))]$.\n- Case D (colinear positions, varied masses): $[(1.0,(0.0,0.0,0.0)),(2.0,(2.0,0.0,0.0)),(3.0,(4.0,0.0,0.0)),(4.0,(6.0,0.0,0.0))]$.\n- Case E (single particle edge case): $[(1.23,(3.4,-5.6,7.8))]$.\n\nProgram requirements:\n- Process each case strictly in a single pass over the particles using your online update scheme, without storing all positions for batch recomputation.\n- For each case, compute $R_g^2$ in nm$^2$.\n- Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be a floating-point number rounded to exactly $6$ decimal places.\n\nAssumptions and constraints:\n- You may assume all masses are finite and nonnegative and all coordinates are finite.\n- If the total mass is zero, $R_g^2$ is undefined; however, the provided test cases avoid this condition.\n- Angles are not used in this problem, so no angle unit is required.\n\nDeliverables:\n- A derivation of the online update from the definitions.\n- A complete, runnable program that implements the derived update and applies it to the specified test suite, outputting a single line with the formatted results.",
            "solution": "The problem is well-posed, scientifically grounded, and objective. It presents a standard task in computational physics: the derivation and implementation of a numerically stable, single-pass algorithm for calculating the radius of gyration of a system of particles. The definitions provided are standard in classical mechanics, and the requirement for a Welford-like online update is a well-defined constraint in numerical analysis. The problem is valid and admits a unique, correct solution.\n\nWe are tasked with deriving an online, single-pass update scheme for the mass-weighted center of mass, $\\mathbf{R}$, and the mass-weighted radius of gyration squared, $R_g^2$. The derivation must begin from the provided first principles and yield a numerically stable algorithm.\n\nLet us denote the state of the system after processing $n$ particles by the triplet $(M_n, \\mathbf{R}_n, S_n)$, where $M_n$ is the total mass, $\\mathbf{R}_n$ is the center of mass, and $S_n$ is an auxiliary accumulator. The definitions for the first $n$ particles with masses $m_i$ and positions $\\mathbf{r}_i$ are:\nTotal mass:\n$$ M_n = \\sum_{i=1}^{n} m_i $$\nMass-weighted center of mass (COM):\n$$ \\mathbf{R}_n = \\frac{1}{M_n} \\sum_{i=1}^{n} m_i \\mathbf{r}_i $$\nThe mass-weighted radius of gyration squared is given by $R_{g,n}^2 = S_n/M_n$, where $S_n$ is defined as the mass-weighted sum of squared distances from the COM:\n$$ S_n = M_n R_{g,n}^2 = \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 $$\nOur goal is to find recurrence relations for $M_{n+1}$, $\\mathbf{R}_{n+1}$, and $S_{n+1}$ in terms of $M_n$, $\\mathbf{R}_n$, $S_n$, and the properties of the new $(n+1)$-th particle, which has mass $m$ and position $\\mathbf{r}$.\n\n1.  **Update for Total Mass ($M_n$)**\n    The update rule for the total mass is derived directly from its definition:\n    $$ M_{n+1} = \\sum_{i=1}^{n+1} m_i = \\left(\\sum_{i=1}^{n} m_i\\right) + m_{n+1} $$\n    Letting $m_{n+1}=m$, the update rule is:\n    $$ M_{n+1} = M_n + m $$\n\n2.  **Update for Center of Mass ($\\mathbf{R}_n$)**\n    The COM for $n+1$ particles is:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} \\sum_{i=1}^{n+1} m_i \\mathbf{r}_i = \\frac{1}{M_{n+1}} \\left( \\sum_{i=1}^{n} m_i \\mathbf{r}_i + m\\mathbf{r} \\right) $$\n    Using the definition $\\sum_{i=1}^{n} m_i \\mathbf{r}_i = M_n \\mathbf{R}_n$:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{r}) $$\n    To obtain a form analogous to Welford's algorithm, which involves updates based on the deviation from the current mean, we add and subtract $m\\mathbf{R}_n$ in the numerator:\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{R}_n - m\\mathbf{R}_n + m\\mathbf{r}) = \\frac{1}{M_{n+1}} ((M_n + m)\\mathbf{R}_n + m(\\mathbf{r} - \\mathbf{R}_n)) $$\n    Since $M_{n+1} = M_n + m$:\n    $$ \\mathbf{R}_{n+1} = \\mathbf{R}_n + \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    This update rule is numerically robust as it adds a small correction term to the existing COM, mitigating potential floating-point precision loss if $\\mathbf{R}_n$ and $\\mathbf{r}$ are large but their difference is small.\n\n3.  **Update for the Auxiliary Accumulator ($S_n$)**\n    The accumulator $S_{n+1}$ is defined as:\n    $$ S_{n+1} = \\sum_{i=1}^{n+1} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 \\right) + m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2 $$\n    We must express $\\mathbf{R}_{n+1}$ in terms of $\\mathbf{R}_n$. Let $\\mathbf{\\Delta_R} = \\mathbf{R}_{n+1} - \\mathbf{R}_n = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$.\n    Consider the sum term:\n    $$ \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\sum_{i=1}^{n} m_i \\lVert (\\mathbf{r}_i - \\mathbf{R}_n) - \\mathbf{\\Delta_R} \\rVert^2 $$\n    Expanding the squared norm:\n    $$ = \\sum_{i=1}^{n} m_i \\left( \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 - 2(\\mathbf{r}_i - \\mathbf{R}_n) \\cdot \\mathbf{\\Delta_R} + \\lVert \\mathbf{\\Delta_R} \\rVert^2 \\right) $$\n    $$ = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 \\right) - 2\\mathbf{\\Delta_R} \\cdot \\left( \\sum_{i=1}^{n} m_i(\\mathbf{r}_i - \\mathbf{R}_n) \\right) + \\left( \\sum_{i=1}^{n} m_i \\right) \\lVert \\mathbf{\\Delta_R} \\rVert^2 $$\n    The first term is $S_n$. The second term is zero because $\\sum m_i(\\mathbf{r}_i - \\mathbf{R}_n) = \\sum m_i \\mathbf{r}_i - \\mathbf{R}_n \\sum m_i = M_n \\mathbf{R}_n - M_n \\mathbf{R}_n = \\mathbf{0}$. The third term is $M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$. Thus, the sum term becomes $S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$.\n\n    Now consider the new particle's term, $m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2$:\n    $$ \\mathbf{r} - \\mathbf{R}_{n+1} = \\mathbf{r} - (\\mathbf{R}_n + \\mathbf{\\Delta_R}) = (\\mathbf{r} - \\mathbf{R}_n) - \\mathbf{\\Delta_R} = (\\mathbf{r} - \\mathbf{R}_n) - \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    $$ = \\left(1 - \\frac{m}{M_{n+1}}\\right) (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_{n+1}-m}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) $$\n    The new particle's contribution to $S_{n+1}$ is:\n    $$ m \\left\\lVert \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) \\right\\rVert^2 = m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    Combining the parts:\n    $$ S_{n+1} = S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    Substitute $\\mathbf{\\Delta_R} = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$:\n    $$ S_{n+1} = S_n + M_n \\left(\\frac{m}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} \\left[ M_n m^2 + m M_n^2 \\right] $$\n    Factoring the term in brackets $M_n m(m + M_n) = M_n m M_{n+1}$:\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} (M_n m M_{n+1}) $$\n    $$ S_{n+1} = S_n + \\frac{m M_n}{M_{n+1}} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 = S_n + \\frac{m M_n}{m+M_n} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    This update rule is purely additive for non-negative masses, avoiding the subtractive cancellation inherent in the naive parallel axis theorem approach ($S_n = \\sum m_i \\lVert \\mathbf{r}_i \\rVert^2 - M_n \\lVert \\mathbf{R}_n \\rVert^2$). This form is the mass-weighted, vector generalization of Welford's algorithm for sum of squared differences.\n\n**Final Algorithm:**\n\nInitialize the state: $N = 0$ (particle count), $M = 0$, $\\mathbf{R} = \\mathbf{0}$, $S = 0$.\n\nFor each incoming particle $(m_i, \\mathbf{r}_i)$:\n1.  If $N = 0$:\n    $M \\leftarrow m_i$, $\\mathbf{R} \\leftarrow \\mathbf{r}_i$, $S \\leftarrow 0$.\n2.  Else if $m_i  0$ (the case $m_i=0$ results in no change):\n    a. Store old state variables: $M_{old} \\leftarrow M$, $\\mathbf{R}_{old} \\leftarrow \\mathbf{R}$.\n    b. Update total mass: $M \\leftarrow M_{old} + m_i$.\n    c. Update COM: $\\mathbf{R} \\leftarrow \\mathbf{R}_{old} + \\frac{m_i}{M}(\\mathbf{r}_i - \\mathbf{R}_{old})$.\n    d. Update accumulator: Let $\\mathbf{\\delta} = \\mathbf{r}_i - \\mathbf{R}_{old}$. Then $S \\leftarrow S + \\frac{m_i M_{old}}{M} (\\mathbf{\\delta} \\cdot \\mathbf{\\delta})$.\n3.  Increment particle count: $N \\leftarrow N + 1$.\n\nAfter processing all particles, if $M  0$, the mass-weighted radius of gyration squared is $R_g^2 = S/M$. For a single particle ($N=1$), $M=m_1, \\mathbf{R}=\\mathbf{r}_1, S=0$, so $R_g^2 = 0$, which is correct. For a system where all particles are at the same location, the update to $S$ is always zero, correctly yielding $R_g^2 = 0$.\nThis algorithm fulfills all requirements of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rg2_online(particles):\n    \"\"\"\n    Calculates the mass-weighted radius of gyration squared using a one-pass\n    online algorithm derived from first principles.\n\n    The algorithm is a mass-weighted, vector generalization of Welford's method.\n    It maintains three running quantities:\n    - M: Total mass\n    - R: Mass-weighted center of mass (COM)\n    - S: Mass-weighted sum of squared distances from the COM, S = M * Rg^2\n\n    The state is initialized with the first particle. For each subsequent\n    particle (m, r), the state (M, R, S) is updated.\n\n    Args:\n        particles (list of tuples): A list where each tuple contains\n                                    (mass, position_vector).\n\n    Returns:\n        float: The mass-weighted radius of gyration squared, Rg^2.\n    \"\"\"\n    if not particles:\n        return 0.0\n\n    n_particles = 0\n    total_mass = 0.0\n    com = np.zeros(3, dtype=np.float64)\n    # S is the accumulator for M * Rg^2\n    s_accumulator = 0.0\n    \n    for m, r_tuple in particles:\n        r_vec = np.array(r_tuple, dtype=np.float64)\n        \n        # Skip zero-mass particles as they don't contribute\n        if m = 0:\n            continue\n\n        n_particles += 1\n        \n        if n_particles == 1:\n            total_mass = m\n            com = r_vec\n            s_accumulator = 0.0\n        else:\n            old_mass = total_mass\n            old_com = com\n            \n            total_mass = old_mass + m\n            \n            # Update COM using the stable online formula\n            delta_r = r_vec - old_com\n            com = old_com + (m / total_mass) * delta_r\n            \n            # Update S (the M*Rg^2 accumulator) using the derived stable formula\n            # S_new = S_old + (m_old * m_new / m_total) * ||r_new - com_old||^2\n            update_term = (m * old_mass / total_mass) * np.dot(delta_r, delta_r)\n            s_accumulator += update_term\n            \n    if total_mass == 0:\n        return 0.0\n        \n    rg2 = s_accumulator / total_mass\n    return rg2\n\ndef solve():\n    \"\"\"\n    Processes a suite of test cases, each a stream of particle data,\n    to compute the radius of gyration squared in a single pass.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, symmetry\n        [(1.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0))],\n        \n        # Case B: asymmetric masses in a plane\n        [(2.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0)), (1.0, (0.0, 1.0, 0.0))],\n        \n        # Case C: degenerate geometry, large dynamic range\n        [(1.0e6, (2.0, 2.0, 2.0)), (2.0e-6, (2.0, 2.0, 2.0)), (3.0, (2.0, 2.0, 2.0))],\n\n        # Case D: colinear positions, varied masses\n        [(1.0, (0.0, 0.0, 0.0)), (2.0, (2.0, 0.0, 0.0)), (3.0, (4.0, 0.0, 0.0)), (4.0, (6.0, 0.0, 0.0))],\n        \n        # Case E: single particle edge case\n        [(1.23, (3.4, -5.6, 7.8))],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rg2_online(case)\n        results.append(result)\n\n    # Format the final output string with results rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}