{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂聚合物和生物分子的离散模型之前，将回旋半径的定义应用于一个理想化的连续体是巩固基本概念的绝佳练习。本练习  要求您从第一性原理出发，为一根均匀的刚性杆计算其回旋半径。这个过程不仅能加强您将离散求和思想推广到连续积分的能力，还能促使您思考一个物体的内在尺寸度量（如$R_g$）是否依赖于其所在空间的维度。",
            "id": "3440358",
            "problem": "考虑一根长度为$L$、横截面厚度可忽略不计、单位长度质量均匀的刚性直杆，该直杆嵌入在$d$维欧几里得空间$\\mathbb{R}^{d}$中。在分子动力学（MD）中，一个物体的质量回转半径$R_{g}$定义为所有质量元到其质心的欧几里得距离平方的质量加权平均值的平方根。\n\n从此定义出发，并根据连续介质力学的第一性原理（将质量分布视为沿杆的连续线密度），计算该杆的回转半径$R_{g}$关于$L$的精确表达式。然后，对于这样一根杆，请给出一个有理有据的论证，说明其$R_{g}$是否依赖于嵌入维度$d$，并清楚地阐明您结论所依赖的假设。\n\n您的最终答案应仅用$L$的符号表示。无需进行数值舍入，且最终表达式中不应包含单位。",
            "solution": "我们首先将质量回转半径$R_g$的定义形式化。对于一个总质量为$M$的连续体，其回转半径的平方定义为每个质量元$dm$到该物体质心$\\mathbf{r}_{cm}$的欧几里得距离平方的质量加权平均值。其数学表达式为：\n$$\nR_g^2 = \\frac{1}{M} \\int_{\\text{body}} |\\mathbf{r} - \\mathbf{r}_{cm}|^2 \\, dm\n$$\n其中$\\mathbf{r}$是质量元$dm$的位置矢量。\n\n问题考虑的是一根长度为$L$、单位长度质量均匀的刚性直杆，我们将其单位长度质量记为$\\lambda$。因此，杆的总质量为$M = \\lambda L$。由于该杆被视为厚度可忽略不计的一维物体，质量元$dm$可以表示为$\\lambda \\, ds$，其中$ds$是沿杆的弧长元。\n\n为了便于计算，我们可以将杆放置在$d$维欧几里得空间$\\mathbb{R}^d$的一个坐标系中。我们将杆与第一个坐标轴（我们称之为$x$轴）对齐，并方便地将杆的中心置于坐标系的原点。在此坐标系下，杆的范围从$x = -L/2$延伸到$x = +L/2$。杆上的一点可以通过位置矢量$\\mathbf{r} = (x, 0, \\dots, 0)$描述，其中$x \\in [-L/2, L/2]$。\n\n首先，我们必须确定质心$\\mathbf{r}_{cm}$。对于密度均匀的物体，质心与其几何中心重合。通过将杆的中心置于原点，我们预期$\\mathbf{r}_{cm} = \\mathbf{0}$。我们可以正式地验证这一点：\n$$\n\\mathbf{r}_{cm} = \\frac{1}{M} \\int_{-L/2}^{L/2} \\mathbf{r}(x) \\, dm = \\frac{1}{\\lambda L} \\int_{-L/2}^{L/2} (x, 0, \\dots, 0) (\\lambda \\, dx)\n$$\n矢量的积分等于其各分量积分所组成的矢量。唯一需要积分的非零分量是第一个：\n$$\n\\frac{1}{L} \\int_{-L/2}^{L/2} x \\, dx = \\frac{1}{L} \\left[ \\frac{x^2}{2} \\right]_{-L/2}^{L/2} = \\frac{1}{2L} \\left( \\left(\\frac{L}{2}\\right)^2 - \\left(-\\frac{L}{2}\\right)^2 \\right) = \\frac{1}{2L} \\left( \\frac{L^2}{4} - \\frac{L^2}{4} \\right) = 0\n$$\n所有其他分量都是对$0$的积分，结果为$0$。因此，$\\mathbf{r}_{cm} = (0, 0, \\dots, 0) = \\mathbf{0}$，与预期相符。\n\n现在，我们可以计算$R_g^2$。从质心到杆上一点的矢量是$\\mathbf{r} - \\mathbf{r}_{cm} = \\mathbf{r}(x) - \\mathbf{0} = (x, 0, \\dots, 0)$。其欧几里得距离的平方为：\n$$\n|\\mathbf{r} - \\mathbf{r}_{cm}|^2 = x^2 + 0^2 + \\dots + 0^2 = x^2\n$$\n将此代入$R_g^2$的定义中：\n$$\nR_g^2 = \\frac{1}{M} \\int_{-L/2}^{L/2} x^2 \\, dm = \\frac{1}{\\lambda L} \\int_{-L/2}^{L/2} x^2 (\\lambda \\, dx)\n$$\n恒定的线密度$\\lambda$被消去：\n$$\nR_g^2 = \\frac{1}{L} \\int_{-L/2}^{L/2} x^2 \\, dx\n$$\n我们计算该定积分：\n$$\nR_g^2 = \\frac{1}{L} \\left[ \\frac{x^3}{3} \\right]_{-L/2}^{L/2} = \\frac{1}{3L} \\left[ x^3 \\right]_{-L/2}^{L/2} = \\frac{1}{3L} \\left( \\left(\\frac{L}{2}\\right)^3 - \\left(-\\frac{L}{2}\\right)^3 \\right)\n$$\n$$\nR_g^2 = \\frac{1}{3L} \\left( \\frac{L^3}{8} - \\left(-\\frac{L^3}{8}\\right) \\right) = \\frac{1}{3L} \\left( \\frac{L^3}{8} + \\frac{L^3}{8} \\right) = \\frac{1}{3L} \\left( \\frac{2L^3}{8} \\right) = \\frac{1}{3L} \\left( \\frac{L^3}{4} \\right) = \\frac{L^2}{12}\n$$\n回转半径$R_g$是该值的平方根：\n$$\nR_g = \\sqrt{\\frac{L^2}{12}} = \\frac{L}{\\sqrt{12}} = \\frac{L}{2\\sqrt{3}}\n$$\n\n关于问题的第二部分，我们必须提供一个有理有据的论证，说明$R_g$是否依赖于嵌入维度$d$。\n\n上述计算表明，$R_g$的最终表达式仅依赖于长度$L$。只要$d \\ge 1$，这个结果就与嵌入空间的维度$d$无关。该论证依赖于以下几个基于问题陈述的关键点：\n1.  **内在维度**：该物体是一根“横截面厚度可忽略不计”的“刚性直杆”。这意味着它在根本上是一个一维物体（一条线段）。\n2.  **坐标系不变性**：无论$d$的值是多少（对于$d \\ge 1$），我们总可以定义一个坐标系，使得这个一维杆完全沿着单个坐标轴分布。杆在更高维度空间中的朝向不影响其内在属性，包括相对于其自身中心的质量分布。\n3.  **欧几里得距离**：$R_g$的定义使用了欧几里得距离的平方，$|\\mathbf{v}|^2 = \\sum_{i=1}^d v_i^2$。当我们将杆（中心在原点）与第一个坐标轴对齐时，杆上任意一点的位置矢量为$\\mathbf{r} = (x, 0, \\dots, 0)$，且质心为$\\mathbf{r}_{cm} = \\mathbf{0}$。距离平方项$|\\mathbf{r} - \\mathbf{r}_{cm}|^2$变为$x^2$。其他$d-1$个空间维度对此距离计算没有贡献，因为对于杆上的每一点，沿这些维度的坐标始终为零。\n4.  **积分域**：积分是在杆的质量分布上进行的，而该分布局限于一个长度为$L$的一维区间内。嵌入空间的维度既不改变积分域，也不改变被积函数。\n\n因此，$R_g^2 = L^2/12$的推导是普适的。欧几里得距离公式的结构和杆的一维性质保证了位置矢量中除杆所在维度外的所有分量均为零，因此对积分没有贡献。计算仅依赖于沿长度$L$的质量分布，这是杆的内在属性，而非其所处空间的属性。对于一根刚性、笔直、均匀的杆，其回转半径$R_g$与嵌入维度$d$无关。\n\n回转半径的最终符号表达式通过化简根式得到。\n$$\nR_g = \\frac{L}{2\\sqrt{3}}\n$$\n该表达式可以有理化为$\\frac{\\sqrt{3}L}{6}$，但$\\frac{L}{2\\sqrt{3}}$的形式同样有效，且为推导直接得出的结果。",
            "answer": "$$\\boxed{\\frac{L}{2\\sqrt{3}}}$$"
        },
        {
            "introduction": "理论公式在实际计算中的应用往往充满挑战，尤其是在处理周期性边界条件（PBC）时。虽然回旋半径的质心定义和等价的配对距离定义在数学上是相通的，但最小镜像约定（MIC）的滥用会轻易打破这种等价性，导致严重的计算错误。这个实践练习  旨在通过编写一个数值实验，让您亲手揭示这个问题，并掌握从周期性模拟数据中稳健计算$R_g^2$的正确方法，这是分子动力学数据分析的一项核心技能。",
            "id": "3440335",
            "problem": "设计并实现一个程序，该程序在三维周期性立方体盒子内构建三个有限点构型，并以两种数学上等价的方式计算回旋半径的平方，然后评估在最小镜像约定下，周期性边界条件何时会使对距离形式失效。推导的基础必须是质心的定义、欧几里得范数以及周期性晶格的结构。除了这些基础元素外，您不得依赖任何专门领域的捷径。\n\n待使用的定义：\n- 对于具有位置 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 的 $N$ 个点，质心位置定义为 $\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i$。\n- 回旋半径的平方由中心二阶矩定义为 $R_g^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2$。\n- 待验证的对距离恒等式为 $R_g^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2$，条件是所有 $\\mathbf{r}_i$ 都在单个欧几里得嵌入中表示。\n\n在边长为 $L$ 的立方周期性盒子中，包裹坐标在每个维度上都以 $L$ 为模进行定义。最小镜像约定将任何差分向量 $\\Delta \\mathbf{r}$ 替换为逐分量应用的 $\\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$，这会产生最近的周期性镜像分离。在周期性边界条件下，可以通过沿连接性积分最小镜像差分来解开一个连接的点链，从而为该链产生一个单一的一致嵌入 $\\{\\tilde{\\mathbf{r}}_i\\}$。\n\n您的程序必须：\n- 在边长为 $L$（单位为纳米）的周期性立方体盒子内构建三个测试构型，并以平方纳米为单位计算所有输出。\n- 对每个构型，计算三个量：\n  - 从解开的坐标通过中心定义计算 $R_{g,\\mathrm{cm}}^2$。\n  - 从解开的坐标通过对距离恒等式计算 $R_{g,\\mathrm{pair,unwrapped}}^2$。\n  - 通过对每个对距离独立应用最小镜像约定，从包裹坐标计算 $R_{g,\\mathrm{pair,MIC}}^2$。\n- 通过检查一个充分条件来诊断最小镜像约定是否保持对距离形式：解开构型在每个笛卡尔维度上的跨度严格小于 $L/2$。具体来说，计算解开的边界框边长 $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$（其中 $\\alpha \\in \\{x,y,z\\}$），并设置一个布尔标志 $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha  L/2 - \\varepsilon)$，其中 $\\varepsilon$ 是一个很小的容差。\n- 报告绝对差 $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2\\rvert$。\n\n实现以下测试套件，其中所有位置均以纳米为单位，最终输出必须以平方纳米表示：\n- 测试用例1（紧凑高斯随机游走，“理想路径”）：$N=32$，$L=10.0$，沿每个笛卡尔分量的高斯步长，标准差为 $\\sigma=0.2$，起始于 $\\mathbf{r}_0 = (1.0,2.0,3.0)$。使用固定的伪随机数生成器种子 $\\mathrm{seed}=12345$ 生成步长，并通过逐分量模 $L$ 将结果位置包裹到盒子中。\n- 测试用例2（高度伸展的直链，最小镜像对距离形式失效）：$N=64$，$L=10.0$，沿 $x$ 轴的步长为 $d=0.45$ 的直线步进，起始于 $\\mathbf{r}_0=(0.1,0.2,0.3)$，然后通过逐分量模 $L$ 包裹到盒子中。\n- 测试用例3（近边界紧凑双峰团簇，边界条件）：$N=20$，$L=10.0$，两个各含10个点的团簇。第一个团簇中心位于 $(1.0,1.0,1.0)$，第二个位于 $(1.0 + L/2 - \\epsilon, 1.0, 1.0)$，其中 $\\epsilon=0.05$，两者都对每个分量施加了标准差为 $\\sigma=0.01$ 的独立高斯扰动。对扰动使用 $\\mathrm{seed}=4242$，然后通过逐分量模 $L$ 将所有位置包裹到盒子中。对于解开连接性，按数组索引对点进行排序，从而形成一个其边连接连续索引的单链。\n\n对于所有情况，使用相同的解开规则：通过设置 $\\tilde{\\mathbf{r}}_0$ 等于包裹的 $\\mathbf{r}_0$ 来构建解开坐标 $\\tilde{\\mathbf{r}}_i$，并且对于 $i\\ge 1$，逐分量更新 $\\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1})$，其中 $\\mathrm{MIC}(\\cdot)$ 使用盒子长度 $L$ 应用最小镜像约定。\n\n数值细节和单位：\n- 以 $\\mathrm{nm}^2$ 表示所有回旋半径平方值。\n- 在 $\\mathrm{MIC\\_valid}$ 准则中使用一个小的容差 $\\varepsilon = 10^{-9}$。\n- 报告时，将所有浮点输出四舍五入到6位小数。\n\n要求的最终输出格式：\n- 您的程序必须生成一个单行，其中包含每个测试用例结果的列表，每个测试用例贡献一个包含五个元素的列表，顺序为 $[R_{g,\\mathrm{cm}}^2, R_{g,\\mathrm{pair,unwrapped}}^2, R_{g,\\mathrm{pair,MIC}}^2, \\Delta_{\\mathrm{MIC}}, \\mathrm{MIC\\_valid}]$。\n- 因此，最终打印的行必须看起来像一个Python风格的列表的列表，例如 $[[a_1,b_1,c_1,d_1,e_1],[a_2,b_2,c_2,d_2,e_2],[a_3,b_3,c_3,d_3,e_3]]$，其中 $a_k,b_k,c_k,d_k$ 是以 $\\mathrm{nm}^2$ 为单位、四舍五入到6位小数的浮点数，$e_k$ 是一个布尔值。",
            "solution": "这个问题要求实现一个程序，用于计算三维周期性立方体盒子内三种不同点构型的回旋半径平方 $R_g^2$。任务的核心是比较在周期性边界条件（PBC）下，由两种不同计算公式得出的 $R_g^2$ 结果，并确定一个使它们等价的充分条件。\n\n### 1. 理论基础：回旋半径\n\n回旋半径的平方 $R_g^2$ 是衡量一组点空间延展性的指标。对于欧几里得空间中 $N$ 个点的位置向量集合 $\\{\\mathbf{r}_i\\}_{i=1}^N$，它通过位置相对于其质心 $\\mathbf{R}_{\\mathrm{cm}}$ 的二阶矩来定义。\n\n质心由下式给出：\n$$\n\\mathbf{R}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{r}_i\n$$\n$R_g^2$ 的主要定义基于与质心的均方距离：\n$$\nR_{g,\\mathrm{cm}}^2 = \\frac{1}{N}\\sum_{i=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{R}_{\\mathrm{cm}}\\rVert^2\n$$\n另一种在数学上等价的公式，用所有点对之间的均方距离来表示 $R_g^2$：\n$$\nR_{g,\\mathrm{pair}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathbf{r}_i - \\mathbf{r}_j\\rVert^2\n$$\n在标准欧几里得空间中，这两种表达式的等价性可以通过展开各项来证明。这种等价性为任何实现提供了关键的验证。\n\n### 2. 周期性边界条件与最小镜像约定\n\n在计算模拟中，系统通常被建模在周期性盒子内，以近似无限介质。对于边长为 $L$ 的立方体盒子，位置 $\\mathbf{r}=(x,y,z)$ 处的点与所有点 $\\mathbf{r} + (n_x L, n_y L, n_z L)$（对于任意整数 $(n_x, n_y, n_z)$）等价。\n\n这种周期性使距离的计算变得复杂。两点 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 之间的距离通常取为其最近周期性镜像之间的距离。这通过使用最小镜像约定（MIC）来计算。对于位移向量 $\\Delta \\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$，最小镜像位移通过对每个笛卡尔分量应用函数 $\\mathrm{MIC}(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} - L \\cdot \\mathrm{round}(\\Delta \\mathbf{r}/L)$ 来找到。这将位移的每个分量映射到区间 $[-L/2, L/2]$ 中。\n\n### 3. 周期性边界条件下 $R_g^2$ 计算方法的比较\n\n该问题研究了在周期性系统中计算 $R_g^2$ 的两种不同方法：\n\n1.  **参考方法（解开坐标）**：一个连接的结构（如聚合物链）可以被“解开”，以在欧几里得空间中创建一个单一的、连续的表示 $\\{\\tilde{\\mathbf{r}}_i\\}$。这是通过从一个参考点开始，沿着链的连接性积分最小镜像位移来实现的。对于按索引 $i$ 排序的链，解开的坐标 $\\tilde{\\mathbf{r}}_i$ 重建如下：\n    $$\n    \\tilde{\\mathbf{r}}_0 = \\mathbf{r}_0 \\quad (\\text{包裹坐标})\n    $$\n    $$\n    \\tilde{\\mathbf{r}}_i = \\tilde{\\mathbf{r}}_{i-1} + \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_{i-1}) \\quad \\text{对于 } i \\ge 1\n    $$\n    一旦获得这些解开的坐标 $\\{\\tilde{\\mathbf{r}}_i\\}$，我们就可以使用质心公式（$R_{g,\\mathrm{cm}}^2$）或对距离公式（$R_{g,\\mathrm{pair,unwrapped}}^2$）来计算真实的 $R_g^2$。这两者必须一致，从而提供了一个自洽性检查。\n\n2.  **近似方法（对距离最小镜像约定）**：一种计算上更简单但可能不正确的方法是直接在对距离公式中使用包裹坐标 $\\{\\mathbf{r}_i\\}$，但对每个对距离差应用最小镜像约定：\n    $$\n    R_{g,\\mathrm{pair,MIC}}^2 = \\frac{1}{2N^2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}\\lVert \\mathrm{MIC}(\\mathbf{r}_i - \\mathbf{r}_j)\\rVert^2\n    $$\n\n关键问题是在什么条件下 $R_{g,\\mathrm{cm}}^2 = R_{g,\\mathrm{pair,MIC}}^2$。当且仅当对于每一对 $(i, j)$，真实位移向量 $\\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ 与其最小镜像相同时，等式成立。如果真实位移向量的每个分量的量值都小于 $L/2$，则此条件为真。对此，一个充分（但非必要）的条件是整个物体包含在一个比主模拟单元更小的体积内。具体来说，解开物体在每个笛卡尔维度 $\\alpha \\in \\{x,y,z\\}$ 上的跨度，定义为 $s_\\alpha = \\max_i \\tilde{r}_{i,\\alpha} - \\min_i \\tilde{r}_{i,\\alpha}$，必须小于 $L/2$。程序将测试条件 $\\mathrm{MIC\\_valid} = \\bigwedge_{\\alpha}(s_\\alpha  L/2 - \\varepsilon)$，其中 $\\varepsilon$ 是一个很小的容差。\n\n### 4. 算法设计与测试用例\n\n程序首先为三个特定的测试用例生成坐标。对于每个用例，它获得一组在欧几里得空间中的“理想”坐标，然后将其包裹到周期性盒子中，得到输入坐标 $\\{\\mathbf{r}_i\\}$。接着，进行完整的分析。\n\n*   **测试用例1（紧凑高斯游走）**：在 $L=10.0$ nm 的盒子内，一个32个粒子的随机游走，步长很小（$\\sigma=0.2$ nm）。产生的结构预期是紧凑的，满足有效性条件（$s_\\alpha  L/2$）。因此，我们预测 $R_{g,\\mathrm{cm}}^2 \\approx R_{g,\\mathrm{pair,MIC}}^2$。\n*   **测试用例2（伸展直链）**：一个64个粒子的直线，步长为 $d=0.45$ nm。总长度为 $(64-1) \\times 0.45 \\approx 28.35$ nm，远大于 $L/2=5.0$ nm。此用例旨在违反有效性条件，我们预测 $R_{g,\\mathrm{cm}}^2 \\neq R_{g,\\mathrm{pair,MIC}}^2$。\n*   **测试用例3（边界上的双峰团簇）**：两个含10个粒子的团簇被放置，使其中心沿一个轴的距离为 $L/2-\\epsilon$。总跨度将非常接近但略小于 $L/2$。此用例测试了有效性条件的边界，我们预期基于最小镜像约定的对距离计算仍然有效。\n\n对于每个用例，程序执行以下步骤：\n1.  根据用例规范生成包裹坐标集 $\\{\\mathbf{r}_i\\}$。\n2.  使用迭代解开算法构建解开坐标 $\\{\\tilde{\\mathbf{r}}_i\\}$。\n3.  使用质心定义从 $\\{\\tilde{\\mathbf{r}}_i\\}$ 计算 $R_{g,\\mathrm{cm}}^2$。这是基准真相。\n4.  使用对距离定义从 $\\{\\tilde{\\mathbf{r}}_i\\}$ 计算 $R_{g,\\mathrm{pair,unwrapped}}^2$，作为交叉检验。\n5.  从包裹坐标 $\\{\\mathbf{r}_i\\}$ 和对距离最小镜像约定公式计算 $R_{g,\\mathrm{pair,MIC}}^2$。\n6.  计算绝对差 $\\Delta_{\\mathrm{MIC}} = \\lvert R_{g,\\mathrm{cm}}^2 - R_{g,\\mathrm{pair,MIC}}^2 \\rvert$。\n7.  根据解开坐标的跨度评估布尔标志 $\\mathrm{MIC\\_valid}$。\n8.  报告五个最终量，浮点值四舍五入到6位小数。\n\n这种结构化的分析将通过经验证明在周期性系统中使用不同 $R_g^2$ 公式的指导原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs three point configurations, computes the squared radius of gyration\n    in multiple ways under periodic boundary conditions, and assesses the validity\n    of the minimum-image convention pairwise shortcut.\n    \"\"\"\n    \n    # Define parameters for the three test cases as specified in the problem.\n    test_cases_params = [\n        {'case': 1, 'N': 32, 'L': 10.0, 'sigma': 0.2, 'r0': np.array([1.0, 2.0, 3.0]), 'seed': 12345},\n        {'case': 2, 'N': 64, 'L': 10.0, 'd': 0.45, 'r0': np.array([0.1, 0.2, 0.3])},\n        {'case': 3, 'N': 20, 'L': 10.0, 'sigma': 0.01, 'epsilon': 0.05, 'seed': 4242}\n    ]\n\n    all_results = []\n    \n    for params in test_cases_params:\n        L = params['L']\n        N = params['N']\n        \n        # --- 1. Generate Ideal and Wrapped Coordinates ---\n        if params['case'] == 1:\n            # Case 1: Compact Gaussian random walk\n            rng = np.random.default_rng(params['seed'])\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = rng.normal(loc=0.0, scale=params['sigma'], size=(N - 1, 3))\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n        \n        elif params['case'] == 2:\n            # Case 2: Highly extended straight chain\n            r0 = params['r0']\n            ideal_coords = np.zeros((N, 3))\n            ideal_coords[0] = r0\n            steps = np.zeros((N - 1, 3))\n            steps[:, 0] = params['d']\n            ideal_coords[1:] = r0 + np.cumsum(steps, axis=0)\n\n        elif params['case'] == 3:\n            # Case 3: Near-boundary compact bimodal cluster\n            rng = np.random.default_rng(params['seed'])\n            N1 = 10\n            N2 = 10\n            c1 = np.array([1.0, 1.0, 1.0])\n            c2 = np.array([1.0 + L / 2.0 - params['epsilon'], 1.0, 1.0])\n            cluster1 = c1 + rng.normal(loc=0.0, scale=params['sigma'], size=(N1, 3))\n            cluster2 = c2 + rng.normal(loc=0.0, scale=params['sigma'], size=(N2, 3))\n            ideal_coords = np.vstack((cluster1, cluster2))\n\n        # Wrap the ideal coordinates into the periodic box [0, L)\n        coords_wrapped = ideal_coords % L\n\n        # --- 2. Unwrap Chain from Wrapped Coordinates ---\n        # This reconstructs a single connected image of the chain.\n        coords_unwrapped = np.zeros_like(coords_wrapped)\n        coords_unwrapped[0] = coords_wrapped[0]\n        for i in range(1, N):\n            dr_wrapped = coords_wrapped[i] - coords_wrapped[i-1]\n            # Minimum Image Convention (MIC) for the displacement vector\n            dr_mic = dr_wrapped - L * np.round(dr_wrapped / L)\n            coords_unwrapped[i] = coords_unwrapped[i-1] + dr_mic\n\n        # --- 3. Compute Rg^2 values ---\n        \n        # Rg_cm^2: From unwrapped coordinates via centered definition (the ground truth)\n        R_cm = np.mean(coords_unwrapped, axis=0)\n        rg2_cm = np.mean(np.sum((coords_unwrapped - R_cm)**2, axis=1))\n\n        # Rg_pair_unwrapped^2: From unwrapped coordinates via pairwise identity\n        # Using broadcasting for an efficient O(N^2) calculation.\n        diffs = coords_unwrapped[:, np.newaxis, :] - coords_unwrapped[np.newaxis, :, :]\n        sum_sq_dist = np.sum(diffs**2)\n        rg2_pair_unwrapped = sum_sq_dist / (2 * N**2)\n\n        # Rg_pair_MIC^2: From wrapped coordinates applying MIC to each pairwise difference\n        diffs_wrapped = coords_wrapped[:, np.newaxis, :] - coords_wrapped[np.newaxis, :, :]\n        mic_diffs = diffs_wrapped - L * np.round(diffs_wrapped / L)\n        sum_sq_dist_mic = np.sum(mic_diffs**2)\n        rg2_pair_mic = sum_sq_dist_mic / (2 * N**2)\n\n        # --- 4. Diagnose and Compare ---\n        \n        # Absolute difference between ground truth and MIC-shortcut\n        delta_mic = np.abs(rg2_cm - rg2_pair_mic)\n        \n        # Check the sufficient condition for MIC validity\n        span = np.max(coords_unwrapped, axis=0) - np.min(coords_unwrapped, axis=0)\n        epsilon = 1e-9\n        mic_valid = np.all(span  (L / 2.0 - epsilon))\n        \n        # --- 5. Collect results for this case ---\n        all_results.append([rg2_cm, rg2_pair_unwrapped, rg2_pair_mic, delta_mic, bool(mic_valid)])\n\n    # --- 6. Format and Print Final Output ---\n    # Construct the final output string exactly as specified.\n    final_output_str_list = []\n    for res in all_results:\n        # Format the four float values to 6 decimal places and get the string for the boolean.\n        formatted_res = [f\"{v:.6f}\" for v in res[:4]] + [str(res[4])]\n        s = f\"[{','.join(formatted_res)}]\"\n        final_output_str_list.append(s)\n\n    # Print the single line containing the list of lists.\n    print(f\"[{','.join(final_output_str_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "随着模拟规模的增大，处理海量轨迹数据对分析算法的效率和数值稳定性提出了更高要求。计算$R_g^2$的标准两遍法（先计算质心，再计算与质心的距离平方和）在处理大数据流时可能效率低下或因舍入误差而不够精确。本练习  将指导您推导并实现一种单遍“在线”算法，它类似于计算方差的Welford算法，能够在一次遍历数据流的过程中以数值稳定的方式精确计算质量加权的回旋半径，这是一项高级计算物理技术。",
            "id": "3440388",
            "problem": "给定一个粒子数据流，其中每个粒子都由一个非负质量和一个三维空间中的位置指定。请仅使用对数据流的单次遍历，从第一性原理推导出一个在线更新方案，以计算质量加权的质心和质量加权的回旋半径的平方。你的推导必须从经典力学中质心和回旋半径的基本定义开始，并通过代数操作进行，避免形成巨大的中间和，因为这对于质量或坐标动态范围大的序列来说，数值上是不稳定的。该在线方案在精神上必须类似于 Welford 的方差计算方法，但推广到三维空间中矢量值的、质量加权的数据。\n\n起始定义：\n- 对于索引为 $i \\in \\{1,\\dots,n\\}$、质量为 $m_i \\ge 0$、位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 的粒子，总质量为 $M_n = \\sum_{i=1}^{n} m_i$，当 $M_n \\gt 0$ 时，质量加权质心 (COM) 为 $\\mathbf{R}_n = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\mathbf{r}_i$。\n- 当 $M_n \\gt 0$ 时，质量加权回旋半径的平方为 $R_{g,n}^2 = \\frac{1}{M_n}\\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2$。\n\n你的任务分为两部分：\n1. 仅使用上述定义和通用代数方法，推导出一个针对质量为 $m$、位置为 $\\mathbf{r}$ 的新粒子的单次遍历更新方案，该方案更新当前的总质量 $M$、当前的质心 $\\mathbf{R}$ 以及一个辅助标量累加器 $S$，使得在处理完所有粒子后，当 $M \\gt 0$ 时，在精确算术中 $R_g^2 = S/M$ 严格成立。你的更新方案对于 $m = 0$ 必须有良好定义，并且必须避免会因 $M$ 值较大或 $\\mathbf{r}$ 动态范围较大而降低数值稳定性的相减抵消路径。\n2. 将推导出的更新方案在一个程序中实现，以处理以下测试套件。每个测试用例都是一系列 $(m_i,\\mathbf{r}_i)$ 值。输入单位：位置单位为纳米 (nm)，质量单位为任意一致的质量单位。输出单位：以平方纳米 (nm$^2$) 报告 $R_g^2$。\n\n待实现的测试套件：\n- 案例 A (正常路径，对称性)：$[(1.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0))]$。\n- 案例 B (平面内的非对称质量)：$[(2.0,(0.0,0.0,0.0)),(1.0,(1.0,0.0,0.0)),(1.0,(0.0,1.0,0.0))]$。\n- 案例 C (退化几何，大动态范围)：$[(1.0\\times 10^{6},(2.0,2.0,2.0)),(2.0\\times 10^{-6},(2.0,2.0,2.0)),(3.0,(2.0,2.0,2.0))]$。\n- 案例 D (共线位置，不同质量)：$[(1.0,(0.0,0.0,0.0)),(2.0,(2.0,0.0,0.0)),(3.0,(4.0,0.0,0.0)),(4.0,(6.0,0.0,0.0))]$。\n- 案例 E (单个粒子的边界情况)：$[(1.23,(3.4,-5.6,7.8))]$。\n\n程序要求：\n- 使用你的在线更新方案，严格地对每个案例中的粒子进行单次遍历处理，无需存储所有位置以进行批量重新计算。\n- 对每个案例，计算以 nm$^2$ 为单位的 $R_g^2$。\n- 最终输出格式：你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"）。每个结果必须是精确到 $6$ 位小数的浮点数。\n\n假设与约束：\n- 你可以假设所有质量都是有限非负的，所有坐标都是有限的。\n- 如果总质量为零，$R_g^2$ 未定义；但是，所提供的测试用例避免了这种情况。\n- 此问题不使用角度，因此不需要角度单位。\n\n交付成果：\n- 从定义推导出的在线更新方案。\n- 一个完整、可运行的程序，该程序实现推导出的更新方案，并将其应用于指定的测试套件，输出一行格式化的结果。",
            "solution": "我们的任务是为质量加权质心 $\\mathbf{R}$ 和质量加权回旋半径的平方 $R_g^2$ 推导一个在线的、单次遍历的更新方案。推导必须从所提供的第一性原理出发，并得出一个数值稳定的算法。\n\n让我们用三元组 $(M_n, \\mathbf{R}_n, S_n)$ 表示处理完 $n$ 个粒子后系统的状态，其中 $M_n$ 是总质量，$\\mathbf{R}_n$ 是质心，而 $S_n$ 是一个辅助累加器。对于前 $n$ 个质量为 $m_i$、位置为 $\\mathbf{r}_i$ 的粒子，定义如下：\n总质量：\n$$ M_n = \\sum_{i=1}^{n} m_i $$\n质量加权质心 (COM)：\n$$ \\mathbf{R}_n = \\frac{1}{M_n} \\sum_{i=1}^{n} m_i \\mathbf{r}_i $$\n质量加权回旋半径的平方由 $R_{g,n}^2 = S_n/M_n$ 给出，其中 $S_n$ 定义为与质心距离平方的质量加权和：\n$$ S_n = M_n R_{g,n}^2 = \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 $$\n我们的目标是根据 $M_n$、$\\mathbf{R}_n$、$S_n$ 以及质量为 $m$、位置为 $\\mathbf{r}$ 的新第 $(n+1)$ 个粒子的性质，找到 $M_{n+1}$、$\\mathbf{R}_{n+1}$ 和 $S_{n+1}$ 的递推关系。\n\n1.  **总质量 ($M_n$) 的更新**\n    总质量的更新规则直接从其定义推导而来：\n    $$ M_{n+1} = \\sum_{i=1}^{n+1} m_i = \\left(\\sum_{i=1}^{n} m_i\\right) + m_{n+1} $$\n    令 $m_{n+1}=m$，则更新规则为：\n    $$ M_{n+1} = M_n + m $$\n\n2.  **质心 ($\\mathbf{R}_n$) 的更新**\n    $n+1$ 个粒子的质心为：\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} \\sum_{i=1}^{n+1} m_i \\mathbf{r}_i = \\frac{1}{M_{n+1}} \\left( \\sum_{i=1}^{n} m_i \\mathbf{r}_i + m\\mathbf{r} \\right) $$\n    使用定义 $\\sum_{i=1}^{n} m_i \\mathbf{r}_i = M_n \\mathbf{R}_n$：\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{r}) $$\n    为了得到一个类似于 Welford 算法的形式（该算法涉及基于当前均值偏差的更新），我们在分子中加上再减去 $m\\mathbf{R}_n$：\n    $$ \\mathbf{R}_{n+1} = \\frac{1}{M_{n+1}} (M_n \\mathbf{R}_n + m\\mathbf{R}_n - m\\mathbf{R}_n + m\\mathbf{r}) = \\frac{1}{M_{n+1}} ((M_n + m)\\mathbf{R}_n + m(\\mathbf{r} - \\mathbf{R}_n)) $$\n    因为 $M_{n+1} = M_n + m$：\n    $$ \\mathbf{R}_{n+1} = \\mathbf{R}_n + \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    这个更新规则在数值上是稳健的，因为它向现有质心添加了一个小的修正项，从而减轻了当 $\\mathbf{R}_n$ 和 $\\mathbf{r}$ 很大但它们的差值很小时可能出现的浮点精度损失。\n\n3.  **辅助累加器 ($S_n$) 的更新**\n    累加器 $S_{n+1}$ 定义为：\n    $$ S_{n+1} = \\sum_{i=1}^{n+1} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 \\right) + m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2 $$\n    我们必须用 $\\mathbf{R}_n$ 来表示 $\\mathbf{R}_{n+1}$。设 $\\mathbf{\\Delta_R} = \\mathbf{R}_{n+1} - \\mathbf{R}_n = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$。\n    考虑求和项：\n    $$ \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_{n+1} \\rVert^2 = \\sum_{i=1}^{n} m_i \\lVert (\\mathbf{r}_i - \\mathbf{R}_n) - \\mathbf{\\Delta_R} \\rVert^2 $$\n    展开平方范数：\n    $$ = \\sum_{i=1}^{n} m_i \\left( \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 - 2(\\mathbf{r}_i - \\mathbf{R}_n) \\cdot \\mathbf{\\Delta_R} + \\lVert \\mathbf{\\Delta_R} \\rVert^2 \\right) $$\n    $$ = \\left( \\sum_{i=1}^{n} m_i \\lVert \\mathbf{r}_i - \\mathbf{R}_n \\rVert^2 \\right) - 2\\mathbf{\\Delta_R} \\cdot \\left( \\sum_{i=1}^{n} m_i(\\mathbf{r}_i - \\mathbf{R}_n) \\right) + \\left( \\sum_{i=1}^{n} m_i \\right) \\lVert \\mathbf{\\Delta_R} \\rVert^2 $$\n    第一项是 $S_n$。第二项为零，因为 $\\sum m_i(\\mathbf{r}_i - \\mathbf{R}_n) = \\sum m_i \\mathbf{r}_i - \\mathbf{R}_n \\sum m_i = M_n \\mathbf{R}_n - M_n \\mathbf{R}_n = \\mathbf{0}$。第三项是 $M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$。因此，求和项变为 $S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2$。\n\n    现在考虑新粒子的项，$m \\lVert \\mathbf{r} - \\mathbf{R}_{n+1} \\rVert^2$：\n    $$ \\mathbf{r} - \\mathbf{R}_{n+1} = \\mathbf{r} - (\\mathbf{R}_n + \\mathbf{\\Delta_R}) = (\\mathbf{r} - \\mathbf{R}_n) - \\mathbf{\\Delta_R} = (\\mathbf{r} - \\mathbf{R}_n) - \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n) $$\n    $$ = \\left(1 - \\frac{m}{M_{n+1}}\\right) (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_{n+1}-m}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) = \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) $$\n    新粒子对 $S_{n+1}$ 的贡献是：\n    $$ m \\left\\lVert \\frac{M_n}{M_{n+1}} (\\mathbf{r} - \\mathbf{R}_n) \\right\\rVert^2 = m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    组合各个部分：\n    $$ S_{n+1} = S_n + M_n \\lVert \\mathbf{\\Delta_R} \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    代入 $\\mathbf{\\Delta_R} = \\frac{m}{M_{n+1}}(\\mathbf{r} - \\mathbf{R}_n)$：\n    $$ S_{n+1} = S_n + M_n \\left(\\frac{m}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 + m \\left(\\frac{M_n}{M_{n+1}}\\right)^2 \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} \\left[ M_n m^2 + m M_n^2 \\right] $$\n    对括号中的项 $M_n m(m + M_n) = M_n m M_{n+1}$ 进行因式分解：\n    $$ S_{n+1} = S_n + \\frac{\\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2}{M_{n+1}^2} (M_n m M_{n+1}) $$\n    $$ S_{n+1} = S_n + \\frac{m M_n}{M_{n+1}} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 = S_n + \\frac{m M_n}{m+M_n} \\lVert \\mathbf{r} - \\mathbf{R}_n \\rVert^2 $$\n    这个更新规则对于非负质量是纯粹加法的，避免了朴素的平行轴定理方法（$S_n = \\sum m_i \\lVert \\mathbf{r}_i \\rVert^2 - M_n \\lVert \\mathbf{R}_n \\rVert^2$）中固有的相减抵消。这种形式是 Welford 平方差求和算法的质量加权、矢量化推广。\n\n**最终算法：**\n\n初始化状态：$N = 0$ (粒子计数)，$M = 0$，$\\mathbf{R} = \\mathbf{0}$，$S = 0$。\n\n对于每个传入的粒子 $(m_i, \\mathbf{r}_i)$：\n1.  如果 $N = 0$：\n    $M \\leftarrow m_i$，$\\mathbf{R} \\leftarrow \\mathbf{r}_i$，$S \\leftarrow 0$。\n2.  否则，如果 $m_i  0$（$m_i=0$ 的情况不产生变化）：\n    a. 存储旧的状态变量：$M_{old} \\leftarrow M$，$\\mathbf{R}_{old} \\leftarrow \\mathbf{R}$。\n    b. 更新总质量：$M \\leftarrow M_{old} + m_i$。\n    c. 更新质心：$\\mathbf{R} \\leftarrow \\mathbf{R}_{old} + \\frac{m_i}{M}(\\mathbf{r}_i - \\mathbf{R}_{old})$。\n    d. 更新累加器：设 $\\mathbf{\\delta} = \\mathbf{r}_i - \\mathbf{R}_{old}$。则 $S \\leftarrow S + \\frac{m_i M_{old}}{M} (\\mathbf{\\delta} \\cdot \\mathbf{\\delta})$。\n3.  增加粒子计数：$N \\leftarrow N + 1$。\n\n处理完所有粒子后，如果 $M  0$，则质量加权回旋半径的平方为 $R_g^2 = S/M$。对于单个粒子 ($N=1$)，$M=m_1, \\mathbf{R}=\\mathbf{r}_1, S=0$，因此 $R_g^2 = 0$，这是正确的。对于所有粒子都位于同一位置的系统，$S$ 的更新量始终为零，从而正确地得到 $R_g^2 = 0$。\n该算法满足问题陈述的所有要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rg2_online(particles):\n    \"\"\"\n    Calculates the mass-weighted radius of gyration squared using a one-pass\n    online algorithm derived from first principles.\n\n    The algorithm is a mass-weighted, vector generalization of Welford's method.\n    It maintains three running quantities:\n    - M: Total mass\n    - R: Mass-weighted center of mass (COM)\n    - S: Mass-weighted sum of squared distances from the COM, S = M * Rg^2\n\n    The state is initialized with the first particle. For each subsequent\n    particle (m, r), the state (M, R, S) is updated.\n\n    Args:\n        particles (list of tuples): A list where each tuple contains\n                                    (mass, position_vector).\n\n    Returns:\n        float: The mass-weighted radius of gyration squared, Rg^2.\n    \"\"\"\n    if not particles:\n        return 0.0\n\n    n_particles = 0\n    total_mass = 0.0\n    com = np.zeros(3, dtype=np.float64)\n    # S is the accumulator for M * Rg^2\n    s_accumulator = 0.0\n    \n    for m, r_tuple in particles:\n        r_vec = np.array(r_tuple, dtype=np.float64)\n        \n        # Skip zero-mass particles as they don't contribute\n        if m == 0:\n            continue\n\n        n_particles += 1\n        \n        if n_particles == 1:\n            total_mass = m\n            com = r_vec\n            s_accumulator = 0.0\n        else:\n            old_mass = total_mass\n            old_com = com\n            \n            total_mass = old_mass + m\n            \n            # Update COM using the stable online formula\n            delta_r = r_vec - old_com\n            com = old_com + (m / total_mass) * delta_r\n            \n            # Update S (the M*Rg^2 accumulator) using the derived stable formula\n            # S_new = S_old + (m_old * m_new / m_total) * ||r_new - com_old||^2\n            update_term = (m * old_mass / total_mass) * np.dot(delta_r, delta_r)\n            s_accumulator += update_term\n            \n    if total_mass == 0:\n        return 0.0\n        \n    rg2 = s_accumulator / total_mass\n    return rg2\n\ndef solve():\n    \"\"\"\n    Processes a suite of test cases, each a stream of particle data,\n    to compute the radius of gyration squared in a single pass.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path, symmetry\n        [(1.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0))],\n        \n        # Case B: asymmetric masses in a plane\n        [(2.0, (0.0, 0.0, 0.0)), (1.0, (1.0, 0.0, 0.0)), (1.0, (0.0, 1.0, 0.0))],\n        \n        # Case C: degenerate geometry, large dynamic range\n        [(1.0e6, (2.0, 2.0, 2.0)), (2.0e-6, (2.0, 2.0, 2.0)), (3.0, (2.0, 2.0, 2.0))],\n\n        # Case D: colinear positions, varied masses\n        [(1.0, (0.0, 0.0, 0.0)), (2.0, (2.0, 0.0, 0.0)), (3.0, (4.0, 0.0, 0.0)), (4.0, (6.0, 0.0, 0.0))],\n        \n        # Case E: single particle edge case\n        [(1.23, (3.4, -5.6, 7.8))],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rg2_online(case)\n        results.append(result)\n\n    # Format the final output string with results rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}