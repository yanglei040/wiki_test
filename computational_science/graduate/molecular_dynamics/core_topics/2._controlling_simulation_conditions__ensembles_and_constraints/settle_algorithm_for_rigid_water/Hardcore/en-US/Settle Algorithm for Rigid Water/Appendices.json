{
    "hands_on_practices": [
        {
            "introduction": "To understand how any constraint algorithm works, we must first grasp the mathematical and physical nature of the constraints themselves. This exercise provides a foundational look into the SETTLE algorithm by having you derive the gradients of the constraint functions. Calculating these gradients reveals the directions of the internal constraint forces that hold the water molecule rigid and, consequently, the directions along which the algorithm applies corrective displacements .",
            "id": "3444600",
            "problem": "Consider a rigid three-site water molecule with atoms labeled oxygen ($O$), hydrogen one ($\\mathrm{H}1$), and hydrogen two ($\\mathrm{H}2$), with position vectors $\\mathbf{r}_O$, $\\mathbf{r}_{\\mathrm{H}1}$, and $\\mathbf{r}_{\\mathrm{H}2}$ in $\\mathbb{R}^3$. In molecular dynamics with holonomic constraints, rigidity is enforced by requiring that selected functions of the atomic coordinates remain constant over time. For rigid water in the Specialized Efficient Constraint Solver for Torsionally Linked Equations (SETTLE) algorithm, a convenient choice is to constrain two oxygen–hydrogen bond lengths and the hydrogen–hydrogen separation, using the three constraints\n$$\nC_1(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2,\n$$\n$$\nC_2(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2,\n$$\n$$\nC_3(\\mathbf{r}_O,\\mathbf{r}_{\\mathrm{H}1},\\mathbf{r}_{\\mathrm{H}2}) \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2,\n$$\nwhere $d_{\\mathrm{OH}}$ is the fixed oxygen–hydrogen bond length, and $d_{\\mathrm{HH}}$ is the fixed hydrogen–hydrogen separation, which is related to the equilibrium hydrogen–oxygen–hydrogen bond angle $\\theta_0$ by $d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta_0)$ when both oxygen–hydrogen bonds have length $d_{\\mathrm{OH}}$.\n\nStarting only from the basic rules of multivariable calculus and the definition of the Euclidean norm, derive explicit analytical expressions for the gradients $\\nabla_{\\mathbf{r}_i} C_k$ with respect to each atomic coordinate $\\mathbf{r}_i$ for all constraints $k \\in \\{1,2,3\\}$ and atoms $i \\in \\{O,\\mathrm{H}1,\\mathrm{H}2\\}$. Then, explain their geometric meaning within the context of constraint forces in holonomically constrained dynamics and comment on how these gradients relate to the instantaneous directions along which the SETTLE algorithm corrects positions to satisfy rigidity.\n\nYour final answer must present the nine gradient vectors in a single analytic expression. Use symbols only; do not substitute numerical values. No units are required. The final answer will not require rounding.",
            "solution": "The problem requires the derivation of the gradients of three constraint functions for a rigid water molecule with respect to the positions of its three atoms. It also asks for the geometric interpretation of these gradients in the context of constraint forces and their role in the SETTLE algorithm.\n\nFirst, we establish the fundamental rule from multivariable calculus for the gradient of a squared Euclidean distance between two position vectors. Let the positions of two particles, $i$ and $j$, be given by vectors $\\mathbf{r}_i$ and $\\mathbf{r}_j$ in $\\mathbb{R}^3$. The squared distance between them is a scalar function $f(\\mathbf{r}_i, \\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2$. Let $\\mathbf{r}_i = (x_i, y_i, z_i)$ and $\\mathbf{r}_j = (x_j, y_j, z_j)$. The squared norm is:\n$$\nf(\\mathbf{r}_i, \\mathbf{r}_j) = (x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2\n$$\nThe gradient of $f$ with respect to $\\mathbf{r}_i$ is defined as the vector of its partial derivatives: $\\nabla_{\\mathbf{r}_i} f = \\left(\\frac{\\partial f}{\\partial x_i}, \\frac{\\partial f}{\\partial y_i}, \\frac{\\partial f}{\\partial z_i}\\right)$. Calculating the partial derivative with respect to $x_i$:\n$$\n\\frac{\\partial f}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left[ (x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2 \\right] = 2(x_i - x_j)\n$$\nBy symmetry, the other components are $\\frac{\\partial f}{\\partial y_i} = 2(y_i - y_j)$ and $\\frac{\\partial f}{\\partial z_i} = 2(z_i - z_j)$. Combining these gives the gradient vector:\n$$\n\\nabla_{\\mathbf{r}_i} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\nSimilarly, the gradient with respect to $\\mathbf{r}_j$ is calculated:\n$$\n\\frac{\\partial f}{\\partial x_j} = \\frac{\\partial}{\\partial x_j} \\left[ (x_i - x_j)^2 \\right] = 2(x_i - x_j)(-1) = -2(x_i - x_j)\n$$\nThis leads to the gradient vector:\n$$\n\\nabla_{\\mathbf{r}_j} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\nFor any other particle with position $\\mathbf{r}_k$ where $k \\neq i,j$, the function $f$ does not depend on $\\mathbf{r}_k$, so its gradient is the zero vector: $\\nabla_{\\mathbf{r}_k} \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 = \\mathbf{0}$.\n\nNow we apply these rules to the three given constraint functions:\n$C_1 \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$\n$C_2 \\equiv \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$\n$C_3 \\equiv \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2$\n\nSince the terms $d_{\\mathrm{OH}}^2$ and $d_{\\mathrm{HH}}^2$ are constants, their derivatives are zero. Thus, we only need to differentiate the squared norm terms.\n\n**Gradients for Constraint $C_1(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$:**\nThe function is $C_1 = \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$.\n- Gradient with respect to $\\mathbf{r}_O$: This corresponds to the role of $\\mathbf{r}_j$ in our general formula with $i=\\mathrm{H}1$ and $j=O$.\n$$\n\\nabla_{\\mathbf{r}_O} C_1 = \\nabla_{\\mathbf{r}_O} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}1}$: This corresponds to the role of $\\mathbf{r}_i$.\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1 = \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}2}$: $C_1$ does not depend on $\\mathbf{r}_{\\mathrm{H}2}$.\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_1 = \\mathbf{0}\n$$\n\n**Gradients for Constraint $C_2(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$:**\nThe function is $C_2 = \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 - d_{\\mathrm{OH}}^2$.\n- Gradient with respect to $\\mathbf{r}_O$:\n$$\n\\nabla_{\\mathbf{r}_O} C_2 = \\nabla_{\\mathbf{r}_O} \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}1}$: $C_2$ does not depend on $\\mathbf{r}_{\\mathrm{H}1}$.\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_2 = \\mathbf{0}\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}2}$:\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_2 = \\nabla_{\\mathbf{r}_{\\mathrm{H}2}} \\|\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O)\n$$\n\n**Gradients for Constraint $C_3(\\mathbf{r}_O, \\mathbf{r}_{\\mathrm{H}1}, \\mathbf{r}_{\\mathrm{H}2})$:**\nThe function is $C_3 = \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 - d_{\\mathrm{HH}}^2$.\n- Gradient with respect to $\\mathbf{r}_O$: $C_3$ does not depend on $\\mathbf{r}_O$.\n$$\n\\nabla_{\\mathbf{r}_O} C_3 = \\mathbf{0}\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}1}$:\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_3 = \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2})\n$$\n- Gradient with respect to $\\mathbf{r}_{\\mathrm{H}2}$:\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{H}2}} C_3 = \\nabla_{\\mathbf{r}_{\\mathrm{H}2}} \\|\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}\\|^2 = -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2})\n$$\n\n**Geometric Meaning and Relation to Constraint Algorithms**\n\nIn the Lagrangian formulation of classical mechanics with holonomic constraints $C_k=0$, the forces of constraint that maintain these conditions are given by $\\mathbf{F}_i^c = \\sum_k -\\lambda_k \\nabla_{\\mathbf{r}_i} C_k$, where $\\lambda_k$ are Lagrange multipliers determined by the dynamics.\n\nThe gradient vector $\\nabla_{\\mathbf{r}_i} C_k$ points in the direction in which a change in atom $i$'s position $\\mathbf{r}_i$ would cause the most rapid increase in the value of the constraint function $C_k$. For our distance constraints, this direction is always along the line connecting the two atoms involved in the constraint. For example, $\\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1 = 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)$ is a vector pointing from atom $O$ to atom $\\mathrm{H}1$. Consequently, the constraint force on atom $\\mathrm{H}1$ due to the first constraint, $\\mathbf{F}_{\\mathrm{H}1,1}^c = -\\lambda_1 \\nabla_{\\mathbf{r}_{\\mathrm{H}1}} C_1$, is a central force directed along the O–H1 bond. The force on atom $O$ from this same constraint, $\\mathbf{F}_{O,1}^c = -\\lambda_1 \\nabla_{\\mathbf{r}_O} C_1 = -\\lambda_1 (-2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O)) = - \\mathbf{F}_{\\mathrm{H}1,1}^c$, is equal and opposite, as required by Newton's third law. The gradients thus define the lines of action for the internal forces that hold the molecule rigid.\n\nIn computational algorithms like SHAKE and SETTLE, the equations of motion are first integrated without constraints, yielding tentative new positions $\\mathbf{r}_i'$ which generally violate the rigidity conditions ($C_k(\\mathbf{r}') \\neq 0$). The algorithm then calculates corrective displacements, $\\Delta\\mathbf{r}_i = \\mathbf{r}_i - \\mathbf{r}_i'$, to find new positions $\\mathbf{r}_i$ that do satisfy the constraints. These corrections are constructed as linear combinations of the constraint gradients. Specifically, the displacement for atom $i$ is of the form $\\Delta \\mathbf{r}_i \\propto \\sum_k g_k \\nabla_{\\mathbf{r}_i} C_k$, where $g_k$ are scalar coefficients related to the Lagrange multipliers.\n\nThis means that the SETTLE algorithm corrects the atomic positions by moving the atoms along the directions defined by these gradients—that is, along the interatomic bond vectors. For example, to correct a violation of the O–H1 bond length, SETTLE moves the $O$ and $\\mathrm{H}1$ atoms along the line connecting them. To correct the H1–H2 distance, it moves the two hydrogen atoms along the line connecting them. The SETTLE algorithm is computationally efficient because it leverages the simple, fixed geometry of the water molecule (an isosceles triangle) to find an exact, non-iterative, analytical solution for the magnitudes of these corrective displacements that simultaneously satisfies all three constraints. The gradient vectors are the fundamental building blocks of this analytical solution.",
            "answer": "$$\n\\boxed{\\pmatrix{ -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O) & 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_O) & \\mathbf{0} & -2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O) & \\mathbf{0} & 2(\\mathbf{r}_{\\mathrm{H}2}-\\mathbf{r}_O) & \\mathbf{0} & 2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}) & -2(\\mathbf{r}_{\\mathrm{H}1}-\\mathbf{r}_{\\mathrm{H}2}) }}\n$$"
        },
        {
            "introduction": "Moving from theory to practice, the real power of the SETTLE algorithm lies in its non-iterative, analytical solution for satisfying the water molecule's constraints. However, a production-level implementation must be robust enough to handle pathological or degenerate geometries that can occur due to numerical errors. This coding exercise challenges you to implement a robust version of the SETTLE projection, forcing you to develop strategies for handling cases like coincident atoms or collinear arrangements, which would cause a naive implementation to fail .",
            "id": "3444670",
            "problem": "You are asked to design and implement a robust analytic constraint projection for a rigid three-site water molecule that avoids branch cut and degeneracy issues that can arise in the Simple Efficient Torsion and Length Enforcement (SETTLE) algorithm when the two hydrogens become nearly coincident due to numerical error. The constraint projection must be derived from first principles and must remain well-defined when the hydrogen-hydrogen separation tends to zero, i.e., $r_{\\mathrm{HH}}\\to 0$.\n\nThe rigid water molecule consists of an oxygen at position $\\mathbf{r}_{\\mathrm{O}}$ and two hydrogens at positions $\\mathbf{r}_{\\mathrm{H}_1}$ and $\\mathbf{r}_{\\mathrm{H}_2}$ in $\\mathbb{R}^3$. The holonomic constraints for the rigid geometry are:\n- Fixed oxygen-hydrogen bond length: $\\lVert \\mathbf{r}_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert = r_{\\mathrm{OH}}$ and $\\lVert \\mathbf{r}_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert = r_{\\mathrm{OH}}$.\n- Fixed hydrogen-oxygen-hydrogen angle: $\\angle \\mathrm{H}_1\\mathrm{O}\\mathrm{H}_2 = \\theta$.\n\nThese constraints imply a fixed hydrogen-hydrogen distance $r_{\\mathrm{HH}} = 2 r_{\\mathrm{OH}} \\sin\\!\\left(\\tfrac{\\theta}{2}\\right)$, which is a geometric identity derived from the law of cosines applied to the triangle formed by the two hydrogens and the oxygen.\n\nStarting from Newton’s laws and holonomic constraints in Molecular Dynamics (MD), your task is to:\n- Derive a re-parameterization of the hydrogen positions relative to the oxygen using orthonormal basis vectors in the molecular plane that does not rely on inverse trigonometric functions with ambiguous branches.\n- Design robust fallback rules that deterministically choose a meaningful bisector direction and in-plane perpendicular direction even when $\\mathbf{r}_{\\mathrm{H}_1}\\approx \\mathbf{r}_{\\mathrm{H}_2}$, $\\mathbf{r}_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}$ and $\\mathbf{r}_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}$ are nearly zero, or when the two oxygen-hydrogen directions are antiparallel so that the bisector is ill-defined.\n- Implement the resulting analytic projection that, given provisional positions $(\\mathbf{r}_{\\mathrm{O}},\\mathbf{r}_{\\mathrm{H}_1},\\mathbf{r}_{\\mathrm{H}_2})$, outputs corrected positions $(\\mathbf{r}'_{\\mathrm{O}},\\mathbf{r}'_{\\mathrm{H}_1},\\mathbf{r}'_{\\mathrm{H}_2})$ satisfying the constraints exactly up to numerical precision.\n\nUse the following physically reasonable parameters for liquid water geometry:\n- Oxygen-hydrogen bond length $r_{\\mathrm{OH}} = 0.9572 \\, \\mathrm{\\AA}$.\n- Hydrogen-oxygen-hydrogen angle $\\theta = 104.52^\\circ$ specified in radians. That is, use $\\theta = 104.52 \\times \\pi/180 \\, \\mathrm{rad}$.\n\nYour program must implement the robust analytic projection and evaluate it on the following test suite of provisional positions. In all cases, the corrected oxygen position must remain $\\mathbf{r}'_{\\mathrm{O}}=\\mathbf{r}_{\\mathrm{O}}$ (pure intramolecular correction with no translational shift). For each case, report two scalar errors:\n- The maximum length deviation across the three constraints, expressed in $\\mathrm{\\AA}$:\n  $$\\varepsilon_{\\mathrm{len}} = \\max\\left(\\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert - r_{\\mathrm{OH}}\\right|,\\ \\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert - r_{\\mathrm{OH}}\\right|,\\ \\left|\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}'_{\\mathrm{H}_2}\\rVert - 2 r_{\\mathrm{OH}}\\sin\\!\\left(\\tfrac{\\theta}{2}\\right)\\right|\\right).$$\n- The hydrogen-oxygen-hydrogen angle error, expressed in rad:\n  $$\\varepsilon_{\\mathrm{ang}} = \\left|\\arccos\\!\\left(\\frac{(\\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}})\\cdot(\\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}})}{\\lVert \\mathbf{r}'_{\\mathrm{H}_1}-\\mathbf{r}_{\\mathrm{O}}\\rVert\\,\\lVert \\mathbf{r}'_{\\mathrm{H}_2}-\\mathbf{r}_{\\mathrm{O}}\\rVert}\\right) - \\theta\\right|.$$\n\nAngles must be computed in rad and lengths in $\\mathrm{\\AA}$. Clamp any cosine argument of $\\arccos$ to the interval $[-1,1]$ to avoid numerical issues in the diagnostic calculation.\n\nDefine the test suite using the following five provisional geometries in $\\mathrm{\\AA}$:\n- Case $1$ (near-ideal with small perturbation):\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,0,0)$,\n  - Let $p = r_{\\mathrm{OH}}\\cos\\!\\left(\\tfrac{\\theta}{2}\\right)$ and $q = r_{\\mathrm{OH}}\\sin\\!\\left(\\tfrac{\\theta}{2}\\right)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (q + 1.0\\times 10^{-4},\\ 0,\\ p)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (-q - 1.0\\times 10^{-4},\\ 0,\\ p)$.\n- Case $2$ (nearly coincident hydrogens, $r_{\\mathrm{HH}}\\to 0$):\n  - $\\mathbf{r}_{\\mathrm{O}} = (1,\\ 2,\\ 3)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} + (1.0\\times 10^{-10},\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} + (1.1\\times 10^{-10},\\ 0,\\ 0)$.\n- Case $3$ (antiparallel oxygen-hydrogen directions, ill-defined bisector):\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,\\ 1,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} + (1,\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} - (1,\\ 0,\\ 0)$.\n- Case $4$ (complete degeneracy, all three atoms coincident):\n  - $\\mathbf{r}_{\\mathrm{O}} = (0,\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (0,\\ 0,\\ 0)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (0,\\ 0,\\ 0)$.\n- Case $5$ (large perturbation far from constraint manifold):\n  - $\\mathbf{r}_{\\mathrm{O}} = (5,\\ -3,\\ 2)$,\n  - $\\mathbf{r}_{\\mathrm{H}_1} = (3,\\ 7,\\ -4)$,\n  - $\\mathbf{r}_{\\mathrm{H}_2} = (-2,\\ 1,\\ 9)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $10$ floating-point numbers in the sequence $[\\varepsilon_{\\mathrm{len}}^{(1)}, \\varepsilon_{\\mathrm{ang}}^{(1)}, \\varepsilon_{\\mathrm{len}}^{(2)}, \\varepsilon_{\\mathrm{ang}}^{(2)}, \\dots, \\varepsilon_{\\mathrm{len}}^{(5)}, \\varepsilon_{\\mathrm{ang}}^{(5)}]$, where superscripts index the cases from $1$ to $5$.\n\nImplement the analytic projection without invoking iterative solvers or trigonometric inversion during the placement. Any diagnostics (such as angle error computation) must be robustly handled to avoid numerical branch cut problems.",
            "solution": "The problem requires the design and implementation of a robust analytic constraint algorithm for a rigid three-site water molecule. The algorithm must project a set of provisional atomic positions $(\\mathbf{r}_{\\mathrm{O}}, \\mathbf{r}_{\\mathrm{H}_1}, \\mathbf{r}_{\\mathrm{H}_2})$ onto the constraint manifold, yielding corrected positions $(\\mathbf{r}'_{\\mathrm{O}}, \\mathbf{r}'_{\\mathrm{H}_1}, \\mathbf{r}'_{\\mathrm{H}_2})$ that precisely satisfy the intramolecular geometric constraints. The primary challenge is to ensure the algorithm is well-defined and numerically stable even in degenerate configurations, such as when atoms become nearly coincident or collinear, which can cause standard implementations of algorithms like SETTLE to fail.\n\nThe constraints dictate a fixed oxygen-hydrogen bond length, $r_{\\mathrm{OH}}$, and a fixed hydrogen-oxygen-hydrogen angle, $\\theta$. The projection is simplified by the requirement that the oxygen atom's position remains unchanged, i.e., $\\mathbf{r}'_{\\mathrm{O}} = \\mathbf{r}_{\\mathrm{O}}$.\n\n### Principle-Based Derivation\n\nThe solution is to construct a local orthonormal basis (a coordinate system) based on the provisional geometry, and then place the hydrogen atoms into this new frame according to the ideal geometry. The robustness of the method hinges on the construction of this basis, which must deterministically handle all possible degenerate arrangements of the input atoms.\n\nLet the provisional positions of the oxygen and two hydrogen atoms be $\\mathbf{r}_{\\mathrm{O}}$, $\\mathbf{r}_{\\mathrm{H}_1}$, and $\\mathbf{r}_{\\mathrm{H}_2}$, respectively. We work with vectors relative to the oxygen atom:\n$$\n\\mathbf{v}_1 = \\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}} \\quad \\text{and} \\quad \\mathbf{v}_2 = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\n$$\nThe corrected positions of the hydrogens, $\\mathbf{r}'_{\\mathrm{H}_1}$ and $\\mathbf{r}'_{\\mathrm{H}_2}$, will be defined with respect to a newly constructed local coordinate system $\\{\\hat{\\mathbf{e}}_x, \\hat{\\mathbf{e}}_y, \\hat{\\mathbf{e}}_z\\}$ centered at $\\mathbf{r}_{\\mathrm{O}}$.\n\nThe ideal geometry within this local frame is defined by two key parameters derived from the constraints:\n1.  The distance from the oxygen to the midpoint of the $\\mathrm{H}_1-\\mathrm{H}_2$ segment: $h = r_{\\mathrm{OH}} \\cos(\\theta/2)$. This distance lies along the angle bisector.\n2.  Half the distance between the two hydrogen atoms: $w = r_{\\mathrm{OH}} \\sin(\\theta/2)$. This distance lies along the line connecting the hydrogens.\n\nWe define the local basis vectors such that $\\hat{\\mathbf{e}}_y$ aligns with the molecule's symmetry axis (the $\\angle \\mathrm{H_1OH_2}$ bisector) and $\\hat{\\mathbf{e}}_x$ aligns with the vector connecting the two hydrogens. $\\hat{\\mathbf{e}}_z$ is the normal to the molecular plane.\n\n### Robust Construction of the Orthonormal Basis\n\nThe core of the algorithm is a case-by-case procedure for defining the basis vectors, guided by the stability of characteristic vectors derived from the provisional geometry. Let $\\epsilon^2$ be a small tolerance (e.g., $10^{-24} \\, \\mathrm{\\AA}^2$) for squared vector norms.\n\n**1. Define Characteristic Vectors:**\n- Vector from $\\mathrm{H}_1$ to $\\mathrm{H}_2$: $\\mathbf{d} = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1} = \\mathbf{v}_2 - \\mathbf{v}_1$.\n- Vector related to the bisector: $\\mathbf{s} = \\mathbf{v}_1 + \\mathbf{v}_2$.\n\n**2. Handle Degeneracies and Construct Basis:**\n\n**Case A: Total Coincidence** ($\\lVert \\mathbf{v}_1 \\rVert^2 < \\epsilon^2$ and $\\lVert \\mathbf{v}_2 \\rVert^2 < \\epsilon^2$)\nAll three atoms are at the same location. The orientation is undefined. We choose a standard, arbitrary basis:\n$$\n\\hat{\\mathbf{e}}_x = (1, 0, 0), \\quad \\hat{\\mathbf{e}}_y = (0, 1, 0), \\quad \\hat{\\mathbf{e}}_z = (0, 0, 1)\n$$\n\n**Case B: Coincident Hydrogens** ($\\lVert \\mathbf{d} \\rVert^2 < \\epsilon^2$, but not Case A)\nThe hydrogen atoms are nearly at the same position. The vector $\\mathbf{d}$ is ill-defined. The most descriptive feature of the geometry is the vector from the oxygen to the coincident hydrogens, approximated by $\\mathbf{s} = \\mathbf{v}_1 + \\mathbf{v}_2$.\n- The bisector axis $\\hat{\\mathbf{e}}_y$ is defined by normalizing $\\mathbf{s}$: $\\hat{\\mathbf{e}}_y = \\mathbf{s} / \\lVert \\mathbf{s} \\rVert$.\n- The molecular plane is undefined. We must create one deterministically. A second vector, $\\mathbf{ref}$, guaranteed to be non-collinear with $\\hat{\\mathbf{e}}_y$, is chosen. A robust method is to select the Cartesian axis vector $(\\hat{\\mathbf{i}}, \\hat{\\mathbf{j}}, \\text{ or } \\hat{\\mathbf{k}})$ that is most perpendicular to $\\hat{\\mathbf{e}}_y$.\n- The normal to the plane, $\\hat{\\mathbf{e}}_z$, is constructed from the cross product: $\\hat{\\mathbf{e}}_z = (\\hat{\\mathbf{e}}_y \\times \\mathbf{ref}) / \\lVert \\hat{\\mathbf{e}}_y \\times \\mathbf{ref} \\rVert$.\n- The H-H axis $\\hat{\\mathbf{e}}_x$ is then found by completing the right-handed system: $\\hat{\\mathbf{e}}_x = \\hat{\\mathbf{e}}_y \\times \\hat{\\mathbf{e}}_z$.\n\n**Case C: General Case** ($\\lVert \\mathbf{d} \\rVert^2 \\ge \\epsilon^2$)\nThe hydrogens are distinct, so the vector $\\mathbf{d}$ is well-defined and serves as the primary axis.\n- The H-H axis is $\\hat{\\mathbf{e}}_x = \\mathbf{d} / \\lVert \\mathbf{d} \\rVert$.\n- We then check if the three atoms are collinear. The normal to the provisional plane is $\\mathbf{n} = \\mathbf{v}_1 \\times \\mathbf{v}_2$.\n  - **If $\\lVert \\mathbf{n} \\rVert^2 > \\epsilon^2$ (non-collinear):** The plane is well-defined.\n    - The plane normal is $\\hat{\\mathbf{e}}_z = \\mathbf{n} / \\lVert \\mathbf{n} \\rVert$.\n    - The bisector axis is $\\hat{\\mathbf{e}}_y = \\hat{\\mathbf{e}}_z \\times \\hat{\\mathbf{e}}_x$.\n  - **If $\\lVert \\mathbf{n} \\rVert^2 \\le \\epsilon^2$ (collinear):** The plane is ill-defined. This includes the anti-parallel case ($\\mathbf{v}_1 \\approx -\\mathbf{v}_2$).\n    - We have $\\hat{\\mathbf{e}}_x$ and must define an orthogonal plane. We use the same robust method as in Case B: choose a reference vector $\\mathbf{ref}$ not parallel to $\\hat{\\mathbf{e}}_x$.\n    - A second axis $\\hat{\\mathbf{e}}_y$ is constructed: $\\hat{\\mathbf{e}}_y = (\\mathbf{ref} \\times \\hat{\\mathbf{e}}_x) / \\lVert \\mathbf{ref} \\times \\hat{\\mathbf{e}}_x \\rVert$.\n    - The third axis is $\\hat{\\mathbf{e}}_z = \\hat{\\mathbf{e}}_x \\times \\hat{\\mathbf{e}}_y$.\n\nThis procedure guarantees a unique, right-handed orthonormal basis for any input geometry.\n\n### Reconstruction of Atomic Positions\n\nWith the basis $\\{\\hat{\\mathbf{e}}_x, \\hat{\\mathbf{e}}_y, \\hat{\\mathbf{e}}_z\\}$ established, the corrected hydrogen positions are calculated directly, without using any inverse trigonometric functions:\n$$\n\\mathbf{r}'_{\\mathrm{O}} = \\mathbf{r}_{\\mathrm{O}}\n$$\n$$\n\\mathbf{r}'_{\\mathrm{H}_1} = \\mathbf{r}_{\\mathrm{O}} - w \\cdot \\hat{\\mathbf{e}}_x + h \\cdot \\hat{\\mathbf{e}}_y\n$$\n$$\n\\mathbf{r}'_{\\mathrm{H}_2} = \\mathbf{r}_{\\mathrm{O}} + w \\cdot \\hat{\\mathbf{e}}_x + h \\cdot \\hat{\\mathbf{e}}_y\n$$\nThe signs are chosen to be consistent with the definition $\\mathbf{d} = \\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}$, ensuring the corrected vector $\\mathbf{r}'_{\\mathrm{H}_2} - \\mathbf{r}'_{\\mathrm{H}_1}$ points in the same direction as $\\hat{\\mathbf{e}}_x$.\n\nThis completes the analytic projection. The final step is to compute the specified error metrics, $\\varepsilon_{\\mathrm{len}}$ and $\\varepsilon_{\\mathrm{ang}}$, using the corrected positions to verify that the constraints are satisfied to machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, applies the robust\n    analytic projection, computes errors, and prints the final results.\n    \"\"\"\n    \n    # Geometric parameters for the rigid water model\n    R_OH = 0.9572  # Angstrom\n    THETA_DEG = 104.52  # degrees\n    THETA_RAD = np.deg2rad(THETA_DEG)\n\n    # Derived geometric constants used for reconstruction\n    H_LEN = R_OH * np.cos(THETA_RAD / 2.0)\n    W_LEN = R_OH * np.sin(THETA_RAD / 2.0)\n    R_HH = 2.0 * W_LEN\n    \n    # Numerical tolerance for squared norms to detect degeneracy\n    TOL_SQ = 1e-24\n\n    def analytic_projection(r_o, r_h1, r_h2):\n        \"\"\"\n        Applies a robust analytic projection to a provisional water geometry\n        to satisfy the rigid constraints, handling degenerate cases.\n\n        Args:\n            r_o (np.ndarray): Provisional position of the oxygen atom.\n            r_h1 (np.ndarray): Provisional position of the first hydrogen atom.\n            r_h2 (np.ndarray): Provisional position of the second hydrogen atom.\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray, np.ndarray]: Corrected positions\n            (r_o_prime, r_h1_prime, r_h2_prime) satisfying constraints.\n        \"\"\"\n        v1 = r_h1 - r_o\n        v2 = r_h2 - r_o\n\n        # Case A: Total Coincidence (all three atoms at the same point)\n        # This handles Case 4.\n        if np.dot(v1, v1) < TOL_SQ and np.dot(v2, v2) < TOL_SQ:\n            ex = np.array([1.0, 0.0, 0.0])\n            ey = np.array([0.0, 1.0, 0.0])\n        else:\n            # Vector connecting the two hydrogens\n            d = r_h2 - r_h1\n            d_sq_norm = np.dot(d, d)\n\n            # Case B: Coincident Hydrogens (r_h1 ≈ r_h2)\n            # This handles Case 2.\n            if d_sq_norm < TOL_SQ:\n                # The bisector vector is the most stable direction.\n                s = v1 + v2\n                ey = s / np.linalg.norm(s)\n\n                # Construct a perpendicular reference vector robustly by selecting\n                # the Cartesian axis most perpendicular to ey.\n                abs_ey = np.abs(ey)\n                if abs_ey[0] < abs_ey[1] and abs_ey[0] < abs_ey[2]:\n                    ref = np.array([1.0, 0.0, 0.0])\n                elif abs_ey[1] < abs_ey[2]:\n                    ref = np.array([0.0, 1.0, 0.0])\n                else:\n                    ref = np.array([0.0, 0.0, 1.0])\n\n                ez_unnormalized = np.cross(ey, ref)\n                ez = ez_unnormalized / np.linalg.norm(ez_unnormalized)\n                ex = np.cross(ey, ez)\n            \n            # Case C: General Case (Hydrogens are distinct)\n            # This handles Cases 1, 3, and 5.\n            else:\n                ex = d / np.sqrt(d_sq_norm)\n                n = np.cross(v1, v2) # Normal to the provisional plane\n                n_sq_norm = np.dot(n, n)\n\n                # If plane is well-defined (non-collinear atoms)\n                if n_sq_norm > TOL_SQ:\n                    ez = n / np.sqrt(n_sq_norm)\n                    ey = np.cross(ez, ex)\n                # If atoms are collinear (plane is ill-defined, e.g., Case 3)\n                else:\n                    # Construct perpendiculars using a robust reference vector\n                    abs_ex = np.abs(ex)\n                    if abs_ex[0] < abs_ex[1] and abs_ex[0] < abs_ex[2]:\n                        ref = np.array([1.0, 0.0, 0.0])\n                    elif abs_ex[1] < abs_ex[2]:\n                        ref = np.array([0.0, 1.0, 0.0])\n                    else:\n                        ref = np.array([0.0, 0.0, 1.0])\n                    \n                    # Order of cross products defines ey and ez\n                    ey_unnormalized = np.cross(ref, ex)\n                    ey = ey_unnormalized / np.linalg.norm(ey_unnormalized)\n                    ez = np.cross(ex, ey)\n\n        # Reconstruct hydrogen positions in the new frame\n        r_o_prime = r_o\n        r_h1_prime = r_o - W_LEN * ex + H_LEN * ey\n        r_h2_prime = r_o + W_LEN * ex + H_LEN * ey\n\n        return r_o_prime, r_h1_prime, r_h2_prime\n\n    def calculate_errors(r_o_p, r_h1_p, r_h2_p):\n        \"\"\"Calculates the length and angle errors for a given geometry.\"\"\"\n        # Length errors\n        len_oh1 = np.linalg.norm(r_h1_p - r_o_p)\n        len_oh2 = np.linalg.norm(r_h2_p - r_o_p)\n        len_hh = np.linalg.norm(r_h1_p - r_h2_p)\n        \n        eps_len = max(abs(len_oh1 - R_OH), abs(len_oh2 - R_OH), abs(len_hh - R_HH))\n        \n        # Angle error\n        v1_p = r_h1_p - r_o_p\n        v2_p = r_h2_p - r_o_p\n        \n        cos_val = np.dot(v1_p, v2_p) / (np.linalg.norm(v1_p) * np.linalg.norm(v2_p))\n        cos_val = np.clip(cos_val, -1.0, 1.0)\n        angle_prime = np.arccos(cos_val)\n        eps_ang = abs(angle_prime - THETA_RAD)\n        \n        return eps_len, eps_ang\n\n    # Define the test cases from the problem statement.\n    p = R_OH * np.cos(THETA_RAD / 2)\n    q = R_OH * np.sin(THETA_RAD / 2)\n    \n    test_cases = [\n        # Case 1 (near-ideal with small perturbation)\n        (np.array([0.0, 0.0, 0.0]), np.array([q + 1e-4, 0.0, p]), np.array([-q - 1e-4, 0.0, p])),\n        # Case 2 (nearly coincident hydrogens)\n        (np.array([1.0, 2.0, 3.0]), np.array([1.0 + 1e-10, 2.0, 3.0]), np.array([1.0 + 1.1e-10, 2.0, 3.0])),\n        # Case 3 (antiparallel oxygen-hydrogen directions)\n        (np.array([0.0, 1.0, 0.0]), np.array([1.0, 1.0, 0.0]), np.array([-1.0, 1.0, 0.0])),\n        # Case 4 (complete degeneracy, all atoms coincident)\n        (np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 5 (large perturbation)\n        (np.array([5.0, -3.0, 2.0]), np.array([3.0, 7.0, -4.0]), np.array([-2.0, 1.0, 9.0]))\n    ]\n    \n    results = []\n    for r_o, r_h1, r_h2 in test_cases:\n        r_o_p, r_h1_p, r_h2_p = analytic_projection(r_o, r_h1, r_h2)\n        eps_len, eps_ang = calculate_errors(r_o_p, r_h1_p, r_h2_p)\n        results.extend([eps_len, eps_ang])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "An \"exact\" analytical solver like SETTLE perfectly satisfies constraints in the world of infinite-precision arithmetic, but what happens in a real computer simulation running for millions of steps? This practice problem investigates the long-term consequences of finite-precision arithmetic, modeling the accumulation of small, per-step rounding errors as a random walk. By simulating this error drift and testing renormalization strategies, you will gain crucial insight into ensuring the long-term stability and physical validity of molecular dynamics simulations using rigid water models .",
            "id": "3444630",
            "problem": "Consider a single rigid water molecule modeled in Molecular Dynamics (MD) with holonomic constraints that enforce the geometry of the water triangle. Let the positions be $\\mathbf{r} = (\\mathbf{r}_{\\mathrm{O}}, \\mathbf{r}_{\\mathrm{H}_1}, \\mathbf{r}_{\\mathrm{H}_2}) \\in \\mathbb{R}^9$, and define the three constraint functions $\\{g_i(\\mathbf{r})\\}_{i=1}^3$ corresponding to two Oxygen–Hydrogen (O–H) bond lengths and the Hydrogen–Hydrogen (H–H) separation:\n- $g_1(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2$,\n- $g_2(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2$,\n- $g_3(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}\\|^2 - d_{\\mathrm{HH}}^2$,\n\nwhere $d_{\\mathrm{OH}}$ is the O–H equilibrium distance and $d_{\\mathrm{HH}}$ is the H–H equilibrium distance implied by the Hydrogen–Oxygen–Hydrogen (H–O–H) angle $\\theta$. Assume a commonly used rigid geometry: $d_{\\mathrm{OH}} = 0.9572\\,\\mathrm{\\AA}$ and $\\theta = 104.52^\\circ$. Use the law of cosines to express $d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta)$, and work in International System of Units (SI), i.e., convert distances to meters and report squared distances in $\\mathrm{m}^2$. Angles must be handled in radians in any computation.\n\nIn a constrained MD integrator with holonomic constraints enforced at each time step by an analytic solver such as SETTLE (a fast exact constraint solver for rigid water), the theoretical constraints $g_i(\\mathbf{r}) = 0$ are satisfied at each step. However, finite-precision arithmetic introduces rounding errors. Model the per-step constraint residual perturbation as a zero-mean random increment $\\delta g_i^{(n)}$ with magnitude scaling like $\\sigma_i \\propto \\epsilon \\, s_i$, where $\\epsilon$ is the machine epsilon of the floating-point type and $s_i$ is a characteristic scale of $g_i$. For this rigid triangle, take $s_1 = d_{\\mathrm{OH}}^2$, $s_2 = d_{\\mathrm{OH}}^2$, and $s_3 = d_{\\mathrm{HH}}^2$. The cumulative constraint residual then evolves as a stochastic recurrence $e_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}$, optionally reset by a renormalization strategy every $K$ steps. Define the constraint satisfaction error at step $n$ as $\\max_i |g_i(\\mathbf{r}^{(n)})|$, and in this model take $g_i(\\mathbf{r}^{(n)}) \\approx e_i^{(n)}$.\n\nYour task is to:\n- Simulate the accumulation of the constraint satisfaction error over $N = 10^7$ steps for two different floating-point precisions: single precision ($\\epsilon_{\\mathrm{single}}$) and double precision ($\\epsilon_{\\mathrm{double}}$).\n- Compare two periodic renormalization strategies executed every $K$ steps:\n    1. Full projection: set all $e_i^{(n)} \\leftarrow 0$ at renormalization steps.\n    2. Bond-only projection: set $e_1^{(n)} \\leftarrow 0$ and $e_2^{(n)} \\leftarrow 0$ at renormalization steps, but leave $e_3^{(n)}$ unchanged.\n- For each case, measure the single scalar value $\\max_{0 \\le n < N} \\max_{i \\in \\{1,2,3\\}} |e_i^{(n)}|$ in $\\mathrm{m}^2$, as a floating-point number.\n\nFundamental base to use:\n- Newton’s second law $m \\,\\frac{d^2 \\mathbf{r}}{dt^2} = \\mathbf{F}$ for unconstrained dynamics.\n- Holonomic constraint enforcement via Lagrange multipliers and projection, guaranteeing $g_i(\\mathbf{r}) = 0$ in exact arithmetic.\n- Finite-precision rounding modeled as a zero-mean random process with characteristic scale proportional to machine epsilon and the magnitude of the constrained quantity.\n- Law of cosines for triangle geometry.\n\nYou must implement a purely numerical simulation of the stochastic accumulation $e_i^{(n)}$ under the specified renormalization, using a reproducible pseudo-random number generator. Do not assume any closed-form for the supremum; compute it numerically using vectorized operations and block processing to remain efficient for $N = 10^7$.\n\nUnits and angle specification:\n- Convert $d_{\\mathrm{OH}} = 0.9572\\,\\mathrm{\\AA}$ to meters before squaring. $1\\,\\mathrm{\\AA} = 10^{-10}\\,\\mathrm{m}$.\n- Convert $\\theta = 104.52^\\circ$ to radians before computing $\\cos\\theta$.\n\nTest suite:\nProvide results for the following parameter sets, each reported as a single float in $\\mathrm{m}^2$:\n1. Precision: single, renormalization period $K = N$ (i.e., no renormalization), full projection.\n2. Precision: single, renormalization period $K = 1000$, full projection.\n3. Precision: double, renormalization period $K = N$ (i.e., no renormalization), full projection.\n4. Precision: double, renormalization period $K = 100000$, full projection.\n5. Precision: single, renormalization period $K = 1$, bond-only projection.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_j$ is the maximum error for test case $j$ as a float in $\\mathrm{m}^2$.",
            "solution": "The user wants to solve a problem on simulating the accumulation of constraint satisfaction errors in a Molecular Dynamics (MD) simulation of a rigid water molecule.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n-   **Model:** Single rigid water molecule in Molecular Dynamics (MD).\n-   **Holonomic Constraints:**\n    -   $g_1(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_1} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2 = 0$\n    -   $g_2(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{O}}\\|^2 - d_{\\mathrm{OH}}^2 = 0$\n    -   $g_3(\\mathbf{r}) = \\|\\mathbf{r}_{\\mathrm{H}_2} - \\mathbf{r}_{\\mathrm{H}_1}\\|^2 - d_{\\mathrm{HH}}^2 = 0$\n-   **Geometric Parameters:**\n    -   O-H equilibrium distance: $d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA}$\n    -   H-O-H angle: $\\theta = 104.52^\\circ$\n-   **Derived Parameter:** $d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta)$\n-   **Units:** Work in SI units. Convert $\\text{\\AA}$ to meters, degrees to radians. Report results in $\\text{m}^2$.\n-   **Error Model:**\n    -   Constraint residual perturbation per step: $\\delta g_i^{(n)}$\n    -   $\\delta g_i^{(n)}$ is a zero-mean random increment.\n    -   Magnitude scaling: $\\sigma_i \\propto \\epsilon \\, s_i$, where $\\epsilon$ is machine epsilon.\n    -   Characteristic scales: $s_1 = d_{\\mathrm{OH}}^2$, $s_2 = d_{\\mathrm{OH}}^2$, and $s_3 = d_{\\mathrm{HH}}^2$.\n-   **Error Evolution:**\n    -   Cumulative constraint residual: $e_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}$.\n    -   Approximation: $g_i(\\mathbf{r}^{(n)}) \\approx e_i^{(n)}$.\n    -   Total steps: $N = 10^7$.\n-   **Renormalization Strategies:** Executed every $K$ steps.\n    1.  **Full projection:** set all $e_i^{(n)} \\leftarrow 0$ at renormalization steps.\n    2.  **Bond-only projection:** set $e_1^{(n)} \\leftarrow 0$ and $e_2^{(n)} \\leftarrow 0$ at renormalization steps, but leave $e_3^{(n)}$ unchanged.\n-   **Task:**\n    -   Simulate error accumulation for two floating-point precisions (single, double).\n    -   Compare the two renormalization strategies.\n    -   Measure the single scalar value $\\max_{0 \\le n < N} \\max_{i \\in \\{1,2,3\\}} |e_i^{(n)}|$ in $\\text{m}^2$.\n-   **Implementation:** Use a reproducible pseudo-random number generator and efficient, vectorized operations.\n-   **Test Suite:** Five specific parameter sets combining precision, renormalization period $K$, and projection strategy.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding:** The problem is firmly rooted in the principles of computational physics and chemistry, specifically molecular dynamics. The use of constraint algorithms like SETTLE, the concept of holonomic constraints, and the modeling of numerical precision errors are all standard topics in the field. The provided parameters for water geometry are standard (e.g., TIP3P or SPC/E models). The model of error accumulation as a random walk is a valid and common simplification used in numerical analysis. The setup is scientifically sound.\n-   **Well-Posedness:** The problem is largely well-posed. It defines a stochastic process and requests a numerical estimate of a specific statistic (the maximum of the trajectory) from a simulation. A minor ambiguity exists in the statement \"magnitude scaling like $\\sigma_i \\propto \\epsilon \\, s_i$\", which does not specify the constant of proportionality or the exact probability distribution of the random increments. However, this is a typical situation in physics-based modeling where reasonable assumptions must be made. Assuming a proportionality constant of $1$ and a standard uniform distribution (e.g., $U[-\\sigma_i, \\sigma_i]$) is a defensible choice that allows for a unique numerical solution. The requirement for a reproducible pseudo-random number generator confirms that a specific numerical answer is expected.\n-   **Objectivity & Completeness:** The problem is stated in objective, quantitative terms. All necessary parameters ($d_{\\mathrm{OH}}, \\theta, N, K$, precisions) are provided. The tasks are unambiguous. The setup is self-contained and free of contradictions.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed valid. It is a well-defined computational problem that tests the understanding of error propagation in numerical simulations and requires an efficient implementation. The minor ambiguity in the error model is acceptable as it requires making a standard, justifiable modeling choice.\n\n### **Solution Procedure**\n\nThe core of the problem is to simulate a stochastic process representing the accumulation of numerical errors in the constraint equations of a rigid water molecule. The state of the system at step $n$ is the vector of constraint violations, $e^{(n)} = (e_1^{(n)}, e_2^{(n)}, e_3^{(n)})$, which evolves according to the recurrence relation:\n$$\ne_i^{(n+1)} = e_i^{(n)} + \\delta g_i^{(n)}\n$$\nstarting from $e^{(0)} = (0, 0, 0)$.\n\n**1. Modeling the Error Term**\nThe per-step error increment $\\delta g_i^{(n)}$ is a random variable. The problem states it is zero-mean and its magnitude scales as $\\sigma_i \\propto \\epsilon s_i$. We will make the standard and reasonable assumption that the proportionality constant is $1$, so the scale is $\\sigma_i = \\epsilon s_i$. We model the increment as a uniformly distributed random variable, $\\delta g_i^{(n)} \\sim U[-\\sigma_i, \\sigma_i]$. This choice provides a simple yet representative model for symmetric rounding errors.\n\n**2. Calculation of Physical Scales**\nFirst, all parameters are converted to SI units.\n-   The O-H bond length is $d_{\\mathrm{OH}} = 0.9572\\,\\text{\\AA} = 0.9572 \\times 10^{-10}\\,\\text{m}$.\n-   The H-O-H bond angle is $\\theta = 104.52^\\circ$, which is converted to radians for trigonometric functions: $\\theta_{\\text{rad}} = 104.52 \\times \\frac{\\pi}{180}$.\n-   The characteristic scales $s_i$ for the squared-distance constraints are:\n    -   $s_1 = s_2 = d_{\\mathrm{OH}}^2 = (0.9572 \\times 10^{-10})^2\\,\\text{m}^2 \\approx 9.1623 \\times 10^{-21}\\,\\text{m}^2$.\n    -   $s_3 = d_{\\mathrm{HH}}^2 = 2 d_{\\mathrm{OH}}^2 (1 - \\cos\\theta_{\\text{rad}}) \\approx 2.2917 \\times 10^{-20}\\,\\text{m}^2$.\n\n**3. Floating-Point Precision and Perturbation Scales**\nThe machine epsilon, $\\epsilon$, depends on the floating-point precision:\n-   Single precision (`float32`): $\\epsilon_{\\text{single}} \\approx 1.192 \\times 10^{-7}$.\n-   Double precision (`float64`): $\\epsilon_{\\text{double}} \\approx 2.220 \\times 10^{-16}$.\n\nThe perturbation scales $\\sigma_i = \\epsilon s_i$ are then calculated for each precision. For single precision, $\\sigma_1 = \\sigma_2 \\approx 1.09 \\times 10^{-27}\\,\\text{m}^2$ and $\\sigma_3 \\approx 2.73 \\times 10^{-27}\\,\\text{m}^2$. For double precision, these scales are many orders of magnitude smaller.\n\n**4. Simulation Algorithm (General Case)**\nA direct step-by-step simulation for $N=10^7$ steps would be inefficient in Python. As suggested, a vectorized, block-based approach is used. The simulation is structured to process data in chunks corresponding to the renormalization period $K$. This is efficient because the Python loop runs only $N/K$ times, and each iteration performs fast, vectorized operations in NumPy on arrays of size $K$.\n\nThe algorithm proceeds as follows for a given test case:\n1.  Initialize error vector $e = (0,0,0)$ and overall maximum absolute error `max_abs_error = 0`. A reproducible pseudo-random number generator is seeded.\n2.  Loop while the total number of steps processed is less than $N$. In each loop iteration, a \"cycle\" of at most $K$ steps is simulated.\n3.  Generate an array of $K$ random increments $(\\delta g^{(n)})$ for each of the $3$ constraints using `numpy.random.uniform`.\n4.  Calculate the trajectory of the error vector within this cycle using `numpy.cumsum`. The initial error for the cycle is the final error from the previous one.\n5.  Update the `max_abs_error` by finding the maximum absolute value within the newly generated part of the trajectory.\n6.  The error vector $e$ is updated to the last value of the cycle's trajectory.\n7.  At the end of the cycle (if `K` steps were taken), the error vector $e$ is reset according to the specified renormalization strategy ('full' or 'bond-only').\n\n**5. Simulation Algorithm (Special Case $K=1$)**\nTest case 5, with $K=1$ and 'bond-only' projection, represents a distinct scenario that permits a more efficient, fully vectorized implementation.\n-   The projection `bond-only` at $K=1$ means that at every step, $e_1$ and $e_2$ are reset to $0$. Thus, their error does not accumulate: $e_{1,2}^{(n)} = \\delta g_{1,2}^{(n)}$. The maximum error for these components is simply the largest magnitude of any random increment drawn over $N$ steps.\n-   The third component, $e_3$, is never reset. It undergoes a standard random walk for all $N$ steps: $e_3^{(n)} = \\sum_{j=0}^{n-1} \\delta g_3^{(j)}$.\n-   The overall maximum error is therefore $\\max\\left( \\max_{n, i \\in \\{1,2\\}} |\\delta g_i^{(n)}|, \\max_{n} |e_3^{(n)}| \\right)$.\n-   This can be calculated very efficiently by generating all $N$ random increments for all $3$ components in a single operation, then computing the maximum of the absolute values for components $1$ and $2$, and the maximum of the absolute values of the cumulative sum for component $3$.\n\nThese two algorithmic approaches allow for the efficient and accurate simulation of all five test cases as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation_generic(precision: str, K: int, strategy: str, N: int, seed: int) -> float:\n    \"\"\"\n    Simulates error accumulation for the general case using K-step cycles.\n    \"\"\"\n    if precision == 'single':\n        dtype = np.float32\n    else:\n        dtype = np.float64\n    epsilon = np.finfo(dtype).eps\n\n    d_OH = 0.9572e-10  # meters\n    theta_deg = 104.52\n    theta_rad = np.deg2rad(theta_deg)\n\n    s1 = dtype(d_OH**2)\n    s2 = s1\n    s3 = dtype(2 * s1 * (1 - np.cos(theta_rad)))\n    scales = np.array([s1, s2, s3], dtype=dtype)\n    sigmas = epsilon * scales\n\n    rng = np.random.default_rng(seed)\n    e = np.zeros(3, dtype=dtype)\n    max_abs_error = dtype(0.0)\n\n    num_steps_processed = 0\n    while num_steps_processed < N:\n        steps_in_cycle = min(K, N - num_steps_processed)\n        \n        deltas = rng.uniform(-sigmas, sigmas, size=(steps_in_cycle, 3)).astype(dtype)\n\n        cycle_errors = e + np.cumsum(deltas, axis=0)\n        \n        if steps_in_cycle > 0:\n            current_max = np.max(np.abs(cycle_errors))\n            max_abs_error = np.maximum(max_abs_error, current_max)\n        \n        if steps_in_cycle > 0:\n            e = cycle_errors[-1]\n            \n        num_steps_processed += steps_in_cycle\n\n        if num_steps_processed % K == 0 and num_steps_processed < N:\n            if strategy == 'full':\n                e[:] = 0.0\n            elif strategy == 'bond-only':\n                e[0:2] = 0.0\n    \n    return float(max_abs_error)\n\n\ndef run_simulation_case5(precision: str, N: int, seed: int) -> float:\n    \"\"\"\n    Simulates error accumulation for the special case with K=1 and bond-only projection.\n    \"\"\"\n    if precision == 'single':\n        dtype = np.float32\n    else: # double\n        dtype = np.float64\n    epsilon = np.finfo(dtype).eps\n\n    d_OH = 0.9572e-10  # meters\n    theta_deg = 104.52\n    theta_rad = np.deg2rad(theta_deg)\n\n    s1 = dtype(d_OH**2)\n    s2 = s1\n    s3 = dtype(2 * s1 * (1 - np.cos(theta_rad)))\n    scales = np.array([s1, s2, s3], dtype=dtype)\n    sigmas = epsilon * scales\n\n    rng = np.random.default_rng(seed)\n    \n    deltas = rng.uniform(-sigmas, sigmas, size=(N, 3)).astype(dtype)\n    \n    # For components 1 and 2, error is reset every step, so e_i(n) = delta_i(n).\n    max_abs_e12 = np.max(np.abs(deltas[:, 0:2])) if N > 0 else dtype(0.0)\n    \n    # For component 3, error accumulates in a random walk.\n    e3_walk = np.cumsum(deltas[:, 2])\n    max_abs_e3 = np.max(np.abs(e3_walk)) if N > 0 else dtype(0.0)\n\n    return float(np.maximum(max_abs_e12, max_abs_e3))\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    N_steps = 10**7\n\n    test_cases = [\n        {'precision': 'single', 'K': N_steps, 'strategy': 'full'},\n        {'precision': 'single', 'K': 1000, 'strategy': 'full'},\n        {'precision': 'double', 'K': N_steps, 'strategy': 'full'},\n        {'precision': 'double', 'K': 100000, 'strategy': 'full'},\n        {'precision': 'single', 'K': 1, 'strategy': 'bond-only'},\n    ]\n\n    results = []\n    # Use a different seed for each case to ensure statistical independence\n    # while maintaining reproducibility for each case individually.\n    base_seed = 42\n\n    for i, case in enumerate(test_cases):\n        seed = base_seed + i\n        if case['K'] == 1 and case['strategy'] == 'bond-only':\n            # Use the specialized, efficient function for Case 5\n            result = run_simulation_case5(case['precision'], N_steps, seed)\n        else:\n            # Use the generic function for all other cases\n            result = run_simulation_generic(case['precision'], case['K'], case['strategy'], N_steps, seed)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}