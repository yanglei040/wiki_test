{
    "hands_on_practices": [
        {
            "introduction": "LINCS 算法的核心是其对约束耦合矩阵逆的级数近似。然而，当分子几何结构导致约束之间近似线性相关时，这个近似的收敛性就会受到破坏。本练习将引导您构建一个可参数化的分子系统，通过调节参数使其接近奇异构型，并从数值上观察 LINCS 稳定性指标的变化，从而深入理解算法的内在局限性 。",
            "id": "3421489",
            "problem": "您需要通过构建一个刻意引入近似相关约束行的小分子几何结构，来分析分子动力学中线性约束求解器 (Linear Constraint Solver, LINCS) 约束投影的稳定性。从经典力学和完整约束的基本原理出发，推导评估基于 Neumann 级数的 LINCS 定点校正稳定性所需的代数对象。然后，针对一个趋近于奇异构型的参数化几何族，实现并执行推导出的公式。\n\n考虑一个三维空间中由 $N=4$ 个质量均为 $m$ 的质点组成的系统。设位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，$i \\in \\{1,2,3,4\\}$。我们指定参数化几何结构\n$$\n\\mathbf{r}_1 = (0,0,0),\\quad\n\\mathbf{r}_2 = (1,\\varepsilon,0),\\quad\n\\mathbf{r}_3 = (2,0,0),\\quad\n\\mathbf{r}_4 = (3,\\varepsilon,0),\n$$\n参数 $\\varepsilon \\ge 0$。当 $\\varepsilon$ 很小时，这会形成一个近似共线的链。施加 $K=5$ 个固定键长约束，对应于原子对\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4),\n$$\n这些约束被解释为 $g_k(\\mathbf{q}) = 0$ 形式的完整约束，其中 $g_k(\\mathbf{q})$ 强制原子对之间的平方距离为固定值，即对于原子对 $(i,j)$，约束为 $g_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2=0$。此处 $\\mathbf{q}$ 堆叠了所有原子的笛卡尔坐标，$d_{ij}$ 是原子对 $(i,j)$ 的目标键长。使用上述瞬时几何结构来定义目标距离 $d_{ij}$，从而使得初始时所有约束都被精确满足。\n\n从牛顿第二定律和带拉格朗日乘子的完整约束出发，并处理 $g_k(\\mathbf{q})=0$ 在笛卡尔坐标下的线性化，执行以下推导和计算：\n\n1. 推导约束雅可比矩阵 $J \\in \\mathbb{R}^{K \\times 3N}$，其第 $k$ 行为在给定几何结构下求值的梯度 $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})$。对于原子对 $(i,j)$，非零块应反映对 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的依赖关系。使用平方距离形式，使得块梯度分别与 $(\\mathbf{r}_i - \\mathbf{r}_j)$ 和 $(\\mathbf{r}_j - \\mathbf{r}_i)$ 成正比。\n\n2. 引入对角线上元素为相同质量 $m$ 的对角质量矩阵 $M \\in \\mathbb{R}^{3N \\times 3N}$。从线性化的约束冲量平衡中，确定对称半正定矩阵\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K}.\n$$\n\n3. 归一化 $S_{\\mathrm{raw}}$ 以获得一个对角线元素为单位元的耦合矩阵。定义 $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ 并构造\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\n这种归一化产生一个对角线元素等于 $1$ 的矩阵 $S$。\n\n4. 考虑在线性约束求解器 (LINCS) 中使用的定点（Neumann 级数）近似，其中 $S$ 的逆通过矩阵 $C = I - S$ 的截断级数来近似。根据 $(I - C)^{-1}$ 的 Neumann 级数，收敛判据要求谱半径 $\\rho(C)  1$。利用此原理，将谱半径 $\\rho(C)$ 定义为稳定性度量。\n\n5. 实现一个程序，对于质量选择 $m=1$（无量纲），为参数值 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$ 构建几何结构，形成 $J$，构建 $S_{\\mathrm{raw}}$，归一化为 $S$，计算 $C=I-S$，并返回每个 $\\varepsilon$ 对应的谱半径 $\\rho(C)$。\n\n6. 科学和数值预期：当 $\\varepsilon \\to 0$ 时，闭环中的约束变得近似冗余，$J$ 的行变得近似线性相关，使得 $S$ 近似奇异。因此，您应该会看到 $\\rho(C)$ 趋近或超过 $1$，这预示着 Neumann 级数停止收敛，LINCS 可能失效。\n\n您的程序必须精确实现上述推导，并输出三个参数值的结果。此问题中没有物理单位；将所有量视为无量纲数。输出必须是单行，包含一个用方括号括起来的逗号分隔列表。列表必须按 $[\\rho(C;\\varepsilon{=}0.2),\\rho(C;\\varepsilon{=}0.02),\\rho(C;\\varepsilon{=}0.0)]$ 的顺序列出，其中每个条目都是一个四舍五入到小数点后恰好六位的浮点数。例如，输出行可能看起来像 `[0.123456,0.987654,1.234567]`。\n\n测试套件涵盖不同情况：\n- $\\varepsilon=0.2$ 的规则、良态几何结构（正常路径）。\n- $\\varepsilon=0.02$ 的近奇异几何结构（接近失效）。\n- $\\varepsilon=0.0$ 的精确共线几何结构（秩亏的边界情况）。\n\n您的程序应按照上述确切格式生成单行输出。",
            "solution": "我们从经典力学和完整约束出发，构建线性约束求解器 (Linear Constraint Solver, LINCS) 的稳定性分析，然后将其简化为关于一个耦合矩阵的代数条件。\n\n我们考虑 $N=4$ 个质量均为 $m$ 的质点。设 $\\mathbf{q} \\in \\mathbb{R}^{3N}$ 是通过堆叠 $\\mathbf{r}_1,\\dots,\\mathbf{r}_N$ 得到的笛卡尔坐标。我们施加 $K=5$ 个 $g_k(\\mathbf{q})=0$ 形式的完整约束，每个约束为原子对 $(i,j)$ 的固定平方距离：\n$$\ng_{ij}(\\mathbf{q}) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2.\n$$\n我们选择 $d_{ij}$ 等于所构建几何结构中的瞬时距离，因此初始时 $g_{ij}(\\mathbf{q})=0$。$g_{ij}$ 相对于 $\\mathbf{q}$ 的梯度集中在原子 $i$ 和 $j$ 上：\n$$\n\\nabla_{\\mathbf{r}_i} g_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\nabla_{\\mathbf{r}_j} g_{ij} = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\nabla_{\\mathbf{r}_k} g_{ij} = \\mathbf{0}\\ \\text{for}\\ k \\notin \\{i,j\\}.\n$$\n将所有约束的这些行梯度堆叠起来，得到雅可比矩阵 $J \\in \\mathbb{R}^{K \\times 3N}$，其中第 $k$ 行为 $\\nabla_{\\mathbf{q}} g_k(\\mathbf{q})^\\top$。\n\n根据带完整约束的牛顿第二定律，约束冲量强制满足：\n$$\nM \\Delta \\dot{\\mathbf{q}} = \\mathbf{f}\\Delta t + J^\\top \\boldsymbol{\\lambda},\\quad \\text{with}\\quad J \\Delta \\mathbf{q} = -\\mathbf{g},\n$$\n其中 $M \\in \\mathbb{R}^{3N \\times 3N}$ 是对角质量矩阵，$\\boldsymbol{\\lambda} \\in \\mathbb{R}^{K}$ 是拉格朗日乘子，$\\mathbf{g}$ 是当前约束值。在时间上进行线性化并消去 $\\Delta \\mathbf{q}$ 或 $\\Delta \\dot{\\mathbf{q}}$，会得到一个关于 $\\boldsymbol{\\lambda}$ 的、包含 $J M^{-1} J^\\top$ 的对称系统。核心矩阵是\n$$\nS_{\\mathrm{raw}} = J M^{-1} J^\\top \\in \\mathbb{R}^{K \\times K},\n$$\n这是一个对称半正定矩阵。如果约束梯度是线性无关的，那么 $S_{\\mathrm{raw}}$ 是对称正定的。\n\n为了模拟线性约束求解器 (LINCS) 中固有的归一化，我们将行缩放至单位质量加权范数。令 $D = \\mathrm{diag}(S_{\\mathrm{raw}})$ 为包含逐行二次型的对角矩阵，并定义归一化的耦合矩阵\n$$\nS = D^{-1/2} S_{\\mathrm{raw}} D^{-1/2}.\n$$\n根据构造，$S$ 的对角线元素为单位元，即对所有 $k$ 都有 $S_{kk} = 1$。在这种表示中，非对角元素度量了约束之间的两两耦合。\n\n线性约束求解器 (LINCS) 通过一个截断的 Neumann 级数来近似 $S^{-1}$。令\n$$\nC = I - S.\n$$\n如果谱半径 $\\rho(C)  1$，那么 Neumann 级数收敛，并且\n$$\nS^{-1} = (I - C)^{-1} = \\sum_{\\ell=0}^{\\infty} C^\\ell,\n$$\n在 $p$ 阶截断会产生一个误差，该误差在一个相容的算子范数下的界为\n$$\n\\left\\| \\sum_{\\ell=p+1}^{\\infty} C^\\ell \\right\\| \\le \\frac{\\|C\\|^{p+1}}{1 - \\|C\\|},\\quad \\text{valid when}\\ \\|C\\|1.\n$$\n因此，关键的稳定性度量是 $\\rho(C)$：如果 $\\rho(C) \\ge 1$，级数不收敛，LINCS 在原则上失效；如果 $\\rho(C)$ 接近 $1$，截断误差会变得很大。\n\n我们现在构造参数化几何结构以趋近秩亏。将原子置于\n$$\n\\mathbf{r}_1 = (0,0,0),\\ \n\\mathbf{r}_2 = (1,\\varepsilon,0),\\ \n\\mathbf{r}_3 = (2,0,0),\\ \n\\mathbf{r}_4 = (3,\\varepsilon,0),\n$$\n其中 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$。约束形成一个环：\n$$\n(1,2),\\ (2,3),\\ (3,4),\\ (1,3),\\ (2,4).\n$$\n当 $\\varepsilon \\to 0$ 时，所有四个原子都位于一条直线上。在该极限下，约束梯度成为环周围的近似共线组合。更精确地说，考虑 $J$ 中对应于这些约束的行向量；环的闭合在共线几何结构中引入了这些行向量之间的近似线性相关性。因此，$S_{\\mathrm{raw}}$ 变得近似奇异，并且由于 $S$ 是 $S_{\\mathrm{raw}}$ 的归一化版本，$S$ 的最小特征值趋于 $0$。$C = I - S$ 的特征值是 $1 - \\lambda_i(S)$。因此，当最小的 $\\lambda_i(S) \\to 0$ 时，$C$ 的一个特征值会趋近于 $1$，所以 $\\rho(C) \\to 1$，或者如果某个 $\\lambda_i(S) > 2$，$\\rho(C)$ 可能超过 $1$。这反映了 Neumann 级数收敛性的丧失以及 LINCS 在近奇异几何结构下的实际失效。\n\n实现的计算细节：\n- 设置 $m=1$，因此 $M=I$ 且 $S_{\\mathrm{raw}} = J J^\\top$。\n- 对于每个约束 $(i,j)$，通过放置以下项来构造 $J$\n$$\n\\text{row}_{ij}[\\mathbf{r}_i] = 2(\\mathbf{r}_i - \\mathbf{r}_j),\\quad\n\\text{row}_{ij}[\\mathbf{r}_j] = 2(\\mathbf{r}_j - \\mathbf{r}_i),\\quad\n\\text{其他位置为零}.\n$$\n- 形成 $S_{\\mathrm{raw}}$，计算 $D$ 和 $S$，然后计算 $C = I - S$。\n- 将 $\\rho(C)$ 计算为 $C$ 的特征值中的最大绝对值。\n- 以要求格式报告三个值 $\\rho(C;\\varepsilon)$（对于 $\\varepsilon \\in \\{0.2, 0.02, 0.0\\}$），每个值四舍五入到小数点后 6 位。\n\n定性结果：\n- 对于 $\\varepsilon = 0.2$，几何结构是良态的；我们预期 $\\rho(C)$ 远小于 $1$。\n- 对于 $\\varepsilon = 0.02$，几何结构是近奇异的；我们预期 $\\rho(C)$ 接近 $1$。\n- 对于 $\\varepsilon = 0.0$，几何结构是精确共线的；我们预期 $S$ 至少有一个特征值为零，因此 $C$ 有一个特征值等于 $1$，使得 $\\rho(C) \\ge 1$ 并指示失效。\n\n所提供的程序相应地构造矩阵并计算谱半径，生成包含三个四舍五入到小数点后六位的浮点数的单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef build_geometry(epsilon: float):\n    # Four atoms with small zig-zag in y to control near-colinearity\n    r1 = np.array([0.0, 0.0, 0.0])\n    r2 = np.array([1.0, epsilon, 0.0])\n    r3 = np.array([2.0, 0.0, 0.0])\n    r4 = np.array([3.0, epsilon, 0.0])\n    R = np.vstack([r1, r2, r3, r4])  # shape (4,3)\n    return R\n\ndef constraints_pairs():\n    # Pairs: (1,2),(2,3),(3,4),(1,3),(2,4) using 0-based indexing\n    return [(0,1),(1,2),(2,3),(0,2),(1,3)]\n\ndef build_J(R: np.ndarray, pairs):\n    N = R.shape[0]\n    K = len(pairs)\n    J = np.zeros((K, 3*N), dtype=float)\n    for k, (i, j) in enumerate(pairs):\n        rij = R[i] - R[j]\n        # Gradient for squared-distance constraint: 2*(ri - rj) and 2*(rj - ri)\n        gi = 2.0 * rij\n        gj = -2.0 * rij\n        # Place into row k at blocks for atoms i and j\n        J[k, 3*i:3*i+3] = gi\n        J[k, 3*j:3*j+3] = gj\n    return J\n\ndef normalized_S(J: np.ndarray, mass: float = 1.0):\n    # M = m * I, so M^{-1} = (1/m) * I; thus S_raw = (1/m) * J J^T\n    S_raw = (J @ J.T) / mass\n    # Normalize to unit diagonal: S = D^{-1/2} S_raw D^{-1/2}\n    d = np.diag(S_raw).copy()\n    # Guard against numerical zeros on diagonal (should not occur since rows nonzero)\n    d_sqrt_inv = 1.0 / np.sqrt(d)\n    D_half_inv = np.diag(d_sqrt_inv)\n    S = D_half_inv @ S_raw @ D_half_inv\n    return S\n\ndef spectral_radius_C(S: np.ndarray):\n    # C = I - S; compute spectral radius of C (max abs eigenvalue)\n    K = S.shape[0]\n    C = np.eye(K) - S\n    # Use eigh for symmetric matrix to improve numerical stability\n    evals = np.linalg.eigvalsh(C)\n    rho = float(np.max(np.abs(evals)))\n    return rho\n\ndef compute_rho_for_epsilon(epsilon: float):\n    R = build_geometry(epsilon)\n    pairs = constraints_pairs()\n    J = build_J(R, pairs)\n    S = normalized_S(J, mass=1.0)\n    rho = spectral_radius_C(S)\n    return rho\n\ndef solve():\n    test_cases = [0.2, 0.02, 0.0]\n    results = []\n    for eps in test_cases:\n        rho = compute_rho_for_epsilon(eps)\n        results.append(rho)\n    # Format with exactly six digits after decimal, no spaces\n    out = \"[\" + \",\".join(f\"{x:.6f}\" for x in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了几何奇异性，约束系统中常见的另一个数值挑战来自于原子质量的巨大差异，例如在生物分子模拟中，氢原子与其连接的重原子。这种质量比会恶化约束耦合矩阵的条件数，威胁到 LINCS 算法的稳定性。本练习不仅将演示此问题，还将指导您实施一种实用的质量缩放策略 ，这是现代分子动力学软件中确保模拟稳健性的关键技术。",
            "id": "3421519",
            "problem": "考虑一个质点系统，其位置为 $\\mathbf{q} \\in \\mathbb{R}^{3N}$，质量为 $m_i > 0$（$i \\in \\{1,\\dots,N\\}$），该系统在牛顿第二定律下演化，并受完整键长约束 $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$（$k \\in \\{1,\\dots,n_c\\}$），其中 $a(k), b(k) \\in \\{1,\\dots,N\\}$ 是原子索引，$\\mathbf{r}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置，$\\ell_k > 0$ 是约束 $k$ 的目标键长。令 $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$ 为约束相对于 $\\mathbf{q}$ 的雅可比矩阵，令 $M \\in \\mathbb{R}^{3N \\times 3N}$ 为对角质量矩阵，$M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$。质量加权约束耦合矩阵定义为 $C(\\mathbf{q}, M) = G(\\mathbf{q}) M^{-1} G(\\mathbf{q})^\\top \\in \\mathbb{R}^{n_c \\times n_c}$。定义严格非对角、对称归一化的耦合矩阵 $S \\in \\mathbb{R}^{n_c \\times n_c}$ 如下\n$$\nS_{ij} =\n\\begin{cases}\n\\displaystyle \\frac{C_{ij}}{\\sqrt{C_{ii}\\, C_{jj}}},  i \\neq j, \\\\\n0,  i = j.\n\\end{cases}\n$$\n用于约束分子动力学的线性约束求解器 (Linear Constraint Solver, LINCS) 算法使用截断的诺伊曼级数来近似一个预处理系统的逆，该级数的收敛性和稳定性由谱半径 $\\rho(S)$ 控制。\n\n任务：从以上定义出发，分析极端质量比（例如，一个轻原子连接到重邻居，使得 $m_{\\mathrm{light}}/m_{\\mathrm{heavy}} \\to 0$）对 $S$ 的元素及其谱半径 $\\rho(S)$ 的影响。基于此分析，提出并实现一个稳健的质量缩放策略，通过修改一部分原子的质量，将 $\\rho(S)$ 控制在预设目标 $\\rho_{\\mathrm{target}} \\in (0,1)$ 的范围内。您的策略必须：\n- 从第一性原理推导为什么增加由多个约束共享的原子的质量会减小 $S$ 中非对角元素的大小，并单调减小 $\\rho(S)$。\n- 仅使用 $G(\\mathbf{q})$ 中的几何信息和 $M$ 的对角质量结构。\n- 是建设性的且数值上可实现的：对于给定的 $\\rho_{\\mathrm{target}}$，返回一组针对选定原子子集的缩放后质量 $\\tilde{m}_i \\ge m_i$，确保 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$，其中 $\\tilde{M} = \\mathrm{diag}(\\tilde{m}_1 I_3,\\dots,\\tilde{m}_N I_3)$。\n\n您的程序应遵循的实现细节：\n1. 构造 $G(\\mathbf{q})$：对于原子 $a$ 和 $b$ 之间的每个约束 $k$，构造一个行向量，其中对应于原子 $a$ 的列的 3 维向量块为 $(\\mathbf{r}_a - \\mathbf{r}_b)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$，对应于原子 $b$ 的块为 $(\\mathbf{r}_b - \\mathbf{r}_a)/\\|\\mathbf{r}_a - \\mathbf{r}_b\\|$，其他位置为零。\n2. 构造 $C = G M^{-1} G^\\top$，然后如上构造 $S$。计算 $\\rho(S)$ 为 $S$ 的最大绝对值特征值。\n3. 提出一个稳健的质量缩放策略，该策略针对至少与两个约束相关联的原子，并将其质量统一增加到一个下限值 $\\mu$（其他质量保持不变），即对这些原子有 $\\tilde{m}_i = \\max\\{m_i, \\mu\\}$，其中 $\\mu$ 的选择应是能确保 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$ 的最小值。您的程序应通过数值稳定的一维搜索来确定 $\\mu$，并输出缩放前后的谱半径。\n\n科学假设与要求：\n- 最终结果中仅使用无量纲量；不需要物理单位。\n- 如果构建几何形状需要角度，则角度必须隐式地以弧度为单位；然而，在本问题中，几何形状由笛卡尔坐标指定，因此不需要显式计算角度。\n- 所有数值结果必须以双精度计算。\n- 确保所有构造的构型在物理上是合理的：所有键长必须为严格正值。\n\n要实现和评估的测试套件：\n您的程序必须硬编码并评估以下四个测试用例，每个用例由 $(\\mathbf{q}, \\text{约束}, m, \\rho_{\\mathrm{target}})$ 指定：\n\n- 用例 A（线性三原子分子，中心原子较轻）：\n  - 原子数 $N = 3$，位置为 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$。\n  - 约束：键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.1, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 B（直角三原子分子，中心原子极轻）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1,1,0)$。\n  - 约束：键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.001, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 C（线性四原子链，两个内部原子较轻）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (2,0,0)$, $\\mathbf{r}_4 = (3,0,0)$。\n  - 约束：键 $(1,2)$, $(2,3)$, $(3,4)$。\n  - 质量：$m = [12.0, 0.1, 0.1, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n- 用例 D（弯曲三原子分子，中心夹角约为 $150^\\circ$ 的钝角，中心原子较轻）：\n  - 位置 $\\mathbf{r}_1 = (0,0,0)$, $\\mathbf{r}_2 = (1,0,0)$, $\\mathbf{r}_3 = (1 + \\cos(30^\\circ), \\sin(30^\\circ), 0)$，即 $\\mathbf{r}_3 = (1 + \\sqrt{3}/2, 1/2, 0)$。\n  - 约束：键 $(1,2)$ 和 $(2,3)$。\n  - 质量：$m = [12.0, 0.05, 12.0]$。\n  - 目标：$\\rho_{\\mathrm{target}} = 0.8$。\n\n对于每种情况，您的程序必须：\n- 计算初始谱半径 $\\rho_{\\mathrm{init}} = \\rho(S(M))$。\n- 通过您的策略计算缩放后的质量 $\\tilde{m}$，然后计算 $\\rho_{\\mathrm{scaled}} = \\rho(S(\\tilde{M}))$。\n- 生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例贡献一个包含两个浮点数 $[\\rho_{\\mathrm{init}}, \\rho_{\\mathrm{scaled}}]$ 的列表。最终输出格式必须为：\n\"[[rA_init,rA_scaled],[rB_init,rB_scaled],[rC_init,rC_scaled],[rD_init,rD_scaled]]\"\n所有数字都以十进制浮点数打印。所有输出都是无量纲的。",
            "solution": "该问题要求分析 LINCS 算法中使用的归一化耦合矩阵 $S$ 的谱半径，其在极端质量比下的行为，并提出一种质量缩放策略来限制该谱半径。\n\n### 理论分析\n\n假设系统由 $N$ 个原子组成，其位置为 $\\mathbf{q} \\in \\mathbb{R}^{3N}$，质量为 $m_i > 0$。$n_c$ 个完整键长约束为 $g_k(\\mathbf{q}) = \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\| - \\ell_k = 0$，其中 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 是原子 $i$ 的位置，$a(k)$ 和 $b(k)$ 是参与约束 $k$ 的原子索引。\n\n约束的雅可比矩阵 $G(\\mathbf{q}) \\in \\mathbb{R}^{n_c \\times 3N}$ 的行由约束函数的梯度 $\\nabla_{\\mathbf{q}} g_k$ 给出。$G$ 的第 $k$ 行（记为 $G_k$）仅在原子 $a(k)$ 和 $b(k)$ 对应的位置有非零的 3 维块。令 $\\mathbf{u}_k = (\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}) / \\|\\mathbf{r}_{a(k)} - \\mathbf{r}_{b(k)}\\|$ 为约束 $k$ 的归一化键向量。梯度块为 $\\nabla_{\\mathbf{r}_{a(k)}} g_k = \\mathbf{u}_k^\\top$ 和 $\\nabla_{\\mathbf{r}_{b(k)}} g_k = -\\mathbf{u}_k^\\top$。\n\n对角质量矩阵为 $M = \\mathrm{diag}(m_1 I_3, \\dots, m_N I_3)$，其中 $I_3$ 是 $3 \\times 3$ 单位矩阵。其逆矩阵为 $M^{-1} = \\mathrm{diag}(m_1^{-1} I_3, \\dots, m_N^{-1} I_3)$。质量加权约束耦合矩阵为 $C = G M^{-1} G^\\top$。元素 $C_{ij}$ 由 $C_{ij} = G_i M^{-1} G_j^\\top$ 给出。这可以计算为对所有原子 $p$ 的求和：\n$$C_{ij} = \\sum_{p=1}^{N} \\frac{1}{m_p} (\\nabla_{\\mathbf{r}_p} g_i) \\cdot (\\nabla_{\\mathbf{r}_p} g_j)$$\n\n对角元素 $C_{ii}$ 为：\n$$C_{ii} = \\frac{1}{m_{a(i)}} (\\mathbf{u}_i \\cdot \\mathbf{u}_i) + \\frac{1}{m_{b(i)}} ((-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_i)) = \\frac{1}{m_{a(i)}} + \\frac{1}{m_{b(i)}}$$\n这是参与约束 $i$ 的两个原子的质量倒数之和。\n\n仅当约束 $i$ 和 $j$ 共享至少一个原子时，非对角元素 $C_{ij}$ 才非零。考虑通过单个公共原子 $p$ 连接的两个约束 $i$ 和 $j$。假设约束 $i$ 涉及原子 $(p_1, p)$，约束 $j$ 涉及原子 $(p_2, p)$。我们可以设置约束内的原子顺序，使得 $b(i) = p$ 和 $b(j) = p$。那么 $\\nabla_{\\mathbf{r}_p} g_i = -\\mathbf{u}_i$ 且 $\\nabla_{\\mathbf{r}_p} g_j = -\\mathbf{u}_j$。对 $C_{ij}$ 求和的唯一非零贡献来自原子 $p$：\n$$C_{ij} = \\frac{1}{m_p} (-\\mathbf{u}_i) \\cdot (-\\mathbf{u}_j) = \\frac{1}{m_p} \\mathbf{u}_i \\cdot \\mathbf{u}_j$$\n在这里，$\\mathbf{u}_i \\cdot \\mathbf{u}_j$ 表示指向共享原子 $p$ 的两个键向量之间的夹角 $\\theta_{ij}$ 的余弦值。因此，$C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$。请注意，$C_{ij}$ 的符号取决于约束定义中任意的原子排序，但谱半径 $\\rho(S)$ 对此选择是不变的。我们继续假设一种排序，它产生 $C_{ij} = \\frac{\\cos\\theta_{ij}}{m_p}$，其中 $\\theta_{ij}$ 是原子 $p$ 处的键之间的夹角。\n\n归一化耦合矩阵 $S$ 定义为 $S_{ij} = C_{ij} / \\sqrt{C_{ii}C_{jj}}$（当 $i \\neq j$ 时）和 $S_{ii}=0$。对于原子 $p$ 处的耦合约束 $i, j$：\n$$S_{ij} = \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{m_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{m_p}\\right)}}$$\n\n### 极端质量比的影响\n\n考虑共享原子 $p$ 与其邻居相比非常轻的情况，即 $m_p \\to 0$，而 $m_{p_1}$ 和 $m_{p_2}$ 较大且固定。在此极限下，$1/m_p$ 项在 $C_{ii}$ 和 $C_{jj}$ 的表达式中占主导地位：\n$$ C_{ii} \\approx \\frac{1}{m_p}, \\quad C_{jj} \\approx \\frac{1}{m_p} $$\n非对角元素 $S_{ij}$ 变为：\n$$ S_{ij} \\approx \\frac{\\frac{\\cos\\theta_{ij}}{m_p}}{\\sqrt{\\frac{1}{m_p} \\cdot \\frac{1}{m_p}}} = \\cos\\theta_{ij} $$\n其大小 $|S_{ij}|$ 趋近于 $|\\cos\\theta_{ij}|$。对于远不等于 $90^\\circ$（此时 $\\cos\\theta_{ij}=0$）的键角，这个值可能接近 $1$。对于一个简单的双约束系统，$\\rho(S) = |S_{12}|$。如果 $|S_{12}|$ 趋近于 $1$，LINCS 算法的诺伊曼级数展开 $(I-S)^{-1} = \\sum_{k=0}^{\\infty} S^k$ 的收敛性将被破坏。在模拟含有与多个重原子键合的轻原子（如氢）的系统时，这是一个关键的数值稳定性问题。\n\n### 质量缩放策略\n\n为了抵消这种效应，我们提出一种策略，增加由两个或多个约束共享的原子的质量。令 $I_{\\text{shared}}$ 为这些共享原子的索引集合。我们为这些原子引入一个统一的质量下限 $\\mu$。缩放后的质量矩阵 $\\tilde{M}$ 使用质量 $\\tilde{m}_i$ 构建：\n$$ \\tilde{m}_i = \\begin{cases} \\max(m_i, \\mu),  i \\in I_{\\text{shared}} \\\\ m_i,  i \\notin I_{\\text{shared}} \\end{cases} $$\n我们必须找到最小的 $\\mu$，使得对于新的矩阵 $S(\\tilde{M})$，其谱半径 $\\rho(S(\\tilde{M})) \\le \\rho_{\\mathrm{target}}$。\n\n让我们分析将共享原子 $p$ 的质量从 $m_p$ 缩放到 $\\tilde{m}_p = \\max(m_p, \\mu) \\ge m_p$ 的效果。相应非对角元素的大小 $|S_{ij}|$ 为：\n$$ |S_{ij}(\\tilde{m}_p)| = \\frac{\\frac{|\\cos\\theta_{ij}|}{\\tilde{m}_p}}{\\sqrt{\\left(\\frac{1}{m_{p_1}} + \\frac{1}{\\tilde{m}_p}\\right) \\left(\\frac{1}{m_{p_2}} + \\frac{1}{\\tilde{m}_p}\\right)}} = \\frac{|\\cos\\theta_{ij}|}{\\sqrt{\\left(\\frac{\\tilde{m}_p}{m_{p_1}} + 1\\right) \\left(\\frac{\\tilde{m}_p}{m_{p_2}} + 1\\right)}} $$\n对于 $\\tilde{m}_p > 0$，该表达式显然是 $\\tilde{m}_p$ 的单调递减函数。因此，增加共享原子的质量会直接减小在该原子处相交的约束之间的耦合强度。这些耦合项正是在小质量情况下会变大的项。尽管 $|S|$ 的其他较小元素可能会略有增加，但对 $\\rho(S)$ 的主导影响来自于这些最大非对角元素的减小。因此，我们预期 $\\rho(S(\\mu))$ 是质量下限 $\\mu$ 的单调递减函数。\n\n这种单调性使我们能够使用高效的一维求根算法来找到所需的最小 $\\mu$。我们定义一个目标函数 $f(\\mu) = \\rho(S(\\mu)) - \\rho_{\\mathrm{target}}$，并搜索满足 $f(\\mu) \\le 0$ 的最小 $\\mu \\ge \\max_{i \\in I_{\\text{shared}}} m_i$。像 Brent 方法这样的区间法适合此任务，因为我们可以轻松找到一个区间 $[\\mu_{\\text{low}}, \\mu_{\\text{high}}]$，使得 $f(\\mu_{\\text{low}}) > 0$（未缩放的系统）和 $f(\\mu_{\\text{high}})  0$（对于足够大的质量下限）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef calculate_rho(positions, constraints, masses):\n    \"\"\"\n    Computes the spectral radius rho(S) for a given molecular system.\n\n    Parameters:\n    positions (np.ndarray): (N, 3) array of atomic positions.\n    constraints (np.ndarray): (nc, 2) array of atom indices for each constraint bond.\n    masses (np.ndarray): (N,) array of atomic masses.\n\n    Returns:\n    float: The spectral radius rho(S).\n    \"\"\"\n    num_atoms = len(masses)\n    num_constraints = len(constraints)\n\n    if num_constraints == 0:\n        return 0.0\n\n    # 1. Construct the Jacobian G\n    G = np.zeros((num_constraints, 3 * num_atoms), dtype=np.float64)\n    for k, (a_idx, b_idx) in enumerate(constraints):\n        r_a = positions[a_idx]\n        r_b = positions[b_idx]\n        r_ab = r_a - r_b\n        dist = np.linalg.norm(r_ab)\n        if dist  1e-9:\n            raise ValueError(f\"Constraint {k} has zero length.\")\n        u = r_ab / dist\n        \n        G[k, 3 * a_idx : 3 * a_idx + 3] = u\n        G[k, 3 * b_idx : 3 * b_idx + 3] = -u\n        \n    # 2. Form C = G M^-1 G^T\n    inv_masses_rep = np.repeat(1.0 / masses, 3)\n    GM_inv = G * inv_masses_rep # Broadcasting\n    C = GM_inv @ G.T\n    \n    # 3. Form S\n    C_diag = np.diag(C)\n    if np.any(C_diag = 0):\n        raise ValueError(\"Non-positive diagonal elements in C.\")\n    \n    denom = np.sqrt(np.outer(C_diag, C_diag))\n    # Handle potential division by zero if C_diag has zero elements, though it shouldn't\n    denom[denom  1e-30] = 1.0\n    \n    S = C / denom\n    np.fill_diagonal(S, 0.0)\n\n    # 4. Compute spectral radius rho(S)\n    if S.shape[0] = 1:\n        return 0.0\n    \n    eigvals = np.linalg.eigvals(S)\n    rho = np.max(np.abs(eigvals))\n    \n    return rho\n\ndef solve():\n    \"\"\"\n    Main function to run the mass-scaling analysis for the given test cases.\n    \"\"\"\n    # Test cases defined with 0-based indexing for atoms.\n    test_cases = [\n        # Case A: linear triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case B: right-angle triatomic, extreme light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0, 1.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.001, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case C: linear four-atom chain with two light interior atoms\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [2.0, 0.0, 0.0], [3.0, 0.0, 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2], [2, 3]], dtype=int),\n            \"masses\": np.array([12.0, 0.1, 0.1, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        },\n        # Case D: bent triatomic with light center\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [1.0 + np.cos(np.pi/6), np.sin(np.pi/6), 0.0]], dtype=np.float64),\n            \"constraints\": np.array([[0, 1], [1, 2]], dtype=int),\n            \"masses\": np.array([12.0, 0.05, 12.0], dtype=np.float64),\n            \"rho_target\": 0.8\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        q, constraints, m, rho_target = case[\"positions\"], case[\"constraints\"], case[\"masses\"], case[\"rho_target\"]\n        \n        rho_init = calculate_rho(q, constraints, m)\n        \n        if rho_init = rho_target:\n            results.append([rho_init, rho_init])\n            continue\n            \n        atom_counts = np.bincount(constraints.flatten(), minlength=len(m))\n        shared_atoms_indices = np.where(atom_counts >= 2)[0]\n        \n        if len(shared_atoms_indices) == 0:\n            results.append([rho_init, rho_init])\n            continue\n\n        def rho_objective_func(mu):\n            scaled_masses = m.copy()\n            for i in shared_atoms_indices:\n                scaled_masses[i] = max(m[i], mu)\n            return calculate_rho(q, constraints, scaled_masses) - rho_target\n\n        mu_low = np.max(m[shared_atoms_indices])\n\n        mu_high = mu_low + 1.0  # Initial guess for upper bound\n        if mu_low == 0: mu_high = 1.0\n        \n        max_iter = 100\n        iter_count = 0\n        while rho_objective_func(mu_high) > 0 and iter_count  max_iter:\n            mu_high *= 2.0\n            iter_count += 1\n        if iter_count == max_iter:\n            raise RuntimeError(\"Failed to find an upper bound for the mass search.\")\n\n        optimal_mu = brentq(rho_objective_func, mu_low, mu_high)\n        \n        final_masses = m.copy()\n        for i in shared_atoms_indices:\n            final_masses[i] = max(m[i], optimal_mu)\n            \n        rho_scaled = calculate_rho(q, constraints, final_masses)\n        \n        results.append([rho_init, rho_scaled])\n\n    output_str = f\"[{','.join([f'[{r[0]},{r[1]}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了 LINCS 的稳定性边界之后，我们转向其实际性能优化。LINCS 算法的阶数参数 $p$ 是一个关键的可调参数，它直接影响计算成本和约束精度之间的平衡。本练习将通过一个数据驱动的建模任务，让您量化这种权衡关系，并学习如何根据给定的精度要求，选择最优的 $p$ 值以实现最高效的模拟 。",
            "id": "3421494",
            "problem": "考虑基于牛顿动力学和完整约束的约束分子动力学。设广义坐标为 $q$，质量为 $m$，完整约束由 $C(q)=0$ 定义，其中 $C:\\mathbb{R}^{n}\\rightarrow \\mathbb{R}^{k}$。在线性约束求解器 (LINCS) 中，通过使用由整数阶参数 $p$ 控制的截断级数展开，将无约束更新投影到流形 $C(q)=0$ 上，从而计算出经过约束校正的位置（或速度）。施加约束校正后的约束违反均方根 (RMS) 值用 $\\|C(q)\\|_{\\mathrm{RMS}}$ 表示，下文简写为 $\\|C(q)\\|$。根据经验，增加 LINCS 阶数 $p$ 会减小 $\\|C(q)\\|$，但会增加运行时间。您的任务是，从基本原理和定义出发，构建一个有原则的、数据驱动的程序。该程序针对每个目标容差 $\\epsilon$，选择一个整数阶数 $p$，以在满足约束 $\\|C(q)\\| \\le \\epsilon$ 的前提下最小化运行时间。\n\n从以下第一性原理和核心定义开始：\n- 适用于完整约束系统的牛顿方程，约束雅可比矩阵 $G(q)=\\partial C(q)/\\partial q$ 的定义，以及使用由约束耦合矩阵决定的校正将无约束更新投影到约束流形上的概念。\n- LINCS 作为由阶数 $p$ 控制的截断迭代投影的算法结构，其中截断阶数控制约束流形被执行的精确程度。\n\n基于这些基础，推导一个模型，将截断阶数 $p$ 与以下两项联系起来：\n- 针对给定系统，建立关于 $p$ 的 RMS 约束违反 $\\|C(q)\\|$ 的预测模型。\n- 建立关于 $p$ 和一个描述约束耦合严重程度的跨系统标量描述符的运行时间 $T(p)$ 的预测模型。\n\n您推导的模型必须能从下面提供的经验数据中进行统计辨识，并且在数值上稳定，适合使用最小二乘法进行拟合。然后，使用您拟合的模型，为每个目标容差 $\\epsilon$ 选择\n$$\np^{\\star}=\\arg\\min_{p \\in \\{1,2,\\dots,12\\}} T(p)\\quad \\text{subject to}\\quad \\|C(q)\\|(p) \\le \\epsilon.\n$$\n如果在 $\\{1,2,\\dots,12\\}$ 中没有 $p$ 满足该不等式，则为该系统返回 $-1$。\n\n数据描述。给定三个综合但科学上一致的系统，索引为 $i\\in\\{A,B,C\\}$，每个系统都具有以下特征：\n- 一个标量描述符 $S_{i}$，等于在代表性步长上聚合的系统级约束耦合度量 $\\|C(q)\\|$ 的 RMS 值（无量纲）。\n- 对于 $p\\in\\{1,2,3,4,5\\}$，测得的 RMS 约束违反 $E_{i}(p)=\\|C(q)\\|$（无量纲）。\n- 对于 $p\\in\\{1,2,3,4,5\\}$，测得的运行时间 $T_{i}(p)$（单位：毫秒）。\n\n所有测量数据提供如下。\n\n系统 A：\n- $S_{A}=0.3$。\n- $P=[1,2,3,4,5]$。\n- $E_{A}(P)=[0.05,0.025,0.0125,0.00625,0.003125]$。\n- $T_{A}(P)=[1.15,2.10,3.05,4.00,4.95]$（单位：ms）。\n\n系统 B：\n- $S_{B}=0.6$。\n- $P=[1,2,3,4,5]$。\n- $E_{B}(P)=[0.14,0.098,0.0686,0.04802,0.033614]$。\n- $T_{B}(P)=[1.60,3.00,4.40,5.80,7.20]$（单位：ms）。\n\n系统 C：\n- $S_{C}=0.9$。\n- $P=[1,2,3,4,5]$。\n- $E_{C}(P)=[0.27,0.243,0.2187,0.19683,0.177147]$。\n- $T_{C}(P)=[2.05,3.90,5.75,7.60,9.45]$（单位：ms）。\n\n您的程序必须：\n- 从第一性原理出发，基于迭代投影的截断，为每个系统的 $\\|C(q)\\|(p)$ 证明一个参数模型的合理性，并使用提供的 $E_{i}(p)$ 数据（$p\\in\\{1,2,3,4,5\\}$）拟合其参数。\n- 从第一性原理出发，为一个关于 $p$ 的线性（直至一个开销项）运行时间 $T(p)$ 模型提供合理解释，并通过一个简单的可辨识关系将其斜率与描述符 $S_{i}$ 在不同系统间耦合起来，该关系可以使用所有提供的 $T_{i}(p)$ 和 $S_{i}$ 数据联合拟合。\n- 对每个目标容差 $\\epsilon$，为每个系统 $i\\in\\{A,B,C\\}$ 计算 $p^{\\star}$，通过在预测的 $\\|C(q)\\|(p) \\le \\epsilon$ 约束下最小化预测的 $T(p)$，其中 $p$ 被限制在整数集合 $\\{1,2,\\dots,12\\}$ 中。如果不存在可行的 $p$，则为该系统输出 $-1$。\n\n测试集。请精确使用以下目标容差：\n- $\\epsilon_{1}=0.02$，\n- $\\epsilon_{2}=0.05$，\n- $\\epsilon_{3}=0.2$，\n- $\\epsilon_{4}=0.18$，\n- $\\epsilon_{5}=0.003$。\n\n覆盖性设计：\n- $\\epsilon_{1}$ 迫使某些系统只有在将 $p$ 外推到 5 以上但在 $p\\leq 12$ 范围内时才可行。\n- $\\epsilon_{2}$ 包含一个与实测约束违反值相匹配的边界条件。\n- $\\epsilon_{3}$ 是一个宽松的容差，在此条件下，除了一个系统外，所有系统在较小的 $p$ 值下都可能可行。\n- $\\epsilon_{4}$ 收紧了前一个案例的条件，以强调在下一个整数 $p$ 处的选择。\n- $\\epsilon_{5}$ 非常严格，旨在迫使一个系统在允许的最大阶数内变得不可行。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表为给定 $\\epsilon$（按 $\\left[\\epsilon_{1},\\epsilon_{2},\\epsilon_{3},\\epsilon_{4},\\epsilon_{5}\\right]$ 顺序）给出三个最优阶数 $\\big[p^{\\star}_{A},p^{\\star}_{B},p^{\\star}_{C}\\big]$。例如，一个假设结果的输出可能看起来像 $[[1,2,3],[4,5,6],[7,8,9],[10,11,12],[1,1,1]]$。输出必须只包含这一行。",
            "solution": "该问题要求为分子动力学中的 LINCS 算法制定一个数据驱动的程序，以选择最优的阶数参数 $p$。目标是最小化运行时间 $T(p)$，同时确保约束违反的均方根 (RMS) 值（记为 $\\|C(q)\\|$）保持在指定的容差 $\\epsilon$ 以下。对 $p$ 的选择被限制在整数集合 $\\{1, 2, \\dots, 12\\}$ 中。为实现这一目标，我们将首先从第一性原理出发，推导约束违反 $\\|C(q)\\|(p)$ 和运行时间 $T(p)$ 的参数模型，然后将这些模型与提供的三个不同系统的经验数据进行拟合。\n\n**1. 约束违反 $\\|C(q)\\|(p)$ 的建模**\n\n完整约束动力学由第一类拉格朗日方程描述。LINCS 算法是与 SHAKE 等方法类似的几种强制执行这些约束的方法之一。LINCS 的工作原理是将无约束积分步骤之后的位置投影回由 $C(q)=0$ 定义的约束流形上。该投影通过校正位置来实现，校正量与一组拉格朗日乘子 $\\lambda$ 成正比。这些乘子通过求解线性方程组 $M\\lambda=d$ 来找到，其中 $M = G m^{-1} G^T$ 是约束耦合矩阵，$G = \\partial C(q)/\\partial q$ 是约束雅可比矩阵，$m$ 是质量矩阵，$d$ 是一个与无约束坐标的约束违反相关的向量。\n\nLINCS 通过使用截断的诺伊曼级数展开来近似 $M^{-1}$，从而避免了对 $M$ 的直接求逆：$M^{-1} \\approx \\sum_{k=0}^{p-1} (I - M)^k$。整数 $p$ 是 LINCS 算法的“阶数”，对应于为近似 $M^{-1}$ 的作用而执行的矩阵-向量乘法次数。此过程等效于一个迭代优化方案。\n\n设 $E(p) = \\|C(q)\\|(p)$ 是应用 $p$ 阶 LINCS 校正后的 RMS 约束违反。一个 $p$ 阶校正可以看作是应用了 $p$ 个连续的优化步骤。如果每一步都将误差减小一个特定因子，那么总的误差减小遵循几何级数。设 $E_0$ 是任何校正前的初始 RMS 违反，并设 $c$ 是每次迭代（$p$ 每增加一个单位）的有效收敛因子。那么，经过 $p$ 次迭代后，剩余误差预期为：\n$$\nE(p) = A \\cdot c^p\n$$\n其中 $A$ 是一个常数，代表 $p=0$ 时的有效初始误差（即，投影到约束梯度上的无约束步骤的误差），而 $c \\in (0, 1)$ 是收敛率，它取决于给定系统中矩阵 $M$ 的谱特性。一个接近 1 的 $c$ 值意味着收敛较慢，这通常与强约束耦合或“刚性”系统相关。该模型在科学上植根于 LINCS 算法的迭代性质。\n\n为了对每个系统 $i \\in \\{A, B, C\\}$ 拟合参数 $A$ 和 $c$，我们可以通过取自然对数来线性化模型：\n$$\n\\ln(E_i(p)) = \\ln(A_i) + p \\ln(c_i)\n$$\n这是 $\\ln(E_i(p))$ 和 $p$ 之间的线性关系。我们可以对每个系统的数据对 $(p, \\ln(E_i(p)))$ 进行线性最小二乘回归。对于所提供的数据，这种关系是精确的。\n\n对于系统 A：$E_A(p) = [0.05, 0.025, 0.0125, 0.00625, 0.003125]$。比率 $E_A(p+1)/E_A(p) = 0.5$ 对所有 $p$ 成立。因此，$c_A = 0.5$。参数 $A_A$ 从 $E_A(1) = A_A \\cdot c_A^1$ 求得，所以 $A_A = 0.05 / 0.5 = 0.1$。\n对于系统 B：$E_B(p) = [0.14, 0.098, 0.0686, 0.04802, 0.033614]$。比率 $E_B(p+1)/E_B(p) = 0.7$。因此，$c_B = 0.7$，且 $A_B = 0.14 / 0.7 = 0.2$。\n对于系统 C：$E_C(p) = [0.27, 0.243, 0.2187, 0.19683, 0.177147]$。比率 $E_C(p+1)/E_C(p) = 0.9$。因此，$c_C = 0.9$，且 $A_C = 0.27 / 0.9 = 0.3$。\n\n拟合后的约束违反模型为：\n- 系统 A：$E_A(p) = 0.1 \\cdot (0.5)^p$\n- 系统 B：$E_B(p) = 0.2 \\cdot (0.7)^p$\n- 系统 C：$E_C(p) = 0.3 \\cdot (0.9)^p$\n请注意，随着约束耦合描述符 $S_i$ 的增加（$S_A  S_B  S_C$），收敛因子 $c_i$ 也随之增加（$c_A  c_B  c_C$），这表明对于耦合更强的系统，收敛速度更慢，这与底层物理原理是一致的。\n\n**2. 运行时间 $T(p)$ 的建模**\n\nLINCS 算法的计算成本主要由迭代部分决定。对于一个 $p$ 阶计算，有 $p$ 次矩阵-向量乘法。因此，总运行时间 $T(p)$ 预期是关于 $p$ 的线性函数。我们可以将其建模为：\n$$\nT_i(p) = k_i \\cdot p + T_{0,i}\n$$\n其中 $k_i$ 是系统 $i$ 每次迭代的时间，而 $T_{0,i}$ 是系统 $i$ 的固定开销（例如，设置成本）。问题指出，斜率 $k_i$ 应与系统描述符 $S_i$ 相关。我们将检验最简单的假设：一个线性关系，$k_i = m_S S_i + b_S$。\n\n首先，我们使用提供的数据为每个系统拟合线性模型 $T_i(p) = k_i p + T_{0,i}$。同样，对于给定的数据，拟合是精确的。\n对于系统 A：$T_A(p) = [1.15, 2.10, 3.05, 4.00, 4.95]$。斜率为 $k_A=(2.10-1.15)/(2-1)=0.95$。截距为 $T_{0,A} = T_A(1) - k_A(1) = 1.15 - 0.95 = 0.2$。\n对于系统 B：$T_B(p) = [1.60, 3.00, 4.40, 5.80, 7.20]$。斜率为 $k_B=(3.00-1.60)/(2-1)=1.40$。截距为 $T_{0,B} = 1.60 - 1.40 = 0.2$。\n对于系统 C：$T_C(p) = [2.05, 3.90, 5.75, 7.60, 9.45]$。斜率为 $k_C=(3.90-2.05)/(2-1)=1.85$。截距为 $T_{0,C} = 2.05 - 1.85 = 0.2$。\n\n开销 $T_0 = 0.2$ ms 在所有系统中都是恒定的。现在，我们拟合斜率的模型：$k_i = m_S S_i + b_S$。我们有数据点 $(S_i, k_i)$: $(0.3, 0.95), (0.6, 1.40), (0.9, 1.85)$。使用两个点，我们找到斜率 $m_S = (1.40 - 0.95)/(0.6 - 0.3) = 0.45/0.3 = 1.5$。截距是 $b_S = k_A - m_S S_A = 0.95 - 1.5 \\cdot 0.3 = 0.95 - 0.45 = 0.5$。这个模型，$k(S) = 1.5 S + 0.5$，完美地拟合了所有三个数据点。\n适用于所有系统的完整运行时间模型是：\n$$\nT(p, S) = (1.5 S + 0.5) p + 0.2\n$$\n\n**3. 求解优化问题**\n\n对于每个系统 $i$ 和目标容差 $\\epsilon$，优化问题是：\n$$\np^{\\star}=\\arg\\min_{p \\in \\{1,2,\\dots,12\\}} T_i(p)\\quad \\text{subject to}\\quad E_i(p) \\le \\epsilon.\n$$\n由于运行时间模型 $T_i(p) = k_i p + T_0$ 是关于 $p$ 的单调递增函数（因为 $k_i > 0$），所以最小运行时间在满足约束 $E_i(p) \\le \\epsilon$ 的最小整数 $p$ 处实现。\n约束条件是 $A_i c_i^p \\le \\epsilon$。求解 $p$：\n$$\nc_i^p \\le \\frac{\\epsilon}{A_i}\n$$\n对两边取自然对数，并注意到 $\\ln(c_i)  0$（因为 $0  c_i  1$），我们必须反转不等号：\n$$\np \\ln(c_i) \\le \\ln\\left(\\frac{\\epsilon}{A_i}\\right) \\implies p \\ge \\frac{\\ln(\\epsilon/A_i)}{\\ln(c_i)}\n$$\n设 $p_{\\text{bound}} = \\frac{\\ln(\\epsilon/A_i)}{\\ln(c_i)}$。满足 $p \\ge p_{\\text{bound}}$ 的最小整数是 $p_{\\min}$。由于 $p$ 的允许值在 $\\{1, 2, \\dots, 12\\}$ 中，系统 $i$ 的最优 $p^{\\star}$ 是：\n$$\np^{\\star}_i(\\epsilon) = \\max(1, p_{\\min})\n$$\n如果计算出的 $p^{\\star}_i(\\epsilon)$ 大于 12，则在给定集合中不存在可行解，结果为 $-1$。此过程将应用于测试集中的每个系统和每个目标容差 $\\epsilon$。\n\n例如，对于系统 A 和 $\\epsilon_1=0.02$：\n$p_{\\text{bound}} = \\frac{\\ln(0.02/0.1)}{\\ln(0.5)} = \\frac{\\ln(0.2)}{\\ln(0.5)} \\approx 2.32$。\n$p^{\\star}_A(0.02)$ 是满足 $p \\ge 2.32$ 的最小整数，即 $p=3$。因为 $3 \\le 12$，这是一个有效的解。\n对于系统 C 和 $\\epsilon_1=0.02$：\n$p_{\\text{bound}} = \\frac{\\ln(0.02/0.3)}{\\ln(0.9)} = \\frac{\\ln(0.066...)}{\\ln(0.9)} \\approx 25.7$。\n$p^{\\star}_C(0.02)$ 是满足 $p \\ge 25.7$ 的最小整数，即 $p=26$。因为 $26 > 12$，结果是 $-1$。\n这些计算将系统地对所有测试用例执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Derives and applies models for LINCS error and runtime to find optimal order p.\n    \"\"\"\n\n    # Model parameters derived from the problem data.\n    # For each system, we store the parameters for the models:\n    # Constraint Violation Model: E(p) = A * c^p\n    # The parameters (A, c) are fitted for each system.\n    # Runtime Model: T(p, S) = (m_S * S + b_S) * p + T_0\n    # The parameters (m_S, b_S, T_0) are fitted globally.\n    \n    systems = {\n        'A': {'S': 0.3, 'A': 0.1, 'c': 0.5},\n        'B': {'S': 0.6, 'A': 0.2, 'c': 0.7},\n        'C': {'S': 0.9, 'A': 0.3, 'c': 0.9}\n    }\n    \n    # Test suite of target tolerances\n    test_cases = [\n        0.02,   # epsilon_1\n        0.05,   # epsilon_2\n        0.2,    # epsilon_3\n        0.18,   # epsilon_4\n        0.003,  # epsilon_5\n    ]\n\n    # Maximum allowed LINCS order\n    P_MAX = 12\n\n    def find_optimal_p(system_params, epsilon):\n        \"\"\"\n        Calculates the optimal p for a given system and tolerance.\n\n        The problem is to find p* = argmin_{p in {1..12}} T(p) s.t. E(p) = epsilon.\n        Since T(p) is monotonically increasing, this is equivalent to finding the\n        smallest p in {1..12} that satisfies E(p) = epsilon.\n\n        The constraint is E(p) = A * c^p = epsilon.\n        c^p = epsilon / A\n        p * log(c) = log(epsilon / A)\n        Since c  1, log(c) is negative, so we reverse the inequality:\n        p >= log(epsilon / A) / log(c)\n        \"\"\"\n        A = system_params['A']\n        c = system_params['c']\n\n        # If epsilon / A >= 1, log(epsilon/A) >= 0. Since log(c)  0,\n        # the bound p_bound will be = 0.\n        # The smallest integer p >= p_bound would be >= 1.\n        # So we take p=1 in this case.\n        if epsilon / A >= 1:\n            p_min = 1\n        else:\n            p_bound = math.log(epsilon / A) / math.log(c)\n            # The smallest integer p greater than or equal to p_bound\n            p_min = math.ceil(p_bound)\n        \n        # Ensure p_min is at least 1, as p starts from 1.\n        p_optimal = max(1, p_min)\n\n        if p_optimal > P_MAX:\n            return -1\n        else:\n            return int(p_optimal)\n\n    all_results = []\n    \n    # Iterate through each epsilon and find the optimal p for each system\n    for epsilon in test_cases:\n        epsilon_results = []\n        for system_id in ['A', 'B', 'C']:\n            p_star = find_optimal_p(systems[system_id], epsilon)\n            epsilon_results.append(p_star)\n        all_results.append(epsilon_results)\n    \n    # Format the output as a string representing a list of lists of integers.\n    # Ex: [[1,2,-1],[1,1,4]]\n    output_str = '[' + ','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}