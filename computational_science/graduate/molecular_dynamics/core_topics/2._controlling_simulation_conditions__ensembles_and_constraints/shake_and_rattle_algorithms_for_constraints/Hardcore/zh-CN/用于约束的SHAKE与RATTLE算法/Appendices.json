{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你从第一性原理出发，为最简单的约束系统——由键连接的两个原子——推导SHAKE算法的位置校正。通过这个推导，你将应用拉格朗日乘子法，深入理解SHAKE算法在满足约束条件的同时最小化质量加权位移的核心思想。这是掌握更复杂的多体约束系统分析的基础。",
            "id": "3444923",
            "problem": "考虑在分子动力学 (MD) 模拟中的两个原子 $i$ 和 $j$，其质量分别为 $m_i$ 和 $m_j$。在一个时间步长内进行无约束的位置更新后，它们被预测的位置为 $\\tilde{\\mathbf{r}}_i$ 和 $\\tilde{\\mathbf{r}}_j$。一个单一的完整键长约束要求最终校正后的位置 $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ 和 $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$ 满足 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| = d$，其中 $d$ 是一个预设的恒定键长。定义 $\\tilde{\\mathbf{r}}_{ij} \\equiv \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ 并假设 $\\|\\tilde{\\mathbf{r}}_{ij}\\| \\neq 0$。\n\n仅使用第一性原理（牛顿力学、完整约束以及 SHAKE 算法的定义原则，即位置校正使质量加权位移最小化，同时在时间步结束时精确满足约束），推导位置校正量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 的闭式表达式，以精确地对该单键施加约束。用 $m_i$、$m_j$、$\\tilde{\\mathbf{r}}_{ij}$ 和 $d$ 表示你的最终答案。选择能产生从 $(\\tilde{\\mathbf{r}}_i, \\tilde{\\mathbf{r}}_j)$ 出发的最小质量加权位移并保持原始键方向的解，并假设不存在其他约束。\n\n以单行矩阵的形式给出你的最终答案，即 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 对。不需要进行数值计算，最终答案中也不应包含单位。",
            "solution": "该问题要求推导质量分别为 $m_i$ 和 $m_j$ 的两个原子的原子位置校正量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$，以满足单个键长约束。推导基于 SHAKE 算法的核心原则：校正量必须在精确满足约束的同时，最小化总的质量加权平方位移。\n\n目标是最小化函数 $S$：\n$$S(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j) = m_i \\|\\delta \\mathbf{r}_i\\|^2 + m_j \\|\\delta \\mathbf{r}_j\\|^2$$\n受限于原子间最终距离为恒定值 $d$ 的完整约束。最终位置由 $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ 和 $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$ 给出，其中 $\\tilde{\\mathbf{r}}_i$ 和 $\\tilde{\\mathbf{r}}_j$ 是无约束的预测位置。\n\n约束方程为：\n$$\\sigma(\\mathbf{r}_i, \\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d^2 = 0$$\n使用校正后位置的定义，约束变为：\n$$\\|(\\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i) - (\\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j)\\|^2 - d^2 = 0$$\n令 $\\tilde{\\mathbf{r}}_{ij} = \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$。则约束方程为：\n$$\\|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j\\|^2 - d^2 = 0$$\n\n这是一个约束优化问题，我们将使用拉格朗日乘子法来解决。我们定义拉格朗日函数 $\\mathcal{L}$：\n$$\\mathcal{L} = m_i \\|\\delta \\mathbf{r}_i\\|^2 + m_j \\|\\delta \\mathbf{r}_j\\|^2 - \\lambda (\\|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j\\|^2 - d^2)$$\n其中 $\\lambda$ 是拉格朗日乘子。为求最小值，我们将 $\\mathcal{L}$ 对优化变量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 的梯度设为零。\n\n对 $\\delta \\mathbf{r}_i$ 求梯度：\n$$\\nabla_{\\delta \\mathbf{r}_i} \\mathcal{L} = 2 m_i \\delta \\mathbf{r}_i - 2 \\lambda (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\n对 $\\delta \\mathbf{r}_j$ 求梯度：\n$$\\nabla_{\\delta \\mathbf{r}_j} \\mathcal{L} = 2 m_j \\delta \\mathbf{r}_j - 2 \\lambda (-1) (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\n令最终校正后的原子间矢量为 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j$。梯度方程简化为：\n$$m_i \\delta \\mathbf{r}_i = \\lambda \\mathbf{r}_{ij}$$\n$$m_j \\delta \\mathbf{r}_j = - \\lambda \\mathbf{r}_{ij}$$\n从这两个方程，我们可以用 $\\lambda$ 和 $\\mathbf{r}_{ij}$ 来表示位置校正量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$：\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}$$\n一个直接的推论是 $m_i \\delta \\mathbf{r}_i + m_j \\delta \\mathbf{r}_j = \\mathbf{0}$。这表明校正不会移动双原子系统的质心，这是内力的一个基本性质。\n\n现在，我们将这些表达式代回到 $\\mathbf{r}_{ij}$ 的定义中：\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\left(\\frac{\\lambda}{m_i} \\mathbf{r}_{ij}\\right) - \\left(-\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}\\right)$$\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\mathbf{r}_{ij}$$\n重新整理各项以求解 $\\mathbf{r}_{ij}$：\n$$\\mathbf{r}_{ij} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\n这个方程表明，最终的原子间矢量 $\\mathbf{r}_{ij}$ 必须与无约束的原子间矢量 $\\tilde{\\mathbf{r}}_{ij}$ 平行。约束要求 $\\mathbf{r}_{ij}$ 的大小为 $d$，即 $\\|\\mathbf{r}_{ij}\\| = d$。问题陈述还指明应保持原始的键方向。这意味着 $\\mathbf{r}_{ij}$ 必须与 $\\tilde{\\mathbf{r}}_{ij}$ 指向相同的方向。因此，我们可以写出：\n$$\\mathbf{r}_{ij} = d \\frac{\\tilde{\\mathbf{r}}_{ij}}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}$$\n这是有效的，因为问题说明了 $\\|\\tilde{\\mathbf{r}}_{ij}\\| \\neq 0$。\n\n现在我们可以通过将 $\\mathbf{r}_{ij}$ 的这个表达式代入重新整理后的方程来确定拉格朗日乘子 $\\lambda$：\n$$\\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}\\right) \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\n将两边同时除以矢量 $\\tilde{\\mathbf{r}}_{ij}$（或者，更正式地说，取两边的模）得到一个标量方程：\n$$\\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = 1$$\n求解 $\\lambda$：\n$$1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) = \\frac{\\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}$$\n$$\\lambda \\left(\\frac{m_i + m_j}{m_i m_j}\\right) = 1 - \\frac{\\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}$$\n$$\\lambda = \\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{\\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}\\right)$$\n现在我们有了求出 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$ 最终表达式的所有组成部分。将 $\\lambda$ 和 $\\mathbf{r}_{ij}$ 的表达式代入校正量的方程中：\n对于 $\\delta \\mathbf{r}_i$：\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij} = \\frac{1}{m_i} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{\\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}\\right)$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - \\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}\\right) \\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - \\|\\tilde{\\mathbf{r}}_{ij}\\|}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\n这可以更简洁地写成：\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\n对于 $\\delta \\mathbf{r}_j$：\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij} = -\\frac{1}{m_j} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{\\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}\\right)$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - \\|\\tilde{\\mathbf{r}}_{ij}\\|}{d}\\right) \\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - \\|\\tilde{\\mathbf{r}}_{ij}\\|}{\\|\\tilde{\\mathbf{r}}_{ij}\\|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\n它可以写成：\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\n这些就是在最小化质量加权位移的同时精确满足键长约束的位置校正量的闭式表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{m_j}{m_i+m_j} \\left(\\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}  -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{\\|\\tilde{\\mathbf{r}}_{ij}\\|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论推导是理想化的，但在实际模拟中，约束算法的收敛性可能成为一个实际的挑战。本编程练习旨在通过一个具体的例子，研究原子质量比对SHAKE算法收敛速度的影响。你将通过模拟一个重原子和一个轻原子组成的系统，亲身体验并量化这种数值刚度（numerical stiffness）问题，这对于模拟包含氢原子等轻原子的真实分子体系至关重要。",
            "id": "2436786",
            "problem": "考虑一个在三维空间中的双点粒子系统，其位置为 $\\mathbf{r}_1 \\in \\mathbb{R}^3$ 和 $\\mathbf{r}_2 \\in \\mathbb{R}^3$，质量为 $m_1$ 和 $m_2$ (单位为 $\\mathrm{kg}$)。粒子由一个刚性完整约束连接，该约束将其间距固定为预设的键长 $d$ (单位为 $\\mathrm{m}$)，即\n$$\n\\phi(\\mathbf{r}_1,\\mathbf{r}_2) \\equiv \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0.\n$$\n系统不受外力作用。设初始位置和速度为\n$$\n\\mathbf{r}_1(0) = (0,0,0)\\ \\mathrm{m},\\quad \\mathbf{r}_2(0) = (d,0,0)\\ \\mathrm{m},\n$$\n$$\n\\mathbf{v}_1(0) = (0,+v_0,0)\\ \\mathrm{m/s},\\quad \\mathbf{v}_2(0) = (0,-v_0,0)\\ \\mathrm{m/s},\n$$\n其中 $d = 1.0\\ \\mathrm{m}$ 且 $v_0 = 1.0\\ \\mathrm{m/s}$。使用均匀时间步长 $h = 0.01\\ \\mathrm{s}$ 对系统进行 $T = 50$ 步的时间演化。在每个时间步，使用基于匀速运动的自由飞行位置预测，\n$$\n\\mathbf{r}_i^{\\ast} = \\mathbf{r}_i + h\\,\\mathbf{v}_i\\quad \\text{for } i \\in \\{1,2\\},\n$$\n然后通过沿约束梯度使用质量加权校正迭代更新位置，来强制执行完整约束 $\\phi(\\mathbf{r}_1,\\mathbf{r}_2)=0$，直到绝对约束违反值 $|\\phi|$ 至多为容差 $\\varepsilon = 10^{-12}\\ \\mathrm{m}^2$。一次迭代定义为应用一次根据当前迭代值计算出的、旨在减小 $\\phi$ 残差的质量加权校正。在某个时间步校正位置后，在校正后的位置上强制执行相应的速度级约束，以使 $\\dot{\\phi} = \\nabla_{\\mathbf{r}_1}\\phi \\cdot \\mathbf{v}_1 + \\nabla_{\\mathbf{r}_2}\\phi \\cdot \\mathbf{v}_2 = 0$ 在该时间步结束时成立。\n\n使用上述设置，对于以下四种 $(m_1,m_2)$（单位为 $\\mathrm{kg}$）的测试用例：\n- 测试用例 1：$(1.0,\\,1.0)$,\n- 测试用例 2：$(1000.0,\\,1.0)$,\n- 测试用例 3：$(10^{8},\\,1.0)$,\n- 测试用例 4：$(10^{12},\\,1.0)$,\n\n模拟该系统，并确定在每个测试用例中，于所有 $T$ 个时间步内为达到 $|\\phi| \\le \\varepsilon$ 所需的内部位置校正迭代的最大次数。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，按测试用例 1 到 4 的顺序排列结果，其中每个条目都是一个整数。例如，所需格式为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\n所有物理量必须在指定的国际单位制（SI）中解释和计算。在中间计算中可能出现的任何角度都必须以弧度解释，但最终报告的结果是如上定义的无单位整数。",
            "solution": "### 基于原理的解决方案设计\n\n该问题要求实现一个包含 SHAKE 和 RATTLE 约束算法的模拟循环，这些算法是 Verlet 积分方案的扩展。\n\n#### 模拟循环\n系统从时间 $t_n$ 演化到 $t_{n+1} = t_n + h$。设 $\\mathbf{r}_i(n)$ 和 $\\mathbf{v}_i(n)$ 分别是粒子 $i$ 在时间 $t_n$ 的位置和速度。\n\n1.  **位置预测**：在没有外力的情况下，粒子以恒定速度运动。预测位置 $\\mathbf{r}_i^*$ 为：\n    $$ \\mathbf{r}_i^{\\ast} = \\mathbf{r}_i(n) + h\\,\\mathbf{v}_i(n) $$\n    这些预测位置通常不满足键长约束。\n\n2.  **位置校正（SHAKE 算法）**：SHAKE 算法迭代校正预测位置，直到满足约束。设 $\\mathbf{r}_i^{(k)}$ 为第 $k$ 次 SHAKE 迭代时粒子 $i$ 的位置，其中 $\\mathbf{r}_i^{(0)} = \\mathbf{r}_i^*$。每一步的校正量 $\\delta\\mathbf{r}_i^{(k)} = \\mathbf{r}_i^{(k+1)} - \\mathbf{r}_i^{(k)}$ 沿约束梯度 $\\nabla_{\\mathbf{r}_i}\\phi$ 方向，并按反质量 $1/m_i$ 加权。\n\n    约束为 $\\phi = \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0$。\n    梯度为 $\\nabla_{\\mathbf{r}_1}\\phi = -2(\\mathbf{r}_2 - \\mathbf{r}_1)$ 和 $\\nabla_{\\mathbf{r}_2}\\phi = 2(\\mathbf{r}_2 - \\mathbf{r}_1)$。\n    校正量为 $\\delta\\mathbf{r}_i^{(k)} = \\lambda_k \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi^{(k)}$，其中 $\\lambda_k$ 是该约束的单个拉格朗日乘子。\n\n    为求 $\\lambda_k$，我们将约束方程在当前迭代值 $\\mathbf{r}^{(k)}$ 附近线性化：\n    $$ \\phi(\\mathbf{r}^{(k+1)}) \\approx \\phi(\\mathbf{r}^{(k)}) + \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\cdot \\delta\\mathbf{r}_i^{(k)} = 0 $$\n    代入 $\\delta\\mathbf{r}_i^{(k)}$ 的表达式：\n    $$ \\phi^{(k)} + \\lambda_k \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\rVert^2 = 0 $$\n    令 $\\mathbf{r}_{12}^{(k)} = \\mathbf{r}_2^{(k)} - \\mathbf{r}_1^{(k)}$，我们有 $\\lVert\\nabla_{\\mathbf{r}_1}\\phi\\rVert^2 = \\lVert\\nabla_{\\mathbf{r}_2}\\phi\\rVert^2 = 4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2$。分母变为 $4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 (\\frac{1}{m_1} + \\frac{1}{m_2})$。\n    解出 $\\lambda_k$：\n    $$ \\lambda_k = - \\frac{\\phi^{(k)}}{4 \\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    因此，迭代更新规则为：\n    $$ \\mathbf{r}_1^{(k+1)} = \\mathbf{r}_1^{(k)} - 2\\lambda_k \\frac{1}{m_1}\\mathbf{r}_{12}^{(k)} $$\n    $$ \\mathbf{r}_2^{(k+1)} = \\mathbf{r}_2^{(k)} + 2\\lambda_k \\frac{1}{m_2}\\mathbf{r}_{12}^{(k)} $$\n    重复此过程直到 $|\\phi^{(k)}| \\le \\varepsilon$。迭代次数 $k$ 被追踪。最终校正后的位置记为 $\\mathbf{r}_i(n+1)$。\n\n3.  **速度校正（RATTLE 算法）**：获得校正后的位置 $\\mathbf{r}_i(n+1)$ 后，必须更新速度。首先计算一个与位置变化一致的临时速度 $\\mathbf{v}_i'$：\n    $$ \\mathbf{v}_i' = \\frac{\\mathbf{r}_i(n+1) - \\mathbf{r}_i(n)}{h} $$\n    这些速度不一定满足速度级约束 $\\dot{\\phi}=0$。类似于 SHAKE 校正，添加一个校正量 $\\delta\\mathbf{v}_i$：$\\mathbf{v}_i(n+1) = \\mathbf{v}_i' + \\delta\\mathbf{v}_i$。校正量为 $\\delta\\mathbf{v}_i = \\gamma \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi(n+1)$，其中 $\\gamma$ 是另一个拉格朗日乘子。\n\n    我们强制 $\\dot{\\phi}(n+1) = \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi(n+1) \\cdot \\mathbf{v}_i(n+1) = 0$。\n    $$ \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi \\cdot \\mathbf{v}_i' + \\gamma \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert\\nabla_{\\mathbf{r}_i}\\phi\\rVert^2 = 0 $$\n    令 $\\mathbf{r}_{12}(n+1) = \\mathbf{r}_2(n+1) - \\mathbf{r}_1(n+1)$，第一项为 $2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2'-\\mathbf{v}_1')$。校正后的位置满足 $\\lVert\\mathbf{r}_{12}(n+1)\\rVert^2 \\approx d^2$。\n    解出 $\\gamma$：\n    $$ \\gamma = - \\frac{2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2' - \\mathbf{v}_1')}{4d^2\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    下一个时间步的最终速度为：\n    $$ \\mathbf{v}_1(n+1) = \\mathbf{v}_1' - \\frac{2\\gamma}{m_1}\\mathbf{r}_{12}(n+1) $$\n    $$ \\mathbf{v}_2(n+1) = \\mathbf{v}_2' + \\frac{2\\gamma}{m_2}\\mathbf{r}_{12}(n+1) $$\n\n这整个序列（预测-校正-校正）构成一个时间步。对每种质量组合运行模拟 $T$ 步，并记录 SHAKE 迭代的最大次数。测试用例中的极端质量比预计将凸显数值刚度以及由于有限浮点精度导致的潜在收敛性下降问题，其中重粒子的位移校正量与其位置的量级相比变得极小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a two-particle system with a rigid bond constraint using the\n    SHAKE and RATTLE algorithms and determines the maximum number of SHAKE\n    iterations required for various mass ratios.\n    \"\"\"\n    \n    # Define physical constants and simulation parameters\n    d = 1.0  # Bond length in meters\n    v0 = 1.0  # Initial velocity component in m/s\n    h = 0.01  # Time step in seconds\n    T_steps = 50  # Total number of time steps\n    tolerance = 1e-12  # Constraint tolerance in m^2\n\n    # Test cases for masses (m1, m2) in kg\n    test_cases = [\n        (1.0, 1.0),\n        (1000.0, 1.0),\n        (1.0e8, 1.0),\n        (1.0e12, 1.0),\n    ]\n\n    results = []\n\n    for m1, m2 in test_cases:\n        # Convert masses to numpy float64 for consistent calculations\n        m1_np = np.float64(m1)\n        m2_np = np.float64(m2)\n        inv_m1 = np.float64(1.0) / m1_np\n        inv_m2 = np.float64(1.0) / m2_np\n\n        # Initial conditions for positions and velocities\n        r1 = np.array([0.0, 0.0, 0.0], dtype=np.float64)\n        r2 = np.array([d, 0.0, 0.0], dtype=np.float64)\n        v1 = np.array([0.0, v0, 0.0], dtype=np.float64)\n        v2 = np.array([0.0, -v0, 0.0], dtype=np.float64)\n\n        max_iterations = 0\n\n        # Main simulation loop\n        for _ in range(T_steps):\n            r1_old, r2_old = r1.copy(), r2.copy()\n\n            # --- 1. Position Prediction (Free-flight) ---\n            # r_i* = r_i(n) + h * v_i(n)\n            r1_pred = r1 + h * v1\n            r2_pred = r2 + h * v2\n\n            # --- 2. Position Correction (SHAKE) ---\n            shake_iterations = 0\n            r1_corr, r2_corr = r1_pred.copy(), r2_pred.copy()\n            \n            while True:\n                r12 = r2_corr - r1_corr\n                r12_sq = np.dot(r12, r12)\n                phi = r12_sq - d*d\n\n                if np.abs(phi) = tolerance:\n                    break\n                \n                shake_iterations += 1\n                \n                # Calculate Lagrange multiplier lambda\n                # Grad_r1(phi) = -2*r12, Grad_r2(phi) = 2*r12\n                # Denominator term: (1/m1)*||Grad_r1||^2 + (1/m2)*||Grad_r2||^2\n                # = (inv_m1 * 4 * r12_sq) + (inv_m2 * 4 * r12_sq)\n                # = 4 * r12_sq * (inv_m1 + inv_m2)\n                denominator = 4.0 * r12_sq * (inv_m1 + inv_m2)\n\n                # Avoid division by zero, though unlikely in this problem\n                if denominator == 0:\n                    break\n\n                lagrange_lambda = -phi / denominator\n\n                # Update positions\n                # delta_r1 = lambda * (1/m1) * Grad_r1(phi)\n                # delta_r2 = lambda * (1/m2) * Grad_r2(phi)\n                r1_corr += lagrange_lambda * inv_m1 * (-2.0 * r12)\n                r2_corr += lagrange_lambda * inv_m2 * (2.0 * r12)\n\n            if shake_iterations > max_iterations:\n                max_iterations = shake_iterations\n            \n            # Final corrected positions for the time step\n            r1, r2 = r1_corr, r2_corr\n\n            # --- 3. Velocity Correction (RATTLE) ---\n            # First, compute uncorrected velocities\n            v1_prime = (r1 - r1_old) / h\n            v2_prime = (r2 - r2_old) / h\n            \n            # Constraint at velocity level: Grad_phi . v = 0\n            # Grad_r1 . v1 + Grad_r2 . v2 = 0\n            # Solve for Lagrange multiplier gamma\n            r12_final = r2 - r1\n            v12_prime = v2_prime - v1_prime\n            \n            # Numerator term: Grad_r1 . v1' + Grad_r2 . v2'\n            # = -2 * r12_final . v1' + 2 * r12_final . v2'\n            # = 2 * r12_final . (v2' - v1')\n            numerator_gamma = 2.0 * np.dot(r12_final, v12_prime)\n            \n            # Denominator is same form as in SHAKE, evaluated at final positions\n            # Here, r12_sq is guaranteed to be d*d to high precision\n            denominator_gamma = 4.0 * d*d * (inv_m1 + inv_m2)\n\n            if denominator_gamma == 0: # Failsafe\n                lagrange_gamma = 0.0\n            else:\n                lagrange_gamma = -numerator_gamma / denominator_gamma\n            \n            # Update velocities\n            v1 = v1_prime + lagrange_gamma * inv_m1 * (-2.0 * r12_final)\n            v2 = v2_prime + lagrange_gamma * inv_m2 * (2.0 * r12_final)\n        \n        results.append(max_iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "精确的分子动力学模拟不仅要求满足位置约束，还要求保持系统的守恒量，如总能量，以确保物理真实性。本练习将探讨RATTLE算法中速度约束的重要性，你将通过编码实现一个单摆模型，并研究速度约束求解的精度如何直接影响模拟的长期能量守恒性。这个实践深刻揭示了为了实现辛积分和保证长期稳定性，精确处理速度约束的必要性。",
            "id": "2436781",
            "problem": "实现并分析一个用于质量为 $m$ 的单个粒子的辛约束积分器，该粒子被约束在半径为 $L$ 的圆周上，并在大小为 $g$ 的匀强引力场中运动。使用 SHAKE 和 RATTLE 约束算法，重点关注位置和速度约束求解器之间的不对称容差如何影响长时间能量行为。\n\n从以下基本基础开始：\n- 粒子的牛顿第二定律，$m\\,\\mathrm{d}^{2}\\mathbf{q}/\\mathrm{d}t^{2}=\\mathbf{f}(\\mathbf{q})$，其中 $\\mathbf{q}\\in\\mathbb{R}^{2}$，$\\mathbf{f}(\\mathbf{q})$ 为非约束力。\n- 一个完整约束 $g(\\mathbf{q})=0$，其梯度为 $\\mathbf{G}(\\mathbf{q})=\\nabla g(\\mathbf{q})$，通过拉格朗日乘子强制执行，使得瞬时速度满足 $\\mathbf{G}(\\mathbf{q})\\cdot\\mathbf{v}=0$。\n- 以 Velocity Verlet 更新作为基础积分器。\n\n物理模型和常数：\n- 单个点质量 $m=1\\,\\mathrm{kg}$，被约束在以原点为中心、半径为 $L=1\\,\\mathrm{m}$ 的圆 $g(\\mathbf{q})=\\mathbf{q}\\cdot\\mathbf{q}-L^{2}=0$ 上，受到匀重力 $\\mathbf{f}(\\mathbf{q})=(0,-m g)$ 的作用，其中 $g=9.81\\,\\mathrm{m/s^{2}}$。\n- 所有物理量必须使用国际单位制 (SI) 处理。角度必须以弧度为单位。\n\n初始条件：\n- 选择初始角度 $\\theta_{0}=\\pi/3$ 并设置初始位置 $\\mathbf{q}_{0}=(L\\sin\\theta_{0},-L\\cos\\theta_{0})$，以使 $g(\\mathbf{q}_{0})=0$ 精确成立。\n- 选择初始速度 $\\mathbf{v}_{0}=(0,0)$，该速度满足 $\\mathbf{G}(\\mathbf{q}_{0})\\cdot\\mathbf{v}_{0}=0$。\n\n要实现的积分器：\n- 使用时间步长 $\\Delta t=1\\times 10^{-3}\\,\\mathrm{s}$ 并积分总时间 $T=10\\,\\mathrm{s}$。\n- 非约束力为 $\\mathbf{f}(\\mathbf{q})=(0,-m g)$，势能为 $V(\\mathbf{q})=m g\\,y$，其中 $y$ 是 $\\mathbf{q}=(x,y)$ 的纵坐标。动能为 $K(\\mathbf{v})=\\tfrac{1}{2}m\\,\\mathbf{v}\\cdot\\mathbf{v}$，总机械能为 $E=K+V$。\n- 实现带有 SHAKE 和 RATTLE 的 Velocity Verlet：\n  1. 预测位置：$\\tilde{\\mathbf{q}}=\\mathbf{q}_{n}+\\Delta t\\,\\mathbf{v}_{n}+\\tfrac{1}{2}\\Delta t^{2}\\,\\mathbf{a}(\\mathbf{q}_{n})$，其中 $\\mathbf{a}(\\mathbf{q})=\\mathbf{f}(\\mathbf{q})/m$。\n  2. 应用 SHAKE 来强制 $g(\\mathbf{q}_{n+1})=0$，通过对当前迭代值进行线性化，求解沿 $M^{-1}\\mathbf{G}^{T}$ (其中 $M=m I$)方向的校正量 $\\delta\\mathbf{q}$。当 $|g(\\mathbf{q}_{n+1})|\\le \\varepsilon_{p}$ 时终止，其中 $\\varepsilon_{p}$ 是位置容差。\n  3. 计算 $\\mathbf{a}(\\mathbf{q}_{n+1})$ 和非约束速度更新 $\\tilde{\\mathbf{v}}=\\mathbf{v}_{n}+\\tfrac{1}{2}\\Delta t\\left[\\mathbf{a}(\\mathbf{q}_{n})+\\mathbf{a}(\\mathbf{q}_{n+1})\\right]$。\n  4. 应用 RATTLE 来强制执行速度约束 $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}_{n+1}=0$，使用迭代线性求解来计算拉格朗日乘子。具体来说，定义残差 $r=\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}$ 和标量 $A=\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot M^{-1}\\mathbf{G}(\\mathbf{q}_{n+1})^T$，并使用固定的步长因子 $\\theta=1/2$ 对乘子进行 Richardson 更新迭代：更新 $\\mathbf{v}\\leftarrow \\mathbf{v}-M^{-1}\\mathbf{G}^{T}\\,\\alpha\\,r$，其中 $\\alpha=\\theta/A$，在每次迭代中重新计算 $r$，并在 $|r|\\le \\varepsilon_{v}$ 时停止，其中 $\\varepsilon_{v}$ 是速度容差。当 $\\varepsilon_{v}$ 宽松时，这种构造使得速度求解不精确，从而导致残差持续存在。\n\n任务：\n- 在一个单一、完整、可运行的程序中实现上述算法，该程序执行模拟并计算最终时间后的绝对相对能量漂移，定义为 $\\left|E(T)-E(0)\\right|/|E(0)|$，此值为无量纲。\n- 通过改变速度约束容差 $\\varepsilon_{v}$ 同时保持位置容差 $\\varepsilon_{p}$ 紧凑，研究能量守恒的破坏情况。使用以下 $(\\varepsilon_{p},\\varepsilon_{v})$ 对的测试套件：\n  - 测试 1：$(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-10})$。\n  - 测试 2：$(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-5})$。\n  - 测试 3：$(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-3})$。\n  - 测试 4：$(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-1})$。\n- 对于每个测试，运行模拟并计算在 $t=T$ 时等于绝对相对能量漂移的单个浮点数。按顺序汇总结果。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：$[r_{1},r_{2},r_{3},r_{4}]$，其中每个 $r_{k}$ 是测试 $k$ 的浮点数。",
            "solution": "该问题提出了一个计算物理学中的适定问题，适合进行严格分析。它具有科学依据，内部一致，并且需要实现一个标准的数值算法。任务是模拟一个受约束的力学系统——一个单摆，使用 Velocity Verlet 积分器结合 SHAKE 和 RATTLE 算法来施加约束。目标是量化不精确的速度约束满足对系统长期能量守恒的影响。\n\n该系统是一个在二维空间 $\\mathbf{q}=(x,y)$ 中运动的点质量 $m$，受到匀重力 $\\mathbf{f}=(0, -mg)$ 的作用。运动被限制在以原点为中心、半径为 $L$ 的圆上。这代表一个完整约束，可以表示为坐标的方程：\n$$\ng(\\mathbf{q}) = \\mathbf{q} \\cdot \\mathbf{q} - L^2 = 0\n$$\n这个约束函数的梯度是 $\\mathbf{G}(\\mathbf{q}) = \\nabla g(\\mathbf{q}) = 2\\mathbf{q}$。这个约束系统的运动方程由第一类拉格朗日方程给出：\n$$\nm\\ddot{\\mathbf{q}} = \\mathbf{f} - \\lambda(t) \\mathbf{G}(\\mathbf{q})\n$$\n其中 $\\lambda(t)$ 是一个随时间变化的拉格朗日乘子，它决定了约束力的大小，该约束力沿着约束梯度的方向作用。将约束方程对时间求导两次，得到速度和加速度约束：\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}t} = \\mathbf{G}(\\mathbf{q}) \\cdot \\dot{\\mathbf{q}} = 0\n$$\n$$\n\\frac{\\mathrm{d}^2g}{\\mathrm{d}t^2} = \\dot{\\mathbf{G}}(\\mathbf{q}) \\cdot \\dot{\\mathbf{q}} + \\mathbf{G}(\\mathbf{q}) \\cdot \\ddot{\\mathbf{q}} = 0\n$$\n此类系统的数值积分需要特别小心，以防止轨迹因离散化误差而违反约束。SHAKE 和 RATTLE 算法就是为此目的设计的，将约束满足直接嵌入到类 Verlet 积分器的步骤中。\n\n核心积分器是 Velocity Verlet 算法。对于一个时间步长 $\\Delta t$，它如下更新从时间 $t_n$ 到 $t_{n+1}$ 的位置 $\\mathbf{q}$ 和速度 $\\mathbf{v}$：\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{v}_n + \\frac{1}{2}\\Delta t^2 \\mathbf{a}_n\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}\\Delta t (\\mathbf{a}_n + \\mathbf{a}_{n+1})\n$$\n其中 $\\mathbf{a}_n = \\mathbf{F}_n / m$ 是时间 $t_n$ 时的加速度。当存在约束时，这个基本方案会被修改。总力 $\\mathbf{F}_n$ 包括外力 $\\mathbf{f}_n$ 和约束力 $\\mathbf{F}_{c,n} = -\\lambda_n \\mathbf{G}(\\mathbf{q}_n)$。带有 SHAKE 和 RATTLE 的 Velocity Verlet 算法将无约束运动的积分与约束的强制执行解耦，后者作为投影步骤应用。\n\n指定的算法在每个时间步中按如下方式进行：\n1. 预测无约束位置：从一个满足约束的有效状态 $(\\mathbf{q}_n, \\mathbf{v}_n)$ 开始，仅使用外力 $\\mathbf{f}(\\mathbf{q}_n)$ 计算出一个中间位置 $\\tilde{\\mathbf{q}}$。加速度为 $\\mathbf{a}(\\mathbf{q}_n) = \\mathbf{f}(\\mathbf{q}_n)/m$。\n$$\n\\tilde{\\mathbf{q}} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{v}_n + \\frac{1}{2}\\Delta t^2 \\mathbf{a}(\\mathbf{q}_n)\n$$\n这个预测的位置 $\\tilde{\\mathbf{q}}$ 通常不满足位置约束，即 $g(\\tilde{\\mathbf{q}}) \\neq 0$。\n\n2. 应用 SHAKE 校正位置：SHAKE 算法迭代地校正 $\\tilde{\\mathbf{q}}$ 以找到一个位于约束流形上的最终位置 $\\mathbf{q}_{n+1}$，即，在指定的容差 $\\varepsilon_p$ 内满足 $g(\\mathbf{q}_{n+1})=0$。校正沿约束梯度方向施加。从 $\\mathbf{q}^{(0)} = \\tilde{\\mathbf{q}}$ 开始，迭代过程为：\n$$\n\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - \\Delta \\mathbf{q}^{(k)} \\quad \\text{其中} \\quad \\Delta \\mathbf{q}^{(k)} = \\lambda^{(k)} m^{-1} \\mathbf{G}(\\mathbf{q}^{(k)})\n$$\n标量 $\\lambda^{(k)}$ 通过线性化约束方程来确定：$g(\\mathbf{q}^{(k+1)}) \\approx g(\\mathbf{q}^{(k)}) - \\mathbf{G}(\\mathbf{q}^{(k)}) \\cdot \\Delta \\mathbf{q}^{(k)} = 0$。代入 $\\Delta \\mathbf{q}^{(k)}$ 的形式得到：\n$$\n\\lambda^{(k)} = m \\frac{g(\\mathbf{q}^{(k)})}{|\\mathbf{G}(\\mathbf{q}^{(k)})|^2}\n$$\n对于特定约束 $g(\\mathbf{q}) = \\mathbf{q}\\cdot\\mathbf{q} - L^2$ 和 $m=1$，这简化为：\n$$\n\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - \\frac{(\\mathbf{q}^{(k)}\\cdot\\mathbf{q}^{(k)}) - L^2}{2(\\mathbf{q}^{(k)}\\cdot\\mathbf{q}^{(k)})} \\mathbf{q}^{(k)}\n$$\n这个循环一直持续到 $|g(\\mathbf{q}^{(k+1)})| \\le \\varepsilon_p$ 为止。这得到了最终位置 $\\mathbf{q}_{n+1}$。\n\n3. 更新速度（无约束部分）：速度更新的无约束部分使用标准的 Velocity Verlet 形式，包含了新的、已校正位置 $\\mathbf{q}_{n+1}$ 处的力。\n$$\n\\tilde{\\mathbf{v}} = \\mathbf{v}_n + \\frac{1}{2}\\Delta t (\\mathbf{a}(\\mathbf{q}_n) + \\mathbf{a}(\\mathbf{q}_{n+1}))\n$$\n这个中间速度 $\\tilde{\\mathbf{v}}$ 通常不满足速度约束，即 $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\tilde{\\mathbf{v}} \\neq 0$。\n\n4. 应用 RATTLE 校正速度：RATTLE 算法将 $\\tilde{\\mathbf{v}}$ 投影到 $\\mathbf{q}_{n+1}$ 处的约束流形的切平面上，以找到满足 $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}_{n+1}=0$ 在容差 $\\varepsilon_v$ 内的最终速度 $\\mathbf{v}_{n+1}$。问题指定了一个迭代的 Richardson 类型更新方案。从 $\\mathbf{v}^{(0)} = \\tilde{\\mathbf{v}}$ 开始，迭代过程为：\n$$\n\\mathbf{v}^{(k+1)} = \\mathbf{v}^{(k)} - m^{-1} \\mathbf{G}(\\mathbf{q}_{n+1}) \\alpha r^{(k)}\n$$\n其中残差是 $r^{(k)} = \\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot \\mathbf{v}^{(k)}$，更新因子是 $\\alpha = \\theta / A$，其中 $\\theta=1/2$ 和 $A = \\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot m^{-1} \\mathbf{G}(\\mathbf{q}_{n+1})^T$。对于我们的系统，其中 $m=1$ 和 $|\\mathbf{q}_{n+1}|=L=1$。因此，$\\mathbf{G}_{n+1}=2\\mathbf{q}_{n+1}$，以及 $A = |2\\mathbf{q}_{n+1}|^2 / m = 4|\\mathbf{q}_{n+1}|^2 / m = 4$。这得到 $\\alpha = (1/2)/4 = 1/8$。更新规则是：\n$$\n\\mathbf{v}^{(k+1)} = \\mathbf{v}^{(k)} - \\mathbf{G}_{n+1} \\frac{1}{8} r^{(k)}\n$$\n这个循环一直持续到 $|r^{(k)}| \\le \\varepsilon_v$ 为止。最终结果是 $\\mathbf{v}_{n+1}$。\n\nVelocity Verlet 与精确的 SHAKE 和 RATTLE 校正相结合，产生了一个辛且时间可逆的积分器。辛性意味着该算法守恒一个“影子”哈密顿量，它是真实哈密顿量的一个微小扰动。这导致了卓越的长期能量守恒，其特征是能量在初始能量周围有界波动，但没有系统性漂移。\n\n这一理想特性取决于在每一步都精确满足约束。在这个问题中，位置约束容差 $\\varepsilon_p$ 保持在一个非常小的值 ($10^{-10}$)，因此位置约束被有效满足。然而，速度约束容差 $\\varepsilon_v$ 从一个小值变化到一个大值。当 $\\varepsilon_v$ 很大时，RATTLE 迭代求解器会过早终止，在速度约束中留下非零残差，$\\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot \\mathbf{v}_{n+1} \\neq 0$。这种未能精确强制执行速度约束的情况破坏了算法的时间可逆性，从而破坏了其辛性。一个非辛积分器不守恒任何影子哈密顿量，并且在长时间模拟中通常会表现出总能量的系统性漂移。这种漂移的幅度预计与允许的约束违反的幅度（即与 $\\varepsilon_v$）密切相关。该模拟旨在演示和量化这种破坏。\n\n最后，能量退化的度量是“绝对相对能量漂移”。在问题中定义为 $\\left|E(T)-E(0)\\right|/E(0)$。对于给定的初始条件，初始能量 $E(0)$ 为负。对此公式的字面解释将为一个正的漂移 $|E(T)-E(0)|$ 产生一个负值，这对于一个被描述为“绝对漂移”的量来说在科学上是荒谬的。科学和工程惯例规定，相对误差或漂移是一个非负量。因此，在计算中将使用物理上有意义的定义 $\\left|E(T)-E(0)\\right|/\\left|E(0)\\right|$。这是为保持科学严谨性而进行的必要修正。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a constrained integrator for a particle on a circle.\n    \n    This function sets up the physical model of a simple pendulum and simulates\n    its motion using a Velocity Verlet integrator augmented with SHAKE and RATTLE\n    constraint algorithms. It investigates how varying the tolerance of the\n    velocity constraint solver (RATTLE) affects long-term energy conservation.\n    The absolute relative energy drift is computed for a suite of test cases.\n    \"\"\"\n\n    def run_simulation(eps_p, eps_v):\n        \"\"\"\n        Runs a single simulation for given position and velocity tolerances.\n\n        Args:\n            eps_p (float): Tolerance for the SHAKE position constraint solver.\n            eps_v (float): Tolerance for the RATTLE velocity constraint solver.\n        \n        Returns:\n            float: The absolute relative energy drift after the simulation.\n        \"\"\"\n        # Physical model and constants (SI units)\n        m = 1.0  # kg\n        L = 1.0  # m\n        g_accel = 9.81  # m/s^2\n\n        # Simulation parameters\n        dt = 1.0e-3  # s\n        T = 10.0  # s\n        n_steps = int(T / dt)\n\n        # Initial conditions\n        theta_0 = np.pi / 3.0\n        q = np.array([L * np.sin(theta_0), -L * np.cos(theta_0)]) # position\n        v = np.array([0.0, 0.0]) # velocity\n\n        # Unconstrained force and acceleration (constant for uniform gravity)\n        force = np.array([0.0, -m * g_accel])\n        accel = force / m\n\n        # Energy calculation functions\n        def kinetic_energy(vel):\n            return 0.5 * m * np.dot(vel, vel)\n\n        def potential_energy(pos):\n            return m * g_accel * pos[1]\n\n        def total_energy(pos, vel):\n            return kinetic_energy(vel) + potential_energy(pos)\n\n        # Initial energy\n        E_initial = total_energy(q, v)\n\n        # Main time-stepping loop\n        for _ in range(n_steps):\n            q_n, v_n = q, v\n            a_n = accel # Acceleration is constant\n\n            # 1. Predict position (unconstrained)\n            q_tilde = q_n + dt * v_n + 0.5 * dt**2 * a_n\n\n            # 2. Apply SHAKE to enforce position constraint g(q) = q.q - L^2 = 0\n            q_k = q_tilde\n            # A max iteration count is good practice to prevent infinite loops\n            max_shake_iter = 10 \n            for _ in range(max_shake_iter):\n                g_k = np.dot(q_k, q_k) - L**2\n                if abs(g_k) = eps_p:\n                    break\n                \n                # As derived in the solution text, for m=1\n                # q_k_plus_1 = q_k - (g_k / (2 * q_k.q_k)) * q_k\n                # Avoid division by zero if q_k is near origin (not possible here)\n                q_k_dot_q_k = np.dot(q_k, q_k)\n                if q_k_dot_q_k == 0:\n                    # This case should not be reached for this problem\n                    break \n                q_k = q_k - (g_k / (2.0 * q_k_dot_q_k)) * q_k\n            \n            q = q_k # Final position for this step\n\n            # 3. Compute unconstrained velocity update\n            a_n_plus_1 = accel # Acceleration is constant\n            v_tilde = v_n + 0.5 * dt * (a_n + a_n_plus_1)\n\n            # 4. Apply RATTLE to enforce velocity constraint G(q).v = 0\n            G_n_plus_1 = 2.0 * q\n            v_k = v_tilde\n            \n            # Precompute constant parts of the RATTLE iteration\n            # A = G.inv(M).G = |G|^2/m = (4*|q|^2)/m = 4*L^2/m\n            # For m=1, L=1, A=4. alpha = theta/A = (1/2)/4 = 1/8.\n            alpha_G = (1.0 / 8.0) * G_n_plus_1\n            \n            max_rattle_iter = 20 # Convergence is fast, but set a limit\n            for _ in range(max_rattle_iter):\n                r_k = np.dot(G_n_plus_1, v_k)\n                if abs(r_k) = eps_v:\n                    break\n                v_k = v_k - alpha_G * r_k\n            \n            v = v_k # Final velocity for this step\n        \n        # Final energy\n        E_final = total_energy(q, v)\n        \n        # Calculate absolute relative energy drift, using abs(E_initial) for robustness.\n        # This corrects the ambiguity in the problem statement for a scientifically\n        # meaningful result, as explained in the solution text.\n        if abs(E_initial) == 0:\n             # Handle case of zero initial energy, though not applicable here\n            if abs(E_final) == 0:\n                return 0.0\n            else:\n                return np.inf # Or handle as an error\n        \n        energy_drift = abs(E_final - E_initial) / abs(E_initial)\n        \n        return energy_drift\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-10, 1e-10),\n        (1e-10, 1e-5),\n        (1e-10, 1e-3),\n        (1e-10, 1e-1),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_p, eps_v = case\n        result = run_simulation(eps_p, eps_v)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format each result to a reasonable number of significant figures\n    # to maintain a clean output.\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}