{
    "hands_on_practices": [
        {
            "introduction": "刚体运动方程的数值积分会引入误差，破坏约束条件并导致能量漂移。本练习  深入分子动力学算法的核心，通过实现 SHAKE 和 RATTLE 方法来分别维持四元数的单位范数约束及其相关的速度约束。通过比较不同约束策略，你将亲身体验这些算法选择如何直接影响旋转温度等物理可观测量，并理解其对能量守恒的重要性。",
            "id": "3442413",
            "problem": "您的任务是设计并分析一种用于分子动力学环境中单个刚体受约束转动动力学的数值方案，该方案使用单位四元数来表示朝向。该方案必须以牛顿-欧拉刚体动力学和四元数运动学为基础。目标是实现一个时间步进积分器，它能维持单位四元数约束并遵守等价关系 $q \\sim -q$，然后量化不同约束投影策略对测量的转动温度的影响。\n\n假设一个刚体，其在物体坐标系中表示的主转动惯量为对角阵 $I = \\operatorname{diag}(I_1,I_2,I_3)$。设物体坐标系中的角速度为 $\\omega \\in \\mathbb{R}^3$，朝向四元数为 $q \\in \\mathbb{R}^4$，其分量为 $q = (q_0,q_x,q_y,q_z)$。该四元数必须满足完整约束 $C(q) = q^\\top q - 1 = 0$，并且物理上相同的朝向满足等价关系 $q \\sim -q$。力矩为零，因此无力矩刚体方程成立。\n\n使用以下基础理论：\n- 在物体坐标系中的无力矩欧拉方程为 $I \\dot{\\omega} = - \\omega \\times (I \\omega)$，其中 $I$ 是惯性张量，$\\times$ 是向量叉积。\n- 四元数运动学方程为 $\\dot{q} = \\tfrac{1}{2} q \\otimes \\Omega$，其中 $\\otimes$ 表示四元数乘法，$\\Omega = (0,\\omega)$ 是一个虚部为 $\\omega$ 的纯虚四元数。\n- 转动动能为 $K = \\tfrac{1}{2} \\omega^\\top I \\omega$。\n- 瞬时转动温度（使用能量均分定理）为 $T_{\\text{rot}} = \\dfrac{2 K}{f k_B}$，其中转动自由度 $f = 3$，玻尔兹曼常数 $k_B$。使用约化单位，令 $k_B = 1$。\n\n实现一个具有以下结构和科学上真实约束的单分子模拟：\n1. 使用欧拉方程的一阶显式更新对 $\\omega$ 进行时间积分：$\\omega_{n+1} = \\omega_n + \\Delta t \\, I^{-1} \\left( - \\omega_n \\times (I \\omega_n) \\right)$，时间步长 $\\Delta t$ 以秒为单位。角度以弧度为单位。\n2. 使用显式更新对 $q$ 进行时间积分：$q_{n+1}^{\\text{unc}} = q_n + \\Delta t \\, \\dot{q}_n$，其中 $\\dot{q}_n = \\tfrac{1}{2} q_n \\otimes (0,\\omega_{n+1})$。\n3. 位置约束投影 (\"SHAKE\"): 通过将 $q_{n+1}^{\\text{unc}}$ 归一化为 $q_{n+1} = \\dfrac{q_{n+1}^{\\text{unc}}}{\\|q_{n+1}^{\\text{unc}}\\|}$ 来强制 $\\|q_{n+1}\\| = 1$。\n4. 符号等价性处理 $q \\sim -q$：归一化后，可选择使用下面定义的策略之一将 $q_{n+1}$ 投影到一个规范表示。\n5. 速度约束投影 (\"RATTLE\"): 在位置投影之后，强制执行速度级约束 $q^\\top \\dot{q} = 0$。令 $S(q)$ 为一个 $4 \\times 3$ 矩阵，使得对于给定的 $q$，$\\dot{q} = \\tfrac{1}{2} S(q) \\omega$ 对 $\\omega$ 线性成立。通过 $\\dot{q}^{\\text{proj}} = \\dot{q} - (q^\\top \\dot{q}) q$ 将 $\\dot{q}$ 投影到切空间，然后通过最小二乘法恢复调整后的角速度 $\\omega' = \\arg\\min_{\\omega} \\| \\tfrac{1}{2} S(q) \\omega - \\dot{q}^{\\text{proj}} \\|_2$，即以最小二乘意义求解 $S(q)\\omega = 2 \\dot{q}^{\\text{proj}}$。如果所选策略包含 RATTLE，则将校正后的角速度设为 $\\omega'$ 用于下一步。\n\n设计并比较以下三种投影策略：\n- 策略 P0：归一化 $q$ (SHAKE)。不强制执行任何符号约定，也不对 $\\omega$ 应用 RATTLE。\n- 策略 P1：归一化 $q$ (SHAKE)，通过翻转 $q$ 以确保 $q_0 \\ge 0$ (如果 $q_0 < 0$，则使用 $q \\leftarrow -q$) 来强制执行半球符号约定，并应用 RATTLE 通过上述最小二乘程序校正 $\\omega$。\n- 策略 P2：归一化 $q$ (SHAKE)，通过翻转 $q$ 以最大化 $q \\cdot q_{\\text{prev}}$ (如果 $q^\\top q_{\\text{prev}} < 0$，则使用 $q \\leftarrow -q$) 来强制执行最大重叠符号约定，并应用 RATTLE 通过最小二乘法校正 $\\omega$。\n\n对于每种策略，模拟 $N$ 步，并计算整个轨迹上瞬时转动温度 $T_{\\text{rot}}$ 的时间平均值。通过报告测量的平均 $T_{\\text{rot}}$ 与根据初始 $\\omega_0$ 和 $I$ 计算的理论基线 $T_0 = \\dfrac{2 K_0}{f k_B}$ 之间的差异来量化每种策略的效果，其中 $f = 3$ 且 $k_B = 1$。明确地，报告每种策略的 $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$。\n\n角度单位必须是弧度，时间单位是秒，转动惯量单位是千克·米²，角速度单位是弧度/秒。温度必须以与 $k_B = 1$ 一致的能量单位报告。\n\n可以使用任何现代语言实现该程序，但最终答案必须是一个完整、可运行的 Python 程序。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按照下面指定的顺序包含所有策略和所有测试用例的 $\\Delta T$ 值。\n\n使用以下测试套件，它探测了不同的物理和数值区域：\n\n- 测试用例1（理想情况，球形陀螺）：$I = \\operatorname{diag}(1,1,1)$，$q_0 = (1,0,0,0)$，$\\omega_0 = (0.2,0.3,0.4)$，$\\Delta t = 0.01$，$N = 1000$。按 P0, P1, P2 的顺序报告三个浮点数。\n\n- 测试用例2（符号边界，球形陀螺）：$I = \\operatorname{diag}(1,1,1)$，$q_0 = (-0.001,0.70710678,0,0.70710678)$，$\\omega_0 = (0.8,0.0,0.0)$，$\\Delta t = 0.02$，$N = 1200$。按 P0, P1, P2 的顺序报告三个浮点数。\n\n- 测试用例3（不对称陀螺，中等时间步长）：$I = \\operatorname{diag}(1.0,1.5,2.0)$，$q_0 = (0.92387953,0.38268343,0,0)$，$\\omega_0 = (0.7,0.01,0.02)$，$\\Delta t = 0.02$，$N = 1500$。按 P0, P1, P2 的顺序报告三个浮点数。\n\n- 测试用例4（不对称陀螺，较大时间步长，接近符号翻转）：$I = \\operatorname{diag}(0.8,1.2,1.6)$，$q_0 = (0.0,0.70710678,0.70710678,0.0)$，$\\omega_0 = (0.5,0.5,0.0)$，$\\Delta t = 0.05$，$N = 600$。按 P0, P1, P2 的顺序报告三个浮点数。\n\n您的程序必须为每个测试用例和策略计算上述 $\\Delta T$ 值，并以完全相同的格式打印单行输出：一个包含十二个逗号分隔浮点数的列表，对应于 $[\\Delta T_{\\text{P0,TC1}},\\Delta T_{\\text{P1,TC1}},\\Delta T_{\\text{P2,TC1}},\\Delta T_{\\text{P0,TC2}},\\Delta T_{\\text{P1,TC2}},\\Delta T_{\\text{P2,TC2}},\\Delta T_{\\text{P0,TC3}},\\Delta T_{\\text{P1,TC3}},\\Delta T_{\\text{P2,TC3}},\\Delta T_{\\text{P0,TC4}},\\Delta T_{\\text{P1,TC4}},\\Delta T_{\\text{P2,TC4}}]$。",
            "solution": "用户提供的问题具有科学依据、定义明确、客观且内容完整；因此被判定为 **有效**。我们将提供完整的解决方案。\n\n该问题要求实现并分析一个用于无力矩刚体转动动力学的数值积分器。朝向由单位四元数 $q$ 描述，其演化与物体坐标系中的角速度 $\\omega$ 耦合。问题的核心在于比较三种不同的策略（P0, P1, P2），这些策略用于处理违反四元数单位范数约束的数值误差，以及管理四元数表示中固有的符号模糊性（$q \\sim -q$）。\n\n### 1. 理论框架\n\n刚体的动力学由牛顿-欧拉方程控制。对于无力矩系统，在固连于物体的的主轴坐标系中的转动由欧拉方程描述：\n$$\nI \\dot{\\omega} = - \\omega \\times (I \\omega)\n$$\n其中 $I = \\operatorname{diag}(I_1, I_2, I_3)$ 是主转动惯量的对角张量，$\\omega \\in \\mathbb{R}^3$ 是物体坐标系中的角速度向量。\n\n物体的朝向由单位四元数 $q = (q_0, q_x, q_y, q_z) \\in \\mathbb{R}^4$ 表示，它必须满足完整约束 $C(q) = q^\\top q - 1 = 0$。将四元数的时间导数与角速度联系起来的运动学方程是：\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\Omega\n$$\n其中 $\\Omega = (0, \\omega)$ 是一个纯虚四元数（标量部分为零），$\\otimes$ 表示四元数乘法。\n\n转动动能由 $K = \\frac{1}{2} \\omega^\\top I \\omega$ 给出。根据能量均分定理，对于具有 $f=3$ 个自由度的系统，瞬时转动温度为 $T_{\\text{rot}} = \\frac{2K}{f k_B}$。使用玻尔兹曼常数 $k_B=1$ 的约化单位，这可以简化为：\n$$\nT_{\\text{rot}} = \\frac{2}{3} K = \\frac{1}{3} \\omega^\\top I \\omega\n$$\n\n### 2. 数值积分方案\n\n我们构建一个离散时间步进算法来求解这些耦合的微分方程。模拟从初始状态 $(q_0, \\omega_0)$ 开始，时间步长为 $\\Delta t$。必须以归一化的四元数开始，因此提供的初始 $q_0$ 首先被缩放以使其单位长度。每个步长 $n \\to n+1$ 都包含以下序列：\n\n**步骤 2.1：角速度预测**\n使用显式前向欧拉步来预测下一时间步的角速度：\n$$\n\\omega_{n+1}^{\\text{pred}} = \\omega_n + \\Delta t \\, I^{-1} (-\\omega_n \\times (I \\omega_n))\n$$\n这个新速度 $\\omega_{n+1}^{\\text{pred}}$ 是一个未校正的预测值。\n\n**步骤 2.2：四元数更新**\n使用半隐式方案更新四元数，其中朝向 $q_n$ 使用预测的角速度 $\\omega_{n+1}^{\\text{pred}}$ 进行推进：\n$$\n\\dot{q}_n = \\frac{1}{2} q_n \\otimes (0, \\omega_{n+1}^{\\text{pred}})\n$$\n$$\nq_{n+1}^{\\text{unc}} = q_n + \\Delta t \\, \\dot{q}_n\n$$\n由于离散化误差，得到的四元数 $q_{n+1}^{\\text{unc}}$ 将不具有完美的单位范数。\n\n### 3. 约束和等价性处理\n\n为了保持物理和数学上的一致性，必须在每个步骤中强制执行约束。问题为此定义了三种策略。\n\n**策略 P0：仅 SHAKE**\n这是最简单的策略。它仅通过归一化未约束的四元数来强制执行位置级约束 $q^\\top q = 1$。此过程通常被称为针对位置的 SHAKE 算法。\n$$\nq_{n+1} = \\frac{q_{n+1}^{\\text{unc}}}{\\|q_{n+1}^{\\text{unc}}\\|}\n$$\n在此策略中，下一步的角速度就是预测的角速度，即 $\\omega_{n+1} = \\omega_{n+1}^{\\text{pred}}$。此方法不校正速度以使其与校正后的位置保持一致，这通常会导致系统总能量出现系统性漂移。\n\n**策略 P1 和 P2：SHAKE、符号约定和 RATTLE**\n这些策略更为复杂。它们在 SHAKE 的基础上，增加了对四元数的符号约定和对角速度的 RATTLE 校正。\n\n**步骤 3.1：符号约定 (P1 和 P2)**\n归一化 (SHAKE) 后，将四元数 $q_{n+1}$ 投影到规范表示以处理 $q \\sim -q$ 等价性。\n- **P1 (半球)：** 如果四元数的标量部分为负，则翻转该四元数，以确保 $q_{n+1, 0} \\ge 0$。这将表示强制到 4D 超球体的一侧。\n- **P2 (最大重叠)：** 如果四元数与前一步的四元数反平行，则翻转该四元数，以确保 $q_{n+1}^\\top q_n \\ge 0$。这最小化了轨迹中连续四元数之间的“距离”，通常会使模拟更平滑、更稳定。\n\n**步骤 3.2：速度校正 (RATTLE)**\n离散化破坏了速度级约束，该约束规定 $\\dot{q}$ 必须在 $q$ 点与单位超球体相切（即 $q^\\top\\dot{q}=0$）。RATTLE 校正角速度以恢复此属性。\n首先，我们定义一个矩阵 $S(q) \\in \\mathbb{R}^{4 \\times 3}$，它通过 $\\dot{q} = \\frac{1}{2}S(q)\\omega$ 线性地关联 $\\omega$ 和 $\\dot{q}$：\n$$\nS(q) = \\begin{pmatrix} -q_x & -q_y & -q_z \\\\ q_0 & -q_z & q_y \\\\ q_z & q_0 & -q_x \\\\ -q_y & q_x & q_0 \\end{pmatrix}\n$$\nRATTLE 程序如下：\n1.  使用校正后的位置 $q_{n+1}$ 和预测的角速度 $\\omega_{n+1}^{\\text{pred}}$ 定义一个临时的四元数速度：$\\dot{q}^{\\text{temp}} = \\frac{1}{2}S(q_{n+1})\\omega_{n+1}^{\\text{pred}}$。\n2.  通过移除其法向分量，将此速度投影到 $q_{n+1}$ 处的切空间：$\\dot{q}^{\\text{proj}} = \\dot{q}^{\\text{temp}} - (q_{n+1}^\\top \\dot{q}^{\\text{temp}}) q_{n+1}$。\n3.  通过以最小二乘意义求解 $\\frac{1}{2}S(q_{n+1})\\omega = \\dot{q}^{\\text{proj}}$ 来找到产生此投影速度的校正角速度 $\\omega_{n+1}$。矩阵 $S(q)$ 有一个有用的性质：对于单位四元数 $q$，$S(q)^\\top S(q) = I_{3\\times3}$，其中 $I_{3 \\times 3}$ 是单位矩阵。这意味着伪逆就是 $S(q)^\\top$。因此，解是一个直接计算：\n    $$\n    \\omega_{n+1} = 2 S(q_{n+1})^\\top \\dot{q}^{\\text{proj}}\n    $$\n这个 $\\omega_{n+1}$ 是该步骤最终的、校正后的角速度，用于计算动能并将动力学传播到下一步。\n\n### 4. 分析\n\n对于每个策略和测试用例，模拟运行 $N$ 步。在每个步骤 $i=1, \\dots, N$，使用该步骤的最终状态 $(q_i, \\omega_i)$ 计算瞬时转动温度 $T_i$。时间平均温度为 $\\overline{T_{\\text{rot}}} = \\frac{1}{N}\\sum_{i=1}^{N} T_i$。将其与从初始状态 $(q_0, \\omega_0)$ 推导出的理论基线温度 $T_0$ 进行比较。最终报告的值是偏差 $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$，它量化了每种策略的能量守恒特性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and strategies\n    and print the results in the required format.\n    \"\"\"\n\n    def quaternion_mult(q1, q2):\n        \"\"\"\n        Performs quaternion multiplication q1 * q2.\n        q1 and q2 are 4-element NumPy arrays.\n        \"\"\"\n        q1_0, q1_v = q1[0], q1[1:]\n        q2_0, q2_v = q2[0], q2[1:]\n        \n        result_0 = q1_0 * q2_0 - np.dot(q1_v, q2_v)\n        result_v = q1_0 * q2_v + q2_0 * q1_v + np.cross(q1_v, q2_v)\n        \n        return np.array([result_0, result_v[0], result_v[1], result_v[2]])\n\n    def get_S_matrix(q):\n        \"\"\"\n        Constructs the 4x3 matrix S(q) such that q_dot = 0.5 * S(q) * omega.\n        \"\"\"\n        q0, qx, qy, qz = q\n        S = np.array([\n            [-qx, -qy, -qz],\n            [ q0, -qz,  qy],\n            [ qz,  q0, -qx],\n            [-qy,  qx,  q0]\n        ])\n        return S\n\n    def run_simulation(I_diag, q_initial, omega_initial, dt, N, strategy):\n        \"\"\"\n        Runs a single rigid body simulation for N steps.\n        \n        Args:\n            I_diag (tuple): Principal moments of inertia (I1, I2, I3).\n            q_initial (tuple): Initial orientation quaternion (q0, qx, qy, qz).\n            omega_initial (tuple): Initial angular velocity (wx, wy, wz).\n            dt (float): Time step.\n            N (int): Number of steps.\n            strategy (str): 'P0', 'P1', or 'P2'.\n            \n        Returns:\n            float: The temperature difference Delta_T = avg(T_rot) - T0.\n        \"\"\"\n        I = np.diag(I_diag).astype(np.float64)\n        I_inv = np.diag(1.0 / np.array(I_diag)).astype(np.float64)\n        \n        q = np.array(q_initial, dtype=np.float64)\n        # Normalize the initial quaternion to ensure it satisfies the constraint\n        q /= np.linalg.norm(q)\n        \n        omega = np.array(omega_initial, dtype=np.float64)\n        \n        # Calculate baseline kinetic energy and temperature from initial conditions\n        K0 = 0.5 * np.dot(omega, np.dot(I, omega))\n        T0 = (2.0 * K0) / 3.0  # Given f=3, kB=1\n        \n        total_temperature = 0.0\n        \n        q_prev_for_p2 = q.copy()\n\n        for _ in range(N):\n            # Step 1: Predict angular velocity using explicit Euler\n            torque = -np.cross(omega, np.dot(I, omega))\n            omega_pred = omega + dt * np.dot(I_inv, torque)\n            \n            # Step 2: Update quaternion with a semi-implicit step\n            omega_pred_quat = np.concatenate(([0], omega_pred))\n            q_dot = 0.5 * quaternion_mult(q, omega_pred_quat)\n            q_unc = q + dt * q_dot\n            \n            # Step 3: Enforce position constraint (SHAKE)\n            q_next = q_unc / np.linalg.norm(q_unc)\n            \n            omega_next = omega_pred\n            \n            # Step 4  5: Apply sign conventions and velocity constraints (RATTLE)\n            if strategy == 'P0':\n                # No sign convention, no RATTLE.\n                pass\n            \n            elif strategy == 'P1':\n                # Hemisphere sign convention\n                if q_next[0]  0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_S_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                S_next = get_S_matrix(q_next)\n                # S(q)^T S(q) = ||q||^2 * I_3. For unit q, pseudo-inverse is S(q)^T.\n                omega_next = 2.0 * np.dot(S_next.T, q_dot_proj)\n            \n            elif strategy == 'P2':\n                # Maximum-overlap sign convention\n                if np.dot(q_next, q)  0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_S_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                S_next = get_S_matrix(q_next)\n                omega_next = 2.0 * np.dot(S_next.T, q_dot_proj)\n\n            # Update state for the next iteration\n            q = q_next\n            omega = omega_next\n            \n            # Calculate instantaneous kinetic energy and temperature from the final state of the step\n            K_current = 0.5 * np.dot(omega, np.dot(I, omega))\n            T_current = (2.0 * K_current) / 3.0\n            total_temperature += T_current\n            \n        # Compute average temperature over the trajectory and the final difference\n        avg_T_rot = total_temperature / N\n        delta_T = avg_T_rot - T0\n        \n        return delta_T\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # TC1\n        {'I': (1.0, 1.0, 1.0), 'q0': (1.0, 0.0, 0.0, 0.0), 'omega0': (0.2, 0.3, 0.4), 'dt': 0.01, 'N': 1000},\n        # TC2\n        {'I': (1.0, 1.0, 1.0), 'q0': (-0.001, 0.70710678, 0.0, 0.70710678), 'omega0': (0.8, 0.0, 0.0), 'dt': 0.02, 'N': 1200},\n        # TC3\n        {'I': (1.0, 1.5, 2.0), 'q0': (0.92387953, 0.38268343, 0.0, 0.0), 'omega0': (0.7, 0.01, 0.02), 'dt': 0.02, 'N': 1500},\n        # TC4\n        {'I': (0.8, 1.2, 1.6), 'q0': (0.0, 0.70710678, 0.70710678, 0.0), 'omega0': (0.5, 0.5, 0.0), 'dt': 0.05, 'N': 600}\n    ]\n\n    results = []\n    strategies = ['P0', 'P1', 'P2']\n\n    for case in test_cases:\n        for strategy in strategies:\n            delta_T = run_simulation(\n                case['I'], case['q0'], case['omega0'], case['dt'], case['N'], strategy\n            )\n            results.append(delta_T)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在单个刚体之外，许多分子系统（如蛋白质结构域或高分子链段）被建模为相互连接的刚性区域，这要求我们对其相对取向施加约束。本练习  将约束动力学的概念推广到双体系统，你将运用拉格朗日乘子法和 Baumgarte 稳定化方法推导并实现必要的约束转矩。这个实践将为你建立模拟复杂多域分子结构所需的基础。",
            "id": "3442432",
            "problem": "考虑一个聚合物的分子动力学 (MD) 模拟中的两个刚性域。每个域被建模为一个刚体，其方向由单位四元数 $q \\in \\mathbb{H}$ 表示，对应的旋转矩阵为 $R(q) \\in \\mathbb{R}^{3 \\times 3}$。设 $\\hat{\\mathbf{n}}_1 \\in \\mathbb{R}^3$ 和 $\\hat{\\mathbf{n}}_2 \\in \\mathbb{R}^3$ 分别是嵌入在域1和域2的物体坐标系中的固定单位向量。定义连接两个域方向的完整标量约束为\n$$\ng(\\mathbf{q}_1,\\mathbf{q}_2) = \\hat{\\mathbf{n}}_1^\\top R(\\mathbf{q}_1)^\\top R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2 - c,\n$$\n其中 $c \\in [-1,1]$ 是一个指定的常数。嵌入方向在世界坐标系中的映像为 $\\mathbf{a}_1 = R(\\mathbf{q}_1)\\,\\hat{\\mathbf{n}}_1$ 和 $\\mathbf{a}_2 = R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2$，因此约束简化为 $g = \\mathbf{a}_1^\\top \\mathbf{a}_2 - c$。\n\n从适用于带四元数表示的刚体动力学的第一性原理出发，即：\n- 牛顿-欧拉旋转动力学，其中转动惯量为 $I \\in \\mathbb{R}^{3 \\times 3}$，角速度为 $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$。\n- 固定物体坐标系向量的运动学关系：若 $\\mathbf{a}(t) = R(\\mathbf{q}(t))\\,\\hat{\\mathbf{n}}$，则 $\\dot{\\mathbf{a}} = \\boldsymbol{\\omega} \\times \\mathbf{a}$。\n- 单位四元数及其关联旋转矩阵的定义。\n\n使用拉格朗日乘子，推导作用于每个域上的方向约束力（以力矩形式表示）的表达式。假设每个域的转动惯量是各向同性的，即 $I_1 = \\mathcal{I}_1 \\mathbf{I}_{3}$ 和 $I_2 = \\mathcal{I}_2 \\mathbf I_{3}$，其中 $\\mathbf{I}_{3}$ 是 $3 \\times 3$ 单位矩阵，$\\mathcal{I}_1,\\mathcal{I}_2 > 0$ 是标量。您必须得出一个显式算法，用于在给定瞬时状态 $(\\mathbf{q}_1,\\mathbf{q}_2,\\boldsymbol{\\omega}_1,\\boldsymbol{\\omega}_2)$ 和外加力矩 $\\boldsymbol{\\tau}_{\\text{app},1}, \\boldsymbol{\\tau}_{\\text{app},2}$ 的情况下，计算瞬时约束拉格朗日乘子 $\\lambda$ 以及作用在域1和域2上的相应约束力矩 $\\boldsymbol{\\tau}_{c,1}$ 和 $\\boldsymbol{\\tau}_{c,2}$。使用带有参数 $\\alpha$ 和 $\\beta$ 的标准稳定化形式，使得目标约束演化满足 $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$。\n\n您的程序必须：\n1. 为单位四元数实现四元数到旋转矩阵 $R(\\mathbf{q})$ 的映射。\n2. 计算 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和标量约束 $g$。\n3. 计算作用于角速度的瞬时雅可比矩阵，以及与假定的各向同性惯量一致地评估 $\\dot{g}$ 和 $\\ddot{g}$ 所需的运动学量。\n4. 使用稳定化参数 $\\alpha$ 和 $\\beta$ 求解瞬时的标量拉格朗日乘子 $\\lambda$，并生成作用在两个域上的相应约束力矩。\n5. 稳健地处理瞬时约束雅可比范数小于指定阈值 $\\varepsilon > 0$ 的退化构型。\n\n所有角度必须以弧度为单位。角速度必须以弧度/秒为单位。转动惯量必须以千克·米²为单位。力矩必须以牛顿·米为单位。\n\n测试套件：\n请提供以下三个测试用例的结果。在每个用例中，最终输出必须严格根据所提供的参数计算得出。\n\n- 用例A (正常路径):\n    - $\\mathbf{q}_1$：单位四元数。\n    - $\\mathbf{q}_2$：绕z轴的轴-角旋转，角度为 $\\theta = \\pi/3$ 弧度。\n    - $\\hat{\\mathbf{n}}_1 = [1,0,0]^\\top$，$\\hat{\\mathbf{n}}_2 = [1,0,0]^\\top$。\n    - $c = 0.5$。\n    - $\\mathcal{I}_1 = 1.0$，$\\mathcal{I}_2 = 1.0$ (千克·米²)。\n    - $\\boldsymbol{\\omega}_1 = [0.0,0.2,0.0]^\\top$ (弧度/秒)，$\\boldsymbol{\\omega}_2 = [0.0,-0.1,0.0]^\\top$ (弧度/秒)。\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.0,0.0,0.0]^\\top$ (牛顿·米)，$\\boldsymbol{\\tau}_{\\text{app},2} = [0.0,0.0,0.0]^\\top$ (牛顿·米)。\n    - 稳定化参数: $\\alpha = 50.0$ (1/秒²)，$\\beta = 5.0$ (1/秒)。\n    - 退化阈值: $\\varepsilon = 10^{-10}$。\n\n- 用例B (边界退化):\n    - $\\mathbf{q}_1$：单位四元数。\n    - $\\mathbf{q}_2$：单位四元数。\n    - $\\hat{\\mathbf{n}}_1 = [0,1,0]^\\top$，$\\hat{\\mathbf{n}}_2 = [0,1,0]^\\top$。\n    - $c = 1.0$。\n    - $\\mathcal{I}_1 = 1.0$，$\\mathcal{I}_2 = 2.0$ (千克·米²)。\n    - $\\boldsymbol{\\omega}_1 = [0.5,0.0,0.0]^\\top$ (弧度/秒)，$\\boldsymbol{\\omega}_2 = [0.0,0.5,0.0]^\\top$ (弧度/秒)。\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.1,0.0,0.0]^\\top$ (牛顿·米)，$\\boldsymbol{\\tau}_{\\text{app},2} = [0.0,0.1,0.0]^\\top$ (牛顿·米)。\n    - 稳定化参数: $\\alpha = 50.0$ (1/秒²)，$\\beta = 5.0$ (1/秒)。\n    - 退化阈值: $\\varepsilon = 10^{-10}$。\n\n- 用例C (具有非零误差的一般未对齐情况):\n    - $\\mathbf{q}_1$：绕x轴的轴-角旋转，角度为 $\\theta = \\pi/4$ 弧度。\n    - $\\mathbf{q}_2$：绕y轴的轴-角旋转，角度为 $\\theta = \\pi/6$ 弧度。\n    - $\\hat{\\mathbf{n}}_1 = [0,1,0]^\\top$, $\\hat{\\mathbf{n}}_2 = [0,0,1]^\\top$。\n    - $c = 0.2$。\n    - $\\mathcal{I}_1 = 0.8$，$\\mathcal{I}_2 = 1.2$ (千克·米²)。\n    - $\\boldsymbol{\\omega}_1 = [0.1,0.2,-0.1]^\\top$ (弧度/秒)，$\\boldsymbol{\\omega}_2 = [-0.05,0.0,0.15]^\\top$ (弧度/秒)。\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.0,0.0,0.0]^\\top$ (牛顿·米)，$\\boldsymbol{\\tau}_{\\text{app},2} = [0.01,-0.02,0.0]^\\top$ (牛顿·米)。\n    - 稳定化参数: $\\alpha = 100.0$ (1/秒²)，$\\beta = 10.0$ (1/秒)。\n    - 退化阈值: $\\varepsilon = 10^{-10}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含七个浮点数的列表，顺序为 $[\\lambda,\\tau_{c,1,x},\\tau_{c,1,y},\\tau_{c,1,z},\\tau_{c,2,x},\\tau_{c,2,y},\\tau_{c,2,z}]$。例如，输出格式必须如下所示\n$$\n[\\,[\\lambda_A,\\dots],\\,[\\lambda_B,\\dots],\\,[\\lambda_C,\\dots]\\,]\n$$\n以单行打印，不含空格。",
            "solution": "用户提供了一个有效的问题陈述，该问题基于经典力学和多体动力学的原理。该问题是适定的、客观的，并包含了推导唯一且有意义的解所需的所有信息。任务是推导并实现一种算法，用于计算两个刚体之間完整方向约束的约束力矩，这是分子动力学模拟中的一个标准问题。\n\n下面将按照要求，遵循第一性原理，介绍推导过程和最终的算法。\n\n### 1. 约束和运动学\n该系统由两个刚性域组成，其方向由单位四元数 $\\mathbf{q}_1$ 和 $\\mathbf{q}_2$ 给出，对应的旋转矩阵为 $R(\\mathbf{q}_1)$ 和 $R(\\mathbf{q}_2)$。完整约束定义在两个物体固定的单位向量 $\\hat{\\mathbf{n}}_1$ 和 $\\hat{\\mathbf{n}}_2$ 的相对方向上：\n$$\ng(\\mathbf{q}_1,\\mathbf{q}_2) = \\hat{\\mathbf{n}}_1^\\top R(\\mathbf{q}_1)^\\top R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2 - c = 0\n$$\n其中 $c \\in [-1,1]$ 是一个常数。令 $\\mathbf{a}_1 = R(\\mathbf{q}_1)\\,\\hat{\\mathbf{n}}_1$ 和 $\\mathbf{a}_2 = R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2$ 为这些向量在世界坐标系中的表示。约束简化为：\n$$\ng = \\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c = 0\n$$\n这些世界坐标系向量的运动学演化由物体固定向量的关系给出，其中 $\\boldsymbol{\\omega}_i$ 是物体 $i$ 的角速度：\n$$\n\\dot{\\mathbf{a}}_i = \\boldsymbol{\\omega}_i \\times \\mathbf{a}_i\n$$\n\n### 2. 约束力矩的推导\n约束力矩 $\\boldsymbol{\\tau}_{c,1}$ 和 $\\boldsymbol{\\tau}_{c,2}$ 是根据虚功原理推导出来的，即对于任何与约束一致的虚位移，约束力所做的虚功为零。对于单个标量约束 $g$，约束力矩与 $g$ 相对于旋转广义坐标的梯度成正比。物体 $i$ 的广义力（力矩）为 $\\boldsymbol{\\tau}_{c,i} = \\lambda \\frac{\\partial g}{\\partial \\boldsymbol{\\theta}_i}$，其中 $\\delta \\boldsymbol{\\theta}_i$ 是一个无穷小旋转向量。\n\n$g$ 的变分为：\n$$\n\\delta g = \\frac{\\partial g}{\\partial \\mathbf{a}_1} \\cdot \\delta \\mathbf{a}_1 + \\frac{\\partial g}{\\partial \\mathbf{a}_2} \\cdot \\delta \\mathbf{a}_2 = \\mathbf{a}_2 \\cdot \\delta \\mathbf{a}_1 + \\mathbf{a}_1 \\cdot \\delta \\mathbf{a}_2\n$$\n由无穷小旋转 $\\delta \\boldsymbol{\\theta}_i$ 引起的 $\\mathbf{a}_i$ 的变分为 $\\delta \\mathbf{a}_i = \\delta \\boldsymbol{\\theta}_i \\times \\mathbf{a}_i$。将其代入 $\\delta g$ 的表达式中：\n$$\n\\delta g = \\mathbf{a}_2 \\cdot (\\delta \\boldsymbol{\\theta}_1 \\times \\mathbf{a}_1) + \\mathbf{a}_1 \\cdot (\\delta \\boldsymbol{\\theta}_2 \\times \\mathbf{a}_2)\n$$\n使用标量三重积恒等式 $\\mathbf{A} \\cdot (\\mathbf{B} \\times \\mathbf{C}) = (\\mathbf{A} \\times \\mathbf{B}) \\cdot \\mathbf{C}$：\n$$\n\\delta g = (\\mathbf{a}_2 \\times \\mathbf{a}_1) \\cdot \\delta \\boldsymbol{\\theta}_1 + (\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta \\boldsymbol{\\theta}_2 = (\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta\\boldsymbol{\\theta}_2 - (\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta\\boldsymbol{\\theta}_1\n$$\n约束力矩所做的虚功为 $\\delta W_c = \\boldsymbol{\\tau}_{c,1} \\cdot \\delta \\boldsymbol{\\theta}_1 + \\boldsymbol{\\tau}_{c,2} \\cdot \\delta \\boldsymbol{\\theta}_2$。根据虚功原理，$\\delta W_c = \\lambda \\delta g$。通过比较各项，我们可以确定约束力矩：\n$$\n\\boldsymbol{\\tau}_{c,1} = -\\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n$$\n\\boldsymbol{\\tau}_{c,2} = \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n这个形式与牛顿第三定律一致：作用在物体1上的力矩与作用在物体2上的力矩大小相等，方向相反。\n\n### 3. 拉格朗日乘子方程\n为了求出标量拉格朗日乘子 $\\lambda$，我们使用稳定化条件 $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$。这需要 $\\dot{g}$ 和 $\\ddot{g}$ 的表达式。\n\n约束的一阶时间导数为：\n$$\n\\dot{g} = \\frac{d}{dt}(\\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c) = \\dot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\dot{\\mathbf{a}}_2\n$$\n代入运动学关系 $\\dot{\\mathbf{a}}_i = \\boldsymbol{\\omega}_i \\times \\mathbf{a}_i$：\n$$\n\\dot{g} = (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1) \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)\n$$\n使用标量三重积恒等式，这变为：\n$$\n\\dot{g} = \\boldsymbol{\\omega}_1 \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2) + \\boldsymbol{\\omega}_2 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_1) = (\\boldsymbol{\\omega}_1 - \\boldsymbol{\\omega}_2) \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n二阶时间导数为：\n$$\n\\ddot{g} = \\frac{d}{dt}(\\dot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\dot{\\mathbf{a}}_2) = \\ddot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\ddot{\\mathbf{a}}_2 + 2(\\dot{\\mathbf{a}}_1 \\cdot \\dot{\\mathbf{a}}_2)\n$$\n世界坐标系中的向量加速度 $\\ddot{\\mathbf{a}}_i$ 为：\n$$\n\\ddot{\\mathbf{a}}_i = \\frac{d}{dt}(\\boldsymbol{\\omega}_i \\times \\mathbf{a}_i) = \\dot{\\boldsymbol{\\omega}}_i \\times \\mathbf{a}_i + \\boldsymbol{\\omega}_i \\times \\dot{\\mathbf{a}}_i = \\dot{\\boldsymbol{\\omega}}_i \\times \\mathbf{a}_i + \\boldsymbol{\\omega}_i \\times (\\boldsymbol{\\omega}_i \\times \\mathbf{a}_i)\n$$\n需要牛顿-欧拉运动方程来求 $\\dot{\\boldsymbol{\\omega}}_i$。对于各向同性惯性张量 $I_i = \\mathcal{I}_i \\mathbf{I}_3$，方程为 $\\mathcal{I}_i \\dot{\\boldsymbol{\\omega}}_i = \\boldsymbol{\\tau}_i$，其中 $\\boldsymbol{\\tau}_i = \\boldsymbol{\\tau}_{\\text{app},i} + \\boldsymbol{\\tau}_{c,i}$ 是总力矩（外加力矩加约束力矩）。代入约束力矩：\n$$\n\\dot{\\boldsymbol{\\omega}}_1 = \\frac{1}{\\mathcal{I}_1}(\\boldsymbol{\\tau}_{\\text{app},1} - \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2))\n$$\n$$\n\\dot{\\boldsymbol{\\omega}}_2 = \\frac{1}{\\mathcal{I}_2}(\\boldsymbol{\\tau}_{\\text{app},2} + \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2))\n$$\n现在，将这些代入 $\\ddot{g}$ 的表达式中。结果可以分为一个关于 $\\lambda$ 的线性项和一个不依赖于 $\\lambda$ 的项。\n$$\n\\ddot{g} = \\ddot{g}_{\\lambda} + \\ddot{g}_0\n$$\n依赖于 $\\lambda$ 的项 $\\ddot{g}_{\\lambda}$ 是：\n$$\n\\ddot{g}_{\\lambda} = \\left(-\\frac{\\lambda}{\\mathcal{I}_1}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\times \\mathbf{a}_1\\right) \\cdot \\mathbf{a}_2 + \\left(\\frac{\\lambda}{\\mathcal{I}_2}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\times \\mathbf{a}_2\\right) \\cdot \\mathbf{a}_1\n$$\n使用标量三重积，这可以简化为：\n$$\n\\ddot{g}_{\\lambda} = -\\frac{\\lambda}{\\mathcal{I}_1}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2) + \\frac{\\lambda}{\\mathcal{I}_2}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_1) = -\\lambda \\left(\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}\\right) \\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2\n$$\n我们定义约束的有效逆质量 $K$：\n$$\nK = \\left(\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}\\right) \\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2\n$$\n不依赖于 $\\lambda$ 的项 $\\ddot{g}_0$ 是在没有施加约束力的情况下约束的加速度：\n$$\n\\ddot{g}_0 = \\left(\\frac{\\boldsymbol{\\tau}_{\\text{app},1}}{\\mathcal{I}_1} \\times \\mathbf{a}_1\\right) \\cdot \\mathbf{a}_2 + \\left(\\frac{\\boldsymbol{\\tau}_{\\text{app},2}}{\\mathcal{I}_2} \\times \\mathbf{a}_2\\right) \\cdot \\mathbf{a}_1 + [\\boldsymbol{\\omega}_1 \\times (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1)] \\cdot \\mathbf{a}_2 + [\\boldsymbol{\\omega}_2 \\times (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)] \\cdot \\mathbf{a}_1 + 2(\\dot{\\mathbf{a}}_1 \\cdot \\dot{\\mathbf{a}}_2)\n$$\n稳定化方程 $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$ 变为 $-\\ddot{g}_{\\lambda} = \\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g$，所以 $K\\lambda = \\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g$。求解 $\\lambda$：\n$$\n\\lambda = \\frac{\\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g}{K}\n$$\n这在 $K$ 不为零的情况下有效。当 $\\mathbf{a}_1$ 和 $\\mathbf{a}_2$ 平行或反平行时，会出现退化构型，使得 $\\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2 = 0$ 从而 $K=0$。在这种情况下，约束力矩无法唯一确定。问题要求通过检查 $K  \\varepsilon$（其中 $\\varepsilon > 0$ 是一个很小的阈值）来处理这种情况。如果满足条件，我们设置 $\\lambda = 0$。\n\n### 4. 算法摘要\n完整的算法如下：\n1.  给定 $\\mathbf{q}_1, \\mathbf{q}_2, \\hat{\\mathbf{n}}_1, \\hat{\\mathbf{n}}_2, c, \\mathcal{I}_1, \\mathcal{I}_2, \\boldsymbol{\\omega}_1, \\boldsymbol{\\omega}_2, \\boldsymbol{\\tau}_{\\text{app},1}, \\boldsymbol{\\tau}_{\\text{app},2}, \\alpha, \\beta, \\varepsilon$。\n2.  计算旋转矩阵 $R_1=R(\\mathbf{q}_1)$ 和 $R_2=R(\\mathbf{q}_2)$。\n3.  计算世界坐标系向量：$\\mathbf{a}_1 = R_1 \\hat{\\mathbf{n}}_1$，$\\mathbf{a}_2 = R_2 \\hat{\\mathbf{n}}_2$。\n4.  计算约束违反值：$g = \\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c$。\n5.  计算叉积向量，这是计算的核心：$\\mathbf{v} = \\mathbf{a}_1 \\times \\mathbf{a}_2$。\n6.  计算约束速度：$\\dot{g} = (\\boldsymbol{\\omega}_1 - \\boldsymbol{\\omega}_2) \\cdot \\mathbf{v}$。\n7.  计算有效逆质量：$K = (\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}) (\\mathbf{v} \\cdot \\mathbf{v})$。\n8.  检查退化情况：如果 $K  \\varepsilon$，则设置 $\\lambda=0, \\boldsymbol{\\tau}_{c,1}=\\mathbf{0}, \\boldsymbol{\\tau}_{c,2}=\\mathbf{0}$ 并终止此用例的计算。\n9.  计算 $\\ddot{g}_0$：\n    a. 外加力矩项：$\\ddot{g}_{\\text{app}} = -\\frac{1}{\\mathcal{I}_1} \\boldsymbol{\\tau}_{\\text{app},1} \\cdot \\mathbf{v} + \\frac{1}{\\mathcal{I}_2} \\boldsymbol{\\tau}_{\\text{app},2} \\cdot \\mathbf{v}$。\n    b. 运动学项 $\\dot{J}\\omega$：$\\ddot{g}_{\\text{kin}} = [\\boldsymbol{\\omega}_1 \\times (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1)] \\cdot \\mathbf{a}_2 + [\\boldsymbol{\\omega}_2 \\times (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)] \\cdot \\mathbf{a}_1 + 2 ((\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1) \\cdot (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2))$。\n    c. $\\ddot{g}_0 = \\ddot{g}_{\\text{app}} + \\ddot{g}_{\\text{kin}}$。\n10. 求解拉格朗日乘子：$\\lambda = (\\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g) / K$。\n11. 计算约束力矩：$\\boldsymbol{\\tau}_{c,1} = -\\lambda \\mathbf{v}$，$\\boldsymbol{\\tau}_{c,2} = \\lambda \\mathbf{v}$。\n12. 返回结果 $[\\lambda, \\tau_{c,1,x}, \\tau_{c,1,y}, \\tau_{c,1,z}, \\tau_{c,2,x}, \\tau_{c,2,y}, \\tau_{c,2,z}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the given problem for all test cases.\n    \"\"\"\n\n    def axis_angle_to_quaternion(axis, angle):\n        \"\"\"Converts an axis-angle rotation to a unit quaternion (w, x, y, z).\"\"\"\n        axis = np.asarray(axis, dtype=float)\n        norm = np.linalg.norm(axis)\n        if norm  1e-12:\n            return np.array([1.0, 0.0, 0.0, 0.0])\n        axis = axis / norm\n        half_angle = angle / 2.0\n        s = np.sin(half_angle)\n        return np.array([np.cos(half_angle), axis[0] * s, axis[1] * s, axis[2] * s])\n\n    def quaternion_to_rotation_matrix(q):\n        \"\"\"Converts a unit quaternion (w, x, y, z) to a 3x3 rotation matrix.\"\"\"\n        w, x, y, z = q\n        # Ensure it's a unit quaternion\n        norm_sq = w*w + x*x + y*y + z*z\n        if abs(norm_sq - 1.0) > 1e-9:\n             # Normalize if not unit, though inputs should be\n             norm = np.sqrt(norm_sq)\n             w, x, y, z = w/norm, x/norm, y/norm, z/norm\n\n        R = np.zeros((3, 3))\n        \n        # Using the standard formula\n        R[0, 0] = 1.0 - 2.0 * (y**2 + z**2)\n        R[0, 1] = 2.0 * (x * y - w * z)\n        R[0, 2] = 2.0 * (x * z + w * y)\n        R[1, 0] = 2.0 * (x * y + w * z)\n        R[1, 1] = 1.0 - 2.0 * (x**2 + z**2)\n        R[1, 2] = 2.0 * (y * z - w * x)\n        R[2, 0] = 2.0 * (x * z - w * y)\n        R[2, 1] = 2.0 * (y * z + w * x)\n        R[2, 2] = 1.0 - 2.0 * (x**2 + y**2)\n        \n        return R\n\n    def calculate_constraint_forces(params):\n        \"\"\"\n        Calculates the Lagrange multiplier and constraint torques for one case.\n        \"\"\"\n        q1_in, q2_in = params['q1'], params['q2']\n        n1_hat, n2_hat = np.array(params['n1_hat']), np.array(params['n2_hat'])\n        c = params['c']\n        I1, I2 = params['I1'], params['I2']\n        inv_I1, inv_I2 = 1.0 / I1, 1.0 / I2\n        omega1, omega2 = np.array(params['omega1']), np.array(params['omega2'])\n        tau_app1, tau_app2 = np.array(params['tau_app1']), np.array(params['tau_app2'])\n        alpha, beta = params['alpha'], params['beta']\n        epsilon = params['epsilon']\n\n        R1 = quaternion_to_rotation_matrix(q1_in)\n        R2 = quaternion_to_rotation_matrix(q2_in)\n\n        a1 = R1 @ n1_hat\n        a2 = R2 @ n2_hat\n\n        # Step 4: Compute constraint value g\n        g = np.dot(a1, a2) - c\n\n        # Step 5: Compute central cross product vector\n        v = np.cross(a1, a2)\n        \n        # Step 6: Compute constraint time derivative g_dot\n        g_dot = np.dot(omega1 - omega2, v)\n        \n        # Step 7: Compute effective inverse mass K\n        K_numerator = np.dot(v, v)\n        K = (inv_I1 + inv_I2) * K_numerator\n        \n        # Step 8: Degeneracy check\n        if abs(K)  epsilon:\n            return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n            \n        # Step 9: Compute g_ddot_0\n        # Contribution from applied torques\n        g_ddot_app = -inv_I1 * np.dot(tau_app1, v) + inv_I2 * np.dot(tau_app2, v)\n\n        # Contribution from kinematic terms (quadratic velocity terms)\n        a1_dot = np.cross(omega1, a1)\n        a2_dot = np.cross(omega2, a2)\n        \n        g_ddot_kin = (\n            np.dot(np.cross(omega1, a1_dot), a2) +\n            np.dot(a1, np.cross(omega2, a2_dot)) +\n            2.0 * np.dot(a1_dot, a2_dot)\n        )\n        \n        g_ddot_0 = g_ddot_app + g_ddot_kin\n\n        # Step 10: Solve for lambda\n        numerator = g_ddot_0 + 2.0 * beta * g_dot + alpha * g\n        lambda_val = numerator / K\n        \n        # Step 11: Compute constraint torques\n        tau_c1 = -lambda_val * v\n        tau_c2 = lambda_val * v\n\n        # Step 12: Collect results\n        result = [lambda_val] + tau_c1.tolist() + tau_c2.tolist()\n        return result\n\n    # Test cases from the problem statement\n    test_cases_params = [\n        # Case A\n        {\n            'q1': np.array([1.0, 0.0, 0.0, 0.0]),\n            'q2': axis_angle_to_quaternion([0, 0, 1], np.pi / 3),\n            'n1_hat': [1.0, 0.0, 0.0], 'n2_hat': [1.0, 0.0, 0.0], 'c': 0.5,\n            'I1': 1.0, 'I2': 1.0,\n            'omega1': [0.0, 0.2, 0.0], 'omega2': [0.0, -0.1, 0.0],\n            'tau_app1': [0.0, 0.0, 0.0], 'tau_app2': [0.0, 0.0, 0.0],\n            'alpha': 50.0, 'beta': 5.0, 'epsilon': 1e-10\n        },\n        # Case B\n        {\n            'q1': np.array([1.0, 0.0, 0.0, 0.0]),\n            'q2': np.array([1.0, 0.0, 0.0, 0.0]),\n            'n1_hat': [0.0, 1.0, 0.0], 'n2_hat': [0.0, 1.0, 0.0], 'c': 1.0,\n            'I1': 1.0, 'I2': 2.0,\n            'omega1': [0.5, 0.0, 0.0], 'omega2': [0.0, 0.5, 0.0],\n            'tau_app1': [0.1, 0.0, 0.0], 'tau_app2': [0.0, 0.1, 0.0],\n            'alpha': 50.0, 'beta': 5.0, 'epsilon': 1e-10\n        },\n        # Case C\n        {\n            'q1': axis_angle_to_quaternion([1, 0, 0], np.pi / 4),\n            'q2': axis_angle_to_quaternion([0, 1, 0], np.pi / 6),\n            'n1_hat': [0.0, 1.0, 0.0], 'n2_hat': [0.0, 0.0, 1.0], 'c': 0.2,\n            'I1': 0.8, 'I2': 1.2,\n            'omega1': [0.1, 0.2, -0.1], 'omega2': [-0.05, 0.0, 0.15],\n            'tau_app1': [0.0, 0.0, 0.0], 'tau_app2': [0.01, -0.02, 0.0],\n            'alpha': 100.0, 'beta': 10.0, 'epsilon': 1e-10\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result_floats = calculate_constraint_forces(params)\n        results.append(f\"[{','.join(f'{x:.8f}' for x in result_floats)}]\")\n\n    # Format output as a single line string\n    final_output = f\"[{','.join(results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "生成轨迹数据只是工作的一半，正确的分析同样至关重要。四元数表示旋转时存在的符号模糊性（$q$ 和 $-q$ 代表相同旋转）会在轨迹数据中引入人为的“跳跃”，使旋转运动的分析变得复杂。这个实践问题  旨在解决这一常见的实际挑战，你将实现并比较不同的“解缠绕”算法，以确保方向轨迹的时间连续性，这对于精确计算角位移和角速度等物理量至关重要。",
            "id": "3442442",
            "problem": "考虑一个在周期性边界条件下的分子动力学中的刚体。在离散时间索引 $t$ 时，该刚体的朝向由一个单位四元数 $q_t \\in \\mathbb{H}$ 表示，其标量部分为 $q_{t,0}$，矢量部分为 $\\mathbf{q}_{t,v}$，并满足 $\\|q_t\\| = 1$。单位四元数表示法是三维特殊正交群 $\\mathrm{SO}(3)$ 的双重覆盖，这意味着 $q$ 和 $-q$ 代表相同的物理旋转。这种符号不确定性在进行朴素的后处理时，可能会在记录的朝向轨迹中产生人为的不连续性，特别是当坐标因周期性边界条件而被重映射，或在不考虑时间连续性的情况下强制施加固定半球符号规则时。\n\n从以下基本依据和定义开始：\n- 一个单位四元数 $q = (q_0, \\mathbf{q}_v)$ 通过映射 $q = \\left(\\cos(\\theta/2), \\hat{\\mathbf{u}} \\sin(\\theta/2)\\right)$ 表示一个绕单位轴 $\\hat{\\mathbf{u}}$ 旋转角度 $\\theta \\in [0, 2\\pi)$ 的旋转。\n- 一个单位四元数的逆是其共轭，即 $q^{-1} = \\bar{q} = (q_0, -\\mathbf{q}_v)$。\n- 哈密顿积 $\\otimes$ 用于组合旋转：如果 $p$ 和 $q$ 是单位四元数，则 $p \\otimes q$ 对应于在旋转 $p$ 之后施加旋转 $q$。\n- 对于两个朝向 $p$ 和 $q$，相对朝向为 $r = p^{-1} \\otimes q$，这对应于绕某个轴旋转角度 $\\Delta \\theta \\in [0, 2\\pi]$。其中 $\\Delta \\theta$ 通过其标量部分 $r_0$ 计算得出，公式为 $\\Delta \\theta = 2 \\arccos(\\max(-1,\\min(1,r_0)))$。本问题中所有角度必须以弧度表示。\n\n任务。您必须为一个单位四元数序列 $\\{q_t\\}_{t=0}^{N-1}$ 实现三种符号包裹约定，并为每种约定计算帧间最大旋转角 $\\max_{t \\ge 1} \\Delta \\theta_t$，具体如下：\n- 约定 $\\mathcal{N}$ (“无”): 保持序列不变。对每个 $t \\ge 1$，计算相对四元数 $r_t = \\bar{q}_{t-1} \\otimes q_t$ 和步长角 $\\Delta \\theta_t = 2 \\arccos(\\max(-1,\\min(1,(r_t)_0)))$，使用 $r_t$ 的标量部分 $(r_t)_0$。\n- 约定 $\\mathcal{H}$ (“半球”): 当且仅当 $q_{t,0}  0$ 时，将每个 $q_t$ 乘以 $-1$ 映射到 $q_t'$，否则保持不变。然后使用相同的相对四元数步骤对 $\\{q_t'\\}$ 计算 $\\Delta \\theta_t$。\n- 约定 $\\mathcal{S}$ (“平滑-最小跳变”): 从 $q_0' = q_0$ 开始，对 $t \\ge 1$ 递归地从 $\\{q_t, -q_t\\}$ 中选择 $q_t'$，以使 $q_{t-1}'$ 和 $q_t'$ 之间的瞬时帧间旋转角最小化，即选择 $q_t'$ 的符号，使得从 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$ 计算出的 $\\Delta \\theta_t$ 最小。然后使用 $\\{q_t'\\}$ 计算 $\\Delta \\theta_t$。\n\n您应实现以下测试套件，其中每个轨迹由一个固定的单位轴 $\\hat{\\mathbf{u}}$、每帧的角度增量 $\\omega$、长度 $N$ 以及一个可选的索引集合 $\\mathcal{F}$ 定义，在这些索引处，记录的四元数将被乘以 $-1$ 以模拟后处理引入的符号翻转：\n- 轨迹 $\\mathsf{A}$：$\\hat{\\mathbf{u}}_{\\mathsf{A}} = (0,0,1)$，$\\omega_{\\mathsf{A}} = 0.1$，$N_{\\mathsf{A}} = 200$，$\\mathcal{F}_{\\mathsf{A}} = \\{50, 120, 121\\}$。定义 $q_t^{\\mathsf{A}} = \\left(\\cos(\\theta_t/2), \\hat{\\mathbf{u}}_{\\mathsf{A}} \\sin(\\theta_t/2)\\right)$，其中 $\\theta_t = \\omega_{\\mathsf{A}} t$。构建序列后，对所有 $t \\in \\mathcal{F}_{\\mathsf{A}}$ 应用 $q_t^{\\mathsf{A}} \\leftarrow - q_t^{\\mathsf{A}}$。\n- 轨迹 $\\mathsf{B}$：$\\hat{\\mathbf{u}}_{\\mathsf{B}} = (1,0,0)$，$\\omega_{\\mathsf{B}} = 0.2$，$N_{\\mathsf{B}} = 100$，$\\mathcal{F}_{\\mathsf{B}} = \\varnothing$。类似地，以 $\\theta_t = \\omega_{\\mathsf{B}} t$ 构建 $q_t^{\\mathsf{B}}$。\n- 轨迹 $\\mathsf{C}$：$\\hat{\\mathbf{u}}_{\\mathsf{C}} = \\frac{1}{\\sqrt{14}}(1,2,3)$，$\\omega_{\\mathsf{C}} = 1.3\\pi$，$N_{\\mathsf{C}} = 5$，$\\mathcal{F}_{\\mathsf{C}} = \\varnothing$。类似地，以 $\\theta_t = \\omega_{\\mathsf{C}} t$ 构建 $q_t^{\\mathsf{C}}$。\n\n对于每个轨迹 $\\mathsf{X} \\in \\{\\mathsf{A}, \\mathsf{B}, \\mathsf{C}\\}$ 和每种约定 $\\mathcal{C} \\in \\{\\mathcal{N}, \\mathcal{H}, \\mathcal{S}\\}$，计算最大帧间旋转角\n$$\nJ(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N_{\\mathsf{X}}-1} \\left[ 2 \\arccos\\left(\\max(-1,\\min(1, (r_t^{\\mathcal{C}})_0))\\right) \\right],\n$$\n其中 $r_t^{\\mathcal{C}}$ 是根据上述定义的约定 $\\mathcal{C}$ 从后处理序列计算出的相对四元数。所有角度必须以弧度为单位。\n\n最终输出格式。您的程序应生成单行输出，包含九个浮点数结果\n$$\n\\left[ J(\\mathsf{A},\\mathcal{N}), J(\\mathsf{A},\\mathcal{H}), J(\\mathsf{A},\\mathcal{S}), J(\\mathsf{B},\\mathcal{N}), J(\\mathsf{B},\\mathcal{H}), J(\\mathsf{B},\\mathcal{S}), J(\\mathsf{C},\\mathcal{N}), J(\\mathsf{C},\\mathcal{H}), J(\\mathsf{C},\\mathcal{S}) \\right]\n$$\n四舍五入到六位小数，以逗号分隔的列表形式打印，并用方括号括起来，例如 $[x_1,x_2,\\dots,x_9]$，其中每个 $x_i$ 是一个以弧度为单位、小数点后恰好有六位数字的十进制数。",
            "solution": "目标是通过计算三种不同符号展开约定下的最大帧间角位移，来分析表示刚体旋转的四元数轨迹。这解决了分子动力学模拟中一个常见的伪影问题，即四元数的符号模糊性（$q$ 和 $-q$ 代表相同的旋转）可能导致时间序列中出现伪跳变。该分析涉及实现这些约定，并将它们应用于三个测试轨迹 $\\mathsf{A}$、$\\mathsf{B}$ 和 $\\mathsf{C}$。\n\n基础数学框架依赖于单位四元数的代数。一个单位四元数 $q = (q_0, \\mathbf{q}_v)$，其标量部分为 $q_0 \\in \\mathbb{R}$，矢量部分为 $\\mathbf{q}_v \\in \\mathbb{R}^3$，满足条件 $\\|q\\|^2 = q_0^2 + \\|\\mathbf{q}_v\\|^2 = 1$。\n\n关键操作如下：\n1. **四元数共轭**：单位四元数 $q$ 的逆是其共轭 $\\bar{q} = (q_0, -\\mathbf{q}_v)$。\n2. **哈密顿积**：由四元数 $p$ 和 $q$ 表示的两次旋转的组合由它们的哈密顿积 $p \\otimes q$ 给出。对于 $p=(p_0, \\mathbf{p}_v)$ 和 $q=(q_0, \\mathbf{q}_v)$，其积 $r=p \\otimes q$ 定义为 $r = (p_0 q_0 - \\mathbf{p}_v \\cdot \\mathbf{q}_v, p_0 \\mathbf{q}_v + q_0 \\mathbf{p}_v + \\mathbf{p}_v \\times \\mathbf{q}_v)$。\n3. **相对朝向**：将由 $q_{t-1}$ 表示的朝向变换到由 $q_t$ 表示的朝向的旋转由相对四元数 $r_t = \\bar{q}_{t-1} \\otimes q_t$ 给出。\n4. **角度提取**：与相对四元数 $r_t$ 对应的旋转角 $\\Delta\\theta_t$ 从其标量部分 $(r_t)_0$ 中提取，使用公式 $\\Delta\\theta_t = 2 \\arccos((r_t)_0)$。为确保数值稳定性，$\\arccos$ 的参数被限制在区间 $[-1, 1]$ 内。\n\n基于这些操作，我们通过如下方式处理原始四元数序列 $\\{q_t\\}_{t=0}^{N-1}$，为每个轨迹 $\\mathsf{X}$ 和约定 $\\mathcal{C}$ 评估最大角度跳变 $J(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N-1} \\Delta\\theta_t$。\n\n**约定 $\\mathcal{N}$ (“无”)**：\n此约定不对输入轨迹进行任何修改。用于角度计算的序列就是原始序列，即 $\\{q_t'\\} = \\{q_t\\}$。最大角度直接从此序列计算。这作为一个基准，揭示了数据中存在的原始不连续性。\n\n**约定 $\\mathcal{H}$ (“半球”)**：\n此约定通过将所有四元数映射到 $S^3$ 超球体的单个半球来强制执行固定的符号选择，通常是指标量部分为非负的那个半球。新序列 $\\{q_t'\\}$ 由原始序列 $\\{q_t\\}$ 根据以下规则生成：\n$$\nq_t' = \\begin{cases}\n-q_t  \\text{if } q_{t,0}  0 \\\\\nq_t  \\text{if } q_{t,0} \\ge 0\n\\end{cases}\n$$\n此规则独立应用于序列中的每个四元数。虽然简单，但此方法不保证时间上的平滑性，并可能在轨迹穿过 $q_0=0$ 边界时引入新的不连续性。\n\n**约定 $\\mathcal{S}$ (“平滑-最小跳变”)**：\n此约定旨在通过最小化帧间旋转距离来生成时间上平滑的轨迹。这是一个递归过程。从 $q_0' = q_0$ 开始，每个后续的四元数 $q_t'$ 从配对 $\\{q_t, -q_t\\}$ 中选择，使其与前一个处理过的四元数 $q_{t-1}'$ “更近”。最小的旋转角对应于相对四元数 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$ 的最大标量部分。$\\overline{q_{t-1}'} \\otimes q_t$ 的标量部分是四维点积 $q_{t-1}' \\cdot q_t$。$\\overline{q_{t-1}'} \\otimes (-q_t)$ 的标量部分是 $-(q_{t-1}' \\cdot q_t)$。因此，为了最大化标量部分，必须确保其为非负。递归规则是：\n$q_0' = q_0$\n$$\nq_t' = \\begin{cases}\n-q_t  \\text{if } q_{t-1}' \\cdot q_t  0 \\\\\nq_t  \\text{if } q_{t-1}' \\cdot q_t \\ge 0\n\\end{cases}\n\\quad \\text{for } t \\ge 1\n$$\n这种贪心方法通过在时间上向前传播一致的符号选择，有效地展开了轨迹。\n\n总体的计算流程如下：\n1. 对于每个测试用例（$\\mathsf{A}$、$\\mathsf{B}$、$\\mathsf{C}$），使用提供的轴 $\\hat{\\mathbf{u}}$、角度增量 $\\omega$、步数 $N$ 和翻转集 $\\mathcal{F}$ 生成原始四元数轨迹 $\\{q_t\\}$。\n2. 对于每种约定（$\\mathcal{N}$、$\\mathcal{H}$、$\\mathcal{S}$），根据其特定规则创建处理后的轨迹 $\\{q_t'\\}$。\n3. 对于每个处理后的轨迹，从 $t=1$ 到 $N-1$ 迭代，计算相对四元数 $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$，提取角度 $\\Delta\\theta_t = 2 \\arccos(\\text{clip}((r_t')_0, -1, 1))$，并确定整个轨迹的最大角度。\n4. 收集九个结果值，将它们格式化为六位小数，并以指定的列表格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quaternion trajectory processing problem.\n    This function defines the quaternion operations, trajectory generation,\n    processing conventions, and then computes the required metrics for the\n    given test cases.\n    \"\"\"\n\n    # --- Quaternion Operations ---\n\n    def hamilton_product(p, q):\n        \"\"\"Computes the Hamilton product of two quaternions.\"\"\"\n        p0, pv = p[0], p[1:]\n        q0, qv = q[0], q[1:]\n        r0 = p0 * q0 - np.dot(pv, qv)\n        rv = p0 * qv + q0 * pv + np.cross(pv, qv)\n        return np.array([r0, rv[0], rv[1], rv[2]])\n\n    def conjugate(q):\n        \"\"\"Computes the conjugate of a quaternion.\"\"\"\n        return np.array([q[0], -q[1], -q[2], -q[3]])\n\n    # --- Trajectory Generation ---\n\n    def generate_trajectory(u, w, N, flips):\n        \"\"\"Generates a quaternion trajectory.\"\"\"\n        q_traj = np.zeros((N, 4))\n        for t in range(N):\n            theta = w * float(t)\n            q0 = np.cos(theta / 2.0)\n            qv = u * np.sin(theta / 2.0)\n            q = np.array([q0, qv[0], qv[1], qv[2]])\n            if t in flips:\n                q = -q\n            q_traj[t] = q\n        return q_traj\n\n    # --- Processing Conventions ---\n\n    def process_none(q_traj):\n        \"\"\"Convention N: No modification.\"\"\"\n        return q_traj\n\n    def process_hemisphere(q_traj):\n        \"\"\"Convention H: Map to q0 >= 0 hemisphere.\"\"\"\n        q_prime = q_traj.copy()\n        # Vectorized operation for efficiency\n        q_prime[q_prime[:, 0]  0] *= -1\n        return q_prime\n\n    def process_smooth(q_traj):\n        \"\"\"Convention S: Minimize frame-to-frame jump.\"\"\"\n        q_prime = np.zeros_like(q_traj)\n        if len(q_traj) == 0:\n            return q_prime\n        q_prime[0] = q_traj[0]\n        for t in range(1, len(q_traj)):\n            # The 4D dot product determines the shorter rotational path.\n            # A negative dot product implies the rotation via -q_t is shorter.\n            if np.dot(q_prime[t-1], q_traj[t])  0:\n                q_prime[t] = -q_traj[t]\n            else:\n                q_prime[t] = q_traj[t]\n        return q_prime\n\n    # --- Main Calculation ---\n\n    def compute_max_angle(q_traj):\n        \"\"\"Computes the max frame-to-frame angle for a trajectory.\"\"\"\n        max_angle = 0.0\n        if len(q_traj)  2:\n            return 0.0\n            \n        for t in range(1, len(q_traj)):\n            q_prev = q_traj[t-1]\n            q_curr = q_traj[t]\n            \n            # Relative quaternion r = q_prev^{-1} * q_curr\n            r = hamilton_product(conjugate(q_prev), q_curr)\n            \n            # Clip to handle potential floating-point inaccuracies\n            r0 = np.clip(r[0], -1.0, 1.0)\n            \n            angle = 2.0 * np.arccos(r0)\n            if angle > max_angle:\n                max_angle = angle\n                \n        return max_angle\n\n    # --- Test Case Definitions ---\n\n    uA = np.array([0.0, 0.0, 1.0])\n    wA = 0.1\n    NA = 200\n    fA = {50, 120, 121}\n\n    uB = np.array([1.0, 0.0, 0.0])\n    wB = 0.2\n    NB = 100\n    fB = set()\n\n    uC_unnormalized = np.array([1.0, 2.0, 3.0])\n    uC = uC_unnormalized / np.linalg.norm(uC_unnormalized)\n    wC = 1.3 * np.pi\n    NC = 5\n    fC = set()\n    \n    test_cases = [\n        {'u': uA, 'w': wA, 'N': NA, 'flips': fA},\n        {'u': uB, 'w': wB, 'N': NB, 'flips': fB},\n        {'u': uC, 'w': wC, 'N': NC, 'flips': fC}\n    ]\n\n    results = []\n    \n    # --- Execution Loop ---\n    \n    for case in test_cases:\n        traj = generate_trajectory(case['u'], case['w'], case['N'], case['flips'])\n        \n        # Convention N\n        traj_N = process_none(traj)\n        max_angle_N = compute_max_angle(traj_N)\n        results.append(max_angle_N)\n        \n        # Convention H\n        traj_H = process_hemisphere(traj)\n        max_angle_H = compute_max_angle(traj_H)\n        results.append(max_angle_H)\n        \n        # Convention S\n        traj_S = process_smooth(traj)\n        max_angle_S = compute_max_angle(traj_S)\n        results.append(max_angle_S)\n        \n    # --- Final Output ---\n    \n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}