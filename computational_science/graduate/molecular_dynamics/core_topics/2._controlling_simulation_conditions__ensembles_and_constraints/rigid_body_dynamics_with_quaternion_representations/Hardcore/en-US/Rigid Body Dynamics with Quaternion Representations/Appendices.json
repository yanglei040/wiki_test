{
    "hands_on_practices": [
        {
            "introduction": "A robust simulation of rigid body dynamics begins with a stable numerical integrator. This first exercise  challenges you to implement a time-stepping scheme for a torque-free rigid body, focusing on the critical task of maintaining the quaternion's unit-norm constraint, $\\mathbf{q}^T \\mathbf{q} = 1$. By comparing different strategies, including the famous SHAKE and RATTLE algorithms, you will gain first-hand experience with how constraint projection methods affect the conservation of energy and the physical realism of your simulation.",
            "id": "3442413",
            "problem": "You are tasked with designing and analyzing a numerical scheme for constrained rotational dynamics of a single rigid body in a molecular dynamics setting, using unit quaternions to represent orientation. The fundamental base must be Newton–Euler rigid body dynamics and the quaternion kinematics. The objective is to implement a time-stepping integrator that maintains the unit-quaternion constraint and respects the equivalence $\\mathbf{q} \\sim -\\mathbf{q}$, and then to quantify the effect of different constraint projection strategies on a measured rotational temperature.\n\nAssume a rigid body with diagonal principal moments of inertia $I = \\operatorname{diag}(I_1,I_2,I_3)$ expressed in the body frame. Let the body-frame angular velocity be $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$ and the orientation quaternion be $\\mathbf{q} \\in \\mathbb{R}^4$ with components $\\mathbf{q} = (q_0,q_x,q_y,q_z)$. The quaternion must satisfy the holonomic constraint $C(\\mathbf{q}) = \\mathbf{q}^\\top \\mathbf{q} - 1 = 0$, and physically identical orientations satisfy the equivalence $\\mathbf{q} \\sim -\\mathbf{q}$. The torque is zero, so the torque-free rigid body equation holds.\n\nUse these foundations:\n- The torque-free Euler equation in the body frame is $I \\dot{\\boldsymbol{\\omega}} = - \\boldsymbol{\\omega} \\times (I \\boldsymbol{\\omega})$, where $I$ is the inertia tensor and $\\times$ is the vector cross product.\n- The quaternion kinematics is $\\dot{\\mathbf{q}} = \\tfrac{1}{2} \\mathbf{q} \\otimes \\mathbf{\\Omega}$, where $\\otimes$ denotes quaternion multiplication and $\\mathbf{\\Omega} = (0,\\boldsymbol{\\omega})$ is the pure-imaginary quaternion whose vector part is $\\boldsymbol{\\omega}$.\n- The rotational kinetic energy is $K = \\tfrac{1}{2} \\boldsymbol{\\omega}^\\top I \\boldsymbol{\\omega}$.\n- The instantaneous rotational temperature (using the equipartition theorem) is $T_{\\text{rot}} = \\dfrac{2 K}{f k_B}$ for $f = 3$ rotational degrees of freedom and Boltzmann constant $k_B$. Use reduced units with $k_B = 1$.\n\nImplement a single-molecule simulation with the following structure and scientifically realistic constraints:\n1. Time integration for $\\boldsymbol{\\omega}$ using a first-order explicit update from the Euler equation: $\\boldsymbol{\\omega}_{n+1} = \\boldsymbol{\\omega}_n + \\Delta t \\, I^{-1} \\left( - \\boldsymbol{\\omega}_n \\times (I \\boldsymbol{\\omega}_n) \\right)$ with time step $\\Delta t$ stated in seconds. Angles are in radians.\n2. Time integration for $\\mathbf{q}$ using an explicit update: $\\mathbf{q}_{n+1}^{\\text{unc}} = \\mathbf{q}_n + \\Delta t \\, \\dot{\\mathbf{q}}_n$ where $\\dot{\\mathbf{q}}_n = \\tfrac{1}{2} \\mathbf{q}_n \\otimes (0,\\boldsymbol{\\omega}_{n+1})$.\n3. Position constraint projection (\"SHAKE\"): enforce $\\|\\mathbf{q}_{n+1}\\| = 1$ by normalizing $\\mathbf{q}_{n+1}^{\\text{unc}}$ to $\\mathbf{q}_{n+1} = \\dfrac{\\mathbf{q}_{n+1}^{\\text{unc}}}{\\|\\mathbf{q}_{n+1}^{\\text{unc}}\\|}$.\n4. Sign equivalence handling $\\mathbf{q} \\sim -\\mathbf{q}$: after normalization, optionally project $\\mathbf{q}_{n+1}$ to a canonical representative using one of the strategies defined below.\n5. Velocity constraint projection (\"RATTLE\"): after position projection, enforce the velocity-level constraint $\\mathbf{q}^\\top \\dot{\\mathbf{q}} = 0$. Let $G(\\mathbf{q})$ be the $4 \\times 3$ matrix such that $\\dot{\\mathbf{q}} = \\tfrac{1}{2} G(\\mathbf{q}) \\boldsymbol{\\omega}$ holds linearly in $\\boldsymbol{\\omega}$ for a given $\\mathbf{q}$. Project $\\dot{\\mathbf{q}}$ to the tangent space by $\\dot{\\mathbf{q}}^{\\text{proj}} = \\dot{\\mathbf{q}} - (\\mathbf{q}^\\top \\dot{\\mathbf{q}}) \\mathbf{q}$, then recover an adjusted angular velocity by least squares $\\boldsymbol{\\omega}' = \\arg\\min_{\\boldsymbol{\\omega}} \\| \\tfrac{1}{2} G(\\mathbf{q}) \\boldsymbol{\\omega} - \\dot{\\mathbf{q}}^{\\text{proj}} \\|_2$, i.e., solve $G(\\mathbf{q})\\boldsymbol{\\omega} = 2 \\dot{\\mathbf{q}}^{\\text{proj}}$ in the least-squares sense. Set the corrected angular velocity to $\\boldsymbol{\\omega}'$ for the next step if the chosen strategy includes RATTLE.\n\nDesign and compare the following three projection strategies:\n- Strategy P0: Normalize $\\mathbf{q}$ (SHAKE). Do not enforce any sign convention and do not apply RATTLE to $\\boldsymbol{\\omega}$.\n- Strategy P1: Normalize $\\mathbf{q}$ (SHAKE), enforce a hemisphere sign convention by flipping $\\mathbf{q}$ to ensure $q_0 \\ge 0$ (use $\\mathbf{q} \\leftarrow -\\mathbf{q}$ if $q_0 < 0$), and apply RATTLE to correct $\\boldsymbol{\\omega}$ via the least-squares procedure described above.\n- Strategy P2: Normalize $\\mathbf{q}$ (SHAKE), enforce a maximum-overlap sign convention by flipping $\\mathbf{q}$ to maximize $\\mathbf{q} \\cdot \\mathbf{q}_{\\text{prev}}$ (use $\\mathbf{q} \\leftarrow -\\mathbf{q}$ if $\\mathbf{q}^\\top \\mathbf{q}_{\\text{prev}} < 0$), and apply RATTLE to correct $\\boldsymbol{\\omega}$ via least squares.\n\nFor each strategy, simulate $N$ steps and compute the time-average of the instantaneous rotational temperature $T_{\\text{rot}}$ over the trajectory. Quantify the effect of each strategy by reporting the difference between the average measured $T_{\\text{rot}}$ and the theoretical baseline $T_0 = \\dfrac{2 K_0}{f k_B}$ computed from the initial $\\boldsymbol{\\omega}_0$ and $I$, using $f = 3$ and $k_B = 1$. Explicitly, report $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$ for each strategy.\n\nAngles must be in radians, time in seconds, inertia in kilogram-meter squared, and angular velocity in radians per second. Temperatures must be reported in energy units consistent with $k_B = 1$.\n\nImplement the program in any modern language, but the final answer must be a complete, runnable Python program. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the values of $\\Delta T$ for all strategies and all test cases in the order specified below.\n\nUse the following test suite that probes different physical and numerical regimes:\n\n- Test case 1 (happy path, spherical top): $I = \\operatorname{diag}(1,1,1)$, $\\mathbf{q}_0 = (1,0,0,0)$, $\\boldsymbol{\\omega}_0 = (0.2,0.3,0.4)$, $\\Delta t = 0.01$, $N = 1000$. Report three floats in the order P0, P1, P2.\n\n- Test case 2 (sign boundary, spherical top): $I = \\operatorname{diag}(1,1,1)$, $\\mathbf{q}_0 = (-0.001,0.70710678,0,0.70710678)$, $\\boldsymbol{\\omega}_0 = (0.8,0.0,0.0)$, $\\Delta t = 0.02$, $N = 1200$. Report three floats in the order P0, P1, P2.\n\n- Test case 3 (asymmetric top, moderate time step): $I = \\operatorname{diag}(1.0,1.5,2.0)$, $\\mathbf{q}_0 = (0.92387953,0.38268343,0,0)$, $\\boldsymbol{\\omega}_0 = (0.7,0.01,0.02)$, $\\Delta t = 0.02$, $N = 1500$. Report three floats in the order P0, P1, P2.\n\n- Test case 4 (asymmetric top, larger time step, near sign flip): $I = \\operatorname{diag}(0.8,1.2,1.6)$, $\\mathbf{q}_0 = (0.0,0.70710678,0.70710678,0.0)$, $\\boldsymbol{\\omega}_0 = (0.5,0.5,0.0)$, $\\Delta t = 0.05$, $N = 600$. Report three floats in the order P0, P1, P2.\n\nYour program must compute the $\\Delta T$ values described above for each test case and strategy and print a single line in the exact following format: a single list with twelve comma-separated floats corresponding to $[\\Delta T_{\\text{P0,TC1}},\\Delta T_{\\text{P1,TC1}},\\Delta T_{\\text{P2,TC1}},\\Delta T_{\\text{P0,TC2}},\\Delta T_{\\text{P1,TC2}},\\Delta T_{\\text{P2,TC2}},\\Delta T_{\\text{P0,TC3}},\\Delta T_{\\text{P1,TC3}},\\Delta T_{\\text{P2,TC3}},\\Delta T_{\\text{P0,TC4}},\\Delta T_{\\text{P1,TC4}},\\Delta T_{\\text{P2,TC4}}]$.",
            "solution": "The user has provided a problem that is scientifically grounded, well-posed, objective, and self-contained; it is therefore deemed **valid**. We will proceed with a full solution.\n\nThe problem requires the implementation and analysis of a numerical integrator for the rotational dynamics of a torque-free rigid body. The orientation is described by a unit quaternion $\\mathbf{q}$, and its evolution is coupled with the body-frame angular velocity $\\boldsymbol{\\omega}$. The core of the problem lies in comparing three different strategies (P0, P1, P2) for handling numerical errors that violate the quaternion's unit-norm constraint and for managing the sign ambiguity ($\\mathbf{q} \\sim -\\mathbf{q}$) inherent in quaternion representation.\n\n### 1. Theoretical Framework\n\nThe dynamics of a rigid body are governed by the Newton-Euler equations. For a torque-free system, the rotational motion in the body-fixed principal axis frame is described by Euler's equation:\n$$\nI \\dot{\\boldsymbol{\\omega}} = - \\boldsymbol{\\omega} \\times (I \\boldsymbol{\\omega})\n$$\nwhere $I = \\operatorname{diag}(I_1, I_2, I_3)$ is the diagonal tensor of principal moments of inertia and $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$ is the angular velocity vector in the body frame.\n\nThe orientation of the body is represented by a unit quaternion $\\mathbf{q} = (q_0, q_x, q_y, q_z) \\in \\mathbb{R}^4$, which must satisfy the holonomic constraint $C(\\mathbf{q}) = \\mathbf{q}^\\top \\mathbf{q} - 1 = 0$. The kinematic equation relating the time derivative of the quaternion to the angular velocity is:\n$$\n\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{q} \\otimes \\mathbf{\\Omega}\n$$\nwhere $\\mathbf{\\Omega} = (0, \\boldsymbol{\\omega})$ is a pure quaternion (scalar part is zero) and $\\otimes$ denotes quaternion multiplication.\n\nThe rotational kinetic energy is given by $K = \\frac{1}{2} \\boldsymbol{\\omega}^\\top I \\boldsymbol{\\omega}$. From the equipartition theorem, the instantaneous rotational temperature for a system with $f=3$ degrees of freedom is $T_{\\text{rot}} = \\frac{2K}{f k_B}$. Using reduced units where the Boltzmann constant $k_B=1$, this simplifies to:\n$$\nT_{\\text{rot}} = \\frac{2}{3} K = \\frac{1}{3} \\boldsymbol{\\omega}^\\top I \\boldsymbol{\\omega}\n$$\n\n### 2. Numerical Integration Scheme\n\nA discrete time-stepping algorithm is constructed to solve these coupled differential equations. The simulation proceeds from an initial state $(\\mathbf{q}_0, \\boldsymbol{\\omega}_0)$ with a time step $\\Delta t$. It is essential to start with a normalized quaternion, so the provided initial $\\mathbf{q}_0$ is first scaled to have unit length. Each step $n \\to n+1$ involves the following sequence:\n\n**Step 2.1: Angular Velocity Prediction**\nAn explicit forward Euler step is used to predict the angular velocity at the next time step:\n$$\n\\boldsymbol{\\omega}_{n+1}^{\\text{pred}} = \\boldsymbol{\\omega}_n + \\Delta t \\, I^{-1} (-\\boldsymbol{\\omega}_n \\times (I \\boldsymbol{\\omega}_n))\n$$\nThis new velocity $\\boldsymbol{\\omega}_{n+1}^{\\text{pred}}$ is an uncorrected prediction.\n\n**Step 2.2: Quaternion Update**\nThe quaternion is updated using a semi-implicit scheme, where the orientation $\\mathbf{q}_n$ is advanced using the predicted angular velocity $\\boldsymbol{\\omega}_{n+1}^{\\text{pred}}$:\n$$\n\\dot{\\mathbf{q}}_n = \\frac{1}{2} \\mathbf{q}_n \\otimes (0, \\boldsymbol{\\omega}_{n+1}^{\\text{pred}})\n$$\n$$\n\\mathbf{q}_{n+1}^{\\text{unc}} = \\mathbf{q}_n + \\Delta t \\, \\dot{\\mathbf{q}}_n\n$$\nDue to discretization error, the resulting quaternion $\\mathbf{q}_{n+1}^{\\text{unc}}$ will not have a perfect unit norm.\n\n### 3. Constraint and Equivalence Handling\n\nTo maintain physical and mathematical consistency, constraints must be enforced at each step. The problem defines three strategies for this.\n\n**Strategy P0: SHAKE only**\nThis is the simplest strategy. It only enforces the position-level constraint $\\mathbf{q}^\\top \\mathbf{q} = 1$ by normalizing the unconstrained quaternion. This procedure is commonly known as SHAKE for positions.\n$$\n\\mathbf{q}_{n+1} = \\frac{\\mathbf{q}_{n+1}^{\\text{unc}}}{\\|\\mathbf{q}_{n+1}^{\\text{unc}}\\|}\n$$\nIn this strategy, the angular velocity for the next step is simply the predicted one, $\\boldsymbol{\\omega}_{n+1} = \\boldsymbol{\\omega}_{n+1}^{\\text{pred}}$. This method does not correct the velocity to be consistent with the corrected position, which typically leads to a systematic drift in the total energy of the system.\n\n**Strategies P1 & P2: SHAKE, Sign Convention, and RATTLE**\nThese strategies are more sophisticated. They supplement SHAKE with a sign convention for the quaternion and a RATTLE correction for the angular velocity.\n\n**Step 3.1: Sign Convention (P1 and P2)**\nAfter normalization (SHAKE), the quaternion $\\mathbf{q}_{n+1}$ is projected to a canonical representation to handle the $\\mathbf{q} \\sim -\\mathbf{q}$ equivalence.\n- **P1 (Hemisphere):** Flips the quaternion if its scalar part is negative, ensuring $q_{n+1, 0} \\ge 0$. This forces the representation to one side of the $4D$ hypersphere.\n- **P2 (Maximum Overlap):** Flips the quaternion if it is anti-parallel to the quaternion from the previous step, ensuring $\\mathbf{q}_{n+1}^\\top \\mathbf{q}_n \\ge 0$. This minimizes the \"distance\" between successive quaternions in the trajectory, generally leading to a smoother and more stable simulation.\n\n**Step 3.2: Velocity Correction (RATTLE)**\nDiscretization breaks the velocity-level constraint, which dictates that $\\dot{\\mathbf{q}}$ must be tangent to the unit hypersphere at $\\mathbf{q}$ (i.e., $\\mathbf{q}^\\top\\dot{\\mathbf{q}}=0$). RATTLE corrects the angular velocity to restore this property.\nFirst, we define a matrix $G(\\mathbf{q}) \\in \\mathbb{R}^{4 \\times 3}$ that linearly relates $\\boldsymbol{\\omega}$ to $\\dot{\\mathbf{q}}$ via $\\dot{\\mathbf{q}} = \\frac{1}{2}G(\\mathbf{q})\\boldsymbol{\\omega}$:\n$$\nG(\\mathbf{q}) = \\begin{pmatrix} -q_x & -q_y & -q_z \\\\ q_0 & -q_z & q_y \\\\ q_z & q_0 & -q_x \\\\ -q_y & q_x & q_0 \\end{pmatrix}\n$$\nThe RATTLE procedure is as follows:\n1.  Define a temporary quaternion velocity using the corrected position $\\mathbf{q}_{n+1}$ and the predicted angular velocity $\\boldsymbol{\\omega}_{n+1}^{\\text{pred}}$: $\\dot{\\mathbf{q}}^{\\text{temp}} = \\frac{1}{2}G(\\mathbf{q}_{n+1})\\boldsymbol{\\omega}_{n+1}^{\\text{pred}}$.\n2.  Project this velocity onto the tangent space at $\\mathbf{q}_{n+1}$ by removing its normal component: $\\dot{\\mathbf{q}}^{\\text{proj}} = \\dot{\\mathbf{q}}^{\\text{temp}} - (\\mathbf{q}_{n+1}^\\top \\dot{\\mathbf{q}}^{\\text{temp}}) \\mathbf{q}_{n+1}$.\n3.  Find the corrected angular velocity $\\boldsymbol{\\omega}_{n+1}$ that produces this projected velocity by solving $\\frac{1}{2}G(\\mathbf{q}_{n+1})\\boldsymbol{\\omega} = \\dot{\\mathbf{q}}^{\\text{proj}}$ in a least-squares sense. The matrix $G(\\mathbf{q})$ has a useful property: for a unit quaternion $\\mathbf{q}$, $G(\\mathbf{q})^\\top G(\\mathbf{q}) = I_{3\\times3}$, where $I_{3 \\times 3}$ is the identity matrix. This means the pseudo-inverse is simply $G(\\mathbf{q})^\\top$. The solution is therefore a direct calculation:\n    $$\n    \\boldsymbol{\\omega}_{n+1} = 2 G(\\mathbf{q}_{n+1})^\\top \\dot{\\mathbf{q}}^{\\text{proj}}\n    $$\nThis $\\boldsymbol{\\omega}_{n+1}$ is the final, corrected angular velocity for the step and is used to both calculate the kinetic energy and to propagate the dynamics to the next step.\n\n### 4. Analysis\n\nFor each strategy and test case, the simulation runs for $N$ steps. The instantaneous rotational temperature $T_i$ is calculated at each step $i=1, \\dots, N$ using the final state $(\\mathbf{q}_i, \\boldsymbol{\\omega}_i)$ of that step. The time-average temperature is $\\overline{T_{\\text{rot}}} = \\frac{1}{N}\\sum_{i=1}^{N} T_i$. This is compared to the theoretical baseline temperature $T_0$ derived from the initial state $(\\mathbf{q}_0, \\boldsymbol{\\omega}_0)$. The final reported value is the deviation $\\Delta T = \\overline{T_{\\text{rot}}} - T_0$, which quantifies the energy conservation properties of each strategy.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and strategies\n    and print the results in the required format.\n    \"\"\"\n\n    def quaternion_mult(q1, q2):\n        \"\"\"\n        Performs quaternion multiplication q1 * q2.\n        q1 and q2 are 4-element NumPy arrays.\n        \"\"\"\n        q1_0, q1_v = q1[0], q1[1:]\n        q2_0, q2_v = q2[0], q2[1:]\n        \n        result_0 = q1_0 * q2_0 - np.dot(q1_v, q2_v)\n        result_v = q1_0 * q2_v + q2_0 * q1_v + np.cross(q1_v, q2_v)\n        \n        return np.array([result_0, result_v[0], result_v[1], result_v[2]])\n\n    def get_G_matrix(q):\n        \"\"\"\n        Constructs the 4x3 matrix G(q) such that q_dot = 0.5 * G(q) * omega.\n        \"\"\"\n        q0, qx, qy, qz = q\n        G = np.array([\n            [-qx, -qy, -qz],\n            [ q0, -qz,  qy],\n            [ qz,  q0, -qx],\n            [-qy,  qx,  q0]\n        ])\n        return G\n\n    def run_simulation(I_diag, q_initial, omega_initial, dt, N, strategy):\n        \"\"\"\n        Runs a single rigid body simulation for N steps.\n        \n        Args:\n            I_diag (tuple): Principal moments of inertia (I1, I2, I3).\n            q_initial (tuple): Initial orientation quaternion (q0, qx, qy, qz).\n            omega_initial (tuple): Initial angular velocity (wx, wy, wz).\n            dt (float): Time step.\n            N (int): Number of steps.\n            strategy (str): 'P0', 'P1', or 'P2'.\n            \n        Returns:\n            float: The temperature difference Delta_T = avg(T_rot) - T0.\n        \"\"\"\n        I = np.diag(I_diag).astype(np.float64)\n        I_inv = np.diag(1.0 / np.array(I_diag)).astype(np.float64)\n        \n        q = np.array(q_initial, dtype=np.float64)\n        # Normalize the initial quaternion to ensure it satisfies the constraint\n        q /= np.linalg.norm(q)\n        \n        omega = np.array(omega_initial, dtype=np.float64)\n        \n        # Calculate baseline kinetic energy and temperature from initial conditions\n        K0 = 0.5 * np.dot(omega, np.dot(I, omega))\n        T0 = (2.0 * K0) / 3.0  # Given f=3, kB=1\n        \n        total_temperature = 0.0\n        \n        q_prev_for_P2 = q.copy()\n\n        for _ in range(N):\n            # Step 1: Predict angular velocity using explicit Euler\n            torque = -np.cross(omega, np.dot(I, omega))\n            omega_pred = omega + dt * np.dot(I_inv, torque)\n            \n            # Step 2: Update quaternion with a semi-implicit step\n            omega_pred_quat = np.concatenate(([0], omega_pred))\n            q_dot = 0.5 * quaternion_mult(q, omega_pred_quat)\n            q_unc = q + dt * q_dot\n            \n            # Step 3: Enforce position constraint (SHAKE)\n            q_next = q_unc / np.linalg.norm(q_unc)\n            \n            omega_next = omega_pred\n            \n            # Step 4 & 5: Apply sign conventions and velocity constraints (RATTLE)\n            if strategy == 'P0':\n                # No sign convention, no RATTLE.\n                pass\n            \n            elif strategy == 'P1':\n                # Hemisphere sign convention\n                if q_next[0] < 0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_G_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                G_next = get_G_matrix(q_next)\n                # G(q)^T G(q) = ||q||^2 * I_3. For unit q, pseudo-inverse is G(q)^T.\n                omega_next = 2.0 * np.dot(G_next.T, q_dot_proj)\n            \n            elif strategy == 'P2':\n                # Maximum-overlap sign convention\n                if np.dot(q_next, q) < 0:\n                    q_next = -q_next\n                \n                # RATTLE correction\n                q_dot_temp = 0.5 * np.dot(get_G_matrix(q_next), omega_pred)\n                lambda_val = np.dot(q_next, q_dot_temp)\n                q_dot_proj = q_dot_temp - lambda_val * q_next\n                \n                G_next = get_G_matrix(q_next)\n                omega_next = 2.0 * np.dot(G_next.T, q_dot_proj)\n\n            # Update state for the next iteration\n            q_prev_for_P2 = q.copy()\n            q = q_next\n            omega = omega_next\n            \n            # Calculate instantaneous kinetic energy and temperature from the final state of the step\n            K_current = 0.5 * np.dot(omega, np.dot(I, omega))\n            T_current = (2.0 * K_current) / 3.0\n            total_temperature += T_current\n            \n        # Compute average temperature over the trajectory and the final difference\n        avg_T_rot = total_temperature / N\n        delta_T = avg_T_rot - T0\n        \n        return delta_T\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # TC1\n        {'I': (1.0, 1.0, 1.0), 'q0': (1.0, 0.0, 0.0, 0.0), 'omega0': (0.2, 0.3, 0.4), 'dt': 0.01, 'N': 1000},\n        # TC2\n        {'I': (1.0, 1.0, 1.0), 'q0': (-0.001, 0.70710678, 0.0, 0.70710678), 'omega0': (0.8, 0.0, 0.0), 'dt': 0.02, 'N': 1200},\n        # TC3\n        {'I': (1.0, 1.5, 2.0), 'q0': (0.92387953, 0.38268343, 0.0, 0.0), 'omega0': (0.7, 0.01, 0.02), 'dt': 0.02, 'N': 1500},\n        # TC4\n        {'I': (0.8, 1.2, 1.6), 'q0': (0.0, 0.70710678, 0.70710678, 0.0), 'omega0': (0.5, 0.5, 0.0), 'dt': 0.05, 'N': 600}\n    ]\n\n    results = []\n    strategies = ['P0', 'P1', 'P2']\n\n    for case in test_cases:\n        for strategy in strategies:\n            delta_T = run_simulation(\n                case['I'], case['q0'], case['omega0'], case['dt'], case['N'], strategy\n            )\n            results.append(delta_T)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Once a simulation generates a trajectory, the next task is to analyze it. However, the quaternion's double-covering of the rotation group, where $\\mathbf{q}$ and $-\\mathbf{q}$ represent the same orientation, can introduce artificial discontinuities in the data. This practice  guides you through implementing and comparing different \"unwrapping\" conventions to create a smooth and physically meaningful orientation trajectory, a crucial step for calculating dynamic properties and accurately visualizing motion.",
            "id": "3442442",
            "problem": "Consider a rigid body in molecular dynamics under periodic boundary conditions. The orientation of the rigid body at discrete time index $t$ is represented by a unit quaternion $\\mathbf{q}_t \\in \\mathbb{H}$ with scalar part $q_{t,0}$ and vector part $\\mathbf{q}_{t,v}$, satisfying $\\|\\mathbf{q}_t\\| = 1$. The unit quaternion representation double-covers the special orthogonal group in three dimensions $\\mathrm{SO}(3)$, meaning $\\mathbf{q}$ and $-\\mathbf{q}$ represent the same physical rotation. This sign indeterminacy can produce artificial discontinuities in recorded orientation trajectories when naïvely post-processed, especially when coordinates are remapped by periodic boundary conditions or when a fixed-hemisphere sign rule is imposed without regard to temporal continuity.\n\nStart from the following fundamental bases and definitions:\n- A unit quaternion $\\mathbf{q} = (q_0, \\mathbf{q}_v)$ represents a rotation by angle $\\theta \\in [0, 2\\pi)$ about a unit axis $\\hat{\\mathbf{u}}$ through the mapping $\\mathbf{q} = \\left(\\cos(\\theta/2), \\hat{\\mathbf{u}} \\sin(\\theta/2)\\right)$.\n- The inverse of a unit quaternion is its conjugate, $\\mathbf{q}^{-1} = \\bar{\\mathbf{q}} = (q_0, -\\mathbf{q}_v)$.\n- The Hamilton product $\\otimes$ composes rotations: if $\\mathbf{p}$ and $\\mathbf{q}$ are unit quaternions, then $\\mathbf{p} \\otimes \\mathbf{q}$ corresponds to applying rotation $\\mathbf{q}$ after rotation $\\mathbf{p}$.\n- For two orientations $\\mathbf{p}$ and $\\mathbf{q}$, the relative orientation is $\\mathbf{r} = \\mathbf{p}^{-1} \\otimes \\mathbf{q}$, which corresponds to a rotation by angle $\\Delta \\theta \\in [0, 2\\pi]$ about some axis, with $\\Delta \\theta$ obtained from the scalar part $r_0$ via $\\Delta \\theta = 2 \\arccos(\\max(-1,\\min(1,r_0)))$. All angles in this problem must be expressed in radians.\n\nTask. You must implement three sign-wrapping conventions for a sequence of unit quaternions $\\{\\mathbf{q}_t\\}_{t=0}^{N-1}$, and for each convention compute the maximum frame-to-frame rotation angle $\\max_{t \\ge 1} \\Delta \\theta_t$ as follows:\n- Convention $\\mathcal{N}$ (\"none\"): Leave the sequence unchanged. For each $t \\ge 1$, compute the relative quaternion $\\mathbf{r}_t = \\bar{\\mathbf{q}}_{t-1} \\otimes \\mathbf{q}_t$ and the step angle $\\Delta \\theta_t = 2 \\arccos(\\max(-1,\\min(1,(\\mathbf{r}_t)_0)))$ using $\\mathbf{r}_t$'s scalar part $(\\mathbf{r}_t)_0$.\n- Convention $\\mathcal{H}$ (\"hemisphere\"): Map each $\\mathbf{q}_t$ to $\\mathbf{q}_t'$ by multiplying by $-1$ if and only if $q_{t,0} < 0$, leaving it unchanged otherwise. Then compute $\\Delta \\theta_t$ using the same relative-quaternion procedure on $\\{\\mathbf{q}_t'\\}$.\n- Convention $\\mathcal{S}$ (\"smooth-min-jump\"): Starting from $\\mathbf{q}_0' = \\mathbf{q}_0$, recursively choose $\\mathbf{q}_t' \\in \\{\\mathbf{q}_t, -\\mathbf{q}_t\\}$ for $t \\ge 1$ so that the immediate frame-to-frame rotation angle between $\\mathbf{q}_{t-1}'$ and $\\mathbf{q}_t'$ is minimized, that is, choose the sign of $\\mathbf{q}_t'$ that minimizes $\\Delta \\theta_t$ computed from $\\mathbf{r}_t' = \\overline{\\mathbf{q}_{t-1}'} \\otimes \\mathbf{q}_t'$. Then compute $\\Delta \\theta_t$ using $\\{\\mathbf{q}_t'\\}$.\n\nYou should implement the following test suite, where each trajectory is defined by a fixed unit axis $\\hat{\\mathbf{u}}$, an angular increment per frame $\\omega$, a length $N$, and an optional set of indices $\\mathcal{F}$ at which the recorded quaternion is multiplied by $-1$ to simulate sign flips introduced by post-processing:\n- Trajectory $\\mathsf{A}$: $\\hat{\\mathbf{u}}_{\\mathsf{A}} = (0,0,1)$, $\\omega_{\\mathsf{A}} = 0.1$, $N_{\\mathsf{A}} = 200$, $\\mathcal{F}_{\\mathsf{A}} = \\{50, 120, 121\\}$. Define $\\mathbf{q}_t^{\\mathsf{A}} = \\left(\\cos(\\theta_t/2), \\hat{\\mathbf{u}}_{\\mathsf{A}} \\sin(\\theta_t/2)\\right)$ with $\\theta_t = \\omega_{\\mathsf{A}} t$. After constructing the sequence, apply $\\mathbf{q}_t^{\\mathsf{A}} \\leftarrow - \\mathbf{q}_t^{\\mathsf{A}}$ for all $t \\in \\mathcal{F}_{\\mathsf{A}}$.\n- Trajectory $\\mathsf{B}$: $\\hat{\\mathbf{u}}_{\\mathsf{B}} = (1,0,0)$, $\\omega_{\\mathsf{B}} = 0.2$, $N_{\\mathsf{B}} = 100$, $\\mathcal{F}_{\\mathsf{B}} = \\varnothing$. Construct $\\mathbf{q}_t^{\\mathsf{B}}$ analogously with $\\theta_t = \\omega_{\\mathsf{B}} t$.\n- Trajectory $\\mathsf{C}$: $\\hat{\\mathbf{u}}_{\\mathsf{C}} = \\frac{1}{\\sqrt{14}}(1,2,3)$, $\\omega_{\\mathsf{C}} = 1.3\\pi$, $N_{\\mathsf{C}} = 5$, $\\mathcal{F}_{\\mathsf{C}} = \\varnothing$. Construct $\\mathbf{q}_t^{\\mathsf{C}}$ analogously with $\\theta_t = \\omega_{\\mathsf{C}} t$.\n\nFor each trajectory $\\mathsf{X} \\in \\{\\mathsf{A}, \\mathsf{B}, \\mathsf{C}\\}$ and each convention $\\mathcal{C} \\in \\{\\mathcal{N}, \\mathcal{H}, \\mathcal{S}\\}$, compute the maximum frame-to-frame rotation angle\n$$\nJ(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N_{\\mathsf{X}}-1} \\left[ 2 \\arccos\\left(\\max(-1,\\min(1, (\\mathbf{r}_t^{\\mathcal{C}})_0))\\right) \\right],\n$$\nwhere $\\mathbf{r}_t^{\\mathcal{C}}$ is the relative quaternion computed from the post-processed sequence under convention $\\mathcal{C}$ as defined above. All angles must be in radians.\n\nFinal output format. Your program should produce a single line of output containing the nine floating-point results\n$$\n\\left[ J(\\mathsf{A},\\mathcal{N}), J(\\mathsf{A},\\mathcal{H}), J(\\mathsf{A},\\mathcal{S}), J(\\mathsf{B},\\mathcal{N}), J(\\mathsf{B},\\mathcal{H}), J(\\mathsf{B},\\mathcal{S}), J(\\mathsf{C},\\mathcal{N}), J(\\mathsf{C},\\mathcal{H}), J(\\mathsf{C},\\mathcal{S}) \\right]\n$$\nrounded to six decimal places, printed as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,\\dots,x_9]$ where each $x_i$ is a decimal numeral in radians with exactly six digits after the decimal point.",
            "solution": "The objective is to analyze quaternion trajectories representing rigid body rotations by computing the maximum frame-to-frame angular displacement under three different sign-unwrapping conventions. This addresses a common artifact in molecular dynamics simulations where the sign ambiguity of quaternions ($\\mathbf{q}$ and $-\\mathbf{q}$ represent the same rotation) can lead to spurious jumps in a time series. The analysis involves implementing the conventions and applying them to three test trajectories, $\\mathsf{A}$, $\\mathsf{B}$, and $\\mathsf{C}$.\n\nThe foundational mathematical framework relies on the algebra of unit quaternions. A unit quaternion $\\mathbf{q} = (q_0, \\mathbf{q}_v)$ with scalar part $q_0 \\in \\mathbb{R}$ and vector part $\\mathbf{q}_v \\in \\mathbb{R}^3$ satisfies the condition $\\|\\mathbf{q}\\|^2 = q_0^2 + \\|\\mathbf{q}_v\\|^2 = 1$.\n\nThe key operations are:\n$1$. **Quaternion Conjugate**: The inverse of a unit quaternion $\\mathbf{q}$ is its conjugate, $\\bar{\\mathbf{q}} = (q_0, -\\mathbf{q}_v)$.\n$2$. **Hamilton Product**: The composition of two rotations represented by quaternions $\\mathbf{p}$ and $\\mathbf{q}$ is given by their Hamilton product, $\\mathbf{p} \\otimes \\mathbf{q}$. For $\\mathbf{p}=(p_0, \\mathbf{p}_v)$ and $\\mathbf{q}=(q_0, \\mathbf{q}_v)$, the product $\\mathbf{r}=\\mathbf{p} \\otimes \\mathbf{q}$ is defined as $\\mathbf{r} = (p_0 q_0 - \\mathbf{p}_v \\cdot \\mathbf{q}_v, p_0 \\mathbf{q}_v + q_0 \\mathbf{p}_v + \\mathbf{p}_v \\times \\mathbf{q}_v)$.\n$3$. **Relative Orientation**: The rotation that transforms an orientation represented by $\\mathbf{q}_{t-1}$ to an orientation represented by $\\mathbf{q}_t$ is given by the relative quaternion $\\mathbf{r}_t = \\bar{\\mathbf{q}}_{t-1} \\otimes \\mathbf{q}_t$.\n$4$. **Angle Extraction**: The angle of rotation $\\Delta\\theta_t$ corresponding to the relative quaternion $\\mathbf{r}_t$ is extracted from its scalar part $(\\mathbf{r}_t)_0$ using the formula $\\Delta\\theta_t = 2 \\arccos((\\mathbf{r}_t)_0)$. To ensure numerical stability, the argument of $\\arccos$ is clamped to the interval $[-1, 1]$.\n\nBased on these operations, we evaluate the maximum angular jump $J(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N-1} \\Delta\\theta_t$ for each trajectory $\\mathsf{X}$ and convention $\\mathcal{C}$ by processing the raw quaternion sequence $\\{\\mathbf{q}_t\\}_{t=0}^{N-1}$ as follows.\n\n**Convention $\\mathcal{N}$ (\"none\")**:\nThis convention performs no modification to the input trajectory. The sequence used for angle calculation is simply the original sequence, $\\{\\mathbf{q}_t'\\} = \\{\\mathbf{q}_t\\}$. The maximum angle is computed directly from this sequence. This serves as a baseline, revealing the raw discontinuities present in the data.\n\n**Convention $\\mathcal{H}$ (\"hemisphere\")**:\nThis convention enforces a fixed sign choice by mapping all quaternions to a single hemisphere of the $S^3$ hypersphere, conventionally the one where the scalar part is non-negative. The new sequence $\\{\\mathbf{q}_t'\\}$ is generated from the original sequence $\\{\\mathbf{q}_t\\}$ by the rule:\n$$\n\\mathbf{q}_t' = \\begin{cases}\n-\\mathbf{q}_t & \\text{if } q_{t,0} < 0 \\\\\n\\mathbf{q}_t & \\text{if } q_{t,0} \\ge 0\n\\end{cases}\n$$\nThis is applied independently to each quaternion in the sequence. While simple, this method does not guarantee temporal smoothness and can introduce new discontinuities where the trajectory crosses the $q_0=0$ boundary.\n\n**Convention $\\mathcal{S}$ (\"smooth-min-jump\")**:\nThis convention aims to produce a temporally smooth trajectory by minimizing the frame-to-frame rotational distance. It is a recursive process. Starting with $\\mathbf{q}_0' = \\mathbf{q}_0$, each subsequent quaternion $\\mathbf{q}_t'$ is chosen from the pair $\\{\\mathbf{q}_t, -\\mathbf{q}_t\\}$ to be \"closer\" to the preceding processed quaternion $\\mathbf{q}_{t-1}'$. The minimal rotation angle corresponds to the maximal scalar part of the relative quaternion $\\mathbf{r}_t' = \\overline{\\mathbf{q}_{t-1}'} \\otimes \\mathbf{q}_t'$. The scalar part of $\\overline{\\mathbf{q}_{t-1}'} \\otimes \\mathbf{q}_t$ is the four-dimensional dot product $\\mathbf{q}_{t-1}' \\cdot \\mathbf{q}_t$. The scalar part of $\\overline{\\mathbf{q}_{t-1}'} \\otimes (-\\mathbf{q}_t)$ is $-(\\mathbf{q}_{t-1}' \\cdot \\mathbf{q}_t)$. Therefore, to maximize the scalar part, one must ensure it is non-negative. The recursive rule is:\n$\\mathbf{q}_0' = \\mathbf{q}_0$\n$$\n\\mathbf{q}_t' = \\begin{cases}\n-\\mathbf{q}_t & \\text{if } \\mathbf{q}_{t-1}' \\cdot \\mathbf{q}_t < 0 \\\\\n\\mathbf{q}_t & \\text{if } \\mathbf{q}_{t-1}' \\cdot \\mathbf{q}_t \\ge 0\n\\end{cases}\n\\quad \\text{for } t \\ge 1\n$$\nThis greedy approach effectively unwraps the trajectory by propagating a consistent sign choice forward in time.\n\nThe overall computational procedure is as follows:\n$1$. For each test case ($\\mathsf{A}$, $\\mathsf{B}$, $\\mathsf{C}$), generate the raw quaternion trajectory $\\{\\mathbf{q}_t\\}$ using the provided axis $\\hat{\\mathbf{u}}$, angular increment $\\omega$, number of steps $N$, and flip set $\\mathcal{F}$.\n$2$. For each convention ($\\mathcal{N}$, $\\mathcal{H}$, $\\mathcal{S}$), create a processed trajectory $\\{\\mathbf{q}_t'\\}$ according to its specific rule.\n$3$. For each processed trajectory, iterate from $t=1$ to $N-1$, calculate the relative quaternion $\\mathbf{r}_t' = \\overline{\\mathbf{q}_{t-1}'} \\otimes \\mathbf{q}_t'$, extract the angle $\\Delta\\theta_t = 2 \\arccos(\\text{clip}((\\mathbf{r}_t')_0, -1, 1))$, and determine the maximum angle over the trajectory.\n$4$. Collect the nine resulting values, format them to six decimal places, and print them in the specified list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quaternion trajectory processing problem.\n    This function defines the quaternion operations, trajectory generation,\n    processing conventions, and then computes the required metrics for the\n    given test cases.\n    \"\"\"\n\n    # --- Quaternion Operations ---\n\n    def hamilton_product(p, q):\n        \"\"\"Computes the Hamilton product of two quaternions.\"\"\"\n        p0, pv = p[0], p[1:]\n        q0, qv = q[0], q[1:]\n        r0 = p0 * q0 - np.dot(pv, qv)\n        rv = p0 * qv + q0 * pv + np.cross(pv, qv)\n        return np.array([r0, rv[0], rv[1], rv[2]])\n\n    def conjugate(q):\n        \"\"\"Computes the conjugate of a quaternion.\"\"\"\n        return np.array([q[0], -q[1], -q[2], -q[3]])\n\n    # --- Trajectory Generation ---\n\n    def generate_trajectory(u, w, N, flips):\n        \"\"\"Generates a quaternion trajectory.\"\"\"\n        q_traj = np.zeros((N, 4))\n        for t in range(N):\n            theta = w * float(t)\n            q0 = np.cos(theta / 2.0)\n            qv = u * np.sin(theta / 2.0)\n            q = np.array([q0, qv[0], qv[1], qv[2]])\n            if t in flips:\n                q = -q\n            q_traj[t] = q\n        return q_traj\n\n    # --- Processing Conventions ---\n\n    def process_none(q_traj):\n        \"\"\"Convention N: No modification.\"\"\"\n        return q_traj\n\n    def process_hemisphere(q_traj):\n        \"\"\"Convention H: Map to q0 >= 0 hemisphere.\"\"\"\n        q_prime = q_traj.copy()\n        # Vectorized operation for efficiency\n        q_prime[q_prime[:, 0] < 0] *= -1\n        return q_prime\n\n    def process_smooth(q_traj):\n        \"\"\"Convention S: Minimize frame-to-frame jump.\"\"\"\n        q_prime = np.zeros_like(q_traj)\n        q_prime[0] = q_traj[0]\n        for t in range(1, len(q_traj)):\n            # The 4D dot product determines the shorter rotational path.\n            # A negative dot product implies the rotation via -q_t is shorter.\n            if np.dot(q_prime[t-1], q_traj[t]) < 0:\n                q_prime[t] = -q_traj[t]\n            else:\n                q_prime[t] = q_traj[t]\n        return q_prime\n\n    # --- Main Calculation ---\n\n    def compute_max_angle(q_traj):\n        \"\"\"Computes the max frame-to-frame angle for a trajectory.\"\"\"\n        max_angle = 0.0\n        if len(q_traj) < 2:\n            return 0.0\n            \n        for t in range(1, len(q_traj)):\n            q_prev = q_traj[t-1]\n            q_curr = q_traj[t]\n            \n            # Relative quaternion r = q_prev^{-1} * q_curr\n            r = hamilton_product(conjugate(q_prev), q_curr)\n            \n            # Clip to handle potential floating-point inaccuracies\n            r0 = np.clip(r[0], -1.0, 1.0)\n            \n            angle = 2.0 * np.arccos(r0)\n            if angle > max_angle:\n                max_angle = angle\n                \n        return max_angle\n\n    # --- Test Case Definitions ---\n\n    uA = np.array([0.0, 0.0, 1.0])\n    wA = 0.1\n    NA = 200\n    fA = {50, 120, 121}\n\n    uB = np.array([1.0, 0.0, 0.0])\n    wB = 0.2\n    NB = 100\n    fB = set()\n\n    uC_unnormalized = np.array([1.0, 2.0, 3.0])\n    uC = uC_unnormalized / np.linalg.norm(uC_unnormalized)\n    wC = 1.3 * np.pi\n    NC = 5\n    fC = set()\n    \n    test_cases = [\n        {'u': uA, 'w': wA, 'N': NA, 'flips': fA},\n        {'u': uB, 'w': wB, 'N': NB, 'flips': fB},\n        {'u': uC, 'w': wC, 'N': NC, 'flips': fC}\n    ]\n\n    results = []\n    \n    # --- Execution Loop ---\n    \n    for case in test_cases:\n        traj = generate_trajectory(case['u'], case['w'], case['N'], case['flips'])\n        \n        # Convention N\n        traj_N = process_none(traj)\n        max_angle_N = compute_max_angle(traj_N)\n        results.append(max_angle_N)\n        \n        # Convention H\n        traj_H = process_hemisphere(traj)\n        max_angle_H = compute_max_angle(traj_H)\n        results.append(max_angle_H)\n        \n        # Convention S\n        traj_S = process_smooth(traj)\n        max_angle_S = compute_max_angle(traj_S)\n        results.append(max_angle_S)\n        \n    # --- Final Output ---\n    \n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond simulating free rotational motion, we often need to confine a body's orientation to satisfy specific geometric conditions. In this final practice , you will derive the constraint torque needed to enforce an alignment between a body-fixed vector and a direction in the laboratory frame. By applying the principle of virtual work and the method of Lagrange multipliers, you will bridge the gap between a high-level constraint definition and the low-level forces required to maintain it within a dynamics simulation.",
            "id": "3442479",
            "problem": "Consider a rigid body used in Molecular Dynamics simulations whose orientation is represented by a unit Hamilton quaternion $\\mathbf{q}=(q_0,q_1,q_2,q_3)$ with scalar-first ordering. Let $R(\\mathbf{q})\\in\\mathbb{R}^{3\\times 3}$ be the rotation matrix corresponding to $\\mathbf{q}$, mapping body-fixed vectors to the space (laboratory) frame. Define the orientation alignment constraint as the scalar function\n$$\ng(\\mathbf{q})=\\hat{\\mathbf{e}}_z\\cdot R(\\mathbf{q})\\hat{\\mathbf{n}}-c,\n$$\nwhere $\\hat{\\mathbf{e}}_z=(0,0,1)$ is the unit vector along the space-frame $z$-axis, $\\hat{\\mathbf{n}}\\in\\mathbb{R}^3$ is a unit vector fixed in the body frame, and $c\\in[-1,1]$ is a prescribed constant. Angles are to be treated in radians. All torques must be expressed in Newton-meters (N·m).\n\nStarting from first principles appropriate to rigid-body dynamics and Molecular Dynamics:\n- Use the virtual work principle for holonomic constraints and the quaternion kinematic relation for small rotations to derive an expression for the generalized constraint torque $\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)$ associated with $g(\\mathbf{q})$, where $\\lambda$ is the Lagrange multiplier with units of Newton-meters.\n- Derive the gradient $\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\in\\mathbb{R}^4$ using quaternion calculus and the mapping between infinitesimal angular variation $\\delta\\boldsymbol{\\theta}\\in\\mathbb{R}^3$ and quaternion variation $\\delta\\mathbf{q}$. Let $E(\\mathbf{q})\\in\\mathbb{R}^{4\\times 3}$ denote the matrix that satisfies $\\dot{\\mathbf{q}}=\\tfrac{1}{2}E(\\mathbf{q})\\boldsymbol{\\omega}_s$ for space-frame angular velocity $\\boldsymbol{\\omega}_s$; use this to express $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$ in a closed form.\n\nYou must implement a complete program that:\n1. Normalizes any input quaternion $\\mathbf{q}$ to unit length and any input body-fixed direction $\\hat{\\mathbf{n}}$ to unit length.\n2. Computes $R(\\mathbf{q})$ from the normalized quaternion.\n3. Computes the constraint torque $\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)$ and the quaternion gradient $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$ according to your derivation.\n4. For each test case in the test suite below, outputs the magnitude $\\|\\boldsymbol{\\tau}_c\\|$ in N·m, rounded to six decimal places.\n\nUse the following test suite of parameter values:\n- Test case 1 (general nontrivial alignment): $\\mathbf{q}=\\big(\\cos(\\pi/8),\\,0,\\,\\sin(\\pi/8),\\,0\\big),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=0.7,\\ \\lambda=1.0$.\n- Test case 2 (boundary alignment, zero torque direction): $\\mathbf{q}=(1,0,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=1.0,\\ \\lambda=5.0$.\n- Test case 3 (unnormalized quaternion, off-axis body direction): $\\mathbf{q}=(0.9,0.3,0.1,0.1),\\ \\hat{\\mathbf{n}}=(1,0,0),\\ c=0.0,\\ \\lambda=2.0$.\n- Test case 4 (antialignment, zero torque direction): $\\mathbf{q}=(0,1,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=-1.0,\\ \\lambda=3.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, output the four torque magnitudes for the test cases in the order listed above, each rounded to six decimal places, for example $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]$.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It contains a complete and consistent setup for a standard problem in constrained rigid-body dynamics.\n\nThe task is to derive expressions for the constraint torque $\\boldsymbol{\\tau}_c$ and the quaternion gradient of the constraint function $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$, and then to implement these to calculate the magnitude of the torque for several test cases. All mathematical derivations and procedures will be presented from first principles as requested.\n\n### Derivation of the Constraint Torque $\\boldsymbol{\\tau}_c$\n\nThe constraint is given by the holonomic equation $g(\\mathbf{q}) = \\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c = 0$. The generalized force (in this case, torque) associated with this constraint can be derived using the principle of virtual work. The virtual work $\\delta W_c$ done by the constraint torque $\\boldsymbol{\\tau}_c$ under an infinitesimal virtual rotation $\\delta\\boldsymbol{\\theta}_s$ (expressed in the space frame) is:\n$$\n\\delta W_c = \\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta}_s\n$$\nAccording to the method of Lagrange multipliers, this virtual work is also given by $\\delta W_c = -\\lambda \\delta g$, where $\\lambda$ is the Lagrange multiplier and $\\delta g$ is the variation of the constraint function.\nWe calculate $\\delta g$ by taking the variation of $g(\\mathbf{q})$:\n$$\n\\delta g = \\delta (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c) = \\hat{\\mathbf{e}}_z \\cdot (\\delta R(\\mathbf{q})) \\hat{\\mathbf{n}}\n$$\nas $\\hat{\\mathbf{e}}_z$, $\\hat{\\mathbf{n}}$, and $c$ are constants.\n\nAn infinitesimal rotation $\\delta\\boldsymbol{\\theta}_s$ in the space frame induces a change in the rotation matrix $R$ given by $\\delta R = [\\delta\\boldsymbol{\\theta}_s]_{\\times} R$, where $[\\mathbf{v}]_{\\times}$ is the skew-symmetric matrix corresponding to the cross product operator such that $[\\mathbf{v}]_{\\times}\\mathbf{u} = \\mathbf{v} \\times \\mathbf{u}$. Substituting this into the expression for $\\delta g$:\n$$\n\\delta g = \\hat{\\mathbf{e}}_z \\cdot ([\\delta\\boldsymbol{\\theta}_s]_{\\times} R(\\mathbf{q})\\hat{\\mathbf{n}}) = \\hat{\\mathbf{e}}_z \\cdot (\\delta\\boldsymbol{\\theta}_s \\times (R(\\mathbf{q})\\hat{\\mathbf{n}}))\n$$\nUsing the scalar triple product identity $\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b} \\cdot (\\mathbf{c} \\times \\mathbf{a})$, we get:\n$$\n\\delta g = \\delta\\boldsymbol{\\theta}_s \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nNow, we equate the two expressions for the virtual work:\n$$\n\\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta}_s = -\\lambda \\, \\delta g = -\\lambda \\, \\delta\\boldsymbol{\\theta}_s \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nThis equality must hold for any arbitrary virtual rotation $\\delta\\boldsymbol{\\theta}_s$. Therefore, we can equate the vector coefficients:\n$$\n\\boldsymbol{\\tau}_c = -\\lambda (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\lambda (\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}})\n$$\nThis is the expression for the constraint torque in the space frame. Its magnitude is $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\|\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}}\\|$. Since $\\hat{\\mathbf{e}}_z$ and $\\hat{\\mathbf{n}}$ are unit vectors and $R(\\mathbf{q})$ is a rotation, $R(\\mathbf{q})\\hat{\\mathbf{n}}$ is also a unit vector. The magnitude simplifies to $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\sqrt{1 - (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}})^2}$.\n\n### Derivation of the Quaternion Gradient $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$\n\nThe gradient of the scalar function $g(\\mathbf{q})$ with respect to the quaternion $\\mathbf{q} \\in \\mathbb{R}^4$ relates the variation $\\delta g$ to the quaternion variation $\\delta\\mathbf{q}$:\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\delta\\mathbf{q}\n$$\nThe problem defines the kinematic relation between an infinitesimal space-frame rotation $\\delta\\boldsymbol{\\theta}_s$ and the resulting quaternion variation $\\delta\\mathbf{q}$ as $\\delta\\mathbf{q} = \\frac{1}{2}E(\\mathbf{q})\\delta\\boldsymbol{\\theta}_s$. Substituting this into the gradient relation:\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\left( \\frac{1}{2} E(\\mathbf{q}) \\delta\\boldsymbol{\\theta}_s \\right) = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q}) \\delta\\boldsymbol{\\theta}_s\n$$\nWe previously found that $\\delta g = (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T \\delta\\boldsymbol{\\theta}_s$. Comparing the two expressions for $\\delta g$, we identify the coefficients of $\\delta\\boldsymbol{\\theta}_s$:\n$$\n(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q})\n$$\nTaking the transpose of both sides:\n$$\nR(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z = \\frac{1}{2} E(\\mathbf{q})^T \\nabla_{\\mathbf{q}} g\n$$\nTo solve for $\\nabla_{\\mathbf{q}} g$, we need to invert the action of $E(\\mathbf{q})^T$. Since $\\mathbf{q}$ is a unit quaternion, any valid variation $\\delta\\mathbf{q}$ must be orthogonal to $\\mathbf{q}$ ($\\mathbf{q}^T\\delta\\mathbf{q}=0$). This implies that the physically relevant part of $\\nabla_{\\mathbf{q}} g$ must also be orthogonal to $\\mathbf{q}$. The matrix $E(\\mathbf{q})$ has the property that its columns are orthogonal to $\\mathbf{q}$ ($E(\\mathbf{q})^T\\mathbf{q} = \\mathbf{0}$), so its column space is the tangent space. We can therefore assume $\\nabla_{\\mathbf{q}} g$ lies in this space, i.e., $\\nabla_{\\mathbf{q}} g = E(\\mathbf{q})\\mathbf{u}$ for some vector $\\mathbf{u} \\in \\mathbb{R}^3$.\nSubstituting this into our equation:\n$$\nR(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z = \\frac{1}{2} E(\\mathbf{q})^T (E(\\mathbf{q})\\mathbf{u}) = \\frac{1}{2} (E(\\mathbf{q})^T E(\\mathbf{q})) \\mathbf{u}\n$$\nFor a unit quaternion, $E(\\mathbf{q})^T E(\\mathbf{q}) = \\|\\mathbf{q}\\|^2 I_{3\\times3} = I_{3\\times3}$. Thus, we can solve for $\\mathbf{u}$:\n$$\n\\mathbf{u} = 2 (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nFinally, substituting $\\mathbf{u}$ back into the expression for $\\nabla_{\\mathbf{q}} g$:\n$$\n\\nabla_{\\mathbf{q}} g(\\mathbf{q}) = 2 E(\\mathbf{q}) (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nThis is the closed-form expression for the quaternion gradient.\n\n### Computational Procedure\nFor each test case, the following steps are performed:\n1.  The input quaternion $\\mathbf{q}_{in}$ and body-fixed vector $\\hat{\\mathbf{n}}_{in}$ are normalized to unit length to get $\\mathbf{q}$ and $\\hat{\\mathbf{n}}$.\n2.  The rotation matrix $R(\\mathbf{q})$ is constructed from the components of the normalized quaternion $\\mathbf{q} = (q_0, q_1, q_2, q_3)^T$:\n    $$\n    R(\\mathbf{q}) = \\begin{pmatrix}\n    q_0^2 + q_1^2 - q_2^2 - q_3^2 & 2(q_1q_2 - q_0q_3) & 2(q_1q_3 + q_0q_2) \\\\\n    2(q_1q_2 + q_0q_3) & q_0^2 - q_1^2 + q_2^2 - q_3^2 & 2(q_2q_3 - q_0q_1) \\\\\n    2(q_1q_3 - q_0q_2) & 2(q_2q_3 + q_0q_1) & q_0^2 - q_1^2 - q_2^2 + q_3^2\n    \\end{pmatrix}\n    $$\n3.  The rotated body vector $\\mathbf{v}_s = R(\\mathbf{q})\\hat{\\mathbf{n}}$ is computed.\n4.  The space-frame constraint torque is calculated using the derived formula: $\\boldsymbol{\\tau}_c = \\lambda (\\hat{\\mathbf{e}}_z \\times \\mathbf{v}_s)$, where $\\hat{\\mathbf{e}}_z=(0,0,1)^T$.\n5.  The Euclidean norm (magnitude) $\\|\\boldsymbol{\\tau}_c\\|$ is computed and stored.\n6.  The program outputs the list of torque magnitudes, each rounded to six decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the constraint torque magnitude for each test case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (quaternion, body_vector_n, constant_c, lambda)\n    test_cases = [\n        ((np.cos(np.pi/8), 0, np.sin(np.pi/8), 0), (0, 0, 1), 0.7, 1.0),\n        ((1, 0, 0, 0), (0, 0, 1), 1.0, 5.0),\n        ((0.9, 0.3, 0.1, 0.1), (1, 0, 0), 0.0, 2.0),\n        ((0, 1, 0, 0), (0, 0, 1), -1.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        q_in, n_in, c, lambda_val = case\n        \n        # The constant c is part of the constraint g(q)=0 definition but does not\n        # enter the expression for the torque, which depends on the gradient of g.\n        \n        # 1. Normalize quaternion and body-fixed vector\n        q_in = np.array(q_in, dtype=float)\n        q = q_in / np.linalg.norm(q_in)\n\n        n_in = np.array(n_in, dtype=float)\n        norm_n = np.linalg.norm(n_in)\n        # Avoid division by zero if n_in is a zero vector, though not in test cases.\n        n = n_in / norm_n if norm_n > 0 else n_in\n\n        # 2. Compute rotation matrix R(q) from the normalized quaternion\n        q0, q1, q2, q3 = q[0], q[1], q[2], q[3]\n\n        R = np.array([\n            [q0**2 + q1**2 - q2**2 - q3**2, 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), q0**2 - q1**2 + q2**2 - q3**2, 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), q0**2 - q1**2 - q2**2 + q3**2]\n        ])\n        \n        # 3. Compute rotated vector and constraint torque\n        e_z = np.array([0.0, 0.0, 1.0])\n        v_s = R @ n\n        \n        # From derivation: tau_c = lambda * (e_z x R*n)\n        tau_c = lambda_val * np.cross(e_z, v_s)\n        \n        # 4. Compute the magnitude of the torque\n        tau_c_magnitude = np.linalg.norm(tau_c)\n        results.append(f\"{tau_c_magnitude:.6f}\")\n\n        # The problem also asks for the derivation of the quaternion gradient,\n        # but not for its computation in the output. The derived formula is:\n        # grad_g = 2 * E(q) * (R(q)n x e_z)\n        # The following lines could be uncommented to compute it.\n        # E = np.array([\n        #     [-q1, -q2, -q3],\n        #     [ q0, -q3,  q2],\n        #     [ q3,  q0, -q1],\n        #     [-q2,  q1,  q0]\n        # ])\n        # grad_g = 2 * E @ np.cross(v_s, e_z)\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}