{
    "hands_on_practices": [
        {
            "introduction": "理论的掌握最终需要通过实践来巩固。本节的第一个练习将指导你从零开始实现Ewald求和方法的核心部分——实空间和倒易空间力的计算。通过这个练习，你将验证你的实现是否满足周期性系统的基本对称性要求，例如平移不变性，并确保在模拟盒子边界附近不会出现人为的计算误差。这是构建任何可靠的周期性系统模拟代码的基石。",
            "id": "2390997",
            "problem": "您将使用Ewald求和法实现一个三维周期性静电计算，以评估位于立方模拟盒子边缘附近点电荷所受的力，并验证结果没有边界赝象。您必须从第一性原理出发，以库仑定律和周期性边界条件的定义为基础，推导出一个计算算法。该算法通过一个平滑的屏蔽过程，将相互作用分解为一个短程的实空间贡献和一个长程的倒易空间贡献。您必须假设采用导体（锡箔）边界条件。所有计算将使用约化无量纲单位，其中库仑前置因子为1，即 $1/(4\\pi\\epsilon_0) = 1$，并且不需要进行物理单位转换。没有需要报告的角度。所有数值答案必须以不带任何单位的原始十进制数形式打印。\n\n起始原理和定义：\n- 该系统是一个边长为 $L$ 的立方盒子，具有三维周期性边界条件（PBC）。对于位于位置 $\\mathbf{r}_i \\in [0,L)^3$ 的任何粒子和位于位置 $\\mathbf{r}_j \\in [0,L)^3$ 的任何不同粒子，其相互作用包括所有由 $\\mathbf{n}L$（其中 $\\mathbf{n} \\in \\mathbb{Z}^3$）位移的晶格镜像。\n- 点电荷的静电势由库仑定律决定，周期性系统中的总能量是条件收敛的，除非总电荷为零。您必须将计算限制在净电荷为零的构型上，即 $\\sum_i q_i = 0$。\n- Ewald方法引入了一个由参数 $\\alpha  0$ 控制宽度的平滑高斯屏蔽，将相互作用分解为一个对近邻镜像的快速衰减的实空间求和，以及一个对波矢 $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{m}$（其中 $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$，不包括 $\\mathbf{k} = \\mathbf{0}$）的互补的倒易空间求和。实空间求和在半径 $r_\\mathrm{cut}  0$ 处截断，倒易空间求和通过将整数矢量分量限制在 $|m_x|,|m_y|,|m_z| \\le k_\\mathrm{max}$ 内来截断。\n\n您的任务：\n- 根据上述原理，推导一个显式且数值稳定的算法，以使用Ewald求和计算每个粒子 $i$ 上的静电力 $\\mathbf{F}_i$，包括实空间和倒易空间的贡献以及自相互作用校正。使用导体边界条件，以便不包含额外的表面项。该算法必须严格遵守周期性边界条件。\n- 在一个程序中实现该算法，以评估以下测试套件。所有位置都在区间 $[0,L)$ 内给出，所有量均为无量纲。所有测试均使用相同的立方盒子边长 $L = 10.0$。在需要时使用互补误差函数。设 $\\pi$ 为通常的数学常数。\n\n基线评估的全局Ewald参数：\n- 对于基线计算，使用 $\\alpha = 0.35$，$r_\\mathrm{cut} = 4.5$ 和 $k_\\mathrm{max} = 6$。\n- 对于备选参数测试，使用 $\\alpha' = 0.28$，$r_\\mathrm{cut}' = 4.5$ 和 $k_\\mathrm{max}' = 8$。\n\n测试系统：\n1. 系统 $\\mathcal{S}_\\mathrm{edge}$（跨边界且靠近边缘的两个相反电荷）：\n   - 电荷：$q_1 = +1.0$, $q_2 = -1.0$。\n   - 位置：$\\mathbf{r}_1 = (9.8, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.2, 5.0, 5.0)$。\n2. 系统 $\\mathcal{S}_\\mathrm{center}$（相同电荷，相同最小镜像间距，居中且远离边缘）：\n   - 电荷：$q_1 = +1.0$, $q_2 = -1.0$。\n   - 位置：$\\mathbf{r}_1 = (0.2, 5.0, 5.0)$, $\\mathbf{r}_2 = (0.6, 5.0, 5.0)$。\n3. 用于不变性测试的平移矢量：$\\mathbf{t} = (3.7, 0.0, -1.1)$，通过 $\\mathbf{r}_i \\mapsto (\\mathbf{r}_i + \\mathbf{t}) \\bmod L$ 按分量应用。\n\n待计算的量：\n- 设 $\\mathbf{F}^{(\\mathrm{edge})}$ 为使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的系统 $\\mathcal{S}_\\mathrm{edge}$ 的力。\n- 设 $\\mathbf{F}^{(\\mathrm{center})}$ 为使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的系统 $\\mathcal{S}_\\mathrm{center}$ 的力。\n- 设 $\\mathbf{F}^{(\\mathrm{trans})}$ 为对系统 $\\mathcal{S}_\\mathrm{edge}$ 应用平移 $\\mathbf{t}$ 并将位置包裹回盒子后，使用 $(\\alpha, r_\\mathrm{cut}, k_\\mathrm{max})$ 计算的力。\n- 设 $\\mathbf{F}^{(\\mathrm{alt})}$ 为使用备选参数 $(\\alpha', r_\\mathrm{cut}', k_\\mathrm{max}')$ 计算的系统 $\\mathcal{S}_\\mathrm{edge}$ 的力。\n\n根据这些量，计算以下四个标量诊断值：\n- $D_1$：$\\mathbf{F}^{(\\mathrm{edge})}$ 和 $\\mathbf{F}^{(\\mathrm{center})}$ 之间分量上的最大绝对差值，即 $D_1 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{center})}_{i,a}\\right|$。\n- $D_2$：系统 $\\mathcal{S}_\\mathrm{edge}$ 中净力矢量的欧几里得范数，对两个粒子求和，$D_2 = \\left\\|\\sum_{i=1}^2 \\mathbf{F}^{(\\mathrm{edge})}_i \\right\\|_2$。\n- $D_3$：$\\mathbf{F}^{(\\mathrm{edge})}$ 和 $\\mathbf{F}^{(\\mathrm{trans})}$ 之间分量上的最大绝对差值，$D_3 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{trans})}_{i,a}\\right|$。\n- $D_4$：使用基线参数和备选参数计算的 $\\mathbf{F}^{(\\mathrm{edge})}$ 之间的分量上最大绝对差值，$D_4 = \\max_{i\\in\\{1,2\\}, a\\in\\{x,y,z\\}} \\left|F^{(\\mathrm{edge})}_{i,a} - F^{(\\mathrm{alt})}_{i,a}\\right|$。\n\n解释指南：\n- $D_1$ 的小值证实了将电荷放置在边界附近与等效的中心构型产生相同的力，表明没有边界赝象。\n- $D_2$ 的小值证实了根据平移不变性的要求，在导体边界条件下，电中性系统的总力为零。\n- $D_3$ 的小值证实了在全局平移和周期性包裹下力的不变性。\n- $D_4$ 的小值证实了在数值截断误差范围内，物理结果与任意选择的分解参数无关。\n\n最终输出格式：\n- 您的程序必须打印一行，其中包含四个结果，格式为方括号内以逗号分隔的列表，顺序为 $[D_1, D_2, D_3, D_4]$。例如，一个有效的输出格式是 $[0.0001,2.3e-06,0.0,1.2e-05]$。\n\n约束和说明：\n- 您必须直接实现Ewald力计算。不要调用任何黑盒静电学求解器。您可以使用标准数值库来计算指数和互补误差函数等基本函数。\n- 仅使用电中性系统；所有提供的测试都满足 $\\sum_i q_i = 0$。\n- 确保使用指定的截断 $(r_\\mathrm{cut}, k_\\mathrm{max})$ 时，算法具有数值稳定性和合理的收敛性。",
            "solution": "我们以库仑定律和周期性边界条件的定义为基础进行计算，然后推导Ewald分解，以获得一个用于计算力的数值收敛算法。推导中的所有符号均指代约化无量纲量，其中 $1/(4\\pi\\epsilon_0) = 1$。\n\n基本原理：\n- 库仑定律给出了电荷 $q_i$ 和 $q_j$ 之间的对势为 $\\phi(\\mathbf{r}) = q_j / \\|\\mathbf{r}\\|$，其中 $\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$。\n- 在边长为 $L$ 的周期性立方盒子中，相互作用是对所有晶格镜像的求和，这个求和只是条件收敛的。Ewald方法通过引入一个高斯屏蔽密度来对其进行正则化，将相互作用分解为快速收敛的实空间和倒易空间级数。\n\nEwald分解：\n我们加上并减去一个由 $\\alpha  0$ 控制宽度的中和高斯函数。来自一个被屏蔽点电荷的势可以分解为一个像互补误差函数一样衰减的短程贡献，和一个可通过傅里叶分量表示的长程贡献。对于电中性系统，在导体边界条件下，省略 $\\mathbf{k} = \\mathbf{0}$ 分量。\n\n力的表达式概念推导：\n- 实空间。定义 $\\mathbf{R} = \\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$，且 $R = \\|\\mathbf{R}\\|$。在屏蔽表示中，对势为 $q_j \\operatorname{erfc}(\\alpha R)/R$。粒子 $i$ 上受到的力为 $\\mathbf{F}_{ij}^{(\\mathrm{real})} = -q_i \\nabla_i \\left[q_j \\operatorname{erfc}(\\alpha R)/R\\right]$。使用乘积法则和 $\\frac{d}{dR}\\operatorname{erfc}(\\alpha R) = -\\frac{2\\alpha}{\\sqrt{\\pi}} e^{-\\alpha^2 R^2}$，以及恒等式 $\\nabla_i R = \\mathbf{R}/R$，我们得到\n$$\n\\mathbf{F}_{ij}^{(\\mathrm{real})} = q_i q_j \\left( \\frac{\\operatorname{erfc}(\\alpha R)}{R^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 R^2}}{R^2} \\right) \\mathbf{R}.\n$$\n为了提高数值效率，这个求和被截断到 $R \\le r_\\mathrm{cut}$，因为被忽略的尾部衰减得非常快。\n\n- 倒易空间。设 $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{m}$，其中整数三元组 $\\mathbf{m} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$。在 $\\mathbf{r}_i$ 处的倒易空间势为\n$$\n\\phi^{(\\mathrm{rec})}(\\mathbf{r}_i) = \\frac{1}{V}\\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{4\\pi}{k^2} e^{-k^2/(4\\alpha^2)} \\sum_j q_j e^{i \\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)},\n$$\n其中 $V = L^3$ 且 $k = \\|\\mathbf{k}\\|$。力为 $\\mathbf{F}_i^{(\\mathrm{rec})} = -q_i \\nabla_i \\phi^{(\\mathrm{rec})}(\\mathbf{r}_i)$。求导从 $e^{i \\mathbf{k}\\cdot \\mathbf{r}_i}$ 中得到一个因子 $i\\mathbf{k}$，并使用正弦函数得到一个显式的实数形式：\n$$\n\\mathbf{F}_i^{(\\mathrm{rec})} = \\frac{4\\pi}{V}\\, q_i \\sum_{\\mathbf{k}\\ne\\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\left[\\sum_j q_j \\sin\\left(\\mathbf{k}\\cdot (\\mathbf{r}_i - \\mathbf{r}_j)\\right)\\right] \\mathbf{k}.\n$$\n为了高效计算，我们使用恒等式 $\\sum_j q_j \\sin(\\mathbf{k}\\cdot(\\mathbf{r}_i - \\mathbf{r}_j)) = \\sin(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\cos(\\mathbf{k}\\cdot \\mathbf{r}_j) - \\cos(\\mathbf{k}\\cdot \\mathbf{r}_i)\\sum_j q_j \\sin(\\mathbf{k}\\cdot \\mathbf{r}_j)$，因此我们每个 $\\mathbf{k}$ 只需要全局结构因子。\n\n- 自作用项。Ewald能量中的自相互作用校正为 $- \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_i q_i^2$，其相对于粒子位置的梯度为零。因此，自作用项对力没有贡献，在计算力时可以忽略。\n\n导体边界条件：\n- 对于导体（锡箔）边界，$\\mathbf{k} = \\mathbf{0}$ 项被舍去，并且没有表面（偶极）校正。为避免发散，系统必须是电中性的，即 $\\sum_i q_i = 0$。\n\n算法设计：\n1. 输入粒子位置 $\\{\\mathbf{r}_i\\}$、电荷 $\\{q_i\\}$、盒子边长 $L$ 以及Ewald参数 $\\alpha$、$r_\\mathrm{cut}$、$k_\\mathrm{max}$。\n2. 实空间力：\n   - 确定整数边界 $n_\\mathrm{max} = \\lceil r_\\mathrm{cut}/L \\rceil$；遍历 $\\mathbf{n} \\in \\{-n_\\mathrm{max},\\ldots,n_\\mathrm{max}\\}^3$。\n   - 对于每个 $i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef ewald_forces(positions, charges, L, alpha, rcut, kmax):\n    \"\"\"\n    Compute Ewald forces for a 3D periodic cubic box with conducting boundary conditions.\n    positions: (N,3) array in [0,L)\n    charges: (N,) array, must sum to zero\n    L: box length\n    alpha: Ewald splitting parameter\n    rcut: real-space cutoff\n    kmax: maximum integer index for reciprocal vectors\n    Returns: (N,3) array of forces\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    charges = np.asarray(charges, dtype=float)\n    N = positions.shape[0]\n    assert positions.shape == (N, 3)\n    assert charges.shape == (N,)\n    # Neutrality check\n    if abs(np.sum(charges)) > 1e-12:\n        raise ValueError(\"System is not neutral; Ewald summation diverges.\")\n    forces = np.zeros_like(positions)\n    V = L**3\n    pi = np.pi\n    sqrt_pi = np.sqrt(pi)\n\n    # Real-space sum\n    nmax = int(np.ceil(rcut / L))\n    # Precompute image shifts\n    shifts = []\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                shifts.append(np.array([nx, ny, nz], dtype=int))\n    shifts = np.array(shifts, dtype=int)\n\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            qiqj = qi * qj\n            # Loop over lattice vectors within cutoff\n            for nvec in shifts:\n                # Displacement including image\n                Rvec = ri - rj + L * nvec\n                R2 = np.dot(Rvec, Rvec)\n                if R2 == 0.0:\n                    continue\n                R = np.sqrt(R2)\n                if R = rcut:\n                    aR = alpha * R\n                    erfc_term = erfc(aR)\n                    exp_term = np.exp(-(aR * aR))\n                    # Force scalar factor\n                    f = erfc_term / (R2 * R) + (2.0 * alpha / sqrt_pi) * exp_term / R2\n                    fij = qiqj * f * Rvec\n                    forces[i] += fij\n                    forces[j] -= fij\n\n    # Reciprocal-space sum\n    # Generate k-vectors\n    ms = np.arange(-kmax, kmax + 1, dtype=int)\n    k_list = []\n    for mx in ms:\n        for my in ms:\n            for mz in ms:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m = np.array([mx, my, mz], dtype=float)\n                kvec = (2.0 * np.pi / L) * m\n                ksq = np.dot(kvec, kvec)\n                if ksq == 0.0:\n                    continue\n                k_list.append((kvec, ksq))\n    # Structure factors and force accumulation\n    # Precompute dot products k·r for all k and all particles can be memory heavy; loop over k\n    for kvec, ksq in k_list:\n        # Coefficient c(k)\n        ck = (4.0 * np.pi / V) * np.exp(-ksq / (4.0 * alpha * alpha)) / ksq\n        # Structure factors\n        kr = positions @ kvec  # shape (N,)\n        cos_kr = np.cos(kr)\n        sin_kr = np.sin(kr)\n        Ck = np.sum(charges * cos_kr)\n        Sk = np.sum(charges * sin_kr)\n        # Per-particle contributions\n        s_i = sin_kr\n        c_i = cos_kr\n        # term = (s_i * Ck - c_i * Sk)\n        term = (s_i * Ck - c_i * Sk) * charges * ck  # shape (N,)\n        # Add to forces: term[:, None] * kvec\n        forces += term[:, None] * kvec\n\n    return forces\n\ndef translate_and_wrap(positions, tvec, L):\n    \"\"\"Translate positions by tvec and wrap back into [0,L).\"\"\"\n    pos_new = positions + np.asarray(tvec, dtype=float)\n    pos_new = pos_new % L\n    return pos_new\n\ndef max_abs_componentwise_diff(A, B):\n    \"\"\"Max absolute component-wise difference between two (N,3) arrays.\"\"\"\n    return float(np.max(np.abs(A - B)))\n\ndef solve():\n    # Define global parameters\n    L = 10.0\n    alpha = 0.35\n    rcut = 4.5\n    kmax = 6\n\n    alpha_alt = 0.28\n    rcut_alt = 4.5\n    kmax_alt = 8\n\n    # Define systems\n    charges = np.array([+1.0, -1.0], dtype=float)\n\n    # Edge configuration (across boundary)\n    r_edge = np.array([\n        [9.8, 5.0, 5.0],\n        [0.2, 5.0, 5.0],\n    ], dtype=float)\n\n    # Centered configuration with same minimum-image separation (0.4 along +x)\n    r_center = np.array([\n        [0.2, 5.0, 5.0],\n        [0.6, 5.0, 5.0],\n    ], dtype=float)\n\n    # Translation vector\n    tvec = np.array([3.7, 0.0, -1.1], dtype=float)\n\n    # Compute forces with baseline parameters\n    F_edge = ewald_forces(r_edge, charges, L, alpha, rcut, kmax)\n    F_center = ewald_forces(r_center, charges, L, alpha, rcut, kmax)\n\n    # D1: max componentwise difference between edge and center\n    D1 = max_abs_componentwise_diff(F_edge, F_center)\n\n    # D2: norm of total force for edge system\n    total_force_edge = np.sum(F_edge, axis=0)\n    D2 = float(np.linalg.norm(total_force_edge))\n\n    # D3: translation invariance\n    r_edge_trans = translate_and_wrap(r_edge, tvec, L)\n    F_trans = ewald_forces(r_edge_trans, charges, L, alpha, rcut, kmax)\n    D3 = max_abs_componentwise_diff(F_edge, F_trans)\n\n    # D4: parameter invariance (alternate parameters)\n    F_alt = ewald_forces(r_edge, charges, L, alpha_alt, rcut_alt, kmax_alt)\n    D4 = max_abs_componentwise_diff(F_edge, F_alt)\n\n    results = [D1, D2, D3, D4]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在验证了代码的基本物理对称性后，下一步是确保其内部的数学一致性以及在动力学模拟中的适用性。这个练习要求你检验两个关键特性：力是否精确地等于势能的负梯度（$\\\\mathbf{F} = -\\\\nabla U$），以及在一个简单的动力学积分步中总能量是否守恒。完成此练习将增强你对Ewald方法在保守力场模拟中扮演角色的理解，并确保你的实现能够可靠地用于产生物理轨迹。",
            "id": "3441713",
            "problem": "考虑一个分子动力学中具有长程静电相互作用的立方、周期性点电荷系统。目标是验证Ewald分解中实空间和倒易空间分量的实现一致性，并检查单步分子动力学积分器下的能量守恒。在无量纲的约化单位制下进行计算，其中库仑常数为1，长度单位为立方盒子的边长，所有质量为1。所有报告的量都必须是无量纲的。\n\n从基本定律和定义出发，包括周期性边界条件下的库仑定律和泊松方程，推导出一个数学上合理的Ewald分裂方法。该方法将总静电能分解为一个短程的实空间求和、一个长程的倒易空间求和，以及导电（锡箔）边界条件所需的任何自相互作用和边界条件校正项。通过对能量取负梯度来推导相应的力。推导必须从第一性原理开始，例如格林函数的屏蔽分解和泊松求和定理，而不能依赖于问题陈述中直接给出的简化公式。\n\n算法要求：\n- 对实空间分量实现最小镜像约定，实空间截断半径 $r_{\\mathrm{c}}$ 不超过 $L/2$，其中 $L$ 是立方盒子的边长。\n- 通过对非零波矢 $\\mathbf{k}$ 求和来实现倒易空间分量。这些波矢由整数三元组 $(n_x,n_y,n_z)$ 构成，其大小受整数截断值 $k_{\\max}$ 的限制，使用 $\\mathbf{k} = 2\\pi \\mathbf{n}/L$ 并排除 $\\mathbf{k}=\\mathbf{0}$。\n- 包括与所选分裂方法相适应的自相互作用项，并采用导电边界条件以使表面项消失。\n- 通过将实空间和倒易空间的贡献以及自能相加来计算总能量和总力。\n- 通过将解析计算的力与通过位置中心有限差分获得的能量负梯度的数值估计进行比较，来验证实现的一致性。\n- 当实空间和倒易空间分量都包含在内且具有一致的截断值时，验证总能量对于分裂参数的选择近似不变。\n- 在使用周期性边界条件和源自Ewald分解的力的情况下，验证在单步速度Verlet时间步长下能量近似守恒。\n\n测试套件：\n使用以下三个测试用例，它们共同探测了一般行为、对分裂参数的敏感性以及动力学守恒性。所有输入和输出均为无量纲。\n\n1. 实现一致性（最大力-梯度不匹配）：\n   - 粒子数 $N=4$。\n   - 电荷 $\\{q_i\\} = [1,-1,1,-1]$。\n   - 主晶胞内的位置 $\\{\\mathbf{r}_i\\}$: $[ [0.7,1.3,2.1], [2.9,3.5,1.8], [4.2,0.4,3.7], [1.1,4.6,0.9] ]$。\n   - 盒子边长 $L=6.0$。\n   - 实空间截断半径 $r_{\\mathrm{c}}=3.0$。\n   - 分裂参数 $\\alpha=0.35$。\n   - 倒易空间截断值 $k_{\\max}=6$。\n   使用Ewald求和计算解析力，并使用中心有限差分法计算能量的数值负梯度。对每个粒子在每个笛卡尔方向上使用 $10^{-6}$ 的小位移步长，并保持位置被包裹在主晶胞内。报告所有粒子上解析力与数值负梯度之差的最大范数，结果为一个浮点数。\n\n2. 分裂参数不变性（两个 $\\alpha$ 值下的能量差）：\n   - 粒子数 $N=2$。\n   - 电荷 $\\{q_i\\} = [1,-1]$。\n   - 位置 $\\{\\mathbf{r}_i\\} = [ [0.5,0.5,0.5], [1.5,1.0,3.0] ]$。\n   - 盒子边长 $L=4.0$。\n   - 实空间截断半径 $r_{\\mathrm{c}}=2.0$。\n   - 倒易空间截断值 $k_{\\max}=7$。\n   - 分裂参数 $\\alpha_1=0.25$ 和 $\\alpha_2=0.45$。\n   使用相同的截断值计算 $\\alpha_1$ 和 $\\alpha_2$ 时的总能量。报告这两个总能量之差的绝对值，结果为一个浮点数。\n\n3. 单步能量守恒（总能量绝对变化）：\n   - 粒子数 $N=3$。\n   - 电荷 $\\{q_i\\} = [-1,-1,2]$。\n   - 位置 $\\{\\mathbf{r}_i\\} = [ [0.3,1.1,2.2], [2.7,3.3,4.1], [1.4,2.0,0.9] ]$。\n   - 初始速度 $\\{\\mathbf{v}_i\\} = [ [0.02,-0.01,0.015], [ -0.03,0.025,-0.02 ], [ 0.01, -0.015, 0.005 ] ]$。\n   - 盒子边长 $L=5.0$。\n   - 实空间截断半径 $r_{\\mathrm{c}}=2.5$。\n   - 倒易空间截断值 $k_{\\max}=6$。\n   - 分裂参数 $\\alpha=0.40$。\n   - 时间步长 $\\Delta t=10^{-3}$。\n   执行一个速度Verlet积分步，位置更新后将其包裹回主晶胞内。计算初始和最终状态之间势能和动能之和的绝对变化，并将其报告为一个浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含三个结果，格式为方括号内以逗号分隔的列表（例如，“[result1,result2,result3]”）。每个结果必须是无量纲的浮点数。不得打印任何额外文本。",
            "solution": "用户提供了一个明确的计算物理问题，要求推导和实现用于计算周期性系统中静电相互作用的Ewald求和方法。该问题在科学上是合理的，内部是一致的，并且所有测试用例的参数都已指定。因此，我将提供一个完整的解决方案。\n\n### 1. Ewald求和的理论推导\n\n在一个边长为 $L$ 的立方模拟盒子中，一个由 $N$ 个位于位置 $\\mathbf{r}_i$ 的点电荷 $q_i$ 组成的系统，在周期性晶格上复制，其静电势能 $U$ 由以下条件收敛的和给出：\n$$\nU = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sideset{}{'}\\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\frac{q_i q_j}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$，晶格矢量 $\\mathbf{n}$ 上的求和符号的撇号表示当 $\\mathbf{n}=\\mathbf{0}$ 时，排除 $i=j$ 的项。库仑常数 $k_e$ 设为1。\n\nEwald方法使用恒等式 $1 = \\text{erf}(\\alpha r) + \\text{erfc}(\\alpha r)$ 将长程的 $1/r$ 相互作用分为两部分，其中 $\\alpha$ 是一个控制分离范围的参数：\n$$\n\\frac{1}{r} = \\frac{\\text{erfc}(\\alpha r)}{r} + \\frac{\\text{erf}(\\alpha r)}{r}\n$$\n第一项包含互补误差函数 $\\text{erfc}$，是短程的，可以在实空间中高效求和。第二项包含误差函数 $\\text{erf}$，是平滑且长程的，使其适合在倒易（傅里叶）空间中求和。\n\n这种分裂可以通过将每个点电荷 $q_i$ 视为其自身加上一个符号相反的中和高斯电荷分布 $-q_i$，并同时加回一个符号相同的屏蔽高斯电荷分布 $+q_i$ 的总和来形象化。总势能则是以下几部分势能之和：\n1.  点电荷通过短程屏蔽势（点电荷与中和高斯电荷之和）相互作用。\n2.  平滑的屏蔽高斯电荷分布彼此相互作用。\n\n#### 1.1. 实空间分量\n实空间能量 $U_{\\text{real}}$ 源于通过短程势 $\\text{erfc}(\\alpha r)/r$ 的相互作用：\n$$\nU_{\\text{real}} = \\frac{1}{2} \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\frac{q_i q_j \\text{erfc}(\\alpha|\\mathbf{r}_{ij} + \\mathbf{n}L|)}{|\\mathbf{r}_{ij} + \\mathbf{n}L|}\n$$\n由于 $\\text{erfc}(x)$ 的快速衰减，这个和可以在一个截断距离 $r_c$ 处被截断。应用最小镜像约定（MIC），我们只考虑每个粒子的最近周期性镜像，从而简化对粒子对的求和：\n$$\nU_{\\text{real}} = \\sum_{i",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the Ewald summation problem for the three specified test cases.\n    The implementation is self-contained within this function.\n    \"\"\"\n\n    # ------------------ Core Ewald Implementation ------------------\n    \n    def _get_k_vectors(k_max, L):\n        \"\"\"Generates reciprocal space vectors up to a spherical cutoff.\"\"\"\n        k_vectors_list = []\n        k_sq_magnitudes_list = []\n        if k_max == 0:\n            return np.array([]), np.array([])\n        \n        k_max_sq = k_max**2\n        n_range = range(-k_max, k_max + 1)\n        \n        for nx in n_range:\n            for ny in n_range:\n                for nz in n_range:\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n                    n_sq = nx**2 + ny**2 + nz**2\n                    if n_sq = k_max_sq:\n                        k_vec = (2 * np.pi / L) * np.array([nx, ny, nz])\n                        k_vectors_list.append(k_vec)\n                        k_sq_magnitudes_list.append(np.dot(k_vec, k_vec))\n        \n        return np.array(k_vectors_list), np.array(k_sq_magnitudes_list)\n\n    def _apply_mic(diff_vec, L):\n        \"\"\"Applies minimum image convention to a vector.\"\"\"\n        return diff_vec - L * np.round(diff_vec / L)\n\n    def ewald_energy(charges, positions, L, alpha, r_c, k_max):\n        \"\"\"Computes the total Ewald potential energy.\"\"\"\n        N = len(charges)\n        \n        # Real-space component\n        U_real = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                r_ij_vec = _apply_mic(positions[i] - positions[j], L)\n                r_ij = np.linalg.norm(r_ij_vec)\n                if r_ij > 0 and r_ij = r_c:\n                    U_real += charges[i] * charges[j] * erfc(alpha * r_ij) / r_ij\n        \n        # Reciprocal-space component\n        U_recip = 0.0\n        k_vectors, k_sq_mags = _get_k_vectors(k_max, L)\n        if k_vectors.size > 0:\n            k_dot_r = np.dot(positions, k_vectors.T)\n            exp_ikr = np.exp(-1j * k_dot_r)\n            S_k = np.dot(charges, exp_ikr)\n            \n            U_recip_sum = np.sum(np.exp(-k_sq_mags / (4 * alpha**2)) / k_sq_mags * np.abs(S_k)**2)\n            U_recip = (2 * np.pi / L**3) * U_recip_sum\n\n        # Self-interaction correction\n        U_self = -(alpha / np.sqrt(np.pi)) * np.sum(charges**2)\n\n        return U_real + U_recip + U_self\n\n    def ewald_forces(charges, positions, L, alpha, r_c, k_max):\n        \"\"\"Computes the Ewald forces on all particles.\"\"\"\n        N = len(charges)\n        forces = np.zeros((N, 3))\n        \n        # Real-space forces\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                r_ij_vec = _apply_mic(positions[i] - positions[j], L)\n                r_ij = np.linalg.norm(r_ij_vec)\n                if r_ij > 0 and r_ij = r_c:\n                    term_in_brackets = (erfc(alpha * r_ij) / r_ij**2 + \n                                       (2 * alpha / np.sqrt(np.pi)) * np.exp(-alpha**2 * r_ij**2) / r_ij)\n                    forces[i] += charges[i] * charges[j] * term_in_brackets * r_ij_vec / r_ij\n\n        # Reciprocal-space forces\n        k_vectors, k_sq_mags = _get_k_vectors(k_max, L)\n        if k_vectors.size > 0:\n            prefactors_base = (4 * np.pi / L**3) * np.exp(-k_sq_mags / (4 * alpha**2)) / k_sq_mags\n            \n            # S(k) = sum_j q_j exp(-i*k.r_j)\n            exp_minus_ikr = np.exp(-1j * np.dot(positions, k_vectors.T))\n            S_k = np.dot(charges, exp_minus_ikr)\n            \n            # Term to sum is Im[S(k) * exp(i*k.r_i)] for each particle i\n            sin_term_matrix = np.imag(S_k[np.newaxis, :] * np.conj(exp_minus_ikr))\n            \n            force_contrib_per_k = prefactors_base[np.newaxis, :] * sin_term_matrix\n            \n            recip_forces = -charges[:, np.newaxis] * np.dot(force_contrib_per_k, k_vectors)\n            forces += recip_forces\n            \n        return forces\n\n    # ------------------ Test Case Functions ------------------\n\n    def run_case_1():\n        N = 4\n        charges = np.array([1.0, -1.0, 1.0, -1.0])\n        positions = np.array([\n            [0.7, 1.3, 2.1], [2.9, 3.5, 1.8], [4.2, 0.4, 3.7], [1.1, 4.6, 0.9]\n        ])\n        L = 6.0\n        r_c = 3.0\n        alpha = 0.35\n        k_max = 6\n        \n        F_analytic = ewald_forces(charges, positions, L, alpha, r_c, k_max)\n        \n        F_numeric = np.zeros_like(positions)\n        h = 1e-6\n        for i in range(N):\n            for j in range(3):\n                pos_plus = positions.copy()\n                pos_plus[i, j] += h\n                pos_plus %= L\n                U_plus = ewald_energy(charges, pos_plus, L, alpha, r_c, k_max)\n                \n                pos_minus = positions.copy()\n                pos_minus[i, j] -= h\n                pos_minus %= L\n                U_minus = ewald_energy(charges, pos_minus, L, alpha, r_c, k_max)\n                \n                F_numeric[i, j] = -(U_plus - U_minus) / (2 * h)\n                \n        diff_norms = np.linalg.norm(F_analytic - F_numeric, axis=1)\n        return np.max(diff_norms)\n\n    def run_case_2():\n        charges = np.array([1.0, -1.0])\n        positions = np.array([[0.5, 0.5, 0.5], [1.5, 1.0, 3.0]])\n        L = 4.0\n        r_c = 2.0\n        k_max = 7\n        alpha1, alpha2 = 0.25, 0.45\n        \n        U1 = ewald_energy(charges, positions, L, alpha1, r_c, k_max)\n        U2 = ewald_energy(charges, positions, L, alpha2, r_c, k_max)\n        \n        return np.abs(U1 - U2)\n\n    def run_case_3():\n        charges = np.array([-1.0, -1.0, 2.0])\n        positions = np.array([[0.3, 1.1, 2.2], [2.7, 3.3, 4.1], [1.4, 2.0, 0.9]])\n        velocities = np.array([\n            [0.02, -0.01, 0.015], [-0.03, 0.025, -0.02], [0.01, -0.015, 0.005]\n        ])\n        L = 5.0\n        r_c = 2.5\n        k_max = 6\n        alpha = 0.40\n        dt = 1e-3\n        masses = np.ones(len(charges))\n        \n        pos0, vel0 = positions, velocities\n        forces0 = ewald_forces(charges, pos0, L, alpha, r_c, k_max)\n        accel0 = forces0 / masses[:, np.newaxis]\n        \n        U0 = ewald_energy(charges, pos0, L, alpha, r_c, k_max)\n        K0 = 0.5 * np.sum(masses * np.sum(vel0**2, axis=1))\n        E0 = U0 + K0\n        \n        pos1 = pos0 + vel0 * dt + 0.5 * accel0 * dt**2\n        pos1 %= L\n        \n        forces1 = ewald_forces(charges, pos1, L, alpha, r_c, k_max)\n        accel1 = forces1 / masses[:, np.newaxis]\n        \n        vel1 = vel0 + 0.5 * (accel0 + accel1) * dt\n        \n        U1 = ewald_energy(charges, pos1, L, alpha, r_c, k_max)\n        K1 = 0.5 * np.sum(masses * np.sum(vel1**2, axis=1))\n        E1 = U1 + K1\n        \n        return np.abs(E1 - E0)\n\n    # ------------------ Main Execution ------------------\n    \n    results = [\n        run_case_1(),\n        run_case_2(),\n        run_case_3()\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个动手实践旨在将你的Ewald求和实现从一个“正确”的算法工具，转变为一个用于科学研究的“实用”工具。你将探索Ewald分裂参数 $\\\\alpha$ 的选择如何影响计算结果，并通过控制截断误差来保持计算的鲁棒性。具体来说，你将使用实现的力来弛豫一个离子系统，并计算其电荷-电荷径向分布函数 $g_{qq}(r)$，从而直接观察算法参数对物理可观测量影响的细微之处。",
            "id": "3441666",
            "problem": "考虑一个在三维周期性边界条件下的中性、强关联离子体系，其中包含等量电荷为 $+1$ 和 $-1$ 的点离子。周期性体系中离子间的静电相互作用使用埃瓦尔德求和方法（Ewald）进行计算，该方法将相互作用分解为一个短程的实空间部分和一个长程的倒易空间部分，二者由一个正分裂参数 $\\alpha$ 控制。在无限求和、零截断的极限情况下，埃瓦尔德求和结果与 $\\alpha$ 无关。但在使用有限截断的实际计算中，实空间和倒易空间的贡献都被截断，从而产生与 $\\alpha$ 相关的误差。本问题要求您实现一个有原则的计算，以测试在规定的误差约束内改变 $\\alpha$ 是否会扰动一个可测量的结构相关性。\n\n您需要从库仑定律和埃瓦尔德分解的定义出发，并使用以下经过科学检验的事实和定义作为基础出发点：\n- 在真空中，电荷 $q_i$ 和 $q_j$ 之间的对势为 $V(r) = q_i q_j / r$，其中 $r$ 为它们之间的距离。\n- 埃瓦尔德方法将 $V(r)$ 分解为一个随互补误差函数衰减的实空间贡献和一个随波矢大小呈高斯函数衰减的倒易空间贡献。自能项和锡箔（导电）边界面项可以被包含进来以稳定能量，但它们不影响不同粒子之间的力。\n- 在周期性边界条件下，波矢为 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$，其中 $n_x, n_y, n_z \\in \\mathbb{Z}$，立方盒子边长为 $L$。系统体积为 $V = L^3$。\n- 实空间截断误差受截断处的互补误差函数限制，倒易空间截断误差受截断壳层处的高斯因子限制：\n  - 要求 $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ 来选择实空间截断半径 $r_{\\mathrm{cut}}$。\n  - 要求 $\\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4\\alpha^2}\\right) \\le \\varepsilon_{\\mathrm{rec}}$ 来选择倒易空间截断波矢大小。\n- 对实空间中的对间距应用最小镜像约定。\n\n定义电荷-电荷径向分布函数（Radial Distribution Function (RDF)）$g_{qq}(r)$ 为在距离 $r$ 处电荷密度的球面平均、无量纲相关性，并通过在均匀参考系中的期望对密度进行归一化：\n$$\ng_{qq}(r) = \\frac{1}{N \\rho \\, 4\\pi r^2 \\Delta r} \\sum_{i \\ne j} q_i q_j \\, \\chi\\!\\left(r \\le r_{ij}  r + \\Delta r\\right),\n$$\n其中 $N$ 是离子总数，$\\rho = N/V$ 是数密度，$q_i \\in \\{+1,-1\\}$，$r_{ij}$ 是最小镜像距离，$\\Delta r$ 是径向箱宽，$\\chi(\\cdot)$ 是指示函数。函数 $g_{qq}(r)$ 是无量纲的。\n\n您的任务是实现一个完整的程序，该程序：\n1. 在边长为 $L$ 的立方盒子中，使用两个在各方向上偏移 $L/4$ 的互穿简单立方子晶格，构建一个中性的、强关联的离子构型，并为每个粒子添加小的随机位移以打破完美对称性。使用 $N=16$ 个离子，$V=L^3$，以及无量纲约化单位（即将库仑常数设为1；程序中不使用任何物理单位）。\n2. 对于给定的 $\\alpha$ 选择，使用边界条件\n   $$\n   \\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}, \\quad \\exp\\!\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4\\alpha^2}\\right) \\le \\varepsilon_{\\mathrm{rec}} \\text{ at } \\lVert \\mathbf{k} \\rVert = K,\n   $$\n   来选择实空间截断半径 $r_{\\mathrm{cut}}$ 和倒易空间整数截断值 $n_{\\max}$，其中 $K = \\frac{2\\pi}{L} n_{\\max}$。强制 $r_{\\mathrm{cut}} \\le L/2$ 且 $n_{\\max} \\ge 1$。倒易空间求和应包括所有分量在 $\\{-n_{\\max}, \\ldots, n_{\\max}\\}$ 范围内的整数波矢，零矢量除外。\n3. 使用与上述截断和锡箔（导电）边界条件一致的埃瓦尔德实空间和倒易空间分量，计算每个离子上的总静电力。对于距离为 $r$、分离矢量为 $\\mathbf{r}$ 的一对粒子，其实空间力通过对实空间势 $q_i q_j \\, \\mathrm{erfc}(\\alpha r)/r$ 对 $\\mathbf{r}$ 求导得到。倒易空间力使用结构因子 $S(\\mathbf{k}) = \\sum_j q_j e^{i \\mathbf{k}\\cdot \\mathbf{r}_j}$ 和高斯衰减因子。在实空间中应用最小镜像约定。\n4. 执行固定次数的梯度下降弛豫步骤，使用小步长 $\\gamma$ 将位置更新为 $\\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\gamma \\mathbf{F}_i$，并在每一步后将位置包裹回盒子中。\n5. 使用宽度为 $\\Delta r = (L/2)/M$ 的 $M$ 个箱子，在 $[0,L/2)$ 区间上计算 $g_{qq}(r)$。\n6. 对三个不同的 $\\alpha$ 值重复步骤 2-5，同时保持误差界限 $\\varepsilon_{\\mathrm{real}}$ 和 $\\varepsilon_{\\mathrm{rec}}$ 不变，并且每次弛豫都从相同的初始构型开始。将第一个 $\\alpha$ 作为基准。对于每个 $\\alpha$（包括基准），计算 $g_{qq}(r)$ 相对于基准曲线的最大绝对箱间差异，并测试此最大差异是否小于或等于规定的容差 $\\tau$。\n\n为确保科学真实性的设计选择：\n- 对倒易空间项使用锡箔边界条件（导电边界），以使宏观表面项力消失。\n- 在实空间中使用最小镜像约定，并强制 $r_{\\mathrm{cut}} \\le L/2$。\n- 从所述边界中选择 $r_{\\mathrm{cut}}$ 和 $n_{\\max}$，以便对所有测试的 $\\alpha$ 保持一致的截断误差约束。\n\n测试套件和参数：\n- 盒子边长 $L = 1$（无量纲）。\n- 离子数 $N = 16$，电荷 $q_i \\in \\{+1,-1\\}$，排列在两个互穿的简单立方子晶格上，各方向偏移量为 $L/4$，并附加大小小于 $0.02 L$ 的小随机位移。\n- 埃瓦尔德参数和误差界限：\n  - 情况 A (基准): $\\alpha = 2$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}$, $\\varepsilon_{\\mathrm{rec}} = 10^{-2}$。\n  - 情况 B: $\\alpha = 4$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}, \\varepsilon_{\\mathrm{rec}} = 10^{-2}$。\n  - 情况 C: $\\alpha = 6$, $\\varepsilon_{\\mathrm{real}} = 10^{-3}, \\varepsilon_{\\mathrm{rec}} = 10^{-2}$。\n- 梯度下降弛豫：步数 $S = 15$，步长 $\\gamma = 0.002$。\n- 径向分布函数参数：在 $[0,L/2)$ 区间内，箱数 $M = 20$。\n- 容差：$\\tau = 0.1$（无量纲）。\n\n您的程序应评估三种情况下 $g_{qq}(r)$ 相对于基准的最大绝对偏差，并与 $\\tau$ 进行比较，为每种情况生成一个布尔值，以指示偏差条件是否成立。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[True,False,True]”）。\n\n最终输出严格为这一行，按顺序包含情况 A、情况 B 和情况 C 的布尔值。不使用任何物理单位；所有量都采用与所述设置一致的约化无量纲形式。",
            "solution": "周期性离子体系中的静电相互作用可以使用埃瓦尔德求和方法（Ewald）计算，该方法将库仑势分解为一个快速衰减的实空间分量和一个平滑变化的倒易空间分量。该分解由一个正参数 $\\alpha$ 控制，对于完整的无限求和，总能量和力与 $\\alpha$ 无关。在实践中，截断这两个求和会引入依赖于 $\\alpha$ 的误差，因为实空间截断误差的衰减方式类似于 $\\mathrm{erfc}(\\alpha r)$，而倒易空间截断误差的衰减方式类似于 $\\exp(-\\lVert \\mathbf{k} \\rVert^2/(4 \\alpha^2))$。因此，在固定的计算成本下，不同的 $\\alpha$ 值可以将误差预算在两个域之间转移，这促使我们去测试当截断误差有界时，结构可观测量是否对 $\\alpha$ 敏感。\n\n我们从真空中点电荷的库仑定律出发：对于位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$、电荷为 $q_i$ 和 $q_j$ 的两个离子，其分离矢量为 $\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$，对势为 $V(r) = q_i q_j / r$，其中 $r = \\lVert \\mathbf{r} \\rVert$。在边长为 $L$、体积为 $V = L^3$ 的立方盒子中的周期性边界条件下，埃瓦尔德方法将能量表示为实空间贡献、倒易空间贡献以及一个自能项和一个表面项的总和。对于不同粒子之间的力，只有实空间和倒易空间分量有贡献。\n\n实空间分量：实空间对势为 $q_i q_j \\, \\mathrm{erfc}(\\alpha r)/r$，其中 $\\mathrm{erfc}(\\cdot)$ 是互补误差函数，相应的力矢量通过对 $\\mathbf{r}$ 求导得到：\n$$\n\\mathbf{F}_{ij}^{\\mathrm{real}}(\\mathbf{r}) = q_i q_j \\left[ \\frac{\\mathrm{erfc}(\\alpha r)}{r^3} + \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-(\\alpha r)^2}}{r^2} \\right] \\mathbf{r}.\n$$\n该表达式由 $-\\nabla \\left( \\mathrm{erfc}(\\alpha r)/r \\right)$ 推导得出。计算 $\\mathbf{r}$ 时强制使用最小镜像约定，使其分量位于 $(-L/2, L/2]$ 区间内，并在 $r_{\\mathrm{cut}} \\le L/2$ 处截断对。\n\n倒易空间分量：倒易空间贡献使用结构因子 $S(\\mathbf{k}) = \\sum_j q_j e^{i \\mathbf{k} \\cdot \\mathbf{r}_j}$，并通过一个高斯因子衰减较高波矢。对于锡箔（导电）边界条件，由于在最大波矢大小 $K$ 处截断的倒易空间模式，作用在离子 $i$ 上的力为\n$$\n\\mathbf{F}_i^{\\mathrm{rec}} = \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\left( \\frac{4\\pi}{V} \\frac{e^{-\\lVert \\mathbf{k} \\rVert^2/(4\\alpha^2)}}{\\lVert \\mathbf{k} \\rVert^2} \\right) q_i \\, \\mathrm{Im}\\!\\left[ S(\\mathbf{k}) e^{-i \\mathbf{k}\\cdot \\mathbf{r}_i} \\right] \\, \\mathbf{k},\n$$\n其中，求和遍及所有分量在 $\\{-n_{\\max}, \\ldots, n_{\\max}\\}$ 范围内的整数三元组 $(n_x, n_y, n_z)$，零矢量除外，且 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$。前置因子 $4\\pi/V$ 适用于锡箔边界条件下的库仑相互作用，且库仑常数设为1（无量纲约化单位）。虚部来自于能量表达式中的余弦项对 $\\mathbf{r}_i$ 的微分。\n\n误差约束与截断：为了在不同的 $\\alpha$ 值之间保持一致的截断误差，我们从以下边界中选择截断值：\n- 实空间截断半径 $r_{\\mathrm{cut}}$，满足 $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ 且 $r_{\\mathrm{cut}} \\le L/2$。\n- 倒易空间大小截断值 $K$，满足 $\\exp(-K^2/(4\\alpha^2)) \\le \\varepsilon_{\\mathrm{rec}}$，从而得出 $K \\ge 2\\alpha \\sqrt{\\ln(1/\\varepsilon_{\\mathrm{rec}})}$。这转化为一个整数截断值 $n_{\\max} = \\left\\lfloor \\frac{K L}{2\\pi} \\right\\rfloor$，且 $n_{\\max} \\ge 1$。\n\n结构相关性：电荷-电荷径向分布函数定义为\n$$\ng_{qq}(r) = \\frac{1}{N \\rho \\, 4\\pi r^2 \\Delta r} \\sum_{i \\ne j} q_i q_j \\, \\chi\\!\\left(r \\le r_{ij}  r + \\Delta r\\right),\n$$\n其中 $r_{ij}$ 使用最小镜像约定计算。归一化因子 $N \\rho \\, 4\\pi r^2 \\Delta r$ 等于在每个离子单位电荷平方密度的均匀参考系中，一个壳层内期望的对数，这使得 $g_{qq}(r)$ 无量纲。\n\n算法设计：\n1. 将一个强关联构型初始化为两个互穿的简单立方子晶格，第二个子晶格偏移 $(L/4, L/4, L/4)$，使得最近邻居在小于 $L/2$ 的距离上带相反电荷。为每个粒子添加小的随机位移以打破完美对称性。\n2. 对于每个测试用例 $(\\alpha, \\varepsilon_{\\mathrm{real}}, \\varepsilon_{\\mathrm{rec}})$，从 $\\mathrm{erfc}(\\alpha r_{\\mathrm{cut}}) \\le \\varepsilon_{\\mathrm{real}}$ 计算 $r_{\\mathrm{cut}}$ 并将其限制在 $L/2$ 以内，并从 $\\exp(-K^2/(4\\alpha^2)) \\le \\varepsilon_{\\mathrm{rec}}$ 计算 $K$ 以获得 $n_{\\max} = \\lfloor K L/(2\\pi) \\rfloor$，且 $n_{\\max} \\ge 1$。相应地构建倒易波矢列表。\n3. 将总力计算为 $\\mathbf{F}_i = \\mathbf{F}_i^{\\mathrm{real}} + \\mathbf{F}_i^{\\mathrm{rec}}$。实空间求和遍及所有满足 $r_{ij} \\le r_{\\mathrm{cut}}$ 的不同对 $i",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc, erfcinv\n\ndef build_initial_configuration(L: float, jitter_amp: float = 0.02):\n    \"\"\"\n    Build two interpenetrating simple-cubic sublattices in a cubic box of edge L.\n    Sublattice B is offset by (L/4, L/4, L/4) relative to sublattice A.\n    Charges: +1 on A, -1 on B. Add small random jitter to each particle.\n    Returns positions (N,3) and charges (N,).\n    \"\"\"\n    # Simple-cubic grid with spacing L/2: points at {0, L/2} in each dimension.\n    base_coords = []\n    for ix in [0.0, 0.5 * L]:\n        for iy in [0.0, 0.5 * L]:\n            for iz in [0.0, 0.5 * L]:\n                base_coords.append([ix, iy, iz])\n    base_coords = np.array(base_coords, dtype=float)  # shape (8,3)\n\n    # Sublattice A: base coords (8 points), charge +1\n    A_positions = base_coords.copy()\n    A_charges = np.ones(len(A_positions), dtype=float)\n\n    # Sublattice B: base coords offset by L/4 in each direction, modulo L, charge -1\n    offset = np.array([0.25 * L, 0.25 * L, 0.25 * L], dtype=float)\n    B_positions = (base_coords + offset) % L\n    B_charges = -np.ones(len(B_positions), dtype=float)\n\n    positions = np.vstack([A_positions, B_positions])  # (16,3)\n    charges = np.concatenate([A_charges, B_charges])   # (16,)\n\n    # Add small random jitter to break perfect symmetry\n    rng = np.random.default_rng(seed=42)\n    jitter = (rng.random(positions.shape) - 0.5) * 2.0 * jitter_amp * L\n    positions = (positions + jitter) % L\n\n    return positions, charges\n\ndef minimum_image(dr, L):\n    \"\"\"\n    Apply minimum-image convention to displacement vectors dr with box length L.\n    \"\"\"\n    return dr - L * np.round(dr / L)\n\ndef select_cutoffs(alpha: float, L: float, eps_real: float, eps_rec: float):\n    \"\"\"\n    Select real-space cutoff rcut and reciprocal-space integer cutoff nmax\n    based on the error bounds:\n        erfc(alpha * rcut) = eps_real\n        exp(-K^2 / (4 alpha^2)) = eps_rec, where K = 2*pi*nmax / L\n    Enforce rcut = L/2 and nmax >= 1.\n    \"\"\"\n    # Real-space cutoff from erfc(alpha rcut) = eps_real\n    # erfcinv returns x such that erfc(x) = y, so rcut >= erfcinv(eps_real)/alpha\n    rcut_min = float(erfcinv(eps_real) / alpha)\n    # Clamp to [0, L/2]\n    rcut = min(L / 2.0, rcut_min)\n\n    # Reciprocal cutoff magnitude K >= 2*alpha*sqrt(log(1/eps_rec))\n    K_min = 2.0 * alpha * np.sqrt(np.log(1.0 / eps_rec))\n    # Integer cutoff nmax such that (2*pi/L) * nmax >= K_min\n    nmax = int(np.ceil((K_min * L) / (2.0 * np.pi)))\n    nmax = max(1, nmax)\n\n    return rcut, nmax\n\ndef build_k_vectors(L: float, nmax: int):\n    \"\"\"\n    Build list of reciprocal-space k-vectors up to integer cutoff nmax,\n    excluding the zero vector. Returns array of shape (M,3).\n    \"\"\"\n    ks = []\n    two_pi_over_L = 2.0 * np.pi / L\n    for nx in range(-nmax, nmax + 1):\n        for ny in range(-nmax, nmax + 1):\n            for nz in range(-nmax, nmax + 1):\n                if nx == 0 and ny == 0 and nz == 0:\n                    continue\n                k = np.array([nx, ny, nz], dtype=float) * two_pi_over_L\n                ks.append(k)\n    return np.array(ks, dtype=float)\n\ndef ewald_forces(positions: np.ndarray, charges: np.ndarray, L: float,\n                 alpha: float, rcut: float, k_vectors: np.ndarray):\n    \"\"\"\n    Compute Ewald forces under tin-foil boundary conditions with given alpha,\n    real-space cutoff rcut, and a set of reciprocal-space k-vectors.\n    Returns forces array of shape (N,3).\n    \"\"\"\n    N = positions.shape[0]\n    V = L ** 3\n    forces = np.zeros_like(positions)\n\n    # Real-space sum: pairwise forces for r = rcut under minimum image\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            dr = rj - ri\n            dr = minimum_image(dr, L)\n            r = np.linalg.norm(dr)\n            if r  1e-12:\n                continue\n            if r = rcut:\n                # Real-space force vector\n                # F_i = -q_i q_j [ erfc(alpha r)/r^3 + 2 alpha / sqrt(pi) * exp(-(alpha r)^2)/r^2 ] * dr_ji\n                # F_i += fij, where fij is force on i from j. dr_ji = r_i - r_j\n                term = erfc(alpha * r) / (r ** 3)\n                term += (2.0 * alpha / np.sqrt(np.pi)) * np.exp(-(alpha * r) ** 2) / (r ** 2)\n                fij = -qi * qj * term * dr\n                forces[i] += fij\n                forces[j] -= fij\n\n    # Reciprocal-space sum: structure factor and forces\n    if k_vectors.size > 0:\n        # Compute structure factor S(k) = sum_j q_j exp(i k·r_j)\n        # Precompute phases\n        phases = positions @ k_vectors.T  # shape (N, M)\n        Sk = (charges[:, None] * np.exp(1j * phases)).sum(axis=0)  # shape (M,)\n        # Accumulate forces\n        for m in range(k_vectors.shape[0]):\n            k = k_vectors[m]\n            k2 = float(np.dot(k, k))\n            if k2  1e-20:\n                continue\n            # Prefactor for Coulomb under tin-foil boundary\n            pref = (4.0 * np.pi / V) * np.exp(-k2 / (4.0 * alpha ** 2)) / k2\n            # For each ion i: F_i += q_i * Im[ S(k) * exp(-i k·r_i) ] * pref * k\n            # Compute exp(-i k·r_i) = conj(exp(i k·r_i)) = np.exp(-1j * phases[:, m])\n            e_terms = np.exp(-1j * phases[:, m])\n            im_vals = np.imag(Sk[m] * e_terms)  # shape (N,)\n            forces += (charges * im_vals * pref)[:, None] * k\n\n    return forces\n\ndef relax_positions(positions: np.ndarray, charges: np.ndarray, L: float,\n                    alpha: float, eps_real: float, eps_rec: float,\n                    steps: int, step_size: float):\n    \"\"\"\n    Perform gradient-descent relaxation under Ewald forces with cutoffs selected\n    from error bounds. Returns relaxed positions and the cutoffs used.\n    \"\"\"\n    rcut, nmax = select_cutoffs(alpha, L, eps_real, eps_rec)\n    k_vectors = build_k_vectors(L, nmax)\n    pos = positions.copy()\n    for _ in range(steps):\n        F = ewald_forces(pos, charges, L, alpha, rcut, k_vectors)\n        pos = (pos + step_size * F) % L\n    return pos, rcut, nmax\n\ndef g_qq(positions: np.ndarray, charges: np.ndarray, L: float, M: int):\n    \"\"\"\n    Compute charge–charge radial distribution function g_qq(r) using M bins over [0, L/2).\n    Returns bin centers and g_qq values.\n    \"\"\"\n    N = positions.shape[0]\n    V = L ** 3\n    rho = N / V\n    r_max = L / 2.0\n    dr = r_max / M\n    r_centers = (np.arange(M) + 0.5) * dr\n    accum = np.zeros(M, dtype=float)\n\n    # Accumulate pair contributions\n    for i in range(N - 1):\n        ri = positions[i]\n        qi = charges[i]\n        for j in range(i + 1, N):\n            rj = positions[j]\n            qj = charges[j]\n            dr_vec = minimum_image(rj - ri, L)\n            r = np.linalg.norm(dr_vec)\n            if r >= r_max or r = 1e-12:\n                continue\n            b = int(r / dr)\n            if 0 = b  M:\n                accum[b] += 2.0 * qi * qj  # account for (i,j) and (j,i)\n\n    # Normalize\n    shell_volumes = 4.0 * np.pi * (r_centers ** 2) * dr\n    # Avoid division by zero for the r=0 bin\n    shell_volumes[shell_volumes  1e-9] = 1.0\n    g = np.zeros_like(accum)\n    g[shell_volumes > 1e-9] = accum[shell_volumes > 1e-9] / (N * rho * shell_volumes[shell_volumes > 1e-9])\n    \n    return r_centers, g\n\ndef solve():\n    # Define constants and test cases from the problem statement.\n    L = 1.0  # dimensionless box length\n    steps = 15\n    step_size = 0.002\n    M_bins = 20\n    tau = 0.1  # tolerance for max absolute difference in g_qq\n\n    # Build initial configuration\n    positions0, charges = build_initial_configuration(L, jitter_amp=0.02)\n\n    # Test cases: (alpha, eps_real, eps_rec)\n    test_cases = [\n        (2.0, 1e-3, 1e-2),  # Case A (baseline)\n        (4.0, 1e-3, 1e-2),  # Case B\n        (6.0, 1e-3, 1e-2),  # Case C\n    ]\n\n    # Relax and compute g_qq for each case, starting from the same initial configuration\n    g_curves = []\n    for alpha, eps_real, eps_rec in test_cases:\n        pos_relaxed, rcut, nmax = relax_positions(\n            positions0, charges, L, alpha, eps_real, eps_rec, steps, step_size\n        )\n        _, g = g_qq(pos_relaxed, charges, L, M_bins)\n        g_curves.append(g)\n\n    # Use Case A as baseline\n    g_base = g_curves[0]\n    results = []\n    for idx, g in enumerate(g_curves):\n        max_dev = float(np.max(np.abs(g - g_base)))\n        results.append(max_dev = tau)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.lower() for r in map(str,results)]))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}