{
    "hands_on_practices": [
        {
            "introduction": "Accurately representing the geometry of a domain is the first critical step in any high-fidelity simulation. While many introductory methods rely on polygonal meshes that only approximate curved boundaries, the isoparametric concept provides a powerful and elegant solution. This practice guides you through the foundational exercise of constructing a high-order element that can perfectly conform to a curved boundary, a cornerstone of modern Finite Element Methods (FEM) . By deriving the mapping and calculating its Jacobian determinant, you will gain direct insight into how mesh element quality is quantified and controlled, a factor that is paramount for the stability and accuracy of the numerical solution.",
            "id": "3380293",
            "problem": "Consider a single curved, six-node ($6$-node) isoparametric triangular element used to discretize a domain boundary for the numerical solution of Partial Differential Equations (PDEs). The reference element is the unit right triangle in the $(\\xi,\\eta)$-plane with vertices at $(0,0)$, $(1,0)$, and $(0,1)$. The isoparametric mapping $\\mathbf{x}(\\xi,\\eta)$ from the reference triangle to the physical triangle uses the standard quadratic triangular shape functions associated with the three vertices and the three mid-side nodes.\n\nYou are to construct a quadratic isoparametric mapping whose physical edge corresponding to the reference edge between nodes $1$ and $2$ interpolates a circular arc. The circular boundary has radius $R0$ and is centered at the origin. The physical coordinates of the two endpoints (nodes $1$ and $2$) of the curved edge are chosen on the circle at polar angles $-\\theta$ and $+\\theta$, respectively, with $0\\theta\\pi$. The mid-side node on this edge (node $4$) is placed at polar angle $0$. Thus, the three physical points on the curved edge are\n- node $1$: $(R\\cos\\theta,\\,-R\\sin\\theta)$,\n- node $4$: $(R,\\,0)$,\n- node $2$: $(R\\cos\\theta,\\,R\\sin\\theta)$.\nFor the remaining three nodes (node $3$ opposite the curved edge and mid-side nodes $5$ and $6$ on the straight edges), place them so that the other two edges of the element are straight segments; for definiteness, take node $3$ at $(0,0)$ and take nodes $5$ and $6$ at the midpoints of the straight segments connecting node $2$ to node $3$ and node $3$ to node $1$, respectively. \n\nStarting from the definitions of barycentric coordinates and the quadratic six-node triangular shape functions, construct the isoparametric mapping $\\mathbf{x}(\\xi,\\eta)$, restrict it to the curved edge by setting the third barycentric coordinate to zero, and parametrize this edge by a scalar parameter $t\\in[0,1]$ running from node $1$ to node $2$.\n\nUsing this construction, derive the one-dimensional Jacobian determinant along the curved edge, defined as the edge metric factor $J_{e}(t)=\\left\\|\\dfrac{\\partial \\mathbf{x}}{\\partial t}\\right\\|$, as a closed-form analytic expression in terms of $R$, $\\theta$, and $t$. Your final answer must be a single closed-form expression for $J_{e}(t)$. Do not provide an inequality or an equation to solve; provide the explicit expression. No numerical rounding is required.",
            "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Element Type**: Single curved, six-node ($6$-node) isoparametric triangular element.\n- **Reference Element**: Unit right triangle in the $(\\xi,\\eta)$-plane with vertices at $(0,0)$, $(1,0)$, and $(0,1)$.\n- **Mapping**: Isoparametric, using standard quadratic triangular shape functions.\n- **Curved Edge**: The physical edge corresponding to the reference edge between nodes $1$ and $2$ interpolates a circular arc of radius $R0$ centered at the origin.\n- **Physical Coordinates on Curved Edge**:\n    - Node $1$: $\\mathbf{x}_1 = (R\\cos\\theta, -R\\sin\\theta)$.\n    - Node $4$ (mid-side node): $\\mathbf{x}_4 = (R, 0)$.\n    - Node $2$: $\\mathbf{x}_2 = (R\\cos\\theta, R\\sin\\theta)$.\n- **Angle Constraint**: $0  \\theta  \\pi$.\n- **Physical Coordinates of Other Nodes**:\n    - Node $3$: $\\mathbf{x}_3 = (0, 0)$.\n    - Node $5$ (mid-side of 2-3): $\\mathbf{x}_5 = \\frac{1}{2}(\\mathbf{x}_2 + \\mathbf{x}_3)$.\n    - Node $6$ (mid-side of 3-1): $\\mathbf{x}_6 = \\frac{1}{2}(\\mathbf{x}_3 + \\mathbf{x}_1)$.\n    These placements ensure the other two edges are straight.\n- **Task**:\n    1. Construct the isoparametric mapping $\\mathbf{x}(\\xi,\\eta)$.\n    2. Restrict it to the curved edge.\n    3. Parametrize the edge by $t \\in [0,1]$ from node $1$ to node $2$.\n    4. Derive the 1D Jacobian determinant (edge metric factor) $J_{e}(t) = \\left\\|\\frac{\\partial \\mathbf{x}}{\\partial t}\\right\\|$ as a closed-form expression in terms of $R$, $\\theta$, and $t$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a standard application of the Finite Element Method (FEM) for discretizing domains with curved boundaries. The concepts of isoparametric mapping, shape functions, and Jacobians are fundamental to numerical analysis of PDEs.\n- **Well-Posed**: The problem is fully specified. The geometry of the reference and physical elements, the type of interpolation, and the coordinates of all nodes are given, either directly or as a function of other givens. This is sufficient to uniquely determine the parametric mapping and its derivative.\n- **Objective**: The problem is stated in precise mathematical language, free of subjective or ambiguous terms.\n- **Flaw Checklist**: The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, consistent, realistic, and well-posed. It is a non-trivial derivation central to computational mechanics and FEM.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived.\n\n### Solution Derivation\nThe solution proceeds by first defining the shape functions, then constructing the isoparametric mapping, parametrizing the specified edge, and finally deriving the Jacobian.\n\nThe standard node numbering for a 6-node triangle places vertices at nodes $1, 2, 3$ and mid-side nodes at $4$ (side 1-2), $5$ (side 2-3), and $6$ (side 3-1). We associate these nodes with points in the reference $(\\xi, \\eta)$ plane. A common convention, which we adopt, is to use barycentric coordinates $L_1, L_2, L_3$ which are related to $(\\xi, \\eta)$ for the reference triangle vertices at $(0,0)$, $(1,0)$, and $(0,1)$. Let's map node $3$ to $(\\xi, \\eta)=(0,0)$, node $1$ to $(\\xi, \\eta)=(1,0)$, and node $2$ to $(\\xi, \\eta)=(0,1)$.\nThe barycentric coordinates are then $L_1 = \\xi$, $L_2 = \\eta$, and $L_3 = 1-\\xi-\\eta$.\nThe nodal coordinates in barycentric space are:\n- Node $1$: $(L_1, L_2, L_3) = (1,0,0)$\n- Node $2$: $(L_1, L_2, L_3) = (0,1,0)$\n- Node $3$: $(L_1, L_2, L_3) = (0,0,1)$\n- Node $4$ (midpoint of 1-2): $(1/2, 1/2, 0)$\n- Node $5$ (midpoint of 2-3): $(0, 1/2, 1/2)$\n- Node $6$ (midpoint of 3-1): $(1/2, 0, 1/2)$\n\nThe quadratic shape functions $N_i$ in terms of barycentric coordinates are:\n- Vertex nodes $(i=1, 2, 3)$: $N_i = L_i(2L_i - 1)$\n- Midside nodes: $N_4 = 4L_1L_2$, $N_5 = 4L_2L_3$, $N_6 = 4L_3L_1$\n\nThe isoparametric mapping is given by $\\mathbf{x}(\\xi, \\eta) = \\sum_{i=1}^6 N_i(L_1, L_2, L_3) \\mathbf{x}_i$. We are interested in the edge connecting nodes $1$ and $2$. This edge is defined by $L_3=0$, which implies $1-\\xi-\\eta=0$, or $\\eta=1-\\xi$.\nOn this edge, the only non-zero shape functions are $N_1$, $N_2$, and $N_4$:\n- $N_1 = L_1(2L_1-1) = \\xi(2\\xi-1)$\n- $N_2 = L_2(2L_2-1) = \\eta(2\\eta-1) = (1-\\xi)(2(1-\\xi)-1) = (1-\\xi)(1-2\\xi)$\n- $N_4 = 4L_1L_2 = 4\\xi\\eta = 4\\xi(1-\\xi)$\nAll other shape functions ($N_3, N_5, N_6$) are zero because they contain a factor of $L_3$.\nThe mapping on this edge is $\\mathbf{x}(\\xi) = N_1(\\xi)\\mathbf{x}_1 + N_2(\\xi)\\mathbf{x}_2 + N_4(\\xi)\\mathbf{x}_4$.\n\nWe need to parametrize this edge with a parameter $t \\in [0,1]$ that runs from node $1$ to node $2$.\nAt node $1$, $(L_1,L_2,L_3)=(1,0,0)$, so $\\xi = 1$.\nAt node $2$, $(L_1,L_2,L_3)=(0,1,0)$, so $\\xi = 0$.\nThe parameter $\\xi$ goes from $1$ to $0$ as we move from node $1$ to $2$. We choose the transformation $t = 1-\\xi$, so $\\xi = 1-t$.\nAs $\\xi$ goes from $1$ to $0$, $t$ goes from $0$ to $1$.\nSubstituting $\\xi = 1-t$ into the shape functions:\n- $L_1 = \\xi = 1-t$\n- $L_2 = \\eta = 1-\\xi = t$\n- $N_1(t) = (1-t)(2(1-t)-1) = (1-t)(1-2t)$\n- $N_2(t) = t(2t-1)$\n- $N_4(t) = 4(1-t)t$\n\nThe edge is now parametrized by $t$:\n$\\mathbf{x}(t) = N_1(t)\\mathbf{x}_1 + N_2(t)\\mathbf{x}_2 + N_4(t)\\mathbf{x}_4$\n$\\mathbf{x}(t) = (1-t)(1-2t)\\mathbf{x}_1 + t(2t-1)\\mathbf{x}_2 + 4t(1-t)\\mathbf{x}_4$\n\nTo find the Jacobian $J_e(t)$, we first compute the tangent vector $\\frac{\\partial\\mathbf{x}}{\\partial t}$:\n$\\frac{\\partial\\mathbf{x}}{\\partial t} = \\frac{\\partial N_1}{\\partial t}\\mathbf{x}_1 + \\frac{\\partial N_2}{\\partial t}\\mathbf{x}_2 + \\frac{\\partial N_4}{\\partial t}\\mathbf{x}_4$\nThe derivatives of the shape functions with respect to $t$ are:\n- $\\frac{\\partial N_1}{\\partial t} = \\frac{\\partial}{\\partial t}(1 - 3t + 2t^2) = 4t-3$\n- $\\frac{\\partial N_2}{\\partial t} = \\frac{\\partial}{\\partial t}(2t^2 - t) = 4t-1$\n- $\\frac{\\partial N_4}{\\partial t} = \\frac{\\partial}{\\partial t}(4t - 4t^2) = 4-8t$\n\nSo, the tangent vector is:\n$\\frac{\\partial\\mathbf{x}}{\\partial t} = (4t-3)\\mathbf{x}_1 + (4t-1)\\mathbf{x}_2 + (4-8t)\\mathbf{x}_4$\n\nNow we substitute the physical coordinates $\\mathbf{x}_1 = (R\\cos\\theta, -R\\sin\\theta)$, $\\mathbf{x}_2 = (R\\cos\\theta, R\\sin\\theta)$, and $\\mathbf{x}_4 = (R, 0)$. Let $\\frac{\\partial\\mathbf{x}}{\\partial t} = (x'(t), y'(t))$.\nThe $x$-component is:\n$x'(t) = (4t-3)(R\\cos\\theta) + (4t-1)(R\\cos\\theta) + (4-8t)(R)$\n$x'(t) = R [ (4t-3+4t-1)\\cos\\theta + (4-8t) ]$\n$x'(t) = R [ (8t-4)\\cos\\theta - (8t-4) ]$\n$x'(t) = R(8t-4)(\\cos\\theta-1) = 4R(2t-1)(\\cos\\theta-1)$\n\nThe $y$-component is:\n$y'(t) = (4t-3)(-R\\sin\\theta) + (4t-1)(R\\sin\\theta) + (4-8t)(0)$\n$y'(t) = R\\sin\\theta [ -(4t-3) + (4t-1) ]$\n$y'(t) = R\\sin\\theta [ -4t+3+4t-1 ] = 2R\\sin\\theta$\n\nThe Jacobian is the magnitude of this tangent vector:\n$J_e(t) = \\left\\| \\frac{\\partial\\mathbf{x}}{\\partial t} \\right\\| = \\sqrt{(x'(t))^2 + (y'(t))^2}$\n$J_e(t)^2 = [4R(2t-1)(\\cos\\theta-1)]^2 + [2R\\sin\\theta]^2$\n$J_e(t)^2 = 16R^2(2t-1)^2(\\cos\\theta-1)^2 + 4R^2\\sin^2\\theta$\n\nTo simplify, we use the half-angle identities:\n$\\cos\\theta-1 = -2\\sin^2\\left(\\frac{\\theta}{2}\\right)$\n$\\sin\\theta = 2\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)$\n\nSubstituting these into the expression for $J_e(t)^2$:\n$J_e(t)^2 = 16R^2(2t-1)^2 \\left(-2\\sin^2\\left(\\frac{\\theta}{2}\\right)\\right)^2 + 4R^2 \\left(2\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\right)^2$\n$J_e(t)^2 = 16R^2(2t-1)^2 \\left(4\\sin^4\\left(\\frac{\\theta}{2}\\right)\\right) + 4R^2 \\left(4\\sin^2\\left(\\frac{\\theta}{2}\\right)\\cos^2\\left(\\frac{\\theta}{2}\\right)\\right)$\n$J_e(t)^2 = 64R^2(2t-1)^2\\sin^4\\left(\\frac{\\theta}{2}\\right) + 16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)\\cos^2\\left(\\frac{\\theta}{2}\\right)$\n\nFactor out the common term $16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)$:\n$J_e(t)^2 = 16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right) \\left[ 4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right) \\right]$\n\nTaking the square root to find $J_e(t)$:\n$J_e(t) = \\sqrt{16R^2\\sin^2\\left(\\frac{\\theta}{2}\\right)} \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}$\nSince $R0$ and $0\\theta\\pi$, we have $0\\frac{\\theta}{2}\\frac{\\pi}{2}$, which implies $\\sin\\left(\\frac{\\theta}{2}\\right)0$.\n$J_e(t) = 4R\\sin\\left(\\frac{\\theta}{2}\\right) \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}$\n\nThis is the final closed-form expression for the Jacobian determinant along the curved edge.",
            "answer": "$$ \\boxed{4R\\sin\\left(\\frac{\\theta}{2}\\right) \\sqrt{4(2t-1)^2\\sin^2\\left(\\frac{\\theta}{2}\\right) + \\cos^2\\left(\\frac{\\theta}{2}\\right)}} $$"
        },
        {
            "introduction": "Real-world engineering problems often involve complex assemblies or materials with distinct properties, making a single, conforming mesh impractical or inefficient. This challenge requires methods that can couple different, non-matching grids across interfaces. This exercise introduces you to the mortar method, a sophisticated domain decomposition technique that weakly enforces physical continuity conditions using Lagrange multipliers . By implementing this method, you will not only solve the practical problem of non-matching grids but also discover the dual role of the Lagrange multiplier as both a mathematical constraint enforcer and a physically meaningful approximation of the interface flux, or traction.",
            "id": "3380250",
            "problem": "Consider the one-dimensional elliptic interface problem defined on the interval $[0,1]$ with a coefficient jump at a fixed interface location $x_0 \\in (0,1)$. Let the diffusion coefficient be piecewise constant, denoted by $a(x) = a_1$ for $x \\in [0,x_0]$ and $a(x) = a_2$ for $x \\in [x_0,1]$. The governing Partial Differential Equation (PDE) is\n$$\n- \\frac{d}{dx}\\left( a(x)\\,\\frac{du}{dx} \\right) = 0 \\quad \\text{on } (0,1),\n$$\nsubject to Dirichlet boundary conditions\n$$\nu(0) = 0, \\quad u(1) = 1.\n$$\nThe interface conditions to be enforced at $x = x_0$ are the continuity of the solution and the continuity of normal flux,\n$$\nu(x_0^-)=u(x_0^+), \\quad a_1\\,u'(x_0^-)=a_2\\,u'(x_0^+).\n$$\nYou must discretize the domain using two non-matching uniform grids (meshes): a left mesh on $[0,x_0]$ with $N_L$ elements and a right mesh on $[x_0,1]$ with $N_R$ elements, where the interior nodes of the two meshes do not align. Use the Finite Element Method (FEM) with continuous, piecewise-linear basis functions on each subdomain and introduce a mortar method (MM) with a single Lagrange multiplier to enforce the interface conditions weakly across the non-matching grids. The goal is to develop and implement the discrete saddle-point formulation that ensures solution continuity through a constraint and represents flux continuity through the Lagrange multiplier as a discrete traction at the interface.\n\nStarting from the weak form over the two subdomains and using fundamental principles of variational methods and interface traction balance, derive the discrete algebraic system that couples the two subdomain solutions (with the Dirichlet boundary conditions enforced on $x=0$ and $x=1$) and a single interface multiplier. Your implementation must:\n- Assemble the subdomain stiffness matrices and load vectors for $- \\frac{d}{dx}\\left( a\\,u' \\right) = 0$ with the given Dirichlet boundary conditions.\n- Incorporate the interface coupling through the Lagrange multiplier that enforces trace continuity and represents the interface traction in the weak form.\n- Solve the resulting saddle-point system to obtain the left subdomain nodal values, right subdomain nodal values, and the interface multiplier.\n\nDefine the following quantitative diagnostics to analyze consistency and flux continuity:\n- The continuity residual at the interface,\n$$\ne_c = \\left| u_L(x_0) - u_R(x_0) \\right|,\n$$\nwhere $u_L(x_0)$ and $u_R(x_0)$ are the discrete nodal values at the interface node in the left and right subdomains, respectively.\n- The flux continuity residual at the interface,\n$$\ne_f = \\left| a_1\\,u_L'(x_0^-) - a_2\\,u_R'(x_0^+) \\right|,\n$$\nwhere $u_L'(x_0^-)$ is the one-sided discrete derivative computed from the last element on the left mesh, and $u_R'(x_0^+)$ is the one-sided discrete derivative computed from the first element on the right mesh.\n- The relative error in the interface traction,\n$$\ne_J = \\frac{\\left| \\lambda - J_{\\text{exact}} \\right|}{\\left| J_{\\text{exact}} \\right|},\n$$\nwhere $\\lambda$ is the computed Lagrange multiplier (interpreted as the discrete interface traction) and $J_{\\text{exact}}$ is the exact constant flux obtained analytically for the given PDE, coefficients, interface location, and Dirichlet boundary conditions.\n\nUse the following test suite, each specified by the tuple $(x_0, a_1, a_2, N_L, N_R)$:\n- Test $1$ (general case with moderate contrast and non-matching grids): $(0.3, 1, 2, 20, 35)$.\n- Test $2$ (high-contrast case with $a_1/a_2 \\gg 1$): $(0.7, 10^6, 1, 5, 9)$.\n- Test $3$ (high-contrast case with $a_1/a_2 \\ll 1$): $(0.4, 10^{-6}, 1, 8, 12)$.\n\nYour program must implement the derivation and computation, then evaluate $(e_c, e_f, e_J)$ for each test case. The final output must be a single line containing a list of the three-element lists for each test case, in the order given by the test suite. The format must be exactly\n$$\n\\text{[}[e_{c,1},e_{f,1},e_{J,1}],[e_{c,2},e_{f,2},e_{J,2}],[e_{c,3},e_{f,3},e_{J,3}]\\text{]},\n$$\nwhere all entries are real numbers. No physical units are required in this problem. Angle units are not applicable. Percentages must be expressed as decimals. The program must be self-contained, require no user input, and produce exactly the specified single-line output. Ensure that your design tests solution consistency, flux continuity, and robustness in the regime $a_1/a_2 \\gg 1$.",
            "solution": "The user has provided a problem that requires the numerical solution of a one-dimensional elliptic interface problem using the Finite Element Method (FEM) with non-matching grids, coupled by a mortar method with a single Lagrange multiplier.\n\n### Step 1: Extract Givens\n- **PDE**: $- \\frac{d}{dx}\\left( a(x)\\,\\frac{du}{dx} \\right) = 0$ on the domain $\\Omega = (0,1)$.\n- **Coefficient**: $a(x)$ is piecewise constant: $a(x) = a_1$ for $x \\in [0,x_0]$ and $a(x) = a_2$ for $x \\in [x_0,1]$, where $x_0 \\in (0,1)$ is the interface location.\n- **Boundary Conditions (BCs)**: $u(0) = 0$ and $u(1) = 1$.\n- **Interface Conditions**: At $x=x_0$, the solution $u(x)$ and the flux $a(x)u'(x)$ are continuous.\n  - $u(x_0^-) = u(x_0^+)$ (Continuity of solution)\n  - $a_1 u'(x_0^-) = a_2 u'(x_0^+)$ (Continuity of flux/traction)\n- **Discretization**: The domain is decomposed into $\\Omega_L = [0, x_0]$ and $\\Omega_R = [x_0, 1]$.\n  - $\\Omega_L$ is meshed with a uniform grid of $N_L$ elements.\n  - $\\Omega_R$ is meshed with a uniform grid of $N_R$ elements.\n- **Numerical Method**:\n  - Finite Element Method with continuous, piecewise-linear basis functions on each subdomain.\n  - A single Lagrange multiplier, $\\lambda$, is used to weakly enforce the interface conditions, resulting in a saddle-point system.\n- **Diagnostics**:\n  - Continuity residual: $e_c = | u_L(x_0) - u_R(x_0) |$.\n  - Flux continuity residual: $e_f = | a_1 u_L'(x_0^-) - a_2 u_R'(x_0^+) |$.\n  - Relative error in interface traction: $e_J = \\frac{| \\lambda - J_{\\text{exact}} |}{| J_{\\text{exact}} |}$, where $\\lambda$ is the Lagrange multiplier and $J_{\\text{exact}}$ is the exact analytical flux.\n- **Test Suite**: Tuples of $(x_0, a_1, a_2, N_L, N_R)$.\n  - Test 1: $(0.3, 1, 2, 20, 35)$\n  - Test 2: $(0.7, 10^6, 1, 5, 9)$\n  - Test 3: $(0.4, 10^{-6}, 1, 8, 12)$\n\n### Step 2: Validate Using Extracted Givens\nThe provided problem is a well-established and standard exercise in the field of numerical methods for Partial Differential Equations, specifically concerning domain decomposition and non-matching grid coupling.\n\n- **Scientifically Grounded (Critical)**: The problem is based on the fundamental principles of elliptic PDEs and the Finite Element Method. The use of a Lagrange multiplier to enforce constraints is a standard technique in variational calculus and numerical analysis.\n- **Well-Posed**: The continuous problem is well-posed, admitting a unique solution. The discrete formulation using a saddle-point system is also well-posed and standard for this class of problems.\n- **Objective (Critical)**: The problem is stated using precise mathematical language, with clear definitions and objectives.\n\nThe problem statement is self-contained, consistent, and does not violate any of the invalidity criteria. It is a formalizable scientific problem relevant to the specified topic.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Principle-Based Design: Derivation and Discretization\n\nThe solution approach is to formulate the problem in a weak, variational form, discretize it using finite elements, and solve the resulting algebraic system.\n\n**1. Weak Formulation with Lagrange Multiplier**\n\nWe decompose the problem into two subdomains, $\\Omega_L = (0, x_0)$ and $\\Omega_R = (x_0, 1)$. The weak formulation is derived by multiplying the PDE by a test function $v(x)$ and integrating over each subdomain.\n\nFor $\\Omega_L$, let $v_L$ be a test function with $v_L(0)=0$:\n$$ -\\int_0^{x_0} \\frac{d}{dx}\\left( a_1 \\frac{du_L}{dx} \\right) v_L dx = 0 $$\nIntegrating by parts gives:\n$$ \\int_0^{x_0} a_1 \\frac{du_L}{dx} \\frac{dv_L}{dx} dx - \\left[ a_1 \\frac{du_L}{dx} v_L \\right]_0^{x_0} = 0 $$\n$$ \\int_0^{x_0} a_1 u_L' v_L' dx = a_1 u_L'(x_0^-) v_L(x_0) $$\nSimilarly for $\\Omega_R$, with a test function $v_R$ having $v_R(1)=0$:\n$$ \\int_{x_0}^1 a_2 u_R' v_R' dx = -a_2 u_R'(x_0^+) v_R(x_0) $$\n\nWe introduce a Lagrange multiplier $\\lambda$ to represent the interface traction (flux). Let's define the traction as $T(x) = a(x) u'(x)$. The interface conditions are $u_L(x_0)=u_R(x_0)$ and $T_L(x_0) = T_R(x_0)$. Let $\\lambda$ approximate this common traction value. The weak formulation becomes: find $u_L, u_R, \\lambda$ such that\n$$ \\int_0^{x_0} a_1 u_L' v_L' dx = \\lambda v_L(x_0) \\quad \\forall v_L \\in H^1_0(0, x_0) $$\n$$ \\int_{x_0}^1 a_2 u_R' v_R' dx = -\\lambda v_R(x_0) \\quad \\forall v_R \\text{ with } v_R(1)=0 $$\n$$ u_L(x_0) = u_R(x_0) $$\nThe second equation uses $-\\lambda$ because the normal vector to $\\Omega_R$ at $x_0$ points in the $-x$ direction. This formulation correctly enforces $a_1 u_L'(x_0^-) = a_2 u_R'(x_0^+) = \\lambda$.\n\n**2. Finite Element Discretization**\n\nWe discretize $\\Omega_L$ with $N_L$ linear elements of size $h_L = x_0/N_L$ and $\\Omega_R$ with $N_R$ linear elements of size $h_R = (1-x_0)/N_R$. The solution on each subdomain is approximated by a sum of piecewise-linear basis (hat) functions $\\phi_i(x)$:\n- $u_L(x) \\approx \\sum_{j=0}^{N_L} U_{L,j} \\phi_{L,j}(x)$ with $U_{L,0}=0$. Unknowns are $\\mathbf{U}_L = [U_{L,1}, \\dots, U_{L,N_L}]^T$.\n- $u_R(x) \\approx \\sum_{j=0}^{N_R} U_{R,j} \\phi_{R,j}(x)$ with $U_{R,N_R}=1$. Unknowns are $\\mathbf{U}_R = [U_{R,0}, \\dots, U_{R,N_R-1}]^T$.\n\nSubstituting these into the weak form and choosing basis functions as test functions leads to a block matrix system. The element stiffness matrix for an element of size $h$ with coefficient $a$ is $k^e = \\frac{a}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$. Assembling these for each subdomain, accounting for the boundary conditions, yields the subdomain stiffness matrices $A_L$ ($N_L \\times N_L$) and $A_R$ ($N_R \\times N_R$).\n\nThe discrete system is a saddle-point problem for the unknown vectors $\\mathbf{U}_L$, $\\mathbf{U}_R$, and the scalar multiplier $\\lambda$:\n$$\n\\begin{pmatrix}\nA_L  \\mathbf{0}  -B_L \\\\\n\\mathbf{0}  A_R  B_R \\\\\nB_L^T  -B_R^T  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{U}_L \\\\\n\\mathbf{U}_R \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n\\mathbf{F}_{BC} \\\\\n0\n\\end{pmatrix}\n$$\n- $A_L$ is the $N_L \\times N_L$ stiffness matrix on $\\Omega_L$ with the Dirichlet BC at $x=0$ applied.\n- $A_R$ is the $N_R \\times N_R$ stiffness matrix on $\\Omega_R$ with homogeneous BCs assumed for now.\n- $B_L = [0, \\dots, 0, 1]^T$ is an $N_L \\times 1$ vector that picks the value at the interface node $x_0$ from $\\mathbf{U}_L$.\n- $B_R = [1, 0, \\dots, 0]^T$ is an $N_R \\times 1$ vector that picks the value at the interface node $x_0$ from $\\mathbf{U}_R$.\n- $\\mathbf{F}_{BC}$ is a vector handling the non-homogeneous BC $u(1)=1$. From the assembly, $\\mathbf{F}_{BC} = [0, \\dots, 0, a_2/h_R]^T$.\n\nThe first block row $A_L \\mathbf{U}_L - \\lambda B_L = \\mathbf{0}$ enforces $\\lambda = a_1 u_L'(x_0^-)$ at the interface.\nThe second block row $A_R \\mathbf{U}_R + \\lambda B_R = \\mathbf{F}_{BC}$ enforces $\\lambda = a_2 u_R'(x_0^+)$ at the interface.\nThe third block row $B_L^T \\mathbf{U}_L - B_R^T \\mathbf{U}_R = 0$ enforces continuity $U_{L,N_L} = U_{R,0}$.\n\n**3. Analytical Solution and Diagnostics**\n\nThe PDE implies that the traction $T(x) = a(x)u'(x)$ is constant. Let this constant be $J_{\\text{exact}}$.\n$$ u'(x) = \\frac{J_{\\text{exact}}}{a(x)} $$\nIntegrating from $x=0$ to $x=1$:\n$$ u(1) - u(0) = \\int_0^1 \\frac{J_{\\text{exact}}}{a(x)} dx = J_{\\text{exact}} \\left( \\int_0^{x_0} \\frac{1}{a_1} dx + \\int_{x_0}^1 \\frac{1}{a_2} dx \\right) $$\n$$ 1 - 0 = J_{\\text{exact}} \\left( \\frac{x_0}{a_1} + \\frac{1-x_0}{a_2} \\right) $$\nThus, the exact constant traction (flux) is:\n$$ J_{\\text{exact}} = \\left( \\frac{x_0}{a_1} + \\frac{1-x_0}{a_2} \\right)^{-1} $$\nThe Lagrange multiplier $\\lambda$ is our numerical approximation of this quantity.\n\nThe diagnostics are computed as follows:\n- $e_c = | U_{L,N_L} - U_{R,0} |$: Value from the last node of the left solution and the first node of the right solution. By construction of our system, this should be zero up to machine precision.\n- $e_f = | a_1 u_L'(x_0^-) - a_2 u_R'(x_0^+) |$: The discrete one-sided derivatives are $u_L'(x_0^-) = (U_{L,N_L} - U_{L,N_L-1}) / h_L$ and $u_R'(x_0^+) = (U_{R,1} - U_{R,0}) / h_R$. Our formulation implies $a_1 u_L' \\approx \\lambda$ and $a_2 u_R' \\approx \\lambda$, so this residual should also be near zero.\n- $e_J = \\frac{| \\lambda - J_{\\text{exact}} |}{| J_{\\text{exact}} |}$: The relative error between the computed Lagrange multiplier and the exact analytical traction. This measures the discretization error of the method.\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_mortar_fem(x0, a1, a2, NL, NR):\n    \"\"\"\n    Solves the 1D elliptic interface problem using a mortar FEM formulation.\n\n    Args:\n        x0 (float): Interface location.\n        a1 (float): Diffusion coefficient on the left subdomain [0, x0].\n        a2 (float): Diffusion coefficient on the right subdomain [x0, 1].\n        NL (int): Number of elements in the left subdomain.\n        NR (int): Number of elements in the right subdomain.\n\n    Returns:\n        tuple[float, float, float]: A tuple containing the diagnostics (ec, ef, eJ).\n    \"\"\"\n    # 1. Define mesh parameters\n    hL = x0 / NL\n    hR = (1 - x0) / NR\n\n    # 2. Assemble subdomain stiffness matrices (A_L, A_R)\n    # A_L is an NL x NL matrix for unknowns U_{L,1}, ..., U_{L,NL}\n    # It corresponds to rows/cols 1 to NL of the full (NL+1)x(NL+1) matrix\n    val_L = a1 / hL\n    AL_diag_vals = np.full(NL, 2.0 * val_L)\n    AL_diag_vals[-1] = 1.0 * val_L  # Modification for interface node\n    AL = np.diag(AL_diag_vals)\n    AL_offdiag_vals = np.full(NL - 1, -1.0 * val_L)\n    AL += np.diag(AL_offdiag_vals, k=1)\n    AL += np.diag(AL_offdiag_vals, k=-1)\n\n    # A_R is an NR x NR matrix for unknowns U_{R,0}, ..., U_{R,NR-1}\n    # It corresponds to rows/cols 0 to NR-1 of the full (NR+1)x(NR+1) matrix\n    val_R = a2 / hR\n    AR_diag_vals = np.full(NR, 2.0 * val_R)\n    AR_diag_vals[0] = 1.0 * val_R  # Modification for interface node\n    AR = np.diag(AR_diag_vals)\n    AR_offdiag_vals = np.full(NR - 1, -1.0 * val_R)\n    AR += np.diag(AR_offdiag_vals, k=1)\n    AR += np.diag(AR_offdiag_vals, k=-1)\n\n    # 3. Assemble coupling vectors and block system\n    # B_L selects the last unknown of U_L (U_L,NL)\n    BL = np.zeros((NL, 1))\n    BL[-1, 0] = 1.0\n\n    # B_R selects the first unknown of U_R (U_R,0)\n    BR = np.zeros((NR, 1))\n    BR[0, 0] = 1.0\n\n    # Assemble the full saddle-point matrix K\n    K = np.block([\n        [AL,                 np.zeros((NL, NR)), -BL],\n        [np.zeros((NR, NL)), AR,                  BR],\n        [BL.T,              -BR.T,                0.0]\n    ])\n\n    # 4. Assemble the right-hand side vector F\n    F = np.zeros(NL + NR + 1)\n    # The non-homogeneous Dirichlet BC u(1)=1 affects the equation for U_R,NR-1.\n    # The term from the full stiffness matrix is (A_R_full)_{NR-1, NR} * u(1),\n    # which is (-a2/hR) * 1. Moved to the RHS, it becomes a2/hR.\n    # This entry corresponds to the last row of the A_R block.\n    F[NL + NR - 1] = a2 / hR\n\n    # 5. Solve the linear system\n    try:\n        solution_vec = np.linalg.solve(K, F)\n    except np.linalg.LinAlgError:\n         # Handle potential singularity for ill-conditioned cases, though not expected here\n         return (float('nan'), float('nan'), float('nan'))\n\n    # 6. Extract results from the solution vector\n    U_L = solution_vec[:NL]          # Nodal values U_{L,1}, ..., U_{L,NL}\n    U_R = solution_vec[NL:NL + NR] # Nodal values U_{R,0}, ..., U_{R,NR-1}\n    lmbda = solution_vec[-1]         # Lagrange multiplier lambda\n\n    # 7. Calculate diagnostics\n    # Continuity residual ec\n    # U_L[-1] is the nodal value U_L,NL at x0 from the left.\n    # U_R[0] is the nodal value U_R,0 at x0 from the right.\n    ec = abs(U_L[-1] - U_R[0])\n\n    # Flux continuity residual ef\n    # Get previous nodal value on the left; U_L,0 is 0.\n    U_L_prev = U_L[-2] if NL > 1 else 0.0\n    u_prime_L = (U_L[-1] - U_L_prev) / hL\n    \n    # Get next nodal value on the right; U_R,NR is 1.0\n    U_R_next = U_R[1] if NR > 1 else 1.0\n    u_prime_R = (U_R_next - U_R[0]) / hR\n    \n    ef = abs(a1 * u_prime_L - a2 * u_prime_R)\n\n    # Relative error in interface traction eJ\n    # The exact traction/flux, J = a(x)u'(x), is constant.\n    J_exact = 1.0 / (x0 / a1 + (1 - x0) / a2)\n    eJ = abs(lmbda - J_exact) / abs(J_exact) if J_exact != 0 else abs(lmbda)\n\n    return (ec, ef, eJ)\n\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (0.3, 1, 2, 20, 35),\n        (0.7, 10**6, 1, 5, 9),\n        (0.4, 10**-6, 1, 8, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        x0, a1, a2, N_L, N_R = case\n        ec, ef, eJ = solve_mortar_fem(x0, a1, a2, N_L, N_R)\n        results.append(f\"[{ec:.16e},{ef:.16e},{eJ:.16e}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
            "answer": "[[0.0000000000000000e+00,0.0000000000000000e+00,0.0000000000000000e+00],[0.0000000000000000e+00,0.0000000000000000e+00,1.4012984643248171e-16],[0.0000000000000000e+00,0.0000000000000000e+00,1.2013146433363322e-16]]"
        },
        {
            "introduction": "For transient problems with dynamic features like moving shocks, flames, or crack tips, a static mesh is profoundly inefficient. The most advanced meshing strategies therefore adapt the grid to the solution itself. This final practice dives into the world of r-adaptive methods with an Arbitrary Lagrangian-Eulerian (ALE) formulation, where the mesh nodes themselves move to track evolving features . In this coding challenge, you will implement a mesh PDE that dynamically redistributes grid points based on a monitor function, concentrating resolution where it is needed most. This provides a powerful, hands-on understanding of how to build intelligent, efficient simulations for complex, time-dependent phenomena.",
            "id": "3380280",
            "problem": "Consider the Arbitrary Lagrangian-Eulerian (ALE) formulation in one spatial dimension, where the computational coordinate $\\xi \\in [0,1]$ is mapped to a physical coordinate $x(\\xi,t) \\in [0,1]$ by a time-dependent, strictly increasing mapping. The mesh evolves under the mesh Partial Differential Equation (PDE)\n$$\n\\partial_t x(\\xi,t) \\;=\\; \\partial_\\xi\\big(m(x(\\xi,t),t)\\,\\partial_\\xi x(\\xi,t)\\big),\n$$\nwith Dirichlet boundary conditions $x(0,t)=0$ and $x(1,t)=1$, and initial condition $x(\\xi,0)=\\xi$. The monitor function is given by\n$$\nm(x,t) \\;=\\; \\left|\\partial_x u(x,t)\\right|,\n$$\nwhere $u(x,t)$ is a scalar field on the physical domain. The goal is to build and analyze a moving mesh that concentrates nodes near steep gradients (shock-like features) while maintaining mesh quality.\n\nThe fundamental base is the equidistribution principle for adaptive meshes, which states that an ideal mesh equidistributes the monitor-weighted cell size, i.e., $m(x,t)\\,\\partial_\\xi x(\\xi,t)$ is spatially constant in $\\xi$. The mesh PDE above serves as a relaxation flow toward equidistribution under the constraint of fixed boundary positions.\n\nYou must discretize the mesh PDE in flux form on a uniform computational grid $\\xi_i = i\\,\\Delta\\xi$ for $i=0,\\ldots,N-1$ with $\\Delta\\xi = 1/(N-1)$, using a first-order explicit time integration and second-order centered spatial differences. At each time step, define the half-index fluxes\n$$\nF_{i+\\frac{1}{2}}(t) \\;=\\; m\\big(x_{i+\\frac{1}{2}}(t),t\\big)\\,\\frac{x_{i+1}(t)-x_i(t)}{\\Delta\\xi},\n$$\nwhere $x_{i+\\frac{1}{2}}(t) = \\frac{1}{2}\\big(x_i(t)+x_{i+1}(t)\\big)$, and advance interior nodes by\n$$\n\\partial_t x_i(t) \\;=\\; \\frac{F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)}{\\Delta\\xi}, \\quad i=1,\\ldots,N-2.\n$$\nTo ensure numerical stability for the explicit scheme, choose a time step $\\Delta t$ satisfying\n$$\n\\Delta t \\;\\le\\; \\alpha\\,\\frac{\\Delta\\xi^2}{\\max_{i} m\\big(x_{i+\\frac{1}{2}}(t),t\\big)},\n$$\nwith a prescribed $\\alpha \\in (0,1/2)$.\n\nFor shock tracking analysis, consider three analytic choices for $u(x,t)$ and the corresponding monitors $m(x,t)$:\n- A smooth shock profile defined by\n$$\nu(x,t) \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c(t)}{\\varepsilon}\\right)\\right), \\quad x_c(t) = x_0 + s\\,t,\n$$\nwith derivative\n$$\n\\partial_x u(x,t) \\;=\\; \\frac{1}{2\\,\\varepsilon}\\,\\operatorname{sech}^2\\!\\left(\\frac{x - x_c(t)}{\\varepsilon}\\right),\n$$\nwhere $\\operatorname{sech}(z)=1/\\cosh(z)$.\n- A boundary-adjacent smooth shock using the same form, but with the center $x_c(t)$ near $0$.\n- A linear profile $u(x,t)=x$, yielding a constant derivative $\\partial_x u(x,t)=1$.\n\nTo avoid degeneracy and maintain positivity of the monitor, use a regularized monitor\n$$\nm_\\delta(x,t) \\;=\\; \\sqrt{\\big(\\partial_x u(x,t)\\big)^2 + \\delta^2},\n$$\nwith a small fixed $\\delta0$.\n\nDefine the following mesh quality metrics evaluated at the final time $t=T$:\n- The clustering ratio $C$, which measures shock-focused refinement,\n$$\nC \\;=\\; \\frac{\\overline{h}_{\\text{in}}}{\\overline{h}_{\\text{out}}},\n$$\nwhere $h_i = x_{i+1}(T) - x_i(T)$ are physical cell sizes, $\\overline{h}_{\\text{in}}$ is the average of $h_i$ whose cell midpoints $x_{i+\\frac{1}{2}}(T)$ lie in a specified band, and $\\overline{h}_{\\text{out}}$ is the average outside that band. For shock-type cases, use the band $[x_c(T) - 3\\varepsilon,\\, x_c(T) + 3\\varepsilon]$ clipped to $[0,1]$. For the linear case, use the band $[0.4,\\,0.6]$.\n- The positivity boolean $J$ indicating mesh untangling,\n$$\nJ \\;=\\; \\text{True if } h_i  0 \\text{ for all } i, \\text{ otherwise False}.\n$$\n- The equidistribution residual $E$ defined by the relative $L^\\infty$ deviation of the flux from its spatial mean,\n$$\nE \\;=\\; \\frac{\\max_{i}\\left|F_{i+\\frac{1}{2}}(T) - \\overline{F}(T)\\right|}{\\overline{F}(T)}, \\quad \\overline{F}(T) \\;=\\; \\frac{1}{N-1}\\sum_{i=0}^{N-2} F_{i+\\frac{1}{2}}(T).\n$$\n\nYour program must implement the mesh PDE discretization, advance the mesh to the prescribed final time for each test case, and report the metrics $C$, $J$, and $E$.\n\nNo physical units are involved; all quantities are dimensionless. Angles are not used.\n\nTest Suite:\n- Case $1$ (smooth interior shock): $N=51$, $T=0.05$, $x_0=0.30$, $s=0.60$, $\\varepsilon=0.05$, $\\delta=10^{-8}$, $\\alpha=0.40$.\n- Case $2$ (boundary-adjacent shock): $N=51$, $T=0.05$, $x_0=0.02$, $s=0.00$, $\\varepsilon=0.03$, $\\delta=10^{-8}$, $\\alpha=0.40$.\n- Case $3$ (constant monitor via linear $u$): $N=51$, $T=0.05$, $u(x,t)=x$ so $\\partial_x u=1$, $\\delta=10^{-8}$, $\\alpha=0.40$.\n\nAnswer Specification and Final Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist $[C,J,E]$ in order. For example,\n$$\n\\text{[}[C_1,J_1,E_1],[C_2,J_2,E_2],[C_3,J_3,E_3]\\text{]}.\n$$\nEach $C$ and $E$ must be a floating-point number, and each $J$ must be a boolean.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of numerical analysis for PDEs, specifically the Arbitrary Lagrangian-Eulerian (ALE) method for adaptive meshing. The problem is well-posed, with all necessary conditions, parameters, and definitions provided. The language is objective and unambiguous. It represents a non-trivial but standard computational task in scientific computing.\n\nThe core of the problem is to solve the one-dimensional moving mesh PDE:\n$$\n\\partial_t x(\\xi,t) \\;=\\; \\partial_\\xi\\big(m(x(\\xi,t),t)\\,\\partial_\\xi x(\\xi,t)\\big)\n$$\nfor the physical node positions $x(\\xi,t)$ as a function of the computational coordinate $\\xi \\in [0,1]$ and time $t$. The boundary conditions are fixed at $x(0,t)=0$ and $x(1,t)=1$, with an initial uniform mesh $x(\\xi,0)=\\xi$. The monitor function $m(x,t)$ serves to drive mesh points towards regions where it is large, thereby refining the mesh in those areas.\n\nThe numerical solution is constructed by discretizing the domain and the PDE. The computational domain $[0,1]$ is discretized into a uniform grid with $N$ points, $\\xi_i = i\\,\\Delta\\xi$ for $i=0, \\ldots, N-1$, where the grid spacing is $\\Delta\\xi = 1/(N-1)$. Let $x_i(t)$ be the approximation of $x(\\xi_i, t)$. The PDE is discretized in space using a second-order conservative finite difference scheme. The flux at the midpoint between nodes $i$ and $i+1$ is defined as:\n$$\nF_{i+\\frac{1}{2}}(t) \\;=\\; m\\big(x_{i+\\frac{1}{2}}(t),t\\big)\\,\\frac{x_{i+1}(t)-x_i(t)}{\\Delta\\xi}\n$$\nwhere $x_{i+\\frac{1}{2}}(t) = \\frac{1}{2}(x_i(t)+x_{i+1}(t))$ is the physical midpoint location. The semi-discretized equation for the interior nodes ($i=1, \\ldots, N-2$) is then:\n$$\n\\frac{d x_i}{dt} \\;=\\; \\frac{F_{i+\\frac{1}{2}}(t) - F_{i-\\frac{1}{2}}(t)}{\\Delta\\xi}\n$$\nThe boundary nodes $x_0(t)=0$ and $x_{N-1}(t)=1$ remain stationary.\n\nFor time integration, a first-order explicit Euler method is employed. The update rule for the interior node positions from time step $n$ to $n+1$ is:\n$$\nx_i^{n+1} = x_i^n + \\Delta t \\cdot \\frac{F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n}{\\Delta\\xi}\n$$\nThe stability of this explicit scheme for the parabolic mesh equation requires a constraint on the time step $\\Delta t$. The problem provides the standard Courant-Friedrichs-Lewy (CFL)-like condition:\n$$\n\\Delta t \\;\\le\\; \\alpha\\,\\frac{\\Delta\\xi^2}{\\max_{i} m(x_{i+\\frac{1}{2}},t)}\n$$\nwith a safety factor $\\alpha \\in (0, 1/2)$. Since $\\max(m)$ can change at each time step, $\\Delta t$ is adaptive. The simulation proceeds from $t=0$ to $t=T$ by taking successive time steps, adjusting $\\Delta t$ at each step to satisfy the stability criterion, and ensuring the final step lands exactly at $T$.\n\nThe monitor function is based on the gradient of a scalar field $u(x,t)$, regularized to prevent degeneracy: $m_\\delta(x,t) = \\sqrt{(\\partial_x u)^2 + \\delta^2}$. The problem specifies three cases for $u(x,t)$: two involving a $\\tanh$ profile to simulate a shock and one with a linear profile ($u(x,t)=x$) which results in a constant monitor function $m_\\delta = \\sqrt{1+\\delta^2}$. For the hyperbolic tangent cases, $u(x,t) = \\frac{1}{2}(1 + \\tanh((x - x_c(t))/\\varepsilon))$, the derivative is $\\partial_x u(x,t) = \\frac{1}{2\\varepsilon}\\operatorname{sech}^2((x - x_c(t))/\\varepsilon)$.\n\nAfter advancing the mesh to the final time $t=T$, three quality metrics are computed:\n$1$. The positivity boolean, $J$, checks if the mesh has become tangled. It is true if all cell sizes $h_i(T) = x_{i+1}(T) - x_i(T)$ are positive.\n$2$. The equidistribution residual, $E$, measures how close the mesh is to the ideal equidistributed state where the quantity $m\\,\\partial_\\xi x$ is constant. This is quantified by the relative $L^\\infty$ norm of the deviation of the final fluxes from their mean:\n$$\nE \\;=\\; \\frac{\\max_{i}\\left|F_{i+\\frac{1}{2}}(T) - \\overline{F}(T)\\right|}{\\overline{F}(T)}\n$$\nFor the linear $u(x,t)=x$ case, the initial uniform mesh is already the steady-state solution, so we expect the mesh to remain stationary and $E$ to be close to zero.\n$3$. The clustering ratio, $C$, quantifies the degree of mesh refinement in a specific region of interest. It is the ratio of the average cell size inside a band, $\\overline{h}_{\\text{in}}$, to the average cell size outside the band, $\\overline{h}_{\\text{out}}$. A value of $C  1$ indicates that cells are smaller inside the band, signifying successful mesh clustering. The bands are defined relative to the shock position or as a fixed interval for the linear case.\n\nThe implementation will consist of a main loop over the test cases. For each case, an inner time-stepping loop will execute the algorithm described above. Finally, the metrics will be calculated and collected.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the moving mesh PDE.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"smooth_interior_shock\",\n            \"N\": 51, \"T\": 0.05, \"x0\": 0.30, \"s\": 0.60,\n            \"eps\": 0.05, \"delta\": 1e-8, \"alpha\": 0.40\n        },\n        {\n            \"name\": \"boundary_adjacent_shock\",\n            \"N\": 51, \"T\": 0.05, \"x0\": 0.02, \"s\": 0.00,\n            \"eps\": 0.03, \"delta\": 1e-8, \"alpha\": 0.40\n        },\n        {\n            \"name\": \"linear_u\",\n            \"N\": 51, \"T\": 0.05, \"x0\": None, \"s\": None,\n            \"eps\": None, \"delta\": 1e-8, \"alpha\": 0.40\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is [item1, item2, ...], which matches the requirement.\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Executes the numerical simulation for a single test case.\n    \"\"\"\n    N = params[\"N\"]\n    T = params[\"T\"]\n    delta = params[\"delta\"]\n    alpha = params[\"alpha\"]\n\n    # Initialize computational grid\n    delta_xi = 1.0 / (N - 1)\n    \n    # Initialize physical grid (initially uniform)\n    x = np.linspace(0.0, 1.0, N)\n    \n    current_t = 0.0\n\n    # Time-stepping loop\n    while current_t  T:\n        # Calculate cell midpoints\n        x_mid = 0.5 * (x[:-1] + x[1:])\n\n        # Calculate monitor function at midpoints\n        if params[\"name\"] == \"linear_u\":\n            du_dx_vals = np.ones_like(x_mid)\n        else:\n            xc = params[\"x0\"] + params[\"s\"] * current_t\n            eps = params[\"eps\"]\n            # sech(z) = 1/cosh(z)\n            arg = (x_mid - xc) / eps\n            sech_vals = 1.0 / np.cosh(arg)\n            du_dx_vals = (1.0 / (2.0 * eps)) * (sech_vals**2)\n        \n        monitor_vals = np.sqrt(du_dx_vals**2 + delta**2)\n\n        # Calculate stable time step\n        max_monitor = np.max(monitor_vals)\n        dt = alpha * delta_xi**2 / max_monitor\n\n        # Ensure we do not step over the final time T\n        if current_t + dt > T:\n            dt = T - current_t\n\n        # Calculate fluxes\n        # h_i / delta_xi\n        h_ratio = (x[1:] - x[:-1]) / delta_xi\n        F = monitor_vals * h_ratio\n\n        # Update interior node positions using Explicit Euler\n        dxdt = (F[1:] - F[:-1]) / delta_xi\n        x[1:-1] += dt * dxdt\n        \n        current_t += dt\n\n    # Final mesh at t=T is now in 'x'\n    # Calculate metrics\n    \n    # Metric J: Positivity\n    h = x[1:] - x[:-1]\n    # Use a small tolerance for floating point comparison\n    J = bool(np.all(h > 1e-15))\n\n    # Metric C: Clustering Ratio\n    x_mid_final = 0.5 * (x[:-1] + x[1:])\n    \n    if params[\"name\"] == \"linear_u\":\n        band = [0.4, 0.6]\n    else:\n        xc_T = params[\"x0\"] + params[\"s\"] * T\n        eps = params[\"eps\"]\n        band_min = max(0.0, xc_T - 3.0 * eps)\n        band_max = min(1.0, xc_T + 3.0 * eps)\n        band = [band_min, band_max]\n        \n    inside_mask = (x_mid_final >= band[0])  (x_mid_final = band[1])\n    \n    h_in = h[inside_mask]\n    h_out = h[~inside_mask]\n    \n    # Handle cases where a region might be empty, though unlikely for these params\n    avg_h_in = np.mean(h_in) if len(h_in) > 0 else 0.0\n    avg_h_out = np.mean(h_out) if len(h_out) > 0 else 1.0 # Avoid division by zero\n    \n    C = avg_h_in / avg_h_out\n\n    # Metric E: Equidistribution Residual\n    # Re-calculate fluxes at the final time T\n    if params[\"name\"] == \"linear_u\":\n        du_dx_final = np.ones_like(x_mid_final)\n    else:\n        xc_T = params[\"x0\"] + params[\"s\"] * T\n        eps = params[\"eps\"]\n        arg_final = (x_mid_final - xc_T) / eps\n        sech_final = 1.0 / np.cosh(arg_final)\n        du_dx_final = (1.0 / (2.0 * eps)) * (sech_final**2)\n        \n    monitor_final = np.sqrt(du_dx_final**2 + delta**2)\n    \n    h_ratio_final = (x[1:] - x[:-1]) / delta_xi\n    F_final = monitor_final * h_ratio_final\n    \n    F_bar = np.mean(F_final)\n    \n    if abs(F_bar) > 1e-15:\n        E = np.max(np.abs(F_final - F_bar)) / F_bar\n    else: # Should not happen with regularized monitor\n        E = 0.0\n\n    return [C, J, E]\n\nsolve()\n```",
            "answer": "[[0.06028682025701839, True, 0.04169733560706248], [0.0385750875422891, True, 0.08055660851893116], [1.0, True, 2.220446049250313e-16]]"
        }
    ]
}