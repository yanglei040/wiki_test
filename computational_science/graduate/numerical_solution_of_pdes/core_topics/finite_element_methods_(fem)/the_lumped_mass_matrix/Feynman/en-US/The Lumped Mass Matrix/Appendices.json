{
    "hands_on_practices": [
        {
            "introduction": "This first practice provides a foundational exercise in applying the finite element method to a dynamic system. By modeling the vibrations of a simple axial bar, you will directly implement and compare the effects of using a consistent mass matrix versus a lumped mass matrix. This hands-on coding task is designed to build intuition about how mass lumping alters the system's inertia and, consequently, its predicted natural frequencies, a critical aspect of structural dynamics and modal analysis .",
            "id": "3589685",
            "problem": "Consider the axial vibration of a uniform, straight, prismatic bar of length $L$, cross-sectional area $A$, Youngâ€™s modulus $E$, and mass density $\\rho$. The governing equation for small-amplitude axial motion is the one-dimensional linear momentum balance, $E A \\, \\frac{\\partial^2 u}{\\partial x^2} + \\rho A \\, \\frac{\\partial^2 u}{\\partial t^2} = 0$, with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(L,t)=0$. The objective is to approximate the first three natural frequencies of this bar using the Finite Element Method (FEM) with polynomial interpolation shape functions, and to rigorously compare the effect of using a consistent mass matrix versus a diagonal lumped mass matrix obtained by either the row-sum technique or nodal quadrature.\n\nStarting from the axial wave equation and the weighted residual statement with the Galerkin choice of weight functions equal to the shape functions, derive the discrete eigenvalue problem in the form $K \\mathbf{u} = \\omega^2 M \\mathbf{u}$, where $K$ is the global stiffness matrix, $M$ is the global mass matrix, $\\mathbf{u}$ is the discrete mode shape vector, and $\\omega$ is the natural circular frequency. Construct $K$ and $M$ using one-dimensional Lagrange polynomial interpolation shape functions of degree one (linear) and degree two (quadratic), on a uniform mesh. For the mass matrix, compute:\n- The consistent mass matrix by exact polynomial integration over each element.\n- The diagonal lumped mass matrix by summing the rows of the global consistent mass matrix (row-sum lumping). You may alternatively implement lumping via nodal quadrature at the element level provided it yields the same diagonal entries.\n\nImplement the assembly procedure on a uniform mesh, enforce the homogeneous Dirichlet boundary conditions by eliminating the boundary degrees of freedom, and solve the generalized symmetric eigenvalue problem for the first three modes. Compare against the exact continuous solution for a fixed-fixed axial bar, whose natural circular frequencies are $\\omega_n = \\frac{n \\pi}{L} \\sqrt{\\frac{E}{\\rho}}$, for integer $n \\ge 1$.\n\nReport the relative error for each mode $n$ defined as $(\\omega_{n}^{\\text{FE}} - \\omega_{n}^{\\text{exact}})/\\omega_{n}^{\\text{exact}}$, expressed as decimal numbers without a percentage sign. The comparison should be presented for both the consistent and lumped mass matrices. Although natural frequencies carry the unit of radians per second, the requested outputs are unitless relative errors.\n\nUse the following scientifically consistent parameter sets as a test suite, spanning interpolation order and mesh density:\n- Case $1$: Linear elements, number of elements $N_e=4$, $L=1.0\\,\\text{m}$, $A=1.0 \\times 10^{-4}\\,\\text{m}^2$, $E=2.00\\times 10^{11}\\,\\text{Pa}$, $\\rho=7800\\,\\text{kg/m}^3$.\n- Case $2$: Linear elements, number of elements $N_e=20$, $L=1.0\\,\\text{m}$, $A=1.0 \\times 10^{-4}\\,\\text{m}^2$, $E=2.00\\times 10^{11}\\,\\text{Pa}$, $\\rho=7800\\,\\text{kg/m}^3$.\n- Case $3$: Quadratic elements, number of elements $N_e=2$, $L=1.0\\,\\text{m}$, $A=1.0 \\times 10^{-4}\\,\\text{m}^2$, $E=2.00\\times 10^{11}\\,\\text{Pa}$, $\\rho=7800\\,\\text{kg/m}^3$.\n- Case $4$: Quadratic elements, number of elements $N_e=5$, $L=1.0\\,\\text{m}$, $A=1.0 \\times 10^{-4}\\,\\text{m}^2$, $E=2.00\\times 10^{11}\\,\\text{Pa}$, $\\rho=7800\\,\\text{kg/m}^3$.\n\nYour program must compute, for each case, the list of six decimal values $[\\varepsilon_{c,1}, \\varepsilon_{l,1}, \\varepsilon_{c,2}, \\varepsilon_{l,2}, \\varepsilon_{c,3}, \\varepsilon_{l,3}]$, where $\\varepsilon_{c,n}$ is the relative error for mode $n$ using the consistent mass matrix, and $\\varepsilon_{l,n}$ is the relative error for mode $n$ using the lumped mass matrix. The final output must aggregate the four case-specific lists into a single line printed as a comma-separated list enclosed in square brackets, for example $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.\n\nNo user input is allowed; all parameters are embedded. The numerical results should be reproducible and scientifically sound. Ensure the construction of the shape functions, element matrices, and assembly is derived from first principles of polynomial interpolation and energy-consistent discretization.",
            "solution": "The problem of determining the natural frequencies of an axially vibrating bar is a classic eigenvalue problem in structural dynamics. The provided problem is well-posed, scientifically sound, and contains all necessary information to proceed with a solution using the Finite Element Method (FEM).\n\nThe governing partial differential equation for the axial displacement $u(x,t)$ is the one-dimensional wave equation:\n$$ E A \\frac{\\partial^2 u}{\\partial x^2} = \\rho A \\frac{\\partial^2 u}{\\partial t^2} $$\nAssuming a harmonic response of the form $u(x,t) = \\tilde{u}(x)e^{i\\omega t}$, where $\\tilde{u}(x)$ is the mode shape and $\\omega$ is the natural circular frequency, the problem reduces to a time-independent ordinary differential equation:\n$$ E A \\frac{d^2 \\tilde{u}}{dx^2} + \\rho A \\omega^2 \\tilde{u} = 0 $$\nwith homogeneous Dirichlet boundary conditions $\\tilde{u}(0) = 0$ and $\\tilde{u}(L) = 0$.\n\nTo formulate the finite element model, we start with the weighted residual statement. Multiplying the governing ODE by a weight function $w(x)$ and integrating over the domain $[0, L]$ yields:\n$$ \\int_0^L w \\left( E A \\frac{d^2 \\tilde{u}}{dx^2} + \\rho A \\omega^2 \\tilde{u} \\right) dx = 0 $$\nApplying integration by parts to the stiffness term gives the weak form:\n$$ -\\int_0^L E A \\frac{dw}{dx} \\frac{d\\tilde{u}}{dx} dx + \\left[ w E A \\frac{d\\tilde{u}}{dx} \\right]_0^L + \\omega^2 \\int_0^L \\rho A w \\tilde{u} dx = 0 $$\nIn the Galerkin method, the weight functions $w(x)$ are chosen from the same space as the trial functions for $\\tilde{u}(x)$. To satisfy the essential boundary conditions at $x=0$ and $x=L$, we require $w(0)=0$ and $w(L)=0$, which makes the boundary term $\\left[ w E A d\\tilde{u}/dx \\right]_0^L$ vanish. The weak form to be solved is:\nFind $\\tilde{u}(x)$ such that for all admissible $w(x)$:\n$$ \\int_0^L E A \\frac{dw}{dx} \\frac{d\\tilde{u}}{dx} dx = \\omega^2 \\int_0^L \\rho A w \\tilde{u} dx $$\n\nThe domain is discretized into $N_e$ elements. Within each element $\\Omega_e$, the displacement field is approximated using polynomial shape functions $\\mathbf{N}^{(e)}$ and nodal displacements $\\mathbf{d}^{(e)}$:\n$$ \\tilde{u}^{(e)}(x) = \\mathbf{N}^{(e)}(x) \\mathbf{d}^{(e)} $$\nApplying the Galerkin principle, where $w$ is taken to be each shape function in turn, and summing the contributions from all elements leads to the global discrete system, a generalized eigenvalue problem:\n$$ K \\mathbf{d} = \\omega^2 M \\mathbf{d} $$\nwhere $\\mathbf{d}$ is the global vector of nodal displacements, and the global stiffness matrix $K$ and mass matrix $M$ are assembled from the element matrices $K^{(e)}$ and $M^{(e)}$:\n$$ K^{(e)} = \\int_{\\Omega_e} E A (\\mathbf{B}^{(e)})^T \\mathbf{B}^{(e)} dx \\quad , \\quad M^{(e)} = \\int_{\\Omega_e} \\rho A (\\mathbf{N}^{(e)})^T \\mathbf{N}^{(e)} dx $$\nHere, $\\mathbf{B}^{(e)} = d\\mathbf{N}^{(e)}/dx$ is the strain-displacement matrix.\n\nIntegrals are typically evaluated over a standard parent element with local coordinate $\\xi \\in [-1, 1]$. For a uniform mesh with element length $h_e = L/N_e$, the Jacobian of the transformation from $\\xi$ to $x$ is $J = h_e/2$. The element matrices become:\n$$ K^{(e)} = \\frac{EA}{h_e} \\int_{-1}^{1} \\left(\\frac{d\\mathbf{N}}{d\\xi}\\right)^T \\frac{d\\mathbf{N}}{d\\xi} d\\xi $$\n$$ M^{(e)} = \\frac{\\rho A h_e}{2} \\int_{-1}^{1} \\mathbf{N}^T \\mathbf{N} d\\xi $$\n\n**1-D Linear Element (2 nodes)**\nThe element has two nodes at $\\xi = -1$ and $\\xi = 1$. The linear Lagrange shape functions are:\n$$ N_1(\\xi) = \\frac{1-\\xi}{2}, \\quad N_2(\\xi) = \\frac{1+\\xi}{2} $$\nThe element stiffness matrix is:\n$$ K^{(e)} = \\frac{EA}{h_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} $$\nThe element consistent mass matrix is:\n$$ M_c^{(e)} = \\frac{\\rho A h_e}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix} $$\nThe diagonal lumped mass matrix is obtained by summing the rows of $M_c^{(e)}$ and placing the sums on the diagonal. This is equivalent to lumping half of the element's mass at each node:\n$$ M_l^{(e)} = \\frac{\\rho A h_e}{2} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} $$\n\n**1-D Quadratic Element (3 nodes)**\nThe element has three nodes at $\\xi = -1, 0, 1$. The quadratic Lagrange shape functions are:\n$$ N_1(\\xi) = \\frac{\\xi(\\xi-1)}{2}, \\quad N_2(\\xi) = 1-\\xi^2, \\quad N_3(\\xi) = \\frac{\\xi(\\xi+1)}{2} $$\nThe element stiffness matrix is:\n$$ K^{(e)} = \\frac{EA}{3h_e} \\begin{bmatrix} 7 & -8 & 1 \\\\ -8 & 16 & -8 \\\\ 1 & -8 & 7 \\end{bmatrix} $$\nThe element consistent mass matrix is:\n$$ M_c^{(e)} = \\frac{\\rho A h_e}{30} \\begin{bmatrix} 4 & 2 & -1 \\\\ 2 & 16 & 2 \\\\ -1 & 2 & 4 \\end{bmatrix} $$\nThe diagonal lumped mass matrix from row-summing is:\n$$ M_l^{(e)} = \\frac{\\rho A h_e}{30} \\begin{bmatrix} 5 & 0 & 0 \\\\ 0 & 20 & 0 \\\\ 0 & 0 & 5 \\end{bmatrix} = \\frac{\\rho A h_e}{6} \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 4 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} $$\n\n**Assembly and Boundary Conditions**\nGlobal matrices $K$ and $M$ are constructed by iterating through each element and adding its contributions to the appropriate global degrees of freedom (DOFs). For linear elements, there are $N_n = N_e+1$ nodes. For quadratic elements, $N_n = 2N_e+1$ nodes. The homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(L)=0$ are enforced by eliminating the rows and columns corresponding to the first and last nodes from the global matrices. This results in reduced matrices $K_{red}$ and $M_{red}$ of size $(N_n-2) \\times (N_n-2)$.\n\n**Eigenvalue Problem and Error Calculation**\nWe solve the reduced generalized eigenvalue problem for both consistent and lumped mass matrices:\n$$ K_{red} \\mathbf{d}_{red} = \\omega_c^2 M_{c,red} \\mathbf{d}_{red} \\quad \\text{and} \\quad K_{red} \\mathbf{d}_{red} = \\omega_l^2 M_{l,red} \\mathbf{d}_{red} $$\nThe eigenvalues $\\omega^2$ are computed, and the natural frequencies are found by taking the square root. The first three computed frequencies, $\\omega_{n}^{\\text{FE}}$, are compared to the exact analytical solution for a fixed-fixed bar:\n$$ \\omega_n^{\\text{exact}} = \\frac{n \\pi}{L} \\sqrt{\\frac{E}{\\rho}}, \\quad n=1, 2, 3, \\dots $$\nThe relative error for each mode $n$ is calculated as:\n$$ \\varepsilon_n = \\frac{\\omega_{n}^{\\text{FE}} - \\omega_{n}^{\\text{exact}}}{\\omega_{n}^{\\text{exact}}} $$\nThis procedure is repeated for each of the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef compute_errors(elem_type, N_e, L, A, E, rho):\n    \"\"\"\n    Computes the relative errors for the first three natural frequencies of an axial bar\n    using the Finite Element Method.\n\n    Args:\n        elem_type (str): 'linear' or 'quadratic'.\n        N_e (int): Number of elements.\n        L (float): Length of the bar.\n        A (float): Cross-sectional area.\n        E (float): Young's modulus.\n        rho (float): Mass density.\n\n    Returns:\n        list: A list of six float values representing the relative errors:\n              [err_c1, err_l1, err_c2, err_l2, err_c3, err_l3]\n              'c' for consistent mass, 'l' for lumped mass.\n    \"\"\"\n    \n    h_e = L / N_e\n    \n    if elem_type == 'linear':\n        n_nodes_elem = 2\n        n_dof_total = N_e + 1\n        \n        # Element stiffness matrix\n        K_e = (E * A / h_e) * np.array([[1, -1], [-1, 1]])\n        \n        # Element consistent mass matrix\n        M_c_e = (rho * A * h_e / 6.0) * np.array([[2, 1], [1, 2]])\n        \n        # Element lumped mass matrix (row-sum technique)\n        M_l_e = np.diag(M_c_e.sum(axis=1))\n        \n    elif elem_type == 'quadratic':\n        n_nodes_elem = 3\n        n_dof_total = 2 * N_e + 1\n        \n        # Element stiffness matrix\n        K_e = (E * A / (3.0 * h_e)) * np.array([\n            [7, -8, 1],\n            [-8, 16, -8],\n            [1, -8, 7]\n        ])\n        \n        # Element consistent mass matrix\n        M_c_e = (rho * A * h_e / 30.0) * np.array([\n            [4, 2, -1],\n            [2, 16, 2],\n            [-1, 2, 4]\n        ])\n        \n        # Element lumped mass matrix (row-sum technique)\n        M_l_e = np.diag(M_c_e.sum(axis=1))\n        \n    else:\n        raise ValueError(\"Invalid element type specified.\")\n\n    # Initialize global matrices\n    K_global = np.zeros((n_dof_total, n_dof_total))\n    M_c_global = np.zeros((n_dof_total, n_dof_total))\n    M_l_global = np.zeros((n_dof_total, n_dof_total))\n\n    # Assembly\n    nodes_per_elem_minus_1 = n_nodes_elem - 1\n    for i in range(N_e):\n        # Determine global indices for the current element's nodes\n        if elem_type == 'linear': # P1 elements\n            start_idx = i\n        else: # P2 elements\n            start_idx = i * 2\n        \n        dof_map = slice(start_idx, start_idx + n_nodes_elem)\n        \n        K_global[dof_map, dof_map] += K_e\n        M_c_global[dof_map, dof_map] += M_c_e\n        M_l_global[dof_map, dof_map] += M_l_e\n\n    # Apply homogeneous Dirichlet boundary conditions (u(0)=0, u(L)=0)\n    # by removing first and last rows/columns\n    internal_dofs = slice(1, n_dof_total - 1)\n    K_red = K_global[internal_dofs, internal_dofs]\n    M_c_red = M_c_global[internal_dofs, internal_dofs]\n    M_l_red = M_l_global[internal_dofs, internal_dofs]\n\n    # Solve generalized eigenvalue problems\n    # scipy.linalg.eigh returns eigenvalues in ascending order\n    # eigenvalues are omega^2\n    \n    # Consistent mass\n    eigvals_c = eigh(K_red, M_c_red, eigvals_only=True)\n    omega_fe_c = np.sqrt(eigvals_c)\n\n    # Lumped mass\n    eigvals_l = eigh(K_red, M_l_red, eigvals_only=True)\n    omega_fe_l = np.sqrt(eigvals_l)\n\n    # Calculate exact frequencies\n    c = np.sqrt(E / rho)\n    n_modes = 3\n    omega_exact = [(n + 1) * np.pi * c / L for n in range(n_modes)]\n    \n    # Calculate relative errors\n    errors = []\n    for i in range(n_modes):\n        # For small problems (3 DOFs), we only get 3 frequencies.\n        # For larger problems, ensure we don't index out of bounds.\n        if i  len(omega_fe_c):\n            err_c = (omega_fe_c[i] - omega_exact[i]) / omega_exact[i]\n            err_l = (omega_fe_l[i] - omega_exact[i]) / omega_exact[i]\n            errors.extend([err_c, err_l])\n        else:\n            # Should not happen for the given test cases\n            errors.extend([np.nan, np.nan])\n            \n    return errors\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'elem_type': 'linear', 'N_e': 4, 'L': 1.0, 'A': 1.0e-4, 'E': 2.0e11, 'rho': 7800},\n        {'elem_type': 'linear', 'N_e': 20, 'L': 1.0, 'A': 1.0e-4, 'E': 2.0e11, 'rho': 7800},\n        {'elem_type': 'quadratic', 'N_e': 2, 'L': 1.0, 'A': 1.0e-4, 'E': 2.0e11, 'rho': 7800},\n        {'elem_type': 'quadratic', 'N_e': 5, 'L': 1.0, 'A': 1.0e-4, 'E': 2.0e11, 'rho': 7800}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_errors(\n            elem_type=case['elem_type'],\n            N_e=case['N_e'],\n            L=case['L'],\n            A=case['A'],\n            E=case['E'],\n            rho=case['rho']\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond its effect on accuracy, a primary motivation for using a lumped mass matrix is the significant computational advantage it offers in explicit time-stepping schemes. This practice moves from implementation to a focused theoretical analysis of numerical stability. By deriving the maximum stable time step for the heat equation, you will uncover the direct mathematical link between mass lumping and stability, providing a clear rationale for why diagonal mass matrices are indispensable in many large-scale dynamic simulations .",
            "id": "3456072",
            "problem": "Consider the heat equation with unit thermal diffusivity on a flat two-dimensional torus, $u_t = \\Delta u$, discretized in space by the Finite Element Method (FEM) with continuous, piecewise-linear shape functions on a uniform, periodic triangulation of the plane by congruent equilateral triangles of edge length $\\ell$. Let $K$ denote the assembled stiffness matrix with entries $K_{ij} = \\int_{\\Omega} \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x$, and let $M$ denote the consistent mass matrix with entries $M_{ij} = \\int_{\\Omega} \\phi_i \\phi_j \\, \\mathrm{d}x$. Define the lumped mass matrix $M_L$ as the diagonal matrix obtained by row-summing $M$. Consider the explicit forward Euler time discretization of the semi-discrete system $M \\dot{u} + K u = 0$, so that $u^{n+1} = u^n - \\Delta t \\, B K u^n$, where $B$ is either $M_L^{-1}$ (lumped mass) or an approximation to $M^{-1}$ obtained by performing a single Jacobi iteration starting from the zero initial guess, i.e., $B = D^{-1}$ with $D = \\operatorname{diag}(M)$.\n\nUsing only the fundamental definitions above and well-tested facts about the stability of forward Euler for linear systems, compute the maximum linearly stable time step $\\Delta t_{\\max}$ for:\n- the lumped mass case $B = M_L^{-1}$,\n- the single-Jacobi-inverted consistent mass case $B = D^{-1}$,\non this periodic equilateral mesh. Express the two values as a closed-form analytic expression in terms of the edge length $\\ell$ only, and provide them in the order $(\\Delta t_{\\max}^{\\mathrm{lump}}, \\Delta t_{\\max}^{\\mathrm{Jacobi}})$.\n\nYour final answer must be a single row matrix containing the two expressions. No rounding is required, and no physical units are to be reported in the final answer.",
            "solution": "The user wants to find the maximum stable time step for the forward Euler time discretization of the finite element approximation of the heat equation $u_t = \\Delta u$ on a periodic mesh of equilateral triangles. The stability of the explicit scheme $u^{n+1} = (I - \\Delta t \\, B K) u^n$ is determined by the spectral radius of the matrix $BK$. For a symmetric positive semi-definite stiffness matrix $K$ and a symmetric positive definite matrix $B$, the matrix $B^{1/2} K B^{1/2}$ is also symmetric positive semi-definite, and thus has real, non-negative eigenvalues. Since $BK$ is similar to $B^{1/2} K B^{1/2}$, its eigenvalues $\\lambda_j(BK)$ are also real and non-negative.\n\nThe stability condition for the forward Euler method requires that all eigenvalues of the amplification matrix $G = I - \\Delta t B K$ satisfy $|\\mu_j| \\le 1$. The eigenvalues of $G$ are $\\mu_j = 1 - \\Delta t \\lambda_j(BK)$. The condition becomes $|1 - \\Delta t \\lambda_j| \\le 1$, which for real non-negative $\\lambda_j$ simplifies to $-1 \\le 1 - \\Delta t \\lambda_j \\le 1$. This implies $0 \\le \\Delta t \\lambda_j \\le 2$. The critical constraint is determined by the largest eigenvalue, $\\lambda_{\\max}(BK)$, leading to the stability limit:\n$$ \\Delta t \\le \\frac{2}{\\lambda_{\\max}(BK)} $$\nOur task is to compute $\\lambda_{\\max}(BK)$ for the two given choices of $B$. This requires calculating the entries of the stiffness matrix $K$ and the mass-related matrices $B$.\n\nFirst, we compute the local element matrices for a single equilateral triangle of edge length $\\ell$. The area of such a triangle is $A = \\frac{\\sqrt{3}}{4}\\ell^2$. For linear shape functions $\\phi_i$, the local stiffness matrix $K^e$ and consistent mass matrix $M^e$ are given by standard formulas:\n$$ K^e_{ij} = \\int_e \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, \\mathrm{d}x, \\quad M^e_{ij} = \\int_e \\phi_i \\phi_j \\, \\mathrm{d}x $$\nFor an equilateral triangle, these matrices are:\n$$ K^e = \\frac{1}{2\\sqrt{3}} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix}, \\quad M^e = \\frac{A}{12} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} = \\frac{\\sqrt{3}\\ell^2}{48} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\nThe uniform triangulation of a torus means every node is topologically identical. Each node is a vertex of $6$ congruent equilateral triangles and has $6$ neighbors. We can determine the stencils for the global matrices $K$ and $M$ by summing the contributions from the elements sharing a node. Let's consider a node $i$.\n\nThe diagonal entry $K_{ii}$ is the sum of $6$ diagonal contributions from $K^e$:\n$K_{ii} = 6 \\times \\left(K^e\\right)_{\\text{diag}} = 6 \\times \\frac{2}{2\\sqrt{3}} = 2\\sqrt{3}$.\nThe off-diagonal entry $K_{ij}$ for a neighbor $j$ is the sum of $2$ off-diagonal contributions from the two elements sharing the edge $(i, j)$:\n$K_{ij} = 2 \\times \\left(K^e\\right)_{\\text{off-diag}} = 2 \\times \\left(-\\frac{1}{2\\sqrt{3}}\\right) = -\\frac{1}{\\sqrt{3}}$.\n\nSimilarly for the mass matrix $M$:\n$M_{ii} = 6 \\times \\frac{2A}{12} = A = \\frac{\\sqrt{3}}{4}\\ell^2$.\n$M_{ij} = 2 \\times \\frac{A}{12} = \\frac{A}{6} = \\frac{\\sqrt{3}}{24}\\ell^2$.\n\nDue to the periodic and uniform nature of the grid, the eigenvectors of $K$ and $M$ are discrete plane waves $u_j = \\exp(i\\mathbf{k} \\cdot \\mathbf{x}_j)$, where $\\mathbf{x}_j$ is the position of node $j$. The corresponding eigenvalues (Fourier symbols) are functions of the wave vector $\\mathbf{k}=(k_x, k_y)$.\nLet node $i$ be at the origin. Its neighbors are at positions $\\mathbf{x}_1 = (\\ell, 0)$, $\\mathbf{x}_2 = (\\ell/2, \\ell\\sqrt{3}/2)$, $\\mathbf{x}_3 = (-\\ell/2, \\ell\\sqrt{3}/2)$, and their opposites. The eigenvalue of a matrix with this stencil structure is found by applying it to the eigenvector:\n$\\hat{K}(\\mathbf{k}) = K_{ii} + \\sum_{j \\in N(i)} K_{ij} e^{i\\mathbf{k}\\cdot\\mathbf{x}_j} = 2\\sqrt{3} - \\frac{1}{\\sqrt{3}} \\sum_{j=1}^6 e^{i\\mathbf{k}\\cdot\\mathbf{x}_j}$.\nThe sum evaluates to $\\sum_{j=1}^6 e^{i\\mathbf{k}\\cdot\\mathbf{x}_j} = 2\\cos(k_x \\ell) + 4\\cos(k_x \\ell / 2)\\cos(k_y \\ell \\sqrt{3} / 2)$.\nLet's define $C(\\mathbf{k}) = \\cos(k_x \\ell) + 2\\cos(k_x \\ell/2)\\cos(k_y \\ell\\sqrt{3}/2)$.\nThen $\\hat{K}(\\mathbf{k}) = 2\\sqrt{3} - \\frac{2}{\\sqrt{3}} C(\\mathbf{k}) = \\frac{2}{\\sqrt{3}}(3 - C(\\mathbf{k}))$.\n\nTo find the maximum eigenvalue of $BK$, we need to find the maximum of $\\hat{B}(\\mathbf{k})\\hat{K}(\\mathbf{k})$ over all $\\mathbf{k}$. This requires finding the minimum value of $C(\\mathbf{k})$. By analyzing this function, its minimum value is found to be $-\\frac{3}{2}$.\n\nNow we analyze the two cases for $B$.\n\n**Case 1: Lumped Mass ($B = M_L^{-1}$)**\nThe lumped mass matrix $M_L$ is diagonal with entries $(M_L)_{ii} = \\sum_j M_{ij}$.\n$(M_L)_{ii} = M_{ii} + 6 \\times M_{ij} = A + 6 \\times \\frac{A}{6} = 2A = \\frac{\\sqrt{3}}{2}\\ell^2$.\nSo, $M_L = \\frac{\\sqrt{3}}{2}\\ell^2 I$, where $I$ is the identity matrix.\nThen $B = M_L^{-1} = \\frac{2}{\\sqrt{3}\\ell^2} I$. This matrix is a scalar multiple of the identity, so its symbol $\\hat{B}$ is constant.\nThe eigenvalues of $BK$ are $\\lambda(\\mathbf{k}) = \\hat{B} \\hat{K}(\\mathbf{k}) = \\frac{2}{\\sqrt{3}\\ell^2} \\cdot \\frac{2}{\\sqrt{3}}(3 - C(\\mathbf{k})) = \\frac{4}{3\\ell^2}(3 - C(\\mathbf{k}))$.\nThe maximum eigenvalue $\\lambda_{\\max}$ occurs when $C(\\mathbf{k})$ is at its minimum, i.e., $C(\\mathbf{k}) = -3/2$.\n$\\lambda_{\\max}(M_L^{-1}K) = \\frac{4}{3\\ell^2}\\left(3 - \\left(-\\frac{3}{2}\\right)\\right) = \\frac{4}{3\\ell^2}\\left(\\frac{9}{2}\\right) = \\frac{6}{\\ell^2}$.\nThe maximum stable time step for the lumped mass case is:\n$\\Delta t_{\\max}^{\\mathrm{lump}} = \\frac{2}{\\lambda_{\\max}} = \\frac{2}{6/\\ell^2} = \\frac{\\ell^2}{3}$.\n\n**Case 2: Single Jacobi Iteration ($B = D^{-1}$)**\nHere, $D = \\operatorname{diag}(M)$. The diagonal entries are $D_{ii} = M_{ii} = A = \\frac{\\sqrt{3}}{4}\\ell^2$.\nSo, $D = \\frac{\\sqrt{3}}{4}\\ell^2 I$.\nThen $B = D^{-1} = \\frac{4}{\\sqrt{3}\\ell^2} I$. Again, a scalar matrix.\nThe eigenvalues of $BK$ are $\\lambda(\\mathbf{k}) = \\hat{B} \\hat{K}(\\mathbf{k}) = \\frac{4}{\\sqrt{3}\\ell^2} \\cdot \\frac{2}{\\sqrt{3}}(3 - C(\\mathbf{k})) = \\frac{8}{3\\ell^2}(3 - C(\\mathbf{k}))$.\nThe maximum eigenvalue again corresponds to the minimum of $C(\\mathbf{k})$:\n$\\lambda_{\\max}(D^{-1}K) = \\frac{8}{3\\ell^2}\\left(3 - \\left(-\\frac{3}{2}\\right)\\right) = \\frac{8}{3\\ell^2}\\left(\\frac{9}{2}\\right) = \\frac{12}{\\ell^2}$.\nThe maximum stable time step for the single-Jacobi-inversion case is:\n$\\Delta t_{\\max}^{\\mathrm{Jacobi}} = \\frac{2}{\\lambda_{\\max}} = \\frac{2}{12/\\ell^2} = \\frac{\\ell^2}{6}$.\n\nThe two requested values are $\\Delta t_{\\max}^{\\mathrm{lump}} = \\frac{\\ell^2}{3}$ and $\\Delta t_{\\max}^{\\mathrm{Jacobi}} = \\frac{\\ell^2}{6}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{\\ell^2}{3}  \\frac{\\ell^2}{6} \\end{pmatrix} } $$"
        },
        {
            "introduction": "The final practice encourages a more critical and nuanced perspective on lumping and related simplification techniques. While the previous exercises highlighted benefits in efficiency, this problem demonstrates a scenario where a quadrature-based lumping procedure can be detrimental to the accuracy of post-processed quantities. By investigating the superconvergence of recovered gradients, you will see how seemingly innocuous approximations can degrade solution quality, emphasizing that the choice between consistent and lumped formulations involves crucial trade-offs between computational cost and numerical precision .",
            "id": "3456027",
            "problem": "Consider the scalar elliptic boundary value problem on the unit interval: find $u:[0,1]\\to\\mathbb{R}$ such that\n$$\n- u''(x) = f(x)\\quad \\text{for } x\\in(0,1),\\qquad u(0)=0,\\quad u(1)=0,\n$$\nwith a manufactured exact solution\n$$\nu(x) = e^{x}\\,\\sin(k x),\\quad \\text{where } k = 4\\pi,\n$$\nand forcing term $f(x) = -u''(x)$. This choice satisfies the Dirichlet conditions by construction, since $u(0)=0$ and $u(1)=e^{1}\\sin(4\\pi)=0$. The spatial discretization uses the standard Galerkin method with continuous piecewise quadratic Lagrange basis functions (Polynomial degree $2$, commonly denoted $P_2$ in Finite Element (FE) terminology). The weak form is: find $u\\in H_0^1(0,1)$ such that for all $v\\in H_0^1(0,1)$,\n$$\n\\int_0^1 u'(x)\\,v'(x)\\,dx = \\int_0^1 f(x)\\,v(x)\\,dx.\n$$\nLet $V_h^{(2)}\\subset H_0^1(0,1)$ denote the $P_2$ space on a mesh with nodes $0=x_0x_1\\cdotsx_{N}=1$ and mid-edge nodes per element. Let $u_h\\in V_h^{(2)}$ be the unique discrete solution.\n\nDefine two gradient recovery operators that map the discontinuous element-wise gradient $u_h'$ (which is piecewise linear and in general discontinuous across element interfaces) to a continuous piecewise linear function in the space $V_h^{(1)}$ of continuous piecewise affine functions on the same partition $\\{x_i\\}_{i=0}^N$:\n\n- Consistent $L^2$-projection recovery $R_h^{\\mathrm{C}}$: find $g_h^{\\mathrm{C}}\\in V_h^{(1)}$ such that\n$$\n\\int_0^1 g_h^{\\mathrm{C}}(x)\\,v_h(x)\\,dx = \\int_0^1 u_h'(x)\\,v_h(x)\\,dx\\quad \\text{for all } v_h\\in V_h^{(1)}.\n$$\nThis is the exact $L^2$ projection of $u_h'$ onto $V_h^{(1)}$.\n\n- Lumped (quadrature-based) nodal recovery $R_h^{\\mathrm{L}}$: define $g_h^{\\mathrm{L}}\\in V_h^{(1)}$ by specifying nodal values as a quadrature-lumped average of one-sided gradients at mesh vertices. For an interior node $x_i$ with adjacent element lengths $h_{i-1}=x_i-x_{i-1}$ and $h_i=x_{i+1}-x_i$, set\n$$\ng_h^{\\mathrm{L}}(x_i) = \\frac{h_{i-1}\\, \\left(u_h'\\big|_{(x_{i-1},x_i)}(x_i^-)\\right) + h_i\\, \\left(u_h'\\big|_{(x_i,x_{i+1})}(x_i^+)\\right)}{h_{i-1}+h_i},\n$$\nand for boundary nodes use the one-sided value. This construction corresponds to diagonal lumping of the mass matrix together with a nodal (Dirac-type) quadrature of the $L^2$ inner product, thereby isolating the role of quadrature in the recovery operator.\n\nLet the error of a recovered gradient $g_h$ be measured in the $L^2$ norm, that is\n$$\nE_h(g_h) := \\left(\\int_0^1 \\left(g_h(x) - u'(x)\\right)^2 dx\\right)^{1/2}.\n$$\nOn sufficiently regular meshes, $R_h^{\\mathrm{C}}$ is known to deliver a recovered gradient that can exhibit superconvergence relative to the raw FE gradient, while the lumped recovery $R_h^{\\mathrm{L}}$ may break this behavior when mesh symmetry that underpins cancellation is disturbed.\n\nYour task is to write a complete, runnable program that:\n\n$1.$ Assembles and solves the $P_2$ finite element system for the above problem using accurate numerical quadrature.\n\n$2.$ Constructs the two recovered gradients $g_h^{\\mathrm{C}}$ and $g_h^{\\mathrm{L}}$ defined above.\n\n$3.$ Computes the $L^2$ errors $E_h\\left(g_h^{\\mathrm{C}}\\right)$ and $E_h\\left(g_h^{\\mathrm{L}}\\right)$.\n\n$4.$ Estimates the observed convergence orders by uniform refinement using the last two refinements:\n$$\np_{\\mathrm{C}} = \\frac{\\log\\left(E_{h_1}\\left(g_{h_1}^{\\mathrm{C}}\\right)/E_{h_2}\\left(g_{h_2}^{\\mathrm{C}}\\right)\\right)}{\\log\\left(h_1/h_2\\right)},\\quad\np_{\\mathrm{L}} = \\frac{\\log\\left(E_{h_1}\\left(g_{h_1}^{\\mathrm{L}}\\right)/E_{h_2}\\left(g_{h_2}^{\\mathrm{L}}\\right)\\right)}{\\log\\left(h_1/h_2\\right)},\n$$\nwith $h$ taken as the maximum element length on the mesh.\n\n$5.$ Runs the following test suite of mesh families, each refined through the set of element counts $\\{40,80,160,320\\}$:\n\n- Test A (Uniform mesh): $x_i = i/N$ for $i=0,\\dots,N$.\n\n- Test B (Two-size alternating mesh): for a fixed ratio $R=4$, define consecutive element lengths alternating between $\\ell_{\\text{small}}=\\dfrac{2}{N(1+R)}$ and $\\ell_{\\text{large}}=\\dfrac{2R}{N(1+R)}$, repeated to fill $[0,1]$; this ensures $\\ell_{\\text{small}}+\\ell_{\\text{large}}=\\dfrac{2}{N}$ so that the total length is $1$.\n\n- Test C (Graded mesh): $x_i = \\left(\\dfrac{i}{N}\\right)^{p}$ with grading exponent $p=2.5$.\n\nFor each test, report the pair of estimated orders $\\left[p_{\\mathrm{C}}, p_{\\mathrm{L}}\\right]$ computed from the last two refinements, that is, between $N=160$ and $N=320$. All computations are dimensionless; no physical units are involved.\n\nYour program should produce a single line of output containing the results as a comma-separated list of three items, each item itself being a two-entry list of floats corresponding to $\\left[p_{\\mathrm{C}}, p_{\\mathrm{L}}\\right]$ for Tests A, B, and C, respectively. For example, the output format must be\n$$\n\\texttt{[[pC\\_A,pL\\_A],[pC\\_B,pL\\_B],[pC\\_C,pL\\_C]]}\n$$\nwith each float rounded to three decimal places.",
            "solution": "The user-provided problem is assessed as **valid**. It presents a well-defined numerical analysis task grounded in the established theory of the Finite Element Method (FEM). The problem is self-contained, scientifically sound, and objective. It specifies a scalar elliptic boundary value problem, a manufactured solution for verification, the choice of discretization ($P_2$ finite elements), and clear definitions for two distinct gradient recovery procedures ($R_h^{\\mathrm{C}}$ and $R_h^{\\mathrm{L}}$). The task is to implement this numerical scheme, compute the $L^2$ errors of the recovered gradients for three different families of meshes (uniform, alternating, and graded), and estimate the orders of convergence. All parameters, error metrics, and output formats are specified unambiguously.\n\nThe solution proceeds as follows:\n\n1.  **Analytical Forms**: The exact solution $u(x) = e^{x}\\,\\sin(k x)$ with $k=4\\pi$, its derivative $u'(x)$, and the corresponding forcing function $f(x) = -u''(x)$ are defined. These are used to construct the right-hand side of the linear system and to compute the final error against the true gradient.\n\n2.  **Finite Element Discretization**: A standard Galerkin FEM is implemented for the one-dimensional problem.\n    *   **Basis Functions**: Continuous piecewise quadratic ($P_2$) Lagrange basis functions are used. On a reference element $[-1, 1]$, these are $\\hat{\\phi}_0(\\xi) = \\frac{1}{2}(\\xi^2 - \\xi)$, $\\hat{\\phi}_1(\\xi) = 1 - \\xi^2$, and $\\hat{\\phi}_2(\\xi) = \\frac{1}{2}(\\xi^2 + \\xi)$. Their derivatives $\\hat{\\phi}_i'(\\xi)$ are also pre-defined.\n    *   **Mesh Generation**: Functions are created to generate the three required mesh types: uniform, two-size alternating, and graded. The nodes produced define the vertices of the elements. The full set of $P_2$ nodes includes the element midpoints.\n    *   **System Assembly**: The problem is discretized into a linear system $A \\mathbf{u} = \\mathbf{b}$.\n        *   The stiffness matrix $A_{ij} = \\int_0^1 \\psi_j'(x)\\psi_i'(x) dx$ is assembled element by element. The element stiffness matrix for a $P_2$ element of length $h_e$ is $A^e = \\frac{1}{3h_e} \\begin{pmatrix} 7  -8  1 \\\\ -8  16  -8 \\\\ 1  -8  7 \\end{pmatrix}$.\n        *   The load vector $b_i = \\int_0^1 f(x)\\psi_i(x) dx$ is also assembled element-wise. The integrals $\\int_{K_e} f(x)\\phi_i(x) dx$ are computed using a high-order (5-point) Gauss-Legendre quadrature rule to accurately handle the transcendental nature of $f(x)$.\n    *   **Boundary Conditions**: Homogeneous Dirichlet conditions $u(0)=0$ and $u(1)=0$ are enforced by solving for the interior degrees of freedom only, resulting in a system of size $(2N-1) \\times (2N-1)$ for a mesh with $N$ elements.\n    *   **Solution**: The resulting linear system is solved to obtain the coefficients $u_h$ of the discrete solution.\n\n3.  **Gradient Recovery**: The piecewise discontinuous FE gradient $u_h'$ is recovered into a continuous piecewise linear function using two methods.\n    *   **Lumped Recovery ($g_h^{\\mathrm{L}}$)**: The nodal values of the recovered gradient $g_h^{\\mathrm{L}} \\in V_h^{(1)}$ are computed directly using the explicit formula provided, which involves a weighted average of the one-sided limits of $u_h'$ at each mesh vertex.\n    *   **Consistent Recovery ($g_h^{\\mathrm{C}}$)**: This involves an $L^2$-projection of $u_h'$ onto the space of continuous piecewise linear functions, $V_h^{(1)}$. This requires solving another linear system $M \\mathbf{g} = \\mathbf{F}$, where $M$ is the standard $P_1$ mass matrix ($M_{ij} = \\int_0^1 \\chi_j(x)\\chi_i(x) dx$) and the right-hand side is $F_i = \\int_0^1 u_h'(x)\\chi_i(x) dx$. The integrals for $\\mathbf{F}$ are computed using 3-point Gaussian quadrature.\n\n4.  **Error Calculation and Convergence**:\n    *   The $L^2$ error, $E_h(g_h) = \\left(\\int_0^1 (g_h(x) - u'(x))^2 dx\\right)^{1/2}$, is computed for both recovered gradients. The integral is evaluated element-wise using 5-point Gaussian quadrature for accuracy.\n    *   The entire process is repeated for a sequence of refined meshes ($N=40, 80, 160, 320$).\n    *   The order of convergence is estimated using the results from the last two refinements ($N=160$ and $N=320$) via the formula $p = \\log(E_{h_1}/E_{h_2}) / \\log(h_1/h_2)$, where $h$ is the maximum element size on the mesh.\n\n5.  **Execution and Output**: The procedure is executed for each of the three test cases (Uniform, Alternating, Graded meshes). The final calculated convergence orders, $[p_{\\mathrm{C}}, p_{\\mathrm{L}}]$, for each test case are collected and formatted into the required single-line string output, with each value rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\n# --- Problem constants and exact solutions ---\nK_VAL = 4 * np.pi\n\ndef u_exact(x):\n    \"\"\"Computes the exact solution u(x).\"\"\"\n    return np.exp(x) * np.sin(K_VAL * x)\n\ndef u_prime_exact(x):\n    \"\"\"Computes the exact derivative u'(x).\"\"\"\n    return np.exp(x) * (np.sin(K_VAL * x) + K_VAL * np.cos(K_VAL * x))\n\ndef f_forcing(x):\n    \"\"\"Computes the forcing term f(x) = -u''(x).\"\"\"\n    return -np.exp(x) * ((1 - K_VAL**2) * np.sin(K_VAL * x) + 2 * K_VAL * np.cos(K_VAL * x))\n\n# --- P2 reference element details ---\n# P2 Lagrange basis functions on [-1, 1]\nphi_ref = [\n    lambda xi: 0.5 * xi * (xi - 1),\n    lambda xi: 1 - xi**2,\n    lambda xi: 0.5 * xi * (xi + 1)\n]\n# Their derivatives\nphi_prime_ref_vals = {\n    -1.0: np.array([-1.5, 2.0, -0.5]),\n     1.0: np.array([0.5, -2.0, 1.5])\n}\nphi_prime_ref = [\n    lambda xi: xi - 0.5,\n    lambda xi: -2 * xi,\n    lambda xi: xi + 0.5\n]\n\n# --- P1 reference element details ---\n# P1 Lagrange basis functions (hat functions) on [-1, 1]\nchi_ref = [\n    lambda xi: 0.5 * (1 - xi),\n    lambda xi: 0.5 * (1 + xi)\n]\n\n#--- MESH GENERATION ---\ndef generate_mesh_vertices(N, mesh_type, params):\n    \"\"\"Generates the vertex nodes for a given mesh type.\"\"\"\n    if mesh_type == 'uniform':\n        return np.linspace(0.0, 1.0, N + 1)\n    elif mesh_type == 'alternating':\n        R = params['R']\n        if N % 2 != 0:\n            raise ValueError(\"Alternating mesh requires an even number of elements N.\")\n        nodes = np.zeros(N + 1)\n        l_small = 2.0 / (N * (1.0 + R))\n        l_large = l_small * R\n        current_x = 0.0\n        for i in range(N // 2):\n            current_x += l_small\n            nodes[2 * i + 1] = current_x\n            current_x += l_large\n            nodes[2 * i + 2] = current_x\n        return nodes\n    elif mesh_type == 'graded':\n        p_grade = params['p']\n        return (np.linspace(0.0, 1.0, N + 1))**p_grade\n    else:\n        raise ValueError(f\"Unknown mesh type: {mesh_type}\")\n\n#--- CORE SOLVER ---\ndef solve_fem_and_recover(N, mesh_type, mesh_params):\n    \"\"\"\n    Performs the full FE solution, gradient recovery, and error computation for a single mesh.\n    \"\"\"\n    # 1. MESH and DOF SETUP\n    vertex_nodes = generate_mesh_vertices(N, mesh_type, mesh_params)\n    h_max = np.max(np.diff(vertex_nodes))\n    \n    # 2. ASSEMBLE P2 FEM SYSTEM\n    num_dofs = 2 * N - 1\n    A = np.zeros((num_dofs, num_dofs))\n    b = np.zeros(num_dofs)\n    \n    q_points, q_weights = np.polynomial.legendre.leggauss(5) # Quadrature for RHS\n    A_loc_stiff_const = (1.0/3.0) * np.array([[7, -8, 1], [-8, 16, -8], [1, -8, 7]], dtype=float)\n\n    for e in range(N):\n        x_start, x_end = vertex_nodes[e], vertex_nodes[e+1]\n        h_e = x_end - x_start\n        A_loc = (1.0 / h_e) * A_loc_stiff_const\n        \n        b_loc = np.zeros(3)\n        x_q = x_start + (h_e / 2.0) * (1.0 + q_points)\n        f_q = f_forcing(x_q)\n        for i in range(3):\n            phi_i_q = phi_ref[i](q_points)\n            b_loc[i] = (h_e / 2.0) * np.sum(q_weights * (f_q * phi_i_q))\n\n        for i_loc in range(3):\n            i_glob = 2 * e + i_loc\n            if 0  i_glob  2 * N:\n                dof_i = i_glob - 1\n                b[dof_i] += b_loc[i_loc]\n                for j_loc in range(3):\n                    j_glob = 2 * e + j_loc\n                    if 0  j_glob  2 * N:\n                        dof_j = j_glob - 1\n                        A[dof_i, dof_j] += A_loc[i_loc, j_loc]\n\n    # 3. SOLVE\n    u_dofs = linalg.solve(A, b, assume_a='sym')\n    u_h_coeffs = np.concatenate(([0.0], u_dofs, [0.0]))\n\n    # 4. GRADIENT RECOVERY\n    # 4.1 Lumped Recovery\n    gL_vals = np.zeros(N + 1)\n    if N > 0:\n        h0 = vertex_nodes[1] - vertex_nodes[0]\n        grad_at_0_plus = (2.0/h0) * np.dot(u_h_coeffs[0:3], phi_prime_ref_vals[-1.0])\n        gL_vals[0] = grad_at_0_plus\n\n        h_last = vertex_nodes[N] - vertex_nodes[N-1]\n        grad_at_1_minus = (2.0/h_last) * np.dot(u_h_coeffs[2*N-2:2*N+1], phi_prime_ref_vals[1.0])\n        gL_vals[N] = grad_at_1_minus\n    \n    for i in range(1, N):\n        h_left = vertex_nodes[i] - vertex_nodes[i-1]\n        h_right = vertex_nodes[i+1] - vertex_nodes[i]\n        \n        grad_left = (2.0/h_left) * np.dot(u_h_coeffs[2*i-2:2*i+1], phi_prime_ref_vals[1.0])\n        grad_right = (2.0/h_right) * np.dot(u_h_coeffs[2*i:2*i+3], phi_prime_ref_vals[-1.0])\n\n        gL_vals[i] = (h_left * grad_left + h_right * grad_right) / (h_left + h_right)\n\n    # 4.2 Consistent Recovery\n    num_p1_nodes = N + 1\n    M_p1 = np.zeros((num_p1_nodes, num_p1_nodes))\n    F_p1 = np.zeros(num_p1_nodes)\n    \n    q_points_rec, q_weights_rec = np.polynomial.legendre.leggauss(3)\n\n    for e in range(N):\n        x_start, x_end = vertex_nodes[e], vertex_nodes[e+1]\n        h_e = x_end - x_start\n        \n        M_p1[e:e+2, e:e+2] += (h_e / 6.0) * np.array([[2, 1], [1, 2]])\n\n        F_loc = np.zeros(2)\n        x_q_rec = x_start + (h_e / 2.0) * (1 + q_points_rec)\n        \n        u_h_prime_q = np.zeros_like(q_points_rec)\n        for i_loc in range(3):\n            u_h_prime_q += u_h_coeffs[2*e + i_loc] * phi_prime_ref[i_loc](q_points_rec)\n        u_h_prime_q *= (2.0 / h_e)\n\n        for i_loc in range(2):\n            chi_i_q = chi_ref[i_loc](q_points_rec)\n            F_loc[i_loc] = (h_e / 2.0) * np.sum(q_weights_rec * (u_h_prime_q * chi_i_q))\n        \n        F_p1[e:e+2] += F_loc\n        \n    gC_vals = linalg.solve(M_p1, F_p1, assume_a='sym')\n\n    # 5. COMPUTE L2 ERRORS\n    err_L_sq, err_C_sq = 0.0, 0.0\n    for e in range(N):\n        x_start, x_end = vertex_nodes[e], vertex_nodes[e+1]\n        h_e = x_end - x_start\n        \n        gL_node_vals = gL_vals[e:e+2]\n        gC_node_vals = gC_vals[e:e+2]\n       \n        x_q = x_start + (h_e / 2.0) * (1.0 + q_points)\n        \n        gL_q = gL_node_vals[0] * chi_ref[0](q_points) + gL_node_vals[1] * chi_ref[1](q_points)\n        gC_q = gC_node_vals[0] * chi_ref[0](q_points) + gC_node_vals[1] * chi_ref[1](q_points)\n        \n        u_prime_q = u_prime_exact(x_q)\n        \n        err_L_sq += (h_e / 2.0) * np.sum(q_weights * (gL_q - u_prime_q)**2)\n        err_C_sq += (h_e / 2.0) * np.sum(q_weights * (gC_q - u_prime_q)**2)\n\n    return h_max, np.sqrt(err_C_sq), np.sqrt(err_L_sq)\n\ndef run_test_suite(mesh_type, mesh_params=None):\n    \"\"\"Runs a full convergence study for a given mesh family.\"\"\"\n    N_values = [40, 80, 160, 320]\n    h_list, err_C_list, err_L_list = [], [], []\n\n    for N in N_values:\n        h, err_C, err_L = solve_fem_and_recover(N, mesh_type, mesh_params)\n        h_list.append(h)\n        err_C_list.append(err_C)\n        err_L_list.append(err_L)\n\n    p_C = np.log(err_C_list[-2] / err_C_list[-1]) / np.log(h_list[-2] / h_list[-1])\n    p_L = np.log(err_L_list[-2] / err_L_list[-1]) / np.log(h_list[-2] / h_list[-1])\n    \n    return [p_C, p_L]\n\ndef solve():\n    \"\"\"Main function to run all test cases and print the results.\"\"\"\n    test_cases = [\n        {'type': 'uniform', 'params': {}},\n        {'type': 'alternating', 'params': {'R': 4.0}},\n        {'type': 'graded', 'params': {'p': 2.5}}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_test_suite(case['type'], case['params'])\n        all_results.append(result)\n\n    # Format the final output string\n    formatted_pairs = []\n    for pair in all_results:\n        pC_str = f\"{pair[0]:.3f}\"\n        pL_str = f\"{pair[1]:.3f}\"\n        formatted_pairs.append(f\"[{pC_str},{pL_str}]\")\n        \n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```"
        }
    ]
}