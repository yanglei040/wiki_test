{
    "hands_on_practices": [
        {
            "introduction": "Transitioning from the abstract weak formulation to a computational implementation requires understanding how the continuous problem maps onto discrete data structures. This exercise guides you through a fundamental analysis of the mass and stiffness matrices, $M$ and $K$, that form the heart of the semi-discrete system. By modeling the mesh as a planar graph, you will use combinatorial arguments to predict the sparsity pattern of these matrices and estimate the computational cost of a simulation, a crucial first step in designing efficient numerical solvers .",
            "id": "3441976",
            "problem": "Consider the heat equation, a parabolic partial differential equation (PDE), on a bounded polygonal domain $\\Omega \\subset \\mathbb{R}^{2}$, given by $u_{t} - \\nabla \\cdot (\\kappa \\nabla u) = f$ with homogeneous Dirichlet boundary conditions, where $\\kappa$ is a uniformly positive conductivity. Using the standard Galerkin approach in the Finite Element Method (FEM), let the trial and test spaces be the conforming Lagrange piecewise linear ($P_{1}$) space on a quasi-uniform, shape-regular triangulation of $\\Omega$ with $N$ global nodes. Denote by $\\{\\varphi_{i}\\}_{i=1}^{N}$ the nodal basis functions. The semi-discrete spatial approximation leads to the matrix ordinary differential equation $M \\dot{U}(t) + K U(t) = F(t)$, where $U(t) \\in \\mathbb{R}^{N}$ collects the nodal values, $M \\in \\mathbb{R}^{N \\times N}$ is the (consistent) mass matrix with entries $M_{ij} = \\int_{\\Omega} \\varphi_{i} \\varphi_{j} \\,d\\boldsymbol{x}$, and $K \\in \\mathbb{R}^{N \\times N}$ is the stiffness matrix with entries $K_{ij} = \\int_{\\Omega} \\kappa \\,\\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j} \\,d\\boldsymbol{x}$. Do not use mass lumping; assume the consistent mass matrix.\n\nStarting from the weak formulation and the definition of the Galerkin method, argue from first principles why the sparsity of $M$ and $K$ is governed by the mesh adjacency induced by the local support of $\\{\\varphi_{i}\\}$. Use planar graph combinatorics valid for triangulations and the quasi-uniformity assumption to bound and then estimate the average vertex degree in the mesh. Based on this, determine the leading-order total number of nonzero entries in $M$ and $K$ in terms of $N$. Then, discuss the arithmetic complexity (as a function of $N$) of assembling $M$ and $K$ from element contributions and of applying $M$ or $K$ to a vector via a matrix-vector product, stating any constants you identify and how they arise.\n\nProvide your final answer as the single leading-order estimate, in terms of $N$, for the total number of nonzeros of $M$ (which equals that of $K$ under the given assumptions). No rounding is required. Express your final answer in a closed-form analytic expression.",
            "solution": "The problem as stated is a standard exercise in the numerical analysis of partial differential equations using the Finite Element Method (FEM). A validation of its premises is performed first.\n\n### Step 1: Extract Givens\n- **PDE**: $u_{t} - \\nabla \\cdot (\\kappa \\nabla u) = f$\n- **Domain**: $\\Omega$, a bounded polygonal domain in $\\mathbb{R}^{2}$.\n- **Boundary Conditions**: Homogeneous Dirichlet boundary conditions on $\\partial \\Omega$.\n- **Conductivity**: $\\kappa$ is a uniformly positive function.\n- **Discretization Method**: Standard Galerkin FEM.\n- **FE Space**: Conforming Lagrange piecewise linear ($P_{1}$) space.\n- **Mesh**: Quasi-uniform, shape-regular triangulation of $\\Omega$.\n- **Nodes/Degrees of Freedom**: $N$ global nodes.\n- **Basis Functions**: Nodal basis functions $\\{\\varphi_{i}\\}_{i=1}^{N}$.\n- **Semi-discrete System**: $M \\dot{U}(t) + K U(t) = F(t)$.\n- **Mass Matrix**: Consistent mass matrix, $M \\in \\mathbb{R}^{N \\times N}$, with entries $M_{ij} = \\int_{\\Omega} \\varphi_{i} \\varphi_{j} \\,d\\boldsymbol{x}$.\n- **Stiffness Matrix**: $K \\in \\mathbb{R}^{N \\times N}$, with entries $K_{ij} = \\int_{\\Omega} \\kappa \\,\\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j} \\,d\\boldsymbol{x}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes the standard FEM semi-discretization of the heat equation, a fundamental parabolic PDE. All concepts (Galerkin method, $P_{1}$ elements, mass/stiffness matrices) are cornerstones of computational mathematics and engineering. The setup is scientifically and mathematically sound.\n- **Well-Posed**: The problem asks for an analysis of matrix sparsity and computational complexity, which is a well-defined theoretical question with a unique logical path to the answer based on the provided setup.\n- **Objective**: The problem statement uses precise, standard terminology from numerical analysis and is free of subjective or ambiguous language.\n- **Completeness**: All necessary information is provided to analyze the structure of the matrices M and K based on the underlying mesh topology. Assumptions like quasi-uniformity and shape-regularity are standard and necessary for the asymptotic analysis requested.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-posed, scientifically grounded, and objective question from the field of numerical analysis. I will proceed with the solution.\n\n### Derivation\nThe core of the problem lies in understanding how the local nature of the finite element basis functions translates into a sparse matrix structure for the global system.\n\n**Sparsity of M and K from First Principles**\n\nThe entries of the mass matrix $M$ and stiffness matrix $K$ are given by $M_{ij} = \\int_{\\Omega} \\varphi_{i} \\varphi_{j} \\,d\\boldsymbol{x}$ and $K_{ij} = \\int_{\\Omega} \\kappa \\,\\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j} \\,d\\boldsymbol{x}$, respectively. A matrix entry $(i, j)$ is non-zero only if the integrand is not identically zero over the domain $\\Omega$.\n\nThe basis functions $\\{\\varphi_{i}\\}_{i=1}^{N}$ are the standard $P_{1}$ nodal basis functions. By definition, the basis function $\\varphi_i$ associated with node $i$ (with position vector $\\vec{x}_i$) has the property that $\\varphi_{i}(\\vec{x}_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta. Geometrically, $\\varphi_i$ is a \"tent\" function that is equal to $1$ at node $i$ and decays linearly to $0$ at all adjacent nodes. The support of $\\varphi_i$, denoted $\\text{supp}(\\varphi_i)$, is the set of points where $\\varphi_i$ is non-zero. For a $P_1$ element, this corresponds to the union of all triangles (elements) that have node $i$ as a vertex. This region is often called the \"star\" of node $i$.\n\nThe integrand for $M_{ij}$, which is $\\varphi_{i} \\varphi_{j}$, is non-zero only on the intersection of the supports, $\\text{supp}(\\varphi_i) \\cap \\text{supp}(\\varphi_j)$. This intersection is non-empty if and only if there is at least one triangle in the mesh that contains both node $i$ and node $j$ as vertices. In a valid triangulation, two distinct nodes $i$ and $j$ can be vertices of the same triangle only if they are directly connected by an edge of the mesh.\nTherefore, $M_{ij} \\neq 0$ if and only if:\n$1$. $i = j$ (the diagonal entries, as $\\varphi_i^2 > 0$ on $\\text{supp}(\\varphi_i)$).\n$2$. Node $i$ and node $j$ are connected by an edge in the triangulation.\n\nThe same logic applies to the stiffness matrix entry $K_{ij}$. The integrand $\\kappa \\nabla \\varphi_{i} \\cdot \\nabla \\varphi_{j}$ is non-zero only where both $\\nabla\\varphi_i$ and $\\nabla\\varphi_j$ can be non-zero. Since $\\nabla\\varphi_i$ is a piecewise constant vector, non-zero only on $\\text{supp}(\\varphi_i)$, the integrand is non-zero only on $\\text{supp}(\\varphi_i) \\cap \\text{supp}(\\varphi_j)$. Thus, the sparsity pattern of $K$ is identical to that of $M$. Both matrices represent the adjacency structure of the mesh graph.\n\n**Planar Graph Combinatorics and Average Degree**\n\nWe model the mesh as a planar graph where vertices are the nodes, and edges are the connections between them. Let $N$, $E$, and $F$ be the number of vertices, edges, and faces (triangles) in the graph, respectively. The problem specifies $N$ global nodes, so $V=N$.\n\nThere is a fundamental relationship between the number of edges and faces in a triangulation. Each triangle is bounded by $3$ edges. Every internal edge is shared by exactly $2$ triangles, while every boundary edge belongs to only $1$ triangle. Let $E_{int}$ be the number of internal edges and $E_{bnd}$ be the number of boundary edges. Summing the edges over all triangles gives $3F = 2E_{int} + E_{bnd}$.\nSince $E = E_{int} + E_{bnd}$, we can write $E_{int} = E - E_{bnd}$. Substituting this gives $3F = 2(E - E_{bnd}) + E_{bnd} = 2E - E_{bnd}$.\n\nFor a connected planar graph representing a domain with one hole (the exterior), Euler's formula is $V - E + F = 1$. Substituting $V=N$ and $F = (2E - E_{bnd})/3$, we get:\n$N - E + \\frac{2E - E_{bnd}}{3} = 1$\n$3N - 3E + 2E - E_{bnd} = 3$\n$3N - E - E_{bnd} = 3 \\implies E = 3N - E_{bnd} - 3$.\n\nFor a large mesh ($N \\to \\infty$) of a compact domain, the number of boundary edges $E_{bnd}$ is asymptotically negligible compared to the total number of nodes $N$ (i.e., $E_{bnd}/N \\to 0$). The quasi-uniformity assumption ensures this behavior. Therefore, for large $N$, we have the asymptotic relationship $E \\approx 3N$.\n\nThe sum of the degrees of all vertices in any graph is twice the number of edges: $\\sum_{i=1}^{N} \\deg(v_i) = 2E$. The average vertex degree $\\bar{d}$ is then:\n$\\bar{d} = \\frac{1}{N} \\sum_{i=1}^{N} \\deg(v_i) = \\frac{2E}{N}$.\nUsing the asymptotic result $E \\approx 3N$, we find the average degree:\n$\\bar{d} \\approx \\frac{2(3N)}{N} = 6$.\nThis confirms that, on average, each node in a large triangulation is connected to $6$ other nodes.\n\n**Total Number of Non-zero Entries**\n\nThe number of non-zero entries in a matrix, let's call it $\\text{nnz}$, can be determined from the sparsity pattern. For a matrix like $M$ or $K$, whose sparsity is defined by the mesh adjacency, the non-zero entries in row $i$ correspond to the diagonal element $M_{ii}$ and the off-diagonal elements $M_{ij}$ where node $j$ is a neighbor of node $i$. The number of such neighbors is $\\deg(v_i)$.\nThus, the number of non-zero entries in row $i$ is $1 + \\deg(v_i)$.\n\nThe total number of non-zero entries, $\\text{nnz}(M)$, is the sum of the non-zeros over all rows:\n$\\text{nnz}(M) = \\sum_{i=1}^{N} (1 + \\deg(v_i)) = N + \\sum_{i=1}^{N} \\deg(v_i)$.\nUsing the identity $\\sum_{i=1}^{N} \\deg(v_i) = 2E$, we have:\n$\\text{nnz}(M) = N + 2E$.\n\nNow, we substitute the asymptotic relationship $E \\approx 3N - E_{bnd} - 3$:\n$\\text{nnz}(M) \\approx N + 2(3N - E_{bnd} - 3) = N + 6N - 2E_{bnd} - 6 = 7N - 2E_{bnd} - 6$.\nThe leading-order term of this expression as $N \\to \\infty$ is $7N$. The terms involving the boundary and the constant are lower-order.\n\n**Arithmetic Complexity**\n\n- **Assembly of M and K**: The assembly process iterates over the $F$ triangles in the mesh. For each triangle, it computes a local $3 \\times 3$ matrix ($M^k$ or $K^k$) and adds its $3^2=9$ entries to the global matrices $M$ and $K$. For $P_1$ elements, the cost of computing the local matrix entries is constant, independent of $N$ or the specific triangle's geometry (assuming $\\kappa$ is simple). Since the number of triangles $F$ is asymptotically related to $N$ ($F \\approx 2N$ from $3F \\approx 2E$ and $E \\approx 3N$), the total assembly cost is proportional to the number of elements. Thus, the arithmetic complexity of assembling $M$ or $K$ is $O(F) = O(N)$.\n\n- **Matrix-Vector Product**: The complexity of applying $M$ or $K$ to a vector (a mat-vec operation, e.g., $y = Mv$) is proportional to the number of non-zero entries in the matrix. Each non-zero entry $M_{ij}$ corresponds to one multiplication ($M_{ij} v_j$) and one addition. Since $\\text{nnz}(M) \\approx 7N$, the total number of arithmetic operations for a matrix-vector product is also proportional to $N$. The complexity is $O(\\text{nnz}(M)) = O(N)$. The constant factor is approximately $7$, as each row has, on average, $7$ non-zero entries.\n\n**Final Answer Calculation**\n\nThe question asks for the leading-order estimate for the total number of non-zeros of $M$ (or $K$) in terms of $N$. As derived from graph-theoretic properties of the triangulation and the local support of the basis functions, the total number of non-zero entries is $\\text{nnz}(M) = N+2E$. Using the asymptotic relation $E \\approx 3N$ for a large mesh, we find $\\text{nnz}(M) \\approx N+2(3N) = 7N$.",
            "answer": "$$\\boxed{7N}$$"
        },
        {
            "introduction": "A correct numerical scheme should do more than just approximate the solution; it should also preserve the fundamental physical properties of the governing equation. This practice explores the Discrete Maximum Principle (DMP), a key property for parabolic problems, and demonstrates how it can be compromised by poor mesh quality. Through a direct calculation on a carefully constructed mesh with an obtuse angle, you will see how the geometry of the elements directly influences the sign pattern of the stiffness matrix $\\boldsymbol{K}$, providing a critical insight into the conditions required for a physically meaningful numerical solution .",
            "id": "3441983",
            "problem": "Consider the heat equation semi-discretized in space by the Finite Element Method (FEM) with continuous, piecewise linear basis functions (also called $P_{1}$ elements). The spatial bilinear form is $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x}$, and the stiffness matrix $\\boldsymbol{K}$ is defined by $K_{ij} = a(\\varphi_{j},\\varphi_{i})$ for the global nodal basis $\\{\\varphi_{i}\\}$. It is known that a necessary condition for the Discrete Maximum Principle (DMP) in the semi-discrete method-of-lines system $\\boldsymbol{M} \\,\\dot{\\boldsymbol{u}} + \\boldsymbol{K} \\boldsymbol{u} = \\boldsymbol{f}$ is that $\\boldsymbol{K}$ has nonpositive off-diagonal entries (an $M$-matrix sign pattern).\n\nConstruct a counterexample patch showing failure of this sign condition as follows. Let the domain $\\Omega$ be the union of two triangles sharing the edge between nodes at coordinates $\\boldsymbol{p}_{1} = (0,0)$ and $\\boldsymbol{p}_{2} = (1,0)$:\n- Triangle $\\mathcal{T}_{1}$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{3} = \\left(\\tfrac{1}{2}, \\tfrac{1}{10}\\right)$.\n- Triangle $\\mathcal{T}_{2}$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{4} = \\left(\\tfrac{1}{2}, -\\tfrac{1}{4}\\right)$.\n\nOn this mesh, using $P_{1}$ basis functions, compute the assembled off-diagonal stiffness entry $K_{12} = \\sum_{\\mathcal{T} \\in \\{\\mathcal{T}_{1},\\mathcal{T}_{2}\\}} \\int_{\\mathcal{T}} \\nabla \\varphi_{2} \\cdot \\nabla \\varphi_{1} \\, d\\boldsymbol{x}$. Provide the exact value of $K_{12}$ as a single simplified real number. No rounding is required.\n\nThen, briefly explain whether the sign of $K_{12}$ is compatible with the nonpositivity requirement for the off-diagonal entries of $\\boldsymbol{K}$ associated with the Discrete Maximum Principle (DMP) in the semi-discretized parabolic problem.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It presents a standard exercise in the numerical analysis of partial differential equations using the Finite Element Method (FEM).\n\nThe objective is to compute the off-diagonal entry $K_{12}$ of the global stiffness matrix $\\boldsymbol{K}$, which is assembled from the local contributions of the two triangles, $\\mathcal{T}_{1}$ and $\\mathcal{T}_{2}$, that share the edge connecting nodes $1$ and $2$. The definition of $K_{ij}$ is given by $K_{ij} = a(\\varphi_j, \\varphi_i)$, where $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x}$ and $\\{\\varphi_i\\}$ are the $P_1$ nodal basis functions.\n\nThe assembled stiffness entry $K_{12}$ is the sum of the local stiffness entries from each triangle sharing the edge between nodes $1$ and $2$:\n$$\nK_{12} = K_{12}^{\\mathcal{T}_1} + K_{12}^{\\mathcal{T}_2} = \\int_{\\mathcal{T}_1} \\nabla \\varphi_2 \\cdot \\nabla \\varphi_1 \\, d\\boldsymbol{x} + \\int_{\\mathcal{T}_2} \\nabla \\varphi_2 \\cdot \\nabla \\varphi_1 \\, d\\boldsymbol{x}\n$$\nFor a triangular element $\\mathcal{T}$ with vertices $\\boldsymbol{p}_i, \\boldsymbol{p}_j, \\boldsymbol{p}_k$, the local stiffness matrix entry $K_{ij}^{\\mathcal{T}}$ is given by the well-known formula:\n$$\nK_{ij}^{\\mathcal{T}} = -\\frac{1}{2} \\cot(\\theta_k)\n$$\nwhere $\\theta_k$ is the interior angle of the triangle at the vertex $\\boldsymbol{p}_k$ opposite the edge connecting $\\boldsymbol{p}_i$ and $\\boldsymbol{p}_j$.\n\nIn our problem, we need to compute $K_{12}$. The edge connecting nodes $1$ and $2$ is common to both triangles $\\mathcal{T}_1$ and $\\mathcal{T}_2$.\nFor triangle $\\mathcal{T}_1$, with vertices $\\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_3$, the vertex opposite the edge $\\boldsymbol{p}_1\\boldsymbol{p}_2$ is $\\boldsymbol{p}_3$. Let $\\theta_3$ be the angle at $\\boldsymbol{p}_3$.\nFor triangle $\\mathcal{T}_2$, with vertices $\\boldsymbol{p}_1, \\boldsymbol{p}_2, \\boldsymbol{p}_4$, the vertex opposite the edge $\\boldsymbol{p}_1\\boldsymbol{p}_2$ is $\\boldsymbol{p}_4$. Let $\\theta_4$ be the angle at $\\boldsymbol{p}_4$.\n\nThus, the global stiffness entry is:\n$$\nK_{12} = K_{12}^{\\mathcal{T}_1} + K_{12}^{\\mathcal{T}_2} = -\\frac{1}{2} \\cot(\\theta_3) - \\frac{1}{2} \\cot(\\theta_4)\n$$\n\nWe proceed to calculate $\\cot(\\theta_3)$ and $\\cot(\\theta_4)$.\n\nFirst, for triangle $\\mathcal{T}_1$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{3} = \\left(\\frac{1}{2}, \\frac{1}{10}\\right)$.\nThe angle $\\theta_3$ is the angle between the vectors $\\boldsymbol{v}_{31} = \\boldsymbol{p}_1 - \\boldsymbol{p}_3$ and $\\boldsymbol{v}_{32} = \\boldsymbol{p}_2 - \\boldsymbol{p}_3$.\n$$\n\\boldsymbol{v}_{31} = (0,0) - \\left(\\frac{1}{2}, \\frac{1}{10}\\right) = \\left(-\\frac{1}{2}, -\\frac{1}{10}\\right)\n$$\n$$\n\\boldsymbol{v}_{32} = (1,0) - \\left(\\frac{1}{2}, \\frac{1}{10}\\right) = \\left(\\frac{1}{2}, -\\frac{1}{10}\\right)\n$$\nThe dot product is:\n$$\n\\boldsymbol{v}_{31} \\cdot \\boldsymbol{v}_{32} = \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(-\\frac{1}{10}\\right)\\left(-\\frac{1}{10}\\right) = -\\frac{1}{4} + \\frac{1}{100} = -\\frac{25}{100} + \\frac{1}{100} = -\\frac{24}{100} = -\\frac{6}{25}\n$$\nThe magnitudes squared are:\n$$\n|\\boldsymbol{v}_{31}|^2 = \\left(-\\frac{1}{2}\\right)^2 + \\left(-\\frac{1}{10}\\right)^2 = \\frac{1}{4} + \\frac{1}{100} = \\frac{26}{100}\n$$\n$$\n|\\boldsymbol{v}_{32}|^2 = \\left(\\frac{1}{2}\\right)^2 + \\left(-\\frac{1}{10}\\right)^2 = \\frac{1}{4} + \\frac{1}{100} = \\frac{26}{100}\n$$\nSo, $|\\boldsymbol{v}_{31}| = |\\boldsymbol{v}_{32}| = \\frac{\\sqrt{26}}{10}$.\nThe cosine of the angle $\\theta_3$ is:\n$$\n\\cos(\\theta_3) = \\frac{\\boldsymbol{v}_{31} \\cdot \\boldsymbol{v}_{32}}{|\\boldsymbol{v}_{31}| |\\boldsymbol{v}_{32}|} = \\frac{-6/25}{26/100} = -\\frac{6}{25} \\cdot \\frac{100}{26} = -\\frac{6 \\cdot 4}{26} = -\\frac{12}{13}\n$$\nSince $\\theta_3$ is an angle in a triangle, $0 < \\theta_3 < \\pi$, so $\\sin(\\theta_3) > 0$.\n$$\n\\sin(\\theta_3) = \\sqrt{1 - \\cos^2(\\theta_3)} = \\sqrt{1 - \\left(-\\frac{12}{13}\\right)^2} = \\sqrt{1 - \\frac{144}{169}} = \\sqrt{\\frac{25}{169}} = \\frac{5}{13}\n$$\nThe cotangent is:\n$$\n\\cot(\\theta_3) = \\frac{\\cos(\\theta_3)}{\\sin(\\theta_3)} = \\frac{-12/13}{5/13} = -\\frac{12}{5}\n$$\nSince $\\cot(\\theta_3)$ is negative, the angle $\\theta_3$ is obtuse.\n\nSecond, for triangle $\\mathcal{T}_2$ with vertices $\\boldsymbol{p}_{1} = (0,0)$, $\\boldsymbol{p}_{2} = (1,0)$, and $\\boldsymbol{p}_{4} = \\left(\\frac{1}{2}, -\\frac{1}{4}\\right)$.\nThe angle $\\theta_4$ is the angle between the vectors $\\boldsymbol{v}_{41} = \\boldsymbol{p}_1 - \\boldsymbol{p}_4$ and $\\boldsymbol{v}_{42} = \\boldsymbol{p}_2 - \\boldsymbol{p}_4$.\n$$\n\\boldsymbol{v}_{41} = (0,0) - \\left(\\frac{1}{2}, -\\frac{1}{4}\\right) = \\left(-\\frac{1}{2}, \\frac{1}{4}\\right)\n$$\n$$\n\\boldsymbol{v}_{42} = (1,0) - \\left(\\frac{1}{2}, -\\frac{1}{4}\\right) = \\left(\\frac{1}{2}, \\frac{1}{4}\\right)\n$$\nThe dot product is:\n$$\n\\boldsymbol{v}_{41} \\cdot \\boldsymbol{v}_{42} = \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{4}\\right) = -\\frac{1}{4} + \\frac{1}{16} = -\\frac{4}{16} + \\frac{1}{16} = -\\frac{3}{16}\n$$\nThe magnitudes squared are:\n$$\n|\\boldsymbol{v}_{41}|^2 = \\left(-\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{4}\\right)^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}\n$$\n$$\n|\\boldsymbol{v}_{42}|^2 = \\left(\\frac{1}{2}\\right)^2 + \\left(\\frac{1}{4}\\right)^2 = \\frac{1}{4} + \\frac{1}{16} = \\frac{5}{16}\n$$\nSo, $|\\boldsymbol{v}_{41}| = |\\boldsymbol{v}_{42}| = \\frac{\\sqrt{5}}{4}$.\nThe cosine of the angle $\\theta_4$ is:\n$$\n\\cos(\\theta_4) = \\frac{\\boldsymbol{v}_{41} \\cdot \\boldsymbol{v}_{42}}{|\\boldsymbol{v}_{41}| |\\boldsymbol{v}_{42}|} = \\frac{-3/16}{5/16} = -\\frac{3}{5}\n$$\n$$\n\\sin(\\theta_4) = \\sqrt{1 - \\cos^2(\\theta_4)} = \\sqrt{1 - \\left(-\\frac{3}{5}\\right)^2} = \\sqrt{1 - \\frac{9}{25}} = \\sqrt{\\frac{16}{25}} = \\frac{4}{5}\n$$\nThe cotangent is:\n$$\n\\cot(\\theta_4) = \\frac{\\cos(\\theta_4)}{\\sin(\\theta_4)} = \\frac{-3/5}{4/5} = -\\frac{3}{4}\n$$\nSince $\\cot(\\theta_4)$ is negative, the angle $\\theta_4$ is also obtuse.\n\nFinally, we assemble the value of $K_{12}$:\n$$\nK_{12} = -\\frac{1}{2} \\cot(\\theta_3) - \\frac{1}{2} \\cot(\\theta_4) = -\\frac{1}{2}\\left(-\\frac{12}{5}\\right) - \\frac{1}{2}\\left(-\\frac{3}{4}\\right)\n$$\n$$\nK_{12} = \\frac{12}{10} + \\frac{3}{8} = \\frac{6}{5} + \\frac{3}{8}\n$$\n$$\nK_{12} = \\frac{6 \\cdot 8}{40} + \\frac{3 \\cdot 5}{40} = \\frac{48 + 15}{40} = \\frac{63}{40}\n$$\nThe computed value is $K_{12} = \\frac{63}{40}$, which is a positive number.\n\nThe Discrete Maximum Principle (DMP) for the semi-discrete system requires, as a necessary condition, that the stiffness matrix $\\boldsymbol{K}$ is an $M$-matrix. A property of an $M$-matrix is that all its off-diagonal entries are nonpositive, i.e., $K_{ij} \\le 0$ for all $i \\neq j$.\nOur calculation for the given mesh yields $K_{12} = \\frac{63}{40} > 0$. This violates the nonpositivity condition. Therefore, the sign of $K_{12}$ is not compatible with the requirement for the DMP. This example demonstrates that triangulations containing obtuse angles can lead to a stiffness matrix that is not an $M$-matrix, and thus the DMP is not guaranteed.",
            "answer": "$$\n\\boxed{\\frac{63}{40}}\n$$"
        },
        {
            "introduction": "The ultimate validation of a numerical method lies in its implementation and verification against a known truth. This programming practice walks you through the gold-standard procedure for code verification: the Method of Manufactured Solutions (MMS). You will build a complete 1D FEM solver for the heat equation, from assembling the semi-discrete system to integrating it in time, and then rigorously test its accuracy by comparing it against a non-trivial, manufactured exact solution. This capstone exercise solidifies theoretical concepts and equips you with the essential skills to develop reliable scientific software .",
            "id": "3442012",
            "problem": "Design and implement a program that verifies a semi-discrete Finite Element Method (FEM) for a parabolic Partial Differential Equation (PDE) using the method of manufactured solutions. Work in one space dimension on the open interval $\\left(0, 1\\right)$ and on the time interval $\\left(0, T\\right]$. Consider the linear heat equation with a source term\n$$\nu_t - \\left(k\\, u_x\\right)_x = s \\quad \\text{in } \\left(0, 1\\right)\\times\\left(0, T\\right],\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu\\left(0, t\\right) = 0,\\quad u\\left(1, t\\right) = 0 \\quad \\text{for } t \\in \\left[0, T\\right],\n$$\nand initial condition\n$$\nu\\left(x, 0\\right) = u_0\\left(x\\right) \\quad \\text{for } x \\in \\left[0, 1\\right].\n$$\nSet the diffusion coefficient to the constant $k\\left(x\\right) = 1$. Use a Galerkin semi-discretization in space with continuous, piecewise linear basis functions on a uniform mesh with $N$ intervals, leading to a system of ordinary differential equations in time. Denote the piecewise linear basis by $\\left\\{\\varphi_i\\right\\}_{i=0}^{N}$ associated with the nodes $x_i = i\\,h$, where $h = 1/N$ and $i \\in \\left\\{0, 1, \\dots, N\\right\\}$. The semi-discrete solution is sought in the finite dimensional space $V_h = \\text{span}\\left\\{\\varphi_i\\right\\}_{i=1}^{N-1}$ due to the homogeneous Dirichlet boundary conditions.\n\nStart from the weak form obtained by multiplying the PDE by a test function $v \\in H_0^1\\left(0, 1\\right)$ and integrating over the spatial domain. Derive the method-of-lines semi-discrete system in the matrix form\n$$\nM\\, \\dot{\\mathbf{U}}\\left(t\\right) + K\\, \\mathbf{U}\\left(t\\right) = \\mathbf{F}\\left(t\\right),\n$$\nwhere $M$ is the mass matrix with entries $M_{ij} = \\int_0^1 \\varphi_i \\varphi_j \\, dx$, $K$ is the stiffness matrix with entries $K_{ij} = \\int_0^1 \\varphi_i' \\varphi_j' \\, dx$, $\\mathbf{U}\\left(t\\right)$ collects the nodal values of the semi-discrete solution at the interior nodes, and $\\mathbf{F}\\left(t\\right)$ is the load vector with entries $F_i\\left(t\\right) = \\int_0^1 s\\left(x, t\\right)\\, \\varphi_i\\left(x\\right)\\, dx$. Do not use mass lumping. Use the exact, consistent mass matrix.\n\nVerification by manufactured solutions. For each manufactured exact solution below, define the corresponding source $s\\left(x, t\\right)$ by substituting the exact solution into the PDE with $k\\left(x\\right) = 1$ and rearranging. Use the exact initial condition $u_0\\left(x\\right) = u\\left(x, 0\\right)$ and impose homogeneous Dirichlet boundary conditions $u\\left(0, t\\right) = u\\left(1, t\\right) = 0$. The manufactured exact solutions are:\n- Manufactured A: $u_A\\left(x, t\\right) = \\sin\\left(\\pi x\\right)\\, e^{-t}$.\n- Manufactured B: $u_B\\left(x, t\\right) = x\\left(1-x\\right) \\cos\\left(2 t\\right)$.\n\nYour program must:\n- Assemble $M$ and $K$ from first principles based on the bilinear forms stated above on the uniform mesh with $N$ intervals.\n- Construct $\\mathbf{F}\\left(t\\right)$ for each $t$ by numerically integrating the given $s\\left(x, t\\right)$ against basis functions using a Gaussian quadrature rule sufficiently accurate to make the spatial discretization error dominant over the quadrature error.\n- Eliminate the boundary degrees of freedom to enforce the homogeneous Dirichlet boundary conditions strongly, yielding the system for the interior unknowns.\n- Evolve the semi-discrete system in time from $t = 0$ to $t = T$ using an implicit, variable-step ordinary differential equation (ODE) solver from the scientific computing library, with relative tolerance $10^{-10}$ and absolute tolerance $10^{-12}$, so that temporal error is negligible compared to spatial error. Use the nodal interpolation of the exact initial condition on the interior nodes as the initial vector for the ODE.\n- At the final time $T$, compute the $L^2\\left(0, 1\\right)$-norm of the error between the exact solution $u\\left(\\cdot, T\\right)$ and the semi-discrete finite element solution $u_h\\left(\\cdot, T\\right)$:\n$$\n\\left\\|u\\left(\\cdot, T\\right) - u_h\\left(\\cdot, T\\right)\\right\\|_{L^2\\left(0, 1\\right)} = \\left(\\int_0^1 \\left(u\\left(x, T\\right) - u_h\\left(x, T\\right)\\right)^2 dx\\right)^{1/2}.\n$$\nUse Gaussian quadrature with enough points to ensure that the quadrature error is negligible relative to the finite element discretization error.\n\nTest suite. Your program must compute the above $L^2$-error for the following four test cases. Each test case is characterized by a pair $\\left(N, T\\right)$ together with the manufactured solution to use. There is no user input.\n\n- Test $1$ (happy path, moderate refinement): $N = 16$, $T = 0.1$, Manufactured A.\n- Test $2$ (refinement study): $N = 32$, $T = 0.1$, Manufactured A.\n- Test $3$ (different temporal behavior): $N = 16$, $T = 0.25$, Manufactured B.\n- Test $4$ (edge, very coarse mesh): $N = 2$, $T = 0.05$, Manufactured A.\n\nOutput specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the entries ordered as $\\left[\\text{error of Test }1,\\text{error of Test }2,\\text{error of Test }3,\\text{error of Test }4\\right]$. Each error must be output as a floating-point number. For example, the format must be exactly like\n$$\n\\left[\\text{float}_1,\\text{float}_2,\\text{float}_3,\\text{float}_4\\right].\n$$\n\nAngle units and physical units. There are no physical units in this problem. All angles in trigonometric functions are in radians.\n\nYour implementation must be a complete, runnable program in the specified language and environment and must strictly adhere to the output format.",
            "solution": "The user-provided problem is valid and represents a standard verification exercise for a Finite Element Method (FEM) implementation. The problem is scientifically grounded in numerical analysis for partial differential equations (PDEs), well-posed, objective, and provides a complete and consistent setup for a computational solution. We proceed with the derivation and implementation.\n\nThe core of the problem is to solve the one-dimensional heat equation, a parabolic PDE, using a semi-discretization approach. This method discretizes the spatial domain first, converting the PDE into a system of ordinary differential equations (ODEs) in time, which is then solved using a numerical ODE integrator.\n\n**1. Weak Formulation**\n\nThe given PDE is the linear heat equation with a source term $s(x,t)$, a constant diffusion coefficient $k=1$, and homogeneous Dirichlet boundary conditions:\n$$\nu_t - u_{xx} = s(x,t) \\quad \\text{for } x \\in (0, 1), t \\in (0, T]\n$$\n$$\nu(0, t) = u(1, t) = 0\n$$\n$$\nu(x, 0) = u_0(x)\n$$\nTo derive the weak formulation, we multiply the PDE by a test function $v(x)$ from an appropriate function space, in this case the Sobolev space $H_0^1(0, 1)$ which consists of functions that are square-integrable, have square-integrable weak derivatives, and are zero at the boundaries $x=0$ and $x=1$. Integrating over the spatial domain $\\Omega = (0, 1)$ gives:\n$$\n\\int_0^1 u_t v \\, dx - \\int_0^1 u_{xx} v \\, dx = \\int_0^1 s v \\, dx\n$$\nApplying integration by parts to the second term and using the fact that $v(0) = v(1) = 0$ yields:\n$$\n-\\int_0^1 u_{xx} v \\, dx = -[u_x v]_0^1 + \\int_0^1 u_x v_x \\, dx = \\int_0^1 u_x v_x \\, dx\n$$\nSubstituting this back, we obtain the weak form: Find $u(\\cdot, t) \\in H_0^1(0, 1)$ for $t > 0$ such that for all $v \\in H_0^1(0, 1)$:\n$$\n\\int_0^1 u_t v \\, dx + \\int_0^1 u_x v_x \\, dx = \\int_0^1 s v \\, dx\n$$\nThe time derivative can be moved outside the integral, leading to the final form used for semi-discretization:\n$$\n\\frac{d}{dt} \\int_0^1 u v \\, dx + \\int_0^1 u_x v_x \\, dx = \\int_0^1 s v \\, dx\n$$\n\n**2. Galerkin Semi-Discretization**\n\nWe approximate the solution $u(x,t)$ in a finite-dimensional subspace $V_h \\subset H_0^1(0, 1)$. The domain $(0, 1)$ is partitioned into $N$ uniform intervals of length $h=1/N$. The nodes are $x_i = i h$ for $i=0, \\dots, N$. We use continuous, piecewise linear basis functions (\"hat\" functions) $\\varphi_i(x)$, where $\\varphi_i(x_j) = \\delta_{ij}$ (the Kronecker delta). Since the boundary conditions are homogeneous Dirichlet, the basis functions associated with the boundary nodes, $\\varphi_0$ and $\\varphi_N$, are excluded from the solution space. Thus, $V_h = \\text{span}\\{\\varphi_i\\}_{i=1}^{N-1}$.\n\nThe approximate solution $u_h(x,t)$ is written as a linear combination of these basis functions with time-dependent coefficients:\n$$\nu_h(x,t) = \\sum_{j=1}^{N-1} U_j(t) \\varphi_j(x)\n$$\nIn the Galerkin method, the test functions are chosen from the same space as the basis functions, i.e., $v = \\varphi_i(x)$ for $i=1, \\dots, N-1$. Substituting $u_h$ and $v=\\varphi_i$ into the weak form gives a system of $N-1$ ODEs:\n$$\n\\sum_{j=1}^{N-1} \\left( \\int_0^1 \\varphi_i \\varphi_j \\, dx \\right) \\frac{d U_j}{dt} + \\sum_{j=1}^{N-1} \\left( \\int_0^1 \\varphi_i' \\varphi_j' \\, dx \\right) U_j(t) = \\int_0^1 s(x,t) \\varphi_i(x) \\, dx\n$$\nThis is the method-of-lines system, which can be expressed in matrix form as:\n$$\nM \\mathbf{\\dot{U}}(t) + K \\mathbf{U}(t) = \\mathbf{F}(t)\n$$\nwhere $\\mathbf{U}(t) = [U_1(t), \\dots, U_{N-1}(t)]^T$ is the vector of unknown nodal values at the interior nodes. The matrices $M$ (mass matrix) and $K$ (stiffness matrix), and the vector $\\mathbf{F}(t)$ (load vector) have entries defined as:\n- $M_{ij} = \\int_0^1 \\varphi_i \\varphi_j \\, dx$\n- $K_{ij} = \\int_0^1 \\varphi_i' \\varphi_j' \\, dx$\n- $F_i(t) = \\int_0^1 s(x,t) \\varphi_i(x) \\, dx$\n(with indices $i, j$ running from $1$ to $N-1$).\n\n**3. Matrix Assembly**\n\nThe entries of $M$ and $K$ are non-zero only if the supports of $\\varphi_i$ and $\\varphi_j$ overlap, which for hat functions occurs only for $|i-j| \\le 1$. Direct integration yields the well-known tridiagonal structures for a uniform mesh of step size $h$:\n- Mass matrix element on an interval $[x_k, x_{k+1}]$: $\\frac{h}{6}\\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$. Assembling for the interior nodes gives the $(N-1) \\times (N-1)$ matrix:\n$$\nM = \\frac{h}{6} \\begin{pmatrix} 4 & 1 & 0 & \\dots \\\\ 1 & 4 & 1 & \\dots \\\\ & \\ddots & \\ddots & \\ddots \\\\ \\dots & 0 & 1 & 4 \\end{pmatrix}\n$$\n- Stiffness matrix element on an interval $[x_k, x_{k+1}]$: $\\frac{1}{h}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$. Assembling gives the $(N-1) \\times (N-1)$ matrix:\n$$\nK = \\frac{1}{h} \\begin{pmatrix} 2 & -1 & 0 & \\dots \\\\ -1 & 2 & -1 & \\dots \\\\ & \\ddots & \\ddots & \\ddots \\\\ \\dots & 0 & -1 & 2 \\end{pmatrix}\n$$\n\n**4. Method of Manufactured Solutions**\n\nTo verify the implementation, we use manufactured solutions. We prescribe a smooth function $u(x,t)$ that satisfies the boundary conditions, and then derive the source term $s(x,t)$ by substituting $u(x,t)$ into the PDE operator: $s = u_t - u_{xx}$.\n- **Solution A**: $u_A(x,t) = \\sin(\\pi x) e^{-t}$.\n$s_A(x,t) = \\frac{\\partial u_A}{\\partial t} - \\frac{\\partial^2 u_A}{\\partial x^2} = -\\sin(\\pi x)e^{-t} - (-\\pi^2 \\sin(\\pi x)e^{-t}) = (\\pi^2-1)\\sin(\\pi x)e^{-t}$.\n- **Solution B**: $u_B(x,t) = x(1-x) \\cos(2t)$.\n$s_B(x,t) = \\frac{\\partial u_B}{\\partial t} - \\frac{\\partial^2 u_B}{\\partial x^2} = -2x(1-x)\\sin(2t) - (-2\\cos(2t)) = 2\\cos(2t) - 2x(1-x)\\sin(2t)$.\nThe initial condition for the ODE system is the nodal projection of the exact solution at $t=0$, i.e., $U_j(0) = u(x_j, 0)$.\n\n**5. Numerical Implementation**\n\n- **Load Vector and Error Calculation**: The integrals for the load vector $\\mathbf{F}(t)$ and the final $L^2$ error norm are computed numerically. We use Gaussian quadrature on each element. A high-order rule (e.g., $5$-point) is chosen to ensure that the quadrature error is negligible compared to the spatial discretization error, which is $O(h^2)$ for linear elements.\n- **Time Integration**: The ODE system is rearranged to $\\mathbf{\\dot{U}}(t) = M^{-1}(\\mathbf{F}(t) - K \\mathbf{U}(t))$. This is a stiff system, so an implicit, high-order, adaptive time-stepping method is required. We use the `Radau` solver provided by `scipy.integrate.solve_ivp` with very strict tolerances ($rtol=10^{-10}$, $atol=10^{-12}$) to make the temporal error insignificant. The mass matrix $M$ is constant, so its LU-factorization is computed once and reused for efficient solving of the linear system $M\\mathbf{y} = \\mathbf{b}$ at each evaluation of the ODE's right-hand side.\n- **$L^2$-Error Norm**: At the final time $T$, the error is computed as $\\|e(\\cdot,T)\\|_{L^2} = \\left(\\int_0^1 (u(x,T) - u_h(x,T))^2 dx\\right)^{1/2}$. The integral is computed as a sum of integrals over each element, each evaluated using Gaussian quadrature:\n$$\n\\|e(\\cdot,T)\\|_{L^2}^2 = \\sum_{k=0}^{N-1} \\int_{x_k}^{x_{k+1}} (u(x,T) - u_h(x,T))^2 dx\n$$\n\nThe implementation encapsulates this entire procedure, running it for each of the four specified test cases and reporting the computed $L^2$ error.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import lu_factor, lu_solve\n# numpy.polynomial is part of numpy.\nfrom numpy.polynomial.legendre import leggauss\n\n# Manufactured solution A\ndef u_A(x, t):\n    \"\"\"Manufactured solution A: u(x,t) = sin(pi*x) * exp(-t)\"\"\"\n    return np.sin(np.pi * x) * np.exp(-t)\n\ndef s_A(x, t):\n    \"\"\"Source term corresponding to manufactured solution A.\"\"\"\n    return (np.pi**2 - 1) * np.sin(np.pi * x) * np.exp(-t)\n\n# Manufactured solution B\ndef u_B(x, t):\n    \"\"\"Manufactured solution B: u(x,t) = x(1-x)cos(2t)\"\"\"\n    return x * (1 - x) * np.cos(2 * t)\n\ndef s_B(x, t):\n    \"\"\"Source term corresponding to manufactured solution B.\"\"\"\n    return 2 * np.cos(2 * t) - 2 * x * (1 - x) * np.sin(2 * t)\n\ndef run_case(N, T, u_exact, s_func):\n    \"\"\"\n    Solves the heat equation for a single test case using FEM.\n\n    Args:\n        N (int): Number of spatial intervals.\n        T (float): Final time.\n        u_exact (callable): Function for the exact solution u(x,t).\n        s_func (callable): Function for the source term s(x,t).\n\n    Returns:\n        float: The L2 error at the final time T.\n    \"\"\"\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n    num_interior_nodes = N - 1\n\n    # Assemble Mass (M) and Stiffness (K) matrices for interior nodes\n    diag_M = np.full(num_interior_nodes, 4.0 * h / 6.0) # Corrected from 2/3 to 4/6 for clarity\n    offdiag_M = np.full(num_interior_nodes - 1, h / 6.0)\n    M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n\n    diag_K = np.full(num_interior_nodes, 2.0 / h)\n    offdiag_K = np.full(num_interior_nodes - 1, -1.0 / h)\n    K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n\n    # Pre-compute LU factorization of M for efficiency\n    M_lu = lu_factor(M)\n\n    # Gaussian quadrature setup (sufficiently high order)\n    num_gauss_points = 5\n    gauss_pts_ref, gauss_wts_ref = leggauss(num_gauss_points)\n\n    def F_vec(t):\n        \"\"\"Computes the load vector F(t) using Gaussian quadrature.\"\"\"\n        f = np.zeros(num_interior_nodes)\n        for j_idx in range(num_interior_nodes):\n            j_node = j_idx + 1  # Node index (1 to N-1)\n\n            # Support of phi_j is [x_{j-1}, x_{j+1}]\n            # Integral over left element [x_{j-1}, x_j]\n            x_L, x_R = x_nodes[j_node - 1], x_nodes[j_node]\n            q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n            q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n            phi_j_vals = (q_pts - x_L) / h\n            integral_L = np.sum(q_wts * s_func(q_pts, t) * phi_j_vals)\n            \n            # Integral over right element [x_j, x_{j+1}]\n            x_L, x_R = x_nodes[j_node], x_nodes[j_node + 1]\n            q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n            q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n            phi_j_vals = (x_R - q_pts) / h\n            integral_R = np.sum(q_wts * s_func(q_pts, t) * phi_j_vals)\n            \n            f[j_idx] = integral_L + integral_R\n        return f\n\n    def rhs(t, U):\n        \"\"\"Right-hand side of the ODE system dU/dt = M^{-1}(F(t) - K*U).\"\"\"\n        b = F_vec(t) - K @ U\n        return lu_solve(M_lu, b)\n\n    # Nodal interpolation for the initial condition\n    U0 = u_exact(x_nodes[1:-1], 0)\n\n    # Solve the system of ODEs\n    sol = solve_ivp(\n        rhs, (0, T), U0, method='Radau',\n        rtol=1e-10, atol=1e-12, t_eval=[T]\n    )\n    U_final = sol.y[:, -1]\n    \n    # Full solution vector including boundaries\n    U_full = np.concatenate(([0], U_final, [0]))\n\n    # Compute L2 error at final time T\n    total_err_sq = 0.0\n    for i in range(N):  # Loop over elements [x_i, x_{i+1}]\n        x_L, x_R = x_nodes[i], x_nodes[i+1]\n        \n        q_pts = 0.5 * (x_R - x_L) * gauss_pts_ref + 0.5 * (x_R + x_L)\n        q_wts = 0.5 * (x_R - x_L) * gauss_wts_ref\n        \n        u_exact_vals = u_exact(q_pts, T)\n        \n        # On element i, u_h(x) = U_i * phi_i(x) + U_{i+1} * phi_{i+1}(x)\n        phi_i_vals = (x_R - q_pts) / h\n        phi_i_plus_1_vals = (q_pts - x_L) / h\n        u_h_vals = U_full[i] * phi_i_vals + U_full[i+1] * phi_i_plus_1_vals\n        \n        total_err_sq += np.sum(q_wts * (u_exact_vals - u_h_vals)**2)\n    \n    return np.sqrt(total_err_sq)\n\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        {'N': 16, 'T': 0.1, 'u': u_A, 's': s_A},\n        {'N': 32, 'T': 0.1, 'u': u_A, 's': s_A},\n        {'N': 16, 'T': 0.25, 'u': u_B, 's': s_B},\n        {'N': 2, 'T': 0.05, 'u': u_A, 's': s_A}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_case(case['N'], case['T'], case['u'], case['s'])\n        results.append(error)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}