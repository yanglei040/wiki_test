{
    "hands_on_practices": [
        {
            "introduction": "在求解对流扩散方程时，高阶格式（如中心差分）虽然在理论上具有更高的精度，但在对流远强于扩散的区域（即高佩克莱数 $Pe$），其数值解往往会产生非物理的伪振荡。本练习将通过一个经典的一维瞬态问题，让你动手实现并对比中心差分格式与基本的混合差分格式。你将亲眼见证混合格式如何通过在 $Pe \\gt 2$ 时切换到稳定的一阶迎风格式，从而有效抑制这些伪振荡，并加深对数值稳定性和精度之间权衡的理解。",
            "id": "3405005",
            "problem": "考虑一个标量输运量 $\\,\\phi(x,t)\\,$ 的一维线性对流扩散方程，\n$$\n\\partial_t \\phi \\;=\\; \\nu\\,\\partial_{xx}\\phi \\;-\\; u\\,\\partial_x \\phi,\n$$\n该方程定义在周期为 $\\,1\\,$ 的周期性域 $[0,1)$ 上，其中 $\\,\\nu0\\,$ 是运动学扩散系数，$\\,u\\,$ 是恒定的平流速度。初始条件为阶跃函数，\n$$\n\\phi(x,0) \\;=\\; \\begin{cases}\n1,  0 \\le x  1/2,\\\\\n0,  1/2 \\le x  1.\n\\end{cases}\n$$\n周期性边界条件意味着对于所有 $\\,t \\ge 0\\,$，都有 $\\,\\phi(0,t)=\\phi(1,t)\\,$。本题的目标是，从第一性原理出发并通过计算来证明，在对该瞬态解进行时间推进时，与纯粹的中心差分空间离散化相比，混合差分开关如何抑制伪振荡。\n\n从以下基本出发点开始：\n- 该方程是线性的，其弱形式允许使用一致的中心和迎风空间离散化。\n- 对于线性抛物线方程，后向欧拉法是无条件稳定的，但它本身并不能强制执行离散极值原理；单调性取决于空间算子的矩阵性质。\n- 网格 Peclet 数 $\\,Pe\\,=\\,|u\\,\\Delta x/\\nu|\\,$ 用于衡量网格尺度上对流与扩散的相对强度。\n\n使用包含 $\\,N\\,$ 个大小为 $\\,\\Delta x \\,=\\, 1/N\\,$ 的控制体的均匀网格对空间域进行离散化。在时间上使用步长为 $\\,\\Delta t0\\,$ 的后向欧拉法：\n$$\n\\phi^{n+1} \\;-\\; \\phi^{n} \\;=\\; \\Delta t\\;\\Big(\\,\\nu\\,\\partial_{xx}\\phi^{n+1} \\;-\\; u\\,\\partial_x \\phi^{n+1}\\Big),\n$$\n因此\n$$\n\\big(I \\;-\\; \\Delta t\\,L\\big)\\,\\phi^{n+1} \\;=\\; \\phi^{n},\n$$\n其中 $\\,L\\,$ 是离散空间算子。对于扩散项，使用二阶中心差分：\n$$\n\\big(\\partial_{xx}\\phi\\big)_i \\;\\approx\\; \\frac{\\phi_{i+1}-2\\phi_{i}+\\phi_{i-1}}{\\Delta x^2},\n$$\n采用模 $\\,N\\,$ 的周期性索引。对于对流项，比较两种空间离散化方法：\n- 中心差分：\n$$\n\\big(\\partial_x \\phi\\big)_i \\;\\approx\\; \\frac{\\phi_{i+1}-\\phi_{i-1}}{2\\Delta x}.\n$$\n- 混合差分开关：定义网格 Peclet 数 $\\,Pe \\,=\\, |u\\,\\Delta x/\\nu|\\,$。如果 $\\,Pe\\le 2\\,$，则使用上述的中心差分；否则，使用一阶迎风格式，\n$$\n\\big(\\partial_x \\phi\\big)_i \\;\\approx\\; \n\\begin{cases}\n\\dfrac{\\phi_{i}-\\phi_{i-1}}{\\Delta x},  u \\ge 0,\\\\\n\\dfrac{\\phi_{i+1}-\\phi_{i}}{\\Delta x},  u  0.\n\\end{cases}\n$$\n这个开关是混合差分格式的精髓：当 $\\,Pe\\,$ 较小时，它简化为中心差分；当 $\\,Pe\\,$ 较大时，它切换到迎风格式以保持单调性。\n\n定义一个定量的、无量纲的振荡度量，作为整个模拟过程中网格上对物理允许范围 $[0,1]$ 的最大违背量：\n$$\n\\mathcal{O} \\;=\\; \\max_{0\\le n\\le n_{\\text{steps}}}\\;\\max\\Big\\{\\;\\max_i \\big(\\phi_i^n - 1\\big)_+,\\;\\max_i \\big(0 - \\phi_i^n\\big)_+\\;\\Big\\},\n$$\n其中 $(z)_+ = \\max\\{z,0\\}$。对于每个测试用例，计算两个值：$\\,\\mathcal{O}_{\\text{central}}\\,$ 和 $\\,\\mathcal{O}_{\\text{hybrid}}\\,$。\n\n实现该算法，并将其应用于以下参数测试套件，每个测试用例由元组 $(N,u,\\nu,\\Delta t,n_{\\text{steps}})$ 指定：\n- 用例 A (阈值 Peclet 数): $(\\,N=200,\\;u=2.0,\\;\\nu=0.005,\\;\\Delta t=0.05,\\;n_{\\text{steps}}=40\\,)$，所以 $\\,Pe = |u\\Delta x/\\nu| = |2\\cdot(1/200)/0.005| = 2$。\n- 用例 B (对流主导): $(\\,N=200,\\;u=5.0,\\;\\nu=0.005,\\;\\Delta t=0.05,\\;n_{\\text{steps}}=40\\,)$，所以 $\\,Pe = 5$。\n- 用例 C (扩散主导): $(\\,N=200,\\;u=2.0,\\;\\nu=0.02,\\;\\Delta t=0.05,\\;n_{\\text{steps}}=40\\,)$，所以 $\\,Pe = 0.5$。\n- 用例 D (强对流，更粗的时间步长): $(\\,N=200,\\;u=10.0,\\;\\nu=0.002,\\;\\Delta t=0.1,\\;n_{\\text{steps}}=20\\,)$，所以 $\\,Pe = 25$。\n- 用例 E (对流主导，精细时间步长): $(\\,N=200,\\;u=5.0,\\;\\nu=0.005,\\;\\Delta t=0.005,\\;n_{\\text{steps}}=400\\,)$，所以 $\\,Pe = 5$。\n\n你的程序必须：\n- 在两种空间格式选择下，根据周期性索引组装 $\\,L\\,$ 的矩阵。\n- 从阶跃初始条件开始，使用后向欧拉法进行时间推进。\n- 对于每个用例，计算并存储 $\\,\\mathcal{O}_{\\text{central}}\\,$ 和 $\\,\\mathcal{O}_{\\text{hybrid}}\\,$ 作为实数。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，条目按用例逐一排序，格式为 $[\\mathcal{O}_{\\text{central}}^{(A)},\\mathcal{O}_{\\text{hybrid}}^{(A)},\\mathcal{O}_{\\text{central}}^{(B)},\\mathcal{O}_{\\text{hybrid}}^{(B)},\\ldots]$，并将每个数字四舍五入到 $\\,6\\,$ 位小数。例如，包含三个数字的输出必须看起来像 $[\\alpha,\\beta,\\gamma]$，其中 $\\,\\alpha,\\beta,\\gamma\\,$ 均写为 $\\,6\\,$ 位小数。\n\n所有输出都是无量纲实数；不需要物理单位。不出现角度。不使用百分比；输出中不要包含任何百分号。",
            "solution": "所提供的问题是计算流体动力学中的一个有效练习，旨在评估不同数值格式在求解对流扩散方程时的行为。该问题具有科学依据，是适定的，并且所有参数都已指定。我们将着手提供一个解法。\n\n问题的核心是关于标量 $\\phi(x,t)$ 的一维线性对流扩散方程：\n$$\n\\partial_t \\phi = \\nu\\,\\partial_{xx}\\phi - u\\,\\partial_x \\phi\n$$\n其中 $\\nu  0$ 是扩散系数，而 $u$ 是一个恒定的平流速度。该方程定义在周期性域 $x \\in [0,1)$ 上。根据抛物线型偏微分方程的极值原理，一个没有内部源或汇的解 $\\phi(x,t)$ 必须在其时空域的边界上达到其最大值和最小值。对于周期性空间域，这意味着解在任何时候都必须保持在初始值的最小值和最大值之间。给定初始条件\n$$\n\\phi(x,0) = \\begin{cases}\n1,  0 \\le x  1/2,\\\\\n0,  1/2 \\le x  1,\n\\end{cases}\n$$\n精确解必须对所有的 $x$ 和 $t \\ge 0$ 满足 $0 \\le \\phi(x,t) \\le 1$。数值解可能会违反这些界限，产生非物理的“伪”振荡。本题的目标是展示混合差分格式与标准的中心差分格式相比，如何抑制这些振荡。\n\n我们将空间域离散化为 $N$ 个宽度为 $\\Delta x = 1/N$ 的均匀控制体。时间导数使用一阶隐式后向欧拉法进行离散化，该方法对于此线性问题是无条件稳定的：\n$$\n\\frac{\\phi_i^{n+1} - \\phi_i^{n}}{\\Delta t} = \\nu (\\partial_{xx}\\phi^{n+1})_i - u (\\partial_x\\phi^{n+1})_i\n$$\n重新整理各项，我们得到关于新时间步 $n+1$ 的解向量 $\\boldsymbol{\\phi}^{n+1} = (\\phi_0^{n+1}, \\dots, \\phi_{N-1}^{n+1})^T$ 的线性方程组：\n$$\n\\phi_i^{n+1} - \\Delta t \\left( \\nu (\\partial_{xx}\\phi^{n+1})_i - u (\\partial_x\\phi^{n+1})_i \\right) = \\phi_i^n\n$$\n该系统可以写成矩阵形式 $A \\boldsymbol{\\phi}^{n+1} = \\boldsymbol{\\phi}^n$。矩阵 $A$ 的性质对数值格式的单调性至关重要。要使格式保持单调性（即满足离散极值原理），一个充分条件是矩阵 $A$ 是一个 M-矩阵。一个矩阵成为 M-矩阵的一个实用充分条件是：它是不可约对角占优的，具有正的对角元素和非正的非对角元素。\n\n扩散项使用标准的二阶中心差分进行离散化：\n$$\n(\\partial_{xx}\\phi)_i = \\frac{\\phi_{i+1}-2\\phi_{i}+\\phi_{i-1}}{\\Delta x^2}\n$$\n我们分析两种用于对流项的格式。\n\n**1. 中心差分 (CD) 格式**\n对流项使用二阶中心差分进行离散化：\n$$\n(\\partial_x \\phi)_i = \\frac{\\phi_{i+1}-\\phi_{i-1}}{2\\Delta x}\n$$\n将这些离散化格式代入时间步进方程，并收集关于 $\\phi_{i-1}^{n+1}$、$\\phi_i^{n+1}$ 和 $\\phi_{i+1}^{n+1}$ 的项，得到线性系统的第 $i$ 行：\n$$\n\\left(-\\frac{\\Delta t \\nu}{\\Delta x^2} - \\frac{\\Delta t u}{2\\Delta x}\\right)\\phi_{i-1}^{n+1} + \\left(1 + \\frac{2\\Delta t \\nu}{\\Delta x^2}\\right)\\phi_i^{n+1} + \\left(-\\frac{\\Delta t \\nu}{\\Delta x^2} + \\frac{\\Delta t u}{2\\Delta x}\\right)\\phi_{i+1}^{n+1} = \\phi_i^n\n$$\n由于是周期性域，矩阵 $A$ 是一个循环矩阵。其典型第 $i$ 行的非零元素为：\n$$\n\\begin{aligned}\nA_{i,i-1} = -\\frac{\\Delta t \\nu}{\\Delta x^2} \\left(1 + \\frac{u \\Delta x}{2\\nu}\\right) = -\\frac{\\Delta t \\nu}{\\Delta x^2} \\left(1 \\pm \\frac{Pe}{2}\\right) \\\\\nA_{i,i}   = 1 + \\frac{2\\Delta t \\nu}{\\Delta x^2}  0 \\\\\nA_{i,i+1} = -\\frac{\\Delta t \\nu}{\\Delta x^2} \\left(1 - \\frac{u \\Delta x}{2\\nu}\\right) = -\\frac{\\Delta t \\nu}{\\Delta x^2} \\left(1 \\mp \\frac{Pe}{2}\\right)\n\\end{aligned}\n$$\n其中 $Pe = |u|\\Delta x/\\nu$ 是网格 Peclet 数，符号选择取决于 $u$ 的符号。对于 M-矩阵条件，所有非对角元素必须为非正。如果我们假设 $u  0$，当 $Pe  2$ 时，项 $A_{i,i+1} = -\\frac{\\Delta t \\nu}{\\Delta x^2}(1 - Pe/2)$ 变为正数。这违反了 M-矩阵的条件，并导致对角占优性的丧失，这就是当网格尺度上对流主导扩散时（$Pe  2$）观察到伪振荡的数学根源。\n\n**2. 混合差分格式**\n混合格式旨在规避此问题。它根据网格 Peclet 数对对流项使用条件表达式：\n- 如果 $Pe \\le 2$：使用中心差分格式，因为在此范围内它是非振荡的，并提供二阶精度。矩阵 $A$ 与 $A_{CD}$ 相同。\n- 如果 $Pe  2$：切换到一阶迎风 (UW) 格式。对于 $u  0$，迎风离散化为：\n$$\n(\\partial_x \\phi)_i = \\frac{\\phi_{i}-\\phi_{i-1}}{\\Delta x}\n$$\n系统的对应行为：\n$$\n\\left(-\\frac{\\Delta t \\nu}{\\Delta x^2} - \\frac{\\Delta t u}{\\Delta x}\\right)\\phi_{i-1}^{n+1} + \\left(1 + \\frac{2\\Delta t \\nu}{\\Delta x^2} + \\frac{\\Delta t u}{\\Delta x}\\right)\\phi_i^{n+1} + \\left(-\\frac{\\Delta t \\nu}{\\Delta x^2}\\right)\\phi_{i+1}^{n+1} = \\phi_i^n\n$$\n当 $u0$ 时，矩阵元素为：\n$$\n\\begin{aligned}\nA_{i,i-1} = -\\frac{\\Delta t \\nu}{\\Delta x^2} (1 + Pe) \\le 0 \\\\\nA_{i,i}   = 1 + \\frac{\\Delta t \\nu}{\\Delta x^2} (2 + Pe)  0 \\\\\nA_{i,i+1} = -\\frac{\\Delta t \\nu}{\\Delta x^2} \\le 0\n\\end{aligned}\n$$\n所有非对角元素都是非正的，对角元素是正的。对于任何 $\\Delta t  0$，该矩阵都是严格对角占优的，因为 $A_{i,i} - |A_{i,i-1}| - |A_{i,i+1}| = 1  0$。因此，它是一个 M-矩阵，该格式是无条件单调的，保证不会产生伪振荡。其代价是迎风格式只有一阶精度，会引入数值扩散。\n\n对于每个测试用例 $(N, u, \\nu, \\Delta t, n_{\\text{steps}})$，算法按以下步骤进行：\n1.  根据给定的阶跃函数初始化解向量 $\\boldsymbol{\\phi}^0$。\n2.  计算网格 Peclet 数 $Pe = |u|\\Delta x / \\nu$。\n3.  对于中心差分格式，组装循环矩阵 $A_{CD}$ 的第一行。\n4.  对于混合差分格式，如果 $Pe \\le 2$，使用 $A_{CD}$。如果 $Pe  2$，则为迎风格式组装循环矩阵 $A_{UW}$ 的第一行。\n5.  从 $n = 0$ 迭代至 $n_{\\text{steps}}-1$。在每个步骤中，求解循环线性系统 $A_{CD}\\boldsymbol{\\phi}^{n+1}_{CD} = \\boldsymbol{\\phi}^{n}_{CD}$ 和 $A_{Hybrid}\\boldsymbol{\\phi}^{n+1}_{Hybrid} = \\boldsymbol{\\phi}^{n}_{Hybrid}$。为了效率，我们使用 `scipy.linalg.solve_circulant`。\n6.  在每个时间步，计算最大过冲 $(\\max(\\boldsymbol{\\phi}^n) - 1)$ 和下冲 $(-\\min(\\boldsymbol{\\phi}^n))$。每种格式的振荡度量 $\\mathcal{O}$ 是在所有时间步中这些违背量（如果为正）的最大值。\n\n测试用例的结果将表明，对于 $Pe  2$，$\\mathcal{O}_{\\text{central}}  0$ 而 $\\mathcal{O}_{\\text{hybrid}} \\approx 0$，这证实了理论性质。对于 $Pe \\le 2$，两种格式相同，因此 $\\mathcal{O}_{\\text{central}} = \\mathcal{O}_{\\text{hybrid}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: Pe = 2\n        (200, 2.0, 0.005, 0.05, 40),\n        # Case B: Pe = 5\n        (200, 5.0, 0.005, 0.05, 40),\n        # Case C: Pe = 0.5\n        (200, 2.0, 0.02, 0.05, 40),\n        # Case D: Pe = 25\n        (200, 10.0, 0.002, 0.1, 20),\n        # Case E: Pe = 5\n        (200, 5.0, 0.005, 0.005, 400),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        O_central, O_hybrid = simulate_case(*case_params)\n        results.append(O_central)\n        results.append(O_hybrid)\n\n    # Format the output as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef simulate_case(N, u, nu, dt, n_steps):\n    \"\"\"\n    Solves the convection-diffusion problem for a single test case.\n\n    Args:\n        N (int): Number of control volumes.\n        u (float): Advection speed.\n        nu (float): Kinematic diffusivity.\n        dt (float): Time step size.\n        n_steps (int): Number of time steps.\n\n    Returns:\n        tuple[float, float]: The oscillation metrics (O_central, O_hybrid).\n    \"\"\"\n    dx = 1.0 / N\n\n    # Initialize solution vector phi from the step function initial condition.\n    # phi_i = 1 for 0 = x  1/2, so for i = 0 to N/2 - 1.\n    phi0 = np.zeros(N)\n    phi0[0:N//2] = 1.0\n\n    # Calculate cell Peclet number\n    Pe = np.abs(u * dx / nu)\n\n    # --- Central Differencing Scheme ---\n    # Coefficients for the circulant matrix A_c * phi^{n+1} = phi^{n}\n    c_l_c = -dt * nu / dx**2 - dt * u / (2 * dx)  # Coefficient for phi_{i-1}\n    c_d_c = 1 + 2 * dt * nu / dx**2             # Coefficient for phi_{i}\n    c_u_c = -dt * nu / dx**2 + dt * u / (2 * dx)  # Coefficient for phi_{i+1}\n    \n    # First row of the circulant matrix\n    A_row_c = np.zeros(N)\n    A_row_c[0] = c_d_c\n    A_row_c[1] = c_u_c\n    A_row_c[-1] = c_l_c\n    \n    phi_c = phi0.copy()\n    O_central = 0.0\n    for _ in range(n_steps):\n        phi_c = solve_circulant(A_row_c, phi_c)\n        overshoot = np.max(phi_c) - 1.0\n        undershoot = -np.min(phi_c)\n        current_oscillation = max(0.0, overshoot, undershoot)\n        O_central = max(O_central, current_oscillation)\n\n    # --- Hybrid Differencing Scheme ---\n    phi_h = phi0.copy()\n    O_hybrid = 0.0\n    \n    if Pe = 2:\n        # Hybrid scheme uses central differencing\n        A_row_h = A_row_c\n    else:\n        # Hybrid scheme uses upwind differencing\n        if u >= 0:\n            c_l_h = -dt * nu / dx**2 - dt * u / dx\n            c_d_h = 1 + 2 * dt * nu / dx**2 + dt * u / dx\n            c_u_h = -dt * nu / dx**2\n        else: # u  0\n            c_l_h = -dt * nu / dx**2\n            c_d_h = 1 + 2 * dt * nu / dx**2 - dt * u / dx\n            c_u_h = -dt * nu / dx**2 + dt * u / dx\n        \n        A_row_h = np.zeros(N)\n        A_row_h[0] = c_d_h\n        A_row_h[1] = c_u_h\n        A_row_h[-1] = c_l_h\n\n    for _ in range(n_steps):\n        phi_h = solve_circulant(A_row_h, phi_h)\n        overshoot = np.max(phi_h) - 1.0\n        undershoot = -np.min(phi_h)\n        current_oscillation = max(0.0, overshoot, undershoot)\n        O_hybrid = max(O_hybrid, current_oscillation)\n\n    return O_central, O_hybrid\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "尽管经典的混合格式能够抑制振荡，但其在中心差分和迎风格式之间的“硬切换”机制本身并不完美。这种不连续的切换可能在流场速度平滑变化的区域（例如靠近滞止点处）引入新的数值误差。本练习将引导你从理论层面着手，设计一个光滑的混合函数 $w(Pe)$，它能够根据佩克莱数 $Pe$ 的大小，在两种格式之间实现平滑过渡。通过这个推导过程，你将掌握如何构建既能保持低 $Pe$ 数下二阶精度，又能在高 $Pe$ 数下确保稳定性的高级格式。",
            "id": "3404972",
            "problem": "考虑一个无源标量场 $\\,\\phi(x)\\,$ 的一维稳态线性对流扩散方程，\n$$-\\frac{d}{dx}\\left(\\Gamma \\frac{d\\phi}{dx}\\right) + \\frac{d}{dx}\\left(b(x)\\,\\phi\\right) = 0,\\quad x\\in[-L,L],$$\n其中扩散系数 $\\,\\Gamma0\\,$ 为常数，速度场为驻点速度场 $\\,b(x)=\\beta x\\,$，且 $\\,\\beta0\\,$。在间距为 $\\,\\Delta x\\,$ 的均匀网格上施加狄利克雷边界条件 $\\,\\phi(-L)=1\\,$ 和 $\\,\\phi(L)=0\\,$。使用有限体积法 (FVM)，将面佩克莱数定义为\n$$Pe \\equiv \\frac{b_f\\,\\Delta x}{\\Gamma},$$\n其中 $\\,b_f\\,$ 是面法向速度。经典的混合差分格式会根据 $\\,|Pe|\\,$ 的值（例如，在 $\\,|Pe|\\approx 2\\,$ 附近的阈值）在中心差分和迎风差分之间不连续地切换，当 $\\,b(x)\\,$ 在驻点 $\\,x=0\\,$ 处变号时，这可能会引发非物理振荡。\n\n为了使切换正则化，考虑在每个面上使用一个光滑权重 $\\,w(Pe)\\in[0,1]\\,$ 对迎风差分和中心差分进行凸混合：\n- $\\,w(Pe)\\,$ 乘以迎风部分的贡献，\n- $\\,1-w(Pe)\\,$ 乘以中心部分的贡献。\n\n从均匀网格上的面插值的泰勒展开以及对流和扩散通量的量纲分析出发，推导为在 $\\,Pe\\approx 0\\,$ 附近保持中心差分的二阶精度，$\\,w(Pe)\\,$ 需要满足的小 $\\,|Pe|\\,$ 约束条件。施加额外约束条件：$\\,w(0)=0\\,$，$\\,w\\,$ 是关于 $\\,Pe\\,$ 的偶函数且至少一阶连续可导，$\\,w\\,$ 在 $\\,|Pe|\\,$ 上非递减，并且 $\\,\\lim_{|Pe|\\to\\infty} w(Pe)=1\\,$，以便在高 $\\,|Pe|\\,$ 时恢复为迎风格式。在满足这些约束的函数中，选择关于 $\\,Pe^2\\,$ 的最简有理形式，该形式需与常规混合阈值匹配，即混合权重在 $\\,|Pe|=Pe_c\\,$（其中 $\\,Pe_c=2\\,$）时达到二分之一。\n\n你得到的 $\\,w(Pe)\\,$ 的显式闭合表达式是什么？将你的最终答案表示为 $\\,Pe\\,$ 的符号函数，不带单位。无需四舍五入。",
            "solution": "该问题要求为混合有限体积格式推导一个光滑的混合函数 $w(Pe)$。此函数用于混合一维稳态对流扩散方程中对流项的中心差分 (CDS) 和迎风差分 (UDS)。\n\n我们考虑在间距为 $\\Delta x$ 的均匀网格上，位于节点 'P' 和 'E' 之间的控制体面 'f' 处的总通量 $F = b\\phi - \\Gamma \\frac{d\\phi}{dx}$ 的离散化。扩散通量使用二阶中心差分进行离散：$-\\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x}$。对流通量 $b_f \\phi_f$ 取决于插值得到的面值 $\\phi_f$。\n\n$\\phi_f$ 的混合插值由下式给出：\n$$ \\phi_f = (1 - w(Pe)) \\phi_f^{CDS} + w(Pe) \\phi_f^{UDS} $$\n其中 $\\phi_f^{CDS} = \\frac{\\phi_P + \\phi_E}{2}$，$\\phi_f^{UDS}$ 是迎风节点处的值。假设 $b_f  0$，因此佩克莱数 $Pe = \\frac{b_f \\Delta x}{\\Gamma}  0$，且 $\\phi_f^{UDS} = \\phi_P$。$\\phi_f$ 的表达式变为：\n$$ \\phi_f = (1 - w(Pe)) \\frac{\\phi_P + \\phi_E}{2} + w(Pe)\\phi_P $$\n我们可以通过分离 CDS 部分和混合部分的贡献来重写此式：\n$$ \\phi_f = \\frac{\\phi_P + \\phi_E}{2} + w(Pe) \\left( \\phi_P - \\frac{\\phi_P + \\phi_E}{2} \\right) = \\phi_f^{CDS} - w(Pe) \\frac{\\phi_E - \\phi_P}{2} $$\n那么，面上的总数值通量为：\n$$ F_f = b_f \\phi_f - \\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x} = b_f \\left( \\phi_f^{CDS} - w(Pe) \\frac{\\phi_E - \\phi_P}{2} \\right) - \\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x} $$\n$$ F_f = \\left( b_f \\phi_f^{CDS} - \\Gamma \\frac{\\phi_E - \\phi_P}{\\Delta x} \\right) - b_f w(Pe) \\frac{\\phi_E - \\phi_P}{2} $$\n括号中的项是通量的标准二阶中心差分离散。附加项表示人工扩散通量。使用泰勒展开 $\\phi_E - \\phi_P \\approx \\Delta x (\\frac{d\\phi}{dx})_f$，附加通量项为：\n$$ - b_f w(Pe) \\frac{\\Delta x}{2} \\left(\\frac{d\\phi}{dx}\\right)_f = - \\left( \\frac{b_f \\Delta x}{\\Gamma} \\right) \\frac{\\Gamma w(Pe)}{2} \\left(\\frac{d\\phi}{dx}\\right)_f = - \\Gamma \\frac{Pe \\, w(Pe)}{2} \\left(\\frac{d\\phi}{dx}\\right)_f $$\n对 $b_f  0$ ($Pe  0$) 的情况进行类似分析，此时 $\\phi_f^{UDS} = \\phi_E$，得到的人工扩散通量为 $- \\Gamma \\frac{|Pe| \\, w(Pe)}{2} (\\frac{d\\phi}{dx})_f$。因此，该格式等效于将人工扩散系数 $\\Gamma_{art}$ 添加到物理扩散系数 $\\Gamma$ 中：\n$$ \\Gamma_{art} = \\Gamma \\frac{|Pe|\\,w(Pe)}{2} $$\n中心差分格式是二阶精度的，这意味着控制体离散守恒方程的截断误差为 $O(\\Delta x^2)$。引入混合项会增加一个等效于 $-\\frac{d}{dx}(\\Gamma_{art} \\frac{d\\phi}{dx})$ 的误差项。为使整个格式保持二阶精度，此误差项必须至少为 $O(\\Delta x^2)$。\n$$ -\\frac{d}{dx}\\left(\\Gamma_{art} \\frac{d\\phi}{dx}\\right) = O(\\Delta x^2) $$\n由于对 $x$ 的微分与 $1/\\Delta x$ 成比例，这要求 $\\Gamma_{art}$ 为 $O(\\Delta x^3)$。\n$$ \\Gamma_{art} = \\Gamma \\frac{|Pe|\\,w(Pe)}{2} = O(\\Delta x^3) $$\n鉴于 $Pe = \\frac{b_f \\Delta x}{\\Gamma}$ 是 $O(\\Delta x)$，我们有 $|Pe|\\,w(Pe) = O(\\Delta x^2) = O(Pe^2)$。这意味着对于小的 $|Pe|$，$w(Pe)$ 必须是 $O(|Pe|)$。\n\n然而，问题陈述对 $w(Pe)$ 施加了额外的约束：它必须是偶函数 ($w(Pe) = w(-Pe)$) 且至少一阶连续可导 ($C^1$)。对于一个 $C^1$ 偶函数，其导数是奇函数：$w'(Pe) = -w'(-Pe)$。在 $Pe=0$ 处，连续性要求 $w'(0) = -w'(0)$，这意味着 $w'(0) = 0$。\n对于一个满足 $w(0)=0$ 和 $w'(0)=0$ 的 $C^1$ 偶函数，$w(Pe)$ 在 $Pe=0$ 附近的泰勒级数展开必须以 $Pe^2$ 或更高阶的项开始：\n$$ w(Pe) = a_2 Pe^2 + a_4 Pe^4 + \\dots $$\n因此，对于小的 $|Pe|$，$w(Pe)$ 的行为必须是 $O(Pe^2)$。这是一个比 $w(Pe) = O(|Pe|)$ 更严格的条件，也是问题所有条件所要求的有效的小 $|Pe|$ 约束。这个条件足以保持二阶精度，因为它使得 $\\Gamma_{art} = \\Gamma \\frac{|Pe| O(Pe^2)}{2} = O(|Pe|^3) = O(\\Delta x^3)$，从而导致截断误差项为 $O(\\Delta x^2)$。\n\n接下来，我们必须找到 $w(Pe)$ 关于 $Pe^2$ 的满足所有给定约束的最简有理形式。令 $y = Pe^2$。对于 $y \\ge 0$，$w(y)$ 的约束条件是：\n1.  对于小的 $y$，$w(y)$ 的行为类似于 $a_2 y$。这确保了 $w(Pe)$ 满足 $w(0)=0$ 和 $w'(0)=0$。\n2.  对于 $y \\ge 0$，$w(y)$ 是非递减的。\n3.  $\\lim_{y \\to \\infty} w(y) = 1$。\n4.  在 $y_c = Pe_c^2 = 2^2 = 4$ 处，$w(y_c) = 1/2$。\n\n我们寻找最简有理函数 $w(y) = P(y)/Q(y)$。\n一次多项式的比值为 $w(y) = \\frac{Ay+B}{Cy+D}$。\n从 $w(0)=0$ 得到 $B/D = 0$，这意味着 $B=0$（假设 $D \\neq 0$）。因此，$w(y)=\\frac{Ay}{Cy+D}$。\n从 $\\lim_{y \\to \\infty} w(y) = 1$ 得到 $A/C=1$，所以我们可以设 $A=C$。形式变为 $w(y) = \\frac{Ay}{Ay+D}$。\n假设 $A \\neq 0$，我们可以将分子和分母同除以 $A$ 得到 $w(y) = \\frac{y}{y+k}$，其中 $k=D/A$。这是 $y$ 的最简有理形式，满足 $w(0)=0$ 和无穷远处的极限。\n\n让我们检查 $w(y) = \\frac{y}{y+k}$ 的其他约束条件：\n-   对于小的 $y$ 的行为：$w(y) = \\frac{y}{k(1+y/k)} \\approx \\frac{y}{k}$。这是 $y$ 的线性函数，满足约束 1。\n-   单调性：导数为 $\\frac{dw}{dy} = \\frac{(y+k) \\cdot 1 - y \\cdot 1}{(y+k)^2} = \\frac{k}{(y+k)^2}$。为了使它在 $y \\ge 0$ 时为非负，我们需要 $k \\ge 0$。如果 $k=0$，$w(y)$ 是不连续的，所以我们要求 $k0$。\n\n最后的约束是阈值处的值，$w(4) = 1/2$：\n$$ w(4) = \\frac{4}{4+k} = \\frac{1}{2} $$\n$$ 8 = 4+k \\implies k=4 $$\n因此，常数 $k$ 为 $4$。将其代回 $w(y)$ 的公式得到：\n$$ w(y) = \\frac{y}{y+4} $$\n最后，我们将 $y=Pe^2$ 代回以获得 $w(Pe)$ 的表达式：\n$$ w(Pe) = \\frac{Pe^2}{Pe^2+4} $$\n这个函数满足所有指定条件。它是一个光滑的、单调的（$|Pe| \\ge 0$）、偶函数，从 $Pe=0$ 处的 CDS ($w=0$) 混合到 $|Pe| \\to \\infty$ 时的 UDS ($w=1$)，同时满足特定的阈值条件并确保在 $Pe=0$ 附近具有二阶精度。",
            "answer": "$$\n\\boxed{\\frac{Pe^2}{Pe^2+4}}\n$$"
        },
        {
            "introduction": "在掌握了设计光滑混合函数的原理后，现在是时候将其应用于更具挑战性的实际场景了。本练习要求你在一个二维有限体积法框架下，为一个稳态对流扩散问题实现一个基于幂律函数的光滑混合格式。我们选择了一个二维旋转流场作为测试案例，该流场中佩克莱数 $Pe$ 的大小和方向在整个计算域内连续变化，这对格式的稳定性和一致性提出了严峻考验。通过使用“制造解方法”，你不仅能验证代码的正确性，还能定量分析该高级格式在复杂流动条件下的准确性和鲁棒性。",
            "id": "3404968",
            "problem": "您的任务是设计并实现一个定向混合差分格式，该格式使用一个平滑的、基于幂律的权重，在中心差分和迎风差分之间进行混合。该权重与面法向对流通量的符号和定向佩克莱数显式相关。控制方程为标量 $\\,\\phi(x,y)\\,$ 的稳态二维对流扩散方程，\n$$\n\\boldsymbol{b}(x,y)\\cdot\\nabla \\phi(x,y) \\;=\\; \\nu \\,\\nabla^2 \\phi(x,y) \\;+\\; s(x,y),\n$$\n其中 $\\boldsymbol{b}(x,y)$ 是一个给定的速度场，$\\nu$ 是扩散系数，$s(x,y)$ 是一个源项。在方形域 $[0,1]\\times[0,1]$ 上，使用有限体积法 (FVM) 在均匀笛卡尔网格上求解，并采用狄利克雷边界条件。速度场是围绕域中心 $(x_0,y_0)=(0.5,0.5)$ 的刚体旋转，\n$$\n\\boldsymbol{b}(x,y) \\;=\\; \\omega\\,\\big(-\\,(y-y_0),\\,x-x_0\\big),\n$$\n角速度为 $\\,\\omega\\,$。精确的制造解为\n$$\n\\phi_{\\text{exact}}(x,y) \\;=\\; \\cos\\!\\big(2\\pi x\\big)\\,\\cos\\!\\big(2\\pi y\\big),\n$$\n其梯度和拉普拉斯算子为\n$$\n\\nabla \\phi_{\\text{exact}}(x,y) \\;=\\; \\Big(-2\\pi\\sin(2\\pi x)\\cos(2\\pi y),\\,-2\\pi\\cos(2\\pi x)\\sin(2\\pi y)\\Big),\n$$\n$$\n\\nabla^2 \\phi_{\\text{exact}}(x,y) \\;=\\; -8\\pi^2\\,\\cos\\!\\big(2\\pi x\\big)\\,\\cos\\!\\big(2\\pi y\\big).\n$$\n根据制造解方法定义源项，以使 $\\,\\phi_{\\text{exact}}\\,$ 满足该偏微分方程：\n$$\ns(x,y) \\;=\\; \\boldsymbol{b}(x,y)\\cdot\\nabla \\phi_{\\text{exact}}(x,y) \\;-\\; \\nu \\,\\nabla^2 \\phi_{\\text{exact}}(x,y).\n$$\n\n在每个大小为 $\\,\\Delta x \\times \\Delta y\\,$ 的控制体积上离散方程的积分形式。对于每个控制体积面 $\\,f\\,$，令 $\\,\\mathbf{n}_f\\,$ 为从主单元指出的单位外法向量，$\\,A_f\\,$ 为面的面积。面对流通量为 $\\,F_f = (\\boldsymbol{b}\\cdot\\mathbf{n}_f)\\,A_f\\,$，扩散传导系数为 $\\,D_f = \\nu\\,A_f/h_f\\,$，其中 $\\,h_f\\,$ 是法向上的单元尺寸（即，对于东/西面，$\\,h_f=\\Delta x\\,$；对于南/北面，$\\,h_f=\\Delta y\\,$）。面上的定向佩克莱数为\n$$\nP_f \\;=\\; \\frac{\\boldsymbol{b}\\cdot\\mathbf{n}_f}{\\nu}\\,h_f.\n$$\n\n您必须按如下方式构建定向混合格式：\n- 定义一个平滑的幂律权重 $\\,\\beta(|P_f|)\\in[0,1]\\,$：\n$$\n\\beta(|P_f|) \\;=\\; 1 \\;-\\; \\max\\!\\Big(0,\\,\\big(1 - 0.1\\,|P_f|\\big)^5\\Big).\n$$\n当 $\\,|P_f|\\approx 0\\,$ 时，该函数表现为中心差分；随着 $\\,|P_f|\\,$ 增大，该函数趋向于完全迎风，这与一维对流扩散方程的经典幂律差分格式一致。\n- 令 $\\,\\phi_{\\text{c}}\\,$ 为中心差分的面值，$\\,\\phi_{\\text{c}} = \\tfrac{1}{2}\\big(\\phi_{\\text{owner}}+\\phi_{\\text{neighbor}}\\big)\\,$。令 $\\,\\phi_{\\text{up}}\\,$ 为由 $\\,F_f\\,$ 符号选择的迎风值：如果 $\\,F_f0\\,$，则 $\\,\\phi_{\\text{up}}=\\phi_{\\text{owner}}\\,$；如果 $\\,F_f0\\,$，则 $\\,\\phi_{\\text{up}}=\\phi_{\\text{neighbor}}\\,$。\n- 进行定向混合：\n$$\n\\phi_f \\;=\\; (1-\\beta(|P_f|))\\,\\phi_{\\text{c}} \\;+\\; \\beta(|P_f|)\\,\\phi_{\\text{up}}.\n$$\n这必须转化为作用于主单元值和相邻单元值的线性权重。对于 $\\,F_f0\\,$，得到的面插值权重为\n$$\nc_{P,f} \\;=\\; \\frac{1+\\beta(|P_f|)}{2},\\qquad c_{N,f} \\;=\\; \\frac{1-\\beta(|P_f|)}{2},\n$$\n对于 $\\,F_f0\\,$，\n$$\nc_{P,f} \\;=\\; \\frac{1-\\beta(|P_f|)}{2},\\qquad c_{N,f} \\;=\\; \\frac{1+\\beta(|P_f|)}{2}.\n$$\n因此，$\\,\\phi_f = c_{P,f}\\,\\phi_{\\text{owner}} + c_{N,f}\\,\\phi_{\\text{neighbor}}\\,$。使用这些面值 $\\,\\phi_f\\,$ 构成对流通量，并使用两点中心差分计算扩散通量。\n\n为未知的内部单元值 $\\,\\phi\\,$ 组装线性系统，其中狄利克雷边界条件由域边界上的 $\\,\\phi_{\\text{exact}}\\,$ 指定。求解得到的稀疏线性系统以获得数值解 $\\,\\phi_{\\text{num}}\\,$，并评估以下定量指标：\n\n- 内部单元上的离散 $L^2$ 误差，\n$$\nE_2 \\;=\\; \\sqrt{ \\frac{\\sum_{P} \\big(\\phi_{\\text{num},P} - \\phi_{\\text{exact},P}\\big)^2\\,\\Delta x\\,\\Delta y}{\\sum_{P} \\Delta x\\,\\Delta y} }.\n$$\n- 迎风一致性布尔值 $\\,C\\,$：如果对于所有内部面，迎风侧的插值权重总是较大，则该值为真。即，对于每个面 $\\,f\\,$，$\\,F_f0\\Rightarrow c_{P,f}\\ge c_{N,f}\\,$ 且 $\\,F_f0\\Rightarrow c_{N,f}\\ge c_{P,f}\\,$。\n- 零附近佩克莱数的光滑性布尔值 $\\,S\\,$：考虑所有满足 $\\,|P_f|\\le \\varepsilon\\,$（其中 $\\,\\varepsilon=0.2\\,$）的内部面。计算 $\\,\\delta_f=\\big|c_{P,f}-c_{N,f}\\big|\\,$，并令 $\\,\\delta_{\\max}\\,$ 为这些面上 $\\,\\delta_f\\,$ 的最大值。如果 $\\,\\delta_{\\max}\\le 0.05\\,$，则将 $\\,S\\,$ 设为真。\n\n实现上述格式，并在以下参数集 $(N_x,N_y,\\nu,\\omega)$ 的测试套件上进行评估，其中 $\\,N_x\\,$ 和 $\\,N_y\\,$ 分别是 $x$ 和 $y$ 方向上的单元数：\n- 测试 $\\,1\\,$ (理想情况，中等定向佩克莱数): $\\,N_x=N_y=40\\,$, $\\,\\nu=0.02\\,$, $\\,\\omega=10.0\\,$。\n- 测试 $\\,2\\,$ (对流主导，大定向佩克莱数且符号变化): $\\,N_x=N_y=40\\,$, $\\,\\nu=0.005\\,$, $\\,\\omega=20.0\\,$。\n- 测试 $\\,3\\,$ (扩散主导，定向佩克莱数接近零): $\\,N_x=N_y=40\\,$, $\\,\\nu=1.0\\,$, $\\,\\omega=5.0\\,$。\n- 测试 $\\,4\\,$ (粗网格，极大定向佩克莱数): $\\,N_x=N_y=24\\,$, $\\,\\nu=0.005\\,$, $\\,\\omega=40.0\\,$。\n\n您的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表。每个测试用例应产生一个三元组 $[E_2,C,S]$。因此，最终输出应是一个包含四个三元组的单一列表，不含空格，例如：\n$$\n[ [E_{2,1},C_1,S_1], [E_{2,2},C_2,S_2], [E_{2,3},C_3,S_3], [E_{2,4},C_4,S_4] ].\n$$\n所有量均为无量纲；将 $\\,E_2\\,$ 报告为浮点数，$\\,C,S\\,$ 报告为布尔值。最终的单行输出不得包含指定列表之外的任何附加文本。",
            "solution": "该问题要求实现一种有限体积法（FVM），以求解单位正方形上的稳态二维对流扩散方程。离散格式是一种特定的定向混合格式，它基于局部面佩克莱数的幂律函数来混合中心差分和迎风差分。使用制造解方法进行验证。\n\n控制方程在一个控制体积 $V_P$ 上的积分形式为\n$$\n\\int_{\\partial V_P} (\\boldsymbol{b}\\phi - \\nu\\nabla\\phi) \\cdot \\mathbf{n} \\, dA = \\int_{V_P} s \\, dV\n$$\n在笛卡尔网格上离散此方程，对于单元P及其相邻单元（东E、西W、北N、南S），会得到一个线性代数方程。我们对控制体积各个面上的通量求和：\n$$\nJ_e - J_w + J_n - J_s = \\bar{s}_P \\Delta x \\Delta y\n$$\n其中 $J_f$ 是通过面 $f$ 流出单元P的总通量（对流+扩散），$\\bar{s}_P$ 是单元P中的平均源项。面通量沿正坐标方向定义。例如，通过东面 $e$ 的通量为\n$$\nJ_e = F_e \\phi_e - D_e (\\phi_E - \\phi_P)\n$$\n在此，$F_e = u_e \\Delta y$ 是对流通量强度，$D_e = \\nu \\Delta y / \\Delta x$ 是扩散传导系数。问题的核心在于定义面值 $\\phi_e$。问题指定了一种定向混合格式：\n$$\n\\phi_f = c_{P,f} \\phi_P + c_{N,f} \\phi_N\n$$\n其中 P 是“主”单元，N 是“相邻”单元。插值权重 $c_{P,f}$ 和 $c_{N,f}$ 是混合因子 $\\beta(|P_f|)$ 的函数，而混合因子又依赖于面佩克莱数 $P_f = F_f h_f / (\\nu A_f)$。其定义如下：\n- 如果 $F_f  0$（从P流向N）：$c_{P,f} = \\frac{1+\\beta}{2}$，$c_{N,f} = \\frac{1-\\beta}{2}$。\n- 如果 $F_f  0$（从N流向P）：$c_{P,f} = \\frac{1-\\beta}{2}$，$c_{N,f} = \\frac{1+\\beta}{2}$。\n注意 $c_{P,f} + c_{N,f} = 1$。\n\n通过将 $\\phi_e$ 的表达式代入通量方程 $J_e$，我们可以推导出线性系统的系数。通量 $J_e$ 对单元P的主对角线系数和单元E的非对角线系数有贡献。单元P的方程结构如下：\n$$\na_P \\phi_P = a_E \\phi_E + a_W \\phi_W + a_N \\phi_N + a_S \\phi_S + S_u\n$$\n其中 $S_u = \\bar{s}_P \\Delta x \\Delta y$ 是源项部分。非对角线系数由通量表达式导出。例如，穿过P和E之间面 $e$ 的通量为 $J_e$。该通量对单元P的平衡方程的总贡献为 $J_e = (F_e c_{P,e} + D_e)\\phi_P - (D_e - F_e c_{E,e})\\phi_E$。\n这给出了相邻单元 $E$ 的系数为 $a_E = D_e - F_e c_{E,e}$。类似地，对于 $W$ 和 $P$ 之间的西面 $w$，通量为 $J_w = F_w \\phi_w - D_w(\\phi_P-\\phi_W)$。它对平衡的贡献是 $-J_w$。相邻单元 $W$ 的系数是 $a_W = D_w + F_w c_{W,w}$。同样的逻辑适用于面 $n$ 和 $s$。\n主对角线系数 $a_P$ 是来自所有面的贡献之和：\n$$\na_P = (F_e c_{P,e} + D_e) + (D_w - F_w c_{P,w}) + (F_n c_{P,n} + D_n) + (D_s - F_s c_{P,s})\n$$\n速度场 $\\boldsymbol{b}$ 是无散度的（$\\nabla \\cdot \\boldsymbol{b} = 0$）。对于均匀网格，这意味着流出一个单元的离散化对流通量之和 $F_e - F_w + F_n - F_s$ 为零。利用这一点以及 $c_{P,f}+c_{N,f}=1$，可以证明 $a_P = a_E+a_W+a_N+a_S$。此属性确保了所得矩阵的对角占优性，这对于迭代求解器的稳定性和收敛性至关重要，尽管我们将使用直接求解器。\n\n实现步骤如下：\n1.  对于每个测试用例，设置网格和物理参数。\n2.  为制造解、速度场和源项定义辅助函数。\n3.  为线性系统 $A\\phi=B$ 初始化一个稀疏矩阵 `A` 和一个右端向量 `B`。\n4.  遍历所有内部网格单元 $(i, j)$。对每个单元，计算矩阵系数 $a_P, a_E, a_W, a_N, a_S$。\n5.  填充矩阵 `A` 和向量 `B`。对于边界上的相邻单元，其已知的 $\\phi$ 值（来自 $\\phi_{\\text{exact}}$）贡献到 `B` 向量中。\n6.  在填充矩阵的同时，在所有内部面上评估布尔指标 $C$（迎风一致性）和 $S$（光滑性）的条件。\n7.  求解稀疏线性系统，得到未知的内部 $\\phi$ 值。\n8.  构建完整的数值解网格，包括边界。\n9.  通过将数值解与内部单元中心的精确解进行比较，计算 $L^2$ 误差 $E_2$。\n10. 最终确定布尔指标 $C$ 和 $S$，并收集结果。\n\n此过程被系统地应用于每个测试用例，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D steady convection-diffusion equation using a finite volume\n    method with a directional power-law hybrid differencing scheme.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, nu, omega)\n        (40, 40, 0.02, 10.0),\n        (40, 40, 0.005, 20.0),\n        (40, 40, 1.0, 5.0),\n        (24, 24, 0.005, 40.0),\n    ]\n\n    results_list = []\n    \n    for Nx, Ny, nu, omega in test_cases:\n        # Domain and Grid Setup\n        Lx, Ly = 1.0, 1.0\n        dx, dy = Lx / Nx, Ly / Ny\n        x_centers = np.linspace(dx/2, Lx - dx/2, Nx)\n        y_centers = np.linspace(dy/2, Ly - dy/2, Ny)\n        x_faces = np.linspace(0, Lx, Nx + 1)\n        y_faces = np.linspace(0, Ly, Ny + 1)\n\n        # Problem-specific functions\n        x0, y0 = 0.5, 0.5\n        \n        def phi_exact(x, y):\n            return np.cos(2 * np.pi * x) * np.cos(2 * np.pi * y)\n\n        def velocity(x, y):\n            u = omega * (-(y - y0))\n            v = omega * (x - x0)\n            return u, v\n\n        def source_term(x, y):\n            # Gradient of phi_exact\n            dphidx = -2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n            dphidy = -2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n            # Laplacian of phi_exact\n            d2phidx2 = -4 * np.pi**2 * np.cos(2 * np.pi * x) * np.cos(2 * np.pi * y)\n            d2phidy2 = -4 * np.pi**2 * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n            lap_phi = d2phidx2 + d2phidy2\n            \n            u, v = velocity(x, y)\n            conv_term = u * dphidx + v * dphidy\n            diff_term = nu * lap_phi\n            return conv_term - diff_term\n\n        def beta_func(P_abs):\n            return 1.0 - np.maximum(0.0, (1.0 - 0.1 * P_abs)**5)\n\n        # Assembly of the linear system\n        num_interior_cells = (Nx - 2) * (Ny - 2)\n        A = lil_matrix((num_interior_cells, num_interior_cells), dtype=np.float64)\n        B = np.zeros(num_interior_cells, dtype=np.float64)\n\n        # Metric-related variables\n        is_consistent_C = True\n        max_delta_S = 0.0\n\n        for j in range(1, Ny - 1):\n            for i in range(1, Nx - 1):\n                k_P = (i - 1) + (j - 1) * (Nx - 2)\n                \n                # Cell P information\n                x_P, y_P = x_centers[i], y_centers[j]\n\n                # Source term\n                s_P = source_term(x_P, y_P)\n                Su = s_P * dx * dy\n\n                # Coefficients\n                a_P = 0.0\n\n                # --- East Face (e) ---\n                x_e, y_e = x_faces[i + 1], y_centers[j]\n                u_e, _ = velocity(x_e, y_e)\n                F_e = u_e * dy\n                D_e = nu * dy / dx\n                P_e = u_e * dx / nu\n                beta_e = beta_func(np.abs(P_e))\n                # Weights c_P,f and c_N,f for face e\n                c_Pe = (1 + beta_e * np.sign(F_e)) / 2 if F_e != 0 else 0.5\n                c_Ee = (1 - beta_e * np.sign(F_e)) / 2 if F_e != 0 else 0.5\n                \n                a_E_contr = D_e - F_e * c_Ee\n                a_P += D_e + F_e * c_Pe\n\n                if i == Nx - 2: # Boundary neighbor\n                    phi_E = phi_exact(x_centers[i+1], y_centers[j])\n                    Su += a_E_contr * phi_E\n                else: # Interior neighbor\n                    k_E = (i) + (j - 1) * (Nx - 2)\n                    A[k_P, k_E] = -a_E_contr\n                    # Check metrics C and S for this interior face\n                    if not ((F_e > 0 and c_Pe >= c_Ee) or (F_e  0 and c_Ee >= c_Pe) or F_e == 0):\n                        is_consistent_C = False\n                    if np.abs(P_e) = 0.2:\n                        delta_f = np.abs(c_Pe - c_Ee)\n                        max_delta_S = max(max_delta_S, delta_f)\n\n                # --- West Face (w) ---\n                x_w, y_w = x_faces[i], y_centers[j]\n                u_w, _ = velocity(x_w, y_w)\n                F_w = u_w * dy\n                D_w = nu * dy / dx\n                # For face w, P is the neighbor and W is the owner\n                P_w = u_w * dx / nu # P_w is wrt to face normal, which points west\n                beta_w = beta_func(np.abs(P_w))\n                # F_w has sign wrt positive x. Owner is W, neighbor is P.\n                c_Ww = (1 + beta_w * np.sign(F_w)) / 2 if F_w != 0 else 0.5\n                c_Pw = (1 - beta_w * np.sign(F_w)) / 2 if F_w != 0 else 0.5\n                \n                a_W_contr = D_w + F_w * c_Ww\n                a_P += D_w - F_w * c_Pw\n\n                if i == 1: # Boundary neighbor\n                    phi_W = phi_exact(x_centers[i-1], y_centers[j])\n                    Su += a_W_contr * phi_W\n                else:\n                    k_W = (i - 2) + (j - 1) * (Nx - 2)\n                    A[k_P, k_W] = -a_W_contr\n                \n                # --- North Face (n) ---\n                x_n, y_n = x_centers[i], y_faces[j + 1]\n                _, v_n = velocity(x_n, y_n)\n                F_n = v_n * dx\n                D_n = nu * dx / dy\n                P_n = v_n * dy / nu\n                beta_n = beta_func(np.abs(P_n))\n                c_Pn = (1 + beta_n * np.sign(F_n)) / 2 if F_n != 0 else 0.5\n                c_Nn = (1 - beta_n * np.sign(F_n)) / 2 if F_n != 0 else 0.5\n\n                a_N_contr = D_n - F_n * c_Nn\n                a_P += D_n + F_n * c_Pn\n\n                if j == Ny - 2: # Boundary neighbor\n                    phi_N = phi_exact(x_centers[i], y_centers[j+1])\n                    Su += a_N_contr * phi_N\n                else:\n                    k_N = (i - 1) + (j) * (Nx - 2)\n                    A[k_P, k_N] = -a_N_contr\n                    # Check metrics C and S for this interior face\n                    if not ((F_n > 0 and c_Pn >= c_Nn) or (F_n  0 and c_Nn >= c_Pn) or F_n == 0):\n                        is_consistent_C = False\n                    if np.abs(P_n) = 0.2:\n                        delta_f = np.abs(c_Pn - c_Nn)\n                        max_delta_S = max(max_delta_S, delta_f)\n\n                # --- South Face (s) ---\n                x_s, y_s = x_centers[i], y_faces[j]\n                _, v_s = velocity(x_s, y_s)\n                F_s = v_s * dx\n                D_s = nu * dx / dy\n                P_s = v_s * dy / nu\n                beta_s = beta_func(np.abs(P_s))\n                # For face s, P is neighbor, S is owner\n                c_Ss = (1 + beta_s * np.sign(F_s)) / 2 if F_s != 0 else 0.5\n                c_Ps = (1 - beta_s * np.sign(F_s)) / 2 if F_s != 0 else 0.5\n\n                a_S_contr = D_s + F_s * c_Ss\n                a_P += D_s - F_s * c_Ps\n\n                if j == 1: # Boundary neighbor\n                    phi_S = phi_exact(x_centers[i], y_centers[j-1])\n                    Su += a_S_contr * phi_S\n                else:\n                    k_S = (i - 1) + (j - 2) * (Nx - 2)\n                    A[k_P, k_S] = -a_S_contr\n                \n                A[k_P, k_P] = a_P\n                B[k_P] = Su\n\n        # Solve system\n        phi_interior_1d = spsolve(A.tocsc(), B)\n        phi_num_interior = phi_interior_1d.reshape((Ny - 2, Nx - 2))\n\n        # Calculate metrics\n        phi_exact_interior = np.zeros_like(phi_num_interior)\n        for j in range(Ny - 2):\n            for i in range(Nx - 2):\n                phi_exact_interior[j, i] = phi_exact(x_centers[i+1], y_centers[j+1])\n        \n        # E2 error\n        sum_sq_err = np.sum((phi_num_interior - phi_exact_interior)**2)\n        E2 = np.sqrt(sum_sq_err * dx * dy / (Lx*Ly - 2*Lx*dy - 2*Ly*dx + 4*dx*dy))\n\n        # C and S booleans\n        C = is_consistent_C\n        S = max_delta_S = 0.05\n        \n        results_list.append(f\"[{E2:.10f},{str(C).lower()},{str(S).lower()}]\")\n\n    print(f\"[[{','.join(results_list)}]]\")\n\n# The provided code snippet has a logic error in the output formatting.\n# The expected output is [[E2_1,C1,S1],[E2_2,C2,S2],...], which requires joining\n# the list of strings with commas.\n# Let's adjust the wrapper to produce the exact format.\ndef solve_wrapper():\n    test_cases = [\n        (40, 40, 0.02, 10.0), (40, 40, 0.005, 20.0),\n        (40, 40, 1.0, 5.0), (24, 24, 0.005, 40.0)\n    ]\n    all_results = []\n    for params in test_cases:\n        E2, C, S = run_single_case(*params)\n        all_results.append(f\"[{E2:.10f},{str(C).lower()},{str(S).lower()}]\")\n    print(f\"[{','.join(all_results)}]\")\n\ndef run_single_case(Nx, Ny, nu, omega):\n    Lx, Ly = 1.0, 1.0\n    dx, dy = Lx / Nx, Ly / Ny\n    x_centers = np.linspace(dx / 2, Lx - dx / 2, Nx)\n    y_centers = np.linspace(dy / 2, Ly - dy / 2, Ny)\n    x_faces = np.linspace(0, Lx, Nx + 1)\n    y_faces = np.linspace(0, Ly, Ny + 1)\n    x0, y0 = 0.5, 0.5\n    \n    def phi_exact(x, y): return np.cos(2 * np.pi * x) * np.cos(2 * np.pi * y)\n    def velocity(x, y): return omega * (-(y - y0)), omega * (x - x0)\n    def source_term(x, y):\n        u, v = velocity(x, y)\n        dphidx = -2 * np.pi * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)\n        dphidy = -2 * np.pi * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        lap_phi = -8 * np.pi**2 * phi_exact(x,y)\n        return u * dphidx + v * dphidy - nu * lap_phi\n    def beta_func(P_abs): return 1.0 - np.maximum(0.0, (1.0 - 0.1 * P_abs)**5)\n\n    num_interior_cells = (Nx - 2) * (Ny - 2)\n    A = lil_matrix((num_interior_cells, num_interior_cells))\n    B = np.zeros(num_interior_cells)\n    \n    is_consistent_C = True\n    max_delta_S = 0.0\n    \n    for j in range(1, Ny - 1):\n        for i in range(1, Nx - 1):\n            k_P = (i - 1) + (j - 1) * (Nx - 2)\n            x_P, y_P = x_centers[i], y_centers[j]\n            Su = source_term(x_P, y_P) * dx * dy\n            a_P = 0.0\n\n            # East face\n            u_e, _ = velocity(x_faces[i + 1], y_centers[j]); F_e = u_e * dy; D_e = nu * dy / dx; P_e = u_e * dx / nu\n            beta_e = beta_func(abs(P_e)); c_Pe = (1 + beta_e * np.sign(F_e))/2 if F_e != 0 else 0.5; c_Ee = 1 - c_Pe\n            a_E_contr = D_e - F_e * c_Ee; a_P += D_e + F_e * c_Pe\n            if i == Nx - 2: Su += a_E_contr * phi_exact(x_centers[i + 1], y_centers[j])\n            else:\n                A[k_P, k_P + 1] = -a_E_contr\n                if not ((F_e >= 0 and c_Pe >= c_Ee) or (F_e  0 and c_Ee >= c_Pe)): is_consistent_C = False\n                if abs(P_e) = 0.2: max_delta_S = max(max_delta_S, abs(c_Pe - c_Ee))\n            \n            # West face\n            u_w, _ = velocity(x_faces[i], y_centers[j]); F_w = u_w * dy; D_w = nu * dy / dx; P_w = u_w * dx / nu\n            beta_w = beta_func(abs(P_w)); c_Ww = (1 + beta_w * np.sign(F_w))/2 if F_w != 0 else 0.5; c_Pw = 1 - c_Ww\n            a_W_contr = D_w + F_w * c_Ww; a_P += D_w - F_w * c_Pw\n            if i == 1: Su += a_W_contr * phi_exact(x_centers[i-1], y_centers[j])\n            else: A[k_P, k_P - 1] = -a_W_contr\n\n            # North face\n            _, v_n = velocity(x_centers[i], y_faces[j + 1]); F_n = v_n * dx; D_n = nu * dx / dy; P_n = v_n * dy / nu\n            beta_n = beta_func(abs(P_n)); c_Pn = (1 + beta_n * np.sign(F_n))/2 if F_n != 0 else 0.5; c_Nn = 1 - c_Pn\n            a_N_contr = D_n - F_n * c_Nn; a_P += D_n + F_n * c_Pn\n            if j == Ny - 2: Su += a_N_contr * phi_exact(x_centers[i], y_centers[j+1])\n            else:\n                A[k_P, k_P + (Nx - 2)] = -a_N_contr\n                if not ((F_n >= 0 and c_Pn >= c_Nn) or (F_n  0 and c_Nn >= c_Pn)): is_consistent_C = False\n                if abs(P_n) = 0.2: max_delta_S = max(max_delta_S, abs(c_Pn - c_Nn))\n\n            # South face\n            _, v_s = velocity(x_centers[i], y_faces[j]); F_s = v_s * dx; D_s = nu * dx / dy; P_s = v_s * dy / nu\n            beta_s = beta_func(abs(P_s)); c_Ss = (1 + beta_s * np.sign(F_s))/2 if F_s != 0 else 0.5; c_Ps = 1 - c_Ss\n            a_S_contr = D_s + F_s * c_Ss; a_P += D_s - F_s * c_Ps\n            if j == 1: Su += a_S_contr * phi_exact(x_centers[i], y_centers[j-1])\n            else: A[k_P, k_P - (Nx - 2)] = -a_S_contr\n                \n            A[k_P, k_P] = a_P; B[k_P] = Su\n\n    phi_sol = spsolve(A.tocsc(), B).reshape((Ny-2, Nx-2))\n    \n    phi_ex = np.array([[phi_exact(x_centers[i+1], y_centers[j+1]) for i in range(Nx-2)] for j in range(Ny-2)])\n    E2 = np.sqrt(np.sum((phi_sol - phi_ex)**2) / num_interior_cells)\n    \n    C = is_consistent_C\n    S = max_delta_S = 0.05\n    return E2, C, S\n\nif __name__ == '__main__':\n    solve_wrapper()\n\n```"
        }
    ]
}