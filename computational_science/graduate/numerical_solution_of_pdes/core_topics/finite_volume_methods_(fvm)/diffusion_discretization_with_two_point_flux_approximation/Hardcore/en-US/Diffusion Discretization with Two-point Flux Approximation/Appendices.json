{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Two-Point Flux Approximation (TPFA) method lies in a simple yet powerful concept: transmissibility. This first exercise takes you back to first principles, guiding you to derive the core TPFA transmissibility formula for a pair of adjacent control volumes from the fundamental laws of diffusion . By performing this derivation and a subsequent sensitivity analysis, you will gain a deep appreciation for the underlying assumptions—such as the one-dimensional flux path—and understand how geometric and material properties quantitatively influence the discrete connection between cells.",
            "id": "3377678",
            "problem": "Consider the steady-state diffusion equation in a heterogeneous medium with isotropic, piecewise constant conductivity, expressed as $\\nabla \\cdot (k \\nabla u) = 0$, where $u$ is the scalar potential (for example, temperature in Kelvin (K)) and $k$ is the conductivity (for example, thermal conductivity in watts per meter-kelvin ($\\text{W}/(\\text{m}\\cdot \\text{K})$)). Two neighboring convex control volumes (cells), indexed by $i$ and $j$, share a flat interface (face) with area $|F|$ in square meters ($\\text{m}^2$). Let $d_i$ and $d_j$ be the perpendicular distances, in meters ($\\text{m}$), from the centers of cells $i$ and $j$ to the shared face along its normal direction. Assume the two-point flux approximation applies: the potential $u$ varies linearly along the line connecting the two cell centers, and the flux across the face can be represented using a scalar transmissibility coupling the two cell-center unknowns.\n\nStarting from the fundamental conservation law and Fick/Fourier-type constitutive relation $q = -k \\nabla u$, derive the transmissibility between cells $i$ and $j$ across face $F$ under the above assumptions. Express the flux $q_F$ across $F$ as $q_F = -T_{ij}(u_j - u_i)$ and obtain a closed-form expression for $T_{ij}$ in terms of $|F|$, $d_i$, $d_j$, $k_i$, and $k_j$, where $k_i$ and $k_j$ are the constant isotropic conductivities in cells $i$ and $j$, respectively. Clearly justify each step using the governing equations and interface conditions, without invoking any shortcut formulas that presuppose the final result.\n\nNext, analyze the sensitivity of the transmissibility with respect to perturbations in $d_i$ and $d_j$. Define the partial derivatives $\\frac{\\partial T_{ij}}{\\partial d_i}$ and $\\frac{\\partial T_{ij}}{\\partial d_j}$, and the dimensionless relative sensitivities\n$$\nS_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}, \\quad S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}.\n$$\nValidate the analytical sensitivities by comparing them against central-difference finite-difference approximations computed from small relative perturbations of $d_i$ and $d_j$.\n\nUse the following test suite of parameter sets to evaluate $T_{ij}$, $S_{d_i}$, $S_{d_j}$, the relative errors between analytical and numerical derivatives, and boolean indicators of agreement within tolerance. For all cases, interpret $k$ in watts per meter-kelvin ($\\text{W}/(\\text{m}\\cdot \\text{K})$), $|F|$ in square meters ($\\text{m}^2$), $d_i$ and $d_j$ in meters ($\\text{m}$), and report $T_{ij}$ in watts per kelvin ($\\text{W}/\\text{K}$). The derivative comparison tolerance should be set to $10^{-9}$ relative error. Use a central-difference step equal to $10^{-8}$ times the nominal distance for each derivative.\n\nTest suite:\n- Case A (general asymmetric): $|F| = 1.2$, $d_i = 0.5$, $d_j = 0.4$, $k_i = 2.0$, $k_j = 4.0$.\n- Case B (symmetric distances and conductivities): $|F| = 2.0$, $d_i = 0.5$, $d_j = 0.5$, $k_i = 1.0$, $k_j = 1.0$.\n- Case C (high contrast conductivities): $|F| = 1.0$, $d_i = 0.1$, $d_j = 0.1$, $k_i = 10.0$, $k_j = 0.1$.\n- Case D (thin-thick pair, equal conductivities): $|F| = 0.5$, $d_i = 10^{-3}$, $d_j = 1.0$, $k_i = 5.0$, $k_j = 5.0$.\n\nYour program must:\n1. Compute $T_{ij}$, $S_{d_i}$, $S_{d_j}$ for each case.\n2. Approximate $\\frac{\\partial T_{ij}}{\\partial d_i}$ and $\\frac{\\partial T_{ij}}{\\partial d_j}$ using central differences with the specified perturbation sizes.\n3. Report the relative error of the numerical derivatives with respect to the analytical ones.\n4. Return boolean flags indicating whether each relative error is less than or equal to $10^{-9}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry in the list corresponds to one test case and must itself be a list in the format\n$[T_{ij}, S_{d_i}, S_{d_j}, \\text{err}_{d_i}, \\text{err}_{d_j}, \\text{ok}_{d_i}, \\text{ok}_{d_j}]$,\nwhere $T_{ij}$ is in watts per kelvin ($\\text{W}/\\text{K}$), $S_{d_i}$ and $S_{d_j}$ are dimensionless, $\\text{err}_{d_i}$ and $\\text{err}_{d_j}$ are dimensionless relative errors, and the booleans indicate agreement within tolerance. For example: $[[\\dots],[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem is well-posed, scientifically grounded, and provides all necessary information to proceed with a unique solution. It is a standard exercise in the numerical analysis of partial differential equations, specifically within the framework of finite volume methods.\n\nThe primary objective is to derive the transmissibility, $T_{ij}$, between two adjacent control volumes, $i$ and $j$, for a steady-state diffusion process, and subsequently analyze its sensitivity to the geometric parameters $d_i$ and $d_j$.\n\n**Derivation of Transmissibility $T_{ij}$**\n\nThe governing equation is the steady-state diffusion equation:\n$$\n\\nabla \\cdot (k \\nabla u) = 0\n$$\nwhere $u$ is the scalar potential and $k$ is the conductivity. The constitutive relation is Fick's or Fourier's law, which states that the flux vector, $\\vec{q}$, is proportional to the negative gradient of the potential:\n$$\n\\vec{q} = -k \\nabla u\n$$\nWe consider two cells, $i$ and $j$, with constant isotropic conductivities $k_i$ and $k_j$, respectively. They share a flat face $F$ of area $|F|$. The cell centers are located at perpendicular distances $d_i$ and $d_j$ from this face.\n\nThe problem makes a key simplifying assumption known as the Two-Point Flux Approximation (TPFA): the potential $u$ varies linearly along the line connecting the two cell centers. This assumption reduces the problem to a one-dimensional analysis along the normal to the face $F$. Let the coordinate along this normal be $x$, with the face $F$ located at $x=0$. The center of cell $i$ is at $x=-d_i$, and the center of cell $j$ is at $x=d_j$. The potentials at these centers are denoted $u_i = u(-d_i)$ and $u_j = u(d_j)$.\n\nIn this one-dimensional steady-state setting, the governing equation $\\nabla \\cdot \\vec{q} = 0$ simplifies to $\\frac{d q_x}{dx} = 0$, where $q_x$ is the component of flux normal to the face. This implies that $q_x$ is constant along the line segment from $-d_i$ to $d_j$. Let this constant flux density be denoted by $f$.\n$$\nf = q_x = -k(x) \\frac{du}{dx} = \\text{constant}\n$$\nWe can integrate this relation over the two segments corresponding to cell $i$ and cell $j$.\n\n1.  **Segment 1 (within cell $i$): from $x=-d_i$ to $x=0$**\n    The conductivity is $k(x) = k_i$.\n    $$\n    f = -k_i \\frac{du}{dx}\n    $$\n    Integrating from the cell center $i$ to the face $F$:\n    $$\n    \\int_{-d_i}^{0} f \\,dx = \\int_{-d_i}^{0} -k_i \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (0 - (-d_i)) = -k_i (u(0) - u(-d_i))\n    $$\n    Let $u_F = u(0)$ be the potential at the face. Then:\n    $$\n    f d_i = -k_i (u_F - u_i) \\implies u_i - u_F = \\frac{f d_i}{k_i}\n    $$\n\n2.  **Segment 2 (within cell $j$): from $x=0$ to $x=d_j$**\n    The conductivity is $k(x) = k_j$.\n    $$\n    f = -k_j \\frac{du}{dx}\n    $$\n    Integrating from the face $F$ to the cell center $j$:\n    $$\n    \\int_{0}^{d_j} f \\,dx = \\int_{0}^{d_j} -k_j \\frac{du}{dx} \\,dx\n    $$\n    $$\n    f \\cdot (d_j - 0) = -k_j (u(d_j) - u(0))\n    $$\n    $$\n    f d_j = -k_j (u_j - u_F) \\implies u_F - u_j = \\frac{f d_j}{k_j}\n    $$\n\n3.  **Eliminate the face potential $u_F$**\n    We have a system of two linear equations for the potential differences:\n    (1) $u_i - u_F = \\frac{f d_i}{k_i}$\n    (2) $u_F - u_j = \\frac{f d_j}{k_j}$\n    Adding these two equations eliminates the unknown face potential $u_F$:\n    $$\n    (u_i - u_F) + (u_F - u_j) = \\frac{f d_i}{k_i} + \\frac{f d_j}{k_j}\n    $$\n    $$\n    u_i - u_j = f \\left( \\frac{d_i}{k_i} + \\frac{d_j}{k_j} \\right)\n    $$\n    Rearranging to solve for the flux density $f$:\n    $$\n    f = \\frac{u_i - u_j}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} = - \\frac{u_j - u_i}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n\n4.  **Determine Transmissibility $T_{ij}$**\n    The total flux $q_F$ through the face $F$ is the flux density $f$ multiplied by the area $|F|$. The flux is directed from high potential to low potential. The problem defines $q_F$ such that it is positive for flow from cell $i$ to cell $j$ if $u_i > u_j$.\n    $$\n    q_F = f \\cdot |F| = -\\left( \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}} \\right) (u_j - u_i)\n    $$\n    Comparing this with the given definition $q_F = -T_{ij}(u_j - u_i)$, we identify the transmissibility $T_{ij}$ as:\n    $$\n    T_{ij} = \\frac{|F|}{\\frac{d_i}{k_i} + \\frac{d_j}{k_j}}\n    $$\n    This expression represents the conductance between the two cell centers, which is the reciprocal of the total thermal resistance. The terms $d_i/k_i$ and $d_j/k_j$ are analogous to electrical resistances in series. An alternative form is:\n    $$\n    T_{ij} = \\frac{|F| k_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n**Sensitivity Analysis**\n\nWe now derive the partial derivatives of $T_{ij}$ with respect to $d_i$ and $d_j$ and the corresponding dimensionless relative sensitivities.\n\n1.  **Partial Derivative with respect to $d_i$**\n    Using the form $T_{ij} = |F| k_i k_j (d_i k_j + d_j k_i)^{-1}$ and applying the chain rule:\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = |F| k_i k_j \\cdot (-1) (d_i k_j + d_j k_i)^{-2} \\cdot \\frac{\\partial}{\\partial d_i}(d_i k_j + d_j k_i)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = -|F| k_i k_j (d_i k_j + d_j k_i)^{-2} \\cdot (k_j)\n    $$\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_i} = - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2}\n    $$\n\n2.  **Dimensionless Sensitivity $S_{d_i}$**\n    The relative sensitivity $S_{d_i}$ is defined as $S_{d_i} = \\frac{d_i}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_i}$.\n    $$\n    S_{d_i} = \\frac{d_i}{\\frac{|F| k_i k_j}{d_i k_j + d_j k_i}} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    $$\n    S_{d_i} = d_i \\frac{d_i k_j + d_j k_i}{|F| k_i k_j} \\left( - \\frac{|F| k_i k_j^2}{(d_i k_j + d_j k_i)^2} \\right)\n    $$\n    After cancellation of terms, we are left with:\n    $$\n    S_{d_i} = - \\frac{d_i k_j}{d_i k_j + d_j k_i}\n    $$\n\n3.  **Partial Derivative with respect to $d_j$**\n    The expression for $T_{ij}$ is symmetric with respect to swapping the pairs $(d_i, k_i)$ and $(d_j, k_j)$. Therefore, we can obtain the derivative with respect to $d_j$ by performing this swap in the expression for $\\frac{\\partial T_{ij}}{\\partial d_i}$:\n    $$\n    \\frac{\\partial T_{ij}}{\\partial d_j} = - \\frac{|F| k_j k_i^2}{(d_j k_i + d_i k_j)^2} = - \\frac{|F| k_i^2 k_j}{(d_i k_j + d_j k_i)^2}\n    $$\n\n4.  **Dimensionless Sensitivity $S_{d_j}$**\n    Similarly, applying the definition $S_{d_j} = \\frac{d_j}{T_{ij}} \\frac{\\partial T_{ij}}{\\partial d_j}$:\n    $$\n    S_{d_j} = - \\frac{d_j k_i}{d_i k_j + d_j k_i}\n    $$\n    Note that $S_{d_i} + S_{d_j} = - \\frac{d_i k_j + d_j k_i}{d_i k_j + d_j k_i} = -1$. This is consistent with Euler's homogeneous function theorem, as $T_{ij}$ is a function homogeneous of degree $-1$ with respect to the distances $d_i$ and $d_j$.\n\n**Numerical Validation Procedure**\n\nTo validate the analytical derivatives, we use a second-order central-difference formula. For a function $f(x)$, the derivative $f'(x)$ is approximated by:\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h}\n$$\nThe step size $h$ is chosen to be a small fraction of the variable's value. The problem specifies a relative step size of $10^{-8}$.\nFor $\\frac{\\partial T_{ij}}{\\partial d_i}$, the numerical approximation $(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}}$ is:\n$$\n(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} = \\frac{T_{ij}(d_i + h_i, d_j) - T_{ij}(d_i - h_i, d_j)}{2h_i}, \\quad \\text{where } h_i = 10^{-8} d_i\n$$\nA similar formula is used for the derivative with respect to $d_j$. The relative error, $\\text{err}_{d_i}$, is then computed as:\n$$\n\\text{err}_{d_i} = \\left| \\frac{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{num}} - (\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}}{(\\frac{\\partial T_{ij}}{\\partial d_i})_{\\text{ana}}} \\right|\n$$\nwhere the 'ana' subscript denotes the analytical derivative derived above. These results are then compared against the specified tolerance of $10^{-9}$.\n\nA program will implement these formulas to process the given test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes transmissibility, sensitivities, and validates derivatives for \n    a set of test cases according to the problem description.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Format: (|F|, d_i, d_j, k_i, k_j)\n    # Units:\n    # |F|: m^2\n    # d_i, d_j: m\n    # k_i, k_j: W/(m.K)\n    test_cases = [\n        # Case A (general asymmetric)\n        (1.2, 0.5, 0.4, 2.0, 4.0),\n        # Case B (symmetric distances and conductivities)\n        (2.0, 0.5, 0.5, 1.0, 1.0),\n        # Case C (high contrast conductivities)\n        (1.0, 0.1, 0.1, 10.0, 0.1),\n        # Case D (thin-thick pair, equal conductivities)\n        (0.5, 1e-3, 1.0, 5.0, 5.0),\n    ]\n\n    # Constants for numerical validation\n    DERIV_TOLERANCE = 1e-9\n    CENTRAL_DIFF_REL_STEP = 1e-8\n\n    def compute_t_ij(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the transmissibility T_ij in W/K.\"\"\"\n        # T_ij = |F| / (d_i/k_i + d_j/k_j)\n        denominator = d_i / k_i + d_j / k_j\n        if denominator == 0:\n            return float('inf')\n        return face_area / denominator\n\n    def compute_dt_di_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_i.\"\"\"\n        # d(T_ij)/d(d_i) = -|F| * k_i * k_j^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_i * k_j**2 / denominator**2\n\n    def compute_dt_dj_analytical(face_area, d_i, d_j, k_i, k_j):\n        \"\"\"Computes the analytical partial derivative of T_ij w.r.t. d_j.\"\"\"\n        # d(T_ij)/d(d_j) = -|F| * k_j * k_i^2 / (d_i*k_j + d_j*k_i)^2\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('-inf')\n        return -face_area * k_j * k_i**2 / denominator**2\n    \n    def compute_s_di(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_di.\"\"\"\n        # S_di = -d_i*k_j / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            # This case implies T is infinite or undefined, sensitivity may also be.\n            return float('nan')\n        return -d_i * k_j / denominator\n\n    def compute_s_dj(d_i, d_j, k_i, k_j):\n        \"\"\"Computes the dimensionless relative sensitivity S_dj.\"\"\"\n        # S_dj = -d_j*k_i / (d_i*k_j + d_j*k_i)\n        denominator = d_i * k_j + d_j * k_i\n        if denominator == 0:\n            return float('nan')\n        return -d_j * k_i / denominator\n\n    results = []\n    for case in test_cases:\n        F_area, di, dj, ki, kj = case\n        \n        # 1. Compute T_ij, S_di, S_dj\n        t_ij = compute_t_ij(F_area, di, dj, ki, kj)\n        s_di = compute_s_di(di, dj, ki, kj)\n        s_dj = compute_s_dj(di, dj, ki, kj)\n        \n        # 2. Approximate derivatives using central differences\n        # For d_i\n        h_i = CENTRAL_DIFF_REL_STEP * di\n        t_plus_i = compute_t_ij(F_area, di + h_i, dj, ki, kj)\n        t_minus_i = compute_t_ij(F_area, di - h_i, dj, ki, kj)\n        dt_di_num = (t_plus_i - t_minus_i) / (2 * h_i)\n\n        # For d_j\n        h_j = CENTRAL_DIFF_REL_STEP * dj\n        t_plus_j = compute_t_ij(F_area, di, dj + h_j, ki, kj)\n        t_minus_j = compute_t_ij(F_area, di, dj - h_j, ki, kj)\n        dt_dj_num = (t_plus_j - t_minus_j) / (2 * h_j)\n\n        # 3. Report relative error of numerical derivatives\n        dt_di_ana = compute_dt_di_analytical(F_area, di, dj, ki, kj)\n        dt_dj_ana = compute_dt_dj_analytical(F_area, di, dj, ki, kj)\n\n        # Relative error for d_i derivative\n        if dt_di_ana != 0:\n            err_di = abs((dt_di_num - dt_di_ana) / dt_di_ana)\n        elif dt_di_num == 0: # 0/0 case\n            err_di = 0.0\n        else: # inf error if analytical is 0 but numerical is not\n            err_di = float('inf')\n\n        # Relative error for d_j derivative\n        if dt_dj_ana != 0:\n            err_dj = abs((dt_dj_num - dt_dj_ana) / dt_dj_ana)\n        elif dt_dj_num == 0:\n            err_dj = 0.0\n        else:\n            err_dj = float('inf')\n\n        # 4. Return boolean flags indicating agreement within tolerance\n        ok_di = err_di = DERIV_TOLERANCE\n        ok_dj = err_dj = DERIV_TOLERANCE\n\n        case_results = [\n            t_ij, \n            s_di, \n            s_dj, \n            err_di, \n            err_dj, \n            ok_di, \n            ok_dj\n        ]\n        results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    # The default str() for a list already uses '[]' and ', ' separators.\n    # str(True) is 'True', which is a valid boolean representation in many contexts.\n    # The prompt's example format is `[[...],[...],...]`, which is achieved by this.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerical model is only as good as its boundary conditions. This practice extends the concept of transmissibility from interior faces to a mixed (Robin) boundary, a common scenario in heat transfer and other transport phenomena . You will derive the boundary transmissibility by modeling the system as a series of thermal resistances and numerically verify the theoretical limit where an infinite exchange coefficient, $\\alpha$, recovers the simpler Dirichlet condition. This exercise builds essential skills for handling realistic and complex physical boundaries in your simulations.",
            "id": "3377670",
            "problem": "Consider a one-dimensional steady diffusion problem on the interval $[0,L]$ with scalar field $u(x)$, thermal conductivity $k(x)0$, and no volumetric sources. The governing partial differential equation is the conservation law $-\\dfrac{d}{dx}\\!\\left(k(x)\\dfrac{du}{dx}\\right)=0$. Discretize the problem by the Finite Volume Method (FVM) with the Two-Point Flux Approximation (TPFA): associate each control volume with a cell center, approximate the diffusive flux across each internal face by a constant-gradient flux driven by the potential difference between adjacent cell centers, and enforce conservation by setting the algebraic sum of fluxes leaving a cell equal to zero.\n\nOn internal faces, determine the transmissibility by enforcing a flux continuity model between adjacent cells that reduces to a harmonic average of distances weighted by the local conductivity. On the left boundary, enforce a mixed (Robin) boundary condition that models heat exchange with an external environment held at prescribed value $u_b$, using an exchange coefficient $\\alpha0$ (units are dimensionless for this problem). On the right boundary, enforce a Dirichlet boundary condition with prescribed value $u_R$. For the Robin boundary condition at the left boundary, derive from first principles a face-based transmissibility consistent with the TPFA model and the series-resistance interpretation of a conduction segment next to a convective exchange layer. Then implement this Robin face transmissibility in the resulting linear system so that the left boundary flux is linearly proportional to the difference between the cell-center value and the external value $u_b$. Show that this construction converges to a Dirichlet boundary as $\\alpha\\to\\infty$.\n\nYour task is to write a complete, runnable program that:\n- Builds three discrete test problems using TPFA on $[0,L]$ with specified grids and conductivities, all with unit cross-sectional area.\n- For each problem, computes a reference solution with a Dirichlet condition at the left boundary set to $u_b$ and at the right boundary set to $u_R$.\n- For each problem, computes solutions with a left Robin boundary condition for a sequence of increasing exchange coefficients $\\alpha$, and reports the root-mean-square (RMS) difference between the Robin solutions and the reference Dirichlet solution, defined by\n$$\nE(\\alpha)=\\sqrt{\\dfrac{1}{L}\\sum_{i=1}^{N}\\Delta x_i\\,\\left(u_i^{(\\alpha)}-u_i^{(D)}\\right)^2},\n$$\nwhere $N$ is the number of cells, $\\Delta x_i$ is the $i$-th cell length, $u_i^{(\\alpha)}$ is the discrete solution with left Robin coefficient $\\alpha$, and $u_i^{(D)}$ is the discrete solution with left Dirichlet boundary $u_b$ and right Dirichlet boundary $u_R$.\n- For each problem, also report a boolean indicating whether the sequence of RMS differences is monotonically non-increasing as $\\alpha$ increases, within a small numerical tolerance $\\varepsilon=10^{-12}$.\n\nTreat all quantities as dimensionless. Use the following configurations as the test suite:\n- Test $1$ (uniform grid, uniform conductivity):\n  - Domain length $L=1$, number of cells $N=50$, uniform grid, $k(x)\\equiv 1$.\n  - Left external value $u_b=0$, right Dirichlet value $u_R=1$.\n  - Left Robin exchange coefficients $\\alpha\\in\\{10^{-3},10^{-1},10^{1},10^{5}\\}$.\n- Test $2$ (uniform grid, piecewise constant conductivity):\n  - Domain length $L=1$, number of cells $N=60$, uniform grid, $k(x)=1$ on $[0,\\tfrac{1}{2}L)$ and $k(x)=5$ on $[\\tfrac{1}{2}L,L]$.\n  - Left external value $u_b=0$, right Dirichlet value $u_R=1$.\n  - Left Robin exchange coefficients $\\alpha\\in\\{10^{-2},10^{0},10^{3}\\}$.\n- Test $3$ (nonuniform grid, smoothly varying conductivity):\n  - Domain length $L=1$, number of cells $N=40$, nonuniform grid with cell edges $x_j=L\\left(\\dfrac{j}{N}\\right)^2$ for $j=0,1,\\dots,N$, and cell centers at the midpoints of edges.\n  - Conductivity $k(x)=1+x$ evaluated at cell centers.\n  - Left external value $u_b=0$, right Dirichlet value $u_R=1$.\n  - Left Robin exchange coefficients $\\alpha\\in\\{10^{-2},10^{2},10^{8}\\}$.\n\nRequirements and constraints for implementation:\n- Use the Two-Point Flux Approximation (TPFA) to define transmissibilities on internal faces by combining the distances from cell centers to the face with local conductivities in a harmonic fashion.\n- At the right boundary, impose the Dirichlet condition by linking the boundary value to the last cell with an appropriate boundary transmissibility consistent with the TPFA model.\n- At the left boundary, impose the Robin condition by modeling the flux as a linear function of the difference between the first cell-center value and $u_b$, with a transmissibility derived from the series combination of a conduction segment and an exchange layer.\n- Assemble the linear system $A\\mathbf{u}=\\mathbf{b}$ from the flux balances and solve it for the cell-center values $\\mathbf{u}$.\n\nFinal output specification:\n- Your program should produce a single line of output containing a comma-separated list enclosed in square brackets with the following entries, in order:\n  - For Test $1$: the four RMS differences $E(\\alpha)$ corresponding to $\\alpha=10^{-3},10^{-1},10^{1},10^{5}$, followed by a boolean indicating monotonic non-increasing behavior.\n  - For Test $2$: the three RMS differences $E(\\alpha)$ corresponding to $\\alpha=10^{-2},10^{0},10^{3}$, followed by a boolean indicating monotonic non-increasing behavior.\n  - For Test $3$: the three RMS differences $E(\\alpha)$ corresponding to $\\alpha=10^{-2},10^{2},10^{8}$, followed by a boolean indicating monotonic non-increasing behavior.\n- The final line must therefore contain a total of $13$ entries: $[E_{1,1},E_{1,2},E_{1,3},E_{1,4},B_1,E_{2,1},E_{2,2},E_{2,3},B_2,E_{3,1},E_{3,2},E_{3,3},B_3]$, where $E_{t,s}$ denotes the $s$-th RMS difference for Test $t$, and $B_t$ is the corresponding monotonicity boolean for Test $t$.",
            "solution": "The user-provided problem is assessed to be **valid**. It is a well-posed, scientifically grounded problem in the field of numerical methods for partial differential equations. The parameters are complete, and the objectives are clear and quantitative. We may therefore proceed with a full solution.\n\nThe problem requires the numerical solution of the one-dimensional steady-state diffusion equation without sources:\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = 0, \\quad x \\in [0, L]\n$$\nwhere $u(x)$ is a scalar potential field and $k(x) > 0$ is the diffusion coefficient (e.g., thermal conductivity). We employ the cell-centered Finite Volume Method (FVM).\n\n**1. Discretization and Flux Balance**\n\nThe domain $[0, L]$ is discretized into $N$ contiguous control volumes (cells). Let the $i$-th cell, for $i=1, \\dots, N$, be denoted by $CV_i = [x_{i-1/2}, x_{i+1/2}]$, where $x_{i-1/2}$ and $x_{i+1/2}$ are the locations of the cell faces. The cell center is $x_i$, and the cell width is $\\Delta x_i = x_{i+1/2} - x_{i-1/2}$.\n\nIntegrating the governing equation over $CV_i$ yields:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} -\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) dx = 0\n$$\nApplying the fundamental theorem of calculus, we get a flux balance equation for each cell:\n$$\n- \\left[ k(x)\\frac{du}{dx} \\right]_{x_{i-1/2}}^{x_{i+1/2}} = 0 \\implies F_{i-1/2} - F_{i+1/2} = 0\n$$\nwhere $F(x) = -k(x)\\frac{du}{dx}$ is the diffusive flux. This equation states that the net flux out of any control volume is zero at steady state.\n\n**2. Two-Point Flux Approximation (TPFA)**\n\nThe TPFA approximates the flux at an internal face $x_{i+1/2}$ (between cells $i$ and $i+1$) as being linearly proportional to the difference in potential between the adjacent cell centers, $u_i$ and $u_{i+1}$:\n$$\nF_{i+1/2} \\approx -T_{i+1/2}(u_{i+1} - u_i)\n$$\nThe term $T_{i+1/2}$ is the transmissibility of the face. To derive its expression, we assume the flux is constant between $x_i$ and $x_{i+1}$ and that conductivity is piecewise constant ($k_i$ in cell $i$, $k_{i+1}$ in cell $i+1$). The potential at the face, $u_{i+1/2}$, can be eliminated by enforcing flux continuity, which is equivalent to a series resistance model:\n$$\nu_i - u_{i+1} = (u_i - u_{i+1/2}) + (u_{i+1/2} - u_{i+1}) = F_{i+1/2} \\left( \\frac{x_{i+1/2}-x_i}{k_i} \\right) + F_{i+1/2} \\left( \\frac{x_{i+1}-x_{i+1/2}}{k_{i+1}} \\right)\n$$\nSolving for $F_{i+1/2}$ gives the transmissibility as the harmonic average of the conductivities over the two half-cells adjacent to the face:\n$$\nT_{i+1/2} = \\left( \\frac{x_{i+1/2}-x_i}{k_i} + \\frac{x_{i+1}-x_{i+1/2}}{k_{i+1}} \\right)^{-1}\n$$\n\n**3. Boundary Conditions**\n\nThe boundary fluxes at $x_{1/2}=0$ and $x_{N+1/2}=L$ are incorporated into the flux balance equations for cells $1$ and $N$.\n\n**Right Boundary (Dirichlet):** At $x=L$, a Dirichlet condition $u(L)=u_R$ is prescribed. The flux through the boundary face $x_{N+1/2}=L$ is modeled using a half-cell transmissibility, connecting the center of cell $N$ to the boundary:\n$$\nF_{N+1/2} = -T_{N+1/2}(u_R - u_N) \\quad \\text{where} \\quad T_{N+1/2} = \\left( \\frac{x_{N+1/2}-x_N}{k_N} \\right)^{-1} = \\frac{k_N}{L-x_N}\n$$\nThe flux balance for cell $N$ is $F_{N-1/2} - F_{N+1/2} = 0$, which becomes:\n$$\n-T_{N-1/2}(u_N-u_{N-1}) - (-T_{N+1/2}(u_R - u_N)) = 0\n$$\n\n**Left Boundary (Robin):** At $x=0$, a mixed (Robin) condition models exchange with an environment at potential $u_b$ via an exchange coefficient $\\alpha > 0$. The physical flux condition is $-k \\frac{du}{dx}|_{x=0} = h(u(0)-u_b)$, where $h$ is a heat transfer coefficient which we take to be $\\alpha$. The total resistance from the external environment to the center of cell $1$ is the sum of the convective resistance at the surface ($R_{conv}=1/\\alpha$) and the conductive resistance of the half-cell ($R_{cond}=(x_1-x_{1/2})/k_1 = x_1/k_1$). The total flux is driven by the potential difference $u_1-u_b$ across this total resistance:\n$$\nF_{1/2} = \\frac{u_1-u_b}{R_{conv} + R_{cond}} = \\left( \\frac{1}{\\alpha} + \\frac{x_1}{k_1} \\right)^{-1} (u_1-u_b)\n$$\nWe define the Robin boundary transmissibility $T_{1/2}^{(\\alpha)} = (1/\\alpha + x_1/k_1)^{-1}$. The flux balance for cell $1$ is $F_{1/2} - F_{3/2} = 0$:\n$$\nT_{1/2}^{(\\alpha)}(u_1-u_b) - (-T_{3/2}(u_2 - u_1)) = 0\n$$\n\n**Convergence to Dirichlet:** As the exchange coefficient $\\alpha \\to \\infty$, the convective resistance $1/\\alpha \\to 0$. The Robin transmissibility becomes:\n$$\n\\lim_{\\alpha\\to\\infty} T_{1/2}^{(\\alpha)} = \\lim_{\\alpha\\to\\infty} \\left( \\frac{1}{\\alpha} + \\frac{x_1}{k_1} \\right)^{-1} = \\left( \\frac{x_1}{k_1} \\right)^{-1} = \\frac{k_1}{x_1}\n$$\nThis is precisely the transmissibility $T_{1/2}^{(D)}$ for a Dirichlet boundary condition $u(0)=u_b$. Thus, as $\\alpha \\to \\infty$, the linear system for the Robin problem converges to the system for the Dirichlet problem, and so do their solutions.\n\n**4. The Linear System ($A\\mathbf{u}=\\mathbf{b}$)**\n\nAssembling the flux balance equations for all $N$ cells results in a tridiagonal linear system $A\\mathbf{u}=\\mathbf{b}$ for the vector of cell-center potentials $\\mathbf{u}=[u_1, u_2, \\dots, u_N]^T$.\n- For an internal cell $i \\in \\{2, \\dots, N-1\\}$:\n  $$ -T_{i-1/2}u_{i-1} + (T_{i-1/2} + T_{i+1/2})u_i - T_{i+1/2}u_{i+1} = 0 $$\n- For the first cell ($i=1$, Robin BC):\n  $$ (T_{1/2}^{(\\alpha)} + T_{3/2})u_1 - T_{3/2}u_2 = T_{1/2}^{(\\alpha)}u_b $$\n- For the last cell ($i=N$, Dirichlet BC):\n  $$ -T_{N-1/2}u_{N-1} + (T_{N-1/2} + T_{N+1/2})u_N = T_{N+1/2}u_R $$\n\nThe reference solution $u_i^{(D)}$ is computed by solving a similar system, but with a Dirichlet condition on the left boundary as well, using the transmissibility $T_{1/2}^{(D)} = k_1/x_1$. The error is then computed using the given RMS formula.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion problem for three test cases using FVM-TPFA,\n    analyzes the convergence of Robin to Dirichlet boundary conditions,\n    and prints the results in the specified format.\n    \"\"\"\n\n    def solve_test_case(L, N, grid_type, k_func, u_b, u_R, alphas, tol):\n        \"\"\"\n        Builds the grid, assembles and solves the linear systems for a single test case.\n        \n        Returns a tuple containing:\n        - A list of RMS errors for the given alpha values.\n        - A boolean indicating if the errors are monotonically non-increasing.\n        \"\"\"\n\n        # 1. Build grid geometry and evaluate conductivity\n        if grid_type == 'uniform':\n            faces = np.linspace(0, L, N + 1)\n        elif grid_type == 'nonuniform_sq':\n            j = np.arange(N + 1)\n            faces = L * (j / N)**2\n        else:\n            raise ValueError(f\"Unknown grid type: {grid_type}\")\n\n        centers = 0.5 * (faces[:-1] + faces[1:])\n        dx = faces[1:] - faces[:-1]\n        k = k_func(centers)\n\n        # 2. Compute internal face transmissibilities\n        # T_internal[i] corresponds to face between cell i and cell i+1\n        T_internal = np.zeros(N - 1)\n        if N > 1:\n            d_i_f = faces[1:-1] - centers[:-1]  # distance from center i to face i+1/2\n            d_f_i1 = centers[1:] - faces[1:-1] # distance from face i+1/2 to center i+1\n            T_internal = 1.0 / (d_i_f / k[:-1] + d_f_i1 / k[1:])\n\n        # --- Helper for system assembly and solution ---\n        def assemble_and_solve(T_left, T_right):\n            A = np.zeros((N, N))\n            b = np.zeros(N)\n\n            # Cell 0 (left boundary)\n            if N > 1:\n                A[0, 0] = T_left + T_internal[0]\n                A[0, 1] = -T_internal[0]\n            else: # Single cell case\n                A[0, 0] = T_left + T_right\n            b[0] = T_left * u_b\n            \n            # Internal cells (1 to N-2)\n            for i in range(1, N - 1):\n                A[i, i - 1] = -T_internal[i - 1]\n                A[i, i] = T_internal[i - 1] + T_internal[i]\n                A[i, i + 1] = -T_internal[i]\n\n            # Cell N-1 (right boundary)\n            if N > 1:\n                A[N - 1, N - 2] = -T_internal[N - 2]\n                A[N - 1, N - 1] = T_internal[N - 2] + T_right\n            b[N - 1] = T_right * u_R\n            \n            return np.linalg.solve(A, b)\n        # --- End of helper ---\n\n        # 3. Compute reference solution (Dirichlet-Dirichlet)\n        T_left_D = k[0] / (centers[0] - faces[0])\n        T_right_D = k[-1] / (faces[-1] - centers[-1])\n        u_D = assemble_and_solve(T_left_D, T_right_D)\n\n        # 4. Compute solutions for Robin BC and RMS errors\n        rms_errors = []\n        for alpha in alphas:\n            # Transmissibility for left Robin boundary\n            # R_cond = (centers[0] - faces[0]) / k[0]\n            # R_conv = 1.0 / alpha\n            # T_left_R = 1.0 / (R_cond + R_conv)\n            T_left_R = 1.0 / ((centers[0] - faces[0]) / k[0] + 1.0 / alpha)\n\n            # Solve for Robin case (right BC is still Dirichlet)\n            u_alpha = assemble_and_solve(T_left_R, T_right_D)\n            \n            # Compute RMS difference\n            error_sq_sum = np.sum(dx * (u_alpha - u_D)**2)\n            rms = np.sqrt(error_sq_sum / L)\n            rms_errors.append(rms)\n\n        # 5. Check for monotonic non-increasing behavior\n        is_monotonic = all(\n            rms_errors[i+1] = rms_errors[i] + tol for i in range(len(rms_errors)-1)\n        )\n        \n        return rms_errors, is_monotonic\n\n    test_configs = [\n        {\n            \"L\": 1.0, \"N\": 50, \"grid_type\": \"uniform\",\n            \"k_func\": lambda x: np.ones_like(x),\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-3, 1e-1, 1e1, 1e5]\n        },\n        {\n            \"L\": 1.0, \"N\": 60, \"grid_type\": \"uniform\",\n            \"k_func\": lambda x: np.where(x  0.5, 1.0, 5.0),\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-2, 1e0, 1e3]\n        },\n        {\n            \"L\": 1.0, \"N\": 40, \"grid_type\": \"nonuniform_sq\",\n            \"k_func\": lambda x: 1.0 + x,\n            \"u_b\": 0.0, \"u_R\": 1.0,\n            \"alphas\": [1e-2, 1e2, 1e8]\n        },\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-12\n\n    for config in test_configs:\n        errors, monotonic = solve_test_case(**config, tol=TOLERANCE)\n        all_results.extend(errors)\n        all_results.append(monotonic)\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "The simplicity of the Two-Point Flux Approximation comes at a cost: it is only consistent under specific geometric conditions. This final practice confronts the limitations of TPFA by comparing it directly against a more advanced Mimetic Finite Difference (MFD) scheme on various grid types . By implementing both methods and analyzing their flux predictions for a known linear solution, you will discover the crucial concept of $K$-orthogonality and gain a definitive, hands-on understanding of the scenarios where TPFA fails and more robust, multipoint flux approximations become necessary.",
            "id": "3377674",
            "problem": "Consider the stationary diffusion equation in two spatial dimensions,\n$$-\\nabla \\cdot (K \\nabla p) = f,$$\nwith symmetric positive definite diffusion tensor $K \\in \\mathbb{R}^{2 \\times 2}$ and scalar potential $p(x,y)$. The physical flux is defined by\n$$q = -K \\nabla p.$$\nYou are to implement and compare the Two-Point Flux Approximation (TPFA) and the Mimetic Finite Difference (MFD) discretizations of the normal flux across interior faces on the same cell-centered mesh for constant $K$ and a manufactured linear solution. Your implementation must be based on the following fundamental principles and definitions only: the flux definition $q = -K \\nabla p$, the divergence theorem, geometric face measures (face length and outward unit normal), and the concept of reconstructing a constant gradient from neighboring cell values so that linear fields are represented exactly.\n\nConstruct the mesh as follows. Start from the unit square $[0,1]^2$ partitioned into $N_x \\times N_y$ axis-aligned rectangles with vertex coordinates $(i/N_x, j/N_y)$ for integers $i=0,\\dots,N_x$ and $j=0,\\dots,N_y$. Apply a given fixed linear transformation $A \\in \\mathbb{R}^{2 \\times 2}$ to all vertex coordinates to obtain the possibly non-orthogonal mesh in physical space. For each cell, define its center as the average of its four transformed vertices. For each interior face, define its endpoints as the corresponding transformed vertices, its edge vector as the difference of endpoints, its unit normal as the unique unit vector orthogonal to the edge vector that points from the “left/bottom” cell to the “right/top” cell, and its length as the norm of the edge vector.\n\nLet the manufactured solution be the linear potential\n$$p(x,y) = a x + b y,$$\nwith constant gradient $\\nabla p = (a,b)^\\top$. For each interior face shared by cells $i$ and $j$, the exact normal flux through that face is\n$$F_{\\mathrm{ex}} = -|f|\\, n^\\top K \\nabla p,$$\nwhere $|f|$ is the face length and $n$ is the unit normal oriented from $i$ to $j$. The TPFA scheme approximates the normal flux using only the two adjacent cell-centered values and the face co-normal, while the MFD scheme reconstructs a cell gradient that is exact for linear fields and uses it to approximate the face-normal flux consistently. Your program must implement both approximations in a way that adheres to the above fundamental definitions and then compare them against the exact face-normal flux.\n\nYour tasks:\n- Implement the mesh generation using the specified affine transformation on the unit square partition for given $N_x$, $N_y$, and $A$.\n- For each interior face, compute:\n  1. The exact normal flux $F_{\\mathrm{ex}}$ using $q = -K \\nabla p$ and the manufactured linear field.\n  2. The TPFA normal flux $F_{\\mathrm{TPFA}}$ using only the two cell-centered values and the geometric co-normal and center-to-center distance projected along the face normal, derived from the flux definition and conservation across the face as established in your solution.\n  3. The MFD normal flux $F_{\\mathrm{MFD}}$ by reconstructing, in each cell, a constant gradient from its neighboring cell-centered values via a least-squares fit that is exact for linear polynomials, and then averaging adjacent cell gradients to form the face-normal flux by contraction with $K$ and the face normal.\n- Compute the relative $L^2$ flux errors over all interior faces,\n$$E_{\\mathrm{TPFA}} = \\frac{\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}, \\quad E_{\\mathrm{MFD}} = \\frac{\\left\\|F_{\\mathrm{MFD}} - F_{\\mathrm{ex}}\\right\\|_2}{\\left\\|F_{\\mathrm{ex}}\\right\\|_2}.$$\n- Identify whether TPFA and MFD coincide on the given case by checking if the discrepancy $\\left\\|F_{\\mathrm{TPFA}} - F_{\\mathrm{MFD}}\\right\\|_2$ is negligible compared to $\\left\\|F_{\\mathrm{ex}}\\right\\|_2$.\n\nUse the following test suite of parameter values, which covers conditions of coincidence and divergence. All angles are specified in degrees, and there are no physical units required.\n\n- Test Case 1 (orthogonal mesh, isotropic diffusion, general gradient):\n  - $N_x = 8$, $N_y = 7$\n  - $A = I$ (the identity transformation)\n  - $K = k I$ with $k = 2$\n  - $\\nabla p = (a,b)^\\top$ with $a = 1.3$, $b = -0.9$\n\n- Test Case 2 (skewed mesh, anisotropic diffusion rotated, general gradient):\n  - $N_x = 8$, $N_y = 7$\n  - $A = \\begin{pmatrix}1  s \\\\ 0  1\\end{pmatrix}$ with $s = 0.7$\n  - $K = R \\,\\mathrm{diag}(k_x, k_y)\\, R^\\top$ with $k_x = 5$, $k_y = 1$, $R$ being the rotation matrix of angle $\\theta = 30$ degrees\n  - $\\nabla p = (a,b)^\\top$ with $a = 1.3$, $b = -0.9$\n\n- Test Case 3 (orthogonal mesh, anisotropic diffusion aligned with grid, general gradient):\n  - $N_x = 8$, $N_y = 7$\n  - $A = I$\n  - $K = \\mathrm{diag}(k_x, k_y)$ with $k_x = 5$, $k_y = 1$\n  - $\\nabla p = (a,b)^\\top$ with $a = 1.3$, $b = -0.9$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of the form $[E_{\\mathrm{TPFA}}, E_{\\mathrm{MFD}}, \\mathrm{coincide}]$. For example:\n$$\\text{[[e1\\_tpfa,e1\\_mfd,true],[e2\\_tpfa,e2\\_mfd,false],[e3\\_tpfa,e3\\_mfd,true]]}$$\nwhere $e\\_*\\_{\\mathrm{tpfa}}$ and $e\\_*\\_{\\mathrm{mfd}}$ are floating-point numbers and $\\mathrm{coincide}$ is a boolean.",
            "solution": "The problem requires the implementation and comparison of the Two-Point Flux Approximation (TPFA) and Mimetic Finite Difference (MFD) schemes for a 2D stationary diffusion equation on a general quadrilateral mesh. We will validate the problem, derive the formulas for the numerical fluxes, and then implement them to compute the requested error metrics for the given test cases.\n\nThe governing equation is the stationary diffusion equation:\n$$-\\nabla \\cdot (\\mathbf{q}) = f \\quad \\text{with} \\quad \\mathbf{q} = -K \\nabla p$$\nwhere $p$ is the scalar potential, $K \\in \\mathbb{R}^{2 \\times 2}$ is a symmetric positive definite diffusion tensor, $\\mathbf{q}$ is the physical flux, and $f$ is a source term. The problem is analyzed on a domain $\\Omega \\subset \\mathbb{R}^2$ with a manufactured linear potential $p(x,y) = ax+by$, for which the source term is $f=0$ because $K$ is constant.\n\n**1. Mesh and Geometry**\nThe computational mesh is constructed by applying a linear transformation $A \\in \\mathbb{R}^{2 \\times 2}$ to the vertices of a uniform Cartesian grid on the unit square $[0,1]^2$. Let the reference grid have vertices $\\mathbf{v}^{\\text{ref}}_{i,j} = (i/N_x, j/N_y)^\\top$ for integers $i \\in \\{0, \\dots, N_x\\}$ and $j \\in \\{0, \\dots, N_y\\}$. The vertices of the physical mesh are $\\mathbf{v}_{i,j} = A \\mathbf{v}^{\\text{ref}}_{i,j}$.\n\nA cell $C_{i,j}$ is the quadrilateral formed by vertices $\\{\\mathbf{v}_{i,j}, \\mathbf{v}_{i+1,j}, \\mathbf{v}_{i,j+1}, \\mathbf{v}_{i+1,j+1}\\}$. Its center, for the cell-centered scheme, is defined as the barycenter (average) of its vertices:\n$$\\mathbf{x}_{i,j} = \\frac{1}{4}(\\mathbf{v}_{i,j} + \\mathbf{v}_{i+1,j} + \\mathbf{v}_{i,j+1} + \\mathbf{v}_{i+1,j+1})$$\n\nAn interior face $e$ is a line segment shared by two adjacent cells, say $C_L$ and $C_R$. Let its endpoints be $\\mathbf{v}_1$ and $\\mathbf{v}_2$. The edge vector is $\\mathbf{e} = \\mathbf{v}_2 - \\mathbf{v}_1$, and its length is $|e| = \\|\\mathbf{e}\\|_2$. The unit normal vector $\\mathbf{n}$ is orthogonal to $\\mathbf{e}$ ($ \\mathbf{n} \\cdot \\mathbf{e} = 0 $) and is oriented to point from cell $C_L$ to cell $C_R$. For a vector $\\mathbf{e}=(e_x, e_y)^\\top$, a normal vector is given by $(-e_y, e_x)^\\top$. We select the sign to ensure $\\mathbf{n} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L) > 0$.\n\n**2. Manufactured Solution and Exact Flux**\nThe potential field is given as a linear function $p(x,y) = ax+by$. In vector notation, $p(\\mathbf{x}) = \\mathbf{g} \\cdot \\mathbf{x}$, where $\\mathbf{g} = (a, b)^\\top$ is the constant gradient, $\\nabla p = \\mathbf{g}$. The potential at a cell center $\\mathbf{x}_i$ is $p_i = p(\\mathbf{x}_i) = \\mathbf{g} \\cdot \\mathbf{x}_i$.\n\nThe normal flux across a face $e$ is the integral of the normal component of the physical flux $\\mathbf{q} = -K \\nabla p$:\n$$F_e = \\int_e \\mathbf{q} \\cdot \\mathbf{n} \\,ds$$\nSince $\\mathbf{q}$ is constant for our manufactured solution, the integral simplifies. The exact normal flux is:\n$$F^{\\text{ex}}_e = (\\mathbf{q} \\cdot \\mathbf{n}) \\int_e ds = (-K \\mathbf{g} \\cdot \\mathbf{n}) |e| = -|e| \\mathbf{n}^\\top K \\mathbf{g}$$\n\n**3. Two-Point Flux Approximation (TPFA)**\nThe TPFA scheme approximates the flux between two cells $C_L$ and $C_R$ using only their cell-centered potentials, $p_L$ and $p_R$. The derivation is based on a 1D assumption of flow along the direction normal to the face. By enforcing flux continuity at the face center and using a finite difference approximation for the gradient, one arrives at the expression for the flux. The resulting flux approximation is:\n$$F^{\\text{TPFA}}_e = -T_e (p_R - p_L)$$\nwhere $T_e$ is the transmissibility of the face. For a general tensor $K$, the transmissibility is derived under the assumption that the potential varies linearly along the normal direction, which yields:\n$$T_e = |e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}}$$\nThe potential difference is $p_R - p_L = \\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L)$. Substituting these into the flux expression gives:\n$$F^{\\text{TPFA}}_e = -|e| \\frac{\\mathbf{n}^\\top K \\mathbf{n}}{(\\mathbf{x}_R - \\mathbf{x}_L) \\cdot \\mathbf{n}} (\\mathbf{g} \\cdot (\\mathbf{x}_R - \\mathbf{x}_L))$$\nThis approximation is exact if and only if the mesh is K-orthogonal, which means the vector $K(\\mathbf{x}_R - \\mathbf{x}_L)$ is parallel to the face normal $\\mathbf{n}$ for every face. This condition is met for orthogonal grids with isotropic ($K=kI$) or axis-aligned anisotropic ($K=\\text{diag}(k_x, k_y)$) diffusion tensors. On skewed meshes or with rotated anisotropic tensors, TPFA introduces a consistency error.\n\n**4. Mimetic Finite Difference (MFD) Flux**\nThe MFD method provides a more accurate flux approximation by first reconstructing a gradient within each cell and then using it to compute the flux.\n\n**4.1. Gradient Reconstruction**\nFor each cell $C_i$, a constant gradient vector $\\nabla p_i$ is computed by a least-squares fit to the potentials of its face-neighboring cells. Let $N(i)$ be the set of indices of face neighbors of cell $C_i$. We seek $\\mathbf{g}_i \\approx \\nabla p_i$ that minimizes the sum of squared residuals:\n$$\\underset{\\mathbf{g}_i \\in \\mathbb{R}^2}{\\text{minimize}} \\sum_{j \\in N(i)} \\left( (p_j - p_i) - \\mathbf{g}_i \\cdot (\\mathbf{x}_j - \\mathbf{x}_i) \\right)^2$$\nThis is a standard linear least-squares problem. Let $\\mathbf{d}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$ and $\\Delta p_{ij} = p_j - p_i$. The system can be written as $M \\mathbf{g}_i = \\mathbf{b}$, where rows of $M$ are $\\mathbf{d}_{ij}^\\top$ and entries of $\\mathbf{b}$ are $\\Delta p_{ij}$. The solution is given by:\n$$\\mathbf{g}_i = (M^\\top M)^{-1} M^\\top \\mathbf{b}$$\nwhere $M^\\top M = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\mathbf{d}_{ij}^\\top$ and $M^\\top \\mathbf{b} = \\sum_{j \\in N(i)} \\mathbf{d}_{ij} \\Delta p_{ij}$.\nA key property of this reconstruction is that it is exact for linear potential fields. If $p(\\mathbf{x}) = \\mathbf{g}_{\\text{true}} \\cdot \\mathbf{x} + c$, then $p_j - p_i = \\mathbf{g}_{\\text{true}} \\cdot (\\mathbf{x}_j - \\mathbf{x}_i)$, so the residuals in the least-squares problem are zero for $\\mathbf{g}_i = \\mathbf{g}_{\\text{true}}$. Thus, for our manufactured solution, the reconstructed gradient $\\mathbf{g}_i$ in every cell will be equal to the true gradient $\\mathbf{g}$, up to machine precision.\n\n**4.2. Flux Computation**\nThe MFD flux across face $e$ between cells $C_L$ and $C_R$ is computed using the reconstructed gradients. The flux vector at the face is approximated by an arithmetic average of the flux vectors from the adjacent cells:\n$$\\mathbf{q}_e \\approx \\frac{\\mathbf{q}_L + \\mathbf{q}_R}{2} = -\\frac{K\\nabla p_L + K\\nabla p_R}{2}$$\nSince $K$ is constant, and for a linear potential the reconstruction is exact ($\\nabla p_L = \\nabla p_R = \\mathbf{g}$), the face flux vector is simply $\\mathbf{q}_e = -K\\mathbf{g}$. The normal flux is then:\n$$F^{\\text{MFD}}_e = |e| (\\mathbf{q}_e \\cdot \\mathbf{n}) = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\nabla p_L + \\nabla p_R}{2}\\right)$$\nFor the linear manufactured solution, this becomes:\n$$F^{\\text{MFD}}_e = -|e| \\mathbf{n}^\\top K \\left(\\frac{\\mathbf{g} + \\mathbf{g}}{2}\\right) = -|e| \\mathbf{n}^\\top K \\mathbf{g} = F^{\\text{ex}}_e$$\nTherefore, the MFD scheme is exact for linear potentials on arbitrary grids and should produce a numerical error close to zero.\n\n**5. Error and Coincidence Analysis**\nThe accuracy of each scheme is measured by the relative $L^2$ norm of the error in the flux approximation over all $N_f$ interior faces:\n$$E = \\frac{\\left\\|F_{\\text{approx}} - F_{\\text{ex}}\\right\\|_2}{\\left\\|F_{\\text{ex}}\\right\\|_2} = \\frac{\\left(\\sum_e (F^{\\text{approx}}_e - F^{\\text{ex}}_e)^2\\right)^{1/2}}{\\left(\\sum_e (F^{\\text{ex}}_e)^2\\right)^{1/2}}$$\nWe must compute this error for both $F_{\\text{approx}} = F_{\\text{TPFA}}$ and $F_{\\text{approx}} = F_{\\text{MFD}}$.\n\nThe two schemes are considered to coincide if the $L^2$ norm of the difference between their fluxes is negligible compared to the norm of the exact flux. We define this using a small tolerance $\\epsilon$:\n$$\\frac{\\left\\|F_{\\text{TPFA}} - F_{\\text{MFD}}\\right\\|_2}{\\left\\|F_{\\text{ex}}\\right\\|_2}  \\epsilon$$\nA tolerance of $\\epsilon=10^{-12}$ is appropriate for double-precision floating-point arithmetic. Coincidence is expected when the TPFA scheme is also exact, i.e., on K-orthogonal meshes.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1: Orthogonal mesh, isotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"iso\", \"k\": 2.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 2: Skewed mesh, anisotropic K\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.array([[1.0, 0.7], [0.0, 1.0]]),\n            \"K_params\": {\"type\": \"aniso_rot\", \"kx\": 5.0, \"ky\": 1.0, \"theta_deg\": 30.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n        {\n            \"name\": \"Case 3: Orthogonal mesh, anisotropic K (aligned)\",\n            \"Nx\": 8, \"Ny\": 7,\n            \"A\": np.identity(2),\n            \"K_params\": {\"type\": \"aniso_aligned\", \"kx\": 5.0, \"ky\": 1.0},\n            \"grad_p\": np.array([1.3, -0.9])\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_flux_errors(case)\n        results.append(result)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_flux_errors(case_params):\n    \"\"\"\n    Computes mesh, fluxes, and errors for a single test case.\n    \"\"\"\n    Nx, Ny = case_params[\"Nx\"], case_params[\"Ny\"]\n    A = case_params[\"A\"]\n    grad_p = case_params[\"grad_p\"]\n\n    # Build diffusion tensor K\n    k_params = case_params[\"K_params\"]\n    if k_params[\"type\"] == \"iso\":\n        K = k_params[\"k\"] * np.identity(2)\n    elif k_params[\"type\"] == \"aniso_aligned\":\n        K = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n    elif k_params[\"type\"] == \"aniso_rot\":\n        theta = np.deg2rad(k_params[\"theta_deg\"])\n        c, s = np.cos(theta), np.sin(theta)\n        R = np.array([[c, -s], [s, c]])\n        D = np.diag([k_params[\"kx\"], k_params[\"ky\"]])\n        K = R @ D @ R.T\n\n    # 1. Mesh Generation\n    ref_x = np.linspace(0, 1, Nx + 1)\n    ref_y = np.linspace(0, 1, Ny + 1)\n    ref_vx, ref_vy = np.meshgrid(ref_x, ref_y, indexing='ij')\n    ref_vertices = np.stack([ref_vx, ref_vy], axis=-1)\n    \n    vertices = np.einsum('ij,klj->kli', A, ref_vertices)\n\n    cell_centers = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            cell_centers[i, j] = 0.25 * (vertices[i, j] + vertices[i+1, j] +\n                                         vertices[i, j+1] + vertices[i+1, j+1])\n\n    # 2. MFD: Reconstruct gradients in all cells\n    p_cell = np.einsum('ij,j->i', cell_centers.reshape(-1, 2), grad_p).reshape(Nx, Ny)\n    grad_p_mfd = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        for j in range(Ny):\n            neighbors = []\n            if i > 0: neighbors.append((i - 1, j))\n            if i  Nx - 1: neighbors.append((i + 1, j))\n            if j > 0: neighbors.append((i, j - 1))\n            if j  Ny - 1: neighbors.append((i, j + 1))\n            \n            num_neighbors = len(neighbors)\n            M = np.zeros((num_neighbors, 2))\n            b = np.zeros(num_neighbors)\n            \n            for k, (ni, nj) in enumerate(neighbors):\n                M[k, :] = cell_centers[ni, nj] - cell_centers[i, j]\n                b[k] = p_cell[ni, nj] - p_cell[i, j]\n            \n            # Least-squares solve: grad = (M^T M)^-1 M^T b\n            MTM = M.T @ M\n            MTb = M.T @ b\n            grad_p_mfd[i, j] = np.linalg.solve(MTM, MTb)\n\n    # 3. Loop over interior faces to compute fluxes\n    F_ex_list, F_tpfa_list, F_mfd_list = [], [], []\n\n    # Vertical interior faces\n    for i in range(Nx - 1):\n        for j in range(Ny):\n            # Face between C(i,j) and C(i+1,j)\n            L_idx, R_idx = (i, j), (i + 1, j)\n            \n            v1, v2 = vertices[i + 1, j], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n            \n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n\n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n\n    # Horizontal interior faces\n    for i in range(Nx):\n        for j in range(Ny - 1):\n            # Face between C(i,j) and C(i,j+1)\n            L_idx, R_idx = (i, j), (i, j + 1)\n            \n            v1, v2 = vertices[i, j + 1], vertices[i + 1, j + 1]\n            edge = v2 - v1\n            length = np.linalg.norm(edge)\n\n            normal_cand = np.array([-edge[1], edge[0]])\n            center_vec = cell_centers[R_idx] - cell_centers[L_idx]\n            if np.dot(normal_cand, center_vec)  0:\n                normal_cand = -normal_cand\n            normal = normal_cand / np.linalg.norm(normal_cand)\n            \n            xL, xR = cell_centers[L_idx], cell_centers[R_idx]\n            pL, pR = p_cell[L_idx], p_cell[R_idx]\n\n            # Exact flux\n            F_ex = -length * normal.T @ K @ grad_p\n            F_ex_list.append(F_ex)\n\n            # TPFA flux\n            trans = length * (normal.T @ K @ normal) / np.dot(normal, xR - xL)\n            F_tpfa = -trans * (pR - pL)\n            F_tpfa_list.append(F_tpfa)\n\n            # MFD flux\n            grad_L, grad_R = grad_p_mfd[L_idx], grad_p_mfd[R_idx]\n            grad_face = 0.5 * (grad_L + grad_R)\n            F_mfd = -length * normal.T @ K @ grad_face\n            F_mfd_list.append(F_mfd)\n            \n    # 4. Calculate final errors and coincidence\n    F_ex_vec = np.array(F_ex_list)\n    F_tpfa_vec = np.array(F_tpfa_list)\n    F_mfd_vec = np.array(F_mfd_list)\n\n    norm_F_ex = np.linalg.norm(F_ex_vec)\n    if norm_F_ex == 0: # Avoid division by zero\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec)\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec)\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec)\n    else:\n        E_tpfa = np.linalg.norm(F_tpfa_vec - F_ex_vec) / norm_F_ex\n        E_mfd = np.linalg.norm(F_mfd_vec - F_ex_vec) / norm_F_ex\n        coincidence_err = np.linalg.norm(F_tpfa_vec - F_mfd_vec) / norm_F_ex\n\n    coincide = coincidence_err  1e-12\n\n    return [E_tpfa, E_mfd, coincide]\n\n# Execute the solver\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}