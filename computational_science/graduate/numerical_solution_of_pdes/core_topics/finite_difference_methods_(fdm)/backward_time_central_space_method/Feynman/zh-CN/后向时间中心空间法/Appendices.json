{
    "hands_on_practices": [
        {
            "introduction": "理论分析是理解数值方法内在特性的基石。本练习将引导你通过“纸笔”推导，深入探究后向时间中心空间（BTCS）方法的一个关键性质：保正性。在许多物理问题中，如浓度或热量扩散，解必须保持非负，这是一个基本的物理约束。此实践要求你为反应-扩散方程推导出一个精确的条件，以确保BTCS格式在何种条件下能够维持解的非负性，这有助于你掌握离散最大值原理和M-矩阵等核心概念。",
            "id": "3365252",
            "problem": "考虑单位区间上的线性反应扩散初边值问题，\n$$\nu_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t) \\;+\\; \\beta\\,u(x,t), \\quad x\\in(0,1),\\; t>0,\n$$\n其具有固定的狄利克雷边界数据\n$$\nu(0,t) \\;=\\; g_{0}(t), \\qquad u(1,t) \\;=\\; g_{1}(t),\n$$\n和初始条件\n$$\nu(x,0) \\;=\\; u_{0}(x),\n$$\n其中 $\\kappa>0$ 和 $\\beta>0$ 为常数。假设数据具有非负性，即对所有 $x\\in[0,1]$ 有 $u_{0}(x)\\ge 0$，且对所有 $t\\ge 0$ 有 $g_{0}(t)\\ge 0$，$g_{1}(t)\\ge 0$。\n\n用均匀网格 $x_{i}=i h$，$i=0,1,\\dots,M$，$h=1/M$ 对空间区间进行离散，并定义时间网格 $t^{n}=n\\,\\Delta t$，$n\\in\\mathbb{N}$。令 $u_{i}^{n}$ 表示在内部节点 $i=1,\\dots,M-1$ 和时间 $n\\ge 0$ 处对 $u(x_{i},t^{n})$ 的近似。应用后向时间中心空间 (BTCS) 方法，对每个时间步 $n\\to n+1$，为内部值 $u_{i}^{n+1}$ 得到一个三对角线性系统，其中出现了扩散比\n$$\n\\lambda \\;=\\; \\frac{\\kappa\\,\\Delta t}{h^{2}}\n$$。\n\n仅使用单调矩阵和离散极值原理的基本性质，从基本原理出发，推导关于时间步长 $\\Delta t$ 的尖锐条件（仅用 $\\beta$ 表示），该条件保证 BTCS 更新方法对于所有空间网格（等价于，对所有 $\\lambda\\ge 0$）都具有以下保正性：\n\n如果对所有内部索引 $i$ 都有 $u_{i}^{n}\\ge 0$，并且新时间层上的狄利克雷边界值满足 $g_{0}(t^{n+1})\\ge 0$ 和 $g_{1}(t^{n+1})\\ge 0$，那么在下一个时间层上的 BTCS 解对所有内部索引 $i$ 都满足 $u_{i}^{n+1}\\ge 0$。\n\n你的最终答案应为一个单独的闭式解析表达式，给出仅用 $\\beta$ 表示的、对所有 $\\lambda\\ge 0$ 都有效的最大允许 $\\Delta t$。最终答案中不要提供不等式；而是将最大允许的 $\\Delta t$ 作为显式表达式给出。最终答案中无需进行数值舍入。请仅用 $\\beta$ 表示你的答案。",
            "solution": "该问题要求推导关于时间步长 $\\Delta t$ 的一个尖锐条件，该条件保证应用于给定反应扩散方程的后向时间中心空间 (BTCS) 方法具有保正性，且对所有空间网格尺寸均有效。\n\n偏微分方程 (PDE) 由下式给出\n$$u_{t}(x,t) \\;=\\; \\kappa\\,u_{xx}(x,t) \\;+\\; \\beta\\,u(x,t), \\quad x\\in(0,1),\\; t>0$$\n其中常数 $\\kappa>0$ 和 $\\beta>0$。边界条件为 $u(0,t) = g_{0}(t)$ 和 $u(1,t) = g_{1}(t)$，初始条件为 $u(x,0) = u_{0}(x)$。假设数据为非负。\n\n我们首先构建 BTCS 数值格式。空间域用均匀网格 $x_{i}=i h$（$i=0,1,\\dots,M$，$h=1/M$）进行离散。时间域离散为 $t^{n}=n\\,\\Delta t$。令 $u_{i}^{n}$ 表示 $u(x_{i},t^{n})$ 的数值近似。\n\nBTCS 方法在时间层 $t^{n+1}$ 对方程进行离散。时间导数 $u_t$ 用后向差分近似，空间导数 $u_{xx}$ 用中心差分近似，两者都在 $(x_i, t^{n+1})$ 处求值。\n$$\n\\frac{u_{i}^{n+1} - u_{i}^{n}}{\\Delta t} \\;=\\; \\kappa\\,\\frac{u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}}{h^{2}} \\;+\\; \\beta\\,u_{i}^{n+1}\n$$\n该方程对内部网格点 $i=1, \\dots, M-1$ 成立。\n\n我们重排该方程，将时间层 $n+1$ 的项归到左侧，时间层 $n$ 的项归到右侧。乘以 $\\Delta t$ 得\n$$\nu_{i}^{n+1} - u_{i}^{n} \\;=\\; \\frac{\\kappa\\,\\Delta t}{h^{2}}(u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}) \\;+\\; \\beta\\,\\Delta t\\,u_{i}^{n+1}\n$$\n使用给定的扩散比 $\\lambda = \\frac{\\kappa\\,\\Delta t}{h^{2}}$，我们有\n$$\nu_{i}^{n+1} - u_{i}^{n} \\;=\\; \\lambda(u_{i+1}^{n+1} - 2u_{i}^{n+1} + u_{i-1}^{n+1}) \\;+\\; \\beta\\,\\Delta t\\,u_{i}^{n+1}\n$$\n将上标为 $n+1$ 的项归到左侧，得到\n$$\n-\\lambda u_{i-1}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{i}^{n+1} - \\lambda u_{i+1}^{n+1} \\;=\\; u_{i}^{n}\n$$\n这组关于 $i=1, \\dots, M-1$ 的方程构成了一个求解未知内部值向量 $\\mathbf{u}^{n+1} = [u_{1}^{n+1}, u_{2}^{n+1}, \\dots, u_{M-1}^{n+1}]^T$ 的线性系统。我们将此系统写成矩阵形式 $A\\mathbf{u}^{n+1} = \\mathbf{b}$。\n\n在内部区域的边界，对于 $i=1$ 和 $i=M-1$，我们引入狄利克雷边界条件：$u_{0}^{n+1} = g_{0}(t^{n+1})$ 和 $u_{M}^{n+1} = g_{1}(t^{n+1})$。\n对于 $i=1$：\n$$\n-\\lambda u_{0}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{1}^{n+1} - \\lambda u_{2}^{n+1} \\;=\\; u_{1}^{n}\n$$\n$$\n(1 + 2\\lambda - \\beta\\Delta t)u_{1}^{n+1} - \\lambda u_{2}^{n+1} \\;=\\; u_{1}^{n} + \\lambda g_{0}(t^{n+1})\n$$\n对于 $i=M-1$：\n$$\n-\\lambda u_{M-2}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{M-1}^{n+1} - \\lambda u_{M}^{n+1} \\;=\\; u_{M-1}^{n}\n$$\n$$\n-\\lambda u_{M-2}^{n+1} + (1 + 2\\lambda - \\beta\\Delta t)u_{M-1}^{n+1} \\;=\\; u_{M-1}^{n} + \\lambda g_{1}(t^{n+1})\n$$\n矩阵 $A$ 是一个 $(M-1) \\times (M-1)$ 的三对角矩阵，其元素为：\n$$\na_{ii} = 1 + 2\\lambda - \\beta\\Delta t \\quad \\text{对于 } i=1, \\dots, M-1\n$$\n$$\na_{i,i-1} = a_{i,i+1} = -\\lambda \\quad \\text{对于相关的 } i\n$$\n右侧向量 $\\mathbf{b}$ 的分量为：\n$$\nb_{1} = u_{1}^{n} + \\lambda g_{0}(t^{n+1})\n$$\n$$\nb_{i} = u_{i}^{n} \\quad \\text{对于 } i=2, \\dots, M-2\n$$\n$$\nb_{M-1} = u_{M-1}^{n} + \\lambda g_{1}(t^{n+1})\n$$\n问题要求，如果前一时间步的解是非负的（对所有 $i$ 有 $u_{i}^{n} \\ge 0$）并且边界数据是非负的（$g_{0}(t^{n+1}) \\ge 0$，$g_{1}(t^{n+1}) \\ge 0$），那么新时间步的解也必须是非负的（对所有 $i$ 有 $u_{i}^{n+1} \\ge 0$）。\n已知 $\\kappa>0$，$\\Delta t > 0$ 且 $h>0$，我们有 $\\lambda>0$。$u_{i}^{n} \\ge 0$，$g_0 \\ge 0$，$g_1 \\ge 0$ 的假设确保了向量 $\\mathbf{b}$ 的每个分量都是非负的，即 $\\mathbf{b} \\ge \\mathbf{0}$（逐分量）。\n因此，保正性可转化为以下矩阵性质：如果 $\\mathbf{b} \\ge \\mathbf{0}$，那么解 $\\mathbf{u}^{n+1} = A^{-1}\\mathbf{b}$ 必须满足 $\\mathbf{u}^{n+1} \\ge \\mathbf{0}$。这当且仅当逆矩阵 $A^{-1}$ 的所有元素都非负时成立，即 $A^{-1} \\ge 0$。具有此性质的矩阵 $A$ 称为单调矩阵。\n\n一个矩阵是单调矩阵的一个充分条件是它是一个非奇异 M 矩阵。一个实方阵 $A=(a_{ij})$ 如果满足以下条件，则为 M 矩阵：\n1. 对所有 $i$，$a_{ii} > 0$（正对角元素）。\n2. 对所有 $i \\ne j$，$a_{ij} \\le 0$（一个 Z 矩阵）。\n3. $A$ 是非奇异的，且 $A^{-1}$ 的所有元素都非负。确保这一点的常用方法是证明 $A$ 是严格或不可约对角占优的。\n\n我们来检查我们的矩阵 $A$ 是否满足这些条件。\n条件 2：非对角元素为 $a_{i,j} = -\\lambda$。由于 $\\lambda = \\frac{\\kappa \\Delta t}{h^2} \\ge 0$，此条件得到满足。$A$ 是一个 Z 矩阵。\n条件 1：对角元素必须为正：$a_{ii} = 1 + 2\\lambda - \\beta\\Delta t > 0$。这个条件必须对所有可能的空间网格选择都成立，这意味着它必须对所有 $\\lambda \\ge 0$ 都成立。表达式 $1 + 2\\lambda - \\beta\\Delta t$ 是 $\\lambda$ 的一个线性函数。它在定义域 $\\lambda \\ge 0$ 上的最小值出现在 $\\lambda=0$ 处。因此，为使不等式对所有 $\\lambda \\ge 0$ 都成立，它必须在该最小值处成立：\n$$\n1 + 2(0) - \\beta\\Delta t > 0 \\implies 1 - \\beta\\Delta t > 0 \\implies \\Delta t  \\frac{1}{\\beta}\n$$\n我们来分析对角占优作为另一种途径，这可以为 M 矩阵候选者确立非奇异性和单调性。如果一个矩阵 $A$ 是不可约的，在所有行上都是弱对角占优的（$|a_{ii}| \\ge \\sum_{j\\ne i} |a_{ij}|$），并且在至少一行上是严格对角占优的（$|a_{ii}|  \\sum_{j\\ne i} |a_{ij}|$），那么它就是不可约对角占优的。\n对于我们的矩阵 $A$，它是一个具有非零非对角线元素的三对角矩阵，因此是不可约的。\n对于行 $i=2, \\dots, M-2$ 的弱对角占优条件是：\n$$\n|1 + 2\\lambda - \\beta\\Delta t| \\ge |-\\lambda| + |-\\lambda| = 2\\lambda\n$$\n假设对角线元素为正，这就是 $1 + 2\\lambda - \\beta\\Delta t \\ge 2\\lambda$，可以简化为 $1 - \\beta\\Delta t \\ge 0$。\n对于第一行和最后一行（$i=1, M-1$），条件是：\n$$\n|1 + 2\\lambda - \\beta\\Delta t| \\ge |-\\lambda| = \\lambda\n$$\n可以简化为 $1 + 2\\lambda - \\beta\\Delta t \\ge \\lambda$，或 $1 + \\lambda - \\beta\\Delta t \\ge 0$。\n为了使该条件对所有行和所有 $\\lambda \\ge 0$ 都成立，必须满足这些条件中最严格的一个。这显然是 $1 - \\beta\\Delta t \\ge 0$，意味着 $\\Delta t \\le 1/\\beta$。\n\n我们来验证 $\\Delta t \\le 1/\\beta$ 是一个充分条件。如果 $\\Delta t \\le 1/\\beta$，那么 $1 - \\beta\\Delta t \\ge 0$。\n- 对角元素为 $a_{ii} = (1 - \\beta\\Delta t) + 2\\lambda \\ge 2\\lambda$。对于任何有效的离散化（$\\Delta t0, h0$），我们有 $\\lambda  0$，所以 $a_{ii}  0$。\n- 非对角元素为 $-\\lambda \\le 0$。\n- 我们已经为所有行建立了弱对角占优：对于内部行 $a_{ii} \\ge 2\\lambda$，对于边界行 $a_{ii} \\ge 2\\lambda  \\lambda$。\n矩阵 $A$ 是不可约对角占优的。这样的矩阵是一个非奇异 M 矩阵，其逆矩阵 $A^{-1}$ 的所有元素均为正。因此，如果 $\\Delta t \\le 1/\\beta$，则对于任何 $h  0$ 的选择，保正性都成立。\n\n现在我们必须证明这个条件是尖锐的（必要的）。假设我们选择一个时间步长 $\\Delta t$ 使得 $\\Delta t  1/\\beta$。令 $\\Delta t = (1+\\epsilon)/\\beta$，其中某个 $\\epsilon  0$。那么 $1 - \\beta\\Delta t = -\\epsilon  0$。\n矩阵 $A$ 的对角元素变为 $a_{ii} = 1 + 2\\lambda - \\beta\\Delta t = 2\\lambda - \\epsilon$。\n保正性条件必须对所有空间网格都成立，即对所有 $\\lambda \\ge 0$ 的值都成立。我们可以自由选择网格尺寸 $h$ 以得到任何 $\\lambda$。如果我们选择一个粗糙的网格（大的 $h$）或一个小的 $\\kappa$，我们可以使 $\\lambda$ 任意小。具体来说，我们可以选择 $h$ 使得 $\\lambda = \\frac{\\kappa \\Delta t}{h^2}  \\frac{\\epsilon}{2}$。\n对于这样的选择，对角元素 $a_{ii} = 2\\lambda - \\epsilon$ 变为负数。一个具有负对角元素的矩阵不可能是 M 矩阵，保正性无法保证。\n为了更明确地看到这一点，考虑极限 $\\lambda \\to 0$。系统矩阵 $A$ 趋近于 $(1-\\beta\\Delta t)I = -\\epsilon I$，其中 $I$ 是单位矩阵。线性系统近似变为 $-\\epsilon \\mathbf{u}^{n+1} = \\mathbf{u}^n$。如果我们从 $\\mathbf{u}^n  \\mathbf{0}$ 开始，下一个解是 $\\mathbf{u}^{n+1} \\approx -\\frac{1}{\\epsilon}\\mathbf{u}^n$，这是负的。这违反了保正性。\n因此，条件 $\\Delta t \\le 1/\\beta$ 是必要的。\n\n由于条件 $\\Delta t \\le 1/\\beta$ 对于所有 $\\lambda \\ge 0$ 的保正性是充要的，尖锐条件是该不等式的边界情况。$\\Delta t$ 的最大允许值是满足此条件的最大值。\n\n最大允许的 $\\Delta t$ 是 $\\frac{1}{\\beta}$。",
            "answer": "$$\\boxed{\\frac{1}{\\beta}}$$"
        },
        {
            "introduction": "在掌握了理论之后，通过代码实现和验证来巩固理解是至关重要的一步。本练习将指导你从零开始实现BTCS方法，并设计一个网格加密实验，以经验性地验证其理论收敛阶，即时间上的一阶精度和空间上的二阶精度($\\mathcal{O}(\\Delta t) + \\mathcal{O}((\\Delta x)^2)$)。通过精心设计的实验，你还将学习如何分离和评估时间误差与空间误差的各自贡献，这是数值方法验证中的一项基本技能。",
            "id": "3365331",
            "problem": "考虑定义在有限区间上、具有常数扩散系数和齐次狄利克雷边界条件的一维热方程。其控制偏微分方程为 $u_t = \\alpha u_{xx}$，定义在 $x \\in [0,1]$，$t \\in [0,T]$ 上，边界条件为 $u(0,t)=0$，$u(1,t)=0$，初始条件为 $u(x,0)=\\sin(\\pi x)$。与这些数据一致的精确解是 $u(x,t)=\\exp(-\\alpha \\pi^2 t)\\sin(\\pi x)$。你将使用后向时间中心空间 (BTCS) 方法来数值逼近该解。该方法定义为时间上使用后向欧拉法，空间上使用标准的二阶中心差分格式。从相容的空间有限差分和后向欧拉时间离散化的基本定义出发，推导在狄利克雷边界条件下每个时间步需要求解的线性系统。确保你推导出的代数系统在维度上是一致的，并且尊重边界值。\n\n你的任务是设计并实现一个网格加密实验，以经验性地验证 BTCS 方法的 $\\mathcal{O}(\\Delta t) + \\mathcal{O}((\\Delta x)^2)$ 收敛行为，并展示如何分离时间和空间误差的贡献。使用离散 $L^2$ 范数量化误差，对于内部节点上的网格函数 $e_i$，其定义为 $\\|e\\|_{L^2_h} = \\sqrt{\\Delta x}\\left(\\sum_i e_i^2\\right)^{1/2}$。相对于加密参数 $h$ 的观测收敛率，通过在一个加密序列上对 $\\log(E)$ 与 $\\log(h)$ 进行最小二乘拟合得到的斜率来衡量，其中 $E$ 表示在 $\\| \\cdot \\|_{L^2_h}$ 范数下的误差。\n\n实现以下三个实验，每个实验都旨在探究误差的不同方面：\n\n- 空间加密主导的实验（用于测量 $\\mathcal{O}((\\Delta x)^2)$ 的贡献）：固定一个非常小的时间步长，使得时间误差相对于空间误差可以忽略不计。使用 $\\alpha = 1$，$T=0.01$，以及目标时间步长 $\\Delta t_{\\mathrm{target}}=10^{-5}$。对于每个 $N_x \\in \\{16,32,64,128\\}$，设置 $\\Delta x = 1/N_x$，设置时间步数 $N_t=\\lceil T/\\Delta t_{\\mathrm{target}} \\rceil$，然后将实际时间步长设置为 $\\Delta t = T/N_t$，以确保模拟恰好在 $t=T$ 结束。计算在 $t=T$ 时与精确解的离散 $L^2$ 误差，并通过拟合 $\\log(E)$ 与 $\\log(\\Delta x)$ 来估计观测到的空间收敛率。\n\n- 时间加密主导的实验（用于测量 $\\mathcal{O}(\\Delta t)$ 的贡献）：固定一个非常精细的空间网格，使得空间误差相对于时间误差可以忽略不计。使用 $\\alpha = 1$，$T=0.01$，固定 $N_x=512$ 以使 $\\Delta x = 1/512$，并对 $N_t \\in \\{4,8,16,32\\}$（即 $\\Delta t = T/N_t$）进行计算。计算在 $t=T$ 时的离散 $L^2$ 误差，并通过拟合 $\\log(E)$ 与 $\\log(\\Delta t)$ 来估计观测到的时间收敛率。\n\n- 耦合加密实验（用于验证组合的 $\\mathcal{O}(\\Delta t) + \\mathcal{O}((\\Delta x)^2)$ 行为，其中各项贡献处于同一量级）：使用 $\\alpha = 1$，$T=0.01$，选择 $N_x \\in \\{16,32,64,128\\}$，并设置耦合常数 $c=0.4$。对于每个 $N_x$，首先计算名义上的 $\\Delta t_{\\mathrm{nom}} = c\\,\\Delta x^2$，然后设置 $N_t=\\max\\{1,\\mathrm{round}(T/\\Delta t_{\\mathrm{nom}})\\}$ 并使用实际的 $\\Delta t=T/N_t$。计算在 $t=T$ 时的离散 $L^2$ 误差，并通过拟合 $\\log(E)$ 与 $\\log(\\Delta x)$ 以及分别与 $\\log(\\Delta t)$ 来估计观测到的耦合收敛率。\n\n在所有实验中，仅对内部点实现全离散形式的 BTCS 方法，并精确处理狄利克雷边界。基于第一性原理构建线性系统，不使用任何预打包的偏微分方程求解器。确保每个时间步的线性代数运算都以一致的方式执行。\n\n测试套件和要求的输出：\n\n- 使用上面指定的三个实验，并采用所述的参数值。这三个实验共同构成测试套件。它们涵盖了一般情况，分离了空间和时间误差，并包括了诸如粗网格 ($N_x=16$) 和极少时间步 ($N_t=4$) 等极端情况。\n\n- 对于空间加密主导的实验，报告一个浮点数：估计的空间阶 $p_{\\mathrm{space}}$。\n\n- 对于时间加密主导的实验，报告一个浮点数：估计的时间阶 $p_{\\mathrm{time}}$。\n\n- 对于耦合加密实验，报告两个浮点数：相对于空间加密的估计阶 $p_{\\mathrm{coupled},x}$ 和相对于时间加密的估计阶 $p_{\\mathrm{coupled},t}$。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。该列表必须按 $[p_{\\mathrm{space}},p_{\\mathrm{time}},p_{\\mathrm{coupled},x},p_{\\mathrm{coupled},t}]$ 的顺序排列。所有输出都必须是浮点数。此问题不涉及物理单位；所有量均为无量纲量。",
            "solution": "我们从一维热方程 $u_t=\\alpha u_{xx}$ 的基本公式开始，该方程定义在 $x\\in[0,1]$上，满足边界条件 $u(0,t)=0$，$u(1,t)=0$ 和初始条件 $u(x,0)=\\sin(\\pi x)$。这些数据的精确解是 $u(x,t)=\\exp(-\\alpha \\pi^2 t)\\sin(\\pi x)$，它为评估数值误差提供了一个可靠的参考。后向时间中心空间方法在时间上使用后向欧拉法，在空间上对拉普拉斯算子使用标准的二阶中心有限差分。\n\n全离散格式的推导遵循核心定义。设空间网格有 $N_x$ 个均匀子区间，间距为 $\\Delta x = 1/N_x$，内部节点为 $x_i=i\\Delta x$，$i=1,2,\\dots,N_x-1$。设时间网格有 $N_t$ 步，步长为 $\\Delta t = T/N_t$，时间点为 $t^n = n\\Delta t$，$n=0,1,\\dots,N_t$。定义 $u_i^n \\approx u(x_i,t^n)$。后向欧拉时间离散化为 $u_t(x_i,t^{n+1}) \\approx (u_i^{n+1} - u_i^n)/\\Delta t$。二阶导数的二阶中心差分为 $u_{xx}(x_i,t^{n+1}) \\approx (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1})/\\Delta x^2$。将这些代入 $u_t=\\alpha u_{xx}$ 可得\n$$(u_i^{n+1} - u_i^n)/\\Delta t = \\alpha \\frac{u_{i-1}^{n+1} - 2 u_i^{n+1} + u_{i+1}^{n+1}}{\\Delta x^2}。$$\n重新整理并定义 $r = \\alpha \\Delta t / \\Delta x^2$，我们得到内部索引 $i=1,\\dots,N_x-1$ 的线性系统，\n$$-r\\,u_{i-1}^{n+1} + (1+2r)\\,u_i^{n+1} - r\\,u_{i+1}^{n+1} = u_i^n。$$\n边界条件是 $u_0^{n+1}=u_{N_x}^{n+1}=0$，因此对于齐次狄利克雷边界，右侧没有额外项。写成矩阵形式，对于内部未知向量 $u^{n+1}\\in\\mathbb{R}^{N_x-1}$，我们求解\n$$(I - \\Delta t\\,\\alpha\\,L_h) u^{n+1} = u^n，$$\n其中 $L_h$ 是离散拉普拉斯算子，采用二阶中心差分并按 $\\Delta x^{-2}$ 缩放。当 $\\alpha0$ 时，系数矩阵是严格对角占优且对称正定的，因此对于任何 $\\Delta t0$，该系统都有唯一解。该方法是无条件稳定的，并且对于足够光滑的解，其局部截断误差在时间上是一阶的，在空间上是二阶的；因此，对于光滑解，全局误差的行为是 $\\mathcal{O}(\\Delta t) + \\mathcal{O}((\\Delta x)^2)$。\n\n为了经验性地验证这一行为并分离时间和空间的贡献，我们设计了三个实验：\n\n1. 空间加密主导的实验：固定一个非常小的 $\\Delta t$，使得在空间加密过程中，$\\mathcal{O}(\\Delta t)$ 项相对于 $\\mathcal{O}((\\Delta x)^2)$ 项可以忽略不计。我们使用 $\\alpha=1$，$T=0.01$，以及目标 $\\Delta t_{\\mathrm{target}}=10^{-5}$。对于每个 $N_x\\in\\{16,32,64,128\\}$，设置 $N_t=\\lceil T/\\Delta t_{\\mathrm{target}}\\rceil$ 和 $\\Delta t=T/N_t$。对于每个网格，我们计算在 $t=T$ 时离散 $L^2$ 范数下的误差 $E(\\Delta x)$，并通过对 $\\log(E)$ 与 $\\log(\\Delta x)$ 进行最小二乘拟合来估计空间阶。因为在加密的网格上，$\\Delta t$ 远小于 $\\Delta x^2$（例如，对于 $N_x=128$，$\\Delta x^2 \\approx 6.10\\times 10^{-5}$，而 $\\Delta t=10^{-5}$），观测到的斜率应接近于 $2$。\n\n2. 时间加密主导的实验：固定一个非常精细的空间网格，使得 $\\mathcal{O}((\\Delta x)^2)$ 的空间误差相对于时间离散化误差可以忽略不计。我们使用 $\\alpha=1$，$T=0.01$，固定 $N_x=512$ 以使 $\\Delta x^2 \\approx 3.81\\times 10^{-6}$，并改变 $N_t\\in\\{4,8,16,32\\}$，使得 $\\Delta t$ 从 $2.5\\times 10^{-3}$ 降至 $3.125\\times 10^{-4}$，这些值都远大于 $\\Delta x^2$。我们计算误差 $E(\\Delta t)$，并对 $\\log(E)$ 与 $\\log(\\Delta t)$ 进行拟合。斜率应接近于 $1$。\n\n3. 耦合加密实验：设置 $\\Delta t = c\\,\\Delta x^2$（为了对齐最终时间而进行取整），使得时间和空间误差处于同一量级。我们使用 $\\alpha=1$，$T=0.01$，$c=0.4$，以及 $N_x\\in\\{16,32,64,128\\}$。对于每个 $N_x$，计算名义上的 $\\Delta t_{\\mathrm{nom}}=c\\,\\Delta x^2$，然后选择 $N_t=\\max\\{1,\\mathrm{round}(T/\\Delta t_{\\mathrm{nom}})\\}$ 和 $\\Delta t=T/N_t$。计算在 $t=T$ 时的误差；当对 $\\Delta x$ 进行拟合时，误差的行为类似于 $\\mathcal{O}((\\Delta x)^2)$，产生的观测斜率接近 $2$。当对 $\\Delta t$ 进行拟合时，利用关系 $\\Delta t\\propto \\Delta x^2$，因此误差的行为类似于 $\\mathcal{O}(\\Delta t)$，得到的斜率接近 $1$。\n\n算法设计的细节如下：\n\n- 组装三对角矩阵，其主对角线元素为 $(1+2r)$，次对角线元素为 $(-r)$，其中 $r=\\alpha \\Delta t/\\Delta x^2$。这对应于作用在内部向量上的算子 $(I - \\Delta t\\,\\alpha\\,L_h)$。\n\n- 对于每个 $(\\Delta x,\\Delta t)$ 的选择，使用稀疏直接求解器对稀疏矩阵进行一次预分解，以加速每个时间步的重复求解。\n\n- 使用线性系统给出的递推关系进行 $N_t$ 步的时间推进。由于边界值为零且恒定，每一步的右侧是前一个时间步的内部向量。\n\n- 在内部网格点 $x_i=i\\Delta x$（其中 $i=1,\\dots,N_x-1$）和时间 $t=T$ 处计算精确解，计算误差 $e_i=u_i^{N_t}-u(x_i,T)$ 的离散 $L^2$ 范数，即 $\\|e\\|_{L^2_h}=\\sqrt{\\Delta x}\\left(\\sum_i e_i^2\\right)^{1/2}$。\n\n- 通过对 $\\log(E)$ 与 $\\log(h)$ 进行线性拟合，以最小二乘意义下的斜率来估计观测到的收敛率，其中 $h$ 根据实验的不同，可以是 $\\Delta x$ 或 $\\Delta t$。\n\n最终的程序执行这三个实验，计算所需的四个度量指标 $[p_{\\mathrm{space}},p_{\\mathrm{time}},p_{\\mathrm{coupled},x},p_{\\mathrm{coupled},t}]$，并将它们作为逗号分隔的列表，用方括号括起来，打印在单行上。对于一个光滑的精确解，我们期望得到接近 $[2,1,2,1]$ 的值，允许由于有限样本大小、$N_t$ 的取整以及在少数加密级别上进行最小二乘拟合而产生的微小偏差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef exact_solution(x, t, alpha):\n    # Exact solution: exp(-alpha*pi^2*t) * sin(pi*x)\n    return np.exp(-alpha * (np.pi**2) * t) * np.sin(np.pi * x)\n\ndef build_btcs_solver(alpha, dx, dt, nx_interior):\n    # Build (I - dt*alpha*L_h) where L_h is centered second-difference / dx^2\n    r = alpha * dt / (dx * dx)\n    main = (1.0 + 2.0 * r) * np.ones(nx_interior)\n    off = (-r) * np.ones(nx_interior - 1)\n    A = diags(diagonals=[off, main, off], offsets=[-1, 0, 1], format='csc')\n    # Factorize once for repeated solves\n    solver = splu(A)\n    return solver\n\ndef btcs_heat(alpha, T, Nx, Nt):\n    # Returns interior solution at final time T, and grid spacing dx\n    dx = 1.0 / Nx\n    dt = T / Nt\n    nx_interior = Nx - 1\n    # Interior grid points x_i = i*dx, i = 1..Nx-1\n    x_interior = np.linspace(dx, 1.0 - dx, nx_interior)\n\n    # Initial condition on interior: sin(pi x)\n    u = np.sin(np.pi * x_interior).copy()\n\n    # Pre-factorized solver for the linear system\n    solver = build_btcs_solver(alpha, dx, dt, nx_interior)\n\n    # Time stepping\n    for _ in range(Nt):\n        u = solver.solve(u)\n\n    return u, x_interior, dx, dt\n\ndef discrete_L2_error(u_num, x_interior, dx, T, alpha):\n    u_ex = exact_solution(x_interior, T, alpha)\n    e = u_num - u_ex\n    return np.sqrt(dx) * np.linalg.norm(e, ord=2)\n\ndef observed_order(h_list, E_list):\n    # Fit log(E) = p * log(h) + c\n    logh = np.log(np.array(h_list))\n    logE = np.log(np.array(E_list))\n    p, _ = np.polyfit(logh, logE, 1)\n    return p\n\ndef spatial_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx_list = [16, 32, 64, 128]\n    # Target very small dt to suppress temporal error; adjust Nt to land on T\n    dt_target = 1e-5\n    Nt = int(np.ceil(T / dt_target))\n    # Final actual dt used\n    dt_actual = T / Nt\n\n    dx_list = []\n    E_list = []\n    for Nx in Nx_list:\n        u_num, x_interior, dx, _ = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx, T, alpha)\n        dx_list.append(dx)\n        E_list.append(E)\n    p_space = observed_order(dx_list, E_list)\n    return p_space\n\ndef temporal_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx = 512  # very fine spatial grid to suppress spatial error\n    Nt_list = [4, 8, 16, 32]\n\n    dt_list = []\n    E_list = []\n    for Nt in Nt_list:\n        u_num, x_interior, dx, dt = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx, T, alpha)\n        dt_list.append(dt)\n        E_list.append(E)\n    p_time = observed_order(dt_list, E_list)\n    return p_time\n\ndef coupled_refinement_experiment():\n    alpha = 1.0\n    T = 0.01\n    Nx_list = [16, 32, 64, 128]\n    c = 0.4\n\n    dx_list = []\n    dt_list = []\n    E_list = []\n    for Nx in Nx_list:\n        dx = 1.0 / Nx\n        dt_nom = c * dx * dx\n        # Choose Nt so that dt ~ c*dx^2 and T is reached exactly\n        Nt = int(max(1, round(T / dt_nom)))\n        u_num, x_interior, dx_used, dt_used = btcs_heat(alpha, T, Nx, Nt)\n        E = discrete_L2_error(u_num, x_interior, dx_used, T, alpha)\n        dx_list.append(dx_used)\n        dt_list.append(dt_used)\n        E_list.append(E)\n    p_coupled_x = observed_order(dx_list, E_list)\n    p_coupled_t = observed_order(dt_list, E_list)\n    return p_coupled_x, p_coupled_t\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Three experiments: spatial-dominated, temporal-dominated, coupled refinement\n    results = []\n    p_space = spatial_refinement_experiment()\n    results.append(f\"{p_space:.6f}\")\n    p_time = temporal_refinement_experiment()\n    results.append(f\"{p_time:.6f}\")\n    p_cx, p_ct = coupled_refinement_experiment()\n    results.append(f\"{p_cx:.6f}\")\n    results.append(f\"{p_ct:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "最后的这项实践将BTCS方法置于一个更高级和更实际的应用场景中：作为计算流体力学（CFD）中半隐式求解器的一个子步骤。你将分析和比较BTCS、Crank-Nicolson以及带有Rannacher启动的Crank-Nicolson方案在处理粘性项时的性能差异。此练习的核心在于量化不同方法对高频空间模式的阻尼特性，这对于评估复杂流动模拟中的数值稳定性和解的质量至关重要。",
            "id": "3365299",
            "problem": "考虑在不可压缩Navier–Stokes方程的半隐式处理中出现的粘性子步，其中对流项被显式处理，而粘性项被隐式处理。在没有对流贡献的情况下，该子步简化为单个速度分量的线性扩散方程，即一维热传导方程\n$$\n\\partial_t u(x,t) = \\nu \\,\\partial_{xx} u(x,t),\n$$\n该方程定义在长度为 $1$ 的周期性区间上，运动粘度 $\\nu  0$。您必须在均匀周期性网格上分析并实现三种用于隐式扩散子步的时间积分策略。\n\n基本基础与离散化框架：\n- 使用具有 $N$ 个点和网格间距 $h = 1/N$ 的均匀网格。设网格点 $j$ 和时间层 $n$ 处的未知量表示为 $u_j^n$，其中 $j \\in \\{0,1,\\dots,N-1\\}$。\n- 使用带周期性环绕的标准二阶中心差分来近似拉普拉斯算子：\n$$\n(\\Delta_h u)_j = \\frac{u_{j+1} - 2 u_j + u_{j-1}}{h^2},\n$$\n其中下标对 $N$ 取模。\n- 引入无量纲步长参数\n$$\nr = \\frac{\\nu\\,\\Delta t}{h^2},\n$$\n其中 $\\Delta t$ 是时间步长。\n\n需要实现的时间离散化方法：\n- 后向时间中心空间（BTCS）：采用上述空间离散化的后向欧拉时间离散化。这是标准的无条件稳定扩散隐式格式，通过用后向差分替换 $\\partial_t u$，并用新时间层的中心差分替换 $\\partial_{xx} u$ 得到。\n- Crank–Nicolson（CN）：用于扩散子步的梯形（时间中心）方法，通过对时间层 $n$ 和 $n+1$ 处的空间算子取平均得到。\n- 带Rannacher启动的Crank–Nicolson：将第一个完整的 $\\Delta t$ 步替换为两个大小为 $\\Delta t/2$ 的后向欧拉半步（使用相同的空间算子），以提供对高频分量的额外阻尼。对于本问题，您只需考虑通过两个大小为 $\\Delta t/2$ 的后向欧拉求解实现的总时间步长 $\\Delta t$ 内的传播；不进行后续步骤。\n\n评估任务：\n- 考虑周期性网格上最高可分辨的空间傅里叶模态，由网格函数 $v_j = (-1)^j$ 给出。这是均匀周期性网格上离散拉普拉斯算子的一个特征向量。对于上面列出的三种格式中的每一种，按如下方式定义单步放大率：从 $u^0 = v$ 开始，根据该格式计算一个总时间步长 $\\Delta t$ 后的 $u^1$，并报告比率\n$$\nG = \\frac{\\|u^1\\|_2}{\\|u^0\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是欧几里得范数。该量度量了该最高频率模态的粘性阻尼。因为网格算子是循环的，$v$ 是一个特征向量，所以 $G$ 与相应标量放大因子的模长相吻合。\n- 您的程序必须构建与中心差分对应的周期性离散拉普拉斯矩阵，形成每种时间离散化所隐含的线性系统，并对下面指定的参数集通过线性代数数值计算 $G$。在您的实现中不要使用任何预先推导的闭式放大公式；结果应通过组装和应用线性系统得出。\n\n测试套件：\n- 使用粘度 $\\nu = 0.01$ 和网格大小 $N = 64$（因此 $h = 1/64$）。\n- 对以下三个时间步长 $\\Delta t$ 中的每一个，评估单步放大率 $G$：\n  - 小步长：$\\Delta t = 0.0005$。\n  - 中等步长：$\\Delta t = 0.005$。\n  - 大步长：$\\Delta t = 0.05$。\n- 对于每个 $\\Delta t$，按以下顺序计算并报告放大率三元组：BTCS、CN、带Rannacher启动的CN（两个后向欧拉半步）。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含所有九个结果，形式为方括号内的逗号分隔列表，按 $\\Delta t$ 递增排序，并且对于每个 $\\Delta t$，按上述指定的格式顺序排列。具体来说，输出格式必须是\n$$\n[\\text{G\\_BTCS}(\\Delta t_1),\\text{G\\_CN}(\\Delta t_1),\\text{G\\_Rannacher}(\\Delta t_1),\\text{G\\_BTCS}(\\Delta t_2),\\text{G\\_CN}(\\Delta t_2),\\text{G\\_Rannacher}(\\Delta t_2),\\text{G\\_BTCS}(\\Delta t_3),\\text{G\\_CN}(\\Delta t_3),\\text{G\\_Rannacher}(\\Delta t_3)],\n$$\n其中 $\\Delta t_1 = 0.0005$，$\\Delta t_2 = 0.005$，$\\Delta t_3 = 0.05$。每个数字必须四舍五入到6位小数。不应打印任何其他文本。",
            "solution": "该问题要求对一维扩散方程 $\\partial_t u = \\nu \\partial_{xx} u$ 在周期性域上的三种隐式时间积分格式进行分析和数值实现。目标是计算离散网格上最高频率傅里叶模态的单步放大率。\n\n控制偏微分方程（PDE）是热传导方程：\n$$\n\\partial_t u(x,t) = \\nu \\,\\partial_{xx} u(x,t)\n$$\n其中 $u(x,t)$ 是关注的物理量（例如，速度分量），$x \\in [0,1)$ 是具有周期性边界条件的空间坐标，$t$ 是时间，$\\nu  0$ 是恒定的运动粘度。\n\n我们首先对空间域进行离散化。使用具有 $N$ 个点的均匀网格，网格间距为 $h = 1/N$。网格点为 $x_j = j h$，其中 $j \\in \\{0, 1, \\dots, N-1\\}$。令 $U(t)$ 为时间 $t$ 时网格值的列向量，$U(t) = [u(x_0,t), u(x_1,t), \\dots, u(x_{N-1},t)]^T$。二阶空间导数 $\\partial_{xx} u$ 使用带周期性边界条件的标准二阶中心差分算子进行近似：\n$$\n(\\Delta_h u)_j = \\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2}\n$$\n其中下标对 $N$ 取模。这种空间离散化将偏微分方程（PDE）转化为一个常微分方程组（ODE）：\n$$\n\\frac{d U}{dt} = \\nu A U(t)\n$$\n这里，$A$ 是离散拉普拉斯算子 $\\Delta_h$ 的 $N \\times N$ 矩阵表示。它是一个实对称循环矩阵，形式如下：\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n-2  1  0  \\dots  0  1 \\\\\n1  -2  1  \\ddots   0 \\\\\n0  1  -2  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1  0 \\\\\n0   \\ddots  1  -2  1 \\\\\n1  0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n令 $U^n$表示在时间 $t_n = n \\Delta t$ 时 $U(t)$ 的数值近似。我们现在介绍三种时间步进格式。\n\n1.  **后向时间中心空间（BTCS）**：此格式对时间导数使用一阶后向欧拉方法，在未来的时间层 $n+1$ 处计算空间项。\n    $$\n    \\frac{U^{n+1} - U^n}{\\Delta t} = \\nu A U^{n+1}\n    $$\n    重新整理各项以求解 $U^{n+1}$，得到线性系统：\n    $$\n    (I - \\nu \\Delta t A) U^{n+1} = U^n\n    $$\n    其中 $I$ 是 $N \\times N$ 的单位矩阵。\n\n2.  **Crank–Nicolson (CN)**：此格式基于用于时间积分的二阶梯形法则，对时间层 $n$ 和 $n+1$ 处的空间项进行平均。\n    $$\n    \\frac{U^{n+1} - U^n}{\\Delta t} = \\frac{\\nu A}{2} (U^n + U^{n+1})\n    $$\n    将包含 $U^{n+1}$ 的项归到左侧，将包含 $U^n$ 的项归到右侧，我们得到线性系统：\n    $$\n    \\left(I - \\frac{\\nu \\Delta t}{2} A\\right) U^{n+1} = \\left(I + \\frac{\\nu \\Delta t}{2} A\\right) U^n\n    $$\n\n3.  **带Rannacher启动的Crank–Nicolson**：此过程通过执行两个后向欧拉步来抑制高频振荡，每步的时间步长为半个 $\\Delta t/2$。对于本问题，这个两步过程构成了在一个完整时间步长 $\\Delta t$ 内的全部演化。\n    - 第1步（从 $t_n$到 $t_{n+1/2} = t_n + \\Delta t/2$）：\n      $$\n      \\left(I - \\nu \\frac{\\Delta t}{2} A\\right) U^{n+1/2} = U^n\n      $$\n    - 第2步（从 $t_{n+1/2}$ 到 $t_{n+1} = t_n + \\Delta t$）：\n      $$\n      \\left(I - \\nu \\frac{\\Delta t}{2} A\\right) U^{n+1} = U^{n+1/2}\n      $$\n    解第一个方程得到 $U^{n+1/2}$，并将其代入第二个方程，得到整体更新公式：\n    $$\n    U^{n+1} = \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-1} \\left[ \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-1} U^n \\right] = \\left(I - \\nu \\frac{\\Delta t}{2} A\\right)^{-2} U^n\n    $$\n    在数值上，这是通过求解两个具有相同系统矩阵的顺序线性系统来实现的。\n\n评估任务是针对特定的初始条件 $U^0$（对应于网格函数 $v_j = (-1)^j$），计算单步放大率 $G = \\|U^1\\|_2 / \\|U^0\\|_2$。该函数代表了周期性网格上的最高可分辨空间频率。由于 $v_j$ 是循环矩阵 $A$ 的一个特征向量，结果向量 $U^1$ 将是 $U^0$ 的一个标量倍数，而 $G$ 将是这个标量乘子（即放大因子）的模。数值计算步骤如下：\n- 对给定的 $N=64$ 和 $h=1/64$ 构建矩阵 $A$。\n- 构建初始向量 $U^0$，其元素为 $(U^0)_j = (-1)^j$。\n- 对于每种格式和每个给定的 $\\Delta t$：\n    - 为线性系统组装相应的矩阵。\n    - 求解解向量 $U^1$。\n    - 计算欧几里得范数 $\\|U^1\\|_2$ 和 $\\|U^0\\|_2$。\n    - 计算比率 $G = \\|U^1\\|_2 / \\|U^0\\|_2$。\n然后报告指定参数集的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes three time-integration schemes for the 1D heat equation by\n    computing the amplification magnitude for the highest-frequency Fourier mode.\n    \"\"\"\n    # Define parameters from the problem statement\n    nu = 0.01\n    N = 64\n    h = 1.0 / N\n\n    # Define the test cases for the time step delta_t\n    test_cases = [0.0005, 0.005, 0.05]\n\n    # Construct the initial condition vector u0 for the highest-frequency mode\n    # u_j = (-1)^j\n    j_indices = np.arange(N)\n    u0 = (-1.0)**j_indices\n    norm_u0 = np.linalg.norm(u0)\n\n    # Construct the discrete Laplacian matrix A\n    # A = (1/h^2) * L, where L is circulant with (-2, 1, ..., 1) in the first row.\n    diag_val = -2.0\n    off_diag_val = 1.0\n    \n    A_unscaled = np.diag(diag_val * np.ones(N)) + \\\n                 np.diag(off_diag_val * np.ones(N - 1), k=1) + \\\n                 np.diag(off_diag_val * np.ones(N - 1), k=-1)\n    \n    # Apply periodic boundary conditions for the corners\n    A_unscaled[0, N - 1] = off_diag_val\n    A_unscaled[N - 1, 0] = off_diag_val\n\n    A = A_unscaled / (h**2)\n\n    all_results = []\n\n    # Iterate through each test case (each delta_t)\n    for delta_t in test_cases:\n        # 1. Backward-Time Central-Space (BTCS)\n        # (I - nu * dt * A) * u1 = u0\n        mat_btcs = np.identity(N) - nu * delta_t * A\n        u1_btcs = np.linalg.solve(mat_btcs, u0)\n        g_btcs = np.linalg.norm(u1_btcs) / norm_u0\n        all_results.append(g_btcs)\n\n        # 2. Crank-Nicolson (CN)\n        # (I - nu*dt/2 * A) * u1 = (I + nu*dt/2 * A) * u0\n        mat_cn_lhs = np.identity(N) - (nu * delta_t / 2.0) * A\n        mat_cn_rhs = np.identity(N) + (nu * delta_t / 2.0) * A\n        rhs_cn = mat_cn_rhs @ u0\n        u1_cn = np.linalg.solve(mat_cn_lhs, rhs_cn)\n        g_cn = np.linalg.norm(u1_cn) / norm_u0\n        all_results.append(g_cn)\n        \n        # 3. Rannacher Startup (two BTCS half-steps)\n        # (I - nu*dt/2 * A) * u_half = u0\n        # (I - nu*dt/2 * A) * u1 = u_half\n        # The matrix is the same as the CN left-hand side matrix.\n        mat_rannacher = mat_cn_lhs\n        u_half = np.linalg.solve(mat_rannacher, u0)\n        u1_rannacher = np.linalg.solve(mat_rannacher, u_half)\n        g_rannacher = np.linalg.norm(u1_rannacher) / norm_u0\n        all_results.append(g_rannacher)\n\n    # Format the final output string to 6 decimal places per number\n    # The format '{:.6f}'.format is used to ensure trailing zeros are printed.\n    print(f\"[{','.join(map('{:.6f}'.format, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}