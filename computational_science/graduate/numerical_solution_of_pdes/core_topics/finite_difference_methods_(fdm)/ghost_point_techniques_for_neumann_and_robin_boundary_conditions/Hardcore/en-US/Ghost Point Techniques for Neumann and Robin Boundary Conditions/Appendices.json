{
    "hands_on_practices": [
        {
            "introduction": "Understanding the formal order of accuracy is a crucial first step, but practical numerical analysis often requires a deeper look. This exercise demonstrates that two methods, both formally second-order accurate, can exhibit different performance due to the coefficients of their leading error terms. By implementing and comparing two distinct approaches for a Robin boundary condition on a simple Poisson problem , you will learn to quantify and compare their practical accuracy, developing a crucial skill in method selection.",
            "id": "3400414",
            "problem": "Consider the one-dimensional stationary Poisson problem on the closed interval $[0,1]$,\n$$-u''(x) = f(x), \\quad x \\in (0,1),$$\nwith a Robin boundary condition at the left endpoint and a Dirichlet boundary condition at the right endpoint:\n$$\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\\quad u(1) = u_R.$$\nAssume a uniform grid with step size $h = 1/N$ and grid points $x_i = i h$ for $i=0,1,\\dots,N$. Let the exact solution be $u(x) = e^x$, so that $f(x) = -e^x$, and choose the boundary data to be consistent with the exact solution, namely $u_R = e^1$ and $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha + \\beta$.\n\nYou must implement two algebraically different, formally second-order accurate boundary closures at $x=0$ (the Robin boundary), while using the standard second-order central difference for the interior discretization of $-u''$. Both methods should produce a linear system for the nodal values $\\{u_i\\}$ that is solved for the unknowns.\n\n- Method A (Centered ghost-derivative closure with a ghost node and boundary-pinned stencil at $i=0$):\n  - Use the second-order centered finite difference for $-u''$ at all grid points including $i=0$:\n    $$-u''(x_i)\\approx \\frac{-u_{i-1}+2u_i-u_{i+1}}{h^2}.$$\n  - Introduce a ghost value $u_{-1}$ at $x_{-1}=-h$. Enforce the Robin boundary by approximating $u'(0)$ with the centered difference that involves the ghost:\n    $$u'(0)\\approx \\frac{u_1 - u_{-1}}{2h}.$$\n    Eliminate the ghost $u_{-1}$ using the Robin boundary condition and substitute it into the discrete equation at $i=0$. Treat $i=N$ by the given Dirichlet data.\n\n- Method B (One-sided, three-point second-order derivative closure without a ghost node):\n  - For interior nodes $i=1,2,\\dots,N-1$, use the second-order central difference for $-u''$ as in Method A.\n  - At $i=0$, enforce the Robin boundary condition using a one-sided, three-point, second-order approximation of the derivative:\n    $$u'(0)\\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}.$$\n\nFor both methods, build and solve the linear system for the unknowns at nodes $i=0,1,\\dots,N-1$, taking $u_N=u(1)=e^1$ as known. For each method and a given $N$, compute the boundary pointwise error $e_0(h) = |u_0 - u(0)| = |u_0 - e^0|$, and then form the boundary error constant estimator\n$$C(h) = \\frac{e_0(h)}{h^2}.$$\n\nYour task is to design a computational test that reveals which boundary closure yields a smaller boundary error constant. Specifically, for each test case below, estimate the ratio\n$$R = \\frac{C_B(h_\\text{fine})}{C_A(h_\\text{fine})},$$\nwhere $C_A$ and $C_B$ denote the boundary error constant estimators for Method A and Method B, respectively, evaluated at a sufficiently fine grid spacing $h_\\text{fine}$ (with the understanding that $C(h)$ is asymptotically constant for small $h$ in a second-order method). A ratio $R<1$ indicates that Method B has a smaller boundary error constant than Method A for that test, while $R>1$ indicates the opposite.\n\nImplement the above for the following test suite, where each test specifies $(\\alpha,\\beta)$ for the Robin boundary at $x=0$:\n- Test $1$: $(\\alpha,\\beta)=(1,1)$.\n- Test $2$: $(\\alpha,\\beta)=(0,1)$.\n- Test $3$: $(\\alpha,\\beta)=(2,0.5)$.\n\nUse a fine grid with $N=512$ so that $h=1/512$. For each test, compute $R$ as defined above.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, namely the list $[R_1,R_2,R_3]$ for the three tests in the order given. Each $R_k$ must be printed as a floating-point number with exactly six digits after the decimal point.",
            "solution": "The problem as stated is scientifically sound, self-contained, and well-posed. It presents a standard numerical analysis task involving the comparison of two different second-order finite difference treatments for a Robin boundary condition. The problem is therefore deemed valid and a solution will be provided.\n\nThe problem under consideration is the one-dimensional stationary Poisson equation:\n$$ -u''(x) = f(x), \\quad x \\in (0,1) $$\nwith a Robin boundary condition at $x=0$ and a Dirichlet boundary condition at $x=1$:\n$$ \\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma $$\n$$ u(1) = u_R $$\nWe are given the exact solution $u(x) = e^x$, which implies the source term must be $f(x) = -u''(x) = -e^x$. The boundary data are chosen to be consistent with this solution: $u_R = u(1) = e^1$, and $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha\\,(1) + \\beta\\,(1) = \\alpha + \\beta$.\n\nWe use a uniform grid with $N+1$ points $x_i = ih$ for $i=0, 1, \\dots, N$, where the grid spacing is $h=1/N$. Let $u_i$ be the numerical approximation of the exact solution $u(x_i)$. The unknowns are the nodal values $\\{u_0, u_1, \\dots, u_{N-1}\\}$. The value $u_N$ is known from the Dirichlet condition: $u_N = u_R = e^1$. This gives a system of $N$ linear equations for $N$ unknowns.\n\nFor the interior grid points $i=1, 2, \\dots, N-1$, we use the standard second-order centered finite difference approximation for the second derivative:\n$$ -u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\nThis leads to the following set of $N-1$ linear equations:\n$$ -u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i) = -h^2 e^{x_i} \\quad \\text{for } i=1, \\dots, N-1. $$\nThe equation for $i=N-1$ involves the known value $u_N$:\n$$ -u_{N-2} + 2u_{N-1} - u_N = -h^2 e^{x_{N-1}} \\implies -u_{N-2} + 2u_{N-1} = -h^2 e^{x_{N-1}} + u_N $$\n\nThe final equation, corresponding to the node $i=0$, is derived from the Robin boundary condition using two different methods.\n\n### Method A: Ghost-node Centered Closure\nThis method enforces the PDE at the boundary point $i=0$ by introducing a \"ghost\" point at $x_{-1} = -h$ with an unknown value $u_{-1}$.\nThe PDE discretization at $i=0$ is:\n$$ \\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f(x_0) = -e^0 = -1 $$\nThe Robin boundary condition is discretized using a second-order centered difference for the derivative $u'(0)$:\n$$ \\alpha u_0 + \\beta \\left(\\frac{u_1 - u_{-1}}{2h}\\right) = \\gamma $$\nWe eliminate the ghost value $u_{-1}$. From the discretized boundary condition, we solve for $u_{-1}$ (assuming $\\beta \\neq 0$, which is true for all test cases):\n$$ u_{-1} = u_1 - \\frac{2h}{\\beta}(\\gamma - \\alpha u_0) = u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta} $$\nSubstituting this expression for $u_{-1}$ into the discretized PDE at $i=0$:\n$$ -\\left(u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta}\\right) + 2u_0 - u_1 = -h^2 $$\nGrouping terms for the unknowns $u_0$ and $u_1$, we obtain the first equation of our linear system:\n$$ \\left(2 - \\frac{2h\\alpha}{\\beta}\\right)u_0 - 2u_1 = -h^2 - \\frac{2h\\gamma}{\\beta} $$\n\n### Method B: One-sided Derivative Closure\nThis method does not use a ghost point. Instead, the equation at $i=0$ is derived directly from the Robin boundary condition by employing a one-sided, second-order accurate approximation for the derivative $u'(0)$:\n$$ u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} $$\nSubstituting this into the Robin boundary condition $\\alpha u_0 + \\beta u'(0) = \\gamma$ gives:\n$$ \\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma $$\nMultiplying by $2h$ and grouping terms for the unknowns $u_0$, $u_1$, and $u_2$ yields the first equation of the linear system:\n$$ (2h\\alpha - 3\\beta)u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma $$\n\n### System Assembly and Solution\nFor each method, we assemble an $N \\times N$ matrix system $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$.\n\n**System for Method A:**\n- First row ($i=0$):\n  $A_{0,0} = 2 - 2h\\alpha/\\beta$, $A_{0,1} = -2$, and $b_0 = -h^2 - 2h\\gamma/\\beta$.\n- Interior rows ($i=1, \\dots, N-2$):\n  $A_{i,i-1}=-1$, $A_{i,i}=2$, $A_{i,i+1}=-1$, and $b_i = -h^2e^{x_i}$.\n- Last row ($i=N-1$):\n  $A_{N-1,N-2}=-1$, $A_{N-1,N-1}=2$, and $b_{N-1} = -h^2e^{x_{N-1}} + u_N$.\n\n**System for Method B:**\n- First row ($i=0$):\n  $A_{0,0} = 2h\\alpha - 3\\beta$, $A_{0,1} = 4\\beta$, $A_{0,2} = -\\beta$, and $b_0 = 2h\\gamma$.\n- Interior and last rows are identical to those in Method A.\n\nFor each test case $(\\alpha, \\beta)$, and with $N=512$, we build and solve the linear systems for Method A and Method B to find the numerical solutions, specifically the boundary values $u_0^{(A)}$ and $u_0^{(B)}$.\n\nThe boundary pointwise error for each method is calculated as $e_0(h) = |u_0 - u(0)| = |u_0 - 1|$. The corresponding error constant estimators are $C_A(h) = e_0^{(A)}(h)/h^2$ and $C_B(h) = e_0^{(B)}(h)/h^2$. The final step is to compute the ratio $R = C_B(h)/C_A(h)$ for each test case.",
            "answer": "```python\nimport numpy as np\n\ndef solve_poisson_1d(N, alpha, beta, method):\n    \"\"\"\n    Solves the 1D Poisson problem with a Robin/Dirichlet BC using two methods.\n\n    Args:\n        N (int): Number of intervals, such that h = 1/N.\n        alpha (float): Robin condition parameter.\n        beta (float): Robin condition parameter.\n        method (str): 'A' or 'B' for the boundary closure method.\n\n    Returns:\n        float: The numerical solution u_0 at the boundary x=0.\n    \"\"\"\n    h = 1.0 / N\n    gamma = alpha + beta\n    u_R = np.exp(1.0)\n    \n    # Grid points and source function values\n    x_nodes = np.linspace(0, 1, N + 1)\n    f_vals = -np.exp(x_nodes)\n    \n    # System A*u = b for unknowns u = [u_0, ..., u_{N-1}]\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Interior rows (i=1 to N-2) are common to both methods\n    for i in range(1, N - 1):\n        A[i, i-1] = -1.0\n        A[i, i]   = 2.0\n        A[i, i+1] = -1.0\n        b[i] = h**2 * f_vals[i]\n        \n    # Last row (i=N-1) is common to both methods\n    if N > 1:\n        A[N-1, N-2] = -1.0\n    A[N-1, N-1] = 2.0\n    b[N-1] = h**2 * f_vals[N-1] + u_R\n        \n    # First row (i=0) depends on the chosen method\n    if method == 'A':\n        # Method A: Ghost-node centered closure\n        # (2 - 2h*alpha/beta)u_0 - 2u_1 = -h^2 - 2h*gamma/beta\n        A[0, 0] = 2.0 - 2.0 * h * alpha / beta\n        if N > 1:\n            A[0, 1] = -2.0\n        # Use f_vals[0] for f(x_0) which equals -h^2*exp(0) = -h^2.\n        b[0] = h**2 * f_vals[0] - 2.0 * h * gamma / beta\n    elif method == 'B':\n        # Method B: One-sided derivative closure\n        # (2h*alpha - 3*beta)u_0 + 4*beta*u_1 - beta*u_2 = 2h*gamma\n        A[0, 0] = 2.0 * h * alpha - 3.0 * beta\n        if N > 1:\n            A[0, 1] = 4.0 * beta\n        if N > 2:\n            A[0, 2] = -beta\n        b[0] = 2.0 * h * gamma\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'A' or 'B'.\")\n        \n    # Solve the linear system\n    u_solution = np.linalg.solve(A, b)\n    \n    return u_solution[0]\n\ndef solve():\n    \"\"\"\n    Main function to run the computational test and print the results.\n    \"\"\"\n    N = 512\n    h = 1.0 / N\n    u_exact_0 = 1.0  # Exact solution u(0) = exp(0)\n    \n    test_cases = [\n        # (alpha, beta)\n        (1.0, 1.0),\n        (0.0, 1.0),\n        (2.0, 0.5)\n    ]\n    \n    R_values = []\n    \n    for alpha, beta in test_cases:\n        # Solve using Method A\n        u0_A = solve_poisson_1d(N, alpha, beta, method='A')\n        \n        # Solve using Method B\n        u0_B = solve_poisson_1d(N, alpha, beta, method='B')\n        \n        # Calculate boundary pointwise errors\n        e0_A = abs(u0_A - u_exact_0)\n        e0_B = abs(u0_B - u_exact_0)\n        \n        # Calculate error constant estimators\n        # C(h) = e0(h) / h^2\n        C_A = e0_A / h**2\n        C_B = e0_B / h**2\n        \n        # The problem formulation ensures C_A will be non-zero for these tests\n        if C_A == 0:\n            # Handle the unlikely case of zero error for Method A\n             R = np.inf if C_B != 0 else 1.0 # Or np.nan\n        else:\n             R = C_B / C_A\n\n        R_values.append(R)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join([f'{r:.6f}' for r in R_values])}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond standard implementations, this practice guides you through the process of actively improving the accuracy of a numerical scheme. You will start from Taylor series analysis to derive correction terms that cancel the leading-order truncation error for a boundary closure, effectively creating a higher-order method. This hands-on exercise in error cancellation  provides deep insight into the construction of high-fidelity numerical schemes and the powerful interplay between analysis and implementation.",
            "id": "3400494",
            "problem": "Consider the two-point boundary value problem for a scalar field $u(x)$ on the interval $[0,1]$ governed by the ordinary differential equation $-u''(x)=f(x)$, subject to a boundary condition at $x=0$ of either Neumann type $u'(0)=g$ or Robin type $a\\,u(0)+b\\,u'(0)=r$, and a Dirichlet condition at $x=1$ prescribed by the exact manufactured solution. Work on the uniform grid $x_j=jh$ for $j\\in\\{0,1,\\dots,N\\}$ with $h=1/N$ and introduce a single ghost point $x_{-1}=-h$ with value $u_{-1}$ to close the boundary at $x=0$.\n\nUse the following paired boundary closure at $x=0$: a discrete equation for the differential operator evaluated at $j=0$,\n$$\n\\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0),\n$$\ncombined with a ghost-point elimination relation derived from the boundary condition at $x=0$,\n- Neumann: \n$$\n\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)=g,\n$$\n- Robin:\n$$\na\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r.\n$$\n\nTask 1 (derivation). Starting only from Taylor expansions about $x=0$ together with the differential equation $-u''(x)=f(x)$ and its derivatives, determine values of the coefficients $\\alpha$ and $\\beta$ that cancel the leading-order boundary truncation error in the paired closure at $x=0$. The notion of “cancel” is: when the exact $u(x)$ is substituted into the left-hand sides and the exact data into the right-hand sides, the residual of the paired system at $j=0$ scales as $\\mathcal{O}(h^3)$ or better for general smooth $u(x)$, and achieves $\\mathcal{O}(h^4)$ for analytic $u(x)$ whose $f''(0)\\neq 0$. Your derivation must start from Taylor polynomials for $u(\\pm h)$, eliminate $u^{(k)}(0)$ in favor of $f^{(\\ell)}(0)$ using $-u''=f$, and identify the conditions on $\\alpha$ and $\\beta$ required to make the $\\mathcal{O}(h)$ and $\\mathcal{O}(h^2)$ residual terms vanish simultaneously.\n\nTask 2 (verification by manufactured solutions). Implement two concrete manufactured solutions and their induced data:\n- Sine: $u(x)=\\sin(\\pi x)$, so that $f(x)=\\pi^2\\sin(\\pi x)$, $u'(0)=\\pi$, $f'(0)=\\pi^3$, and $f''(0)=-\\pi^4\\sin(0)=0$.\n- Exponential: $u(x)=e^{\\lambda x}$ with a given fixed parameter $\\lambda$, so that $f(x)=-\\lambda^2 e^{\\lambda x}$, $u'(0)=\\lambda$, $f'(0)=-\\lambda^3$, and $f''(0)=-\\lambda^4$.\n\nFor the Robin boundary condition, use fixed real constants $a$ and $b$ with $b\\neq 0$, and define $r=a\\,u(0)+b\\,u'(0)$ from the manufactured solution. For the Neumann boundary condition, set $g=u'(0)$ from the manufactured solution. In both cases, use the exact $u(1)$ at $x=1$, which is $u(1)=\\sin(\\pi)$ for the sine case and $u(1)=e^{\\lambda}$ for the exponential case.\n\nTask 3 (discrete residual order measurement). For each manufactured solution and each boundary type (Neumann and Robin), form the paired boundary residual at $j=0$ by substituting the exact nodal values $u_0=u(0)$ and $u_1=u(h)$ and the exact data into the discrete formulas. Define:\n- Baseline scheme: $\\alpha=0$ and $\\beta=0$.\n- Corrected scheme: use your derived $\\alpha$ and $\\beta$ from Task 1.\n\nFor each scheme, form the ghost value $u_{-1}$ algebraically from the corresponding boundary relation and then evaluate the left-hand side of the discrete differential equation at $j=0$ to obtain the discrete residual $R_0(h)$, i.e.,\n$$\nR_0(h)=\\frac{-u_1+2u_0-u_{-1}}{h^2}-\\left(f(0)+\\beta\\,h^2 f''(0)\\right),\n$$\nwith $u_1=u(h)$ and $u_0=u(0)$. Measure the observed order $p$ of the boundary residual by computing\n$$\np=\\log_2\\left(\\frac{|R_0(h)|}{|R_0(h/2)|}\\right)\n$$\nfor a pair of mesh sizes related by halving $h$.\n\nTest suite specification. Use the following parameter sets:\n- Manufactured solutions: the sine case and the exponential case with $\\lambda=2$.\n- Boundary types: Neumann and Robin with coefficients $a=2$ and $b=1$.\n- Mesh sizes: $N_1=64$ and $N_2=128$ (so $h_1=1/N_1$ and $h_2=1/N_2$).\n\nYour program must compute, for each of the four combinations (Neumann-sine, Neumann-exponential, Robin-sine, Robin-exponential), the observed order for the baseline scheme and for the corrected scheme. The final output should be a single line containing a comma-separated Python list of eight floating-point numbers in the following order:\n$[\\text{Neu-sin baseline},\\text{Neu-sin corrected},\\text{Neu-exp baseline},\\text{Neu-exp corrected},\\text{Rob-sin baseline},\\text{Rob-sin corrected},\\text{Rob-exp baseline},\\text{Rob-exp corrected}]$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]$). No additional text should be printed. Angles are not involved, and no physical units are required. All numeric outputs must be ordinary decimal floating-point numbers; it is acceptable to round to three decimal places. The code must be fully self-contained and require no user input.",
            "solution": "The problem is assessed to be valid. It is a well-posed problem in the field of numerical analysis, dealing with standard, verifiable techniques for analyzing the truncation error of finite difference schemes. All provided information is self-contained, scientifically grounded, and unambiguous.\n\n### Task 1: Derivation of Coefficients $\\alpha$ and $\\beta$\n\nThe objective is to determine the coefficients $\\alpha$ and $\\beta$ in the paired boundary closure scheme such that the leading-order terms of the local truncation error at the boundary $x=0$ are eliminated. The process involves substituting the exact solution $u(x)$ into the discrete equations, performing a Taylor series analysis, and choosing $\\alpha$ and $\\beta$ to cancel the lowest-order error terms.\n\nThe paired boundary closure at $x=0$ consists of two equations:\n1.  A modified discrete form of the differential equation $-u''(x)=f(x)$ at $x_0=0$:\n    $$ \\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0) $$\n2.  A discrete representation of the boundary condition, which is used to eliminate the ghost point value $u_{-1}$. We analyze the Neumann and Robin cases.\n\nLet $u(x)$ be the exact solution, which is assumed to be sufficiently smooth. We use the notation $u_j = u(x_j)$, $u_0 = u(0)$, $u_1 = u(h)$, $u_{-1}$ is the ghost point value, and $u^{(k)}_0 = \\frac{d^k u}{dx^k}(0)$. From the differential equation, we have the relations $u^{(k)}_0 = -f^{(k-2)}_0$ for $k \\ge 2$, where $f^{(m)}_0 = \\frac{d^m f}{dx^m}(0)$.\n\nFirst, consider the Robin boundary condition, $a\\,u(0)+b\\,u'(0)=r$, for which the discrete form is:\n$$ a\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r $$\nWe substitute the exact values into this relation: $u_0 = u(0)$, $u_1 = u(h)$, and $r = a\\,u(0)+b\\,u'(0)$.\n$$ a\\,u(0)+b\\left(\\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=a\\,u(0)+b\\,u'(0) $$\nAssuming $b \\neq 0$, we can solve for the implied ghost point value $u_{-1}$:\n$$ \\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0) = u'(0) $$\n$$ u(h)-u_{-1} = 2h\\,u'(0) - 2h\\,\\alpha\\,h^2 f'(0) $$\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\nThe Neumann case $u'(0)=g$ with its discrete form $\\frac{u_1-u_{-1}}{2h}+\\alpha h^2 f'(0)=g$ yields the same expression for $u_{-1}$ upon setting $g=u'(0)$. Thus, the derivation is identical for both boundary condition types.\n\nThe core task is to analyze the residual of the discrete differential equation at $j=0$ after this expression for $u_{-1}$ is substituted. The residual, $R_0(h)$, is defined by substituting the exact solution into the numerical scheme:\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\nSubstituting the expression for $u_{-1}$:\n$$ R_0(h) = \\frac{-u(h)+2u(0)-\\left(u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0)\\right)}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n$$ R_0(h) = \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} - 2\\alpha h f'(0) - f(0) - \\beta h^2 f''(0) $$\nTo analyze this expression, we use the Taylor series expansion for $u(h)$ around $x=0$:\n$$ u(h) = u(0) + h\\,u'(0) + \\frac{h^2}{2}u''(0) + \\frac{h^3}{6}u'''(0) + \\frac{h^4}{24}u^{(4)}(0) + \\frac{h^5}{120}u^{(5)}(0) + \\mathcal{O}(h^6) $$\nSubstituting this into the term containing $u(h)$:\n$$ 2u(0) - 2u(h) + 2h\\,u'(0) = 2u_0 - 2\\left(u_0 + h u'_0 + \\frac{h^2}{2}u''_0 + \\frac{h^3}{6}u'''_0 + \\dots\\right) + 2h u'_0 $$\n$$ = -h^2 u''_0 - \\frac{h^3}{3}u'''_0 - \\frac{h^4}{12}u^{(4)}_0 - \\frac{h^5}{60}u^{(5)}_0 - \\mathcal{O}(h^6) $$\nDividing by $h^2$, the first part of the residual becomes:\n$$ \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} = -u''_0 - \\frac{h}{3}u'''_0 - \\frac{h^2}{12}u^{(4)}_0 - \\frac{h^3}{60}u^{(5)}_0 - \\mathcal{O}(h^4) $$\nNow, we use the relations from the ODE, $u''_0 = -f_0$, $u'''_0 = -f'_0$, $u^{(4)}_0 = -f''_0$, and so on:\n$$ = -(-f_0) - \\frac{h}{3}(-f'_0) - \\frac{h^2}{12}(-f''_0) - \\frac{h^3}{60}(-f'''_0) - \\mathcal{O}(h^4) $$\n$$ = f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\nWe substitute this back into the full expression for the residual $R_0(h)$:\n$$ R_0(h) = \\left(f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0\\right) - 2\\alpha h f'_0 - f_0 - \\beta h^2 f''_0 + \\mathcal{O}(h^4) $$\nCollecting terms by powers of $h$:\n$$ R_0(h) = \\left(\\frac{1}{3} - 2\\alpha\\right)h f'_0 + \\left(\\frac{1}{12} - \\beta\\right)h^2 f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\nTo cancel the leading-order error terms, which are $\\mathcal{O}(h)$ and $\\mathcal{O}(h^2)$, we must set their coefficients to zero:\n\\begin{enumerate}\n    \\item Coefficient of $h$: $\\frac{1}{3} - 2\\alpha = 0 \\implies \\alpha = \\frac{1}{6}$\n    \\item Coefficient of $h^2$: $\\frac{1}{12} - \\beta = 0 \\implies \\beta = \\frac{1}{12}$\n\\end{enumerate}\nWith these values, the residual becomes:\n$$ R_0(h) = \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\nThe order of the residual for the corrected scheme is therefore $\\mathcal{O}(h^3)$, provided $f'''(0) \\neq 0$. This meets the requirement of being $\\mathcal{O}(h^3)$ or better. The problem's suggestion that the method achieves $\\mathcal{O}(h^4)$ for analytic $u(x)$ with $f''(0) \\neq 0$ is not supported by this direct derivation; the leading error term is $\\mathcal{O}(h^3)$ as shown.\n\n### Tasks 2 & 3: Verification by Manufactured Solutions and Residual Measurement\n\nWe now verify these findings numerically. We will compute the residual $R_0(h)$ and its convergence order for both a baseline scheme ($\\alpha=0, \\beta=0$) and the corrected scheme ($\\alpha=1/6, \\beta=1/12$).\n\nThe manufactured solutions are:\n\\begin{itemize}\n    \\item **Sine case**: $u(x)=\\sin(\\pi x)$. This gives $f(x)=\\pi^2\\sin(\\pi x)$. At $x=0$, we have $u(0)=0$, $u'(0)=\\pi$, $f(0)=0$, $f'(0)=\\pi^3$, and $f''(0)=0$.\n    \\item **Exponential case**: $u(x)=e^{\\lambda x}$ with $\\lambda=2$. This gives $f(x)=-\\lambda^2 e^{\\lambda x}$. At $x=0$, we have $u(0)=1$, $u'(0)=\\lambda=2$, $f(0)=-\\lambda^2=-4$, $f'(0)=-\\lambda^3=-8$, and $f''(0)=-\\lambda^4=-16$.\n\\end{itemize}\n\nFor each case, we compute the residual $R_0(h)$ for two mesh sizes, $h_1=1/N_1$ and $h_2=1/N_2$ where $N_1=64$ and $N_2=128$. The formula for the residual is:\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\nwhere $u_{-1}$ is found from the boundary condition relation:\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\nThe observed order of convergence, $p$, is calculated as:\n$$ p = \\log_2\\left(\\frac{|R_0(h_1)|}{|R_0(h_2)|}\\right) $$\nThe following Python code implements this verification procedure for the four specified test configurations (Neumann/Robin with sine/exponential). As derived, the calculation of the residual $R_0(h)$ is identical for the Neumann and Robin boundary conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving coefficients and performing numerical verification.\n    The derivation shows alpha=1/6 and beta=1/12. This is implemented and tested.\n    \"\"\"\n    \n    # Task 1 derived coefficients for the corrected scheme\n    ALPHA_CORRECTED = 1.0 / 6.0\n    BETA_CORRECTED = 1.0 / 12.0\n\n    # Baseline scheme coefficients\n    ALPHA_BASELINE = 0.0\n    BETA_BASELINE = 0.0\n\n    # Test parameters\n    LAMBDA = 2.0\n    A_ROBIN = 2.0\n    B_ROBIN = 1.0\n    N1 = 64\n    N2 = 128\n    \n    # --- Manufactured Solutions ---\n\n    # Sine case\n    u_sin = lambda x: np.sin(np.pi * x)\n    u_prime_sin = lambda x: np.pi * np.cos(np.pi * x)\n    f_sin = lambda x: np.pi**2 * np.sin(np.pi * x)\n    f_prime_sin = lambda x: np.pi**3 * np.cos(np.pi * x)\n    f_double_prime_sin = lambda x: -np.pi**4 * np.sin(np.pi * x)\n\n    # Exponential case\n    u_exp = lambda x: np.exp(LAMBDA * x)\n    u_prime_exp = lambda x: LAMBDA * np.exp(LAMBDA * x)\n    f_exp = lambda x: -LAMBDA**2 * np.exp(LAMBDA * x)\n    f_prime_exp = lambda x: -LAMBDA**3 * np.exp(LAMBDA * x)\n    f_double_prime_exp = lambda x: -LAMBDA**4 * np.exp(LAMBDA * x)\n\n    def calculate_residual(h, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta):\n        \"\"\"\n        Calculates the residual R_0(h) for a given manufactured solution and scheme.\n        \"\"\"\n        # Get exact values at x=0 and x=h\n        u0 = u_func(0)\n        u1 = u_func(h)\n        u_prime0 = u_prime_func(0)\n        f0 = f_func(0)\n        f_prime0 = f_prime_func(0)\n        f_double_prime0 = f_double_prime_func(0)\n        \n        # Calculate ghost point value u_{-1}\n        # This expression is the same for both Neumann and Robin cases as per the derivation.\n        u_minus_1 = u1 - 2 * h * u_prime0 + 2 * alpha * h**3 * f_prime0\n        \n        # Calculate the residual R_0(h)\n        lhs = (-u1 + 2 * u0 - u_minus_1) / h**2\n        rhs = f0 + beta * h**2 * f_double_prime0\n        residual = lhs - rhs\n        \n        return residual\n\n    def calculate_order(u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta, n1, n2):\n        \"\"\"\n        Calculates the observed order of convergence p.\n        \"\"\"\n        h1 = 1.0 / n1\n        h2 = 1.0 / n2\n        \n        r1 = calculate_residual(h1, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        r2 = calculate_residual(h2, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        \n        # Handle cases where residual is zero to avoid division by zero or log(0)\n        if abs(r2)  1e-15:\n            # If r2 is zero, the error is machine precision. If r1 was also zero, order is irrelevant.\n            # If r1 was not, convergence is faster than can be measured.\n            return np.inf\n        if abs(r1)  1e-15:\n            # This case should not be hit if h is halved, but as a safe guard:\n            return 0.0\n\n        order = np.log2(abs(r1) / abs(r2))\n        return order\n\n\n    test_cases = [\n        # (name, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func)\n        (\"Neu-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Neu-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n        (\"Rob-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Rob-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n    ]\n\n    results = []\n    for name, u, up, f, fp, fpp in test_cases:\n        # Baseline scheme\n        order_baseline = calculate_order(u, up, f, fp, fpp, ALPHA_BASELINE, BETA_BASELINE, N1, N2)\n        results.append(round(order_baseline, 3))\n        \n        # Corrected scheme\n        order_corrected = calculate_order(u, up, f, fp, fpp, ALPHA_CORRECTED, BETA_CORRECTED, N1, N2)\n        results.append(round(order_corrected, 3))\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world problems rarely conform to simple Cartesian domains, demanding methods that can handle complex geometries. This exercise extends the ghost point technique from one-dimensional lines to a curved boundary embedded within a three-dimensional grid, a common scenario in scientific computing. You will use the signed distance function to geometrically construct ghost points and verify the accuracy of enforcing a Neumann condition , gaining practical experience with the challenges posed by boundary curvature and grid anisotropy.",
            "id": "3400490",
            "problem": "Consider the numerical enforcement of a Neumann boundary condition for a scalar field on a three-dimensional Cartesian grid using ghost points derived from the signed distance function. Let the computational box be $[-1,1]^3$, and let the physical domain $\\Omega$ be the interior of a sphere of radius $R$ centered at the origin, i.e., the boundary $\\partial \\Omega$ is given by the level set $\\{\\boldsymbol{x} \\in \\mathbb{R}^3 : \\phi(\\boldsymbol{x}) = 0\\}$ where $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$ is the signed distance function, negative inside $\\Omega$. Let the unknown scalar field $u(\\boldsymbol{x})$ be smooth. The Neumann boundary condition seeks to enforce $\\partial u/\\partial n = g$ on $\\partial \\Omega$, where $\\partial u/\\partial n$ denotes the normal derivative of $u$ and $g$ is a prescribed smooth function on $\\partial \\Omega$.\n\nYou will investigate the ghost point technique for the Neumann boundary condition on a smooth curved boundary using the signed distance function. Your objective is to quantify the accuracy of the ghost point construction and verify its observed order of accuracy under changes in curvature and grid anisotropy. The analysis is purely mathematical and algorithmic, using a manufactured solution. No physical units are involved.\n\nFundamental definitions to be used:\n- The Partial Differential Equation (PDE) boundary condition is $\\partial u/\\partial n = g$ on $\\partial \\Omega$.\n- The signed distance function is $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$; its gradient $\\nabla \\phi(\\boldsymbol{x})$ is the outward unit normal $\\boldsymbol{n}$ at $\\partial \\Omega$ and equals $\\boldsymbol{x}/\\|\\boldsymbol{x}\\|$ for $\\boldsymbol{x} \\neq \\boldsymbol{0}$.\n- A ghost point for an interior grid node $\\boldsymbol{x}_i$ near the boundary is constructed by reflection across $\\partial \\Omega$ along the normal direction determined by the signed distance function.\n\nManufactured data:\n- Let the scalar field be $u(\\boldsymbol{x}) = \\sin(\\pi x) + \\cos(2 \\pi y) + \\sinh(z)$, where $\\boldsymbol{x} = (x,y,z)$.\n- Then $\\nabla u(\\boldsymbol{x}) = \\left(\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z)\\right)$.\n- The Neumann boundary data is $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$ for $\\boldsymbol{x}_B \\in \\partial \\Omega$.\n\nGhost point construction to implement:\n- For a grid node $\\boldsymbol{x}_i$ with $\\phi(\\boldsymbol{x}_i)  0$ and $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$, define $d = -\\phi(\\boldsymbol{x}_i)  0$ and $\\boldsymbol{n}_i = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$.\n- The closest boundary point along the normal is $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i$.\n- The reflected ghost location is $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2 d \\boldsymbol{n}_i$.\n- Enforce the Neumann boundary condition by defining the ghost value via the symmetric Taylor expansion along the normal: $u_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2 d \\, g(\\boldsymbol{x}_B)$.\n- The exact ghost value for error assessment is $u_G^{\\text{exact}} = u(\\boldsymbol{x}_G)$.\n\nError measure and observed order of accuracy:\n- Over the set of interior nodes satisfying $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$ (i.e., a one-cell-thick interior band adjacent to the boundary), define the root-mean-square error\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2},\n$$\nwhere $N$ is the number of nodes in the set.\n- Perform two grid resolutions for each test case, with the fine grid having half the maximum grid spacing of the coarse grid. The observed order of accuracy is\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}.\n$$\n\nGrid generation:\n- Use Cartesian grids with anisotropic spacings allowed. For a given number of nodes $N_x$, $N_y$, $N_z$ in the $x$, $y$, $z$ directions, respectively, define the grids by uniform linspaces on $[-1,1]$, i.e., $x_j = -1 + j \\, h_x$, $h_x = 2/(N_x-1)$, and similarly for $y$ and $z$.\n- Define $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$.\n\nTest suite:\n- Case $1$: $R = 0.70$, coarse grid $(N_x,N_y,N_z) = (25,25,25)$, fine grid $(N_x,N_y,N_z) = (49,49,49)$.\n- Case $2$: $R = 0.35$, coarse grid $(N_x,N_y,N_z) = (25,25,25)$, fine grid $(N_x,N_y,N_z) = (49,49,49)$.\n- Case $3$: $R = 0.70$, coarse grid $(N_x,N_y,N_z) = (25,49,97)$, fine grid $(N_x,N_y,N_z) = (49,97,193)$.\n- Case $4$: $R = 0.35$, coarse grid $(N_x,N_y,N_z) = (25,49,97)$, fine grid $(N_x,N_y,N_z) = (49,97,193)$.\n\nYour program should compute the observed order $p$ for each of the four cases above and produce a single line of output containing the four $p$ values as a comma-separated list enclosed in square brackets, for example, $[p_1,p_2,p_3,p_4]$. All quantities are dimensionless. Angles (if any appear in trigonometric functions) are in radians. The final answers are real numbers.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically sound exercise in numerical analysis. It outlines a clear procedure for verifying the order of accuracy of a specific ghost point method for enforcing Neumann boundary conditions on a curved boundary embedded in a Cartesian grid. All definitions, parameters, and manufactured data are self-contained and consistent. The problem is free of logical flaws, ambiguities, or contradictions. The potential singularity at the origin, where the normal vector is undefined, is naturally avoided by the problem's parameter choices, as the origin does not fall within the one-cell-thick boundary layer where computations are performed. We may therefore proceed with the solution.\n\nThe objective is to compute the observed order of accuracy, $p$, for a ghost point construction used to enforce the Neumann boundary condition $\\partial u/\\partial n = g$ on a spherical domain. This involves a numerical experiment using a manufactured solution. The process is executed for four distinct test cases, each defined by a sphere radius $R$ and a set of coarse and fine grid resolutions.\n\nThe core of the methodology is to calculate a root-mean-square (RMS) error, $E$, for both a coarse and a fine grid for each test case. The observed order of accuracy $p$ is then determined using the formula:\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}\n$$\nThis formula quantifies how the error decreases as the grid spacing is halved. A method with error $E = O(h^k)$ is expected to yield an observed order $p \\approx k$.\n\nThe error calculation proceeds as follows:\nFirst, a uniform Cartesian grid is generated over the computational box $[-1, 1]^3$ with a specified number of nodes $(N_x, N_y, N_z)$. The grid spacings are $h_x = 2/(N_x-1)$, $h_y = 2/(N_y-1)$, and $h_z = 2/(N_z-1)$, with $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$.\n\nSecond, we identify the set of \"near-boundary\" interior grid nodes, $\\boldsymbol{x}_i$. These are the nodes for which the signed distance function $\\phi(\\boldsymbol{x}_i) = \\|\\boldsymbol{x}_i\\| - R$ is negative (indicating the node is inside the sphere) and the normal distance to the boundary, $d = -\\phi(\\boldsymbol{x}_i)$, is no greater than $h_{\\max}$. This defines a one-cell-thick layer of nodes adjacent to the interior side of the boundary $\\partial\\Omega$. Let this set contain $N$ nodes.\n\nThird, for each node $\\boldsymbol{x}_i$ in this set, we construct its corresponding ghost point and calculate two values for the scalar field $u$ at this ghost location: a numerical approximation, $u_G^{\\text{num}}$, and an exact value, $u_G^{\\text{exact}}$.\n\nThe construction is based on reflection across the boundary along the normal direction. For a node $\\boldsymbol{x}_i$:\n1.  The normal distance to the boundary is $d = -\\phi(\\boldsymbol{x}_i) = R - \\|\\boldsymbol{x}_i\\|$.\n2.  The outward normal direction is approximated at $\\boldsymbol{x}_i$ as $\\boldsymbol{n}_i = \\nabla\\phi(\\boldsymbol{x}_i) = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$.\n3.  The closest point on the boundary along this normal is $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i = \\boldsymbol{x}_i (R / \\|\\boldsymbol{x}_i\\|)$.\n4.  The reflected ghost point location is $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2d \\boldsymbol{n}_i$.\n\nThe exact value at the ghost point, $u_G^{\\text{exact}}$, is obtained by directly evaluating the manufactured solution at $\\boldsymbol{x}_G$:\n$$\nu_G^{\\text{exact}} = u(\\boldsymbol{x}_G) = \\sin(\\pi x_G) + \\cos(2 \\pi y_G) + \\sinh(z_G)\n$$\n\nThe numerical value, $u_G^{\\text{num}}$, is defined by a first-order Taylor expansion centered at the interior point $\\boldsymbol{x}_i$, which enforces the Neumann condition at the boundary point $\\boldsymbol{x}_B$:\n$$\nu_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2d \\, g(\\boldsymbol{x}_B)\n$$\nHere, $u(\\boldsymbol{x}_i)$ is the value of the manufactured solution at the interior node. The boundary data $g(\\boldsymbol{x}_B)$ is determined from the manufactured solution as $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$, where $\\boldsymbol{n}(\\boldsymbol{x}_B) = \\boldsymbol{x}_B/R$ is the exact unit normal at the boundary point. The gradient vector is given by $\\nabla u(\\boldsymbol{x}) = (\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z))$.\n\nA Taylor series analysis of the local error, $u_G^{\\text{num}} - u_G^{\\text{exact}}$, reveals that the error is dominated by a term proportional to $d^3$:\n$$\nu_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) = -\\frac{d^3}{3} \\frac{\\partial^3 u}{\\partial n^3}\\Big|_{\\boldsymbol{x}_B} + O(d^4)\n$$\nSince $d$ is on the order of the grid spacing $h$, the local error in the ghost value is $O(h^3)$.\n\nFinally, the RMS error $E$ is computed by averaging the squared differences over the $N$ near-boundary nodes:\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2}\n$$\nGiven the local error analysis, the RMS error $E$ is expected to be $O(h^3)$, and thus the observed order of accuracy $p$ is expected to be close to $3$.\n\nThe implementation will perform these calculations for each of the four specified test cases using vectorized NumPy operations for efficiency. For each case, $E_{\\text{coarse}}$ and $E_{\\text{fine}}$ are computed, and the resulting value of $p$ is reported.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_manufactured(points):\n    \"\"\"\n    Computes the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N,) with the value of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    return np.sin(np.pi * x) + np.cos(2 * np.pi * y) + np.sinh(z)\n\ndef grad_u_manufactured(points):\n    \"\"\"\n    Computes the gradient of the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N, 3) with the gradient vector of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    du_dx = np.pi * np.cos(np.pi * x)\n    du_dy = -2 * np.pi * np.sin(2 * np.pi * y)\n    du_dz = np.cosh(z)\n    return np.stack([du_dx, du_dy, du_dz], axis=1)\n\ndef compute_error(R, N_x, N_y, N_z):\n    \"\"\"\n    Computes the RMS error of the ghost point value approximation.\n\n    Args:\n        R (float): Radius of the spherical domain.\n        N_x (int): Number of grid points in the x-direction.\n        N_y (int): Number of grid points in the y-direction.\n        N_z (int): Number of grid points in the z-direction.\n\n    Returns:\n        float: The root-mean-square error E.\n    \"\"\"\n    # 1. Grid Generation\n    h_x = 2.0 / (N_x - 1) if N_x > 1 else 0.0\n    h_y = 2.0 / (N_y - 1) if N_y > 1 else 0.0\n    h_z = 2.0 / (N_z - 1) if N_z > 1 else 0.0\n    h_max = max(h_x, h_y, h_z)\n\n    x_coords = np.linspace(-1.0, 1.0, N_x)\n    y_coords = np.linspace(-1.0, 1.0, N_y)\n    z_coords = np.linspace(-1.0, 1.0, N_z)\n    \n    xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n    all_points = np.stack([xx.ravel(), yy.ravel(), zz.ravel()], axis=1)\n\n    # 2. Identify Nodes of Interest\n    phi = np.linalg.norm(all_points, axis=1) - R\n    interior_band_indices = np.where((phi  0)  (-phi = h_max))[0]\n    \n    if len(interior_band_indices) == 0:\n        return 0.0\n\n    x_i_set = all_points[interior_band_indices]\n\n    # 3. Ghost Point Construction (Vectorized)\n    d = -phi[interior_band_indices]\n    norm_x_i = np.linalg.norm(x_i_set, axis=1, keepdims=True)\n\n    # Filter out origin if it is in the set to avoid division by zero.\n    # The problem setup ensures this is not the case for the given test cases.\n    non_zero_mask = (norm_x_i > 1e-15).ravel()\n    if not np.all(non_zero_mask):\n        x_i_set = x_i_set[non_zero_mask]\n        d = d[non_zero_mask]\n        norm_x_i = norm_x_i[non_zero_mask]\n\n    n_i = x_i_set / norm_x_i\n    x_B = x_i_set * (R / norm_x_i)\n    x_G = x_i_set + 2 * d[:, np.newaxis] * n_i\n    \n    # 4. Calculate Numerical and Exact Ghost Values\n    # Numerical: u_G_num = u(x_i) + 2*d*g(x_B)\n    u_at_xi = u_manufactured(x_i_set)\n    grad_u_at_xB = grad_u_manufactured(x_B)\n    n_at_xB = x_B / R\n    g_at_xB = np.sum(grad_u_at_xB * n_at_xB, axis=1)\n    u_G_num = u_at_xi + 2 * d * g_at_xB\n    \n    # Exact: u_G_exact = u(x_G)\n    u_G_exact = u_manufactured(x_G)\n\n    # 5. Compute RMS Error\n    squared_errors = (u_G_num - u_G_exact)**2\n    rms_error = np.sqrt(np.mean(squared_errors))\n    \n    return rms_error\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute observed orders of accuracy.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, (Nx_coarse, Ny_coarse, Nz_coarse), (Nx_fine, Ny_fine, Nz_fine))\n        (0.70, (25, 25, 25), (49, 49, 49)),\n        (0.35, (25, 25, 25), (49, 49, 49)),\n        (0.70, (25, 49, 97), (49, 97, 193)),\n        (0.35, (25, 49, 97), (49, 97, 193)),\n    ]\n\n    results = []\n    for R, coarse_grid, fine_grid in test_cases:\n        E_coarse = compute_error(R, *coarse_grid)\n        E_fine = compute_error(R, *fine_grid)\n        \n        if E_fine > 0 and E_coarse > 0:\n            order = np.log(E_coarse / E_fine) / np.log(2.0)\n        else:\n            # This case shouldn't occur for this problem but is good practice\n            order = np.nan\n        \n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}