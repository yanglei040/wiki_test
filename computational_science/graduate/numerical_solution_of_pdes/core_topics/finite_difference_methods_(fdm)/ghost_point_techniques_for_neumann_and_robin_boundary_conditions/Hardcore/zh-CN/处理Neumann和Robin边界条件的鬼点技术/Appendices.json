{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你完成一项基础的实践任务：实现并比较两种用于处理 Robin 边界条件、但代数形式不同、且理论上均为二阶精度的方法。通过此实践 ，你将认识到，理论收敛阶数并非衡量算法性能的唯一标准。通过数值方法估算误差常数，你将更深刻地理解不同离散格式在实际应用中的性能差异。",
            "id": "3400414",
            "problem": "考虑闭区间 $[0,1]$ 上的一维稳态泊松问题，\n$$-u''(x) = f(x), \\quad x \\in (0,1),$$\n左端点为罗宾 (Robin) 边值条件，右端点为狄利克雷 (Dirichlet) 边值条件：\n$$\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\\quad u(1) = u_R.$$\n假设采用均匀网格，步长为 $h = 1/N$，网格点为 $x_i = i h$，$i=0,1,\\dots,N$。设精确解为 $u(x) = e^x$，因此 $f(x) = -e^x$，并选择与精确解一致的边界数据，即 $u_R = e^1$ 和 $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha + \\beta$。\n\n你必须在 $x=0$（罗宾边界）处实现两种代数上不同、形式上二阶精确的边界封闭格式，同时对内部 $-u''$ 的离散化使用标准的二阶中心差分。两种方法都应为节点值 $\\{u_i\\}$ 生成一个线性系统，通过求解该系统得到未知数。\n\n- 方法 A（使用虚拟节点和在 $i=0$ 处边界固定的中心差分导数封闭格式）：\n  - 在包括 $i=0$ 在内的所有网格点上，对 $-u''$ 使用二阶中心有限差分：\n    $$-u''(x_i)\\approx \\frac{-u_{i-1}+2u_i-u_{i+1}}{h^2}.$$\n  - 在 $x_{-1}=-h$ 处引入一个虚拟值 $u_{-1}$。通过使用涉及该虚拟节点的中心差分来近似 $u'(0)$，从而施加罗宾边界条件：\n    $$u'(0)\\approx \\frac{u_1 - u_{-1}}{2h}.$$\n    使用罗宾边界条件消去虚拟值 $u_{-1}$，并将其代入 $i=0$ 处的离散方程。根据给定的狄利克雷数据处理 $i=N$。\n\n- 方法 B（不使用虚拟节点的单侧三点二阶导数封闭格式）：\n  - 对于内部节点 $i=1,2,\\dots,N-1$，与方法 A 一样，对 $-u''$ 使用二阶中心差分。\n  - 在 $i=0$ 处，使用导数的单侧三点二阶近似来施加罗宾边界条件：\n    $$u'(0)\\approx \\frac{-3u_0 + 4u_1 - u_2}{2h}.$$\n\n对于这两种方法，建立并求解节点 $i=0,1,\\dots,N-1$ 处未知数的线性系统，其中 $u_N=u(1)=e^1$ 为已知值。对于每种方法和给定的 $N$，计算边界点误差 $e_0(h) = |u_0 - u(0)| = |u_0 - e^0|$，然后构建边界误差常数估计量\n$$C(h) = \\frac{e_0(h)}{h^2}.$$\n\n你的任务是设计一个计算测试，以揭示哪种边界封闭格式能产生更小的边界误差常数。具体来说，对于下面的每个测试用例，估计比率\n$$R = \\frac{C_B(h_\\text{fine})}{C_A(h_\\text{fine})},$$\n其中 $C_A$ 和 $C_B$ 分别表示方法 A 和方法 B 的边界误差常数估计量，在足够精细的网格间距 $h_\\text{fine}$ 下计算（我们知道对于二阶方法，当 $h$ 很小时，$C(h)$ 是渐近常数）。比率 $R<1$ 表明在该测试中，方法 B 的边界误差常数小于方法 A，而 $R>1$ 则表明情况相反。\n\n为以下测试套件实现上述过程，每个测试都指定了 $x=0$ 处罗宾边界的 $(\\alpha,\\beta)$：\n- 测试 1：$(\\alpha,\\beta)=(1,1)$。\n- 测试 2：$(\\alpha,\\beta)=(0,1)$。\n- 测试 3：$(\\alpha,\\beta)=(2,0.5)$。\n\n使用 $N=512$ 的精细网格，因此 $h=1/512$。对每个测试，计算如上定义的 $R$。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，即按给定顺序排列的三个测试的列表 $[R_1,R_2,R_3]$。每个 $R_k$ 必须以浮点数形式打印，小数点后恰好有六位数字。",
            "solution": "所述问题在科学上是合理的、自洽的且适定的。它提出了一个标准的数值分析任务，涉及比较两种不同的二阶有限差分方法来处理罗宾边界条件。因此，该问题被认为是有效的，并将提供一个解。\n\n所考虑的问题是一维稳态泊松方程：\n$$ -u''(x) = f(x), \\quad x \\in (0,1) $$\n左端点为罗宾边界条件，右端点为狄利克雷边界条件：\n$$ \\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma $$\n$$ u(1) = u_R $$\n我们已知精确解为 $u(x) = e^x$，这意味着源项必须是 $f(x) = -u''(x) = -e^x$。边界数据被选择为与此解一致：$u_R = u(1) = e^1$，以及 $\\gamma = \\alpha\\,u(0) + \\beta\\,u'(0) = \\alpha\\,(1) + \\beta\\,(1) = \\alpha + \\beta$。\n\n我们使用一个具有 $N+1$ 个点 $x_i = ih$（$i=0, 1, \\dots, N$）的均匀网格，其中网格间距为 $h=1/N$。令 $u_i$ 为精确解 $u(x_i)$ 的数值近似。未知数是节点值 $\\{u_0, u_1, \\dots, u_{N-1}\\}$。值 $u_N$ 由狄利克雷条件已知：$u_N = u_R = e^1$。这就得到了一个包含 $N$ 个未知数的 $N$ 个线性方程组。\n\n对于内部网格点 $i=1, 2, \\dots, N-1$，我们使用标准的二阶中心有限差分近似来处理二阶导数：\n$$ -u''(x_i) \\approx \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} $$\n这导出了以下 $N-1$ 个线性方程组：\n$$ -u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i) = -h^2 e^{x_i} \\quad \\text{for } i=1, \\dots, N-1. $$\n$i=N-1$ 的方程涉及已知值 $u_N$：\n$$ -u_{N-2} + 2u_{N-1} - u_N = -h^2 e^{x_{N-1}} \\implies -u_{N-2} + 2u_{N-1} = -h^2 e^{x_{N-1}} + u_N $$\n\n最后一个方程，对应于节点 $i=0$，是使用两种不同的方法从罗宾边界条件推导出来的。\n\n### 方法 A：虚拟节点中心封闭格式\n此方法通过在 $x_{-1} = -h$ 处引入一个带有未知值 $u_{-1}$ 的“虚拟”点，来在边界点 $i=0$ 处施加偏微分方程（PDE）。\n在 $i=0$ 处的 PDE 离散化为：\n$$ \\frac{-u_{-1} + 2u_0 - u_1}{h^2} = f(x_0) = -e^0 = -1 $$\n罗宾边界条件通过使用二阶中心差分来离散化导数 $u'(0)$：\n$$ \\alpha u_0 + \\beta \\left(\\frac{u_1 - u_{-1}}{2h}\\right) = \\gamma $$\n我们消去虚拟值 $u_{-1}$。从离散化的边界条件中，我们求解 $u_{-1}$（假设 $\\beta \\neq 0$，这对所有测试用例都成立）：\n$$ u_{-1} = u_1 - \\frac{2h}{\\beta}(\\gamma - \\alpha u_0) = u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta} $$\n将这个 $u_{-1}$ 的表达式代入 $i=0$ 处的离散化 PDE 中：\n$$ -\\left(u_1 + \\frac{2h\\alpha}{\\beta}u_0 - \\frac{2h\\gamma}{\\beta}\\right) + 2u_0 - u_1 = -h^2 $$\n对未知数 $u_0$ 和 $u_1$ 的项进行分组，我们得到线性系统的第一个方程：\n$$ \\left(2 - \\frac{2h\\alpha}{\\beta}\\right)u_0 - 2u_1 = -h^2 - \\frac{2h\\gamma}{\\beta} $$\n\n### 方法 B：单侧导数封闭格式\n这种方法不使用虚拟点。相反，$i=0$ 处的方程是通过对导数 $u'(0)$ 采用单侧、二阶精确的近似直接从罗宾边界条件推导出来的：\n$$ u'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} $$\n将此代入罗宾边界条件 $\\alpha u_0 + \\beta u'(0) = \\gamma$ 中，得到：\n$$ \\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma $$\n乘以 $2h$ 并对未知数 $u_0$、$u_1$ 和 $u_2$ 的项进行分组，得到线性系统的第一个方程：\n$$ (2h\\alpha - 3\\beta)u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma $$\n\n### 系统组装与求解\n对于每种方法，我们组装一个 $N \\times N$ 的矩阵系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。\n\n**方法 A 的系统：**\n- 第一行 ($i=0$)：\n  $A_{0,0} = 2 - 2h\\alpha/\\beta$，$A_{0,1} = -2$，以及 $b_0 = -h^2 - 2h\\gamma/\\beta$。\n- 内部行 ($i=1, \\dots, N-2$)：\n  $A_{i,i-1}=-1$，$A_{i,i}=2$，$A_{i,i+1}=-1$，以及 $b_i = -h^2e^{x_i}$。\n- 最后一行 ($i=N-1$)：\n  $A_{N-1,N-2}=-1$，$A_{N-1,N-1}=2$，以及 $b_{N-1} = -h^2e^{x_{N-1}} + u_N$。\n\n**方法 B 的系统：**\n- 第一行 ($i=0$)：\n  $A_{0,0} = 2h\\alpha - 3\\beta$，$A_{0,1} = 4\\beta$，$A_{0,2} = -\\beta$，以及 $b_0 = 2h\\gamma$。\n- 内部行和最后一行与方法 A 中的相同。\n\n对于每个测试用例 $(\\alpha, \\beta)$，以及 $N=512$，我们为方法 A 和方法 B 建立并求解线性系统，以找到数值解，特别是边界值 $u_0^{(A)}$ 和 $u_0^{(B)}$。\n\n每种方法的边界点误差计算为 $e_0(h) = |u_0 - u(0)| = |u_0 - 1|$。相应的误差常数估计量为 $C_A(h) = e_0^{(A)}(h)/h^2$ 和 $C_B(h) = e_0^{(B)}(h)/h^2$。最后一步是为每个测试用例计算比率 $R = C_B(h)/C_A(h)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_poisson_1d(N, alpha, beta, method):\n    \"\"\"\n    Solves the 1D Poisson problem with a Robin/Dirichlet BC using two methods.\n\n    Args:\n        N (int): Number of intervals, such that h = 1/N.\n        alpha (float): Robin condition parameter.\n        beta (float): Robin condition parameter.\n        method (str): 'A' or 'B' for the boundary closure method.\n\n    Returns:\n        float: The numerical solution u_0 at the boundary x=0.\n    \"\"\"\n    h = 1.0 / N\n    gamma = alpha + beta\n    u_R = np.exp(1.0)\n    \n    # Grid points and source function values\n    x_nodes = np.linspace(0, 1, N + 1)\n    f_vals = -np.exp(x_nodes)\n    \n    # System A*u = b for unknowns u = [u_0, ..., u_{N-1}]\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Interior rows (i=1 to N-2) are common to both methods\n    for i in range(1, N - 1):\n        A[i, i-1] = -1.0\n        A[i, i]   = 2.0\n        A[i, i+1] = -1.0\n        b[i] = h**2 * f_vals[i]\n        \n    # Last row (i=N-1) is common to both methods\n    if N > 1:\n        A[N-1, N-2] = -1.0\n    A[N-1, N-1] = 2.0\n    b[N-1] = h**2 * f_vals[N-1] + u_R\n        \n    # First row (i=0) depends on the chosen method\n    if method == 'A':\n        # Method A: Ghost-node centered closure\n        # (2 - 2h*alpha/beta)u_0 - 2u_1 = -h^2 - 2h*gamma/beta\n        A[0, 0] = 2.0 - 2.0 * h * alpha / beta\n        if N > 1:\n            A[0, 1] = -2.0\n        # Use f_vals[0] for f(x_0) which equals -exp(0)*h^2 = -h^2. Wait, the derivation was based on f(0)=-1, so it should be -h^2.\n        # The derivation was: (-u_{-1}+2u_0-u_1)/h^2 = f(0) = -1, so -u_{-1}+2u_0-u_1 = -h^2.\n        b[0] = -h**2 - 2.0 * h * gamma / beta\n    elif method == 'B':\n        # Method B: One-sided derivative closure\n        # (2h*alpha - 3*beta)u_0 + 4*beta*u_1 - beta*u_2 = 2h*gamma\n        A[0, 0] = 2.0 * h * alpha - 3.0 * beta\n        if N > 1:\n            A[0, 1] = 4.0 * beta\n        if N > 2:\n            A[0, 2] = -beta\n        b[0] = 2.0 * h * gamma\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'A' or 'B'.\")\n        \n    # Solve the linear system\n    u_solution = np.linalg.solve(A, b)\n    \n    return u_solution[0]\n\ndef solve():\n    \"\"\"\n    Main function to run the computational test and print the results.\n    \"\"\"\n    N = 512\n    h = 1.0 / N\n    u_exact_0 = 1.0  # Exact solution u(0) = exp(0)\n    \n    test_cases = [\n        # (alpha, beta)\n        (1.0, 1.0),\n        (0.0, 1.0),\n        (2.0, 0.5)\n    ]\n    \n    R_values = []\n    \n    for alpha, beta in test_cases:\n        # Solve using Method A\n        u0_A = solve_poisson_1d(N, alpha, beta, method='A')\n        \n        # Solve using Method B\n        u0_B = solve_poisson_1d(N, alpha, beta, method='B')\n        \n        # Calculate boundary pointwise errors\n        e0_A = abs(u0_A - u_exact_0)\n        e0_B = abs(u0_B - u_exact_0)\n        \n        # Calculate error constant estimators\n        # C(h) = e0(h) / h^2\n        C_A = e0_A / h**2\n        C_B = e0_B / h**2\n        \n        # The problem formulation ensures C_A will be non-zero for these tests\n        if C_A == 0:\n            # Handle the unlikely case of zero error for Method A\n             R = np.inf if C_B != 0 else 1.0 # Or np.nan\n        else:\n             R = C_B / C_A\n\n        R_values.append(R)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join([f'{r:.6f}' for r in R_values])}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "在具备实现和比较基本格式能力的基础上，本实践将挑战你设计一种更高精度的方法。你将运用泰勒展开分析边界截断误差，并推导能够抵消主误差项的修正系数。这项练习  展示了一种在不加密网格的情况下提升数值精度的强大技术，让你从简单应用方法，迈向主动优化算法。",
            "id": "3400494",
            "problem": "考虑区间 $[0,1]$ 上标量场 $u(x)$ 的两点边值问题，其由常微分方程 $-u''(x)=f(x)$ 控制，在 $x=0$ 处服从 Neumann 型边界条件 $u'(0)=g$ 或 Robin 型边界条件 $a\\,u(0)+b\\,u'(0)=r$，在 $x=1$ 处服从由精确构造解给定的 Dirichlet 条件。\n\n在均匀网格 $x_j=jh$（其中 $j\\in\\{0,1,\\dots,N\\}$，$h=1/N$）上进行计算，并引入单个值为 $u_{-1}$ 的虚点 $x_{-1}=-h$ 以闭合 $x=0$ 处的边界。\n\n在 $x=0$ 处使用以下配对边界处理格式：一个在 $j=0$ 处计算的微分算子的离散方程，\n$$\n\\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0),\n$$\n结合一个从 $x=0$ 处的边界条件推导出的虚点消除关系式，\n- Neumann：\n$$\n\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)=g,\n$$\n- Robin：\n$$\na\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r.\n$$\n\n任务 1 (推导)。仅从关于 $x=0$ 的泰勒展开以及微分方程 $-u''(x)=f(x)$ 及其导数出发，确定系数 $\\alpha$ 和 $\\beta$ 的值，以消除 $x=0$ 处配对处理格式中的主阶边界截断误差。“消除”的含义是：当将精确解 $u(x)$ 代入左侧，将精确数据代入右侧时，对于一般光滑的 $u(x)$，配对系统在 $j=0$ 处的残差尺度为 $\\mathcal{O}(h^3)$ 或更高阶，而对于 $f''(0)\\neq 0$ 的解析函数 $u(x)$，则达到 $\\mathcal{O}(h^4)$。你的推导必须从 $u(\\pm h)$ 的泰勒多项式开始，使用 $-u''=f$ 将 $u^{(k)}(0)$ 替换为 $f^{(\\ell)}(0)$，并找出使 $\\mathcal{O}(h)$ 和 $\\mathcal{O}(h^2)$ 残差项同时消失所需的 $\\alpha$ 和 $\\beta$ 的条件。\n\n任务 2 (通过构造解进行验证)。实现两个具体的构造解及其导出数据：\n- 正弦：$u(x)=\\sin(\\pi x)$，因此 $f(x)=\\pi^2\\sin(\\pi x)$，$u'(0)=\\pi$，$f'(0)=\\pi^3$ 且 $f''(0)=-\\pi^4\\sin(0)=0$。\n- 指数：$u(x)=e^{\\lambda x}$，其中 $\\lambda$ 是给定的固定参数，因此 $f(x)=-\\lambda^2 e^{\\lambda x}$，$u'(0)=\\lambda$，$f'(0)=-\\lambda^3$ 且 $f''(0)=-\\lambda^4$。\n\n对于 Robin 边界条件，使用固定的实常数 $a$ 和 $b$（其中 $b\\neq 0$），并根据构造解定义 $r=a\\,u(0)+b\\,u'(0)$。对于 Neumann 边界条件，根据构造解设置 $g=u'(0)$。在这两种情况下，都在 $x=1$ 处使用精确的 $u(1)$，对于正弦情况是 $u(1)=\\sin(\\pi)$，对于指数情况是 $u(1)=e^{\\lambda}$。\n\n任务 3 (离散残差阶数测量)。对于每种构造解和每种边界类型（Neumann 和 Robin），通过将精确的节点值 $u_0=u(0)$ 和 $u_1=u(h)$ 以及精确数据代入离散公式，形成 $j=0$ 处的配对边界残差。定义：\n- 基准格式：$\\alpha=0$ 和 $\\beta=0$。\n- 修正格式：使用你从任务 1 推导出的 $\\alpha$ 和 $\\beta$。\n\n对于每种格式，从相应的边界关系式中代数地求出虚点值 $u_{-1}$，然后计算 $j=0$ 处离散微分方程的左侧，以获得离散残差 $R_0(h)$，即：\n$$\nR_0(h)=\\frac{-u_1+2u_0-u_{-1}}{h^2}-\\left(f(0)+\\beta\\,h^2 f''(0)\\right),\n$$\n其中 $u_1=u(h)$ 且 $u_0=u(0)$。通过计算以下公式来测量边界残差的观测阶数 $p$\n$$\np=\\log_2\\left(\\frac{|R_0(h)|}{|R_0(h/2)|}\\right)\n$$\n对一对通过将 $h$ 减半而关联的网格尺寸进行计算。\n\n测试套件规范。使用以下参数集：\n- 构造解：正弦情况和指数情况（$\\lambda=2$）。\n- 边界类型：Neumann 和 Robin（系数 $a=2$ 和 $b=1$）。\n- 网格尺寸：$N_1=64$ 和 $N_2=128$（因此 $h_1=1/N_1$ 和 $h_2=1/N_2$）。\n\n你的程序必须为四种组合（Neumann-正弦、Neumann-指数、Robin-正弦、Robin-指数）中的每一种计算基准格式和修正格式的观测阶数。最终输出应为单行，包含一个逗号分隔的 Python 列表，其中包含八个浮点数，顺序如下：\n$[\\text{Neu-sin 基准},\\text{Neu-sin 修正},\\text{Neu-exp 基准},\\text{Neu-exp 修正},\\text{Rob-sin 基准},\\text{Rob-sin 修正},\\text{Rob-exp 基准},\\text{Rob-exp 修正}]$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]$）。不应打印任何附加文本。不涉及角度，也不需要任何物理单位。所有数值输出必须是普通的十进制浮点数；可以四舍五入到三位小数。代码必须是完全自包含的，并且不需要用户输入。",
            "solution": "问题被评估为有效。这是一个数值分析领域的适定问题，涉及分析有限差分格式截断误差的标准、可验证技术。所有提供的信息都是自包含的、有科学依据的且明确无误的。\n\n### 任务 1：系数 $\\alpha$ 和 $\\beta$ 的推导\n\n目标是确定配对边界处理格式中的系数 $\\alpha$ 和 $\\beta$，使得在边界 $x=0$ 处的局部截断误差的主阶项被消除。该过程包括将精确解 $u(x)$ 代入离散方程，进行泰勒级数分析，并选择 $\\alpha$ 和 $\\beta$ 以消除最低阶误差项。\n\n在 $x=0$ 处的配对边界处理格式由两个方程组成：\n1.  微分方程 $-u''(x)=f(x)$ 在 $x_0=0$ 处的一个修正离散形式：\n    $$ \\frac{-u_1+2u_0-u_{-1}}{h^2}=f(0)+\\beta\\,h^2 f''(0) $$\n2.  边界条件的离散表示，用于消除虚点值 $u_{-1}$。我们分析 Neumann 和 Robin 两种情况。\n\n设 $u(x)$ 为精确解，并假设其足够光滑。我们使用记号 $u_j = u(x_j)$，$u_0 = u(0)$，$u_1 = u(h)$，$u_{-1}$ 是虚点值，以及 $u^{(k)}_0 = \\frac{d^k u}{dx^k}(0)$。从微分方程，我们得到关系式 $u^{(k)}_0 = -f^{(k-2)}_0$ (对于 $k \\ge 2$)，其中 $f^{(m)}_0 = \\frac{d^m f}{dx^m}(0)$。\n\n首先，考虑 Robin 边界条件 $a\\,u(0)+b\\,u'(0)=r$，其离散形式为：\n$$ a\\,u_0+b\\left(\\frac{u_1-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=r $$\n我们将精确值代入此关系式：$u_0 = u(0)$，$u_1 = u(h)$，以及 $r = a\\,u(0)+b\\,u'(0)$。\n$$ a\\,u(0)+b\\left(\\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0)\\right)=a\\,u(0)+b\\,u'(0) $$\n假设 $b \\neq 0$，我们可以解出其隐含的虚点值 $u_{-1}$：\n$$ \\frac{u(h)-u_{-1}}{2h}+\\alpha\\,h^2 f'(0) = u'(0) $$\n$$ u(h)-u_{-1} = 2h\\,u'(0) - 2h\\,\\alpha\\,h^2 f'(0) $$\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\nNeumann 情况 $u'(0)=g$ 及其离散形式 $\\frac{u_1-u_{-1}}{2h}+\\alpha h^2 f'(0)=g$，在设置 $g=u'(0)$ 后，会得到与 $u_{-1}$ 相同的表达式。因此，对于两种边界条件类型，推导过程是相同的。\n\n核心任务是在代入 $u_{-1}$ 的表达式后，分析 $j=0$ 处离散微分方程的残差。残差 $R_0(h)$ 的定义是通过将精确解代入数值格式得到的：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n代入 $u_{-1}$ 的表达式：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-\\left(u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0)\\right)}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n$$ R_0(h) = \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} - 2\\alpha h f'(0) - f(0) - \\beta h^2 f''(0) $$\n为分析此表达式，我们使用 $u(h)$ 在 $x=0$ 附近的泰勒级数展开：\n$$ u(h) = u(0) + h\\,u'(0) + \\frac{h^2}{2}u''(0) + \\frac{h^3}{6}u'''(0) + \\frac{h^4}{24}u^{(4)}(0) + \\frac{h^5}{120}u^{(5)}(0) + \\mathcal{O}(h^6) $$\n将此代入含有 $u(h)$ 的项中：\n$$ 2u(0) - 2u(h) + 2h\\,u'(0) = 2u_0 - 2\\left(u_0 + h u'_0 + \\frac{h^2}{2}u''_0 + \\frac{h^3}{6}u'''_0 + \\dots\\right) + 2h u'_0 $$\n$$ = -h^2 u''_0 - \\frac{h^3}{3}u'''_0 - \\frac{h^4}{12}u^{(4)}_0 - \\frac{h^5}{60}u^{(5)}_0 - \\mathcal{O}(h^6) $$\n除以 $h^2$，残差的第一部分变为：\n$$ \\frac{2u(0) - 2u(h) + 2h\\,u'(0)}{h^2} = -u''_0 - \\frac{h}{3}u'''_0 - \\frac{h^2}{12}u^{(4)}_0 - \\frac{h^3}{60}u^{(5)}_0 - \\mathcal{O}(h^4) $$\n现在，我们使用来自常微分方程的关系式，$u''_0 = -f_0$，$u'''_0 = -f'_0$，$u^{(4)}_0 = -f''_0$，等等：\n$$ = -(-f_0) - \\frac{h}{3}(-f'_0) - \\frac{h^2}{12}(-f''_0) - \\frac{h^3}{60}(-f'''_0) - \\mathcal{O}(h^4) $$\n$$ = f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n我们将此代回残差 $R_0(h)$ 的完整表达式中：\n$$ R_0(h) = \\left(f_0 + \\frac{h}{3}f'_0 + \\frac{h^2}{12}f''_0 + \\frac{h^3}{60}f'''_0\\right) - 2\\alpha h f'_0 - f_0 - \\beta h^2 f''_0 + \\mathcal{O}(h^4) $$\n按 $h$ 的幂次收集项：\n$$ R_0(h) = \\left(\\frac{1}{3} - 2\\alpha\\right)h f'_0 + \\left(\\frac{1}{12} - \\beta\\right)h^2 f''_0 + \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n为了消除主阶误差项，即 $\\mathcal{O}(h)$ 和 $\\mathcal{O}(h^2)$ 项，我们必须将其系数设为零：\n\\begin{enumerate}\n    \\item $h$ 的系数：$\\frac{1}{3} - 2\\alpha = 0 \\implies \\alpha = \\frac{1}{6}$\n    \\item $h^2$ 的系数：$\\frac{1}{12} - \\beta = 0 \\implies \\beta = \\frac{1}{12}$\n\\end{enumerate}\n使用这些值，残差变为：\n$$ R_0(h) = \\frac{h^3}{60}f'''_0 + \\mathcal{O}(h^4) $$\n因此，只要 $f'''(0) \\neq 0$，修正格式的残差阶数为 $\\mathcal{O}(h^3)$。这满足了阶数达到 $\\mathcal{O}(h^3)$ 或更高的要求。问题中关于该方法对 $f''(0) \\neq 0$ 的解析函数 $u(x)$ 能达到 $\\mathcal{O}(h^4)$ 的说法，并未被此直接推导所支持；如推导所示，主误差项为 $\\mathcal{O}(h^3)$。\n\n### 任务 2 和 3：通过构造解进行验证和残差测量\n\n我们现在通过数值方法验证这些发现。我们将为基准格式 ($\\alpha=0, \\beta=0$) 和修正格式 ($\\alpha=1/6, \\beta=1/12$) 计算残差 $R_0(h)$ 及其收敛阶数。\n\n构造解为：\n\\begin{itemize}\n    \\item **正弦情况**：$u(x)=\\sin(\\pi x)$。这给出 $f(x)=\\pi^2\\sin(\\pi x)$。在 $x=0$ 处，我们有 $u(0)=0$，$u'(0)=\\pi$，$f(0)=0$，$f'(0)=\\pi^3$ 以及 $f''(0)=0$。\n    \\item **指数情况**：$u(x)=e^{\\lambda x}$ 且 $\\lambda=2$。这给出 $f(x)=-\\lambda^2 e^{\\lambda x}$。在 $x=0$ 处，我们有 $u(0)=1$，$u'(0)=\\lambda=2$，$f(0)=-\\lambda^2=-4$，$f'(0)=-\\lambda^3=-8$ 以及 $f''(0)=-\\lambda^4=-16$。\n\\end{itemize}\n\n对于每种情况，我们针对两个网格尺寸 $h_1=1/N_1$ 和 $h_2=1/N_2$（其中 $N_1=64$ 和 $N_2=128$）计算残差 $R_0(h)$。残差的公式为：\n$$ R_0(h) = \\frac{-u(h)+2u(0)-u_{-1}}{h^2} - \\left(f(0)+\\beta\\,h^2 f''(0)\\right) $$\n其中 $u_{-1}$ 从边界条件关系式中求得：\n$$ u_{-1} = u(h) - 2h\\,u'(0) + 2\\alpha h^3 f'(0) $$\n收敛的观测阶数 $p$ 计算如下：\n$$ p = \\log_2\\left(\\frac{|R_0(h_1)|}{|R_0(h_2)|}\\right) $$\n以下 Python 代码为四种指定的测试配置（Neumann/Robin 与正弦/指数）实现了此验证过程。根据推导，对于 Neumann 和 Robin 边界条件，残差 $R_0(h)$ 的计算是相同的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving coefficients and performing numerical verification.\n    The derivation shows alpha=1/6 and beta=1/12. This is implemented and tested.\n    \"\"\"\n    \n    # Task 1 derived coefficients for the corrected scheme\n    ALPHA_CORRECTED = 1.0 / 6.0\n    BETA_CORRECTED = 1.0 / 12.0\n\n    # Baseline scheme coefficients\n    ALPHA_BASELINE = 0.0\n    BETA_BASELINE = 0.0\n\n    # Test parameters\n    LAMBDA = 2.0\n    A_ROBIN = 2.0\n    B_ROBIN = 1.0\n    N1 = 64\n    N2 = 128\n    \n    # --- Manufactured Solutions ---\n\n    # Sine case\n    u_sin = lambda x: np.sin(np.pi * x)\n    u_prime_sin = lambda x: np.pi * np.cos(np.pi * x)\n    f_sin = lambda x: np.pi**2 * np.sin(np.pi * x)\n    f_prime_sin = lambda x: np.pi**3 * np.cos(np.pi * x)\n    f_double_prime_sin = lambda x: -np.pi**4 * np.sin(np.pi * x)\n\n    # Exponential case\n    u_exp = lambda x: np.exp(LAMBDA * x)\n    u_prime_exp = lambda x: LAMBDA * np.exp(LAMBDA * x)\n    f_exp = lambda x: -LAMBDA**2 * np.exp(LAMBDA * x)\n    f_prime_exp = lambda x: -LAMBDA**3 * np.exp(LAMBDA * x)\n    f_double_prime_exp = lambda x: -LAMBDA**4 * np.exp(LAMBDA * x)\n\n    def calculate_residual(h, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta):\n        \"\"\"\n        Calculates the residual R_0(h) for a given manufactured solution and scheme.\n        \"\"\"\n        # Get exact values at x=0 and x=h\n        u0 = u_func(0)\n        u1 = u_func(h)\n        u_prime0 = u_prime_func(0)\n        f0 = f_func(0)\n        f_prime0 = f_prime_func(0)\n        f_double_prime0 = f_double_prime_func(0)\n        \n        # Calculate ghost point value u_{-1}\n        # This expression is the same for both Neumann and Robin cases as per the derivation.\n        u_minus_1 = u1 - 2 * h * u_prime0 + 2 * alpha * h**3 * f_prime0\n        \n        # Calculate the residual R_0(h)\n        lhs = (-u1 + 2 * u0 - u_minus_1) / h**2\n        rhs = f0 + beta * h**2 * f_double_prime0\n        residual = lhs - rhs\n        \n        return residual\n\n    def calculate_order(u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta, n1, n2):\n        \"\"\"\n        Calculates the observed order of convergence p.\n        \"\"\"\n        h1 = 1.0 / n1\n        h2 = 1.0 / n2\n        \n        r1 = calculate_residual(h1, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        r2 = calculate_residual(h2, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func, alpha, beta)\n        \n        # Handle cases where residual is zero to avoid division by zero or log(0)\n        if abs(r2) < 1e-15:\n            # If r2 is zero, the error is machine precision. If r1 was also zero, order is irrelevant.\n            # If r1 was not, convergence is faster than can be measured.\n            return np.inf\n        if abs(r1) < 1e-15:\n            # This case should not be hit if h is halved, but as a safe guard:\n            return 0.0\n\n        order = np.log2(abs(r1) / abs(r2))\n        return order\n\n\n    test_cases = [\n        # (name, u_func, u_prime_func, f_func, f_prime_func, f_double_prime_func)\n        (\"Neu-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Neu-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n        (\"Rob-sin\", u_sin, u_prime_sin, f_sin, f_prime_sin, f_double_prime_sin),\n        (\"Rob-exp\", u_exp, u_prime_exp, f_exp, f_prime_exp, f_double_prime_exp),\n    ]\n\n    results = []\n    for name, u, up, f, fp, fpp in test_cases:\n        # Baseline scheme\n        order_baseline = calculate_order(u, up, f, fp, fpp, ALPHA_BASELINE, BETA_BASELINE, N1, N2)\n        results.append(round(order_baseline, 3))\n        \n        # Corrected scheme\n        order_corrected = calculate_order(u, up, f, fp, fpp, ALPHA_CORRECTED, BETA_CORRECTED, N1, N2)\n        results.append(round(order_corrected, 3))\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将鬼点法的概念从简单的一维区域推广到一个更真实、也更具挑战性的场景：在嵌入三维笛卡尔网格的曲面边界上施加边界条件。你将学习使用符号距离函数这一处理复杂几何的有力工具来构建鬼点。这项练习  对于理解如何将这些技术应用于边界与计算网格不重合的实际问题至关重要。",
            "id": "3400490",
            "problem": "考虑在一个三维笛卡爾網格上，對一個純量場使用由符號距離函數導出的虛擬點來數值上實施諾伊曼邊界條件。設計算區域為 $[-1,1]^3$，且物理域 $\\Omega$ 為一個以原點為中心、半徑為 $R$ 的球體內部，亦即邊界 $\\partial \\Omega$ 由水平集 $\\{\\boldsymbol{x} \\in \\mathbb{R}^3 : \\phi(\\boldsymbol{x}) = 0\\}$ 給出，其中 $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$ 是符號距離函數，在 $\\Omega$ 內部為負值。设未知纯量场 $u(\\boldsymbol{x})$ 是光滑的。诺伊曼边界条件旨在边界 $\\partial \\Omega$ 上施加 $\\partial u/\\partial n = g$，其中 $\\partial u/\\partial n$ 表示 $u$ 的法向导数，$g$ 是在 $\\partial \\Omega$ 上给定的光滑函数。\n\n您將研究如何使用符號距離函數在光滑曲面邊界上应用虚擬點技術来处理诺伊曼边界条件。您的目標是量化虛擬點構造的精度，并验证其在曲率和网格各向异性变化下的观测精度阶。该分析使用人造解，纯粹是数学和算法层面的，不涉及任何物理单位。\n\n将使用的基本定义：\n- 偏微分方程（PDE）的边界条件为在 $\\partial \\Omega$ 上 $\\partial u/\\partial n = g$。\n- 符号距离函数为 $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}\\| - R$；其梯度 $\\nabla \\phi(\\boldsymbol{x})$ 是在 $\\partial \\Omega$ 上的向外单位法向量 $\\boldsymbol{n}$，并且对于 $\\boldsymbol{x} \\neq \\boldsymbol{0}$，等于 $\\boldsymbol{x}/\\|\\boldsymbol{x}\\|$。\n- 对于边界附近的一个内部网格节点 $\\boldsymbol{x}_i$，其虚拟点是通过沿符号距离函数确定的法线方向跨 $\\partial \\Omega$ 反射构造的。\n\n人造数据：\n- 设纯量场为 $u(\\boldsymbol{x}) = \\sin(\\pi x) + \\cos(2 \\pi y) + \\sinh(z)$，其中 $\\boldsymbol{x} = (x,y,z)$。\n- 那么 $\\nabla u(\\boldsymbol{x}) = \\left(\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z)\\right)$。\n- 诺伊曼边界数据为 $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$，其中 $\\boldsymbol{x}_B \\in \\partial \\Omega$。\n\n待实现的虚拟点构造方法：\n- 对于一个满足 $\\phi(\\boldsymbol{x}_i) < 0$ 和 $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$ 的网格节点 $\\boldsymbol{x}_i$，定义 $d = -\\phi(\\boldsymbol{x}_i) > 0$ 和 $\\boldsymbol{n}_i = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$。\n- 沿法线方向最近的边界点是 $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i$。\n- 反射后的虚拟点位置是 $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2 d \\boldsymbol{n}_i$。\n- 通过沿法线的对称泰勒展开定义虚拟点值来施加诺伊曼边界条件：$u_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2 d \\, g(\\boldsymbol{x}_B)$。\n- 用于误差评估的精确虚拟点值为 $u_G^{\\text{exact}} = u(\\boldsymbol{x}_G)$。\n\n误差度量和观测精度阶：\n- 在满足 $-\\phi(\\boldsymbol{x}_i) \\le h_{\\max}$ 的内部节点集合上（即邻近边界的一个单元厚度的内部带），定义均方根误差\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2},\n$$\n其中 $N$ 是该集合中节点的数量。\n- 对每个测试案例执行两种网格分辨率，其中细网格的最大网格间距是粗网格的一半。观测到的精度阶为\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}.\n$$\n\n网格生成：\n- 使用允许各向异性间距的笛卡尔网格。对于 $x, y, z$ 方向上给定的节点数 $N_x, N_y, N_z$，通过在 $[-1,1]$ 上的均匀线性间隔来定义网格，即 $x_j = -1 + j \\, h_x$，$h_x = 2/(N_x-1)$，对 $y$ 和 $z$ 也类似。\n- 定义 $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$。\n\n测试套件：\n- 案例 1：$R = 0.70$，粗网格 $(N_x,N_y,N_z) = (25,25,25)$，细网格 $(N_x,N_y,N_z) = (49,49,49)$。\n- 案例 2：$R = 0.35$，粗网格 $(N_x,N_y,N_z) = (25,25,25)$，细网格 $(N_x,N_y,N_z) = (49,49,49)$。\n- 案例 3：$R = 0.70$，粗网格 $(N_x,N_y,N_z) = (25,49,97)$，细网格 $(N_x,N_y,N_z) = (49,97,193)$。\n- 案例 4：$R = 0.35$，粗网格 $(N_x,N_y,N_z) = (25,49,97)$，细网格 $(N_x,N_y,N_z) = (49,97,193)$。\n\n您的程序应计算上述四个案例中每一个的观测阶 $p$，并生成单行输出，其中包含四个 $p$ 值，形式为方括号内的逗号分隔列表，例如 $[p_1,p_2,p_3,p_4]$。所有量均为无量纲。角度（如果出现在三角函数中）以弧度为单位。最终答案是实数。",
            "solution": "问题陈述已经过验证，被确定为一项适定的、科学上合理的数值分析练习。它概述了一个清晰的流程，用于验证在嵌入笛卡尔网格的曲面边界上实施诺伊曼边界条件的特定虚拟点方法的精度阶。所有的定义、参数和人造数据都是自洽且一致的。该问题没有逻辑缺陷、歧义或矛盾。原点处法向量未定义的潜在奇点问题，由于问题的参数选择，被自然地避免了，因为原点不会落在进行计算的一个单元厚度的边界层内。因此，我们可以继续求解。\n\n目标是计算用于在球形域上施加诺伊曼边界条件 $\\partial u/\\partial n = g$ 的虚拟点构造方法的观测精度阶 $p$。这涉及一个使用人造解的数值实验。该过程将对四个不同的测试案例执行，每个案例由一个球体半径 $R$ 和一组粗、细网格分辨率定义。\n\n该方法论的核心是为每个测试案例的粗网格和细网格计算均方根（RMS）误差 $E$。然后使用以下公式确定观测精度阶 $p$：\n$$\np = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(2)}\n$$\n该公式量化了当网格间距减半时误差如何减小。一个误差为 $E = O(h^k)$ 的方法预计会得到一个观测阶 $p \\approx k$。\n\n误差计算过程如下：\n首先，在计算区域 $[-1, 1]^3$ 上生成一个具有指定节点数 $(N_x, N_y, N_z)$ 的均匀笛卡尔网格。网格间距为 $h_x = 2/(N_x-1)$, $h_y = 2/(N_y-1)$ 和 $h_z = 2/(N_z-1)$，且 $h_{\\max} = \\max\\{h_x, h_y, h_z\\}$。\n\n其次，我们识别出“近边界”内部网格节点集合 $\\boldsymbol{x}_i$。这些节点的符号距离函数 $\\phi(\\boldsymbol{x}_i) = \\|\\boldsymbol{x}_i\\| - R$ 为负（表明节点在球体内部），并且到边界的法向距离 $d = -\\phi(\\boldsymbol{x}_i)$ 不大于 $h_{\\max}$。这定义了邻近边界 $\\partial\\Omega$ 内侧的一个单元厚度的节点层。设该集合包含 $N$ 个节点。\n\n第三，对于此集合中的每个节点 $\\boldsymbol{x}_i$，我们构造其对应的虚拟点，并计算在该虚拟点位置纯量场 $u$ 的两个值：一个数值近似值 $u_G^{\\text{num}}$ 和一个精确值 $u_G^{\\text{exact}}$。\n\n该构造基于沿法线方向跨边界的反射。对于一个节点 $\\boldsymbol{x}_i$：\n1. 到边界的法向距离是 $d = -\\phi(\\boldsymbol{x}_i) = R - \\|\\boldsymbol{x}_i\\|$。\n2. 在 $\\boldsymbol{x}_i$ 处的向外法线方向近似为 $\\boldsymbol{n}_i = \\nabla\\phi(\\boldsymbol{x}_i) = \\boldsymbol{x}_i / \\|\\boldsymbol{x}_i\\|$。\n3. 沿此法线方向边界上最近的点是 $\\boldsymbol{x}_B = \\boldsymbol{x}_i + d \\boldsymbol{n}_i = \\boldsymbol{x}_i (R / \\|\\boldsymbol{x}_i\\|)$。\n4. 反射后的虚拟点位置是 $\\boldsymbol{x}_G = \\boldsymbol{x}_i + 2d \\boldsymbol{n}_i$。\n\n虚拟点处的精确值 $u_G^{\\text{exact}}$ 是通过直接在 $\\boldsymbol{x}_G$ 处计算人造解得到的：\n$$\nu_G^{\\text{exact}} = u(\\boldsymbol{x}_G) = \\sin(\\pi x_G) + \\cos(2 \\pi y_G) + \\sinh(z_G)\n$$\n\n数值 $u_G^{\\text{num}}$ 是通过以内部点 $\\boldsymbol{x}_i$ 为中心的一阶泰勒展开定义的，该展开在边界点 $\\boldsymbol{x}_B$ 处施加诺伊曼条件：\n$$\nu_G^{\\text{num}} = u(\\boldsymbol{x}_i) + 2d \\, g(\\boldsymbol{x}_B)\n$$\n此处，$u(\\boldsymbol{x}_i)$ 是人造解在内部节点处的值。边界数据 $g(\\boldsymbol{x}_B)$ 由人造解确定为 $g(\\boldsymbol{x}_B) = \\nabla u(\\boldsymbol{x}_B) \\cdot \\boldsymbol{n}(\\boldsymbol{x}_B)$，其中 $\\boldsymbol{n}(\\boldsymbol{x}_B) = \\boldsymbol{x}_B/R$ 是边界点处的精确单位法向量。梯度向量由 $\\nabla u(\\boldsymbol{x}) = (\\pi \\cos(\\pi x), -2 \\pi \\sin(2 \\pi y), \\cosh(z))$ 给出。\n\n对局部误差 $u_G^{\\text{num}} - u_G^{\\text{exact}}$ 的泰勒级数分析表明，误差由一个与 $d^3$ 成正比的项主导：\n$$\nu_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) = -\\frac{d^3}{3} \\frac{\\partial^3 u}{\\partial n^3}\\Big|_{\\boldsymbol{x}_B} + O(d^4)\n$$\n由于 $d$ 与网格间距 $h$ 同阶，虚拟点值的局部误差为 $O(h^3)$。\n\n最后，通过对 $N$ 个近边界节点的平方差求平均来计算 RMS 误差 $E$：\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N \\left(u_G^{\\text{num}}(\\boldsymbol{x}_i) - u_G^{\\text{exact}}(\\boldsymbol{x}_i) \\right)^2}\n$$\n根据局部误差分析，RMS 误差 $E$ 预期为 $O(h^3)$，因此观测精度阶 $p$ 预期接近于 3。\n\n该实现将为了效率使用 NumPy 向量化操作为四个指定的测试案例分别执行这些计算。对于每个案例，计算 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$，并报告最终的 $p$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_manufactured(points):\n    \"\"\"\n    Computes the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N,) with the value of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    return np.sin(np.pi * x) + np.cos(2 * np.pi * y) + np.sinh(z)\n\ndef grad_u_manufactured(points):\n    \"\"\"\n    Computes the gradient of the scalar field u for a set of points (vectorized).\n\n    Args:\n        points: A numpy array of shape (N, 3) representing N points in 3D space.\n\n    Returns:\n        A numpy array of shape (N, 3) with the gradient vector of u at each point.\n    \"\"\"\n    x = points[:, 0]\n    y = points[:, 1]\n    z = points[:, 2]\n    du_dx = np.pi * np.cos(np.pi * x)\n    du_dy = -2 * np.pi * np.sin(2 * np.pi * y)\n    du_dz = np.cosh(z)\n    return np.stack([du_dx, du_dy, du_dz], axis=1)\n\ndef compute_error(R, N_x, N_y, N_z):\n    \"\"\"\n    Computes the RMS error of the ghost point value approximation.\n\n    Args:\n        R (float): Radius of the spherical domain.\n        N_x (int): Number of grid points in the x-direction.\n        N_y (int): Number of grid points in the y-direction.\n        N_z (int): Number of grid points in the z-direction.\n\n    Returns:\n        float: The root-mean-square error E.\n    \"\"\"\n    # 1. Grid Generation\n    h_x = 2.0 / (N_x - 1) if N_x > 1 else 0.0\n    h_y = 2.0 / (N_y - 1) if N_y > 1 else 0.0\n    h_z = 2.0 / (N_z - 1) if N_z > 1 else 0.0\n    h_max = max(h_x, h_y, h_z)\n\n    x_coords = np.linspace(-1.0, 1.0, N_x)\n    y_coords = np.linspace(-1.0, 1.0, N_y)\n    z_coords = np.linspace(-1.0, 1.0, N_z)\n    \n    xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n    all_points = np.stack([xx.ravel(), yy.ravel(), zz.ravel()], axis=1)\n\n    # 2. Identify Nodes of Interest\n    phi = np.linalg.norm(all_points, axis=1) - R\n    interior_band_indices = np.where((phi < 0) & (-phi <= h_max))[0]\n    \n    if len(interior_band_indices) == 0:\n        return 0.0\n\n    x_i_set = all_points[interior_band_indices]\n\n    # 3. Ghost Point Construction (Vectorized)\n    d = -phi[interior_band_indices]\n    norm_x_i = np.linalg.norm(x_i_set, axis=1, keepdims=True)\n\n    # Filter out origin if it is in the set to avoid division by zero.\n    # The problem setup ensures this is not the case for the given test cases.\n    non_zero_mask = (norm_x_i > 1e-15).ravel()\n    if not np.all(non_zero_mask):\n        x_i_set = x_i_set[non_zero_mask]\n        d = d[non_zero_mask]\n        norm_x_i = norm_x_i[non_zero_mask]\n\n    n_i = x_i_set / norm_x_i\n    x_B = x_i_set * (R / norm_x_i)\n    x_G = x_i_set + 2 * d[:, np.newaxis] * n_i\n    \n    # 4. Calculate Numerical and Exact Ghost Values\n    # Numerical: u_G_num = u(x_i) + 2*d*g(x_B)\n    u_at_xi = u_manufactured(x_i_set)\n    grad_u_at_xB = grad_u_manufactured(x_B)\n    n_at_xB = x_B / R\n    g_at_xB = np.sum(grad_u_at_xB * n_at_xB, axis=1)\n    u_G_num = u_at_xi + 2 * d * g_at_xB\n    \n    # Exact: u_G_exact = u(x_G)\n    u_G_exact = u_manufactured(x_G)\n\n    # 5. Compute RMS Error\n    squared_errors = (u_G_num - u_G_exact)**2\n    rms_error = np.sqrt(np.mean(squared_errors))\n    \n    return rms_error\n    \ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute observed orders of accuracy.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R, (Nx_coarse, Ny_coarse, Nz_coarse), (Nx_fine, Ny_fine, Nz_fine))\n        (0.70, (25, 25, 25), (49, 49, 49)),\n        (0.35, (25, 25, 25), (49, 49, 49)),\n        (0.70, (25, 49, 97), (49, 97, 193)),\n        (0.35, (25, 49, 97), (49, 97, 193)),\n    ]\n\n    results = []\n    for R, coarse_grid, fine_grid in test_cases:\n        E_coarse = compute_error(R, *coarse_grid)\n        E_fine = compute_error(R, *fine_grid)\n        \n        if E_fine > 0 and E_coarse > 0:\n            order = np.log(E_coarse / E_fine) / np.log(2.0)\n        else:\n            # This case shouldn't occur for this problem but is good practice\n            order = np.nan\n        \n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}