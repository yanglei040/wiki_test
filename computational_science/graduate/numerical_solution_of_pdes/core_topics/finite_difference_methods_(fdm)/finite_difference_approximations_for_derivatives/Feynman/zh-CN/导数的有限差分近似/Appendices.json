{
    "hands_on_practices": [
        {
            "introduction": "有限差分方法的基础是泰勒级数展开。本练习将通过待定系数法，训练您构建自定义高阶差分格式的核心技能，例如在处理计算区域的边界时必须使用的单边格式。通过这个练习，您将从头开始推导一个三阶精度的前向差分公式。",
            "id": "3307331",
            "problem": "在一维横电磁场的麦克斯韦旋度方程的时域有限差分 (FDTD) 离散化中，位于位置 $x_{0}$ 的理想导电边界处的空间导数必须使用单边模板进行近似，以避免在计算域外进行采样。设 $f(x)$ 表示沿边界法向方向的一个足够光滑的笛卡尔场分量。你需要使用网格点上的值 $f(x_{0})$、$f(x_{0}+h)$、$f(x_{0}+2h)$ 和 $f(x_{0}+3h)$ 构建一个对于 $f'(x_{0})$ 的单边三阶精度有限差分近似，其中 $h>0$ 是均匀空间步长。\n\n仅从 $f(x)$ 在 $x_{0}$ 点的泰勒级数展开和一阶导数的定义出发，确定系数 $c_{0}$、$c_{1}$、$c_{2}$ 和 $c_{3}$，使得\n$$\nf'(x_{0}) \\approx \\frac{c_{0} f(x_{0}) + c_{1} f(x_{0}+h) + c_{2} f(x_{0}+2h) + c_{3} f(x_{0}+3h)}{h}\n$$\n其截断误差为 $O(h^{3})$ 阶。将最终的近似表示为样本值除以 $h$ 的单一封闭形式有理组合。最终答案必须是单一的解析表达式。不要包含任何单位。",
            "solution": "该问题要求为在点 $x_0$ 处的一个足够光滑函数 $f(x)$ 的一阶导数构建一个单边、三阶精度的有限差分近似。该近似必须使用四个网格点 $x_0$、$x_0+h$、$x_0+2h$ 和 $x_0+3h$，其中 $h > 0$ 是均匀的网格间距。指定的近似形式为：\n$$\nf'(x_0) \\approx \\frac{c_0 f(x_0) + c_1 f(x_0+h) + c_2 f(x_0+2h) + c_3 f(x_0+3h)}{h}\n$$\n任务是确定未知系数 $c_0$、$c_1$、$c_2$ 和 $c_3$，使得该近似的截断误差为 $O(h^3)$ 阶。推导过程必须从函数 $f(x)$ 在指定网格点处的泰勒级数展开开始。\n\n我们首先写出 $f(x)$ 在点 $x_0$ 附近的泰勒级数展开。对于一个足够光滑的函数， $f(x_0+h)$、$f(x_0+2h)$ 和 $f(x_0+3h)$ 的展开式为：\n$$\nf(x_0+h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + \\frac{h^4}{4!} f^{(4)}(x_0) + O(h^5)\n$$\n$$\nf(x_0+2h) = f(x_0) + (2h) f'(x_0) + \\frac{(2h)^2}{2!} f''(x_0) + \\frac{(2h)^3}{3!} f'''(x_0) + \\frac{(2h)^4}{4!} f^{(4)}(x_0) + O(h^5)\n$$\n$$\nf(x_0+3h) = f(x_0) + (3h) f'(x_0) + \\frac{(3h)^2}{2!} f''(x_0) + \\frac{(3h)^3}{3!} f'''(x_0) + \\frac{(3h)^4}{4!} f^{(4)}(x_0) + O(h^5)\n$$\n我们将这些展开式代入有限差分公式的分子中：\n$$\nc_0 f(x_0) + c_1 f(x_0+h) + c_2 f(x_0+2h) + c_3 f(x_0+3h)\n$$\n代入并按 $f(x)$ 在 $x_0$ 处的各阶导数对各项进行分组：\n$$\n= c_0 f(x_0) + c_1 \\left( \\sum_{k=0}^{\\infty} \\frac{h^k}{k!} f^{(k)}(x_0) \\right) + c_2 \\left( \\sum_{k=0}^{\\infty} \\frac{(2h)^k}{k!} f^{(k)}(x_0) \\right) + c_3 \\left( \\sum_{k=0}^{\\infty} \\frac{(3h)^k}{k!} f^{(k)}(x_0) \\right)\n$$\n$$\n= (c_0 + c_1 + c_2 + c_3) f(x_0) + h(c_1 + 2c_2 + 3c_3) f'(x_0) + \\frac{h^2}{2}(c_1 + 4c_2 + 9c_3) f''(x_0) + \\frac{h^3}{6}(c_1 + 8c_2 + 27c_3) f'''(x_0) + \\frac{h^4}{24}(c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) + \\dots\n$$\n现在，我们将其代回到完整的近似表达式中，并要求它等于 $f'(x_0) + O(h^3)$。\n$$\n\\frac{1}{h} \\left[ (c_0 + c_1 + c_2 + c_3) f(x_0) + h(c_1 + 2c_2 + 3c_3) f'(x_0) + \\frac{h^2}{2}(c_1 + 4c_2 + 9c_3) f''(x_0) + \\frac{h^3}{6}(c_1 + 8c_2 + 27c_3) f'''(x_0) + \\dots \\right] = f'(x_0) + O(h^3)\n$$\n为了满足这个等式，左侧各阶导数的系数必须与右侧匹配。\n\\begin{itemize}\n    \\item $f(x_0)/h$ 的系数必须为 $0$：$c_0 + c_1 + c_2 + c_3 = 0$。\n    \\item $f'(x_0)$ 的系数必须为 $1$：$c_1 + 2c_2 + 3c_3 = 1$。\n    \\item $h f''(x_0)$ 的系数必须为 $0$：$\\frac{1}{2}(c_1 + 4c_2 + 9c_3) = 0 \\implies c_1 + 4c_2 + 9c_3 = 0$。\n    \\item $h^2 f'''(x_0)$ 的系数必须为 $0$：$\\frac{1}{6}(c_1 + 8c_2 + 27c_3) = 0 \\implies c_1 + 8c_2 + 27c_3 = 0$。\n\\end{itemize}\n这就建立了一个关于四个未知系数 $c_0, c_1, c_2, c_3$ 的四元线性方程组：\n\\begin{align}\n    c_0 + c_1 + c_2 + c_3 = 0 \\quad (1) \\\\\n    c_1 + 2c_2 + 3c_3 = 1 \\quad (2) \\\\\n    c_1 + 4c_2 + 9c_3 = 0 \\quad (3) \\\\\n    c_1 + 8c_2 + 27c_3 = 0 \\quad (4)\n\\end{align}\n我们可以使用方程 $(2)$、$(3)$ 和 $(4)$ 来求解 $c_1, c_2, c_3$。\n从 $(3)$ 中减去 $(2)$：\n$$\n(c_1 + 4c_2 + 9c_3) - (c_1 + 2c_2 + 3c_3) = 0 - 1 \\implies 2c_2 + 6c_3 = -1 \\quad (5)\n$$\n从 $(4)$ 中减去 $(3)$：\n$$\n(c_1 + 8c_2 + 27c_3) - (c_1 + 4c_2 + 9c_3) = 0 - 0 \\implies 4c_2 + 18c_3 = 0 \\implies 2c_2 + 9c_3 = 0 \\quad (6)\n$$\n现在我们求解方程组 $(5)$ 和 $(6)$。从 $(6)$ 中减去 $(5)$：\n$$\n(2c_2 + 9c_3) - (2c_2 + 6c_3) = 0 - (-1) \\implies 3c_3 = 1 \\implies c_3 = \\frac{1}{3}\n$$\n将 $c_3 = 1/3$ 代入方程 $(6)$：\n$$\n2c_2 + 9\\left(\\frac{1}{3}\\right) = 0 \\implies 2c_2 + 3 = 0 \\implies c_2 = -\\frac{3}{2}\n$$\n将 $c_2 = -3/2$ 和 $c_3 = 1/3$ 代入方程 $(2)$：\n$$\nc_1 + 2\\left(-\\frac{3}{2}\\right) + 3\\left(\\frac{1}{3}\\right) = 1 \\implies c_1 - 3 + 1 = 1 \\implies c_1 = 3\n$$\n最后，使用方程 $(1)$ 来求解 $c_0$：\n$$\nc_0 + 3 + \\left(-\\frac{3}{2}\\right) + \\frac{1}{3} = 0 \\implies c_0 + \\frac{18-9+2}{6} = 0 \\implies c_0 + \\frac{11}{6} = 0 \\implies c_0 = -\\frac{11}{6}\n$$\n因此，系数为：$c_0 = -11/6$，$c_1 = 3$，$c_2 = -3/2$ 和 $c_3 = 1/3$。\n\n截断误差的主项由级数展开中下一个非零项决定，即包含 $f^{(4)}(x_0)$ 的项。误差 $E$ 由下式给出：\n$$\nE = \\frac{1}{h} \\left( \\frac{h^4}{24} (c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) \\right) + O(h^4) = \\frac{h^3}{24} (c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) + O(h^4)\n$$\n我们来计算该系数：\n$$\nc_1 + 16c_2 + 81c_3 = 3 + 16\\left(-\\frac{3}{2}\\right) + 81\\left(\\frac{1}{3}\\right) = 3 - 24 + 27 = 6\n$$\n所以，主误差项为 $\\frac{6h^3}{24}f^{(4)}(x_0) = \\frac{h^3}{4}f^{(4)}(x_0)$。误差阶为 $O(h^3)$，符合要求。\n\n现在，我们将系数代回给定的形式，构建最终的近似公式：\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left( -\\frac{11}{6} f(x_0) + 3 f(x_0+h) - \\frac{3}{2} f(x_0+2h) + \\frac{1}{3} f(x_0+3h) \\right)\n$$\n为了将其表示为单一的有理组合，我们找到系数的公分母，即 $6$。\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left( \\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6} \\right)\n$$\n这给出了近似的最终封闭形式表达式：\n$$\nf'(x_0) \\approx \\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6h}\n$$\n该表达式代表了在 $x_0$ 处一阶导数的三阶精度单边有限差分近似。",
            "answer": "$$\n\\boxed{\\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6h}}\n$$"
        },
        {
            "introduction": "在推导出差分格式后，理解其在实际计算中的行为至关重要。本练习将指导您进行一次网格加密研究，以验证一个方法的理论收敛阶，并观察截断误差与舍入误差之间的相互作用。您将看到，随着步长 $h$ 的减小，数值解的精度并非无限提高，而是会受到浮点数舍入误差的限制。",
            "id": "3307315",
            "problem": "考虑空间微分在计算电磁学中的作用，特别是在麦克斯韦方程组的有限差分离散化中。在时域有限差分（FDTD）等方法中，空间导数在网格上通过有限差分进行近似，电磁场更新方程的精度和稳定性取决于导数算子的离散化方式以及步长。为了在受控的环境中研究这些数值特性，我们将重点使用对称模板来近似一个光滑标量函数的导数。\n\n从一个足够光滑的函数 $f$ 在点 $x$ 附近的泰勒展开出发，推导出一个关于导数 $f'(x)$ 的对称两点模板近似。该近似通过在必要的最低阶截断泰勒级数以消除 $h$ 的奇数阶项而得到，并实现了关于 $h$ 的二阶相容性。在您的程序中，将该近似用于特定函数 $f(x) = \\cos x$ 在点 $x = 1$ 处的情况，角度以弧度为单位。\n\n将步长为 $h$ 时的绝对误差定义为 $E(h) = \\left|D(h) - f'(1)\\right|$，其中 $D(h)$ 是使用对称模板得到的 $f'(1)$ 的数值近似，而 $f'(1)$ 是在 $x = 1$ 处的精确导数。使用一个递减步长序列 $(h_i)$，将连续步长之间的观测阶定义为\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}.\n$$\n在网格加密研究中，当截断误差占主导时，理论上的二阶行为意味着 $p_i \\approx 2$。对于足够小的 $h$，$f(x+h) - f(x-h)$ 中的相减抵消以及浮点舍入（以机器精度为特征）可能导致与这种理想行为的偏差。您的解答必须根据截断误差和舍入误差来解释这些偏差的来源。\n\n实现一个程序，对于以下每个 $h$ 的测试序列，计算：\n- $f'(1)$ 的数值近似序列 $D(h_i)$，\n- 绝对误差序列 $E(h_i)$，\n- 连续对 $(h_i, h_{i+1})$ 的观测阶序列 $(p_i)$。\n\n角度必须以弧度为单位。本问题中没有其他物理单位。程序的最终输出应将所有测试序列的观测阶聚合到单行中，该行包含一个列表的列表，其中每个内层列表对应一个测试序列，并包含作为浮点数的 $p_i$ 值。\n\n步长序列测试套件：\n- 情况 A（中等加密）：$[10^{-1},\\, 5 \\cdot 10^{-2},\\, 2.5 \\cdot 10^{-2},\\, 1.25 \\cdot 10^{-2}]$。\n- 情况 B（从粗到中等加密）：$[5 \\cdot 10^{-1},\\, 2.5 \\cdot 10^{-1},\\, 1.25 \\cdot 10^{-1},\\, 6.25 \\cdot 10^{-2}]$。\n- 情况 C（接近平衡截断误差和舍入误差的预期最优 $h$）：$[10^{-5},\\, 5 \\cdot 10^{-6},\\, 2.5 \\cdot 10^{-6},\\, 1.25 \\cdot 10^{-6}]$。\n- 情况 D（舍入误差占主导的极小步长）：$[10^{-8},\\, 5 \\cdot 10^{-9},\\, 2.5 \\cdot 10^{-9},\\, 1.25 \\cdot 10^{-9}]$。\n- 情况 E（非均匀比率以测试通用性）：$[10^{-3},\\, 7.5 \\cdot 10^{-4},\\, 3 \\cdot 10^{-4},\\, 10^{-4},\\, 7.5 \\cdot 10^{-5}]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素是对应情况的内层观测阶列表（例如，$[[p_{A,1},p_{A,2},p_{A,3}],[p_{B,1},\\dots],\\dots]$）。",
            "solution": "该问题要求推导一阶导数的二阶精确有限差分近似，分析其数值误差特性，并实现一个程序来计算特定函数和几组步长下的收敛观测阶。\n\n**1. 对称有限差分模板的推导**\n\n为了推导一阶导数 $f'(x)$ 的对称两点模板，我们从一个足够光滑的函数 $f(x)$ 在点 $x$ 附近对点 $x+h$ 和 $x-h$ 的泰勒级数展开开始，其中 $h > 0$ 是步长。\n\n$f(x+h)$ 关于 $x$ 的泰勒展开为：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2!}f''(x) + \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) + \\dots\n$$\n\n$f(x-h)$ 关于 $x$ 的泰勒展开为：\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2!}f''(x) - \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) - \\dots\n$$\n\n为了分离一阶导数项 $f'(x)$，我们将第二个展开式从第一个中减去。这可以方便地消去所有 $h$ 的偶次幂项：\n$$\nf(x+h) - f(x-h) = (f(x) - f(x)) + (h - (-h))f'(x) + \\left(\\frac{h^2}{2} - \\frac{h^2}{2}\\right)f''(x) + \\left(\\frac{h^3}{6} - \\left(-\\frac{h^3}{6}\\right)\\right)f'''(x) + \\dots\n$$\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{6}f'''(x) + O(h^5)\n$$\n其中 $O(h^5)$ 代表 $h^5$ 阶及更高阶的项。\n\n重新整理此方程以求解 $f'(x)$ 可得：\n$$\nf'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{6}f'''(x) - O(h^4)\n$$\n\n由此，我们通过截断级数来定义 $f'(x)$ 的数值近似 $D(h)$：\n$$\nD(h) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n这就是所要求的对称两点模板，通常称为中心差分公式。\n\n此近似的误差，称为截断误差 $E_t(h)$，是精确导数与其近似值之间的差：\n$$\nE_t(h) = f'(x) - D(h) = -\\frac{h^2}{6}f'''(x) - O(h^4)\n$$\n由于误差的主导项与 $h^2$ 成正比，因此该方法是二阶精确的（或具有二阶相容性）。\n\n**2. 数值误差来源分析**\n\n在浮点计算中，总绝对误差 $E(h) = |D(h) - f'(x)|$ 是两个主要来源的组合：截断误差和舍入误差。\n\n**截断误差**：如上所推导，截断误差是由于用有限过程（模板）近似无限过程（泰勒级数）而产生的。对于较小的 $h$，该误差由其主导项决定：\n$$\nE_t(h) \\approx \\left|-\\frac{h^2}{6}f'''(x)\\right| = C_t h^2\n$$\n其中 $C_t = |f'''(x)|/6$。随着 $h$ 的减小，该误差呈二次方递减。对于指定的函数 $f(x) = \\cos x$，我们有 $f'(x) = -\\sin x$，$f''(x) = -\\cos x$，以及 $f'''(x) = \\sin x$。在 $x=1$ 处，常数是 $C_t = \\sin(1)/6 \\approx 0.140$。\n\n**舍入误差**：舍入误差的产生是因为数字计算机使用有限精度表示实数。当 $h$ 非常小时，$f(x+h)$ 和 $f(x-h)$ 的值变得非常接近。此时，相减操作 $f(x+h) - f(x-h)$ 会遭受**相减抵消**，导致有效数字的损失。设 $\\epsilon_{mach}$ 为机器ε（浮点运算中因舍入引起的相对误差的上限）。计算分子 $f(x+h) - f(x-h)$ 的误差大致与 $|f(x)|\\epsilon_{mach}$ 成正比。这个误差随后被除以一个小数 $2h$ 而放大。因此，舍入误差 $E_r(h)$ 可以建模为：\n$$\nE_r(h) \\approx \\frac{C_r}{h}\n$$\n其中常数 $C_r$ 的数量级约为 $|f(x)|\\epsilon_{mach}$。该误差随着 $h$ 的减小而增大。\n\n**总误差与最优步长**：总误差是这两个分量的和：\n$$\nE(h) \\approx C_t h^2 + \\frac{C_r}{h}\n$$\n对于较大的 $h$，$C_t h^2$ 项占主导。对于非常小的 $h$，$C_r/h$ 项占主导。存在一个最优步长 $h_{opt}$ 使总误差最小化，可通过将 $E(h)$ 对 $h$ 的导数设为零来找到：\n$$\n\\frac{dE}{dh} = 2C_t h - \\frac{C_r}{h^2} = 0 \\implies h_{opt} = \\left(\\frac{C_r}{2C_t}\\right)^{1/3}\n$$\n对于双精度浮点运算，$\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$。对于函数 $f(x)=\\cos x$ 在 $x=1$ 处，$h_{opt}$ 的数量级在 $10^{-5}$ 到 $10^{-6}$ 之间。\n\n**3. 收敛的观测阶**\n\n两个连续步长 $h_i$ 和 $h_{i+1}$ 之间的收敛观测阶 $p_i$ 按如下方式计算：\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}\n$$\n该公式是基于误差行为符合 $E(h) \\approx C h^p$ 的假设推导出来的。如果这个假设成立，则 $E(h_i)/E(h_{i+1}) \\approx (h_i/h_{i+1})^p$，两边取对数即可解出 $p$。\n\n对于这些测试用例，$p_i$ 的预期行为如下：\n- **情况 A、B 和 E**：步长 $h_i$ 处于截断误差占主导的区域 ($E(h) \\propto h^2$)。因此，我们预期观测阶 $p_i$ 约等于 $2$。\n- **情况 C**：步长接近 $h_{opt}$。在此区域，截断误差和舍入误差都很显著。误差不遵循简单的幂律，因此 $p_i$ 将偏离 $2$，并可能减小。\n- **情况 D**：步长非常小，处于舍入误差占主导的深层区域。误差预计会随着 $h$ 的减小而增大，大约为 $E(h) \\propto 1/h$。在这种情况下，$E(h_i)/E(h_{i+1}) \\approx (1/h_i)/(1/h_{i+1}) = h_{i+1}/h_i$。$p_i$ 的公式得出 $p_i \\approx \\log(h_{i+1}/h_i) / \\log(h_i/h_{i+1}) = -1$。由于浮点运算的随机性，观测值可能会混乱，但通常应为负数或接近于零，表明收敛性被破坏。\n接下来的实现将根据指定的测试用例计算这些值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a central difference approximation for f'(x) to study\n    numerical error behavior. The function computes numerical derivatives, errors,\n    and observed orders of convergence for several sequences of step sizes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderate refinement)\n        [1e-1, 5e-2, 2.5e-2, 1.25e-2],\n        # Case B (coarse-to-moderate refinement)\n        [5e-1, 2.5e-1, 1.25e-1, 6.25e-2],\n        # Case C (near the expected optimal h)\n        [1e-5, 5e-6, 2.5e-6, 1.25e-6],\n        # Case D (extremely small steps where round-off dominates)\n        [1e-8, 5e-9, 2.5e-9, 1.25e-9],\n        # Case E (non-uniform ratios to test generality)\n        [1e-3, 7.5e-4, 3e-4, 1e-4, 7.5e-5],\n    ]\n\n    # The point at which to evaluate the derivative\n    x = 1.0\n    \n    # The function f(x) = cos(x)\n    f = np.cos\n    \n    # The exact derivative f'(x) = -sin(x) at x=1\n    f_prime_exact = -np.sin(x)\n\n    all_p_results = []\n\n    for h_sequence in test_cases:\n        errors = []\n        for h in h_sequence:\n            # Symmetric, two-point stencil (central difference) approximation\n            # D(h) = (f(x+h) - f(x-h)) / (2*h)\n            d_approx = (f(x + h) - f(x - h)) / (2.0 * h)\n            \n            # Absolute error E(h) = |D(h) - f'(x)|\n            error = np.abs(d_approx - f_prime_exact)\n            errors.append(error)\n\n        p_values = []\n        # Calculate observed order p_i for successive pairs (h_i, h_{i+1})\n        for i in range(len(h_sequence) - 1):\n            h_i = h_sequence[i]\n            h_i_plus_1 = h_sequence[i+1]\n            \n            error_i = errors[i]\n            error_i_plus_1 = errors[i+1]\n            \n            # Formula for observed order: p_i = log(E_i/E_{i+1}) / log(h_i/h_{i+1})\n            # Handle cases where error might be zero to avoid log(0)\n            if error_i_plus_1 == 0.0 or error_i == 0.0:\n                # If the error becomes zero, the order is theoretically infinite.\n                # In practice with floating point, this suggests perfect cancellation or\n                # reaching the limits of precision.\n                p = np.inf\n            else:\n                log_error_ratio = np.log(error_i / error_i_plus_1)\n                log_h_ratio = np.log(h_i / h_i_plus_1)\n                p = log_error_ratio / log_h_ratio\n            \n            p_values.append(p)\n        \n        all_p_results.append(p_values)\n\n    # Format the final output string exactly as required: [[...],[...],...]\n    # without extraneous spaces.\n    outer_list_str = []\n    for p_list in all_p_results:\n        inner_list_str = \"[\" + \",\".join(map(str, p_list)) + \"]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(outer_list_str) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "为了在不扩大模板（stencil）宽度的前提下获得更高的精度，我们可以使用隐式或“紧致”差分格式。本练习介绍了一种四阶紧致格式，它的求解需要解一个线性方程组。通过这个实践，您将体验到算法复杂性与计算精度之间的权衡，并学习如何高效求解周期性边界条件下产生的特殊循环三对角系统。",
            "id": "3307323",
            "problem": "考虑在一维周期性网格上计算空间导数 $\\partial_x E_y$ 的任务，这在计算电磁学中离散化麦克斯韦方程组的旋度算子时会出现。在区间 $[0,2\\pi)$ 上使用一个包含 $N$ 个点的均匀周期性网格，网格间距为 $\\Delta x = 2\\pi/N$，节点位置为 $x_i = i \\,\\Delta x$，$i = 0,1,\\dots,N-1$。角度必须以弧度处理。从导数的定义和围绕网格点的泰勒级数展开出发，推导一个用于计算 $\\partial_x E_y$ 的三点四阶紧致有限差分格式，该格式具有以下特征：\n\n- 节点 $i$ 处的近似使用一个线性系统，该系统通过左侧的对称最近邻模板耦合离散导数 $\\{(\\partial_x E_y)_j\\}$，并在右侧对函数值 $\\{E_y(x_j)\\}$ 使用最近邻反对称模板。\n- 该格式对于光滑周期函数 $E_y(x)$ 必须是四阶精度的，即局部截断误差为 $O(\\Delta x^4)$。\n- 由于周期性边界条件，得到的离散导数向量的全局线性系统必须是循环三对角的。\n\n根据这些要求：\n\n1. 确定能使三点紧致格式在满足上述约束条件下达到四阶精度的唯一系数（如果存在）。通过仅使用导数的基本定义以及 $E_y(x)$ 及其导数在相邻节点处的泰勒展开来匹配泰勒级数系数，从而推导这些系数。\n\n2. 明确写出为获得离散导数向量 $\\mathbf{d} \\in \\mathbb{R}^N$（其中 $d_i \\approx (\\partial_x E_y)(x_i)$）而必须求解的线性系统，并强调系统矩阵的循环三对角结构。概述一个利用此结构且不使用稠密线性代数的高效求解器的原理。你的概述必须基于可逆矩阵低秩更新的基本线性代数恒等式。\n\n3. 将该方法实现为一个程序，该程序：\n   - 构建具有指定 $N$ 的周期性网格 $x_i$，并使用 $\\Delta x = 2\\pi/N$。\n   - 对下面列出的每个测试函数 $E_y(x)$，组装相应的右端项，并求解循环三对角线性系统，以获得 $\\partial_x E_y$ 的紧致四阶近似。\n   - 将数值结果与每个网格点上的精确导数进行比较，并返回每个测试用例在整个网格上的最大绝对误差。\n\n仅使用纯数学单位（不需要物理单位），角度必须以弧度为单位。最终输出必须将所有测试用例的结果汇总为一行，即一个用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的最大绝对误差，以浮点数形式打印。您必须将每个条目四舍五入到 $12$ 位有效数字的科学记数法。\n\n测试套件（每个案例必须独立评估并按给定顺序进行）：\n\n- 案例 1 (光滑，中等波数)：$N = 64$，$E_y(x) = \\sin(3 x)$，精确导数 $\\partial_x E_y = 3 \\cos(3 x)$。\n- 案例 2 (恒定场)：$N = 32$，$E_y(x) = 5$，精确导数 $\\partial_x E_y = 0$。\n- 案例 3 (接近奈奎斯特频率的高频)：$N = 128$，令 $k = N/2 - 1 = 63$，$E_y(x) = \\sin(k x)$，精确导数 $\\partial_x E_y = k \\cos(k x)$。\n- 案例 4 (非多项式光滑函数)：$N = 100$，$E_y(x) = \\exp(\\sin x)$，精确导数 $\\partial_x E_y = \\cos x \\,\\exp(\\sin x)$。\n- 案例 5 (极小网格)：$N = 4$，$E_y(x) = \\sin x$，精确导数 $\\partial_x E_y = \\cos x$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其顺序与测试用例相同（例如，\"[v1,v2,v3,v4,v5]\"）。每个值都必须是科学记数法表示的浮点数，并四舍五入到 $12$ 位有效数字。\n\n程序不应从用户读取任何输入，也不应使用任何外部文件。实现应以通用方式表达，使其适用于任何 $N \\ge 4$ 和任何遵循指定模板的光滑周期函数 $E_y(x)$，但它应仅计算并打印上述测试套件的结果。",
            "solution": "该问题要求对一维周期性网格上的一阶导数，推导、分析并实现一个三点四阶紧致有限差分格式。验证过程确认了该问题具有科学依据、是适定的、客观的，并包含足够信息以获得唯一解。这是偏微分方程数值分析中的一个标准问题。\n\n**第1部分：紧致格式系数的推导**\n\n我们的任务是在一个间距为 $\\Delta x = 2\\pi/N$ 的均匀周期性网格上，为网格点 $x_i = i \\Delta x$（$i = 0, 1, \\dots, N-1$）处的导数 $\\partial_x E_y$ 寻找一个有限差分近似。设 $d_i$ 为 $E_y'(x_i) \\equiv (\\partial_x E_y)(x_i)$ 的数值近似，并用 $E_{y,i}$ 表示 $E_y(x_i)$。\n\n问题指定了紧致格式的形式。在每个节点 $i$，$d_j$ 的离散导数通过一个对称的最近邻模板耦合，而函数值 $\\{E_{y,j}\\}$ 通过一个最近邻的反对称模板耦合。这种结构可以表示为：\n$$\n\\alpha d_{i-1} + \\beta d_i + \\alpha d_{i+1} = \\frac{1}{\\Delta x} \\left( c E_{y,i+1} - c E_{y,i-1} \\right)\n$$\n其中 $\\alpha$、$\\beta$ 和 $c$ 是待确定的未知系数。左侧（LHS）的对称性要求 $d_{i-1}$ 和 $d_{i+1}$ 的系数相同。右侧（RHS）的反对称性给出了 $E_{y,i+1} - E_{y,i-1}$ 的形式。不失一般性，我们可以将 $d_i$ 的系数归一化为 $\\beta=1$。RHS 上的因子 $1/\\Delta x$ 是一阶导数近似的常规做法。为了代数上的方便，我们还将 RHS 系数重新缩放为 $a/2$，以匹配标准中心差分的形式。格式变为：\n$$\n\\alpha d_{i-1} + d_i + \\alpha d_{i+1} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n为了找到能产生四阶精度的系数 $\\alpha$ 和 $a$，我们将所有项替换为它们在点 $x_i$ 附近的泰勒级数展开。我们将 $E_y(x)$ 在 $x_i$ 处的精确导数记为 $E_y'$、$E_y''$ 等。在进行此误差分析时，假设数值导数 $d_j$ 等于精确导数 $E_y'(x_j)$。\n\n$E_y(x)$ 在相邻点 $x_{i\\pm1} = x_i \\pm \\Delta x$ 处的泰勒级数为：\n$$\nE_{y,i\\pm1} = E_y \\pm \\Delta x E_y' + \\frac{(\\Delta x)^2}{2!} E_y'' \\pm \\frac{(\\Delta x)^3}{3!} E_y''' + \\frac{(\\Delta x)^4}{4!} E_y^{(4)} \\pm \\frac{(\\Delta x)^5}{5!} E_y^{(5)} + O((\\Delta x)^6)\n$$\n导数 $E_y'(x)$ 在相邻点处的泰勒级数为：\n$$\nd_{i\\pm1} \\approx E_y'(x_{i\\pm1}) = E_y' \\pm \\Delta x E_y'' + \\frac{(\\Delta x)^2}{2!} E_y''' \\pm \\frac{(\\Delta x)^3}{3!} E_y^{(4)} + \\frac{(\\Delta x)^4}{4!} E_y^{(5)} + O((\\Delta x)^5)\n$$\n\n首先，我们展开格式的右侧（RHS）：\n$$\n\\text{RHS} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{a}{2\\Delta x} \\left( 2\\Delta x E_y' + 2\\frac{(\\Delta x)^3}{6} E_y''' + 2\\frac{(\\Delta x)^5}{120} E_y^{(5)} + O((\\Delta x)^7) \\right)\n$$\n$$\n\\text{RHS} = a E_y' + \\frac{a(\\Delta x)^2}{6} E_y''' + \\frac{a(\\Delta x)^4}{120} E_y^{(5)} + O((\\Delta x)^6)\n$$\n\n接下来，我们展开格式的左侧（LHS）：\n$$\n\\text{LHS} = \\alpha (d_{i-1} + d_{i+1}) + d_i \\approx \\alpha (E_y'(x_{i-1}) + E_y'(x_{i+1})) + E_y'(x_i)\n$$\n$$\n\\text{LHS} \\approx \\alpha \\left( 2E_y' + 2\\frac{(\\Delta x)^2}{2} E_y''' + 2\\frac{(\\Delta x)^4}{24} E_y^{(5)} + O((\\Delta x)^6) \\right) + E_y'\n$$\n$$\n\\text{LHS} \\approx (1+2\\alpha)E_y' + \\alpha(\\Delta x)^2 E_y''' + \\frac{\\alpha(\\Delta x)^4}{12} E_y^{(5)} + O((\\Delta x)^6)\n$$\n\n为了使格式精确，表达式 LHS - RHS 必须尽可能接近于零。我们令等式两边 $E_y$ 各阶导数的系数相等。\n\\begin{itemize}\n    \\item $E_y'$ 的系数：$1+2\\alpha = a$\n    \\item $E_y''$ 的系数：由于对称性，$E_y$ 的奇数阶导数项消失了，这是该中心格式的一个关键特性。\n    \\item $E_y'''$ 的系数：为达到高于二阶的精度，$(\\Delta x)^2$ 项必须抵消。\n    $$ \\alpha(\\Delta x)^2 = \\frac{a(\\Delta x)^2}{6} \\implies \\alpha = \\frac{a}{6} $$\n\\end{itemize}\n\n现在我们得到了一个关于两个未知数 $\\alpha$ 和 $a$ 的二元线性方程组：\n1. $a = 1 + 2\\alpha$\n2. $a = 6\\alpha$\n\n将 (2) 代入 (1) 得到 $6\\alpha = 1 + 2\\alpha$，解得 $4\\alpha = 1$，所以 $\\alpha = 1/4$。\n将 $\\alpha=1/4$ 代回 (2) 得到 $a = 6(1/4) = 3/2$。\n\n唯一的系数是 $\\alpha = 1/4$ 和 $a = 3/2$。该格式为：\n$$\n\\frac{1}{4} d_{i-1} + d_i + \\frac{1}{4} d_{i+1} = \\frac{3/2}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n局部截断误差 (LTE) 由展开式中的第一个非零项决定。我们比较 $(\\Delta x)^4$ 项的系数：\n$$\n\\text{LTE} \\propto \\left( \\frac{\\alpha(\\Delta x)^4}{12} - \\frac{a(\\Delta x)^4}{120} \\right) E_y^{(5)} = \\left( \\frac{1/4}{12} - \\frac{3/2}{120} \\right) (\\Delta x)^4 E_y^{(5)}\n$$\n$$\n= \\left( \\frac{1}{48} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\left( \\frac{5}{240} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\frac{2}{240} (\\Delta x)^4 E_y^{(5)} = \\frac{1}{120} (\\Delta x)^4 E_y^{(5)}\n$$\n误差与 $(\\Delta x)^4$ 成正比，证实了该格式是四阶精度的。截断误差的正式定义是当精确解代入归一化差分算子时产生的残差。除以归一化因子 $1+2\\alpha = 3/2$ 后，误差为 $T_i = -\\frac{1}{180}(\\Delta x)^4 E_y^{(5)}(x_i) + O((\\Delta x)^6)$。\n\n**第2部分：线性系统与高效求解器**\n\n该格式必须应用于从 $i=0$ 到 $i=N-1$ 的所有 $N$ 个网格点。这将为 $N$ 个未知导数 $d_0, d_1, \\dots, d_{N-1}$ 生成一个包含 $N$ 个线性方程的系统。设 $\\mathbf{d} = [d_0, d_1, \\dots, d_{N-1}]^T$ 为离散导数向量。该系统可以写成矩阵形式 $A \\mathbf{d} = \\mathbf{b}$，其中 $A$ 是系数矩阵，$\\mathbf{b}$ 是右端向量。\n\n对于一个一般内部点 $i$，方程为：\n$$\n(\\frac{1}{4}) d_{i-1} + (1) d_i + (\\frac{1}{4}) d_{i+1} = b_i\n$$\n其中 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$。\n\n由于周期性边界条件，下标需对 $N$ 取模。对于 $i=0$，$d_{i-1}=d_{-1}$ 变为 $d_{N-1}$。对于 $i=N-1$，$d_{i+1}=d_N$ 变为 $d_0$。这种“环绕”特性赋予矩阵 $A$ 其特有的结构：\n$$\nA = \\begin{pmatrix}\n1  & 1/4  & 0  & \\dots  & 0  & 1/4 \\\\\n1/4  & 1  & 1/4  & \\dots  & 0  & 0 \\\\\n0  & 1/4  & 1  & \\dots  & 0  & 0 \\\\\n\\vdots  & \\vdots  & \\ddots  & \\ddots  & \\ddots  & \\vdots \\\\\n0  & 0  & 0  & \\dots  & 1  & 1/4 \\\\\n1/4  & 0  & 0  & \\dots  & 1/4  & 1\n\\end{pmatrix}\n$$\n这是一个对称、三对角、循环矩阵。右端向量 $\\mathbf{b}$ 的分量为 $b_i = \\frac{3}{4\\Delta x} (E_{y,(i+1)\\%N} - E_{y,(i-1+N)\\%N})$。\n\n一个高效的求解器必须利用这种循环结构。\n一种复杂度为 $O(N \\log N)$ 的高效方法是基于离散傅里叶变换（DFT），因为循环矩阵可以被 DFT 对角化。\n1.  设 $\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$ 为 $A$ 的第一行。卷积定理指出，对于一个循环矩阵 $A$，矩阵向量乘积 $A\\mathbf{d}$ 等价于 $\\mathbf{c}$ 和 $\\mathbf{d}$ 的循环卷积。\n2.  对系统 $A\\mathbf{d} = \\mathbf{b}$ 应用 DFT（记为 $\\mathcal{F}$），得到 $\\mathcal{F}(A\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$。\n3.  这就变成了 $\\mathcal{F}(\\mathbf{c}) \\odot \\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$，其中 $\\odot$ 表示逐元素相乘。向量 $\\mathbf{\\Lambda} = \\mathcal{F}(\\mathbf{c})$ 包含 $A$ 的特征值。\n4.  该系统通过在频域中进行逐元素相除来求解：$\\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda}$。\n5.  通过应用逆 DFT 来恢复解向量 $\\mathbf{d}$：$\\mathbf{d} = \\mathcal{F}^{-1}(\\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda})$。使用快速傅里叶变换（FFT）算法进行 DFT 及其逆变换使得该方法非常快。$A$ 的特征值为 $\\lambda_j = 1 + (1/4)e^{i 2\\pi j/N} + (1/4)e^{-i 2\\pi j/N} = 1 + (1/2)\\cos(2\\pi j/N)$，$j=0, \\dots, N-1$。由于 $|\\cos(\\theta)| \\le 1$，所有特征值均为正，确保了矩阵是非奇异的。\n\n另一种复杂度为 $O(N)$ 的高效方法，即提示中提到的“低秩更新”，是使用 Sherman-Morrison-Woodbury 公式。矩阵 $A$ 可以写成一个简单的三对角矩阵 $T$ 加上一个针对角落元素的秩-2 校正 $U V^T$：$A = T + \\alpha(\\mathbf{e}_0 \\mathbf{e}_{N-1}^T + \\mathbf{e}_{N-1} \\mathbf{e}_0^T)$，其中 $\\alpha=1/4$。然后，可以通过求解几个三对角系统（使用复杂度为 $O(N)$ 的 Thomas 算法）和一个小的 $2 \\times 2$ 系统来找到 $A\\mathbf{d} = \\mathbf{b}$ 的解。\n\n**第3部分：实现策略**\n\n实现将遵循基于 FFT 的方法，`scipy.linalg.solve_circulant` 方便地提供了该功能。\n对于每个指定的测试用例：\n1.  设置网格大小 $N$ 并定义函数 $E_y(x)$ 及其解析导数。\n2.  构建网格 $x_i = i (2\\pi/N)$，$i=0, \\dots, N-1$。\n3.  在网格上计算函数值以创建向量 $\\mathbf{E}_y$。\n4.  使用公式 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$ 构建右端向量 $\\mathbf{b}$。周期性索引可以使用 `numpy.roll` 高效处理。\n5.  定义循环矩阵 $A$ 的第一行：$\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$。\n6.  使用 `scipy.linalg.solve_circulant(c, b)` 求解线性系统 $A\\mathbf{d} = \\mathbf{b}$ 以得到 $\\mathbf{d}$。\n7.  在网格上计算精确导数以得到向量 $\\mathbf{d}_{\\text{exact}}$。\n8.  计算整个网格上的最大绝对误差：$\\max(|\\mathbf{d} - \\mathbf{d}_{\\text{exact}}|)$。\n9.  收集所有测试用例的误差，并将其格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Derives and implements a fourth-order compact finite difference scheme\n    to compute the first derivative of periodic functions.\n    \"\"\"\n\n    def compact_fourth_order_derivative(Ey_values, N):\n        \"\"\"\n        Computes the derivative using the 4th-order compact scheme.\n\n        Args:\n            Ey_values (np.ndarray): The function values E_y(x_i) on the grid.\n            N (int): The number of grid points.\n\n        Returns:\n            np.ndarray: The numerical derivative d_i at each grid point.\n        \"\"\"\n        # Grid spacing\n        delta_x = 2.0 * np.pi / N\n\n        # Coefficients of the scheme derived from Taylor series analysis.\n        # Scheme: (1/4)d_{i-1} + d_i + (1/4)d_{i+1} = (3/4 * delta_x) * (E_{y,i+1} - E_{y,i-1})\n        alpha = 1.0 / 4.0\n        a = 3.0 / 2.0\n\n        # Construct the right-hand side (RHS) vector b.\n        # np.roll handles the periodic boundary conditions efficiently.\n        Ey_plus_1 = np.roll(Ey_values, -1)\n        Ey_minus_1 = np.roll(Ey_values, 1)\n        \n        rhs_b = (a / (2.0 * delta_x)) * (Ey_plus_1 - Ey_minus_1)\n\n        # Construct the first row of the circulant-cyclic tridiagonal matrix A.\n        # A has 1 on the main diagonal, and alpha on the sub- and super-diagonals,\n        # with cyclic wrap-around.\n        circulant_first_row = np.zeros(N)\n        circulant_first_row[0] = 1.0\n        circulant_first_row[1] = alpha\n        circulant_first_row[N - 1] = alpha  # or circulant_first_row[-1]\n\n        # Solve the linear system A*d = b using the efficient circulant solver,\n        # which is based on FFTs.\n        d_numerical = solve_circulant(circulant_first_row, rhs_b)\n\n        return d_numerical\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64,\n            \"Ey_func\": lambda x: np.sin(3 * x),\n            \"dEy_exact_func\": lambda x: 3 * np.cos(3 * x),\n        },\n        {\n            \"N\": 32,\n            \"Ey_func\": lambda x: np.full_like(x, 5.0),\n            \"dEy_exact_func\": lambda x: np.zeros_like(x),\n        },\n        {\n            \"N\": 128,\n            \"k\": 63, # k = N/2 - 1\n            \"Ey_func\": lambda x, k=63: np.sin(k * x),\n            \"dEy_exact_func\": lambda x, k=63: k * np.cos(k * x),\n        },\n        {\n            \"N\": 100,\n            \"Ey_func\": lambda x: np.exp(np.sin(x)),\n            \"dEy_exact_func\": lambda x: np.cos(x) * np.exp(np.sin(x)),\n        },\n        {\n            \"N\": 4,\n            \"Ey_func\": lambda x: np.sin(x),\n            \"dEy_exact_func\": lambda x: np.cos(x),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Create the periodic grid\n        x_grid = np.arange(N) * (2.0 * np.pi / N)\n\n        # Evaluate the function and its exact derivative on the grid\n        Ey_values = case[\"Ey_func\"](x_grid)\n        dEy_exact = case[\"dEy_exact_func\"](x_grid)\n        \n        # Compute the numerical derivative\n        dEy_numerical = compact_fourth_order_derivative(Ey_values, N)\n        \n        # Calculate the maximum absolute error\n        max_abs_error = np.max(np.abs(dEy_numerical - dEy_exact))\n        \n        results.append(max_abs_error)\n\n    # Format output as a comma-separated list of values in scientific notation\n    # with 12 significant digits.\n    formatted_results = [f\"{res:.11e}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}