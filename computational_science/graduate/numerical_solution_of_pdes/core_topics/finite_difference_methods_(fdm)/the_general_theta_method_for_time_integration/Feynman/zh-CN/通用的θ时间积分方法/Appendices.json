{
    "hands_on_practices": [
        {
            "introduction": "检验数值积分器最基本的方法是将其应用于具有已知精确解的标量线性测试问题 $y' = \\lambda y$。这个练习将引导你通过经验性地测量方法的准确度阶数并验证其稳定性，来确认理论与实践相符。这是在将代码应用于更复杂问题之前，建立对其信任的关键第一步 。",
            "id": "3455040",
            "problem": "设计并实现一个验证程序，用于验证应用于标量线性测试问题 $y' = \\lambda y$ 的通用$\\theta$方法。其目的是确认给定实现的观测精度阶和线性稳定性行为。该验证必须基于第一性原理，并且除了下述核心定义外，不得依赖任何预先给定的特定公式。\n\n从以下基本依据出发：\n- 常微分方程初值问题的定义：给定 $y' = f(t,y)$ 和 $y(0) = y_0$，在时间 $t$ 的精确解记为 $y(t)$。\n- 用于时间积分的通用单步$\\theta$方法，使用参数 $\\theta \\in [0,1]$，通过一个时间步内起始点和终点处右端项的凸组合，从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$。\n- 标量线性测试问题 $y' = \\lambda y$（其中常数 $\\lambda \\in \\mathbb{C}$）的精确解为 $y(t) = y_0 \\exp(\\lambda t)$。\n\n您的任务：\n1) 从$\\theta$方法的定义出发，推导其应用于标量线性测试问题 $y'=\\lambda y$ 时的更新规则，求解出以 $y_n$、时间步长 $h$ 和 $\\theta$ 表示的 $y_{n+1}$。根据该推导，确定作为 $z = h \\lambda$ 函数的单步放大因子。\n2) 使用泰勒级数和局部截断误差的定义，确定$\\theta$方法的形式精度阶（作为 $\\theta$ 的函数）。解释为什么对于足够光滑的解且在线性稳定区域内，当 $\\theta \\neq \\tfrac{1}{2}$ 时预期为一阶方法，而当 $\\theta = \\tfrac{1}{2}$ 时预期为二阶方法。\n3) 通过数值实验定义并计算经验观测精度阶，方法如下。对于固定的最终时间 $T$、初始条件 $y_0$ 和参数集 $(\\theta,\\lambda)$，设 $N = T/h$ 为整数，经过 $N$ 步后的数值解为 $y_N$。定义全局误差 $E(h) = |y_N - y(T)|$。给定三个步长 $h_1  h_2  h_3$，定义两两间的观测阶\n$$\np_{12} = \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)}, \\quad p_{23} = \\frac{\\log(E(h_2)/E(h_3))}{\\log(h_2/h_3)},\n$$\n并将平均值 $\\tfrac{1}{2}(p_{12}+p_{23})$ 作为该参数集的观测阶进行报告。所有对数均为自然对数。\n4) 根据单步放大因子的模长小于或等于 $1$ 的准则，为给定的 $(\\theta,\\lambda,h)$ 定义并计算线性稳定性。\n5) 精确地（无需迭代）实现用于标量线性问题的$\\theta$方法，并使用精确解 $y(t) = y_0 \\exp(\\lambda t)$ 在以下测试套件上验证观测阶和稳定性准则。对于所有测试，取 $y_0 = 1$。\n\n观测精度阶测试（使用 $T = 1$ 和三个步长 $h_1 = 1/20$、$h_2 = 1/40$、$h_3 = 1/80$；报告每个观测阶，结果四舍五入到三位小数）：\n- 测试 $\\mathbf{A_1}$: $\\theta = 0$, $\\lambda = -1$。\n- 测试 $\\mathbf{A_2}$: $\\theta = 1/2$, $\\lambda = -1$。\n- 测试 $\\mathbf{A_3}$: $\\theta = 1$, $\\lambda = -1$。\n\n稳定性测试（使用线性放大因子准则 $|R(z)| \\le 1$ 报告一个布尔值，其中 $z = h \\lambda$）：\n- 测试 $\\mathbf{S_1}$: $\\theta = 0$, $\\lambda = -1$, $h = 1$。\n- 测试 $\\mathbf{S_2}$: $\\theta = 0$, $\\lambda = -1$, $h = 3$。\n- 测试 $\\mathbf{S_3}$: $\\theta = 1/2$, $\\lambda = -1$, $h = 100$。\n- 测试 $\\mathbf{S_4}$: $\\theta = 1$, $\\lambda = -1$, $h = 100$。\n- 测试 $\\mathbf{S_5}$: $\\theta = 1/2$, $\\lambda = \\mathrm{i}\\,10$, $h = 0.1$ 其中 $\\mathrm{i}^2 = -1$。\n- 测试 $\\mathbf{S_6}$: $\\theta = 0$, $\\lambda = \\mathrm{i}\\,10$, $h = 0.1$。\n\n您的程序必须：\n- 精确实现标量问题的$\\theta$方法更新。\n- 使用指定的步长计算三个观测精度阶测试的观测阶，并将每个结果四舍五入到三位小数。\n- 使用放大因子模长准则计算六个稳定性的布尔值。\n- 生成单行输出，包含一个逗号分隔的 Python 列表形式的结果，顺序如下：\n  $[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{S}_5,\\text{S}_6]$,\n  其中 $\\text{A}_k$ 是浮点数（观测阶），四舍五入到三位小数，$\\text{S}_k$ 是布尔值。\n\n此问题不涉及物理单位。当通过复数出现角度时，它们作为复指数的一部分，隐式地以弧度为单位。输出必须是所描述的精确格式的单行文本，不得包含任何额外文本。",
            "solution": "该问题要求针对应用于标量线性测试问题 $y' = \\lambda y$ 的通用$\\theta$方法，进行推导、分析并实现一个验证套件。解决方案分步呈现，首先是必要的理论推导，然后是按规定进行的计算验证。\n\n### 1. 更新规则与放大因子的推导\n\n对于一个常微分方程 $y' = f(t,y)$，通用单步$\\theta$方法定义为使用参数 $\\theta \\in [0,1]$ 从时间 $t_n$ 推进到 $t_{n+1} = t_n + h$ 的过程。其更新规则由时间步起点和终点处函数 $f$ 值的凸组合给出：\n$$\ny_{n+1} = y_n + h \\left[ (1-\\theta) f(t_n, y_n) + \\theta f(t_{n+1}, y_{n+1}) \\right]\n$$\n将此规则应用于标量线性测试问题 $f(t,y) = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$ 是常数），我们代入 $f(t_n, y_n) = \\lambda y_n$ 和 $f(t_{n+1}, y_{n+1}) = \\lambda y_{n+1}$：\n$$\ny_{n+1} = y_n + h \\left[ (1-\\theta) \\lambda y_n + \\theta \\lambda y_{n+1} \\right]\n$$\n如果 $\\theta \\neq 0$，该方程对于 $y_{n+1}$ 是隐式的。我们必须求解 $y_{n+1}$，用 $y_n$ 来表示。重新整理各项，将所有含 $y_{n+1}$ 的项移到左边，所有含 $y_n$ 的项移到右边，得到：\n$$\ny_{n+1} - h \\theta \\lambda y_{n+1} = y_n + h (1-\\theta) \\lambda y_n\n$$\n在左边提出 $y_{n+1}$ 因子，在右边提出 $y_n$ 因子，得到：\n$$\ny_{n+1} (1 - \\theta h \\lambda) = y_n (1 + (1-\\theta) h \\lambda)\n$$\n假设 $1 - \\theta h \\lambda \\neq 0$，我们可以分离出 $y_{n+1}$：\n$$\ny_{n+1} = \\left( \\frac{1 + (1-\\theta) h \\lambda}{1 - \\theta h \\lambda} \\right) y_n\n$$\n单步放大因子，记作 $R(z)$，是数值解在每一步中乘以的因子。它是 $z = h \\lambda$ 的函数。从上式中，我们可以确定 $R(z)$ 为：\n$$\nR(z) = \\frac{y_{n+1}}{y_n} = \\frac{1 + (1-\\theta) z}{1 - \\theta z}\n$$\n这就是所要求的更新规则和放大因子。$N$ 步后的数值解为 $y_N = (R(h\\lambda))^N y_0$。\n\n### 2. 形式精度阶\n\n一个数值方法的形式精度阶由其局部截断误差（LTE）决定。对于测试问题 $y' = \\lambda y$，精确解从 $t$ 到 $t+h$ 的演化为 $y(t+h) = y(t) e^{\\lambda h}$。从精确解 $y(t)$ 出发，数值方法单步计算得到 $y_{t+h} = R(h\\lambda) y(t)$。单步的局部误差是其差值 $T_{h} = y(t+h) - y_{t+h} = y(t) (e^{h\\lambda} - R(h\\lambda))$。\n如果一个方法的局部误差 $T_h$ 是 $O(h^{p+1})$，则该方法是 $p$ 阶的。我们通过比较精确放大因子 $e^z$ 与数值放大因子 $R(z)$ 的泰勒级数展开来分析这一点，其中 $z = h\\lambda$。\n\n$e^z$ 在 $z=0$ 附近的泰勒级数展开为：\n$$\ne^z = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + O(z^4) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + O(z^4)\n$$\n$R(z)$ 的泰勒级数可以通过展开几何级数 $(1-\\theta z)^{-1} = 1 + \\theta z + (\\theta z)^2 + (\\theta z)^3 + \\dots$ 得到：\n$$\n\\begin{align*}\nR(z) = (1 + (1-\\theta)z) (1 + \\theta z + \\theta^2 z^2 + \\dots) \\\\\n= 1 + \\theta z + \\theta^2 z^2 + \\dots + (1-\\theta)z + \\theta(1-\\theta)z^2 + \\dots \\\\\n= 1 + (\\theta + 1 - \\theta)z + (\\theta^2 + \\theta(1-\\theta))z^2 + O(z^3) \\\\\n= 1 + z + \\theta z^2 + O(z^3)\n\\end{align*}\n$$\n精确放大因子和数值放大因子之差为：\n$$\ne^z - R(z) = \\left(1 + z + \\frac{1}{2}z^2 + O(z^3)\\right) - \\left(1 + z + \\theta z^2 + O(z^3)\\right) = \\left(\\frac{1}{2} - \\theta\\right)z^2 + O(z^3)\n$$\n因此，局部误差为 $T_h = y(t) (e^z - R(z)) = y(t)\\left[\\left(\\frac{1}{2} - \\theta\\right)(h\\lambda)^2 + O(h^3)\\right]$。\n\n情况 1: $\\theta \\neq \\frac{1}{2}$\n局部误差的首项与 $h^2$ 成正比。因此，$T_h = O(h^2)$。$O(h^{p+1})$ 的局部误差对应于 $O(h^p)$ 的全局误差。所以，当 $p+1=2$ 时，该方法是一阶精度的 ($p=1$）。\n\n情况 2: $\\theta = \\frac{1}{2}$ (Crank-Nicolson 方法)\n$z^2$ 项的系数 $(\\frac{1}{2} - \\theta)$ 变为零。我们必须考察级数展开中的下一项。\n$$\ne^z = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + O(z^4)\n$$\n$$\nR(z)|_{\\theta=1/2} = \\frac{1+z/2}{1-z/2} = (1+z/2)(1+z/2+(z/2)^2+(z/2)^3+\\dots) = 1+z+\\frac{1}{2}z^2+\\frac{1}{4}z^3+O(z^4)\n$$\n此时的差值为：\n$$\ne^z - R(z) = \\left(1+z+\\frac{1}{2}z^2+\\frac{1}{6}z^3+\\dots\\right) - \\left(1+z+\\frac{1}{2}z^2+\\frac{1}{4}z^3+\\dots\\right) = \\left(\\frac{1}{6}-\\frac{1}{4}\\right)z^3 + O(z^4) = -\\frac{1}{12}z^3 + O(z^4)\n$$\n局部误差为 $T_h = y(t)\\left[-\\frac{1}{12}(h\\lambda)^3 + O(h^4)\\right] = O(h^3)$。当 $p+1=3$ 时，该方法是二阶精度的 ($p=2$）。\n\n### 3. 经验观测精度阶\n\n给定一个固定的最终时间 $T$，全局误差 $E(h)$ 是经过 $N=T/h$ 步后，数值解 $y_N$ 与精确解 $y(T)$ 之间的绝对差：\n$$\nE(h) = |y_N - y(T)|\n$$\n对于一个 $p$ 阶方法，当 $h$ 足够小时，全局误差的行为近似为 $E(h) \\approx C h^p$，其中 $C$ 是某个常数。使用两个不同的步长 $h_1$ 和 $h_2$，我们有 $E(h_1) \\approx C h_1^p$ 和 $E(h_2) \\approx C h_2^p$。取其比值然后取对数，得到：\n$$\n\\frac{E(h_1)}{E(h_2)} \\approx \\left(\\frac{h_1}{h_2}\\right)^p \\implies \\log\\left(\\frac{E(h_1)}{E(h_2)}\\right) \\approx p \\log\\left(\\frac{h_1}{h_2}\\right)\n$$\n求解 $p$ 即可得到观测阶的公式：\n$$\np \\approx \\frac{\\log(E(h_1)/E(h_2))}{\\log(h_1/h_2)}\n$$\n问题指定使用三个步长 $h_1  h_2  h_3$ 来计算两个两两间的阶 $p_{12}$ 和 $p_{23}$，并报告它们的平均值 $\\frac{1}{2}(p_{12}+p_{23})$。\n\n### 4. 线性稳定性\n\n对于给定的一组参数 $(\\theta, \\lambda, h)$，如果当精确解不无界增长时，数值解的模长也不无界增长，则称该数值方法是线性稳定的。对于标量测试问题，这对应于要求放大因子的模长不大于1：\n$$\n|R(z)| \\le 1\n$$\n其中 $z=h\\lambda$。在复平面上，对于给定的 $\\theta$，此条件成立的区域称为该方法的绝对稳定区域。验证测试仅检查对于特定的 $z$ 值，此条件是否满足。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to perform verification of the theta-method.\n    It runs accuracy and stability tests as specified in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n\n    y0 = 1.0\n\n    # ----- Task 1  4 (Core Functions) -----\n    \n    def compute_R(z, theta):\n        \"\"\"\n        Computes the amplification factor R(z) for the theta-method.\n        z = h * lambda.\n        \"\"\"\n        # To avoid division by zero if 1 - theta*z is exactly 0.\n        # This is unlikely with typical floating-point numbers but is good practice.\n        denominator = 1.0 - theta * z\n        if denominator == 0:\n            return np.inf\n        return (1.0 + (1.0 - theta) * z) / denominator\n\n    # ----- Task 5: Implementation and Verification -----\n\n    def run_accuracy_test(theta, lambda_val, T, y0, h_vals):\n        \"\"\"\n        Computes the empirical order of accuracy for a given set of parameters.\n        \"\"\"\n        errors = []\n        exact_solution_at_T = y0 * np.exp(lambda_val * T)\n\n        for h in h_vals:\n            N = int(round(T / h)) # Number of steps\n            z = h * lambda_val\n            \n            # Amplification factor\n            R_z = compute_R(z, theta)\n            \n            # Numerical solution at T\n            # y_N = y_0 * (R_z)^N\n            y_N = y0 * (R_z ** N)\n            \n            # Global error\n            error = np.abs(y_N - exact_solution_at_T)\n            errors.append(error)\n\n        E1, E2, E3 = errors\n        h1, h2, h3 = h_vals\n        \n        # Pairwise observed orders\n        p12 = np.log(E1 / E2) / np.log(h1 / h2)\n        p23 = np.log(E2 / E3) / np.log(h2 / h3)\n        \n        # Average observed order\n        avg_p = 0.5 * (p12 + p23)\n        return avg_p\n\n    def run_stability_test(theta, lambda_val, h):\n        \"\"\"\n        Checks the linear stability condition |R(z)| = 1.\n        \"\"\"\n        z = h * lambda_val\n        R_z = compute_R(z, theta)\n        is_stable = np.abs(R_z) = 1.0\n        return is_stable\n\n    # --- Test Suite Execution ---\n    \n    results = []\n\n    # Observed order tests\n    T_acc = 1.0\n    h_vals_acc = [1/20, 1/40, 1/80]\n    \n    # Test A1\n    theta_A1, lambda_A1 = 0, -1.0\n    order_A1 = run_accuracy_test(theta_A1, lambda_A1, T_acc, y0, h_vals_acc)\n    results.append(round(order_A1, 3))\n\n    # Test A2\n    theta_A2, lambda_A2 = 0.5, -1.0\n    order_A2 = run_accuracy_test(theta_A2, lambda_A2, T_acc, y0, h_vals_acc)\n    results.append(round(order_A2, 3))\n    \n    # Test A3\n    theta_A3, lambda_A3 = 1.0, -1.0\n    order_A3 = run_accuracy_test(theta_A3, lambda_A3, T_acc, y0, h_vals_acc)\n    results.append(round(order_A3, 3))\n\n    # Stability tests\n    # Test S1\n    stable_S1 = run_stability_test(theta=0, lambda_val=-1.0, h=1.0)\n    results.append(stable_S1)\n    \n    # Test S2\n    stable_S2 = run_stability_test(theta=0, lambda_val=-1.0, h=3.0)\n    results.append(stable_S2)\n\n    # Test S3\n    stable_S3 = run_stability_test(theta=0.5, lambda_val=-1.0, h=100.0)\n    results.append(stable_S3)\n    \n    # Test S4\n    stable_S4 = run_stability_test(theta=1.0, lambda_val=-1.0, h=100.0)\n    results.append(stable_S4)\n\n    # Test S5\n    stable_S5 = run_stability_test(theta=0.5, lambda_val=1j * 10, h=0.1)\n    results.append(stable_S5)\n\n    # Test S6\n    stable_S6 = run_stability_test(theta=0, lambda_val=1j * 10, h=0.1)\n    results.append(stable_S6)\n\n    # Final output formatting\n    # The map(str, ...) correctly converts rounded floats and booleans to their string representation.\n    # Note: Python's str(True) is 'True', not 'true'. The problem does not specify case.\n    # We will produce standard Python boolean string representations.\n    # To match the example format, we need to convert booleans to lowercase 'true'/'false'.\n    final_results_str = []\n    for res in results:\n        if isinstance(res, bool):\n            final_results_str.append(str(res).lower())\n        else:\n            final_results_str.append(str(res))\n            \n    print(f\"[{','.join(final_results_str)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "从标量问题过渡到更实际的场景，我们常常需要求解由偏微分方程（PDE）空间离散化后产生的常微分方程组。在这种情况下，精确解通常是未知的。本练习将介绍“人造解方法”（Method of Manufactured Solutions, MMS），这是一种强大的技术，用于创建一个具有已知解的测试用例，从而实现严格的误差分析。你将学习如何将 $\\theta$-方法应用于线性系统，并在一个更复杂的环境中验证其准确性 。",
            "id": "3455115",
            "problem": "您需要实现并使用通用的$\\theta$方法进行时间积分，以在一个制造的半离散偏微分方程（PDE）系统上验证其观察到的精度阶。该验证必须通过在半离散层面设计一个制造解来执行，从而使得唯一的数值误差来源于时间离散化。您的实现必须是一个完整的、可运行的程序，能够为指定的测试套件生成所要求的输出。\n\n从以下数学基础开始。\n\n- 考虑一个长度为 $L=2\\pi$ 的一维周期性域，用一个包含 $N=64$ 个点的均匀网格进行离散化，网格间距为 $h=L/N$。令 $\\mathbf{y}(t)\\in\\mathbb{R}^N$ 表示在时间 $t$ 近似制造解的节点值向量。\n- 令 $\\mathbf{A}\\in\\mathbb{R}^{N\\times N}$ 为周期性二阶中心差分拉普拉斯算子，其元素为\n  $$\n  A_{jj}=-\\frac{2}{h^2},\\quad A_{j,j+1}=\\frac{1}{h^2},\\quad A_{j,j-1}=\\frac{1}{h^2},\n  $$\n  具有环绕周期性连接 $A_{1,N}=\\frac{1}{h^2}$ 和 $A_{N,1}=\\frac{1}{h^2}$。\n- 令 $\\mathbf{q}\\in\\mathbb{R}^N$ 为离散正弦模式 $\\mathbf{q}_j=\\sin\\!\\big(m x_j\\big)$，其中 $x_j=jh$，$j=0,1,\\dots,N-1$，$m=3$。对于此网格和算子，$\\mathbf{q}$ 是 $\\mathbf{A}$ 的一个特征向量，其特征值为\n  $$\n  \\mu=\\frac{2\\cos\\!\\big(2\\pi m/N\\big)-2}{h^2}=-\\frac{4\\sin^2\\!\\big(\\pi m/N\\big)}{h^2}.\n  $$\n- 将精确的半离散解制造为 $\\mathbf{y}^\\star(t)=\\phi(t)\\,\\mathbf{q}$，其中 $\\phi(t)=\\mathrm{e}^{\\gamma t}$ 且 $\\gamma=1$。定义强迫项 $\\mathbf{r}(t)$，使得半离散系统\n  $$\n  \\mathbf{y}'(t)=\\mathbf{A}\\,\\mathbf{y}(t)+\\mathbf{r}(t)\n  $$\n  能被 $\\mathbf{y}^\\star(t)$ 精确满足。您必须根据此要求推导出 $\\mathbf{r}(t)$ 并实现它。\n\n时间积分任务。\n\n- 通过对积分形式\n  $$\n  \\mathbf{y}(t_{n+1})=\\mathbf{y}(t_n)+\\int_{t_n}^{t_{n+1}}\\big(\\mathbf{A}\\,\\mathbf{y}(s)+\\mathbf{r}(s)\\big)\\,\\mathrm{d}s,\n  $$\n  应用参数为 $\\theta\\in[0,1]$ 的凸组合求积，推导用于从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的单步时间推进的 $\\theta$ 方法，然后构建一个关于 $\\mathbf{y}_n$、$\\mathbf{A}$ 和 $\\mathbf{r}(\\cdot)$ 的可解的 $\\mathbf{y}_{n+1}$ 更新式。除线性外，不要假设任何特殊结构；您的更新必须能处理 $\\theta=0$、$\\theta=\\tfrac{1}{2}$ 和 $\\theta=1$ 的情况。\n- 将初始条件设置为 $\\mathbf{y}(0)=\\mathbf{y}^\\star(0)$。\n\n误差测量与观察阶。\n\n- 对于一个固定的最终时间 $T=0.1$，将给定时间步长 $\\Delta t$ 的离散误差定义为\n  $$\n  E(\\Delta t)=\\frac{\\|\\mathbf{y}^{\\Delta t}(T)-\\mathbf{y}^\\star(T)\\|_2}{\\sqrt{N}},\n  $$\n  其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\mathbf{y}^{\\Delta t}(T)$ 是使用时间步长 $\\Delta t$ 计算得到的在时间 $T$ 的数值解。\n- 对于下面测试套件中的每个 $\\theta$，计算观察阶\n  $$\n  p=\\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n  $$\n\n测试套件。\n\n使用以下测试用例集，每个用例指定为一个序对 $(\\theta,\\Delta t_0)$：\n- $(0,\\;0.001)$,\n- $(0.5,\\;0.01)$,\n- $(1,\\;0.01)$,\n- $(0.75,\\;0.01)$.\n\n对于每个用例，使用 $\\Delta t=\\Delta t_0$ 和 $\\Delta t=\\Delta t_0/2$ 计算 $p$，空间离散化参数保持不变，即 $L=2\\pi$、$N=64$、$m=3$ 和 $\\gamma=1$。显式情况 $\\theta=0$ 必须遵守由 $\\mathbf{A}$ 的特征值所隐含的稳定性约束。\n\n输出规格。\n\n- 您的程序必须生成单行输出，其中包含四个用例的观察阶的逗号分隔列表，顺序与上面列出的一致，四舍五入到三位小数，并用方括号括起来。例如，格式必须类似于 $\\big[$$p_1$,$p_2$,$p_3$,$p_4$$\\big]$。\n- 本问题中没有物理单位；仅报告纯数值。",
            "solution": "所提出的问题已经过验证，并被确定为有效。这是一个定义明确的数值分析任务，科学上合理，内容自洽，没有矛盾或含糊不清之处。该问题要求实现和验证 $\\theta$ 方法（一种求解常微分方程的标准数值技术），并使用制造解方法（一种用于代码验证的标准程序）。所有必需的参数和定义均已提供。因此，我们可以着手提供一个完整的解决方案。\n\n### 1. 制造强迫项的推导\n\n问题为半离散系统 $\\mathbf{y}'(t) = \\mathbf{A}\\mathbf{y}(t) + \\mathbf{r}(t)$ 定义了一个制造解 $\\mathbf{y}^\\star(t) \\in \\mathbb{R}^N$。目标是推导强迫项 $\\mathbf{r}(t)$，使得 $\\mathbf{y}^\\star(t)$ 是该系统的精确解。\n\n制造解由 $\\mathbf{y}^\\star(t) = \\phi(t)\\mathbf{q}$ 给出，其中 $\\phi(t) = e^{\\gamma t}$ 且 $\\gamma=1$。向量 $\\mathbf{q} \\in \\mathbb{R}^N$ 定义为 $\\mathbf{q}_j = \\sin(m x_j)$，并且是离散拉普拉斯矩阵 $\\mathbf{A}$ 的一个特征向量，对应特征值为 $\\mu$。\n\n首先，我们计算 $\\mathbf{y}^\\star(t)$ 的时间导数：\n$$\n(\\mathbf{y}^\\star(t))' = \\frac{d}{dt} \\left( e^{\\gamma t} \\mathbf{q} \\right) = \\left( \\frac{d}{dt} e^{\\gamma t} \\right) \\mathbf{q} = \\gamma e^{\\gamma t} \\mathbf{q} = \\gamma \\phi(t) \\mathbf{q}.\n$$\n接下来，我们将矩阵 $\\mathbf{A}$ 应用于 $\\mathbf{y}^\\star(t)$：\n$$\n\\mathbf{A}\\mathbf{y}^\\star(t) = \\mathbf{A} \\left( \\phi(t) \\mathbf{q} \\right) = \\phi(t) (\\mathbf{A}\\mathbf{q}).\n$$\n由于 $\\mathbf{q}$ 是 $\\mathbf{A}$ 的一个特征值为 $\\mu$ 的特征向量，我们有 $\\mathbf{A}\\mathbf{q} = \\mu \\mathbf{q}$。代入可得：\n$$\n\\mathbf{A}\\mathbf{y}^\\star(t) = \\phi(t) (\\mu \\mathbf{q}) = \\mu \\phi(t) \\mathbf{q}.\n$$\n将这些表达式代回半离散系统方程，得到：\n$$\n\\gamma \\phi(t) \\mathbf{q} = \\mu \\phi(t) \\mathbf{q} + \\mathbf{r}(t).\n$$\n求解强迫项 $\\mathbf{r}(t)$，我们得到：\n$$\n\\mathbf{r}(t) = \\gamma \\phi(t) \\mathbf{q} - \\mu \\phi(t) \\mathbf{q} = (\\gamma - \\mu) \\phi(t) \\mathbf{q} = (\\gamma - \\mu) e^{\\gamma t} \\mathbf{q}.\n$$\n该表达式定义了必要的强迫项，确保 $\\mathbf{y}^\\star(t)$ 是半离散常微分方程系统的精确解。\n\n### 2. 通用 $\\theta$ 方法更新规则的推导\n\n$\\theta$ 方法是通过对常微分方程系统的积分形式应用特定的求积法则来推导的。从 $\\mathbf{y}'(t) = \\mathbf{F}(t, \\mathbf{y}(t))$ 开始，其中 $\\mathbf{F}(t, \\mathbf{y}) = \\mathbf{A}\\mathbf{y} + \\mathbf{r}(t)$，解可以精确地写为：\n$$\n\\mathbf{y}(t_{n+1}) = \\mathbf{y}(t_n) + \\int_{t_n}^{t_{n+1}} \\mathbf{F}(s, \\mathbf{y}(s)) ds.\n$$\n$\\theta$ 方法使用在时间步端点 $t_n$ 和 $t_{n+1}=t_n+\\Delta t$ 处计算的被积函数的凸组合来近似该积分：\n$$\n\\int_{t_n}^{t_{n+1}} \\mathbf{F}(s, \\mathbf{y}(s)) ds \\approx \\Delta t \\left[ (1-\\theta) \\mathbf{F}(t_n, \\mathbf{y}(t_n)) + \\theta \\mathbf{F}(t_{n+1}, \\mathbf{y}(t_{n+1})) \\right].\n$$\n令 $\\mathbf{y}_n \\approx \\mathbf{y}(t_n)$，数值格式变为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\left[ (1-\\theta) \\mathbf{F}(t_n, \\mathbf{y}_n) + \\theta \\mathbf{F}(t_{n+1}, \\mathbf{y}_{n+1}) \\right].\n$$\n代入 $\\mathbf{F}(t, \\mathbf{y}) = \\mathbf{A}\\mathbf{y} + \\mathbf{r}(t)$：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\left[ (1-\\theta)(\\mathbf{A}\\mathbf{y}_n + \\mathbf{r}(t_n)) + \\theta(\\mathbf{A}\\mathbf{y}_{n+1} + \\mathbf{r}(t_{n+1})) \\right].\n$$\n当 $\\theta  0$ 时，该方程对于 $\\mathbf{y}_{n+1}$ 是隐式的。我们重新整理各项，将 $\\mathbf{y}_{n+1}$ 隔离在左侧：\n$$\n\\mathbf{y}_{n+1} - \\Delta t \\theta \\mathbf{A}\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t (1-\\theta) \\mathbf{A}\\mathbf{y}_n + \\Delta t (1-\\theta)\\mathbf{r}(t_n) + \\Delta t \\theta \\mathbf{r}(t_{n+1}).\n$$\n在左侧提出 $\\mathbf{y}_{n+1}$，在右侧提出 $\\mathbf{y}_n$，我们得到关于 $\\mathbf{y}_{n+1}$ 的线性系统：\n$$\n(\\mathbf{I} - \\Delta t \\theta \\mathbf{A})\\mathbf{y}_{n+1} = (\\mathbf{I} + \\Delta t (1-\\theta) \\mathbf{A})\\mathbf{y}_n + \\Delta t \\left[ (1-\\theta)\\mathbf{r}(t_n) + \\theta \\mathbf{r}(t_{n+1}) \\right],\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。必须在每个时间步求解此系统，以将解从 $\\mathbf{y}_n$ 推进到 $\\mathbf{y}_{n+1}$。\n对于 $\\theta=0$ (前向欧拉法，Forward Euler)，左侧矩阵是 $\\mathbf{I}$，得到一个显式更新。对于 $\\theta \\in (0, 1]$，该方法是隐式的，需要求解一个线性系统。\n\n### 3. 数值实现与验证\n\n验证过程包括以下步骤：\n1.  **系统设置**：设置物理和数值参数：$L=2\\pi$，$N=64$，$m=3$，$\\gamma=1$ 和 $T=0.1$。计算网格间距 $h=L/N$ 并构造网格点 $x_j=jh$，$j=0, \\dots, N-1$。\n2.  **矩阵和向量构造**：\n    - 构造 $N \\times N$ 周期性二阶有限差分矩阵 $\\mathbf{A}$。\n    - 构造离散特征向量 $\\mathbf{q}_j = \\sin(m x_j)$。\n    - 计算相应的特征值 $\\mu = \\frac{2\\cos(2\\pi m/N)-2}{h^2}$。\n3.  **定义解函数和强迫函数**：实现精确半离散解 $\\mathbf{y}^\\star(t) = e^{\\gamma t}\\mathbf{q}$ 和推导出的强迫项 $\\mathbf{r}(t) = (\\gamma - \\mu) e^{\\gamma t} \\mathbf{q}$ 的函数。\n4.  **时间积分**：对于每个测试用例 $(\\theta, \\Delta t_0)$：\n    - 定义一个函数，用给定的时间步长 $\\Delta t$ 执行从 $t=0$ 到 $t=T$ 的时间积分。\n    - 设置初始条件 $\\mathbf{y}_0 = \\mathbf{y}^\\star(0)$。\n    - 循环所需的步数（$T/\\Delta t$）。在每一步中，构建线性系统 $(\\mathbf{I} - \\Delta t \\theta \\mathbf{A})\\mathbf{y}_{n+1} = \\mathbf{b}$ 并求解 $\\mathbf{y}_{n+1}$。\n5.  **误差和阶的计算**：\n    - 对于每个测试用例，运行两次模拟：一次使用 $\\Delta t = \\Delta t_0$，另一次使用 $\\Delta t = \\Delta t_0/2$。\n    - 计算最终时间的精确解 $\\mathbf{y}^\\star(T)$。\n    - 计算每次运行的离散误差：$E(\\Delta t) = \\frac{\\|\\mathbf{y}^{\\Delta t}(T)-\\mathbf{y}^\\star(T)\\|_2}{\\sqrt{N}}$。\n    - 使用两个误差计算观察到的精度阶：$p = \\frac{\\log(E(\\Delta t_0)/E(\\Delta t_0/2))}{\\log(2)}$。\n\n### 4. 稳定性考虑\n对于显式前向欧拉法（Forward Euler method，$\\theta=0$），稳定性要求时间步长 $\\Delta t$ 满足 $\\Delta t \\le 2/\\rho(\\mathbf{A})$，其中 $\\rho(\\mathbf{A})$ 是 $\\mathbf{A}$ 的谱半径。$\\mathbf{A}$ 的特征值为 $\\lambda_k = \\frac{2}{h^2}(\\cos(2\\pi k/N) - 1)$。对于偶数 $N$，最负的特征值约为 $\\lambda_{N/2} = -4/h^2$。因此，$\\rho(\\mathbf{A}) \\approx 4/h^2$。当 $h=\\pi/32$ 时，稳定性极限为 $\\Delta t \\le h^2/2 \\approx (\\pi/32)^2/2 \\approx 0.0048$。为 $\\theta=0$ 情况提供的时间步长 $\\Delta t_0=0.001$ 满足此条件。$\\theta \\ge 0.5$ 的方法是 A-稳定的，对于此问题没有对 $\\Delta t$ 的稳定性限制。\n\n### 5. 预期结果\n$\\theta$ 方法的理论精度阶为：\n- $\\theta=0.5$ (Crank-Nicolson) 时为 $p=2$。\n- 对于所有其他 $\\theta$ 值，包括 $\\theta=0, 0.75, 1$，为 $p=1$。\n数值实验应该产生接近这些理论值的观察阶。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the theta-method for a manufactured semi-discrete PDE system.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    L = 2 * np.pi\n    N = 64\n    m = 3\n    gamma = 1.0\n    T = 0.1\n\n    # --- Discretization ---\n    h = L / N\n    x = np.arange(N) * h\n\n    # --- Matrix A (Periodic 2nd-order Central Difference Laplacian) ---\n    A = np.zeros((N, N))\n    h2_inv = 1.0 / (h * h)\n    for i in range(N):\n        A[i, i] = -2.0 * h2_inv\n        A[i, (i + 1) % N] = 1.0 * h2_inv\n        A[i, (i - 1 + N) % N] = 1.0 * h2_inv\n\n    # --- Eigenvector and Eigenvalue ---\n    q = np.sin(m * x)\n    # The given formula for mu is the exact eigenvalue for the discrete operator\n    mu = (2.0 * np.cos(2.0 * np.pi * m / N) - 2.0) / (h * h)\n    \n    # --- Manufactured Solution and Forcing Term ---\n    def y_exact(t):\n        return np.exp(gamma * t) * q\n\n    def r_forcing(t):\n        return (gamma - mu) * np.exp(gamma * t) * q\n\n    def time_stepper(theta, dt):\n        \"\"\"\n        Solves the ODE system y' = Ay + r(t) from t=0 to T using the theta-method.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        y = y_exact(0.0)\n        t = 0.0\n\n        # Pre-compute matrices for the linear system\n        LHS_matrix = np.eye(N) - dt * theta * A\n        RHS_matrix_op = np.eye(N) + dt * (1 - theta) * A\n\n        for n in range(num_steps):\n            t_next = (n + 1) * dt\n            \n            # Form the right-hand side vector\n            rhs_y_part = RHS_matrix_op @ y\n            rhs_r_part = dt * ((1 - theta) * r_forcing(t) + theta * r_forcing(t_next))\n            rhs_vector = rhs_y_part + rhs_r_part\n            \n            # Solve the linear system for the next time step\n            if theta == 0:  # Explicit Euler\n                y_next = rhs_vector\n            else:  # Implicit methods\n                y_next = np.linalg.solve(LHS_matrix, rhs_vector)\n            \n            y = y_next\n            t = t_next\n            \n        return y\n\n    def compute_order(theta, dt0):\n        \"\"\"\n        Computes the observed order of accuracy for a given theta and base time step dt0.\n        \"\"\"\n        # Get numerical solutions at T for dt0 and dt0/2\n        y_final_dt0 = time_stepper(theta, dt0)\n        y_final_dt0_2 = time_stepper(theta, dt0 / 2)\n\n        # Get exact solution at T\n        y_star_T = y_exact(T)\n\n        # Compute errors\n        err_dt0 = np.linalg.norm(y_final_dt0 - y_star_T) / np.sqrt(N)\n        err_dt0_2 = np.linalg.norm(y_final_dt0_2 - y_star_T) / np.sqrt(N)\n        \n        # Compute observed order of accuracy\n        if err_dt0 == 0 or err_dt0_2 == 0:\n             # If error is zero, order calculation is not meaningful.\n             # This might happen with machine precision, return a high number.\n             return np.inf\n        \n        p = np.log(err_dt0 / err_dt0_2) / np.log(2)\n        return p\n\n    # --- Test Suite ---\n    test_cases = [\n        (0.0, 0.001),   # Forward Euler\n        (0.5, 0.01),    # Crank-Nicolson\n        (1.0, 0.01),    # Backward Euler\n        (0.75, 0.01),   # General implicit\n    ]\n\n    results = []\n    for theta_val, dt0_val in test_cases:\n        p = compute_order(theta_val, dt0_val)\n        results.append(np.round(p, 3))\n\n    # --- Output ---\n    # Format the results as [p1,p2,p3,p4] rounded to three decimals\n    print(f\"[{','.join(f'{res:.3f}' for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了精度阶数，方法的稳定性至关重要，特别是对于“刚性”（stiff）问题，其中不同过程在迥异的时间尺度上发生（例如，缓慢的扩散和快速的反应）。本练习探讨了广泛使用的二阶Crank-Nicolson方法（$\\theta=1/2$）的一个关键局限性：它缺乏L-稳定性。通过一个反应-扩散方程的动手实例，你将观察到Crank-Nicolson如何产生非物理的振荡，并理解为何具有更优稳定性（如向后欧拉法，$\\theta=1$）的方法能避免此陷阱 。",
            "id": "3455051",
            "problem": "考虑一维线性反应扩散偏微分方程（PDE）\n$$\n\\partial_t u(x,t) \\;=\\; D\\,\\partial_{xx} u(x,t) \\;-\\; \\lambda\\,u(x,t),\n\\qquad x\\in(0,1),\\; t\\ge 0,\n$$\n其边界条件为齐次狄利克雷（Dirichlet）边界条件\n$$\nu(0,t)=0,\\quad u(1,t)=0,\\quad t\\ge 0,\n$$\n初始条件为\n$$\nu(x,0)=u_0(x)=\\sin(\\pi x),\\quad x\\in[0,1].\n$$\n参数满足 $D\\ge 0$ 和 $\\lambda0$。目标是构造、分析并验证一个反例，该反例表明当反应项是刚性时，Crank-Nicolson 方法（通用 $\\theta$ 方法中 $\\theta=\\tfrac{1}{2}$ 的特例）会产生下冲（负值），并将其与L-稳定性的缺失联系起来。\n\n您必须按以下步骤进行。\n\n1) 空间离散化（线方法）：\n- 使用包含 $N$ 个内部点的均匀网格对空间区间 $[0,1]$ 进行离散化，使得 $\\Delta x = 1/(N+1)$，内部节点为 $x_i=i\\Delta x$，其中 $i=1,\\dots,N$。\n- 使用标准的二阶中心有限差分算子来近似 $\\partial_{xx}u$。\n- 记 $U^n\\in\\mathbb{R}^N$ 为时间层 $t_n=n\\,\\Delta t$ 上内部节点值的向量，并令 $L\\in\\mathbb{R}^{N\\times N}$ 为对应于带有齐次狄利克雷边界条件的离散拉普拉斯算子的三对角矩阵，即 $L=\\frac{1}{\\Delta x^2}\\,\\mathrm{tridiag}(1,-2,1)$。证明线方法可以导出如下的线性常微分方程（ODE）组\n$$\n\\frac{dU}{dt} \\;=\\; A\\,U, \\qquad A \\;=\\; D\\,L \\;-\\; \\lambda\\,I,\n$$\n其中 $I$ 是 $N\\times N$ 的单位矩阵。\n\n2) 时间离散化（通用 $\\theta$ 方法）：\n- 从一阶 ODE 系统通用 $\\theta$ 方法的定义出发，将其应用于第1项中的半离散系统，推导出用于在每个时间步求解 $U^{n+1}$ 的线性系统形式的全离散更新格式。\n- 您的推导应从 ODE 单步法的基础定义开始，并将空间离散化后的问题视为一个线性 ODE 系统，而不假设任何预先推导出的 $\\theta$ 方法公式。\n- 在每个时间步，清晰地指出需要进行因式分解的左端矩阵和需要构造的右端向量。\n\n3) 稳定性讨论与L-稳定性：\n- 考虑线性标量测试方程 $y'=\\mu y$，其中 $\\mu\\in\\mathbb{C}$。\n- 推导与通用 $\\theta$ 方法相关的线性稳定性函数 $R(z)$，其中 $z=\\Delta t\\,\\mu$。\n- 仅使用 $\\theta$ 方法的基础定义，推导出 $R(z)$，然后确定当 $z\\to -\\infty$ 时 $R(z)$ 的极限。\n- 用此解释为什么 $\\theta=\\tfrac{1}{2}$ (Crank-Nicolson) 不是 L-稳定的，而 $\\theta=1$ (向后欧拉法) 是 L-稳定的。\n- 用数学上精确的术语解释，为什么在反应占主导地位时，即使连续问题在给定数据下保持非负性，L-稳定性的缺失仍会在刚性衰减中引发振荡，从而在上述反应扩散问题中产生下冲。\n\n4) 程序规范：\n- 将第2项中的格式实现为一个完整且可运行的程序，该程序使用应用于第1项中半离散系统的通用 $\\theta$ 方法来推进 $U^n$。\n- 使用投影到内部网格点上的初始条件 $u_0(x)=\\sin(\\pi x)$。\n- 使用以下测试套件，每个测试由元组 $(\\theta, D, \\lambda, \\Delta t, N_{\\text{steps}}, N)$ 指定：\n    - 测试 A（刚性反应，Crank-Nicolson 反例）：$(\\tfrac{1}{2},\\,10^{-3},\\,10^3,\\,1,\\,1,\\,200)$。\n    - 测试 B（温和反应，Crank-Nicolson 理想情况）：$(\\tfrac{1}{2},\\,10^{-2},\\,1,\\,10^{-3},\\,10,\\,200)$。\n    - 测试 C（刚性反应，向后欧拉法）：$(1,\\,10^{-3},\\,10^3,\\,1,\\,1,\\,200)$。\n    - 测试 D（刚性反应，中间值 $\\theta$）：$(\\tfrac{3}{4},\\,10^{-3},\\,10^3,\\,1,\\,1,\\,200)$。\n- 对于每个测试，从 $t=0$ 开始运行该方法 $N_{\\text{steps}}$ 步，并计算 $U^{N_{\\text{steps}}}$ 的内部最小值，即 $\\min_i U^{N_{\\text{steps}}}_i$。\n- 四个测试所需的输出是等于这些最小值的四个浮点数。不涉及物理单位；所有量均为无量纲。\n\n5) 最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试结果，按 A、B、C、D 的顺序排列，以逗号分隔并用方括号括起来。例如，输出格式必须与以下完全一样\n$$\n[result_A,result_B,result_C,result_D].\n$$\n\n您的交付内容：\n- 第1-3项的完整推导，以及您所实现算法的清晰描述。\n- 一个实现了第4项并按第5项规定打印结果的、完整的、可运行的程序。",
            "solution": "所提出的问题是偏微分方程数值分析中一个定义明确的标准练习。它在科学上是合理的、自洽的，并且其所有组成部分都可以被严格地形式化。因此，我将给出一个完整的解决方案。分析将按要求分为四个部分呈现。\n\n**1. 空间离散化（线方法）**\n\n第一步是通过离散化空间域，将偏微分方程（PDE）转化为一个常微分方程（ODE）组。这个过程被称为线方法。\n\n给定空间域 $x \\in [0, 1]$，我们用一个包含 $N$ 个内部点 $x_i = i \\Delta x$（$i=1, \\dots, N$）的均匀网格对其进行离散化。网格间距为 $\\Delta x = 1/(N+1)$。边界点为 $x_0 = 0$ 和 $x_{N+1} = 1$。设 $U_i(t)$ 是解 $u(x_i, t)$ 在内部节点上的数值近似。齐次狄利克雷边界条件规定，对于所有 $t \\ge 0$，有 $U_0(t) = u(0, t) = 0$ 和 $U_{N+1}(t) = u(1, t) = 0$。\n\n在每个内部节点 $x_i$ 处，空间导数 $\\partial_{xx} u$ 使用标准的二阶中心有限差分公式进行近似：\n$$\n\\partial_{xx} u(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{\\Delta x^2}\n$$\n用其离散近似 $U_i(t)$ 替换连续函数 $u(x_i, t)$，我们得到：\n$$\n\\partial_{xx} u(x_i, t) \\approx \\frac{U_{i-1}(t) - 2U_i(t) + U_{i+1}(t)}{\\Delta x^2}\n$$\n将此近似代入原始 PDE $\\partial_t u = D\\,\\partial_{xx} u - \\lambda\\,u$，得到一个包含 $N$ 个耦合 ODE 的系统，每个 ODE 对应一个内部节点 $U_i(t)$：\n$$\n\\frac{dU_i}{dt} = D \\left( \\frac{U_{i-1}(t) - 2U_i(t) + U_{i+1}(t)}{\\Delta x^2} \\right) - \\lambda U_i(t), \\qquad i=1, \\dots, N\n$$\n让我们将这个系统写成矩阵形式。设 $U(t) \\in \\mathbb{R}^N$ 是节点值的列向量，$U(t) = [U_1(t), U_2(t), \\dots, U_N(t)]^T$。二阶导数项可以表示为矩阵向量乘积 $L U(t)$，其中 $L \\in \\mathbb{R}^{N \\times N}$ 是离散拉普拉斯矩阵。对于 $i=1, \\dots, N$，系统的第 $i$ 行为：\n$$\n\\frac{dU_i}{dt} = \\frac{D}{\\Delta x^2} (U_{i-1} - 2U_i + U_{i+1}) - \\lambda U_i\n$$\n考虑到边界条件 $U_0=0$ 和 $U_{N+1}=0$，矩阵 $L$ 呈现三对角形式：\n$$\nL = \\frac{1}{\\Delta x^2}\n\\begin{pmatrix}\n-2   1   0  \\cdots  0 \\\\\n1   -2  1  \\cdots  0 \\\\\n0   \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots  \\cdots  1  -2  1 \\\\\n0  \\cdots  0  1  -2\n\\end{pmatrix}\n= \\frac{1}{\\Delta x^2} \\mathrm{tridiag}(1, -2, 1)\n$$\n反应项 $-\\lambda u$ 离散化为 $-\\lambda U$。这可以写成 $-\\lambda I U$，其中 $I \\in \\mathbb{R}^{N \\times N}$ 是单位矩阵。结合扩散项和反应项，半离散的 ODE 系统为：\n$$\n\\frac{dU}{dt} = D L U(t) - \\lambda I U(t) = (D L - \\lambda I) U(t)\n$$\n这是一个形如 $\\frac{dU}{dt} = A U$ 的线性 ODE 系统，其系统矩阵 $A$ 由下式给出：\n$$\nA = D L - \\lambda I\n$$\n至此，完成了所要求的推导。\n\n**2. 时间离散化（通用 $\\theta$ 方法）**\n\n我们现在对 ODE 系统 $\\frac{dU}{dt} = A U$ 中的时间变量进行离散化。通用 $\\theta$ 方法是一种将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的单步法。\n\n我们从单个时间步 $[t_n, t_{n+1}]$ 上的 ODE 积分形式开始：\n$$\nU(t_{n+1}) - U(t_n) = \\int_{t_n}^{t_{n+1}} \\frac{dU}{dt}(\\tau) d\\tau = \\int_{t_n}^{t_{n+1}} A U(\\tau) d\\tau\n$$\n$\\theta$ 方法使用被积函数 $f(\\tau) = A U(\\tau)$ 在端点 $t_n$ 和 $t_{n+1}$ 处的加权平均来近似该积分：\n$$\n\\int_{t_n}^{t_{n+1}} A U(\\tau) d\\tau \\approx \\Delta t \\left[ (1-\\theta) A U(t_n) + \\theta A U(t_{n+1}) \\right]\n$$\n其中 $\\theta \\in [0, 1]$ 是定义该方法的参数。特殊情况包括向前欧拉法（$\\theta=0$）、向后欧拉法（$\\theta=1$）和 Crank-Nicolson 方法（$\\theta=1/2$）。\n\n设 $U^n$ 是 $U(t_n)$ 的数值近似。将积分的近似值代入精确关系式，得到全离散格式：\n$$\nU^{n+1} = U^n + \\Delta t \\left[ (1-\\theta) A U^n + \\theta A U^{n+1} \\right]\n$$\n当 $\\theta  0$ 时，此方程是隐式的，因为未知数 $U^{n+1}$ 出现在等式两边。为了求得 $U^{n+1}$，我们必须求解一个线性系统。重新整理各项以分离 $U^{n+1}$：\n$$\nU^{n+1} - \\theta \\Delta t A U^{n+1} = U^n + (1-\\theta) \\Delta t A U^n\n$$\n在等式左边提出公因子 $U^{n+1}$，在右边提出公因子 $U^n$，得到：\n$$\n(I - \\theta \\Delta t A) U^{n+1} = (I + (1-\\theta) \\Delta t A) U^n\n$$\n这是更新步骤的最终形式。在每个时间层 $n$，我们求解这个线性系统以获得未知向量 $U^{n+1}$。\n- 需要进行因式分解的**左端矩阵**是 $M = I - \\theta \\Delta t A$。由于 $A = DL - \\lambda I$，该矩阵为 $M = (1 + \\theta \\Delta t \\lambda)I - \\theta \\Delta t D L$。因为 $L$ 是三对角的，所以 $M$ 也是三对角的。\n- 需要构造的**右端向量**是 $b = (I + (1-\\theta) \\Delta t A) U^n$。\n\n$M$ 的三对角结构使得线性系统 $M U^{n+1} = b$ 可以通过类似托马斯算法（三对角矩阵算法）的算法以 $\\mathcal{O}(N)$ 的运算量非常高效地求解。\n\n**3. 稳定性讨论与 L-稳定性**\n\n为分析 $\\theta$ 方法的稳定性，我们将其应用于标量 Dahlquist 测试方程 $y' = \\mu y$，其中 $\\mu \\in \\mathbb{C}$ 且 $\\text{Re}(\\mu)  0$。半离散系统 $U' = AU$ 可以通过其特征分解被看作是这类标量方程的叠加。\n\n将 $\\theta$ 方法格式应用于 $y' = \\mu y$：\n$$\ny_{n+1} = y_n + \\Delta t \\left[ (1-\\theta) \\mu y_n + \\theta \\mu y_{n+1} \\right]\n$$\n求解 $y_{n+1}$ 得：\n$$\ny_{n+1} (1 - \\theta \\Delta t \\mu) = y_n (1 + (1-\\theta) \\Delta t \\mu)\n$$\n放大因子，或称线性稳定性函数 $R(z)$，通过 $y_{n+1} = R(z) y_n$ 将 $y_{n+1}$ 和 $y_n$ 联系起来，其中 $z = \\Delta t \\mu$。由上式可推导：\n$$\nR(z) = \\frac{1 + (1-\\theta) z}{1 - \\theta z}\n$$\n如果一个数值方法的稳定区域包含整个左半复平面，即对于所有满足 $\\text{Re}(z) \\le 0$ 的 $z$，都有 $|R(z)| \\le 1$，则该方法是 A-稳定的。这确保了对于任何稳定的 ODE，无论时间步长 $\\Delta t$ 如何，数值解都不会出现伪增长。当 $\\theta \\ge 1/2$ 时，$\\theta$ 方法是 A-稳定的。\n\n然而，对于刚性问题，其解的某些分量会极快衰减（对应于具有非常大负实部的特征值 $\\mu$），A-稳定性是不够的。我们要求数值格式也能正确地模拟这种快速衰减。这引出了 L-稳定性的概念。一个方法如果是 L-稳定的，那么它必须是 A-稳定的，并且其稳定性函数满足：\n$$\n\\lim_{\\text{Re}(z) \\to -\\infty} |R(z)| = 0\n$$\n让我们来计算当 $z$ 沿实轴趋于 $-\\infty$ 时通用 $\\theta$ 方法的这个极限：\n$$\n\\lim_{z \\to -\\infty} R(z) = \\lim_{z \\to -\\infty} \\frac{1 + (1-\\theta) z}{1 - \\theta z} = \\lim_{z \\to -\\infty} \\frac{1/z + (1-\\theta)}{1/z - \\theta} = \\frac{1-\\theta}{-\\theta} = 1 - \\frac{1}{\\theta}\n$$\n- 对于 **Crank-Nicolson 方法**（$\\theta=1/2$），该极限为 $\\lim_{z \\to -\\infty} R(z) = 1 - 1/(1/2) = 1 - 2 = -1$。由于该极限不为 0，Crank-Nicolson 方法是 A-稳定的，但**不是 L-稳定的**。\n- 对于**向后欧拉法**（$\\theta=1$），该极限为 $\\lim_{z \\to -\\infty} R(z) = 1 - 1/1 = 0$。向后欧拉法是 A-稳定的，且极限为 0，因此它是 **L-稳定的**。\n\nCrank-Nicolson 方法缺乏 L-稳定性，这对刚性问题有深远的影响。在我们的反应扩散问题中，当 $\\lambda$ 很大时，反应项引入了刚性。矩阵 $A$ 的特征值为 $\\mu_k = -D \\kappa_k^2 - \\lambda$，其中 $\\kappa_k^2$ 是负离散拉普拉斯算子的特征值。所有的 $\\mu_k$ 都是实数且为负。对于大的 $\\lambda$，所有的 $\\mu_k$ 都变得大且为负。这对应于刚性衰减状态，此时真实解会迅速趋近于零。\n当我们取一个时间步长 $\\Delta t$ 使得 $\\Delta t \\lambda \\gg 1$ 时，对于所有模式 $k$， $z_k = \\Delta t \\mu_k$ 的值都将是大的负数。对于 Crank-Nicolson 方法，$R(z_k) \\approx -1$。数值解将按 $U^{n+1} \\approx -U^n$ 进行更新。\n初始条件 $u_0(x) = \\sin(\\pi x)$ 在 $(0, 1)$ 上是严格为正的。因此，初始向量 $U^0$ 的所有分量都是正的。使用 Crank-Nicolson 方法进行一步计算后，解将变为 $U^1 \\approx -U^0$，导致所有节点值变为负数。这是一种严重的、非物理的振荡和下冲。真实解是严格为正且单调衰减趋于零的。Crank-Nicolson 方法无法抑制与刚性特征值相关的高频误差分量，从而导致了这些伪振荡。\n相比之下，对于像向后欧拉法这样的 L-稳定方法，对于刚性分量，$R(z_k) \\approx 0$。数值解变为 $U^{n+1} \\approx 0 \\cdot U^n = 0$，从而正确地捕捉到向零稳态的快速衰减，而没有振荡。这就是为什么 L-稳定方法对于稳健地求解刚性问题至关重要。\n\n**4. 算法实现**\n\n该算法实现了第 2 部分中推导的格式。对于由 $(\\theta, D, \\lambda, \\Delta t, N_{\\text{steps}}, N)$ 定义的每个测试用例：\n1.  建立空间网格：$\\Delta x = 1/(N+1)$，内部节点坐标为 $x_i = i\\Delta x$，其中 $i=1,\\dots,N$。\n2.  在 $t=0$ 初始化解向量 $U$：$U_i^0 = \\sin(\\pi x_i)$，其中 $i=1,\\dots,N$。\n3.  为线性求解器构造左端（LHS）矩阵。矩阵 $M = (I - \\theta \\Delta t A)$ 是三对角的，并且在所有时间步中保持不变。其对角线元素计算如下：\n    - 主对角线：$1 + \\theta \\Delta t \\lambda + 2 \\theta \\Delta t D / \\Delta x^2$\n    - 次对角线：$-\\theta \\Delta t D / \\Delta x^2$\n    此矩阵被准备成 `scipy.linalg.solve_banded` 所需的格式。\n4.  开始时间步进循环，从 $n=0$ 到 $N_{\\text{steps}}-1$：\n    a. 构造右端（RHS）向量 $b = (I + (1-\\theta) \\Delta t A) U^n$。这可以通过高效的三对角矩阵-向量乘积来完成。三对角矩阵 $K = (I + (1-\\theta) \\Delta t A)$ 的对角线元素为：\n       - 主对角线：$1 - (1-\\theta) \\Delta t \\lambda - 2(1-\\theta) \\Delta t D / \\Delta x^2$\n       - 次对角线：$(1-\\theta) \\Delta t D / \\Delta x^2$\n    b. 使用 `scipy.linalg.solve_banded` 求解三对角系统 $M U^{n+1} = b$ 以得到 $U^{n+1}$。\n    c. 更新 $U \\leftarrow U^{n+1}$。\n5.  循环结束后，计算最终解向量 $U^{N_{\\text{steps}}}$ 中的最小值并存储它。\n\n对所有四个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D reaction-diffusion equation using the general theta-method\n    and demonstrates the lack of L-stability for the Crank-Nicolson method.\n    \"\"\"\n    \n    # Test cases: (theta, D, lam, dt, N_steps, N)\n    test_cases = [\n        (0.5, 1e-3, 1e3, 1.0, 1, 200),      # A: Stiff, Crank-Nicolson\n        (0.5, 1e-2, 1.0, 1e-3, 10, 200),    # B: Mild, Crank-Nicolson\n        (1.0, 1e-3, 1e3, 1.0, 1, 200),      # C: Stiff, Backward Euler\n        (0.75, 1e-3, 1e3, 1.0, 1, 200)      # D: Stiff, Intermediate theta=0.75\n    ]\n\n    results = []\n\n    for case in test_cases:\n        theta, D, lam, dt, N_steps, N = case\n\n        # 1. Spatial discretization\n        dx = 1.0 / (N + 1)\n        x = np.linspace(0, 1, N + 2)[1:-1] # Interior nodes\n\n        # 2. Initial condition\n        U = np.sin(np.pi * x)\n\n        # 3. Setup linear system for the theta-method\n        # The update is (I - theta*dt*A) U_new = (I + (1-theta)*dt*A) U_old\n        # where A = D*L - lam*I\n        # LHS Matrix M = I - theta*dt*(D*L - lam*I)\n        #            = (1 + theta*dt*lam)*I - theta*dt*D*L\n        # RHS is multiplication by K = I + (1-theta)*dt*(D*L - lam*I)\n        #            = (1 - (1-theta)*dt*lam)*I + (1-theta)*dt*D*L\n        \n        # Setup LHS matrix M for the banded solver\n        # M is tridiagonal: diag(m_off, m_diag, m_off)\n        m_diag = 1.0 + theta * dt * lam + 2.0 * theta * dt * D / (dx**2)\n        m_off = -theta * dt * D / (dx**2)\n        \n        # Banded matrix format for scipy.linalg.solve_banded\n        # ab[0, 1:] = upper diagonal\n        # ab[1, :]  = main diagonal\n        # ab[2, :-1]= lower diagonal\n        ab = np.zeros((3, N))\n        ab[0, 1:] = m_off\n        ab[1, :] = m_diag\n        ab[2, :-1] = m_off\n\n        # Setup for RHS calculation: b = K @ U\n        # K is tridiagonal: diag(k_off, k_diag, k_off)\n        k_diag = 1.0 - (1.0 - theta) * dt * lam - 2.0 * (1.0 - theta) * dt * D / (dx**2)\n        k_off = (1.0 - theta) * dt * D / (dx**2)\n        \n        # 4. Time stepping loop\n        for _ in range(N_steps):\n            # Calculate RHS vector b = K @ U efficiently\n            b = np.zeros(N)\n            # Interior points\n            b[1:-1] = k_off * U[:-2] + k_diag * U[1:-1] + k_off * U[2:]\n            # Boundary points\n            b[0] = k_diag * U[0] + k_off * U[1]\n            b[-1] = k_off * U[-2] + k_diag * U[-1]\n\n            # Solve the linear system M * U_new = b\n            U = solve_banded((1, 1), ab, b)\n            \n        # 5. Store the minimum value of the final solution\n        min_val = np.min(U)\n        results.append(min_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}