{
    "hands_on_practices": [
        {
            "introduction": "A critical first step in computational science is ensuring your code is correct. This practice introduces the Method of Manufactured Solutions (MMS), a rigorous technique for code verification. By designing a problem with a known analytic solution, you can directly measure your numerical error and empirically verify the convergence rates of your implemented schemes . This exercise will guide you through implementing and validating two cornerstone methods for parabolic equations: the explicit Forward-Time Central-Space (FTCS) scheme and the implicit Crank-Nicolson (CN) method, providing a concrete baseline for their accuracy and behavior.",
            "id": "3388344",
            "problem": "Consider the two-dimensional heat equation with a manufactured smooth solution on the unit square. Let the spatial domain be $\\Omega = (0,1)\\times(0,1)$ and the time interval be $[0,T]$. The governing partial differential equation is\n$$\nu_t = \\alpha \\left(u_{xx} + u_{yy}\\right) + f(x,y,t)\\quad\\text{in}\\quad \\Omega\\times(0,T],\n$$\nwith Dirichlet boundary conditions\n$$\nu(x,y,t) = g(x,y,t)\\quad\\text{for}\\quad (x,y)\\in\\partial\\Omega,\\ t\\in[0,T],\n$$\nand initial condition\n$$\nu(x,y,0) = u_0(x,y)\\quad\\text{for}\\quad (x,y)\\in\\Omega.\n$$\nTake the thermal diffusivity to be $\\alpha = 1$. Use the method of manufactured solutions as the context-appropriate fundamental base: choose the exact smooth function\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\nand construct the forcing term $f(x,y,t)$, the initial condition $u_0(x,y)$, and the boundary data $g(x,y,t)$ so that the above equation and data are satisfied exactly by $u(x,y,t)$. The discrete spatial operator must use second-order central differences on a uniform Cartesian interior grid with $N_x$ by $N_y$ unknowns, grid spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. Dirichlet boundary conditions must be imposed strongly by using the exact boundary values. Time integration must be performed using:\n- the explicit Forward-Time Central-Space (FTCS) method (first-order one-step forward Euler in time with the central-difference Laplacian), and\n- the implicit Crank–Nicolson (CN) method (trapezoidal rule in time with the central-difference Laplacian).\n\nYour program must:\n- Assemble the discrete two-dimensional five-point Laplacian on the interior using second-order central differences.\n- For FTCS, respect the stability condition; in two dimensions with $h_x = h_y = h$, the stability constraint is $\\Delta t \\le h^2/4$ when $\\alpha = 1$.\n- For Crank–Nicolson, solve the linear system at each time step exactly (up to numerical linear algebra accuracy), accounting for the source term and Dirichlet boundary values.\n\nUse the discrete $\\ell^2$-error at final time $T$ computed as the square root of the interior-grid weighted sum of squares with cell area $h_x h_y$:\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(u_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2},\n$$\nwhere $x_i = i h_x$ and $y_j = j h_y$. Use this $E$ to estimate observed orders of convergence by comparing errors under mesh or time-step refinement by a factor $r>1$:\n$$\np_{\\text{obs}} = \\frac{\\log\\left(E_{\\text{coarse}}/E_{\\text{fine}}\\right)}{\\log(r)}.\n$$\n\nImplement both methods and compute observed temporal and spatial convergence orders for each method using the following test suite. In each case, integrate to the final time $T = 0.01$. When a target time step $\\Delta t_{\\text{target}}$ is prescribed, use an integer number of steps $n = \\lceil T/\\Delta t_{\\text{target}}\\rceil$ and set the actual time step to $\\Delta t = T/n$.\n\nTest suite:\n- Test $1$ (FTCS temporal order): Use $N_x=N_y=80$, let $h=1/(N_x+1)$, and choose two target time steps $\\Delta t_{\\text{coarse}} = 0.2\\,h^2$ and $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$. Compute the observed temporal order $p^{\\text{FTCS}}_t$ using the actual steps employed. Ensure the FTCS stability criterion $\\Delta t \\le h^2/4$ is satisfied.\n- Test $2$ (FTCS spatial order): Use two grids, $(N_x,N_y)=(20,20)$ and $(N_x,N_y)=(40,40)$. For each grid, let $h=1/(N_x+1)$ and choose a target time step $\\Delta t = 0.05\\,h^2$. Compute the observed spatial order $p^{\\text{FTCS}}_h$ using the two errors and the exact refinement ratio $r_h = h_{\\text{coarse}}/h_{\\text{fine}}$.\n- Test $3$ (Crank–Nicolson temporal order): Use $N_x=N_y=80$. Choose $\\Delta t_{\\text{coarse}} = 0.0025$ and $\\Delta t_{\\text{fine}} = \\Delta t_{\\text{coarse}}/2$. Compute the observed temporal order $p^{\\text{CN}}_t$ using the actual steps employed.\n- Test $4$ (Crank–Nicolson spatial order): Use two grids, $(N_x,N_y)=(16,16)$ and $(N_x,N_y)=(32,32)$. For each grid, let $h=1/(N_x+1)$ and choose a target time step $\\Delta t = h^2$. Compute the observed spatial order $p^{\\text{CN}}_h$ using the two errors and $r_h$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[p^{\\text{FTCS}}_t,\\ p^{\\text{FTCS}}_h,\\ p^{\\text{CN}}_t,\\ p^{\\text{CN}}_h\\right].\n$$\nAll four outputs must be real numbers (floats). No other text should be printed.",
            "solution": "The user-provided problem is a well-defined exercise in the numerical solution of partial differential equations. It requires implementing and verifying two standard finite difference methods for the two-dimensional heat equation. The problem is valid as it is scientifically grounded, self-contained, and objective. We will proceed with a full solution.\n\nThe core of the problem is to solve the two-dimensional heat equation on a unit square domain $\\Omega = (0,1)\\times(0,1)$ over the time interval $[0,T]$:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + f(x,y,t)\n$$\nThe problem specifies using the method of manufactured solutions, where a known, smooth function is chosen as the exact solution, and the problem data (forcing term, initial and boundary conditions) are derived from it.\n\n**1. Formulation via Manufactured Solution**\n\nThe prescribed exact solution is:\n$$\nu(x,y,t) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\n$$\nThe thermal diffusivity is given as $\\alpha = 1$. We derive the problem components by substituting $u(x,y,t)$ into the governing PDE.\n\nThe partial derivatives of $u$ are:\n- Time derivative: $u_t = \\frac{\\partial}{\\partial t} \\left(e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)\\right) = e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n- Spatial derivatives:\n  - $u_x = \\pi e^{t}\\,\\cos(\\pi x)\\,\\sin(\\pi y) \\implies u_{xx} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n  - $u_y = \\pi e^{t}\\,\\sin(\\pi x)\\,\\cos(\\pi y) \\implies u_{yy} = -\\pi^2 e^{t}\\,\\sin(\\pi x)\\,\\sin(\\pi y)$.\n\nThe forcing term $f(x,y,t)$ is determined by rearranging the PDE: $f = u_t - \\alpha(u_{xx} + u_{yy})$.\n$$\nf(x,y,t) = e^{t}\\sin(\\pi x)\\sin(\\pi y) - (1)\\left(-\\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y) - \\pi^2 e^{t}\\sin(\\pi x)\\sin(\\pi y)\\right)\n$$\n$$\nf(x,y,t) = (1 + 2\\pi^2)e^{t}\\sin(\\pi x)\\sin(\\pi y)\n$$\n\nThe initial condition $u_0(x,y)$ at $t=0$ is:\n$$\nu_0(x,y) = u(x,y,0) = e^{0}\\,\\sin(\\pi x)\\,\\sin(\\pi y) = \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n\nThe Dirichlet boundary condition $g(x,y,t)$ is the value of $u(x,y,t)$ on the boundary $\\partial\\Omega$:\n$$\ng(x,y,t) = u(x,y,t)|_{(x,y) \\in \\partial\\Omega}\n$$\nThe boundary $\\partial\\Omega$ consists of the four line segments where $x=0$, $x=1$, $y=0$, or $y=1$. Since $\\sin(0) = 0$ and $\\sin(\\pi) = 0$, the manufactured solution is zero on the entire boundary for all time:\n$$\ng(x,y,t) = 0\n$$\n\n**2. Discretization**\n\nWe define a uniform Cartesian grid with $N_x \\times N_y$ interior points. The grid spacings are $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. The grid points are $(x_i, y_j)$, where $x_i = i h_x$ and $y_j = j h_y$, for $i \\in \\{0, 1, \\dots, N_x+1\\}$ and $j \\in \\{0, 1, \\dots, N_y+1\\}$. The numerical solution at $(x_i, y_j)$ at time $t_n = n\\Delta t$ is denoted by $U_{ij}^n$.\n\nThe spatial derivatives are approximated using second-order central differences. The discrete Laplacian operator, $\\nabla_h^2$, acting on $U$ at an interior grid point $(i,j)$ is:\n$$\n\\nabla_h^2 U_{ij} = \\frac{U_{i+1,j} - 2U_{ij} + U_{i-1,j}}{h_x^2} + \\frac{U_{i,j+1} - 2U_{ij} + U_{i,j-1}}{h_y^2}\n$$\n\n**3. Time Integration Schemes**\n\n**a) Forward-Time Central-Space (FTCS) Method**\nThis method is explicit, using a forward Euler step in time and the central difference operator for space.\n$$\n\\frac{U_{ij}^{n+1} - U_{ij}^n}{\\Delta t} = \\alpha \\nabla_h^2 U_{ij}^n + f(x_i, y_j, t_n)\n$$\nSolving for $U_{ij}^{n+1}$, we get the update rule:\n$$\nU_{ij}^{n+1} = U_{ij}^n + \\alpha \\Delta t \\left( \\frac{U_{i+1,j}^n - 2U_{ij}^n + U_{i-1,j}^n}{h_x^2} + \\frac{U_{i,j+1}^n - 2U_{ij}^n + U_{i,j-1}^n}{h_y^2} \\right) + \\Delta t f_{ij}^n\n$$\nwhere $f_{ij}^n = f(x_i, y_j, t_n)$. This scheme is first-order accurate in time, $\\mathcal{O}(\\Delta t)$, and second-order in space, $\\mathcal{O}(h_x^2, h_y^2)$. It is conditionally stable, requiring $\\alpha \\Delta t (1/h_x^2 + 1/h_y^2) \\le 1/2$. For the test cases where $h_x=h_y=h$ and $\\alpha=1$, this simplifies to the provided condition $\\Delta t \\le h^2/4$.\n\n**b) Crank-Nicolson (CN) Method**\nThis method is implicit, based on the trapezoidal rule for time integration, which averages the spatial operator over the current and next time levels.\n$$\n\\frac{U^{n+1}_{ij} - U^{n}_{ij}}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\nabla^2_h U^{n+1}_{ij} + \\nabla^2_h U^n_{ij} \\right) + \\frac{f_{ij}^{n+1} + f_{ij}^{n}}{2}\n$$\nRearranging terms to isolate the unknowns ($U^{n+1}$) on the left-hand side:\n$$\nU^{n+1}_{ij} - \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^{n+1}_{ij} = U^{n}_{ij} + \\frac{\\alpha \\Delta t}{2} \\nabla_h^2 U^n_{ij} + \\frac{\\Delta t}{2}(f_{ij}^{n+1} + f_{ij}^{n})\n$$\nThis equation forms a large, sparse linear system for the vector of unknowns $\\mathbf{U}^{n+1}$ at each time step. Let $\\mathbf{L}_h$ be the matrix representation of the discrete Laplacian $\\nabla_h^2$. The system can be written as:\n$$\n\\left(\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^{n+1} = \\left(\\mathbf{I} + \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h\\right)\\mathbf{U}^n + \\frac{\\Delta t}{2}(\\mathbf{F}^{n+1} + \\mathbf{F}^n)\n$$\nwhere $\\mathbf{I}$ is the identity matrix and $\\mathbf{U}^n$ is the flattened vector of interior grid values at time $t_n$. The matrix $\\mathbf{A} = (\\mathbf{I} - \\frac{\\alpha \\Delta t}{2}\\mathbf{L}_h)$ is constant for a fixed $\\Delta t$, so it can be constructed and factorized once before the time-stepping loop for efficiency. The CN method is unconditionally stable and second-order accurate in both time and space, $\\mathcal{O}(\\Delta t^2, h_x^2, h_y^2)$.\n\n**4. Convergence Analysis**\n\nThe numerical error is quantified using the discrete $\\ell^2$-norm at the final time $T$:\n$$\nE = \\left(h_x h_y \\sum_{i=1}^{N_x}\\sum_{j=1}^{N_y} \\left(U_{ij}^{\\text{num}}(T) - u(x_i,y_j,T)\\right)^2\\right)^{1/2}\n$$\nThe observed order of convergence, $p_{\\text{obs}}$, is estimated by running simulations with a coarse parameter (step size $h_1$ or $\\Delta t_1$) and a fine parameter (step size $h_2$ or $\\Delta t_2$) yielding errors $E_1$ and $E_2$, respectively. With a refinement ratio $r = h_1/h_2$ or $r = \\Delta t_1/\\Delta t_2$:\n$$\np_{\\text{obs}} = \\frac{\\log(E_1/E_2)}{\\log(r)}\n$$\nThe implementation will carry out the four tests specified in the problem to calculate the temporal and spatial convergence orders for both FTCS and CN methods. For temporal tests, the spatial grid is held fixed and $\\Delta t$ is refined. For spatial tests, both the grid spacing $h$ and the time step $\\Delta t$ (which is coupled to $h$) are refined.\n\n**5. Implementation Strategy**\n\n- **FTCS Solver**: This will be implemented using NumPy array operations for efficiency. The solution domain will be represented by an $(N_y+2) \\times (N_x+2)$ array, where the boundary cells are kept at zero, simplifying the update for interior points.\n- **Crank-Nicolson Solver**: This requires building the sparse matrix $\\mathbf{L}_h$ representing the $2$D Laplacian with lexicographical ordering of the $N_x \\times N_y$ interior grid points. `scipy.sparse` is ideal for constructing this matrix and the system matrix $\\mathbf{A}$. The linear system at each step is solved using `scipy.sparse.linalg.spsolve` or, for greater efficiency, by pre-factorizing $\\mathbf{A}$ with `scipy.sparse.linalg.factorized`. The solution vector is reshaped back into a $2$D grid for analysis if needed.\n- **Main Driver**: A main function will execute the four test cases, calling the appropriate solver with coarse and fine parameters, collecting the errors, and calculating the four required convergence orders. The final output will be formatted as a comma-separated list in brackets.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n    \n    # Global parameters\n    ALPHA = 1.0\n    T_FINAL = 0.01\n\n    def u_exact(x, y, t):\n        \"\"\"Manufactured exact solution.\"\"\"\n        return np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_source(x, y, t):\n        \"\"\"Derived source term for the manufactured solution.\"\"\"\n        return (1.0 + 2.0 * np.pi**2 * ALPHA) * np.exp(t) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def solve_ftcs(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the FTCS method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        x = np.linspace(0, 1, Nx + 2)\n        y = np.linspace(0, 1, Ny + 2)\n        \n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n        \n        # Initial condition (u=0 on boundaries is implicit)\n        u_n = np.zeros((Ny + 2, Nx + 2))\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_n[j, i] = u_exact(x[i], y[j], 0.0)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            \n            # Vectorized update of interior points\n            laplacian_u = (u_n[1:-1, 2:] - 2 * u_n[1:-1, 1:-1] + u_n[1:-1, :-2]) / hx**2 \\\n                        + (u_n[2:, 1:-1] - 2 * u_n[1:-1, 1:-1] + u_n[:-2, 1:-1]) / hy**2\n            \n            # Source term evaluated on interior grid\n            xx, yy = np.meshgrid(x[1:-1], y[1:-1])\n            f_n = f_source(xx, yy, t_n)\n            \n            u_n[1:-1, 1:-1] += dt * (ALPHA * laplacian_u + f_n)\n\n        # Compute error at final time T\n        u_final_exact_grid = np.zeros_like(u_n)\n        for j in range(1, Ny + 1):\n            for i in range(1, Nx + 1):\n                u_final_exact_grid[j, i] = u_exact(x[i], y[j], T_FINAL)\n\n        error_grid = u_n[1:-1, 1:-1] - u_final_exact_grid[1:-1, 1:-1]\n        l2_error = np.sqrt(hx * hy * np.sum(error_grid**2))\n        \n        return l2_error, dt\n\n    def solve_cn(Nx, Ny, dt_target):\n        \"\"\"\n        Solves the 2D heat equation using the Crank-Nicolson method.\n        Returns the discrete l2-error and the actual time step used.\n        \"\"\"\n        # Grid setup\n        hx = 1.0 / (Nx + 1)\n        hy = 1.0 / (Ny + 1)\n        \n        x_int = np.linspace(hx, 1.0 - hx, Nx)\n        y_int = np.linspace(hy, 1.0 - hy, Ny)\n        xx, yy = np.meshgrid(x_int, y_int)\n\n        # Time setup\n        n_steps = int(np.ceil(T_FINAL / dt_target))\n        dt = T_FINAL / n_steps\n\n        # Initial condition (vectorized)\n        u_vec_n = u_exact(xx, yy, 0.0).flatten()\n\n        # System matrices\n        N = Nx * Ny\n        \n        main_diag = np.ones(N) * (-2/hx**2 - 2/hy**2)\n        x_diag = np.ones(N - 1) * (1/hx**2)\n        for i in range(1, Ny):\n            x_diag[i * Nx - 1] = 0\n        y_diag = np.ones(N - Nx) * (1/hy**2)\n        \n        L = sparse.diags([main_diag, x_diag, x_diag, y_diag, y_diag], \n                          [0, -1, 1, -Nx, Nx], shape=(N, N), format='csc')\n\n        A = sparse.identity(N) - (dt / 2.0) * ALPHA * L\n        B = sparse.identity(N) + (dt / 2.0) * ALPHA * L\n        \n        # Factorize A for repeated solves\n        solve_A = linalg.factorized(A)\n\n        # Time stepping loop\n        for n in range(n_steps):\n            t_n = n * dt\n            t_np1 = (n + 1) * dt\n            \n            F_n = f_source(xx, yy, t_n).flatten()\n            F_np1 = f_source(xx, yy, t_np1).flatten()\n            F_avg = (F_n + F_np1) / 2.0\n            \n            rhs = B.dot(u_vec_n) + dt * F_avg\n            u_vec_n = solve_A(rhs)\n\n        # Compute error at final time T\n        u_final_exact_vec = u_exact(xx, yy, T_FINAL).flatten()\n        error_vec = u_vec_n - u_final_exact_vec\n        l2_error = np.sqrt(hx * hy * np.sum(error_vec**2))\n        \n        return l2_error, dt\n\n    def get_order(E_coarse, E_fine, r):\n        \"\"\"Computes the observed order of convergence.\"\"\"\n        return np.log(E_coarse / E_fine) / np.log(r)\n\n    results = []\n\n    # Test 1: FTCS temporal order\n    N = 80\n    h = 1.0 / (N + 1)\n    dt_target_coarse_1 = 0.2 * h**2\n    dt_target_fine_1 = dt_target_coarse_1 / 2.0\n    \n    E_coarse, dt_coarse = solve_ftcs(N, N, dt_target_coarse_1)\n    E_fine, dt_fine = solve_ftcs(N, N, dt_target_fine_1)\n    r_t = dt_coarse / dt_fine\n    p_ftcs_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_ftcs_t)\n\n    # Test 2: FTCS spatial order\n    N_coarse, N_fine = 20, 40\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = 0.05 * h_coarse**2\n    dt_target_fine = 0.05 * h_fine**2\n    \n    E_coarse, _ = solve_ftcs(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_ftcs(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_ftcs_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_ftcs_h)\n    \n    # Test 3: Crank-Nicolson temporal order\n    N = 80\n    dt_target_coarse = 0.0025\n    dt_target_fine = dt_target_coarse / 2.0\n    \n    E_coarse, dt_coarse = solve_cn(N, N, dt_target_coarse)\n    E_fine, dt_fine = solve_cn(N, N, dt_target_fine)\n    r_t = dt_coarse / dt_fine\n    p_cn_t = get_order(E_coarse, E_fine, r_t)\n    results.append(p_cn_t)\n    \n    # Test 4: Crank-Nicolson spatial order\n    N_coarse, N_fine = 16, 32\n    h_coarse = 1.0 / (N_coarse + 1)\n    h_fine = 1.0 / (N_fine + 1)\n    dt_target_coarse = h_coarse**2\n    dt_target_fine = h_fine**2\n    \n    E_coarse, _ = solve_cn(N_coarse, N_coarse, dt_target_coarse)\n    E_fine, _ = solve_cn(N_fine, N_fine, dt_target_fine)\n    r_h = h_coarse / h_fine\n    p_cn_h = get_order(E_coarse, E_fine, r_h)\n    results.append(p_cn_h)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The stability of an explicit time-stepping scheme is paramount, as it dictates the maximum permissible time step. In the previous practice, a stability constraint for the FTCS method was provided; here, we will derive it from first principles using von Neumann stability analysis . This analytical exercise explores how the choice of boundary conditions—specifically, shifting from Dirichlet to Neumann—alters the set of admissible eigenmodes and, consequently, impacts the stability criterion. Mastering this analysis provides a deeper understanding of the theoretical underpinnings that govern the practical limits of explicit methods.",
            "id": "3388348",
            "problem": "Consider the two-dimensional heat equation on a rectangular domain subject to homogeneous Neumann boundary conditions. Let the temperature field be $u(x,y,t)$ evolving according to the partial differential equation $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$ for $x\\in[0,L_{x}]$, $y\\in[0,L_{y}]$, and $t\\ge 0$, where $\\kappa>0$ is the thermal diffusivity. The boundary conditions are $u_{x}(0,y,t)=0$, $u_{x}(L_{x},y,t)=0$, $u_{y}(x,0,t)=0$, and $u_{y}(x,L_{y},t)=0$ for all appropriate $(x,y,t)$. Discretize the spatial domain by a uniform grid that includes the boundaries: $x_{i}=i\\,\\Delta x$ for $i=0,1,\\dots,N_{x}$ with $\\Delta x=L_{x}/N_{x}$, and $y_{j}=j\\,\\Delta y$ for $j=0,1,\\dots,N_{y}$ with $\\Delta y=L_{y}/N_{y}$. In time, use the Forward Time Centered Space (FTCS) scheme with time step $\\Delta t>0$, so the nodal values $u_{i,j}^{n}$ approximate $u(x_{i},y_{j},t_{n})$ with $t_{n}=n\\,\\Delta t$. Impose the Neumann boundary conditions via second-order centered differences with mirrored ghost nodes satisfying $u_{-1,j}^{n}=u_{1,j}^{n}$, $u_{N_{x}+1,j}^{n}=u_{N_{x}-1,j}^{n}$, $u_{i,-1}^{n}=u_{i,1}^{n}$, and $u_{i,N_{y}+1}^{n}=u_{i,N_{y}-1}^{n}$.\n\nStarting from the governing equation and these discrete boundary closures, derive the linear update of the FTCS method and perform a modal stability analysis using eigenmodes consistent with homogeneous Neumann boundary conditions. Let $r_{x}=\\kappa\\,\\Delta t/\\Delta x^{2}$ and $r_{y}=\\kappa\\,\\Delta t/\\Delta y^{2}$. By requiring that the amplification factor of every admissible spatial mode has magnitude bounded by $1$, determine the largest permissible value of the combined non-dimensional time-step parameter $r_{x}+r_{y}$ that guarantees stability of FTCS under Neumann boundaries. Express your final answer as a dimensionless number.",
            "solution": "The problem statement will be validated before a solution is attempted.\n\n### Step 1: Extract Givens\nThe following information is provided in the problem statement:\n- **Governing Equation:** The two-dimensional heat equation, $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$.\n- **Domain:** $x\\in[0,L_{x}]$, $y\\in[0,L_{y}]$, and $t\\ge 0$.\n- **Physical Constant:** Thermal diffusivity $\\kappa>0$.\n- **Boundary Conditions (BCs):** Homogeneous Neumann boundary conditions: $u_{x}(0,y,t)=0$, $u_{x}(L_{x},y,t)=0$, $u_{y}(x,0,t)=0$, and $u_{y}(x,L_{y},t)=0$.\n- **Spatial Discretization:** A uniform grid with $x_{i}=i\\,\\Delta x$ for $i=0,1,\\dots,N_{x}$ where $\\Delta x=L_{x}/N_{x}$, and $y_{j}=j\\,\\Delta y$ for $j=0,1,\\dots,N_{y}$ where $\\Delta y=L_{y}/N_{y}$.\n- **Temporal Discretization:** A uniform time step $\\Delta t>0$ with $t_n = n\\,\\Delta t$. The solution at a grid point $(x_i, y_j)$ and time $t_n$ is denoted $u_{i,j}^{n}$.\n- **Numerical Scheme:** Forward Time Centered Space (FTCS).\n- **Discrete BC Implementation:** Second-order centered differences with ghost nodes, specified by the relations $u_{-1,j}^{n}=u_{1,j}^{n}$, $u_{N_{x}+1,j}^{n}=u_{N_{x}-1,j}^{n}$, $u_{i,-1}^{n}=u_{i,1}^{n}$, and $u_{i,N_{y}+1}^{n}=u_{i,N_{y}-1}^{n}$.\n- **Non-dimensional Parameters:** $r_{x}=\\kappa\\,\\Delta t/\\Delta x^{2}$ and $r_{y}=\\kappa\\,\\Delta t/\\Delta y^{2}$.\n- **Objective:** Determine the largest permissible value of $r_{x}+r_{y}$ that guarantees stability of the FTCS scheme.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is critically evaluated based on the extracted givens:\n- **Scientifically Grounded:** The problem is based on the heat equation, a fundamental parabolic partial differential equation (PDE) in physics and engineering. The FTCS method is a standard, albeit simple, numerical scheme for solving such PDEs. The stability analysis is a cornerstone of numerical analysis. The problem is free of any pseudoscience or factual errors.\n- **Well-Posed:** The problem provides a clear PDE, domain, and boundary conditions. The discretization method and the treatment of boundary conditions are specified unambiguously. The question asks for a single, derivable numerical value, the stability limit, which is known to exist and be unique for this setup.\n- **Objective:** The language is precise, technical, and free of any subjectivity or ambiguity. All terms are standard in the field of numerical PDEs.\n- **Completeness and Consistency:** The problem is self-contained. All necessary information to derive the stability criterion is provided. The use of ghost points to implement Neumann boundary conditions is consistent with the second-order centered difference stencils.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, objective, and internally consistent. A solution will now be derived.\n\nThe first step is to write down the discrete form of the governing partial differential equation using the Forward Time Centered Space (FTCS) scheme. The time derivative is approximated by a forward difference, and the spatial derivatives are approximated by centered differences:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = \\kappa \\left( \\frac{u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n}{\\Delta x^2} + \\frac{u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n}{\\Delta y^2} \\right)\n$$\nThis equation holds for all grid points, including the boundaries, provided we use the specified ghost node conditions. Let's rearrange the equation to express the solution at the new time step, $u_{i,j}^{n+1}$, in terms of the solutions at the current time step, $u^n$:\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + \\frac{\\kappa \\Delta t}{\\Delta x^2} (u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + \\frac{\\kappa \\Delta t}{\\Delta y^2} (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\nIntroducing the non-dimensional parameters $r_x = \\kappa \\Delta t / \\Delta x^2$ and $r_y = \\kappa \\Delta t / \\Delta y^2$, the update equation becomes:\n$$\nu_{i,j}^{n+1} = u_{i,j}^n + r_x (u_{i+1,j}^n - 2u_{i,j}^n + u_{i-1,j}^n) + r_y (u_{i,j+1}^n - 2u_{i,j}^n + u_{i,j-1}^n)\n$$\nThis can be regrouped as:\n$$\nu_{i,j}^{n+1} = (1 - 2r_x - 2r_y)u_{i,j}^n + r_x(u_{i+1,j}^n + u_{i-1,j}^n) + r_y(u_{i,j+1}^n + u_{i,j-1}^n)\n$$\nTo perform a modal or von Neumann stability analysis, we investigate the amplification of individual spatial modes. The analytical solution to the continuous problem with homogeneous Neumann boundary conditions can be expressed as a Fourier-cosine series. This motivates the choice of a discrete trial solution that has the same spatial form. A single mode can be represented as:\n$$\nu_{i,j}^n = A(\\Delta t)^n \\cos\\left(\\frac{p\\pi x_i}{L_x}\\right) \\cos\\left(\\frac{q\\pi y_j}{L_y}\\right)\n$$\nwhere $p$ and $q$ are integer wavenumbers. Substituting $x_i = i\\Delta x = i L_x/N_x$ and $y_j = j\\Delta y = j L_y/N_y$, we get:\n$$\nu_{i,j}^n = G^n \\cos\\left(\\frac{p\\pi i}{N_x}\\right) \\cos\\left(\\frac{q\\pi j}{N_y}\\right)\n$$\nHere, $G$ is the amplification factor per time step. The integers $p$ and $q$ represent the mode numbers, ranging from $p=0, 1, \\dots, N_x$ and $q=0, 1, \\dots, N_y$ to represent all unique modes on the grid. This form of solution inherently satisfies the discrete Neumann boundary conditions. For instance, at $i=0$, the condition is $u_{-1,j}^n = u_{1,j}^n$. For our trial solution:\n$$\nu_{-1,j}^n = G^n \\cos\\left(\\frac{-p\\pi}{N_x}\\right) \\cos\\left(\\frac{q\\pi j}{N_y}\\right) = G^n \\cos\\left(\\frac{p\\pi}{N_x}\\right) \\cos\\left(\\frac_q\\pi j}{N_y}\\right) = u_{1,j}^n\n$$\nThis holds due to the even property of the cosine function, $\\cos(-\\theta) = \\cos(\\theta)$. The same logic applies to the other three boundaries.\n\nNow, we substitute the trial solution into the discrete update equation. Let $\\phi_p = \\frac{p\\pi}{N_x}$ and $\\phi_q = \\frac{q\\pi}{N_y}$. The trial solution is $u_{i,j}^n = G^n \\cos(i\\phi_p) \\cos(j\\phi_q)$.\nSubstituting into the FTCS equation:\n$$\nG^{n+1} \\cos(i\\phi_p) \\cos(j\\phi_q) = (1 - 2r_x - 2r_y)G^n \\cos(i\\phi_p) \\cos(j\\phi_q) + r_x G^n \\cos(j\\phi_q)[\\cos((i+1)\\phi_p) + \\cos((i-1)\\phi_p)] + r_y G^n \\cos(i\\phi_p)[\\cos((j+1)\\phi_q) + \\cos((j-1)\\phi_q)]\n$$\nWe use the trigonometric identity $\\cos(A+B) + \\cos(A-B) = 2\\cos A \\cos B$.\nThis gives $\\cos((i+1)\\phi_p) + \\cos((i-1)\\phi_p) = 2\\cos(i\\phi_p)\\cos(\\phi_p)$ and similarly for the $y$-direction.\nSubstituting these into the equation and dividing by the common factor $G^n \\cos(i\\phi_p) \\cos(j\\phi_q)$ (which is non-zero for a general mode), we obtain the expression for the amplification factor $G$:\n$$\nG = (1 - 2r_x - 2r_y) + r_x(2\\cos(\\phi_p)) + r_y(2\\cos(\\phi_q))\n$$\n$$\nG = 1 - 2r_x(1 - \\cos(\\phi_p)) - 2r_y(1 - \\cos(\\phi_q))\n$$\nUsing the half-angle identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$\nG = 1 - 4r_x \\sin^2\\left(\\frac{\\phi_p}{2}\\right) - 4r_y \\sin^2\\left(\\frac{\\phi_q}{2}\\right)\n$$\nSubstituting back the definitions of $\\phi_p$ and $\\phi_q$:\n$$\nG(p,q) = 1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\nFor the numerical scheme to be stable, the magnitude of the amplification factor for every mode must not exceed unity, i.e., $|G(p,q)| \\le 1$ for all valid $p$ and $q$. This is equivalent to the condition $-1 \\le G(p,q) \\le 1$.\n\nLet's check each inequality:\n$1$. $G(p,q) \\le 1$:\n$$\n1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\le 1\n$$\n$$\n-4\\left[ r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\right] \\le 0\n$$\nSince $r_x > 0$, $r_y > 0$, and the sine-squared terms are always non-negative, this inequality is always satisfied.\n\n$2$. $G(p,q) \\ge -1$:\n$$\n1 - 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) - 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right) \\ge -1\n$$\n$$\n2 \\ge 4r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + 4r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\n$$\n\\frac{1}{2} \\ge r_x \\sin^2\\left(\\frac{p\\pi}{2N_x}\\right) + r_y \\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)\n$$\nThis condition must hold for all modes, i.e., for all $p \\in \\{0, 1, \\dots, N_x\\}$ and $q \\in \\{0, 1, \\dots, N_y\\}$. To ensure this, we must satisfy the inequality for the \"worst-case\" scenario, which corresponds to the combination of $p$ and $q$ that maximizes the right-hand side of the inequality. The sine-squared terms are maximized when their arguments are as close to $\\pi/2$ as possible.\nThe term $\\sin^2\\left(\\frac{p\\pi}{2N_x}\\right)$ reaches its maximum value of $1$ when $p=N_x$.\nThe term $\\sin^2\\left(\\frac{q\\pi}{2N_y}\\right)$ reaches its maximum value of $1$ when $q=N_y$.\nThese represent the highest frequency modes resolvable by the grid.\n\nSubstituting these maximum values into the stability inequality gives the most restrictive condition:\n$$\n\\frac{1}{2} \\ge r_x (1) + r_y (1)\n$$\n$$\nr_x + r_y \\le \\frac{1}{2}\n$$\nThis is the condition for stability of the FTCS scheme for the $2$D heat equation with homogeneous Neumann boundary conditions. The largest permissible value of the combined non-dimensional time-step parameter $r_x + r_y$ is therefore $\\frac{1}{2}$.",
            "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$"
        },
        {
            "introduction": "While the previous exercises explored fundamental implementation and theory on uniform, isotropic grids, practical problems often involve complex geometries that necessitate anisotropic meshes (where $h_x \\ne h_y$). This practice investigates the significant challenges that mesh anisotropy poses for standard finite difference methods . You will quantify how a large aspect ratio degrades the stability of explicit methods and the conditioning of implicit linear systems, and then explore how a more sophisticated nine-point stencil can mitigate these issues, offering a clear view of the trade-offs involved in choosing a discretization for real-world applications.",
            "id": "3388339",
            "problem": "Consider the two-dimensional heat equation on a rectangle with homogeneous Dirichlet boundary conditions, governed by $$u_t = \\alpha \\, \\nabla^2 u,$$ where $u(x,y,t)$ is the temperature, $t$ is time, $x$ and $y$ are spatial coordinates, and $\\alpha$ is the thermal diffusivity. You will study the impact of mesh anisotropy on the explicit forward Euler stability limit (Courant–Friedrichs–Lewy (CFL) constraint) and on the conditioning of the implicit backward Euler linear system, and then quantify improvements achieved by a mesh-aligned nine-point diffusion discretization compared to the standard five-point stencil.\n\nYour task is to construct discrete Laplacian matrices using two stencils over a uniform but anisotropic Cartesian grid with interior grid sizes $N_x$ and $N_y$. Let the domain be $[0,L_x]\\times[0,L_y]$ with interior grid spacings $$h_x = \\frac{L_x}{N_x+1}, \\qquad h_y = \\frac{L_y}{N_y+1}.$$ Use homogeneous Dirichlet boundary conditions ($u=0$ on the boundary), so the discrete solution is defined on $N_x \\times N_y$ interior points. Define the thermal diffusivity as $$\\alpha = 1 \\text{ m}^2\\text{/s}.$$ For each discretization, form the matrix $L$ that represents the discrete Laplacian operator acting on the vectorized interior grid values.\n\n1. Standard five-point stencil (axis-aligned second-order central differences): for each interior node $(i,j)$, the discrete operator is\n$$\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$$\nIn matrix form, this defines a symmetric negative definite matrix $L_5$.\n\n2. Mesh-aligned nine-point stencil (axis and diagonal neighbors), derived by matching the second-derivative consistency via Taylor expansion and choosing a diagonal weight to reduce spectral radius while preserving consistency. Let the diagonal weight be\n$$w_d = \\frac{1}{3\\left(h_x^2 + h_y^2\\right)}.$$\nThen the axis neighbor weights and the central coefficient are determined by consistency:\n$$w_x = \\frac{1 - 2 w_d h_x^2}{h_x^2}, \\qquad w_y = \\frac{1 - 2 w_d h_y^2}{h_y^2}, \\qquad c_0 = -2 w_x - 2 w_y - 4 w_d.$$\nThe resulting nine-point discrete operator is\n$$\\left(L_9 u\\right)_{i,j} = c_0 \\, u_{i,j} + w_x \\left(u_{i+1,j} + u_{i-1,j}\\right) + w_y \\left(u_{i,j+1} + u_{i,j-1}\\right) + w_d \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right).$$\nIn matrix form, this defines a symmetric negative definite matrix $L_9$. For $h_x = h_y = h$, this reduces to the classical fourth-order accurate nine-point Laplacian with coefficients $$c_0 = -\\frac{10}{3 h^2},\\quad w_x = w_y = \\frac{2}{3 h^2},\\quad w_d = \\frac{1}{6 h^2}.$$\n\nLet the explicit forward Euler scheme be $$u^{n+1} = u^n + \\Delta t \\, \\alpha \\, L \\, u^n.$$ For stability, the largest admissible time step satisfies $$\\Delta t_{\\max} = \\frac{2}{\\alpha \\, \\rho\\!\\left(L\\right)},$$ where $\\rho(L)$ is the spectral radius of $L$ (the largest absolute eigenvalue of $L$), and $L$ is negative definite. For the implicit backward Euler scheme $$\\left(I - \\Delta t \\, \\alpha \\, L\\right) u^{n+1} = u^n,$$ the linear system matrix is symmetric positive definite with eigenvalues $$\\lambda\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = 1 + \\Delta t \\, \\alpha \\, \\left|\\lambda\\!\\left(L\\right)\\right|.$$ Its two-norm condition number is $$\\kappa_2\\!\\left(I - \\Delta t \\, \\alpha \\, L\\right) = \\frac{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\max}^{\\text{abs}}(L)}{1 + \\Delta t \\, \\alpha \\, \\lambda_{\\min}^{\\text{abs}}(L)},$$ where $\\lambda_{\\max}^{\\text{abs}}(L)$ and $\\lambda_{\\min}^{\\text{abs}}(L)$ are the largest and smallest absolute eigenvalues of $L$.\n\nCompute the following quantitative metrics that capture degradation due to mesh anisotropy and improvements due to the nine-point stencil:\n\n- Explicit CFL degradation for the five-point stencil: $$E_{\\text{deg},5}(r) = \\frac{\\Delta t_{\\max,5}(r)}{\\Delta t_{\\max,5}(1)},$$ where $r$ is the mesh aspect ratio defined by $$r = \\frac{h_x}{h_y} = \\frac{L_x(N_y+1)}{L_y(N_x+1)}.$$ The baseline isotropic case has $r=1$.\n- Implicit conditioning degradation for the five-point stencil at a fixed reference time step: choose $$\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1).$$ Then\n$$K_{\\text{deg},5}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(1)\\right)}.$$\n- Explicit CFL improvement factor of nine-point over five-point for the same anisotropic mesh:\n$$E_{\\text{imp}}(r) = \\frac{\\Delta t_{\\max,9}(r)}{\\Delta t_{\\max,5}(r)}.$$\n- Implicit conditioning improvement factor of nine-point over five-point for the same anisotropic mesh at the same $\\Delta t_{\\text{ref}}$:\n$$K_{\\text{imp}}(r) = \\frac{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_9(r)\\right)}{\\kappa_2\\!\\left(I - \\Delta t_{\\text{ref}} \\, \\alpha \\, L_5(r)\\right)}.$$\n\nTest Suite. Use the following parameter sets, all with $N_x = N_y = 12$, $L_x = 1 \\text{ m}$, and $\\alpha = 1 \\text{ m}^2\\text{/s}$:\n- Case A (baseline isotropic): $L_y = 1 \\text{ m}$ so $r=1$.\n- Case B (moderate anisotropy): $L_y = \\frac{1}{5} \\text{ m}$ so $r=5$.\n- Case C (strong anisotropy): $L_y = \\frac{1}{25} \\text{ m}$ so $r=25$.\n- Case D (extreme anisotropy): $L_y = \\frac{1}{50} \\text{ m}$ so $r=50$.\n\nFor each case, compute the quadruple $$\\left[E_{\\text{deg},5}(r),\\, K_{\\text{deg},5}(r),\\, E_{\\text{imp}}(r),\\, K_{\\text{imp}}(r)\\right],$$ which are dimensionless real numbers. Your program should produce a single line of output containing the four case results as a comma-separated list enclosed in square brackets, where each case result is itself a list in the same order. For example, the format must be $$\\left[\\left[e_1,k_1,i_1,j_1\\right],\\left[e_2,k_2,i_2,j_2\\right],\\left[e_3,k_3,i_3,j_3\\right],\\left[e_4,k_4,i_4,j_4\\right]\\right],$$ with each $e_i, k_i, i_i, j_i$ represented as decimal floating-point numbers. No units should be printed since all metrics are dimensionless.",
            "solution": "The user wants to analyze the properties of two different finite difference discretizations of the two-dimensional Laplacian operator, $\\nabla^2$, on an anisotropic Cartesian grid. The analysis focuses on the stability of the explicit forward Euler time integration scheme and the conditioning of the linear system arising from the implicit backward Euler scheme for the 2D heat equation, $u_t = \\alpha \\nabla^2 u$.\n\n### Problem Validation\nThe problem statement has been meticulously validated.\n**Givens Extracted**:\n- PDE: $u_t = \\alpha \\, \\nabla^2 u$ with $\\alpha = 1 \\text{ m}^2\\text{/s}$.\n- Domain: $[0,L_x]\\times[0,L_y]$ with homogeneous Dirichlet boundary conditions.\n- Discretization: $N_x \\times N_y$ interior grid points, with $h_x = \\frac{L_x}{N_x+1}$ and $h_y = \\frac{L_y}{N_y+1}$.\n- Stencils: Standard five-point and a specific mesh-aligned nine-point stencil for the Laplacian operator, yielding matrices $L_5$ and $L_9$.\n- Time-stepping: Explicit Forward Euler and Implicit Backward Euler schemes.\n- Metrics: Definitions for $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$, and $K_{\\text{imp}}(r)$ based on eigenvalues of $L_5$ and $L_9$ and a reference time step $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$.\n- Test Parameters: Constants $N_x=12, N_y=12, L_x=1$. Four cases for $L_y$: $1, 1/5, 1/25, 1/50$, corresponding to mesh aspect ratios $r = h_x/h_y$ of $1, 5, 25, 50$.\n\n**Validation Verdict**:\nThe problem is **valid**. It is scientifically grounded in the numerical analysis of partial differential equations, well-posed with a unique computational solution, and expressed in objective, formal language. All constants, formulas, and procedures are clearly defined and consistent. The problem is a standard, albeit detailed, exercise in the field.\n\n### Solution Approach\n\nThe core of the problem requires computing the minimum and maximum absolute eigenvalues of the discrete Laplacian matrices $L_5$ and $L_9$. For a rectangular domain with Dirichlet boundary conditions, the eigenvectors of these discrete operators are known to be discrete sine functions. This allows for the derivation of analytical expressions for the eigenvalues, obviating the need for numerical eigensolvers and yielding exact results.\n\n**1. Eigenvalues of the 5-point Laplacian ($L_5$)**\nThe discrete operator is:\n$(\\left(L_5 u\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}.$\nIts eigenvalues $\\lambda_{p,q}(L_5)$ for $p=1, \\dots, N_x$ and $q=1, \\dots, N_y$ are given by:\n$$ \\lambda_{p,q}(L_5) = \\frac{2}{h_x^2} \\left( \\cos\\left(\\frac{p \\pi}{N_x+1}\\right) - 1 \\right) + \\frac{2}{h_y^2} \\left( \\cos\\left(\\frac{q \\pi}{N_y+1}\\right) - 1 \\right) $$\nUsing the identity $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$, and noting that all eigenvalues are negative, their absolute values are:\n$$ |\\lambda_{p,q}(L_5)| = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{p \\pi}{2(N_x+1)}\\right) + \\frac{4}{h_y^2} \\sin^2\\left(\\frac{q \\pi}{2(N_y+1)}\\right) $$\nThe minimum and maximum absolute eigenvalues are found by taking $(p,q)=(1,1)$ and $(p,q)=(N_x, N_y)$, respectively.\n\n**2. Eigenvalues of the 9-point Laplacian ($L_9$)**\nThe 9-point operator is defined by coefficients $w_d, w_x, w_y, c_0$. Since the eigenvectors are the same as for $L_5$, we can find the eigenvalues $\\lambda_{p,q}(L_9)$ by applying the operator to a generic eigenvector. This leads to the following expression:\n$$ \\lambda_{p,q}(L_9) = c_0 + 2w_x \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) + 2w_y \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) + 4w_d \\cos\\left(\\frac{p\\pi}{N_x+1}\\right) \\cos\\left(\\frac{q\\pi}{N_y+1}\\right) $$\nSubstituting the definitions for $w_x, w_y,$ and $c_0$ and simplifying algebraically yields a more insightful form:\n$$ \\lambda_{p,q}(L_9) = \\lambda_{p,q}(L_5) + 16 w_d \\sin^2\\left(\\frac{p\\pi}{2(N_x+1)}\\right) \\sin^2\\left(\\frac{q\\pi}{2(N_y+1)}\\right) $$\nSince $w_d = 1/(3(h_x^2+h_y^2)) > 0$ and the sine terms are non-negative, the second term is positive or zero. This confirms that all eigenvalues of $L_9$ are negative (as shown in the thought process) and that $|\\lambda_{p,q}(L_9)| < |\\lambda_{p,q}(L_5)|$ for $p,q > 0$. The minimum and maximum absolute eigenvalues of $L_9$ are found by computing $|\\lambda_{p,q}(L_9)|$ for all pairs $(p,q)$ and finding the minimum and maximum of the resulting values.\n\n**3. Computation of Metrics**\nWith the ability to calculate the spectral bounds $\\lambda_{\\min}^{\\text{abs}}(L)$ and $\\lambda_{\\max}^{\\text{abs}}(L)$ for both stencils, we can compute the required metrics.\n\nFirst, the baseline isotropic case ($r=1$) is computed to establish $\\Delta t_{\\max,5}(1)$ and the reference condition number $\\kappa_2(I - \\Delta t_{\\text{ref}} \\alpha L_5(1))$. The reference time step is $\\Delta t_{\\text{ref}} = 0.9 \\, \\Delta t_{\\max,5}(1)$.\n\nThen, for each test case (including the baseline), we compute:\n- $\\Delta t_{\\max,5}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}$\n- $\\Delta t_{\\max,9}(r) = \\frac{2}{\\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}$\n- $\\kappa_{2,5}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_5(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_5(r))}$\n- $\\kappa_{2,9}(r) = \\frac{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\max}^{\\text{abs}}(L_9(r))}{1 + \\Delta t_{\\text{ref}} \\alpha \\lambda_{\\min}^{\\text{abs}}(L_9(r))}$\n\nFinally, these values are used to compute the four dimensionless ratios $E_{\\text{deg},5}(r)$, $K_{\\text{deg},5}(r)$, $E_{\\text{imp}}(r)$, and $K_{\\text{imp}}(r)$ as defined in the problem statement.\n\nThe implementation will follow this analytical approach for precision and efficiency. A Python script will perform these calculations for the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef get_eigenvalues_L5(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 5-point discrete Laplacian\n    using the analytical formula.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Eigenvalues of 1D Laplacians in x and y directions\n    lambda_p_abs = (4 / hx**2) * np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    lambda_q_abs = (4 / hy**2) * np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # 2D eigenvalues are sums of 1D eigenvalues.\n    # The smallest is sum of smallest, largest is sum of largest.\n    lambda_min_abs = lambda_p_abs[0] + lambda_q_abs[0]\n    lambda_max_abs = lambda_p_abs[-1] + lambda_q_abs[-1]\n    \n    return lambda_min_abs, lambda_max_abs\n\ndef get_eigenvalues_L9(Nx, Ny, hx, hy):\n    \"\"\"\n    Computes the min and max absolute eigenvalues of the 9-point discrete Laplacian\n    by correcting the 5-point eigenvalues.\n    \"\"\"\n    p = np.arange(1, Nx + 1)\n    q = np.arange(1, Ny + 1)\n    \n    # Pre-calculate sine-squared terms\n    sp_sq = np.sin(p * np.pi / (2 * (Nx + 1)))**2\n    sq_sq = np.sin(q * np.pi / (2 * (Ny + 1)))**2\n    \n    # Matrix of absolute eigenvalues for the 5-point stencil\n    lambda5_abs_mat = np.add.outer((4 / hx**2) * sp_sq, (4 / hy**2) * sq_sq)\n    \n    # Diagonal weight for the 9-point stencil\n    wd = 1 / (3 * (hx**2 + hy**2))\n    \n    # Correction term to get 9-point eigenvalues from 5-point\n    correction_mat = 16 * wd * np.outer(sp_sq, sq_sq)\n    \n    # Matrix of absolute eigenvalues for the 9-point stencil\n    # As derived, lambda9 = lambda5 + correction, and lambda5 is negative.\n    # So |lambda9| = |lambda5| - correction.\n    lambda9_abs_mat = lambda5_abs_mat - correction_mat\n    \n    lambda_min_abs = np.min(lambda9_abs_mat)\n    lambda_max_abs = np.max(lambda9_abs_mat)\n    \n    return lambda_min_abs, lambda_max_abs\n    \ndef solve():\n    \"\"\"\n    Main function to orchestrate the calculation of metrics for all test cases.\n    \"\"\"\n    # Global parameters\n    Nx = 12\n    Ny = 12\n    Lx = 1.0\n    alpha = 1.0\n    \n    # Test cases defined by Ly values\n    test_cases = [\n        1.0,        # Case A: r=1\n        1.0 / 5.0,  # Case B: r=5\n        1.0 / 25.0, # Case C: r=25\n        1.0 / 50.0  # Case D: r=50\n    ]\n\n    # --- Baseline Calculation (r=1) ---\n    Ly_base = test_cases[0]\n    hx_base = Lx / (Nx + 1)\n    hy_base = Ly_base / (Ny + 1)\n\n    lambda_min_5_base, lambda_max_5_base = get_eigenvalues_L5(Nx, Ny, hx_base, hy_base)\n    \n    dt_max_5_base = 2.0 / (alpha * lambda_max_5_base)\n    dt_ref = 0.9 * dt_max_5_base\n    \n    kappa_5_base = (1 + dt_ref * alpha * lambda_max_5_base) / (1 + dt_ref * alpha * lambda_min_5_base)\n\n    results = []\n    \n    # --- Loop over all cases ---\n    for Ly in test_cases:\n        hx = Lx / (Nx + 1)\n        hy = Ly / (Ny + 1)\n        \n        # --- 5-point stencil calculations ---\n        lambda_min_5, lambda_max_5 = get_eigenvalues_L5(Nx, Ny, hx, hy)\n        \n        dt_max_5 = 2.0 / (alpha * lambda_max_5)\n        E_deg_5 = dt_max_5 / dt_max_5_base\n        \n        kappa_5 = (1 + dt_ref * alpha * lambda_max_5) / (1 + dt_ref * alpha * lambda_min_5)\n        K_deg_5 = kappa_5 / kappa_5_base\n        \n        # --- 9-point stencil calculations ---\n        lambda_min_9, lambda_max_9 = get_eigenvalues_L9(Nx, Ny, hx, hy)\n        \n        dt_max_9 = 2.0 / (alpha * lambda_max_9)\n        E_imp = dt_max_9 / dt_max_5\n        \n        kappa_9 = (1 + dt_ref * alpha * lambda_max_9) / (1 + dt_ref * alpha * lambda_min_9)\n        K_imp = kappa_9 / kappa_5\n        \n        # Store the quadruple of metrics for the current case\n        results.append([E_deg_5, K_deg_5, E_imp, K_imp])\n\n    # Format output as a single-line string representation of a list of lists.\n    # The problem's output template suggests this formatting strategy.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}