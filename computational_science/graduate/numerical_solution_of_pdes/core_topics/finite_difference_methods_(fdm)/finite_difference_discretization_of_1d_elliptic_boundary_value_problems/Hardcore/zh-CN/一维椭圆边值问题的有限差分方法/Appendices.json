{
    "hands_on_practices": [
        {
            "introduction": "掌握任何数值方法的第一步都是构建一个可用的程序，并严格验证其正确性和准确性。这个练习将引导你使用“人造解方法”（Method of Manufactured Solutions, MMS）这一强大的验证工具，来检验你实现的有限差分格式是否达到了预期的收敛阶。此外，你还将学习并应用理查森外推法（Richardson extrapolation），这是一种在不增加计算模型复杂性的前提下，有效提升特定点解的精度的技巧。通过这个实践，你将为成为一名合格的计算科学家奠定坚实的基础。",
            "id": "3392829",
            "problem": "考虑闭区间 $[0,1]$ 上的一维线性二阶椭圆边值问题，其守恒形式如下：\n$$\n-\\frac{d}{dx}\\left(a(x)\\,\\frac{du(x)}{dx}\\right) + c(x)\\,u(x) = f(x).\n$$\n您将使用制造解方法（Method of Manufactured Solutions, MMS）验证一个二阶守恒有限差分离散的精度，然后应用理查森外推（Richardson extrapolation）来改进一个点态解的估计值。所有三角函数的参数都应解释为弧度。\n\n基本定义与离散化。设 $N\\in\\mathbb{N}$ 为均匀子区间的数量，$h = 1/N$ 为网格间距，$x_i = i\\,h$（其中 $i=0,1,\\dots,N$）为网格节点。对于内部索引 $i=1,\\dots,N-1$，定义中点位置 $x_{i\\pm \\frac{1}{2}} = x_i \\pm \\frac{h}{2}$。内部节点的二阶守恒有限差分格式是根据守恒形式和扩散系数的中点求值构建的：\n$$\n-\\frac{1}{h}\\left(a\\!\\left(x_{i+\\frac{1}{2}}\\right)\\frac{u_{i+1}-u_i}{h} - a\\!\\left(x_{i-\\frac{1}{2}}\\right)\\frac{u_i-u_{i-1}}{h}\\right) + c(x_i)\\,u_i = f(x_i).\n$$\n对于 $x=0$ 和 $x=1$ 处的狄利克雷（Dirichlet）边界条件，将 $u_0$ 和 $u_N$ 设置为精确的边界值。对于 $x=0$ 处形式为\n$$\n\\alpha\\,u(0) + \\beta\\,u'(0) = \\gamma,\n$$\n的罗宾（Robin）边界条件，使用二阶单边差分近似\n$$\nu'(0) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h},\n$$\n来强制执行该边界方程，并将此方程作为线性系统的第一个方程（内部方程位于 $i=1,\\dots,N-1$，而右侧在 $x=1$ 处的狄利克雷边界通过代入 $u_N$ 来施加）。\n\n制造解方法（MMS）。对于下面的每个测试，选择一个光滑的精确解 $u_{\\text{ex}}(x)$，并通过将 $u_{\\text{ex}}(x)$ 代入微分算子来定义数据 $f(x)$：\n$$\nf(x) = -\\left(a(x)\\,u_{\\text{ex}}''(x) + a'(x)\\,u_{\\text{ex}}'(x)\\right) + c(x)\\,u_{\\text{ex}}(x).\n$$\n使用 $u_{\\text{ex}}$ 以及在需要时使用 $u_{\\text{ex}}'$ 来精确施加边界条件。\n\n观测精度阶与理查森外推。设 $\\|e_h\\|_{\\infty}$ 表示在间距为 $h$ 的网格上的最大范数误差，定义为 $\\|e_h\\|_{\\infty} = \\max_{0\\le i\\le N} |u_i - u_{\\text{ex}}(x_i)|$（当两个端点都包含在未知数中时），或定义为所有节点上的最大值（包括精确边界值）（当狄利克雷值被施加时）。从两个尺寸分别为 $h$ 和 $h/2$ 的嵌套网格计算出的观测阶为\n$$\np_{\\infty} = \\log_2\\!\\left(\\frac{\\|e_h\\|_{\\infty}}{\\|e_{h/2}\\|_{\\infty}}\\right).\n$$\n给定在固定点 $x^\\star\\in(0,1)$ 处对 $u(x^\\star)$ 的近似值 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$（通过两个网格的线性插值获得），以及收敛阶的估计值 $p$，理查森外推值是\n$$\nU_{\\text{RE}}(x^\\star) = \\frac{2^p\\,U_{h/2}(x^\\star) - U_{h}(x^\\star)}{2^p - 1}.\n$$\n\n任务。实现上述有限差分方法，使用MMS在测试套件上验证观测阶，并在指定点执行理查森外推。您的程序必须解决以下三个制造解测试问题：\n\n- 测试 A（光滑变系数，狄利克雷-狄利克雷）：\n  - $a(x) = 2 + \\sin(3x)$,\n  - $c(x) = 1 + x$,\n  - $u_{\\text{ex}}(x) = e^{x}\\,\\sin(2\\pi x)$,\n  - 边界： $u(0) = u_{\\text{ex}}(0)$, $u(1) = u_{\\text{ex}}(1)$。\n\n- 测试 B（扩散主导，狄利克雷-狄利克雷）：\n  - $a(x) = e^{x}$,\n  - $c(x) = 0$,\n  - $u_{\\text{ex}}(x) = \\sin(5x)$,\n  - 边界： $u(0) = u_{\\text{ex}}(0)$, $u(1) = u_{\\text{ex}}(1)$。\n\n- 测试 C（可变扩散与反应，罗宾-狄利克雷）：\n  - $a(x) = 1 + x$,\n  - $c(x) = 2$,\n  - $u_{\\text{ex}}(x) = \\cos(3\\pi x)$,\n  - 左边界（$x=0$ 处的罗宾条件）： $\\alpha = 1$, $\\beta = 1$, $\\gamma = \\alpha\\,u_{\\text{ex}}(0) + \\beta\\,u_{\\text{ex}}'(0)$,\n  - 右边界（$x=1$ 处的狄利克雷条件）： $u(1) = u_{\\text{ex}}(1)$。\n\n数值实验规格：\n\n- 对于每个测试，使用来自两个网格尺寸 $N = 64$ 和 $N = 128$（因此 $h = 1/64$ 和 $h/2 = 1/128$）的无穷范数误差计算观测阶 $p_{\\infty}$。\n- 仅对于测试 A，在内点 $x^\\star = 0.37$ 处执行理查森外推。分别通过对 $N=64$ 和 $N=128$ 网格的离散解进行线性插值来计算 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$。使用为测试 A 计算的观测阶 $p_{\\infty}$ 来构成 $U_{\\text{RE}}(x^\\star)$，并以浮点数形式报告绝对误差 $|U_{\\text{RE}}(x^\\star)-u_{\\text{ex}}(x^\\star)|$。\n\n角度单位：所有三角函数均使用弧度。\n\n最终输出格式：您的程序必须生成一行包含四个浮点数的Python风格列表\n$$\n\\big[\\,p_{\\infty}^{(A)},\\; p_{\\infty}^{(B)},\\; p_{\\infty}^{(C)},\\; E_{\\text{RE}}^{(A)}(x^\\star)\\,\\big],\n$$\n其中 $p_{\\infty}^{(A)}$、$p_{\\infty}^{(B)}$ 和 $p_{\\infty}^{(C)}$ 分别是测试 A、B 和 C 的观测阶，而 $E_{\\text{RE}}^{(A)}(x^\\star)$ 是测试 A 在 $x^\\star = 0.37$ 处的绝对理查森外推误差。程序应以如下形式精确打印一行\n$$\n[{\\tt pA},{\\tt pB},{\\tt pC},{\\tt errRE}]\n$$\n并用数值替换占位符。",
            "solution": "经评估，用户提供的问题是有效的。在偏微分方程数值分析领域，这是一个适定的、科学上合理的、完整的问题。所有必需的数据、函数和过程都已明确定义。任务涉及实现一个标准的二阶有限差分方法，使用制造解方法验证其精度，并应用理查son外推，所有这些都是标准且严谨的技术。\n\n我们着手提供一个完整的解决方案。\n\n### 1. 问题公式化与离散化\n\n控制方程为一维椭圆边值问题，以守恒形式给出：\n$$\n-\\frac{d}{dx}\\left(a(x)\\,\\frac{du(x)}{dx}\\right) + c(x)\\,u(x) = f(x) \\quad \\text{for } x \\in [0, 1].\n$$\n我们使用具有 $N$ 个子区间的均匀网格对定义域 $[0, 1]$ 进行离散化，得到网格间距 $h=1/N$。网格节点表示为 $x_i = i h$，其中 $i=0, 1, \\dots, N$。在这些节点上的数值解为 $u_i \\approx u(x_i)$。\n\n该方法的核心是针对内部节点 $x_i$（其中 $i=1, \\dots, N-1$）的二阶精度守恒有限差分格式：\n$$\n-\\frac{1}{h}\\left(a\\left(x_{i+\\frac{1}{2}}\\right)\\frac{u_{i+1}-u_i}{h} - a\\left(x_{i-\\frac{1}{2}}\\right)\\frac{u_i-u_{i-1}}{h}\\right) + c(x_i)\\,u_i = f(x_i).\n$$\n此处，$x_{i \\pm \\frac{1}{2}} = x_i \\pm \\frac{h}{2}$ 是网格节点之间的中点。为便于组装线性系统，我们将方程两边乘以 $h^2$ 并收集对应于 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项：\n$$\n-a\\left(x_{i-\\frac{1}{2}}\\right) u_{i-1} + \\left(a\\left(x_{i+\\frac{1}{2}}\\right) + a\\left(x_{i-\\frac{1}{2}}\\right) + h^2 c(x_i)\\right) u_i - a\\left(x_{i+\\frac{1}{2}}\\right) u_{i+1} = h^2 f(x_i).\n$$\n该方程对每个内部节点都成立，并构成一个线性方程组 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是未知节点值的向量。$A$ 和 $\\mathbf{b}$ 的具体结构取决于边界条件。\n\n### 2. 边界条件\n\n#### 2.1. 狄利克雷-狄利克雷边界条件（测试 A 和 B）\n当给定狄利克雷条件 $u(0)=u_0$ 和 $u(1)=u_N$ 时，$u_0$ 和 $u_N$ 的值是已知的。未知量是内部节点值 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$。方程组的大小为 $(N-1) \\times (N-1)$。\n第一个内部节点 $i=1$ 的方程为：\n$$\n\\left(a\\left(x_{\\frac{3}{2}}\\right) + a\\left(x_{\\frac{1}{2}}\\right) + h^2 c(x_1)\\right) u_1 - a\\left(x_{\\frac{3}{2}}\\right) u_2 = h^2 f(x_1) + a\\left(x_{\\frac{1}{2}}\\right) u_0.\n$$\n最后一个内部节点 $i=N-1$ 的方程为：\n$$\n-a\\left(x_{N-\\frac{3}{2}}\\right) u_{N-2} + \\left(a\\left(x_{N-\\frac{1}{2}}\\right) + a\\left(x_{N-\\frac{3}{2}}\\right) + h^2 c(x_{N-1})\\right) u_{N-1} = h^2 f(x_{N-1}) + a\\left(x_{N-\\frac{1}{2}}\\right) u_N.\n$$\n如果 $a(x)$ 是常数，得到的矩阵 $A$ 是三对角且对称的。对于可变的 $a(x)$，它仍然是三对角的。\n\n#### 2.2. 罗宾-狄利克雷边界条件（测试 C）\n对于 $x=0$ 处的罗宾条件 $\\alpha u(0) + \\beta u'(0) = \\gamma$ 和 $x=1$ 处的狄利克雷条件 $u(1)=u_N$。未知量为 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]^T$。系统的大小为 $N \\times N$。\n\n第一个方程来自罗宾条件，使用了对 $u'(0)$ 的二阶向前差分近似：\n$$\n\\alpha u_0 + \\beta \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma.\n$$\n乘以 $2h$ 并重新整理，得到我们线性系统的第一行：\n$$\n(2h\\alpha - 3\\beta) u_0 + 4\\beta u_1 - \\beta u_2 = 2h\\gamma.\n$$\n$i=1, \\dots, N-2$ 的内部方程遵循标准模板。最后一个方程，即节点 $i=N-1$ 的方程，包含了已知值 $u_N$：\n$$\n-a\\left(x_{N-\\frac{3}{2}}\\right) u_{N-2} + \\left(a\\left(x_{N-\\frac{1}{2}}\\right) + a\\left(x_{N-\\frac{3}{2}}\\right) + h^2 c(x_{N-1})\\right) u_{N-1} = h^2 f(x_{N-1}) + a\\left(x_{N-\\frac{1}{2}}\\right) u_N.\n$$\n得到的矩阵 $A$ 几乎是三对角的，在 $A_{0,2}$ 处有一个额外的非零项。\n\n### 3. 制造解方法（MMS）与误差分析\n\nMMS 用于验证代码的正确性和收敛率。我们选择一个光滑函数 $u_{\\text{ex}}(x)$作为精确解。然后通过将 $u_{\\text{ex}}(x)$ 代入微分算子来制造源项 $f(x)$：\n$$\nf(x) = -\\frac{d}{dx}\\left(a(x)\\,\\frac{du_{\\text{ex}}(x)}{dx}\\right) + c(x)\\,u_{\\text{ex}}(x) = -\\left(a(x)\\,u_{\\text{ex}}''(x) + a'(x)\\,u_{\\text{ex}}'(x)\\right) + c(x)\\,u_{\\text{ex}}(x).\n$$\n边界条件也由 $u_{\\text{ex}}(x)$ 推导得出。在求解得到 $u_i$ 的数值系统后，使用最大范数计算误差：\n$$\n\\|e_h\\|_{\\infty} = \\max_{0 \\le i \\le N} |u_i - u_{\\text{ex}}(x_i)|.\n$$\n对于一个二阶精度的方法，误差的行为应为 $\\|e_h\\|_{\\infty} \\approx C h^2$，其中 $C$ 为某个常数。观测精度阶 $p_{\\infty}$ 是通过在两个间距分别为 $h$ 和 $h/2$ 的嵌套网格上的解计算得出的：\n$$\np_{\\infty} = \\log_2\\left(\\frac{\\|e_h\\|_{\\infty}}{\\|e_{h/2}\\|_{\\infty}}\\right).\n$$\n\n### 4. 理查森外推\n\n理查森外推提高了在特定点 $x^\\star$ 处近似的精度。给定来自网格 $h$ 的解 $U_h(x^\\star)$ 和来自网格 $h/2$ 的解 $U_{h/2}(x^\\star)$，并且知道该方法的首项误差阶为 $p$，一个改进的估计值为：\n$$\nU_{\\text{RE}}(x^\\star) = U_{h/2}(x^\\star) + \\frac{U_{h/2}(x^\\star) - U_h(x^\\star)}{2^p - 1} = \\frac{2^p U_{h/2}(x^\\star) - U_h(x^\\star)}{2^p - 1}.\n$$\n值 $U_h(x^\\star)$ 和 $U_{h/2}(x^\\star)$ 是通过对离散解进行线性插值得到的。如果 $x_j \\le x^\\star \\le x_{j+1}$，插值后的值为：\n$$\nU(x^\\star) = u_j + (u_{j+1} - u_j) \\frac{x^\\star - x_j}{h}.\n$$\n对于这个问题，我们在外推公式中使用数值观测阶 $p=p_{\\infty}$。\n\n### 5. 测试案例的实现\n\n所述方法论应用于三个测试案例。对于每个案例，我们定义特定的函数 $a(x)$、$c(x)$、$u_{\\text{ex}}(x)$ 及其导数，以计算源项 $f(x)$ 和边界数据。\n\n- **测试 A：** $a(x) = 2 + \\sin(3x)$，$c(x) = 1 + x$，$u_{\\text{ex}}(x) = e^x\\sin(2\\pi x)$。\n- **测试 B：** $a(x) = e^x$，$c(x) = 0$，$u_{\\text{ex}}(x) = \\sin(5x)$。\n- **测试 C：** $a(x) = 1 + x$，$c(x) = 2$，$u_{\\text{ex}}(x) = \\cos(3\\pi x)$。\n\n对于每个测试，我们求解 $N=64$ 和 $N=128$ 的系统，计算误差 $\\|e_{1/64}\\|_{\\infty}$ 和 $\\|e_{1/128}\\|_{\\infty}$，并找出观测阶 $p_{\\infty}$。对于测试 A，我们额外在 $x^\\star = 0.37$ 处使用来自 $N=64$ 和 $N=128$ 的解以及为测试 A 计算出的 $p_{\\infty}$ 来执行理查森外推，并报告此外推值的绝对误差。\n\n最终输出包含三个观测阶和一个外推误差，以四个浮点数的列表形式呈現。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases specified in the problem, computes observed\n    orders of accuracy, performs Richardson extrapolation for Test A, and\n    prints the results in the specified format.\n    \"\"\"\n\n    # --- Test Case A: Smooth variable coefficients, Dirichlet-Dirichlet ---\n    def get_test_A():\n        case = {\n            'a': lambda x: 2 + np.sin(3*x),\n            'a_prime': lambda x: 3 * np.cos(3*x),\n            'c': lambda x: 1 + x,\n            'u_ex': lambda x: np.exp(x) * np.sin(2*np.pi*x),\n            'u_ex_prime': lambda x: np.exp(x) * (np.sin(2*np.pi*x) + 2*np.pi*np.cos(2*np.pi*x)),\n            'u_ex_double_prime': lambda x: np.exp(x) * ((1 - 4*np.pi**2)*np.sin(2*np.pi*x) + 4*np.pi*np.cos(2*np.pi*x)),\n            'bc_type': ('dirichlet', 'dirichlet'),\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        case['bc_left_val'] = case['u_ex'](0.0)\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    # --- Test Case B: Diffusion-dominated, Dirichlet-Dirichlet ---\n    def get_test_B():\n        case = {\n            'a': lambda x: np.exp(x),\n            'a_prime': lambda x: np.exp(x),\n            'c': lambda x: 0.0,\n            'u_ex': lambda x: np.sin(5*x),\n            'u_ex_prime': lambda x: 5 * np.cos(5*x),\n            'u_ex_double_prime': lambda x: -25 * np.sin(5*x),\n            'bc_type': ('dirichlet', 'dirichlet'),\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        case['bc_left_val'] = case['u_ex'](0.0)\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    # --- Test Case C: Variable diffusion and reaction, Robin-Dirichlet ---\n    def get_test_C():\n        alpha, beta = 1.0, 1.0\n        case = {\n            'a': lambda x: 1 + x,\n            'a_prime': lambda x: 1.0,\n            'c': lambda x: 2.0,\n            'u_ex': lambda x: np.cos(3*np.pi*x),\n            'u_ex_prime': lambda x: -3 * np.pi * np.sin(3*np.pi*x),\n            'u_ex_double_prime': lambda x: -9 * np.pi**2 * np.cos(3*np.pi*x),\n            'bc_type': ('robin', 'dirichlet'),\n            'robin_params': (alpha, beta)\n        }\n        case['f'] = lambda x: -(case['a'](x)*case['u_ex_double_prime'](x) + case['a_prime'](x)*case['u_ex_prime'](x)) + case['c'](x)*case['u_ex'](x)\n        gamma = alpha * case['u_ex'](0.0) + beta * case['u_ex_prime'](0.0)\n        case['bc_left_val'] = gamma\n        case['bc_right_val'] = case['u_ex'](1.0)\n        return case\n\n    test_cases = [get_test_A(), get_test_B(), get_test_C()]\n    results = []\n\n    for i, case in enumerate(test_cases):\n        # Solve for N=64\n        u_h, x_h = solve_bvp(64, case)\n        u_ex_h = case['u_ex'](x_h)\n        err_h = np.linalg.norm(u_h - u_ex_h, np.inf)\n        \n        # Solve for N=128\n        u_h_2, x_h_2 = solve_bvp(128, case)\n        u_ex_h_2 = case['u_ex'](x_h_2)\n        err_h_2 = np.linalg.norm(u_h_2 - u_ex_h_2, np.inf)\n        \n        # Compute observed order\n        p_inf = np.log2(err_h / err_h_2)\n        results.append(p_inf)\n        \n        # Perform Richardson Extrapolation for Test A\n        if i == 0:\n            x_star = 0.37\n            \n            # Interpolate for N=64\n            h = 1.0/64\n            j = int(x_star / h)\n            U_h_star = u_h[j] + (u_h[j+1] - u_h[j]) * (x_star - x_h[j]) / h\n            \n            # Interpolate for N=128\n            h_2 = 1.0/128\n            j_2 = int(x_star / h_2)\n            U_h_2_star = u_h_2[j_2] + (u_h_2[j_2+1] - u_h_2[j_2]) * (x_star - x_h_2[j_2]) / h_2\n            \n            # Extrapolate\n            U_RE = (2**p_inf * U_h_2_star - U_h_star) / (2**p_inf - 1)\n            \n            # Compute error\n            u_ex_star = case['u_ex'](x_star)\n            err_RE = np.abs(U_RE - u_ex_star)\n            \n            # Store results, but need to append the error at the end\n            extrap_error = err_RE\n\n    # Reorder results to match output format\n    final_results = [results[0], results[1], results[2], extrap_error]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\n\ndef solve_bvp(N, case):\n    \"\"\"\n    General solver for the 1D BVP.\n    Assembles and solves the linear system based on the boundary condition types.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(0, 1, N + 1)\n    \n    a_func = case['a']\n    c_func = case['c']\n    f_func = case['f']\n    bc_type = case['bc_type']\n    \n    if bc_type == ('dirichlet', 'dirichlet'):\n        # --- Dirichlet-Dirichlet System Assembly ---\n        # Unknowns are u_1, ..., u_{N-1}\n        num_unknowns = N - 1\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        u0 = case['bc_left_val']\n        uN = case['bc_right_val']\n\n        for i in range(1, N):\n            idx = i - 1 # Matrix index\n            \n            x_i = x[i]\n            x_imhalf = x_i - h/2\n            x_iphalf = x_i + h/2\n            \n            a_imhalf = a_func(x_imhalf)\n            a_iphalf = a_func(x_iphalf)\n            \n            diag_val = a_iphalf + a_imhalf + h**2 * c_func(x_i)\n            \n            A[idx, idx] = diag_val\n            if i > 1:\n                A[idx, idx - 1] = -a_imhalf\n            if i  N - 1:\n                A[idx, idx + 1] = -a_iphalf\n            \n            b[idx] = h**2 * f_func(x_i)\n            \n            # Boundary contributions to RHS\n            if i == 1:\n                b[idx] += a_imhalf * u0\n            if i == N - 1:\n                b[idx] += a_iphalf * uN\n        \n        u_interior = np.linalg.solve(A, b)\n        u_full = np.concatenate(([u0], u_interior, [uN]))\n\n    elif bc_type == ('robin', 'dirichlet'):\n        # --- Robin-Dirichlet System Assembly ---\n        # Unknowns are u_0, ..., u_{N-1}\n        num_unknowns = N\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        alpha, beta = case['robin_params']\n        gamma = case['bc_left_val']\n        uN = case['bc_right_val']\n        \n        # Row 0: Robin condition at x=0\n        A[0, 0] = 2*h*alpha - 3*beta\n        A[0, 1] = 4*beta\n        A[0, 2] = -beta\n        b[0] = 2*h*gamma\n        \n        # Rows 1 to N-1: Interior finite difference equations\n        for i in range(1, N):\n            x_i = x[i]\n            x_imhalf = x_i - h/2\n            x_iphalf = x_i + h/2\n            \n            a_imhalf = a_func(x_imhalf)\n            a_iphalf = a_func(x_iphalf)\n            \n            diag_val = a_iphalf + a_imhalf + h**2 * c_func(x_i)\n            \n            A[i, i] = diag_val\n            A[i, i - 1] = -a_imhalf\n            if i  N - 1:\n                A[i, i + 1] = -a_iphalf\n                \n            b[i] = h**2 * f_func(x_i)\n            \n            # Boundary contribution to RHS for last equation\n            if i == N - 1:\n                b[i] += a_iphalf * uN\n\n        u_solved = np.linalg.solve(A, b)\n        u_full = np.concatenate((u_solved, [uN]))\n    else:\n        raise ValueError(\"Unsupported boundary condition configuration.\")\n\n    return u_full, x\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的问题，如复合材料或地下水流动，往往涉及具有不同物理属性的介质，这在偏微分方程中表现为不连续的系数。本练习将揭示，在这种情况下，一个看似合理的“朴素”离散格式（如算术平均）可能会导致较大的误差。你将通过从物理第一性原理出发，推导并实现一种更为稳健的“调和平均”方法来处理材料界面处的通量，并亲手验证它在处理系数存在尖锐跳跃问题时的优越性。这个实践将深化你对物理原则、数值稳定性和离散格式设计之间紧密联系的理解。",
            "id": "3392861",
            "problem": "考虑区间 $[0,1]$ 上的具有齐次狄利克雷边界条件的一维椭圆边值问题，\n$$\n-(a(x)\\,u'(x))' + c(x)\\,u(x) = f(x),\\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中 $a(x)0$ 是扩散系数，$c(x)\\ge 0$ 是反应系数，$f(x)$ 是给定的源项。目标是构建一个守恒、对称且 $L^2$-稳定的有限差分离散格式，该格式在 $a(x)$ 出现急剧跳变时仍保持稳健。你必须使用通过调和平均定义的界面系数来构建离散通量，并将其在 $a(x)$ 剧烈变化问题上的性能与算术平均进行比较。\n\n仅从基本定义（通量的守恒性与相容性、对称性以及离散双线性形式的正定性）出发，推导一个在具有 $m$ 个分段的均匀网格（因此网格尺寸为 $h=1/m$，网格点为 $x_j=jh$，$j=0,1,\\dots,m$）上的二阶守恒有限差分格式。未知量为内部节点值 $u_j\\approx u(x_j)$，$j=1,\\dots,m-1$。对于每个内部节点 $j$，使用以下方法构建跨越界面 $x_{j\\pm 1/2}$ 的离散通量：\n- 调和平均值 $H(a_j,a_{j+1})=\\dfrac{2\\,a_j\\,a_{j+1}}{a_j+a_{j+1}}$，以及\n- 算术平均值 $A(a_j,a_{j+1})=\\dfrac{a_j+a_{j+1}}{2}$，\n其中 $a_j:=a(x_j)$。\n\n待使用的测试问题必须具有以下形式\n- 定义域 $[0,1]$；\n- 齐次狄利克雷边界条件 $u(0)=u(1)=0$；\n- 反应系数 $c(x)=0$；\n- 源项 $f(x)=1$（应以与未知量 $u$ 一致的单位来解释；由于这纯粹是数学问题陈述，请勿附加物理单位）；\n- 扩散系数 $a(x)$ 为分段常数，在 $x=0.5$ 处有急剧跳变，\n$$\na(x) =\n\\begin{cases}\n1,  x  0.5 \\\\\n\\alpha,  x \\ge 0.5\n\\end{cases}\n$$\n其中 $\\alpha0$ 是一个控制跳变大小的参数。\n\n你的推导必须证明为何在界面处使用调和平均会产生一个 $L^2$-稳定的离散算子，并必须解释对称性和正定性（矫顽性）对于所得到的线性系统意味着什么。推导过程不得使用最终离散算子的简便公式；它必须从守恒通量平衡和界面系数的定义出发。\n\n实现两种离散化方法（调和平均和算术平均），并对每种方法，在具有 $m=200$ 个分段（因此 $h=1/200$）的均匀网格上求解得到的线性系统。为进行误差评估，请使用通过分段求解问题并保证 $u$ 的连续性以及通量 $a\\,u'$ 在 $x=0.5$ 处的连续性所获得的精确解。计算离散 $L^2$ 误差\n$$\nE = \\left(h\\,\\sum_{j=1}^{m-1} \\left(u_j - u(x_j)\\right)^2\\right)^{1/2},\n$$\n对调和平均和算术平均两种方法都进行计算。\n\n此外，为定量地验证 $L^2$-稳定性和对称性，请计算每种平均策略下离散算子的最小特征值，并报告其是否严格为正，这表明矩阵是对称正定（SPD）的。你还必须报告每个测试案例的误差比 $E_A/E_H$。\n\n测试套件：\n- 案例 1：$\\alpha=1$（无跳变）。\n- 案例 2：$\\alpha=10^{-3}$（右侧扩散非常小）。\n- 案例 3：$\\alpha=10^{3}$（右侧扩散非常大）。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个案例，按顺序输出以下五个量：\n- $E_H$：调和平均的 $L^2$ 误差（一个浮点数），\n- $E_A$：算术平均的 $L^2$ 误差（一个浮点数），\n- $\\mathrm{SPD}_H$：一个布尔值，指示调和平均矩阵是否为 SPD（如果其最小特征值严格为正，则为 true），\n- $\\mathrm{SPD}_A$：一个布尔值，指示算术平均矩阵是否为 SPD，\n- $R$：误差比 $E_A/E_H$（一个浮点数）。\n\n因此，最终输出应将所有三个案例的结果汇总为一个长度为 15 的列表，顺序如下\n$$\n[E_H^{(1)},E_A^{(1)},\\mathrm{SPD}_H^{(1)},\\mathrm{SPD}_A^{(1)},R^{(1)},E_H^{(2)},E_A^{(2)},\\mathrm{SPD}_H^{(2)},\\mathrm{SPD}_A^{(2)},R^{(2)},E_H^{(3)},E_A^{(3)},\\mathrm{SPD}_H^{(3)},\\mathrm{SPD}_A^{(3)},R^{(3)}].\n$$",
            "solution": "该问题要求针对一个具有不连续扩散系数的一维椭圆边值问题，推导、实现并比较两种有限差分格式。在思考模块中详述的验证过程确认了该问题是科学上合理的、适定的且完整的。我们现在开始进行求解。\n\n### 守恒有限差分格式的推导\n\n我们从给定的区间 $[0,1]$ 上的一维椭圆边值问题开始：\n$$\n-(a(x)\\,u'(x))' + c(x)\\,u(x) = f(x), \\quad u(0)=0, \\quad u(1)=0\n$$\n此处，$a(x)0$ 是扩散系数，$c(x)\\ge 0$ 是反应系数，$f(x)$ 是源项。\n\n我们使用一个包含 $m$ 个分段的均匀网格来离散化定义域 $[0,1]$，从而得到网格尺寸 $h=1/m$。网格点为 $x_j = jh$，$j=0, 1, \\dots, m$。我们在内部网格点上求解数值解，记为 $u_j \\approx u(x_j)$，$j=1, \\dots, m-1$。\n\n为了推导守恒格式，我们在以每个内部节点 $x_j$ 为中心的控制体 $V_j = [x_{j-1/2}, x_{j+1/2}]$ 上对微分方程进行积分。该控制体的宽度为 $h=x_{j+1/2} - x_{j-1/2}$。\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} \\left( -(a(x)\\,u'(x))' + c(x)u(x) \\right) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n令 $F(x) = -a(x)u'(x)$ 代表物理通量。对第一项应用微积分基本定理，我们得到跨越控制体边界的净通量：\n$$\n\\left[ -a(x)u'(x) \\right]_{x_{j-1/2}}^{x_{j+1/2}} + \\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n$$\nF(x_{j-1/2}) - F(x_{j+1/2}) + \\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx = \\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx\n$$\n现在我们对每一项进行近似。积分项使用中点法则近似：\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} c(x)u(x) dx \\approx h c(x_j)u(x_j) = h c_j u_j\n$$\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} f(x) dx \\approx h f(x_j) = h f_j\n$$\n单元界面 $x_{j\\pm 1/2}$ 处的通量使用中心差分来近似导数：\n$$\nF_{j+1/2} = F(x_{j+1/2}) \\approx -a(x_{j+1/2}) \\frac{u(x_{j+1}) - u(x_j)}{h} \\approx -a_{j+1/2} \\frac{u_{j+1} - u_j}{h}\n$$\n$$\nF_{j-1/2} = F(x_{j-1/2}) \\approx -a(x_{j-1/2}) \\frac{u(x_j) - u(x_{j-1})}{h} \\approx -a_{j-1/2} \\frac{u_j - u_{j-1}}{h}\n$$\n项 $a_{j\\pm 1/2}$ 表示界面处的有效扩散系数。当 $a(x)$ 变化时，其定义至关重要。将这些近似代入积分方程，得到节点 $j$ 处的离散守恒律：\n$$\n-a_{j-1/2} \\frac{u_j - u_{j-1}}{h} - \\left(-a_{j+1/2} \\frac{u_{j+1} - u_j}{h}\\right) + h c_j u_j = h f_j\n$$\n两边同除以 $h$ 并重新整理各项，我们得到每个内部节点 $j=1, \\dots, m-1$ 的有限差分方程：\n$$\n\\frac{1}{h^2} \\left[ -a_{j-1/2}u_{j-1} + (a_{j-1/2} + a_{j+1/2})u_j - a_{j+1/2}u_{j+1} \\right] + c_j u_j = f_j\n$$\n这组 $m-1$ 个线性方程，再加上边界条件 $u_0=0$ 和 $u_m=0$，构成一个线性系统 $K\\mathbf{u} = \\mathbf{f}$。\n\n### 调和平均的合理性证明\n\n该格式的精度取决于界面系数 $a_{j+1/2}$ 的选择。连续问题的一个关键物理原理是通量 $F(x) = -a(x)u'(x)$ 的连续性。对于在界面（例如 $x_{j+1/2}$）处有跳变的分段常数 $a(x)$，必须精确地捕捉到这一条件。假设通量在区间 $[x_j, x_{j+1}]$ 上近似为常数，即 $-a(x)u'(x) \\approx F_{j+1/2}$。则 $u'(x) \\approx -F_{j+1/2}/a(x)$。从 $x_j$ 积分到 $x_{j+1}$：\n$$\nu(x_{j+1}) - u(x_j) = \\int_{x_j}^{x_{j+1}} u'(x) dx \\approx -F_{j+1/2} \\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}\n$$\n这意味着一个精确的数值通量应满足：\n$$\nF_{j+1/2} \\approx -\\frac{u_{j+1} - u_j}{\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}}\n$$\n将其与我们的离散通量定义 $F_{j+1/2} = -a_{j+1/2} \\frac{u_{j+1}-u_j}{h}$ 进行比较，我们确定物理上正确的有效扩散系数为：\n$$\na_{j+1/2} = \\frac{h}{\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)}}\n$$\n这是 $a(x)$ 在该区间上的积分调和平均值。如果我们假设 $a(x)$ 是分段常数，且跳变恰好发生在界面 $x_{j+1/2}$ 处，在 $[x_j, x_{j+1/2}]$ 上取值为 $a_j=a(x_j)$，在 $[x_{j+1/2}, x_{j+1}]$ 上取值为 $a_{j+1}=a(x_{j+1})$，则积分变为：\n$$\n\\int_{x_j}^{x_{j+1}} \\frac{dx}{a(x)} = \\frac{h/2}{a_j} + \\frac{h/2}{a_{j+1}} = \\frac{h}{2}\\left(\\frac{1}{a_j} + \\frac{1}{a_{j+1}}\\right)\n$$\n将其代回，得到界面系数：\n$$\na_{j+1/2} = \\frac{h}{\\frac{h}{2}\\left(\\frac{a_j+a_{j+1}}{a_j a_{j+1}}\\right)} = \\frac{2 a_j a_{j+1}}{a_j+a_{j+1}}\n$$\n这正是调和平均值 $H(a_j, a_{j+1})$。该推导表明，对于分段常数系数，使用调和平均作为界面系数可以正确地模拟连续通量条件。算术平均值 $A(a_j, a_{j+1}) = (a_j+a_{j+1})/2$ 不具备此性质，并且已知在急剧跳变处会产生较大误差。\n\n### 矩阵性质：对称性与正定性（$L^2$-稳定性）\n\n方程组可以写成 $K\\mathbf{u}=\\mathbf{f}$ 的形式，其中 $\\mathbf{u}=[u_1, \\dots, u_{m-1}]^T$。矩阵 $K$ 是三对角的。第 $i$ 行（代表未知数 $u_i$）和第 $j$ 列的元素记为 $K_{ij}$。对于 $i=1, \\dots, m-1$：\n- 主对角线：$K_{ii} = \\frac{1}{h^2}(a_{i-1/2} + a_{i+1/2}) + c_i$\n- 次对角线：$K_{i, i-1} = -\\frac{1}{h^2}a_{i-1/2}$ 和 $K_{i, i+1} = -\\frac{1}{h^2}a_{i+1/2}$\n\n**对称性**：矩阵 $K$ 是对称的，因为 $K_{i,i+1} = -\\frac{1}{h^2}a_{i+1/2}$ 且 $K_{i+1,i} = -\\frac{1}{h^2}a_{(i+1)-1/2} = -\\frac{1}{h^2}a_{i+1/2}$，所以 $K_{i,i+1}=K_{i+1,i}$。这对 $a_{i+1/2}$ 的任何定义都成立。\n\n**正定性**：如果对于任意非零向量 $\\mathbf{v}$，二次型 $\\mathbf{v}^T K \\mathbf{v}  0$ 都成立，那么一个对称矩阵是正定的。这个性质确保了矩阵是可逆的，并意味着数值格式的稳定性。设 $\\mathbf{u}$ 是节点值向量，其中 $u_0=u_m=0$。二次型为：\n$$\n\\mathbf{u}^T K \\mathbf{u} = \\sum_{j=1}^{m-1} u_j \\left( \\frac{1}{h^2} \\left[ -a_{j-1/2}u_{j-1} + (a_{j-1/2} + a_{j+1/2})u_j - a_{j+1/2}u_{j+1} \\right] + c_j u_j \\right)\n$$\n通过分部求和法，这可以重新整理为离散的“能量”：\n$$\n\\mathbf{u}^T K \\mathbf{u} = \\frac{1}{h^2} \\sum_{j=0}^{m-1} a_{j+1/2} (u_{j+1}-u_j)^2 + \\sum_{j=1}^{m-1} c_j u_j^2\n$$\n由于 $c(x) \\ge 0$，第二项是非负的。为了使第一项为正，我们要求 $a_{j+1/2}  0$。由于 $a(x)0$，正数的调和平均值和算术平均值都是正的。当且仅当对于所有 $j$ 都有 $u_{j+1}-u_j=0$ 时，求和项 $\\sum_{j=0}^{m-1} a_{j+1/2} (u_{j+1}-u_j)^2$ 才为零，这意味着 $u_0=u_1=\\dots=u_m$。边界条件 $u_0=0$ 继而强制所有 $u_j=0$，即 $\\mathbf{u}=\\mathbf{0}$。因此，对于任何非零向量 $\\mathbf{u}$，我们都有 $\\mathbf{u}^T K \\mathbf{u}  0$。两种格式都产生一个对称正定（SPD）矩阵，这保证了唯一解并提供了 $L^2$-稳定性。SPD 矩阵的最小特征值严格为正。\n\n### 测试问题的精确解\n\n测试问题为 $-(a(x)u'(x))' = 1$，边界条件为 $u(0)=u(1)=0$，$c(x)=0$，以及 $a(x)$ 定义如下：\n$$\na(x) = \\begin{cases} 1,  x  0.5 \\\\ \\alpha,  x \\ge 0.5 \\end{cases}\n$$\n设 $x^*=0.5$。我们分段求解常微分方程（ODE）。\n对于 $x \\in [0, x^*)$：$-u_1''(x)=1 \\implies u_1(x) = -x^2/2 + C_1 x + C_2$。\n对于 $x \\in (x^*, 1]$：$-\\alpha u_2''(x)=1 \\implies u_2(x) = -x^2/(2\\alpha) + C_3 x + C_4$。\n\n这四个未知常数由四个条件确定：\n1. 边界条件 $u_1(0)=0 \\implies C_2=0$。\n2. 边界条件 $u_2(1)=0 \\implies -1/(2\\alpha) + C_3 + C_4 = 0$。\n3. 解的连续性 $u_1(x^*) = u_2(x^*)$。\n4. 通量的连续性 $1 \\cdot u_1'(x^*) = \\alpha \\cdot u_2'(x^*)$。\n\n根据通量连续性，我们得到 $-x^*+C_1 = \\alpha(-x^*/\\alpha+C_3)$，化简为 $C_1 = \\alpha C_3$。\n求解关于 $C_1, C_3, C_4$ 的线性方程组（其中 $x^*=0.5$）得到：\n$$\nC_1 = \\frac{\\alpha+3}{4(\\alpha+1)}, \\quad C_3 = \\frac{\\alpha+3}{4\\alpha(\\alpha+1)}, \\quad C_4 = \\frac{\\alpha-1}{4\\alpha(\\alpha+1)}\n$$\n因此，精确解为：\n$$\nu(x) =\n\\begin{cases}\n-\\dfrac{x^2}{2} + \\dfrac{\\alpha+3}{4(\\alpha+1)}\\,x,  x  0.5 \\\\\n-\\dfrac{x^2}{2\\alpha} + \\dfrac{\\alpha+3}{4\\alpha(\\alpha+1)}\\,x + \\dfrac{\\alpha-1}{4\\alpha(\\alpha+1)},  x \\ge 0.5\n\\end{cases}\n$$\n此解用于评估数值格式的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded, eigvalsh_tridiagonal\n\ndef build_and_solve(m, alpha, averaging_method):\n    \"\"\"\n    Builds and solves the finite difference system for a given averaging method.\n\n    Args:\n        m (int): Number of grid segments.\n        alpha (float): Jump parameter for the diffusion coefficient.\n        averaging_method (str): 'harmonic' or 'arithmetic'.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The numerical solution vector at interior nodes.\n            - bool: True if the resulting matrix is Symmetric Positive Definite.\n    \"\"\"\n    h = 1.0 / m\n    N = m - 1  # Number of interior unknowns\n\n    # Define diffusion coefficient a(x) at grid points x_j\n    a_vals = np.ones(m + 1)\n    jump_index = m // 2\n    a_vals[jump_index:] = alpha\n\n    # Construct interface coefficients a_{j+1/2}\n    a_half = np.zeros(m)  # a_half[j] corresponds to a_{j+1/2}\n    for j in range(m):\n        a_left = a_vals[j]\n        a_right = a_vals[j+1]\n        \n        if averaging_method == 'harmonic':\n            if a_left + a_right == 0.0:\n                 a_half[j] = 0.0\n            else:\n                 a_half[j] = 2.0 * a_left * a_right / (a_left + a_right)\n        elif averaging_method == 'arithmetic':\n            a_half[j] = 0.5 * (a_left + a_right)\n        else:\n            raise ValueError(\"Unknown averaging method\")\n\n    # Construct the tridiagonal matrix A such that A*u = h^2 * f\n    # The matrix K in the derivation is A/h^2.\n    # d: main diagonal, e: off-diagonal (for a symmetric tridiagonal matrix)\n    # The matrix size is N x N, where N = m-1.\n    # The i-th row (0-indexed) corresponds to unknown u_{i+1}.\n    # d[i] = a_{i+1/2} + a_{i+3/2}\n    # e[i] = -a_{i+3/2}\n    d = a_half[:-1] + a_half[1:]  # Main diagonal, size N\n    e = -a_half[1:-1]            # Off-diagonal, size N-1\n\n    # Right-hand side vector\n    b = h**2 * np.ones(N)\n    \n    # Use scipy's efficient banded solver.\n    # The matrix must be in a specific format for solve_banded.\n    # For a symmetric tridiagonal matrix (l=1, u=1), shape is (3, N)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = e   # Super-diagonal\n    ab[1, :] = d    # Main diagonal\n    ab[2, :-1] = e  # Sub-diagonal\n    \n    u_num = solve_banded((1, 1), ab, b)\n    \n    # Compute the smallest eigenvalue to check for SPD property.\n    # eigvalsh_tridiagonal is efficient for this.\n    # A matrix is SPD if and only if all its eigenvalues are strictly positive.\n    min_eig = eigvalsh_tridiagonal(d, e, select='i', select_range=(0, 0))[0]\n    is_spd = min_eig > 0\n\n    return u_num, is_spd\n\ndef exact_solution(x_vals, alpha):\n    \"\"\"\n    Computes the exact solution of the BVP for a given alpha.\n    \"\"\"\n    # Integration constants from the derivation\n    c1 = (alpha + 3.0) / (4.0 * (alpha + 1.0))\n    c3 = (alpha + 3.0) / (4.0 * alpha * (alpha + 1.0))\n    c4 = (alpha - 1.0) / (4.0 * alpha * (alpha + 1.0))\n\n    sol = np.zeros_like(x_vals, dtype=float)\n    mask_left = x_vals  0.5\n    \n    # Function for x  0.5\n    sol[mask_left] = -0.5 * x_vals[mask_left]**2 + c1 * x_vals[mask_left]\n    # Function for x >= 0.5\n    sol[~mask_left] = -0.5 * x_vals[~mask_left]**2 / alpha + c3 * x_vals[~mask_left] + c4\n    \n    return sol\n\ndef compute_l2_error(h, u_num, u_exact_vals):\n    \"\"\"\n    Computes the discrete L2 error.\n    \"\"\"\n    return np.sqrt(h * np.sum((u_num - u_exact_vals)**2))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1.0,        # Case 1: alpha = 1 (no jump)\n        1e-3,       # Case 2: alpha = 10^-3\n        1e3,        # Case 3: alpha = 10^3\n    ]\n\n    results = []\n    m = 200\n    h = 1.0 / m\n    x_interior = np.linspace(0, 1, m + 1)[1:-1]\n    \n    for alpha in test_cases:\n        # Evaluate exact solution at interior grid points\n        u_exact_vals = exact_solution(x_interior, alpha)\n\n        # Harmonic averaging solution\n        u_h, spd_h = build_and_solve(m, alpha, 'harmonic')\n        E_H = compute_l2_error(h, u_h, u_exact_vals)\n\n        # Arithmetic averaging solution\n        u_a, spd_a = build_and_solve(m, alpha, 'arithmetic')\n        E_A = compute_l2_error(h, u_a, u_exact_vals)\n        \n        # Calculate the error ratio\n        if E_H == 0:\n            ratio = np.inf if E_A > 0 else 1.0\n        else:\n            ratio = E_A / E_H\n        \n        results.extend([\n            E_H,\n            E_A,\n            str(spd_h).lower(),\n            str(spd_a).lower(),\n            ratio\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "许多物理系统在多个尺度上都存在复杂的微观结构，这给数值模拟带来了巨大挑战，因为完全解析这些微观细节的计算成本可能高得惊人。这个高级练习将带你探索一类具有快速振荡系数的多尺度问题。你将接触到“均匀化”理论的核心思想——用一个等效的、更简单的“有效”介质来替代复杂的微观结构，并从数值上验证一个精心设计的离散格式（基于调和平均）如何能够在远不足以解析微观振荡的粗糙网格上，成功捕捉到系统的宏观有效行为。",
            "id": "3392831",
            "problem": "考虑区间 $[0,1]$ 上的一维二阶椭圆型偏微分方程（PDE）的散度形式：\n$$\n- \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}(x)\\right) = f(x), \\quad x \\in (0,1), \\qquad u(0) = 0,\\quad u(1) = 0,\n$$\n其多尺度系数为\n$$\na(x) = 1 + \\alpha \\sin(\\omega x),\n$$\n其中正弦函数中的角度以弧度为单位。源项规定为\n$$\nf(x) \\equiv 1.\n$$\n假设 $|\\alpha|  1$，因此 $a(x)$ 严格为正。您的任务是：\n- 从基本原理出发，为该散度形式算子推导一个二阶守恒有限差分（FD）格式。推导必须从在每个单元上对PDE进行积分并强制通量平衡开始。得到的离散算子必须包含半网格点处的界面系数，以确保对通量的一致逼近。\n- 为界面系数 $a_{i+\\frac{1}{2}}$ 实现两种选择：\n  1. 中点取值：$a_{i+\\frac{1}{2}} = a\\!\\left(\\frac{x_i + x_{i+1}}{2}\\right)$。\n  2. 单元调和平均：$a_{i+\\frac{1}{2}} = \\dfrac{h}{\\int_{x_i}^{x_{i+1}} \\dfrac{1}{a(s)}\\,ds}$，其中 $h$ 是均匀的网格间距。\n- 计算一系列网格尺寸下的有限差分数值解，并对照以下两种情况度量离散误差：\n  1. 一个高精度参考解，该解通过利用散度形式算子的一维通量积分，并以高精度计算所需积分来构建。\n  2. 在周期性微结构假设下获得的均匀化预测。利用应用于 $a(x)$ 的一维周期性均匀化原理推导均匀化有效系数，并构建带狄利克雷边界条件的均匀化解。\n\n在均匀间距 $h = 1/N$ 的内部网格点 $\\{x_i\\}_{i=1}^{N-1}$ 上，离散 $L^2$ 范数定义为\n$$\n\\|v\\|_h = \\left(h \\sum_{i=1}^{N-1} v(x_i)^2\\right)^{\\frac{1}{2}}.\n$$\n逼近解 $u_h$ 相对于参考解 $v$ 的相对离散 $L^2$ 误差定义为\n$$\n\\mathcal{E}_{\\mathrm{rel}}(u_h; v) = \\frac{\\|u_h - v\\|_h}{\\|v\\|_h}.\n$$\n\n定义微周期长度\n$$\nL_{\\mathrm{micro}} = \\frac{2\\pi}{\\omega}.\n$$\n对于给定的网格间距 $h$，如果 $h \\geq L_{\\mathrm{micro}}$，则称其“相对于微结构是粗糙的”。\n\n“捕捉到有效行为”的准则定义如下：如果一个使用单元调和平均计算的有限差分解 $u_h$ 同时满足以下两个条件，则认为其捕捉到了有效行为：\n$$\n\\mathcal{E}_{\\mathrm{rel}}(u_h; u_{\\mathrm{hom}}) \\leq \\tau_{\\mathrm{hom}}\n$$\n且\n$$\nh \\geq L_{\\mathrm{micro}},\n$$\n其中 $u_{\\mathrm{hom}}$ 是使用有效系数构建的均匀化解，$\\tau_{\\mathrm{hom}}$ 是一个预设的容差。此外，为了报告目的，还需计算在首次满足有效行为准则的网格尺寸下，相对于高精度参考解 $u_{\\mathrm{ref}}$ 的绝对离散 $L^2$ 误差 $\\|u_h - u_{\\mathrm{ref}}\\|_h$。\n\n角度单位说明：所有三角函数求值必须以弧度为单位。本问题中没有物理单位；所有量均为无量纲。\n\n实现一个程序，对下述每个测试用例，为中点格式和单元调和平均格式构建并求解有限差分系统，计算所需的误差，并确定（从该测试用例提供的列表中）对每种格式满足有效行为准则的最小网格尺寸 $N$。如果没有网格尺寸满足该准则，则报告最小网格尺寸为 $0$，相关误差量为 $-1.0$。\n\n测试套件：\n- 测试 $1$：$\\alpha = 0.5$，$\\omega = 200$， $N \\in \\{16, 32, 64, 128\\}$，$\\tau_{\\mathrm{hom}} = 0.01$。\n- 测试 $2$：$\\alpha = 0.8$，$\\omega = 300$， $N \\in \\{16, 32, 64, 128, 256\\}$，$\\tau_{\\mathrm{hom}} = 0.01$。\n- 测试 $3$：$\\alpha = 0.3$，$\\omega = 50$， $N \\in \\{8, 16, 32\\}$，$\\tau_{\\mathrm{hom}} = 0.01$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果，每个测试用例的结果本身是一个包含五个条目的列表：\n$$\n[\\;N_{\\mathrm{harm}},\\; N_{\\mathrm{mid}},\\; \\text{coarse\\_ok},\\; \\|u_{\\mathrm{harm}} - u_{\\mathrm{ref}}\\|_h,\\; \\mathcal{E}_{\\mathrm{rel}}(u_{\\mathrm{harm}}; u_{\\mathrm{hom}})\\;],\n$$\n具体说明如下：\n- $N_{\\mathrm{harm}}$：测试列表中使单元调和平均格式满足有效行为准则的最小 $N$；若没有，则报告 $0$。\n- $N_{\\mathrm{mid}}$：测试列表中使中点格式满足有效行为准则的最小 $N$；若没有，则报告 $0$。\n- $\\text{coarse\\_ok}$：一个布尔值，如果 $N_{\\mathrm{harm}} \\neq 0$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- $\\|u_{\\mathrm{harm}} - u_{\\mathrm{ref}}\\|_h$：在 $N_{\\mathrm{harm}}$ 处计算的单元调和平均解相对于高精度参考解的绝对离散 $L^2$ 误差；如果 $N_{\\mathrm{harm}} = 0$，则报告 $-1.0$。\n- $\\mathcal{E}_{\\mathrm{rel}}(u_{\\mathrm{harm}}; u_{\\mathrm{hom}})$：在 $N_{\\mathrm{harm}}$ 处计算的单元调和平均解相对于均匀化解的相对离散 $L^2$ 误差；如果 $N_{\\mathrm{harm}} = 0$，则报告 $-1.0$。\n\n您的程序应按顺序为三个测试生成单行输出，结果是一个包含三个列表的列表，例如：\n$$\n[\\,[N_{\\mathrm{harm}}^{(1)},N_{\\mathrm{mid}}^{(1)},\\text{coarse\\_ok}^{(1)},E_{\\mathrm{abs}}^{(1)},E_{\\mathrm{rel}}^{(1)}],\\,[\\ldots],\\,[\\ldots]\\,].\n$$",
            "solution": "该问题要求针对一个带有多尺度系数的一维椭圆边值问题，推导并实现一种有限差分（FD）方法，并将数值解与高精度参考解及均匀化解进行比较。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n\n- **偏微分方程（PDE）**：$- \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}(x)\\right) = f(x)$，适用于 $x \\in (0,1)$。\n- **边界条件**：$u(0) = 0$, $u(1) = 0$。\n- **系数**：$a(x) = 1 + \\alpha \\sin(\\omega x)$，其中 $|\\alpha|  1$。\n- **源项**：$f(x) \\equiv 1$。\n- **有限差分界面系数**：\n  1. 中点：$a_{i+\\frac{1}{2}} = a\\left(\\frac{x_i + x_{i+1}}{2}\\right)$。\n  2. 单元调和平均：$a_{i+\\frac{1}{2}} = \\dfrac{h}{\\int_{x_i}^{x_{i+1}} \\dfrac{1}{a(s)}\\,ds}$。\n- **网格**：均匀网格，间距 $h = 1/N$，节点 $x_i = ih$，$i=0, \\ldots, N$。\n- **离散 $L^2$ 范数**：$\\|v\\|_h = \\left(h \\sum_{i=1}^{N-1} v(x_i)^2\\right)^{\\frac{1}{2}}$。\n- **相对 $L^2$ 误差**：$\\mathcal{E}_{\\mathrm{rel}}(u_h; v) = \\frac{\\|u_h - v\\|_h}{\\|v\\|_h}$。\n- **微周期**：$L_{\\mathrm{micro}} = \\frac{2\\pi}{\\omega}$。\n- **有效行为准则**：如果有限差分解 $u_h$ 满足 $\\mathcal{E}_{\\mathrm{rel}}(u_h; u_{\\mathrm{hom}}) \\leq \\tau_{\\mathrm{hom}}$ 且 $h \\geq L_{\\mathrm{micro}}$，则认为其捕捉到了有效行为。\n- **任务**：对每个测试用例，从给定列表中找到对每种格式（`midpoint`, `cell-harmonic`）满足准则的最小 $N$。报告这些值以及 `cell-harmonic` 格式的相关误差。\n- **$N_{\\mathrm{harm}}$ 的报告要求**：如果找到了一个合适的 $N$（设为 $N_{\\mathrm{harm}}$），则报告 $N_{\\mathrm{harm}}$、一个布尔值 `coarse_ok`、$\\|u_{\\mathrm{harm}} - u_{\\mathrm{ref}}\\|_h$ 和 $\\mathcal{E}_{\\mathrm{rel}}(u_{\\mathrm{harm}}; u_{\\mathrm{hom}})$。如果不存在这样的 $N$，则报告 $0$、`False`、$-1.0$ 和 $-1.0$。\n- **测试套件**：\n  - 测试 $1$：$\\alpha = 0.5$, $\\omega = 200$, $N \\in \\{16, 32, 64, 128\\}$, $\\tau_{\\mathrm{hom}} = 0.01$。\n  - 测试 $2$：$\\alpha = 0.8$, $\\omega = 300$, $N \\in \\{16, 32, 64, 128, 256\\}$, $\\tau_{\\mathrm{hom}} = 0.01$。\n  - 测试 $3$：$\\alpha = 0.3$, $\\omega = 50$, $N \\in \\{8, 16, 32\\}$, $\\tau_{\\mathrm{hom}} = 0.01$。\n\n**1.2. 验证与结论**\n\n该问题在科学上植根于偏微分方程的数值分析和均匀化理论领域。该偏微分方程是一个标准的一维、二阶、散度形式的线性椭圆方程。条件 $|\\alpha|  1$ 确保了 $a(x)  0$，从而保证算子是椭圆的，并且边值问题是适定的。守恒有限差分格式、界面系数的调和平均以及周期性均匀化等概念都是成熟的理论。该问题是自洽的，提供了所有必要的定义、参数和评估的客观标准。该问题是可形式化的、非平凡的，并且没有任何科学或事实上的不健全、模糊或矛盾之处。\n\n**结论**：该问题是**有效的**。\n\n### 步骤 2：推导与求解方法\n\n**2.1. 守恒有限差分格式**\n\n我们通过在控制体上对偏微分方程进行积分，从基本原理出发推导该格式。考虑一个均匀网格，其节点为 $x_i = ih$，其中 $i=0, 1, \\ldots, N$ 且 $h=1/N$。对于内部节点 $x_i$（$i=1, \\ldots, N-1$），其控制体是单元 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i \\pm 1/2} = x_i \\pm h/2$。在该单元上对PDE进行积分，得到：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} - \\frac{d}{dx}\\left(a(x)\\frac{du}{dx}\\right) dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx\n$$\n对左侧应用微积分基本定理，得到：\n$$\n-\\left[a(x)\\frac{du}{dx}(x)\\right]_{x_{i-1/2}}^{x_{i+1/2}} = \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx\n$$\n这表示单元边界处的通量平衡：\n$$\n\\left(-a(x)\\frac{du}{dx}\\right)\\bigg|_{x_{i+1/2}} - \\left(-a(x)\\frac{du}{dx}\\right)\\bigg|_{x_{i-1/2}} = \\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx\n$$\n我们对每一项进行离散化。单元界面处的导数通过二阶中心差分来逼近：\n$$\n\\frac{du}{dx}(x_{i+1/2}) \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{u_{i+1} - u_i}{h}\n$$\n$$\n\\frac{du}{dx}(x_{i-1/2}) \\approx \\frac{u(x_i) - u(x_{i-1})}{h} = \\frac{u_i - u_{i-1}}{h}\n$$\n右端项通过中点法则来逼近：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} f(x) dx \\approx h f(x_i) = h f_i\n$$\n代入这些逼近，以及有效的界面系数 $a_{i \\pm 1/2}$，我们得到离散方程：\n$$\n-a_{i+1/2} \\frac{u_{i+1} - u_i}{h} + a_{i-1/2} \\frac{u_i - u_{i-1}}{h} = h f_i\n$$\n两边乘以 $h$ 并整理各项，我们得到第 $i$ 个未知数 $u_i$ 的计算模板：\n$$\n-a_{i-1/2}u_{i-1} + (a_{i-1/2} + a_{i+1/2})u_i - a_{i+1/2}u_{i+1} = h^2 f_i\n$$\n由于 $f(x) \\equiv 1$，我们有 $f_i=1$。对于内部节点 $i=1, \\ldots, N-1$ 的方程，连同边界条件 $u_0=0$ 和 $u_N=0$，构成了一个关于未知向量 $U = [u_1, \\ldots, u_{N-1}]^T$ 的对称正定三对角线性系统 $AU = F$。\n\n**2.2. 高精度参考解**\n\n精确解可以通过直接积分得到。设通量为 $J(x) = -a(x) \\frac{du}{dx}$。该偏微分方程为 $J'(x) = f(x) = 1$。\n从 $0$ 到 $x$ 积分：\n$$\nJ(x) - J(0) = \\int_0^x 1 ds = x \\implies -a(x)\\frac{du}{dx} = x + J(0)\n$$\n设 $C_1 = -J(0) = a(0)u'(0)$，这是一个未知常数。则：\n$$\n\\frac{du}{dx} = \\frac{C_1 - x}{a(x)}\n$$\n再次从 $0$ 到 $x$ 积分，并使用边界条件 $u(0)=0$：\n$$\nu(x) - u(0) = \\int_0^x \\frac{C_1 - s}{a(s)} ds \\implies u(x) = C_1 \\int_0^x \\frac{1}{a(s)}ds - \\int_0^x \\frac{s}{a(s)}ds\n$$\n为了求出 $C_1$，我们应用第二个边界条件 $u(1)=0$：\n$$\n0 = C_1 \\int_0^1 \\frac{1}{a(s)}ds - \\int_0^1 \\frac{s}{a(s)}ds \\implies C_1 = \\frac{\\int_0^1 \\frac{s}{a(s)}ds}{\\int_0^1 \\frac{1}{a(s)}ds}\n$$\n因此，参考解 $u_{\\mathrm{ref}}(x)$ 由此积分公式给出。这些积分将通过数值方法以高精度计算。\n\n**2.3. 均匀化解**\n\n对于一个周期为 $Y$ 的周期性系数 $a(y)$ 的介质，其有效系数 $a^*$ 是在一个周期内的调和平均：\n$$\na^* = \\left( \\frac{1}{Y} \\int_0^Y \\frac{1}{a(y)} dy \\right)^{-1}\n$$\n在我们的问题中，$a(x) = 1 + \\alpha\\sin(\\omega x)$ 是周期性的，周期为 $Y=L_{\\mathrm{micro}}=2\\pi/\\omega$。\n$$\na^* = \\left( \\frac{\\omega}{2\\pi} \\int_0^{2\\pi/\\omega} \\frac{1}{1 + \\alpha\\sin(\\omega y)} dy \\right)^{-1}\n$$\n设 $t = \\omega y$，则 $dt = \\omega dy$。积分为：\n$$\n\\frac{\\omega}{2\\pi} \\frac{1}{\\omega} \\int_0^{2\\pi} \\frac{1}{1 + \\alpha\\sin(t)} dt = \\frac{1}{2\\pi} \\frac{2\\pi}{\\sqrt{1-\\alpha^2}} = \\frac{1}{\\sqrt{1-\\alpha^2}}\n$$\n这里我们使用了标准定积分 $\\int_0^{2\\pi} \\frac{dt}{A+B\\sin t} = \\frac{2\\pi}{\\sqrt{A^2-B^2}}$ (对于 $A>|B|$)。\n因此，有效系数为 $a^* = \\sqrt{1-\\alpha^2}$。均匀化问题为：\n$$\n-a^* \\frac{d^2 u_{\\mathrm{hom}}}{dx^2} = 1, \\quad u_{\\mathrm{hom}}(0)=0, \\quad u_{\\mathrm{hom}}(1)=0\n$$\n积分两次并应用边界条件，得到抛物线解：\n$$\nu_{\\mathrm{hom}}(x) = \\frac{x(1-x)}{2a^*} = \\frac{x(1-x)}{2\\sqrt{1-\\alpha^2}}\n$$\n\n**2.4. 数值实现策略**\n\n实现的核心是遍历所有测试用例。对于每个用例，我们遍历所提供的网格尺寸 $N$ 的列表。\n\n对每个 $N$，我们执行以下步骤：\n1.  定义网格参数 $h=1/N$ 和内部网格点 $x_i$（$i=1, \\ldots, N-1$）。\n2.  对中点格式和单元调和平均格式，计算界面系数 $a_{i+1/2}$（$i=0, \\ldots, N-1$）。调和平均需要对每个单元 $[x_i, x_{i+1}]$ 进行数值积分。\n3.  对每种格式，根据推导出的模板构建三对角矩阵 $A$。该矩阵由其对角带表示。\n4.  定义右端向量 $F$，其中每个元素都是 $h^2$。\n5.  使用 `scipy.linalg.solve_banded` 求解线性系统 $AU=F$，以获得数值解 $u_h^{\\mathrm{mid}}$ 和 $u_h^{\\mathrm{harm}}$。\n6.  在网格上计算均匀化解 $u_{\\mathrm{hom}}$。\n7.  检查“有效行为”准则：$h \\geq L_{\\mathrm{micro}}$ 且 $\\mathcal{E}_{\\mathrm{rel}}(u_h; u_{\\mathrm{hom}}) \\leq \\tau_{\\mathrm{hom}}$。我们对每种格式，在列表中搜索满足此准则的最小 $N$，并将其存储为 $N_{\\mathrm{mid}}$ 和 $N_{\\mathrm{harm}}$。\n8.  如果找到了一个有效的 $N_{\\mathrm{harm}}$，我们继续计算所需的误差度量。这包括：\n    a. 在对应于 $N_{\\mathrm{harm}}$ 的网格上计算高精度参考解 $u_{\\mathrm{ref}}$。为了高效地完成此操作，我们首先计算每个单元上的积分 $\\int_{x_i}^{x_{i+1}} \\frac{1}{a(s)}ds$ 和 $\\int_{x_i}^{x_{i+1}} \\frac{s}{a(s)}ds$。通过对这些单元积分求和，可以得到在 $[0,1]$ 上的总积分。这决定了常数 $C_1$。然后，使用单元积分的累加和来计算 $u_{\\mathrm{ref}}(x_i)$ 的值。\n    b. 计算绝对离散 $L^2$ 误差 $\\|u_{\\mathrm{harm}} - u_{\\mathrm{ref}}\\|_h$。\n    c. 存储在准则检查中使用的相对离散 $L^2$ 误差 $\\mathcal{E}_{\\mathrm{rel}}(u_{\\mathrm{harm}}; u_{\\mathrm{hom}})$。\n9.  如果列表中没有 $N$ 满足给定格式的准则，则该格式的 $N$ 结果为 $0$，相关误差为 $-1.0$。\n10. 收集每个测试用例的最终结果，并按指定格式打印。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg, integrate\n\ndef solve():\n    \"\"\"\n    Solves the 1D elliptic BVP with multiscale coefficient using finite differences,\n    analyzes the performance against homogenized and reference solutions,\n    and reports the results according to the problem specification.\n    \"\"\"\n    \n    test_cases = [\n        (0.5, 200, [16, 32, 64, 128], 0.01),\n        (0.8, 300, [16, 32, 64, 128, 256], 0.01),\n        (0.3, 50, [8, 16, 32], 0.01),\n    ]\n\n    final_results = []\n\n    for alpha, omega, N_list, tau_hom in test_cases:\n        \n        L_micro = 2 * np.pi / omega\n        a_star = np.sqrt(1 - alpha**2)\n        \n        def a_coeff(x):\n            return 1 + alpha * np.sin(omega * x)\n\n        def u_hom_func(x):\n            return x * (1 - x) / (2 * a_star)\n\n        def l2_norm_h(v, h):\n            return np.sqrt(h * np.sum(v**2))\n\n        def l2_rel_error(u_h, v, h):\n            norm_v = l2_norm_h(v, h)\n            if norm_v == 0:\n                return np.inf\n            return l2_norm_h(u_h - v, h) / norm_v\n\n        def solve_fd_system(N, a_interface):\n            h = 1.0 / N\n            main_diag = a_interface[:-1] + a_interface[1:]\n            sub_diag = -a_interface[1:-1]\n            sup_diag = -a_interface[1:-1]\n            \n            ab = np.zeros((3, N - 1))\n            ab[0, 1:] = sup_diag\n            ab[1, :] = main_diag\n            ab[2, :-1] = sub_diag\n\n            b = (h**2) * np.ones(N - 1)\n            \n            u_h = linalg.solve_banded((1, 1), ab, b)\n            return u_h\n\n        def get_reference_solution(N, a_func):\n            h = 1.0/N\n            x_nodes = np.linspace(0, 1, N + 1)\n            \n            integrand1 = lambda s: 1.0 / a_func(s)\n            integrand2 = lambda s: s / a_func(s)\n\n            dI1 = np.array([integrate.quad(integrand1, x_nodes[i], x_nodes[i+1])[0] for i in range(N)])\n            dI2 = np.array([integrate.quad(integrand2, x_nodes[i], x_nodes[i+1])[0] for i in range(N)])\n\n            I1_total = np.sum(dI1)\n            I2_total = np.sum(dI2)\n            \n            C1 = I2_total / I1_total\n            \n            I1_at_nodes = np.concatenate(([0], np.cumsum(dI1)))\n            I2_at_nodes = np.concatenate(([0], np.cumsum(dI2)))\n            \n            u_ref_nodes = C1 * I1_at_nodes - I2_at_nodes\n            return u_ref_nodes[1:-1]\n\n        N_harm = 0\n        N_mid = 0\n        err_abs_at_N_harm = -1.0\n        err_rel_at_N_harm = -1.0\n        \n        # Midpoint scheme\n        for N in N_list:\n            h = 1.0 / N\n            if h >= L_micro:\n                x_grid = np.linspace(0, 1, N + 1)\n                x_interior = x_grid[1:-1]\n                x_half = x_grid[:-1] + h / 2.0\n                \n                a_interface_mid = a_coeff(x_half)\n                u_h_mid = solve_fd_system(N, a_interface_mid)\n                u_hom_grid = u_hom_func(x_interior)\n                \n                err_rel = l2_rel_error(u_h_mid, u_hom_grid, h)\n                \n                if err_rel = tau_hom:\n                    N_mid = N\n                    break\n        \n        # Harmonic average scheme\n        for N in N_list:\n            h = 1.0 / N\n            if h >= L_micro:\n                x_grid = np.linspace(0, 1, N + 1)\n                x_interior = x_grid[1:-1]\n                \n                inv_a_integrand = lambda s: 1.0 / a_coeff(s)\n                a_interface_harm = np.array([h / integrate.quad(inv_a_integrand, x_grid[i], x_grid[i+1])[0] for i in range(N)])\n                u_h_harm = solve_fd_system(N, a_interface_harm)\n                u_hom_grid = u_hom_func(x_interior)\n                \n                err_rel = l2_rel_error(u_h_harm, u_hom_grid, h)\n                \n                if err_rel = tau_hom:\n                    N_harm = N\n                    err_rel_at_N_harm = err_rel\n                    \n                    # Compute absolute error against reference solution\n                    u_ref_grid = get_reference_solution(N, a_coeff)\n                    err_abs_at_N_harm = l2_norm_h(u_h_harm - u_ref_grid, h)\n                    break\n        \n        coarse_ok = N_harm != 0\n        final_results.append([N_harm, N_mid, coarse_ok, err_abs_at_N_harm, err_rel_at_N_harm])\n\n    # Format output as specified\n    result_str_parts = []\n    for res in final_results:\n      N_h, N_m, c_ok, e_abs, e_rel = res\n      e_abs_str = f\"{e_abs:.1f}\" if e_abs == -1.0 else str(e_abs)\n      e_rel_str = f\"{e_rel:.1f}\" if e_rel == -1.0 else str(e_rel)\n      result_str_parts.append(f\"[{N_h},{N_m},{str(c_ok)},{e_abs_str},{e_rel_str}]\")\n    print(f\"[{','.join(result_str_parts)}]\")\n\n\nsolve()\n```"
        }
    ]
}