{
    "hands_on_practices": [
        {
            "introduction": "The performance of level-set based ordering algorithms like Cuthill–McKee is highly sensitive to the choice of the starting vertex. An effective heuristic is to begin the traversal from a \"pseudo-peripheral\" node, a vertex with high eccentricity that sits at the \"edge\" of the graph. This practice provides a concrete, hands-on understanding of how to find such a node by stepping through the pseudo-peripheral detection algorithm on a canonical grid graph, building intuition for why this starting point leads to the deep, narrow level structures ideal for bandwidth reduction.",
            "id": "3365607",
            "problem": "Consider the sparse linear system arising from a standard five-point finite difference discretization of the Poisson equation on a unit square with Dirichlet boundary conditions at a uniform grid of size $6\\times 6$. The adjacency structure of the resulting matrix is the graph $G$ whose vertices correspond to the grid points $\\{(i,j): i,j\\in\\{1,2,3,4,5,6\\}\\}$, and whose edges connect pairs of vertices that differ by exactly one in exactly one coordinate. This is the $6\\times 6$ grid graph, which is the canonical testbed for bandwidth reduction techniques such as the Reverse Cuthill–McKee algorithm. \n\nA bandwidth reduction heuristic often used in practice is to start the Reverse Cuthill–McKee ordering from a so-called pseudo-peripheral node, obtained by the pseudo-peripheral detection procedure: starting from an initial vertex $s_{0}$, one computes a breadth-first search (BFS) level structure rooted at $s_{0}$; one then picks a vertex $s_{1}$ from the last nonempty level, recomputes the BFS levels rooted at $s_{1}$, and repeats, replacing $s_{k}$ by a vertex from the last level of the new structure whenever the number of levels strictly increases; the process terminates when the number of levels no longer increases, and the current root is declared the pseudo-peripheral node. The number of BFS levels for a root $s$ equals the eccentricity of $s$ plus one, where eccentricity is the largest graph distance from $s$ to any vertex in $G$.\n\nStarting from the interior node $s_{0}=(3,4)$, carry out (symbolically, by exact reasoning on the grid geometry) the pseudo-peripheral detection procedure until termination, and determine the number of BFS levels $L_{\\mathrm{pp}}$ at termination. Separately, determine the number of BFS levels $L_{\\mathrm{corner}}$ when the root is the corner node $(1,1)$, and the number of BFS levels $L_{\\mathrm{center}}$ when the root is the interior “center” node $(3,3)$.\n\nCompute the scalar difference\n$$\n\\Delta L \\equiv L_{\\mathrm{pp}} - L_{\\mathrm{center}}.\n$$\nGive your answer as an exact integer with no units. No rounding is required. In your reasoning, justify from first principles on grid graphs why the BFS level counts you report are correct and why the pseudo-peripheral detection terminates at the claimed node on this graph. You may assume the basic definitions of graph distance, eccentricity, and breadth-first search (BFS), but do not assume any shortcut formulas beyond these definitions.",
            "solution": "The problem requires the analysis of a specific graph and the execution of a vertex ordering algorithm. Let us begin by formalizing the problem setting.\n\nThe graph $G=(V, E)$ is the $6 \\times 6$ grid graph. The set of vertices is $V = \\{(i,j) : i,j \\in \\{1, 2, 3, 4, 5, 6\\}\\}$. An edge exists between two vertices $(i_1, j_1)$ and $(i_2, j_2)$ if and only if $|i_1 - i_2| + |j_1 - j_2| = 1$. The graph distance $d(v_1, v_2)$ between two vertices $v_1 = (i_1, j_1)$ and $v_2 = (i_2, j_2)$ is the length of the shortest path between them, which on a grid graph is given by the Manhattan distance:\n$$\nd(v_1, v_2) = |i_1 - i_2| + |j_1 - j_2|\n$$\nThe eccentricity of a vertex $v \\in V$, denoted $e(v)$, is the maximum distance from $v$ to any other vertex in the graph:\n$$\ne(v) = \\max_{u \\in V} d(v,u)\n$$\nFor a grid graph, the vertex $u$ that is farthest from $v=(i,j)$ must be one of the four corner vertices: $(1,1)$, $(1,6)$, $(6,1)$, or $(6,6)$. This is because the distance function $d((i,j),(i',j')) = |i-i'| + |j-j'|$ is maximized by independently maximizing the two terms $|i-i'|$ and $|j-j'|$. The value of $i'$ that maximizes $|i-i'|$ is either $1$ or $6$, and similarly for $j'$. Thus, $e(v) = \\max\\{d(v,(1,1)), d(v,(1,6)), d(v,(6,1)), d(v,(6,6))\\}$.\n\nThe number of levels in a Breadth-First Search (BFS) rooted at a vertex $v$ is given by $L(v) = e(v) + 1$, as the levels are indexed from $0$ to $e(v)$.\n\nWe now execute the pseudo-peripheral detection procedure starting from $s_0 = (3,4)$.\n\n**Step 0:** The initial root is $s_0 = (3,4)$. We compute its eccentricity $e(s_0)$.\n$d(s_0, (1,1)) = |3-1| + |4-1| = 2+3 = 5$.\n$d(s_0, (1,6)) = |3-1| + |4-6| = 2+2 = 4$.\n$d(s_0, (6,1)) = |3-6| + |4-1| = 3+3 = 6$.\n$d(s_0, (6,6)) = |3-6| + |4-6| = 3+2 = 5$.\nThe maximum of these distances is $6$. So, $e(s_0) = 6$.\nThe initial number of BFS levels is $L_0 = L(s_0) = e(s_0) + 1 = 6+1=7$.\nThe last BFS level, at distance $6$ from $s_0$, consists of the single vertex $(6,1)$.\n\n**Step 1:** We select a vertex from the last level of the BFS from $s_0$. The only choice is $s_1 = (6,1)$. We now compute its eccentricity $e(s_1)$.\n$d(s_1, (1,1)) = |6-1| + |1-1| = 5+0 = 5$.\n$d(s_1, (1,6)) = |6-1| + |1-6| = 5+5 = 10$.\n$d(s_1, (6,6)) = |6-6| + |1-6| = 0+5 = 5$.\nThe maximum distance is $10$. So, $e(s_1) = 10$.\nThe number of BFS levels for $s_1$ is $L_1 = L(s_1) = e(s_1) + 1 = 10+1=11$.\nSince $L_1 = 11 > L_0 = 7$, the number of levels has strictly increased. The procedure continues, and $s_1$ becomes the new current root. The last BFS level from $s_1$, at distance $10$, consists of the single vertex $(1,6)$.\n\n**Step 2:** We select the vertex from the last level of the BFS from $s_1$, which is $s_2 = (1,6)$. We compute its eccentricity $e(s_2)$.\n$d(s_2, (1,1)) = |1-1| + |6-1| = 0+5 = 5$.\n$d(s_2, (6,1)) = |1-6| + |6-1| = 5+5 = 10$.\n$d(s_2, (6,6)) = |1-6| + |6-6| = 5+0 = 5$.\nThe maximum distance is $10$. So, $e(s_2) = 10$.\nThe number of BFS levels for $s_2$ is $L_2 = L(s_2) = e(s_2) + 1 = 10+1=11$.\nWe compare this with the previous number of levels, $L_1 = 11$. Since $L_2=11$ is not strictly greater than $L_1=11$, the condition for continuing is not met. The procedure terminates. The current root at the time of termination is $s_1=(6,1)$, which is declared the pseudo-peripheral node. The number of BFS levels associated with this terminated state corresponds to the last successful update, which is $L_1$. Therefore, the number of BFS levels at termination is $L_{\\mathrm{pp}} = L_1 = 11$.\n\nNext, we determine the number of BFS levels for the specified corner and center nodes.\n\nFor the corner node $(1,1)$, we compute its eccentricity $e((1,1))$:\n$d((1,1), (1,6)) = |1-1| + |1-6| = 0+5=5$.\n$d((1,1), (6,1)) = |1-6| + |1-1| = 5+0=5$.\n$d((1,1), (6,6)) = |1-6| + |1-6| = 5+5=10$.\nThe maximum distance is $10$, so $e((1,1)) = 10$.\nThe number of BFS levels is $L_{\\mathrm{corner}} = L((1,1)) = e((1,1)) + 1 = 10+1=11$.\n\nFor the center node $(3,3)$, we compute its eccentricity $e((3,3))$:\n$d((3,3), (1,1)) = |3-1| + |3-1| = 2+2=4$.\n$d((3,3), (1,6)) = |3-1| + |3-6| = 2+3=5$.\n$d((3,3), (6,1)) = |3-6| + |3-1| = 3+2=5$.\n$d((3,3), (6,6)) = |3-6| + |3-6| = 3+3=6$.\nThe maximum distance is $6$, so $e((3,3)) = 6$.\nThe number of BFS levels is $L_{\\mathrm{center}} = L((3,3)) = e((3,3)) + 1 = 6+1=7$.\n\nFinally, we compute the required difference $\\Delta L$.\n$$\n\\Delta L = L_{\\mathrm{pp}} - L_{\\mathrm{center}}\n$$\nSubstituting the values we have computed:\n$$\n\\Delta L = 11 - 7 = 4\n$$\nThe scalar difference is $4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "Building on the concept of finding a good starting node, this exercise directly quantifies the impact of that choice on the final matrix bandwidth. By applying the Cuthill–McKee (CM) algorithm to a simple binary tree, you will compare the resulting bandwidth when starting from a poor, central node versus an optimal, peripheral one . This explicit calculation makes the theoretical benefit of a pseudo-peripheral start tangible and demonstrates how a simple change in strategy can yield a significantly more compact matrix structure.",
            "id": "3365677",
            "problem": "In the numerical solution of partial differential equations, sparse symmetric positive definite matrices arise from discretizations on meshes. A classical preprocessing step for direct solvers is to reduce the matrix bandwidth using the Cuthill–McKee (CM) algorithm. The bandwidth of a labeling $\\pi:V\\to\\{1,\\dots,|V|\\}$ of a simple undirected graph $G=(V,E)$ is defined as $b(\\pi)=\\max_{(i,j)\\in E}|\\pi(i)-\\pi(j)|$. The Cuthill–McKee (CM) ordering from a chosen start vertex $s$ is obtained by a breadth-first search (BFS) that visits neighbors in nondecreasing degree order, breaking ties by smaller vertex index. A good practical choice for $s$ is a pseudo-peripheral node, which is a vertex whose eccentricity (the maximum graph distance to any other vertex) is close to the graph diameter, and which is found heuristically by repeated BFS layer expansion.\n\nConsider the following explicitly constructed graph $G$ that models a hierarchical binary refinement tree arising in an adaptive finite element discretization. Let $V=\\{1,2,\\dots,15\\}$ and let $E$ be the edge set of the full binary tree of height $3$ with root $1$, that is,\n$$(1,2),(1,3),(2,4),(2,5),(3,6),(3,7),(4,8),(4,9),(5,10),(5,11),(6,12),(6,13),(7,14),(7,15).$$\nThis tree has diameter $6$, attained between any two leaves in opposite subtrees, and the root $1$ has eccentricity $3$, hence is non-peripheral, while any leaf at depth $3$ (for example $8$) is peripheral and thus acceptable as a pseudo-peripheral start.\n\nUsing the precise CM visiting rule described above (neighbors strictly ordered by nondecreasing degree, breaking ties by smaller index), compute:\n- the CM ordering $\\pi_{1}$ starting at the non-peripheral node $1$ and its bandwidth $b(\\pi_{1})$,\n- the CM ordering $\\pi_{8}$ starting at the pseudo-peripheral node $8$ and its bandwidth $b(\\pi_{8})$,\n\nand then report the exact bandwidth difference\n$$\\Delta b = b(\\pi_{1}) - b(\\pi_{8}).$$\nProvide your final result for $\\Delta b$ as a single integer with no units. No rounding is required.",
            "solution": "The problem asks for the computation of the bandwidth difference between two Cuthill-McKee (CM) orderings of a given graph, starting from two different vertices. The procedure consists of three main steps:\n$1$. Compute the CM ordering $\\pi_1$ starting at vertex $s=1$ and its bandwidth $b(\\pi_1)$.\n$2$. Compute the CM ordering $\\pi_8$ starting at vertex $s=8$ and its bandwidth $b(\\pi_8)$.\n$3$. Calculate the difference $\\Delta b = b(\\pi_1) - b(\\pi_8)$.\n\nThe graph $G=(V, E)$ is a full binary tree of height $3$.\nThe vertex set is $V = \\{1, 2, \\dots, 15\\}$.\nThe edge set $E$ is given by:\n$(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (4,8), (4,9), (5,10), (5,11), (6,12), (6,13), (7,14), (7,15)$.\n\nThe CM algorithm is a Breadth-First Search (BFS) where neighbors of a vertex are visited in order of non-decreasing degree. Ties are broken by choosing the vertex with the smaller index.\n\nFirst, we determine the degree of each vertex in the graph $G$:\n- The root, vertex $1$, has degree $\\deg(1)=2$.\n- The internal nodes at level $1$ and $2$, vertices $\\{2, 3, 4, 5, 6, 7\\}$, each have degree $3$.\n- The leaves, vertices $\\{8, 9, 10, 11, 12, 13, 14, 15\\}$, each have degree $1$.\n\n**Part 1: CM Ordering $\\pi_1$ starting from $s=1$**\n\nWe perform a BFS starting from vertex $1$. The ordering of vertices will be denoted by the sequence $P_1$, where $P_1[k]$ is the vertex assigned the new label $k$. The labeling $\\pi_1$ is the inverse mapping, i.e., $\\pi_1(P_1[k])=k$.\n\n$1$. Initialize: Queue $Q=[1]$, new ordering $P_1=[1]$, Visited $S=\\{1\\}$, label counter $k=1$.\n$2$. Dequeue $1$. Neighbors are $\\{2, 3\\}$. Both have degree $3$. Tie-breaking with vertex index: $2  3$. So, visit $2$ then $3$.\n   - Enqueue $2$, $P_1=[1, 2]$, $S=\\{1,2\\}$, $k=2$.\n   - Enqueue $3$, $P_1=[1, 2, 3]$, $S=\\{1,2,3\\}$, $k=3$.\n   - $Q$ is now $[2, 3]$.\n$3$. Dequeue $2$. Unvisited neighbors are $\\{4, 5\\}$. Both have degree $3$. Tie-breaking: $4  5$. Visit $4$ then $5$.\n   - Enqueue $4$, $P_1=[1, \\dots, 3, 4]$, $S=\\{1,2,3,4\\}$, $k=4$.\n   - Enqueue $5$, $P_1=[1, \\dots, 4, 5]$, $S=\\{1,2,3,4,5\\}$, $k=5$.\n   - $Q$ is now $[3, 4, 5]$.\n$4$. Dequeue $3$. Unvisited neighbors are $\\{6, 7\\}$. Both have degree $3$. Tie-breaking: $6  7$. Visit $6$ then $7$.\n   - Enqueue $6$, $P_1=[1, \\dots, 5, 6]$, $S=\\{...,6\\}$, $k=6$.\n   - Enqueue $7$, $P_1=[1, \\dots, 6, 7]$, $S=\\{...,7\\}$, $k=7$.\n   - $Q$ is now $[4, 5, 6, 7]$.\n$5$. Dequeue $4$. Unvisited neighbors are $\\{8, 9\\}$. Both have degree $1$. Tie-breaking: $8  9$. Visit $8$ then $9$.\n   - Enqueue $8$, $P_1=[1, \\dots, 7, 8]$, $S=\\{...,8\\}$, $k=8$.\n   - Enqueue $9$, $P_1=[1, \\dots, 8, 9]$, $S=\\{...,9\\}$, $k=9$.\n   - $Q$ is now $[5, 6, 7, 8, 9]$.\n$6$. This process continues level by level. For each parent node, its children are visited in increasing order of their vertex indices as they have the same degree.\n   - Dequeue $5$, visit neighbors $10, 11$. $P_1$ appends $10, 11$.\n   - Dequeue $6$, visit neighbors $12, 13$. $P_1$ appends $12, 13$.\n   - Dequeue $7$, visit neighbors $14, 15$. $P_1$ appends $14, 15$.\nThe final ordered sequence of vertices is $P_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$.\nThis means the labeling $\\pi_1$ is the identity: $\\pi_1(i) = i$ for all $i \\in V$.\n\nThe bandwidth $b(\\pi_1)$ is $\\max_{(i,j)\\in E} |\\pi_1(i) - \\pi_1(j)| = \\max_{(i,j)\\in E} |i - j|$. We check all edges:\n- $|1-2|=1$, $|1-3|=2$\n- $|2-4|=2$, $|2-5|=3$\n- $|3-6|=3$, $|3-7|=4$\n- $|4-8|=4$, $|4-9|=5$\n- $|5-10|=5$, $|5-11|=6$\n- $|6-12|=6$, $|6-13|=7$\n- $|7-14|=7$, $|7-15|=8$\nThe maximum difference is $8$. Therefore, $b(\\pi_1) = 8$.\n\n**Part 2: CM Ordering $\\pi_8$ starting from $s=8$**\n\nWe perform a BFS starting from the peripheral vertex $8$.\n$1$. Initialize: $Q=[8]$, $P_8=[8]$, $S=\\{8\\}$, $k=1$.\n$2$. Dequeue $8$. Neighbor is $\\{4\\}$. Visit $4$.\n   - Enqueue $4$, $P_8=[8, 4]$, $S=\\{8,4\\}$, $k=2$. $Q=[4]$.\n$3$. Dequeue $4$. Unvisited neighbors are $\\{2, 9\\}$. We have $\\deg(9)=1$ and $\\deg(2)=3$. Sort by non-decreasing degree: visit $9$ then $2$.\n   - Enqueue $9$, $P_8=[8, 4, 9]$, $S=\\{8,4,9\\}$, $k=3$.\n   - Enqueue $2$, $P_8=[8, 4, 9, 2]$, $S=\\{8,4,9,2\\}$, $k=4$.\n   - $Q$ is now $[9, 2]$.\n$4$. Dequeue $9$. Neighbor $\\{4\\}$ is already visited. $Q=[2]$.\n$5$. Dequeue $2$. Unvisited neighbors are $\\{1, 5\\}$. We have $\\deg(1)=2$ and $\\deg(5)=3$. Sort by degree: visit $1$ then $5$.\n   - Enqueue $1$, $P_8=[8, 4, 9, 2, 1]$, $S=\\{...,1\\}$, $k=5$.\n   - Enqueue $5$, $P_8=[8, 4, 9, 2, 1, 5]$, $S=\\{...,5\\}$, $k=6$.\n   - $Q$ is now $[1, 5]$.\n$6$. Dequeue $1$. Unvisited neighbor is $\\{3\\}$. Visit $3$.\n   - Enqueue $3$, $P_8=[... ,1, 5, 3]$, $S=\\{...,3\\}$, $k=7$. $Q=[5, 3]$.\n$7$. Dequeue $5$. Unvisited neighbors are $\\{10, 11\\}$. Both have degree $1$. Tie-break with index: $10  11$. Visit $10$ then $11$.\n   - Enqueue $10$, $P_8=[..., 5, 3, 10]$, $S=\\{...,10\\}$, $k=8$.\n   - Enqueue $11$, $P_8=[..., 3, 10, 11]$, $S=\\{...,11\\}$, $k=9$.\n   - $Q$ is now $[3, 10, 11]$.\n$8$. Dequeue $3$. Unvisited neighbors are $\\{6, 7\\}$. Both have degree $3$. Tie-break with index: $6  7$. Visit $6$ then $7$.\n   - Enqueue $6$, $P_8=[..., 10, 11, 6]$, $S=\\{...,6\\}$, $k=10$.\n   - Enqueue $7$, $P_8=[..., 11, 6, 7]$, $S=\\{...,7\\}$, $k=11$.\n   - $Q$ is now $[10, 11, 6, 7]$.\n$9$. Dequeue $10$ and $11$. Their only neighbor $\\{5\\}$ is visited. $Q=[6, 7]$.\n$10$. Dequeue $6$. Unvisited neighbors $\\{12, 13\\}$. Both degree $1$. Tie-break: $12  13$. Visit $12$ then $13$.\n   - Enqueue $12, 13$. $P_8$ appends $12, 13$. $k=13$. $Q=[7, 12, 13]$.\n$11$. Dequeue $7$. Unvisited neighbors $\\{14, 15\\}$. Both degree $1$. Tie-break: $14  15$. Visit $14$ then $15$.\n   - Enqueue $14, 15$. $P_8$ appends $14, 15$. $k=15$. $Q=[12, 13, 14, 15]$.\n$12$. Dequeue remaining leaves $12, 13, 14, 15$. They have no unvisited neighbors.\n\nThe final ordered sequence of vertices is $P_8 = [8, 4, 9, 2, 1, 5, 3, 10, 11, 6, 7, 12, 13, 14, 15]$.\nThe labeling $\\pi_8$ maps a vertex to its position (label) in this sequence:\n$\\pi_8(8)=1$, $\\pi_8(4)=2$, $\\pi_8(9)=3$, $\\pi_8(2)=4$, $\\pi_8(1)=5$, $\\pi_8(5)=6$, $\\pi_8(3)=7$, $\\pi_8(10)=8$, $\\pi_8(11)=9$, $\\pi_8(6)=10$, $\\pi_8(7)=11$, $\\pi_8(12)=12$, $\\pi_8(13)=13$, $\\pi_8(14)=14$, $\\pi_8(15)=15$.\n\nThe bandwidth $b(\\pi_8)$ is $\\max_{(i,j)\\in E} |\\pi_8(i) - \\pi_8(j)|$. We check all edges:\n- $(1,2): |\\pi_8(1)-\\pi_8(2)| = |5-4|=1$\n- $(1,3): |\\pi_8(1)-\\pi_8(3)| = |5-7|=2$\n- $(2,4): |\\pi_8(2)-\\pi_8(4)| = |4-2|=2$\n- $(2,5): |\\pi_8(2)-\\pi_8(5)| = |4-6|=2$\n- $(3,6): |\\pi_8(3)-\\pi_8(6)| = |7-10|=3$\n- $(3,7): |\\pi_8(3)-\\pi_8(7)| = |7-11|=4$\n- $(4,8): |\\pi_8(4)-\\pi_8(8)| = |2-1|=1$\n- $(4,9): |\\pi_8(4)-\\pi_8(9)| = |2-3|=1$\n- $(5,10): |\\pi_8(5)-\\pi_8(10)| = |6-8|=2$\n- $(5,11): |\\pi_8(5)-\\pi_8(11)| = |6-9|=3$\n- $(6,12): |\\pi_8(6)-\\pi_8(12)| = |10-12|=2$\n- $(6,13): |\\pi_8(6)-\\pi_8(13)| = |10-13|=3$\n- $(7,14): |\\pi_8(7)-\\pi_8(14)| = |11-14|=3$\n- $(7,15): |\\pi_8(7)-\\pi_8(15)| = |11-15|=4$\nThe maximum difference is $4$. Therefore, $b(\\pi_8) = 4$.\n\n**Part 3: Bandwidth Difference**\n\nFinally, we compute the difference $\\Delta b$:\n$$ \\Delta b = b(\\pi_1) - b(\\pi_8) = 8 - 4 = 4. $$\nThe choice of a pseudo-peripheral node as the starting vertex for the Cuthill-McKee algorithm resulted in a significant reduction of the matrix bandwidth.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "While powerful, heuristics like Reverse Cuthill–McKee (RCM) are not infallible and can perform poorly on certain graph topologies. This exercise challenges you to move beyond rote application and critically analyze the algorithm's behavior by constructing a \"dumbbell\" mesh, a classic counterexample where RCM actually *increases* the matrix bandwidth. By implementing and observing this failure mode, you will gain a deeper appreciation for the importance of graph structure, particularly bottlenecks, and learn to recognize scenarios where standard reordering algorithms may not be the optimal choice.",
            "id": "3365697",
            "problem": "You are asked to explore the behavior of ordering algorithms on sparse matrices arising from the discretization of the two-dimensional Poisson equation, with a focus on bandwidth reduction. Consider the canonical linear finite difference or linear finite element discretization of the two-dimensional Poisson equation on a mesh (interpreted as a graph), which yields a symmetric positive definite matrix $A \\in \\mathbb{R}^{n \\times n}$ whose sparsity pattern is determined by mesh adjacency. The bandwidth $b(A)$ of a square matrix $A$ is defined by\n$$\nb(A) = \\max\\{\\,|i - j| \\,\\mid\\, A_{ij} \\neq 0 \\,\\},\n$$\nand for a given permutation (ordering) $p \\in \\{0,1,\\dots,n-1\\}^n$ of the indices, the permuted bandwidth is the bandwidth of the matrix $PAP^\\top$ where $P$ is the permutation matrix associated with $p$.\n\nThe Reverse Cuthill–McKee (RCM) technique is a heuristic algorithm intended to reduce bandwidth. It operates by performing a breadth-first traversal of the graph starting from a designated root, visiting vertices level by level, ordering vertices by nondecreasing degree within each level, and then reversing the obtained order. In practice there are different root-selection heuristics; for the purposes of this task, you must use the following well-defined variant:\n- Choose a start vertex $s$ as follows: if the graph has articulation points (cut vertices), select among them the one with minimum degree; if there are multiple such vertices, pick the one with the smallest index. If no articulation points exist, select the minimum-degree vertex with the smallest index.\n- Perform breadth-first search (BFS) from $s$, visiting neighbors in nondecreasing degree order (break ties by smaller index).\n- If the graph is disconnected, repeat the above for any remaining unvisited component (at each stage choosing the new root by the same rule among unvisited vertices).\n- Reverse the concatenated BFS order to produce the final RCM permutation $p_{\\mathrm{RCM}}$.\n\nStarting from fundamental definitions (graph adjacency derived from a mesh, the matrix bandwidth definition, and breadth-first traversal), construct deterministic meshes that expose when RCM can fail to reduce bandwidth relative to an initial geometric ordering, and provide a geometric characterization of that failure mechanism.\n\nPrecisely:\n1. Build the discrete Laplacian matrix adjacency for a regular grid mesh: a rectangular grid of size $W \\times H$, where grid points are connected by four-neighbor adjacency (Manhattan distance equal to $1$). Use the initial order $p_{\\mathrm{geo}}$ given by scanning in nondecreasing $x$ then nondecreasing $y$ (this is the geometric lexicographic order).\n2. Build a \"dumbbell\" mesh that consists of two vertical columns of nodes connected by a single central corridor node. Specifically, define the coordinate sets:\n   - Left column: $(0,0)$, $(0,1)$, $(0,2)$,\n   - Corridor: $(1,1)$,\n   - Right column: $(2,0)$, $(2,1)$, $(2,2)$,\n   with four-neighbor adjacency. Use the initial order $p_{\\mathrm{geo}}$ that lists nodes in the sequence: all left-column nodes (from $(0,0)$ to $(0,2)$), then the corridor node $(1,1)$, then all right-column nodes (from $(2,0)$ to $(2,2)$). This ordering is consistent with a geometric lexicographic order for these coordinates.\n3. Build a one-dimensional chain mesh (a straight path): coordinates $(0,0)$, $(1,0)$, $(2,0)$, $(3,0)$, $(4,0)$ where adjacency is between consecutive points only. Use the initial order $p_{\\mathrm{geo}}$ that lists nodes by nondecreasing $x$.\n\nFor each mesh, compute:\n- The bandwidth $b_{\\mathrm{geo}} = b(P_{\\mathrm{geo}} A P_{\\mathrm{geo}}^\\top)$ under the initial geometric ordering $p_{\\mathrm{geo}}$.\n- The bandwidth $b_{\\mathrm{RCM}} = b(P_{\\mathrm{RCM}} A P_{\\mathrm{RCM}}^\\top)$ under the RCM ordering $p_{\\mathrm{RCM}}$ defined above.\n- Report the integer delta $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$.\n\nYou must implement the matrix bandwidth computation strictly from the definition of $b(A)$ above. You must construct the adjacency $A$ from the mesh coordinates by connecting nodes whose coordinates differ by exactly one in the $\\ell_1$ norm. You are not required to compute numerical finite difference coefficients; only the nonzero structure is necessary. Ensure scientific realism by adhering to the stated discretization patterns and definitions.\n\nExplain, with a derivation grounded in the definitions, why the \"dumbbell\" mesh can lead to an increase in bandwidth under the stated RCM variant, and characterize the geometric feature responsible for the failure in terms of graph-theoretic properties of the mesh (e.g., cut vertices and bottlenecks).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of the three test meshes described above. The expected output types are integers. For example, produce a line of the form\n$$\n[\\Delta b_{\\mathrm{grid}}, \\Delta b_{\\mathrm{dumbbell}}, \\Delta b_{\\mathrm{chain}}].\n$$\n\nTest suite parameters:\n- Grid mesh: $W = 4$, $H = 4$ (happy path where RCM should not increase bandwidth relative to the geometric ordering).\n- Dumbbell mesh: the coordinates specified above (counterexample candidate where RCM increases bandwidth relative to the given geometric ordering).\n- Chain mesh: the coordinates specified above (edge case where bandwidth is already minimal).\n\nNo physical units or angles appear in this problem. Express each numerical result as an integer in the list format specified.",
            "solution": "The user-provided problem statement has been validated and is determined to be sound, well-posed, and objective. It presents a clear task in the domain of numerical linear algebra and graph theory, with all necessary definitions, constants, and constraints provided. The problem asks for the implementation and analysis of a specific variant of the Reverse Cuthill–McKee (RCM) algorithm for sparse matrix bandwidth reduction. We will proceed with a complete solution.\n\n### Introduction to Bandwidth Reduction\nIn the numerical solution of partial differential equations (PDEs) using methods like finite differences or finite elements, the resulting system of linear equations $Ax=b$ often involves a sparse, symmetric, and positive definite matrix $A$. The efficiency of direct solvers (e.g., LU or Cholesky factorization) for such systems is highly dependent on the matrix's structure. A key structural property is the **bandwidth**, defined for a matrix $A$ as:\n$$\nb(A) = \\max_{i,j} \\{|i - j| \\mid A_{ij} \\neq 0\\}\n$$\nA smaller bandwidth implies that all non-zero entries are clustered around the main diagonal. This structure can be exploited to reduce both memory storage and computational work during factorization. Reordering algorithms aim to find a permutation $p$ of the matrix rows and columns such that the permuted matrix, $P A P^\\top$ (where $P$ is the permutation matrix corresponding to $p$), has a significantly smaller bandwidth than the original $A$.\n\nThe Reverse Cuthill–McKee (RCM) algorithm is a widely used heuristic for this purpose. It is based on a breadth-first search (BFS) of the graph associated with the matrix's sparsity pattern. This analysis investigates a specific, deterministic variant of RCM and examines its performance on three distinct mesh types, including a case designed to expose a failure mode of the heuristic.\n\n### Methodology\nFor each mesh, we perform the following steps:\n1.  **Graph Construction**: We construct an undirected graph $G=(V, E)$, where vertices $V$ correspond to the mesh nodes and edges $E$ connect nodes with a Manhattan distance ($\\ell_1$ norm) of exactly $1$. The adjacency matrix of this graph has the same non-zero pattern as the discrete Laplacian matrix $A$.\n2.  **Geometric Ordering ($p_{\\mathrm{geo}}$)**: We establish the initial \"geometric\" ordering $p_{\\mathrm{geo}}$ as specified for each mesh. This serves as our baseline.\n3.  **Bandwidth Calculation ($b_{\\mathrm{geo}}$)**: We compute the bandwidth of the matrix corresponding to the geometric ordering. An edge between original nodes $u$ and $v$ contributes $|p_{\\mathrm{geo}}^{-1}(u) - p_{\\mathrm{geo}}^{-1}(v)|$ to the bandwidth consideration, where $p_{\\mathrm{geo}}^{-1}(k)$ is the new index of the original node $k$.\n4.  **RCM Ordering ($p_{\\mathrm{RCM}}$)**: We implement the RCM algorithm as defined in the problem:\n    a.  **Root Selection**: If articulation points exist, the root is the one with minimum degree (smallest index as tie-breaker). Otherwise, it is the overall minimum-degree vertex (smallest index as tie-breaker).\n    b.  **Traversal**: A BFS is performed from the root. When visiting neighbors of a node, they are processed in order of non-decreasing degree (smallest index as tie-breaker).\n    c.  **Reversal**: The final permutation $p_{\\mathrm{RCM}}$ is the reverse of the BFS traversal order.\n5.  **Bandwidth Calculation ($b_{\\mathrm{RCM}}$)**: We compute the bandwidth for the RCM-permuted matrix.\n6.  **Comparison**: We calculate the difference $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$.\n\n### Analysis of Test Cases\n\n#### 1. Grid Mesh ($4 \\times 4$)\nA $W \\times H$ grid graph is constructed with $n=WH$ nodes. The geometric ordering $p_{\\mathrm{geo}}$ is lexicographical, where node $(x,y)$ is assigned the index $i = xH + y$. For a $4 \\times 4$ grid, $H=4$.\n*   **Geometric Bandwidth ($b_{\\mathrm{geo}}$)**: The maximum index difference occurs between vertically adjacent nodes. A node $(x,y)$ with index $i = 4x+y$ is connected to node $(x+1, y)$ with index $j = 4(x+1)+y$. The difference is $|j-i| = 4$. Thus, $b_{\\mathrm{geo}} = 4$.\n*   **RCM Bandwidth ($b_{\\mathrm{RCM}}$)**: The grid has no articulation points. The minimum-degree nodes are the four corners (degree $2$). The root is the corner $(0,0)$ (original index $0$), which has the smallest index. RCM performs a BFS from this corner, creating level sets that expand in wavefronts. Reversing this order places nodes that are far from the root at the beginning of the permutation. This is the canonical application of RCM, which typically performs well. The resulting bandwidth $b_{\\mathrm{RCM}}$ is found to be $4$.\n*   **Result**: $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 4 = 0$. RCM does not worsen the bandwidth in this case.\n\n#### 2. Dumbbell Mesh\nThis mesh consists of $7$ nodes forming two three-node lobes connected by a single central node. The geometric ordering is $p_{\\mathrm{geo}} = (0, 1, 2, 3, 4, 5, 6)$, where nodes $0, 1, 2$ form the left lobe, $3$ is the corridor, and $4, 5, 6$ form the right lobe.\n*   **Geometric Bandwidth ($b_{\\mathrm{geo}}$)**: The graph edges are $(0,1), (1,2), (1,3), (3,5), (4,5), (5,6)$. We inspect the index differences for each edge:\n    *   $|p_{\\mathrm{geo}}^{-1}(1) - p_{\\mathrm{geo}}^{-1}(0)| = |1-0|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(2) - p_{\\mathrm{geo}}^{-1}(1)| = |2-1|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(3) - p_{\\mathrm{geo}}^{-1}(1)| = |3-1|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(3)| = |5-3|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(4)| = |5-4|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(6) - p_{\\mathrm{geo}}^{-1}(5)| = |6-5|=1$\n    The maximum difference is $2$. Thus, $b_{\\mathrm{geo}} = 2$.\n*   **RCM Bandwidth ($b_{\\mathrm{RCM}}$)**: We follow the specified RCM procedure:\n    1.  **Find Articulation Points (APs)**: Nodes $1, 3, 5$ are APs.\n    2.  **Select Root**: Their degrees are $\\text{deg}(1)=3, \\text{deg}(3)=2, \\text{deg}(5)=3$. The AP with minimum degree is node $3$. This becomes the root.\n    3.  **BFS Traversal**:\n        *   Start with root: $\\{3\\}$\n        *   Neighbors of $3$ are $\\{1, 5\\}$. Both have degree $3$. Tie-break with smaller index: visit $1$ then $5$. Queue: $\\{1, 5\\}$.\n        *   Neighbors of $1$: $\\{0, 2\\}$. Both have degree $1$. Tie-break with index: visit $0$ then $2$. Queue: $\\{5, 0, 2\\}$.\n        *   Neighbors of $5$: $\\{4, 6\\}$. Both have degree $1$. Tie-break with index: visit $4$ then $6$. Queue: $\\{0, 2, 4, 6\\}$.\n        The Cuthill–McKee (CM) order is $p_{\\mathrm{CM}} = (3, 1, 5, 0, 2, 4, 6)$.\n    4.  **Reverse Order**: $p_{\\mathrm{RCM}} = (6, 4, 2, 0, 5, 1, 3)$.\n    5.  **Compute Bandwidth**: We find the new indices $p_{\\mathrm{RCM}}^{-1}$ of each node and check edge differences. The edge $(5,6)$ is illustrative. Its original nodes are $5$ and $6$. Their new indices are $p_{\\mathrm{RCM}}^{-1}(5)=4$ and $p_{\\mathrm{RCM}}^{-1}(6)=0$. The difference is $|4-0|=4$. The full calculation confirms $b_{\\mathrm{RCM}} = 4$.\n*   **Result**: $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 2 = 2$. The bandwidth has increased.\n\n#### 3. Chain Mesh\nA $5$-node path graph. Original nodes are indexed $0, 1, 2, 3, 4$. $p_{\\mathrm{geo}}$ is this natural ordering.\n*   **Geometric Bandwidth ($b_{\\mathrm{geo}}$)**: The edges are $(i, i+1)$. The index difference is always $1$. Thus, $b_{\\mathrm{geo}} = 1$. This is the optimal bandwidth.\n*   **RCM Bandwidth ($b_{\\mathrm{RCM}}$)**:\n    1.  **Find APs**: Nodes $1, 2, 3$ are APs.\n    2.  **Select Root**: All APs have degree $2$. The one with the smallest index is node $1$.\n    3.  **BFS Traversal**: from root $1$: visit neighbor $0$ (degree $1$), then neighbor $2$ (degree $2$). Then from $2$ visit $3$, from $3$ visit $4$. The CM order is $p_{\\mathrm{CM}} = (1, 0, 2, 3, 4)$.\n    4.  **Reverse Order**: $p_{\\mathrm{RCM}} = (4, 3, 2, 0, 1)$.\n    5.  **Compute Bandwidth**: Consider the edge $(1,2)$. The new indices are $p_{\\mathrm{RCM}}^{-1}(1)=4$ and $p_{\\mathrm{RCM}}^{-1}(2)=2$. The difference is $|4-2|=2$. The full calculation gives $b_{\\mathrm{RCM}} = 2$.\n*   **Result**: $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 2 - 1 = 1$. The bandwidth has increased.\n\n### Characterization of RCM Failure\nThe dumbbell mesh exemplifies a classic failure mode for RCM. The degradation in performance is not random but is a direct consequence of the interaction between the graph's topology and the algorithm's root-selection heuristic.\n\nThe geometric feature responsible is the **bottleneck** structure, where two or more relatively dense subgraphs are connected by a small number of vertices or edges. In the dumbbell mesh, node $3$ (the \"corridor\") acts as a low-degree articulation point connecting the two lobes.\n\nThe specified RCM variant prioritizes finding a low-degree articulation point as the root. By selecting the central bottleneck node $3$ as the root, the subsequent BFS traversal expands into both lobes simultaneously. The level sets of the BFS (e.g., level 1 contains nodes $\\{1, 5\\}$) group nodes that are topologically distant but are at an equal graph distance from the central root.\n\nThe final step of RCM reverses this order. This places nodes from the extremities of the graph (e.g., nodes $6, 4, 2, 0$) at the beginning of the new permutation. Crucially, it scatters nodes that were originally adjacent within a lobe. For instance, adjacent nodes $5$ and $6$ are assigned new indices $4$ and $0$, resulting in a large index difference of $4$. The geometric ordering, by contrast, kept nodes within each lobe contiguous, resulting in a small bandwidth.\n\nIn summary, the RCM heuristic fails when its root-selection strategy picks a vertex on a structural bottleneck. This leads to a BFS ordering that interleaves nodes from disparate regions of the graph, and the final reversal tears apart local connectivity, thereby increasing the matrix bandwidth. An ideal starting vertex would be a low-degree node at the periphery of the graph (like node $0$ or $6$), which would produce a level structure that respects the graph's geometric layout.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the bandwidth analysis for the three specified meshes.\n    \"\"\"\n\n    def _find_articulation_points(n, adj):\n        \"\"\"\n        Finds all articulation points in a graph using a DFS-based algorithm.\n        This is a standard algorithm related to Tarjan's bridge-finding algorithm.\n        \"\"\"\n        timer_ref = [0]\n        tin = [-1] * n\n        low = [-1] * n\n        parent = [-1] * n\n        ap_set = set()\n\n        def dfs(u):\n            tin[u] = low[u] = timer_ref[0]\n            timer_ref[0] += 1\n            children = 0\n\n            for v in adj[u]:\n                if v == parent[u]:\n                    continue\n                if tin[v] != -1:\n                    low[u] = min(low[u], tin[v])\n                else:\n                    children += 1\n                    parent[v] = u\n                    dfs(v)\n                    low[u] = min(low[u], low[v])\n                    if parent[u] == -1 and children > 1:\n                        ap_set.add(u)\n                    if parent[u] != -1 and low[v] >= tin[u]:\n                        ap_set.add(u)\n\n        for i in range(n):\n            if tin[i] == -1:\n                dfs(i)\n        \n        return list(ap_set)\n\n    def select_root(degrees, aps, visited):\n        \"\"\"\n        Selects a root for BFS according to the problem's specific heuristic.\n        \"\"\"\n        unvisited_nodes = [i for i, v in enumerate(visited) if not v]\n        \n        unvisited_aps = [ap for ap in aps if not visited[ap]]\n        \n        candidate_nodes = []\n        if unvisited_aps:\n            min_deg_ap = min(degrees[ap] for ap in unvisited_aps)\n            candidate_nodes = [ap for ap in unvisited_aps if degrees[ap] == min_deg_ap]\n        else:\n            min_deg = min(degrees[i] for i in unvisited_nodes)\n            candidate_nodes = [i for i in unvisited_nodes if degrees[i] == min_deg]\n            \n        return min(candidate_nodes)\n\n    def get_rcm_permutation(adj):\n        \"\"\"\n        Computes the Reverse Cuthill-McKee permutation for a given graph.\n        \"\"\"\n        n = len(adj)\n        if n == 0:\n            return []\n        degrees = [len(a) for a in adj]\n        aps = _find_articulation_points(n, adj)\n        \n        cm_order = []\n        visited = [False] * n\n        \n        while len(cm_order) < n:\n            root = select_root(degrees, aps, visited)\n            \n            # BFS starting from the selected root\n            component_order = []\n            q = [root]\n            visited[root] = True\n            \n            head = 0\n            while head < len(q):\n                u = q[head]\n                component_order.append(u)\n                \n                # Sort neighbors by non-decreasing degree, breaking ties with smaller index\n                neighbors = sorted(adj[u], key=lambda v: (degrees[v], v))\n                \n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                head += 1\n            \n            cm_order.extend(component_order)\n\n        return cm_order[::-1]\n\n    def compute_bandwidth(adj, p):\n        \"\"\"\n        Computes the bandwidth of a matrix permuted by permutation p.\n        \"\"\"\n        n = len(p)\n        if n == 0:\n            return 0\n        p_inv = [0] * n\n        for i, original_index in enumerate(p):\n            p_inv[original_index] = i\n            \n        max_diff = 0\n        for u in range(n):\n            for v in adj[u]:\n                if u < v: # Process each edge once\n                    diff = abs(p_inv[u] - p_inv[v])\n                    if diff > max_diff:\n                        max_diff = diff\n        return max_diff\n\n    def build_graph_from_coords(coords):\n        \"\"\"\n        Builds a graph based on 4-neighbor adjacency (Manhattan distance = 1).\n        \"\"\"\n        n = len(coords)\n        adj = [[] for _ in range(n)]\n        coords_np = [np.array(c) for c in coords]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if np.linalg.norm(coords_np[i] - coords_np[j], ord=1) == 1.0:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        return adj\n\n    # Define the test cases from the problem statement.\n    W, H = 4, 4\n    grid_coords = [(x, y) for y in range(H) for x in range(W)]\n    \n    dumbbell_coords = [(0,0), (0,1), (0,2), (1,1), (2,0), (2,1), (2,2)]\n    \n    chain_coords = [(x, 0) for x in range(5)]\n    \n    test_cases = [\n        {\n            \"name\": \"grid\",\n            \"coords\": grid_coords,\n            \"p_geo\": list(range(len(grid_coords))) # Already in lexicographic order\n        },\n        {\n            \"name\": \"dumbbell\",\n            \"coords\": dumbbell_coords,\n            \"p_geo\": list(range(len(dumbbell_coords))) # Already in specified order\n        },\n        {\n            \"name\": \"chain\",\n            \"coords\": chain_coords,\n            \"p_geo\": list(range(len(chain_coords))) # Already in specified order\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        adj = build_graph_from_coords(case[\"coords\"])\n        \n        # Geometric ordering\n        p_geo = case[\"p_geo\"]\n        b_geo = compute_bandwidth(adj, p_geo)\n        \n        # RCM ordering\n        p_rcm = get_rcm_permutation(adj)\n        b_rcm = compute_bandwidth(adj, p_rcm)\n        \n        delta_b = b_rcm - b_geo\n        results.append(delta_b)\n    \n    # Correction for Grid mesh ordering\n    # The problem asks for \"nondecreasing x then nondecreasing y\".\n    # My grid_coords generation was row-major, this is column-major.\n    # W=4, H=4. p_geo is (0,0), (0,1), (0,2), (0,3), (1,0), ...\n    # index of (x,y) is x*H + y.\n    # edge ((x,y), (x+1,y)) has indices xH+y and (x+1)H+y. diff is H=4.\n    # edge ((x,y), (x,y+1)) has indices xH+y and xH+y+1. diff is 1.\n    # The geometric bandwidth is H=4. The code for grid_coords was wrong.\n    grid_coords_correct = [(x,y) for x in range(W) for y in range(H)]\n    adj_grid = build_graph_from_coords(grid_coords_correct)\n    b_geo_grid = compute_bandwidth(adj_grid, list(range(W*H)))\n    p_rcm_grid = get_rcm_permutation(adj_grid)\n    b_rcm_grid = compute_bandwidth(adj_grid, p_rcm_grid)\n    results[0] = b_rcm_grid - b_geo_grid\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}