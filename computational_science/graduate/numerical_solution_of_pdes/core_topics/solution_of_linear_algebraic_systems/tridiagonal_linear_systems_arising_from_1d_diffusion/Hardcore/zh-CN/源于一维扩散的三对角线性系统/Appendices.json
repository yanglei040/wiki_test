{
    "hands_on_practices": [
        {
            "introduction": "当我们使用像后向欧拉这样的隐式方法来求解扩散方程时，每个时间步都需要求解一个线性方程组。这个线性系统的矩阵的条件数对于解的稳定性和求解器效率至关重要。本练习将运用盖尔圆定理（Gershgorin Circle Theorem）来估计该矩阵特征值的范围，进而推导出其条件数的界，从而深入理解数值格式的稳定性。 ",
            "id": "3458560",
            "problem": "考虑定义在区间 $(0,1)$ 上的一维扩散方程 $u_{t} = D\\,u_{xx}$，其具有齐次狄利克雷边界条件，并在空间上使用包含 $n$ 个内部点的均匀网格，网格间距为 $h$。采用时间步长为 $\\tau$ 的后向欧拉时间离散化，可得到一个关于 $u^{k+1}$ 的线性系统，其形式为 $(I - \\lambda T)\\,u^{k+1} = u^{k}$，其中 $I$ 是单位矩阵，$\\lambda = \\tau D / h^{2} > 0$，$T \\in \\mathbb{R}^{n \\times n}$ 是与在具有齐次狄利克雷条件的内部网格上对 $u_{xx}$ 进行二阶中心有限差分近似相关的三对角托普利茨矩阵，其主对角线上的元素为 $-2$，紧邻的次对角线上的元素为 $1$。利用盖尔圆定理和关于对称矩阵的性质，确定当 $n \\geq 2$ 和 $\\lambda > 0$ 时，该线性系统矩阵的2-范数条件数 $\\kappa_{2}(I - \\lambda T)$ 的基于盖尔圆的最紧上界。请将最终答案表示为关于 $\\lambda$ 的闭式解析表达式。无需四舍五入，不涉及单位。",
            "solution": "### 第1步：分析问题并确定方法\n问题要求我们找到矩阵 $A = I - \\lambda T$ 的2-范数条件数 $\\kappa_{2}(A)$ 的基于盖尔圆定理的最紧上界。\n-   矩阵 $A$ 是一个 $n \\times n$ 的实对称三对角矩阵。\n-   主对角线元素为 $A_{ii} = 1 - \\lambda(-2) = 1 + 2\\lambda$。\n-   次对角线和超对角线元素为 $A_{i, i \\pm 1} = -\\lambda$。\n-   由于 $A$ 是对称矩阵，其2-范数条件数为 $\\kappa_{2}(A) = \\frac{\\max_j |\\mu_j|}{\\min_j |\\mu_j|}$，其中 $\\mu_j$ 是 $A$ 的特征值。\n-   盖尔圆定理指出，矩阵的所有特征值都位于所有盖尔圆盘的并集内。由于 $A$ 是对称的，其特征值是实数，所以盖尔圆盘是实轴上的区间。\n\n### 第2步：应用盖尔圆定理\n对于矩阵 $A$ 的第 $i$ 行，盖尔圆区间是 $[A_{ii} - R_i, A_{ii} + R_i]$，其中 $R_i = \\sum_{j \\neq i} |A_{ij}|$ 是第 $i$ 行非对角元素绝对值之和。\n\n我们根据行的位置计算盖尔圆区间：\n1.  **对于第一行 ($i=1$) 和最后一行 ($i=n$)：**\n    -   圆心为 $A_{11} = A_{nn} = 1+2\\lambda$。\n    -   半径为 $R_1 = |A_{12}| = |-\\lambda| = \\lambda$ (因为 $\\lambda > 0$) 且 $R_n = |A_{n,n-1}| = |-\\lambda| = \\lambda$。\n    -   这些行的盖尔圆区间为 $[(1+2\\lambda)-\\lambda, (1+2\\lambda)+\\lambda] = [1+\\lambda, 1+3\\lambda]$。\n\n2.  **对于内部行 ($i=2, \\dots, n-1$) (如果存在，即 $n \\geq 3$)：**\n    -   圆心为 $A_{ii} = 1+2\\lambda$。\n    -   半径为 $R_i = |A_{i,i-1}| + |A_{i,i+1}| = |-\\lambda| + |-\\lambda| = 2\\lambda$。\n    -   这些行的盖尔圆区间为 $[(1+2\\lambda)-2\\lambda, (1+2\\lambda)+2\\lambda] = [1, 1+4\\lambda]$。\n\n所有特征值 $\\mu_j$ 都位于这些区间的并集 $\\mathcal{G}$ 中。\n\n### 第3步：确定并集和条件数上界\n我们需要考虑 $n$ 的不同情况。\n\n-   **情况 1: $n=2$。**\n    矩阵只有两行，均为端点类型。因此，所有盖尔圆盘的并集是 $\\mathcal{G} = [1+\\lambda, 1+3\\lambda]$。所有特征值 $\\mu_j$ 都位于此区间内。由于 $\\lambda > 0$，此区间内的所有值都为正。因此，我们可以界定条件数：\n    $$\n    \\kappa_{2}(A) \\le \\frac{\\sup\\{x \\mid x \\in [1+\\lambda, 1+3\\lambda]\\}}{\\inf\\{x \\mid x \\in [1+\\lambda, 1+3\\lambda]\\}} = \\frac{1+3\\lambda}{1+\\lambda}\n    $$\n\n-   **情况 2: $n \\geq 3$。**\n    盖尔圆盘的集合为 $\\{[1+\\lambda, 1+3\\lambda], [1, 1+4\\lambda]\\}$。由于 $\\lambda > 0$，我们有 $1  1+\\lambda$ 且 $1+3\\lambda  1+4\\lambda$。这意味着区间 $[1+\\lambda, 1+3\\lambda]$ 完全包含在区间 $[1, 1+4\\lambda]$ 内。因此，并集是 $\\mathcal{G} = [1, 1+4\\lambda]$。所有特征值 $\\mu_j$ 都位于此区间内，并且都为正。条件数上界为：\n    $$\n    \\kappa_{2}(A) \\le \\frac{\\sup\\{x \\mid x \\in [1, 1+4\\lambda]\\}}{\\inf\\{x \\mid x \\in [1, 1+4\\lambda]\\}} = \\frac{1+4\\lambda}{1} = 1+4\\lambda\n    $$\n\n### 第4步：找到对所有 $n \\ge 2$ 都有效的最紧上界\n问题要求一个对所有 $n \\geq 2$ 都有效的单一上界。这个界必须大于或等于为 $n=2$ 和 $n \\geq 3$ 推导出的两个界。我们比较这两个界：$1+4\\lambda$ 和 $\\frac{1+3\\lambda}{1+\\lambda}$。\n\n对于 $\\lambda > 0$：\n$$\n(1+4\\lambda) - \\frac{1+3\\lambda}{1+\\lambda} = \\frac{(1+4\\lambda)(1+\\lambda) - (1+3\\lambda)}{1+\\lambda} = \\frac{(1+5\\lambda+4\\lambda^2) - (1+3\\lambda)}{1+\\lambda} = \\frac{2\\lambda+4\\lambda^2}{1+\\lambda}\n$$\n由于 $\\lambda > 0$，分子 $2\\lambda+4\\lambda^2 > 0$，分母 $1+\\lambda > 0$。因此，它们的比值为正，这意味着 $1+4\\lambda > \\frac{1+3\\lambda}{1+\\lambda}$。\n\n因此，界 $1+4\\lambda$ 对所有 $n \\geq 2$ 都有效，并且是这两种情况中较大的一个。当 $n \\to \\infty$ 时，真实条件数会趋近于此界，这证实了它是通过应用盖尔圆定理可以获得的、与 $n$ 无关的最紧上界。\n\n对于 $n \\geq 2$，$\\kappa_{2}(I - \\lambda T)$ 基于盖尔圆的最紧上界是 $1+4\\lambda$。",
            "answer": "$$\n\\boxed{1+4\\lambda}\n$$"
        },
        {
            "introduction": "从分析矩阵的基本性质，我们转向求解这些线性系统的方法。虽然直接法对于一维问题很有效，但迭代法对于更高维度的问题是必不可少的。本练习将介绍局部傅里叶分析（Local Fourier Analysis），用以量化为何像高斯-赛德尔法这样一个看似简单的迭代法，却是多重网格法等高级算法中的强大组成部分（即“平滑算子”），其关键在于它能高效地衰减误差中的高频分量。 ",
            "id": "3458583",
            "problem": "考虑一个均匀网格上的一维扩散模型问题，该问题导出了与离散拉普拉斯算子相关的三对角系统。具体来说，令 $A$ 表示一个 $N \\times N$ 的三对角矩阵，其模板为 $[-1,\\, 2,\\, -1]$，对应于带有齐次狄利克雷边界条件的负二阶导数的二阶中心有限差分格式。假设我们使用标准的前向字典序高斯-赛德尔 (GS) 方法求解 $A x = b$。将 $A$ 分解为 $A = L + D + U$，其中 $D$ 是对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。\n\n使用误差传播的观点和周期性延拓来进行局部傅里叶分析 (LFA)。也就是说，考虑一次 GS 扫描后的误差满足 $e^{\\text{new}} = T e^{\\text{old}}$，其中 $T = -(D + L)^{-1} U$，并分析 $T$ 在离散傅里叶模 $e_j = \\exp(i j \\theta)$ ($j \\in \\mathbb{Z}$，$\\theta \\in [0, \\pi]$) 上的作用。推导标量放大因子 $g(\\theta)$，使得 $T$ 将傅里叶模映射为该模乘以 $g(\\theta)$，然后定义高频集 $\\Theta_H = [\\pi/2,\\, \\pi]$，它是在标准双网格多重网格方法中，在下一层更粗网格上可表示的子空间的补集。\n\n从迭代法和离散算子的第一性原理出发，计算平滑因子\n$$\n\\mu_s \\;=\\; \\sup_{\\theta \\in \\Theta_H} \\, |g(\\theta)|,\n$$\n并将你的最终结果表示为一个单一的封闭形式实数。在你的推导中，明确论证为什么这个值可以量化高频误差模态的衰减，并简要解释这种衰减如何与一维双网格多重网格方法的效率相关联。最终的数值必须精确给出，不能是近似值，并且不带单位。",
            "solution": "### 步骤1：定义算子和傅里叶分析设置\n根据问题描述，我们分析用于求解 $A x = b$ 的高斯-赛德尔法，其中 $A$ 的模板是 $[-1, 2, -1]$。矩阵 $A$ 可以分解为 $A = L+D+U$，其中：\n-   $(Dv)_j = 2v_j$\n-   $(Lv)_j = -v_{j-1}$\n-   $(Uv)_j = -v_{j+1}$\n\n误差传播算子是 $T = -(D+L)^{-1}U$。我们想找到它在傅里叶模 $v_j(\\theta) = \\exp(ij\\theta)$ 上的放大因子 $g(\\theta)$。如果 $w = Tv(\\theta)$，那么 $g(\\theta)$ 满足 $w_j = g(\\theta) v_j(\\theta)$。\n\n$w = Tv(\\theta)$ 的定义等价于 $(D+L)w = -Uv(\\theta)$。我们按分量写出此方程：\n$$\n(Dw)_j + (Lw)_j = -(Uv(\\theta))_j\n$$\n代入算子的定义：\n$$\n2w_j - w_{j-1} = -(-v_{j+1}(\\theta)) = v_{j+1}(\\theta)\n$$\n现在，代入 $w_j = g(\\theta)\\exp(ij\\theta)$ 和 $v_j(\\theta) = \\exp(ij\\theta)$：\n$$\n2g(\\theta)\\exp(ij\\theta) - g(\\theta)\\exp(i(j-1)\\theta) = \\exp(i(j+1)\\theta)\n$$\n除以非零项 $\\exp(ij\\theta)$：\n$$\n2g(\\theta) - g(\\theta)\\exp(-i\\theta) = \\exp(i\\theta)\n$$\n\n### 步骤2：推导放大因子 $g(\\theta)$\n从上式中解出 $g(\\theta)$：\n$$\ng(\\theta)(2 - \\exp(-i\\theta)) = \\exp(i\\theta)\n$$\n$$\ng(\\theta) = \\frac{\\exp(i\\theta)}{2 - \\exp(-i\\theta)}\n$$\n\n### 步骤3：计算放大因子的模 $|g(\\theta)|$\n为了计算平滑因子，我们需要放大因子的模。我们计算其模的平方：\n$$\n|g(\\theta)|^2 = g(\\theta) \\overline{g(\\theta)} = \\left(\\frac{\\exp(i\\theta)}{2 - \\exp(-i\\theta)}\\right) \\left(\\frac{\\overline{\\exp(i\\theta)}}{\\overline{2 - \\exp(-i\\theta)}}\\right) = \\frac{\\exp(i\\theta)\\exp(-i\\theta)}{(2 - \\exp(-i\\theta))(2 - \\exp(i\\theta))}\n$$\n$$\n|g(\\theta)|^2 = \\frac{1}{4 - 2\\exp(i\\theta) - 2\\exp(-i\\theta) + \\exp(-i\\theta)\\exp(i\\theta)} = \\frac{1}{5 - 2(\\exp(i\\theta) + \\exp(-i\\theta))}\n$$\n使用欧拉公式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos\\theta$：\n$$\n|g(\\theta)|^2 = \\frac{1}{5 - 4\\cos\\theta}\n$$\n因此，放大因子的模为：\n$$\n|g(\\theta)| = \\frac{1}{\\sqrt{5 - 4\\cos\\theta}}\n$$\n\n### 步骤4：计算平滑因子 $\\mu_s$\n平滑因子定义为放大因子在高频集 $\\Theta_H = [\\pi/2, \\pi]$ 上的上确界（最大值）：\n$$\n\\mu_s = \\sup_{\\theta \\in [\\pi/2, \\pi]} |g(\\theta)| = \\sup_{\\theta \\in [\\pi/2, \\pi]} \\frac{1}{\\sqrt{5 - 4\\cos\\theta}}\n$$\n为了最大化这个表达式，我们需要最小化其分母 $\\sqrt{5 - 4\\cos\\theta}$，这等价于最小化函数 $f(\\theta) = 5 - 4\\cos\\theta$。这又等价于最大化函数 $\\cos\\theta$。\n\n在区间 $\\theta \\in [\\pi/2, \\pi]$ 上，$\\cos\\theta$ 是一个单调递减的函数。它的最大值出现在区间的左端点，即 $\\theta = \\pi/2$。\n在该点，$\\cos(\\pi/2) = 0$。\n\n因此，平滑因子为：\n$$\n\\mu_s = |g(\\pi/2)| = \\frac{1}{\\sqrt{5 - 4\\cos(\\pi/2)}} = \\frac{1}{\\sqrt{5 - 4(0)}} = \\frac{1}{\\sqrt{5}} = \\frac{\\sqrt{5}}{5}\n$$\n\n### 论证及与多重网格法的联系\n\n**高频误差衰减：** 平滑因子 $\\mu_s$ 量化了迭代方法（“平滑器”）在衰减误差的高频分量方面的最差情况下的效率。在多重网格法的背景下，误差分量根据其在网格层次结构中的表现分为高频和低频。高频误差是指那些无法在下一个更粗的网格上被准确表示的误差分量。对于标准的粗化比为2的情况，这些高频模态对应于傅里叶频率 $\\theta \\in \\Theta_H = [\\pi/2, \\pi]$。\n一个有效的平滑器（如高斯-赛德尔法）的主要目的不是完全求解线性系统，而是快速减小这些高频误差分量的幅度。$\\mu_s = \\sup_{\\theta \\in \\Theta_H} |g(\\theta)|$ 是所有高频模态中的最大放大因子。一个小于1的 $\\mu_s$ 值确保所有高频误差都会被衰减；$\\mu_s$ 的值越小，平滑器就越有效。\n\n**与多重网格效率的联系：** 多重网格方法通过在“平滑”和“粗网格校正”之间交替来高效求解。\n1.  **平滑：** 应用几次平滑器（如GS）的迭代。这一步能有效衰减高频误差，但对低频误差的衰减非常缓慢。平滑之后，剩余的误差主要由低频分量主导，即误差变得“光滑”。\n2.  **粗网格校正：** 光滑的误差可以在更粗的网格上被准确近似。因此，残差方程被转移（限制）到粗网格上求解，然后粗网格校正被插值回细网格以更新解。这个过程能有效消除低频误差。\n\n多重网格方法的整体效率依赖于这两个过程的协同作用。平滑器必须有效地处理粗网格校正无法处理的误差分量（即高频分量）。平滑因子 $\\mu_s$ 是预测多重网格方法收敛速度的关键参数。一个小的 $\\mu_s$（如我们计算出的 $\\sqrt{5}/5 \\approx 0.447$）意味着高频误差在几次迭代内就被显著衰减，使得算法可以高效地进行到粗网格校正步骤，从而实现与网格大小无关的快速收敛。",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{5}}{5}}\n$$"
        },
        {
            "introduction": "我们将前面的理论概念置于一个实际的计算情境中。在真实的模拟中，我们常常在每个时间步都非精确地求解线性系统（例如，使用带容差的迭代求解器）。本练习结合了理论推导与编程实践，旨在确定如何明智地设置此求解容差，以确保线性求解器引入的代数误差不会掩盖时间离散格式的固有误差。 ",
            "id": "3458596",
            "problem": "考虑定义域 $[0,1]$ 上的一维扩散方程，其具有齐次狄利克雷边界条件和归一化单位，使得扩散系数等于1。该偏微分方程为 $u_t = u_{xx}$，其中 $u(0,t) = 0$，$u(1,t) = 0$，且对于 $x \\in [0,1]$ 有 $u(x,0) = \\sin(\\pi x)$。使用 $N$ 个内部点对空间进行离散化，得到均匀的网格间距 $h = \\frac{1}{N+1}$，并使用标准的二阶中心有限差分近似拉普拉斯算子。使用时间步长 $\\Delta t$ 和最终时间 $T$，采用后向欧拉法（全隐式）对时间进行离散化。在每个时间步长上得到的线性系统为 $A u^{n+1} = u^{n}$，其中 $A = I - \\Delta t L_h$，$L_h$ 是带有狄利克雷边界条件的离散拉普拉斯算子，其产生如下三对角表示\n$$\nA = \\begin{bmatrix}\n1 + \\frac{2\\Delta t}{h^2}   -\\frac{\\Delta t}{h^2}   \\\\\n-\\frac{\\Delta t}{h^2}   1 + \\frac{2\\Delta t}{h^2}  -\\frac{\\Delta t}{h^2}  \\\\\n  \\ddots   \\ddots  \\ddots \\\\\n    -\\frac{\\Delta t}{h^2}  1 + \\frac{2\\Delta t}{h^2}\n\\end{bmatrix},\n$$\n其维度为 $N \\times N$，零狄利克雷边界已通过内部未知数并入方程。由于 $A$ 是对称正定矩阵，任何线性求解都可以通过 Thomas 算法（在机器精度内精确）或迭代法（如共轭梯度法 (CG) 或截断的并行循环约化法 (PCR)）来执行，这些迭代法可以根据相对残差容差 $\\varepsilon$ 提前终止。\n\n你的任务是检验在每个时间步使用非精确三对角求解器如何影响最终时间 $T$ 的全局时间误差，并建立一个容差选择准则，以确保累积的代数误差保持在时间离散化误差之下。请使用以下基本原理。\n- 后向欧拉法在时间上具有一阶精度，因此对于足够光滑的解，其全局时间离san化误差的表现为 $\\mathcal{O}(\\Delta t)$。\n- 对于线性求解 $A x = b$，若其非精确解 $\\tilde{x}$ 的残差为 $r = b - A \\tilde{x}$，则代数解误差在任何从属范数下满足 $\\|x - \\tilde{x}\\| \\le \\|A^{-1}\\| \\, \\|r\\|$。\n- 对于应用于半离散扩散算子的后向欧拉法，矩阵 $A$ 的特征值为 $\\lambda_k(A) = 1 - \\Delta t \\lambda_k(L_h)$，其中 $\\lambda_k(L_h) = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)$，对于 $k = 1,\\dots,N$。\n\n基于这些原理，推导由非精确求解引起的每步代数误差的累积效应，并为每步的相对残差 $\\varepsilon$ 推导出一个容差选择准则，以使在时间 $T$ 的总代数误差不超过时间离散化误差。\n\n你的程序必须：\n1. 对半离散系统实现后向欧拉时间步进，使用 Thomas 算法进行精确三对角求解，以生成在时间 $T$ 的参考解。\n2. 在每个时间步实现一个非精确求解，该求解使用迭代法，并在相对残差低于预设容差 $\\varepsilon$ 时终止。你可以使用共轭梯度法作为截断的并行循环约化法 (PCR) 的实用替代方法，通过提前停止来实现可控的非精确性。\n3. 通过计算使用步长 $\\Delta t$ 的精确求解后向欧拉解与使用步长 $\\Delta t/2$ 的精确求解后向欧拉解之间的差值，来估计在时间 $T$ 的时间离散化误差 $E_{\\text{time}}$。两种解都从相同的初始条件和使用相同的空间网格开始。使用 $\\mathbb{R}^N$ 中的欧几里得范数进行误差测量。\n4. 通过计算使用步长 $\\Delta t$ 的精确求解后向欧拉解与使用步长 $\\Delta t$ 和选定容差 $\\varepsilon$ 的非精确求解后向欧拉解之间的差值，来估计在时间 $T$ 的代数误差 $E_{\\text{alg}}$。\n5. 根据你的推导，实现容差选择准则 $\\varepsilon = \\theta \\Delta t^2$，其中 $\\theta$ 是使用半离散模型中的可用量来选择的，以确保 $E_{\\text{alg}} \\le E_{\\text{time}}$；$\\theta$ 的具体公式必须在你的解决方案中得到证明，并在代码中实现。\n\n使用以下参数值的测试套件，并报告该准则是否实现了 $E_{\\text{alg}} \\le E_{\\text{time}}$。\n- 测试用例1：$N=64$，$T=0.1$，$\\Delta t = 10^{-3}$，容差由准则设定。\n- 测试用例2：$N=64$，$T=0.1$，$\\Delta t = 2 \\times 10^{-3}$，容差由准则设定。\n- 测试用例3：$N=64$，$T=0.1$，$\\Delta t = 5 \\times 10^{-4}$，容差由准则设定。\n- 测试用例4（用于测试违反准则时失败情况的边界用例）：$N=64$，$T=0.1$，$\\Delta t = 10^{-3}$，容差被设置为一个与 $\\Delta t$ 成正比的较大值，以致累积代数误差预计将超过时间误差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3,result_4]$）。每个 $result_i$ 必须是一个布尔值，指示相应测试用例是否满足 $E_{\\text{alg}} \\le E_{\\text{time}}$。由于全程使用归一化单位，输出中无需物理单位。",
            "solution": "### 容差选择准则的推导\n\n目标是为每步的相对残差容差 $\\varepsilon$ 推导出一个形如 $\\varepsilon = \\theta \\Delta t^2$ 的准则，以使在最终时间 $T$ 的总累积代数误差 $E_{alg}$ 与全局时间离散化误差 $E_{time}$ 处于同一量级或更小。\n\n令 $u^n$ 为在时间 $t_n = n \\Delta t$ 时的数值精确解向量，通过精确求解后向欧拉系统 $A u^{n+1} = u^n$ 得到。令 $\\tilde{u}^n$ 为线性系统被非精确求解时得到的解向量。我们从相同的初始条件开始，因此 $\\tilde{u}^0 = u^0$。\n\n**1. 累积代数误差 ($E_{alg}$) 的界定**\n\n在每个时间步 $n+1$，我们从系统 $A x = \\tilde{u}^n$ 求解 $\\tilde{u}^{n+1}$。非精确求解器产生一个解 $\\tilde{u}^{n+1}$，使得其残差 $r^{n+1} = \\tilde{u}^n - A \\tilde{u}^{n+1}$ 满足相对容差条件 $\\|r^{n+1}\\| / \\|\\tilde{u}^n\\| \\le \\varepsilon$。所有范数均为欧几里得 $L_2$-范数。这意味着 $\\|r^{n+1}\\| \\le \\varepsilon \\|\\tilde{u}^n\\|$。\n\n在此步引入的局部代数误差 $\\delta^{n+1}$ 是该系统精确解与非精确解之间的差：$\\delta^{n+1} = A^{-1}\\tilde{u}^n - \\tilde{u}^{n+1}$。使用问题陈述中提供的误差界，我们有：\n$$\n\\|\\delta^{n+1}\\| \\le \\|A^{-1}\\| \\|r^{n+1}\\| \\le \\|A^{-1}\\| \\varepsilon \\|\\tilde{u}^n\\|\n$$\n对于扩散方程的后向欧拉离散化，矩阵 $A = I - \\Delta t L_h$ 是对称正定的，且其所有特征值都大于或等于1。因此，其逆矩阵 $A^{-1}$ 也是对称正定的，且特征值小于或等于1，这意味着 $\\|A^{-1}\\| \\le 1$。此外，扩散过程是耗散的，意味着解的范数不会随时间增长：$\\|\\tilde{u}^n\\| \\le \\|\\tilde{u}^{n-1}\\| \\le \\dots \\le \\|\\tilde{u}^0\\| = \\|u^0\\|$。\n这简化了局部代数误差的界：\n$$\n\\|\\delta^{n+1}\\| \\le \\varepsilon \\|u^0\\|\n$$\n在第 $n+1$ 步的全局代数误差 $e_{alg}^{n+1} = u^{n+1} - \\tilde{u}^{n+1}$，是从上一步的全局误差和新的局部误差累积而来的：\n$$\ne_{alg}^{n+1} = (A^{-1} u^n) - (A^{-1}\\tilde{u}^n - \\delta^{n+1}) = A^{-1}(u^n - \\tilde{u}^n) + \\delta^{n+1} = A^{-1}e_{alg}^n + \\delta^{n+1}\n$$\n取范数并使用 $\\|A^{-1}\\| \\le 1$：$\\|e_{alg}^{n+1}\\| \\le \\|e_{alg}^n\\| + \\|\\delta^{n+1}\\|$。从 $e_{alg}^0 = 0$ 开始进行归纳，最终时间 $T = N_T \\Delta t$ 的总代数误差受局部误差大小之和的限制：\n$$\nE_{alg} = \\|e_{alg}^{N_T}\\| \\le \\sum_{n=1}^{N_T} \\|\\delta^n\\| \\le \\sum_{n=1}^{N_T} \\varepsilon \\|u^0\\| = N_T \\varepsilon \\|u^0\\| = \\frac{T}{\\Delta t} \\varepsilon \\|u^0\\|\n$$\n因此，累积代数误差的尺度关系为 $E_{alg} \\propto \\varepsilon / \\Delta t$。\n\n**2. 时间离散化误差 ($E_{time}$) 的界定**\n\n后向欧拉法在时间上是一阶精确的。对于半离散系统 $du/dt = L_h u$，在第 $n+1$ 步的局部截断误差 (LTE) 由下式给出：\n$$\n\\tau^{n+1} \\approx \\frac{\\Delta t^2}{2} u_{tt}(t_{n+1})\n$$\n其中 $u_{tt} = \\frac{d^2u}{dt^2}$。由于 $u_t = L_h u$，我们有 $u_{tt} = L_h u_t = L_h(L_h u) = L_h^2 u$。因此，LTE 为：\n$$\n\\|\\tau^{n+1}\\| \\approx \\frac{\\Delta t^2}{2} \\|L_h^2 u(t_{n+1})\\|\n$$\n全局时间离散化误差 $E_{time}$ 在主导阶上是这些局部误差的累积。一个启发式的论证表明，全局误差受步数乘以最大LTE的限制：\n$$\nE_{time} \\approx N_T \\times \\max_n \\|\\tau^n\\| = \\frac{T}{\\Delta t} \\left( \\frac{\\Delta t^2}{2} \\max_n \\|L_h^2 u(t_n)\\| \\right) = \\frac{T \\Delta t}{2} \\max_n \\|L_h^2 u(t_n)\\|\n$$\n因此，全局时间误差的尺度为 $E_{time} \\propto \\Delta t$。\n\n**3. 平衡误差并推导准则**\n\n为确保代数误差不污染时间精度，我们要求 $E_{alg} \\lesssim E_{time}$：\n$$\n\\frac{T}{\\Delta t} \\varepsilon \\|u^0\\| \\lesssim \\frac{T \\Delta t}{2} \\max_n \\|L_h^2 u(t_n)\\|\n$$\n求解 $\\varepsilon$：\n$$\n\\varepsilon \\lesssim \\frac{\\Delta t^2}{2} \\frac{\\max_n \\|L_h^2 u(t_n)\\|}{\\|u^0\\|}\n$$\n问题指定了初始条件 $u(x,0) = \\sin(\\pi x)$。这是连续算子 $-\\partial^2/\\partial x^2$ 的第一个特征函数，其特征值为 $\\pi^2$。离散初始条件是离散拉普拉斯算子 $-L_h$ 的第一个特征向量的紧密近似，其对应的特征值为 $\\lambda_1(-L_h) = - \\lambda_1(L_h) = \\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) \\approx \\pi^2$。\n半离散系统的解为 $u(t) \\approx e^{\\lambda_1(L_h)t} u^0$。因此，$L_h^2 u(t) \\approx (\\lambda_1(L_h))^2 u(t)$。由于解是指数衰减的，范数 $\\|L_h^2 u(t_n)\\|$ 将在 $t=0$ 时达到最大值。\n$$\n\\max_n \\|L_h^2 u(t_n)\\| \\approx \\|L_h^2 u(0)\\| \\approx \\|(\\lambda_1(L_h))^2 u^0\\| = (\\lambda_1(L_h))^2 \\|u^0\\|\n$$\n将此代入 $\\varepsilon$ 的不等式中：\n$$\n\\varepsilon \\lesssim \\frac{\\Delta t^2}{2} \\frac{(\\lambda_1(L_h))^2 \\|u^0\\|}{\\|u^0\\|} = \\frac{(\\lambda_1(L_h))^2}{2} \\Delta t^2\n$$\n这提供了所需的形式 $\\varepsilon = \\theta \\Delta t^2$。我们选择 $\\theta = \\frac{(\\lambda_1(L_h))^2}{2}$，这是一个可以直接从空间离散化计算出的参数。\n$L_h$ 的最小（绝对值）特征值的具体公式为 $\\lambda_1(L_h) = -\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(N+1)}\\right)$，其中 $k=1$。我们将在实现中使用这个公式来设置容差。\n$$\n\\theta = \\frac{1}{2} \\left[ -\\frac{4}{h^2}\\sin^2\\left(\\frac{\\pi}{2(N+1)}\\right) \\right]^2 = \\frac{8}{h^4} \\sin^4\\left(\\frac{\\pi}{2(N+1)}\\right)\n$$\n\n### 实现策略\n\n程序将按以下结构组织：\n1.  `thomas_algorithm`：用于“精确”求解的标准 Thomas 算法实现。\n2.  `conjugate_gradient`：用于“非精确”求解的共轭梯度算法实现，当相对残差低于容差 $\\varepsilon$ 时终止。\n3.  `solve_diffusion`：一个主驱动函数，使用 Thomas 或 CG 求解器执行时间步进。\n4.  `solve`：协调四个测试用例的主函数。对于每个用例：\n    a. 计算基于准则的系数 $\\theta$。\n    b. 计算参考解 $u_{\\Delta t}$（精确求解器）。\n    c. 计算更精确的参考解 $u_{\\Delta t/2}$ 以估计时间误差。\n    d. 估计时间误差 $E_{time} = \\|u_{\\Delta t} - u_{\\Delta t/2}\\|$。\n    e. 根据推导的准则（或在用例4中使用错误的准则）设置容差 $\\varepsilon$。\n    f. 计算非精确解 $\\tilde{u}_{\\Delta t}$。\n    g. 计算代数误差 $E_{alg} = \\|u_{\\Delta t} - \\tilde{u}_{\\Delta t}\\|$。\n    h. 记录是否满足 $E_{alg} \\le E_{time}$。\n最终输出将是这些布尔结果的列表。",
            "answer": "```python\nimport numpy as np\n\ndef thomas_algorithm(l, m, u, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    l: lower diagonal (length n-1)\n    m: main diagonal (length n)\n    u: upper diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    m_copy = np.copy(m)\n    d_copy = np.copy(d)\n    \n    # Forward elimination\n    for i in range(1, n):\n        factor = l[i-1] / m_copy[i-1]\n        m_copy[i] = m_copy[i] - factor * u[i-1]\n        d_copy[i] = d_copy[i] - factor * d_copy[i-1]\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_copy[n-1] / m_copy[n-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = (d_copy[i] - u[i] * x[i+1]) / m_copy[i]\n        \n    return x\n\ndef conjugate_gradient(A, b, tolerance, initial_guess):\n    \"\"\"\n    Solves Ax=b for SPD matrix A using the Conjugate Gradient method.\n    Termination is based on relative residual norm.\n    \"\"\"\n    x = initial_guess\n    r = b - A @ x\n    p = r.copy()\n    rs_old = np.dot(r, r)\n    norm_b = np.linalg.norm(b)\n\n    if norm_b == 0:\n        return np.zeros_like(b)\n\n    max_iter = len(b) * 2\n    for _ in range(max_iter):\n        Ap = A @ p\n        alpha = rs_old / np.dot(p, Ap)\n        x = x + alpha * p\n        r = r - alpha * Ap\n        rs_new = np.dot(r, r)\n        \n        current_rel_residual = np.sqrt(rs_new) / norm_b\n        if current_rel_residual = tolerance:\n            break\n            \n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return x\n\ndef solve_diffusion(N, T, dt, solver_type, tolerance=None):\n    \"\"\"\n    Solves the 1D diffusion equation using backward Euler.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x_grid = np.linspace(h, 1.0 - h, N)\n    u = np.sin(np.pi * x_grid)\n\n    diag_val = 1.0 + 2.0 * dt / h**2\n    offdiag_val = -dt / h**2\n    \n    main_diag = np.full(N, diag_val)\n    off_diag = np.full(N - 1, offdiag_val)\n\n    num_steps = int(round(T / dt))\n\n    if solver_type == 'exact':\n        for _ in range(num_steps):\n            u = thomas_algorithm(off_diag, main_diag, off_diag, u)\n    elif solver_type == 'inexact':\n        # Build dense matrix for CG\n        A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        for _ in range(num_steps):\n            # Use previous solution as a warm start for the CG solver\n            u = conjugate_gradient(A, u, tolerance, initial_guess=u.copy())\n            \n    return u\n\ndef solve():\n    test_cases = [\n        # N, T, dt, is_edge_case\n        (64, 0.1, 1e-3, False),\n        (64, 0.1, 2e-3, False),\n        (64, 0.1, 5e-4, False),\n        (64, 0.1, 1e-3, True),\n    ]\n\n    results = []\n    \n    for N, T, dt, is_edge_case in test_cases:\n        h = 1.0 / (N + 1)\n        lambda_1_Lh = -4.0 / h**2 * np.sin(np.pi / (2.0 * (N + 1)))**2\n        theta = (lambda_1_Lh**2) / 2.0\n        \n        u_ref_dt = solve_diffusion(N, T, dt, 'exact')\n        \n        u_ref_dt_half = solve_diffusion(N, T, dt / 2.0, 'exact')\n        \n        # Richardson extrapolation gives a better error estimate, but difference is sufficient here.\n        E_time = np.linalg.norm(u_ref_dt - u_ref_dt_half)\n        \n        if is_edge_case:\n            # Violate the rule: set tolerance proportional to dt, which is too loose.\n            tolerance = 0.1 * dt\n        else:\n            # Use the derived rule\n            tolerance = theta * dt**2\n            \n        u_inexact = solve_diffusion(N, T, dt, 'inexact', tolerance=tolerance)\n        \n        E_alg = np.linalg.norm(u_ref_dt - u_inexact)\n        \n        results.append(E_alg = E_time)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\")\n\nsolve()\n```"
        }
    ]
}