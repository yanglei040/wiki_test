{
    "hands_on_practices": [
        {
            "introduction": "对于方程组，迎风格式的核心思想是根据信息传播方向，对每个特征场独立处理。本练习将引导你完成这一基本过程。通过对一个简单线性系统的通量雅可bi矩阵进行特征分解，你将学会如何识别特征场、确定其传播速度，并据此为每个分量选择正确的迎风方向。",
            "id": "3459961",
            "problem": "考虑常系数线性双曲偏微分方程（PDE）组\n$$\nU_{t} + A\\,U_{x} = 0,\\qquad U(x,t)\\in\\mathbb{R}^{2},\\qquad\nA=\\begin{pmatrix}2  1\\\\ 0  1\\end{pmatrix}.\n$$\n从线性双曲系统的基本特征出发，即通过沿特征方向的对角化来描述：如果通量雅可比矩阵具有实的、不等的特征值，并且特征变量以等于这些特征值的速度传播，则该系统是严格双曲的。使用此特征按以下步骤进行，不调用任何现成的通量公式：\n\n1) 计算矩阵 $A$ 的完全特征分解，即确定特征值、相应的右特征向量基，并组装特征向量矩阵 $R$ 及其逆矩阵 $R^{-1}$，使得 $A=R\\Lambda R^{-1}$，其中 $\\Lambda$ 是对角矩阵。\n\n2) 使用特征速度（$\\Lambda$ 的对角元）的符号，确定在 $U_{t}+A\\,U_{x}=0$ 的一阶迎风离散化中，每个特征分量必须从哪个空间侧（左侧或右侧）进行迎风处理。\n\n3) 基于对角化所蕴含的特征分裂，通过以下方式定义通量雅可比矩阵的正部和负部\n$$\n\\Lambda^{+}=\\operatorname{diag}\\big(\\max(\\lambda_{1},0),\\max(\\lambda_{2},0)\\big),\\qquad\n\\Lambda^{-}=\\operatorname{diag}\\big(\\min(\\lambda_{1},0),\\min(\\lambda_{2},0)\\big),\n$$\n和\n$$\nA^{+}=R\\,\\Lambda^{+}\\,R^{-1},\\qquad A^{-}=R\\,\\Lambda^{-}\\,R^{-1}.\n$$\n然后构造矩阵绝对值\n$$\n|A| \\equiv A^{+}-A^{-} = R\\,|\\Lambda|\\,R^{-1},\\qquad |\\Lambda|=\\operatorname{diag}\\big(|\\lambda_{1}|,|\\lambda_{2}|\\big).\n$$\n\n以精确的 $2\\times 2$ 矩阵 $|A|$ 的形式提供您的最终答案，无任何近似。不包含单位。无需四舍五入。",
            "solution": "在尝试任何解答之前，对问题陈述进行严格验证。\n\n### 步骤1：提取已知条件\n给定的信息是：\n- 常系数线性双曲偏微分方程组：$U_{t} + A\\,U_{x} = 0$，其中 $U(x,t)\\in\\mathbb{R}^{2}$。\n- 系数矩阵：$A=\\begin{pmatrix}2  1\\\\ 0  1\\end{pmatrix}$。\n- 求解过程分为三个部分：\n    1.  计算 $A$ 的完全特征分解：特征值、右特征向量、特征向量矩阵 $R$ 及其逆矩阵 $R^{-1}$。\n    2.  根据特征值的符号确定每个特征分量的迎风方向。\n    3.  使用定义 $\\Lambda^{+}=\\operatorname{diag}\\big(\\max(\\lambda_{i},0)\\big)$, $\\Lambda^{-}=\\operatorname{diag}\\big(\\min(\\lambda_{i},0)\\big)$, $A^{+}=R\\,\\Lambda^{+}\\,R^{-1}$, $A^{-}=R\\,\\Lambda^{-}\\,R^{-1}$ 和 $|A| \\equiv A^{+} - A^{-} = R\\,|\\Lambda|\\,R^{-1}$ 构造矩阵绝对值 $|A|$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学性**：该问题是偏微分方程数值方法领域的标准练习，具体涉及双曲系统的分析和迎风格式的开发。特征分解、特征变量和通量矢量分裂（如此处隐式定义的Steger-Warming分裂）等概念都是基础且成熟的。\n- **适定性**：该问题是适定的。矩阵 $A$ 已给定，计算顺序也已明确定义。这种结构确保了矩阵 $|A|$ 存在唯一且有意义的解。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有歧义或主观论断。\n- **完整性和一致性**：提供了所有必要信息（矩阵 $A$）。步骤逻辑清晰且自洽。引言部分正确地描述了线性双曲系统的特征，各项任务也直接由此特征导出。\n\n### 步骤3：结论与行动\n该问题是 **有效的**。这是一个清晰、独立且在应用数学中科学合理的问题。可以开始求解过程。\n\n### 解答\n按照问题陈述中概述的三个步骤构建解答。\n\n**1) 矩阵 $A$ 的特征分解**\n\n给定矩阵为 $A = \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix}$。\n首先，我们通过求解特征方程 $\\det(A - \\lambda I) = 0$ 来求特征值 $\\lambda$，其中 $I$ 是 $2 \\times 2$ 单位矩阵。\n$$\n\\det\\left(\\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix} - \\lambda\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\\right) = \\det\\begin{pmatrix} 2 - \\lambda  1 \\\\ 0  1 - \\lambda \\end{pmatrix} = 0\n$$\n行列式为 $(2 - \\lambda)(1 - \\lambda) - (1)(0) = (2 - \\lambda)(1 - \\lambda)$。\n将特征多项式置为零，得到特征值：$\\lambda_1 = 2$ 和 $\\lambda_2 = 1$。由于特征值是实数且不相等，系统 $U_t + A\\,U_x = 0$ 是严格双曲的。\n\n接下来，我们通过求解 $(A - \\lambda_i I)r_i = 0$ 来求对应的右特征向量 $r_i$。\n\n对于 $\\lambda_1 = 2$：\n$$\n(A - 2I)r_1 = \\begin{pmatrix} 2-2  1 \\\\ 0  1-2 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 0  -1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到方程 $y = 0$。我们可以选择 $x=1$。因此，$\\lambda_1=2$ 的一个右特征向量是 $r_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n对于 $\\lambda_2 = 1$：\n$$\n(A - 1I)r_2 = \\begin{pmatrix} 2-1  1 \\\\ 0  1-1 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到方程 $x + y = 0$。我们可以选择 $y=1$，这意味着 $x=-1$。因此，$\\lambda_2=1$ 的一个右特征向量是 $r_2 = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$。\n\n右特征向量矩阵 $R$ 由特征向量作为列构成：\n$$\nR = [r_1, r_2] = \\begin{pmatrix} 1  -1 \\\\ 0  1 \\end{pmatrix}\n$$\n特征值对角矩阵 $\\Lambda$ 是：\n$$\n\\Lambda = \\begin{pmatrix} \\lambda_1  0 \\\\ 0  \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}\n$$\n为了完成分解 $A = R\\Lambda R^{-1}$，我们计算 $R$ 的逆矩阵。对于一个一般的 $2\\times 2$ 矩阵 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$，其逆矩阵为 $\\frac{1}{ad-bc}\\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$。\n$R$ 的行列式是 $\\det(R) = (1)(1) - (-1)(0) = 1$。\n因此，逆矩阵是：\n$$\nR^{-1} = \\frac{1}{1}\\begin{pmatrix} 1  -(-1) \\\\ -0  1 \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix}\n$$\n因此，完整的特征分解由 $R = \\begin{pmatrix} 1  -1 \\\\ 0  1 \\end{pmatrix}$，$\\Lambda = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}$ 和 $R^{-1} = \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix}$ 指定。\n\n**2) 迎风方向**\n\n特征值 $\\lambda_1=2$ 和 $\\lambda_2=1$ 代表特征变量的传播速度。通过使用 $W=R^{-1}U$ 对系统进行变换，我们得到解耦的系统 $W_t + \\Lambda W_x = 0$，或者按分量写为 $(\\partial_t + \\lambda_i \\partial_x)w_i = 0$。\n特征值的符号决定了信息传播的方向。\n- 对于第一个特征场，速度为 $\\lambda_1 = 2 > 0$。信息沿 $x$ 轴正方向传播（从左到右）。因此，该分量的一阶迎风离散化必须使用来自左侧空间位置（例如，网格单元索引 $j-1$）的信息。\n- 对于第二个特征场，速度为 $\\lambda_2 = 1 > 0$。信息也沿 $x$ 轴正方向传播。同样，其迎风离散化必须使用来自左侧的信息。\n\n总之，由于两个特征速度均为正，两个特征分量都必须从左侧进行迎风处理。\n\n**3) 构造矩阵绝对值 $|A|$**\n\n问题将矩阵绝对值定义为 $|A| = R\\,|\\Lambda|\\,R^{-1}$，其中 $|\\Lambda| = \\operatorname{diag}(|\\lambda_1|, |\\lambda_2|)$。\n使用计算出的特征值 $\\lambda_1 = 2$ 和 $\\lambda_2 = 1$：\n$$\n|\\lambda_1| = |2| = 2\n$$\n$$\n|\\lambda_2| = |1| = 1\n$$\n所以矩阵 $|\\Lambda|$ 是：\n$$\n|\\Lambda| = \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix}\n$$\n我们观察到，由于两个特征值都是正的，所以 $|\\Lambda| = \\Lambda$。\n现在我们通过矩阵乘法构造 $|A|$：\n$$\n|A| = R\\,|\\Lambda|\\,R^{-1} = \\begin{pmatrix} 1  -1 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix}\n$$\n首先，我们将前两个矩阵相乘：\n$$\nR\\,|\\Lambda| = \\begin{pmatrix} 1  -1 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 2  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} (1)(2)+(-1)(0)  (1)(0)+(-1)(1) \\\\ (0)(2)+(1)(0)  (0)(0)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 2  -1 \\\\ 0  1 \\end{pmatrix}\n$$\n接下来，我们将此结果乘以 $R^{-1}$：\n$$\n|A| = (R\\,|\\Lambda|)R^{-1} = \\begin{pmatrix} 2  -1 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  1 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} (2)(1)+(-1)(0)  (2)(1)+(-1)(1) \\\\ (0)(1)+(1)(0)  (0)(1)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix}\n$$\n因此，矩阵绝对值为 $|A| = \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix}$。\n\n这个结果与提供的另一种定义是一致的。由于 $\\lambda_1 > 0$ 且 $\\lambda_2 > 0$：\n$\\Lambda^{+} = \\operatorname{diag}(\\max(2,0), \\max(1,0)) = \\operatorname{diag}(2,1) = \\Lambda$。\n$\\Lambda^{-} = \\operatorname{diag}(\\min(2,0), \\min(1,0)) = \\operatorname{diag}(0,0)$，即零矩阵。\n那么 $A^{+} = R\\Lambda^{+}R^{-1} = R\\Lambda R^{-1} = A$。\n并且 $A^{-} = R\\Lambda^{-}R^{-1} = R\\,0\\,R^{-1} = 0$。\n因此， $|A| \\equiv A^{+} - A^{-} = A - 0 = A$。结果与原始矩阵 $A$ 相同。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "特征速度（即雅可bi矩阵的特征值）不仅是理论概念，它直接决定了数值方法的稳定性和精度。本练习将理论与实践相结合，要求你根据给定的流场参数范围，确定求解欧拉方程时所需的最大波速。这个值对于设定局部 Lax-Friedrichs 型通量中的耗散系数，以及通过 Courant–Friedrichs–Lewy (CFL) 条件计算最大允许时间步长至关重要。",
            "id": "3459987",
            "problem": "考虑在间距为 $\\Delta x$ 的均匀网格上，质量、动量和能量守恒形式的一维可压缩欧拉方程。在每个界面上，使用 Lax–Friedrichs 类型的局部通量分裂的显式有限体积法进行更新。假设在某个特定界面上，通过对左右状态的材料速度 $u$ 和声速 $c$ 的界限，可以获得三个特征速度（通量雅可比矩阵的特征值）的严格先验界。具体而言，左侧状态满足 $|u_{\\mathrm{L}}| \\leq 180$ 且 $c_{\\mathrm{L}} \\in [320, 340]$，而右侧状态满足 $|u_{\\mathrm{R}}| \\leq 220$ 且 $c_{\\mathrm{R}} \\in [300, 360]$。假设这些界限已考虑了与该界面数据一致的所有可能的局部变化。\n\n定义界面耗散系数 $\\alpha$ 为一个标量，它是在允许的左右状态下，界面上所有特征速度大小的上界，并用于在显式更新中稳定分裂通量。对于 Courant–Friedrichs–Lewy (CFL) 条件，取 Courant 数 $\\nu = 0.7$，均匀网格间距 $\\Delta x = 5.0 \\times 10^{-3}$ 米，并假设该界面控制全局时间步长。仅使用上述界限和欧拉系统特征结构的基本性质，计算：\n- 最小允许耗散系数 $\\alpha$，以及\n- 在 CFL 条件下，显式格式对应的最大允许时间步长 $\\Delta t_{\\max}$。\n\n将 $\\alpha$ 和 $\\Delta t_{\\max}$ 都四舍五入至四位有效数字。以秒为单位表示 $\\Delta t_{\\max}$。",
            "solution": "用户希望我在验证一个偏微分方程数值方法问题后，对其进行求解。\n\n### 问题验证\n\n**第一步：提取已知信息**\n- 系统：守恒形式的一维可压缩欧拉方程。\n- 网格：均匀网格，间距为 `$\\Delta x$`。\n- 数值方法：Lax–Friedrichs 类型的局部通量分裂的显式有限体积法。\n- 左状态界限：`$|u_{\\mathrm{L}}| \\leq 180$` 且 `$c_{\\mathrm{L}} \\in [320, 340]$`。\n- 右状态界限：`$|u_{\\mathrm{R}}| \\leq 220$` 且 `$c_{\\mathrm{R}} \\in [300, 360]$`。\n- 耗散系数 `$\\alpha$`：一个标量，是界面上所有特征速度大小的最小允许上界值。\n- CFL 条件参数：Courant 数 `$\\nu = 0.7$`，网格间距 `$\\Delta x = 5.0 \\times 10^{-3}$` 米。\n- 时间步长约束：指定的界面控制全局时间步长。\n- 要求计算：最小的 `$\\alpha$` 和最大的 `$\\Delta t_{\\max}$`，均四舍五入至四位有效数字。`$\\Delta t_{\\max}$` 必须以秒为单位。\n\n**第二步：使用提取的已知信息进行验证**\n该问题具有科学依据，是适定的，并且是客观的。\n- **科学依据**：该问题基于计算流体动力学的基本原理，特别是欧拉方程的数值解。特征速度（通量雅可比矩阵的特征值）、Lax-Friedrichs 通量分裂以及 Courant–Friedrichs–Lewy (CFL) 稳定性条件等概念，在偏微分方程数值分析领域是标准且成熟的。\n- **适定性**：该问题定义清晰且自洽。它提供了计算所求量所需的所有数据（流动变量的界限、网格间距、Courant 数）。目标是在一个紧集上找到一个明确定义的函数（`$|u|+c$`）的上确界，这保证了唯一解的存在性。通过 CFL 条件，最大波速与时间步长之间的关系是直接且明确的。\n- **客观性**：语言精确且量化，没有任何主观或偏颇的陈述。给定的流体速度和声速值对于气体动力学问题是物理上合理的（例如，`$c \\approx 340$` 米/秒是标准条件下空气中的声速）。\n- **完整性与一致性**：问题没有矛盾之处。“这些界限已经考虑了所有可能的局部变化”这一说明是一个关键的澄清，使得问题仅凭所提供的信息即可解决，消除了关于如何处理界面性质的模糊性。\n\n**第三步：结论与行动**\n该问题有效。将构建一个完整的解法。\n\n### 解法\n\n该问题要求为一个求解一维欧拉方程的数值格式计算两个量：最小允许耗散系数 `$\\alpha$` 和相应的最大时间步长 `$\\Delta t_{\\max}$`。\n\n**第一部分：耗散系数 `$\\alpha$` 的计算**\n\n一维可压缩欧拉方程构成一个双曲守恒律系统。该系统的特征速度是通量雅可比矩阵 `$\\mathbf{A}(\\mathbf{U}) = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{U}}$` 的特征值，其中 `$\\mathbf{U}$` 是守恒变量向量，`$\\mathbf{F}$` 是通量向量。对于一维欧拉方程，特征值为：\n$$\n\\lambda_1 = u, \\quad \\lambda_2 = u + c, \\quad \\lambda_3 = u - c\n$$\n其中 `$u$` 是局部流体速度，`$c$` 是局部声速。\n\n问题指定了一种局部 Lax-Friedrichs 型通量分裂（也称为 Rusanov 格式）。界面处的数值通量通过一个耗散项来稳定，该项与一个我们记为 `$\\alpha$` 的系数成正比，该系数必须是局部特征速度大小的一个上界。对于左状态 `$\\mathrm{L}$` 和右状态 `$\\mathrm{R}$` 之间的界面，耗散系数 `$\\alpha$` 必须满足：\n$$\n\\alpha \\geq \\max(|\\lambda_{\\mathrm{L}}|), \\quad \\alpha \\geq \\max(|\\lambda_{\\mathrm{R}}|)\n$$\n其中 `$|\\lambda_{\\mathrm{L}}|$` 和 `$|\\lambda_{\\mathrm{R}}|$` 分别表示左右状态下特征值的大小。对于给定的状态 `$(u, c)$`，特征值的最大幅值是通量雅可比矩阵的谱半径，即 `$\\rho(\\mathbf{A}) = \\max(|\\lambda_1|, |\\lambda_2|, |\\lambda_3|)$`。欧拉方程的一个标准结论是，该谱半径由下式给出：\n$$\n\\rho(\\mathbf{A}) = |u| + c\n$$\n问题将 `$\\alpha$` 定义为在界面上，跨越所有允许的左右状态时，所有特征速度大小的最小标量上界。因此，`$\\alpha$` 必须是在考虑左右两个状态中所有允许的 `$(u, c)` 对时，谱半径可能的最大值。\n$$\n\\alpha = \\max \\left( \\sup_{(u_{\\mathrm{L}}, c_{\\mathrm{L}})} (|u_{\\mathrm{L}}| + c_{\\mathrm{L}}), \\sup_{(u_{\\mathrm{R}}, c_{\\mathrm{R}})} (|u_{\\mathrm{R}}| + c_{\\mathrm{R}}) \\right)\n$$\n我们利用给定的界限分别计算左状态和右状态的上确界。\n\n对于左状态：\n`$|u_{\\mathrm{L}}| \\leq 180$` 且 `$c_{\\mathrm{L}} \\in [320, 340]$`。\n`$|u_{\\mathrm{L}}| + c_{\\mathrm{L}}$` 的最大值是通过取 `$|u_{\\mathrm{L}}|$` 和 `$c_{\\mathrm{L}}$` 各自的最大值得到的：\n$$\n\\sup(|u_{\\mathrm{L}}| + c_{\\mathrm{L}}) = \\sup(|u_{\\mathrm{L}}|) + \\sup(c_{\\mathrm{L}}) = 180 + 340 = 520\n$$\n\n对于右状态：\n`$|u_{\\mathrm{R}}| \\leq 220$` 且 `$c_{\\mathrm{R}} \\in [300, 360]$`。\n类似地，`$|u_{\\mathrm{R}}| + c_{\\mathrm{R}}$` 的最大值可以得到：\n$$\n\\sup(|u_{\\mathrm{R}}| + c_{\\mathrm{R}}) = \\sup(|u_{\\mathrm{R}}|) + \\sup(c_{\\mathrm{R}}) = 220 + 360 = 580\n$$\n\n最小的允许 `$\\alpha$` 必须是这两者的上界，所以我们取这两个值的最大值：\n$$\n\\alpha = \\max(520, 580) = 580\n$$\n`$\\alpha$` 的单位是米/秒 (m/s)。四舍五入到四位有效数字，我们得到 `$\\alpha = 580.0$`。\n\n**第二部分：最大时间步长 `$\\Delta t_{\\max}$` 的计算**\n\nCourant–Friedrichs–Lewy (CFL) 条件为显式时间步进格式提供了稳定性约束。对于均匀网格上的有限体积格式，该条件由下式给出：\n$$\n\\nu = \\frac{\\Delta t \\cdot S_{\\max}}{\\Delta x} \\leq \\nu_{\\text{stable}}\n$$\n其中 `$\\Delta t$` 是时间步长，`$\\Delta x$` 是网格间距，`$S_{\\max}$` 是整个计算域上的最大波速（特征值大小），`$\\nu$` 是 Courant 数。问题陈述给出 `$\\nu = 0.7$`，这意味着 `$\\nu_{\\text{stable}} \\geq 0.7$`。当等式成立时，可以找到最大允许时间步长 `$\\Delta t_{\\max}$`：\n$$\n\\Delta t_{\\max} = \\frac{\\nu \\cdot \\Delta x}{S_{\\max}}\n$$\n问题指出，所考虑的界面“控制全局时间步长”。这意味着整个区域的最大波速 `$S_{\\max}$` 出现在该界面处。从第一部分可知，该界面上可能的最大波速是我们为 `$\\alpha$` 计算出的值。因此，`$S_{\\max} = \\alpha = 580$` 米/秒。\n\n我们已知：\n- Courant 数，`$\\nu = 0.7$`\n- 网格间距，`$\\Delta x = 5.0 \\times 10^{-3}$` 米\n- 最大波速，`$S_{\\max} = \\alpha = 580$` 米/秒\n\n将这些值代入 `$\\Delta t_{\\max}$` 的方程中：\n$$\n\\Delta t_{\\max} = \\frac{0.7 \\cdot (5.0 \\times 10^{-3})}{580}\n$$\n$$\n\\Delta t_{\\max} = \\frac{3.5 \\times 10^{-3}}{580} \\approx 6.0344827... \\times 10^{-6} \\text{ s}\n$$\n问题要求将结果四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} \\approx 6.034 \\times 10^{-6} \\text{ s}\n$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n580.0  6.034 \\times 10^{-6}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "构建一个稳健的求解器不仅需要正确的代码实现，更需要对数值格式的内在属性和潜在缺陷有深刻的理解。本练习是一项综合性挑战，要求你从零开始实现完整的一阶 Roe 通量差分分裂格式。更重要的是，你将通过测试一个经典的 near-vacuum 黎曼问题，直面 Roe 格式在极端情况下丧失正定性的著名缺陷，并利用特征分解的知识，诊断出导致该问题的具体特征场。",
            "id": "3460005",
            "problem": "考虑一个绝热指数为 $\\gamma$ 的理想气体的一维可压缩欧拉方程，\n$$\n\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0,\n$$\n其中 $\\mathbf{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ E \\end{bmatrix}$ 是守恒变量的矢量，$\\rho$ 是质量密度，$u$ 是速度，$E$ 是单位体积的总能量。无粘通量为\n$$\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u (E + p) \\end{bmatrix},\n$$\n热力学封闭关系由理想气体定律给出\n$$\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right).\n$$\n计算域为区间 $[-1,1]$，被划分为 $N$ 个等大的有限体积单元。设 $N = 200$，使用透射边界条件，并考虑 Courant-Friedrichs-Lewy (CFL) 数 $\\text{CFL} = 0.9$。初始条件为在 $x=0$ 处存在间断的黎曼问题：\n$$\n\\mathbf{U}(x,0) = \n\\begin{cases}\n\\mathbf{U}_L,  x  0, \\\\\n\\mathbf{U}_R,  x > 0,\n\\end{cases}\n$$\n其中 $\\mathbf{U}_L$ 和 $\\mathbf{U}_R$ 由密度、速度和压力 $(\\rho, u, p)$ 指定，而 $E$ 由理想气体定律从 $p$ 计算得出。假设使用无量纲单位。\n\n您的任务是实现一个采用 Roe 通量差分分裂和特征场分离的一阶显式有限体积法。Roe 格式应从第一性原理构建：从欧拉方程和理想气体封闭关系出发，构建 Roe 平均值，推导特征分解（特征值和特征向量），计算波强度，并组装单元间数值通量。在每个交界面上，将通量贡献分离为三个特征场：左行声学场（特征值为 $u-c$）、接触场（特征值为 $u$）和右行声学场（特征值为 $u+c$），其中 $c$ 是声速。将解演化至最终时间 $T_{\\text{end}} = 0.15$，或者在首次出现正性损失的时间步提前终止。\n\n将正性损失定义为任意单元中出现 $\\rho \\le 0$ 或 $p \\le 0$。如果在单元 $i$ 发生正性损失，通过计算各场对守恒变量的更新贡献，诊断在该时间步哪个特征场是主要原因。具体而言：\n- 令 $\\Delta \\mathbf{U}_k(i)$ 表示在该步中，由于相邻交界面上的特征场 $k \\in \\{1,2,3\\}$ 对单元 $i$ 的守恒更新所做的贡献，其中 $k=1$ 对应左行声学场 ($u-c$)，$k=2$ 对应接触场 ($u$)，$k=3$ 对应右行声学场 ($u+c$)。\n- 如果检测到的是密度正性损失，选择使 $\\rho^n(i) + \\left[\\Delta \\mathbf{U}_k(i)\\right]_1$ 最小化的特征场索引 $k$，其中 $\\rho^n(i)$ 是更新前的密度，$\\left[\\cdot\\right]_1$ 表示密度分量。\n- 如果检测到的是压力正性损失，选择使根据 $\\mathbf{U}^n(i) + \\Delta \\mathbf{U}_k(i)$ 计算出的压力最小化的特征场索引 $k$，其中 $\\mathbf{U}^n(i)$ 是该步更新前的状态。\n\n将特征场索引报告为 $\\{-1, 0, +1\\}$ 中的一个整数，其映射关系为 $k=1 \\mapsto -1$，$k=2 \\mapsto 0$，$k=3 \\mapsto +1$。如果在 $T_{\\text{end}}$ 之前没有发生正性损失，则报告特征场索引为 $-2$。\n\n使用 Roe 通量差分分裂，除了标准的熵自洽波速绝对值外，不添加任何特别的修正，并在组装交界面通量时分离每个场的通量贡献。使用由 CFL 条件根据最大局部信号速度 $|u| + c$ 决定的稳定时间步长进行演化。\n\n测试套件：\n- 情况 A（标准非真空）：左状态 $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$，右状态 $(\\rho_R, u_R, p_R) = (0.125, 0.0, 0.1)$，$\\gamma = 1.4$。\n- 情况 B（左侧近真空）：左状态 $(\\rho_L, u_L, p_L) = (10^{-6}, 0.0, 10^{-6})$，右状态 $(\\rho_R, u_R, p_R) = (1.0, 0.0, 1.0)$，$\\gamma = 1.4$。\n- 情况 C（右侧近真空）：左状态 $(\\rho_L, u_L, p_L) = (1.0, 0.0, 1.0)$，右状态 $(\\rho_R, u_R, p_R) = (10^{-6}, 0.0, 10^{-6})$，$\\gamma = 1.4$。\n- 情况 D（非常强的非对称性）：左状态 $(\\rho_L, u_L, p_L) = (10^{-4}, 0.0, 10^{-8})$，右状态 $(\\rho_R, u_R, p_R) = (1.0, 0.0, 1.0)$，$\\gamma = 1.4$。\n\n对于每种情况，运行模拟并产生以下输出：\n- 一个整数 $b \\in \\{0,1\\}$，指示是否发生正性损失（1 表示是，0 表示否）。\n- 一个整数 $f \\in \\{-2,-1,0,1\\}$，指示导致正性损失的诊断特征场（如果未发生损失，则为 -2）。\n- 终止时域内的最小密度（浮点数）。\n- 终止时域内的最小压力（浮点数）。\n\n最终输出格式：\n您的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身表示为一个方括号括起来的逗号分隔列表。例如：\n$$\n[\\,[b_1,f_1,\\rho_{\\min,1},p_{\\min,1}],\\,[b_2,f_2,\\rho_{\\min,2},p_{\\min,2}],\\,[b_3,f_3,\\rho_{\\min,3},p_{\\min,3}],\\,[b_4,f_4,\\rho_{\\min,4},p_{\\min,4}]\\,]\n$$\n打印的输出中不能有空格。所有数值都应以上述无量纲单位输出。",
            "solution": "用户提供的问题是计算流体力学中一个适定性良好的任务，要求实现一个一阶有限体积法来求解一维理想气体欧拉方程。指定的数值格式是 Roe 通量差分分裂，该方法必须从基本原理构建。该任务的一个关键部分是诊断潜在的正性失效（即产生非物理状态，如负密度或负压力）的原因，方法是将更新归因于单个特征场。\n\n该问题在科学上和数学上是合理的，提供了所有必要的参数和一组明确的测试用例。这些测试用例，特别是涉及近真空状态的用例，旨在挑战标准 Roe 求解器的鲁棒性，众所周知，该求解器在没有专门“修正”的情况下容易出现此类失效。诊断要求使这成为一个非平凡的实现任务。\n\n解决方案按以下步骤进行：\n\n首先，我们建立数值框架。空间域 $[-1, 1]$ 被离散化为 $N=200$ 个宽度为 $\\Delta x$ 的均匀单元。系统的状态由每个单元中心的守恒变量矢量 $\\mathbf{U} = [\\rho, \\rho u, E]^T$ 描述。透射边界条件通过在计算域两端使用虚拟单元来实现，其中状态被设置为与相邻内部单元的状态相等（零阶外插）。\n\n时间演化由一个显式一阶格式控制：\n$$\n\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\mathbf{F}_{i+1/2} - \\mathbf{F}_{i-1/2} \\right)\n$$\n其中 $\\mathbf{U}_i^n$ 是在时间 $t^n$ 时单元 $i$ 中的状态，$\\mathbf{F}_{i+1/2}$ 是在单元 $i$ 和 $i+1$ 之间交界面上的数值通量。时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件动态确定，$\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_i(|u_i| + c_i)}$，其中 $c_i=\\sqrt{\\gamma p_i / \\rho_i}$ 是局部声速。\n\n该方法的核心是 Roe 数值通量，它在左状态 $\\mathbf{U}_L$ 和右状态 $\\mathbf{U}_R$ 之间的每个交界面 $i+1/2$ 处构建。Roe 格式通过在一个特殊构造的平均状态（即“Roe 平均”）周围对欧拉方程进行线性化，来近似局部黎曼问题的解。Roe 平均量（用帽子符号表示，例如 $\\hat{\\rho}, \\hat{u}, \\hat{H}, \\hat{c}$）是根据左右状态计算得出的。\n\n守恒变量的跳跃量 $\\Delta\\mathbf{U} = \\mathbf{U}_R - \\mathbf{U}_L$ 被分解到 Roe 平均雅可比矩阵 $\\hat{A}$ 的右特征向量 $\\hat{\\mathbf{r}}_k$ 的基上。\n$$\n\\Delta\\mathbf{U} = \\sum_{k=1}^3 \\hat{\\alpha}_k \\hat{\\mathbf{r}}_k\n$$\n其中系数 $\\hat{\\alpha}_k$ 是波强度。三个特征场对应于：\n1.  一个速度为 $\\hat{\\lambda}_1 = \\hat{u} - \\hat{c}$ 的左行声学波 ($k=1$)。\n2.  一个速度为 $\\hat{\\lambda}_2 = \\hat{u}$ 的接触间断 ($k=2$)。\n3.  一个速度为 $\\hat{\\lambda}_3 = \\hat{u} + \\hat{c}$ 的右行声学波 ($k=3$)。\n\n问题要求一种基于波传播的特定更新公式，这与 Roe 格式是等价的。单元 $i$ 的更新是其左右边界进入的扰动之和。从交界面 $i-1/2$ 进入单元 $i$ 的扰动是 $\\mathcal{A}_{i-1/2}^+ \\Delta \\mathbf{U}$，从交界面 $i+1/2$ 进入的是 $\\mathcal{A}_{i+1/2}^- \\Delta \\mathbf{U}$。算子 $\\mathcal{A}^\\pm$ 是 Roe 矩阵 $\\hat{A}$ 的正部和负部，由其谱分解构造而成：\n$$\n\\mathcal{A}_{i+1/2}^\\pm \\Delta \\mathbf{U} = \\sum_{k=1}^3 (\\hat{\\lambda}_k^\\pm)^* \\hat{\\alpha}_k \\hat{\\mathbf{r}}_k\n$$\n其中 $(\\hat{\\lambda}_k^\\pm)^* = \\frac{1}{2}(\\hat{\\lambda}_k \\pm |\\hat{\\lambda}_k|^*)$。项 $|\\hat{\\lambda}_k|^*$ 是波速大小，通过 Harten-Hyman 熵修正进行修改，以增加必要的耗散并防止非物理的膨胀激波。如果声学波（$k=1,3$）正在穿过声速点，则应用此修正。\n\n单元 $i$ 的总更新为：\n$$\n\\mathbf{U}_i^{n+1} - \\mathbf{U}_i^n = -\\frac{\\Delta t}{\\Delta x} \\left[ \\mathcal{A}_{i-1/2}^+ \\Delta \\mathbf{U} + \\mathcal{A}_{i+1/2}^- \\Delta \\mathbf{U} \\right]\n$$\n每个特征场 $k$ 对此更新的贡献 $\\Delta \\mathbf{U}_k(i)$ 被分离出来：\n$$\n\\Delta \\mathbf{U}_k(i) = -\\frac{\\Delta t}{\\Delta x} \\left[ ((\\hat{\\lambda}_k^+)^* \\hat{\\alpha}_k \\hat{\\mathbf{r}}_k)|_{i-1/2} + ((\\hat{\\lambda}_k^-)^* \\hat{\\alpha}_k \\hat{\\mathbf{r}}_k)|_{i+1/2} \\right]\n$$\n在计算总更新 $\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n + \\sum_k \\Delta \\mathbf{U}_k(i)$ 后，我们检查正性损失（$\\rho_i^{n+1} \\le 0$ 或 $p_i^{n+1} \\le 0$）。如果在单元 $i$ 检测到损失，模拟终止。通过找到那个当其更新贡献被单独考虑时会导致“最负”状态的场索引 $k$，来识别责任特征场。具体来说：\n-   如果 $\\rho_i^{n+1} \\le 0$，我们找到最小化 $\\rho_i^n + [\\Delta\\mathbf{U}_k(i)]_1$ 的 $k$。\n-   如果 $p_i^{n+1} \\le 0$，我们找到最小化由状态 $\\mathbf{U}_i^n + \\Delta\\mathbf{U}_k(i)$ 计算出的压力的 $k$。\n\n然后将识别出的场索引 $k \\in \\{1,2,3\\}$ 映射到 $\\{-1, 0, 1\\}$ 以便报告。如果模拟在 $T_{\\text{end}}=0.15$ 前无失效地完成，则场索引报告为 $-2$。每个测试用例的最终输出包括正性损失标志、责任场索引以及终止时域内的最小密度和压力。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': (1.0, 0.0, 1.0), 'R': (0.125, 0.0, 0.1), 'gamma': 1.4},\n        {'L': (1e-6, 0.0, 1e-6), 'R': (1.0, 0.0, 1.0), 'gamma': 1.4},\n        {'L': (1.0, 0.0, 1.0), 'R': (1e-6, 0.0, 1e-6), 'gamma': 1.4},\n        {'L': (1e-4, 0.0, 1e-8), 'R': (1.0, 0.0, 1.0), 'gamma': 1.4},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_simulation(case)\n        results.append(f\"[{res['b']},{res['f']},{res['rho_min']},{res['p_min']}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef get_cons_from_prim(rho, u, p, gamma):\n    \"\"\"Converts primitive variables (rho, u, p) to conserved variables U.\"\"\"\n    E = p / (gamma - 1.0) + 0.5 * rho * u**2\n    return np.array([rho, rho * u, E])\n\ndef get_prim_from_cons(U, gamma):\n    \"\"\"Converts conserved variables U to primitive variables (rho, u, p).\"\"\"\n    rho = U[0]\n    u = U[1] / rho\n    p = (gamma - 1.0) * (U[2] - 0.5 * rho * u**2)\n    return rho, u, p\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation case for the 1D Euler equations using Roe's scheme.\n\n    Args:\n        params (dict): A dictionary containing the initial left/right states and gamma.\n\n    Returns:\n        dict: A dictionary with the simulation results (b, f, rho_min, p_min).\n    \"\"\"\n    # Numerical and physical parameters\n    N = 200\n    L_domain = 2.0\n    dx = L_domain / N\n    \n    CFL = 0.9\n    T_end = 0.15\n    gamma = params['gamma']\n\n    # Initialize state vector U with ghost cells\n    U = np.zeros((3, N + 2))\n    \n    rho_L, u_L, p_L = params['L']\n    U_L = get_cons_from_prim(rho_L, u_L, p_L, gamma)\n    \n    rho_R, u_R, p_R = params['R']\n    U_R = get_cons_from_prim(rho_R, u_R, p_R, gamma)\n\n    # Set initial condition (Riemann problem at x=0)\n    U[:, 1 : N//2 + 1] = U_L[:, np.newaxis]\n    U[:, N//2 + 1 : N + 1] = U_R[:, np.newaxis]\n\n    t = 0.0\n    \n    while t  T_end:\n        # Apply transmissive boundary conditions\n        U[:, 0] = U[:, 1]\n        U[:, N + 1] = U[:, N]\n\n        # Calculate stable time step dt\n        rho_core = U[0, 1:N+1]\n        u_core = U[1, 1:N+1] / rho_core\n        p_core = (gamma - 1.0) * (U[2, 1:N+1] - 0.5 * U[1, 1:N+1]**2 / rho_core)\n        \n        # Guard against non-physical states from previous step for c calculation\n        p_core[p_core = 0] = 1e-12 \n        rho_core[rho_core = 0] = 1e-12\n        c_core = np.sqrt(gamma * p_core / rho_core)\n        \n        lambda_max = np.max(np.abs(u_core) + c_core)\n        if lambda_max == 0: lambda_max = 1e-9 # Avoid division by zero\n        dt = CFL * dx / lambda_max\n\n        if t + dt > T_end:\n            dt = T_end - t\n\n        # Array to store per-field contributions to the update\n        dU_k_contributions = np.zeros((3, 3, N)) # field_idx, component, cell_idx\n\n        # Loop over interfaces to compute fluctuations\n        for j in range(N + 1): # Interface j+1/2 is between cells j and j+1\n            U_L = U[:, j]\n            U_R = U[:, j+1]\n\n            rho_L, u_L, p_L = get_prim_from_cons(U_L, gamma)\n            rho_R, u_R, p_R = get_prim_from_cons(U_R, gamma)\n\n            # Roe Averages\n            sqrt_rho_L, sqrt_rho_R = np.sqrt(rho_L), np.sqrt(rho_R)\n            rho_hat = sqrt_rho_L * sqrt_rho_R\n            u_hat = (sqrt_rho_L * u_L + sqrt_rho_R * u_R) / (sqrt_rho_L + sqrt_rho_R)\n            \n            H_L = (U_L[2] + p_L) / rho_L\n            H_R = (U_R[2] + p_R) / rho_R\n            H_hat = (sqrt_rho_L * H_L + sqrt_rho_R * H_R) / (sqrt_rho_L + sqrt_rho_R)\n            \n            c_hat_sq = (gamma - 1.0) * (H_hat - 0.5 * u_hat**2)\n            c_hat = np.sqrt(max(c_hat_sq, 1e-12)) # Safety for c_hat\n\n            # Eigenvalues, eigenvectors, and wave strengths\n            lambdas_hat = np.array([u_hat - c_hat, u_hat, u_hat + c_hat])\n            r_hats = np.array([\n                [1.0, u_hat - c_hat, H_hat - u_hat * c_hat],\n                [1.0, u_hat, 0.5 * u_hat**2],\n                [1.0, u_hat + c_hat, H_hat + u_hat * c_hat]\n            ]).T\n            \n            dU = U_R - U_L\n            if c_hat > 1e-9:\n                alpha_2 = (gamma - 1.0) / c_hat**2 * ((H_hat - u_hat**2) * dU[0] + u_hat * dU[1] - dU[2])\n                alpha_3 = (dU[1] + (c_hat - u_hat) * dU[0] - c_hat * alpha_2) / (2.0 * c_hat)\n                alpha_1 = dU[0] - alpha_2 - alpha_3\n            else: # Fallback for near-zero c_hat\n                alpha_1, alpha_2, alpha_3 = 0, dU[0], 0\n            alphas = np.array([alpha_1, alpha_2, alpha_3])\n\n            # Harten-Hyman entropy fix for acoustic waves\n            c_L_safe = np.sqrt(max(1e-12, gamma * p_L / rho_L))\n            c_R_safe = np.sqrt(max(1e-12, gamma * p_R / rho_R))\n            lambdas_L = np.array([u_L - c_L_safe, u_L, u_L + c_L_safe])\n            lambdas_R = np.array([u_R - c_R_safe, u_R, u_R + c_R_safe])\n            \n            abs_lambdas_hat_fixed = np.abs(lambdas_hat)\n            for k in [0, 2]: # Acoustic fields\n                delta_k = lambdas_R[k] - lambdas_L[k]\n                if abs_lambdas_hat_fixed[k]  delta_k and delta_k > 0:\n                    abs_lambdas_hat_fixed[k] = (lambdas_hat[k]**2 + delta_k**2) / (2.0 * delta_k)\n\n            # Distribute fluctuations to neighboring cells\n            lambdas_plus = 0.5 * (lambdas_hat + abs_lambdas_hat_fixed)\n            lambdas_minus = 0.5 * (lambdas_hat - abs_lambdas_hat_fixed)\n            for k in range(3):\n                wave = alphas[k] * r_hats[:, k]\n                if j  N:  # Fluctuation to the right affects cell j (0-indexed)\n                    dU_k_contributions[k, :, j] += lambdas_plus[k] * wave\n                if j > 0:  # Fluctuation to the left affects cell j-1 (0-indexed)\n                    dU_k_contributions[k, :, j - 1] += lambdas_minus[k] * wave\n        \n        # Update state and check for positivity loss\n        U_old_core = U[:, 1:N+1].copy()\n        \n        dU_total = np.sum(dU_k_contributions, axis=0)\n        U_new_core = U_old_core - (dt / dx) * dU_total\n        \n        rho_new = U_new_core[0, :]\n        p_new = (gamma - 1.0) * (U_new_core[2, :] - 0.5 * U_new_core[1, :]**2 / rho_new)\n        \n        min_rho, min_p = np.min(rho_new), np.min(p_new)\n\n        if min_rho = 0 or min_p = 0:\n            fail_idx = np.argmin(rho_new) if min_rho = 0 else np.argmin(p_new)\n            U_fail_old = U_old_core[:, fail_idx]\n            dU_k_fail = dU_k_contributions[:, :, fail_idx]\n            \n            if min_rho = 0:\n                # Find field k that minimizes rho_old + delta_rho_k\n                # which is equivalent to maximizing the positive contribution to dU (rho component)\n                rho_updates = dU_k_fail[:, 0]\n                k_star = np.argmax(rho_updates) + 1\n            else: # Pressure loss\n                p_test = []\n                for k in range(3):\n                    U_test_k = U_fail_old - (dt / dx) * dU_k_fail[k, :]\n                    rho_k = U_test_k[0]\n                    if rho_k = 0:\n                        p_test.append(-1e9) # Heavily penalize density loss\n                    else:\n                        p_k = (gamma-1.0) * (U_test_k[2] - 0.5*U_test_k[1]**2/rho_k)\n                        p_test.append(p_k)\n                k_star = np.argmin(p_test) + 1\n            \n            field_map = {1: -1, 2: 0, 3: 1}\n            return {'b': 1, 'f': field_map[k_star], 'rho_min': min_rho, 'p_min': min_p}\n        \n        # Update state for next iteration\n        U[:, 1:N+1] = U_new_core\n        t += dt\n\n    # Simulation finished without positivity loss\n    rho_final = U[0, 1:N+1]\n    p_final = (gamma - 1.0) * (U[2, 1:N+1] - 0.5 * U[1, 1:N+1]**2 / rho_final)\n    \n    return {'b': 0, 'f': -2, 'rho_min': np.min(rho_final), 'p_min': np.min(p_final)}\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}