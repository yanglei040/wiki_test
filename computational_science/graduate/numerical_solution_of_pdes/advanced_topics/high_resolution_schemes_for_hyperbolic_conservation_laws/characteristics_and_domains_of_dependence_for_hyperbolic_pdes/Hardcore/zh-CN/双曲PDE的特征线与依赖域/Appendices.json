{
    "hands_on_practices": [
        {
            "introduction": "非线性双曲型偏微分方程（如伯格斯方程）的一个显著特征是其解可能在有限时间内形成激波，即使初始条件是光滑的。特征线法不仅是求解这类方程的有力工具，还能用于预测解何时何地会失效。本练习  旨在通过分析特征线的交叉来精确计算激波的形成时间，从而揭示非线性效应如何导致与线性波动截然不同的物理现象。",
            "id": "3369909",
            "problem": "考虑标量守恒律，即所谓的无粘性伯格斯偏微分方程（PDE），\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0,$$\n其光滑初始数据为\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x),$$\n其中 $A0$ 和 $K0$ 是常数。使用特征线法作为与上下文相符的基本方法，论证点 $(x,t)$ 的依赖域与特征流之间的关系，然后确定经典解因特征线相交（激波形成）而失去正则性的最早时间 $t_{s}0$。请以 $A$ 和 $K$ 的闭合形式给出 $t_{s}$。最终答案必须是单一的解析表达式。无需四舍五入。",
            "solution": "本题旨在分析无粘性伯格斯方程（一种标量守恒律）的解，并确定在特定初始条件下激波形成的时间。\n\n控制偏微分方程（PDE）为：\n$$u_{t} + \\left(\\frac{u^{2}}{2}\\right)_{x} = 0 \\quad \\text{for} \\quad x \\in \\mathbb{R}, \\ t \\ge 0$$\n使用链式法则，我们可以将通量项写为 $(\\frac{u^2}{2})_x = \\frac{d}{du}(\\frac{u^2}{2}) \\frac{\\partial u}{\\partial x} = u u_x$。这将该偏微分方程转换为其拟线性形式：\n$$u_{t} + u u_{x} = 0$$\n初始条件以光滑函数形式给出：\n$$u(x,0) = u_{0}(x) = -A \\tanh(K x)$$\n其中 $A$ 和 $K$ 是正常数，$A0$ 且 $K0$。\n\n特征线法是求解此类一阶双曲型偏微分方程的基本工具。拟线性形式 $u_t + c(u) u_x = 0$（在此，波速为 $c(u) = u$）表明，沿着由 $\\frac{dx}{dt} = c(u)$ 定义的曲线，$u$ 对时间的全导数为零。即，\n$$\\frac{d}{dt} u(x(t), t) = u_{t} + u_{x} \\frac{dx}{dt} = u_{t} + u u_{x} = 0$$\n这意味着解 $u$ 沿着由常微分方程 $\\frac{dx}{dt} = u$ 定义的特征曲线是恒定的。\n由于 $u$ 沿每条特征线是恒定的，因此每条特征线的传播速度也是恒定的。因此，特征曲线是在 $(x,t)$ 平面中的直线。\n\n设一条特征曲线从初始线上的一点 $(x_0, 0)$ 出发。沿着整条曲线的解的值由 $x_0$ 处的初始数据确定，即 $u(x(t), t) = u(x_0, 0) = u_0(x_0)$。特征线的方程则为：\n$$\\frac{dx}{dt} = u_{0}(x_0)$$\n将此方程对时间从 $0$ 积分到 $t$，得到特征线的显式方程：\n$$x(t) = x_{0} + u_{0}(x_0) t$$\n这个方程隐式地定义了解 $u(x,t)$。为了求出在点 $(x,t)$ 处 $u$ 的值，必须求解方程 $x = x_0 + u_0(x_0) t$ 以得到起始点 $x_0$。解即为 $u(x,t) = u_0(x_0)$。\n\n点 $(x,t)$ 的依赖域是在初始数据曲面（$t=0$ 处）上影响 $(x,t)$ 处解的点的集合。从特征方程可以明显看出，解 $u(x,t)$ 完全由通过 $(x,t)$ 的特征线在初始线上的落足点 $x_0$ 处的初始数据值决定。因此，对于这个一阶双曲型问题，$(x,t)$ 的依赖域是初始线 $t=0$ 上的单点集 $\\{x_0\\}$。\n\n只要在给定时间 $t$ 下从 $x_0$到 $x$ 的映射是一对一的，经典解就存在。当特征线相交时，该条件不再满足，导致多值解，这在物理上是不可能的。经典解的这种破坏称为激波形成。\n当从 $x_{0,1}$ 和 $x_{0,2}$ 出发的两条不同特征线在同一点 $(x,t)$ 相遇时，就会发生相交。对于从 $x_0$ 和 $x_0 + dx_0$ 出发的无限接近的特征线，它们的相交时间 $t$ 可以通过令它们的位置相等来找到：\n$$x_0 + u_0(x_0)t = (x_0 + dx_0) + u_0(x_0 + dx_0)t$$\n整理可得：\n$$[u_0(x_0) - u_0(x_0 + dx_0)]t = dx_0$$\n$$t = \\frac{dx_0}{u_0(x_0) - u_0(x_0 + dx_0)} = -\\frac{1}{\\frac{u_0(x_0 + dx_0) - u_0(x_0)}{dx_0}}$$\n取 $dx_0 \\to 0$ 的极限，从 $x_0$ 邻域出发的特征线的相交时间为：\n$$t(x_0) = -\\frac{1}{u_0'(x_0)}$$\n激波只能在 $t0$ 时形成，这要求 $u_0'(x_0)  0$。这个条件意味着特征线正在汇聚：从一个稍大的初始位置 $x_0+dx_0$ 出发的特征线，其速度 $u_0(x_0+dx_0)$ 比从 $x_0$ 出发的特征线的速度更小（或更负），导致它们相互靠近。\n\n激波首次出现的时间，记为 $t_s$，是所有导数为负的可能起始点 $x_0$ 的相交时间中的最小值：\n$$t_{s} = \\min_{x_0 : u_{0}'(x_0)0} \\left( -\\frac{1}{u_{0}'(x_0)} \\right)$$\n这等价于找到 $u_0'(x_0)$ 的全局最小值。我们想找到最小的正 $t$。这意味着我们想要 $u_0'(x_0)$ 的最大负值。所以我们需要找到 $u_0'(x_0)$ 的最小值。\n$$t_s = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)}$$\n我们给定的初始条件是 $u_{0}(x) = -A \\tanh(K x)$。我们必须计算其导数 $u_0'(x)$。\n$$u_{0}'(x) = \\frac{d}{dx} \\left( -A \\tanh(K x) \\right)$$\n使用链式法则以及 $\\frac{d}{dz}\\tanh(z) = \\operatorname{sech}^2(z)$ 这个事实，我们得到：\n$$u_{0}'(x) = -A \\cdot (\\operatorname{sech}^2(K x)) \\cdot K = -AK \\operatorname{sech}^2(K x)$$\n由于 $A0$ 且 $K0$，乘积 $-AK$ 是负的。函数 $\\operatorname{sech}^2(y)$ 总是非负的。因此，对于所有 $x \\in \\mathbb{R}$，$u_0'(x) \\le 0$ 成立，这证实了特征线总是在汇聚或是平行的（在无穷远处）。\n为了求出激波时间 $t_s$，我们必须找到 $u_0'(x)$ 的最小值。$u_0'(x)$ 的最小值将在正项 $\\operatorname{sech}^2(Kx)$ 取其最大值时出现。\n双曲正割函数 $\\operatorname{sech}(z) = \\frac{1}{\\cosh(z)}$，在其分母 $\\cosh(z)$ 取最小值时达到最大值。$\\cosh(z)$ 的最小值为 $1$，在 $z=0$ 时取得。\n因此，$\\operatorname{sech}(Kx)$ 的最大值为 $1$，在 $Kx=0$ 即 $x=0$ 时取得。$\\operatorname{sech}^2(Kx)$ 的最大值也为 $1$，在 $x=0$ 时取得。\n因此，导数的最小值为：\n$$\\min_{x \\in \\mathbb{R}} u_{0}'(x) = -AK \\cdot \\max_{x \\in \\mathbb{R}}(\\operatorname{sech}^2(K x)) = -AK \\cdot 1 = -AK$$\n这个最小值在 $x_0=0$ 处取得。这是初始剖面中负斜率最陡的点，也是特征线汇聚速率最高的地方。\n\n将此最小值代入激波形成时间的公式：\n$$t_{s} = \\frac{-1}{\\min_{x_0 \\in \\mathbb{R}} u_{0}'(x_0)} = \\frac{-1}{-AK} = \\frac{1}{AK}$$\n由于 $A0$ 且 $K0$，激波时间 $t_s$ 是正的，符合预期。",
            "answer": "$$\\boxed{\\frac{1}{AK}}$$"
        },
        {
            "introduction": "将连续的偏微分方程离散化为数值格式时，一个根本性问题是如何确保计算结果能捕捉到真实的物理过程。为了使数值解有意义，其依赖域必须包含真实的连续依赖域。本练习  深入探讨了这一核心原则，即Courant–Friedrichs–Lewy (CFL) 条件，并通过几何方式展示了它如何约束时间步长、空间步长以及计算模板之间的关系。",
            "id": "3369972",
            "problem": "考虑标量线性双曲偏微分方程 $u_t + a\\,u_x = 0$，其特征速度 $a \\in \\mathbb{R}$ 为常数，定义在间距为 $\\Delta x  0$ 的均匀网格上，并采用步长为 $\\Delta t  0$ 的显式时间步进方法。对于一个点 $(x_i, t_N)$（其中 $t_N = N\\,\\Delta t$），其连续依赖域是由特征曲线 $x(t) = x_i - a\\,t$ 决定的单个点 $(x_i - a\\,t_N, 0)$。在线性显式有限差分方法中，数值更新可以写为\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n,\n$$\n其中 $\\mathcal{S}$ 是定义模板的整数偏移量集合，$\\alpha_s$ 是满足相容性约束的、与方法相关的系数。$u_0^N$ 的数值依赖域是在时间层 $n=0$ 上所有网格指数的集合，这些网格上的值可以通过重复应用更新关系 $N$ 步来影响 $u_0^N$。该集合由 $\\mathcal{S}$ 中元素的所有 $N$ 重和生成，其在 $N$ 步后的极值指数为\n$$\ni_{\\min}(N) = N\\,\\min(\\mathcal{S}),\\qquad i_{\\max}(N) = N\\,\\max(\\mathcal{S}).\n$$\n$N$ 步后的数值影响包络是从 $i_{\\min}(N)$ 到 $i_{\\max}(N)$ 的空间范围，其物理宽度为\n$$\nW_{\\text{num}}(N) = \\left(i_{\\max}(N) - i_{\\min}(N)\\right)\\,\\Delta x.\n$$\nCourant–Friedrichs–Lewy (CFL) 条件要求 $\\Delta t \\le C\\,\\Delta x/\\max|\\lambda|$，其中 $\\lambda$ 表示双曲系统的特征速度，$C$ 是一个与方法相关的常数。对于上述标量方程，$\\max|\\lambda| = |a|$。您的任务是：\n- 从第一性原理推导 CFL 条件如何限制数值依赖域，即只要遵守格式相关的 $C$ 的界限，连续依赖域点 $(x_0 - a\\,t_N, 0)$ 就位于数值影响包络内部。\n- 构造并比较两个具有相同 CFL 参数 $C$ 但模板不同的显式格式：\n  1. 一个紧致迎风模板 $\\mathcal{S}_{\\mathrm{c}} = \\{0,-1\\}$。\n  2. 一个宽迎风模板 $\\mathcal{S}_{\\mathrm{w}} = \\{0,-1,-2,-3\\}$。\n- 对每种格式，量化其 $N$ 步后的有效数值域宽度 $W_{\\text{num}}(N)$，并将其与连续依赖域传播距离 $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t$ 进行比较。\n\n使用无量纲单位，使所有量均为纯数。使用以下参数值测试套件，它探索了一个典型情况、一个边界情况和一个边缘情况：\n1. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.8,\\,10)$。\n2. $(a,\\Delta x,C,N) = (0.5,\\,0.5,\\,1.0,\\,1)$。\n3. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.0,\\,5)$。\n4. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,1.2,\\,5)$。\n5. $(a,\\Delta x,C,N) = (1.0,\\,1.0,\\,0.7,\\,0)$。\n\n对每个测试用例，计算：\n- 紧致格式宽度 $W_{\\text{num,c}}(N)$。\n- 宽格式宽度 $W_{\\text{num,w}}(N)$。\n- 连续传播距离 $D_{\\text{cont}}(N)$。\n- 对每个格式，计算一个布尔标志，指示连续依赖域位置是否位于该格式的数值影响包络内（对于 $a0$，这简化为检查左侧延伸范围 $R_{\\text{left}}(N) = -i_{\\min}(N)\\,\\Delta x$ 是否满足 $R_{\\text{left}}(N) \\ge D_{\\text{cont}}(N)$）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形如\n$$\n[W_{\\text{num,c}},W_{\\text{num,w}},D_{\\text{cont}},\\text{inside\\_compact},\\text{inside\\_wide}],\n$$\n的内部列表，最终的聚合输出必须是这些内部列表的单个列表，列表内没有空格。例如，一个包含两个测试用例的输出将如下所示\n$$\n[[w_c^{(1)},w_w^{(1)},d^{(1)},b_c^{(1)},b_w^{(1)}],[w_c^{(2)},w_w^{(2)},d^{(2)},b_c^{(2)},b_w^{(2)}]].\n$$",
            "solution": "本问题要求推导 Courant-Friedrichs-Lewy (CFL) 条件与线性双曲偏微分方程依赖域之间的关系，然后对两种特定的有限差分格式进行定量分析。\n\n**1. 几何CFL条件的推导**\n\n给定的偏微分方程（PDE）是标量线性平流方程：\n$$\nu_t + a\\,u_x = 0\n$$\n其中 $a \\in \\mathbb{R}$ 是常数特征速度。特征线是 $(x,t)$ 平面中的一些线，解 $u$ 沿着这些线为常数。它们由常微分方程 $\\frac{dx}{dt} = a$ 定义。其解为 $x(t) = x(0) + a\\,t$。这意味着在时间 $t=0$ 时位于位置 $x(0)$ 的信号，在时间 $t$ 会传播到位置 $x(t)$。\n\n点 $(x_i, t_N)$ 的**连续依赖域**是在时间 $t=0$ 时影响点 $(x_i, t_N)$ 处解的所有点的集合。从 $(x_i, t_N)$ 沿特征线向后追溯时间，我们发现在 $t=0$ 时的影响点位于位置 $x_0 = x_i - a\\,t_N$。在时间间隔 $t_N$ 内，特征信息的传播距离为 $D_{\\text{cont}} = |a\\,t_N|$。\n\n线性显式有限差分格式在间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的网格上近似求解。其更新法则如下：\n$$\nu_i^{n+1} = \\sum_{s \\in \\mathcal{S}} \\alpha_s\\,u_{i+s}^n\n$$\n其中 $\\mathcal{S}$ 是模板。经过一个时间步后，网格点 $i$ 处的值取决于前一时间层上集合 $\\{i+s \\mid s \\in \\mathcal{S}\\}$ 中的点。经过 $N$ 步后，值 $u_i^N$ 取决于初始值 $u_j^0$，其中指数 $j$ 的范围是 $[i + N\\min(\\mathcal{S}), i + N\\max(\\mathcal{S})]$。\n\n点 $(x_i, t_N)$ 的**数值依赖域**是在 $t=0$ 时包含所有影响 $u_i^N$ 的网格点的空间区间。相对于 $x_i$，该区间为 $[i_{\\min}(N)\\Delta x, i_{\\max}(N)\\Delta x]$，其中 $i_{\\min}(N) = N\\min(\\mathcal{S})$ 且 $i_{\\max}(N) = N\\max(\\mathcal{S})$。此数值影响包络的宽度为 $W_{\\text{num}}(N) = (i_{\\max}(N) - i_{\\min}(N))\\Delta x$。\n\n基本的 Courant-Friedrichs-Lewy (CFL) 条件规定，对于一个收敛的数值格式，连续依赖域必须被包含在数值依赖域之内。对于点 $(x_i, t_N)$，这意味着物理点 $x_i - a\\,t_N$ 必须位于物理区间 $[x_i + i_{\\min}(N)\\Delta x, x_i + i_{\\max}(N)\\Delta x]$ 内。\n$$\nx_i + N\\min(\\mathcal{S})\\Delta x \\le x_i - a\\,t_N \\le x_i + N\\max(\\mathcal{S})\\Delta x\n$$\n减去 $x_i$ 并代入 $t_N = N\\Delta t$：\n$$\nN\\min(\\mathcal{S})\\Delta x \\le -a\\,N\\Delta t \\le N\\max(\\mathcal{S})\\Delta x\n$$\n对于 $N0$，我们可以除以 $N\\Delta x$：\n$$\n\\min(\\mathcal{S}) \\le -a\\,\\frac{\\Delta t}{\\Delta x} \\le \\max(\\mathcal{S})\n$$\n令 Courant 数为 $\\nu = a\\frac{\\Delta t}{\\Delta x}$。该条件变为 $\\min(\\mathcal{S}) \\le -\\nu \\le \\max(\\mathcal{S})$，或等价地，$-\\max(\\mathcal{S}) \\le \\nu \\le -\\min(\\mathcal{S})$。\n\n所有测试用例都具有 $a0$，并且问题指定了偏向负指数的“迎风”模板。这意味着 $\\max(\\mathcal{S})=0$。因此，CFL 条件简化为：\n$$\n0 \\le \\nu \\le -\\min(\\mathcal{S})\n$$\n第一个不等式 $0 \\le \\nu$ 对于 $a0$、$\\Delta t0$ 和 $\\Delta x0$ 总是成立。关键部分是第二个不等式 $\\nu \\le -\\min(\\mathcal{S})$。问题使用参数 $C$ 将 CFL 条件定义为 $\\Delta t \\le C\\,\\Delta x/|a|$，这对于 $a0$ 等价于 $\\nu \\le C$。因此，当且仅当所选参数 $C$ 满足 $C \\le -\\min(\\mathcal{S})$ 时，几何包含条件才成立。\n\n**2. 对指定格式的分析**\n\n对于这两种格式，我们都使用给定参数 $C$ 所允许的最大时间步长，即 $\\Delta t = C\\,\\Delta x/|a|$。对于 $a0$，即为 $\\Delta t = C\\,\\Delta x/a$。连续传播距离为 $D_{\\text{cont}}(N) = |a|\\,N\\,\\Delta t = a\\,N(C\\,\\Delta x/a) = NC\\Delta x$。\n\n**格式1：紧致迎风模板**\n- 模板：$\\mathcal{S}_{\\mathrm{c}} = \\{0, -1\\}$。\n- 模板边界：$\\min(\\mathcal{S}_{\\mathrm{c}}) = -1$，$\\max(\\mathcal{S}_{\\mathrm{c}}) = 0$。\n- $N$ 步后的极值指数：$i_{\\min,c}(N) = -N$，$i_{\\max,c}(N) = 0$。\n- 数值宽度：$W_{\\text{num,c}}(N) = (i_{\\max,c}(N) - i_{\\min,c}(N))\\Delta x = (0 - (-N))\\Delta x = N\\Delta x$。\n- 包含条件：连续点 $x_i - a\\,t_N$ 必须在数值包络内。对于 $a0$，我们检查数值格式的左向延伸范围是否足够。左向延伸范围为 $R_{\\text{left,c}}(N) = -i_{\\min,c}(N)\\Delta x = N\\Delta x$。条件为 $R_{\\text{left,c}}(N) \\ge D_{\\text{cont}}(N)$，即 $N\\Delta x \\ge NC\\Delta x$，或 $1 \\ge C$。\n\n**格式2：宽迎风模板**\n- 模板：$\\mathcal{S}_{\\mathrm{w}} = \\{0, -1, -2, -3\\}$。\n- 模板边界：$\\min(\\mathcal{S}_{\\mathrm{w}}) = -3$，$\\max(\\mathcal{S}_{\\mathrm{w}}) = 0$。\n- $N$ 步后的极值指数：$i_{\\min,w}(N) = -3N$，$i_{\\max,w}(N) = 0$。\n- 数值宽度：$W_{\\text{num,w}}(N) = (i_{\\max,w}(N) - i_{\\min,w}(N))\\Delta x = (0 - (-3N))\\Delta x = 3N\\Delta x$。\n- 包含条件：左向延伸范围为 $R_{\\text{left,w}}(N) = -i_{\\min,w}(N)\\Delta x = 3N\\Delta x$。条件 $R_{\\text{left,w}}(N) \\ge D_{\\text{cont}}(N)$ 变为 $3N\\Delta x \\ge NC\\Delta x$，或 $3 \\ge C$。\n\n**3. 测试用例的计算**\n\n对于每个测试用例 $(a, \\Delta x, C, N)$，我们计算以下量：\n1.  $W_{\\text{num,c}}(N) = N\\Delta x$\n2.  $W_{\\text{num,w}}(N) = 3N\\Delta x$\n3.  $D_{\\text{cont}}(N) = NC\\Delta x$\n4.  `inside_compact`：一个布尔标志，如果 $C \\le 1$ 则为 `True`，否则为 `False`。\n5.  `inside_wide`：一个布尔标志，如果 $C \\le 3$ 则为 `True`，否则为 `False`。\n\n这些公式在提供的 Python 脚本中实现，以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating numerical domain widths and\n    checking CFL inclusion for two finite difference schemes.\n    \"\"\"\n    # Define the test cases from the problem statement:\n    # Each case is a tuple (a, delta_x, C, N).\n    test_cases = [\n        (1.0, 1.0, 0.8, 10),\n        (0.5, 0.5, 1.0, 1),\n        (1.0, 1.0, 1.0, 5),\n        (1.0, 1.0, 1.2, 5),\n        (1.0, 1.0, 0.7, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, delta_x, C, N = case\n\n        # For the compact upwind scheme, S_c = {0, -1}\n        # min(S_c) = -1, max(S_c) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_c = (0 - (-1)) * N * delta_x = N * delta_x\n        w_num_c = float(N * delta_x)\n\n        # For the wide upwind scheme, S_w = {0, -1, -2, -3}\n        # min(S_w) = -3, max(S_w) = 0\n        # The numerical domain width is (max - min) * N * delta_x\n        # W_num_w = (0 - (-3)) * N * delta_x = 3 * N * delta_x\n        w_num_w = float(3 * N * delta_x)\n\n        # The continuum travel distance is D_cont = |a| * N * delta_t.\n        # We use delta_t = C * delta_x / |a|.\n        # So, D_cont = |a| * N * (C * delta_x / |a|) = N * C * delta_x\n        d_cont = float(N * C * delta_x)\n\n        # The CFL inclusion condition is that the continuum domain of dependence\n        # must lie within the numerical domain of dependence.\n        # As derived, this is equivalent to C = -min(S).\n\n        # For the compact scheme, -min(S_c) = 1. Condition: C = 1.\n        inside_compact = (C = 1.0)\n\n        # For the wide scheme, -min(S_w) = 3. Condition: C = 3.\n        inside_wide = (C = 3.0)\n\n        # Assemble the results for the current test case.\n        case_result = [w_num_c, w_num_w, d_cont, inside_compact, inside_wide]\n        results.append(case_result)\n\n    # The final output must be a single string representing a list of lists,\n    # with no spaces.\n    final_output_string = str(results).replace(\" \", \"\")\n\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "满足CFL条件保证了数值格式的稳定性，但并不等同于高精度。许多数值格式，特别是像迎风格式这样的一阶方法，会引入一种被称为数值扩散（或数值黏性）的误差，导致解被过度平滑。本练习  提供了一种量化这种效应的动手方法，通过计算格式对脉冲输入的响应（其离散格林函数），并测量解“溢出”真实特征锥边界的程度，从而帮助理解数值方法中简单性、稳定性和精度之间的权衡。",
            "id": "3369903",
            "problem": "要求您构建一个程序，用于计算和分析常系数线性平流方程的一阶线性迎风有限差分法（FDM）的离散格林函数。请完全在无量纲环境下工作；不需要物理单位。\n\n控制偏微分方程为线性平流方程\n$$\nu_t + c\\,u_x = 0,\n$$\n其中 $c \\in \\mathbb{R}$ 为恒定平流速度。考虑一个间距为 $\\Delta x  0$ 的均匀空间网格和一个均匀时间步长 $\\Delta t  0$。令 Courant–Friedrichs–Lewy (CFL) 数为 $\\lambda = \\dfrac{c\\,\\Delta t}{\\Delta x}$。假设采用标准的单调迎风 FDM：\n- 若 $c  0$，则更新式为\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n.\n$$\n- 若 $c  0$，则更新式为\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right) = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n.\n$$\n假设 $|\\lambda| \\le 1$ 以确保稳定性和单调性。离散格林函数 $G_j^n$ 定义为从脉冲初始数据 $u_j^0 = \\delta_{j,j_0}$ 得到的数值解，其中 $\\delta_{j,j_0}$ 是 Kronecker delta，而 $j_0$ 是一个固定的网格索引。\n\n对于连续方程，有限的传播速度产生了一个解析前向锥约束：从初始点 $x_0 = j_0 \\Delta x$ 出发，在时间 $t^n = n\\,\\Delta t$ 时可达的点集受 $s\\,(x-x_0) \\le |c|\\,t^n$ 约束，其中 $s = \\mathrm{sign}(c)$ 且 $|\\cdot|$ 表示绝对值。在网格上，这个解析前向锥转化为索引约束\n$$\ns\\,(j - j_0) \\le |\\lambda|\\,n.\n$$\n引入 Heaviside 函数 $H(z)$，当 $z0$ 时 $H(z)=1$，否则 $H(z)=0$。将在时间层 $n$ 的离散“解析锥边界之外的溢出”定义为\n$$\nE(n) \\equiv \\sum_{j \\in \\mathbb{Z}} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right).\n$$\n这个 $E(n)$ 是一个非负实数，它衡量了离散格林函数对解析传播速度约束的违反程度，其意义是在时间 $t^n$ 时，严格位于解析锥边界之外的质量分数。\n\n您的任务是：\n- 在一个有 $N$ 个点的足够大的一维网格上，通过给定的迎风格式数值化地构造 $G_j^n$，在计算域外使用零值。使用 $N = 2048$ 和 $j_0 = N/2$。确保所选的测试用例使演化中的支撑集与边界保持足够远的距离，以便边界截断不会影响离散解。\n- 对每个测试用例，计算并返回最终时间层 $n$ 的单个标量值 $E(n)$。\n\n程序必须是自包含的，并且在没有用户输入的情况下，为以下测试套件生成结果。每个测试用例都是一个四元组 $(c,\\Delta x,\\Delta t,n)$：\n- 测试 A（具有不可忽略扩散的通用“理想路径”）：$(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;\\frac{1}{4},\\;40\\,)$。\n- 测试 B（精确平移的边界情况，无数值扩散）：$(c,\\Delta x,\\Delta t,n) = (\\,1,\\;1,\\;1,\\;40\\,)$。\n- 测试 C（负平流速度，具有不可忽略的扩散）：$(c,\\Delta x,\\Delta t,n) = (\\,-\\frac{1}{2},\\;1,\\;0.6,\\;50\\,)$。\n- 测试 D（中等 CFL 下的更长时间演化）：$(c,\\Delta x,\\Delta t,n) = (\\,2,\\;1,\\;0.2,\\;100\\,)$。\n\n您的程序应生成单行输出，其中包含测试 A、B、C 和 D 的 $E(n)$ 值，按此顺序排列，形式为方括号内以逗号分隔的列表（例如 `[result_A,result_B,result_C,result_D]`）。答案必须是实数。\n\n设计要求和约束：\n- 使用 $G_j^n$ 的定义，即从 $u_j^0 = \\delta_{j,j_0}$ 开始，通过将离散格式演化 $n$ 步获得的数值脉冲响应。\n- 使用上面给出的 $E(n)$ 的定义，其中 $s = \\mathrm{sign}(c)$ 且 $|\\lambda| = \\left|\\dfrac{c\\,\\Delta t}{\\Delta x}\\right|$。\n- 计算过程必须是确定性的，不依赖于任何外部数据或用户输入。",
            "solution": "该问题具有科学依据、是适定的，并且其所有参数都已完全指定。控制方程、数值格式以及待计算的度量都是偏微分方程数值分析中的标准概念。所有测试用例都满足稳定性条件 $|\\lambda| \\le 1$。计算域足够大，可以防止边界效应影响结果，符合要求。因此，该问题被认为是有效的。\n\n问题的核心是为一阶迎风格式计算离散格林函数 $G_j^n$，然后用它来评估一个特定的度量 $E(n)$，该度量用于量化数值扩散。\n\n控制方程是线性平流方程 $u_t + c\\,u_x = 0$，其中 $u(x,t)$ 是一个标量， $c \\in \\mathbb{R}$ 是恒定的平流速度。我们在一个空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上离散化该方程。在网格点 $j$ 和时间层 $n$ 的数值解记为 $u_j^n$。Courant–Friedrichs–Lewy (CFL) 数是 $\\lambda = \\frac{c\\,\\Delta t}{\\Delta x}$。\n\n迎风有限差分法的具体规定如下：\n如果平流速度为正 ($c  0$)，信息从左向右流动。格式为：\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_j^n - u_{j-1}^n\\right) = (1-\\lambda)u_j^n + \\lambda u_{j-1}^n\n$$\n如果平流速度为负 ($c  0$)，信息从右向左流动。格式为：\n$$\nu_j^{n+1} = u_j^n - \\lambda\\left(u_{j+1}^n - u_j^n\\right)\n$$\n注意到当 $c  0$ 时，$\\lambda  0$，我们可以写成 $\\lambda = -|\\lambda|$，因此格式变为：\n$$\nu_j^{n+1} = (1+\\lambda)u_j^n - \\lambda u_{j+1}^n = (1-|\\lambda|)u_j^n + |\\lambda| u_{j+1}^n\n$$\n这些格式在 $|\\lambda| \\le 1$ 的条件下是稳定且单调的。\n\n离散格林函数 $G_j^n$ 是该数值格式对初始脉冲的响应。我们从初始条件 $u_j^0 = \\delta_{j,j_0}$ 开始，其中 $\\delta_{j,j_0}$ 是 Kronecker delta，它在一个特定的索引 $j_0$ 处为 1，在其他所有地方为 0。计算域是一个由 $N=2048$ 个点组成的有限网格，索引从 $j=0$ 到 $N-1$。初始脉冲放置在中心，$j_0 = N/2 = 1024$。问题指定对该域外的网格点使用零值，这在实现格式时转化为零-Dirichlet 边界条件。例如，在 $c0$ 的情况下更新 $j=0$ 处的值时，$u_{-1}^n$ 的值取为 0。\n\n求解算法通过从初始脉冲 $u_j^0 = \\delta_{j,1024}$ 开始，迭代地应用适当的迎风格式共 $n$ 个时间步来进行。在每一步中，从当前状态 $u^n$ 计算出新的状态向量 $u^{n+1}$。使用当前状态的临时副本，以确保新时间层的所有更新都基于相同的、完整的旧时间层。经过 $n$ 步后，得到的网格函数 $u_j^n$ 就是所求的离散格林函数 $G_j^n$。\n\n一旦计算出 $G_j^n$，最后一步就是计算溢出度量 $E(n)$。该度量定义为：\n$$\nE(n) \\equiv \\sum_{j=0}^{N-1} G_j^n\\, H\\!\\left( s\\,(j - j_0) - |\\lambda|\\,n \\right)\n$$\n在这里，$s = \\mathrm{sign}(c)$ 是平流速度的符号。Heaviside 函数的参数 $z = s\\,(j - j_0) - |\\lambda|\\,n$ 决定了网格点 $j$ 是否严格位于源自 $x_0 = j_0 \\Delta x$ 的解析特征线之外。解析解以速度 $c$ 传播，因此在时间 $t^n = n\\,\\Delta t$ 时，波前应位于 $x = x_0 + c t^n$，这在网格上对应于索引偏移 $\\frac{c t^n}{\\Delta x} = \\frac{c (n \\Delta t)}{\\Delta x} = \\lambda n = s |\\lambda| n$。因此，溢出条件 $s(j - j_0)  |\\lambda| n$ 标识了所有位于此特征线“前方”的网格点 $j$。\n\nHeaviside 函数 $H(z)$ 定义为当 $z0$ 时为 1，否则为 0。它起到一个滤波器的作用，因此 $E(n)$ 的求和只包括这些溢出网格点上的“质量”（即 $G_j^n$ 的值）。对所提供的四个测试用例中的每一个都执行此过程，并收集得到的 $E(n)$ 值。\n\n在实现上，使用 `numpy` 的向量化方法是高效的。对于 $c0$ 的时间步进，可以通过对数组切片 `u[1:]` 和 `u[:-1]` 进行操作来实现，并对边界点 `u[0]` 进行单独更新。类似的方法也适用于 $c0$ 的情况。$E(n)$ 的最终计算涉及根据 Heaviside 函数的参数创建一个布尔掩码，并将其与最终的 $G_j^n$ 向量进行点积运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spillover(c, delta_x, delta_t, n_final):\n    \"\"\"\n    Computes the discrete Green's function and the spillover metric E(n).\n\n    Args:\n        c (float): Advection speed.\n        delta_x (float): Spatial grid spacing.\n        delta_t (float): Time step.\n        n_final (int): Number of time steps to evolve.\n\n    Returns:\n        float: The spillover metric E(n) at the final time step.\n    \"\"\"\n    N = 2048\n    j0 = N // 2\n\n    # Initialize the grid with the discrete impulse (Kronecker delta).\n    u = np.zeros(N, dtype=np.float64)\n    u[j0] = 1.0\n\n    # Calculate CFL number and sign of c.\n    lambda_val = c * delta_t / delta_x\n    s = np.sign(c)\n\n    # Time-stepping loop to construct the Green's function G_j^n.\n    for _ in range(n_final):\n        # Use a copy of u to ensure updates are based on the complete state at time n.\n        u_old = u.copy()\n        \n        if c > 0:\n            # Upwind scheme for c > 0: u_j^{n+1} = (1-lambda)u_j^n + lambda*u_{j-1}^n\n            # Update interior points j=1,...,N-1\n            u[1:] = (1.0 - lambda_val) * u_old[1:] + lambda_val * u_old[:-1]\n            # Update boundary point j=0, where u_{-1}^n is 0.\n            u[0] = (1.0 - lambda_val) * u_old[0]\n        elif c  0:\n            abs_lambda = abs(lambda_val)\n            # Upwind scheme for c  0: u_j^{n+1} = (1-|lambda|)u_j^n + |lambda|*u_{j+1}^n\n            # Update interior points j=0,...,N-2\n            u[:-1] = (1.0 - abs_lambda) * u_old[:-1] + abs_lambda * u_old[1:]\n            # Update boundary point j=N-1, where u_{N}^n is 0.\n            u[-1] = (1.0 - abs_lambda) * u_old[-1]\n        # If c = 0, lambda = 0, u remains unchanged, which is the correct behavior.\n\n    # At this point, u contains the values of the discrete Green's function G_j^n\n    # at the final time step n_final.\n\n    # Compute the spillover metric E(n).\n    j_indices = np.arange(N)\n    abs_lambda = abs(lambda_val)\n\n    # Calculate the argument of the Heaviside function for all j.\n    # z = s*(j - j0) - |lambda|*n\n    heaviside_arg = s * (j_indices - j0) - abs_lambda * n_final\n\n    # Create the Heaviside mask. H(z)=1 if z>0, and 0 otherwise.\n    heaviside_mask = (heaviside_arg > 0).astype(np.float64)\n\n    # E(n) is the sum of G_j^n over the indices where the mask is 1.\n    E_n = np.sum(u * heaviside_mask)\n\n    return E_n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (c, delta_x, delta_t, n_final)\n    test_cases = [\n        (1.0, 1.0, 0.25, 40),      # Test A\n        (1.0, 1.0, 1.0, 40),       # Test B\n        (-0.5, 1.0, 0.6, 50),      # Test C\n        (2.0, 1.0, 0.2, 100),      # Test D\n    ]\n\n    results = []\n    for case in test_cases:\n        c, delta_x, delta_t, n_final = case\n        result = compute_spillover(c, delta_x, delta_t, n_final)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}