{
    "hands_on_practices": [
        {
            "introduction": "We begin our hands-on exploration with a foundational and computationally elegant case: random fields on periodic domains. For a stationary random field, the covariance operator is a convolution, which means its eigenfunctions are the familiar Fourier modes. This exercise  solidifies this crucial theoretical link and leverages it to build a powerful solver using the Fast Fourier Transform (FFT) for everything from computing KL eigenvalues to sampling the random field and solving a stochastic PDE.",
            "id": "3413062",
            "problem": "Consider the periodic domain $D=\\mathbb{T}^d$ modeled as the $d$-dimensional unit torus with periodic boundary conditions and a stationary covariance function $C(x-y)$ that depends only on spatial differences. The Karhunen-Loève expansion is defined by the eigenvalue problem for the covariance operator $K$ acting on square-integrable functions:\n$$\n(K\\phi)(x) = \\int_D C(x-y)\\,\\phi(y)\\,dy = \\lambda\\,\\phi(x).\n$$\nBegin from first principles: stationarity (translation invariance) and periodicity imply that the covariance operator can be represented as a convolution. From this base, derive that the eigenfunctions of $K$ on $D=\\mathbb{T}^d$ are spatial Fourier modes and that the corresponding eigenvalues are the Fourier series coefficients of $C$. Then, design an algorithm that uses the Fast Fourier Transform (FFT) to:\n- Compute the discrete eigenvalues $\\lambda_k$ from samples of $C$ on a uniform grid.\n- Verify numerically that applying $K$ to a Fourier mode $e^{2\\pi i k\\cdot x}$ returns a scalar multiple of the same mode.\n- Sample a real-valued Gaussian random field $a(x)$ with zero mean and covariance $C$ by drawing independent complex Gaussian Fourier coefficients with appropriate Hermitian symmetry and scaling by $\\sqrt{\\lambda_k}$.\n- Solve the periodic Helmholtz-type partial differential equation $(I - \\beta \\Delta)u = a$ using Fourier diagonalization, where $\\Delta$ is the Laplacian on $\\mathbb{T}^d$ and $\\beta>0$ is a scalar.\n\nYour program must implement the following numerical model components:\n- A uniform grid in one and two dimensions with $N$ points per dimension, representing $D=[0,1]^d$ with grid points $x_j=j/N$ (component-wise for $d=2$).\n- A discrete, periodic covariance kernel $C_h$ constructed by evaluating either a Gaussian model $C_{\\text{G}}(r) = \\sigma^2 \\exp(-r^2/(2\\ell^2))$ or an exponential model $C_{\\text{E}}(r) = \\sigma^2 \\exp(-r/\\ell)$ at the minimal periodic Euclidean distance $r$ between grid points.\n- Discrete Fourier transforms to compute $\\lambda_k$ as the array $\\mathcal{F}[C_h]$.\n- An FFT-based convolution to apply $K$ to a discrete function $f$ via $(K f)_h = \\mathcal{F}^{-1}(\\mathcal{F}[C_h]\\cdot \\mathcal{F}[f])$.\n- A Fourier-mode generator $\\phi_k$ on the grid $\\phi_k(x_j)=\\exp(2\\pi i\\,k\\cdot x_j)$ for multi-index $k$.\n- A sampler to generate a real Gaussian field $a$ with covariance $C_h$ by constructing complex Fourier coefficients with Hermitian symmetry and variance proportional to $\\lambda_k$; enforce real-valued output by symmetry constraints at self-conjugate modes.\n- A solver for $(I-\\beta\\Delta)u=a$ using the Fourier symbol $1+\\beta(2\\pi)^2\\lVert k\\rVert^2$.\n\nUse the following test suite of parameter sets to produce numerical validations:\n- Test 1 (one-dimensional Gaussian eigenmode consistency): $d=1$, $N=64$, covariance $C_{\\text{G}}$ with $\\sigma=1$ and $\\ell=0.12$, mode $k=3$. Output the relative $\\ell^2$-error $\\lVert K\\phi_k - \\lambda_k \\phi_k\\rVert_2 / \\lVert \\lambda_k \\phi_k\\rVert_2$.\n- Test 2 (one-dimensional exponential eigenmode consistency): $d=1$, $N=64$, covariance $C_{\\text{E}}$ with $\\sigma=1$ and $\\ell=0.20$, mode $k=5$. Output the same relative error as Test 1.\n- Test 3 (two-dimensional Gaussian eigenmode consistency): $d=2$, $N=(32,32)$, covariance $C_{\\text{G}}$ with $\\sigma=1$ and $\\ell=0.15$, mode $k=(2,3)$. Output the same relative error as Test 1.\n- Test 4 (FFT-based sampling realness check): Use the two-dimensional Gaussian covariance from Test 3 and a fixed random seed $12345$ to sample $a$. Output the maximum absolute value of the imaginary part of $a$.\n- Test 5 (FFT-based Helmholtz solver residual): Solve $(I-\\beta\\Delta)u=a$ with $\\beta=0.01$ using the same sampled $a$ from Test 4. Output the relative residual norm $\\lVert (I-\\beta\\Delta)u - a\\rVert_2 / \\lVert a\\rVert_2$.\n\nAll outputs must be dimensionless real numbers. Your program should produce a single line of output containing the results of the five tests as a comma-separated list enclosed in square brackets, in the order of Tests 1 through 5 (for example, $[r_1,r_2,r_3,r_4,r_5]$). Use radians consistently for all Fourier phase computations. No physical units are involved in this problem. The implementation must be self-contained, require no external input, and must adhere to the specified execution environment.",
            "solution": "The problem requires a theoretical derivation followed by the design and implementation of a numerical algorithm for tasks related to the Karhunen-Loève (KL) expansion on a periodic domain.\n\n**Theoretical Derivation: Eigenfunctions and Eigenvalues on the Torus**\n\nWe are given the eigenvalue problem for the covariance operator $K$ on the domain $D=\\mathbb{T}^d$, the $d$-dimensional unit torus:\n$$\n(K\\phi)(x) = \\int_{\\mathbb{T}^d} C(x-y)\\,\\phi(y)\\,dy = \\lambda\\,\\phi(x)\n$$\nThe covariance function $C$ is stationary, meaning it only depends on the spatial difference $z=x-y$. This implies that the operator $K$ is a convolution operator, which can be expressed as $(K\\phi)(x) = (C * \\phi)(x)$.\n\nWe will demonstrate that the complex spatial Fourier modes, $\\phi_k(x) = e^{2\\pi i k \\cdot x}$ for wave vectors $k \\in \\mathbb{Z}^d$, are eigenfunctions of this operator. We substitute $\\phi_k(x)$ into the eigenvalue equation:\n$$\n(K\\phi_k)(x) = \\int_{\\mathbb{T}^d} C(x-y) e^{2\\pi i k \\cdot y} dy\n$$\nLet's perform a change of variables in the integral letting $z = x-y$. This implies $y = x-z$ and $dy = dz$ (as the Jacobian determinant is $1$ and the domain is periodic). The integration is over the same domain $\\mathbb{T}^d$.\n$$\n(K\\phi_k)(x) = \\int_{\\mathbb{T}^d} C(z) e^{2\\pi i k \\cdot (x-z)} dz\n$$\nWe can factor out the term depending on $x$ from the integral:\n$$\n(K\\phi_k)(x) = e^{2\\pi i k \\cdot x} \\int_{\\mathbb{T}^d} C(z) e^{-2\\pi i k \\cdot z} dz\n$$\nThe integral on the right is the definition of the Fourier series coefficient of the function $C(z)$ for the mode $k$. Let's define this coefficient as $\\lambda_k$:\n$$\n\\lambda_k = \\int_{\\mathbb{T}^d} C(z) e^{-2\\pi i k \\cdot z} dz\n$$\nSubstituting this back, we obtain:\n$$\n(K\\phi_k)(x) = \\lambda_k \\, e^{2\\pi i k \\cdot x} = \\lambda_k \\, \\phi_k(x)\n$$\nThis confirms that the Fourier modes $\\phi_k(x)$ are indeed the eigenfunctions of any stationary (convolutional) operator on the torus $\\mathbb{T}^d$. The corresponding eigenvalues $\\lambda_k$ are the Fourier series coefficients of the kernel function, which in this case is the covariance function $C$. Since for a real-valued random field, the covariance function is real and even ($C(z) = C(-z)$), its Fourier coefficients (the eigenvalues $\\lambda_k$) are real and non-negative.\n\n**Algorithm Design and Numerical Implementation**\n\nThe numerical model is implemented on a uniform discrete grid on $[0,1]^d$ with $N$ points per dimension and periodic boundary conditions.\n\n1.  **Discrete Covariance Kernel $C_h$**: The continuous covariance function $C(r)$ is evaluated on a grid of spatial lags corresponding to the structure required for discrete circular convolution via FFT. For a grid of size $N_1 \\times \\dots \\times N_d$, we form a grid of lag vectors $(\\delta_1, \\dots, \\delta_d)$ where each $\\delta_i \\in [-0.5, 0.5)$. The value of the kernel at each point is $C(r)$, where $r = \\sqrt{\\delta_1^2 + \\dots + \\delta_d^2}$ is the Euclidean norm of the lag vector. This construction ensures that the kernel is centered and properly handles periodic wrapping.\n\n2.  **Discrete Eigenvalues and Operator Application**: Based on the theoretical derivation and the convolution theorem for the Discrete Fourier Transform (DFT), the discrete eigenvalues are the DFT of the discrete covariance kernel: $\\hat{C}_h = \\mathcal{F}[C_h]$. The eigenvalue corresponding to mode $k$ is $\\lambda_k = \\hat{C}_{h,k}$. The application of the discrete operator $K_h$ to a grid function $f$ is defined as $(K_h f) = \\mathcal{F}^{-1}(\\mathcal{F}[C_h] \\cdot \\mathcal{F}[f])$.\n\n3.  **Numerical Verification**: To test the eigen-relation, we generate a discrete Fourier mode $\\phi_k(x_j)=e^{2\\pi i k \\cdot x_j}$ on the grid. We then compute $K_h\\phi_k$ using the FFT-based convolution. The result is compared against $\\lambda_k \\phi_k$, where $\\lambda_k$ is the $k$-th component of $\\mathcal{F}[C_h]$. The relative $\\ell^2$ error is calculated to quantify the agreement, which should be near machine precision.\n\n4.  **Gaussian Random Field Sampling**: A real-valued Gaussian random field $a(x)$ with zero mean and covariance $C$ is synthesized in Fourier space. The variance of the discrete Fourier coefficient $\\hat{a}_k$ is proportional to the eigenvalue $\\lambda_k$: $\\mathbb{E}[|\\hat{a}_k|^2] = N_{\\text{tot}}\\lambda_k$, where $N_{\\text{tot}}$ is the total number of grid points. To generate a real-valued field $a(x)$, its Fourier coefficients must satisfy Hermitian symmetry: $\\hat{a}_k = \\overline{\\hat{a}_{-k}}$. The algorithm generates complex Gaussian random variables for each unique frequency mode, scaled by $\\sqrt{N_{\\text{tot}}\\lambda_k}$, and enforces this symmetry. For self-conjugate modes (like $k=0$), the coefficient must be real and is sampled from a real normal distribution. The field $a(x)$ is then obtained by applying the inverse FFT.\n\n5.  **Periodic Helmholtz Solver**: The partial differential equation $(I - \\beta\\Delta)u = a$ on the torus is solved efficiently in Fourier space. aApplying the Fourier transform yields $(\\mathcal{F}[I] - \\beta\\mathcal{F}[\\Delta])\\hat{u} = \\hat{a}$. The symbol of the Laplacian operator $-\\Delta$ for a mode $k$ is $(2\\pi \\|k_{\\text{phys}}\\|)^2$, where $k_{\\text{phys}}$ is the physical wave vector. Thus, the equation in Fourier space becomes $(1 + \\beta(2\\pi \\|k_{\\text{phys}}\\|)^2)\\hat{u}_k = \\hat{a}_k$. The solution's Fourier coefficients are found by division: $\\hat{u}_k = \\hat{a}_k / (1 + \\beta(2\\pi \\|k_{\\text{phys}}\\|)^2)$. An inverse FFT on $\\hat{u}$ yields the solution $u(x)$. The residual is computed by applying the discrete operator back to the numerical solution $u$ and comparing it with the original right-hand side $a$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the five specified tests and print the results in the required format.\n    The problem asks for several numerical validations related to the Karhunen-Loève expansion\n    of a stationary random field on a periodic domain, and the solution of a PDE with such a field as input.\n    \"\"\"\n\n    def get_covariance_kernel(d, N_dims, model, sigma, ell):\n        \"\"\"\n        Constructs the discrete, periodic covariance kernel C_h on a grid.\n        \n        The kernel is arranged for use with FFT for circular convolution. This means\n        the spatial lags are centered around the origin with periodic boundary conditions.\n        \"\"\"\n        if d == 1:\n            N = N_dims\n            lags = np.arange(N, dtype=float) / N\n            lags[lags >= 0.5] -= 1.0  # Lags in [-0.5, 0.5)\n            r = np.abs(lags)\n        elif d == 2:\n            N1, N2 = N_dims\n            lags1 = np.arange(N1, dtype=float) / N1\n            lags1[lags1 >= 0.5] -= 1.0\n            lags2 = np.arange(N2, dtype=float) / N2\n            lags2[lags2 >= 0.5] -= 1.0\n            L1, L2 = np.meshgrid(lags1, lags2, indexing='ij')\n            r = np.sqrt(L1**2 + L2**2)\n        else:\n            raise ValueError(\"Dimension d must be 1 or 2.\")\n            \n        if model == 'G': # Gaussian covariance model\n            return sigma**2 * np.exp(-r**2 / (2 * ell**2))\n        elif model == 'E': # Exponential covariance model\n            return sigma**2 * np.exp(-r / ell)\n        else:\n            raise ValueError(\"Unknown covariance model.\")\n\n    def get_fourier_mode(d, N_dims, k):\n        \"\"\"\n        Generates a discrete spatial Fourier mode exp(2*pi*i*k.x) on the grid.\n        \"\"\"\n        if d == 1:\n            N = N_dims\n            x = np.arange(N, dtype=float) / N\n            return np.exp(2j * np.pi * k * x)\n        elif d == 2:\n            N1, N2 = N_dims\n            x1 = np.arange(N1, dtype=float) / N1\n            x2 = np.arange(N2, dtype=float) / N2\n            X1, X2 = np.meshgrid(x1, x2, indexing='ij')\n            return np.exp(2j * np.pi * (k[0] * X1 + k[1] * X2))\n        else:\n            raise ValueError(\"Dimension d must be 1 or 2.\")\n            \n    def run_eigenmode_test(d, N_dims, model, sigma, ell, k):\n        \"\"\"\n        Performs the eigenmode consistency check for Tests 1, 2, and 3.\n        It computes ||K*phi_k - lambda_k*phi_k|| / ||lambda_k*phi_k||.\n        \"\"\"\n        C_h = get_covariance_kernel(d, N_dims, model, sigma, ell)\n        lambda_vals = np.fft.fftn(C_h)\n        \n        if d == 1:\n            lambda_k = lambda_vals[k]\n        else: # d == 2\n            lambda_k = lambda_vals[k[0], k[1]]\n            \n        phi_k = get_fourier_mode(d, N_dims, k)\n        \n        # As per problem statement, discrete operator K is defined via FFT\n        K_phi_k = np.fft.ifftn(lambda_vals * np.fft.fftn(phi_k))\n        target = lambda_k * phi_k\n        \n        err_norm = np.linalg.norm(K_phi_k - target)\n        target_norm = np.linalg.norm(target)\n        \n        # Avoid division by zero\n        if target_norm  1e-15:\n            return 0.0 if err_norm  1e-15 else np.inf\n        \n        return err_norm / target_norm\n\n    def sample_field(N1, N2, C_h, seed):\n        \"\"\"\n        Samples a real-valued Gaussian random field with a given covariance kernel C_h.\n        This is done by generating Fourier coefficients with appropriate variance and\n        Hermitian symmetry, then applying an inverse FFT.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        N_tot = N1 * N2\n        \n        lambda_vals = np.fft.fftn(C_h)\n        # Variance of Fourier coefficient k is N_tot * lambda_k\n        variances = N_tot * np.maximum(0, np.real(lambda_vals))\n        \n        hat_a = np.zeros((N1, N2), dtype=np.complex128)\n        \n        # Loop over half the frequency plane and enforce Hermitian symmetry\n        for i in range(N1):\n            for j in range(N2):\n                kp_i, kp_j = (-i % N1), (-j % N2)\n\n                if (i, j) > (kp_i, kp_j):\n                    continue\n                \n                var = variances[i, j]\n                if var  1e-30: continue\n                std_dev = np.sqrt(var)\n\n                if (i, j) == (kp_i, kp_j):  # Self-conjugate modes must be real\n                    hat_a[i, j] = rng.normal(scale=std_dev)\n                else:  # Paired modes are complex conjugates\n                    std_dev_half = np.sqrt(var / 2.0)\n                    val = (rng.normal(scale=std_dev_half) + \n                           1j * rng.normal(scale=std_dev_half))\n                    hat_a[i, j] = val\n                    hat_a[kp_i, kp_j] = np.conj(val)\n\n        a = np.fft.ifftn(hat_a)\n        return a\n\n    def solve_helmholtz_and_get_residual(N1, N2, beta, a):\n        \"\"\"\n        Solves the Helmholtz equation (I - beta*Delta)u = a using Fourier diagonalization\n        and computes the relative residual norm.\n        \"\"\"\n        hat_a = np.fft.fftn(a)\n        \n        # Physical frequencies corresponding to FFT indices\n        freqs1 = np.fft.fftfreq(N1, d=1.0/N1)\n        freqs2 = np.fft.fftfreq(N2, d=1.0/N2)\n        K1, K2 = np.meshgrid(freqs1, freqs2, indexing='ij')\n        K_norm_sq = K1**2 + K2**2\n        \n        # Fourier symbol of the operator (I - beta * Delta)\n        M = 1.0 + beta * (2 * np.pi)**2 * K_norm_sq\n        \n        hat_u = hat_a / M\n        u = np.fft.ifftn(hat_u)\n        \n        # To compute residual, apply operator to numerical solution `u`\n        Au = np.fft.ifftn(M * np.fft.fftn(u))\n        residual = Au - a\n        \n        res_norm = np.linalg.norm(residual)\n        a_norm = np.linalg.norm(a)\n        \n        if a_norm  1e-15:\n            return 0.0 if res_norm  1e-15 else np.inf\n            \n        return res_norm / a_norm\n\n    results = []\n\n    # Test 1: 1D Gaussian eigenmode consistency\n    results.append(run_eigenmode_test(d=1, N_dims=64, model='G', sigma=1, ell=0.12, k=3))\n    \n    # Test 2: 1D Exponential eigenmode consistency\n    results.append(run_eigenmode_test(d=1, N_dims=64, model='E', sigma=1, ell=0.20, k=5))\n    \n    # Test 3: 2D Gaussian eigenmode consistency\n    results.append(run_eigenmode_test(d=2, N_dims=(32,32), model='G', sigma=1, ell=0.15, k=(2,3)))\n    \n    # Common setup for Tests 4 and 5\n    d_T4, N_dims_T4, model_T4, sigma_T4, ell_T4 = 2, (32,32), 'G', 1, 0.15\n    seed_T4 = 12345\n    C_h_T4 = get_covariance_kernel(d_T4, N_dims_T4, model_T4, sigma_T4, ell_T4)\n    a_field = sample_field(N_dims_T4[0], N_dims_T4[1], C_h_T4, seed_T4)\n    \n    # Test 4: Realness check of the sampled field\n    results.append(np.max(np.abs(np.imag(a_field))))\n    \n    # Test 5: Relative residual of the Helmholtz solver\n    beta_T5 = 0.01\n    results.append(solve_helmholtz_and_get_residual(N_dims_T4[0], N_dims_T4[1], beta_T5, a_field))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond the special structure of periodic domains, we now tackle the problem of computing KL expansions on general bounded domains. For certain widely-used covariance functions, such as the exponential kernel, the integral eigenvalue problem can be transformed into a more tractable differential Sturm-Liouville problem. This practice  challenges you to first derive this equivalence from basic principles and then to implement and contrast two powerful numerical strategies for finding the eigenpairs: a Nyström method for the original integral operator and a Finite Element Method for the derived differential form.",
            "id": "3413105",
            "problem": "Consider the one-dimensional domain $D=(0,L)$ with $L0$ and a centered, mean-square continuous random field whose covariance kernel is $C(x,y)=\\exp(-\\alpha\\lvert x-y\\rvert)$ with $\\alpha0$. The Karhunen–Loève (KL) expansion of this random field is governed by the integral eigenvalue problem for the covariance operator, understood as a compact, self-adjoint operator on $L^2(0,L)$.\n\nTask A (Derivation). Starting from the definitions of a covariance operator and eigenpairs $(\\lambda,\\phi)$ satisfying the integral equation\n$$\n\\int_0^L C(x,y)\\,\\phi(y)\\,dy = \\lambda\\,\\phi(x),\\quad x\\in (0,L),\n$$\nand using only fundamental facts from calculus and functional analysis (e.g., differentiation under the integral sign, properties of absolute values, and linear operators), derive the equivalent differential formulation in $(0,L)$ for the eigenfunctions $\\phi$. Show that $\\phi$ satisfies a second-order Sturm–Liouville (SL) boundary value problem with Robin-type boundary conditions, and explicitly identify how the differential eigenvalue parameter is related to the integral eigenvalue $\\lambda$. Do not assume any shortcut formulas beyond these fundamentals, and ensure each step is justified from first principles.\n\nTask B (Numerical spectral approximation). Implement a spectral discretization of the covariance operator using Gauss–Legendre (GL) quadrature with $N_q$ quadrature points on $(0,L)$. Approximate the integral operator by a symmetric matrix constructed from the quadrature nodes and weights and compute the largest $m$ eigenvalues $\\{\\lambda_n\\}_{n=1}^m$ (ordered from largest to smallest) that approximate the KL eigenvalues.\n\nTask C (Finite element approximation via the Sturm–Liouville form). Using the differential formulation from Task A, implement a conforming linear Finite Element Method (FEM) on a uniform mesh with $N_e$ elements on $(0,L)$. Assemble the stiffness and mass matrices corresponding to the weak form of the SL operator, incorporate the Robin-type boundary terms consistently in the bilinear form, and solve the resulting generalized symmetric eigenvalue problem to obtain the smallest $m$ differential eigenvalues $\\{\\mu_n\\}_{n=1}^m$. Convert these to KL eigenvalues via the relation you derived in Task A to obtain $\\{\\lambda_n^{\\mathrm{FEM}}\\}_{n=1}^m$, ordered from largest to smallest.\n\nTask D (Comparison metric and test suite). For each parameter set $(L,\\alpha,N_q,N_e,m)$, compute the largest $m$ KL eigenvalues spectrally, $\\{\\lambda_n^{\\mathrm{spec}}\\}_{n=1}^m$, and via the finite element route, $\\{\\lambda_n^{\\mathrm{FEM}}\\}_{n=1}^m$. Define the relative discrepancy\n$$\nr = \\max_{1\\le n\\le m}\\frac{\\lvert \\lambda_n^{\\mathrm{spec}}-\\lambda_n^{\\mathrm{FEM}}\\rvert}{\\lvert \\lambda_n^{\\mathrm{spec}}\\rvert}.\n$$\nYour program must evaluate $r$ for each of the following three test cases:\n- Case $1$: $(L,\\alpha,N_q,N_e,m)=(1.0,1.0,120,300,5)$.\n- Case $2$: $(L,\\alpha,N_q,N_e,m)=(2.0,0.5,160,300,5)$.\n- Case $3$: $(L,\\alpha,N_q,N_e,m)=(0.7,5.0,200,350,5)$.\n\nRequired final output. Your program should produce a single line of output containing the three values of $r$ for the cases above, as a comma-separated list enclosed in square brackets, with each value rounded to $8$ decimal places (for example, $[0.00000123,0.00000456,0.00000789]$). No other output should be produced.\n\nNotes:\n- All symbols, variables, functions, operators, and numbers appearing in your derivation and reasoning must be presented using standard mathematical notation.\n- No physical units are involved in this problem.\n- Angles are not used in this problem.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the theory of stochastic processes and numerical analysis, specifically concerning the Karhunen-Loève expansion and its numerical approximation. The problem is well-posed, self-contained, and all data, definitions, and tasks are specified with mathematical precision, allowing for a unique and meaningful solution. There are no contradictions, ambiguities, or factual inaccuracies.\n\n### Task A: Derivation of the Sturm-Liouville Formulation\n\nWe begin with the integral eigenvalue problem defined on the domain $D=(0,L)$:\n$$\n\\lambda\\,\\phi(x) = \\int_0^L C(x,y)\\,\\phi(y)\\,dy\n$$\nwhere the covariance kernel is $C(x,y) = \\exp(-\\alpha|x-y|)$ for $\\alpha  0$. The task is to derive an equivalent differential eigenvalue problem.\n\nFirst, we split the integral at $y=x$ to handle the absolute value term $|x-y|$:\n$$\n\\lambda\\,\\phi(x) = \\int_0^x e^{-\\alpha(x-y)}\\,\\phi(y)\\,dy + \\int_x^L e^{-\\alpha(y-x)}\\,\\phi(y)\\,dy\n$$\nWe can rewrite this by factoring out the terms dependent on $x$:\n$$\n\\lambda\\,\\phi(x) = e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy + e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy\n$$\nTo convert this integral equation into a differential equation, we differentiate with respect to $x$. We apply the Leibniz integral rule, which states that for an integral of the form $I(x) = \\int_{a(x)}^{b(x)} f(x,t)\\,dt$, its derivative is $I'(x) = \\int_{a(x)}^{b(x)} \\frac{\\partial f}{\\partial x}\\,dt + f(x, b(x)) \\frac{db}{dx} - f(x, a(x)) \\frac{da}{dx}$.\n\nDifferentiating the equation for $\\lambda\\,\\phi(x)$ term by term yields:\n$$\n\\lambda\\,\\phi'(x) = \\left[ -\\alpha e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy + e^{-\\alpha x} \\cdot (e^{\\alpha x}\\,\\phi(x)) \\right] + \\left[ \\alpha e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy - e^{\\alpha x} \\cdot (e^{-\\alpha x}\\,\\phi(x)) \\right]\n$$\nThe boundary evaluation terms $e^{-\\alpha x} \\cdot (e^{\\alpha x}\\,\\phi(x))$ and $-e^{\\alpha x} \\cdot (e^{-\\alpha x}\\,\\phi(x))$ simplify to $\\phi(x)$ and $-\\phi(x)$ respectively, which cancel each other out. This leaves:\n$$\n\\lambda\\,\\phi'(x) = -\\alpha e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy + \\alpha e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy\n$$\nWe differentiate a second time with respect to $x$, again applying the Leibniz rule:\n$$\n\\lambda\\,\\phi''(x) = -\\alpha \\left[ -\\alpha e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy + e^{-\\alpha x} \\cdot (e^{\\alpha x}\\phi(x)) \\right] + \\alpha \\left[ \\alpha e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy - e^{\\alpha x} \\cdot (e^{-\\alpha x}\\phi(x)) \\right]\n$$\nSimplifying the terms:\n$$\n\\lambda\\,\\phi''(x) = \\alpha^2 e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy - \\alpha\\phi(x) + \\alpha^2 e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy - \\alpha\\phi(x)\n$$\n$$\n\\lambda\\,\\phi''(x) = \\alpha^2 \\left( e^{-\\alpha x} \\int_0^x e^{\\alpha y}\\,\\phi(y)\\,dy + e^{\\alpha x} \\int_x^L e^{-\\alpha y}\\,\\phi(y)\\,dy \\right) - 2\\alpha\\phi(x)\n$$\nWe recognize the expression in the parenthesis as the original integral representation of $\\lambda\\,\\phi(x)$. Substituting this back, we get:\n$$\n\\lambda\\,\\phi''(x) = \\alpha^2 (\\lambda\\,\\phi(x)) - 2\\alpha\\phi(x)\n$$\nAssuming $\\lambda \\neq 0$ (which is guaranteed since the kernel is positive definite), we can rearrange the equation:\n$$\n\\phi''(x) - \\alpha^2\\phi(x) = -\\frac{2\\alpha}{\\lambda}\\phi(x)\n$$\n$$\n\\phi''(x) + \\left(\\frac{2\\alpha}{\\lambda} - \\alpha^2\\right)\\phi(x) = 0\n$$\nThis is a second-order ordinary differential equation. We can write it in the standard Sturm-Liouville form $-\\phi''(x) = \\mu\\,\\phi(x)$, where $\\mu$ is the differential eigenvalue defined as:\n$$\n\\mu = \\frac{2\\alpha}{\\lambda} - \\alpha^2\n$$\nConversely, the integral eigenvalue $\\lambda$ is related to the differential eigenvalue $\\mu$ by:\n$$\n\\lambda = \\frac{2\\alpha}{\\mu + \\alpha^2}\n$$\nNext, we derive the boundary conditions. We evaluate the expressions for $\\lambda\\,\\phi(x)$ and $\\lambda\\,\\phi'(x)$ at the boundaries $x=0$ and $x=L$.\nAt $x=0$:\n$$\n\\lambda\\,\\phi(0) = \\int_0^L e^{-\\alpha y}\\,\\phi(y)\\,dy\n$$\n$$\n\\lambda\\,\\phi'(0) = -\\alpha \\int_0^0 (\\dots)\\,dy + \\alpha \\int_0^L e^{-\\alpha y}\\,\\phi(y)\\,dy = \\alpha \\int_0^L e^{-\\alpha y}\\,\\phi(y)\\,dy\n$$\nComparing these two equations, we find $\\lambda\\,\\phi'(0) = \\alpha(\\lambda\\,\\phi(0))$, which for $\\lambda \\neq 0$ implies the Robin-type boundary condition:\n$$\n\\phi'(0) - \\alpha\\,\\phi(0) = 0\n$$\nAt $x=L$:\n$$\n\\lambda\\,\\phi(L) = e^{-\\alpha L} \\int_0^L e^{\\alpha y}\\,\\phi(y)\\,dy\n$$\n$$\n\\lambda\\,\\phi'(L) = -\\alpha e^{-\\alpha L} \\int_0^L e^{\\alpha y}\\,\\phi(y)\\,dy - \\alpha \\int_L^L (\\dots)\\,dy = -\\alpha e^{-\\alpha L} \\int_0^L e^{\\alpha y}\\,\\phi(y)\\,dy\n$$\nComparing these gives $\\lambda\\,\\phi'(L) = -\\alpha(\\lambda\\,\\phi(L))$, which yields the second boundary condition:\n$$\n\\phi'(L) + \\alpha\\,\\phi(L) = 0\n$$\nIn summary, the eigenfunction $\\phi(x)$ satisfies the Sturm-Liouville boundary value problem:\n$$\n-\\phi''(x) = \\mu\\,\\phi(x), \\quad x \\in (0,L)\n$$\n$$\n\\text{BCs: } \\phi'(0) - \\alpha\\,\\phi(0) = 0, \\quad \\phi'(L) + \\alpha\\,\\phi(L) = 0\n$$\n\n### Task B: Numerical Spectral Approximation\n\nThe integral eigenvalue problem $\\int_0^L C(x,y)\\phi(y)dy = \\lambda\\phi(x)$ is approximated using Gauss-Legendre quadrature with $N_q$ points. Let $\\{y_j, w_j\\}_{j=1}^{N_q}$ be the quadrature nodes and weights on the interval $[-1,1]$. These are mapped to the domain $(0,L)$ via the affine transformation $x_j' = \\frac{L}{2}(y_j+1)$ and $w_j' = \\frac{L}{2}w_j$. The integral equation at each node $x_i'$ is discretized as:\n$$\n\\sum_{j=1}^{N_q} C(x_i', x_j')\\,\\phi(x_j')\\,w_j' \\approx \\lambda\\,\\phi(x_i')\n$$\nTo formulate this as a symmetric matrix eigenvalue problem, we define a new vector $\\psi_j = \\sqrt{w_j'}\\,\\phi(x_j')$. Substituting $\\phi(x_j') = \\psi_j/\\sqrt{w_j'}$ into the discretized equation and multiplying by $\\sqrt{w_i'}$ gives:\n$$\n\\sum_{j=1}^{N_q} \\sqrt{w_i'} C(x_i', x_j') \\sqrt{w_j'}\\,\\psi_j \\approx \\lambda\\,\\psi_i\n$$\nThis is a standard symmetric eigenvalue problem $A\\mathbf{\\psi} = \\lambda\\mathbf{\\psi}$, where the matrix $A$ has entries $A_{ij} = \\sqrt{w_i'} C(x_i', x_j') \\sqrt{w_j'}$. The eigenvalues of this matrix $A$ provide the approximations $\\{\\lambda_n^{\\mathrm{spec}}\\}$ to the true KL eigenvalues. Since the KL eigenvalues are conventionally ordered from largest to smallest, we compute all eigenvalues of $A$ and select the $m$ largest values.\n\n### Task C: Finite Element Approximation\n\nThe FEM is applied to the Sturm-Liouville problem derived in Task A. The weak formulation is found by multiplying the differential equation $-\\phi'' = \\mu\\phi$ by a test function $v \\in H^1(0,L)$ and integrating over $(0,L)$:\n$$\n-\\int_0^L \\phi''(x)v(x)\\,dx = \\mu \\int_0^L \\phi(x)v(x)\\,dx\n$$\nApplying integration by parts to the left-hand side:\n$$\n\\int_0^L \\phi'(x)v'(x)\\,dx - [\\phi'(x)v(x)]_0^L = \\mu \\int_0^L \\phi(x)v(x)\\,dx\n$$\nWe substitute the Robin boundary conditions $\\phi'(0)=\\alpha\\phi(0)$ and $\\phi'(L)=-\\alpha\\phi(L)$ into the boundary term:\n$$\n[\\phi'(x)v(x)]_0^L = \\phi'(L)v(L) - \\phi'(0)v(0) = -\\alpha\\phi(L)v(L) - \\alpha\\phi(0)v(0)\n$$\nThe weak form is then: Find $\\phi \\in H^1(0,L)$ such that for all $v \\in H^1(0,L)$,\n$$\n\\int_0^L \\phi'(x)v'(x)\\,dx + \\alpha\\phi(0)v(0) + \\alpha\\phi(L)v(L) = \\mu \\int_0^L \\phi(x)v(x)\\,dx\n$$\nThis defines the stiffness bilinear form $a(\\phi,v) = \\int_0^L \\phi'v'\\,dx + \\alpha\\phi(0)v(0) + \\alpha\\phi(L)v(L)$ and the mass bilinear form $b(\\phi,v) = \\int_0^L \\phi v\\,dx$.\nWe discretize the domain $(0,L)$ with $N_e$ uniform linear elements of size $h=L/N_e$, yielding $N_e+1$ nodes. Using the standard linear \"hat\" basis functions $N_i(x)$, we approximate $\\phi(x) \\approx \\sum_{j=0}^{N_e} u_j N_j(x)$ and set $v(x) = N_i(x)$. This leads to the generalized matrix eigenvalue problem $K\\mathbf{u} = \\mu M\\mathbf{u}$, where the entries of the stiffness matrix $K$ and mass matrix $M$ are $K_{ij} = a(N_j, N_i)$ and $M_{ij} = b(N_j, N_i)$. The standard local element stiffness matrix is $\\frac{1}{h}\\begin{psmallmatrix} 1  -1 \\\\ -1  1 \\end{psmallmatrix}$ and the local mass matrix is $\\frac{h}{6}\\begin{psmallmatrix} 2  1 \\\\ 1  2 \\end{psmallmatrix}$. The boundary term $\\alpha\\phi(0)v(0) + \\alpha\\phi(L)v(L)$ exclusively contributes to the diagonal entries $K_{0,0}$ and $K_{N_e, N_e}$ of the global stiffness matrix, adding a value of $\\alpha$ to each.\nWe solve this generalized eigenvalue problem for the smallest $m$ eigenvalues $\\{\\mu_n\\}_{n=1}^m$. These are then converted to the KL eigenvalues using the derived relation: $\\lambda_n^{\\mathrm{FEM}} = \\frac{2\\alpha}{\\mu_n + \\alpha^2}$. Because $\\mu_n$ are ordered smallest to largest, the resulting $\\lambda_n^{\\mathrm{FEM}}$ will be correctly ordered largest to smallest.\n\n### Task D: Comparison Metric\n\nFor each test case, the largest $m$ eigenvalues from the spectral method, $\\{\\lambda_n^{\\mathrm{spec}}\\}_{n=1}^m$, and the finite element method, $\\{\\lambda_n^{\\mathrm{FEM}}\\}_{n=1}^m$, are computed. The relative discrepancy $r$ is calculated as the maximum relative error across the top $m$ eigenvalues:\n$$\nr = \\max_{1\\le n\\le m}\\frac{\\lvert \\lambda_n^{\\mathrm{spec}}-\\lambda_n^{\\mathrm{FEM}}\\rvert}{\\lvert \\lambda_n^{\\mathrm{spec}}\\rvert}\n$$\nThe program will evaluate and report this value for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom numpy.polynomial.legendre import leggauss\n\ndef compute_spectral_eigenvalues(L, alpha, N_q, m):\n    \"\"\"\n    Computes KL eigenvalues using a spectral (Nyström) method.\n    Discretizes the integral operator with Gauss-Legendre quadrature.\n    \"\"\"\n    # 1. Get Gauss-Legendre nodes and weights for [-1, 1]\n    nodes, weights = leggauss(N_q)\n\n    # 2. Map nodes and weights to [0, L]\n    x_gl = L * (nodes + 1.0) / 2.0\n    w_gl = L * weights / 2.0\n\n    # 3. Construct the covariance matrix C(x_i, x_j)\n    x_diff = x_gl[:, None] - x_gl[None, :]\n    cov_matrix = np.exp(-alpha * np.abs(x_diff))\n\n    # 4. Symmetrize the matrix for the eigenvalue problem\n    sqrt_w = np.sqrt(w_gl)\n    symm_matrix = sqrt_w[:, None] * cov_matrix * sqrt_w[None, :]\n\n    # 5. Solve for eigenvalues. eigh returns them in ascending order.\n    eigenvalues = eigh(symm_matrix, eigvals_only=True)\n\n    # 6. Return the largest m eigenvalues, sorted in descending order.\n    return eigenvalues[-m:][::-1]\n\ndef compute_fem_eigenvalues(L, alpha, N_e, m):\n    \"\"\"\n    Computes KL eigenvalues via the Sturm-Liouville FEM formulation.\n    \"\"\"\n    # 1. Setup mesh parameters\n    h = L / N_e\n    num_nodes = N_e + 1\n\n    # 2. Assemble global mass matrix M (for linear elements)\n    diag_M = np.full(num_nodes, 2.0 * h / 3.0)\n    diag_M[0] = diag_M[-1] = h / 3.0\n    offdiag_M = np.full(num_nodes - 1, h / 6.0)\n    M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n    \n    # 3. Assemble global stiffness matrix K (for linear elements)\n    diag_K = np.full(num_nodes, 2.0 / h)\n    diag_K[0] = diag_K[-1] = 1.0 / h\n    offdiag_K = np.full(num_nodes - 1, -1.0 / h)\n    K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n\n    # 4. Incorporate Robin boundary conditions\n    K[0, 0] += alpha\n    K[-1, -1] += alpha\n\n    # 5. Solve the generalized eigenvalue problem K*u = mu*M*u\n    # eigh returns differential eigenvalues (mu) in ascending order.\n    mu_values = eigh(K, M, eigvals_only=True)\n\n    # 6. We need the smallest m differential eigenvalues\n    mu_m = mu_values[:m]\n\n    # 7. Convert differential eigenvalues (mu) to KL eigenvalues (lambda)\n    # The relation is lambda = 2*alpha / (mu + alpha^2)\n    # Since mu_m is sorted ascending, lambda_fem will be sorted descending.\n    lambda_fem = (2.0 * alpha) / (mu_m + alpha**2)\n    \n    return lambda_fem\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, N_q, N_e, m)\n        (1.0, 1.0, 120, 300, 5),\n        (2.0, 0.5, 160, 300, 5),\n        (0.7, 5.0, 200, 350, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, N_q, N_e, m = case\n\n        # Compute eigenvalues using both methods\n        lambda_spec = compute_spectral_eigenvalues(L, alpha, N_q, m)\n        lambda_fem = compute_fem_eigenvalues(L, alpha, N_e, m)\n\n        # Calculate the relative discrepancy\n        relative_errors = np.abs(lambda_spec - lambda_fem) / np.abs(lambda_spec)\n        max_discrepancy = np.max(relative_errors)\n        \n        # Store result formatted to 8 decimal places\n        results.append(f\"{max_discrepancy:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After mastering the implementation of numerical methods for KL expansions, a critical next step is to analyze their accuracy. This final practice shifts our focus from computation to a priori error analysis, using the tools of functional analysis and operator perturbation theory. By working through this problem , you will derive explicit bounds that connect numerical parameters, like mesh size and quadrature order, to the resulting errors in the computed eigenvalues and eigenfunctions, and ultimately see how these errors propagate into a downstream uncertainty quantification problem.",
            "id": "3413059",
            "problem": "Let $D \\subset \\mathbb{R}^{d}$ be a bounded Lipschitz domain and let $k : D \\times D \\to \\mathbb{R}$ be a symmetric, positive semi-definite kernel with $k \\in W^{s,\\infty}(D \\times D)$ for some integer $s \\geq 2$. Define the covariance operator $C : L^{2}(D) \\to L^{2}(D)$ by\n$$\n(C f)(x) = \\int_{D} k(x,y) f(y) \\, dy.\n$$\nAssume $C$ is compact, self-adjoint, and nonnegative. Let $\\{ \\lambda_{n}, \\phi_{n} \\}_{n \\geq 1}$ denote its eigenpairs, with eigenvalues ordered as $\\lambda_{1} \\geq \\lambda_{2} \\geq \\cdots \\geq 0$ and $\\{ \\phi_{n} \\}$ forming an orthonormal basis of $L^{2}(D)$. Suppose $\\lambda_{n}$ is simple and isolated with spectral gap\n$$\n\\mathrm{gap}_{n} = \\min\\{ \\lambda_{n-1} - \\lambda_{n}, \\lambda_{n} - \\lambda_{n+1} \\}  0,\n$$\nwith the convention $\\lambda_{0} = +\\infty$ if $n=1$.\n\nLet $V_{h} \\subset L^{2}(D)$ be a finite element space of piecewise polynomials of degree $p \\geq 1$ on a quasi-uniform, shape-regular mesh of size $h  0$. Consider the Galerkin discretization of the eigenproblem for $C$ in $V_{h}$, where the bilinear form\n$$\nb(u,v) = \\int_{D} \\int_{D} k(x,y) u(y) v(x) \\, dy \\, dx\n$$\nis approximated elementwise by a quadrature rule that is exact for polynomials up to degree $q \\geq 1$ on each pair of elements. Denote the resulting quadrature-based discrete operator by $C_{h,q}$, and its $n$-th discrete eigenpair by $\\{ \\lambda_{n}^{h,q}, \\phi_{n}^{h,q} \\in V_{h} \\}$, normalized in $L^{2}(D)$. Assume a spectral pollution parameter $\\delta_{\\mathrm{spec}} \\in [0,\\mathrm{gap}_{n})$ that quantifies the worst-case proximity of spurious discrete eigenvalues or unresolved clusters near $\\lambda_{n}$, so that the effective gap available for perturbation bounds is $\\mathrm{gap}_{n} - \\delta_{\\mathrm{spec}}$.\n\nAssume standard finite element approximation properties and quadrature consistency: there exist mesh- and kernel-regularity dependent positive constants $c_{\\mathrm{approx}}$ and $c_{\\mathrm{quad}}$, independent of $h$ and $q$, such that the operator-norm discretization error satisfies\n$$\n\\| C - C_{h,q} \\|_{L^{2}(D) \\to L^{2}(D)} \\leq c_{\\mathrm{approx}} h^{p+1} + c_{\\mathrm{quad}} h^{q+1}.\n$$\nDefine the shorthand\n$$\n\\varepsilon(h,q) = c_{\\mathrm{approx}} h^{p+1} + c_{\\mathrm{quad}} h^{q+1}.\n$$\n\nNext, consider a linear elliptic partial differential equation with random coefficient for uncertainty quantification: find $u(\\cdot,\\omega) \\in H^{1}_{0}(D)$ such that\n$$\n- \\nabla \\cdot \\big( a(x,\\omega) \\nabla u(x,\\omega) \\big) = f(x) \\quad \\text{in } D, \\qquad u(\\cdot,\\omega)\\big|_{\\partial D} = 0,\n$$\nwith deterministic $f \\in H^{-1}(D)$ and uniformly elliptic, bounded baseline $a_{0} \\in L^{\\infty}(D)$ satisfying $0  a_{\\min} \\leq a_{0}(x) \\leq a_{\\max}  \\infty$. The random perturbation is given by a truncated Karhunen–Loève (KL) expansion\n$$\na(x,\\omega) = a_{0}(x) + \\epsilon \\sum_{j=1}^{N} \\sqrt{\\lambda_{j}} \\, \\xi_{j}(\\omega) \\, \\phi_{j}(x),\n$$\nwhere $\\epsilon  0$ is a fixed amplitude parameter and $\\{ \\xi_{j} \\}_{j=1}^{N}$ are independent standard normal random variables. The numerical model uses the discrete eigenpairs in the truncated KL expansion,\n$$\na^{h,q}(x,\\omega) = a_{0}(x) + \\epsilon \\sum_{j=1}^{N} \\sqrt{\\lambda_{j}^{h,q}} \\, \\xi_{j}(\\omega) \\, \\phi_{j}^{h,q}(x).\n$$\nAssume the solution operator mapping $a \\mapsto u$ is Lipschitz from $L^{2}(D)$ into $H^{1}_{0}(D)$ with constant $c_{\\mathrm{map}}  0$, i.e.,\n$$\n\\big\\| u(\\cdot;\\,a) - u(\\cdot;\\,a') \\big\\|_{H^{1}_{0}(D)} \\leq c_{\\mathrm{map}} \\, \\| a - a' \\|_{L^{2}(D)} \\quad \\text{for all admissible } a,a'.\n$$\nLet $\\lambda_{*} = \\min_{1 \\leq j \\leq N} \\lambda_{j}  0$ and $g_{*} = \\min_{1 \\leq j \\leq N} \\big( \\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}} \\big)  0$.\n\nStarting from the spectral theory of compact self-adjoint operators, Galerkin finite element approximation properties, and classical perturbation bounds for invariant subspaces, derive explicit analytic expressions for:\n1) An upper bound for the eigenvalue error of the $n$-th mode, expressed in terms of $\\varepsilon(h,q)$.\n2) An upper bound for the $L^{2}(D)$-norm of the eigenfunction error of the $n$-th mode, expressed in terms of $\\varepsilon(h,q)$ and the effective gap $\\mathrm{gap}_{n} - \\delta_{\\mathrm{spec}}$.\n3) An upper bound for the root-mean-square $H^{1}_{0}(D)$-error between $u(\\cdot,\\omega)$ and $u^{h,q}(\\cdot,\\omega)$, expressed in terms of $\\varepsilon(h,q)$, $c_{\\mathrm{map}}$, $\\epsilon$, and the set $\\{ \\lambda_{j} \\}_{j=1}^{N}$ together with $\\lambda_{*}$ and $g_{*}$.\n\nYour final answer must be the analytic expressions of these three bounds, presented as a single row vector. Do not include inequalities or equations in the final answer; only present the three bound expressions themselves as closed-form expressions that a reader can evaluate symbolically. No rounding is required.",
            "solution": "The problem is evaluated as valid as it is scientifically grounded, well-posed, and objective, situated within the standard mathematical frameworks of functional analysis, numerical analysis, and uncertainty quantification. All necessary components for a rigorous derivation are provided.\n\nThe problem asks for three distinct upper bounds related to the Galerkin finite element approximation of the eigenproblem for a covariance operator and its application in a PDE with a random coefficient. Let $\\varepsilon(h,q) = c_{\\mathrm{approx}} h^{p+1} + c_{\\mathrm{quad}} h^{q+1}$ denote the provided bound on the operator norm of the discretization error, $\\|C - C_{h,q}\\|_{L^{2}(D) \\to L^{2}(D)} \\leq \\varepsilon(h,q)$.\n\n**1) Upper bound for the eigenvalue error $|\\lambda_{n} - \\lambda_{n}^{h,q}|$**\n\nThis bound is a direct consequence of Weyl's inequality for self-adjoint operators. Let $C$ and $C_{h,q}$ be two self-adjoint operators on $L^2(D)$. The Courant-Fischer-Weyl min-max principle states that for any $n \\geq 1$, the $n$-th eigenvalue $\\lambda_n$ of an operator $A$ can be characterized. A corollary is that if $A' = A+E$, then $|\\lambda_n(A) - \\lambda_n(A')| \\le \\|E\\|$.\n\nIn our case, we can set $A=C$ and $A'=C_{h,q}$. The perturbation is $E = C_{h,q} - C$. The problem provides the operator-norm bound $\\|E\\|_{L^{2}(D) \\to L^{2}(D)} \\leq \\varepsilon(h,q)$.\nApplying the inequality directly yields the bound on the eigenvalue error:\n$$\n|\\lambda_{n} - \\lambda_{n}^{h,q}| \\leq \\|C - C_{h,q}\\|_{L^{2}(D) \\to L^{2}(D)} \\leq \\varepsilon(h,q).\n$$\nThus, the first requested upper bound is $\\varepsilon(h,q)$.\n\n**2) Upper bound for the eigenfunction error $\\|\\phi_{n} - \\phi_{n}^{h,q}\\|_{L^2(D)}$**\n\nThis requires a perturbation bound for the invariant subspace, which for a simple eigenvalue corresponds to the eigenfunction. Let $\\theta_n$ be the angle between the true eigenfunction $\\phi_n$ and the discrete one $\\phi_n^{h,q}$. A standard result from perturbation theory, often a consequence of the Davis-Kahan theorems, bounds $\\sin\\theta_n$.\n\nLet's consider the residual of the approximate eigenpair with respect to the exact operator $C$. We have $C_{h,q}\\phi_{n}^{h,q} = \\lambda_{n}^{h,q}\\phi_{n}^{h,q}$.\nThen, $C\\phi_{n}^{h,q} - \\lambda_n \\phi_{n}^{h,q} = (C - C_{h,q})\\phi_{n}^{h,q} + (C_{h,q} - \\lambda_n)\\phi_{n}^{h,q} = (C - C_{h,q})\\phi_{n}^{h,q} + (\\lambda_{n}^{h,q} - \\lambda_n)\\phi_{n}^{h,q}$.\nCall this residual $R_n$. Its norm is bounded by:\n$$\n\\|R_n\\|_{L^2(D)} \\leq \\|C - C_{h,q}\\| \\|\\phi_{n}^{h,q}\\| + |\\lambda_{n}^{h,q} - \\lambda_n| \\|\\phi_{n}^{h,q}\\|.\n$$\nUsing $\\|\\phi_n^{h,q}\\|=1$ and the result from part 1, we get:\n$$\n\\|R_n\\|_{L^2(D)} \\leq \\varepsilon(h,q) + \\varepsilon(h,q) = 2\\varepsilon(h,q).\n$$\nThe component of $\\phi_{n}^{h,q}$ orthogonal to $\\phi_n$, denoted $\\delta_n$, can be bounded in terms of this residual. Let $P_n$ be the spectral projector onto the span of $\\phi_n$. Then $\\delta_n = (I-P_n)\\phi_n^{h,q}$. The sine of the angle between the functions is $\\|\\delta_n\\|_{L^2(D)} = \\sin\\theta_n$.\nA standard bound gives $\\sin\\theta_n \\le \\|R_n\\|_{L^2(D)} / (\\mathrm{gap}_n - |\\lambda_n - \\tilde{\\lambda}_n|)$ where $\\tilde{\\lambda}_n$ is the Rayleigh quotient. Using the effective gap provided, this simplifies to:\n$$\n\\sin\\theta_n \\leq \\frac{\\|R_n\\|_{L^2(D)}}{\\mathrm{gap}_{n} - \\delta_{\\mathrm{spec}}} \\leq \\frac{2\\varepsilon(h,q)}{\\mathrm{gap}_{n} - \\delta_{\\mathrm{spec}}}.\n$$\nThe problem asks for the bound on $\\|\\phi_{n} - \\phi_{n}^{h,q}\\|_{L^2(D)}$. Assuming an appropriate phase choice for $\\phi_n^{h,q}$ such that $(\\phi_n, \\phi_n^{h,q}) \\ge 0$, the error norm is related to the angle $\\theta_n$ by $\\|\\phi_{n} - \\phi_{n}^{h,q}\\|_{L^2(D)} = 2\\sin(\\theta_n/2)$.\nUsing the inequality $2\\sin(\\theta_n/2) \\leq \\sqrt{2} \\sin\\theta_n$ for $\\theta_n \\in [0, \\pi/2]$, we obtain:\n$$\n\\|\\phi_{n} - \\phi_{n}^{h,q}\\|_{L^2(D)} \\leq \\sqrt{2} \\sin\\theta_n \\leq \\frac{2\\sqrt{2}\\varepsilon(h,q)}{\\mathrm{gap}_{n} - \\delta_{\\mathrm{spec}}}.\n$$\nThis provides the second requested bound.\n\n**3) Upper bound for the root-mean-square $H^{1}_{0}(D)$-error**\n\nThe quantity to bound is $E = \\left( \\mathbb{E} \\left[ \\| u(\\cdot, \\omega) - u^{h,q}(\\cdot, \\omega) \\|_{H_0^1(D)}^2 \\right] \\right)^{1/2}$.\nUsing the provided Lipschitz continuity of the solution operator mapping the coefficient field $a$ to the solution $u$:\n$$\n\\| u(\\cdot, \\omega) - u^{h,q}(\\cdot, \\omega) \\|_{H_0^1(D)} \\leq c_{\\mathrm{map}} \\| a(\\cdot, \\omega) - a^{h,q}(\\cdot, \\omega) \\|_{L^2(D)}.\n$$\nSquaring both sides, taking the expectation, and then the square root yields:\n$$\nE \\leq c_{\\mathrm{map}} \\left( \\mathbb{E} \\left[ \\| a(\\cdot, \\omega) - a^{h,q}(\\cdot, \\omega) \\|_{L^2(D)}^2 \\right] \\right)^{1/2}.\n$$\nThe error in the coefficient field is:\n$$\na(\\cdot, \\omega) - a^{h,q}(\\cdot, \\omega) = \\epsilon \\sum_{j=1}^{N} \\xi_{j}(\\omega) \\left( \\sqrt{\\lambda_{j}} \\phi_{j}(x) - \\sqrt{\\lambda_{j}^{h,q}} \\phi_{j}^{h,q}(x) \\right).\n$$\nLet $e_j(x) = \\sqrt{\\lambda_{j}} \\phi_{j}(x) - \\sqrt{\\lambda_{j}^{h,q}} \\phi_{j}^{h,q}(x)$. The squared $L^2(D)$-norm of the error is\n$$\n\\|a - a^{h,q}\\|_{L^2(D)}^2 = \\epsilon^2 \\left\\| \\sum_{j=1}^{N} \\xi_j(\\omega) e_j(x) \\right\\|_{L^2(D)}^2 = \\epsilon^2 \\sum_{j=1}^{N} \\sum_{k=1}^{N} \\xi_j(\\omega)\\xi_k(\\omega) (e_j, e_k)_{L^2(D)}.\n$$\nTaking the expectation and using the property that $\\mathbb{E}[\\xi_j \\xi_k] = \\delta_{jk}$ for i.i.d. standard normal variables, we get:\n$$\n\\mathbb{E}\\left[ \\|a - a^{h,q}\\|_{L^2(D)}^2 \\right] = \\epsilon^2 \\sum_{j=1}^{N} \\|e_j\\|_{L^2(D)}^2.\n$$\nWe bound $\\|e_j\\|_{L^2(D)}$ for each $j \\in \\{1, \\dots, N\\}$ using the triangle inequality:\n$$\n\\|e_j\\|_{L^2(D)} = \\|\\sqrt{\\lambda_{j}} \\phi_{j} - \\sqrt{\\lambda_{j}^{h,q}} \\phi_{j}^{h,q}\\| \\leq \\|\\sqrt{\\lambda_{j}} (\\phi_{j} - \\phi_{j}^{h,q})\\| + \\|(\\sqrt{\\lambda_{j}} - \\sqrt{\\lambda_{j}^{h,q}}) \\phi_{j}^{h,q}\\|.\n$$\nThis simplifies to $\\|e_j\\|_{L^2(D)} \\leq \\sqrt{\\lambda_j} \\|\\phi_{j} - \\phi_{j}^{h,q}\\| + |\\sqrt{\\lambda_{j}} - \\sqrt{\\lambda_{j}^{h,q}}|$.\nWe use the bounds from parts 1 and 2. For the second term,\n$$\n|\\sqrt{\\lambda_{j}} - \\sqrt{\\lambda_{j}^{h,q}}| = \\frac{|\\lambda_{j} - \\lambda_{j}^{h,q}|}{\\sqrt{\\lambda_{j}} + \\sqrt{\\lambda_{j}^{h,q}}} \\leq \\frac{\\varepsilon(h,q)}{\\sqrt{\\lambda_{j}}},\n$$\nwhere we used $|\\lambda_{j} - \\lambda_{j}^{h,q}| \\leq \\varepsilon(h,q)$ and $\\sqrt{\\lambda_{j}} + \\sqrt{\\lambda_{j}^{h,q}} \\geq \\sqrt{\\lambda_{j}}$. The assumption $\\lambda_*  0$ ensures $\\lambda_j  0$.\nSubstituting the bounds for eigenfunction and eigenvalue errors:\n$$\n\\|e_j\\|_{L^2(D)} \\leq \\sqrt{\\lambda_j} \\left( \\frac{2\\sqrt{2}\\varepsilon(h,q)}{\\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}}} \\right) + \\frac{\\varepsilon(h,q)}{\\sqrt{\\lambda_j}} = \\varepsilon(h,q) \\left( \\frac{2\\sqrt{2}\\sqrt{\\lambda_j}}{\\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}}} + \\frac{1}{\\sqrt{\\lambda_j}} \\right).\n$$\nInserting this into the expression for the RMS error $E$:\n$$\nE \\leq c_{\\mathrm{map}} \\epsilon \\left( \\sum_{j=1}^{N} \\left[ \\varepsilon(h,q) \\left( \\frac{2\\sqrt{2}\\sqrt{\\lambda_j}}{\\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}}} + \\frac{1}{\\sqrt{\\lambda_j}} \\right) \\right]^2 \\right)^{1/2}.\n$$\nFactoring out $\\varepsilon(h,q)$ gives the final expression for the third bound:\n$$\nE \\leq c_{\\mathrm{map}} \\epsilon \\, \\varepsilon(h,q) \\left( \\sum_{j=1}^{N} \\left( \\frac{2\\sqrt{2}\\sqrt{\\lambda_j}}{\\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}}} + \\frac{1}{\\sqrt{\\lambda_j}} \\right)^2 \\right)^{1/2}.\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\varepsilon(h,q)  \\frac{2\\sqrt{2}\\varepsilon(h,q)}{\\mathrm{gap}_n - \\delta_{\\mathrm{spec}}}  c_{\\mathrm{map}} \\epsilon \\, \\varepsilon(h,q) \\left( \\sum_{j=1}^{N} \\left( \\frac{2\\sqrt{2}\\sqrt{\\lambda_j}}{\\mathrm{gap}_{j} - \\delta_{\\mathrm{spec}}} + \\frac{1}{\\sqrt{\\lambda_j}} \\right)^2 \\right)^{1/2} \\end{pmatrix}}\n$$"
        }
    ]
}