{
    "hands_on_practices": [
        {
            "introduction": "构建降阶模型的第一步是理解其数学基础。本练习将引导您完成一个核心过程：对一个参数化的椭圆型偏微分方程应用伽辽金投影（Galerkin projection），从而推导出其降阶线性系统 。通过这项实践，您将掌握从高维问题到低维表示的关键转化，并学习如何通过分析降阶算子的属性（如矫顽性）来确保模型的稳定性，这是任何可靠降阶模型的基石。",
            "id": "2593121",
            "problem": "考虑参数化对称椭圆变分问题：求解 $u(\\mu) \\in V$ 使得对于所有 $v \\in V$ 都有 $a_{\\mu}(u(\\mu),v) = f(v)$，其中 $V = H_{0}^{1}(0,\\pi)$ 且\n$$\na_{\\mu}(u,v) = \\int_{0}^{\\pi} \\left( \\mu \\, u'(x) v'(x) + u(x) v(x) \\right) \\,\\mathrm{d}x, \n\\qquad\nf(v) = \\int_{0}^{\\pi} g(x) v(x) \\,\\mathrm{d}x,\n$$\n其中参数 $\\mu \\in [\\mu_{\\min},\\mu_{\\max}]$ 且 $g(x) = \\sin(x)$。令一个基于投影的降阶模型(ROM)的试探空间为 $V_{r} = \\mathrm{span}\\{\\phi_{1},\\phi_{2}\\}$，其中 $\\phi_{1}(x) = \\sqrt{\\frac{2}{\\pi}} \\sin(x)$ 且 $\\phi_{2}(x) = \\sqrt{\\frac{2}{\\pi}} \\sin(2x)$。选择测试空间 $W_{r}$，并通过 $u_{r}(\\mu) = \\sum_{j=1}^{2} c_{j}(\\mu) \\phi_{j}$ 来近似 $u(\\mu)$。\n\n从弱形式和投影方法的定义出发，通过施加残差与 $W_{r}$ 正交的条件，推导出降阶线性系统 $A_{r}(\\mu) c(\\mu) = b_{r}(\\mu)$，其中 $c(\\mu) = (c_{1}(\\mu), c_{2}(\\mu))^{\\top}$。将 $A_{r}(\\mu)$ 和 $b_{r}(\\mu)$ 严格用双线性形式和线性形式表示，即对于 $W_{r}$ 的一组选定基 $\\{\\psi_{i}\\}_{i=1}^{2}$，$A_{r}(\\mu)_{ij} = a_{\\mu}(\\phi_{j},\\psi_{i})$ 且 $b_{r}(\\mu)_{i} = f(\\psi_{i})$。\n\n然后，设 $W_{r} = V_{r}$（伽辽金选择）并显式计算 $A_{r}(\\mu)$ 和 $b_{r}(\\mu)$。接下来，基于变分问题适定性的第一性原理，陈述双线性形式 $a_{\\mu}(\\cdot,\\cdot)$ 和相关空间需要满足何种条件，才能使得伽辽金降阶模型（即 $W_{r} = V_{r}$）对所有 $\\mu \\in [\\mu_{\\min},\\mu_{\\max}]$ 都是稳定的。\n\n最后，令 $V$ 上的范数为 $H^{1}$ 型范数\n$$\n\\|v\\|_{V}^{2} = \\int_{0}^{\\pi} \\left( |v'(x)|^{2} + |v(x)|^{2} \\right) \\,\\mathrm{d}x,\n$$\n并将参数限制在 $[\\mu_{\\min},\\mu_{\\max}] = \\left[\\frac{1}{2}, 2\\right]$。定义降阶矫顽常数\n$$\n\\alpha_{r}(\\mu) = \\inf_{0 \\neq v_{r} \\in V_{r}} \\frac{a_{\\mu}(v_{r},v_{r})}{\\|v_{r}\\|_{V}^{2}},\n$$\n及其一致对应项\n$$\n\\alpha_{r}^{\\star} = \\inf_{\\mu \\in [\\frac{1}{2},2]} \\alpha_{r}(\\mu).\n$$\n计算 $\\alpha_{r}^{\\star}$。你的最终答案必须是一个没有单位的实数，且无舍入要求。",
            "solution": "所给的问题陈述已经过验证，并被认定是有效的。它在科学上基于偏微分方程数值方法的理论，特别是针对参数化椭圆问题的基于投影的模型降阶。该问题是适定的、客观的、内部一致的，并包含其求解所需的所有必要信息。它没有违反任何基本原理，构成了该领域一个标准的、可验证的练习。因此，我们可以着手求解。\n\n问题要求找到弱形式的一个近似解 $u_{r}(\\mu) \\in V_{r}$：求解 $u(\\mu) \\in V$ 使得\n$$a_{\\mu}(u(\\mu),v) = f(v) \\quad \\forall v \\in V.$$\n该近似由 $u_{r}(\\mu) = \\sum_{j=1}^{2} c_{j}(\\mu) \\phi_{j}$ 给出，其中 $V_{r} = \\mathrm{span}\\{\\phi_{1}, \\phi_{2}\\}$。投影方法要求近似的残差与测试空间 $W_{r} = \\mathrm{span}\\{\\psi_{1}, \\psi_{2}\\}$ 正交。残差定义为 $R(v) = f(v) - a_{\\mu}(u_{r}(\\mu), v)$。因此正交性条件为\n$$a_{\\mu}(u_{r}(\\mu), \\psi_{i}) = f(\\psi_{i}), \\quad i = 1, 2.$$\n代入 $u_{r}(\\mu)$ 的表达式，并利用双线性形式 $a_{\\mu}(\\cdot, \\cdot)$ 在其第一个参数上的线性性质，我们得到\n$$a_{\\mu}\\left(\\sum_{j=1}^{2} c_{j}(\\mu) \\phi_{j}, \\psi_{i}\\right) = \\sum_{j=1}^{2} c_{j}(\\mu) a_{\\mu}(\\phi_{j}, \\psi_{i}) = f(\\psi_{i}), \\quad i=1, 2.$$\n这是一个关于未知系数 $c(\\mu) = (c_{1}(\\mu), c_{2}(\\mu))^{\\top}$ 的二元线性方程组。写成矩阵形式为 $A_{r}(\\mu) c(\\mu) = b_{r}(\\mu)$，其中矩阵项为 $(A_{r}(\\mu))_{ij} = a_{\\mu}(\\phi_{j}, \\psi_{i})$，向量项为 $(b_{r}(\\mu))_{i} = f(\\psi_{i})$。\n\n我们现在专门讨论伽辽金方法，其中测试空间与试探空间相同，$W_{r} = V_{r}$，这意味着我们选择 $\\psi_{i} = \\phi_{i}$。我们显式地计算降阶系统矩阵 $A_{r}(\\mu)$ 和向量 $b_{r}(\\mu)$。基函数为 $\\phi_{1}(x) = \\sqrt{\\frac{2}{\\pi}} \\sin(x)$ 和 $\\phi_{2}(x) = \\sqrt{\\frac{2}{\\pi}} \\sin(2x)$。它们的导数为 $\\phi_{1}'(x) = \\sqrt{\\frac{2}{\\pi}} \\cos(x)$ 和 $\\phi_{2}'(x) = 2\\sqrt{\\frac{2}{\\pi}} \\cos(2x)$。\n矩阵项为 $(A_{r}(\\mu))_{ij} = a_{\\mu}(\\phi_{j}, \\phi_{i}) = \\int_{0}^{\\pi} (\\mu \\phi_{j}'(x) \\phi_{i}'(x) + \\phi_{j}(x) \\phi_{i}(x)) \\,\\mathrm{d}x$。我们需要以下积分，这些积分可由三角函数在 $[0,\\pi]$ 上的性质得出：\n$$ \\int_{0}^{\\pi} \\sin(kx)\\sin(lx)\\,\\mathrm{d}x = \\frac{\\pi}{2}\\delta_{kl}, \\quad \\int_{0}^{\\pi} \\cos(kx)\\cos(lx)\\,\\mathrm{d}x = \\frac{\\pi}{2}\\delta_{kl} \\quad (k,l \\in \\{1,2\\}), $$\n$$ \\int_{0}^{\\pi} \\sin(x)\\sin(2x)\\,\\mathrm{d}x = 0, \\quad \\int_{0}^{\\pi} \\cos(x)\\cos(2x)\\,\\mathrm{d}x = 0. $$\n质量矩阵 $M_{ij} = \\int_{0}^{\\pi} \\phi_{i}(x)\\phi_{j}(x)\\,\\mathrm{d}x$：\n$M_{11} = \\frac{2}{\\pi}\\int_{0}^{\\pi}\\sin^2(x)\\,\\mathrm{d}x = 1$, $M_{22} = \\frac{2}{\\pi}\\int_{0}^{\\pi}\\sin^2(2x)\\,\\mathrm{d}x = 1$, $M_{12}=M_{21} = 0$。所以，$M = I$。\n刚度矩阵 $K_{ij} = \\int_{0}^{\\pi} \\phi_{i}'(x)\\phi_{j}'(x)\\,\\mathrm{d}x$：\n$K_{11} = \\frac{2}{\\pi}\\int_{0}^{\\pi}\\cos^2(x)\\,\\mathrm{d}x = 1$, $K_{22} = \\frac{2}{\\pi}\\int_{0}^{\\pi}(2\\cos(2x))^2\\,\\mathrm{d}x = \\frac{8}{\\pi}\\frac{\\pi}{2}=4$, $K_{12}=K_{21}=0$。\n因此，$A_{r}(\\mu) = \\mu K + M = \\mu \\begin{pmatrix} 1  0 \\\\ 0  4 \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} \\mu+1  0 \\\\ 0  4\\mu+1 \\end{pmatrix}$。\n\n向量项为 $(b_{r})_{i} = f(\\phi_{i}) = \\int_{0}^{\\pi} g(x)\\phi_{i}(x)\\,\\mathrm{d}x$，其中 $g(x) = \\sin(x)$。\n$(b_{r})_{1} = \\int_{0}^{\\pi} \\sin(x) \\sqrt{\\frac{2}{\\pi}}\\sin(x)\\,\\mathrm{d}x = \\sqrt{\\frac{2}{\\pi}}\\int_{0}^{\\pi}\\sin^2(x)\\,\\mathrm{d}x = \\sqrt{\\frac{2}{\\pi}}\\frac{\\pi}{2} = \\sqrt{\\frac{\\pi}{2}}$。\n$(b_{r})_{2} = \\int_{0}^{\\pi} \\sin(x) \\sqrt{\\frac{2}{\\pi}}\\sin(2x)\\,\\mathrm{d}x = \\sqrt{\\frac{2}{\\pi}}\\int_{0}^{\\pi}\\sin(x)\\sin(2x)\\,\\mathrm{d}x = 0$。\n所以，$b_{r} = \\begin{pmatrix} \\sqrt{\\frac{\\pi}{2}} \\\\ 0 \\end{pmatrix}$。注意 $b_r$ 与 $\\mu$ 无关。\n\n为保证伽辽金降阶模型的稳定性，我们要求降阶线性系统对任意右端项都有唯一解。这等价于矩阵 $A_{r}(\\mu)$ 是可逆的。令 $v_{r} = \\sum_{j=1}^{2} c_{j}\\phi_{j}$ 为 $V_{r}$ 中的任意函数，其系数向量为 $c = (c_{1}, c_{2})^{\\top}$。与矩阵 $A_{r}(\\mu)$ 相关联的二次型为\n$$c^{\\top}A_{r}(\\mu)c = \\sum_{i=1}^{2}\\sum_{j=1}^{2} c_{i} (A_{r}(\\mu))_{ij} c_{j} = \\sum_{i=1}^{2}\\sum_{j=1}^{2} c_{i} a_{\\mu}(\\phi_{j}, \\phi_{i}) c_{j} = a_{\\mu}\\left(\\sum_{j=1}^{2}c_{j}\\phi_{j}, \\sum_{i=1}^{2}c_{i}\\phi_{i}\\right) = a_{\\mu}(v_{r},v_{r}).$$\n根据第一性原理，矩阵 $A_{r}(\\mu)$ 是正定的当且仅当对于所有 $c \\neq 0$ 都有 $c^{\\top}A_{r}(\\mu)c > 0$。这等价于对于所有 $v_{r} \\neq 0$ 都有 $a_{\\mu}(v_{r},v_{r}) > 0$。为保证稳定性，一个更强的条件，即双线性形式 $a_{\\mu}(\\cdot,\\cdot)$ 在子空间 $V_{r}$ 上的矫顽性，是充分的。该条件表明，存在一个常数 $\\alpha_{r}(\\mu)>0$ 使得对于所有 $v_{r} \\in V_{r}$ 都有 $a_{\\mu}(v_{r},v_{r}) \\ge \\alpha_{r}(\\mu) \\|v_{r}\\|_{V}^{2}$。如果这个条件成立，$v_r \\neq 0$ 意味着 $\\|v_r\\|_V > 0$，进而意味着 $a_{\\mu}(v_{r},v_{r}) > 0$。$A_{r}(\\mu)$ 由此产生的正定性保证了其可逆性，从而保证了伽辽金降阶模型的稳定性。对于所有 $\\mu \\in [\\mu_{\\min},\\mu_{\\max}]$ 的一致稳定性取决于矫顽常数的一致正性，即 $\\inf_{\\mu \\in [\\mu_{\\min},\\mu_{\\max}]} \\alpha_{r}(\\mu) > 0$。\n\n最后，我们计算 $\\alpha_{r}^{\\star} = \\inf_{\\mu \\in [\\frac{1}{2},2]} \\alpha_{r}(\\mu)$，其中 $\\alpha_{r}(\\mu) = \\inf_{0 \\neq v_{r} \\in V_{r}} \\frac{a_{\\mu}(v_{r},v_{r})}{\\|v_{r}\\|_{V}^{2}}$。\n令 $v_{r}(x) = c_{1}\\phi_{1}(x) + c_{2}\\phi_{2}(x)$。分子是\n$a_{\\mu}(v_{r},v_{r}) = \\int_{0}^{\\pi} (\\mu (v_{r}')^2 + v_{r}^2) \\,\\mathrm{d}x = \\mu\\int_{0}^{\\pi}(c_{1}\\phi_{1}' + c_{2}\\phi_{2}')^2\\,\\mathrm{d}x + \\int_{0}^{\\pi}(c_{1}\\phi_{1} + c_{2}\\phi_{2})^2\\,\\mathrm{d}x$。\n使用前面计算出的正交性质，这可以简化为\n$a_{\\mu}(v_{r},v_{r}) = \\mu(c_{1}^2 K_{11} + c_{2}^2 K_{22}) + (c_{1}^2 M_{11} + c_{2}^2 M_{22}) = \\mu(c_{1}^2 + 4c_{2}^2) + (c_{1}^2+c_{2}^2) = (\\mu+1)c_{1}^2 + (4\\mu+1)c_{2}^2$。\n分母是范数的平方 $\\|v_{r}\\|_{V}^{2} = \\int_{0}^{\\pi} ((v_{r}')^2 + v_{r}^2)\\,\\mathrm{d}x$。这对应于 $\\mu=1$ 时的 $a_{\\mu}(v_r, v_r)$。\n$\\|v_{r}\\|_{V}^{2} = (c_{1}^2 + 4c_{2}^2) + (c_{1}^2+c_{2}^2) = 2c_{1}^2 + 5c_{2}^2$。\n我们需要找到这个比值的下确界：\n$$ \\frac{a_{\\mu}(v_{r},v_{r})}{\\|v_{r}\\|_{V}^{2}} = \\frac{(\\mu+1)c_{1}^2 + (4\\mu+1)c_{2}^2}{2c_{1}^2 + 5c_{2}^2}. $$\n该表达式关于 $(c_1, c_2)$ 是齐次的，因此我们可以通过变量 $t = c_{2}^2/c_{1}^2 \\ge 0$ 进行最小化。这涵盖了除 $c_1=0$ 之外的所有情况，我们将单独考虑 $c_1=0$。令 $h(t) = \\frac{(\\mu+1) + (4\\mu+1)t}{2 + 5t}$。\n为了找到 $t \\ge 0$ 时 $h(t)$ 的下确界，我们分析其导数：\n$$ h'(t) = \\frac{(4\\mu+1)(2+5t) - 5((\\mu+1)+(4\\mu+1)t)}{(2+5t)^2} = \\frac{8\\mu+2 - (5\\mu+5)}{(2+5t)^2} = \\frac{3\\mu-3}{(2+5t)^2}. $$\n$h'(t)$ 的符号由 $\\mu-1$ 的符号决定。\n- 如果 $\\mu > 1$，$h'(t) > 0$，所以 $h(t)$ 是递增的。下确界在 $t=0$ 处取得：$h(0) = \\frac{\\mu+1}{2}$。这对应于 $c_2=0$。\n- 如果 $\\mu < 1$，$h'(t) < 0$，所以 $h(t)$ 是递减的。下确界是当 $t \\to \\infty$ 时的极限：$\\lim_{t\\to\\infty}h(t) = \\frac{4\\mu+1}{5}$。这对应于 $c_1=0$。\n- 如果 $\\mu = 1$，$h'(t) = 0$，所以 $h(t)$ 是常数：$h(t) = \\frac{1+1}{2} = 1$。\n\n所以，降阶矫顽常数为 $\\alpha_{r}(\\mu) = \\min\\left(\\frac{\\mu+1}{2}, \\frac{4\\mu+1}{5}\\right)$。\n我们需要找到 $\\alpha_{r}^{\\star} = \\inf_{\\mu \\in [\\frac{1}{2},2]} \\alpha_{r}(\\mu)$。我们来分析这两个关于 $\\mu$ 的函数。它们相等时 $\\frac{\\mu+1}{2} = \\frac{4\\mu+1}{5} \\implies 5\\mu+5 = 8\\mu+2 \\implies 3\\mu = 3 \\implies \\mu=1$。\n对于 $\\mu < 1$，$\\frac{\\mu+1}{2} > \\frac{4\\mu+1}{5}$。对于 $\\mu > 1$，$\\frac{\\mu+1}{2} < \\frac{4\\mu+1}{5}$。\n因此，$\\alpha_{r}(\\mu)$ 由下式给出：\n$$ \\alpha_{r}(\\mu) = \\begin{cases} \\frac{4\\mu+1}{5} & \\text{若 } \\mu \\in [\\frac{1}{2}, 1] \\\\ \\frac{\\mu+1}{2} & \\text{若 } \\mu \\in [1, 2] \\end{cases} $$\n函数 $\\frac{4\\mu+1}{5}$ 在 $[\\frac{1}{2}, 1]$ 上是递增的。函数 $\\frac{\\mu+1}{2}$ 在 $[1, 2]$ 上是递增的。由于 $\\alpha_{r}(1)$ 是连续的，整个函数 $\\alpha_{r}(\\mu)$ 在区间 $[\\frac{1}{2}, 2]$ 上是递增的。\n一个递增函数在一个区间上的下确界是其在左端点的值。\n因此，$\\alpha_{r}^{\\star} = \\alpha_{r}(\\frac{1}{2})$。\n使用 $\\alpha_r(\\mu)$ 表达式的第一分支：\n$$ \\alpha_{r}^{\\star} = \\frac{4(\\frac{1}{2}) + 1}{5} = \\frac{2+1}{5} = \\frac{3}{5}. $$",
            "answer": "$$\\boxed{\\frac{3}{5}}$$"
        },
        {
            "introduction": "虽然伽辽金投影能有效降低线性系统的维度，但对于非线性系统，直接评估非线性项的计算成本仍然与原始模型相当，这构成了“降阶”的一大障碍。本练习介绍了一种强大的超降阶技术——离散经验插值方法（DEIM），它通过巧妙地选择插值点来近似非线性项，从而显著降低在线计算成本 。您将通过一个非线性多孔介质流动的具体案例，从原理和实现上掌握如何构建真正高效的非线性降阶模型。",
            "id": "3540261",
            "problem": "您的任务是推导并实现离散经验插值方法（Discrete Empirical Interpolation Method），用于在计算地质力学背景下，高效评估多孔介质中非线性流动的降阶模型所产生的非线性残差。考虑在域 $[0,1]$ 上的一维稳态达西型流动问题，其渗透率依赖于压力。压力场建模为 $p(x;\\mu) = 1 - x + \\mu \\sin(\\pi x)$，满足狄利克雷边界条件 $p(0;\\mu)=1$ 和 $p(1;\\mu)=0$。渗透率为 $k(p) = k_0 \\exp(\\alpha p)$，为简化起见，设 $k_0=1$，$α$ 是一个无量纲的非线性系数。在内部网格节点 $i$（均匀网格尺寸为 $h$）处的有限体积残差由下式给出：\n$$\nr_i(p) = -\\frac{1}{h}\\left( \\frac{2\\,k_{i+1}k_i}{k_{i+1}+k_i}\\,\\frac{p_{i+1}-p_i}{h} - \\frac{2\\,k_i k_{i-1}}{k_i+k_{i-1}}\\,\\frac{p_i-p_{i-1}}{h}\\right),\n$$\n其中 $k_i = \\exp(\\alpha p_i)$，并且在界面处使用了调和平均值。所有量均为无量纲。\n\n您的目标是从非线性系统降阶建模的基本思想出发：使用由快照构建的降阶基 $U\\in\\mathbb{R}^{n\\times m}$ 和一个选择 $m$ 行的插值算子 $P\\in\\mathbb{R}^{n\\times m}$ 来近似非线性残差向量 $f(\\mathbf{u})\\in\\mathbb{R}^n$。施加插值约束 $P^\\top f(\\mathbf{u}) = P^\\top U\\,c(\\mathbf{u})$ 以确保在所选索引处精确匹配，并推导出当 $P^\\top U$ 非奇异时，$c(\\mathbf{u}) = (P^\\top U)^{-1} P^\\top f(\\mathbf{u})$。解释为什么可以使用贪婪的离散最大范数准则来选择使 $P^\\top U$ 良态的插值索引，并构建一个算法，在给定 $U$ 的情况下，返回插值索引集。\n\n然后，实现此算法以计算上述问题的非线性残差快照的离散经验插值方法（DEIM）索引。使用一个具有 $N$ 个内部节点的均匀网格，网格间距为 $h = 1/(N+1)$，并通过在一组预设参数值 $\\{\\mu_j\\}$ 下，在压力场 $p(x;\\mu_j)$ 处评估残差来形成快照列 $\\mathbf{r}(\\mu_j)$。通过快照矩阵的前 $m$ 个左奇异向量（本征正交分解）构建降阶基 $U$，然后通过贪婪算法计算 DEIM 插值索引，该算法在与先前选择的行进行正交插值后，迭代选择当前基向量中绝对值最大条目的行索引。\n\n所有量均为无量纲，并且必须按此处理。不出现角度，也无需使用。下面的测试套件指定了三种情况，以涵盖一般场景、边界情况和近共线性快照场景。\n\n测试套件：\n- 情况 1（一般情况，中等非线性）：$N=20$，$\\alpha=4.0$，$m=5$，$\\{\\mu_j\\} = [0.2,\\,0.5,\\,0.8,\\,1.1,\\,1.4]$。\n- 情况 2（最小选择的边界情况）：$N=20$，$\\alpha=4.0$，$m=1$，$\\{\\mu_j\\} = [0.2,\\,0.5,\\,0.8,\\,1.1,\\,1.4]$。\n- 情况 3（弱非线性下的近共线性）：$N=20$，$\\alpha=0.5$，$m=3$，$\\{\\mu_j\\} = [0.01,\\,0.02,\\,0.05,\\,0.08]$。\n\n要求：\n- 完全按照规定实现残差组装，在单元界面处对渗透率使用调和平均，并在一个均匀网格上使用给定的压力场 $p(x;\\mu)$，狄利克雷边界条件嵌入在 $x=0$ 和 $x=1$ 的节点值中。\n- 通过为每个 $\\mu_j$ 评估残差并将结果向量作为列堆叠来构建快照矩阵。\n- 通过快照矩阵的前 $m$ 个左奇异向量计算本征正交分解基 $U$。\n- 实现离散经验插值方法的贪婪算法，从 $U$ 计算插值索引。\n- 索引使用从零开始的编号。\n\n您的程序必须输出单行，其中包含一个由三个列表组成的列表，每个列表分别是对应情况的 DEIM 索引集（作为从零开始的整数），顺序为情况 1、情况 2、情况 3。输出格式必须严格为单行形式\n[ [i1_1,i1_2,...,i1_m1], [i2_1,...,i2_m2], [i3_1,...,i3_m3] ]\n不含任何额外文本，其中 $i\\ell_k$ 是整数。例如，打印的输出必须看起来像 [[0,3,5],[2],[1,4,7]]，但要使用为此问题实际计算出的索引。",
            "solution": "该问题经评估有效。它在科学上基于计算流体动力学和模型降阶的原理，特别是本征正交分解（POD）和离散经验插值方法（DEIM）。该问题是自洽的、数学上一致的、适定的，并提供了推导唯一可验证解所需的所有信息。\n\n核心任务是开发并应用 DEIM 为非线性多孔介质流动问题构建一个高效的降阶模型。这需要对 DEIM 算法进行详细解释，然后进行实现。\n\n**离散经验插值方法（DEIM）的理论基础**\n\n降阶建模（ROM）旨在用评估速度更快的低维代理模型取代高维、计算成本高昂的模型。考虑一个非线性常微分方程组，通常由偏微分方程（PDE）的空间离散化产生，形式为 $\\dot{\\mathbf{z}}(t) = A\\mathbf{z}(t) + \\mathbf{f}(\\mathbf{z}(t))$，其中 $\\mathbf{z} \\in \\mathbb{R}^n$ 是高维 $n$ 的状态向量，$A \\in \\mathbb{R}^{n \\times n}$ 是一个线性算子，$\\mathbf{f}: \\mathbb{R}^n \\to \\mathbb{R}^n$ 是一个非线性函数。\n\n使用基于投影的 ROM，状态在一个由降阶基 $U \\in \\mathbb{R}^{n \\times m}$（其中 $m \\ll n$）张成的低维子空间中进行近似：$\\mathbf{z}(t) \\approx U \\mathbf{z}_r(t)$，其中 $\\mathbf{z}_r \\in \\mathbb{R}^m$ 是降阶状态向量。在基 $U$ 上的伽辽金投影得到降阶系统：\n$$\n\\dot{\\mathbf{z}}_r(t) = (U^\\top A U) \\mathbf{z}_r(t) + U^\\top \\mathbf{f}(U \\mathbf{z}_r(t))\n$$\n降阶线性算子 $A_r = U^\\top A U \\in \\mathbb{R}^{m \\times m}$ 可以预先计算，从而实现线性项的高效评估。然而，非线性项 $U^\\top \\mathbf{f}(U \\mathbf{z}_r(t))$ 仍然是一个计算瓶颈。其评估首先需要构建全阶状态 $U \\mathbf{z}_r(t) \\in \\mathbb{R}^n$，然后在该状态下评估非线性函数 $\\mathbf{f}$（成本取决于 $n$），最后将结果投影回降阶空间。这种 $O(n)$ 的复杂度违背了 ROM 的初衷。\n\nDEIM 为此问题提供了一个解决方案，这种技术通常被称为超降阶。其中心思想是同样在一个低维子空间中近似非线性向量 $\\mathbf{f}(\\mathbf{u})$（使用 $\\mathbf{u}$ 作为通用状态向量）。该子空间由一个基张成，根据问题陈述我们称之为 $U$，但需要注意的是，这个基是针对非线性项的，不一定是状态本身的。基 $U \\in \\mathbb{R}^{n \\times m}$ 通常通过 POD（即前导左奇异向量）从非线性项的一组快照 $\\{\\mathbf{f}(\\mathbf{u}_1), \\mathbf{f}(\\mathbf{u}_2), \\dots\\}$ 构建。因此，近似为：\n$$\n\\mathbf{f}(\\mathbf{u}) \\approx U \\mathbf{c}(\\mathbf{u})\n$$\n其中 $\\mathbf{c}(\\mathbf{u}) \\in \\mathbb{R}^m$ 是一个系数向量。挑战在于如何高效地找到 $\\mathbf{c}(\\mathbf{u})$。伽辽金投影 $U^\\top \\mathbf{f}(\\mathbf{u}) = (U^\\top U) \\mathbf{c}(\\mathbf{u})$ 仍然需要评估完整的向量 $\\mathbf{f}(\\mathbf{u})$。\n\nDEIM 通过用插值替换投影来规避这个问题。它强制要求近似在 $m$ 个精心选择的小索引集 $\\{s_1, s_2, \\dots, s_m\\}$ 上是精确的。设 $P \\in \\mathbb{R}^{n \\times m}$ 是一个选择这些行的矩阵，构造为 $P = [\\mathbf{e}_{s_1}, \\mathbf{e}_{s_2}, \\dots, \\mathbf{e}_{s_m}]$，其中 $\\mathbf{e}_{s_j}$ 是在位置 $s_j$ 处为 $1$ 的标准基向量。插值约束为：\n$$\nP^\\top \\mathbf{f}(\\mathbf{u}) = P^\\top (U \\mathbf{c}(\\mathbf{u})) = (P^\\top U) \\mathbf{c}(\\mathbf{u})\n$$\n如果矩阵 $(P^\\top U) \\in \\mathbb{R}^{m \\times m}$ 非奇异，则可以求解系数：\n$$\n\\mathbf{c}(\\mathbf{u}) = (P^\\top U)^{-1} P^\\top \\mathbf{f}(\\mathbf{u})\n$$\n这就是所要求的推导。计算效率的提升源于评估 $P^\\top \\mathbf{f}(\\mathbf{u})$ 仅需要计算非线性函数 $\\mathbf{f}$ 中与所选索引相对应的 $m$ 个分量，而不是全部 $n$ 个分量。完整的 DEIM 近似为：\n$$\n\\mathbf{f}(\\mathbf{u}) \\approx U (P^\\top U)^{-1} P^\\top \\mathbf{f}(\\mathbf{u})\n$$\n矩阵 $U$ 和 $(P^\\top U)^{-1}$ 是离线计算的。在线评估成本主要由计算 $\\mathbf{f}$ 的 $m$ 个分量和一个大小为 $n \\times m$ 的矩阵向量乘积主导，这远低于原始的 $O(n)$ 成本。\n\n**用于索引选择的贪婪算法**\n\n矩阵 $(P^\\top U)$ 的可逆性和条件数至关重要。DEIM 采用贪婪算法选择插值索引 $\\{s_1, \\dots, s_m\\}$ 以确保 $(P^\\top U)$ 是良态的。此过程在概念上类似于带部分主元分解的 LU 分解，在每一步中，选择具有最大可能幅值的主元以控制误差传播。\n\n给定标准正交基 $U = [\\mathbf{u}_1, \\mathbf{u}_2, \\dots, \\mathbf{u}_m] \\in \\mathbb{R}^{n \\times m}$，算法流程如下：\n\n1. 选择第一个基向量 $\\mathbf{u}_1$。找到其幅值最大的索引 $s_1$。该索引成为第一个插值点。\n$$\ns_1 = \\arg\\max_{i \\in \\{1, \\dots, n\\}} |\\mathbf{u}_1^{(i)}|\n$$\n令 $\\mathcal{S} = \\{s_1\\}$。\n\n2. 对于 $k = 2, \\dots, m$：\n   a. 取下一个基向量 $\\mathbf{u}_k$。\n   b. 使用已选择的插值点 $\\mathcal{S}_{k-1} = \\{s_1, \\dots, s_{k-1}\\}$，在先前选择的基向量 $\\{\\mathbf{u}_1, \\dots, \\mathbf{u}_{k-1}\\}$ 张成的空间中找到其最佳近似。我们从插值约束中求解系数 $\\mathbf{c} \\in \\mathbb{R}^{k-1}$：\n   $$\n   P_{k-1}^\\top \\mathbf{u}_k = (P_{k-1}^\\top U_{k-1}) \\mathbf{c} \\implies \\mathbf{c} = (P_{k-1}^\\top U_{k-1})^{-1} P_{k-1}^\\top \\mathbf{u}_k\n   $$\n   其中 $U_{k-1} = [\\mathbf{u}_1, \\dots, \\mathbf{u}_{k-1}]$ 且 $P_{k-1}$ 从 $\\mathcal{S}_{k-1}$ 中选择行。\n   c. 计算插值误差（或残差）向量 $\\mathbf{r}_k$：\n   $$\n   \\mathbf{r}_k = \\mathbf{u}_k - U_{k-1}\\mathbf{c}\n   $$\n   d. 下一个插值索引 $s_k$ 被选为该残差幅值最大的位置。这是当前近似最差的点，因此也是最需要新信息的点。\n   $$\n   s_k = \\arg\\max_{i \\in \\{1, \\dots, n\\}} |\\mathbf{r}_k^{(i)}|\n   $$\n   e. 将新索引添加到集合中：$\\mathcal{S}_k = \\mathcal{S}_{k-1} \\cup \\{s_k\\}$。\n\n3. 最终的插值索引集为 $\\mathcal{S}_m = \\{s_1, \\dots, s_m\\}$。通过迭代地最大化残差的分量，该算法确保 $P^\\top U$ 的列尽可能线性无关，从而得到一个良态矩阵。\n\n**针对多孔介质问题的实现**\n\n我们现在将此框架应用于给定的问题。\n\n1. **离散化与状态表示**：域 $[0,1]$ 用 $N$ 个内部节点和 $2$ 个边界节点进行离散化，总共 $N+2$ 个点。网格间距为 $h=1/(N+1)$。空间坐标为 $x_j = j h$，其中 $j=0, 1, \\dots, N+1$。对于测试套件中的每个参数 $\\mu_j$，在这些节点上评估压力场 $p(x;\\mu) = 1 - x + \\mu \\sin(\\pi x)$。\n\n2. **快照生成**：对于每个 $\\mu_j$，我们计算非线性残差向量 $\\mathbf{r}(\\mu_j) \\in \\mathbb{R}^N$。内部节点 $i=1, \\dots, N$ 的分量 $r_i$ 由有限体积公式给出：\n$$\nr_i(p) = -\\frac{1}{h}\\left( T_{i+1/2}\\,\\frac{p_{i+1}-p_i}{h} - T_{i-1/2}\\,\\frac{p_i-p_{i-1}}{h}\\right)\n$$\n其中 $T_{i+1/2}$ 是单元间传导率，使用渗透率 $k_i = \\exp(\\alpha p_i)$ 的调和平均值计算：\n$$\nT_{i \\pm 1/2} = \\frac{2\\,k_{i \\pm 1}k_i}{k_{i \\pm 1}+k_i}\n$$\n在域的末端使用来自狄利克雷边界条件的压力值 $p_0=1$ 和 $p_{N+1}=0$。通过将这些残差向量作为列堆叠来形成快照矩阵 $R$：$R=[\\mathbf{r}(\\mu_1), \\mathbf{r}(\\mu_2), \\dots]$。\n\n3. **POD 基的构建**：快照矩阵的奇异值分解（SVD）$R = U \\Sigma V^\\top$ 得到 POD 模态。非线性项的降阶基由前 $m$ 个左奇异向量构成，这些向量是 $U \\in \\mathbb{R}^{N \\times m}$ 的列。\n\n4. **DEIM 索引计算**：将上述贪婪算法应用于该基 $U$，以计算 $m$ 个 DEIM 插值索引。实现将使用从零开始的索引，因此索引范围为 $0$ 到 $N-1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_deim_indices(N, alpha, m, mu_values):\n    \"\"\"\n    Computes the DEIM indices for the given porous media problem.\n\n    Args:\n        N (int): Number of interior grid nodes.\n        alpha (float): Nonlinearity coefficient for permeability.\n        m (int): Number of basis vectors / interpolation points.\n        mu_values (list of float): List of parameters for snapshot generation.\n\n    Returns:\n        list of int: The computed zero-based DEIM indices.\n    \"\"\"\n    if m == 0:\n        return []\n\n    # 1. Grid setup\n    h = 1.0 / (N + 1)\n    x_full = np.linspace(0.0, 1.0, N + 2)\n\n    # 2. Snapshot matrix generation\n    snapshots = []\n    for mu in mu_values:\n        # Evaluate pressure and permeability on the full grid (N+2 nodes)\n        p_vec = 1.0 - x_full + mu * np.sin(np.pi * x_full)\n        k_vec = np.exp(alpha * p_vec)\n\n        # Compute the residual vector for the N interior nodes\n        r_vec = np.zeros(N)\n        for i in range(N):\n            # i is the 0-based index for the residual vector,\n            # corresponding to interior node i+1.\n            # We need values from grid nodes i, i+1, and i+2.\n            p_im1, p_i, p_ip1 = p_vec[i], p_vec[i+1], p_vec[i+2]\n            k_im1, k_i, k_ip1 = k_vec[i], k_vec[i+1], k_vec[i+2]\n\n            # Harmonic mean for internodal permeability\n            k_right = (2.0 * k_ip1 * k_i) / (k_ip1 + k_i)\n            k_left = (2.0 * k_i * k_im1) / (k_i + k_im1)\n            \n            # Fluxes\n            flux_right = k_right * (p_ip1 - p_i) / h\n            flux_left = k_left * (p_i - p_im1) / h\n\n            # Residual (Finite Volume formulation)\n            r_vec[i] = -(1.0 / h) * (flux_right - flux_left)\n        \n        snapshots.append(r_vec)\n\n    R = np.array(snapshots).T\n    if R.shape[1]  m:\n        # If number of snapshots is less than desired basis size,\n        # reduce basis size to number of snapshots.\n        # The rank of R is at most min(N, len(mu_values)).\n        m = R.shape[1]\n\n    # 3. POD basis construction (via SVD)\n    U, s, Vt = np.linalg.svd(R, full_matrices=False)\n    U_m = U[:, :m]\n\n    # 4. DEIM greedy algorithm\n    indices = []\n    \n    # First index\n    u1 = U_m[:, 0]\n    p1 = np.argmax(np.abs(u1))\n    indices.append(p1)\n\n    # Subsequent indices\n    for k in range(1, m):\n        u_k = U_m[:, k]\n        \n        # Assemble sub-problem to find coefficients 'c'\n        U_prev = U_m[:, :k]\n        P_T_U_prev = U_prev[indices, :]\n        P_T_u_k = u_k[indices]\n        \n        # Solve c = (P^T U_{k-1})^{-1} (P^T u_k)\n        try:\n            c = np.linalg.solve(P_T_U_prev, P_T_u_k)\n        except np.linalg.LinAlgError:\n            # Fallback for singular matrix, although DEIM is designed to avoid this.\n            c = np.linalg.lstsq(P_T_U_prev, P_T_u_k, rcond=None)[0]\n\n        # Compute residual r = u_k - U_{k-1} c\n        residual = u_k - U_prev @ c\n        \n        # Find index of max absolute value of residual\n        pk = np.argmax(np.abs(residual))\n        indices.append(pk)\n        \n    return [int(i) for i in indices]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, moderate nonlinearity)\n        {'N': 20, 'alpha': 4.0, 'm': 5, 'mu_values': [0.2, 0.5, 0.8, 1.1, 1.4]},\n        # Case 2 (boundary case for minimal selection)\n        {'N': 20, 'alpha': 4.0, 'm': 1, 'mu_values': [0.2, 0.5, 0.8, 1.1, 1.4]},\n        # Case 3 (near-collinearity with weak nonlinearity)\n        {'N': 20, 'alpha': 0.5, 'm': 3, 'mu_values': [0.01, 0.02, 0.05, 0.08]}\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        indices = compute_deim_indices(\n            case['N'], case['alpha'], case['m'], case['mu_values']\n        )\n        all_results.append(indices)\n        \n    # Final print statement in the exact required format without spaces\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在模拟动态系统（如热传导或流体流动）时，一个固定的降阶基可能无法在整个时间域内都保证足够的精度。本练习旨在解决这一挑战，带您实践一种在线自适应策略，以确保降阶模型的可靠性 。您将学习如何通过计算后验误差估计来实时监控模型的精度，并在误差超过预设阈值时动态地扩充降阶基，从而在保证精度的同时最大限度地提升计算效率。",
            "id": "3435653",
            "problem": "考虑一个一维空间中的线性抛物型偏微分方程 (PDE)，其具有齐次 Dirichlet 边界条件和一个含时源项。该方程在均匀网格上使用中心有限差分进行空间离散，并使用后向欧拉法进行时间离散。设空间域为区间 $\\left[0,1\\right]$，有 $N$ 个内部点，网格间距为 $h = \\frac{1}{N+1}$，网格点为 $x_i = i h$，其中 $i = 1,\\dots,N$。设扩散系数为 $\\nu  0$。使用带有齐次 Dirichlet 边界条件的标准二阶中心差分拉普拉斯算子进行空间半离散，可得到关于未知向量 $u(t) \\in \\mathbb{R}^N$ 的常微分方程组，其形式为\n$$\n\\frac{d}{dt} u(t) = \\nu L u(t) + s(t),\n$$\n其中 $L \\in \\mathbb{R}^{N \\times N}$ 是通常的有限差分拉普拉斯算子，其模板为 $\\left[\\frac{1}{h^2}, -\\frac{2}{h^2}, \\frac{1}{h^2}\\right]$，并且由于齐次 Dirichlet 边界条件，其在第一行和最后一行中对应边界外的元素被置为零。$s(t) \\in \\mathbb{R}^N$ 是源项在网格点上采样的向量。使用时间步长 $\\Delta t  0$ 的后向欧拉时间离散，在每个整数时间索引 $k \\ge 1$ 处得到线性系统\n$$\n\\left(\\frac{1}{\\Delta t} I - \\nu L\\right) u^k = \\frac{1}{\\Delta t} u^{k-1} + s^k,\n$$\n其中 $I$ 是单位矩阵，$u^k \\approx u(t_k)$ 且 $t_k = k \\Delta t$，$s^k \\approx s(t_k)$。\n\n定义对称正定矩阵\n$$\nA := -\\nu L \\in \\mathbb{R}^{N \\times N}, \\quad B := \\frac{1}{\\Delta t} I + A \\in \\mathbb{R}^{N \\times N}.\n$$\n设降阶模型 (ROM) 在一个维度为 $r \\ll N$ 的试探子空间中逼近 $u^k$，该子空间由基矩阵 $V_r \\in \\mathbb{R}^{N \\times r}$ 的列向量张成，且满足 $V_r^T V_r = I_r$。将后向欧拉格式 Galerkin 投影到 $\\text{span}(V_r)$ 上，得到关于系数 $a^k \\in \\mathbb{R}^r$ 的降阶系统\n$$\n\\left(\\frac{1}{\\Delta t} I_r + V_r^T A V_r\\right) a^k = \\frac{1}{\\Delta t} a^{k-1} + V_r^T s^k.\n$$\nROM 状态为 $u_r^k = V_r a^k$。在时间步 $k$ 对应的全阶残差向量定义为\n$$\nr(u_r^k) := \\frac{1}{\\Delta t} u_r^{k-1} + s^k - \\left(\\frac{1}{\\Delta t} I + A\\right) u_r^k = \\frac{1}{\\Delta t} u_r^{k-1} + s^k - B u_r^k \\in \\mathbb{R}^N.\n$$\n\n要求您为 ROM 时间积分器实现一种在线误差控制策略，该策略基于投影残差的对偶范数和增量式基富集。\n\n任务：\n- 从线性强制问题的 Galerkin 投影和后向欧拉格式的基本概念出发，推导出一个每个时间步的可计算后验误差界。该误差界用残差 $r(u_r^k)$ 相对于对称正定算子 $B$ 的对偶范数表示。设对偶范数定义为\n$$\n\\|r\\|_{B^{-1}} := \\sqrt{r^T B^{-1} r}.\n$$\n- 基于一个与 $\\|r(u_r^k)\\|_{B^{-1}}$ 相关的、经过验证的后验界，为在时间步 $k$ 接受 ROM 解设计一个停止准则。在时间步 $k$ 的接受准则必须是：如果 $\\|r(u_r^k)\\|_{B^{-1}} \\le \\tau$，则接受，其中 $\\tau  0$ 是一个容差。如果不接受，则通过附加一个在线计算的新方向来执行增量式基更新，并在同一时间步重新计算 ROM 解，如此迭代直到解被接受或基的规模达到预设的最大值 $r_{\\max}$。\n- 在时间步 $k$ 的在线富集方向的选择方式必须由误差方程证明其合理性。使用残差在 $B$-内积下的 Riesz 表示，即求解 $B w^k = r(u_r^k)$ 得到的向量 $w^k$。在欧几里得内积下，将 $w^k$ 与当前基的列向量进行正交化，然后将其归一化，附加到 $V_r$ 中，并更新降阶算子。在重新求解 $a^k$ 之前，先在新基中重新计算 $a^{k-1}$ 为 $V_r^T u_r^{k-1}$。\n- 初始降阶基必须由对应于齐次 Dirichlet 边界条件的前 $r_0$ 个离散正弦模态构成，即由元素为 $v_j(i) = \\sin\\left(\\frac{j \\pi i}{N+1}\\right)$（其中 $j = 1,\\dots,r_0$，$i = 1,\\dots,N$）的列向量组成，并在欧几里得内积下进行标准正交化。初始 ROM 状态 $u_r^0$ 必须是初始条件在 $\\text{span}(V_{r_0})$ 上的投影。\n\n将全阶模型的数据设置如下：\n- 空间维度：$N = 80$ 个内部网格点。\n- 扩散系数：$\\nu = 10^{-2}$。\n- 最终时间：$T = 10^{-1}$。\n- 时间步长：$\\Delta t = 2 \\cdot 10^{-3}$，因此共有 $K = \\frac{T}{\\Delta t} = 50$ 个时间步。\n- 初始条件：$u^0(x) = \\sin(\\pi x)$，在网格点上采样。\n- 源项：$s(x,t) = \\sin(5 \\pi x) e^{-t}$，在网格点上采样并在 $t_k = k \\Delta t$ 处求值。\n\n测试套件规范：\n实现所述的在线自适应 ROM 积分器，并针对以下三个测试用例运行它，每个用例由一个三元组 $(r_0, \\tau, r_{\\max})$ 指定：\n- 用例 A (理想路径)：$r_0 = 1$, $\\tau = 10^{-4}$, $r_{\\max} = 20$。\n- 用例 B (严格容差)：$r_0 = 2$, $\\tau = 10^{-5}$, $r_{\\max} = 25$。\n- 用例 C (容量紧张的边缘情况)：$r_0 = 3$, $\\tau = 10^{-6}$, $r_{\\max} = 8$。\n\n对于每个用例，报告：\n- 使用在线自适应规则完成所有 $K$ 个时间步后的最终降阶维度 $r_{\\text{final}}$。\n- 在所有被接受的时间步中，最大的被接受后验估计子 $\\max_{1 \\le k \\le K} \\|r(u_r^k)\\|_{B^{-1}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n\\left[r_{\\text{final},A}, \\max\\_k \\|r(u_{r,A}^k)\\|_{B^{-1}}, r_{\\text{final},B}, \\max\\_k \\|r(u_{r,B}^k)\\|_{B^{-1}}, r_{\\text{final},C}, \\max\\_k \\|r(u_{r,C}^k)\\|_{B^{-1}}\\right],\n$$\n其中下标 $A,B,C$ 指代这三个用例。每个 $r_{\\text{final}}$ 是一个整数，每个最大估计子值是一个浮点数。不需要物理单位。不使用角度。不使用百分比；所有量都应以原始数字报告。该行必须严格按照此顺序包含这六个值，不得有任何附加文本。\n\n您的实现必须是完全自包含和确定性的，仅使用指定的数值参数和所描述的在线算法。数值线性代数部分必须能稳健地求解以 $B$ 为系数矩阵的线性系统。任何标准正交化都必须使用欧几里得内积。",
            "solution": "该问题要求为一维线性抛物型偏微分方程实现一个在线自适应降阶模型 (ROM)。解决方案包括两个主要阶段：首先，进行理论推导以证明误差控制策略的合理性；其次，设计并实现数值算法。\n\n### 1. 后验误差估计子的推导\n\n含时问题使用后向欧拉法进行离散，从而在每个时间步 $k \\ge 1$ 导出一个需求解的线性系统：\n$$ \\left(\\frac{1}{\\Delta t} I - \\nu L\\right) u^k = \\frac{1}{\\Delta t} u^{k-1} + s^k $$\n使用给定的定义 $A := -\\nu L$ 和 $B := \\frac{1}{\\Delta t} I + A$，全阶模型 (FOM) 方程可以简写为：\n$$ B u^k = \\frac{1}{\\Delta t} u^{k-1} + s^k $$\n此处，$u^k \\in \\mathbb{R}^N$ 是在时间 $t_k$ 的 FOM 解。矩阵 $B$ 是对称正定 (SPD) 的，因为 $A$ 是 SPD 的（由于 $L$ 是负定离散拉普拉斯算子且 $\\nu  0$），并且 $\\frac{1}{\\Delta t}I$ 是一个正定对角矩阵。\n\nROM 解 $u_r^k$ 用于定义全阶残差向量 $r(u_r^k)$：\n$$ r(u_r^k) := \\frac{1}{\\Delta t} u_r^{k-1} + s^k - B u_r^k $$\n该残差量化了 ROM 解未能满足 FOM 方程的程度。\n\n为了将此残差与真实误差 $e^k := u^k - u_r^k$ 联系起来，我们推导误差演化方程。我们从 FOM 方程中减去重新整理后的残差定义 $\\frac{1}{\\Delta t} u_r^{k-1} + s^k = B u_r^k + r(u_r^k)$：\n$$ B u^k - (B u_r^k + r(u_r^k)) = \\frac{1}{\\Delta t} u^{k-1} - \\frac{1}{\\Delta t} u_r^{k-1} $$\n$$ B (u^k - u_r^k) - r(u_r^k) = \\frac{1}{\\Delta t} (u^{k-1} - u_r^{k-1}) $$\n$$ B e^k = \\frac{1}{\\Delta t} e^{k-1} + r(u_r^k) $$\n该方程将第 $k$ 步的误差与前一步的误差 $e^{k-1}$ 以及在当前步产生的残差联系起来。\n\n对于单步后验误差界，我们关心的是在第 $k$ 步*内部*产生的误差。通常的估计方法是假设前一步的解是精确的，即 $u_r^{k-1} = u^{k-1}$，这意味着 $e^{k-1} = 0$。在此假设下，误差方程简化为：\n$$ B e^k = r(u_r^k) \\implies e^k = B^{-1} r(u_r^k) $$\n为了度量这个误差，我们使用由 SPD 算子 $B$ 导出的自然能量范数，定义为 $\\|x\\|_B := \\sqrt{x^T B x}$。误差的范数平方为：\n$$ \\|e^k\\|_B^2 = (e^k)^T B e^k = (B^{-1} r(u_r^k))^T B (B^{-1} r(u_r^k)) $$\n由于 $B$ 是对称的，其逆 $B^{-1}$ 也是对称的。因此，$(B^{-1} r(u_r^k))^T = r(u_r^k)^T (B^{-1})^T = r(u_r^k)^T B^{-1}$。将此代回，我们得到：\n$$ \\|e^k\\|_B^2 = r(u_r^k)^T B^{-1} B B^{-1} r(u_r^k) = r(u_r^k)^T B^{-1} r(u_r^k) $$\n这恰好是残差的对偶范数平方，即 $\\|r(u_r^k)\\|_{B^{-1}}^2$。因此，我们建立了关键的恒等式：\n$$ \\|e^k\\|_B = \\|r(u_r^k)\\|_{B^{-1}} $$\n这个等式为使用可计算量 $\\|r(u_r^k)\\|_{B^{-1}}$ 作为在时间步 $k$ 引入的误差的后验估计子提供了理论依据。\n\n### 2. 算法设计与实现\n\n在线自适应算法执行一个关于时间步的循环。在每个时间步内，一个内循环执行基自适应，直到误差估计子低于容差 $\\tau$ 或达到最大基规模 $r_{\\max}$。\n\n**初始化：**\n1.  **FOM 设置**：定义网格，一个包含 $N$ 个内部点的均匀集合。构建有限差分拉普拉斯算子 $L$、矩阵 $A = -\\nu L$ 和时间步进矩阵 $B = \\frac{1}{\\Delta t}I + A$。由于 $B$ 是常数并在每个自适应步骤中都用于求解，为了提高效率，我们在开始时一次性计算其 Cholesky 分解 $B = C^T C$。\n2.  **初始 ROM**：大小为 $r_0$ 的初始基 $V_{r_0}$ 通过选取 $L$ 的前 $r_0$ 个特征向量（即离散正弦模态）并将其标准正交化来构成。将初始条件 $u^0$ 投影到该基上以获得初始 ROM 状态 $u_r^0$。对于本问题，$u^0(x) = \\sin(\\pi x)$ 对应于第一个正弦模态，因此如果 $r_0 \\ge 1$，则投影是精确的，即 $u_r^0 = u^0$。\n\n**带在线自适应的时间积分 (对每个时间步 $k=1, \\dots, K$)：** 使用一个内部 `while` 循环来管理每个时间步 $k$ 的自适应过程。设 $u_r^{k-1}$ 为前一步已接受的 ROM 解。\n\n1.  **求解降阶系统**：\n    - 将算子 $A$ 投影到当前基 $V_r$ 上：$A_r = V_r^T A V_r$。\n    - 构造降阶系统矩阵 $B_r = \\frac{1}{\\Delta t} I_r + A_r$。\n    - 投影源项 $s^k$ 和前一步解的贡献：$s_r^k = V_r^T s^k$ 和系数向量 $a^{k-1} = V_r^T u_r^{k-1}$。\n    - 求解关于新系数 $a^k$ 的 $r \\times r$ 线性系统：$B_r a^k = \\frac{1}{\\Delta t} a^{k-1} + s_r^k$。\n    - 重构全空间 ROM 解：$u_r^k = V_r a^k$。\n\n2.  **计算误差估计子**：\n    - 计算全阶残差：$r_k = \\frac{1}{\\Delta t} u_r^{k-1} + s^k - B u_r^k$。\n    - 为了计算估计子 $\\eta_k = \\|r_k\\|_{B^{-1}} = \\sqrt{r_k^T B^{-1} r_k}$，我们首先求解 $N \\times N$ 系统 $B z_k = r_k$ 以得到 $z_k = B^{-1} r_k$。这可以通过使用预先计算的 $B$ 的 Cholesky 分解来高效完成。\n    - 于是估计子为 $\\eta_k = \\sqrt{r_k^T z_k}$。\n\n3.  **决策与自适应**：\n    - **接受**：如果 $\\eta_k \\le \\tau$ 或基的规模已达到其上限（$r \\ge r_{\\max}$），则接受解 $u_r^k$。这个 $u_r^k$ 将成为下一个时间步的 $u_r^{k-1}$，内循环终止。$\\eta_k$ 的值被记录为此时间步的已接受估计子。\n    - **拒绝与富集**：如果 $\\eta_k  \\tau$ 且 $r  r_{\\max}$，则拒绝该解，并对基进行富集。\n        - 富集向量选择为 $w_k = z_k = B^{-1} r_k$，即残差的 Riesz 表示。已知这个方向对于减小误差是有效的。\n        - 使用欧几里得内积（Gram-Schmidt 过程）将 $w_k$ 与当前基的列向量 $V_r$ 进行正交化：$\\tilde{w}_k = w_k - V_r(V_r^T w_k)$。\n        - 将得到的向量 $\\tilde{w}_k$ 归一化以产生 $\\hat{w}_k$。\n        - 扩充基：$V_{r+1} = [V_r, \\hat{w}_k]$。\n        - 内循环在同一时间步 $k$ 使用更大的基从第 1 步继续。\n\n这个过程重复进行，直到为所有 $K$ 个时间步都找到了满意的解。对于每个测试用例，报告最终的基规模和所有已接受估计子中的最大值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cho_factor, cho_solve\n\ndef run_simulation(N, nu, T, dt, r0, tau, r_max):\n    \"\"\"\n    Runs the online-adaptive ROM simulation for one test case.\n\n    Args:\n        N (int): Number of interior spatial grid points.\n        nu (float): Diffusion coefficient.\n        T (float): Final time.\n        dt (float): Time step size.\n        r0 (int): Initial reduced basis size.\n        tau (float): Tolerance for the a posteriori error estimator.\n        r_max (int): Maximum allowed reduced basis size.\n\n    Returns:\n        tuple: A tuple containing:\n            - r_final (int): The final size of the reduced basis.\n            - max_estimator (float): The maximum accepted estimator value over all time steps.\n    \"\"\"\n    # 1. Setup Full-Order Model (FOM)\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n\n    # Construct the 1D discrete Laplacian matrix L with homogeneous Dirichlet BCs\n    main_diag_L = -2.0 / h**2 * np.ones(N)\n    off_diag_L = 1.0 / h**2 * np.ones(N - 1)\n    L = np.diag(main_diag_L) + np.diag(off_diag_L, k=1) + np.diag(off_diag_L, k=-1)\n    \n    # Define system matrices A and B\n    A = -nu * L\n    B = (1.0 / dt) * np.eye(N) + A\n    \n    # B is symmetric positive definite; pre-compute its Cholesky factorization\n    # for efficient solves of the form B*z = r.\n    B_cholesky_factor = cho_factor(B, lower=False)\n    \n    # 2. Setup Reduced-Order Model (ROM)\n    # Initial basis V from the first r0 orthonormalized discrete sine modes\n    V = np.zeros((N, r0))\n    norm_factor = np.sqrt(2.0 / (N + 1))\n    for j in range(1, r0 + 1):\n        V[:, j - 1] = norm_factor * np.sin(j * np.pi * x)\n    \n    # Initial condition and its projection onto the initial basis\n    u0 = np.sin(np.pi * x)\n    # As u0 is the first sine mode, its projection is exact if r0 >= 1\n    u_r_prev = V @ (V.T @ u0)\n    \n    # Time stepping parameters\n    num_steps = int(round(T / dt))\n    time_grid = np.arange(1, num_steps + 1) * dt\n\n    # Source term function\n    source_func = lambda x_coords, time: np.sin(5 * np.pi * x_coords) * np.exp(-time)\n    \n    max_accepted_estimator = 0.0\n    \n    # 3. Time Integration Loop\n    for t_k in time_grid:\n        s_k = source_func(x, t_k)\n        \n        # 4. Adaptive Inner Loop for Basis Enrichment\n        while True:\n            r = V.shape[1]\n            \n            # Project operators and states onto the current reduced basis\n            A_r = V.T @ A @ V\n            B_r = (1.0 / dt) * np.eye(r) + A_r\n            a_prev = V.T @ u_r_prev\n            s_r = V.T @ s_k\n            \n            # Assemble and solve the small r x r reduced system\n            rhs_r = (1.0 / dt) * a_prev + s_r\n            a_k = np.linalg.solve(B_r, rhs_r)\n            u_r_k = V @ a_k\n            \n            # Compute the a posteriori error estimator\n            residual = (1.0 / dt) * u_r_prev + s_k - B @ u_r_k\n            z_k = cho_solve(B_cholesky_factor, residual)\n            \n            # residual.T @ z_k is guaranteed non-negative in theory,\n            # but can be a tiny negative number due to floating point arithmetic.\n            est_squared = residual.T @ z_k\n            estimator = np.sqrt(max(0, est_squared))\n            \n            # Decision: Accept step or enrich basis\n            if estimator = tau or r >= r_max:\n                if estimator > max_accepted_estimator:\n                    max_accepted_estimator = estimator\n                u_r_prev = u_r_k\n                break  # Exit adaptation loop and proceed to next time step\n            else:\n                # Enrich basis with the Riesz representative of the residual\n                w_k = z_k\n                \n                # Orthogonalize the new direction w_k against the existing basis V\n                proj_w = V @ (V.T @ w_k)\n                w_ortho = w_k - proj_w\n                norm_w_ortho = np.linalg.norm(w_ortho)\n                \n                # Add normalized vector if it's not already in the basis\n                if norm_w_ortho > 1e-12:\n                    w_new = w_ortho / norm_w_ortho\n                    V = np.hstack((V, w_new[:, np.newaxis]))\n                else:\n                    # Enrichment direction is linearly dependent. Accept the step\n                    # to prevent an infinite loop.\n                    if estimator > max_accepted_estimator:\n                        max_accepted_estimator = estimator\n                    u_r_prev = u_r_k\n                    break\n    \n    r_final = V.shape[1]\n    return r_final, max_accepted_estimator\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Full-order model parameters\n    N = 80\n    nu = 1e-2\n    T = 1e-1\n    dt = 2e-3\n\n    # Test cases: (r0, tau, r_max)\n    test_cases = [\n        (1, 1e-4, 20),   # Case A\n        (2, 1e-5, 25),   # Case B\n        (3, 1e-6, 8),    # Case C\n    ]\n\n    results = []\n    for r0, tau, r_max in test_cases:\n        r_final, max_estimator = run_simulation(N, nu, T, dt, r0, tau, r_max)\n        results.extend([r_final, max_estimator])\n\n    # Print results in the specified single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}