{
    "hands_on_practices": [
        {
            "introduction": "To build effective error estimators, we must first understand their theoretical underpinnings. This initial practice delves into the core of reliability theory for residual-based estimators, demonstrating how the structure of the estimator is dictated by fundamental functional analysis tools to ensure it provides a guaranteed upper bound on the true error. By working through this derivation for the Neumann boundary term, you will see precisely why specific powers of the mesh size $h$ appear in the estimator's definition. ",
            "id": "3439898",
            "problem": "Consider the second-order linear elliptic boundary value problem with mixed Dirichlet–Neumann boundary conditions on a bounded Lipschitz domain $\\Omega \\subset \\mathbb{R}^{2}$:\n$$\n-\\nabla \\cdot (\\boldsymbol{A} \\nabla u) = f \\quad \\text{in } \\Omega, \\qquad u = 0 \\quad \\text{on } \\Gamma_{D}, \\qquad \\boldsymbol{A}\\nabla u \\cdot \\boldsymbol{n} = g \\quad \\text{on } \\Gamma_{N},\n$$\nwhere $\\partial\\Omega = \\overline{\\Gamma_{D}} \\cup \\overline{\\Gamma_{N}}$, $\\Gamma_{D} \\cap \\Gamma_{N} = \\emptyset$, $\\boldsymbol{n}$ is the outward unit normal on $\\partial\\Omega$, $f \\in L^{2}(\\Omega)$, $g \\in L^{2}(\\Gamma_{N})$, and $\\boldsymbol{A}(x)$ is a uniformly bounded and uniformly coercive Symmetric Positive Definite (SPD) matrix field that is piecewise constant with respect to a conforming, shape-regular simplicial triangulation $\\mathcal{T}_{h}$ of $\\Omega$. Let $u_{h} \\in V_{h} \\subset H^{1}_{0}(\\Omega; \\Gamma_{D})$ be the conforming piecewise linear Galerkin finite element approximation.\n\nDefine the standard residual quantities on elements and edges as follows. For an element $K \\in \\mathcal{T}_{h}$, let\n$$\nr_{K} := f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h}) \\in L^{2}(K).\n$$\nFor an interior edge $E \\in \\mathcal{E}_{h}^{\\mathrm{int}}$, let $J_{E} := \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket$ denote the jump of the normal flux across $E$. For a Neumann boundary edge $E \\subset \\Gamma_{N}$, define the boundary residual\n$$\nR_{E} := g - \\boldsymbol{A}\\nabla u_{h}\\cdot \\boldsymbol{n} \\in L^{2}(E).\n$$\nLet $h_{K}$ denote the diameter of $K$ and $h_{E}$ the length of $E$. Consider the residual-type a posteriori error estimator in the energy norm\n$$\n\\eta^{2} := \\sum_{K \\in \\mathcal{T}_{h}} h_{K}^{2}\\,\\|r_{K}\\|_{L^2(K)}^{2} \\;+\\; \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} h_{E}\\,\\|J_{E}\\|_{L^2(E)}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{N}} h_{E}^{\\beta}\\,\\|R_{E}\\|_{L^2(E)}^{2},\n$$\nwhere $\\beta > 0$ is an exponent to be determined. The energy semi-norm induced by $\\boldsymbol{A}$ is\n$$\n\\|v\\|_{\\boldsymbol{A}}^{2} := \\int_{\\Omega} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx.\n$$\nAssume the boundary trace inequality on each element $K$ with edge $E \\subset \\partial K$:\n$$\n\\|w\\|_{L^2(E)}^{2} \\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\,\\|w\\|_{L^2(K)}^{2} + h_{E}\\,\\|\\nabla w\\|_{L^2(K)}^{2} \\right) \\quad \\text{for all } w \\in H^{1}(K),\n$$\nwhere the constant $C_{\\mathrm{tr}}$ depends only on the shape regularity of $\\mathcal{T}_{h}$ and is independent of $h$. Starting from the weak formulation and using only the above assumptions, derive the scaling of the Neumann boundary residual contribution that ensures the reliability bound\n$$\n\\|u - u_{h}\\|_{\\boldsymbol{A}}^{2} \\;\\lesssim\\; \\eta^{2},\n$$\nwith a hidden constant independent of the mesh size. Specifically, determine the value of the exponent $\\beta$ such that the boundary residual term must scale like $h_{E}^{\\beta}\\,\\|R_{E}\\|_{L^2(E)}^{2}$ in the estimator to obtain the reliability bound via the boundary trace inequality. Your final answer must be the exact value of $\\beta$ as a single number.",
            "solution": "We begin from the variational formulation of the model problem. The exact solution $u \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ satisfies\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u \\cdot \\nabla v \\, dx \\;=\\; \\int_{\\Omega} f\\, v \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v \\, ds \\quad \\text{for all } v \\in H^{1}_{0}(\\Omega; \\Gamma_{D}).\n$$\nThe Galerkin finite element solution $u_{h} \\in V_{h} \\subset H^{1}_{0}(\\Omega; \\Gamma_{D})$ satisfies\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v_{h} \\, dx \\;=\\; \\int_{\\Omega} f\\, v_{h} \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v_{h} \\, ds \\quad \\text{for all } v_{h} \\in V_{h}.\n$$\nLet $e := u - u_{h} \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ denote the error. For any $v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$, subtracting the two weak forms yields\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx \\;=\\; \\int_{\\Omega} f\\, v \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v \\, ds \\;-\\; \\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v \\, dx.\n$$\nWe now integrate by parts elementwise on each $K \\in \\mathcal{T}_{h}$. Using that $\\boldsymbol{A}$ is piecewise constant and that $v$ is continuous, we obtain\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\left( - \\int_{K} \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h})\\, v \\, dx + \\int_{\\partial K} \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{K}\\, v \\, ds \\right).\n$$\nSimilarly, since $u$ is the exact solution, we have\n$$\n\\int_{\\Omega} f\\, v \\, dx = \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} f\\, v \\, dx, \\qquad \\int_{\\Gamma_{N}} g\\, v \\, ds = \\sum_{E \\subset \\Gamma_{N}} \\int_{E} g\\, v \\, ds.\n$$\nGathering these expressions and using the cancellation of normal fluxes on interior edges, we find the standard residual decomposition:\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} \\big( f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h}) \\big)\\, v \\, dx\n+ \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} \\int_{E} \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket \\, v \\, ds\n+ \\sum_{E \\subset \\Gamma_{N}} \\int_{E} \\big( g - \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n} \\big)\\, v \\, ds.\n$$\nDenoting $r_{K} := f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h})$, $J_{E} := \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket$, and $R_{E} := g - \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}$, we have\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} r_{K}\\, v \\, dx\n+ \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} \\int_{E} J_{E}\\, v \\, ds\n+ \\sum_{E \\subset \\Gamma_{N}} \\int_{E} R_{E}\\, v \\, ds.\n$$\nThe reliability estimate is obtained by bounding each term on the right-hand side in terms of local contributions multiplied by $\\|\\nabla v\\|_{L^2(K)}$, then taking the supremum over $v$ with respect to the energy semi-norm $\\|v\\|_{\\boldsymbol{A}}$. We focus on the Neumann boundary term. By the Cauchy–Schwarz inequality on $E$,\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\le \\|R_{E}\\|_{L^2(E)}\\, \\|v\\|_{L^2(E)}.\n$$\nThe boundary trace inequality on an element $K$ with $E \\subset \\partial K$ asserts that for every $w \\in H^{1}(K)$,\n$$\n\\|w\\|_{L^2(E)}^{2} \\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\,\\|w\\|_{L^2(K)}^{2} + h_{E}\\,\\|\\nabla w\\|_{L^2(K)}^{2} \\right).\n$$\nTo tie this to the energy semi-norm, we use a local Poincaré inequality on $K$ for functions with zero mean or vanishing on a portion of $\\partial K$ (a standard consequence of shape regularity and the construction of local test functions in residual reliability proofs): there exists a constant $C_{\\mathrm{P}}$ independent of $h$ such that\n$$\n\\|v\\|_{L^2(K)} \\le C_{\\mathrm{P}}\\, h_{K}\\, \\|\\nabla v\\|_{L^2(K)}.\n$$\nPlugging this into the trace inequality and using the shape regularity equivalence $h_{K} \\simeq h_{E}$ for $E \\subset \\partial K$, we obtain\n$$\n\\|v\\|_{L^2(E)}^{2}\n\\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\, C_{\\mathrm{P}}^{2} h_{E}^{2}\\, \\|\\nabla v\\|_{L^2(K)}^{2} + h_{E}\\, \\|\\nabla v\\|_{L^2(K)}^{2} \\right)\n\\le C\\, h_{E}\\, \\|\\nabla v\\|_{L^2(K)}^{2},\n$$\nwhere $C := C_{\\mathrm{tr}}(C_{\\mathrm{P}}^{2} + 1)$ is independent of the mesh size. Taking square roots yields\n$$\n\\|v\\|_{L^2(E)} \\le C^{1/2}\\, h_{E}^{1/2}\\, \\|\\nabla v\\|_{L^2(K)}.\n$$\nConsequently,\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\le C^{1/2}\\, h_{E}^{1/2}\\, \\|R_{E}\\|_{L^2(E)}\\, \\|\\nabla v\\|_{L^2(K)}.\n$$\nLet $\\alpha_{0}, \\alpha_{1} > 0$ be the coercivity and boundedness constants of $\\boldsymbol{A}$, that is, $\\alpha_{0}\\, |\\xi|^{2} \\le \\xi^{\\top}\\boldsymbol{A}(x)\\,\\xi \\le \\alpha_{1}\\, |\\xi|^{2}$ for all $\\xi \\in \\mathbb{R}^{2}$ and almost every $x$. Then\n$$\n\\alpha_{0}\\, \\|\\nabla v\\|_{L^2(K)}^{2} \\le \\int_{K} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx \\le \\alpha_{1}\\, \\|\\nabla v\\|_{L^2(K)}^{2},\n$$\nso $\\|\\nabla v\\|_{L^2(K)} \\lesssim \\|v\\|_{\\boldsymbol{A},K}$, where $\\|v\\|_{\\boldsymbol{A},K}^{2} := \\int_{K} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx$. Therefore,\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right| \\lesssim h_{E}^{1/2}\\, \\|R_{E}\\|_{L^2(E)}\\, \\|v\\|_{\\boldsymbol{A},K}.\n$$\nSumming this bound over all Neumann edges $E \\subset \\Gamma_{N}$ and applying the Cauchy–Schwarz inequality yields\n$$\n\\sum_{E \\subset \\Gamma_{N}} \\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\lesssim \\left( \\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{L^2(E)}^{2} \\right)^{1/2} \\left( \\sum_{E \\subset \\Gamma_{N}} \\|v\\|_{\\boldsymbol{A},K(E)}^{2} \\right)^{1/2},\n$$\nwhere $K(E)$ denotes an element attached to $E$. By finite overlap of edge patches in a shape-regular mesh, $\\sum_{E \\subset \\Gamma_{N}} \\|v\\|_{\\boldsymbol{A},K(E)}^{2} \\lesssim \\|v\\|_{\\boldsymbol{A}}^{2}$. Consequently,\n$$\n\\sum_{E \\subset \\Gamma_{N}} \\left| \\int_{E} R_{E}\\, v \\, ds \\right| \\lesssim \\left( \\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{L^2(E)}^{2} \\right)^{1/2} \\|v\\|_{\\boldsymbol{A}}.\n$$\nTaking the supremum over $v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ with $v \\neq 0$ and using the characterization of the energy semi-norm via duality,\n$$\n\\|e\\|_{\\boldsymbol{A}} \\;=\\; \\sup_{0 \\neq v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})} \\frac{\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx}{\\|v\\|_{\\boldsymbol{A}}},\n$$\nwe see that the Neumann boundary residual contributes to the reliability bound precisely through the quantity $\\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{L^2(E)}^{2}$. Therefore, to ensure\n$$\n\\|u - u_{h}\\|_{\\boldsymbol{A}}^{2} \\;\\lesssim\\; \\sum_{K \\in \\mathcal{T}_{h}} h_{K}^{2}\\,\\|r_{K}\\|_{L^2(K)}^{2} \\;+\\; \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} h_{E}\\,\\|J_{E}\\|_{L^2(E)}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{N}} h_{E}^{\\beta}\\,\\|R_{E}\\|_{L^2(E)}^{2},\n$$\nthe exponent must be $\\beta = 1$, so that the Neumann edge term scales like $h_{E}\\,\\|R_{E}\\|_{L^2(E)}^{2}$. This choice arises directly from the factor $h_{E}^{1/2}$ in the trace bound at the level of the linear form, which becomes $h_{E}$ after squaring in the estimator.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "While theoretical guarantees are crucial, many practical estimators are heuristic, relying on properties like superconvergence that may not always hold. This hands-on coding exercise explores a famous cautionary tale involving the popular Zienkiewicz-Zhu (ZZ) recovery-based estimator. You will implement and test the ZZ estimator against a guaranteed residual-based one, creating specific mesh conditions that expose a critical failure mode and lead to misleadingly large error estimates, a phenomenon known as overrefinement. ",
            "id": "3439906",
            "problem": "Consider the one-dimensional model problem for the stationary Poisson equation on the unit interval with homogeneous Dirichlet boundary conditions: find a function $u \\in H_0^1(0,1)$ such that for all test functions $v \\in H_0^1(0,1)$,\n$$\n\\int_{0}^{1} u'(x)\\,v'(x)\\,dx = \\int_{0}^{1} f(x)\\,v(x)\\,dx,\n$$\nwhere the source term is prescribed by the manufactured solution $u(x) = \\sin(2\\pi x)$, so that $f(x) = -u''(x) = (2\\pi)^2 \\sin(2\\pi x)$. This data produces smooth extrema in $u$ at $x = \\tfrac{1}{4}$ and $x = \\tfrac{3}{4}$ with $u'(x) = 0$.\n\nLet $u_h$ denote the conforming piecewise linear Continuous Galerkin finite element approximation on a given partition (mesh) of $[0,1]$ into elements $K_i = [x_i, x_{i+1}]$ with nodes $0 = x_0 < x_1 < \\dots < x_n = 1$ and element lengths $h_i = x_{i+1} - x_i$. Define the piecewise constant finite element gradient on each element $K_i$ by $g_i = \\dfrac{u_h(x_{i+1}) - u_h(x_i)}{h_i}$. Consider two standard a posteriori error estimators:\n\n1. A guaranteed residual-based estimator. For each element $K_i$, define the local residual indicator by\n$$\n\\eta_i^2 = h_i^2 \\int_{K_i} f(x)^2\\,dx + \\frac{1}{2}\\,h_i\\,J_i^2 + \\frac{1}{2}\\,h_i\\,J_{i+1}^2,\n$$\nwhere the interior flux jump at node $x_j$ is $J_j = g_j - g_{j-1}$ for $1 \\le j \\le n-1$, and $J_0 = J_n = 0$ at the Dirichlet boundaries. The global residual estimator is $\\eta = \\left(\\sum_{i=0}^{n-1} \\eta_i^2 \\right)^{1/2}$, which is known to bound the energy norm of the error with a mesh-independent constant in one dimension under standard shape regularity.\n\n2. A Zienkiewicz–Zhu (ZZ) recovery-based estimator. Recover a continuous gradient field by nodal averaging: for interior nodes $1 \\le i \\le n-1$, set\n$$\ng_i^{\\mathrm{rec}} = \\frac{h_{i-1}\\,g_{i-1} + h_i\\,g_i}{h_{i-1} + h_i},\n$$\nand at boundaries set $g_0^{\\mathrm{rec}} = g_0$ and $g_n^{\\mathrm{rec}} = g_{n-1}$. On each element $K_i$, define the recovered gradient as the linear interpolation $g^{\\mathrm{rec}}(x) = g_i^{\\mathrm{rec}}\\,\\lambda_i(x) + g_{i+1}^{\\mathrm{rec}}\\,\\lambda_{i+1}(x)$ with the local hat functions $\\lambda_i(x) = \\dfrac{x_{i+1} - x}{h_i}$ and $\\lambda_{i+1}(x) = \\dfrac{x - x_i}{h_i}$. The local ZZ indicator is\n$$\n\\zeta_i^2 = \\int_{K_i} \\left(g^{\\mathrm{rec}}(x) - g_i\\right)^2\\,dx,\n$$\nand the global ZZ estimator is $\\zeta = \\left(\\sum_{i=0}^{n-1} \\zeta_i^2 \\right)^{1/2}$.\n\nIt is known that under certain symmetry and regularity conditions the ZZ recovered gradient can exhibit superconvergence, improving accuracy by one order near interior points. However, this superconvergence can be lost in non-uniform or asymmetric meshes, especially near smooth extrema where the true gradient vanishes and changes sign. In such cases, the ZZ estimator may overrefine (i.e., produce artificially large local indicators) compared to a guaranteed residual-based estimator.\n\nYour task is to construct and analyze a counterexample demonstrating overrefinement of the ZZ estimator near a smooth extremum due to loss of superconvergence. Use the following test suite of meshes on $[0,1]$ with the manufactured source $f(x) = (2\\pi)^2 \\sin(2\\pi x)$:\n\n- Test case 1 (uniform mesh, baseline): $n = 64$ elements with nodes $x_i = \\dfrac{i}{n}$ for $i = 0,\\dots,64$.\n\n- Test case 2 (alternating perturbed patch near the extremum at $x^\\ast = \\tfrac{1}{4}$): $n = 64$ with base element size $h = \\dfrac{1}{n}$. Let $i^\\ast = \\lfloor n x^\\ast \\rfloor = 16$. For the ten-element patch $i \\in \\{i^\\ast-5, i^\\ast-4, \\dots, i^\\ast+4\\}$, prescribe alternating lengths $h_i = 0.3\\,h$ for even offsets $(i - (i^\\ast-5))$ and $h_i = 1.7\\,h$ for odd offsets; for all other elements use $h_i = h$. This construction preserves the total length $1$.\n\n- Test case 3 (strongly graded symmetric patch near $x^\\ast = \\tfrac{1}{4}$): $n = 64$ with base size $h = \\dfrac{1}{n}$. Let $m = 21$ and $r = 2$. Define a patch of $m$ elements centered at index $i^\\ast$ with lengths\n$$\nh_i = a\\,r^{\\left|i - i^\\ast\\right|}, \\quad \\text{for } i \\in \\{i^\\ast - \\tfrac{m-1}{2}, \\dots, i^\\ast + \\tfrac{m-1}{2}\\},\n$$\nwhere $a$ is chosen so that the sum of these $m$ lengths equals $m\\,h$, i.e., $a = \\dfrac{m\\,h}{\\sum_{j=-\\frac{m-1}{2}}^{\\frac{m-1}{2}} r^{|j|}}$. Outside the patch, set $h_i = h$. This produces a highly graded mesh with the smallest element at the extremum.\n\nFor each test case:\n- Assemble the piecewise linear finite element solution $u_h$.\n- Compute the elementwise residual estimator $\\eta_i$ and ZZ estimator $\\zeta_i$ as defined above.\n- Identify the \"extremum element\" index $i_{\\mathrm{ext}}$ whose midpoint is closest to $x^\\ast = 0.25$. Identify a \"far element\" index $i_{\\mathrm{far}}$ whose midpoint is closest to $x = 0.6$.\n- Compute the ratios $R_{\\mathrm{ext}} = \\dfrac{\\zeta_{i_{\\mathrm{ext}}}}{\\eta_{i_{\\mathrm{ext}}}}$ and $R_{\\mathrm{far}} = \\dfrac{\\zeta_{i_{\\mathrm{far}}}}{\\eta_{i_{\\mathrm{far}}}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a two-entry list $[R_{\\mathrm{ext}}, R_{\\mathrm{far}}]$. For example, the output format must be of the form:\n$$\n[\\,[R_{\\mathrm{ext}}^{(1)},R_{\\mathrm{far}}^{(1)}],[R_{\\mathrm{ext}}^{(2)},R_{\\mathrm{far}}^{(2)}],[R_{\\mathrm{ext}}^{(3)},R_{\\mathrm{far}}^{(3)}]\\,].\n$$\nAll values are pure real numbers; no physical units or angle units apply. The test suite is designed to reveal the misbehavior: in test case 2 and test case 3, the ratio near the extremum should significantly exceed the ratio far from the extremum, in contrast to the baseline uniform case.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the numerical analysis of partial differential equations, specifically the finite element method and a posteriori error estimation. The definitions are mathematically precise, the test cases are well-specified, and the required computations are computationally feasible. There are no contradictions, ambiguities, or factual errors. We may therefore proceed with the solution.\n\nThe core of the problem is to solve the one-dimensional Poisson equation numerically and then to compute and compare two types of a posteriori error indicators for different mesh configurations. The objective is to demonstrate a known deficiency of the Zienkiewicz-Zhu (ZZ) error estimator, namely its tendency to over-report error (overrefine) near smooth extrema on non-uniform meshes where its underlying superconvergence properties are lost.\n\nThe entire process can be broken down into the following steps, which will be implemented for each of the three test cases.\n\n1.  **Mesh Generation:** For each test case, we first construct the computational mesh, which is a set of $n+1$ nodal coordinates $x_0, x_1, \\dots, x_n$ defining $n$ elements $K_i = [x_i, x_{i+1}]$. The element lengths are denoted by $h_i = x_{i+1} - x_i$. The problem specifies $n=64$ and provides explicit rules for constructing the vector of element lengths $\\{h_i\\}_{i=0}^{n-1}$ for each of the three cases: a uniform mesh, a locally perturbed mesh, and a locally graded mesh.\n\n2.  **Finite Element Discretization:** We solve the problem using the Continuous Galerkin method with piecewise linear basis functions ($P_1$ elements). The weak formulation is: find $u \\in H_0^1(0,1)$ such that $a(u,v) = L(v)$ for all $v \\in H_0^1(0,1)$, where the bilinear form is $a(u,v) = \\int_0^1 u'(x)v'(x)dx$ and the linear functional is $L(v) = \\int_0^1 f(x)v(x)dx$.\n\n    The finite element approximation $u_h(x)$ is represented as a linear combination of nodal basis (hat) functions $\\phi_j(x)$: $u_h(x) = \\sum_{j=0}^{n} U_j \\phi_j(x)$, where $U_j = u_h(x_j)$ are the nodal values to be determined. Imposing the homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$ sets $U_0 = 0$ and $U_n = 0$.\n\n    Substituting this into the weak form and testing against each interior basis function $\\phi_k(x)$ for $k=1, \\dots, n-1$ leads to a system of linear algebraic equations, $A \\mathbf{U} = \\mathbf{b}$, for the vector of interior nodal values $\\mathbf{U} = [U_1, \\dots, U_{n-1}]^T$.\n\n    The $(n-1) \\times (n-1)$ stiffness matrix $A$ is symmetric, positive-definite, and tridiagonal, with entries given by:\n    $$\n    A_{k,j} = a(\\phi_j, \\phi_k) = \\int_0^1 \\phi_j'(x) \\phi_k'(x) dx.\n    $$\n    For $k, j \\in \\{1, \\dots, n-1\\}$, this yields:\n    $$\n    A_{k,k} = \\frac{1}{h_{k-1}} + \\frac{1}{h_k}, \\quad A_{k, k-1} = -\\frac{1}{h_{k-1}} \\text{ for } k>1, \\quad A_{k, k+1} = -\\frac{1}{h_k} \\text{ for } k<n-1.\n    $$\n    The load vector $\\mathbf{b}$ of size $n-1$ has entries:\n    $$\n    b_k = L(\\phi_k) = \\int_0^1 f(x) \\phi_k(x) dx = \\int_{x_{k-1}}^{x_{k+1}} f(x) \\phi_k(x) dx,\n    $$\n    where $f(x) = (2\\pi)^2 \\sin(2\\pi x)$. The integrals for the load vector terms must be computed numerically, for which high-order Gaussian quadrature is suitable. After solving the system $A \\mathbf{U} = \\mathbf{b}$, we have the complete finite element solution $u_h$.\n\n3.  **Computation of Estimators:** With the solution $u_h$ known, we can compute the element-wise error indicators.\n\n    **FEM Gradient:** On each element $K_i=[x_i, x_{i+1}]$, the gradient of the piecewise linear solution $u_h$ is a constant, given by $g_i = \\frac{U_{i+1} - U_i}{h_i}$.\n\n    **Residual-Based Estimator ($\\eta_i$):** This estimator is based on the local residuals of the finite element solution. For each element $K_i$, the squared indicator $\\eta_i^2$ is the sum of two terms: the element residual and the flux jump residual.\n    $$\n    \\eta_i^2 = h_i^2 \\int_{K_i} f(x)^2\\,dx + \\frac{1}{2}\\,h_i\\,J_i^2 + \\frac{1}{2}\\,h_i\\,J_{i+1}^2.\n    $$\n    The first term involves an integral of $f(x)^2$, which is computed numerically. The second and third terms involve the jump in the gradient (flux) at the element's nodes, $x_i$ and $x_{i+1}$. The jump at an interior node $x_j$ (for $j=1, \\dots, n-1$) is defined as the difference in the constant gradients of the adjacent elements: $J_j = g_j - g_{j-1}$. At the Dirichlet boundaries, the jumps are zero: $J_0 = J_n = 0$.\n\n    **Zienkiewicz–Zhu (ZZ) Estimator ($\\zeta_i$):** This estimator is based on recovering a more accurate gradient field from the raw FEM gradient.\n    First, a continuous, piecewise linear gradient field $g^{\\mathrm{rec}}(x)$ is constructed. At each interior node $x_j$, the recovered gradient is a weighted average of the FEM gradients on the adjacent elements:\n    $$\n    g_j^{\\mathrm{rec}} = \\frac{h_{j-1}\\,g_{j-1} + h_j\\,g_j}{h_{j-1} + h_j}.\n    $$\n    At the boundary nodes, the recovery is defined as $g_0^{\\mathrm{rec}} = g_0$ and $g_n^{\\mathrm{rec}} = g_{n-1}$.\n    On each element $K_i$, $g^{\\mathrm{rec}}(x)$ is the linear function interpolating the nodal values $g_i^{\\mathrm{rec}}$ and $g_{i+1}^{\\mathrm{rec}}$. The ZZ indicator $\\zeta_i$ measures the difference between this recovered gradient and the original FEM gradient $g_i$ in the $L^2$-norm on the element:\n    $$\n    \\zeta_i^2 = \\int_{K_i} (g^{\\mathrm{rec}}(x) - g_i)^2 dx.\n    $$\n    This integral can be computed exactly. By letting $E_i^* = g_i^{\\mathrm{rec}} - g_i$ and $E_{i+1}^* = g_{i+1}^{\\mathrm{rec}} - g_i$, the integral evaluates to:\n    $$\n    \\zeta_i^2 = \\frac{h_i}{3} \\left( (E_i^*)^2 + E_i^* E_{i+1}^* + (E_{i+1}^*)^2 \\right).\n    $$\n\n4.  **Analysis and Output:** For each test case, we compute the arrays of local indicators $\\{\\eta_i\\}_{i=0}^{n-1}$ and $\\{\\zeta_i\\}_{i=0}^{n-1}$. We then identify two specific elements:\n    -   $i_{\\mathrm{ext}}$: the element whose midpoint is closest to the extremum at $x^* = 0.25$.\n    -   $i_{\\mathrm{far}}$: a representative element far from the extremum, whose midpoint is closest to $x = 0.6$.\n\n    Finally, we compute the desired ratios $R_{\\mathrm{ext}} = \\zeta_{i_{\\mathrm{ext}}} / \\eta_{i_{\\mathrm{ext}}}$ and $R_{\\mathrm{far}} = \\zeta_{i_{\\mathrm{far}}} / \\eta_{i_{\\mathrm{far}}}$. These ratios compare the magnitude of the two estimators at the specified locations. The hypothesis is that for the non-uniform meshes (Cases 2 and 3), the ratio $R_{\\mathrm{ext}}$ will be significantly larger than $R_{\\mathrm{far}}$, indicating a localized failure of the ZZ estimator's accuracy near the extremum. The results from all three cases are then collected and formatted as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Define source term f(x) and its square\n    f = lambda x: (2 * np.pi)**2 * np.sin(2 * np.pi * x)\n    f_squared = lambda x: f(x)**2\n    \n    n = 64\n    h_base = 1.0 / n\n    x_star_ext = 0.25\n    x_star_far = 0.6\n\n    # Test Case 1: Uniform mesh\n    h_vec1 = np.full(n, h_base)\n\n    # Test Case 2: Alternating perturbed patch\n    h_vec2 = np.full(n, h_base)\n    i_star = int(np.floor(n * x_star_ext))  # 16\n    patch_start_idx = i_star - 5 # 11\n    patch_end_idx = i_star + 4   # 20\n    for i in range(patch_start_idx, patch_end_idx + 1):\n        offset = i - patch_start_idx\n        if offset % 2 == 0:\n            h_vec2[i] = 0.3 * h_base\n        else:\n            h_vec2[i] = 1.7 * h_base\n    # Rescale to ensure total length is exactly 1\n    h_vec2 *= 1.0 / np.sum(h_vec2)\n\n    # Test Case 3: Strongly graded symmetric patch\n    h_vec3 = np.full(n, h_base)\n    i_star = int(np.floor(n * x_star_ext)) # 16\n    m = 21\n    r = 2.0\n    patch_half_width = (m - 1) // 2 # 10\n    patch_start_idx = i_star - patch_half_width # 6\n    patch_end_idx = i_star + patch_half_width   # 26\n    \n    # Sum for scaling factor 'a'\n    sum_geom = 1.0 + 2.0 * np.sum([r**j for j in range(1, patch_half_width + 1)])\n    a = (m * h_base) / sum_geom\n    \n    for i in range(patch_start_idx, patch_end_idx + 1):\n        h_vec3[i] = a * (r**np.abs(i - i_star))\n    \n    # Rescale to ensure total length is exactly 1\n    h_vec3 *= 1.0 / np.sum(h_vec3)\n\n    test_cases = [h_vec1, h_vec2, h_vec3]\n    \n    results = []\n    for h_vec in test_cases:\n        ratios = _compute_for_case(n, h_vec, f, f_squared, x_star_ext, x_star_far)\n        results.append(ratios)\n\n    print(f\"[[{results[0][0]},{results[0][1]}],[{results[1][0]},{results[1][1]}],[{results[2][0]},{results[2][1]}]]\")\n\ndef _compute_for_case(n, h_vec, f, f_squared, x_star_ext, x_star_far):\n    \"\"\"\n    Computes the estimator ratios for a single mesh configuration.\n    \"\"\"\n    # 1. Mesh Generation\n    x_nodes = np.zeros(n + 1)\n    x_nodes[1:] = np.cumsum(h_vec)\n\n    # 2. Finite Element Solution\n    # Assemble stiffness matrix A and load vector b for interior nodes\n    A_banded = np.zeros((3, n - 1))\n    b = np.zeros(n - 1)\n\n    # Main diagonal\n    A_banded[1, :] = 1.0 / h_vec[:-1] + 1.0 / h_vec[1:]\n    # Upper diagonal\n    A_banded[0, 1:] = -1.0 / h_vec[1:-1]\n    # Lower diagonal\n    A_banded[2, :-1] = -1.0 / h_vec[1:-1]\n\n    # Assemble load vector b\n    for k in range(1, n):\n        # Integral over [x_{k-1}, x_k]\n        integrand1 = lambda x: f(x) * (x - x_nodes[k-1]) / h_vec[k-1]\n        b[k-1] += quad(integrand1, x_nodes[k-1], x_nodes[k])[0]\n        # Integral over [x_k, x_{k+1}]\n        integrand2 = lambda x: f(x) * (x_nodes[k+1] - x) / h_vec[k]\n        b[k-1] += quad(integrand2, x_nodes[k], x_nodes[k+1])[0]\n\n    # Solve for interior nodal values U\n    U_interior = solve_banded((1, 1), A_banded, b)\n    U = np.concatenate(([0], U_interior, [0]))\n\n    # 3. Compute Estimators\n    # FEM gradient g_i on each element K_i\n    g = (U[1:] - U[:-1]) / h_vec\n    \n    # --- Residual Estimator ---\n    eta_sq = np.zeros(n)\n    # Flux jumps J_j at each interior node x_j\n    Jumps = np.zeros(n + 1)\n    Jumps[1:n] = g[1:] - g[:-1]\n    \n    for i in range(n):\n        # Element residual term\n        term1 = h_vec[i]**2 * quad(f_squared, x_nodes[i], x_nodes[i+1])[0]\n        # Jump residual term\n        term2 = 0.5 * h_vec[i] * (Jumps[i]**2 + Jumps[i+1]**2)\n        eta_sq[i] = term1 + term2\n\n    # --- ZZ Estimator ---\n    zeta_sq = np.zeros(n)\n    # Recovered gradient g_rec at nodes\n    g_rec = np.zeros(n + 1)\n    g_rec[0] = g[0]\n    g_rec[n] = g[n-1]\n    g_rec[1:n] = (h_vec[:-1] * g[:-1] + h_vec[1:] * g[1:]) / (h_vec[:-1] + h_vec[1:])\n\n    for i in range(n):\n        # Integral of (g_rec(x) - g_i)^2 over K_i\n        E_i_star = g_rec[i] - g[i]\n        E_i1_star = g_rec[i+1] - g[i]\n        zeta_sq[i] = (h_vec[i] / 3.0) * (E_i_star**2 + E_i_star * E_i1_star + E_i1_star**2)\n\n    # 4. Analysis\n    midpoints = (x_nodes[:-1] + x_nodes[1:]) / 2.0\n    i_ext = np.argmin(np.abs(midpoints - x_star_ext))\n    i_far = np.argmin(np.abs(midpoints - x_star_far))\n    \n    zeta_i_ext = np.sqrt(zeta_sq[i_ext])\n    eta_i_ext = np.sqrt(eta_sq[i_ext])\n    \n    zeta_i_far = np.sqrt(zeta_sq[i_far])\n    eta_i_far = np.sqrt(eta_sq[i_far])\n    \n    R_ext = zeta_i_ext / eta_i_ext if eta_i_ext > 1e-12 else 0.0\n    R_far = zeta_i_far / eta_i_far if eta_i_far > 1e-12 else 0.0\n\n    return [R_ext, R_far]\n\nsolve()\n```"
        },
        {
            "introduction": "Our exploration culminates in the domain of high-order discretizations, such as the Spectral Element Method, where estimator design presents unique challenges and opportunities. This advanced problem requires you to compare strong-form and weak-form residual estimators, which can behave differently in a high-order context, and to implement a sophisticated recovery-based indicator. You will use modal filtering to improve the recovered solution's quality, a powerful technique for handling numerical artifacts like Gibbs oscillations that arise when approximating non-smooth solutions with high-degree polynomials. ",
            "id": "3439891",
            "problem": "You are asked to implement, compare, and analyze three a posteriori error indicators for a one-dimensional elliptic model problem discretized by a high-order Spectral Element Method (SEM) with Gauss–Lobatto–Legendre (GLL) nodes. The three indicators are: a strong-form residual estimator, a weak-form residual estimator, and a recovery-based estimator that projects to a filtered polynomial basis to mitigate Gibbs-type oscillations.\n\nThe model problem is the scalar elliptic boundary-value problem on the unit interval:\nFind a function $u : [0,1] \\to \\mathbb{R}$ such that\n$$\n- u''(x) = f(x) \\quad \\text{for } x \\in (0,1), \\qquad u(0) = 0, \\quad u(1) = 0.\n$$\nYou will not solve the discrete system. Instead, you will construct a nodal SEM interpolant $u_h$ of a prescribed exact function $u$ at elementwise GLL nodes, and then evaluate error indicators for this $u_h$ and a corresponding source $f$. This isolates and compares the estimators in a controlled setting. All integrals must be approximated by GLL quadrature of order $p$ on each element.\n\nBase definitions and discretization ingredients you must use:\n- Spectral Element Method (SEM) with $E$ elements partitioning $[0,1]$ into subintervals $K = [x_L, x_R]$ of length $h_K = x_R - x_L$. Each element uses polynomial degree $p \\in \\mathbb{N}$ and GLL nodes $\\{\\xi_i\\}_{i=0}^p$ on $[-1,1]$, with corresponding GLL weights $\\{w_i\\}_{i=0}^p$.\n- The mapping from reference coordinate $\\xi \\in [-1,1]$ to physical coordinate is $x(\\xi) = \\frac{x_R - x_L}{2} \\, \\xi + \\frac{x_R + x_L}{2}$ with Jacobian $J_K = \\frac{h_K}{2}$.\n- The SEM interpolant $u_h$ is defined by evaluating $u(x)$ at element nodes $\\{x_i\\}_{i=0}^p$ mapped from $\\{\\xi_i\\}_{i=0}^p$ and using the Lagrange basis on GLL nodes as usual. Its nodal gradient on $K$ is computed with the GLL differentiation matrix $D$ on $[-1,1]$ via\n$$\n\\left.\\frac{d u_h}{d x}\\right|_{x_i} \\;=\\; \\frac{1}{J_K} \\sum_{j=0}^p D_{ij}\\, u_h(x_j),\n$$\nand the nodal second derivative by\n$$\n\\left.\\frac{d^2 u_h}{d x^2}\\right|_{x_i} \\;=\\; \\frac{1}{J_K^2} \\sum_{j=0}^p (D^2)_{ij} \\, u_h(x_j), \\quad \\text{where } D^2 := D \\, D.\n$$\n- The element mass and stiffness matrices, evaluated by GLL quadrature, are\n$$\nM_K = J_K \\,\\mathrm{diag}(w_0,\\dots,w_p), \\qquad\nK_K = \\frac{1}{J_K} \\, D^\\top \\, \\mathrm{diag}(w_0,\\dots,w_p) \\, D.\n$$\n- The weak-form element residual vector for $u_h$ is\n$$\nr_K \\;=\\; M_K \\, f_h \\;-\\; K_K \\, u_h, \\quad \\text{where } (f_h)_i = f(x_i).\n$$\n- The strong-form pointwise residual at element nodes is\n$$\n\\rho_K(x_i) \\;=\\; f(x_i) \\;+\\; \\left.\\frac{d^2 u_h}{d x^2}\\right|_{x_i}.\n$$\n- The gradient jump at an internal interface $x_e$ shared by neighboring elements $K^-$ and $K^+$ is\n$$\n\\llbracket u_h' \\rrbracket_{x_e} \\;=\\; \\left.\\frac{d u_h}{d x}\\right|_{K^+,\\,x_e} \\;-\\; \\left.\\frac{d u_h}{d x}\\right|_{K^-,\\,x_e}.\n$$\n\nDefine the three global error indicators as follows:\n- Strong-form residual estimator\n$$\n\\eta_{\\mathrm{s}}^2 \\;=\\; \\sum_{K} \\left[ h_K^2 \\, \\int_K \\rho_K(x)^2 \\, dx \\right] \\;+\\; \\sum_{x_e \\in \\mathcal{E}_\\mathrm{int}} h_e \\, \\llbracket u_h' \\rrbracket_{x_e}^2,\n$$\nwhere $h_e$ is the average of the lengths of the two adjacent elements, and the element integral is evaluated by GLL quadrature as\n$$\n\\int_K \\rho_K(x)^2 \\, dx \\;\\approx\\; J_K \\sum_{i=0}^p w_i \\, \\rho_K(x_i)^2.\n$$\n- Weak-form residual estimator\n$$\n\\eta_{\\mathrm{w}}^2 \\;=\\; \\sum_{K} \\left[ h_K^2 \\, r_K^\\top \\, M_K^{-1} \\, r_K \\right] \\;+\\; \\sum_{x_e \\in \\mathcal{E}_\\mathrm{int}} h_e \\, \\llbracket u_h' \\rrbracket_{x_e}^2.\n$$\n- Recovery-based filtered estimator. First define a recovered gradient $q_K^{\\mathrm{rec}}$ on each element by projecting the discrete gradient $q_K := du_h/dx$ onto the elementwise Legendre polynomial basis $\\{L_k(\\xi)\\}_{k=0}^p$ using GLL quadrature to compute modal coefficients\n$$\nc_k \\;=\\; \\frac{2k+1}{2} \\sum_{i=0}^p w_i \\, q_K(\\xi_i) \\, L_k(\\xi_i), \\qquad k=0,\\dots,p,\n$$\napply a modal filter\n$$\n\\sigma_k \\;=\\; \\exp\\!\\left( - \\alpha \\, \\left(\\frac{k}{p}\\right)^m \\right), \\quad \\alpha > 0,\\; m \\in 2\\mathbb{N},\n$$\nto obtain filtered modal coefficients $\\widehat{c}_k = \\sigma_k \\, c_k$, and reconstruct the recovered gradient by\n$$\nq_K^{\\mathrm{rec}}(\\xi_i) \\;=\\; \\sum_{k=0}^p \\widehat{c}_k \\, L_k(\\xi_i).\n$$\nThen define the recovered second derivative at nodes by\n$$\n\\left.\\frac{d^2 u_h}{d x^2}\\right|_{\\mathrm{rec},\\,x_i} \\;=\\; \\frac{1}{J_K} \\sum_{j=0}^p D_{ij} \\, q_K^{\\mathrm{rec}}(\\xi_j),\n$$\nand the recovered residual $\\rho_K^{\\mathrm{rec}}(x_i) = f(x_i) + \\left.\\frac{d^2 u_h}{d x^2}\\right|_{\\mathrm{rec},\\,x_i}$. Finally set\n$$\n\\eta_{\\mathrm{rec}}^2 \\;=\\; \\sum_{K} \\left[ h_K^2 \\, \\int_K \\left(\\rho_K^{\\mathrm{rec}}(x)\\right)^2 \\, dx \\right] \\;+\\; \\sum_{x_e \\in \\mathcal{E}_\\mathrm{int}} h_e \\, \\left( \\llbracket q^{\\mathrm{rec}} \\rrbracket_{x_e} \\right)^2,\n$$\nwhere the jump uses the recovered gradient $q^{\\mathrm{rec}}$ at interfaces.\n\nImplementation details and fundamental bases you must use:\n- Use the Gauss–Lobatto–Legendre (GLL) nodes and weights of order $p$; the nodes are $\\xi_0=-1$, $\\xi_p=1$ and the interior nodes are the roots of the derivative of the Legendre polynomial $P_p'$, and the GLL weights are $w_i = \\dfrac{2}{p(p+1)} \\dfrac{1}{P_p(\\xi_i)^2}$.\n- Construct the reference differentiation matrix $D$ for the Lagrange basis at GLL nodes via barycentric weights $\\lambda_j = \\prod_{k \\neq j} (\\xi_j - \\xi_k)^{-1}$ and\n$$\nD_{ij} \\;=\\; \\begin{cases}\n\\dfrac{\\lambda_j}{\\lambda_i} \\dfrac{1}{\\xi_i - \\xi_j}, & i \\ne j,\\\n$$6pt]\n- \\sum_{\\ell \\ne i} D_{i\\ell}, & i=j.\n\\end{cases}\n$$\n- Use Legendre polynomials $\\{L_k\\}_{k=0}^p$ on $[-1,1]$ for the recovery projection with the exact GLL orthogonality property: for $k,m \\le p$, $\\int_{-1}^1 L_k(\\xi) L_m(\\xi) \\, d\\xi = \\dfrac{2}{2k+1} \\delta_{km}$.\n\nYour program must implement the above and evaluate the three global indicators $\\eta_{\\mathrm{s}}$, $\\eta_{\\mathrm{w}}$, and $\\eta_{\\mathrm{rec}}$ for the following test suite of cases, each defined by the number of elements $E$, polynomial degree $p$, and the exact function $u$ with its source $f$:\n- Case A (smooth, well-resolved): $E=2$, $p=10$, $u(x) = \\sin(2\\pi x)$, $f(x) = (2\\pi)^2 \\sin(2\\pi x)$.\n- Case B (non-smooth, interface-aligned kink): $E=2$, $p=10$, $u(x) = |x - \\tfrac{1}{2}| - \\tfrac{1}{2}$, and set $f(x) = 0$ for all $x$ (this corresponds to a point-load at $x=\\tfrac{1}{2}$ in the distributional sense but for the purpose of residual computation you must use the zero function; the kink aligns with the inter-element interface at $x=\\tfrac{1}{2}$).\n- Case C (non-smooth, kink inside an element): $E=3$, $p=10$, $u(x) = |x - \\tfrac{1}{2}| - \\tfrac{1}{2}$, and set $f(x) = 0$ for all $x$ (the kink is in the interior of the middle element).\n- Case D (smooth, under-resolved): $E=2$, $p=6$, $u(x) = \\sin(20\\pi x)$, $f(x) = (20\\pi)^2 \\sin(20\\pi x)$.\n\nUse the modal filter parameters $\\alpha = 36$ and $m = 8$. For each case, form the uniform mesh of $E$ equal-length elements on $[0,1]$.\n\nAngle units and physical units: This task is purely mathematical. No physical unit conversion is required.\n\nYour program must output the results in the following format: a single line containing a list of four items (one per case), where each item is itself a list of three floating-point numbers $[\\eta_{\\mathrm{s}}, \\eta_{\\mathrm{w}}, \\eta_{\\mathrm{rec}}]$ in this order. For example, the output format is\n\"[ [sA,wA,rA], [sB,wB,rB], [sC,wC,rC], [sD,wD,rD] ]\"\nwith actual numeric values substituted. Only this single line should be printed.\n\nThe solution must be a complete, runnable program as specified, using the provided definitions and test suite, and must use the exact numerical procedures described above without external data or user input. The final numerical answers for each test case must be floating-point numbers.",
            "solution": "The user's request is a well-defined computational problem in the field of numerical analysis for partial differential equations. It asks for the implementation and comparison of three a posteriori error indicators for a one-dimensional spectral element discretization.\n\n### Step 1: Problem Validation\n\n**1.1. Givens Extraction:**\n- **Model Problem:** $-u''(x) = f(x)$ on $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$.\n- **Discretization:** Spectral Element Method (SEM) using $E$ elements of degree $p$ with Gauss–Lobatto–Legendre (GLL) nodes and weights.\n- **Interpolant:** The numerical solution $u_h$ is the nodal interpolant of a given exact solution $u(x)$.\n- **Mathematical tools:** Specific formulas are provided for:\n    - GLL nodes $\\{\\xi_i\\}$, weights $\\{w_i\\}$, and differentiation matrix $D$.\n    - Mappings from reference to physical coordinates and the Jacobian $J_K$.\n    - Nodal first and second derivatives of $u_h$ using $D$ and $D^2 = D \\cdot D$.\n    - Element mass ($M_K$) and stiffness ($K_K$) matrices via GLL quadrature.\n    - Strong-form residual $\\rho_K$ and weak-form residual vector $r_K$.\n    - Gradient jump $\\llbracket u_h' \\rrbracket$ at inter-element faces.\n- **Error Indicators:** Explicit formulas for three estimators are given:\n    1.  $\\eta_{\\mathrm{s}}^2$ (strong-form residual based).\n    2.  $\\eta_{\\mathrm{w}}^2$ (weak-form residual based).\n    3.  $\\eta_{\\mathrm{rec}}^2$ (recovery-based with a specified modal filter).\n- **Test Suite:** Four distinct cases are defined by parameters $(E, p)$ and functions $(u, f)$, covering smooth, non-smooth, well-resolved, and under-resolved scenarios.\n- **Filter Parameters:** For the recovery estimator, $\\alpha=36$ and $m=8$.\n- **Output:** A single-line string representing a list of lists of the three computed indicators for each case.\n\n**1.2. Validation against Criteria:**\n- **Scientifically Grounded:** The problem is firmly rooted in the theory of a posteriori error estimation for FEM/SEM, a standard topic in numerical analysis. All provided formulas and concepts are standard or well-defined modifications of standard techniques.\n- **Well-Posed:** The task is to compute three definite numerical quantities based on a complete set of inputs and formulas. The problem is unambiguous and yields a unique solution.\n- **Objective:** The language is entirely mathematical and devoid of subjectivity.\n- **Completeness and Consistency:** All necessary parameters, functions, and formulas are provided. The definitions are mathematically consistent with each other (e.g., element matrices derived from the basis and quadrature rules). For instance, the K-matrix is the correct weak form of the Laplacian operator under GLL quadrature.\n- **Feasibility:** The problem is a standard, albeit non-trivial, numerical implementation task that is computationally feasible.\n\n**1.3. Verdict:**\nThe problem statement is valid, complete, and well-posed. It constitutes a standard numerical experiment for comparing error estimators. The solution will proceed as requested.\n\n### Step 2: Solution Implementation strategy\n\nThe solution will be implemented in Python using the `numpy` library. The overall structure will consist of a main `solve` function that orchestrates the computation for all test cases and a set of helper functions.\n\n**2.1. Foundational Routines:**\nA helper function, `get_gll_data(p)`, will be created to compute the fundamental components for a given polynomial degree $p$:\n- **GLL Nodes ($\\xi$):** The roots of the derivative of the Legendre polynomial of degree $p$, $P_p'(\\xi)$, augmented with the interval endpoints $-1$ and $1$. These will be computed using `numpy.polynomial.legendre.Legendre.basis(p).deriv().roots()`.\n- **GLL Weights ($w$):** Calculated using the provided formula $w_i = \\frac{2}{p(p+1)P_p(\\xi_i)^2}$.\n- **Differentiation Matrix ($D$):** Constructed using the specified barycentric interpolation formula, which is robust for arbitrary node sets. The diagonal elements are determined by the property that the derivative of a constant is zero.\n\n**2.2. Per-Case Computation:**\nA function `solve_case` will encapsulate the logic for a single test case $(E, p, u, f, \\alpha, m)$. Its steps are:\n1.  **Mesh and Basis Setup:** Define the uniform mesh of $E$ elements. Pre-compute the GLL data $(\\xi, w, D)$ and the second-derivative matrix $D^2 = D \\cdot D$. A matrix `Lmat` containing values of Legendre polynomials $L_k(\\xi_i)$ at the GLL nodes will also be pre-computed for the recovery estimator.\n2.  **Element Loop:** Iterate through each element $K$ of the mesh.\n    -   Map the reference GLL nodes to physical nodes on the element.\n    -   Evaluate the given $u(x)$ and $f(x)$ at these nodes to obtain the nodal vectors $u_{h,K}$ and $f_{h,K}$.\n    -   Compute the nodal first derivative ($q_k$) and second derivative ($u''_{h,K}$) using $D$ and $D^2$.\n    -   Store the first derivative values at the element's start and end points for later jump calculations.\n    -   **Strong-Form Estimator ($\\eta_s$):** Compute the element residual $\\rho_K = f_{h,K} + u''_{h,K}$ and add its scaled, squared norm to a running total for $\\eta_s^2$.\n    -   **Weak-Form Estimator ($\\eta_w$):** Assemble the element residual vector $r_K = M_K f_{h,K} - K_K u_{h,K}$ and add its scaled, squared norm in the dual of the mass matrix, $h_K^2 r_K^T M_K^{-1} r_K$, to a running total for $\\eta_w^2$.\n    -   **Recovery-Based Estimator ($\\eta_{rec}$):**\n        -   Project the nodal gradient $q_k$ onto the Legendre basis to get modal coefficients $c_k$.\n        -   Apply the specified exponential filter to get filtered coefficients $\\hat{c}_k$.\n        -   Reconstruct the filtered gradient $q_k^{\\mathrm{rec}}$ at the nodes.\n        -   Store the recovered gradient values at the element's endpoints.\n        -   Compute the recovered second derivative and the recovered residual $\\rho_K^{\\mathrm{rec}}$.\n        -   Add the scaled, squared norm of $\\rho_K^{\\mathrm{rec}}$ to a running total for $\\eta_{rec}^2$.\n3.  **Interface Jumps:** After the element loop, iterate through the internal interfaces.\n    -   Calculate the jump in the standard gradient, $\\llbracket u_h' \\rrbracket$, and add its contribution ($h_e \\llbracket u_h' \\rrbracket^2$) to both $\\eta_s^2$ and $\\eta_w^2$.\n    -   Calculate the jump in the recovered gradient, $\\llbracket q^{\\mathrm{rec}} \\rrbracket$, and add its contribution ($h_e \\llbracket q^{\\mathrm{rec}} \\rrbracket^2$) to $\\eta_{rec}^2$.\n4.  **Finalization:** Compute the final indicators by taking the square root of the total squared sums. Return the three values in a list.\n\n**2.3. Main Driver:**\nThe main `solve()` function will define the four test cases, call `solve_case` for each, collect the results, and print them in the exact string format specified in the problem statement.",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import Legendre\n\ndef get_gll_data(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes (xi), weights (w), and the \n    first-derivative spectral differentiation matrix (D) for a given polynomial degree p.\n    \"\"\"\n    if p == 0:\n        return np.array([-1.0], dtype=np.float64), np.array([2.0], dtype=np.float64), np.array([[0.0]], dtype=np.float64)\n    \n    n = p + 1\n    \n    # GLL nodes: {-1, 1} and the roots of the derivative of the p-th degree Legendre polynomial.\n    if p > 1:\n        Lp_deriv_roots = Legendre.basis(p).deriv().roots()\n        xi = np.concatenate(([-1.0], np.sort(Lp_deriv_roots), [1.0]))\n    else:  # p=1\n        xi = np.array([-1.0, 1.0])\n\n    # GLL weights using the formula w_i = 2 / (p(p+1) * L_p(xi_i)^2)\n    Lp_vals_at_xi = Legendre.basis(p)(xi)\n    w = 2.0 / (p * (p + 1) * Lp_vals_at_xi**2)\n\n    # Differentiation matrix D using the barycentric formula.\n    D = np.zeros((n, n), dtype=np.float64)\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            D[i, j] = Legendre.basis(p)(xi[j]) / (Legendre.basis(p)(xi[i]) * (xi[j] - xi[i]))\n    \n    # Diagonal entries are set such that the derivative of a constant is zero.\n    np.fill_diagonal(D, 0.0)\n    D_diag = -np.sum(D, axis=1)\n    np.fill_diagonal(D, D_diag)\n\n    return xi.astype(np.float64), w.astype(np.float64), D.astype(np.float64)\n\n\ndef solve_case(E, p, u_func, f_func, alpha, m):\n    \"\"\"\n    Computes the three error indicators for a single test case.\n    \"\"\"\n    # 1. Setup\n    hK = 1.0 / E\n    Jk = hK / 2.0\n    \n    xi, w, D = get_gll_data(p)\n    D2 = D @ D\n    \n    n_nodes = p + 1\n    \n    # Pre-compute Legendre polynomial values at GLL nodes for recovery projection.\n    Lmat = np.zeros((n_nodes, n_nodes))\n    for k in range(n_nodes):\n        Lmat[:, k] = Legendre.basis(k)(xi)\n\n    # Storage for interface gradients\n    q_R = np.zeros(E, dtype=np.float64) # grad at right end of element e\n    q_L = np.zeros(E, dtype=np.float64) # grad at left end of element e\n    q_rec_R = np.zeros(E, dtype=np.float64)\n    q_rec_L = np.zeros(E, dtype=np.float64)\n    \n    eta_s_sq_elem, eta_w_sq_elem, eta_rec_sq_elem = 0.0, 0.0, 0.0\n    \n    # 2. Loop over Elements\n    for e in range(E):\n        xL = e * hK\n        x_nodes = xL + Jk * (xi + 1.0)\n        \n        u_h_k = u_func(x_nodes)\n        f_h_k = f_func(x_nodes)\n        \n        # --- Derivatives ---\n        q_k = (1.0 / Jk) * (D @ u_h_k) # du_h/dx at nodes\n        q_L[e], q_R[e] = q_k[0], q_k[-1]\n        \n        u_pp_k = (1.0 / Jk**2) * (D2 @ u_h_k) # d^2u_h/dx^2 at nodes\n        \n        # --- Strong-form estimator element contribution ---\n        rho_k = f_h_k + u_pp_k\n        eta_s_sq_elem += hK**2 * Jk * np.sum(w * rho_k**2)\n\n        # --- Weak-form estimator element contribution ---\n        Kk = (1.0 / Jk) * (D.T @ np.diag(w) @ D)\n        Mk = Jk * np.diag(w)\n        r_k = (Mk @ f_h_k) - (Kk @ u_h_k)\n        eta_w_sq_elem += hK**2 * (r_k.T @ np.linalg.inv(Mk) @ r_k)\n\n        # --- Recovery-based estimator element contribution ---\n        c_k = np.zeros(n_nodes)\n        for k in range(n_nodes):\n           c_k[k] = ((2*k + 1) / 2.0) * np.sum(w * q_k * Lmat[:, k])\n        \n        k_scaled = np.arange(n_nodes, dtype=np.float64) / p if p > 0 else np.zeros(n_nodes)\n        sigma = np.exp(-alpha * (k_scaled**m))\n        c_hat_k = sigma * c_k\n        \n        q_rec_k = Lmat @ c_hat_k\n        q_rec_L[e], q_rec_R[e] = q_rec_k[0], q_rec_k[-1]\n        \n        u_pp_rec_k = (1.0 / Jk) * (D @ q_rec_k)\n        rho_rec_k = f_h_k + u_pp_rec_k\n        eta_rec_sq_elem += hK**2 * Jk * np.sum(w * rho_rec_k**2)\n\n    # 3. Interface jump terms\n    eta_s_sq_jump, eta_rec_sq_jump = 0.0, 0.0\n    h_e = hK # For uniform mesh\n\n    for e_int in range(1, E): # Loop over internal interfaces\n        jump_q = q_L[e_int] - q_R[e_int - 1]\n        eta_s_sq_jump += h_e * jump_q**2\n        \n        jump_q_rec = q_rec_L[e_int] - q_rec_R[e_int - 1]\n        eta_rec_sq_jump += h_e * jump_q_rec**2\n        \n    # Weak-form jump term is the same as strong-form's\n    eta_w_sq_jump = eta_s_sq_jump\n    \n    # 4. Final combination\n    eta_s = np.sqrt(eta_s_sq_elem + eta_s_sq_jump)\n    eta_w = np.sqrt(eta_w_sq_elem + eta_w_sq_jump)\n    eta_rec = np.sqrt(eta_rec_sq_elem + eta_rec_sq_jump)\n    \n    return [eta_s, eta_w, eta_rec]\n\ndef solve():\n    pi = np.pi\n\n    test_cases = [\n        # Case A (smooth, well-resolved)\n        {'E': 2, 'p': 10, 'u': lambda x: np.sin(2*pi*x), 'f': lambda x: (2*pi)**2 * np.sin(2*pi*x)},\n        # Case B (non-smooth, interface-aligned kink)\n        {'E': 2, 'p': 10, 'u': lambda x: np.abs(x - 0.5) - 0.5, 'f': lambda x: 0.0*x if isinstance(x, np.ndarray) else 0.0},\n        # Case C (non-smooth, kink inside an element)\n        {'E': 3, 'p': 10, 'u': lambda x: np.abs(x - 0.5) - 0.5, 'f': lambda x: 0.0*x if isinstance(x, np.ndarray) else 0.0},\n        # Case D (smooth, under-resolved)\n        {'E': 2, 'p': 6,  'u': lambda x: np.sin(20*pi*x), 'f': lambda x: (20*pi)**2 * np.sin(20*pi*x)},\n    ]\n    \n    filter_params = {'alpha': 36, 'm': 8}\n    \n    results = []\n    for case in test_cases:\n        res = solve_case(E=case['E'], p=case['p'], u_func=case['u'], f_func=case['f'], \n                         alpha=filter_params['alpha'], m=filter_params['m'])\n        results.append(res)\n        \n    # Format output string exactly as requested\n    inner_results_str = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_str)\n\nsolve()\n```"
        }
    ]
}