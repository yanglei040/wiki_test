{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a foundational, hands-on calculation of a residual-based a posteriori error estimator. By manually computing the element and edge jump residuals for a simple Poisson problem, you will gain a concrete understanding of where these quantities come from and how they quantify the local error in a finite element solution. This practice is essential for demystifying the components of the estimators that drive adaptive algorithms .",
            "id": "3359755",
            "problem": "Consider the model elliptic partial differential equation (PDE) $-\\Delta u = f$ in the unit square domain $\\Omega = (0,1)^2$ with homogeneous Dirichlet boundary conditions $u=0$ on $\\partial \\Omega$. Let $\\mathcal{T}_h$ be a conforming triangulation of $\\Omega$ consisting of two triangles obtained by splitting the square along the diagonal from $(0,0)$ to $(1,1)$:\n- $K_1 = \\operatorname{conv}\\{(0,0),(1,0),(1,1)\\}$,\n- $K_2 = \\operatorname{conv}\\{(0,0),(1,1),(0,1)\\}$.\nThe interior edge (face) is $F = \\operatorname{conv}\\{(0,0),(1,1)\\}$.\n\nLet $u_h \\in V_h$ be the conforming $\\mathbb{P}_1$ (piecewise-linear) finite element function determined by the nodal values\n$u_h(0,0)=0$, $u_h(1,0)=1$, $u_h(1,1)=2$, $u_h(0,1)=0.7$, and let $f \\equiv 1$ in $\\Omega$. Assume the symmetric diffusion tensor is the identity, so the operator is $-\\Delta$. For each element $K \\in \\mathcal{T}_h$, denote its diameter by $h_K$ (the largest distance between any two vertices of $K$), and for each edge $F$ denote its length by $h_F$. For any subdomain $D \\subset \\mathbb{R}^2$, write the $L^2$ norm as $\\|g\\|_{0,D}^2 = \\int_D |g|^2$.\n\nStarting from the weak formulation and Green's identity, derive explicit residual-based formulas for the element indicator $\\eta_K$ and the interior-edge indicator $\\eta_F$ that depend only on local integrals and the known piecewise-constant gradients $\\nabla u_h|_K$. Then, using these formulas:\n- compute $\\eta_{K_1}$ on the element $K_1$ with $h_{K_1}$ chosen as its diameter,\n- compute $\\eta_F$ on the interior edge $F$ with $h_F$ chosen as the edge length,\nand define the combined local indicator for $K_1$ by\n$$\n\\Theta(K_1) = \\sqrt{\\eta_{K_1}^{2} + \\frac{1}{2}\\,\\eta_{F}^{2}}.\n$$\n\nExpress the final value of $\\Theta(K_1)$ as a single simplified analytic expression. No numerical rounding is required, and no physical units are involved.",
            "solution": "The problem asks for the computation of a local a posteriori error indicator for a given piecewise-linear function $u_h$ on a specific triangulation of the unit square $\\Omega = (0,1)^2$ for the Poisson problem $-\\Delta u = f$.\n\nFirst, we must derive the formulas for the residual-based error indicators. The starting point is the weak formulation of the problem: find $u \\in H_0^1(\\Omega)$ such that for all test functions $v \\in H_0^1(\\Omega)$,\n$$\n\\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_\\Omega f v \\, d\\mathbf{x}.\n$$\nLet $e = u - u_h$ be the error, where $u_h \\in V_h$ is the given finite element function. For any $v \\in H_0^1(\\Omega)$, the error equation is\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\int_\\Omega f v \\, d\\mathbf{x} - \\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x}.\n$$\nWe apply integration by parts (Green's identity) element-wise to the term involving $u_h$:\n$$\n\\int_\\Omega \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\nabla u_h \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\left( \\int_K (-\\Delta u_h) v \\, d\\mathbf{x} + \\int_{\\partial K} (\\nabla u_h \\cdot \\mathbf{n}_K) v \\, ds \\right),\n$$\nwhere $\\mathbf{n}_K$ is the outward unit normal to the boundary $\\partial K$ of element $K$. Substituting this into the error equation yields:\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) v \\, d\\mathbf{x} - \\sum_{K \\in \\mathcal{T}_h} \\int_{\\partial K} (\\nabla u_h \\cdot \\mathbf{n}_K) v \\, ds.\n$$\nThe sum over element boundaries can be reorganized as a sum over all edges (or faces) $\\mathcal{F}_h$ of the triangulation. For an interior edge $F$ shared by two elements $K_1$ and $K_2$, its contribution is $\\int_F (\\nabla u_h|_{K_1} \\cdot \\mathbf{n}_1 + \\nabla u_h|_{K_2} \\cdot \\mathbf{n}_2) v \\, ds$. This term in parentheses is defined as the jump of the normal flux across $F$, denoted $\\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F$. Since $v=0$ on $\\partial\\Omega$, the boundary edge terms vanish. The error equation becomes:\n$$\n\\int_\\Omega \\nabla e \\cdot \\nabla v \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) v \\, d\\mathbf{x} - \\sum_{F \\in \\mathcal{F}_h^i} \\int_F \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F v \\, ds,\n$$\nwhere $\\mathcal{F}_h^i$ is the set of interior edges. The a posteriori error analysis bounds the error norm $\\| \\nabla e \\|_{0,\\Omega}$ by a quantity (the error estimator) that depends on the element residuals $R_K = f + \\Delta u_h$ and the edge jump residuals $J_F = \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket_F$.\n\nThe standard definitions for the local error indicators, which we adopt here, are:\n- The element indicator for an element $K$: $\\eta_K = h_K \\| R_K \\|_{0,K} = h_K \\| f + \\Delta u_h \\|_{0,K}$.\n- The edge indicator for an interior edge $F$: $\\eta_F = h_F^{1/2} \\| J_F \\|_{0,F} = h_F^{1/2} \\| \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket \\|_{0,F}$.\n\nThe problem provides a conforming $\\mathbb{P}_1$ finite element function $u_h$, which is piecewise linear. Therefore, its Laplacian $\\Delta u_h$ is zero within the interior of each element $K$. The formulas simplify to:\n- $\\eta_K = h_K \\| f \\|_{0,K}$.\n- $\\eta_F = h_F^{1/2} \\| \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket \\|_{0,F}$.\n\nNow we compute these quantities for the given setup.\nThe triangulation consists of two triangles:\n- $K_1 = \\operatorname{conv}\\{(0,0),(1,0),(1,1)\\}$, a right triangle with area $|K_1| = 1/2$.\n- $K_2 = \\operatorname{conv}\\{(0,0),(1,1),(0,1)\\}$, a right triangle with area $|K_2| = 1/2$.\nThe interior edge is $F = \\operatorname{conv}\\{(0,0),(1,1)\\}$.\n\nThe function $u_h$ is linear on each element.\nOn $K_1$, $u_h(x,y) = a_1 x + b_1 y + c_1$. Using the nodal values $u_h(0,0)=0$, $u_h(1,0)=1$, $u_h(1,1)=2$:\n- $u_h(0,0) = c_1 = 0$.\n- $u_h(1,0) = a_1 = 1$.\n- $u_h(1,1) = a_1 + b_1 = 2 \\implies 1 + b_1 = 2 \\implies b_1 = 1$.\nSo, $u_h|_{K_1}(x,y) = x+y$. The gradient on $K_1$ is constant: $\\nabla u_h|_{K_1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$.\n\nOn $K_2$, $u_h(x,y) = a_2 x + b_2 y + c_2$. Using the nodal values $u_h(0,0)=0$, $u_h(0,1)=0.7$, $u_h(1,1)=2$:\n- $u_h(0,0) = c_2 = 0$.\n- $u_h(0,1) = b_2 = 0.7$.\n- $u_h(1,1) = a_2 + b_2 = 2 \\implies a_2 + 0.7 = 2 \\implies a_2 = 1.3$.\nSo, $u_h|_{K_2}(x,y) = 1.3x + 0.7y$. The gradient on $K_2$ is constant: $\\nabla u_h|_{K_2} = \\begin{pmatrix} 1.3 \\\\ 0.7 \\end{pmatrix}$.\n\nNext, we compute the indicators $\\eta_{K_1}$ and $\\eta_F$.\n\n**Calculation of $\\eta_{K_1}$**:\n- The diameter of $K_1$, $h_{K_1}$, is the length of its longest side. The side lengths are $1$, $1$, and $\\sqrt{(1-0)^2 + (1-0)^2} = \\sqrt{2}$. Thus, $h_{K_1} = \\sqrt{2}$.\n- The source function is $f \\equiv 1$.\n- $\\|f\\|_{0,K_1}^2 = \\int_{K_1} f^2 d\\mathbf{x} = \\int_{K_1} 1^2 d\\mathbf{x} = |K_1| = \\frac{1}{2}$.\n- $\\|f\\|_{0,K_1} = \\sqrt{1/2} = 1/\\sqrt{2}$.\n- $\\eta_{K_1} = h_{K_1} \\|f\\|_{0,K_1} = \\sqrt{2} \\cdot \\frac{1}{\\sqrt{2}} = 1$.\n\n**Calculation of $\\eta_F$**:\n- The edge $F$ is the line segment from $(0,0)$ to $(1,1)$. Its length is $h_F = \\sqrt{1^2+1^2} = \\sqrt{2}$.\n- The jump in the normal flux across $F$ is $J_F = \\llbracket \\nabla u_h \\cdot \\mathbf{n} \\rrbracket = (\\nabla u_h|_{K_1} - \\nabla u_h|_{K_2}) \\cdot \\mathbf{n}$, where $\\mathbf{n}$ is a unit normal vector on $F$. Let's choose the normal pointing from $K_1$ to $K_2$. The edge $F$ lies on the line $y=x$. $K_1$ is in the region $y \\le x$ and $K_2$ is in the region $y \\ge x$. The normal from $K_1$ to $K_2$ is $\\mathbf{n} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}$.\n- The difference in gradients is $\\nabla u_h|_{K_1} - \\nabla u_h|_{K_2} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 1.3 \\\\ 0.7 \\end{pmatrix} = \\begin{pmatrix} -0.3 \\\\ 0.3 \\end{pmatrix}$.\n- The jump $J_F$ is constant along $F$:\n$J_F = \\begin{pmatrix} -0.3 \\\\ 0.3 \\end{pmatrix} \\cdot \\frac{1}{\\sqrt{2}}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}}((-0.3)(-1) + (0.3)(1)) = \\frac{0.3+0.3}{\\sqrt{2}} = \\frac{0.6}{\\sqrt{2}}$.\n- Now we compute the $L^2$ norm of $J_F$ on the edge $F$:\n$\\|J_F\\|_{0,F}^2 = \\int_F |J_F|^2 ds = |J_F|^2 \\int_F ds = |J_F|^2 h_F = \\left(\\frac{0.6}{\\sqrt{2}}\\right)^2 \\sqrt{2} = \\frac{0.36}{2}\\sqrt{2} = 0.18\\sqrt{2}$.\n- The indicator $\\eta_F$ is:\n$\\eta_F^2 = h_F \\|J_F\\|_{0,F}^2 = \\sqrt{2} \\cdot (0.18\\sqrt{2}) = 0.18 \\cdot 2 = 0.36$.\nThus, $\\eta_F = \\sqrt{0.36} = 0.6 = \\frac{3}{5}$.\n\nFinally, we compute the combined local indicator for $K_1$:\n$$\n\\Theta(K_1) = \\sqrt{\\eta_{K_1}^{2} + \\frac{1}{2}\\,\\eta_{F}^{2}}.\n$$\nSubstituting the calculated values:\n$$\n\\Theta(K_1) = \\sqrt{1^2 + \\frac{1}{2}(0.6)^2} = \\sqrt{1 + \\frac{1}{2}(0.36)} = \\sqrt{1 + 0.18} = \\sqrt{1.18}.\n$$\nTo express this as a simplified analytic expression, we use fractions:\n$$\n\\Theta(K_1) = \\sqrt{\\frac{118}{100}} = \\frac{\\sqrt{118}}{\\sqrt{100}} = \\frac{\\sqrt{118}}{10}.\n$$\nThe number $118$ factors as $2 \\times 59$, so no further simplification of the square root is possible.",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{118}}{10}}\n$$"
        },
        {
            "introduction": "Moving beyond standard elliptic problems, this practice explores the design of custom error indicators for complex nonlinear physics, specifically the Allen-Cahn equation. You will implement a multi-component estimator that not only includes standard residual terms but also incorporates physics-aware indicators for interface resolution and curvature. This exercise demonstrates how to tailor estimators to capture the dominant error sources in challenging problems like phase-field models .",
            "id": "3359770",
            "problem": "Construct an a posteriori error indicator for the stationary Allen–Cahn operator that scales correctly with the diffuse interface width and captures curvature-driven interface errors while enforcing interface resolution criteria. Consider the one-dimensional (spatial dimension $1$) Allen–Cahn Partial Differential Equation (PDE): \n$$u_t = \\varepsilon^2 u_{xx} - f(u), \\quad f(u) = u^3 - u,$$ \non the domain $[-L,L]$, with $L0$ and interface width parameter $\\varepsilon \\in (0,1)$. The stationary equation is \n$$\\varepsilon^2 u_{xx} - f(u) = 0.$$\nA classical steady front profile is \n$$u(x) = \\tanh\\!\\left(\\frac{x}{\\sqrt{2}\\,\\varepsilon}\\right),$$ \nwhose transition layer has thickness on the order of $\\mathcal{O}(\\varepsilon)$.\n\nYou will work with the conforming, continuous, piecewise linear finite element (also interpretable as piecewise linear nodal interpolation on a uniform grid) function $u_h$ obtained by nodal interpolation of the exact profile on a uniform mesh with $N$ elements on $[-L,L]$. Let $h = 2L/N$ denote the element size. Your task is to derive and implement a computable residual-type a posteriori error indicator $\\eta_K$ on each element $K$, and a global estimator $\\mathcal{E}$, that satisfy all of the following:\n\n- They are built from quantities accessible from $u_h$ only (no knowledge of the exact $u$ during the estimator computation beyond its nodal values used to define $u_h$).\n- They scale correctly with $\\varepsilon$ to reflect the balance between diffusion and reaction near the interface.\n- They include a curvature-driven surrogate term reflecting the fact that interface motion and geometry errors scale with curvature, and for Allen–Cahn dynamics are known to be curvature driven in the sharp-interface limit.\n- They include an interface resolution indicator that penalizes under-resolution whenever $h$ is not small enough relative to $\\varepsilon$ and the local gradient magnitude.\n\nStarting from the variational structure of the stationary operator \n$$\\mathcal{L}(u) := \\varepsilon^2 u_{xx} - f(u),$$ \nand standard residual-based a posteriori estimation for reaction–diffusion operators with nonlinearity, derive, justify, and then implement the following computable elementwise quantities for a uniform mesh on $[-L,L]$:\n\n1. An element residual contribution $I_{1,K}$ motivated by the strong residual $R_K(x) := \\mathcal{L}(u_h)|_K(x)$ and the local bubble-function stability bound. Inside each element, for a piecewise linear $u_h$, one has $u_h'' \\equiv 0$ and $R_K(x) = - f(u_h(x))$. Use a quadrature-based approximation to \n$$I_{1,K} := h_K \\,\\Big\\|\\; f(u_h)\\;\\Big\\|_{L^2(K)} \\approx h_K \\,\\sqrt{\\frac{1}{h_K}\\int_K \\big(f(u_h(x))\\big)^2 \\,dx}.$$\n\n2. An edge jump contribution $I_{2,K}$ that distributes the interior node flux jumps \n$$J_i := \\varepsilon\\,\\big|\\,\\llbracket u_h'\\rrbracket(x_i)\\,\\big|,$$ \nwhere $\\llbracket u_h'\\rrbracket(x_i)$ is the jump of the derivative across the interior node $x_i$, to the two adjacent elements. For a uniform mesh and piecewise linear $u_h$, the elementwise slopes are constants and the jumps are computed from neighboring slopes. Distribute each $J_i$ equally to its left and right adjacent elements so that each element accumulates half from each of its two endpoints (when interior).\n\n3. An interface-resolution contribution $I_{3,K}$ that penalizes under-resolution when the local dimensionless ratio \n$\\rho_K := \\frac{h_K \\,\\max_{x\\in K}|u_h'(x)|}{\\varepsilon}$ \nexceeds a threshold $\\rho_0$. Use \n$I_{3,K} := \\max\\!\\big(0, \\rho_K - \\rho_0\\big),$ \nwith a fixed threshold $\\rho_0 = 0.5$.\n\n4. A curvature surrogate contribution $I_{4,K}$ motivated by curvature-driven interface motion and the matched asymptotic scaling that ties interface geometry errors to $\\varepsilon\\,\\kappa$, where $\\kappa$ is curvature. In one dimension, the level-set curvature surrogate can be approximated by \n$\\kappa(x_i) \\approx \\frac{|u_{xx}(x_i)|}{|u_x(x_i)| + \\delta},$ \nwith a small $\\delta0$ to avoid division by zero; approximate $u_{xx}$ and $u_x$ at nodes by centered finite differences of nodal values of $u_h$. Define the element contribution \n$I_{4,K} := \\varepsilon\\, h_K \\,\\max_{x_i \\in \\partial K} \\kappa(x_i).$\n\nCombine the above into a single element indicator \n$$\\eta_K := \\sqrt{ I_{1,K}^2 + I_{2,K}^2 + I_{4,K}^2 } \\;+\\; I_{3,K},$$ \nand define the global estimator \n$$\\mathcal{E} := \\Big(\\sum_{K} \\eta_K^2 \\Big)^{1/2}.$$\n\nImplement the above indicator for the interpolant $u_h$ of the exact front \n$$u(x) = \\tanh\\!\\left(\\frac{x}{\\sqrt{2}\\,\\varepsilon}\\right)$$ \non the uniform mesh of $N$ elements on $[-L,L]$ with $L=1$. Use two-point Gaussian quadrature to approximate the $L^2$ term in $I_{1,K}$. Use centered differences for nodal curvature surrogates and distribute jump terms as specified. Set $\\rho_0 = 0.5$ and use $\\delta = 10^{-12}$ in the curvature surrogate.\n\nYour program must compute $\\mathcal{E}$ for each of the following test cases (this is the test suite):\n\n- Case A (well-resolved interface): $\\varepsilon = 0.05$, $L = 1$, $N = 200$.\n- Case B (marginal resolution): $\\varepsilon = 0.05$, $L = 1$, $N = 40$.\n- Case C (thin interface, borderline resolution): $\\varepsilon = 0.01$, $L = 1$, $N = 200$.\n- Case D (under-resolved): $\\varepsilon = 0.02$, $L = 1$, $N = 20$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list of real numbers enclosed in square brackets, with each number rounded to exactly six digits after the decimal point, in the order [Case A, Case B, Case C, Case D]. For example: \n\"[0.123456,0.234567,0.345678,0.456789]\". No additional text should be printed.\n\nAll quantities are purely mathematical and dimensionless in this setting; no physical units are required. Angles do not appear. Percentages are not used. The required outputs are real numbers.",
            "solution": "The user-provided problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, objective, and self-contained. The problem specifies the derivation and implementation of a custom a posteriori error indicator for the stationary one-dimensional Allen-Cahn equation, providing all necessary formulas and parameters. The task is to compute a global error estimator for four distinct cases. We proceed with a detailed solution.\n\nThe problem concerns the stationary Allen-Cahn equation in one spatial dimension, given by\n$$ \\mathcal{L}(u) := \\varepsilon^2 u_{xx} - f(u) = 0, $$\nwhere the reaction term is $f(u) = u^3 - u$. The equation is defined on the domain $[-L, L]$ with $L=1$. The parameter $\\varepsilon \\in (0,1)$ controls the width of the transition layer. The exact solution profile is given as\n$$ u(x) = \\tanh\\left(\\frac{x}{\\sqrt{2}\\,\\varepsilon}\\right). $$\n\nOur task is to compute an a posteriori error estimator $\\mathcal{E}$ for a continuous, piecewise linear finite element approximation $u_h$. This approximation $u_h$ is constructed by nodal interpolation of the exact solution $u(x)$ on a uniform mesh.\n\nFirst, we define the discrete setting. The domain $[-L, L]$ is partitioned into $N$ uniform elements, $K_j = [x_{j-1}, x_j]$ for $j=1, \\dots, N$. The mesh nodes are $x_i = -L + i \\cdot h$ for $i=0, \\dots, N$, where $h = 2L/N$ is the uniform element size. The approximate solution $u_h$ is linear on each element $K_j$ and its nodal values are given by $u_h(x_i) = u(x_i)$. Let $u_i$ denote the nodal value $u_h(x_i)$.\n\nThe global error estimator $\\mathcal{E}$ is defined as the $l^2$-sum of element-wise indicators $\\eta_K$:\n$$ \\mathcal{E} := \\left(\\sum_{j=1}^{N} \\eta_{K_j}^2\\right)^{1/2}. $$\nThe element indicator $\\eta_{K_j}$ for an element $K_j$ is a composite quantity defined as:\n$$ \\eta_{K_j} := \\sqrt{ I_{1,K_j}^2 + I_{2,K_j}^2 + I_{4,K_j}^2 } \\;+\\; I_{3,K_j}. $$\nWe now detail the computation of each component $I_{m,K_j}$.\n\n**1. Element Residual Contribution $I_{1,K}$**\nThis term quantifies the error from the residual of the PDE within each element. The strong residual is $R(u_h) = \\varepsilon^2 u_{h,xx} - f(u_h)$. Since $u_h$ is piecewise linear, its second derivative $u_{h,xx}$ is zero inside each element. Thus, the residual on element $K_j$ simplifies to $R(u_h)|_{K_j}(x) = -f(u_h(x))$. The contribution is defined as:\n$$ I_{1,K_j}^2 = h \\int_{K_j} \\left(f(u_h(x))\\right)^2 dx. $$\nTo compute the integral, we use two-point Gaussian quadrature on the reference interval $[-1, 1]$ with quadrature points $\\xi_{1,2} = \\mp 1/\\sqrt{3}$ and weights $\\omega_{1,2} = 1$. The mapping from the reference coordinate $\\xi$ to the physical coordinate $x \\in K_j = [x_{j-1}, x_j]$ is $x(\\xi) = x_{j-1} + \\frac{h}{2}(1+\\xi)$. The value of $u_h$ at a point $x(\\xi)$ is given by linear interpolation of its nodal values $u_{j-1}$ and $u_j$: $u_h(x(\\xi)) = u_{j-1}\\frac{1-\\xi}{2} + u_j\\frac{1+\\xi}{2}$.\nThe values of $u_h$ at the quadrature points are:\n$$ u_{h,1} = u_h(x(-1/\\sqrt{3})) = u_{j-1}\\frac{1+1/\\sqrt{3}}{2} + u_j\\frac{1-1/\\sqrt{3}}{2} $$\n$$ u_{h,2} = u_h(x(+1/\\sqrt{3})) = u_{j-1}\\frac{1-1/\\sqrt{3}}{2} + u_j\\frac{1+1/\\sqrt{3}}{2} $$\nThe integral is then approximated as:\n$$ \\int_{K_j} (f(u_h(x)))^2 dx \\approx \\frac{h}{2} \\sum_{q=1}^2 (f(u_{h,q}))^2 = \\frac{h}{2} \\left[ (f(u_{h,1}))^2 + (f(u_{h,2}))^2 \\right]. $$\nThus, we have:\n$$ I_{1,K_j}^2 \\approx \\frac{h^2}{2} \\left[ \\left(u_{h,1}^3 - u_{h,1}\\right)^2 + \\left(u_{h,2}^3 - u_{h,2}\\right)^2 \\right]. $$\n\n**2. Edge Jump Contribution $I_{2,K}$**\nThis term accounts for the jump in the derivative of $u_h$ across interior nodes, which contributes to the error. On each element $K_j$, the slope $s_j = u_h'|_{K_j}$ is constant: $s_j = (u_j - u_{j-1})/h$. The jump in the derivative at an interior node $x_i$ ($i=1, \\dots, N-1$) is $\\llbracket u_h' \\rrbracket(x_i) = s_{i+1} - s_i$. The problem defines a quantity $J_i$ at each interior node:\n$$ J_i := \\varepsilon\\,\\big|\\,\\llbracket u_h'\\rrbracket(x_i)\\,\\big| = \\varepsilon |s_{i+1} - s_i| = \\frac{\\varepsilon}{h} |(u_{i+1}-u_i) - (u_i-u_{i-1})| = \\frac{\\varepsilon}{h} |u_{i+1} - 2u_i + u_{i-1}|. $$\nThis jump $J_i$ is distributed equally to the two adjacent elements, $K_i$ and $K_{i+1}$. For an interior element $K_j$ ($j=2, \\dots, N-1$), it receives contributions from its left node $x_{j-1}$ and its right node $x_j$. The contribution is:\n$$ I_{2,K_j} = \\frac{1}{2}(J_{j-1} + J_j) = \\frac{\\varepsilon}{2} (|s_j - s_{j-1}| + |s_{j+1} - s_j|). $$\nFor the boundary elements $K_1$ and $K_N$, we assume no jumps at the domain boundaries $x_0$ and $x_N$. Thus:\n$$ I_{2,K_1} = \\frac{1}{2}J_1 = \\frac{\\varepsilon}{2} |s_2 - s_1| $$\n$$ I_{2,K_N} = \\frac{1}{2}J_{N-1} = \\frac{\\varepsilon}{2} |s_N - s_{N-1}|. $$\n\n**3. Interface Resolution Contribution $I_{3,K}$**\nThis term acts as a penalty if the mesh size $h$ is too large to resolve the interface profile relative to the interface width $\\varepsilon$. It is based on the dimensionless ratio:\n$$ \\rho_{K_j} := \\frac{h \\,\\max_{x\\in K_j}|u_h'(x)|}{\\varepsilon} = \\frac{h |s_j|}{\\varepsilon} = \\frac{|u_j - u_{j-1}|}{\\varepsilon}. $$\nThe contribution is defined as a penalty that activates when this ratio exceeds a threshold $\\rho_0 = 0.5$:\n$$ I_{3,K_j} := \\max\\!\\big(0, \\rho_{K_j} - \\rho_0\\big). $$\nThis term is added to the indicator outside the square root, emphasizing its role as a penalty for under-resolution.\n\n**4. Curvature Surrogate Contribution $I_{4,K}$**\nThis term is motivated by the fact that in the sharp-interface limit of the Allen-Cahn equation, the interface evolves under curvature flow. Errors in representing the interface geometry are related to curvature. In one dimension, a surrogate for curvature $\\kappa$ at a node $x_i$ can be approximated using centered finite differences of nodal values:\n$$ \\kappa(x_i) \\approx \\frac{|u_{xx}(x_i)|}{|u_x(x_i)| + \\delta}. $$\nWe approximate the derivatives at interior nodes ($i=1, \\dots, N-1$) as:\n$$ u_x(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}. $$\nFor the boundary nodes $x_0$ and $x_N$, where centered differences are not available, we set $\\kappa(x_0)=0$ and $\\kappa(x_N)=0$. This is justified because the interface is centered at $x=0$ and the solution profile is nearly constant at the domain boundaries $x=\\pm L$. A small regularization parameter $\\delta=10^{-12}$ prevents division by zero.\nThe element contribution $I_{4,K_j}$ is then defined as:\n$$ I_{4,K_j} := \\varepsilon\\, h \\,\\max_{x_i \\in \\{x_{j-1}, x_j\\}} \\kappa(x_i) = \\varepsilon\\, h \\,\\max(\\kappa(x_{j-1}), \\kappa(x_j)). $$\n\nWith all four components defined, we can compute $\\eta_{K_j}$ for each element $j=1, \\dots, N$, and finally the global estimator $\\mathcal{E}$ for each test case provided in the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the a posteriori error estimator for the stationary Allen-Cahn\n    equation based on the provided formulas and test parameters.\n    \"\"\"\n\n    test_cases = [\n        # Case A (well-resolved interface)\n        {'eps': 0.05, 'L': 1, 'N': 200},\n        # Case B (marginal resolution)\n        {'eps': 0.05, 'L': 1, 'N': 40},\n        # Case C (thin interface, borderline resolution)\n        {'eps': 0.01, 'L': 1, 'N': 200},\n        # Case D (under-resolved)\n        {'eps': 0.02, 'L': 1, 'N': 20},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_estimator(case['eps'], case['L'], case['N'])\n        results.append(result)\n\n    # Format the final output as a comma-separated list of numbers with 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef compute_estimator(eps, L, N):\n    \"\"\"\n    Computes the global a posteriori error estimator E for a given set of\n    parameters (eps, L, N).\n    \"\"\"\n\n    # --- 1. Setup Mesh and Nodal Solution ---\n    h = 2 * L / N\n    # Node coordinates (N+1 nodes, indexed 0 to N)\n    x_nodes = np.linspace(-L, L, N + 1)\n    \n    # Nodal values of u_h (interpolant of exact solution u(x))\n    u_nodal = np.tanh(x_nodes / (np.sqrt(2) * eps))\n    \n    # --- 2. Pre-compute Quantities for All Elements/Nodes ---\n    \n    # Slopes s_j on each element K_j.\n    # slopes[j] is the slope on element [x_j, x_{j+1}] (i.e., K_{j+1}).\n    slopes = (u_nodal[1:] - u_nodal[:-1]) / h\n    \n    # Curvature surrogate kappa_i at each node x_i.\n    # We use centered differences for interior nodes (i=1 to N-1).\n    delta = 1e-12\n    # Nodal derivatives at interior nodes\n    u_h_deriv_approx = (u_nodal[2:] - u_nodal[:-2]) / (2 * h)\n    u_h_deriv2_approx = (u_nodal[2:] - 2 * u_nodal[1:-1] + u_nodal[:-2]) / (h**2)\n    \n    # Compute kappa for interior nodes\n    kappa_interior = np.abs(u_h_deriv2_approx) / (np.abs(u_h_deriv_approx) + delta)\n    \n    # Full kappa array for all nodes (0 to N). Set to 0 at boundaries.\n    kappa = np.zeros(N + 1)\n    kappa[1:-1] = kappa_interior\n\n    eta_K_squared_list = []\n    \n    # --- 3. Loop over Elements to Compute Local Indicators ---\n    # The loop variable 'j' corresponds to the element [x_j, x_{j+1}], or K_{j+1}.\n    for j in range(N):\n        # Nodal values for the current element\n        u_elem_left, u_elem_right = u_nodal[j], u_nodal[j+1]\n        \n        # --- Component I_1,K (Element Residual) ---\n        # Two-point Gaussian quadrature for the integral of f(u_h)^2.\n        # u_h values at quadrature points based on linear interpolation.\n        sqrt3_inv = 1.0 / np.sqrt(3.0)\n        u_q1 = u_elem_left * 0.5 * (1 + sqrt3_inv) + u_elem_right * 0.5 * (1 - sqrt3_inv)\n        u_q2 = u_elem_left * 0.5 * (1 - sqrt3_inv) + u_elem_right * 0.5 * (1 + sqrt3_inv)\n        \n        f = lambda u: u**3 - u\n        \n        # Quadrature integral approx: (h/2) * (w1*f(u_q1)^2 + w2*f(u_q2)^2) with w1=w2=1\n        integral_approx = (h / 2.0) * (f(u_q1)**2 + f(u_q2)**2)\n        # I_1,K^2 = h * integral\n        I_1_K_squared = h * integral_approx\n\n        # --- Component I_2,K (Edge Jump) ---\n        # The jump J_i at an interior node x_i is distributed to elements K_i and K_{i+1}.\n        # Element j ([x_j, x_{j+1}]) gets contributions from nodes x_j and x_{j+1}.\n        \n        # Contribution from left node x_j (if it's an interior node)\n        J_left_node = 0.0\n        if j > 0:\n            # Jump at x_j involves slopes on element j-1 and j\n            # which are slopes[j-1] and slopes[j]\n            jump_at_x_j = eps * np.abs(slopes[j] - slopes[j-1])\n            J_left_node = jump_at_x_j\n            \n        # Contribution from right node x_{j+1} (if it's an interior node)\n        J_right_node = 0.0\n        if j  N - 1:\n            # Jump at x_{j+1} involves slopes on element j and j+1\n            # which are slopes[j] and slopes[j+1]\n            jump_at_x_j_plus_1 = eps * np.abs(slopes[j+1] - slopes[j])\n            J_right_node = jump_at_x_j_plus_1\n            \n        I_2_K = 0.5 * (J_left_node + J_right_node)\n        I_2_K_squared = I_2_K**2\n        \n        # --- Component I_3,K (Interface Resolution) ---\n        rho_0 = 0.5\n        # Slope on current element j is slopes[j]\n        rho_K = (h * np.abs(slopes[j])) / eps\n        I_3_K = np.maximum(0, rho_K - rho_0)\n        \n        # --- Component I_4,K (Curvature Surrogate) ---\n        # Element j has nodes j and j+1. Check max kappa at these two nodes.\n        kappa_max_on_elem = np.maximum(kappa[j], kappa[j+1])\n        I_4_K = eps * h * kappa_max_on_elem\n        I_4_K_squared = I_4_K**2\n        \n        # --- 4. Combine Components for Element Indicator eta_K ---\n        # Formula: eta_K = sqrt(I_1^2 + I_2^2 + I_4^2) + I_3\n        eta_K = np.sqrt(I_1_K_squared + I_2_K_squared + I_4_K_squared) + I_3_K\n        eta_K_squared_list.append(eta_K**2)\n        \n    # --- 5. Compute Global Estimator E ---\n    E_squared = np.sum(eta_K_squared_list)\n    E = np.sqrt(E_squared)\n    \n    return E\n\n# Execute the main function to produce the final output.\nsolve()\n\n```"
        },
        {
            "introduction": "This practice extends the concept of a posteriori error estimation from spatial discretization to the temporal domain. You will implement an adaptive time-stepping algorithm for a semilinear parabolic PDE, using a temporal residual to control the step size. A key feature of this exercise is designing a robust criterion to detect a finite-time blow-up singularity, illustrating how estimator-driven adaptivity can be used not only for efficiency but also to identify critical qualitative behaviors of the solution .",
            "id": "3359754",
            "problem": "Consider the semilinear parabolic Partial Differential Equation (PDE) $u_t - \\Delta u = u^p$ on the one-dimensional spatial domain $x \\in (0,1)$ and dimensionless time $t \\ge 0$, with homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$ and initial condition $u(x,0) = A \\sin(\\pi x)$. The exponent $p$ satisfies $p1$, and the amplitude $A$ is nonnegative.\n\nYou must design an estimator-driven time-adaptive algorithm to detect and resolve finite-time blow-up by monitoring a posteriori temporal residuals. Discretize space using a second-order centered finite difference with $N$ interior grid points, mesh spacing $h = 1/(N+1)$, and homogeneous Dirichlet boundary conditions imposed by ghost values $u_0=0$ and $u_{N+1}=0$. Denote the discrete Laplacian at interior indices $i=1,\\dots,N$ by\n$$\n(\\Delta_h u)_i = \\frac{u_{i-1} - 2 u_i + u_{i+1}}{h^2},\n$$\nwith $u_0=0$ and $u_{N+1}=0$.\n\nAdvance in time with the explicit forward Euler scheme\n$$\nu^{n+1} = u^n + \\Delta t \\left( \\Delta_h u^n + (u^n)^p \\right),\n$$\nwhere $\\Delta t$ is the time step. Define the discrete temporal residual at the end of the step $n \\to n+1$ by the pointwise defect of the PDE evaluated at $u^{n+1}$:\n$$\nR^{n+1} = \\frac{u^{n+1} - u^n}{\\Delta t} - \\Delta_h u^{n+1} - \\left(u^{n+1}\\right)^p,\n$$\nand use its infinity norm\n$$\n\\|R^{n+1}\\|_{\\infty} = \\max_{1 \\le i \\le N} \\left| R^{n+1}_i \\right|\n$$\nas a posteriori estimator of the local temporal error on the step. The algorithm must implement:\n- An acceptance criterion for a time step $n \\to n+1$ based on $\\|R^{n+1}\\|_{\\infty} \\le \\tau$, where $\\tau$ is a prescribed tolerance.\n- A rejection-and-refinement rule that halves (or, more generally, multiplicatively reduces) $\\Delta t$ when $\\|R^{n+1}\\|_{\\infty}  \\tau$, recomputing $u^{n+1}$ until acceptance or until the minimum time step $\\Delta t_{\\min}$ is reached.\n- A step-size update $ \\Delta t_{\\text{new}}$ after acceptance using first-order scaling with safety factor $s \\in (0,1)$:\n$$\n\\Delta t_{\\text{new}} = \\min\\left( \\Delta t_{\\text{diff}}, \\max\\left( \\gamma_{\\min} \\Delta t, \\min\\left( \\gamma_{\\max} \\Delta t, s \\Delta t \\frac{\\tau}{\\|R^{n+1}\\|_{\\infty}} \\right)\\right)\\right),\n$$\nwhere $\\Delta t_{\\text{diff}}$ is a diffusion-driven stability cap proportional to $h^2$, and $\\gamma_{\\min}, \\gamma_{\\max}$ bound the multiplicative change per step.\n\nDesign stopping criteria for blow-up detection based on monitored growth of temporal residuals, in the following sense:\n- Declare blow-up if either (i) the supremum norm of the numerical solution $\\|u^{n+1}\\|_{\\infty}$ exceeds a large threshold $U_{\\max}$, or (ii) $\\Delta t$ has reached $\\Delta t_{\\min}$ and $\\|R^{n+1}\\|_{\\infty}  \\kappa \\tau$ with $\\kappa1$, indicating that the temporal residual cannot be controlled by further time-step reductions.\n- If blow-up is declared, report the estimated blow-up time $T_{\\text{blow}}$ as the current time at which the blow-up criterion first triggers.\n- If blow-up is not declared by the final horizon time $T_{\\max}$, report the final supremum norm $\\|u(\\cdot,T_{\\max})\\|_{\\infty}$.\n\nFor numerical robustness when $p$ is not an integer, enforce nonnegativity of the solution after each update by replacing negative entries by zero before evaluating $(u^{n+1})^p$.\n\nImplement the above algorithm as a complete, runnable program. Use a uniform grid and the explicit Euler method in time with adaptive time-step control. Use the following fixed parameters within the algorithm unless stated otherwise:\n- Diffusion stability cap $\\Delta t_{\\text{diff}} = \\eta h^2$ with $\\eta = 0.4$.\n- Tolerance $\\tau = 10^{-3}$, minimum time step $\\Delta t_{\\min} = 10^{-8}$, safety factor $s=0.9$.\n- Per-step growth bounds $\\gamma_{\\min} = 0.2$ and $\\gamma_{\\max} = 2.0$.\n- Blow-up residual factor $\\kappa = 100$ and supremum threshold $U_{\\max} = 10^4$.\n\nYour program must run four test cases specified below. For each case, discretize with $N=64$ interior points and report results in dimensionless time units. The test suite is:\n- Case $1$: $p=2$, $A=8$, $T_{\\max}=0.2$.\n- Case $2$: $p=2$, $A=0.1$, $T_{\\max}=0.2$.\n- Case $3$: $p=1.1$, $A=1.0$, $T_{\\max}=0.2$.\n- Case $4$: $p=3$, $A=4.0$, $T_{\\max}=0.05$.\n\nFor each test case, output a list $[b,v]$ where $b$ is $1$ if blow-up is detected and $0$ otherwise, and $v$ is:\n- If $b=1$, the estimated blow-up time $T_{\\text{blow}}$ in dimensionless time units;\n- If $b=0$, the final supremum norm $\\|u(\\cdot,T_{\\max})\\|_{\\infty}$.\n\nRound every reported float to $6$ decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the four test cases in order, for example, $[[b_1,v_1],[b_2,v_2],[b_3,v_3],[b_4,v_4]]$.",
            "solution": "The user wants to solve a given problem statement.\n\n### Step 1: Extract Givens\n\n**PDE and Domain**:\n- Equation: $u_t - \\Delta u = u^p$\n- Spatial domain: $x \\in (0,1)$\n- Time domain: $t \\ge 0$\n\n**Boundary and Initial Conditions**:\n- Boundary Conditions (BC): Homogeneous Dirichlet, $u(0,t)=0$ and $u(1,t)=0$.\n- Initial Condition (IC): $u(x,0) = A \\sin(\\pi x)$, with $A \\ge 0$.\n- Exponent: $p  1$.\n\n**Spatial Discretization**:\n- Method: Second-order centered finite difference.\n- Number of interior grid points: $N=64$.\n- Mesh spacing: $h = 1/(N+1)$.\n- Discrete Laplacian at interior index $i \\in \\{1, \\dots, N\\}$: $(\\Delta_h u)_i = \\frac{u_{i-1} - 2 u_i + u_{i+1}}{h^2}$, with ghost values $u_0=0$ and $u_{N+1}=0$.\n\n**Temporal Discretization and Adaptation**:\n- Time-stepping scheme: Explicit forward Euler, $u^{n+1} = u^n + \\Delta t \\left( \\Delta_h u^n + (u^n)^p \\right)$.\n- Temporal residual definition: $R^{n+1} = \\frac{u^{n+1} - u^n}{\\Delta t} - \\Delta_h u^{n+1} - \\left(u^{n+1}\\right)^p$.\n- Error estimator: $\\|R^{n+1}\\|_{\\infty} = \\max_{1 \\le i \\le N} |R^{n+1}_i|$.\n- Acceptance criterion: $\\|R^{n+1}\\|_{\\infty} \\le \\tau$.\n- Rejection rule: If $\\|R^{n+1}\\|_{\\infty}  \\tau$, reduce $\\Delta t$ by halving and recompute.\n- New step-size formula (after acceptance): $ \\Delta t_{\\text{new}} = \\min\\left( \\Delta t_{\\text{diff}}, \\max\\left( \\gamma_{\\min} \\Delta t, \\min\\left( \\gamma_{\\max} \\Delta t, s \\Delta t \\frac{\\tau}{\\|R^{n+1}\\|_{\\infty}} \\right)\\right)\\right)$.\n\n**Algorithm Parameters**:\n- Diffusion stability cap: $\\Delta t_{\\text{diff}} = \\eta h^2$ with $\\eta = 0.4$.\n- Tolerance: $\\tau = 10^{-3}$.\n- Minimum time step: $\\Delta t_{\\min} = 10^{-8}$.\n- Safety factor: $s=0.9$.\n- Step-size change bounds: $\\gamma_{\\min} = 0.2$, $\\gamma_{\\max} = 2.0$.\n\n**Blow-up Detection**:\n- Criterion (i): Solution norm exceeds a threshold, $\\|u^{n+1}\\|_{\\infty}  U_{\\max}$.\n- Criterion (ii): Time step reaches minimum and error is uncontrolled, $\\Delta t = \\Delta t_{\\min}$ and $\\|R^{n+1}\\|_{\\infty}  \\kappa \\tau$.\n- Parameters: $\\kappa = 100$, $U_{\\max} = 10^4$.\n- Reporting: If blow-up, report time $T_{\\text{blow}}$; otherwise, report final norm $\\|u(\\cdot, T_{\\max})\\|_{\\infty}$.\n\n**Numerical Robustness**:\n- Enforce nonnegativity after each update before evaluating $(u^{n+1})^p$ if $p$ is not an integer.\n\n**Test Cases**:\n- $N=64$ for all cases.\n- Case 1: $p=2$, $A=8$, $T_{\\max}=0.2$.\n- Case 2: $p=2$, $A=0.1$, $T_{\\max}=0.2$.\n- Case 3: $p=1.1$, $A=1.0$, $T_{\\max}=0.2$.\n- Case 4: $p=3$, $A=4.0$, $T_{\\max}=0.05$.\n\n**Output Format**:\n- For each case, $[b, v]$, where $b \\in \\{0,1\\}$ indicates blow-up and $v$ is the corresponding value.\n- All reported floats must be rounded to $6$ decimal places.\n- Final output is a list of lists: $[[b_1,v_1],[b_2,v_2],[b_3,v_3],[b_4,v_4]]$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem describes the numerical simulation of a semilinear heat equation, a classic topic in PDE theory and numerics. The phenomenon of finite-time blow-up for $u_t = \\Delta u + f(u)$ when $f(u)$ grows superlinearly (like $u^p$ for $p1$) is a well-established scientific fact. The methods proposed—finite differences, explicit Euler, and adaptive time-stepping based on a posteriori residuals—are standard techniques in computational science. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is a well-defined computational task. All necessary parameters, equations, and algorithmic rules are specified, leading to a determinate (though computationally obtained) result for each test case.\n- **Objective**: The problem is stated in precise, objective mathematical and algorithmic language. There are no subjective or opinion-based components.\n- **Completeness and Consistency**: All required information is provided. The discretization methods, adaptive control logic, blow-up criteria, and all associated parameters are explicitly defined. There are no apparent contradictions in the setup. The treatment of non-negativity is specified, which is crucial for non-integer powers.\n- **Feasibility**: The specified parameters ($N=64$) and time horizons are computationally tractable. The algorithm is complex but standard.\n- **Structure**: The problem is well-structured and guides the user toward a specific, advanced numerical implementation. It is not trivial or tautological.\n\n### Step 3: Verdict and Action\nThe problem is valid. A detailed solution will be provided.\n\nThe provided problem is to design and implement an adaptive time-stepping algorithm for the numerical solution of the semilinear parabolic PDE $u_t - \\Delta u = u^p$. The central challenge is to resolve potential finite-time blow-up singularities, which arise when the nonlinear reaction term $u^p$ (for $p1$) dominates the diffusive term $-\\Delta u$, causing the solution to grow unboundedly in a finite amount of time.\n\nThe overall approach is the Method of Lines. First, the spatial domain $x \\in (0,1)$ is discretized, converting the single PDE into a large system of coupled ordinary differential equations (ODEs) in time. We use a uniform grid with $N$ interior points $x_i=i \\cdot h$ for $i=1,\\dots,N$, where the mesh spacing is $h=1/(N+1)$. The solution at these points is represented by a vector $\\mathbf{u}(t) = [u_1(t), u_2(t), \\dots, u_N(t)]^T$. The Laplacian operator $\\Delta$ is approximated by a second-order centered finite difference stencil, which can be represented by a matrix $\\mathbf{L}$. The PDE system then becomes the ODE system:\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\mathbf{u} + F(\\mathbf{u})\n$$\nwhere $F(\\mathbf{u}) = \\mathbf{u}^p$ is the component-wise nonlinear reaction term. The matrix $\\mathbf{L}$ is a symmetric tridiagonal matrix of size $N \\times N$ with $-2/h^2$ on the main diagonal and $1/h^2$ on the sub- and super-diagonals, incorporating the homogeneous Dirichlet boundary conditions.\n\nFor time integration, the explicit forward Euler method is specified. A time step from $t_n$ to $t_{n+1}=t_n+\\Delta t$ is computed as:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^n + \\Delta t \\left( \\mathbf{L}\\mathbf{u}^n + (\\mathbf{u}^n)^p \\right)\n$$\nThis method is simple but has a limited stability region, especially for stiff problems like this one where different physical processes (diffusion and reaction) occur at vastly different time scales. As the solution approaches a blow-up, its gradient and magnitude increase dramatically, demanding progressively smaller time steps for stability and accuracy. This necessitates an adaptive time-stepping strategy.\n\nThe core of the adaptive algorithm is an a posteriori error estimator. After computing a tentative solution $\\mathbf{u}^{n+1}$, we measure how well it satisfies the original PDE. The problem defines a temporal residual $\\mathbf{R}^{n+1}$ as the defect in the PDE equation when evaluated at the new time level:\n$$\n\\mathbf{R}^{n+1} = \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} - \\left( \\mathbf{L}\\mathbf{u}^{n+1} + (\\mathbf{u}^{n+1})^p \\right)\n$$\nThe infinity norm of this residual, $\\| \\mathbf{R}^{n+1} \\|_{\\infty}$, serves as an indicator of the local truncation error for the time step. The adaptive control loop operates as follows:\n1.  **Step Acceptance/Rejection**: A step is accepted if $\\| \\mathbf{R}^{n+1} \\|_{\\infty}$ is below a given tolerance $\\tau$. If it is larger, the step is rejected, the time step $\\Delta t$ is halved, and the step is recomputed. This process is repeated until the step is accepted or a minimum time step $\\Delta t_{\\min}$ is reached.\n2.  **Step Size Control**: Upon a successful step, a new, optimal time step for the subsequent step is calculated. The formula provided is a standard PI (Proportional-Integral) controller, aiming to keep the error close to the target tolerance $\\tau$. The new step size is proposed as $\\Delta t_{\\text{new}} = s \\Delta t (\\tau / \\| \\mathbf{R}^{n+1} \\|_{\\infty})^{1/k}$, where the method order is $k=1$ for Euler. The formula includes a safety factor $s1$ and clamps ($\\gamma_{\\min}$, $\\gamma_{\\max}$, $\\Delta t_{\\text{diff}}$) to prevent excessively aggressive changes in $\\Delta t$ and to respect the CFL stability condition for the diffusion part of the equation, $\\Delta t \\le \\eta h^2$.\n\nA crucial part of the algorithm is the robust detection of blow-up. Two criteria are used:\n1.  **Magnitude Threshold**: If the solution's maximum value, $\\|\\mathbf{u}^{n+1}\\|_{\\infty}$, exceeds a large pre-defined threshold $U_{\\max}$, it is a clear indication of blow-up.\n2.  **Adaptivity Failure**: A more subtle and often earlier indicator is the failure of the time-stepping algorithm. If the time step $\\Delta t$ must be reduced to its minimum allowed value, $\\Delta t_{\\min}$, and the error estimator $\\| \\mathbf{R}^{n+1} \\|_{\\infty}$ still significantly exceeds the tolerance (by a factor $\\kappa$), it implies that the error can no longer be controlled by reducing the time step. This is a characteristic signature of a developing singularity, and blow-up is declared.\n\nFor cases where the exponent $p$ is not an integer, the term $u^p$ is undefined for $u0$. The problem specifies that non-negativity must be enforced. To maintain consistency, after calculating a tentative solution vector, any negative components are set to zero. This projected, non-negative vector is then used for both the subsequent time step and the calculation of the residual, ensuring that the error estimation is performed on the same solution that propagates forward.\n\nThe final implementation encapsulates this entire logic. It initializes the solution from the given IC, then enters a time-stepping loop. Within this loop, an inner loop handles the step acceptance/rejection. The blow-up conditions are checked at each stage. The simulation terminates either upon reaching the final time $T_{\\max}$ or by declaring a blow-up, reporting the results as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (p, A, T_max)\n        (2.0, 8.0, 0.2),\n        (2.0, 0.1, 0.2),\n        (1.1, 1.0, 0.2),\n        (3.0, 4.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        p, A, T_max = case\n        result = run_simulation(p, A, T_max)\n        results.append(result)\n\n    # Format the final output string\n    str_results = []\n    for res in results:\n        # res[0] is int (b), res[1] is float (v)\n        str_results.append(f'[{res[0]},{res[1]:.6f}]')\n    \n    print(f\"[{','.join(str_results)}]\")\n\ndef laplacian(u, h):\n    \"\"\"\n    Computes the 1D discrete Laplacian with homogeneous Dirichlet boundary conditions.\n    u is a 1D array of interior points.\n    \"\"\"\n    N = len(u)\n    # Pad with ghost points for boundary conditions u_0=0, u_{N+1}=0\n    u_padded = np.zeros(N + 2)\n    u_padded[1:-1] = u\n    \n    # Second-order centered difference\n    lap = (u_padded[:-2] - 2 * u_padded[1:-1] + u_padded[2:]) / (h**2)\n    return lap\n\ndef run_simulation(p, A, T_max):\n    \"\"\"\n    Runs the simulation for a single test case.\n    \"\"\"\n    # Fixed parameters\n    N = 64\n    eta = 0.4\n    tau = 1e-3\n    dt_min = 1e-8\n    s = 0.9\n    gamma_min = 0.2\n    gamma_max = 2.0\n    kappa = 100.0\n    U_max = 1e4\n\n    # Grid setup\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n\n    # Initial condition\n    u = A * np.sin(np.pi * x)\n    # Ensure IC is non-negative\n    u[u  0] = 0.0\n    u_final = np.copy(u) # To store the last valid state\n\n    # Time-stepping setup\n    t = 0.0\n    dt_diff = eta * h**2\n    dt = dt_diff\n\n    # Main time loop\n    while t  T_max:\n        # Adjust dt to not overshoot T_max\n        if t + dt > T_max:\n            dt = T_max - t\n        \n        # Avoid zero or negative dt if we land exactly on T_max\n        if dt = 1e-12:\n            break\n\n        t_current_step = t\n        u_current_step = np.copy(u)\n        \n        dt_try = dt\n        step_halted = False\n\n        # Inner loop for step acceptance/rejection\n        while True:\n            # Forward Euler step\n            F_u = laplacian(u_current_step, h) + u_current_step**p\n            u_tentative = u_current_step + dt_try * F_u\n\n            # Enforce non-negativity\n            u_next = np.maximum(0, u_tentative)\n            \n            # A posteriori residual R^{n+1}\n            F_unext = laplacian(u_next, h) + u_next**p\n            R = (u_next - u_current_step) / dt_try - F_unext\n            residual_norm = np.max(np.abs(R))\n\n            if residual_norm = tau: # Step accepted\n                u = u_next\n                t = t_current_step + dt_try\n                u_final = np.copy(u)\n\n                # Check for blow-up by magnitude (Criterion i)\n                if np.max(u) > U_max:\n                    return [1, round(t, 6)]\n                \n                # If we've reached the end, stop updating dt and break\n                if t >= T_max:\n                    break\n\n                # Update dt for the next step\n                dt_accepted = dt_try\n                if residual_norm  1e-12: # Avoid division by zero\n                    dt_ratio = gamma_max\n                else:\n                    dt_ratio = s * (tau / residual_norm)\n                \n                dt = dt_accepted * dt_ratio\n                dt = min(dt, gamma_max * dt_accepted)\n                dt = max(dt, gamma_min * dt_accepted)\n                dt = min(dt, dt_diff)\n                \n                break # Exit acceptance loop\n            \n            else: # Step rejected\n                dt_prev_try = dt_try\n                dt_try /= 2.0\n\n                if dt_try  dt_min:\n                    # Check for blow-up by adaptivity failure (Criterion ii)\n                    # Note: residual_norm is from the last failed attempt with dt_prev_try\n                    if residual_norm > kappa * tau:\n                        blowup_time = t_current_step + dt_prev_try\n                        return [1, round(blowup_time, 6)]\n                    \n                    # Cannot meet tolerance, halt simulation\n                    step_halted = True\n                    break # Exit acceptance loop\n        \n        if step_halted:\n            break # Exit main time loop\n\n    # Loop finished, either by reaching T_max or by halting.\n    return [0, round(np.max(u_final), 6)]\n\nsolve()\n\n```"
        }
    ]
}