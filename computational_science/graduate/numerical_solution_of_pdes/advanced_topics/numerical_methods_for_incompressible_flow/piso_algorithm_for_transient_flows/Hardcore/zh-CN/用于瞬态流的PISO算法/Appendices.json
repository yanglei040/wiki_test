{
    "hands_on_practices": [
        {
            "introduction": "PISO算法的有效性源于其压力修正步骤，该步骤如同一个投影算子，强制执行不可压缩约束。为了真正掌握这一核心机制，我们可以进行一次理论上的“动手”分析。这个练习将引导你对预测步产生的单个傅里叶误差模式进行传输分析，从而精确地揭示压力修正步骤是如何分离并消除速度误差中不符合物理的、有散度的部分，最终得到一个物理上合理的无散度场。",
            "id": "3432037",
            "problem": "考虑一个在三周期域中，密度为常数 $\\rho$ 的瞬态不可压缩流，该流动通过算子分裂压力隐式 (PISO) 算法进行时间推进。设时间步长为 $\\Delta t$，并用 $\\mathbf{u}^{*}$ 表示在时间层 $n+1$ 预测步之后的速度，由于截断误差，该速度与精确的无散速度 $\\mathbf{u}^{n+1}$ 不同。定义预测截断误差场 $\\mathbf{e}_{\\mathrm{pred}}$ 为 $\\mathbf{u}^{*} = \\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}$。压力修正步通过减去一个压力梯度增量来更新速度，以在时间层 $n+1$ 强制满足不可压缩性。假设在修正步中忽略了粘性，并且选择压力增量来强制满足无散约束。\n\n仅使用不可压缩约束 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$、压力修正步被定义为通过梯度场更新速度，以及周期域中的傅里叶分析，对预测截断误差的单个傅里叶模态进行误差输运分析。具体来说，考虑 $\\mathbf{e}_{\\mathrm{pred}}(\\mathbf{x}) = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$，其中振幅矢量 $\\mathbf{a} \\in \\mathbb{C}^{3}$ 为常数，波矢 $\\mathbf{k} \\in \\mathbb{R}^{3} \\setminus \\{\\mathbf{0}\\}$。推导由压力修正引起的 $\\mathbf{e}_{\\mathrm{pred}}$ 的重新分布，并计算第一次压力修正后，保留在修正速度中的误差模态动能的比例。用 $\\mathbf{a}$ 和 $\\mathbf{k}$ 之间的夹角 $\\theta$（由 $\\cos \\theta = \\dfrac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\, \\|\\mathbf{a}\\|}$ 定义）来表示您的最终答案的闭式解析表达式。不需要数值近似；请提供一个精确表达式。最终答案应无单位。",
            "solution": "PISO算法的压力修正步骤旨在将一个给定的速度场投影到无散（solenoidal）向量场的空间上。本题旨在通过傅里叶分析，量化此投影操作对单个误差模态的影响。\n\n设预测步之后的速度场为 $\\mathbf{u}^{*}$。第一个修正步通过减去一个标量场 $\\phi$ 的梯度来计算修正后的速度 $\\mathbf{u}^{**}$，以强制其满足无散度约束：\n$$\n\\mathbf{u}^{**} = \\mathbf{u}^{*} - \\nabla\\phi\n$$\n其中，无散度条件 $\\nabla \\cdot \\mathbf{u}^{**} = 0$ 决定了场 $\\phi$（与压力修正量成比例）。代入上式可得一个关于 $\\phi$ 的泊松方程：\n$$\n\\nabla \\cdot (\\mathbf{u}^{*} - \\nabla\\phi) = 0 \\implies \\nabla^2\\phi = \\nabla \\cdot \\mathbf{u}^{*}\n$$\n根据题意，预测速度 $\\mathbf{u}^{*}$ 与精确的无散速度 $\\mathbf{u}^{n+1}$ 之间的关系为 $\\mathbf{u}^{*} = \\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}}$。由于 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$，泊松方程的源项完全由预测误差的散度决定：\n$$\n\\nabla^2\\phi = \\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}}\n$$\n修正后的速度场中的误差 $\\mathbf{e}_{\\mathrm{corr}}$ 为：\n$$\n\\mathbf{e}_{\\mathrm{corr}} = \\mathbf{u}^{**} - \\mathbf{u}^{n+1} = (\\mathbf{u}^{*} - \\nabla\\phi) - \\mathbf{u}^{n+1} = (\\mathbf{u}^{n+1} + \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi) - \\mathbf{u}^{n+1} = \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi\n$$\n这表明压力修正步骤通过从原始误差场中移除其梯度部分来修正误差。现在，我们对给定的单个傅里叶模态误差 $\\mathbf{e}_{\\mathrm{pred}}(\\mathbf{x}) = \\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$ 分析这个过程。\n\n首先，计算该误差模态的散度：\n$$\n\\nabla \\cdot \\mathbf{e}_{\\mathrm{pred}} = \\nabla \\cdot (\\mathbf{a} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = i(\\mathbf{k} \\cdot \\mathbf{a})\\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\n泊松方程变为：\n$$\n\\nabla^2\\phi = i(\\mathbf{k} \\cdot \\mathbf{a})\\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\n假设解的形式为 $\\phi(\\mathbf{x}) = \\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$，其中 $\\hat{\\phi}$ 是傅里叶系数。应用拉普拉斯算子可得 $\\nabla^2\\phi = -\\hat{\\phi} \\|\\mathbf{k}\\|^2 \\exp(i \\mathbf{k} \\cdot \\mathbf{x})$。代入泊松方程求解 $\\hat{\\phi}$：\n$$\n-\\hat{\\phi} \\|\\mathbf{k}\\|^2 = i(\\mathbf{k} \\cdot \\mathbf{a}) \\implies \\hat{\\phi} = -\\frac{i(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2}\n$$\n接下来，计算从误差中移除的梯度项 $\\nabla\\phi$：\n$$\n\\nabla\\phi = \\nabla(\\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})) = i\\mathbf{k} \\hat{\\phi} \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = i\\mathbf{k} \\left( -\\frac{i(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\right) \\exp(i \\mathbf{k} \\cdot \\mathbf{x}) = \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\n这个被移除的项是原始误差振幅 $\\mathbf{a}$ 在波矢 $\\mathbf{k}$ 方向上的投影（也称为纵向部分）。修正后的误差场 $\\mathbf{e}_{\\mathrm{corr}}$ 是原始误差减去其纵向部分，即其正交于 $\\mathbf{k}$ 的部分（螺线管部分）：\n$$\n\\mathbf{e}_{\\mathrm{corr}} = \\mathbf{e}_{\\mathrm{pred}} - \\nabla\\phi = \\left( \\mathbf{a} - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\right) \\exp(i \\mathbf{k} \\cdot \\mathbf{x})\n$$\n在周期域中，单个傅里叶模态的动能与其振幅矢量的范数平方成正比。因此，保留在修正速度中的误差模态动能与原始误差动能之比为：\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = \\frac{\\left\\| \\mathbf{a} - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\right\\|^2}{\\|\\mathbf{a}\\|^2}\n$$\n根据勾股定理，对于正交分解 $\\mathbf{a} = \\mathbf{a}_{\\|} + \\mathbf{a}_{\\perp}$，我们有 $\\|\\mathbf{a}\\|^2 = \\|\\mathbf{a}_{\\|}\\|^2 + \\|\\mathbf{a}_{\\perp}\\|^2$。上式中的分子正是 $\\|\\mathbf{a}_{\\perp}\\|^2$。因此，\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = \\frac{\\|\\mathbf{a}_{\\perp}\\|^2}{\\|\\mathbf{a}\\|^2} = \\frac{\\|\\mathbf{a}\\|^2 - \\|\\mathbf{a}_{\\|}\\|^2}{\\|\\mathbf{a}\\|^2} = 1 - \\frac{\\left\\| \\frac{(\\mathbf{k} \\cdot \\mathbf{a})}{\\|\\mathbf{k}\\|^2} \\mathbf{k} \\right\\|^2}{\\|\\mathbf{a}\\|^2} = 1 - \\frac{(\\mathbf{k} \\cdot \\mathbf{a})^2}{\\|\\mathbf{k}\\|^2 \\|\\mathbf{a}\\|^2}\n$$\n利用问题中给出的夹角定义 $\\cos\\theta = \\dfrac{\\mathbf{k} \\cdot \\mathbf{a}}{\\|\\mathbf{k}\\| \\, \\|\\mathbf{a}\\|}$，上式简化为：\n$$\n\\frac{E_{\\mathrm{corr}}}{E_{\\mathrm{pred}}} = 1 - \\cos^2\\theta = \\sin^2\\theta\n$$\n这个结果明确表明，压力修正投影精确地消除了误差中与波矢方向相同的纵向（有散度）部分，并完整地保留了与其正交的横向（无散度）部分。",
            "answer": "$$\n\\boxed{\\sin^2(\\theta)}\n$$"
        },
        {
            "introduction": "在理想情况下理解算法是一回事，但在复杂的实际应用中对其进行调试则是另一回事。这个练习将你置于一个计算流体力学（CFD）工程师的角色，面对一个发散的仿真。通过分析一个详尽但存在缺陷的PISO算法设置，你将学会诊断与边界条件不一致性、数值稳定性以及压力-速度耦合相关的关键问题，这些都是CFD实践中常见的陷阱。",
            "id": "3432034",
            "problem": "考虑一个不可压缩、密度恒定的瞬态流动，该流动由不可压缩的Navier–Stokes方程控制，在一个长度为$L$、高度为$H$的二维($2\\mathrm{D}$)通道中进行，其密度为$\\rho$，运动粘度为$\\nu$。控制方程为：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + \\nabla \\cdot (\\mathbf{u}\\mathbf{u}) = -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}, \\qquad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中$\\mathbf{u}$是速度场，$p$是运动压力（压力除以密度），$\\mathbf{f}$是体积力。该流动在非正交网格上，通过有限体积法（FVM）框架内的算子分裂压力隐式（PISO）算法进行数值求解。\n\n边界条件规定如下：在$x=0$（入口），施加一个随时间变化的速度剖面$\\mathbf{u}_{\\text{in}}(t)$，并设法向压力梯度为零；在$x=L$（出口），运动压力固定为$p=p_0$；在$y=0$和$y=H$（壁面），强制执行无滑移和不可穿透条件，即$\\mathbf{u}=\\mathbf{0}$和$\\mathbf{u}\\cdot \\mathbf{n}=0$。入口速度为$\\mathbf{u}_{\\text{in}}(t)=\\left(U_0\\sin(\\omega t),\\,0\\right)$，其中$U_0$和$\\omega$为给定值。库朗数定义为：\n$$\nCo \\equiv \\max\\left(\\frac{|\\mathbf{u}|\\Delta t}{\\Delta x}\\right),\n$$\n其中$\\Delta t$是时间步长，$\\Delta x$是特征单元尺寸。\n\n一位计算流体动力学（CFD）从业者按如下方式设置PISO算法：动量预测步产生一个中间速度$\\mathbf{u}^*$，在计算面通量时未使用Rhie–Chow插值，并且在出口处（此处$p=p_0$固定）为压力修正量组装压力修正方程时使用了齐次Neumann条件（法向梯度为零），且未指定全局压力参考点；对流项使用中心差分格式，时间步长的选择使得$Co \\approx 3$。压力线性求解器使用预条件共轭梯度（PCG）方法，配合简单的对角预条件子和宽松的收敛容差。PISO修正步数很少。模拟表现出发散，其特征是压力修正残差不断增长，以及$\\mathbf{u}$和$p$出现无界振荡。\n\n从不可压缩性约束和PISO算法中压力修正方程的定义出发，诊断导致发散的主要原因，需从边界条件不一致和算子奇异性的角度进行分析。然后，选择一套必要且充分的纠正措施，以恢复此瞬态问题的鲁棒收敛性。您的回答应基于第一性原理，并就离散连续性、压力-速度耦合、时间稳定性以及线性求解器行为提供合理的论证。\n\n哪个选项正确地识别并解决了问题？\n\nA. 增加PISO压力修正步数，并将压力求解器切换为代数多重网格（AMG），保持边界条件和时间步长不变。这将提高修正强度和多重网格的收敛性，从而解决发散问题。\n\nB. 在固定压力的出口处对压力修正量$p'$施加Dirichlet条件（在$p=p_0$的边界上$p'=0$），设置单个压力参考点以消除零空间，启用Rhie–Chow插值计算面通量，减小时间步长以确保$Co \\le 0.5$，对流项使用有界迎风格式或总变差减小（TVD）格式，并增加非正交压力修正步数以确保在非正交网格上的一致性。通过这些更改，离散压力方程是适定的，瞬态耦合也变得稳定。\n\nC. 在瞬态PISO中对压力应用强欠松弛，在出口处保留压力修正量的齐次Neumann边界条件，不设置压力参考点，并使用二阶中心差分格式处理对流项以最小化扩散。额外的精度和松弛将消除发散。\n\nD. 在出口处施加零法向速度以防止回流，在压力方程中加入人工可压缩项$\\beta \\,\\partial p/\\partial t$（其中$\\beta0$），并增加$\\Delta t$以平滑瞬态过程。这将使系统正则化并稳定瞬态演化。\n\nE. 在动量方程中直接加入一个散度阻尼项$\\epsilon \\nabla^2 p$（其中$\\epsilon0$），在所有边界上设置零梯度压力边界条件，并保持$Co \\approx 3$以避免过高的计算成本。增加的压力扩散将消除振荡并实现收敛。",
            "solution": "本题要求诊断一个设置不当的PISO算法模拟为何会发散，并从给出的选项中选择一套全面且正确的修正措施。\n\n### 缺陷分析\n\nPISO算法通过一个“预测-修正”的框架来求解速度-压力耦合的不可压缩Navier-Stokes方程。我们首先分析原设置中的几个致命缺陷。\n\n1.  **压力修正边界条件不一致与矩阵奇异性**:\n    -   物理问题在出口处指定了绝对压力 $p=p_0$（一个Dirichlet条件）。PISO算法通过 $p^{n+1} = p^n + p'$ 来更新压力。因此，为满足物理边界条件，压力修正量 $p'$ 在出口处应满足 $p' = p_0 - p^n$，这是一个 **Dirichlet条件** (通常简化为 $p'=0$)。\n    -   然而，原设置在出口为 $p'$ 施加了 **Neumann条件** ($\\partial p' / \\partial n = 0$)。这与物理边界条件不符。由于在入口和壁面也是Neumann条件，这导致 $p'$ 的泊松方程是一个在所有边界上都是纯Neumann条件的问题。\n    -   这样的线性系统是 **奇异的**：它的解只在相差一个常数时是唯一的，并且仅当源项（预测速度的散度）在整个域上积分为零时才有解（该条件通常不满足）。此外，问题中提到“未指定全局压力参考点”，这使得求解器无法处理奇异性。这是导致“压力修正残差不断增长”和发散的主要原因。\n\n2.  **压力-速度解耦（棋盘格振荡）**:\n    -   在同位网格（collocated grid）上，若直接使用相邻单元中心的速度进行插值来计算面通量，会导致压力场和速度场之间的解耦。这允许非物理的、高频的“棋盘格”压力振荡出现而速度场无法“感知”。\n    -   原设置“未使用Rhie–Chow插值”。**Rhie–Chow插值**正是为了解决此问题而设计的标准方法，它通过在面速度计算中引入压力梯度相关的项来重新耦合压力和速度。缺少此项是观察到“无界振荡”的直接原因。\n\n3.  **对流和时间稳定性问题**:\n    -   **中心差分格式** 用于对流项时，虽然是二阶精度，但它是非耗散的，在对流主导的流动中会引入严重的非物理振荡。\n    -   **库朗数 $Co \\approx 3$** 表示时间步长相对较大。虽然PISO是隐式算法，理论上对 $Co$ 数没有严格的稳定性限制，但高 $Co$ 数会引入较大的时间截断误差，并且当与非耗散的中心差分格式结合时，会放大数值不稳定性。对于精确的瞬态模拟，通常要求 $Co \\le 1$。\n\n4.  **非正交网格处理不当**:\n    -   在非正交网格上，离散化的压力泊松方程会包含非正交修正项。PISO算法的多次修正是为了迭代地处理这些项引入的误差。原设置中“PISO修正步数很少”，这不足以保证在非正交网格上的质量守恒和稳定性。\n\n### 选项评估\n\n**A**: 增加PISO修正步数和使用更强的AMG求解器是好的实践，但它们无法解决根本性的问题：一个由错误边界条件导致的不适定（奇异）线性系统，以及由缺少Rhie-Chow插值和不稳定的空间格式引起的振荡。**因此，A不正确。**\n\n**B**: 此选项提出了一套全面的修正方案，直接解决了上述所有关键缺陷：\n    -   在出口为 $p'$ 施加 **Dirichlet条件** ($p'=0$)，修正了边界条件的不一致性，使压力修正方程适定。\n    -   启用 **Rhie–Chow插值**，解决了压力-速度解耦问题。\n    -   减小时间步长至 **$Co \\le 0.5$** 并使用 **有界的高阶格式（如迎风或TVD）**，确保了对流项的稳定性和时间精度。\n    -   **增加非正交压力修正步数**，恰当地处理了网格非正交性。\n    **因此，B是正确且充分的解决方案。**\n\n**C**: 对PISO应用压力欠松弛会破坏其为瞬态问题设计的非迭代特性。保留错误的Neumann边界条件和不稳定的中心差分格式，只会使问题恶化。**因此，C不正确。**\n\n**D**: 在出口施加零法向速度从根本上改变了物理问题。引入人工可压缩性是一种完全不同的方法，而非修正PISO算法。增加 $\\Delta t$ 很可能会加剧不稳定性。**因此，D不正确。**\n\n**E**: 在动量方程中加入人工压力扩散项是一种非物理的、临时的“修复”。在所有边界上施加零梯度压力，对于一个有净流量的通道流问题，是物理上不正确的，并且同样会导致一个奇异的压力系统。**因此，E不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "关于算法精度的理论预测，最终必须通过数值实验来验证。这个实践将指导你设计并实施这样一个实验，以量化PISO算法的一个关键方面：时间步长 $\\Delta t$、压力求解器的收敛容差与最终残余的质量守恒误差之间的关系。通过这项数值研究，你将学会如何衡量算法的收敛阶数，并为确保仿真达到预期的精度水平而做出有原则的决策。",
            "id": "3432041",
            "problem": "考虑一个在坐标为 $(x,y) \\in [0,1]\\times[0,1]$ 的周期性单位平方域上建模的二维不可压缩瞬态流。在惯性可忽略的极限情况下，不可压缩纳维-斯托克斯方程简化为非定常斯托克斯方程。该方程通过 $\\nabla \\cdot \\mathbf{u} = 0$ 强制质量守恒，通过 $\\partial_t \\mathbf{u} = -\\nabla p + \\nu \\Delta \\mathbf{u} + \\mathbf{f}$ 实现动量平衡，其中 $\\mathbf{u}$ 是速度场，$p$ 是运动学压力，$\\nu$ 是运动粘度，$\\mathbf{f}$ 是彻体力。对于瞬态不可压缩流，一种常用的解耦策略是算子分裂压力隐式 (PISO) 算法。该算法对动量方程使用预测步，然后进行迭代压力修正，以在下一时间层级上近似满足无散度约束。在实践中，内部压力修正循环由修正后速度散度的容差来终止，这可能会引入残余的“声学污染”，其量级由 $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert$ 量化。\n\n您的任务是设计并实现一个数值实验，以分离并测量在一个带有基于散度的停止准则的类 PISO 内部修正过程中，残差 $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert_2$ 如何随时间步长 $\\Delta t$ 变化。请使用以下原则性设置：\n\n- 使用具有 $N \\times N$ 个均匀间隔点的周期性单位平方网格，网格间距为 $\\Delta x = \\Delta y = 1/N$。所有场都是无量纲的，因此无需报告物理单位。\n- 通过泰勒-格林涡定义在下一时间层 $t^{n+1}$ 的无散度基流：$\\mathbf{u}_{\\mathrm{base}}(x,y) = \\big(\\sin(2\\pi x)\\cos(2\\pi y), -\\cos(2\\pi x)\\sin(2\\pi y)\\big)$。\n- 通过添加一个与 $\\Delta t$ 成正比的梯度扰动来模拟 PISO 动量预测步，该预测步产生一个可压缩的临时速度：$\\mathbf{u}^{\\star}(x,y;\\Delta t) = \\mathbf{u}_{\\mathrm{base}}(x,y) + \\Delta t \\nabla \\chi(x,y)$，其中 $\\chi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。\n- 在周期性网格上使用二阶中心差分计算离散散度 $\\nabla \\cdot \\mathbf{u}^{\\star}$，并计算其离散 $L^2$ 范数，定义为 $\\lVert \\phi \\rVert_2 = \\sqrt{\\sum_{i,j} \\phi_{i,j}^2 \\, \\Delta x \\, \\Delta y}$。\n- 将内部 PISO 压力修正循环建模为一系列线性修正，每次迭代都以一个固定的、与 $\\Delta t$ 无关的收缩因子 $\\theta \\in (0,1)$ 按几何级数减小散度范数。如果 $R_0(\\Delta t) = \\lVert \\nabla \\cdot \\mathbf{u}^{\\star} \\rVert_2$ 表示初始散度范数，那么经过 $k$ 次修正后，散度范数为 $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$。当 $k$ 是满足 $R_k(\\Delta t) \\le \\epsilon(\\Delta t)$ 的最小值时，终止循环，其中 $\\epsilon(\\Delta t)$ 是用户指定的容差方案。\n\n您的程序必须使用以下固定的数值选项来实现上述过程：\n- 使用 $N = 64$，$\\nu$ 为任意值但在此简化实验中未显式使用，$\\theta = 0.5$。\n- 使用二阶中心差分和周期性包裹来离散化导数。\n- 使用离散 $L^2$ 范数，其中 $\\Delta x = \\Delta y = 1/N$。\n\n您必须研究最终散度范数相对于 $\\Delta t$ 的标度关系，针对两族容差 $\\epsilon(\\Delta t) = C \\Delta t^{\\alpha}$：\n- 族 A (候选二阶): $\\alpha = 2$，其中 $C = 10^{-2}$。\n- 族 B (候选一阶): $\\alpha = 1$，其中 $C = 10^{-2}$。\n\n对于每个族，使用时间步长测试集 $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$ 运行模拟：\n- 对于每个 $\\Delta t$，构造 $\\mathbf{u}^{\\star}$，计算 $R_0(\\Delta t)$，确定满足 $R_k(\\Delta t) \\le \\epsilon(\\Delta t)$ 的最小整数 $k$，并返回最终散度范数 $R_k(\\Delta t)$。\n- 根据得到的三个 $R_k(\\Delta t)$ 值，通过公式 $p = \\dfrac{\\log\\big(R_k(\\Delta t_i)/R_k(\\Delta t_{i+1})\\big)}{\\log\\big(\\Delta t_i/\\Delta t_{i+1}\\big)}$ 计算连续对之间的观测阶数 $p$，其中对为 $(\\Delta t_i,\\Delta t_{i+1}) = (0.2,0.1)$ 和 $(0.1,0.05)$。\n\n您的程序必须输出单行内容，包含一个含有四个浮点数的列表，顺序如下：\n- 族 A (其中 $\\alpha = 2$) 在时间步对 $(0.2,0.1)$ 和 $(0.1,0.05)$ 上的两个观测阶数 $p$。\n- 族 B (其中 $\\alpha = 1$) 在相同时间步对上的两个观测阶数 $p$。\n\n科学和数值要求：\n- 所有导数计算必须使用指定的有限差分算子进行显式实现；不要使用任何谱方法或解析恒等式来计算范数。\n- 所有计算都是无量纲的。无需物理单位。\n- 最终输出必须是下面描述的精确格式的单行。\n\n测试集和最终输出格式：\n- 使用上述固定的参数集，它们共同构成了每个容差族在 $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$ 上的测试集。\n- 您的程序应生成单行输出，其中包含四个结果，格式为方括号内以逗号分隔的列表（例如，\"[r1,r2,r3,r4]\"），其中每个 $r_i$ 是按上述规定计算的浮点数。",
            "solution": "所提出的问题是一个数值实验，旨在研究在一个简化的算子分裂压力隐式 (PISO) 算法模型中，用于瞬态不可压缩流的残余质量守恒误差的标度特性。主要目标是，在内部压力修正循环的两种不同容差方案下，确定最终散度范数 $\\lVert \\nabla \\cdot \\mathbf{u}^{n+1} \\rVert_2$ 相对于时间步长 $\\Delta t$ 的观测收敛阶 $p$。\n\n这个问题的理论基础在于不可压缩纳维-斯托克斯方程的投影法。这些方法将速度和压力的计算解耦。一个典型的时间步首先涉及通过求解一个动量方程来预测一个临时速度场 $\\mathbf{u}^\\star$，此时并不严格强制执行无散度约束。这个 $\\mathbf{u}^\\star$ 通常具有非零散度，即 $\\nabla \\cdot \\mathbf{u}^\\star \\neq 0$。随后，通过求解一个压力泊松方程 $\\Delta \\phi \\propto \\nabla \\cdot \\mathbf{u}^\\star$ 来计算压力修正量 $\\phi$，然后用它来同时修正速度场和压力场以满足约束条件，即 $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\tau \\nabla \\phi$，其中 $\\tau$ 与 $\\Delta t$ 相关。PISO 算法在单个时间步内多次重复此修正步骤，以改进对无散度条件的近似。\n\n这个问题为该过程提供了一个定义明确的抽象。\n1.  一个已知的无散度流，即泰勒-格林涡 $\\mathbf{u}_{\\mathrm{base}}$，代表了在新时间层 $t^{n+1}$ 的精确解。\n2.  临时速度 $\\mathbf{u}^{\\star} = \\mathbf{u}_{\\mathrm{base}} + \\Delta t \\nabla \\chi$ 模拟了动量预测步的结果。项 $\\Delta t \\nabla \\chi$ 引入了一个非零散度 $\\nabla \\cdot \\mathbf{u}^{\\star} = \\Delta t \\Delta \\chi$，它与时间步长 $\\Delta t$ 成正比，这是许多分裂格式的一个典型特征。\n3.  PISO 内部循环被建模为一个迭代过程，在每次迭代中将散度范数 $R_k = \\lVert \\nabla \\cdot \\mathbf{u}_k \\rVert_2$ 乘以一个常数因子 $\\theta$ 来减小它：$R_{k+1} = \\theta R_k$。这代表了求解压力泊松方程的定常迭代求解器（如 Jacobi 或 Gauss-Seidel）的收敛过程。\n4.  循环基于一个依赖于时间步长的容差 $\\epsilon(\\Delta t)$ 终止。这是一个关键方面，因为在精度和计算成本之间权衡容差的选择是一个关键的实践考量。\n\n我们现在将详细说明数值步骤。\n\n首先，我们定义计算网格。区域是一个周期性单位平方 $[0,1] \\times [0,1]$，由 $N \\times N$ 个点离散化，其中 $N=64$。网格坐标为 $(x_i, y_j)$，其中 $x_i = i \\Delta x$，$y_j = j \\Delta y$，对于 $i, j \\in \\{0, 1, \\dots, N-1\\}$。网格间距是均匀的，$\\Delta x = \\Delta y = 1/N$。\n\n在此网格上评估解析场：\n-   基流速度分量：$u_{\\mathrm{base}, i,j} = \\sin(2\\pi x_i)\\cos(2\\pi y_j)$ 和 $v_{\\mathrm{base}, i,j} = -\\cos(2\\pi x_i)\\sin(2\\pi y_j)$。\n-   扰动势：$\\chi_{i,j} = \\sin(2\\pi x_i)\\sin(2\\pi y_j)$。\n\n数值计算的核心涉及离散微分算子。我们使用带有周期性包裹的二阶中心差分。对于任意网格函数 $\\phi_{i,j}$，其偏导数近似为：\n$$ (\\delta_x \\phi)_{i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta x} $$\n$$ (\\delta_y \\phi)_{i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta y} $$\n其中索引对 $N$ 取模以强制周期性。\n\n对于每个给定的 $\\Delta t$，计算步骤如下：\n\n1.  **计算临时速度 $\\mathbf{u}^{\\star}$**：\n    临时速度 $\\mathbf{u}^{\\star} = (u^\\star, v^\\star)$ 的分量通过将扰动势的离散梯度加到基流上构建：\n    $$ u^\\star_{i,j} = u_{\\mathrm{base}, i,j} + \\Delta t (\\delta_x \\chi)_{i,j} $$\n    $$ v^\\star_{i,j} = v_{\\mathrm{base}, i,j} + \\Delta t (\\delta_y \\chi)_{i,j} $$\n\n2.  **计算 $\\mathbf{u}^{\\star}$ 的散度**：\n    在每个网格点上计算临时速度场的离散散度 $D_{i,j} = (\\nabla_h \\cdot \\mathbf{u}^\\star)_{i,j}$：\n    $$ D_{i,j} = (\\delta_x u^\\star)_{i,j} + (\\delta_y v^\\star)_{i,j} $$\n\n3.  **计算初始散度范数 $R_0(\\Delta t)$**：\n    初始误差通过散度场的离散 $L^2$ 范数量化：\n    $$ R_0(\\Delta t) = \\left\\| \\nabla_h \\cdot \\mathbf{u}^\\star \\right\\|_2 = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} D_{i,j}^2 \\, \\Delta x \\, \\Delta y} $$\n\n4.  **确定修正次数 $k$**：\n    对于由 $C$ 和 $\\alpha$ 定义的给定容差族，容差为 $\\epsilon(\\Delta t) = C \\Delta t^\\alpha$。我们找到最小的整数 $k \\ge 0$，使得修正后的散度范数 $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$ 满足容差要求：\n    $$ \\theta^k R_0(\\Delta t) \\le \\epsilon(\\Delta t) $$\n    如果 $R_0(\\Delta t) \\le \\epsilon(\\Delta t)$，则 $k=0$。否则，取对数（并注意因为 $\\theta=0.5$ 所以 $\\log(\\theta)  0$），我们得到 $k \\ge \\frac{\\log(\\epsilon(\\Delta t) / R_0(\\Delta t))}{\\log(\\theta)}$。因此，最小整数 $k$ 是：\n    $$ k = \\left\\lceil \\frac{\\log(\\epsilon(\\Delta t) / R_0(\\Delta t))}{\\log(\\theta)} \\right\\rceil $$\n\n5.  **计算最终散度范数 $R_k(\\Delta t)$**：\n    经过 $k$ 次修正后的最终残余散度就是 $R_k(\\Delta t) = \\theta^k R_0(\\Delta t)$。对于测试集中的每个 $\\Delta t$，该值都会被存储。\n\n对每个时间步长 $\\Delta t \\in \\{0.2, 0.1, 0.05\\}$ 以及两个容差族：族 A ($\\alpha=2, C=10^{-2}$) 和族 B ($\\alpha=1, C=10^{-2}$)，执行此过程。\n\n最后，我们计算观测收敛阶 $p$。给定一组对应于时间步长 $\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\}$ 的三个最终范数 $\\{R_k(\\Delta t_1), R_k(\\Delta t_2), R_k(\\Delta t_3)\\}$，阶数 $p$ 使用以下公式在连续对之间进行估计：\n$$ p = \\frac{\\log(R_k(\\Delta t_i) / R_k(\\Delta t_{i+1}))}{\\log(\\Delta t_i / \\Delta t_{i+1})} $$\n对于我们的时间步长测试集，比率 $\\Delta t_i / \\Delta t_{i+1}$ 总是 $2$，所以分母简化为 $\\log(2)$。\n\n预期的结果是最终散度范数 $R_k(\\Delta t)$ 将与容差 $\\epsilon(\\Delta t)$ 具有相似的标度关系，因为当范数大约在容差的量级时，迭代过程停止。因此，我们预计族 A 的观测阶数 $p$ 将接近 $\\alpha=2$，而族 B 的观测阶数将接近 $\\alpha=1$。该实现将精确计算这些阶数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements a numerical experiment to measure the scaling of residual divergence\n    in a simplified PISO-like algorithm for two different tolerance schedules.\n    \"\"\"\n    # Fixed numerical choices from the problem statement\n    N = 64\n    theta = 0.5\n    delta_t_suite = [0.2, 0.1, 0.05]\n\n    # Define the two families of tolerances epsilon(dt) = C * dt^alpha\n    families = [\n        {'C': 1e-2, 'alpha': 2, 'name': 'A'},\n        {'C': 1e-2, 'alpha': 1, 'name': 'B'}\n    ]\n\n    all_orders = []\n\n    # Setup computational grid\n    dx = 1.0 / N\n    dy = 1.0 / N\n    # Create coordinate arrays. endpoint=False for periodic domain [0, 1)\n    x = np.linspace(0, 1, N, endpoint=False)\n    y = np.linspace(0, 1, N, endpoint=False)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Define helper functions for discrete derivatives\n    def central_diff_x(field, hx):\n        # Second-order central difference in x-direction with periodic boundaries\n        return (np.roll(field, -1, axis=1) - np.roll(field, 1, axis=1)) / (2.0 * hx)\n\n    def central_diff_y(field, hy):\n        # Second-order central difference in y-direction with periodic boundaries\n        return (np.roll(field, -1, axis=0) - np.roll(field, 1, axis=0)) / (2.0 * hy)\n\n    # Evaluate analytical fields on the grid\n    u_base = np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy)\n    v_base = -np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    chi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n\n    # Pre-compute gradient of chi\n    grad_chi_x = central_diff_x(chi, dx)\n    grad_chi_y = central_diff_y(chi, dy)\n\n    # --- Main loop over tolerance families ---\n    for family in families:\n        C = family['C']\n        alpha = family['alpha']\n        final_norms = []\n\n        # --- Loop over the time-step suite ---\n        for delta_t in delta_t_suite:\n            # 1. Construct the provisional velocity field u_star\n            u_star = u_base + delta_t * grad_chi_x\n            v_star = v_base + delta_t * grad_chi_y\n\n            # 2. Compute the discrete divergence of u_star\n            div_u_star = central_diff_x(u_star, dx) + central_diff_y(v_star, dy)\n\n            # 3. Compute the initial divergence L2-norm, R0\n            R0 = np.sqrt(np.sum(div_u_star**2) * dx * dy)\n\n            # 4. Determine the number of corrections, k\n            epsilon = C * (delta_t**alpha)\n            \n            if R0 = epsilon:\n                k = 0\n            else:\n                # Calculate smallest integer k s.t. theta^k * R0 = epsilon\n                k_float = math.log(epsilon / R0) / math.log(theta)\n                k = math.ceil(k_float)\n\n            # 5. Compute the final divergence norm, Rk\n            Rk = (theta**k) * R0\n            final_norms.append(Rk)\n\n        # --- Compute observed orders for the current family ---\n        # Order for pair (dt_1, dt_2) = (0.2, 0.1)\n        p1 = (math.log(final_norms[0] / final_norms[1]) /\n              math.log(delta_t_suite[0] / delta_t_suite[1]))\n        \n        # Order for pair (dt_2, dt_3) = (0.1, 0.05)\n        p2 = (math.log(final_norms[1] / final_norms[2]) /\n              math.log(delta_t_suite[1] / delta_t_suite[2]))\n        \n        all_orders.extend([p1, p2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n\n```"
        }
    ]
}