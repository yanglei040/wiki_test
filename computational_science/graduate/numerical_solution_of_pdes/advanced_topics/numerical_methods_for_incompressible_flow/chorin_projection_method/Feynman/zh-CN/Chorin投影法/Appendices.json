{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，最好的巩固方式莫过于亲手实践。本节练习将引导你从最基础的层面入手，在一个简单的一维通道流模型中，手动构建Chorin投影法的核心部件。通过显式地写出离散散度（$D$）、梯度（$G$）和拉普拉斯（$L$）算子矩阵，你将深刻理解这些抽象概念在交错网格（MAC网格）上的具体实现，并完成一次完整的投影计算，直观地看到速度场是如何被校正以满足不可压缩条件的。",
            "id": "3301246",
            "problem": "考虑在一个长度为 $L$、在 $x=0$ 和 $x=L$ 处具有无滑移壁面的通道中，在交错网格 (MAC) 上的一维空间不可压缩纳维-斯托克斯方程。速度存储在面上，压力存储在单元中心。设有 $N$ 个大小均匀的控制体（单元），单元中心的索引为 $i=1,\\dots,N$，面的索引为 $j=0,\\dots,N$。网格间距为 $h=L/N$。与通道对齐的速度分量用 $u$ 表示，不可压缩性要求在投影后每个单元内的离散散度等于零。Chorin 方法的投影步通过求解压力的离散泊松方程，然后修正中间速度来强制实现不可压缩性。\n\n从质量守恒的有限体积表述（每个单元的面法向通量的离散散度）和内部面上压力梯度的中心差分近似（在壁面处采用与无滑移和零法向压力梯度一致的齐次诺伊曼边界条件）出发，针对 $N=4$，$L=1$ 米，$h=L/N$，密度 $\\rho=1$ 千克/米$^{3}$，时间步长 $\\Delta t=0.2$ 秒的具体情况，完成以下任务：\n\n1. 定义离散散度算子 $D \\in \\mathbb{R}^{N \\times (N+1)}$，该算子使用二阶有限体积通量差分，将面速度 $\\boldsymbol{u} \\in \\mathbb{R}^{N+1}$ 映射到单元中心的散度。对于排序为 $\\boldsymbol{u} = \\big(u_0,u_1,\\dots,u_N\\big)^{\\mathsf{T}}$ 且 $\\boldsymbol{d} = D \\boldsymbol{u}$（其中 $\\boldsymbol{d} \\in \\mathbb{R}^{N}$ 按单元 $i=1,\\dots,N$ 排序），写出其显式矩阵项。\n\n2. 定义离散梯度算子 $G \\in \\mathbb{R}^{(N+1) \\times N}$，该算子将单元中心的压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$ 映射到面中心的压力梯度，在内部面 $j=1,\\dots,N-1$ 上使用中心差分，并在边界面 $j=0$ 和 $j=N$ 上使用齐次诺伊曼条件。写出其显式矩阵项。\n\n3. 构建离散压力拉普拉斯算子 $L = D G \\in \\mathbb{R}^{N \\times N}$ 并写出其显式矩阵形式。陈述诺伊曼问题的可解性条件以及为获得唯一压力将使用的规范约束。\n\n4. 给定中间面速度向量（单位：米/秒）\n$$\n\\boldsymbol{u}^{\\ast} \\;=\\; \\big(0,\\;0.8,\\;-0.4,\\;0.6,\\;0\\big)^{\\mathsf{T}},\n$$\n从第一性原理推导投影步中压力的离散泊松方程，并求解唯一的均值为零的离散压力 $\\boldsymbol{p} \\in \\mathbb{R}^{N}$（单位：帕）。然后通过投影更新计算修正后的面速度，该更新在壁面处强制实施无滑移条件。\n\n第二个单元中心的压力值 $p_2$ 是多少（单位：帕）？将您的答案四舍五入到四位有效数字，并以帕斯卡（Pa）表示。",
            "solution": "该问题要求计算第二个单元中心的压力值 $p_2$，这是针对不可压缩纳维-斯托克斯方程的 Chorin 方法中投影步的一部分。该问题定义明确，并提供了所有必要的数据和边界条件。我们将通过系统地构建离散算子并求解最终的压力泊松方程来继续。\n\n给定具体情况的参数如下：\n- 单元数量：$N=4$\n- 通道长度：$L=1$ 米\n- 单元宽度：$h = \\frac{L}{N} = \\frac{1}{4} = 0.25$ 米\n- 流体密度：$\\rho=1$ 千克/米$^3$\n- 时间步长：$\\Delta t = 0.2$ 秒\n- 中间速度向量：$\\boldsymbol{u}^{\\ast} = \\big(0, 0.8, -0.4, 0.6, 0\\big)^{\\mathsf{T}}$ 米/秒\n\n**1. 离散散度算子 $D$**\n\n离散散度算子 $D$ 将面中心的速度 $\\boldsymbol{u} = \\big(u_0, u_1, u_2, u_3, u_4\\big)^{\\mathsf{T}}$ 映射到单元中心的散度 $\\boldsymbol{d} = \\big(d_1, d_2, d_3, d_4\\big)^{\\mathsf{T}}$。对于均匀网格，单元 $i$（其面为 $i-1$ 和 $i$）中的散度是单位体积（二维中为面积，一维中为长度）的净通量，由下式给出：\n$$\nd_i = (\\nabla \\cdot \\boldsymbol{u})_i = \\frac{u_i - u_{i-1}}{h}\n$$\n其中 $i=1, \\dots, N$。这定义了 $N \\times (N+1)$ 矩阵 $D$ 的行。当 $N=4$ 且 $h=0.25$ 时，有 $1/h=4$，该算子为：\n$$\n\\boldsymbol{d} = D\\boldsymbol{u} = \\frac{1}{h}\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ u_3 \\\\ u_4 \\end{pmatrix}\n$$\n\n**2. 离散梯度算子 $G$**\n\n离散梯度算子 $G$ 将单元中心的压力 $\\boldsymbol{p} = \\big(p_1, p_2, p_3, p_4\\big)^{\\mathsf{T}}$ 映射到面中心的梯度 $(\\nabla p)_j$。\n- 对于内部面 $j=1, \\dots, N-1$，使用中心差分。面 $j$ （在单元 $j$ 和 $j+1$ 之间）处的梯度为：\n  $$ (\\nabla p)_j = \\frac{p_{j+1} - p_j}{h} $$\n- 对于边界面 $j=0$ 和 $j=N=4$，应用齐次诺伊曼条件 $(\\nabla p)_0 = 0$ 和 $(\\nabla p)_N = 0$。\n\n这定义了 $(N+1) \\times N$ 矩阵 $G$：\n$$\nG \\boldsymbol{p} = \\frac{1}{h}\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n4\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n$$\n对于此类离散化，一个常见的性质是，若忽略边界条件，则 $G$ 是 $D$ 的负转置，即 $D = -G^{\\mathsf{T}}$。$G$ 中的零行代表诺伊曼边界条件。\n\n**3. 离散压力拉普拉斯算子 $L = DG$**\n\n离散拉普拉斯算子是一个通过乘积 $L=DG$ 形成的 $N \\times N$ 矩阵。\n$$\nL = DG = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1  1  0  0  0 \\\\\n0  -1  1  0  0 \\\\\n0  0  -1  1  0 \\\\\n0  0  0  -1  1\n\\end{pmatrix}\n\\begin{pmatrix}\n0  0  0  0 \\\\\n-1  1  0  0 \\\\\n0  -1  1  0 \\\\\n0  0  -1  1 \\\\\n0  0  0  0\n\\end{pmatrix}\n$$\n执行矩阵乘法得到：\n$$\nL = \\frac{1}{h^2}\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n$$\n代入 $h=0.25$，我们有 $1/h^2 = 1/(0.0625) = 16$。\n$$\nL = 16\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n$$\n这是具有诺伊曼边界条件的二阶导数的标准一维有限差分表示。每行元素的总和为零，这意味着矩阵 $L$ 是奇异的。其零空间由常数向量 $\\boldsymbol{c} = (c, c, \\dots, c)^{\\mathsf{T}}$ 组成。诺伊曼问题 $L\\boldsymbol{p} = \\boldsymbol{f}$ 的可解性条件是右端向量 $\\boldsymbol{f}$ 必须与 $L^{\\mathsf{T}}$ 的零空间正交。由于 $L$ 是对称的（$L=L^{\\mathsf{T}}$），这意味着 $\\boldsymbol{f}$ 必须与常数向量正交，这要求其分量之和为零：$\\sum_{i=1}^N f_i = 0$。为了获得 $\\boldsymbol{p}$ 的唯一解，需要施加一个规范约束，例如固定一个压力值或按要求使平均压力为零：$\\sum_{i=1}^N p_i = 0$。\n\n**4. 求解压力**\n\n投影步涉及求解一个压力的泊松方程，该方程修正中间速度场 $\\boldsymbol{u}^*$ 使其无散度。更新步骤为 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} \\nabla p$。要求 $\\nabla \\cdot \\boldsymbol{u}^{n+1}=0$ 会得到压力泊松方程：\n$$\n\\nabla^2 p = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^*\n$$\n其离散形式为 $L\\boldsymbol{p} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n\n首先，我们计算右端项 $\\boldsymbol{f} = \\frac{\\rho}{\\Delta t} D\\boldsymbol{u}^*$。\n$$\n\\frac{\\rho}{\\Delta t} = \\frac{1 \\text{ kg/m}^3}{0.2 \\text{ s}} = 5 \\text{ kg/(m}^3 \\cdot \\text{s)}\n$$\n$$\nD\\boldsymbol{u}^* = \\frac{1}{h}\n\\begin{pmatrix} u_1^* - u_0^* \\\\ u_2^* - u_1^* \\\\ u_3^* - u_2^* \\\\ u_4^* - u_3^* \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 - 0 \\\\ -0.4 - 0.8 \\\\ 0.6 - (-0.4) \\\\ 0 - 0.6 \\end{pmatrix}\n= 4\n\\begin{pmatrix} 0.8 \\\\ -1.2 \\\\ 1.0 \\\\ -0.6 \\end{pmatrix}\n=\n\\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix} \\text{ s}^{-1}\n$$\n各分量之和为 $3.2 - 4.8 + 4.0 - 2.4 = 0$，满足可解性条件。现在，我们计算 $\\boldsymbol{f}$：\n$$\n\\boldsymbol{f} = 5 \\times D\\boldsymbol{u}^* =\n5 \\begin{pmatrix} 3.2 \\\\ -4.8 \\\\ 4.0 \\\\ -2.4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix} \\text{ Pa/m}^2\n$$\n需要求解的线性系统是 $L\\boldsymbol{p} = \\boldsymbol{f}$：\n$$\n16\n\\begin{pmatrix}\n-1  1  0  0 \\\\\n1  -2  1  0 \\\\\n0  1  -2  1 \\\\\n0  0  1  -1\n\\end{pmatrix}\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\\\ p_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 16 \\\\ -24 \\\\ 20 \\\\ -12 \\end{pmatrix}\n$$\n两边除以 $16$ 得到方程组：\n1.  $-p_1 + p_2 = 1$\n2.  $p_1 - 2p_2 + p_3 = -1.5$\n3.  $p_2 - 2p_3 + p_4 = 1.25$\n4.  $p_3 - p_4 = -0.75$\n\n我们用均值为零的规范约束来补充这些方程：\n5.  $p_1 + p_2 + p_3 + p_4 = 0$\n\n由方程（1）得，$p_1 = p_2 - 1$。\n由方程（4）得，$p_4 = p_3 + 0.75$。\n将 $p_1$ 代入方程（2）：\n$(p_2 - 1) - 2p_2 + p_3 = -1.5 \\implies -p_2 + p_3 = -0.5 \\implies p_3 = p_2 - 0.5$。\n现在用 $p_2$ 表示 $p_4$：\n$p_4 = p_3 + 0.75 = (p_2 - 0.5) + 0.75 = p_2 + 0.25$。\n\n我们已经用 $p_2$ 表示了所有的压力：\n- $p_1 = p_2 - 1$\n- $p_2 = p_2$\n- $p_3 = p_2 - 0.5$\n- $p_4 = p_2 + 0.25$\n\n现在，将这些代入规范约束（5）：\n$$ (p_2 - 1) + p_2 + (p_2 - 0.5) + (p_2 + 0.25) = 0 $$\n$$ 4p_2 - 1.25 = 0 $$\n$$ 4p_2 = 1.25 $$\n$$ p_2 = \\frac{1.25}{4} = \\frac{5/4}{4} = \\frac{5}{16} = 0.3125 $$\n第二个单元中心的压力值 $p_2$ 是 $0.3125$ 帕。题目要求答案四舍五入到四位有效数字，这恰好是 $0.3125$。\n\n作为最后的验证，我们可以计算修正后的速度场 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p}$。\n压力向量为 $\\boldsymbol{p} = (-0.6875, 0.3125, -0.1875, 0.5625)^{\\mathsf{T}}$。\n压力梯度项为：\n$$\n\\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = 0.2 \\times 4 \\times\n\\begin{pmatrix}\n0 \\\\\np_2 - p_1 \\\\\np_3 - p_2 \\\\\np_4 - p_3 \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n0.3125 - (-0.6875) \\\\\n-0.1875 - 0.3125 \\\\\n0.5625 - (-0.1875) \\\\\n0\n\\end{pmatrix}\n= 0.8\n\\begin{pmatrix}\n0 \\\\\n1 \\\\\n-0.5 \\\\\n0.75 \\\\\n0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0.8 \\\\\n-0.4 \\\\\n0.6 \\\\\n0\n\\end{pmatrix}\n$$\n修正后的速度为：\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^* - \\frac{\\Delta t}{\\rho} G \\boldsymbol{p} = \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0 \\\\ 0.8 \\\\ -0.4 \\\\ 0.6 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n最终速度处处为零。它显然是无散度的（$D\\boldsymbol{u}^{n+1} = \\boldsymbol{0}$）并且满足无滑移边界条件（$u_0^{n+1}=0, u_4^{n+1}=0$）。这证实了计算的正确性。\n\n第二个单元中心的压力值 $p_2$ 是 $0.3125$ 帕。",
            "answer": "$$\\boxed{0.3125}$$"
        },
        {
            "introduction": "在真实的计算流体动力学（CFD）模拟中，压力泊松方程往往通过迭代法进行近似求解，而非直接求得精确解。这次的实践练习将理论与编程相结合，旨在揭示一个至关重要的问题：压力求解器的精度如何直接影响最终流场的质量守恒性？你将首先从理论上推导出校正后速度场的离散散度范数与求解器残差（即求解误差）之间的定量关系，然后通过编写程序，用数值实验来验证这一关系，从而掌握在实际应用中如何设置合理的求解器容差以控制计算误差。",
            "id": "3301215",
            "problem": "考虑不可压缩的 Navier–Stokes 方程以及一种算子分裂格式，其中速度通过投影步骤进行更新以强制满足不可压缩性。在 Chorin 的投影法中，首先使用不含压力的动量方程推进到一个中间速度场 $u^\\ast$，然后通过求解一个类压力变量 $p$ 的泊松方程并进行投影来强制满足不可压缩性：\n$$\nu^{n+1} \\leftarrow u^\\ast - \\frac{\\Delta t}{\\rho}\\,\\nabla p,\n$$\n其目的是使修正后的速度满足离散无散约束。假设在周期性方形域 $[0,1]^2$ 上有一个均匀的笛卡尔网格，每个方向的网格间距为 $h = 1/N$，并采用交错的标记-单元 (Marker-And-Cell, MAC) 离散化方法：水平速度分量位于水平面中心，垂直速度分量位于垂直面中心，而压力和散度位于单元中心。记 $\\nabla_h \\cdot$ 为 MAC 离散散度算子，将面心速度映射到单元中心；记 $\\nabla_h$ 为 MAC 离散梯度算子，将单元中心压力映射到面；记 $L_h$ 为单元中心的标准五点离散拉普拉斯算子。在周期性边界条件下，MAC 算子满足相容性恒等式 $\\nabla_h \\cdot \\nabla_h p = L_h p$。令 $\\|\\cdot\\|_{2}$ 表示所有网格值组成的向量的未加权欧几里得范数，令 $\\|\\cdot\\|_{L^2_h}$ 表示在域上定义的离散 $L^2$ 范数，其定义为\n$$\n\\|q\\|_{L^2_h} \\equiv \\left( \\sum_{i,j} |q_{i,j}|^2\\, h^2 \\right)^{1/2}.\n$$\n在压力投影中，类压力变量 $p_h$ 通过求解离散泊松方程\n$$\nL_h p_h = b_h, \\quad \\text{其中} \\quad b_h = \\frac{\\rho}{\\Delta t} \\, (\\nabla_h \\cdot u^\\ast),\n$$\n来计算，但假设线性求解是不精确的，并在残差 $r_h = L_h p_h - b_h$ 满足停止准则时终止。然后用这个不精确的 $p_h$ 执行投影。两种常见的停止准则是：\n1. 绝对容差：对于给定的 $\\varepsilon_{\\mathrm{abs}} > 0$，有 $\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{abs}}$。\n2. 相对容差：对于给定的 $\\varepsilon_{\\mathrm{rel}} > 0$，有 $\\|r_h\\|_{2} \\le \\varepsilon_{\\mathrm{rel}} \\, \\|b_h\\|_{2}$。\n\n仅从 MAC 离散化的基本性质、投影更新的定义以及上述范数出发，推导修正后速度的离散质量守恒误差（以离散 $L^2$ 范数 $\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 度量）、求解器容差（$\\varepsilon_{\\mathrm{abs}}$ 或 $\\varepsilon_{\\mathrm{rel}}$）和网格间距 $h$ 之间的定量关系。使用无量纲单位，其中 $\\rho = 1$ 且 $\\Delta t = 1$。\n\n然后，实现一个程序，通过在均匀周期性网格上适当的面位置对连续场\n$$\nu_x(x,y) = \\sin(2\\pi x)\\,\\sin(2\\pi y), \\qquad u_y(x,y) = \\cos(2\\pi x)\\,\\sin(2\\pi y),\n$$\n进行采样，来构造 MAC 网格上的光滑面心中间速度场 $u^\\ast_h$，计算相应的单元中心 $b_h = \\nabla_h \\cdot u^\\ast_h$，并在不实际求解线性系统的情况下，根据推导出的关系和两种停止准则，评估预测的离散质量守恒误差 $\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$。利用连接 $\\nabla_h \\cdot u^{n+1}$ 与残差 $r_h$ 的恒等式以及离散范数之间的关系，来评估给定容差下的误差大小。\n\n构建以下测试套件以探究不同的标度关系：\n- 固定网格分辨率下的绝对容差标度关系：固定 $N = 64$，使用 $\\varepsilon_{\\mathrm{abs}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算 $\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 相对于 $\\log \\varepsilon_{\\mathrm{abs}}$ 的斜率（以 $e$ 为底的对数回归）。\n- 固定容差下随网格间距变化的绝对容差标度关系：固定 $\\varepsilon_{\\mathrm{abs}} = 10^{-6}$，使用 $N \\in \\{32, 64, 128\\}$（因此 $h \\in \\{1/32,1/64,1/128\\}$），计算 $\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 相对于 $\\log h$ 的斜率。\n- 固定网格分辨率下的相对容差标度关系：固定 $N = 64$，使用 $\\varepsilon_{\\mathrm{rel}} \\in \\{10^{-6}, 5\\times 10^{-7}, 2.5\\times 10^{-7}\\}$，计算 $\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 相对于 $\\log \\varepsilon_{\\mathrm{rel}}$ 的斜率。\n- 固定容差下随网格间距变化的相对容差标度关系：固定 $\\varepsilon_{\\mathrm{rel}} = 10^{-6}$，使用 $N \\in \\{32, 64, 128\\}$，计算 $\\log \\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 相对于 $\\log h$ 的斜率。\n\n对于上述四种情况，通过对数据点对 $(\\log x, \\log y)$ 进行线性最小二乘拟合来估计斜率，其中 $x$ 相应地为 $\\varepsilon_{\\mathrm{abs}}$、$h$、$\\varepsilon_{\\mathrm{rel}}$ 或 $h$，而 $y$ 是对应的 $\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$。您的程序应输出一行，其中包含按此顺序排列的四个斜率：\n- 首先，绝对容差相对于 $\\varepsilon_{\\mathrm{abs}}$ 的斜率，\n- 其次，绝对容差相对于 $h$ 的斜率，\n- 第三，相对容差相对于 $\\varepsilon_{\\mathrm{rel}}$ 的斜率，\n- 第四，相对容差相对于 $h$ 的斜率，\n保留三位小数。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个斜率，格式为逗号分隔的列表并用方括号括起，例如“[s1,s2,s3,s4]”。由于输出的是无量纲的斜率，因此不需要物理单位。",
            "solution": "### 基于原理的解答\n\n目标是推导投影速度场的离散质量守恒误差 $\\|\\nabla_h \\cdot u^{n+1}\\|_{L^2_h}$ 与数值方法参数（即求解器容差和网格间距）之间的定量关系。\n\n**1. 将散度误差与泊松求解器残差联系起来**\n\n投影法分两步更新速度。我们关注的是第二步，即实施不可压缩性约束的投影步骤。速度场 $u_h$ 的离散更新规则如下：\n$$\nu_h^{n+1} = u_h^\\ast - \\frac{\\Delta t}{\\rho} \\nabla_h p_h\n$$\n其中 $u_h^{n+1}$ 是新速度，$u_h^\\ast$ 是中间速度，$\\nabla_h p_h$ 是离散压力梯度，$\\Delta t$ 是时间步长，$\\rho$ 是密度。问题陈述要求使用无量纲单位，其中 $\\rho = 1$ 和 $\\Delta t = 1$，这简化了方程为：\n$$\nu_h^{n+1} = u_h^\\ast - \\nabla_h p_h\n$$\n为了评估新速度场的质量守恒，我们将离散散度算子 $\\nabla_h \\cdot$ 应用于此方程。该算子将面心速度数据映射到单元中心散度数据。\n$$\n\\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - \\nabla_h \\cdot (\\nabla_h p_h)\n$$\n问题提供了在周期域上 MAC 离散化的恒等式：$\\nabla_h \\cdot \\nabla_h p_h = L_h p_h$，其中 $L_h$ 是作用于单元中心数据的离散拉普拉斯算子。代入此恒等式得：\n$$\n\\nabla_h \\cdot u_h^{n+1} = \\nabla_h \\cdot u_h^\\ast - L_h p_h\n$$\n类压力变量 $p_h$ 是通过求解离散泊松方程 $L_h p_h = b_h$ 得到的，其中源项为 $b_h = \\frac{\\rho}{\\Delta t} \\nabla_h \\cdot u_h^\\ast$。在我们使用的单位常数下，这变成 $b_h = \\nabla_h \\cdot u_h^\\ast$。问题指定这个线性系统被不精确地求解，导致一个非零残差 $r_h$：\n$$\nr_h = L_h p_h - b_h\n$$\n我们可以重新整理这个残差的定义，将 $L_h p_h$ 表示为 $L_h p_h = b_h + r_h$。将此式以及 $b_h$ 的定义代入 $u_h^{n+1}$ 的散度方程中：\n$$\n\\nabla_h \\cdot u_h^{n+1} = b_h - (b_h + r_h)\n$$\n这简化为投影方法的一个基本恒等式：\n$$\n\\nabla_h \\cdot u_h^{n+1} = -r_h\n$$\n此结果表明，投影速度场的离散散度精确地等于不精确压力泊松求解的残差的相反数。\n\n**2. 关联范数**\n\n问题要求我们使用离散 $L^2_h$ 范数量化误差。根据上述恒等式，我们有：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = \\|-r_h\\|_{L^2_h} = \\|r_h\\|_{L^2_h}\n$$\n线性求解器的停止准则是根据未加权欧几里得范数 $\\|\\cdot\\|_2$ 给出的。我们必须将 $\\|\\cdot\\|_{L^2_h}$ 范数与 $\\|\\cdot\\|_2$ 范数关联起来。对于定义在 $N \\times N$ 单元中心上的任何网格函数 $q_h$，定义如下：\n$$\n\\|q_h\\|_{L^2_h}^2 = \\sum_{i,j=0}^{N-1} |q_{h,i,j}|^2 h^2 \\quad \\text{和} \\quad \\|q_h\\|_2^2 = \\sum_{i,j=0}^{N-1} |q_{h,i,j}|^2\n$$\n通过从第一个和式中提出常数 $h^2$，我们找到了直接关系：\n$$\n\\|q_h\\|_{L^2_h}^2 = h^2 \\|q_h\\|_2^2 \\implies \\|q_h\\|_{L^2_h} = h \\|q_h\\|_2\n$$\n将此关系应用于残差 $r_h$，我们得到了散度误差的核心表达式：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} = h \\|r_h\\|_2\n$$\n\n**3. 停止准则分析**\n\n我们现在通过将两个指定的停止准则代入此表达式来进行分析。我们假设求解器在准则的边界处终止，这代表了最坏情况。\n\n**情况 A：绝对容差**\n停止准则是 $\\|r_h\\|_2 \\le \\varepsilon_{\\mathrm{abs}}$。在终止时，我们有 $\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{abs}}$。因此，散度误差为：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{abs}}\n$$\n该关系预测了以下标度律：\n- 在固定网格分辨率（固定的 $h$）下，误差 $\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h}$与 $\\varepsilon_{\\mathrm{abs}}$ 成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$ 相对于 $\\log(\\varepsilon_{\\mathrm{abs}})$ 的斜率为 $1$。\n- 在固定容差（固定的 $\\varepsilon_{\\mathrm{abs}}$）下，误差与 $h$ 成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$ 相对于 $\\log(h)$ 的斜率为 $1$。\n\n**情况 B：相对容差**\n停止准则是 $\\|r_h\\|_2 \\le \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2$。在终止时，我们有 $\\|r_h\\|_2 \\approx \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2$。散度误差为：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} \\|b_h\\|_2\n$$\n为了理解相对于 $h$ 的标度关系，我们必须确定 $\\|b_h\\|_2$ 如何依赖于 $h$。$b_h = \\nabla_h \\cdot u_h^\\ast$ 项是连续散度 $\\nabla \\cdot u$ 的离散逼近。对于一个光滑的速度场，离散算子 $\\nabla_h \\cdot$是一致的，即当 $h \\to 0$ 时，$(\\nabla_h \\cdot u_h^\\ast)(x,y) \\to (\\nabla \\cdot u)(x,y)$。离散 $L^2_h$ 范数旨在逼近连续 $L^2$ 积分范数：\n$$\n\\|b_h\\|_{L^2_h}^2 = \\sum_{i,j} |b_{h,i,j}|^2 h^2 \\xrightarrow{h \\to 0} \\int_{[0,1]^2} |(\\nabla \\cdot u)(x,y)|^2 dx dy\n$$\n右侧的积分对于给定的连续场 $u$ 是一个常数。因此，对于小的 $h$ 值，$\\|b_h\\|_{L^2_h}$ 近似为常数。利用范数之间的关系 $\\|b_h\\|_2 = h^{-1}\\|b_h\\|_{L^2_h}$，我们推导出标度关系：\n$$\n\\|b_h\\|_2 \\propto h^{-1}\n$$\n将此标度关系代回相对容差情况的误差表达式：\n$$\n\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h} \\approx h \\varepsilon_{\\mathrm{rel}} (C h^{-1}) = C \\varepsilon_{\\mathrm{rel}}\n$$\n其中 $C$ 是一个与连续散度的 $L^2$ 范数相关的常数。该关系预测：\n- 在固定网格分辨率（固定的 $h$）下，误差 $\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h}$与 $\\varepsilon_{\\mathrm{rel}}$ 成正比。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$ 相对于 $\\log(\\varepsilon_{\\mathrm{rel}})$ 的斜率为 $1$。\n- 在固定容差（固定的 $\\varepsilon_{\\mathrm{rel}}$）下，误差近似独立于网格间距 $h$。$\\log(\\|\\nabla_h \\cdot u_h^{n+1}\\|_{L^2_h})$ 相对于 $\\log(h)$ 的斜率为 $0$。\n\n所提供的问题要求实现一个程序来数值验证这四个预测的斜率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_bh_norm2(N):\n    \"\"\"\n    Computes the Euclidean norm of the discrete divergence of the\n    intermediate velocity field u* on a MAC grid.\n\n    Args:\n        N (int): The number of grid cells in each direction.\n\n    Returns:\n        float: The Euclidean L2 norm of the discrete divergence vector b_h.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Create grid indices for an N x N grid\n    j_idx, i_idx = np.indices((N, N))\n\n    # Define coordinates for the horizontal (u) velocity components\n    # ux is located at (i*h, (j+0.5)*h)\n    x_u = i_idx * h\n    y_u = (j_idx + 0.5) * h\n    \n    # Define coordinates for the vertical (v) velocity components\n    # uy is located at ((i+0.5)*h, j*h)\n    x_v = (i_idx + 0.5) * h\n    y_v = j_idx * h\n\n    # Sample the continuous velocity field to get the discrete intermediate velocity u*\n    # u_x(x,y) = sin(2*pi*x)*sin(2*pi*y)\n    # u_y(x,y) = cos(2*pi*x)*sin(2*pi*y)\n    ux_h = np.sin(2 * np.pi * x_u) * np.sin(2 * np.pi * y_u)\n    uy_h = np.cos(2 * np.pi * x_v) * np.sin(2 * np.pi * y_v)\n\n    # Compute the discrete divergence b_h = nabla_h . u* at cell centers.\n    # The divergence at cell (j,i) is (u_right - u_left)/h + (u_top - u_bottom)/h.\n    # On a periodic MAC grid, u_left of cell (j,i) is ux_h[j,i] and u_right is ux_h[j,(i+1)%N].\n    # Similarly, u_bottom is uy_h[j,i] and u_top is uy_h[(j+1)%N,i].\n    # We use np.roll for efficient periodic boundary handling.\n    # np.roll(ux_h, -1, axis=1) corresponds to ux_h[j, (i+1)%N]\n    # np.roll(uy_h, -1, axis=0) corresponds to uy_h[(j+1)%N, i]\n    b_h = ((np.roll(ux_h, -1, axis=1) - ux_h) + (np.roll(uy_h, -1, axis=0) - uy_h)) / h\n    \n    # The Euclidean norm ||b_h||_2 is equivalent to the Frobenius norm of the matrix\n    b_h_norm2 = np.linalg.norm(b_h)\n    \n    return b_h_norm2\n\ndef get_slope(x_values, y_values):\n    \"\"\"\n    Performs a linear regression on the base-e logarithm of the data.\n\n    Args:\n        x_values (np.ndarray): The independent variable values.\n        y_values (np.ndarray): The dependent variable values.\n\n    Returns:\n        float: The slope of the line fitted to (log(x), log(y)).\n    \"\"\"\n    log_x = np.log(x_values)\n    log_y = np.log(y_values)\n    # np.polyfit with degree 1 returns [slope, intercept]\n    slope, _ = np.polyfit(log_x, log_y, 1)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to perform the four scaling tests and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Absolute tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'abs_vs_eps'},\n        # 2. Absolute tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'abs_vs_h'},\n        # 3. Relative tolerance scaling with tol, fixed N\n        {'N_vals': np.array([64]), 'eps_vals': np.array([1e-6, 5e-7, 2.5e-7]), 'mode': 'rel_vs_eps'},\n        # 4. Relative tolerance scaling with h, fixed tol\n        {'N_vals': np.array([32, 64, 128]), 'eps_vals': np.array([1e-6]), 'mode': 'rel_vs_h'},\n    ]\n\n    results = []\n\n    # Case 1: Absolute tolerance vs. epsilon_abs\n    case1 = test_cases[0]\n    N1 = case1['N_vals'][0]\n    h1 = 1.0 / N1\n    eps_abs_vals = case1['eps_vals']\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors1 = h1 * eps_abs_vals\n    slope1 = get_slope(eps_abs_vals, errors1)\n    results.append(slope1)\n\n    # Case 2: Absolute tolerance vs. h\n    case2 = test_cases[1]\n    N_vals2 = case2['N_vals']\n    h_vals2 = 1.0 / N_vals2\n    eps_abs2 = case2['eps_vals'][0]\n    # Derived relationship: ||div u||_L2h = h * eps_abs\n    errors2 = h_vals2 * eps_abs2\n    slope2 = get_slope(h_vals2, errors2)\n    results.append(slope2)\n\n    # Case 3: Relative tolerance vs. epsilon_rel\n    case3 = test_cases[2]\n    N3 = case3['N_vals'][0]\n    h3 = 1.0 / N3\n    eps_rel_vals = case3['eps_vals']\n    b_h_norm2_N64 = compute_bh_norm2(N3)\n    # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n    errors3 = h3 * eps_rel_vals * b_h_norm2_N64\n    slope3 = get_slope(eps_rel_vals, errors3)\n    results.append(slope3)\n\n    # Case 4: Relative tolerance vs. h\n    case4 = test_cases[3]\n    N_vals4 = case4['N_vals']\n    h_vals4 = 1.0 / N_vals4\n    eps_rel4 = case4['eps_vals'][0]\n    errors4 = []\n    for N_val in N_vals4:\n        h_val = 1.0 / N_val\n        b_h_norm2 = compute_bh_norm2(N_val)\n        # Derived relationship: ||div u||_L2h = h * eps_rel * ||b_h||_2\n        error = h_val * eps_rel4 * b_h_norm2\n        errors4.append(error)\n    errors4 = np.array(errors4)\n    slope4 = get_slope(h_vals4, errors4)\n    results.append(slope4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]:.3f},{results[1]:.3f},{results[2]:.3f},{results[3]:.3f}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了求解器精度，网格的布置方式也是影响数值稳定性的关键因素。与天然稳定的交错网格不同，一种更直接的配置——同位网格（collocated grid），在实践中常因压力与速度解耦而引发非物理的“棋盘”状压力振荡。本练习将带你直面这一经典的数值难题，通过编程实现并对比三种不同的投影格式：朴素的同位格式、经典的Rhie-Chow插值格式以及精确的离散投影。你将通过量化指标，清晰地看到Rhie-Chow插值是如何有效抑制压力振荡，确保计算结果的物理真实性的。",
            "id": "3301242",
            "problem": "考虑一个单位正方形域上的二维不可压缩流，该域具有均匀间距和 $N \\times N$ 个单元中心的同位网格 (collocated grid)。本问题的基础是不可压缩的 Navier–Stokes 方程和 Chorin 的投影法。控制方程是质量和动量守恒方程，其投影思想是：一个中间速度 $u^\\*$ 由压力 $p$ 进行修正，从而使得修正后的速度 $u^{n+1}$ 是无散度的。在连续形式下，这表示为 $u^{n+1} = u^\\* - \\frac{\\Delta t}{\\rho} \\nabla p$ 和 $\\nabla \\cdot u^{n+1} = 0$，其中 $\\rho$ 是密度，$\\Delta t$ 是时间步长。压力 $p$ 是通过求解一个由施加不可压缩约束推导出的压力泊松方程来确定的。\n\n在同位网格上，压力和速度的离散耦合可能导致伪压力棋盘格现象，即压力在相邻单元之间以交替模式振荡。Rhie–Chow 插值是一种著名的格式，它通过修正面插值质量通量来防止这种解耦。你的任务是在纯数值背景下实现并比较三种投影变体：\n\n1. 一种不使用 Rhie–Chow 插值的朴素同位网格格式。在该格式中，面速度通过平均修正后的单元中心速度得到，离散压力方程通过对单元中心梯度求散度得到。\n\n2. 一种使用 Rhie–Chow 插值的格式。在该格式中，面法向压力梯度是作为跨面的差分计算的（而不是单元中心梯度的平均），并且面速度包含在面上计算的压力梯度贡献。\n\n3. 一种精确离散投影格式。在该格式中，压力通过求解标准的五点离散拉普拉斯算子得到，并且修正后的速度使用与该拉普拉斯算子一致的单元中心梯度来计算。\n\n所有三种变体都应在均匀同位网格上实现，其索引为 $(i,j)$，$i,j \\in \\{0,1,\\dots,N-1\\}$，单元中心坐标为 $x_i = \\frac{i+1/2}{N}$，$y_j = \\frac{j+1/2}{N}$。取密度 $\\rho = 1$（无量纲）和一个指定的时间步长 $\\Delta t$。对压力求解使用一个内部计算未知数集，其索引限制在 $i \\in \\{2,3,\\dots,N-3\\}$ 和 $j \\in \\{2,3,\\dots,N-3\\}$。在该内部集合的边界上对 $p$ 施加齐次 Dirichlet 边界条件。这一限制确保了朴素同位网格格式中出现的宽模板不会引用域外索引。\n\n设在单元中心处定义的构造中间速度场为\n$$\nu^\\*_x(i,j) = \\sin(2\\pi y_j) + \\varepsilon (-1)^i,\\quad\nu^\\*_y(i,j) = \\sin(2\\pi x_i) - \\varepsilon (-1)^j,\n$$\n其中 $\\varepsilon$ 是一个指定的振幅。对于每个变体，从 $u^\\*$ 的离散散度构造压力方程的离散右侧项，并在内部集合上求解压力 $p$。然后根据每个变体的面速度构造方法形成修正后的速度 $u^{n+1}$，并计算其离散散度。\n\n定义以下离散度量，你的程序必须为内部集合上的每个变体计算这些度量：\n\n- 离散散度范数 $\\|\\nabla \\cdot u^{n+1}\\|_2$，计算为使用适用于该格式的面速度的单元有限体积散度的均方根，表示为一个无量纲浮点数。\n\n- 压力棋盘格振幅 $\\alpha$，定义为求解出的压力与内部集合上交替模式 $v_{i,j}=(-1)^{i+j}$ 的绝对相关性，\n$$\n\\alpha = \\frac{\\left|\\sum_{i,j} p_{i,j}\\,(-1)^{i+j}\\right|}{\\|p\\|_2\\,\\|v\\|_2},\n$$\n其值在 $[0,1]$ 区间内，且无量纲。\n\n对于不含 Rhie-Chow 的朴素同位网格方案，通过对单元中心梯度求散度来构建压力算子，这会在 $x$ 和 $y$ 方向上产生一个宽模板离散算子。对于 Rhie–Chow 格式，在质量通量中使用基于面的压力梯度，并恢复标准的五点离散拉普拉斯算子。对于精确投影格式，使用五点离散拉普拉斯算子求解 $p$，并用单元中心梯度进行修正；其散度应使用与五点拉普拉斯算子一致的单元中心离散散度来测量。\n\n使用以下参数值的测试套件：\n\n- 测试用例 1（正常路径）：$N=16$，$\\Delta t = 10^{-3}$，$\\varepsilon = 0.2$。\n\n- 测试用例 2（边缘情况，小网格）：$N=8$，$\\Delta t = 10^{-3}$，$\\varepsilon = 0.3$。\n\n- 测试用例 3（加密）：$N=24$，$\\Delta t = 10^{-3}$，$\\varepsilon = 0.1$。\n\n对于每个测试用例，你的程序必须按顺序输出六个浮点数：\n$[\\|\\nabla \\cdot u\\|_2^{\\text{noRC}}, \\alpha^{\\text{noRC}}, \\|\\nabla \\cdot u\\|_2^{\\text{RC}}, \\alpha^{\\text{RC}}, \\|\\nabla \\cdot u\\|_2^{\\text{exact}}, \\alpha^{\\text{exact}}]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（所有测试用例的结果按顺序连接）。在这个无量纲化的问题中没有物理单位；所有输出都是无量纲的浮点数。",
            "solution": "用户希望在同位网格上比较 Chorin 投影法用于不可压缩流的三种变体。目标是分析它们在抑制伪压力振荡（一种称为棋盘格现象）方面的有效性。这将通过从一个构造的中间速度场求解压力场，然后计算两个关键指标来完成：压力棋盘格振幅和修正后速度场的散度范数。\n\n### 问题建模\n\n问题设置在一个二维单位正方形域上，该域由一个 $N \\times N$ 单元的均匀同位网格离散化。单元中心位于 $(x_i, y_j) = (\\frac{i+1/2}{N}, \\frac{j+1/2}{N})$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$。网格间距为 $h=1/N$。我们给定在单元中心的构造中间速度场 $u^*$：\n$$\nu^\\*_x(i,j) = \\sin(2\\pi y_j) + \\varepsilon (-1)^i\n$$\n$$\nu^\\*_y(i,j) = \\sin(2\\pi x_i) - \\varepsilon (-1)^j\n$$\n振幅为 $\\varepsilon$ 的项引入了一个高频分量，旨在激发棋盘格不稳定性。\n\n投影法的核心是找到一个压力场 $p$，使得修正后的速度 $u^{n+1}$ 是无散度的。这导致了一个形式为 $L p = f$ 的压力泊松方程，其中 $L$ 是一个离散拉普拉斯算子，$f$ 与 $u^*$ 的散度有关。压力 $p$ 在由索引 $i, j \\in \\{2, 3, \\dots, N-3\\}$ 定义的内部子网格上求解，并在该子网格的边界上施加齐次 Dirichlet 边界条件 ($p=0$)。对于所有格式，我们假设密度 $\\rho=1$。\n\n### 离散算子\n\n我们定义几个离散算子：\n1.  **单元中心散度 ($\\nabla_c \\cdot$)：** 应用于单元中心矢量场的标准二阶中心差分。\n    $$\n    (\\nabla_c \\cdot \\mathbf{u})_{i,j} = \\frac{u_{x,i+1,j} - u_{x,i-1,j}}{2h} + \\frac{u_{y,i,j+1} - u_{y,i,j-1}}{2h}\n    $$\n2.  **单元中心梯度 ($\\nabla_c$)：** 标准二阶中心差分。\n    $$\n    (\\nabla_c p)_{i,j} = \\left( \\frac{p_{i+1,j} - p_{i-1,j}}{2h}, \\frac{p_{i,j+1} - p_{i,j-1}}{2h} \\right)\n    $$\n3.  **基于面的散度 ($\\nabla_f \\cdot$)：** 使用单元面（例如，在 $i\\pm1/2, j$ 和 $i, j\\pm1/2$ 处）上的速度的标准有限体积散度。\n    $$\n    (\\nabla_f \\cdot \\mathbf{u})_{i,j} = \\frac{u_{x,i+1/2,j} - u_{x,i-1/2,j}}{h} + \\frac{u_{y,i,j+1/2} - u_{y,i,j-1/2}}{h}\n    $$\n4.  **基于面的梯度 ($\\nabla_f$)：** 在单元面上计算的梯度。\n    $$\n    (\\nabla_{f,x} p)_{i+1/2,j} = \\frac{p_{i+1,j} - p_{i,j}}{h}\n    $$\n5.  **标准5点拉普拉斯算子 ($L_{5pt}$):** 由 $\\nabla_f \\cdot \\nabla_f p$ 产生。\n    $$\n    (L_{5pt} p)_{i,j} = \\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4p_{i,j}}{h^2}\n    $$\n6.  **宽模板拉普拉斯算子 ($L_{wide}$):** 由 $\\nabla_c \\cdot \\nabla_c p$ 产生。\n    $$\n    (L_{wide} p)_{i,j} = \\frac{p_{i+2,j} + p_{i-2,j} + p_{i,j+2} + p_{i,j-2} - 4p_{i,j}}{4h^2}\n    $$\n所有变体中压力方程的右侧项都源于 $u^*$ 的散度。对所有格式而言，一个一致的选择是单元中心散度 $(\\nabla_c \\cdot u^*)$。\n\n### 三种投影变体\n\n**1. 朴素同位网格格式 (noRC)**\n该格式使用不一致的算子，这已知会导致压力-速度解耦。单元中心的修正速度为 $u^{n+1} = u^* - \\Delta t \\nabla_c p$。不可压缩约束施加在面速度上，这些面速度是单元中心速度的简单平均。这导致了包含宽模板拉普拉斯算子的压力方程：\n$$\nL_{wide} p = \\frac{1}{\\Delta t} (\\nabla_c \\cdot u^*)\n$$\n在求解出 $p$ 之后，修正后的速度 $u^{n+1}$ 在单元中心计算。用于度量的散度是使用有限体积方法 ($\\nabla_f \\cdot$) 计算的，其中面速度通过平均修正后的单元中心速度获得。预计该格式会表现出强烈的压力棋盘格现象。\n\n**2. Rhie-Chow 插值格式 (RC)**\n该格式为面速度引入了一种特殊的插值，以修正解耦问题。面法向速度修正是与面法向压力梯度 $\\nabla_f p$ 成正比的。\n$$\nu^{n+1}_{x,i+1/2,j} = \\bar{u}^*_{x,i+1/2,j} - \\Delta t (\\nabla_{f,x} p)_{i+1/2,j}\n$$\n其中 $\\bar{u}^*$ 表示简单平均。施加 $\\nabla_f \\cdot u^{n+1} = 0$ 约束会得到一个带有标准5点拉普拉斯算子的压力方程：\n$$\nL_{5pt} p = \\frac{1}{\\Delta t} (\\nabla_c \\cdot u^*)\n$$\n算子 $L_{5pt}$ 耦合了相邻的压力节点，从而有效地抑制了高频振荡。求解出 $p$ 后，修正后的速度直接在面上计算，散度范数度量基于这些速度。该格式应产生非常小的棋盘格振幅 $\\alpha$ 和接近于零的散度范数。\n\n**3. “精确”离散投影格式 (exact)**\n此变体旨在强调使用一致离散算子的重要性。它求解与 Rhie-Chow 格式相同的压力方程，使用稳定的5点拉普拉斯算子：\n$$\nL_{5pt} p = \\frac{1}{\\Delta t} (\\nabla_c \\cdot u^*)\n$$\n因此，得到的压力场 $p_{exact}$ 与 $p_{RC}$ 相同，所以 $\\alpha_{exact} = \\alpha_{RC}$。然而，速度修正随后使用单元中心梯度执行，这与所使用的拉普拉斯算子不一致：\n$$\nu^{n+1} = u^* - \\Delta t \\nabla_c p\n$$\n然后使用单元中心散度算子 $\\nabla_c \\cdot u^{n+1}$ 计算散度度量。由于算子不一致 ($L_{5pt} \\neq \\nabla_c \\cdot \\nabla_c$)，得到的散度将不为零。我们预期会得到一个小的 $\\alpha$ 但一个不可忽略的散度范数。\n\n### 实现策略\n对于每个测试用例：\n1.  初始化网格属性 ($N, h$) 和中间速度场 $u^*$。\n2.  定义大小为 $M \\times M$ 的内部计算网格，其中 $M = N-4$。\n3.  在内部网格上计算压力方程的右侧项 $f = \\frac{1}{\\Delta t} (\\nabla_c \\cdot u^*)$。\n4.  对于每个变体：\n    a.  为离散拉普拉斯算子（$L_{wide}$ 或 $L_{5pt}$）构建相应的稀疏矩阵，并包含齐次 Dirichlet 边界条件。\n    b.  在内部网格上求解线性系统 $L p = f$ 以获得压力场 $p$。\n    c.  用零填充内部解，以获得一个完整的 $N \\times N$ 压力场。\n    d.  根据变体的定义（单元中心或面中心）计算修正后的速度场 $u^{n+1}$。\n    e.  使用适当的离散算子计算 $u^{n+1}$ 的散度。\n    f.  在内部网格上计算两个所需的度量：棋盘格振幅 $\\alpha$ 和散度的均方根范数 $\\|\\nabla \\cdot u^{n+1}\\|_2$。\n5.  收集并返回六个得到的浮点数值。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse\nimport scipy.sparse.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, 1e-3, 0.2),  # Test case 1\n        (8, 1e-3, 0.3),   # Test case 2\n        (24, 1e-3, 0.1),  # Test case 3\n    ]\n\n    results = []\n    for N, dt, epsilon in test_cases:\n        case_results = run_single_case(N, dt, epsilon)\n        results.extend(case_results)\n\n    # Format output as a comma-separated list of floats inside brackets\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\ndef run_single_case(N, dt, epsilon):\n    \"\"\"\n    Implements the three projection variants for a single test case.\n    \"\"\"\n    h = 1.0 / N\n    if N  5:  # Interior grid must have positive size\n        return [np.nan] * 6\n    M = N - 4\n    \n    int_slice = np.s_[2:N-2, 2:N-2]\n    \n    # Setup grid and intermediate velocity\n    coords = (np.arange(N) + 0.5) * h\n    x, y = np.meshgrid(coords, coords, indexing='ij')\n\n    u_star_x = np.sin(2 * np.pi * y) + epsilon * ((-1) ** np.arange(N))[:, np.newaxis]\n    u_star_y = np.sin(2 * np.pi * x) - epsilon * ((-1) ** np.arange(N))[np.newaxis, :]\n\n    # Common Part: RHS from divergence of u*\n    div_u_star_full = (u_star_x[2:, 1:-1] - u_star_x[:-2, 1:-1]) / (2 * h) + \\\n                      (u_star_y[1:-1, 2:] - u_star_y[1:-1, :-2]) / (2 * h)\n    div_u_star_int = div_u_star_full[1:N-3, 1:N-3] # Extract interior corresponding to [2:N-2] on N-grid\n\n    # --- Variant 1: Naive (noRC) ---\n    A_noRC = scipy.sparse.lil_matrix((M*M, M*M))\n    for i in range(M): # M-grid index\n        for j in range(M):\n            k = i * M + j\n            A_noRC[k, k] = -4.0\n            if i >= 2:   A_noRC[k, k - 2 * M] = 1.0\n            if i = M-3: A_noRC[k, k + 2 * M] = 1.0\n            if j >= 2:   A_noRC[k, k - 2] = 1.0\n            if j = M-3: A_noRC[k, k + 2] = 1.0\n    \n    b_noRC = -(4 * h**2 / dt) * div_u_star_int.flatten()\n    p_vec_noRC = scipy.sparse.linalg.spsolve(A_noRC.tocsr(), b_noRC)\n    p_int_noRC = p_vec_noRC.reshape((M, M))\n    \n    p_full_noRC = np.zeros((N, N))\n    p_full_noRC[int_slice] = p_int_noRC\n    \n    grad_p_x_c = (p_full_noRC[2:, 1:-1] - p_full_noRC[:-2, 1:-1]) / (2 * h)\n    grad_p_y_c = (p_full_noRC[1:-1, 2:] - p_full_noRC[1:-1, :-2]) / (2 * h)\n    u_np1_x = u_star_x.copy(); u_np1_y = u_star_y.copy()\n    u_np1_x[1:-1, 1:-1] -= dt * grad_p_x_c\n    u_np1_y[1:-1, 1:-1] -= dt * grad_p_y_c\n    \n    u_face_x = 0.5 * (u_np1_x[:-1, :] + u_np1_x[1:, :])\n    u_face_y = 0.5 * (u_np1_y[:, :-1] + u_np1_y[:, 1:])\n    \n    div_u_np1_full = (u_face_x[1:, 1:-1] - u_face_x[:-1, 1:-1]) / h + \\\n                     (u_face_y[1:-1, 1:] - u_face_y[1:-1, :-1]) / h\n    div_u_np1_int_noRC = div_u_np1_full[1:N-3, 1:N-3]\n\n    div_norm_noRC, alpha_noRC = compute_metrics(p_int_noRC, div_u_np1_int_noRC)\n\n    # --- Variant 2: Rhie-Chow (RC) ---\n    A_RC = scipy.sparse.lil_matrix((M*M, M*M))\n    for i in range(M):\n        for j in range(M):\n            k = i * M + j\n            A_RC[k, k] = -4.0\n            if i > 0:   A_RC[k, k - M] = 1.0\n            if i  M-1: A_RC[k, k + M] = 1.0\n            if j > 0:   A_RC[k, k - 1] = 1.0\n            if j  M-1: A_RC[k, k + 1] = 1.0\n\n    b_RC = (h**2 / dt) * div_u_star_int.flatten()\n    p_vec_RC = scipy.sparse.linalg.spsolve(A_RC.tocsr(), b_RC)\n    p_int_RC = p_vec_RC.reshape((M, M))\n    \n    p_full_RC = np.zeros((N, N))\n    p_full_RC[int_slice] = p_int_RC\n\n    u_star_face_x = 0.5 * (u_star_x[:-1, :] + u_star_x[1:, :])\n    u_star_face_y = 0.5 * (u_star_y[:, :-1] + u_star_y[:, 1:])\n    grad_p_x_f = (p_full_RC[1:, :] - p_full_RC[:-1, :]) / h\n    grad_p_y_f = (p_full_RC[:, 1:] - p_full_RC[:, :-1]) / h\n    u_np1_face_x = u_star_face_x - dt * grad_p_x_f\n    u_np1_face_y = u_star_face_y - dt * grad_p_y_f\n\n    div_u_np1_full_rc = (u_np1_face_x[1:, 1:-1] - u_np1_face_x[:-1, 1:-1]) / h + \\\n                        (u_np1_face_y[1:-1, 1:] - u_np1_face_y[1:-1, :-1]) / h\n    div_u_np1_int_RC = div_u_np1_full_rc[1:N-3, 1:N-3]\n\n    div_norm_RC, alpha_RC = compute_metrics(p_int_RC, div_u_np1_int_RC)\n\n    # --- Variant 3: \"Exact\" Discrete Projection ---\n    p_int_exact = p_int_RC\n    p_full_exact = p_full_RC\n    alpha_exact = alpha_RC\n\n    grad_p_x_c_ex = (p_full_exact[2:, 1:-1] - p_full_exact[:-2, 1:-1]) / (2 * h)\n    grad_p_y_c_ex = (p_full_exact[1:-1, 2:] - p_full_exact[1:-1, :-2]) / (2 * h)\n    \n    u_np1_x_ex = u_star_x.copy(); u_np1_y_ex = u_star_y.copy()\n    u_np1_x_ex[1:-1, 1:-1] -= dt * grad_p_x_c_ex\n    u_np1_y_ex[1:-1, 1:-1] -= dt * grad_p_y_c_ex\n\n    div_u_np1_full_ex = (u_np1_x_ex[2:, 1:-1] - u_np1_x_ex[:-2, 1:-1]) / (2 * h) + \\\n                        (u_np1_y_ex[1:-1, 2:] - u_np1_y_ex[1:-1, :-2]) / (2 * h)\n    div_u_np1_int_exact = div_u_np1_full_ex[1:N-3, 1:N-3]\n    \n    div_norm_exact, _ = compute_metrics(p_int_exact, div_u_np1_int_exact)\n    \n    return [div_norm_noRC, alpha_noRC, div_norm_RC, alpha_RC, div_norm_exact, alpha_exact]\n\ndef compute_metrics(p_int, div_u_np1_int):\n    \"\"\"\n    Computes the pressure checkerboard amplitude and divergence norm.\n    \"\"\"\n    M = p_int.shape[0]\n    i_m, j_m = np.meshgrid(np.arange(M), np.arange(M), indexing='ij')\n    v = (-1)**(i_m + 2 + j_m + 2) # Use original grid indices for checkerboard pattern\n\n    norm_p = np.linalg.norm(p_int)\n    norm_v = np.linalg.norm(v)\n\n    if norm_p  1e-15:\n        alpha = 0.0\n    else:\n        alpha = np.abs(np.sum(p_int * v)) / (norm_p * norm_v)\n\n    div_norm = np.linalg.norm(div_u_np1_int) / M if M > 0 else 0.0\n    \n    return div_norm, alpha\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}