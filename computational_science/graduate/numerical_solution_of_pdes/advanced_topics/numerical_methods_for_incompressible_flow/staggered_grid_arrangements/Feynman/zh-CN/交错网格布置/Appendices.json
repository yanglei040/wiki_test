{
    "hands_on_practices": [
        {
            "introduction": "从理论到实践，理解交错网格最根本的动机是至关重要的，那就是为了抑制非物理性的压力振荡（即“棋盘格”模式）。本练习将通过数值方式直接展示一个朴素的同位网格（colocated grid）如何在其动量方程中“无视”高频压力模式，从而导致伪解，而经典的标记-单元（MAC）交错网格则能自然地耦合压力与速度，有效抑制这些伪影。通过这个练习，您将亲身体验到交错网格在保持数值稳定性方面的内在优势。",
            "id": "3365597",
            "problem": "考虑在每个方向上长度为 $L=1$ 的二维周期性域上的定常、不可压缩 Stokes 方程，其空间坐标为 $(x,y)$，速度场为 $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$：\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n其中 $p(x,y)$ 是压力，$\\nu$ 是运动粘度，$\\mathbf{f}(x,y)$ 是给定的体积力。在分数步长投影法中，压力场 $p$ 是通过求解以下与实施离散不可压缩性相关的压力泊松方程来恢复的：\n$$\n\\nabla^2 p = s,\n$$\n其中 $s$ 是由中间速度场的散度构建的离散源项。在间距为 $\\Delta x = \\Delta y$ 的均匀笛卡尔网格上，不同的网格排列方式会导致不同的离散梯度和散度算子。具体而言：\n- 同位（以单元为中心）排列将 $u$、$v$ 和 $p$ 全部置于单元中心。一种常见的朴素中心差分实现使用每个坐标方向上最近的邻点来计算中心的离散压力梯度：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i,j+1} - p_{i,j-1}}{2 \\Delta x}.\n$$\n- Marker-And-Cell (MAC) 交错排列将 $u$ 置于 $(i+\\tfrac{1}{2}, j)$ 处的垂直面上，$v$ 置于 $(i, j+\\tfrac{1}{2})$ 处的水平面上，$p$ 置于 $(i,j)$ 处的单元中心。离散压力梯度自然地出现在面上：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}, \\quad\n\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}} = \\frac{p_{i,j+1} - p_{i,j}}{\\Delta x}.\n$$\n\n众所周知，同位中心差分会产生一种伪压力模式，通常称为棋盘格模式，它在 $N_x \\times N_y$ 均匀周期性网格上定义为\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j}, \\quad i = 0,1,\\dots,N_x-1, \\quad j = 0,1,\\dots,N_y-1,\n$$\n并且对应于最高可分辨空间频率（奈奎斯特模式）。这种模式可由特定的离散强迫项激发，并且在同位网格上，当采用从中心到面的朴素插值时，它会与动量方程解耦，导致 $p$ 中出现不驱动动量的非物理振荡。相反，MAC 交错排列抑制了这种解耦，因为以面为中心的离散梯度直接采样相邻单元中心的压力，而棋盘格差分在面上不为零。\n\n你的任务是：\n1. 使用一个制造源 $s_{i,j} = (-1)^{i+j}$，在具有周期性边界条件的离散压力泊松方程中激发棋盘格模式，该方程通过标准五点拉普拉斯算子进行离散化。间距为 $\\Delta x$ 的均匀网格上五点拉普拉斯算子的离散傅里叶符号是\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\n适用于离散波数 $k_x = \\frac{2\\pi m}{L}$，$k_y = \\frac{2\\pi n}{L}$，其中 $m = 0,1,\\dots,N_x-1$ 且 $n = 0,1,\\dots,N_y-1$。当 $N_x$ 和 $N_y$ 为偶数时，棋盘格模式对应于 $(m,n) = (N_x/2, N_y/2)$，得出 $\\cos(\\pi) = -1$，因此\n$$\n\\lambda_{\\text{chk}} = -\\frac{4}{\\Delta x^2} - \\frac{4}{\\Delta x^2} = -\\frac{8}{\\Delta x^2}.\n$$\n由此，与棋盘格强迫项相关的压力振幅的缩放关系为\n$$\nA_p(\\Delta x) = \\frac{1}{|\\lambda_{\\text{chk}}|} = \\frac{\\Delta x^2}{8}.\n$$\n2. 对于一系列均匀网格，在傅里叶域中使用上述离散拉普拉斯符号数值求解离散周期性泊松方程 $\\nabla^2 p = s$，并通过将计算出的 $p$ 投影到 $p^{\\text{chk}}$ 上来提取棋盘格分量的数值振幅 $A_p(\\Delta x)$。\n3. 计算并比较在以下两种情况下，将进入动量方程的以面为中心的压力梯度的均方根（RMS）大小：\n   - 一种同位朴素面梯度，通过将相邻单元的中心梯度平均到面来获得：\n   $$\n   \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1,j}^{\\text{col}}\\right], \\quad\n   \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{col-face}} = \\frac{1}{2}\\left[\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}} + \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+1}^{\\text{col}}\\right].\n   $$\n   - 如上定义的 MAC 面梯度。RMS 大小定义为\n   $$\n   G_{\\text{RMS}} = \\sqrt{\\frac{1}{N_f}\\sum_{f} g_f^2},\n   $$\n   其中 $g_f$ 遍历两个方向上的所有面梯度分量，$N_f$ 是面的总数。\n4. 数值上证明：\n   - 同位朴素面梯度对棋盘格分量是“盲目的”，因此对于制造的强迫项，其 RMS 大小在数值上为零，这解释了解耦现象。\n   - MAC 面梯度与棋盘格模式耦合，并且对于制造的强迫项，其 RMS 大小按 $\\mathcal{O}(\\Delta x)$ 缩放，因为 $A_p(\\Delta x) \\sim \\Delta x^2$ 且面梯度按 $A_p(\\Delta x)/\\Delta x$ 缩放。\n\n实现一个程序，该程序：\n- 在长度为 $L=1$ 的周期性域上构建制造源 $s_{i,j} = (-1)^{i+j}$。\n- 在傅里叶空间中使用离散拉普拉斯符号求解离散泊松方程以获得 $p_{i,j}$。\n- 通过投影到 $(-1)^{i+j}$ 上来计算数值棋盘格振幅 $A_p(\\Delta x)$。\n- 为得到的 $p_{i,j}$ 计算 $G_{\\text{RMS}}^{\\text{col-face}}$ 和 $G_{\\text{RMS}}^{\\text{MAC}}$。\n- 报告每个网格的元组 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$。\n\n测试套件：\n- 对以下情况使用 $N_x=N_y$ 和 $L=1$ 的正方形网格：\n  1. $N_x=N_y=8$（粗网格，$\\Delta x = 1/8$）。\n  2. $N_x=N_y=16$（中等网格，$\\Delta x = 1/16$）。\n  3. $N_x=N_y=32$（细网格，$\\Delta x = 1/32$）。\n  4. $N_x=N_y=64$（很细的网格，$\\Delta x = 1/64$）。\n所有报告的量均为无量纲。您的程序应生成单行输出，其中包含一个由逗号分隔的四个方括号元组列表的结果，每个元组按 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$ 的顺序排列，与测试用例的顺序相同，例如：\n\"[(a1,b1,c1),(a2,b2,c2),(a3,b3,c3),(a4,b4,c4)]\"。",
            "solution": "我们从定常不可压缩 Stokes 方程开始\n$$\n-\\nabla p + \\nu \\nabla^2 \\mathbf{u} = \\mathbf{f}, \\quad \\nabla \\cdot \\mathbf{u} = 0,\n$$\n在分数步长法下，这导致通过压力泊松方程来强制执行离散不可压缩性\n$$\n\\nabla^2 p = s,\n$$\n其中源项 $s$ 由中间速度的散度得到。在均匀周期性网格上，在离散傅里叶空间中求解此泊松方程是很自然的，并且它揭示了某些空间模式如何传播到压力中。我们关注棋盘格（奈奎斯特）模式，\n$$\np_{i,j}^{\\text{chk}} = (-1)^{i+j},\n$$\n该模式在相邻单元中心之间符号交替。\n\n对于间距为 $\\Delta x$ 且具有周期性边界条件的均匀网格，标准的五点离散拉普拉斯算子具有傅里叶符号\n$$\n\\lambda(k_x,k_y) = \\frac{2}{\\Delta x^2}\\left(\\cos(k_x \\Delta x)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos(k_y \\Delta x)-1\\right),\n$$\n其离散波数为 $k_x = \\frac{2\\pi m}{L}$ 和 $k_y = \\frac{2\\pi n}{L}$，$m=0,\\dots,N_x-1$，$n=0,\\dots,N_y-1$，且 $L=1$。对于棋盘格模式，$(m,n)=(N_x/2, N_y/2)$ 且 $k_x \\Delta x = \\pi$，$k_y \\Delta x = \\pi$，得到\n$$\n\\lambda_{\\text{chk}} = \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos \\pi - 1\\right) = \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) + \\frac{2}{\\Delta x^2}\\left(-1 - 1\\right) = -\\frac{8}{\\Delta x^2}.\n$$\n用 $s_{i,j}=(-1)^{i+j}$ 强迫泊松方程意味着右侧仅包含此模式。因此解与该模式成正比：\n$$\np_{i,j} = A_p(\\Delta x)\\, (-1)^{i+j}.\n$$\n代入傅里叶空间中的离散泊松方程可得\n$$\n\\lambda_{\\text{chk}} A_p(\\Delta x) = 1 \\quad \\Rightarrow \\quad A_p(\\Delta x) = -\\frac{1}{\\lambda_{\\text{chk}}} = \\frac{\\Delta x^2}{8}.\n$$\n因此，计算出的压力中棋盘格分量的振幅按 $\\Delta x^2$ 缩放。\n\n同位排列与 Marker-And-Cell (MAC) 交错排列之间的区别在于压力梯度在动量方程中的表示方式：\n- 在同位（以单元为中心）格式中，一种常见的朴素实现使用中心差分来估计单元中心的 $\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}}$ 和 $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}$。对于棋盘格压力 $p_{i,j} = A_p(\\Delta x)\\,(-1)^{i+j}$，\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j}^{\\text{col}} = \\frac{p_{i+1,j} - p_{i-1,j}}{2 \\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i-1+j}\\right]}{2\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}\\left[-1 - (-1)\\right]}{2\\Delta x} = 0,\n$$\n类似的计算表明 $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j}^{\\text{col}}=0$。如果接着通过平均相邻中心梯度来朴素地构造面梯度，则驱动动量方程的最终面压力梯度仍然为零。这证明了解耦：在同位朴素格式中，棋盘格压力不会产生以面为中心的压力。\n- 在 MAC 交错排列中，以面为中心的离散梯度直接取相邻中心压力的差值：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+\\frac{1}{2},j}^{\\text{MAC}} = \\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\left[(-1)^{i+1+j} - (-1)^{i+j}\\right]}{\\Delta x}\n= \\frac{A_p(\\Delta x)\\,(-1)^{i+j}(-1 - 1)}{\\Delta x}\n= -\\frac{2\\,A_p(\\Delta x)}{\\Delta x}\\,(-1)^{i+j}.\n$$\n对于 $\\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j+\\frac{1}{2}}^{\\text{MAC}}$ 也存在类似的表达式。因此，MAC 面梯度与棋盘格模式强耦合，并驱动动量修正以抑制此类振荡。对于制造的强迫项，MAC 面梯度的大小按 $\\frac{A_p(\\Delta x)}{\\Delta x} \\sim \\frac{\\Delta x^2}{\\Delta x} = \\mathcal{O}(\\Delta x)$ 缩放。\n\n程序的算法设计：\n1. 对于每个具有 $N_x=N_y$ 和 $\\Delta x = 1/N_x$ 的测试网格，构建制造源 $s_{i,j} = (-1)^{i+j}$。\n2. 计算 $s$ 的二维离散傅里叶变换以获得 $\\hat{s}(m,n)$。\n3. 对于每个傅里叶模式 $(m,n)$，使用以下公式计算离散拉普拉斯符号 $\\lambda(m,n)$\n$$\n\\lambda(m,n) = \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi m}{N_x}\\right)-1\\right) + \\frac{2}{\\Delta x^2}\\left(\\cos\\left(\\frac{2\\pi n}{N_y}\\right)-1\\right).\n$$\n4. 对所有满足 $\\lambda(m,n) \\neq 0$ 的 $(m,n)$，计算 $\\hat{p}(m,n) = \\hat{s}(m,n) / \\lambda(m,n)$。由于交替模式，零模式 $(m,n)=(0,0)$ 在 $\\hat{s}$ 中不存在，因此不会发生除以零的情况。\n5. 进行逆变换以在物理空间中获得 $p_{i,j}$。\n6. 将 $p$ 投影到棋盘格模式上以提取振幅，\n$$\nA_p(\\Delta x) = \\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1} p_{i,j}(-1)^{i+j}.\n$$\n7. 使用中心差分计算同位中心梯度，然后通过将相邻中心梯度平均到面来获得同位面梯度。计算所有面上的均方根大小：\n$$\nG_{\\text{RMS}}^{\\text{col-face}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{col-face}}\\right)^2}.\n$$\n8. 从相邻中心压力计算 MAC 面梯度及其对应的均方根大小：\n$$\nG_{\\text{RMS}}^{\\text{MAC}} = \\sqrt{\\frac{1}{N_f}\\sum_{f}\\left(g_{f}^{\\text{MAC}}\\right)^2}.\n$$\n9. 对于测试套件中的每个网格，输出 $(A_p(\\Delta x), G_{\\text{RMS}}^{\\text{col-face}}, G_{\\text{RMS}}^{\\text{MAC}})$，并按规定汇总到单行中。\n\n预期行为：\n- 数值 $A_p(\\Delta x)$ 应与 $\\Delta x^2/8$ 紧密缩放（在浮点和离散变换归一化的精度范围内）。\n- $G_{\\text{RMS}}^{\\text{col-face}}$ 在数值上应为零（达到机器精度），证明同位朴素梯度对棋盘格压力是“盲目的”。\n- 对于此制造强迫项，$G_{\\text{RMS}}^{\\text{MAC}}$ 应与 $\\Delta x$ 线性缩放，因为面梯度大小的行为类似于 $2 A_p(\\Delta x)/\\Delta x$。\n\n这直接展示了 Marker-And-Cell (MAC) 交错网格抑制棋盘格压力模式的机制：通过将速度置于面上，离散压力梯度被评估为相邻压力的差值，该差值对于交替模式不为零，从而将伪模式耦合到动量中并被阻尼。相反，用于中心压力梯度的同位朴素中心差分会消除交替分量，从而允许伪压力模式在不影响速度场的情况下持续存在。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef discrete_laplacian_symbol(nx, ny, dx):\n    \"\"\"\n    Build the discrete Laplacian symbol lambda(m,n) for a periodic grid\n    using the five-point stencil central differences on a uniform grid.\n    \"\"\"\n    # Wavenumber indices m, n\n    m = np.arange(nx)\n    n = np.arange(ny)\n    # Cosine terms for each axis\n    cos_m = np.cos(2.0 * np.pi * m / nx)\n    cos_n = np.cos(2.0 * np.pi * n / ny)\n    # Broadcast to 2D grid of (m,n)\n    lam = (2.0 / dx**2) * (cos_m[:, None] - 1.0) + (2.0 / dx**2) * (cos_n[None, :] - 1.0)\n    return lam\n\ndef solve_poisson_checkerboard(nx, ny, L=1.0):\n    \"\"\"\n    Solve the discrete periodic Poisson equation for s_{i,j} = (-1)^{i+j}\n    using the discrete Laplacian symbol in Fourier space.\n\n    Returns:\n        p: computed pressure field (nx x ny)\n        Ap: numerical checkerboard amplitude via projection onto (-1)^{i+j}\n    \"\"\"\n    dx = L / nx\n    # Manufactured source s = (-1)^{i+j}\n    i = np.arange(nx)[:, None]\n    j = np.arange(ny)[None, :]\n    s = ((-1.0) ** (i + j)).astype(np.float64)\n\n    # FFT of source\n    s_hat = np.fft.fft2(s)\n\n    # Discrete Laplacian symbol\n    lam = discrete_laplacian_symbol(nx, ny, dx)\n\n    # Avoid division by zero: source has zero mean, so lam[0,0] won't be used\n    # Construct p_hat = s_hat / lam\n    # Use where to handle potential zeros robustly (though s_hat[0,0]==0)\n    p_hat = np.zeros_like(s_hat, dtype=np.complex128)\n    mask = lam != 0.0\n    p_hat[mask] = s_hat[mask] / lam[mask]\n\n    # Inverse FFT to get p\n    p = np.real(np.fft.ifft2(p_hat))\n\n    # Compute checkerboard amplitude Ap = mean(p * (-1)^{i+j})\n    pattern = ((-1.0) ** (i + j)).astype(np.float64)\n    Ap = np.sum(p * pattern) / (nx * ny)\n\n    return p, Ap, dx\n\ndef colocated_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute colocated center gradients via central differences and then\n    naive face gradients by averaging adjacent center gradients.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # Periodic shifts\n    p_ip = np.roll(p, -1, axis=0)\n    p_im = np.roll(p,  1, axis=0)\n    p_jp = np.roll(p, -1, axis=1)\n    p_jm = np.roll(p,  1, axis=1)\n\n    # Center gradients (central difference)\n    gx_c = (p_ip - p_im) / (2.0 * dx)\n    gy_c = (p_jp - p_jm) / (2.0 * dx)  # dx == dy\n\n    # Face gradients: average adjacent center gradients to faces\n    # x-faces at (i+1/2, j): average gx_c[i,j] and gx_c[i+1,j]\n    gx_face = 0.5 * (gx_c + np.roll(gx_c, -1, axis=0))\n    # y-faces at (i, j+1/2): average gy_c[i,j] and gy_c[i,j+1]\n    gy_face = 0.5 * (gy_c + np.roll(gy_c, -1, axis=1))\n\n    # RMS over all faces (both directions)\n    # Number of faces: 2 * nx * ny\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef mac_face_gradient_rms(p, dx):\n    \"\"\"\n    Compute MAC face gradients directly from adjacent center pressures.\n    Return RMS magnitude over all faces.\n    \"\"\"\n    nx, ny = p.shape\n\n    # x-face gradient: (p_{i+1,j} - p_{i,j}) / dx\n    p_ip = np.roll(p, -1, axis=0)\n    gx_face = (p_ip - p) / dx\n\n    # y-face gradient: (p_{i,j+1} - p_{i,j}) / dx\n    p_jp = np.roll(p, -1, axis=1)\n    gy_face = (p_jp - p) / dx\n\n    rms = np.sqrt((np.sum(gx_face**2) + np.sum(gy_face**2)) / (2.0 * nx * ny))\n    return rms\n\ndef run_test_case(nx):\n    ny = nx\n    p, Ap, dx = solve_poisson_checkerboard(nx, ny, L=1.0)\n    rms_col = colocated_face_gradient_rms(p, dx)\n    rms_mac = mac_face_gradient_rms(p, dx)\n    return (Ap, rms_col, rms_mac)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 32, 64]\n\n    results = []\n    for nx in test_cases:\n        Ap, rms_col, rms_mac = run_test_case(nx)\n        # Format each tuple with reasonable precision\n        results.append(f\"({Ap:.10f},{rms_col:.10e},{rms_mac:.10e})\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在建立了交错网格的稳定性优势之后，我们可以进一步探究其精度特性。本实践揭示了 MAC 格式一个出色的性质：它能够精确地表示某些物理平衡态。通过编程验证在刚体旋转流场中，离散压力梯度能够精确抵消离心力，您将深入理解该离散格式的“模拟”（mimetic）特性，即离散算子能够正确地模拟其连续对应物的性质。",
            "id": "3365551",
            "problem": "构建一个程序，在标记-单元（MAC）交错网格布局上验证对于刚体旋转速度场，离散压力梯度是否能精确抵消离心力。物理背景是一个密度恒定的流体，以角速度矢量 $\\boldsymbol{\\Omega}$ 进行稳态、无粘性的刚体旋转，其速度由 $\\mathbf{u} = \\boldsymbol{\\Omega} \\times \\mathbf{r}$ 给出，其中 $\\mathbf{r}$ 是位置矢量。该验证必须在旋转参考系中进行，其中离心加速度被建模为一种体积力，对于恒定密度 $\\rho$，静水平衡为 $-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$，其中 $\\mathbf{a}_{\\mathrm{cf}}$ 是离心加速度。使用经过充分检验的公式 $\\mathbf{a}_{\\mathrm{cf}} = -\\boldsymbol{\\Omega}\\times(\\boldsymbol{\\Omega}\\times \\mathbf{r})$。所有量都必须使用国际单位制（SI）处理：位置单位为米，时间单位为秒，质量单位为千克，角速度单位为弧度/秒。最终的残差必须以 $\\mathrm{N/m^3}$ 表示。\n\n在嵌入平面 $z = z_0$ 的均匀、正交、二维网格上使用以下 MAC 网格定义：\n- 压力 $p$ 存储在单元中心，坐标为 $(x_{i+\\frac{1}{2}}, y_{j+\\frac{1}{2}})$，其中 $x_{i+\\frac{1}{2}} = x_{\\min} + (i+\\frac{1}{2})\\Delta x$ 和 $y_{j+\\frac{1}{2}} = y_{\\min} + (j+\\frac{1}{2})\\Delta y$，整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。\n- $x$方向动量（$u$速度位置）位于 $x$面的中心，坐标为 $(x_{i+1}, y_{j+\\frac{1}{2}})$，其中 $x_{i+1} = x_{\\min} + (i+1)\\Delta x$，整数 $i \\in \\{0,\\dots,N_x-2\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$。作用于此速度位置的 $x$方向动量方程中，MAC 离散压力梯度项定义为 $-\\partial p/\\partial x \\approx -\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}$。\n- $y$方向动量（$v$速度位置）位于 $y$面的中心，坐标为 $(x_{i+\\frac{1}{2}}, y_{j+1})$，其中 $y_{j+1} = y_{\\min} + (j+1)\\Delta y$，整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-2\\}$。作用于此速度位置的 $y$方向动量方程中，MAC 离散压力梯度项定义为 $-\\partial p/\\partial y \\approx -\\frac{p_{i,j+1} - p_{i,j}}{\\Delta y}$。\n\n您必须：\n- 从第一性原理出发，推导出一个流体压力场 $p(\\mathbf{r})$，使得对于恒定密度 $\\rho$ 的刚体旋转，连续静水平衡 $-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$ 得以满足。\n- 使用该 $p(\\mathbf{r})$，在所有单元中心计算 $p$，在面中心计算 MAC 离散压力梯度，在相同的面中心计算 $\\rho \\mathbf{a}_{\\mathrm{cf}}$，然后计算 $x$ 和 $y$ 方向动量方程中的逐点残差：在 $x$面上为 $R_x = -\\frac{p_{i+1,j}-p_{i,j}}{\\Delta x} + \\rho \\, a_{\\mathrm{cf},x}$，在 $y$面上为 $R_y = -\\frac{p_{i,j+1}-p_{i,j}}{\\Delta y} + \\rho \\, a_{\\mathrm{cf},y}$。\n- 通过报告所有内部面和两个分量上的最大绝对残差来汇总结果，即 $\\max\\left(\\max_{i,j} |R_x|, \\max_{i,j} |R_y|\\right)$，单位为 $\\mathrm{N/m^3}$。\n\n角度单位：角速度矢量 $\\boldsymbol{\\Omega} = (\\Omega_x,\\Omega_y,\\Omega_z)$ 的分量单位为弧度/秒。距离单位为米。密度单位为 $\\mathrm{kg/m^3}$。残差必须以 $\\mathrm{N/m^3}$ 报告。\n\n测试套件：\n对于以下每一组参数，计算上述的单个标量输出。\n\n- 测试 1（理想情况，方形单元，轴对齐角速度）：\n  - $\\rho = 1000$，\n  - $\\boldsymbol{\\Omega} = (0,0,10)$，\n  - 区域：$x \\in [0,1]$，$y \\in [0,1]$，$z_0 = 0$，\n  - 网格：$N_x = 64$，$N_y = 64$。\n- 测试 2（矩形单元，轴对齐角速度，偏心区域）：\n  - $\\rho = 1$，\n  - $\\boldsymbol{\\Omega} = (0,0,2.5)$，\n  - 区域：$x \\in [-2,3]$，$y \\in [-1,1]$，$z_0 = 0$，\n  - 网格：$N_x = 50$，$N_y = 20$。\n- 测试 3（非轴对齐角速度，非零平面偏移）：\n  - $\\rho = 1.2$，\n  - $\\boldsymbol{\\Omega} = (3,4,5)$，\n  - 区域：$x \\in [1,2]$，$y \\in [-0.3,0.7]$，$z_0 = 0.2$，\n  - 网格：$N_x = 37$，$N_y = 29$。\n- 测试 4（最少内部面）：\n  - $\\rho = 850$，\n  - $\\boldsymbol{\\Omega} = (0,0,0.1)$，\n  - 区域：$x \\in [-1,1]$，$y \\in [-1,1]$，$z_0 = 0$，\n  - 网格：$N_x = 2$，$N_y = 2$。\n- 测试 5（更大角速度，小区域）：\n  - $\\rho = 997$，\n  - $\\boldsymbol{\\Omega} = (0,0,1000)$，\n  - 区域：$x \\in [0.1,0.2]$，$y \\in [-0.05,0.05]$，$z_0 = 0$，\n  - 网格：$N_x = 16$，$N_y = 16$。\n\n您的程序必须为每个测试计算单个标量 $\\max\\left(\\max_{i,j} |R_x|, \\max_{i,j} |R_y|\\right)$，并最终打印一行结果，该结果是包含所有测试结果的逗号分隔列表，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是一个以 $\\mathrm{N/m^3}$ 为单位的浮点数值。",
            "solution": "用户提供的问题是一个在计算流体力学领域中定义明确的验证性练习。它在科学上是合理的，并且所有必需的信息都已提供。\n\n该问题要求针对一个特定案例，验证标记-单元（MAC）交错网格离散化的一个属性。物理情景是处于稳态、无粘性刚体旋转状态的流体。在与流体一同旋转的参考系中，静止流体的控制方程是压力梯度和体积力之间的静水平衡。除了可以被吸收到修正后压力中的均匀引力场外，唯一考虑的体积力是离心力。平衡方程为：\n$$-\\nabla p + \\rho \\mathbf{a}_{\\mathrm{cf}} = \\mathbf{0}$$\n其中 $p$ 是压力，$\\rho$ 是恒定的流体密度，$\\mathbf{a}_{\\mathrm{cf}}$ 是离心加速度。问题在于证明，当使用精确的解析压力场时，该方程的标准 MAC 网格离散化会产生一个在机器精度范围内的零残差。这是对离散化方案精确表示某类解析解能力的验证。\n\n## 基于原理的设计与推导\n\n### 1. 解析压力场的推导\n首先，我们推导满足连续静水平衡方程的解析压力场 $p(\\mathbf{r})$。该方程可以写为：\n$$\\nabla p = \\rho \\mathbf{a}_{\\mathrm{cf}}$$\n离心加速度由公式 $\\mathbf{a}_{\\mathrm{cf}} = -\\boldsymbol{\\Omega} \\times (\\boldsymbol{\\Omega} \\times \\mathbf{r})$ 给出，其中 $\\boldsymbol{\\Omega}$ 是恒定的角速度矢量，$\\mathbf{r}$ 是位置矢量。\n\n使用矢量三重积恒等式 $\\mathbf{A} \\times (\\mathbf{B} \\times \\mathbf{C}) = \\mathbf{B}(\\mathbf{A} \\cdot \\mathbf{C}) - \\mathbf{C}(\\mathbf{A} \\cdot \\mathbf{B})$，我们展开 $\\mathbf{a}_{\\mathrm{cf}}$ 的表达式：\n$$\\mathbf{a}_{\\mathrm{cf}} = -[\\boldsymbol{\\Omega}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) - \\mathbf{r}(\\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega})]$$\n$$\\mathbf{a}_{\\mathrm{cf}} = (\\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega})\\mathbf{r} - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega}$$\n令 $\\Omega^2 = |\\boldsymbol{\\Omega}|^2 = \\boldsymbol{\\Omega} \\cdot \\boldsymbol{\\Omega}$。因此，压力梯度为：\n$$\\nabla p = \\rho [ \\Omega^2 \\mathbf{r} - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega} ]$$\n该矢量场是一个标量势的梯度。我们可以通过积分找到 $p(\\mathbf{r})$。我们识别出表达式中的部分是标量场的梯度：\n$$\\nabla(\\frac{1}{2} r^2) = \\nabla(\\frac{1}{2} \\mathbf{r} \\cdot \\mathbf{r}) = \\mathbf{r}$$\n$$\\nabla(\\frac{1}{2}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) = (\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) \\nabla(\\boldsymbol{\\Omega} \\cdot \\mathbf{r}) = (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})\\boldsymbol{\\Omega}$$\n将这些代入 $\\nabla p$ 的表达式中：\n$$\\nabla p = \\rho [ \\Omega^2 \\nabla(\\frac{1}{2} r^2) - \\nabla(\\frac{1}{2}(\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) ] = \\nabla \\left[ \\frac{1}{2}\\rho ( \\Omega^2 r^2 - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2 ) \\right]$$\n对 $\\mathbf{r}$ 进行积分，得到压力场，相差一个任意常数 $p_0$：\n$$p(\\mathbf{r}) = \\frac{1}{2}\\rho (\\Omega^2 r^2 - (\\boldsymbol{\\Omega} \\cdot \\mathbf{r})^2) + p_0$$\n这可以用恒等式 $|\\mathbf{A} \\times \\mathbf{B}|^2 = |\\mathbf{A}|^2 |\\mathbf{B}|^2 - (\\mathbf{A} \\cdot \\mathbf{B})^2$ 更紧凑地表示：\n$$p(\\mathbf{r}) = \\frac{1}{2}\\rho |\\boldsymbol{\\Omega} \\times \\mathbf{r}|^2 + p_0$$\n由于只有压力差有意义，我们可以将参考压力 $p_0$ 设为 $0$。\n\n### 2. 离散化与残差分析\n问题指定了一个在平面 $z=z_0$ 中的二维 MAC 网格。压力 $p$ 位于单元中心 $(x_{i+1/2}, y_{j+1/2})$，而速度分量（以及动量方程残差）位于面中心。\n$x$方向动量方程的残差 $R_x$ 在垂直面的中心，即位置 $(x_{i+1}, y_{j+1/2})$ 处进行计算。残差定义为：\n$$R_x = -\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} + \\rho \\, a_{\\mathrm{cf},x}|_{(x_{i+1}, y_{j+1/2})}$$\n其中 $p_{i,j}$ 表示单元 $(i,j)$ 中心的压力，即 $p(x_{i+1/2}, y_{j+1/2}, z_0)$。\n\n一个关键的观察是，解析压力场 $p(x,y,z_0)$ 是空间坐标 $x$ 和 $y$ 的二次多项式。让我们用 $\\mathbf{r}=(x,y,z_0)$ 和 $\\boldsymbol{\\Omega}=(\\Omega_x, \\Omega_y, \\Omega_z)$ 展开 $p$ 的表达式：\n$$p(x,y) = \\frac{1}{2}\\rho [(\\Omega_x^2+\\Omega_y^2+\\Omega_z^2)(x^2+y^2+z_0^2) - (\\Omega_x x + \\Omega_y y + \\Omega_z z_0)^2]$$\n$$p(x,y) = A x^2 + B y^2 + C xy + D x + E y + F$$\n其中 $A, B, C, D, E, F$ 是依赖于 $\\rho, \\boldsymbol{\\Omega}$ 和 $z_0$ 的常数。\n\n离散压力梯度项 $-\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x}$ 是 $-\\frac{\\partial p}{\\partial x}$ 的中心差分近似。压力值取自单元中心 $(x_{i+1/2}, y_{j+1/2})$ 和 $(x_{i+3/2}, y_{j+1/2})$。这两个位置之间的中点是 $(x_{i+1}, y_{j+1/2})$，这正是计算残差 $R_x$ 的位置。\n\n对于任何二次多项式 $f(x) = ax^2 + bx + c$，中心有限差分是精确的，即它等于中点处的解析导数：\n$$\\frac{f(x_0 + h/2) - f(x_0 - h/2)}{h} = \\frac{[a(x_0+h/2)^2 + b(x_0+h/2)+c] - [a(x_0-h/2)^2 + b(x_0-h/2)+c]}{h} = 2ax_0 + b = f'(x_0)$$\n由于我们的压力场 $p(x,y)$ 对于固定的 $y$ 是 $x$ 的二次函数，所以离散梯度精确地等于面中心的连续梯度：\n$$\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = \\left. \\frac{\\partial p}{\\partial x} \\right|_{(x_{i+1}, y_{j+1/2})}$$\n从我们最初的推导中，我们知道连续压力场精确地平衡了离心力，即 $\\nabla p = \\rho \\mathbf{a}_{\\mathrm{cf}}$。这意味着在空间中的每一点 $\\frac{\\partial p}{\\partial x} = \\rho a_{\\mathrm{cf},x}$。\n因此，在面中心 $(x_{i+1}, y_{j+1/2})$ 处：\n$$\\frac{p_{i+1,j} - p_{i,j}}{\\Delta x} = \\left. \\rho a_{\\mathrm{cf},x} \\right|_{(x_{i+1}, y_{j+1/2})}$$\n将此代入残差 $R_x$ 的定义中：\n$$R_x = -\\left(\\rho a_{\\mathrm{cf},x}\\right) + \\rho a_{\\mathrm{cf},x} = 0$$\n同样的逻辑也适用于 $y$ 分量残差 $R_y$。因此，离散残差在解析上为零。数值实现应产生在浮点精度范围内为零的结果。\n\n### 3. 算法实现\n程序将通过以下步骤为每个测试用例实现验证：\n1. 解析测试用例参数：$\\rho$、$\\boldsymbol{\\Omega}$、区域边界、$z_0$ 以及网格分辨率 $N_x, N_y$。\n2. 计算网格间距 $\\Delta x$ 和 $\\Delta y$。\n3. 使用 NumPy 的广播机制高效地生成压力单元中心的坐标数组。\n4. 在所有单元中心计算解析压力场 $p(\\mathbf{r})$，以填充一个二维压力数组 `p_grid`。\n5. 对于 $x$ 方向动量残差：\n    a. 生成内部垂直面中心的坐标数组。\n    b. 计算所有相关面的离散压力梯度 $-\\left(p_{i+1,j}-p_{i,j}\\right)/\\Delta x$。\n    c. 在相同的面中心计算离心力项 $\\rho a_{\\mathrm{cf},x}$。\n    d. 将这两项相加，计算残差 $R_x$。\n6. 对 $y$ 方向动量残差 $R_y$ 在内部水平面上重复此过程。\n7. 确定所有计算出的 $R_x$ 和 $R_y$ 值的最大绝对值。这是该测试用例的最终结果。\n8. 收集所有测试用例的结果，并按指定格式进行格式化。\n\n该算法直接实现了问题陈述中的公式和定义，并利用了上面推导出的解析解来测试数值格式的特性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases and print the results.\n    \"\"\"\n\n    def calculate_max_residual(params):\n        \"\"\"\n        Calculates the maximum absolute residual for a single test case.\n\n        Args:\n            params (tuple): A tuple containing all parameters for the test case:\n                (rho, Omega_vec, domain_x, domain_y, z0, Nx, Ny).\n\n        Returns:\n            float: The maximum absolute residual found on the grid.\n        \"\"\"\n        rho, Omega_vec, domain_x, domain_y, z0, Nx, Ny = params\n        Omega_vec = np.array(Omega_vec, dtype=float)\n        x_min, x_max = domain_x\n        y_min, y_max = domain_y\n\n        dx = (x_max - x_min) / Nx\n        dy = (y_max - y_min) / Ny\n\n        # --- 1. Calculate pressure at cell centers ---\n        # Use broadcasting to create coordinate grids implicitly\n        i_p = np.arange(Nx, dtype=float).reshape(-1, 1)\n        j_p = np.arange(Ny, dtype=float).reshape(1, -1)\n        x_p = x_min + (i_p + 0.5) * dx\n        y_p = y_min + (j_p + 0.5) * dy\n\n        # Evaluate analytical pressure field p(r) = 0.5 * rho * |Omega x r|^2\n        omega_sq = np.dot(Omega_vec, Omega_vec)\n        r_sq = x_p**2 + y_p**2 + z0**2\n        omega_dot_r = Omega_vec[0] * x_p + Omega_vec[1] * y_p + Omega_vec[2] * z0\n        p_grid = 0.5 * rho * (omega_sq * r_sq - omega_dot_r**2)\n\n        max_res = 0.0\n\n        # --- 2. Calculate x-momentum residual Rx ---\n        if Nx > 1:\n            # Coordinates of x-face centers (where Rx is evaluated)\n            i_rx = np.arange(Nx - 1, dtype=float).reshape(-1, 1)\n            j_rx = np.arange(Ny, dtype=float).reshape(1, -1)\n            x_fx = x_min + (i_rx + 1.0) * dx\n            y_fx = y_min + (j_rx + 0.5) * dy\n\n            # Discrete pressure gradient component in x\n            grad_p_x = (p_grid[1:, :] - p_grid[:-1, :]) / dx\n\n            # Centrifugal force component at x-faces: rho * a_cf,x\n            # a_cf = Omega^2 * r - (Omega . r) * Omega\n            omega_dot_r_fx = Omega_vec[0] * x_fx + Omega_vec[1] * y_fx + Omega_vec[2] * z0\n            a_cf_x = omega_sq * x_fx - omega_dot_r_fx * Omega_vec[0]\n            force_x = rho * a_cf_x\n\n            # Calculate residual\n            Rx = -grad_p_x + force_x\n            max_res = max(max_res, np.max(np.abs(Rx)))\n\n        # --- 3. Calculate y-momentum residual Ry ---\n        if Ny > 1:\n            # Coordinates of y-face centers (where Ry is evaluated)\n            i_ry = np.arange(Nx, dtype=float).reshape(-1, 1)\n            j_ry = np.arange(Ny - 1, dtype=float).reshape(1, -1)\n            x_fy = x_min + (i_ry + 0.5) * dx\n            y_fy = y_min + (j_ry + 1.0) * dy\n\n            # Discrete pressure gradient component in y\n            grad_p_y = (p_grid[:, 1:] - p_grid[:, :-1]) / dy\n\n            # Centrifugal force component at y-faces: rho * a_cf,y\n            omega_dot_r_fy = Omega_vec[0] * x_fy + Omega_vec[1] * y_fy + Omega_vec[2] * z0\n            a_cf_y = omega_sq * y_fy - omega_dot_r_fy * Omega_vec[1]\n            force_y = rho * a_cf_y\n\n            # Calculate residual\n            Ry = -grad_p_y + force_y\n            max_res = max(max_res, np.max(np.abs(Ry)))\n\n        return max_res\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: rho, Omega, domain_x, domain_y, z0, Nx, Ny\n        (1000.0, (0.0, 0.0, 10.0), (0.0, 1.0), (0.0, 1.0), 0.0, 64, 64),\n        # Test 2\n        (1.0, (0.0, 0.0, 2.5), (-2.0, 3.0), (-1.0, 1.0), 0.0, 50, 20),\n        # Test 3\n        (1.2, (3.0, 4.0, 5.0), (1.0, 2.0), (-0.3, 0.7), 0.2, 37, 29),\n        # Test 4\n        (850.0, (0.0, 0.0, 0.1), (-1.0, 1.0), (-1.0, 1.0), 0.0, 2, 2),\n        # Test 5\n        (997.0, (0.0, 0.0, 1000.0), (0.1, 0.2), (-0.05, 0.05), 0.0, 16, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_max_residual(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}