{
    "hands_on_practices": [
        {
            "introduction": "The remarkable efficiency of transform-based solvers stems from a deep connection between the discrete Laplacian operator and sinusoidal functions. This first practice invites you to uncover this connection from first principles. By deriving the eigenvalues and eigenvectors of the 1D second-difference operator, you will see precisely why the Discrete Sine Transform is the natural tool for diagonalizing the system in the presence of Dirichlet boundary conditions .",
            "id": "3443413",
            "problem": "Consider the uniform partition of the interval $[0,1]$ into $n+2$ points $x_j=jh$ with $j=0,1,\\dots,n+1$ and $h=1/(n+1)$. Impose homogeneous Dirichlet boundary conditions $u_0=0$ and $u_{n+1}=0$, and consider the discrete negative Laplacian (second-difference) operator acting on interior unknowns $\\mathbf{u}=(u_1,\\dots,u_n)^{\\top}$ by\n$$(A\\mathbf{u})_j=\\frac{-u_{j-1}+2u_j-u_{j+1}}{h^2},\\quad j=1,\\dots,n,$$\nwith the boundary values $u_0$ and $u_{n+1}$ fixed at zero. Starting from the definition of eigenvalues and eigenvectors for a linear operator, and using only foundational facts such as linearity, trigonometric identities, and the characterization of separable modes that satisfy homogeneous Dirichlet conditions, determine the closed-form expression for the eigenvalues $\\lambda_k$ of $A$ indexed by $k\\in\\{1,2,\\dots,n\\}$. Relate your reasoning to the role of the Discrete Sine Transform (DST) in diagonalizing $A$, but do not assume any pre-tabulated transform pairs.\n\nProvide your final answer as a single analytic expression for $\\lambda_k$ in terms of $h$, $n$, and $k$. No numerical approximation is required, and no units are involved.",
            "solution": "The problem is first validated against the specified criteria.\n\n### Step 1: Extract Givens\n- Domain partition: The interval $[0, 1]$ is partitioned by $n+2$ points $x_j=jh$ for $j=0, 1, \\dots, n+1$.\n- Step size: $h=1/(n+1)$.\n- Boundary conditions: Homogeneous Dirichlet conditions $u_0=0$ and $u_{n+1}=0$.\n- Unknowns: The vector of interior values $\\mathbf{u}=(u_1, u_2, \\dots, u_n)^{\\top}$.\n- Operator: The discrete negative Laplacian (second-difference) operator $A$ is defined by its action on $\\mathbf{u}$ as\n$$(A\\mathbf{u})_j = \\frac{-u_{j-1} + 2u_j - u_{j+1}}{h^2}, \\quad \\text{for } j=1, 2, \\dots, n.$$\n- Task: Determine the closed-form expression for the eigenvalues $\\lambda_k$ of $A$ for $k \\in \\{1, 2, \\dots, n\\}$.\n- Methodological constraints: The derivation must start from the definition of eigenvalues and eigenvectors, using only foundational principles. The result should be related to the Discrete Sine Transform (DST) without assuming its properties.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is a fundamental topic in numerical analysis, specifically in the finite difference method for solving partial differential equations. The discrete Laplacian is a standard, well-studied mathematical object. The problem is scientifically sound.\n- **Well-Posed**: The problem asks for the eigenvalues of a specific $n \\times n$ matrix. An $n \\times n$ matrix always has a set of $n$ eigenvalues (counting multiplicity), so a solution exists and is unique. The problem is well-posed.\n- **Objective**: The problem is stated in precise, formal mathematical language, with no subjectivity or ambiguity.\n\nThe problem statement is self-contained, consistent, and adheres to established scientific and mathematical principles. It does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be provided.\n\n### Solution Derivation\n\nThe eigenvalues $\\lambda$ and corresponding eigenvectors $\\mathbf{v} \\neq \\mathbf{0}$ of a linear operator $A$ are defined by the equation $A\\mathbf{v} = \\lambda\\mathbf{v}$. For the given discrete negative Laplacian operator $A$, this equation can be written component-wise for an eigenvector $\\mathbf{v} = (v_1, v_2, \\dots, v_n)^{\\top}$ as:\n$$ (A\\mathbf{v})_j = \\frac{-v_{j-1} + 2v_j - v_{j+1}}{h^2} = \\lambda v_j, \\quad \\text{for } j=1, 2, \\dots, n. $$\nThe definition of the operator uses the boundary values $v_0$ and $v_{n+1}$, which, like the original variable $u$, must satisfy the homogeneous Dirichlet conditions $v_0 = 0$ and $v_{n+1} = 0$.\n\nThe problem prompts us to consider separable modes satisfying these boundary conditions. The continuous analogue is the Sturm-Liouville problem $-u''(x) = \\lambda u(x)$ on $[0,1]$ with $u(0)=u(1)=0$, whose eigenfunctions are of the form $\\sin(k\\pi x)$. This motivates proposing a discrete analogue for the components of the eigenvector $\\mathbf{v}$:\n$$ v_j = C \\sin(\\alpha x_j) = C \\sin(\\alpha j h) $$\nfor some constants $C$ and $\\alpha$. We can set $C=1$ since eigenvectors are defined up to a scalar multiple.\n\nWe must first ensure this form satisfies the boundary conditions:\n1.  For $j=0$: $v_0 = \\sin(\\alpha \\cdot 0 \\cdot h) = \\sin(0) = 0$. This condition is automatically satisfied.\n2.  For $j=n+1$: $v_{n+1} = \\sin(\\alpha(n+1)h) = 0$. Given $h=1/(n+1)$, this becomes $\\sin(\\alpha(n+1)\\frac{1}{n+1}) = \\sin(\\alpha) = 0$.\n\nThe condition $\\sin(\\alpha)=0$ implies that $\\alpha$ must be an integer multiple of $\\pi$. Let $\\alpha = k\\pi$ for some integer $k$. The proposed eigenvector components are therefore:\n$$ v_j^{(k)} = \\sin(k\\pi j h) $$\nWe need to find $n$ linearly independent eigenvectors. Let's examine the choice of the integer $k$:\n- If $k=0$, $v_j^{(0)} = \\sin(0) = 0$ for all $j$, which is the trivial zero vector and not an eigenvector.\n- For $k \\in \\{1, 2, \\dots, n\\}$, the vectors $\\mathbf{v}^{(k)}$ are non-trivial and are known to be linearly independent.\n- If $k=n+1$, $v_j^{(n+1)} = \\sin((n+1)\\pi j h) = \\sin(\\pi j (n+1)/(n+1)) = \\sin(j\\pi) = 0$ for all integer $j$. This again is the zero vector.\n- For other integer values of $k$, the vectors become redundant (e.g., $\\mathbf{v}^{(k)} = -\\mathbf{v}^{(-k)}$ and $\\mathbf{v}^{(k)} = (-1)^{m} \\mathbf{v}^{(k+m(n+1))}$).\n\nThus, we can generate all $n$ distinct eigenvectors by choosing $k=1, 2, \\dots, n$. Let us now substitute the $k$-th eigenvector form, $v_j = \\sin(k\\pi jh)$, into the eigenvalue equation. Let $\\lambda_k$ be the eigenvalue corresponding to the eigenvector $\\mathbf{v}^{(k)}$.\n$$ \\frac{-\\sin(k\\pi(j-1)h) + 2\\sin(k\\pi jh) - \\sin(k\\pi(j+1)h)}{h^2} = \\lambda_k \\sin(k\\pi jh) $$\nLet's focus on the numerator. Using the sum-to-product identity $\\sin(A-B) + \\sin(A+B) = 2\\sin(A)\\cos(B)$, we can simplify the term $\\sin(k\\pi(j-1)h) + \\sin(k\\pi(j+1)h)$. Let $A = k\\pi jh$ and $B = k\\pi h$.\n$$ \\sin(k\\pi jh - k\\pi h) + \\sin(k\\pi jh + k\\pi h) = 2\\sin(k\\pi jh)\\cos(k\\pi h) $$\nThe numerator of the left-hand side of the eigenvalue equation becomes:\n$$ 2\\sin(k\\pi jh) - \\big( \\sin(k\\pi(j-1)h) + \\sin(k\\pi(j+1)h) \\big) = 2\\sin(k\\pi jh) - 2\\sin(k\\pi jh)\\cos(k\\pi h) $$\n$$ = 2\\sin(k\\pi jh) \\big( 1 - \\cos(k\\pi h) \\big) $$\nSubstituting this back into the eigenvalue equation:\n$$ \\frac{2\\sin(k\\pi jh) (1 - \\cos(k\\pi h))}{h^2} = \\lambda_k \\sin(k\\pi jh) $$\nSince $\\mathbf{v}^{(k)}$ is a non-zero vector, we can find a $j$ for which $\\sin(k\\pi jh) \\neq 0$. Thus, we can divide both sides by $\\sin(k\\pi jh)$ to solve for the eigenvalue $\\lambda_k$:\n$$ \\lambda_k = \\frac{2(1 - \\cos(k\\pi h))}{h^2} $$\nTo obtain a more common form, we use the half-angle trigonometric identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$. With $\\theta = k\\pi h$, this gives:\n$$ \\lambda_k = \\frac{2(2\\sin^2(k\\pi h/2))}{h^2} = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right) $$\nThe problem asks for the expression in terms of $h$, $n$, and $k$. We can use the definition $h=1/(n+1)$ to write the argument of the sine function in terms of $n$.\n$$ \\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) $$\nThis expression is valid for each $k = 1, 2, \\dots, n$.\n\nFinally, we relate this result to the Discrete Sine Transform (DST). The components of the $k$-th eigenvector are $v_j^{(k)} = \\sin(k \\pi j h) = \\sin\\left(\\frac{k j \\pi}{n+1}\\right)$. The matrix $S$ whose $(j,k)$-th entry is proportional to this value, i.e., $S_{jk} = \\sqrt{\\frac{2}{n+1}}\\sin\\left(\\frac{kj\\pi}{n+1}\\right)$, is the matrix of the DST (specifically, DST-I). The columns of this matrix $S$ are the orthonormalized eigenvectors of the discrete Laplacian matrix $A$. The existence of such an eigenbasis implies that the matrix $A$ is diagonalized by the DST matrix $S$. That is, $S^{-1}AS = \\Lambda$ or $S^{\\top}AS = \\Lambda$, where $\\Lambda$ is a diagonal matrix whose entries are the eigenvalues $\\lambda_k$. This is the fundamental reason why transform-based methods are exceptionally efficient for solving linear systems involving the discrete Laplacian on uniform grids. The transform decouples the system of equations into $n$ independent scalar equations in the transformed domain, which can be solved trivially.",
            "answer": "$$\n\\boxed{\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)}\n$$"
        },
        {
            "introduction": "Building on the 1D foundation, we can now construct a powerful solver for two-dimensional problems by leveraging the principle of separability. This exercise guides you through the implementation of a 2D fast Poisson solver that uses a sequence of 1D transforms applied to the rows and columns of the data grid. This practice demonstrates not only the algorithmic elegance of the method but also introduces practical considerations for efficient computation .",
            "id": "3443478",
            "problem": "Consider the separable Poisson problem on a rectangle with homogeneous Dirichlet boundary conditions: find $u(x,y)$ such that\n$$ -\\frac{\\partial^2 u}{\\partial x^2}(x,y) - \\frac{\\partial^2 u}{\\partial y^2}(x,y) = f(x,y), \\quad (x,y) \\in (0,L_x)\\times(0,L_y), $$\nwith $u(x,y)=0$ on the boundary of the rectangle. Discretize the interior of the domain using a uniform tensor-product grid with $N_x$ and $N_y$ interior points in the $x$ and $y$ directions, respectively, and grid spacings $h_x = \\frac{L_x}{N_x+1}$ and $h_y = \\frac{L_y}{N_y+1}$. Let $u_{j,i} \\approx u(x_i,y_j)$ denote the grid function at interior nodes $x_i = i h_x$ for $i=1,\\dots,N_x$ and $y_j = j h_y$ for $j=1,\\dots,N_y$. Using centered second-order finite differences, the discrete Laplacian $\\Delta_h$ acting on an interior grid function $u$ is\n$$ (\\Delta_h u)_{j,i} = \\frac{u_{j,i-1} - 2 u_{j,i} + u_{j,i+1}}{h_x^2} + \\frac{u_{j-1,i} - 2 u_{j,i} + u_{j+1,i}}{h_y^2}, $$\nwith the convention that values outside the interior index range are set to zero to enforce the homogeneous Dirichlet boundary conditions. The discrete problem is: find the interior grid function $u$ such that\n$$ -\\Delta_h u = f_h, $$\nwhere $f_h$ is a sampling of $f$ on the interior grid.\n\nIt is a well-tested fact that the one-dimensional discrete operator corresponding to the second derivative with homogeneous Dirichlet boundary conditions is diagonalized by the Discrete Sine Transform (DST) of type $\\mathrm{I}$, with eigenvalues\n$$ \\lambda^{(x)}_k = \\frac{4}{h_x^2} \\sin^2\\!\\left(\\frac{k\\pi}{2(N_x+1)}\\right), \\quad k=1,\\dots,N_x, $$\nand similarly in the $y$-direction with\n$$ \\lambda^{(y)}_\\ell = \\frac{4}{h_y^2} \\sin^2\\!\\left(\\frac{\\ell\\pi}{2(N_y+1)}\\right), \\quad \\ell=1,\\dots,N_y. $$\nBy separability, the two-dimensional operator $-\\Delta_h$ is diagonalized by applying the one-dimensional transform along rows and columns.\n\nYour task is to implement a two-dimensional solver for $-\\Delta_h u = f_h$ based on one-dimensional transforms that are applied separately along rows and columns. You must:\n- Derive, from the above definitions and facts, how to diagonalize the two-dimensional operator using the Discrete Sine Transform (DST) of type $\\mathrm{I}$ with orthonormal normalization, and hence obtain the spectral formula to compute the transformed solution coefficients.\n- Implement the two-dimensional transform application by performing one-dimensional transforms along the last axis only, then permuting axes to bring the other spatial dimension to the last position, and repeating. This is to preserve contiguous memory access (cache efficiency) for each transform call. You may use the Discrete Sine Transform (DST) and the Discrete Cosine Transform (DCT) from a standard scientific library with explicit type and normalization parameters, but you must not use any direct two-dimensional transform routine.\n- Implement a function that computes the discrete Laplacian $\\Delta_h$ on the interior with homogeneous Dirichlet boundary conditions by zero-padding the boundary as described above. Use this to generate right-hand sides $f_h$ from known (sampled) exact interior solutions $u$ so that the numerical solver’s output can be compared to the exact discrete solution.\n- In addition to the Poisson solver based on sine transforms, implement analogous two-pass helpers for two-dimensional Discrete Cosine Transform (DCT) of a given type and normalization, again by transforming along the last axis with a permutation step between passes.\n\nAngles must be in radians. No physical units are present. All numerical answers must be reported as floating-point numbers or booleans, as specified below.\n\nTest Suite:\nImplement your program to evaluate the following five test cases and produce outputs as specified.\n\n$1$. Homogeneous Dirichlet, rectangular grid (happy path):\n- Parameters: $N_x=32$, $N_y=20$, $L_x=1$, $L_y=1$, exact interior solution $u(x,y) = \\sin(3\\pi x/L_x)\\sin(5\\pi y/L_y)$.\n- Construct $u_{j,i}$ by sampling $u$ at interior nodes, compute $f_h = -\\Delta_h u$, solve $-\\Delta_h \\tilde{u} = f_h$, and return the relative discrete $\\ell^2$ error\n$$ \\frac{\\| \\tilde{u} - u \\|_2}{\\|u\\|_2}, $$\nwhere the norm is the Euclidean norm over the interior grid values.\n\n$2$. Homogeneous Dirichlet, rectangular domain with unequal side lengths:\n- Parameters: $N_x=29$, $N_y=37$, $L_x=2.0$, $L_y=0.5$, exact interior solution $u(x,y) = \\sin(2\\pi x/L_x)\\sin(9\\pi y/L_y)$.\n- Return the relative discrete $\\ell^2$ error, defined as in case $1$.\n\n$3$. Homogeneous Dirichlet, edge case with $N_x=1$:\n- Parameters: $N_x=1$, $N_y=17$, $L_x=1.0$, $L_y=1.0$, exact interior solution $u(x,y) = \\sin(\\pi x/L_x)\\sin(7\\pi y/L_y)$.\n- Return the relative discrete $\\ell^2$ error, defined as in case $1$.\n\n$4$. Two-pass transform equivalence for DST:\n- Generate a fixed random array $A \\in \\mathbb{R}^{23\\times 17}$ using a fixed seed. Compute the two-dimensional DST-$\\mathrm{I}$ with orthonormal normalization in two ways:\n  (a) by applying the one-dimensional transform along the last axis, swapping axes, and transforming along the last axis again; and\n  (b) by transforming directly along axis $1$ and then along axis $0$ without swaps.\n- Return a boolean that is $true$ if the maximum absolute difference between the two results is less than or equal to $10^{-10}$, and $false$ otherwise.\n\n$5$. Two-pass transform equivalence for DCT:\n- Generate a fixed random array $B \\in \\mathbb{R}^{16\\times 10}$ using the same fixed seed as in case $4$. Compute the two-dimensional DCT-$\\mathrm{II}$ with orthonormal normalization using the same two approaches as in case $4$.\n- Return a boolean that is $true$ if the maximum absolute difference between the two results is less than or equal to $10^{-10}$, and $false$ otherwise.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $5$, for example, in the format\n$[r_1,r_2,r_3,b_4,b_5]$,\nwhere $r_1$, $r_2$, and $r_3$ are floating-point numbers and $b_4$, $b_5$ are booleans represented as $True$ or $False$.",
            "solution": "The user-provided problem has been analyzed and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. I will now proceed with a complete solution.\n\n### Derivation of the Spectral Poisson Solver\n\nThe problem is to solve the discrete Poisson equation $-\\Delta_h u = f_h$ on a rectangular grid with homogeneous Dirichlet boundary conditions. Let the grid function $u$ be represented by an $N_y \\times N_x$ matrix $U = [u_{j,i}]$, where $j \\in \\{1, \\dots, N_y\\}$ is the row index and $i \\in \\{1, \\dots, N_x\\}$ is the column index. The right-hand side $f_h$ is similarly represented by a matrix $F = [f_{j,i}]$.\n\nThe discrete Laplacian operator $\\Delta_h$ is separable, meaning it can be expressed as the sum of one-dimensional operators acting along each coordinate direction:\n$$ \\Delta_h = D_{xx} + D_{yy} $$\nwhere $(D_{xx} U)_{j,i} = \\frac{u_{j,i-1} - 2u_{j,i} + u_{j,i+1}}{h_x^2}$ acts on the rows of $U$, and $(D_{yy} U)_{j,i} = \\frac{u_{j-1,i} - 2u_{j,i} + u_{j+1,i}}{h_y^2}$ acts on the columns.\n\nLet $A_x$ be the $N_x \\times N_x$ matrix representing the one-dimensional finite difference operator for the second derivative in the $x$-direction, and $A_y$ be the corresponding $N_y \\times N_y$ matrix for the $y$-direction. These are symmetric tridiagonal matrices:\n$$ A_x = \\frac{1}{h_x^2} \\begin{pmatrix} -2 & 1 & & \\\\ 1 & -2 & 1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & 1 & -2 \\end{pmatrix}_{N_x \\times N_x} $$\nand similarly for $A_y$. The action of $D_{xx}$ corresponds to right-multiplication by $A_x$, and the action of $D_{yy}$ corresponds to left-multiplication by $A_y$. The discrete Poisson equation in matrix form is:\n$$ -(A_y U + U A_x) = F $$\n\nThe problem states that the one-dimensional operators are diagonalized by the Discrete Sine Transform of type I (DST-I). Let $S_x$ and $S_y$ be the orthonormal DST-I transform matrices of size $N_x \\times N_x$ and $N_y \\times N_y$, respectively. Their elements are given by $(S_x)_{k,i} = \\sqrt{\\frac{2}{N_x+1}} \\sin\\left(\\frac{ki\\pi}{N_x+1}\\right)$ for $k,i=1,\\dots,N_x$, and similarly for $S_y$. These matrices are symmetric ($S_x^T = S_x$) and orthogonal ($S_x S_x = I_x$, where $I_x$ is the $N_x \\times N_x$ identity matrix).\n\nThe operators $-A_x$ and $-A_y$ are diagonalized by $S_x$ and $S_y$:\n$$ -A_x = S_x \\Lambda_x S_x \\quad \\text{and} \\quad -A_y = S_y \\Lambda_y S_y $$\nwhere $\\Lambda_x$ and $\\Lambda_y$ are diagonal matrices containing the eigenvalues provided in the problem statement:\n$$ (\\Lambda_x)_{k,k} = \\lambda_k^{(x)} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{k\\pi}{2(N_x+1)}\\right), \\quad k=1,\\dots,N_x $$\n$$ (\\Lambda_y)_{\\ell,\\ell} = \\lambda_\\ell^{(y)} = \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\ell\\pi}{2(N_y+1)}\\right), \\quad \\ell=1,\\dots,N_y $$\n\nTo solve the matrix equation, we apply the 2D DST-I to it. Let $\\hat{U} = S_y U S_x$ be the transformed solution and $\\hat{F} = S_y F S_x$ be the transformed right-hand side. We pre-multiply the equation by $S_y$ and post-multiply by $S_x$:\n$$ S_y ((-A_y U) + (U (-A_x))) S_x = S_y F S_x $$\n$$ (S_y (-A_y)) U S_x + S_y U ((-A_x) S_x) = \\hat{F} $$\nSubstituting the diagonalizations:\n$$ (S_y (S_y \\Lambda_y S_y)) U S_x + S_y U ((S_x \\Lambda_x S_x) S_x) = \\hat{F} $$\nUsing the orthogonality property ($S_y S_y = I_y$, $S_x S_x = I_x$):\n$$ (I_y \\Lambda_y S_y) U S_x + S_y U (S_x \\Lambda_x I_x) = \\hat{F} $$\n$$ \\Lambda_y (S_y U S_x) + (S_y U S_x) \\Lambda_x = \\hat{F} $$\nThis yields the equation in the spectral domain:\n$$ \\Lambda_y \\hat{U} + \\hat{U} \\Lambda_x = \\hat{F} $$\nSince $\\Lambda_x$ and $\\Lambda_y$ are diagonal, this is an element-wise algebraic equation for the coefficients $\\hat{U}_{\\ell,k}$ of the transformed matrix $\\hat{U}$:\n$$ \\lambda_\\ell^{(y)} \\hat{U}_{\\ell,k} + \\hat{U}_{\\ell,k} \\lambda_k^{(x)} = \\hat{F}_{\\ell,k} $$\n$$ (\\lambda_\\ell^{(y)} + \\lambda_k^{(x)}) \\hat{U}_{\\ell,k} = \\hat{F}_{\\ell,k} $$\nThe solution for the transformed coefficients is thus:\n$$ \\hat{U}_{\\ell,k} = \\frac{\\hat{F}_{\\ell,k}}{\\lambda_\\ell^{(y)} + \\lambda_k^{(x)}} $$\n\n### Algorithmic Implementation\n\nThe solution process consists of the following steps:\n1.  Given the right-hand side grid function $F$, compute its 2D DST-I, $\\hat{F} = S_y F S_x$.\n2.  Construct a matrix of the eigenvalues of the 2D operator, $(\\Lambda_{2D})_{\\ell,k} = \\lambda_\\ell^{(y)} + \\lambda_k^{(x)}$.\n3.  Compute the transformed solution coefficients $\\hat{U}$ by element-wise division: $\\hat{U} = \\hat{F} ./ \\Lambda_{2D}$.\n4.  Compute the final solution $U$ by applying the inverse 2D DST-I to $\\hat{U}$, which for the orthonormal DST-I is the transform itself: $U = S_y \\hat{U} S_x$.\n\nThe 2D transforms are implemented as two passes of 1D transforms. As required, a permutation-based approach is used for cache efficiency. For an $N_y \\times N_x$ array `data`, the 2D transform is computed by:\n1.  Applying a 1D transform along the last axis (`axis=-1`).\n2.  Transposing the resulting matrix (`data.T`).\n3.  Applying the 1D transform again along the new last axis.\n4.  Transposing the result back.\n\nThis procedure will be implemented in helper functions `dst1_2d_permute` for the DST-I and `dct2_2d_permute` for the DCT-II.\n\nFor test cases $1$-$3$, the right-hand side $f_h$ is generated from a known exact solution $u$ using $f_h = -\\Delta_h u$. The discrete Laplacian $\\Delta_h$ is implemented by first padding the $N_y \\times N_x$ interior grid function $u$ with a layer of zeros to create an $(N_y+2) \\times (N_x+2)$ array, representing the homogeneous Dirichlet boundary conditions. The centered finite difference formula is then applied to this padded array to compute the Laplacian on the interior grid.\n\nFor test cases $4$ and $5$, the equivalence of the permutation-based 2D transform and a direct application of 1D transforms along `axis=1` then `axis=0` is checked to validate the implementation of the two-pass helpers.\n\nThe final numerical solution $\\tilde{u}$ is compared against the known exact discrete solution $u$ by computing the relative discrete $\\ell^2$ error: $\\frac{\\| \\tilde{u} - u \\|_2}{\\|u\\|_2}$. For the chosen exact solutions, which are eigenfunctions of the discrete operator, this error is expected to be near machine precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef discrete_laplacian(u, hx, hy):\n    \"\"\"\n    Computes the discrete Laplacian of an interior grid function u\n    with homogeneous Dirichlet boundary conditions.\n    \n    Args:\n        u (np.ndarray): A 2D numpy array of shape (Ny, Nx) representing the grid function.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n        \n    Returns:\n        np.ndarray: A 2D numpy array of shape (Ny, Nx) representing the discrete Laplacian of u.\n    \"\"\"\n    Ny, Nx = u.shape\n    u_padded = np.zeros((Ny + 2, Nx + 2))\n    u_padded[1:-1, 1:-1] = u\n    \n    lap_u = (u_padded[1:-1, 0:-2] - 2 * u_padded[1:-1, 1:-1] + u_padded[1:-1, 2:]) / (hx**2)\n    lap_u += (u_padded[0:-2, 1:-1] - 2 * u_padded[1:-1, 1:-1] + u_padded[2:, 1:-1]) / (hy**2)\n    \n    return lap_u\n\ndef dst1_2d_permute(data):\n    \"\"\"Computes 2D DST-I using 1D transforms on last axis with permutation.\"\"\"\n    temp = fft.dst(data, type=1, axis=-1, norm='ortho')\n    temp = fft.dst(temp.T, type=1, axis=-1, norm='ortho')\n    return temp.T\n\ndef dct2_2d_permute(data):\n    \"\"\"Computes 2D DCT-II using 1D transforms on last axis with permutation.\"\"\"\n    temp = fft.dct(data, type=2, axis=-1, norm='ortho')\n    temp = fft.dct(temp.T, type=2, axis=-1, norm='ortho')\n    return temp.T\n\ndef poisson_solve_dst(f_h, Lx, Ly):\n    \"\"\"\n    Solves the discrete Poisson equation -Delta_h u = f_h using the DST.\n    \n    Args:\n        f_h (np.ndarray): A 2D array of shape (Ny, Nx) for the right-hand side.\n        Lx (float): Length of the domain in x-direction.\n        Ly (float): Length of the domain in y-direction.\n        \n    Returns:\n        np.ndarray: The solution grid function u of shape (Ny, Nx).\n    \"\"\"\n    Ny, Nx = f_h.shape\n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    \n    f_hat = dst1_2d_permute(f_h)\n    \n    k = np.arange(1, Nx + 1).reshape(1, -1)\n    l = np.arange(1, Ny + 1).reshape(-1, 1)\n\n    lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * (Nx + 1)))**2\n    lambda_y = (4 / hy**2) * np.sin(l * np.pi / (2 * (Ny + 1)))**2\n    \n    lambda_2d = lambda_y + lambda_x\n    \n    u_hat = f_hat / lambda_2d\n    \n    u_solution = dst1_2d_permute(u_hat)\n    \n    return u_solution\n\ndef run_poisson_test(params):\n    \"\"\"Runs a single Poisson solver test case.\"\"\"\n    Nx, Ny, Lx, Ly, m, n = params\n    \n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    \n    # Handle the 1D case for meshgrid\n    if Nx == 1:\n        x = np.array([hx])\n    else:\n        x = np.arange(1, Nx + 1) * hx\n    \n    if Ny == 1:\n        y = np.array([hy])\n    else:\n        y = np.arange(1, Ny + 1) * hy\n        \n    xx, yy = np.meshgrid(x, y)\n    \n    u_exact = np.sin(m * np.pi * xx / Lx) * np.sin(n * np.pi * yy / Ly)\n\n    f_h = -discrete_laplacian(u_exact, hx, hy)\n    \n    u_tilde = poisson_solve_dst(f_h, Lx, Ly)\n    \n    norm_diff = np.linalg.norm(u_tilde - u_exact)\n    norm_exact = np.linalg.norm(u_exact)\n    \n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n        \n    return norm_diff / norm_exact\n\ndef test_dst_equivalence():\n    \"\"\"Tests equivalence of two methods for 2D DST-I.\"\"\"\n    np.random.seed(42)\n    A = np.random.rand(23, 17)\n    \n    res_permute = dst1_2d_permute(A)\n    \n    temp_direct = fft.dst(A, type=1, axis=1, norm='ortho')\n    res_direct = fft.dst(temp_direct, type=1, axis=0, norm='ortho')\n    \n    max_diff = np.max(np.abs(res_permute - res_direct))\n    return max_diff <= 1e-10\n\ndef test_dct_equivalence():\n    \"\"\"Tests equivalence of two methods for 2D DCT-II.\"\"\"\n    np.random.seed(42)\n    B = np.random.rand(16, 10)\n    \n    res_permute = dct2_2d_permute(B)\n    \n    temp_direct = fft.dct(B, type=2, axis=1, norm='ortho')\n    res_direct = fft.dct(temp_direct, type=2, axis=0, norm='ortho')\n    \n    max_diff = np.max(np.abs(res_permute - res_direct))\n    return max_diff <= 1e-10\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Poisson solver tests: (Nx, Ny, Lx, Ly, m, n)\n        (32, 20, 1.0, 1.0, 3, 5),\n        (29, 37, 2.0, 0.5, 2, 9),\n        (1, 17, 1.0, 1.0, 1, 7),\n    ]\n\n    results = []\n    \n    # Cases 1, 2, 3\n    for case_params in test_cases:\n        error = run_poisson_test(case_params)\n        results.append(error)\n        \n    # Case 4\n    results.append(test_dst_equivalence())\n    \n    # Case 5\n    results.append(test_dct_equivalence())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "To achieve full mastery, this final practice takes you under the hood of the transforms themselves and extends the methodology to different boundary conditions. You will implement the Discrete Sine and Cosine Transforms (DST/DCT) using the Fast Fourier Transform (FFT) and apply them to solve problems with both Dirichlet and Neumann boundaries. This exercise also provides a crucial lesson in numerical analysis by asking you to investigate and quantify the spectral leakage that occurs when non-periodic data is improperly handled .",
            "id": "3443474",
            "problem": "You are asked to implement discrete sine and cosine transforms realized via the Fast Fourier Transform (FFT) using symmetry-based extensions, and to use them to solve separable Poisson problems with homogeneous Dirichlet and homogeneous Neumann boundary conditions on the unit square. You must also quantify aliasing and spectral leakage when nonperiodic boundary data are embedded into a periodic FFT using either zero-padding or symmetry-respecting mirror extensions. Your implementation must be self-contained, based on first principles, and must not assume any specialized transform routine beyond the standard FFT.\n\nFundamental base:\n- Consider the one-dimensional second-order centered finite-difference approximation of the Laplacian on a uniform grid. For homogeneous Dirichlet boundary conditions, the one-dimensional discrete Laplacian on the interior grid has eigenvectors given by the sine basis and for homogeneous Neumann boundary conditions on a grid including endpoints it has eigenvectors given by the cosine basis. These are well-tested facts used in separation of variables for separable elliptic problems.\n- The discrete eigenvalues for the one-dimensional second-difference operator with homogeneous Dirichlet boundary conditions on an interior grid of size $N$ with spacing $h$ are\n$$\n\\lambda_k^{(D)} = \\frac{4}{h^2} \\sin^2\\!\\left(\\frac{\\pi k}{2\\,(N+1)}\\right), \\quad k=1,2,\\dots,N.\n$$\nFor homogeneous Neumann boundary conditions on a grid including endpoints with $N$ nodes and spacing $h$, the eigenvalues are\n$$\n\\lambda_k^{(N)} = \\frac{4}{h^2} \\sin^2\\!\\left(\\frac{\\pi k}{2\\,(N-1)}\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwith the zero mode $\\lambda_0^{(N)}=0$ corresponding to the constant nullspace.\n\nCore requirements to implement from these bases:\n- Implement the discrete sine transform of type I (DST-I) for vectors of length $N$ corresponding to interior Dirichlet data, using an odd mirror extension to a periodic sequence of length $M=2\\,(N+1)$ and the Fast Fourier Transform (FFT). Implement both forward and inverse transforms by constructing the appropriate extended sequence and extracting or assembling the relevant Fourier modes.\n- Implement the discrete cosine transform of type I (DCT-I) for vectors of length $N$ corresponding to data on a grid including endpoints for Neumann boundary conditions, using an even mirror extension to a periodic sequence of length $M=2\\,(N-1)$ and the FFT. Implement both forward and inverse transforms similarly.\n\nSeparable Poisson solvers to build:\n- Two-dimensional homogeneous Dirichlet Poisson problem on $(0,1)^2$:\n  - Let $N \\in \\mathbb{N}$ be the number of interior points per coordinate. Let $h=1/(N+1)$ and interior grid points $x_i=i\\,h$, $y_j=j\\,h$ for $i=1,\\dots,N$, $j=1,\\dots,N$.\n  - Solve the finite-difference discretization of\n  $$\n  \\Delta u(x,y) = f(x,y), \\quad u=0 \\text{ on } \\partial(0,1)^2,\n  $$\n  using a separable scheme diagonalized by two-dimensional DST-I. Use the one-dimensional eigenvalues $\\lambda_k^{(D)}$ to form the two-dimensional eigenvalues $\\lambda_{k_x}^{(D)}+\\lambda_{k_y}^{(D)}$ and divide the transformed right-hand side accordingly, then invert the transform.\n  - Test with the manufactured solution $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ so that $f(x,y)=-2\\,\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$. Report the relative discrete $\\ell^2$ error on the interior grid:\n  $$\n  \\frac{\\|u_h - u_{\\text{exact}}\\|_2}{\\|u_{\\text{exact}}\\|_2},\n  $$\n  where $\\|\\cdot\\|_2$ is the Euclidean norm on the grid values.\n\n- Two-dimensional homogeneous Neumann Poisson problem on $[0,1]^2$:\n  - Let $N \\in \\mathbb{N}$ be the number of grid points per coordinate including the boundary, with spacing $h=1/(N-1)$ and grid points $x_i=i\\,h$, $y_j=j\\,h$ for $i=0,\\dots,N-1$, $j=0,\\dots,N-1$.\n  - Solve the finite-difference discretization of\n  $$\n  \\Delta u(x,y) = f(x,y), \\quad \\partial_n u = 0 \\text{ on } \\partial[0,1]^2,\n  $$\n  using a separable scheme diagonalized by two-dimensional DCT-I. Use the one-dimensional eigenvalues $\\lambda_k^{(N)}$ to form the two-dimensional eigenvalues $\\lambda_{k_x}^{(N)}+\\lambda_{k_y}^{(N)}$. Handle the zero mode by enforcing zero-mean on the solution, i.e., set the $(k_x,k_y)=(0,0)$ coefficient to zero. Divide the transformed right-hand side accordingly and invert the transform.\n  - Test with the manufactured solution $u(x,y)=\\cos(2\\,\\pi x)+\\cos(2\\,\\pi y)$ so that $f(x,y)=-4\\,\\pi^2(\\cos(2\\,\\pi x)+\\cos(2\\,\\pi y))$. Report the relative discrete $\\ell^2$ error on the full grid after subtracting the spatial average from both numerical and exact solutions to resolve the constant nullspace:\n  $$\n  \\frac{\\| (u_h-\\overline{u_h}) - (u_{\\text{exact}}-\\overline{u_{\\text{exact}}}) \\|_2}{\\|u_{\\text{exact}}-\\overline{u_{\\text{exact}}}\\|_2}.\n  $$\n\nAliasing and leakage quantification via FFT embeddings:\n- Let $g(x)=e^x$ on $[0,1]$, sampled at the $N$ interior Dirichlet points $x_j=j\\,h$ with $h=1/(N+1)$ and $j=1,\\dots,N$. Consider two embeddings into a periodic sequence of length $M=2\\,(N+1)$ prior to FFT:\n  - Odd mirror extension (compatible with homogeneous Dirichlet boundaries): define an odd $2\\,(N+1)$-periodic sequence $y$ with $y[0]=0$, $y[j]=g(x_j)$ for $j=1,\\dots,N$, $y[N+1]=0$, and $y[N+1+\\ell]=-g(x_{N+1-\\ell})$ for $\\ell=1,\\dots,N$.\n  - Zero-padding extension: define $z$ with $z[j]=g(x_j)$ for $j=1,\\dots,N$ and $z[j]=0$ otherwise, for a total length $M=2\\,(N+1)$.\n- For each extension, compute the discrete Fourier transform and define the half-spectrum energy over indices $k=0,1,\\dots,N+1$,\n  $$\n  E_{\\text{half}} = \\sum_{k=0}^{N+1} |Y[k]|^2,\n  $$\n  and the energy in the sine-harmonic bins $k=1,2,\\dots,N$,\n  $$\n  E_{\\text{sine}} = \\sum_{k=1}^{N} |Y[k]|^2.\n  $$\n  Define the leakage ratio\n  $$\n  L = 1 - \\frac{E_{\\text{sine}}}{E_{\\text{half}}}.\n  $$\n  For the odd mirror extension, the ideal is $L \\approx 0$, while for zero-padding, $L$ should be significantly larger due to aliasing/leakage into non-sine bins.\n\nTest suite and required outputs:\n- Test $1$ (happy path, Dirichlet): $N=32$ for the two-dimensional Dirichlet Poisson problem described above; output a single floating-point number equal to the relative discrete $\\ell^2$ error.\n- Test $2$ (Neumann, nullspace handling): $N=33$ for the two-dimensional Neumann Poisson problem described above; output a single floating-point number equal to the relative discrete $\\ell^2$ error with mean removed.\n- Test $3$ (aliasing/leakage, boundary embedding): $N=64$ for the one-dimensional leakage experiment with $g(x)=e^x$; output a list of two floating-point numbers $[L_{\\text{mirror}}, L_{\\text{zeropad}}]$ in this order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results of Tests $1$–$3$ as a comma-separated list enclosed in square brackets, where the third entry is itself a list of two floating-point numbers. For example, a syntactically valid output shape is\n$$\n[\\text{err\\_D},\\text{err\\_N},[\\text{L\\_mirror},\\text{L\\_zeropad}]].\n$$\nNo units are involved in this problem, and any angles used internally must be in radians.",
            "solution": "The posed problem requires the implementation of fast Poisson solvers for Dirichlet and Neumann boundary conditions, based upon Discrete Sine and Cosine Transforms (DST/DCT) realized via the Fast Fourier Transform (FFT). The analysis further extends to quantifying spectral artifacts arising from different periodic embedding strategies. The solution is developed from first principles as stipulated.\n\n### 1. Fast Fourier Transform Realization of Sine and Cosine Transforms\n\nThe core of the fast solvers lies in the ability to diagonalize the discrete Laplacian operator using sinusoidal basis functions. The DST and DCT, which represent transformations into these bases, can be computed efficiently by embedding the data into a larger, symmetric sequence and applying the standard FFT.\n\n#### 1.1. Discrete Sine Transform Type I (DST-I)\n\nThe DST-I is associated with the eigenvectors of the second-order centered difference matrix for a function on an interior grid of size $N$ that is zero at the boundaries.\n\n**Forward Transform (DST-I):** For a data vector $u = (u_1, \\dots, u_N)$, the unnormalized DST-I is given by:\n$$\n\\hat{u}_k = \\sum_{j=1}^{N} u_j \\sin\\left(\\frac{\\pi j k}{N+1}\\right), \\quad k=1, \\dots, N\n$$\nTo compute this using an FFT, we construct an extended sequence $y$ of length $M=2(N+1)$ with odd symmetry. Let the input vector in the implementation be a zero-indexed array `u` of length $N$. The extended sequence `y` is:\n$$\ny_j =\n\\begin{cases}\n0 & j=0, N+1 \\\\\nu_{j-1} & j=1, \\dots, N \\\\\n-u_{N+1-j} & j=N+2, \\dots, 2N+1\n\\end{cases}\n$$\nThe FFT of this real, odd sequence $y$ results in a purely imaginary, conjugate anti-symmetric spectrum $Y_k$. The relationship to the DST-I sum is:\n$$\nY_k = \\text{FFT}(y)_k = \\sum_{j=0}^{M-1} y_j e^{-2\\pi i j k / M} = -2i \\sum_{j=1}^{N} u_j \\sin\\left(\\frac{\\pi j k}{N+1}\\right) = -2i \\, \\hat{u}_k\n$$\nTherefore, the forward DST-I coefficients can be extracted from the FFT result:\n$$\n\\hat{u}_k = -\\frac{1}{2} \\text{Im}(Y_k)\n$$\nwhere `u` in code is indexed $0, \\dots, N-1$ corresponding to physical points $1, \\dots, N$, and $\\hat{u}$ is indexed $0, \\dots, N-1$ corresponding to modes $k=1, \\dots, N$.\n\n**Inverse Transform (IDST-I):** The transform matrix for the DST-I, $S_{kj} = \\sin(\\frac{\\pi k j}{N+1})$, satisfies $S^2 = \\frac{N+1}{2}I$. This implies that the inverse transform is proportional to the forward transform: $S^{-1} = \\frac{2}{N+1}S$. Thus, the inverse DST-I can be implemented by applying the forward DST-I routine and scaling the result:\n$$\nu = \\text{IDST-I}(\\hat{u}) = \\frac{2}{N+1} \\text{DST-I}(\\hat{u})\n$$\nThis elegant property simplifies the implementation, as one core routine suffices for both forward and inverse transforms.\n\n#### 1.2. Discrete Cosine Transform Type I (DCT-I)\n\nThe DCT-I arises from the eigenvectors of the discrete Laplacian on a grid of size $N$ including endpoints, with homogeneous Neumann boundary conditions.\n\n**Forward Transform (DCT-I):** For data $u = (u_0, \\dots, u_{N-1})$, the unnormalized DCT-I is:\n$$\n\\hat{u}_k = u_0 + (-1)^k u_{N-1} + 2\\sum_{j=1}^{N-2} u_j \\cos\\left(\\frac{\\pi j k}{N-1}\\right), \\quad k=0, \\dots, N-1\n$$\nThis is computed via FFT by constructing an extended sequence $y$ of length $M=2(N-1)$ with even symmetry:\n$$\ny_j =\n\\begin{cases}\nu_j & j=0, \\dots, N-1 \\\\\nu_{2(N-1)-j} & j=N, \\dots, 2N-3\n\\end{cases}\n$$\nThe FFT of this real, even sequence $y$ yields a real, even spectrum $Y_k$, which corresponds exactly to the DCT-I coefficients:\n$$\nY_k = \\text{FFT}(y)_k = \\hat{u}_k\n$$\nThus, the forward DCT-I is simply the real part of the first $N$ components of the FFT of the extended sequence.\n\n**Inverse Transform (IDCT-I):** The forward transform maps the signal $u$ to the FFT coefficients $Y_k = \\text{FFT}(\\text{extend}(u))_k$. The inverse operation involves reconstructing the full FFT spectrum $Y$ from the $N$ DCT-I coefficients $\\hat{u}$ using even symmetry, and then applying the inverse FFT. Since `ifft(fft(y)) = y`, this process perfectly recovers the extended sequence $y$, from which the original data $u$ is extracted. No additional scaling is needed if using a standard `fft`/`ifft` pair where the inverse transform includes the $1/M$ normalization factor.\n\n### 2. Separable Poisson Solvers\n\nThe 2D Poisson equation $\\Delta u = f$ on a rectangular domain with separable boundary conditions can be solved efficiently by applying 1D transforms along each coordinate direction.\n\n#### 2.1. Homogeneous Dirichlet Problem\nThe problem is $\\Delta u = f$ on $(0,1)^2$ with $u=0$ on the boundary. The finite-difference approximation on an $N \\times N$ interior grid is $(L_x + L_y)U = F$, where $L_x$ and $L_y$ are 1D discrete Laplacian operators. The 2D DST-I diagonalizes this system. The algorithm is:\n1.  Compute the 2D DST-I of the source term matrix $F$: $\\hat{\\hat{F}} = \\text{DST2D}(F)$. This is done by applying the 1D DST-I to each column of $F$, then to each row of the result.\n2.  The transformed equation is algebraic: $\\Lambda_{k_x, k_y} \\hat{\\hat{U}}_{k_x, k_y} = \\hat{\\hat{F}}_{k_x, k_y}$. The eigenvalues of the 2D operator are sums of the 1D eigenvalues: $\\Lambda_{k_x, k_y} = \\lambda_{k_x}^{(D)} + \\lambda_{k_y}^{(D)}$.\n3.  Solve for the transformed solution: $\\hat{\\hat{U}}_{k_x, k_y} = \\hat{\\hat{F}}_{k_x, k_y} / \\Lambda_{k_x, k_y}$.\n4.  Compute the solution $U$ by applying the 2D inverse DST-I: $U = \\text{IDST2D}(\\hat{\\hat{U}})$.\n\n#### 2.2. Homogeneous Neumann Problem\nThe problem is $\\Delta u = f$ on $[0,1]^2$ with $\\partial_n u = 0$ on the boundary. A solution exists only if the compatibility condition $\\int f dA = 0$ is met. The solution is unique only up to an additive constant. The 2D DCT-I diagonalizes the discrete system.\n1.  Compute the 2D DCT-I of the source matrix $F$: $\\hat{\\hat{F}} = \\text{DCT2D}(F)$.\n2.  The eigenvalue $\\Lambda_{0,0} = \\lambda_0^{(N)} + \\lambda_0^{(N)} = 0$. This corresponds to the constant nullspace.\n3.  Solve for the transformed solution, handling the zero mode:\n    $$\n    \\hat{\\hat{U}}_{k_x, k_y} =\n    \\begin{cases}\n    0 & (k_x,k_y)=(0,0) \\\\\n    \\hat{\\hat{F}}_{k_x, k_y} / \\Lambda_{k_x, k_y} & \\text{otherwise}\n    \\end{cases}\n    $$\n    Setting $\\hat{\\hat{U}}_{0,0} = 0$ enforces that the solution $U$ has a zero spatial mean. The compatibility condition ensures $\\hat{\\hat{F}}_{0,0} = \\sum F_{ij} \\approx 0$.\n4.  Compute the solution $U$ by applying the 2D inverse DCT-I: $U = \\text{IDCT2D}(\\hat{\\hat{U}})$.\n\n### 3. Aliasing and Leakage Quantification\n\nWhen a non-periodic signal is analyzed with a DFT/FFT, which assumes periodicity, spectral energy \"leaks\" from the signal's true frequencies into other frequency bins. This is a form of aliasing.\n- **Symmetry-Respecting Extension**: For a signal $g(x_j)$ that is to be represented by a sine series (implying $g(0)=0, g(1)=0$), an odd mirror extension creates a signal that is smooth (in a periodic sense) and whose energy is concentrated in the sine-related frequency bins of the FFT. The leakage ratio $L$ should be close to $0$.\n- **Zero-Padding Extension**: Embedding the signal in an array of zeros creates sharp discontinuities at the signal's endpoints. The FFT of this signal exhibits significant spectral leakage into all frequency bins, as a large number of sinusoids are needed to represent the discontinuities. The leakage ratio $L$ will be significantly greater than $0$.\nThe leakage ratio $L = 1 - E_{\\text{sine}} / E_{\\text{half}}$ quantifies the fraction of energy outside the target (sine) harmonic bins.\n\nThe provided test cases are now executed using these principles.\n- **Test 1**: Solves the Dirichlet problem with $N=32$.\n- **Test 2**: Solves the Neumann problem with $N=33$.\n- **Test 3**: Computes leakage ratios for $g(x)=e^x$ with $N=64$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests fast Poisson solvers and spectral analysis\n    based on custom FFT-based Discrete Sine and Cosine Transforms.\n    \"\"\"\n\n    # =========================================================================\n    # Part 1: Discrete Sine/Cosine Transforms via FFT\n    # =========================================================================\n\n    def dst1(u):\n        \"\"\"\n        Computes the Discrete Sine Transform of type I (DST-I).\n        The unnormalized DST-I sum is Sum[u_j * sin(pi*(j+1)*(k+1)/(N+1))].\n        This implementation returns DST-I_sum(u).\n        \"\"\"\n        N = len(u)\n        M = 2 * (N + 1)\n        y = np.zeros(M)\n        y[1:N + 1] = u\n        y[N + 2:] = -u[::-1]\n        \n        Y_fft = np.fft.fft(y)\n        \n        # From derivation, Y_k = -2i * DST_I_sum(u)_k.\n        # We extract the coefficients for k=1,...,N.\n        return -np.imag(Y_fft[1:N + 1]) / 2.0\n\n    def idst1(u_hat):\n        \"\"\"\n        Computes the Inverse Discrete Sine Transform of type I (IDST-I).\n        The transform matrix S for DST-I satisfies S^2 = (N+1)/2 * I.\n        Thus, S_inv = (2/(N+1)) * S.\n        \"\"\"\n        N = len(u_hat)\n        # Apply the forward transform and scale appropriately.\n        return dst1(u_hat) * 2.0 / (N + 1)\n\n    def dct1(u):\n        \"\"\"\n        Computes the Discrete Cosine Transform of type I (DCT-I).\n        This is implemented via an even extension and FFT.\n        \"\"\"\n        N = len(u)\n        M = 2 * (N - 1)\n        y = np.zeros(M)\n        y[0:N] = u\n        y[N:] = u[1:N - 1][::-1]\n        \n        Y_fft = np.fft.fft(y)\n        \n        # The DCT-I coefficients are the real part of the FFT of this sequence.\n        return np.real(Y_fft[0:N])\n\n    def idct1(u_hat):\n        \"\"\"\n        Computes the Inverse Discrete Cosine Transform of type I (IDCT-I).\n        This is the exact inverse of the dct1 function implemented above.\n        \"\"\"\n        N = len(u_hat)\n        M = 2 * (N - 1)\n        # Reconstruct the full, even FFT spectrum from DCT-I coeffs.\n        Y_hat = np.zeros(M, dtype=complex)\n        Y_hat[0:N] = u_hat\n        Y_hat[N:] = u_hat[1:N-1][::-1]\n        \n        # The inverse FFT recovers the extended signal.\n        y_reco = np.fft.ifft(Y_hat)\n        \n        # Return the first N points, which is the original signal.\n        return np.real(y_reco[0:N])\n\n    # --- 2D Transform Wrappers ---\n    def dst2(F):\n        F_hat = np.apply_along_axis(dst1, 0, F)\n        return np.apply_along_axis(dst1, 1, F_hat)\n\n    def idst2(F_hat):\n        F_cols = np.apply_along_axis(idst1, 1, F_hat)\n        return np.apply_along_axis(idst1, 0, F_cols)\n\n    def dct2(F):\n        F_hat = np.apply_along_axis(dct1, 0, F)\n        return np.apply_along_axis(dct1, 1, F_hat)\n\n    def idct2(F_hat):\n        F_cols = np.apply_along_axis(idct1, 1, F_hat)\n        return np.apply_along_axis(idct1, 0, F_cols)\n\n    # =========================================================================\n    # Part 2: Poisson Solvers and Leakage Analysis\n    # =========================================================================\n    \n    def solve_poisson_dirichlet(N):\n        \"\"\"Test Case 1: 2D Dirichlet Poisson problem.\"\"\"\n        h = 1.0 / (N + 1)\n        x = np.arange(1, N + 1) * h\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_exact = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n        f_rhs = -2.0 * np.pi**2 * u_exact\n\n        k = np.arange(1, N + 1)\n        lambda_d = (4.0 / h**2) * np.sin(np.pi * k / (2.0 * (N + 1)))**2\n        Lambda_2d = lambda_d[:, None] + lambda_d[None, :]\n\n        f_hat = dst2(f_rhs)\n        u_hat = f_hat / Lambda_2d\n        u_h = idst2(u_hat)\n\n        error = np.linalg.norm(u_h - u_exact) / np.linalg.norm(u_exact)\n        return error\n\n    def solve_poisson_neumann(N):\n        \"\"\"Test Case 2: 2D Neumann Poisson problem.\"\"\"\n        h = 1.0 / (N - 1)\n        x = np.arange(0, N) * h\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_exact = np.cos(2 * np.pi * xx) + np.cos(2 * np.pi * yy)\n        f_rhs = -4.0 * np.pi**2 * u_exact\n\n        k = np.arange(0, N)\n        lambda_n = (4.0 / h**2) * np.sin(np.pi * k / (2.0 * (N - 1)))**2\n        Lambda_2d = lambda_n[:, None] + lambda_n[None, :]\n\n        f_hat = dct2(f_rhs)\n        u_hat = np.zeros_like(f_hat)\n        \n        non_zero_mode = Lambda_2d != 0\n        u_hat[non_zero_mode] = f_hat[non_zero_mode] / Lambda_2d[non_zero_mode]\n        u_hat[0, 0] = 0.0\n\n        u_h = idct2(u_hat)\n\n        u_h_mean_removed = u_h - np.mean(u_h)\n        u_exact_mean_removed = u_exact - np.mean(u_exact)\n        \n        norm_u_exact_mean_removed = np.linalg.norm(u_exact_mean_removed)\n        if norm_u_exact_mean_removed == 0:\n            return 0.0\n        \n        error = np.linalg.norm(u_h_mean_removed - u_exact_mean_removed) / norm_u_exact_mean_removed\n        return error\n\n    def quantify_leakage(N):\n        \"\"\"Test Case 3: Spectral leakage analysis.\"\"\"\n        h = 1.0 / (N + 1)\n        x_grid = np.arange(1, N + 1) * h\n        g_data = np.exp(x_grid)\n        \n        M = 2 * (N + 1)\n        \n        # Odd mirror extension\n        y_mirror = np.zeros(M)\n        y_mirror[1:N + 1] = g_data\n        y_mirror[N + 2:] = -g_data[::-1]\n        Y_mirror = np.fft.fft(y_mirror)\n        \n        E_half_mirror = np.sum(np.abs(Y_mirror[0:N + 2])**2)\n        E_sine_mirror = np.sum(np.abs(Y_mirror[1:N + 1])**2)\n        L_mirror = 1.0 - E_sine_mirror / E_half_mirror if E_half_mirror != 0 else 0.0\n\n        # Zero-padding extension\n        y_zeropad = np.zeros(M)\n        y_zeropad[1:N + 1] = g_data\n        Y_zeropad = np.fft.fft(y_zeropad)\n\n        E_half_zeropad = np.sum(np.abs(Y_zeropad[0:N + 2])**2)\n        E_sine_zeropad = np.sum(np.abs(Y_zeropad[1:N + 1])**2)\n        L_zeropad = 1.0 - E_sine_zeropad / E_half_zeropad if E_half_zeropad != 0 else 0.0\n        \n        return [L_mirror, L_zeropad]\n\n    # =========================================================================\n    # Part 3: Execute Test Suite and Format Output\n    # =========================================================================\n    \n    test_cases = [\n        # (function, parameter)\n        (solve_poisson_dirichlet, 32),\n        (solve_poisson_neumann, 33),\n        (quantify_leakage, 64)\n    ]\n\n    results = []\n    for func, param in test_cases:\n        result = func(param)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    err_D, err_N, leakage_ratios = results\n    print(f\"[{err_D},{err_N},[{leakage_ratios[0]},{leakage_ratios[1]}]]\")\n\nsolve()\n\n```"
        }
    ]
}