{
    "hands_on_practices": [
        {
            "introduction": "辛几何性质是几何积分算法的核心。检验一个数值方法是否辛，最直接的方式就是将其应用于一个简单的哈密顿系统，并根据辛映射的定义进行代数验证。通过将这个基本定义应用于像显式欧拉法这样常见但非辛的方法，我们可以具体地理解它为何会破坏哈密顿系统的相流结构，从而揭示开发保结构算法的必要性。",
            "id": "3451935",
            "problem": "考虑一个二维典范哈密顿系统，其相矢量为 $y = (q,p)^{\\top}$，标准辛矩阵为 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。一个步长为 $h$ 的单步法，记作 $\\Psi_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$，如果其雅可比矩阵满足雅可比约束 $D\\Psi_h(y)^{\\top} J D\\Psi_h(y) = J$ 对所有 $y$ 成立，则称该方法是辛的。从可分离二次哈密顿量 $H(q,p) = \\tfrac{1}{2}(p^2 + q^2)$ 的哈密顿正则方程出发，推导显式欧拉单步映射 $\\Psi_h$ 及其雅可比矩阵。然后，仅使用辛性的定义和基础线性代数，证明存在一个标量因子 $\\lambda(h)$，使得对于该方法有 $D\\Psi_h(y)^{\\top} J D\\Psi_h(y) = \\lambda(h)\\, J$。以 $h$ 的符号表达式的形式计算 $\\lambda(h)$ 的闭式解，并用它来确定显式欧拉法在 $h$ 非零时是否满足辛性约束。将最终答案以 $\\lambda(h)$ 的单一符号表达式形式给出，不带单位。不需要数值取整。",
            "solution": "对问题陈述的有效性进行严格评估。\n\n**第1步：提取已知条件**\n- **系统：**一个二维典范哈密顿系统。\n- **相矢量：**$y = (q,p)^{\\top}$。\n- **辛矩阵：**$J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。\n- **单步法：**$\\Psi_h: \\mathbb{R}^2 \\to \\mathbb{R}^2$，步长为 $h$。\n- **辛性条件：**如果一个方法的雅可比矩阵 $D\\Psi_h(y)$ 满足 $D\\Psi_h(y)^{\\top} J D\\Psi_h(y) = J$ 对所有 $y$ 成立，则该方法是辛的。\n- **哈密顿量：**$H(q,p) = \\frac{1}{2}(p^2 + q^2)$。\n- **待分析方法：**显式欧拉法。\n- **任务：**\n    1. 推导显式欧拉单步映射 $\\Psi_h$ 及其雅可比矩阵 $D\\Psi_h(y)$。\n    2. 证明存在某个标量 $\\lambda(h)$，使得 $D\\Psi_h(y)^{\\top} J D\\Psi_h(y) = \\lambda(h) J$。\n    3. 计算 $\\lambda(h)$ 的闭式表达式。\n    4. 使用 $\\lambda(h)$ 判断当 $h \\neq 0$ 时，显式欧拉法是否是辛的。\n- **最终答案要求：**提供 $\\lambda(h)$ 的单一符号表达式。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：**该问题坚实地植根于经典力学（哈密顿系统）和数值分析（常微分方程的数值解，特别是几何积分）领域。简谐振子的哈密顿量、显式欧拉法以及辛映射的定义都是标准且公认的概念。\n- **适定性：**该问题是适定的。它提供了一个特定的哈密顿量和一个特定的数值积分器，并要求一个清晰、可推导的数学性质（$\\lambda(h)$ 的值）。所有必要信息都已给出，足以得出一个唯一解。\n- **客观性：**该问题以精确、客观的数学语言陈述，没有任何主观论断。\n\n**第3步：结论与行动**\n该问题在科学上是合理的、适定的、客观的且自洽的。这是数值分析中的一个有效练习。因此，将推导其解。\n\n第一步是使用哈密顿正则方程从给定的哈密顿量 $H(q,p) = \\frac{1}{2}(p^2 + q^2)$ 推导出常微分方程组：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} \\\\\n\\dot{p} = -\\frac{\\partial H}{\\partial q}\n$$\n计算 $H$ 的偏导数：\n$$\n\\frac{\\partial H}{\\partial p} = p \\\\\n\\frac{\\partial H}{\\partial q} = q\n$$\n将这些代入哈密顿方程，得到方程组：\n$$\n\\dot{q} = p \\\\\n\\dot{p} = -q\n$$\n以矢量形式，令 $y = (q,p)^{\\top}$，该系统可写作 $\\dot{y} = f(y)$，其中 $f(y) = \\begin{pmatrix} p \\\\ -q \\end{pmatrix}$。\n\n接下来，我们将显式欧拉法应用于该系统。对于初值问题 $\\dot{y} = f(y)$，显式欧拉法由递推关系 $y_{n+1} = y_n + h f(y_n)$ 给出，其中 $h$ 是步长。单步映射 $\\Psi_h$ 定义为 $y_{n+1} = \\Psi_h(y_n)$。令 $y = (q,p)^{\\top}$。因此，映射 $\\Psi_h$ 为：\n$$\n\\Psi_h(y) = y + h f(y) = \\begin{pmatrix} q \\\\ p \\end{pmatrix} + h \\begin{pmatrix} p \\\\ -q \\end{pmatrix} = \\begin{pmatrix} q + hp \\\\ p - hq \\end{pmatrix}\n$$\n这就是应用于给定哈密顿系统的显式欧拉法的单步映射的显式形式。\n\n下一步是计算此映射的雅可比矩阵 $D\\Psi_h(y)$。$\\Psi_h(y)$ 的分量是 $\\Psi_{h,1}(q,p) = q + hp$ 和 $\\Psi_{h,2}(q,p) = p - hq$。雅可比矩阵为：\n$$\nD\\Psi_h(y) = \\begin{pmatrix} \\frac{\\partial \\Psi_{h,1}}{\\partial q}  \\frac{\\partial \\Psi_{h,1}}{\\partial p} \\\\ \\frac{\\partial \\Psi_{h,2}}{\\partial q}  \\frac{\\partial \\Psi_{h,2}}{\\partial p} \\end{pmatrix}\n$$\n计算偏导数：\n$$\n\\frac{\\partial}{\\partial q}(q + hp) = 1 \\\\\n\\frac{\\partial}{\\partial p}(q + hp) = h \\\\\n\\frac{\\partial}{\\partial q}(p - hq) = -h \\\\\n\\frac{\\partial}{\\partial p}(p - hq) = 1\n$$\n因此，雅可比矩阵是常数，由下式给出：\n$$\nD\\Psi_h(y) = M = \\begin{pmatrix} 1  h \\\\ -h  1 \\end{pmatrix}\n$$\n为了检验辛性，我们必须计算乘积 $M^{\\top} J M$。$M$ 的转置是：\n$$\nM^{\\top} = \\begin{pmatrix} 1  -h \\\\ h  1 \\end{pmatrix}\n$$\n现在，我们进行矩阵乘法。首先，我们计算 $M^{\\top}J$：\n$$\nM^{\\top}J = \\begin{pmatrix} 1  -h \\\\ h  1 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} = \\begin{pmatrix} (1)(0) + (-h)(-1)  (1)(1) + (-h)(0) \\\\ (h)(0) + (1)(-1)  (h)(1) + (1)(0) \\end{pmatrix} = \\begin{pmatrix} h  1 \\\\ -1  h \\end{pmatrix}\n$$\n接下来，将此结果乘以 $M$：\n$$\n(M^{\\top}J)M = \\begin{pmatrix} h  1 \\\\ -1  h \\end{pmatrix} \\begin{pmatrix} 1  h \\\\ -h  1 \\end{pmatrix} = \\begin{pmatrix} (h)(1) + (1)(-h)  (h)(h) + (1)(1) \\\\ (-1)(1) + (h)(-h)  (-1)(h) + (h)(1) \\end{pmatrix}\n$$\n化简各项可得：\n$$\nM^{\\top} J M = \\begin{pmatrix} h - h  h^2 + 1 \\\\ -1 - h^2  -h + h \\end{pmatrix} = \\begin{pmatrix} 0  1+h^2 \\\\ -(1+h^2)  0 \\end{pmatrix}\n$$\n我们可以提出标量项 $(1+h^2)$：\n$$\n\\begin{pmatrix} 0  1+h^2 \\\\ -(1+h^2)  0 \\end{pmatrix} = (1+h^2) \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} = (1+h^2)J\n$$\n此结果的形式为 $\\lambda(h)J$，其中标量因子是 $\\lambda(h) = 1+h^2$。\n\n一个方法是辛方法的条件是其雅可比矩阵 $M$ 必须满足 $M^{\\top} J M = J$。在我们的例子中，这要求 $\\lambda(h) = 1$。\n令我们推导出的 $\\lambda(h)$ 表达式等于 $1$：\n$$\n1+h^2 = 1\n$$\n这意味着 $h^2 = 0$，这仅在 $h=0$ 时成立。对于任何非零步长 $h \\neq 0$，我们有 $h^2 > 0$，因此 $\\lambda(h) = 1+h^2 > 1$。所以，对于任何非零步长，显式欧拉法对该系统不是辛的。问题要求给出 $\\lambda(h)$ 的闭式符号表达式。\n\n推导出的表达式是 $\\lambda(h) = 1+h^2$。",
            "answer": "$$\n\\boxed{1+h^2}\n$$"
        },
        {
            "introduction": "在理解了辛方法的定义之后，下一步是探究其性质和影响。一个常见的误解是认为辛积分器能够精确地保持能量守恒。本练习旨在澄清这一点，通过对比一个真正保持能量的离散梯度法（平均向量场法）和一个经典的辛方法（隐式中点法），深刻揭示辛方法所保持的是一个“修正哈密顿量”而非原始哈密顿量，这对于理解几何积分的长期行为至关重要。",
            "id": "3451940",
            "problem": "考虑一个由哈密顿偏微分方程 (PDE) 的空间半离散化产生的单自由度正则哈密顿系统，其正则变量为 $q$ 和 $p$，常值辛矩阵为 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$，三次哈密顿量为\n$$\nH(q,p) = \\frac{1}{2} p^{2} + \\frac{1}{3} q^{3}.\n$$\n连续时间动力学由哈密顿常微分方程 $y'(t) = J \\nabla H(y(t))$ 给出，其中 $y = (q,p)^{\\top}$。\n\n考虑使用时间步长 $h  0$ 从 $(q_{n},p_{n})$ 步进到 $(q_{n+1},p_{n+1})$ 的两种时间离散化方法：\n- 平均向量场 (AVF) 方法，定义为\n$$\ny_{n+1} = y_{n} + h \\, J \\int_{0}^{1} \\nabla H\\big((1-\\xi) y_{n} + \\xi \\, y_{n+1}\\big) \\, d\\xi,\n$$\n其中 $y_{n} = (q_{n},p_{n})^{\\top}$ 且 $y_{n+1} = (q_{n+1},p_{n+1})^{\\top}$。\n- 隐式中点法，定义为\n$$\ny_{n+1} = y_{n} + h \\, J \\nabla H\\!\\left(\\frac{y_{n} + y_{n+1}}{2}\\right).\n$$\n\n仅使用正则哈密顿结构 $y' = J \\nabla H(y)$ 以及 AVF 方法和隐式中点法的定义性质，完成以下任务：\n1. 对给定的三次哈密顿量 $H(q,p)$，推导两种方法的分量形式。\n2. 证明 AVF 方法精确保守哈密顿量，即对于给定的 $H(q,p)$，有 $H(y_{n+1}) = H(y_{n})$。\n3. 对于隐式中点法，推导精确的代数单步更新，并计算精确的单步能量变化\n$$\n\\Delta H_{\\mathrm{mid}}(q_{n},p_{n};h) := H(q_{n+1},p_{n+1}) - H(q_{n},p_{n})\n$$\n将其表示为关于 $q_{n}$、$p_{n}$ 和 $h$ 的闭式符号表达式。\n\n比较两种方法所保守的不变量，并给出 $\\Delta H_{\\mathrm{mid}}(q_{n},p_{n};h)$ 的精确表达式。你的最终答案必须是关于 $q_{n}$、$p_{n}$ 和 $h$ 的单个闭式解析表达式。如果你为了解释近似守恒性而进行了任何级数展开，请不要进行舍入；然而，最终报告的表达式必须是精确的，而不是近似值。不需要物理单位，最终表达式中也不要包含任何单位。",
            "solution": "该问题是有效的。它提法适定，在几何数值积分领域具有科学依据，并包含了严格求解所需的所有必要信息。\n\n该问题研究了用于单自由度哈密顿系统的两种数值积分器。系统状态由向量 $y = (q,p)^{\\top}$ 描述。哈密顿量由下式给出\n$$\nH(q,p) = \\frac{1}{2} p^{2} + \\frac{1}{3} q^{3}.\n$$\n哈密顿量的梯度 $\\nabla H = (\\frac{\\partial H}{\\partial q}, \\frac{\\partial H}{\\partial p})^{\\top}$ 为\n$$\n\\nabla H(q,p) = \\begin{pmatrix} q^2 \\\\ p \\end{pmatrix}.\n$$\n连续时间动力学由哈密顿方程 $y'(t) = J \\nabla H(y(t))$ 控制，其中 $J$ 是标准辛矩阵 $J = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。这给出了分量形式的方程 $q' = p$ 和 $p' = -q^2$。\n\n### 1. 数值方法的分量形式\n\n我们推导平均向量场 (AVF) 方法和隐式中点法在一个时间步长 $h$ 内将解从 $y_n = (q_n, p_n)^{\\top}$ 推进到 $y_{n+1} = (q_{n+1}, p_{n+1})^{\\top}$ 的分量形式。\n\n**平均向量场 (AVF) 方法**\n\nAVF 方法定义为\n$$\ny_{n+1} - y_{n} = h \\, J \\int_{0}^{1} \\nabla H\\big((1-\\xi) y_{n} + \\xi \\, y_{n+1}\\big) \\, d\\xi.\n$$\n设 $y_{\\xi} = (1-\\xi) y_{n} + \\xi \\, y_{n+1}$。其分量为 $q_{\\xi} = (1-\\xi)q_n + \\xi q_{n+1}$ 和 $p_{\\xi} = (1-\\xi)p_n + \\xi p_{n+1}$。\n我们必须计算梯度 $\\nabla H(y_\\xi) = (q_\\xi^2, p_\\xi)^{\\top}$ 的积分：\n$p$-分量的积分为：\n$$\n\\int_0^1 (p_n + \\xi(p_{n+1}-p_n)) d\\xi = \\left[p_n \\xi + \\frac{\\xi^2}{2}(p_{n+1}-p_n)\\right]_0^1 = p_n + \\frac{1}{2}(p_{n+1}-p_n) = \\frac{p_n+p_{n+1}}{2}.\n$$\n$q$-分量的积分为：\n$$\n\\int_{0}^{1} q_{\\xi}^2 \\, d\\xi = \\int_{0}^{1} \\big( (1-\\xi)q_n + \\xi q_{n+1} \\big)^2 \\, d\\xi.\n$$\n使用恒等式 $\\int_0^1 ((1-\\xi)a+\\xi b)^2 d\\xi = \\frac{1}{3}(a^2+ab+b^2)$，我们得到：\n$$\n\\int_{0}^{1} q_{\\xi}^2 \\, d\\xi = \\frac{1}{3}(q_n^2 + q_n q_{n+1} + q_{n+1}^2).\n$$\n因此，AVF 的向量形式更新为\n$$\n\\begin{pmatrix} q_{n+1} - q_n \\\\ p_{n+1} - p_n \\end{pmatrix} = h \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{3}(q_n^2 + q_n q_{n+1} + q_{n+1}^2) \\\\ \\frac{1}{2}(p_n + p_{n+1}) \\end{pmatrix}.\n$$\nAVF 方法的分量形式为：\n$$\nq_{n+1} - q_n = h \\frac{p_n + p_{n+1}}{2}\n$$\n$$\np_{n+1} - p_n = -h \\frac{1}{3}(q_n^2 + q_n q_{n+1} + q_{n+1}^2)\n$$\n\n**隐式中点法**\n\n隐式中点法定义为\n$$\ny_{n+1} - y_{n} = h \\, J \\nabla H\\left(\\frac{y_{n} + y_{n+1}}{2}\\right).\n$$\n梯度的自变量是中点状态 $(\\frac{q_n+q_{n+1}}{2}, \\frac{p_n+p_{n+1}}{2})$。\n在中点处计算的梯度为\n$$\n\\nabla H\\left(\\frac{y_{n} + y_{n+1}}{2}\\right) = \\begin{pmatrix} \\left(\\frac{q_n+q_{n+1}}{2}\\right)^2 \\\\ \\frac{p_n+p_{n+1}}{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4}(q_n+q_{n+1})^2 \\\\ \\frac{1}{2}(p_n+p_{n+1}) \\end{pmatrix}.\n$$\n向量形式的更新为\n$$\n\\begin{pmatrix} q_{n+1} - q_n \\\\ p_{n+1} - p_n \\end{pmatrix} = h \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{4}(q_n+q_{n+1})^2 \\\\ \\frac{1}{2}(p_n+p_{n+1}) \\end{pmatrix}.\n$$\n隐式中点法的分量形式为：\n$$\nq_{n+1} - q_n = h \\frac{p_n + p_{n+1}}{2}\n$$\n$$\np_{n+1} - p_n = -h \\frac{1}{4}(q_n + q_{n+1})^2\n$$\n\n### 2. AVF 方法的能量守恒证明\n\n我们证明 AVF 方法精确保守哈密顿量，即 $H(y_{n+1}) = H(y_n)$。\n设 $y(\\xi) = (1-\\xi)y_n + \\xi y_{n+1}$ 为连接 $y_n$ 和 $y_{n+1}$ 的线段。根据曲线积分的基本定理，哈密顿量的变化为\n$$\nH(y_{n+1}) - H(y_n) = \\int_0^1 \\frac{d}{d\\xi}H(y(\\xi)) \\,d\\xi.\n$$\n使用链式法则，$\\frac{d}{d\\xi}H(y(\\xi)) = \\nabla H(y(\\xi))^{\\top} \\frac{dy(\\xi)}{d\\xi} = \\nabla H(y(\\xi))^{\\top} (y_{n+1}-y_n)$。\n所以，\n$$\nH(y_{n+1}) - H(y_n) = \\int_0^1 \\nabla H(y(\\xi))^{\\top} (y_{n+1}-y_n) \\,d\\xi.\n$$\n由于 $(y_{n+1}-y_n)$ 相对于 $\\xi$ 是常数，可以将其移到积分号外：\n$$\nH(y_{n+1}) - H(y_n) = \\left( \\int_0^1 \\nabla H(y(\\xi)) \\,d\\xi \\right)^{\\top} (y_{n+1}-y_n).\n$$\n让我们定义平均梯度向量 $V = \\int_0^1 \\nabla H(y(\\xi)) \\,d\\xi$。AVF 方法的定义是 $y_{n+1}-y_n = hJV$。将此代入上式可得\n$$\nH(y_{n+1}) - H(y_n) = V^{\\top} (hJV) = h V^{\\top} J V.\n$$\n矩阵 $J$ 是斜对称的，即 $J^{\\top} = -J$。对于任何向量 $V$，二次型 $V^{\\top}JV$ 恒为零：\n$V^{\\top}JV = (V^{\\top}JV)^{\\top} = V^{\\top}J^{\\top}V = V^{\\top}(-J)V = -V^{\\top}JV$。\n这意味着 $2V^{\\top}JV = 0$，所以 $V^{\\top}JV = 0$。\n因此，\n$$\nH(y_{n+1}) - H(y_n) = h \\cdot 0 = 0.\n$$\n这表明 AVF 方法精确保守任何可微的哈密顿量 $H(y)$，因此它也保守给定的三次哈密顿量。\n\n### 3. 隐式中点法的能量变化\n\n我们推导精确的单步能量变化 $\\Delta H_{\\mathrm{mid}}(q_{n},p_{n};h) = H(q_{n+1},p_{n+1}) - H(q_{n},p_{n})$。\n$$\n\\Delta H_{\\mathrm{mid}} = \\left(\\frac{1}{2} p_{n+1}^{2} + \\frac{1}{3} q_{n+1}^{3}\\right) - \\left(\\frac{1}{2} p_{n}^{2} + \\frac{1}{3} q_{n}^{3}\\right)\n$$\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{1}{2} (p_{n+1}^2 - p_n^2) + \\frac{1}{3} (q_{n+1}^3 - q_n^3) = \\frac{1}{2} (p_{n+1}-p_n)(p_{n+1}+p_n) + \\frac{1}{3} (q_{n+1}-q_n)(q_n^2+q_n q_{n+1}+q_{n+1}^2).\n$$\n代入中点法的更新规则：\n$p_{n+1}-p_n = -h \\frac{1}{4}(q_n+q_{n+1})^2$ 和 $q_{n+1}-q_n = h \\frac{p_n+p_{n+1}}{2}$。\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{1}{2} \\left( -h \\frac{(q_n+q_{n+1})^2}{4} \\right) (p_n+p_{n+1}) + \\frac{1}{3} \\left( h \\frac{p_n+p_{n+1}}{2} \\right) (q_n^2+q_n q_{n+1}+q_{n+1}^2)\n$$\n提取公因式 $\\frac{h}{2}(p_n+p_{n+1})$：\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{h}{2}(p_n+p_{n+1}) \\left[ -\\frac{(q_n+q_{n+1})^2}{4} + \\frac{q_n^2+q_n q_{n+1}+q_{n+1}^2}{3} \\right].\n$$\n化简方括号中的表达式：\n$$\n-\\frac{1}{4}(q_n^2+2q_n q_{n+1}+q_{n+1}^2) + \\frac{1}{3}(q_n^2+q_n q_{n+1}+q_{n+1}^2) = \\left(-\\frac{1}{4}+\\frac{1}{3}\\right)q_n^2 + \\left(-\\frac{2}{4}+\\frac{1}{3}\\right)q_n q_{n+1} + \\left(-\\frac{1}{4}+\\frac{1}{3}\\right)q_{n+1}^2\n$$\n$$\n= \\frac{1}{12}q_n^2 - \\frac{1}{6}q_n q_{n+1} + \\frac{1}{12}q_{n+1}^2 = \\frac{1}{12}(q_n^2-2q_n q_{n+1}+q_{n+1}^2) = \\frac{1}{12}(q_{n+1}-q_n)^2.\n$$\n将此结果代回得到：\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{h}{2}(p_n+p_{n+1}) \\left[ \\frac{1}{12}(q_{n+1}-q_n)^2 \\right].\n$$\n现在，代入 $q_{n+1}-q_n = h \\frac{p_n+p_{n+1}}{2}$：\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{h(p_n+p_{n+1})}{24} \\left( h \\frac{p_n+p_{n+1}}{2} \\right)^2 = \\frac{h^3}{96}(p_n+p_{n+1})^3.\n$$\n为了得到关于 $(q_n, p_n, h)$ 的最终表达式，我们必须解出 $P = p_n+p_{n+1}$。根据两个更新方程，我们有 $q_{n+1} = q_n + \\frac{h}{2}P$ 和 $p_{n+1} = p_n - \\frac{h}{4}(q_n+q_{n+1})^2$。代入 $p_{n+1}=P-p_n$ 和 $q_{n+1}$ 的表达式，可以得到一个关于 $P$ 的方程：\n$$\nP - 2p_n = -\\frac{h}{4}\\left(q_n + q_n + \\frac{h}{2}P\\right)^2 = -\\frac{h}{4}\\left(2q_n + \\frac{h}{2}P\\right)^2\n$$\n$$\nP - 2p_n = -\\frac{h}{4}\\left(4q_n^2 + 2hq_n P + \\frac{h^2}{4}P^2\\right) = -hq_n^2 - \\frac{h^2}{2}q_n P - \\frac{h^3}{16}P^2.\n$$\n这是一个关于 $P$ 的二次方程：\n$$\n\\frac{h^3}{16}P^2 + \\left(1+\\frac{h^2}{2}q_n\\right)P + (hq_n^2 - 2p_n) = 0.\n$$\n使用求根公式解出 $P$：\n$$\nP = \\frac{-\\left(1+\\frac{h^2}{2}q_n\\right) \\pm \\sqrt{\\left(1+\\frac{h^2}{2}q_n\\right)^2 - 4\\left(\\frac{h^3}{16}\\right)(hq_n^2 - 2p_n)}}{2(h^3/16)}.\n$$\n判别式化简为 $1+h^2q_n+\\frac{h^4}{4}q_n^2 - \\frac{h^4}{4}q_n^2 + \\frac{h^3}{2}p_n = 1+h^2q_n+\\frac{h^3}{2}p_n$。\n$$\nP = \\frac{8}{h^3}\\left[ -\\left(1+\\frac{h^2}{2}q_n\\right) \\pm \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} \\right].\n$$\n在 $h \\to 0$ 的极限下，我们必须恢复 $y_{n+1} \\to y_n$，这意味着 $P = p_n+p_{n+1} \\to 2p_n$。解中只有取‘+’号才能得到这个正确的物理极限。因此：\n$$\np_n+p_{n+1} = \\frac{8}{h^3}\\left[ \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} - \\left(1+\\frac{h^2}{2}q_n\\right) \\right].\n$$\n将此代入 $\\Delta H_{\\mathrm{mid}}$ 的表达式中：\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{h^3}{96} \\left( \\frac{8}{h^3}\\left[ \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} - \\left(1+\\frac{h^2}{2}q_n\\right) \\right] \\right)^3\n$$\n$$\n\\Delta H_{\\mathrm{mid}} = \\frac{h^3}{96} \\frac{8^3}{h^9} \\left[ \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} - \\left(1+\\frac{h^2}{2}q_n\\right) \\right]^3\n$$\n$$\n\\Delta H_{\\mathrm{mid}}(q_{n},p_{n};h) = \\frac{16}{3h^6} \\left[ \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} - \\left(1+\\frac{h^2}{2}q_n\\right) \\right]^3.\n$$\n这就是隐式中点法的精确单步能量变化。\n\n总之，AVF 方法作为一种离散梯度法，其构造保证了它能保守任何多项式哈密顿量 $H$，本题情况即是如此。而隐式中点法虽然是辛方法，因而能保守一个邻近的修正哈密顿量 $H_{mod} = H + O(h^2)$，但它并不能精确保守 $H$。所推导出的非零表达式 $\\Delta H_{\\mathrm{mid}}$ 量化了这一单步偏差。",
            "answer": "$$\n\\boxed{\\frac{16}{3h^6} \\left[ \\sqrt{1+h^2q_n+\\frac{h^3}{2}p_n} - \\left(1+\\frac{h^2}{2}q_n\\right) \\right]^3}\n$$"
        },
        {
            "introduction": "理论知识的最终目的是应用于实际的科学计算。本练习将带领我们将理论付诸实践，设计一个数值实验来验证和量化不同积分器的辛性。通过编写代码来近似计算离散映射的雅可比矩阵，并测量其与辛条件的偏差，我们能够凭经验区分真正的几何积分器与非保结构方法，这是连接抽象数学与计算实践的关键一步。",
            "id": "3451938",
            "problem": "考虑一个一维线性波动方程在具有 $N$ 个节点的周期性网格上的空间半离散化，这会产生一个有限维哈密顿系统，其状态为 $y = (q, p) \\in \\mathbb{R}^{2N}$，由正则方程 $y'(t) = J \\nabla H(y(t))$ 控制。其中 $J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$ 是大小为 $2N \\times 2N$ 的正则辛矩阵，$I$ 是大小为 $N \\times N$ 的单位矩阵，且 $H(q,p) = T(p) + V(q)$，其中 $T(p) = \\tfrac{1}{2} \\sum_{i=1}^{N} p_i^2$ 且 $V(q) = -\\tfrac{1}{2} c^2 q^\\top L q$。矩阵 $L \\in \\mathbb{R}^{N \\times N}$ 是标准的二阶差分周期性拉普拉斯算子，使得 $(L q)_i = q_{i+1} - 2 q_i + q_{i-1}$，其中指数在模 $N$ 意义下解释，$c \\in \\mathbb{R}$ 是一个正常数波速参数。\n\n一个步长为 $h \\in \\mathbb{R}$ 的离散单步时间积分器定义了一个映射 $\\Psi_h : \\mathbb{R}^{2N} \\to \\mathbb{R}^{2N}$。如果对于所有状态 $y$，$D\\Psi_h(y)^\\top J D\\Psi_h(y) = J$ 成立，则称映射 $\\Psi_h$ 是辛的，其中 $D\\Psi_h(y) \\in \\mathbb{R}^{2N \\times 2N}$ 是 $\\Psi_h$ 在 $y$ 处的雅可比矩阵。你的任务是通过在代表性的测试状态上使用有限差分来近似 $D\\Psi_h(y)$，从而经验性地验证离散辛性，并计算其违反量的弗罗贝尼乌斯范数\n$$\n\\Delta(y; h) = D\\Psi_h(y)^\\top J D\\Psi_h(y) - J,\n$$\n并以相对量\n$$\nr(y; h) = \\frac{\\lVert \\Delta(y; h) \\rVert_F}{\\lVert J \\rVert_F}\n$$\n的形式报告。\n使用中心差分来近似 $D\\Psi_h(y)$ 的列：对于第 $i$ 个标准基向量 $e_i \\in \\mathbb{R}^{2N}$ 和一个有限差分尺度 $\\varepsilon \\in \\mathbb{R}$，第 $i$ 列可通过下式近似\n$$\n\\frac{\\Psi_h(y + \\varepsilon e_i) - \\Psi_h(y - \\varepsilon e_i)}{2 \\varepsilon}.\n$$\n\n在半离散系统上实现以下单步时间积分器 $\\Psi_h$：\n- 一种基于正则变量下动能-势能分裂的可分哈密顿辛方法（Störmer–Verlet）。\n- 一种由应用于正则系统的中点法则定义的辛方法（隐式中点法）。\n- 一种基于显式欧拉步的非辛方法。\n- 一种在动量更新中包含线性阻尼的非辛方法（带阻尼的显式欧拉法），其中阻尼强度 $\\gamma \\in \\mathbb{R}$ 将半离散动力学修改为 $p'(t) = c^2 L q(t) - \\gamma p(t)$。\n\n从控制方程和系统结构推导每个积分器，并实现 $\\Psi_h$，使其作用于一个输入状态向量 $y \\in \\mathbb{R}^{2N}$ 并返回下一个状态。完全按照规定构造周期性拉普拉斯算子 $L$。使用由以下组成的代表性测试状态：\n- 一个确定性的正弦构型，其中对于 $i = 0, 1, \\dots, N-1$，$q_i = \\sin(2\\pi i/N)$ 且 $p_i = 0$。\n- 一个从具有固定种子的标准正态分布中抽样的可复现随机状态。\n\n对于所有计算，使用纯数学量，无物理单位。在适用于正弦函数的情况下，角度默认为弧度。\n\n设计并运行一个测试套件，包含以下参数集 $(\\text{method}, N, h, \\varepsilon, c, \\text{state}, \\gamma)$，为每个参数集生成 $r(y; h)$：\n- 情况 1：$(\\text{Verlet},\\, 6,\\, 0.2,\\, 10^{-6},\\, 1.0,\\, \\text{random},\\, 0.0)$。\n- 情况 2：$(\\text{ImplicitMidpoint},\\, 6,\\, 0.2,\\, 10^{-6},\\, 1.0,\\, \\text{random},\\, 0.0)$。\n- 情况 3：$(\\text{ExplicitEuler},\\, 6,\\, 0.2,\\, 10^{-6},\\, 1.0,\\, \\text{random},\\, 0.0)$。\n- 情况 4：$(\\text{Verlet},\\, 6,\\, 0.8,\\, 10^{-6},\\, 1.0,\\, \\text{sine},\\, 0.0)$。\n- 情况 5：$(\\text{DampedExplicitEuler},\\, 6,\\, 0.2,\\, 10^{-6},\\, 1.0,\\, \\text{sine},\\, 0.5)$。\n- 情况 6：$(\\text{ExplicitEuler},\\, 6,\\, 0.05,\\, 10^{-6},\\, 1.0,\\, \\text{random},\\, 0.0)$。\n\n你的程序应产生单行输出，其中包含六个得到的相对偏差 $r(y; h)$，形式为用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$）。每个 $\\text{result}_i$ 必须是一个浮点数。",
            "solution": "该问题要求对应用于半离散化线性波动方程的几种数值时间积分器的辛性质进行经验性验证。验证过程通过数值近似离散流的雅可比矩阵，并测量其与辛条件的偏差来执行。\n\n### 系统公式化\n物理系统被建模为一个有限维哈密顿系统。在时间 $t$ 的状态由向量 $y(t) = (q(t), p(t))^\\top \\in \\mathbb{R}^{2N}$ 给出，其中 $q \\in \\mathbb{R}^N$ 表示网格点位置，而 $p \\in \\mathbb{R}^N$ 表示它们对应的动量。系统的演化遵循哈密顿正则方程：\n$$y'(t) = J \\nabla H(y(t))$$\n其中 $J \\in \\mathbb{R}^{2N \\times 2N}$ 是正则辛矩阵，$H(y)$ 是系统的哈密顿量（总能量）。矩阵 $J$ 定义为：\n$$J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$$\n其中 $I$ 是 $N \\times N$ 的单位矩阵。哈密顿量是可分的，$H(q,p) = T(p) + V(q)$，其动能 $T(p)$ 和势能 $V(q)$ 分别为：\n$$\nT(p) = \\frac{1}{2} p^\\top p \\quad \\text{和} \\quad V(q) = -\\frac{1}{2} c^2 q^\\top L q\n$$\n这里，$c$ 是一个正常数波速，而 $L \\in \\mathbb{R}^{N \\times N}$ 是对称的二阶差分周期性拉普拉斯矩阵。$L$ 作用于向量 $q$ 的行为按元素定义为 $(Lq)_i = q_{i+1} - 2q_i + q_{i-1}$，其中指数在模 $N$ 意义下解释。\n\n能量分量的梯度为 $\\nabla_p T(p) = p$，且由于 $L$ 的对称性，$\\nabla_q V(q) = -c^2 L q$。因此，哈密顿方程展开为：\n$$\nq'(t) = \\frac{\\partial H}{\\partial p} = p(t)\n$$\n$$\np'(t) = -\\frac{\\partial H}{\\partial q} = -(-c^2 L q(t)) = c^2 L q(t)\n$$\n这个由 $2N$ 个一阶常微分方程（ODE）组成的系统，可以紧凑地写成 $y' = Ay$，其中 $A = \\begin{pmatrix} 0  I \\\\ c^2 L  0 \\end{pmatrix}$，是这些数值方法的基础。\n\n### 数值积分器\n我们实现四种单步积分器 $\\Psi_h$，它们将时间 $t_n$ 的状态 $y_n$ 映射到时间 $t_{n+1} = t_n + h$ 的状态 $y_{n+1}$。\n\n1.  **Störmer–Verlet 积分器 ($\\Psi_h^{\\text{Verlet}}$)**：这是一种二阶、显式、辛积分器，非常适合可分哈密顿量。一种常见的实现方式，称为位置 Verlet 法或蛙跳法，由一系列三个显式步骤给出：\n    - 动量的半步更新：$p_{n+1/2} = p_n + \\frac{h}{2} (c^2 L q_n)$。\n    - 位置的整步更新：$q_{n+1} = q_n + h p_{n+1/2}$。\n    - 动量的最后半步更新：$p_{n+1} = p_{n+1/2} + \\frac{h}{2} (c^2 L q_{n+1})$。\n\n2.  **隐式中点法则 ($\\Psi_h^{\\text{IM}}$)**：该方法是一种单步、二阶、隐式积分器，对任何哈密顿系统都是保辛的。对于一个常微分方程 $y' = f(y)$，其更新规则为 $y_{n+1} = y_n + h f(\\frac{y_n+y_{n+1}}{2})$。对于我们的线性系统 $y' = Ay$，这会得到：\n    $$y_{n+1} = y_n + h A \\frac{y_n + y_{n+1}}{2}$$\n    这可以重排为一个关于 $y_{n+1}$ 的线性系统：$(I - \\frac{h}{2}A) y_{n+1} = (I + \\frac{h}{2}A) y_n$。在实现时，我们解耦 $q$ 和 $p$ 的方程。通过代入，我们获得一个仅关于 $q_{n+1}$ 的线性系统：\n    $$ \\left(I - \\frac{h^2 c^2}{4} L\\right) q_{n+1} = \\left(I + \\frac{h^2 c^2}{4} L\\right) q_n + h p_n $$\n    解出这个 $N \\times N$ 系统的 $q_{n+1}$ 后，我们可以通过显式更新 $p_{n+1} = p_n + \\frac{h c^2}{2} L(q_n + q_{n+1})$ 来求得 $p_{n+1}$。\n\n3.  **显式欧拉法 ($\\Psi_h^{\\text{EE}}$)**：最简单的显式方法，定义为 $y_{n+1} = y_n + h f(y_n)$。它是一阶的且非辛的。对于我们的系统：\n    - $q_{n+1} = q_n + h p_n$。\n    - $p_{n+1} = p_n + h c^2 L q_n$。\n\n4.  **带阻尼的显式欧拉法 ($\\Psi_h^{\\text{DEE}}$)**：此处，底层动力学被修改以包含一个强度为 $\\gamma \\ge 0$ 的非保守阻尼项：$p'(t) = c^2 L q(t) - \\gamma p(t)$。该系统不再是哈密顿系统。应用于这些修正后动力学的显式欧拉法给出：\n    - $q_{n+1} = q_n + h p_n$。\n    - $p_{n+1} = p_n + h (c^2 L q_n - \\gamma p_n) = (1-h\\gamma)p_n + h c^2 L q_n$。\n\n### 辛性的验证\n一个从 $\\mathbb{R}^{2N}$ 到自身的映射 $\\Psi_h$ 是辛的，如果其雅可比矩阵 $D\\Psi_h(y)$ 满足条件\n$$ D\\Psi_h(y)^\\top J D\\Psi_h(y) = J $$\n对于所有状态 $y$ 均成立。为了经验性地验证此性质，我们近似雅可比矩阵。$D\\Psi_h(y)$ 的第 $j$ 列是偏导数 $\\frac{\\partial \\Psi_h}{\\partial y_j}(y)$，我们使用一个步长为 $\\varepsilon$ 的二阶中心有限差分公式来近似它：\n$$ \\left[D\\Psi_h(y)\\right]_{\\cdot, j} \\approx \\frac{\\Psi_h(y + \\varepsilon e_j) - \\Psi_h(y - \\varepsilon e_j)}{2 \\varepsilon} $$\n其中 $e_j$ 是 $\\mathbb{R}^{2N}$ 中的第 $j$ 个标准基向量。一旦构造了近似的雅可比矩阵 $D\\Psi_h$，我们就评估辛性违反矩阵 $\\Delta(y; h) = D\\Psi_h(y)^\\top J D\\Psi_h(y) - J$。该违反的大小由相对弗罗贝尼乌斯范数量化：\n$$ r(y; h) = \\frac{\\lVert \\Delta(y; h) \\rVert_F}{\\lVert J \\rVert_F} $$\n$J$ 的弗罗贝尼乌斯范数为 $\\lVert J \\rVert_F = \\sqrt{\\text{Tr}(J^\\top J)} = \\sqrt{\\text{Tr}(\\text{diag}(I,I))} = \\sqrt{2N}$。\n\n对于 Störmer-Verlet 和隐式中点法这两种精确保辛的方法，理论上的违反量为零。计算值 $r(y;h)$ 将非零但很小，主要由浮点舍入误差和有限差分近似的 $O(\\varepsilon^2)$ 误差主导。对于像显式欧拉法这样的非辛方法，违反是内在的，并且 $r(y;h)$ 预计为 $O(h)$ 阶。阻尼系统是非哈密顿的，因此其离散流也预计是非辛的。\n\n计算过程包括实现四种积分器映射，为给定维度 $N$ 构造必要的矩阵，生成指定的初始状态，然后执行测试套件。对于每种情况，都会数值计算雅可比矩阵，并计算和报告相对违反量 $r(y;h)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef get_laplacian(N):\n    \"\"\"Constructs the 1D periodic Laplacian matrix L of size N x N.\"\"\"\n    L = np.zeros((N, N))\n    for i in range(N):\n        L[i, i] = -2\n        L[i, (i + 1) % N] = 1\n        L[i, (i - 1 + N) % N] = 1\n    return L\n\ndef get_J_matrix(N):\n    \"\"\"Constructs the canonical symplectic matrix J of size 2N x 2N.\"\"\"\n    J = np.zeros((2 * N, 2 * N))\n    I = np.eye(N)\n    J[0:N, N:2*N] = I\n    J[N:2*N, 0:N] = -I\n    return J\n    \ndef verlet_step(y, h, c, L):\n    \"\"\"Performs one step of the Störmer-Verlet integrator.\"\"\"\n    N = L.shape[0]\n    q_n = y[:N]\n    p_n = y[N:]\n    \n    # Half-step momentum\n    p_half = p_n + (h / 2.0) * (c**2) * (L @ q_n)\n    # Full-step position\n    q_next = q_n + h * p_half\n    # Half-step momentum\n    p_next = p_half + (h / 2.0) * (c**2) * (L @ q_next)\n    \n    return np.concatenate([q_next, p_next])\n\ndef implicit_midpoint_step(y, h, c, L):\n    \"\"\"Performs one step of the Implicit Midpoint integrator.\"\"\"\n    N = L.shape[0]\n    I_N = np.eye(N)\n    q_n = y[:N]\n    p_n = y[N:]\n\n    # System for q_{n+1}: M_imp * q_{n+1} = b_imp\n    M_imp = I_N - (h**2 * c**2 / 4.0) * L\n    b_imp = (I_N + (h**2 * c**2 / 4.0) * L) @ q_n + h * p_n\n    \n    q_next = np.linalg.solve(M_imp, b_imp)\n    \n    # Update p_{n+1}\n    p_next = p_n + (h * c**2 / 2.0) * (L @ (q_n + q_next))\n\n    return np.concatenate([q_next, p_next])\n\ndef explicit_euler_step(y, h, c, L):\n    \"\"\"Performs one step of the Explicit Euler integrator.\"\"\"\n    N = L.shape[0]\n    q_n = y[:N]\n    p_n = y[N:]\n\n    q_next = q_n + h * p_n\n    p_next = p_n + h * (c**2) * (L @ q_n)\n    \n    return np.concatenate([q_next, p_next])\n\ndef damped_explicit_euler_step(y, h, c, L, gamma):\n    \"\"\"Performs one step of the Damped Explicit Euler integrator.\"\"\"\n    N = L.shape[0]\n    q_n = y[:N]\n    p_n = y[N:]\n\n    q_next = q_n + h * p_n\n    p_next = p_n + h * ((c**2) * (L @ q_n) - gamma * p_n)\n\n    return np.concatenate([q_next, p_next])\n\ndef compute_jacobian(integrator_func, y, h, epsilon, **kwargs):\n    \"\"\"Computes the Jacobian of the integrator map using central differences.\"\"\"\n    dim = len(y)\n    D = np.zeros((dim, dim))\n    \n    for j in range(dim):\n        e_j = np.zeros(dim)\n        e_j[j] = 1.0\n        \n        y_plus = y + epsilon * e_j\n        y_minus = y - epsilon * e_j\n        \n        psi_plus = integrator_func(y_plus, h, **kwargs)\n        psi_minus = integrator_func(y_minus, h, **kwargs)\n        \n        D[:, j] = (psi_plus - psi_minus) / (2.0 * epsilon)\n        \n    return D\n\ndef calculate_violation(D, J):\n    \"\"\"Calculates the relative Frobenius norm of the symplecticity violation.\"\"\"\n    N = J.shape[0] // 2\n    delta = D.T @ J @ D - J\n    norm_delta = np.linalg.norm(delta, 'fro')\n    norm_J = np.sqrt(2.0 * N)\n    \n    return norm_delta / norm_J\n\ndef solve():\n    test_cases = [\n        {'method': 'Verlet', 'N': 6, 'h': 0.2, 'epsilon': 1e-6, 'c': 1.0, 'state': 'random', 'gamma': 0.0},\n        {'method': 'ImplicitMidpoint', 'N': 6, 'h': 0.2, 'epsilon': 1e-6, 'c': 1.0, 'state': 'random', 'gamma': 0.0},\n        {'method': 'ExplicitEuler', 'N': 6, 'h': 0.2, 'epsilon': 1e-6, 'c': 1.0, 'state': 'random', 'gamma': 0.0},\n        {'method': 'Verlet', 'N': 6, 'h': 0.8, 'epsilon': 1e-6, 'c': 1.0, 'state': 'sine', 'gamma': 0.0},\n        {'method': 'DampedExplicitEuler', 'N': 6, 'h': 0.2, 'epsilon': 1e-6, 'c': 1.0, 'state': 'sine', 'gamma': 0.5},\n        {'method': 'ExplicitEuler', 'N': 6, 'h': 0.05, 'epsilon': 1e-6, 'c': 1.0, 'state': 'random', 'gamma': 0.0},\n    ]\n\n    integrators = {\n        'Verlet': verlet_step,\n        'ImplicitMidpoint': implicit_midpoint_step,\n        'ExplicitEuler': explicit_euler_step,\n        'DampedExplicitEuler': damped_explicit_euler_step\n    }\n\n    results = []\n    \n    # Use a fixed seed for reproducibility of random states\n    np.random.seed(42)\n\n    for case in test_cases:\n        N = case['N']\n        h = case['h']\n        epsilon = case['epsilon']\n        c = case['c']\n        gamma = case['gamma']\n        \n        # Construct matrices\n        L = get_laplacian(N)\n        J = get_J_matrix(N)\n\n        # Generate initial state y = (q, p)\n        if case['state'] == 'sine':\n            i_vals = np.arange(N)\n            q0 = np.sin(2 * np.pi * i_vals / N)\n            p0 = np.zeros(N)\n            y0 = np.concatenate([q0, p0])\n        elif case['state'] == 'random':\n            y0 = np.random.randn(2 * N)\n        \n        # Select integrator\n        integrator = integrators[case['method']]\n        \n        # Prepare kwargs for the integrator and jacobian calculation\n        kwargs = {'c': c, 'L': L}\n        if case['method'] == 'DampedExplicitEuler':\n            kwargs['gamma'] = gamma\n        \n        # Compute Jacobian\n        D_psi_h = compute_jacobian(integrator, y0, h, epsilon, **kwargs)\n        \n        # Calculate violation\n        r = calculate_violation(D_psi_h, J)\n        results.append(r)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}