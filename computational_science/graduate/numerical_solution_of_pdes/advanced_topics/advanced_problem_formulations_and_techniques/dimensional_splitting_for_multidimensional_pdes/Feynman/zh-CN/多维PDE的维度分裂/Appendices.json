{
    "hands_on_practices": [
        {
            "introduction": "理论是基础，但真正掌握维数分裂法的精髓在于亲手实现它。我们的第一个实践将从一个经典的抛物型偏微分方程——二维热传导方程入手。在这个练习中，你将构建一个完整的数值求解器，分别实现一阶精度的李分裂（Lie splitting）和二阶精度的斯特朗分裂（Strang splitting）。通过与一个精确的“人造解”（manufactured solution）进行比较，你将进行收敛性测试，亲眼验证这两种分裂格式在时间精度上的理论差异，这是数值方法研究中的一项基本功。",
            "id": "3377992",
            "problem": "考虑单位正方形上的二维热方程，其具有齐次 Dirichlet 边界条件，其精确的制造解由 $u(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\mathrm{e}^{-2\\pi^2 t}$ 给出。控制偏微分方程为 $u_t=u_{xx}+u_{yy}$，其中 $(x,y)\\in(0,1)\\times(0,1)$ 且 $t\\ge 0$，初始条件为 $u(x,y,0)=\\sin(\\pi x)\\sin(\\pi y)$，并且对于所有 $t\\ge 0$，在边界 $\\partial\\Omega$ 上 $u=0$。你的任务是构建一个基于交替一维演化子问题的维度分裂求解器，并通过将时间步长 $\\Delta t$ 减半来凭经验确定其在时间上的观测精度阶，同时通过采用足够小的空间网格尺寸 $h$ 来确保空间离散化误差可以忽略不计。\n\n请完全在纯数学和算法的环境中进行工作：使用均匀的笛卡尔网格对 $(0,1)^2$ 进行离散化，内部网格大小为 $M\\times M$，间距为 $h=1/(M+1)$。使用 $M=128$，此时 $h=1/129$。维度分裂必须通过在同一网格上交替求解子问题 $v_t=v_{xx}$ 和 $w_t=w_{yy}$ 来进行，并遵守齐次 Dirichlet 边界条件。每个一维子问题必须使用沿相应网格线应用的二阶精度且无条件稳定的方法在时间上进行推进。使用一阶 Lie 分裂（先应用一个大小为 $\\Delta t$ 的 $x$ 方向步长，然后是一个大小为 $\\Delta t$ 的 $y$ 方向步长）或二阶 Strang 分裂（先应用一个大小为 $\\Delta t/2$ 的 $x$ 方向步长，然后是一个大小为 $\\Delta t$ 的 $y$ 方向步长，最后再应用一个大小为 $\\Delta t/2$ 的 $x$ 方向步长）来组合一维子求解器以产生一个完整的时间步。在 $t=0$ 时使用精确初始条件初始化数值解，推进到最终时间 $T$，并计算在 $t=T$ 时相对于精确制造解的离散 $\\ell^2$ 误差，其定义为\n$$\nE(\\Delta t):=\\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(u_{i,j}^{\\mathrm{num}}(T)-u\\!\\left(x_i,y_j,T\\right)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i=ih$ 和 $y_j=jh$ 表示内部网格点。\n\n为了量化时间上的观测精度阶，请使用三个减半的时间步长 $\\Delta t,\\,\\Delta t/2,\\,\\Delta t/4$（其中 $T$ 是这些时间步长的整数倍）。计算误差 $E(\\Delta t)$、$E(\\Delta t/2)$ 和 $E(\\Delta t/4)$，然后计算两个观测阶，\n$$\np_1=\\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)},\\quad p_2=\\frac{\\log\\big(E(\\Delta t/2)/E(\\Delta t/4)\\big)}{\\log(2)},\n$$\n并为每个测试案例输出平均值 $\\bar{p}=(p_1+p_2)/2$ 作为单个浮点数。\n\n实现你的求解器并为以下三个测试案例生成数值结果，这三个案例共同构成测试套件：\n- 案例 1：一阶 Lie 分裂，最终时间 $T=0.1$，基础时间步长 $\\Delta t=0.025$（因此减半后的步长为 $0.0125$ 和 $0.00625$）。\n- 案例 2：二阶 Strang 分裂，最终时间 $T=0.1$，基础时间步长 $\\Delta t=0.025$。\n- 案例 3：二阶 Strang 分裂，最终时间 $T=0.2$，基础时间步长 $\\Delta t=0.05$。\n\n在所有案例中，每个空间方向使用 $M=128$ 个内部点，设置 $h=1/129$，并强制执行齐次 Dirichlet 边界条件。三角函数中的角度必须以弧度为单位。要求的最终输出格式为单行，其中包含一个逗号分隔的 Python 风格列表，列表内是三个案例的三个浮点平均值 $\\bar{p}$，按上述顺序列出，并用方括号括起来。例如，你的程序应该打印类似“[1.0,2.0,2.0]”的内容，但使用为这三个案例计算出的实际浮点值。",
            "solution": "用户想要解决一个涉及二维热方程的数值分析问题。\n\n## 1. 数学公式\n\n所考虑的问题是单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的二维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = (\\Delta_x + \\Delta_y) u\n$$\n其初始条件为 $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$，齐次 Dirichlet 边界条件为 $u(x,y,t) = 0$ 对 $(x,y) \\in \\partial\\Omega$ 成立。提供的制造解为 $u(x,y,t) = \\sin(\\pi x)\\sin(\\pi y)e^{-2\\pi^2 t}$，它满足该偏微分方程和辅助条件。\n\n## 2. 数值方法：算子分裂\n\n为了数值求解此方程，我们采用算子分裂（或维度分裂）技术。其核心思想是将二维拉普拉斯算子 $\\Delta = \\Delta_x + \\Delta_y$ 分解为两个一维算子。然后通过求解一系列更简单的一维问题来近似解在时间步长 $\\Delta t$ 内的演化。\n\n设 $\\mathcal{L}_x = \\Delta_x$ 和 $\\mathcal{L}_y = \\Delta_y$。该偏微分方程为 $u_t = (\\mathcal{L}_x + \\mathcal{L}_y)u$。形式解为 $u(t) = e^{t(\\mathcal{L}_x + \\mathcal{L}_y)}u(0)$。算子分裂法近似矩阵指数 $e^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)}$。\n\n### 2.1. Lie 分裂（一阶）\n\n一阶 Lie-Trotter 分裂将演化近似为一维演化算子的顺序应用：\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\Delta t \\mathcal{L}_y} e^{\\Delta t \\mathcal{L}_x}\n$$\n这种近似引入了 $O(\\Delta t)$ 阶的分裂误差。将解 $U^n$ 从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 处的 $U^{n+1}$ 的数值格式是一个两阶段过程：\n1.  求解 $u^*_t = \\mathcal{L}_x u^*$，步长为 $\\Delta t$，初始条件为 $u^*(t_n) = U^n$。设结果为 $U^* = \\mathcal{S}_x(\\Delta t) U^n$。\n2.  求解 $u^{**}_t = \\mathcal{L}_y u^{**}$，步长为 $\\Delta t$，初始条件为 $u^{**}(t_n) = U^*$。最终结果是 $U^{n+1} = \\mathcal{S}_y(\\Delta t) U^* = \\mathcal{S}_y(\\Delta t) \\mathcal{S}_x(\\Delta t) U^n$。\n\n### 2.2. Strang 分裂（二阶）\n\n二阶 Strang 分裂提供了一个更精确的对称近似：\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\frac{\\Delta t}{2} \\mathcal{L}_x} e^{\\Delta t \\mathcal{L}_y} e^{\\frac{\\Delta t}{2} \\mathcal{L}_x}\n$$\n这引入了 $O(\\Delta t^2)$ 阶的分裂误差。该数值格式是一个三阶段过程：\n1.  在 $x$ 方向求解半步：$U^* = \\mathcal{S}_x(\\Delta t/2) U^n$。\n2.  在 $y$ 方向求解全步：$U^{**} = \\mathcal{S}_y(\\Delta t) U^*$。\n3.  在 $x$ 方向再求解半步：$U^{n+1} = \\mathcal{S}_x(\\Delta t/2) U^{**}$。\n\n## 3. 离散化和一维求解器：Crank-Nicolson 方法\n\n区域使用 $M \\times M$ 个内部点的均匀网格进行离散化，空间步长为 $h = 1/(M+1)$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{1, \\dots, M\\}$。\n\n每个一维子问题，例如 $v_t = v_{xx}$，都必须使用二阶精度且无条件稳定的方法求解。Crank-Nicolson 方法是经典选择。对于具有值 $V_i^n \\approx v(x_i, t_n)$ 的一维网格，Crank-Nicolson 离散化为：\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2} \\left( \\frac{V_{i+1}^n - 2V_i^n + V_{i-1}^n}{h^2} + \\frac{V_{i+1}^{n+1} - 2V_i^{n+1} + V_{i-1}^{n+1}}{h^2} \\right)\n$$\n其中 $\\Delta \\tau$ 是一维求解的时间步长（可以是 $\\Delta t$ 或 $\\Delta t/2$）。设扩散数为 $\\alpha = \\frac{\\Delta \\tau}{2h^2}$。整理各项，我们得到关于未知值 $V_i^{n+1}$ 的线性方程组：\n$$\n-\\alpha V_{i-1}^{n+1} + (1+2\\alpha)V_i^{n+1} - \\alpha V_{i+1}^{n+1} = \\alpha V_{i-1}^n + (1-2\\alpha)V_i^n + \\alpha V_{i+1}^n\n$$\n对于 $i=1, \\dots, M$。边界条件 $V_0 = V_{M+1} = 0$ 已被纳入。这形成了一个三对角线性方程组 $A \\mathbf{V}^{n+1} = B \\mathbf{V}^n$，其中 $\\mathbf{V}^n$ 是时间 $t_n$ 处的值向量。矩阵 $A$ 是三对角矩阵，其对角线元素为 $(1+2\\alpha)$，非对角线元素为 $-\\alpha$。该系统可以使用三对角矩阵算法（例如，Thomas 算法）高效地求解 $\\mathbf{V}^{n+1}$。\n\n## 4. 算法实现\n\n对于三个测试案例中的每一个，执行以下步骤：\n1.  设置参数：分裂方法类型、最终时间 $T$、基础时间步长 $\\Delta t_{base}$ 和网格大小 $M=128$。\n2.  定义用于精度测试的三个时间步长：$\\Delta t_1 = \\Delta t_{base}$，$\\Delta t_2 = \\Delta t_{base}/2$，$\\Delta t_3 = \\Delta t_{base}/4$。\n3.  对于每个时间步长 $\\Delta t_k$：\n    a. 用初始条件 $u(x,y,0)$ 在内部网格点上的值初始化一个 $M \\times M$ 的矩阵 $U$。\n    b. 计算时间步数 $N_k = T/\\Delta t_k$。\n    c. 通过迭代 $N_k$ 次，将解从 $t=0$ 演化到 $t=T$：\n        i. 在每次迭代中，应用所选的分裂方案（Lie 或 Strang）。\n        ii. 每次应用一维求解器 $\\mathcal{S}_x(\\tau)$ 或 $\\mathcal{S}_y(\\tau)$ 时，分别遍历当前数据矩阵的所有行或列，并使用 Crank-Nicolson 方法求解得到的三对角系统。对于列操作，矩阵先转置，然后应用行求解器，最后将结果转置回来。\n    d. 在最终时间 $T$，计算网格点上的精确解矩阵 $U_{exact}$。\n    e. 计算离散 $\\ell^2$ 误差：\n       $$\n       E(\\Delta t_k) = \\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(U_{ij}^{\\mathrm{num}}(T) - U_{ij}^{\\mathrm{exact}}(T)\\right)^2\\right)^{1/2} = h \\cdot \\|U^{\\mathrm{num}}(T) - U^{\\mathrm{exact}}(T)\\|_{\\text{F}}\n       $$\n       其中 $\\|\\cdot\\|_{\\text{F}}$ 是 Frobenius 范数。\n4. 计算出三个误差 $E_1, E_2, E_3$ 后，计算观测到的收敛阶：\n   $$\n   p_1 = \\frac{\\log(E_1/E_2)}{\\log(2)}, \\quad p_2 = \\frac{\\log(E_2/E_3)}{\\log(2)}\n   $$\n5. 该测试案例的最终结果是平均观测阶 $\\bar{p} = (p_1+p_2)/2$。\n\n此过程为三个指定的测试案例中的每一个产生一个 $\\bar{p}$ 值。预计 Lie 分裂将显示一阶收敛（$\\bar{p} \\approx 1.0$），而 Strang 分裂应显示二阶收敛（$\\bar{p} \\approx 2.0$），前提是时间分裂误差主导空间离散化误差，这一点由较小的 $h=1/129$ 值保证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef cn_step(u_in, dt_1d, h, M):\n    \"\"\"\n    Performs one step of the Crank-Nicolson method for the 1D heat equation.\n    u_t = u_xx with homogeneous Dirichlet boundary conditions. The method solves\n    the tridiagonal system (I - alpha*A_lap) u_new = (I + alpha*A_lap) u_in.\n\n    Args:\n        u_in (np.ndarray): The 1D array of solution values at the current time.\n        dt_1d (float): The time step for this 1D solve.\n        h (float): The spatial grid spacing.\n        M (int): The number of interior grid points.\n\n    Returns:\n        np.ndarray: The updated 1D array of solution values.\n    \"\"\"\n    alpha = dt_1d / (2.0 * h**2)\n\n    # Construct the right-hand side vector: b = (I + alpha*A_lap) * u_in\n    b = np.zeros(M)\n    b[0] = (1.0 - 2.0 * alpha) * u_in[0] + alpha * u_in[1]\n    b[M-1] = alpha * u_in[M-2] + (1.0 - 2.0 * alpha) * u_in[M-1]\n    b[1:-1] = alpha * u_in[:-2] + (1.0 - 2.0 * alpha) * u_in[1:-1] + alpha * u_in[2:]\n\n    # Construct the banded matrix for the left-hand side: A_lhs = (I - alpha*A_lap)\n    # The `ab` matrix for solve_banded has shape (3, M) for a tridiagonal system.\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -alpha          # Super-diagonal\n    ab[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n    ab[2, :-1] = -alpha         # Sub-diagonal\n\n    # Solve the tridiagonal system A_lhs * u_out = b.\n    # (1, 1) specifies one sub-diagonal and one super-diagonal.\n    u_out = solve_banded((1, 1), ab, b)\n    return u_out\n\ndef run_simulation(splitting_type, T, dt_base, M):\n    \"\"\"\n    Runs the full simulation for a given case to find the order of accuracy.\n    It computes the solution for three time steps (dt_base, dt_base/2, dt_base/4)\n    and uses the resulting errors to calculate the observed order of convergence.\n\n    Args:\n        splitting_type (str): 'Lie' or 'Strang'.\n        T (float): The final simulation time.\n        dt_base (float): The base time step.\n        M (int): The number of interior grid points per dimension.\n\n    Returns:\n        float: The average observed order of accuracy.\n    \"\"\"\n    h = 1.0 / (M + 1.0)\n    x = h * np.arange(1, M + 1)\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    dts = [dt_base, dt_base / 2.0, dt_base / 4.0]\n    errors = []\n\n    for dt in dts:\n        # Initialize the solution matrix with the initial condition\n        U = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            if splitting_type == 'Lie':\n                # --- Lie Splitting Step ---\n                # X-sweep (full dt)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt, h, M)\n                \n                # Y-sweep (full dt)\n                U_next = np.zeros_like(U)\n                for j in range(M):\n                    U_next[:, j] = cn_step(U_star[:, j], dt, h, M)\n                U = U_next\n\n            elif splitting_type == 'Strang':\n                # --- Strang Splitting Step ---\n                dt_half = dt / 2.0\n                \n                # X-sweep (dt/2)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt_half, h, M)\n\n                # Y-sweep (full dt)\n                U_dstar = np.zeros_like(U)\n                for j in range(M):\n                    U_dstar[:, j] = cn_step(U_star[:, j], dt, h, M)\n\n                # X-sweep (dt/2)\n                U_next = np.zeros_like(U)\n                for i in range(M):\n                    U_next[i, :] = cn_step(U_dstar[i, :], dt_half, h, M)\n                U = U_next\n\n        # Compute the L2 error at the final time T\n        U_exact = np.sin(np.pi * xx) * np.sin(np.pi * yy) * np.exp(-2.0 * np.pi**2 * T)\n        # The error is defined as h * ||U_num - U_exact||_F\n        error = h * np.linalg.norm(U - U_exact)\n        errors.append(error)\n\n    E1, E2, E3 = errors\n    p1 = np.log(E1 / E2) / np.log(2.0)\n    p2 = np.log(E2 / E3) / np.log(2.0)\n\n    p_avg = (p1 + p2) / 2.0\n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases\n    and prints the final result in the specified format.\n    \"\"\"\n    # Define the problem-specific parameters\n    M = 128\n\n    test_cases = [\n        # Case 1: Lie splitting, T=0.1, base dt=0.025\n        {'type': 'Lie', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 2: Strang splitting, T=0.1, base dt=0.025\n        {'type': 'Strang', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 3: Strang splitting, T=0.2, base dt=0.05\n        {'type': 'Strang', 'T': 0.2, 'dt_base': 0.05, 'M': M}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_avg = run_simulation(case['type'], case['T'], case['dt_base'], case['M'])\n        results.append(p_avg)\n\n    # Print the results in the required format: [p1,p2,p3]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了抛物型方程的基础后，我们将转向更具挑战性的双曲守恒律方程，这类方程描述了质量、动量等物理量的守恒。在应用维数分裂时，一个至关重要的细节浮出水面：天真地拆分算子可能导致数值解违反基本的物理守恒定律。这个实践将引导你分别实现一个“非守恒格式”和一个“守恒格式”的维数分裂方案，用于求解一个二维对流方程。通过比较两者在模拟可压缩流场时的表现，你将深刻理解为何必须在离散通量层面进行分裂，以确保数值结果的物理意义。",
            "id": "3377962",
            "problem": "考虑周期性方形域 $[0,1] \\times [0,1]$ 上的二维偏微分方程 (PDE) $u_t + \\nabla \\cdot (\\mathbf{b}(x,y) u) = 0$，其中 $\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ 是一个可压缩漂移场，$u(x,y,t)$ 是一个标量密度。在整个域上的积分守恒形式意味着，对于光滑解和周期性边界条件，总质量 $M(t) = \\int_0^1 \\int_0^1 u(x,y,t) \\, dx \\, dy$ 必须是守恒的，即 $\\frac{dM}{dt}=0$。\n\n在一个均匀的笛卡尔网格上设计并实现两种分裂步数值格式，该网格在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元，并采用周期性边界条件：\n- 一种朴素的维度分裂格式，该格式在每次扫描中以输运形式处理 PDE，在 $x$-扫描中近似求解 $u_t + b_x u_x = 0$，在 $y$-扫描中近似求解 $u_t + b_y u_y = 0$，使用基于单元中心的 $b_x$ 和 $b_y$ 的一阶迎风有限差分，并忽略可压缩源项 $u \\, \\nabla \\cdot \\mathbf{b}$。此格式必须使用单元中心速度和一维迎风，如在 $x$-扫描中 $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[a_{i,j}^+ (u_{i,j} - u_{i-1,j}) + a_{i,j}^- (u_{i+1,j} - u_{i,j})\\right]$，其中 $a_{i,j} = b_x(x_i,y_j)$，$a^+ = \\max(a,0)$，$a^- = \\min(a,0)$，$y$-扫描也类似。\n- 一种守恒的维度分裂格式，该格式在每次扫描中以通量形式更新，在 $x$-扫描中为 $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[F_{i+1/2,j} - F_{i-1/2,j}\\right]$，其中 $F_{i+1/2,j} = b_x(x_{i+1/2}, y_j) \\, u^{\\text{up}}_{i+1/2,j}$ 是在面 $(x_{i+1/2}, y_j)$ 处乘积 $b_x u$ 的迎风面通量，$u^{\\text{up}}_{i+1/2,j}$ 根据 $b_x(x_{i+1/2}, y_j)$ 的符号从左侧或右侧相邻单元中选择。对 $y$-扫描使用类似的通量形式，其面通量为 $G_{i,j+1/2} = b_y(x_i, y_{j+1/2}) \\, u^{\\text{up}}_{i,j+1/2}$。此格式必须使用面中心速度和乘积 $b u$ 的迎风，确保在周期性边界下每次扫描的离散质量守恒。\n\n从基本守恒律 $u_t + \\nabla \\cdot (\\mathbf{b} u) = 0$ 出发，推导离散更新，说明所需假设，并阐明输运形式和守恒形式之间的差异。从数学上证明，当 $\\mathbf{b}(x,y)$ 在空间上变化（可压缩漂移）时，由于输运形式分裂中离散乘积法则的失效，朴素分裂步会引入位于网格单元角点附近的人为质量源，并以基于通量的更新形式推导一个修正，该修正通过通量差的级数求和来强制实现每次扫描的质量守恒。\n\n实现这两种格式，并比较它们在由一次 $x$-扫描和一次 $y$-扫描组成的一个完整时间步后的离散质量误差。使用 Courant–Friedrichs–Lewy (CFL) 条件选择 $\\Delta t$，即 $\\Delta t = \\text{CFL} \\cdot \\min\\left(\\frac{\\Delta x}{\\max |b_x|}, \\frac{\\Delta y}{\\max |b_y|}\\right)$，其中 $\\text{CFL} = 0.4$。使用初始条件 $u(x,y,0) = \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2 \\sigma^2}\\right)$，其中 $x_0 = 0.3$, $y_0 = 0.7$, $\\sigma = 0.05$。网格由单元中心 $x_i = (i + \\tfrac{1}{2}) \\Delta x$，$y_j = (j + \\tfrac{1}{2}) \\Delta y$ 定义，其中 $i = 0, \\dots, N_x-1$ 和 $j = 0, \\dots, N_y-1$；面由 $x_{i+1/2} = (i+1) \\Delta x$，$y_{j+1/2} = (j+1) \\Delta y$ 定义。\n\n测试套件：\n- 情况 1（理想情况，无散度漂移）：$N_x = 64$，$N_y = 64$，$b_x(x,y) = \\cos(2\\pi y)$，$b_y(x,y) = -\\cos(2\\pi x)$。\n- 情况 2（可压缩漂移）：$N_x = 64$，$N_y = 64$，$b_x(x,y) = 2\\pi \\sin(2\\pi x) \\left[1 + 0.5 \\cos(2\\pi y)\\right]$，$b_y(x,y) = 2\\pi \\sin(2\\pi y) \\left[1 - 0.5 \\cos(2\\pi x)\\right]$。\n- 情况 3（具有剧烈符号变化和角点伪影的边界情况）：$N_x = 32$，$N_y = 32$，$b_x(x,y) = 2\\pi \\tanh\\left(4 \\sin(2\\pi x) \\cos(2\\pi y)\\right)$，$b_y(x,y) = 2\\pi \\tanh\\left(4 \\cos(2\\pi x) \\sin(2\\pi y)\\right)$。\n\n对于每种情况，运行一个完整的分裂步并报告两个浮点数：\n- 朴素格式的绝对质量误差，即 $|M^{\\text{naive}} - M^0|$，其中 $M^0$ 是初始质量，$M^{\\text{naive}}$ 是经过朴素分裂步后的质量。\n- 守恒格式的绝对质量误差，即 $|M^{\\text{cons}} - M^0|$，其中 $M^{\\text{cons}}$ 是经过守恒分裂步后的质量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个结果，格式为逗号分隔的列表，并用方括号括起来，顺序为 [情况 1 朴素误差, 情况 1 守恒误差, 情况 2 朴素误差, 情况 2 守恒误差, 情况 3 朴素误差, 情况 3 守恒误差]。",
            "solution": "所提出的问题是有效的。这是一个在偏微分方程数值方法领域中适定的、具有科学依据的问题，专门探讨了守恒律的守恒和非守恒离散格式之间的关键差异。它包含了获得唯一解所需的所有信息和定义。\n\n该问题的核心是守恒形式的二维平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{b} u) = 0\n$$\n其中 $u(x,y,t)$ 是一个标量密度，$\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ 是一个给定的速度场。该方程表达了量 $u$ 的守恒。域 $\\Omega = [0,1] \\times [0,1]$ 中的总质量定义为 $M(t) = \\int_{0}^{1}\\int_{0}^{1} u(x,y,t) \\,dx\\,dy$，是一个守恒量。在周期性边界条件下应用散度定理可以证实这一点：\n$$\n\\frac{dM}{dt} = \\int_{\\Omega} \\frac{\\partial u}{\\partial t} \\,dx\\,dy = -\\int_{\\Omega} \\nabla \\cdot (\\mathbf{b} u) \\,dx\\,dy = -\\int_{\\partial\\Omega} (\\mathbf{b} u) \\cdot \\mathbf{n} \\,ds = 0\n$$\n边界 $\\partial\\Omega$ 上的积分由于周期性而为零。理想情况下，数值格式应保留此性质的离散模拟。\n\n使用乘积法则，该偏微分方程可以展开为所谓的“输运”或“非守恒”形式：\n$$\n\\frac{\\partial u}{\\partial t} + \\mathbf{b} \\cdot \\nabla u + u(\\nabla \\cdot \\mathbf{b}) = 0\n$$\n当速度场是可压缩的，即 $\\nabla \\cdot \\mathbf{b} \\neq 0$ 时，项 $u(\\nabla \\cdot \\mathbf{b})$ 充当源项或汇项。\n\n维度分裂，或称算子分裂，通过求解一系列一维方程来近似二维方程的解。对于一阶 Lie-Trotter 分裂，我们通过先求解 $x$ 方向的偏微分方程一个时间步 $\\Delta t$，然后将结果用作求解 $y$ 方向偏微分方程一个时间步 $\\Delta t$ 的初始条件，从而完成一个完整时间步的求解。\n\n**格式 1：输运形式的朴素维度分裂**\n\n该格式基于对偏微分方程的不正确分裂。它分裂了平流算子 $\\mathbf{b} \\cdot \\nabla u = b_x \\frac{\\partial u}{\\partial x} + b_y \\frac{\\partial u}{\\partial y}$ 并忽略了源项 $u(\\nabla \\cdot \\mathbf{b})$。\n\n$x$-扫描求解：$\\frac{\\partial u}{\\partial t} + b_x \\frac{\\partial u}{\\partial x} = 0$。\n$y$-扫描求解：$\\frac{\\partial u}{\\partial t} + b_y \\frac{\\partial u}{\\partial y} = 0$。\n\n这种方法仅在 $\\nabla \\cdot \\mathbf{b}=0$（不可压缩流）时有效，并且还需要谨慎地进行分裂。对于一般的可压缩场，这种提法是根本错误的，因为它忽略了一个物理源项。\n\n问题指定了在具有单元中心 $(x_i, y_j)$ 的网格上，对 $x$-扫描使用一阶迎风离散化，并使用单元中心速度 $a_{i,j} = b_x(x_i, y_j)$：\n$$\n\\frac{u_{i,j}^{*} - u_{i,j}^{n}}{\\Delta t} = - \\left[ a_{i,j}^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + a_{i,j}^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} \\right]\n$$\n其中 $a^+ = \\max(a,0)$，$a^- = \\min(a,0)$。这等价于所给的更新规则。对 $y$-扫描执行类似的步骤。\n\n为了证明质量不守恒，我们将给定行 $j$ 的所有单元 $i=0, \\dots, N_x-1$ 的单元值变化求和。该行质量的变化与 $\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) \\Delta x$ 成正比。为简单起见，假设对所有 $i$ 都有 $a_{i,j}>0$。更新规则简化为 $u_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})$。变化的总和为：\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})\n$$\n通过对求和重新索引（在第二项中令 $k=i-1$）并应用周期性边界条件（$u_{-1,j} = u_{N_x-1,j}$，$a_{N_x,j}=a_{0,j}$）：\n$$\n\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\left( \\sum_{i} a_{i,j} u_{i,j}^n - \\sum_{i} a_{i,j} u_{i-1,j}^n \\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i} (a_{i,j} - a_{i+1,j}) u_{i,j}^n\n$$\n如果 $a_{i,j} = b_x(x_i, y_j)$ 随 $x$ 变化，即如果 $\\frac{\\partial b_x}{\\partial x} \\neq 0$，则该和不为零。因此，该格式会人为地产生或消灭质量，违反了基本守恒原理。如果 $b_y$ 随 $y$ 变化，则 $y$-扫描也存在同样的问题。\n\n**格式 2：通量形式的守恒维度分裂**\n\n该格式正确地分裂了偏微分方程的守恒形式。\n$x$-扫描求解：$\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}(b_x u) = 0$。\n$y$-扫描求解：$\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial y}(b_y u) = 0$。\n\n这是一种有限体积法。我们将 $x$-扫描的偏微分方程在一个控制体积 $V_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$ 上积分。我们可以一次只考虑一个维度。单元 $i$ 中的平均值是 $u_{i,j}(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, y_j, t) \\,dx$。积分后的偏微分方程变为：\n$$\n\\frac{d u_{i,j}}{dt} \\Delta x + \\left[ (b_x u)|_{x_{i+1/2}, y_j} - (b_x u)|_{x_{i-1/2}, y_j} \\right] = 0\n$$\n我们定义数值通量 $F_{i+1/2,j}$ 来近似单元交界面 $x_{i+1/2}$ 处的真实通量 $(b_x u)$。前向欧拉时间离散化给出：\n$$\nu_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2,j}^n - F_{i-1/2,j}^n \\right)\n$$\n对于一阶迎风格式，通量由面上的速度符号决定，$b_{x, i+1/2, j} = b_x(x_{i+1/2}, y_j)$：\n$$\nF_{i+1/2,j} = \n\\begin{cases} \nb_{x, i+1/2, j} \\, u_{i,j}  \\text{若 } b_{x, i+1/2, j} \\geq 0 \\\\\nb_{x, i+1/2, j} \\, u_{i+1,j}  \\text{若 } b_{x, i+1/2, j} < 0\n\\end{cases}\n= b_{x, i+1/2, j}^+ u_{i,j} + b_{x, i+1/2, j}^- u_{i+1,j}\n$$\n为了验证离散质量守恒，我们对所有 $i$ 的更新规则求和：\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j})\n$$\n右边的和是一个伸缩级数：\n$$\n\\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j}) = (F_{1/2,j} - F_{-1/2,j}) + (F_{3/2,j} - F_{1/2,j}) + \\dots + (F_{N_x-1/2,j} - F_{N_x-3/2,j})\n$$\n由于周期性边界条件，面 $x_{-1/2}$ 处的通量与面 $x_{N_x-1/2}$ 处的通量相同。因此，和收缩为零。每行 $j$ 的总质量 $\\sum_i u_{i,j} \\Delta x$ 在机器精度范围内是守恒的。对于 $y$-扫描也存在类似的论证。\n\n非守恒离散化与分裂误差的组合（该误差与 $x$ 和 $y$ 算子的交换子成正比并涉及混合导数），可能导致朴素格式中显著的误差累积，通常在速度场散度最大的地方表现为伪影。守恒格式通过将每个分裂步正确地表述为守恒律，避免了主要的误差来源，只留下分裂误差，该误差关系到解的精度而非其总质量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares a naive and a conservative dimensional splitting scheme\n    for the 2D advection equation, reporting the mass conservation error for each.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: np.cos(2 * np.pi * y),\n            \"by_func\": lambda x, y: -np.cos(2 * np.pi * x)\n        },\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * x) * (1 + 0.5 * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * y) * (1 - 0.5 * np.cos(2 * np.pi * x))\n        },\n        {\n            \"Nx\": 32, \"Ny\": 32,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y))\n        }\n    ]\n\n    results = []\n    CFL = 0.4\n    x0, y0, sigma = 0.3, 0.7, 0.05\n\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        bx_func, by_func = case[\"bx_func\"], case[\"by_func\"]\n\n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        # The problem statement defines faces at (i+1)*dx, which is not standard for FV\n        # but we follow it. This means x_faces[i] is x_{i+1/2} where cell i is to the left.\n        # So x_faces grid is Nx long. x_faces[Nx-1] is the face between cell Nx-1 and 0.\n        x_faces = (np.arange(Nx) + 1.0) * dx\n        y_faces = (np.arange(Ny) + 1.0) * dy\n\n        XX_cen, YY_cen = np.meshgrid(y_centers, x_centers, indexing='ij')\n        XX_xf, YY_xf = np.meshgrid(y_centers, x_faces, indexing='ij')\n        XX_yf, YY_yf = np.meshgrid(y_faces, x_centers, indexing='ij')\n\n        # Initial condition\n        u0 = np.exp(-((XX_cen - x0)**2 + (YY_cen - y0)**2) / (2 * sigma**2))\n        initial_mass = np.sum(u0) * dx * dy\n\n        # Time step calculation\n        bx_vals = np.concatenate([bx_func(XX_cen, YY_cen).flatten(), bx_func(XX_xf, YY_xf).flatten()])\n        by_vals = np.concatenate([by_func(XX_cen, YY_cen).flatten(), by_func(XX_yf, YY_yf).flatten()])\n        max_bx = np.max(np.abs(bx_vals)) if len(bx_vals) > 0 else 0\n        max_by = np.max(np.abs(by_vals)) if len(by_vals) > 0 else 0\n        \n        dt = CFL * min(dx / (max_bx + 1e-9), dy / (max_by + 1e-9))\n\n        # --- Scheme 1: Naive Splitting ---\n        u_naive = np.copy(u0)\n\n        # X-sweep (naive)\n        bx_center = bx_func(XX_cen, YY_cen)\n        bx_p = np.maximum(bx_center, 0)\n        bx_m = np.minimum(bx_center, 0)\n        u_im1 = np.roll(u_naive, 1, axis=1)\n        u_ip1 = np.roll(u_naive, -1, axis=1)\n        # Note the signs: the problem gives u_new = u_old - dt/dx * [...] which discretizes u_t = -b*u_x\n        # This corresponds to u_t + b*u_x = 0\n        u_star = u_naive - (dt / dx) * (bx_p * (u_naive - u_im1) + bx_m * (u_ip1 - u_naive))\n        \n        # Y-sweep (naive)\n        by_center = by_func(XX_cen, YY_cen)\n        by_p = np.maximum(by_center, 0)\n        by_m = np.minimum(by_center, 0)\n        u_jm1 = np.roll(u_star, 1, axis=0)\n        u_jp1 = np.roll(u_star, -1, axis=0)\n        u_final_naive = u_star - (dt / dy) * (by_p * (u_star - u_jm1) + by_m * (u_jp1 - u_star))\n\n        mass_naive = np.sum(u_final_naive) * dx * dy\n        error_naive = np.abs(mass_naive - initial_mass)\n        results.append(error_naive)\n\n        # --- Scheme 2: Conservative Splitting ---\n        u_cons = np.copy(u0)\n\n        # X-sweep (conservative)\n        bx_face = bx_func(XX_xf, YY_xf)\n        bx_face_p = np.maximum(bx_face, 0)\n        bx_face_m = np.minimum(bx_face, 0)\n        u_ip1 = np.roll(u_cons, -1, axis=1)\n        flux_x = bx_face_p * u_cons + bx_face_m * u_ip1\n        flux_x_im1 = np.roll(flux_x, 1, axis=1)\n        # Note the sign: problem gives u_new = u_old + dt/dx [F_i+1/2 - F_i-1/2]\n        # This discretizes u_t = -dF/dx, i.e., u_t + dF/dx = 0\n        u_star_cons = u_cons - (dt / dx) * (flux_x - flux_x_im1)\n\n        # Y-sweep (conservative)\n        by_face = by_func(XX_yf, YY_yf)\n        by_face_p = np.maximum(by_face, 0)\n        by_face_m = np.minimum(by_face, 0)\n        u_jp1 = np.roll(u_star_cons, -1, axis=0)\n        flux_y = by_face_p * u_star_cons + by_face_m * u_jp1\n        flux_y_jm1 = np.roll(flux_y, 1, axis=0)\n        u_final_cons = u_star_cons - (dt / dy) * (flux_y - flux_y_jm1)\n\n        mass_cons = np.sum(u_final_cons) * dx * dy\n        error_cons = np.abs(mass_cons - initial_mass)\n        results.append(error_cons)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "维数分裂的应用远不止于时间步进。它同样是求解大型线性系统（通常由椭圆型偏微分方程离散化而来）的强大预条件技术。在这个高级实践中，我们将探索交替方向隐式（ADI）分裂法在各向异性多孔介质流问题中的应用。你将构建一个基于维数分裂的预条件子，并通过分析预条件后算子的特征值谱，研究其性能如何随物理各向异性方向与计算网格的夹角而变化。这个练习不仅展示了维数分裂法的高度灵活性，也揭示了数值算法性能与底层物理特性之间深刻的内在联系。",
            "id": "3377961",
            "problem": "考虑用于多孔介质流的各向异性扩散算子，由散度形式的偏微分方程 $-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$ 给出，该方程定义在单位正方形域 $[0,1]\\times[0,1]$ 上，边界条件为在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件 $p=0$。在使用时间步长为 $\\Delta t$ 的后向隐式瞬态格式中，每个时间步都需要求解一个形如 $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$ 的线性系统，其中 $I$ 是单位算子，$L$ 是 $-\\nabla\\cdot\\left(K\\nabla\\cdot\\right)$ 的空间离散化，$b^n$ 是已知的右端项。交替方向隐式 (ADI) 分裂引入了一个由 $L$ 的方向分量构建的预条件子 $M$。\n\n您的任务是为瞬态步内的椭圆求解构建一个维数分裂 ADI 预条件子，并研究预处理后算子的特征值聚集如何随各向异性张量的方向变化。使用以下科学标准基础：\n\n- 各向异性张量在空间上是恒定的，由 $K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$ 给出，其中 $R(\\theta)=\\begin{pmatrix}\\cos\\theta & -\\sin\\theta\\\\\\sin\\theta & \\cos\\theta\\end{pmatrix}$ 是旋转矩阵，$k_\\parallel\\ge k_\\perp>0$ 是主扩散率，$\\theta$ 是以弧度为单位的方向角。\n- 对于常系数，算子简化为 $-\\nabla\\cdot(K\\nabla p)=-(K_{xx}\\,\\partial_{xx}p+2K_{xy}\\,\\partial_{xy}p+K_{yy}\\,\\partial_{yy}p)$，其中 $K_{xx}$，$K_{xy}$ 和 $K_{yy}$ 是 $K$ 在坐标系中的分量。\n- 在均匀网格上使用二阶中心有限差分，每个坐标方向有 $N$ 个内部点，网格间距为 $h=1/(N+1)$，并采用齐次狄利克雷边界条件。离散化：\n  1. 将一维二阶导数离散为三对角矩阵 $D_{xx}\\in\\mathbb{R}^{N\\times N}$，其对角线元素为 $-2/h^2$，次对角线元素为 $1/h^2$。\n  2. 将一维一阶导数离散为一个三对角矩阵 $D_x\\in\\mathbb{R}^{N\\times N}$，其上对角线元素为 $1/(2h)$，下对角线元素为 $-1/(2h)$（缺失邻居处的项隐式地乘以边界值，边界值为零）。\n- 通过克罗内克积构建二维离散算子：\n  1. $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$,\n  2. $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$,\n  3. $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$,\n  其中 $I_N$ 是 $N\\times N$ 单位矩阵，$\\otimes$ 表示克罗内克积。完整的离散算子为 $A=A_{xx}+A_{yy}+A_{xy}\\in\\mathbb{R}^{N^2\\times N^2}$。\n- 构建瞬态步矩阵 $S=I_{N^2}-\\Delta t\\,A$，以及 ADI 分裂预条件子 $M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$，其中 $A_x=A_{xx}$ 且 $A_y=A_{yy}$（从预条件子中排除混合导数项）。\n- 通过计算矩阵束 $(S,M)$ 的广义特征值 $\\{\\lambda_i\\}$（定义为 $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$）来量化特征值聚集，然后将聚集半径 $R=\\max_i|\\lambda_i-1|$ 报告为单个标量。\n\n实现一个完整、可运行的程序，该程序：\n- 根据上述规范构建 $S$ 和 $M$。\n- 计算广义特征值和聚集半径 $R$。\n- 在以下测试套件上评估 $R$，角度以弧度为单位指定：\n  1. $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$，\n  2. $(12,10^{-5},10,1,\\pi/4)$，\n  3. $(12,10^{-5},1,1,\\pi/6)$，\n  4. $(12,10^{-5},100,1,\\pi/8)$，\n  5. $(12,10^{-5},10,1,\\pi/2)$，\n  6. $(12,10^{-5},10,1,0.01)$。\n您的程序应生成单行输出，其中包含每个测试用例的聚集半径，格式为方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（无单位）。\n\n您的答案必须是一个用 Python 编写的完整、可运行的程序，使用指定的数值库实现上述算法。最终输出格式必须严格为“[r1,r2,r3,r4,r5,r6]”。",
            "solution": "用户要求构建和分析用于各向异性扩散方程的维数分裂交替方向隐式 (ADI) 预条件子。该分析涉及量化预处理后算子的特征值聚集情况。\n\n### 步骤 1：问题验证\n\n首先将根据所需标准验证问题陈述。\n\n#### 步骤 1.1：提取给定条件\n\n- **偏微分方程 (PDE)**：$-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$，定义在 $[0,1]\\times[0,1]$ 上。\n- **边界条件**：齐次狄利克雷边界条件，$p=0$ on $\\partial\\Omega$。\n- **瞬态格式**：后向隐式，需要求解 $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$。\n- **各向异性张量**：$K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$，其中 $R(\\theta)=\\begin{pmatrix}\\cos\\theta & -\\sin\\theta\\\\\\sin\\theta & \\cos\\theta\\end{pmatrix}$。$K$ 在空间上是常数。\n- **空间算子展开**：$L = -\\nabla\\cdot(K\\nabla\\cdot) = -(K_{xx}\\,\\partial_{xx}+2K_{xy}\\,\\partial_{xy}+K_{yy}\\,\\partial_{yy})$。\n- **离散化网格**：均匀网格，每个方向有 $N$ 个内部点，网格间距 $h=1/(N+1)$。\n- **一维离散算子**：\n    - 二阶导数：$D_{xx} \\in \\mathbb{R}^{N\\times N}$ 是一个三对角矩阵，对角线元素为 $-2/h^2$，次对角线元素为 $1/h^2$。\n    - 一阶导数：$D_x \\in \\mathbb{R}^{N\\times N}$ 是一个三对角矩阵，上对角线元素为 $1/(2h)$，下对角线元素为 $-1/(2h)$。\n- **二维离散算子**：通过与 $I_N$（$N\\times N$ 单位矩阵）进行克罗内克积 $\\otimes$ 形成。\n    - $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$\n    - $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$\n    - $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$\n    - 完整离散算子：$A=A_{xx}+A_{yy}+A_{xy} \\in \\mathbb{R}^{N^2\\times N^2}$。\n- **瞬态系统矩阵**：$S=I_{N^2}-\\Delta t\\,A$。\n- **ADI 预条件子**：$M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$，其中 $A_x=A_{xx}$ 且 $A_y=A_{yy}$。\n- **分析指标**：聚集半径 $R=\\max_i|\\lambda_i-1|$，其中 $\\{\\lambda_i\\}$ 是来自矩阵束 $(S,M)$ 的广义特征值，求解 $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$。\n- **测试套件**：\n    1. $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$\n    2. $(12,10^{-5},10,1,\\pi/4)$\n    3. $(12,10^{-5},1,1,\\pi/6)$\n    4. $(12,10^{-5},100,1,\\pi/8)$\n    5. $(12,10^{-5},10,1,\\pi/2)$\n    6. $(12,10^{-5},10,1,0.01)$\n\n#### 步骤 1.2：使用提取的给定条件进行验证\n\n1.  **科学依据**：该问题坚实地基于偏微分方程数值方法的标准理论。各向异性扩散方程、后向欧拉时间步进、有限差分离散化、用于二维算子的克罗内克积构造以及 ADI 预处理都是计算科学与工程中的经典主题。\n2.  **适定性**：问题是适定的。所有参数、矩阵和程序都有明确定义，为每个测试用例导向唯一的数值结果。所涉及的矩阵定义明确，对于给定的参数，它们将是非奇异的，确保广义特征值问题有解。\n3.  **客观性**：问题使用精确、客观的数学语言陈述。没有主观或基于意见的主张。\n4.  **完整性和一致性**：问题是自洽的。所有必要信息，包括数学公式、离散化细节、参数值以及精确的分析指标都已提供。没有矛盾之处。\n5.  **主题相关性**：问题完全属于指定的*多维偏微分方程的维数分裂*主题。\n\n#### 步骤 1.3：结论与行动\n\n问题是有效的。这是一个定义明确、科学上合理的数值实验。我将继续构建解决方案。\n\n### 步骤 2：构建解决方案\n\n解决方案涉及为每个测试用例实现指定的矩阵构建和特征值分析。该方法的核心是将连续算子转换为离散矩阵形式，然后分析所得预处理系统的谱特性。\n\n对于由元组 $(N, \\Delta t, k_\\parallel, k_\\perp, \\theta)$ 指定的每个测试用例：\n\n1.  **设置离散化参数**：网格间距为 $h = 1/(N+1)$。内部网格点总数为 $N^2$。\n\n2.  **构建一维有限差分矩阵**：\n    - 矩阵 $D_{xx}$ 离散化二阶导数 $\\partial_{xx}$。对于一个 $N \\times N$ 矩阵，其元素为 $(D_{xx})_{i,j} = (1/h^2)(\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})$，其中 $\\delta$ 是克罗内克δ。这对应于指定的三对角矩阵。\n    - 矩阵 $D_x$ 使用中心差分格式离散化一阶导数 $\\partial_x$。其元素为 $(D_x)_{i,j} = (1/(2h))(\\delta_{i,j-1} - \\delta_{i,j+1})$。这对应于指定的双对角矩阵（主对角线为零）。\n\n3.  **计算各向异性张量分量**：常数张量 $K$ 的分量由主扩散率 $k_\\parallel, k_\\perp$ 和方向角 $\\theta$ 计算得出。\n    $$K=R(\\theta)\\begin{pmatrix}k_\\parallel & 0\\\\0 & k_\\perp\\end{pmatrix}R(\\theta)^\\top = \\begin{pmatrix} k_\\parallel c^2 + k_\\perp s^2 & (k_\\parallel - k_\\perp) sc \\\\ (k_\\parallel - k_\\perp) sc & k_\\parallel s^2 + k_\\perp c^2 \\end{pmatrix}$$\n    其中 $c = \\cos\\theta$，$s = \\sin\\theta$。由此，我们确定 $K_{xx}$、$K_{yy}$ 和 $K_{xy}$。\n\n4.  **构建二维算子矩阵**：在按字典序排列的未知数网格向量上，使用克罗内克积形成二维算子。\n    - 离散拉普拉斯分量为 $L_{xx} = D_{xx} \\otimes I_N$ 和 $L_{yy} = I_N \\otimes D_{xx}$。\n    - 混合导数项为 $L_{xy} = D_x \\otimes D_x$。\n    - 完整的空间算子矩阵为 $A = -K_{xx}L_{xx} - K_{yy}L_{yy} - 2K_{xy}L_{xy}$。符号为负是因为瞬态方程中的算子 $L$ 定义为 $L = -\\nabla\\cdot(K\\nabla\\cdot)$。\n\n5.  **构建瞬态系统和预条件子**：\n    - 后向隐式步的矩阵为 $S = I_{N^2} - \\Delta t A$。\n    - ADI 预条件子是通过将 $A$ 分裂为其方向分量 $A_x = -K_{xx}L_{xx}$ 和 $A_y = -K_{yy}L_{yy}$，并忽略混合导数项 $A_{xy}$ 来构建的。预条件子为 $M = (I_{N^2} - \\Delta t A_x)(I_{N^2} - \\Delta t A_y)$。这种因式分解在实践中应用起来很高效，因为它只涉及求解三对角系统。\n\n6.  **分析特征值聚集**：通过检查预处理算子 $M^{-1}S$ 的特征值 $\\lambda_i$ 来研究 $M$ 作为 $S$ 的预条件子的有效性。这些是广义特征值问题 $S v_i = \\lambda_i M v_i$ 的解。聚集半径 $R = \\max_i |\\lambda_i-1|$ 衡量这些特征值与 $1$ 的最大偏差。较小的 $R$ 表示特征值更紧密地聚集在 $1$ 附近，这通常会导致像 GMRES 这样的克雷洛夫子空间求解器收敛得更快。广义特征值使用标准的数值库函数计算。\n\n最终的 Python 代码为所有指定的测试用例实现了此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Δt, k_parallel, k_perp, θ in radians)\n        (12, 1e-5, 10, 1, 0),\n        (12, 1e-5, 10, 1, np.pi/4),\n        (12, 1e-5, 1, 1, np.pi/6),\n        (12, 1e-5, 100, 1, np.pi/8),\n        (12, 1e-5, 10, 1, np.pi/2),\n        (12, 1e-5, 10, 1, 0.01),\n    ]\n\n    results = []\n    for N, dt, k_parallel, k_perp, theta in test_cases:\n        # ---- Discretization setup ----\n        # Grid spacing h for N interior points on [0,1]\n        h = 1.0 / (N + 1)\n        N_sq = N**2\n\n        # ---- Build 1D finite difference matrices ----\n        # D_xx for second derivative: [1, -2, 1]/h^2\n        diag_xx = -2.0 / h**2 * np.ones(N)\n        offdiag_xx = 1.0 / h**2 * np.ones(N - 1)\n        D_xx = np.diag(diag_xx) + np.diag(offdiag_xx, k=1) + np.diag(offdiag_xx, k=-1)\n\n        # D_x for first derivative: [-1, 0, 1]/(2h)\n        offdiag_x_upper = 1.0 / (2.0 * h) * np.ones(N - 1)\n        offdiag_x_lower = -1.0 / (2.0 * h) * np.ones(N - 1)\n        D_x = np.diag(offdiag_x_upper, k=1) + np.diag(offdiag_x_lower, k=-1)\n\n        I_N = np.eye(N)\n        I_N2 = np.eye(N_sq)\n\n        # ---- Calculate anisotropy tensor K components ----\n        c, s = np.cos(theta), np.sin(theta)\n        K_xx = k_parallel * c**2 + k_perp * s**2\n        K_yy = k_parallel * s**2 + k_perp * c**2\n        K_xy = (k_parallel - k_perp) * s * c\n\n        # ---- Build 2D operator matrices via Kronecker products ----\n        # The operator is L = -(K_xx*d_xx + 2*K_xy*d_xy + K_yy*d_yy)\n        # So A is the discretization of L.\n        A_xx_op = -K_xx * np.kron(D_xx, I_N)\n        A_yy_op = -K_yy * np.kron(I_N, D_xx)\n        A_xy_op = -2 * K_xy * np.kron(D_x, D_x)\n        A = A_xx_op + A_yy_op + A_xy_op\n\n        # ---- Build transient matrix S and ADI preconditioner M ----\n        S = I_N2 - dt * A\n        \n        # M is built from the ADI splitting, ignoring the mixed-derivative term\n        # The split operators Ax and Ay are defined as Axx and Ayy in the prompt.\n        M = (I_N2 - dt * A_xx_op) @ (I_N2 - dt * A_yy_op)\n\n        # ---- Compute generalized eigenvalues and clustering radius ----\n        # Solves the generalized eigenvalue problem S v = λ M v for eigenvalues λ\n        lambdas = eig(S, M, right=False)\n\n        # The clustering radius R = max|λ_i - 1|\n        R = np.max(np.abs(lambdas - 1.0))\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}