{
    "hands_on_practices": [
        {
            "introduction": "这项实践是进行数值探索的基础。我们将在一个环形域上实现极坐标拉普拉斯算子的标准有限差分近似，该区域巧妙地避开了原点处的奇点。通过“制造解方法”(Method of Manufactured Solutions)，您将把它应用于已知的调和函数来验证您实现的算子的一致性，并观察数值误差的行为——这是计算代码验证中的一项关键技能。",
            "id": "3379318",
            "problem": "考虑在极坐标中作用于一个足够光滑的标量场 $u(r,\\theta)$ 的拉普拉斯算子，该标量场定义在一个环形域上，其内径严格为正以避免在 $r=0$ 处的坐标奇点。本任务的目标是，当极坐标拉普拉斯算子的离散近似应用于在笛卡尔变量中构造并通过 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$ 映射到极坐标的精确调和函数时，验证其一致性。一致性意味着，当离散算子应用于连续方程的精确解时，随着离散化的细化，所产生的离散残差趋于零。\n\n基本原理：笛卡尔坐标中的拉普拉斯算子定义为 $\\nabla^2 u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$，其在极坐标 $(r,\\theta)$ 中的表达式是一个经过充分验证的事实，由 $\\nabla^2 u = \\partial^2 u/\\partial r^2 + (1/r)\\,\\partial u/\\partial r + (1/r^2)\\,\\partial^2 u/\\partial \\theta^2$ 给出。在偏微分方程 (PDE) 的数值解法中，一种标准方法是用在网格上计算的有限差分来替换空间导数，同时遵循坐标系所决定的结构。\n\n任务：实现一个程序，在 $(r,\\theta)$ 中构造一个均匀张量积网格，该网格在 $[r_{\\min},R]$ 上有 $N_r$ 个径向节点，在 $[0,2\\pi)$ 上有 $N_\\theta$ 个角向节点，其中角度必须以弧度解释。角向必须被视为周期性的，周期为 $2\\pi$。内径必须满足 $r_{\\min}>0$，以避免在 $r=0$ 处的奇异因子 $(1/r)$ 和 $(1/r^2)$。在此网格上，通过在 $r$ 和 $\\theta$ 方向上使用二阶中心有限差分来一致地近似三个导数项，从而定义离散极坐标拉普拉斯算子。将此离散算子应用于以下最初以笛卡尔变量编写并通过 $x=r\\cos\\theta$ 和 $y=r\\sin\\theta$ 映射到极坐标的精确调和函数：\n- $u_1(x,y) = x^2 - y^2$，映射为 $u_1(r,\\theta) = r^2 \\cos(2\\theta)$。\n- $u_2(x,y) = x$，映射为 $u_2(r,\\theta) = r \\cos(\\theta)$。\n- $u_3(x,y) = \\operatorname{Re}\\big((x+\\mathrm{i}y)^3\\big)$，映射为 $u_3(r,\\theta) = r^3 \\cos(3\\theta)$。\n- $u_4(x,y) = c$（对于常数 $c$），映射为 $u_4(r,\\theta) = c$。\n\n对于每个测试用例，通过将离散算子逐点应用于网格上的精确函数值来计算拉普拉斯算子的离散残差，并报告在所有内部径向索引 $i\\in\\{1,\\dots,N_r-2\\}$ 和所有角向索引 $j\\in\\{0,\\dots,N_\\theta-1\\}$ 上的最大绝对残差。不要在残差计算中包括 $i=0$ 和 $i=N_r-1$ 处的边界径向点，以便只使用内部二阶模板。角向必须按周期性处理，其中 $j=-1$ 和 $j=N_\\theta$ 处的邻居分别等同于 $j=N_\\theta-1$ 和 $j=0$。\n\n角度单位要求：所有角度 $\\theta$ 必须以弧度表示和解释。\n\n您必须实现程序来评估以下测试套件，其中所有量都是无量纲的：\n- 测试用例 1：$N_r=64$，$N_\\theta=64$，$r_{\\min}=0.1$，$R=1.0$，函数 $u(r,\\theta)=r^2\\cos(2\\theta)$。\n- 测试用例 2：$N_r=8$，$N_\\theta=16$，$r_{\\min}=0.1$，$R=1.0$，函数 $u(r,\\theta)=r^2\\cos(2\\theta)$。\n- 测试用例 3：$N_r=64$，$N_\\theta=64$，$r_{\\min}=10^{-3}$，$R=1.0$，函数 $u(r,\\theta)=r\\cos(\\theta)$。\n- 测试用例 4：$N_r=100$，$N_\\theta=80$，$r_{\\min}=0.05$，$R=2.0$，函数 $u(r,\\theta)=r^3\\cos(3\\theta)$。\n- 测试用例 5：$N_r=64$，$N_\\theta=64$，$r_{\\min}=0.1$，$R=1.0$，函数 $u(r,\\theta)=2$。\n\n对于每个测试用例，程序必须计算一个单一的浮点数：在指定的内部集合上的最大绝对离散残差。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中 $r_k$ 是测试用例 $k$ 的结果，顺序如上所述。\n\n期望解决方案通过计算证明，对于更精细的网格，离散残差趋于更小，并且在小的 $r_{\\min}$ 附近保持有界，从而证实了对于光滑的调和函数，离散极坐标拉普拉斯算子与连续算子的一致性。除了指定的角度单位条件外，输出不涉及任何物理单位；所有报告的值都是纯数。",
            "solution": "## 问题验证\n\n### 步骤1：提取给定信息\n\n- **拉普拉斯算子（笛卡尔坐标）**：$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n- **拉普拉斯算子（极坐标）**：$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}$。\n- **定义域**：内径为 $r_{\\min} > 0$、外径为 $R$ 的环形区域。\n- **网格**：在 $(r,\\theta)$ 中的均匀张量积网格，径向 $[r_{\\min}, R]$ 上有 $N_r$ 个节点，角向 $[0, 2\\pi)$ 上有 $N_\\theta$ 个节点。\n- **角向周期性**：角向是周期性的，周期为 $2\\pi$。所有角度均以弧度为单位。\n- **离散算子**：所有三个导数项均采用二阶中心有限差分。\n- **调和测试函数**：离散拉普拉斯算子将应用于以下映射到极坐标的精确调和函数：\n    1.  $u_1(x,y) = x^2 - y^2 \\implies u_1(r,\\theta) = r^2 \\cos(2\\theta)$。\n    2.  $u_2(x,y) = x \\implies u_2(r,\\theta) = r \\cos(\\theta)$。\n    3.  $u_3(x,y) = \\operatorname{Re}\\big((x+\\mathrm{i}y)^3\\big) \\implies u_3(r,\\theta) = r^3 \\cos(3\\theta)$。\n    4.  $u_4(x,y) = c \\implies u_4(r,\\theta) = c$。\n- **残差计算**：要计算的量是逐点离散残差的最大绝对值，该残差定义为将离散算子应用于精确函数值。该最大值取自所有内部径向索引 $i \\in \\{1, \\dots, N_r-2\\}$ 和所有角向索引 $j \\in \\{0, \\dots, N_\\theta-1\\}$。\n- **测试套件**：\n    - **用例 1**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=r^2\\cos(2\\theta)$。\n    - **用例 2**：$N_r=8$, $N_\\theta=16$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=r^2\\cos(2\\theta)$。\n    - **用例 3**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=10^{-3}$, $R=1.0$, $u(r,\\theta)=r\\cos(\\theta)$。\n    - **用例 4**：$N_r=100$, $N_\\theta=80$, $r_{\\min}=0.05$, $R=2.0$, $u(r,\\theta)=r^3\\cos(3\\theta)$。\n    - **用例 5**：$N_r=64$, $N_\\theta=64$, $r_{\\min}=0.1$, $R=1.0$, $u(r,\\theta)=2$。\n- **输出格式**：单行输出，包含每个测试用例结果的逗号分隔列表，并用方括号括起来。示例：`[r_1,r_2,r_3,r_4,r_5]`。\n\n### 步骤2：使用提取的给定信息进行验证\n\n1.  **科学上合理**：该问题在根本上是合理的。笛卡尔坐标和极坐标中拉普拉斯算子的表达式都是正确的，并且是矢量微积分和物理学中的标准。所提供的测试函数确实是调和的（即在笛卡尔坐标中 $\\nabla^2 u = 0$），这是精确解方法（Method of Manufactured Solutions）验证测试的一项关键要求。使用有限差分来近似导数是偏微分方程数值方法的基石。\n2.  **适定性**：该问题是适定的。计算每个测试用例唯一结果所需的所有参数和过程都已明确定义。网格生成、有限差分模板、周期性边界条件的处理以及计算最终残差的域都已明确无误地指定。这确保了每个测试用例都存在一个唯一、稳定且有意义的数值答案。\n3.  **客观性**：问题陈述以精确、客观的数学语言编写。它没有任何模糊性、主观性或基于观点的断言。\n4.  **完整性**：该问题是独立的。它提供了所有必要的信息，包括网格参数（$N_r, N_\\theta, r_{\\min}, R$）、测试函数的精确形式以及待计算量的精确定义。\n5.  **无其他缺陷**：该问题没有表现出任何其他缺陷，如不可形式化、矛盾、不切实际、不适定、琐碎或无法验证。它是数值分析领域中一个标准且表述清晰的问题。\n\n### 步骤3：结论与行动\n该问题是有效的。在计算数学中，验证一个数值格式的一致性是一个定义明确的任务。我现在将开始进行求解。\n\n## 解法\n\n任务是计算极坐标拉普拉斯算子的有限差分近似的一致性。通过将离散算子应用于连续方程（$\\nabla^2 u = 0$）的已知解析解，并验证当网格细化时，所得的离散残差趋近于零，来测试一致性。由于连续拉普拉斯算子为零，残差就是将离散拉普拉斯算子应用于函数的值。\n\n### 1. 网格与函数离散化\n构造一个 $(r,\\theta)$ 坐标系下的离散网格。网格点为 $(r_i, \\theta_j)$，其中：\n- $r_i = r_{\\min} + i \\cdot \\Delta r$，对于 $i \\in \\{0, 1, \\dots, N_r-1\\}$。径向步长为 $\\Delta r = \\frac{R - r_{\\min}}{N_r - 1}$。\n- $\\theta_j = j \\cdot \\Delta \\theta$，对于 $j \\in \\{0, 1, \\dots, N_\\theta-1\\}$。角向步长为 $\\Delta \\theta = \\frac{2\\pi}{N_\\theta}$。$\\theta$ 的定义域为 $[0, 2\\pi)$。\n\n函数 $u(r,\\theta)$ 在此网格上的值表示为 $u_{i,j} = u(r_i, \\theta_j)$。\n\n### 2. 有限差分近似\n极坐标拉普拉斯算子为 $\\nabla^2 u = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}$。我们使用二阶中心差分在内部网格点 $(r_i, \\theta_j)$ 处近似每一项：\n\n1.  **二阶径向导数**：\n    $$ \\left. \\frac{\\partial^2 u}{\\partial r^2} \\right|_{i,j} \\approx \\frac{u_{i+1, j} - 2u_{i, j} + u_{i-1, j}}{(\\Delta r)^2} $$\n\n2.  **一阶径向导数**：\n    $$ \\left. \\frac{1}{r} \\frac{\\partial u}{\\partial r} \\right|_{i,j} \\approx \\frac{1}{r_i} \\frac{u_{i+1, j} - u_{i-1, j}}{2 \\Delta r} $$\n\n3.  **二阶角向导数**：\n    $$ \\left. \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2} \\right|_{i,j} \\approx \\frac{1}{r_i^2} \\frac{u_{i, j+1} - 2u_{i, j} + u_{i, j-1}}{(\\Delta \\theta)^2} $$\n    角向索引按周期性处理。对于索引 $j$，其邻居为 $(j-1 \\pmod{N_\\theta})$ 和 $(j+1 \\pmod{N_\\theta})$。\n\n### 3. 离散拉普拉斯算子\n在内部点 $(i, j)$（其中 $i \\in \\{1, \\dots, N_r-2\\}$）处的离散拉普拉斯算子 $(\\nabla^2_d u)_{i,j}$ 是这三个近似值的和：\n$$ (\\nabla^2_d u)_{i,j} = \\frac{u_{i+1, j} - 2u_{i, j} + u_{i-1, j}}{(\\Delta r)^2} + \\frac{1}{r_i} \\frac{u_{i+1, j} - u_{i-1, j}}{2 \\Delta r} + \\frac{1}{r_i^2} \\frac{u_{i, j+1 \\pmod{N_\\theta}} - 2u_{i, j} + u_{i, j-1 \\pmod{N_\\theta}}}{(\\Delta \\theta)^2} $$\n\n### 4. 最大残差的计算\n残差定义为 $(\\nabla^2_d u)_{i,j}$，因为给定测试函数的精确连续拉普拉斯算子为零。程序将为每个测试用例执行以下步骤：\n1.  设置网格参数 $N_r, N_\\theta, r_{\\min}, R$。\n2.  计算网格步长 $\\Delta r$ 和 $\\Delta \\theta$。\n3.  创建坐标 $(r_i, \\theta_j)$ 的二维网格，并在每个网格点上评估指定的调和函数 $u(r, \\theta)$，以获得矩阵 $U = [u_{i,j}]$。\n4.  为所有内部径向点（即 $i \\in \\{1, \\dots, N_r-2\\}$）计算离散拉普拉斯矩阵 $(\\nabla^2_d U)$。这可以使用矢量化数组操作高效完成。\n5.  找出所得内部残差矩阵所有元素的最大绝对值。这个单一的浮点数就是该测试用例的结果。\n\n对所有五个测试用例重复此过程，并收集结果按指定格式化。例如，对于常数函数 $u=c$，所有有限差分都恒等于零，因此残差预期为 $0.0$。对于其他函数，残差是近似的截断误差，应随着网格的细化（即当 $\\Delta r, \\Delta \\theta \\to 0$ 时）而减小，从而证实该格式的一致性。",
            "answer": "```python\nimport numpy as np\n\ndef compute_max_residual(Nr, Ntheta, r_min, R, func_name):\n    \"\"\"\n    Computes the maximum absolute residual of a discrete polar Laplacian operator.\n\n    Args:\n        Nr (int): Number of radial grid points.\n        Ntheta (int): Number of angular grid points.\n        r_min (float): Inner radius.\n        R (float): Outer radius.\n        func_name (str): The name of the harmonic function to test ('u1', 'u2', 'u3', 'u4').\n\n    Returns:\n        float: The maximum absolute residual over the interior grid points.\n    \"\"\"\n    # 1. Grid and Function Discretization\n    # Define grid spacing\n    dr = (R - r_min) / (Nr - 1)\n    dtheta = 2 * np.pi / Ntheta\n\n    # Create grid coordinates\n    # r includes both endpoints. Shape: (Nr,)\n    r = np.linspace(r_min, R, Nr)\n    # theta is exclusive of 2*pi. Shape: (Ntheta,)\n    theta = np.linspace(0, 2 * np.pi, Ntheta, endpoint=False)\n\n    # Create a 2D meshgrid. R_grid and T_grid have shape (Nr, Ntheta)\n    R_grid, T_grid = np.meshgrid(r, theta, indexing='ij')\n\n    # Evaluate the test function on the grid\n    U = None\n    if func_name == 'u1':\n        # u(r,θ) = r^2 * cos(2θ)\n        U = R_grid**2 * np.cos(2 * T_grid)\n    elif func_name == 'u2':\n        # u(r,θ) = r * cos(θ)\n        U = R_grid * np.cos(T_grid)\n    elif func_name == 'u3':\n        # u(r,θ) = r^3 * cos(3θ)\n        U = R_grid**3 * np.cos(3 * T_grid)\n    elif func_name == 'u4':\n        # u(r,θ) = 2\n        U = np.full_like(R_grid, 2.0)\n\n    # 2. Finite Difference Approximation on Interior Grid\n    # The residual is only computed on interior radial points i = 1, ..., Nr-2.\n    # We use array slicing to select these points.\n    \n    # Slices of U for neighbor points\n    # U_interior has shape (Nr-2, Ntheta)\n    U_interior = U[1:-1, :]\n    # U_ip1 (i+1) and U_im1 (i-1) also have shape (Nr-2, Ntheta)\n    U_ip1 = U[2:, :]\n    U_im1 = U[:-2, :]\n\n    # Radial grid points corresponding to the interior\n    # r_interior has shape (Nr-2,). We reshape for broadcasting.\n    r_interior = r[1:-1]\n    r_interior_col = r_interior[:, np.newaxis]\n\n    # Calculate radial derivative terms\n    d2u_dr2 = (U_ip1 - 2 * U_interior + U_im1) / (dr**2)\n    du_dr_term = (1 / r_interior_col) * (U_ip1 - U_im1) / (2 * dr)\n    \n    # Calculate angular derivative term with periodic boundary conditions\n    # np.roll handles periodicity efficiently. axis=1 is the theta dimension.\n    U_jp1 = np.roll(U_interior, -1, axis=1)\n    U_jm1 = np.roll(U_interior, 1, axis=1)\n    d2u_dtheta2_term = (1 / r_interior_col**2) * (U_jp1 - 2 * U_interior + U_jm1) / (dtheta**2)\n\n    # 3. Sum terms to get the discrete Laplacian (residual)\n    residual_matrix = d2u_dr2 + du_dr_term + d2u_dtheta2_term\n    \n    # 4. Find the maximum absolute residual\n    max_abs_residual = np.max(np.abs(residual_matrix))\n    \n    return max_abs_residual\n\ndef solve():\n    \"\"\"\n    Executes the defined test suite for the discrete polar Laplacian.\n    \"\"\"\n    # (Nr, Ntheta, r_min, R, function_name)\n    test_cases = [\n        (64, 64, 0.1, 1.0, 'u1'),  # Test case 1\n        (8, 16, 0.1, 1.0, 'u1'),   # Test case 2\n        (64, 64, 1e-3, 1.0, 'u2'), # Test case 3\n        (100, 80, 0.05, 2.0, 'u3'),# Test case 4\n        (64, 64, 0.1, 1.0, 'u4'),  # Test case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        Nr, Ntheta, r_min, R, func_name = case\n        result = compute_max_residual(Nr, Ntheta, r_min, R, func_name)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然环形域是一个很好的起点，但许多物理问题是在整个圆盘上定义的，这在极坐标拉普拉斯算子中引入了原点 $r=0$ 处的坐标奇点。本练习旨在挑战您对这一奇点进行批判性思考。通过分析平滑解在原点附近的行为，您将推导出在小半径 $r=\\epsilon$ 处施加的正确人工边界条件，这是确保您的数值格式收敛到物理上正确解的关键一步。",
            "id": "3379301",
            "problem": "考虑在闭合单位圆盘 $\\Omega = \\{(r,\\theta): 0 \\le r \\le 1\\}$ 中求解泊松问题 $-\\Delta u = f$，其中右端项 $f$ 是光滑的，并服从给定的狄利克雷边界条件 $u(1,\\theta) = g(\\theta)$，其中 $g$ 是光滑的。在极坐标 $(r,\\theta)$ 中，拉普拉斯算子具有经过充分检验的形式 $\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。在极坐标网格上使用标准的有限差分法时，由于系数 $\\frac{1}{r}$ 和 $\\frac{1}{r^2}$，在原点 $r=0$ 处会遇到退化问题。为避免此问题，一种方法是排除原点周围的一个小圆盘，而在圆环 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$ 上求解，其中在 $r=\\epsilon$ 处设置了一个人工内边界，$\\epsilon > 0$ 是一个很小的数，并最终随网格尺寸趋于 $0$。在一个均匀极坐标网格上，其中 $r_i = \\epsilon + i \\Delta r$（$i = 0,1,\\dots,N_r$）且 $\\theta_j = j \\Delta \\theta$（$j = 0,1,\\dots,N_\\theta-1$），对所有 $r_i > \\epsilon$ 的内点应用标准的二阶中心差分格式来计算 $\\Delta$，并为系统补充一个在 $r=\\epsilon$ 处的边界条件。\n\n从第一性原理出发，证明在这种离散化中排除原点的合理性，并选择在 $r=\\epsilon$ 处的内边界规定，这些规定需与原点处的光滑性渐近相容，并在极限 $\\epsilon \\to 0$ 时恢复正确的解。你可以假设 $f$ 和 $g$ 是光滑的，且精确解在 $r=0$ 处也是光滑的。\n\n选择所有适用项：\n\n- A. 施加条件使 $u(\\epsilon,\\theta)$ 不依赖于 $\\theta$（即 $u(\\epsilon,\\theta)$ 等于其方位角平均值），并对该方位角平均值施加齐次诺伊曼条件，即 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$。在离散实现中，将 $u_{0,j}$ 设置为鬼点层以满足方位角均值的 $u_{0,\\cdot} = u_{2,\\cdot}$，同时约束 $u_{1,j}$ 对所有 $j$ 保持为常数。\n- B. 在内边界上对所有角度统一施加齐次诺伊曼条件，即对所有 $\\theta$ 有 $\\partial_r u(\\epsilon,\\theta) = 0$。\n- C. 在内边界上对所有角度统一施加齐次狄利克雷条件，即对所有 $\\theta$ 有 $u(\\epsilon,\\theta) = 0$。\n- D. 将 $u$ 分解为关于 $\\theta$ 的傅里叶模态，对方位角平均模态施加齐次狄利克雷条件 $u_0(\\epsilon) = 0$，而对所有非零模态施加齐次诺伊曼条件 $\\partial_r u_m(\\epsilon) = 0$（对所有整数 $m \\ge 1$）。\n- E. 将 $u$ 分解为傅里叶模态 $u(r,\\theta) = \\sum_{m\\in\\mathbb{Z}} u_m(r) e^{\\mathrm{i} m \\theta}$，并对 $m=0$ 施加齐次诺伊曼条件 $\\partial_r u_0(\\epsilon) = 0$，对所有 $m \\neq 0$ 施加齐次狄利克雷条件 $u_m(\\epsilon) = 0$。\n\n你的选择必须得到以下要求的支持：对于光滑解，$\\Delta u$ 中的所有项在 $r \\to 0$ 时保持有界，并且 $\\Omega_\\epsilon$ 上的离散格式在 $\\epsilon \\to 0$ 时收敛到正确的极限。",
            "solution": "用户希望对问题陈述进行严格验证，然后从第一性原理推导在圆盘上求解泊松方程的数值格式所需的正确内边界条件。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **方程**：泊松问题 $-\\Delta u = f$。\n- **区域**：闭合单位圆盘 $\\Omega = \\{(r,\\theta): 0 \\le r \\le 1\\}$。\n- **极坐标中的拉普拉斯算子**：$\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。\n- **外边界条件**：$u(1,\\theta) = g(\\theta)$（狄利克雷类型）。\n- **光滑性假设**：右端项 $f$、边界数据 $g$ 以及精确解 $u$ 都是光滑函数，包括在原点 $r=0$ 处。\n- **数值方法**：在均匀极坐标网格上的有限差分法。为处理 $r=0$ 处的坐标奇点，计算区域被修改为圆环 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$，其中 $\\epsilon > 0$ 是一个小参数。\n- **网格定义**：$r_i = \\epsilon + i \\Delta r$（$i = 0,1,\\dots,N_r$）和 $\\theta_j = j \\Delta \\theta$（$j = 0,1,\\dots,N_\\theta-1$）。\n- **目标**：证明排除原点的合理性，并选择在 $r=\\epsilon$ 处的内边界条件，这些条件需与解在原点处的光滑性渐近相容，并在极限 $\\epsilon \\to 0$ 时恢复正确的解。\n- **推导约束**：选择必须基于 $\\Delta u$ 中所有项在 $r \\to 0$ 时保持有界的要求。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础（关键）**：该问题描述了数值分析中的一个典型问题：偏微分方程中坐标奇点的处理。圆盘上的泊松方程、拉普拉斯算子的极坐标表示以及有限差分法的使用都是应用数学和计算物理中标准且成熟的课题。所提出的切除奇点并引入人工边界条件的技术是一种常见且有效的方法。该问题有坚实的科学原理基础。\n- **适定性**：该问题是适定的。它要求基于解的正则性推导适当的边界条件，这是将渐近分析应用于数值方法的标准程序。假设存在光滑解（由 $f$ 和 $g$ 的光滑性保证），其在原点附近的行为是唯一确定的，这反过来又指定了正确的渐近边界条件。\n- **客观性（关键）**：问题以精确、客观的数学语言陈述。它避免了模糊性和主观性。任务定义明确，需要严格的数学推导。\n\n问题设定没有表现出任何科学或事实上的不健全之处，是可形式化的、完整的、可行的和结构良好的。它是数值偏微分方程领域一个标准且非平凡的问题。\n\n**步骤3：结论和行动**\n问题陈述是**有效的**。现在开始求解过程。\n\n### 推导与求解\n\n问题要求我们为在圆盘上求解泊松方程 $-\\Delta u = f$ 的数值解确定在人工边界 $r=\\epsilon$ 处的适当边界条件。该条件必须与光滑真解在原点 $r=0$ 附近的行为一致。\n\n**排除原点的理由**\n极坐标中的拉普拉斯算子为 $\\Delta u = u_{rr} + \\frac{1}{r} u_r + \\frac{1}{r^2} u_{\\theta\\theta}$。在原点 $r=0$ 直接应用有限差分格式将涉及计算带有系数 $\\frac{1}{r}$ 和 $\\frac{1}{r^2}$ 的项，导致除以零。这是一个坐标奇点。为避免这种情况，将原点从计算网格中排除，在圆环 $\\Omega_\\epsilon = \\{(r,\\theta): \\epsilon \\le r \\le 1\\}$ 上求解问题，这使得在 $r=\\epsilon$ 处必须设置一个人工边界条件。\n\n**内边界条件的推导**\n在 $r=\\epsilon$ 处的条件必须反映真实光滑解在 $r \\to 0$ 时的行为。一个光滑解 $u$ 在原点必须有良定义的值和导数。我们通过将解分解为关于角度 $\\theta$ 的傅里叶级数来分析其行为：\n$$u(r,\\theta) = \\sum_{m=-\\infty}^{\\infty} u_m(r) e^{\\mathrm{i} m \\theta}$$\n偏微分方程 $-\\Delta u = f$ 转化为每个傅里叶模态 $u_m(r)$ 的一个常微分方程组（ODEs）：\n$$-\\left( \\frac{d^2 u_m}{dr^2} + \\frac{1}{r} \\frac{du_m}{dr} - \\frac{m^2}{r^2} u_m \\right) = f_m(r)$$\n其中 $f_m(r)$ 是 $f(r,\\theta)$ 的傅里叶模态。\n\n为了理解在 $r=0$ 处所需的行为，我们考虑相应齐次方程的通解：\n- 对于方位角平均（模态 $m=0$）：$u_0(r) = C_1 + C_2 \\ln r$。\n- 对于所有其他模态（$m \\neq 0$）：$u_m(r) = C_1 r^{|m|} + C_2 r^{-|m|}$。\n\n为了使解 $u(r,\\theta)$ 在 $r=0$ 处是光滑的（甚至只是连续的），每个模态 $u_m(r)$ 在 $r \\to 0$ 时必须是非奇异的。\n1.  **对于 $m=0$ 模态**：项 $C_2 \\ln r$ 在 $r \\to 0$ 时发散。因此，对于一个正则解，我们必须有 $C_2 = 0$。这意味着在原点附近，$u_0(r)$ 的行为像一个常数（直到由强迫项 $f_0$ 生成的项）。具体来说，对于光滑解，$u_0(r) \\approx u_0(0) + O(r^2)$。其导数为 $\\frac{du_0}{dr}(r) \\approx O(r)$，这意味着 $\\frac{du_0}{dr}(0) = 0$。正确的渐近条件是对方位角均值施加**齐次诺伊曼条件**。\n\n2.  **对于 $m \\neq 0$ 模态**：项 $C_2 r^{-|m|}$ 对任何整数 $m \\neq 0$ 在 $r \\to 0$ 时发散。因此，对于一个正则解，我们必须有 $C_2 = 0$。这意味着在原点附近，$u_m(r)$ 的行为像 $C_1 r^{|m|}$。由于 $|m| \\ge 1$，这意味着当 $r \\to 0$ 时，$u_m(r) \\to 0$。正确的渐近条件是对所有非零模态施加**齐次狄利克雷条件**。\n\n总结来说，要在 $r=\\epsilon$ 处施加的边界条件（该条件应近似于 $r=0$ 处的行为）是：\n- $\\frac{\\partial u_0}{\\partial r}(\\epsilon) = 0$\n- 对所有 $m \\in \\mathbb{Z}$，$m \\neq 0$，$u_m(\\epsilon) = 0$。\n\n### 逐项分析选项\n\n-   **A. 施加条件使 $u(\\epsilon,\\theta)$ 不依赖于 $\\theta$（即 $u(\\epsilon,\\theta)$ 等于其方位角平均值），并对该方位角平均值施加齐次诺伊曼条件，即 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$。在离散实现中，将 $u_{0,j}$ 设置为鬼点层以满足方位角均值的 $u_{0,\\cdot} = u_{2,\\cdot}$，同时约束 $u_{1,j}$ 对所有 $j$ 保持为常数。**\n    -   $u(\\epsilon,\\theta)$ 不依赖于 $\\theta$ 的条件意味着 $u(\\epsilon,\\theta) = u_0(\\epsilon)$，这又意味着对于 $m \\neq 0$ 的所有高阶傅里叶模态 $u_m(\\epsilon)$ 必须为零。这等价于施加 $u_m(\\epsilon) = 0$（对 $m \\neq 0$）。\n    -   条件 $\\partial_r \\big(\\frac{1}{2\\pi}\\int_0^{2\\pi} u(r,\\varphi)\\,d\\varphi\\big)\\big|_{r=\\epsilon} = 0$ 正是 $m=0$ 模态的齐次诺伊曼条件，即 $\\frac{\\partial u_0}{\\partial r}(\\epsilon) = 0$。\n    -   此选项在物理空间中正确描述了所需的条件。其对离散实现的描述也是一种标准的、有效的方法。\n    -   **结论：正确。**\n\n-   **B. 在内边界上对所有角度统一施加齐次诺伊曼条件，即对所有 $\\theta$ 有 $\\partial_r u(\\epsilon,\\theta) = 0$。**\n    -   这意味着对所有模态 $m$ 都有 $\\frac{\\partial u_m}{\\partial r}(\\epsilon) = 0$。这对 $m=0$ 是正确的，但对 $m \\neq 0$ 是不正确的。例如，一个光滑解可以有 $u(x,y) \\approx c x = c r \\cos\\theta$，它有一个非零的 $m=1$ 模态 $u_1(r) \\propto r$。其导数 $\\frac{\\partial u_1}{\\partial r} \\propto 1$，不为零。强行使该导数为零是错误的。\n    -   **结论：不正确。**\n\n-   **C. 在内边界上对所有角度统一施加齐次狄利克雷条件，即对所有 $\\theta$ 有 $u(\\epsilon,\\theta) = 0$。**\n    -   这意味着对所有模态 $m$ 都有 $u_m(\\epsilon) = 0$。这对 $m \\neq 0$ 是正确的，但对 $m=0$ 是不正确的。解在原点的值 $u(0,0)=u_0(0)$ 通常是非零的，由全局问题确定。强行使其为零是错误的。\n    -   **结论：不正确。**\n\n-   **D. 将 $u$ 分解为关于 $\\theta$ 的傅里叶模态，对方位角平均模态施加齐次狄利克雷条件 $u_0(\\epsilon) = 0$，而对所有非零模态施加齐次诺伊曼条件 $\\partial_r u_m(\\epsilon) = 0$（对所有整数 $m \\ge 1$）。**\n    -   此选项恰好颠倒了正确的条件。它建议对 $m=0$ 使用狄利克雷条件，对 $m \\neq 0$ 使用诺伊曼条件。\n    -   **结论：不正确。**\n\n-   **E. 将 $u$ 分解为傅里叶模态 $u(r,\\theta) = \\sum_{m\\in\\mathbb{Z}} u_m(r) e^{\\mathrm{i} m \\theta}$，并对 $m=0$ 施加齐次诺伊曼条件 $\\partial_r u_0(\\epsilon) = 0$，对所有 $m \\neq 0$ 施加齐次狄利克雷条件 $u_m(\\epsilon) = 0$。**\n    -   此选项以傅里叶模态的语言精确而正确地陈述了推导出的条件。它要求对 $m=0$ 模态施加齐次诺伊曼条件，对所有 $m \\neq 0$ 模态施加齐次狄利克雷条件。\n    -   **结论：正确。**\n\n选项 A 和 E 是同一组正确物理条件的等价陈述，其中 A 在物理空间中表述，E 在傅里叶空间中表述。两者都是有效的选择。",
            "answer": "$$\\boxed{AE}$$"
        },
        {
            "introduction": "标准的均匀网格虽然简单，但并非总是解析复杂解特征的最有效选择。这项高级实践将探讨一种强大的替代方案：在对数径向坐标 $\\rho = \\ln r$ 上均匀的网格。您将发现在此坐标变换下，网格点如何自然地聚集在原点附近，使其非常适合求解在该区域具有陡峭梯度的问题。您将推导相应的离散算子，并与均匀网格的性能进行定量比较，从而深入了解网格生成的艺术。",
            "id": "3379306",
            "problem": "您需要研究环形域上标量场 $u(r,\\theta)$ 在极坐标下的二维拉普拉斯算子的离散近似。目标是比较在 $r$ 上的均匀径向间距与在对数径向坐标 $\\rho=\\ln r$ 上的均匀间距，在解析靠近内边界 $r\\to 0$ 处的陡峭梯度方面的效果。您的分析和程序必须基于第一性原理，并且除了基础微积分和坐标定义外，不得依赖任何预先给定的离散化公式。\n\n您可以使用的基本依据是二维拉普拉斯算子的定义、极坐标变换以及微积分中的链式法则。设环形域由 $r\\in[r_\\min,r_\\max]$（其中 $r_\\min>0$）定义，且 $\\theta\\in[0,2\\pi)$（单位为弧度）。您将考虑一个在 $r=r_\\min$ 附近光滑但陡峭的函数，形式为 $u(r,\\theta)=r^\\gamma\\cos(k\\theta)$，其中 $\\gamma\\in(0,1)$ 且 $k\\in\\mathbb{N}$。\n\n您必须从使用标准坐标变换和链式法则从笛卡尔坐标下的拉普拉斯算子推导出的极坐标下的连续拉普拉斯算子出发，然后在两种设置下推导相容的二阶中心差分近似：\n- 在径向坐标 $r$ 上使用均匀网格，在角坐标 $\\theta$ 上使用均匀网格，并在 $\\theta$ 方向上施加周期性边界条件。\n- 在对数径向坐标 $\\rho=\\ln r$ 上使用均匀网格，在角坐标 $\\theta$ 上使用均匀网格，同样在 $\\theta$ 方向上施加周期性边界条件。\n\n在这两种设置中，您都应只在内部径向节点上计算离散拉普拉斯算子（将第一个和最后一个径向节点排除在模板之外，以避免边界处理的复杂性）。在 $\\theta$ 方向上，利用周期性在所有角向节点上构建中心模板。角度单位是弧度。\n\n为了量化精度，请将离散拉普拉斯算子与解析得到的 $u(r,\\theta)$ 的精确连续拉普拉斯算子进行比较。在所有内部径向节点和所有角向节点上使用面积加权的 $L^2$ 相对误差，其中权重由在网格上近似的极坐标面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 给出。具体来说，如果 $D_h u$ 表示离散拉普拉斯算子，$D u$ 表示精确拉普拉斯算子，您的相对误差应为\n$$\nE = \\frac{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D_h u(r_i,\\theta_j)-D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}},\n$$\n其中 $w_{i,j}$ 使用相容的内部节点径向间距 $\\mathrm{d}r_i$（例如，在内部节点上 $\\mathrm{d}r_i=\\frac{1}{2}(r_{i+1}-r_{i-1})$）来近似节点 $(r_i,\\theta_j)$ 处的面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$。在均匀 $\\rho$ 的情况下，您应该一致地应用坐标变换，并仍然使用 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$ 在物理空间中对误差进行加权。\n\n此外，报告一个能够捕捉对数间距近原点加密优势的分辨率度量。将近原点分辨率增益 $G$ 定义为\n$$\nG=\\frac{\\Delta r_{\\min}^{\\text{uniform-}r}}{\\Delta r_{\\min}^{\\text{uniform-}\\rho}},\n$$\n其中 $\\Delta r_{\\min}^{\\text{uniform-}r}$ 是均匀 $r$ 网格上前两个径向节点之间的最小径向间距，而 $\\Delta r_{\\min}^{\\text{uniform-}\\rho}$ 是在 $\\rho$ 上均匀的网格上前两个径向节点之间的最小径向间距。应为每个测试案例计算该比率 $G$。\n\n实现这两种离散化方案并计算：\n- $E_r$：均匀 $r$ 网格上离散拉普拉斯算子的面积加权 $L^2$ 相对误差，\n- $E_\\rho$：均匀 $\\rho$ 网格上离散拉普拉斯算子的面积加权 $L^2$ 相对误差，\n- $Q=E_\\rho/E_r$：比较两种离散化方案的误差比，\n- $G$：如上定义的近原点分辨率增益。\n\n您的程序必须评估以下参数集构成的测试套件，这些参数集涵盖了一系列行为，包括一般情况、近原点的陡峭梯度、粗分辨率和高角频率。角度单位为弧度。\n\n测试套件：\n- 案例 1：$r_\\min=1\\times 10^{-3}$，$r_\\max=1$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=3$。\n- 案例 2：$r_\\min=1\\times 10^{-6}$，$r_\\max=1$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=3$。\n- 案例 3：$r_\\min=1\\times 10^{-3}$，$r_\\max=1$，$N_r=50$，$N_\\theta=64$，$\\gamma=0.2$，$k=3$。\n- 案例 4：$r_\\min=1\\times 10^{-3}$，$r_\\max=10$，$N_r=200$，$N_\\theta=128$，$\\gamma=0.2$，$k=8$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中首先是案例 1 的四个值 $[E_{r,1},E_{\\rho,1},Q_1,G_1]$，然后依次是案例 2、案例 3 和案例 4 的值，所有值合并成一个扁平列表。例如，输出格式必须为\n$[E_{r,1},E_{\\rho,1},Q_1,G_1,E_{r,2},E_{\\rho,2},Q_2,G_2,E_{r,3},E_{\\rho,3},Q_3,G_3,E_{r,4},E_{\\rho,4},Q_4,G_4]$。",
            "solution": "本问题的目标是推导并比较两种基于有限差分的数值近似方法，用于求解极坐标下的拉普拉斯算子，并应用于在原点附近表现出陡峭梯度的函数。比较将在由 $r \\in [r_\\min, r_\\max]$ 和 $\\theta \\in [0, 2\\pi)$ 定义的环形域上进行。这两种方案分别基于 $(r, \\theta)$ 坐标下的均匀网格和对数-极坐标 $(\\rho, \\theta)$ 下的均匀网格，其中 $\\rho = \\ln r$。\n\n### 1. 连续拉普拉斯算子\n\n分析从笛卡尔坐标 $(x, y)$ 下的拉普拉斯算子 $\\nabla^2$ 开始：\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\n$$\n到极坐标的变换由 $x = r\\cos\\theta$ 和 $y = r\\sin\\theta$ 给出。使用链式法则变换偏导数，可以得到极坐标下拉普拉斯算子的众所周知的表达式：\n$$\n\\nabla^2 u(r, \\theta) = \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r} \\frac{\\partial u}{\\partial r} + \\frac{1}{r^2} \\frac{\\partial^2 u}{\\partial \\theta^2}\n$$\n这种形式适用于在 $r$ 上具有均匀间距的网格上的离散化。\n\n对于第二种情况，我们引入对数径向坐标 $\\rho = \\ln r$，这意味着 $r = e^\\rho$。我们使用链式法则变换径向导数：\n$$\n\\frac{\\partial u}{\\partial r} = \\frac{\\partial u}{\\partial \\rho} \\frac{\\mathrm{d}\\rho}{\\mathrm{d}r} = \\frac{\\partial u}{\\partial \\rho} \\frac{1}{r}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial r^2} = \\frac{\\partial}{\\partial r}\\left(\\frac{1}{r} \\frac{\\partial u}{\\partial \\rho}\\right) = -\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r} \\frac{\\partial}{\\partial r}\\left(\\frac{\\partial u}{\\partial \\rho}\\right) = -\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\rho^2}\n$$\n将这些代入极坐标拉普拉斯公式可得：\n$$\n\\nabla^2 u = \\left(-\\frac{1}{r^2}\\frac{\\partial u}{\\partial \\rho} + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\rho^2}\\right) + \\frac{1}{r}\\left(\\frac{1}{r} \\frac{\\partial u}{\\partial \\rho}\\right) + \\frac{1}{r^2}\\frac{\\partial^2 u}{\\partial \\theta^2}\n$$\n关于 $\\rho$ 的一阶导数项相互抵消，得到一个非常简洁的形式：\n$$\n\\nabla^2 u(\\rho, \\theta) = \\frac{1}{r^2} \\left( \\frac{\\partial^2 u}{\\partial \\rho^2} + \\frac{\\partial^2 u}{\\partial \\theta^2} \\right) = e^{-2\\rho} \\left( \\frac{\\partial^2 u}{\\partial \\rho^2} + \\frac{\\partial^2 u}{\\partial \\theta^2} \\right)\n$$\n这种形式是有利的，因为括号内的微分算子是 $(\\rho, \\theta)$ 坐标下的标准笛卡尔拉普拉斯算子，它天然适用于在 $\\rho$ 和 $\\theta$ 上具有均匀间距的网格。\n\n### 2. 测试函数的解析拉普拉斯算子\n\n问题指定了测试函数 $u(r,\\theta) = r^\\gamma\\cos(k\\theta)$。我们使用极坐标公式计算其精确的拉普拉斯算子，记为 $D u$。所需的偏导数是：\n$$\n\\frac{\\partial u}{\\partial r} = \\gamma r^{\\gamma-1} \\cos(k\\theta)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial r^2} = \\gamma(\\gamma-1) r^{\\gamma-2} \\cos(k\\theta)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial \\theta^2} = -k^2 r^\\gamma \\cos(k\\theta)\n$$\n将这些代入极坐标拉普拉斯方程：\n$$\nD u = \\nabla^2 u = \\gamma(\\gamma-1) r^{\\gamma-2} \\cos(k\\theta) + \\frac{1}{r} (\\gamma r^{\\gamma-1} \\cos(k\\theta)) + \\frac{1}{r^2} (-k^2 r^\\gamma \\cos(k\\theta))\n$$\n$$\nD u = (\\gamma(\\gamma-1) + \\gamma - k^2) r^{\\gamma-2} \\cos(k\\theta) = (\\gamma^2 - k^2) r^{\\gamma-2} \\cos(k\\theta)\n$$\n这就是将与数值近似进行比较的解析表达式。\n\n### 3. 网格生成与离散化\n\n我们在域上定义两种类型的网格，它们在径向都有 $N_r$ 个点，在角向都有 $N_\\theta$ 个点。两种情况下的角向网格都是均匀的：$\\theta_j = j \\Delta\\theta$，其中 $j=0, 1, \\dots, N_\\theta-1$，且 $\\Delta\\theta = 2\\pi/N_\\theta$。\n\n#### 3.1. 均匀 $(r, \\theta)$ 网格\n径向节点均匀分布：$r_i = r_\\min + i \\Delta r$，其中 $i=0, 1, \\dots, N_r-1$，且 $\\Delta r = (r_\\max - r_\\min)/(N_r-1)$。我们在内部节点 $(r_i, \\theta_j)$ 处对极坐标拉普拉斯算子应用二阶中心差分公式：\n$$\n(D_h u)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\Delta r)^2} + \\frac{1}{r_i}\\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta r} + \\frac{1}{r_i^2}\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\Delta\\theta)^2}\n$$\n该公式在内部径向节点 $i=1, \\dots, N_r-2$ 处进行计算。对于角向导数，周期性意味着 $u_{i,N_\\theta} = u_{i,0}$ 和 $u_{i,-1} = u_{i,N_\\theta-1}$。\n\n#### 3.2. 均匀 $(\\rho, \\theta)$ 网格\n对数径向节点均匀分布：$\\rho_i = \\rho_\\min + i \\Delta\\rho$，其中 $i=0, 1, \\dots, N_r-1$，且 $\\rho_\\min = \\ln r_\\min$，$\\rho_\\max = \\ln r_\\max$，以及 $\\Delta\\rho = (\\rho_\\max - \\rho_\\min)/(N_r-1)$。物理径向节点则为 $r_i = e^{\\rho_i}$。使用 $(\\rho, \\theta)$ 坐标系中简化后的拉普拉斯形式，在 $(r_i, \\theta_j)$ 处的离散算子为：\n$$\n(D_h u)_{i,j} = \\frac{1}{r_i^2} \\left(\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\Delta\\rho)^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\Delta\\theta)^2}\\right)\n$$\n这同样在 $i=1, \\dots, N_r-2$ 处进行计算，并对 $\\theta$ 索引进行周期性处理。\n\n### 4. 误差与分辨率度量\n\n每种离散化方案的精度由面积加权的 $L^2$ 相对误差 $E$ 来量化：\n$$\nE = \\frac{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D_h u(r_i,\\theta_j)-D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}{\\left(\\sum_{i,j} w_{i,j}\\,\\left(D u(r_i,\\theta_j)\\right)^2\\right)^{1/2}}\n$$\n求和范围是内部径向节点（$i=1, \\dots, N_r-2$）和所有角向节点（$j=0, \\dots, N_\\theta-1$）。面积权重 $w_{i,j}$ 近似了节点 $(r_i, \\theta_j)$ 处的极坐标面积元 $r\\,\\mathrm{d}r\\,\\mathrm{d}\\theta$。它由 $w_{i,j} = r_i \\Delta r_i \\Delta\\theta$ 给出，其中 $\\Delta r_i = \\frac{1}{2}(r_{i+1}-r_{i-1})$ 是中心径向单元的宽度。\n- 对于均匀 $r$ 网格，$\\Delta r_i = \\Delta r$。\n- 对于均匀 $\\rho$ 网格，$\\Delta r_i = \\frac{1}{2}(e^{\\rho_i+\\Delta\\rho} - e^{\\rho_i-\\Delta\\rho}) = r_i \\sinh(\\Delta\\rho)$。\n\n为了比较网格，我们计算误差比 $Q = E_\\rho / E_r$，其中 $E_r$ 和 $E_\\rho$ 分别是均匀 $r$ 网格和均匀 $\\rho$ 网格的误差。\n\n近原点分辨率增益 $G$ 定义为两种网格第一个径向单元宽度的比值：\n$$\nG = \\frac{\\Delta r_{\\min}^{\\text{uniform-}r}}{\\Delta r_{\\min}^{\\text{uniform-}\\rho}} = \\frac{r_1^{\\text{uniform}}-r_0^{\\text{uniform}}}{r_1^{\\text{log}}-r_0^{\\text{log}}} = \\frac{\\Delta r}{r_\\min (e^{\\Delta\\rho}-1)}\n$$\n该度量量化了对数网格在内边界 $r=r_\\min$ 附近比均匀网格精细多少。这些推导出的公式构成了数值实现的基础。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def calculate_metrics_for_case(r_min, r_max, N_r, N_theta, gamma, k):\n        \"\"\"\n        Calculates the error and resolution metrics for a single test case.\n\n        Args:\n            r_min (float): Minimum radius of the annulus.\n            r_max (float): Maximum radius of the annulus.\n            N_r (int): Number of radial grid points.\n            N_theta (int): Number of angular grid points.\n            gamma (float): Exponent in the radial part of the test function.\n            k (int): Wavenumber in the angular part of the test function.\n\n        Returns:\n            list: A list containing [E_r, E_rho, Q, G].\n        \"\"\"\n        # Define the exact analytical functions\n        u_exact_func = lambda r, theta: (r**gamma) * np.cos(k * theta)\n        Du_exact_func = lambda r, theta: (gamma**2 - k**2) * (r**(gamma - 2)) * np.cos(k * theta)\n        \n        # --- Grid Parameters ---\n        theta = np.linspace(0, 2*np.pi, N_theta, endpoint=False)\n        delta_theta = 2 * np.pi / N_theta\n\n        # --- Grid 1: Uniform in r ---\n        \n        # Grid setup\n        r_uniform = np.linspace(r_min, r_max, N_r)\n        delta_r = (r_max - r_min) / (N_r - 1)\n        R_uniform, THETA = np.meshgrid(r_uniform, theta, indexing='ij')\n\n        # Evaluate function on the grid\n        U_r_grid = u_exact_func(R_uniform, THETA)\n\n        # Compute discrete Laplacian (interior radial nodes only)\n        # Slicing extracts interior points: i from 1 to N_r-2\n        U_r_interior = U_r_grid[1:-1, :]\n        u_im1 = U_r_grid[:-2, :]\n        u_ip1 = U_r_grid[2:, :]\n        # np.roll handles periodic boundary conditions in theta\n        u_jm1 = np.roll(U_r_grid, 1, axis=1)[1:-1, :]\n        u_jp1 = np.roll(U_r_grid, -1, axis=1)[1:-1, :]\n        \n        R_interior_2d = R_uniform[1:-1, :]\n        \n        d2u_dr2 = (u_ip1 - 2*U_r_interior + u_im1) / delta_r**2\n        du_dr = (u_ip1 - u_im1) / (2 * delta_r)\n        d2u_dtheta2 = (u_jp1 - 2*U_r_interior + u_jm1) / delta_theta**2\n        \n        DhU_r_grid = d2u_dr2 + (1/R_interior_2d) * du_dr + (1/R_interior_2d**2) * d2u_dtheta2\n        \n        # Error calculation for uniform-r grid\n        Du_r_grid = Du_exact_func(R_interior_2d, THETA[1:-1, :])\n        w_r = R_interior_2d[:, 0] * delta_r * delta_theta\n        w_r_2d = w_r[:, np.newaxis]\n\n        err_norm_sq_r = np.sum(w_r_2d * (DhU_r_grid - Du_r_grid)**2)\n        exact_norm_sq_r = np.sum(w_r_2d * Du_r_grid**2)\n        E_r = np.sqrt(err_norm_sq_r / exact_norm_sq_r)\n\n        # --- Grid 2: Uniform in rho = ln(r) ---\n        \n        # Grid setup\n        rho_min, rho_max = np.log(r_min), np.log(r_max)\n        rho_uniform = np.linspace(rho_min, rho_max, N_r)\n        delta_rho = (rho_max - rho_min) / (N_r - 1)\n        r_log = np.exp(rho_uniform)\n        R_log, THETA_log = np.meshgrid(r_log, theta, indexing='ij')\n\n        # Evaluate function on the grid\n        U_rho_grid = u_exact_func(R_log, THETA_log)\n\n        # Compute discrete Laplacian (interior radial nodes only)\n        U_rho_interior = U_rho_grid[1:-1, :]\n        u_im1_rho = U_rho_grid[:-2, :]\n        u_ip1_rho = U_rho_grid[2:, :]\n        u_jm1_rho = np.roll(U_rho_grid, 1, axis=1)[1:-1, :]\n        u_jp1_rho = np.roll(U_rho_grid, -1, axis=1)[1:-1, :]\n\n        R_log_interior_2d = R_log[1:-1, :]\n\n        d2u_drho2 = (u_ip1_rho - 2*U_rho_interior + u_im1_rho) / delta_rho**2\n        d2u_dtheta2_rho = (u_jp1_rho - 2*U_rho_interior + u_jm1_rho) / delta_theta**2\n\n        DhU_rho_grid = (1/R_log_interior_2d**2) * (d2u_drho2 + d2u_dtheta2_rho)\n\n        # Error calculation for uniform-rho grid\n        Du_rho_grid = Du_exact_func(R_log_interior_2d, THETA_log[1:-1, :])\n        dr_i_log = 0.5 * (r_log[2:] - r_log[:-2]) # dr_i = 0.5 * (r_{i+1} - r_{i-1})\n        w_rho = r_log[1:-1] * dr_i_log * delta_theta\n        w_rho_2d = w_rho[:, np.newaxis]\n\n        err_norm_sq_rho = np.sum(w_rho_2d * (DhU_rho_grid - Du_rho_grid)**2)\n        exact_norm_sq_rho = np.sum(w_rho_2d * Du_rho_grid**2)\n        E_rho = np.sqrt(err_norm_sq_rho / exact_norm_sq_rho)\n\n        # --- Final Metrics Q and G ---\n        Q = E_rho / E_r\n        \n        delta_r_min_uniform = delta_r\n        delta_r_min_log = r_log[1] - r_log[0]\n        G = delta_r_min_uniform / delta_r_min_log\n        \n        return [E_r, E_rho, Q, G]\n\n    # Test suite defined in the problem statement\n    test_cases = [\n        # (r_min, r_max, N_r, N_theta, gamma, k)\n        (1e-3, 1.0, 200, 128, 0.2, 3),\n        (1e-6, 1.0, 200, 128, 0.2, 3),\n        (1e-3, 1.0, 50, 64, 0.2, 3),\n        (1e-3, 10.0, 200, 128, 0.2, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_metrics_for_case(*case)\n        results.extend(case_results)\n\n    # Format the final output as a single comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}