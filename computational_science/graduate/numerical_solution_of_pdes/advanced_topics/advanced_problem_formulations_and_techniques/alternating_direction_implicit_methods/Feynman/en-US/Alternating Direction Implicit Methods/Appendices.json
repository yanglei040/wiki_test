{
    "hands_on_practices": [
        {
            "introduction": "The best way to understand an algorithm is to implement it. This first exercise  is a foundational practice in computational physics: solving the two-dimensional heat equation using the Peaceman–Rachford ADI method. By translating the scheme into code, you will gain direct experience with the core mechanism of ADI—decomposing a 2D implicit problem into a sequence of easily solvable 1D tridiagonal systems—and verify your implementation against an exact analytical solution.",
            "id": "2446320",
            "problem": "Consider the two-dimensional heat equation on the unit square with homogeneous Dirichlet boundary conditions and a separable analytic solution. Let $u(x,y,t)$ satisfy\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + \\frac{\\partial^2 u}{\\partial y^2}(x,y,t) \\right), \\quad (x,y)\\in (0,1)\\times(0,1), \\; t\\in (0,T],\n$$\nwith $u(x,y,t) = 0$ for $(x,y)$ on the boundary $\\partial([0,1]\\times[0,1])$ and $t\\ge 0$. The initial condition is\n$$\nu(x,y,0) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y),\n$$\nwhich yields the exact solution\n$$\nu(x,y,t) \\;=\\; \\sin(m\\pi x)\\,\\sin(n\\pi y)\\,\\exp\\!\\left( -\\,\\kappa \\pi^2 (m^2+n^2)\\, t \\right).\n$$\nDiscretize the spatial domain with $N_x$ and $N_y$ interior points in the $x$- and $y$-directions, respectively. Let $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$, and let the interior grid points be $(x_i,y_j) = (i\\,h_x, j\\,h_y)$ for $i\\in\\{1,\\dots,N_x\\}$ and $j\\in\\{1,\\dots,N_y\\}$. Discretize time with time step $\\Delta t$ such that $N_t = T/\\Delta t$ is an integer and $t^n = n\\,\\Delta t$ for $n\\in\\{0,1,\\dots,N_t\\}$.\n\nUse the Peaceman–Rachford Alternating Direction Implicit (ADI) scheme to advance the solution from $t^n$ to $t^{n+1}$ via the two-stage update at each time step. Define the interior grid function $U^n_{i,j} \\approx u(x_i,y_j,t^n)$. With $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ and $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$, the two half-steps are:\n$$\n\\text{Stage 1:}\\quad\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n,\n$$\n$$\n\\text{Stage 2:}\\quad\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star},\n$$\nwhere $A_x$ and $A_y$ are the standard second-difference operators acting along $x$ and $y$ on interior points with homogeneous Dirichlet boundary values outside the interior. Concretely, for interior indices,\n$$\n(A_x U)_{i,j} \\;=\\; U_{i-1,j} - 2U_{i,j} + U_{i+1,j},\\qquad\n(A_y U)_{i,j} \\;=\\; U_{i,j-1} - 2U_{i,j} + U_{i,j+1},\n$$\nwith the understanding that any $U$ value indexed outside the interior uses the boundary value $0$.\n\nImplement this scheme on the interior grid and advance exactly $N_t$ full steps to time $T$. For each test case below, compute the relative discrete $L^2$ error $\\varepsilon$ at time $T$,\n$$\n\\varepsilon \\;=\\; \\frac{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(U^{N_t}_{i,j} - u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}}{\\left( \\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\big(u(x_i,y_j,T)\\big)^2\\, h_x h_y \\right)^{1/2}},\n$$\nwhich is dimensionless.\n\nTest Suite:\n- Case $1$ (general case): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 20$, $N_y = 20$, $\\Delta t = 10^{-4}$, $T = 10^{-2}$.\n- Case $2$ (anisotropic spatial frequencies and grid): $\\kappa = 1$, $m = 2$, $n = 1$, $N_x = 12$, $N_y = 8$, $\\Delta t = 5\\times 10^{-4}$, $T = 2\\times 10^{-2}$.\n- Case $3$ (coarse grid and large time step): $\\kappa = 1$, $m = 1$, $n = 1$, $N_x = 2$, $N_y = 2$, $\\Delta t = 10^{-1}$, $T = 10^{-1}$.\n- Case $4$ (finer grid and small time step): $\\kappa = 1$, $m = 3$, $n = 2$, $N_x = 50$, $N_y = 50$, $\\Delta t = 5\\times 10^{-5}$, $T = 5\\times 10^{-3}$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_k$ is the relative discrete $L^2$ error $\\varepsilon$ computed for the corresponding test case in the order listed above. The program must be fully self-contained and produce these four numbers without requiring any user input or external files.",
            "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational science: the numerical solution of the two-dimensional heat equation using the Peaceman-Rachford Alternating Direction Implicit (ADI) scheme. All parameters and definitions required for a unique numerical solution are provided, and the task is a direct application of established numerical methods.\n\nThe objective is to solve the two-dimensional heat equation\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\non a unit square domain $(x,y)\\in (0,1)\\times(0,1)$ with homogeneous Dirichlet boundary conditions. The provided initial condition $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ corresponds to a known analytical solution, which serves as a benchmark for verifying the accuracy of the numerical implementation.\n\nThe Peaceman-Rachford ADI method is a finite difference scheme that is second-order accurate in both space and time, and it is unconditionally stable for the heat equation. Its principal advantage lies in its computational efficiency. A fully implicit two-dimensional scheme would require solving a large, sparse linear system with a block-tridiagonal structure. The ADI method circumvents this by splitting the time step $\\Delta t$ into two half-steps. Each half-step is implicit only in one spatial direction, which results in systems of equations that are merely tridiagonal.\n\nThe method advances the discrete solution $U^n$, an approximation of $u(x,y,t^n)$ on the grid, to $U^{n+1}$ via an intermediate step $U^{\\star}$. The grid is defined by $N_x \\times N_y$ interior points, with spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$.\n\nThe two stages of the ADI scheme are:\n\nStage 1: Implicit in the $x$-direction.\n$$\n\\big(I - \\lambda_x A_x\\big)\\, U^{\\star} \\;=\\; \\big(I + \\lambda_y A_y\\big)\\, U^n\n$$\nHere, $\\lambda_x = \\kappa \\Delta t /(2 h_x^2)$ and $\\lambda_y = \\kappa \\Delta t /(2 h_y^2)$. The operator $A_x$ is the one-dimensional second-difference operator in $x$, and $A_y$ is the corresponding operator in $y$. For each grid row, indexed by $j \\in \\{1, \\dots, N_y\\}$, this equation forms an independent tridiagonal system of $N_x$ linear equations for the unknowns $U^{\\star}_{1,j}, \\dots, U^{\\star}_{N_x,j}$. The system for a given row $j$ is:\n$$\n-\\lambda_x U^{\\star}_{i-1,j} + (1 + 2\\lambda_x) U^{\\star}_{i,j} - \\lambda_x U^{\\star}_{i+1,j} \\;=\\; d_{i,j}, \\quad i \\in \\{1, \\dots, N_x\\}\n$$\nwhere $d = (I + \\lambda_y A_y)U^n$ is the right-hand side, which is known from the solution at time $t^n$. The boundary conditions imply $U^{\\star}_{0,j} = U^{\\star}_{N_x+1,j} = 0$.\n\nStage 2: Implicit in the $y$-direction.\n$$\n\\big(I - \\lambda_y A_y\\big)\\, U^{n+1} \\;=\\; \\big(I + \\lambda_x A_x\\big)\\, U^{\\star}\n$$\nFollowing the first stage, this equation is solved for $U^{n+1}$. For each grid column, indexed by $i \\in \\{1, \\dots, N_x\\}$, this forms an independent tridiagonal system of $N_y$ linear equations for the unknowns $U^{n+1}_{i,1}, \\dots, U^{n+1}_{i,N_y}$. The system for a given column $i$ is:\n$$\n-\\lambda_y U^{n+1}_{i,j-1} + (1 + 2\\lambda_y) U^{n+1}_{i,j} - \\lambda_y U^{n+1}_{i,j+1} \\;=\\; e_{i,j}, \\quad j \\in \\{1, \\dots, N_y\\}\n$$\nwhere $e = (I + \\lambda_x A_x)U^{\\star}$ is the right-hand side, known from the intermediate solution $U^{\\star}$. The boundary conditions imply $U^{n+1}_{i,0} = U^{n+1}_{i,N_y+1} = 0$.\n\nThe implementation strategy is as follows:\n1.  Initialize the solution. A two-dimensional array $U$ of size $N_y \\times N_x$ is initialized with the values from the initial condition $u(x,y,0) = \\sin(m\\pi x)\\sin(n\\pi y)$ evaluated at the interior grid points $(x_i, y_j)$.\n2.  Construct the tridiagonal system matrices. More precisely, we construct the banded representations of the matrices $(I-\\lambda_x A_x)$ and $(I-\\lambda_y A_y)$ required by a numerical solver.\n3.  Iterate for $N_t = T/\\Delta t$ time steps. In each step:\n    a. Calculate the right-hand side of Stage 1, $RHS_1 = (I + \\lambda_y A_y)U^n$. This is achieved using vectorized array operations on $U^n$, accounting for the zero Dirichlet boundary conditions.\n    b. Solve the $N_y$ tridiagonal systems for the rows of $U^{\\star}$. This is done efficiently using a vectorized call to a banded linear system solver, such as `scipy.linalg.solve_banded`, by transposing the $RHS_1$ matrix.\n    c. Calculate the right-hand side of Stage 2, $RHS_2 = (I + \\lambda_x A_x)U^{\\star}$, again using vectorized operations on the intermediate solution $U^{\\star}$.\n    d. Solve the $N_x$ tridiagonal systems for the columns of $U^{n+1}$. This is a direct application of the banded solver to the columns of $RHS_2$.\n    e. Update the solution: $U \\leftarrow U^{n+1}$.\n4.  After the final time step, calculate the exact solution $u(x,y,T)$ on the same grid.\n5.  Compute the relative discrete $L^2$ error, $\\varepsilon$. The formula provided is equivalent to the ratio of the Frobenius norms of the error matrix and the exact solution matrix:\n    $$\n    \\varepsilon = \\frac{|| U^{N_t} - u(\\cdot, \\cdot, T) ||_F}{|| u(\\cdot, \\cdot, T) ||_F}\n    $$\n    where $||A||_F = \\left(\\sum_{i,j} |A_{ij}|^2\\right)^{1/2}$. This is computationally straightforward.\n\nThis procedure is systematically applied to the four test cases specified in the problem statement. The final output consists of the computed error $\\varepsilon$ for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the 2D heat equation for all test cases\n    using the Peaceman-Rachford ADI method and compute the errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, m, n, Nx, Ny, dt, T)\n        (1.0, 1, 1, 20, 20, 1e-4, 1e-2),\n        (1.0, 2, 1, 12, 8, 5e-4, 2e-2),\n        (1.0, 1, 1, 2, 2, 1e-1, 1e-1),\n        (1.0, 3, 2, 50, 50, 5e-5, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_one_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single set of parameters.\n    \"\"\"\n    kappa, m, n, Nx, Ny, dt, T = params\n\n    # 1. Calculate derived parameters\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    Nt = round(T / dt)  # Problem guarantees this is integer\n\n    lx = kappa * dt / (2.0 * hx**2)\n    ly = kappa * dt / (2.0 * hy**2)\n\n    # 2. Create spatial grid\n    x = np.linspace(hx, 1.0 - hx, Nx)\n    y = np.linspace(hy, 1.0 - hy, Ny)\n    X, Y = np.meshgrid(x, y) # X has shape (Ny, Nx), Y has shape (Ny, Nx)\n\n    # 3. Set initial condition\n    U = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y)\n\n    # 4. Construct banded matrices for the tridiagonal solvers\n    # Stage 1: systems in x-direction (size Nx)\n    ab_x = np.zeros((3, Nx))\n    ab_x[0, 1:] = -lx\n    ab_x[1, :] = 1.0 + 2.0 * lx\n    ab_x[2, :-1] = -lx\n\n    # Stage 2: systems in y-direction (size Ny)\n    ab_y = np.zeros((3, Ny))\n    ab_y[0, 1:] = -ly\n    ab_y[1, :] = 1.0 + 2.0 * ly\n    ab_y[2, :-1] = -ly\n\n    # 5. Time-stepping loop\n    for _ in range(Nt):\n        # --- Stage 1: (I - lx*Ax) U_star = (I + ly*Ay) U ---\n\n        # Calculate RHS_1 = (I + ly*Ay) * U\n        # Ay applied to columns of U, with homogeneous Dirichlet BCs\n        RHS1 = np.zeros_like(U)\n        if Ny > 1:\n            RHS1[1:-1, :] = U[1:-1, :] + ly * (U[0:-2, :] - 2.0 * U[1:-1, :] + U[2:, :])\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :] + U[1, :])      # j=0\n            RHS1[-1, :] = U[-1, :] + ly * (U[-2, :] - 2.0 * U[-1, :])  # j=Ny-1\n        else: # Ny == 1\n            RHS1[0, :] = U[0, :] + ly * (-2.0 * U[0, :])\n\n        # Solve for U_star (systems are along rows)\n        # We transpose RHS1 to feed rows as columns to solve_banded\n        U_star_T = solve_banded((1, 1), ab_x, RHS1.T, overwrite_ab=False, overwrite_b=False)\n        U_star = U_star_T.T\n\n        # --- Stage 2: (I - ly*Ay) U_np1 = (I + lx*Ax) U_star ---\n        \n        # Calculate RHS_2 = (I + lx*Ax) * U_star\n        # Ax applied to rows of U_star, with homogeneous Dirichlet BCs\n        RHS2 = np.zeros_like(U_star)\n        if Nx > 1:\n            RHS2[:, 1:-1] = U_star[:, 1:-1] + lx * (U_star[:, 0:-2] - 2.0 * U_star[:, 1:-1] + U_star[:, 2:])\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0] + U_star[:, 1])    # i=0\n            RHS2[:, -1] = U_star[:, -1] + lx * (U_star[:, -2] - 2.0 * U_star[:, -1])  # i=Nx-1\n        else: # Nx == 1\n            RHS2[:, 0] = U_star[:, 0] + lx * (-2.0 * U_star[:, 0])\n\n        # Solve for U_np1 (systems are along columns)\n        U_np1 = solve_banded((1, 1), ab_y, RHS2, overwrite_ab=False, overwrite_b=False)\n        \n        # Update solution for next time step\n        U = U_np1\n\n    # 6. Compute exact solution at final time T\n    U_exact = np.sin(m * np.pi * X) * np.sin(n * np.pi * Y) * np.exp(-kappa * np.pi**2 * (m**2 + n**2) * T)\n\n    # 7. Compute relative discrete L2 error\n    # The term sqrt(hx*hy) cancels in numerator and denominator.\n    # So error is ratio of Frobenius norms.\n    norm_diff = np.linalg.norm(U - U_exact)\n    norm_exact = np.linalg.norm(U_exact)\n\n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n\n    return norm_diff / norm_exact\n\nsolve()\n```"
        },
        {
            "introduction": "After seeing the ADI method in action, it's essential to understand the source of its high accuracy. This 'pen-and-paper' exercise  guides you through a theoretical analysis of the local splitting error, the subtle discrepancy between the ADI update and the ideal, unsplit Crank-Nicolson scheme. By performing a Taylor series expansion of the operator calculus, you will prove that the method is second-order accurate in time, a key feature that contributes to its power and efficiency.",
            "id": "3128240",
            "problem": "Consider the two-dimensional diffusion equation $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$ on a square domain with periodic boundary conditions, where $\\kappa>0$ is constant. Discretize space on a uniform grid with spacing $h$ using second-order central differences to obtain a linear system of ordinary differential equations $\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$, where $A_{h}$ and $B_{h}$ are the standard discrete one-dimensional second-derivative operators (scaled by $\\kappa$) acting along the $x$- and $y$-directions, respectively, extended to two dimensions by tensor products. On this grid with periodic boundaries, assume $A_{h}$ and $B_{h}$ commute.\n\nDefine one step of the Peaceman–Rachford Alternating Direction Implicit (ADI) method with time step $\\Delta t>0$ by the pair of linear solves\n$$(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n},\\qquad (I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}},$$\nand let its one-step propagator be the linear operator $S(\\Delta t)$ satisfying $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$. Let the unsplit Crank–Nicolson propagator be\n$$R_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}.$$\n\nDefine the local splitting error operator per time step by $E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$. Starting from fundamental series expansions of matrix rational functions and using only the definitions above (no appeal to unproven shortcut formulas), determine the smallest integer $p$ such that $E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$ as $\\Delta t\\to 0$ under the commuting assumption on $A_{h}$ and $B_{h}$.\n\nReport only the integer $p$ as your final answer. No units are required.",
            "solution": "The user wants to determine the order of the local splitting error for the Peaceman-Rachford ADI method.\n\n### Step 1: Problem Validation\n\n**1. Extract Givens:**\n- PDE: $u_{t}=\\kappa\\,(u_{xx}+u_{yy})$ on a square domain with periodic boundary conditions, $\\kappa>0$.\n- Discretization: Spatial discretization on a uniform grid with spacing $h$ using second-order central differences.\n- Semi-discrete system: $\\dot{\\mathbf{u}}=(A_{h}+B_{h})\\,\\mathbf{u}$.\n- Operators: $A_{h}$ and $B_{h}$ are discrete one-dimensional second-derivative operators (scaled by $\\kappa$) for the $x$- and $y$-directions.\n- Assumption: $A_{h}$ and $B_{h}$ commute, i.e., $A_{h}B_{h} = B_{h}A_{h}$.\n- Peaceman-Rachford ADI method:\n  - $(I-\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}=(I+\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n}$\n  - $(I-\\tfrac{\\Delta t}{2}B_{h})\\,\\mathbf{u}^{n+1}=(I+\\tfrac{\\Delta t}{2}A_{h})\\,\\mathbf{u}^{n+\\frac{1}{2}}$\n- ADI propagator: $S(\\Delta t)$ such that $\\mathbf{u}^{n+1}=S(\\Delta t)\\,\\mathbf{u}^{n}$.\n- Crank-Nicolson propagator: $R_{\\mathrm{CN}}(\\Delta t)=\\bigl(I+\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)\\,\\bigl(I-\\tfrac{\\Delta t}{2}(A_{h}+B_{h})\\bigr)^{-1}$.\n- Local splitting error operator: $E_{\\mathrm{spl}}(\\Delta t)=S(\\Delta t)-R_{\\mathrm{CN}}(\\Delta t)$.\n- Objective: Find the smallest integer $p$ such that $E_{\\mathrm{spl}}(\\Delta t)=\\mathcal{O}(\\Delta t^{p})$ as $\\Delta t\\to 0$.\n- Constraint: Use fundamental series expansions and the commuting assumption.\n\n**2. Validate Using Extracted Givens:**\n- **Scientifically Grounded:** The problem is a standard analysis of a well-known numerical method (ADI) for a fundamental partial differential equation (the diffusion equation). All concepts are established in the field of numerical analysis.\n- **Well-Posed:** The problem is mathematically well-defined. It provides all the necessary definitions and the crucial assumption of operator commutativity, which allows for a unique solution to be derived.\n- **Objective:** The language is formal and precise, with no subjective or ambiguous statements.\n- The problem passes all checks for validity. It is not unsound, incomplete, inconsistent, or ill-posed.\n\n**3. Verdict and Action:**\n- The problem is valid. A detailed solution will be provided.\n\n### Step 2: Solution Derivation\n\nThe goal is to find the smallest integer $p$ such that the local splitting error, $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$, is of order $\\mathcal{O}(\\Delta t^p)$.\n\nFirst, we find an explicit expression for the ADI propagator $S(\\Delta t)$. From the definition of the method:\n$$ \\mathbf{u}^{n+\\frac{1}{2}} = \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\mathbf{u}^{n} $$\n$$ \\mathbf{u}^{n+1} = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\mathbf{u}^{n+\\frac{1}{2}} $$\nSubstituting the expression for $\\mathbf{u}^{n+\\frac{1}{2}}$ into the second equation gives $\\mathbf{u}^{n+1} = S(\\Delta t) \\mathbf{u}^n$, where the propagator $S(\\Delta t)$ is:\n$$ S(\\Delta t) = \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) $$\nThe problem states that $A_h$ and $B_h$ commute. This implies that any well-behaved function of $A_h$ commutes with any well-behaved function of $B_h$. We can therefore reorder the operators in the expression for $S(\\Delta t)$:\n$$ S(\\Delta t) = \\left[ \\left(I+\\frac{\\Delta t}{2}A_{h}\\right) \\left(I-\\frac{\\Delta t}{2}A_{h}\\right)^{-1} \\right] \\left[ \\left(I+\\frac{\\Delta t}{2}B_{h}\\right) \\left(I-\\frac{\\Delta t}{2}B_{h}\\right)^{-1} \\right] $$\nThe problem asks us to start from fundamental series expansions. For a generic operator $Z$, let us define the rational operator function $F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left(I-\\frac{\\Delta t}{2}Z\\right)^{-1}$. We can expand this using the geometric series for matrices, $(I-M)^{-1} = \\sum_{k=0}^{\\infty} M^k$, which is valid for small $\\Delta t$ such that the spectral radius of $\\frac{\\Delta t}{2}Z$ is less than $1$.\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\sum_{k=0}^{\\infty} \\left(\\frac{\\Delta t}{2}Z\\right)^k $$\nExpanding the sum:\n$$ F(Z, \\Delta t) = \\left(I+\\frac{\\Delta t}{2}Z\\right) \\left( I + \\frac{\\Delta t}{2}Z + \\left(\\frac{\\Delta t}{2}\\right)^2 Z^2 + \\left(\\frac{\\Delta t}{2}\\right)^3 Z^3 + \\mathcal{O}(\\Delta t^4) \\right) $$\nMultiplying the terms:\n$$ F(Z, \\Delta t) = \\left( I + \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\left( \\frac{\\Delta t}{2}Z + \\frac{\\Delta t^2}{4}Z^2 + \\frac{\\Delta t^3}{8}Z^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ F(Z, \\Delta t) = I + \\Delta t Z + \\frac{\\Delta t^2}{2}Z^2 + \\frac{\\Delta t^3}{4}Z^3 + \\mathcal{O}(\\Delta t^4) $$\nUsing this expansion, the ADI propagator $S(\\Delta t)$ can be written as the product of two such series, $S(\\Delta t) = F(A_h, \\Delta t) F(B_h, \\Delta t)$:\n$$ S(\\Delta t) = \\left( I + \\Delta t A_h + \\frac{\\Delta t^2}{2}A_h^2 + \\frac{\\Delta t^3}{4}A_h^3 + \\dots \\right) \\left( I + \\Delta t B_h + \\frac{\\Delta t^2}{2}B_h^2 + \\frac{\\Delta t^3}{4}B_h^3 + \\dots \\right) $$\nSince $A_h$ and $B_h$ commute, we can multiply these series and collect terms by powers of $\\Delta t$:\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\left( \\frac{\\Delta t^2}{2}A_h^2 + \\Delta t^2 A_h B_h + \\frac{\\Delta t^2}{2}B_h^2 \\right) + \\left( \\frac{\\Delta t^3}{4}A_h^3 + \\frac{\\Delta t^3}{2}A_h B_h^2 + \\frac{\\Delta t^3}{2}A_h^2 B_h + \\frac{\\Delta t^3}{4}B_h^3 \\right) + \\mathcal{O}(\\Delta t^4) $$\n$$ S(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\nNext, we expand the unsplit Crank-Nicolson propagator, $R_{\\mathrm{CN}}(\\Delta t)$. This has the same functional form $F(Z, \\Delta t)$, but with the operator $Z = A_h+B_h$:\n$$ R_{\\mathrm{CN}}(\\Delta t) = F(A_h+B_h, \\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h+B_h)^3 + \\mathcal{O}(\\Delta t^4) $$\nUsing the commutativity of $A_h$ and $B_h$, we can expand the cubic term:\n$$ (A_h+B_h)^3 = A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3 $$\nSo the expansion for $R_{\\mathrm{CN}}(\\Delta t)$ is:\n$$ R_{\\mathrm{CN}}(\\Delta t) = I + \\Delta t(A_h+B_h) + \\frac{\\Delta t^2}{2}(A_h+B_h)^2 + \\frac{\\Delta t^3}{4}(A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) + \\mathcal{O}(\\Delta t^4) $$\nFinally, we compute the local splitting error $E_{\\mathrm{spl}}(\\Delta t) = S(\\Delta t) - R_{\\mathrm{CN}}(\\Delta t)$. We subtract the two series expansions. The terms of order $\\Delta t^0$, $\\Delta t^1$, and $\\Delta t^2$ are identical and cancel out. The leading error term arises from the difference in the $\\mathcal{O}(\\Delta t^3)$ terms:\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (A_h^3 + 2A_h^2 B_h + 2A_h B_h^2 + B_h^3) - (A_h^3 + 3A_h^2 B_h + 3A_h B_h^2 + B_h^3) \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ (2-3)A_h^2 B_h + (2-3)A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = \\frac{\\Delta t^3}{4} \\left[ -A_h^2 B_h - A_h B_h^2 \\right] + \\mathcal{O}(\\Delta t^4) $$\n$$ E_{\\mathrm{spl}}(\\Delta t) = -\\frac{\\Delta t^3}{4} A_h B_h (A_h+B_h) + \\mathcal{O}(\\Delta t^4) $$\nSince $A_h$ and $B_h$ are generally non-zero operators (representing second derivatives), the coefficient of $\\Delta t^3$ is not zero. Thus, the leading term in the splitting error is of third order in $\\Delta t$.\nThe smallest integer $p$ for which $E_{\\mathrm{spl}}(\\Delta t) = \\mathcal{O}(\\Delta t^p)$ is therefore $p=3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "Building on a solid understanding of the basic ADI scheme, this final practice  moves into the realm of advanced, practical solvers. You will design and implement an adaptive time-step controller that uses an estimate of the splitting error—the very quantity analyzed in the previous exercise—to dynamically adjust the step size $\\Delta t$. This powerful technique allows the solver to take large steps when the solution evolves slowly and smaller steps during periods of rapid change, optimizing both computational efficiency and accuracy.",
            "id": "3363234",
            "problem": "You are to design and implement an adaptive time-step controller for a linear Alternating Direction Implicit (ADI) method for a diffusion-type partial differential equation. The starting point is the two-dimensional diffusion equation with homogeneous Dirichlet boundary conditions on the unit square,\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}, \\quad (x,y) \\in (0,1)\\times(0,1), \\quad t \\ge 0,\n$$\nwith\n$$\nu(0,x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad u(t,0,y)=u(t,1,y)=u(t,x,0)=u(t,x,1)=0.\n$$\nDiscretize the spatial domain using a uniform grid of $N_x$ interior points in the $x$-direction and $N_y$ interior points in the $y$-direction, with spacings $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$. Let $u^n \\in \\mathbb{R}^{N_y \\times N_x}$ denote the grid function at time level $t^n$, representing values at interior grid points. Define the one-dimensional centered second difference operators acting along each axis with homogeneous Dirichlet boundary treatment, yielding linear operators $A_x$ and $A_y$ acting on $u^n$ by\n$$\nA_x u[i,j] = k_x \\frac{u[i,j-1] - 2u[i,j] + u[i,j+1]}{h_x^2}, \\quad A_y u[i,j] = k_y \\frac{u[i-1,j] - 2u[i,j] + u[i+1,j]}{h_y^2},\n$$\nwhere out-of-range indices correspond to boundary values equal to $0$. Consider the factorized implicit Euler ADI update,\n$$\n(I - \\Delta t A_y) v = u^n, \\quad (I - \\Delta t A_x) u^{n+1} = v,\n$$\nwhich is algebraically equivalent to $(I - \\Delta t A_x)(I - \\Delta t A_y)u^{n+1} = u^n$.\n\nAt the start of each step, estimate the splitting defect using the linearized defect formula\n$$\nd^{n+1}(\\Delta t; u^n) = \\Big(I - \\Delta t A_x\\Big)\\Big(I - \\Delta t A_y\\Big) u^n - \\Big(I - \\Delta t (A_x + A_y)\\Big) u^n,\n$$\nwhich simplifies exactly to\n$$\nd^{n+1}(\\Delta t; u^n) = \\Delta t^2 A_x A_y u^n,\n$$\nand use its infinity norm $\\|d^{n+1}\\|_\\infty$ to adaptively control $\\Delta t$ so that this surrogate of the splitting error remains within a target tolerance. For each step, define a local tolerance\n$$\n\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty.\n$$\nAccept the step if $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$; otherwise, reject it. In both cases, update the next time step using a proportional controller based on the expected quadratic scaling of the defect with respect to the time step,\n$$\n\\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2},\n$$\nbounded by user-chosen multiplicative limits $g_{\\min} \\le \\Delta t_{\\text{new}}/\\Delta t \\le g_{\\max}$ and an absolute maximum $\\Delta t \\le \\Delta t_{\\max}$. Here $\\varepsilon$ is a tiny positive number to avoid division by zero. On rejection, enforce $\\Delta t_{\\text{new}} \\le \\Delta t$; on acceptance, permit $\\Delta t_{\\text{new}} \\ge \\Delta t$ within the chosen bounds. Ensure that the time integration lands exactly at the final time by clipping $\\Delta t$ to the remaining time as needed.\n\nImplement the above with the following requirements:\n- Use the ADI factorization with tridiagonal solves in each direction for the two linear systems per accepted step.\n- Use the infinity norm for both $\\|u^n\\|_\\infty$ and $\\|d^{n+1}\\|_\\infty$.\n- Use the initial condition $u(0,x,y)=\\sin(\\pi x)\\sin(\\pi y)$ sampled at interior grid points $x_j = (j+1)h_x$, $y_i = (i+1)h_y$.\n\nTest suite. Run your implementation on the three parameter sets below. For each case, return the number of rejected steps (an integer) incurred by the controller over the whole integration. The three cases are:\n- Case 1 (balanced diffusion): $k_x = 1.0$, $k_y = 1.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, initial $\\Delta t_0 = 10^{-4}$, $\\Delta t_{\\max} = 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$.\n- Case 2 (anisotropic diffusion): $k_x = 1.0$, $k_y = 10.0$, $N_x = 32$, $N_y = 32$, $T = 0.05$, initial $\\Delta t_0 = 5 \\cdot 10^{-5}$, $\\Delta t_{\\max} = 5 \\cdot 10^{-3}$, $\\mathrm{rtol} = 5 \\cdot 10^{-4}$, $\\mathrm{atol} = 10^{-8}$.\n- Case 3 (degenerate in $y$): $k_x = 1.0$, $k_y = 0.0$, $N_x = 32$, $N_y = 32$, $T = 0.1$, initial $\\Delta t_0 = 10^{-3}$, $\\Delta t_{\\max} = 2 \\cdot 10^{-2}$, $\\mathrm{rtol} = 10^{-3}$, $\\mathrm{atol} = 10^{-8}$.\n\nController constants to use for all cases: $\\mathrm{safety} = 0.9$, $g_{\\min} = 0.2$, $g_{\\max} = 2.5$, and $\\varepsilon = 10^{-300}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of the three integers in order of the test cases, enclosed in square brackets, for example,\n\"[r1,r2,r3]\".",
            "solution": "The user requires the implementation of an adaptive time-stepping controller for the Alternating Direction Implicit (ADI) method applied to the two-dimensional diffusion equation on the unit square $[0,1] \\times [0,1]$:\n$$\n\\frac{\\partial u}{\\partial t} = k_x \\frac{\\partial^2 u}{\\partial x^2} + k_y \\frac{\\partial^2 u}{\\partial y^2}\n$$\nwith homogeneous Dirichlet boundary conditions and a given initial condition $u(0,x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n\nThe solution proceeds by first discretizing the problem, then implementing the ADI time-stepping scheme, and finally integrating the adaptive controller logic.\n\n### 1. Spatial Discretization\nThe continuous domain is discretized into a grid of $N_y \\times N_x$ interior points. The solution $u(t,x,y)$ at a time $t^n$ is represented by a matrix $u^n \\in \\mathbb{R}^{N_y \\times N_x}$, where $u^n_{i,j}$ approximates the solution at $(x_j, y_i) = ((j+1)h_x, (i+1)h_y)$. The grid spacings are $h_x = 1/(N_x+1)$ and $h_y = 1/(N_y+1)$.\n\nThe second partial derivatives are approximated using centered finite differences. This gives rise to two linear operators, $A_x$ and $A_y$, which act on the grid function $u^n$:\n- $A_x$ applies the one-dimensional second-difference stencil scaled by $k_x/h_x^2$ to each row of the matrix $u^n$.\n- $A_y$ applies the one-dimensional second-difference stencil scaled by $k_y/h_y^2$ to each column of the matrix $u^n$.\nThe homogeneous Dirichlet boundary conditions are handled by assuming that any grid function value at an index outside the interior domain is zero. In the implementation, this is achieved by padding the grid function matrix with zeros before applying the finite difference stencils.\n\n### 2. ADI Method\nThe time evolution is governed by the semi-discretized equation $\\frac{du}{dt} = (A_x + A_y)u$. The ADI method, specifically the factorized implicit Euler variant specified, splits the time step $\\Delta t$ into two sub-steps. This approach transforms a large two-dimensional problem into a series of smaller, independent one-dimensional problems, which are computationally efficient to solve.\n\nThe update from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ is performed in two stages:\n1.  **Y-direction implicit step**: Solve for an intermediate state $v$:\n    $$ (I - \\Delta t A_y) v = u^n $$\n    This equation represents a set of $N_x$ independent tridiagonal linear systems, one for each column of the grid function $v$.\n2.  **X-direction implicit step**: Solve for the new state $u^{n+1}$:\n    $$ (I - \\Delta t A_x) u^{n+1} = v $$\n    This equation represents a set of $N_y$ independent tridiagonal linear systems, one for each row of the grid function $u^{n+1}$.\n\nEach set of tridiagonal systems is solved efficiently a single call to `scipy.linalg.solve_banded`, which is optimized for this task. For the X-direction step, which acts on rows, the intermediate matrix $v$ is transposed, the solver is called, and the result is transposed back.\n\n### 3. Adaptive Time-Step Control\nAn adaptive controller adjusts the time step $\\Delta t$ to maintain a measure of the local error below a specified tolerance. This improves efficiency by allowing larger steps when the solution is smooth and smaller steps when it changes rapidly.\n\n-   **Error Estimation**: The error used for control is a surrogate based on the ADI splitting defect, given by $d^{n+1} = \\Delta t^2 A_x A_y u^n$. Its infinity norm, $\\|d^{n+1}\\|_\\infty$, is used as the error measure for the current step. This quantity is computed by sequentially applying the implemented discrete operators $A_y$ and then $A_x$ to the current solution $u^n$.\n\n-   **Tolerance**: At each step, a local tolerance is computed as $\\mathrm{tol}_n = \\mathrm{atol} + \\mathrm{rtol}\\,\\|u^n\\|_\\infty$, where $\\mathrm{atol}$ and $\\mathrm{rtol}$ are absolute and relative tolerance parameters, respectively.\n\n-   **Accept/Reject Mechanism**: A step of size $\\Delta t$ is attempted.\n    - If $\\|d^{n+1}\\|_\\infty \\le \\mathrm{tol}_n$, the step is **accepted**. The solution and time are updated: $u^{n+1}$ is computed and becomes the new $u^n$, and $t$ advances by $\\Delta t$.\n    - If $\\|d^{n+1}\\|_\\infty > \\mathrm{tol}_n$, the step is **rejected**. The solution and time are not changed, and the number of rejected steps is incremented.\n\n-   **Step Size Update**: In both cases (acceptance or rejection), a new prospective time step $\\Delta t_{\\text{new}}$ is calculated using a proportional-integral (PI) type control law. The problem specifies a proportional controller:\n    $$ \\Delta t_{\\text{new}} = \\Delta t \\cdot \\mathrm{safety} \\cdot \\left(\\frac{\\mathrm{tol}_n}{\\max(\\|d^{n+1}\\|_\\infty,\\varepsilon)}\\right)^{1/2} $$\n    The tiny value $\\varepsilon$ prevents division by zero. The resulting step size change ratio, $\\Delta t_{\\text{new}}/\\Delta t$, is constrained to lie within $[g_{\\min}, g_{\\max}]$, and the new step size is capped by an absolute maximum $\\Delta t_{\\max}$. If a step is rejected, the newly computed $\\Delta t_{\\text{new}}$ (which will be smaller) is used to retry the step. If accepted, $\\Delta t_{\\text{new}}$ is used for the subsequent time step.\n\n### 4. Implementation Logic\nThe overall process is encapsulated in a function that runs the simulation for a given set of parameters.\n1.  Initialize the grid, the initial condition $u^0$ by sampling $\\sin(\\pi x)\\sin(\\pi y)$, the current time $t=0$, the initial step size $\\Delta t = \\Delta t_0$, and a counter for rejected steps.\n2.  A `while` loop runs as long as $t < T$.\n3.  Inside the loop, the current $\\Delta t$ is first clipped to not exceed $\\Delta t_{\\max}$ and to ensure the final step lands exactly at $t=T$.\n4.  The error a posteriori, $\\|d^{n+1}\\|_\\infty$, is calculated based on the current $u^n$ and the attempted $\\Delta t$.\n5.  A decision to accept or reject is made.\n6.  The new step size is calculated using the control formula and associated bounds.\n7.  If the step is accepted, time and the solution are advanced. The `dt` for the next iteration is set to the newly calculated step size.\n8.  If the step is rejected, the counter is incremented, and the `dt` for the next iteration (which is a retry of the current step) is set to the newly calculated (smaller) step size.\n9.  This process repeats until the final time $T$ is reached. The total number of rejected steps is returned. This logic is applied to each of the three test cases specified.\n\nA special case arises when $k_y = 0$, as in Case 3. Here, $A_y=0$, making the splitting defect $d^{n+1}$ identically zero. The implementation correctly handles this: the error norm is always zero, so every step is accepted, and the step size controller will increase $\\Delta t$ at the maximum allowed rate, $g_{\\max}$, until it is limited by $\\Delta t_{\\max}$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(kx, ky, Nx, Ny, T, dt0, dt_max, rtol, atol, safety, g_min, g_max, eps):\n    \"\"\"\n    Runs the adaptive ADI simulation for one parameter set.\n    \"\"\"\n    # 1. Grid and Initial Condition Setup\n    hx = 1.0 / (Nx + 1)\n    hy = 1.0 / (Ny + 1)\n    \n    x = (np.arange(Nx) + 1) * hx\n    y = (np.arange(Ny) + 1) * hy\n    X, Y = np.meshgrid(x, y)\n    \n    u = np.sin(np.pi * X) * np.sin(np.pi * Y)\n\n    t = 0.0\n    dt = dt0\n    rejected_steps = 0\n\n    # Helper functions for applying discrete operators\n    def apply_Ax(u_mat, k, h):\n        padded = np.pad(u_mat, ((0, 0), (1, 1)), 'constant')\n        diff = padded[:, :-2] - 2 * padded[:, 1:-1] + padded[:, 2:]\n        return (k / h**2) * diff\n\n    def apply_Ay(u_mat, k, h):\n        padded = np.pad(u_mat, ((1, 1), (0, 0)), 'constant')\n        diff = padded[:-2, :] - 2 * padded[1:-1, :] + padded[2:, :]\n        return (k / h**2) * diff\n\n    # 2. Main Time-Stepping Loop\n    while t  T:\n        # Clip dt by global max and to land on T\n        dt_attempt = min(dt, dt_max)\n        if t + dt_attempt > T:\n            dt_attempt = T - t\n        \n        # 3. Defect and Tolerance Calculation\n        u_norm = np.max(np.abs(u))\n        tol = atol + rtol * u_norm\n\n        if ky == 0.0 or kx == 0.0:\n            err_norm = 0.0\n        else:\n            d = (dt_attempt**2) * apply_Ax(apply_Ay(u, ky, hy), kx, hx)\n            err_norm = np.max(np.abs(d))\n\n        # 4. Accept/Reject Step\n        accepted = err_norm = tol\n\n        # 5. Calculate new step size\n        if err_norm  eps: # To handle err_norm == 0 or very small\n             factor = g_max\n        else:\n            factor_raw = safety * (tol / err_norm)**0.5\n            factor = max(g_min, min(g_max, factor_raw))\n        \n        dt_new = dt_attempt * factor\n\n        if accepted:\n            # Perform ADI step\n            # Y-sweep: (I - dt*Ay) v = u\n            if ky != 0.0:\n                cy = -dt_attempt * ky / hy**2\n                diag_y = 1.0 - 2.0 * cy\n                ab_y = np.zeros((3, Ny))\n                ab_y[0, 1:] = cy\n                ab_y[1, :] = diag_y\n                ab_y[2, :-1] = cy\n                v = solve_banded((1, 1), ab_y, u, overwrite_ab=True, overwrite_b=False)\n            else:\n                v = u\n\n            # X-sweep: (I - dt*Ax) u_new = v\n            if kx != 0.0:\n                cx = -dt_attempt * kx / hx**2\n                diag_x = 1.0 - 2.0 * cx\n                ab_x = np.zeros((3, Nx))\n                ab_x[0, 1:] = cx\n                ab_x[1, :] = diag_x\n                ab_x[2, :-1] = cx\n                u_new_T = solve_banded((1, 1), ab_x, v.T, overwrite_ab=True, overwrite_b=False)\n                u = u_new_T.T\n            else:\n                u = v\n            \n            t += dt_attempt\n            dt = dt_new\n        else:\n            rejected_steps += 1\n            # Retry with smaller step size\n            dt = dt_new\n            \n    return rejected_steps\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Controller constants\n    safety = 0.9\n    g_min = 0.2\n    g_max = 2.5\n    eps = 1e-300\n\n    test_cases = [\n        # Case 1: balanced diffusion\n        {\"kx\": 1.0, \"ky\": 1.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1, \n         \"dt0\": 1e-4, \"dt_max\": 1e-2, \"rtol\": 1e-3, \"atol\": 1e-8},\n        # Case 2: anisotropic diffusion\n        {\"kx\": 1.0, \"ky\": 10.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.05,\n         \"dt0\": 5e-5, \"dt_max\": 5e-3, \"rtol\": 5e-4, \"atol\": 1e-8},\n        # Case 3: degenerate in y\n        {\"kx\": 1.0, \"ky\": 0.0, \"Nx\": 32, \"Ny\": 32, \"T\": 0.1,\n         \"dt0\": 1e-3, \"dt_max\": 2e-2, \"rtol\": 1e-3, \"atol\": 1e-8}\n    ]\n\n    results = []\n    for params in test_cases:\n        rejections = run_simulation(\n            kx=params[\"kx\"], ky=params[\"ky\"],\n            Nx=params[\"Nx\"], Ny=params[\"Ny\"],\n            T=params[\"T\"], dt0=params[\"dt0\"], dt_max=params[\"dt_max\"],\n            rtol=params[\"rtol\"], atol=params[\"atol\"],\n            safety=safety, g_min=g_min, g_max=g_max, eps=eps\n        )\n        results.append(rejections)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}