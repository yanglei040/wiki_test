{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of designing energy-conserving schemes lies in the discrete gradient method. This practice guides you through the implementation of such a method for a general nonlinear wave equation, demonstrating how to construct an integrator that perfectly respects the Hamiltonian structure of the system at the discrete level . By using a specific form of the discrete gradient, you will create a scheme that guarantees energy conservation not just approximately, but exactly to within machine precision, a crucial property for ensuring the stability and physical fidelity of long-term simulations.",
            "id": "3384894",
            "problem": "Consider the semi-discrete wave equation in canonical form, obtained by introducing the generalized momentum $p$ via $p = M \\dot{q}$, where $M$ is a symmetric positive-definite mass matrix:\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q),\n$$\nwith symmetric positive-definite stiffness matrix $K$, and nonlinear restoring force $g(q)$ that is assumed to be the gradient of a scalar potential $G(q)$, i.e., $g(q) = \\nabla G(q)$. The associated Hamiltonian is\n$$\nH(q,p) = \\tfrac{1}{2} q^\\top K q + G(q) + \\tfrac{1}{2} p^\\top M^{-1} p.\n$$\n\nAn energy-conserving time integrator can be constructed by the discrete gradient method for Hamiltonian systems of the form $\\dot{x} = S \\nabla H(x)$, where $S$ is a constant skew-symmetric matrix. For canonical variables $x = (q, p)$, $S$ has block form $S = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}$, with $I$ the identity matrix. A discrete gradient $\\overline{\\nabla} H(x^n, x^{n+1})$ is any map that satisfies the fundamental mean value property\n$$\nH(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n),\n$$\nand is consistent with the exact gradient in the limit $x^{n+1} \\to x^n$. Using such a discrete gradient, the implicit one-step method\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\nis energy-conserving, because $S$ is skew-symmetric.\n\nYour task is to implement this method using the Gonzalez discrete gradient for the Hamiltonian $H(q,p)$ of the semi-discrete wave equation. For a separable Hamiltonian $H(q,p) = V(q) + T(p)$, with $V(q) = \\tfrac{1}{2} q^\\top K q + G(q)$ and $T(p) = \\tfrac{1}{2} p^\\top M^{-1} p$, you should construct a block discrete gradient that preserves the mean value property\n$$\nH(q^{n+1},p^{n+1}) - H(q^n,p^n) = \\overline{\\nabla}_q V(q^n, q^{n+1}) \\cdot (q^{n+1} - q^n) + \\overline{\\nabla}_p T(p^n, p^{n+1}) \\cdot (p^{n+1} - p^n).\n$$\nThe discrete gradient for the quadratic terms should be consistent with their exact gradients evaluated appropriately to satisfy the mean value property, and the discrete gradient for $G(q)$ should be the Gonzalez discrete gradient constructed to satisfy the mean value property for the scalar function $G$.\n\nStarting from the fundamental laws and core definitions for Hamiltonian systems and the mean value property of discrete gradients, derive and implement a robust Newton-type solver for the implicit update equations in $(q^{n+1}, p^{n+1})$. The implementation must:\n- Accept symmetric positive-definite matrices $M$ and $K$.\n- Accept a polynomial potential $G(q)$ with $g(q) = \\nabla G(q)$.\n- Use the Gonzalez discrete gradient for $G(q)$ to ensure exact discrete energy conservation at the algebraic level.\n- Verify energy conservation numerically by computing the Hamiltonian $H(q,p)$ along the numerical trajectory and reporting the maximum absolute deviation from the initial energy over the integration window.\n\nAll quantities are dimensionless. Angles do not appear. The final numerical results must be floats.\n\nTest Suite:\nImplement the program to run the integrator and report the maximum absolute Hamiltonian deviation $E_{\\max}$ for each of the following four cases with specified parameters:\n\n1. One-dimensional linear oscillator (happy path):\n   - $M = [1.0]$, $K = [1.0]$, $G(q) = 0$.\n   - Initial state: $q(0) = 1.0$, $p(0) = 0.0$.\n   - Time step: $\\Delta t = 0.05$.\n   - Steps: $N = 200$.\n\n2. One-dimensional quartic nonlinearity:\n   - $M = [1.5]$, $K = [0.7]$, $G(q) = \\lambda \\tfrac{q^4}{4}$ with $\\lambda = 0.3$, so $g(q) = \\lambda q^3$.\n   - Initial state: $q(0) = 0.2$, $p(0) = 0.3$.\n   - Time step: $\\Delta t = 0.02$.\n   - Steps: $N = 500$.\n\n3. Two-dimensional coupled polynomial potential:\n   - $M = \\mathrm{diag}(1.0, 2.0)$, $K = \\begin{pmatrix} 2.0 & 0.3 \\\\ 0.3 & 1.5 \\end{pmatrix}$.\n   - $G(q) = \\alpha \\tfrac{q_1^4 + q_2^4}{4} + \\beta \\tfrac{q_1^2 q_2^2}{2}$, with $\\alpha = 0.2$, $\\beta = 0.1$.\n   - Thus $g(q) = \\begin{pmatrix} \\alpha q_1^3 + \\beta q_1 q_2^2 \\\\ \\alpha q_2^3 + \\beta q_2 q_1^2 \\end{pmatrix}$.\n   - Initial state: $q(0) = (0.1, -0.2)$, $p(0) = (0.0, 0.25)$.\n   - Time step: $\\Delta t = 0.015$.\n   - Steps: $N = 400$.\n\n4. One-dimensional trivial equilibrium (edge case):\n   - $M = [1.0]$, $K = [2.0]$, $G(q) = \\tfrac{1}{4} q^4$, so $g(q) = q^3$.\n   - Initial state: $q(0) = 0.0$, $p(0) = 0.0$.\n   - Time step: $\\Delta t = 0.1$.\n   - Steps: $N = 10$.\n\nOutput format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the maximum absolute Hamiltonian deviation $E_{\\max}$ for the corresponding test case in the order listed above. For example, the output format must be exactly:\n$$\n[\\text{E1},\\text{E2},\\text{E3},\\text{E4}]\n$$\nwith each $\\text{E}$ a floating-point number.",
            "solution": "The user has provided a well-defined problem in the field of geometric numerical integration. The task is to implement an energy-conserving time integrator for a canonical Hamiltonian system using the discrete gradient method, specifically with a Gonzalez-type discrete gradient for the nonlinear potential. The problem is scientifically sound, self-contained, and all parameters for the test cases are provided. The problem is deemed valid.\n\nHere follows the derivation and explanation of the numerical method.\n\nThe system is described by the canonical Hamiltonian equations:\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q)\n$$\nwhere $q$ are the generalized coordinates, $p$ are the generalized momenta, $M$ is the mass matrix, and $K$ is the stiffness matrix. The force $g(q)$ is the gradient of a potential, $g(q) = \\nabla G(q)$. The Hamiltonian, representing the total energy of the system, is a separable function of $q$ and $p$:\n$$\nH(q,p) = V(q) + T(p) = \\left(\\tfrac{1}{2} q^\\top K q + G(q)\\right) + \\left(\\tfrac{1}{2} p^\\top M^{-1} p\\right)\n$$\nThe system can be written in the compact form $\\dot{x} = S \\nabla H(x)$, with $x=(q, p)$ and $S = \\begin{pmatrix} 0 & I \\\\ -I & 0 \\end{pmatrix}$.\n\nThe discrete gradient method provides a general framework for constructing energy-conserving schemes. The update from time step $n$ to $n+1$ is given by the implicit rule:\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\nwhere $\\Delta t$ is the time step, and $\\overline{\\nabla} H$ is a discrete gradient of the Hamiltonian $H$. A discrete gradient must satisfy the mean value property $H(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n)$ and be consistent with the true gradient, $\\overline{\\nabla} H(x, x) = \\nabla H(x)$. The energy conservation of the method follows directly from the mean value property and the skew-symmetry of $S$:\n$$\nH(x^{n+1}) - H(x^n) = (x^{n+1} - x^n)^\\top \\overline{\\nabla} H = (\\Delta t \\, S \\, \\overline{\\nabla} H)^\\top \\overline{\\nabla} H = \\Delta t (\\overline{\\nabla} H)^\\top S^\\top \\overline{\\nabla} H = -\\Delta t (\\overline{\\nabla} H)^\\top S \\overline{\\nabla} H = 0\n$$\nThe last equality holds because for any vector $v$, $v^\\top S v = 0$ if $S$ is skew-symmetric. Thus, $H(x^{n+1}) = H(x^n)$ for all $n$.\n\nFor a separable Hamiltonian, we use a separable discrete gradient:\n$$\n\\overline{\\nabla} H(x^n, x^{n+1}) = \\begin{pmatrix} \\overline{\\nabla}_q V(q^n, q^{n+1}) \\\\ \\overline{\\nabla}_p T(p^n, p^{n+1}) \\end{pmatrix}\n$$\nSubstituting this into the update rule gives a pair of coupled equations:\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = \\overline{\\nabla}_p T(p^n, p^{n+1}) \\quad (1)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -\\overline{\\nabla}_q V(q^n, q^{n+1}) \\quad (2)\n$$\n\nWe must now define the specific discrete gradients.\nFor the quadratic kinetic energy $T(p) = \\frac{1}{2} p^\\top M^{-1} p$, a suitable discrete gradient that satisfies the mean value property is the midpoint gradient:\n$$\n\\overline{\\nabla}_p T(p^n, p^{n+1}) = \\nabla_p T \\left( \\frac{p^n + p^{n+1}}{2} \\right) = M^{-1} \\left( \\frac{p^n + p^{n+1}}{2} \\right)\n$$\nSimilarly, for the quadratic part of the potential energy, $\\frac{1}{2} q^\\top K q$, we use:\n$$\n\\overline{\\nabla}_q \\left(\\tfrac{1}{2} q^\\top K q\\right)(q^n, q^{n+1}) = K \\left( \\frac{q^n + q^{n+1}}{2} \\right)\n$$\nFor the nonlinear potential $G(q)$, we use the Gonzalez discrete gradient. For potentials that are sums of products of functions of single coordinates, a symmetric form can be derived. For a polynomial potential $G(q)$ with dimension $d$, its components $\\overline{g}_i(q^n, q^{n+1}) = (\\overline{\\nabla}G(q^n, q^{n+1}))_i$ are constructed to satisfy the mean value property. For the potentials in the test suite, this leads to specific algebraic expressions that are implemented directly. For example, for a 1D potential $G(q)$, $\\overline{\\nabla}G(q^n, q^{n+1}) = (G(q^{n+1})-G(q^n))/(q^{n+1}-q^n)$ if $q^{n+1} \\neq q^n$, and $\\nabla G(q^n)$ otherwise. For polynomial potentials, this can be written in a numerically stable polynomial form.\n\nThe full update equations are:\n$$\nq^{n+1} - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p^{n+1}) = 0\n$$\n$$\np^{n+1} - p^n + \\frac{\\Delta t}{2} K (q^n + q^{n+1}) + \\Delta t \\, \\overline{\\nabla}G(q^n, q^{n+1}) = 0\n$$\nThis is a system of $2d$ nonlinear algebraic equations for the unknown state $(q^{n+1}, p^{n+1})$. We solve this system using Newton's method. Let the unknowns be $y = (q^{n+1}, p^{n+1})$ and the system of equations be $F(y) = 0$. The Newton iteration is $y_{k+1} = y_k - [J_F(y_k)]^{-1} F(y_k)$, where $J_F$ is the Jacobian of $F$. The iteration starts with an initial guess, e.g., $y_0 = (q^n, p^n)$.\n\nThe residual vector is $F(y_k) = (F_q, F_p)$ where $y_k = (q_k, p_k)$:\n$$\nF_q(q_k, p_k) = q_k - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p_k)\n$$\n$$\nF_p(q_k, p_k) = p_k - p^n + \\frac{\\Delta t}{2} K (q^n + q_k) + \\Delta t \\, \\overline{\\nabla}G(q^n, q_k)\n$$\nThe Jacobian matrix $J_F = \\frac{\\partial F}{\\partial y}$ is given by:\n$$\nJ_F = \\begin{pmatrix} \\partial F_q / \\partial q_k & \\partial F_q / \\partial p_k \\\\ \\partial F_p / \\partial q_k & \\partial F_p / \\partial p_k \\end{pmatrix} = \\begin{pmatrix} I & -\\frac{\\Delta t}{2} M^{-1} \\\\ \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}} & I \\end{pmatrix}\n$$\nwhere $J_{\\overline{g}} = \\frac{\\partial}{\\partial q_k} \\overline{\\nabla}G(q^n, q_k)$ is the Jacobian of the discrete gradient of $G$. The Newton update step involves solving the linear system $J_F \\Delta y = -F$ for the update $\\Delta y = (\\Delta q, \\Delta p)$. This $2d \\times 2d$ system can be solved more efficiently by block elimination. We solve for $\\Delta q$ first from the $d \\times d$ system:\n$$\n\\left( \\frac{2}{\\Delta t} M + \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}} \\right) \\Delta q = -F_p - \\frac{2}{\\Delta t} M F_q\n$$\nand then find $\\Delta p$ via substitution:\n$$\n\\Delta p = \\frac{2}{\\Delta t} M (\\Delta q + F_q)\n$$\nThis procedure is repeated until the norm of the residual $F$ or the update $\\Delta y$ is below a chosen tolerance. The implementation will use this Newton-based solver to advance the system in time for each test case and report the maximum deviation in the numerically computed Hamiltonian.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the energy-conserving integrator.\n    \"\"\"\n\n    def get_hamiltonian_func(M, K, G_func):\n        \"\"\"Constructs the Hamiltonian function for a given system.\"\"\"\n        M_inv = np.linalg.inv(M)\n        def hamiltonian(q, p):\n            T = 0.5 * p.T @ M_inv @ p\n            V_lin = 0.5 * q.T @ K @ q\n            V_nonlin = G_func(q)\n            return float(T + V_lin + V_nonlin)\n        return hamiltonian\n\n    def newton_solver(q_n, p_n, M, K, dG_disc_func, J_dG_disc_func, dt, tol=1e-13, max_iter=20):\n        \"\"\"\n        Solves the implicit update equations for one time step using Newton's method.\n        \"\"\"\n        dim = len(q_n)\n        M_inv = np.linalg.inv(M)\n        \n        # Initial guess for (q_{n+1}, p_{n+1})\n        q_k = np.copy(q_n)\n        p_k = np.copy(p_n)\n\n        for _ in range(max_iter):\n            # Evaluate residuals F_q, F_p\n            F_q = q_k - q_n - (dt / 2.0) * M_inv @ (p_n + p_k)\n            \n            dG = dG_disc_func(q_n, q_k)\n            F_p = p_k - p_n + (dt / 2.0) * K @ (q_n + q_k) + dt * dG\n            \n            residual_norm = np.linalg.norm(np.concatenate([F_q, F_p]))\n            if residual_norm < tol:\n                return q_k, p_k\n            \n            # Evaluate Jacobian of the discrete gradient of G\n            J_dG = J_dG_disc_func(q_n, q_k)\n            \n            # Form and solve the linear system for the update (dq, dp)\n            # A * dq = b\n            A = (2.0 / dt) * M + (dt / 2.0) * K + dt * J_dG\n            b = -F_p - (2.0 / dt) * M @ F_q\n            \n            dq = np.linalg.solve(A, b)\n            dp = (2.0 / dt) * M @ (dq + F_q)\n            \n            q_k += dq\n            p_k += dp\n\n        # Return the last computed value if max_iter is reached.\n        # For this problem setup, convergence should be rapid.\n        return q_k, p_k\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a full simulation for a given test case configuration.\n        \"\"\"\n        M, K = case[\"M\"], case[\"K\"]\n        G_func = case[\"G\"]\n        dG_disc_func = case[\"dG_disc\"]\n        J_dG_disc_func = case[\"J_dG_disc\"]\n        q, p = case[\"q0\"], case[\"p0\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n\n        H_func = get_hamiltonian_func(M, K, G_func)    \n        \n        energies = np.zeros(N + 1)\n        energies[0] = H_func(q, p)\n\n        for i in range(N):\n            q, p = newton_solver(q, p, M, K, dG_disc_func, J_dG_disc_func, dt)\n            energies[i+1] = H_func(q, p)\n            \n        initial_energy = energies[0]\n        max_dev = np.max(np.abs(energies - initial_energy))\n        \n        return max_dev\n\n    # --- Test Case Definitions ---\n\n    # Case 1: 1D Linear Oscillator\n    case1 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[1.0]]),\n        \"G\": lambda q: 0.0,\n        \"dG_disc\": lambda q0, q1: np.array([0.0]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[0.0]]),\n        \"q0\": np.array([1.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.05, \"N\": 200,\n    }\n\n    # Case 2: 1D Quartic Nonlinearity\n    lam = 0.3\n    case2 = {\n        \"M\": np.array([[1.5]]), \"K\": np.array([[0.7]]),\n        \"G\": lambda q: lam * q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            lam/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            lam/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.2]), \"p0\": np.array([0.3]),\n        \"dt\": 0.02, \"N\": 500,\n    }\n\n    # Case 3: 2D Coupled Polynomial Potential\n    alpha, beta = 0.2, 0.1\n    def G_case3(q):\n        return alpha * (q[0]**4 + q[1]**4) / 4.0 + beta * q[0]**2 * q[1]**2 / 2.0\n\n    def dG_disc_case3(q0, q1):\n        g1 = alpha/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3) + \\\n             beta/4.0 * (q1[0] + q0[0]) * (q1[1]**2 + q0[1]**2)\n        g2 = alpha/4.0 * (q1[1]**3 + q1[1]**2*q0[1] + q1[1]*q0[1]**2 + q0[1]**3) + \\\n             beta/4.0 * (q1[0]**2 + q0[0]**2) * (q1[1] + q0[1])\n        return np.array([g1, g2])\n\n    def J_dG_disc_case3(q0, q1):\n        J11 = alpha/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2) + \\\n              beta/4.0 * (q1[1]**2 + q0[1]**2)\n        J12 = beta/2.0 * (q1[0] + q0[0]) * q1[1]\n        J21 = beta/2.0 * q1[0] * (q1[1] + q0[1])\n        J22 = alpha/4.0 * (3*q1[1]**2 + 2*q1[1]*q0[1] + q0[1]**2) + \\\n              beta/4.0 * (q1[0]**2 + q0[0]**2)\n        return np.array([[J11, J12], [J21, J22]])\n\n    case3 = {\n        \"M\": np.diag([1.0, 2.0]),\n        \"K\": np.array([[2.0, 0.3], [0.3, 1.5]]),\n        \"G\": G_case3,\n        \"dG_disc\": dG_disc_case3,\n        \"J_dG_disc\": J_dG_disc_case3,\n        \"q0\": np.array([0.1, -0.2]), \"p0\": np.array([0.0, 0.25]),\n        \"dt\": 0.015, \"N\": 400,\n    }\n\n    # Case 4: 1D Trivial Equilibrium\n    case4 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[2.0]]),\n        \"G\": lambda q: q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            1.0/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            1.0/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.1, \"N\": 10,\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = [run_simulation(case) for case in test_cases]\n    \n    # Format the output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While exact energy conservation is fundamental for closed systems, most physical models involve interaction with an environment, leading to energy exchange. This practice shifts our focus from strict conservation to a precise energy budget, where the change in a system's energy is balanced by the work done by external forces . You will derive this energy balance for the wave equation with boundary forcing and implement a finite element scheme that captures this physical law at the discrete level, demonstrating that a well-designed integrator can do more than just conserve energyâ€”it can accurately model its flow.",
            "id": "3384928",
            "problem": "Consider the scalar wave equation on a bounded domain with mixed boundary conditions. Let $\\Omega \\subset \\mathbb{R}^d$ be sufficiently regular, partition its boundary $\\partial \\Omega$ into a Dirichlet part $\\partial \\Omega_D$ and a Neumann part $\\partial \\Omega_N$, with $\\partial \\Omega_D \\cap \\partial \\Omega_N = \\emptyset$ and $\\partial \\Omega_D \\cup \\partial \\Omega_N = \\partial \\Omega$. The scalar displacement $u(x,t)$ satisfies the initial-boundary value problem\n$$\nu_{tt}(x,t) = c^2 \\Delta u(x,t) \\quad \\text{for } x \\in \\Omega, \\ t \\ge 0,\n$$\nwith boundary conditions\n$$\nu(x,t) = 0 \\ \\text{on } \\partial \\Omega_D, \\qquad c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t) \\ \\text{on } \\partial \\Omega_N,\n$$\nand initial data $u(x,0) = u_0(x)$, $u_t(x,0) = v_0(x)$. Here $c > 0$ is the wave speed, $\\Delta$ is the Laplace operator, and $\\partial u/\\partial n$ is the outward normal derivative. Define the mechanical energy\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\n\nTask 1 (Derivation from first principles): Starting from the stated partial differential equation and boundary conditions, derive from first principles an exact expression for the time derivative $\\frac{d}{dt} E(t)$ in terms of boundary fluxes and interior terms. Show how the boundary conditions determine which parts contribute to the energy rate and which do not, and express the final rate only through quantities defined on $\\partial \\Omega_N$.\n\nTask 2 (Discretization design): Specialize to the one-dimensional case with $\\Omega = (0,L)$, Dirichlet at $x=0$ and Neumann at $x=L$. Work in dimensionless units throughout. Use the standard Galerkin finite element method with continuous, piecewise-linear basis functions on a uniform mesh of $N_{\\text{el}}$ elements. Derive the semi-discrete system in first-order form\n$$\n\\mathbf{u}_t = \\mathbf{v}, \\qquad \\mathbf{M} \\mathbf{v}_t + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t),\n$$\nwhere $\\mathbf{M}$ is the consistent mass matrix, $\\mathbf{K}$ is the stiffness matrix weighted by $c^2$, and $\\mathbf{f}(t)$ is the Neumann load vector assembled from the boundary traction at $x=L$. Define the discrete energy\n$$\nE_d(t) = \\frac{1}{2} \\mathbf{v}(t)^{\\top} \\mathbf{M} \\mathbf{v}(t) + \\frac{1}{2} \\mathbf{u}(t)^{\\top} \\mathbf{K} \\mathbf{u}(t).\n$$\nDerive the semi-discrete energy rate and show its dependence on the discrete boundary traction applied at $x=L$.\n\nTask 3 (Energy-consistent time integrator): Design and implement an energy-consistent time integrator for the semi-discrete system. Use the implicit midpoint rule applied to the first-order form above, with the load vector evaluated at the temporal midpoint. Derive the one-step update equations and the linear system to be solved each step. Show that, in the absence of Neumann boundary traction, the discrete energy is exactly conserved by the method, and in its presence, the discrete energy change over a time step matches the discrete boundary work computed with midpoint quadrature.\n\nTask 4 (Program and test suite): Implement the one-dimensional finite element assembly and the implicit midpoint time integrator to verify the energy budget numerically. All quantities are dimensionless. For each test case below, integrate to time $T$ with time step $\\Delta t$ and compute the absolute discrepancy\n$$\n\\varepsilon = \\left| E_d(T) - E_d(0) - W \\right|,\n$$\nwhere $W$ is the discrete boundary work accumulated as\n$$\nW = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right),\n$$\nwith $\\mathbf{v}_{n+\\frac{1}{2}}$ and $\\mathbf{f}\\!\\left(t_{n+\\frac{1}{2}}\\right)$ evaluated at the temporal midpoint $t_{n+\\frac{1}{2}} = t_n + \\Delta t/2$. Use the following test suite:\n\n- Test case 1 (no boundary work, energy conservation): $L = 1$, $c = 1$, $N_{\\text{el}} = 50$, $\\Delta t = 10^{-3}$, $T = 0.5$, Neumann traction $g(t) = 0$, initial displacement $u_0(x) = \\sin(\\pi x)$, initial velocity $v_0(x) = 0$.\n- Test case 2 (sinusoidal boundary work injection): $L = 1$, $c = 1$, $N_{\\text{el}} = 50$, $\\Delta t = 10^{-3}$, $T = 0.5$, Neumann traction $g(t) = \\sin(6\\pi t)$, initial displacement $u_0(x) = 0$, initial velocity $v_0(x) = 0$.\n- Test case 3 (ramp boundary work with nonzero initial velocity): $L = 1$, $c = 0.8$, $N_{\\text{el}} = 60$, $\\Delta t = 5 \\times 10^{-4}$, $T = 0.6$, Neumann traction $g(t) = 0.5\\, t$, initial displacement $u_0(x) = 0$, initial velocity $v_0(x) = \\sin(2\\pi x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result must be the floating-point value of $\\varepsilon$ for the corresponding test case, in the order listed above.",
            "solution": "The problem posed is a comprehensive exercise in the numerical analysis of partial differential equations, specifically focusing on energy-conserving integrators for the wave equation. It is scientifically sound, well-posed, and all its components are standard in the field of computational mechanics and geometric numerical integration. The problem is validated as sound and a full solution can be constructed. The solution will proceed by addressing each of the four tasks in order: derivation of the continuous energy balance, finite element semi-discretization, design of an energy-consistent time integrator, and finally, numerical implementation and verification.\n\n### Task 1: Continuous Energy Rate Derivation\n\nThe mechanical energy of the system is defined as\n$$\nE(t) = \\frac{1}{2} \\int_{\\Omega} \\left( u_t(x,t)^2 + c^2 \\left|\\nabla u(x,t)\\right|^2 \\right) \\, dx.\n$$\nTo find its rate of change, we differentiate with respect to time $t$. Since the domain $\\Omega$ is fixed, we can move the derivative inside the integral (Leibniz integral rule):\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( \\frac{\\partial}{\\partial t} \\left(\\frac{1}{2} u_t^2\\right) + \\frac{\\partial}{\\partial t} \\left(\\frac{c^2}{2} |\\nabla u|^2\\right) \\right) \\, dx = \\int_{\\Omega} \\left( u_t u_{tt} + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx.\n$$\nWe substitute the wave equation, $u_{tt} = c^2 \\Delta u$, into this expression:\n$$\n\\frac{dE}{dt} = \\int_{\\Omega} \\left( u_t (c^2 \\Delta u) + c^2 \\nabla u \\cdot \\nabla u_t \\right) \\, dx = c^2 \\int_{\\Omega} \\left( u_t \\Delta u + \\nabla u_t \\cdot \\nabla u \\right) \\, dx.\n$$\nRecognizing the integrand as the expansion of a divergence, specifically using the product rule $\\nabla \\cdot (\\phi \\mathbf{F}) = (\\nabla \\phi) \\cdot \\mathbf{F} + \\phi (\\nabla \\cdot \\mathbf{F})$, we let $\\phi = u_t$ and $\\mathbf{F} = \\nabla u$. This gives $\\nabla \\cdot (u_t \\nabla u) = \\nabla u_t \\cdot \\nabla u + u_t \\Delta u$. The integrand is precisely this expression. Thus,\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\Omega} \\nabla \\cdot (u_t \\nabla u) \\, dx.\n$$\nApplying the divergence theorem, $\\int_{\\Omega} \\nabla \\cdot \\mathbf{V} \\, dx = \\oint_{\\partial \\Omega} \\mathbf{V} \\cdot \\mathbf{n} \\, ds$, where $\\mathbf{n}$ is the outward unit normal vector, we obtain:\n$$\n\\frac{dE}{dt} = c^2 \\oint_{\\partial \\Omega} (u_t \\nabla u) \\cdot \\mathbf{n} \\, ds = c^2 \\oint_{\\partial \\Omega} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\nThe boundary $\\partial \\Omega$ is partitioned into $\\partial \\Omega_D$ and $\\partial \\Omega_N$. We split the integral accordingly:\n$$\n\\frac{dE}{dt} = c^2 \\int_{\\partial \\Omega_D} u_t \\frac{\\partial u}{\\partial n} \\, ds + c^2 \\int_{\\partial \\Omega_N} u_t \\frac{\\partial u}{\\partial n} \\, ds.\n$$\nOn the Dirichlet boundary $\\partial \\Omega_D$, we have $u(x,t) = 0$ for all $t \\ge 0$. This implies its tangential derivatives are zero, and its time derivative is also zero: $u_t(x,t) = 0$ for $x \\in \\partial \\Omega_D$. Therefore, the first integral vanishes. On the Neumann boundary $\\partial \\Omega_N$, the condition is $c^2 \\frac{\\partial u}{\\partial n}(x,t) = g(x,t)$. Substituting these conditions yields the final expression for the energy rate:\n$$\n\\frac{dE}{dt} = 0 + \\int_{\\partial \\Omega_N} u_t(x,t) \\left( c^2 \\frac{\\partial u}{\\partial n}(x,t) \\right) \\, ds = \\int_{\\partial \\Omega_N} u_t(x,t) g(x,t) \\, ds.\n$$\nThis result shows that the rate of change of the system's mechanical energy is equal to the power supplied by the traction forces $g(x,t)$ on the Neumann boundary. If $g=0$ or $\\partial\\Omega_N$ is empty, energy is conserved.\n\n### Task 2: Semi-Discretization and Discrete Energy Rate\n\nFor the 1D case on $\\Omega = (0,L)$ with $u(0,t)=0$ and $c^2 u_x(L,t) = g(t)$, we use the Galerkin finite element method. The displacement is approximated as $u(x,t) \\approx u^h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)$, where $\\phi_j(x)$ are the standard piecewise-linear \"hat\" basis functions on a uniform mesh of size $h = L/N_{\\text{el}}$ ($N=N_{\\text{el}}$ is the number of free nodes). The basis function $\\phi_j(x)$ is $1$ at node $x_j=j \\cdot h$ and $0$ at all other nodes. The sum starts from $j=1$ to enforce the Dirichlet condition $u(0,t)=0$. The weak form of the PDE is obtained by multiplying by a test function $w^h(x) = \\sum_{i=1}^N w_i \\phi_i(x)$ and integrating over the domain:\n$$\n\\int_0^L w^h u^h_{tt} \\, dx + c^2 \\int_0^L w^h_x u^h_x \\, dx = \\left[ c^2 w^h u^h_x \\right]_0^L.\n$$\nThe boundary term evaluates to $w^h(L) g(t)$ since $w^h(0)=0$ and $c^2 u_x(L,t)=g(t)$. Substituting the FEM expansions for $u^h$ and $w^h$ and requiring the equation to hold for all $w_i$ (i.e., for each basis function $\\phi_i$) yields the semi-discrete system:\n$$\n\\sum_{j=1}^N \\left(\\int_0^L \\phi_i \\phi_j dx\\right) \\ddot{u}_j(t) + c^2 \\sum_{j=1}^N \\left(\\int_0^L \\phi'_i \\phi'_j dx\\right) u_j(t) = \\phi_i(L) g(t), \\quad_ \\text{for } i=1, \\dots, N.\n$$\nThis is the second-order matrix system $\\mathbf{M} \\ddot{\\mathbf{u}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$, with matrix and vector entries:\n- Mass Matrix: $M_{ij} = \\int_0^L \\phi_i(x) \\phi_j(x) \\, dx$.\n- Stiffness Matrix: $K_{ij} = c^2 \\int_0^L \\phi'_i(x) \\phi'_j(x) \\, dx$.\n- Load Vector: $f_i(t) = \\phi_i(L) g(t)$. This vector is zero except for its last component, $f_N(t) = \\phi_N(L) g(t) = g(t)$.\nDefining $\\mathbf{v} = \\dot{\\mathbf{u}}$, we get the first-order system: $\\dot{\\mathbf{u}} = \\mathbf{v}$, $\\mathbf{M} \\dot{\\mathbf{v}} + \\mathbf{K} \\mathbf{u} = \\mathbf{f}(t)$.\nThe discrete energy is $E_d(t) = \\frac{1}{2} \\mathbf{v}^{\\top} \\mathbf{M} \\mathbf{v} + \\frac{1}{2} \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u}$. Its time derivative is:\n$$\n\\frac{dE_d}{dt} = \\dot{\\mathbf{v}}^{\\top} \\mathbf{M} \\mathbf{v} + \\dot{\\mathbf{u}}^{\\top} \\mathbf{K} \\mathbf{u}.\n$$\n(using symmetry of $\\mathbf{M}$ and $\\mathbf{K}$). Substituting $\\dot{\\mathbf{u}}=\\mathbf{v}$ and $\\mathbf{M}\\dot{\\mathbf{v}} = \\mathbf{f} - \\mathbf{K}\\mathbf{u}$:\n$$\n\\frac{dE_d}{dt} = (\\mathbf{M}^{-1}(\\mathbf{f} - \\mathbf{K}\\mathbf{u}))^{\\top} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = (\\mathbf{f} - \\mathbf{K}\\mathbf{u})^{\\top} \\mathbf{M}^{-1} \\mathbf{M} \\mathbf{v} + \\mathbf{v}^{\\top} \\mathbf{K} \\mathbf{u} = \\mathbf{f}^{\\top}\\mathbf{v} - \\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} + \\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}.\n$$\nSince $\\mathbf{u}^{\\top}\\mathbf{K}\\mathbf{v} = (\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u})^{\\top}$ is a scalar, it equals $\\mathbf{v}^{\\top}\\mathbf{K}\\mathbf{u}$. The terms involving $\\mathbf{K}$ cancel, leaving:\n$$\n\\frac{dE_d}{dt} = \\mathbf{v}^{\\top} \\mathbf{f}(t).\n$$\nThis is the discrete analogue of the continuous power identity, where the rate of energy change is the inner product of the generalized velocity vector and the external force vector.\n\n### Task 3: Energy-Consistent Time Integrator\n\nThe implicit midpoint rule is applied to the first-order system over a time step $\\Delta t$ from $t_n$ to $t_{n+1}$:\n$$\n\\frac{\\mathbf{u}_{n+1} - \\mathbf{u}_n}{\\Delta t} = \\mathbf{v}_{n+\\frac{1}{2}}, \\qquad \\mathbf{M} \\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} + \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}} = \\mathbf{f}_{n+\\frac{1}{2}},\n$$\nwhere quantities at the midpoint are defined as averages, e.g., $\\mathbf{u}_{n+\\frac{1}{2}} = (\\mathbf{u}_n + \\mathbf{u}_{n+1})/2$.\nTo derive the one-step update, we eliminate $\\mathbf{v}_{n+1}$ and $\\mathbf{v}_{n+\\frac{1}{2}}$. From the first equation, $\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$, and $\\mathbf{v}_{n+1} = 2\\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{v}_n$. Substituting these into the second equation yields a system for the unknown $\\mathbf{u}_{n+1}$. After algebraic manipulation, we arrive at the linear system to be solved for $\\mathbf{u}_{n+1}$ at each time step:\n$$\n\\left(\\mathbf{M} + \\frac{\\Delta t^2}{4}\\mathbf{K}\\right) \\mathbf{u}_{n+1} = \\frac{\\Delta t^2}{2} \\mathbf{f}_{n+\\frac{1}{2}} + \\left(\\mathbf{M} - \\frac{\\Delta t^2}{4}\\mathbf{K}\\right)\\mathbf{u}_n + \\Delta t \\mathbf{M} \\mathbf{v}_n.\n$$\nOnce $\\mathbf{u}_{n+1}$ is computed, $\\mathbf{v}_{n+1}$ is found via $\\mathbf{v}_{n+1} = \\frac{2}{\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\mathbf{v}_n$.\n\nTo demonstrate the energy-consistency property, we examine the change in discrete energy over one step, $E_{d,n+1} - E_{d,n}$:\n$$\nE_{d,n+1} - E_{d,n} = \\frac{1}{2}(\\mathbf{v}_{n+1}^{\\top}\\mathbf{M}\\mathbf{v}_{n+1} - \\mathbf{v}_n^{\\top}\\mathbf{M}\\mathbf{v}_n) + \\frac{1}{2}(\\mathbf{u}_{n+1}^{\\top}\\mathbf{K}\\mathbf{u}_{n+1} - \\mathbf{u}_n^{\\top}\\mathbf{K}\\mathbf{u}_n).\n$$\nUsing the identity $a^2-b^2 = (a-b)(a+b)$, this becomes:\n$$\nE_{d,n+1} - E_{d,n} = (\\mathbf{v}_{n+1} - \\mathbf{v}_n)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + (\\mathbf{u}_{n+1} - \\mathbf{u}_n)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nSubstituting the midpoint rule discretizations, $\\mathbf{u}_{n+1} - \\mathbf{u}_n = \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}$ and $\\mathbf{v}_{n+1} - \\mathbf{v}_n = \\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})$:\n$$\nE_{d,n+1} - E_{d,n} = \\left(\\Delta t \\mathbf{M}^{-1}(\\mathbf{f}_{n+\\frac{1}{2}} - \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}})\\right)^{\\top} \\mathbf{M} \\mathbf{v}_{n+\\frac{1}{2}} + \\left(\\Delta t \\mathbf{v}_{n+\\frac{1}{2}}\\right)^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nThis simplifies to:\n$$\nE_{d,n+1} - E_{d,n} = \\Delta t \\left( \\mathbf{f}_{n+\\frac{1}{2}}^{\\top} \\mathbf{v}_{n+\\frac{1}{2}} - \\mathbf{u}_{n+\\frac{1}{2}}^{\\top}\\mathbf{K}\\mathbf{v}_{n+\\frac{1}{2}} \\right) + \\Delta t \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{K} \\mathbf{u}_{n+\\frac{1}{2}}.\n$$\nThe terms involving $\\mathbf{K}$ cancel, leaving $E_{d,n+1} - E_{d,n} = \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$. This equation demonstrates that the change in discrete energy over one step is exactly equal to the work done by the external forces, evaluated with midpoint quadrature. Summing over all time steps gives $E_d(T) - E_d(0) = W$, where $W = \\sum_{n=0}^{N-1} \\Delta t \\, \\mathbf{v}_{n+\\frac{1}{2}}^{\\top} \\mathbf{f}_{n+\\frac{1}{2}}$. Thus, the method exactly balances the discrete energy budget. In the absence of external forces ($\\mathbf{f}=0$), $W=0$ and the discrete energy $E_d$ is exactly conserved.\n\n### Task 4: Program and Test Suite Implementation\n\nThe implementation translates the derived mathematical framework into a computer program. A Python script is developed to perform the following steps for each test case:\n1.  **FEM Assembly**: The consistent mass matrix $\\mathbf{M}$ and stiffness matrix $\\mathbf{K}$ (scaled by $c^2$) are assembled for a 1D uniform mesh with $N_{\\text{el}}$ piecewise-linear elements, corresponding to $N=N_{\\text{el}}$ unconstrained degrees of freedom.\n2.  **Initial Conditions**: The initial displacement $u_0(x)$ and velocity $v_0(x)$ are projected onto the finite element basis by solving the linear systems $\\mathbf{M}\\mathbf{u}_0 = \\mathbf{b}_u$ and $\\mathbf{M}\\mathbf{v}_0 = \\mathbf{b}_v$, where the right-hand sides are computed via $b_i = \\int_0^L f(x)\\phi_i(x)dx$ for $f=u_0, v_0$. This ensures a consistent initialization of the discrete state.\n3.  **Time Integration**: A loop executes the implicit midpoint rule for the specified number of time steps. In each step, the linear system for $\\mathbf{u}_{n+1}$ is formed and solved. The velocity $\\mathbf{v}_{n+1}$ is then updated.\n4.  **Energy and Work Calculation**: The initial energy $E_d(0)$ is computed. During the time-stepping loop, the accumulated boundary work $W$ is updated at each step using the midpoint values of velocity and force. After the loop, the final energy $E_d(T)$ is computed.\n5.  **Discrepancy**: The absolute discrepancy $\\varepsilon = |E_d(T) - E_d(0) - W|$ is calculated. Due to the energy-consistent nature of the scheme, this value is expected to be close to machine precision, confirming the theoretical derivation.\n\nThe program is structured to run the provided test suite and output the resulting discrepancy for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef run_simulation(L, c, Nel, dt, T, g_func, u0_func, v0_func):\n    \"\"\"\n    Performs one complete simulation for the 1D wave equation.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nel (int): Number of elements.\n        dt (float): Time step.\n        T (float): Final time.\n        g_func (callable): Neumann traction function g(t).\n        u0_func (callable): Initial displacement function u0(x).\n        v0_func (callable): Initial velocity function v0(x).\n\n    Returns:\n        float: The absolute energy discrepancy epsilon.\n    \"\"\"\n    # 1. Mesh and Matrix Assembly\n    N = Nel\n    h = L / float(Nel)\n    nodes = np.linspace(0, L, Nel + 1)\n\n    M = np.zeros((N, N))\n    K = np.zeros((N, N))\n\n    # Assemble tridiagonal M and K matrices for 1D linear elements\n    # Diagonal entries\n    for i in range(N - 1):\n        M[i, i] = 2.0 * h / 3.0\n        K[i, i] = 2.0 * c**2 / h\n    M[N - 1, N - 1] = h / 3.0\n    K[N - 1, N - 1] = c**2 / h\n\n    # Off-diagonal entries\n    for i in range(N - 1):\n        M[i, i + 1] = h / 6.0\n        M[i + 1, i] = h / 6.0\n        K[i, i + 1] = -c**2 / h\n        K[i + 1, i] = -c**2 / h\n    \n    # 2. Initial Conditions (L2 Projection)\n    u = np.zeros(N)\n    v = np.zeros(N)\n\n    # Check if u0 is a non-zero function\n    if np.any(u0_func(np.linspace(0, L, 20)) != 0):\n        b_u = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            # Linear function for the \"up-slope\" part of the hat function\n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: u0_func(x) * up_slope(x), x_left, x_center)[0]\n            \n            if node_idx < N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                # Linear function for the \"down-slope\"\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: u0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_u[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_u[i] = integral1\n        u = np.linalg.solve(M, b_u)\n\n    # Check if v0 is a non-zero function\n    if np.any(v0_func(np.linspace(0, L, 20)) != 0):\n        b_v = np.zeros(N)\n        for i in range(N):\n            node_idx = i + 1\n            x_center = nodes[node_idx]\n            x_left = nodes[node_idx - 1]\n            \n            def up_slope(x): return (x - x_left) / h\n            integral1 = quad(lambda x: v0_func(x) * up_slope(x), x_left, x_center)[0]\n\n            if node_idx < N:  # Full hat function\n                x_right = nodes[node_idx + 1]\n                def down_slope(x): return (x_right - x) / h\n                integral2 = quad(lambda x: v0_func(x) * down_slope(x), x_center, x_right)[0]\n                b_v[i] = integral1 + integral2\n            else:  # Half hat function at x=L\n                b_v[i] = integral1\n        v = np.linalg.solve(M, b_v)\n\n    # 3. Energy and Work Calculation\n    def calculate_energy(u_vec, v_vec, M_mat, K_mat):\n        E_kin = 0.5 * v_vec.T @ M_mat @ v_vec\n        E_pot = 0.5 * u_vec.T @ K_mat @ u_vec\n        return E_kin + E_pot\n    \n    E0 = calculate_energy(u, v, M, K)\n    W = 0.0\n\n    # 4. Time Stepping with Implicit Midpoint Rule\n    num_steps = int(round(T / dt))\n    \n    # System matrix for the update equation (constant in time)\n    A_sys = M + (dt**2 / 4.0) * K\n    M_term = M - (dt**2 / 4.0) * K\n    dtM = dt * M\n\n    for n in range(num_steps):\n        t_mid = (n + 0.5) * dt\n        \n        # Neumann force vector\n        f_mid = np.zeros(N)\n        f_mid[-1] = g_func(t_mid)\n\n        # Form the RHS of the linear system\n        b = (dt**2 / 2.0) * f_mid + M_term @ u + dtM @ v\n        \n        # Solve for new displacement\n        u_new = np.linalg.solve(A_sys, b)\n        \n        # Update velocity\n        v_new = (2.0 / dt) * (u_new - u) - v\n        \n        # Midpoint velocity for work calculation\n        v_mid = 0.5 * (v + v_new)\n\n        # Update work\n        work_increment = dt * (v_mid.T @ f_mid)\n        W += work_increment\n        \n        # Update state for next step\n        u, v = u_new, v_new\n        \n    ET = calculate_energy(u, v, M, K)\n    \n    discrepancy = abs(ET - E0 - W)\n    return discrepancy\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # Test case 1 (L, c, Nel, dt, T, g(t), u0(x), v0(x))\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: 0.0, \n         lambda x: np.sin(np.pi * x), \n         lambda x: 0.0),\n        \n        # Test case 2\n        (1.0, 1.0, 50, 1e-3, 0.5, \n         lambda t: np.sin(6 * np.pi * t), \n         lambda x: 0.0, \n         lambda x: 0.0),\n        \n        # Test case 3\n        (1.0, 0.8, 60, 5e-4, 0.6, \n         lambda t: 0.5 * t, \n         lambda x: 0.0, \n         lambda x: np.sin(2 * np.pi * x)),\n    ]\n\n    results = []\n    for params in test_cases:\n        discrepancy = run_simulation(*params)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In modern scientific computing, efficiency often demands that the computational mesh adapts to the solution's features, a technique known as adaptive mesh refinement (AMR). However, changing the discretization mid-simulation poses a significant challenge to conservation laws. This exercise tackles this advanced, practical problem by asking you to design a remapping procedure that conserves energy when the mesh is refined or coarsened . You will learn how a naive interpolation fails and how a corrective step, such as a global energy-scaling factor, can elegantly enforce the conservation law in a dynamic computational setting.",
            "id": "3384904",
            "problem": "Consider the one-dimensional linear wave equation on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions, discretized in space by the first-order continuous Finite Element Method (FEM) on a possibly nonuniform mesh and integrated in time by a method that preserves a discrete energy invariant. Let $c>0$ denote the wave speed. On a given mesh with $n$ interior nodes, let $M\\in \\mathbb{R}^{n\\times n}$ be the symmetric positive definite FEM mass matrix and $K\\in \\mathbb{R}^{n\\times n}$ be the symmetric positive semidefinite FEM stiffness matrix for $c^2 u_{xx}$. The semi-discrete equations of motion are\n$$\nM \\, \\ddot{q}(t) + K \\, q(t) = 0,\n$$\nwhere $q(t)\\in \\mathbb{R}^n$ are the interior nodal values of $u(x,t)$ at time $t$. Introducing the canonical momentum $p(t) := M \\, \\dot{q}(t)$ yields the first-order form\n$$\n\\dot{q}(t) = M^{-1} p(t), \\qquad \\dot{p}(t) = - K \\, q(t).\n$$\nDefine the discrete energy (Hamiltonian)\n$$\nE(t) = \\tfrac{1}{2} \\, p(t)^{\\top} M^{-1} p(t) + \\tfrac{1}{2} \\, q(t)^{\\top} K \\, q(t).\n$$\nYou must implement:\n- A time integrator that, for fixed $(M,K)$, preserves the discrete energy $E(t)$ to within machine precision for the quadratic Hamiltonian above.\n- An adaptive mesh refinement (AMR) remapping at specified regridding steps, where the mesh (and thus the matrices $M$ and $K$) changes in time. The remapping must map the state $(q,p)$ from the old mesh to the new mesh such that the discrete energy computed with the new $(M,K)$ immediately after remapping equals the discrete energy computed with the old $(M,K)$ immediately before remapping (to within machine precision), i.e., if $(q^{-},p^{-},M^{-},K^{-})$ is the state just before remapping and $(q^{+},p^{+},M^{+},K^{+})$ is the state just after, then $E^{+} = E^{-}$, where\n$$\nE^{-} = \\tfrac{1}{2} \\, (p^{-})^{\\top} (M^{-})^{-1} p^{-} + \\tfrac{1}{2} \\, (q^{-})^{\\top} K^{-} q^{-}, \\quad\nE^{+} = \\tfrac{1}{2} \\, (p^{+})^{\\top} (M^{+})^{-1} p^{+} + \\tfrac{1}{2} \\, (q^{+})^{\\top} K^{+} q^{+}.\n$$\n\nThe spatial discretization must use continuous, piecewise-linear FEM on a one-dimensional mesh with homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$. The local element matrices for an element of length $h$ are the standard ones:\n- For the mass: $\\tfrac{h}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix}$,\n- For the stiffness: $\\tfrac{c^2}{h}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix}$.\n\nYou must design a remapping strategy at regridding events that:\n- Uses the old discrete state to define a continuous, piecewise-linear field and its time derivative on the old mesh,\n- Constructs a new discrete state on the new mesh, and\n- Enforces $E^{+}=E^{-}$ computed with the new matrices via a deterministic, mesh-local or global algebraic operation.\n\nInitial conditions are specified via continuous functions $u_0(x)$ and $v_0(x)=\\partial_t u(x,0)$; in the discrete setting, you must initialize $q(0)$ by interpolating $u_0$ at interior mesh nodes and initialize $p(0)=M \\, v(0)$ from the nodal values of $v_0$.\n\nYou must implement the following fixed test suite. In all cases, use the interval $[0,1]$ with homogeneous Dirichlet boundary conditions, and a base uniform coarse mesh with $N=64$ intervals (so the coarse nodal spacing is $h=1/64$). When a refined mesh is specified, refine the central region $[0.25,0.75]$ by a factor of $2$ (so the spacing there is $h/2$) while keeping the coarse spacing outside that region. Regridding events occur at specified time steps and must be handled by your energy-preserving remapping.\n\nFor all tests, angles appearing in trigonometric functions are in radians. There are no physical units to report; energies and errors are dimensionless.\n\n- Test case A (happy path, coarse to refined):\n  - Wave speed: $c=1$.\n  - Time step: $\\Delta t = 0.001$.\n  - Final time: $T=0.5$.\n  - Initial mesh: uniform coarse mesh with $N=64$ intervals.\n  - Regridding: at time step $n=200$, change to the refined mesh described above; no further regridding.\n  - Initial data: $u_0(x) = \\sin(\\pi x)$, $v_0(x) = 0$.\n\n- Test case B (refined to coarse):\n  - Wave speed: $c=1$.\n  - Time step: $\\Delta t = 0.001$.\n  - Final time: $T=0.5$.\n  - Initial mesh: refined mesh as described above.\n  - Regridding: at time step $n=200$, change to the uniform coarse mesh; no further regridding.\n  - Initial data: $u_0(x) = 0$, $v_0(x) = \\sin(2\\pi x)$.\n\n- Test case C (two regrids, different speed):\n  - Wave speed: $c=1.3$.\n  - Time step: $\\Delta t = 0.001$.\n  - Final time: $T=0.6$.\n  - Initial mesh: uniform coarse mesh with $N=64$ intervals.\n  - Regridding: at time step $n=150$, change to the refined mesh; at time step $n=350$, change back to the uniform coarse mesh.\n  - Initial data: $u_0(x) = 0.2\\sin(\\pi x) + 0.1\\sin(2\\pi x)$, $v_0(x) = \\sin(3\\pi x)$.\n\nYour program must, for each test case, compute the maximum absolute relative energy deviation over the entire time integration, defined as\n$$\n\\max_{0 \\le n \\le N_T} \\frac{\\left|E^n - E^0\\right|}{E^0},\n$$\nwhere $E^n$ is the discrete energy after step $n$ (including immediately after any regridding), and $N_T$ is the total number of time steps to reach the final time. Use the same time step $\\Delta t$ before and after regridding.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [result for A, result for B, result for C]. Each result must be a floating-point number. For example: \"[0.0,1.0,2.0]\".",
            "solution": "The user-provided problem is valid. It is a well-posed problem in the field of numerical analysis for partial differential equations, grounded in the established principles of finite element methods and geometric numerical integration. All parameters are clearly defined, and the objectives are quantitative and verifiable.\n\nThe solution requires the design and implementation of a numerical scheme for the one-dimensional linear wave equation. The scheme must handle two distinct requirements for energy conservation:\n1.  Conservation of a discrete energy invariant during time evolution on a fixed spatial mesh.\n2.  Conservation of the same discrete energy across adaptive mesh refinement (AMR) events, where the underlying mesh, and thus the system matrices, change.\n\nThe overall approach is to combine an energy-conserving time integrator for the semi-discretized Hamiltonian system with a carefully designed energy-preserving remapping procedure at regridding steps.\n\n### 1. Spatial Discretization: Finite Element Method (FEM)\n\nThe linear wave equation $u_{tt} - c^2 u_{xx} = 0$ is discretized in space on the interval $[0,1]$ using the continuous, piecewise-linear Galerkin finite element method. For a given mesh of $N+1$ nodes $x_0, x_1, \\dots, x_N$ with $x_0=0$ and $x_N=1$, the solution $u(x,t)$ is approximated by $u_h(x,t) = \\sum_{j=1}^{N-1} q_j(t) \\phi_j(x)$, where $\\phi_j(x)$ are the standard \"hat\" basis functions and $q_j(t)$ are the time-dependent coefficients representing the solution at the $n=N-1$ interior nodes. Homogeneous Dirichlet boundary conditions $u(0,t)=u(1,t)=0$ are imposed by excluding the boundary nodes from the degrees of freedom.\n\nApplying the Galerkin method yields the semi-discrete system of ordinary differential equations:\n$$\nM \\ddot{q}(t) + K q(t) = 0\n$$\nwhere $q(t) \\in \\mathbb{R}^n$ is the vector of interior nodal values. The matrices $M$ (mass matrix) and $K$ (stiffness matrix) are assembled by summing contributions from each element $[x_i, x_{i+1}]$. For an element of length $h = x_{i+1} - x_i$, the local $2 \\times 2$ element matrices are given as:\n- Mass matrix: $M_e = \\frac{h}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix}$\n- Stiffness matrix: $K_e = \\frac{c^2}{h}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix}$\n\nThe global matrix $M$ is symmetric positive definite (SPD), while $K$ is symmetric positive semidefinite (SPSD).\n\n### 2. Energy-Conserving Time Integration\n\nThe semi-discrete system is a Hamiltonian system. By defining the canonical momentum $p(t) = M \\dot{q}(t)$, the second-order system is transformed into a first-order system:\n$$\n\\dot{q}(t) = M^{-1} p(t), \\qquad \\dot{p}(t) = -K q(t)\n$$\nThe Hamiltonian, representing the discrete energy of the system, is the sum of kinetic and potential energies:\n$$\nE(q, p) = \\underbrace{\\frac{1}{2} \\dot{q}(t)^{\\top} M \\dot{q}(t)}_{\\text{Kinetic}} + \\underbrace{\\frac{1}{2} q(t)^{\\top} K q(t)}_{\\text{Potential}} = \\frac{1}{2} p(t)^{\\top} M^{-1} p(t) + \\frac{1}{2} q(t)^{\\top} K q(t)\n$$\nTo preserve this quadratic energy invariant to machine precision, a symplectic integrator is the ideal choice. We select the implicit midpoint rule, which is A-stable, second-order accurate, and exactly conserves all quadratic invariants of a linear system. For a time step $\\Delta t$, the update from state $(q^n, p^n)$ to $(q^{n+1}, p^{n+1})$ is defined by:\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = M^{-1} \\left(\\frac{p^n + p^{n+1}}{2}\\right)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -K \\left(\\frac{q^n + q^{n+1}}{2}\\right)\n$$\nThis implicit system can be rearranged into a sequence of explicit updates by first solving for $q^{n+1}$:\n1.  Solve the linear system for $q^{n+1}$:\n    $$\n    \\left(M + \\frac{(\\Delta t)^2}{4} K\\right) q^{n+1} = \\left(M - \\frac{(\\Delta t)^2}{4} K\\right) q^n + \\Delta t \\, p^n\n    $$\n    The matrix on the left-hand side is SPD, ensuring a unique solution.\n2.  Update the momentum $p^{n+1}$:\n    $$\n    p^{n+1} = p^n - \\frac{\\Delta t}{2} K (q^n + q^{n+1})\n    $$\nThis integrator will form the basis of the time evolution between regridding events.\n\n### 3. Energy-Conserving Remapping for AMR\n\nWhen the mesh changes from a grid with matrices $(M^-, K^-)$ to one with $(M^+, K^+)$, the state vector $(q^-, p^-)$ must be mapped to a new state $(q^+, p^+)$ such that the discrete energy is conserved, i.e., $E(q^+, p^+, M^+, K^+) = E(q^-, p^-, M^-, K^-)$.\n\nA naive interpolation of the solution onto the new mesh will not, in general, conserve energy. The problem requires a deterministic procedure to enforce this conservation. We design the following multi-step remapping strategy:\n\n1.  **Reconstruction**: From the discrete state $(q^-, p^-)$ on the old mesh, reconstruct the continuous, piecewise-linear displacement field $u_h^-(x)$ and velocity field $\\dot{u}_h^-(x)$. The nodal velocities $v^-$ are first computed by solving the linear system $M^- v^- = p^-$.\n2.  **Projection/Interpolation**: An initial guess for the new state, $(\\tilde{q}^+, \\tilde{v}^+)$, is obtained by interpolating the continuous fields $u_h^-(x)$ and $\\dot{u}_h^-(x)$ at the interior nodes of the new mesh. The corresponding new momentum is $\\tilde{p}^+ = M^+ \\tilde{v}^+$.\n3.  **Energy Calculation**: Compute the energy $E^-$ of the pre-remapping state and the energy $\\tilde{E}^+$ of the interpolated post-remapping state:\n    $$\n    E^{-} = E(q^-, p^-, M^-, K^-), \\qquad \\tilde{E}^{+} = E(\\tilde{q}^+, \\tilde{p}^+, M^+, K^+)\n    $$\n4.  **Energy-Conserving Scaling**: To enforce $E^+ = E^-$, we introduce a global scaling factor $\\alpha$. The final post-remapping state $(q^+, p^+)$ is defined as a scaled version of the interpolated state:\n    $$\n    q^+ = \\alpha \\tilde{q}^+, \\qquad p^+ = \\alpha \\tilde{p}^+\n    $$\n    The energy of this new state is $E^+ = \\alpha^2 \\tilde{E}^+$. Setting $E^+ = E^-$ yields the deterministic scaling factor:\n    $$\n    \\alpha = \\sqrt{\\frac{E^{-}}{\\tilde{E}^{+}}}\n    $$\n    This operation ensures that the energy after remapping is identical (to machine precision) to the energy before remapping, satisfying the problem's constraint.\n\n### 4. Overall Algorithm\n\nThe complete numerical simulation for each test case proceeds as follows:\n1.  **Initialization**: Set parameters ($c, \\Delta t, T$), define regridding schedule, and specify initial condition functions $u_0(x), v_0(x)$.\n2.  **Initial State**: Generate the initial mesh and assemble the corresponding matrices $M$ and $K$. Initialize the state vectors $q(0)$ and $p(0)$ by interpolating $u_0(x)$ and $v_0(x)$ at the interior nodes and setting $p(0)=M v(0)$.\n3.  **Initial Energy**: Compute and store the initial energy $E^0 = E(q(0), p(0), M, K)$.\n4.  **Time Loop**: For each time step $n=0, 1, \\dots, N_T-1$:\n    a. **Regridding Check**: If step $n$ is a scheduled regridding event, execute the energy-conserving remapping procedure described in Section 3 to obtain the new state $(q, p)$ and matrices $(M, K)$. Calculate and store the energy immediately after remapping.\n    b. **Time Integration**: Advance the state from $(q, p)$ at time $t_n$ to $(q, p)$ at time $t_{n+1}$ using one step of the implicit midpoint rule described in Section 2.\n    c. **Energy Tracking**: Calculate and store the energy after the time step.\n5.  **Metric Calculation**: After completing all time steps, compute the maximum absolute relative energy deviation over the entire simulation, including the values recorded immediately after any regridding events:\n    $$\n    \\max_{k} \\frac{|E_k - E^0|}{E^0}\n    $$\n    where $\\{E_k\\}$ is the set of all recorded energy values. This metric quantifies the performance of the energy conservation strategy.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_mesh(coarse_N, refined_flag):\n    \"\"\"Generates the mesh node coordinates based on the problem specification.\"\"\"\n    if not refined_flag:\n        return np.linspace(0, 1, coarse_N + 1, dtype=np.float64)\n    else:\n        h = 1.0 / coarse_N\n        n1 = int(round(0.25 / h))\n        nodes1 = np.linspace(0, 0.25, n1 + 1, dtype=np.float64)\n        \n        n2 = int(round(0.5 / (h / 2.0)))\n        nodes2 = np.linspace(0.25, 0.75, n2 + 1, dtype=np.float64)\n        \n        n3 = int(round(0.25 / h))\n        nodes3 = np.linspace(0.75, 1.0, n3 + 1, dtype=np.float64)\n        \n        nodes = np.concatenate((nodes1[:-1], nodes2[:-1], nodes3))\n        return nodes\n\ndef assemble_matrices(nodes, c):\n    \"\"\"Assembles the FEM mass (M) and stiffness (K) matrices.\"\"\"\n    n = len(nodes) - 2\n    if n <= 0:\n        return csc_matrix((0, 0), dtype=np.float64), csc_matrix((0, 0), dtype=np.float64)\n\n    M = lil_matrix((n, n), dtype=np.float64)\n    K = lil_matrix((n, n), dtype=np.float64)\n    \n    for i in range(n + 1):\n        h = nodes[i+1] - nodes[i]\n        \n        m_loc = (h / 6.0) * np.array([[2, 1], [1, 2]])\n        k_loc = (c**2 / h) * np.array([[1, -1], [-1, 1]])\n        \n        g_indices = [i - 1, i]\n        \n        for r_loc in range(2):\n            g_r = g_indices[r_loc]\n            if 0 <= g_r < n:\n                for c_loc in range(2):\n                    g_c = g_indices[c_loc]\n                    if 0 <= g_c < n:\n                        M[g_r, g_c] += m_loc[r_loc, c_loc]\n                        K[g_r, g_c] += k_loc[r_loc, c_loc]\n                        \n    return M.tocsc(), K.tocsc()\n\ndef calculate_energy(q, p, M, K):\n    \"\"\"Calculates the discrete energy E = 1/2 p^T M^-1 p + 1/2 q^T K q.\"\"\"\n    if q.shape[0] == 0:\n        return 0.0\n    \n    # Kinetic term: Solve Mv = p for v, then 0.5 * p^T v\n    v = spsolve(M, p, use_umfpack=False)\n    kinetic_energy = 0.5 * p.dot(v)\n    \n    # Potential term\n    potential_energy = 0.5 * q.dot(K @ q)\n    \n    return kinetic_energy + potential_energy\n\ndef time_step(q, p, M, K, dt):\n    \"\"\"Performs one time step using the implicit midpoint rule.\"\"\"\n    n = q.shape[0]\n    if n == 0:\n        return q, p\n\n    A = M + (dt**2 / 4.0) * K\n    b = (M - (dt**2 / 4.0) * K) @ q + dt * p\n    \n    q_new = spsolve(A, b, use_umfpack=False)\n    p_new = p - (dt / 2.0) * (K @ (q + q_new))\n    \n    return q_new, p_new\n\ndef remap_state(q_old, p_old, M_old, K_old, nodes_old, c, nodes_new):\n    \"\"\"Remaps the state to a new mesh while preserving energy.\"\"\"\n    E_old = calculate_energy(q_old, p_old, M_old, K_old)\n    \n    v_old = spsolve(M_old, p_old, use_umfpack=False)\n    \n    q_old_full = np.concatenate(([0], q_old, [0]))\n    v_old_full = np.concatenate(([0], v_old, [0]))\n    \n    M_new, K_new = assemble_matrices(nodes_new, c)\n    \n    nodes_new_interior = nodes_new[1:-1]\n    q_new_tilde = np.interp(nodes_new_interior, nodes_old, q_old_full)\n    v_new_tilde = np.interp(nodes_new_interior, nodes_old, v_old_full)\n\n    p_new_tilde = M_new @ v_new_tilde\n    \n    E_new_tilde = calculate_energy(q_new_tilde, p_new_tilde, M_new, K_new)\n    \n    if E_old == 0.0:\n        alpha = 0.0\n    elif E_new_tilde == 0.0:\n        alpha = 0.0 \n    else:\n        alpha = np.sqrt(E_old / E_new_tilde)\n        \n    q_new = alpha * q_new_tilde\n    p_new = alpha * p_new_tilde\n    \n    return q_new, p_new, M_new, K_new\n\ndef run_simulation(case_params):\n    \"\"\"Runs a full simulation for a given test case.\"\"\"\n    c = case_params[\"c\"]\n    dt = case_params[\"dt\"]\n    T = case_params[\"T\"]\n    initial_mesh_refined = case_params[\"initial_mesh_refined\"]\n    regridding_events = case_params[\"regridding_events\"]\n    u0_func = case_params[\"u0_func\"]\n    v0_func = case_params[\"v0_func\"]\n\n    coarse_N = 64\n    \n    nodes = generate_mesh(coarse_N, initial_mesh_refined)\n    M, K = assemble_matrices(nodes, c)\n    \n    interior_nodes = nodes[1:-1]\n    q = u0_func(interior_nodes)\n    v = v0_func(interior_nodes)\n    if q.shape[0] > 0:\n        p = M @ v\n    else:\n        p = np.array([])\n    \n    E0 = calculate_energy(q, p, M, K)\n    energies = [E0]\n    \n    if E0 == 0.0:\n        return 0.0\n\n    num_steps = int(round(T / dt))\n    \n    for n in range(num_steps):\n        if n in regridding_events:\n            new_mesh_refined = regridding_events[n]\n            nodes_new = generate_mesh(coarse_N, new_mesh_refined)\n            \n            q, p, M_new, K_new = remap_state(q, p, M, K, nodes, c, nodes_new)\n\n            M, K, nodes = M_new, K_new, nodes_new\n\n            energies.append(calculate_energy(q, p, M, K))\n        \n        q, p = time_step(q, p, M, K, dt)\n        \n        energies.append(calculate_energy(q, p, M, K))\n        \n    energies = np.array(energies)\n    max_rel_dev = np.max(np.abs(energies - E0)) / E0\n    \n    return max_rel_dev\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"c\": 1.0, \"dt\": 0.001, \"T\": 0.5,\n            \"initial_mesh_refined\": False,\n            \"regridding_events\": {200: True},\n            \"u0_func\": lambda x: np.sin(np.pi * x),\n            \"v0_func\": lambda x: np.zeros_like(x)\n        },\n        # Test Case B\n        {\n            \"c\": 1.0, \"dt\": 0.001, \"T\": 0.5,\n            \"initial_mesh_refined\": True,\n            \"regridding_events\": {200: False},\n            \"u0_func\": lambda x: np.zeros_like(x),\n            \"v0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        # Test Case C\n        {\n            \"c\": 1.3, \"dt\": 0.001, \"T\": 0.6,\n            \"initial_mesh_refined\": False,\n            \"regridding_events\": {150: True, 350: False},\n            \"u0_func\": lambda x: 0.2 * np.sin(np.pi * x) + 0.1 * np.sin(2 * np.pi * x),\n            \"v0_func\": lambda x: np.sin(3 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}