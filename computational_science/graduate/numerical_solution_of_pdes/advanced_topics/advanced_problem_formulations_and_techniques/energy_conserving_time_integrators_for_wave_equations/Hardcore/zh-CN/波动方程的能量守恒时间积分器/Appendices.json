{
    "hands_on_practices": [
        {
            "introduction": "我们从构建能量守恒格式的基石——离散梯度法——开始。这项练习将指导您为一个具有光滑非线性势能的波动方程构建一个积分器 。通过这个实践，您将巩固对如何在代数上精确满足离散能量守恒定律的理解，并学会如何利用牛顿法等技术高效求解由此产生的隐式时间步进系统。",
            "id": "3384894",
            "problem": "考虑典范形式的半离散波动方程，通过引入广义动量 $p$（由 $p = M \\dot{q}$ 定义）得到，其中 $M$ 是一个对称正定质量矩阵：\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q),\n$$\n其中 $K$ 是对称正定刚度矩阵，$g(q)$ 是非线性恢复力，并假设其为标量势 $G(q)$ 的梯度，即 $g(q) = \\nabla G(q)$。相关的哈密顿量为\n$$\nH(q,p) = \\tfrac{1}{2} q^\\top K q + G(q) + \\tfrac{1}{2} p^\\top M^{-1} p.\n$$\n\n对于形式为 $\\dot{x} = S \\nabla H(x)$ 的哈密顿系统，可以通过离散梯度法构造一个保能量时间积分器，其中 $S$ 是一个常数斜对称矩阵。对于典范变量 $x = (q, p)$，$S$ 具有分块形式 $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$，其中 $I$ 是单位矩阵。离散梯度 $\\overline{\\nabla} H(x^n, x^{n+1})$ 是任何满足基本中值性质\n$$\nH(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n),\n$$\n并且在极限 $x^{n+1} \\to x^n$ 下与精确梯度一致的映射。使用这样的离散梯度，隐式单步法\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\n是保能量的，因为 $S$ 是斜对称的。\n\n您的任务是使用 Gonzalez 离散梯度，为半离散波动方程的哈密顿量 $H(q,p)$ 实现此方法。对于一个可分离的哈密顿量 $H(q,p) = V(q) + T(p)$，其中 $V(q) = \\tfrac{1}{2} q^\\top K q + G(q)$ 且 $T(p) = \\tfrac{1}{2} p^\\top M^{-1} p$，您应构造一个分块离散梯度，使其保持中值性质\n$$\nH(q^{n+1},p^{n+1}) - H(q^n,p^n) = \\overline{\\nabla}_q V(q^n, q^{n+1}) \\cdot (q^{n+1} - q^n) + \\overline{\\nabla}_p T(p^n, p^{n+1}) \\cdot (p^{n+1} - p^n).\n$$\n二次项的离散梯度应与其精确梯度在适当点上的取值一致，以满足中值性质，而 $G(q)$ 的离散梯度应为构造的 Gonzalez 离散梯度，以满足标量函数 $G$ 的中值性质。\n\n从哈密顿系统的基本定律和核心定义以及离散梯度的中值性质出发，为关于 $(q^{n+1}, p^{n+1})$ 的隐式更新方程推导并实现一个稳健的牛顿类型求解器。实现必须：\n- 接受对称正定矩阵 $M$ 和 $K$。\n- 接受一个多项式势 $G(q)$，其中 $g(q) = \\nabla G(q)$。\n- 对 $G(q)$ 使用 Gonzalez 离散梯度，以确保在代数层面上的精确离散能量守恒。\n- 通过计算数值轨迹上的哈密顿量 $H(q,p)$ 并报告在积分窗口内与初始能量的最大绝对偏差，来数值验证能量守恒。\n\n所有量均为无量纲。不出现角度。最终数值结果必须是浮点数。\n\n测试套件：\n实现程序以运行积分器，并报告以下四种情况中每一种的最大绝对哈密顿量偏差 $E_{\\max}$，参数已指定：\n\n1. 一维线性振子（正常路径）：\n   - $M = [1.0]$, $K = [1.0]$, $G(q) = 0$。\n   - 初始状态：$q(0) = 1.0$, $p(0) = 0.0$。\n   - 时间步长：$\\Delta t = 0.05$。\n   - 步数：$N = 200$。\n\n2. 一维四次非线性：\n   - $M = [1.5]$, $K = [0.7]$, $G(q) = \\lambda \\tfrac{q^4}{4}$，其中 $\\lambda = 0.3$，因此 $g(q) = \\lambda q^3$。\n   - 初始状态：$q(0) = 0.2$, $p(0) = 0.3$。\n   - 时间步长：$\\Delta t = 0.02$。\n   - 步数：$N = 500$。\n\n3. 二维耦合多项式势：\n   - $M = \\mathrm{diag}(1.0, 2.0)$, $K = \\begin{pmatrix} 2.0  0.3 \\\\ 0.3  1.5 \\end{pmatrix}$。\n   - $G(q) = \\alpha \\tfrac{q_1^4 + q_2^4}{4} + \\beta \\tfrac{q_1^2 q_2^2}{2}$，其中 $\\alpha = 0.2$, $\\beta = 0.1$。\n   - 因此 $g(q) = \\begin{pmatrix} \\alpha q_1^3 + \\beta q_1 q_2^2 \\\\ \\alpha q_2^3 + \\beta q_2 q_1^2 \\end{pmatrix}$。\n   - 初始状态：$q(0) = (0.1, -0.2)$, $p(0) = (0.0, 0.25)$。\n   - 时间步长：$\\Delta t = 0.015$。\n   - 步数：$N = 400$。\n\n4. 一维平凡平衡点（边界情况）：\n   - $M = [1.0]$, $K = [2.0]$, $G(q) = \\tfrac{1}{4} q^4$，因此 $g(q) = q^3$。\n   - 初始状态：$q(0) = 0.0$, $p(0) = 0.0$。\n   - 时间步长：$\\Delta t = 0.1$。\n   - 步数：$N = 10$。\n\n输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起来，其中每个条目是按上面列出的顺序对应的测试用例的最大绝对哈密顿量偏差 $E_{\\max}$。例如，输出格式必须完全是：\n$$\n[\\text{E1},\\text{E2},\\text{E3},\\text{E4}]\n$$\n其中每个 $\\text{E}$ 是一个浮点数。",
            "solution": "用户提供了一个在几何数值积分领域中定义明确的问题。任务是使用离散梯度法，特别是对非线性势使用 Gonzalez 类型的离散梯度，为典范哈密顿系统实现一个保能量时间积分器。该问题在科学上是合理的、自洽的，并且所有测试用例的参数都已提供。该问题被认为是有效的。\n\n下面是数值方法的推导和解释。\n\n系统由以下典范哈密顿方程描述：\n$$\n\\dot{q} = M^{-1} p, \\quad \\dot{p} = -K q - g(q)\n$$\n其中 $q$ 是广义坐标，$p$ 是广义动量，$M$ 是质量矩阵，$K$ 是刚度矩阵。力 $g(q)$ 是一个势的梯度，$g(q) = \\nabla G(q)$。代表系统总能量的哈密顿量是 $q$ 和 $p$ 的一个可分离函数：\n$$\nH(q,p) = V(q) + T(p) = \\left(\\tfrac{1}{2} q^\\top K q + G(q)\\right) + \\left(\\tfrac{1}{2} p^\\top M^{-1} p\\right)\n$$\n该系统可以写成紧凑形式 $\\dot{x} = S \\nabla H(x)$，其中 $x=(q, p)$ 且 $S = \\begin{pmatrix} 0  I \\\\ -I  0 \\end{pmatrix}$。\n\n离散梯度法为构造保能量格式提供了一个通用框架。从时间步 $n$ 到 $n+1$ 的更新由隐式规则给出：\n$$\n\\frac{x^{n+1} - x^n}{\\Delta t} = S \\, \\overline{\\nabla} H(x^n, x^{n+1})\n$$\n其中 $\\Delta t$ 是时间步长，$\\overline{\\nabla} H$ 是哈密顿量 $H$ 的离散梯度。离散梯度必须满足中值性质 $H(x^{n+1}) - H(x^n) = \\overline{\\nabla} H(x^n, x^{n+1}) \\cdot (x^{n+1} - x^n)$ 并且与真实梯度一致，$\\overline{\\nabla} H(x, x) = \\nabla H(x)$。该方法的能量守恒性直接源于中值性质和 $S$ 的斜对称性：\n$$\nH(x^{n+1}) - H(x^n) = (x^{n+1} - x^n)^\\top \\overline{\\nabla} H = (\\Delta t \\, S \\, \\overline{\\nabla} H)^\\top \\overline{\\nabla} H = \\Delta t (\\overline{\\nabla} H)^\\top S^\\top \\overline{\\nabla} H = -\\Delta t (\\overline{\\nabla} H)^\\top S \\overline{\\nabla} H = 0\n$$\n最后一个等式成立是因为对于任何向量 $v$，如果 $S$ 是斜对称的，则 $v^\\top S v = 0$。因此，对所有 $n$ 都有 $H(x^{n+1}) = H(x^n)$。\n\n对于可分离的哈密顿量，我们使用可分离的离散梯度：\n$$\n\\overline{\\nabla} H(x^n, x^{n+1}) = \\begin{pmatrix} \\overline{\\nabla}_q V(q^n, q^{n+1}) \\\\ \\overline{\\nabla}_p T(p^n, p^{n+1}) \\end{pmatrix}\n$$\n将此代入更新规则，得到一对耦合方程：\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = \\overline{\\nabla}_p T(p^n, p^{n+1}) \\quad (1)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -\\overline{\\nabla}_q V(q^n, q^{n+1}) \\quad (2)\n$$\n\n现在我们必须定义具体的离散梯度。\n对于二次动能 $T(p) = \\frac{1}{2} p^\\top M^{-1} p$，一个满足中值性质的合适离散梯度是中点梯度：\n$$\n\\overline{\\nabla}_p T(p^n, p^{n+1}) = \\nabla_p T \\left( \\frac{p^n + p^{n+1}}{2} \\right) = M^{-1} \\left( \\frac{p^n + p^{n+1}}{2} \\right)\n$$\n类似地，对于势能的二次部分 $\\frac{1}{2} q^\\top K q$，我们使用：\n$$\n\\overline{\\nabla}_q \\left(\\tfrac{1}{2} q^\\top K q\\right)(q^n, q^{n+1}) = K \\left( \\frac{q^n + q^{n+1}}{2} \\right)\n$$\n对于非线性势 $G(q)$，我们使用 Gonzalez 离散梯度。对于是单坐标函数乘积之和的势，可以推导出一种对称形式。对于一个维度为 $d$ 的多项式势 $G(q)$，其分量 $\\overline{g}_i(q^n, q^{n+1}) = (\\overline{\\nabla}G(q^n, q^{n+1}))_i$ 被构造以满足中值性质。对于测试套件中的势，这导致了直接实现的特定代数表达式。例如，对于一维势 $G(q)$，如果 $q^{n+1} \\neq q^n$，则 $\\overline{\\nabla}G(q^n, q^{n+1}) = (G(q^{n+1})-G(q^n))/(q^{n+1}-q^n)$，否则为 $\\nabla G(q^n)$。对于多项式势，这可以写成数值稳定的多项式形式。\n\n完整的更新方程是：\n$$\nq^{n+1} - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p^{n+1}) = 0\n$$\n$$\np^{n+1} - p^n + \\frac{\\Delta t}{2} K (q^n + q^{n+1}) + \\Delta t \\, \\overline{\\nabla}G(q^n, q^{n+1}) = 0\n$$\n这是一个关于未知状态 $(q^{n+1}, p^{n+1})$ 的 $2d$ 个非线性代数方程组。我们使用牛顿法来解这个系统。设未知数为 $y = (q^{n+1}, p^{n+1})$，方程组为 $F(y) = 0$。牛顿迭代为 $y_{k+1} = y_k - [J_F(y_k)]^{-1} F(y_k)$，其中 $J_F$ 是 $F$ 的雅可比矩阵。迭代从一个初始猜测开始，例如 $y_0 = (q^n, p^n)$。\n\n残差向量是 $F(y_k) = (F_q, F_p)$，其中 $y_k = (q_k, p_k)$：\n$$\nF_q(q_k, p_k) = q_k - q^n - \\frac{\\Delta t}{2} M^{-1} (p^n + p_k)\n$$\n$$\nF_p(q_k, p_k) = p_k - p^n + \\frac{\\Delta t}{2} K (q^n + q_k) + \\Delta t \\, \\overline{\\nabla}G(q^n, q_k)\n$$\n雅可比矩阵 $J_F = \\frac{\\partial F}{\\partial y}$ 由下式给出：\n$$\nJ_F = \\begin{pmatrix} \\partial F_q / \\partial q_k  \\partial F_q / \\partial p_k \\\\ \\partial F_p / \\partial q_k  \\partial F_p / \\partial p_k \\end{pmatrix} = \\begin{pmatrix} I  -\\frac{\\Delta t}{2} M^{-1} \\\\ \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}}  I \\end{pmatrix}\n$$\n其中 $J_{\\overline{g}} = \\frac{\\partial}{\\partial q_k} \\overline{\\nabla}G(q^n, q_k)$ 是 $G$ 的离散梯度的雅可比矩阵。牛顿更新步骤涉及求解线性系统 $J_F \\Delta y = -F$ 以获得更新量 $\\Delta y = (\\Delta q, \\Delta p)$。这个 $2d \\times 2d$ 的系统可以通过分块消元法更有效地求解。我们首先从 $d \\times d$ 系统求解 $\\Delta q$：\n$$\n\\left( \\frac{2}{\\Delta t} M + \\frac{\\Delta t}{2} K + \\Delta t J_{\\overline{g}} \\right) \\Delta q = -F_p - \\frac{2}{\\Delta t} M F_q\n$$\n然后通过代入找到 $\\Delta p$：\n$$\n\\Delta p = \\frac{2}{\\Delta t} M (\\Delta q + F_q)\n$$\n重复此过程，直到残差 $F$ 或更新量 $\\Delta y$ 的范数低于选定的容差。该实现将使用这个基于牛顿法的求解器来对每个测试用例进行时间推进，并报告数值计算的哈密顿量的最大偏差。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the energy-conserving integrator.\n    \"\"\"\n\n    def get_hamiltonian_func(M, K, G_func):\n        \"\"\"Constructs the Hamiltonian function for a given system.\"\"\"\n        M_inv = np.linalg.inv(M)\n        def hamiltonian(q, p):\n            T = 0.5 * p.T @ M_inv @ p\n            V_lin = 0.5 * q.T @ K @ q\n            V_nonlin = G_func(q)\n            return float(T + V_lin + V_nonlin)\n        return hamiltonian\n\n    def newton_solver(q_n, p_n, M, K, dG_disc_func, J_dG_disc_func, dt, tol=1e-13, max_iter=20):\n        \"\"\"\n        Solves the implicit update equations for one time step using Newton's method.\n        \"\"\"\n        dim = len(q_n)\n        M_inv = np.linalg.inv(M)\n        \n        # Initial guess for (q_{n+1}, p_{n+1})\n        q_k = np.copy(q_n)\n        p_k = np.copy(p_n)\n\n        for _ in range(max_iter):\n            # Evaluate residuals F_q, F_p\n            F_q = q_k - q_n - (dt / 2.0) * M_inv @ (p_n + p_k)\n            \n            dG = dG_disc_func(q_n, q_k)\n            F_p = p_k - p_n + (dt / 2.0) * K @ (q_n + q_k) + dt * dG\n            \n            residual_norm = np.linalg.norm(np.concatenate([F_q, F_p]))\n            if residual_norm  tol:\n                return q_k, p_k\n            \n            # Evaluate Jacobian of the discrete gradient of G\n            J_dG = J_dG_disc_func(q_n, q_k)\n            \n            # Form and solve the linear system for the update (dq, dp)\n            # A * dq = b\n            A = (2.0 / dt) * M + (dt / 2.0) * K + dt * J_dG\n            b = -F_p - (2.0 / dt) * M @ F_q\n            \n            dq = np.linalg.solve(A, b)\n            dp = (2.0 / dt) * M @ (dq + F_q)\n            \n            q_k += dq\n            p_k += dp\n\n        # Return the last computed value if max_iter is reached.\n        # For this problem setup, convergence should be rapid.\n        return q_k, p_k\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a full simulation for a given test case configuration.\n        \"\"\"\n        M, K = case[\"M\"], case[\"K\"]\n        G_func = case[\"G\"]\n        dG_disc_func = case[\"dG_disc\"]\n        J_dG_disc_func = case[\"J_dG_disc\"]\n        q, p = case[\"q0\"], case[\"p0\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n\n        H_func = get_hamiltonian_func(M, K, G_func)    \n        \n        energies = np.zeros(N + 1)\n        energies[0] = H_func(q, p)\n\n        for i in range(N):\n            q, p = newton_solver(q, p, M, K, dG_disc_func, J_dG_disc_func, dt)\n            energies[i+1] = H_func(q, p)\n            \n        initial_energy = energies[0]\n        max_dev = np.max(np.abs(energies - initial_energy))\n        \n        return max_dev\n\n    # --- Test Case Definitions ---\n\n    # Case 1: 1D Linear Oscillator\n    case1 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[1.0]]),\n        \"G\": lambda q: 0.0,\n        \"dG_disc\": lambda q0, q1: np.array([0.0]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[0.0]]),\n        \"q0\": np.array([1.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.05, \"N\": 200,\n    }\n\n    # Case 2: 1D Quartic Nonlinearity\n    lam = 0.3\n    case2 = {\n        \"M\": np.array([[1.5]]), \"K\": np.array([[0.7]]),\n        \"G\": lambda q: lam * q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            lam/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            lam/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.2]), \"p0\": np.array([0.3]),\n        \"dt\": 0.02, \"N\": 500,\n    }\n\n    # Case 3: 2D Coupled Polynomial Potential\n    alpha, beta = 0.2, 0.1\n    def G_case3(q):\n        return alpha * (q[0]**4 + q[1]**4) / 4.0 + beta * q[0]**2 * q[1]**2 / 2.0\n\n    def dG_disc_case3(q0, q1):\n        g1 = alpha/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3) + \\\n             beta/4.0 * (q1[0] + q0[0]) * (q1[1]**2 + q0[1]**2)\n        g2 = alpha/4.0 * (q1[1]**3 + q1[1]**2*q0[1] + q1[1]*q0[1]**2 + q0[1]**3) + \\\n             beta/4.0 * (q1[0]**2 + q0[0]**2) * (q1[1] + q0[1])\n        return np.array([g1, g2])\n\n    def J_dG_disc_case3(q0, q1):\n        J11 = alpha/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2) + \\\n              beta/4.0 * (q1[1]**2 + q0[1]**2)\n        J12 = beta/2.0 * (q1[0] + q0[0]) * q1[1]\n        J21 = beta/2.0 * q1[0] * (q1[1] + q0[1])\n        J22 = alpha/4.0 * (3*q1[1]**2 + 2*q1[1]*q0[1] + q0[1]**2) + \\\n              beta/4.0 * (q1[0]**2 + q0[0]**2)\n        return np.array([[J11, J12], [J21, J22]])\n\n    case3 = {\n        \"M\": np.diag([1.0, 2.0]),\n        \"K\": np.array([[2.0, 0.3], [0.3, 1.5]]),\n        \"G\": G_case3,\n        \"dG_disc\": dG_disc_case3,\n        \"J_dG_disc\": J_dG_disc_case3,\n        \"q0\": np.array([0.1, -0.2]), \"p0\": np.array([0.0, 0.25]),\n        \"dt\": 0.015, \"N\": 400,\n    }\n\n    # Case 4: 1D Trivial Equilibrium\n    case4 = {\n        \"M\": np.array([[1.0]]), \"K\": np.array([[2.0]]),\n        \"G\": lambda q: q[0]**4 / 4.0,\n        \"dG_disc\": lambda q0, q1: np.array([\n            1.0/4.0 * (q1[0]**3 + q1[0]**2*q0[0] + q1[0]*q0[0]**2 + q0[0]**3)\n        ]),\n        \"J_dG_disc\": lambda q0, q1: np.array([[\n            1.0/4.0 * (3*q1[0]**2 + 2*q1[0]*q0[0] + q0[0]**2)\n        ]]),\n        \"q0\": np.array([0.0]), \"p0\": np.array([0.0]),\n        \"dt\": 0.1, \"N\": 10,\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    results = [run_simulation(case) for case in test_cases]\n    \n    # Format the output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的物理模型常常包含非光滑的相互作用，例如接触或摩擦，这对标准数值方法构成了挑战。这项练习将通过处理一个具有不可微势能的波动方程来提升您的技能，这需要用到次梯度的概念 。您将学习如何推广离散梯度的思想，以便在势能函数存在“尖点”的情况下依然能够精确保持能量守恒。",
            "id": "3384885",
            "problem": "考虑在空间区间 $[0,1]$ 上的半线性一维偏微分方程（PDE）波模型，其带有齐次狄利克雷边界条件，\n$$u_{tt}(x,t) - c^2 u_{xx}(x,t) + \\partial V(u(x,t)) = 0,$$\n其中 $c0$ 是波速，$V(u)=\\lambda |u|$ 是一个非光滑势，且 $\\lambda0$。这里 $\\partial V$ 表示关于 $u$ 的次微分，它与绝对值的集值符号函数一致，即 $\\partial(\\lambda |u|)=\\lambda\\,\\mathrm{sign}(u)$，其中 $\\mathrm{sign}(0)$ 被理解为 $[-1,1]$ 中的任意值。\n\n使用具有 $N$ 个内部网格点和网格间距 $h_x=\\frac{1}{N+1}$ 的标准二阶中心有限差分空间半离散化方法，定义节点值向量 $q(t)\\in\\mathbb{R}^N$ 及其速度 $p(t)=\\dot{q}(t)\\in\\mathbb{R}^N$。该半离散动力学可以写成一个哈密顿系统\n$$\\dot{q}=p,\\quad \\dot{p}=-K q - g(q),$$\n其离散能量（哈密顿量）为\n$$H(q,p)=\\frac{1}{2}\\|p\\|^2 + \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|,$$\n其中 $K\\in\\mathbb{R}^{N\\times N}$ 是对应于离散狄利克雷拉普拉斯算子的对称正定刚度矩阵，并按 $c^2$ 进行了缩放，即 $K=\\frac{c^2}{h_x^2}\\,\\mathrm{tridiag}(-1,2,-1)$，而 $g(q)\\in\\partial(\\lambda \\sum_i |q_i|)$ 是次梯度的任意分量式选取。该常微分方程系统在时间上精确地保持能量 $H$。\n\n您的任务是：\n1. 从可分哈密顿量 $H(q,p)=T(p)+W(q)$ 的离散能量守恒基本定义出发，构建一个时间积分器，该积分器使用一个包含绝对值非光滑次梯度的 $W(q)$ 的离散梯度，从而在所有时间步长上精确地保持离散能量 $H(q,p)$。不要假设 $V$ 的光滑性，也不要使用预设在 $u=0$ 处可微的公式。该方法必须从第一性原理推导，并且必须明确如何处理在扭结 $q_i=0$ 处的次梯度。\n2. 为具有上述定义的矩阵 $K$ 的半离散系统实现该积分器。您的实现必须通过采用确保离散能量守恒恒等式得到满足的一致性次梯度选择，来稳健地处理 $q_i=0$ 处的扭结。\n3. 对每个时间步，使用一种在扭结处不假设光滑导数的数值稳定方法，求解由保能构造产生的任何隐式方程。使用一个能保证足够精度以评估能量守恒性的停止准则。\n4. 计算数值轨迹上的能量 $H(q^n,p^n)$，并报告在整个模拟过程中与初始能量 $H(q^0,p^0)$ 的最大绝对偏差，定义为\n$$\\Delta H_{\\max}=\\max_{0\\le n\\le N_{\\mathrm{steps}}} \\left| H(q^n,p^n) - H(q^0,p^0) \\right|.$$\n\n测试套件：\n- 情况 A（一般情况，远离扭结）：$N=16$, $c=1.0$, $\\lambda=0.8$, 时间步长 $h=0.02$, 步数 $N_{\\mathrm{steps}}=200$, 初始条件 $q_i^0 = 0.5\\sin(\\pi x_i)$, $p^0=0$，其中 $x_i=i h_x$，$i=1,\\dots,N$。\n- 情况 B（靠近扭结且频繁变号的稳健性测试）：$N=16$, $c=1.0$, $\\lambda=2.0$, 时间步长 $h=0.015$, 步数 $N_{\\mathrm{steps}}=300$, 初始条件 $q_i^0 = 0.05\\sin(6\\pi x_i)$, $p^0=0$。\n- 情况 C（靠近扭结的大时间步长压力测试）：$N=10$, $c=1.5$, $\\lambda=1.0$, 时间步长 $h=0.1$, 步数 $N_{\\mathrm{steps}}=120$, 初始条件 $q_i^0 = 0.2\\sin(2\\pi x_i)$, $p^0=0$。\n\n对于每种情况，确定积分器是否在容差 $\\varepsilon_{\\mathrm{energy}}=10^{-8}$ 内实现了能量守恒，即 $\\Delta H_{\\max} \\le \\varepsilon_{\\mathrm{energy}}$ 是否成立。整个程序的最终输出要求是包含一个由对应于情况 A、B 和 C 的三个布尔值组成的逗号分隔列表的单行，并用方括号括起来。例如，输出格式必须严格符合\n$$[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C],$$\n其中每个 $\\mathrm{result}_\\bullet$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "该问题要求构建并实现一个数值积分器，该积分器能精确保持一个具有非光滑势的半离散化半线性波方程的离散能量。该问题是适定的且科学上合理的，代表了几何数值积分领域的一个标准任务。我们着手进行推导和实现。\n\n### 1. 保能积分器的推导\n\n该半离散系统是一个可分哈密顿系统，其哈密顿量为 $H(q,p) = T(p) + W(q)$，其中 $T(p) = \\frac{1}{2}\\|p\\|^2$ 是动能，$W(q) = \\frac{1}{2} q^\\top K q + \\lambda \\sum_{i=1}^N |q_i|$ 是势能。运动方程为 $\\dot{q} = \\nabla_p H = p$ 和 $\\dot{p} = -\\nabla_q H = -Kq - g(q)$，其中 $g(q) \\in \\partial_q(\\lambda\\sum_i|q_i|)$ 是一个次梯度。\n\n一个积分器 $(q^n, p^n) \\mapsto (q^{n+1}, p^{n+1})$ 如果对所有步数 $n$ 都满足 $H(q^{n+1}, p^{n+1}) = H(q^n, p^n)$，则它是精确保能的。这可以通过离散梯度法实现。函数 $W(q)$ 的离散梯度 $\\overline{\\nabla} W(q^a, q^b)$ 是一个满足以下两个性质的向量值函数：\n1.  一致性：在 $W$ 可微的任意点，$\\overline{\\nabla} W(q, q) = \\nabla W(q)$。\n2.  能量关系：$W(q^b) - W(q^a) = (\\overline{\\nabla} W(q^a, q^b))^\\top (q^b - q^a)$。\n\n我们采用一种基于平均向量场法（一种特定的离散梯度积分器）的保能格式，对于可分哈密顿量，其形式为：\n$$\n\\frac{q^{n+1} - q^n}{h} = \\overline{\\nabla} T(p^n, p^{n+1})\n$$\n$$\n\\frac{p^{n+1} - p^n}{h} = -\\overline{\\nabla} W(q^n, q^{n+1})\n$$\n其中 $h$ 是时间步长。\n\n对于动能 $T(p)=\\frac{1}{2}p^\\top p$，其梯度为 $\\nabla_p T(p) = p$。离散梯度的一个标准选择是中点取值：\n$$\n\\overline{\\nabla} T(p^n, p^{n+1}) = \\frac{p^n + p^{n+1}}{2}\n$$\n格式的第一个方程变成了我们所熟知的运动学关系的梯形法则：\n$$\n\\frac{q^{n+1} - q^n}{h} = \\frac{p^n + p^{n+1}}{2} \\quad (*).\n$$\n\n对于势能 $W(q) = W_{smooth}(q) + W_{nonsmooth}(q)$，其中 $W_{smooth}(q) = \\frac{1}{2}q^\\top K q$ 和 $W_{nonsmooth}(q) = \\lambda \\sum_{i=1}^N |q_i|$，离散梯度是可加性构造的：$\\overline{\\nabla} W = \\overline{\\nabla} W_{smooth} + \\overline{\\nabla} W_{nonsmooth}$。\n- 对于二次（光滑）部分，其梯度 $\\nabla W_{smooth}(q)=Kq$ 的中点取值给出了一个有效的离散梯度：\n$$\n\\overline{\\nabla} W_{smooth}(q^n, q^{n+1}) = K\\left(\\frac{q^n + q^{n+1}}{2}\\right)\n$$\n- 对于非光滑部分 $W_{nonsmooth}(q)$，它是可分的，我们逐分量定义离散梯度。对每个分量 $w_i(q_i) = \\lambda |q_i|$，离散梯度性质 $w_i(q_i^{n+1}) - w_i(q_i^n) = [\\overline{\\nabla} W_{nonsmooth}]_i (q_i^{n+1}-q_i^n)$ 导出以下定义：\n$$\n[\\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})]_i = \\lambda \\frac{|q_i^{n+1}| - |q_i^n|}{q_i^{n+1} - q_i^n}, \\quad \\text{若 } q_i^{n+1} \\neq q_i^n\n$$\n若 $q_i^{n+1} = q_i^n$，则离散梯度必须从次微分 $\\partial w_i(q_i^n)$ 中选取。一个一致的选择是，当 $q_i^n \\neq 0$ 时为 $\\lambda\\,\\mathrm{sign}(q_i^n)$，当 $q_i^n = 0$ 时为 $0$。\n\n格式的第二个方程是：\n$$\n\\frac{p^{n+1} - p^n}{h} = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}) \\quad (**).\n$$\n\n为了证明能量守恒，我们将 $(*)$ 式与 $(\\overline{\\nabla} W)^\\top h$ 作内积，并将 $(**)$ 式与 $(p^n+p^{n+1})^\\top h/2$ 作内积，然后求和：\n$W(q^{n+1})-W^n) = (\\overline{\\nabla} W)^\\top (q^{n+1}-q^n) = (\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$。\n$T(p^{n+1})-T(p^n) = \\frac{1}{2}(p^{n+1})^\\top p^{n+1} - \\frac{1}{2}(p^n)^\\top p^n = \\frac{1}{2}(p^{n+1}-p^n)^\\top(p^{n+1}+p^n) = -(\\overline{\\nabla} W)^\\top h \\frac{p^n+p^{n+1}}{2}$。\n将这两个等式相加得到 $\\Delta H = (W^{n+1}-W^n) + (T^{n+1}-T^n) = 0$。因此，该格式是精确保能的。\n\n### 2. 隐式求解器公式\n\n该格式是隐式的。我们推导一个关于 $q^{n+1}$ 的方程。从 $(*)$ 式，我们表达出 $p^{n+1} = \\frac{2}{h}(q^{n+1}-q^n) - p^n$。将其代入 $(**)$ 式，得到一个关于 $q^{n+1}$ 的非线性系统：\n$$\n\\frac{1}{h}\\left(\\frac{2}{h}(q^{n+1}-q^n) - p^n - p^n\\right) = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\frac{2}{h^2}(q^{n+1}-q^n) - \\frac{2}{h}p^n = -K\\left(\\frac{q^n + q^{n+1}}{2}\\right) - \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n两边乘以 $h^2/2$ 并整理各项以求解 $q^{n+1}$：\n$$\nq^{n+1} - q^n - h p^n = -\\frac{h^2}{4} K(q^n + q^{n+1}) - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1})\n$$\n这是一个关于 $z=q^{n+1}$ 的形如 $F(z)=0$ 的非线性向量方程。它必须在每个时间步求解。由于问题要求使用一种不假设光滑性的方法，我们采用不动点迭代法：\n$$\n\\left(I + \\frac{h^2}{4} K\\right) q^{n+1}_{(k+1)} = q^n + h p^n - \\frac{h^2}{4} K q^n - \\frac{h^2}{2} \\overline{\\nabla} W_{nonsmooth}(q^n, q^{n+1}_{(k)}),\n$$\n其中 $q^{n+1}_{(k)}$ 是 $q^{n+1}$ 的第 $k$ 次迭代。我们以初始猜测 $q^{n+1}_{(0)} = q^n$ 开始。矩阵 $A = I + \\frac{h^2}{4} K$ 是对称、正定且三对角的。每次迭代步骤中的线性系统可以使用带状矩阵求解器高效求解。当连续迭代值之间的差异低于一个严格的容差（例如 $10^{-14}$）时，迭代停止，以确保能量守恒性质能保持到机器精度。\n\n### 3. 实现与数值稳定性\n\n实现时需要小心处理绝对值项的离散梯度，以避免当 $q_i^{n+1} \\approx q_i^n$ 时出现数值不稳定性。表达式 $\\lambda(|v|-|u|)/(v-u)$ 的计算方式如下：\n- 若 $u$ 和 $v$ 符号相同（或其中一个为零），则为 $\\lambda\\,\\mathrm{sign}(u)$。\n- 若它们符号不同，则为 $\\lambda(|v|-|u|)/(v-u)$。\n在数值上，如果 $|v-u|$ 小于某个机器ε容差，我们将其视为 $v=u$ 的情况，并选择一个次梯度。我们的一致性选择是：当 $u \\neq 0$ 时为 $\\lambda\\,\\mathrm{sign}(u)$，当 $u=0$ 时为 $0$。\n\n一旦不动点迭代收敛到解 $q^{n+1}$，新的动量 $p^{n+1}$ 通过运动学更新计算得出：\n$$\np^{n+1} = \\frac{2}{h}(q^{n+1} - q^n) - p^n\n$$\n然后计算能量 $H(q^{n+1}, p^{n+1})$ 并跟踪其与初始能量 $H(q^0,p^0)$ 的偏差。所有时间步长的最大绝对偏差 $\\Delta H_{\\max}$ 将与指定的容差 $\\varepsilon_{\\mathrm{energy}}=10^{-8}$ 进行比较。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef discrete_gradient_nonsmooth(q_n, q_np1, lam, N):\n    \"\"\"\n    Computes the discrete gradient of the nonsmooth potential W_nonsmooth = lambda * sum(|q_i|).\n    \"\"\"\n    g = np.zeros(N)\n    # Use a small tolerance based on machine epsilon for robust floating point comparison.\n    machine_eps = np.finfo(float).eps * 10.0\n    \n    for i in range(N):\n        q_i_n = q_n[i]\n        q_i_np1 = q_np1[i]\n        diff = q_i_np1 - q_i_n\n        \n        if np.abs(diff)  machine_eps:\n            # Case q_i^{n+1} is numerically equal to q_i^n.\n            # Select a subgradient. A consistent choice is made here.\n            if np.abs(q_i_n)  machine_eps:\n                # Subgradient at q=0. The choice 0 is natural and symmetric.\n                g[i] = 0.0\n            else:\n                # Differentiable region, gradient is sign(q).\n                g[i] = lam * np.sign(q_i_n)\n        else:\n            # Standard discrete gradient formula for |q|.\n            g[i] = lam * (np.abs(q_i_np1) - np.abs(q_i_n)) / diff\n    return g\n\ndef hamiltonian(q, p, K, lam):\n    \"\"\"\n    Computes the total discrete energy (Hamiltonian) of the system.\n    \"\"\"\n    kinetic = 0.5 * np.dot(p, p)\n    potential_smooth = 0.5 * np.dot(q, K @ q)\n    potential_nonsmooth = lam * np.sum(np.abs(q))\n    return kinetic + potential_smooth + potential_nonsmooth\n\ndef run_simulation(N, c, lam, h, N_steps, q0_func):\n    \"\"\"\n    Runs a simulation for one test case and checks for energy preservation.\n    \"\"\"\n    # 1. System setup\n    hx = 1.0 / (N + 1)\n    x = np.array([i * hx for i in range(1, N + 1)])\n\n    # Stiffness matrix K = (c^2/h_x^2) * tridiag(-1, 2, -1)\n    diag_K = np.full(N, 2.0)\n    off_diag_K = np.full(N - 1, -1.0)\n    K = (c**2 / hx**2) * (np.diag(diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n\n    # 2. Initial conditions\n    q = q0_func(x)\n    p = np.zeros(N)\n\n    # Initial energy and tracking variables\n    H0 = hamiltonian(q, p, K, lam)\n    max_energy_deviation = 0.0\n\n    # 3. Setup for the fixed-point solver\n    fixed_point_tol = 1e-14\n    max_fixed_point_iter = 100\n\n    # System matrix A = I + (h^2/4) * K for the implicit solve\n    A_diag = 1.0 + (h**2 / 4.0) * (c**2 / hx**2) * 2.0\n    A_off_diag = -(h**2 / 4.0) * (c**2 / hx**2)\n    \n    A_banded = np.zeros((3, N))\n    A_banded[0, 1:] = A_off_diag  # Super-diagonal\n    A_banded[1, :] = A_diag     # Main diagonal\n    A_banded[2, :-1] = A_off_diag # Sub-diagonal\n    \n    # 4. Time stepping loop\n    for _ in range(N_steps):\n        # --- Solve for q^{n+1} using fixed-point iteration ---\n        rhs_const = q + h * p - (h**2 / 4.0) * (K @ q)\n        q_next_iter = np.copy(q) \n\n        for k in range(max_fixed_point_iter):\n            q_prev_iter = np.copy(q_next_iter)\n            \n            g_nonsmooth = discrete_gradient_nonsmooth(q, q_prev_iter, lam, N)\n            rhs = rhs_const - (h**2 / 2.0) * g_nonsmooth\n            \n            # Solve the banded linear system A * q_next_iter = rhs\n            q_next_iter = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n            \n            if np.linalg.norm(q_next_iter - q_prev_iter, ord=np.inf)  fixed_point_tol:\n                break\n        \n        q_next = q_next_iter\n        \n        # --- Update p^{n+1} ---\n        p_next = (2.0 / h) * (q_next - q) - p\n        \n        # Update state for the next step\n        q, p = q_next, p_next\n        \n        # --- Calculate and record energy deviation ---\n        H_n = hamiltonian(q, p, K, lam)\n        energy_dev = np.abs(H_n - H0)\n        if energy_dev > max_energy_deviation:\n            max_energy_deviation = energy_dev\n            \n    # 5. Final check\n    energy_preservation_tol = 1e-8\n    return max_energy_deviation = energy_preservation_tol\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: General case, away from kinks\n        {'N': 16, 'c': 1.0, 'lam': 0.8, 'h': 0.02, 'N_steps': 200, 'q0_func': lambda x: 0.5 * np.sin(np.pi * x)},\n        # Case B: Robustness near kinks\n        {'N': 16, 'c': 1.0, 'lam': 2.0, 'h': 0.015, 'N_steps': 300, 'q0_func': lambda x: 0.05 * np.sin(6 * np.pi * x)},\n        # Case C: Large time step stress test\n        {'N': 10, 'c': 1.5, 'lam': 1.0, 'h': 0.1, 'N_steps': 120, 'q0_func': lambda x: 0.2 * np.sin(2 * np.pi * x)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case['N'],\n            c=case['c'],\n            lam=case['lam'],\n            h=case['h'],\n            N_steps=case['N_steps'],\n            q0_func=case['q0_func']\n        )\n        results.append(result)\n\n    # Format the output as a list of lowercase boolean strings\n    formatted_results = ','.join(map(lambda b: str(b).lower(), results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "为了提高计算效率，求解波动方程通常需要自适应网格加密（AMR），即计算网格会随时间动态变化。一个主要的挑战是，简单的网格重映（remapping）会破坏能量守恒。这项综合性练习要求您设计并实现一个能量守恒的重映策略，确保在网格疏密变化时，系统的总离散能量保持不变，从而将几何积分理论与实际的高性能计算需求联系起来 。",
            "id": "3384904",
            "problem": "考虑区间 $[0,1]$ 上具有齐次狄利克雷边界条件的一维线性波动方程，该方程在空间上通过可能非均匀的网格上的一阶连续有限元法 (FEM) 进行离散化，在时间上通过一种保持离散能量不变量的方法进行积分。令 $c0$ 表示波速。在一个具有 $n$ 个内部节点的给定网格上，令 $M\\in \\mathbb{R}^{n\\times n}$ 为对称正定的 FEM 质量矩阵，令 $K\\in \\mathbb{R}^{n\\times n}$ 为对应 $c^2 u_{xx}$ 的对称半正定的 FEM 刚度矩阵。半离散的运动方程为\n$$\nM \\, \\ddot{q}(t) + K \\, q(t) = 0,\n$$\n其中 $q(t)\\in \\mathbb{R}^n$ 是 $u(x,t)$ 在时间 $t$ 的内部节点值。引入正则动量 $p(t) := M \\, \\dot{q}(t)$，得到一阶形式\n$$\n\\dot{q}(t) = M^{-1} p(t), \\qquad \\dot{p}(t) = - K \\, q(t).\n$$\n定义离散能量（哈密顿量）\n$$\nE(t) = \\tfrac{1}{2} \\, p(t)^{\\top} M^{-1} p(t) + \\tfrac{1}{2} \\, q(t)^{\\top} K \\, q(t).\n$$\n您必须实现：\n- 一个时间积分器，对于固定的 $(M,K)$，它能将上述二次哈密顿量的离散能量 $E(t)$ 保持在机器精度内。\n- 在指定的网格重划分步骤中进行自适应网格加密 (AMR) 重映射，此时网格（以及矩阵 $M$ 和 $K$）会随时间变化。重映射必须将状态 $(q,p)$ 从旧网格映射到新网格，使得重映射后立即用新 $(M,K)$ 计算的离散能量等于重映射前立即用旧 $(M,K)$ 计算的离散能量（在机器精度内），即，如果 $(q^{-},p^{-},M^{-},K^{-})$是重映射前的状态，$(q^{+},p^{+},M^{+},K^{+})$是重映射后的状态，则 $E^{+} = E^{-}$，其中\n$$\nE^{-} = \\tfrac{1}{2} \\, (p^{-})^{\\top} (M^{-})^{-1} p^{-} + \\tfrac{1}{2} \\, (q^{-})^{\\top} K^{-} q^{-}, \\quad\nE^{+} = \\tfrac{1}{2} \\, (p^{+})^{\\top} (M^{+})^{-1} p^{+} + \\tfrac{1}{2} \\, (q^{+})^{\\top} K^{+} q^{+}.\n$$\n\n空间离散化必须在具有 $x=0$ 和 $x=1$ 处齐次狄利克雷边界条件的一维网格上使用连续分段线性 FEM。长度为 $h$ 的单元的局部单元矩阵是标准的：\n- 质量矩阵： $\\tfrac{h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$，\n- 刚度矩阵： $\\tfrac{c^2}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$。\n\n您必须设计一种在网格重划分事件中的重映射策略，该策略：\n- 使用旧的离散状态在旧网格上定义一个连续的分段线性场及其时间导数，\n- 在新网格上构建一个新的离散状态，以及\n- 通过一个确定性的、网格局部或全局的代数运算，强制实现用新矩阵计算的 $E^{+}=E^{-}$。\n\n初始条件通过连续函数 $u_0(x)$ 和 $v_0(x)=\\partial_t u(x,0)$ 指定；在离散设置中，您必须通过在内部网格节点上插值 $u_0$ 来初始化 $q(0)$，并根据 $v_0$ 的节点值初始化 $p(0)=M \\, v(0)$。\n\n您必须实现以下固定的测试套件。在所有情况下，使用区间 $[0,1]$ 和齐次狄利克雷边界条件，以及一个包含 $N=64$ 个区间的基准均匀粗网格（因此粗网格节点间距为 $h=1/64$）。当指定加密网格时，将中心区域 $[0.25,0.75]$ 加密一个因子 2（因此该区域的间距为 $h/2$），同时保持该区域外的粗网格间距。网格重划分事件发生在指定的时间步长，并且必须由您的保能量重映射处理。\n\n对于所有测试，三角函数中出现的角度都以弧度为单位。没有需要报告的物理单位；能量和误差都是无量纲的。\n\n- 测试用例 A（正常路径，从粗网格到加密网格）：\n  - 波速：$c=1$。\n  - 时间步长：$\\Delta t = 0.001$。\n  - 结束时间：$T=0.5$。\n  - 初始网格：包含 $N=64$ 个区间的均匀粗网格。\n  - 网格重划分：在时间步 $n=200$ 时，更改为上述加密网格；不再进行网格重划分。\n  - 初始数据：$u_0(x) = \\sin(\\pi x)$，$v_0(x) = 0$。\n\n- 测试用例 B（从加密网格到粗网格）：\n  - 波速：$c=1$。\n  - 时间步长：$\\Delta t = 0.001$。\n  - 结束时间：$T=0.5$。\n  - 初始网格：如上所述的加密网格。\n  - 网格重划分：在时间步 $n=200$ 时，更改为均匀粗网格；不再进行网格重划分。\n  - 初始数据：$u_0(x) = 0$，$v_0(x) = \\sin(2\\pi x)$。\n\n- 测试用例 C（两次网格重划分，不同速度）：\n  - 波速：$c=1.3$。\n  - 时间步长：$\\Delta t = 0.001$。\n  - 结束时间：$T=0.6$。\n  - 初始网格：包含 $N=64$ 个区间的均匀粗网格。\n  - 网格重划分：在时间步 $n=150$ 时，更改为加密网格；在时间步 $n=350$ 时，改回均匀粗网格。\n  - 初始数据：$u_0(x) = 0.2\\sin(\\pi x) + 0.1\\sin(2\\pi x)$，$v_0(x) = \\sin(3\\pi x)$。\n\n您的程序必须为每个测试用例计算整个时间积分过程中的最大绝对相对能量偏差，定义为\n$$\n\\max_{0 \\le n \\le N_T} \\frac{\\left|E^n - E^0\\right|}{E^0},\n$$\n其中 $E^n$ 是第 $n$ 步后的离散能量（包括任何网格重划分之后立即的能量），$N_T$ 是达到最终时间所需的总时间步数。在网格重划分前后使用相同的时间步长 $\\Delta t$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [A的结果, B的结果, C的结果]。每个结果必须是浮点数。例如：\"[0.0,1.0,2.0]\"。",
            "solution": "用户提供的问题是有效的。这是一个偏微分方程数值分析领域的适定问题，其基础是有限元法和几何数值积分的既定原则。所有参数都定义清晰，目标是定量且可验证的。\n\n解决方案要求为一维线性波动方程设计并实现一个数值格式。该格式必须处理能量守恒的两个不同要求：\n1.  在固定空间网格上的时间演化过程中，保持离散能量不变量。\n2.  在自适应网格加密 (AMR) 事件中，当底层网格及系统矩阵发生变化时，保持相同的离散能量。\n\n总体方法是将用于半离散哈密顿系统的保能量时间积分器与在网格重划分步骤中精心设计的保能量重映射过程相结合。\n\n### 1. 空间离散化：有限元法 (FEM)\n\n线性波动方程 $u_{tt} - c^2 u_{xx} = 0$ 在区间 $[0,1]$ 上使用连续分段线性 Galerkin 有限元法进行空间离散化。对于一个给定的包含 $N+1$ 个节点 $x_0, x_1, \\dots, x_N$ (其中 $x_0=0$ 且 $x_N=1$) 的网格，解 $u(x,t)$ 被近似为 $u_h(x,t) = \\sum_{j=1}^{N-1} q_j(t) \\phi_j(x)$，其中 $\\phi_j(x)$ 是标准的“帽”基函数，$q_j(t)$ 是代表 $n=N-1$ 个内部节点上解的随时间变化的系数。通过将边界节点排除在自由度之外来施加齐次狄利克雷边界条件 $u(0,t)=u(1,t)=0$。\n\n应用 Galerkin 方法得到常微分方程的半离散系统：\n$$\nM \\ddot{q}(t) + K q(t) = 0\n$$\n其中 $q(t) \\in \\mathbb{R}^n$ 是内部节点值的向量。矩阵 $M$（质量矩阵）和 $K$（刚度矩阵）是通过对每个单元 $[x_i, x_{i+1}]$ 的贡献求和来组装的。对于一个长度为 $h = x_{i+1} - x_i$ 的单元，局部的 $2 \\times 2$ 单元矩阵如下：\n- 质量矩阵：$M_e = \\frac{h}{6}\\begin{bmatrix}2  1 \\\\ 1  2\\end{bmatrix}$\n- 刚度矩阵：$K_e = \\frac{c^2}{h}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}$\n\n全局矩阵 $M$ 是对称正定的 (SPD)，而 $K$ 是对称半正定的 (SPSD)。\n\n### 2. 保能量时间积分\n\n半离散系统是一个哈密顿系统。通过定义正则动量 $p(t) = M \\dot{q}(t)$，二阶系统被转换为一阶系统：\n$$\n\\dot{q}(t) = M^{-1} p(t), \\qquad \\dot{p}(t) = -K q(t)\n$$\n代表系统离散能量的哈密顿量是动能和势能之和：\n$$\nE(q, p) = \\underbrace{\\frac{1}{2} \\dot{q}(t)^{\\top} M \\dot{q}(t)}_{\\text{Kinetic}} + \\underbrace{\\frac{1}{2} q(t)^{\\top} K q(t)}_{\\text{Potential}} = \\frac{1}{2} p(t)^{\\top} M^{-1} p(t) + \\frac{1}{2} q(t)^{\\top} K q(t)\n$$\n为了将这个二次能量不变量保持到机器精度，辛积分器是理想的选择。我们选择隐式中点格式，它是 A-稳定的、二阶精度的，并且能精确保持线性系统的所有二次不变量。对于时间步长 $\\Delta t$，从状态 $(q^n, p^n)$ 到 $(q^{n+1}, p^{n+1})$ 的更新定义为：\n$$\n\\frac{q^{n+1} - q^n}{\\Delta t} = M^{-1} \\left(\\frac{p^n + p^{n+1}}{2}\\right)\n$$\n$$\n\\frac{p^{n+1} - p^n}{\\Delta t} = -K \\left(\\frac{q^n + q^{n+1}}{2}\\right)\n$$\n这个隐式系统可以通过首先求解 $q^{n+1}$ 来重新排列成一系列显式更新：\n1.  求解 $q^{n+1}$ 的线性系统：\n    $$\n    \\left(M + \\frac{(\\Delta t)^2}{4} K\\right) q^{n+1} = \\left(M - \\frac{(\\Delta t)^2}{4} K\\right) q^n + \\Delta t \\, p^n\n    $$\n    左侧的矩阵是 SPD 的，确保了唯一解。\n2.  更新动量 $p^{n+1}$：\n    $$\n    p^{n+1} = p^n - \\frac{\\Delta t}{2} K (q^n + q^{n+1})\n    $$\n该积分器将构成网格重划分事件之间时间演化的基础。\n\n### 3. 用于 AMR 的保能量重映射\n\n当网格从具有矩阵 $(M^-, K^-)$ 的网格变为具有 $(M^+, K^+)$ 的网格时，状态向量 $(q^-, p^-)$ 必须映射到一个新的状态 $(q^+, p^+)$，以使离散能量守恒，即 $E(q^+, p^+, M^+, K^+) = E(q^-, p^-, M^-, K^-)$。\n\n将解朴素地插值到新网格上通常不会保持能量。该问题需要一个确定性的过程来强制实现这种守恒。我们设计了以下多步重映射策略：\n\n1.  **重构**：根据旧网格上的离散状态 $(q^-, p^-)$，重构连续的分段线性位移场 $u_h^-(x)$ 和速度场 $\\dot{u}_h^-(x)$。首先通过求解线性系统 $M^- v^- = p^-$ 来计算节点速度 $v^-$。\n2.  **投影/插值**：通过在新网格的内部节点上插值连续场 $u_h^-(x)$ 和 $\\dot{u}_h^-(x)$，获得新状态的初始猜测 $(\\tilde{q}^+, \\tilde{v}^+)$。相应的新动量为 $\\tilde{p}^+ = M^+ \\tilde{v}^+$。\n3.  **能量计算**：计算重映射前状态的能量 $E^-$ 和插值后重映射状态的能量 $\\tilde{E}^+$：\n    $$\n    E^{-} = E(q^-, p^-, M^-, K^-), \\qquad \\tilde{E}^{+} = E(\\tilde{q}^+, \\tilde{p}^+, M^+, K^+)\n    $$\n4.  **保能量缩放**：为了强制实现 $E^+ = E^-$，我们引入一个全局缩放因子 $\\alpha$。最终的重映射后状态 $(q^+, p^+)$ 被定义为插值状态的缩放版本：\n    $$\n    q^+ = \\alpha \\tilde{q}^+, \\qquad p^+ = \\alpha \\tilde{p}^+\n    $$\n    这个新状态的能量是 $E^+ = \\alpha^2 \\tilde{E}^+$。设置 $E^+ = E^-$ 得到确定性缩放因子：\n    $$\n    \\alpha = \\sqrt{\\frac{E^{-}}{\\tilde{E}^{+}}}\n    $$\n    此操作确保重映射后的能量与重映射前的能量相同（达到机器精度），从而满足问题的约束。\n\n### 4. 总体算法\n\n每个测试用例的完整数值模拟过程如下：\n1.  **初始化**：设置参数 ($c, \\Delta t, T$)，定义网格重划分计划，并指定初始条件函数 $u_0(x), v_0(x)$。\n2.  **初始状态**：生成初始网格并组装相应的矩阵 $M$ 和 $K$。通过在内部节点上插值 $u_0(x)$ 和 $v_0(x)$ 来初始化状态向量 $q(0)$ 和 $p(0)$，并设置 $p(0)=M v(0)$。\n3.  **初始能量**：计算并存储初始能量 $E^0 = E(q(0), p(0), M, K)$。\n4.  **时间循环**：对于每个时间步 $n=0, 1, \\dots, N_T-1$：\n    a. **网格重划分检查**：如果步骤 $n$ 是计划的网格重划分事件，执行第 3 节中描述的保能量重映射过程，以获得新的状态 $(q, p)$ 和矩阵 $(M, K)$。计算并存储重映射后立即的能量。\n    b. **时间积分**：使用第 2 节中描述的隐式中点格式的一个步骤，将状态从时间 $t_n$ 的 $(q, p)$推进到时间 $t_{n+1}$ 的 $(q, p)$。\n    c. **能量跟踪**：计算并存储时间步后的能量。\n5.  **度量计算**：完成所有时间步后，计算整个模拟过程中的最大绝对相对能量偏差，包括在任何网格重划分事件后立即记录的值：\n    $$\n    \\max_{k} \\frac{|E_k - E^0|}{E^0}\n    $$\n    其中 $\\{E_k\\}$ 是所有记录的能量值的集合。该度量量化了能量守恒策略的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_mesh(coarse_N, refined_flag):\n    \"\"\"Generates the mesh node coordinates based on the problem specification.\"\"\"\n    if not refined_flag:\n        return np.linspace(0, 1, coarse_N + 1, dtype=np.float64)\n    else:\n        h = 1.0 / coarse_N\n        n1 = int(round(0.25 / h))\n        nodes1 = np.linspace(0, 0.25, n1 + 1, dtype=np.float64)\n        \n        n2 = int(round(0.5 / (h / 2.0)))\n        nodes2 = np.linspace(0.25, 0.75, n2 + 1, dtype=np.float64)\n        \n        n3 = int(round(0.25 / h))\n        nodes3 = np.linspace(0.75, 1.0, n3 + 1, dtype=np.float64)\n        \n        nodes = np.concatenate((nodes1[:-1], nodes2[:-1], nodes3))\n        return nodes\n\ndef assemble_matrices(nodes, c):\n    \"\"\"Assembles the FEM mass (M) and stiffness (K) matrices.\"\"\"\n    n = len(nodes) - 2\n    if n = 0:\n        return csc_matrix((0, 0), dtype=np.float64), csc_matrix((0, 0), dtype=np.float64)\n\n    M = lil_matrix((n, n), dtype=np.float64)\n    K = lil_matrix((n, n), dtype=np.float64)\n    \n    for i in range(n + 1):\n        h = nodes[i+1] - nodes[i]\n        \n        m_loc = (h / 6.0) * np.array([[2, 1], [1, 2]])\n        k_loc = (c**2 / h) * np.array([[1, -1], [-1, 1]])\n        \n        g_indices = [i - 1, i]\n        \n        for r_loc in range(2):\n            g_r = g_indices[r_loc]\n            if 0 = g_r  n:\n                for c_loc in range(2):\n                    g_c = g_indices[c_loc]\n                    if 0 = g_c  n:\n                        M[g_r, g_c] += m_loc[r_loc, c_loc]\n                        K[g_r, g_c] += k_loc[r_loc, c_loc]\n                        \n    return M.tocsc(), K.tocsc()\n\ndef calculate_energy(q, p, M, K):\n    \"\"\"Calculates the discrete energy E = 1/2 p^T M^-1 p + 1/2 q^T K q.\"\"\"\n    if q.shape[0] == 0:\n        return 0.0\n    \n    # Kinetic term: Solve Mv = p for v, then 0.5 * p^T v\n    v = spsolve(M, p, use_umfpack=False)\n    kinetic_energy = 0.5 * p.dot(v)\n    \n    # Potential term\n    potential_energy = 0.5 * q.dot(K @ q)\n    \n    return kinetic_energy + potential_energy\n\ndef time_step(q, p, M, K, dt):\n    \"\"\"Performs one time step using the implicit midpoint rule.\"\"\"\n    n = q.shape[0]\n    if n == 0:\n        return q, p\n\n    A = M + (dt**2 / 4.0) * K\n    b = (M - (dt**2 / 4.0) * K) @ q + dt * p\n    \n    q_new = spsolve(A, b, use_umfpack=False)\n    p_new = p - (dt / 2.0) * (K @ (q + q_new))\n    \n    return q_new, p_new\n\ndef remap_state(q_old, p_old, M_old, K_old, nodes_old, c, nodes_new):\n    \"\"\"Remaps the state to a new mesh while preserving energy.\"\"\"\n    E_old = calculate_energy(q_old, p_old, M_old, K_old)\n    \n    v_old = spsolve(M_old, p_old, use_umfpack=False)\n    \n    q_old_full = np.concatenate(([0], q_old, [0]))\n    v_old_full = np.concatenate(([0], v_old, [0]))\n    \n    M_new, K_new = assemble_matrices(nodes_new, c)\n    \n    nodes_new_interior = nodes_new[1:-1]\n    q_new_tilde = np.interp(nodes_new_interior, nodes_old, q_old_full)\n    v_new_tilde = np.interp(nodes_new_interior, nodes_old, v_old_full)\n\n    p_new_tilde = M_new @ v_new_tilde\n    \n    E_new_tilde = calculate_energy(q_new_tilde, p_new_tilde, M_new, K_new)\n    \n    if E_old == 0.0:\n        alpha = 0.0\n    elif E_new_tilde == 0.0:\n        alpha = 0.0 \n    else:\n        alpha = np.sqrt(E_old / E_new_tilde)\n        \n    q_new = alpha * q_new_tilde\n    p_new = alpha * p_new_tilde\n    \n    return q_new, p_new, M_new, K_new\n\ndef run_simulation(case_params):\n    \"\"\"Runs a full simulation for a given test case.\"\"\"\n    c = case_params[\"c\"]\n    dt = case_params[\"dt\"]\n    T = case_params[\"T\"]\n    initial_mesh_refined = case_params[\"initial_mesh_refined\"]\n    regridding_events = case_params[\"regridding_events\"]\n    u0_func = case_params[\"u0_func\"]\n    v0_func = case_params[\"v0_func\"]\n\n    coarse_N = 64\n    \n    nodes = generate_mesh(coarse_N, initial_mesh_refined)\n    M, K = assemble_matrices(nodes, c)\n    \n    interior_nodes = nodes[1:-1]\n    q = u0_func(interior_nodes)\n    v = v0_func(interior_nodes)\n    if q.shape[0] > 0:\n        p = M @ v\n    else:\n        p = np.array([])\n    \n    E0 = calculate_energy(q, p, M, K)\n    energies = [E0]\n    \n    if E0 == 0.0:\n        return 0.0\n\n    num_steps = int(round(T / dt))\n    \n    for n in range(num_steps):\n        if n in regridding_events:\n            new_mesh_refined = regridding_events[n]\n            nodes_new = generate_mesh(coarse_N, new_mesh_refined)\n            \n            q, p, M_new, K_new = remap_state(q, p, M, K, nodes, c, nodes_new)\n\n            M, K, nodes = M_new, K_new, nodes_new\n\n            energies.append(calculate_energy(q, p, M, K))\n        \n        q, p = time_step(q, p, M, K, dt)\n        \n        energies.append(calculate_energy(q, p, M, K))\n        \n    energies = np.array(energies)\n    max_rel_dev = np.max(np.abs(energies - E0)) / E0\n    \n    return max_rel_dev\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"c\": 1.0, \"dt\": 0.001, \"T\": 0.5,\n            \"initial_mesh_refined\": False,\n            \"regridding_events\": {200: True},\n            \"u0_func\": lambda x: np.sin(np.pi * x),\n            \"v0_func\": lambda x: np.zeros_like(x)\n        },\n        # Test Case B\n        {\n            \"c\": 1.0, \"dt\": 0.001, \"T\": 0.5,\n            \"initial_mesh_refined\": True,\n            \"regridding_events\": {200: False},\n            \"u0_func\": lambda x: np.zeros_like(x),\n            \"v0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        # Test Case C\n        {\n            \"c\": 1.3, \"dt\": 0.001, \"T\": 0.6,\n            \"initial_mesh_refined\": False,\n            \"regridding_events\": {150: True, 350: False},\n            \"u0_func\": lambda x: 0.2 * np.sin(np.pi * x) + 0.1 * np.sin(2 * np.pi * x),\n            \"v0_func\": lambda x: np.sin(3 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}