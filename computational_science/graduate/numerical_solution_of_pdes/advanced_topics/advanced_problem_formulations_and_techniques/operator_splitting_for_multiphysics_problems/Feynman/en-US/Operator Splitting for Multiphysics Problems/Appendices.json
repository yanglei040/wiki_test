{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, our first practice delves into the mathematical origin of the error inherent in operator splitting. This exercise requires you to calculate the leading-order error term for Strang splitting, which arises directly from the non-commutativity of the advection and diffusion operators. By implementing the commutator expression from the Baker-Campbell-Hausdorff formula, you will gain a concrete understanding of how abstract operator algebra translates into tangible numerical error in a simulation.",
            "id": "3427806",
            "problem": "Consider the two-dimensional passive scalar advection–diffusion equation on a periodic square domain with side length $2\\pi$:\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s),\n$$\nwhere the advection operator $A$ and the diffusion operator $B$ are defined by\n$$\nA(s) = -\\boldsymbol{v}\\cdot\\nabla s,\\qquad B(s) = \\nu \\Delta s.\n$$\nThe velocity field $\\boldsymbol{v}(x,y)$ is time-independent and given by the Taylor–Green vortex:\n$$\n\\boldsymbol{v}(x,y) = \\left(U\\sin(k_v x)\\cos(k_v y),\\,-U\\cos(k_v x)\\sin(k_v y)\\right),\n$$\nand the initial scalar field is\n$$\ns_0(x,y) = \\cos(k_s x)\\cos(k_s y).\n$$\nAssume all quantities are dimensionless and the domain is $[0,2\\pi]\\times[0,2\\pi]$ with periodic boundary conditions.\n\nYou are to:\n- Compute the leading-order expected error in the $L^2$ norm after one time step due to operator splitting alone (that is, excluding spatial and temporal discretization errors) using the Baker–Campbell–Hausdorff expansion. For time-invariant operators $A$ and $B$, the local error of Strang splitting is of order $\\mathcal{O}(\\Delta t^3)$ and the leading term is given by\n$$\n\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0,\n$$\nwhere the commutator $[X,Y]$ acting on a function $f$ is defined by $[X,Y]f = X(Yf) - Y(Xf)$. The expected $L^2$ error should therefore be computed as\n$$\n\\left\\|\\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\\right\\|_{L^2},\n$$\nwith the $L^2$ norm defined by\n$$\n\\|f\\|_{L^2} = \\left(\\int_{0}^{2\\pi}\\int_{0}^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}.\n$$\n\nYour implementation must:\n- Use a uniform grid of size $N\\times N$ over $[0,2\\pi]\\times[0,2\\pi]$.\n- Compute spatial derivatives via the Fast Fourier Transform (FFT) to evaluate $\\nabla s$ and $\\Delta s$ consistently for periodic functions.\n- Compute the expected $L^2$ error using the commutator expression above, implemented by composing $A$ and $B$ numerically via FFT-based derivatives.\n\nDesign a test suite covering different facets:\n- A general case with nonzero advection and diffusion.\n- Boundary cases where either advection or diffusion vanishes, for which the splitting error should be zero by definition.\n- A case with higher wavenumbers to stress noncommutativity.\n- A case with stronger advection.\n\nUse the following test cases $(U,k_v,k_s,\\nu,\\Delta t,N)$:\n1. $(1.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n2. $(1.0,\\,1,\\,1,\\,0.00,\\,0.05,\\,64)$\n3. $(0.0,\\,1,\\,1,\\,0.01,\\,0.05,\\,64)$\n4. $(2.0,\\,2,\\,3,\\,0.02,\\,0.05,\\,64)$\n5. $(1.0,\\,4,\\,4,\\,0.01,\\,0.10,\\,64)$\n\nYour program should produce a single line of output containing the expected $L^2$ error values for the five cases, as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3,e_4,e_5]$). No other text should be printed. All values must be dimensionless real numbers. Angles in trigonometric functions are in radians.",
            "solution": "The problem requires the computation of the leading-order error of a Strang-splitting scheme for the two-dimensional advection-diffusion equation. The solution involves discretizing the domain and operators, then numerically evaluating a complex expression involving nested commutators of these operators.\n\nThe governing equation is\n$$\n\\frac{\\partial s}{\\partial t} = A(s) + B(s)\n$$\non a periodic domain $[0,2\\pi]\\times[0,2\\pi]$, where $A(s) = -\\boldsymbol{v}\\cdot\\nabla s$ is the advection operator and $B(s) = \\nu \\Delta s$ is the diffusion operator. The velocity field is a time-independent Taylor-Green vortex, and the initial scalar field is $s_0(x,y) = \\cos(k_s x)\\cos(k_s y)$.\n\nThe primary objective is to calculate the $L^2$ norm of the leading-order local error term for a single Strang-splitting step of duration $\\Delta t$. For time-invariant operators, this error term is given by the Baker-Campbell-Hausdorff (BCH) expansion as:\n$$\nE = \\frac{\\Delta t^3}{12}\\left([A,[A,B]] + [B,[B,A]]\\right) s_0\n$$\nwhere $[X,Y]f = X(Yf) - Y(Xf)$ is the commutator of operators $X$ and $Y$. We are tasked to compute $\\|E\\|_{L^2}$.\n\nThe computational strategy proceeds as follows:\n1.  Discretize the continuous domain $[0,2\\pi]\\times[0,2\\pi]$ into a uniform $N\\times N$ grid.\n2.  Implement numerical representations of the differential operators $A$ and $B$ using pseudospectral methods (i.e., via the Fast Fourier Transform, FFT).\n3.  Evaluate the nested commutator expression by applying the numerical operators sequentially to the initial field $s_0$.\n4.  Compute the $L^2$ norm of the resulting error field using numerical integration.\n\n**Step 1: Discretization and Fourier Representation**\nThe domain is discretized into an $N \\times N$ grid with coordinates $(x_i, y_j)$, where $x_i = i \\frac{2\\pi}{N}$ and $y_j = j \\frac{2\\pi}{N}$ for $i,j \\in \\{0, 1, \\dots, N-1\\}$. A scalar field $s(x,y)$ is represented as a matrix $s_{ij} = s(x_i, y_j)$.\n\nFor a periodic function on this grid, spatial derivatives are most accurately computed in Fourier space. The 2D discrete Fourier transform of $s$ is $\\hat{s}(\\boldsymbol{k}) = \\mathcal{F}(s)$, where $\\boldsymbol{k}=(k_x, k_y)$ is the wavevector. The integer wavenumbers corresponding to the grid are $k_x, k_y \\in \\{-\\frac{N}{2}, \\dots, \\frac{N}{2}-1\\}$. Derivatives transform as:\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial x}\\right) = i k_x \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}\\left(\\frac{\\partial s}{\\partial y}\\right) = i k_y \\hat{s}(\\boldsymbol{k})\n$$\n$$\n\\mathcal{F}(\\Delta s) = \\mathcal{F}\\left(\\frac{\\partial^2 s}{\\partial x^2} + \\frac{\\partial^2 s}{\\partial y^2}\\right) = -(k_x^2 + k_y^2) \\hat{s}(\\boldsymbol{k}) = -|\\boldsymbol{k}|^2 \\hat{s}(\\boldsymbol{k})\n$$\nThe real-space derivatives are then recovered by applying the inverse Fourier transform $\\mathcal{F}^{-1}$.\n\n**Step 2: Numerical Implementation of Operators $A$ and $B$**\nThe operators are implemented as functions that act on a 2D array representing the scalar field.\n\nThe diffusion operator $B(s) = \\nu \\Delta s$ is computed entirely in Fourier space. The numerical procedure is:\n1.  Compute the 2D FFT of the field $s$: $\\hat{s} = \\text{fft2}(s)$.\n2.  Multiply by the Fourier symbol of the operator: $\\widehat{B(s)} = \\nu (-|\\boldsymbol{k}|^2) \\hat{s}$.\n3.  Compute the 2D inverse FFT of the result and take the real part: $B(s) = \\text{real}(\\text{ifft2}(\\widehat{B(s)}))$.\n\nThe advection operator $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$ is implemented using the pseudospectral method:\n1.  Compute the gradients $\\frac{\\partial s}{\\partial x}$ and $\\frac{\\partial s}{\\partial y}$ in Fourier space as described above.\n2.  Transform the gradients back to real space.\n3.  Compute the velocity field components $v_x$ and $v_y$ on the grid.\n4.  Perform the dot product and multiplication by $-1$ in real space: $A(s) = -(v_x \\frac{\\partial s}{\\partial x} + v_y \\frac{\\partial s}{\\partial y})$.\n\n**Step 3: Evaluation of the Commutator Expression**\nThe expression $E = \\frac{\\Delta t^3}{12} \\left( [A,[A,B]]s_0 + [B,[B,A]]s_0 \\right)$ involves nested commutators. To compute this numerically, we expand the commutators:\n$$\n[A,[A,B]]s_0 = A(A(B(s_0))) - 2A(B(A(s_0))) + B(A(A(s_0)))\n$$\n$$\n[B,[B,A]]s_0 = A(B(B(s_0))) - 2B(A(B(s_0))) + B(B(A(s_0)))\n$$\nLet's denote the application of an operator $X$ to a field $f$ as $Xf$. The numerical evaluation requires computing all six unique third-order operator sequences on the initial field $s_0$:\n$AABs_0$, $ABAs_0$, $BAAs_0$, $ABBs_0$, $BABs_0$, $BBAs_0$.\nThe total unscaled error field is then assembled as:\n$$\n_E = (AABs_0 - 2 ABAs_0 + BAAs_0) + (ABBs_0 - 2 BABs_0 + BBAs_0)\n$$\nFinally, the full error field is $E = \\frac{\\Delta t^3}{12} {}_E$. Note that if either $U=0$ (so $A=0$) or $\\nu=0$ (so $B=0$), the commutators vanish, yielding an error of zero as expected.\n\n**Step 4: Computation of the $L^2$ Norm**\nThe $L^2$ norm of a function $f$ on the domain is $\\|f\\|_{L^2} = \\left(\\int_0^{2\\pi}\\int_0^{2\\pi} |f(x,y)|^2 \\, dx\\,dy\\right)^{1/2}$. This integral is approximated by a sum over the discrete grid points:\n$$\n\\|E\\|_{L^2} \\approx \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} |E(x_i, y_j)|^2 \\Delta x \\Delta y \\right)^{1/2}\n$$\nwhere $E(x_i, y_j)$ are the values of the computed error field on the grid, and the grid spacing is $\\Delta x = \\Delta y = \\frac{2\\pi}{N}$.\n\nThe overall algorithm iterates through each test case, sets up the parameters and initial field, and then executes steps 2 through 4 to calculate the final scalar error value.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the leading-order Strang splitting error for the 2D\n    advection-diffusion equation on a periodic domain.\n    \"\"\"\n    test_cases = [\n        (1.0, 1, 1, 0.01, 0.05, 64),\n        (1.0, 1, 1, 0.00, 0.05, 64),\n        (0.0, 1, 1, 0.01, 0.05, 64),\n        (2.0, 2, 3, 0.02, 0.05, 64),\n        (1.0, 4, 4, 0.01, 0.10, 64)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        U, k_v, k_s, nu, dt, N = case\n\n        # If U or nu is zero, one operator is zero, so the commutator is zero,\n        # and the splitting error is zero.\n        if U == 0.0 or nu == 0.0:\n            results.append(0.0)\n            continue\n\n        # 1. Setup Grid, Wavenumbers, and Fields\n        L = 2.0 * np.pi\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        # Wavenumbers for FFT on a domain of size L=2*pi\n        k_vec = np.fft.fftfreq(N) * N \n        Kx, Ky = np.meshgrid(k_vec, k_vec, indexing='ij')\n        K2 = Kx**2 + Ky**2\n\n        # Initial scalar field\n        s0 = np.cos(k_s * X) * np.cos(k_s * Y)\n        # Velocity field\n        vx = U * np.sin(k_v * X) * np.cos(k_v * Y)\n        vy = -U * np.cos(k_v * X) * np.sin(k_v * Y)\n\n        # 2. Define numerical operators A and B\n        def apply_A(s_field):\n            \"\"\"Applies advection operator A(s) = -v . grad(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            ds_dx_hat = 1j * Kx * s_hat\n            ds_dy_hat = 1j * Ky * s_hat\n            ds_dx = np.fft.ifft2(ds_dx_hat).real\n            ds_dy = np.fft.ifft2(ds_dy_hat).real\n            return -(vx * ds_dx + vy * ds_dy)\n\n        def apply_B(s_field):\n            \"\"\"Applies diffusion operator B(s) = nu * laplacian(s)\"\"\"\n            s_hat = np.fft.fft2(s_field)\n            lap_s_hat = -K2 * s_hat\n            lap_s = np.fft.ifft2(lap_s_hat).real\n            return nu * lap_s\n\n        # 3. Compute all third-order operator applications\n        \n        # 1st order applications\n        As0 = apply_A(s0)\n        Bs0 = apply_B(s0)\n        \n        # 2nd order applications\n        AAs0 = apply_A(As0)\n        ABs0 = apply_A(Bs0)\n        BAs0 = apply_B(As0)\n        BBs0 = apply_B(Bs0)\n\n        # 3rd order applications\n        # For term [A, [A, B]]s0 = AABs0 - 2*ABAs0 + BAAs0\n        AABs0 = apply_A(ABs0)\n        ABAs0 = apply_A(BAs0)\n        BAAs0 = apply_B(AAs0)\n        \n        # For term [B, [B, A]]s0 = ABBs0 - 2*BABs0 + BBAs0\n        ABBs0 = apply_A(BBs0)\n        BABs0 = apply_B(ABs0)\n        BBAs0 = apply_B(BAs0)\n\n        # 4. Assemble the full error field\n        # term1 = A(A(B(s0))) - 2A(B(A(s0))) + B(A(A(s0)))\n        term1_field = AABs0 - 2.0 * ABAs0 + BAAs0\n        # term2 = A(B(B(s0))) - 2B(A(B(s0))) + B(B(A(s0)))\n        term2_field = ABBs0 - 2.0 * BABs0 + BBAs0\n        \n        unscaled_error_field = term1_field + term2_field\n        error_field = (dt**3 / 12.0) * unscaled_error_field\n\n        # 5. Compute the L2 norm of the error field\n        l2_norm_sq = np.sum(np.abs(error_field)**2) * (dx**2)\n        l2_norm = np.sqrt(l2_norm_sq)\n        \n        results.append(l2_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Operator splitting is a flexible principle that gives rise to a wide variety of numerical schemes. In this exercise, you will implement and compare two powerful methods for a semilinear partial differential equation: the symmetric Strang splitting scheme and a first-order exponential time differencing (ETD) integrator. This practice illuminates how the core idea of separating operators can be realized in fundamentally different algorithmic structures, each with its own trade-offs for handling stiff and nonlinear dynamics.",
            "id": "3427836",
            "problem": "Consider the semilinear partial differential equation (PDE) $u_t = D u_{xx} + \\lambda u^3$ posed on the periodic spatial domain $x \\in [0,L]$ with periodic boundary conditions and a uniform grid. The objective is to compute a single time step from $t=0$ to $t=\\Delta t$ using two operator-splitting based integrators and to quantify the difference between their numerical solutions at $t=\\Delta t$.\n\nYou must implement both of the following time-integration strategies on a uniform grid with $N$ points:\n- Exponential Time Differencing of first order (ETD1), where the linear diffusion operator is treated by its exact semigroup and the nonlinearity is treated to first order in time.\n- Strang splitting (symmetric second-order splitting) between the diffusion and the cubic reaction, using exact substeps for each operator.\n\nYour program must use the Fourier spectral method (with the Fast Fourier Transform) to represent the periodic spatial discretization. Compute the exact linear diffusion substep via the Fourier multiplier corresponding to the semigroup of the Laplacian, and use the exact solution of the pointwise ordinary differential equation (ODE) $u_t=\\lambda u^3$ for the reaction substeps. Use the Variation-of-Constants principle to formulate ETD1, and do not introduce any artificial stabilization.\n\nInitial data must be prescribed as a trigonometric function on the grid. For a uniform grid with spacing $h=L/N$, grid points $x_j = j h$ for $j=0,1,\\dots,N-1$, and parameters $(L,N,D,\\lambda,\\Delta t,A_1,A_2)$, set\n$$\nu_0(x) = A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\cos\\left(\\frac{4\\pi x}{L}\\right).\n$$\n\nCompute, for each test case, the discrete $L^2$ difference between the ETD1 solution $u^{\\text{ETD1}}(\\Delta t)$ and the Strang splitting solution $u^{\\text{Strang}}(\\Delta t)$, defined by\n$$\n\\| u^{\\text{ETD1}}(\\Delta t) - u^{\\text{Strang}}(\\Delta t) \\|_{L^2_h}\n\\;=\\;\n\\left( h \\sum_{j=0}^{N-1} \\left( u^{\\text{ETD1}}_j - u^{\\text{Strang}}_j \\right)^2 \\right)^{1/2}.\n$$\n\nAll quantities are dimensionless; do not include any physical units. Angles must be interpreted in radians. Produce results as decimal floating-point numbers.\n\nImplement the following test suite of parameter sets to exercise different regimes:\n- Test $1$ (general case): $(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.05,1.0,0.001,0.2,0.05)$.\n- Test $2$ (no diffusion boundary case): $(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.0,1.0,0.001,0.2,0.05)$.\n- Test $3$ (no reaction edge case): $(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,128,0.2,0.0,0.005,0.2,0.05)$.\n- Test $4$ (strong diffusion, negative reaction coefficient): $(L,N,D,\\lambda,\\Delta t,A_1,A_2) = (1,64,1.0,-1.0,0.005,0.1,0.05)$.\n\nYour program should produce a single line of output containing the discrete $L^2$ differences for all tests as a comma-separated list enclosed in square brackets, in the order of the tests above; for example, the output format must be\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\nEach $\\text{result}_i$ must be a decimal floating-point number.",
            "solution": "The present problem requires the numerical solution of a semilinear reaction-diffusion equation over a single time step using two distinct operator-splitting methods. The results are to be compared by computing the discrete $L^2$ norm of their difference.\n\nThe governing partial differential equation (PDE) is:\n$$\nu_t = D u_{xx} + \\lambda u^3\n$$\nThis equation is posed on a one-dimensional spatial domain $x \\in [0, L]$ with periodic boundary conditions. It can be formally written as an abstract ordinary differential equation (ODE) in a function space, $u_t = (\\mathcal{L} + \\mathcal{N})u$, where $\\mathcal{L}u = D u_{xx}$ is the linear diffusion operator and $\\mathcal{N}(u) = \\lambda u^3$ is the nonlinear reaction operator.\n\nFirst, we define the spatial discretization. A uniform grid with $N$ points is used, with grid spacing $h = L/N$. The grid points are $x_j = j h$ for $j = 0, 1, \\dots, N-1$. The solution on this grid is a vector $u_j(t) \\approx u(x_j, t)$.\n\nFor periodic problems, the Fourier spectral method is exceptionally effective. A function $u(x)$ is represented by its discrete Fourier coefficients $\\hat{u}_k$, computed via the Fast Fourier Transform (FFT). The key property of this method is that spatial differentiation in real space becomes multiplication in Fourier space. The second derivative operator $\\partial_{xx}$ corresponds to multiplication by $(i k_p)^2 = -k_p^2$, where $k_p$ are the physical wavenumbers. The wavenumbers corresponding to the discrete grid are given by $k_p = 2\\pi k_s$, where the spatial frequencies $k_s$ are arranged by the FFT algorithm. For a grid of $N$ points with spacing $h$, these frequencies are given by $k_s = [0, 1/L, 2/L, \\dots, F_{max}, \\dots, -2/L, -1/L]$, where $F_{max}$ is the Nyquist frequency. The linear operator $\\mathcal{L}$ in Fourier space is thus represented by multiplication with the diagonal matrix with entries $\\hat{L}_k = -D k_p^2 = -D (2\\pi k_s)^2$.\n\nThe initial condition is given by:\n$$\nu_0(x_j) = A_1 \\sin\\left(\\frac{2\\pi x_j}{L}\\right) + A_2 \\cos\\left(\\frac{4\\pi x_j}{L}\\right)\n$$\n\nWe will now detail the two numerical integration schemes for advancing the solution from time $t=0$ to $t=\\Delta t$.\n\n**Method 1: Strang Splitting**\n\nStrang splitting is a second-order accurate method that approximates the exponential of the sum of two operators by a symmetric composition of their individual exponentials. For one time step $\\Delta t$, the update from the solution $u_n$ at time $t_n$ to $u_{n+1}$ at $t_{n+1} = t_n + \\Delta t$ is:\n$$\nu_{n+1} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{N}} e^{\\Delta t \\mathcal{L}} e^{\\frac{\\Delta t}{2}\\mathcal{N}} u_n\n$$\nThis is implemented as a sequence of three substeps:\n1.  **Half-step for Reaction**: Evolve the solution under the nonlinear operator $\\mathcal{N}$ for a time of $\\Delta t/2$. This involves solving the ODE $v_t = \\lambda v^3$ for each grid point independently. The exact solution to this ODE with initial condition $v(0) = v_0$ is found by separation of variables:\n    $$\n    \\int_{v_0}^{v(t)} \\frac{dv}{v^3} = \\int_0^t \\lambda ds \\implies -\\frac{1}{2v(t)^2} + \\frac{1}{2v_0^2} = \\lambda t \\implies v(t) = \\frac{v_0}{\\sqrt{1 - 2\\lambda v_0^2 t}}\n    $$\n    For a time step of duration $\\tau = \\Delta t/2$, the update is $v_j \\to v_j / \\sqrt{1 - 2\\lambda v_j^2 (\\Delta t/2)} = v_j / \\sqrt{1 - \\lambda v_j^2 \\Delta t}$. This is applied to the initial data $u_0$.\n\n2.  **Full-step for Diffusion**: Evolve the result from the first substep under the linear operator $\\mathcal{L}$ for a full time step $\\Delta t$. The solution to $u_t = \\mathcal{L}u = D u_{xx}$ is formally $u(t) = e^{t\\mathcal{L}} u(0)$. In Fourier space, this becomes a simple multiplication: $\\hat{u}_k(t) = e^{t\\hat{L}_k} \\hat{u}_k(0)$. The procedure is to take the FFT of the current state, multiply each Fourier coefficient $\\hat{u}_k$ by the propagator $e^{\\hat{L}_k \\Delta t} = e^{-D k_p^2 \\Delta t}$, and then take the inverse FFT to return to real space.\n\n3.  **Half-step for Reaction**: Evolve the result from the diffusion step under the nonlinear operator $\\mathcal{N}$ for another time of $\\Delta t/2$, using the same exact pointwise update rule as in the first step.\n\n**Method 2: First-Order Exponential Time Differencing (ETD1)**\n\nExponential integrators work with the variation-of-constants formula for the PDE:\n$$\nu(t_{n+1}) = e^{\\Delta t \\mathcal{L}} u(t_n) + \\int_0^{\\Delta t} e^{(\\Delta t - s)\\mathcal{L}} \\mathcal{N}(u(t_n+s)) ds\n$$\nThe ETD1 method approximates the integral by assuming the nonlinear term is constant over the time step, i.e., $\\mathcal{N}(u(t_n+s)) \\approx \\mathcal{N}(u(t_n))$. This gives:\n$$\nu_{n+1} \\approx e^{\\Delta t \\mathcal{L}} u_n + \\mathcal{N}(u_n) \\int_0^{\\Delta t} e^{(\\Delta t-s)\\mathcal{L}} ds = e^{\\Delta t \\mathcal{L}} u_n + \\left( e^{\\Delta t \\mathcal{L}} - I \\right) \\mathcal{L}^{-1} \\mathcal{N}(u_n)\n$$\nThis is commonly written using the $\\phi_1$ function, where $\\phi_1(z) = (e^z-1)/z$:\n$$\nu_{n+1} \\approx e^{\\Delta t \\mathcal{L}} u_n + \\Delta t \\phi_1(\\Delta t \\mathcal{L}) \\mathcal{N}(u_n)\n$$\nThe implementation is performed in Fourier space:\n1.  Compute the nonlinear term in real space: $N_0 = \\lambda u_0^3$.\n2.  Transform both the initial state $u_0$ and the nonlinear term $N_0$ to Fourier space to obtain $\\hat{u}_0$ and $\\hat{N}_0$.\n3.  Define the Fourier multipliers. Let $z_k = \\hat{L}_k \\Delta t = -D k_p^2 \\Delta t$. The first multiplier is $E_k = e^{z_k}$. The second is the $\\phi_1$ multiplier, $\\phi_{1,k} = (e^{z_k}-1)/z_k$. For the case $z_k=0$ (which occurs for the $k=0$ mode or if $D=0$), the limit $\\lim_{z \\to 0} \\phi_1(z) = 1$ is used to avoid division by zero.\n4.  Apply the update in Fourier space: $\\hat{u}_{1,k} = E_k \\hat{u}_{0,k} + \\Delta t \\phi_{1,k} \\hat{N}_{0,k}$.\n5.  Transform $\\hat{u}_1$ back to real space using the inverse FFT to get the solution $u^{\\text{ETD1}}(\\Delta t)$.\n\n**Final Comparison**\n\nAfter computing the solutions at $t=\\Delta t$ from both methods, $u^{\\text{Strang}}(\\Delta t)$ and $u^{\\text{ETD1}}(\\Delta t)$, we quantify their difference using the discrete $L^2$ norm, defined as:\n$$\n\\| u^{\\text{ETD1}}(\\Delta t) - u^{\\text{Strang}}(\\Delta t) \\|_{L^2_h} = \\left( h \\sum_{j=0}^{N-1} \\left( u^{\\text{ETD1}}_j - u^{\\text{Strang}}_j \\right)^2 \\right)^{1/2}\n$$\nThis calculation is performed for each of the four test cases provided. For the special case where the reaction is absent ($\\lambda=0$), both methods reduce to an exact solve of the linear diffusion equation, and their difference should be zero up to machine precision. For the case where diffusion is absent ($D=0$), Strang splitting exactly solves the remaining ODE, while ETD1 reduces to the first-order forward Euler method, leading to a non-zero difference.",
            "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef strang_step(u_n, linear_op_fourier, lam, dt):\n    \"\"\"\n    Performs one Strang splitting step.\n    u_np1 = exp(dt/2 N) exp(dt L) exp(dt/2 N) u_n\n    \"\"\"\n    # First nonlinear substep for dt/2\n    if lam == 0.0:\n        u_star = u_n\n    else:\n        # Exact solution for u_t = lam * u^3 for time dt/2\n        # u(t) = u0 / sqrt(1 - 2*lam*u0^2*t)\n        # Here t = dt/2, so the denominator term is (1 - lam * u_n^2 * dt)\n        denom_sq_term = 1.0 - lam * (u_n**2) * dt\n        if np.any(denom_sq_term = 0):\n            raise ValueError(\"Blow-up detected in Strang splitting nonlinear step.\")\n        u_star = u_n / np.sqrt(denom_sq_term)\n\n    # Linear substep for dt\n    u_star_hat = fft(u_star)\n    propagator = np.exp(linear_op_fourier * dt)\n    u_star_star_hat = propagator * u_star_hat\n    u_star_star = ifft(u_star_star_hat).real\n\n    # Second nonlinear substep for dt/2\n    if lam == 0.0:\n        u_np1 = u_star_star\n    else:\n        denom_sq_term = 1.0 - lam * (u_star_star**2) * dt\n        if np.any(denom_sq_term = 0):\n            raise ValueError(\"Blow-up detected in Strang splitting nonlinear step.\")\n        u_np1 = u_star_star / np.sqrt(denom_sq_term)\n    \n    return u_np1\n\ndef etd1_step(u_n, linear_op_fourier, lam, dt):\n    \"\"\"\n    Performs one first-order Exponential Time Differencing (ETD1) step.\n    u_np1 = exp(dt*L)u_n + dt*phi1(dt*L)N(u_n)\n    \"\"\"\n    # Calculate nonlinear term N(u_n)\n    N_u = lam * u_n**3\n    \n    # FFT of state vector and nonlinear term\n    u_n_hat = fft(u_n)\n    N_u_hat = fft(N_u)\n    \n    # Define z = dt * L_op\n    z = linear_op_fourier * dt\n    \n    # Calculate propagators E = exp(z) and phi1 = (exp(z)-1)/z\n    E = np.exp(z)\n    \n    # Use np.where to handle the z=0 case to avoid division by zero\n    phi1 = np.where(z == 0, 1.0, (E - 1.0) / z)\n    \n    # Update in Fourier space\n    u_np1_hat = E * u_n_hat + dt * phi1 * N_u_hat\n    \n    # Inverse FFT to get the solution in real space\n    u_np1 = ifft(u_np1_hat).real\n    \n    return u_np1\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and compute differences.\n    \"\"\"\n    test_cases = [\n        # (L, N, D, lambda, dt, A1, A2)\n        (1.0, 128, 0.05, 1.0, 0.001, 0.2, 0.05),\n        (1.0, 128, 0.0, 1.0, 0.001, 0.2, 0.05),\n        (1.0, 128, 0.2, 0.0, 0.005, 0.2, 0.05),\n        (1.0, 64, 1.0, -1.0, 0.005, 0.1, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, D, lam, dt, A1, A2 = case\n\n        # 1. Set up grid, initial condition, and Fourier space operator\n        h = L / N\n        x = np.arange(N) * h\n        \n        u0 = A1 * np.sin(2 * np.pi * x / L) + A2 * np.cos(4 * np.pi * x / L)\n\n        # Spatial frequencies (cycles per unit length)\n        k_freq = fftfreq(N, d=h)\n        # Physical wavenumbers\n        k_physical = 2 * np.pi * k_freq\n        \n        # Linear operator in Fourier space (for D*u_xx)\n        linear_op_fourier = -D * (k_physical**2)\n\n        # 2. Compute one step with Strang splitting\n        u_strang = strang_step(u0, linear_op_fourier, lam, dt)\n\n        # 3. Compute one step with ETD1\n        u_etd1 = etd1_step(u0, linear_op_fourier, lam, dt)\n\n        # 4. Compute the discrete L2 difference\n        diff = u_etd1 - u_strang\n        l2_diff = np.sqrt(h * np.sum(diff**2))\n        \n        results.append(l2_diff)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Our final practice addresses the complexities that arise when applying operator splitting to tightly coupled multiphysics systems. This problem simulates a chemo-mechanical model where the choice of operator ordering is not just a matter of accuracy, but can impact fundamental physical properties of the solution. By testing how different splitting sequences affect the monotonic behavior of state-of-charge and stress, you will develop a crucial skill: evaluating the physical consistency of numerical schemes in complex, real-world inspired scenarios.",
            "id": "3427809",
            "problem": "Consider a one-dimensional electrode domain $x \\in [0,L]$ in which lithium concentration $c(x,t)$ diffuses and induces stress through chemo-mechanical coupling with displacement $u(x,t)$. The coupled multiphysics model consists of a diffusion equation for $c$ and a viscoelastic-mechanical equilibrium for $u$, with operator splitting to evolve the two physics sequentially over each time step. All variables are nondimensional; no physical units are required.\n\nFundamental base:\n- Mass conservation and Fickian diffusion: the lithium concentration $c$ evolves according to $\\partial c/\\partial t = -\\partial J/\\partial x$, where $J$ is the flux.\n- Chemo-mechanical coupling in the flux: adopt a stress-driven correction in the Larché–Cahn spirit, $J = -D\\left(\\partial c/\\partial x - \\chi \\,\\partial \\sigma/\\partial x\\right)$, where $D$ is the diffusivity, $\\chi$ is a coupling coefficient, and $\\sigma$ is the stress.\n- Linear viscoelasticity (Kelvin–Voigt) with a Winkler foundation: stress is $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$, strain is $\\varepsilon = \\partial u/\\partial x$, elastic modulus is $E$, viscosity is $\\eta$, and chemical expansion coefficient is $\\alpha$. The mechanical equilibrium is $\\partial \\sigma/\\partial x - k_f\\,u = 0$, where $k_f$ is the foundation stiffness.\n\nFrom these principles, the coupled partial differential equations (PDEs) are\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right], \\quad 0  x  L,\n$$\n$$\n\\frac{\\partial}{\\partial x}\\left(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\right) - k_f\\,u = 0, \\quad 0  x  L.\n$$\nUsing the mechanical equilibrium relation $\\partial \\sigma/\\partial x = k_f\\,u$ for the full viscoelastic stress $\\sigma$, the diffusion equation becomes\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\nBoundary and initial conditions:\n- Concentration boundary flux at $x=0$ models charging: $J(0,t) = J_{\\text{in}}$ with $J_{\\text{in}}  0$ constant, and zero flux at $x=L$: $J(L,t) = 0$. Using $J = -D(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x)$ and the mechanical boundary conditions below, this reduces to Neumann conditions $-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ and $-D\\,\\partial c/\\partial x(L,t) = 0$.\n- Mechanics are clamped: $u(0,t) = 0$ and $u(L,t) = 0$.\n- Initial conditions: $c(x,0) = 0$ and $u(x,0) = 0$.\n\nSpatial discretization:\n- Uniform grid with $N$ nodes on $[0,L]$ and spacing $\\Delta x = L/(N-1)$.\n- Finite differences: second derivative via a standard three-point stencil and first derivative via central differences. For the diffusion equation, the Neumann boundary conditions for $c$ are enforced via ghost-point values consistent with the prescribed fluxes.\n\nTime discretization and operator splitting:\n- Time step $\\Delta t$ and $N_t$ total steps.\n- Two Lie-splitting orderings per time step $t^n \\to t^{n+1}$:\n  1. Diffusion–Mechanics (DM): first advance $c$ explicitly using $u$ at time $t^n$, then solve mechanics for $u$ at time $t^{n+1}$ using the updated $c$.\n  2. Mechanics–Diffusion (MD): first solve mechanics using $c$ at time $t^n$, then advance $c$ explicitly using the updated $u$; the stress at the end of the step is evaluated consistently with the mechanical substep concentration $c^n$.\n- Diffusion substep (explicit Euler):\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right),\n$$\nwhere $\\Delta_x$ is the discrete Laplacian with Neumann boundary conditions, and $\\partial u^n/\\partial x$ is the discrete displacement gradient at time $t^n$.\n- Mechanics substep (backward Euler in time for the viscoelastic term, finite differences in space on the interior nodes with homogeneous Dirichlet boundaries for $u$):\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\nwhere $I$ is the identity on the interior nodes, $G_x$ is the discrete first-derivative operator, and $c^{*}$ is the concentration used by the mechanical substep: $c^{*} = c^{n+1}$ in the DM ordering and $c^{*} = c^n$ in the MD ordering. The stress at the end of the step is computed as\n$$\n\\sigma^{n+1} = E\\,\\varepsilon^{n+1} + \\eta\\,\\frac{\\varepsilon^{n+1} - \\varepsilon^n}{\\Delta t} - E\\,\\alpha\\,\\tilde{c},\n$$\nwhere $\\varepsilon^n$ and $\\varepsilon^{n+1}$ are the discrete strain fields and $\\tilde{c}$ is the concentration consistent with the mechanical substep: $\\tilde{c} = c^{n+1}$ for DM and $\\tilde{c} = c^n$ for MD.\n\nQuantities of interest and monotonicity tests:\n- State-of-charge (SOC) is the spatial integral of $c$ over $[0,L]$, computed by the composite trapezoid rule. Its discrete time series must be tested for monotonic nondecreasing behavior.\n- Stress peak is the maximum absolute stress over the spatial grid at the end of each time step. Its discrete time series must be tested for monotonic nondecreasing behavior.\n\nYour tasks:\n1. Implement the described operator-splitting scheme for both DM and MD orderings using the provided parameters in each test case.\n2. For each test case, compute two boolean results for SOC monotonicity (DM then MD) and two boolean results for peak stress monotonicity (DM then MD).\n3. Produce a single line of output containing the results for all test cases as a comma-separated list of case results, where each case result is a list of four booleans in the order $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$.\n\nTest suite:\n- Case 1 (happy path): $N=50$, $L=1$, $D=0.01$, $\\alpha=0.1$, $E=1$, $\\eta=0.05$, $k_f=5$, $\\chi=0.5$, $J_{\\text{in}}=1$, $\\Delta t=5\\times 10^{-4}$, $N_t=200$.\n- Case 2 (aggressive coupling near stability): $N=50$, $L=1$, $D=0.05$, $\\alpha=0.1$, $E=1$, $\\eta=0.2$, $k_f=10$, $\\chi=1.0$, $J_{\\text{in}}=2$, $\\Delta t=2\\times 10^{-3}$, $N_t=200$.\n- Case 3 (no coupling): $N=50$, $L=1$, $D=0.02$, $\\alpha=0.1$, $E=1$, $\\eta=0.1$, $k_f=5$, $\\chi=0.0$, $J_{\\text{in}}=1$, $\\Delta t=10^{-3}$, $N_t=200$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of the case results, each in the format $[\\text{SOC}_{\\text{DM}}, \\text{SOC}_{\\text{MD}}, \\text{Stress}_{\\text{DM}}, \\text{Stress}_{\\text{MD}}]$, with boolean entries, and the overall list enclosed in square brackets. For example: $[[\\text{True},\\text{True},\\text{True},\\text{True}],[\\dots],[\\dots]]$.",
            "solution": "The model starts from mass conservation of the lithium concentration and a modified Fickian flux that includes a stress-gradient term. The flux is defined as $J = -D\\left(\\partial c/\\partial x - \\chi\\,\\partial \\sigma/\\partial x\\right)$, so mass conservation yields\n$$\n\\frac{\\partial c}{\\partial t} = -\\frac{\\partial J}{\\partial x} = \\frac{\\partial}{\\partial x}\\left[D\\,\\frac{\\partial c}{\\partial x} - D\\,\\chi\\,\\frac{\\partial \\sigma}{\\partial x}\\right].\n$$\nThe mechanical model uses Kelvin–Voigt viscoelasticity with a chemical expansion term and a Winkler foundation. Stress is $\\sigma = E\\,\\varepsilon + \\eta\\,\\partial \\varepsilon/\\partial t - E\\,\\alpha\\,c$, and mechanical equilibrium imposes $\\partial \\sigma/\\partial x - k_f\\,u = 0$. Differentiating the constitutive equation and applying equilibrium gives\n$$\n\\frac{\\partial}{\\partial x}\\Big(E\\,\\frac{\\partial u}{\\partial x} + \\eta\\,\\frac{\\partial}{\\partial t}\\left(\\frac{\\partial u}{\\partial x}\\right) - E\\,\\alpha\\,c\\Big) - k_f\\,u = 0,\n$$\nwhich is linear, second order in space for the displacement but includes a first-order time derivative term via the viscous contribution. Importantly, equilibrium implies $\\partial \\sigma/\\partial x = k_f\\,u$ for the full stress (including the viscous term). Substituting this into the diffusion equation simplifies the coupling to the displacement gradient:\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^2 c}{\\partial x^2} - D\\,\\chi\\,k_f\\,\\frac{\\partial u}{\\partial x}.\n$$\n\nBoundary conditions for concentration are expressed via the flux definition. At $x=0$, $J(0,t) = J_{\\text{in}}$ and at $x=L$, $J(L,t) = 0$. With clamped mechanics, $u(0,t) = 0$ and $u(L,t) = 0$, hence $\\partial \\sigma/\\partial x(0,t) = k_f\\,u(0,t) = 0$ and $\\partial \\sigma/\\partial x(L,t) = k_f\\,u(L,t) = 0$. Therefore the flux conditions reduce to Neumann conditions for $c$: $-D\\,\\partial c/\\partial x(0,t) = J_{\\text{in}}$ and $-D\\,\\partial c/\\partial x(L,t) = 0$. Initial conditions are $c(x,0)=0$ and $u(x,0)=0$.\n\nSpatial discretization uses a uniform grid with $N$ nodes and spacing $\\Delta x = L/(N-1)$. The discrete Laplacian for the diffusion equation incorporates Neumann boundary conditions via ghost points. At $x=0$ with known gradient $g_0 = \\partial c/\\partial x(0) = -J_{\\text{in}}/D$, a ghost value is $c_{-1} = c_1 - 2\\,\\Delta x\\,g_0$, and at $x=L$ with $g_L = 0$, a ghost value is $c_N = c_{N-2} + 2\\,\\Delta x\\,g_L = c_{N-2}$. The discrete Laplacian at node $i$ is then $(c_{i-1} - 2 c_i + c_{i+1})/\\Delta x^2$ with ghost handling at the boundaries. The displacement gradient is computed with central differences in the interior and one-sided differences at the boundaries consistent with clamped values.\n\nTime discretization uses operator splitting:\n- Diffusion substep is explicit Euler:\n$$\nc^{n+1} = c^n + \\Delta t\\left( D\\,\\Delta_x c^n - D\\,\\chi\\,k_f\\,\\frac{\\partial u^n}{\\partial x}\\right).\n$$\nThis incorporates the Neumann boundary flux through the ghost-point construction in $\\Delta_x c^n$.\n\n- Mechanics substep is backward Euler in time applied to the viscoelastic term with finite differences in space. On interior nodes (excluding boundaries where $u$ is specified), define the discrete Laplacian operator $\\Delta_x$ as the tri-diagonal matrix with entries $1/\\Delta x^2$ on the sub- and super-diagonals and $-2/\\Delta x^2$ on the main diagonal. The backward Euler discretization yields the linear system\n$$\n\\left(\\frac{\\eta}{\\Delta t}\\,\\Delta_x + E\\,\\Delta_x - k_f\\,I\\right)u^{n+1} = \\frac{\\eta}{\\Delta t}\\,\\Delta_x u^n + E\\,\\alpha\\,G_x\\,c^{*},\n$$\nwhere $G_x$ is the centered-difference first-derivative operator on interior nodes, and $I$ is the identity. The choice of $c^{*}$ depends on the splitting order:\n  - For Diffusion–Mechanics (DM), $c^{*} = c^{n+1}$, meaning mechanics responds to the updated concentration within the time step.\n  - For Mechanics–Diffusion (MD), $c^{*} = c^n$, meaning mechanics responds to the previous concentration. The diffusion update uses the newly computed displacement field $u^{n+1}$.\n\nThe stress at the end of the time step is computed as\n$$\n\\sigma^{n+1}(x) = E\\,\\varepsilon^{n+1}(x) + \\eta\\,\\frac{\\varepsilon^{n+1}(x) - \\varepsilon^n(x)}{\\Delta t} - E\\,\\alpha\\,\\tilde{c}(x),\n$$\nwhere $\\varepsilon^n = \\partial u^n/\\partial x$ and $\\varepsilon^{n+1} = \\partial u^{n+1}/\\partial x$ are computed by finite differences, and $\\tilde{c}$ is chosen consistent with the mechanical substep: $\\tilde{c} = c^{n+1}$ for DM and $\\tilde{c} = c^n$ for MD. This choice isolates the effect of operator ordering on the stress evaluation, which is a key element in assessing monotonicity under splitting.\n\nThe state-of-charge (SOC) is the spatial integral of $c$ over $[0,L]$, computed numerically by the trapezoidal rule:\n$$\n\\text{SOC}^{n} \\approx \\int_0^L c(x,t^n)\\,\\mathrm{d}x \\approx \\sum_{i=0}^{N-1} w_i\\,c_i^n\\,\\Delta x,\n$$\nwhere $w_0 = w_{N-1} = \\tfrac{1}{2}$ and $w_i = 1$ otherwise. The stress peak is $\\max_i |\\sigma_i^n|$. Monotonicity for a discrete sequence $\\{y^n\\}$ is checked by verifying $y^{n+1} \\ge y^n$ within a small numerical tolerance for all $n$.\n\nAlgorithm outline per test case:\n1. Initialize arrays for $c$, $u$, and the previous strain field to zeros.\n2. For each time step:\n   - DM ordering:\n     a. Compute $\\Delta_x c^n$ with Neumann boundary conditions and $\\partial u^n/\\partial x$; update $c^{n+1}$.\n     b. Assemble and solve the linear system for $u^{n+1}$ using $c^{n+1}$ in the forcing term.\n     c. Compute $\\varepsilon^{n+1}$ and $\\sigma^{n+1}$ using $c^{n+1}$.\n     d. Update SOC and peak stress sequences.\n   - MD ordering:\n     a. Assemble and solve the linear system for $u^{n+1}$ using $c^n$.\n     b. Compute $\\partial u^{n+1}/\\partial x$ and update $c^{n+1}$ using this displacement gradient.\n     c. Compute $\\varepsilon^{n+1}$ and $\\sigma^{n+1}$ using $c^n$ (consistent with the mechanical substep).\n     d. Update SOC and peak stress sequences.\n3. After $N_t$ steps, test monotonicity of the SOC and peak stress sequences for both orderings.\n\nDesign considerations:\n- The explicit diffusion step with coupling term has a stability constraint similar to the pure diffusion case, $\\Delta t \\lesssim \\Delta x^2/(2D)$; the chosen test cases respect this approximately, while Case 2 probes stronger coupling near the stability limit to examine sensitivity to ordering.\n- The backward Euler mechanics substep ensures numerical stability for the viscoelastic model by treating the viscous contribution implicitly.\n- Clamped mechanical boundaries lead to nonuniform displacement and stress fields under spatially varying $c$, and the Winkler foundation introduces a distributed restoring force that produces nonzero stress gradients, thereby enabling chemo-mechanical coupling in the diffusion equation.\n- Monotonicity is evaluated with a small tolerance to avoid false negatives due to floating-point roundoff.\n\nThe final program executes the three specified test cases, applies both DM and MD operator orderings, computes the monotonicity booleans for SOC and stress peaks, and prints a single-line result in the required format.",
            "answer": "```python\nimport numpy as np\n\ndef is_nondecreasing(seq, tol=1e-10):\n    return all(seq[i+1] >= seq[i] - tol for i in range(len(seq)-1))\n\ndef laplacian_c_neumann(c, dx, D, J_in):\n    # Neumann BCs: -D * dc/dx(0) = J_in => dc/dx(0) = -J_in / D\n    # and -D * dc/dx(L) = 0 => dc/dx(L) = 0\n    g0 = -J_in / D\n    gL = 0.0\n    n = len(c)\n    lap = np.zeros_like(c)\n    # Ghost values\n    c_left = c[1] - 2.0 * dx * g0\n    c_right = c[n-2] + 2.0 * dx * gL\n    # Left boundary\n    lap[0] = (c_left - 2.0 * c[0] + c[1]) / (dx * dx)\n    # Interior\n    for i in range(1, n-1):\n        lap[i] = (c[i-1] - 2.0 * c[i] + c[i+1]) / (dx * dx)\n    # Right boundary\n    lap[n-1] = (c[n-2] - 2.0 * c[n-1] + c_right) / (dx * dx)\n    return lap\n\ndef grad_u(u, dx):\n    n = len(u)\n    du_dx = np.zeros_like(u)\n    # Left boundary one-sided (u[0] = 0)\n    du_dx[0] = (u[1] - u[0]) / dx\n    # Interior central difference\n    for i in range(1, n-1):\n        du_dx[i] = (u[i+1] - u[i-1]) / (2.0 * dx)\n    # Right boundary one-sided (u[n-1] = 0)\n    du_dx[n-1] = (u[n-1] - u[n-2]) / dx\n    return du_dx\n\ndef build_mechanics_matrices(N, dx, E, eta, kf, dt):\n    # Interior nodes: indices 1..N-2, size Ni = N-2\n    Ni = N - 2\n    # Discrete Laplacian on interior with homogeneous Dirichlet boundaries\n    main = (-2.0 / (dx*dx)) * np.ones(Ni)\n    off = (1.0 / (dx*dx)) * np.ones(Ni - 1)\n    L = np.zeros((Ni, Ni))\n    np.fill_diagonal(L, main)\n    np.fill_diagonal(L[1:], off)\n    np.fill_diagonal(L[:,1:], off)\n    I = np.eye(Ni)\n    A = (eta / dt) * L + E * L - kf * I\n    return A, L\n\ndef grad_c_interior(c, dx):\n    # Gradient at interior nodes 1..N-2\n    n = len(c)\n    Ni = n - 2\n    gc = np.zeros(Ni)\n    for j in range(1, n-1):\n        gc[j-1] = (c[j+1] - c[j-1]) / (2.0 * dx)\n    return gc\n\ndef trapezoid_integral(y, dx):\n    # Composite trapezoid rule on uniform grid\n    return dx * (0.5 * y[0] + np.sum(y[1:-1]) + 0.5 * y[-1])\n\ndef run_case(N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt):\n    dx = L / (N - 1)\n    # Prebuild mechanics matrices\n    A, Lmat = build_mechanics_matrices(N, dx, E, eta, kf, dt)\n    # Initialize fields\n    c_DM = np.zeros(N)\n    u_DM = np.zeros(N)\n    strain_prev_DM = np.zeros(N)  # previous strain for viscous term\n    soc_series_DM = []\n    stresspeak_series_DM = []\n\n    c_MD = np.zeros(N)\n    u_MD = np.zeros(N)\n    strain_prev_MD = np.zeros(N)\n    soc_series_MD = []\n    stresspeak_series_MD = []\n\n    # Time stepping\n    for n in range(Nt):\n        # ---------------- DM: Diffusion then Mechanics ----------------\n        # Diffusion update using u at time n\n        du_dx_DM = grad_u(u_DM, dx)\n        lap_c_DM = laplacian_c_neumann(c_DM, dx, D, J_in)\n        c_DM_next = c_DM + dt * (D * lap_c_DM - D * chi * kf * du_dx_DM)\n\n        # Mechanics update using updated concentration c_DM_next\n        u_int_DM = u_DM[1:-1]\n        rhs_DM = (eta / dt) * (Lmat @ u_int_DM) + E * alpha * grad_c_interior(c_DM_next, dx)\n        u_int_new_DM = np.linalg.solve(A, rhs_DM)\n        u_DM_next = np.zeros(N)\n        u_DM_next[1:-1] = u_int_new_DM\n\n        # Compute strain and stress\n        strain_DM = grad_u(u_DM_next, dx)\n        sigma_DM = E * strain_DM + eta * (strain_DM - strain_prev_DM) / dt - E * alpha * c_DM_next\n        strain_prev_DM = strain_DM.copy()\n        u_DM = u_DM_next.copy()\n        c_DM = c_DM_next.copy()\n\n        # SOC and stress peak\n        soc_DM = trapezoid_integral(c_DM, dx)\n        stresspeak_DM = float(np.max(np.abs(sigma_DM)))\n        soc_series_DM.append(soc_DM)\n        stresspeak_series_DM.append(stresspeak_DM)\n\n        # ---------------- MD: Mechanics then Diffusion ----------------\n        # Mechanics update using c_MD (at time n)\n        u_int_MD = u_MD[1:-1]\n        rhs_MD = (eta / dt) * (Lmat @ u_int_MD) + E * alpha * grad_c_interior(c_MD, dx)\n        u_int_new_MD = np.linalg.solve(A, rhs_MD)\n        u_MD_next = np.zeros(N)\n        u_MD_next[1:-1] = u_int_new_MD\n        \n        # Consistent c for stress: c_tilde is c_MD at time n\n        c_tilde_MD = c_MD.copy()\n        \n        # Diffusion update using updated displacement u_MD_next\n        du_dx_MD = grad_u(u_MD_next, dx)\n        lap_c_MD = laplacian_c_neumann(c_MD, dx, D, J_in)\n        c_MD_next = c_MD + dt * (D * lap_c_MD - D * chi * kf * du_dx_MD)\n\n        # Compute strain and stress; stress uses c_MD at time n (mechanical substep input)\n        strain_MD = grad_u(u_MD_next, dx)\n        sigma_MD = E * strain_MD + eta * (strain_MD - strain_prev_MD) / dt - E * alpha * c_tilde_MD\n        \n        # Store current state for next step\n        strain_prev_MD = strain_MD.copy()\n        u_MD = u_MD_next.copy()\n        c_MD = c_MD_next.copy()\n\n        # SOC and stress peak\n        soc_MD = trapezoid_integral(c_MD, dx)\n        stresspeak_MD = float(np.max(np.abs(sigma_MD)))\n        soc_series_MD.append(soc_MD)\n        stresspeak_series_MD.append(stresspeak_MD)\n\n    # Monotonicity checks\n    soc_DM_monotone = is_nondecreasing(soc_series_DM)\n    soc_MD_monotone = is_nondecreasing(soc_series_MD)\n    stress_DM_monotone = is_nondecreasing(stresspeak_series_DM)\n    stress_MD_monotone = is_nondecreasing(stresspeak_series_MD)\n\n    return soc_DM_monotone, soc_MD_monotone, stress_DM_monotone, stress_MD_monotone\n\ndef solve():\n    # Define test cases from the problem statement\n    test_cases = [\n        # (N, L, D, alpha, E, eta, kf, chi, J_in, dt, Nt)\n        (50, 1.0, 0.01, 0.1, 1.0, 0.05, 5.0, 0.5, 1.0, 5e-4, 200),\n        (50, 1.0, 0.05, 0.1, 1.0, 0.2, 10.0, 1.0, 2.0, 2e-3, 200),\n        (50, 1.0, 0.02, 0.1, 1.0, 0.1, 5.0, 0.0, 1.0, 1e-3, 200),\n    ]\n\n    results_str_items = []\n    for case in test_cases:\n        socDM, socMD, stressDM, stressMD = run_case(*case)\n        # Build a compact string representation without spaces\n        case_str = f\"[{str(socDM).lower()},{str(socMD).lower()},{str(stressDM).lower()},{str(stressMD).lower()}]\"\n        results_str_items.append(case_str)\n\n    print(f\"[{','.join(results_str_items)}]\")\n\nsolve()\n```"
        }
    ]
}