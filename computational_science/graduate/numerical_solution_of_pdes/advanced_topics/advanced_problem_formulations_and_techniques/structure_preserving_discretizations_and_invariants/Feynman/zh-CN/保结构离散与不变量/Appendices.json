{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习是一项基础性训练。我们将通过研究最简单的守恒律——线性平流方程，来理解“守恒”数值格式是如何构建的 。通过推导离散总质量的演化，你将从解析上证明这类格式如何保证守恒量的守恒性，这一性质对于精确模拟物理系统至关重要。",
            "id": "3450230",
            "problem": "考虑在周期性区域 $[0, 2\\pi]$ 上的线性平流偏微分方程 (PDE) $u_{t} + (a u)_{x} = 0$，其中平流速度 $a \\in \\mathbb{R}$ 为常数。设该区域被划分为 $N \\in \\mathbb{N}$ 个宽度为 $h = \\frac{2\\pi}{N}$ 的均匀控制体积，其单元中心为 $x_{i} = \\left(i + \\frac{1}{2}\\right) h$，其中 $i = 0, 1, \\dots, N-1$。并用 $u_{i}^{n}$ 表示在时间层 $t^{n} = n \\,\\Delta t$ 时 $u$ 在单元 $i$ 上的单元平均值的近似值，其中 $\\Delta t > 0$ 是一个固定的时间步长。\n\n从该偏微分方程的积分守恒形式和守恒通量的定义出发，在每个单元交界面 $x_{i+1/2} = x_{i} + \\frac{h}{2}$ 处构造一个数值通量 $F_{i+1/2}$。该数值通量需与物理通量 $f(u) = a u$ 相容，并能导出一个守恒的全离散有限体积更新格式。然后，利用周期性边界条件和您得到的离散更新格式，推导离散质量\n$$\nM^{n} = h \\sum_{i=0}^{N-1} u_{i}^{n}\n$$\n的演化规律，并确定 $M^{n}$ 是否不随 $n$ 变化。\n\n最后，考虑正弦初始条件\n$$\nu_{i}^{0} = \\sin\\!\\big(m x_{i}\\big)\n$$\n其中 $m \\in \\mathbb{N}$，并显式地计算所有 $n \\geq 0$ 的 $M^{n}$ 的值，结果为一个实数。假设 $N \\geq 1$ 是任意但固定的，并且时间积分使用与您构造的通量相容的单步显式方法。最终答案请勿带单位。无需四舍五入，请给出精确值。",
            "solution": "该问题是适定的且有科学依据，是偏微分方程数值方法分析中的一个标准练习。所有数据和条件都足以得到唯一解。\n\n线性平流方程为 $u_{t} + (a u)_{x} = 0$，可以写成守恒律形式 $u_{t} + f(u)_{x} = 0$，其中物理通量为 $f(u) = a u$。\n\n我们首先应用有限体积法。将该偏微分方程在控制体积 $C_{i} = [x_{i-1/2}, x_{i+1/2}]$ 上从时间 $t^{n}$ 到 $t^{n+1}$ 进行积分，得到：\n$$\n\\int_{t^{n}}^{t^{n+1}} \\int_{x_{i-1/2}}^{x_{i+1/2}} u_{t} \\,dx\\,dt + \\int_{t^{n}}^{t^{n+1}} \\int_{x_{i-1/2}}^{x_{i+1/2}} (a u)_{x} \\,dx\\,dt = 0\n$$\n两次应用微积分基本定理，得到：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( u(x, t^{n+1}) - u(x, t^{n}) \\right) \\,dx + \\int_{t^{n}}^{t^{n+1}} \\left( f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right) \\,dt = 0\n$$\n令 $u_{i}(t) = \\frac{1}{h} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, t) \\,dx$ 为 $u$ 在单元 $C_i$ 上的精确单元平均值。方程变为：\n$$\nh \\left( u_{i}(t^{n+1}) - u_{i}(t^{n}) \\right) + \\int_{t^{n}}^{t^{n+1}} \\left( f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right) \\,dt = 0\n$$\n通过用 $u_i^n$ 近似单元平均值 $u_i(t^n)$，并用 $\\Delta t$ 乘以在时间 $t^n$ 计算的数值通量差来近似通量差的时间积分，我们得到了一个全离散有限体积格式。数值通量 $F_{i+1/2}$ 是一个在单元交界面 $x_{i+1/2}$ 处近似物理通量 $f(u)$ 的函数。为使格式守恒，它必须能表示为以下形式：\n$$\nu_{i}^{n+1} = u_{i}^{n} - \\frac{\\Delta t}{h} \\left( F_{i+1/2}^{n} - F_{i-1/2}^{n} \\right)\n$$\n其中 $F_{i+1/2}^{n}$ 是在时间 $t^n$ 时交界面 $x_{i+1/2}$ 处的数值通量。该通量使用相邻单元的单元平均数据（例如，$u_{i}^{n}$ 和 $u_{i+1}^{n}$）计算。为使该通量与物理通量 $f(u) = a u$ 相容，它必须满足 $F(u, u, \\dots) = f(u) = a u$。\n问题不要求指定通量的确切形式（例如，迎风格式、Lax-Friedrichs 格式等），只要求它是相容的并且是一个守恒更新法则的一部分。质量守恒的分析仅依赖于更新的守恒形式和周期性边界条件。\n\n在时间 $t^{n}$ 的总离散质量定义为 $M^{n} = h \\sum_{i=0}^{N-1} u_{i}^{n}$。\n为了找到 $M^{n}$ 的演化规律，我们计算 $M^{n+1}$：\n$$\nM^{n+1} = h \\sum_{i=0}^{N-1} u_{i}^{n+1}\n$$\n代入 $u_{i}^{n+1}$ 的守恒更新公式：\n$$\nM^{n+1} = h \\sum_{i=0}^{N-1} \\left[ u_{i}^{n} - \\frac{\\Delta t}{h} \\left( F_{i+1/2}^{n} - F_{i-1/2}^{n} \\right) \\right]\n$$\n分配求和：\n$$\nM^{n+1} = h \\sum_{i=0}^{N-1} u_{i}^{n} - \\Delta t \\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{n} - F_{i-1/2}^{n} \\right)\n$$\n第一项恰好是时间 $t^n$ 时的质量 $M^n$。第二项是一个裂项求和：\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{n} - F_{i-1/2}^{n} \\right) = (F_{1/2}^{n} - F_{-1/2}^{n}) + (F_{3/2}^{n} - F_{1/2}^{n}) + \\dots + (F_{N-1/2}^{n} - F_{N-3/2}^{n})\n$$\n求和裂项相消后得到 $F_{N-1/2}^{n} - F_{-1/2}^{n}$。\n问题指定了在区域 $[0, 2\\pi]$ 上的周期性边界条件。单元的索引从 $i=0$ 到 $i=N-1$。周期性意味着单元 $i=N$ 的状态与单元 $i=0$ 的状态相同，而单元 $i=-1$ 的状态与单元 $i=N-1$ 的状态相同。\n数值通量 $F_{i+1/2}^n$ 是交界面 $x_{i+1/2}$ 周围单元状态的函数，通常是 $u_i^n$ 和 $u_{i+1}^n$。也就是说，$F_{i+1/2}^n = F(u_i^n, u_{i+1}^n)$。\n区域右边界的通量为 $F_{N-1/2}^n = F(u_{N-1}^n, u_N^n)$。由于周期性，$u_N^n = u_0^n$，因此 $F_{N-1/2}^n = F(u_{N-1}^n, u_0^n)$。\n区域左边界的通量，对应于单元 $i=0$ 的左边缘，是 $F_{-1/2}^n = F(u_{-1}^n, u_0^n)$。由于周期性，$u_{-1}^n = u_{N-1}^n$，因此 $F_{-1/2}^n = F(u_{N-1}^n, u_0^n)$。\n因此，由于周期性边界条件，$F_{N-1/2}^{n} = F_{-1/2}^{n}$。\n裂项求和的计算结果为零：\n$$\n\\sum_{i=0}^{N-1} \\left( F_{i+1/2}^{n} - F_{i-1/2}^{n} \\right) = F_{N-1/2}^{n} - F_{-1/2}^{n} = 0\n$$\n因此，离散质量的演化规律是：\n$$\nM^{n+1} = M^{n} - \\Delta t \\cdot 0 = M^{n}\n$$\n这表明离散质量 $M^{n}$ 是该数值格式的一个不变量。这意味着对于所有 $n \\geq 0$，$M^{n}$ 是恒定的，其值由初始条件决定，$M^{n} = M^{0}$。\n\n我们现在计算给定初始条件 $u_{i}^{0} = \\sin(m x_{i})$（其中 $m \\in \\mathbb{N}$）下的 $M^{0}$ 的值。\n$$\nM^{0} = h \\sum_{i=0}^{N-1} u_{i}^{0} = h \\sum_{i=0}^{N-1} \\sin(m x_{i})\n$$\n代入 $x_{i}$ 和 $h$ 的定义：\n$x_{i} = \\left(i + \\frac{1}{2}\\right) h$ 和 $h = \\frac{2\\pi}{N}$。\n$$\nM^{0} = \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} \\sin\\left(m \\left(i + \\frac{1}{2}\\right) \\frac{2\\pi}{N}\\right) = \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} \\sin\\left(\\frac{2\\pi m i}{N} + \\frac{\\pi m}{N}\\right)\n$$\n为了计算这个和，我们使用欧拉公式 $\\sin(\\theta) = \\operatorname{Im}(\\exp(j \\theta))$，其中 $j^2=-1$。\n令 $S = \\sum_{i=0}^{N-1} \\exp\\left(j \\left(\\frac{2\\pi m i}{N} + \\frac{\\pi m}{N}\\right)\\right)$。正弦和是 $\\operatorname{Im}(S)$。\n$$\nS = \\sum_{i=0}^{N-1} \\exp\\left(j \\frac{2\\pi m i}{N}\\right) \\exp\\left(j \\frac{\\pi m}{N}\\right) = \\exp\\left(j \\frac{\\pi m}{N}\\right) \\sum_{i=0}^{N-1} \\left(\\exp\\left(j \\frac{2\\pi m}{N}\\right)\\right)^{i}\n$$\n这是一个公比为 $r = \\exp(j \\frac{2\\pi m}{N})$ 的等比级数。\n\n情况1：$m$ 是 $N$ 的倍数。\n令 $m = k N$，其中 $k \\in \\mathbb{N}$ 为某个整数。那么 $r = \\exp(j \\frac{2\\pi k N}{N}) = \\exp(j 2\\pi k) = 1$。\n该和变为 $\\sum_{i=0}^{N-1} 1^{i} = N$。\n在这种情况下，$S = \\exp(j \\frac{\\pi k N}{N}) \\cdot N = N \\exp(j \\pi k) = N (\\cos(k\\pi) + j\\sin(k\\pi)) = N(-1)^{k}$。\n由于 $S$ 是一个实数，其虚部为 $\\operatorname{Im}(S) = 0$。\n\n情况2：$m$ 不是 $N$ 的倍数。\n在这种情况下，$r \\neq 1$。等比级数的和为 $\\frac{1-r^{N}}{1-r}$。\n项 $r^{N}$ 为：\n$$\nr^{N} = \\left(\\exp\\left(j \\frac{2\\pi m}{N}\\right)\\right)^{N} = \\exp(j 2\\pi m) = 1\n$$\n因为 $m$ 是一个整数。分子是 $1 - 1 = 0$，所以级数的和为 $0$。\n那么 $S = \\exp(j \\frac{\\pi m}{N}) \\cdot 0 = 0$。\n虚部为 $\\operatorname{Im}(S) = 0$。\n\n在这两种情况下，正弦项的和都为 $0$。\n$$\n\\sum_{i=0}^{N-1} \\sin\\left(m \\left(i + \\frac{1}{2}\\right) \\frac{2\\pi}{N}\\right) = 0\n$$\n因此，初始质量为：\n$$\nM^{0} = h \\cdot 0 = 0\n$$\n由于离散质量是不变的，所以对所有 $n \\geq 0$ 都有 $M^{n} = M^{0}$。我们得出结论，对所有 $n \\geq 0$ 都有 $M^{n} = 0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在离散守恒概念的基础上，本实践将处理非线性的粘性伯格斯方程 (viscous Burgers' equation)，这是一个以形成激波而闻名的模型 。你将实现并比较守恒与非守恒格式，亲眼见证为何守恒形式对于捕捉正确的物理行为至关重要。这种动手比较将突显在质量守恒和能量平衡方面的显著差异，为在计算物理中使用保结构方法提供了有力的论据。",
            "id": "3450238",
            "problem": "考虑周期性域 $[0,2\\pi]$ 上的粘性伯格斯偏微分方程，\n$$ u_t + \\frac{1}{2}(u^2)_x = \\nu u_{xx}, $$\n初始条件为 $u(x,0)=\\sin(x)$，粘性参数 $\\nu>0$。重点是数值比较两种平流项空间离散化方法在激波主导和光滑区域下的表现，并量化它们在质量守恒、能量平衡和熵产生方面的差异。比较必须在一致的时间积分框架和周期性边界条件下进行。\n\n平流项有两种空间离散化选择：\n\n- 使用单调数值通量对物理通量 $f(u)=\\frac{1}{2}u^2$ 进行守恒型有限体积离散化，有两种重构选择：\n  1. 分段常数重构（一阶）。\n  2. 使用 minmod 斜率限制器的分段线性重构（MUSCL）。\n- 对非守恒形式 $-u\\,u_x$ 中的平流项进行非守恒型有限差分离散化，其中 $u_x$ 由中心差分近似。\n\n粘性项使用 $u_{xx}$ 的二阶中心差分近似进行离散化。时间积分必须使用两阶段强稳定性保持（SSP）龙格-库塔方法，并采用满足显式稳定性约束的恒定时间步长。\n\n推导的基本依据：\n- 对于足够光滑的解，粘性伯格斯方程在周期性边界条件下存在质量不变量，即空间积分 $M(t)=\\int_0^{2\\pi} u(x,t)\\,dx$ 随时间保持恒定。\n- 二次能量 $E(t)=\\int_0^{2\\pi}\\frac{1}{2}u(x,t)^2\\,dx$ 在周期性边界条件下满足以下平衡关系\n$$ \\frac{d}{dt}E(t) = -\\nu \\int_0^{2\\pi} u_x(x,t)^2\\,dx, $$\n这也是凸熵 $\\eta(u)=\\frac{1}{2}u^2$ 和熵通量 $q(u)=\\frac{1}{3}u^3$ 的熵不等式；特别地，熵产生是非负的，且等于 $\\nu\\int_0^{2\\pi}u_x^2\\,dx$。\n- 当与一致的数值通量和周期性边界条件一起使用时，平流项的守恒型离散化保持离散质量不变量，并满足离散熵平衡。非守恒型离散化通常不保持质量，并可能在激波附近破坏熵平衡。\n\n你必须设计并实现一个完整的程序，该程序：\n1. 用 $N$ 个均匀网格对空间域 $[0,2\\pi]$ 进行离散化，具有网格中心和周期性索引。\n2. 实现平流项的守恒型有限体积离散化，在网格面上使用 Engquist–Osher 单调通量计算 $f(u)=\\frac{1}{2}u^2$，并提供两种重构选择：\n   - 分段常数重构。\n   - 使用 minmod 斜率限制器的分段线性重构。minmod 限制器定义为\n     $$ \\operatorname{minmod}(a,b) = \\frac{1}{2}\\left(\\operatorname{sign}(a)+\\operatorname{sign}(b)\\right)\\min\\{|a|,|b|\\}。 $$\n     面 $i+\\frac{1}{2}$ 处的左右界面状态必须使用此限制性斜率从相邻网格的平均值重构。\n3. 实现 $-u\\,u_x$ 的非守恒型有限差分离散化，其中 $u_x$ 由中心差分近似\n   $$ (u_x)_i \\approx \\frac{u_{i+1}-u_{i-1}}{2\\Delta x}。 $$\n4. 用中心二阶差分对粘性项 $u_{xx}$ 进行离散化\n   $$ (u_{xx})_i \\approx \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}。 $$\n5. 使用两阶段强稳定性保持（SSP）龙格-库塔方法将解推进到最终时间 $T$，时间步长 $\\Delta t$ 为常数，其选择满足显式稳定性约束\n   $$ \\Delta t \\le C \\min\\left(\\frac{\\Delta x}{\\max|u|},\\frac{\\Delta x^2}{\\nu}\\right), $$\n   其中 $C=0.4$，并通过设置均匀步数和使用 $\\Delta t=T/\\text{steps}$ 来调整以精确达到 $T$。\n6. 在最终时间 $T$ 为每次运行计算以下诊断量：\n   - 离散质量 $M^n=\\Delta x\\sum_i u_i^n$ 和绝对质量误差 $|M^N - M^0|$。\n   - 离散能量 $E^n=\\Delta x\\sum_i \\frac{1}{2}(u_i^n)^2$。\n   - 时间积分熵产生的数值近似\n     $$ \\mathcal{D}_{\\text{num}} = \\nu \\int_0^T \\int_0^{2\\pi} u_x(x,t)^2\\,dx\\,dt, $$\n     通过将 $u_x$ 替换为 $u_x$ 的中心差分，并在每个时间步的每个 SSP 阶段内使用梯形法则计算。\n   - 能量平衡残差\n     $$ R = \\left(E^0 - E^N\\right) - \\mathcal{D}_{\\text{num}}, $$\n     以及指示能量单调性的布尔值 $E^N \\le E^0$。\n7. 在所有空间离散化中使用周期性边界条件。\n\n测试套件和覆盖范围：\n- 情况 1：守恒型平流离散化，分段常数重构，$N=256$，$\\nu=10^{-3}$，$T=0.4$。\n- 情况 2：守恒型平流离散化，带 minmod 限制器的分段线性 MUSCL 重构，$N=256$，$\\nu=10^{-3}$，$T=0.4$。\n- 情况 3：非守恒型平流离散化（$-u\\,u_x$），$N=256$，$\\nu=10^{-3}$，$T=0.4$。\n- 情况 4：在粗网格上进行非守恒型平流离散化，以测试激波附近欠分辨率的情况，$N=64$，$\\nu=10^{-3}$，$T=0.4$。\n- 情况 5：守恒型平流离散化，光滑区域下的分段常数重构，$N=128$，$\\nu=10^{-1}$，$T=0.4$。\n\n对于每种情况，你的程序必须计算并返回一个包含四个条目的列表，顺序如下：\n- 绝对质量误差 $|M^N - M^0|$，为一个浮点数。\n- 能量平衡残差 $R$，为一个浮点数。\n- 布尔能量单调性指示符，如果 $E^N \\le E^0$ 则为 $\\text{True}$，否则为 $\\text{False}$。\n- 数值熵产生 $\\mathcal{D}_{\\text{num}}$，为一个浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有情况的结果，形式为逗号分隔的列表，每个情况的结果列表都包含在方括号中，例如 $[\\,[m_1,r_1,b_1,d_1],\\,[m_2,r_2,b_2,d_2],\\,\\dots\\,]$。不允许有其他输出。角度不出现，也不需要物理单位，因此不需要单位说明。所有返回值必须是如上所述的基本类型（浮点数和布尔值）。",
            "solution": "该问题要求对粘性伯格斯方程 $u_t + \\frac{1}{2}(u^2)_x = \\nu u_{xx}$ 在周期性域 $[0, 2\\pi]$ 上、初始条件为 $u(x,0)=\\sin(x)$ 的几种数值格式进行实现和比较。比较的重点在于不同平流项空间离散化方法下的质量守恒、能量平衡和熵产生。\n\n首先，我们建立数值框架。空间域 $[0, 2\\pi]$ 被离散化为 $N$ 个均匀网格，宽度为 $\\Delta x = 2\\pi/N$。网格中心位于 $x_i = i \\Delta x$，其中 $i=0, \\dots, N-1$。解由网格平均值向量 $u = [u_0, u_1, \\dots, u_{N-1}]^T$ 表示。强制执行周期性边界条件，意味着索引按模 $N$ 处理。\n\nPDE 的半离散化形式是一个常微分方程（ODE）系统 $\\frac{d\\vec{u}}{dt} = \\vec{L}(\\vec{u})$，其中 $\\vec{L}$ 是空间算子。该算子是粘性部分和平流部分之和：$L(u)_i = L_{visc}(u)_i + L_{adv}(u)_i$。\n\n粘性项 $\\nu u_{xx}$ 使用标准的二阶中心有限差分近似进行离散化，这对所有测试用例都适用：\n$$ L_{visc}(u)_i = \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} $$\n周期性通过取 $u_{N}=u_0$ 和 $u_{-1}=u_{N-1}$ 来处理。\n\n平流项 $-\\frac{1}{2}(u^2)_x = -u u_x$ 按规定使用三种不同的方法进行离散化：\n\n1.  **非守恒型有限差分**：该项以其非守恒形式 $-u u_x$ 处理。空间导数 $u_x$ 由二阶中心差分近似：\n    $$ L_{adv}(u)_i = -u_i \\frac{u_{i+1} - u_{i-1}}{2\\Delta x} $$\n    该格式简单，但已知会违反质量守恒，这可能导致在弱解极限下出现不正确的激波速度。\n\n2.  **守恒型有限体积（分段常数）**：这种一阶格式基于守恒律的积分形式。网格 $i$ 的更新由其边界上的数值通量 $\\hat{f}_{i-1/2}$ 和 $\\hat{f}_{i+1/2}$ 驱动：\n    $$ L_{adv}(u)_i = -\\frac{1}{\\Delta x} (\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) $$\n    界面 $i+1/2$ 左右两侧的状态为 $u_L = u_i$ 和 $u_R = u_{i+1}$。使用 Engquist–Osher (EO) 单调通量来计算 $f(u)=\\frac{1}{2}u^2$。由于 $f'(u)=u$，通量根据 $u$ 的符号分裂。EO 通量为 $\\hat{f}^{EO}(u_L, u_R) = f^+(u_L) + f^-(u_R)$，其中如果 $u>0$ 则 $f^+(u) = f(u)$ 否则为 $0$，如果 $u \\le 0$ 则 $f^-(u) = f(u)$ 否则为 $0$。\n\n3.  **守恒型有限体积（MUSCL）**：这种二阶扩展在每个网格内使用分段线性重构以获得更高精度。使用 `minmod` 限制器计算每个网格的斜率 $\\delta_i$，以防止在陡峭梯度附近产生伪振荡：\n    $$ \\delta_i = \\operatorname{minmod}\\left(\\frac{u_{i+1}-u_i}{\\Delta x}, \\frac{u_i-u_{i-1}}{\\Delta x}\\right) $$\n    其中 $\\operatorname{minmod}(a,b) = \\frac{1}{2}(\\operatorname{sign}(a)+\\operatorname{sign}(b))\\min(|a|,|b|)$。界面 $i+1/2$ 处的重构状态为：\n    $$ u^L_{i+1/2} = u_i + \\delta_i \\frac{\\Delta x}{2}, \\quad u^R_{i+1/2} = u_{i+1} - \\delta_{i+1} \\frac{\\Delta x}{2} $$\n    然后，这些状态像之前一样用于 Engquist–Osher 通量计算。\n\n时间积分使用两阶段强稳定性保持（SSP）龙格-库塔方法（也称为休恩方法）进行：\n$$ u^{(1)} = u^n + \\Delta t L(u^n) $$\n$$ u^{n+1} = \\frac{1}{2}u^n + \\frac{1}{2}\\left(u^{(1)} + \\Delta t L(u^{(1)})\\right) $$\n时间步长 $\\Delta t$ 是恒定的，在模拟开始时选择以满足 CFL 稳定性条件 $\\Delta t \\le C \\min(\\frac{\\Delta x}{\\max|u|}, \\frac{\\Delta x^2}{\\nu})$，其中 $C=0.4$。由于粘性伯格斯方程满足最大值原理，任何时刻的 $\\max|u|$ 都受其初始最大值的限制。计算步数以精确达到最终时间 $T$。\n\n为评估每种格式的性能，计算了几个诊断量：\n-   **绝对质量误差**：$|M^N - M^0|$，其中离散质量为 $M^n = \\Delta x \\sum_i u_i^n$。对于具有周期性边界的连续 PDE，质量 $M(t)=\\int_0^{2\\pi} u(x,t) dx$ 是守恒的。对于初始条件 $u(x,0)=\\sin(x)$，初始质量为 $M^0=0$。\n-   **能量平衡残差**：$R = (E^0 - E^N) - \\mathcal{D}_{\\text{num}}$。离散能量为 $E^n = \\Delta x \\sum_i \\frac{1}{2}(u_i^n)^2$。连续能量平衡为 $\\frac{dE}{dt} = - \\nu \\int_0^{2\\pi} u_x^2 dx$。残差 $R$ 衡量数值格式保持此平衡的程度。$\\mathcal{D}_{\\text{num}}$ 是时间积分的数值熵产生，计算如下：\n    $$ \\mathcal{D}_{\\text{num}} = \\int_0^T \\left( \\nu \\Delta x \\sum_i \\left(\\frac{u_{i+1}(t)-u_{i-1}(t)}{2\\Delta x}\\right)^2 \\right) dt $$\n    这个时间积分使用与 SSP-RK2 积分器一致的求积规则进行近似，在每个时间步的两个阶段上应用梯形法则。\n-   **能量单调性**：一个布尔标志，指示是否 $E^N \\le E^0$，这符合连续能量平衡的预期。\n\n实现使用 NumPy 进行了向量化，其中周期性索引通过 `np.roll` 高效处理。一个主函数遍历五个指定的测试用例，为每个用例运行模拟，计算诊断量，并格式化输出。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef minmod(a, b):\n    \"\"\"\n    Implements the minmod function as defined in the problem.\n    minmod(a,b) = 1/2 * (sign(a) + sign(b)) * min(|a|,|b|)\n    This is zero if signs differ, and the value with smaller magnitude if signs are the same.\n    \"\"\"\n    sign_a = np.sign(a)\n    sign_b = np.sign(b)\n    return 0.5 * (sign_a + sign_b) * np.minimum(np.abs(a), np.abs(b))\n\ndef spatial_entropy_integrand(u, dx, nu):\n    \"\"\"\n    Computes the discrete spatial integral of nu * u_x^2.\n    The integral is approximated by a sum, where u_x is a centered difference.\n    integral(nu * u_x^2, dx) approx nu * sum( ( (u_{i+1}-u_{i-1})/(2*dx) )^2 * dx )\n    \"\"\"\n    u_xp = np.roll(u, -1)\n    u_xm = np.roll(u, 1)\n    ux = (u_xp - u_xm) / (2 * dx)\n    return nu * dx * np.sum(ux**2)\n\ndef rhs(u, dx, nu, method, recon):\n    \"\"\"\n    Calculates the right-hand side of the semi-discretized PDE: du/dt = L(u).\n    The operator L(u) is composed of advection and viscous terms.\n    \"\"\"\n    # Periodic shifts for finite differences\n    u_xp = np.roll(u, -1)\n    u_xm = np.roll(u, 1)\n    \n    # Viscous term (common to all methods)\n    # nu * u_xx approx nu * (u_{i+1} - 2u_i + u_{i-1}) / dx^2\n    viscous_term = nu * (u_xp - 2 * u + u_xm) / (dx**2)\n\n    # Advective term\n    if method == 'nonconservative':\n        # -u * u_x approx -u_i * (u_{i+1} - u_{i-1}) / (2*dx)\n        advective_term = u * (u_xp - u_xm) / (2 * dx)\n    elif method == 'conservative':\n        # Split flux functions for Engquist-Osher flux for f(u)=u^2/2\n        def f_plus(val):\n            return 0.5 * np.maximum(val, 0)**2\n\n        def f_minus(val):\n            return 0.5 * np.minimum(val, 0)**2\n\n        if recon == 'const':\n            # Piecewise constant reconstruction\n            u_L = u\n            u_R = u_xp # u_{i+1}\n        elif recon == 'muscl':\n            # MUSCL reconstruction with minmod limiter\n            slope_arg1 = (u - u_xm) / dx\n            slope_arg2 = (u_xp - u) / dx\n            slopes = minmod(slope_arg1, slope_arg2)\n            \n            # Reconstruct interface values from cell i (left) and i+1 (right)\n            u_L = u + slopes * dx / 2.0\n            u_R = u_xp - np.roll(slopes, -1) * dx / 2.0\n        else:\n            raise ValueError(f\"Unknown reconstruction method: {recon}\")\n\n        # Engquist-Osher numerical flux: F_hat(u_L, u_R) = f^+(u_L) + f^-(u_R)\n        flux_hat = f_plus(u_L) + f_minus(u_R)\n        \n        # Finite volume discretization: -(F_{i+1/2} - F_{i-1/2}) / dx\n        flux_hat_m = np.roll(flux_hat, 1)\n        advective_term = (flux_hat - flux_hat_m) / dx\n    else:\n        raise ValueError(f\"Unknown advection method: {method}\")\n\n    return viscous_term - advective_term\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the viscous Burgers' equation.\n    \"\"\"\n    test_cases = [\n        # (advection_method, reconstruction, N, nu, T)\n        ('conservative', 'const', 256, 1e-3, 0.4),\n        ('conservative', 'muscl', 256, 1e-3, 0.4),\n        ('nonconservative', None, 256, 1e-3, 0.4),\n        ('nonconservative', None, 64, 1e-3, 0.4),\n        ('conservative', 'const', 128, 1e-1, 0.4),\n    ]\n\n    results = []\n    for advection_method, reconstruction, N, nu, T in test_cases:\n        # 1. Setup grid and initial condition\n        dx = 2 * np.pi / N\n        x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n        u0 = np.sin(x)\n\n        # 2. Initial diagnostics\n        M0 = dx * np.sum(u0) # Should be ~0 due to symmetry\n        E0 = dx * np.sum(0.5 * u0**2)\n\n        # 3. Setup time stepping\n        # The maximum principle for viscous Burgers allows setting dt based on initial data.\n        max_u_abs = np.max(np.abs(u0))\n        if max_u_abs  1e-12: max_u_abs = 1.0 # Avoid division by zero\n        \n        CFL_const = 0.4\n        dt_adv = CFL_const * dx / max_u_abs\n        dt_visc = CFL_const * (dx**2) / nu\n        dt_max = min(dt_adv, dt_visc)\n        \n        num_steps = int(np.ceil(T / dt_max))\n        dt = T / num_steps\n        \n        # 4. Time integration loop\n        u = u0.copy()\n        D_num = 0.0\n\n        for _ in range(num_steps):\n            # Two-stage SSP Runge-Kutta (SSP-RK2 / Heun's method)\n            L_u = rhs(u, dx, nu, advection_method, reconstruction)\n            u_stage1 = u + dt * L_u\n            \n            # Accumulate numerical entropy production using quadrature consistent with SSP-RK2\n            g_u = spatial_entropy_integrand(u, dx, nu)\n            g_u_stage1 = spatial_entropy_integrand(u_stage1, dx, nu)\n            D_num += 0.5 * dt * (g_u + g_u_stage1)\n            \n            L_u_stage1 = rhs(u_stage1, dx, nu, advection_method, reconstruction)\n            u = 0.5 * u + 0.5 * (u_stage1 + dt * L_u_stage1)\n\n        # 5. Final diagnostics\n        uN = u\n        MN = dx * np.sum(uN)\n        EN = dx * np.sum(0.5 * uN**2)\n\n        mass_error = abs(MN - M0)\n        energy_residual = (E0 - EN) - D_num\n        energy_mono = bool(EN = E0)\n        \n        results.append([mass_error, energy_residual, energy_mono, D_num])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将注意力从守恒律转向另一类关键的物理模型：哈密顿系统 (Hamiltonian systems)。本练习探讨图上的薛定谔方程 (Schrödinger equation)，这是一个离散空间中量子动力学的模型 。你将实现一个基于经典几何积分算子——Cayley 变换的时间步进方法，并验证其精确保持总概率（$L^2$ 范数）和能量的能力，这正是量子演化的标志性特征。",
            "id": "3450219",
            "problem": "考虑一个有限无向图上的薛定谔动力学，其复振幅向量为 $\\psi(t) \\in \\mathbb{C}^n$，由线性方程 $i \\,\\dot{\\psi}(t) = L \\,\\psi(t)$ 控制，其中 $L \\in \\mathbb{R}^{n \\times n}$ 是一个对称的图拉普拉斯矩阵。对于一个具有对称邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的无向图，定义两种标准的拉普拉斯矩阵：未归一化拉普拉斯矩阵 $L_{\\mathrm{unn}} = D - A$，其中 $D = \\mathrm{diag}(d_0,\\dots,d_{n-1})$ 且 $d_j = \\sum_{k=0}^{n-1} A_{jk}$；以及对称归一化拉普拉斯矩阵 $L_{\\mathrm{sym}} = I - D^{-1/2} A D^{-1/2}$，其中对角矩阵 $D^{-1/2}$ 的分量定义为：当 $d_j  0$ 时，$(D^{-1/2})_{jj} = d_j^{-1/2}$；当 $d_j = 0$ 时，$(D^{-1/2})_{jj} = 0$。精确的连续时间演化保持离散勒贝格空间 ($L^2$) 范数 $\\|\\psi(t)\\|_2^2 = \\psi(t)^* \\psi(t)$ 和二次能量期望 $E(t) = \\psi(t)^* L \\,\\psi(t)$ 不变。\n\n您的任务是使用凯莱变换构建一种用于离散时间更新的幺正时间步进法，该方法能保持离散 $L^2$ 范数，并分析拉普拉斯矩阵归一化对能量谱的影响。对于一个固定的时间步长 $h  0$，考虑凯莱更新算子\n$$\nU_h(L) = \\big(I - i \\tfrac{h}{2} L\\big)^{-1} \\big(I + i \\tfrac{h}{2} L\\big),\n$$\n以及相关的更新 $\\psi^{n+1} = U_h(L)\\,\\psi^{n}$（从步骤 $n$ 到步骤 $n+1$）。已知当 $L$ 是自伴时，该方法是保范数的。您必须为 $L_{\\mathrm{unn}}$ 和 $L_{\\mathrm{sym}}$ 实现此方案，并通过多步迭代经验性地验证不变量。此外，您还应该计算并比较 $L_{\\mathrm{unn}}$ 和 $L_{\\mathrm{sym}}$ 的最小和最大特征值，以探究归一化如何影响能量谱。\n\n请使用以下测试套件，每个案例指定一个邻接矩阵 $A$、一个时间步长 $h$ 和步数 $M$。对于每个案例，通过 $\\psi^0_j = j + i (n - j)$ for $j = 0,1,\\dots,n-1$ 初始化 $\\psi^0 \\in \\mathbb{C}^n$，并重新缩放以使 $\\|\\psi^0\\|_2 = 1$。所有角度（若有使用）必须以弧度为单位。本问题不需要物理单位。\n\n测试套件：\n- 案例 $\\#1$ (路径图): $n = 5$，邻接项 $A_{j,j+1} = A_{j+1,j} = 1$ 对 $j = 0,1,2,3$ 成立，所有其他项为 $0$，其中 $h = 0.2$，$M = 20$。\n- 案例 $\\#2$ (星形图): $n = 6$，邻接项 $A_{0,k} = A_{k,0} = 1$ 对 $k = 1,2,3,4,5$ 成立，所有其他项为 $0$，其中 $h = 0.05$，$M = 100$。\n- 案例 $\\#3$ (加权环): $n = 5$，环上的边权重为 $w_0 = 1.0$, $w_1 = 2.0$, $w_2 = 0.5$, $w_3 = 1.5$, $w_4 = 1.0$，即 $A_{j,(j+1)\\bmod 5} = A_{(j+1)\\bmod 5,j} = w_j$ 对 $j=0,1,2,3,4$ 成立，其中 $h = 1.0$，$M = 10$。\n- 案例 $\\#4$ (含孤立节点的非连通图): $n = 4$，邻接项 $A_{0,1} = A_{1,0} = 1$，所有其他项为 $0$，其中 $h = 0.3$，$M = 30$。\n\n对于每个案例和每种拉普拉斯矩阵类型（$L_{\\mathrm{unn}}$ 和 $L_{\\mathrm{sym}}$）：\n- 计算范数 $\\|\\psi^n\\|_2$ 与其初始值 $\\|\\psi^0\\|_2$ 在 $n = 1,2,\\dots,M$ 上的最大绝对偏差，并返回一个布尔值，指示该偏差是否不大于 $10^{-12}$。\n- 计算能量期望 $\\psi^{n*} L \\psi^n$ 与其初始值 $\\psi^{0*} L \\psi^0$ 在 $n = 1,2,\\dots,M$ 上的最大绝对偏差，并返回一个布尔值，指示該偏差是否不大于 $10^{-12}$。\n- 计算并返回 $L$ 的最小和最大特征值（作为浮点数）。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的案例结果列表，每个案例结果本身是一个包含八个值的列表，顺序如下：\n[$L_{\\mathrm{unn}}$范数保持性, $L_{\\mathrm{unn}}$能量保持性, $L_{\\mathrm{sym}}$范数保持性, $L_{\\mathrm{sym}}$能量保持性, $\\min \\sigma(L_{\\mathrm{unn}})$, $\\max \\sigma(L_{\\mathrm{unn}})$, $\\min \\sigma(L_{\\mathrm{sym}})$, $\\max \\sigma(L_{\\mathrm{sym}})]$，\n其中保持性指标为布尔值，特征值极值为浮点数。例如，输出格式必须严格遵循以下形式：\n$[[$result\\_case\\_1$],[$result\\_case\\_2$],[$result\\_case\\_3$],[$result\\_case\\_4$]]$\n不得包含任何额外文本。",
            "solution": "该问题要求实现并分析一种求解图上薛定谔方程 $i \\,\\dot{\\psi}(t) = L \\,\\psi(t)$ 的数值方法，其中 $\\psi(t)$ 是复振幅向量，$L$ 是图拉普拉斯矩阵。分析的重点在于不变量的保持性以及兩種不同類型拉普拉斯矩阵（未归一化拉普拉斯矩阵 $L_{\\mathrm{unn}}$ 和对称归一化拉普拉斯矩阵 $L_{\\mathrm{sym}}$）的谱性质。\n\n首先，我们来确定连续系统和数值积分方法的理论性质。图拉普拉斯矩阵 $L$，无论是未归一化的还是对称归一化的，都是一个实对称矩阵。在量子力学背景下，它充当哈密顿算符，而哈密顿算符必须是自伴的。实对称矩阵确实是自伴的（$L^* = L^T = L$）。\n\n系统的时间演化由算子 $e^{-iLt}$ 控制，使得 $\\psi(t) = e^{-iLt}\\psi(0)$。由于 $L$ 是自伴的，演化算子 $e^{-iLt}$ 是幺正的。这一性质保证了离散 $L^2$-范数（总概率）的守恒：\n$$\n\\|\\psi(t)\\|_2^2 = \\psi(t)^* \\psi(t) = (e^{-iLt}\\psi(0))^* (e^{-iLt}\\psi(0)) = \\psi(0)^* (e^{-iLt})^* (e^{-iLt}) \\psi(0) = \\psi(0)^* e^{iLt} e^{-iLt} \\psi(0) = \\psi(0)^* \\psi(0) = \\|\\psi(0)\\|_2^2.\n$$\n第二个不变量是能量期望 $E(t) = \\psi(t)^* L \\psi(t)$。其守恒性可由薛定谔方程推导得出：\n$$\n\\frac{dE}{dt} = \\dot{\\psi}(t)^* L \\psi(t) + \\psi(t)^* L \\dot{\\psi}(t).\n$$\n代入 $\\dot{\\psi} = -iL\\psi$ 和 $\\dot{\\psi}^* = (-iL\\psi)^* = i\\psi^*L^* = i\\psi^*L$：\n$$\n\\frac{dE}{dt} = (i\\psi^*L) L \\psi(t) + \\psi(t)^* L (-iL\\psi(t)) = i\\psi^*L^2\\psi - i\\psi^*L^2\\psi = 0.\n$$\n因此，范数和能量都是连续时间动力学的精确不变量。\n\n问题提出使用凯莱变换进行从 $\\psi^n$ 到 $\\psi^{n+1}$ 的时间步进：\n$$\n\\psi^{n+1} = U_h(L) \\psi^n, \\quad \\text{其中} \\quad U_h(L) = \\big(I - i \\tfrac{h}{2} L\\big)^{-1} \\big(I + i \\tfrac{h}{2} L\\big).\n$$\n该数值格式是几何积分或保结构积分方法的一个例子。我们可以验证它保持了与连续系统相同的不变量。对于任何自伴的 $L$，算子 $U_h(L)$ 都是幺正的。一个矩阵 $U$ 是幺正的，如果 $U^*U=I$。令 $X = i \\frac{h}{2} L$。由于 $L$ 是自伴的，所以 $X$ 是反自伴的（$X^* = -X$）。\n$$\nU_h(L)^* = \\left( \\big(I - X\\big)^{-1} \\big(I + X\\big) \\right)^* = (I+X)^* ((I-X)^{-1})^* = (I+X^*) (I-X^*)^{-1} = (I-X)(I+X)^{-1}.\n$$\n然后，乘积 $U_h(L)^* U_h(L)$ 为：\n$$\n(I-X)(I+X)^{-1} (I-X)^{-1}(I+X).\n$$\n由于 $(I-X)^{-1}$ 和 $(I+X)^{-1}$ 是 $X$ 的有理函数，它们是可交换的。同样，$(I-X)$ 和 $(I+X)$ 也可交换。因此，我们可以重新排列这些项：\n$$\nU_h(L)^* U_h(L) = (I-X) (I-X)^{-1} (I+X)^{-1} (I+X) = I \\cdot I = I.\n$$\n$U_h(L)$ 的幺正性保证了离散更新能精确保持 $L^2$-范数（在机器精度范围内）：\n$$\n\\|\\psi^{n+1}\\|_2^2 = (\\psi^{n+1})^* \\psi^{n+1} = (U_h \\psi^n)^* (U_h \\psi^n) = (\\psi^n)^* U_h^* U_h \\psi^n = (\\psi^n)^* \\psi^n = \\|\\psi^n\\|_2^2.\n$$\n此外，离散能量 $E^n = (\\psi^n)^* L \\psi^n$ 也被保持。这是因为 $L$ 与 $U_h(L)$ 可交换，因为 $U_h(L)$ 是 $L$ 的一个有理函数。\n$$\nE^{n+1} = (\\psi^{n+1})^* L \\psi^{n+1} = (U_h \\psi^n)^* L (U_h \\psi^n) = (\\psi^n)^* U_h^* L U_h \\psi^n.\n$$\n由于 $L$ 和 $U_h$ 可交换，所以 $L U_h = U_h L$。取伴随可得 $U_h^* L^* = L^* U_h^*$，又因为 $L=L^*$，我们有 $U_h^* L = L U_h^*$。所以，$L$ 也与 $U_h^*$ 可交换。\n$$\nE^{n+1} = (\\psi^n)^* U_h^* U_h L \\psi^n = (\\psi^n)^* I L \\psi^n = (\\psi^n)^* L \\psi^n = E^n.\n$$\n因此，凯莱映射积分方法精确地保持了与所选拉普拉斯矩阵 $L$ 相关的范数和能量。问题中的验证，即检查偏差是否在 $10^{-12}$ 的容差范围内，是对这些理论性质的数值验证，考虑了浮点运算误差。\n\n每个测试案例的实现将按以下步骤进行：\n1.  构建邻接矩阵 $A$。\n2.  对 $L_{\\mathrm{unn}}$ 和 $L_{\\mathrm{sym}}$ 分别执行：\n    a. 从 $A$ 构建拉普拉斯矩阵 $L$。对于 $L_{\\mathrm{sym}}$，必须仔细实现定义 $(D^{-1/2})_{jj} = d_j^{-1/2}$ (当 $d_j  0$ 时) 和 $0$ (当 $d_j=0$ 时)。\n    b. 使用适用于对称矩阵的方法（如 `numpy.linalg.eigvalsh`）计算 $L$ 的最小和最大特征值。\n    c. 按规定初始化状态向量 $\\psi^0$ 并将其归一化。\n    d. 计算初始范数和能量。\n    e. 为线性系统求解器预先计算矩阵：$M_A = I - i \\frac{h}{2} L$ 和 $M_B = I + i \\frac{h}{2} L$。\n    f. 迭代 $M$ 次，在每一步通过求解线性系统 $M_A \\psi^{n+1} = M_B \\psi^n$ 来更新状态向量。\n    g. 在迭代过程中，跟踪范数和能量与其初始值的最大绝对偏差。\n    h. 模拟结束后，判断范数和能量是否在给定容差内得以保持。\n3.  收集并格式化八个指定的结果用于最终输出。\n\n拉普拉斯矩阵的特征值决定了系统的能量谱。对于未归一化拉普拉斯矩阵 $L_{\\mathrm{unn}}$，其特征值非负，最小特征值为 0，其重数等于图的连通分量数。最大特征值的大小与最大度数有关。对于对称归一化拉普拉斯矩阵 $L_{\\mathrm{sym}}$，已知其特征值在范围 $[0, 2]$ 内。同样，对于任何至少有一条边的图，其最小特征值为 0。特征值 2 的出现当且仅当图包含一个二分连通分量。这种归一化过程将谱映射到一个固定区间，这在理论分析和某些数值方法的稳定性方面可能是有利的。",
            "answer": "```python\nimport numpy as np\n\ndef process_case(A, h, M):\n    \"\"\"\n    Processes a single test case for both unnormalized and symmetric\n    normalized Laplacians.\n    \"\"\"\n    n = A.shape[0]\n    \n    # --- Initial State ---\n    psi0_unscaled = np.arange(n, dtype=np.complex128) + 1j * (n - np.arange(n, dtype=np.complex128))\n    psi0 = psi0_unscaled / np.linalg.norm(psi0_unscaled)\n    \n    # --- Unnormalized Laplacian: L_unn ---\n    d_unn = np.sum(A, axis=1)\n    D_unn = np.diag(d_unn)\n    L_unn = D_unn - A\n    \n    eigvals_unn = np.linalg.eigvalsh(L_unn)\n    min_eig_unn = np.min(eigvals_unn)\n    max_eig_unn = np.max(eigvals_unn)\n    \n    psi = psi0.copy()\n    initial_norm_unn = np.linalg.norm(psi)\n    initial_energy_unn = np.real(psi.conj().T @ L_unn @ psi)\n    max_norm_dev_unn = 0.0\n    max_energy_dev_unn = 0.0\n    \n    Id = np.eye(n, dtype=np.complex128)\n    mat_A_unn = Id - 0.5j * h * L_unn\n    mat_B_unn = Id + 0.5j * h * L_unn\n    \n    for _ in range(M):\n        b = mat_B_unn @ psi\n        psi = np.linalg.solve(mat_A_unn, b)\n        \n        current_norm = np.linalg.norm(psi)\n        current_energy = np.real(psi.conj().T @ L_unn @ psi)\n        \n        max_norm_dev_unn = max(max_norm_dev_unn, abs(current_norm - initial_norm_unn))\n        max_energy_dev_unn = max(max_energy_dev_unn, abs(current_energy - initial_energy_unn))\n        \n    norm_preserved_unn = max_norm_dev_unn = 1e-12\n    energy_preserved_unn = max_energy_dev_unn = 1e-12\n\n    # --- Symmetric Normalized Laplacian: L_sym ---\n    d_sym = np.sum(A, axis=1)\n    d_sqrt_inv_diag = np.zeros_like(d_sym, dtype=float)\n    non_zero_mask = d_sym > 0\n    d_sqrt_inv_diag[non_zero_mask] = 1.0 / np.sqrt(d_sym[non_zero_mask])\n    D_sqrt_inv = np.diag(d_sqrt_inv_diag)\n    \n    L_sym = Id.real - D_sqrt_inv @ A @ D_sqrt_inv\n    \n    eigvals_sym = np.linalg.eigvalsh(L_sym)\n    min_eig_sym = np.min(eigvals_sym)\n    max_eig_sym = np.max(eigvals_sym)\n    \n    psi = psi0.copy()\n    initial_norm_sym = np.linalg.norm(psi)\n    initial_energy_sym = np.real(psi.conj().T @ L_sym @ psi)\n    max_norm_dev_sym = 0.0\n    max_energy_dev_sym = 0.0\n\n    mat_A_sym = Id - 0.5j * h * L_sym\n    mat_B_sym = Id + 0.5j * h * L_sym\n    \n    for _ in range(M):\n        b = mat_B_sym @ psi\n        psi = np.linalg.solve(mat_A_sym, b)\n\n        current_norm = np.linalg.norm(psi)\n        current_energy = np.real(psi.conj().T @ L_sym @ psi)\n\n        max_norm_dev_sym = max(max_norm_dev_sym, abs(current_norm - initial_norm_sym))\n        max_energy_dev_sym = max(max_energy_dev_sym, abs(current_energy - initial_energy_sym))\n\n    norm_preserved_sym = max_norm_dev_sym = 1e-12\n    energy_preserved_sym = max_energy_dev_sym = 1e-12\n\n    return [\n        norm_preserved_unn, energy_preserved_unn,\n        norm_preserved_sym, energy_preserved_sym,\n        min_eig_unn, max_eig_unn,\n        min_eig_sym, max_eig_sym\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run simulations, and print results.\n    \"\"\"\n    # Case #1: Path graph\n    n1 = 5\n    A1 = np.zeros((n1, n1))\n    for j in range(n1 - 1):\n        A1[j, j + 1] = A1[j + 1, j] = 1.0\n    h1, M1 = 0.2, 20\n\n    # Case #2: Star graph\n    n2 = 6\n    A2 = np.zeros((n2, n2))\n    for k in range(1, n2):\n        A2[0, k] = A2[k, 0] = 1.0\n    h2, M2 = 0.05, 100\n\n    # Case #3: Weighted cycle\n    n3 = 5\n    A3 = np.zeros((n3, n3))\n    weights = [1.0, 2.0, 0.5, 1.5, 1.0]\n    for j in range(n3):\n        A3[j, (j + 1) % n3] = A3[(j + 1) % n3, j] = weights[j]\n    h3, M3 = 1.0, 10\n\n    # Case #4: Disconnected with isolated nodes\n    n4 = 4\n    A4 = np.zeros((n4, n4))\n    A4[0, 1] = A4[1, 0] = 1.0\n    h4, M4 = 0.3, 30\n    \n    test_cases = [\n        (A1, h1, M1),\n        (A2, h2, M2),\n        (A3, h3, M3),\n        (A4, h4, M4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, h, M = case\n        case_result = process_case(A, h, M)\n        results.append(case_result)\n\n    case_strings = [str(res) for res in results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}