{
    "hands_on_practices": [
        {
            "introduction": "要分析一个时间积分格式的稳定性，第一步也是最关键的一步，是推导出它的稳定性函数 $R(z)$。这个练习将指导你完成这一基本功的训练。我们将以一个常用的隐式龙格-库塔法（SDIRK）为例，将其应用于半离散化的热传导方程，通过从方法的Butcher系数出发，一步步推导出其稳定性函数，并最终依据A-稳定性和L-稳定性的基本定义来判断其性质。这个过程能帮助你深刻理解数值格式的系数是如何决定其在求解刚性问题时的表现的 。",
            "id": "3360286",
            "problem": "考虑具有齐次狄利克雷边界条件的一维热方程，\n$$\nu_{t}(x,t) = \\nu\\,u_{xx}(x,t), \\quad x \\in (0,1), \\quad t \\geq 0, \\quad u(0,t) = u(1,t) = 0,\n$$\n其中 $\\nu  0$ 是热扩散系数。设在具有网格宽度 $h = \\frac{1}{N+1}$ 的 $N$ 个内部点的均匀网格上使用标准的二阶中心差分进行空间半离散化，得到常微分方程组\n$$\n\\frac{d}{dt}\\mathbf{u}(t) = A_{h}\\,\\mathbf{u}(t),\n$$\n其中 $\\mathbf{u}(t) \\in \\mathbb{R}^{N}$ 汇集了节点值，而 $A_{h} = \\frac{\\nu}{h^{2}}L$，$L \\in \\mathbb{R}^{N \\times N}$ 是一个三对角矩阵，其元素为 $L_{jj} = -2$，$L_{j,j+1} = L_{j+1,j} = 1$，其余为零。已知 $A_{h}$ 的谱满足 $\\sigma(A_{h}) \\subset (-\\infty,0)$，并且对于每个特征值 $\\lambda \\in \\sigma(A_{h})$，其对应的模态满足标量测试方程 $\\frac{d}{dt}y(t) = \\lambda\\,y(t)$。\n\n使用以下二阶单对角隐式龙格-库塔（SDIRK）方法（Alexander二阶方法）对该半离散系统进行时间积分，其布彻系数为\n$$\n\\begin{array}{c|cc}\n\\gamma  \\gamma  0 \\\\\n1  1-\\gamma  \\gamma \\\\\n\\hline\n  1-\\gamma  \\gamma\n\\end{array}\n\\quad \\text{其中} \\quad \\gamma = 1 - \\frac{1}{\\sqrt{2}}.\n$$\n将该方法应用于标量测试方程 $\\frac{d}{dt}y(t) = \\lambda\\,y(t)$，并定义 $z = \\Delta t\\,\\lambda$，其中 $\\Delta t  0$ 是时间步长。推导此方法的稳定性函数 $R(z)$，并将其表示为 $z$ 的单个闭式解析函数，其中 $\\gamma$ 已被 $1 - \\frac{1}{\\sqrt{2}}$ 替换。\n\n然后，仅使用 $A_{h}$ 的谱特征以及您推导出的 $R(z)$，评估该方法对于此半离散热方程是否是 $A$-稳定的以及是否是 $L$-稳定的。您的推理必须基于基本定义：$A$-稳定性意味着对于所有 $\\operatorname{Re}(z) \\leq 0$ 的 $z$，有 $|R(z)| \\leq 1$；而 $L$-稳定性意味着在 $A$-稳定的基础上，还需满足 $\\lim_{z \\to -\\infty} R(z) = 0$。您不得引用任何现成的稳定性定理；必须直接根据定义和 $A_{h}$ 的谱进行推理。\n\n您的最终答案必须是推导出的 $R(z)$ 的闭式表达式。不需要四舍五入。",
            "solution": "问题陈述是有效的，因为它描述了数值分析中一个关于偏微分方程时间积分格式稳定性的标准、适定问题。它在科学上是合理的、客观的，并包含了所有必要的信息。\n\n任务是为给定的二阶单对角隐式龙格-库塔（SDIRK）方法推导稳定性函数 $R(z)$，并随后分析其 $A$-稳定性和 $L$-稳定性。\n\n该方法的布彻表为：\n$$\n\\begin{array}{c|cc}\n\\gamma  \\gamma  0 \\\\\n1  1-\\gamma  \\gamma \\\\\n\\hline\n  1-\\gamma  \\gamma\n\\end{array}\n$$\n其中 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。\n\n我们将此方法应用于标量测试方程 $\\frac{d}{dt}y(t) = \\lambda y(t)$。龙格-库塔方法从 $y_n$ 到 $y_{n+1}$ 的单步计算是通过计算阶段值 $Y_1, Y_2$ 然后得出最终结果。\n\n阶段值 $Y_i$ 是对 $y(t_n + c_i \\Delta t)$ 的近似。对于隐式方法，它们由以下公式定义：\n$$\nY_i = y_n + \\Delta t \\sum_{j=1}^{2} a_{ij} f(Y_j)\n$$\n其中 $f(Y_j) = \\lambda Y_j$。令 $z = \\Delta t \\lambda$。阶段方程变为：\n$$\nY_i = y_n + z \\sum_{j=1}^{2} a_{ij} Y_j\n$$\n对于给定的方法（$a_{11}=\\gamma$, $a_{12}=0$, $a_{21}=1-\\gamma$, $a_{22}=\\gamma$）：\n\n阶段 $1$：\n$$\nY_1 = y_n + z a_{11} Y_1 = y_n + z \\gamma Y_1\n$$\n求解 $Y_1$：\n$$\nY_1(1 - z\\gamma) = y_n \\implies Y_1 = \\frac{y_n}{1 - z\\gamma}\n$$\n\n阶段 $2$：\n$$\nY_2 = y_n + z(a_{21}Y_1 + a_{22}Y_2) = y_n + z(1-\\gamma)Y_1 + z\\gamma Y_2\n$$\n求解 $Y_2$：\n$$\nY_2(1 - z\\gamma) = y_n + z(1-\\gamma)Y_1\n$$\n代入 $Y_1$ 的表达式：\n$$\nY_2(1 - z\\gamma) = y_n + z(1-\\gamma)\\frac{y_n}{1 - z\\gamma}\n$$\n$$\nY_2 = \\frac{y_n}{1 - z\\gamma} + \\frac{z(1-\\gamma)y_n}{(1 - z\\gamma)^2} = \\frac{y_n(1 - z\\gamma) + z(1-\\gamma)y_n}{(1 - z\\gamma)^2}\n$$\n$$\nY_2 = \\frac{y_n(1 - z\\gamma + z - z\\gamma)}{(1 - z\\gamma)^2} = y_n \\frac{1 + z(1-2\\gamma)}{(1 - z\\gamma)^2}\n$$\n更新步骤由 $y_{n+1} = y_n + \\Delta t \\sum_{i=1}^{2} b_i f(Y_i)$ 给出。稳定性函数 $R(z)$ 定义为 $y_{n+1} = R(z)y_n$。\n\n对于给定的方法，注意到其系数满足 $b_1 = 1-\\gamma = a_{21}$ 且 $b_2 = \\gamma = a_{22}$。这类方法被称为“刚性精确”(stiffly accurate)，其一个重要性质是更新后的解恰好等于最后一个阶段值，即 $y_{n+1} = Y_2$。这是一个更直接的推导路径。\n\n因此，稳定性函数就简化为：\n$$\nR(z) = \\frac{y_{n+1}}{y_n} = \\frac{Y_2}{y_n} = \\frac{1 + z(1-2\\gamma)}{(1 - z\\gamma)^2}\n$$\n现在我们代入给定的值 $\\gamma = 1 - \\frac{1}{\\sqrt{2}} = 1 - \\frac{\\sqrt{2}}{2}$：\n$$\n1-2\\gamma = 1 - 2\\left(1 - \\frac{\\sqrt{2}}{2}\\right) = 1 - 2 + \\sqrt{2} = \\sqrt{2}-1\n$$\n所以，稳定性函数为：\n$$\nR(z) = \\frac{1 + (\\sqrt{2}-1)z}{\\left(1 - \\left(1-\\frac{\\sqrt{2}}{2}\\right)z\\right)^2}\n$$\n这就是所要求的闭式表达式。\n\n接下来，我们评估其稳定性。\n**A-稳定性**：如果一个方法的绝对稳定区域包含整个复平面的左半部分，即对于所有 $\\operatorname{Re}(z) \\le 0$ 的 $z \\in \\mathbb{C}$，都有 $|R(z)| \\le 1$，则该方法是 $A$-稳定的。\n稳定性函数 $R(z)$ 是一个关于 $z$ 的有理函数。\n$R(z)$ 的极点由分母的根给出，$1 - z\\gamma = 0$，解得 $z = 1/\\gamma$。\n由于 $\\gamma = 1 - \\frac{1}{\\sqrt{2}} \\approx 1 - 0.707 = 0.293  0$，极点 $z = 1/\\gamma$ 位于右半平面，即 $\\operatorname{Re}(z)  0$。\n因此，$R(z)$ 在所有 $\\operatorname{Re}(z) \\le 0$ 的 $z$ 上都是解析的。\n根据最大模原理，如果 $|R(z)| \\le 1$ 在该区域的边界上（即虚轴，$z=iy$，$y \\in \\mathbb{R}$）以及在无穷远处成立，那么 $|R(z)| \\le 1$ 在整个区域内都成立。\n我们来检查虚轴，$z = iy$：\n$$\n|R(iy)|^2 = \\frac{|1 + iy(\\sqrt{2}-1)|^2}{|(1 - iy(1-\\frac{\\sqrt{2}}{2}))^2|^2} = \\frac{1^2 + y^2(\\sqrt{2}-1)^2}{(1^2 + y^2(1-\\frac{\\sqrt{2}}{2})^2)^2}\n$$\n我们来简化系数：$(\\sqrt{2}-1)^2 = 2-2\\sqrt{2}+1 = 3-2\\sqrt{2}$。\n$\\left(1-\\frac{\\sqrt{2}}{2}\\right)^2 = \\left(\\frac{2-\\sqrt{2}}{2}\\right)^2 = \\frac{4-4\\sqrt{2}+2}{4} = \\frac{6-4\\sqrt{2}}{4} = \\frac{3-2\\sqrt{2}}{2}$。\n令 $a = y^2(3-2\\sqrt{2})$。由于 $3-2\\sqrt{2} > 0$，我们有 $a \\ge 0$。不等式 $|R(iy)|^2 \\le 1$ 变为：\n$$\n1 + a \\le \\left(1 + \\frac{a}{2}\\right)^2\n$$\n$$\n1 + a \\le 1 + a + \\frac{a^2}{4}\n$$\n$$\n0 \\le \\frac{a^2}{4}\n$$\n这个不等式对所有实数 $a$ 都成立，因此对所有 $y \\in \\mathbb{R}$ 都成立。所以，$|R(iy)| \\le 1$。\n现在我们检查在左半平面 $|z| \\to \\infty$ 时的极限：\n$$\n\\lim_{|z|\\to\\infty, \\operatorname{Re}(z)\\le 0} |R(z)| = \\lim_{|z|\\to\\infty} \\left|\\frac{1 + z(1-2\\gamma)}{1-2z\\gamma+z^2\\gamma^2}\\right| = \\lim_{|z|\\to\\infty} \\left|\\frac{z(1-2\\gamma)}{z^2\\gamma^2}\\right| = \\lim_{|z|\\to\\infty} \\left|\\frac{1-2\\gamma}{\\gamma^2 z}\\right| = 0\n$$\n由于在边界上 $|R(z)| \\le 1$ 并且在无穷远处趋于 $0$，根据最大模原理，对于所有 $\\operatorname{Re}(z) \\le 0$，都有 $|R(z)| \\le 1$。该方法是 $A$-稳定的。\n\n**L-稳定性**：如果一个方法是 $A$-稳定的，并且还满足 $\\lim_{z \\to -\\infty} R(z) = 0$，那么该方法是 $L$-稳定的。\n该问题涉及半离散热方程，其特征值 $\\lambda$ 是实数且为负。因此，相关的极限是 $z$ 沿负实轴趋于 $-\\infty$。\n我们已经证明了该方法是 $A$-稳定的。现在我们来检查极限：\n$$\n\\lim_{z \\to -\\infty} R(z) = \\lim_{z \\to -\\infty} \\frac{1 + z(1-2\\gamma)}{(1 - z\\gamma)^2}\n$$\n这是一个有理函数，其中分子的次数是 $1$，分母的次数是 $2$。\n$$\n\\lim_{z \\to -\\infty} \\frac{z(1-2\\gamma)}{z^2\\gamma^2} = \\lim_{z \\to -\\infty} \\frac{1-2\\gamma}{z\\gamma^2} = 0\n$$\n由于该方法是 $A$-稳定的，并且 $\\lim_{z \\to -\\infty} R(z) = 0$，所以该方法是 $L$-稳定的。这个性质对于像半离散热方程这样的刚性问题是非常理想的，因为它确保了非常刚性（高振荡或快速衰减）的模态会被数值格式强力衰减。",
            "answer": "$$\\boxed{\\frac{1 + \\left(\\sqrt{2}-1\\right)z}{\\left(1 - \\left(1-\\frac{\\sqrt{2}}{2}\\right)z\\right)^2}}$$"
        },
        {
            "introduction": "理论分析告诉我们，L-稳定性对于有效抑制刚性分量至关重要，而仅仅具备A-稳定性的格式（如Crank-Nicolson）则有所欠缺。但这种理论上的差异在实际计算中究竟会带来怎样的后果？本练习将通过一个包含对流和强扩散项的偏微分方程，让你直观地观察和量化这一差异。你将使用傅里叶谱方法，对比L-稳定的后向欧拉格式和非L-稳定的Crank-Nicolson格式在处理包含高频信息的初始条件（如阶跃函数）时的表现，从而将抽象的稳定性理论与实际计算中出现的数值振荡现象直接联系起来 。",
            "id": "3360288",
            "problem": "考虑周期域上的一维线性对流扩散偏微分方程（PDE），\n$$\nu_t(x,t) + b\\,u_x(x,t) = \\kappa\\,u_{xx}(x,t),\n$$\n对于 $x \\in [0,L]$，周期为 $L$，对流速度 $b \\in \\mathbb{R}$ 为常数，扩散系数 $\\kappa  0$。假设在具有 $N$ 个点和网格间距 $h = L/N$ 的均匀网格上进行空间半离散，采用周期性边界条件，并对空间算子使用以下标准的二阶中心差分格式：\n- 对于一阶导数，使用 $(u_{j+1} - u_{j-1})/(2h)$，其离散傅里叶符号为 $i\\,\\sin(\\theta)/h$。\n- 对于二阶导数，使用 $(u_{j+1} - 2u_j + u_{j-1})/h^2$，其离散傅里叶符号为 $-4\\,\\sin^2(\\theta/2)/h^2$。\n其中，$\\theta = 2\\pi m/N$，傅里叶模态指数 $m \\in \\{0,1,\\dots,N-1\\}$。\n\n因此，该半离散系统可以写作 $\\partial_t u = \\mathcal{L} u$，其中 $\\mathcal{L}$ 是离散线性空间算子，其作用于对应于 $\\theta$ 的离散傅里叶模态的特征值为\n$$\n\\lambda(\\theta) = -i\\,b\\,\\frac{\\sin(\\theta)}{h} - \\kappa\\,\\frac{4\\sin^2(\\theta/2)}{h^2}.\n$$\n\n将对比两种隐式时间积分器：\n1. 后向欧拉（implicit Euler），定义为 $(I - \\Delta t\\,\\mathcal{L})\\,u^{n+1} = u^{n}$。\n2. Crank–Nicolson，定义为 $\\left(I - \\frac{\\Delta t}{2}\\,\\mathcal{L}\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2}\\,\\mathcal{L}\\right) u^{n}$。\n\n从广泛使用的线性测试方程 $y'(t) = \\lambda\\,y(t)$ 和上述格式的定义出发，推导后向欧拉和 Crank–Nicolson 相应的标量稳定性函数 $R(z)$，其中 $z = \\Delta t\\,\\lambda$。然后，使用上面指定的 $\\lambda(\\theta)$ 的离散傅里叶符号，为每种格式设计一个单步傅里叶空间传播算子，使得 $\\widehat{u}^{n+1}(\\theta) = R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right)\\,\\widehat{u}^{n}(\\theta)$，其中 $\\widehat{u}$ 表示 $u$ 的离散傅里叶变换。\n\n使用从 $t=0$ 到 $t=\\Delta t$ 的单步更新，如下定义振荡的度量：\n- 考虑初始条件\n$$\nu(x,0) = \n\\begin{cases}\n1,  0 \\le x  L/2, \\\\\n0,  L/2 \\le x  L,\n\\end{cases}\n$$\n在周期性网格上的解释。这是一个不连续的阶跃函数，它会激发广谱的傅里叶模态，包括最刚性的高频分量。\n- 对于每种格式（后向欧拉和 Crank–Nicolson），通过傅里叶空间单步更新计算 $u(x,\\Delta t)$。\n- 将一种格式的下冲幅度定义为 $u(x,\\Delta t)$ 的最小值，它量化了产生低于 $0$ 的值的振荡。将一种格式的上冲幅度定义为 $\\max\\{u(x,\\Delta t)-1,\\,0\\}$，它量化了高于 $1$ 的值。\n\n此外，为了将振荡与非 $L$-稳定性联系起来，使用在奈奎斯特（Nyquist）模态 $\\theta_{\\mathrm{nyq}} = \\pi$（即 $m = N/2$）处评估的稳定性函数的大小来量化高频刚性模态的放大，即\n$$\nG_{\\mathrm{nyq}}^{\\mathrm{scheme}} = \\left|R\\big(\\Delta t\\,\\lambda(\\pi)\\big)\\right|.\n$$\n回顾一下，对于 $L$-稳定性（刚性衰减），要求 $R(\\infty) = 0$，这意味着无限刚性的模态被完全阻尼；否则，非零的 $R(\\infty)$ 意味着持久的（或符号交替的）高频分量，表现为振荡。\n\n你的任务是：\n- 从应用于 $y'=\\lambda y$ 的格式定义中推导后向欧拉和 Crank–Nicolson 的稳定性函数 $R(z)$。\n- 使用给定的离散符号构造单步傅里叶空间传播算子。\n- 实现一个完整的程序，该程序：\n  1. 设置 $L = 2\\pi$，$N = 256$，并在网格上构建阶跃函数初始条件。\n  2. 对于每个指定的测试用例，通过将傅里叶系数与 $R\\!\\left(\\Delta t\\,\\lambda(\\theta)\\right)$ 相乘并变换回物理空间，计算两种格式的单步更新。\n  3. 按照上述定义测量下冲和上冲幅度。\n  4. 计算两种格式的 $G_{\\mathrm{nyq}}^{\\mathrm{scheme}}$。\n  5. 对于每个测试用例，按顺序输出一个包含六个浮点数的列表\n     $$\n     \\big[\\min(u_{\\mathrm{CN}}),\\,\\min(u_{\\mathrm{BE}}),\\,\\max\\{u_{\\mathrm{CN}}-1,0\\},\\,\\max\\{u_{\\mathrm{BE}}-1,0\\},\\,G_{\\mathrm{nyq}}^{\\mathrm{CN}},\\,G_{\\mathrm{nyq}}^{\\mathrm{BE}}\\big],\n     $$\n\n所有量都是无量纲的；不需要物理单位。\n\n测试套件：\n- 案例1（刚性扩散，无对流）：$b = 0.0$，$\\kappa = 100.0$，$\\Delta t = 0.5$。\n- 案例2（带对流的刚性扩散）：$b = 3.0$，$\\kappa = 100.0$，$\\Delta t = 0.5$。\n- 案例3（中等扩散，小时间步长）：$b = 0.0$，$\\kappa = 1.0$，$\\Delta t = 10^{-4}$。\n\n最终输出格式：\n- 你的程序应该生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是针对一个测试用例的六元素列表，不含空格。例如：\n$$\n[\\,[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],[a_3,b_3,c_3,d_3,e_3,f_3]\\,].\n$$",
            "solution": "问题陈述是偏微分方程数值分析领域中一个适定且有科学依据的练习。它关注两种常见的时间积分格式，后向欧拉和 Crank-Nicolson，在应用于半离散的对流扩散方程时的稳定性和振荡特性。所有定义、参数和目标都陈述清晰，并与该领域的标准理论一致。因此，该问题是有效的。\n\n解决方案分为两个主要部分：首先，对必要组件（稳定性函数和传播算子）进行理论推导；其次，描述用于计算所需指标的数值实现。\n\n**1. 稳定性函数和传播算子的推导**\n\n为分析时间积分格式的稳定性，我们将其应用于线性测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 是一个满足 $\\text{Re}(\\lambda) \\le 0$ 的复数。数值格式的单步将解从时间 $t_n$ 更新到 $t_{n+1} = t_n + \\Delta t$，形式为 $y^{n+1} = R(z) y^n$，其中 $z = \\lambda \\Delta t$。函数 $R(z)$ 是该格式的标量稳定性函数。\n\n**1.1. 后向欧拉（BE）**\n后向欧拉格式由以下隐式关系定义：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\mathcal{L} u^{n+1}\n$$\n将其应用于测试方程，其中 $\\mathcal{L}$ 对应于乘以 $\\lambda$：\n$$\ny^{n+1} - y^n = \\Delta t \\lambda y^{n+1}\n$$\n求解 $y^{n+1}$：\n$$\ny^{n+1} (1 - \\Delta t \\lambda) = y^n\n$$\n$$\ny^{n+1} = \\frac{1}{1 - \\Delta t \\lambda} y^n\n$$\n因此，后向欧拉的稳定性函数为：\n$$\nR_{\\mathrm{BE}}(z) = \\frac{1}{1-z}\n$$\n\n**1.2. Crank-Nicolson (CN)**\nCrank-Nicolson 格式由以下隐式关系定义：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2} (\\mathcal{L} u^n + \\mathcal{L} u^{n+1})\n$$\n将其应用于测试方程：\n$$\ny^{n+1} - y^n = \\frac{\\Delta t}{2} (\\lambda y^n + \\lambda y^{n+1})\n$$\n求解 $y^{n+1}$：\n$$\ny^{n+1} \\left(1 - \\frac{\\Delta t \\lambda}{2}\\right) = y^n \\left(1 + \\frac{\\Delta t \\lambda}{2}\\right)\n$$\n$$\ny^{n+1} = \\frac{1 + \\Delta t \\lambda / 2}{1 - \\Delta t \\lambda / 2} y^n\n$$\n因此，Crank-Nicolson 的稳定性函数为：\n$$\nR_{\\mathrm{CN}}(z) = \\frac{1 + z/2}{1 - z/2}\n$$\n\n**1.3. L-稳定性与振荡的联系**\n如果对于所有 $\\text{Re}(z) \\le 0$ 的 $z$，都有 $|R(z)| \\le 1$，则该格式是 $A$-稳定的。如果一个格式是 $A$-稳定的，并且额外满足当 $\\text{Re}(z) \\le 0$ 时 $\\lim_{|z| \\to \\infty} |R(z)| = 0$，则该格式是 $L$-稳定的。后一个条件对于阻尼无限刚性的模态至关重要，这些模态对应于高频空间分量，如不连续点。\n- 对于后向欧拉：$\\lim_{|z| \\to \\infty} |R_{\\mathrm{BE}}(z)| = \\lim_{|z| \\to \\infty} \\left|\\frac{1}{1-z}\\right| = 0$。后向欧拉是 $L$-稳定的。它能有效地阻尼刚性分量。\n- 对于 Crank-Nicolson：$\\lim_{|z| \\to \\infty} |R_{\\mathrm{CN}}(z)| = \\lim_{|z| \\to \\infty} \\left|\\frac{1+z/2}{1-z/2}\\right| = \\lim_{|z| \\to \\infty} \\left|\\frac{1/z+1/2}{1/z-1/2}\\right| = \\left|\\frac{1/2}{-1/2}\\right| = 1$。Crank-Nicolson 是 $A$-稳定的，但不是 $L$-稳定的。它无法阻尼刚性分量，这可能在数值解中表现为持续的、非物理的振荡，尤其是在陡峭梯度附近。\n\n**1.4. 傅里叶空间传播算子**\n半离散系统 $\\partial_t u = \\mathcal{L}u$ 是关于网格点值 $u_j(t)$ 的耦合常微分方程（ODE）系统。通过应用离散傅里叶变换（DFT），该系统被对角化。每个傅里叶模态 $\\widehat{u}(\\theta)$ 根据 ODE 独立演化：\n$$\n\\frac{d}{dt}\\widehat{u}(\\theta, t) = \\lambda(\\theta)\\,\\widehat{u}(\\theta, t)\n$$\n其中 $\\lambda(\\theta)$ 是算子 $\\mathcal{L}$ 对于模态 $\\theta = 2\\pi m/N$ 的特征值。这是标量测试方程的一个实例。因此，从 $t_n$ 到 $t_{n+1}$ 的单个时间步长按如下方式更新每个傅里叶系数：\n$$\n\\widehat{u}^{n+1}(\\theta) = R(\\Delta t\\,\\lambda(\\theta))\\,\\widehat{u}^{n}(\\theta)\n$$\n单步傅里叶传播算子是所有离散模态 $\\theta$ 的值 $R(\\Delta t\\,\\lambda(\\theta))$ 组成的数组。\n\n**2. 数值实现与指标**\n\n解决该问题的算法如下：\n1.  设置物理和数值参数：$L=2\\pi$，$N=256$。由此计算网格间距 $h=L/N$。\n2.  定义空间网格 $x_j = j h$，其中 $j=0, 1, \\dots, N-1$。\n3.  构造初始条件数组 $u_0$，表示网格上的阶跃函数。对于 $j=0, \\dots, N/2-1$，$u_j(0) = 1$，否则 $u_j(0)=0$。\n4.  构造无量纲波数数组 $\\theta_m = 2\\pi m/N$。为了与 `numpy.fft` 一同使用，有效模态指数 $m$ 的顺序为 $0, 1, \\dots, N/2-1, -N/2, \\dots, -1$。这可以方便地使用 `np.fft.fftfreq` 生成。\n5.  对于每个测试用例 $(b, \\kappa, \\Delta t)$:\n    a. 使用给定公式计算所有模态的特征值数组 $\\lambda(\\theta)$：\n    $$\n    \\lambda(\\theta) = -i\\,b\\,\\frac{\\sin(\\theta)}{h} - \\kappa\\,\\frac{4\\sin^2(\\theta/2)}{h^2}\n    $$\n    b. 计算数组 $z = \\Delta t\\,\\lambda(\\theta)$。\n    c. 计算两种格式的传播算子数组：$R_{\\mathrm{BE}}(z)$ 和 $R_{\\mathrm{CN}}(z)$。\n    d. 计算初始条件的 DFT：$\\widehat{u}^0 = \\text{DFT}(u_0)$。\n    e. 在傅里叶空间中传播一步：$\\widehat{u}^1_{\\mathrm{BE}} = R_{\\mathrm{BE}}(z) \\odot \\widehat{u}^0$ 和 $\\widehat{u}^1_{\\mathrm{CN}} = R_{\\mathrm{CN}}(z) \\odot \\widehat{u}^0$，其中 $\\odot$ 是逐元素乘法。\n    f. 通过应用逆 DFT 计算在时间 $\\Delta t$ 的解：$u^1_{\\mathrm{scheme}} = \\text{IDFT}(\\widehat{u}^1_{\\mathrm{scheme}})$。由于初始数据是实数，我们取结果的实部以舍弃由数值舍入引起的可以忽略的虚部。\n    g. 计算振荡指标：\n        - 下冲：$\\min(u^1_{\\mathrm{scheme}})$。\n        - 上冲：$\\max\\{0, \\max(u^1_{\\mathrm{scheme}}) - 1\\}$。\n    h. 计算奈奎斯特频率下的刚性模态放大率 $G_{\\mathrm{nyq}}$。奈奎斯特模态对应于 $\\theta = \\pi$。其特征值是纯实数且与扩散相关：\n    $$\n    \\lambda(\\pi) = -i\\,b\\,\\frac{\\sin(\\pi)}{h} - \\kappa\\,\\frac{4\\sin^2(\\pi/2)}{h^2} = - \\frac{4\\kappa}{h^2}\n    $$\n    令 $z_{\\mathrm{nyq}} = \\Delta t \\lambda(\\pi) = -4\\kappa\\Delta t/h^2$。则：\n    $$\n    G_{\\mathrm{nyq}}^{\\mathrm{BE}} = |R_{\\mathrm{BE}}(z_{\\mathrm{nyq}})| = \\left|\\frac{1}{1 - z_{\\mathrm{nyq}}}\\right|\n    $$\n    $$\n    G_{\\mathrm{nyq}}^{\\mathrm{CN}} = |R_{\\mathrm{CN}}(z_{\\mathrm{nyq}})| = \\left|\\frac{1 + z_{\\mathrm{nyq}}/2}{1 - z_{\\mathrm{nyq}}/2}\\right|\n    $$\n6.  收集每个测试用例的六个指定浮点数，并将最终输出格式化为列表的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing backward Euler and Crank-Nicolson schemes\n    for a convection-diffusion equation, focusing on stability and oscillations.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (stiff diffusion, no convection)\n        (0.0, 100.0, 0.5),\n        # Case 2 (stiff diffusion with convection)\n        (3.0, 100.0, 0.5),\n        # Case 3 (moderately diffusive, small time step)\n        (0.0, 1.0, 1e-4),\n    ]\n\n    # Global parameters\n    L = 2.0 * np.pi\n    N = 256\n    h = L / N\n\n    # Spatial grid and initial condition\n    x = np.arange(N) * h\n    u0 = np.zeros(N)\n    # The condition is u(x,0)=1 for 0 = x  L/2.\n    # On the grid x_j = j*h, this means j*h  L/2 = j  L/(2*h) = N/2.\n    # Indices are 0, 1, ..., N/2 - 1.\n    u0[0:N//2] = 1.0\n\n    # Fourier space setup\n    # theta = 2*pi*m/N, where m are the DFT mode numbers\n    # np.fft.fftfreq(N) gives m/N for the standard FFT ordering\n    theta = 2.0 * np.pi * np.fft.fftfreq(N)\n    u0_hat = np.fft.fft(u0)\n    \n    results = []\n    for b, kappa, dt in test_cases:\n        # 1. Compute eigenvalues and stability function arguments\n        # Eigenvalue of the semi-discrete operator for each mode theta\n        # lambda(theta) = -i*b*sin(theta)/h - kappa*4*sin^2(theta/2)/h^2\n        # Use 2*(1-cos(theta)) for 4*sin^2(theta/2) to avoid creating theta/2 array\n        lambda_theta = (-1j * b * np.sin(theta) / h\n                        - kappa * 2.0 * (1.0 - np.cos(theta)) / h**2)\n        \n        # Stability function argument z = dt * lambda\n        z = dt * lambda_theta\n\n        # 2. Compute the one-step Fourier propagators (R(z))\n        # Backward Euler: R_BE(z) = 1 / (1 - z)\n        R_BE = 1.0 / (1.0 - z)\n        # Crank-Nicolson: R_CN(z) = (1 + z/2) / (1 - z/2)\n        R_CN = (1.0 + 0.5 * z) / (1.0 - 0.5 * z)\n\n        # 3. Propagate one step in Fourier space\n        u1_hat_BE = R_BE * u0_hat\n        u1_hat_CN = R_CN * u0_hat\n\n        # 4. Transform back to physical space and take the real part\n        u1_BE = np.real(np.fft.ifft(u1_hat_BE))\n        u1_CN = np.real(np.fft.ifft(u1_hat_CN))\n\n        # 5. Measure undershoot and overshoot amplitudes\n        # Undershoot is defined as the minimum value of u\n        min_u_cn = np.min(u1_CN)\n        min_u_be = np.min(u1_BE)\n        \n        # Overshoot is defined as max{u-1, 0}\n        overshoot_cn = np.max([np.max(u1_CN) - 1.0, 0.0])\n        overshoot_be = np.max([np.max(u1_BE) - 1.0, 0.0])\n\n        # 6. Compute stiff-mode amplification at Nyquist mode (theta=pi)\n        # lambda_nyq = -4*kappa/h^2, since sin(pi)=0 and sin(pi/2)=1\n        lambda_nyq = -4.0 * kappa / h**2\n        z_nyq = dt * lambda_nyq\n        \n        # G_nyq for BE\n        g_nyq_be = np.abs(1.0 / (1.0 - z_nyq))\n        \n        # G_nyq for CN\n        g_nyq_cn = np.abs((1.0 + 0.5 * z_nyq) / (1.0 - 0.5 * z_nyq))\n\n        # 7. Collect results for the current case\n        case_results = [\n            min_u_cn,\n            min_u_be,\n            overshoot_cn,\n            overshoot_be,\n            g_nyq_cn,\n            g_nyq_be\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Create '[a,b,c],[d,e,f]' string\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    # Enclose in outer '[]'\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经在线性问题中看到了L-稳定性的威力，但它的重要性在非线性问题中更为凸显，因为刚性常常源于系统本身的非线性动力学。这个练习将带你进入非线性刚性问题的世界，通过求解一个具有强非线性源项的标量ODE来揭示L-稳定性的关键作用。你将需要实现一个非线性求解器（如牛顿法）来处理隐式格式，并对比后向欧拉法（L-稳定）和隐式中点法（非L-稳定）的行为。通过这个练习，你将亲身体会到，对于某些非线性刚性问题，缺乏L-稳定性不仅会导致精度下降，甚至可能引发解的“过冲”现象，产生完全不符合物理实际的负值结果 。",
            "id": "3360266",
            "problem": "考虑一个由偏微分方程中的半离散反应项产生的标量初值问题，其抽象形式为\n$$\n\\frac{du}{dt} = -p\\big(u + f(u)\\big), \\qquad f(u)=u^p, \\qquad p1,\\qquad u(0)=1,\n$$\n其中 $p$ 是一个无量纲刚性参数，同时也是非线性的指数。$u(t)$ 的精确解保持非负，并单调递减至稳定平衡点 $u^\\star=0$。您将研究应用于此问题的两种隐式单步时间积分器的定性行为：\n- 后向欧拉法（一种 $L$-稳定方法），\n- 隐式中点法，对于常微分方程也称为 Crank-Nicolson 方法（一种 $A$-稳定但非 $L$-稳定的方法）。\n\n您必须从以下基本概念出发：\n- $A$-稳定性和 $L$-稳定性的定义，这些定义是基于线性测试方程 $\\frac{dy}{dt}=\\lambda y$ 以及与时间积分器相关的线性稳定性函数，无需预先假设任何具体公式。\n- 对于刚性问题，在当前状态附近对非线性右侧项进行局部线性化可以忠实地捕捉大刚度极限下的刚性衰减，并且此举可将分析局部地简化为具有大的负实数参数的线性测试方程——您必须基于这一概念。\n\n问题陈述中不会给出任何特定于方法的稳定性公式。相反，您必须从第一性原理出发进行推理，并使用它们定义的隐式更新方程直接在非线性问题上实现这两种方法。\n\n对于时间步长 $h0$ 和当前值 $u_n$，这两种方法由关于 $u_{n+1}$ 的隐式方程定义：\n- 后向欧拉法：求 $u_{n+1}$ 使得\n$$\nu_{n+1} = u_n + h\\Big(-p\\big(u_{n+1} + u_{n+1}^p\\big)\\Big).\n$$\n- 隐式中点法：求 $u_{n+1}$ 使得\n$$\nu_{n+1} = u_n + h\\Big(-p\\big(\\tfrac{1}{2}(u_n+u_{n+1}) + \\big(\\tfrac{1}{2}(u_n+u_{n+1})\\big)^p\\big)\\Big).\n$$\n\n为给定的方法和参数集定义过冲指示器如下：从 $u_0=1$ 开始模拟 $N$ 步，如果在任何一步中数值解变为负值，即 $\\min_{0\\leq n\\leq N} u_n  0$，则声明“过冲”(overshoot)。该指示器是一个布尔值，您必须以整数形式报告，其中 $1$ 表示“发生过冲”，$0$ 表示“未发生过冲”。\n\n设计并实现一个鲁棒的非线性求解器，用于求解每一步的上述隐式方程，该求解器需保证收敛到物理相关的解分支。不要做任何绕过求解非线性方程的假设。\n\n测试套件。使用以下参数集 $(p, h, N)$：\n- 测试 1：$p=10$, $h=0.5$, $N=3$。\n- 测试 2：$p=10$, $h=0.05$, $N=20$。\n- 测试 3：$p=100$, $h=0.1$, $N=3$。\n- 测试 4：$p=2$, $h=0.9$, $N=3$。\n- 测试 5：$p=1000$, $h=0.01$, $N=3$。\n\n您的程序必须输出单行，其中包含一个用方括号括起来的逗号分隔列表，列表内容为过冲指示器，并按每个测试“隐式中点法然后后向欧拉法”的顺序展开，即：\n$$\n[\\mathrm{IM}_1,\\mathrm{BE}_1,\\mathrm{IM}_2,\\mathrm{BE}_2,\\mathrm{IM}_3,\\mathrm{BE}_3,\\mathrm{IM}_4,\\mathrm{BE}_4,\\mathrm{IM}_5,\\mathrm{BE}_5],\n$$\n其中每个条目为 $0$ 或 $1$。不应打印任何额外文本。所有量均为无量纲，因此输出中不要求也不允许使用物理单位。角度单位不适用。不使用百分比；任何分数量必须在中间计算中表示为十进制数，但最终报告的指示器是 $\\{0,1\\}$ 中的整数。\n\n您的解答必须从第一性原理出发，论证为什么 $L$-稳定的方法可以避免过冲，而仅仅是 $A$-稳定的方法在 $p\\to\\infty$ 时会表现出过冲，以及所提供的数值实验是如何具体体现这种区别的，而无需依赖任何捷径公式。",
            "solution": "问题的核心在于，当时间积分方法应用于刚性常微分方程（ODE）时，A-稳定性与 L-稳定性之间的区别。我们从第一性原理开始定义这些概念。\n\n**A-稳定性和 L-稳定性**\nODE 数值方法的稳定性是使用 Dahlquist 的线性测试问题来分析的：\n$$\n\\frac{dy}{dt} = \\lambda y, \\qquad y(0)=y_0\n$$\n其中 $\\lambda$ 是一个复数。对于一个稳定的物理系统，$\\text{Re}(\\lambda) \\le 0$。将单步数值方法应用于此方程会得到一个形式为 $y_{n+1} = R(z) y_n$ 的递推关系，其中 $z = h\\lambda$，$R(z)$ 是该方法特有的稳定性函数。\n\n- **A-稳定性**：如果一个方法的绝对稳定区域 $S = \\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ 包含了整个左半复平面 $\\mathbb{C}^- = \\{z \\in \\mathbb{C} : \\text{Re}(z) \\le 0\\}$，则该方法是 A-稳定的。这确保了对于任何稳定的线性问题，无论时间步长 $h$ 如何，数值解都不会增长。\n\n- **L-稳定性**：如果一个方法是 A-稳定的，并且其稳定性函数还满足：\n$$\n\\lim_{|z| \\to \\infty, \\, \\text{Re}(z)0} |R(z)| = 0\n$$\n对于 $\\lambda$ 是大的负实数的刚性系统，出于实际目的，这可以简化为 $\\lim_{z \\to -\\infty} R(z) = 0$。此性质对刚性问题至关重要，因为它能确保与非常大的负特征值相对应的分量在单个时间步内被强烈衰减，从而模仿真实解的快速衰减行为。\n\n**指定方法的分析**\n\n1.  **后向欧拉法 (BE)**：将该方法应用于测试方程可得 $y_{n+1} = y_n + h\\lambda y_{n+1}$。解出 $y_{n+1}$ 可得 $y_{n+1} = \\frac{1}{1 - h\\lambda} y_n$。稳定性函数为：\n    $$\n    R_{\\text{BE}}(z) = \\frac{1}{1-z}\n    $$\n    - **A-稳定性**：对于任何 $x \\le 0$ 的 $z=x+iy$，由于 $1-x \\ge 1$，有 $|R_{\\text{BE}}(z)|^2 = \\frac{1}{(1-x)^2 + y^2} \\le 1$。因此，BE 是 A-稳定的。\n    - **L-稳定性**：当 $z \\to -\\infty$ 时，$R_{\\text{BE}}(z) \\to 0$。因此，后向欧拉法是 L-稳定的。\n\n2.  **隐式中点法 (IM)**：将该方法应用于测试方程可得 $y_{n+1} = y_n + h\\lambda \\frac{y_n+y_{n+1}}{2}$。解出 $y_{n+1}$ 可得 $y_{n+1} = \\frac{1+h\\lambda/2}{1-h\\lambda/2} y_n$。稳定性函数为：\n    $$\n    R_{\\text{IM}}(z) = \\frac{1+z/2}{1-z/2}\n    $$\n    - **A-稳定性**：对于任何 $x \\le 0$ 的 $z=x+iy$，由于 $|1+x/2| \\le |1-x/2|$，有 $|R_{\\text{IM}}(z)|^2 = \\frac{(1+x/2)^2 + (y/2)^2}{(1-x/2)^2 + (y/2)^2} \\le 1$。因此，IM 是 A-稳定的。\n    - **L-稳定性**：当 $z \\to -\\infty$ 时，$R_{\\text{IM}}(z) = \\frac{1/z + 1/2}{1/z - 1/2} \\to \\frac{1/2}{-1/2} = -1$。由于极限不为 $0$，隐式中点法不是 L-稳定的。\n\n**与非线性刚性问题及过冲的联系**\n给定问题 $\\frac{du}{dt} = -p(u+u^p)$ 对于大的 $p$ 是刚性的。局部动态由右侧项 $F(u)=-p(u+u^p)$ 的雅可比矩阵 $J(u) = -p(1+pu^{p-1})$ 决定。对于 $u_0=1$，初始“特征值”实际上是 $\\lambda \\approx J(1) = -p(1+p)$，这是一个大的负数。对于一个粗略的时间步长 $h$，乘积 $z=h\\lambda$ 可以是大的负数。\n\n- **L-稳定**的后向欧拉法，由于当 $z \\to -\\infty$ 时 $R_{\\text{BE}}(z) \\to 0$，会在第一步中极大地衰减解，从而得到一个小的正值 $u_1 \\approx 0$。这种行为可以防止非物理的振荡和过冲。\n\n- **A-稳定但非 L-稳定**的隐式中点法，由于当 $z \\to -\\infty$ 时 $R_{\\text{IM}}(z) \\to -1$，会导致解的刚性分量在没有显著衰减的情况下翻转符号，导致 $u_1 \\approx -u_0 = -1$。这是一种称为过冲的数值伪影，此时解变为负值，违反了原始问题的物理特性（其中 $u \\ge 0$）。\n\n**对给定问题过冲的严格分析**\n为了从 $u_n$ 求出 $u_{n+1}$（为清晰起见记为 $x$），我们必须求解一个非线性方程 $G(x)=0$。如果计算出的根 $x=u_{n+1}$ 为负，则表示从正状态 $u_n  0$ 发生了过冲。\n\n- **后向欧拉法**：残差为 $G_{\\text{BE}}(x) = x - u_n + hp(x+x^p) = 0$。对于 $x \\ge 0$，导数 $G'_{\\text{BE}}(x) = 1+hp+hp^2x^{p-1}$ 严格为正。由于 $G_{\\text{BE}}(0) = -u_n \\le 0$（因为我们从 $u_0=1$ 开始且解是衰减的），唯一的物理相关根 $x$ 必须是非负的。因此，通过归纳法，如果 $u_n \\ge 0$，那么 $u_{n+1} \\ge 0$。后向欧拉法不会发生过冲。\n\n- **隐式中点法**：残差为 $G_{\\text{IM}}(x) = x - u_n + hp\\left(\\frac{u_n+x}{2} + \\left(\\frac{u_n+x}{2}\\right)^p\\right) = 0$。导数 $G'_{\\text{IM}}(x) = 1 + \\frac{hp}{2} + \\frac{hp^2}{2}\\left(\\frac{u_n+x}{2}\\right)^{p-1}$ 在期望解附近为正。因此函数 $G_{\\text{IM}}(x)$ 是单调的。如果根 $u_1=x$ 为负，则在第一步（$u_0=1$）发生过冲。根据介值定理，如果 $G_{\\text{IM}}(0)  0$，这一点是保证的。\n$$\nG_{\\text{IM}}(0) = -1 + hp\\left(\\frac{1}{2} + \\left(\\frac{1}{2}\\right)^p\\right)\n$$\n如果 $hp\\left(\\frac{1}{2} + 2^{-p}\\right)  1$，则发生过冲。对于大的整数 $p$，该条件趋近于 $hp  2$。我们注意到，要发生过冲，可能需要计算负数的幂；测试套件中 $p$ 的整数值确保了该计算是良定义的。\n\n**数值实现**\n在每个时间步，使用牛顿法求解关于 $u_{n+1}$ 的隐式方程。这需要为每个积分器定义残差函数 $G(x)$ 及其导数 $G'(x)$。模拟从 $u_0=1$ 开始，进行 $N$ 步，并在每一步检查解是否变为负值。\n\n检验 IM 的条件 $hp\\left(\\frac{1}{2} + 2^{-p}\\right)  1$：\n- T1: $p=10, h=0.5 \\implies hp=5$。$5(0.5+2^{-10}) \\approx 2.5  1$ (过冲)。\n- T2: $p=10, h=0.05 \\implies hp=0.5$。$0.5(0.5+2^{-10}) \\approx 0.25  1$ (不过冲)。\n- T3: $p=100, h=0.1 \\implies hp=10$。$10(0.5+2^{-100}) \\approx 5  1$ (过冲)。\n- T4: $p=2, h=0.9 \\implies hp=1.8$。$1.8(0.5+2^{-2}) = 1.35  1$ (过冲)。\n- T5: $p=1000, h=0.01 \\implies hp=10$。$10(0.5+2^{-1000}) \\approx 5  1$ (过冲)。\n该分析预测，除了测试2之外，IM 在所有情况下都会发生过冲，而 BE 永远不会过冲。代码实现将证实这一行为。",
            "answer": "```python\nimport numpy as np\n\ndef newton_solver(g, g_prime, x0, tol=1e-12, max_iter=50):\n    \"\"\"\n    Solves the scalar nonlinear equation g(x) = 0 using Newton's method.\n    \"\"\"\n    x = float(x0)\n    for _ in range(max_iter):\n        try:\n            gx = g(x)\n            if abs(gx)  tol:\n                return x\n            gpx = g_prime(x)\n        except (ValueError, OverflowError):\n            # Handles cases like non-integer power of a negative number or overflow\n            return float('nan')\n\n        if gpx == 0:\n            return float('nan')\n        \n        x = x - gx / gpx\n    return x\n\ndef run_simulation(method, p, h, N):\n    \"\"\"\n    Runs a time integration for N steps and reports if overshoot occurs.\n    \n    Returns:\n        1 if overshoot occurred, 0 otherwise.\n    \"\"\"\n    u = 1.0\n    for _ in range(N):\n        u_n = u\n        \n        if method == 'BE':\n            # Residual g(x) = x - u_n - h * F(x) = 0\n            # F(x) = -p * (x + x**p)\n            g = lambda x: x * (1.0 + h * p) + h * p * np.power(x, p) - u_n\n            # Derivative g'(x) = 1 - h * F'(x)\n            # F'(x) = -p * (1 + p * x**(p-1))\n            g_prime = lambda x: 1.0 + h * p + h * p * p * np.power(x, p - 1)\n        \n        elif method == 'IM':\n            # Residual g(x) = x - u_n - h * F((u_n+x)/2) = 0\n            def g(x):\n                mid = (u_n + x) / 2.0\n                return x - u_n + h * p * (mid + np.power(mid, p))\n            \n            # Derivative g'(x) = 1 - h/2 * F'((u_n+x)/2)\n            def g_prime(x):\n                mid = (u_n + x) / 2.0\n                return 1.0 + h * p * (0.5 + 0.5 * p * np.power(mid, p - 1))\n        \n        else:\n            raise ValueError(\"Unknown method specified.\")\n            \n        u_next = newton_solver(g, g_prime, u_n)\n        \n        # Check for overshoot. Also catches solver failure (nan).\n        if not np.isfinite(u_next) or u_next  0:\n            return 1\n        \n        u = u_next\n           \n    return 0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (10, 0.5, 3),    # Test 1\n        (10, 0.05, 20),  # Test 2\n        (100, 0.1, 3),   # Test 3\n        (2, 0.9, 3),     # Test 4\n        (1000, 0.01, 3), # Test 5\n    ]\n\n    results = []\n    for p, h, N in test_cases:\n        # Implicit Midpoint simulation\n        im_res = run_simulation('IM', float(p), float(h), N)\n        results.append(im_res)\n        \n        # Backward Euler simulation\n        be_res = run_simulation('BE', float(p), float(h), N)\n        results.append(be_res)\n        \n    # Format and print the final output as a single line\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}