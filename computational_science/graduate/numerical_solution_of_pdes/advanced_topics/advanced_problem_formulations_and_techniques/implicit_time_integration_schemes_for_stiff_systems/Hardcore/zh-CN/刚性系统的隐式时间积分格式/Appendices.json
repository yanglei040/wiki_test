{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你从第一性原理出发，构建并分析一种特定的隐式龙格-库塔（Runge-Kutta）方法。通过推导其稳定性函数并确定A-稳定性和L-稳定性的条件，你将掌握评估时间积分格式是否适用于刚性系统的核心技能。这项实践旨在深化你对数值稳定性理论的理解，这是设计和选择高效积分器的理论基石。",
            "id": "3407002",
            "problem": "考虑一个由抛物型偏微分方程空间离散化得到的刚性半离散发展系统，写为常微分方程 (ODE) $y'(t) = F(y(t))$，其中状态向量为 $y(t) \\in \\mathbb{R}^{m}$ 且 $F : \\mathbb{R}^{m} \\to \\mathbb{R}^{m}$。您将构建一个两级单对角隐式龙格-库塔 (Singly Diagonally Implicit Runge–Kutta, SDIRK) 方法，该方法具有一个公共对角系数 $\\gamma$（两个阶段相同）和刚性精确性质，这意味着数值解的更新使用与龙格-库塔系数矩阵最后一行相同的最后阶段权重。设时间步长为 $h > 0$，阶段值记为 $Y_{1}$ 和 $Y_{2}$，并定义 $k_{1} = F(Y_{1})$，$k_{2} = F(Y_{2})$。\n\n任务：\n1. 从龙格-库塔方法的核心定义、SDIRK 结构和刚性精确性质出发，推导以 $\\gamma$、$h$ 和前一个解 $y_{n}$ 表示的显式阶段方程 $Y_{1}$ 和 $Y_{2}$ 以及更新公式 $y_{n+1}$，并确保该方法的横坐标满足 $c_{1} = \\gamma$ 和 $c_{2} = 1$。\n2. 使用线性检验方程 $y'(t) = \\lambda y(t)$（其中复数 $\\lambda$ 满足 $\\operatorname{Re}(\\lambda) \\le 0$），为所构建的两级 SDIRK 方法推导稳定性函数 $R(z)$（其中 $z = h \\lambda$）。不要假设 $R(z)$ 有任何预先存在的形式；而是直接从阶段方程和更新公式推导它。\n3. 从第一性原理出发，确定使该方法 A-稳定 的 $\\gamma$ 条件，即确保整个闭左半复平面都位于该方法绝对稳定区域内的条件。您的答案必须以关于 $\\gamma$ 的解析条件给出。\n4. 评估稳定性函数在 $\\operatorname{Re}(z) \\to -\\infty$ 的射线上当 $|z|$ 很大时的渐近行为，并确定该方法是否是 L-稳定的。明确说明 L-稳定性成立时 $\\gamma$ 所需满足的条件。\n5. 施加两级龙格-库塔方法的经典二阶精度条件，并确定在 $(0,1)$ 区间内唯一的 $\\gamma$ 值，使其同时实现二阶精度和 L-稳定性。将您的最终答案表示为关于 $\\gamma$ 的精确闭式解析表达式。最终答案无需进行数值舍入。",
            "solution": "该问题被验证为具有科学依据、适定且客观。它是常微分方程数值分析领域的标准问题，提供了所有必要信息且无矛盾。\n\n用于求解常微分方程 $y'(t) = F(y(t))$ 的一般两级龙格-库塔方法由以下方程定义：\n$$ Y_1 = y_n + h (a_{11} F(Y_1) + a_{12} F(Y_2)) $$\n$$ Y_2 = y_n + h (a_{21} F(Y_1) + a_{22} F(Y_2)) $$\n$$ y_{n+1} = y_n + h (b_1 F(Y_1) + b_2 F(Y_2)) $$\n系数由 Butcher 表定义：\n$$\n\\begin{array}{c|cc}\nc_1  a_{11}  a_{12} \\\\\nc_2  a_{21}  a_{22} \\\\\n\\hline\n     b_1  b_2\n\\end{array}\n$$\n该问题对此一般形式规定了几个约束条件。\n首先，它是一个具有公共对角系数 $\\gamma$ 的单对角隐式龙格-库塔 (SDIRK) 方法。这意味着系数矩阵 $A = (a_{ij})$ 是下三角矩阵（当 $ji$ 时 $a_{ij}=0$），且对角元素相等（$a_{11}=a_{22}=\\gamma$）。Butcher 表变为：\n$$\n\\begin{array}{c|cc}\nc_1  \\gamma  0 \\\\\nc_2  a_{21}  \\gamma \\\\\n\\hline\n     b_1  b_2\n\\end{array}\n$$\n其次，横坐标给定为 $c_1 = \\gamma$ 和 $c_2 = 1$。横坐标必须满足相容性条件 $c_i = \\sum_{j=1}^2 a_{ij}$。对于 $i=1$，我们有 $c_1 = a_{11} + a_{12}$，即 $\\gamma = \\gamma + 0$，这是一个相容的关系。对于 $i=2$，我们有 $c_2 = a_{21} + a_{22}$，得到 $1 = a_{21} + \\gamma$，所以 $a_{21} = 1 - \\gamma$。\n第三，该方法是刚性精确的。这意味着解的更新使用最后一个阶段，即 $y_{n+1} = Y_2$。就 Butcher 表系数而言，此性质意味着权重 $b_j$ 等于系数矩阵 $A$ 的最后一行。因此，$b_1 = a_{21} = 1-\\gamma$ 且 $b_2 = a_{22} = \\gamma$。\n综合这些约束，Butcher 表完全由参数 $\\gamma$ 确定：\n$$\n\\begin{array}{c|cc}\n\\gamma  \\gamma  0 \\\\\n1       1-\\gamma  \\gamma \\\\\n\\hline\n        1-\\gamma  \\gamma\n\\end{array}\n$$\n\n**1. 阶段方程和更新公式的推导**\n使用已确定的 Butcher 表，我们可以写出显式阶段方程。设 $k_1 = F(Y_1)$ 和 $k_2 = F(Y_2)$。\n第一个阶段方程为：\n$$ Y_1 = y_n + h (a_{11} k_1 + a_{12} k_2) = y_n + h (\\gamma k_1 + 0 \\cdot k_2) $$\n$$ Y_1 = y_n + h \\gamma F(Y_1) $$\n第二个阶段方程为：\n$$ Y_2 = y_n + h (a_{21} k_1 + a_{22} k_2) = y_n + h ((1-\\gamma) k_1 + \\gamma k_2) $$\n$$ Y_2 = y_n + h((1-\\gamma)F(Y_1) + \\gamma F(Y_2)) $$\n由于具有刚性精确性质，更新公式就是最后一个阶段的值：\n$$ y_{n+1} = Y_2 $$\n这些方程定义了该方法。它们是隐式的，因为 $Y_1$ 和 $Y_2$ 出现在它们各自定义方程的两边。\n\n**2. 稳定性函数 $R(z)$ 的推导**\n为了求稳定性函数，我们将该方法应用于线性检验方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$ 且 $\\operatorname{Re}(\\lambda) \\le 0$。对于此方程，$F(y) = \\lambda y$。设 $z = h \\lambda$。\n阶段方程变为：\n$$ Y_1 = y_n + h \\gamma (\\lambda Y_1) = y_n + z \\gamma Y_1 $$\n$$ Y_2 = y_n + h ((1-\\gamma) \\lambda Y_1 + \\gamma \\lambda Y_2) = y_n + z(1-\\gamma) Y_1 + z \\gamma Y_2 $$\n首先，我们求解第一个阶段方程得到 $Y_1$：\n$$ Y_1 (1 - z \\gamma) = y_n \\implies Y_1 = \\frac{1}{1 - z \\gamma} y_n $$\n接下来，我们求解第二个阶段方程得到 $Y_2$：\n$$ Y_2 (1 - z \\gamma) = y_n + z(1-\\gamma) Y_1 $$\n代入 $Y_1$ 的表达式：\n$$ Y_2 (1 - z \\gamma) = y_n + z(1-\\gamma) \\left( \\frac{1}{1 - z \\gamma} \\right) y_n $$\n$$ Y_2 = \\frac{1}{1 - z \\gamma} y_n + \\frac{z(1-\\gamma)}{(1 - z \\gamma)^2} y_n $$\n$$ Y_2 = \\left( \\frac{1 - z \\gamma + z(1-\\gamma)}{(1 - z \\gamma)^2} \\right) y_n $$\n$$ Y_2 = \\left( \\frac{1 - z \\gamma + z - z\\gamma}{(1 - z \\gamma)^2} \\right) y_n $$\n$$ Y_2 = \\left( \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} \\right) y_n $$\n数值解的更新为 $y_{n+1} = Y_2$。稳定性函数由 $y_{n+1} = R(z) y_n$ 定义。因此：\n$$ R(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} $$\n\n**3. A-稳定性的条件**\n如果一个数值方法的绝对稳定区域包含整个左半复平面 $\\mathbb{C}^- = \\{ z \\in \\mathbb{C} \\mid \\operatorname{Re}(z) \\le 0 \\}$，则该方法是 A-稳定的。对于有理稳定性函数 $R(z)$，这需要满足两个条件：\n(i) $R(z)$ 在开左半复平面 $\\operatorname{Re}(z)  0$ 内必须是解析的。$R(z)$ 的极点由 $(1-\\gamma z)^2 = 0$ 给出，即 $z = 1/\\gamma$。为了在开左半复平面内解析，极点不能在该区域内，即 $\\operatorname{Re}(1/\\gamma) \\ge 0$。由于 $\\gamma$ 是实数，这意味着 $1/\\gamma \\ge 0$，因此我们必须有 $\\gamma  0$。\n(ii) 在区域的边界，即虚轴上，对于所有 $\\omega \\in \\mathbb{R}$，必须有 $|R(i\\omega)| \\le 1$。\n让我们计算 $|R(i\\omega)|^2$：\n$$ |R(i\\omega)|^2 = \\left| \\frac{1 + (1 - 2\\gamma)i\\omega}{(1 - i\\gamma\\omega)^2} \\right|^2 = \\frac{|1 + i(1-2\\gamma)\\omega|^2}{|(1 - i\\gamma\\omega)^2|^2} = \\frac{1^2 + ((1-2\\gamma)\\omega)^2}{(|1-i\\gamma\\omega|^2)^2} $$\n$$ |R(i\\omega)|^2 = \\frac{1 + (1-2\\gamma)^2\\omega^2}{(1+\\gamma^2\\omega^2)^2} $$\n条件 $|R(i\\omega)|^2 \\le 1$ 变为：\n$$ 1 + (1-2\\gamma)^2\\omega^2 \\le (1+\\gamma^2\\omega^2)^2 $$\n$$ 1 + (1 - 4\\gamma + 4\\gamma^2)\\omega^2 \\le 1 + 2\\gamma^2\\omega^2 + \\gamma^4\\omega^4 $$\n两边减去 $1$ 并除以 $\\omega^2$（对于 $\\omega \\neq 0$）：\n$$ 1 - 4\\gamma + 4\\gamma^2 \\le 2\\gamma^2 + \\gamma^4\\omega^2 $$\n$$ 1 - 4\\gamma + 2\\gamma^2 \\le \\gamma^4\\omega^2 $$\n这个不等式必须对所有 $\\omega \\in \\mathbb{R}$ 成立。右边是非负的（假设 $\\gamma$ 为实数），其最小值为 $0$，在 $\\omega=0$ 时取到。因此，该不等式必须对这个最小值成立，从而得到条件：\n$$ 2\\gamma^2 - 4\\gamma + 1 \\le 0 $$\n这是 $\\gamma$ 满足 A-稳定性的条件，需与 $\\gamma  0$ 结合。二次方程 $2\\gamma^2 - 4\\gamma + 1 = 0$ 的根为 $\\gamma = \\frac{4 \\pm \\sqrt{16-8}}{4} = 1 \\pm \\frac{\\sqrt{2}}{2}$。由于该二次函数图像开口向上，不等式在两根之间成立。范围 $1 - \\frac{\\sqrt{2}}{2} \\approx 0.293  0$，所以条件 $\\gamma0$ 被满足。条件是 $\\gamma \\in [1 - \\frac{\\sqrt{2}}{2}, 1 + \\frac{\\sqrt{2}}{2}]$。\n\n**4. L-稳定性分析**\n如果一个方法是 A-稳定的，并且其稳定性函数满足 $\\lim_{|z|\\to\\infty, \\operatorname{Re}(z) \\le 0} |R(z)| = 0$，则该方法是 L-稳定的。对于像 $R(z)$ 这样的有理函数，这等价于要求 A-稳定性以及 $\\lim_{z\\to\\infty} R(z) = 0$。后一个条件在分子多项式的次数严格小于分母多项式的次数时成立。\n我们的稳定性函数是：\n$$ R(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2} = \\frac{(1-2\\gamma)z + 1}{\\gamma^2 z^2 - 2\\gamma z + 1} $$\n假设 $\\gamma \\neq 0$，分母的次数是 $2$。如果 $1-2\\gamma \\neq 0$（即 $\\gamma \\neq 1/2$），分子的次数是 $1$；如果 $1-2\\gamma = 0$（即 $\\gamma=1/2$），分子的次数是 $0$。无论哪种情况，分子的次数都严格小于分母的次数。\n因此，对于任何 $\\gamma \\neq 0$，我们有 $\\lim_{z\\to\\infty} R(z) = 0$。A-稳定性条件要求 $\\gamma0$。所以，这种形式的任何 A-稳定方法都会自动成为 L-稳定方法。L-稳定性的条件与 A-稳定性的条件相同：\n$$ 2\\gamma^2 - 4\\gamma + 1 \\le 0 $$\n\n**5. 二阶精度和 L-稳定性**\n龙格-库塔方法达到二阶精度的阶条件是：\n1 阶条件：$\\sum_{i=1}^2 b_i = 1$。我们的方法有 $b_1 = 1-\\gamma$ 和 $b_2 = \\gamma$，所以 $\\sum b_i = (1-\\gamma) + \\gamma = 1$。对于任意 $\\gamma$，该方法至少是一阶的。\n2 阶条件：$\\sum_{i=1}^2 b_i c_i = 1/2$。我们的方法有 $c_1=\\gamma$ 和 $c_2=1$。条件是：\n$$ b_1 c_1 + b_2 c_2 = (1-\\gamma)\\gamma + \\gamma(1) = \\gamma - \\gamma^2 + \\gamma = 2\\gamma - \\gamma^2 $$\n令其等于 $1/2$：\n$$ 2\\gamma - \\gamma^2 = \\frac{1}{2} $$\n乘以 $2$ 并重新整理得到二次方程：\n$$ 4\\gamma - 2\\gamma^2 = 1 \\implies 2\\gamma^2 - 4\\gamma + 1 = 0 $$\n这恰好是定义 A-稳定性和 L-稳定性区域边界的方程。根为 $\\gamma = 1 \\pm \\frac{\\sqrt{2}}{2}$。\n问题要求找到唯一的 $\\gamma \\in (0,1)$。\n两个根是 $\\gamma_1 = 1 - \\frac{\\sqrt{2}}{2}$ 和 $\\gamma_2 = 1 + \\frac{\\sqrt{2}}{2}$。数值上，$\\sqrt{2} \\approx 1.414$，所以 $\\gamma_1 \\approx 1 - 0.707 = 0.293$ 且 $\\gamma_2 \\approx 1 + 0.707 = 1.707$。\n在区间 $(0,1)$ 内唯一的根是 $\\gamma_1 = 1 - \\frac{\\sqrt{2}}{2}$。\n对于这个 $\\gamma$ 值，L-稳定性条件 $2\\gamma^2 - 4\\gamma + 1 \\le 0$ 是满足的，因为 $2\\gamma^2 - 4\\gamma + 1 = 0$。\n因此，在 $(0,1)$ 区间内同时实现二阶精度和 L-稳定性的唯一 $\\gamma$ 值是 $\\gamma = 1 - \\frac{\\sqrt{2}}{2}$。",
            "answer": "$$\\boxed{1 - \\frac{\\sqrt{2}}{2}}$$"
        },
        {
            "introduction": "理论和实践之间有时会存在差距，本练习旨在通过一个经典的计算案例来揭示这一点。你将实现梯形法则（Crank-Nicolson方法）来求解一个带有时变边界条件的抛物线型偏微分方程，并亲手验证一个著名的现象：“阶数退化”（order reduction）。通过这个动手编程任务，你将直观地理解为何一个理论上的二阶方法在求解某些刚性问题时，其实际收敛阶会降至一阶。",
            "id": "3406952",
            "problem": "考虑一维热方程，它是一个线性抛物型偏微分方程 (PDE)，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t), \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n服从狄利克雷边界条件\n$$\nu(0,t) = g_0(t), \\quad u(1,t) = g_1(t),\n$$\n和一个初始条件\n$$\nu(x,0) = u_0(x),\n$$\n其中 $u$ 是温度，$\\alpha$ 是热扩散系数，$f$ 是一个源项，$g_0$、$g_1$ 是给定的边界数据。使用方法线法 (MOL)，在具有 $M$ 个内部点的均匀网格上，用二阶中心差分离散化空间算子，并应用梯形法则（也称为 Crank–Nicolson 方法）进行时间积分。通过将非齐次狄利克雷边界条件的贡献纳入半离散右端项中，来一致地处理它们。在最大范数（无穷范数）下量化时间上的经验收敛阶，并分析带有非齐次边界条件的刚性系统的降阶现象。\n\n将推导和实现建立在以下基本且被广泛接受的事实之上：\n- 在间距为 $h$ 的均匀网格上，二阶导数的二阶中心差分近似由三点格式给出。\n- 对于常微分方程 (ODE)，梯形法则是隐式的、A-稳定的二阶格式。\n- 随着空间网格的加密，半离散抛物型偏微分方程的刚性会增加，其离散拉普拉斯算子的特征值与 $h^{-2}$ 成比例。\n\n实施一种人工解方法来设置 $f$、$g_0$、$g_1$ 和 $u_0$，从而使精确解已知。对于下文的每个测试案例，使用一系列时间步长计算在时间 $T$ 时的数值解，并测量内部网格上的最大范数误差。然后，通过对所提供的时间步长上的 $\\log_{10}(E(\\Delta t))$ 与 $\\log_{10}(\\Delta t)$ 进行最小二乘线性拟合来估计观测到的收敛阶 $p$，其中 $E(\\Delta t)$ 表示最终时刻的最大范数误差，$\\Delta t$ 是时间步长。\n\n使用以下测试套件，所有测试均设置 $\\alpha = 1$ 和 $T = 1$：\n\n- 案例 A（非齐次狄利克雷边界条件，平滑的时间依赖性）：\n  - 精确解：$u(x,t) = e^{-t}\\left(\\sin(\\pi x) + x\\right)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = e^{-t}$。\n  - 源项：$f(x,t) = e^{-t}\\left((\\pi^2 - 1)\\sin(\\pi x) - x\\right)$。\n  - 空间分辨率：$M = 400$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n- 案例 B（齐次狄利克雷边界条件）：\n  - 精确解：$u(x,t) = e^{-t}\\sin(\\pi x)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = 0$。\n  - 源项：$f(x,t) = e^{-t}(\\pi^2 - 1)\\sin(\\pi x)$。\n  - 空间分辨率：$M = 400$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n- 案例 C（非齐次狄利克雷边界条件，通过更细的网格增强刚性）：\n  - 精确解：$u(x,t) = e^{-t^2}\\left(\\sin(\\pi x) + x\\right)$。\n  - 边界数据：$g_0(t) = 0$, $g_1(t) = e^{-t^2}$。\n  - 源项：$f(x,t) = e^{-t^2}\\left(\\pi^2\\sin(\\pi x) - 2t\\left(\\sin(\\pi x) + x\\right)\\right)$。\n  - 空间分辨率：$M = 1600$ 个内部点。\n  - 时间步长：$\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$。\n\n对每个案例，按以下步骤进行：\n- 构建内部网格点 $x_i = i h$，其中 $i = 1,2,\\dots,M$，$h = \\frac{1}{M+1}$。\n- 使用二阶中心差分离散化和适当的随时间变化的边界注入，为内部未知数构建半离散刚性 ODE 系统，得到形式为 $\\mathbf{y}'(t) = A\\mathbf{y}(t) + \\mathbf{b}(t)$ 的 ODE，其中 $A$ 是由 $\\alpha$ 缩放的离散拉普拉斯算子，$\\mathbf{b}(t)$ 则包含了边界数据和源项。\n- 从精确的内部初始条件开始，对每个给定的 $\\Delta t$ 应用梯形法则于 $\\mathbf{y}'(t) = A\\mathbf{y}(t) + \\mathbf{b}(t)$ 进行时间推进，并计算在 $t = T$ 时的数值解。\n- 计算在 $t = T$ 时的最大范数误差为 $E(\\Delta t) = \\max_i \\left|y_i^{\\text{num}}(T) - u(x_i,T)\\right|$。\n- 通过最小二乘法对点 $\\left(\\log_{10}(\\Delta t), \\log_{10}(E(\\Delta t))\\right)$ 进行线性拟合来估计观测阶 $p$，并报告其斜率 $p$。\n\n您的程序应生成单行输出，其中包含案例 A、案例 B 和案例 C 的三个观测阶 $p$，以逗号分隔的列表形式并用方括号括起（例如，“[pA,pB,pC]”）。所有计算均为纯数学计算，不需要物理单位。此问题中不出现角度。此问题中不出现百分比。",
            "solution": "为了分析梯形法则（Crank–Nicolson 方法）在处理带非齐次狄利克雷边界条件的一维热方程时的降阶现象，我们从抛物型偏微分方程的标准形式开始\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t) + f(x,t), \\quad x \\in (0,1), \\ t \\in (0,T],\n$$\n其边界条件为 $u(0,t)=g_0(t)$ 和 $u(1,t)=g_1(t)$，初始条件为 $u(x,0)=u_0(x)$。\n\n方法线法 (MOL) 将空间算子离散化，同时保持时间连续，从而产生一个常微分方程 (ODE) 的刚性系统。使用一个包含 $M$ 个内部点 $x_i = i h$（其中 $i=1,\\dots,M$，$h=(M+1)^{-1}$）的均匀网格，二阶导数由二阶中心差分近似为\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t) \\approx \\frac{u_{i-1}(t) - 2u_i(t) + u_{i+1}(t)}{h^2}.\n$$\n对于狄利克雷边界条件，$u_0(t)=g_0(t)$ 和 $u_{M+1}(t)=g_1(t)$ 是已知值，通过一个随时间变化的边界注入向量进入半离散 ODE。将内部未知数表示为 $\\mathbf{y}(t) \\in \\mathbb{R}^M$，其分量为 $y_i(t)=u(x_i,t)$，并将离散拉普拉斯矩阵 $L \\in \\mathbb{R}^{M \\times M}$ 定义为三对角矩阵，其主对角线元素为 $-2/h^2$，次对角线和超对角线元素为 $1/h^2$。半离散 ODE 可写为\n$$\n\\mathbf{y}'(t) = \\alpha L \\mathbf{y}(t) + \\alpha \\mathbf{b}_{\\text{bc}}(t) + \\mathbf{f}(t),\n$$\n其中 $\\mathbf{b}_{\\text{bc}}(t) \\in \\mathbb{R}^M$ 除了第一个分量（接收 $g_0(t)/h^2$）和最后一个分量（接收 $g_1(t)/h^2$）外，其余分量均为零，而 $\\mathbf{f}(t) \\in \\mathbb{R}^M$ 是源项 $f(x_i,t)$ 的内部采样。\n\n我们现在将梯形法则应用于非自治线性 ODE\n$$\n\\mathbf{y}'(t) = A \\mathbf{y}(t) + \\mathbf{b}(t), \\quad \\text{with } A = \\alpha L, \\ \\mathbf{b}(t) = \\alpha \\mathbf{b}_{\\text{bc}}(t) + \\mathbf{f}(t).\n$$\n梯形法则通过以下方式从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left( A \\mathbf{y}_{n} + \\mathbf{b}(t_n) + A \\mathbf{y}_{n+1} + \\mathbf{b}(t_{n+1}) \\right),\n$$\n这可以重新整理为线性系统\n$$\n\\left(I - \\frac{\\Delta t}{2} A \\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{\\Delta t}{2} A \\right) \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left( \\mathbf{b}(t_n) + \\mathbf{b}(t_{n+1}) \\right).\n$$\n由于 $A$ 是刚性的（其谱半径与 $h^{-2}$ 成比例），该系统必须在每个时间步长上进行隐式求解。我们预先计算矩阵 $I \\pm \\frac{\\Delta t}{2} A$，并使用直接稀疏求解器来高效处理具有相同 $\\Delta t$ 的多个时间步。\n\n为了测试降阶现象，我们采用人工解，该解一致地定义了 $u(x,t)$、$g_0(t)$、$g_1(t)$ 和 $f(x,t)$，从而使得内部精确解在所有时间点都是已知的。我们考虑三个案例：\n- 案例 A：$u(x,t) = e^{-t}\\left(\\sin(\\pi x) + x\\right)$，其中 $g_0(t) = 0$，$g_1(t) = e^{-t}$，以及 $f(x,t) = e^{-t}\\left((\\pi^2 - 1)\\sin(\\pi x) - x\\right)$。\n- 案例 B：$u(x,t) = e^{-t}\\sin(\\pi x)$，其中 $g_0(t) = 0$，$g_1(t) = 0$，以及 $f(x,t) = e^{-t}(\\pi^2 - 1)\\sin(\\pi x)$。\n- 案例 C：$u(x,t) = e^{-t^2}\\left(\\sin(\\pi x) + x\\right)$，其中 $g_0(t) = 0$，$g_1(t) = e^{-t^2}$，以及 $f(x,t) = e^{-t^2}\\left(\\pi^2\\sin(\\pi x) - 2t\\left(\\sin(\\pi x) + x\\right)\\right)$。\n\n对于每个案例，我们设置 $\\alpha = 1$、$T = 1$，并使用各自的 $M$ 值（案例 A 和案例 B 为 $M=400$，案例 C 为 $M=1600$）。然后我们用 $\\Delta t \\in \\left\\{\\frac{1}{20}, \\frac{1}{40}, \\frac{1}{80}, \\frac{1}{160}\\right\\}$ 进行积分，并计算最终时刻的最大范数误差\n$$\nE(\\Delta t) = \\max_{1 \\le i \\le M} \\left| y_i^{\\text{num}}(T) - u(x_i,T) \\right|.\n$$\n为了估计观测阶 $p$，我们对点 $\\left( \\log_{10}(\\Delta t), \\log_{10}(E(\\Delta t)) \\right)$ 进行最小二乘直线拟合；这条线的斜率即为经验收敛阶 $p$：\n$$\np \\approx \\text{slope of } \\log_{10}(E(\\Delta t)) \\text{ versus } \\log_{10}(\\Delta t).\n$$\n\n降阶的原理性解释：对于足够光滑的非刚性 ODE，梯形法则是全局二阶精确的。然而，对于由半离散抛物型 PDE 产生的刚性系统，随时间变化的非齐次边界条件的存在会引入一个非自治的强迫项 $\\mathbf{b}(t)$，该强迫项在每个时间步都会激发刚性空间模式。在无穷范数中，这些由边界驱动的层可能主导全局误差，除非该方法经过特殊设计，对非自治项具有刚性精度，或者采用了边界校正，否则在最大范数下观测到的时间收敛阶可能会从二阶降至约一阶。相比之下，对于齐次狄利克雷边界条件，强迫项不会引入随时间变化的边界层，梯形法则通常能保持二阶的最大范数精度。\n\n算法如下：\n- 对每个 $\\Delta t$ 构建离散拉普拉斯算子 $L$ 和稀疏矩阵 $I \\pm \\frac{\\Delta t}{2}A$。\n- 预先计算 $I - \\frac{\\Delta t}{2}A$ 的稀疏分解，以高效求解线性系统。\n- 使用梯形更新进行时间推进，并采用一致的边界注入和源项采样。\n- 计算最终时刻的最大范数误差，并进行拟合以获得 $p$。\n\n程序最终以单行 \"[pA,pB,pC]\" 的格式输出案例 A、案例 B 和案例 C 的三个观测阶 $p$。基于理论和经验证据，我们预计对于非齐次边界条件（案例 A 和案例 C），收敛阶约为一阶；对于齐次边界条件（案例 B），收敛阶约为二阶。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import splu\n\ndef build_laplacian_matrix(M, h, alpha=1.0):\n    \"\"\"\n    Build the discrete Laplacian with Dirichlet boundary conditions on M interior points.\n    L is tridiagonal with -2/h^2 on diagonal and 1/h^2 on off-diagonals, scaled by alpha.\n    \"\"\"\n    main = (-2.0 / h**2) * np.ones(M)\n    off = (1.0 / h**2) * np.ones(M - 1)\n    L = diags([off, main, off], offsets=[-1, 0, 1], shape=(M, M), format='csc')\n    return alpha * L\n\ndef trapezoidal_time_integration(M, T, dt, alpha, u_exact, f_fun, g0_fun, g1_fun):\n    \"\"\"\n    Integrate the semi-discrete system y' = A y + b(t), with A = alpha*L,\n    where b(t) = alpha*bc(t) + f(t), bc encodes Dirichlet boundary injection.\n    Return the infinity-norm error at time T.\n    \"\"\"\n    h = 1.0 / (M + 1)\n    x = (np.arange(1, M + 1)) * h\n\n    # Build A = alpha*L\n    A = build_laplacian_matrix(M, h, alpha=alpha)\n    I = diags([np.ones(M)], [0], shape=(M, M), format='csc')\n\n    # Precompute matrices for trapezoidal rule\n    M_lhs = (I - (dt / 2.0) * A).tocsc()\n    M_rhs = (I + (dt / 2.0) * A).tocsc()\n    # Factorize LHS matrix for repeated solves\n    lu = splu(M_lhs)\n\n    # Initial condition from exact solution at t=0\n    y = u_exact(x, 0.0)\n\n    # Number of time steps\n    N_steps = int(round(T / dt))\n    # March in time\n    t = 0.0\n    for n in range(N_steps):\n        t_n = t\n        t_np1 = t + dt\n\n        # Boundary injection vectors at t_n and t_{n+1}\n        bc_n = np.zeros(M)\n        bc_np1 = np.zeros(M)\n        g0_n = g0_fun(t_n)\n        g1_n = g1_fun(t_n)\n        g0_np1 = g0_fun(t_np1)\n        g1_np1 = g1_fun(t_np1)\n        # Injection: first and last entries incorporate boundary values scaled by 1/h^2\n        bc_n[0] = g0_n / h**2\n        bc_n[-1] = g1_n / h**2\n        bc_np1[0] = g0_np1 / h**2\n        bc_np1[-1] = g1_np1 / h**2\n\n        # Source term vectors at t_n and t_{n+1}\n        f_n = f_fun(x, t_n)\n        f_np1 = f_fun(x, t_np1)\n\n        # Assemble RHS: (I + dt/2 A) y_n + dt/2 [alpha*(bc_n + bc_np1) + (f_n + f_np1)]\n        rhs = M_rhs.dot(y) + (dt / 2.0) * (alpha * (bc_n + bc_np1) + (f_n + f_np1))\n\n        # Solve for y_{n+1}\n        y = lu.solve(rhs)\n\n        t = t_np1\n\n    # Compute exact solution at final time and error in infinity norm\n    y_exact_T = u_exact(x, T)\n    err = np.max(np.abs(y - y_exact_T))\n    return err\n\ndef observed_order(errors, dts):\n    \"\"\"\n    Estimate observed order p by least-squares fit of log10(error) vs log10(dt).\n    \"\"\"\n    log_dt = np.log10(np.array(dts))\n    log_err = np.log10(np.array(errors))\n    # Fit line: log_err = p*log_dt + c\n    p, c = np.polyfit(log_dt, log_err, 1)\n    return float(p)\n\n# Manufactured solutions and data for the test cases\ndef case_A_data():\n    alpha = 1.0\n    M = 400\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t) * (sin(pi x) + x)\n    def u_exact(x, t):\n        return np.exp(-t) * (np.sin(np.pi * x) + x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return np.exp(-t)\n    # f(x,t) = exp(-t) * ((pi^2 - 1) sin(pi x) - x)\n    def f_fun(x, t):\n        return np.exp(-t) * ((np.pi**2 - 1.0) * np.sin(np.pi * x) - x)\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef case_B_data():\n    alpha = 1.0\n    M = 400\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t) * sin(pi x)\n    def u_exact(x, t):\n        return np.exp(-t) * np.sin(np.pi * x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return 0.0\n    # f(x,t) = exp(-t) * (pi^2 - 1) * sin(pi x)\n    def f_fun(x, t):\n        return np.exp(-t) * (np.pi**2 - 1.0) * np.sin(np.pi * x)\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef case_C_data():\n    alpha = 1.0\n    M = 1600\n    T = 1.0\n    dts = [1/20, 1/40, 1/80, 1/160]\n    # Exact solution: u(x,t) = exp(-t^2) * (sin(pi x) + x)\n    def u_exact(x, t):\n        return np.exp(-t**2) * (np.sin(np.pi * x) + x)\n    def g0_fun(t):\n        return 0.0\n    def g1_fun(t):\n        return np.exp(-t**2)\n    # f(x,t) = exp(-t^2) * (pi^2 sin(pi x) - 2 t (sin(pi x) + x))\n    def f_fun(x, t):\n        return np.exp(-t**2) * (np.pi**2 * np.sin(np.pi * x) - 2.0 * t * (np.sin(np.pi * x) + x))\n    return alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun\n\ndef run_case(alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun):\n    errors = []\n    for dt in dts:\n        err = trapezoidal_time_integration(M, T, dt, alpha, u_exact, f_fun, g0_fun, g1_fun)\n        errors.append(err)\n    p = observed_order(errors, dts)\n    return p\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = [case_A_data(), case_B_data(), case_C_data()]\n    results = []\n    for alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun in cases:\n        p = run_case(alpha, M, T, dts, u_exact, f_fun, g0_fun, g1_fun)\n        # For stability in printing, limit to a reasonable number of decimals\n        results.append(f\"{p:.6f}\")\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在处理包含瞬态行为或不连续源项的刚性系统时，数值方法的初始几步表现至关重要。本练习将通过一个包含阶跃源项的对流扩散问题，深入探究隐式龙格-库塔方法的“阶段阶”（stage order）如何影响初始瞬态的计算精度。通过比较几种具有不同阶段阶的方法，你将揭示为何高阶段阶对于准确捕捉由系统突变引起的快速动态响应是必不可少的。",
            "id": "3407004",
            "problem": "考虑周期性域上的一维对流-扩散偏微分方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2} + s(t)\\, \\sin(2\\pi x),\n$$\n其在区间 $[0,L)$ 上具有周期性边界条件，对流速度 $a \\gt 0$，扩散系数 $\\nu \\gt 0$，$s(t)$ 为 Heaviside 阶跃函数，即当 $t \\lt 0$ 时 $s(t) = 0$，当 $t \\ge 0$ 时 $s(t) = 1$。设初始条件为 $u(x,0) = 0$。使用 $N$ 个均匀间隔的网格点 $x_i = i \\Delta x$（其中 $\\Delta x = L/N$）对空间进行离散化，并对对流项应用一阶迎风格式，对扩散项应用二阶中心差分。将得到的半离散系统表示为\n$$\n\\frac{d \\mathbf{y}}{dt} = A \\mathbf{y} + \\mathbf{r}, \\quad \\mathbf{y}(0) = \\mathbf{0},\n$$\n其中 $\\mathbf{y}(t) \\in \\mathbb{R}^N$，$A \\in \\mathbb{R}^{N \\times N}$ 是代表空间离散化的矩阵，$\\mathbf{r} \\in \\mathbb{R}^N$ 是离散强迫向量，其分量为 $r_i = \\sin(2\\pi x_i)$。迎风和扩散差分格式为\n$$\n(D_{\\text{up}} \\mathbf{y})_i = \\frac{\\mathbf{y}_i - \\mathbf{y}_{i-1}}{\\Delta x}, \\quad (L \\mathbf{y})_i = \\frac{\\mathbf{y}_{i+1} - 2 \\mathbf{y}_i + \\mathbf{y}_{i-1}}{\\Delta x^2},\n$$\n其中索引为周期性的，算子矩阵为\n$$\nA = -a D_{\\text{up}} + \\nu L.\n$$\n\n研究当扩散项占主导地位且源项在 $t=0^{+}$ 时刻开启时，对此刚性半离散系统在时间 $t=h$ 处使用单步隐式 Runge–Kutta (IRK) 时间积分的精度。具体而言，实现以下由其 Butcher 表征的 IRK 格式：\n\n1. Backward Euler（单级，阶序为 $1$）：\n$$\nc = \\begin{bmatrix} 1 \\end{bmatrix}, \\quad\nA_{\\text{RK}} = \\begin{bmatrix} 1 \\end{bmatrix}, \\quad\nb = \\begin{bmatrix} 1 \\end{bmatrix}.\n$$\n\n2. 一个双级 Singly Diagonally Implicit Runge–Kutta (SDIRK) 方法，参数 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$（阶序为 $1$）：\n$$\nc = \\begin{bmatrix} \\gamma \\\\ 1 \\end{bmatrix}, \\quad\nA_{\\text{RK}} = \\begin{bmatrix} \\gamma  0 \\\\ 1 - \\gamma  \\gamma \\end{bmatrix}, \\quad\nb = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{2} \\end{bmatrix}.\n$$\n\n3. 三阶双级 Radau IIA 方法（阶序为 $2$）：\n$$\nc = \\begin{bmatrix} \\tfrac{1}{3} \\\\ 1 \\end{bmatrix}, \\quad\nA_{\\text{RK}} = \\begin{bmatrix} \\tfrac{5}{12}  -\\tfrac{1}{12} \\\\ \\tfrac{3}{4}  \\tfrac{1}{4} \\end{bmatrix}, \\quad\nb = \\begin{bmatrix} \\tfrac{3}{4} \\\\ \\tfrac{1}{4} \\end{bmatrix}.\n$$\n\n从 $t=0$ 开始，对于大小为 $h$ 的单个时间步，通过求解相应的线性级方程，计算将每种 IRK 格式应用于线性非自治系统 $\\frac{d\\mathbf{y}}{dt} = A \\mathbf{y} + \\mathbf{r}$（其中 $\\mathbf{y}(0)=\\mathbf{0}$）所产生的数值解 $\\mathbf{y}^{(h)}$。在时间 $t=h$ 处的精确解由下式给出\n$$\n\\mathbf{y}(h) = \\int_0^h e^{(h-\\tau)A} \\mathbf{r} \\, d\\tau,\n$$\n该解必须在不假设 $A$ 可逆的情况下，通过使用标准的分块增广矩阵指数法计算：\n$$\n\\exp\\!\\left(h \\begin{bmatrix} A  \\mathbf{r} \\\\ \\mathbf{0}^\\top  0 \\end{bmatrix}\\right) =\n\\begin{bmatrix} e^{hA}  \\displaystyle \\int_0^h e^{(h-\\tau)A} \\mathbf{r} \\, d\\tau \\\\ \\mathbf{0}^\\top  1 \\end{bmatrix}.\n$$\n\n将一种格式的误差定义为欧几里得范数\n$$\nE = \\left\\| \\mathbf{y}^{(h)} - \\mathbf{y}(h) \\right\\|_2,\n$$\n该范数是无量纲的。通过比较这三种方法的误差，展示在刚性扩散的情况下，阶序如何影响由 $s(t)$ 中的阶跃引起的初始瞬态附近的精度。\n\n您的程序必须构建 $A$ 和 $\\mathbf{r}$，使用每种 IRK 方法执行一个步骤，使用增广指数法计算精确解 $\\mathbf{y}(h)$，并为每个测试用例返回一个列表，该列表包含三个误差值，后跟两个布尔值，按顺序分别指示 Radau IIA 误差是否严格小于 SDIRK 误差以及是否严格小于 Backward Euler 误差。\n\n使用以下参数值测试套件（所有量均为无量纲）：\n- 测试用例 1：$N = 50$, $L = 1$, $a = 1$, $\\nu = 100$, $h = 10^{-3}$。\n- 测试用例 2：$N = 50$, $L = 1$, $a = 1$, $\\nu = 1000$, $h = 10^{-3}$。\n- 测试用例 3：$N = 50$, $L = 1$, $a = 1$, $\\nu = 1000$, $h = 5 \\times 10^{-3}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含以逗号分隔的各测试用例结果列表，每个测试用例的结果本身是一个用方括号括起来的逗号分隔列表，顺序为 $\\left[E_{\\text{BE}}, E_{\\text{SDIRK2}}, E_{\\text{Radau2}}, \\text{Radau2} \\lt \\text{SDIRK2}, \\text{Radau2} \\lt \\text{BE}\\right]$。例如：\n$$\n[\\,[e_1^{\\text{BE}},e_1^{\\text{SDIRK2}},e_1^{\\text{Radau2}},b_{1,1},b_{1,2}],\\,[e_2^{\\text{BE}},\\dots],\\,[e_3^{\\text{BE}},\\dots]\\,].\n$$",
            "solution": "用户希望验证一个问题，如果问题有效，则提供一个解决方案。\n\n### 步骤 1：提取已知条件\n\n- **偏微分方程**：$\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2} + s(t)\\, \\sin(2\\pi x)$\n- **域和边界条件**：$x \\in [0,L)$，周期性边界条件。\n- **参数**：对流速度 $a  0$，扩散系数 $\\nu  0$。\n- **源项**：$s(t)$ 是 Heaviside 阶跃函数：当 $t  0$ 时 $s(t) = 0$，当 $t \\ge 0$ 时 $s(t) = 1$。\n- **初始条件**：$u(x,0) = 0$。\n- **空间离散化**：$N$ 个均匀网格点 $x_i = i \\Delta x$，其中 $\\Delta x = L/N$。\n- **半离散系统**：$\\frac{d \\mathbf{y}}{dt} = A \\mathbf{y} + \\mathbf{r}$，其中 $\\mathbf{y}(0) = \\mathbf{0}$。\n- **离散向量/矩阵**：$\\mathbf{y}(t) \\in \\mathbb{R}^N$，$A \\in \\mathbb{R}^{N \\times N}$，$\\mathbf{r} \\in \\mathbb{R}^N$，其分量为 $r_i = \\sin(2\\pi x_i)$。\n- **离散化格式**：\n    - 一阶迎风：$(D_{\\text{up}} \\mathbf{y})_i = \\frac{\\mathbf{y}_i - \\mathbf{y}_{i-1}}{\\Delta x}$\n    - 二阶中心差分（扩散）：$(L \\mathbf{y})_i = \\frac{\\mathbf{y}_{i+1} - 2 \\mathbf{y}_i + \\mathbf{y}_{i-1}}{\\Delta x^2}$\n    - 算子矩阵：$A = -a D_{\\text{up}} + \\nu L$。\n- **时间积分方法 (IRK)**：\n    1.  **Backward Euler**：$c = \\begin{bmatrix} 1 \\end{bmatrix}, A_{\\text{RK}} = \\begin{bmatrix} 1 \\end{bmatrix}, b = \\begin{bmatrix} 1 \\end{bmatrix}$。（阶序为 $1$）\n    2.  **一个双级 SDIRK**：$\\gamma = 1 - \\frac{1}{\\sqrt{2}}$，$c = \\begin{bmatrix} \\gamma \\\\ 1 \\end{bmatrix}, A_{\\text{RK}} = \\begin{bmatrix} \\gamma  0 \\\\ 1 - \\gamma  \\gamma \\end{bmatrix}, b = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{2} \\end{bmatrix}$。（阶序为 $1$）\n    3.  **三阶双级 Radau IIA**：$c = \\begin{bmatrix} \\tfrac{1}{3} \\\\ 1 \\end{bmatrix}, A_{\\text{RK}} = \\begin{bmatrix} \\tfrac{5}{12}  -\\tfrac{1}{12} \\\\ \\tfrac{3}{4}  \\tfrac{1}{4} \\end{bmatrix}, b = \\begin{bmatrix} \\tfrac{3}{4} \\\\ \\tfrac{1}{4} \\end{bmatrix}$。（阶序为 $2$）\n- **精确解计算**：$\\mathbf{y}(h) = \\int_0^h e^{(h-\\tau)A} \\mathbf{r} \\, d\\tau$，使用 $\\exp\\!\\left(h \\begin{bmatrix} A  \\mathbf{r} \\\\ \\mathbf{0}^\\top  0 \\end{bmatrix}\\right)$ 计算。\n- **误差度量**：$E = \\left\\| \\mathbf{y}^{(h)} - \\mathbf{y}(h) \\right\\|_2$。\n- **测试用例**：\n    1.  $N = 50$, $L = 1$, $a = 1$, $\\nu = 100$, $h = 10^{-3}$。\n    2.  $N = 50$, $L = 1$, $a = 1$, $\\nu = 1000$, $h = 10^{-3}$。\n    3.  $N = 50$, $L = 1$, $a = 1$, $\\nu = 1000$, $h = 5 \\times 10^{-3}$。\n- **要求的输出**：对于每个测试用例，一个列表 $[E_{\\text{BE}}, E_{\\text{SDIRK2}}, E_{\\text{Radau2}}, \\text{Radau2}  \\text{SDIRK2}, \\text{Radau2}  \\text{BE}]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n该问题是数值分析中的一个标准练习，侧重于偏微分方程的数值解。\n- **科学/事实合理性**：该问题在科学上和数学上都是合理的。对流-扩散方程是物理学和工程学中的一个基本模型。空间离散化方法（迎风、中心差分）和时间积分格式（IRK）是标准技术。使用矩阵指数来求解线性常微分方程组的精确解是一种正确且标准的方法。\n- **完整性**：该问题是自洽的。所有必要的参数（$N, L, a, \\nu, h$）、初始条件（$\\mathbf{y}(0) = \\mathbf{0}$）、边界条件（周期性）、格式（由 Butcher 表定义）以及精确解的评估方法都已指定。\n- **清晰度和客观性**：该问题以精确、无歧义的数学语言陈述。目标明确定义：计算并比较特定数值方法的精度。\n- **适定性**：半离散线性常微分方程系统是适定的，并且对于给定的初始条件有唯一解。所指定的数值方法定义明确，其应用可得到唯一的数值解。\n- **基本概念**：该问题旨在展示当强迫项（或其导数）不连续时，刚性系统时间积分中的阶数降低现象。阶跃函数 $s(t)$ 在 $t=0$ 处引入了一个不连续点。在这种情况下，Runge-Kutta 方法的精度已知取决于其*阶序*。所选方法（BE、SDIRK、Radau IIA）的阶序分别为 $1$、$1$ 和 $2$，使其成为说明这一重要数值现象的合适测试套件。该问题并非微不足道，且在概念上具有实质内容。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**，因为它在科学上是合理的、适定的、完整的和客观的。将提供一个解决方案。\n\n该问题要求从 $\\mathbf{y}(0)=\\mathbf{0}$ 开始，求解半离散系统 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y} + \\mathbf{r}$ 一个大小为 $h$ 的时间步。对于 $t \\ge 0$，源项是常数，这使得它在积分区间上成为一个自治线性常微分方程。\n\n首先，我们构建空间离散化矩阵 $A$ 和源向量 $\\mathbf{r}$。网格由 $N$ 个点 $x_i = iL/N$ 组成，其中 $i=0, \\dots, N-1$。源向量 $\\mathbf{r}$ 的分量为 $r_i = \\sin(2\\pi x_i)$。矩阵 $A$ 由 $A = -a D_{\\text{up}} + \\nu L$ 给出，其中 $D_{\\text{up}}$ 和 $L$ 是周期性网格上离散算子的矩阵表示。对于周期性索引，这些矩阵是循环矩阵。\n迎风算子 $(D_{\\text{up}} \\mathbf{y})_i = (\\mathbf{y}_i - \\mathbf{y}_{i-1})/\\Delta x$ 由矩阵 $D_{\\text{up}} = \\frac{1}{\\Delta x}(I - P_{shift})$ 表示，其中 $I$ 是 $N \\times N$ 单位矩阵，$P_{shift}$ 是一个将向量分量向下移动的循环置换矩阵（即 $(P_{shift}\\mathbf{y})_i = \\mathbf{y}_{i-1}$）。\n拉普拉斯算子 $(L \\mathbf{y})_i = (\\mathbf{y}_{i+1} - 2\\mathbf{y}_i + \\mathbf{y}_{i-1})/\\Delta x^2$ 由 $L = \\frac{1}{\\Delta x^2}(P_{shift}^{-1} - 2I + P_{shift})$ 表示。\n\n将一个 $s$ 级的隐式 Runge-Kutta 方法应用于 $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y}) = A\\mathbf{y}+\\mathbf{r}$，需要求解级值 $\\mathbf{Y}_i$，它们是 $\\mathbf{y}(t_0+c_i h)$ 的近似值。级方程为：\n$$\n\\mathbf{Y}_i = \\mathbf{y}_0 + h \\sum_{j=1}^s a_{ij} f(\\mathbf{Y}_j) = \\mathbf{y}_0 + h \\sum_{j=1}^s a_{ij} (A\\mathbf{Y}_j + \\mathbf{r}), \\quad i=1, \\dots, s.\n$$\n给定 $\\mathbf{y}_0=\\mathbf{0}$，这是一个关于级 $\\mathbf{Y}_1, \\dots, \\mathbf{Y}_s$ 的线性系统。求解它们之后，在 $t=h$ 处的解为：\n$$\n\\mathbf{y}^{(h)} = \\mathbf{y}_0 + h \\sum_{j=1}^s b_j f(\\mathbf{Y}_j) = h \\sum_{j=1}^s b_j (A\\mathbf{Y}_j + \\mathbf{r}).\n$$\n\n1.  **Backward Euler** ($s=1$, $a_{11}=1$, $b_1=1$)：单个级方程为 $\\mathbf{Y}_1 = h(A\\mathbf{Y}_1 + \\mathbf{r})$，得到 $(I - hA)\\mathbf{Y}_1 = h\\mathbf{r}$。最终解为 $\\mathbf{y}^{(h)} = h(A\\mathbf{Y}_1 + \\mathbf{r}) = \\mathbf{Y}_1$。我们求解 $(I - hA)\\mathbf{y}^{(h)} = h\\mathbf{r}$。\n\n2.  **SDIRK** ($s=2$, $A_{RK}$ 是下三角矩阵)：可以顺序求解各个级。设 $\\gamma = 1 - 1/\\sqrt{2}$。由于 $y_0=0$：\n    - 级 1：$\\mathbf{Y}_1 = h a_{11}(A\\mathbf{Y}_1 + \\mathbf{r}) = h\\gamma(A\\mathbf{Y}_1 + \\mathbf{r}) \\implies (I - h\\gamma A)\\mathbf{Y}_1 = h\\gamma \\mathbf{r}$。\n    - 级 2：$\\mathbf{Y}_2 = h a_{21}(A\\mathbf{Y}_1 + \\mathbf{r}) + h a_{22}(A\\mathbf{Y}_2 + \\mathbf{r}) \\implies (I - h\\gamma A)\\mathbf{Y}_2 = h(1-\\gamma)(A\\mathbf{Y}_1+\\mathbf{r}) + h\\gamma \\mathbf{r}$。\n    - 最终解：$\\mathbf{y}^{(h)} = h(b_1(A\\mathbf{Y}_1+\\mathbf{r}) + b_2(A\\mathbf{Y}_2+\\mathbf{r})) = \\frac{h}{2}((A\\mathbf{Y}_1+\\mathbf{r}) + (A\\mathbf{Y}_2+\\mathbf{r}))$。\n\n3.  **Radau IIA** ($s=2$, $A_{RK}$ 是满矩阵)：两个级是耦合的。设 $A_{RK} = (a_{ij})$。\n    $$\n    \\begin{cases}\n    \\mathbf{Y}_1 = h a_{11}(A\\mathbf{Y}_1+\\mathbf{r}) + h a_{12}(A\\mathbf{Y}_2+\\mathbf{r}) \\\\\n    \\mathbf{Y}_2 = h a_{21}(A\\mathbf{Y}_1+\\mathbf{r}) + h a_{22}(A\\mathbf{Y}_2+\\mathbf{r})\n    \\end{cases}\n    \\implies\n    \\begin{pmatrix} I - h a_{11}A  -h a_{12}A \\\\ -h a_{21}A  I - h a_{22}A \\end{pmatrix}\n    \\begin{pmatrix} \\mathbf{Y}_1 \\\\ \\mathbf{Y}_2 \\end{pmatrix}\n    =\n    \\begin{pmatrix} h(a_{11}+a_{12})\\mathbf{r} \\\\ h(a_{21}+a_{22})\\mathbf{r} \\end{pmatrix}.\n    $$\n    求解此 $2N \\times 2N$ 分块系统以得到 $\\mathbf{Y}_1, \\mathbf{Y}_2$。最终解为 $\\mathbf{y}^{(h)} = h(b_1(A\\mathbf{Y}_1+\\mathbf{r}) + b_2(A\\mathbf{Y}_2+\\mathbf{r}))$。\n\n从 $\\mathbf{y}(0)=\\mathbf{0}$ 开始单步的精确解由常数变易公式给出，简化为 $\\mathbf{y}(h) = \\int_0^h e^{(h-\\tau)A}\\mathbf{r} \\, d\\tau$。该积分是增广 $(N+1) \\times (N+1)$ 矩阵 $M_{aug} = \\begin{bsmallmatrix} A  \\mathbf{r} \\\\ \\mathbf{0}^\\top  0 \\end{bsmallmatrix}$ 在乘以 $h$ 后进行矩阵指数运算所得矩阵的右上角 $N \\times 1$ 分块。具体来说，$\\mathbf{y}(h)$ 是 $\\exp(h M_{aug})$ 最后一列的前 $N$ 个元素。\n\n最后，每种方法的误差计算为欧几里得范数 $E = \\|\\mathbf{y}^{(h)} - \\mathbf{y}(h)\\|_2$。然后对这些误差进行比较。由于源项在 $t=0$ 处不连续，阶序较低的方法（BE 和 SDIRK，均为 $q=1$）预计会遭受阶数降低的影响，其精度会低于具有更高阶序（$q=2$）且更适合处理带瞬态的刚性问题的 Radau IIA 方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the errors of three IRK schemes for a stiff convection-diffusion\n    problem and compares their performance.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, a, nu, h)\n        (50, 1.0, 1.0, 100.0, 1e-3),\n        (50, 1.0, 1.0, 1000.0, 1e-3),\n        (50, 1.0, 1.0, 1000.0, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, nu, h = case\n        \n        # 1. Construct discretization operators and source vector\n        dx = L / N\n        x_grid = np.linspace(0, L, N, endpoint=False)\n        # r vector from the forcing term sin(2*pi*x)\n        r = np.sin(2 * np.pi * x_grid)\n\n        # Identity matrix, used for constructing operators\n        I_N = np.eye(N)\n\n        # First-order upwind operator D_up (periodic).\n        # Corresponds to (y_i - y_{i-1}) / dx.\n        # Implemented via a circulant matrix constructed using np.roll.\n        # np.roll(I_N, 1, axis=0) creates a matrix that shifts vector components down.\n        D_up_mat = (I_N - np.roll(I_N, 1, axis=0)) / dx\n\n        # Second-order central difference Laplacian L (periodic).\n        # Corresponds to (y_{i+1} - 2*y_i + y_{i-1}) / dx^2.\n        L_mat = (np.roll(I_N, -1, axis=0) - 2 * I_N + np.roll(I_N, 1, axis=0)) / (dx**2)\n\n        # Full spatial operator matrix A\n        A = -a * D_up_mat + nu * L_mat\n\n        # 2. Compute the exact solution y(h) via augmented matrix exponential\n        # y(h) = integral_0^h exp((h-tau)A) r d(tau)\n        # This is the top-right block of exp(h * [[A, r], [0, 0]])\n        M_aug = np.zeros((N + 1, N + 1))\n        M_aug[:N, :N] = A\n        M_aug[:N, N] = r\n        \n        E_aug = expm(h * M_aug)\n        y_exact = E_aug[:N, N]\n\n        # Initial condition is y(0) = 0\n        y0 = np.zeros(N)\n\n        # 3. Method 1: Backward Euler (p=1, q=1)\n        # (I - hA)y_1 = y_0 + h*r. Since y_0=0, (I-hA)y_1 = h*r\n        mat_be = I_N - h * A\n        rhs_be = h * r\n        y_be = np.linalg.solve(mat_be, rhs_be)\n        error_be = np.linalg.norm(y_be - y_exact)\n\n        # 4. Method 2: Two-stage SDIRK (p=1-2, q=1)\n        gamma = 1 - 1 / np.sqrt(2)\n        mat_sdirk = I_N - h * gamma * A\n        \n        # Stage 1: (I - h*gamma*A) Y1 = h*gamma*r\n        rhs_Y1 = h * gamma * r\n        Y1_sdirk = np.linalg.solve(mat_sdirk, rhs_Y1)\n        \n        # Stage 2: (I - h*gamma*A) Y2 = h*(1-gamma)*A*Y1 + h*r\n        rhs_Y2 = h * (1 - gamma) * (A @ Y1_sdirk) + h * r\n        Y2_sdirk = np.linalg.solve(mat_sdirk, rhs_Y2)\n        \n        # Final solution update\n        y_sdirk = y0 + 0.5 * h * ((A @ Y1_sdirk + r) + (A @ Y2_sdirk + r))\n        error_sdirk = np.linalg.norm(y_sdirk - y_exact)\n\n        # 5. Method 3: Two-stage Radau IIA (p=3, q=2)\n        a11, a12 = 5/12, -1/12\n        a21, a22 = 3/4, 1/4\n        b1, b2 = 3/4, 1/4\n        c1 = a11 + a12\n        c2 = a21 + a22\n        \n        # Solve the 2N x 2N block system for stages [Y1, Y2]\n        M_radau = np.block([\n            [I_N - h * a11 * A, -h * a12 * A],\n            [-h * a21 * A, I_N - h * a22 * A]\n        ])\n        \n        rhs_radau = np.concatenate((h * c1 * r, h * c2 * r))\n        \n        Y_stacked = np.linalg.solve(M_radau, rhs_radau)\n        Y1_radau = Y_stacked[:N]\n        Y2_radau = Y_stacked[N:]\n        \n        y_radau = y0 + h * (b1 * (A @ Y1_radau + r) + b2 * (A @ Y2_radau + r))\n        error_radau = np.linalg.norm(y_radau - y_exact)\n\n        # 6. Comparisons\n        radau_lt_sdirk = error_radau  error_sdirk\n        radau_lt_be = error_radau  error_be\n        \n        results.append([error_be, error_sdirk, error_radau, radau_lt_sdirk, radau_lt_be])\n\n    # Format the final output string exactly as specified\n    case_results_str = []\n    for r in results:\n        # map(str, r) correctly handles floats and booleans ('True'/'False')\n        case_str = f\"[{','.join(map(str, r))}]\"\n        case_results_str.append(case_str)\n        \n    final_output = f\"[{','.join(case_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}