{
    "hands_on_practices": [
        {
            "introduction": "Before a numerical solver for partial differential equations can be trusted, its implementation must be rigorously verified. The Method of Manufactured Solutions (MMS) is a cornerstone of software verification in computational science, allowing us to create a test problem with a known analytical solution. This practice  guides you through the essential steps of manufacturing a solution: deriving the necessary source term and boundary conditions for a given PDE, a fundamental skill for developing and debugging any spectral method solver.",
            "id": "3397996",
            "problem": "Consider the one-dimensional, variable-coefficient, second-order elliptic operator on the interval $[-1,1]$ defined by\n$$\n\\mathcal{L}u(x) \\;=\\; -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)\\,u'(x)\\Big) \\;+\\; c(x)\\,u(x),\n$$\nwith smooth positive coefficient $a(x)=2+x$ and smooth nonnegative coefficient $c(x)=1+x^2$. In the method of manufactured solutions, choose a smooth target solution\n$$\nu(x) \\;=\\; \\exp(x) \\;+\\; \\sin\\!\\Big(\\frac{\\pi x}{2}\\Big).\n$$\nYour tasks are:\n- Derive the source term $f(x)$ so that the strong form $\\mathcal{L}u(x)=f(x)$ holds identically on $[-1,1]$.\n- Derive consistent Dirichlet boundary conditions by specifying $u(-1)$ and $u(1)$.\n- For verification of spectral Galerkin, tau, and collocation formulations using Legendre polynomials, compute the first Legendre coefficient of the source term $f(x)$ under the standard $L^2([-1,1])$ normalization. Specifically, with $P_1(x)=x$ and the coefficient defined by\n$$\n\\widehat{f}_1 \\;=\\; \\frac{2\\cdot 1 + 1}{2}\\int_{-1}^{1} f(x)\\,P_1(x)\\,\\mathrm{d}x \\;=\\; \\frac{3}{2}\\int_{-1}^{1} f(x)\\,x\\,\\mathrm{d}x,\n$$\ndetermine a closed-form analytic expression for $\\widehat{f}_1$.\n\nProvide all derivations starting from product rule and orthogonality principles. Express the final answer for $\\widehat{f}_1$ in exact form using elementary functions and constants (no numerical rounding).",
            "solution": "The problem is valid as it is mathematically well-posed, scientifically grounded in the theory of differential equations and numerical analysis, and provides all necessary information to derive a unique solution without ambiguity or contradiction.\n\nThe tasks are to derive the source term $f(x)$ for a manufactured solution, determine the corresponding boundary conditions, and compute the first Legendre coefficient of the source term.\n\n### Task 1: Derive the source term $f(x)$\nThe differential operator is given by\n$$\n\\mathcal{L}u(x) = -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)\\,u'(x)\\Big) + c(x)\\,u(x),\n$$\nwith coefficients $a(x) = 2+x$ and $c(x) = 1+x^2$. The manufactured solution is $u(x) = \\exp(x) + \\sin(\\frac{\\pi x}{2})$. The source term $f(x)$ is defined by the equation $\\mathcal{L}u(x) = f(x)$.\n\nFirst, we compute the first derivative of $u(x)$:\n$$\nu'(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\exp(x) + \\sin\\left(\\frac{\\pi x}{2}\\right)\\right) = \\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right).\n$$\nNext, we form the product $a(x)u'(x)$:\n$$\na(x)u'(x) = (2+x)\\left(\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right)\\right).\n$$\nNow, we differentiate this product with respect to $x$ using the product rule, $\\frac{\\mathrm{d}}{\\mathrm{d}x}(gh) = g'h + gh'$:\n\\begin{align*}\n\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)u'(x)\\Big) &= \\frac{\\mathrm{d}}{\\mathrm{d}x}(2+x) \\cdot \\left(\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right)\\right) + (2+x) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right)\\right) \\\\\n&= 1 \\cdot \\left(\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right)\\right) + (2+x) \\left(\\exp(x) - \\frac{\\pi^2}{4}\\sin\\left(\\frac{\\pi x}{2}\\right)\\right) \\\\\n&= \\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) + (2+x)\\exp(x) - (2+x)\\frac{\\pi^2}{4}\\sin\\left(\\frac{\\pi x}{2}\\right) \\\\\n&= (1+2+x)\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) - \\left(\\frac{\\pi^2}{2}+\\frac{\\pi^2 x}{4}\\right)\\sin\\left(\\frac{\\pi x}{2}\\right) \\\\\n&= (3+x)\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) - \\frac{\\pi^2}{4}(2+x)\\sin\\left(\\frac{\\pi x}{2}\\right).\n\\end{align*}\nThe second part of the operator is $c(x)u(x)$:\n$$\nc(x)u(x) = (1+x^2)\\left(\\exp(x) + \\sin\\left(\\frac{\\pi x}{2}\\right)\\right) = (1+x^2)\\exp(x) + (1+x^2)\\sin\\left(\\frac{\\pi x}{2}\\right).\n$$\nCombining these results gives the source term $f(x)$:\n\\begin{align*}\nf(x) &= -\\left((3+x)\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) - \\frac{\\pi^2}{4}(2+x)\\sin\\left(\\frac{\\pi x}{2}\\right)\\right) + (1+x^2)\\exp(x) + (1+x^2)\\sin\\left(\\frac{\\pi x}{2}\\right) \\\\\n&= (-3-x+1+x^2)\\exp(x) - \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) + \\left(\\frac{\\pi^2}{4}(2+x) + 1+x^2\\right)\\sin\\left(\\frac{\\pi x}{2}\\right) \\\\\n&= (x^2-x-2)\\exp(x) - \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right) + \\left(x^2 + \\frac{\\pi^2}{4}x + 1 + \\frac{\\pi^2}{2}\\right)\\sin\\left(\\frac{\\pi x}{2}\\right).\n\\end{align*}\n\n### Task 2: Derive Dirichlet boundary conditions\nThe Dirichlet boundary conditions are found by evaluating the manufactured solution $u(x)$ at the endpoints of the interval $[-1, 1]$:\n$$\nu(-1) = \\exp(-1) + \\sin\\left(-\\frac{\\pi}{2}\\right) = \\frac{1}{e} - 1.\n$$\n$$\nu(1) = \\exp(1) + \\sin\\left(\\frac{\\pi}{2}\\right) = e + 1.\n$$\n\n### Task 3: Compute the Legendre coefficient $\\widehat{f}_1$\nThe first Legendre coefficient of $f(x)$ is defined as:\n$$\n\\widehat{f}_1 = \\frac{3}{2}\\int_{-1}^{1} f(x)P_1(x)\\,\\mathrm{d}x = \\frac{3}{2}\\int_{-1}^{1} f(x)x\\,\\mathrm{d}x.\n$$\nSince $f(x) = \\mathcal{L}u(x)$, we have:\n$$\n\\int_{-1}^{1} f(x)x\\,\\mathrm{d}x = \\int_{-1}^{1} \\mathcal{L}u(x) \\cdot x\\,\\mathrm{d}x = \\int_{-1}^{1} \\left(-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)u'(x)\\Big) + c(x)u(x)\\right)x\\,\\mathrm{d}x.\n$$\nWe can apply integration by parts to the first term. Let the test function be $v(x) = x$.\n$$\n\\int_{-1}^{1} -\\frac{\\mathrm{d}}{\\mathrm{d}x}\\Big(a(x)u'(x)\\Big) v(x)\\,\\mathrm{d}x = \\left[-a(x)u'(x)v(x)\\right]_{-1}^{1} + \\int_{-1}^{1} a(x)u'(x)v'(x)\\,\\mathrm{d}x.\n$$\nWith $v(x) = x$ and $v'(x) = 1$, the integral for the coefficient becomes:\n$$\n\\int_{-1}^{1} f(x)x\\,\\mathrm{d}x = \\left[-a(x)u'(x)x\\right]_{-1}^{1} + \\int_{-1}^{1} \\left(a(x)u'(x) \\cdot 1 + c(x)u(x)x\\right)\\,\\mathrm{d}x.\n$$\nLet's evaluate the boundary term and the integral term separately.\n\nThe boundary term is:\n\\begin{align*}\n\\left[-a(x)u'(x)x\\right]_{-1}^{1} &= -a(1)u'(1)(1) - (-a(-1)u'(-1)(-1)) \\\\\n&= -a(1)u'(1) - a(-1)u'(-1).\n\\end{align*}\nWe have $a(x) = 2+x$, so $a(1)=3$ and $a(-1)=1$.\nWe have $u'(x) = \\exp(x) + \\frac{\\pi}{2}\\cos(\\frac{\\pi x}{2})$, so:\n$u'(1) = \\exp(1) + \\frac{\\pi}{2}\\cos(\\frac{\\pi}{2}) = e$.\n$u'(-1) = \\exp(-1) + \\frac{\\pi}{2}\\cos(-\\frac{\\pi}{2}) = e^{-1}$.\nThe boundary term is therefore $-3e - 1 \\cdot e^{-1} = -3e - e^{-1}$.\n\nThe integral term is $I = \\int_{-1}^{1} \\left(a(x)u'(x) + c(x)u(x)x\\right)\\,\\mathrm{d}x$:\n\\begin{align*}\nI &= \\int_{-1}^{1} \\left( (2+x)\\left(\\exp(x) + \\frac{\\pi}{2}\\cos\\left(\\frac{\\pi x}{2}\\right)\\right) + (1+x^2)\\left(\\exp(x) + \\sin\\left(\\frac{\\pi x}{2}\\right)\\right)x \\right) \\,\\mathrm{d}x \\\\\n&= \\int_{-1}^{1} \\left( (2+x)\\exp(x) + (x+x^3)\\exp(x) + \\pi\\cos\\left(\\frac{\\pi x}{2}\\right) + \\frac{\\pi}{2}x\\cos\\left(\\frac{\\pi x}{2}\\right) + (x+x^3)\\sin\\left(\\frac{\\pi x}{2}\\right) \\right) \\,\\mathrm{d}x \\\\\n&= \\int_{-1}^{1} \\left( (x^3+2x+2)\\exp(x) + \\pi\\cos\\left(\\frac{\\pi x}{2}\\right) + \\frac{\\pi}{2}x\\cos\\left(\\frac{\\pi x}{2}\\right) + (x+x^3)\\sin\\left(\\frac{\\pi x}{2}\\right) \\right) \\,\\mathrm{d}x.\n\\end{align*}\nWe compute the integral of each part over the symmetric interval $[-1, 1]$:\n1. $\\int_{-1}^{1} (x^3+2x+2)\\exp(x)\\,\\mathrm{d}x$. We use the formula $\\int p(x)\\exp(x)dx = [p(x) - p'(x) + p''(x) - \\ldots]\\exp(x)$.\nWith $p(x) = x^3+2x+2$, $p'(x) = 3x^2+2$, $p''(x) = 6x$, $p'''(x) = 6$.\n$$\n\\int_{-1}^{1} (x^3+2x+2)\\exp(x)\\,\\mathrm{d}x = \\left[(x^3+2x+2) - (3x^2+2) + 6x - 6\\right]\\exp(x)\\Big|_{-1}^{1} \\\\\n= \\left[x^3 - 3x^2 + 8x - 6\\right]\\exp(x)\\Big|_{-1}^{1} = (1-3+8-6)e - (-1-3-8-6)e^{-1} = 0 \\cdot e - (-18)e^{-1} = 18e^{-1}.\n$$\n2. $\\int_{-1}^{1} \\pi\\cos\\left(\\frac{\\pi x}{2}\\right)\\,\\mathrm{d}x = \\left[\\pi \\frac{2}{\\pi}\\sin\\left(\\frac{\\pi x}{2}\\right)\\right]_{-1}^{1} = 2(\\sin(\\frac{\\pi}{2}) - \\sin(-\\frac{\\pi}{2})) = 2(1 - (-1)) = 4$.\n3. $\\int_{-1}^{1} \\frac{\\pi}{2}x\\cos\\left(\\frac{\\pi x}{2}\\right)\\,\\mathrm{d}x = 0$ since the integrand is an odd function.\n4. $\\int_{-1}^{1} (x+x^3)\\sin\\left(\\frac{\\pi x}{2}\\right)\\,\\mathrm{d}x$. The integrand is an even function. Let $k=\\pi/2$.\nThe integral is $2\\int_{0}^{1} (x+x^3)\\sin(kx)\\,\\mathrm{d}x = 2(\\int_{0}^{1} x\\sin(kx)\\,\\mathrm{d}x + \\int_{0}^{1} x^3\\sin(kx)\\,\\mathrm{d}x)$.\nUsing integration by parts:\n$\\int_{0}^{1} x\\sin(kx)\\,\\mathrm{d}x = \\left[\\frac{\\sin(kx)}{k^2} - \\frac{x\\cos(kx)}{k}\\right]_{0}^{1} = \\frac{\\sin(k)}{k^2} - \\frac{\\cos(k)}{k} = \\frac{1}{k^2} = \\frac{4}{\\pi^2}$.\n$\\int_{0}^{1} x^3\\sin(kx)\\,\\mathrm{d}x = \\left[\\left(\\frac{3x^2}{k^2}-\\frac{6}{k^4}\\right)\\sin(kx) - \\left(\\frac{x^3}{k}-\\frac{6x}{k^3}\\right)\\cos(kx)\\right]_{0}^{1} = \\left(\\frac{3}{k^2}-\\frac{6}{k^4}\\right)\\sin(k) - \\left(\\frac{1}{k}-\\frac{6}{k^3}\\right)\\cos(k) = \\frac{3}{k^2}-\\frac{6}{k^4} = 3\\left(\\frac{4}{\\pi^2}\\right) - 6\\left(\\frac{16}{\\pi^4}\\right) = \\frac{12}{\\pi^2} - \\frac{96}{\\pi^4}$.\nThe sum is $2\\left(\\frac{4}{\\pi^2} + \\frac{12}{\\pi^2} - \\frac{96}{\\pi^4}\\right) = 2\\left(\\frac{16}{\\pi^2} - \\frac{96}{\\pi^4}\\right) = \\frac{32}{\\pi^2} - \\frac{192}{\\pi^4}$.\nSumming all integral parts: $I = 18e^{-1} + 4 + 0 + (\\frac{32}{\\pi^2} - \\frac{192}{\\pi^4})$.\n\nThe total value of $\\int_{-1}^{1} f(x)x\\,\\mathrm{d}x$ is the sum of the boundary and integral contributions:\n$$\n\\int_{-1}^{1} f(x)x\\,\\mathrm{d}x = (-3e - e^{-1}) + (18e^{-1} + 4 + \\frac{32}{\\pi^2} - \\frac{192}{\\pi^4}) = -3e + 17e^{-1} + 4 + \\frac{32}{\\pi^2} - \\frac{192}{\\pi^4}.\n$$\nFinally, we multiply by $\\frac{3}{2}$ to get $\\widehat{f}_1$:\n$$\n\\widehat{f}_1 = \\frac{3}{2}\\left(-3e + 17e^{-1} + 4 + \\frac{32}{\\pi^2} - \\frac{192}{\\pi^4}\\right) = -\\frac{9}{2}e + \\frac{51}{2}e^{-1} + 6 + \\frac{48}{\\pi^2} - \\frac{288}{\\pi^4}.\n$$",
            "answer": "$$\n\\boxed{6 - \\frac{9}{2}\\exp(1) + \\frac{51}{2}\\exp(-1) + \\frac{48}{\\pi^2} - \\frac{288}{\\pi^4}}\n$$"
        },
        {
            "introduction": "The power of spectral methods lies in their elegant mathematical structure, but this elegance often comes with implementation subtleties where small mistakes can lead to catastrophic failures. The spectral tau method, in particular, requires careful handling of boundary conditions by replacing specific modal equations in the discretized system. This exercise  serves as an insightful \"cautionary tale,\" demonstrating how an incorrect placement of these boundary constraints can fundamentally break the numerical scheme, leading to spurious, non-physical solutions and highlighting the theoretical principles that ensure the method's stability and accuracy.",
            "id": "3397978",
            "problem": "Consider the Sturm–Liouville eigenvalue problem on the interval $[-1,1]$:\n$$-u''(x) = \\lambda\\, u(x), \\quad u(-1)=0, \\quad u(1)=0,$$\nto be approximated by a Chebyshev spectral tau method using the first $N+1$ Chebyshev polynomials $\\{T_k(x)\\}_{k=0}^{N}$, where $T_k(x) = \\cos(k \\arccos x)$ on $[-1,1]$. Let $N=3$ so that the approximation space is spanned by $\\{T_0, T_1, T_2, T_3\\}$ and let the approximate solution be\n$$u_3(x) = \\sum_{k=0}^{3} a_k\\, T_k(x).$$\n\nBy definition of the spectral tau method, one forms the residual\n$$R(x) = -u_3''(x) - \\lambda\\, u_3(x),$$\nand enforces that $R(x)$ is orthogonal (in the Chebyshev modal sense) to a chosen set of test modes while the two boundary conditions are imposed by replacing two modal equations with the boundary equations. The mathematically standard tau placement for a second-order problem enforces orthogonality on the lowest two modes $T_0$ and $T_1$, replacing the equations for $T_2$ and $T_3$ by the boundary conditions. In contrast, consider the incorrect tau placement that replaces the equations for $T_0$ and $T_1$ with the boundary conditions and enforces orthogonality of $R(x)$ only against the highest two modes $T_2$ and $T_3$.\n\nStarting from the definitions above and the identities $T_0(x)=1$, $T_1(x)=x$, $T_2(x)=2x^2-1$, $T_3(x)=4x^3-3x$, together with the endpoint values $T_k(1)=1$ and $T_k(-1)=(-1)^k$, derive the algebraic system produced by this incorrect tau placement and show that it removes precisely the modal equations that carry the action of the differential operator, thereby overconstraining the system to the extent that it either admits only the trivial solution for any $\\lambda \\neq 0$ or else admits a nontrivial solution only for a spurious eigenvalue.\n\nYour final answer should be the spurious eigenvalue admitted by this incorrectly placed tau system. Provide this value as a real number. No rounding is required.",
            "solution": "The user wants me to analyze an incorrect application of the Chebyshev spectral tau method for a given Sturm-Liouville problem and find the resulting spurious eigenvalue.\n\nFirst, I will validate the problem statement.\n\n### Step 1: Extract Givens\n- **Differential Equation:** $-u''(x) = \\lambda\\, u(x)$ on the interval $[-1,1]$.\n- **Boundary Conditions:** $u(-1)=0$ and $u(1)=0$.\n- **Approximation Space:** The space spanned by the first $N+1=4$ Chebyshev polynomials, $\\{T_0(x), T_1(x), T_2(x), T_3(x)\\}$.\n- **Approximate Solution:** $u_3(x) = \\sum_{k=0}^{3} a_k\\, T_k(x)$.\n- **Residual:** $R(x) = -u_3''(x) - \\lambda\\, u_3(x)$.\n- **Incorrect Tau Placement:**\n  1. The modal equations corresponding to $T_0$ and $T_1$ are replaced by the two boundary conditions.\n  2. The residual $R(x)$ is made orthogonal to the test modes $T_2$ and $T_3$.\n- **Provided Identities:**\n  - $T_0(x)=1$, $T_1(x)=x$, $T_2(x)=2x^2-1$, $T_3(x)=4x^3-3x$.\n  - $T_k(1)=1$ and $T_k(-1)=(-1)^k$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** Yes. The problem is a well-defined exercise in the numerical analysis of partial differential equations, specifically focusing on the implementation details and potential pitfalls of spectral methods. The Sturm-Liouville problem and Chebyshev polynomials are standard mathematical tools.\n- **Well-Posed:** Yes. The procedure, though described as \"incorrect\" from a practical standpoint, is unambiguously defined. The task is to follow this procedure and derive a specific quantity (the spurious eigenvalue), which is a solvable mathematical problem.\n- **Objective:** Yes. The problem uses precise mathematical language and is free of subjective or ambiguous statements.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Detailed Solution\n\nThe core of the problem is to derive the algebraic system that results from the specified incorrect tau method. Let the approximate solution be $u_3(x) = \\sum_{k=0}^{3} a_k T_k(x)$.\n\nThe first step is to express the second derivative, $u_3''(x)$, in the Chebyshev basis. A standard result for the coefficients of the second derivative of a Chebyshev series $u(x) = \\sum_{k=0}^{N} a_k T_k(x)$ is $u''(x) = \\sum_{k=0}^{N-2} c_k^{(2)} T_k(x)$, where the coefficients $c_k^{(2)}$ are given by:\n$$c_k^{(2)} = \\frac{1}{\\bar{c}_k} \\sum_{p=k+2, \\, p+k \\text{ even}}^{N} p(p^2 - k^2) a_p$$\nwith $\\bar{c}_0=2$ and $\\bar{c}_k=1$ for $k>0$.\n\nFor our case, $N=3$, so the second derivative is a polynomial of degree at most $1$, meaning it is a linear combination of $T_0(x)$ and $T_1(x)$.\n$$u_3''(x) = c_0^{(2)} T_0(x) + c_1^{(2)} T_1(x)$$\nLet's compute the coefficients $c_0^{(2)}$ and $c_1^{(2)}$.\n\nFor $k=0$:\n$$c_0^{(2)} = \\frac{1}{2} \\sum_{p=2, \\, p \\text{ even}}^{3} p(p^2 - 0^2) a_p = \\frac{1}{2} \\left[ 2(2^2 - 0^2) a_2 \\right] = \\frac{1}{2}(8a_2) = 4a_2$$\n\nFor $k=1$:\n$$c_1^{(2)} = \\frac{1}{1} \\sum_{p=3, \\, p \\text{ odd}}^{3} p(p^2 - 1^2) a_p = 3(3^2 - 1^2) a_3 = 3(8)a_3 = 24a_3$$\n\nSo, the second derivative is:\n$$u_3''(x) = 4a_2 T_0(x) + 24a_3 T_1(x)$$\n\nNow, we form the residual $R(x) = -u_3''(x) - \\lambda u_3(x)$:\n$$R(x) = -(4a_2 T_0(x) + 24a_3 T_1(x)) - \\lambda \\sum_{k=0}^{3} a_k T_k(x)$$\nGrouping terms by the basis functions $T_k(x)$:\n$$R(x) = (-4a_2 - \\lambda a_0) T_0(x) + (-24a_3 - \\lambda a_1) T_1(x) - \\lambda a_2 T_2(x) - \\lambda a_3 T_3(x)$$\nThe spectral method requires setting the coefficients of the residual in the test basis to zero. The \"incorrect\" scheme enforces orthogonality against $T_2$ and $T_3$. This means the coefficients of $T_2(x)$ and $T_3(x)$ in the expansion of $R(x)$ must be zero.\n1. Orthogonality against $T_2(x)$: $-\\lambda a_2 = 0$\n2. Orthogonality against $T_3(x)$: $-\\lambda a_3 = 0$\n\nThese two equations replace the modal equations for $T_0$ and $T_1$. The boundary conditions are used to form the remaining two equations.\n3. Boundary condition $u_3(1)=0$:\n$$u_3(1) = \\sum_{k=0}^{3} a_k T_k(1) = \\sum_{k=0}^{3} a_k (1) = a_0 + a_1 + a_2 + a_3 = 0$$\n4. Boundary condition $u_3(-1)=0$:\n$$u_3(-1) = \\sum_{k=0}^{3} a_k T_k(-1) = \\sum_{k=0}^{3} a_k (-1)^k = a_0 - a_1 + a_2 - a_3 = 0$$\n\nThis gives a system of four homogeneous linear equations for the coefficients $(a_0, a_1, a_2, a_3)$:\n$$\\begin{cases}\n    a_0 + a_1 + a_2 + a_3 &= 0 \\\\\n    a_0 - a_1 + a_2 - a_3 &= 0 \\\\\n    -\\lambda a_2 &= 0 \\\\\n    -\\lambda a_3 &= 0\n\\end{cases}$$\n\nThe flaw in this method, as described in the problem, is now evident. The action of the differential operator $-d^2/dx^2$ on the higher-order modes ($T_2, T_3$) is captured entirely by the coefficients of the lower-order modes ($T_0, T_1$) in the residual, namely the terms $-4a_2$ and $-24a_3$. By replacing the modal equations for $T_0$ and $T_1$ with boundary conditions, the \"stiffness matrix\" contribution of the operator is discarded. The remaining orthogonality conditions, $-\\lambda a_2=0$ and $-\\lambda a_3=0$, only contain the \"mass matrix\" part of the operator, completely decoupling the system and destroying the structure of the eigenvalue problem.\n\nWe seek a non-trivial solution for the vector of coefficients $\\mathbf{a} = (a_0, a_1, a_2, a_3)^T$. Such a solution exists if and only if the determinant of the system's matrix is zero. The system can be written as $M(\\lambda) \\mathbf{a} = \\mathbf{0}$, where:\n$$M(\\lambda) = \\begin{pmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & -1 & 1 & -1 \\\\\n0 & 0 & -\\lambda & 0 \\\\\n0 & 0 & 0 & -\\lambda\n\\end{pmatrix}$$\n\nWe compute the determinant of this matrix:\n$$\\det(M(\\lambda)) = (1) \\det \\begin{pmatrix} -1 & 1 & -1 \\\\ 0 & -\\lambda & 0 \\\\ 0 & 0 & -\\lambda \\end{pmatrix} - (1) \\det \\begin{pmatrix} 1 & 1 & -1 \\\\ 0 & -\\lambda & 0 \\\\ 0 & 0 & -\\lambda \\end{pmatrix}$$\nThis is more complex than needed. Using cofactor expansion along the fourth row is much simpler:\n$$\\det(M(\\lambda)) = (-\\lambda) \\det \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & -1 & 1 \\\\ 0 & 0 & -\\lambda \\end{pmatrix}$$\nNow, expand the $3 \\times 3$ determinant along its third row:\n$$\\det(M(\\lambda)) = (-\\lambda) \\left( (-\\lambda) \\det \\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} \\right)$$\n$$\\det(M(\\lambda)) = \\lambda^2 \\left( (1)(-1) - (1)(1) \\right) = \\lambda^2(-2) = -2\\lambda^2$$\nFor a non-trivial solution to exist, we must have $\\det(M(\\lambda))=0$.\n$$-2\\lambda^2 = 0 \\implies \\lambda = 0$$\nThus, the only eigenvalue for which this incorrectly formulated system admits a non-trivial solution is $\\lambda=0$. For any $\\lambda \\neq 0$, the system forces $a_2=0$ and $a_3=0$, which in turn forces $a_0=0$ and $a_1=0$, leading to the trivial solution $u_3(x)=0$.\n\nThe true eigenvalues for this Sturm-Liouville problem are $\\lambda_n = (n\\pi/2)^2$ for integer $n \\ge 1$ (e.g., $\\lambda_1 = \\pi^2/4 \\approx 2.467$). These are all strictly positive. The value $\\lambda=0$ produced by the flawed numerical scheme is therefore spurious.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "As problem sizes ($N$) grow, the $O(N^2)$ memory and computational cost of forming, storing, and multiplying dense system matrices become a critical bottleneck for spectral methods. High-performance implementations overcome this barrier by using matrix-free techniques, which compute the action of an operator without ever assembling the matrix itself. This advanced practice  explores the implementation of a matrix-free Legendre-Galerkin operator using recurrence relations, providing a direct comparison of its computational efficiency and memory requirements against the traditional dense matrix approach.",
            "id": "3398043",
            "problem": "Implement a matrix-free application of the Legendre–Galerkin operator for the one-dimensional weak form of the second derivative using three-term recurrences and Gauss–Legendre quadrature, and quantify the computational arithmetic intensity and memory bandwidth requirements relative to an explicitly formed dense stiffness matrix multiplication.\n\nYou are given the following mathematical setting.\n\n- Let $P_n(x)$ denote the degree-$n$ Legendre polynomial on $[-1,1]$, defined by the three-term recurrence\n$$\nP_0(x) = 1,\\quad P_1(x) = x,\\quad (n+1) P_{n+1}(x) = (2n+1)\\,x\\,P_n(x) - n\\,P_{n-1}(x),\\quad n \\ge 1.\n$$\n\n- For a coefficient vector $a \\in \\mathbb{R}^N$, define the polynomial\n$$\nu_N(x) = \\sum_{j=0}^{N-1} a_j\\,P_j(x).\n$$\n\n- Define the Legendre–Galerkin operator $K\\in\\mathbb{R}^{N\\times N}$ by the bilinear form\n$$\n(K a)_i \\equiv \\sum_{j=0}^{N-1} \\left(\\int_{-1}^{1} P_i'(x)\\,P_j'(x)\\,dx\\right) a_j,\\quad i=0,\\dots,N-1,\n$$\nso that the operator maps $a$ to the coefficient vector $b$ with entries\n$$\nb_i = \\int_{-1}^{1} u_N'(x)\\,P_i'(x)\\,dx,\\quad i=0,\\dots,N-1.\n$$\n\n- Approximate the integral exactly using $M$-point Gauss–Legendre quadrature with nodes $\\{x_k\\}_{k=1}^M$ and weights $\\{w_k\\}_{k=1}^M$, where $M=N$. Since $u_N'(x)$ and $P_i'(x)$ are polynomials of degrees at most $N-1$, the product $u_N'(x)\\,P_i'(x)$ has degree at most $2N-2$, and $N$-point Gauss–Legendre quadrature integrates this product exactly.\n\n- Evaluate $P_n(x)$ and $P_n'(x)$ simultaneously for all $n=0,\\dots,N-1$ at any quadrature node $x$ using only recurrence relations, without forming any dense matrices. Use:\n  1. The three-term recurrence for $P_n(x)$ as given above.\n  2. The derivative recurrence obtained by differentiating the three-term recurrence:\n  $$\n  (n+1) P_{n+1}'(x) = (2n+1)\\,\\big(P_n(x) + x\\,P_n'(x)\\big) - n\\,P_{n-1}'(x),\\quad n \\ge 1,\n  $$\n  with initialization $P_0'(x) = 0$ and $P_1'(x) = 1$.\n\n- Implement a matrix-free application of $K$ to $a$:\n  $$\n  b_i = \\sum_{k=1}^{N} w_k\\,u_N'(x_k)\\,P_i'(x_k),\\quad u_N'(x_k) = \\sum_{j=0}^{N-1} a_j\\,P_j'(x_k).\n  $$\n  This must be done by looping over quadrature nodes, evaluating $\\{P_n(x_k),P_n'(x_k)\\}_{n=0}^{N-1}$ via recurrences, forming the scalar $u_N'(x_k)$, and accumulating $b$.\n\n- For verification, also assemble the dense stiffness matrix $K$ using the same quadrature:\n  $$\n  K_{ij} = \\sum_{k=1}^N w_k\\, P_i'(x_k)\\,P_j'(x_k),\n  $$\n  and compute $b^{\\mathrm{dense}} = K a$. Compare the matrix-free result $b^{\\mathrm{mf}}$ to $b^{\\mathrm{dense}}$ using the relative error\n  $$\n  \\varepsilon = \\frac{\\|b^{\\mathrm{mf}} - b^{\\mathrm{dense}}\\|_2}{\\|b^{\\mathrm{dense}}\\|_2}.\n  $$\n  If $\\|b^{\\mathrm{dense}}\\|_2=0$, define $\\varepsilon=0$ when $b^{\\mathrm{mf}}=b^{\\mathrm{dense}}$.\n\n- Quantify arithmetic intensity and memory bandwidth as follows. Use the standard floating-point operation count model in which one multiply and one add count as two floating-point operations (FLOPs).\n\n  Dense multiplication model:\n  - FLOPs for one application $b = K a$: \n    $$\n    F_{\\mathrm{dense}} = 2 N^2.\n    $$\n  - Bytes moved (assuming double-precision, $8$ bytes per scalar) for one application:\n    $$\n    B_{\\mathrm{dense}} = 8\\,(N^2 + 2N),\n    $$\n    corresponding to reading $K$ ($N^2$ entries), reading $a$ ($N$ entries), and writing $b$ ($N$ entries).\n\n  Matrix-free model (with $M=N$ quadrature nodes and streaming access):\n  - FLOPs per node to evaluate all $P_n(x_k)$ and $P_n'(x_k)$ by recurrences for $n=0,\\dots,N-1$ using the above formulas and precomputed scalar coefficients is modeled as $9\\,(N-2)$ when $N\\ge 2$ and $0$ when $N<2$. The dot product and accumulation cost per node is $4N$ FLOPs (two FLOPs per entry for the dot product, and two FLOPs per entry for the axpy-type accumulation).\n    Thus, total FLOPs:\n    $$\n    F_{\\mathrm{mf}} = N\\left(4N + 9\\max(N-2,0)\\right).\n    $$\n  - Bytes moved (streaming lower bound, double-precision):\n    $$\n    B_{\\mathrm{mf}} = 8\\,(2N) + 8\\,(2M) = 32 N,\n    $$\n    corresponding to reading $a$ ($N$ entries) once, reading the $N$ quadrature nodes and $N$ weights once, and writing $b$ ($N$ entries) once.\n\n  Arithmetic intensities (FLOPs per byte) and ratios:\n  $$\n  \\mathrm{AI}_{\\mathrm{dense}} = \\frac{F_{\\mathrm{dense}}}{B_{\\mathrm{dense}}},\\quad\n  \\mathrm{AI}_{\\mathrm{mf}} = \\frac{F_{\\mathrm{mf}}}{B_{\\mathrm{mf}}},\\quad\n  r_{\\mathrm{AI}} = \\frac{\\mathrm{AI}_{\\mathrm{mf}}}{\\mathrm{AI}_{\\mathrm{dense}}},\\quad\n  r_{\\mathrm{BW}} = \\frac{B_{\\mathrm{mf}}}{B_{\\mathrm{dense}}}.\n  $$\n\nYour program must:\n\n- Implement the matrix-free Legendre–Galerkin operator application and the dense verification route using the specified recurrences and Gauss–Legendre quadrature.\n- For each test case below, compute the relative error $\\varepsilon$, the arithmetic intensity ratio $r_{\\mathrm{AI}}$, and the bandwidth ratio $r_{\\mathrm{BW}}$, and output them.\n\nTest suite:\n\n- Use coefficient vectors $a \\in \\mathbb{R}^N$ with entries $a_j = 1/(j+1)$ for $j=0,\\dots,N-1$.\n- Evaluate the three metrics for the following values of $N$:\n  1. $N=1$ (boundary case with zero derivative space),\n  2. $N=2$ (smallest nontrivial derivative content),\n  3. $N=8$ (moderate size),\n  4. $N=32$ (larger size).\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each test case $N$ in the sequence $[1,2,8,32]$, the triple of floats\n  $[\\varepsilon, r_{\\mathrm{AI}}, r_{\\mathrm{BW}}]$ flattened into a single list. For example, the final output format should be\n  $$\n  [\\varepsilon_{N=1}, r_{\\mathrm{AI},N=1}, r_{\\mathrm{BW},N=1}, \\varepsilon_{N=2}, r_{\\mathrm{AI},N=2}, r_{\\mathrm{BW},N=2}, \\dots].\n  $$\n- All numerical values must be printed as Python floats in default string formatting. No physical units are involved in this problem.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of numerical analysis, specifically spectral methods for solving partial differential equations. The problem is well-posed, with all necessary mathematical definitions, algorithmic prescriptions, and analysis models provided in a clear and consistent manner. It presents a standard, verifiable task in computational science: comparing a matrix-free operator application with a dense matrix-vector product.\n\nThe core of the problem is to compute the action of the Legendre-Galerkin second-derivative operator, $b = Ka$, in two ways. The vector $a \\in \\mathbb{R}^N$ contains the coefficients of a polynomial expansion $u_N(x) = \\sum_{j=0}^{N-1} a_j P_j(x)$, where $P_j(x)$ are Legendre polynomials. The resulting vector $b \\in \\mathbb{R}^N$ has entries given by the weak form of the second derivative:\n$$\nb_i = \\int_{-1}^{1} u_N'(x) P_i'(x) dx = \\sum_{j=0}^{N-1} \\left(\\int_{-1}^{1} P_i'(x) P_j'(x) dx\\right) a_j, \\quad i=0,\\dots,N-1.\n$$\nThe term in parentheses is the $(i,j)$ entry of the stiffness matrix $K$.\n\nThe integral is numerically evaluated using $N$-point Gauss-Legendre quadrature with nodes $\\{x_k\\}_{k=1}^N$ and weights $\\{w_k\\}_{k=1}^N$. This quadrature is exact for polynomial integrands of degree up to $2N-1$. Since $P_n'(x)$ is a polynomial of degree $n-1$, the integrand $P_i'(x) P_j'(x)$ has degree at most $(i-1) + (j-1) \\le 2(N-2) = 2N-4$. As $2N-4 \\le 2N-1$ for all $N \\ge 2$, the quadrature is exact. For $N=1$, the derivatives are zero, making the integral trivially zero.\n\n**Dense Matrix Method (Verification)**\n\nThe first method is a direct, dense matrix-vector multiplication. The stiffness matrix $K$ is assembled explicitly entry by entry:\n$$\nK_{ij} = \\int_{-1}^{1} P_i'(x) P_j'(x) dx \\approx \\sum_{k=1}^{N} w_k P_i'(x_k) P_j'(x_k).\n$$\nTo implement this, we first compute and store a matrix $\\mathbf{P}'$ of size $N \\times N$, where $(\\mathbf{P}')_{ki} = P_i'(x_k)$. This is done by iterating through each quadrature node $x_k$ and evaluating the derivatives of all basis functions $P_i'$ for $i=0, \\dots, N-1$ at that node. These evaluations rely on the provided three-term recurrence relations. With the matrix $\\mathbf{P}'$ and a diagonal matrix $W = \\text{diag}(w_k)$, the stiffness matrix is computed as $K = (\\mathbf{P}')^T W \\mathbf{P}'$. The final result is then calculated as $b^{\\mathrm{dense}} = K a$.\n\n**Matrix-Free Method**\n\nThe matrix-free method avoids the explicit formation and storage of the $N \\times N$ matrix $K$. This is crucial for large-scale problems where storing $K$ (which requires $O(N^2)$ memory) is infeasible. The method is derived by rearranging the order of summations in the definition of $b_i$:\n$$\nb_i = \\sum_{j=0}^{N-1} \\left( \\sum_{k=1}^{N} w_k P_i'(x_k) P_j'(x_k) \\right) a_j = \\sum_{k=1}^{N} w_k P_i'(x_k) \\left( \\sum_{j=0}^{N-1} a_j P_j'(x_k) \\right).\n$$\nThe term in the inner parentheses is recognized as the value of the derivative of the expanded function $u'_N(x)$ at the quadrature node $x_k$, i.e., $u'_N(x_k) = \\sum_{j=0}^{N-1} a_j P_j'(x_k)$. This leads to the matrix-free formulation:\n$$\nb_i = \\sum_{k=1}^{N} w_k u'_N(x_k) P_i'(x_k).\n$$\nThe algorithm proceeds by looping over the quadrature nodes $k=1, \\dots, N$. At each node $x_k$:\n1.  The values of the basis polynomials $\\{P_n(x_k)\\}_{n=0}^{N-1}$ and their derivatives $\\{P'_n(x_k)\\}_{n=0}^{N-1}$ are evaluated simultaneously using the provided recurrence relations.\n2.  The scalar value $u'_N(x_k)$ is computed via a dot product between the coefficient vector $a$ and the vector of derivatives $\\{P'_j(x_k)\\}_{j=0}^{N-1}$.\n3.  The result vector $b$ is updated by adding the vector $\\{P'_i(x_k)\\}_{i=0}^{N-1}$ scaled by the factor $w_k u'_N(x_k)$.\n\nThis process computes the product $Ka$ without ever forming $K$.\n\n**Implementation and Analysis**\n\nThe implementation follows the described algorithms. The basis functions and their derivatives are evaluated using a helper function that implements the recurrences. For each $N$ in the test suite, both $b^{\\mathrm{mf}}$ and $b^{\\mathrm{dense}}$ are computed. The relative error $\\varepsilon = \\|b^{\\mathrm{mf}} - b^{\\mathrm{dense}}\\|_2 / \\|b^{\\mathrm{dense}}\\|_2$ is calculated to verify correctness. Since the quadrature is exact, this error is expected to be at the level of floating-point machine precision.\n\nThe performance analysis is based on the provided theoretical models for floating-point operations (FLOPs) and memory bandwidth (bytes moved). The arithmetic intensity $\\mathrm{AI} = \\text{FLOPs} / \\text{Byte}$ is calculated for both methods, and their ratios are computed to quantify the trade-offs. The total FLOPs and bytes moved are given by:\n-   Dense: $F_{\\mathrm{dense}} = 2N^2$, $B_{\\mathrm{dense}} = 8(N^2 + 2N)$\n-   Matrix-Free: $F_{\\mathrm{mf}} = N(4N + 9\\max(N-2,0))$, $B_{\\mathrm{mf}} = 32N$\n\nThese formulas are used to calculate the arithmetic intensity ratio $r_{\\mathrm{AI}} = \\mathrm{AI}_{\\mathrm{mf}} / \\mathrm{AI}_{\\mathrm{dense}}$ and the memory bandwidth ratio $r_{\\mathrm{BW}} = B_{\\mathrm{mf}} / B_{\\mathrm{dense}}$. These metrics provide insight into the computational efficiency and memory access patterns of the matrix-free approach relative to a standard dense matrix implementation.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a matrix-free Legendre-Galerkin operator application.\n    \"\"\"\n\n    def evaluate_all_P_Pl(N, x):\n        \"\"\"\n        Evaluates Legendre polynomials P_n(x) and their derivatives P_n'(x)\n        for n=0,...,N-1 at a point x using three-term recurrences.\n        \"\"\"\n        if N == 0:\n            return np.array([]), np.array([])\n        \n        P_vals = np.zeros(N)\n        Pl_vals = np.zeros(N)\n\n        # Base case n=0\n        P_vals[0] = 1.0\n        Pl_vals[0] = 0.0\n\n        # Base case n=1\n        if N > 1:\n            P_vals[1] = x\n            Pl_vals[1] = 1.0\n\n        # Recurrence for n >= 1 to compute P_{n+1}\n        for n in range(1, N - 1):\n            P_vals[n+1] = ((2*n + 1) * x * P_vals[n] - n * P_vals[n-1]) / (n + 1)\n            Pl_vals[n+1] = ((2*n + 1) * (P_vals[n] + x * Pl_vals[n]) - n * Pl_vals[n-1]) / (n + 1)\n            \n        return P_vals, Pl_vals\n\n    def calculate_perf_ratios(N):\n        \"\"\"\n        Calculates the arithmetic intensity and bandwidth ratios based on the\n        provided theoretical models.\n        \"\"\"\n        if N == 0:\n            return np.nan, np.nan\n        \n        # Dense model\n        F_dense = 2.0 * N**2\n        B_dense = 8.0 * (N**2 + 2.0 * N)\n        # B_dense is non-zero for N>=1\n        AI_dense = F_dense / B_dense if B_dense > 0 else 0\n\n        # Matrix-free model\n        F_mf = N * (4.0 * N + 9.0 * max(0, N - 2))\n        B_mf = 32.0 * N\n        # B_mf is non-zero for N>=1\n        AI_mf = F_mf / B_mf if B_mf > 0 else 0\n        \n        r_AI = AI_mf / AI_dense if AI_dense > 0 else np.inf\n        r_BW = B_mf / B_dense if B_dense > 0 else np.inf\n        \n        return r_AI, r_BW\n\n    test_cases = [1, 2, 8, 32]\n    results = []\n\n    for N in test_cases:\n        # Step 1: Setup for the given N\n        a = 1.0 / (np.arange(N) + 1.0)\n        nodes, weights = np.polynomial.legendre.leggauss(N)\n\n        # Step 2: Matrix-free computation\n        b_mf = np.zeros(N)\n        Pl_all_nodes = np.zeros((N, N)) # Stores P_j'(x_k)\n\n        for k in range(N):\n            x_k, w_k = nodes[k], weights[k]\n            \n            # Evaluate all P_j(x_k) and P_j'(x_k)\n            _ , Pl_vals_k = evaluate_all_P_Pl(N, x_k)\n            Pl_all_nodes[k, :] = Pl_vals_k\n            \n            # Compute u_N'(x_k)\n            u_N_prime_xk = np.dot(a, Pl_vals_k)\n            \n            # Accumulate into b_mf\n            b_mf += w_k * u_N_prime_xk * Pl_vals_k\n        \n        # Step 3: Dense matrix computation for verification\n        K = np.zeros((N,N))\n        # K = Pl_all_nodes.T @ np.diag(weights) @ Pl_all_nodes is more concise\n        # but the explicit loop is also clear.\n        for i in range(N):\n            for j in range(N):\n                K[i,j] = np.sum(weights * Pl_all_nodes[:, i] * Pl_all_nodes[:, j])\n\n        b_dense = K @ a\n        \n        # Step 4: Compute metrics\n        # Relative error\n        diff_norm = np.linalg.norm(b_mf - b_dense)\n        norm_bdense = np.linalg.norm(b_dense)\n        \n        if norm_bdense == 0.0:\n            # As per problem: if ||b_dense||=0, error is 0 if b_mf=b_dense.\n            # This occurs for N=1.\n            eps = 0.0 if diff_norm == 0.0 else np.inf\n        else:\n            eps = diff_norm / norm_bdense\n            \n        # Performance ratios\n        r_AI, r_BW = calculate_perf_ratios(N)\n        \n        results.extend([eps, r_AI, r_BW])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}