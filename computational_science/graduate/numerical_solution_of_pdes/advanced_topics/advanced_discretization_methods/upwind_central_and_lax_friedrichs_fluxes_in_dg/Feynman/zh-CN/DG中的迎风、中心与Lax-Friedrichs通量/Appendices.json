{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础的理论分析开始，它将为后续的实践奠定坚实的数学基础。该练习  聚焦于最简单的一维线性平流方程，要求你推导不同数值通量下的稳定性条件。通过这个过程，你将清晰地看到数值耗散是如何直接影响显式时间步长的 Courant–Friedrichs–Lewy ($CFL$) 限制的，从而从根本上理解为什么中心通量本质上是不稳定的，而迎风和Lax-Friedrichs通量则可以稳定求解。",
            "id": "3459774",
            "problem": "考虑周期区间 $[0,1]$ 上的一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中 $a \\in \\mathbb{R}\\setminus\\{0\\}$ 为常数。设该区域被划分为 $N$ 个大小为 $h = 1/N$ 的均匀单元。在每个单元上，使用次数至多为 $p \\in \\mathbb{N}_{0}$ 的多项式，通过 discontinuous Galerkin (DG) 方法进行离散化。用 $\\llbracket \\cdot \\rrbracket$ 表示界面跳跃，用 $\\{\\cdot\\}$ 表示界面平均，并考虑由线性物理通量 $f(u)=a u$ 导出的数值通量：\n- 中心通量：$f^{*}(u^{-},u^{+}) = a\\,\\{u\\}$，\n- 迎风通量：$f^{*}(u^{-},u^{+}) = a\\,u^{-}$ (若 $a0$) 且 $f^{*}(u^{-},u^{+}) = a\\,u^{+}$ (若 $a0$)，\n- Lax–Friedrichs (Rusanov) 通量：$f^{*}(u^{-},u^{+}) = a\\,\\{u\\} - \\frac{\\alpha}{2}\\,\\llbracket u \\rrbracket$ (其中 $\\alpha \\ge |a|$)。\n\n假设在每个参考单元上使用模态 Legendre 基，该参考单元通过仿射映射到物理单元，从而使得局部质量矩阵是对角的，且其元素与 $h$ 成正比。设 $\\|\\cdot\\|_{L^{2}}$ 表示由 DG 质量矩阵导出的离散 $L^{2}$ 范数。你可以使用一个基本事实，即在大小为 $h$ 的单个单元 $K$ 上的精确一维多项式迹不等式：\n$$\n|v|^{2}_{\\partial K} \\le \\frac{2p+1}{h}\\,\\|v\\|^{2}_{L^{2}(K)} \\quad \\text{for all } v \\in \\mathbb{P}_{p}(K),\n$$\n其中 $|v|^{2}_{\\partial K}$ 表示 $v$ 在 $K$ 的两个端点处的迹的平方和。\n\n仅使用守恒、半离散层面上的分部积分以及上述迹不等式，推导前向 Euler 时间步长 $\\Delta t$ 的显式 Courant–Friedrichs–Lewy (CFL) 界限，以确保在每次通量选择下，离散 $L^{2}$ 范数在一次前向 Euler 更新后不增加。然后利用经典三阶强稳定性保持 Runge–Kutta 方法 (SSP-RK3) 的强稳定性保持 (Strong Stability Preserving, SSP) 特性，得出 SSP-RK3 对应的 $\\Delta t_{\\max}$。\n\n你的最终答案必须是单行三个闭式表达式，给出 $\\Delta t_{\\max}$ 作为 $p$ 和 $h$ 的函数（以及在适用情况下，作为 $|a|$、$\\alpha$ 的函数），顺序为：中心通量、迎风通量、Lax–Friedrichs 通量。在你的推导中解释界面耗散水平为何以及如何改变稳定性常数。以符号形式作答；不要代入数值。最终表达式不得包含单位。",
            "solution": "问题要求求解应用于线性平流方程的 discontinuous Galerkin (DG) 方法，在前向 Euler 和三阶强稳定性保持 Runge-Kutta (SSP-RK3) 时间积分下，所允许的最大时间步长 $\\Delta t_{\\max}$。稳定性判据是解的离散 $L^2$ 范数不增加。必须对三种不同的数值通量进行分析：中心通量、迎风通量和 Lax-Friedrichs 通量。\n\n首先，我们建立 DG 方法的半离散格式。对于方程 $u_t + a u_x = 0$，在单元 $K_j = [x_{j-1/2}, x_{j+1/2}]$ 上的 DG 格式是：在次数至多为 $p$ 的分片多项式空间中寻找 $u_h$，使得对于同一空间中的任何检验函数 $v_h$ 都有：\n$$\n\\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\, dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\, dx + \\left[ f^*(u_h) v_h \\right]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\n其中 $f^*(u_h)$ 是数值通量，它依赖于单元界面两侧 $u_h$ 的值。在界面 $x_{j+1/2}$ 处，令 $u^-$ 表示来自单元 $K_j$ 的值 $u_h(x_{j+1/2}^-)$，令 $u^+$ 表示来自单元 $K_{j+1}$ 的值 $u_h(x_{j+1/2}^+)$。边界项为 $f^*(u^-, u^+) v_h(x_{j+1/2}^-) - f^*(u_{j-1/2}^-, u_{j-1/2}^+) v_h(x_{j-1/2}^-)$。\n\n为了分析 $L^2$ 稳定性，我们设置检验函数 $v_h = u_h$ 并对区域 $[0,1]$ 中的所有单元 $K_j$求和。设 $\\|\\cdot\\|_{L^2}$ 为标准 $L^2$ 范数，定义为 $\\|u_h\\|_{L^2}^2 = \\sum_j \\int_{K_j} u_h^2 \\, dx$。\n$$\n\\sum_j \\int_{K_j} u_h \\frac{\\partial u_h}{\\partial t} \\, dx = \\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2\n$$\n右侧变为：\n$$\n\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = \\sum_j \\left( \\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx - f^*_{j+1/2} u_h(x_{j+1/2}^-) + f^*_{j-1/2} u_h(x_{j-1/2}^-) \\right)\n$$\n其中 $f^*_{j+1/2}$ 表示界面 $x_{j+1/2}$ 处的数值通量。\n积分项可以直接计算：\n$$\n\\int_{K_j} a u_h \\frac{\\partial u_h}{\\partial x} \\, dx = \\frac{a}{2} \\int_{K_j} \\frac{\\partial(u_h^2)}{\\partial x} \\, dx = \\frac{a}{2} \\left[ u_h^2(x_{j+1/2}^-) - u_h^2(x_{j-1/2}^-) \\right]\n$$\n对所有单元 $j=1, \\dots, N$求和，并按界面（利用周期性）重组各项，界面 $x_{j+1/2}$ 处来自单元 $K_j$ 和 $K_{j+1}$ 的贡献为：\n- 来自 $K_j$：$\\frac{a}{2} u_h(x_{j+1/2}^-)^2 - f^*_{j+1/2} u_h(x_{j+1/2}^-)$\n- 来自 $K_{j+1}$：$-\\frac{a}{2} u_h(x_{j+1/2}^+)^2 + f^*_{j+1/2} u_h(x_{j+1/2}^+)$\n界面 $x_{j+1/2}$ 处的和为：\n$$\nf^*_{j+1/2} (u_h(x_{j+1/2}^+) - u_h(x_{j+1/2}^-)) - \\frac{a}{2} (u_h(x_{j+1/2}^+)^2 - u_h(x_{j+1/2}^-)^2)\n$$\n使用跳跃算子 $\\llbracket u \\rrbracket = u^+ - u^-$ 和平均算子 $\\{u\\} = (u^+ + u^-)/2$，该表达式简化为：\n$$\nf^* \\llbracket u \\rrbracket - a \\{u\\} \\llbracket u \\rrbracket = (f^* - a\\{u\\}) \\llbracket u \\rrbracket\n$$\n对所有界面求和，我们得到 $L^2$ 范数平方的变化率：\n$$\n\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = \\sum_{j=1}^N \\left( f^*(u_h^-, u_h^+) - a\\{u_h\\} \\right)_{j+1/2} \\llbracket u_h \\rrbracket_{j+1/2}\n$$\n此项表示界面处的数值耗散。对于稳定的半离散化，我们要求此量为非正。\n\n现在，我们对每种数值通量进行分析：\n1.  **中心通量**：$f^*(u^-, u^+) = a\\{u\\}$。\n    耗散项为 $(a\\{u\\} - a\\{u\\}) \\llbracket u \\rrbracket = 0$。\n    因此，$\\frac{d}{dt} \\|u_h\\|_{L^2}^2 = 0$。该半离散格式是能量守恒的。\n    对于前向 Euler 更新 $u_h^{n+1} = u_h^n + \\Delta t \\, \\mathcal{L}_h(u_h^n)$，其中 $\\mathcal{L}_h$ 是空间算子，范数演化如下：\n    $$\n    \\|u_h^{n+1}\\|_{L^2}^2 = \\|u_h^n + \\Delta t \\, \\mathcal{L}_h(u_h^n)\\|_{L^2}^2 = \\|u_h^n\\|_{L^2}^2 + 2\\Delta t (u_h^n, \\mathcal{L}_h(u_h^n)) + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2\n    $$\n    因为 $(u_h, \\mathcal{L}_h u_h) = \\frac{1}{2} \\frac{d}{dt}\\|u_h\\|_{L^2}^2 = 0$，这变为 $\\|u_h^{n+1}\\|_{L^2}^2 = \\|u_h^n\\|_{L^2}^2 + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2$。\n    为使范数不增加，我们需要 $(\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2 \\le 0$。由于 $\\|\\cdot\\|_{L^2}^2 \\ge 0$，这要求要么 $\\mathcal{L}_h(u_h^n)=0$（稳态），要么 $\\Delta t=0$。因此，对于任何非平凡解，前向 Euler 格式对于任何 $\\Delta t  0$ 都是不稳定的。唯一能确保范数不增加的有效 CFL 界限是 $\\Delta t \\le 0$。\n\n2.  **迎风通量**：\n    如果 $a  0$, $f^*(u^-, u^+) = a u^-$。耗散项为 $(a u^- - a\\{u\\}) \\llbracket u \\rrbracket = (a u^- - a\\frac{u^-+u^+}{2})(u^+-u^-) = -\\frac{a}{2}(u^+-u^-)^2 = -\\frac{a}{2}\\llbracket u \\rrbracket^2$。\n    如果 $a  0$, $f^*(u^-, u^+) = a u^+$。耗散项为 $(a u^+ - a\\{u\\}) \\llbracket u \\rrbracket = (a u^+ - a\\frac{u^-+u^+}{2})(u^+-u^-) = \\frac{a}{2}(u^+-u^-)^2 = \\frac{a}{2}\\llbracket u \\rrbracket^2$。\n    在两种情况下，我们都可以将耗散写为 $-\\frac{|a|}{2} \\llbracket u \\rrbracket^2$。\n    所以，$\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = -\\sum_{j=1}^N \\frac{|a|}{2} \\llbracket u_h \\rrbracket_{j+1/2}^2 \\le 0$。该格式是耗散的。\n\n3.  **Lax–Friedrichs 通量**：$f^*(u^-, u^+) = a\\{u\\} - \\frac{\\alpha}{2}\\llbracket u \\rrbracket$，其中 $\\alpha \\ge |a|$。\n    耗散项为 $(a\\{u\\} - \\frac{\\alpha}{2}\\llbracket u \\rrbracket - a\\{u\\}) \\llbracket u \\rrbracket = -\\frac{\\alpha}{2} \\llbracket u \\rrbracket^2$。\n    所以，$\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|_{L^2}^2 = -\\sum_{j=1}^N \\frac{\\alpha}{2} \\llbracket u_h \\rrbracket_{j+1/2}^2 \\le 0$。此格式也是耗散的。\n\n对于耗散通量，前向 Euler 稳定性条件是：\n$$\n- \\Delta t \\sum_j C_{flux} \\llbracket u_h \\rrbracket_j^2 + (\\Delta t)^2 \\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2 \\le 0\n$$\n其中，迎风通量 $C_{flux} = |a|$，Lax-Friedrichs 通量 $C_{flux} = \\alpha$。这导致了 CFL 条件：\n$$\n\\Delta t \\le \\frac{\\sum_j C_{flux} \\llbracket u_h \\rrbracket_j^2}{\\|\\mathcal{L}_h(u_h^n)\\|_{L^2}^2}\n$$\n为了找到 $\\Delta t$ 的一致界，我们需要找到右侧在所有可能的解 $u_h$ 上的最小值。这需要详细分析来界定 $\\|\\mathcal{L}_h u_h\\|_{L^2}^2$。这涉及到使用多项式的反不等式和给定的迹不等式，将空间算子的范数与解的范数及其跳跃关联起来。这种分析在 DG 文献中是标准的，但超出了简单地按顺序使用所述工具的范围。此分析的一个关键结果是，DG 空间算子的最大特征值（或算子范数）的尺度为 $\\frac{C_{flux}(2p+1)^2}{h}$，或者更精确地为了稳定性，它导致的时间步长限制的尺度为 $\\frac{h}{C_{flux}(2p+1)}$。项 $2p+1$ 的存在可以通过将迹不等式与 Legendre 多项式（模态基）的其他性质相结合来严格推导，但完整的推导过程很长。其本质是，高阶多项式相对于其 $L^2$-范数可以有大得多的导数和边界值，这收紧了稳定性约束。\n对于一个多项式 $v \\in \\mathbb{P}_p(K)$，迹不等式 $|v|^2_{\\partial K} \\le \\frac{2p+1}{h} \\|v\\|^2_{L^2(K)}$ 表明边界值由单元内部范数控制，系数为 $(2p+1)/h$。空间算子 $\\mathcal{L}_h$ 既涉及单元内部的导数，也涉及边界通量。一个反不等式 $\\|v'\\|_{L^2(K)} \\le C_p h^{-1} \\|v\\|_{L^2(K)}$ 控制着导数项，其中 $C_p$ 与 $p^2$ 成比例。这两种效应结合起来，产生一个算子范数 $\\|\\mathcal{L}_h\\|$，其尺度约为 $\\sim C_{flux} \\frac{(2p+1)}{h}$。这导致了形式为 $\\Delta t \\le c \\frac{1}{\\|\\mathcal{L}_h\\|}$ 的前向 Euler 稳定性极限，从而得到：\n$$\n\\Delta t \\le \\frac{c' h}{C_{flux}(2p+1)}\n$$\n对于 DG 方法，常数 $c'$ 被发现是 $1$。\n- 对于迎风通量 ($C_{flux} = |a|$): $\\Delta t \\le \\frac{h}{|a|(2p+1)}$。\n- 对于 Lax-Friedrichs 通量 ($C_{flux} = \\alpha$): $\\Delta t \\le \\frac{h}{\\alpha(2p+1)}$。耗散 $\\alpha$ 必须大于或等于 $|a|$，因此如果 $\\alpha  |a|$，这是一个更严格的条件。与迎风通量的最小耗散相比，由 LF 通量（由 $\\alpha$ 控制）增加的耗散需要更小的时间步长来维持稳定性。\n\n最后，我们考虑 SSP-RK3 方法。SSP 方法的一个关键特性是，如果前向 Euler 方法对于步长 $\\Delta t_{FE}$ 是稳定的（在不增加凸泛函的意义上，这里指 $L^2$-范数），那么一个 $m$ 阶 SSP-RK 方法对于 $\\Delta t \\le C_{SSP} \\Delta t_{FE}$ 是稳定的，其中 $C_{SSP}$ 是 Runge-Kutta 方法的 SSP 系数。对于经典的三阶 SSP-RK3 方法，SSP 系数 $C_{SSP}$ 为 $1$。\n因此，SSP-RK3 的最大时间步长与前向 Euler 的相同。\n\n$\\Delta t_{\\max}$ 的最终结果是：\n1.  **中心通量**：由于该格式是能量中性的，任何显式时间步进方法都是不稳定的。$\\Delta t_{\\max} = 0$。\n2.  **迎风通量**：$\\Delta t_{\\max} = \\frac{h}{|a|(2p+1)}$。\n3.  **Lax-Friedrichs 通量**：$\\Delta t_{\\max} = \\frac{h}{\\alpha(2p+1)}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  \\frac{h}{|a|(2p+1)}  \\frac{h}{\\alpha(2p+1)}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在理解了线性问题的稳定性之后，我们将转向更具挑战性的非线性守恒律——伯格斯方程（Burgers' equation）。对于这类会产生激波的方程，仅仅保证数值稳定性是不够的，解还必须满足物理上的熵条件。这个实践  旨在通过编码实现，对比一个熵守恒通量和一个熵稳定通量，让你亲眼见证耗散机制对于正确捕捉激波和确保物理真实性的至关重要性。",
            "id": "3459810",
            "problem": "考虑一维无粘性 Burgers 方程，这是一个标量守恒律，\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{u^2}{2}\\right) = 0,\n$$\n该方程定义在一个周期性域上。设域为区间 $[0,1]$，空间坐标为 $x \\in [0,1]$，时间为 $t \\ge 0$。零阶（分片常数基函数）间断 Galerkin (DG) 方法等价于一个演化单元平均值的守恒有限体积法。记 $u_i(t)$ 为单元 $i$ 中 $u$ 的单元平均值，网格尺寸均匀为 $\\Delta x$，并令 $\\hat{f}_{i+1/2}$ 表示在单元 $i$ 和单元 $i+1$ 之间的界面上近似物理通量 $f(u) = u^2/2$ 的一个两点数值通量。\n\n从守恒律和单元平均值的定义出发，每个单元的半离散更新格式为\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}\\right),\n$$\n这是散度定理和对分片常数表示进行精确积分的结果。数值通量 $\\hat{f}$ 必须是一致的和守恒的，以确保离散质量守恒。\n\n定义三个界面通量：\n- 算术中心通量\n$$\n\\hat{f}^{\\text{cen}}(u_L,u_R) = \\frac{1}{2}\\left(f(u_L) + f(u_R)\\right),\n$$\n其中 $u_L$ 和 $u_R$ 是界面处的左右状态。\n- 一个熵守恒两点通量（由 Tadmor 针对 Burgers 方程提出），设计用于通量差分分裂形式，\n$$\n\\hat{f}^{\\text{ec}}(u_L,u_R) = \\frac{u_L^2 + u_L u_R + u_R^2}{6},\n$$\n该通量是对称的且与 $f(u)$ 一致，当与分裂形式的体积项离散化结合使用时，可以得到离散熵守恒。\n- 一个熵稳定通量，它将熵守恒中心通量与 Lax–Friedrichs (LF) 耗散相结合，\n$$\n\\hat{f}^{\\text{es}}(u_L,u_R) = \\hat{f}^{\\text{ec}}(u_L,u_R) - \\frac{1}{2}\\alpha(u_L,u_R)\\left(u_R - u_L\\right), \\quad \\alpha(u_L,u_R) = \\max\\left(\\left|u_L\\right|,\\left|u_R\\right|\\right),\n$$\n在对体积项采用合适的分裂形式离散化时，该通量可以产生一个离散熵不等式。\n\n设凸熵为\n$$\nU(u) = \\frac{u^2}{2}, \\qquad \\text{其关联的熵通量为} \\qquad \\Psi(u) = \\frac{u^3}{3}.\n$$\n定义时刻 $t$ 的离散总熵为\n$$\nS(t) = \\sum_{i} U\\left(u_i(t)\\right) \\Delta x.\n$$\n\n你的任务是实现一个完整的求解器，用于求解带有显式强稳定性保持三阶 Runge–Kutta (SSP-RK3) 时间步进和周期性边界条件的分片常数（零阶）间断 Galerkin 方法。使用 Courant–Friedrichs–Lewy (CFL) 条件来选择时间步长，\n$$\n\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{\\max_i \\left|u_i\\right| + \\varepsilon},\n$$\n其中 $\\varepsilon$ 是一个小的正常数，以避免当解恒为零时出现除以零的情况。\n\n在单元界面处实现通量差分，针对以下两种通量选择：熵守恒通量 $\\hat{f}^{\\text{ec}}$ 和熵稳定通量 $\\hat{f}^{\\text{es}}$（熵守恒加 Lax–Friedrichs 耗散）。为完整起见，你也可以实现算术中心通量 $\\hat{f}^{\\text{cen}}$，但下面要求的输出将只使用 $\\hat{f}^{\\text{ec}}$ 和 $\\hat{f}^{\\text{es}}$。\n\n测试套件：\n使用以下三个初始数据配置，每个都在周期性域 $[0,1]$ 上，其中网格尺寸 $\\Delta x = 1/N$，单元数 $N$，最终时间 $T$，以及指定的 Courant–Friedrichs–Lewy (CFL) 数。对于每种情况，计算总熵的变化量 $\\Delta S = S(T) - S(0)$，分别针对 $\\hat{f}^{\\text{ec}}$ 和 $\\hat{f}^{\\text{es}}$ 两种通量。\n\n- 情况1（激波形成的 Riemann 问题，理想路径）：$N = 400$, $T = 0.20$, $\\text{CFL} = 0.40$，初始条件\n$$\nu(x,0) = \\begin{cases}\n1,  x  0.5, \\\\\n-1,  x \\ge 0.5,\n\\end{cases}\n$$\n使用周期性边界。输出此情况下的两个浮点数 $[\\Delta S_{\\text{ec}}, \\Delta S_{\\text{es}}]$。\n\n- 情况2（稀疏波 Riemann 问题，覆盖平滑膨胀）：$N = 400$, $T = 0.20$, $\\text{CFL} = 0.40$，初始条件\n$$\nu(x,0) = \\begin{cases}\n-1,  x  0.5, \\\\\n1,  x \\ge 0.5,\n\\end{cases}\n$$\n使用周期性边界。输出此情况下的两个浮点数 $[\\Delta S_{\\text{ec}}, \\Delta S_{\\text{es}}]$。\n\n- 情况3（常数状态，边界情况）：$N = 200$, $T = 0.20$, $\\text{CFL} = 0.40$，初始条件\n$$\nu(x,0) = 0 \\quad \\text{for all } x \\in [0,1].\n$$\n输出此情况下的两个浮点数 $[\\Delta S_{\\text{ec}}, \\Delta S_{\\text{es}}]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含按顺序排列的六个结果，这些结果是三个测试案例的汇总，格式为一个用方括号括起来的逗号分隔的 Python 列表。顺序如下\n$$\n\\left[\\Delta S_{\\text{ec}}^{(1)}, \\Delta S_{\\text{es}}^{(1)}, \\Delta S_{\\text{ec}}^{(2)}, \\Delta S_{\\text{es}}^{(2)}, \\Delta S_{\\text{ec}}^{(3)}, \\Delta S_{\\text{es}}^{(3)}\\right].\n$$\n不涉及物理单位，但所有数值必须以浮点数形式返回。程序必须是完整且可运行的。",
            "solution": "所提出的问题是偏微分方程数值方法领域中一个适定且标准的练习。它涉及一维无粘性 Burgers 方程的有限体积法的实现和分析。所有提供的数据、方程和参数在科学上都是合理的、一致的，并且足以推导出一个唯一的计算解。因此，该问题被认为是有效的。\n\n解决方案的开发将首先概述数值方法，包括空间和时间离散化。然后，我们将详细说明指定的数值通量、边界条件和时间步进格式的实现策略。最后，我们将对三个指定的测试案例执行该算法，并分析离散总熵的变化。\n\n**1. 控制方程与空间离散化**\n\n该问题针对的是被称为无粘性 Burgers 方程的标量非线性守恒律：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0, \\quad \\text{其中物理通量为} \\quad f(u) = \\frac{u^2}{2}.\n$$\n空间域为 $x \\in [0,1]$，带有周期性边界条件。指定的方法是零阶间断 Galerkin (DG) 方法，它等价于一个守恒有限体积法。\n\n将域划分为 $N$ 个均匀单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$，其中 $i=0, \\dots, N-1$。每个单元的宽度为 $\\Delta x = 1/N$。每个单元内的解由其单元平均值 $u_i(t)$ 表示。\n在单元 $C_i$ 上对偏微分方程进行积分，并应用散度定理，得到单元平均值的精确关系式：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left(f(u(x_{i+1/2},t)) - f(u(x_{i-1/2},t))\\right).\n$$\n由于解 $u$ 在单元界面处是不连续的，因此精确的点态通量 $f(u)$ 被一个数值通量函数 $\\hat{f}(u_L, u_R)$ 所取代，该函数依赖于界面左侧 ($u_L$) 和右侧 ($u_R$) 的状态。对于界面 $x_{i+1/2}$，我们有 $u_L = u_i(t)$ 和 $u_R = u_{i+1}(t)$。这导出了常微分方程 (ODEs) 的半离散系统：\n$$\n\\frac{d u_i}{dt} = -\\frac{1}{\\Delta x}\\left(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}\\right),\n$$\n其中 $\\hat{f}_{i+1/2} = \\hat{f}(u_i, u_{i+1})$ 且 $\\hat{f}_{i-1/2} = \\hat{f}(u_{i-1}, u_i)$。\n\n**2. 数值通量与熵分析**\n\n数值通量的选择对于格式的稳定性和准确性至关重要，特别是对于会产生不连续性（激波）的非线性问题。本问题研究了两种与熵稳定性相关的高级通量函数。\n\nBurgers 方程的熵是一个凸函数 $U(u) = u^2/2$，其对应的熵通量为 $\\Psi(u) = u^3/3$。对于物理上正确的弱解，总熵必须随时间不增：$\\frac{d}{dt} \\int U(u) dx \\le 0$。一个数值格式在离散层面上应理想地复制这一性质。\n\n离散总熵由 $S(t) = \\sum_{i=0}^{N-1} U(u_i(t)) \\Delta x$ 给出。我们将考察其变化量 $\\Delta S = S(T) - S(0)$，针对两种通量选择：\n\na) **熵守恒 (EC) 通量**：\n$$\n\\hat{f}^{\\text{ec}}(u_L, u_R) = \\frac{u_L^2 + u_L u_R + u_R^2}{6}.\n$$\n这种通量是专门设计的，对于光滑解，它能守恒离散总熵 $S(t)$。然而，它缺乏耗散机制，而这种机制对于稳定跨激波的解并正确模拟物理熵减是必需的。\n\nb) **熵稳定 (ES) 通量**：\n$$\n\\hat{f}^{\\text{es}}(u_L, u_R) = \\hat{f}^{\\text{ec}}(u_L, u_R) - \\frac{1}{2}\\alpha(u_L, u_R)(u_R - u_L).\n$$\n该通量在 EC 通量的基础上增加了一个数值耗散项。系数 $\\alpha(u_L, u_R) = \\max(|u_L|, |u_R|)$ 是最大局部特征速度 $|u|$ 的一个估计。这种形式是 Lax-Friedrichs 通量的一个变体，但建立在熵守恒的基础上。增加的项确保了该格式满足一个离散熵不等式，这意味着它能在激波处正确地耗散熵并提供稳定性。\n\n**3. 时间积分**\n\n半离散系统 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}(\\mathbf{u})$ 必须在时间上进行积分，其中 $\\mathbf{u} = [u_0, \\dots, u_{N-1}]^T$ 且 $\\mathbf{L}$ 是空间离散化算子。该问题指定了三阶强稳定性保持 Runge-Kutta (SSP-RK3) 方法。给定时刻 $t_n$ 的解 $\\mathbf{u}^n$，时刻 $t_{n+1} = t_n + \\Delta t$ 的解通过三个阶段计算得出：\n$$\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t \\mathbf{L}(\\mathbf{u}^n)\n$$\n$$\n\\mathbf{u}^{(2)} = \\frac{3}{4}\\mathbf{u}^n + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t \\mathbf{L}(\\mathbf{u}^{(1)})\\right)\n$$\n$$\n\\mathbf{u}^{n+1} = \\frac{1}{3}\\mathbf{u}^n + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t \\mathbf{L}(\\mathbf{u}^{(2)})\\right)\n$$\n时间步长 $\\Delta t$ 根据 Courant-Friedrichs-Lewy (CFL) 条件自适应地选择，以确保稳定性：\n$$\n\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i| + \\varepsilon},\n$$\n其中，为保证稳定性，$\\text{CFL}  1$，而 $\\varepsilon$ 是一个小的正数（例如 $10^{-15}$）以防止除以零。\n\n**4. 实现细节**\n\n算法实现如下：\n- **初始化**：在 $[0,1]$ 上创建一个包含 $N$ 个单元的均匀网格。单元中心为 $x_i = (i+0.5)\\Delta x$，其中 $i=0, \\dots, N-1$。解向量 $\\mathbf{u}$ 根据指定的初始条件用值 $u_i(0) = u(x_i, 0)$ 进行初始化。计算初始熵 $S(0)$。\n- **时间推进**：一个从 $t=0$ 开始直到最终时间 $T$ 的循环。在每次迭代中，计算 $\\Delta t$，确保最后一步不会超过 $T$。SSP-RK3 算法在此时间步长上推进解。\n- **右端项 (RHS) 评估**：SSP-RK3 步骤的核心是评估右端项向量 $\\mathbf{L}(\\mathbf{u})$。这包括：\n    1. 为所有界面定义左 ($u_L$) 和右 ($u_R$) 状态。对于周期性边界，如果 $\\mathbf{u} = [u_0, \\dots, u_{N-1}]$，则左状态是 $\\mathbf{u}$，右状态是一个循环移位，即 $[u_1, \\dots, u_{N-1}, u_0]$。\n    2. 使用 $\\hat{f}^{\\text{ec}}$ 或 $\\hat{f}^{\\text{es}}$ 计算每个界面 $i=0, \\dots, N-1$ 上的数值通量 $\\hat{f}_{i+1/2}$。\n    3. 计算每个单元的通量散度：$L_i(\\mathbf{u}) = -\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2})$。这也可以通过循环移位来高效处理。\n- **最终计算**：时间循环结束后，计算最终熵 $S(T)$。然后计算所需的输出 $\\Delta S = S(T) - S(0)$。\n\n对三个测试案例中的每一个，都使用熵守恒和熵稳定两种通量重复此过程。\n\n- **情况1（激波）**：初始条件形成一个激波。EC 通量由于缺少耗散，预计会产生振荡，并且可能因为非物理伪影而无法正确地守恒熵。ES 通量应能干净地捕捉激波，并伴随总熵的相应减少（$\\Delta S_{\\text{es}}  0$）。\n- **情况2（稀疏波）**：解是一个光滑的膨胀波。两种通量都应表现良好。EC 通量应能以接近机器精度的程度守恒熵（$\\Delta S_{\\text{ec}} \\approx 0$）。ES 通量在光滑区域的耗散极小，因此也应几乎守恒熵。\n- **情况3（常数状态）**：初始解和精确解均为 $u(x,t)=0$。数值通量为零，因此 $\\mathbf{L}(\\mathbf{u})=0$。解必须保持不变。因此，对于两种通量，$\\Delta S$ 必须精确为 $0$。这是对实现的一个关键的合理性检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases.\n    \"\"\"\n    # Small constant to prevent division by zero in CFL condition.\n    EPSILON = 1e-15\n\n    # =========================================================================\n    # Flux Functions\n    # =========================================================================\n\n    def flux_ec(u_L, u_R):\n        \"\"\"Entropy-conservative flux for Burgers' equation.\"\"\"\n        return (u_L**2 + u_L * u_R + u_R**2) / 6.0\n\n    def flux_es(u_L, u_R):\n        \"\"\"Entropy-stable flux for Burgers' equation.\"\"\"\n        f_ec = flux_ec(u_L, u_R)\n        alpha = np.maximum(np.abs(u_L), np.abs(u_R))\n        return f_ec - 0.5 * alpha * (u_R - u_L)\n\n    FLUX_FUNCTIONS = {\n        'ec': flux_ec,\n        'es': flux_es,\n    }\n\n    # =========================================================================\n    # Spatial Discretization (RHS of the semi-discrete form)\n    # =========================================================================\n\n    def compute_rhs(u, dx, flux_type):\n        \"\"\"\n        Computes the right-hand-side of the semi-discrete form du/dt = L(u).\n        L(u) = -1/dx * (f_{i+1/2} - f_{i-1/2}).\n        \"\"\"\n        flux_func = FLUX_FUNCTIONS[flux_type]\n        \n        # States at interfaces: u_L is u_i, u_R is u_{i+1}\n        u_L = u\n        u_R = np.roll(u, -1)  # Periodic boundary condition\n        \n        # Calculate numerical fluxes at all interfaces i+1/2\n        flux_hat = flux_func(u_L, u_R)\n        \n        # Flux difference for each cell\n        flux_hat_left = np.roll(flux_hat, 1) # Flux at i-1/2\n        \n        return -1.0 / dx * (flux_hat - flux_hat_left)\n\n    # =========================================================================\n    # Entropy Calculation\n    # =========================================================================\n\n    def calculate_entropy(u, dx):\n        \"\"\"Calculates the discrete total entropy S(t) = sum( U(u_i) * dx ).\"\"\"\n        # Entropy function U(u) = u^2 / 2\n        return 0.5 * np.sum(u**2) * dx\n\n    # =========================================================================\n    # Main Simulation Runner\n    # =========================================================================\n\n    def run_simulation(N, T, CFL, u0_func, flux_type):\n        \"\"\"\n        Runs a single simulation case.\n\n        Args:\n            N (int): Number of cells.\n            T (float): Final time.\n            CFL (float): CFL number for time step calculation.\n            u0_func (function): Function to define the initial condition.\n            flux_type (str): 'ec' for entropy-conservative, 'es' for entropy-stable.\n\n        Returns:\n            float: The change in total entropy, Delta_S = S(T) - S(0).\n        \"\"\"\n        # --- Grid and Initial Condition ---\n        dx = 1.0 / N\n        x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)\n        u = u0_func(x)\n        \n        S0 = calculate_entropy(u, dx)\n        \n        t = 0.0\n        \n        # --- Time-stepping loop ---\n        while t  T:\n            # --- Calculate time step dt ---\n            max_wave_speed = np.max(np.abs(u))\n            dt = CFL * dx / (max_wave_speed + EPSILON)\n            if t + dt  T:\n                dt = T - t\n\n            # --- SSP-RK3 Time Stepping ---\n            # Stage 1\n            L0 = compute_rhs(u, dx, flux_type)\n            u1 = u + dt * L0\n            \n            # Stage 2\n            L1 = compute_rhs(u1, dx, flux_type)\n            u2 = 0.75 * u + 0.25 * (u1 + dt * L1)\n            \n            # Stage 3\n            L2 = compute_rhs(u2, dx, flux_type)\n            u = (1.0/3.0) * u + (2.0/3.0) * (u2 + dt * L2)\n            \n            t += dt\n\n        # --- Final Entropy Calculation ---\n        S_final = calculate_entropy(u, dx)\n        \n        return S_final - S0\n\n    # =========================================================================\n    # Test Cases\n    # =========================================================================\n    \n    test_cases = [\n        # Case 1: Shock-forming Riemann problem\n        {\n            'N': 400, 'T': 0.20, 'CFL': 0.40,\n            'u0_func': lambda x: 1.0 * (x  0.5) - 1.0 * (x = 0.5)\n        },\n        # Case 2: Rarefaction Riemann problem\n        {\n            'N': 400, 'T': 0.20, 'CFL': 0.40,\n            'u0_func': lambda x: -1.0 * (x  0.5) + 1.0 * (x = 0.5)\n        },\n        # Case 3: Constant state\n        {\n            'N': 200, 'T': 0.20, 'CFL': 0.40,\n            'u0_func': lambda x: np.zeros_like(x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run with entropy-conservative flux\n        delta_s_ec = run_simulation(**case, flux_type='ec')\n        results.append(delta_s_ec)\n        \n        # Run with entropy-stable flux\n        delta_s_es = run_simulation(**case, flux_type='es')\n        results.append(delta_s_es)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "我们已经知道耗散在激波处是必不可少的，但过多的耗散会模糊解的光滑部分，从而降低精度。这个高级实践  探讨了一种更智能的策略：混合格式。你将设计并实现一个基于激波传感器的DG方法，该方法能自动在光滑区域使用高精度的中心通量，而在激波附近切换到稳健的Lax-Friedrichs通量，从而在稳定性与精度之间取得理想的平衡。",
            "id": "3459800",
            "problem": "考虑由伯格斯方程 $u_t + \\tfrac{1}{2}(u^2)_x = 0$ 给出的标量守恒律，定义在周期性一维区间 $[0,1]$ 上。您将设计并实现在一个均匀网格上的多项式阶数为 $1$ 的间断伽辽金 (DG) 方法，并研究不同数值通量对激波捕捉和稳定性的影响。您的实现必须从第一性原理出发：守恒律的弱形式、使用合适基函数的 DG 框架以及相容的界面数值通量。您必须构建半离散系统，选择一个稳定的显式时间积分器，并计算一个用于量化激波附近振荡的稳定性度量。\n\n您的程序必须使用以下基本框架：\n- 标量守恒律的定义 $u_t + f(u)_x = 0$，其中 $f(u) = \\tfrac{1}{2}u^2$。\n- 在每个单元上使用测试函数、分部积分和界面数值通量的间断伽辽金方法。\n- 在 $[0,1]$ 上的周期性边界条件。\n- 界面数值通量的定义，特别是中心通量和 Lax–Friedrichs 通量，两者都与 $f(u)$ 及其导数相容。\n\n您必须研究以下通量配置：\n- 中心通量，定义为物理通量的平均值，不使用任何限制器。\n- Lax–Friedrichs 通量，通过一个与局部波速成正比的耗散修正项来定义。\n- 一种基于传感器的切换策略，在光滑区域使用中心通量，在检测到的间断附近使用 Lax–Friedrichs 通量。\n\n激波传感器必须是一个局部可计算的量，仅依赖于每个单元内的多项式表示，并能检测陡峭梯度或跳跃。界面处的切换决策必须取决于两个相邻单元的最大传感器值。\n\n您的稳定性度量必须通过将最终数值解与初始范围进行比较来量化振荡的幅度。对于初始条件 $u(x,0) = A \\sin(2\\pi x)$，将初始范围定义为 $[-A, A]$。在最终时刻，评估每个单元内部代表点上的 DG 解，并将过冲幅度计算为超过 $A$ 或低于 $-A$ 的最大超量。此过冲幅度既要用作浮点数（用于报告），也要用于与阈值进行布尔判断。\n\n您的 DG 离散化要求：\n- 在 $[0,1]$ 上使用一个包含 $N$ 个单元的均匀网格，多项式阶数为 $1$，并在参考单元上使用类勒让德模态基进行半离散化。\n- 从弱形式和分部积分推导出半离散单元方程，包括质量矩阵和表面项。使用一个稳定的显式时间积分器，例如强稳定性保持三阶龙格-库塔格式。\n- 使用满足 Courant–Friedrichs–Lewy 条件的自适应时间步长，该条件基于最大局部特征速度 $|u|$ 和网格尺寸。\n\n需要实现的通量选项：\n- 中心通量：在界面处使用相容的中心通量。\n- Lax–Friedrichs 通量：使用相容的中心部分减去一个耗散修正项 $-\\tfrac{1}{2}\\alpha(u_R - u_L)$，其中 $\\alpha$ 是一个合适的局部特征速度。\n- 基于传感器的切换：在每个单元中定义一个局部激波传感器（仅基于局部多项式表示），在每个界面处，如果两个相邻的传感器值都低于一个阈值，则选择中心通量，否则选择 Lax–Friedrichs 通量。\n\n时间积分和参数：\n- 积分至指定的最终时间 $T$。\n- 使用满足多项式阶数为 $1$ 的 Courant–Friedrichs–Lewy 条件的自适应时间步长。\n- 使用周期性边界条件。\n\n稳定性度量和输出规范：\n- 对每个测试用例，计算过冲幅度，定义为一个非负浮点数，即最终解对范围 $[-A, A]$ 的最大违背量。\n- 对于布尔判断，将过冲幅度与指定的阈值进行比较，如果超过阈值则返回 $True$，否则返回 $False$。\n\n测试套件：\n- 用例 $1$：$A = 1.0$, $N = 64$, $T = 0.3$，中心通量。返回一个布尔值，指示过冲幅度是否超过 $0.15 A$。\n- 用例 $2$：$A = 1.0$, $N = 64$, $T = 0.3$，Lax–Friedrichs 通量。以浮点数形式返回过冲幅度。\n- 用例 $3$：$A = 1.0$, $N = 64$, $T = 0.3$，基于传感器的切换策略，阈值参数 $\\tau = 0.5$，即如果任一相邻单元的传感器值超过 $\\tau A$，则界面使用 Lax–Friedrichs 通量；否则使用中心通量。以浮点数形式返回过冲幅度。\n- 用例 $4$：$A = 0.1$, $N = 64$, $T = 0.3$，中心通量。返回一个布尔值，指示过冲幅度是否超过 $0.15 A$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3,result4]$）。\n- 结果必须按照上述测试套件的顺序排列，类型必须与指定完全一致：用例 $1$ 为布尔值，用例 $2$ 为浮点数，用例 $3$ 为浮点数，用例 $4$ 为布尔值。",
            "solution": "该问题是有效的。它提出了一个在偏微分方程数值解领域定义明确的任务，具体是使用间断伽辽金 (DG) 方法求解伯格斯方程。所有参数、方程和条件在科学上都是合理的、一致的，并且足以构建一个唯一的数值解。我将进行详细的推导和求解。\n\n### 1. 控制方程与弱形式\n\n该问题考虑的是被称为无粘性伯格斯方程的标量非线性守恒律：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0, \\quad \\text{with } f(u) = \\frac{1}{2}u^2\n$$\n空间域为 $x \\in [0, 1]$，采用周期性边界条件。该域被离散为 $N$ 个均匀单元 $I_j = [x_{j-1/2}, x_{j+1/2}]$，其中 $j=1, \\dots, N$。每个单元的宽度为 $h = 1/N$。\n\n间断伽辽金方法首先将偏微分方程乘以一个测试函数 $v(x)$，并在单个单元 $I_j$ 上进行积分：\n$$\n\\int_{I_j} \\frac{\\partial u}{\\partial t} v \\,dx + \\int_{I_j} \\frac{\\partial f(u)}{\\partial x} v \\,dx = 0\n$$\n对第二项应用分部积分得到：\n$$\n\\int_{I_j} \\frac{\\partial u}{\\partial t} v \\,dx - \\int_{I_j} f(u) \\frac{\\partial v}{\\partial x} \\,dx + \\left[ f(u)v(x) \\right]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\n解 $u$ 在单元界面处是间断的。这种不确定性通过将边界处的物理通量 $f(u)$ 替换为一个单值数值通量 $\\hat{f}(u_L, u_R)$ 来解决，该数值通量取决于界面左侧 ($u_L$) 和右侧 ($u_R$) 的解值。弱形式变为：\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} f(u_h) \\frac{\\partial v_h}{\\partial x} \\,dx + \\hat{f}_{j+1/2}v_h(x_{j+1/2}^-) - \\hat{f}_{j-1/2}v_h(x_{j-1/2}^+) = 0\n$$\n此处，$u_h$ 和 $v_h$ 是来自有限维多项式空间的近似解和测试函数，$\\hat{f}_{j \\pm 1/2}$ 是界面 $x_{j \\pm 1/2}$ 处的数值通量。\n\n### 2. 使用 $p=1$ 基函数的离散化\n\n对于多项式阶数 $p=1$，每个单元中的解 $u_h$ 和测试函数 $v_h$ 都是线性多项式。我们通过映射 $x(\\xi) = x_j + \\frac{h}{2}\\xi$ 将每个物理单元 $I_j$ 映射到一个参考单元 $\\hat{I}=[-1, 1]$，其中 $x_j$ 是 $I_j$ 的中心。在这个参考单元上，我们使用模态基 $\\{\\phi_0(\\xi), \\phi_1(\\xi)\\} = \\{1, \\xi\\}$。解表示为：\n$$\nu_h(x, t) = u_h(\\xi(x), t) = u_0^{(j)}(t)\\phi_0(\\xi) + u_1^{(j)}(t)\\phi_1(\\xi) = u_0^{(j)}(t) + u_1^{(j)}(t)\\xi\n$$\n将此代入弱形式，并选择测试函数 $v_h$ 为基函数 $\\phi_k$，我们得到一个关于系数 $\\vec{u}^{(j)} = [u_0^{(j)}, u_1^{(j)}]^T$ 的常微分方程组 (ODEs)。经过变量替换 $dx = \\frac{h}{2}d\\xi$ 后，对于每个基函数 $\\phi_k$ 的方程为：\n$$\n\\frac{h}{2}\\frac{d}{dt}\\int_{-1}^{1} \\sum_{l=0}^{1} u_l^{(j)}\\phi_l \\phi_k \\,d\\xi = \\int_{-1}^{1} f(u_h) \\frac{d\\phi_k}{d\\xi} \\,d\\xi - \\left[ \\hat{f}\\phi_k \\right]_{x_{j-1/2}}^{x_{j+1/2}}\n$$\n这可以写成每个单元 $j$ 的矩阵形式：\n$$\nM \\frac{d\\vec{u}^{(j)}}{dt} = \\frac{2}{h}S(\\vec{u}^{(j)}) - \\frac{2}{h}F(\\vec{u}^{(j)})\n$$\n各个分量为：\n- **质量矩阵 $M$**: $M_{kl} = \\int_{-1}^1 \\phi_l(\\xi)\\phi_k(\\xi)d\\xi$.\n  $M_{00} = \\int_{-1}^1 1 \\cdot 1 \\,d\\xi = 2$, $M_{01} = M_{10} = \\int_{-1}^1 \\xi \\cdot 1 \\,d\\xi = 0$, $M_{11} = \\int_{-1}^1 \\xi \\cdot \\xi \\,d\\xi = 2/3$.\n  $M = \\begin{pmatrix} 2  0 \\\\ 0  2/3 \\end{pmatrix}$。其逆矩阵为 $M^{-1} = \\begin{pmatrix} 1/2  0 \\\\ 0  3/2 \\end{pmatrix}$。\n- **刚度项 $S$**: $S_k = \\int_{-1}^1 f(u_h(\\xi))\\frac{d\\phi_k}{d\\xi}d\\xi$.\n  由于 $\\frac{d\\phi_0}{d\\xi}=0$ 和 $\\frac{d\\phi_1}{d\\xi}=1$，我们有 $S_0 = 0$。\n  $S_1 = \\int_{-1}^1 \\frac{1}{2}(u_0^{(j)} + u_1^{(j)}\\xi)^2 \\,d\\xi = (u_0^{(j)})^2 + \\frac{1}{3}(u_1^{(j)})^2$。\n- **通量项 $F$**: $F_k = \\hat{f}_{j+1/2}\\phi_k(1) - \\hat{f}_{j-1/2}\\phi_k(-1)$。\n  $F_0 = \\hat{f}_{j+1/2} - \\hat{f}_{j-1/2}$。\n  $F_1 = \\hat{f}_{j+1/2}(1) - \\hat{f}_{j-1/2}(-1) = \\hat{f}_{j+1/2} + \\hat{f}_{j-1/2}$。\n\n综合这些，单元 $j$ 的系数的半离散系统为：\n$$\n\\frac{d u_0^{(j)}}{dt} = -\\frac{1}{h} \\left( \\hat{f}_{j+1/2} - \\hat{f}_{j-1/2} \\right)\n$$\n$$\n\\frac{d u_1^{(j)}}{dt} = \\frac{3}{h} \\left( (u_0^{(j)})^2 + \\frac{1}{3}(u_1^{(j)})^2 \\right) - \\frac{3}{h} \\left( \\hat{f}_{j+1/2} + \\hat{f}_{j-1/2} \\right)\n$$\n界面 $x_{j+1/2}$ 处的值为来自单元 $j$ 的 $u_L = u_h(x_{j+1/2}^-)$ 和来自单元 $j+1$ 的 $u_R = u_h(x_{j+1/2}^+)$。在参考坐标系中，这些对应于单元 $j$ 的 $\\xi=1$ 和单元 $j+1$ 的 $\\xi=-1$：\n$u_L = u_0^{(j)} + u_1^{(j)}$\n$u_R = u_0^{(j+1)} - u_1^{(j+1)}$\n\n### 3. 数值通量与激波传感器\n\n- **中心通量：** 该通量是物理通量的平均值。它是非耗散的，并且已知对于非线性问题是不稳定的，会在激波附近导致振荡。\n$$\n\\hat{f}_{\\text{cen}}(u_L, u_R) = \\frac{f(u_L) + f(u_R)}{2} = \\frac{1}{4}(u_L^2 + u_R^2)\n$$\n- **Lax-Friedrichs (LF) 通量：** 该通量引入了与局部波速成正比的数值耗散，以稳定格式。\n$$\n\\hat{f}_{\\text{LF}}(u_L, u_R) = \\frac{f(u_L) + f(u_R)}{2} - \\frac{\\alpha}{2}(u_R - u_L)\n$$\n对于伯格斯方程，特征速度为 $f'(u) = u$。耗散系数 $\\alpha$ 的一个合适选择是 $\\alpha = \\max(|u_L|, |u_R|)$。\n- **基于传感器的切换通量：** 为了将在光滑区域的中心通量的准确性与在激波附近的 LF 通量的稳定性相结合，我们使用一个激波传感器。单元 $j$ 的传感器 $s_j$ 应量化解的“粗糙度”。对于 $p=1$ 的方法，一个简单而有效的传感器是线性模态系数的绝对值，即 $s_j = |u_1^{(j)}|$。该系数表示单元内解的斜率。在每个界面 $x_{j+1/2}$ 处，传感器值取为 $s_{\\text{int}} = \\max(s_j, s_{j+1})$。如果 $s_{\\text{int}}$ 超过阈值 $\\tau A$，则使用 LF 通量；否则，使用中心通量。\n\n### 4. 时间积分与初始条件\n\n半离散系统 $\\frac{d\\vec{U}}{dt} = L(\\vec{U})$（其中 $\\vec{U}$ 是所有系数的全局向量）使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 格式进行时间积分：\n$$\n\\vec{U}^{(1)} = \\vec{U}^n + \\Delta t L(\\vec{U}^n)\n$$\n$$\n\\vec{U}^{(2)} = \\frac{3}{4}\\vec{U}^n + \\frac{1}{4}\\vec{U}^{(1)} + \\frac{1}{4}\\Delta t L(\\vec{U}^{(1)})\n$$\n$$\n\\vec{U}^{n+1} = \\frac{1}{3}\\vec{U}^n + \\frac{2}{3}\\vec{U}^{(2)} + \\frac{2}{3}\\Delta t L(\\vec{U}^{(2)})\n$$\n时间步长 $\\Delta t$ 在每个阶段自适应调整以满足 CFL 条件：\n$$\n\\Delta t = C_{\\text{CFL}} \\frac{h}{(2p+1)\\max(|u_h|)}\n$$\n对于 $p=1$，这变为 $\\Delta t = C_{\\text{CFL}} \\frac{h}{3\\max(|u_h|)}$。我们选择一个安全的 CFL 数，$C_{\\text{CFL}}=0.3$。最大速度估计为 $\\max_{j} (|u_0^{(j)}| + |u_1^{(j)}|)$。\n\n初始条件 $u(x,0) = A \\sin(2\\pi x)$ 通过对每个单元进行 $L^2$ 投影，投影到 DG 基空间上。系数 $\\vec{u}^{(j)}(0)$ 通过求解 $M\\vec{u}^{(j)} = \\vec{b}^{(j)}$ 得到，其中右侧项为 $b_k^{(j)} = \\int_{I_j} u(x,0)\\phi_k(x)dx$。这些积分使用高斯求积法进行数值计算。\n\n### 5. 稳定性度量：过冲幅度\n\n在最终时间 $T$，通过计算过冲幅度来量化稳定性。初始条件位于范围 $[-A, A]$ 内。由于数值解在每个单元内是线性的，其极值出现在单元边界上。我们找出所有单元的全局最大值 $\\max(u_h(x, T))$ 和最小值 $\\min(u_h(x, T))$。然后，过冲为：\n$$\n\\text{Overshoot} = \\max\\left(0, \\max(u_h) - A, -(\\min(u_h) + A)\\right)\n$$\n该度量捕捉了任何违反解的初始范围的伪振荡的幅度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef get_gauss_quadrature(order):\n    \"\"\"Returns points and weights for Gauss-Legendre quadrature.\"\"\"\n    if order == 4: # Hardcoded for simplicity as required by the IC projection\n        points = np.array([-0.86113631, -0.33998104, 0.33998104, 0.86113631])\n        weights = np.array([0.34785485, 0.65214515, 0.65214515, 0.34785485])\n        return points, weights\n    raise ValueError(\"Quadrature order not implemented\")\n\nclass DGSolver:\n    \"\"\"\n    A Discontinuous Galerkin solver for Burgers' equation u_t + 0.5*(u^2)_x = 0\n    on a periodic domain [0,1] with p=1 polynomials.\n    \"\"\"\n    def __init__(self, A, N, T, flux_type, tau=None):\n        self.A = float(A)\n        self.N = int(N)\n        self.T = float(T)\n        self.flux_type = flux_type\n        self.tau = tau\n        \n        self.h = 1.0 / self.N\n        self.x = np.linspace(0.5 * self.h, 1.0 - 0.5 * self.h, self.N) # Cell centers\n        \n        # p=1 basis: {1, xi} on [-1,1]\n        # u_coeffs is an (N, 2) array: u_coeffs[:, 0] = u_0, u_coeffs[:, 1] = u_1\n        self.u_coeffs = self._project_initial_condition()\n\n    def _project_initial_condition(self):\n        \"\"\"Projects u(x,0) = A*sin(2*pi*x) onto the DG basis space.\"\"\"\n        u_coeffs = np.zeros((self.N, 2))\n        q_points, q_weights = get_gauss_quadrature(4)\n        \n        # M_inv = diag(1/2, 3/2)\n        M_inv = np.array([0.5, 1.5])\n        \n        for j in range(self.N):\n            b = np.zeros(2)\n            for i in range(len(q_points)):\n                xi = q_points[i]\n                x_val = self.x[j] + 0.5 * self.h * xi\n                u_val = self.A * np.sin(2.0 * np.pi * x_val)\n                \n                phi_0 = 1.0\n                phi_1 = xi\n                \n                b[0] += u_val * phi_0 * q_weights[i]\n                b[1] += u_val * phi_1 * q_weights[i]\n            \n            b *= 0.5 * self.h # from dx = (h/2)d_xi\n            \n            # u = M_inv * b\n            u_coeffs[j, 0] = M_inv[0] * b[0]\n            u_coeffs[j, 1] = M_inv[1] * b[1]\n            \n        return u_coeffs\n\n    def _compute_rhs(self, u_coeffs):\n        \"\"\"Computes the right-hand side of the semi-discrete system.\"\"\"\n        \n        # Get left and right states at interfaces\n        u_left = u_coeffs[:, 0] + u_coeffs[:, 1]\n        \n        # For periodic BC, the right neighbor of cell N-1 is cell 0\n        u_coeffs_right_neighbor = np.roll(u_coeffs, -1, axis=0)\n        u_right = u_coeffs_right_neighbor[:, 0] - u_coeffs_right_neighbor[:, 1]\n\n        # Physical fluxes\n        f_left = 0.5 * u_left**2\n        f_right = 0.5 * u_right**2\n\n        # Central flux\n        f_hat_central = 0.5 * (f_left + f_right)\n\n        # Lax-Friedrichs Dissipation\n        alpha = np.maximum(np.abs(u_left), np.abs(u_right))\n        f_hat_lf = f_hat_central - 0.5 * alpha * (u_right - u_left)\n\n        # Select flux\n        if self.flux_type == 'central':\n            f_hat = f_hat_central\n        elif self.flux_type == 'lax_friedrichs':\n            f_hat = f_hat_lf\n        elif self.flux_type == 'sensor':\n            s_j = np.abs(u_coeffs[:, 1])\n            s_j_plus_1 = np.roll(s_j, -1)\n            s_interface = np.maximum(s_j, s_j_plus_1)\n            threshold = self.tau * self.A\n            use_lf = s_interface  threshold\n            f_hat = np.where(use_lf, f_hat_lf, f_hat_central)\n        else:\n            raise ValueError(f\"Unknown flux type: {self.flux_type}\")\n        \n        # Flux at left interface of cell j is the flux at right interface of cell j-1\n        f_hat_minus = np.roll(f_hat, 1)\n        f_hat_plus = f_hat\n        \n        # Assemble RHS\n        rhs = np.zeros_like(u_coeffs)\n        u0 = u_coeffs[:, 0]\n        u1 = u_coeffs[:, 1]\n        \n        # d(u0)/dt\n        rhs[:, 0] = -1.0 / self.h * (f_hat_plus - f_hat_minus)\n        \n        # d(u1)/dt\n        stiffness_term = u0**2 + (1.0/3.0) * u1**2\n        rhs[:, 1] = 3.0 / self.h * stiffness_term - 3.0 / self.h * (f_hat_plus + f_hat_minus)\n        \n        return rhs\n\n    def run(self):\n        \"\"\"Main time-stepping loop using SSP-RK3.\"\"\"\n        t = 0.0\n        cfl_const = 0.3 # CFL number for the scheme\n        \n        u = self.u_coeffs.copy()\n\n        while t  self.T:\n            max_u = np.max(np.abs(u[:, 0]) + np.abs(u[:, 1]))\n            if max_u  1e-9: max_u = 1e-9 # Avoid division by zero\n            \n            p = 1 # polynomial degree\n            dt = cfl_const * self.h / ((2 * p + 1) * max_u)\n            \n            if t + dt  self.T:\n                dt = self.T - t\n\n            # SSP-RK3\n            u1 = u + dt * self._compute_rhs(u)\n            u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt * self._compute_rhs(u1)\n            u_new = (1.0/3.0) * u + (2.0/3.0) * u2 + (2.0/3.0) * dt * self._compute_rhs(u2)\n            \n            u = u_new\n            t += dt\n\n        self.u_coeffs = u\n        return self\n\n    def compute_overshoot(self):\n        \"\"\"Computes the overshoot magnitude from the final solution.\"\"\"\n        # For p=1, extrema are at cell boundaries\n        vals_at_xi_plus_1 = self.u_coeffs[:, 0] + self.u_coeffs[:, 1]\n        vals_at_xi_minus_1 = self.u_coeffs[:, 0] - self.u_coeffs[:, 1]\n        \n        all_vals = np.concatenate((vals_at_xi_plus_1, vals_at_xi_minus_1))\n        \n        global_max = np.max(all_vals)\n        global_min = np.min(all_vals)\n        \n        overshoot = max(0.0, global_max - self.A, -self.A - global_min)\n        return overshoot\n\ndef solve():\n    test_cases = [\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'central', 'type': 'bool', 'thresh': 0.15},\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'lax_friedrichs', 'type': 'float'},\n        {'A': 1.0, 'N': 64, 'T': 0.3, 'flux': 'sensor', 'type': 'float', 'tau': 0.5},\n        {'A': 0.1, 'N': 64, 'T': 0.3, 'flux': 'central', 'type': 'bool', 'thresh': 0.15}\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = DGSolver(A=case['A'], N=case['N'], T=case['T'], \n                          flux_type=case.get('flux'), tau=case.get('tau'))\n        solver.run()\n        overshoot = solver.compute_overshoot()\n        \n        if case['type'] == 'bool':\n            result = overshoot  (case['thresh'] * case['A'])\n            # Ensure Python bool (True/False) is printed, not numpy.bool_\n            results.append(bool(result))\n        elif case['type'] == 'float':\n            results.append(overshoot)\n\n    # The spec requires a comma-separated list without spaces\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}