{
    "hands_on_practices": [
        {
            "introduction": "Solving linear elliptic partial differential equations is a cornerstone of computational physics and engineering. This practice demonstrates how the Fast Fourier Transform, via the Discrete Sine Transform (DST), can elegantly solve the Poisson equation by diagonalizing the discrete Laplacian operator. By implementing a DST-I solver from scratch, you will gain a deep understanding of how spectral methods turn differential problems into simple algebraic ones in the frequency domain. ",
            "id": "3390805",
            "problem": "Consider the one-dimensional boundary value problem on a finite interval with homogeneous Dirichlet boundary conditions. Let the domain be the closed interval $\\left[0,L\\right]$ with $L > 0$. The continuous problem is to find a sufficiently smooth function $u(x)$ satisfying $-u''(x) = f(x)$ for $x \\in (0,L)$ and $u(0) = u(L) = 0$. You will construct a numerical solver for the discrete analogue of this problem using a spectral diagonalization approach based on the Fast Fourier Transform (FFT), in particular implementing the Discrete Sine Transform Type-I (DST-I) via an FFT of an odd extension.\n\nYou must work on a uniform grid with $n$ interior points. The grid staggering is as follows: introduce a uniform spacing $h = L/(n+1)$, and define interior grid locations $x_j = j h$ for $j=1,2,\\ldots,n$. The unknown vector is $u = \\left(u_1, u_2, \\ldots, u_n\\right)$ with $u_j$ approximating $u(x_j)$. The boundary conditions impose $u_0 = u_{n+1} = 0$. The corresponding second-order centered finite difference discretization of $-u''(x) = f(x)$ on this staggered grid is\n$$\n-\\frac{u_{j-1} - 2 u_j + u_{j+1}}{h^2} = f_j,\n$$\nfor $j=1,2,\\ldots,n$, where $f_j = f(x_j)$ is the sampled right-hand side.\n\nStarting from fundamental definitions of the Discrete Sine Transform Type-I, the properties of the discrete Laplacian with homogeneous Dirichlet boundary conditions on a uniform grid, and the Fast Fourier Transform of an odd extension, derive and implement an algorithm that:\n- Constructs a forward DST-I using an FFT of an odd extension (no call to a built-in sine transform routine is permitted; the DST-I must be computed via FFT).\n- Uses the DST-I to diagonalize the discrete Dirichlet Laplacian and solve for $u$ in sine space by dividing by the appropriate eigenvalues.\n- Applies the inverse DST-I (based on the same transform and the orthogonality of the sine basis) to recover $u_j$ on the grid.\n\nAll angles are to be treated in radians.\n\nYour program must implement this solver and evaluate its accuracy on the following test suite. For each case, compute the maximum absolute error $\\max_{1\\le j\\le n} \\left|u_j - u_{\\mathrm{exact}}(x_j)\\right|$ as a floating-point number.\n\nTest suite:\n- Case 1 (general sine mode): $L = 1$, $n = 63$, $u_{\\mathrm{exact}}(x) = \\sin(\\pi x)$, $f(x) = \\pi^2 \\sin(\\pi x)$.\n- Case 2 (different domain and mode): $L = 2$, $n = 31$, $u_{\\mathrm{exact}}(x) = \\sin\\!\\left( \\frac{3\\pi x}{L} \\right)$, $f(x) = \\left(\\frac{3\\pi}{L}\\right)^2 \\sin\\!\\left( \\frac{3\\pi x}{L} \\right)$.\n- Case 3 (constant forcing, minimal interior grid): $L = 1$, $n = 1$, $u_{\\mathrm{exact}}(x) = \\frac{x(L-x)}{2}$, $f(x) = 1$.\n- Case 4 (higher sine mode, finer grid): $L = 1$, $n = 127$, $u_{\\mathrm{exact}}(x) = \\sin(5\\pi x)$, $f(x) = 25\\pi^2 \\sin(5\\pi x)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$, where each $\\text{result}_k$ is the maximum absolute error for the corresponding case represented as a floating-point number. The output must follow exactly the specified format in a single line.",
            "solution": "The problem presented is a valid and well-posed boundary value problem from the field of numerical analysis. It requires the solution of the one-dimensional Poisson equation, $-u''(x) = f(x)$ on a domain $x \\in [0, L]$, with homogeneous Dirichlet boundary conditions $u(0)=u(L)=0$. The specified solution method involves a spectral diagonalization of the discretized operator using a Fast Fourier Transform (FFT)-based implementation of the Discrete Sine Transform Type-I (DST-I). All components of the problem are scientifically and mathematically sound.\n\nWe begin by formalizing the discrete problem. The domain $[0,L]$ is discretized with $n$ interior points $x_j = j h$ for $j=1, 2, \\ldots, n$, where the grid spacing is $h = L/(n+1)$. The boundary conditions imply $u_0 = u_{n+1} = 0$. The second-order centered finite difference approximation for the negative second derivative is given as:\n$$\n-u''(x_j) \\approx -\\frac{u(x_{j-1}) - 2u(x_j) + u(x_{j+1})}{h^2}\n$$\nApplying this to the differential equation at each interior grid point $x_j$ yields the system of linear equations:\n$$\n-\\frac{u_{j-1} - 2u_j + u_{j+1}}{h^2} = f_j, \\quad \\text{for } j=1, 2, \\ldots, n\n$$\nwhere $u_j$ is the numerical approximation to $u(x_j)$ and $f_j = f(x_j)$. This system can be written in matrix form as $A\\mathbf{u} = \\mathbf{f}$, where $\\mathbf{u} = [u_1, u_2, \\ldots, u_n]^T$, $\\mathbf{f} = [f_1, f_2, \\ldots, f_n]^T$, and $A$ is the $n \\times n$ matrix representing the discrete negative Laplacian:\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n 2 & -1 & 0 & \\cdots & 0 \\\\\n-1 &  2 & -1 & \\cdots & 0 \\\\\n 0 & -1 &  2 & \\ddots & \\vdots \\\\\n \\vdots & \\vdots & \\ddots & \\ddots & -1 \\\\\n 0 & 0 & \\cdots & -1 & 2\n\\end{pmatrix}\n$$\nThe core of the spectral method is to diagonalize the matrix $A$. The eigenvectors and eigenvalues of this specific tridiagonal Toeplitz matrix are well-known. The $k$-th eigenvector, for $k=1, 2, \\ldots, n$, has components:\n$$\nv_j^{(k)} = \\sin\\left(\\frac{jk\\pi}{n+1}\\right), \\quad \\text{for } j=1, 2, \\ldots, n\n$$\nThe corresponding eigenvalue $\\lambda_k$ of the matrix $A$ is found by applying $A$ to $\\mathbf{v}^{(k)}$. The action of the unscaled tridiagonal matrix on the $j$-th component yields $2 v_j^{(k)} - v_{j-1}^{(k)} - v_{j+1}^{(k)}$. Using the trigonometric identity $\\sin(a-b) + \\sin(a+b) = 2\\sin(a)\\cos(b)$, we find:\n$$\n- (v_{j-1}^{(k)} - 2v_j^{(k)} + v_{j+1}^{(k)}) = 2\\left(1 - \\cos\\left(\\frac{k\\pi}{n+1}\\right)\\right)v_j^{(k)} = 4\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)v_j^{(k)}\n$$\nThus, the eigenvalues of the full matrix $A$ are:\n$$\n\\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right), \\quad \\text{for } k=1, 2, \\ldots, n\n$$\nSince the eigenvectors $\\{\\mathbf{v}^{(k)}\\}_{k=1}^n$ form a complete orthogonal basis for $\\mathbb{R}^n$, we can expand the solution vector $\\mathbf{u}$ and the forcing vector $\\mathbf{f}$ in this basis:\n$$\n\\mathbf{u} = \\sum_{k=1}^n \\hat{u}_k \\mathbf{v}^{(k)}, \\quad \\mathbf{f} = \\sum_{k=1}^n \\hat{f}_k \\mathbf{v}^{(k)}\n$$\nSubstituting these expansions into the system $A\\mathbf{u} = \\mathbf{f}$ gives:\n$$\nA \\left(\\sum_{k=1}^n \\hat{u}_k \\mathbf{v}^{(k)}\\right) = \\sum_{k=1}^n \\hat{f}_k \\mathbf{v}^{(k)} \\implies \\sum_{k=1}^n \\hat{u}_k (A\\mathbf{v}^{(k)}) = \\sum_{k=1}^n \\hat{f}_k \\mathbf{v}^{(k)} \\implies \\sum_{k=1}^n \\hat{u}_k \\lambda_k \\mathbf{v}^{(k)} = \\sum_{k=1}^n \\hat{f}_k \\mathbf{v}^{(k)}\n$$\nBy the linear independence of the eigenvectors, we can equate the coefficients for each mode $k$:\n$$\n\\lambda_k \\hat{u}_k = \\hat{f}_k \\implies \\hat{u}_k = \\frac{\\hat{f}_k}{\\lambda_k}\n$$\nThis constitutes the solution in the spectral (sine) domain. The coefficients $\\hat{f}_k$ are determined by the Discrete Sine Transform Type-I (DST-I). We define a consistent transform pair. The forward DST-I (analysis) is:\n$$\n\\hat{y}_k = \\sum_{j=1}^n y_j \\sin\\left(\\frac{jk\\pi}{n+1}\\right)\n$$\nThe inverse DST-I (synthesis) is, due to the orthogonality property $\\sum_{j=1}^n \\sin\\left(\\frac{jk\\pi}{n+1}\\right)\\sin\\left(\\frac{jm\\pi}{n+1}\\right) = \\frac{n+1}{2}\\delta_{km}$:\n$$\ny_j = \\frac{2}{n+1} \\sum_{k=1}^n \\hat{y}_k \\sin\\left(\\frac{jk\\pi}{n+1}\\right)\n$$\nThe problem requires computing the DST-I via an FFT. This is achieved by constructing an odd-extended sequence. Given a vector $\\mathbf{y} = (y_1, \\ldots, y_n)$, we form a new vector $\\mathbf{Y}$ of length $M = 2(n+1)$ with odd symmetry:\n$$\nY_j = \\begin{cases} 0 & \\text{if } j=0 \\text{ or } j=n+1 \\\\ y_j & \\text{if } 1 \\le j \\le n \\\\ -y_{2(n+1)-j} & \\text{if } n+2 \\le j \\le 2(n+1)-1 \\end{cases}\n$$\nThis construction is equivalent to creating the sequence $[0, y_1, \\ldots, y_n, 0, -y_n, \\ldots, -y_1]$. The Discrete Fourier Transform (DFT) of this real and odd sequence $\\mathbf{Y}$ is purely imaginary. The DFT is $\\hat{Y}_k = \\sum_{j=0}^{M-1} Y_j e^{-i 2\\pi jk/M}$. Evaluating this sum shows its relation to the DST-I:\n$$\n\\hat{Y}_k = \\sum_{j=1}^n y_j \\left(e^{-i\\frac{2\\pi jk}{2(n+1)}} - e^{i\\frac{2\\pi jk}{2(n+1)}}\\right) = -2i \\sum_{j=1}^n y_j \\sin\\left(\\frac{jk\\pi}{n+1}\\right)\n$$\nTherefore, the DST-I of $\\mathbf{y}$ can be computed from the imaginary part of the FFT of $\\mathbf{Y}$:\n$$\n\\text{DST-I}(\\mathbf{y})_k = -\\frac{1}{2} \\text{Im}(\\text{FFT}(\\mathbf{Y})_k)\n$$\nThe algorithm for solving the boundary value problem is as follows:\n1. Given $L$, $n$, and $f(x)$, construct the grid $x_j=jh$ with $h=L/(n+1)$ and the forcing vector $\\mathbf{f}$ with components $f_j=f(x_j)$.\n2. Compute the spectral coefficients of the forcing vector, $\\hat{\\mathbf{f}} = \\text{DST-I}(\\mathbf{f})$, using the FFT-based method described above.\n3. Compute the eigenvalues $\\lambda_k$ of the discrete Laplacian for $k=1, \\ldots, n$.\n4. Solve for the spectral coefficients of the solution: $\\hat{u}_k = \\hat{f}_k / \\lambda_k$. For numerical stability, if any $\\hat{f}_k=0$, we set $\\hat{u}_k=0$ to avoid division by a potentially zero $\\lambda_k$.\n5. Compute the solution vector $\\mathbf{u}$ by applying the inverse DST-I to $\\hat{\\mathbf{u}}$. This is performed by first computing $\\text{DST-I}(\\hat{\\mathbf{u}})$ and then scaling the result by $2/(n+1)$.\n6. Calculate the maximum absolute error between the numerical solution $u_j$ and the exact solution $u_{\\mathrm{exact}}(x_j)$ over all interior grid points.\nThis procedure will be implemented and applied to the provided test suite.",
            "answer": "```python\nimport numpy as np\n\ndef dst1(v, n):\n    \"\"\"\n    Computes the Discrete Sine Transform Type-I (DST-I) of a vector v\n    of length n using a Fast Fourier Transform (FFT) of an odd extension.\n    This implementation is based on the relationship:\n    DST-I(y)_k = -0.5 * imag(FFT(Y)_k)\n    where Y is an oddly extended version of y.\n    \"\"\"\n    M = 2 * (n + 1)\n    y_ext = np.zeros(M)\n    \n    # Construct the odd extension: [0, v_1, ..., v_n, 0, -v_n, ..., -v_1]\n    y_ext[1:n+1] = v\n    y_ext[n+2:] = -v[::-1]\n    \n    # Compute the FFT of the extended vector\n    y_fft = np.fft.fft(y_ext)\n    \n    # The DST-I coefficients are derived from the imaginary part of the FFT result\n    return -0.5 * np.imag(y_fft[1:n+1])\n\ndef solve_poisson_1d(L, n, f_func, u_exact_func):\n    \"\"\"\n    Solves the 1D Poisson equation -u''=f on [0, L] with u(0)=u(L)=0\n    using a spectral method based on the Discrete Sine Transform (DST-I).\n\n    Args:\n        L (float): The length of the domain.\n        n (int): The number of interior grid points.\n        f_func (callable): A function f(x, L) for the forcing term.\n        u_exact_func (callable): A function u_exact(x, L) for the exact solution.\n\n    Returns:\n        float: The maximum absolute error between the numerical and exact solutions.\n    \"\"\"\n    # 1. Setup grid and forcing vector\n    h = L / (n + 1)\n    x_grid = np.arange(1, n + 1) * h\n    f_vec = f_func(x_grid, L)\n    \n    # 2. Forward DST-I of the forcing vector\n    f_hat = dst1(f_vec, n)\n    \n    # 3. Compute eigenvalues of the discrete Laplacian\n    k_modes = np.arange(1, n + 1)\n    lambda_k = (4 / h**2) * np.sin(k_modes * np.pi / (2 * (n + 1)))**2\n    \n    # 4. Solve for spectral coefficients of the solution\n    u_hat = np.zeros_like(f_hat)\n    # Avoid division by zero if an eigenvalue is zero, although for this problem\n    # lambda_k is always positive for k in [1, n].\n    # Also handle the case where f_hat is zero to prevent 0/lambda resulting in -0.0\n    # which is harmless but less clean.\n    nonzero_f_hat_indices = np.where(f_hat != 0)\n    u_hat[nonzero_f_hat_indices] = f_hat[nonzero_f_hat_indices] / lambda_k[nonzero_f_hat_indices]\n\n    # 5. Inverse DST-I to get the solution vector\n    # The IDST-I is a scaled DST-I.\n    # u_j = (2/(n+1)) * sum(u_hat_k * sin(j*k*pi/(n+1)))\n    # First, compute the sum part, which is a DST-I of u_hat\n    u_vec_intermediate = dst1(u_hat, n)\n    u_vec = (2 / (n + 1)) * u_vec_intermediate\n    \n    # 6. Calculate error\n    u_exact_vec = u_exact_func(x_grid, L)\n    max_error = np.max(np.abs(u_vec - u_exact_vec))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the 1D Poisson solver.\n    \"\"\"\n    test_cases = [\n        {\n            'L': 1.0, \n            'n': 63,\n            'u_exact': lambda x, L_p: np.sin(np.pi * x),\n            'f': lambda x, L_p: np.pi**2 * np.sin(np.pi * x)\n        },\n        {\n            'L': 2.0, \n            'n': 31,\n            'u_exact': lambda x, L_p: np.sin(3 * np.pi * x / L_p),\n            'f': lambda x, L_p: (3 * np.pi / L_p)**2 * np.sin(3 * np.pi * x / L_p)\n        },\n        {\n            'L': 1.0, \n            'n': 1,\n            'u_exact': lambda x, L_p: x * (L_p - x) / 2.0,\n            'f': lambda x, L_p: np.ones_like(x)\n        },\n        {\n            'L': 1.0, \n            'n': 127,\n            'u_exact': lambda x, L_p: np.sin(5 * np.pi * x),\n            'f': lambda x, L_p: 25 * np.pi**2 * np.sin(5 * np.pi * x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_1d(case['L'], case['n'], case['f'], case['u_exact'])\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While linear problems are foundational, most real-world phenomena are nonlinear, introducing unique numerical challenges. This exercise tackles the problem of aliasing, a spurious effect that arises when computing nonlinear terms with FFT-based pseudo-spectral methods. You will derive and implement the famous de-aliasing rule for quadratic nonlinearities and its extension to cubic terms, a critical technique for ensuring the accuracy of your simulations. ",
            "id": "3390818",
            "problem": "Consider the one-dimensional periodic viscous Burgers equation on the interval of length $2\\pi$,\n$$\nu_t + \\tfrac{1}{2}(u^2)_x = \\nu u_{xx},\n$$\nto be discretized by a pseudo-spectral algorithm that uses the Fast Fourier Transform (FFT) to evaluate nonlinear terms in physical space and linear terms in spectral space. Let the base spatial grid have $N$ equispaced collocation points with even $N$, and denote by $\\widehat{u}_k$ the Discrete Fourier Transform (DFT) coefficients at wavenumbers $k \\in \\{-\\tfrac{N}{2},\\ldots,\\tfrac{N}{2}-1\\}$ in the usual FFT ordering.\n\nThe following foundational facts are assumed:\n\n- The convolution theorem: the DFT of a pointwise product in physical space equals a circular convolution of the corresponding DFTs in spectral space.\n- The circular convolution property of the DFT: for a grid of length $M$, spectral interactions are folded modulo $M$, so that a quadratic interaction at modes $k_1$ and $k_2$ contributes at $k \\equiv k_1 + k_2 \\pmod{M}$; more generally, a polynomial nonlinearity of degree $P$ produces sums $k \\equiv k_1 + \\cdots + k_P \\pmod{M}$.\n- Aliasing arises when a sum $k_1 + \\cdots + k_P$ that lies outside the principal wavenumber band $\\{-\\tfrac{M}{2},\\ldots,\\tfrac{M}{2}-1\\}$ is folded back into that band by modulo-$M$ wrapping, thereby adding spurious contributions within the retained band of the base grid, $\\{-\\tfrac{N}{2},\\ldots,\\tfrac{N}{2}-1\\}$, after truncation.\n\nTask A. Starting strictly from the above definitions and facts, analyze the discrete triad interactions that arise in the pseudo-spectral evaluation of the quadratic nonlinearity $(u^2)_x$ for the case $P=2$ and the cubic pointwise product $u^3$ for the case $P=3$. Derive a necessary and sufficient inequality on a zero-padding grid length $M$ (with $M$ even and $M \\ge N$) that guarantees that, after computing the product on the grid of length $M$ and truncating back to the base band of length $N$, there is no aliasing into the retained modes for degree $P \\in \\{2,3\\}$. Show that this inequality leads to a minimal padding factor $p_P \\equiv M/N$ for each degree $P$, and determine the exact minimal values $p_2$ and $p_3$.\n\nTask B. Using the derived padding factors, design a minimal zero-padding pseudo-spectral scheme that exactly eliminates spurious energy transfer for both quadratic and cubic nonlinearities. The scheme must:\n- Zero-pad the base spectrum of length $N$ to a padded spectrum of length $M = p_P N$, with $p_2$ and $p_3$ as in Task A.\n- Transform to physical space on the padded grid, perform the pointwise multiplication for the nonlinearity of degree $P$, transform back to spectral space on length $M$, and then truncate exactly back to the base band of length $N$.\n\nTask C. Implement a complete, runnable program that:\n- Computes the minimal padding factors $p_2$ and $p_3$ you derived in Task A.\n- Verifies the correctness of the minimal zero-padding scheme from Task B by comparing, for each test case below, the truncated padded pseudo-spectral product against an alias-free reference computed on a sufficiently large grid of length $M_{\\mathrm{ref}}$ that provably suppresses aliasing for degree $P \\le 3$. Use $M_{\\mathrm{ref}} = 4N$ for all tests.\n- Uses reproducible random real fields $u(x)$ generated on the base grid (set a fixed random seed), embeds their spectra by zero-padding for the padded and reference grids, and performs the comparisons in spectral space after truncation back to length $N$.\n- Declares a test case as passed (boolean $\\mathrm{True}$) if the truncated padded spectrum and the truncated reference spectrum are numerically equal within a tight tolerance, and failed (boolean $\\mathrm{False}$) otherwise. Use absolute tolerance $\\varepsilon_{\\mathrm{abs}} = 10^{-12}$ and relative tolerance $\\varepsilon_{\\mathrm{rel}} = 10^{-10}$ in a standard elementwise comparison of complex arrays.\n\nTest suite. Your program must evaluate the following test cases, each represented by $(N, P, p)$, where $N$ is the base grid length, $P$ is the polynomial degree, and $p$ is the padding factor used in the padded product (note that for verification we always use $M_{\\mathrm{ref}} = 4N$ for the reference, independent of $p$):\n- Case $1$: $(N,P,p) = (16,2, \\tfrac{3}{2})$.\n- Case $2$: $(N,P,p) = (16,2, 1)$.\n- Case $3$: $(N,P,p) = (16,3, 2)$.\n- Case $4$: $(N,P,p) = (16,3, \\tfrac{3}{2})$.\n- Case $5$: $(N,P,p) = (8,2, \\tfrac{3}{2})$.\n- Case $6$: $(N,P,p) = (32,3, 2)$.\n\nFinal output format. Your program should produce a single line of output containing a comma-separated Python-style list:\n- The first two entries must be the minimal padding factors $p_2$ and $p_3$ as floating-point numbers.\n- The next entries must be the boolean pass or fail results for Cases $1$ through $6$, in that order.\nFor example, the output format must be exactly\n$[p_2,p_3,b_1,b_2,b_3,b_4,b_5,b_6]$,\nwith no extra spaces or text. There are no physical units required in this problem, and all angles, where implicitly involved by complex exponentials, are in radians by definition of the DFT.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard, albeit fundamental, problem in the theory and practice of spectral methods for nonlinear partial differential equations. The parameters and test cases are clearly specified, allowing for a unique and verifiable solution. Therefore, the problem is deemed valid.\n\n### Task A: Derivation of Minimal Padding Factors\n\nThe core of the pseudo-spectral method for a nonlinear term is to perform a pointwise product in physical space. For a periodic function $u(x)$ discretized on a grid of $N$ points, its Discrete Fourier Transform (DFT) coefficients, denoted $\\widehat{u}_k$, exist for wavenumbers in the set $K_N = \\{-\\frac{N}{2}, \\ldots, \\frac{N}{2}-1\\}$. The problem specifies that the initial field $u(x)$ is represented by these modes.\n\nTo compute the pointwise product $v(x) = [u(x)]^P$ without aliasing error, we employ zero-padding. The discrete spectrum $\\widehat{u}$ is embedded into a larger array of size $M \\ge N$ by adding $M-N$ zeros for the higher wavenumbers. Let this padded spectrum be $\\widehat{u}^{\\text{pad}}$. The corresponding physical-space function on the padded $M$-point grid is $u^{\\text{pad}}(x) = \\text{IDFT}(\\widehat{u}^{\\text{pad}})$.\n\nAccording to the convolution theorem, the exact spectrum of the product $v=u^P$ is the $P$-fold convolution of $\\widehat{u}$ with itself. Since $\\widehat{u}_k$ is non-zero only for $k \\in K_N$, the resulting wavenumbers $k' = k_1 + \\dots + k_P$ (with each $k_j \\in K_N$) will lie in a specific range. The maximum possible value of $k'$ is $P(\\frac{N}{2}-1)$, and the minimum is $P(-\\frac{N}{2}) = -\\frac{PN}{2}$. Thus, the exact spectrum of the product, $\\widehat{v}$, has support on the wavenumber interval $K_{prod} = [-\\frac{PN}{2}, P(\\frac{N}{2}-1)]$.\n\nWhen the product is computed via DFT on a grid of size $M$, what is actually calculated is a circular convolution. The resulting spectral coefficient at wavenumber $k \\in K_M = \\{-\\frac{M}{2}, \\ldots, \\frac{M}{2}-1\\}$ is given by:\n$$\n\\widehat{v}^{\\text{pseudo}}_k = \\sum_{q=-\\infty}^{\\infty} \\widehat{v}_{k+qM}\n$$\nwhere $\\widehat{v}$ is the spectrum of the exact, unaliased product. Aliasing error corrupts the coefficient $\\widehat{v}^{\\text{pseudo}}_k$ if any term with $q \\ne 0$ is non-zero.\n\nOur goal is to ensure that the computed coefficients are exact for the retained modes, i.e., $\\widehat{v}^{\\text{pseudo}}_k = \\widehat{v}_k$ for all $k \\in K_N$. This requires that for all $k \\in K_N$ and all integers $q \\ne 0$, the aliasing term $\\widehat{v}_{k+qM}$ is zero. This means the aliased wavenumber $k+qM$ must lie outside the support of $\\widehat{v}$, which is the interval $K_{prod} = [-\\frac{PN}{2}, P(\\frac{N}{2}-1)]$.\n\nWe analyze the constraints imposed by $q=1$ and $q=-1$, as these are the most restrictive for $M \\approx N$.\n\n1.  For $q=1$, we require $k+M$ to be outside $K_{prod}$ for all $k \\in K_N$. This implies either $k+M > \\max(K_{prod})$ or $k+M < \\min(K_{prod})$. As $M>0$, the second case is impossible. So we must satisfy $k+M > P(\\frac{N}{2}-1)$ for all $k \\in K_N$. To ensure this, we test the minimum possible value of the left-hand side, which occurs at $k_{\\min} = -\\frac{N}{2}$.\n    $$\n    -\\frac{N}{2} + M > P\\left(\\frac{N}{2}-1\\right) \\implies M > \\frac{PN}{2} - P + \\frac{N}{2} = \\frac{(P+1)N}{2} - P\n    $$\n\n2.  For $q=-1$, we require $k-M$ to be outside $K_{prod}$ for all $k \\in K_N$. This implies either $k-M > \\max(K_{prod})$ or $k-M < \\min(K_{prod})$. The first case is impossible for reasonable $M$. So we must satisfy $k-M < -\\frac{PN}{2}$ for all $k \\in K_N$. To ensure this, we test the maximum possible value of the left-hand side, which occurs at $k_{\\max} = \\frac{N}{2}-1$.\n    $$\n    \\frac{N}{2}-1 - M < -\\frac{PN}{2} \\implies M > \\frac{N}{2}-1 + \\frac{PN}{2} = \\frac{(P+1)N}{2} - 1\n    $$\n\nSince $P \\ge 2$, the second inequality, $M > \\frac{(P+1)N}{2} - 1$, is stricter and thus represents the necessary and sufficient condition on $M$.\n\nNow we find the minimal padding factors for $P=2$ and $P=3$. The problem specifies that $M$ must be an even integer.\n\n**Case $P=2$ (Quadratic Nonlinearity):**\nThe inequality is $M > \\frac{(2+1)N}{2} - 1 = \\frac{3N}{2} - 1$.\nSince $N$ is even, $\\frac{3N}{2}$ is an integer. As $M$ must be an integer, the condition implies $M \\ge \\frac{3N}{2}$.\nIf $\\frac{3N}{2}$ is even, the minimal choice for $M$ is $\\frac{3N}{2}$. If $\\frac{3N}{2}$ is odd, the minimal even choice is $M=\\frac{3N}{2}+1$. The simplest general rule that works for all even $N$ is to choose $M$ such that $M \\ge \\frac{3N}{2}$. The minimal padding factor is $p_2 \\equiv M/N = 3/2 = 1.5$. This is sufficient if $3N/2$ is an even integer, which is true for the test cases.\n\n**Case $P=3$ (Cubic Nonlinearity):**\nThe inequality is $M > \\frac{(3+1)N}{2} - 1 = 2N - 1$.\nSince $N$ is even, $2N$ is a multiple of $2$, and $2N-1$ is an odd integer. The smallest integer $M$ satisfying $M > 2N-1$ is $2N$. Since $N$ is even, $2N$ is always even.\nThus, the minimal choice for $M$ is $2N$. The minimal padding factor is $p_3 \\equiv M/N = 2$.\n\nThe derived minimal padding factors are $p_2 = 1.5$ and $p_3 = 2.0$.\n\n### Task B: Design of the Minimal Zero-Padding Scheme\n\nThe scheme leverages the derived padding factors to compute the nonlinear term $u^P$ without aliasing. For efficiency with real-valued fields $u(x)$, the algorithm is best implemented using the Real-to-Complex Fast Fourier Transform (`rfft`) and its inverse (`irfft`).\n\nThe algorithm proceeds as follows:\n1.  **Initialization**: Given a real-valued field $u$ on an $N$-point grid, first compute its spectrum $\\widehat{u}_r = \\text{rfft}(u)$. The resulting complex array has length $N/2+1$.\n2.  **Padding Factor and Grid Size**: For a nonlinearity of degree $P$, select the minimal padding factor $p_P$ derived in Task A ($p_2=1.5$, $p_3=2$). Calculate the padded grid size $M = \\text{int}(p_P \\times N)$, ensuring it is an even integer.\n3.  **Zero-Padding**: Create a new complex array $\\widehat{u}^{\\text{pad}}_r$ of length $M/2+1$, initialized to zeros. Copy the coefficients from $\\widehat{u}_r$ into the low-frequency part of $\\widehat{u}^{\\text{pad}}_r$:\n    $$\n    \\widehat{u}^{\\text{pad}}_r[k] = \\begin{cases} \\widehat{u}_r[k] & \\text{if } 0 \\le k \\le N/2 \\\\ 0 & \\text{if } N/2 < k \\le M/2 \\end{cases}\n    $$\n4.  **Inverse Transform**: Transform the padded spectrum back to physical space to obtain the field on the high-resolution grid: $u^{\\text{pad}} = \\text{irfft}(\\widehat{u}^{\\text{pad}}_r, n=M)$.\n5.  **Pointwise Product**: Compute the nonlinearity pointwise on the padded grid: $v^{\\text{pad}} = (u^{\\text{pad}})^P$.\n6.  **Forward Transform**: Transform the result back to the padded spectral space: $\\widehat{v}^{\\text{pad}}_r = \\text{rfft}(v^{\\text{pad}}, n=M)$. This array has length $M/2+1$.\n7.  **Truncation**: Truncate the resulting spectrum by taking the first $N/2+1$ components, which correspond to the wavenumbers of the original base grid. The final, de-aliased spectrum of the product is $\\widehat{v}_r = \\widehat{v}^{\\text{pad}}_r[0 : N/2+1]$.\n\n### Task C: Verification Strategy\n\nThe correctness of the padding factors and the scheme is verified by comparing the result of the pseudo-spectral product against a reference calculation performed on a grid large enough to be considered effectively alias-free. The problem specifies a reference grid of size $M_{\\text{ref}} = 4N$. For the nonlinearities of degree $P \\le 3$ considered here, this resolution is more than sufficient (since $4N > 2N-1$).\n\nFor each test case $(N, P, p)$:\n1.  A random real field $u$ of length $N$ is generated.\n2.  Its spectrum $\\widehat{u}_r$ is computed.\n3.  The padded product is computed using the scheme from Task B with the given padding factor $p$, yielding $\\widehat{v}^{\\text{test}}_r$.\n4.  A reference product is computed using the same scheme but with a padding factor of $p_{\\text{ref}} = M_{\\text{ref}}/N = 4$, yielding $\\widehat{v}^{\\text{ref}}_r$.\n5.  The two resulting spectra, $\\widehat{v}^{\\text{test}}_r$ and $\\widehat{v}^{\\text{ref}}_r$, are compared element-wise. The test passes if they are numerically equal within a specified tight tolerance ($\\varepsilon_{\\text{rel}}=10^{-10}$, $\\varepsilon_{\\text{abs}}=10^{-12}$).\n6.  A test case with $p \\ge p_P$ is expected to pass, indicating successful de-aliasing. A test case with $p < p_P$ is expected to fail due to aliasing contamination.\n\nThe expected results for the test suite are:\n-   Case 1: $(16, 2, 1.5)$. $p=p_2$. Expected: `True`.\n-   Case 2: $(16, 2, 1.0)$. $p<p_2$. Expected: `False`.\n-   Case 3: $(16, 3, 2.0)$. $p=p_3$. Expected: `True`.\n-   Case 4: $(16, 3, 1.5)$. $p<p_3$. Expected: `False`.\n-   Case 5: $(8, 2, 1.5)$. $p=p_2$. Expected: `True`.\n-   Case 6: $(32, 3, 2.0)$. $p=p_3$. Expected: `True`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef padded_product(u_hat_r, N, P, p):\n    \"\"\"\n    Computes the spectrum of u**P using a zero-padded pseudo-spectral method.\n\n    Args:\n        u_hat_r (np.ndarray): The rfft of the real field u (length N/2 + 1).\n        N (int): The length of the base grid for u.\n        P (int): The degree of the polynomial nonlinearity.\n        p (float): The padding factor M/N.\n\n    Returns:\n        np.ndarray: The truncated spectrum of the product (length N/2 + 1).\n    \"\"\"\n    # Calculate padded grid size M, must be an even integer\n    if (p * N) % 1 != 0:\n        raise ValueError(f\"Padding factor p={p} for N={N} does not result in an integer M.\")\n    M = int(p * N)\n    if M % 2 != 0:\n        raise ValueError(f\"Padded grid size M={M} must be even.\")\n\n    # 1. Zero-pad the spectrum.\n    # The padded spectrum will have length for an M-point real FFT.\n    u_hat_r_padded = np.zeros(M // 2 + 1, dtype=np.complex128)\n    \n    # Copy the original spectrum coefficients to the low-frequency portion.\n    # u_hat_r has length N//2 + 1.\n    u_hat_r_padded[0 : N // 2 + 1] = u_hat_r\n\n    # 2. Transform to physical space on the padded grid.\n    u_padded = np.fft.irfft(u_hat_r_padded, n=M)\n\n    # 3. Perform the pointwise multiplication for the nonlinearity.\n    v_padded = u_padded**P\n\n    # 4. Transform back to the padded spectral space.\n    v_hat_padded_r = np.fft.rfft(v_padded, n=M)\n\n    # 5. Truncate the spectrum back to the original base grid resolution.\n    v_hat_final = v_hat_padded_r[0 : N // 2 + 1]\n\n    return v_hat_final\n\ndef solve():\n    \"\"\"\n    Main solver function to perform the derivation and verification tasks.\n    \"\"\"\n    # Task A: Derived minimal padding factors\n    p2_minimal = 1.5\n    p3_minimal = 2.0\n\n    # Task C: Test suite verification\n    test_cases = [\n        # (N, P, p)\n        (16, 2, 1.5),    # Case 1: P=2, minimal padding -> should pass\n        (16, 2, 1.0),    # Case 2: P=2, no padding -> should fail\n        (16, 3, 2.0),    # Case 3: P=3, minimal padding -> should pass\n        (16, 3, 1.5),    # Case 4: P=3, insufficient padding -> should fail\n        (8,  2, 1.5),    # Case 5: P=2, minimal padding -> should pass\n        (32, 3, 2.0),    # Case 6: P=3, minimal padding -> should pass\n    ]\n    \n    # Parameters for verification\n    M_ref_factor = 4.0  # Reference grid is 4 * N\n    random_seed = 42    # For reproducible random fields\n    rtol = 1e-10\n    atol = 1e-12\n\n    # Initialize results list with the derived factors\n    results = [p2_minimal, p3_minimal]\n    \n    # Set a generator for reproducibility across all test cases\n    rng = np.random.default_rng(random_seed)\n\n    for N, P, p in test_cases:\n        # Generate a reproducible random real field on the base grid\n        u = rng.standard_normal(N)\n        \n        # Compute its spectrum\n        u_hat_r = np.fft.rfft(u)\n\n        # Compute the product using the test padding factor\n        v_hat_test = padded_product(u_hat_r, N, P, p)\n        \n        # Compute the \"alias-free\" reference product on a much larger grid\n        v_hat_ref = padded_product(u_hat_r, N, P, M_ref_factor)\n\n        # Compare the results and determine if the test passes\n        passed = np.allclose(v_hat_test, v_hat_ref, rtol=rtol, atol=atol)\n        results.append(passed)\n\n    # Format and print the final output exactly as required\n    # Note: Python's str(bool) gives 'True'/'False' which is correct for a \"Python-style list\" string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For time-dependent wave equations, accuracy is not just about spatial resolution, but also about how well the simulation preserves wave properties like phase speed over time. This practice delves into the analysis of numerical dispersion, the phenomenon where different wave components travel at incorrect speeds in a simulation. You will derive the discrete dispersion relation for the linearized Korteweg-de Vries equation to quantify the phase error, providing a powerful tool for analyzing the long-term fidelity of a numerical scheme without running a full simulation. ",
            "id": "3390863",
            "problem": "Consider the periodic initial value problem for the linearized Korteweg–De Vries equation on a one-dimensional torus with period $2\\pi$,\n$$\nu_t(x,t) + u_{xxx}(x,t) = 0, \\quad x \\in [0,2\\pi), \\quad t \\ge 0,\n$$\nsubject to the periodic boundary condition $u(x+2\\pi,t) = u(x,t)$ and an initial condition composed of a single Fourier mode $u(x,0) = \\sin(k x)$ for a given integer wavenumber $k \\ge 1$. Let $N$ be the number of equispaced spatial grid points on $[0,2\\pi)$ and let the Fast Fourier Transform (FFT) be used to implement spectral differentiation, where the discrete wavenumbers are $k_m = m$ for $m \\in \\{-N/2,\\ldots,N/2-1\\}$ and the third derivative in Fourier space is represented by multiplication by $(i k_m)^3$.\n\nStarting from the definitions of the Fourier series on a periodic domain, the FFT-based pseudospectral differentiation operator, and a fixed-step explicit time-stepping method with step size $\\Delta t$, derive the discrete dispersion relation associated with advancing a single Fourier mode over one time step when the third derivative is computed via FFT. Analyze how filtering and padding strategies modify this discrete dispersion relation. Your derivation must begin from the Fourier representation of $u(x,t)$ and the ordinary differential equation satisfied by each Fourier mode of the linearized Korteweg–De Vries equation, and then proceed to the discrete-in-time update for a single step using a classical explicit Runge–Kutta method. Do not introduce any formulas for the discrete dispersion relation without deriving them from these bases.\n\nDefine two classes of filtering strategies:\n- A post-step real-valued spectral filter, which multiplies the Fourier coefficients by a real factor $g(k)$ after each time step.\n- A pre-derivative spectral filter, which multiplies the Fourier coefficients by a real factor $g(k)$ before each evaluation of the derivative in a time step.\n\nAssume the real-valued exponential filter\n$$\ng(k) = \\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{k_{\\max}}\\right)^p\\right),\n$$\nwhere $k_{\\max} = N/2$, $\\alpha > 0$ is a strength parameter, and $p \\ge 1$ is an even integer. For padding, consider an upsampling factor $s \\in \\{1,2\\}$ implemented by zero-padding the Fourier coefficients to size $sN$ before spectral differentiation and then truncating back to $N$; for a single Fourier mode that is exactly represented on the base grid, this operation should be analyzed for its effect on the discrete dispersion relation.\n\nDefine the phase of a single Fourier mode at time $t$ as the argument of its Fourier coefficient. Let the exact continuous dispersion relation be $\\omega(k) = k^3$, so that the exact phase at time $T$ is $\\varphi_{\\mathrm{exact}}(T) = k^3 T$ in radians. Let $\\varphi_{\\mathrm{num}}(T)$ be the accumulated numerical phase after $n = T/\\Delta t$ steps, defined as $n$ times the principal argument of the single-step amplification factor of the time-stepping scheme applied to the FFT-based differentiation operator, including any filtering strategy. Define the phase error as\n$$\n\\Delta \\varphi(T) = \\varphi_{\\mathrm{num}}(T) - \\varphi_{\\mathrm{exact}}(T),\n$$\nexpressed in radians.\n\nYour program must compute $\\Delta \\varphi(T)$ in radians for the following test suite, without simulating the field in physical space, by using the derived discrete dispersion relation for a single mode:\n1. Baseline case (happy path): $N = 128$, $\\Delta t = 0.005$, $T = 10$, $k = 7$, strategy: no filtering, padding factor $s=1$.\n2. Padding case: $N = 128$, $\\Delta t = 0.005$, $T = 10$, $k = 7$, strategy: no filtering, padding factor $s=2$.\n3. Pre-derivative exponential filter case: $N = 128$, $\\Delta t = 0.002$, $T = 10$, $k = 20$, strategy: pre-derivative exponential filter with $\\alpha = 50$, $p = 2$, padding factor $s=1$.\n4. Post-step exponential filter case: $N = 128$, $\\Delta t = 0.002$, $T = 10$, $k = 20$, strategy: post-step exponential filter with $\\alpha = 50$, $p = 2$, padding factor $s=1$.\n5. Boundary-stability case: $N = 64$, $\\Delta t = 0.002$, $T = 5$, $k = 10$, strategy: no filtering, padding factor $s=1$.\n\nAll phases and phase errors must be computed and reported in radians. Assume that $T/\\Delta t$ is an integer in all cases.\n\nYour program should produce a single line of output containing the phase errors for the five test cases as a comma-separated list enclosed in square brackets, for example, \"[result1,result2,result3,result4,result5]\". Each result must be a floating-point number in radians. The output must be exactly this single line and nothing else.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the numerical analysis of partial differential equations, well-posed with a unique answer for each sub-problem, and formulated using objective, standard terminology. The ambiguity in specifying \"a classical explicit Runge–Kutta method\" is resolved by selecting the fourth-order classical Runge-Kutta scheme (RK4), which is a standard choice in scientific computing and fits the description. The problem's dispersion relation $\\omega(k)=-k^3$ for the equation $u_t+u_{xxx}=0$ corresponds to a wave $e^{i(kx-\\omega t)}$, which means $u_t+u_{xxx}=0 \\implies (-i\\omega + (ik)^3)e^{i(kx-\\omega t)}=0 \\implies \\omega=-k^3$. The phase $\\phi=kx-\\omega t = kx+k^3 t$ increases over time as $k^3 t$. Therefore the exact phase is $\\varphi_{\\mathrm{exact}}(T) = k^3 T$, which is consistent with the problem statement.\n\nThis solution will derive the discrete dispersion relation for the numerical scheme by finding the single-step complex amplification factor for a single Fourier mode. This factor will then be used to calculate the accumulated numerical phase and the resulting phase error. The derivation proceeds from first principles as requested.\n\nThe linearized Korteweg-de Vries (KdV) equation is given by:\n$$\nu_t + u_{xxx} = 0\n$$\nWe consider solutions on a periodic domain $x \\in [0, 2\\pi)$. A function $u(x,t)$ on this domain can be represented by its Fourier series:\n$$\nu(x,t) = \\sum_{k=-\\infty}^{\\infty} \\hat{u}_k(t) e^{ikx}\n$$\nwhere $\\hat{u}_k(t)$ are the time-dependent Fourier coefficients and $k$ are integer wavenumbers. The derivatives of $u(x,t)$ are found by differentiating this series term by term:\n$$\nu_t = \\sum_{k} \\frac{d\\hat{u}_k}{dt} e^{ikx}, \\quad u_{xxx} = \\sum_{k} (ik)^3 \\hat{u}_k(t) e^{ikx}\n$$\nSubstituting these into the KdV equation gives:\n$$\n\\sum_{k} \\left( \\frac{d\\hat{u}_k}{dt} + (ik)^3 \\hat{u}_k \\right) e^{ikx} = 0\n$$\nDue to the orthogonality of the complex exponentials $e^{ikx}$, this equation must hold for each mode individually. This yields a decoupled system of ordinary differential equations (ODEs) for the Fourier coefficients:\n$$\n\\frac{d\\hat{u}_k}{dt} = -(ik)^3 \\hat{u}_k = -i^3 k^3 \\hat{u}_k = i k^3 \\hat{u}_k\n$$\nThis is a linear ODE of the form $\\frac{dy}{dt} = \\lambda y$ with $\\lambda = ik^3$. The exact solution is $\\hat{u}_k(t) = \\hat{u}_k(0) e^{\\lambda t} = \\hat{u}_k(0) e^{ik^3 t}$. The complex coefficient $\\hat{u}_k(t)$ rotates in the complex plane with an angular frequency of $k^3$. The total accumulated phase at time $T$ for a mode with wavenumber $k$ is $\\varphi_{\\mathrm{exact}}(T) = k^3 T$.\n\nFor the numerical solution, we use a pseudospectral method. A single Fourier mode $e^{ikx}$ with integer wavenumber $k$ is represented exactly on a grid of $N$ points, provided $|k| < N/2$. The spectral differentiation via FFT is also exact for such a mode, equivalent to multiplication by $(ik)^3$ in Fourier space. Thus, the semi-discretized problem for a single mode is identical to the continuous ODE: $\\frac{d\\hat{u}_k}{dt} = i k^3 \\hat{u}_k$.\n\nThe time integration is performed using the classical fourth-order Runge-Kutta (RK4) method. For an ODE $\\frac{dy}{dt} = \\lambda y$, a single step of RK4 from $t_n$ to $t_{n+1}=t_n+\\Delta t$ is given by $y_{n+1} = G(\\lambda \\Delta t) y_n$, where $G(z)$ is the RK4 stability polynomial:\n$$\nG(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\nThe complex number $A = G(z)$ is the single-step amplification factor. For our problem, the argument to this polynomial is $z = \\mathcal{L}_k \\Delta t$, where $\\mathcal{L}_k$ is the numerical operator corresponding to $ik^3$.\n\nThe total numerical phase accumulated over a time $T$ is the number of steps $n = T/\\Delta t$ multiplied by the phase change per step, which is the argument of the amplification factor $A$:\n$$\n\\varphi_{\\mathrm{num}}(T) = n \\cdot \\arg(A) = \\frac{T}{\\Delta t} \\arg(A)\n$$\nThe phase error is then $\\Delta \\varphi(T) = \\varphi_{\\mathrm{num}}(T) - \\varphi_{\\mathrm{exact}}(T)$. We now analyze the amplification factor $A$ for each strategy.\n\n1.  **Baseline Case (No Filtering, No Padding):**\n    The numerical operator for the mode $k$ is $\\mathcal{L}_k = ik^3$. The argument to the RK4 polynomial is $z = ik^3 \\Delta t$. The amplification factor is:\n    $$\n    A_{\\mathrm{base}} = G(ik^3 \\Delta t)\n    $$\n\n2.  **Padding Case ($s=2$):**\n    Padding involves embedding the $N$-point Fourier coefficients into a larger array of size $sN$ (here $2N$), performing the derivative operation on the larger grid, and then truncating back to $N$ coefficients. For a linear differential operator and a single Fourier mode $e^{ikx}$ that is perfectly resolved on the $N$-point grid (i.e., $|k| < N/2$), this procedure has no effect. The coefficient $\\hat{u}_k$ is mapped to the same wavenumber $k$ in the padded space. Multiplication by $(ik')^3$ on the padded grid applies the factor $(ik)^3$ to $\\hat{u}_k$. Truncation preserves this modified coefficient. Therefore, the operator is unchanged: $\\mathcal{L}_k = ik^3$. The amplification factor is identical to the baseline case:\n    $$\n    A_{\\mathrm{pad}} = A_{\\mathrm{base}} = G(ik^3 \\Delta t)\n    $$\n    Padding is a technique for de-aliasing nonlinear terms, which are absent in this linear problem.\n\n3.  **Pre-derivative Exponential Filter Case:**\n    The filter $g(k) = \\exp(-\\alpha (|k|/k_{\\max})^p)$ is applied to the Fourier coefficients before each derivative calculation. This modifies the numerical operator itself. For a single mode $k$, the operator becomes $\\mathcal{L}^{\\text{pre}}_k = g(k) \\cdot (ik^3)$. This modified operator is used throughout the RK4 stages. The amplification factor is thus:\n    $$\n    A_{\\mathrm{pre}} = G(g(k) \\cdot ik^3 \\Delta t)\n    $$\n\n4.  **Post-step Exponential Filter Case:**\n    The filter is applied once at the end of a complete RK4 time step. The time step is computed with the original operator $\\mathcal{L}_k = ik^3$, and the resulting coefficient is then multiplied by the filter factor $g(k)$. The amplification factor is:\n    $$\n    A_{\\mathrm{post}} = g(k) \\cdot G(ik^3 \\Delta t)\n    $$\n    Note that the stability of the method is determined by $G(ik^3 \\Delta t)$, and the filter $g(k)$ simply scales the result. If the unfiltered step is unstable ($|G(ik^3\\Delta t)| > 1$), the post-step filter may not be sufficient to stabilize the overall scheme unless $g(k)$ is very small.\n\nUsing these derived amplification factors, the phase error for each test case is computed according to $\\Delta \\varphi(T) = (T/\\Delta t) \\arg(A) - k^3 T$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the phase error for five test cases of a pseudospectral simulation\n    of the linearized Korteweg-De Vries equation. The computation is based on the\n    analytically derived discrete dispersion relation for a single Fourier mode\n    advanced with a fourth-order Runge-Kutta (RK4) time-stepping scheme.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Baseline\n        {'label': 'Baseline', 'N': 128, 'dt': 0.005, 'T': 10, 'k': 7,\n         'strategy': 'none', 's': 1},\n        # Case 2: Padding\n        {'label': 'Padding', 'N': 128, 'dt': 0.005, 'T': 10, 'k': 7,\n         'strategy': 'none', 's': 2},\n        # Case 3: Pre-derivative Filter\n        {'label': 'Pre-derivative Filter', 'N': 128, 'dt': 0.002, 'T': 10, 'k': 20,\n         'strategy': 'pre_filter', 'alpha': 50, 'p': 2, 's': 1},\n        # Case 4: Post-step Filter\n        {'label': 'Post-step Filter', 'N': 128, 'dt': 0.002, 'T': 10, 'k': 20,\n         'strategy': 'post_filter', 'alpha': 50, 'p': 2, 's': 1},\n        # Case 5: Boundary-stability\n        {'label': 'Boundary-stability', 'N': 64, 'dt': 0.002, 'T': 5, 'k': 10,\n         'strategy': 'none', 's': 1},\n    ]\n\n    results = []\n\n    def rk4_poly(z: complex) -> complex:\n        \"\"\"Computes the RK4 stability polynomial P(z) = 1 + z + z^2/2 + z^3/6 + z^4/24.\"\"\"\n        return 1 + z + z**2 / 2 + z**3 / 6 + z**4 / 24\n\n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        T = case['T']\n        k = case['k']\n        strategy = case['strategy']\n        \n        # The number of time steps, guaranteed to be an integer per problem statement.\n        n_steps = T / dt\n        \n        # The exact phase accumulation over time T for the continuous equation.\n        exact_phase = (k**3) * T\n        \n        # The argument to the RK4 polynomial for the unfiltered operator.\n        z0 = 1j * (k**3) * dt\n        \n        # Calculate the single-step complex amplification factor A based on the strategy.\n        A = 0j\n        if strategy == 'none':\n            # Padding (s=2) does not affect a single resolved mode in a linear problem.\n            # The operator applied to the mode's coefficient remains unchanged.\n            A = rk4_poly(z0)\n        \n        elif strategy == 'pre_filter':\n            alpha = case['alpha']\n            p = case['p']\n            k_max = N / 2\n            g_k = np.exp(-alpha * (abs(k) / k_max)**p)\n            \n            # The filter modifies the operator itself.\n            z_filtered = g_k * z0\n            A = rk4_poly(z_filtered)\n            \n        elif strategy == 'post_filter':\n            alpha = case['alpha']\n            p = case['p']\n            k_max = N / 2\n            g_k = np.exp(-alpha * (abs(k) / k_max)**p)\n            \n            # The filter is applied after the RK4 step.\n            A_unfiltered = rk4_poly(z0)\n            A = g_k * A_unfiltered\n            \n        else:\n            # This path should not be reached with the given test cases.\n            raise ValueError(f\"Unknown strategy: {strategy}\")\n\n        # The numerical phase accumulation is n_steps times the phase change per step.\n        # The phase change per step is the argument (angle) of the amplification factor.\n        num_phase_per_step = np.angle(A)\n        total_num_phase = n_steps * num_phase_per_step\n        \n        # The phase error is the difference between numerical and exact phase.\n        phase_error = total_num_phase - exact_phase\n        results.append(phase_error)\n\n    # Print the final results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}