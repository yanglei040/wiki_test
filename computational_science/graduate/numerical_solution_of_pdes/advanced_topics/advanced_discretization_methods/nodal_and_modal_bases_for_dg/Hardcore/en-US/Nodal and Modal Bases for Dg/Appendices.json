{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of the efficiency of Discontinuous Galerkin and other finite element methods is the use of a reference element. By performing calculations once on a standardized domain, like the interval $[-1, 1]$, we can reuse them for every element in our mesh. This practice walks you through the fundamental mechanics of this process, using the change of variables theorem and the chain rule to derive how the essential mass and stiffness matrices are transformed from the reference element to any physical element . Mastering this transformation is the first step toward building a practical DG code.",
            "id": "3424466",
            "problem": "Consider the one-dimensional Discontinuous Galerkin (DG) discretization of a second-order scalar partial differential equation on an element $e = [x_L, x_R]$. Let the reference element be $[-1, 1]$, and consider the affine mapping $x(\\xi) = \\dfrac{x_R - x_L}{2}\\,\\xi + \\dfrac{x_R + x_L}{2}$ with Jacobian $J = \\dfrac{x_R - x_L}{2}$. Let $\\{\\hat{\\phi}_i(\\xi)\\}_{i=0}^{p}$ be a polynomial basis on the reference element (which may be either nodal or modal), and define the corresponding physical-element basis by $\\phi_i(x) = \\hat{\\phi}_i(\\xi(x))$. The element mass and stiffness matrices are defined by\n$$\nM_{ij}^{e} = \\int_{x_L}^{x_R} \\phi_i(x)\\,\\phi_j(x)\\,dx,\\qquad \nK_{ij}^{e} = \\int_{x_L}^{x_R} \\frac{d\\phi_i}{dx}(x)\\,\\frac{d\\phi_j}{dx}(x)\\,dx.\n$$\nOn the reference element, define the mass and stiffness matrices\n$$\n\\hat{M}_{ij} = \\int_{-1}^{1} \\hat{\\phi}_i(\\xi)\\,\\hat{\\phi}_j(\\xi)\\,d\\xi,\\qquad \n\\hat{K}_{ij} = \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi)\\,\\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi)\\,d\\xi.\n$$\nStarting from the change-of-variables theorem for integrals and the chain rule for derivatives, derive how integrals over $[x_L, x_R]$ transform under the affine map and determine precisely how the Jacobian $J$ appears in $M_{ij}^{e}$ and $K_{ij}^{e}$ in terms of $\\hat{M}_{ij}$ and $\\hat{K}_{ij}$. Provide all steps in your reasoning and do not assume any special properties of the basis beyond polynomiality and the pullback $\\phi_i(x) = \\hat{\\phi}_i(\\xi(x))$. \n\nGive your final answer as the pair $(M_{ij}^{e}, K_{ij}^{e})$ expressed only in terms of $J$, $\\hat{M}_{ij}$, and $\\hat{K}_{ij}$. Your final answer must be a single analytic expression and contain no equations or inequalities.",
            "solution": "The problem as stated is valid. It is a standard and well-posed problem in the theory of finite element and discontinuous Galerkin methods, based on established mathematical principles. All terms are clearly defined, and the premises are self-consistent and sufficient to derive the required relationships. We now proceed with the solution.\n\nThe objective is to relate the physical element matrices, $M_{ij}^{e}$ and $K_{ij}^{e}$, defined on the physical element $e = [x_L, x_R]$, to the reference element matrices, $\\hat{M}_{ij}$ and $\\hat{K}_{ij}$, defined on the reference element $[-1, 1]$. This is achieved through the provided affine mapping and its Jacobian.\n\nLet the affine mapping from the reference coordinate $\\xi \\in [-1, 1]$ to the physical coordinate $x \\in [x_L, x_R]$ be\n$$\nx(\\xi) = \\frac{x_R - x_L}{2}\\,\\xi + \\frac{x_R + x_L}{2}.\n$$\nThe Jacobian of this transformation, $J$, is the derivative of $x$ with respect to $\\xi$:\n$$\nJ = \\frac{dx}{d\\xi} = \\frac{d}{d\\xi}\\left(\\frac{x_R - x_L}{2}\\,\\xi + \\frac{x_R + x_L}{2}\\right) = \\frac{x_R - x_L}{2}.\n$$\nSince $x_L$ and $x_R$ are constants for a given element, the Jacobian $J$ is a constant. The inverse mapping from $x$ to $\\xi$ can also be differentiated:\n$$\n\\frac{d\\xi}{dx} = \\left(\\frac{dx}{d\\xi}\\right)^{-1} = J^{-1} = \\frac{1}{J}.\n$$\n\nWe will now derive the expressions for the mass matrix $M_{ij}^{e}$ and the stiffness matrix $K_{ij}^{e}$ separately.\n\n### Transformation of the Mass Matrix $M_{ij}^{e}$\n\nThe definition of the physical element mass matrix is\n$$\nM_{ij}^{e} = \\int_{x_L}^{x_R} \\phi_i(x)\\,\\phi_j(x)\\,dx.\n$$\nTo evaluate this integral, we perform a change of variables from the physical coordinate $x$ to the reference coordinate $\\xi$. The integration limits change from $[x_L, x_R]$ to $[-1, 1]$. The differential element transforms as $dx = \\frac{dx}{d\\xi}\\,d\\xi = J\\,d\\xi$. The basis functions on the physical element, $\\phi_i(x)$, are defined as the pullback of the reference basis functions, $\\hat{\\phi}_i(\\xi)$, such that $\\phi_i(x(\\xi)) = \\hat{\\phi}_i(\\xi)$.\n\nSubstituting these transformations into the integral for $M_{ij}^{e}$:\n$$\nM_{ij}^{e} = \\int_{-1}^{1} \\phi_i(x(\\xi))\\,\\phi_j(x(\\xi))\\,(J\\,d\\xi).\n$$\nUsing the pullback relationship $\\phi_k(x(\\xi)) = \\hat{\\phi}_k(\\xi)$, we get:\n$$\nM_{ij}^{e} = \\int_{-1}^{1} \\hat{\\phi}_i(\\xi)\\,\\hat{\\phi}_j(\\xi)\\,J\\,d\\xi.\n$$\nSince the Jacobian $J$ is constant with respect to the integration variable $\\xi$, it can be factored out of the integral:\n$$\nM_{ij}^{e} = J \\int_{-1}^{1} \\hat{\\phi}_i(\\xi)\\,\\hat{\\phi}_j(\\xi)\\,d\\xi.\n$$\nThe remaining integral is, by definition, the reference mass matrix, $\\hat{M}_{ij}$:\n$$\n\\hat{M}_{ij} = \\int_{-1}^{1} \\hat{\\phi}_i(\\xi)\\,\\hat{\\phi}_j(\\xi)\\,d\\xi.\n$$\nTherefore, the relationship for the mass matrix is:\n$$\nM_{ij}^{e} = J \\hat{M}_{ij}.\n$$\n\n### Transformation of the Stiffness Matrix $K_{ij}^{e}$\n\nThe definition of the physical element stiffness matrix is\n$$\nK_{ij}^{e} = \\int_{x_L}^{x_R} \\frac{d\\phi_i}{dx}(x)\\,\\frac{d\\phi_j}{dx}(x)\\,dx.\n$$\nThis transformation requires two steps: first, transforming the derivatives $\\frac{d\\phi_k}{dx}$, and second, transforming the integral itself.\n\nWe use the chain rule to relate the derivative with respect to $x$ to the derivative with respect to $\\xi$:\n$$\n\\frac{d\\phi_k}{dx} = \\frac{d\\phi_k}{d\\xi}\\,\\frac{d\\xi}{dx}.\n$$\nThe term $\\frac{d\\phi_k}{d\\xi}$ is the derivative of the composite function $\\phi_k(x(\\xi))$ with respect to $\\xi$. By definition, this is equal to the derivative of the reference basis function $\\frac{d\\hat{\\phi}_k}{d\\xi}$. The term $\\frac{d\\xi}{dx}$ is the inverse of the Jacobian, which we found to be $J^{-1}$. Thus,\n$$\n\\frac{d\\phi_k}{dx}(x) = \\frac{d\\hat{\\phi}_k}{d\\xi}(\\xi(x)) \\cdot \\frac{1}{J}.\n$$\nSubstituting this expression for the derivatives of both $\\phi_i$ and $\\phi_j$ into the definition of $K_{ij}^{e}$:\n$$\nK_{ij}^{e} = \\int_{x_L}^{x_R} \\left(\\frac{1}{J}\\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi(x))\\right) \\left(\\frac{1}{J}\\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi(x))\\right) dx.\n$$\nCombining the constant factors of $J$:\n$$\nK_{ij}^{e} = \\int_{x_L}^{x_R} \\frac{1}{J^2} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi(x)) \\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi(x)) dx.\n$$\nNext, we perform the change of variables for the integral, similar to the mass matrix case. The integration domain becomes $[-1, 1]$ and the differential $dx$ becomes $J\\,d\\xi$:\n$$\nK_{ij}^{e} = \\int_{-1}^{1} \\frac{1}{J^2} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi) \\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi) (J\\,d\\xi).\n$$\nThe factors involving the constant Jacobian $J$ can be simplified and moved outside the integral:\n$$\nK_{ij}^{e} = \\frac{J}{J^2} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi)\\,\\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi)\\,d\\xi = \\frac{1}{J} \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi)\\,\\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi)\\,d\\xi.\n$$\nThe remaining integral is the definition of the reference stiffness matrix, $\\hat{K}_{ij}$:\n$$\n\\hat{K}_{ij} = \\int_{-1}^{1} \\frac{d\\hat{\\phi}_i}{d\\xi}(\\xi)\\,\\frac{d\\hat{\\phi}_j}{d\\xi}(\\xi)\\,d\\xi.\n$$\nTherefore, the relationship for the stiffness matrix is:\n$$\nK_{ij}^{e} = \\frac{1}{J} \\hat{K}_{ij}.\n$$\n\nThe final answer is the pair $(M_{ij}^{e}, K_{ij}^{e})$ expressed in terms of $J$, $\\hat{M}_{ij}$, and $\\hat{K}_{ij}$. Based on the derivations above, this pair is $\\left(J\\,\\hat{M}_{ij}, \\frac{1}{J}\\hat{K}_{ij}\\right)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nJ \\hat{M}_{ij}  \\frac{1}{J} \\hat{K}_{ij}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Having established how to map between reference and physical domains, we now investigate the internal structure of a modal DG scheme. This exercise focuses on a basis of Legendre polynomials, a common choice for its advantageous mathematical properties . By deriving the weak derivative matrix from first principles, you will uncover its elegant sparse and parity-coupling structure, gaining insight into how differentiation is represented algebraically and why modal bases can be particularly effective.",
            "id": "3424476",
            "problem": "Consider the one-dimensional reference element $[-1,1]$ used in the Discontinuous Galerkin (DG) method for the numerical solution of partial differential equations (PDEs). Let $\\{\\phi_{n}(\\xi)\\}_{n=0}^{p}$ be the Legendre-based modal basis on $[-1,1]$, specifically take $\\phi_{n}(\\xi)=P_{n}(\\xi)$, the degree-$n$ Legendre polynomial, where $P_{n}$ is orthogonal on $[-1,1]$ with weight $1$ and satisfies $\\int_{-1}^{1} P_{m}(\\xi)P_{n}(\\xi)\\,d\\xi=\\frac{2}{2n+1}\\delta_{mn}$ and $P_{n}(\\pm 1)=(\\pm 1)^{n}$. Define the stiffness matrix $S\\in\\mathbb{R}^{(p+1)\\times(p+1)}$ by\n$$\nS_{mn}=\\int_{-1}^{1}\\phi_{m}'(\\xi)\\,\\phi_{n}(\\xi)\\,d\\xi=\\int_{-1}^{1}P_{m}'(\\xi)\\,P_{n}(\\xi)\\,d\\xi\n$$\nfor $0\\le m,n\\le p$. Starting from the fundamental properties of Legendre polynomials and first principles of Galerkin projection, derive an explicit closed-form expression for $S_{mn}$ for all nonnegative integers $m,n$. Then, explain how $S$ represents the derivative operator in modal space, including its sparsity and parity-coupling structure.\n\nYour final answer must be a single closed-form analytic expression for $S_{mn}$ as a function of the integers $m$ and $n$. If you use the Heaviside step function $H(k)$, take $H(k)=1$ for integer $k\\ge 1$ and $H(k)=0$ for integer $k\\le 0$. No rounding is required.",
            "solution": "The problem requires the derivation of the stiffness matrix elements $S_{mn}$ and an explanation of its properties. The problem statement is validated as scientifically grounded, well-posed, and objective. It is based on standard principles of numerical analysis and the theory of orthogonal polynomials. All necessary information is provided.\n\nThe stiffness matrix element $S_{mn}$ is defined as\n$$ S_{mn} = \\int_{-1}^{1} \\phi_{m}'(\\xi)\\,\\phi_{n}(\\xi)\\,d\\xi = \\int_{-1}^{1} P_{m}'(\\xi)\\,P_{n}(\\xi)\\,d\\xi $$\nwhere $P_k(\\xi)$ is the Legendre polynomial of degree $k$.\n\nTo derive an explicit expression for $S_{mn}$, we will use the fundamental properties of Legendre polynomials.\n\nFirst, consider the degree of the integrand's terms. The Legendre polynomial $P_m(\\xi)$ is a polynomial of degree $m$. Its derivative, $P_m'(\\xi)$, is a polynomial of degree $m-1$. The Legendre polynomials form an orthogonal basis on the interval $[-1,1]$ with a weight function of $1$. A key property of this orthogonality is that for any polynomial $q(\\xi)$ of degree less than $n$,\n$$ \\int_{-1}^{1} q(\\xi)P_{n}(\\xi)\\,d\\xi = 0 $$\nIn our case, the integral for $S_{mn}$ contains the term $P_m'(\\xi)$, which has degree $m-1$. If the degree of $P_m'(\\xi)$ is less than the degree of $P_n(\\xi)$ (which is $n$), the integral will be zero. This condition is $m-1  n$, which is equivalent to $m \\le n$.\nTherefore, for all $m \\le n$, the matrix elements are\n$$ S_{mn} = 0 \\quad \\text{for } m \\le n $$\nThis shows that the stiffness matrix $S$ is strictly lower triangular, meaning all its diagonal and upper-triangular entries are zero.\n\nNext, we consider the case where $m  n$. We employ integration by parts on the definition of $S_{mn}$:\nLet $u = P_n(\\xi)$ and $dv = P_m'(\\xi)d\\xi$. Then $du = P_n'(\\xi)d\\xi$ and $v = P_m(\\xi)$.\n$$ S_{mn} = \\int_{-1}^{1} P_m'(\\xi)P_n(\\xi)\\,d\\xi = \\left[ P_m(\\xi)P_n(\\xi) \\right]_{-1}^{1} - \\int_{-1}^{1} P_m(\\xi)P_n'(\\xi)\\,d\\xi $$\nThe integral on the right-hand side is, by definition, $S_{nm} = \\int_{-1}^{1} P_n'(\\xi)P_m(\\xi)\\,d\\xi$.\nThe boundary term is evaluated using the given property $P_k(\\pm 1) = (\\pm 1)^k$:\n$$ \\left[ P_m(\\xi)P_n(\\xi) \\right]_{-1}^{1} = P_m(1)P_n(1) - P_m(-1)P_n(-1) = (1)^m (1)^n - (-1)^m (-1)^n = 1 - (-1)^{m+n} $$\nSubstituting these back, we get the relation:\n$$ S_{mn} = 1 - (-1)^{m+n} - S_{nm} $$\nThis relation holds for all $m, n$. We are currently examining the case $m  n$. For the term $S_{nm}$, the row index $n$ is strictly less than the column index $m$. As we established that $S_{ij}=0$ for $i \\le j$, it follows that $S_{nm} = 0$ since $n  m$.\nTherefore, for $m  n$, the expression for $S_{mn}$ simplifies to:\n$$ S_{mn} = 1 - (-1)^{m+n} \\quad \\text{for } m  n $$\nWe can analyze this expression further:\n- If $m$ and $n$ have the same parity (i.e., both are even or both are odd), then their sum $m+n$ is even. In this case, $S_{mn} = 1 - (-1)^{\\text{even}} = 1 - 1 = 0$.\n- If $m$ and $n$ have opposite parity (i.e., one is even and one is odd), then their sum $m+n$ is odd. In this case, $S_{mn} = 1 - (-1)^{\\text{odd}} = 1 - (-1) = 2$.\nThe parity of $m+n$ is the same as the parity of $m-n$. So, for $m  n$, $S_{mn}$ is $2$ if $m-n$ is odd, and $0$ if $m-n$ is even.\n\nWe can combine these results into a single closed-form expression using the Heaviside step function $H(k)$ defined as $H(k)=1$ for integer $k \\ge 1$ and $H(k)=0$ for integer $k \\le 0$. The condition $mn$ for non-negative integers $m, n$ is equivalent to $m-n \\ge 1$, so the indicator function for this condition is $H(m-n)$. The condition for non-zero entries is that $m-n$ is odd, which can be encapsulated by the factor $(1 - (-1)^{m-n})$.\nThis gives the final expression for $S_{mn}$:\n$$ S_{mn} = H(m-n) \\left( 1 - (-1)^{m-n} \\right) $$\n\nNow, we explain the role and structure of $S$.\nIn the DG method, a function $u(\\xi)$ is approximated by a polynomial $u_h(\\xi) = \\sum_{n=0}^{p} \\hat{u}_n \\phi_n(\\xi)$ where $\\{\\hat{u}_n\\}$ are the modal coefficients. The derivative is $u_h'(\\xi) = \\sum_{n=0}^{p} \\hat{u}_n \\phi_n'(\\xi)$. To represent this derivative in the same basis, we project it back, seeking coefficients $\\{\\widehat{u'}_m\\}$ such that $u_h' \\approx \\sum_{m=0}^{p} \\widehat{u'}_m \\phi_m(\\xi)$. The Galerkin projection gives the system of equations:\n$$ \\sum_{m=0}^{p} \\widehat{u'}_m \\int_{-1}^1 \\phi_m(\\xi) \\phi_j(\\xi) d\\xi = \\sum_{n=0}^{p} \\hat{u}_n \\int_{-1}^1 \\phi_n'(\\xi) \\phi_j(\\xi) d\\xi $$\nIn matrix form, this is $M\\widehat{\\mathbf{u'}} = S^T \\mathbf{\\hat{u}}$, where $M$ is the mass matrix with entries $M_{jm} = \\int_{-1}^1 \\phi_j \\phi_m d\\xi = \\frac{2}{2j+1}\\delta_{jm}$, $\\mathbf{\\hat{u}}$ is the vector of coefficients of $u_h$, and $\\widehat{\\mathbf{u'}}$ is the vector of coefficients for its derivative. The stiffness matrix $S$ (or rather, its transpose $S^T$) thus maps the coefficients of a function to the coefficients of its weak derivative, which are then normalized by the inverse of the (diagonal) mass matrix. So, $S$ is the integral kernel of the weak derivative operator in the modal basis.\n\nThe structure of $S$ reveals properties of the differentiation operator.\n- **Sparsity**: The matrix $S$ is strictly lower triangular. Furthermore, half of the entries in the lower triangle are also zero. Specifically, $S_{mn} \\neq 0$ only if $m  n$ and $m-n$ is odd. This checkerboard pattern of non-zero entries means that for a polynomial order $p$, the number of non-zero entries is approximately $\\frac{1}{4}(p+1)^2$. While not sparse in the sense of being banded, a large fraction of its entries are zero.\n- **Parity-Coupling Structure**: The condition that $S_{mn} \\neq 0$ only when $m$ and $n$ have opposite parity reflects a fundamental property of differentiation with respect to symmetric functions. Legendre polynomials $P_k(\\xi)$ have definite parity: $P_k(-\\xi) = (-1)^k P_k(\\xi)$, so $P_k$ is an even function for even $k$ and an odd function for odd $k$. The derivative of an even function is odd, and the derivative of an odd function is even. The modal expansion of the derivative $P_m'(\\xi)$ thus only contains basis functions $P_n(\\xi)$ that have the opposite parity of $P_m(\\xi)$. This means $m$ and $n$ must have opposite parities. The matrix $S$ therefore couples the coefficients of even-indexed basis functions to those of odd-indexed basis functions and vice-versa. This is the parity-coupling structure. If the basis vectors were reordered by parity, the matrix $S^T$ (which acts on the coefficient vectors) would take on a block anti-diagonal form.",
            "answer": "$$ \\boxed{S_{mn} = H(m-n) \\left( 1 - (-1)^{m-n} \\right)} $$"
        },
        {
            "introduction": "While nodal and modal bases can be algebraically equivalent, the choice of implementation has significant practical consequences for the accuracy and stability of a numerical scheme. This practice provides a powerful tool, Fourier analysis, to quantitatively compare the performance of modal and nodal DG methods for a canonical wave propagation problem . By constructing the discrete operator for each basis and analyzing its eigenvalues, you will directly measure and contrast their numerical dispersion and dissipation, revealing the subtle but crucial differences in their behavior.",
            "id": "3424500",
            "problem": "Consider the one-dimensional linear advection equation $u_t + a u_x = 0$ with constant advection speed $a  0$ on a periodic domain partitioned into a uniform mesh of elements of size $h$. Using the Discontinuous Galerkin (DG) method, approximate $u$ on each element with polynomials of degree $p$ and employ an upwind numerical flux at interfaces. Compare two bases for representing the local polynomial space: a modal basis (orthonormal Legendre polynomials) and a nodal basis (Lagrange polynomials at Gauss-Lobatto-Legendre (GLL) nodes). Work in a semi-discrete setting (continuous in time, discrete in space).\n\nStart from the weak form of the DG method on a single element, mapped from the physical interval $[x_{j-1/2}, x_{j+1/2}]$ to the reference interval $[-1,1]$ via $x = x_j + (h/2)\\xi$, where $x_j$ is the element center and $\\xi \\in [-1,1]$. Let $\\{\\phi_i(\\xi)\\}_{i=0}^p$ denote either the modal or nodal basis functions on the reference element, and let $u_j(\\xi,t) = \\sum_{i=0}^p u_{j,i}(t) \\phi_i(\\xi)$ be the local expansion. Define the reference mass matrix $M_{\\text{ref}}$ and the reference stiffness matrix $S_{\\text{ref}}$ by\n$$\n(M_{\\text{ref}})_{i k} = \\int_{-1}^{1} \\phi_i(\\xi)\\,\\phi_k(\\xi)\\,d\\xi,\\qquad\n(S_{\\text{ref}})_{i k} = \\int_{-1}^{1} \\phi_i'(\\xi)\\,\\phi_k(\\xi)\\,d\\xi,\n$$\nand define the boundary evaluation vectors $b_- \\in \\mathbb{R}^{p+1}$ and $b_+ \\in \\mathbb{R}^{p+1}$ by $b_{\\pm,i} = \\phi_i(\\pm 1)$, with associated boundary bilinear forms\n$$\nB_R = b_+\\,b_+^\\top,\\qquad B_L = b_-\\,b_+^\\top.\n$$\nFor $a0$ (flow to the right) with upwind flux, the semi-discrete elemental operator can be written in the form\n$$\n\\frac{h}{a}\\,\\dot{\\boldsymbol{u}}_j = 2\\,M_{\\text{ref}}^{-1}\\left(-S_{\\text{ref}} + B_R\\right)\\boldsymbol{u}_j - 2\\,M_{\\text{ref}}^{-1}B_L\\,\\boldsymbol{u}_{j-1},\n$$\nwhere $\\boldsymbol{u}_j \\in \\mathbb{R}^{p+1}$ collects the degrees of freedom on element $j$.\n\nOn a uniform periodic mesh, perform a Fourier (Bloch) analysis by assuming a mode of the form $\\boldsymbol{u}_j(t) = \\boldsymbol{v}\\,e^{\\lambda t} e^{\\mathrm{i}\\theta j}$, where $\\theta \\in \\mathbb{R}$ is the dimensionless wavenumber (angle) in radians, and define the dimensionless eigenvalue\n$$\n\\mu(\\theta) = \\frac{h}{a}\\,\\lambda(\\theta).\n$$\nShow that $\\mu(\\theta)$ is given by the eigenvalues of the $(p+1)\\times(p+1)$ Fourier symbol matrix\n$$\n\\mathcal{G}(\\theta) = 2\\,M_{\\text{ref}}^{-1}\\left(-S_{\\text{ref}} + B_R - e^{-\\mathrm{i}\\theta} B_L\\right).\n$$\nFor each basis (modal or nodal), construct $\\mathcal{G}(\\theta)$ and compute its eigenvalues at prescribed $(p,\\theta)$ pairs. Identify the principal branch eigenvalue $\\mu_\\star(\\theta)$ for each case as the one whose imaginary part is nearest to $-\\theta$ (the exact continuous dispersion relation for $u_t + a u_x = 0$ is $\\lambda_{\\text{exact}} = -\\mathrm{i} a k$, so in dimensionless form $\\mu_{\\text{exact}} = -\\mathrm{i}\\theta$). Quantify dispersion error and numerical dissipation as:\n- dispersion error: $\\mathrm{Im}(\\mu_\\star(\\theta)) + \\theta$,\n- dissipation: $\\mathrm{Re}(\\mu_\\star(\\theta))$.\n\nAdditionally, quantify the difference between the eigenstructures of the modal and nodal operators at the same $(p,\\theta)$ by:\n- principal eigenvalue difference: $\\left|\\mu_{\\star,\\text{modal}}(\\theta) - \\mu_{\\star,\\text{nodal}}(\\theta)\\right|$,\n- bidirectional Hausdorff distance between eigenvalue sets: the maximum of the two directed distances, where a directed distance from set $A$ to set $B$ is $\\max_{\\alpha\\in A}\\min_{\\beta\\in B}|\\alpha-\\beta|$.\n\nImplement all constructions rigorously from first principles as follows:\n- For the modal basis, use orthonormal Legendre polynomials on $[-1,1]$, i.e., $\\phi_n(\\xi) = \\sqrt{\\frac{2n+1}{2}}\\,P_n(\\xi)$, where $P_n$ is the $n$-th Legendre polynomial. For integration, use Gauss-Legendre quadrature of sufficient order to evaluate $S_{\\text{ref}}$ exactly. Use $M_{\\text{ref}} = I$.\n- For the nodal basis, use Lagrange polynomials at $N=p+1$ Gauss-Lobatto-Legendre nodes and their associated quadrature weights, with volume integrals approximated by GLL quadrature and a diagonal mass matrix $M_{\\text{ref}} = \\mathrm{diag}(w_0,\\dots,w_p)$. Use the exact boundary evaluations $\\phi_i(\\pm 1)$ implied by the nodal basis.\n\nYour program must compute, for each test case $(p,\\theta)$ in the test suite below, the six quantities:\n1. dispersion error in the modal basis,\n2. dissipation in the modal basis,\n3. dispersion error in the nodal basis,\n4. dissipation in the nodal basis,\n5. principal eigenvalue difference between modal and nodal bases,\n6. bidirectional Hausdorff distance between the full eigenvalue sets.\n\nAngles are to be provided and interpreted in radians. There are no physical units required in the final output because all quantities are dimensionless.\n\nTest Suite:\n- $(p,\\theta) = (1, 10^{-6})$,\n- $(p,\\theta) = (3, \\pi/4)$,\n- $(p,\\theta) = (4, 0.9\\pi)$,\n- $(p,\\theta) = (2, \\pi/2)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of six floating-point numbers in the order specified above. For example, the output format should be exactly like:\n$[ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}, r_{1,6}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}, r_{2,5}, r_{2,6}], \\dots ]$.",
            "solution": "The user has provided a well-defined problem in the field of numerical analysis for partial differential equations. The problem is scientifically grounded, formally specified, and requires the implementation of established numerical methods. There are no contradictions, ambiguities, or unsound premises. Therefore, the problem is valid.\n\n### Step 1: Givens Extraction\n\nThe problem statement provides the following data and definitions:\n1.  **Governing Equation**: The one-dimensional linear advection equation $u_t + a u_x = 0$ with constant advection speed $a  0$.\n2.  **Domain and Mesh**: A periodic domain with a uniform mesh of element size $h$.\n3.  **Numerical Method**: Discontinuous Galerkin (DG) method with local polynomial approximations of degree $p$.\n4.  **Numerical Flux**: Upwind flux.\n5.  **Local Bases**:\n    -   Modal: Orthonormal Legendre polynomials on $[-1,1]$, $\\phi_n(\\xi) = \\sqrt{\\frac{2n+1}{2}}\\,P_n(\\xi)$.\n    -   Nodal: Lagrange polynomials at $p+1$ Gauss-Lobatto-Legendre (GLL) nodes on $[-1,1]$.\n6.  **Coordinate Mapping**: $x = x_j + (h/2)\\xi$ for $\\xi \\in [-1,1]$.\n7.  **Local Solution Expansion**: $u_j(\\xi,t) = \\sum_{i=0}^p u_{j,i}(t) \\phi_i(\\xi)$.\n8.  **Reference Matrices and Vectors**:\n    -   Mass Matrix: $(M_{\\text{ref}})_{i k} = \\int_{-1}^{1} \\phi_i(\\xi)\\,\\phi_k(\\xi)\\,d\\xi$.\n    -   Stiffness Matrix: $(S_{\\text{ref}})_{i k} = \\int_{-1}^{1} \\phi_i'(\\xi)\\,\\phi_k(\\xi)\\,d\\xi$.\n    -   Boundary Vectors: $b_{\\pm,i} = \\phi_i(\\pm 1)$.\n    -   Boundary Bilinear Forms: $B_R = b_+\\,b_+^\\top$, $B_L = b_-\\,b_+^\\top$.\n9.  **Semi-Discrete System**: The evolution of the degrees of freedom $\\boldsymbol{u}_j$ on element $j$ is given by\n    $$\n    \\frac{h}{a}\\,\\dot{\\boldsymbol{u}}_j = 2\\,M_{\\text{ref}}^{-1}\\left(-S_{\\text{ref}} + B_R\\right)\\boldsymbol{u}_j - 2\\,M_{\\text{ref}}^{-1}B_L\\,\\boldsymbol{u}_{j-1}.\n    $$\n10. **Fourier Analysis**:\n    -   Ansatz: $\\boldsymbol{u}_j(t) = \\boldsymbol{v}\\,e^{\\lambda t} e^{\\mathrm{i}\\theta j}$, where $\\theta$ is the dimensionless wavenumber.\n    -   Dimensionless Eigenvalue: $\\mu(\\theta) = \\frac{h}{a}\\,\\lambda(\\theta)$.\n    -   Fourier Symbol Matrix: $\\mathcal{G}(\\theta) = 2\\,M_{\\text{ref}}^{-1}\\left(-S_{\\text{ref}} + B_R - e^{-\\mathrm{i}\\theta} B_L\\right)$. The values $\\mu(\\theta)$ are the eigenvalues of $\\mathcal{G}(\\theta)$.\n11. **Analysis Quantities**:\n    -   Principal Eigenvalue $\\mu_\\star(\\theta)$: The eigenvalue whose imaginary part is closest to $-\\theta$.\n    -   Dispersion Error: $\\mathrm{Im}(\\mu_\\star(\\theta)) + \\theta$.\n    -   Dissipation: $\\mathrm{Re}(\\mu_\\star(\\theta))$.\n    -   Principal Eigenvalue Difference: $|\\mu_{\\star,\\text{modal}}(\\theta) - \\mu_{\\star,\\text{nodal}}(\\theta)|$.\n    -   Bidirectional Hausdorff Distance: The maximum of the two directed distances between the sets of modal and nodal eigenvalues.\n12. **Basis-Specific Implementations**:\n    -   Modal: $M_{\\text{ref}} = I$. $S_{\\text{ref}}$ to be computed using Gauss-Legendre quadrature of sufficient order for exactness.\n    -   Nodal: $M_{\\text{ref}}$ is a diagonal mass matrix from GLL quadrature, $M_{\\text{ref}} = \\mathrm{diag}(w_0,\\dots,w_p)$. Integrals are approximated by GLL quadrature.\n13. **Test Suite**:\n    -   $(p,\\theta) = (1, 10^{-6})$\n    -   $(p,\\theta) = (3, \\pi/4)$\n    -   $(p,\\theta) = (4, 0.9\\pi)$\n    -   $(p,\\theta) = (2, \\pi/2)$\n\n### Step 2: Problem Validation\n\nThe problem is a standard exercise in the numerical analysis of DG methods. All components are well-defined within the established mathematical framework.\n-   **Scientifically Grounded and Objective**: The problem is based on the mathematical theory of numerical methods for PDEs. The concepts of DG methods, basis functions, Fourier stability analysis, dispersion, and dissipation are standard and objective.\n-   **Well-Posed and Complete**: The problem provides all necessary equations, definitions, and data to construct the required matrices and perform the analysis. The tasks are specific and lead to a unique set of computable numbers. The formulation is self-contained.\n-   **No Flaws**: The problem does not violate any scientific principles, is not based on false premises, is formalizable, and is computationally feasible. It is a non-trivial problem requiring careful implementation of several numerical components.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be provided by implementing the specified constructions.\n\n### Method and Implementation\n\nThe solution involves constructing the Fourier symbol matrix $\\mathcal{G}(\\theta)$ for both the modal and nodal bases for each given $(p, \\theta)$ pair. This requires the following steps:\n\n**A. Modal Basis Construction ($\\phi_n(\\xi) = \\sqrt{(2n+1)/2} P_n(\\xi)$)**\n1.  **Mass Matrix ($M_{\\text{ref}}$)**: Due to the orthonormality of the basis, $M_{\\text{ref}}$ is the identity matrix, $I$, of size $(p+1) \\times (p+1)$.\n2.  **Stiffness Matrix ($S_{\\text{ref}}$)**: The entries are $(S_{\\text{ref}})_{ik} = \\int_{-1}^{1} \\phi_i'(\\xi)\\phi_k(\\xi)d\\xi$. The integrand $\\phi_i'(\\xi)\\phi_k(\\xi)$ is a polynomial of degree $(i-1)+k$. The maximum degree for $i,k \\in \\{0, \\dots, p\\}$ is $2p-1$. Gauss-Legendre quadrature with $N_q$ points is exact for polynomials of degree up to $2N_q-1$. Thus, we need $N_q \\ge p$. We will use $N_q = p+2$ points for robustness. The integral is computed as a weighted sum of the integrand evaluated at the quadrature nodes.\n3.  **Boundary Vectors ($b_{\\pm}$)**: The entries are $b_{\\pm,i} = \\phi_i(\\pm 1)$. Since $P_i(1)=1$ and $P_i(-1)=(-1)^i$, these are readily computed as $b_{+,i} = \\sqrt{(2i+1)/2}$ and $b_{-,i} = (-1)^i \\sqrt{(2i+1)/2}$.\n4.  **Boundary Matrices**: $B_R$ and $B_L$ are formed by the outer products $b_+ b_+^T$ and $b_- b_+^T$, respectively.\n\n**B. Nodal Basis Construction (Lagrange Polynomials $\\ell_i(\\xi_j) = \\delta_{ij}$ at GLL nodes)**\n1.  **GLL Nodes and Weights**: For a given degree $p$, the $p+1$ GLL nodes $\\{\\xi_j\\}_{j=0}^p$ are the roots of $(1-\\xi^2)P_p'(\\xi)=0$. These consist of $\\xi_0 = -1$, $\\xi_p=1$, and the $p-1$ roots of $P_p'(\\xi)$, which are also the roots of the Jacobi polynomial $P_{p-1}^{(1,1)}(\\xi)$. The corresponding weights $\\{w_j\\}_{j=0}^p$ are given by the formula $w_j = \\frac{2}{p(p+1)[P_p(\\xi_j)]^2}$.\n2.  **Mass Matrix ($M_{\\text{ref}}$)**: Using GLL quadrature for the mass matrix integral yields a diagonal (\"lumped\") mass matrix with the quadrature weights on the diagonal: $M_{\\text{ref}} = \\mathrm{diag}(w_0, \\dots, w_p)$.\n3.  **Stiffness Matrix ($S_{\\text{ref}}$)**: Applying GLL quadrature to the stiffness matrix integral gives $(S_{\\text{ref}})_{ik} = \\int \\phi_i' \\phi_k d\\xi \\approx \\sum_j w_j \\phi_i'(\\xi_j) \\phi_k(\\xi_j) = w_k \\phi_i'(\\xi_k)$. Let $D$ be the differentiation matrix where $D_{ki} = \\phi_i'(\\xi_k)$ (derivative of $i$-th basis function at $k$-th node). Then $(S_{\\text{ref}})_{ik} = w_k D_{ki}$. In matrix terms, this is $S_{\\text{ref}} = (D^T W)$, where $W=\\mathrm{diag}(w_0, \\dots, w_p)$. The differentiation matrix $D$ can be constructed from its known analytical formula involving Legendre polynomials.\n4.  **Boundary Vectors ($b_{\\pm}$)**: Since $\\xi_0=-1$ and $\\xi_p=1$, the basis property $\\phi_i(\\xi_j)=\\delta_{ij}$ directly gives $b_{+,i} = \\phi_i(1) = \\phi_i(\\xi_p) = \\delta_{ip}$ and $b_{-,i} = \\phi_i(-1) = \\phi_i(\\xi_0) = \\delta_{i0}$. Thus, $b_+$ is the last standard basis vector and $b_-$ is the first.\n5.  **Boundary Matrices**: $B_R = e_p e_p^T$ and $B_L = e_0 e_p^T$.\n\n**C. Analysis**\nFor each basis, once $M_{\\text{ref}}$, $S_{\\text{ref}}$, $B_R$, and $B_L$ are constructed:\n1.  The Fourier symbol matrix $\\mathcal{G}(\\theta)$ is assembled.\n2.  Its eigenvalues $\\mu(\\theta)$ are computed using a standard numerical library function.\n3.  The principal eigenvalue $\\mu_\\star$ is identified by finding the eigenvalue whose imaginary part is closest to the exact dimensionless dispersion relation, $-\\theta$.\n4.  The requested six metrics (dispersion error, dissipation for both bases, principal eigenvalue difference, and Hausdorff distance) are calculated from the computed eigenvalues.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef get_modal_matrices(p):\n    \"\"\"\n    Constructs matrices for the modal basis (orthonormal Legendre polynomials).\n    \"\"\"\n    # Orthonormal Legendre polynomials: phi_n(x) = sqrt((2n+1)/2) * P_n(x)\n    # Mass matrix M_ref is the identity matrix due to orthonormality.\n    M_ref = np.identity(p + 1)\n    \n    # Stiffness matrix S_ref: (S_ref)_ik = integral(phi_i' * phi_k) dx\n    # We use high-order Gauss-Legendre quadrature for exact integration.\n    # Integrand phi_i' * phi_k is a polynomial of degree (i-1) + k.\n    # Max degree is (p-1) + p = 2p-1. We need n_quad points such that 2*n_quad - 1 = 2p - 1.\n    # Using p+2 points is sufficient.\n    n_quad = p + 2\n    xi_q, w_q = np.polynomial.legendre.leggauss(n_quad)\n    \n    S_ref = np.zeros((p + 1, p + 1))\n    \n    phi_vals = np.zeros((p + 1, n_quad))\n    phi_deriv_vals = np.zeros((p + 1, n_quad))\n    \n    for i in range(p + 1):\n        P_i = legendre(i)\n        P_i_deriv = P_i.deriv(1)\n        c_i = np.sqrt((2 * i + 1) / 2.0)\n        phi_vals[i, :] = c_i * P_i(xi_q)\n        phi_deriv_vals[i, :] = c_i * P_i_deriv(xi_q)\n\n    # Compute S_ref using quadrature\n    for i in range(p + 1):\n        for k in range(p + 1):\n            integrand = phi_deriv_vals[i, :] * phi_vals[k, :]\n            S_ref[i, k] = np.sum(w_q * integrand)\n\n    # Boundary vectors b_plus and b_minus\n    b_plus = np.array([np.sqrt((2 * i + 1) / 2.0) for i in range(p + 1)])\n    b_minus = np.array([np.sqrt((2 * i + 1) / 2.0) * (-1)**i for i in range(p + 1)])\n\n    B_R = np.outer(b_plus, b_plus)\n    B_L = np.outer(b_minus, b_plus)\n    \n    return M_ref, S_ref, B_R, B_L\n\ndef get_gll_nodes_weights(p):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre nodes and weights for degree p.\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n    interior_nodes = roots_jacobi(p - 1, 1, 1)[0]\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n    \n    P_p = legendre(p)\n    weights = 2.0 / (p * (p + 1) * P_p(nodes)**2)\n    \n    return nodes, weights\n\ndef get_differentiation_matrix(p, nodes):\n    \"\"\"\n    Computes the differentiation matrix for Lagrange basis at GLL nodes.\n    D_ij = phi_j'(xi_i)\n    \"\"\"\n    N = p + 1\n    D = np.zeros((N, N))\n    P_p = legendre(p)\n    \n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                if i == 0:\n                    D[i, j] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[i, j] = p * (p + 1) / 4.0\n                else:\n                    D[i, j] = 0.0\n            else:\n                D[i, j] = P_p(nodes[i]) / (P_p(nodes[j]) * (nodes[i] - nodes[j]))\n    return D\n\ndef get_nodal_matrices(p):\n    \"\"\"\n    Constructs matrices for the nodal basis (Lagrange at GLL nodes).\n    \"\"\"\n    nodes, weights = get_gll_nodes_weights(p)\n    \n    M_ref = np.diag(weights)\n    \n    D = get_differentiation_matrix(p, nodes) # D_ij = phi_j'(xi_i)\n    \n    # S_ref_ik = integral(phi_i' phi_k) approx sum_j w_j phi_i'(xi_j) phi_k(xi_j)\n    # = w_k phi_i'(xi_k) = w_k D_ki\n    # In matrix form: S_ref = (D.T @ W), where W=diag(weights)\n    S_ref = D.T @ np.diag(weights)\n    \n    B_R = np.zeros((p + 1, p + 1))\n    B_R[p, p] = 1.0\n    \n    B_L = np.zeros((p + 1, p + 1))\n    B_L[0, p] = 1.0\n    \n    return M_ref, S_ref, B_R, B_L\n\ndef bidirectional_hausdorff(A, B):\n    \"\"\"\n    Calculates the bidirectional Hausdorff distance between two sets of numbers.\n    \"\"\"\n    # Reshape for broadcasting\n    A_col = A[:, np.newaxis]\n    B_row = B[np.newaxis, :]\n    \n    dist_mat_abs = np.abs(A_col - B_row)\n    \n    d_A_to_B = np.max(np.min(dist_mat_abs, axis=1))\n    d_B_to_A = np.max(np.min(dist_mat_abs, axis=0))\n    \n    return max(d_A_to_B, d_B_to_A)\n\ndef analyze_basis(p, theta, basis_type):\n    if basis_type == 'modal':\n        M_ref, S_ref, B_R, B_L = get_modal_matrices(p)\n    elif basis_type == 'nodal':\n        M_ref, S_ref, B_R, B_L = get_nodal_matrices(p)\n    else:\n        raise ValueError(\"Unknown basis type\")\n\n    M_inv = np.linalg.inv(M_ref)\n    \n    G = 2 * M_inv @ (-S_ref + B_R - np.exp(-1j * theta) * B_L)\n    \n    eigenvalues = np.linalg.eigvals(G)\n    \n    idx = np.argmin(np.abs(np.imag(eigenvalues) + theta))\n    mu_star = eigenvalues[idx]\n    \n    dispersion_error = np.imag(mu_star) + theta\n    dissipation = np.real(mu_star)\n    \n    return dispersion_error, dissipation, mu_star, eigenvalues\n\ndef solve():\n    test_cases = [\n        (1, 1e-6),\n        (3, np.pi/4),\n        (4, 0.9*np.pi),\n        (2, np.pi/2),\n    ]\n\n    results = []\n    for p, theta in test_cases:\n        disp_err_modal, diss_modal, mu_star_modal, eig_modal = analyze_basis(p, theta, 'modal')\n        disp_err_nodal, diss_nodal, mu_star_nodal, eig_nodal = analyze_basis(p, theta, 'nodal')\n        \n        principal_eig_diff = np.abs(mu_star_modal - mu_star_nodal)\n        hausdorff_dist = bidirectional_hausdorff(eig_modal, eig_nodal)\n        \n        case_results = [\n            disp_err_modal,\n            diss_modal,\n            disp_err_nodal,\n            diss_nodal,\n            principal_eig_diff,\n            hausdorff_dist\n        ]\n        results.append(case_results)\n\n    # Format output as a list of lists strings\n    formatted_results = []\n    for case_res in results:\n        formatted_results.append(f\"[{', '.join(f'{x:.15e}' for x in case_res)}]\")\n    \n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}