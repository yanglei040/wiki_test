{
    "hands_on_practices": [
        {
            "introduction": "To effectively address locking, one must first learn to detect and quantify it. This practice introduces a direct diagnostic for volumetric locking in linear elasticity by examining how well a numerical method conserves volume under hydrostatic pressure. You will implement and compare a standard displacement-based formulation with a stabilized mixed-field formulation, observing their behavior in the nearly incompressible limit where the bulk modulus $\\kappa$ is large. By computing the element-wise divergence of the displacement field, $\\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$, you will gain a tangible measure of how a poorly chosen finite element fails to satisfy the incompressibility constraint, a foundational skill for diagnosing numerical pathologies .",
            "id": "3418041",
            "problem": "Consider the plane-strain Linear Elasticity boundary value problem on the unit square domain $[0,1]\\times[0,1]$, with outward unit normal $\\boldsymbol{n}$, under uniform hydrostatic traction $-p_0\\,\\boldsymbol{n}$ applied on the entire boundary. The strong form consists of the equilibrium equations and constitutive relations\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{in }[0,1]^2,\\qquad \\boldsymbol{\\sigma}=2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I},\n$$\nwith small-strain tensor $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$, shear modulus $\\mu>0$, Lamé parameter $\\lambda\\ge 0$, bulk modulus $\\kappa=\\lambda+\\tfrac{2\\mu}{3}$, and Neumann boundary condition $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$ on $\\partial([0,1]^2)$. Assume nondimensional units (no physical unit conversion is required), and set $\\mu=1$.\n\nIn the continuous problem, under uniform hydrostatic load, the volumetric strain $\\nabla\\cdot\\boldsymbol{u}$ is spatially uniform and equals $-\\tfrac{p_0}{\\kappa}$, which tends to $0$ as $\\kappa\\to\\infty$. In numerical discretizations, however, displacement-only formulations can exhibit volumetric locking: the discrete divergence $\\nabla\\cdot\\boldsymbol{u}_h$ fails to approach $0$ as $\\kappa\\to\\infty$ at fixed mesh size, while appropriate mixed formulations enforce the near-incompressibility constraint more robustly.\n\nYour task is to implement two Finite Element Method (FEM) discretizations on a structured quadrilateral mesh with $n\\times n$ bilinear ($\\mathsf{Q}_1$) elements:\n- A displacement-only formulation using the standard symmetric bilinear form for isotropic elasticity in plane strain. In Voigt notation with engineering shear strain $\\gamma_{xy}=2\\varepsilon_{xy}$, the bilinear form uses the matrix with entries $D_{11}=\\lambda+2\\mu$, $D_{12}=\\lambda$, and $D_{33}=\\mu$.\n- A stabilized mixed displacement-pressure formulation with equal-order bilinear ($\\mathsf{Q}_1$) discrete spaces for both displacement and pressure. The weak form splits into the deviatoric part and a constraint on the divergence:\n$$\n\\text{find }(\\boldsymbol{u}_h,p_h)\\text{ s.t.}\\quad\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s,\n$$\nfor all test pairs $(\\boldsymbol{v}_h,q_h)$, where $h=1/n$ and $\\gamma>0$ is a small stabilization parameter. The deviatoric-only stiffness uses $D_{11}=2\\mu$, $D_{12}=0$, $D_{33}=\\mu$.\n\nFor both formulations, apply hydrostatic Neumann traction $-p_0\\,\\boldsymbol{n}$ on the entire boundary via line integrals, and remove rigid body modes by constraining the displacement $\\boldsymbol{u}_h=\\boldsymbol{0}$ at the bottom-left corner node and the vertical displacement component at the bottom-right corner node to be zero. In the mixed formulation, do not constrain the pressure field.\n\nDefine the diagnostic quantity for locking based on local mass conservation: for each element $K$ of the mesh, compute the element-wise volumetric change\n$$\nI_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x,\n$$\nusing $2\\times 2$ Gauss quadrature. For a perfectly incompressible response under hydrostatic load, $I_K$ should be $0$ for all $K$. A method is said to lock if, as $\\kappa\\to\\infty$, the set $\\{I_K\\}$ fails to approach $0$ uniformly at fixed $h$, while a method is non-locking if $I_K$ decays like $\\mathcal{O}(h)$ with mesh refinement at large $\\kappa$.\n\nImplement both discretizations, assemble and solve the linear systems using sparse linear algebra, and compute the diagnostic aggregate\n$$\nA = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|,\n$$\nwhere $N_{\\mathrm{el}}=n^2$ is the number of elements. Use nondimensional numbers and express $A$ as a floating-point number.\n\nYour program must evaluate the following test suite:\n- Test case 1: displacement-only, $n=4$, $\\kappa=10^6$, $p_0=1$.\n- Test case 2: mixed, $n=4$, $\\kappa=10^6$, $p_0=1$, with stabilization parameter $\\gamma=10^{-3}$.\n- Test case 3: mixed, $n=8$, $\\kappa=10^6$, $p_0=1$, with stabilization parameter $\\gamma=10^{-3}$.\n- Test case 4: displacement-only, $n=8$, $\\kappa=10^6$, $p_0=1$.\n- Test case 5: displacement-only, $n=4$, $\\kappa=10^3$, $p_0=1$.\n\nFor each test case, compute and return the aggregate $A$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), with each result formatted as a standard Python float.",
            "solution": "The user's request is a valid computational mechanics problem. It requires the implementation of two distinct Finite Element Method (FEM) formulations for a plane-strain linear elasticity problem to investigate the phenomenon of volumetric locking. The problem is scientifically grounded, well-posed, and all necessary parameters and conditions are provided for a unique solution.\n\n### 1. Problem Formulation\n\nThe problem is defined on the unit square domain $\\Omega = [0,1]^2$. The governing equations are those of linear elasticity:\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{in }\\Omega\n$$\nThe stress tensor $\\boldsymbol{\\sigma}$ is related to the displacement field $\\boldsymbol{u}$ via the constitutive law for an isotropic material:\n$$\n\\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I}\n$$\nwhere $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$ is the small-strain tensor, $\\mu$ is the shear modulus, and $\\lambda$ is the first Lamé parameter. The material is subjected to a uniform hydrostatic pressure $p_0$ on its entire boundary $\\partial\\Omega$, which corresponds to a Neumann boundary condition $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$.\n\nWe are given $\\mu=1$ and the bulk modulus $\\kappa = \\lambda + \\frac{2\\mu}{3}$. This allows us to express $\\lambda$ in terms of the given $\\kappa$ and $\\mu$: $\\lambda = \\kappa - \\frac{2}{3}$. The problem considers the nearly incompressible limit, where $\\kappa \\to \\infty$, which implies $\\lambda \\to \\infty$.\n\nTo ensure a unique solution, rigid body motions (two translations and one rotation in 2D) must be suppressed. This is achieved by imposing Dirichlet boundary conditions: $\\boldsymbol{u}(0,0) = \\boldsymbol{0}$ and $u_y(1,0) = 0$.\n\n### 2. Finite Element Discretization\n\nThe domain is discretized into a structured mesh of $n \\times n$ quadrilateral elements. Bilinear shape functions ($\\mathsf{Q}_1$) are used for all field variables. For a generic element $K$, the displacement field is interpolated as $\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\boldsymbol{d}_i$, where $N_i$ are the shape functions and $\\boldsymbol{d}_i$ are the nodal displacement vectors.\n\n#### 2.1. Formulation 1: Displacement-Only\n\nThe standard weak form derived from the principle of virtual work is: find $\\boldsymbol{u}_h$ such that for all admissible virtual displacements $\\boldsymbol{v}_h$:\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}(\\boldsymbol{u}_h) : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h) \\, \\mathrm{d}x = \\int_{\\partial\\Omega} (-p_0\\boldsymbol{n}) \\cdot \\boldsymbol{v}_h \\, \\mathrm{d}s\n$$\nThis leads to a linear system of equations $[K]\\{U\\} = \\{F\\}$, where $\\{U\\}$ is the global vector of nodal displacements. The element stiffness matrix $K_e$ is computed by integrating over the element domain:\n$$\nK_e = \\int_{K} B^T D B \\, \\mathrm{d}x\n$$\nwhere $B$ is the discrete strain-displacement matrix and $D$ is the material constitutive matrix for plane strain. In Voigt notation for stresses $\\{\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}\\}$ and engineering strains $\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$, the $D$ matrix is:\n$$\nD = \\begin{bmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}\n$$\nThe force vector $\\{F\\}$ is assembled from line integrals over the boundary elements.\n\n#### 2.2. Formulation 2: Stabilized Mixed Displacement-Pressure (u-p)\n\nThis formulation introduces an independent pressure field $p_h$ to enforce the incompressibility constraint. The displacement and pressure fields are approximated using the same bilinear ($\\mathsf{Q}_1$) basis. Since this choice does not satisfy the Ladyzhenskaya-Babuška-Brezzi (LBB) inf-sup condition, a stabilization term is added. The specified weak form is: find $(\\boldsymbol{u}_h, p_h)$ such that for all test functions $(\\boldsymbol{v}_h, q_h)$:\n$$\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s\n$$\nThis leads to a larger, saddle-point linear system of the form:\n$$\n\\begin{bmatrix} K_{uu} & -G^T \\\\ G & -\\frac{1}{\\kappa}M_p + K_{stab} \\end{bmatrix}\n\\begin{Bmatrix} U \\\\ P \\end{Bmatrix}\n= \\begin{Bmatrix} F_u \\\\ 0 \\end{Bmatrix}\n$$\nThe matrix blocks correspond to:\n- $K_{uu}$: Stiffness from the $2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)$ term.\n- $G$: Gradient/divergence coupling matrix from $\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$.\n- $M_p$: Pressure mass matrix from $\\int p_h\\,q_h\\,\\mathrm{d}x$.\n- $K_{stab}$: Pressure stabilization matrix (a scaled Laplacian) from $\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x$.\n\n### 3. Implementation Details\n\n- **Quadrature**: All element integrations (for stiffness matrices, mass matrices, and force vectors) are performed numerically using $2 \\times 2$ Gauss quadrature on the reference element $[-1,1]^2$. Line integrals for the boundary traction are evaluated using $2$-point one-dimensional Gauss quadrature.\n- **Assembly**: Element-level matrices and vectors are computed and then assembled into global sparse matrices (`scipy.sparse.lil_matrix`) and vectors.\n- **Linear Solve**: The Dirichlet constraints are applied by partitioning the system into free and fixed degrees of freedom. The resulting reduced system for the free DOFs is solved using `scipy.sparse.linalg.spsolve`.\n- **Diagnostic Quantity**: After solving for the displacement field $\\boldsymbol{u}_h$, the element-wise volumetric change $I_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$ is computed for each element $K$ using $2 \\times 2$ Gauss quadrature. The final diagnostic is the average of the absolute values of these changes, $A = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|$.\n\nThe displacement-only formulation is expected to exhibit locking, where $A$ remains large as $\\kappa$ increases for a fixed mesh. The mixed formulation is designed to mitigate this, and $A$ should be significantly smaller and show better convergence properties.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_quadrature_2d():\n    \"\"\"Returns 2x2 Gauss quadrature points and weights on [-1,1]^2.\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    quad_points = np.array([(p, q) for q in points for p in points])\n    quad_weights = np.array([w * v for v in weights for w in weights])\n    return quad_points, quad_weights\n\ndef get_quadrature_1d():\n    \"\"\"Returns 2-point Gauss quadrature points and weights on [-1,1].\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    return points, weights\n\ndef get_shape_functions(xi, eta):\n    \"\"\"Returns Q1 shape functions and their gradients on the reference element.\"\"\"\n    N = 0.25 * np.array([(1.0 - xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 + eta),\n                         (1.0 - xi) * (1.0 + eta)])\n    dN_dxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dN_deta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef run_fem_analysis(formulation, n, kappa, p0, gamma=0.0, mu=1.0):\n    \"\"\"Main FEM analysis function for both displacement-only and mixed formulations.\"\"\"\n    # 1. Mesh Generation\n    h = 1.0 / n\n    num_nodes = (n + 1)**2\n    num_elems = n**2\n    nodes = np.array([[i * h, j * h] for j in range(n + 1) for i in range(n + 1)], dtype=float)\n    elements = np.array([[j * (n + 1) + i, j * (n + 1) + i + 1, (j + 1) * (n + 1) + i + 1, (j + 1) * (n + 1) + i]\n                         for j in range(n) for i in range(n)], dtype=int)\n\n    # 2. DOF and Matrix Setup\n    num_u_dofs = 2 * num_nodes\n    if formulation == 'displacement':\n        total_dofs = num_u_dofs\n    elif formulation == 'mixed':\n        total_dofs = 3 * num_nodes\n    else:\n        raise ValueError(\"Unknown formulation\")\n\n    K_global = lil_matrix((total_dofs, total_dofs))\n    F_global = np.zeros(total_dofs)\n\n    # 3. Material and quadrature setup\n    if formulation == 'displacement':\n        lam = kappa - 2.0 * mu / 3.0\n        D = np.array([[lam + 2 * mu, lam, 0.0],\n                      [lam, lam + 2 * mu, 0.0],\n                      [0.0, 0.0, mu]])\n    else:  # mixed\n        D_dev = np.array([[2 * mu, 0.0, 0.0],\n                          [0.0, 2 * mu, 0.0],\n                          [0.0, 0.0, mu]])\n    \n    quad_points_2d, quad_weights_2d = get_quadrature_2d()\n\n    # 4. Assembly loop over elements\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n\n        # Displacement-only formulation assembly\n        if formulation == 'displacement':\n            Ke = np.zeros((8, 8))\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Ke += qw * (B.T @ D @ B) * detJ\n            K_global[np.ix_(u_dofs, u_dofs)] += Ke\n\n        # Mixed formulation assembly\n        elif formulation == 'mixed':\n            p_dofs = el_nodes_indices\n            global_p_dofs = num_u_dofs + p_dofs\n            \n            Kuu_e = np.zeros((8, 8))\n            G_e = np.zeros((4, 8))\n            Mp_e = np.zeros((4, 4))\n            Ks_e = np.zeros((4, 4))\n\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                N, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Kuu_e += qw * (B.T @ D_dev @ B) * detJ\n                \n                for i in range(4):\n                    for j in range(4):\n                        G_e[i, 2*j]   += qw * N[i] * dN_dxy[0, j] * detJ\n                        G_e[i, 2*j+1] += qw * N[i] * dN_dxy[1, j] * detJ\n                \n                Mp_e += qw * np.outer(N, N) * detJ\n                Ks_e += qw * (dN_dxy.T @ dN_dxy) * detJ\n\n            K_global[np.ix_(u_dofs, u_dofs)] += Kuu_e\n            K_global[np.ix_(u_dofs, global_p_dofs)] -= G_e.T\n            K_global[np.ix_(global_p_dofs, u_dofs)] += G_e\n            \n            pp_block = (-1.0/kappa) * Mp_e + gamma * (h**2) * Ks_e\n            K_global[np.ix_(global_p_dofs, global_p_dofs)] += pp_block\n\n    # 5. Assemble Force Vector from Neumann BC\n    F_u = np.zeros(num_u_dofs)\n    q1d_pts, q1d_wts = get_quadrature_1d()\n\n    for j in range(n):\n        for i in range(n):\n            el_nodes = elements[j * n + i]\n            el_dofs = np.ravel([[2 * k, 2 * k + 1] for k in el_nodes])\n            \n            # Bottom edge (y=0)\n            if j == 0:\n                load = np.array([0., p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, -1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Top edge (y=1)\n            if j == n - 1:\n                load = np.array([0., -p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, 1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Left edge (x=0)\n            if i == 0:\n                load = np.array([p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(-1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Right edge (x=1)\n            if i == n - 1:\n                load = np.array([-p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n    F_global[:num_u_dofs] = F_u\n\n    # 6. Apply Displacement Constraints and Solve\n    fixed_dofs = np.array([0, 1, 2 * n + 1])\n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n\n    K_free = K_global[np.ix_(free_dofs, free_dofs)].tocsr()\n    F_free = F_global[free_dofs]\n\n    Sol_free = spsolve(K_free, F_free)\n\n    Sol = np.zeros(total_dofs)\n    Sol[free_dofs] = Sol_free\n    U = Sol[:num_u_dofs]\n\n    # 7. Post-processing: Compute Diagnostic A\n    total_vol_change_abs_sum = 0.0\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        el_u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n        el_U = U[el_u_dofs]\n        \n        I_K = 0.0\n        for qp, qw in zip(quad_points_2d, quad_weights_2d):\n            _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n            J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n            detJ = np.linalg.det(J)\n            dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n            \n            div_u_h = 0.0\n            for i in range(4):\n                div_u_h += dN_dxy[0, i] * el_U[2*i] + dN_dxy[1, i] * el_U[2*i+1]\n            I_K += qw * div_u_h * detJ\n        \n        total_vol_change_abs_sum += np.abs(I_K)\n        \n    A = total_vol_change_abs_sum / num_elems\n    return A\n\ndef solve():\n    test_cases = [\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'mixed', 'n': 4, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'mixed', 'n': 8, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'displacement', 'n': 8, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e3, 'p0': 1.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_fem_analysis(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once locking is identified, a common and computationally efficient remedy is selective reduced integration, where the stiff volumetric part of the strain energy is integrated with fewer quadrature points than the deviatoric part. This exercise challenges you to implement this technique and critically evaluate its consequences . While reduced integration can successfully alleviate locking, it can also destabilize the element stiffness matrix by failing to detect certain deformation patterns, leading to spurious \"hourglass\" modes. Through a spectral analysis of the stiffness matrix, you will explore the crucial trade-off between accuracy and stability, a central theme in the design of robust finite elements.",
            "id": "3418037",
            "problem": "Consider two-dimensional linear elasticity in plane strain on the unit square domain with isotropic material parameters Young’s modulus $E$ and Poisson’s ratio $\\nu$, using a standard $Q_1$ (bilinear) finite element discretization on a structured rectangular mesh of $N_x \\times N_y$ elements. The governing equations are derived from the principle of minimum potential energy: find the displacement field $\\boldsymbol{u}$ that minimizes the total potential energy\n$$\n\\Pi(\\boldsymbol{u}) = \\int_{\\Omega} \\left( \\mu \\, \\boldsymbol{\\epsilon}_{\\text{dev}} : \\boldsymbol{\\epsilon}_{\\text{dev}} + \\tfrac{1}{2} \\kappa \\, (\\operatorname{tr}\\boldsymbol{\\epsilon})^2 \\right)\\, \\mathrm{d}\\Omega \\;-\\; \\int_{\\Omega} \\boldsymbol{b}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Omega \\;-\\; \\int_{\\Gamma_N} \\boldsymbol{t}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Gamma,\n$$\nwhere $\\boldsymbol{\\epsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$ is the small strain tensor, $\\boldsymbol{\\epsilon}_{\\text{dev}} = \\boldsymbol{\\epsilon} - \\tfrac{1}{3}(\\operatorname{tr}\\boldsymbol{\\epsilon})\\boldsymbol{I}$ is its deviatoric part, $\\mu = \\dfrac{E}{2(1+\\nu)}$ is the shear modulus and $\\kappa = \\lambda + \\dfrac{2}{3}\\mu$ is the bulk modulus with Lamé parameter $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$. In a displacement-based $Q_1$ discretization for plane strain, the constitutive matrix in Voigt form with engineering shear strain $\\gamma_{xy}$ is\n$$\n\\boldsymbol{C} = \\begin{bmatrix} \\lambda + 2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda + 2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}.\n$$\nA common quadrature-based technique to mitigate volumetric locking as $\\nu \\to 0.5$ is selective reduced integration, which integrates the deviatoric and volumetric contributions with different quadrature rules. In particular, define\n$$\n\\boldsymbol{C}_{\\mu} = \\mu \\,\\operatorname{diag}(2,2,1), \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\n$$\nso that $\\boldsymbol{C} = \\boldsymbol{C}_{\\mu} + \\boldsymbol{C}_{\\lambda}$. The element stiffness contribution is\n$$\n\\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega,\n$$\nwhere $\\boldsymbol{B}$ is the standard $Q_1$ strain-displacement matrix in plane strain with engineering shear $\\gamma_{xy} = \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x}$.\n\nYour task is to perform a spectral analysis of the assembled discrete stiffness matrix to evaluate two claims about locking phenomena in $Q_1$ elements as $\\nu \\to 0.5$:\n\n- Claim A: Selective reduced integration, defined by integrating the deviatoric part with full $2\\times 2$ Gauss quadrature and the volumetric part with reduced $1\\times 1$ Gauss quadrature, eliminates volumetric locking in the sense that the displacement response under a fixed load remains insensitive to $\\nu$ approaching $0.5$.\n\n- Claim B: Selective reduced integration does not introduce spurious zero-energy modes (hourglass modes), i.e., the discrete stiffness matrix does not acquire additional zero eigenvalues beyond those removed by essential boundary conditions.\n\nYou must design and implement a program that assembles the global stiffness matrix and examines its spectrum under three quadrature schemes:\n\n- Scheme F (full): integrate both $\\boldsymbol{C}_{\\mu}$ and $\\boldsymbol{C}_{\\lambda}$ with the $2\\times 2$ Gauss rule on the reference square, with abscissae $\\pm 1/\\sqrt{3}$ and weights $1$, yielding four points and total weight $4$.\n\n- Scheme S (selective reduced integration): integrate $\\boldsymbol{C}_{\\mu}$ with the $2\\times 2$ Gauss rule and $\\boldsymbol{C}_{\\lambda}$ with the $1\\times 1$ Gauss rule at $(0,0)$ with weight $4$.\n\n- Scheme R (fully reduced): integrate both $\\boldsymbol{C}_{\\mu}$ and $\\boldsymbol{C}_{\\lambda}$ with the $1\\times 1$ Gauss rule.\n\nUse a structured $Q_1$ mesh on $\\Omega = [0,1]\\times[0,1]$ with $N_x = 8$, $N_y = 8$, and unit thickness. Impose homogeneous essential boundary conditions by clamping the left boundary $x=0$ with $u = 0$ and $v = 0$. For the loading test, apply a uniform body force per unit area $\\boldsymbol{b} = (1,0)$ and no Neumann traction, and assemble the consistent nodal force vector using the $2\\times 2$ Gauss rule. Use $E=1$ and Poisson ratios $\\nu \\in \\{0.3, 0.49, 0.4999\\}$.\n\nDefine the following quantitative tests:\n\n- Spectral zero-mode test at $\\nu = 0.4999$: For schemes S and R, construct the clamped stiffness matrix and compute all eigenvalues. Let $\\lambda_{\\max}$ be the largest eigenvalue. Count the number of eigenvalues strictly less than $\\tau \\, \\lambda_{\\max}$ with $\\tau = 10^{-8}$, denoted $n_{\\text{near-}0}$. Report $n_{\\text{near-}0}$ for scheme S and scheme R. Also report the smallest eigenvalue for scheme S, denoted $\\lambda_{\\min}^{(S)}$.\n\n- Locking sensitivity test under body force: For schemes F and S, solve the linear system for the clamped problem with the body force loading, and compute the Euclidean norm of the displacement vector, $\\|\\boldsymbol{u}\\|_2$. Let $r_F = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ and $r_S = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ be the ratios for schemes F and S, respectively. A value of $r$ substantially less than $1$ is indicative of locking, whereas a value closer to $1$ indicates mitigation of locking.\n\nYour program must:\n\n- Assemble the global stiffness matrices using the specified quadrature decompositions for schemes F, S, and R.\n\n- Apply the boundary conditions by eliminating the clamped degrees of freedom and constructing the reduced system.\n\n- Compute the complete spectrum of the reduced stiffness matrices where required for the spectral tests.\n\n- Solve the reduced linear systems for the loading test using a direct linear solver.\n\nTest suite and output specification:\n\n- Use $N_x = 8$, $N_y = 8$, $E = 1$, and $\\nu \\in \\{0.3, 0.49, 0.4999\\}$.\n\n- Body force $\\boldsymbol{b} = (1,0)$ per unit area.\n\n- Spectral zero-mode test at $\\nu = 0.4999$ with tolerance factor $\\tau = 10^{-8}$.\n\n- The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n  1. $\\lambda_{\\min}^{(S)}$ at $\\nu = 0.4999$ (float).\n  2. $n_{\\text{near-}0}$ for scheme S at $\\nu = 0.4999$ (integer).\n  3. $n_{\\text{near-}0}$ for scheme R at $\\nu = 0.4999$ (integer).\n  4. $r_F$ (float).\n  5. $r_S$ (float).\n\nAll angles, where relevant, are in radians; however, no angle quantities are required in this problem. No physical units are required in the final answers because $E$ and the geometry are nondimensionalized. The output must be in the exact list format described, e.g., $[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$.",
            "solution": "The user's problem statement has been analyzed and validated. It constitutes a well-posed, scientifically grounded computational task within the field of finite element analysis of partial differential equations. The problem is self-contained, with all necessary physical parameters, geometric specifications, boundary conditions, and numerical procedures clearly defined. The objectives are quantitative and unambiguous. Therefore, the problem is deemed valid, and a full solution is provided below.\n\nThe core of this problem is to implement a two-dimensional finite element model for linear elasticity under plane strain conditions. The goal is to investigate numerical locking, a pathology common in low-order elements when dealing with near-incompressible materials (i.e., Poisson's ratio $\\nu \\to 0.5$). The investigation centers on comparing three different numerical quadrature schemes for computing the element stiffness matrix $\\boldsymbol{K}^{(e)}$ and analyzing their impact on the spectrum of the global stiffness matrix and the solution's sensitivity to $\\nu$.\n\nThe methodology involves the following steps:\n1.  **Discretization and Formulation**: The unit square domain $\\Omega = [0,1]^2$ is discretized using a structured mesh of $N_x \\times N_y = 8 \\times 8$ bilinear quadrilateral ($Q_1$) elements. Each node has two degrees of freedom (DOFs), corresponding to horizontal ($u$) and vertical ($v$) displacements. The total number of nodes is $(N_x+1)(N_y+1) = 81$, yielding $162$ DOFs.\n\n2.  **Element-Level Computations**: For each $Q_1$ element, we compute the element stiffness matrix $\\boldsymbol{K}^{(e)}$ and the consistent nodal force vector $\\boldsymbol{f}^{(e)}$.\n    The element stiffness matrix is given by the integral over the element domain $\\Omega_e$:\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    where $\\boldsymbol{B}$ is the strain-displacement matrix that relates nodal displacements to strains, and $\\boldsymbol{C}$ is the constitutive matrix for plane strain. The integral is evaluated numerically using Gauss quadrature on a reference element $[-1,1] \\times [-1,1]$. The Jacobian of the transformation from reference to physical coordinates, $\\det(\\boldsymbol{J})$, must be included in the integrand. For a rectangular element of size $h_x \\times h_y$, $\\det(\\boldsymbol{J}) = h_x h_y / 4$.\n\n    The problem specifies a decomposition of $\\boldsymbol{C}$ into a deviatoric part ($\\boldsymbol{C}_\\mu$) and a volumetric part ($\\boldsymbol{C}_\\lambda$), where $\\mu = \\frac{E}{2(1+\\nu)}$ and $\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ are the Lamé parameters.\n    $$\n    \\boldsymbol{C}_{\\mu} = \\mu \\,\\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}, \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}\n    $$\n    The element stiffness is then computed as two separate integrals, each with a potentially different quadrature rule:\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    The three schemes are:\n    *   **Scheme F (Full)**: $2 \\times 2$ Gauss quadrature for both terms.\n    *   **Scheme S (Selective Reduced)**: $2 \\times 2$ for the $\\boldsymbol{C}_\\mu$ term, $1 \\times 1$ for the $\\boldsymbol{C}_\\lambda$ term.\n    *   **Scheme R (Fully Reduced)**: $1 \\times 1$ for both terms.\n\n    The element force vector due to a body force $\\boldsymbol{b}$ is:\n    $$\n    \\boldsymbol{f}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{N}^\\top \\boldsymbol{b} \\, \\mathrm{d}\\Omega\n    $$\n    where $\\boldsymbol{N}$ is the matrix of shape functions. This integral is computed using the $2 \\times 2$ Gauss rule.\n\n3.  **Assembly and Boundary Conditions**: The element matrices and vectors are assembled into a global system of linear equations $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{f}$. Homogeneous essential boundary conditions ($u=v=0$) are applied to all nodes on the left boundary ($x=0$). This is accomplished by identifying the DOFs corresponding to these nodes and eliminating the corresponding rows and columns from the global system, resulting in a reduced system $\\boldsymbol{K}_{\\text{red}}\\boldsymbol{d}_{\\text{red}} = \\boldsymbol{f}_{\\text{red}}$.\n\n4.  **Spectral Analysis**: For Schemes S and R at $\\nu=0.4999$, the eigenvalues of the reduced stiffness matrix $\\boldsymbol{K}_{\\text{red}}$ are computed. Spurious zero-energy modes (hourglass modes) manifest as zero or near-zero eigenvalues in $\\boldsymbol{K}_{\\text{red}}$. We count the number of eigenvalues $\\lambda_i$ such that $\\lambda_i < \\tau \\lambda_{\\max}$, where $\\tau=10^{-8}$ is a small tolerance. For a stable scheme, this count should be zero, and the minimum eigenvalue $\\lambda_{\\min}$ should be strictly positive.\n\n5.  **Locking Analysis**: For Schemes F and S, the reduced linear system is solved for the displacement vector $\\boldsymbol{d}_{\\text{red}}$ at $\\nu=0.3$ and $\\nu=0.4999$. Volumetric locking is characterized by an artificially stiff response as $\\nu \\to 0.5$. This is quantified by the ratio $r = \\|\\boldsymbol{d}\\|_2(\\nu=0.4999) / \\|\\boldsymbol{d}\\|_2(\\nu=0.3)$, where $\\|\\cdot\\|_2$ is the Euclidean norm of the full displacement vector. A ratio significantly less than $1$ indicates locking, while a ratio close to $1$ indicates that the scheme successfully mitigates locking.\n\nThe implementation encapsulates these steps into a single Python script. Helper functions are defined for element-level computations and system assembly. The main part of the script orchestrates the required analyses for the different schemes and Poisson's ratios and formats the final results as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Performs a spectral and locking analysis of Q1 finite elements for plane strain elasticity.\n    \"\"\"\n    # ------------------\n    # --- Parameters ---\n    # ------------------\n    Nx, Ny = 8, 8\n    E = 1.0\n    nu_spectral = 0.4999\n    nu_locking = [0.3, 0.4999]\n    tau = 1e-8\n    body_force_vec = np.array([1.0, 0.0])\n\n    # ------------------------\n    # --- Mesh and DOF Setup ---\n    # ------------------------\n    hx, hy = 1.0 / Nx, 1.0 / Ny\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    # -------------------------------------\n    # --- Boundary Condition Definition ---\n    # -------------------------------------\n    clamped_node_indices = [iy * num_nodes_x for iy in range(num_nodes_y + 1)]\n    clamped_dofs = []\n    for node_idx in clamped_node_indices:\n        clamped_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, clamped_dofs, assume_unique=True)\n\n    # ------------------------------\n    # --- FEM Helper Functions ---\n    # ------------------------------\n    # Quadrature points and weights for reference element [-1, 1]^2\n    p = 1.0 / np.sqrt(3.0)\n    gp_2x2 = [(-p, -p, 1.0), (p, -p, 1.0), (p, p, 1.0), (-p, p, 1.0)]\n    gp_1x1 = [(0.0, 0.0, 4.0)]\n\n    def get_B_matrix(xi, eta):\n        # Derivatives of shape functions w.r.t. xi, eta for nodes 0-3 (CCW from bottom-left)\n        dN_d_xi_eta = 0.25 * np.array([\n            [-(1.0 - eta), -(1.0 - xi)],\n            [ (1.0 - eta), -(1.0 + xi)],\n            [ (1.0 + eta),  (1.0 + xi)],\n            [-(1.0 + eta),  (1.0 - xi)]\n        ])\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            dNi_dx = dN_d_xi_eta[i, 0] * 2.0 / hx\n            dNi_dy = dN_d_xi_eta[i, 1] * 2.0 / hy\n            \n            B[0, 2 * i]     = dNi_dx\n            B[1, 2 * i + 1] = dNi_dy\n            B[2, 2 * i]     = dNi_dy\n            B[2, 2 * i + 1] = dNi_dx\n        return B\n\n    def get_element_matrices(nu, scheme):\n        # Material properties\n        mu = E / (2.0 * (1.0 + nu))\n        lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        \n        C_mu = mu * np.array([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]])\n        C_lambda = lmbda * np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0]])\n\n        quad_map = {'F': (gp_2x2, gp_2x2), 'S': (gp_2x2, gp_1x1), 'R': (gp_1x1, gp_1x1)}\n        quad_mu, quad_lambda = quad_map[scheme]\n        \n        detJ = (hx * hy) / 4.0\n        \n        Ke_mu = np.zeros((8, 8))\n        for xi, eta, w in quad_mu:\n            B = get_B_matrix(xi, eta)\n            Ke_mu += B.T @ C_mu @ B * w * detJ\n\n        Ke_lambda = np.zeros((8, 8))\n        for xi, eta, w in quad_lambda:\n            B = get_B_matrix(xi, eta)\n            Ke_lambda += B.T @ C_lambda @ B * w * detJ\n        \n        Ke = Ke_mu + Ke_lambda\n        \n        fe = np.zeros(8)\n        # Force vector is always computed with 2x2 quadrature\n        for xi, eta, w in gp_2x2:\n            N_vals = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n            N_matrix = np.zeros((2, 8))\n            N_matrix[0, 0::2] = N_vals\n            N_matrix[1, 1::2] = N_vals\n            fe += N_matrix.T @ body_force_vec * w * detJ\n        \n        return Ke, fe\n\n    def assemble(nu, scheme):\n        K_global = np.zeros((num_dofs, num_dofs))\n        F_global = np.zeros(num_dofs)\n        \n        # Optimization: Ke and fe are the same for all elements in a structured mesh\n        Ke, fe = get_element_matrices(nu, scheme)\n        \n        for ey in range(Ny):\n            for ex in range(Nx):\n                node_indices = [\n                    ey * num_nodes_x + ex,\n                    ey * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex\n                ]\n                \n                dof_map = np.empty(8, dtype=int)\n                for i in range(4):\n                    dof_map[2*i]   = 2 * node_indices[i]\n                    dof_map[2*i+1] = 2 * node_indices[i] + 1\n                \n                ix_ = np.ix_(dof_map, dof_map)\n                K_global[ix_] += Ke\n                F_global[dof_map] += fe\n\n        return K_global, F_global\n\n    # -----------------------\n    # --- Main Analysis ---\n    # -----------------------\n\n    # --- Part 1: Spectral Zero-Mode Test (nu = 0.4999) ---\n    \n    # Scheme S\n    K_global_S, _ = assemble(nu=nu_spectral, scheme='S')\n    K_reduced_S = K_global_S[np.ix_(free_dofs, free_dofs)]\n    eigvals_S = linalg.eigh(K_reduced_S, eigvals_only=True)\n    lambda_min_S = eigvals_S[0]\n    n_near_0_S = np.sum(eigvals_S < tau * eigvals_S[-1])\n\n    # Scheme R\n    K_global_R, _ = assemble(nu=nu_spectral, scheme='R')\n    K_reduced_R = K_global_R[np.ix_(free_dofs, free_dofs)]\n    eigvals_R = linalg.eigh(K_reduced_R, eigvals_only=True)\n    n_near_0_R = np.sum(eigvals_R < tau * eigvals_R[-1])\n\n    # --- Part 2: Locking Sensitivity Test ---\n    u_norms = {}\n    for scheme in ['F', 'S']:\n        for nu in nu_locking:\n            K_global, F_global = assemble(nu=nu, scheme=scheme)\n\n            K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n            F_reduced = F_global[free_dofs]\n            \n            u_reduced = linalg.solve(K_reduced, F_reduced, assume_a='sym')\n            \n            u_full = np.zeros(num_dofs)\n            u_full[free_dofs] = u_reduced\n            u_norm = linalg.norm(u_full)\n            u_norms[(scheme, nu)] = u_norm\n            \n    r_F = u_norms[('F', 0.4999)] / u_norms[('F', 0.3)]\n    r_S = u_norms[('S', 0.4999)] / u_norms[('S', 0.3)]\n\n    # --- Part 3: Format and Print Output ---\n    results = [lambda_min_S, int(n_near_0_S), int(n_near_0_R), r_F, r_S]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Locking phenomena become particularly insidious in models with heterogeneous materials, where an incompressibility constraint in one region can non-physically stiffen the entire domain. This practice guides you through a numerical experiment to demonstrate this \"constraint pollution\" in a standard displacement formulation. By comparing this with a mixed method that uses a local Lagrange multiplier to enforce the incompressibility constraint only where needed, you will understand the non-local nature of locking. This exercise  illuminates the limitations of simple penalty methods and highlights the power of mixed formulations to model complex, multi-material systems accurately.",
            "id": "3418018",
            "problem": "You are asked to design and implement a numerical experiment that exposes locking phenomena in the Finite Element Method (FEM) for linear elasticity when incompressibility-like constraints are applied only on part of the domain. The numerical experiment must compare a pure displacement-based formulation against a mixed formulation with local Lagrange multiplier enforcement of the volumetric constraint on a subset of elements. Your program must compute quantitative measures that certify whether locking has propagated the volumetric constraint into unconstrained regions, and whether local Lagrange multiplier enforcement prevents this nonphysical global spread.\n\nThe fundamental base for the derivation must be the principle of minimum potential energy and the standard linearized kinematics and constitutive equations of small-strain elasticity. Under plane strain, the small-strain tensor is defined by $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\top})$ and the Cauchy stress is $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$, where $\\mu$ and $\\lambda$ are the Lamé parameters. The weak form for the displacement-only formulation follows from the first variation of the elastic potential and surface traction work, and the mixed formulation introduces a scalar pressure field $p$ acting as a Lagrange multiplier to enforce the incompressibility constraint $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = 0$ on designated elements only.\n\nThe computational domain is the rectangle $\\Omega = [0,L]\\times[0,H]$ with $L = 1$ and $H = 1$. It is discretized with two bilinear quadrilateral elements aligned horizontally: the left element covers $[0,L/2]\\times[0,H]$ and the right element covers $[L/2,L]\\times[0,H]$. There are $(3)\\times(2) = 6$ nodes and each node carries two displacement degrees of freedom (components $u_x$ and $u_y$). The left boundary $\\{x=0\\}$ is clamped: $u_x = 0$ and $u_y = 0$. A uniform traction $\\boldsymbol{t} = (t_x,0)$ is applied on the right boundary $\\{x=L\\}$. The top and bottom boundaries are traction-free. All quantities are to be treated in dimensionless units.\n\nYou must implement:\n- A displacement-only FEM with element stiffness derived from the bilinear isoparametric mapping and a $2\\times 2$ Gaussian quadrature. The left element is made nearly incompressible by choosing a very large $\\lambda$ (bulk stiffness), while the right element remains compressible with a moderate $\\lambda$. The shear modulus $\\mu$ is uniform.\n- A mixed FEM that enforces incompressibility locally only on the left element by introducing one pressure degree of freedom per constrained element and a Lagrange multiplier constraint $\\int_{\\text{left element}}(\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega = 0$. In the constrained element, the displacement stiffness must exclude the volumetric part (set $\\lambda = 0$), retaining only the shear contribution. In the unconstrained element, use the standard compressible stiffness with the prescribed $\\lambda$ and $\\mu$.\n\nFrom first principles, start with the variational statement of equilibrium with surface tractions, discretize the displacement field using bilinear shape functions, construct the element strain-displacement matrix $B$ and the material stiffness matrix $D$ for plane strain, assemble the global stiffness matrix for both formulations, apply Dirichlet boundary conditions by elimination of fixed degrees of freedom, and solve the linear systems. For the mixed formulation, assemble the saddle-point system\n$$\n\\begin{bmatrix}\nK_{uu} & B^{\\top} \\\\\nB & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{f} \\\\\n\\boldsymbol{0}\n\\end{bmatrix},\n$$\nwhere the single-row matrix $B$ contains the integral coefficients of $\\nabla\\cdot\\boldsymbol{u}$ over the constrained element using the same Gaussian quadrature, and $\\boldsymbol{p}$ are the elementwise pressure Lagrange multipliers.\n\nFor each test case, compute the following quantitative outputs:\n- The tip displacement $u_{\\text{tip}}^{\\text{pen}}$, defined as the average $x$-displacement of the two right-edge nodes, in the displacement-only (penalty) formulation.\n- The tip displacement $u_{\\text{tip}}^{\\text{mix}}$ in the mixed formulation with local Lagrange multipliers on the left element.\n- The integrated divergence $\\mathcal{D}_{\\text{right}}^{\\text{pen}} = \\int_{\\text{right element}} (\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega$ in the displacement-only formulation.\n- The integrated divergence $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$ in the mixed formulation.\n- A boolean leakage indicator $\\beta$, equal to $\\text{True}$ if $|\\mathcal{D}_{\\text{right}}^{\\text{pen}}| < \\tfrac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|$, which certifies that the volumetric constraint has nonphysically propagated into the unconstrained right element in the displacement-only method (locking), and $\\text{False}$ otherwise.\n\nYour program must implement the following test suite, covering a general case, a near-incompressible boundary case, and an edge case without constraints:\n- Case A (general): $\\lambda_{\\text{left}} = 10^{4}$, $\\lambda_{\\text{right}} = 10^{-1}$, $\\mu = 1$, $t_x = 1$, with the left element constrained in the mixed formulation.\n- Case B (near-incompressible): $\\lambda_{\\text{left}} = 10^{7}$, $\\lambda_{\\text{right}} = 10^{-1}$, $\\mu = 1$, $t_x = 1$, with the left element constrained in the mixed formulation.\n- Case C (edge case): $\\lambda_{\\text{left}} = 10^{-1}$, $\\lambda_{\\text{right}} = 10^{-1}$, $\\mu = 1$, $t_x = 1$, with no constrained elements in the mixed formulation.\n\nAll outputs must be expressed in dimensionless units. Your program should produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets in the order $[u_{\\text{tip}}^{\\text{pen}}, u_{\\text{tip}}^{\\text{mix}}, \\mathcal{D}_{\\text{right}}^{\\text{pen}}, \\mathcal{D}_{\\text{right}}^{\\text{mix}}, \\beta]$. For example, the format must be similar to $[[a_1,a_2,a_3,a_4,b_1],[c_1,c_2,c_3,c_4,b_2],[\\dots]]$.",
            "solution": "The problem statement constitutes a valid and well-posed numerical experiment in computational solid mechanics. It is scientifically grounded in the theory of linear elasticity and the Finite Element Method (FEM), objective in its formulation, and provides a complete set of parameters and conditions to reproduce the specified analysis. The task is to demonstrate the phenomenon of volumetric locking in low-order finite elements and its mitigation using a mixed formulation.\n\nWe will first establish the theoretical framework common to both the displacement-only (penalty) and mixed formulations. Then, we will detail the specifics of each method, including the construction of element matrices, assembly of the global system, application of boundary conditions, and the computation of the required output metrics.\n\n### 1. Fundamental Equations of Linear Elasticity (Plane Strain)\n\nThe analysis is based on the principle of minimum potential energy. For a linear elastic body occupying a domain $\\Omega$, the equilibrium displacement field $\\boldsymbol{u} = (u_x, u_y)$ is the one that minimizes the total potential energy $\\Pi(\\boldsymbol{u})$. The problem is considered under plane strain conditions ($\\varepsilon_{zz} = 0$).\n\nThe strain-displacement relationship is given by the symmetric gradient of the displacement field:\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^{\\top}) $$\nUsing Voigt notation for the strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$, where $\\gamma_{xy} = 2\\varepsilon_{xy}$.\n\nThe constitutive law relating the stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ to the strain vector is $\\boldsymbol{\\sigma} = \\boldsymbol{D}\\boldsymbol{\\varepsilon}$. For an isotropic material under plane strain, the material stiffness matrix $\\boldsymbol{D}$ is:\n$$\n\\boldsymbol{D} =\n\\begin{bmatrix}\n\\lambda+2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda+2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}\n$$\nwhere $\\mu$ and $\\lambda$ are the Lamé parameters.\n\n### 2. Finite Element Discretization\n\nThe domain $\\Omega = [0,L]\\times[0,H]$ with $L=1$ and $H=1$ is discretized into two rectangular bilinear quadrilateral elements. The nodes are numbered as follows:\n- Node 1: $(0, 0)$\n- Node 2: $(L/2, 0)$\n- Node 3: $(L, 0)$\n- Node 4: $(0, H)$\n- Node 5: $(L/2, H)$\n- Node 6: $(L, H)$\n\nThe left element $\\Omega_1$ comprises nodes $(1, 2, 5, 4)$. The right element $\\Omega_2$ comprises nodes $(2, 3, 6, 5)$. Each of the $6$ nodes has two displacement degrees of freedom (DOFs), $u_x$ and $u_y$, for a total of $12$ DOFs.\n\nWithin each element, the displacement field $\\boldsymbol{u}$ is approximated using bilinear shape functions $N_a(\\xi, \\eta)$ in a local isoparametric coordinate system $(\\xi, \\eta) \\in [-1, 1]\\times[-1, 1]$:\n$$ \\boldsymbol{u}^h(\\xi, \\eta) = \\sum_{a=1}^{4} N_a(\\xi, \\eta) \\boldsymbol{d}_a $$\nwhere $\\boldsymbol{d}_a = [u_{ax}, u_{ay}]^{\\top}$ are the nodal displacements for the element's four nodes. The shape functions are $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$, where $(\\xi_a, \\eta_a)$ are the local coordinates of the nodes.\n\nThe discrete strain-displacement relationship is $\\boldsymbol{\\varepsilon} = \\boldsymbol{B}\\boldsymbol{d}^e$, where $\\boldsymbol{d}^e$ is the $8\\times 1$ vector of the element's nodal DOFs. The strain-displacement matrix $\\boldsymbol{B}$ is a $3 \\times 8$ matrix constructed from the spatial derivatives of the shape functions:\n$$ \\boldsymbol{B}_a = \\begin{bmatrix} \\frac{\\partial N_a}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_a}{\\partial y} \\\\ \\frac{\\partial N_a}{\\partial y} & \\frac{\\partial N_a}{\\partial x} \\end{bmatrix}, \\quad \\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4] $$\nThe derivatives w.r.t. global coordinates $(x,y)$ are obtained via the chain rule using the Jacobian matrix $\\boldsymbol{J}$ of the isoparametric mapping:\n$$ \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta} \\end{Bmatrix} $$\nFor the rectangular elements in this problem, $\\boldsymbol{J} = \\text{diag}(L/4, H/2)$ and its determinant is $\\det(\\boldsymbol{J}) = LH/8$.\n\n### 3. Displacement-Only (Penalty) Formulation\n\nThe element stiffness matrix $\\boldsymbol{K}^e$ is derived from the strain energy and is computed by integrating over the element domain:\n$$ \\boldsymbol{K}^e = \\int_{\\Omega^e} \\boldsymbol{B}^{\\top} \\boldsymbol{D} \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\nThis integral is evaluated numerically using $2 \\times 2$ Gaussian quadrature. The element stiffness matrices are assembled into a global stiffness matrix $\\boldsymbol{K}$ of size $12 \\times 12$.\n\nThe external forces are due to the traction $\\boldsymbol{t} = (t_x, 0)$ on the right boundary $\\{x=L, 0 \\le y \\le H\\}$. This boundary corresponds to the edge between nodes 3 and 6 of the right element. The consistent nodal force vector $\\boldsymbol{f}^e$ is:\n$$ \\boldsymbol{f}^e = \\int_{\\Gamma_t^e} \\boldsymbol{N}^{\\top} \\boldsymbol{t} \\, \\mathrm{d}S $$\nwhere $\\boldsymbol{N}$ is the matrix of shape functions. Integration shows that the traction results in forces of magnitude $t_x H / 2$ in the $x$-direction at nodes 3 and 6. For $t_x=1$ and $H=1$, these forces are $0.5$. The global force vector $\\boldsymbol{F}$ contains these two non-zero entries.\n\nDirichlet boundary conditions are applied at the clamped left boundary ($x=0$), where nodes 1 and 4 have their displacements fixed to zero ($u_{1x}=u_{1y}=u_{4x}=u_{4y}=0$). These DOFs are eliminated from the global system, resulting in a reduced system $\\boldsymbol{K}_{red}\\boldsymbol{d}_{free} = \\boldsymbol{F}_{free}$, which is solved for the unknown nodal displacements $\\boldsymbol{d}_{free}$.\n\nIn this formulation, near-incompressibility in the left element is modeled by using a very large value for $\\lambda_{\\text{left}}$, which acts as a penalty parameter on the volumetric strain $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$.\n\n### 4. Mixed Formulation\n\nTo alleviate locking, a mixed formulation is introduced. A piecewise constant pressure field $p$ is added as a Lagrange multiplier to enforce the incompressibility constraint $\\operatorname{tr}(\\boldsymbol{\\varepsilon})=0$ only on the specified constrained elements. For this problem, a single pressure DOF $p_1$ is introduced for the left element.\n\nThe potential energy functional is modified to a saddle-point functional:\n$$ \\Pi(\\boldsymbol{u}, p_1) = \\int_{\\Omega} \\frac{1}{2}\\boldsymbol{\\sigma}(\\boldsymbol{u}):\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, \\mathrm{d}\\Omega - \\int_{\\Gamma_t} \\boldsymbol{t}\\cdot\\boldsymbol{u} \\, \\mathrm{d}S - \\int_{\\Omega_1} p_1 \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u})) \\, \\mathrm{d}\\Omega $$\nFor the constrained element ($\\Omega_1$), the volumetric part of the stiffness is removed from the internal energy term by setting its $\\lambda$ to $0$. The standard compressible stiffness is used for the unconstrained element ($\\Omega_2$).\n\nDiscretization leads to the following block matrix system:\n$$\n\\begin{bmatrix}\n\\boldsymbol{K}_{uu} & \\boldsymbol{G}^{\\top} \\\\\n\\boldsymbol{G} & \\boldsymbol{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{F} \\\\\n\\boldsymbol{0}\n\\end{bmatrix}\n$$\n- $\\boldsymbol{K}_{uu}$ is the global stiffness matrix assembled from element contributions. For the constrained left element, $\\boldsymbol{D}$ is evaluated with $\\lambda=0$. For the unconstrained right element, the standard $\\boldsymbol{D}$ is used.\n- $\\boldsymbol{p}$ is the vector of pressure DOFs, here just the scalar $p_1$.\n- $\\boldsymbol{G}$ is the discrete gradient operator (coupling matrix), derived from the constraint term. For a single constraint on element $\\Omega_1$:\n$$ \\boldsymbol{G}_{1,j} \\boldsymbol{u}_j = p_1 \\int_{\\Omega_1} \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h)) \\, \\mathrm{d}\\Omega $$\nThe row vector $\\boldsymbol{G}$ (denoted as $B$ in the problem description) is computed as:\n$$ \\boldsymbol{G} = \\int_{\\Omega_1} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\nThis integral is also evaluated using $2 \\times 2$ Gaussian quadrature.\n\nThe full system (size $13 \\times 13$ for cases A and B) is assembled. Boundary conditions are applied by elimination, and the resulting reduced system is solved for the free displacement DOFs and the pressure $p_1$. For Case C, with no constraints, this formulation is identical to the displacement-only method.\n\n### 5. Output Metrics\n\nAfter solving for the nodal displacements for both formulations ($\\boldsymbol{d}^{\\text{pen}}$ and $\\boldsymbol{d}^{\\text{mix}}$), we compute the required outputs:\n- **Tip displacement** $u_{\\text{tip}}$: The average of the $x$-displacements of the right-edge nodes (nodes 3 and 6).\n$$ u_{\\text{tip}} = \\frac{1}{2}(u_{3x} + u_{6x}) $$\n- **Integrated divergence** $\\mathcal{D}_{\\text{right}}$: The integral of the volumetric strain over the right element.\n$$ \\mathcal{D}_{\\text{right}} = \\int_{\\Omega_2} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathrm{d}\\Omega = \\left(\\int_{\\Omega_2} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega \\right) \\boldsymbol{d}^e_{\\text{right}} $$\nwhere $\\boldsymbol{d}^e_{\\text{right}}$ are the nodal displacements of the right element. This quantity is computed for both formulations.\n- **Leakage indicator** $\\beta$: A boolean value indicating if the penalty method causes significant spurious volumetric constraint on the unconstrained element.\n$$ \\beta = (|\\mathcal{D}_{\\text{right}}^{\\text{pen}}| < \\frac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|) $$\nLocking is expected in the penalty formulation (Cases A and B), which will manifest as an artificially small $u_{\\text{tip}}^{\\text{pen}}$ and a near-zero $\\mathcal{D}_{\\text{right}}^{\\text{pen}}$. The mixed method should alleviate this, yielding a larger tip displacement and a physically reasonable, non-zero $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$. This will result in $\\beta = \\text{True}$. Case C serves as a baseline where both methods should yield identical results and $\\beta = \\text{False}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as linsolve\n\ndef get_shape_fns_and_derivs(xi, eta):\n    \"\"\"\n    Computes bilinear shape functions and their derivatives in local coords.\n    Nodes are ordered anti-clockwise from bottom-left (-1, -1).\n    \"\"\"\n    # Shape functions\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),\n        (1 + xi) * (1 - eta),\n        (1 + xi) * (1 + eta),\n        (1 - xi) * (1 + eta)\n    ])\n    # Derivatives w.r.t. local coordinates (xi, eta)\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef assemble_fem_matrices(lambda_val, mu, L_elem, H_elem):\n    \"\"\"\n    Computes element stiffness matrix Ke, coupling vector G.\n    \"\"\"\n    elem_dofs = 8\n    Ke = np.zeros((elem_dofs, elem_dofs))\n    G = np.zeros(elem_dofs) # for mixed formulation\n    \n    # 2x2 Gaussian quadrature\n    gp_locs = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gp_weights = [1.0, 1.0]\n    \n    # Plane strain material stiffness matrix D\n    D = np.array([\n        [lambda_val + 2 * mu, lambda_val, 0],\n        [lambda_val, lambda_val + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    for i, wi in enumerate(gp_weights):\n        for j, wj in enumerate(gp_weights):\n            xi, eta = gp_locs[j], gp_locs[i]\n            _, dN_dxi, dN_deta = get_shape_fns_and_derivs(xi, eta)\n            \n            # Jacobian matrix for axis-aligned rectangle\n            J = np.array([\n                [L_elem/2, 0],\n                [0, H_elem/2]\n            ])\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Derivatives w.r.t. global coordinates (x,y)\n            dN_dxy = invJ @ np.vstack((dN_dxi, dN_deta))\n            dN_dx = dN_dxy[0, :]\n            dN_dy = dN_dxy[1, :]\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, elem_dofs))\n            for k in range(4):\n                B[0, 2*k] = dN_dx[k]\n                B[1, 2*k+1] = dN_dy[k]\n                B[2, 2*k] = dN_dy[k]\n                B[2, 2*k+1] = dN_dx[k]\n            \n            # Integrate for stiffness matrix\n            Ke += B.T @ D @ B * detJ * wi * wj\n            \n            # Integrate for coupling vector G\n            g_vec = np.array([1, 1, 0])\n            G += g_vec @ B * detJ * wi * wj\n            \n    return Ke, G\n\ndef solve_case(lambda_left, lambda_right, mu, tx, constrained):\n    L, H = 1.0, 1.0\n    num_nodes = 6\n    total_dofs = num_nodes * 2\n\n    elem_connectivity = [\n        [0, 1, 4, 3],  # Left element (nodes 0,1,4,3)\n        [1, 2, 5, 4]   # Right element (nodes 1,2,5,4)\n    ]\n    \n    # ----- Displacement-only (Penalty) Formulation -----\n    K_pen = np.zeros((total_dofs, total_dofs))\n    \n    # Assemble left element\n    Ke_left_pen, _ = assemble_fem_matrices(lambda_left, mu, L/2, H)\n    dof_map_left = np.array([[2*i, 2*i+1] for i in elem_connectivity[0]]).flatten()\n    K_pen[np.ix_(dof_map_left, dof_map_left)] += Ke_left_pen\n\n    # Assemble right element\n    Ke_right_pen, G_right_pen_elem = assemble_fem_matrices(lambda_right, mu, L/2, H)\n    dof_map_right = np.array([[2*i, 2*i+1] for i in elem_connectivity[1]]).flatten()\n    K_pen[np.ix_(dof_map_right, dof_map_right)] += Ke_right_pen\n\n    F_pen = np.zeros(total_dofs)\n    F_pen[2*2 + 0] += tx * H / 2.0  # Force on node 3 (index 2)\n    F_pen[2*5 + 0] += tx * H / 2.0  # Force on node 6 (index 5)\n\n    # Apply BCs\n    fixed_dofs = [0, 1, 2*3+0, 2*3+1] # DOFs for nodes 0 and 3\n    free_dofs = np.setdiff1d(np.arange(total_dofs), fixed_dofs)\n    \n    K_red_pen = K_pen[np.ix_(free_dofs, free_dofs)]\n    F_red_pen = F_pen[free_dofs]\n    \n    u_red_pen = linsolve(K_red_pen, F_red_pen)\n    \n    u_pen = np.zeros(total_dofs)\n    u_pen[free_dofs] = u_red_pen\n\n    # ----- Mixed Formulation -----\n    num_pressure_dofs = 1 if constrained else 0\n    sys_size = total_dofs + num_pressure_dofs\n    A_mix = np.zeros((sys_size, sys_size))\n    b_mix = np.zeros(sys_size)\n\n    # Assemble K_uu part\n    lambda_left_mix = 0.0 if constrained else lambda_left\n    Ke_left_mix, G_left_mix_elem = assemble_fem_matrices(lambda_left_mix, mu, L/2, H)\n    A_mix[np.ix_(dof_map_left, dof_map_left)] += Ke_left_mix\n    \n    Ke_right_mix, G_right_mix_elem = assemble_fem_matrices(lambda_right, mu, L/2, H)\n    A_mix[np.ix_(dof_map_right, dof_map_right)] += Ke_right_mix\n\n    # Assemble G part if constrained\n    if constrained:\n        pressure_dof_idx = total_dofs\n        A_mix[pressure_dof_idx, dof_map_left] = G_left_mix_elem\n        A_mix[dof_map_left, pressure_dof_idx] = G_left_mix_elem\n\n    b_mix[:total_dofs] = F_pen # Force vector is same\n\n    # Apply BCs for mixed system\n    all_sys_dofs = np.arange(sys_size)\n    free_sys_dofs = np.concatenate([free_dofs, np.arange(total_dofs, sys_size)])\n    \n    A_red_mix = A_mix[np.ix_(free_sys_dofs, free_sys_dofs)]\n    b_red_mix = b_mix[free_sys_dofs]\n\n    # Solve\n    sol_red_mix = linsolve(A_red_mix, b_red_mix)\n    \n    u_mix = np.zeros(total_dofs)\n    u_mix_red = sol_red_mix[:-num_pressure_dofs] if constrained else sol_red_mix\n    u_mix[free_dofs] = u_mix_red\n\n    # ----- Compute Outputs -----\n    u_tip_pen = (u_pen[2*2 + 0] + u_pen[2*5 + 0]) / 2.0\n    u_tip_mix = (u_mix[2*2 + 0] + u_mix[2*5 + 0]) / 2.0\n    \n    u_elem_right_pen = u_pen[dof_map_right]\n    D_right_pen = G_right_pen_elem @ u_elem_right_pen\n\n    u_elem_right_mix = u_mix[dof_map_right]\n    D_right_mix = G_right_mix_elem @ u_elem_right_mix\n    \n    beta = False\n    if abs(D_right_mix) > 1e-15: # Avoid division by zero\n        if abs(D_right_pen)  0.5 * abs(D_right_mix):\n            beta = True\n\n    return [u_tip_pen, u_tip_mix, D_right_pen, D_right_mix, beta]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (general)\n        {'lambda_left': 1e4, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case B (near-incompressible)\n        {'lambda_left': 1e7, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case C (edge case)\n        {'lambda_left': 1e-1, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(result)\n\n    # Format output as specified a list of lists.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = \"[\" + \",\".join([\n        \"[\" + \",\".join([f\"{v:.6f}\" if isinstance(v, float) else str(v) for v in res]) + \"]\"\n        for res in results\n    ]) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}