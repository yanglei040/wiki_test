{
    "hands_on_practices": [
        {
            "introduction": "我们如何才能在模拟中定量地检测体积锁定现象？本练习将介绍一种直接的方法。通过对比标准的纯位移有限元公式和稳定的混合位移-压力公式，你将实现一个基于局部质量守恒的诊断工具。你会直接观察到标准方法在处理不可压缩性时的失效，以及混合方法如何成功地解决这一问题，从而培养识别和验证数值病态问题的基本技能。",
            "id": "3418041",
            "problem": "考虑单位正方形域 $[0,1]\\times[0,1]$ 上的平面应变线性弹性边值问题，其单位外法向量为 $\\boldsymbol{n}$，在整个边界上施加均匀静水牵引力 $-p_0\\,\\boldsymbol{n}$。其强形式由平衡方程和本构关系组成\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{在 }[0,1]^2,\\qquad \\boldsymbol{\\sigma}=2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I},\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$ 为小应变张量，剪切模量 $\\mu>0$，Lamé 参数 $\\lambda\\ge 0$，体积模量 $\\kappa=\\lambda+\\tfrac{2\\mu}{3}$，以及在 $\\partial([0,1]^2)$ 上的 Neumann 边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$。假设采用无量纲单位（无需进行物理单位转换），并设置 $\\mu=1$。\n\n在连续问题中，于均匀静水载荷作用下，体积应变 $\\nabla\\cdot\\boldsymbol{u}$ 在空间上是均匀的，其值等于 $-\\tfrac{p_0}{\\kappa}$，当 $\\kappa\\to\\infty$ 时趋近于 $0$。然而，在数值离散化中，纯位移格式会表现出体积锁定现象：在固定的网格尺寸下，当 $\\kappa\\to\\infty$ 时，离散散度 $\\nabla\\cdot\\boldsymbol{u}_h$ 无法趋近于 $0$。而适当的混合格式能更稳健地施加近不可压缩约束。\n\n您的任务是在一个包含 $n\\times n$ 个双线性（$\\mathsf{Q}_1$）单元的结构化四边形网格上，实现两种有限元法（FEM）离散格式：\n- 一种纯位移格式，它使用平面应变中各向同性弹性的标准对称双线性形式。在采用工程剪切应变 $\\gamma_{xy}=2\\varepsilon_{xy}$ 的 Voigt 记法中，该双线性形式使用的矩阵其元素为 $D_{11}=\\lambda+2\\mu$，$D_{12}=\\lambda$ 和 $D_{33}=\\mu$。\n- 一种稳定的位移-压力混合格式，其中位移和压力采用同阶的双线性（$\\mathsf{Q}_1$）离散空间。其弱形式分解为偏量部分和对散度的约束：\n$$\n\\text{求 }(\\boldsymbol{u}_h,p_h)\\text{ 使得}\\quad\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s,\n$$\n对所有测试函数对 $(\\boldsymbol{v}_h,q_h)$ 成立，其中 $h=1/n$ 且 $\\gamma>0$ 是一个小的稳定化参数。纯偏量刚度使用 $D_{11}=2\\mu$，$D_{12}=0$，$D_{33}=\\mu$。\n\n对两种格式，都通过线积分在整个边界上施加静水 Neumann 牵引力 $-p_0\\,\\boldsymbol{n}$，并通过在左下角节点约束位移 $\\boldsymbol{u}_h=\\boldsymbol{0}$ 以及在右下角节点约束竖向位移分量为零来消除刚体模态。在混合格式中，不要约束压力场。\n\n基于局部质量守恒定义用于诊断锁定的量：对网格中的每个单元 $K$，计算其单元体积变化\n$$\nI_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x,\n$$\n使用 $2\\times 2$ Gauss 积分进行计算。对于静水载荷下的完全不可压缩响应，所有单元 $K$ 的 $I_K$ 都应为 $0$。如果当 $\\kappa\\to\\infty$ 时，在固定的 $h$ 下，集合 $\\{I_K\\}$ 未能一致地趋近于 $0$，则称该方法是锁定的；而如果在大 $\\kappa$ 值下，随着网格细化，$I_K$ 以 $\\mathcal{O}(h)$ 的速率衰减，则称该方法是非锁定的。\n\n实现这两种离散格式，使用稀疏线性代数方法组装并求解线性系统，然后计算诊断聚合量\n$$\nA = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|,\n$$\n其中 $N_{\\mathrm{el}}=n^2$ 是单元的数量。使用无量纲数，并将 $A$ 表示为浮点数。\n\n您的程序必须评估以下测试套件：\n- 测试用例 1：纯位移格式，$n=4$，$\\kappa=10^6$，$p_0=1$。\n- 测试用例 2：混合格式，$n=4$，$\\kappa=10^6$，$p_0=1$，稳定化参数 $\\gamma=10^{-3}$。\n- 测试用例 3：混合格式，$n=8$，$\\kappa=10^6$，$p_0=1$，稳定化参数 $\\gamma=10^{-3}$。\n- 测试用例 4：纯位移格式，$n=8$，$\\kappa=10^6$，$p_0=1$。\n- 测试用例 5：纯位移格式，$n=4$，$\\kappa=10^3$，$p_0=1$。\n\n对于每个测试用例，计算并返回如上定义的聚合量 $A$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），每个结果都格式化为标准的 Python 浮点数。",
            "solution": "用户的请求是一个有效的计算力学问题。它要求为平面应变线性弹性问题实现两种不同的有限元法（FEM）格式，以研究体积锁定现象。该问题具有科学依据、是良定的，并且为获得唯一解提供了所有必要的参数和条件。\n\n### 1. 问题描述\n\n问题定义在单位正方形域 $\\Omega = [0,1]^2$ 上。控制方程为线性弹性方程：\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{在 }\\Omega\n$$\n应力张量 $\\boldsymbol{\\sigma}$ 通过各向同性材料的本构律与位移场 $\\boldsymbol{u}$ 相关联：\n$$\n\\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I}\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$ 是小应变张量，$\\mu$ 是剪切模量，$\\lambda$ 是第一 Lamé 参数。材料在其整个边界 $\\partial\\Omega$ 上承受均匀的静水压力 $p_0$，这对应于一个 Neumann 边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$。\n\n给定 $\\mu=1$ 和体积模量 $\\kappa = \\lambda + \\frac{2\\mu}{3}$。这使我们能够用给定的 $\\kappa$ 和 $\\mu$ 来表示 $\\lambda$：$\\lambda = \\kappa - \\frac{2}{3}$。该问题考虑的是近不可压缩极限，其中 $\\kappa \\to \\infty$，这意味着 $\\lambda \\to \\infty$。\n\n为确保唯一解，必须抑制刚体运动（二维中的两次平移和一次旋转）。这通过施加 Dirichlet 边界条件来实现：$\\boldsymbol{u}(0,0) = \\boldsymbol{0}$ 和 $u_y(1,0) = 0$。\n\n### 2. 有限元离散\n\n该域被离散为 $n \\times n$ 个四边形单元的结构化网格。所有场变量都使用双线性形函数（$\\mathsf{Q}_1$）。对于一个一般单元 $K$，位移场插值为 $\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\boldsymbol{d}_i$，其中 $N_i$ 是形函数，$\\boldsymbol{d}_i$ 是节点位移向量。\n\n#### 2.1. 格式 1：纯位移\n\n从虚功原理推导出的标准弱形式是：找到 $\\boldsymbol{u}_h$，使得对于所有容许的虚位移 $\\boldsymbol{v}_h$：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}(\\boldsymbol{u}_h) : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h) \\, \\mathrm{d}x = \\int_{\\partial\\Omega} (-p_0\\boldsymbol{n}) \\cdot \\boldsymbol{v}_h \\, \\mathrm{d}s\n$$\n这导出了一个线性方程组 $[K]\\{U\\} = \\{F\\}$，其中 $\\{U\\}$ 是节点位移的全局向量。单元刚度矩阵 $K_e$ 通过在单元域上积分计算得出：\n$$\nK_e = \\int_{K} B^T D B \\, \\mathrm{d}x\n$$\n其中 $B$ 是离散应变-位移矩阵，$D$ 是平面应变的材料本构矩阵。在应力 $\\{\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}\\}$ 和工程应变 $\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$ 的 Voigt 记法中，$D$ 矩阵为：\n$$\nD = \\begin{bmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}\n$$\n力向量 $\\{F\\}$ 由边界单元上的线积分组装而成。\n\n#### 2.2. 格式 2：稳定的位移-压力混合格式（u-p）\n\n该格式引入一个独立的压力场 $p_h$ 来施加不可压缩约束。位移场和压力场使用相同的双线性（$\\mathsf{Q}_1$）基进行近似。由于这种选择不满足 Ladyzhenskaya-Babuška-Brezzi (LBB) inf-sup 条件，因此需要添加一个稳定项。指定的弱形式为：找到 $(\\boldsymbol{u}_h, p_h)$，使得对于所有测试函数 $(\\boldsymbol{v}_h, q_h)$：\n$$\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s\n$$\n这导出了一个更大的、形如下式的鞍点线性系统：\n$$\n\\begin{bmatrix} K_{uu} & -G^T \\\\ G & -\\frac{1}{\\kappa}M_p + K_{stab} \\end{bmatrix}\n\\begin{Bmatrix} U \\\\ P \\end{Bmatrix}\n= \\begin{Bmatrix} F_u \\\\ 0 \\end{Bmatrix}\n$$\n矩阵块对应于：\n- $K_{uu}$：来自 $2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)$ 项的刚度。\n- $G$：来自 $\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$ 的梯度/散度耦合矩阵。\n- $M_p$：来自 $\\int p_h\\,q_h\\,\\mathrm{d}x$ 的压力质量矩阵。\n- $K_{stab}$：来自 $\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x$ 的压力稳定矩阵（一个缩放的拉普拉斯算子）。\n\n### 3. 实现细节\n\n- **积分**：所有单元积分（针对刚度矩阵、质量矩阵和力向量）都在参考单元 $[-1,1]^2$ 上使用 $2 \\times 2$ Gauss 积分进行数值计算。边界牵引力的线积分则使用 2 点一维 Gauss 积分进行评估。\n- **组装**：计算单元级矩阵和向量，然后将它们组装成全局稀疏矩阵（`scipy.sparse.lil_matrix`）和向量。\n- **线性求解**：通过将系统划分为自由自由度和固定自由度来施加 Dirichlet 约束。得到的自由自由度简化系统使用 `scipy.sparse.linalg.spsolve` 求解。\n- **诊断量**：求解位移场 $\\boldsymbol{u}_h$ 后，对每个单元 $K$ 使用 $2 \\times 2$ Gauss 积分计算单元体积变化 $I_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$。最终的诊断量是这些变化绝对值的平均值，$A = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|$。\n\n纯位移格式预计会表现出锁定现象，即对于固定网格，随着 $\\kappa$ 的增加，$A$ 保持较大。混合格式旨在缓解此问题，$A$ 应该显著更小并表现出更好的收敛特性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_quadrature_2d():\n    \"\"\"Returns 2x2 Gauss quadrature points and weights on [-1,1]^2.\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    quad_points = np.array([(p, q) for q in points for p in points])\n    quad_weights = np.array([w * v for v in weights for w in weights])\n    return quad_points, quad_weights\n\ndef get_quadrature_1d():\n    \"\"\"Returns 2-point Gauss quadrature points and weights on [-1,1].\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    return points, weights\n\ndef get_shape_functions(xi, eta):\n    \"\"\"Returns Q1 shape functions and their gradients on the reference element.\"\"\"\n    N = 0.25 * np.array([(1.0 - xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 + eta),\n                         (1.0 - xi) * (1.0 + eta)])\n    dN_dxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dN_deta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef run_fem_analysis(formulation, n, kappa, p0, gamma=0.0, mu=1.0):\n    \"\"\"Main FEM analysis function for both displacement-only and mixed formulations.\"\"\"\n    # 1. Mesh Generation\n    h = 1.0 / n\n    num_nodes = (n + 1)**2\n    num_elems = n**2\n    nodes = np.array([[i * h, j * h] for j in range(n + 1) for i in range(n + 1)], dtype=float)\n    elements = np.array([[j * (n + 1) + i, j * (n + 1) + i + 1, (j + 1) * (n + 1) + i + 1, (j + 1) * (n + 1) + i]\n                         for j in range(n) for i in range(n)], dtype=int)\n\n    # 2. DOF and Matrix Setup\n    num_u_dofs = 2 * num_nodes\n    if formulation == 'displacement':\n        total_dofs = num_u_dofs\n    elif formulation == 'mixed':\n        total_dofs = 3 * num_nodes\n    else:\n        raise ValueError(\"Unknown formulation\")\n\n    K_global = lil_matrix((total_dofs, total_dofs))\n    F_global = np.zeros(total_dofs)\n\n    # 3. Material and quadrature setup\n    if formulation == 'displacement':\n        lam = kappa - 2.0 * mu / 3.0\n        D = np.array([[lam + 2 * mu, lam, 0.0],\n                      [lam, lam + 2 * mu, 0.0],\n                      [0.0, 0.0, mu]])\n    else:  # mixed\n        D_dev = np.array([[2 * mu, 0.0, 0.0],\n                          [0.0, 2 * mu, 0.0],\n                          [0.0, 0.0, mu]])\n    \n    quad_points_2d, quad_weights_2d = get_quadrature_2d()\n\n    # 4. Assembly loop over elements\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n\n        # Displacement-only formulation assembly\n        if formulation == 'displacement':\n            Ke = np.zeros((8, 8))\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Ke += qw * (B.T @ D @ B) * detJ\n            K_global[np.ix_(u_dofs, u_dofs)] += Ke\n\n        # Mixed formulation assembly\n        elif formulation == 'mixed':\n            p_dofs = el_nodes_indices\n            global_p_dofs = num_u_dofs + p_dofs\n            \n            Kuu_e = np.zeros((8, 8))\n            G_e = np.zeros((4, 8))\n            Mp_e = np.zeros((4, 4))\n            Ks_e = np.zeros((4, 4))\n\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                N, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Kuu_e += qw * (B.T @ D_dev @ B) * detJ\n                \n                for i in range(4):\n                    for j in range(4):\n                        G_e[i, 2*j]   += qw * N[i] * dN_dxy[0, j] * detJ\n                        G_e[i, 2*j+1] += qw * N[i] * dN_dxy[1, j] * detJ\n                \n                Mp_e += qw * np.outer(N, N) * detJ\n                Ks_e += qw * (dN_dxy.T @ dN_dxy) * detJ\n\n            K_global[np.ix_(u_dofs, u_dofs)] += Kuu_e\n            K_global[np.ix_(u_dofs, global_p_dofs)] -= G_e.T\n            K_global[np.ix_(global_p_dofs, u_dofs)] += G_e\n            \n            pp_block = (-1.0/kappa) * Mp_e + gamma * (h**2) * Ks_e\n            K_global[np.ix_(global_p_dofs, global_p_dofs)] += pp_block\n\n    # 5. Assemble Force Vector from Neumann BC\n    F_u = np.zeros(num_u_dofs)\n    q1d_pts, q1d_wts = get_quadrature_1d()\n\n    for j in range(n):\n        for i in range(n):\n            el_nodes = elements[j * n + i]\n            el_dofs = np.ravel([[2 * k, 2 * k + 1] for k in el_nodes])\n            \n            # Bottom edge (y=0)\n            if j == 0:\n                load = np.array([0., p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, -1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Top edge (y=1)\n            if j == n - 1:\n                load = np.array([0., -p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, 1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Left edge (x=0)\n            if i == 0:\n                load = np.array([p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(-1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Right edge (x=1)\n            if i == n - 1:\n                load = np.array([-p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n    F_global[:num_u_dofs] = F_u\n\n    # 6. Apply Displacement Constraints and Solve\n    fixed_dofs = np.array([0, 1, 2 * n + 1])\n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n\n    K_free = K_global[np.ix_(free_dofs, free_dofs)].tocsr()\n    F_free = F_global[free_dofs]\n\n    Sol_free = spsolve(K_free, F_free)\n\n    Sol = np.zeros(total_dofs)\n    Sol[free_dofs] = Sol_free\n    U = Sol[:num_u_dofs]\n\n    # 7. Post-processing: Compute Diagnostic A\n    total_vol_change_abs_sum = 0.0\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        el_u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n        el_U = U[el_u_dofs]\n        \n        I_K = 0.0\n        for qp, qw in zip(quad_points_2d, quad_weights_2d):\n            _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n            J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n            detJ = np.linalg.det(J)\n            dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n            \n            div_u_h = 0.0\n            for i in range(4):\n                div_u_h += dN_dxy[0, i] * el_U[2*i] + dN_dxy[1, i] * el_U[2*i+1]\n            I_K += qw * div_u_h * detJ\n        \n        total_vol_change_abs_sum += np.abs(I_K)\n        \n    A = total_vol_change_abs_sum / num_elems\n    return A\n\ndef solve():\n    test_cases = [\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'mixed', 'n': 4, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'mixed', 'n': 8, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'displacement', 'n': 8, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e3, 'p0': 1.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_fem_analysis(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "选择性减缩积分（Selective Reduced Integration, SRI）是解决锁定问题的一种常见且计算高效的技术，但这种“疗法”有时可能比问题本身更糟糕。本练习要求你通过对刚度矩阵的偏量和体积部分应用不同的求积规则来实现和分析SRI。通过对所得刚度矩阵进行谱分析，你不仅能验证SRI缓解了锁定，还将揭示其主要缺陷：可能引入伪零能“沙漏”模式，这突显了在选择数值方案时进行权衡的关键性。",
            "id": "3418037",
            "problem": "考虑在单位正方形域上的平面应变二维线弹性问题，材料为各向同性，其参数为杨氏模量 $E$ 和泊松比 $\\nu$。使用标准的 $Q_1$（双线性）有限元离散化方法，网格为 $N_x \\times N_y$ 个单元的结构化矩形网格。控制方程由最小势能原理导出：寻找位移场 $\\boldsymbol{u}$，使总势能最小化\n$$\n\\Pi(\\boldsymbol{u}) = \\int_{\\Omega} \\left( \\mu \\, \\boldsymbol{\\epsilon}_{\\text{dev}} : \\boldsymbol{\\epsilon}_{\\text{dev}} + \\tfrac{1}{2} \\kappa \\, (\\operatorname{tr}\\boldsymbol{\\epsilon})^2 \\right)\\, \\mathrm{d}\\Omega \\;-\\; \\int_{\\Omega} \\boldsymbol{b}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Omega \\;-\\; \\int_{\\Gamma_N} \\boldsymbol{t}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Gamma,\n$$\n其中 $\\boldsymbol{\\epsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$ 是小应变张量，$\\boldsymbol{\\epsilon}_{\\text{dev}} = \\boldsymbol{\\epsilon} - \\tfrac{1}{3}(\\operatorname{tr}\\boldsymbol{\\epsilon})\\boldsymbol{I}$ 是其偏量部分，$\\mu = \\dfrac{E}{2(1+\\nu)}$ 是剪切模量，$\\kappa = \\lambda + \\dfrac{2}{3}\\mu$ 是体积模量，其中拉梅参数 $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$。在基于位移的平面应变 $Q_1$ 离散化中，使用工程剪应变 $\\gamma_{xy}$ 的 Voigt 形式本构矩阵为\n$$\n\\boldsymbol{C} = \\begin{bmatrix} \\lambda + 2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda + 2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}.\n$$\n当 $\\nu \\to 0.5$ 时，一种常用的、基于求积的、用于缓解体积闭锁的技术是选择性减缩积分，该技术对偏量和体量贡献采用不同的求积法则进行积分。特别地，定义\n$$\n\\boldsymbol{C}_{\\mu} = \\mu \\,\\operatorname{diag}(2,2,1), \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix},\n$$\n使得 $\\boldsymbol{C} = \\boldsymbol{C}_{\\mu} + \\boldsymbol{C}_{\\lambda}$。单元刚度贡献为\n$$\n\\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega,\n$$\n其中 $\\boldsymbol{B}$ 是平面应变中标准的 $Q_1$ 应变-位移矩阵，工程剪应变为 $\\gamma_{xy} = \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x}$。\n\n您的任务是对组装的离散刚度矩阵进行谱分析，以评估关于当 $\\nu \\to 0.5$ 时 $Q_1$ 单元中闭锁现象的两个论断：\n\n- 论断 A：选择性减缩积分（定义为用完全的 $2\\times 2$ Gauss 求积对偏量部分进行积分，用减缩的 $1\\times 1$ Gauss 求积对体量部分进行积分）能够消除体积闭锁，即在固定载荷下，位移响应对 $\\nu$ 趋近于 $0.5$ 保持不敏感。\n\n- 论断 B：选择性减缩积分不会引入伪零能模式（沙漏模式），即离散刚度矩阵不会获得除通过本质边界条件消除的零特征值之外的额外零特征值。\n\n您必须设计并实现一个程序，该程序在三种求积方案下组装全局刚度矩阵并检查其谱：\n\n- 方案 F（完全积分）：在参考正方形上使用 $2\\times 2$ Gauss 法则对 $\\boldsymbol{C}_{\\mu}$ 和 $\\boldsymbol{C}_{\\lambda}$ 进行积分，横坐标为 $\\pm 1/\\sqrt{3}$，权重为 $1$，共计四个点，总权重为 $4$。\n\n- 方案 S（选择性减缩积分）：使用 $2\\times 2$ Gauss 法则对 $\\boldsymbol{C}_{\\mu}$ 进行积分，使用在 $(0,0)$ 处权重为 $4$ 的 $1\\times 1$ Gauss 法则对 $\\boldsymbol{C}_{\\lambda}$ 进行积分。\n\n- 方案 R（完全减缩积分）：使用 $1\\times 1$ Gauss 法则对 $\\boldsymbol{C}_{\\mu}$ 和 $\\boldsymbol{C}_{\\lambda}$ 进行积分。\n\n在 $\\Omega = [0,1]\\times[0,1]$ 上使用 $N_x = 8, N_y = 8$ 且单位厚度的结构化 $Q_1$ 网格。通过固定左边界 $x=0$ 上的位移 $u=0$ 和 $v=0$ 来施加齐次本质边界条件。对于加载测试，施加单位面积上的均布体力 $\\boldsymbol{b} = (1,0)$，且无 Neumann 牵引，并使用 $2\\times 2$ Gauss 法则组装一致节点力向量。使用 $E=1$ 和泊松比 $\\nu \\in \\{0.3, 0.49, 0.4999\\}$。\n\n定义以下量化测试：\n\n- 在 $\\nu = 0.4999$ 下的谱零模态测试：对于方案 S 和 R，构造施加约束后的刚度矩阵并计算所有特征值。设 $\\lambda_{\\max}$ 为最大特征值。计算严格小于 $\\tau \\, \\lambda_{\\max}$（其中 $\\tau = 10^{-8}$）的特征值数量，记为 $n_{\\text{near-}0}$。报告方案 S 和方案 R 的 $n_{\\text{near-}0}$。同时报告方案 S 的最小特征值，记为 $\\lambda_{\\min}^{(S)}$。\n\n- 体力作用下的闭锁敏感性测试：对于方案 F 和 S，求解体力加载下施加约束后的问题的线性系统，并计算位移向量的欧几里得范数 $\\|\\boldsymbol{u}\\|_2$。令 $r_F = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ 和 $r_S = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ 分别为方案 F 和 S 的比率。一个远小于 $1$ 的 $r$ 值表示存在闭锁，而一个接近 $1$ 的值表示闭锁得到缓解。\n\n您的程序必须：\n\n- 为方案 F、S 和 R 使用指定的求积分解组装全局刚度矩阵。\n\n- 通过消除被固定的自由度来施加边界条件，并构造约简系统。\n\n- 在需要进行谱测试时，计算约简刚度矩阵的全谱。\n\n- 使用直接线性求解器求解加载测试的约简线性系统。\n\n测试套件和输出规范：\n\n- 使用 $N_x = 8$, $N_y = 8$, $E = 1$ 以及 $\\nu \\in \\{0.3, 0.49, 0.4999\\}$。\n\n- 单位面积体力 $\\boldsymbol{b} = (1,0)$。\n\n- 在 $\\nu = 0.4999$ 下使用容差因子 $\\tau = 10^{-8}$ 进行谱零模态测试。\n\n- 程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  1. $\\nu = 0.4999$ 时的 $\\lambda_{\\min}^{(S)}$（浮点数）。\n  2. $\\nu = 0.4999$ 时方案 S 的 $n_{\\text{near-}0}$（整数）。\n  3. $\\nu = 0.4999$ 时方案 R 的 $n_{\\text{near-}0}$（整数）。\n  4. $r_F$（浮点数）。\n  5. $r_S$（浮点数）。\n\n所有相关角度均以弧度为单位；但此问题中不需要角度量。最终答案中不需要物理单位，因为 $E$ 和几何尺寸是无量纲的。输出必须严格遵循所述的列表格式，例如 $[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$。",
            "solution": "用户的问题陈述已经过分析和验证。它构成了偏微分方程有限元分析领域内一个适定的、具有科学依据的计算任务。该问题是自包含的，所有必要的物理参数、几何规格、边界条件和数值程序都已明确定义。目标是量化的、明确的。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n此问题的核心是为平面应变条件下的线弹性问题实现一个二维有限元模型。目标是研究数值闭锁，这是一种在处理近不可压缩材料（即泊松比 $\\nu \\to 0.5$）时低阶单元中常见的病态问题。本研究的重点是比较用于计算单元刚度矩阵 $\\boldsymbol{K}^{(e)}$ 的三种不同数值求积方案，并分析它们对全局刚度矩阵谱以及解对 $\\nu$ 的敏感性的影响。\n\n该方法包括以下步骤：\n1.  **离散化与公式化**：单位正方形域 $\\Omega = [0,1]^2$ 使用 $N_x \\times N_y = 8 \\times 8$ 的结构化双线性四边形（$Q_1$）单元网格进行离散化。每个节点有两个自由度（DOF），对应于水平（$u$）和垂直（$v$）位移。总节点数为 $(N_x+1)(N_y+1) = 81$，产生 $162$ 个自由度。\n\n2.  **单元级计算**：对于每个 $Q_1$ 单元，我们计算单元刚度矩阵 $\\boldsymbol{K}^{(e)}$ 和一致节点力向量 $\\boldsymbol{f}^{(e)}$。\n    单元刚度矩阵由单元域 $\\Omega_e$ 上的积分给出：\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    其中 $\\boldsymbol{B}$ 是将节点位移与应变关联的应变-位移矩阵，$\\boldsymbol{C}$ 是平面应变的本构矩阵。该积分在参考单元 $[-1,1] \\times [-1,1]$ 上使用 Gauss 求积进行数值计算。从参考坐标到物理坐标的变换雅可比行列式 $\\det(\\boldsymbol{J})$ 必须包含在被积函数中。对于尺寸为 $h_x \\times h_y$ 的矩形单元，$\\det(\\boldsymbol{J}) = h_x h_y / 4$。\n\n    问题指定将 $\\boldsymbol{C}$ 分解为偏量部分（$\\boldsymbol{C}_\\mu$）和体量部分（$\\boldsymbol{C}_\\lambda$），其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 是拉梅参数。\n    $$\n    \\boldsymbol{C}_{\\mu} = \\mu \\,\\begin{bmatrix} 2 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}, \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1 & 1 & 0 \\\\ 1 & 1 & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}\n    $$\n    单元刚度随后被计算为两个独立的积分，每个积分可能使用不同的求积法则：\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    三种方案是：\n    *   **方案 F（完全积分）**：对两项均使用 $2 \\times 2$ Gauss 求积。\n    *   **方案 S（选择性减缩）**：对 $\\boldsymbol{C}_\\mu$ 项使用 $2 \\times 2$ 求积，对 $\\boldsymbol{C}_\\lambda$ 项使用 $1 \\times 1$ 求积。\n    *   **方案 R（完全减缩）**：对两项均使用 $1 \\times 1$ 求积。\n\n    由体力 $\\boldsymbol{b}$ 产生的单元力向量为：\n    $$\n    \\boldsymbol{f}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{N}^\\top \\boldsymbol{b} \\, \\mathrm{d}\\Omega\n    $$\n    其中 $\\boldsymbol{N}$ 是形函数矩阵。该积分使用 $2 \\times 2$ Gauss 法则计算。\n\n3.  **组装与边界条件**：单元矩阵和向量被组装成一个全局线性方程组 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{f}$。齐次本质边界条件（$u=v=0$）施加在左边界（$x=0$）上的所有节点上。这是通过识别与这些节点对应的自由度，并从全局系统中删除相应的行和列来完成的，从而得到一个约简系统 $\\boldsymbol{K}_{\\text{red}}\\boldsymbol{d}_{\\text{red}} = \\boldsymbol{f}_{\\text{red}}$。\n\n4.  **谱分析**：对于 $\\nu=0.4999$ 下的方案 S 和 R，计算约简刚度矩阵 $\\boldsymbol{K}_{\\text{red}}$ 的特征值。伪零能模式（沙漏模式）表现为 $\\boldsymbol{K}_{\\text{red}}$ 中的零或近零特征值。我们计算满足 $\\lambda_i  \\tau \\lambda_{\\max}$ 的特征值数量 $\\lambda_i$，其中 $\\tau=10^{-8}$ 是一个小的容差。对于一个稳定的方案，这个计数应该为零，并且最小特征值 $\\lambda_{\\min}$ 应该是严格为正的。\n\n5.  **闭锁分析**：对于方案 F 和 S，在 $\\nu=0.3$ 和 $\\nu=0.4999$ 时求解约简线性系统以获得位移向量 $\\boldsymbol{d}_{\\text{red}}$。体积闭锁的特征是当 $\\nu \\to 0.5$ 时出现人为的过刚响应。这通过比率 $r = \\|\\boldsymbol{d}\\|_2(\\nu=0.4999) / \\|\\boldsymbol{d}\\|_2(\\nu=0.3)$ 来量化，其中 $\\|\\cdot\\|_2$ 是完整位移向量的欧几里得范数。一个远小于 $1$ 的比率表示存在闭锁，而一个接近 $1$ 的比率表示该方案成功地缓解了闭锁。\n\n该实现将这些步骤封装在一个单独的 Python 脚本中。为单元级计算和系统组装定义了辅助函数。脚本的主要部分协调了针对不同方案和泊松比所需的分析，并按规定格式化最终结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Performs a spectral and locking analysis of Q1 finite elements for plane strain elasticity.\n    \"\"\"\n    # ------------------\n    # --- Parameters ---\n    # ------------------\n    Nx, Ny = 8, 8\n    E = 1.0\n    nu_spectral = 0.4999\n    nu_locking = [0.3, 0.4999]\n    tau = 1e-8\n    body_force_vec = np.array([1.0, 0.0])\n\n    # ------------------------\n    # --- Mesh and DOF Setup ---\n    # ------------------------\n    hx, hy = 1.0 / Nx, 1.0 / Ny\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    # -------------------------------------\n    # --- Boundary Condition Definition ---\n    # -------------------------------------\n    clamped_node_indices = [iy * num_nodes_x for iy in range(num_nodes_y)]\n    clamped_dofs = []\n    for node_idx in clamped_node_indices:\n        clamped_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, clamped_dofs, assume_unique=True)\n\n    # ------------------------------\n    # --- FEM Helper Functions ---\n    # ------------------------------\n    # Quadrature points and weights for reference element [-1, 1]^2\n    p = 1.0 / np.sqrt(3.0)\n    gp_2x2 = [(-p, -p, 1.0), (p, -p, 1.0), (p, p, 1.0), (-p, p, 1.0)]\n    gp_1x1 = [(0.0, 0.0, 4.0)]\n\n    def get_B_matrix(xi, eta):\n        # Derivatives of shape functions w.r.t. xi, eta for nodes 0-3 (CCW from bottom-left)\n        dN_d_xi_eta = 0.25 * np.array([\n            [-(1.0 - eta), -(1.0 - xi)],\n            [ (1.0 - eta), -(1.0 + xi)],\n            [ (1.0 + eta),  (1.0 + xi)],\n            [-(1.0 + eta),  (1.0 - xi)]\n        ])\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            dNi_dx = dN_d_xi_eta[i, 0] * 2.0 / hx\n            dNi_dy = dN_d_xi_eta[i, 1] * 2.0 / hy\n            \n            B[0, 2 * i]     = dNi_dx\n            B[1, 2 * i + 1] = dNi_dy\n            B[2, 2 * i]     = dNi_dy\n            B[2, 2 * i + 1] = dNi_dx\n        return B\n\n    def get_element_matrices(nu, scheme):\n        # Material properties\n        mu = E / (2.0 * (1.0 + nu))\n        lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        \n        C_mu = mu * np.array([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]])\n        C_lambda = lmbda * np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0]])\n\n        quad_map = {'F': (gp_2x2, gp_2x2), 'S': (gp_2x2, gp_1x1), 'R': (gp_1x1, gp_1x1)}\n        quad_mu, quad_lambda = quad_map[scheme]\n        \n        detJ = (hx * hy) / 4.0\n        \n        Ke_mu = np.zeros((8, 8))\n        for xi, eta, w in quad_mu:\n            B = get_B_matrix(xi, eta)\n            Ke_mu += B.T @ C_mu @ B * w * detJ\n\n        Ke_lambda = np.zeros((8, 8))\n        for xi, eta, w in quad_lambda:\n            B = get_B_matrix(xi, eta)\n            Ke_lambda += B.T @ C_lambda @ B * w * detJ\n        \n        Ke = Ke_mu + Ke_lambda\n        \n        fe = np.zeros(8)\n        # Force vector is always computed with 2x2 quadrature\n        for xi, eta, w in gp_2x2:\n            N_vals = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n            N_matrix = np.zeros((2, 8))\n            N_matrix[0, 0::2] = N_vals\n            N_matrix[1, 1::2] = N_vals\n            fe += N_matrix.T @ body_force_vec * w * detJ\n        \n        return Ke, fe\n\n    def assemble(nu, scheme):\n        K_global = np.zeros((num_dofs, num_dofs))\n        F_global = np.zeros(num_dofs)\n        \n        # Optimization: Ke and fe are the same for all elements in a structured mesh\n        Ke, fe = get_element_matrices(nu, scheme)\n        \n        for ey in range(Ny):\n            for ex in range(Nx):\n                node_indices = [\n                    ey * num_nodes_x + ex,\n                    ey * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex\n                ]\n                \n                dof_map = np.empty(8, dtype=int)\n                for i in range(4):\n                    dof_map[2*i]   = 2 * node_indices[i]\n                    dof_map[2*i+1] = 2 * node_indices[i] + 1\n                \n                ix_ = np.ix_(dof_map, dof_map)\n                K_global[ix_] += Ke\n                F_global[dof_map] += fe\n\n        return K_global, F_global\n\n    # -----------------------\n    # --- Main Analysis ---\n    # -----------------------\n\n    # --- Part 1: Spectral Zero-Mode Test (nu = 0.4999) ---\n    \n    # Scheme S\n    K_global_S, _ = assemble(nu=nu_spectral, scheme='S')\n    K_reduced_S = K_global_S[np.ix_(free_dofs, free_dofs)]\n    eigvals_S = linalg.eigh(K_reduced_S, eigvals_only=True)\n    lambda_min_S = eigvals_S[0]\n    n_near_0_S = np.sum(eigvals_S  tau * eigvals_S[-1])\n\n    # Scheme R\n    K_global_R, _ = assemble(nu=nu_spectral, scheme='R')\n    K_reduced_R = K_global_R[np.ix_(free_dofs, free_dofs)]\n    eigvals_R = linalg.eigh(K_reduced_R, eigvals_only=True)\n    n_near_0_R = np.sum(eigvals_R  tau * eigvals_R[-1])\n\n    # --- Part 2: Locking Sensitivity Test ---\n    u_norms = {}\n    for scheme in ['F', 'S']:\n        for nu in nu_locking:\n            K_global, F_global = assemble(nu=nu, scheme=scheme)\n\n            K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n            F_reduced = F_global[free_dofs]\n            \n            u_reduced = linalg.solve(K_reduced, F_reduced, assume_a='sym')\n            \n            u_full = np.zeros(num_dofs)\n            u_full[free_dofs] = u_reduced\n            u_norm = linalg.norm(u_full)\n            u_norms[(scheme, nu)] = u_norm\n            \n    r_F = u_norms[('F', 0.4999)] / u_norms[('F', 0.3)]\n    r_S = u_norms[('S', 0.4999)] / u_norms[('S', 0.3)]\n\n    # --- Part 3: Format and Print Output ---\n    results = [lambda_min_S, int(n_near_0_S), int(n_near_0_R), r_F, r_S]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "锁定并非总是局限于单个“刚性”单元的局部问题，本练习将探讨数值约束的非局部传播特性。通过一个简单的双单元模型（其中只有一个单元是近乎不可压缩的），你将研究在标准位移公式中，体积约束是如何“泄漏”到相邻的可压缩单元中的。通过将此行为与能够正确定位约束的局部拉格朗日乘子法进行比较，你将对锁定作为一种全局现象获得更深刻的理解，并明白为何某些公式会导致远离刚度源的非物理结果。",
            "id": "3418018",
            "problem": "您需要设计并实现一个数值实验，以揭示当类不可压缩约束仅应用于域的一部分时，有限元法 (FEM) 在线性弹性分析中出现的锁定现象。该数值实验必须比较纯位移法和一种混合法，后者在单元子集上通过局部拉格朗日乘子强制施加体积约束。您的程序必须计算定量指标，以验证锁定是否已将体积约束传播到无约束区域，以及局部拉格朗日乘子强制法是否能阻止这种非物理性的全局扩散。\n\n推导的基本基础必须是最小势能原理以及标准的小应变弹性线性化运动学和本构方程。在平面应变条件下，小应变张量定义为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\top})$，柯西应力为 $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$，其中 $\\mu$ 和 $\\lambda$ 是拉梅参数。纯位移法的弱形式源于弹性势能和表面牵引力功的一阶变分，而混合法引入一个标量压力场 $p$ 作为拉格朗日乘子，仅在指定单元上强制施加不可压缩约束 $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = 0$。\n\n计算域为矩形 $\\Omega = [0,L]\\times[0,H]$，其中 $L = 1$ 且 $H = 1$。它被离散为两个水平对齐的双线性四边形单元：左侧单元覆盖 $[0,L/2]\\times[0,H]$，右侧单元覆盖 $[L/2,L]\\times[0,H]$。共有 $(3)\\times(2) = 6$ 个节点，每个节点带有两个位移自由度（分量 $u_x$ 和 $u_y$）。左边界 $\\{x=0\\}$ 是固支的：$u_x = 0$ 且 $u_y = 0$。在右边界 $\\{x=L\\}$ 上施加均匀牵引力 $\\boldsymbol{t} = (t_x,0)$。顶部和底部边界是无牵引力的。所有量都应视为无量纲单位。\n\n您必须实现：\n- 一种纯位移 FEM，其单元刚度源自双线性等参映射和 $2\\times 2$ 高斯积分。通过为左侧单元选择一个非常大的 $\\lambda$（体积刚度）使其接近不可压缩，而右侧单元则使用一个适中的 $\\lambda$ 保持可压缩性。剪切模量 $\\mu$ 是均匀的。\n- 一种混合 FEM，通过为每个受约束单元引入一个压力自由度和一个拉格朗日乘子约束 $\\int_{\\text{left element}}(\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega = 0$，仅在左侧单元上局部强制不可压缩性。在受约束单元中，位移刚度必须排除体积部分（设置 $\\lambda = 0$），仅保留剪切贡献。在无约束单元中，使用标准的、具有指定 $\\lambda$ 和 $\\mu$ 的可压缩刚度。\n\n从第一性原理出发，从带有表面牵引力的平衡变分陈述开始，使用双线性形函数离散位移场，为平面应变构建单元应变-位移矩阵 $B$ 和材料刚度矩阵 $D$，为两种方法组装全局刚度矩阵，通过消去固定自由度来施加狄利克雷边界条件，并求解线性系统。对于混合法，组装鞍点系统\n$$\n\\begin{bmatrix}\nK_{uu}  B^{\\top} \\\\\nB  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{f} \\\\\n\\boldsymbol{0}\n\\end{bmatrix},\n$$\n其中单行矩阵 $B$ 包含使用相同高斯积分在受约束单元上对 $\\nabla\\cdot\\boldsymbol{u}$ 进行积分的系数，而 $\\boldsymbol{p}$ 是单元级的压力拉格朗日乘子。\n\n对于每个测试用例，计算以下定量输出：\n- 在纯位移（罚函数）法中，尖端位移 $u_{\\text{tip}}^{\\text{pen}}$，定义为两个右边缘节点的平均 $x$ 向位移。\n- 在对左侧单元使用局部拉格朗日乘子的混合法中，尖端位移 $u_{\\text{tip}}^{\\text{mix}}$。\n- 在纯位移法中，积分散度 $\\mathcal{D}_{\\text{right}}^{\\text{pen}} = \\int_{\\text{right element}} (\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega$。\n- 在混合法中，积分散度 $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$。\n- 一个布尔泄漏指标 $\\beta$，如果 $|\\mathcal{D}_{\\text{right}}^{\\text{pen}}|  \\tfrac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|$ 则等于 $\\text{True}$，这证明体积约束在纯位移法中非物理性地传播到了无约束的右侧单元（锁定），否则为 $\\text{False}$。\n\n您的程序必须实现以下测试套件，涵盖一般情况、接近不可压缩的边界情况和无约束的边缘情况：\n- 情况 A（一般）：$\\lambda_{\\text{left}} = 10^{4}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$， $t_x = 1$，在混合法中左侧单元受约束。\n- 情况 B（接近不可压缩）：$\\lambda_{\\text{left}} = 10^{7}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$， $t_x = 1$，在混合法中左侧单元受约束。\n- 情况 C（边缘情况）：$\\lambda_{\\text{left}} = 10^{-1}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$， $t_x = 1$，在混合法中无受约束单元。\n\n所有输出都必须以无量纲单位表示。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，每个测试用例的结果本身也是方括号括起来的逗号分隔列表，顺序为 $[u_{\\text{tip}}^{\\text{pen}}, u_{\\text{tip}}^{\\text{mix}}, \\mathcal{D}_{\\text{right}}^{\\text{pen}}, \\mathcal{D}_{\\text{right}}^{\\text{mix}}, \\beta]$。例如，格式必须类似于 $[[a_1,a_2,a_3,a_4,b_1],[c_1,c_2,c_3,c_4,b_2],[\\dots]]$。",
            "solution": "该问题陈述构成了一个在计算固体力学领域中有效且适定的数值实验。它在科学上基于线性弹性理论和有限元法 (FEM)，其表述是客观的，并提供了一套完整的参数和条件来复现指定的分析。任务是演示低阶有限元中的体积锁定现象及其使用混合法的缓解方法。\n\n我们将首先建立纯位移（罚函数）法和混合法共有的理论框架。然后，我们将详细介绍每种方法的具体细节，包括单元矩阵的构建、全局系统的组装、边界条件的施加以及所需输出指标的计算。\n\n### 1. 线性弹性基本方程（平面应变）\n\n分析基于最小势能原理。对于占据域 $\\Omega$ 的线性弹性体，平衡位移场 $\\boldsymbol{u} = (u_x, u_y)$ 是使总势能 $\\Pi(\\boldsymbol{u})$ 最小化的位移场。该问题在平面应变条件（$\\varepsilon_{zz} = 0$）下考虑。\n\n应变-位移关系由位移场的对称梯度给出：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^{\\top}) $$\n使用 Voigt 记法表示应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$，其中 $\\gamma_{xy} = 2\\varepsilon_{xy}$。\n\n将应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ 与应变向量联系起来的本构关系是 $\\boldsymbol{\\sigma} = \\boldsymbol{D}\\boldsymbol{\\varepsilon}$。对于平面应变下的各向同性材料，材料刚度矩阵 $\\boldsymbol{D}$ 为：\n$$\n\\boldsymbol{D} =\n\\begin{bmatrix}\n\\lambda+2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda+2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\n其中 $\\mu$ 和 $\\lambda$ 是拉梅参数。\n\n### 2. 有限元离散化\n\n域 $\\Omega = [0,L]\\times[0,H]$（其中 $L=1$ 和 $H=1$）被离散为两个矩形双线性四边形单元。节点编号如下：\n- 节点 1: $(0, 0)$\n- 节点 2: $(L/2, 0)$\n- 节点 3: $(L, 0)$\n- 节点 4: $(0, H)$\n- 节点 5: $(L/2, H)$\n- 节点 6: $(L, H)$\n\n左单元 $\\Omega_1$ 由节点 $(1, 2, 5, 4)$ 组成。右单元 $\\Omega_2$ 由节点 $(2, 3, 6, 5)$ 组成。6 个节点中的每一个都有两个位移自由度 (DOF)，$u_x$ 和 $u_y$，总共有 12 个自由度。\n\n在每个单元内，位移场 $\\boldsymbol{u}$ 使用局部等参坐标系 $(\\xi, \\eta) \\in [-1, 1]\\times[-1, 1]$ 中的双线性形函数 $N_a(\\xi, \\eta)$ 进行近似：\n$$ \\boldsymbol{u}^h(\\xi, \\eta) = \\sum_{a=1}^{4} N_a(\\xi, \\eta) \\boldsymbol{d}_a $$\n其中 $\\boldsymbol{d}_a = [u_{ax}, u_{ay}]^{\\top}$ 是单元四个节点的节点位移。形函数为 $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$，其中 $(\\xi_a, \\eta_a)$ 是节点的局部坐标。\n\n离散的应变-位移关系为 $\\boldsymbol{\\varepsilon} = \\boldsymbol{B}\\boldsymbol{d}^e$，其中 $\\boldsymbol{d}^e$ 是单元节点自由度的 $8\\times 1$ 向量。应变-位移矩阵 $\\boldsymbol{B}$ 是一个 $3 \\times 8$ 矩阵，由形函数的空间导数构成：\n$$ \\boldsymbol{B}_a = \\begin{bmatrix} \\frac{\\partial N_a}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_a}{\\partial y} \\\\ \\frac{\\partial N_a}{\\partial y}  \\frac{\\partial N_a}{\\partial x} \\end{bmatrix}, \\quad \\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4] $$\n相对于全局坐标 $(x,y)$ 的导数通过链式法则，利用等参映射的雅可比矩阵 $\\boldsymbol{J}$ 获得：\n$$ \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta} \\end{Bmatrix} $$\n对于此问题中的矩形单元，$\\boldsymbol{J} = \\text{diag}(L/4, H/2)$，其行列式为 $\\det(\\boldsymbol{J}) = LH/8$。\n\n### 3. 纯位移（罚函数）法\n\n单元刚度矩阵 $\\boldsymbol{K}^e$ 源自应变能，并通过在单元域上积分计算得出：\n$$ \\boldsymbol{K}^e = \\int_{\\Omega^e} \\boldsymbol{B}^{\\top} \\boldsymbol{D} \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\n该积分使用 $2 \\times 2$ 高斯积分进行数值计算。单元刚度矩阵被组装成一个 $12 \\times 12$ 的全局刚度矩阵 $\\boldsymbol{K}$。\n\n外力来自于右边界 $\\{x=L, 0 \\le y \\le H\\}$ 上的牵引力 $\\boldsymbol{t} = (t_x, 0)$。该边界对应于右单元的节点 3 和 6 之间的边。一致节点力向量 $\\boldsymbol{f}^e$ 为：\n$$ \\boldsymbol{f}^e = \\int_{\\Gamma_t^e} \\boldsymbol{N}^{\\top} \\boldsymbol{t} \\, \\mathrm{d}S $$\n其中 $\\boldsymbol{N}$ 是形函数矩阵。积分表明，牵引力在节点 3 和 6 的 $x$ 方向上产生大小为 $t_x H / 2$ 的力。对于 $t_x=1$ 和 $H=1$，这些力为 $0.5$。全局力向量 $\\boldsymbol{F}$ 包含这两个非零项。\n\n狄利克雷边界条件施加在固支的左边界（$x=0$）上，其中节点 1 和 4 的位移固定为零（$u_{1x}=u_{1y}=u_{4x}=u_{4y}=0$）。这些自由度从全局系统中消去，得到一个简化的系统 $\\boldsymbol{K}_{red}\\boldsymbol{d}_{free} = \\boldsymbol{F}_{free}$，求解该系统可得到未知的节点位移 $\\boldsymbol{d}_{free}$。\n\n在这种方法中，左单元的近不可压缩性是通过为一个非常大的 $\\lambda_{\\text{left}}$ 值来建模的，该值作为体积应变 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ 的罚参数。\n\n### 4. 混合法\n\n为缓解锁定，引入了混合法。添加一个分片常数压力场 $p$ 作为拉格朗日乘子，仅在指定的受约束单元上强制施加不可压缩约束 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})=0$。对于此问题，为左单元引入单个压力自由度 $p_1$。\n\n势能泛函被修改为鞍点泛函：\n$$ \\Pi(\\boldsymbol{u}, p_1) = \\int_{\\Omega} \\frac{1}{2}\\boldsymbol{\\sigma}(\\boldsymbol{u}):\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, \\mathrm{d}\\Omega - \\int_{\\Gamma_t} \\boldsymbol{t}\\cdot\\boldsymbol{u} \\, \\mathrm{d}S - \\int_{\\Omega_1} p_1 \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u})) \\, \\mathrm{d}\\Omega $$\n对于受约束的单元 ($\\Omega_1$)，通过将其 $\\lambda$ 设置为 0，从内能项中移除了刚度的体积部分。对于无约束的单元 ($\\Omega_2$)，使用标准的可压缩刚度。\n\n离散化导致以下分块矩阵系统：\n$$\n\\begin{bmatrix}\n\\boldsymbol{K}_{uu}  \\boldsymbol{G}^{\\top} \\\\\n\\boldsymbol{G}  \\boldsymbol{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{F} \\\\\n\\boldsymbol{0}\n\\end{bmatrix}\n$$\n- $\\boldsymbol{K}_{uu}$ 是由单元贡献组装的全局刚度矩阵。对于受约束的左单元，$\\boldsymbol{D}$ 使用 $\\lambda=0$ 进行评估。对于无约束的右单元，使用标准的 $\\boldsymbol{D}$。\n- $\\boldsymbol{p}$ 是压力自由度向量，这里只是标量 $p_1$。\n- $\\boldsymbol{G}$ 是离散梯度算子（耦合矩阵），源自约束项。对于单元 $\\Omega_1$ 上的单个约束：\n$$ \\boldsymbol{G}_{1,j} \\boldsymbol{u}_j = p_1 \\int_{\\Omega_1} \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h)) \\, \\mathrm{d}\\Omega $$\n行向量 $\\boldsymbol{G}$（在问题描述中记为 $B$）计算如下：\n$$ \\boldsymbol{G} = \\int_{\\Omega_1} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\n该积分也使用 $2 \\times 2$ 高斯积分进行计算。\n\n完整的系统（对于情况 A 和 B，大小为 $13 \\times 13$）被组装起来。通过消元法施加边界条件，并求解得到的简化系统以获得自由位移自由度和压力 $p_1$。对于情况 C，由于没有约束，此方法与纯位移法相同。\n\n### 5. 输出指标\n\n在求解得到两种方法的节点位移（$\\boldsymbol{d}^{\\text{pen}}$ 和 $\\boldsymbol{d}^{\\text{mix}}$）后，我们计算所需的输出：\n- **尖端位移** $u_{\\text{tip}}$：右边缘节点（节点 3 和 6）的 $x$ 向位移的平均值。\n$$ u_{\\text{tip}} = \\frac{1}{2}(u_{3x} + u_{6x}) $$\n- **积分散度** $\\mathcal{D}_{\\text{right}}$：体积应变在右单元上的积分。\n$$ \\mathcal{D}_{\\text{right}} = \\int_{\\Omega_2} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathrm{d}\\Omega = \\left(\\int_{\\Omega_2} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega \\right) \\boldsymbol{d}^e_{\\text{right}} $$\n其中 $\\boldsymbol{d}^e_{\\text{right}}$ 是右单元的节点位移。此量对两种方法都进行计算。\n- **泄漏指标** $\\beta$：一个布尔值，指示罚函数法是否在无约束单元上引起显著的伪体积约束。\n$$ \\beta = (|\\mathcal{D}_{\\text{right}}^{\\text{pen}}|  \\frac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|) $$\n在罚函数法中（情况 A 和 B），预计会发生锁定，这将表现为一个人为的小 $u_{\\text{tip}}^{\\text{pen}}$ 和一个接近零的 $\\mathcal{D}_{\\text{right}}^{\\text{pen}}$。混合法应能缓解此问题，产生更大的尖端位移和物理上合理的、非零的 $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$。这将导致 $\\beta = \\text{True}$。情况 C 作为基线，其中两种方法应产生相同的结果且 $\\beta = \\text{False}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as linsolve\n\ndef get_shape_fns_and_derivs(xi, eta):\n    \"\"\"\n    Computes bilinear shape functions and their derivatives in local coords.\n    Nodes are ordered anti-clockwise from bottom-left (-1, -1).\n    \"\"\"\n    # Shape functions\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),\n        (1 + xi) * (1 - eta),\n        (1 + xi) * (1 + eta),\n        (1 - xi) * (1 + eta)\n    ])\n    # Derivatives w.r.t. local coordinates (xi, eta)\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef assemble_fem_matrices(lambda_val, mu, elem_width, elem_height):\n    \"\"\"\n    Computes element stiffness matrix Ke, coupling vector G.\n    \"\"\"\n    elem_dofs = 8\n    Ke = np.zeros((elem_dofs, elem_dofs))\n    G = np.zeros(elem_dofs) # for mixed formulation\n    \n    # 2x2 Gaussian quadrature\n    gp_locs = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gp_weights = [1.0, 1.0]\n    \n    # Plane strain material stiffness matrix D\n    D = np.array([\n        [lambda_val + 2 * mu, lambda_val, 0],\n        [lambda_val, lambda_val + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    for i, wi in enumerate(gp_weights):\n        for j, wj in enumerate(gp_weights):\n            xi, eta = gp_locs[j], gp_locs[i]\n            _, dN_dxi, dN_deta = get_shape_fns_and_derivs(xi, eta)\n            \n            # Jacobian matrix for an axis-aligned rectangle\n            J = np.array([\n                [elem_width / 2.0, 0],\n                [0, elem_height / 2.0]\n            ])\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Derivatives w.r.t. global coordinates (x,y)\n            dN_dxy = invJ @ np.vstack((dN_dxi, dN_deta))\n            dN_dx = dN_dxy[0, :]\n            dN_dy = dN_dxy[1, :]\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, elem_dofs))\n            for k in range(4):\n                B[0, 2*k] = dN_dx[k]\n                B[1, 2*k+1] = dN_dy[k]\n                B[2, 2*k] = dN_dy[k]\n                B[2, 2*k+1] = dN_dx[k]\n            \n            Ke += B.T @ D @ B * detJ * wi * wj\n            \n            g_vec = np.array([1, 1, 0])\n            G += g_vec @ B * detJ * wi * wj\n            \n    return Ke, G\n\ndef solve_case(lambda_left, lambda_right, mu, tx, constrained):\n    L, H = 1.0, 1.0\n    num_nodes = 6\n    total_dofs = num_nodes * 2\n\n    elem_connectivity = [\n        [0, 1, 4, 3],  # Left element (nodes 1, 2, 5, 4)\n        [1, 2, 5, 4]   # Right element (nodes 2, 3, 6, 5)\n    ]\n    \n    dof_map_left = np.array([[2*i, 2*i+1] for i in elem_connectivity[0]]).flatten()\n    dof_map_right = np.array([[2*i, 2*i+1] for i in elem_connectivity[1]]).flatten()\n\n    # ----- Displacement-only (Penalty) Formulation -----\n    K_pen = np.zeros((total_dofs, total_dofs))\n    \n    Ke_left_pen, _ = assemble_fem_matrices(lambda_left, mu, L/2, H)\n    K_pen[np.ix_(dof_map_left, dof_map_left)] += Ke_left_pen\n\n    Ke_right_pen, G_right_pen_elem = assemble_fem_matrices(lambda_right, mu, L/2, H)\n    K_pen[np.ix_(dof_map_right, dof_map_right)] += Ke_right_pen\n\n    F_pen = np.zeros(total_dofs)\n    F_pen[2*2 + 0] += tx * H / 2.0  # Force on node 3 (x-dir)\n    F_pen[2*5 + 0] += tx * H / 2.0  # Force on node 6 (x-dir)\n\n    fixed_dofs = [0, 1, 6, 7] # DOFs for nodes 1 and 4\n    free_dofs = np.setdiff1d(np.arange(total_dofs), fixed_dofs)\n    \n    K_red_pen = K_pen[np.ix_(free_dofs, free_dofs)]\n    F_red_pen = F_pen[free_dofs]\n    \n    u_red_pen = linsolve(K_red_pen, F_red_pen)\n    \n    u_pen = np.zeros(total_dofs)\n    u_pen[free_dofs] = u_red_pen\n\n    # ----- Mixed Formulation -----\n    num_pressure_dofs = 1 if constrained else 0\n    sys_size = total_dofs + num_pressure_dofs\n    A_mix = np.zeros((sys_size, sys_size))\n    b_mix = np.zeros(sys_size)\n\n    lambda_left_mix = 0.0 if constrained else lambda_left\n    Ke_left_mix, G_left_mix_elem = assemble_fem_matrices(lambda_left_mix, mu, L/2, H)\n    A_mix[np.ix_(dof_map_left, dof_map_left)] += Ke_left_mix\n    \n    Ke_right_mix, G_right_mix_elem = assemble_fem_matrices(lambda_right, mu, L/2, H)\n    A_mix[np.ix_(dof_map_right, dof_map_right)] += Ke_right_mix\n\n    if constrained:\n        pressure_dof_idx = total_dofs\n        A_mix[pressure_dof_idx, dof_map_left] = G_left_mix_elem\n        A_mix[dof_map_left, pressure_dof_idx] = G_left_mix_elem\n\n    b_mix[:total_dofs] = F_pen\n\n    all_sys_dofs = np.arange(sys_size)\n    free_sys_dofs = np.concatenate([free_dofs, np.arange(total_dofs, sys_size)])\n    \n    A_red_mix = A_mix[np.ix_(free_sys_dofs, free_sys_dofs)]\n    b_red_mix = b_mix[free_sys_dofs]\n\n    sol_red_mix = linsolve(A_red_mix, b_red_mix)\n    \n    u_mix = np.zeros(total_dofs)\n    u_mix[free_dofs] = sol_red_mix[:len(free_dofs)]\n\n    # ----- Compute Outputs -----\n    u_tip_pen = (u_pen[2*2 + 0] + u_pen[2*5 + 0]) / 2.0\n    u_tip_mix = (u_mix[2*2 + 0] + u_mix[2*5 + 0]) / 2.0\n    \n    u_elem_right_pen = u_pen[dof_map_right]\n    D_right_pen = G_right_pen_elem @ u_elem_right_pen\n\n    u_elem_right_mix = u_mix[dof_map_right]\n    D_right_mix = G_right_mix_elem @ u_elem_right_mix\n    \n    beta = False\n    # Avoid division by zero and check for meaningful comparison\n    if abs(D_right_mix) > 1e-15:\n        if abs(D_right_pen)  0.5 * abs(D_right_mix):\n            beta = True\n\n    return [u_tip_pen, u_tip_mix, D_right_pen, D_right_mix, beta]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (general)\n        {'lambda_left': 1e4, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case B (near-incompressible)\n        {'lambda_left': 1e7, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case C (edge case)\n        {'lambda_left': 1e-1, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(result)\n\n    output_str = \"[\" + \",\".join([\n        \"[\" + \",\".join([f\"{v:.6f}\" if isinstance(v, float) else str(v) for v in res]) + \"]\"\n        for res in results\n    ]) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}