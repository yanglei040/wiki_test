{
    "hands_on_practices": [
        {
            "introduction": "A fundamental requirement for any numerical stabilization scheme is that it must not penalize the underlying physical behavior of the system. This practice provides a hands-on verification of this principle for hourglass control by confirming its orthogonality to rigid-body motions. By implementing the algebraic definition of an hourglass mode , you will numerically demonstrate that the control mechanism remains inactive during rigid translations and rotations, a cornerstone property that ensures its physical consistency.",
            "id": "3555163",
            "problem": "You are asked to implement, from first principles, a verification that hourglass control forces constructed for a two-dimensional, four-node bilinear quadrilateral finite element with single-point (reduced) integration do not spuriously activate under rigid-body motions. Work in the context of the Finite Element Method (FEM) and consider linearized kinematics appropriate for small strains and small rotations. The core quantity to evaluate is an hourglass generalized coordinate vector $\\mathbf{q}_{\\alpha}$ that must vanish for any rigid-body translation and any rigid-body rotation. Your task is to define an element-level hourglass vector $\\mathbf{g}$ that annihilates all discrete fields that are linear in physical coordinates, construct $\\mathbf{q}_{\\alpha}$ for given nodal displacements, and verify that $\\lVert \\mathbf{q}_{\\alpha} \\rVert_{2}$ is zero (to numerical precision) for rigid motions.\n\nStart from the following fundamental bases:\n- Finite Element Method (FEM) interpolation completeness in physical space: any field that is linear in the physical coordinates $x$ and $y$ can be represented at the element level as $u(x,y)=a_{0}+a_{1}x+a_{2}y$.\n- Partition of unity and linear field reproduction for bilinear shape functions ensure that rigid-body translations and rigid-body rotations are linear fields in the small-rotation sense. A small rigid-body rotation by angle $\\theta$ (in radians) about a point $(x_{0},y_{0})$ induces a displacement field $\\mathbf{u}(x,y)=\\theta[-(y-y_{0}),\\,(x-x_{0})]$.\n- Reduced integration at a single quadrature point admits spurious element-level zero-energy (hourglass) modes, whose algebraic characterization can be constructed by enforcing orthogonality to the polynomial space $\\operatorname{span}\\{1,x,y\\}$ evaluated at the element nodes.\n\nDefinitions and construction:\n1. Consider a two-dimensional four-node bilinear quadrilateral with nodes indexed $i\\in\\{1,2,3,4\\}$ and physical coordinates $(x_{i},y_{i})$. Define the $4\\times 3$ matrix\n   $$\\mathbf{P}=\\begin{bmatrix}\n   1 & x_{1} & y_{1}\\\\\n   1 & x_{2} & y_{2}\\\\\n   1 & x_{3} & y_{3}\\\\\n   1 & x_{4} & y_{4}\n   \\end{bmatrix}.$$\n   Let $\\mathbf{g}\\in\\mathbb{R}^{4}$ be any nonzero vector satisfying\n   $$\\mathbf{P}^{\\top}\\mathbf{g}=\\mathbf{0},$$\n   and then normalize it to unit Euclidean norm so that $\\lVert \\mathbf{g}\\rVert_{2}=1$. This choice enforces discrete orthogonality to all linear fields in $x$ and $y$ and to constants, independently of element distortion. You may compute $\\mathbf{g}$ by taking the left nullspace of $\\mathbf{P}$, for example via a singular value decomposition.\n2. For nodal displacements $\\{\\mathbf{u}_{i}\\}_{i=1}^{4}$ with components $\\mathbf{u}_{i}=[u_{i}^{x},u_{i}^{y}]^{\\top}$, define the hourglass generalized coordinates\n   $$q_{x}=\\sum_{i=1}^{4}g_{i}\\,u_{i}^{x},\\qquad q_{y}=\\sum_{i=1}^{4}g_{i}\\,u_{i}^{y},\\qquad \\mathbf{q}_{\\alpha}=\\begin{bmatrix}q_{x}\\\\ q_{y}\\end{bmatrix}.$$\n   The hourglass control forces are proportional to $\\mathbf{q}_{\\alpha}$ in many schemes, so verifying $\\mathbf{q}_{\\alpha}=\\mathbf{0}$ under rigid motions ensures no spurious control forces for such motions.\n3. Verification target: Show numerically that $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}=0$ (up to floating-point tolerance) for rigid-body translations and rotations, and that $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}\\neq 0$ for a non-rigid hourglass-like pattern.\n\nAlgorithmic instructions your program must implement:\n- Given node coordinates $\\{(x_{i},y_{i})\\}_{i=1}^{4}$, construct $\\mathbf{P}$, compute a unit-norm vector $\\mathbf{g}$ in the left nullspace of $\\mathbf{P}$ (equivalently, the nullspace of $\\mathbf{P}^{\\top}$), and then evaluate $\\mathbf{q}_{\\alpha}$ for each specified displacement pattern.\n- Rigid-body translation by a vector $\\mathbf{t}=[t_{x},t_{y}]^{\\top}$ assigns $u_{i}^{x}=t_{x}$ and $u_{i}^{y}=t_{y}$ for all nodes $i$.\n- Small rigid-body rotation by angle $\\theta$ (angle specified in radians) about a chosen center $(x_{0},y_{0})$ assigns\n  $$u_{i}^{x}=\\theta\\left(-(y_{i}-y_{0})\\right),\\qquad u_{i}^{y}=\\theta\\left(x_{i}-x_{0}\\right).$$\n- Non-rigid hourglass-like displacement for a specific element uses the computed $\\mathbf{g}$ itself: assign $u_{i}^{x}=g_{i}$ and $u_{i}^{y}=-2g_{i}$ for all nodes $i$.\n\nTest suite:\n- Test case $1$ (translation on a general convex quadrilateral):\n  - Nodes: $\\{(0.0,0.0),(3.0,0.2),(2.7,1.8),(-0.1,1.5)\\}$.\n  - Displacement: translation $\\mathbf{t}=[0.7,-1.1]$.\n  - Output: the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$.\n- Test case $2$ (rotation about centroid on the same quadrilateral):\n  - Nodes: as in Test case $1$.\n  - Rotation center: centroid $(x_{0},y_{0})$ equal to the arithmetic mean of nodal coordinates.\n  - Angle: $\\theta=0.1$ radians.\n  - Output: the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$.\n- Test case $3$ (rotation about an external point on a skewed quadrilateral):\n  - Nodes: $\\{(0.0,0.0),(2.0,0.1),(2.2,0.5),(0.1,1.2)\\}$.\n  - Rotation center: $(x_{0},y_{0})=(0.0,0.0)$.\n  - Angle: $\\theta=-0.35$ radians.\n  - Output: the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$.\n- Test case $4$ (rotation on a slender parallelogram-like quadrilateral):\n  - Nodes: $\\{(0.0,0.0),(10.0,0.02),(10.5,0.05),(0.5,0.03)\\}$.\n  - Rotation center: centroid $(x_{0},y_{0})$ equal to the arithmetic mean of nodal coordinates.\n  - Angle: $\\theta=0.2$ radians.\n  - Output: the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$.\n- Test case $5$ (non-rigid hourglass-like displacement on the first quadrilateral):\n  - Nodes: as in Test case $1$.\n  - Displacement: $u_{i}^{x}=g_{i}$ and $u_{i}^{y}=-2g_{i}$, where $\\mathbf{g}$ is the normalized left-nullspace vector computed for these nodes.\n  - Output: the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$, which should equal $\\sqrt{5}$ up to floating-point roundoff if $\\lVert \\mathbf{g}\\rVert_{2}=1$.\n\nAngle unit specification: all angles $\\theta$ must be in radians. No physical units are required for coordinates or displacements; treat them as dimensionless.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, namely $[\\text{r}_{1},\\text{r}_{2},\\text{r}_{3},\\text{r}_{4},\\text{r}_{5}]$, where $\\text{r}_{k}$ is the scalar $\\lVert \\mathbf{q}_{\\alpha}\\rVert_{2}$ for Test case $k$.\n- Each scalar must be formatted in scientific notation with exactly $12$ digits after the decimal point (for example, $1.234000000000e-03$). Angles are in radians by construction.\n\nYour implementation must be a complete, runnable program that carries out the construction of $\\mathbf{g}$ via linear algebra and evaluates the results for the above test suite, aggregating them in the exact output format described.",
            "solution": "The core of this problem is to verify a fundamental property of hourglass control schemes for under-integrated finite elements: they must not generate spurious restoring forces under rigid-body motion. For a $2$-dimensional, $4$-node quadrilateral element using a single integration point (reduced integration), the stiffness matrix becomes rank-deficient, admitting non-physical, zero-energy deformation modes known as hourglass modes. An hourglass control scheme adds a stabilization term to the element's energy to suppress these modes. This stabilization is typically proportional to a set of hourglass generalized strains or coordinates, here denoted $\\mathbf{q}_{\\alpha}$. A crucial requirement is that these generalized coordinates must be zero for any rigid-body motion. This ensures that the control mechanism only acts on the spurious modes and does not incorrectly resist rigid translations or rotations. The verification relies on the algebraic construction of the hourglass modes.\n\nIn the context of the Finite Element Method (FEM), the shape functions for a bilinear quadrilateral element can exactly represent any displacement field that is a linear function of the spatial coordinates, i.e., of the form $\\mathbf{u}(x,y) = \\mathbf{a}_{0} + \\mathbf{a}_{1}x + \\mathbf{a}_{2}y$. This space of linear fields contains constant fields (rigid-body translations) and, for small deformations, linear fields corresponding to rigid-body rotations. The hourglass modes are, by definition, the modes of nodal displacement that are orthogonal to this space of linear fields.\n\nThe analytical and numerical verification proceeds as follows:\n\nFirst, we establish the basis for the linear fields evaluated at the element nodes. For a $4$-node element with physical coordinates $(x_{i}, y_{i})$ for $i \\in \\{1, 2, 3, 4\\}$, any linear field can be described by its values at the nodes. The matrix $\\mathbf{P}$ is constructed to represent the basis functions $\\{1, x, y\\}$ evaluated at each of the $4$ nodes:\n$$\n\\mathbf{P} = \\begin{bmatrix}\n1 & x_{1} & y_{1} \\\\\n1 & x_{2} & y_{2} \\\\\n1 & x_{3} & y_{3} \\\\\n1 & x_{4} & y_{4}\n\\end{bmatrix}\n$$\nThe columns of this $4 \\times 3$ matrix $\\mathbf{P}$ represent nodal vectors corresponding to a constant field, a field linear in $x$, and a field linear in $y$, respectively. For any non-degenerate quadrilateral, these three vectors are linearly independent, and so $\\mathbf{P}$ has rank $3$.\n\nThe hourglass vector, $\\mathbf{g} \\in \\mathbb{R}^{4}$, is defined as a vector that is discretely orthogonal to all linear fields. This is expressed algebraically by the condition that $\\mathbf{g}$ must be orthogonal to every column of $\\mathbf{P}$:\n$$\n\\mathbf{P}^{\\top}\\mathbf{g} = \\mathbf{0}\n$$\nThis means $\\mathbf{g}$ belongs to the nullspace of $\\mathbf{P}^{\\top}$. Since $\\mathbf{P}^{\\top}$ is a $3 \\times 4$ matrix of rank $3$, its nullspace has dimension $4 - 3 = 1$. This guarantees that the hourglass mode shape is unique up to a scalar multiple. We compute this vector $\\mathbf{g}$ (e.g., via Singular Value Decomposition of $\\mathbf{P}^{\\top}$) and normalize it to have a unit Euclidean norm, $\\lVert\\mathbf{g}\\rVert_{2}=1$.\n\nNext, we define the hourglass generalized coordinates. Given a set of nodal displacements in the $x$ and $y$ directions, collected into vectors $\\mathbf{u}^{x} = [u_{1}^{x}, u_{2}^{x}, u_{3}^{x}, u_{4}^{x}]^{\\top}$ and $\\mathbf{u}^{y} = [u_{1}^{y}, u_{2}^{y}, u_{3}^{y}, u_{4}^{y}]^{\\top}$, the generalized coordinates $q_{x}$ and $q_{y}$ are the projections of these displacement vectors onto the hourglass vector $\\mathbf{g}$:\n$$\nq_{x} = \\sum_{i=1}^{4} g_{i}u_{i}^{x} = \\mathbf{g}^{\\top}\\mathbf{u}^{x}\n$$\n$$\nq_{y} = \\sum_{i=1}^{4} g_{i}u_{i}^{y} = \\mathbf{g}^{\\top}\\mathbf{u}^{y}\n$$\nThese are assembled into the vector $\\mathbf{q}_{\\alpha} = [q_{x}, q_{y}]^{\\top}$. The quantity to be computed is its $L_2$-norm, $\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}$.\n\nWe now analytically verify the outcome for the specified displacement patterns.\n\n1.  **Rigid-Body Translation**: The displacement is constant across all nodes: $\\mathbf{u}_{i} = \\mathbf{t} = [t_{x}, t_{y}]^{\\top}$. The nodal displacement vectors are $\\mathbf{u}^{x} = t_{x}[1, 1, 1, 1]^{\\top}$ and $\\mathbf{u}^{y} = t_{y}[1, 1, 1, 1]^{\\top}$. The vector $[1, 1, 1, 1]^{\\top}$ is precisely the first column of $\\mathbf{P}$. Let's denote the columns of $\\mathbf{P}$ as $\\mathbf{p}_{1}$, $\\mathbf{p}_{2}$, $\\mathbf{p}_{3}$. The condition $\\mathbf{P}^{\\top}\\mathbf{g}=\\mathbf{0}$ implies $\\mathbf{p}_{j}^{\\top}\\mathbf{g}=0$ for $j=1,2,3$.\n    $$\n    q_{x} = \\mathbf{g}^{\\top}(t_{x}\\mathbf{p}_{1}) = t_{x}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = t_{x}(0) = 0\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}(t_{y}\\mathbf{p}_{1}) = t_{y}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = t_{y}(0) = 0\n    $$\n    Therefore, $\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}=0$.\n\n2.  **Rigid-Body Rotation (Small Angle)**: A rotation by a small angle $\\theta$ about a center $(x_{0}, y_{0})$ induces displacements $u_{i}^{x} = \\theta(-(y_{i}-y_{0}))$ and $u_{i}^{y} = \\theta(x_{i}-x_{0})$. The nodal displacement vectors can be written as linear combinations of the columns of $\\mathbf{P}$:\n    $$\n    \\mathbf{u}^{x} = \\theta(\\mathbf{p}_{1}y_{0} - \\mathbf{p}_{3})\n    $$\n    $$\n    \\mathbf{u}^{y} = \\theta(\\mathbf{p}_{2} - \\mathbf{p}_{1}x_{0})\n    $$\n    Projecting these onto $\\mathbf{g}$:\n    $$\n    q_{x} = \\mathbf{g}^{\\top}(\\theta y_{0}\\mathbf{p}_{1} - \\theta\\mathbf{p}_{3}) = \\theta y_{0}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) - \\theta(\\mathbf{g}^{\\top}\\mathbf{p}_{3}) = 0 - 0 = 0\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}(\\theta\\mathbf{p}_{2} - \\theta x_{0}\\mathbf{p}_{1}) = \\theta(\\mathbf{g}^{\\top}\\mathbf{p}_{2}) - \\theta x_{0}(\\mathbf{g}^{\\top}\\mathbf{p}_{1}) = 0 - 0 = 0\n    $$\n    Again, $\\lVert\\mathbf{q}_{\\alpha}\\rVert_{2}=0$. The numerical results for test cases $1, 2, 3, 4$ should be zero up to floating-point precision.\n\n3.  **Non-Rigid Hourglass Displacement**: The specified displacement has the form of the hourglass mode itself: $u_{i}^{x}=g_{i}$ and $u_{i}^{y}=-2g_{i}$. This means $\\mathbf{u}^{x} = \\mathbf{g}$ and $\\mathbf{u}^{y} = -2\\mathbf{g}$.\n    $$\n    q_{x} = \\mathbf{g}^{\\top}\\mathbf{u}^{x} = \\mathbf{g}^{\\top}\\mathbf{g} = \\lVert\\mathbf{g}\\rVert_{2}^{2} = 1\n    $$\n    $$\n    q_{y} = \\mathbf{g}^{\\top}\\mathbf{u}^{y} = \\mathbf{g}^{\\top}(-2\\mathbf{g}) = -2(\\mathbf{g}^{\\top}\\mathbf{g}) = -2\\lVert\\mathbf{g}\\rVert_{2}^{2} = -2\n    $$\n    The norm is therefore:\n    $$\n    \\lVert\\mathbf{q}_{\\alpha}\\rVert_{2} = \\sqrt{q_{x}^{2} + q_{y}^{2}} = \\sqrt{1^{2} + (-2)^{2}} = \\sqrt{1+4} = \\sqrt{5}\n    $$\n    This demonstrates that the hourglass generalized coordinates are non-zero for a displacement pattern that matches the hourglass mode, confirming the control mechanism would be activated.\n\nThe algorithm implemented in the code follows these steps for each test case: construct $\\mathbf{P}$, compute $\\mathbf{g}$ via the nullspace of $\\mathbf{P}^{\\top}$, define the nodal displacement vectors $\\mathbf{u}^{x}$ and $\\mathbf{u}^{y}$ for the given motion, calculate $\\mathbf{q}_{\\alpha}$, and finally compute its norm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Implements the verification of hourglass control properties for a 4-node\n    quadrilateral element under various displacement patterns.\n    \"\"\"\n\n    def calculate_q_norm(nodes, motion_type, params):\n        \"\"\"\n        Calculates the L2-norm of the hourglass generalized coordinate vector q_alpha.\n\n        Args:\n            nodes (np.ndarray): A 4x2 array of nodal coordinates (x, y).\n            motion_type (str): Type of motion ('translation', 'rotation', 'hourglass').\n            params (dict): Dictionary of parameters for the motion.\n\n        Returns:\n            float: The L2-norm of q_alpha.\n        \"\"\"\n        # 1. Construct the matrix P\n        P = np.hstack([np.ones((4, 1)), nodes])\n\n        # 2. Compute the unit-norm hourglass vector g\n        # g is the basis for the left nullspace of P, i.e., nullspace of P.T\n        g_vec = null_space(P.T)\n        if g_vec.shape[1] == 0:\n            # This case should not happen for non-degenerate quads\n            raise ValueError(\"Could not find a nullspace vector. The element may be degenerate.\")\n        g = g_vec[:, 0]  # null_space returns an orthonormal basis as columns\n\n        # Ensure g is a consistent choice (e.g., g[0] is positive) to avoid sign flips\n        # that don't affect the norm but could affect intermediate values.\n        if g[0]  0:\n            g = -g\n\n        # 3. Define nodal displacement vectors u_x and u_y\n        x_coords = nodes[:, 0]\n        y_coords = nodes[:, 1]\n        u_x = np.zeros(4)\n        u_y = np.zeros(4)\n\n        if motion_type == 'translation':\n            t = params['t']\n            u_x.fill(t[0])\n            u_y.fill(t[1])\n        elif motion_type == 'rotation':\n            theta = params['theta']\n            center = params['center']\n            if isinstance(center, str) and center == 'centroid':\n                x0, y0 = np.mean(nodes, axis=0)\n            else:\n                x0, y0 = center\n            u_x = theta * -(y_coords - y0)\n            u_y = theta * (x_coords - x0)\n        elif motion_type == 'hourglass':\n            u_x = g\n            u_y = -2 * g\n        else:\n            raise ValueError(f\"Unknown motion type: {motion_type}\")\n\n        # 4. Calculate hourglass generalized coordinates q_x and q_y\n        q_x = np.dot(g, u_x)\n        q_y = np.dot(g, u_y)\n\n        # 5. Calculate and return the L2-norm of q_alpha\n        return np.linalg.norm([q_x, q_y])\n\n    # Define the test cases from the problem statement.\n    nodes1 = np.array([[0.0, 0.0], [3.0, 0.2], [2.7, 1.8], [-0.1, 1.5]])\n    nodes2 = np.array([[0.0, 0.0], [2.0, 0.1], [2.2, 0.5], [0.1, 1.2]])\n    nodes3 = np.array([[0.0, 0.0], [10.0, 0.02], [10.5, 0.05], [0.5, 0.03]])\n\n    test_cases = [\n        # Test case 1 (translation)\n        {'nodes': nodes1, 'motion_type': 'translation', 'params': {'t': [0.7, -1.1]}},\n        # Test case 2 (rotation about centroid)\n        {'nodes': nodes1, 'motion_type': 'rotation', 'params': {'theta': 0.1, 'center': 'centroid'}},\n        # Test case 3 (rotation about external point)\n        {'nodes': nodes2, 'motion_type': 'rotation', 'params': {'theta': -0.35, 'center': (0.0, 0.0)}},\n        # Test case 4 (rotation about centroid on slender element)\n        {'nodes': nodes3, 'motion_type': 'rotation', 'params': {'theta': 0.2, 'center': 'centroid'}},\n        # Test case 5 (non-rigid hourglass pattern)\n        {'nodes': nodes1, 'motion_type': 'hourglass', 'params': {}}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_q_norm(case['nodes'], case['motion_type'], case['params'])\n        results.append(result)\n\n    # Format results to scientific notation with 12 decimal places\n    formatted_results = [f\"{r:.12e}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a clear understanding of what defines an hourglass mode, the practical question becomes how to suppress it effectively. This exercise guides you through the implementation of a robust, physically-based stabilization method that penalizes deviations in the strain field not captured by single-point integration. By constructing the hourglass stiffness matrix, $K_{hg}$, from first principles , you will gain direct experience in translating stabilization theory into a working finite element code.",
            "id": "3404232",
            "problem": "You are asked to design and implement a program that adds an hourglass control stiffness matrix into a reduced-integration quadrilateral element within the Finite Element Method (FEM) for the numerical solution of partial differential equations (PDEs). The focus is on a four-node bilinear isoparametric quadrilateral under small-strain linear elasticity in plane strain and on controlling zero-energy hourglass modes that appear with one-point integration.\n\nBegin from the foundational weak form of small-strain linear elasticity, the strain-displacement relation, and the constitutive law:\n- The displacement field is denoted by $\\mathbf{u}(\\mathbf{x}) = [u_x(\\mathbf{x}), u_y(\\mathbf{x})]^T$.\n- The small strain tensor is defined by $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T\\right)$, and its vector form is $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$.\n- The stress is $\\boldsymbol{\\sigma} = \\mathbf{D}\\,\\boldsymbol{\\varepsilon}$ with the plane strain constitutive matrix $\\mathbf{D}$ constructed from Young’s modulus $E$ and Poisson’s ratio $\\nu$ through the Lamé parameters $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$, giving\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n\nFor the bilinear quadrilateral element, use the standard isoparametric mapping from the reference square $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$:\n- The shape functions are $\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\;\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\;\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\;\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$\n- The isoparametric map to physical coordinates is $\n\\mathbf{x}(\\xi,\\eta) = \\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{x}_i,\n$ where $\\mathbf{x}_i = [x_i,y_i]^T$ are the nodal coordinates.\n- The strain-displacement matrix $\\mathbf{B}(\\xi,\\eta)$ is obtained by $\\mathbf{B} = \\mathbf{L}\\,\\mathbf{S}$, where $\\mathbf{S}$ stacks $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ for $i=1,\\dots,4$, and $\\mathbf{L}$ maps gradients to the strain vector via $\n\\mathbf{L} =\n\\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n\\end{bmatrix}\n$ acting appropriately on displacement gradients to form $\n\\mathbf{B} =\n\\begin{bmatrix}\n\\frac{\\partial N_1}{\\partial x}  0  \\frac{\\partial N_2}{\\partial x}  0  \\frac{\\partial N_3}{\\partial x}  0  \\frac{\\partial N_4}{\\partial x}  0 \\\\\n0  \\frac{\\partial N_1}{\\partial y}  0  \\frac{\\partial N_2}{\\partial y}  0  \\frac{\\partial N_3}{\\partial y}  0  \\frac{\\partial N_4}{\\partial y} \\\\\n\\frac{\\partial N_1}{\\partial y}  \\frac{\\partial N_1}{\\partial x}  \\frac{\\partial N_2}{\\partial y}  \\frac{\\partial N_2}{\\partial x}  \\frac{\\partial N_3}{\\partial y}  \\frac{\\partial N_3}{\\partial x}  \\frac{\\partial N_4}{\\partial y}  \\frac{\\partial N_4}{\\partial x}\n\\end{bmatrix}.\n$\n\nUnder reduced (one-point) integration, spurious zero-energy hourglass modes may appear due to insufficient sampling of the strain field. A robust hourglass control matrix $K_{hg}$ can be added to the global stiffness to penalize subcell strain fluctuations that are not captured by the centroid strain. Your task is to implement a step-by-step algorithm that:\n- Computes subcell strains at a small set of points within each element.\n- Constructs a stabilization based on deviations of subcell strains from the centroid strain.\n- Assembles the resulting hourglass stiffness contribution into the global system.\n- Selects a stabilization parameter based on physically meaningful quantities.\n\nUse the following requirements for the algorithm and implementation:\n1. Compute the centroid strain-displacement matrix $\\mathbf{B}_{\\text{cent}}$ at $(\\xi,\\eta) = (0,0)$.\n2. Select a set of subcell points $(\\xi_m,\\eta_m)$, with $m$ indexing subcells, to sample strain fluctuations. Use four points at the two-point Gaussian abscissae $ \\xi_m,\\eta_m \\in \\{-1/\\sqrt{3}, +1/\\sqrt{3}\\}$ with unit weights; denote the Jacobian determinant at each point by $J_m$.\n3. For each subcell $m$, define the deviation matrix $\\mathbf{H}_m = \\mathbf{B}(\\xi_m,\\eta_m) - \\mathbf{B}_{\\text{cent}}$ and construct a stabilization energy density based on $\\mathbf{H}_m$ and the constitutive matrix $\\mathbf{D}$.\n4. Assemble an element hourglass stiffness that penalizes these deviations with a scalar stabilization coefficient $\\alpha$ selected from the shear modulus $\\mu$ via $\\alpha = c_{\\alpha}\\,\\mu$, where $c_{\\alpha}$ is a dimensionless parameter to be chosen.\n5. Assemble the global hourglass stiffness matrix by summing element contributions according to standard FEM assembly rules.\n\nYou must implement the above algorithm for a small mesh with two quadrilateral elements and evaluate the resulting global hourglass stiffness matrix $K_{hg}^{\\text{global}}$ for several test cases. For each test case, compute the smallest strictly positive eigenvalue of $K_{hg}^{\\text{global}}$; if there are no strictly positive eigenvalues (for example, if $c_{\\alpha} = 0$ yields a zero matrix), return $0.0$.\n\nPhysical units are not required, and all quantities can be treated as dimensionless for this task. Angles do not appear in this problem, so no angle unit is required.\n\nTest Suite:\n- Test $1$ (happy path): Two elements forming a unit rectangle split at $x = 0.5$. Node coordinates are $[ (0,0), (0.5,0), (1,0), (0,1), (0.5,1), (1,1) ]$ with elements $[ (0,1,4,3), (1,2,5,4) ]$, $E = 1000$, $\\nu = 0.3$, $c_{\\alpha} = 0.1$.\n- Test $2$ (distortion): Same connectivity as Test $1$ but with node coordinates $[ (0,0), (0.5,-0.2), (1,0), (0,1), (0.5,1.3), (1,1) ]$, $E = 1000$, $\\nu = 0.3$, $c_{\\alpha} = 0.1$.\n- Test $3$ (boundary condition $c_{\\alpha} = 0$): Same geometry as Test $1$, $E = 1000$, $\\nu = 0.3$, $c_{\\alpha} = 0.0$.\n- Test $4$ (strong stabilization): Same geometry as Test $2$, $E = 1000$, $\\nu = 0.3$, $c_{\\alpha} = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_i$ is the smallest strictly positive eigenvalue of $K_{hg}^{\\text{global}}$ for Test $i$ (or $0.0$ if none exist). All numerical values must be reported as floating-point numbers.",
            "solution": "The problem requires the design and implementation of an hourglass control stabilization for a four-node bilinear isoparametric quadrilateral element used in a finite element analysis for linear elasticity under plane strain conditions. The stabilization is necessary to counteract the spurious zero-energy modes, known as hourglass modes, that arise when using reduced one-point (1x1) Gaussian quadrature to compute the element stiffness matrix.\n\nThe fundamental principle behind the stabilization is to add a penalty energy to the system's potential energy. This penalty energy is designed to be zero for rigid body motions and constant strain states but positive for the non-physical hourglass deformation modes. The element stiffness matrix is derived from the second variation of the potential energy. Consequently, the hourglass stabilization contributes an additional stiffness matrix, denoted $K_{hg}^{(e)}$, to the standard element stiffness matrix. The total element stiffness is $K^{(e)}_{\\text{total}} = K^{(e)}_{\\text{std}} + K^{(e)}_{hg}$. This problem focuses exclusively on the computation of the hourglass contribution.\n\nThe hourglass stabilization energy, $W_{hg}^{(e)}$, for an element $(e)$ is formulated based on the deviation of the strain field within the element, $\\boldsymbol{\\varepsilon}$, from the strain calculated at the element's centroid, $\\boldsymbol{\\varepsilon}_{\\text{cent}}$. These strains are related to the element's nodal displacement vector $\\mathbf{d}$ via the strain-displacement matrix $\\mathbf{B}(\\xi, \\eta)$, where $(\\xi, \\eta)$ are coordinates in the reference element domain $[-1,1] \\times [-1,1]$. Specifically, $\\boldsymbol{\\varepsilon}(\\xi, \\eta) = \\mathbf{B}(\\xi, \\eta)\\mathbf{d}$ and $\\boldsymbol{\\varepsilon}_{\\text{cent}} = \\mathbf{B}(0,0)\\mathbf{d} = \\mathbf{B}_{\\text{cent}}\\mathbf{d}$.\n\nThe stabilization energy density is constructed to be proportional to the squared norm of this strain deviation, weighted by the material's constitutive matrix $\\mathbf{D}$ and a stabilization parameter $\\alpha$. The total stabilization energy for the element is the integral of this density over the element's volume $V_e$:\n$$\nW_{hg}^{(e)} = \\frac{1}{2} \\int_{V_e} (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}_{\\text{cent}})^T (\\alpha\\mathbf{D}) (\\boldsymbol{\\varepsilon} - \\boldsymbol{\\varepsilon}_{\\text{cent}}) \\,dV\n$$\nSubstituting the relationship between strain and nodal displacements, we get:\n$$\nW_{hg}^{(e)} = \\frac{1}{2} \\mathbf{d}^T \\left( \\alpha \\int_{V_e} (\\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}})^T \\mathbf{D} (\\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}}) \\,dV \\right) \\mathbf{d}\n$$\nThe term in the parenthesis is the element hourglass stiffness matrix $K_{hg}^{(e)}$:\n$$\nK_{hg}^{(e)} = \\alpha \\int_{V_e} \\mathbf{H}(\\xi,\\eta)^T \\mathbf{D} \\mathbf{H}(\\xi,\\eta) \\,dV\n$$\nwhere $\\mathbf{H}(\\xi,\\eta) = \\mathbf{B}(\\xi,\\eta) - \\mathbf{B}_{\\text{cent}}$ is the deviation matrix.\n\nThe integral over the physical volume $V_e$ is transformed into an integral over the reference square domain using the isoparametric mapping, where $dV = J(\\xi,\\eta) \\,d\\xi d\\eta$ for a unit thickness plane strain element, with $J(\\xi,\\eta)$ being the determinant of the Jacobian matrix of the coordinate mapping.\n$$\nK_{hg}^{(e)} = \\alpha \\int_{-1}^{1} \\int_{-1}^{1} \\mathbf{H}(\\xi,\\eta)^T \\mathbf{D} \\mathbf{H}(\\xi,\\eta) J(\\xi,\\eta) \\,d\\xi d\\eta\n$$\nThis integral is then approximated numerically using a quadrature rule. The problem specifies a special rule with four sampling points, $(\\xi_m, \\eta_m)$, located at the $2\\times2$ Gaussian quadrature abscissae, i.e., $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$, but with unit weights ($w_m=1$). The element hourglass stiffness matrix is thus approximated as a sum:\n$$\nK_{hg}^{(e)} \\approx \\alpha \\sum_{m=1}^{4} \\mathbf{H}_m^T \\mathbf{D} \\mathbf{H}_m J_m\n$$\nThe stabilization parameter $\\alpha$ is chosen to be proportional to the material's shear modulus $\\mu$, as hourglass modes are typically dominated by shear deformation. The relation is $\\alpha = c_{\\alpha}\\mu$, where $c_{\\alpha}$ is a dimensionless coefficient. The material properties are defined by Young's modulus $E$ and Poisson's ratio $\\nu$, from which the Lamé parameters $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$ are derived. The plane strain constitutive matrix $\\mathbf{D}$ is given by:\n$$\n\\mathbf{D} =\n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\nThe algorithmic procedure to compute the global hourglass stiffness matrix $K_{hg}^{\\text{global}}$ is as follows:\n1.  For each test case, initialize a zero matrix $K_{hg}^{\\text{global}}$ of size $(2 \\times N_{\\text{nodes}}) \\times (2 \\times N_{\\text{nodes}})$, where $N_{\\text{nodes}}$ is the total number of nodes in the mesh.\n2.  Calculate the material properties $\\lambda$, $\\mu$, the constitutive matrix $\\mathbf{D}$, and the stabilization parameter $\\alpha$. If $\\alpha=0$, the hourglass stiffness is zero.\n3.  Iterate through each element in the mesh:\n    a. For an element with nodal coordinates $\\mathbf{x}_i$, first compute the strain-displacement matrix at the centroid, $\\mathbf{B}_{\\text{cent}} = \\mathbf{B}(0,0)$. This involves calculating the shape function derivatives, the Jacobian matrix $\\mathbf{J}$, and its inverse at $(\\xi, \\eta)=(0,0)$.\n    b. Initialize the $8 \\times 8$ element hourglass stiffness $K_{hg}^{(e)}$ to zero.\n    c. Loop over the four specified subcell points $(\\xi_m, \\eta_m) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$:\n        i.  At each point, compute the strain-displacement matrix $\\mathbf{B}_m = \\mathbf{B}(\\xi_m, \\eta_m)$ and the Jacobian determinant $J_m = J(\\xi_m, \\eta_m)$.\n        ii. Form the deviation matrix $\\mathbf{H}_m = \\mathbf{B}_m - \\mathbf{B}_{\\text{cent}}$.\n        iii. Calculate the contribution to the element stiffness, $\\alpha \\mathbf{H}_m^T \\mathbf{D} \\mathbf{H}_m J_m$, and add it to $K_{hg}^{(e)}$.\n    d. Assemble the computed $K_{hg}^{(e)}$ into the global matrix $K_{hg}^{\\text{global}}$ using the element's node connectivity to map local degrees of freedom to global degrees of freedom.\n4.  After assembling contributions from all elements, compute the eigenvalues of the symmetric, positive semi-definite global matrix $K_{hg}^{\\text{global}}$.\n5.  Identify the smallest eigenvalue that is strictly greater than a small numerical tolerance (e.g., $10^{-9}$). If no such eigenvalue exists, the result is $0.0$. This value is reported for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef compute_b_matrix_and_jacobian_det(xi, eta, node_coords):\n    \"\"\"\n    Computes the strain-displacement matrix B and Jacobian determinant J for a 4-node quad.\n\n    Args:\n        xi (float): xi-coordinate in the reference element [-1, 1].\n        eta (float): eta-coordinate in the reference element [-1, 1].\n        node_coords (np.ndarray): A 4x2 array of the element's nodal coordinates.\n\n    Returns:\n        tuple[np.ndarray, float]: A tuple containing the B matrix (3x8) and the Jacobian determinant.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. reference coordinates (xi, eta)\n    # N1 = 0.25 * (1-xi) * (1-eta)\n    # N2 = 0.25 * (1+xi) * (1-eta)\n    # N3 = 0.25 * (1+xi) * (1+eta)\n    # N4 = 0.25 * (1-xi) * (1+eta)\n    dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n\n    # grad_N_ref is a 4x2 matrix of shape function derivatives w.r.t (xi, eta)\n    grad_N_ref = np.vstack((dNdxi, dNdeta)).T\n\n    # Jacobian matrix J of the isoparametric map: J_ij = d(x_i)/d(xi_j)\n    # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n    # (dx/dxi) = sum(dNi/dxi * xi), (dy/dxi) = sum(dNi/dxi * yi), etc.\n    # This can be computed as: J = node_coords.T @ grad_N_ref\n    jacobian = grad_N_ref.T @ node_coords\n    \n    det_J = np.linalg.det(jacobian)\n    if det_J = 0:\n        raise ValueError(\"Jacobian determinant is non-positive, check element geometry.\")\n\n    inv_J = np.linalg.inv(jacobian)\n    \n    # Derivatives of shape functions w.r.t. physical coordinates (x, y)\n    # [dNi/dx, dNi/dy] = [dNi/dxi, dNi/deta] @ inv(J)\n    grad_N_phys = grad_N_ref @ inv_J\n\n    B = np.zeros((3, 8))\n    for i in range(4):\n        dNi_dx = grad_N_phys[i, 0]\n        dNi_dy = grad_N_phys[i, 1]\n        B[0, 2 * i] = dNi_dx\n        B[1, 2 * i + 1] = dNi_dy\n        B[2, 2 * i] = dNi_dy\n        B[2, 2 * i + 1] = dNi_dx\n    \n    return B, det_J\n\ndef calculate_elem_hg_stiffness(node_coords, D_matrix, alpha):\n    \"\"\"\n    Calculates the element hourglass stiffness matrix.\n    \"\"\"\n    if alpha == 0.0:\n        return np.zeros((8, 8))\n\n    B_cent, _ = compute_b_matrix_and_jacobian_det(0.0, 0.0, node_coords)\n    \n    K_hg_elem = np.zeros((8, 8))\n    \n    g = 1.0 / np.sqrt(3.0)\n    subcell_points = [(-g, -g), (g, -g), (g, g), (-g, g)]\n\n    for xi_m, eta_m in subcell_points:\n        B_m, J_m = compute_b_matrix_and_jacobian_det(xi_m, eta_m, node_coords)\n        H_m = B_m - B_cent\n        # The problem specifies unit weights (w_m=1) for the quadrature.\n        K_hg_elem += alpha * (H_m.T @ D_matrix @ H_m) * J_m\n\n    return K_hg_elem\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute the smallest positive eigenvalue\n    of the global hourglass stiffness matrix.\n    \"\"\"\n    test_cases = [\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, 0.0), (1.0, 0.0), (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.1},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, -0.2), (1.0, 0.0), (0.0, 1.0), (0.5, 1.3), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.1},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, 0.0), (1.0, 0.0), (0.0, 1.0), (0.5, 1.0), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 0.0},\n        {\"nodes\": np.array([(0.0, 0.0), (0.5, -0.2), (1.0, 0.0), (0.0, 1.0), (0.5, 1.3), (1.0, 1.0)]),\n         \"elements\": np.array([(0, 1, 4, 3), (1, 2, 5, 4)]),\n         \"E\": 1000.0, \"nu\": 0.3, \"c_alpha\": 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        elements = case[\"elements\"]\n        E = case[\"E\"]\n        nu = case[\"nu\"]\n        c_alpha = case[\"c_alpha\"]\n\n        num_nodes = len(nodes)\n        K_global_hg = np.zeros((2 * num_nodes, 2 * num_nodes))\n\n        lame_lambda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        lame_mu = E / (2.0 * (1.0 + nu))\n        \n        D_matrix = np.array([\n            [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n            [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n            [0, 0, lame_mu]\n        ])\n        \n        alpha = c_alpha * lame_mu\n\n        if alpha == 0.0:\n            results.append(0.0)\n            continue\n            \n        for elem_node_indices in elements:\n            node_coords = nodes[elem_node_indices]\n            K_elem_hg = calculate_elem_hg_stiffness(node_coords, D_matrix, alpha)\n            \n            # Assembly\n            dof_map = np.array([[2 * n, 2 * n + 1] for n in elem_node_indices]).flatten()\n            K_global_hg[np.ix_(dof_map, dof_map)] += K_elem_hg\n\n        eigenvalues = eigvalsh(K_global_hg)\n        \n        # Find smallest strictly positive eigenvalue, using tolerance for numerical zero\n        positive_eigs = eigenvalues[eigenvalues > 1e-9]\n        \n        result = np.min(positive_eigs) if len(positive_eigs) > 0 else 0.0\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While static analyses may sometimes mask the dangers of hourglassing, dynamic simulations reveal their truly unstable nature. This final practice provides a compelling demonstration of why hourglass control is indispensable in many applications, particularly those involving explicit time integration. Using a one-dimensional surrogate model , you will witness the catastrophic growth of an unstabilized hourglass mode and observe how a proper stabilization scheme effectively restores stability to the simulation.",
            "id": "3404226",
            "problem": "Consider one-dimensional linear elastodynamics on a bar of length $L$ with displacement field $u(x,t)$ governed by the partial differential equation\n$$\\rho A \\,\\frac{\\partial^2 u}{\\partial t^2} = \\frac{\\partial}{\\partial x}\\left(E A \\,\\frac{\\partial u}{\\partial x}\\right),$$\nwhere $\\rho$ is the mass density, $A$ is the cross-sectional area, and $E$ is Young's modulus. Impose homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(L,t)=0$.\n\nTo mimic the hourglass behavior of under-integrated bilinear quadrilateral four-node elements (Q4) in a tractable one-dimensional surrogate, discretize the domain into $N$ equally spaced nodes with spacing $h = L/(N-1)$, and define overlapping four-node macro-elements $\\{i,i+1,i+2,i+3\\}$ for $i=0,1,\\dots,N-4$. For each macro-element, define a reduced-integration strain surrogate at the element center by\n$$\\varepsilon_e = g^\\top u_e,\\quad g = \\frac{1}{2h}[-1,-1,1,1]^\\top,$$\nwhere $u_e \\in \\mathbb{R}^4$ collects the nodal displacements of the macro-element. The associated under-integrated elemental stiffness is\n$$K_e^{\\text{RI}} = E A (2h)\\, g g^\\top,$$\nwhich produces a rank-deficient global stiffness matrix when assembled over all macro-elements. The nullspace corresponds to hourglass modes $u_e$ satisfying $g^\\top u_e = 0$, namely oscillatory patterns internal to each macro-element that do not contribute to the center strain. A convenient set of hourglass basis vectors for each macro-element is\n$$h_1 = [1,-1,0,0]^\\top,\\quad h_2=[0,0,1,-1]^\\top,\\quad h_3=[1,-1,-1,1]^\\top.$$\nIntroduce an hourglass control stabilization by adding, for each element, the stiffness\n$$K_e^{\\text{HG}} = s \\sum_{j=1}^3 h_j h_j^\\top,\\quad s = \\beta\\,\\frac{E A}{h},$$\nwhere $\\beta \\ge 0$ is a dimensionless stabilization coefficient. The total global stiffness is the assembly of $K_e^{\\text{RI}}$ for all elements, optionally augmented with $K_e^{\\text{HG}}$ if $\\beta0$.\n\nUse explicit central difference time stepping with lumped mass matrix $M=\\operatorname{diag}(m_i)$, $m_i=\\rho A h$ for interior nodes, zero external traction, and initial conditions $u(x,0)=0$ and an hourglass-dominated initial velocity $v(x,0)$ proportional to the alternating nodal pattern. For free (interior) degrees of freedom, the update is\n$$u^{n+1} = 2u^n - u^{n-1} + \\Delta t^2 M^{-1}\\left(-K\\,u^n\\right),$$\nwith the first step\n$$u^1 = u^0 + \\Delta t\\,v^0 + \\frac{1}{2}\\Delta t^2 M^{-1}\\left(-K\\,u^0\\right).$$\nFix boundary nodes to zero at all times by direct imposition after each update. Choose a stable time step by\n$$\\Delta t = \\alpha\\,\\frac{2}{\\sqrt{\\lambda_{\\max}(M^{-1/2} K M^{-1/2})}},$$\nwhere $\\lambda_{\\max}(\\cdot)$ denotes the largest eigenvalue and $0\\alpha1$ is a safety factor.\n\nDefine the global hourglass pattern vector $\\phi \\in \\mathbb{R}^N$ by $\\phi_i = (-1)^i$ for interior nodes and $\\phi$ equals zero at the boundary nodes. Quantify the hourglass amplitude at time $t$ by the scalar projection in the mass inner product,\n$$a(t) = \\left|\\frac{\\phi^\\top M u(t)}{\\phi^\\top M \\phi}\\right|,$$\nwhich has units of meters.\n\nYour task is to write a complete, runnable program that:\n- Assembles $K$ using the reduced-integration surrogate and optional hourglass control.\n- Computes an explicit central difference time integration to time $T$, starting from $u(0)=0$ and $v(0)$ equal to the alternating hourglass pattern with a prescribed amplitude.\n- Outputs the final hourglass amplitude $a(T)$ in meters for each test case.\n\nAll physical quantities must be handled in base SI units: meters (m), seconds (s), kilograms (kg), Pascals (Pa), and Newtons (N). Angles are not involved. The outputs are floats representing $a(T)$ in meters.\n\nImplement the following test suite. Each test case is a tuple $(N, L, E, \\rho, A, V_0, T, \\beta, \\alpha)$ where:\n- $N$: number of nodes,\n- $L$: bar length in meters,\n- $E$: Young's modulus in Pascals,\n- $\\rho$: density in kilograms per cubic meter,\n- $A$: area in square meters,\n- $V_0$: initial hourglass velocity amplitude in meters per second,\n- $T$: final time in seconds,\n- $\\beta$: stabilization coefficient (dimensionless),\n- $\\alpha$: safety factor for the time step (dimensionless).\n\nUse the following parameter values:\n- Case 1 (no stabilization, observe growth): $(N,L,E,\\rho,A,V_0,T,\\beta,\\alpha) = (\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.0,\\,0.80\\,)$.\n- Case 2 (moderate stabilization): $(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.80\\,)$.\n- Case 3 (strong stabilization): $(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,2.0,\\,0.80\\,)$.\n- Case 4 (small mesh, moderate stabilization): $(\\,7,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.80\\,)$.\n- Case 5 (near-critical time step with moderate stabilization): $(\\,41,\\,1.0,\\,200\\times 10^9,\\,7800,\\,1.0\\times 10^{-2},\\,1.0\\times 10^{-1},\\,2.0\\times 10^{-3},\\,0.5,\\,0.98\\,)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result must be the final hourglass amplitude $a(T)$ in meters for the corresponding test case, in the order given above.",
            "solution": "The problem asks for the simulation of one-dimensional elastodynamics using an explicit finite difference scheme. The spatial discretization is specifically designed to mimic hourglass instability, a phenomenon common in under-integrated finite element methods. The solution involves several steps: system discretization, construction of mass and stiffness matrices, determination of a stable time step, time integration of the equations of motion, and calculation of a final metric for the hourglassing amplitude. All calculations are performed in base SI units.\n\n### 1. Discretization and System Matrices\n\nThe continuous bar of length $L$ is discretized into $N$ nodes, with a uniform spacing of $h = L/(N-1)$. The displacement of the $i$-th node at time $t$ is denoted by $u_i(t)$. The system of equations is governed by the matrix equation $M \\ddot{u} + K u = F_{ext}$, where $u$ is the vector of nodal displacements, $M$ is the mass matrix, $K$ is the stiffness matrix, and $F_{ext}$ is the vector of external nodal forces, which is zero in this problem.\n\n**Mass Matrix ($M$)**\nA lumped mass matrix is used, which is diagonal and thus computationally efficient for explicit dynamics. For the $N-2$ interior nodes (from $i=1$ to $N-2$), the mass is $m_i = \\rho A h$. For the boundary nodes ($i=0$ and $i=N-1$), the displacements are fixed to zero, so their mass values do not influence the dynamics of the interior nodes. For implementation purposes, we can assign them any non-zero value to prevent division by zero; using the interior mass value $m_{0}=m_{N-1}=\\rho A h$ is convenient. Thus, $M = \\operatorname{diag}(m_i)$ is an $N \\times N$ matrix.\n\n**Stiffness Matrix ($K$)**\nThe global stiffness matrix $K$ is an $N \\times N$ matrix assembled from elemental stiffness matrices $K_e$. The problem defines overlapping $4$-node macro-elements. For each element $e$ spanning nodes $\\{i, i+1, i+2, i+3\\}$, the elemental stiffness $K_e$ is the sum of a reduced-integration part $K_e^{\\text{RI}}$ and a stabilization part $K_e^{\\text{HG}}$.\n\nThe reduced-integration stiffness is given by:\n$$K_e^{\\text{RI}} = EA(2h) g g^\\top$$\nwhere $g = \\frac{1}{2h}[-1, -1, 1, 1]^\\top$ is the gradient vector for the strain surrogate at the element's center. This matrix is rank-one and has a nullspace corresponding to zero-energy \"hourglass\" modes.\n\nTo control these non-physical modes, a stabilization stiffness is added:\n$$K_e^{\\text{HG}} = s \\sum_{j=1}^3 h_j h_j^\\top$$\nwhere $s = \\beta \\frac{EA}{h}$ is the stabilization parameter magnitude, controlled by the dimensionless coefficient $\\beta$, and $\\{h_j\\}$ are the provided hourglass basis vectors:\n$$h_1 = [1, -1, 0, 0]^\\top, \\quad h_2 = [0, 0, 1, -1]^\\top, \\quad h_3 = [1, -1, -1, 1]^\\top$$\nThe total elemental stiffness is $K_e = K_e^{\\text{RI}} + K_e^{\\text{HG}}$. The global stiffness matrix $K$ is formed by iterating through all $N-3$ macro-elements and adding each $4 \\times 4$ elemental matrix $K_e$ into the appropriate rows and columns of $K$.\n\n### 2. Time Integration\n\nAn explicit central difference scheme is used to integrate the semi-discretized equations of motion, $M \\ddot{u} = -K u$.\n\n**Time Step Determination**\nThe stability of the explicit scheme is governed by the Courant-Friedrichs-Lewy (CFL) condition. The stable time step $\\Delta t$ is calculated based on the maximum natural frequency of the system, which is related to the maximum eigenvalue $\\lambda_{\\max}$ of the dynamically scaled stiffness matrix $D = M^{-1/2} K M^{-1/2}$. Since boundary nodes are fixed, we only consider the sub-system for the free interior degrees of freedom. The formula is:\n$$\\Delta t = \\alpha \\frac{2}{\\sqrt{\\lambda_{\\max}(D_{free})}}$$\nwhere $D_{free}$ is the matrix $D$ corresponding to the free nodes, and $\\alpha$ is a safety factor ($0  \\alpha  1$). The eigenvalues of $D_{free}$ are computed numerically.\n\n**Update Scheme**\nThe displacement vector $u^n$ at time step $n$ is updated to $u^{n+1}$ using the central difference formula:\n$$u^{n+1} = 2u^n - u^{n-1} + \\Delta t^2 M^{-1}(-K u^n)$$\nwhere $u^{n-1}$ and $u^n$ are the displacements at the two previous time steps. Since $M$ is diagonal, $M^{-1}$ is simply the element-wise reciprocal of the nodal masses.\n\n**Initial Conditions and First Step**\nThe system starts from rest, $u(x,0)=0$, so $u^0=0$. The initial velocity is an alternating pattern for the interior nodes, $v^0_i = V_0 (-1)^i$ for $i=1, ..., N-2$, and zero at the boundaries. The first time step requires special treatment:\n$$u^1 = u^0 + \\Delta t v^0 + \\frac{1}{2}\\Delta t^2 M^{-1}(-K u^0)$$\nGiven $u^0 = 0$, this simplifies to $u^1 = \\Delta t v^0$.\n\n**Boundary Conditions**\nThe homogeneous Dirichlet boundary conditions, $u(0, t) = 0$ and $u(L, t) = 0$, are enforced directly at each time step by setting the first and last components of the displacement vector to zero, i.e., $u^{n+1}_0 = 0$ and $u^{n+1}_{N-1} = 0$, after each update calculation.\n\n### 3. Hourglass Amplitude Calculation\n\nThe simulation runs for a total time $T$. The final state is the displacement vector $u(T)$ at the end of the last full time step. The amplitude of the hourglass mode at this time is quantified by projecting the displacement solution onto the global hourglass pattern vector $\\phi$, where $\\phi_i = (-1)^i$ for interior nodes and is zero at the boundaries. The projection is performed in the energy inner product defined by the mass matrix:\n$$a(T) = \\left|\\frac{\\phi^\\top M u(T)}{\\phi^\\top M \\phi}\\right| = \\left| \\frac{\\sum_{i=1}^{N-2} \\phi_i m_i u_i(T)}{\\sum_{i=1}^{N-2} \\phi_i m_i \\phi_i} \\right|$$\nThis scalar value $a(T)$, in meters, is the required output for each test case. For the case with no stabilization ($\\beta=0$), the initial velocity profile is a zero-energy mode, leading to a theoretical linear growth in displacement, $a(t)=V_0 t$. With stabilization ($\\beta  0$), this mode acquires a non-zero stiffness, resulting in oscillatory behavior with a suppressed amplitude.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: No stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.0, 0.80),\n        # Case 2: Moderate stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.80),\n        # Case 3: Strong stabilization\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 2.0, 0.80),\n        # Case 4: Small mesh, moderate stabilization\n        (7, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.80),\n        # Case 5: Near-critical time step\n        (41, 1.0, 200e9, 7800, 1.0e-2, 1.0e-1, 2.0e-3, 0.5, 0.98),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(N, L, E, rho, A, V0, T, beta, alpha):\n    \"\"\"\n    Solves a single instance of the 1D elastodynamics problem with hourglass control.\n\n    Args:\n        N (int): Number of nodes.\n        L (float): Bar length in meters.\n        E (float): Young's modulus in Pascals.\n        rho (float): Density in kg/m^3.\n        A (float): Cross-sectional area in m^2.\n        V0 (float): Initial hourglass velocity amplitude in m/s.\n        T (float): Final time in seconds.\n        beta (float): Dimensionless stabilization coefficient.\n        alpha (float): Safety factor for the time step.\n\n    Returns:\n        float: The final hourglass amplitude a(T) in meters.\n    \"\"\"\n    # 1. Discretization\n    h = L / (N - 1)\n\n    # 2. System Matrices (Mass M, Stiffness K)\n    # Lumped mass vector (m_i)\n    m = np.full(N, rho * A * h)\n    \n    # Global stiffness matrix\n    K = np.zeros((N, N))\n    \n    # Elemental stiffness matrix calculation\n    g = (1.0 / (2.0 * h)) * np.array([-1.0, -1.0, 1.0, 1.0])\n    Ke_RI = E * A * (2.0 * h) * np.outer(g, g)\n    \n    if beta > 1e-12:  # Treat sufficiently small beta as zero\n        s = beta * E * A / h\n        h1 = np.array([1.0, -1.0, 0.0, 0.0])\n        h2 = np.array([0.0, 0.0, 1.0, -1.0])\n        h3 = np.array([1.0, -1.0, -1.0, 1.0])\n        Ke_HG = s * (np.outer(h1, h1) + np.outer(h2, h2) + np.outer(h3, h3))\n    else:\n        Ke_HG = np.zeros((4, 4))\n        \n    Ke = Ke_RI + Ke_HG\n    \n    # Assembly of the global stiffness matrix\n    num_elements = N - 3\n    for i in range(num_elements):\n        nodes = np.arange(i, i + 4)\n        K[np.ix_(nodes, nodes)] += Ke\n        \n    # 3. Time Step Calculation based on CFL condition\n    free_dofs = slice(1, N - 1)\n    K_free = K[free_dofs, free_dofs]\n    m_free_val = rho * A * h\n    \n    D_matrix = (1.0 / m_free_val) * K_free\n    \n    eigenvalues = eigh(D_matrix, eigvals_only=True)\n    lambda_max = eigenvalues[-1]\n\n    if lambda_max = 0:\n        # For the pure RI case (beta=0), the max eigenvalue corresponding to\n        # the hourglass mode might be numerically zero. We need a physical\n        # frequency to define a timestep. Use the analytical wave speed.\n        c_wave = np.sqrt(E/rho)\n        # Smallest wavelength is ~2h for the physical modes\n        dt_phys = h / c_wave\n        dt = alpha * dt_phys\n        if lambda_max > 1e-9: # if there is a non-zero eigenvalue, still respect it\n            dt_eig = alpha * 2.0 / np.sqrt(lambda_max)\n            dt = min(dt, dt_eig)\n    else:\n        dt = alpha * 2.0 / np.sqrt(lambda_max)\n    \n    # 4. Explicit Time Integration (Central Difference)\n    num_steps = int(np.ceil(T / dt))\n    \n    u_prev = np.zeros(N)\n    u_curr = np.zeros(N)\n    \n    v0_vec = np.zeros(N)\n    for i in range(1, N - 1):\n        v0_vec[i] = V0 * ((-1.0)**i)\n        \n    # First time step\n    F_int_0 = -K @ u_prev\n    accel_0 = F_int_0 / m\n    u_curr = u_prev + dt * v0_vec + 0.5 * (dt**2) * accel_0\n    u_curr[0] = u_curr[-1] = 0.0\n    \n    # Time stepping loop\n    for _ in range(1, num_steps):\n        F_int = -K @ u_curr\n        accel = F_int / m\n        u_new = 2.0 * u_curr - u_prev + (dt**2) * accel\n        u_new[0] = u_new[-1] = 0.0\n        u_prev, u_curr = u_curr, u_new\n        \n    u_final = u_curr\n    \n    # 5. Final Amplitude Calculation\n    phi = np.zeros(N)\n    for i in range(1, N - 1):\n        phi[i] = (-1.0)**i\n        \n    numerator = np.dot(phi, m * u_final)\n    mass_norm_phi_sq = np.dot(phi, m * phi)\n    \n    if abs(mass_norm_phi_sq)  1e-15:\n        return 0.0\n            \n    amplitude = np.abs(numerator / mass_norm_phi_sq)\n    return amplitude\n\nsolve()\n```"
        }
    ]
}