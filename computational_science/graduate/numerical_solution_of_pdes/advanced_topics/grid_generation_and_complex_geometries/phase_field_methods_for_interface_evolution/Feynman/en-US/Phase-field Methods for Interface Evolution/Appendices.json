{
    "hands_on_practices": [
        {
            "introduction": "Before using a numerical simulation for scientific discovery, we must first verify that our code is free of bugs and correctly solves the intended mathematical equations. The Method of Manufactured Solutions (MMS) is a rigorous framework for this process of code verification. In this exercise , you will apply MMS to the Allen-Cahn and Cahn-Hilliard equations by deriving custom source terms that make a chosen analytical function an exact solution, allowing you to precisely measure your implementation's discretization error and confirm its theoretical order of accuracy.",
            "id": "3430574",
            "problem": "You are asked to design, derive, and implement a numerical code-verification experiment for phase-field interface evolution equations using the Method of Manufactured Solutions (MMS). The target equations are the Allen–Cahn equation and the Cahn–Hilliard equation, two standard phase-field models derived as gradient flows of the Ginzburg–Landau free energy. Your task is to start from fundamental definitions of the equations, derive the forcing functions that make a manufactured field an exact solution of the resulting forced equations, and then quantify the spatial discretization error of a second-order central-difference operator on a periodic domain by measuring the residuals that remain when the exact forcing is inserted into the discretized equations.\n\nThe governing equations are, for a scalar order parameter field $\\,\\phi(x,t)\\,$ on the one-dimensional periodic domain $\\,x\\in[0,1]\\,$ with period $\\,1\\,$:\n\n- Allen–Cahn (AC) equation with an added source $\\,S_{\\mathrm{AC}}(x,t)\\,$:\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t),\n$$\n- Cahn–Hilliard (CH) equation with an added source $\\,S_{\\mathrm{CH}}(x,t)\\,$, written in the equivalent fourth-order form with constant mobility $\\,M=1\\,$:\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t).\n$$\n\nHere $\\,\\varepsilon>0\\,$ is the diffuse-interface thickness parameter, $\\,W(\\phi)\\,$ is the classical double-well potential\n$$\nW(\\phi) \\;=\\; \\tfrac{1}{4}\\,\\big(\\phi^2-1\\big)^2,\n$$\nand hence\n$$\nW'(\\phi) \\;=\\; \\phi^3\\;-\\;\\phi.\n$$\n\nAdopt the following manufactured smooth solution with mixed spatial and temporal frequencies:\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big),\n$$\nwhere the constants are $\\,A=0.6\\,$, $\\,B=0.2\\,$, $\\,k=1\\,$, $\\,q=2\\,$, and $\\,\\omega=1.7\\,$. The spatial domain is periodic with period $\\,1\\,$, and all derivatives with respect to $\\,x\\,$ should satisfy periodic boundary conditions. Fix the evaluation time at $\\,t_0=0.37\\,$.\n\nTask 1 (derivation from first principles): Using the Method of Manufactured Solutions (MMS), derive the source terms $\\,S_{\\mathrm{AC}}(x,t)\\,$ and $\\,S_{\\mathrm{CH}}(x,t)\\,$ so that the above $\\,\\phi(x,t)\\,$ is an exact solution of the respective forced equations. Your starting point must be the given governing equations and the chain rule, together with exact spatial and temporal derivatives of the manufactured field. You must express $\\,S_{\\mathrm{AC}}(x,t)\\,$ and $\\,S_{\\mathrm{CH}}(x,t)\\,$ entirely in terms of $\\,\\phi\\,$ and its exact derivatives, and $\\,W'(\\phi)\\,$, without introducing any discretization at this stage.\n\nTask 2 (discrete residual design for verification): Consider a uniform grid with $\\,N\\,$ points on $\\,x\\in[0,1]\\,$ with grid spacing $\\,\\Delta x = 1/N\\,$, and let $\\,x_i=i\\,\\Delta x\\,$ for $\\,i=0,1,\\dots,N-1\\,$. Define the second-order central-difference approximation to the second derivative with periodic boundary conditions:\n$$\n\\mathcal{D}_2[\\psi]_i \\;=\\; \\frac{\\psi_{i-1} - 2\\,\\psi_i + \\psi_{i+1}}{(\\Delta x)^2},\n$$\nwhere indices are taken modulo $\\,N\\,$. Define the corresponding discrete fourth derivative as $\\,\\mathcal{D}_4[\\psi]\\equiv \\mathcal{D}_2\\!\\big[\\mathcal{D}_2[\\psi]\\big]\\,$. The discrete verification residuals at each grid point $\\,x_i\\,$ are then defined as follows:\n\n- For the Allen–Cahn case,\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big).\n$$\n\n- For the Cahn–Hilliard case (using the fourth-order form),\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\,-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big).\n$$\n\nBecause the sources are derived with exact derivatives but the residual uses discrete spatial operators, the nonzero residual directly measures the spatial discretization error. Quantify this error with the discrete $\\,L^2\\,$ norm on $[0,1]$,\n$$\n\\|\\mathcal{R}\\|_{L^2_h} \\;=\\; \\sqrt{\\,\\sum_{i=0}^{N-1} \\big(\\mathcal{R}_i\\big)^2\\,\\Delta x\\,}.\n$$\n\nTask 3 (implementation and test suite): Implement a program that\n- evaluates $\\,\\phi(x_i,t_0)\\,$ and its exact derivatives needed for $\\,S_{\\mathrm{AC}}\\,$ and $\\,S_{\\mathrm{CH}}\\,$,\n- constructs the discrete operators $\\,\\mathcal{D}_2\\,$ and $\\,\\mathcal{D}_4\\,$ with periodic boundary conditions,\n- forms the discrete residuals $\\,\\mathcal{R}_{\\mathrm{AC}}\\,$ and $\\,\\mathcal{R}_{\\mathrm{CH}}\\,$ at time $\\,t_0\\,$, and\n- returns the discrete $\\,L^2\\,$ norms for each specified test case.\n\nUse the following four test cases, each defined by the tuple $\\,(\\text{equation},\\,N,\\,\\varepsilon)\\,$ with the manufactured constants $\\,A=0.6\\,$, $\\,B=0.2\\,$, $\\,k=1\\,$, $\\,q=2\\,$, $\\,\\omega=1.7\\,$, and $\\,t_0=0.37\\,$ as above:\n\n- Test $\\,1\\,$: $\\,(\\text{AC},\\,N=64,\\,\\varepsilon=0.05)\\,$,\n- Test $\\,2\\,$: $\\,(\\text{AC},\\,N=128,\\,\\varepsilon=0.05)\\,$,\n- Test $\\,3\\,$: $\\,(\\text{CH},\\,N=64,\\,\\varepsilon=0.03)\\,$,\n- Test $\\,4\\,$: $\\,(\\text{CH},\\,N=128,\\,\\varepsilon=0.03)\\,$.\n\nYour program should produce a single line of output containing the four residual norms as a comma-separated list enclosed in square brackets (e.g., $[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4]$). Each entry must be a floating-point number. No user input is allowed, and no external files may be read or written. The domain length is nondimensional and equal to $\\,1\\,$, so no physical units are required in the answer. Angles are implicitly in radians via the trigonometric functions.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded, and objective problem in the field of numerical analysis for partial differential equations. It asks for the derivation and implementation of a code verification test for the Allen–Cahn and Cahn–Hilliard equations using the standard Method of Manufactured Solutions (MMS). All necessary information is provided, and the tasks are clearly defined.\n\nThe solution proceeds in two stages as requested. First, we perform the analytical derivations for the source terms and the resulting discrete residuals. Second, we implement these derivations in a Python program to compute the specified residual norms.\n\n### Task 1: Derivation of Source Terms\n\nThe Method of Manufactured Solutions (MMS) involves positing a smooth analytical function as an exact solution to a modified version of the governing partial differential equation (PDE). The modification consists of adding a source term, which is derived by substituting the manufactured solution into the original PDE.\n\nThe given manufactured solution is:\n$$\n\\phi(x,t) \\;=\\; A\\,\\cos\\!\\big(2\\pi k\\,x\\big)\\,\\cos\\!\\big(\\omega\\,t\\big)\\;+\\; B\\,\\sin\\!\\big(2\\pi q\\,x\\big)\\,\\sin\\!\\big(\\omega\\,t\\big)\n$$\nwith constants $A=0.6$, $B=0.2$, $k=1$, $q=2$, and $\\omega=1.7$. The potential is $W(\\phi) = \\tfrac{1}{4}(\\phi^2-1)^2$, with derivative $W'(\\phi) = \\phi^3 - \\phi$.\n\nTo derive the source terms, we rearrange the governing equations to solve for $S_{\\mathrm{AC}}(x,t)$ and $S_{\\mathrm{CH}}(x,t)$, assuming $\\phi(x,t)$ is a solution.\n\n**Allen–Cahn (AC) Source Term:**\nThe forced AC equation is:\n$$\n\\partial_t \\phi \\;=\\; \\varepsilon^2 \\,\\partial_{xx}\\phi \\;-\\; W'(\\phi)\\;+\\; S_{\\mathrm{AC}}(x,t)\n$$\nSolving for the source term $S_{\\mathrm{AC}}(x,t)$ gives:\n$$\nS_{\\mathrm{AC}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;-\\; \\varepsilon^2 \\,\\partial_{xx}\\phi(x,t) \\;+\\; W'(\\phi(x,t))\n$$\nHere, $\\partial_t \\phi$ and $\\partial_{xx}\\phi$ are the exact analytical temporal and second spatial derivatives of the manufactured solution $\\phi(x,t)$.\n\n**Cahn–Hilliard (CH) Source Term:**\nThe forced CH equation is:\n$$\n\\partial_t \\phi \\;=\\; -\\,\\varepsilon^2\\,\\partial_{xxxx}\\phi \\;+\\;\\partial_{xx}\\!\\big(W'(\\phi)\\big)\\;+\\; S_{\\mathrm{CH}}(x,t)\n$$\nSolving for the source term $S_{\\mathrm{CH}}(x,t)$ gives:\n$$\nS_{\\mathrm{CH}}(x,t) \\;=\\; \\partial_t \\phi(x,t) \\;+\\; \\varepsilon^2\\,\\partial_{xxxx}\\phi(x,t) \\;-\\; \\partial_{xx}\\!\\big(W'(\\phi(x,t))\\big)\n$$\nHere, $\\partial_t \\phi$ and $\\partial_{xxxx}\\phi$ are exact analytical derivatives of $\\phi(x,t)$. The term $\\partial_{xx}(W'(\\phi))$ is computed using the chain rule. First, the derivative of $W'(\\phi)$ with respect to $\\phi$ is $W''(\\phi) = 3\\phi^2-1$.\nThe first spatial derivative is:\n$$\n\\partial_x(W'(\\phi)) = W''(\\phi) \\, \\partial_x\\phi = (3\\phi^2-1)\\,\\partial_x\\phi\n$$\nThe second spatial derivative is:\n$$\n\\partial_{xx}(W'(\\phi)) = \\partial_x\\left( (3\\phi^2-1)\\,\\partial_x\\phi \\right) = (6\\phi\\,\\partial_x\\phi)\\,\\partial_x\\phi + (3\\phi^2-1)\\,\\partial_{xx}\\phi = 6\\phi(\\partial_x\\phi)^2 + (3\\phi^2-1)\\,\\partial_{xx}\\phi\n$$\nThese expressions for $S_{\\mathrm{AC}}$ and $S_{\\mathrm{CH}}$ are exact and defined at all points $(x,t)$.\n\n### Task 2: Discrete Residual Design\n\nThe discrete verification residual measures the extent to which the manufactured solution fails to satisfy the *discretized* governing equation when the exact source term is used. This nonzero residual is a direct measure of the discretization error of the spatial operators.\n\n**AC Residual:**\nThe definition of the AC residual at grid point $x_i$ and time $t_0$ is:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'\\big(\\phi(x_i,t_0)\\big) \\;+\\; S_{\\mathrm{AC}}(x_i,t_0)\\Big)\n$$\nSubstituting the expression for $S_{\\mathrm{AC}}(x_i,t_0) = (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))|_{x_i,t_0}$:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i \\;-\\; W'(\\phi) \\;+\\; (\\partial_t\\phi - \\varepsilon^2\\,\\partial_{xx}\\phi + W'(\\phi))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\partial_t\\phi - \\varepsilon^2\\,\\mathcal{D}_2[\\phi]_i + W'(\\phi) - \\partial_t\\phi + \\varepsilon^2\\,\\partial_{xx}\\phi - W'(\\phi)\n$$\nSimplifying, we obtain:\n$$\n\\mathcal{R}_{\\mathrm{AC},i} \\;=\\; \\varepsilon^2\\left(\\partial_{xx}\\phi(x_i,t_0) - \\mathcal{D}_2[\\phi]_i\\right)\n$$\nThis shows that the residual is precisely $\\varepsilon^2$ times the truncation error of the second-order central difference operator $\\mathcal{D}_2$ when approximating the second derivative $\\partial_{xx}\\phi$.\n\n**CH Residual:**\nThe definition of the CH residual at grid point $x_i$ and time $t_0$ is:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\big(\\partial_t\\phi\\big)(x_i,t_0)\\;-\\;\\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; S_{\\mathrm{CH}}(x_i,t_0)\\Big)\n$$\nSubstitute the expression for $S_{\\mathrm{CH}}(x_i,t_0) = (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))|_{x_i,t_0}$:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi \\;-\\; \\Big(\\!-\\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i \\;+\\; \\mathcal{D}_2\\big[W'(\\phi)\\big]_i \\;+\\; (\\partial_t\\phi + \\varepsilon^2\\,\\partial_{xxxx}\\phi - \\partial_{xx}(W'(\\phi)))\\Big)\n$$\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\partial_t\\phi + \\varepsilon^2\\,\\mathcal{D}_4[\\phi]_i - \\mathcal{D}_2[W'(\\phi)]_i - \\partial_t\\phi - \\varepsilon^2\\,\\partial_{xxxx}\\phi + \\partial_{xx}(W'(\\phi))\n$$\nSimplifying, we obtain:\n$$\n\\mathcal{R}_{\\mathrm{CH},i} \\;=\\; \\varepsilon^2\\big(\\mathcal{D}_4[\\phi]_i - \\partial_{xxxx}\\phi(x_i, t_0)\\big) \\;+\\; \\big(\\partial_{xx}(W'(\\phi))(x_i,t_0) - \\mathcal{D}_2[W'(\\phi)]_i\\big)\n$$\nThis residual consists of two terms, each representing a truncation error. The first term is $\\varepsilon^2$ times the truncation error of the discrete biharmonic operator $\\mathcal{D}_4$. The second term is the truncation error of the discrete Laplacian $\\mathcal{D}_2$ acting on the nonlinear quantity $W'(\\phi)$. Both discrete operators $\\mathcal{D}_2$ and $\\mathcal{D}_4$ are second-order accurate, so the overall residual norm is expected to converge to zero as $O((\\Delta x)^2)$.\n\nThese simplified expressions for $\\mathcal{R}_{\\mathrm{AC},i}$ and $\\mathcal{R}_{\\mathrm{CH},i}$ will be implemented to compute the residual norms.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs, derives, and implements a code verification experiment for\n    Allen-Cahn and Cahn-Hilliard equations using MMS.\n    \"\"\"\n    # Define constants from the problem statement.\n    A = 0.6\n    B = 0.2\n    k = 1.0\n    q = 2.0\n    omega = 1.7\n    t0 = 0.37\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('AC', 64, 0.05),\n        ('AC', 128, 0.05),\n        ('CH', 64, 0.03),\n        ('CH', 128, 0.03),\n    ]\n\n    # Pre-calculate angular frequencies for efficiency\n    K = 2.0 * np.pi * k\n    Q = 2.0 * np.pi * q\n\n    # --- Analytical functions for the manufactured solution and its derivatives ---\n\n    def phi_fn(x, t):\n        \"\"\"Manufactured solution phi(x,t).\"\"\"\n        term1 = A * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dt_phi_fn(x, t):\n        \"\"\"Temporal derivative d(phi)/dt.\"\"\"\n        term1 = -A * omega * np.cos(K * x) * np.sin(omega * t)\n        term2 = B * omega * np.sin(Q * x) * np.cos(omega * t)\n        return term1 + term2\n\n    def dx_phi_fn(x, t):\n        \"\"\"First spatial derivative d(phi)/dx.\"\"\"\n        term1 = -A * K * np.sin(K * x) * np.cos(omega * t)\n        term2 = B * Q * np.cos(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def dxx_phi_fn(x, t):\n        \"\"\"Second spatial derivative d^2(phi)/dx^2.\"\"\"\n        term1 = -A * K**2 * np.cos(K * x) * np.cos(omega * t)\n        term2 = -B * Q**2 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n        \n    def dxxxx_phi_fn(x, t):\n        \"\"\"Fourth spatial derivative d^4(phi)/dx^4.\"\"\"\n        term1 = A * K**4 * np.cos(K * x) * np.cos(omega * t)\n        term2 = B * Q**4 * np.sin(Q * x) * np.sin(omega * t)\n        return term1 + term2\n\n    def w_prime_fn(p):\n        \"\"\"Derivative of the double-well potential W'(phi) = phi^3 - phi.\"\"\"\n        return p**3 - p\n\n    def dxx_w_prime_fn(p, dx_p, dxx_p):\n        \"\"\"Analytical second spatial derivative of W'(phi(x,t)).\"\"\"\n        # d/dx(W'(p)) = (3p^2 - 1) * dx_p\n        # d^2/dx^2(W'(p)) = 6p*(dx_p)^2 + (3p^2 - 1)*dxx_p\n        return 6.0 * p * dx_p**2 + (3.0 * p**2 - 1.0) * dxx_p\n\n    # --- Discrete operators with periodic boundary conditions ----\n\n    def d2_op(f, dx):\n        \"\"\"Second-order central difference for the second derivative.\"\"\"\n        f_im1 = np.roll(f, 1)  # f_{i-1}\n        f_ip1 = np.roll(f, -1) # f_{i+1}\n        return (f_im1 - 2.0 * f + f_ip1) / dx**2\n\n    def d4_op(f, dx):\n        \"\"\"Second-order central difference for the fourth derivative (biharmonic).\"\"\"\n        return d2_op(d2_op(f, dx), dx)\n\n    results = []\n    for eq_type, N, eps in test_cases:\n        dx = 1.0 / N\n        x = np.arange(N) * dx  # Grid points x_i = i * dx for i=0,...,N-1\n\n        # Evaluate the manufactured solution and its derivatives on the grid at t0\n        phi_vals = phi_fn(x, t0)\n\n        if eq_type == 'AC':\n            # Calculate the AC residual: R_AC = eps^2 * (exact_dxx - discrete_dxx)\n            exact_dxx_phi = dxx_phi_fn(x, t0)\n            discrete_dxx_phi = d2_op(phi_vals, dx)\n            residual = eps**2 * (exact_dxx_phi - discrete_dxx_phi)\n        \n        elif eq_type == 'CH':\n            # Calculate CH residual: R_CH = eps^2(D4[p]-d4p) + (d2(W') - D2[W'])\n            # Term 1: Discretization error of the biharmonic operator\n            exact_dxxxx_phi = dxxxx_phi_fn(x, t0)\n            discrete_d4_phi = d4_op(phi_vals, dx)\n            term1 = eps**2 * (discrete_d4_phi - exact_dxxxx_phi)\n            \n            # Term 2: Discretization error of the Laplacian on W'(phi)\n            w_prime_vals = w_prime_fn(phi_vals)\n            discrete_d2_w_prime = d2_op(w_prime_vals, dx)\n            \n            # For exact dxx(W'), we need exact phi, dx_phi, and dxx_phi\n            dx_phi_vals = dx_phi_fn(x, t0)\n            dxx_phi_vals = dxx_phi_fn(x, t0)\n            exact_dxx_w_prime_vals = dxx_w_prime_fn(phi_vals, dx_phi_vals, dxx_phi_vals)\n            \n            term2 = exact_dxx_w_prime_vals - discrete_d2_w_prime\n            \n            residual = term1 + term2\n\n        # Calculate the discrete L2 norm of the residual\n        # ||R||_h = sqrt( sum(R_i^2 * dx) )\n        norm = np.sqrt(np.sum(residual**2) * dx)\n        results.append(norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Phase-field equations are fundamentally gradient flows, meaning they evolve in a way that consistently decreases a free energy functional. A reliable numerical scheme must respect this property, along with any conservation laws like the mass conservation inherent to the Cahn-Hilliard equation. This practice  challenges you to implement a spectrally-accurate solver and verify these crucial physical consistency properties, ensuring your simulations are not just numerically correct but also physically meaningful.",
            "id": "3430539",
            "problem": "Implement and verify numerical solvers for phase-field interface evolution based on the Allen–Cahn and Cahn–Hilliard equations under periodic boundary conditions on a two-dimensional square domain. The implementation must be a complete, runnable program that uses a spectrally accurate spatial discretization and a first-order, stabilized, semi-implicit time discretization consistent with the gradient-flow structure. The required checks focus on consistency properties: free-energy decay for gradient flows, exact mass conservation for Cahn–Hilliard, and temporal-order estimation for the time-stepping scheme.\n\nThe fundamental base is as follows. The Allen–Cahn equation is the $L^{2}$ gradient flow of the Ginzburg–Landau energy, and the Cahn–Hilliard equation is the $H^{-1}$ gradient flow of the same energy. Let the free energy functional be\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\nwith double-well potential\n$$\nF(u) = \\frac{(u^{2} - 1)^{2}}{4}.\n$$\nThe first variation gives the chemical potential\n$$\n\\mu = \\frac{\\delta \\mathcal{E}}{\\delta u} = -\\varepsilon^{2} \\Delta u + F'(u),\n\\quad F'(u) = u^{3} - u.\n$$\nThe gradient flows are\n$$\n\\text{Allen–Cahn:} \\quad \\frac{\\partial u}{\\partial t} = - M \\mu\n= \\varepsilon^{2} \\Delta u - F'(u),\n$$\n$$\n\\text{Cahn–Hilliard:} \\quad \\frac{\\partial u}{\\partial t} = \\nabla \\cdot ( M \\nabla \\mu )\n= \\Delta \\mu = -\\varepsilon^{2} \\Delta^{2} u + \\Delta F'(u),\n$$\nwhere $M$ is the mobility, set to $M=1$ for simplicity. Both problems are posed on $\\Omega = [0,L] \\times [0,L]$ with periodic boundary conditions. The spatial discretization must use the Fast Fourier Transform (FFT) with wavenumbers consistent with the domain size, and the time discretization must be first-order, stabilized, semi-implicit in the linear stiff terms and explicit in the nonlinear terms, adding a linear stabilization term with coefficient $S > 0$ to ensure unconditional stability of the treated linear part without violating the gradient-flow structure.\n\nThe discrete free energy to monitor is the trapezoidal Riemann sum consistent with the spectral representation of the gradient term. Denoting by $\\widehat{u}$ the discrete Fourier transform of $u$, and using physical wavenumbers $\\boldsymbol{k} = (k_{x}, k_{y})$ with $k_{x}, k_{y} \\in \\frac{2\\pi}{L} \\mathbb{Z}$, the discrete energy must be computed as\n$$\n\\mathcal{E}_{h}(u) = \\frac{\\varepsilon^{2}}{2} \\, \\Delta x^{2} \\, \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\boldsymbol{k} \\rvert^{2} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}\n\\;+\\; \\Delta x^{2} \\sum_{i,j} F\\big(u(x_{i},y_{j})\\big),\n$$\nwhere $N \\times N$ is the number of grid points, $\\Delta x = L/N$, and the discrete Fourier transform is unnormalized so that Parseval's identity in discrete form is $\\sum_{i,j} \\lvert u_{ij} \\rvert^{2} = \\frac{1}{N^{2}} \\sum_{\\boldsymbol{k}} \\lvert \\widehat{u}(\\boldsymbol{k}) \\rvert^{2}$. The discrete mass is\n$$\nm_{h}(u) = \\Delta x^{2} \\sum_{i,j} u(x_{i},y_{j}).\n$$\n\nYour implementation must:\n\n1. Use a two-dimensional Fourier spectral discretization on a uniform grid and periodic boundary conditions, with $N$ points per dimension over $[0,L]$ and physical wavenumbers computed from the domain size.\n\n2. Implement a first-order stabilized semi-implicit scheme compatible with the gradient-flow structure for both equations. The stabilization coefficient $S$ must be positive, and the nonlinear term $F'(u)$ must be treated explicitly, while the linear stiff terms are treated implicitly. The scheme must preserve the zero-wavenumber mode for the Cahn–Hilliard update exactly to machine precision, thus conserving mass.\n\n3. Compute and monitor the discrete free energy $\\mathcal{E}_{h}(u^{n})$ at every time step for the energy decay checks, and compute $m_{h}(u^{n})$ for the mass conservation check.\n\n4. For temporal convergence, estimate the observed order $p$ by running the Allen–Cahn solver with three different time steps $\\Delta t$, $\\Delta t/2$, and $\\Delta t/4$ up to the same final time and computing\n$$\ne_{12} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t}(x_{i},y_{j},T) - u_{\\Delta t/2}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2}, \\quad\ne_{23} = \\left( \\Delta x^{2} \\sum_{i,j} \\big(u_{\\Delta t/2}(x_{i},y_{j},T) - u_{\\Delta t/4}(x_{i},y_{j},T)\\big)^{2} \\right)^{1/2},\n$$\nand reporting\n$$\np = \\frac{\\log(e_{12}/e_{23})}{\\log(2)}.\n$$\n\nUse the following test suite with parameters carefully chosen to test the required properties. The domain length is $L=1.0$ in all cases. Angles, if used, must be in radians. No physical units beyond the dimensionless setup are required.\n\n- Test case $1$ (Allen–Cahn energy monotonicity): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output a boolean indicating whether $\\mathcal{E}_{h}(u^{n})$ is monotonically nonincreasing for all steps within a tolerance of $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$.\n\n- Test case $2$ (Cahn–Hilliard mass conservation): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L) + 0.1$. Output the absolute drift $\\lvert m_{h}(u^{T}) - m_{h}(u^{0}) \\rvert$ as a float.\n\n- Test case $3$ (Allen–Cahn temporal order estimate): $N=32$, $\\varepsilon=0.02$, $S=2.0$, three time steps $\\Delta t=2\\times 10^{-3}$, $\\Delta t/2=10^{-3}$, and $\\Delta t/4=5\\times 10^{-4}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.3 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output the estimated observed order $p$ as a float.\n\n- Test case $4$ (Cahn–Hilliard energy monotonicity): $N=64$, $\\varepsilon=0.02$, $S=2.0$, $\\Delta t=10^{-3}$, final time $T=0.2$, initial condition $u_{0}(x,y) = 0.2 \\cos(2\\pi x/L) \\cos(2\\pi y/L)$. Output a boolean indicating whether $\\mathcal{E}_{h}(u^{n})$ is monotonically nonincreasing for all steps within a tolerance of $10^{-10}\\,\\mathcal{E}_{h}(u^{0})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). The four results must be, in order, the boolean from test case $1$, the float from test case $2$, the float from test case $3$, and the boolean from test case $4$.",
            "solution": "The user requests the implementation and verification of numerical solvers for the Allen-Cahn (AC) and Cahn-Hilliard (CH) equations on a two-dimensional periodic domain. The verification will focus on energy monotonicity, mass conservation, and temporal convergence order.\n\nThe governing equations are gradient flows of the Ginzburg-Landau free energy functional:\n$$\n\\mathcal{E}(u) = \\int_{\\Omega} \\left( \\frac{\\varepsilon^{2}}{2} \\lvert \\nabla u \\rvert^{2} + F(u) \\right) \\, \\mathrm{d}x,\n$$\nwhere $F(u) = \\frac{1}{4}(u^2-1)^2$ is a double-well potential. The chemical potential is the variational derivative of the energy, $\\mu = \\delta \\mathcal{E} / \\delta u = -\\varepsilon^2 \\Delta u + F'(u)$, with $F'(u) = u^3-u$.\n\nThe Allen-Cahn equation is the $L^2$ gradient flow, $\\partial_t u = -\\mu$:\n$$\n\\frac{\\partial u}{\\partial t} = \\varepsilon^{2} \\Delta u - (u^3 - u)\n$$\nThe Cahn-Hilliard equation is the $H^{-1}$ gradient flow, $\\partial_t u = \\Delta \\mu$:\n$$\n\\frac{\\partial u}{\\partial t} = \\Delta(-\\varepsilon^2 \\Delta u + u^3-u) = -\\varepsilon^2 \\Delta^2 u + \\Delta(u^3-u)\n$$\n\nThe solution employs a Fourier spectral method for spatial discretization on a uniform $N \\times N$ grid over the domain $\\Omega = [0,L] \\times [0,L]$. The use of the Fast Fourier Transform (FFT) is ideal for periodic boundary conditions, as it diagonalizes the constant-coefficient differential operators (like $\\Delta$ and $\\Delta^2$), turning the partial differential equations into a system of ordinary differential equations in Fourier space. The Laplacian $\\Delta$ corresponds to multiplication by $-|\\boldsymbol{k}|^2 = -(k_x^2 + k_y^2)$ for each wavenumber vector $\\boldsymbol{k}$. Similarly, the biharmonic operator $\\Delta^2$ corresponds to multiplication by $|\\boldsymbol{k}|^4$.\n\nFor time discretization, a first-order, stabilized, semi-implicit scheme is required. This class of schemes treats stiff linear terms implicitly for stability while handling nonlinear terms explicitly for simplicity. To guarantee energy stability for any time step size (unconditional stability), a linear stabilization term is added. A common and robust approach is the linearly stabilized scheme, which has the general form in the time-discrete domain:\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = \\mathcal{L}u^{n+1} + \\mathcal{N}(u^n) - \\mathcal{S}(u^{n+1}-u^n)\n$$\nwhere $\\mathcal{L}$ is the linear differential operator, $\\mathcal{N}$ is the nonlinear term, and $\\mathcal{S}$ is the stabilization operator. For the AC and CH equations, this leads to the following schemes in Fourier space, where $\\widehat{u}$ is the discrete Fourier transform of $u$:\n\nFor Allen-Cahn, $\\mathcal{L}u = \\varepsilon^2 \\Delta u$, $\\mathcal{N}(u) = -F'(u)$, and the stabilization is $\\mathcal{S} = S \\cdot I$ (identity operator). The Fourier-space update is:\n$$\n\\widehat{u}^{n+1} = \\frac{(1 + S \\Delta t) \\widehat{u}^n - \\Delta t \\widehat{F'(u^n)}}{1 + S \\Delta t + \\varepsilon^2 |\\boldsymbol{k}|^2 \\Delta t}\n$$\nThis scheme is unconditionally energy-stable for any $S>0$.\n\nFor Cahn-Hilliard, $\\mathcal{L}u = -\\varepsilon^2 \\Delta^2 u$, $\\mathcal{N}(u) = \\Delta F'(u)$. To maintain the conservative nature ($H^{-1}$ structure), the stabilization operator is chosen as $\\mathcal{S} = -S \\Delta$. The scheme becomes:\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} = (-\\varepsilon^2\\Delta^2 - S\\Delta) u^{n+1} + \\Delta F'(u^n) + S\\Delta u^n\n$$\nIn Fourier space, this yields the update rule:\n$$\n\\widehat{u}^{n+1} = \\frac{\\widehat{u}^n(1 + S\\Delta t|\\boldsymbol{k}|^2) - \\Delta t |\\boldsymbol{k}|^2 \\widehat{F'(u^n)}}{1 + \\Delta t(\\varepsilon^2|\\boldsymbol{k}|^4 + S|\\boldsymbol{k}|^2)}\n$$\nThis scheme is unconditionally energy-stable for $S \\ge 0$. Notably, for the zero-wavenumber mode ($\\boldsymbol{k}=\\boldsymbol{0}$), $|\\boldsymbol{k}|=0$, the update simplifies to $\\widehat{u}^{n+1}(\\boldsymbol{0}) = \\widehat{u}^n(\\boldsymbol{0})$, which ensures exact conservation of the total mass, $\\int u \\, \\mathrm{d}x$, to machine precision.\n\nThe implementation consists of a main solver function that dispatches four test cases. A general-purpose simulation function handles the core logic for both equation types. Helper functions compute the discrete energy and mass as defined in the problem statement.\n\n1.  **Energy Monotonicity Checks (Tests 1 & 4):** The discrete energy $\\mathcal{E}_h(u^n)$ is computed at each time step. The test passes if the energy is non-increasing throughout the simulation, within a small numerical tolerance, i.e., $\\mathcal{E}_h(u^{n+1}) \\le \\mathcal{E}_h(u^n) + \\text{tol}$.\n\n2.  **Mass Conservation Check (Test 2):** For the Cahn-Hilliard equation, the total discrete mass $m_h(u) = \\Delta x^2 \\sum_{i,j} u_{ij}$ is computed for the initial and final states. The absolute difference is reported.\n\n3.  **Temporal Order Estimation (Test 3):** The Allen-Cahn equation is solved up to time $T$ using three successively halved time steps ($\\Delta t, \\Delta t/2, \\Delta t/4$). The discrete $L^2$ errors between the solutions, $e_{12}$ and $e_{23}$, are computed. The observed order of convergence $p$ is then estimated using the formula $p = \\log(e_{12}/e_{23})/\\log(2)$. For a first-order scheme, $p$ is expected to be approximately $1$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies numerical solvers for Allen-Cahn and Cahn-Hilliard equations\n    based on the specified test suite.\n    \"\"\"\n\n    def compute_energy(u, K2, epsilon, dx, N):\n        \"\"\"\n        Computes the discrete Ginzburg-Landau free energy according to the problem specification.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            K2 (np.ndarray): The squared magnitudes of the wavenumbers.\n            epsilon (float): The interface width parameter.\n            dx (float): The grid spacing.\n            N (int): The number of grid points in one dimension.\n            \n        Returns:\n            float: The total discrete free energy.\n        \"\"\"\n        u_hat = np.fft.fftn(u)\n        \n        # Gradient term, consistent with the specified Parseval's identity.\n        grad_energy_term = (epsilon**2 / 2.0) * dx**2 * (1.0 / (N**2)) * np.sum(K2 * np.abs(u_hat)**2)\n        \n        # Potential term.\n        potential_F = (u**2 - 1.0)**2 / 4.0\n        potential_energy_term = dx**2 * np.sum(potential_F)\n        \n        return grad_energy_term + potential_energy_term\n\n    def compute_mass(u, dx):\n        \"\"\"\n        Computes the discrete total mass.\n        \n        Args:\n            u (np.ndarray): The field variable on a 2D grid.\n            dx (float): The grid spacing.\n        \n        Returns:\n            float: The total discrete mass.\n        \"\"\"\n        return dx**2 * np.sum(u)\n\n    def run_simulation(eq_type, N, L, epsilon, S, dt, T, u0_func, track_energy=False):\n        \"\"\"\n        Runs a simulation for either the Allen-Cahn or Cahn-Hilliard equation.\n        \n        Args:\n            eq_type (str): 'AC' for Allen-Cahn, 'CH' for Cahn-Hilliard.\n            N (int): Grid points per dimension.\n            L (float): Domain size.\n            epsilon (float): Interface width parameter.\n            S (float): Stabilization coefficient.\n            dt (float): Time step size.\n            T (float): Final time.\n            u0_func (callable): Function to generate the initial condition u0(X, Y).\n            track_energy (bool): If True, computes and returns the energy at each step.\n            \n        Returns:\n            tuple: A tuple containing the final field u (np.ndarray) and a list of energies.\n        \"\"\"\n        dx = L / N\n        \n        # Set up grid and wavenumbers. `indexing='ij'` ensures (row, col) consistency.\n        x_1d = np.arange(N) * dx\n        X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n        \n        k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        KX, KY = np.meshgrid(k_1d, k_1d, indexing='ij')\n        K2 = KX**2 + KY**2\n\n        u = u0_func(X, Y)\n\n        # Precompute denominators for Fourier-space updates.\n        if eq_type == 'AC':\n            denom = 1.0 + S * dt + epsilon**2 * K2 * dt\n        elif eq_type == 'CH':\n            K4 = K2**2\n            denom = 1.0 + dt * (epsilon**2 * K4 + S * K2)\n        else:\n            raise ValueError(\"Unknown equation type\")\n\n        num_steps = int(round(T / dt))\n        \n        energies = []\n        if track_energy:\n            energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        for _ in range(num_steps):\n            Fprime = u**3 - u\n            \n            u_hat = np.fft.fftn(u)\n            Fprime_hat = np.fft.fftn(Fprime)\n\n            if eq_type == 'AC':\n                u_hat_new = ((1.0 + S * dt) * u_hat - dt * Fprime_hat) / denom\n            else:  # CH\n                u_hat_new = (u_hat * (1.0 + S * dt * K2) - dt * K2 * Fprime_hat) / denom\n\n            u = np.fft.ifftn(u_hat_new).real\n\n            if track_energy:\n                energies.append(compute_energy(u, K2, epsilon, dx, N))\n\n        return u, energies\n\n    # Set common domain size\n    L = 1.0\n    \n    # Test cases defined in the problem statement\n    test_cases = [\n        # (1) Allen-Cahn energy monotonicity check\n        {\n            \"id\": 1, \"type\": \"AC\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (2) Cahn-Hilliard mass conservation check\n        {\n            \"id\": 2, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L) + 0.1\n        },\n        # (3) Allen-Cahn temporal order estimation\n        {\n            \"id\": 3, \"type\": \"AC\", \"N\": 32, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dts\": [2e-3, 1e-3, 5e-4], \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.3 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        },\n        # (4) Cahn-Hilliard energy monotonicity check\n        {\n            \"id\": 4, \"type\": \"CH\", \"N\": 64, \"epsilon\": 0.02, \"S\": 2.0,\n            \"dt\": 1e-3, \"T\": 0.2,\n            \"u0_func\": lambda X, Y: 0.2 * np.cos(2*np.pi*X/L) * np.cos(2*np.pi*Y/L)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"id\"] == 1:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1] > energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n        elif case[\"id\"] == 2:\n            p = case\n            dx = L / p[\"N\"]\n            x_1d = np.arange(p[\"N\"]) * dx\n            X, Y = np.meshgrid(x_1d, x_1d, indexing='ij')\n            u_initial = p[\"u0_func\"](X, Y)\n            m0 = compute_mass(u_initial, dx)\n            \n            u_final, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"])\n            \n            mf = compute_mass(u_final, dx)\n            results.append(abs(mf - m0))\n\n        elif case[\"id\"] == 3:\n            p = case\n            u_final_dt1, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][0], p[\"T\"], p[\"u0_func\"])\n            u_final_dt2, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][1], p[\"T\"], p[\"u0_func\"])\n            u_final_dt3, _ = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dts\"][2], p[\"T\"], p[\"u0_func\"])\n            \n            dx = L / p[\"N\"]\n            e12 = dx * np.sqrt(np.sum((u_final_dt1 - u_final_dt2)**2))\n            e23 = dx * np.sqrt(np.sum((u_final_dt2 - u_final_dt3)**2))\n            \n            if e12 > 0 and e23 > 0 and e12 / e23 > 0:\n                order = np.log(e12 / e23) / np.log(2.0)\n            else:\n                order = 0.0 # Indicate failure or no convergence\n            results.append(order)\n\n        elif case[\"id\"] == 4:\n            p = case\n            _, energies = run_simulation(p[\"type\"], p[\"N\"], L, p[\"epsilon\"], p[\"S\"], p[\"dt\"], p[\"T\"], p[\"u0_func\"], track_energy=True)\n            \n            is_monotonic = True\n            E0 = energies[0]\n            tolerance = 1e-10 * abs(E0) if E0 != 0 else 1e-10\n            for i in range(len(energies) - 1):\n                if energies[i+1] > energies[i] + tolerance:\n                    is_monotonic = False\n                    break\n            results.append(is_monotonic)\n\n    # Format output as specified: comma-separated list in brackets, booleans as lowercase\n    formatted_results = []\n    for r in results:\n        if isinstance(r, (bool, np.bool_)):\n            formatted_results.append(str(r).lower())\n        else:\n            formatted_results.append(f\"{r:.15g}\")\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world systems often require more complex models than the standard Allen-Cahn or Cahn-Hilliard equations. This advanced practice  introduces a degenerate mobility, which confines phase evolution to the interfaces and is crucial for modeling phenomena like solidification. You will develop a finite element scheme for this challenging non-linear problem and use it to explore the numerical artifact of interface pinning, a critical issue that arises when the physical interface scale $\\varepsilon$ becomes too small for the computational grid.",
            "id": "3430598",
            "problem": "Consider the Cahn–Hilliard equation on the periodic one-dimensional domain $[0,1]$ with a degenerate mobility,\n$$\n\\partial_t \\phi = \\partial_x \\left( M(\\phi)\\, \\partial_x \\mu \\right), \\qquad \\mu = -\\varepsilon^2 \\partial_{xx} \\phi + W'(\\phi),\n$$\nwhere $W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2$ is the symmetric double-well potential and $M(\\phi) = (1 - \\phi^2)_+$ is the degenerate mobility, with $(\\cdot)_+$ denoting the positive part. The unknown $\\phi(x,t)$ represents a phase-field order parameter taking values close to $-1$ and $+1$ in the bulk phases, and $\\varepsilon > 0$ controls the interfacial thickness.\n\nYour task is to design and implement a linear finite element discretization that, by construction, preserves nonnegative mobility pointwise and allows you to quantitatively assess the competition between interface pinning and artificial diffusion as $\\varepsilon \\to 0$.\n\nStarting from the variational form obtained by multiplying the equations by test functions and integrating over $[0,1]$ with periodic boundary conditions, proceed as follows:\n\n- Use continuous, piecewise-linear finite elements on a uniform mesh of $N$ nodes with periodic boundary conditions, and apply mass lumping to the $L^2$ inner products so that the mass matrix is diagonal.\n- Discretize the mobility in a way that preserves nonnegativity pointwise: evaluate $M(\\phi)$ at the nodes and define the elementwise coefficient on each mesh edge as the arithmetic mean of the adjacent nodal mobilities. Assemble the corresponding mobility-weighted stiffness operator so that it is symmetric positive semidefinite for any nonnegative element coefficients.\n- Use a linear semi-implicit time discretization derived from the gradient flow structure by treating the interfacial term implicitly and the nonlinear bulk term explicitly, stabilized by adding a linear term proportional to $\\phi^{n+1}-\\phi^n$ with a stabilization parameter $s>0$. Choose a fixed $s$ that is large enough to ensure linear well-posedness and numerical stability without destroying the degenerate mobility structure in space.\n\nQuantify two diagnostics at a final time for several parameter values:\n\n1. Nonnegative mobility preservation: compute the minimal element mobility at the final time, defined as the minimum over elements of the arithmetic average of the two adjacent nodal values of $M(\\phi)$, and report it as a nonnegative float.\n2. Interface width versus $\\varepsilon$: for an initial condition consisting of a smooth droplet of the $+1$ phase in a $-1$ background,\n$$\n\\phi(x,0) = -\\tanh\\!\\left(\\frac{x-x_L}{\\sqrt{2}\\,\\varepsilon}\\right)\\tanh\\!\\left(\\frac{x-x_R}{\\sqrt{2}\\,\\varepsilon}\\right),\n$$\nwith $x_L = 0.3$ and $x_R = 0.7$, approximate the total length of the interfacial region at the final time as the measure of the set where $|\\phi(x,t_{\\text{final}})| < 0.9$, computed on the mesh. Divide this length by $2$ (because there are two interfaces) to obtain a per-interface width estimate, and then normalize by $\\varepsilon$ to obtain a dimensionless width ratio. This ratio is expected to be approximately constant for well-resolved interfaces and to drop when the interface pins to the mesh as $\\varepsilon/h \\to 0$ (with $h$ the mesh size), while excessive artificial diffusion would increase it.\n\nUse the following time-stepping and mesh parameters as a test suite, with periodic boundary conditions on $[0,1]$ and the stabilization parameter $s$ set to a fixed value:\n\n- Test case $1$ (well-resolved interface): $(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.05, 2\\times 10^{-4}, 60)$.\n- Test case $2$ (moderately resolved interface): $(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.01, 2\\times 10^{-4}, 60)$.\n- Test case $3$ (under-resolved interface prone to pinning): $(N, \\varepsilon, \\Delta t, n_{\\mathrm{steps}}) = (256, 0.002, 2\\times 10^{-4}, 60)$.\n\nFor each test case, run the discretization until the specified final time, and compute:\n- The normalized per-interface width ratio at the final time, as defined above, as a float.\n- The minimal element mobility at the final time, as a float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case and containing two floats per test case in the sequence $[\\text{width\\_ratio}_1,\\text{min\\_mobility}_1,\\text{width\\_ratio}_2,\\text{min\\_mobility}_2,\\text{width\\_ratio}_3,\\text{min\\_mobility}_3]$. There are no physical units in this problem; all quantities are nondimensional. Angles are not involved. Express all numbers as standard decimal floats without percentage signs.",
            "solution": "The problem asks for the design and implementation of a finite element-based numerical scheme for the Cahn-Hilliard equation with degenerate mobility on a one-dimensional periodic domain. The goal is to simulate phase evolution and compute specific diagnostics related to mobility preservation and interface pinning.\n\nThe governing Cahn-Hilliard equation system is given by:\n$$\n\\partial_t \\phi = \\partial_x \\left( M(\\phi)\\, \\partial_x \\mu \\right)\n$$\n$$\n\\mu = -\\varepsilon^2 \\partial_{xx} \\phi + W'(\\phi)\n$$\nwhere $\\phi(x,t)$ is the phase-field variable, $\\mu(x,t)$ is the chemical potential, $\\varepsilon$ is the interface width parameter, $W(\\phi) = \\frac{1}{4}(\\phi^2-1)^2$ is the double-well potential, and $M(\\phi) = (1-\\phi^2)_+$ is the degenerate mobility. The domain is $[0,1]$ with periodic boundary conditions.\n\nFirst, we derive the weak formulation. We multiply the equations by suitable test functions, $v(x)$ for the first equation and $q(x)$ for the second, and integrate over the domain $[0,1]$. Using integration by parts and the periodic boundary conditions (which cause boundary terms to vanish), we obtain:\n$$\n\\int_0^1 \\partial_t \\phi \\, v \\, dx = - \\int_0^1 M(\\phi) (\\partial_x \\mu) (\\partial_x v) \\, dx\n$$\n$$\n\\int_0^1 \\mu \\, q \\, dx = \\varepsilon^2 \\int_0^1 (\\partial_x \\phi) (\\partial_x q) \\, dx + \\int_0^1 W'(\\phi) \\, q \\, dx\n$$\n\nWe discretize in space using continuous, piecewise-linear (P1) finite elements on a uniform mesh of $N$ nodes $x_j=j h$ for $j=0, \\ldots, N-1$ with mesh size $h=1/N$. The solution $\\phi(x,t)$ is approximated by $\\phi_h(x,t) = \\sum_{j=0}^{N-1} \\phi_j(t) N_j(x)$, where $N_j(x)$ are the P1 basis functions (hat functions). We apply this expansion to $\\phi$, $\\mu$, and the test functions $v, q$. The problem specifies using mass lumping, which diagonalizes the mass matrix $\\mathbf{M}$ with entries $M_{ij} = \\int_0^1 N_i N_j dx$. For a uniform 1D mesh, the lumped mass matrix is $\\mathbf{M}_{\\text{lump}} = h \\mathbf{I}$, where $\\mathbf{I}$ is the identity matrix.\n\nThe spatial discretization leads to a system of ordinary differential equations (ODEs):\n$$\nh \\frac{d\\boldsymbol{\\phi}}{dt} = -\\mathbf{K}_M \\boldsymbol{\\mu}\n$$\n$$\nh \\boldsymbol{\\mu} = \\varepsilon^2 \\mathbf{K} \\boldsymbol{\\phi} + h \\mathbf{W}'(\\boldsymbol{\\phi})\n$$\nwhere $\\boldsymbol{\\phi}(t)$ and $\\boldsymbol{\\mu}(t)$ are vectors of nodal values.\nThe stiffness matrix $\\mathbf{K}$ has entries $K_{ij} = \\int_0^1 N_i'(x) N_j'(x) dx$. For a uniform periodic mesh, it is a symmetric, circulant, tridiagonal matrix with the stencil $\\frac{1}{h}[-1, 2, -1]$.\nThe mobility-weighted stiffness matrix $\\mathbf{K}_M$ is assembled as specified. The mobility $M(\\phi)$ is evaluated at the nodes, $M_j = M(\\phi_j)$. On each element (edge) $[x_j, x_{j+1}]$, the mobility is approximated by the constant arithmetic mean $M_{j+1/2} = (M_j + M_{j+1})/2$. The matrix entries are $(\\mathbf{K}_M)_{ij} = \\int_0^1 M_h(x) N_i'(x) N_j'(x) dx$, where $M_h(x)$ is the piecewise constant approximation. This results in a symmetric, circulant, tridiagonal matrix whose entries depend on the nodal mobility values. For instance, the diagonal entry $(\\mathbf{K}_M)_{jj}$ is $\\frac{1}{h}(M_{j-1/2} + M_{j+1/2})$, and the off-diagonal $(\\mathbf{K}_M)_{j,j+1}$ is $-\\frac{1}{h}M_{j+1/2}$. Since $M(\\phi) \\ge 0$, $\\mathbf{K}_M$ is symmetric positive semidefinite. The vector $\\mathbf{W}'(\\boldsymbol{\\phi})$ contains the nodal values of the potential's derivative, $W'(\\phi_j) = \\phi_j^3 - \\phi_j$.\n\nFor time discretization, we use the specified linear semi-implicit scheme. The highly stiff term involving $\\varepsilon^2$ is treated implicitly, while the nonlinear potential term $W'(\\phi)$ is treated explicitly. A stabilization term $s(\\phi^{n+1}-\\phi^n)$ is added. A suitable value for the stabilization parameter $s$ must be chosen. The potential $W(\\phi)$ is a sum of a convex part and a concave part. The scheme is stabilized against the concave part by adding and subtracting a quadratic term $\\frac{s}{2}\\phi^2$. The stability of this scheme generally requires $s \\ge \\max|W''(\\phi)|$ over the relevant range of $\\phi$. Since $W''(\\phi) = 3\\phi^2 - 1$, its minimum is $-1$ at $\\phi=0$. Thus, a choice of $s=1.0$ is sufficient to ensure linear stability. The resulting time-marching scheme from time $t_n$ to $t_{n+1}=t_n+\\Delta t$ is:\n$$\nh \\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = - \\mathbf{K}_{M^n} \\boldsymbol{\\mu}^{n+1}\n$$\n$$\nh \\boldsymbol{\\mu}^{n+1} = \\varepsilon^2 \\mathbf{K} \\boldsymbol{\\phi}^{n+1} + h \\mathbf{W}'(\\boldsymbol{\\phi}^n) + s h(\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n)\n$$\nwhere $\\mathbf{K}_{M^n}$ is the mobility matrix evaluated using $\\boldsymbol{\\phi}^n$.\n\nWe solve for $\\boldsymbol{\\phi}^{n+1}$ by combining these two equations. First, we express $\\boldsymbol{\\mu}^{n+1}$ from the second equation:\n$$\n\\boldsymbol{\\mu}^{n+1} = \\left(\\frac{\\varepsilon^2}{h}\\mathbf{K} + s\\mathbf{I}\\right) \\boldsymbol{\\phi}^{n+1} + \\left(\\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n\\right)\n$$\nSubstituting this into the first equation gives:\n$$\nh \\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = - \\mathbf{K}_{M^n} \\left[ \\left(\\frac{\\varepsilon^2}{h}\\mathbf{K} + s\\mathbf{I}\\right) \\boldsymbol{\\phi}^{n+1} + \\left(\\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n\\right) \\right]\n$$\nRearranging this equation yields a linear system of the form $\\mathbf{A} \\boldsymbol{\\phi}^{n+1} = \\mathbf{b}$:\n$$\n\\left( h\\mathbf{I} + \\frac{\\Delta t \\varepsilon^2}{h} \\mathbf{K}_{M^n} \\mathbf{K} + s \\Delta t \\mathbf{K}_{M^n} \\right) \\boldsymbol{\\phi}^{n+1} = h\\boldsymbol{\\phi}^n - \\Delta t \\mathbf{K}_{M^n} \\left( \\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n \\right)\n$$\nThe system matrix $\\mathbf{A} = h\\mathbf{I} + \\frac{\\Delta t \\varepsilon^2}{h} \\mathbf{K}_{M^n} \\mathbf{K} + s \\Delta t \\mathbf{K}_{M^n}$ is a sparse, pentadiagonal matrix with additional corner entries due to periodicity. The right-hand side vector is $\\mathbf{b} = h\\boldsymbol{\\phi}^n - \\Delta t \\mathbf{K}_{M^n} \\left( \\mathbf{W}'(\\boldsymbol{\\phi}^n) - s\\boldsymbol{\\phi}^n \\right)$. At each time step, this linear system is assembled and solved for $\\boldsymbol{\\phi}^{n+1}$.\n\nAfter running the simulation for the specified number of steps, we compute the two required diagnostics from the final state $\\boldsymbol{\\phi}_{\\text{final}}$:\n1.  Minimal element mobility: First, compute nodal mobilities $M_j = (1-\\phi_j^2)_+$. Then, for each element/edge $j$ (from $0$ to $N-1$), compute the average mobility $M_{j+1/2} = (M_j + M_{j+1})/2$ (with $M_N=M_0$ for periodicity). The minimal element mobility is the minimum value among all these averages.\n2.  Normalized per-interface width ratio: We identify the interfacial region as the set of points where $|\\phi(x,t_{\\text{final}})| < 0.9$. On the discrete mesh, its total length is approximated by $L_{\\text{int}} = h \\times (\\text{number of nodes } j \\text{ where } |\\phi_j| < 0.9)$. Since the initial condition creates two interfaces, the width per interface is $W_{\\text{int}} = L_{\\text{int}}/2$. The final normalized ratio is this width divided by the parameter $\\varepsilon$, i.e., $W_{\\text{int}}/\\varepsilon$.\n\nThe implementation will use sparse matrix representations from `scipy.sparse` to efficiently construct and handle the matrices $\\mathbf{K}$, $\\mathbf{K}_{M^n}$, and $\\mathbf{A}$, and `scipy.sparse.linalg.spsolve` to solve the linear system at each time step.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Cahn-Hilliard equation with degenerate mobility using a\n    semi-implicit finite element method and computes specified diagnostics.\n    \"\"\"\n    test_cases = [\n        # (N, epsilon, dt, n_steps)\n        (256, 0.05, 2e-4, 60),\n        (256, 0.01, 2e-4, 60),\n        (256, 0.002, 2e-4, 60),\n    ]\n\n    # Parameters from the problem statement\n    x_L = 0.3\n    x_R = 0.7\n    s = 1.0  # Stabilization parameter, chosen as per the theory\n\n    results = []\n\n    for N, eps, dt, n_steps in test_cases:\n        h = 1.0 / N\n        x = np.linspace(0, 1, N, endpoint=False)\n\n        # Initial condition\n        arg1 = (x - x_L) / (np.sqrt(2.0) * eps)\n        arg2 = (x - x_R) / (np.sqrt(2.0) * eps)\n        phi = -np.tanh(arg1) * np.tanh(arg2)\n\n        # Stiffness matrix K (circulant tridiagonal for periodic BCs)\n        # Corresponds to operator -d^2/dx^2, weak form gives K_ij = int(N_i' N_j')\n        diag_K = np.full(N, 2.0 / h)\n        off_diag_K = np.full(N - 1, -1.0 / h)\n        K = diags([off_diag_K, diag_K, off_diag_K], [-1, 0, 1], shape=(N, N), format='csc')\n        K[0, N - 1] = -1.0 / h\n        K[N - 1, 0] = -1.0 / h\n\n        # Time stepping loop\n        for _ in range(n_steps):\n            # Compute nonlinear potential term W'(phi) = phi^3 - phi\n            w_prime = phi**3 - phi\n\n            # Compute nodal mobilities M(phi) = (1 - phi^2)_+\n            m_nodes = np.maximum(0, 1.0 - phi**2)\n\n            # Assemble mobility-weighted stiffness matrix KM\n            # Average mobility on edges\n            m_edges = (m_nodes + np.roll(m_nodes, -1)) / 2.0\n            \n            diag_KM = (m_edges + np.roll(m_edges, 1)) / h\n            off_diag_KM = -m_edges[:-1] / h\n            \n            KM = diags([off_diag_KM, diag_KM, off_diag_KM], [-1, 0, 1], shape=(N, N), format='csc')\n            KM[0, N - 1] = -m_edges[-1] / h\n            KM[N - 1, 0] = -m_edges[-1] / h\n            \n            # Assemble the linear system A * phi_new = b\n            # A = h*I + (dt*eps^2/h)*KM*K + s*dt*KM\n            # b = h*phi - dt*KM*(w_prime - s*phi)\n            \n            A = (h * identity(N, format='csc') +\n                 (dt * eps**2 / h) * (KM @ K) +\n                 (s * dt) * KM)\n            \n            rhs_term = w_prime - s * phi\n            b = h * phi - dt * (KM @ rhs_term)\n\n            # Solve for the next time step\n            phi = spsolve(A, b)\n\n        # Post-processing: compute diagnostics at final time\n        phi_final = phi\n\n        # 1. Minimal element mobility\n        m_nodes_final = np.maximum(0, 1.0 - phi_final**2)\n        m_edges_final = (m_nodes_final + np.roll(m_nodes_final, -1)) / 2.0\n        min_mobility = np.min(m_edges_final)\n\n        # 2. Normalized per-interface width ratio\n        # Number of nodes where |phi| < 0.9\n        interface_nodes_count = np.sum(np.abs(phi_final) < 0.9)\n        total_interface_length = interface_nodes_count * h\n        # Two interfaces are present\n        width_per_interface = total_interface_length / 2.0\n        width_ratio = width_per_interface / eps\n\n        results.extend([width_ratio, min_mobility])\n\n    # Format the final output string\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}