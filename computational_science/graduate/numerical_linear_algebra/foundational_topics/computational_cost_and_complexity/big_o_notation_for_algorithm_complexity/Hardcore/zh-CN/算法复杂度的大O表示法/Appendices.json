{
    "hands_on_practices": [
        {
            "introduction": "稠密矩阵-向量乘法是科学计算中的一个基本构件，几乎所有更复杂的矩阵算法都依赖于它。精确计算其运算量是分析更复杂算法的第一步，也是掌握复杂度分析的基础。本练习将引导你从基本定义出发，推导其精确的浮点运算（flop）计数，并使用大O符号的严格定义来证明其属于 $O(n^2)$ 复杂度级别 。",
            "id": "3534517",
            "problem": "考虑基础线性代数子程序（BLAS）意义下的稠密矩阵向量乘法，具体是指运算 $y \\leftarrow A x$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $x, y \\in \\mathbb{R}^{n}$。在数值线性代数中使用的标准浮点运算（flop）成本模型下进行计算：每次标量浮点加法计为 $1$ flop，每次标量浮点乘法计为 $1$ flop；忽略数据移动、分支和循环开销。假设不使用融合乘加运算。\n\n从 flop 计数的​​基本定义和 大O（Landau）表示法的形式化定义出发，为一个直接的、面向行的稠密矩阵向量乘法实现推导出精确的 flop 计数 $F(n)$。该实现通过使用单个累加器将 $A$ 的第 $i$ 行与 $x$ 的点积计算出每个分量 $y_{i}$。然后，使用大O表示法的形式化定义，证明 $F(n)$ 属于集合 $O(n^{2})$。\n\n以关于 $n$ 的单个闭式表达式的形式报告精确的 flop 计数。最终答案中不要提供不等式、方程式或渐近表示法。无需四舍五入。",
            "solution": "该问题经验证是自洽、一致且科学合理的。它是数值线性代数导论和计算复杂度分析中的一个标准问题。\n\n任务是确定稠密矩阵向量乘法 $y \\leftarrow A x$（其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $x, y \\in \\mathbb{R}^{n}$）的精确浮点运算（flop）数量，然后形式化地证明该数量属于 $O(n^2)$。\n\n首先，我们将推导精确的 flop 计数，记为 $F(n)$。该运算是针对向量 $y$ 的每个元素 $y_i$ 按分量定义的，其中 $i$ 的范围从 $1$ 到 $n$。第 $i$ 个分量的公式为：\n$$\ny_i = \\sum_{j=1}^{n} A_{ij} x_j\n$$\n这可以展开为：\n$$\ny_i = A_{i1}x_1 + A_{i2}x_2 + \\dots + A_{in}x_n\n$$\n我们基于指定的 flop 模型分析计算单个分量 $y_i$ 的成本，其中一次标量加法和一次标量乘法各计为 $1$ flop。\n\n对于单个 $y_i$，其计算涉及以下运算：\n$1.$ 一系列 $n$ 次标量乘法：$A_{i1}x_1, A_{i2}x_2, \\dots, A_{in}x_n$。这贡献了 $n$ 次乘法 flop。\n$2.$ 对乘法产生的 $n$ 个乘积求和。将 $n$ 个项相加需要 $n-1$ 次标量加法。例如，$(A_{i1}x_1 + A_{i2}x_2)$ 是一次加法，将 $A_{i3}x_3$ 加到这个和上是第二次加法，依此类推，直到加上第 $n$ 个项，这构成了第 $(n-1)$ 次加法。使用单个累加器进行点积计算对应于这种顺序求和。这贡献了 $n-1$ 次加法 flop。\n\n计算单个分量 $y_i$ 的 flop 总数是乘法 flop 和加法 flop 的总和：\n$$\n\\text{每个分量的 flop 数} = n + (n-1) = 2n-1\n$$\n由于向量 $y$ 有 $n$ 个分量（$y_1, y_2, \\dots, y_n$），并且每个分量的计算是独立的且成本相同，因此整个矩阵向量乘法的总 flop 计数 $F(n)$ 是分量数乘以每个分量的 flop 数：\n$$\nF(n) = n \\times (2n-1)\n$$\n展开此表达式可得到精确 flop 计数的最终闭式表达式：\n$$\nF(n) = 2n^2 - n\n$$\n接下来，我们必须使用大O表示法的形式化定义来证明 $F(n)$ 属于集合 $O(n^2)$。一个函数 $f(n)$ 属于 $O(g(n))$，如果存在一个正常数 $C$ 和一个自然数 $n_0$，使得对于所有 $n \\geq n_0$，不等式 $|f(n)| \\leq C |g(n)|$ 成立。\n\n在本例中，我们的函数是 $f(n) = F(n) = 2n^2 - n$，我们要证明它属于 $O(n^2)$，所以 $g(n) = n^2$。\n我们需要找到常数 $C  0$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有 $n \\geq n_0$：\n$$\n|2n^2 - n| \\leq C |n^2|\n$$\n由于 $n$ 代表矩阵的维度，$n$ 必须是一个正整数，所以 $n \\geq 1$。\n对于 $n \\geq 1$，项 $2n^2 - n = n(2n - 1)$ 是非负的，所以 $|2n^2 - n| = 2n^2 - n$。同样，对于 $n \\geq 1$，有 $|n^2| = n^2$。\n不等式变为：\n$$\n2n^2 - n \\leq C n^2\n$$\n为了找到一个合适的 $C$ 值，我们可以对不等式进行变换。由于当 $n \\geq 1$ 时 $n^2  0$，我们可以将两边同时除以 $n^2$：\n$$\n2 - \\frac{1}{n} \\leq C\n$$\n我们需要找到一个常数 $C$，使得从某个 $n_0$ 开始的所有 $n$ 都满足这个不等式。我们选择 $n_0 = 1$。对于所有 $n \\geq 1$，我们知道 $0  \\frac{1}{n} \\leq 1$。\n这意味着 $2 - \\frac{1}{n}  2$。\n因此，我们可以选择任何满足 $C \\geq 2$ 的常数。一个简单且有效的选择是 $C = 2$。\n\n我们来验证我们的选择。我们选择 $C = 2$ 和 $n_0 = 1$。我们必须证明对于所有 $n \\geq 1$，不等式 $2n^2 - n \\leq 2n^2$ 成立。\n两边都减去 $2n^2$ 得到：\n$$\n-n \\leq 0\n$$\n这个不等式对所有正整数 $n$ 都成立，因此对所有 $n \\geq 1$ 也必然成立。\n由于我们找到了满足定义的常数 $C = 2$ 和整数 $n_0 = 1$，我们已经形式化地证明了 $F(n) = 2n^2 - n$ 属于 $O(n^2)$。\n\n题目要求的最终答案是关于 $n$ 的单个闭式表达式形式的精确 flop 计数。这就是我们推导出的函数 $F(n)$。",
            "answer": "$$\n\\boxed{2n^{2} - n}\n$$"
        },
        {
            "introduction": "Cholesky 分解是数值线性代数中求解对称正定线性系统的基石算法，因其高效和数值稳定性而备受青睐。与简单的矩阵-向量乘法相比，其复杂度分析更为复杂，需要仔细处理嵌套循环中的运算求和。本练习提供了一个绝佳的机会，将浮点运算计数技巧应用于一个更具实质性的多阶段算法，并推导出其 $O(n^3)$ 复杂度 。",
            "id": "3534512",
            "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稠密对称正定（SPD）矩阵。考虑一种非分块左向 Cholesky 分解算法，该算法通过以下面向列的过程计算一个对角线元素为正的下三角矩阵 $L$，使得 $A = L L^{\\top}$：\n- 对于 $k = 1, \\dots, n$：\n  - 计算对角线元素\n    $$L_{k k} = \\sqrt{A_{k k} - \\sum_{s=1}^{k-1} L_{k s}^{2}}.$$\n  - 对于每个 $i = k+1, \\dots, n$，计算\n    $$L_{i k} = \\frac{A_{i k} - \\sum_{s=1}^{k-1} L_{i s} L_{k s}}{L_{k k}}.$$\n采用一个标量运算成本模型，其中以下每种标量算术运算的成本均为单位成本：加法、减法、乘法、除法和平方根。设 $T(n)$ 表示该算法在处理一个 $n \\times n$ 输入时执行的此类标量运算的总数。\n\n从第一性原理出发——即 Cholesky 分解的定义、上述算法步骤以及大O表示法 $O(\\cdot)$ 的形式化渐近定义——推导 $T(n)$ 的一个闭式表达式，并用它来确定该算法的渐近复杂度类别。您的推导必须明确说明每次内部计算中标量运算的数量，并在所有循环中精确地对它们求和。\n\n将您的最终答案表示为关于 $n$ 的单个简化解析表达式 $T(n)$（无单位）。最终答案中不要提供不等式或方程。",
            "solution": "问题要求我们推导对一个 $n \\times n$ 的稠密对称正定（SPD）矩阵 $A$ 进行非分块左向 Cholesky 分解时所需标量算术运算的确切数量，记为 $T(n)$。我们还被要求确定该算法的渐近复杂度。允许的标量运算，每种成本均为单位成本，包括加法、减法、乘法、除法和平方根。\n\n该算法通过顺序计算下三角矩阵 $L$ 的各列来进行。总成本 $T(n)$ 是外层循环每一步成本的总和，该循环从 $k=1$ 迭代到 $n$。设 $C_k$ 为该循环第 $k$ 次迭代期间执行的运算成本。那么，$T(n) = \\sum_{k=1}^{n} C_k$。\n\n在第 $k$ 次迭代中，执行两个主要计算：\n1. 对角线元素 $L_{kk}$ 的计算。\n2. 第 $k$ 列中非对角线元素 $L_{ik}$ 的计算，其中 $i = k+1, \\dots, n$。\n\n让我们分析在一次通用迭代 $k$ 中这些计算的成本。\n\n**计算 $L_{kk}$ 的成本**\n公式为 $L_{k k} = \\sqrt{A_{k k} - \\sum_{s=1}^{k-1} L_{k s}^{2}}$。\n当 $k=1$ 时，求和 $\\sum_{s=1}^{0}$ 为空，其值为 $0$。表达式简化为 $L_{11} = \\sqrt{A_{11}}$。这需要 $1$ 次平方根运算。\n当 $k  1$ 时，计算涉及以下几个步骤：\n- 求和 $\\sum_{s=1}^{k-1} L_{k s}^{2}$ 需要计算 $k-1$ 个平方（$L_{ks}^2$），这需要 $k-1$ 次乘法。\n- 对这 $k-1$ 项求和，需要 $k-2$ 次加法。\n- 然后，有 $1$ 次减法（$A_{kk} - \\dots$）。\n- 最后，有 $1$ 次平方根运算。\n当 $k  1$ 时，计算 $L_{kk}$ 的总成本为 $(k-1) + (k-2) + 1 + 1 = 2k-1$ 次运算。\n我们将 $L_{kk}$ 的成本表示为 $C_{kk}$。\n$C_{kk} = \\begin{cases} 1  k=1 \\\\ 2k-1  k  1 \\end{cases}$。\n\n**计算 $L_{ik}$（其中 $i=k+1, \\dots, n$）的成本**\n对于一个固定的 $k$，一个循环对 $i$ 从 $k+1$ 到 $n$ 运行。这个循环有 $n-k$ 次迭代。在这个循环内部，元素 $L_{ik}$ 使用以下公式计算：\n$L_{i k} = \\frac{A_{i k} - \\sum_{s=1}^{k-1} L_{i s} L_{k s}}{L_{k k}}$。\n设 $c_{ik}$ 为计算单个元素 $L_{ik}$ 的成本。\n当 $k=1$ 时，求和为空。公式变为 $L_{i1} = \\frac{A_{i1}}{L_{11}}$。这需要 $1$ 次除法。\n当 $k  1$ 时，计算涉及：\n- 求和 $\\sum_{s=1}^{k-1} L_{i s} L_{k s}$ 需要 $k-1$ 次乘法和 $k-2$ 次加法。\n- 然后，有 $1$ 次减法（$A_{ik} - \\dots$）。\n- 最后，有 $1$ 次除以 $L_{kk}$ 的除法。\n当 $k  1$ 时，计算一个元素 $L_{ik}$ 的总成本为 $(k-1) + (k-2) + 1 + 1 = 2k-1$ 次运算。\n所以，成本 $c_{ik}$ 是：\n$c_{ik} = \\begin{cases} 1  k=1 \\\\ 2k-1  k  1 \\end{cases}$。\n\n在固定的步骤 $k$，对 $i$ 的内层循环的总成本是 $(n-k) \\times c_{ik}$。\n\n**第 $k$ 次迭代的总成本 $C_k$**\n我们现在可以求出外层循环每次迭代 $k$ 的总成本 $C_k$。\n当 $k=1$ 时：\n$C_1 = C_{11} + \\sum_{i=2}^{n} c_{i1} = 1 + (n-1) \\times 1 = n$。\n当 $k  1$ 时：\n$C_k = C_{kk} + \\sum_{i=k+1}^{n} c_{ik} = (2k-1) + (n-k) \\times (2k-1)$。\n提出公因式 $(2k-1)$，我们得到 $C_k = (1 + n-k)(2k-1) = (n-k+1)(2k-1)$。\n\n我们可以检查这个对于 $k1$ 的通用公式是否也对 $k=1$ 成立：\n当 $k=1$ 时，该公式给出 $C_1 = (n-1+1)(2(1)-1) = n \\times 1 = n$。\n该公式是一致的。因此，我们可以将任意迭代 $k \\in \\{1, \\dots, n\\}$ 的成本表示为 $C_k = (n-k+1)(2k-1)$。\n\n**总运算次数 $T(n)$**\n总运算次数是所有迭代成本的总和：\n$$T(n) = \\sum_{k=1}^{n} C_k = \\sum_{k=1}^{n} (n-k+1)(2k-1).$$\n为了简化这个求和，我们进行一次索引变换。令 $j = n-k+1$。当 $k$ 从 $1$ 跑到 $n$ 时，新索引 $j$ 从 $n$ 递减到 $1$。对 $k$ 的变换是 $k = n-j+1$。\n将此代入求和中：\n$$T(n) = \\sum_{j=1}^{n} j \\cdot \\left( 2(n-j+1) - 1 \\right).$$\n求和内部的项是 $j(2n - 2j + 2 - 1) = j(2n - 2j + 1) = 2nj - 2j^2 + j$。\n求和变为：\n$$T(n) = \\sum_{j=1}^{n} (2nj - 2j^2 + j) = \\sum_{j=1}^{n} (-2j^2 + (2n+1)j).$$\n利用求和的线性性质：\n$$T(n) = -2 \\sum_{j=1}^{n} j^2 + (2n+1) \\sum_{j=1}^{n} j.$$\n我们使用前 $n$ 个整数的和以及前 $n$ 个整数的平方和的标准公式：\n$\\sum_{j=1}^{n} j = \\frac{n(n+1)}{2}$\n$\\sum_{j=1}^{n} j^2 = \\frac{n(n+1)(2n+1)}{6}$\n将这些公式代入 $T(n)$ 的表达式中：\n$$T(n) = -2 \\left( \\frac{n(n+1)(2n+1)}{6} \\right) + (2n+1) \\left( \\frac{n(n+1)}{2} \\right).$$\n$$T(n) = -\\frac{n(n+1)(2n+1)}{3} + \\frac{n(n+1)(2n+1)}{2}.$$\n提出公因式 $n(n+1)(2n+1)$：\n$$T(n) = n(n+1)(2n+1) \\left( \\frac{1}{2} - \\frac{1}{3} \\right) = n(n+1)(2n+1) \\left( \\frac{3-2}{6} \\right) = \\frac{n(n+1)(2n+1)}{6}.$$\n这就是标量运算总数的闭式表达式。我们可以展开它以查看首项：\n$$T(n) = \\frac{1}{6} (n(2n^2 + 3n + 1)) = \\frac{1}{6} (2n^3 + 3n^2 + n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n.$$\n\n**渐近复杂度**\n$T(n)$ 的多项式表达式中的最高阶项决定了渐近复杂度。主导项是 $\\frac{1}{3}n^3$。\n根据大O表示法的形式化定义，如果一个函数 $f(n)$ 是 $O(g(n))$，那么必须存在一个常数 $C0$ 和一个整数 $n_0$，使得对于所有 $n \\ge n_0$，都有 $|f(n)| \\le C|g(n)|$。\n在我们的情况下，$T(n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n$。对于 $n \\ge 1$：\n$$T(n) = \\frac{1}{3}n^3 + \\frac{1}{2}n^2 + \\frac{1}{6}n \\le \\frac{1}{3}n^3 + \\frac{1}{2}n^3 + \\frac{1}{6}n^3 = \\left(\\frac{1}{3} + \\frac{1}{2} + \\frac{1}{6}\\right)n^3 = \\frac{2+3+1}{6}n^3 = n^3.$$\n因此，我们可以选择 $C=1$ 和 $n_0=1$，这满足了定义。该算法的渐近复杂度是 $O(n^3)$。\n问题要求的是 $T(n)$ 的简化解析表达式。",
            "answer": "$$\\boxed{\\frac{n(n+1)(2n+1)}{6}}$$"
        },
        {
            "introduction": "Strassen 算法是一个经典的例子，它颠覆了人们对矩阵乘法复杂度“极限”为 $O(n^3)$ 的传统认知。通过巧妙的分治策略，它实现了渐进意义上更快的计算，这在算法设计史上具有里程碑意义。本练习将引导你使用递推关系这一强大工具来分析其复杂度，并最终得出著名的 $O(n^{\\log_2 7})$ 结果，从而深刻理解递归算法设计的力量 。",
            "id": "3534539",
            "problem": "考虑使用 Strassen 的分块递归方法，对实数域上的两个维度为 $n \\times n$ 的稠密方阵进行乘法运算。假设使用随机存取机（RAM）模型，其中每次标量加法和每次标量乘法的成本都为单位成本。在递归的每一层，Strassen 的构造将每个输入矩阵划分为 $2 \\times 2$ 个维度为 $(n/2) \\times (n/2)$ 的块，对 $(n/2) \\times (n/2)$ 的子矩阵精确执行 $7$ 次递归乘法，并使用固定有限次数的 $(n/2) \\times (n/2)$ 矩阵加法和减法来组合这些结果。设 $T(n)$ 表示通过 Strassen 算法乘以两个 $n \\times n$ 矩阵所需的标量算术运算（加法和乘法）的总数，并假设 $n$ 是 $2$ 的幂，因此不会出现取整问题。利用以下事实：两个 $(m \\times m)$ 矩阵相加或相减的成本为 $\\Theta(m^{2})$ 次标量运算，并且在每个递归级别执行的块加法和减法的次数是一个与 $n$ 无关的固定常数。\n\n从这些原则出发，推导并分析 $T(n)$ 满足的分治递归关系，明确描绘其导出的递归树，并确定当 $n \\to \\infty$ 时 $T(n)$ 的主导缩放行为。请以封闭形式的解析表达式给出 Strassen 算法关于 $n$ 的领先阶渐近算术复杂度的最终答案，忽略常数因子和低阶项。你的最终答案必须是关于 $n$ 的单一表达式（在最终方框内不得包含不等式或大O符号）。",
            "solution": "问题要求解 Strassen 矩阵乘法算法对两个维度为 $n \\times n$ 的稠密方阵的渐近复杂度。我们已知 $n$ 是 $2$ 的幂，即对于某个整数 $k \\ge 0$，有 $n = 2^k$。该分析基于一个分治递归关系。\n\n设 $T(n)$ 为使用此算法乘以两个 $n \\times n$ 矩阵所需的标量算术运算（加法、减法和乘法）的总数。该方法涉及将每个 $n \\times n$ 矩阵划分为四个 $(n/2) \\times (n/2)$ 的子矩阵。然后递归地计算 $7$ 个大小为 $(n/2) \\times (n/2)$ 的矩阵乘积。这些递归调用的成本是 $7 \\cdot T(n/2)$。\n\n在递归乘法之后，使用固定次数的矩阵加法和减法来组合结果。设这个常数为 $c_{ops}$。问题陈述该数是有限的且与 $n$ 无关。进行加减运算的矩阵大小为 $(n/2) \\times (n/2)$。两个 $m \\times m$ 矩阵相加或相减需要 $m^2$ 次标量运算。因此，一次 $(n/2) \\times (n/2)$ 矩阵的加法/减法成本为 $(n/2)^2 = n^2/4$ 次标量运算。因此，在递归的某一层，这个组合步骤的总成本是 $c_{ops} \\cdot (n^2/4)$。这个成本与 $n^2$ 成正比，所以我们可以将其写为 $C n^2$，其中 $C$ 是某个正常数。\n\n结合递归调用和组合步骤的成本，我们得到 $T(n)$ 的递归关系式：\n$$T(n) = 7 T(n/2) + C n^2$$\n递归的基准情形是两个 $1 \\times 1$ 矩阵的乘法，这只包含一次标量乘法。因此，$T(1) = 1$。\n\n为了确定 $T(n)$ 的主导缩放行为，我们可以分析此递归关系导出的递归树。\n树的深度为 $k = \\log_2(n)$，因为在每一层 $j$（从根部的 $j=0$ 到叶子节点的 $j=k$），问题规模从 $n/2^j$ 减小到 $n/2^{j+1}$。当规模为 $1$ 时，即 $n/2^k = 1$，递归停止。\n\n让我们对树的每一层的成本求和：\n第 $0$ 层（根节点）：完成的工作是初始规模为 $n$ 的问题的组合成本，即 $C n^2$。\n第 $1$ 层：有 $7$ 个子问题，每个规模为 $n/2$。这一层的总工作量是 $7 \\times C(n/2)^2 = 7 C (n^2/4) = C n^2 (7/4)^1$。\n第 $2$ 层：有 $7^2$ 个子问题，每个规模为 $n/4$。这一层的总工作量是 $7^2 \\times C(n/4)^2 = 49 C (n^2/16) = C n^2 (7/4)^2$。\n第 $j$ 层：一般地，在第 $j$ 层，有 $7^j$ 个子问题，每个规模为 $n/2^j$。这一层的总组合工作量是 $7^j \\times C(n/2^j)^2 = 7^j C (n^2/4^j) = C n^2 (7/4)^j$。\n\n递归树所有内部节点的总工作量（即所有加法和减法的总成本）是第 $j=0$ 到 $j=k-1$ 层工作量的总和：\n$$W_{internal} = \\sum_{j=0}^{k-1} C n^2 \\left(\\frac{7}{4}\\right)^j$$\n这是一个公比为 $r = 7/4$ 的等比数列。其和为：\n$$W_{internal} = C n^2 \\frac{(7/4)^k - 1}{(7/4) - 1} = C n^2 \\frac{(7/4)^{\\log_2(n)} - 1}{3/4} = \\frac{4C}{3} n^2 \\left(\\left(\\frac{7}{4}\\right)^{\\log_2(n)} - 1\\right)$$\n我们可以简化项 $(7/4)^{\\log_2(n)}$：\n$$\\left(\\frac{7}{4}\\right)^{\\log_2(n)} = \\frac{7^{\\log_2(n)}}{4^{\\log_2(n)}} = \\frac{n^{\\log_2(7)}}{(2^2)^{\\log_2(n)}} = \\frac{n^{\\log_2(7)}}{2^{2\\log_2(n)}} = \\frac{n^{\\log_2(7)}}{2^{\\log_2(n^2)}} = \\frac{n^{\\log_2(7)}}{n^2}$$\n将此代回 $W_{internal}$ 的表达式中：\n$$W_{internal} = \\frac{4C}{3} n^2 \\left(\\frac{n^{\\log_2(7)}}{n^2} - 1\\right) = \\frac{4C}{3} n^{\\log_2(7)} - \\frac{4C}{3} n^2$$\n\n总成本 $T(n)$ 是内部工作量和叶子节点处完成的工作量之和。\n叶子节点对应于递归的基准情形。在深度 $k = \\log_2(n)$ 处的叶子节点数量是 $7^k = 7^{\\log_2(n)} = n^{\\log_2(7)}$。每个叶子节点代表一个 $1 \\times 1$ 矩阵乘法，其成本为 $T(1)=1$。\n叶子节点的总工作量是：\n$$W_{leaves} = 7^k \\cdot T(1) = n^{\\log_2(7)} \\cdot 1 = n^{\\log_2(7)}$$\n\n总成本是 $T(n) = W_{internal} + W_{leaves}$：\n$$T(n) = \\left(\\frac{4C}{3} n^{\\log_2(7)} - \\frac{4C}{3} n^2\\right) + n^{\\log_2(7)} = \\left(1 + \\frac{4C}{3}\\right) n^{\\log_2(7)} - \\frac{4C}{3} n^2$$\n为了确定当 $n \\to \\infty$ 时的主导缩放行为，我们比较 $n$ 的指数。指数是 $\\log_2(7)$ 和 $2$。\n我们知道 $2^2 = 4$ 且 $2^3 = 8$。由于 $4  7  8$，我们有 $\\log_2(4)  \\log_2(7)  \\log_2(8)$，这意味着 $2  \\log_2(7)  3$。数值上，$\\log_2(7) \\approx 2.807$。\n因为 $\\log_2(7)  2$，所以项 $n^{\\log_2(7)}$ 比 $n^2$ 增长得更快。因此，项 $\\left(1 + \\frac{4C}{3}\\right) n^{\\log_2(7)}$ 是 $T(n)$ 表达式中的主导项。\n\n领先阶渐近算术复杂度是表达式中随 $n$ 增长最快的部分。忽略常数因子 $\\left(1 + \\frac{4C}{3}\\right)$ 和低阶项 $-\\frac{4C}{3} n^2$，复杂度由 $n^{\\log_2(7)}$ 的缩放行为决定。\n\n这个结果也可以使用主定理来证实，该定理适用于形式为 $T(n) = a T(n/b) + f(n)$ 的递归式。在我们的例子中，$a=7$，$b=2$，且 $f(n) = C n^2$。我们将 $f(n)$ 与 $n^{\\log_b(a)} = n^{\\log_2(7)}$ 进行比较。由于 $f(n) = C n^2$ 且 $2  \\log_2(7)$，我们有 $f(n) = O(n^{\\log_2(7) - \\epsilon})$，其中某个 $\\epsilon  0$（例如，$\\epsilon = \\log_2(7) - 2$）。这对应于主定理的第1种情况，它给出的解是 $T(n) = \\Theta(n^{\\log_b(a)}) = \\Theta(n^{\\log_2(7)})$。\n\n问题要求的是领先阶渐近复杂度的封闭形式解析表达式，即函数形式 $n^{\\log_2(7)}$。",
            "answer": "$$\\boxed{n^{\\log_{2}(7)}}$$"
        }
    ]
}