{
    "hands_on_practices": [
        {
            "introduction": "在我们分析计算误差之前，首先需要一种方法来量化不同浮点格式的精度。本练习将浮点格式定义中的比特数与其精度的两个最重要指标联系起来：尾数的有效位数和单位舍入误差 $u$。理解这种关系是建立对单精度、双精度乃至四精度算术预期准确性直觉的第一步。",
            "id": "3589114",
            "problem": "请考虑电气与电子工程师协会（IEEE）754 浮点数算术标准及其二进制交换格式：binary16（半精度）、binary32（单精度）、binary64（双精度）和 binary128（四倍精度）。在这些格式中，每个规格化浮点数都可以写成 $x = m \\times 2^{E}$，其中 $m \\in [1, 2)$ 是尾数，其形式为一个隐含的前导 $1$ 后跟固定数量的小数位，而 $E$ 是一个整数指数，其值在由该格式的指数场和偏置决定的正常范围内。对于这四种格式，小数位数分别为 $10$ (binary16)、$23$ (binary32)、$52$ (binary64) 和 $112$ (binary128)。\n\n在“向最近舍入，偶数优先”规则下，对一个规格化值进行单步舍入的舍入误差，其界限为该数量级上相邻可表示数之间间距的一半。在数值线性代数中用于规格化算术的标准舍入模型中，对于单个舍入步骤，我们写作 $\\mathrm{fl}(x) = x(1 + \\delta)$，其中 $|\\delta| \\leq u$，$u$ 是单位舍入误差。正确的二进制数字位数定义为尾数中在舍入后保证与精确值匹配的比特数，而单位舍入误差 $u$ 量化了在“向最近舍入，偶数优先”规则下的最大相对舍入误差界限。\n\n从上述格式定义和“向最近舍入，偶数优先”规则出发，为每种格式推导出正确的二进制数字位数（尾数精度）以及规格化数对应的精确单位舍入误差 $u$。请将您的最终答案以单行矩阵的形式呈现：\n$$\n\\left(p_{16},\\, u_{16},\\, p_{32},\\, u_{32},\\, p_{64},\\, u_{64},\\, p_{128},\\, u_{128}\\right),\n$$\n其中 $p_{f}$ 是正确的二进制数字位数（尾数位数，包括隐含的前导 $1$），$u_{f}$ 是所指示格式 $f \\in \\{16,32,64,128\\}$ 的单位舍入误差。无需舍入；请提供精确值。",
            "solution": "该问题要求为 IEEE 754 标准指定的四种二进制交换格式（binary16、binary32、binary64 和 binary128）推导尾数精度 $p$ 和单位舍入误差 $u$。求解过程首先根据所提供的信息定义这些量，然后为每种格式计算它们的值。\n\n一个规格化浮点数 $x$ 表示为 $x = s \\times m \\times 2^{E}$，其中 $s$ 是符号（$\\pm 1$），$m$ 是尾数， $E$ 是指数。对于所讨论的格式，尾数 $m$ 被规格化到区间 $[1, 2)$ 内，其二进制形式为 $m = (1.f_1f_2...f_n)_2$，其中前导 $1$ 是隐含的，$f_1f_2...f_n$ 是存储在内存中的 $n$ 位小数。\n\n问题将“正确的二进制数字位数”定义为尾数精度，记作 $p$。这是尾数中的总比特数，包括隐含的前导 $1$。如果一个格式有 $n$ 个小数位，则尾数精度由下式给出：\n$$\np = n + 1\n$$\n这个值 $p$ 决定了对于一个给定的数可以表示的有效位数。\n\n单位舍入误差，记作 $u$，被定义为在向最近舍入规则下单个舍入操作的最大相对误差界限。标准舍入模型给出为 $\\mathrm{fl}(x) = x(1 + \\delta)$，其中 $|\\delta| \\leq u$。\n\n假设一个实数 $x$ 的表示需要超过 $p$ 个尾数位。舍入过程 $\\mathrm{fl}(x)$ 将 $x$ 映射到最接近的可表示浮点数。设一个可表示数为 $y = m \\times 2^E$，其中 $m$ 是一个 $p$ 位尾数。下一个更大的可表示数是 $y^{+} = (m + 2^{-(p-1)}) \\times 2^E$。这两个数之间的距离，称为相对于指数 $E$ 的“末位单位”(ulp)，是 $\\mathrm{ulp}(y) = 2^{-(p-1)} \\times 2^E$。\n\n在向最近舍入规则下，绝对误差的界限是此距离的一半：\n$$\n|\\mathrm{fl}(x) - x| \\leq \\frac{1}{2} \\mathrm{ulp}(\\mathrm{fl}(x)) = \\frac{1}{2} \\times 2^{-(p-1)} \\times 2^E = 2^{-p} \\times 2^E\n$$\n相对误差由 $\\frac{|\\mathrm{fl}(x) - x|}{|x|}$ 给出。为了找到上界 $u$，我们必须找到这个量在所有可能的非零实数 $x$ 上的上确界。\n$$\nu = \\sup_{x} \\frac{|\\mathrm{fl}(x) - x|}{|x|}\n$$\n对于恰好位于两个可表示浮点数中间的数，绝对舍入误差达到最大值。让我们考虑这样一个数 $x = (m + 2^{-p}) \\times 2^E$，其中 $m$ 是较小的可表示数的尾数。绝对误差为 $|\\mathrm{fl}(x) - x| \\approx 2^{-p} \\times 2^E$。相对误差则近似为：\n$$\n\\frac{2^{-p} \\times 2^E}{|x|} = \\frac{2^{-p} \\times 2^E}{|(m + 2^{-p}) \\times 2^E|} = \\frac{2^{-p}}{m + 2^{-p}}\n$$\n当分母最小时，此表达式的值最大。对于一个规格化数，最小的尾数 $m$ 是 $1$。因此，最大相对误差发生在接近 2 的幂的数上，其界限值接近于 $\\frac{2^{-p}}{1} = 2^{-p}$。\n在数值分析中，对于向最近舍入算术的单位舍入误差的标准定义正是这个界限：\n$$\nu = 2^{-p}\n$$\n这个值确保关系式 $\\mathrm{fl}(x) = x(1+\\delta)$ 在 $|\\delta| \\leq u$ 的条件下成立。\n\n现在我们可以为每种指定格式计算 $p$ 和 $u$。\n\n1.  **binary16 (半精度):**\n    给出的小数位数为 $n_{16} = 10$。\n    尾数精度为 $p_{16} = n_{16} + 1 = 10 + 1 = 11$。\n    单位舍入误差为 $u_{16} = 2^{-p_{16}} = 2^{-11}$。\n\n2.  **binary32 (单精度):**\n    给出的小数位数为 $n_{32} = 23$。\n    尾数精度为 $p_{32} = n_{32} + 1 = 23 + 1 = 24$。\n    单位舍入误差为 $u_{32} = 2^{-p_{32}} = 2^{-24}$。\n\n3.  **binary64 (双精度):**\n    给出的小数位数为 $n_{64} = 52$。\n    尾数精度为 $p_{64} = n_{64} + 1 = 52 + 1 = 53$。\n    单位舍入误差为 $u_{64} = 2^{-p_{64}} = 2^{-53}$。\n\n4.  **binary128 (四倍精度):**\n    给出的小数位数为 $n_{128} = 112$。\n    尾数精度为 $p_{128} = n_{128} + 1 = 112 + 1 = 113$。\n    单位舍入误差为 $u_{128} = 2^{-p_{128}} = 2^{-113}$。\n\n将这些结果组合成所需的行矩阵 $(p_{16}, u_{16}, p_{32}, u_{32}, p_{64}, u_{64}, p_{128}, u_{128})$，即可得到最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11  2^{-11}  24  2^{-24}  53  2^{-53}  113  2^{-113}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当计算结果恰好落在两个可表示的浮点数之间时，IEEE 754 标准定义的多种舍入模式就变得至关重要。本思想实验提供了一个具体的例子，展示了不同的定向舍入模式（向 $+\\infty$ 和 $-\\infty$ 舍入）如何对同一个简单的加法产生不同的结果。通过完成这个计算 ，你将对“末位单位”（ulp）的含义以及舍入选择如何决定最终存储值有一个切实的感受。",
            "id": "3589160",
            "problem": "考虑一种遵循电气和电子工程师协会 (IEEE) 754 binary64 格式（双精度）的算术。该格式将一个规格化浮点数 $x$ 表示为 $x = m \\cdot 2^{e}$，其中 $1 \\leq m  2$，$e \\in \\mathbb{Z}$，并有一个 53 位的有效数（包括隐含的前导 1）。对于一个规格化数 $x$，其最后一个位置的单位 $\\mathrm{ulp}(x)$ 定义为在 $x$ 的数量级上相邻可表示浮点数之间的间距，当 $x$ 的无偏指数为 $e$ 时，其值等于 $2^{e-52}$。朝向 $+\\infty$ 的定向舍入返回满足 $r \\geq s$ 的最小可表示浮点数 $r$，而朝向 $-\\infty$ 的定向舍入返回满足 $r \\leq s$ 的最大可表示浮点数 $r$，其中 $s$ 是精确的实数结果。\n\n你需要构造并分析一个与数值线性代数相关的具体 binary64 示例，其中 $a$ 是一个大数值，而 $b$ 是一个远小于它的修正量。设 $a = 2^{100}$ 和 $b = 3 \\cdot 2^{46}$，并考虑 $a + b$ 的浮点求和。该求和先进行精确的实数加法，然后以两种定向模式（朝向 $+\\infty$ 和朝向 $-\\infty$）之一进行舍入。仅使用上面给出的 IEEE 754 核心定义，确定两个舍入后的和 $r_{+} = \\operatorname{round}_{+\\infty}(a+b)$ 和 $r_{-} = \\operatorname{round}_{-\\infty}(a+b)$，然后将其差的绝对值 $|r_{+} - r_{-}|$ 量化为 $\\mathrm{ulp}(a+b)$ 的倍数。\n\n将你的最终答案表示为一个实数，该实数等于 $|r_{+} - r_{-}| = k \\cdot \\mathrm{ulp}(a+b)$ 中的倍数 $k$。无需舍入。",
            "solution": "该问题要求我们分析两个数 $a$ 和 $b$ 在两种不同定向舍入模式下的浮点求和。\n\n首先，我们将给定的数表示为标准浮点形式。\n数 $a = 2^{100}$ 已经是规格化形式 $m \\cdot 2^{e}$，其有效数 $m_a = 1$，指数 $e_a = 100$。由于其小数部分为零，因此它可以在 binary64 格式中精确表示。\n\n数 $b = 3 \\cdot 2^{46}$ 可以写成 $b = (2+1) \\cdot 2^{46} = (1.5) \\cdot 2 \\cdot 2^{46} = 1.5 \\cdot 2^{47}$。它也是一个规格化的、可精确表示的数，其有效数 $m_b = 1.5 = 1.1_2$，指数 $e_b = 47$。\n\n接下来，我们计算精确的实数和 $s = a+b$。\n$s = 2^{100} + 3 \\cdot 2^{46}$\n为了在浮点系统中分析这个和，我们提出较大的 2 的幂，$2^{100}$，以确定结果的指数和有效数。\n$s = 2^{100} \\cdot \\left(1 + \\frac{3 \\cdot 2^{46}}{2^{100}}\\right) = 2^{100} \\cdot (1 + 3 \\cdot 2^{-54})$\n精确和 $s$ 的指数为 $e_s = 100$，有效数为 $m_s = 1 + 3 \\cdot 2^{-54}$。\n\n现在我们检查有效数 $m_s$ 是否可以在 binary64 格式中表示。一个可表示的有效数形式为 $1.f_1 f_2 \\dots f_{52}$，其中 $f_i$ 是 52 个小数位。这样一个有效数的值为 $1 + \\sum_{i=1}^{52} f_i 2^{-i}$。\n我们用二进制表示 $m_s$ 的小数部分。\n$3 \\cdot 2^{-54} = (2+1) \\cdot 2^{-54} = 2 \\cdot 2^{-54} + 1 \\cdot 2^{-54} = 2^{-53} + 2^{-54}$。\n所以，有效数是 $m_s = 1 + 2^{-53} + 2^{-54}$。\n用二进制表示为 $m_s = 1.\\underbrace{00\\dots0}_{52 \\text{ 个零}}11_2$。\n有效数 $m_s$ 在二进制小数点后的第 53 位和第 54 位上有非零位。由于 binary64 格式只存储 52 个小数位，因此 $m_s$ 不能被精确表示。和 $s = a+b$ 必须进行舍入。\n\n为了执行定向舍入，我们必须确定包围精确和 $s$ 的两个可表示的浮点数。这些数将与 $s$ 具有相同的指数 $e=100$。\n设 $r_{-}$ 是小于或等于 $s$ 的最大可表示数，而 $r_{+}$ 是大于或等于 $s$ 的最小可表示数。\n$r_{-}$ 的有效数是通过在第 52 个小数位后截断 $m_s$ 的二进制表示得到的。\n$m_{-} = 1.\\underbrace{00\\dots0}_{52 \\text{ 个零}} = 1$。\n因此，$r_{-} = 1 \\cdot 2^{100} = 2^{100}$。\n\n数 $r_{+}$ 是 $r_{-}$ 之后的下一个可表示的浮点数。指数为 $e$ 的连续可表示数之间的间距是 $2^{e-52}$。这个值也是该范围内数的 $\\mathrm{ulp}$ 的定义。对于 $e=100$，这个间距是 $2^{100-52} = 2^{48}$。\n所以，$r_{+} = r_{-} + 2^{100-52} = 2^{100} + 2^{48}$。\n$r_{+}$ 的有效数是 $m_{+} = 1 + 2^{-52}$，即 $1.\\underbrace{00\\dots01}_{52 \\text{ 位}}$。\n\n我们有不等式 $r_{-}  s  r_{+}$。我们来验证一下：\n$r_{-} = 2^{100}$\n$s = 2^{100} + 3 \\cdot 2^{46}$\n$r_{+} = 2^{100} + 2^{48} = 2^{100} + 4 \\cdot 2^{46}$\n确实，$2^{100}  2^{100} + 3 \\cdot 2^{46}  2^{100} + 4 \\cdot 2^{46}$。\n\n现在我们应用指定的舍入模式：\n- 朝向 $-\\infty$ 舍入 (向下取整)：$\\operatorname{round}_{-\\infty}(s)$ 是满足 $r \\leq s$ 的最大可表示数。这个数是 $r_{-}$。\n  $\\operatorname{round}_{-\\infty}(a+b) = r_{-} = 2^{100}$。\n- 朝向 $+\\infty$ 舍入 (向上取整)：$\\operatorname{round}_{+\\infty}(s)$ 是满足 $r \\geq s$ 的最小可表示数。这个数是 $r_{+}$。\n  $\\operatorname{round}_{+\\infty}(a+b) = r_{+} = 2^{100} + 2^{48}$。\n\n下一步是计算这两个舍入值之差的绝对值。\n$|r_{+} - r_{-}| = |(2^{100} + 2^{48}) - 2^{100}| = 2^{48}$。\n\n最后，我们需要将这个差表示为 $\\mathrm{ulp}(a+b)$ 的倍数。\n精确和 $s = a+b$ 是一个指数为 $e=100$ 的规格化数。根据问题的定义，$\\mathrm{ulp}(s)$ 由下式给出：\n$\\mathrm{ulp}(a+b) = 2^{e-52} = 2^{100-52} = 2^{48}$。\n\n我们在寻找常数 $k$，使得 $|r_{+} - r_{-}| = k \\cdot \\mathrm{ulp}(a+b)$。\n代入我们找到的值：\n$2^{48} = k \\cdot 2^{48}$。\n解出 $k$ 得 $k=1$。\n\n两个定向舍入结果之差的绝对值恰好是和的最后一个位置的一个单位。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "现代处理器通常包含专门的指令，如积和熔加（FMA），这些指令由 IEEE 754 标准定义，可以显著提高数值算法的性能和准确性。本练习要求你分析 FMA 对补偿求和（一种用于提高点积和总和准确性的经典技术）的影响 。你将探索 FMA 何时可以替代更复杂的基于软件的补偿方法，并理解其中涉及的微妙之处，例如对非规格化数的支持的重要性。",
            "id": "3589159",
            "problem": "考虑电气和电子工程师协会浮点算术标准 (IEEE 754) 的 binary64 格式，采用“向最近舍入，平局时向偶数舍入”(round-to-nearest ties-to-even) 的舍入模式，支持次正规数 (subnormals)，且所述运算不发生上溢 (overflow)。令单位舍入误差表示为 $u$ (对于 binary64， $u = 2^{-53}$)。融合乘加 (Fused Multiply-Add, FMA) 运算计算 $a \\times b + c$ 的方式是，先计算精确的实数 $a b + c$，然后对结果进行一次舍入，得到目标格式的数。假设 $n \\geq 1$ 且 $x_i, a_i, b_i \\in \\mathbb{R}$ 是有界的，以至于不发生上溢。\n\n你需要分析在数值线性代数中 FMA 对补偿求和 (compensated summation) 的影响。对于一个简单求和 $S = \\sum_{i=1}^{n} x_i$，Kahan 式补偿求和使用一个补偿变量 $c$ 并执行以下更新：\n$$\ny \\leftarrow x_i - c, \\quad t \\leftarrow s + y, \\quad c \\leftarrow (t - s) - y, \\quad s \\leftarrow t,\n$$\n这在代数上保证了 $s + c$ 比单独的 $s$ 更接近精确的累加和。对于点积 $S = \\sum_{i=1}^{n} a_i b_i$，可以在累加步骤中使用 FMA：$s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$。\n\n从 IEEE 754 中关于向最近舍入的定义、FMA 的单次舍入语义以及算术运算的标准浮点误差模型出发，分析下列哪些陈述是正确的或错误的，并论证 FMA 何时可以替代显式补偿以达到相似的精度。选择所有正确的选项。\n\nA. 在纯求和 $S = \\sum_{i=1}^{n} x_i$ 中，如果舍入模式为“向最近舍入，平局时向偶数舍入”，将 $s \\leftarrow s + x_i$ 替换为 $s \\leftarrow \\mathrm{fma}(x_i, 1, s)$ 可以消除对 Kahan 式补偿的需求，并达到与 Kahan 补偿求和相当的前向误差界（在小的常数因子内）。\n\nB. 在点积 $S = \\sum_{i=1}^{n} a_i b_i$ 中，使用 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 将每项的舍入次数从两次减少到一次。在最坏情况的对抗性输入顺序下，其前向误差仍为 $O(n u)$ 阶，而 Kahan 式补偿可以将误差增长降低到 $O(u)$ 阶；因此，对于长的、病态的累加，单独使用 FMA 无法匹敌 Kahan 的最坏情况精度。\n\nC. 对于 $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$ 和 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$，只要不发生上溢且 $e_i$ 不会下溢为零，在实数算术中就有 $p_i + e_i = a_i b_i$ 精确成立。因此，在这些条件下，将 $p_i$ 累加到一个运行和中，并将 $e_i$ 累加到第二个运行和中，可以产生一种源于 FMA 的补偿机制，能够匹敌 Kahan 式补偿在点积中的精度优势。\n\nD. 在定向舍入（例如，向零舍入）下，Kahan 更新 $c \\leftarrow (t - s) - y$ 不再是一个有效的数值恒等式，因此 FMA 是绝对更优的，并且可以在任何舍入模式下替代显式补偿。\n\nE. 如果启用了刷新到零 (flush-to-zero, FTZ) 或非规格化数视为零 (denormals-are-zero, DAZ)，那么在陈述 C 中计算 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$ 可能会对以抵消为主的项错误地产生 $e_i = 0$ 的结果，从而破坏补偿机制；因此，要依赖 FMA 替代显式的 Kahan 式补偿，必须确保完全支持次正规数并避免 $e_i$ 发生下溢。",
            "solution": "该问题要求分析关于在数值求和与点积的背景下使用融合乘加 (FMA) 运算的几个陈述，特别是与 Kahan 式补偿求和进行比较。运算环境是 IEEE 754 binary64 标准，采用“向最近舍入，平局时向偶数舍入”的舍入模式，支持次正规数，且无上溢。单位舍入误差为 $u = 2^{-53}$。\n\n一个标准浮点运算 $\\circ \\in \\{+, -, \\times, \\div\\}$ 被建模为 $\\mathrm{fl}(x \\circ y) = (x \\circ y)(1+\\delta)$，其中 $|\\delta| \\leq u$。\n融合乘加运算被建模为 $\\mathrm{fma}(a, b, c) = \\mathrm{fl}(ab+c) = (ab+c)(1+\\eta)$，其中 $|\\eta| \\leq u$。其关键特性是，先计算精确的乘积 $a \\times b$，再与 $c$ 相加，然后最终结果仅进行一次舍入到目标格式。\n\n用于计算 $S = \\sum_{i=1}^{n} x_i$ 的 Kahan 求和算法维护一个累加和 $s$ 和一个补偿项 $c$。一次迭代如下：\n$y \\leftarrow \\mathrm{fl}(x_i - c)$\n$t \\leftarrow \\mathrm{fl}(s + y)$\n$c \\leftarrow \\mathrm{fl}(\\mathrm{fl}(t - s) - y)$\n$s \\leftarrow t$\n在标准假设下，最终和 $s_n$ 的误差界为 $(2u + O(nu^2))\\sum_{i=1}^{n} |x_i|$。其关键特性是，误差界在 $u$ 的一阶上与 $n$ 无关。相比之下，简单的递归求和 $s_k \\leftarrow \\mathrm{fl}(s_{k-1} + x_k)$ 的误差界随 $n$ 线性增长，约为 $(n-1)u \\sum_{i=1}^{n} |x_i|$。\n\n我们现在来评估每个陈述。\n\n### 选项 A 分析\n该陈述建议对于纯求和 $S = \\sum_{i=1}^{n} x_i$，用 FMA 运算 $s \\leftarrow \\mathrm{fma}(x_i, 1, s)$ 替代标准加法 $s \\leftarrow \\mathrm{fl}(s + x_i)$。其主张是这种替换消除了对 Kahan 补偿的需求，并能达到一个可比的误差界。\n\n运算 $\\mathrm{fma}(x_i, 1, s)$ 计算的是 $\\mathrm{fl}(x_i \\cdot 1 + s)$。设 $x_i$ 和 $s$ 是浮点数。数字 $1$ 是可以精确表示的。乘积 $x_i \\cdot 1$ 就是 $x_i$，这是一个精确运算。因此，$\\mathrm{fma}(x_i, 1, s) = \\mathrm{fl}(x_i + s)$。这与标准浮点加法是完全相同的运算。\n\n与简单加法相比，以这种方式使用 FMA 并未提供新的计算路径或减少舍入误差。该求和仍然是一个递归求和，其中和 $s_k$ 的更新规则是 $s_k \\leftarrow \\mathrm{fl}(s_{k-1} + x_k)$。如前所述，该方法的最坏情况前向误差为 $O(nu)$ 阶。Kahan 补偿求和的最坏情况前向误差界为 $O(u)$ 阶（忽略 $u$ 的高阶项）。对于大的 $n$，这两个误差界是不可比的。因此，这种 FMA 的使用方式并不能消除为达到高精度而使用 Kahan 式补偿的必要性。\n\n结论：**错误**。\n\n### 选项 B 分析\n该陈述涉及点积 $S = \\sum_{i=1}^{n} a_i b_i$。\n第 1 部分：使用 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 将每项的舍入次数从两次减少到一次。\n标准实现会计算 $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$（一次舍入），然后更新和 $s \\leftarrow \\mathrm{fl}(s + p_i)$（第二次舍入）。总共每项有两个舍入误差。基于 FMA 的更新是 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s) = \\mathrm{fl}(a_i b_i + s)$。这涉及到计算精确的乘积 $a_i b_i$，加上之前的和 $s$，然后执行单次舍入。这将每项的舍入操作次数从两次减少到一次。这部分陈述是正确的。\n\n第 2 部分：在最坏情况下，其前向误差仍为 $O(nu)$ 阶，并且对于长的、病态的累加，单独使用 FMA 无法匹敌 Kahan 的最坏情况精度。\n基于 FMA 的点积是项 $a_i b_i$ 的递归求和。设 $s_k$ 为 $k$ 项后的和。更新为 $s_k = \\mathrm{fl}(a_k b_k + s_{k-1}) = (a_k b_k + s_{k-1})(1+\\eta_k)$，其中 $|\\eta_k| \\le u$。对此的误差传播分析与标准递归求和的分析基本相同。最终误差由一个与 $nu\\sum_{i=1}^n|a_ib_i|$ 成正比的量所界定。误差界的增长与 $n$ 呈线性关系。一个病态的累加，例如将许多小项加到一个大的累加和中，会表现出这种较差的精度。\n当 Kahan 式补偿应用于乘积序列 $p_i = \\mathrm{fl}(a_i b_i)$ 时，其最终误差的界在 $u$ 的一阶上与 $n$ 无关。对于大的 $n$，这是一个显著的改进。因此，当 FMA 用于简单累加时，其精度无法与补偿求和在长或病态求和中的精度相匹敌。\n\n结论：**正确**。\n\n### 选项 C 分析\n该陈述描述了一种基于 FMA 的为乘积创建无误差变换的方法，该技术被称为 `TwoProduct`。方法如下：\n1.  $p_i \\leftarrow \\mathrm{fl}(a_i b_i)$\n2.  $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$\n\n第 1 部分：“在实数算术中，有 $p_i + e_i = a_i b_i$ 精确成立”。\n设 $a_i$ 和 $b_i$ 是具有 $P$ 个有效数字位的二进制浮点数（对于 binary64，$P=53$）。它们的精确乘积 $a_i b_i$ 可能需要多达 $2P$ 位来表示。量 $p_i = \\mathrm{fl}(a_i b_i)$ 是这个精确乘积舍入到 $P$ 位的结果。舍入误差为 $E = a_i b_i - p_i$。浮点算术的一个基本定理（最初由 Dekker 提出）指出，只要没有下溢或上溢，这个误差 $E$ 本身就可以精确地表示为一个浮点数。FMA 指令计算 $e_i = \\mathrm{fl}(a_i b_i - p_i)$。由于精确值 $a_i b_i - p_i$ 是一个浮点数，对其进行舍入没有影响，即 $\\mathrm{fl}(a_i b_i - p_i) = a_i b_i - p_i$。因此，$e_i = a_i b_i - p_i$，整理后得到 $p_i + e_i = a_i b_i$。这部分陈述，包括其附带条件，是正确的。这是一个标准的无误差变换 (Error-Free Transformation, EFT)。\n\n第 2 部分：“将 $p_i$ 累加到一个运行和中，并将 $e_i$ 累加到第二个运行和中，可以产生一种补偿机制...能够匹敌 Kahan 式补偿的精度优势”。\n这描述了一种精确的求和算法。我们将精确的点积 $\\sum a_i b_i$ 分解为 $\\sum (p_i + e_i) = \\sum p_i + \\sum e_i$。我们现在可以计算高位部分的和 $S_p = \\sum p_i$，以及低位误差部分的和 $S_e = \\sum e_i$。最终结果就是 $S_p + S_e$。这是一种双精度累加的形式（与 double-double 算术相关）。像 Ogita, Rump 和 Oishi 的 `Dot2` 算法就完全采用了这个原理。对此类方法的误差分析表明，它们非常精确，产生的误差界与对舍入乘积序列 $\\mathrm{fl}(a_i b_i)$ 应用 Kahan 求和相当或更优。\n\n结论：**正确**。\n\n### 选项 D 分析\n该陈述声称，在定向舍入（例如，向零舍入）下，Kahan 更新 $c \\leftarrow \\mathrm{fl}(\\mathrm{fl}(t-s)-y)$ 会失效，因此 FMA 是“绝对更优”的。\n\n第 1 部分：“在定向舍入下...Kahan 更新...不再是一个有效的数值恒等式”。\nKahan 求和中误差计算的正确性依赖于一种称为 `TwoSum` 的无误差变换，它严重依赖于舍入模式为“向最近舍入”。具体来说，允许使用减法恢复 $t = \\mathrm{fl}(s+y)$ 中舍入误差的定理（通常利用像 Sterbenz 引理这样的性质，即若 $a/2 \\le b \\le 2a$ 则 $\\mathrm{fl}(a-b)=a-b$），在定向舍入下会失效。定向舍入引入了偏差，并且舍入误差不再保证是一个可以通过简单减法精确恢复的浮点数。因此，Kahan 补偿的效果会减弱，误差项无法被精确恢复。这部分陈述是正确的。\n\n第 2 部分：“因此 FMA 是绝对更优的，并且可以在任何舍入模式下替代显式补偿”。\n这个结论是不合逻辑的。即使 Kahan 求和的效果下降，也不意味着简单的基于 FMA 的求和 $s \\leftarrow \\mathrm{fma}(a_i, b_i, s)$ 就是“绝对更优”的。如在 B 中所证，这种简单的 FMA 累加的误差界随 $O(nu)$ 增长。一个效果下降的 Kahan 求和，虽然不如在“向最近舍入”模式下有效，但通常仍然能抵消误差的高位部分，并且其性能往往远优于朴素求和，特别是对于大的 $n$。宣称 FMA“绝对更优”是不正确的。此外，该陈述似乎忽略了基于 FMA 的补偿方案（如 C 中所述）的可能性，这种方案将远优于简单的 FMA 累加。该主张是一个过度概括，逻辑上有缺陷。\n\n结论：**错误**。\n\n### 选项 E 分析\n该陈述考虑了在 FTZ（刷新到零）或 DAZ（非规格化数视为零）模式下，选项 C 中基于 FMA 的补偿方法 $e_i \\leftarrow \\mathrm{fma}(a_i, b_i, -p_i)$。\n\n该补偿机制依赖于误差项 $e_i = a_i b_i - p_i$ 的精确计算。这个误差项可能非常小。具体来说，其量级有界：$|e_i| \\le u |p_i|$。如果 $p_i$ 本身很小，或者由于抵消，$e_i$ 可能会落入次正规数范围（量级小于最小规格化数 $2^{E_{min}}$ 的数）。\n\nFTZ（刷新到零）是一种模式，其中任何结果为次正规数的操作都会产生一个（有符号的）零。如果真实的误差 $e_i$ 是一个在次正规数范围内的非零值，在启用 FTZ 的情况下计算它将得到结果 $0$。\nDAZ（非规格化数视为零）在次正规数作为运算输入时将其视为零。这也可能影响 $e_i$ 的计算。\n\n如果 $e_i$ 被错误地刷新为零，恒等式 $p_i + e_i = a_i b_i$ 就不再成立。该步骤的误差项丢失，补偿失败。误差项的累加和 $\\sum e_i$ 变得不准确，补偿方案的精度优势也遭到破坏。因此，为了使 `TwoProduct` 无误差变换和类似的补偿方案可靠，硬件和软件环境必须按照完整的 IEEE 754 标准正确支持次正规数。问题陈述正确地假设了这种支持（“支持次正规数”），而这个选项正确地指出了如果缺少这种支持会发生什么。\n\n结论：**正确**。",
            "answer": "$$\\boxed{BCE}$$"
        }
    ]
}