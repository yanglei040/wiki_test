{
    "hands_on_practices": [
        {
            "introduction": "特征值计算的数值困难通常源于多重根的存在。本练习将矩阵的抽象代数结构（特别是其若尔当标准型）与特征多项式和最小多项式的性质联系起来。通过一个具体的若尔当块示例，您将从根本上理解矩阵的亏损性（即不可对角化）如何导致高重根，而这正是病态问题的根源。",
            "id": "3536789",
            "problem": "设 $\\lambda_{0} \\in \\mathbb{R}$，并考虑由 $J_{k}(\\lambda_{0}) = \\lambda_{0} I_{k} + N_{k}$ 定义的大小为 $k$ 的若尔当块，其中 $I_{k}$ 是 $k \\times k$ 的单位矩阵，$N_{k}$ 是一个严格上三角矩阵，其第一超对角线上的元素为1，其余元素为0。定义 $5 \\times 5$ 矩阵\n$$\nA \\;=\\; \\operatorname{diag}\\!\\big(J_{3}(\\lambda_{0}),\\, J_{2}(\\lambda_{0})\\big).\n$$\n从以下基本定义出发：特征多项式 $p_{A}(\\lambda)$ 为 $p_{A}(\\lambda) = \\det(\\lambda I - A)$；最小多项式 $m_{A}(\\lambda)$ 是使得 $m_{A}(A) = 0$ 的次数最低的唯一首一多项式；矩阵 $N$ 是幂零的，如果对于某个正整数 $q$ 有 $N^{q} = 0$，其中最小的这样的 $q$ 称为幂零指数。从这些定义推导 $m_{A}(\\lambda)$ 和 $p_{A}(\\lambda)$，并严格证明为何一个特征值对应的最大若尔当块的大小决定了最小多项式中相应因子的指数，而代数重数决定了特征多项式中相应因子的指数。特别地，解释幂零部分 $N_{3}$ 和 $N_{2}$ 在决定 $m_{A}(\\lambda)$ 中 $(\\lambda - \\lambda_{0})$ 的指数时所起的作用，并说明为何 $p_{A}(\\lambda)$ 中的重根在数值上是敏感的：仅使用数值线性代数中的标准事实，提供一个有理有据的论证，说明当存在重特征值时，通过系数确定法计算 $p_{A}(\\lambda)$ 是病态的，并且微小扰动通常会改变若尔当结构，从而改变 $p_{A}(\\lambda)$ 的根的重数，并可能改变 $m_{A}(\\lambda)$ 中的指数。\n\n给出上述矩阵 $A$ 的最小多项式 $m_{A}(\\lambda)$ 的显式闭合形式表达式作为你的最终答案。最终答案中不要提供中间步骤。无需四舍五入。",
            "solution": "首先验证问题是自洽的、有科学依据且提法恰当的。所有定义和前提都是线性代数和数值分析中的标准内容。矩阵 $A$ 被精确定义为 $A = \\operatorname{diag}(J_{3}(\\lambda_{0}),\\, J_{2}(\\lambda_{0}))$，其中 $J_{k}(\\lambda_{0})$ 是一个大小为 $k$、特征值为 $\\lambda_{0} \\in \\mathbb{R}$ 的若尔当块。任务是推导 $A$ 的特征多项式和最小多项式，解释若尔当结构与这些多项式之间的联系，并讨论其数值意义。问题有效，我们开始求解。\n\n矩阵 $A$ 是一个 $5 \\times 5$ 的块对角矩阵：\n$$\nA = \\begin{pmatrix} J_{3}(\\lambda_{0})  \\mathbf{0}_{3 \\times 2} \\\\ \\mathbf{0}_{2 \\times 3}  J_{2}(\\lambda_{0}) \\end{pmatrix}\n$$\n其中 $\\mathbf{0}_{m \\times n}$ 是 $m \\times n$ 的零矩阵，若尔当块定义为 $J_{k}(\\lambda_{0}) = \\lambda_{0} I_{k} + N_{k}$。具体来说，\n$$\nJ_{3}(\\lambda_{0}) = \\begin{pmatrix} \\lambda_{0}  1  0 \\\\ 0  \\lambda_{0}  1 \\\\ 0  0  \\lambda_{0} \\end{pmatrix} \\quad \\text{和} \\quad J_{2}(\\lambda_{0}) = \\begin{pmatrix} \\lambda_{0}  1 \\\\ 0  \\lambda_{0} \\end{pmatrix}.\n$$\n矩阵 $N_{3}$ 和 $N_{2}$ 是以下形式的幂零矩阵：\n$$\nN_3 = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} \\quad \\text{和} \\quad N_2 = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix}.\n$$\n首先，我们从其定义 $p_{A}(\\lambda) = \\det(\\lambda I - A)$ 推导特征多项式 $p_{A}(\\lambda)$。矩阵 $\\lambda I - A$ 也是块对角的：\n$$\n\\lambda I - A = \\begin{pmatrix} \\lambda I_3 - J_3(\\lambda_0)  \\mathbf{0}_{3 \\times 2} \\\\ \\mathbf{0}_{2 \\times 3}  \\lambda I_2 - J_2(\\lambda_0) \\end{pmatrix}.\n$$\n一个块对角矩阵的行列式是其对角线上各块的行列式的乘积：\n$$\np_{A}(\\lambda) = \\det(\\lambda I_3 - J_3(\\lambda_0)) \\cdot \\det(\\lambda I_2 - J_2(\\lambda_0)).\n$$\n我们来分析单个块 $\\lambda I_k - J_k(\\lambda_0)$:\n$$\n\\lambda I_k - J_k(\\lambda_0) = \\lambda I_k - (\\lambda_0 I_k + N_k) = (\\lambda - \\lambda_0) I_k - N_k.\n$$\n这是一个上三角矩阵，其每个对角位置上的值都是 $(\\lambda - \\lambda_0)$。三角矩阵的行列式是其对角元素的乘积。因此，对于一个大小为 $k$ 的块：\n$$\n\\det((\\lambda - \\lambda_0) I_k - N_k) = (\\lambda - \\lambda_0)^k.\n$$\n将此应用于我们的具体情况：\n$$\n\\det(\\lambda I_3 - J_3(\\lambda_0)) = (\\lambda - \\lambda_0)^3 \\quad \\text{和} \\quad \\det(\\lambda I_2 - J_2(\\lambda_0)) = (\\lambda - \\lambda_0)^2.\n$$\n因此，$A$ 的特征多项式是：\n$$\np_{A}(\\lambda) = (\\lambda - \\lambda_0)^3 \\cdot (\\lambda - \\lambda_0)^2 = (\\lambda - \\lambda_0)^5.\n$$\n该推导阐释了一般性原理：特征多项式中因子 $(\\lambda - \\lambda_i)$ 的指数是与特征值 $\\lambda_i$ 相关联的所有若尔当块大小之和。根据定义，这个和就是 $\\lambda_i$ 的代数重数。对于矩阵 $A$，唯一的特征值是 $\\lambda_0$，其代数重数为 $3+2=5$。\n\n接下来，我们推导最小多项式 $m_{A}(\\lambda)$。根据凯莱-哈密顿定理，$p_{A}(A) = 0$，这意味着 $m_{A}(\\lambda)$ 必须整除 $p_{A}(\\lambda)$。由于 $p_{A}(\\lambda)$ 唯一的不可约因子是 $(\\lambda - \\lambda_0)$，最小多项式必为 $m_{A}(\\lambda) = (\\lambda - \\lambda_0)^q$ 的形式，其中 $q$ 是某个满足 $1 \\le q \\le 5$ 的整数。根据定义，$m_{A}(\\lambda)$ 是使得 $m_{A}(A) = \\mathbf{0}$ 的次数最低的首一多项式。我们需要找到使 $(A - \\lambda_0 I)^q = \\mathbf{0}$ 成立的最小正整数 $q$。\n\n我们来计算矩阵多项式 $(A - \\lambda_0 I)^q$:\n$$\nA - \\lambda_0 I = \\operatorname{diag}(J_3(\\lambda_0) - \\lambda_0 I_3, J_2(\\lambda_0) - \\lambda_0 I_2) = \\operatorname{diag}(N_3, N_2).\n$$\n将此块对角矩阵升至 $q$ 次幂得到：\n$$\n(A - \\lambda_0 I)^q = \\operatorname{diag}(N_3^q, N_2^q).\n$$\n这个矩阵是零矩阵当且仅当 $N_3^q = \\mathbf{0}$ 和 $N_2^q = \\mathbf{0}$ 同时成立。\n我们需要确定 $N_k$ 的幂零指数，即使得 $N_k^j = \\mathbf{0}$ 的最小整数 $j$。对于一个大小为 $k$ 的标准幂零若尔当块 $N_k$，每次乘以自身，超对角线上的 1 会向上移动一个对角线位置。$N_k^j$ 在第 $j$ 条超对角线上有 1。因此，$N_k^{k-1}$ 在右上角有一个 1，而 $N_k^k = \\mathbf{0}$。$N_k$ 的幂零指数为 $k$。\n对于我们的块， $N_3$ 的幂零指数是 $3$， $N_2$ 的幂零指数是 $2$。\n条件 $N_3^q = \\mathbf{0}$ 要求 $q \\ge 3$。\n条件 $N_2^q = \\mathbf{0}$ 要求 $q \\ge 2$。\n要同时满足这两个条件，$q$ 必须大于或等于这些所需指数的最大值：$q \\ge \\max(3, 2) = 3$。\n最小多项式对应于最小的此类整数 $q$，因此 $q=3$。\n因此，$A$ 的最小多项式是：\n$$\nm_A(\\lambda) = (\\lambda - \\lambda_0)^3.\n$$\n该推导严格地证明了一般性法则：最小多项式中因子 $(\\lambda - \\lambda_i)$ 的指数是与特征值 $\\lambda_i$ 相关联的*最大*若尔当块的大小。幂零部分 $N_3$ 和 $N_2$ 在此过程中起着核心作用。矩阵 $(A - \\lambda_0 I)$ 是幂零的，其幂零指数恰好是最小多项式的次数（此处没有其他不同特征值因子）。$\\operatorname{diag}(N_{k_1}, N_{k_2}, \\dots)$ 的幂零指数是 $\\max(k_1, k_2, \\dots)$，也就是最大块的大小。$N_3$ 块作为较大的块，决定了最小多项式的次数，因为它的幂零性要求（$q \\ge 3$）最为严格。\n\n最后，我们讨论通过特征多项式计算特征值的数值敏感性问题。通过首先计算 $p_A(\\lambda) = \\sum_{i=0}^n c_i \\lambda^i$ 的系数，然后求其根来寻找特征值的过程是众所周知的数值不稳定，尤其是在根具有高重数时。\n设 $p(\\lambda)$ 是一个多项式，它有一个重数为 $m > 1$ 的根 $\\lambda_0$。这个根对多项式系数扰动的敏感度很高。考虑对多项式的一个小扰动，$\\tilde{p}(\\lambda) = p(\\lambda) + \\epsilon g(\\lambda)$，其中 $\\epsilon$ 是一个很小的参数。$\\tilde{p}(\\lambda)$ 的根会从 $\\lambda_0$ 扰动到 $\\tilde{\\lambda}$。对于接近 $\\lambda_0$ 的 $\\lambda$，我们可以近似 $p(\\lambda) \\approx C(\\lambda - \\lambda_0)^m$，其中 $C \\neq 0$ 是某个常数。扰动后根的方程为 $\\tilde{p}(\\tilde{\\lambda}) = C(\\tilde{\\lambda} - \\lambda_0)^m + \\epsilon g(\\tilde{\\lambda}) \\approx 0$。假设 $g(\\lambda_0) \\neq 0$，这得到 $(\\tilde{\\lambda} - \\lambda_0)^m \\approx -\\epsilon g(\\lambda_0)/C$。那么根扰动的量级为：\n$$\n|\\tilde{\\lambda} - \\lambda_0| \\approx \\left| \\frac{\\epsilon g(\\lambda_0)}{C} \\right|^{1/m} = O(\\epsilon^{1/m}).\n$$\n对于 $m>1$，指数 $1/m$ 小于 1。这意味着根的扰动 $O(\\epsilon^{1/m})$ 远大于系数的扰动 $O(\\epsilon)$。例如，如果 $m=5$（如我们的 $p_{A}(\\lambda)$ 的情况）且 $\\epsilon=10^{-10}$，根的扰动量级为 $(10^{-10})^{1/5} = 10^{-2}$，误差放大了 $10^8$ 倍。这种极端的敏感性是病态问题的标志。\n\n此外，对矩阵 $A$ 本身的微小扰动会对其代数结构产生深远影响。矩阵 $A$ 是亏损的，意味着它不可对角化。这是因为 $\\lambda_0$ 的几何重数（若尔当块的数量，即2）小于其代数重数（即5）。矩阵扰动理论的一个基本结果是，亏损矩阵不是一个“一般”情况。对 $A$ 施加一个小的、任意的扰动 $E$，得到 $A' = A + E$，几乎必然会产生一个具有互异特征值的矩阵 $A'$。\n对于矩阵 $A$，一个范数很小的一般性扰动 $E$ 将会产生一个扰动后的矩阵 $A'$，它有 5 个互异的特征值 $\\lambda_1', \\dots, \\lambda_5'$，这些特征值都与 $\\lambda_0$ 相距很近。\n若尔当结构被破坏了。$A$ 的若尔当范式是 $\\operatorname{diag}(J_3(\\lambda_0), J_2(\\lambda_0))$。而 $A'$ 的若尔当范式将是一个对角矩阵 $\\operatorname{diag}(\\lambda_1', \\dots, \\lambda_5')$，它由五个 $1 \\times 1$ 的若尔当块组成。\n这极大地改变了特征多项式和最小多项式。特征多项式变为 $p_{A'}(\\lambda) = \\prod_{i=1}^5 (\\lambda - \\lambda_i')$，它有 5 个单根。对于可对角化矩阵，最小多项式是不同线性因子的乘积，因此最小多项式变为 $m_{A'}(\\lambda) = p_{A'}(\\lambda)$。最小多项式的次数从 $A$ 的 3 次跃升为 $A'$ 的 5 次。\n这种不稳定性——即无穷小的扰动可以从根本上改变若尔当结构、根的重数以及最小多项式的次数——解释了为什么用于计算特征值的数值方法（如QR算法）被设计为直接处理矩阵，以避免通过构建特征多项式系数这一中间的病态步骤。它们通过迭代将矩阵转换为一种范式（如上三角的舒尔范式），从而可以稳定地读取特征值。",
            "answer": "$$\n\\boxed{(\\lambda - \\lambda_{0})^{3}}\n$$"
        },
        {
            "introduction": "在理解了多重根的理论基础之后，本实践将展示这些问题如何在有限精度计算中显现。尽管特征多项式在理论上于相似变换下保持不变，但这个编程练习将通过实验证明，这种不变性在数值计算中是脆弱的。通过比较稳定的正交变换和病态的非正交变换，您将直接观察并量化计算过程中舍入误差如何被急剧放大，从而破坏系数的准确性。",
            "id": "3536821",
            "problem": "考虑一个 $n \\times n$ 矩阵 $A$ 的特征多项式 $p_A(\\lambda)$ 的数值计算，其定义为 $p_A(\\lambda) = \\det(\\lambda I - A)$。一个基本事实是，$p_A$ 在相似变换下保持不变：对于任意可逆矩阵 $S$，有 $p_A(\\lambda) = p_{S^{-1} A S}(\\lambda)$。一个特例是正交相似，其中 $Q$ 是正交矩阵（即 $Q^\\top Q = I$），从而得到 $p_A(\\lambda) = p_{Q^\\top A Q}(\\lambda)$。在浮点运算中，计算会受到舍入误差的影响，遵循标准模型 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\leq u$，$u$ 是单位舍入。在数值线性代数中，正交变换在谱范数下是保范数的，即 $\\|Q^\\top A Q\\|_2 = \\|A\\|_2$，而由 $S$ 引起的一般相似变换可能会放大范数，其程度由条件数 $\\kappa_2(S) = \\|S\\|_2 \\|S^{-1}\\|_2$ 控制。\n\n您的任务是使用一个固定的、基于迹的方案，通过经验比较正交与非正交相似变换对 $p_A(\\lambda)$ 系数数值计算的影响。具体来说：\n\n- 使用 Faddeev–LeVerrier 递推来计算特征多项式的系数。设 $B_0 = I$，对于 $k = 1, 2, \\dots, n$，定义\n  $$\n  c_k = -\\frac{1}{k}\\operatorname{tr}(A B_{k-1}), \\quad B_k = A B_{k-1} + c_k I,\n  $$\n  使得特征多项式为 $p_A(\\lambda) = \\lambda^n + c_1 \\lambda^{n-1} + \\cdots + c_n$。\n- 此递推需要在两种数值上不同的算术模型中实现：\n  1. 对给定的整数矩阵 $A$ 使用精确有理数运算，以使输出的系数在数学上是精确的（这些系数定义了 $p_A$ 的基准真相）。\n  2. 使用双精度浮点运算，应用于 $A$ 的变换版本。\n\n使用以下科学依据和定义，无需进一步推导：(i) 特征多项式在相似变换下的不变性，(ii) 正交矩阵满足 $Q^\\top Q = I$，(iii) 带有单位舍入 $u$ 的标准浮点舍入模型，以及 (iv) 谱范数在正交相似下的不变性，而一般相似变换可能会将中间量放大，放大比例与基变换的条件数成正比。\n\n对于下面的每个测试用例，执行以下操作：\n1. 使用指定的随机种子，从 $\\{-2,-1,0,1,2\\}$ 中均匀抽取元素，构建一个整数矩阵 $A \\in \\mathbb{Z}^{n \\times n}$。\n2. 使用精确有理数运算计算精确的系数向量 $\\mathbf{c}_{\\mathrm{exact}} = (c_1,\\dots,c_n)$（此分支不使用浮点数）。\n3. 使用指定的种子，通过对一个具有独立标准正态分布条目的 $n \\times n$ 矩阵进行 $QR$ 分解，形成一个正交矩阵 $Q$，并在浮点运算中定义 $A_{\\mathrm{orth}} = Q^\\top A Q$。\n4. 使用指定的指数，形成一个对角的、可逆的、非正交的相似矩阵 $S = \\operatorname{diag}(10^{\\alpha_0}, \\dots, 10^{\\alpha_{n-1}})$，并在浮点运算中定义 $A_{\\mathrm{non}} = S^{-1} A S$。\n5. 使用浮点运算，通过相同的 Faddeev–LeVerrier 方案，从 $A_{\\mathrm{orth}}$ 计算 $\\mathbf{c}_{\\mathrm{orth}}$，从 $A_{\\mathrm{non}}$ 计算 $\\mathbf{c}_{\\mathrm{non}}$。\n6. 量化相对系数误差\n   $$\n   e_{\\mathrm{orth}} = \\frac{\\|\\mathbf{c}_{\\mathrm{orth}} - \\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}{\\|\\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}, \\quad\n   e_{\\mathrm{non}} = \\frac{\\|\\mathbf{c}_{\\mathrm{non}} - \\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}{\\|\\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}.\n   $$\n7. 将放大比 $r = e_{\\mathrm{non}}/e_{\\mathrm{orth}}$ 报告为一个浮点数。\n\n测试套件：\n- 用例 1（正常路径）：$n = 6$，$A$ 的种子是 $2025$，$Q$ 的种子是 $123$，$S = \\operatorname{diag}(10^{0}, 10^{1}, 10^{2}, 10^{3}, 10^{4}, 10^{5})$。\n- 用例 2（边界：无非正交失真）：$n = 6$，与用例 1 中的 $A$ 相同，$Q$ 的种子是 $321$，$S = I$（即所有指数均为零）。\n- 用例 3（边缘：更强的非正交失真）：$n = 6$，与用例 1 中的 $A$ 相同，$Q$ 的种子是 $999$，$S = \\operatorname{diag}(10^{0}, 10^{2}, 10^{4}, 10^{6}, 10^{8}, 10^{10})$。\n\n用例 1-3 中的所有矩阵都将根据所述种子确定性地构建，以确保结果是可复现的。\n\n您的程序必须：\n- 使用有理数运算实现精确的 Faddeev–LeVerrier 算法，从整数矩阵 $A$ 生成 $\\mathbf{c}_{\\mathrm{exact}}$。\n- 实现浮点 Faddeev–LeVerrier 算法，分别从 $A_{\\mathrm{orth}}$ 和 $A_{\\mathrm{non}}$ 生成 $\\mathbf{c}_{\\mathrm{orth}}$ 和 $\\mathbf{c}_{\\mathrm{non}}$。\n- 对于每个用例，计算比率 $r = e_{\\mathrm{non}}/e_{\\mathrm{orth}}$ 并将其存储为 Python 浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个比率，形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3]”）。此问题不涉及单位。不涉及角度。不涉及百分比；所有比率都应以普通十进制数输出。",
            "solution": "用户想要解决一个数值线性代数问题。\n该问题要求对给定 $n \\times n$ 矩阵 $A$ 的特征多项式 $p_A(\\lambda) = \\det(\\lambda I - A)$ 系数计算的数值稳定性进行实证研究。任务的核心是比较应用正交相似变换与非正交、病态相似变换后所得结果的准确性。特征多项式在任何相似变换下的不变性，即 $p_A(\\lambda) = p_{S^{-1}AS}(\\lambda)$，在精确算术中成立，但在数值计算中常因浮点误差而失效。本实验旨在量化这种失效。\n\n选择的系数计算算法是 Faddeev–LeVerrier 递推。给定一个 $n \\times n$ 矩阵，该方法生成特征多项式 $p_A(\\lambda) = \\lambda^n + c_1 \\lambda^{n-1} + \\cdots + c_n$ 的系数 $c_1, \\dots, c_n$。该递推的定义是：初始化 $B_0 = I$（$n \\times n$ 单位矩阵），然后对 $k = 1, 2, \\dots, n$ 进行迭代：\n$$c_k = -\\frac{1}{k}\\operatorname{tr}(A B_{k-1})$$\n$$B_k = A B_{k-1} + c_k I$$\n众所周知，该算法在数值上是不稳定的，部分原因在于它涉及重复的矩阵乘法，这会放大初始误差。\n\n为了进行受控的数值实验，我们对每个测试用例遵循一个三管齐下的计算策略：\n\n1.  **精确基准真相计算**：为建立一个无误差的基线，系数向量 $\\mathbf{c}_{\\mathrm{exact}} = (c_1, \\dots, c_n)$ 是通过对初始整数矩阵 $A$ 使用以精确有理数运算实现的 Faddeev–LeVerrier 算法计算得出的。这是通过将所有数字和矩阵元素表示为 `fractions.Fraction` 对象来实现的，确保所有除法和其他运算都不会产生任何舍入误差。该向量 $\\mathbf{c}_{\\mathrm{exact}}$ 作为衡量浮点计算结果的基准真相。\n\n2.  **正交变换路径**：生成一个正交矩阵 $Q$（其中 $Q^\\top Q = I$），并使用标准双精度浮点运算计算变换后的矩阵 $A_{\\mathrm{orth}} = Q^\\top A Q$。正交变换对于谱范数是完美条件的，其条件数 $\\kappa_2(Q) = 1$，并且它们是保范数的，即 $\\|Q^\\top A Q\\|_2 = \\|A\\|_2$。因此，从 $A$到 $A_{\\mathrm{orth}}$ 的变换引入的数值扰动极小。然后将 Faddeev–LeVerrier 算法应用于 $A_{\\mathrm{orth}}$ 的浮点运算中，以产生系数向量 $\\mathbf{c}_{\\mathrm{orth}}$。预计该向量中的误差主要由算法本身的内在不稳定性决定，而非变换过程。\n\n3.  **非正交变换路径**：构建一个非正交的对角相似矩阵 $S$，其元素跨越多个数量级。这使得 $S$ 成为病态矩阵，具有很大的条件数 $\\kappa_2(S) = \\|S\\|_2 \\|S^{-1}\\|_2$。变换后的矩阵 $A_{\\mathrm{non}} = S^{-1} A S$ 在浮点运算中计算。$A_{\\mathrm{non}}$ 的元素由 $(A_{\\mathrm{non}})_{ij} = (S^{-1}AS)_{ij} = A_{ij} S_{jj} / S_{ii}$ 给出。$S$ 的对角元素之间的巨大比率可以急剧改变 $A_{\\mathrm{non}}$ 中元素的尺度（与 $A$ 相比），可能导致在矩阵运算中将较小的数加到较大的数时丢失有效数字。将 Faddeev–LeVerrier 算法应用于 $A_{\\mathrm{non}}$ 以找到 $\\mathbf{c}_{\\mathrm{non}}$。预计由此产生的误差将远大于正交情况下的误差，并因相似变换的病态性而被放大。\n\n最后一步是量化和比较误差。使用无穷范数计算正交和非正交路径的相对误差：\n$$e_{\\mathrm{orth}} = \\frac{\\|\\mathbf{c}_{\\mathrm{orth}} - \\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}{\\|\\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}, \\quad e_{\\mathrm{non}} = \\frac{\\|\\mathbf{c}_{\\mathrm{non}} - \\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}{\\|\\mathbf{c}_{\\mathrm{exact}}\\|_\\infty}$$\n放大比 $r = e_{\\mathrm{non}} / e_{\\mathrm{orth}}$ 衡量了病态非正交变换相对于稳定正交变换多引入了多少数值误差。一个大的比率 $r \\gg 1$ 表明，在实践中使用正交变换具有更优的数值稳定性。对于 $S=I$ 的特殊情况，“非正交”路径导致 $A_{\\mathrm{non}}=A$，我们预计 $e_{\\mathrm{non}}$ 和 $e_{\\mathrm{orth}}$ 的量级相似，从而得到 $r \\approx 1$。",
            "answer": "```python\nimport numpy as np\nfrom fractions import Fraction\n\ndef faddeev_leverrier_exact(A_int, n):\n    \"\"\"\n    Computes characteristic polynomial coefficients using exact rational arithmetic.\n    All intermediate calculations are done using Python's Fraction type.\n    \"\"\"\n    A_frac = np.array([[Fraction(x) for x in row] for row in A_int], dtype=object)\n    I_frac = np.array([[Fraction(int(i==j)) for j in range(n)] for i in range(n)], dtype=object)\n    \n    B = I_frac.copy()\n    c_coeffs = []\n    \n    for k in range(1, n + 1):\n        # B_{k} = A*B_{k-1} + c_k*I\n        # c_k = -1/k * tr(A*B_{k-1})\n        AB = A_frac @ B\n        tr_AB = np.trace(AB)\n        c_k = -tr_AB / Fraction(k)\n        c_coeffs.append(c_k)\n        B = AB + c_k * I_frac\n        \n    return np.array(c_coeffs, dtype=object)\n\ndef faddeev_leverrier_float(A_float, n):\n    \"\"\"\n    Computes characteristic polynomial coefficients using standard floating-point arithmetic.\n    \"\"\"\n    B = np.identity(n)\n    c_coeffs = np.zeros(n)\n    \n    for k in range(1, n + 1):\n        AB = A_float @ B\n        c_k = -np.trace(AB) / k\n        c_coeffs[k-1] = c_k\n        B = AB + c_k * np.identity(n)\n        \n    return c_coeffs\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute error amplification ratios.\n    \"\"\"\n    test_cases = [\n        {'n': 6, 'seed_A': 2025, 'seed_Q': 123, 'S_exponents': [0, 1, 2, 3, 4, 5]},\n        {'n': 6, 'seed_A': 2025, 'seed_Q': 321, 'S_exponents': [0, 0, 0, 0, 0, 0]},\n        {'n': 6, 'seed_A': 2025, 'seed_Q': 999, 'S_exponents': [0, 2, 4, 6, 8, 10]},\n    ]\n\n    ratios = []\n\n    for case in test_cases:\n        n = case['n']\n        seed_A = case['seed_A']\n        seed_Q = case['seed_Q']\n        S_exponents = case['S_exponents']\n\n        # Step 1: Construct integer matrix A deterministically.\n        rng_A = np.random.default_rng(seed_A)\n        A_int = rng_A.integers(-2, 3, size=(n, n))\n\n        # Step 2: Compute exact coefficients c_exact using rational arithmetic.\n        c_exact = faddeev_leverrier_exact(A_int, n)\n        c_exact_float = np.array([float(c) for c in c_exact])\n        norm_c_exact = np.linalg.norm(c_exact_float, ord=np.inf)\n        \n        if norm_c_exact == 0:\n            # Handle the unlikely degenerate case where c_exact is a zero vector.\n            ratios.append(float('nan'))\n            continue\n\n        A_float = A_int.astype(float)\n\n        # Step 3: Form orthogonal matrix Q and A_orth.\n        rng_Q = np.random.default_rng(seed_Q)\n        Z = rng_Q.standard_normal(size=(n, n))\n        Q, _ = np.linalg.qr(Z)\n        A_orth = Q.T @ A_float @ Q\n\n        # Step 4: Form non-orthogonal matrix S and A_non.\n        S_diag = np.array([10.0**exp for exp in S_exponents])\n        # Efficiently compute A_non = S_inv @ A @ S for diagonal S.\n        # (A_non)_ij = A_ij * (S_j / S_i)\n        A_non = A_float * (S_diag / S_diag[:, np.newaxis])\n\n        # Step 5: Compute float coefficients for transformed matrices.\n        c_orth = faddeev_leverrier_float(A_orth, n)\n        c_non = faddeev_leverrier_float(A_non, n)\n        \n        # Step 6: Quantify relative coefficient errors.\n        err_vec_orth = c_orth - c_exact_float\n        e_orth = np.linalg.norm(err_vec_orth, ord=np.inf) / norm_c_exact\n        \n        err_vec_non = c_non - c_exact_float\n        e_non = np.linalg.norm(err_vec_non, ord=np.inf) / norm_c_exact\n\n        # Step 7: Report the amplification ratio r.\n        # If e_orth is zero, the orthogonal path was perfectly accurate.\n        if e_orth == 0:\n            r = float('inf') if e_non > 0 else 1.0\n        else:\n            r = e_non / e_orth\n        ratios.append(r)\n\n    print(f\"[{','.join(map(str, ratios))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个练习深入探讨了通过多项式求根来计算特征值为何不可靠的核心原因：多项式系数对其根（即特征值）的微小变化极为敏感。这项编程实践要求您推导并实现一个敏感性分析，以确定哪个特征值的变动对给定系数的影响最大。通过这种方式，您将能够量化从特征值到系数这一映射的病态程度，从而完成对特征多项式计算局限性的全面理解。",
            "id": "3536823",
            "problem": "考虑一个实数域上的 $n$ 维方阵，其特征值为 $\\lambda_1,\\ldots,\\lambda_n$。其特征多项式定义为 $p(\\lambda) = \\det(\\lambda I - A)$，可以写成一个首一多项式 $p(\\lambda) = \\lambda^n + c_{n-1}\\lambda^{n-1} + \\cdots + c_0$。从特征值多重集到多项式系数 $c_{n-k}$ 的映射是特征值的对称函数。仅从特征多项式的基本定义和系数关于特征值的对称性出发，推导单个系数 $c_{n-k}$ 相对于单个特征值 $\\lambda_j$ 扰动的一阶灵敏度的第一性原理表达式，即偏导数 $\\frac{\\partial c_{n-k}}{\\partial \\lambda_j}$，并纯粹用特征值来表示。\n\n利用你推導出的表达式，设计一个算法实验。对于一组固定的特征值和一个固定的索引 $k$，该实验需要选出那个无穷小移动能导致系数 $c_{n-k}$ 产生最大一阶变化的单个特征值。实验必须以数值稳健的方式执行以下步骤：\n\n- 仅使用给定的特征值作为输入；不要从任何矩阵中恢复它们。\n- 通过将特征多项式 $p(\\lambda)$ 构造为乘积 $\\prod_{i=1}^{n}(\\lambda - \\lambda_i)$ 并读取系数来计算 $c_{n-k}$。\n- 使用你推导的表达式计算所有偏导数 $\\frac{\\partial c_{n-k}}{\\partial \\lambda_j}$，其中 $j \\in \\{1,\\ldots,n\\}$。\n- 确定使导数大小 $\\left|\\frac{\\partial c_{n-k}}{\\partial \\lambda_j}\\right|$ 最大化的索引 $j^\\star$。\n- 选择一个施加于 $\\lambda_{j^\\star}$ 的带符号扰动 $\\Delta$，使其在梯度方向上最大化 $c_{n-k}$ 的增量，即，取 $\\Delta$ 的符号与 $\\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}}$ 的符号相同，并使用每个测试用例指定的固定大小。\n- 通过线性化 $\\Delta c_{\\text{pred}} = \\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}} \\cdot \\Delta$ 来预测系数的变化，然后通过使用扰动后的特征值重构 $p(\\lambda)$ 并再次读取 $c_{n-k}$ 来计算实际变化 $\\Delta c_{\\text{act}}$。\n- 报告相对线性化误差，定义为 $$\\mathrm{err}_{\\text{rel}} = \\frac{\\left|\\Delta c_{\\text{act}} - \\Delta c_{\\text{pred}}\\right|}{\\left|\\Delta c_{\\text{pred}}\\right| + \\eta},$$ 其中 $\\eta = 10^{-300}$ 是为避免除以零而引入的一个小的正数。\n- 报告 $c_{n-k}$ 相对于 $\\lambda_{j^\\star}$ 的单参数相对条件数，定义为 $$\\kappa_{j^\\star} = \\left|\\frac{\\lambda_{j^\\star}}{c_{n-k}}\\right| \\left|\\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}}\\right|,$$ 并根据其大小解释浮点 (FP) 舍入误差的潜在放大效应，其中 IEEE 754 双精度的机器 epsilon 为 $u = 2^{-53}$。\n\n将此实验实现为一个完整的程序。程序必须生成单行输出，将所有测试用例的结果汇总为一个由方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含五个条目的列表，顺序如下：所选索引 $j^\\star$（作为 0-based 整数）、预测变化 $\\Delta c_{\\text{pred}}$（作为浮点数）、实际变化 $\\Delta c_{\\text{act}}$（作为浮点数）、相对线性化误差 $\\mathrm{err}_{\\text{rel}}$（作为浮点数）以及相对条件数 $\\kappa_{j^\\star}$（作为浮点数）。\n\n使用以下测试套件，它涵盖了一般情况、近似抵消、大数值以及重复或零特征值：\n\n- 测试 1：$n=5$，特征值 $[1,2,3,4,5]$，索引 $k=3$，扰动大小 $\\Delta = 10^{-8}$。\n- 测试 2：$n=6$，特征值 $[1,-1,1+10^{-8},-1-10^{-8},2,-2]$，索引 $k=3$，扰动大小 $\\Delta = 10^{-8}$。\n- 测试 3：$n=6$，特征值 $[10,9,8,7,6,5]$，索引 $k=6$，扰动大小 $\\Delta = 10^{-12}$。\n- 测试 4：$n=4$，特征值 $[0,0,1,2]$，索引 $k=2$，扰动大小 $\\Delta = 10^{-6}$。\n\n你的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，其中每个元素是对应于一个测试用例的列表，并按上述确切顺序排列。例如，一个语法上有效的输出格式是 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$，其中每个 $\\text{case}$ 是一个包含五个指定基本条目的 Python 风格列表。",
            "solution": "该问题要求推导特征多项式系数相对于其某个根（特征值）的一阶灵敏度，并基于此推导实现一个数值实验。\n\n### 第 1 部分：灵敏度的第一性原理推导\n\n设 $A$ 是一个 $n \\times n$ 矩阵，其特征值为 $\\lambda_1, \\ldots, \\lambda_n$。$A$ 的特征多项式定义为 $p(\\lambda) = \\det(\\lambda I - A)$。该多项式可以表示为两种形式：\n1.  因式分解形式，用其根（特征值）表示：\n    $$p(\\lambda) = \\prod_{i=1}^{n} (\\lambda - \\lambda_i)$$\n2.  展开的首一形式：\n    $$p(\\lambda) = \\lambda^n + c_{n-1}\\lambda^{n-1} + \\cdots + c_1\\lambda + c_0 = \\sum_{k=0}^{n} c_{n-k} \\lambda^{n-k}$$\n    按照惯例，$\\lambda^n$ 的系数为 $c_n=1$。\n\n多项式的系数 $c_{n-k}$ 与特征值的初等对称多项式 $e_k(\\lambda_1, \\ldots, \\lambda_n)$ 相关。$k$ 次初等对称多项式是所有 $k$ 个不同特征值乘积之和：\n$$e_k(\\lambda_1, \\ldots, \\lambda_n) = \\sum_{1 \\le i_1  i_2  \\cdots  i_k \\le n} \\lambda_{i_1} \\lambda_{i_2} \\cdots \\lambda_{i_k}$$\n通过展开 $p(\\lambda)$ 的因式分解形式，可以发现系数和初等对称多项式之间的关系为：\n$$c_{n-k} = (-1)^k e_k(\\lambda_1, \\ldots, \\lambda_n) \\quad \\text{for } k=1, \\ldots, n$$\n\n我们的目标是为某个特征值 $\\lambda_j$ 推导偏导数 $\\frac{\\partial c_{n-k}}{\\partial \\lambda_j}$ 的表达式。我们首先对 $c_{n-k}$ 的表达式进行微分：\n$$\\frac{\\partial c_{n-k}}{\\partial \\lambda_j} = \\frac{\\partial}{\\partial \\lambda_j} \\left[ (-1)^k e_k(\\lambda_1, \\ldots, \\lambda_n) \\right] = (-1)^k \\frac{\\partial e_k(\\lambda_1, \\ldots, \\lambda_n)}{\\partial \\lambda_j}$$\n\n现在，我们分析初等对称多项式 $e_k$ 的偏导数。$e_k$ 的求和项中要么包含 $\\lambda_j$，要么不包含。\n- 如果一项不包含 $\\lambda_j$，其相对于 $\\lambda_j$ 的导数为零。\n- 如果一项包含 $\\lambda_j$，则其形式为 $\\lambda_j \\cdot (\\text{k-1 个其他不同特征值的乘积})$。这样一项相对于 $\\lambda_j$ 的导数恰好是其他 $k-1$ 个特征值的乘积。\n\n因此，$\\frac{\\partial e_k}{\\partial \\lambda_j}$ 是从集合 $\\{\\lambda_1, \\ldots, \\lambda_n\\} \\setminus \\{\\lambda_j\\}$ 中选取 $k-1$ 个不同特征值的所有乘积之和。根据定义，这是作用于 $n-1$ 个变量 $\\{\\lambda_i\\}_{i \\ne j}$ 的 $k-1$ 次初等对称多项式。我们将其记为 $e_{k-1}(\\{\\lambda_i\\}_{i \\ne j})$。\n对于 $k=1$ 的特殊情况，$e_1 = \\sum \\lambda_i$。那么 $\\frac{\\partial e_1}{\\partial \\lambda_j} = 1$。这与我们的结果一致，因为 $e_0$（空乘积之和）被定义为 1。\n\n将此结果代回到 $c_{n-k}$ 的导数表达式中：\n$$\\frac{\\partial c_{n-k}}{\\partial \\lambda_j} = (-1)^k e_{k-1}(\\{\\lambda_i\\}_{i \\ne j})$$\n这就是所求的第一性原理表达式。\n\n为了计算方便，将此结果用多项式系数表示是很有利的，因为多项式系数可以高效计算。让我们定义一个新的 $n-1$ 次多项式 $p_j(\\lambda)$，其根为特征值 $\\{\\lambda_i\\}_{i \\ne j}$：\n$$p_j(\\lambda) = \\prod_{i \\ne j} (\\lambda - \\lambda_i) = \\sum_{m=0}^{n-1} c'_{n-1-m} \\lambda^{n-1-m}$$\n这个新多项式的系数 $c'_{n-1-m}$ 由 $c'_{n-1-m} = (-1)^m e_m(\\{\\lambda_i\\}_{i \\ne j})$ 给出。\n我们需要找到 $e_{k-1}(\\{\\lambda_i\\}_{i \\ne j})$。这对应于设置 $m=k-1$：\n$$e_{k-1}(\\{\\lambda_i\\}_{i \\ne j}) = (-1)^{-(k-1)} c'_{n-1-(k-1)} = (-1)^{k-1} c'_{n-k}$$\n将此代入推导出的灵敏度公式中得到：\n$$\\frac{\\partial c_{n-k}}{\\partial \\lambda_j} = (-1)^k \\left( (-1)^{k-1} c'_{n-k} \\right) = -c'_{n-k}$$\n项 $c'_{n-k}$ 是多项式 $p_j(\\lambda)$ 中 $\\lambda^{(n-1)-(k-1)} = \\lambda^{n-k}$ 项的系数。这提供了一种直接且数值稳定的方法来计算导数。\n\n### 第 2 部分：算法实验设计\n\n基于以上推导，实验按以下步骤进行：\n1.  **输入**：一组 $n$ 个特征值 $\\{\\lambda_i\\}_{i=1}^n$、一个索引 $k \\in \\{1, \\ldots, n\\}$ 以及一个扰动大小 $\\Delta_0$。\n2.  **计算初始系数**：构造特征多项式 $p(\\lambda) = \\prod_{i=1}^n (\\lambda - \\lambda_i)$。得到系数 $[c_n, c_{n-1}, \\ldots, c_0]$，其中 $c_n=1$。我们关注的初始系数是 $c_{n-k}$。\n3.  **计算灵敏度**：对于每个特征值 $\\lambda_j$（其中 $j=1, \\ldots, n$）：\n    a. 形成包含 $n-1$ 个特征值的集合 $\\{\\lambda_i\\}_{i \\ne j}$。\n    b. 构造多项式 $p_j(\\lambda) = \\prod_{i \\ne j} (\\lambda-\\lambda_i)$ 并获得其系数，记为 $\\{c'_{m}\\}$。\n    c. 灵敏度计算为 $\\frac{\\partial c_{n-k}}{\\partial \\lambda_j} = -c'_{n-k}$，其中 $c'_{n-k}$ 是 $p_j(\\lambda)$ 中 $\\lambda^{n-k}$ 项的系数。\n4.  **识别最敏感方向**：找到对应于使灵敏度大小最大化的特征值 $\\lambda_{j^\\star}$ 的索引 $j^\\star$：$j^\\star = \\arg\\max_j \\left| \\frac{\\partial c_{n-k}}{\\partial \\lambda_j} \\right|$。\n5.  **施加扰动**：\n    a. 确定扰动的符号以最大化 $c_{n-k}$ 的增量：$s = \\mathrm{sign}\\left(\\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}}\\right)$。\n    b. 要施加的扰动为 $\\Delta = s \\cdot \\Delta_0$。\n    c. 通过将 $\\lambda_{j^\\star}$ 替换为 $\\lambda_{j^\\star} + \\Delta$ 来形成扰动后的特征值集合。\n6.  **预测和测量变化**：\n    a. 基于线性化的系数预测变化为 $\\Delta c_{\\text{pred}} = \\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}} \\cdot \\Delta$。\n    b. 通过从扰动后的特征值构造新的特征多项式并找到新系数 $c^{\\text{new}}_{n-k}$ 来计算实际变化。然后 $\\Delta c_{\\text{act}} = c^{\\text{new}}_{n-k} - c_{n-k}$。\n7.  **计算误差和条件数**：\n    a. 相对线性化误差计算为 $\\mathrm{err}_{\\text{rel}} = \\frac{\\left|\\Delta c_{\\text{act}} - \\Delta c_{\\text{pred}}\\right|}{\\left|\\Delta c_{\\text{pred}}\\right| + \\eta}$，其中 $\\eta=10^{-300}$ 用于防止除以零。\n    b. 单参数相对条件数为 $\\kappa_{j^\\star} = \\left|\\frac{\\lambda_{j^\\star}}{c_{n-k}}\\right| \\left|\\frac{\\partial c_{n-k}}{\\partial \\lambda_{j^\\star}}\\right|$。\n8.  **条件数 ($\\kappa$) 的解释**：相对条件数 $\\kappa_{j^\\star}$ 衡量输出 ($c_{n-k}$) 对输入 ($\\lambda_{j^\\star}$) 相对扰动的敏感性。一个大的 $\\kappa$ 值表示一个病态问题，其中输入特征值的微小相对误差（例如，来自浮点表示）可能会被放大成计算出的系数的巨大相对误差。由于 $\\lambda_{j^\\star}$ 的浮点舍入导致的 $c_{n-k}$ 相对误差的先验估计近似为 $\\kappa_{j^\\star} \\cdot u$，其中 $u = 2^{-53}$ 是 IEEE 754 双精度的机器 epsilon。\n\n这个结构化的步骤构成了所需程序的基础。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_experiment(eigs, k, delta_mag):\n    \"\"\"\n    Performs the numerical experiment for a single test case.\n\n    Args:\n        eigs (np.ndarray): The array of eigenvalues.\n        k (int): The index for the coefficient c_{n-k} (1-based).\n        delta_mag (float): The magnitude of the perturbation.\n\n    Returns:\n        list: A list containing [j_star, delta_c_pred, delta_c_act, err_rel, kappa_j_star].\n    \"\"\"\n    n = len(eigs)\n    eta = 1e-300\n\n    # Step: Compute original coefficient c_{n-k}\n    # np.poly returns coefficients [c_n, c_{n-1}, ..., c_0] where c_n=1.\n    # The coefficient c_{n-k} is at index k.\n    coeffs_orig = np.poly(eigs)\n    c_nk_orig = coeffs_orig[k]\n\n    # Step: Compute all partial derivatives\n    derivs = np.zeros(n)\n    for j in range(n):\n        # Create the set of n-1 eigenvalues excluding eigs[j]\n        eigs_j = np.delete(eigs, j)\n        \n        # This polynomial is of degree n-1. Coefficients are [c'_{n-1}, ..., c'_0].\n        # The coefficient of lambda^{n-k} is at index (n-1) - (n-k) = k-1.\n        coeffs_j = np.poly(eigs_j)\n        \n        # Check for k=1 up to k=n.\n        # If k=1, k-1=0, coeffs_j[0] is the leading coeff (1). deriv = -1. Correct.\n        # If k=n, k-1=n-1, coeffs_j[n-1] is the constant term. Correct.\n        if k-1  0 or k-1 >= len(coeffs_j):\n            c_prime_nk = 0.0\n        else:\n            c_prime_nk = coeffs_j[k-1]\n        \n        derivs[j] = -c_prime_nk\n\n    # Step: Identify j* that maximizes the absolute derivative\n    j_star = int(np.argmax(np.abs(derivs)))\n    max_deriv = derivs[j_star]\n    lambda_j_star = eigs[j_star]\n\n    # Step: Choose signed perturbation\n    # np.sign(0) is 0, which is the correct behavior if max_deriv is 0.\n    perturb_sign = np.sign(max_deriv)\n    delta = perturb_sign * delta_mag\n\n    # Step: Predict change via linearization\n    delta_c_pred = max_deriv * delta\n\n    # Step: Compute actual change\n    eigs_perturbed = eigs.copy()\n    eigs_perturbed[j_star] += delta\n    coeffs_perturbed = np.poly(eigs_perturbed)\n    c_nk_new = coeffs_perturbed[k]\n    delta_c_act = c_nk_new - c_nk_orig\n\n    # Step: Compute relative linearization error\n    err_rel = np.abs(delta_c_act - delta_c_pred) / (np.abs(delta_c_pred) + eta)\n\n    # Step: Compute relative condition number\n    if c_nk_orig == 0.0:\n        # If the original coefficient is zero, the relative condition number is\n        # arguably infinite if numerator is non-zero, or undefined.\n        kappa_j_star = np.inf if lambda_j_star != 0 and max_deriv != 0 else 0.0\n    else:\n        kappa_j_star = np.abs(lambda_j_star / c_nk_orig) * np.abs(max_deriv)\n    \n    return [j_star, delta_c_pred, delta_c_act, err_rel, kappa_j_star]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test 1: General case\n        {'eigs': [1, 2, 3, 4, 5], 'k': 3, 'delta': 1e-8},\n        # Test 2: Near-cancellation/clustered eigenvalues\n        {'eigs': [1, -1, 1 + 1e-8, -1 - 1e-8, 2, -2], 'k': 3, 'delta': 1e-8},\n        # Test 3: Large magnitudes, k=n\n        {'eigs': [10, 9, 8, 7, 6, 5], 'k': 6, 'delta': 1e-12},\n        # Test 4: Repeated and zero eigenvalues\n        {'eigs': [0, 0, 1, 2], 'k': 2, 'delta': 1e-6},\n    ]\n\n    results_str = []\n    for case in test_cases:\n        eigs_np = np.array(case['eigs'], dtype=float)\n        result = run_experiment(eigs_np, case['k'], case['delta'])\n        # Format the list into a string representation for the final output\n        results_str.append(str(result))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}