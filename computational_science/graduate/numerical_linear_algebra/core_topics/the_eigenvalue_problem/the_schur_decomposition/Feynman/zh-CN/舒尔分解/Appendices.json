{
    "hands_on_practices": [
        {
            "introduction": "矩阵函数，特别是矩阵指数$e^A$，在求解线性微分方程系统方面起着核心作用。虽然对角化为计算矩阵函数提供了一条直接路径，但并非所有矩阵都可以对角化。本练习  介绍了一种更通用、数值上更稳健的方法，即利用实Schur分解来计算矩阵指数，突显了Schur分解在基本应用中的强大功能。",
            "id": "3596233",
            "problem": "设 $A \\in \\mathbb{R}^{3 \\times 3}$ 为\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  1 \\\\\n-1  0  0 \\\\\n0  0  2\n\\end{pmatrix}.\n$$\n使用实舒尔型，通过计算实舒尔因子 $T$ 的 $1 \\times 1$ 和 $2 \\times 2$ 分块的指数，并组合成 $\\,\\exp(A) = Q \\exp(T) Q^{*}\\,$，来计算矩阵指数 $\\,\\exp(A)\\,$。在您的推导中，请从矩阵指数的定义、相似变换和分块上三角矩阵的基本性质出发，并为一个实准上三角矩阵 $T$ 证明 $\\,\\exp(T)\\,$ 的结构。作为一个高级的数值考虑，请讨论在有限精度运算中，缩放平方法如何提高此计算的准确性和稳定性，包括如何选择缩放参数以及平方的作用。\n\n请将 $\\,\\exp(A)\\,$ 的 $(1,3)$ 元作为最终结果，以封闭形式的解析表达式报告。不要近似或四舍五入。所有三角函数的参数都以弧度解释。",
            "solution": "首先验证问题，以确保其科学上可靠、适定且客观。\n\n### 第一步：提取已知条件\n- 矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 由 $A = \\begin{pmatrix} 0  1  1 \\\\ -1  0  0 \\\\ 0  0  2 \\end{pmatrix}$ 给出。\n- 任务是计算矩阵指数 $\\exp(A)$。\n- 指定的方法是使用实舒尔型 $A = Q T Q^*$，通过计算其分块的指数得到 $\\exp(T)$，然后求得 $\\exp(A) = Q \\exp(T) Q^*$。\n- 推导必须从矩阵指数的定义开始，并证明分块矩阵计算的合理性。\n- 需要一个高级的数值考虑：关于缩放平方法的讨论。\n- 需要报告的最终结果是 $\\exp(A)$ 的 $(1,3)$ 元，以封闭形式的解析表达式表示。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据：** 该问题基于数值线性代数的基本概念：矩阵指数和实舒尔分解。这些是标准的、完善的课题。所概述的程序是计算矩阵指数的公认算法。\n- **适定性：** 矩阵 $A$ 已明确给出。任何实矩阵的实舒尔分解都存在。矩阵指数是唯一定义的。问题要求一个具体的、可计算的量。问题是自洽且明确的。\n- **客观性：** 问题以精确的数学语言陈述，没有任何主观性或意见。\n\n### 第三步：结论与行动\n该问题是有效的，因为它在数学上是可靠的、适定的且客观的。将提供一个完整的解答。\n\n### 解题推导\n\n一个方阵 $M$ 的矩阵指数由幂级数定义\n$$\n\\exp(M) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} M^k.\n$$\n矩阵指数的一个基本性质与相似变换有关。如果一个矩阵 $A$ 可以写成 $A = S B S^{-1}$，其中 $S$ 是某个可逆矩阵，那么它的幂由 $A^k = (S B S^{-1})^k = S B^k S^{-1}$ 给出。将此代入幂级数定义，得到\n$$\n\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} (S B^k S^{-1}) = S \\left( \\sum_{k=0}^{\\infty} \\frac{1}{k!} B^k \\right) S^{-1} = S \\exp(B) S^{-1}.\n$$\n实舒尔分解定理指出，对于任何实矩阵 $A \\in \\mathbb{R}^{n \\times n}$，存在一个实正交矩阵 $Q$（即 $Q^T Q = I$，因此 $Q^{-1} = Q^T = Q^*$）和一个实准上三角矩阵 $T$，使得 $A = Q T Q^T$。矩阵 $T$ 是分块上三角矩阵，其 $1 \\times 1$ 的对角块对应于实特征值，$2 \\times 2$ 的对角块的特征值是复共轭对。\n使用上述性质，我们有 $\\exp(A) = Q \\exp(T) Q^T$。因此，我们必须计算 $\\exp(T)$。\n\n设 $T$ 是一个分块上三角矩阵，例如，以 $2 \\times 2$ 分块形式表示：\n$$\nT = \\begin{pmatrix} T_{11}  T_{12} \\\\ 0  T_{22} \\end{pmatrix}.\n$$\n$T$ 的幂保持这种分块上三角结构：\n$$\nT^k = \\begin{pmatrix} T_{11}^k  U_k \\\\ 0  T_{22}^k \\end{pmatrix},\n$$\n其中 $U_k$ 是一个更复杂的项。那么 $T$ 的指数是\n$$\n\\exp(T) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} T^k = \\begin{pmatrix} \\sum_{k=0}^{\\infty} \\frac{1}{k!} T_{11}^k  \\sum_{k=0}^{\\infty} \\frac{1}{k!} U_k \\\\ 0  \\sum_{k=0}^{\\infty} \\frac{1}{k!} T_{22}^k \\end{pmatrix} = \\begin{pmatrix} \\exp(T_{11})  U \\\\ 0  \\exp(T_{22}) \\end{pmatrix}.\n$$\n$\\exp(T)$ 的对角块是 $T$ 的对角块的指数。非对角块 $U$ 可以通过求解 $Y(t) = \\exp(tT)$ 的微分方程得到，即 $Y'(t) = T Y(t)$，初始条件为 $Y(0)=I$。对于所示的分块结构，这会导出一个关于 $Y(t)$ 各分块的方程组。非对角块 $Y_{12}(t)$ 满足 $Y'_{12}(t) = T_{11}Y_{12}(t) + T_{12}Y_{22}(t)$，且 $Y_{12}(0)=0$。通过常数变易法得到的解是 $Y_{12}(t) = \\int_0^t \\exp((t-s)T_{11}) T_{12} \\exp(sT_{22}) ds$。那么分块 $U$就是 $Y_{12}(1)$。\n\n现在，我们将此过程应用于给定的矩阵 $A = \\begin{pmatrix} 0  1  1 \\\\ -1  0  0 \\\\ 0  0  2 \\end{pmatrix}$。我们首先求其舒尔分解 $A=QTQ^T$。其特征方程为 $\\det(A-\\lambda I) = (2-\\lambda)(\\lambda^2+1)=0$，得到特征值 $\\lambda_1 = 2$ 和 $\\lambda_{2,3} = \\pm i$。\n矩阵 $A$可以分块为\n$$\nA = \\begin{pmatrix} B  C \\\\ 0  D \\end{pmatrix}, \\quad \\text{其中} \\quad B = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}, \\quad C = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad D = (2).\n$$\n$2 \\times 2$ 分块 $B$ 的特征值是 $\\pm i$，而 $1 \\times 1$ 分块 $D$ 的特征值是 $2$。这种分块结构恰好与实舒尔型的结构相匹配。因此，矩阵 $A$ 本身已经是一个实舒尔型。我们可以选择 $T=A$ 和正交矩阵 $Q=I$。\n因此，我们需要通过计算其分块的指数来计算 $\\exp(A)$。我们有\n$$\nT_{11} = B = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}, \\quad T_{12} = C = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad T_{22} = D = (2).\n$$\n对角块的指数为：\n1.  对于 $T_{22}=(2)$，$\\exp(T_{22}) = \\exp(2) = e^2$。\n2.  对于 $T_{11} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$，我们认出它是旋转的生成元。其指数由公式 $\\exp(t T_{11}) = (\\cos t)I + (\\sin t)T_{11}$ 给出。对于 $t=1$：\n    $$\n    \\exp(T_{11}) = \\begin{pmatrix} \\cos 1  \\sin 1 \\\\ -\\sin 1  \\cos 1 \\end{pmatrix}.\n    $$\n$\\exp(A)$ 的非对角块 $U$ 由 $t=1$ 时的积分公式给出：\n$$\nU = \\int_0^1 \\exp((1-s)T_{11}) T_{12} \\exp(sT_{22}) ds.\n$$\n代入已知量：\n$$\nU = \\int_0^1 \\begin{pmatrix} \\cos(1-s)  \\sin(1-s) \\\\ -\\sin(1-s)  \\cos(1-s) \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} e^{2s} ds = \\int_0^1 \\begin{pmatrix} \\cos(1-s) e^{2s} \\\\ -\\sin(1-s) e^{2s} \\end{pmatrix} ds.\n$$\n我们对每个分量进行积分。令 $u=1-s$，则 $s=1-u$ 且 $ds=-du$。积分限从 $s \\in [0,1]$ 变为 $u \\in [1,0]$。\n第一个分量是：\n$$\n\\int_0^1 \\cos(1-s) e^{2s} ds = \\int_1^0 \\cos(u) e^{2(1-u)} (-du) = e^2 \\int_0^1 e^{-2u} \\cos(u) du.\n$$\n使用标准积分公式 $\\int e^{ax}\\cos(bx)dx = \\frac{e^{ax}}{a^2+b^2}(a\\cos(bx)+b\\sin(bx))$，其中 $a=-2, b=1$：\n$$\ne^2 \\left[ \\frac{e^{-2u}}{(-2)^2+1^2}(-2\\cos u + \\sin u) \\right]_0^1 = \\frac{e^2}{5} \\left[ e^{-2}(-2\\cos 1 + \\sin 1) - e^0(-2\\cos 0 + \\sin 0) \\right] = \\frac{1}{5}(\\sin 1 - 2\\cos 1 + 2e^2).\n$$\n第二个分量是：\n$$\n\\int_0^1 -\\sin(1-s) e^{2s} ds = \\int_1^0 -\\sin(u) e^{2(1-u)} (-du) = -e^2 \\int_0^1 e^{-2u} \\sin(u) du.\n$$\n使用标准积分公式 $\\int e^{ax}\\sin(bx)dx = \\frac{e^{ax}}{a^2+b^2}(a\\sin(bx)-b\\cos(bx))$：\n$$\n-e^2 \\left[ \\frac{e^{-2u}}{5}(-2\\sin u - \\cos u) \\right]_0^1 = -\\frac{e^2}{5} \\left[ e^{-2}(-2\\sin 1 - \\cos 1) - e^0(-2\\sin 0 - \\cos 0) \\right] = \\frac{1}{5}(2\\sin 1 + \\cos 1 - e^2).\n$$\n组合成完整的矩阵 $\\exp(A)$：\n$$\n\\exp(A) = \\begin{pmatrix} \\exp(T_{11})  U \\\\ 0  \\exp(T_{22}) \\end{pmatrix} = \\begin{pmatrix} \\cos 1  \\sin 1  \\frac{1}{5}(\\sin 1 - 2\\cos 1 + 2e^2) \\\\ -\\sin 1  \\cos 1  \\frac{1}{5}(2\\sin 1 + \\cos 1 - e^2) \\\\ 0  0  e^2 \\end{pmatrix}.\n$$\n问题要求该矩阵的 $(1,3)$ 元。\n$$\n[\\exp(A)]_{1,3} = \\frac{1}{5} (\\sin 1 - 2\\cos 1 + 2e^2).\n$$\n\n### 关于缩放平方法的讨论\n如果矩阵 $A$ 的范数很大，在有限精度运算中，通过其幂级数 $\\exp(A) = \\sum_{k=0}^{\\infty} A^k/k!$ 计算矩阵指数可能在数值上是不稳定的。大的中间项 $A^k/k!$ 在求和时可能导致灾难性抵消。“缩放平方法”缓解了这个问题。它基于恒等式 $\\exp(A) = (\\exp(A/s))^s$。\n\n该方法按以下步骤进行：\n1.  **缩放：** 选择一个缩放因子 $s$，通常是2的幂，$s=2^m$，使得缩放后矩阵的范数 $\\|A/s\\|$ 足够小（例如，小于1）。整数 $m$ 被选为满足此条件的最小非负整数，对于一个选定的范数（例如，$\\|A\\|_{\\infty}/2^m \\le \\theta$，其中 $\\theta$ 是一个预定义的阈值）。较小的范数确保了对 $\\exp(A/s)$ 的近似能够快速收敛。\n2.  **近似：** 计算 $X_0 = \\exp(A/s)$ 的一个近似值。因为自变量 $A/s$ 的范数很小，截断的泰勒级数或者更稳健地，一个中等阶数的帕德近似，可以在截断误差很低的情况下提供高精度。\n3.  **平方：** 通过反复对结果进行平方来逆转缩放。如果 $s = 2^m$，则 $\\exp(A) = (\\exp(A/2^m))^{2^m}$。这通过 $m$ 次矩阵平方来计算：$X_1 = X_0^2$, $X_2 = X_1^2, \\dots, X_m = X_{m-1}^2 = \\exp(A)$。\n\n主要的权衡在于截断误差和舍入误差之间。一个更大的缩放因子 $s$（更大的 $m$）会减小初始近似的截断误差，但需要更多的平方步骤。每一步平方都可能累积舍入误差，这些误差可能会增长，特别是当中介矩阵 $X_j$ 的范数变大时。选择一个最优的缩放参数 $m$ 和帕德近似的阶数对于一个稳健的算法至关重要，并且涉及到平衡这些误差源。缩放平方法构成了大多数用于计算矩阵指数的现代高质量库程序的基础。在舒尔方法的背景下，如果对角块 $\\exp(T_{ii})$ 的范数很大，可以应用此技术来计算它们的指数。对于给定的问题，$\\|T_{11}\\|_{\\infty} = 1$，所以对于这个分块，缩放并非严格必要，解析解更优。",
            "answer": "$$\\boxed{\\frac{1}{5}(\\sin(1) - 2\\cos(1) + 2e^2)}$$"
        },
        {
            "introduction": "一个矩阵的“正规性”（即当$A^*A = AA^*$时）是一个非常理想的性质，因为它保证了存在一组正交的特征向量。然而，许多现实世界中的矩阵并非正规的，其行为可能与它们的特征值所暗示的大相径庭。本实践  探讨了如何利用Schur分解来量化一个矩阵偏离正规性的程度，并通过编写代码将这个理论上的度量与瞬态增长和伪谱等实际数值现象联系起来。",
            "id": "3596183",
            "problem": "您需要编写一个完整、可运行的程序，通过方阵的舒尔型（Schur form）的严格上三角部分来量化其偏离正规性的程度，并将该量与瞬时增长和伪谱特征联系起来。请在数值线性代数和舒尔分解（Schur decomposition）的背景下进行操作。\n\n从以下基本原理开始：\n- 对于任何复方阵 $A \\in \\mathbb{C}^{n \\times n}$，存在一个酉矩阵 $Q \\in \\mathbb{C}^{n \\times n}$ 和一个上三角矩阵 $T \\in \\mathbb{C}^{n \\times n}$，使得 $A = Q T Q^*$，其中 $Q^*$ 表示 $Q$ 的共轭转置。这就是舒尔分解。\n- 弗罗贝尼乌斯范数（Frobenius norm）是酉不变的，即 $\\|A\\|_F = \\|T\\|_F$。\n- 一个矩阵 $A$ 是正规的当且仅当 $A^* A = A A^*$。等价地，$A$ 是正规的当且仅当其舒尔型 $T$ 是一个对角矩阵。\n- $T$ 的对角线元素是 $A$ 的特征值。\n\n您的程序必须：\n1. 对于每个测试矩阵 $A$，计算其舒尔分解 $A = Q T Q^*$ 以及量 $D_F = \\|T - \\operatorname{diag}(T)\\|_F$，其中 $\\operatorname{diag}(T)$ 表示由 $T$ 的对角线元素构成的对角矩阵。这个 $D_F$ 通过 $T$ 的严格上三角部分的弗罗贝尼乌斯范数量化了偏离正规性的程度。\n2. 验证将 $D_F$ 与 $A$ 的特征值相关联的恒等式：报告残差\n   $$\\delta = \\left| \\|T - \\operatorname{diag}(T)\\|_F - \\sqrt{\\|A\\|_F^2 - \\sum_{i=1}^n |\\lambda_i|^2} \\right|,$$\n   其中 $\\{\\lambda_i\\}_{i=1}^n$ 是 $A$ 的特征值。使用 $T$ 的对角线元素作为 $\\{\\lambda_i\\}$。\n3. 通过计算以下公式来量化离散时间瞬时增长：\n   $$M_K = \\max_{1 \\le k \\le K} \\|A^k\\|_2,$$\n   其中 $\\|\\cdot\\|_2$ 表示诱导2-范数（最大奇异值），$K$ 是下面指定的一个固定正整数。\n4. 通过在指定的复数点网格上计算预解范数（resolvent norm）的峰值来量化伪谱特征。对于网格中的每个复数 $z$，计算\n   $$R(z) = \\|(z I - A)^{-1}\\|_2 = \\frac{1}{\\sigma_{\\min}(z I - A)},$$\n   其中 $\\sigma_{\\min}(\\cdot)$ 表示最小奇异值，并报告\n   $$R_{\\max} = \\max_{z \\in \\mathcal{G}} R(z).$$\n\n使用以下测试套件以确保覆盖范围：\n- 测试用例 1（边界正规情况）：$A_1 = 0.9 I_6$，其中 $I_6$ 是 $6 \\times 6$ 的单位矩阵。\n- 测试用例 2（中度非正规）：$A_2 = 0.9 I_6 + 0.2 N$，其中 $N \\in \\mathbb{R}^{6 \\times 6}$ 在第一超对角线上元素为 1，其余元素为 0，即对于 $i = 1,\\dots,5$，$N_{i,i+1} = 1$，否则 $N_{ij} = 0$。\n- 测试用例 3（高度非正规）：$A_3 = 0.9 I_6 + 1.0 N$，其中 $N$ 如上所述。\n\n瞬时增长计算中设置 $K = 50$。对于伪谱网格，使用\n$$\\mathcal{G} = \\{ z = x + i y \\mid x \\in \\{1.00, 1.02, 1.04, \\dots, 1.20\\},\\ y \\in \\{-0.10, 0.00, 0.10\\} \\},$$\n在适用的情况下，角度以弧度为单位（请注意，此问题涉及复数算术，但不需要明确的角度）。\n\n对于每个测试用例，您的程序必须输出一个包含四个浮点数的列表 $[D_F, M_K, R_{\\max}, \\delta]$。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，其中每个元素本身是对应测试用例的四元素列表。例如：\n\"[[D_F1,M_K1,Rmax1,delta1],[D_F2,M_K2,Rmax2,delta2],[D_F3,M_K3,Rmax3,delta3]]\"。\n除此单行外，不应打印任何其他文本。",
            "solution": "对用户的问题进行验证。\n\n### 步骤 1：提取已知信息\n- **任务**：对于给定的方阵 $A$，计算与其非正规性相关的四个量：\n    1. $D_F$：偏离正规性，定义为 $\\|T - \\operatorname{diag}(T)\\|_F$，其中 $A=QTQ^*$ 是舒尔分解。\n    2. $\\delta$：一个用于验证恒等式 $D_F^2 = \\|A\\|_F^2 - \\sum_{i=1}^n |\\lambda_i|^2$ 的残差，定义为 $\\delta = \\left| D_F - \\sqrt{\\|A\\|_F^2 - \\sum_{i=1}^n |\\lambda_i|^2} \\right|$。\n    3. $M_K$：离散时间瞬时增长的度量，定义为 $M_K = \\max_{1 \\le k \\le K} \\|A^k\\|_2$。\n    4. $R_{\\max}$：伪谱幅度的度量，定义为 $R_{\\max} = \\max_{z \\in \\mathcal{G}} \\|(z I - A)^{-1}\\|_2$。\n- **常量和定义**：\n    - $A \\in \\mathbb{C}^{n \\times n}$。\n    - $A = Q T Q^*$ 是舒尔分解，其中 $Q$ 是酉矩阵，$T$ 是上三角矩阵。\n    - $Q^*$ 是 $Q$ 的共轭转置。\n    - $\\operatorname{diag}(T)$ 是与 $T$ 具有相同对角线的对角矩阵。\n    - $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。\n    - $\\|\\cdot\\|_2$ 是诱导2-范数（谱范数）。\n    - $\\lambda_i$ 是 $A$ 的特征值，取自 $T$ 的对角线。\n    - $\\sigma_{\\min}(\\cdot)$ 是最小奇异值。\n    - $K = 50$。\n- **测试矩阵 ($n=6$)**：\n    - $A_1 = 0.9 I_6$。\n    - $A_2 = 0.9 I_6 + 0.2 N$，其中 $N$ 是一个 $6 \\times 6$ 矩阵，其 $N_{i,i+1} = 1$，所有其他项为零。\n    - $A_3 = 0.9 I_6 + 1.0 N$。\n- **伪谱网格**：\n    - $\\mathcal{G} = \\{ z = x + i y \\mid x \\in \\{1.00, 1.02, \\dots, 1.20\\},\\ y \\in \\{-0.10, 0.00, 0.10\\} \\}$。\n- **输出格式**：对于每个测试用例，生成一个列表 $[D_F, M_K, R_{\\max}, \\delta]$。最终输出必须是表示这些列表的列表的单个字符串，例如 `[[...],[...],[...]]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学依据**：该问题是数值线性代数中的一个标准练习，基于舒尔分解及其与正规性、瞬态动力学和伪谱的关系。所有概念和定义（$A=QTQ^*$、矩阵范数、特征值、预解式）都是基础且陈述正确的。$D_F$ 的恒等式是弗罗贝尼乌斯范数酉不变性的一个已知推论。\n2.  **适定性**：该问题是适定的。对于任何给定的方阵 $A$，舒尔分解都存在，并且所有四个量（$D_F, \\delta, M_K, R_{\\max}$）都可以通过标准数值算法唯一计算。参数 $K$ 和网格 $\\mathcal{G}$ 都有明确定义。\n3.  **客观性**：该问题以精确、客观的数学语言陈述，没有任何主观性或歧义。\n4.  **完整性和一致性**：提供了解决问题所需的所有必要信息。定义或约束中没有矛盾。\n5.  **非平凡性**：虽然第一个测试用例是一个简单的正规矩阵，用作基线，但后续用例涉及非平凡的非正规矩阵，它们将展示我们感兴趣的现象（瞬时增长和大的伪谱）。该问题需要实现几个不同的数值计算，这是一项实质性的任务。\n\n### 步骤 3：结论和行动\n该问题是**有效的**，因为它科学合理、适定、客观且完整。它代表了非正规矩阵研究中的一个典型数值实验。将继续进行求解。\n\n---\n\n目标是量化矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的非正规程度，并展示其与两个主要后果的关联：动力学系统中的瞬时增长及其伪谱的范围。我们将为三个测试矩阵中的每一个计算四个度量。\n\n**理论框架**\n\n此分析的基础是**舒尔分解**，它指出任何方阵 $A$ 都可以分解为 $A = Q T Q^*$，其中 $Q$ 是一个酉矩阵 ($Q^*Q = I$)，$T$ 是一个上三角矩阵。$T$ 的对角线元素是 $A$ 的特征值，表示为 $\\{\\lambda_i\\}_{i=1}^n$。如果一个矩阵 $A$ 与其共轭转置交换，即 $A A^* = A^* A$，则定义为**正规**矩阵。一个关键定理指出，一个矩阵是正规的当且仅当其舒尔型 $T$ 是一个对角矩阵。\n\n**1. 偏离正规性 ($D_F$) 与恒等式验证 ($\\delta$)**\n\n$T$ 非对角线的程度提供了 $A$ 偏离正规性的定量度量。我们使用 $T$ 的严格上三角部分的弗罗贝尼乌斯范数来度量这一点。设 $T_{off} = T - \\operatorname{diag}(T)$。那么该量为：\n$$D_F = \\|T_{off}\\|_F = \\|T - \\operatorname{diag}(T)\\|_F$$\n$D_F=0$ 的值意味着 $T$ 是对角矩阵且 $A$ 是正规的。较大的 $D_F$ 表示偏离正规性的程度更大。\n\n一个有用的恒等式将 $D_F$ 与原始矩阵 $A$ 的弗罗贝尼乌斯范数及其特征值联系起来。弗罗贝尼乌斯范数是酉不变的，意味着 $\\|A\\|_F = \\|Q T Q^*\\|_F = \\|T\\|_F$。三角矩阵 $T$ 的弗罗贝尼乌斯范数的平方可以分解为其对角线和非对角线元素平方的和：\n$$\\|T\\|_F^2 = \\sum_{i,j=1}^n |T_{ij}|^2 = \\sum_{i=1}^n |T_{ii}|^2 + \\sum_{i \\neq j} |T_{ij}|^2$$\n认识到 $T_{ii} = \\lambda_i$ 并且 $\\sum_{i \\neq j} |T_{ij}|^2$ 正是 $T$ 的严格上三角部分的弗罗贝尼乌斯范数的平方，即 $D_F^2$，我们有：\n$$\\|A\\|_F^2 = \\|T\\|_F^2 = \\sum_{i=1}^n |\\lambda_i|^2 + D_F^2$$\n重新排列这个公式，可以得到一个用 $A$ 及其特征值表示 $D_F$ 的显式公式：\n$$D_F = \\sqrt{\\|A\\|_F^2 - \\sum_{i=1}^n |\\lambda_i|^2}$$\n问题要求我们计算这个恒等式的残差 $\\delta$ 来验证其数值有效性：\n$$\\delta = \\left| \\|T - \\operatorname{diag}(T)\\|_F - \\sqrt{\\|A\\|_F^2 - \\sum_{i=1}^n |\\lambda_i|^2} \\right|$$\n在精确算术中，$\\delta$ 将为 $0$。在浮点算术中，一个小的非零 $\\delta$ 反映了数值误差的累积。\n\n**2. 瞬时增长 ($M_K$)**\n\n对于形式为 $x_{k+1} = A x_k$ 的离散动力系统，状态向量的范数演化为 $\\|x_k\\| = \\|A^k x_0\\|$。当 $k \\to \\infty$ 时，$\\|A^k\\|$ 的行为由谱半径 $\\rho(A) = \\max_i |\\lambda_i|$ 决定。如果 $\\rho(A)  1$，则 $\\|A^k\\| \\to 0$。然而，对于非正规矩阵，范数 $\\|A^k\\|$ 可能会在最终衰减之前，在较小的 $k$ 值时经历显著增长。这被称为**瞬时增长**。对于一个谱半径 $\\rho(A)  1$ 的正规矩阵，我们有 $\\|A^k\\|_2 = (\\rho(A))^k$，这是一个严格递减的序列。瞬时增长的存在是非正规性的直接后果。我们通过计算在有限范围 $K$ 内达到的最大范数来量化这一点：\n$$M_K = \\max_{1 \\le k \\le K} \\|A^k\\|_2$$\n其中 $\\|\\cdot\\|_2$ 是谱范数（最大奇异值）。\n\n**3. 伪谱特征 ($R_{\\max}$)**\n\n矩阵 $A$ 的**伪谱**，记为 $\\Lambda_{\\epsilon}(A)$，是复数 $z$ 的集合，这些复数是某个邻近矩阵 $A+E$（其中 $\\|E\\|_2 \\le \\epsilon$）的特征值。一个等价的定义是 $\\Lambda_{\\epsilon}(A) = \\{z \\in \\mathbb{C} \\mid \\|(zI-A)^{-1}\\|_2 \\ge \\epsilon^{-1}\\}$。矩阵 $(zI-A)^{-1}$ 是 $A$在 $z$ 点的**预解式**。\n\n对于正规矩阵，预解范数就是到谱的距离的倒数：$\\|(zI-A)^{-1}\\|_2 = 1/\\text{dist}(z, \\Lambda(A))$。只有当 $z$ 非常接近一个特征值时，范数才会很大。对于非正规矩阵，即使 $z$ 远离任何特征值，预解范数也可能非常大，这表明该矩阵对扰动很敏感。大片的高预解范数区域是高度非正规矩阵的特征。\n\n我们将通过在指定的复数网格 $\\mathcal{G}$ 上计算预解范数的峰值来探究此行为：\n$$R_{\\max} = \\max_{z \\in \\mathcal{G}} \\|(z I - A)^{-1}\\|_2$$\n计算使用恒等式 $\\|(zI-A)^{-1}\\|_2 = 1/\\sigma_{\\min}(zI-A)$，其中 $\\sigma_{\\min}$ 是最小奇异值。在远离谱的网格上出现大的 $R_{\\max}$ 值表示显著的非正规性。\n\n这三个测试用例将说明这三个度量之间的紧密耦合关系：随着非正规性的增加（从 $A_1$ 到 $A_3$），我们预计会看到 $D_F$、$M_K$ 和 $R_{\\max}$ 的相应增加。",
            "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Computes measures of non-normality for a set of test matrices.\n    \"\"\"\n    # Define problem constants\n    n = 6\n    K = 50\n    identity_n = np.identity(n)\n    \n    # Define matrix N (nilpotent, ones on first superdiagonal)\n    N = np.diag(np.ones(n - 1), k=1)\n    \n    # Define the test cases\n    test_cases = [\n        0.9 * identity_n,                     # Case 1: A1 (normal)\n        0.9 * identity_n + 0.2 * N,           # Case 2: A2 (moderately nonnormal)\n        0.9 * identity_n + 1.0 * N,           # Case 3: A3 (highly nonnormal)\n    ]\n\n    # Define the pseudospectral grid G\n    x_grid = np.linspace(1.0, 1.2, 11)\n    y_grid = np.array([-0.10, 0.00, 0.10])\n    G_grid = [x + 1j*y for x in x_grid for y in y_grid]\n\n    all_results = []\n    \n    for A in test_cases:\n        # 1. Compute D_F: Departure from normality\n        T, _ = scipy.linalg.schur(A, output='complex')\n        diag_T = np.diag(np.diag(T))\n        T_off = T - diag_T\n        D_F = np.linalg.norm(T_off, 'fro')\n\n        # 2. Verify identity and compute residual delta\n        norm_A_F_sq = np.linalg.norm(A, 'fro')**2\n        lambdas = np.diag(T)\n        sum_lambda_sq = np.sum(np.abs(lambdas)**2)\n        \n        # Handle potential floating point inaccuracies where norm_A_F_sq  sum_lambda_sq\n        val_under_sqrt = norm_A_F_sq - sum_lambda_sq\n        if val_under_sqrt  0:\n             val_under_sqrt = 0\n\n        identity_rhs = np.sqrt(val_under_sqrt)\n        delta = np.abs(D_F - identity_rhs)\n\n        # 3. Quantify transient growth M_K\n        M_K = 0.0\n        A_power_k = np.identity(n)\n        for _ in range(K):\n            A_power_k = A_power_k @ A\n            norm_k = np.linalg.norm(A_power_k, 2)\n            if norm_k > M_K:\n                M_K = norm_k\n\n        # 4. Quantify pseudospectral peak R_max\n        R_max = 0.0\n        for z in G_grid:\n            # Compute resolvent norm as 1 / sigma_min(zI - A)\n            zI_minus_A = z * identity_n - A\n            s_min = np.linalg.svd(zI_minus_A, compute_uv=False)[-1]\n            resolvent_norm = 1.0 / s_min if s_min > 0 else np.inf\n            if resolvent_norm > R_max:\n                R_max = resolvent_norm\n        \n        # Store results for this case\n        all_results.append([D_F, M_K, R_max, delta])\n\n    # Format the final output string to remove spaces for exact match\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在许多科学和工程应用中，矩阵不是静态的，而是会随着时间的推移或模型的调整而发生微小变化。在这种情况下，每次都从头重新计算完整的Schur分解是极其低效的。本高级练习  将引导您设计一种更智能的算法，以在矩阵经历秩为1的更新后，高效地更新其Schur分解，这引入了在计算科学中至关重要的在精度和计算成本之间进行权衡的概念。",
            "id": "3596205",
            "problem": "给定一个方阵 $A \\in \\mathbb{C}^{n \\times n}$ 及其 Schur 分解 $A = Q T Q^{*}$，其中 $Q$ 是酉矩阵，$T$ 是上三角矩阵（复 Schur 型），考虑一个秩-1 扰动 $s \\, u v^{*}$，其中 $u, v \\in \\mathbb{C}^{n}$ 且 $s \\in \\{+1,-1\\}$。仅从 Schur 分解、酉相似性和三角矩阵的一阶微扰理论的定义出发，您必须设计、实现并评估一个实用的秩-1 更新方案，为受扰矩阵 $A' = A + s \\, u v^{*}$ 生成一个近似的更新后 Schur 对 $(Q', T')$。您的设计必须从以下基本事实出发：\n\n- 对于任意方阵 $A \\in \\mathbb{C}^{n \\times n}$，存在一个酉矩阵 $Q \\in \\mathbb{C}^{n \\times n}$，使得 $Q^{*} A Q = T$ 成立，其中 $T$ 是上三角矩阵（复 Schur 型）。\n- 对于任意酉矩阵 $Q$，酉相似性保持谱不变：$Q^{*} A Q$ 和 $A$ 具有相同的特征值。\n- 如果 $A = Q T Q^{*}$ 且 $A' = A + s \\, u v^{*}$，那么在 Schur 基下，$Q^{*} A' Q = T + s \\, x y^{*}$，其中 $x = Q^{*} u$ 且 $y = Q^{*} v$。\n\n您的任务是完成以下所有内容：\n\n- 提出一种算法，在给定 $(Q,T)$ 和 $(u,v,s)$ 的情况下，通过在 Schur 基中进行运算，为 $A' = A + s \\, u v^{*}$ 生成一个近似的更新后 $(Q',T')$。该算法必须：\n  - 计算 $x = Q^{*} u$ 和 $y = Q^{*} v$，构成 $S = T + s \\, x y^{*}$。\n  - 基于从上三角矩阵的一阶微扰分析中导出的一个有原则的、尺度感知的准则，决定是接受近似 $(Q',T') = (Q,S)$（这对 $A'$ 是精确的，但不一定是三角矩阵），还是通过酉相似变换 $S = Z R Z^{*}$ 对 $S$ 进行完全的重新三角化，以获得 $(Q',T') = (Q Z, R)$。\n  - 您的接受准则必须仅使用从 $T$ 和 $S$ 中可获得的量来表示，并且它必须依赖于 $S$ 的严格下三角部分的大小与 $T$ 对角线分离度度量的相对关系。具体来说，定义分离度\n    $$ \\operatorname{sep}(T) = \\min_{1 \\le i  j \\le n} \\left| T_{j j} - T_{i i} \\right|, $$\n    约定当 $n = 1$ 时 $\\operatorname{sep}(T) = +\\infty$。\n    令 $L = \\operatorname{tril}(S,-1)$ 表示 $S$ 的严格下三角部分。使用以下形式的接受准则\n    $$ \\lVert L \\rVert_{\\mathrm{F}} \\le \\kappa \\, \\operatorname{sep}(T), $$\n    其中 $\\kappa$ 是用户选择的非负标量，$\\lVert \\cdot \\rVert_{\\mathrm{F}}$ 表示 Frobenius 范数。如果不等式成立，则设 $(Q',T') = (Q,S)$；否则，计算复 Schur 分解 $S = Z R Z^{*}$ 并设 $(Q',T') = (Q Z,R)$。\n- 使用 $\\kappa = 10^{-2}$ 的选择来实现上述算法。\n- 对于下面的每个测试用例，报告以下五个标量诊断值：\n  - Frobenius 范数残差\n    $$ r = \\left\\lVert Q' T' Q'^{*} - \\left( A + s \\, u v^{*} \\right) \\right\\rVert_{\\mathrm{F}}. $$\n  - $Q'$ 的正交性误差\n    $$ o = \\left\\lVert Q'^{*} Q' - I \\right\\rVert_{\\mathrm{F}}. $$\n  - $T'$ 的三角性比率\n    $$ \\tau = \\frac{\\left\\lVert \\operatorname{tril}(T',-1) \\right\\rVert_{\\mathrm{F}}}{\\max\\left(\\left\\lVert T' \\right\\rVert_{\\mathrm{F}}, \\epsilon\\right)}, $$\n    其中 $\\epsilon = 10^{-300}$ 是一个微小的正标量，用于在退化情况下防止除以零。\n  - 尺度感知指标\n    $$ \\rho = \\frac{\\left\\lVert \\operatorname{tril}(S,-1) \\right\\rVert_{\\mathrm{F}}}{\\max\\left(\\operatorname{sep}(T), \\epsilon\\right)}. $$\n  - 接受标志 $a$，如果接受近似 $(Q',T') = (Q,S)$（未执行重新三角化），则定义为 $a=1$，否则为 $a=0$。\n- 您的程序必须通过复 Schur 分解从 $A$ 内部计算 $(Q,T)$，并且必须完全按照所述实现上述决策和更新逻辑。不允许随机化。\n\n测试套件。使用以下四个确定性测试用例，每个用例由 $(A, u, v, s)$ 指定：\n\n- 测试用例 1（对角线元素分离良好的三角矩阵 $A$ 上的小更新）：\n  - $A_{1} = \\begin{bmatrix}\n  1.0  2 \\times 10^{-3}  0.0 \\\\\n  0.0  2.0  3 \\times 10^{-3} \\\\\n  0.0  0.0  3.0\n  \\end{bmatrix}$,\n  - $u_{1} = \\begin{bmatrix} 1 \\times 10^{-10} \\\\ -2 \\times 10^{-10} \\\\ 3 \\times 10^{-10} \\end{bmatrix}$,\n  - $v_{1} = \\begin{bmatrix} 4 \\times 10^{-10} \\\\ -5 \\times 10^{-10} \\\\ 6 \\times 10^{-10} \\end{bmatrix}$,\n  - $s_{1} = +1$。\n- 测试用例 2（特征值分离良好的非三角矩阵 $A$ 上的中等更新）：\n  - $A_{2} = \\begin{bmatrix}\n  0.0  1.0  0.2 \\\\\n  -1.0  0.1  0.3 \\\\\n  0.0  -0.5  0.2\n  \\end{bmatrix}$,\n  - $u_{2} = \\begin{bmatrix} 1 \\times 10^{-4} \\\\ 2 \\times 10^{-4} \\\\ -1 \\times 10^{-4} \\end{bmatrix}$,\n  - $v_{2} = \\begin{bmatrix} -2 \\times 10^{-4} \\\\ 1 \\times 10^{-4} \\\\ 3 \\times 10^{-4} \\end{bmatrix}$,\n  - $s_{2} = +1$。\n- 测试用例 3（特征值接近重合；更新相对于分离度较大）：\n  - $A_{3} = \\begin{bmatrix}\n  1.0  1 \\times 10^{-6}  0.0 \\\\\n  0.0  1.0 + 10^{-8}  1 \\times 10^{-6} \\\\\n  0.0  0.0  3.0\n  \\end{bmatrix}$,\n  - $u_{3} = \\begin{bmatrix} 1 \\times 10^{-4} \\\\ -1 \\times 10^{-4} \\\\ 0.0 \\end{bmatrix}$,\n  - $v_{3} = \\begin{bmatrix} 1 \\times 10^{-4} \\\\ 1 \\times 10^{-4} \\\\ 0.0 \\end{bmatrix}$,\n  - $s_{3} = +1$。\n- 测试用例 4（对一个 $2 \\times 2$ 三角矩阵 $A$ 进行降秩更新）：\n  - $A_{4} = \\begin{bmatrix}\n  2.0  0.5 \\\\\n  0.0  2.5\n  \\end{bmatrix}$,\n  - $u_{4} = \\begin{bmatrix} 1 \\times 10^{-3} \\\\ -1 \\times 10^{-3} \\end{bmatrix}$,\n  - $v_{4} = \\begin{bmatrix} -1 \\times 10^{-3} \\\\ 2 \\times 10^{-3} \\end{bmatrix}$,\n  - $s_{4} = -1$。\n\n角度单位不适用。不涉及物理单位。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例贡献一个包含五个数字 $[r, o, \\tau, \\rho, a]$ 的列表，且顺序如此，总输出是这些列表的列表，例如 $[[r_{1},o_{1},\\tau_{1},\\rho_{1},a_{1}],[r_{2},o_{2},\\tau_{2},\\rho_{2},a_{2}],\\ldots]$。所有浮点数量必须以标准十进制或科学记数法打印；接受标志 $a$ 必须打印为整数 $0$ 或 $1$。",
            "solution": "任务是为复 Schur 分解设计、实现并评估一个秩-1 更新算法。给定矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的 Schur 分解 $A = Q T Q^{*}$，我们寻求受扰矩阵 $A' = A + s \\, u v^{*}$ 的一个近似 Schur 分解 $(Q', T')$，其中 $u, v \\in \\mathbb{C}^{n}$ 且 $s \\in \\{+1, -1\\}$。\n\n该算法的设计始于酉相似性和微扰理论的基本原理。\n\n首先，我们将扰动转换到由酉矩阵 $Q$ 的列定义的 Schur 基中。受扰矩阵 $A'$ 可以通过酉相似变换在此基中表示：\n$$ Q^{*} A' Q = Q^{*} (A + s \\, u v^{*}) Q $$\n利用矩阵乘法的性质以及 $Q^{*}Q = I$ 这一事实，此表达式可简化为：\n$$ Q^{*} A Q + s (Q^{*} u) (v^{*} Q) = T + s (Q^{*} u) (Q^{*} v)^{*} $$\n我们定义变换后的向量 $x = Q^{*} u$ 和 $y = Q^{*} v$。表达式于是变为：\n$$ Q^{*} A' Q = T + s \\, x y^{*} $$\n我们将这个中间矩阵表示为 $S = T + s \\, x y^{*}$。方程 $A' = Q S Q^{*}$ 是 $A'$ 的一个精确表示，并且由于 $Q$ 是酉矩阵，$A'$ 的特征值与 $S$ 的特征值相同。然而，$S$ 是一个上三角矩阵 $T$ 和一个秩-1 矩阵 $s \\, x y^{*}$ 的和，因此不能保证其自身是上三角矩阵。这个秩-1 项在 $S$ 的严格下三角部分引入了“填充”。\n\n这带来了一个根本性的权衡，导致算法有两种可能的路径：\n\n路径 1：接受近似\n我们可以选择接受对 $(Q, S)$ 作为更新后的 Schur 分解。我们设置 $Q' = Q$ 和 $T' = S$。\n- 优点：这在计算上很廉价，仅需要两次矩阵-向量乘法来求得 $x$ 和 $y$，以及一次外积来形成 $S$。\n- 缺点：得到的矩阵 $T' = S$ 通常不是上三角矩阵。因此，$(Q', T')$ 不是一个真正的 Schur 分解，而是一个放宽了三角性条件的近似。尽管如此，等式 $A' = Q' T' (Q')^{*}$ 在机器精度下是成立的。“误差”纯粹是结构性的。\n\n路径 2：完全重新三角化\n为了恢复三角结构，我们可以计算中间矩阵 $S$ 的 Schur 分解。设该分解为 $S = Z R Z^{*}$，其中 $Z$ 是酉矩阵，$R$ 是上三角矩阵。将此代入 $A'$ 的表达式中，我们得到：\n$$ A' = Q S Q^{*} = Q (Z R Z^{*}) Q^{*} = (Q Z) R (Z^{*} Q^{*}) = (Q Z) R (Q Z)^{*} $$\n然后我们定义更新后的 Schur 对为 $Q' = QZ$ 和 $T' = R$。\n- 优点：这为 $A'$ 产生了一个真正的 Schur 分解，因为 $Q'$（酉矩阵的乘积）是酉矩阵，而 $T'$ 是上三角矩阵。\n- 缺点：这在计算上是昂贵的，因为它需要对 $n \\times n$ 矩阵 $S$ 进行一次完整的 Schur 分解。\n\n问题的核心是建立一个有原则的准则来在这两条路径之间做出选择。特征值和不变子空间的一阶微扰理论提供了必要的见解。不变子空间（进而 Schur 向量）在扰动下的稳定性与相应特征值与谱中其余部分的“分离度”成反比。对于一个三角矩阵 $T$，其特征值是其对角元素 $T_{ii}$。这些特征值的分离度定义为：\n$$ \\operatorname{sep}(T) = \\min_{1 \\le i  j \\le n} |T_{jj} - T_{ii}| $$\n一个小的 $\\operatorname{sep}(T)$ 表明至少有两个特征值很接近，这意味着 Schur 基对扰动很敏感。一个大的 $\\operatorname{sep}(T)$ 则表明基更为稳定。\n\n对 $T$ 三角结构的扰动是秩-1 项 $s \\, x y^{*}$。此扰动中破坏上三角结构的部分由 $S$ 的严格下三角部分捕获，我们将其表示为 $L = \\operatorname{tril}(S, -1)$。一个小的 $\\lVert L \\rVert_{\\mathrm{F}}$ 表明 $S$ “接近”于上三角矩阵。\n\n所提出的决策准则 $\\lVert L \\rVert_{\\mathrm{F}} \\le \\kappa \\, \\operatorname{sep}(T)$ 巧妙地结合了这些思想。它指出，如果扰动中破坏结构的分量的大小 $\\lVert L \\rVert_{\\mathrm{F}}$ 相对于原始问题的内在谱稳定性 $\\operatorname{sep}(T)$ 而言较小，我们应该接受近似（路径 1）。标量 $\\kappa$ 是一个用户定义的容差参数，用于控制结构精确性与计算成本之间的权衡。\n\n完整的算法如下：\n1.  给定 $A$ 的 Schur 对 $(Q, T)$、扰动向量 $u, v$ 和符号 $s$。\n2.  计算 $x = Q^{*} u$ 和 $y = Q^{*} v$。\n3.  形成中间矩阵 $S = T + s \\, x y^{*}$。\n4.  计算 $S$ 的严格下三角部分 $L = \\operatorname{tril}(S, -1)$。\n5.  计算 Frobenius 范数 $\\lVert L \\rVert_{\\mathrm{F}}$。\n6.  计算对角分离度 $\\operatorname{sep}(T)$。\n7.  如果 $\\lVert L \\rVert_{\\mathrm{F}} \\le \\kappa \\, \\operatorname{sep}(T)$（其中 $\\kappa = 10^{-2}$），则设 $(Q', T') = (Q, S)$ 且接受标志 $a=1$。\n8.  否则，计算 Schur 分解 $S = Z R Z^{*}$ 并设 $(Q', T') = (Q Z, R)$ 且接受标志 $a=0$。\n9.  计算所需的诊断度量 $(r, o, \\tau, \\rho, a)$ 以评估结果。\n\n所要求的诊断指标用于量化算法的性能：\n-   $r = \\left\\lVert Q' T' (Q')^{*} - A' \\right\\rVert_{\\mathrm{F}}$：残差范数。对于正确的实现，在路径 1 和路径 2 中，此值都应接近机器精度，因为等式 $A' = Q' T' (Q')^{*}$ 在代数上是保持的。\n-   $o = \\left\\lVert (Q')^{*} Q' - I \\right\\rVert_{\\mathrm{F}}$：正交性误差。在两条路径中 $Q'$ 都保持为酉矩阵，因此此值也应接近机器精度。\n-   $\\tau = \\frac{\\left\\lVert \\operatorname{tril}(T',-1) \\right\\rVert_{\\mathrm{F}}}{\\max(\\left\\lVert T' \\right\\rVert_{\\mathrm{F}}, \\epsilon)}$：三角性比率。这是关键的结构度量。对于路径 1，它将为非零值；对于路径 2，它将接近零。\n-   $\\rho = \\frac{\\left\\lVert \\operatorname{tril}(S,-1) \\right\\rVert_{\\mathrm{F}}}{\\max(\\operatorname{sep}(T), \\epsilon)}$：尺度感知指标。这是决策准则左侧的值，经 $\\operatorname{sep}(T)$ 归一化。决策等价于检查是否 $\\rho \\le \\kappa$。\n-   $a \\in \\{0, 1\\}$：接受标志，指示采取了哪条路径。\n\n该算法提供了一种实用且具有计算意识的 Schur 分解更新方法，在严格执行数学结构与计算成本之间取得了平衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import schur\n\ndef solve():\n    \"\"\"\n    Implements and evaluates a rank-1 update scheme for the complex Schur decomposition.\n    \"\"\"\n    # Define the small positive scalar to prevent division by zero.\n    epsilon = 1e-300\n    kappa = 1e-2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1.0, 2e-3, 0.0],\n                [0.0, 2.0, 3e-3],\n                [0.0, 0.0, 3.0]\n            ], dtype=np.complex128),\n            \"u\": np.array([1e-10, -2e-10, 3e-10], dtype=np.complex128),\n            \"v\": np.array([4e-10, -5e-10, 6e-10], dtype=np.complex128),\n            \"s\": 1.0\n        },\n        {\n            \"A\": np.array([\n                [0.0, 1.0, 0.2],\n                [-1.0, 0.1, 0.3],\n                [0.0, -0.5, 0.2]\n            ], dtype=np.complex128),\n            \"u\": np.array([1e-4, 2e-4, -1e-4], dtype=np.complex128),\n            \"v\": np.array([-2e-4, 1e-4, 3e-4], dtype=np.complex128),\n            \"s\": 1.0\n        },\n        {\n            \"A\": np.array([\n                [1.0, 1e-6, 0.0],\n                [0.0, 1.0 + 1e-8, 1e-6],\n                [0.0, 0.0, 3.0]\n            ], dtype=np.complex128),\n            \"u\": np.array([1e-4, -1e-4, 0.0], dtype=np.complex128),\n            \"v\": np.array([1e-4, 1e-4, 0.0], dtype=np.complex128),\n            \"s\": 1.0\n        },\n        {\n            \"A\": np.array([\n                [2.0, 0.5],\n                [0.0, 2.5]\n            ], dtype=np.complex128),\n            \"u\": np.array([1e-3, -1e-3], dtype=np.complex128),\n            \"v\": np.array([-1e-3, 2e-3], dtype=np.complex128),\n            \"s\": -1.0\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        A, u, v, s = case[\"A\"], case[\"u\"], case[\"v\"], case[\"s\"]\n        n = A.shape[0]\n\n        # Compute the initial Schur decomposition of A.\n        # We need the complex Schur form, which scipy.linalg.schur provides by default\n        # when the input is complex, or when output='complex'.\n        T, Q = schur(A, output='complex')\n\n        # Compute x and y in the Schur basis.\n        # Q* is the conjugate transpose of Q.\n        x = Q.conj().T @ u\n        y = Q.conj().T @ v\n\n        # Form the intermediate matrix S.\n        # np.outer(x, y.conj()) computes x y*.\n        S = T + s * np.outer(x, y.conj())\n\n        # Calculate a scale-aware indicator for the decision.\n        # 1. Compute sep(T)\n        diag_T = np.diag(T)\n        if n == 1:\n            sep_T = np.inf\n        else:\n            # Create a matrix of all pairwise absolute differences of diagonal elements.\n            diffs = np.abs(diag_T[:, np.newaxis] - diag_T)\n            # Find the minimum of the strictly upper triangular part.\n            sep_T = np.min(diffs[np.triu_indices(n, k=1)])\n\n        # 2. Compute the norm of the strictly lower-triangular part of S.\n        L = np.tril(S, k=-1)\n        norm_L = np.linalg.norm(L, 'fro')\n\n        # 3. Compute the indicator rho\n        rho = norm_L / max(sep_T, epsilon)\n        \n        # Make the decision\n        if norm_L = kappa * sep_T:\n            # Accept the approximation (Q, S)\n            Q_prime, T_prime = Q, S\n            a = 1\n        else:\n            # Perform full re-triangularization\n            R, Z = schur(S, output='complex')\n            Q_prime, T_prime = Q @ Z, R\n            a = 0\n\n        # Compute the five diagnostic scalars.\n        A_prime = A + s * np.outer(u, v.conj())\n        \n        # 1. Residual r\n        reconstruction_error = Q_prime @ T_prime @ Q_prime.conj().T - A_prime\n        r = np.linalg.norm(reconstruction_error, 'fro')\n        \n        # 2. Orthogonality error o\n        ortho_error = Q_prime.conj().T @ Q_prime - np.eye(n)\n        o = np.linalg.norm(ortho_error, 'fro')\n        \n        # 3. Triangularity ratio tau\n        norm_tril_T_prime = np.linalg.norm(np.tril(T_prime, k=-1), 'fro')\n        norm_T_prime = np.linalg.norm(T_prime, 'fro')\n        tau = norm_tril_T_prime / max(norm_T_prime, epsilon)\n        \n        # 4. rho is already computed.\n        # 5. a is already computed.\n        \n        all_results.append([r, o, tau, rho, float(a)])\n\n    # Format the final output string.\n    result_str = \"[\" + \",\".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}