{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握车象主元法 (rook pivoting) 的具体机制，没有什么比动手计算更有效了。本练习  将引导你对一个特定的 $8 \\times 8$ 矩阵完成第一面板的因式分解。通过手动执行迭代的主元搜索、应用置换以及计算舒尔补更新，你将对该算法的运算流程建立起一个具体的理解。",
            "id": "3575078",
            "problem": "考虑对矩阵\n$$\nA=\\begin{pmatrix}\n1  & 2  & 0  & 0  & 0  & 0  & 0  & 0\\\\\n5  & 0  & 9  & 0  & 0  & 0  & 0  & 0\\\\\n0  & 6  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 0  & 8  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix}.\n$$\n进行同时包含行置换和列置换的分块高斯消元法（LU分解）。\n在活动子矩阵上使用车象主元法（rook pivoting），即交替进行行搜索和列搜索，以选择一个在其所在行和所在列中绝对值同时达到最大的主元。执行块大小为 $b=3$ 的第一面板分解，这意味着您必须选择并应用三个主元（可能伴随行和列交换）来分解前导面板。严格在带置换的LU分解的标准框架内进行操作：在面板的第 $k$ 步，对第 $k$ 行到第 $n$ 行以及第 $k$ 列到第 $n$ 列进行操作，如果车象主元搜索在位置 $(i,j)$（其中 $i\\geq k$ 且 $j\\geq k$）确定了一个主元，则在计算乘子和执行秩-1更新之前，应用行交换将第 $i$ 行换到第 $k$ 行，并应用列交换将第 $j$ 列换到第 $k$ 列。\n\n完成以下步骤，展示中间矩阵以及由更新产生的精确有理数值：\n\n- 确定在第一面板中应用的行置换和列置换（将它们以每次选择主元时应用的对换乘积形式列出）。\n- 计算前三列中的乘子，这些乘子填充了该面板的$L$因子的严格下三角部分。\n- 形成第三个主元操作后的拖尾子矩阵，即第 $4$ 行到第 $8$ 行和第 $4$ 列到第 $8$ 列的舒尔补，并将其明确写出。\n\n最后，报告在第一面板中选择的三个车象主元的绝对值之积。提供精确值，无需四舍五入。您的最终数值答案必须是这三个绝对值之积，表示为一个单独的实数，不带任何额外评论。",
            "solution": "我们将使用精确有理数算法对给定的 $8 \\times 8$ 矩阵 $A$ 执行 LU 分解的前三个步骤 ($b=3$)。\n\n初始矩阵为：\n$$ A^{(1)} = A = \\begin{pmatrix}\n1  & 2  & 0  & 0  & 0  & 0  & 0  & 0\\\\\n5  & 0  & 9  & 0  & 0  & 0  & 0  & 0\\\\\n0  & 6  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 0  & 8  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n\n该过程包括三个步骤 ($k=1, 2, 3$)。\n\n**步骤1：第一个主元 ($k=1$)**\n\n活动子矩阵是整个矩阵 $A^{(1)}$。我们从左上角元素 $A^{(1)}_{1,1} = 1$ 开始执行车象主元搜索。\n1.  第1行中的最大绝对值是 $|A^{(1)}_{1,2}| = 2$。搜索移至第2列。\n2.  第2列中的最大绝对值是 $|A^{(1)}_{3,2}| = 6$。搜索移至第3行。\n3.  第3行中的最大绝对值是 $|A^{(1)}_{3,2}| = 6$。搜索停留在第2列。\n4.  搜索稳定下来。\n\n第一个主元是 $p_1 = 6$，位于 $(i,j) = (3,2)$。\n为了将该主元移到位置 $(1,1)$，我们应用行置换 $P_1 = (1,3)$ 和列置换 $Q_1 = (1,2)$。\n将这些置换应用于 $A^{(1)}$：\n$$ A_{perm}^{(1)} = P_1 A^{(1)} Q_1 = \\begin{pmatrix}\n6  & 0  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 5  & 9  & 0  & 0  & 0  & 0  & 0\\\\\n2  & 1  & 0  & 0  & 0  & 0  & 0  & 0\\\\\n0  & 0  & 8  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n第一列的乘子计算为 $l_{i1} = A_{perm, i1}^{(1)}/p_1$ (对于 $i > 1$)。对角线下方第一列中唯一的非零元素是 $A_{perm, 31}^{(1)} = 2$。乘子为 $l_{31} = 2/6 = 1/3$。\n秩-1更新影响拖尾子矩阵 $A^{(1)}_{perm}[2:8, 2:8]$。更新公式为 $A_{22} \\leftarrow A_{22} - l_1 u_1^T$，其中 $u_1^T = A_{perm}^{(1)}[1, 2:8] = [0, 0, 3, 0, 0, 0, 0]$。\n外积 $l_1 u_1^T$ 中唯一的非零项对应于 $l_{31} \\cdot u_{14} = (1/3) \\cdot 3 = 1$。这会更新全局位置 $(3,4)$ 处的元素。\n得到的矩阵（乘子存储在第一列中）为：\n$$ A^{(2)} = \\begin{pmatrix}\n6  & 0  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 5  & 9  & 0  & 0  & 0  & 0  & 0\\\\\n1/3  & 1  & 0  & -1  & 0  & 0  & 0  & 0\\\\\n0  & 0  & 8  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n\n**步骤2：第二个主元 ($k=2$)**\n\n活动子矩阵是 $A^{(2)}[2:8, 2:8]$。我们从 $A^{(2)}_{2,2}=5$ 开始搜索主元。\n1.  子矩阵的第一行（全局第2行）中的最大绝对值是 $|A^{(2)}_{2,3}| = 9$。搜索移至子矩阵的第二列（全局第3列）。\n2.  子矩阵的该列中的最大绝对值是 $|A^{(2)}_{2,3}| = 9$。搜索稳定下来。\n\n第二个主元是 $p_2 = 9$，位于全局位置 $(i,j) = (2,3)$。\n为了将其移至位置 $(2,2)$，我们应用 $k=2$ 时的置换。行 $i=2$ 已经是正确的，所以 $P_2 = I$。我们交换列 $j=3$ 和 $k=2$，所以 $Q_2 = (2,3)$。\n将 $Q_2$ 应用于 $A^{(2)}$：\n$$ A_{perm}^{(2)} = A^{(2)} Q_2 = \\begin{pmatrix}\n6  & 0  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 9  & 5  & 0  & 0  & 0  & 0  & 0\\\\\n1/3  & 0  & 1  & -1  & 0  & 0  & 0  & 0\\\\\n0  & 8  & 0  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n第二列的乘子来自 $A_{perm}^{(2)}[3:8, 2]/p_2$。唯一的非零项是 $A_{perm, 42}^{(2)}=8$。乘子为 $l_{42} = 8/9$。\n更新公式为 $A_{33} \\leftarrow A_{33} - l_2 u_2^T$，其中 $u_2^T = A_{perm}^{(2)}[2, 3:8] = [5, 0, 0, 0, 0, 0]$。\n$l_2 u_2^T$ 中唯一的非零项对应于 $l_{42} \\cdot u_{23} = (8/9) \\cdot 5 = 40/9$。这会更新全局位置 $(4,3)$。$A^{(3)}_{4,3} = A_{perm, 43}^{(2)} - 40/9 = 0 - 40/9 = -40/9$。\n矩阵变为：\n$$ A^{(3)} = \\begin{pmatrix}\n6  & 0  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 9  & 5  & 0  & 0  & 0  & 0  & 0\\\\\n1/3  & 0  & 1  & -1  & 0  & 0  & 0  & 0\\\\\n0  & 8/9  & -40/9  & 0  & 4  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n\n**步骤3：第三个主元 ($k=3$)**\n\n活动子矩阵是 $A^{(3)}[3:8, 3:8]$。我们从 $A^{(3)}_{3,3}=1$ 开始搜索主元。\n1.  子矩阵的第一行（全局第3行）中的最大绝对值为 $|-1|=1$，这是一个并列情况。我们可以保持在第一列（全局第3列）。\n2.  子矩阵的该列中的最大绝对值为 $|A^{(3)}_{4,3}| = |-40/9| \\approx 4.44$。搜索移至子矩阵的第二行（全局第4行）。\n3.  子矩阵的该行（全局第4行）中的最大绝对值为 $|-40/9|$，因为 $|-40/9|>|4|$。搜索停留在当前列。\n4.  搜索稳定下来。\n\n第三个主元是 $p_3 = -40/9$，位于全局位置 $(i,j) = (4,3)$。\n为了将其移至位置 $(3,3)$，我们交换行 $i=4$ 和 $k=3$，所以 $P_3=(3,4)$。列 $j=3$ 是正确的，所以 $Q_3=I$。\n将 $P_3$ 应用于 $A^{(3)}$ 会交换第3行和第4行，包括已存储的乘子：\n$$ A_{perm}^{(3)} = P_3 A^{(3)} = \\begin{pmatrix}\n6  & 0  & 0  & 3  & 0  & 0  & 0  & 0\\\\\n0  & 9  & 5  & 0  & 0  & 0  & 0  & 0\\\\\n0  & 8/9  & -40/9  & 0  & 4  & 0  & 0  & 0\\\\\n1/3  & 0  & 1  & -1  & 0  & 0  & 0  & 0\\\\\n0  & 0  & 0  & 7  & 0  & 5  & 0  & 0\\\\\n0  & 0  & 0  & 0  & 6  & 0  & 2  & 0\\\\\n0  & 0  & 0  & 0  & 0  & 7  & 0  & 1\\\\\n0  & 0  & 0  & 0  & 0  & 0  & 8  & 0\n\\end{pmatrix} $$\n乘子为 $l_{i3} = A_{perm, i3}^{(3)}/p_3$ (对于 $i > 3$) 。唯一的非零项是 $A_{perm, 43}^{(3)}=1$。\n乘子为 $l_{43} = 1/(-40/9) = -9/40$。\n更新公式为 $A_{44} \\leftarrow A_{44} - l_3 u_3^T$，其中 $u_3^T = A_{perm}^{(3)}[3, 4:8] = [0, 4, 0, 0, 0]$。\n$l_3 u_3^T$ 中唯一的非零项是 $l_{43} \\cdot u_{35} = (-9/40) \\cdot 4 = -36/40 = -9/10$。这会更新全局位置 $(4,5)$。$A^{(4)}_{4,5} = A_{perm, 45}^{(3)} - (-9/10) = 0 + 9/10 = 9/10$。\n\n**结果摘要**\n\n1.  **行和列置换**：\n    - 步骤1 ($k=1$)：行置换 $P_1=(1,3)$，列置换 $Q_1=(1,2)$。\n    - 步骤2 ($k=2$)：行置换 $P_2=I$ (单位矩阵)，列置换 $Q_2=(2,3)$。\n    - 步骤3 ($k=3$)：行置换 $P_3=(3,4)$，列置换 $Q_3=I$ (单位矩阵)。\n\n2.  **L因子中的乘子**：\n    填充L因子前三列严格下三角部分的乘子（在最终置换后的位置）如下：\n    - 第1列：$l_{41}=1/3$。所有其他 $l_{i1}=0$（对于 $i>1$）。\n    - 第2列：$l_{32}=8/9$。所有其他 $l_{i2}=0$（对于 $i>2$）。\n    - 第3列：$l_{43}=-9/40$。所有其他 $l_{i3}=0$（对于 $i>3$）。\n\n3.  **拖尾子矩阵（舒尔补）**：\n    这是子矩阵 $A^{(4)}[4:8, 4:8]$。根据最终的更新，它为：\n    $$ S = \\begin{pmatrix}\n    -1  & 9/10  & 0  & 0  & 0\\\\\n    7  & 0  & 5  & 0  & 0\\\\\n    0  & 6  & 0  & 2  & 0\\\\\n    0  & 0  & 7  & 0  & 1\\\\\n    0  & 0  & 0  & 8  & 0\n    \\end{pmatrix} $$\n\n**最终计算**\n\n选定的三个主元是 $p_1=6$，$p_2=9$ 和 $p_3=-40/9$。\n它们的绝对值之积为：\n$$ |p_1| \\cdot |p_2| \\cdot |p_3| = |6| \\cdot |9| \\cdot \\left|-\\frac{40}{9}\\right| = 6 \\cdot 9 \\cdot \\frac{40}{9} = 6 \\cdot 40 = 240 $$\n这就是所要求的最终数值答案。",
            "answer": "$$\n\\boxed{240}\n$$"
        },
        {
            "introduction": "一个算法的精妙之处常常体现在其对特殊情况的处理上。本练习  探讨了打破僵局规则 (tie-breaking rules) 在车象主元搜索中的关键作用，这个细节确保了算法的确定性。通过一个经特殊设计的、拥有多个相同大小潜在主元的矩阵，你将亲眼见证不同的打破僵局策略如何改变主元的选择，并进而改变整个因式分解的进程。",
            "id": "3575128",
            "problem": "考虑 $4 \\times 4$ 矩阵\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  & 1  & 2  & 3 \\\\\n10  & 0.5  & 10  & 1 \\\\\n10  & 2  & 0.5  & 10 \\\\\n9  & 8  & 7  & 6\n\\end{pmatrix}.\n$$\n我们在第一步 $k=1$ 时执行车象主元（rook pivoting）法，从第 1 列开始搜索。车象主元法定义为以下过程：迭代选择当前列中绝对值最大的元素，然后切换到该元素所在行中绝对值最大元素的列，并继续此过程，直到所选元素同时是其所在行和所在列的绝对值最大值。我们在绝对值出现平局的情况下，根据两种不同的平局打破策略来执行搜索：\n- 策略 $\\mathcal{A}$：当出现平局时，选择最小的索引（行或列）。\n- 策略 $\\mathcal{B}$：当出现平局时，选择最大的索引（行或列）。\n\n在第 $k=1$ 步的车象主元搜索结束时，令 $(i_{\\mathcal{A}},j_{\\mathcal{A}})$ 和 $(i_{\\mathcal{B}},j_{\\mathcal{B}})$ 分别为在策略 $\\mathcal{A}$ 和 $\\mathcal{B}$ 下找到的主元位置。令 $\\mathbf{P}_{\\mathcal{A}}$ 和 $\\mathbf{Q}_{\\mathcal{A}}$ 分别为将第 $i_{\\mathcal{A}}$ 行与第 1 行交换、将第 $j_{\\mathcal{A}}$ 列与第 1 列交换的置换矩阵；类似地，为策略 $\\mathcal{B}$ 定义 $\\mathbf{P}_{\\mathcal{B}}$ 和 $\\mathbf{Q}_{\\mathcal{B}}$。构成置换后的矩阵 $A_{\\mathcal{A}}' = \\mathbf{P}_{\\mathcal{A}} A \\mathbf{Q}_{\\mathcal{A}}$ 和 $A_{\\mathcal{B}}' = \\mathbf{P}_{\\mathcal{B}} A \\mathbf{Q}_{\\mathcal{B}}$。\n\n对每个置换后的矩阵，以 $a'_{11}$ 为主元执行一步高斯消元，以产生第一步的 LU 分解（Lower-Upper factorization）。具体步骤为：通过设置第一列的乘数 $l_{i1} = a'_{i1}/a'_{11}$（$i = 2,3,4$）并在对角线上置 1 来定义单位下三角的第一步因子 $L^{(1)}$；然后通过行操作 $R_{i} \\leftarrow R_{i} - l_{i1} R_{1}$（$i = 2,3,4$）更新 $A'$，将主元下方的第一列元素清零。由此定义的第一步上三角因子 $U^{(1)}$ 即为行操作后得到的矩阵。对于策略 $\\mathcal{A}$，将这些因子记为 $L_{\\mathcal{A}}^{(1)}, U_{\\mathcal{A}}^{(1)}$；对于策略 $\\mathcal{B}$，记为 $L_{\\mathcal{B}}^{(1)}, U_{\\mathcal{B}}^{(1)}$。\n\n使用弗罗贝尼乌斯范数（Frobenius norm）$\\|\\cdot\\|_{F}$，计算标量\n$$\nS \\;=\\; \\big\\|\\,U_{\\mathcal{A}}^{(1)} - U_{\\mathcal{B}}^{(1)}\\,\\big\\|_{F}^{2}.\n$$\n请以精确值的形式给出最终答案，无需四舍五入。",
            "solution": "### 解题过程\n\n#### 策略 $\\mathcal{A}$ 下的车象主元（最小索引）\n我们在步骤 $k=1$ 时从列 $j=1$ 开始搜索。\n$A$ 的第一列是 $(0, 10, 10, 9)^T$。\n1.  **列搜索**：找到使 $|a_{i1}|$ 最大化的行索引 $i$。最大绝对值为 $10$，出现在 $a_{21}$ 和 $a_{31}$ 处。策略 $\\mathcal{A}$ 要求选择最小的行索引，因此我们选择 $i=2$。我们当前的候选位置是 $(2, 1)$，值为 $a_{21}=10$。\n2.  **行搜索**：我们检查第 2 行，即 $(10, 0.5, 10, 1)$。找到使 $|a_{2j}|$ 最大化的列索引 $j$。最大绝对值为 $10$，出现在 $a_{21}$ 和 $a_{23}$ 处。策略 $\\mathcal{A}$ 要求选择最小的列索引，因此我们选择 $j=1$。\n3.  **收敛**：列搜索给出了位置 $(2,1)$，随后的行搜索让我们回到了第 1 列。过程已经稳定。主元元素是 $a_{21}=10$。\n因此，对于策略 $\\mathcal{A}$，主元位置是 $(i_{\\mathcal{A}}, j_{\\mathcal{A}}) = (2, 1)$。\n\n为了将此主元移动到 $(1,1)$ 位置，$\\mathbf{P}_{\\mathcal{A}}$ 必须交换第 2 行和第 1 行。$\\mathbf{Q}_{\\mathcal{A}}$ 是单位矩阵。\n$A_{\\mathcal{A}}' = \\mathbf{P}_{\\mathcal{A}} A \\mathbf{Q}_{\\mathcal{A}}$ 是将矩阵 $A$ 的第 1 行和第 2 行交换后的矩阵：\n$$ A_{\\mathcal{A}}' = \\begin{pmatrix} 10 & \\frac{1}{2} & 10 & 1 \\\\ 0 & 1 & 2 & 3 \\\\ 10 & 2 & \\frac{1}{2} & 10 \\\\ 9 & 8 & 7 & 6 \\end{pmatrix} $$\n现在，我们执行一步高斯消元。主元是 $a'_{11} = 10$。乘数为：\n$l_{21} = \\frac{0}{10} = 0$, $l_{31} = \\frac{10}{10} = 1$, $l_{41} = \\frac{9}{10}$。\n通过更新第 2、3、4 行得到第一步的上三角因子 $U_{\\mathcal{A}}^{(1)}$：\n- $R_2 \\leftarrow R_2 - 0 \\cdot R_1$: 第 2 行不变。\n- $R_3 \\leftarrow R_3 - 1 \\cdot R_1 = (10, 2, \\frac{1}{2}, 10) - (10, \\frac{1}{2}, 10, 1) = (0, \\frac{3}{2}, -\\frac{19}{2}, 9)$。\n- $R_4 \\leftarrow R_4 - \\frac{9}{10} \\cdot R_1 = (9, 8, 7, 6) - \\frac{9}{10}(10, \\frac{1}{2}, 10, 1) = (9, 8, 7, 6) - (9, \\frac{9}{20}, 9, \\frac{9}{10}) = (0, \\frac{151}{20}, -2, \\frac{51}{10})$。\n所以，\n$$ U_{\\mathcal{A}}^{(1)} = \\begin{pmatrix} 10 & \\frac{1}{2} & 10 & 1 \\\\ 0 & 1 & 2 & 3 \\\\ 0 & \\frac{3}{2} & -\\frac{19}{2} & 9 \\\\ 0 & \\frac{151}{20} & -2 & \\frac{51}{10} \\end{pmatrix} $$\n\n#### 策略 $\\mathcal{B}$ 下的车象主元（最大索引）\n我们在步骤 $k=1$ 时从列 $j=1$ 开始搜索。\n1.  **列搜索 (第 1 列)**：找到使 $|a_{i1}|$ 最大化的 $i$。最大值是 $10$，在 $a_{21}$ 和 $a_{31}$ 处。策略 $\\mathcal{B}$ 选择最大的行索引，所以我们选择 $i=3$。候选位置：$(3, 1)$，值为 $a_{31}=10$。\n2.  **行搜索 (第 3 行)**：检查第 3 行，即 $(10, 2, 0.5, 10)$。找到使 $|a_{3j}|$ 最大化的 $j$。最大值是 $10$，在 $a_{31}$ 和 $a_{34}$ 处。策略 $\\mathcal{B}$ 选择最大的列索引，所以我们切换到第 $j=4$ 列。\n3.  **列搜索 (第 4 列)**：新的搜索列是 $j=4$。第 4 列是 $(3, 1, 10, 6)^T$。找到使 $|a_{i4}|$ 最大化的 $i$。最大值是 $10$，在 $a_{34}$ 處。我们选择 $i=3$。候选位置：$(3, 4)$，值为 $a_{34}=10$。\n4.  **行搜索 (第 3 行)**：检查第 3 行，即 $(10, 2, 0.5, 10)$。找到使 $|a_{3j}|$ 最大化的 $j$。最大值是 $10$，在 $a_{31}$ 和 $a_{34}$ 处。策略 $\\mathcal{B}$ 选择最大的列索引，$j=4$。\n5.  **收敛**：列搜索给出了位置 $(3,4)$，随后的行搜索让我们回到了第 4 列。过程已经稳定。主元元素是 $a_{34}=10$。\n因此，对于策略 $\\mathcal{B}$，主元位置是 $(i_{\\mathcal{B}}, j_{\\mathcal{B}}) = (3, 4)$。\n\n$\\mathbf{P}_{\\mathcal{B}}$ 交换第 3 行和第 1 行。$\\mathbf{Q}_{\\mathcal{B}}$ 交换第 4 列和第 1 列。\n$$ A_{\\mathcal{B}}' = \\mathbf{P}_{\\mathcal{B}} A \\mathbf{Q}_{\\mathcal{B}} = \\begin{pmatrix} 10 & 2 & \\frac{1}{2} & 10 \\\\ 1 & \\frac{1}{2} & 10 & 10 \\\\ 3 & 1 & 2 & 0 \\\\ 6 & 8 & 7 & 9 \\end{pmatrix} $$\n现在，我们执行一步高斯消元。主元是 $a'_{11}=10$。乘数为：\n$l_{21} = \\frac{1}{10}$, $l_{31} = \\frac{3}{10}$, $l_{41} = \\frac{6}{10} = \\frac{3}{5}$。\n- $R_2 \\leftarrow R_2 - \\frac{1}{10} R_1 = (1, \\frac{1}{2}, 10, 10) - (1, \\frac{2}{10}, \\frac{1}{20}, 1) = (0, \\frac{3}{10}, \\frac{199}{20}, 9)$。\n- $R_3 \\leftarrow R_3 - \\frac{3}{10} R_1 = (3, 1, 2, 0) - (3, \\frac{6}{10}, \\frac{3}{20}, 3) = (0, \\frac{4}{10}, \\frac{37}{20}, -3) = (0, \\frac{2}{5}, \\frac{37}{20}, -3)$。\n- $R_4 \\leftarrow R_4 - \\frac{6}{10} R_1 = (6, 8, 7, 9) - (6, \\frac{12}{10}, \\frac{3}{10}, 6) = (0, \\frac{68}{10}, \\frac{67}{10}, 3) = (0, \\frac{34}{5}, \\frac{67}{10}, 3)$。\n所以，\n$$ U_{\\mathcal{B}}^{(1)} = \\begin{pmatrix} 10 & 2 & \\frac{1}{2} & 10 \\\\ 0 & \\frac{3}{10} & \\frac{199}{20} & 9 \\\\ 0 & \\frac{2}{5} & \\frac{37}{20} & -3 \\\\ 0 & \\frac{34}{5} & \\frac{67}{10} & 3 \\end{pmatrix} $$\n\n#### 最终计算\n我们计算差分矩阵 $D = U_{\\mathcal{A}}^{(1)} - U_{\\mathcal{B}}^{(1)}$。\n$$ D = \\begin{pmatrix} 10 - 10 & \\frac{1}{2} - 2 & 10 - \\frac{1}{2} & 1 - 10 \\\\ 0-0 & 1 - \\frac{3}{10} & 2 - \\frac{199}{20} & 3 - 9 \\\\ 0-0 & \\frac{3}{2} - \\frac{2}{5} & -\\frac{19}{2} - \\frac{37}{20} & 9 - (-3) \\\\ 0-0 & \\frac{151}{20} - \\frac{34}{5} & -2 - \\frac{67}{10} & \\frac{51}{10} - 3 \\end{pmatrix} = \\begin{pmatrix} 0 & -\\frac{3}{2} & \\frac{19}{2} & -9 \\\\ 0 & \\frac{7}{10} & -\\frac{159}{20} & -6 \\\\ 0 & \\frac{11}{10} & -\\frac{227}{20} & 12 \\\\ 0 & \\frac{15}{20} & -\\frac{87}{10} & \\frac{21}{10} \\end{pmatrix} $$\n标量 $S$ 是 $D$ 的弗罗贝尼乌斯范数的平方，即其所有元素平方的总和。\n$S = \\big\\|D\\big\\|_{F}^{2} = \\sum_{i,j} d_{ij}^2$\n$S = \\left(-\\frac{3}{2}\\right)^2 + \\left(\\frac{19}{2}\\right)^2 + (-9)^2 + \\left(\\frac{7}{10}\\right)^2 + \\left(-\\frac{159}{20}\\right)^2 + (-6)^2 + \\left(\\frac{11}{10}\\right)^2 + \\left(-\\frac{227}{20}\\right)^2 + (12)^2 + \\left(\\frac{3}{4}\\right)^2 + \\left(-\\frac{87}{10}\\right)^2 + \\left(\\frac{21}{10}\\right)^2$\n$S = \\frac{9}{4} + \\frac{361}{4} + 81 + \\frac{49}{100} + \\frac{25281}{400} + 36 + \\frac{121}{100} + \\frac{51529}{400} + 144 + \\frac{9}{16} + \\frac{7569}{100} + \\frac{441}{100}$\n使用公分母 $400$：\n$S = \\frac{900}{400} + \\frac{36100}{400} + \\frac{32400}{400} + \\frac{196}{400} + \\frac{25281}{400} + \\frac{14400}{400} + \\frac{484}{400} + \\frac{51529}{400} + \\frac{57600}{400} + \\frac{225}{400} + \\frac{30276}{400} + \\frac{1764}{400}$\n分子求和：\n$S = \\frac{900+36100+32400+196+25281+14400+484+51529+57600+225+30276+1764}{400} = \\frac{251155}{400}$\n这个分数可以通过分子分母同时除以 $5$ 来化简：\n$S = \\frac{50231}{80}$",
            "answer": "$$ \\boxed{\\frac{50231}{80}} $$"
        },
        {
            "introduction": "车象主元法较高的计算成本只有在其于特定情况下表现出卓越的数值稳定性时才显得合理。这个综合性练习  将从计算转向实现和实证分析。你将实现车象主元法和更常见的局部主元法，然后在一系列臭名昭著的病态矩阵上对它们进行测试，使用后向误差和元素增长来量化它们的性能。这个练习将为“何时以及为何车象主元法是更优越的选择”这个问题提供一个清晰的、由数据驱动的答案。",
            "id": "3575115",
            "problem": "为方形非奇异矩阵实现两种高斯消元求解器：一种使用部分（行）主元法，另一种使用车象主元法。请从高斯消元法的基本定义出发，该定义将矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 分解为三角因子和置换，使得 $P A = L U$（部分主元法）或 $P A Q = L U$（车象主元法），其中 $P$ 和 $Q$ 是置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。车象主元策略选择的主元，在其当前列中是绝对值最大的元素，并且在交替搜索后，在活动子矩阵内的对应行中也是绝对值最大的元素。您必须从基本原理出发实现这两种策略，不得调用任何库中的分解例程。\n\n使用这两种求解器，对一系列逐渐变得更病態的矩阵进行经验性研究，并找出部分主元法“失效”而车象主元法仍能保持可接受的范数反向误差的情况。失效的概念必须从基于反向误差和元素增长的基本原理推导出来。具体来说：\n\n- 对于 $A x = b$ 的计算解 $\\hat{x}$，定义范数反向误差\n$$\n\\eta(A,b,\\hat{x}) = \\frac{\\lVert b - A \\hat{x}\\rVert_{2}}{\\lVert A\\rVert_{2}\\,\\lVert \\hat{x}\\rVert_{2} + \\lVert b\\rVert_{2}},\n$$\n该误差衡量了使 $\\hat{x}$ 成为精确解所需的最小相对扰动。这是衡量数值行为是否可接受的基本度量。\n\n- 定义元素增长因子\n$$\n\\rho = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|},\n$$\n该因子衡量了消元过程中元素的放大程度，并可作为一个实用的风险指标。\n\n对于每个测试用例，使用精确的右端项 $b = A \\,\\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 是全1向量。使用部分主元法计算 $\\hat{x}_{\\mathrm{pp}}$，使用车象主元法计算 $\\hat{x}_{\\mathrm{rook}}$，并评估 $\\eta(A,b,\\hat{x}_{\\mathrm{pp}})$、$\\eta(A,b,\\hat{x}_{\\mathrm{rook}})$ 以及在部分主元法分解过程中观察到的增长因子 $\\rho_{\\mathrm{pp}}$。如果反向误差超过固定容差或观察到的增长因子超过固定界限，则宣告部分主元法“失效”；而如果车象主元法的反向误差在容差范围内，则其为“可接受的”。请使用以下接受标准：\n- 可接受的反向误差容差：$\\eta \\le 5\\times 10^{-12}$。\n- 部分主元法失效的增长阈值：$\\rho_{\\mathrm{pp}} > 10^{3}$。\n\n测试矩阵族。构建以下参数化的确定性矩阵族（其定义中使用了基于1的索引，必须小心地将其映射到基于0的程序索引）：\n\n- Wilkinson 型矩阵 $W_{n}$ (n阶)，其定义与本文主体部分一致：\n$$\n(W_n)_{ij} = \\begin{cases}\n1, & \\text{if } i=j \\text{ or } j=n \\\\\n-1, & \\text{if } i>j \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n\n- Lotkin 矩阵 $L_{n}$ (n阶)：\n$$\n(L_n)_{1j} = 1 \\text{ for } 1 \\le j \\le n, \\quad (L_n)_{ij} = \\frac{1}{i + j - 1} \\text{ for } 2 \\le i \\le n, \\, 1 \\le j \\le n.\n$$\n\n- Vandermonde 矩阵 $V_{n}(\\alpha)$ (n阶)，节点为 $\\{t_i\\}_{i=1}^n$：\n$$\nt_i = \\alpha_0 + \\frac{i-1}{n-1}(\\alpha_1 - \\alpha_0), \\quad 0  \\alpha_0  \\alpha_1  1, \\quad V_{ij} = t_i^{\\,j-1}.\n$$\n所有 Vandermonde 测试均使用 $(\\alpha_0,\\alpha_1)=(0.9,1.0)$。\n\n- Kahan 型上三角矩阵族 $K_{n}(s)$ (n阶)，参数为 $s \\in (0,1)$ 且 $c = \\sqrt{1 - s^{2}}$：\n$$\n(K_n(s))_{ii} = 1 \\text{ for } 1 \\le i \\le n,\\quad (K_n(s))_{ij} = -c \\text{ for } 1 \\le i  j \\le n,\\quad (K_n(s))_{i1} = s^{\\,i-1} \\text{ for } 1 \\le i \\le n.\n$$\n此处明确定义该矩阵族是为了提供一个额外的、可调的三角矩阵情况。\n\n您的程序必须实现：\n- 一个部分主元高斯消元法，返回 $P$、$L$、$U$、作为索引映射的行置换以及元素增长因子 $\\rho_{\\mathrm{pp}}$。\n- 一个车象主元高斯消元法，返回 $P$、$Q$、$L$、$U$、行和列的索引映射及其元素增长因子 $\\rho_{\\mathrm{rook}}$。\n\n使用前向与后向代换求解分解所蕴含的三角系统，注意根据 $P A = L U$（部分）和 $P A Q = L U$（车象）正确应用 $P$ 和 $Q$。为每个测试中的两种求解器计算 $\\eta$。\n\n测试套件。为确保覆盖良性、临界和对抗性情形，请运行以下七个案例：\n\n- 案例1：Wilkinson, $n=8$。\n- 案例2：Wilkinson, $n=16$。\n- 案例3：Lotkin, $n=8$。\n- 案例4：Lotkin, $n=12$。\n- 案例5：Vandermonde, $n=10$, $(\\alpha_0,\\alpha_1)=(0.9,1.0)$。\n- 案例6：Vandermonde, $n=12$, $(\\alpha_0,\\alpha_1)=(0.95,1.0)$。\n- 案例7：Kahan-type, $n=12$, $s=0.99$。\n\n对于每个案例，输出指示符\n$$\n\\mathsf{flag} = \\begin{cases}\n1,  \\text{如果部分主元法失效且车象主元法具有可接受的反向误差},\\\\\n0,  \\text{其他情况}.\n\\end{cases}\n$$\n具体来说，“部分主元法失效”意味着 $\\eta(A,b,\\hat{x}_{\\mathrm{pp}})  5\\times 10^{-12}$ 或 $\\rho_{\\mathrm{pp}}  10^{3}$，“车象主元法可接受”意味着 $\\eta(A,b,\\hat{x}_{\\mathrm{rook}}) \\le 5\\times 10^{-12}$。\n\n最终输出格式。您的程序应生成一行输出，其中包含七个标志，形式为逗号分隔的列表，并用方括号括起来（例如，“[0,1,0,0,0,0,0]”），按顺序对应案例1到案例7。此任务不涉及物理单位或角度。所有数值比较均应在标准双精度下执行。",
            "solution": "此问题要求实现、测试并比较部分主元法和车象主元法在高斯消元中的性能。以下是遵循问题规范的完整 Python 3 实现，用于生成所需的标志序列。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Ensure consistent use of 64-bit floating point numbers.\nDTYPE = np.float64\n\ndef make_wilkinson(n):\n    \"\"\"Constructs the Wilkinson-type matrix W_n of order n as defined in the article.\"\"\"\n    A = np.zeros((n, n), dtype=DTYPE)\n    # Note: problem uses 1-based indexing, code uses 0-based\n    for i in range(n):\n        for j in range(n):\n            if i == j or j == n - 1:\n                A[i, j] = 1.0\n            elif i  j:\n                A[i, j] = -1.0\n    return A\n\ndef make_lotkin(n):\n    \"\"\"Constructs the Lotkin matrix L_n of order n.\"\"\"\n    A = np.zeros((n, n), dtype=DTYPE)\n    A[0, :] = 1.0\n    for i in range(1, n):\n        for j in range(n):\n            # Problem: i+j-1 (1-based); Code: (i+1)+(j+1)-1 = i+j+1 (0-based)\n            A[i, j] = 1.0 / (i + j + 1)\n    return A\n\ndef make_vandermonde(n, alpha0, alpha1):\n    \"\"\"Constructs a Vandermonde matrix V_n of order n.\"\"\"\n    # Problem: (i-1)/(n-1); Code: arange(n)/(n-1)\n    t = alpha0 + (np.arange(n, dtype=DTYPE) / (n - 1)) * (alpha1 - alpha0)\n    # Problem: V_ij = t_i^(j-1); Code: A[i, j] = t[i]**j\n    return np.power.outer(t, np.arange(n, dtype=DTYPE))\n\ndef make_kahan_type(n, s):\n    \"\"\"Constructs the Kahan-type matrix K_n(s) of order n.\"\"\"\n    A = np.zeros((n, n), dtype=DTYPE)\n    c = np.sqrt(1 - s**2)\n    # Upper triangle\n    for i in range(n):\n        for j in range(i + 1, n):\n            A[i, j] = -c\n    # Diagonal\n    np.fill_diagonal(A, 1.0)\n    # First column\n    for i in range(n):\n        A[i, 0] = s**i\n    return A\n\ndef lu_partial_pivot(A_in):\n    \"\"\"Performs LU factorization with partial pivoting: P A = L U.\"\"\"\n    A = A_in.copy()\n    n = A.shape[0]\n    piv = np.arange(n)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0: return A, piv, 1.0\n    \n    for k in range(n - 1):\n        max_row_idx = k + np.argmax(np.abs(A[k:, k]))\n        if max_row_idx != k:\n            A[[k, max_row_idx]] = A[[max_row_idx, k]]\n            piv[[k, max_row_idx]] = piv[[max_row_idx, k]]\n        if A[k, k] == 0: continue\n        multipliers = A[k+1:, k] / A[k, k]\n        A[k+1:, k] = multipliers\n        A[k+1:, k+1:] -= np.outer(multipliers, A[k, k+1:])\n        \n    U = np.triu(A)\n    max_abs_U = np.max(np.abs(U))\n    rho = max_abs_U / max_abs_A if max_abs_A > 0 else 1.0\n    return A, piv, rho\n\ndef lu_rook_pivot(A_in):\n    \"\"\"Performs LU factorization with rook pivoting: P A Q = L U.\"\"\"\n    A = A_in.copy()\n    n = A.shape[0]\n    piv = np.arange(n)\n    qiv = np.arange(n)\n    max_abs_A = np.max(np.abs(A))\n    if max_abs_A == 0: return A, piv, qiv, 1.0\n\n    for k in range(n - 1):\n        r, c = k, k\n        while True:\n            r_new = k + np.argmax(np.abs(A[k:, c]))\n            if np.abs(A[r_new, c])  np.abs(A[r, c]):\n                r = r_new\n            \n            c_new = k + np.argmax(np.abs(A[r, k:]))\n            if np.abs(A[r, c_new])  np.abs(A[r, c]):\n                c = c_new\n                continue\n            break\n            \n        if r != k:\n            A[[k, r]] = A[[r, k]]\n            piv[[k, r]] = piv[[r, k]]\n        \n        if c != k:\n            A[:, [k, c]] = A[:, [c, k]]\n            qiv[[k, c]] = qiv[[c, k]]\n        \n        if A[k, k] == 0: continue\n        \n        multipliers = A[k+1:, k] / A[k, k]\n        A[k+1:, k] = multipliers\n        A[k+1:, k+1:] -= np.outer(multipliers, A[k, k+1:])\n\n    U = np.triu(A)\n    max_abs_U = np.max(np.abs(U))\n    rho = max_abs_U / max_abs_A if max_abs_A > 0 else 1.0\n    return A, piv, qiv, rho\n\ndef solve_lu_system(LU, piv, qiv, b):\n    \"\"\"Solves Ax=b given LU factorization.\"\"\"\n    n = LU.shape[0]\n    b_p = b[piv]\n    \n    z = np.zeros(n, dtype=DTYPE)\n    for i in range(n):\n        z[i] = b_p[i] - LU[i, :i] @ z[:i]\n        \n    y = np.zeros(n, dtype=DTYPE)\n    for i in range(n - 1, -1, -1):\n        if LU[i, i] == 0: y[i] = np.inf\n        else: y[i] = (z[i] - LU[i, i+1:] @ y[i+1:]) / LU[i, i]\n           \n    if qiv is None: return y\n    else:\n        x = np.zeros(n, dtype=DTYPE)\n        x[qiv] = y\n        return x\n\ndef calculate_backward_error(A, b, x_hat):\n    \"\"\"Computes the normwise backward error.\"\"\"\n    if np.all(x_hat == 0): return 0.0\n    res_norm = np.linalg.norm(b - A @ x_hat, 2)\n    A_norm = np.linalg.norm(A, 2)\n    x_hat_norm = np.linalg.norm(x_hat, 2)\n    b_norm = np.linalg.norm(b, 2)\n    denominator = A_norm * x_hat_norm + b_norm\n    if denominator == 0: return res_norm\n    return res_norm / denominator\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        {'type': 'wilkinson', 'n': 8},\n        {'type': 'wilkinson', 'n': 16},\n        {'type': 'lotkin', 'n': 8},\n        {'type': 'lotkin', 'n': 12},\n        {'type': 'vandermonde', 'n': 10, 'alpha0': 0.9, 'alpha1': 1.0},\n        {'type': 'vandermonde', 'n': 12, 'alpha0': 0.95, 'alpha1': 1.0},\n        {'type': 'kahan', 'n': 12, 's': 0.99},\n    ]\n\n    results = []\n    \n    ETA_TOLERANCE = 5e-12\n    RHO_THRESHOLD = 1e3\n\n    for case in test_cases:\n        if case['type'] == 'wilkinson':\n            A = make_wilkinson(case['n'])\n        elif case['type'] == 'lotkin':\n            A = make_lotkin(case['n'])\n        elif case['type'] == 'vandermonde':\n            A = make_vandermonde(case['n'], case['alpha0'], case['alpha1'])\n        elif case['type'] == 'kahan':\n            A = make_kahan_type(case['n'], case['s'])\n        \n        n = A.shape[0]\n        b = A @ np.ones(n, dtype=DTYPE)\n\n        A_pp = A.copy()\n        LU_pp, piv_pp, rho_pp = lu_partial_pivot(A_pp)\n        x_pp = solve_lu_system(LU_pp, piv_pp, None, b)\n        eta_pp = calculate_backward_error(A, b, x_pp)\n\n        A_rook = A.copy()\n        LU_rook, piv_r, qiv_r, _ = lu_rook_pivot(A_rook)\n        x_rook = solve_lu_system(LU_rook, piv_r, qiv_r, b)\n        eta_rook = calculate_backward_error(A, b, x_rook)\n\n        pp_fails = (eta_pp  ETA_TOLERANCE) or (rho_pp  RHO_THRESHOLD)\n        rook_ok = (eta_rook = ETA_TOLERANCE)\n        \n        flag = 1 if (pp_fails and rook_ok) else 0\n        results.append(flag)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
            "answer": "$$\n\\boxed{[0, 1, 0, 0, 0, 0, 1]}\n$$"
        }
    ]
}