{
    "hands_on_practices": [
        {
            "introduction": "标准的部分主元高斯消去法（GEPP）是数值线性代数的一块基石，但现代并行算法为了减少通信开销，常采用替代的主元选择策略。本练习将探讨一种此类策略——在通信避免 LU（CALU）分解框架下的锦标赛主元选择法，并要求您具体分析其对增长因子的影响 。通过在一个精心构造的矩阵上比较 CALU 与 GEPP 的主元选择，您将更深刻地理解不同主元选择机制如何影响数值稳定性。",
            "id": "3591199",
            "problem": "考虑 $4 \\times 4$ 矩阵\n$$\nA \\;=\\;\n\\begin{pmatrix}\n100  10^{6}  0  0 \\\\\n10^{-1}  2  2000  0 \\\\\n90  -1  0  0 \\\\\n5 \\times 10^{-2}  3  0  0\n\\end{pmatrix}.\n$$\n你将比较部分主元高斯消去法 (GEPP) 与采用锦标赛主元选择的通信避免 LU 分解 (CALU) 的主元选择方法，然后量化元素增长。\n\n使用以下基本依据和定义。\n- LU 分解将 $A$ 写为 $A = P L U$，其中 $P$ 是一个置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。在 GEPP 中，对于每一列 $k$，选择主元行作为索引 $p \\geq k$，使得绝对值 $|a_{pk}^{(k)}|$ 最大化，其中 $a_{ij}^{(k)}$ 表示经过 $k-1$ 步消元后的元素，并且在消元前将主元行交换到位置 $k$。\n- 在面板宽度 $b = 2$ 和两个行域 $D_1 = \\{1,2\\}$、$D_2 = \\{3,4\\}$ 的 CALU 锦标赛主元选择中，通过在 2 列面板上对每个域限制性地执行部分主元选择来选出局部候选主元，然后通过一个两级锦标赛，仅比较域局部候选主元，来为每一列选择全局主元。具体到本问题：\n  1. 第 1 列：每个域选择其局部主元行（域中对应列 $k$ 的 $|a_{ik}|$ 最大的索引）。第 1 列的全局主元是值更大的那个候选主元。\n  2. 第 2 列（在同一面板内）：在每个域内，使用其自身的局部第 1 列主元，在其域的行上进行相应的消元，然后在该域的剩余行中选择第 2 列的域局部主元。通过比较这两个域局部第 2 列候选主元的绝对值大小，来选择第 2 列的全局主元。\n- 完成 LU 分解后的增长因子为\n$$\n\\rho \\;=\\; \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|},\n$$\n其中 $u_{ij}$ 是最终上三角因子 $U$ 的元素，$a_{ij}$ 是原始矩阵 $A$ 的元素。\n\n任务：\n1. 对矩阵 $A$ 的前两列应用 GEPP，并说明在第 1 列和第 2 列选择的主元行，并从基本原理出发解释为何选择这些行。\n2. 对相同的 2 列面板应用上述 CALU 的锦标赛主元选择过程，确定在第 1 列和第 2 列选择的主元行，并证明它们与 GEPP 的选择不同。\n3. 完成由 CALU 主元序列所隐含的至第 2 列的消元，并将其影响传播到第 3 列，以确定分解过程中产生的最大 $|u_{ij}|$。计算 $A$ 的 CALU 增长因子 $\\rho_{\\text{CALU}}$。将 $\\rho_{\\text{CALU}}$ 报告为一个简化的精确分数；不要四舍五入。\n4. 使用 LU 分解的标准后向误差框架，根据增长因子和面板/锦标赛结构，解释采用锦标赛主元选择的 CALU 何时能保持后向稳定。你的解释必须从后向稳定性的定义开始，即计算出的解是一个邻近问题 $(A + \\Delta A) x = b$ 的精确解，其中 $\\|\\Delta A\\|$ 的界是机器精度的适度倍数，并且必须明确地将此界与增长因子联系起来。\n\n你的最终答案必须是 $\\rho_{\\text{CALU}}$ 的唯一精确分数值，不带单位，也不进行四舍五入。",
            "solution": "该问题经验证具有科学依据、问题明确且客观。这是一个定义清晰的数值线性代数问题，要求应用和分析两种不同的 LU 分解主元选择策略，计算增长因子，并对数值稳定性进行理论解释。所有必要信息均已提供，任务明确无歧义。\n\n设给定矩阵为 $A$。\n$$\nA \\;=\\;\n\\begin{pmatrix}\n100  1000000  0  0 \\\\\n0.1  2  2000  0 \\\\\n90  -1  0  0 \\\\\n0.05  3  0  0\n\\end{pmatrix}\n$$\n\n**任务 1：部分主元高斯消去法 (GEPP)**\n\n对于第一列 ($k=1$)，我们在 $A$ 的第一列中寻找绝对值最大的元素。这些元素是 $a_{11} = 100$，$a_{21} = 0.1$，$a_{31} = 90$ 和 $a_{41} = 0.05$。最大绝对值为 $|a_{11}| = 100$。\n因此，对于第 1 列，主元行是第 1 行。不需要进行行交换。\n\n我们继续进行消元。乘数是 $l_{21} = \\frac{a_{21}}{a_{11}} = \\frac{0.1}{100} = 10^{-3}$，$l_{31} = \\frac{a_{31}}{a_{11}} = \\frac{90}{100} = 0.9$，以及 $l_{41} = \\frac{a_{41}}{a_{11}} = \\frac{0.05}{100} = 5 \\times 10^{-4}$。第一步消元后的矩阵，记为 $A^{(2)}$，是：\n\\begin{align*} R_2' = R_2 - l_{21}R_1 = (0.1, 2, 2000, 0) - 10^{-3}(100, 10^6, 0, 0) = (0, 2 - 1000, 2000, 0) = (0, -998, 2000, 0) \\\\ R_3' = R_3 - l_{31}R_1 = (90, -1, 0, 0) - 0.9(100, 10^6, 0, 0) = (0, -1 - 9 \\times 10^5, 0, 0) = (0, -900001, 0, 0) \\\\ R_4' = R_4 - l_{41}R_1 = (0.05, 3, 0, 0) - 5 \\times 10^{-4}(100, 10^6, 0, 0) = (0, 3 - 500, 0, 0) = (0, -497, 0, 0)\\end{align*}\n$$\nA^{(2)} \\;=\\;\n\\begin{pmatrix}\n100  10^{6}  0  0 \\\\\n0  -998  2000  0 \\\\\n0  -900001  0  0 \\\\\n0  -497  0  0\n\\end{pmatrix}\n$$\n对于第二列 ($k=2$)，我们在子列 $a_{i2}^{(2)}$ (其中 $i \\geq 2$) 中寻找绝对值最大的元素。这些元素是 $a_{22}^{(2)} = -998$，$a_{32}^{(2)} = -900001$ 和 $a_{42}^{(2)} = -497$。最大绝对值为 $|a_{32}^{(2)}| = 900001$。\n因此，对于第 2 列，主元行是第 3 行。GEPP 会交换第 2 行和第 3 行。\n\nGEPP 为第 1 列和第 2 列选择的主元行分别是第 1 行和第 3 行。\n\n**任务 2：采用锦标赛主元选择的通信避免 LU 分解 (CALU)**\n\n面板宽度为 $b=2$，行域为 $D_1 = \\{1,2\\}$ 和 $D_2 = \\{3,4\\}$。\n\n对于第 1 列：\n- 在域 $D_1$ 中，我们比较 $|a_{11}| = 100$ 和 $|a_{21}| = 0.1$。局部主元是第 1 行，其值为 $100$。\n- 在域 $D_2$ 中，我们比较 $|a_{31}| = 90$ 和 $|a_{41}| = 0.05$。局部主元是第 3 行，其值为 $90$。\n- 锦标赛比较局部候选主元：$|100|$ 对比 $|90|$。胜出者是来自第 1 行的候选主元。\n第 1 列的全局主元是第 1 行。这与 GEPP 的选择相同。\n\n对于第 2 列：\n该过程要求在每个域内使用局部的第 1 列主元进行局部消元，以找到第 2 列的候选主元。\n- 在域 $D_1=\\{1,2\\}$ 中，局部的第 1 列主元是第 1 行（$a_{11}=100$）。我们基于第 1 行更新第 2 行。乘数为 $m_1 = \\frac{a_{21}}{a_{11}} = \\frac{0.1}{100} = 10^{-3}$。第 2 行的新第二个元素是 $a_{22} - m_1 a_{12} = 2 - 10^{-3}(10^6) = 2 - 1000 = -998$。来自 $D_1$ 的第 2 列主元候选者是这个值，即来自第 2 行的 $-998$。\n- 在域 $D_2=\\{3,4\\}$ 中，局部的第 1 列主元是第 3 行（$a_{31}=90$）。我们基于第 3 行更新第 4 行。乘数为 $m_2 = \\frac{a_{41}}{a_{31}} = \\frac{0.05}{90} = \\frac{5/100}{90} = \\frac{5}{9000} = \\frac{1}{1800}$。第 4 行的新第二个元素是 $a_{42} - m_2 a_{32} = 3 - \\frac{1}{1800}(-1) = 3 + \\frac{1}{1800} = \\frac{5401}{1800}$。来自 $D_2$ 的第 2 列主元候选者是这个值，即来自第 4 行的 $\\frac{5401}{1800}$。\n- 第 2 列的锦标赛比较来自每个域的候选主元：$|-998|$ 对比 $|\\frac{5401}{1800}| \\approx 3.0$。值 $|-998|=998$ 更大。\n第 2 列的全局主元是第 2 行。\n\nCALU 为第 1 列和第 2 列选择的主元行是第 1 行和第 2 行。这与 GEPP 对第二个主元（第 3 行）的选择不同。\n\n**任务 3：CALU 增长因子计算**\n\nCALU 的主元序列是（第 1 行，第 2 行）。这意味着前两步不执行任何置换。使用主元 $a_{11}=100$ 对第 1 列进行的消元与 GEPP 的第一步相同，得到上面计算出的矩阵 $A^{(2)}$。\n$$\nA^{(2)} \\;=\\;\n\\begin{pmatrix}\n100  10^{6}  0  0 \\\\\n0  -998  2000  0 \\\\\n0  -900001  0  0 \\\\\n0  -497  0  0\n\\end{pmatrix}\n$$\n接下来，我们使用 CALU 选择的主元 $a_{22}^{(2)}=-998$ 对第 2 列进行消元。\n乘数是 $l_{32} = \\frac{a_{32}^{(2)}}{a_{22}^{(2)}} = \\frac{-900001}{-998} = \\frac{900001}{998}$ 和 $l_{42} = \\frac{a_{42}^{(2)}}{a_{22}^{(2)}} = \\frac{-497}{-998} = \\frac{497}{998}$。\n\n我们更新第 3 行和第 4 行得到矩阵 $A^{(3)}$。我们只需要考虑 $j \\ge 3$ 的列。\n对于第 3 行： $a_{33}^{(3)} = a_{33}^{(2)} - l_{32} a_{23}^{(2)} = 0 - \\frac{900001}{998} (2000) = - \\frac{1800002000}{998} = - \\frac{900001000}{499}$。\n$a_{34}^{(3)} = a_{34}^{(2)} - l_{32} a_{24}^{(2)} = 0 - l_{32}(0) = 0$。\n对于第 4 行： $a_{43}^{(3)} = a_{43}^{(2)} - l_{42} a_{23}^{(2)} = 0 - \\frac{497}{998} (2000) = - \\frac{994000}{998} = - \\frac{497000}{499}$。\n$a_{44}^{(3)} = a_{44}^{(2)} - l_{42} a_{24}^{(2)} = 0 - l_{42}(0) = 0$。\n\n最终的上三角矩阵 $U$ 是在对右下角的 $2 \\times 2$ 子矩阵再进行一步消元后得到的，尽管很明显第四列为零。我们可以写出最后一步之前的矩阵：\n$$\nA^{(3)} \\;=\\;\n\\begin{pmatrix}\n100  10^{6}  0  0 \\\\\n0  -998  2000  0 \\\\\n0  0  - \\frac{900001000}{499}  0 \\\\\n0  0  - \\frac{497000}{499}  0\n\\end{pmatrix}\n$$\n对第 3 列的剩余消元步骤将使 $u_{43}$ 变为零，而显示的所有其他元素都是 $U$ 的最终元素。\n最终矩阵 $U$ 的元素是所示的非零元素和零。我们找到 $U$ 中绝对值最大的元素。\n$|u_{11}| = 100$\n$|u_{12}| = 10^6$\n$|u_{22}| = 998$\n$|u_{23}| = 2000$\n$|u_{33}| = \\frac{900001000}{499} \\approx 1.803 \\times 10^6$。\n$U$ 中绝对值最大的元素是 $|u_{33}| = \\frac{900001000}{499}$。\n\n增长因子是 $\\rho_{\\text{CALU}} = \\frac{\\max_{i,j} |u_{ij}|}{\\max_{i,j} |a_{ij}|}$。\n原始矩阵 $A$ 中绝对值最大的元素是 $|a_{12}| = 10^6$。\n$$\n\\rho_{\\text{CALU}} = \\frac{\\frac{900001000}{499}}{10^6} = \\frac{900001000}{499 \\times 10^6} = \\frac{900.001}{499} = \\frac{900001}{499000}\n$$\n数字 $499$ 是一个质数。$900001 = 1803 \\times 499 + 304$，所以 $900001$ 不能被 $499$ 整除。该分数为最简形式。\n\n**任务 4：CALU 的后向稳定性**\n\n用于求解 $Ax=b$ 的数值算法的后向稳定性意味着，计算出的解 $\\hat{x}$ 是一个邻近问题 $(A + \\Delta A)\\hat{x} = b$ 的精确解，其中扰动矩阵 $\\Delta A$ 相对于 $A$ 是小的。具体来说，扰动的范数有界，例如 $\\|\\Delta A\\| \\le C \\cdot u \\cdot \\text{poly}(n) \\cdot \\|A\\|$，其中 $u$ 是机器精度，$n$ 是矩阵维度，$C$ 是一个常数。\n\n对于基于 LU 分解的求解器，标准的后向误差界与增长因子 $\\rho$ 成正比。一个常见的界是 $\\|\\Delta A\\|_{\\infty} \\le n u (3\\|A\\|_{\\infty} + 5\\||L| |U|\\|_{\\infty}) + O(u^2)$。由于 $\\| |L| |U| \\|_{\\infty}$ 包含 $U$ 的元素，这个界可以与 $\\rho$ 相关联。一个更简单、更直接的形式指出，相对误差由一个与 $\\rho$ 成比例的项界定：$\\|\\Delta A\\| / \\|A\\| \\le \\gamma_n \\rho u$，其中 $\\gamma_n$ 是一个关于 $n$ 的低次多项式。\n\n要使一个 LU 算法是后向稳定的，增长因子 $\\rho$ 必须很小（即，大小适中，不随 $n$呈指数增长）。\n\nCALU 的面板和锦标赛结构在每一步都限制了潜在主元的集合。与 GEPP 在整个剩余列中搜索主元不同，锦标赛主元选择只比较少数几个候选者，每个域一个。这样做是为了在并行计算环境中降低通信成本。然而，这种限制意味着算法可能无法选出可用的全局最大主元。\n\n正如本问题所示，CALU 为第 2 列的锦标赛选择了第 2 行作为主元，其值为 $-998$。这忽略了第 3 行中大得多的元素 $-900001$，因为它位于“获胜”域的局部搜索范围之外。这种次优的主元选择导致了一个大的乘数，$l_{32} = \\frac{900001}{998} \\gg 1$。这个大乘数作用于元素 $a_{23}^{(2)}=2000$ 时，引起了显著的元素增长，产生了大的元素 $u_{33} \\approx -1.8 \\times 10^6$。由此产生的增长因子 $\\rho_{\\text{CALU}} \\approx 1.8$ 大于 GEPP 主元选择所能得到的增长因子 $\\rho_{\\text{GEPP}}=1$。\n\n只要这种在通信和稳定性之间的权衡不导致大的增长因子，采用锦标赛主元选择的 CALU 就能保持后向稳定。其稳定性取决于每个域内选择的局部主元在全局范围内也足够好的期望。如果矩阵的结构使得大的潜在主元被锦标赛系统性地忽略，$\\rho$ 可能会变得很大，而项 $\\gamma_n \\rho u$ 可能会超过机器精度的数倍，从而违反后向稳定性的条件。本质上，CALU 的稳定性取决于矩阵的数值特性不会与固定的域结构产生不良的相互作用。",
            "answer": "$$\\boxed{\\frac{900001}{499000}}$$"
        },
        {
            "introduction": "对于大型稀疏线性系统，在 LU 分解过程中保持稀疏性与维持数值稳定性同等重要。这个编程练习将通过对比严格部分主元法和阈值主元法，来展示在这两个目标之间的经典权衡 。您将构造一个旨在通过标准主元法产生灾难性填充（fill-in）的稀疏矩阵，并观察阈值主元法如何缓解这一问题，从而实践性地了解现代稀疏直接求解器中使用的算法。",
            "id": "3591254",
            "problem": "考虑在下三角-上三角 (LU) 分解框架下，采用不同主元选择策略对稀疏矩阵进行构造、分解和分析。本问题的理论基础是一个非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的 LU 分解定义，即将其分解为一个单位下三角因子 $L$ 和一个上三角因子 $U$。同时涉及两种主元选择策略：部分主元选择，即在每一步选择当前列中幅值最大的元素作为主元；以及阈值主元选择，即如果对角线元素相对于列中最大元素的幅值满足某个阈值条件，则接受其作为主元。\n\n您必须根据以下原则，通过算法构造一个稀疏矩阵族 $A$。首先从一个带状矩阵开始，其主对角线上为 $1$ 值项，第一条次对角线和超对角线上为小值项，以确保非奇异性和数值稳定性。然后，在精心选择的列中，在远离对角线的位置注入大幅值的“异常”项，以迫使严格部分主元选择策略选用非对角线主元，从而通过行交换触发大量填充；而阈值主元选择策略在合适的阈值参数 $\\tau$ 下，当对角线主元幅值可接受时会优先选择它们，从而能够保持稀疏性。\n\n矩阵构造要求：\n- 对于给定的 $n \\in \\mathbb{N}$，构造一个 $A \\in \\mathbb{R}^{n \\times n}$ 矩阵，其模式如下：\n  - 对所有 $i$，$A_{i,i} = 1$，应实现为对角线上幅值为 $1$ 的元素。\n  - 对所有有效的 $i$，$A_{i,i+1} = \\epsilon$ 和 $A_{i+1,i} = \\epsilon$，应实现为一个具有较小非对角线幅值 $\\epsilon$ 的三对角带。\n  - 对于一个指定的列集合 $J \\subset \\{0,1,\\dots,n-1\\}$ 和一个映射 $r: J \\to \\{0,1,\\dots,n-1\\}$（其中 $r(j)$ 远非 $j$），设置 $A_{r(j),\\, j} = M$，其中 $M$ 是一个相对于 $1$ 和 $\\epsilon$ 的大幅值。\n\n待执行的主元选择策略：\n- 严格部分主元选择：这对应于参数 $\\tau = 1$ 的阈值主元选择，意味着只有当对角线元素的幅值等于该列中的最大幅值时才选择它作为主元；否则，选择最大的非对角线元素。\n- 阈值主元选择：使用一个给定的 $\\tau \\in [0,1]$，如果对角线元素的幅值至少是该列中最大幅值元素的 $\\tau$ 倍，则接受该对角线元素作为主元；否则，使用幅值最大的元素。\n\n对于每个矩阵，在两种策略下均使用自然列序（即，不进行旨在减少填充的预排序）执行 LU 分解。从因子中计算：\n- 填充率 $f := \\dfrac{\\operatorname{nnz}(L) + \\operatorname{nnz}(U)}{\\operatorname{nnz}(A)}$，其中 $\\operatorname{nnz}(\\cdot)$ 表示非零元素的数量。\n- 元素增长因子 $\\rho := \\dfrac{\\max_{i,j} |U_{i,j}|}{\\max_{i,j} |A_{i,j}|}$，它量化了原始矩阵和上三角因子之间出现的最大幅值增长。\n\n您的程序必须为每个测试案例返回两个布尔值结果：\n- 与严格部分主元选择相比，阈值主元选择是否减少了填充？即，$f_{\\text{threshold}} < f_{\\text{partial}}$ 是否成立？\n- 在阈值主元选择下的增长是否可接受？即，对于指定的界限 $g > 0$，$\\rho_{\\text{threshold}} \\le g$ 是否成立？\n\n实现约束：\n- 对 $A$ 使用压缩稀疏列 (CSC) 存储，并以自然顺序执行 LU 分解。分解必须遵守指定的主元选择阈值 $\\tau$。\n\n测试套件：\n- 案例 $1$（常规“顺利”路径）：$n = 50$，$\\epsilon = 0.05$，$J = \\{0,1,2,3,4,5,6,7,8,9\\}$，$r(j) = 49 - j$，$M = 100$，$\\tau = 0.01$，$g = 500$。\n- 案例 $2$（严格部分主元选择的边界情况）：$n = 50$，$\\epsilon = 0.05$，$J = \\{0,1,2,3,4,5,6,7,8,9\\}$，$r(j) = 49 - j$，$M = 100$，$\\tau = 1.0$，$g = 500$。\n- 案例 $3$（较小维度，中等异常项）：$n = 12$，$\\epsilon = 0.02$，$J = \\{0,1,2,3,4,5\\}$，$r(j) = 11 - j$，$M = 50$，$\\tau = 0.05$，$g = 250$。\n- 案例 $4$（始终选择对角线主元的边缘情况）：$n = 20$，$\\epsilon = 0.02$，$J = \\{0,1,2,3,4,5,6,7\\}$，$r(j) = 19 - j$，$M = 500$，$\\tau = 0.0$，$g = 5000$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表，每个测试案例贡献一个按上述顺序排列的含两个布尔元素的列表。例如，输出必须类似于 $[\\,[b_{1}^{(1)},b_{2}^{(1)}],\\,[b_{1}^{(2)},b_{2}^{(2)}],\\,\\dots\\,]$，不含任何额外文本。",
            "solution": "当前问题是对稀疏矩阵 LU 分解中固有权衡关系的一次计算性探索。具体而言，它对比了优先考虑数值稳定性的严格部分主元选择，和寻求在稳定性与稀疏性保持之间取得平衡的阈值主元选择。\n\n一个非奇异矩阵 $A$ 的 LU 分解是将其分解为乘积 $PA = LU$，其中 $P$ 是一个编码行交换的置换矩阵，$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。在求解线性系统 $Ax=b$ 时，这种分解可以通过前向和后向替换实现高效求解：$L(Ux) = Pb$。\n\n对于稀疏矩阵，一个主要目标是在因子 $L$ 和 $U$ 中保持稀疏性。在原始矩阵中为零的位置引入非零项的现象称为“填充”（fill-in）。填充量对高斯消去过程中主元（pivot）的选择高度敏感。\n\n**主元选择策略及其后果**\n\n1.  **严格部分主元选择**：在消去过程的每一步 $k$，算法选择当前列 $k$ 中（对角线或其下方）幅值最大的元素作为主元。如果最大元素不在对角线上，则需要进行行交换。该策略能有效防止由小主元引起的数值不稳定性，并保证元素增长因子 $\\rho$ 有界。然而，行交换可能对稀疏性造成损害，常常导致大量填充。在本问题中，此策略对应于阈值主元参数 $\\tau=1$。\n\n2.  **阈值主元选择**：该策略提供了一种折衷方案。在步骤 $k$，它确定当前列中最大幅值元素 $|A_{p,k}^{(k)}|$。如果对角线元素 $A_{k,k}^{(k)}$ 的幅值相对于此最大值足够大，即满足 $|A_{k,k}^{(k)}| \\ge \\tau \\cdot |A_{p,k}^{(k)}|$（其中 $\\tau \\in [0,1]$ 是用户定义的阈值），则接受该对角线元素作为主元。若此条件满足，则不发生行交换。否则，与第 $p$ 行进行交换。较小的 $\\tau$ 值倾向于选择对角线主元，从而保持稀疏性，但代价是可能使用较小的主元，这可能导致更大的元素增长和潜在的数值不稳定性。$\\tau=0$ 强制在对角线元素非零时使用它们（等效于不选主元），而 $\\tau=1$ 则恢复为严格部分主元选择。\n\n**矩阵构造与预期效果**\n\n该问题指定了一种精心设计的矩阵结构，以突显这些策略之间的差异。矩阵 $A$ 构建于一个良性的、行为良好的三对角结构（$A_{i,i}=1$, $A_{i,i\\pm 1}=\\epsilon$）之上。然后，插入大幅值的“异常”项 $A_{r(j),j} = M$。对于一个列 $j \\in J$：\n- 该列中幅值最大的元素是位于第 $r(j)$ 行的 $M$。\n- 对角线元素是 $A_{j,j}=1$。\n\n当对列 $j$ 应用严格部分主元选择（$\\tau=1$）时，主元条件是 $|A_{j,j}| \\ge 1 \\cdot |A_{r(j),j}|$，即 $1 \\ge M$。由于 $M$ 很大（例如 $100$），此条件不成立。因此，部分主元选择被迫将第 $j$ 行与第 $r(j)$ 行交换。由于 $r(j)$ 远离 $j$，这将一个遥远的行带入矩阵的活动部分，从而在 $L$ 因子的结构内造成显著的填充。\n\n当使用一个小的 $\\tau$ 进行阈值主元选择时，主元条件是 $|A_{j,j}| \\ge \\tau \\cdot |A_{r(j),j}|$，即 $1 \\ge \\tau M$。如果选择的 $\\tau$ 使得该不等式成立（例如，$\\tau=0.01, M=100 \\implies 1 \\ge 1$），则接受对角线元素作为主元。不发生行交换，稀疏结构得以保留，填充被最小化。\n\n**指标分析**\n\n两个指标量化了这种主元选择权衡的结果：\n\n1.  **填充率, $f = \\frac{\\operatorname{nnz}(L) + \\operatorname{nnz}(U)}{\\operatorname{nnz}(A)}$**：该指标衡量稀疏性的保持程度。如果阈值主元选择成功地避免了由异常项引起的行交换，我们预期 $f_{\\text{threshold}}$ 将显著小于 $f_{\\text{partial}}$。第一个布尔值输出 $f_{\\text{threshold}}  f_{\\text{partial}}$，检验的就是这一结果。\n\n2.  **增长因子, $\\rho = \\frac{\\max_{i,j} |U_{i,j}|}{\\max_{i,j} |A_{i,j}|}$**：该指标衡量数值稳定性。通过接受一个大小为 $1$ 的主元，而该列中含有一个大小为 $M$ 的元素，阈值主元选择可能会在因子 $U$ 中引入大数值。在消去 $A_{r(j), j}$ 的过程中，第 $j$ 行乘以因子 $A_{r(j),j}/A_{j,j} = M/1 = M$ 并从第 $r(j)$ 行中减去。这会在更新后的矩阵的位置 $(r(j), j+1)$ 处产生一个大小为 $-M\\epsilon$ 的新元素。在这种特定的矩阵结构中，这是元素增长的主要来源。因此，增长因子近似为 $\\rho_{\\text{threshold}} \\approx \\frac{|M\\epsilon|}{M} = |\\epsilon|$，此值很小。第二个布尔值输出 $\\rho_{\\text{threshold}} \\le g$，检查的就是这种增长是否在可接受范围内。\n\n**算法实现**\n\n对每个测试案例，执行以下过程：\n1.  以稀疏格式构造大小为 $n \\times n$ 的矩阵 $A$，具体使用 `scipy.sparse.lil_matrix` 以实现高效的逐元素赋值，然后转换为 `csc_matrix` 以进行分解。\n2.  填充三对角元素和指定的异常项。\n3.  计算 $\\operatorname{nnz}(A)$ 和 $\\max_{i,j} |A_{i,j}| = M$。\n4.  通过调用 `scipy.sparse.linalg.splu` 并设置 `permc_spec='NATURAL'` 和 `diag_pivot_thresh=1.0`，执行严格部分主元选择的 LU 分解。将所得 $L$ 和 $U$ 因子的非零元素数量相加，以计算 $f_{\\text{partial}}$。\n5.  通过调用 `splu` 并设置 `permc_spec='NATURAL'` 和 `diag_pivot_thresh=\\tau`（测试案例中的值），执行阈值主元选择的 LU 分解。\n6.  从第二次分解中，通过对新因子的非零元素求和来计算 $f_{\\text{threshold}}$。\n7.  找到新 $U$ 因子数据中的最大绝对值 $\\max|U_{i,j}|$，并计算 $\\rho_{\\text{threshold}}$。\n8.  最后，评估两个布尔条件 $[f_{\\text{threshold}}  f_{\\text{partial}}, \\rho_{\\text{threshold}} \\le g]$，并存储结果。对所有测试案例重复此过程。",
            "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nfrom scipy.sparse.linalg import splu\n\n# Set the environment according to the problem statement.\n# language: Python, version: 3.12\n# libraries: numpy==1.23.5, scipy==1.11.4\n\ndef run_factorization_analysis(n, epsilon, J, r_map, M, tau_thresh, g):\n    \"\"\"\n    Constructs a sparse matrix and analyzes its LU factorization under two\n    pivoting strategies.\n\n    Args:\n        n (int): Dimension of the matrix.\n        epsilon (float): Magnitude of off-diagonal entries in the tridiagonal band.\n        J (set): Set of column indices for rogue entries.\n        r_map (callable): Function mapping a column index j to a row index r(j).\n        M (float): Magnitude of the rogue entries.\n        tau_thresh (float): Threshold for threshold pivoting.\n        g (float): Growth factor bound.\n\n    Returns:\n        tuple[bool, bool]: A tuple of two booleans:\n                           (reduces_fill, acceptable_growth)\n    \"\"\"\n    # 1. Construct the matrix A using LIL format for efficient construction.\n    A = sp.lil_matrix((n, n), dtype=np.float64)\n\n    # Add tridiagonal band\n    for i in range(n):\n        A[i, i] = 1.0\n        if i  n - 1:\n            A[i, i + 1] = epsilon\n            A[i + 1, i] = epsilon\n    \n    # Add rogue entries\n    for j in J:\n        A[r_map(j), j] = M\n\n    # Convert to CSC format for factorization\n    A_csc = A.tocsc()\n    nnz_A = A_csc.nnz\n    max_A = M  # Max magnitude in A is M by construction\n\n    # 2. Factorize with strict partial pivoting (tau = 1.0)\n    # The 'NATURAL' permutation spec ensures no column reordering.\n    lu_partial = splu(A_csc, permc_spec='NATURAL', diag_pivot_thresh=1.0)\n    nnz_partial = lu_partial.L.nnz + lu_partial.U.nnz\n    f_partial = nnz_partial / nnz_A\n\n    # 3. Factorize with threshold pivoting (given tau)\n    lu_threshold = splu(A_csc, permc_spec='NATURAL', diag_pivot_thresh=tau_thresh)\n    nnz_threshold = lu_threshold.L.nnz + lu_threshold.U.nnz\n    f_threshold = nnz_threshold / nnz_A\n    \n    # Find max element in U for growth factor calculation.\n    # U.data can contain explicit zeros, so filter them out if necessary,\n    # though max(abs(..)) handles it. If U.data is empty, max would fail.\n    max_U_thresh = 0.0\n    if lu_threshold.U.data.size  0:\n        max_U_thresh = np.max(np.abs(lu_threshold.U.data))\n    \n    rho_threshold = max_U_thresh / max_A\n\n    # 4. Evaluate the boolean conditions\n    reduces_fill = f_threshold  f_partial\n    acceptable_growth = rho_threshold = g\n\n    return [reduces_fill, acceptable_growth]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the LU factorization problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: General \"happy path\"\n        {'n': 50, 'epsilon': 0.05, 'J': set(range(10)), 'r_map': lambda j: 49 - j, \n         'M': 100, 'tau': 0.01, 'g': 500},\n        # Case 2: Boundary for strict partial pivoting\n        {'n': 50, 'epsilon': 0.05, 'J': set(range(10)), 'r_map': lambda j: 49 - j, \n         'M': 100, 'tau': 1.0, 'g': 500},\n        # Case 3: Smaller dimension, moderate rogue entries, threshold too high\n        {'n': 12, 'epsilon': 0.02, 'J': set(range(6)), 'r_map': lambda j: 11 - j, \n         'M': 50, 'tau': 0.05, 'g': 250},\n        # Case 4: Edge case of always-diagonal pivoting (no pivoting)\n        {'n': 20, 'epsilon': 0.02, 'J': set(range(8)), 'r_map': lambda j: 19 - j, \n         'M': 500, 'tau': 0.0, 'g': 5000},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_factorization_analysis(\n            n=case['n'],\n            epsilon=case['epsilon'],\n            J=case['J'],\n            r_map=case['r_map'],\n            M=case['M'],\n            tau_thresh=case['tau'],\n            g=case['g']\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[true,true],[false,true],...]\n    formatted_results = []\n    for res_pair in results:\n        s = f\"[{str(res_pair[0]).lower()},{str(res_pair[1]).lower()}]\"\n        formatted_results.append(s)\n    \n    final_string = f\"[{','.join(formatted_results)}]\"\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在数值稳定性分析中，获得一个小的范数反向误差是一个标准目标，但这并不能保证分量级别的准确性，对于病态缩放的矩阵尤其如此。这项高级计算练习将通过分析一个缩放后的 Kahan 型矩阵在不同主元策略下的 LU 分解，来挑战您对这一微妙之处的理解 。通过实现部分主元法、Rook 主元法和完全主元法，并比较范数反向误差与分量反向误差，您将对“数值稳定性”在不同情境下的含义建立起更细致的认识。",
            "id": "3591252",
            "problem": "考虑对一族缩放后的 Kahan 型矩阵应用行和列置换的 LU 分解。对于整数大小 $n \\geq 2$，参数 $\\sigma \\in (0,1)$ 和列缩放参数 $s \\in (0,1]$，定义未缩放的 Kahan 型矩阵 $B \\in \\mathbb{R}^{n \\times n}$ 为\n$$\nb_{ij} = \\begin{cases}\n1,  i \\leq j, \\\\\n-\\sigma,  i  j,\n\\end{cases}\n$$\n并定义对角列缩放矩阵 $S \\in \\mathbb{R}^{n \\times n}$ 为\n$$\nS = \\mathrm{diag}(1, s, s^2, \\dots, s^{n-1}).\n$$\n缩放后的 Kahan 矩阵为\n$$\nA = B S,\n$$\n因此 $A$ 的第 $j$ 列等于 $B$ 的第 $j$ 列乘以 $s^{j-1}$。注意，对于 $\\sigma \\in (0,1)$ 和 $s \\in (0,1]$，矩阵 $A$ 的所有元素都是非零的。\n\n对于主元选择策略，定义以下三种高斯消元算法：\n- 部分主元法 (PP)：在第 $k$ 步，在第 $k$ 列的第 $k,k+1,\\dots,n$ 行中选择绝对值最大的元素作为主元；执行一次行交换，然后进行消元。\n- 完全主元法 (CP)：在第 $k$ 步，在由第 $k,k+1,\\dots,n$ 行和列定义的子矩阵中选择绝对值最大的元素作为主元；执行一次行交换和一次列交换，然后进行消元。\n- 车象主元法 (RP)：在第 $k$ 步，从第 $k$ 列开始，在第 $k,\\dots,n$ 行中找到该列绝对值最大的元素所在的行 $p$，然后在该行中找到第 $k,\\dots,n$ 列中绝对值最大的元素所在的列 $q$；如果 $(p,q)$ 位置的元素在第 $q$ 列中也是最大的，则接受它作为主元；否则，迭代行/列搜索，直到在尾随子矩阵中找到一个在其当前行和列中同时是最大的元素，然后执行相应的行和列交换并进行消元。\n\n设 $P \\in \\mathbb{R}^{n \\times n}$ 和 $Q \\in \\mathbb{R}^{n \\times n}$ 为置换矩阵，使得对于所选策略，计算出的因子满足\n$$\nP A Q = L U,\n$$\n其中 $L \\in \\mathbb{R}^{n \\times n}$ 是单位下三角矩阵，$U \\in \\mathbb{R}^{n \\times n}$ 是上三角矩阵。分解的向后误差由扰动\n$$\n\\Delta A = P^\\top L U Q^\\top - A,\n$$\n度量，它量化了计算出的因子与原始矩阵 $A$ 的精确分解之间的差异。\n\n通过 Frobenius 范数定义范数相对向后误差\n$$\n\\beta_{\\mathrm{norm}} = \\frac{\\lVert \\Delta A \\rVert_F}{\\lVert A \\rVert_F},\n$$\n并定义分量相对向后误差为\n$$\n\\beta_{\\mathrm{comp}} = \\max_{1 \\leq i,j \\leq n} \\frac{|\\Delta A_{ij}|}{|A_{ij}|}.\n$$\n假设在双精度浮点数算术下进行计算，机器精度为 $\\epsilon$，并定义增长因子估计为\n$$\ng = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}.\n$$\n\n任务：\n1. 实现三种主元策略（PP、CP、RP）的 LU 分解，并为给定的输入矩阵 $A$ 计算 $P$、$L$、$U$ 和 $Q$。\n2. 对每个分解，计算上文定义的 $\\beta_{\\mathrm{norm}}$、$\\beta_{\\mathrm{comp}}$ 和 $g$。\n3. 使用基于浮点舍入误差传播的原则性预测器，根据以下准则预测分量误差是否在范数误差很小的情况下占主导地位：\n$$\n\\text{预测主导性} \\iff \\left(\\beta_{\\mathrm{norm}}  10^{-12}\\right) \\;\\text{and}\\; \\left(\\epsilon \\, g \\, \\frac{\\lVert A \\rVert_F}{\\min_{i,j} |A_{ij}|}  10^{-6}\\right).\n$$\n该预测器模拟了这样一个事实：大小为 $\\mathcal{O}(\\epsilon)$ 的舍入误差经增长因子 $g$ 缩放后，可以在 $\\Delta A$ 中产生一些项，这些项与 $A$ 的最小元素相比，其相对影响可能不成比例地大，即使整体范数误差非常小。\n\n4. 比较不同主元策略和矩阵下的范数和分量向后误差，并报告每种情况下预测器是否标记了分量误差占主导地位。\n\n设计您的程序以运行以下 $(n, \\sigma, s)$ 测试套件：\n- 案例 1（基线，无列缩放）：$n = 10$, $\\sigma = 0.99$, $s = 1$。\n- 案例 2（中等缩放）：$n = 10$, $\\sigma = 0.99$, $s = 10^{-4}$。\n- 案例 3（极端缩放）：$n = 12$, $\\sigma = 0.999$, $s = 10^{-8}$。\n\n对于每种情况，评估所有三种主元策略（PP、RP、CP），并按以下顺序将九个预测（三种策略乘以三种情况）作为布尔值输出：\n$$\n[\\text{案例 1 PP}, \\text{案例 1 RP}, \\text{案例 1 CP}, \\text{案例 2 PP}, \\text{案例 2 RP}, \\text{案例 2 CP}, \\text{案例 3 PP}, \\text{案例 3 RP}, \\text{案例 3 CP}].\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[{\\tt result1},{\\tt result2},\\dots,{\\tt result9}]$）。不涉及物理单位；所有量纲均为无量纲。此计算不涉及角度。所有输出均为布尔值，必须严格按照 Python 的布尔文本形式打印。",
            "solution": "用户提供了一个数值线性代数问题，涉及一族缩放 Kahan 型矩阵的 LU 分解。任务要求实现三种不同的主元选择策略，计算向后误差度量，并评估一个用于分量误差主导性的预测器。\n\n### 步骤 1：提取已知信息\n-   **矩阵定义**：$A = B S \\in \\mathbb{R}^{n \\times n}$，其中 $n \\geq 2$ 是一个整数。\n-   **未缩放矩阵 $B$**：对于参数 $\\sigma \\in (0,1)$，$b_{ij} = 1$ (如果 $i \\leq j$)，$b_{ij} = -\\sigma$ (如果 $i  j$)。\n-   **缩放矩阵 $S$**：对于参数 $s \\in (0,1]$，$S = \\mathrm{diag}(1, s, s^2, \\dots, s^{n-1})$。\n-   **分解**：$P A Q = L U$，其中 $P, Q$ 是置换矩阵，$L$ 是单位下三角矩阵，$U$ 是上三角矩阵。\n-   **主元选择策略**：\n    1.  部分主元法 (PP)：主元是子矩阵当前列中绝对值最大的元素。$Q$ 是单位矩阵。\n    2.  完全主元法 (CP)：主元是整个子矩阵中绝对值最大的元素。\n    3.  车象主元法 (RP)：主元是通过迭代搜索找到的，在子矩阵的行和列中均为最大值。\n-   **向后误差矩阵**：$\\Delta A = P^\\top L U Q^\\top - A$。\n-   **范数相对向后误差**：$\\beta_{\\mathrm{norm}} = \\frac{\\lVert \\Delta A \\rVert_F}{\\lVert A \\rVert_F}$。\n-   **分量相对向后误差**：$\\beta_{\\mathrm{comp}} = \\max_{1 \\leq i,j \\leq n} \\frac{|\\Delta A_{ij}|}{|A_{ij}|}$。\n-   **增长因子估计**：$g = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}$。\n-   **计算环境**：双精度浮点运算，机器精度为 $\\epsilon$。\n-   **预测准则**：当且仅当 $(\\beta_{\\mathrm{norm}}  10^{-12}) \\land (\\epsilon \\, g \\, \\frac{\\lVert A \\rVert_F}{\\min_{i,j} |A_{ij}|}  10^{-6})$ 时，预测分量误差占主导地位。\n-   **测试案例**：\n    -   案例 1：$n=10, \\sigma=0.99, s=1$。\n    -   案例 2：$n=10, \\sigma=0.99, s=10^{-4}$。\n    -   案例 3：$n=12, \\sigma=0.999, s=10^{-8}$。\n-   **输出**：一个包含九个布尔值的列表，每个值对应一个（案例，策略）对，顺序为 `[Case1-PP, Case1-RP, Case1-CP, Case2-PP, Case2-RP, Case2-CP, Case3-PP, Case3-RP, Case3-CP]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题具有科学依据，是适定且客观的。\n-   **科学依据**：该问题位于数值线性代数的核心领域，涉及基本算法高斯消元的稳定性。Kahan 型矩阵的使用、各种主元选择策略、增长因子和向后误差分析都是该领域标准的、成熟的概念。预测启发式算法基于浮点误差传播的可靠原理。\n-   **适定性**：矩阵、算法和度量的定义是精确且无歧义的。对于一组给定的参数和指定的主元选择策略，在固定的浮点算术模型下，计算会产生一个确定性的结果。问题是自包含且完全指定的。\n-   **客观性**：语言纯粹是数学性的，没有主观性或观点。预测准则是一个严格的不等式。\n\n该问题**没有**验证清单中列出的任何缺陷。这是数值分析中一个严谨且重要的计算练习。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 解法\n该解法涉及实现三种不同主元策略的 LU 分解，计算稳定性和误差度量，并评估一个用于病态缩放效应的预测性启发式算法。\n\n**1. 矩阵构造**\n\n对于给定的参数 $n$、$\\sigma$ 和 $s$，构造缩放后的 Kahan 型矩阵 $A \\in \\mathbb{R}^{n \\times n}$。其元素 $A_{ij}$ 由 $A_{ij} = B_{ij} s^{j-1}$ 给出，其中 $j$ 是基于 1 的列索引。未缩放矩阵 $B$ 的元素为：当 $i \\le j$ 时 $b_{ij}=1$，当 $i  j$ 时 $b_{ij}=-\\sigma$。对于 $s  1$，这种构造导致矩阵的列范数呈几何级数递减，从而导致不良缩放。最大与最小元素绝对值之比 $\\frac{\\max|A_{ij}|}{\\min|A_{ij}|}$ 变得非常大，这种情况会降低数值算法的分量精度。\n\n**2. 带主元选择的 LU 分解**\n\n任务的核心是实现高斯消元法，在每一步 $k$（从 $k=0$到$n-1$），根据特定策略从尾随子矩阵 $A^{(k)}[k:n, k:n]$ 中选择一个主元，执行行和/或列交换，然后消去主元下方的元素。这个过程计算出分解 $PAQ=LU$，其中 $P$ 和 $Q$ 分别是编码行交换和列交换的置换矩阵。\n\n-   **部分主元法 (PP)**：在第 $k$ 步，选择主元 $A_{rk}^{(k)}$ 使得 $|A_{rk}^{(k)}| = \\max_{k \\le i  n} |A_{ik}^{(k)}|$。在第 $k$ 行和第 $r$ 行之间进行行交换。这里，$Q$ 是单位矩阵。这个策略计算效率高，但对某些矩阵可能不稳定，尽管在实践中对大多数矩阵是稳定的。\n-   **完全主元法 (CP)**：在第 $k$ 步，选择主元 $A_{rc}^{(k)}$ 使得 $|A_{rc}^{(k)}| = \\max_{k \\le i,j  n} |A_{ij}^{(k)}|$。同时进行行交换（$k \\leftrightarrow r$）和列交换（$k \\leftrightarrow c$）。这个策略被证明是稳定的，具有最小的最坏情况增长因子，但会产生巨大的搜索开销，使其在实践中不太常用。\n-   **车象主元法 (RP)**：该策略是 PP 和 CP 之间的一种折衷。在第 $k$ 步，它在子矩阵 $A^{(k)}[k:n, k:n]$ 中搜索一个在其行和列中均为最大的元素。搜索是迭代的：在某一列中找到最大的元素，然后在这个元素的所在行中找到最大的元素。如果这个新元素在不同的列中，则重复搜索。这个过程会收敛到一个合适的主元。它提供了比 PP 更好的稳定性，同时开销比 CP 小。\n\n实现了一个原地算法，将 $L$ 的乘子存储在矩阵 $A$ 的下三角部分，将得到的上三角矩阵 $U$ 存储在 $A$ 的上三角和对角线部分。使用向量 $p$ 和 $q$ 来跟踪置换，它们记录了每个原始行和列的最终位置。\n\n**3. 误差与稳定性度量**\n\n分解之后，根据计算出的因子 $\\hat{L}$ 和 $\\hat{U}$ 以及置换矩阵 $P$ 和 $Q$ 重构原始矩阵 $A$，即 $A_{\\text{recon}} = P^\\top \\hat{L} \\hat{U} Q^\\top$。然后向后误差为 $\\Delta A = A_{\\text{recon}} - A$。\n根据 $\\Delta A$，我们计算：\n-   范数相对向后误差 $\\beta_{\\mathrm{norm}} = \\frac{\\lVert \\Delta A \\rVert_F}{\\lVert A \\rVert_F}$。这在平均、均方根的意义上度量了扰动 $\\Delta A$ 相对于 $A$ 的大小。一个小的 $\\beta_{\\mathrm{norm}}$（通常为 $\\epsilon$ 量级）表示范数稳定性。\n-   分量相对向后误差 $\\beta_{\\mathrm{comp}} = \\max_{i,j} \\frac{|\\Delta A_{ij}|}{|A_{ij}|}$。这度量了 $A$ 中任意单个元素的最坏情况相对误差。即使 $\\beta_{\\mathrm{norm}}$ 很小，它也可能很大，特别是当 $A$ 包含数量级差异很大的元素时。\n-   增长因子 $g = \\frac{\\max_{i,j} |U_{ij}|}{\\max_{i,j} |A_{ij}|}$ 量化了消元过程中元素数量级增加的程度。大的 $g$ 是潜在数值不稳定的迹象。\n\n**4. 分量主导性预测**\n\n最后一步是应用给定的预测准则：\n$$\n\\left(\\beta_{\\mathrm{norm}}  10^{-12}\\right) \\;\\text{and}\\; \\left(\\epsilon \\, g \\, \\frac{\\lVert A \\rVert_F}{\\min_{i,j} |A_{ij}|}  10^{-6}\\right)\n$$\n第一个条件 $\\beta_{\\mathrm{norm}}  10^{-12}$ 检查范数稳定性。第二个条件启发式地估计分量误差是否可能较大。项 $\\frac{\\lVert A \\rVert_F}{\\min_{i,j} |A_{ij}|}$ 作为矩阵缩放质量的度量。值越大表明缩放性越差。该预测器假定，如果算法是范数稳定的，但矩阵缩放不良，大小为 $\\mathcal{O}(\\epsilon g \\max|A_{ij}|)$ 的舍入误差相对于最小元素 $\\min|A_{ij}|}$ 可能会很大，从而导致大的分量向后误差。程序为测试用例和主元策略定义的九种场景中的每一种评估此布尔条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_kahan_matrix(n: int, sigma: float, s: float) - np.ndarray:\n    \"\"\"\n    Constructs the scaled Kahan-type matrix A.\n    A_{ij} = B_{ij} * s^(j-1), where j is a 1-based index.\n    \"\"\"\n    B = np.ones((n, n), dtype=np.float64)\n    rows, cols = np.tril_indices(n, k=-1)\n    B[rows, cols] = -sigma\n    \n    # Create scaling vector with powers s^k for k=0 to n-1\n    s_powers = np.power(s, np.arange(n, dtype=np.float64))\n    \n    # Apply column scaling via broadcasting\n    A = B * s_powers\n    return A\n\ndef lu_factor(A: np.ndarray, strategy: str) - tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"\n    Performs LU factorization with pivoting on matrix A in-place.\n    Returns:\n        A: Modified matrix containing L (without diagonal) and U.\n        p_vec: Final row permutation vector. p_vec[i] is the original row index at new row i.\n        q_vec: Final column permutation vector. q_vec[i] is the original col index at new col i.\n    \"\"\"\n    n = A.shape[0]\n    p_vec = np.arange(n)\n    q_vec = np.arange(n)\n\n    for k in range(n):\n        # --- Pivoting ---\n        if strategy == 'PP':\n            # Partial Pivoting: find pivot in column k\n            sub_col = A[k:, k]\n            r_sub = np.argmax(np.abs(sub_col))\n            r, c = k + r_sub, k\n        elif strategy == 'CP':\n            # Complete Pivoting: find pivot in submatrix A[k:, k:]\n            sub_matrix = A[k:, k:]\n            r_sub, c_sub = np.unravel_index(np.argmax(np.abs(sub_matrix)), sub_matrix.shape)\n            r, c = k + r_sub, k + c_sub\n        elif strategy == 'RP':\n            # Rook Pivoting: iterative search for equilibrium\n            r_search, c_search = k, k\n            while True:\n                # Find best row for current column c_search\n                r_current = k + np.argmax(np.abs(A[k:, c_search]))\n                # Find best column for that row r_current\n                c_current = k + np.argmax(np.abs(A[r_current, k:]))\n                \n                if c_current == c_search:\n                    r, c = r_current, c_current\n                    break\n                else:\n                    c_search = c_current\n        else:\n            raise ValueError(f\"Unknown pivot strategy: {strategy}\")\n\n        # --- Permutations ---\n        if k != r:\n            A[[k, r], :] = A[[r, k], :]\n            p_vec[[k, r]] = p_vec[[r, k]]\n        \n        if k != c:\n            A[:, [k, c]] = A[:, [c, k]]\n            q_vec[[k, c]] = q_vec[[c, k]]\n\n        # --- Elimination ---\n        if k  n - 1:\n            pivot_val = A[k, k]\n            if np.abs(pivot_val)  1e-30:  # Matrix is effectively singular\n                continue\n            \n            multipliers = A[k+1:, k] / pivot_val\n            A[k+1:, k] = multipliers\n            A[k+1:, k+1:] -= np.outer(multipliers, A[k, k+1:])\n            \n    return A, p_vec, q_vec\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (10, 0.99, 1.0),       # Case 1\n        (10, 0.99, 1e-4),      # Case 2\n        (12, 0.999, 1e-8),     # Case 3\n    ]\n    pivot_strategies = ['PP', 'RP', 'CP']\n    \n    results = []\n    epsilon = np.finfo(np.float64).eps\n\n    for n, sigma, s in test_cases:\n        for strategy in pivot_strategies:\n            # 1. Build original matrix\n            A_orig = build_kahan_matrix(n, sigma, s)\n\n            # 2. Perform LU factorization\n            LU_factors, p_vec, q_vec = lu_factor(A_orig.copy(), strategy)\n            \n            # 3. Extract L and U factors\n            L = np.tril(LU_factors, -1) + np.eye(n)\n            U = np.triu(LU_factors)\n\n            # 4. Reconstruct A from factors: A_recon = P.T @ L @ U @ Q.T\n            # This is equivalent to un-doing the permutations.\n            # A_recon[p, :] = (L@U @ Q.T)\n            # A_recon[p, q] = L@U\n            A_recon = np.zeros_like(A_orig)\n            lu_prod = L @ U\n            # Un-permute columns\n            A_recon_perm_rows = np.zeros_like(A_orig)\n            A_recon_perm_rows[:, q_vec] = lu_prod\n            # Un-permute rows\n            A_recon[p_vec, :] = A_recon_perm_rows\n\n            # 5. Calculate backward error and related metrics\n            delta_A = A_recon - A_orig\n\n            norm_A = np.linalg.norm(A_orig, 'fro')\n            norm_delta_A = np.linalg.norm(delta_A, 'fro')\n            \n            beta_norm = norm_delta_A / norm_A if norm_A  0 else 0.0\n\n            max_A = np.max(np.abs(A_orig))\n            max_U = np.max(np.abs(U))\n            g = max_U / max_A if max_A  0 else 0.0\n\n            # 6. Evaluate the prediction criterion\n            min_abs_A = np.min(np.abs(A_orig))\n            \n            # This check avoids division by zero, though the problem states entries are non-zero.\n            if min_abs_A  0:\n                predictor_val = epsilon * g * norm_A / min_abs_A\n            else:\n                predictor_val = float('inf')\n            \n            prediction = (beta_norm  1e-12) and (predictor_val  1e-6)\n            results.append(prediction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}