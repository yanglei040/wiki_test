{
    "hands_on_practices": [
        {
            "introduction": "在数值线性代数中，算法的稳定性和精度至关重要。本练习通过一个含有极小元素的简单 $2 \\times 2$ 矩阵，直观地揭示了标准 LU 分解在面对不良主元时可能引发的数值不稳定问题。通过对比有无部分主元法的计算结果，你将深刻理解为何部分主元法是保证计算结果可靠性的关键策略。",
            "id": "1383205",
            "problem": "考虑矩阵 $A$ 定义如下：\n$$\nA = \\begin{pmatrix} \\epsilon & 2 \\\\ 1 & 3 \\end{pmatrix}\n$$\n其中 $\\epsilon = 10^{-8}$ 是一个很小的正常数。\n\n我们将对矩阵 $A$ 进行两种类型的 LU 分解。\n\n首先，求 $A$ 的标准 LU 分解，使得 $A = LU$。在此分解中，$L$ 是一个单位下三角矩阵（主对角线上的元素为1），$U$ 是一个上三角矩阵。设矩阵 $U$ 的第二行第二列的元素记为 $u_{22}$。\n\n其次，使用部分主元法求 $A$ 的 LU 分解。该策略得到一个形式为 $PA = L'U'$ 的分解，其中 $P$ 是一个置換矩阵，选择 $P$ 是为了最大化每列主元的绝对值，$L'$ 是一个单位下三角矩阵，$U'$ 是一个上三角矩阵。设矩阵 $U'$ 的第二行第二列的元素记为 $u'_{22}$。\n\n计算和 $u_{22} + u'_{22}$ 的数值。",
            "solution": "我们使用不含主元选择的 Doolittle LU 分解，然后使用含部分主元选择的 Doolittle LU 分解。\n\n不使用主元选择时，记 $A=LU$ 如下：\n$$\nL=\\begin{pmatrix}1 & 0\\\\ \\ell_{21} & 1\\end{pmatrix},\\quad\nU=\\begin{pmatrix}u_{11} & u_{12}\\\\ 0 & u_{22}\\end{pmatrix}.\n$$\n与 $A=\\begin{pmatrix}\\epsilon & 2\\\\ 1 & 3\\end{pmatrix}$ 匹配可得标准关系式：\n$$\nu_{11}=a_{11}=\\epsilon,\\quad u_{12}=a_{12}=2,\\quad \\ell_{21}=\\frac{a_{21}}{u_{11}}=\\frac{1}{\\epsilon},\n$$\n以及\n$$\nu_{22}=a_{22}-\\ell_{21}u_{12}=3-\\frac{1}{\\epsilon}\\cdot 2=3-\\frac{2}{\\epsilon}.\n$$\n\n使用部分主元选择时，因为 $|1|>|\\,\\epsilon\\,|$，我们首先交换行，得到\n$$\nPA=\\begin{pmatrix}1 & 3\\\\ \\epsilon & 2\\end{pmatrix}.\n$$\n分解 $PA=L'U'$ 如下：\n$$\nL'=\\begin{pmatrix}1 & 0\\\\ \\ell'_{21} & 1\\end{pmatrix},\\quad\nU'=\\begin{pmatrix}u'_{11} & u'_{12}\\\\ 0 & u'_{22}\\end{pmatrix}.\n$$\n则\n$$\nu'_{11}=1,\\quad u'_{12}=3,\\quad \\ell'_{21}=\\frac{\\epsilon}{u'_{11}}=\\epsilon,\n$$\n以及\n$$\nu'_{22}=2-\\ell'_{21}u'_{12}=2-3\\epsilon.\n$$\n\n因此，\n$$\nu_{22}+u'_{22}=\\left(3-\\frac{2}{\\epsilon}\\right)+(2-3\\epsilon)=5-\\frac{2}{\\epsilon}-3\\epsilon.\n$$\n代入 $\\epsilon=10^{-8}$：\n$$\n\\frac{2}{\\epsilon}=2\\times 10^{8},\\qquad 3\\epsilon=3\\times 10^{-8},\n$$\n所以\n$$\nu_{22}+u'_{22}=5-2\\times 10^{8}-3\\times 10^{-8}=-199999995.00000003.\n$$",
            "answer": "$$\\boxed{-199999995.00000003}$$"
        },
        {
            "introduction": "理解了部分主元法的重要性之后，掌握其具体操作步骤便是下一步。本练习提供了一个 $4 \\times 4$ 矩阵，其初始主元为零，因此必须进行行交换。通过手动执行高斯消元法，你将实践如何一步步地识别主元、执行行交换、计算乘子以及最终得到 $P$、$L$ 和 $U$ 矩阵，从而巩固对 $PA=LU$ 分解过程的机械理解。",
            "id": "1029963",
            "problem": "考虑矩阵 $A$ 定义如下：\n$$\nA = \\begin{pmatrix}\n0 & 1 & 1 & 0 \\\\\n2 & 1 & 0 & 1 \\\\\n1 & 0 & 2 & 1 \\\\\n0 & 1 & 1 & 1\n\\end{pmatrix}\n$$\n\n计算 $A$ 的带部分主元法的 $PA=LU$ 分解，其中 $P$ 是一个置换矩阵，$L$ 是一个下三角矩阵，$U$ 是一个上三角矩阵，使得 $PA = LU$。计算出分解后，给出 $L$ 矩阵的第三行第二列的元素。请将您的答案表示为最简分数。",
            "solution": "我们通过带部分主元法的高斯消元法来寻求一个 $P\\,A=L\\,U$ 分解。\n\n初始矩阵：\n$$\nA=\\begin{pmatrix}\n0 & 1 & 1 & 0\\\\\n2 & 1 & 0 & 1\\\\\n1 & 0 & 2 & 1\\\\\n0 & 1 & 1 & 1\n\\end{pmatrix}.\n$$\n\n第 1 步（第 1 列）：对于 $i=1\\ldots4$，$|a_{i1}|$ 的最大值是位于 $i=2$ 处的 $|2|$，因此交换第 1 行和第 2 行。定义\n$$\nP_1=\\begin{pmatrix}\n0 & 1 & 0 & 0\\\\\n1 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & 1\n\\end{pmatrix},\\quad\nP_1A=\\begin{pmatrix}\n2 & 1 & 0 & 1\\\\\n0 & 1 & 1 & 0\\\\\n1 & 0 & 2 & 1\\\\\n0 & 1 & 1 & 1\n\\end{pmatrix}.\n$$\n主元 $a_{11}=2$。计算乘数\n$$\n\\ell_{21}=0,\\quad \\ell_{31}=\\frac12,\\quad \\ell_{41}=0.\n$$\n消去第 3 行：\n$$\n(1,0,2,1)-\\tfrac12(2,1,0,1)=(0,-\\tfrac12,2,\\tfrac12).\n$$\n经过第一步消元后的矩阵为：\n$$\n\\begin{pmatrix}\n2 & 1 & 0 & 1\\\\\n0 & 1 & 1 & 0\\\\\n0 & -\\tfrac12 & 2 & \\tfrac12\\\\\n0 & 1 & 1 & 1\n\\end{pmatrix}.\n$$\n\n第 2 步（第 2 列）：在第 2-4 行中，$|a_{i2}|$ 的最大值是位于第 2 行和第 4 行的 1（无需交换，选择第一个）。主元 $a_{22}=1$。乘数\n$$\n\\ell_{32}=-\\tfrac12,\\quad \\ell_{42}=1.\n$$\n消元：\n$$\n\\text{第3行}:(0,-\\tfrac12,2,\\tfrac12)-(-\\tfrac12)(0,1,1,0)=(0,0,\\tfrac52,\\tfrac12),\n$$\n$$\n\\text{第4行}:(0,1,1,1)-(0,1,1,0)=(0,0,0,1).\n$$\n\n第 3 步（第 3 列）：在第 3-4 行之间，主元是 $a_{33}=\\tfrac52$（无需交换），乘数 $\\ell_{43}=0$。\n\n这些计算出的乘数构成了 $L$ 矩阵的非对角线元素。因此，$L$ 的 $(3,2)$ 元素是 $\\ell_{32}$，即\n$$\nL_{3,2}=-\\tfrac12.\n$$",
            "answer": "$$\\boxed{-\\frac{1}{2}}$$"
        },
        {
            "introduction": "将算法理论转化为可执行代码是掌握任何数值方法的最终环节。这项综合性练习将引导你设计并实现一个高效的、就地（in-place）执行的 $PA=LU$ 分解算法。你需要解决诸如如何紧凑地存储置换信息和如何验证分解正确性等实际问题，从而将理论知识与实用的编程技能联系起来。",
            "id": "3558119",
            "problem": "您必须设计并分析一个用于高斯消元法（带部分主元法）的原位算法，以计算实数方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的 $PA = LU$ 分解，其中 $P$ 是一个置换矩阵，$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。该算法必须原位覆写输入数组 $A$，使得最终数组的严格下三角部分存储 $L$ 的乘子（即 $L$ 的严格下三角部分），而上三角部分（包括对角线）存储 $U$ 的元素。您必须指定在何处以及如何存储由部分主元法产生的置换信息，并且除了输入数组 $A$ 之外，只能使用 $\\mathcal{O}(n)$ 的额外存储空间。\n\n您的推导必须从基本定义出发：矩阵乘法、置换矩阵、三角矩阵、弗罗贝尼乌斯范数 $\\|\\cdot\\|_F$ 以及高斯消元过程。您必须设计一个分步的消元策略，在每一步 $k \\in \\{0,\\dots,n-1\\}$ 中，在第 $k$ 列的第 $k$ 行到第 $n-1$ 行中，使用具有最大绝对值主元的行，然后执行一次行交换，计算乘子，并对尾随子矩阵进行一次秩-1 更新。您的设计必须包含：\n- 如何将置换信息存储在一个独立的整数向量 $p \\in \\{0,\\dots,n-1\\}^n$ 中的精确规范，该向量记录了在每一步 $k$ 中与第 $k$ 行交换的行索引 $p[k]$。请使用从零开始的索引。如果步骤 $k$ 不需要交换，则设置 $p[k] = k$。\n- 从 $p$ 重构置换矩阵 $P$ 的精确规则，通过复合由 $p[0],p[1],\\dots,p[n-1]$ 编码的对换序列来实现。\n- 算法终止后如何从被覆写的数组中提取 $L$ 和 $U$ 的说明：$L = \\operatorname{tril}(A,-1) + I$ 和 $U = \\operatorname{triu}(A)$，其中 $I$ 是单位矩阵。\n\n您的程序必须实现这个用于 $PA=LU$ 分解（带部分主元法）的原位算法，并且必须在以下测试集上验证其正确性。对于每个矩阵 $A_i$，请执行以下操作：\n- 创建一个工作副本 $\\widetilde{A}_i$ 传递给您的原位例程，以便原始的 $A_i$ 仍可用于验证。\n- 在 $\\widetilde{A}_i$ 上运行您的原位分解，获得编码了 $L_i$ 和 $U_i$ 的修改后数组以及编码了行交换序列的主元向量 $p_i$。\n- 从 $p_i$ 重构 $P_i$。\n- 使用 $L_i = \\operatorname{tril}(\\widetilde{A}_i,-1)+I$ 和 $U_i=\\operatorname{triu}(\\widetilde{A}_i)$ 从修改后的 $\\widetilde{A}_i$ 中提取 $L_i$ 和 $U_i$。\n- 计算弗罗贝尼乌斯残差 $R_i = \\|P_i A_i - L_i U_i\\|_F$。\n- 令 $s_i$ 为满足 $p_i[k] \\neq k$ 的索引 $k \\in \\{0,\\dots,n-1\\}$ 的数量（即实际执行的对换次数）。通过检查定义为 $\\det(P_i) = (-1)^{s_i}$ 的布尔值 $B_i$ 来验证置换奇偶性恒等式。\n\n测试集（所有元素均为实数）：\n- $A_1 = \\begin{bmatrix} 0 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 10 \\end{bmatrix}$。\n- $A_2 = \\begin{bmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 1 & 2 & 3 \\\\ 0 & 4 & 5 & 6 \\\\ 0 & 7 & 8 & 9 \\end{bmatrix}$。\n- $A_3 = \\begin{bmatrix} 5.5 \\end{bmatrix}$。\n- $A_4 = \\begin{bmatrix} 10^{-20} & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1.0001 & 1 & 1 \\\\ 1 & 1 & 1 & 1.0002 & 1 \\\\ 1 & 1 & 1 & 1 & 1.0003 \\end{bmatrix}$。\n- $A_5 = \\begin{bmatrix} 1 & 3 & 1 & 5 \\\\ 2 & 6 & 4 & 8 \\\\ 1 & 0 & 0 & 3 \\\\ 2 & 1 & 7 & 9 \\end{bmatrix}$。\n\n边界情况处理：\n- 如果在步骤 $k$ 中，所有候选元素 $|A_{ik}|$（对于 $i \\in \\{k,\\dots,n-1\\}$）均为零，则设置 $p[k]=k$，保持对角线下方的列元素不变（等效于将乘子设置为零），并跳过该步骤的秩-1 更新。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[R_1,B_1,R_2,B_2,R_3,B_3,R_4,B_4,R_5,B_5]$，其中每个 $R_i$ 是一个浮点数，每个 $B_i$ 是一个布尔值。不需要单位或四舍五入；请打印原始浮点值。\n\n您的算法设计、其数学证明以及实现必须一致、科学合理，并基于上述定义和性质。不允许使用其他输入或文件，也不允许用户交互。代码必须是一个完整、可运行的程序。",
            "solution": "该问题要求设计、分析并实现一个用于高斯消元法（带部分主元法）的原位算法，以计算 $PA = LU$ 分解。这里，$A \\in \\mathbb{R}^{n \\times n}$ 是一个给定的方阵，$P$ 是一个置换矩阵，$L$ 是一个单位下三角矩阵，$U$ 是一个上三角矩阵。推导过程必须基于基本原理。\n\n我们首先定义主要目标。高斯消元法旨在通过应用一系列基本行操作，将矩阵 $A$ 转换为一个上三角矩阵 $U$。每个这样的操作都可以表示为与一个初等矩阵进行左乘。具体来说，为了消除第 $k$ 列对角线以下的元素，我们使用一个高斯变换矩阵 $M_k$。\n\n过程始于 $A^{(0)} = A$。对于每一列 $k \\in \\{0, 1, \\dots, n-2\\}$，我们试图在主元元素 $A_{k,k}^{(k)}$下方引入零。对于每一行 $i \\in \\{k+1, \\dots, n-1\\}$，操作为 $R_i \\leftarrow R_i - m_{i,k} R_k$，其中 $m_{i,k} = A_{i,k}^{(k)} / A_{k,k}^{(k)}$ 是乘子。这等价于左乘一个单位下三角矩阵 $M_k = I - \\sum_{i=k+1}^{n-1} m_{i,k} e_i e_k^T$，其中 $e_i$ 是第 $i$ 个标准基向量。经过 $n-1$ 步后，我们得到 $M_{n-2} \\dots M_1 M_0 A = U$。乘积 $L = (M_{n-2} \\dots M_0)^{-1} = M_0^{-1} M_1^{-1} \\dots M_{n-2}^{-1}$ 是一个单位下三角矩阵，其严格下三角元素恰好是乘子 $m_{i,k}$。这就得到了 $A=LU$ 分解。\n\n如果主元元素 $A_{k,k}^{(k)}$ 为零，此过程将失败。即使它非零但数值很小，使用它也可能导致矩阵元素值的灾难性增长，从而引起巨大的舍入误差。部分主元法是减轻这种不稳定性的策略。在每一步 $k$，我们在当前第 $k$ 列的第 $k$ 行到第 $n-1$ 行中搜索绝对值最大的元素。假设这个元素在第 $i_{max}$ 行。然后在执行消元之前，我们交换第 $k$ 行和第 $i_{max}$ 行。这确保了乘子的绝对值 $|m_{i,k}|$ 始终小于或等于 $1$。\n\n每次行交换都可以表示为与一个置换矩阵 $P_k$ 进行左乘，该矩阵是单位矩阵交换了第 $k$ 行和第 $i_{max}$ 行。因此，在步骤 $k$ 的算法变为：\n$1$. 找到 $i_{max} \\in \\{k, \\dots, n-1\\}$，使得 $|A_{i,k}^{(k)}|$ 最大。\n$2$. 交换第 $k$ 行和第 $i_{max}$ 行。即 $A'^{(k)} = P_k A^{(k)}$。\n$3$. 计算高斯变换 $M_k$ 以消去 $A'^{(k)}$ 第 $k$ 列对角线以下的元素。\n$4$. 下一步的矩阵是 $A^{(k+1)} = M_k A'^{(k)} = M_k P_k A^{(k)}$。\n\n经过 $n-1$ 步后（对于 $k=0, \\dots, n-2$），我们得到：\n$$ U = A^{(n-1)} = (M_{n-2} P_{n-2}) \\dots (M_0 P_0) A $$\n这还不是 $PA=LU$ 的形式。然而，利用置换矩阵可以移动到高斯变换矩阵之后的性质（代价是置换变换矩阵内的乘子），即对于 $j < k$ 有 $P_k M_j = M'_j P_k$，我们可以将表达式重新排列为：\n$$ U = (M'_{n-2} \\dots M'_0) (P_{n-2} \\dots P_0) A $$\n其中 $M'_j$ 是高斯变换矩阵，其乘子根据后续的行交换进行了置换。令 $P = P_{n-2} \\dots P_0$ 且 $L^{-1} = M'_{n-2} \\dots M'_0$。这给了我们 $PA=LU$。矩阵 $L = (L^{-1})^{-1}$ 是单位下三角矩阵，其次对角线元素是在消元过程中计算出的乘子，但经过了行交换的置换。\n\n原位算法巧妙地处理了这种复杂的簿记工作。通过在步骤 $k$ 对*整个*矩阵执行行交换，我们不仅交换了未来 $U$ 部分的行，也交换了已经计算出的 $L$ 部分（存储在第 $0$ 列到第 $k-1$ 列中的乘子）的行。这自动计算出了最终 $L$ 矩阵所需的经过置换的乘子。\n\n对于矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的原位算法如下：\n令 $A$ 为被覆写的数组。我们还需要一个大小为 $n$ 的整数向量 $p$ 来存储主元信息。\n\n对于 $k = 0, \\dots, n-1$：\n$1$. **寻找主元**：找到索引 $i_{max} \\in \\{k, k+1, \\dots, n-1\\}$，使得 $|A_{i,k}|$ 最大。\n$2$. **存储置换**：记录主元行索引：$p[k] = i_{max}$。\n$3$. **行交换**：如果 $i_{max} \\neq k$，则交换整个矩阵 $A$ 的第 $k$ 行和第 $i_{max}$ 行。`A[[k, i_max], :] = A[[i_max, k], :]`。\n$4$. **处理奇异性**：如果新的主元元素 $A_{k,k}$ 为零，那么所有 $i \\geq k$ 的元素 $A_{i,k}$ 必定都为零。此列的乘子隐式地为零。根据问题要求，为与记录的交换保持一致，我们设置 $p[k]=k$，但交换本身不改变值。问题陈述说“设置 $p[k]=k$...并跳过秩-1 更新”，这意味着如果主元为零我们不进行交换。然而，更稳健的实现是找到最大绝对值。如果它为零，无论如何都存储交换（可能 $i_{max} \\ne k$ 但 $A_{i_{max},k}=0$），但之后跳过除以 $A_{k,k}$ 的步骤。这正是问题中边界情况处理规则所指导的：“如果在步骤 $k$ 中所有候选...均为零，则设置 $p[k]=k$，...将乘子设置为零，并跳过秩-1 更新”。我的实现将遵循这一点。（修正：更仔细地阅读提示“设置 $p[k]=k$”意味着如果该列全为零，我们不应记录交换。让我们改进逻辑：找到 $i_{max}$，如果 $|A_{i_{max}, k}|$ 为零，我们设置 $p[k]=k$ 并跳到下一次迭代。否则，我们设置 $p[k]=i_{max}$，执行交换，然后继续）。一个更简单且等效的逻辑是：找到 $i_{max}$，将其记录在 $p[k]$ 中，执行交换，然后检查新的主元 $A_{k,k}$ 是否数值上为零。如果是，则跳过更新。这涵盖了奇异情况。\n$5$. **计算乘子并更新**：如果 $|A_{k,k}| > 0$，那么对于每一行 $i = k+1, \\dots, n-1$：\n    a. 乘子是 $A_{i,k} / A_{k,k}$。我们将其原位存储：$A_{i,k} \\leftarrow A_{i,k} / A_{k,k}$。\n    b. 更新第 $i$ 行的剩余部分：对于 $j = k+1, \\dots, n-1$，$A_{i,j} \\leftarrow A_{i,j} - A_{i,k} \\cdot A_{k,j}$。这是一个向量操作：$A[i, k+1:n] \\leftarrow A[i, k+1:n] - A[i, k] \\cdot A[k, k+1:n]$。\n\n循环结束后，数组 $A$ 包含了 $L$ 和 $U$ 的元素。\n- $A$ 的上三角部分，包括对角线，构成了矩阵 $U$。因此，$U = \\operatorname{triu}(A)$。\n- $A$ 的严格下三角部分包含了乘子，它们是 $L$ 的元素。因此，$L = \\operatorname{tril}(A, -1) + I$。\n\n问题规定 $p[k]$ 记录与第 $k$ 行交换的行索引。总置换 $P$ 是这些交换的复合。令 $T(i, j)$ 为交换第 $i$ 行和第 $j$ 行的对换矩阵。在步骤 $k$，我们将 $T(k, p[k])$ 应用于先前步骤得到的矩阵。因此，应用于原始矩阵 $A$ 的总置换为 $P = T(n-1, p[n-1]) \\dots T(1, p[1]) T(0, p[0])$。\n要从向量 $p$ 重构 $P$：\n$1$. 从一个 $n \\times n$ 的单位矩阵 $I$ 开始作为 $P$。\n$2$. 对于 $k = 0, \\dots, n-1$，交换矩阵 $P$ 的第 $k$ 行和第 $p[k]$ 行。这将相继把对换 $T(k,p[k])$ 应用于单位矩阵的各行，从而构建出最终的置换矩阵 $P$。\n\n最后，我们必须验证奇偶性恒等式。当 $i \\neq j$ 时，一个对换矩阵 $T(i,j)$ 的行列式为 $-1$。矩阵乘积的行列式是它们行列式的乘积。因此：\n$$ \\det(P) = \\prod_{k=0}^{n-1} \\det(T(k, p[k])) $$\n由于当 $k \\neq p[k]$ 时 $\\det(T(k, p[k])) = -1$，而当 $k = p[k]$ 时为 $1$，这可以简化为：\n$$ \\det(P) = (-1)^s $$\n其中 $s = |\\{k \\in \\{0, \\dots, n-1\\} \\mid p[k] \\neq k\\}|$ 是执行的有效对换次数。因此，布尔值检查 $B$ 即为 $\\det(P) = (-1)^s$。\n\n残差误差使用弗罗贝尼乌斯范数来衡量，对于矩阵 $M \\in \\mathbb{R}^{m \\times n}$，其定义为 $\\|M\\|_F = \\sqrt{\\sum_{i=0}^{m-1} \\sum_{j=0}^{n-1} M_{i,j}^2}$。残差 $R = \\|PA - LU\\|_F$ 量化了分解的后向误差。一个小的残差表示计算成功。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef in_place_lu_partial_piv(A_in):\n    \"\"\"\n    Computes the PA=LU factorization of a square matrix A using\n    in-place Gaussian elimination with partial pivoting.\n\n    Args:\n        A_in (np.ndarray): The input square matrix.\n\n    Returns:\n        tuple: A tuple containing:\n            - A (np.ndarray): The matrix A overwritten with L and U factors.\n            - p (np.ndarray): The pivot vector encoding the row swaps.\n    \"\"\"\n    A = A_in.copy().astype(np.float64)\n    n = A.shape[0]\n    p = np.arange(n) # Using arange to initialize, but will store swap indices as per prompt\n\n    for k in range(n):\n        # Find the row with the largest pivot in column k, among rows k to n-1\n        pivot_row_index_local = np.argmax(np.abs(A[k:n, k]))\n        pivot_row_index_global = pivot_row_index_local + k\n\n        # As per the edge case: if all candidates are zero, set p[k]=k and skip.\n        if np.isclose(A[pivot_row_index_global, k], 0.0):\n            p[k] = k\n            continue\n\n        # Store the pivot choice\n        p[k] = pivot_row_index_global\n        \n        # Swap row k with the pivot row if necessary\n        if pivot_row_index_global != k:\n            A[[k, pivot_row_index_global]] = A[[pivot_row_index_global, k]]\n\n        # The loop for elimination and update only needs to run for k  n-1\n        if k  n - 1:\n            # Compute multipliers and store them in the lower triangular part\n            # This is a vectorized operation for column k\n            multipliers = A[k+1:n, k] / A[k, k]\n            A[k+1:n, k] = multipliers\n            \n            # Apply rank-1 update to the trailing submatrix\n            # A[i, j] = A[i, j] - m_ik * A[k, j] for i,j > k\n            sub_matrix_update = np.outer(multipliers, A[k, k+1:n])\n            A[k+1:n, k+1:n] -= sub_matrix_update\n            \n    return A, p.astype(int)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        np.array([\n            [0, 2, 3], \n            [4, 5, 6], \n            [7, 8, 10]\n        ], dtype=float),\n        np.array([\n            [0, 0, 0, 0],\n            [0, 1, 2, 3],\n            [0, 4, 5, 6],\n            [0, 7, 8, 9]\n        ], dtype=float),\n        np.array([[5.5]], dtype=float),\n        np.array([\n            [1e-20, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1.0001, 1, 1],\n            [1, 1, 1, 1.0002, 1],\n            [1, 1, 1, 1, 1.0003]\n        ], dtype=float),\n        np.array([\n            [1, 3, 1, 5],\n            [2, 6, 4, 8],\n            [1, 0, 0, 3],\n            [2, 1, 7, 9]\n        ], dtype=float)\n    ]\n\n    results = []\n    for A_orig in test_cases:\n        n = A_orig.shape[0]\n\n        # Run the in-place factorization\n        A_modified, p_vec = in_place_lu_partial_piv(A_orig)\n\n        # Reconstruct P from the pivot vector p\n        # To get the final permutation matrix P that acts on A (PA = LU),\n        # we must apply the sequence of swaps in reverse order to the identity matrix.\n        # Or, more simply, construct P such that P[k, p_k] = 1, where p is the final permuted index vector.\n        # Let's create the final permutation vector first.\n        perm_final = np.arange(n)\n        for k in range(n):\n            swap_idx = p_vec[k]\n            perm_final[[k, swap_idx]] = perm_final[[swap_idx, k]]\n        \n        P = np.identity(n)[perm_final]\n\n        # Extract L and U from the modified matrix\n        L = np.tril(A_modified, -1) + np.identity(n)\n        U = np.triu(A_modified)\n        \n        # Compute the Frobenius residual\n        residual = np.linalg.norm(P @ A_orig - L @ U, 'fro')\n        \n        # Verify the permutation parity identity\n        # The number of swaps is the number of k where p_vec[k] != k\n        s = np.sum(p_vec != np.arange(n, dtype=int)) # Number of actual transpositions\n        det_P = np.linalg.det(P)\n        parity = (-1.0)**s\n        is_parity_correct = np.isclose(det_P, parity)\n\n        results.append(residual)\n        results.append(is_parity_correct)\n\n    # Final print statement in the exact required format.\n    # The python boolean 'True' gets converted to 'True' string, which is fine.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}