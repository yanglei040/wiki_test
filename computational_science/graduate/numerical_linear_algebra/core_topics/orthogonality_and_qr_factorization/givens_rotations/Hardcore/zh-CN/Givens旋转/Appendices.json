{
    "hands_on_practices": [
        {
            "introduction": "要掌握任何工具，我们必须首先理解其构造原理。本练习是学习吉文斯旋转的基础实践。通过从正交性的第一性原理和零化特定矩阵元素的目标出发，你将推导出定义旋转的参数，从而巩固你对这一强大变换在最基本层面如何工作的理解。",
            "id": "3548499",
            "problem": "考虑稠密矩阵\n$$\nA \\;=\\; \\begin{pmatrix}\n4  -3  8 \\\\\n7  5  -2 \\\\\n1  -9  6\n\\end{pmatrix}.\n$$\n吉文斯旋转是一种平面正交变换，它非平凡地作用于选定的一对坐标，并保持欧几里得 $2$-范数。仅使用正交矩阵作为 $\\mathbb{R}^{n}$ 中保范线性等距变换的基本定义以及 $\\mathbb{R}^{2}$ 中平面旋转的特征，推导出一个作用于第 $1$ 行和第 $2$ 行的吉文斯旋转的两个实参数所需满足的约束条件。该旋转通过左乘矩阵 $A$ 来消去其第 $1$ 列对角线下方的元素，即元素 $a_{21}$。从这些第一性原理出发，确定这些参数关于 $a_{11}$ 和 $a_{21}$ 的解析表达式，然后对上面给定的特定矩阵 $A$ 计算它们的值。\n\n将消去给定矩阵 $A$ 中 $a_{21}$ 的吉文斯旋转的余弦参数 $c$ 作为您的最终答案。以精确的封闭形式表示您的最终答案；无需四舍五入。",
            "solution": "该问题被验证为具有科学依据、问题明确且客观。这是数值线性代数中的一个标准问题，内容自洽且无矛盾。\n\n任务是推导出一个吉文斯旋转的参数，该旋转可以消去矩阵的特定元素，然后为给定的矩阵 $A$ 计算其中一个参数。推导必须基于第一性原理。吉文斯旋转是作用于二维子空间的正交变换。\n\n设给定矩阵为 $A \\in \\mathbb{R}^{3 \\times 3}$，其元素记为 $a_{ij}$。\n$$\nA \\;=\\; \\begin{pmatrix}\n4  -3  8 \\\\\n7  5  -2 \\\\\n1  -9  6\n\\end{pmatrix}\n$$\n我们寻求一个吉文斯旋转矩阵 $G$，当通过左乘应用于 $A$ 时，能够消去元素 $a_{21}=7$。此旋转必须作用于第 $1$ 行和第 $2$ 行。吉文斯旋转矩阵 $G$ 是一个正交矩阵，它与单位矩阵相同，除了一个执行平面旋转的 $2 \\times 2$ 子矩阵。对于作用于第 $1$ 行和第 $2$ 行的情况，矩阵 $G$ 的一般形式为：\n$$\nG \\;=\\; \\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n其中 $c$ 和 $s$ 是实参数。\n\n所述的第一性原理是 $G$ 必须是一个正交矩阵。正交矩阵 $Q$ 满足条件 $Q^T Q = I$，其中 $I$ 是单位矩阵。此性质确保了该变换是线性等距变换，即它保持欧几里得 $2$-范数。将此条件应用于 $G$：\n$$\nG^T G = \\begin{pmatrix}\nc  -s  0 \\\\\ns  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\nc^2 + s^2  cs - sc  0 \\\\\nsc - cs  s^2 + c^2  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n从所得单位矩阵的左上角元素，我们推导出关于参数 $c$ 和 $s$ 的第一个约束条件：\n$$\nc^2 + s^2 = 1\n$$\n这个约束证实了 $c$ 和 $s$ 可以被解释为某个旋转角 $\\theta$ 的余弦和正弦，即 $c = \\cos(\\theta)$ 和 $s = \\sin(\\theta)$，对应于此处使用的旋转矩阵约定（顺时针旋转 $\\theta$）。\n\n接下来，我们将变换应用于矩阵 $A$ 以形成一个新矩阵 $A' = G A$。\n$$\nA' = \\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\na_{11}  a_{12}  a_{13} \\\\\na_{21}  a_{22}  a_{23} \\\\\na_{31}  a_{32}  a_{33}\n\\end{pmatrix}\n$$\n问题要求 $A'$ 的第二行第一列的元素，记为 $a'_{21}$，被消去（即，设为 $0$）。$a'_{21}$ 的表达式通过计算 $G$ 的第二行与 $A$ 的第一列的点积得到：\n$$\na'_{21} = (-s) \\cdot a_{11} + c \\cdot a_{21} + 0 \\cdot a_{31} = -s a_{11} + c a_{21}\n$$\n令 $a'_{21} = 0$ 得到第二个约束条件：\n$$\n-s a_{11} + c a_{21} = 0 \\quad \\implies \\quad c a_{21} = s a_{11}\n$$\n现在我们得到了一个包含两个未知数 $c$ 和 $s$ 的方程组：\n1. $c^2 + s^2 = 1$\n2. $c a_{21} = s a_{11}$\n\n假设 $a_{11} \\ne 0$，我们可以写出 $s = c \\frac{a_{21}}{a_{11}}$。将此代入第一个方程：\n$$\nc^2 + \\left(c \\frac{a_{21}}{a_{11}}\\right)^2 = 1\n$$\n$$\nc^2 \\left(1 + \\frac{a_{21}^2}{a_{11}^2}\\right) = 1\n$$\n$$\nc^2 \\left(\\frac{a_{11}^2 + a_{21}^2}{a_{11}^2}\\right) = 1\n$$\n$$\nc^2 = \\frac{a_{11}^2}{a_{11}^2 + a_{21}^2}\n$$\n取平方根，我们得到 $c = \\pm \\frac{|a_{11}|}{\\sqrt{a_{11}^2 + a_{21}^2}}$。一个标准的约定是选择正根，并让 $c$ 与 $a_{11}$ 符号相同，这也能确保新的对角元素 $a'_{11}$ 为正。这导出了 $c$ 的一般解析表达式：\n$$\nc = \\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{21}^2}}\n$$\n将此代回 $c a_{21} = s a_{11}$，我们求解 $s$：\n$$\n\\left(\\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{21}^2}}\\right) a_{21} = s a_{11}\n$$\n假设 $a_{11} \\ne 0$，我们得到 $s$ 的表达式：\n$$\ns = \\frac{a_{21}}{\\sqrt{a_{11}^2 + a_{21}^2}}\n$$\n如果 $a_{11}=0$，消去方程变为 $c a_{21} = 0$。如果 $a_{21} \\ne 0$，则 $c=0$。从 $c^2+s^2=1$，我们得到 $s^2=1$，所以 $s=\\pm 1$。我们的公式得出 $c=0$ 和 $s=a_{21}/|a_{21}| = \\pm 1$，这是一致的。如果 $a_{11}=0$ 和 $a_{21}=0$ 都成立，则该元素已经为零，不需要旋转（$c=1, s=0$）。因此，我们的公式是稳健的。\n\n现在，我们为给定的矩阵 $A$ 计算这些参数。相关元素为 $a_{11} = 4$ 和 $a_{21} = 7$。\n首先，我们计算分母，它对应于向量 $(a_{11}, a_{21})^T$ 的欧几里得范数。设其为 $r$。\n$$\nr = \\sqrt{a_{11}^2 + a_{21}^2} = \\sqrt{4^2 + 7^2} = \\sqrt{16 + 49} = \\sqrt{65}\n$$\n使用推导出的解析表达式，余弦参数 $c$ 为：\n$$\nc = \\frac{a_{11}}{r} = \\frac{4}{\\sqrt{65}}\n$$\n为完整起见，正弦参数 $s$ 为：\n$$\ns = \\frac{a_{21}}{r} = \\frac{7}{\\sqrt{65}}\n$$\n问题要求以精确的封闭形式给出余弦参数 $c$ 的值。\n最终答案是 $c = \\frac{4}{\\sqrt{65}}$。",
            "answer": "$$\n\\boxed{\\frac{4}{\\sqrt{65}}}\n$$"
        },
        {
            "introduction": "单个的吉文斯旋转是构建诸如QR分解等强大算法的基础模块。本练习要求你将这些模块组装成一个完整的QR分解程序，并且同样重要的是，验证其正确性。你将把你的实现与另一种标准方法（豪斯霍尔德QR）进行比较，并通过实施符号对齐策略来解决分解唯一性这一微妙但关键的问题，这是任何计算科学家都必须掌握的一项重要技能。",
            "id": "3548524",
            "problem": "设计并实现一个完整的程序，该程序为给定的有限实数矩阵集合，计算两种正交三角分解（QR分解）：一种通过Householder反射，另一种通过Givens旋转。目标是构建有原则的交叉检验，以验证正交性、三角因子的上梯形结构、重构精度，并提出和实现一种数学上合理的方法来对齐符号，以便两个三角因子在一致的符号约定下可以进行比较。\n\n您的推导和实现必须从以下基本基础出发：\n- 正交矩阵的定义：一个实数矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{m \\times m}$ 是正交的，如果 $\\mathbf{Q}^{\\top} \\mathbf{Q} = \\mathbf{I}_m$。\n- 由内积诱导的欧几里得范数，以及由矩阵上的欧几里得内积诱导的Frobenius范数 $\\|\\cdot\\|_F$。\n- Householder反射是一种形式为 $\\mathbf{H} = \\mathbf{I} - 2 \\mathbf{u} \\mathbf{u}^{\\top}$ 的正交变换，其中 $\\mathbf{u} \\in \\mathbb{R}^{k}$ 且 $\\|\\mathbf{u}\\|_2 = 1$，它将向量反射过与 $\\mathbf{u}$ 正交的超平面。\n- Givens旋转是一种作用于由两个标准基向量张成的坐标平面上的正交变换，由满足 $c^2 + s^2 = 1$ 的标量 $c$ 和 $s$ 参数化，用于将选定的元素置零。\n\n您必须：\n- 使用Householder反射构造 $\\mathbf{Q}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{H}}$，使得 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{H}} \\mathbf{R}_{\\mathrm{H}}$，其中 $\\mathbf{Q}_{\\mathrm{H}}$ 是正交的，$\\mathbf{R}_{\\mathrm{H}}$ 是上梯形的。\n- 使用Givens旋转构造 $\\mathbf{Q}_{\\mathrm{G}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$，使得 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{G}} \\mathbf{R}_{\\mathrm{G}}$，其中 $\\mathbf{Q}_{\\mathrm{G}}$ 是正交的，$\\mathbf{R}_{\\mathrm{G}}$ 是上梯形的。\n- 提出并实现一种符号对齐方法，以使 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 的对角线在单一符号约定下可比。该方法必须为每次分解保留等式 $\\mathbf{A} = \\mathbf{Q} \\mathbf{R}$。一种有效的方法是强制 $\\mathbf{R}$ 的对角线为非负，具体做法是：对于 $k = 1, \\dots, \\min(m,n)$，当对角元素 $\\mathbf{R}_{k k}$ 为负时，将 $\\mathbf{R}$ 的第 $k$ 行和 $\\mathbf{Q}$ 的第 $k$ 列乘以 $-1$；当 $\\mathbf{R}_{k k}$ 在数值上为零时，保持不变。\n\n对于每个矩阵，设计交叉检验以验证：\n- 上梯形结构：$\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 主对角线严格下方的元素相对于 $\\mathbf{A}$ 的尺度具有很小的量级。\n- 正交性：对于 $\\mathbf{Q}_{\\mathrm{H}}$ 和 $\\mathbf{Q}_{\\mathrm{G}}$，$\\|\\mathbf{Q}^{\\top}\\mathbf{Q} - \\mathbf{I}\\|_F$ 都很小。\n- 重构：对于两种分解，$\\|\\mathbf{A} - \\mathbf{Q}\\mathbf{R}\\|_F$ 都很小。\n- 对齐后的三角因子比较：在对 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 应用符号对齐约定后，两个三角因子在Frobenius范数下很接近。\n\n所有比较都必须使用基于输入矩阵的Frobenius范数 $\\|\\mathbf{A}\\|_F$ 和一个尺度不变阈值的数值上合理的容差。角度隐含在Givens旋转的余弦和正弦的使用中，不需要明确的单位。不涉及物理单位。\n\n直接根据上述原理实现算法；不要调用任何内置的正交三角分解（QR）例程。但是，您可以使用基本的线性代数运算。\n\n使用以下明确作为数组给出的实数矩阵测试套件：\n- 测试用例1（高矩阵，满列秩）：\n$$\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n3  -2  5 \\\\\n7  1  -1 \\\\\n2  4  0 \\\\\n-3  5  2 \\\\\n1  -6  3\n\\end{bmatrix}.\n$$\n- 测试用例2（方阵，满秩）：\n$$\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n4  2  -2 \\\\\n1  3  0 \\\\\n0  -1  5\n\\end{bmatrix}.\n$$\n- 测试用例3（方阵，秩亏）：\n$$\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1  0  1  2 \\\\\n0  1  2  -1 \\\\\n2  -3  -4  1 \\\\\n-1  4  7  0\n\\end{bmatrix}.\n$$\n- 测试用例4（宽矩阵，满行秩）：\n$$\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1  0  2  -1  3 \\\\\n0  -2  1  4  -1 \\\\\n3  5  -2  0  1\n\\end{bmatrix}.\n$$\n\n对于每个 $\\mathbf{A}_i$，将所有交叉检验聚合为单个布尔结果 $b_i$，当且仅当以下所有条件同时成立时，$b_i$ 为 $ \\mathrm{True} $：\n- $\\mathbf{R}_{\\mathrm{H}}$ 在容差范围内是上梯形的。\n- $\\mathbf{R}_{\\mathrm{G}}$ 在容差范围内是上梯形的。\n- $\\mathbf{Q}_{\\mathrm{H}}$ 在容差范围内是正交的。\n- $\\mathbf{Q}_{\\mathrm{G}}$ 在容差范围内是正交的。\n- $\\mathbf{A}_i \\approx \\mathbf{Q}_{\\mathrm{H}} \\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{A}_i \\approx \\mathbf{Q}_{\\mathrm{G}} \\mathbf{R}_{\\mathrm{G}}$ 在容差范围内成立。\n- 在对 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 进行符号对齐以强制对角线为非负后，两个三角因子在容差范围内近似匹配。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的布尔结果列表，顺序为 $[b_1,b_2,b_3,b_4]$。例如，如果所有测试用例都通过所有交叉检验，则输出可能看起来像 $[\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}]$。",
            "solution": "该问题定义明确，科学上合理，并包含了解决问题所需的所有必要信息。它要求实现并验证两种基本的数值线性代数算法——通过Householder反射和Givens旋转的QR分解——并进行后续比较。这在计算科学中是一项标准且有价值的练习。\n\n核心任务是找到给定实数矩阵 $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$ 的QR分解，即形如 $\\mathbf{A} = \\mathbf{Q}\\mathbf{R}$ 的分解，其中 $\\mathbf{Q} \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵（$\\mathbf{Q}^{\\top}\\mathbf{Q} = \\mathbf{I}_m$），而 $\\mathbf{R} \\in \\mathbb{R}^{m \\times n}$ 是一个上梯形矩阵。上梯形矩阵在其主对角线以下的元素均为零，即 $\\mathbf{R}_{ij} = 0$ 对所有 $i > j$。\n\n我们将分别使用Householder反射和Givens旋转来构造两种这样的分解，即 $(\\mathbf{Q}_{\\mathrm{H}}, \\mathbf{R}_{\\mathrm{H}})$ 和 $(\\mathbf{Q}_{\\mathrm{G}}, \\mathbf{R}_{\\mathrm{G}})$。\n\n### 1. 通过Householder反射的QR分解\n\n策略是对矩阵 $\\mathbf{A}$ 应用一系列正交变换，以逐步在主对角线下方引入零。每次变换都会将单个列的对角线以下元素置零。Householder反射是完成此任务的工具。\n\n对于每一列 $k$（从 $1$ 到 $\\min(m-1, n)$），我们的目标是将当前矩阵（我们称之为 $\\mathbf{A}^{(k-1)}$，其中 $\\mathbf{A}^{(0)} = \\mathbf{A}$）转换为 $\\mathbf{A}^{(k)} = \\mathbf{H}_k \\mathbf{A}^{(k-1)}$，其中 $\\mathbf{H}_k$ 是一个Householder反射器，其选择旨在将第 $k$ 列中对角元素 $\\mathbf{A}^{(k)}_{kk}$ 下方的元素置零。\n\n反射器 $\\mathbf{H}_k$ 作用于向量 $\\mathbf{x} \\in \\mathbb{R}^{m-k+1}$，该向量是子列 $\\mathbf{A}^{(k-1)}_{k:m,k}$。我们需要一个反射器 $\\hat{\\mathbf{H}}_k$ 使得 $\\hat{\\mathbf{H}}_k \\mathbf{x} = \\alpha \\mathbf{e}_1$，其中 $\\mathbf{e}_1 = [1, 0, \\dots, 0]^{\\top}$，$\\alpha$ 是一个标量。由于正交变换保持欧几里得范数，所以 $|\\alpha| = \\|\\mathbf{x}\\|_2$。反射器由一个垂直于反射超平面的向量 $\\mathbf{v}$ 定义。该向量由 $\\mathbf{v} = \\mathbf{x} - \\alpha \\mathbf{e}_1$ 给出。为避免数值抵消，$\\alpha$ 的一个稳健选择是 $\\alpha = -\\mathrm{sgn}(\\mathbf{x}_1) \\|\\mathbf{x}\\|_2$，其中 $\\mathbf{x}_1$ 是 $\\mathbf{x}$ 的第一个分量。\n\nHouseholder反射器则由 $\\hat{\\mathbf{H}}_k = \\mathbf{I} - 2\\frac{\\mathbf{v}\\mathbf{v}^{\\top}}{\\mathbf{v}^{\\top}\\mathbf{v}}$ 给出。在实践中，为避免显式构造该矩阵，我们计算 $\\beta = 2/(\\mathbf{v}^{\\top}\\mathbf{v})$ 并将变换应用于矩阵 $\\mathbf{C}$，即 $\\hat{\\mathbf{H}}_k\\mathbf{C} = \\mathbf{C} - \\beta \\mathbf{v}(\\mathbf{v}^{\\top}\\mathbf{C})$。\n\n在第 $k$ 步的完整变换矩阵是 $\\mathbf{H}_k = \\begin{pmatrix} \\mathbf{I}_{k-1} & \\mathbf{0} \\\\ \\mathbf{0} & \\hat{\\mathbf{H}}_k \\end{pmatrix}$。经过 $\\min(m-1, n)$ 步后，我们得到 $\\mathbf{H}_{\\min(m-1,n)} \\dots \\mathbf{H}_2 \\mathbf{H}_1 \\mathbf{A} = \\mathbf{R}_{\\mathrm{H}}$。\n由于每个 $\\mathbf{H}_k$ 都是正交的，它们的乘积也是正交的。令 $\\mathbf{Q}_{\\mathrm{H}}^{\\top} = \\mathbf{H}_{\\min(m-1,n)} \\dots \\mathbf{H}_1$。那么 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{H}}\\mathbf{R}_{\\mathrm{H}}$，其中 $\\mathbf{Q}_{\\mathrm{H}} = \\mathbf{H}_1^{\\top} \\dots \\mathbf{H}_{\\min(m-1,n)}^{\\top} = \\mathbf{H}_1 \\dots \\mathbf{H}_{\\min(m-1,n)}$。\n矩阵 $\\mathbf{Q}_{\\mathrm{H}}$ 是通过从 $\\mathbf{Q} = \\mathbf{I}_m$ 开始并相继应用反射器来形成的：$\\mathbf{Q} \\leftarrow \\mathbf{Q} \\mathbf{H}_k$。\n\n### 2. 通过Givens旋转的QR分解\n\nGivens旋转提供了一种更细粒度的方法，一次引入一个零。Givens旋转作用于由两个坐标轴张成的二维平面。为了使用位于 $(j, j)$ 的主元元素将位置 $(i, j)$（其中 $i > j$）的元素置零，我们在 $(j, i)$ 平面上应用一个旋转。\n\n设这两个元素的值为 $a = \\mathbf{R}_{jj}$ 和 $b = \\mathbf{R}_{ij}$。我们寻求一个旋转矩阵，将向量 $[a, b]^{\\top}$ 变换为 $[r, 0]^{\\top}$。旋转矩阵是\n$$\n\\mathbf{G}_{ji}^{\\top} = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}\n$$\n其中 $c^2 + s^2 = 1$。变换产生 $\\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} ca + sb \\\\ -sa + cb \\end{pmatrix}$。为了使第二个分量为零，我们选择 $c = a/r$ 和 $s = b/r$，其中 $r = \\sqrt{a^2 + b^2}$。这会得到新的向量 $[r, 0]^{\\top}$。\n\n整个算法通过从 $1$ 到 $n$ 遍历列 $j$，并对每一列，从 $j+1$ 到 $m$ 遍历行 $i$ 来进行。在每一步 $(i, j)$，一个Givens旋转 $\\mathbf{G}_{ji}^{\\top}$ 被左乘到当前矩阵上，以将元素 $\\mathbf{R}_{ij}$ 置零。\n最终的上梯形矩阵是 $\\mathbf{R}_{\\mathrm{G}} = (\\dots \\mathbf{G}_{m,n-1}^{\\top} \\dots \\mathbf{G}_{j+1,j}^{\\top} \\dots) \\mathbf{A}$。\n正交矩阵 $\\mathbf{Q}_{\\mathrm{G}}$ 是所有Givens矩阵的乘积：$\\mathbf{Q}_{\\mathrm{G}} = (\\dots \\mathbf{G}_{j+1,j} \\dots \\mathbf{G}_{m,n-1} \\dots)$。这是通过初始化 $\\mathbf{Q} = \\mathbf{I}_m$ 并相继后乘以每个Givens矩阵 $\\mathbf{G}_{ji}$ 来构建的。$\\mathbf{Q}$ 的两列 $\\mathbf{q}_j$ 和 $\\mathbf{q}_i$ 的更新规则变为：\n$(\\mathbf{q}'_j, \\mathbf{q}'_i) = (\\mathbf{q}_j, \\mathbf{q}_i) \\begin{pmatrix} c & -s \\\\ s & c \\end{pmatrix}$。\n\n### 3. 符号对齐与唯一性\n\n对于一个满秩矩阵，其QR分解在 $\\mathbf{Q}$ 的列和 $\\mathbf{R}$ 的行的符号方面是唯一的。具体来说，如果 $\\mathbf{A} = \\mathbf{Q}\\mathbf{R}$，那么对于任何对角矩阵 $\\mathbf{D}$ 且 $\\mathbf{D}_{kk} = \\pm 1$，分解 $\\mathbf{A} = (\\mathbf{Q}\\mathbf{D})(\\mathbf{D}\\mathbf{R})$ 也是一个有效的QR分解。为了能够在 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 之间进行有意义的比较，我们必须强制执行一个一致的符号约定。\n\n问题指定了一种规范表示，其中 $\\mathbf{R}$ 的所有对角元素都是非负的。对于每个 $k \\in \\{1, \\dots, \\min(m,n)\\}$，如果 $\\mathbf{R}_{kk} < 0$，我们将 $\\mathbf{R}$ 的第 $k$ 行和 $\\mathbf{Q}$ 的第 $k$ 列乘以 $-1$。这对应于设置 $\\mathbf{D}_{kk} = \\mathrm{sgn}(\\mathbf{R}_{kk})$（其中 $\\mathrm{sgn}(0)$ 定义为 $1$）。此操作保持了等式 $\\mathbf{A}=\\mathbf{Q}\\mathbf{R}$ 和 $\\mathbf{Q}$ 的正交性。\n\n### 4. 验证与交叉检验\n\n为了验证所实现算法的正确性和精度，我们对每个输入矩阵 $\\mathbf{A}$ 执行四类检查，使用一个动态缩放的容差 $\\tau = \\|\\mathbf{A}\\|_F \\times \\epsilon$，其中 $\\epsilon$ 是一个小的因子，如 $10^{-12}$。\n\n1.  **上梯形结构**：$\\mathbf{R}$ 的严格下三角部分的Frobenius范数必须接近于零。我们检查 $\\|\\mathrm{tril}(\\mathbf{R}, -1)\\|_F < \\tau$。\n2.  **Q的正交性**：矩阵 $\\mathbf{Q}$ 必须是正交的。我们通过检查其与正交性的偏差是否很小来验证这一点：$\\|\\mathbf{Q}^{\\top}\\mathbf{Q} - \\mathbf{I}_m\\|_F < \\tau$。\n3.  **重构精度**：乘积 $\\mathbf{Q}\\mathbf{R}$ 必须重构出原始矩阵 $\\mathbf{A}$。我们检查重构误差：$\\|\\mathbf{A} - \\mathbf{Q}\\mathbf{R}\\|_F < \\tau$。\n4.  **对齐后的三角因子比较**：在对 $(\\mathbf{Q}_{\\mathrm{H}}, \\mathbf{R}_{\\mathrm{H}})$ 和 $(\\mathbf{Q}_{\\mathrm{G}}, \\mathbf{R}_{\\mathrm{G}})$ 应用符号对齐约定以获得 $(\\mathbf{Q}_{\\mathrm{H}}', \\mathbf{R}_{\\mathrm{H}}')$ 和 $(\\mathbf{Q}_{\\mathrm{G}}', \\mathbf{R}_{\\mathrm{G}}')$ 后，得到的三角因子应该（在容差范围内）是相同的。我们检查 $\\|\\mathbf{R}_{\\mathrm{H}}' - \\mathbf{R}_{\\mathrm{G}}'\\|_F < \\tau$。\n\n只有当基于Householder和Givens的分解的所有这些检查都通过时，一个测试用例才被认为是成功的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef qr_householder(A):\n    \"\"\"\n    Computes QR factorization of a matrix A using Householder reflectors.\n    Returns Q, R where A = QR, Q is orthogonal, and R is upper-trapezoidal.\n    \"\"\"\n    m, n = A.shape\n    R = A.copy().astype(float)\n    Q = np.identity(m, dtype=float)\n\n    for k in range(min(m - 1, n)):\n        # Extract the k-th column vector from the k-th row\n        x = R[k:, k]\n        # Skip if the sub-column is already zero\n        x_norm = np.linalg.norm(x)\n        if np.isclose(x_norm, 0.0):\n            continue\n\n        # Compute the Householder vector v\n        v = x.copy()\n        # Use copysign for robustness to avoid cancellation\n        v[0] += np.copysign(x_norm, x[0])\n        \n        v_norm = np.linalg.norm(v)\n        if np.isclose(v_norm, 0.0):\n            continue\n\n        v = v / v_norm  # Normalize v to get u\n        # Efficiently v is prepared for beta computation\n        # beta = 2.0\n        # H = I - beta * u * u.T\n        \n        # Apply the reflector to the submatrix of R\n        # R_sub = R_sub - beta * u * (u.T @ R_sub)\n        R_sub = R[k:, k:]\n        R[k:, k:] -= 2.0 * np.outer(v, v.T @ R_sub)\n\n        # Apply the reflector to the submatrix of Q\n        # Q_sub = Q_sub @ H = Q_sub @ (I - beta * u * u.T) = Q_sub - beta * (Q_sub @ u) * u.T\n        Q_sub = Q[:, k:]\n        Q[:, k:] -= 2.0 * np.outer(Q_sub @ v, v)\n\n    return Q, R\n\n\ndef qr_givens(A):\n    \"\"\"\n    Computes QR factorization of a matrix A using Givens rotations.\n    Returns Q, R where A = QR, Q is orthogonal, and R is upper-trapezoidal.\n    \"\"\"\n    m, n = A.shape\n    R = A.copy().astype(float)\n    Q = np.identity(m, dtype=float)\n\n    for j in range(n):\n        for i in range(j + 1, m):\n            # Element to be zeroed out is R[i, j]\n            a = R[j, j]\n            b = R[i, j]\n\n            if np.isclose(b, 0.0):\n                continue\n            \n            # Compute c and s for the Givens rotation\n            r = np.hypot(a, b)\n            c = a / r\n            s = b / r\n\n            # Rotation matrix for rows: [[c, s], [-s, c]]\n            # Apply G.T to R (affecting rows j and i)\n            R_j_row = R[j, j:].copy()\n            R_i_row = R[i, j:].copy()\n            R[j, j:] = c * R_j_row + s * R_i_row\n            R[i, j:] = -s * R_j_row + c * R_i_row\n\n            # Apply G to Q (affecting columns j and i)\n            # Rotation matrix for columns: [[c, -s], [s, c]]\n            Q_j_col = Q[:, j].copy()\n            Q_i_col = Q[:, i].copy()\n            Q[:, j] = c * Q_j_col + s * Q_i_col\n            Q[:, i] = -s * Q_j_col + c * Q_i_col\n            \n    return Q, R\n\n\ndef align_signs(Q, R):\n    \"\"\"\n    Enforces a sign convention on QR factorization.\n    The convention is that the diagonal elements of R must be non-negative.\n    \"\"\"\n    m, n = R.shape\n    Q_aligned = Q.copy()\n    R_aligned = R.copy()\n\n    for k in range(min(m, n)):\n        if R_aligned[k, k]  0:\n            R_aligned[k, :] *= -1\n            Q_aligned[:, k] *= -1\n    \n    return Q_aligned, R_aligned\n\n\ndef run_checks_for_matrix(A):\n    \"\"\"\n    Performs all computations and cross-checks for a single matrix A.\n    Returns True if all checks pass, False otherwise.\n    \"\"\"\n    m, n = A.shape\n    \n    # Use a relative tolerance, with a small absolute floor\n    norm_A = np.linalg.norm(A, 'fro')\n    if np.isclose(norm_A, 0.0):\n        tol = 1e-10\n    else:\n        tol = norm_A * 1e-12\n\n    # 1. Compute QR factorizations\n    Q_H, R_H = qr_householder(A)\n    Q_G, R_G = qr_givens(A)\n\n    # 2. Perform cross-checks\n    checks = []\n\n    # Check 1: Upper-trapezoidal structure\n    checks.append(np.linalg.norm(np.tril(R_H, -1), 'fro')  tol)\n    checks.append(np.linalg.norm(np.tril(R_G, -1), 'fro')  tol)\n\n    # Check 2: Orthogonality of Q\n    I_m = np.identity(m)\n    checks.append(np.linalg.norm(Q_H.T @ Q_H - I_m, 'fro')  tol)\n    checks.append(np.linalg.norm(Q_G.T @ Q_G - I_m, 'fro')  tol)\n\n    # Check 3: Reconstruction accuracy\n    checks.append(np.linalg.norm(A - Q_H @ R_H, 'fro')  tol)\n    checks.append(np.linalg.norm(A - Q_G @ R_G, 'fro')  tol)\n\n    # Check 4: Aligned triangular comparison\n    Q_H_a, R_H_a = align_signs(Q_H, R_H)\n    Q_G_a, R_G_a = align_signs(Q_G, R_G)\n\n    # Sanity check: ensure alignment preserved factorization\n    checks.append(np.linalg.norm(A - Q_H_a @ R_H_a, 'fro')  tol)\n    checks.append(np.linalg.norm(A - Q_G_a @ R_G_a, 'fro')  tol)\n    \n    # Main comparison of aligned R factors\n    checks.append(np.linalg.norm(R_H_a - R_G_a, 'fro')  tol)\n\n    return all(checks)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the process for the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (tall, full column rank)\n        np.array([\n            [3, -2, 5],\n            [7, 1, -1],\n            [2, 4, 0],\n            [-3, 5, 2],\n            [1, -6, 3]\n        ]),\n        # Test case 2 (square, full rank)\n        np.array([\n            [4, 2, -2],\n            [1, 3, 0],\n            [0, -1, 5]\n        ]),\n        # Test case 3 (square, rank deficient)\n        np.array([\n            [1, 0, 1, 2],\n            [0, 1, 2, -1],\n            [2, -3, -4, 1],\n            [-1, 4, 7, 0]\n        ]),\n        # Test case 4 (wide, full row rank)\n        np.array([\n            [1, 0, 2, -1, 3],\n            [0, -2, 1, 4, -1],\n            [3, 5, -2, 0, 1]\n        ]),\n    ]\n    \n    results = []\n    for A in test_cases:\n        result = run_checks_for_matrix(A)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "标准算法通常需要进行调整，以应对现实世界数据中的复杂情况，例如矩阵中存在的近似线性相关性。这个高级实践探讨了如何通过引入列主元法来使基于吉文斯旋转的QR分解更加稳健。通过分析列主元选择、$R$ 矩阵对角元素的大小以及数值稳定性之间的相互作用，你将深入理解如何创建数值上可靠的算法，从而能够准确地确定矩阵的有效秩。",
            "id": "3548451",
            "problem": "考虑使用一系列 Givens 旋转来计算一个可能秩亏的实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的正交三角 (QR) 分解。Givens 旋转是一种正交变换，它作用于一对行，将一个目标次对角线元素置为零，同时保持其所乘向量的欧几里得范数不变。令 $A P = Q R$ 表示带列主元选择的 QR 分解，其中 $P \\in \\mathbb{R}^{n \\times n}$ 是一个置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是上三角矩阵。在存在秩亏的情况下，一个重要的实用调整是监控 $R$ 的对角线元素 $r_{kk}$，并在进行第 $k$ 步的 Givens 旋转之前，应用列主元选择，将剩余列中（按 2-范数计算）最大的一列移动到第 $k$ 个主元位置。当 $|r_{kk}|$ 相对于一个全局尺度非常小时，可以使用一个数值停止准则来提前终止分解，并判定一个数值秩。\n\n从正交变换的定义和性质以及 QR 分解的 Gram–Schmidt 解释（即，$r_{kk}$ 等于第 $k$ 个主元列在与先前选择的列正交化后的残差范数）出发，回答下面的多项选择题。你应该推理列主元选择和监控小的 $r_{kk}$ 如何使基于 Givens 的 QR 算法适应秩亏情况，以及这对数值稳定性有何影响。\n\n令\n$$\nA \\;=\\;\n\\begin{bmatrix}\n1  1  10^{-8} \\\\\n0  1  2\\cdot 10^{-8} \\\\\n0  0  3\\cdot 10^{-8} \\\\\n0  0  4\\cdot 10^{-8}\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 3},\n$$\n并考虑一个使用贪心列主元选择的基于 Givens 的 QR 分解（在每一步，将 $A$ 的剩余列中 2-范数最大的一列换到位置 $k$），同时对照阈值 $\\tau = 10^{-6} \\|A\\|_F$（其中 $\\|A\\|_F$ 是 Frobenius 范数）来监控 $|r_{kk}|$。选择所有正确的陈述。\n\nA. 在使用贪心列主元选择的基于 Givens 的 QR 分解中，在应用旋转之前将剩余列中 2-范数最大的一列换到主元位置 $k$，确保了 $r_{kk}$ 等于第 $k$ 个主元列在正交化后的残差的欧几里得范数；当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值上揭示秩的分解 $A P = Q R$，这与标准的阈值处理方法一致。\n\nB. 因为 Givens 旋转作用于行，所以执行行主元选择（而不是列主元选择）来处理秩亏是充分且适当的；得到的分解 $P^{\\top} A = Q R$ 会以与列主元 QR 分解相同的方式揭示列秩。\n\nC. 在基于 Givens 的 QR 分解过程中交换列会破坏累积的 $Q$ 矩阵的正交性，使 $Q^{\\top} Q = I$ 无效；因此，列主元选择与保持 $Q$ 的正交性不兼容。\n\nD. 如果 $|r_{kk}|$ 相对于一个全局尺度（例如 $\\|A\\|_F$）非常小，这表明在正交化后，第 $k$ 个主元列几乎包含在前 $k-1$ 个列的张成空间中；在此时停止并宣布数值秩为 $r = k-1$，可以避免舍入误差的过度放大，并与继续对几乎线性相关的列进行旋转相比，提高了数值稳定性。\n\nE. 将列主元选择引入基于 Givens 的 QR 分解会将渐近计算复杂度从 $\\mathcal{O}(m n^{2})$ 增加到 $\\mathcal{O}(m^{2} n)$，因为每次旋转后都必须重新计算列范数；因此，对于大的 $m$ 和 $n$ 来说，这是不切实际的。\n\nF. 对于给定的矩阵 $A$，贪心列主元选择的顺序是先第二列，然后第一列，最后是第三列；在 $\\tau = 10^{-6} \\|A\\|_F$ 的条件下，当 $|r_{33}| \\le \\tau$ 时，算法将宣布数值秩为 $2$。\n\n选择所有适用项：A, B, C, D, E, F。",
            "solution": "用户希望我批判性地验证并解决一个关于使用带列主元选择的 Givens 旋转对秩亏矩阵进行 QR 分解的多项选择题。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n- 任务是使用 Givens 旋转计算一个可能秩亏的实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的 QR 分解。\n- Givens 旋转是一种作用于两行以将次对角线元素置零的正交变换。\n- 带列主元选择的分解表示为 $A P = Q R$，其中 $P \\in \\mathbb{R}^{n \\times n}$ 是置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是上三角矩阵。\n- 对于秩亏情况，算法涉及监控 $R$ 的对角线元素 $r_{kk}$。\n- 列主元策略：在第 $k$ 步，将剩余列中 2-范数最大的一列移动到第 $k$ 个主元位置。\n- 停止准则：当 $|r_{kk}|$ 相对于一个全局尺度非常小时，可以宣布一个数值秩并提前终止分解。\n- Gram-Schmidt 解释：$r_{kk}$ 等于第 $k$ 个主元列在与先前选择的列正交化后的残差范数。\n- 提供的特定矩阵是：\n$$\nA \\;=\\;\n\\begin{bmatrix}\n1  1  10^{-8} \\\\\n0  1  2\\cdot 10^{-8} \\\\\n0  0  3\\cdot 10^{-8} \\\\\n0  0  4\\cdot 10^{-8}\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 3}\n$$\n- 特定的主元策略是“贪心列主元选择（在每一步，将 $A$ 的剩余列中 2-范数最大的一列换到位置 $k$）”。\n- 特定的停止阈值是 $\\tau = 10^{-6} \\|A\\|_F$，其中 $\\|A\\|_F$ 是 Frobenius 范数。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学上合理：** 该问题植根于数值线性代数中标准的、完善的概念，特别是揭示秩的 QR 分解、Givens 旋转和列主元选择。所描述的 $r_{kk}$ 的大小与线性相关性之间的联系是该主题的基石。使用像 $\\tau = 10^{-6} \\|A\\|_F$ 这样的阈值是数值实践中的一种常见启发式方法。\n- **良构的：** 问题陈述提供了所有必要信息：矩阵 $A$，对算法的清晰描述（带贪心列主元选择的 Givens QR），以及停止准则。这种设置允许对算法的性质及其在给定矩阵上的应用进行明确的分析。\n- **客观的：** 语言正式、精确，没有主观或含糊的术语。\n\n**缺陷清单：**\n1.  **科学或事实不健全：** 无。前提在数值线性代数领域内是事实正确的。\n2.  **非形式化或不相关：** 无。问题是形式化的，并与主题直接相关。\n3.  **不完整或矛盾的设置：** 无。设置是自洽的。\n4.  **不现实或不可行：** 无。矩阵和算法在计算上是现实的。\n5.  **病态或结构不良：** 无。选项中提出的问题是明确定义的，并且可以根据给定的信息来回答。\n6.  **伪深刻、琐碎或同义反复：** 无。该问题需要对数值稳定性、算法复杂度和 QR 分解的机制有多方面的理解。\n7.  **超出科学可验证性范围：** 无。所有主张都可以通过数学方法验证。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。我将继续进行解答。\n\n### 推导与选项分析\n\n问题涉及带列主元选择的 QR 分解 (QRCP)，特别是使用 Givens 旋转。分解的形式为 $AP = QR$。在每一步 $k$（对于 $k = 1, \\dots, n$）：\n1.  在当前矩阵状态的剩余列中（从索引 $k$ 到 $n$），我们识别出其子列（从行 $k$ 到 $m$）具有最大欧几里得（2-）范数的那个。\n2.  我们将此列与当前的第 $k$ 列交换。此交换记录在置换矩阵 $P$ 中。\n3.  我们使用一系列 Givens 旋转，在这个新的第 $k$ 列的次对角线元素中引入零。这些旋转被累积到正交矩阵 $Q$ 中。\n\n关键思想是，所得矩阵 $R$ 的对角元素 $r_{kk}$ 表示第 $k$ 个主元列中正交于前 $k-1$ 个主元列张成空间的分量的长度。一个小的 $|r_{kk}|$ 值表明第 $k$ 个主元列几乎线性依赖于前面的列。这使得能够确定数值秩。\n\n现在我们评估每个陈述。\n\n**A. 在使用贪心列主元选择的基于 Givens 的 QR 分解中，在应用旋转之前将剩余列中 2-范数最大的一列换到主元位置 $k$，确保了 $r_{kk}$ 等于第 $k$ 个主元列在正交化后的残差的欧几里得范数；当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值上揭示秩的分解 $A P = Q R$，这与标准的阈值处理方法一致。**\n\n这个陈述有两个部分。\n1.  “...$r_{kk}$ 等于第 $k$ 个主元列在正交化后的残差的欧几里得范数...”。这是任何 QR 分解的一个基本性质。如果 $AP=[a'_1, \\dots, a'_n]$ 和 $Q=[q_1, \\dots, q_m]$，方程 $AP=QR$ 意味着 $a'_k = \\sum_{i=1}^k r_{ik}q_i$。列 $q_1, \\dots, q_{k-1}$ 构成 $\\{a'_1, \\dots, a'_{k-1}\\}$ 张成空间的一个标准正交基。$a'_k$ 在与此基正交化后的残差是 $a'_k - \\sum_{i=1}^{k-1} \\langle a'_k, q_i \\rangle q_i$。从 $AP=QR$ 可知，$\\langle a'_k, q_i \\rangle = r_{ik}$。因此，残差是 $a'_k - \\sum_{i=1}^{k-1} r_{ik}q_i = r_{kk}q_k$。这个残差的欧几里得范数是 $\\|r_{kk}q_k\\|_2 = |r_{kk}|\\|q_k\\|_2 = |r_{kk}|$。这部分是正确的。\n2.  “...当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值上揭示秩的分解...与标准的阈值处理方法一致。” 这是 QRCP 的主要目的。贪心列选择策略旨在每一步最大化 $|r_{kk}|$，使得任何后续出现的小 $|r_{kk}|$ 都是近似线性相关的强有力指标。基于阈值停止是确定数值秩的标准方法。\n整个陈述是对揭示秩的 QR 的正确而简洁的描述。\n\n**结论：正确**\n\n**B. 因为 Givens 旋转作用于行，所以执行行主元选择（而不是列主元选择）来处理秩亏是充分且适当的；得到的分解 $P^{\\top} A = Q R$ 会以与列主元 QR 分解相同的方式揭示列秩。**\n\n这是不正确的。$A$ 的秩亏涉及其 *列* 之间的线性相关性。行操作，包括行主元选择（$P^\\top A$），会改变矩阵的列空间（即 $\\mathrm{col}(P^\\top A)$ 不一定等于 $\\mathrm{col}(A)$）。要分析 $A$ 的列之间的相关性，必须使用列操作，例如由 $AP$ 表示的列置换。列主元选择保留了列空间，只是重新排序了基向量。行主元选择用于分析 *行秩*（或等价地，$A^\\top$ 的列秩）。虽然数学上行秩等于列秩，但揭示列相关性的数值算法必须作用于列。\n\n**结论：不正确**\n\n**C. 在基于 Givens 的 QR 分解过程中交换列会破坏累积的 $Q$ 矩阵的正交性，使 $Q^{\\top} Q = I$ 无效；因此，列主元选择与保持 $Q$ 的正交性不兼容。**\n\n这误解了算法。分解是 $AP=QR$。矩阵 $Q$ 是由正交的 Givens 旋转矩阵的乘积构成的，即 $Q = G_1^\\top G_2^\\top \\dots G_k^\\top$。正交矩阵的乘积总是正交矩阵，所以 $Q^\\top Q=I$ 是保证的。列交换不属于 $Q$；它们完全由置换矩阵 $P$ 来解释。正交变换（Givens 旋转）应用于经过列置换的矩阵 $AP$。该过程正确地计算出三个独立的矩阵：一个正交的 $Q$，一个上三角的 $R$ 和一个置换矩阵 $P$。\n\n**结论：不正确**\n\n**D. 如果 $|r_{kk}|$ 相对于一个全局尺度（例如 $\\|A\\|_F$）非常小，这表明在正交化后，第 $k$ 个主元列几乎包含在前 $k-1$ 个列的张成空间中；在此时停止并宣布数值秩为 $r = k-1$，可以避免舍入误差的过度放大，并与继续对几乎线性相关的列进行旋转相比，提高了数值稳定性。**\n\n这个陈述准确地描述了停止准则的解释和好处。正如在选项 A 的分析中所确立的，$|r_{kk}|$ 是第 $k$ 个主元列中“新的”或正交于先前主元列的部分的范数。因此，一个小的 $|r_{kk}|$ 表明第 $k$ 列几乎在前 $\\{1, \\dots, k-1\\}$ 列的张成空间内。如果算法继续进行，未来的步骤可能涉及除以这个小的 $r_{kk}$（例如，在求解线性系统 $Rx=y$ 时），这是数值不稳定的，并会放大舍入误差。通过停止并宣布数值秩为 $r=k-1$，我们确定了数值列空间的一个良态基，并避免了这些不稳定性。\n\n**结论：正确**\n\n**E. 将列主元选择引入基于 Givens 的 QR 分解会将渐近计算复杂度从 $\\mathcal{O}(m n^{2})$ 增加到 $\\mathcal{O}(m^{2} n)$，因为每次旋转后都必须重新计算列范数；因此，对于大的 $m$ 和 $n$ 来说，这是不切实际的。**\n\n对一个 $m \\times n$ 矩阵（$m \\ge n$）使用 Givens 或 Householder 方法进行 QR 分解的标准复杂度是 $\\mathcal{O}(mn^2)$。让我们分析主元选择的额外成本。在第 $k$ 步，我们需要在剩下的 $n-k+1$ 列中找到范数最大的那一列。一个关键的细节是，范数不需要从头开始重新计算。正交变换只会以可预测的方式修改向量范数。具体来说，对矩阵的两行应用 Givens 旋转只会影响这两行所涉及的列的范数。每次旋转，每列的范数平方可以用常数次运算更新。在整个过程中更新所有相关范数的总工作量受限于旋转本身的成本。主要成本仍然是应用旋转，即 $\\mathcal{O}(mn^2)$。寻找最大范数列（每步 $O(n)$，总共 $O(n^2)$）和更新范数的开销是低阶的，或者被吸收到主要的复杂度项中。因此，总复杂度仍然是 $\\mathcal{O}(mn^2)$。声称增加到 $\\mathcal{O}(m^2 n)$ 是错误的。\n\n**结论：不正确**\n\n**F. 对于给定的矩阵 $A$，贪心列主元选择的顺序是先第二列，然后第一列，最后是第三列；在 $\\tau = 10^{-6} \\|A\\|_F$ 的条件下，当 $|r_{33}| \\le \\tau$ 时，算法将宣布数值秩为 $2$。**\n\n我们来进行计算。$A$ 的列是 $a_1 = [1, 0, 0, 0]^\\top$，$a_2 = [1, 1, 0, 0]^\\top$，和 $a_3 = [10^{-8}, 2\\cdot10^{-8}, 3\\cdot10^{-8}, 4\\cdot10^{-8}]^\\top$。\n1.  **步骤 k=1 (主元选择):** 计算初始列范数。\n    $\\|a_1\\|_2 = \\sqrt{1^2} = 1$。\n    $\\|a_2\\|_2 = \\sqrt{1^2 + 1^2} = \\sqrt{2} \\approx 1.414$。\n    $\\|a_3\\|_2 = \\sqrt{(1^2+2^2+3^2+4^2)(10^{-8})^2} = \\sqrt{30} \\cdot 10^{-8} \\approx 5.48 \\cdot 10^{-8}$。\n    最大的范数是 $\\|a_2\\|_2$。所以，第一个主元列是 $a_2$。置换矩阵 $P$ 将交换第 1 列和第 2 列。\n2.  **步骤 k=1 (旋转):** 令 $A' = [a_2, a_1, a_3]$。我们对 $A'$ 的第 1 行和第 2 行应用 Givens 旋转，以将 $(2,1)$ 元素置零。之后，矩阵变为（如思路推导）：\n    $$A^{(1)} = \\begin{bmatrix} \\sqrt{2}  \\frac{1}{\\sqrt{2}}  \\frac{3\\cdot 10^{-8}}{\\sqrt{2}} \\\\ 0  -\\frac{1}{\\sqrt{2}}  \\frac{10^{-8}}{\\sqrt{2}} \\\\ 0  0  3\\cdot 10^{-8} \\\\ 0  0  4\\cdot 10^{-8} \\end{bmatrix}$$\n    所以 $r_{11} = \\sqrt{2}$。\n3.  **步骤 k=2 (主元选择):** 我们比较第 2 列和第 3 列剩余部分的范数。\n    对于第 2 列（原始的 $a_1$），剩余部分是 $[-\\frac{1}{\\sqrt{2}}, 0, 0]^\\top$。其范数是 $|-\\frac{1}{\\sqrt{2}}| = \\frac{1}{\\sqrt{2}}$。\n    对于第 3 列（原始的 $a_3$），剩余部分是 $[\\frac{10^{-8}}{\\sqrt{2}}, 3\\cdot 10^{-8}, 4\\cdot 10^{-8}]^\\top$。其范数是 $\\sqrt{(\\frac{1}{2}+9+16)(10^{-8})^2} = \\sqrt{25.5} \\cdot 10^{-8} \\approx 5.05\\cdot 10^{-8}$。\n    因为 $\\frac{1}{\\sqrt{2}} \\gg \\sqrt{25.5} \\cdot 10^{-8}$，第二个主元是当前的第 2 列（原始的 $a_1$）。不需要交换。主元顺序确实是 $(a_2, a_1, a_3)$。\n4.  **步骤 k=2 (旋转):** $A^{(1)}$ 的第二列在对角线下方已经是零，所以 $r_{22} = -\\frac{1}{\\sqrt{2}}$。\n5.  **步骤 k=3:** 处理最后一列。剩余部分是 $[3\\cdot 10^{-8}, 4\\cdot 10^{-8}]^\\top$。对第 3 行和第 4 行进行 Givens 旋转会将其变为 $[5\\cdot 10^{-8}, 0]^\\top$。因此，$r_{33} = 5 \\cdot 10^{-8}$。\n6.  **停止检验:** 我们必须将 $|r_{33}|$ 与 $\\tau = 10^{-6} \\|A\\|_F$ 进行比较。\n    $\\|A\\|_F^2 = \\|a_1\\|_2^2 + \\|a_2\\|_2^2 + \\|a_3\\|_2^2 = 1^2 + (\\sqrt{2})^2 + (\\sqrt{30}\\cdot 10^{-8})^2 = 1 + 2 + 30 \\cdot 10^{-16} = 3 + 30 \\cdot 10^{-16}$。\n    $\\|A\\|_F = \\sqrt{3 + 30 \\cdot 10^{-16}} \\approx \\sqrt{3} \\approx 1.732$。\n    $\\tau = 10^{-6} \\cdot \\|A\\|_F \\approx 1.732 \\cdot 10^{-6}$。\n    我们检查是否 $|r_{33}| \\le \\tau$：即 $5 \\cdot 10^{-8} \\le 1.732 \\cdot 10^{-6}$ 是否成立？重写后为 $0.05 \\cdot 10^{-6} \\le 1.732 \\cdot 10^{-6}$，这是成立的。\n    因为在 $k=3$ 时条件满足，算法会宣布第三列在数值上是线性相关的并停止，报告数值秩为 $r = k-1 = 2$。\n    该陈述的所有部分都经验证是正确的。\n\n**结论：正确**",
            "answer": "$$\\boxed{ADF}$$"
        }
    ]
}