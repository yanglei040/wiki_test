{
    "hands_on_practices": [
        {
            "introduction": "本次练习将聚焦于吉文斯旋转的基本机理。你将从正交矩阵的第一性原理出发，推导出手动构造一个吉文斯旋转以消除特定矩阵元素所需的参数。这个练习旨在巩固吉文斯旋转在最基础层面上的核心工作原理，即如何通过平面旋转精确地将一个向量分量置零 。",
            "id": "3548499",
            "problem": "考虑稠密矩阵\n$$\nA \\;=\\; \\begin{pmatrix}\n4  -3  8 \\\\\n7  5  -2 \\\\\n1  -9  6\n\\end{pmatrix}.\n$$\n吉文斯旋转是一种平面正交变换，它非平凡地作用于选定的一对坐标，并保持欧几里得$2$-范数。仅使用正交矩阵作为 $\\mathbb{R}^{n}$ 中保范数的线性等距变换的基本定义以及 $\\mathbb{R}^{2}$ 中平面旋转的特征，推导出一个通过左乘作用于第 1 行和第 2 行并将 $A$ 的第 1 列对角线下方的元素（即元素 $a_{21}$）置零的吉文斯旋转的两个实数参数所满足的约束条件。从这些第一性原理出发，确定这些参数关于 $a_{11}$ 和 $a_{21}$ 的解析表达式，然后为上面给出的特定矩阵 $A$ 计算它们的值。\n\n报告将给定矩阵 $A$ 的 $a_{21}$ 置零的吉文斯旋转的余弦参数 $c$ 作为你的最终答案。以精确的封闭形式表示你的最终答案；不需要四舍五入。",
            "solution": "该问题被验证为具有科学依据、适定且客观。这是数值线性代数中的一个标准问题，它自洽且没有矛盾。\n\n任务是推导出一个将矩阵特定元素置零的吉文斯旋转的参数，然后为给定的矩阵 $A$ 计算其中一个参数的值。推导必须基于第一性原理。吉文斯旋转是作用于一个二维子空间的正交变换。\n\n设给定矩阵为 $A \\in \\mathbb{R}^{3 \\times 3}$，其元素记为 $a_{ij}$。\n$$\nA \\;=\\; \\begin{pmatrix}\n4  -3  8 \\\\\n7  5  -2 \\\\\n1  -9  6\n\\end{pmatrix}\n$$\n我们寻求一个吉文斯旋转矩阵 $G$，当通过左乘作用于 $A$ 时，将元素 $a_{21}=7$ 置零。该旋转必须作用于第 $1$ 行和第 $2$ 行。吉文斯旋转矩阵 $G$ 是一个正交矩阵，除了一个执行平面旋转的 $2 \\times 2$ 子矩阵外，与单位矩阵相同。对于作用于第 $1$ 行和第 $2$ 行的情况，矩阵 $G$ 的一般形式为：\n$$\nG \\;=\\; \\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n其中 $c$ 和 $s$ 是实数参数。\n\n所述的第一性原理是 $G$ 必须是一个正交矩阵。一个正交矩阵 $Q$ 满足条件 $Q^T Q = I$，其中 $I$ 是单位矩阵。这个性质确保该变换是一个线性等距变换，即它保持欧几里得 $2$-范数。将此条件应用于 $G$：\n$$\nG^T G = \\begin{pmatrix}\nc  -s  0 \\\\\ns  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\nc^2 + s^2  cs - sc  0 \\\\\nsc - cs  s^2 + c^2  0 \\\\\n0  0  1\n\\end{pmatrix} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n从结果单位矩阵的左上角元素，我们推导出关于参数 $c$ 和 $s$ 的第一个约束条件：\n$$\nc^2 + s^2 = 1\n$$\n这个约束证实了 $c$ 和 $s$ 可以被解释为某个旋转角 $\\theta$ 的余弦和正弦，即 $c = \\cos(\\theta)$ 和 $s = \\sin(\\theta)$，这符合这里使用的旋转矩阵约定（顺时针旋转 $\\theta$）。\n\n接下来，我们将该变换应用于矩阵 $A$，形成一个新矩阵 $A' = G A$。\n$$\nA' = \\begin{pmatrix}\nc  s  0 \\\\\n-s  c  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\na_{11}  a_{12}  a_{13} \\\\\na_{21}  a_{22}  a_{23} \\\\\na_{31}  a_{32}  a_{33}\n\\end{pmatrix}\n$$\n问题要求 $A'$ 的第二行第一列的元素，记为 $a'_{21}$，被置零（即，设为 $0$）。$a'_{21}$ 的表达式通过计算 $G$ 的第二行和 $A$ 的第一列的点积得到：\n$$\na'_{21} = (-s) \\cdot a_{11} + c \\cdot a_{21} + 0 \\cdot a_{31} = -s a_{11} + c a_{21}\n$$\n将 $a'_{21} = 0$ 得到第二个约束条件：\n$$\n-s a_{11} + c a_{21} = 0 \\quad \\implies \\quad c a_{21} = s a_{11}\n$$\n我们现在得到了一个关于两个未知数 $c$ 和 $s$ 的方程组：\n1. $c^2 + s^2 = 1$\n2. $c a_{21} = s a_{11}$\n\n假设 $a_{11} \\ne 0$，我们可以写出 $s = c \\frac{a_{21}}{a_{11}}$。将此代入第一个方程：\n$$\nc^2 + \\left(c \\frac{a_{21}}{a_{11}}\\right)^2 = 1\n$$\n$$\nc^2 \\left(1 + \\frac{a_{21}^2}{a_{11}^2}\\right) = 1\n$$\n$$\nc^2 \\left(\\frac{a_{11}^2 + a_{21}^2}{a_{11}^2}\\right) = 1\n$$\n$$\nc^2 = \\frac{a_{11}^2}{a_{11}^2 + a_{21}^2}\n$$\n开平方根，我们得到 $c = \\pm \\frac{|a_{11}|}{\\sqrt{a_{11}^2 + a_{21}^2}}$。一个标准的约定是选择正根并让 $c$ 与 $a_{11}$ 同号，这也确保了新的对角元素 $a'_{11}$ 是正的。这导出了 $c$ 的一般解析表达式：\n$$\nc = \\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{21}^2}}\n$$\n将此代回 $c a_{21} = s a_{11}$，我们解出 $s$：\n$$\n\\left(\\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{21}^2}}\\right) a_{21} = s a_{11}\n$$\n假设 $a_{11} \\ne 0$，我们得到 $s$ 的表达式：\n$$\ns = \\frac{a_{21}}{\\sqrt{a_{11}^2 + a_{21}^2}}\n$$\n如果 $a_{11}=0$，置零方程变为 $c a_{21} = 0$。如果 $a_{21} \\ne 0$，则 $c=0$。从 $c^2+s^2=1$，我们得到 $s^2=1$，所以 $s=\\pm 1$。我们的公式得出 $c=0$ 和 $s=a_{21}/|a_{21}| = \\pm 1$，这是相容的。如果 $a_{11}=0$ 和 $a_{21}=0$ 都成立，则该元素已经是零，不需要旋转（$c=1, s=0$）。因此我们的公式是稳健的。\n\n现在，我们为给定的矩阵 $A$ 计算这些参数的值。相关元素是 $a_{11} = 4$ 和 $a_{21} = 7$。\n首先，我们计算分母，它对应于向量 $(a_{11}, a_{21})^T$ 的欧几里得范数。设其为 $r$。\n$$\nr = \\sqrt{a_{11}^2 + a_{21}^2} = \\sqrt{4^2 + 7^2} = \\sqrt{16 + 49} = \\sqrt{65}\n$$\n使用推导出的解析表达式，余弦参数 $c$ 是：\n$$\nc = \\frac{a_{11}}{r} = \\frac{4}{\\sqrt{65}}\n$$\n为了完整性，正弦参数 $s$ 是：\n$$\ns = \\frac{a_{21}}{r} = \\frac{7}{\\sqrt{65}}\n$$\n问题要求余弦参数 $c$ 的值，并以精确的封闭形式表示。\n最终答案是 $c = \\frac{4}{\\sqrt{65}}$。",
            "answer": "$$\n\\boxed{\\frac{4}{\\sqrt{65}}}\n$$"
        },
        {
            "introduction": "在单个旋转的基础上，本练习将探讨一个关键的实际挑战：如何将QR分解应用于秩亏矩阵。你将分析如何通过监测对角元素和引入列主元策略，将标准的基于吉文斯旋转的QR算法转变为一个数值稳定且能揭示矩阵秩的工具。这对于理解在实际计算中如何处理近似线性相关的列至关重要 。",
            "id": "3548451",
            "problem": "考虑使用一系列Givens旋转来计算一个可能秩亏的实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的正交三角(QR)分解。Givens旋转是一种正交变换，它作用于一对行，将一个目标次对角线元素置为零，同时保持其所乘向量的欧几里得范数不变。令 $A P = Q R$ 表示带列主元的QR分解，其中 $P \\in \\mathbb{R}^{n \\times n}$ 是一个置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是上三角矩阵。在存在秩亏的情况下，一个重要的实用改进是监控 $R$ 的对角线元素 $r_{kk}$，并在对第 $k$ 步应用Givens旋转之前，应用列主元法将剩余列中2-范数最大的列移动到第 $k$ 个主元位置。当 $|r_{kk}|$ 相对于某个全局尺度非常小时，可以使用一个数值停止准则来提前终止分解，并确定一个数值秩。\n\n从正交变换的定义和性质以及QR分解的Gram–Schmidt解释（即 $r_{kk}$ 等于第 $k$ 个主元列在与先前已选列正交化后的残差范数）出发，回答以下多项选择题。你应该推理列主元法和监控小的 $r_{kk}$ 如何使基于Givens的QR算法适应秩亏情况，以及这对数值稳定性有何影响。\n\n设\n$$\nA \\;=\\;\n\\begin{bmatrix}\n1  1  10^{-8} \\\\\n0  1  2\\cdot 10^{-8} \\\\\n0  0  3\\cdot 10^{-8} \\\\\n0  0  4\\cdot 10^{-8}\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 3},\n$$\n并考虑一个基于Givens的QR分解，采用贪心列主元法（在每一步，将 $A$ 的剩余列中2-范数最大者交换到位置 $k$），同时监控 $|r_{kk}|$ 是否超过阈值 $\\tau = 10^{-6} \\|A\\|_F$（其中 $\\|A\\|_F$ 是弗罗贝尼乌斯范数）。选择所有正确的陈述。\n\nA. 在基于Givens的带贪心列主元QR分解中，在应用旋转之前将剩余列中2-范数最大者交换到主元位置 $k$，可确保 $r_{kk}$ 等于第 $k$ 个主元列正交化后的残差的欧几里得范数；当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值秩揭示分解 $A P = Q R$，这与标准阈值实践一致。\n\nB. 因为Givens旋转作用于行，所以为解决秩亏问题，执行行主元法（而非列主元法）既充分又恰当；得到的分解 $P^{\\top} A = Q R$ 会以与列主元QR相同的方式揭示列秩。\n\nC. 在基于Givens的QR分解过程中交换列会破坏累积的 $Q$ 的正交性，使 $Q^{\\top} Q = I$ 不再成立；因此，列主元法与维持一个正交的 $Q$ 不兼容。\n\nD. 如果 $|r_{kk}|$ 相对于一个全局尺度（例如 $\\|A\\|_F$）非常小，这表明第 $k$ 个主元列在正交化后几乎包含在前 $k-1$ 个列的张成空间中；此时停止并宣布数值秩为 $r = k-1$，可以避免舍入误差的过度放大，并比继续对近线性相关的列进行旋转提高了数值稳定性。\n\nE. 在基于Givens的QR分解中引入列主元法会将渐进计算复杂度从 $\\mathcal{O}(m n^{2})$ 增加到 $\\mathcal{O}(m^{2} n)$，因为每次旋转后都必须重新计算列范数；因此，对于大的 $m$ 和 $n$ 来说，这是不切实际的。\n\nF. 对于给定的矩阵 $A$，贪心列主元顺序是先第二列，然后第一列，最后第三列；使用 $\\tau = 10^{-6} \\|A\\|_F$ 时，当 $|r_{33}| \\le \\tau$ 时，算法将宣布数值秩为 $2$。\n\n选择所有适用项：A, B, C, D, E, F。",
            "solution": "用户希望我批判性地验证并解决一个关于使用带列主元的Givens旋转对秩亏矩阵进行QR分解的多项选择题。\n\n### 问题验证\n\n**第1步：提取给定信息**\n- 任务是使用Givens旋转计算一个可能秩亏的实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的正交三角(QR)分解。\n- Givens旋转是一种作用于两行以将次对角线元素置零的正交变换。\n- 带列主元的分解表示为 $A P = Q R$，其中 $P \\in \\mathbb{R}^{n \\times n}$ 是置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是上三角矩阵。\n- 对于秩亏情况，算法涉及监控 $R$ 的对角线元素 $r_{kk}$。\n- 列主元策略：在第 $k$ 步，将剩余列中2-范数最大的列移动到第 $k$ 个主元位置。\n- 停止准则：当 $|r_{kk}|$ 相对于某个全局尺度非常小时，可以宣布一个数值秩并提前终止分解。\n- Gram–Schmidt解释：$r_{kk}$ 等于第 $k$ 个主元列在与先前已选列正交化后的残差范数。\n- 提供的具体矩阵是：\n$$\nA \\;=\\;\n\\begin{bmatrix}\n1  1  10^{-8} \\\\\n0  1  2\\cdot 10^{-8} \\\\\n0  0  3\\cdot 10^{-8} \\\\\n0  0  4\\cdot 10^{-8}\n\\end{bmatrix} \\in \\mathbb{R}^{4 \\times 3}\n$$\n- 具体的主元策略是“贪心列主元法（在每一步，将 $A$ 的剩余列中2-范数最大者交换到位置 $k$）”。\n- 具体的停止阈值是 $\\tau = 10^{-6} \\|A\\|_F$，其中 $\\|A\\|_F$ 是弗罗贝尼乌斯范数。\n\n**第2步：使用提取的给定信息进行验证**\n- **科学上合理：** 该问题植根于数值线性代数中标准且完善的概念，特别是秩揭示QR分解、Givens旋转和列主元法。所述的 $r_{kk}$ 的大小与线性相关性之间的联系是该主题的基石。使用像 $\\tau = 10^{-6} \\|A\\|_F$ 这样的阈值是数值实践中的常见启发式方法。\n- **良态的：** 问题陈述提供了所有必要信息：矩阵 $A$、算法的清晰描述（带贪心列主元的Givens QR）和停止准则。这个设置允许对算法的属性及其在给定矩阵上的应用进行明确的分析。\n- **客观的：** 语言正式、精确，没有主观或含糊的术语。\n\n**缺陷清单：**\n1.  **科学或事实上的不健全：** 无。前提在数值线性代数领域内是事实正确的。\n2.  **不可形式化或不相关：** 无。问题是形式化的，并与主题直接相关。\n3.  **不完整或矛盾的设置：** 无。设置是自包含的。\n4.  **不切实际或不可行：** 无。矩阵和算法在计算上是现实的。\n5.  **病态或结构不良：** 无。选项中提出的问题定义良好，可以从给定信息中回答。\n6.  **伪深刻、琐碎或同义反复：** 无。该问题需要对数值稳定性、算法复杂度和QR分解机制的多方面理解。\n7.  **超出科学可验证性：** 无。所有主张都可以通过数学方式验证。\n\n**第3步：结论与行动**\n问题陈述是有效的。我将继续进行解答。\n\n### 推导与选项分析\n\n该问题涉及带列主元的QR分解(QRCP)，特别是使用Givens旋转。分解的形式为 $AP = QR$。在每一步 $k$（对于 $k = 1, \\dots, n$）：\n1. 在矩阵当前状态下的剩余列中（从索引 $k$ 到 $n$），我们识别出其子列（从行 $k$ 到 $m$）具有最大欧几里得（2-）范数的列。\n2. 我们将此列与当前的第 $k$ 列交换。此交换记录在置换矩阵 $P$ 中。\n3. 我们使用一系列Givens旋转，将这个新的第 $k$ 列的次对角线元素置为零。这些旋转被累积到正交矩阵 $Q$ 中。\n\n关键思想是，所得矩阵 $R$ 的对角线元素 $r_{kk}$ 表示第 $k$ 个主元列中与前 $k-1$ 个主元列的张成空间正交的分量的长度。一个小的 $|r_{kk}|$ 值表示第 $k$ 个主元列几乎与前面的列线性相关。这允许确定数值秩。\n\n现在我们评估每个陈述。\n\n**A. 在基于Givens的带贪心列主元QR分解中，在应用旋转之前将剩余列中2-范数最大者交换到主元位置 $k$，可确保 $r_{kk}$ 等于第 $k$ 个主元列正交化后的残差的欧几里得范数；当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值秩揭示分解 $A P = Q R$，这与标准阈值实践一致。**\n\n这个陈述有两部分。\n1. “...$r_{kk}$ 等于第 $k$ 个主元列正交化后的残差的欧几里得范数...”。这是任何QR分解的基本属性。如果 $AP=[a'_1, \\dots, a'_n]$ 且 $Q=[q_1, \\dots, q_m]$，则方程 $AP=QR$ 意味着 $a'_k = \\sum_{i=1}^k r_{ik}q_i$。列 $q_1, \\dots, q_{k-1}$ 构成了 $\\{a'_1, \\dots, a'_{k-1}\\}$ 张成空间的一组标准正交基。$a'_k$ 对此基正交化后的残差为 $a'_k - \\sum_{i=1}^{k-1} \\langle a'_k, q_i \\rangle q_i$。从 $AP=QR$ 可知 $\\langle a'_k, q_i \\rangle = r_{ik}$。因此，残差为 $a'_k - \\sum_{i=1}^{k-1} r_{ik}q_i = r_{kk}q_k$。此残差的欧几里得范数为 $\\|r_{kk}q_k\\|_2 = |r_{kk}|\\|q_k\\|_2 = |r_{kk}|$。这部分是正确的。\n2. “...当 $|r_{kk}| \\le \\tau$ 时停止，会得到一个数值秩揭示分解...与标准阈值实践一致。” 这是QRCP的主要目的。贪心列选择策略旨在每一步最大化 $|r_{kk}|$，使得任何后续出现的小 $|r_{kk}|$ 成为近线性相关的强有力指标。基于阈值停止是确定数值秩的标准方法。\n整个陈述是对秩揭示QR的正确而简洁的描述。\n\n**结论：正确**\n\n**B. 因为Givens旋转作用于行，所以为解决秩亏问题，执行行主元法（而非列主元法）既充分又恰当；得到的分解 $P^{\\top} A = Q R$ 会以与列主元QR相同的方式揭示列秩。**\n\n这是不正确的。$A$ 的秩亏涉及其*列*之间的线性相关性。行操作，包括行主元法 ($P^\\top A$)，会改变矩阵的列空间（即 $\\text{col}(P^\\top A)$ 不一定等于 $\\text{col}(A)$）。要分析 $A$ 的列之间的相关性，必须使用列操作，例如由 $AP$ 表示的列置换。列主元法保留了列空间，仅仅是对基向量重新排序。行主元法用于分析*行秩*（或等价地，$A^\\top$ 的列秩）。虽然数学上行秩等于列秩，但揭示列相关性的数值算法必须对列进行操作。\n\n**结论：不正确**\n\n**C. 在基于Givens的QR分解过程中交换列会破坏累积的 $Q$ 的正交性，使 $Q^{\\top} Q = I$ 不再成立；因此，列主元法与维持一个正交的 $Q$ 不兼容。**\n\n这曲解了算法。分解是 $AP=QR$。矩阵 $Q$ 是由正交的Givens旋转矩阵的乘积形成的，即 $Q = G_1^\\top G_2^\\top \\dots G_k^\\top$。正交矩阵的乘积总是正交矩阵，所以 $Q^\\top Q=I$ 是保证的。列交换不属于 $Q$ 的一部分；它们完全由置换矩阵 $P$ 来解释。正交变换（Givens旋转）应用于列置换后的矩阵 $AP$。该过程正确地计算出三个独立的矩阵：一个正交的 $Q$，一个上三角的 $R$ 和一个置换矩阵 $P$。\n\n**结论：不正确**\n\n**D. 如果 $|r_{kk}|$ 相对于一个全局尺度（例如 $\\|A\\|_F$）非常小，这表明第 $k$ 个主元列在正交化后几乎包含在前 $k-1$ 个列的张成空间中；此时停止并宣布数值秩为 $r = k-1$，可以避免舍入误差的过度放大，并比继续对近线性相关的列进行旋转提高了数值稳定性。**\n\n这个陈述准确地描述了停止准则的解释和好处。如在分析选项A时所确立的，|r_kk|是第 $k$ 个主元列中“新的”或与先前主元列正交的部分的范数。因此，一个小的 $|r_{kk}|$ 意味着第 $k$ 列几乎在前 $k-1$ 个列 $\\{1, \\dots, k-1\\}$ 的张成空间中。如果算法继续进行，未来的步骤可能涉及除以这个小的 $r_{kk}$（例如，在解线性系统 $Rx=y$ 时），这在数值上是不稳定的，并会放大舍入误差。通过停止并宣布数值秩为 $r=k-1$，我们为数值列空间确定了一个良态基，并避免了这些不稳定性。\n\n**结论：正确**\n\n**E. 在基于Givens的QR分解中引入列主元法会将渐进计算复杂度从 $\\mathcal{O}(m n^{2})$ 增加到 $\\mathcal{O}(m^{2} n)$，因为每次旋转后都必须重新计算列范数；因此，对于大的 $m$ 和 $n$ 来说，这是不切实际的。**\n\n使用Givens或Householder方法对 $m \\times n$ 矩阵（$m \\ge n$）进行QR分解的标准复杂度是 $\\mathcal{O}(mn^2)$。让我们分析主元法的额外成本。在第 $k$ 步，我们需要在剩下的 $n-k+1$ 列中找到范数最大的那一列。一个关键的细节是，范数不需要从头重新计算。正交变换只会以可预测的方式修改向量范数。具体来说，对矩阵的两行应用Givens旋转只影响这两行所涉及的列的范数。每次旋转，每列的范数平方可以通过常数次操作来更新。在整个过程中更新所有相关范数的总工作量受限于旋转本身的成本。主要成本仍然是应用旋转，即 $\\mathcal{O}(mn^2)$。寻找最大范数列（每步`$O(n)$`，总共`$O(n^2)$`）和更新范数的开销是较低阶的，或者被吸收到主复杂度项中。因此，总复杂度仍然是 $\\mathcal{O}(mn^2)$。声称增加到 $\\mathcal{O}(m^2 n)$ 是错误的。\n\n**结论：不正确**\n\n**F. 对于给定的矩阵 $A$，贪心列主元顺序是先第二列，然后第一列，最后第三列；使用 $\\tau = 10^{-6} \\|A\\|_F$ 时，当 $|r_{33}| \\le \\tau$ 时，算法将宣布数值秩为 $2$。**\n\n让我们进行计算。$A$ 的列是 $a_1 = [1, 0, 0, 0]^\\top$，$a_2 = [1, 1, 0, 0]^\\top$ 和 $a_3 = [10^{-8}, 2\\cdot10^{-8}, 3\\cdot10^{-8}, 4\\cdot10^{-8}]^\\top$。\n1.  **步骤 k=1 (主元选择):** 计算初始列范数。\n    $\\|a_1\\|_2 = \\sqrt{1^2} = 1$。\n    $\\|a_2\\|_2 = \\sqrt{1^2 + 1^2} = \\sqrt{2} \\approx 1.414$。\n    $\\|a_3\\|_2 = \\sqrt{(1^2+2^2+3^2+4^2)(10^{-8})^2} = \\sqrt{30} \\cdot 10^{-8} \\approx 5.48 \\cdot 10^{-8}$。\n    最大范数是 $\\|a_2\\|_2$。所以，第一个主元列是 $a_2$。置换矩阵 $P$ 将交换第1列和第2列。\n2.  **步骤 k=1 (旋转):** 令 $A' = [a_2, a_1, a_3]$。我们对 $A'$ 的第1行和第2行应用Givens旋转，以将 $(2,1)$ 元素置零。之后，矩阵变为（如思考过程中推导）：\n    $$\n    A^{(1)} = \\begin{bmatrix} \\sqrt{2}  1/\\sqrt{2}  3\\cdot 10^{-8}/\\sqrt{2} \\\\ 0  -1/\\sqrt{2}  1\\cdot 10^{-8}/\\sqrt{2} \\\\ 0  0  3\\cdot 10^{-8} \\\\ 0  0  4\\cdot 10^{-8} \\end{bmatrix}\n    $$\n    所以 $r_{11} = \\sqrt{2}$。\n3.  **步骤 k=2 (主元选择):** 我们比较第2列和第3列剩余部分的范数。\n    对于第2列（原始的 $a_1$），剩余部分是 $[-1/\\sqrt{2}, 0, 0]^\\top$。其范数为 $|-1/\\sqrt{2}| = 1/\\sqrt{2}$。\n    对于第3列（原始的 $a_3$），剩余部分是 $[1\\cdot 10^{-8}/\\sqrt{2}, 3\\cdot 10^{-8}, 4\\cdot 10^{-8}]^\\top$。其范数为 $\\sqrt{(0.5+9+16)(10^{-8})^2} = \\sqrt{25.5} \\cdot 10^{-8} \\approx 5.05\\cdot 10^{-8}$。\n    由于 $1/\\sqrt{2} \\gg \\sqrt{25.5} \\cdot 10^{-8}$，第二个主元是当前的第2列（原始的 $a_1$）。不需要交换。主元顺序确实是 $(a_2, a_1, a_3)$。\n4.  **步骤 k=2 (旋转):** $A^{(1)}$ 的第二列在对角线下方已经为零，所以 $r_{22} = -1/\\sqrt{2}$。\n5.  **步骤 k=3:** 处理最后一列。剩余部分是 $[3\\cdot 10^{-8}, 4\\cdot 10^{-8}]^\\top$。对第3行和第4行进行Givens旋转将使其变为 $[5\\cdot 10^{-8}, 0]^\\top$。因此，$r_{33} = 5 \\cdot 10^{-8}$。\n6.  **停止检验:** 我们必须将 $|r_{33}|$ 与 $\\tau = 10^{-6} \\|A\\|_F$ 进行比较。\n    $\\|A\\|_F^2 = \\|a_1\\|_2^2 + \\|a_2\\|_2^2 + \\|a_3\\|_2^2 = 1^2 + (\\sqrt{2})^2 + (\\sqrt{30}\\cdot 10^{-8})^2 = 1 + 2 + 30 \\cdot 10^{-16} = 3 + 30 \\cdot 10^{-16}$。\n    $\\|A\\|_F = \\sqrt{3 + 30 \\cdot 10^{-16}} \\approx \\sqrt{3} \\approx 1.732$。\n    $\\tau = 10^{-6} \\cdot \\|A\\|_F \\approx 1.732 \\cdot 10^{-6}$。\n    我们检查是否 $|r_{33}| \\le \\tau$：$5 \\cdot 10^{-8} \\le 1.732 \\cdot 10^{-6}$？重写为 $0.05 \\cdot 10^{-6} \\le 1.732 \\cdot 10^{-6}$，这是成立的。\n    因为在 $k=3$ 时条件满足，算法宣布第三列在数值上是相关的并停止，报告数值秩为 $r = k-1 = 2$。\n    该陈述的所有部分都经验证是正确的。\n\n**结论：正确**",
            "answer": "$$\\boxed{ADF}$$"
        },
        {
            "introduction": "最后的这个综合练习要求你从零开始，完整实现一个基于吉文斯旋转的QR分解算法。为了确保其正确性并加深理解，你还将实现豪斯霍尔德QR方法作为对比，并设计一系列交叉验证检查。这个练习将重点强调算法验证和处理符号约定等微妙之处的重要性，这些都是计算科学家必备的关键技能 。",
            "id": "3548524",
            "problem": "设计并实现一个完整的程序，该程序针对一个给定的实数矩阵有限集，计算两种正交三角（QR）分解：一种通过Householder反射实现，另一种通过Givens旋转实现。目标是构建有原则的交叉检验，用以验证正交性、三角因子的上梯形结构、重构精度，并提出和实现一种数学上合理的方法来对齐符号，从而使得两个三角因子在一致的符号约定下具有可比性。\n\n您的推导和实现必须基于以下基本原理：\n- 正交矩阵的定义：一个实矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{m \\times m}$ 是正交的，如果 $\\mathbf{Q}^{\\top} \\mathbf{Q} = \\mathbf{I}_m$。\n- 由内积诱导的欧几里得范数，以及由矩阵上的欧几里得内积诱导的Frobenius范数 $\\|\\cdot\\|_F$。\n- Householder反射是一种形式为 $\\mathbf{H} = \\mathbf{I} - 2 \\mathbf{u} \\mathbf{u}^{\\top}$ 的正交变换，其中 $\\mathbf{u} \\in \\mathbb{R}^{k}$ 且 $\\|\\mathbf{u}\\|_2 = 1$，该变换将向量关于与 $\\mathbf{u}$ 正交的超平面进行反射。\n- Givens旋转是一种作用于由两个标准基向量张成的坐标平面上的正交变换，由满足 $c^2 + s^2 = 1$ 的标量 $c$ 和 $s$ 参数化，用于将选定的元素置零。\n\n您必须：\n- 使用Householder反射构造 $\\mathbf{Q}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{H}}$，使得 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{H}} \\mathbf{R}_{\\mathrm{H}}$，其中 $\\mathbf{Q}_{\\mathrm{H}}$ 是正交矩阵，$\\mathbf{R}_{\\mathrm{H}}$ 是上梯形矩阵。\n- 使用Givens旋转构造 $\\mathbf{Q}_{\\mathrm{G}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$，使得 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{G}} \\mathbf{R}_{\\mathrm{G}}$，其中 $\\mathbf{Q}_{\\mathrm{G}}$ 是正交矩阵，$\\mathbf{R}_{\\mathrm{G}}$ 是上梯形矩阵。\n- 提出并实现一种符号对齐方法，以使 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 的对角线在单一符号约定下具有可比性。该方法必须对每种分解都保持等式 $\\mathbf{A} = \\mathbf{Q} \\mathbf{R}$ 成立。一种有效的方法是，对于 $k = 1, \\dots, \\min(m,n)$，当对角元素 $\\mathbf{R}_{k k}$ 为负时，通过将 $\\mathbf{R}$ 的第 $k$ 行和 $\\mathbf{Q}$ 的第 $k$ 列乘以 $-1$ 来强制 $\\mathbf{R}$ 的对角线元素为非负；当 $\\mathbf{R}_{k k}$ 在数值上为零时，保持不变。\n\n对于每个矩阵，设计交叉检验以验证：\n- 上梯形结构：$\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 的主对角线严格下方的元素的量级相对于 $\\mathbf{A}$ 的尺度而言很小。\n- 正交性：对于 $\\mathbf{Q}_{\\mathrm{H}}$ 和 $\\mathbf{Q}_{\\mathrm{G}}$，$\\|\\mathbf{Q}^{\\top}\\mathbf{Q} - \\mathbf{I}_m\\|_F$ 的值都很小。\n- 重构：对于两种分解，$\\|\\mathbf{A} - \\mathbf{Q}\\mathbf{R}\\|_F$ 的值都很小。\n- 对齐后的三角因子比较：对 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 应用符号对齐约定后，两个三角因子在Frobenius范数下近似相等。\n\n所有比较必须使用一个基于输入矩阵的Frobenius范数 $\\|\\mathbf{A}\\|_F$ 和一个尺度不变阈值的、数值上合理的容差。在Givens旋转中使用余弦和正弦时，角度是隐式包含的，不需要明确的单位。不涉及任何物理单位。\n\n请直接根据上述原理实现算法；不要调用任何内置的正交三角分解（QR）例程。但是，您可以使用基本的线性代数运算。\n\n使用以下实数矩阵测试套件，以数组形式明确给出：\n- 测试用例1（高矩阵，满列秩）：\n$$\n\\mathbf{A}_1 =\n\\begin{bmatrix}\n3  -2  5 \\\\\n7  1  -1 \\\\\n2  4  0 \\\\\n-3  5  2 \\\\\n1  -6  3\n\\end{bmatrix}.\n$$\n- 测试用例2（方阵，满秩）：\n$$\n\\mathbf{A}_2 =\n\\begin{bmatrix}\n4  2  -2 \\\\\n1  3  0 \\\\\n0  -1  5\n\\end{bmatrix}.\n$$\n- 测试用例3（方阵，秩亏）：\n$$\n\\mathbf{A}_3 =\n\\begin{bmatrix}\n1  0  1  2 \\\\\n0  1  2  -1 \\\\\n2  -3  -4  1 \\\\\n-1  4  7  0\n\\end{bmatrix}.\n$$\n- 测试用例4（宽矩阵，满行秩）：\n$$\n\\mathbf{A}_4 =\n\\begin{bmatrix}\n1  0  2  -1  3 \\\\\n0  -2  1  4  -1 \\\\\n3  5  -2  0  1\n\\end{bmatrix}.\n$$\n\n对于每个 $\\mathbf{A}_i$，将所有交叉检验聚合为单个布尔结果 $b_i$，当且仅当以下所有条件同时成立时，该结果为 $\\mathrm{True}$：\n- $\\mathbf{R}_{\\mathrm{H}}$ 在容差范围内是上梯形的。\n- $\\mathbf{R}_{\\mathrm{G}}$ 在容差范围内是上梯形的。\n- $\\mathbf{Q}_{\\mathrm{H}}$ 在容差范围内是正交的。\n- $\\mathbf{Q}_{\\mathrm{G}}$ 在容差范围内是正交的。\n- $\\mathbf{A}_i \\approx \\mathbf{Q}_{\\mathrm{H}} \\mathbf{R}_{\\mathrm{H}}$ 且 $\\mathbf{A}_i \\approx \\mathbf{Q}_{\\mathrm{G}} \\mathbf{R}_{\\mathrm{G}}$ 在容差范围内成立。\n- 在进行符号对齐以强制 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 的对角线为非负后，两个三角因子在容差范围内近似匹配。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含布尔结果，形式为方括号内以逗号分隔的列表，顺序为 $[b_1,b_2,b_3,b_4]$。例如，如果所有测试用例都通过了所有交叉检验，输出可能为 $[\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}]$。",
            "solution": "该问题提法明确，科学上合理，并包含了解决问题所需的所有信息。它要求实现并验证两种基本的数值线性代数算法——通过Householder反射和Givens旋转实现的QR分解——并进行后续比较。这在计算科学中是一项标准且有价值的练习。\n\n核心任务是找到给定实矩阵 $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$ 的QR分解，这是一种形式为 $\\mathbf{A} = \\mathbf{Q}\\mathbf{R}$ 的分解，其中 $\\mathbf{Q} \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵（$\\mathbf{Q}^{\\top}\\mathbf{Q} = \\mathbf{I}_m$），$\\mathbf{R} \\in \\mathbb{R}^{m \\times n}$ 是一个上梯形矩阵。上梯形矩阵在其主对角线以下的元素为零，即对于 $i  j$，有 $\\mathbf{R}_{ij} = 0$。\n\n我们将分别使用Householder反射和Givens旋转来构造两种这样的分解，即 $(\\mathbf{Q}_{\\mathrm{H}}, \\mathbf{R}_{\\mathrm{H}})$ 和 $(\\mathbf{Q}_{\\mathrm{G}}, \\mathbf{R}_{\\mathrm{G}})$。\n\n### 1. 通过Householder反射实现QR分解\n\n其策略是向矩阵 $\\mathbf{A}$ 应用一系列正交变换，以在主对角线下方逐步引入零。每次变换会将某一列的次对角线元素置零。Householder反射是完成此任务的工具。\n\n对于每一列 $k$（从 $1$ 到 $\\min(m-1, n)$），我们的目标是将当前矩阵（我们称之为 $\\mathbf{A}^{(k-1)}$，其中 $\\mathbf{A}^{(0)} = \\mathbf{A}$）变换为 $\\mathbf{A}^{(k)} = \\mathbf{H}_k \\mathbf{A}^{(k-1)}$，其中 $\\mathbf{H}_k$ 是一个被选择用来将第 $k$ 列中对角元素 $\\mathbf{A}^{(k)}_{kk}$ 下方的元素置零的Householder反射。\n\n反射矩阵 $\\mathbf{H}_k$ 作用于向量 $\\mathbf{x} \\in \\mathbb{R}^{m-k+1}$，该向量是子列 $\\mathbf{A}^{(k-1)}_{k:m,k}$。我们需要一个反射矩阵 $\\hat{\\mathbf{H}}_k$ 使得 $\\hat{\\mathbf{H}}_k \\mathbf{x} = \\alpha \\mathbf{e}_1$，其中 $\\mathbf{e}_1 = [1, 0, \\dots, 0]^{\\top}$ 且 $\\alpha$ 是一个标量。由于正交变换保持欧几里得范数不变，因此 $|\\alpha| = \\|\\mathbf{x}\\|_2$。该反射由一个垂直于反射超平面的向量 $\\mathbf{v}$ 定义。该向量由 $\\mathbf{v} = \\mathbf{x} - \\alpha \\mathbf{e}_1$ 给出。为避免数值抵消，$\\alpha$ 的一个稳健选择是 $\\alpha = -\\mathrm{sgn}(\\mathbf{x}_1) \\|\\mathbf{x}\\|_2$，其中 $\\mathbf{x}_1$ 是 $\\mathbf{x}$ 的第一个分量。\n\nHouseholder反射则由 $\\hat{\\mathbf{H}}_k = \\mathbf{I} - 2\\frac{\\mathbf{v}\\mathbf{v}^{\\top}}{\\mathbf{v}^{\\top}\\mathbf{v}}$ 给出。在实践中，为避免显式构造矩阵，我们计算 $\\beta = 2/(\\mathbf{v}^{\\top}\\mathbf{v})$ 并将变换应用于矩阵 $\\mathbf{C}$，形式为 $\\hat{\\mathbf{H}}_k\\mathbf{C} = \\mathbf{C} - \\beta \\mathbf{v}(\\mathbf{v}^{\\top}\\mathbf{C})$。\n\n在第 $k$ 步的完整变换矩阵是 $\\mathbf{H}_k = \\begin{pmatrix} \\mathbf{I}_{k-1}  \\mathbf{0} \\\\ \\mathbf{0}  \\hat{\\mathbf{H}}_k \\end{pmatrix}$。经过 $\\min(m-1, n)$ 步后，我们得到 $\\mathbf{R}_{\\mathrm{H}} = \\mathbf{H}_{\\min(m-1,n)} \\dots \\mathbf{H}_2 \\mathbf{H}_1 \\mathbf{A}$。\n因为每个 $\\mathbf{H}_k$ 都是正交的，所以它们的乘积也是正交的。令 $\\mathbf{Q}_{\\mathrm{H}}^{\\top} = \\mathbf{H}_{\\min(m-1,n)} \\dots \\mathbf{H}_1$。于是 $\\mathbf{A} = \\mathbf{Q}_{\\mathrm{H}}\\mathbf{R}_{\\mathrm{H}}$，其中 $\\mathbf{Q}_{\\mathrm{H}} = \\mathbf{H}_1^{\\top} \\dots \\mathbf{H}_{\\min(m-1,n)}^{\\top} = \\mathbf{H}_1 \\dots \\mathbf{H}_{\\min(m-1,n)}$。\n矩阵 $\\mathbf{Q}_{\\mathrm{H}}$ 的构造方法是，从单位矩阵 $\\mathbf{Q} = \\mathbf{I}_m$ 开始，并依次右乘每个反射矩阵：$\\mathbf{Q} \\leftarrow \\mathbf{Q} \\mathbf{H}_k$。\n\n### 2. 通过Givens旋转实现QR分解\n\nGivens旋转提供了一种更精细的方法，一次只引入一个零。Givens旋转作用于由两个坐标轴张成的二维平面。为了使用位于 $(j, j)$ 的主元元素将位置 $(i, j)$（其中 $i  j$）的元素置零，我们在 $(j, i)$ 平面内应用一个旋转。\n\n设这两个元素的值为 $a = \\mathbf{R}_{jj}$ 和 $b = \\mathbf{R}_{ij}$。我们寻求一个旋转矩阵，将向量 $[a, b]^{\\top}$ 变换为 $[r, 0]^{\\top}$。该旋转矩阵为\n$$\n\\mathbf{G}_{ji}^{\\top} = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n其中 $c^2 + s^2 = 1$。该变换产生 $\\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} ca + sb \\\\ -sa + cb \\end{pmatrix}$。为使第二个分量为零，我们选择 $c = a/r$ 和 $s = b/r$，其中 $r = \\sqrt{a^2 + b^2}$。这将得到新向量 $[r, 0]^{\\top}$。\n\n整体算法的流程是遍历列 $j$（从 $1$ 到 $n$），对于每一列，再遍历行 $i$（从 $j+1$ 到 $m$）。在每一步 $(i, j)$，一个Givens旋转 $\\mathbf{G}_{ji}^{\\top}$ 被左乘到当前矩阵上，以将元素 $\\mathbf{R}_{ij}$ 置零。\n最终的上梯形矩阵是 $\\mathbf{R}_{\\mathrm{G}} = (\\dots \\mathbf{G}_{m,n-1}^{\\top} \\dots \\mathbf{G}_{j+1,j}^{\\top} \\dots) \\mathbf{A}$。\n正交矩阵 $\\mathbf{Q}_{\\mathrm{G}}$ 是所有Givens矩阵的乘积：$\\mathbf{Q}_{\\mathrm{G}} = (\\dots \\mathbf{G}_{j+1,j} \\dots \\mathbf{G}_{m,n-1} \\dots)$。它的构造方法是，将 $\\mathbf{Q}$ 初始化为 $\\mathbf{I}_m$，然后依次右乘每个Givens矩阵 $\\mathbf{G}_{ji}$。$\\mathbf{Q}$ 的两列 $\\mathbf{q}_j$ 和 $\\mathbf{q}_i$ 的更新规则变为：\n$(\\mathbf{q}'_j, \\mathbf{q}'_i) = (\\mathbf{q}_j, \\mathbf{q}_i) \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix}$。\n\n### 3. 符号对齐与唯一性\n\n满秩矩阵的QR分解是唯一的，直至相差 $\\mathbf{Q}$ 的列和 $\\mathbf{R}$ 的行的符号。具体来说，如果 $\\mathbf{A} = \\mathbf{Q}\\mathbf{R}$，那么对于任何对角元素为 $\\mathbf{D}_{kk} = \\pm 1$ 的对角矩阵 $\\mathbf{D}$，分解 $\\mathbf{A} = (\\mathbf{Q}\\mathbf{D})(\\mathbf{D}\\mathbf{R})$ 也是一个有效的QR分解。为了能够在 $\\mathbf{R}_{\\mathrm{H}}$ 和 $\\mathbf{R}_{\\mathrm{G}}$ 之间进行有意义的比较，我们必须强制执行一个一致的符号约定。\n\n问题指定了一种规范表示，其中 $\\mathbf{R}$ 的所有对角元素都是非负的。对于每个 $k \\in \\{1, \\dots, \\min(m,n)\\}$，如果 $\\mathbf{R}_{kk}  0$，我们就将 $\\mathbf{R}$ 的第 $k$ 行和 $\\mathbf{Q}$ 的第 $k$ 列乘以 $-1$。这对应于设置 $\\mathbf{D}_{kk} = \\mathrm{sgn}(\\mathbf{R}_{kk})$（其中 $\\mathrm{sgn}(0)$ 定义为 $1$）。此操作保持了等式 $\\mathbf{A}=\\mathbf{Q}\\mathbf{R}$ 和 $\\mathbf{Q}$ 的正交性。\n\n### 4. 验证与交叉检验\n\n为了验证所实现算法的正确性和精度，我们对每个输入矩阵 $\\mathbf{A}$ 执行四类检查，使用一个动态缩放的容差 $\\tau = \\|\\mathbf{A}\\|_F \\times \\epsilon$，其中 $\\epsilon$ 是一个类似 $10^{-12}$ 的小因子。\n\n1.  **上梯形结构**：$\\mathbf{R}$ 的严格下三角部分的Frobenius范数必须接近于零。我们检查 $\\|\\mathrm{tril}(\\mathbf{R}, -1)\\|_F \\le \\tau$。\n2.  **Q的正交性**：矩阵 $\\mathbf{Q}$ 必须是正交的。我们通过检查其与正交性的偏差是否很小来验证这一点：$\\|\\mathbf{Q}^{\\top}\\mathbf{Q} - \\mathbf{I}_m\\|_F \\le \\tau$。\n3.  **重构精度**：乘积 $\\mathbf{Q}\\mathbf{R}$ 必须能重构原始矩阵 $\\mathbf{A}$。我们检查重构误差：$\\|\\mathbf{A} - \\mathbf{Q}\\mathbf{R}\\|_F \\le \\tau$。\n4.  **对齐后的三角因子比较**：在对 $(\\mathbf{Q}_{\\mathrm{H}}, \\mathbf{R}_{\\mathrm{H}})$ 和 $(\\mathbf{Q}_{\\mathrm{G}}, \\mathbf{R}_{\\mathrm{G}})$ 应用符号对齐约定以获得 $(\\mathbf{Q}_{\\mathrm{H}}', \\mathbf{R}_{\\mathrm{H}}')$ 和 $(\\mathbf{Q}_{\\mathrm{G}}', \\mathbf{R}_{\\mathrm{G}}')$ 之后，所得的三角因子应该（在容差范围内）相同。我们检查 $\\|\\mathbf{R}_{\\mathrm{H}}' - \\mathbf{R}_{\\mathrm{G}}'\\|_F \\le \\tau$。\n\n一个测试用例被视为成功，当且仅当所有这些检查对于基于Householder和基于Givens的两种分解都通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef qr_householder(A):\n    \"\"\"\n    Computes QR factorization of a matrix A using Householder reflectors.\n    Returns Q, R where A = QR, Q is orthogonal, and R is upper-trapezoidal.\n    \"\"\"\n    m, n = A.shape\n    R = A.copy().astype(float)\n    Q = np.identity(m, dtype=float)\n\n    for k in range(min(m - 1, n)):\n        # Extract the k-th column vector from the k-th row\n        x = R[k:, k]\n        # Skip if the sub-column is already zero\n        x_norm = np.linalg.norm(x)\n        if np.isclose(x_norm, 0.0):\n            continue\n\n        # Compute the Householder vector v\n        v = x.copy()\n        # Use copysign for robustness to avoid cancellation\n        v[0] += np.copysign(x_norm, x[0])\n        \n        v_norm = np.linalg.norm(v)\n        if np.isclose(v_norm, 0.0):\n            continue\n\n        v = v / v_norm  # Normalize v to get u\n        # Efficiently v is prepared for beta computation\n        # beta = 2.0\n        # H = I - beta * u * u.T\n        \n        # Apply the reflector to the submatrix of R\n        # R_sub = R_sub - beta * u * (u.T @ R_sub)\n        R_sub = R[k:, k:]\n        R[k:, k:] -= 2.0 * np.outer(v, v.T @ R_sub)\n\n        # Apply the reflector to the submatrix of Q\n        # Q_sub = Q_sub @ H = Q_sub @ (I - beta * u * u.T) = Q_sub - beta * (Q_sub @ u) * u.T\n        Q_sub = Q[:, k:]\n        Q[:, k:] -= 2.0 * np.outer(Q_sub @ v, v)\n\n    return Q, R\n\n\ndef qr_givens(A):\n    \"\"\"\n    Computes QR factorization of a matrix A using Givens rotations.\n    Returns Q, R where A = QR, Q is orthogonal, and R is upper-trapezoidal.\n    \"\"\"\n    m, n = A.shape\n    R = A.copy().astype(float)\n    Q = np.identity(m, dtype=float)\n\n    for j in range(n):\n        for i in range(j + 1, m):\n            # Element to be zeroed out is R[i, j]\n            a = R[j, j]\n            b = R[i, j]\n\n            if np.isclose(b, 0.0):\n                continue\n            \n            # Compute c and s for the Givens rotation\n            r = np.hypot(a, b)\n            c = a / r\n            s = b / r\n\n            # Rotation matrix for rows: [[c, s], [-s, c]]\n            # Apply G.T to R (affecting rows j and i)\n            R_j_row = R[j, j:].copy()\n            R_i_row = R[i, j:].copy()\n            R[j, j:] = c * R_j_row + s * R_i_row\n            R[i, j:] = -s * R_j_row + c * R_i_row\n\n            # Apply G to Q (affecting columns j and i)\n            # Rotation matrix for columns: [[c, -s], [s, c]]\n            Q_j_col = Q[:, j].copy()\n            Q_i_col = Q[:, i].copy()\n            Q[:, j] = c * Q_j_col + s * Q_i_col\n            Q[:, i] = -s * Q_j_col + c * Q_i_col\n            \n    return Q, R\n\n\ndef align_signs(Q, R):\n    \"\"\"\n    Enforces a sign convention on QR factorization.\n    The convention is that the diagonal elements of R must be non-negative.\n    \"\"\"\n    m, n = R.shape\n    Q_aligned = Q.copy()\n    R_aligned = R.copy()\n\n    for k in range(min(m, n)):\n        if R_aligned[k, k]  0:\n            R_aligned[k, :] *= -1\n            Q_aligned[:, k] *= -1\n    \n    return Q_aligned, R_aligned\n\n\ndef run_checks_for_matrix(A):\n    \"\"\"\n    Performs all computations and cross-checks for a single matrix A.\n    Returns True if all checks pass, False otherwise.\n    \"\"\"\n    m, n = A.shape\n    \n    # Use a relative tolerance, with a small absolute floor\n    norm_A = np.linalg.norm(A, 'fro')\n    if np.isclose(norm_A, 0.0):\n        tol = 1e-10\n    else:\n        tol = norm_A * 1e-12\n\n    # 1. Compute QR factorizations\n    Q_H, R_H = qr_householder(A)\n    Q_G, R_G = qr_givens(A)\n\n    # 2. Perform cross-checks\n    checks = []\n\n    # Check 1: Upper-trapezoidal structure\n    checks.append(np.linalg.norm(np.tril(R_H, -1), 'fro') = tol)\n    checks.append(np.linalg.norm(np.tril(R_G, -1), 'fro') = tol)\n\n    # Check 2: Orthogonality of Q\n    I_m = np.identity(m)\n    checks.append(np.linalg.norm(Q_H.T @ Q_H - I_m, 'fro') = tol)\n    checks.append(np.linalg.norm(Q_G.T @ Q_G - I_m, 'fro') = tol)\n\n    # Check 3: Reconstruction accuracy\n    checks.append(np.linalg.norm(A - Q_H @ R_H, 'fro') = tol)\n    checks.append(np.linalg.norm(A - Q_G @ R_G, 'fro') = tol)\n\n    # Check 4: Aligned triangular comparison\n    Q_H_a, R_H_a = align_signs(Q_H, R_H)\n    Q_G_a, R_G_a = align_signs(Q_G, R_G)\n\n    # Sanity check: ensure alignment preserved factorization\n    checks.append(np.linalg.norm(A - Q_H_a @ R_H_a, 'fro') = tol)\n    checks.append(np.linalg.norm(A - Q_G_a @ R_G_a, 'fro') = tol)\n    \n    # Main comparison of aligned R factors\n    checks.append(np.linalg.norm(R_H_a - R_G_a, 'fro') = tol)\n\n    return all(checks)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the process for the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (tall, full column rank)\n        np.array([\n            [3, -2, 5],\n            [7, 1, -1],\n            [2, 4, 0],\n            [-3, 5, 2],\n            [1, -6, 3]\n        ]),\n        # Test case 2 (square, full rank)\n        np.array([\n            [4, 2, -2],\n            [1, 3, 0],\n            [0, -1, 5]\n        ]),\n        # Test case 3 (square, rank deficient)\n        np.array([\n            [1, 0, 1, 2],\n            [0, 1, 2, -1],\n            [2, -3, -4, 1],\n            [-1, 4, 7, 0]\n        ]),\n        # Test case 4 (wide, full row rank)\n        np.array([\n            [1, 0, 2, -1, 3],\n            [0, -2, 1, 4, -1],\n            [3, 5, -2, 0, 1]\n        ]),\n    ]\n    \n    results = []\n    for A in test_cases:\n        result = run_checks_for_matrix(A)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}