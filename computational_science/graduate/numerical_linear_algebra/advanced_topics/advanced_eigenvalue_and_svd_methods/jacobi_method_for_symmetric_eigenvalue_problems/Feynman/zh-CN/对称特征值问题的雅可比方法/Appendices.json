{
    "hands_on_practices": [
        {
            "introduction": "整个雅可比方法构建在一个简单而重复的核心操作之上：通过一次平面旋转来消去一个非对角元素。本练习旨在让你专注于高效地实现这关键的一步，其计算复杂度为 $O(n)$，这对整个算法的性能至关重要。掌握这一基本构建模块是理解和实现完整雅可比迭代的基础。",
            "id": "3552566",
            "problem": "给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和两个不同的索引 $(p,q)$，其中 $0 \\leq p  q \\leq n-1$。考虑一次雅可比旋转，该旋转通过正交相似变换来消除非对角线元素 $a_{pq}$。您的任务是实现雅可比方法的单步操作，计算更新后的矩阵 $A' \\in \\mathbb{R}^{n \\times n}$，对应于 $A' \\leftarrow G^\\top A G$，其中 $G \\in \\mathbb{R}^{n \\times n}$ 是一个仅作用于 $(p,q)$ 平面的正交旋转，并被选择用来消除 $a_{pq}$。实现必须避免构造完整的乘积 $G^\\top A G$，并且必须通过对受影响的行和列重用临时变量，以 $O(n)$ 的时间复杂度更新 $A$。\n\n待使用的基本原理：\n- 一个实对称矩阵 $A$ 具有实特征值，并且可以被正交对角化。正交相似变换 $A' = Q^\\top A Q$ 保持对称性和特征值。\n- 雅可比旋转是一个正交矩阵 $G$，它除了在索引 $(p,q)$ 上作用的一个 $2 \\times 2$ 旋转子块外，其余部分与单位矩阵相同；通过恰当选择旋转参数，它可以消除单个非对角线元素 $a_{pq}$。\n\n定义与要求：\n- 令 $a_{ij}$ 表示 $A$ 的 $(i,j)$ 元素，令 $a'_{ij}$ 表示 $A'$ 的 $(i,j)$ 元素。\n- 必须以数值稳定的方式选择旋转参数以消除 $a_{pq}$。\n- 效率要求：仅更新由 $p$ 和 $q$ 索引的行和列，重用临时变量以避免不必要的内存操作。不要显式构造 $G$，也不要执行稠密矩阵-矩阵乘法。\n- 正确性要求：$A'$ 必须保持对称，并满足 $a'_{pq} \\approx 0$（在浮点（FP）舍入误差范围内）。\n\n对于每个测试用例，计算并报告以下三个量：\n1. 整数 $m$，等于满足 $|a'_{ij} - a_{ij}|  \\varepsilon$ 的元素 $(i,j)$ 的数量，其中 $\\varepsilon = 10^{-12}$。\n2. 浮点数 $r$，等于 $|a'_{pq}|$。\n3. 浮点数 $f$，等于弗罗贝尼乌斯范数 $\\|A' - A\\|_F$，其中 $\\|X\\|_F = \\sqrt{\\sum_{i,j} x_{ij}^2}$。\n\n角度单位：任何内部形成的旋转角度（如果形成）必须以弧度为单位；但是，要求的输出中不包含任何角度。\n\n测试套件：\n- 情况 1（边界情况，平凡消除）：$n=2$，\n$$\nA = \\begin{bmatrix}\n2.0  0.0 \\\\\n0.0  3.0\n\\end{bmatrix},\\quad (p,q) = (0,1).\n$$\n- 情况 2（一般情况，混合符号）：$n=5$，\n$$\nA = \\begin{bmatrix}\n4  1  2  0  0 \\\\\n1  3  -1  2  0 \\\\\n2  -1  5  0  1 \\\\\n0  2  0  4  -2 \\\\\n0  0  1  -2  3\n\\end{bmatrix},\\quad (p,q) = (1,2).\n$$\n- 情况 3（边缘情况，对角线元素相等）：$n=8$，\n$$\nA = \\begin{bmatrix}\n7  2  0  1  0  0  3  0 \\\\\n2  6  1  0  0  2  0  0 \\\\\n0  1  5  0  2  0  0  1 \\\\\n1  0  0  6  0  0  2  0 \\\\\n0  0  2  0  4  1  0  0 \\\\\n0  2  0  0  1  3  1  0 \\\\\n3  0  0  2  0  1  6  0 \\\\\n0  0  1  0  0  0  0  5\n\\end{bmatrix},\\quad (p,q) = (3,6).\n$$\n\n您的程序必须对每个测试用例应用一次雅可比旋转以生成更新后的矩阵 $A'$，为每个测试用例计算 $(m,r,f)$，并输出一行包含结果的字符串，其格式为逗号分隔的列表的列表，如下所示：\n$$\n\\text{[}[m_1,r_1,f_1],[m_2,r_2,f_2],[m_3,r_3,f_3]\\text{]}.\n$$\n所有数值输出必须为标准浮点格式（除常规十进制表示外，无科学记数法符号），并且没有物理单位。容差固定为 $\\varepsilon = 10^{-12}$。",
            "solution": "用户提供的问题是有效的。它在科学上是合理的、良置的、客观的，并包含了唯一解所需的所有必要信息。任务是为对称矩阵实现雅可比方法的单步高效操作。\n\n### 基于原理的设计\n\n问题的核心是对一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 应用一次正交相似变换 $A' = G^\\top A G$。变换矩阵 $G$ 是一个雅可比旋转（也称为吉文斯旋转），其设计目的是消除一个特定的非对角线元素 $a_{pq}$（以及其对称位置上的对应元素 $a_{qp}$）。\n\n**1. 雅可比旋转矩阵 ($G$)**\n\n矩阵 $G$ 是一个正交矩阵，它除了在索引 $(p,q)$（其中 $0 \\leq p  q \\leq n-1$）上作用的一个 $2 \\times 2$ 旋转子块外，其余部分与单位矩阵相同。其定义如下：\n$$\nG_{ij} =\n\\begin{cases}\n    c = \\cos(\\theta)  \\text{如果 } i=j=p \\text{ 或 } i=j=q \\\\\n    s = \\sin(\\theta)  \\text{如果 } (i,j) = (p,q) \\\\\n    -s = -\\sin(\\theta)  \\text{如果 } (i,j) = (q,p) \\\\\n    1  \\text{如果 } i=j \\text{ 且 } i \\notin \\{p,q\\} \\\\\n    0  \\text{其它情况}\n\\end{cases}\n$$\n选择 $\\theta$ 的值是为了使变换后矩阵 $A'$ 的元素 $a'_{pq}$ 等于零。正交性（$G^\\top G = I$）由属性 $c^2 + s^2 = 1$ 保证。\n\n**2. 旋转参数 ($c, s$) 的推导**\n\n该变换对 $A$ 在索引 $(p,q)$ 处的 $2 \\times 2$ 子矩阵的影响如下：\n$$\n\\begin{pmatrix} a'_{pp}  a'_{pq} \\\\ a'_{qp}  a'_{qq} \\end{pmatrix} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{qp}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n执行此矩阵乘法可得到新的非对角线元素 $a'_{pq}$ 的表达式：\n$$ a'_{pq} = (c^2 - s^2) a_{pq} + c s (a_{pp} - a_{qq}) $$\n为消除此元素（设置 $a'_{pq} = 0$），我们必须有：\n$$ (c^2 - s^2) a_{pq} = -c s (a_{pp} - a_{qq}) $$\n使用二倍角恒等式 $c^2-s^2 = \\cos(2\\theta)$ 和 $2cs = \\sin(2\\theta)$，我们发现：\n$$ \\cot(2\\theta) = \\frac{\\cos(2\\theta)}{\\sin(2\\theta)} = \\frac{a_{qq} - a_{pp}}{2 a_{pq}} $$\n令 $\\tau = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}$。为了在不显式求解 $\\theta$ 的情况下以数值稳定的方式计算 $c$ 和 $s$，我们首先求出 $t = \\tan(\\theta)$。关系式 $\\cot(2\\theta) = \\frac{1-t^2}{2t} = \\tau$ 导出一个二次方程 $t^2 + 2\\tau t - 1 = 0$。为了稳定性，选择绝对值较小的根，它对应于一个较小的旋转角 $|\\theta| \\leq \\pi/4$。该根由以下公式给出：\n$$ t = \\frac{\\text{sgn}(\\tau)}{|\\tau| + \\sqrt{\\tau^2 + 1}} $$\n一个特殊情况是当 $\\tau = 0$ 时（即 $a_{pp}=a_{qq}$），此时我们取 $t=1$（对应于 $\\theta = \\pi/4$ 的旋转）。如果 $a_{pq}=0$，则不需要旋转，因此我们设置 $\\theta=0$，这意味着 $t=0, c=1, s=0$。\n一旦 $t$ 已知，$c$ 和 $s$ 可通过以下方式求得：\n$$ c = \\frac{1}{\\sqrt{1+t^2}}, \\quad s = t c $$\n\n**3. 高效的 $O(n)$ 矩阵更新**\n\n变换 $A' = G^\\top A G$ 仅修改第 $p$ 行和第 $q$ 行以及第 $p$ 列和第 $q$ 列。涉及完整矩阵乘法的朴素实现将是 $O(n^3)$。通过推导变化元素的显式公式，可以实现高效的 $O(n)$ 更新。\n- 对于 $i,j \\notin \\{p,q\\}$，元素 $a_{ij}$ 保持不变：$a'_{ij} = a_{ij}$。\n- 对于受影响的行和列中的元素（但在 $2 \\times 2$ 块之外），对于 $i \\notin \\{p,q\\}$：\n  $$ a'_{pi} = a'_{ip} = c \\cdot a_{pi} - s \\cdot a_{qi} $$\n  $$ a'_{qi} = a'_{iq} = s \\cdot a_{pi} + c \\cdot a_{qi} $$\n  这需要 $O(n)$ 次运算。\n- 对于索引 $(p,q)$ 处的 $2 \\times 2$ 子矩阵，更新后的值为：\n  $$ a'_{pp} = c^2 a_{pp} - 2cs a_{pq} + s^2 a_{qq} $$\n  $$ a'_{qq} = s^2 a_{pp} + 2cs a_{pq} + c^2 a_{qq} $$\n  而 $a'_{pq} = a'_{qp}$ 根据构造为零。这些更新需要 $O(1)$ 次运算。\n\n**4. 算法实现与输出计算**\n\n算法流程如下：\n1. 对于给定的矩阵 $A$ 和索引 $(p,q)$，首先处理 $a_{pq}$ 已经为零的平凡情况。\n2. 如果 $a_{pq} \\neq 0$，计算 $\\tau$，然后使用稳定公式求出 $t, c, s$。\n3. 创建原始矩阵的副本 $A_{orig}$，以供后续比较。工作矩阵 $A$（或其副本 $A'$）将被更新。\n4. 从 $i=0$ 迭代到 $n-1$。对于每个 $i \\notin \\{p,q\\}$，使用上述公式更新元素 $a'_{pi}, a'_{ip}, a'_{qi}, a'_{iq}$。\n5. 更新 $2 \\times 2$ 子矩阵的四个元素 $a'_{pp}, a'_{qq}, a'_{pq}, a'_{qp}$。计算并存储 $a'_{pq}$ 的值以求得 $r$，然后可以在矩阵中将其精确设置为 $0.0$，以反映完美的消除效果。\n6. 然后计算所需的度量指标：\n   - $m$：满足 $|a'_{ij} - a_{ij}|  \\varepsilon$ 的元素 $(i,j)$ 的数量。这通过 $A'$ 和 $A_{orig}$ 之间的逐元素比较找到。\n   - $r$：从变换公式计算出的绝对值 $|a'_{pq}|$，它衡量了消除过程中的数值误差。\n   - $f$：差值的弗罗贝尼乌斯范数，$\\|A' - A_{orig}\\|_F = \\sqrt{\\sum_{i,j} (a'_{ij} - a_{ij})^2}$。\n\n此过程正确且高效地实现了一步雅可比旋转，并遵循所有指定的约束条件。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes one step of the Jacobi rotation for multiple test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[2.0, 0.0], [0.0, 3.0]], dtype=float),\n            \"p\": 0, \"q\": 1\n        },\n        {\n            \"A\": np.array([\n                [4.0, 1.0, 2.0, 0.0, 0.0],\n                [1.0, 3.0, -1.0, 2.0, 0.0],\n                [2.0, -1.0, 5.0, 0.0, 1.0],\n                [0.0, 2.0, 0.0, 4.0, -2.0],\n                [0.0, 0.0, 1.0, -2.0, 3.0]\n            ], dtype=float),\n            \"p\": 1, \"q\": 2\n        },\n        {\n            \"A\": np.array([\n                [7.0, 2.0, 0.0, 1.0, 0.0, 0.0, 3.0, 0.0],\n                [2.0, 6.0, 1.0, 0.0, 0.0, 2.0, 0.0, 0.0],\n                [0.0, 1.0, 5.0, 0.0, 2.0, 0.0, 0.0, 1.0],\n                [1.0, 0.0, 0.0, 6.0, 0.0, 0.0, 2.0, 0.0],\n                [0.0, 0.0, 2.0, 0.0, 4.0, 1.0, 0.0, 0.0],\n                [0.0, 2.0, 0.0, 0.0, 1.0, 3.0, 1.0, 0.0],\n                [3.0, 0.0, 0.0, 2.0, 0.0, 1.0, 6.0, 0.0],\n                [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 5.0]\n            ], dtype=float),\n            \"p\": 3, \"q\": 6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        results.append(jacobi_step(A, p, q))\n\n    # Format the final output string\n    result_strings = []\n    for res in results:\n        # Format list to string '[m,r,f]' without extra spaces\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef jacobi_step(A, p, q):\n    \"\"\"\n    Performs a single Jacobi rotation on matrix A to annihilate element (p,q).\n    \n    Args:\n        A (np.ndarray): The real symmetric matrix.\n        p (int): The first index (row/column).\n        q (int): The second index (row/column).\n\n    Returns:\n        list: A list containing [m, r, f].\n    \"\"\"\n    A_orig = A.copy()\n    A_prime = A.copy()\n    n = A.shape[0]\n\n    app = A_orig[p, p]\n    aqq = A_orig[q, q]\n    apq = A_orig[p, q]\n\n    # If the element is already zero, no rotation is necessary.\n    if np.isclose(apq, 0.0):\n        return [0, 0.0, 0.0]\n\n    # Calculate rotation parameters c and s\n    tau = (aqq - app) / (2.0 * apq)\n    if tau >= 0:\n        t = 1.0 / (tau + np.sqrt(1.0 + tau**2))\n    else:\n        t = -1.0 / (-tau + np.sqrt(1.0 + tau**2))\n    \n    c = 1.0 / np.sqrt(1.0 + t**2)\n    s = t * c\n\n    # Update the matrix A_prime in an O(n) fashion\n    # First, update elements in rows/cols p,q but not the 2x2 block\n    for i in range(n):\n        if i != p and i != q:\n            a_pi = A_orig[p, i]\n            a_qi = A_orig[q, i]\n            \n            val_pi_prime = c * a_pi - s * a_qi\n            val_qi_prime = s * a_pi + c * a_qi\n            \n            A_prime[p, i] = val_pi_prime\n            A_prime[i, p] = val_pi_prime\n            A_prime[q, i] = val_qi_prime\n            A_prime[i, q] = val_qi_prime\n\n    # Second, update the 2x2 submatrix\n    A_prime[p, p] = c**2 * app - 2 * c * s * apq + s**2 * aqq\n    A_prime[q, q] = s**2 * app + 2 * c * s * apq + c**2 * aqq\n    \n    apq_prime = (c**2 - s**2) * apq + c * s * (app - aqq)\n    A_prime[p, q] = apq_prime\n    A_prime[q, p] = apq_prime\n\n    # Compute the required metrics\n    eps = 1e-12\n    m = int(np.sum(np.abs(A_prime - A_orig) > eps))\n    r = float(np.abs(A_prime[p, q]))\n    f = float(np.linalg.norm(A_prime - A_orig, 'fro'))\n    \n    return [m, r, f]\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "掌握了核心的旋转操作后，我们现在可以将这些模块组装成一个完整的迭代算法。本练习要求你实现经典的雅可比方法，包括选择最大非对角元素的关键“主元”策略。你将运用你编写的程序来研究一个有趣的现象：随着算法收敛，对角线元素是否会趋向于按特定顺序排列的特征值。",
            "id": "2405313",
            "problem": "你将研究用于实对称矩阵特征值问题的经典 Jacobi 旋转法，在对角线元素收敛于特征值的过程中，是否表现出任何内在的“排序”行为。该研究必须通过从第一性原理出发实现此方法来完成，并根据非递减顺序的概念来验证最终对角线元素的排序。\n\n从以下基本原理开始：\n- 对于任意实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，存在一个正交矩阵 $V$，使得 $V^{\\mathsf{T}} A V$ 是对角矩阵。正交相似变换保持 $A$ 的对称性及其特征值多重集。\n- Jacobi 旋转是在一个二维坐标平面 $(p,q)$ 中的正交变换，可以选择它来将一个对称矩阵的 $(p,q)$ 和 $(q,p)$ 元素置零，同时保持对称性。\n\n任务：\n1. 推导在 $(p,q)$-平面中必要的平面旋转，通过正交相似变换 $G^{\\mathsf{T}}(p,q,\\theta) A G(p,q,\\theta)$ 将实对称矩阵 $A$ 的单个非对角线元素置零。其中 $G$ 是单位矩阵，但作用于索引 $(p,q)$ 的是一个 $2 \\times 2$ 的旋转块。角度必须以弧度表示。不要假定任何预先给定的旋转参数公式；从变换后的非对角线元素为零以及 $G$ 的正交性这两个条件来推导它们。\n2. 设计并实现一个经典的 Jacobi 算法，该算法重复应用此类旋转，以将非对角线元素的 Frobenius 范数降至一个容差以下。采用一种稳健的主元选择策略，在每一步选择绝对值最大的非对角线元素进行置零。当非对角线范数小于指定容差乘以当前矩阵的 Frobenius 范数，或达到一个合理的迭代次数上限时，算法终止。角度必须以弧度表示。\n3. 对于下面列出的每个测试矩阵，运行你的实现直至收敛，并报告最终的对角向量是否按非递减顺序排列。使用数值容差 $ \\varepsilon $ 定义非递减顺序，要求对于所有相邻对，均满足 $d_i \\le d_{i+1} + \\varepsilon$，其中 $d_i$ 表示最终矩阵的第 $i$ 个对角线元素。使用 $ \\varepsilon = 10^{-10} $。\n4. Jacobi 方法的数值容差应为绝对容差，定义为 $ \\tau = 10^{-12} \\|A\\|_F $，其中 $ \\|A\\|_F $ 是初始矩阵的 Frobenius 范数。角度必须以弧度表示。\n\n测试套件（每个矩阵都是对称的，数值无单位）：\n- 案例 $1$ (非平凡的 $2 \\times 2$ 矩阵)：$A_1 = \\begin{bmatrix} 2  1 \\\\ 1  0 \\end{bmatrix}$。\n- 案例 $2$ (已对角化，已排序)：$A_2 = \\mathrm{diag}(1,2,3)$。\n- 案例 $3$ (已对角化，未排序)：$A_3 = \\mathrm{diag}(3,1,2)$。\n- 案例 $4$ (已对角化，有重复特征值，已排序)：$A_4 = \\mathrm{diag}(1,1,2,2)$。\n- 案例 $5$ (已对角化，有重复特征值，未排序)：$A_5 = \\mathrm{diag}(2,2,1)$。\n\n对于每种情况，如果最终的对角线（在容差 $ \\varepsilon $ 内）是按非递减顺序排列的，你的程序必须输出整数 $1$，否则输出 $0$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表是针对上述测试用例按顺序排列的结果。例如，格式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k \\in \\{0,1\\}$。\n\n角度必须以弧度表示。矩阵或输出中不涉及任何物理单位。",
            "solution": "问题陈述经评估为**有效**。它在科学上基于数值线性代数的原理，特别是针对对称矩阵的 Jacobi 特征值算法。该问题是适定的，所有必要的数据、常数和边界条件都已明确提供。术语精确，目标客观且可验证。\n\n以下是按要求提供的完整推理和推导。\n\n### 1. Jacobi 旋转的推导\n\n设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称矩阵。Jacobi 方法旨在通过应用一系列正交相似变换来对角化 $A$。每次变换，即一次 Jacobi 旋转，都旨在将一个特定的非对角线元素置零。\n\n一次 Jacobi 旋转是一个正交变换 $A \\to A' = G^{\\mathsf{T}} A G$。矩阵 $G \\equiv G(p, q, \\theta)$ 是一个 Givens 旋转，它是一个单位矩阵，但在对应于索引 $p$ 和 $q$ 的位置有一个 $2 \\times 2$ 的子块（我们不失一般性地假设 $p  q$）。我们将此子块定义为：\n$$\n\\begin{pmatrix} g_{pp}  g_{pq} \\\\ g_{qp}  g_{qq} \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n这个矩阵对应于一个角度为 $\\theta$ 的旋转。矩阵 $G$ 是正交的，即 $G^{\\mathsf{T}}G = I$。\n\n变换 $A' = G^{\\mathsf{T}} A G$ 只影响 $A$ 的第 $p$ 行、第 $q$ 行、第 $p$ 列和第 $q$ 列。新矩阵 $A'$ 的元素与 $A$ 的元素关系如下。我们来分析由索引 $p$ 和 $q$ 定义的子矩阵的变换：\n$$\n\\begin{pmatrix} a'_{pp}  a'_{pq} \\\\ a'_{qp}  a'_{qq} \\end{pmatrix} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix}^{\\mathsf{T}} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{pq}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{pq}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix}\n$$\n新的非对角线元素 $a'_{pq}$ 计算如下：\n$$\na'_{pq} = (c a_{pp} + s a_{pq})(-s) + (c a_{pq} + s a_{qq})c = -cs a_{pp} - s^2 a_{pq} + c^2 a_{pq} + cs a_{qq}\n$$\n$$\na'_{pq} = (c^2 - s^2) a_{pq} + cs(a_{qq} - a_{pp})\n$$\n使用二倍角三角恒等式，上式变为：\n$$\na'_{pq} = \\cos(2\\theta) a_{pq} - \\frac{1}{2}\\sin(2\\theta) (a_{pp} - a_{qq})\n$$\n我们要求 $a'_{pq} = 0$，这导出了旋转角 $\\theta$ 所需满足的条件：\n$$\n\\cos(2\\theta) a_{pq} = \\frac{1}{2}\\sin(2\\theta) (a_{pp} - a_{qq})\n$$\n假定 $a_{pq} \\neq 0$ 且 $\\cos(2\\theta) \\neq 0$，我们可以写出：\n$$\n\\tan(2\\theta) = \\frac{2 a_{pq}}{a_{pp} - a_{qq}}\n$$\n如果 $a_{pp} = a_{qq}$，方程简化为 $a_{pq}\\cos(2\\theta) = 0$。对于 $a_{pq} \\neq 0$ 的情况，这要求 $\\cos(2\\theta) = 0$，所以 $2\\theta = \\pm \\pi/2$，即 $\\theta = \\pm \\pi/4$。\n\n为了数值稳定性，我们避免直接计算 $\\theta$。取而代之，我们从 $t = \\tan\\theta$ 计算 $c = \\cos\\theta$ 和 $s = \\sin\\theta$。令 $\\xi = \\frac{a_{pp} - a_{qq}}{2 a_{pq}}$。那么 $\\tan(2\\theta) = 1/\\xi$。恒等式 $\\tan(2\\theta) = \\frac{2t}{1-t^2}$ 导出了关于 $t$ 的二次方程：$t^2 + 2\\xi t - 1 = 0$。其根为 $t = -\\xi \\pm \\sqrt{\\xi^2 + 1}$。为了最小化旋转角，我们选择绝对值较小的根。这对应于 $|\\theta| \\le \\pi/4$ 和 $|t| \\le 1$。所需的根由以下数值稳定的公式给出：\n$$\nt = \\frac{\\mathrm{sgn}(\\xi)}{|\\xi| + \\sqrt{1 + \\xi^2}}\n$$\n其中我们定义 $\\mathrm{sgn}(0)=1$。\n从 $t$ 我们可以求得 $c$ 和 $s$：\n$$\nc = \\frac{1}{\\sqrt{1 + t^2}}, \\quad s = c \\cdot t\n$$\n必须使用这些值来更新矩阵。该 $2 \\times 2$ 子块的元素变为：\n$$\na'_{pp} = c^2 a_{pp} + s^2 a_{qq} + 2cs a_{pq}\n$$\n$$\na'_{qq} = s^2 a_{pp} + c^2 a_{qq} - 2cs a_{pq}\n$$\n可以验证迹是不变的：$a'_{pp} + a'_{qq} = a_{pp} + a_{qq}$。此外，可以推导出 $a'_{pp} - a'_{qq} = \\sqrt{(a_{pp}-a_{qq})^2 + 4a_{pq}^2}$，这意味着对于我们选择的旋转，有 $a'_{pp} \\geq a'_{qq}$。这表示子矩阵的两个特征值中较大的一个被放置在索引 $p$ 处，较小的被放置在索引 $q$ 处（因为按惯例 $p  q$）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements the Jacobi rotation method and checks the ordering of the resulting eigenvalues.\n    \"\"\"\n    \n    test_cases = [\n        np.array([[2.0, 1.0], [1.0, 0.0]]),\n        np.diag([1.0, 2.0, 3.0]),\n        np.diag([3.0, 1.0, 2.0]),\n        np.diag([1.0, 1.0, 2.0, 2.0]),\n        np.diag([2.0, 2.0, 1.0]),\n    ]\n    \n    results = []\n    \n    for A in test_cases:\n        final_diagonal = jacobi_eigen_solver(A)\n        is_sorted_flag = is_nondecreasing(final_diagonal)\n        results.append(is_sorted_flag)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef jacobi_eigen_solver(A, convergence_tol_factor=1e-12, max_iter=100):\n    \"\"\"\n    Computes the eigenvalues of a symmetric matrix A using the classical Jacobi method.\n\n    Args:\n        A (np.ndarray): The symmetric input matrix.\n        convergence_tol_factor (float): Factor for the convergence tolerance.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        np.ndarray: A vector containing the eigenvalues (the diagonal of the final matrix).\n    \"\"\"\n    A_k = np.copy(A).astype(np.float64)\n    n = A.shape[0]\n    if n == 1:\n        return np.diag(A_k)\n\n    initial_fro_norm = np.linalg.norm(A, 'fro')\n    if initial_fro_norm == 0:\n      return np.diag(A_k)\n    convergence_tol = convergence_tol_factor * initial_fro_norm\n\n    for _ in range(max_iter):\n        # Calculate the Frobenius norm of off-diagonal elements\n        off_diag_norm = np.sqrt(max(0, np.linalg.norm(A_k, 'fro')**2 - np.linalg.norm(np.diag(A_k))**2))\n\n        if off_diag_norm  convergence_tol:\n            break\n\n        # Find the off-diagonal element with the largest magnitude\n        # We only need to search the upper triangle\n        p, q = np.unravel_index(np.argmax(np.abs(np.triu(A_k, 1))), A_k.shape)\n\n        app, aqq, apq = A_k[p, p], A_k[q, q], A_k[p, q]\n\n        # Compute rotation parameters c and s\n        if apq == 0.0:\n            c, s = 1.0, 0.0\n        else:\n            xi = (app - aqq) / (2.0 * apq)\n            # Use sgn(0)=1 convention for the t formula\n            t_sign = np.sign(xi) if xi != 0 else 1.0\n            t = t_sign / (np.abs(xi) + np.sqrt(1.0 + xi**2))\n            \n            c = 1.0 / np.sqrt(1.0 + t**2)\n            s = c * t\n\n        # Store old values needed for updates\n        app_old, aqq_old = A_k[p, p], A_k[q, q]\n        apq_old = A_k[p, q]\n\n        # Update the 2x2 sub-block diagonal elements\n        A_k[p, p] = c**2 * app_old + s**2 * aqq_old + 2 * c * s * apq_old\n        A_k[q, q] = s**2 * app_old + c**2 * aqq_old - 2 * c * s * apq_old\n\n        # Update the rest of rows/columns p and q\n        for k in range(n):\n            if k != p and k != q:\n                apk_old = A_k[p, k]\n                aqk_old = A_k[q, k]\n                A_k[p, k] = c * apk_old + s * aqk_old\n                A_k[q, k] = -s * apk_old + c * aqk_old\n                # Maintain symmetry\n                A_k[k, p] = A_k[p, k]\n                A_k[k, q] = A_k[q, k]\n\n        # Annihilate the target off-diagonal element\n        A_k[p, q] = 0.0\n        A_k[q, p] = 0.0\n\n    return np.diag(A_k)\n\ndef is_nondecreasing(d, tol=1e-10):\n    \"\"\"\n    Checks if a vector d is in nondecreasing order within a given tolerance.\n    The condition is d_i = d_{i+1} + tol for all i.\n\n    Args:\n        d (np.ndarray): The vector to check.\n        tol (float): The numerical tolerance for comparison.\n\n    Returns:\n        int: 1 if the vector is in nondecreasing order, 0 otherwise.\n    \"\"\"\n    for i in range(len(d) - 1):\n        if d[i] > d[i+1] + tol:\n            return 0\n    return 1\n\nsolve()\n```"
        },
        {
            "introduction": "实现一个算法后，评估其输出结果的质量至关重要。本练习将重心从代码实现转移到理论分析，它要求你将一个实际的算法停止准则与计算出的特征值和特征向量的严格精度保证联系起来。通过运用矩阵扰动理论中的经典定理，你将深刻理解算法输出的数学意义及其可靠性。",
            "id": "3552523",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和经典的雅可比方法，该方法在经过 $k$ 轮扫描后，通过一系列平面旋转生成一个正交矩阵 $Q_{k}$，使得 $D_{k} = Q_{k}^{\\top} A Q_{k}$ 是近似对角的。定义弗罗贝尼乌斯范数 $\\|A\\|_{F} = \\sqrt{\\sum_{i,j} a_{ij}^{2}}$ 和非对角弗罗贝尼乌斯半范数 $\\operatorname{off}(A) = \\sqrt{\\sum_{i \\neq j} a_{ij}^{2}}$。设 $D = D_{k}$ 为终止时的矩阵，其对角元为 $d_{ii}$，并设 $q_{i}$ 表示 $Q_{k}$ 的第 $i$ 列。考虑停止准则\n$$\n\\operatorname{off}(D) \\le \\epsilon \\,\\|A\\|_{F},\n$$\n其中 $\\epsilon  0$ 是一个给定的容差。雅可比方法在终止时报告的近似特征对是 $(d_{ii}, q_{i})$，即在 $D$ 坐标系下相对于标准基的瑞利-里兹对。\n\n仅使用正交相似、瑞利商、残差、弗罗贝尼乌斯范数的基本定义，以及关于埃尔米特（实对称）矩阵的成熟结论（包括 Hoffman–Wielandt 定理和 Davis–Kahan sin–$\\Theta$ 扰动界），选出所有作为上述停止准则的有效推论的陈述，并说明它们如何为特征值和计算出的特征向量提供相对精度保证。\n\nA. 存在 $\\{1,\\dots,n\\}$ 的一个排列 $\\pi$ 使得\n$$\n\\sum_{i=1}^{n} \\bigl(\\lambda_{i}(A) - d_{\\pi(i)\\pi(i)}\\bigr)^{2} \\le \\operatorname{off}(D)^{2} \\le \\epsilon^{2}\\,\\|A\\|_{F}^{2},\n$$\n因此均方根特征值误差至多为 $\\epsilon\\,\\|A\\|_{F}$。此外，对于每个 $i$，设 $u_{i}$ 为与 $\\lambda_{i}(A)$ 相关联的 $A$ 的单位特征向量，并设 $q_{\\pi(i)}$ 为其匹配的计算向量，则有\n$$\n\\sin \\angle(u_{i}, q_{\\pi(i)}) \\le \\frac{\\|D - \\operatorname{diag}(d_{11},\\dots,d_{nn})\\|_{2}}{\\min_{j \\neq i} |\\lambda_{i}(A) - \\lambda_{j}(A)|} \\le \\frac{\\epsilon\\,\\|A\\|_{F}}{\\operatorname{sep}_{i}},\n$$\n其中 $\\operatorname{sep}_{i} = \\min_{j \\neq i} |\\lambda_{i}(A) - \\lambda_{j}(A)|$。\n\nB. 对于每个 $i$，都有 $|\\lambda_{i}(A) - d_{ii}| \\le \\epsilon\\,\\|A\\|_{F}$ 且 $\\|A q_{i} - d_{ii} q_{i}\\|_{2} = 0$，因此计算出的向量 $q_{i}$ 是 $A$ 的精确特征向量。\n\nC. 对于所有满足 $\\lambda_{i}(A) \\neq 0$ 的指标 $i$，相对特征值误差满足\n$$\n\\frac{|\\lambda_{i}(A) - d_{ii}|}{|\\lambda_{i}(A)|} \\le \\epsilon.\n$$\n\nD. 记 $R = D - \\operatorname{diag}(d_{11},\\dots,d_{nn})$（$D$ 的严格非对角部分），则有 $\\|R\\|_{2} \\le \\|R\\|_{F} = \\operatorname{off}(D) \\le \\epsilon\\,\\|A\\|_{F}$。因此，对于与谱的其余部分由一个间隙 $g  0$ 分隔开的 $A$ 的任何孤立特征值簇，计算出的不变子空间与真实不变子空间之间的主角 $\\Theta$ 服从\n$$\n\\sin \\Theta \\le \\frac{\\|R\\|_{2}}{g} \\le \\frac{\\epsilon\\,\\|A\\|_{F}}{g}.\n$$\n\nE. 因为雅可比方法具有二次收敛性，所以停止准则意味着\n$$\n\\max_{i} |\\lambda_{i}(A) - d_{ii}| \\le \\epsilon^{2}\\,\\|A\\|_{F}.\n$$\n\n选择所有正确的选项。",
            "solution": "用户希望我验证并解决一个关于雅可比特征值方法精度的问题。\n\n### 步骤1：提取已知条件\n-   $A$ 是一个实对称矩阵，$A \\in \\mathbb{R}^{n \\times n}$。\n-   经典雅可比方法在经过 $k$ 轮扫描后生成一个正交矩阵 $Q_k$。\n-   $D_k = Q_k^\\top A Q_k$ 是一个近似对角矩阵。\n-   弗罗贝尼乌斯范数定义为 $\\|A\\|_{F} = \\sqrt{\\sum_{i,j} a_{ij}^{2}}$。\n-   非对角弗罗贝尼乌斯半范数定义为 $\\operatorname{off}(A) = \\sqrt{\\sum_{i \\neq j} a_{ij}^{2}}$。\n-   终止时，我们有 $D = D_k$，其对角元为 $d_{ii}$。\n-   $Q_k$ 的第 $i$ 列表示为 $q_i$。\n-   停止准则为 $\\operatorname{off}(D) \\le \\epsilon \\,\\|A\\|_{F}$，容差 $\\epsilon  0$。\n-   计算出的近似特征对是 $(d_{ii}, q_{i})$。\n-   分析应使用基本定义和成熟的结论，包括 Hoffman–Wielandt 定理和 Davis–Kahan sin–$\\Theta$ 扰动界。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、适定的和客观的。这是一个数值线性代数中的标准问题，分析由类雅可比方法计算出的特征分解的精度。设置很清晰：一个正交相似变换 $D = Q^T A Q$ 产生一个近似对角矩阵 $D$，其偏离对角形式的程度由停止准则限定。任务是推导这对特征值和特征向量精度的影响，这是矩阵扰动理论的经典应用。问题要求使用特定的、成熟的定理（Hoffman-Wielandt, Davis-Kahan），这些是进行此分析的正确工具。问题是完整的、一致的、可形式化的。未发现任何缺陷。\n\n### 步骤3：判断与行动\n问题是 **有效的**。我将继续进行求解推导和逐项分析。\n\n### 求解推导\n\n问题的核心在于关系式 $A = Q_k D_k Q_k^\\top$，其中 $Q_k$ 是正交的。为简单起见，令 $Q = Q_k$ 和 $D = D_k$。由于 $A$ 和 $D$ 正交相似，它们具有相同的特征值，我们记为 $\\lambda_1(A), \\dots, \\lambda_n(A)$。\n\n矩阵 $D$ 不是完全对角的。我们可以将其分解为对角部分和非对角部分：\n$$\nD = \\operatorname{diag}(d_{11}, d_{22}, \\dots, d_{nn}) + R\n$$\n其中 $\\operatorname{diag}(d_{11}, \\dots, d_{nn})$ 是一个包含 $D$ 的对角元的对角矩阵，而 $R$ 是一个对角线为零，其他位置为 $D$ 的非对角元的矩阵。\n\n停止准则为 $\\operatorname{off}(D) \\le \\epsilon \\|A\\|_F$。\n根据定义，非对角部分 $R$ 的弗罗贝尼乌斯范数是：\n$$\n\\|R\\|_F = \\sqrt{\\sum_{i \\neq j} d_{ij}^2} = \\operatorname{off}(D)\n$$\n因此，停止准则可以写成 $\\|R\\|_F \\le \\epsilon \\|A\\|_F$。\n\n计算出的特征对是 $(d_{ii}, q_i)$。这些是从 $Q$ 的列向量张成的子空间（即整个 $\\mathbb{R}^n$）中获得的瑞利-里兹对，并在标准基中表示。$A$ 在基 $\\{q_1, \\dots, q_n\\}$ 下的矩阵表示是 $D = Q^\\top A Q$。\n\n我们现在分析每个选项。\n\n### 逐项分析\n\n**A. 存在 $\\{1,\\dots,n\\}$ 的一个排列 $\\pi$ 使得 $\\sum_{i=1}^{n} \\bigl(\\lambda_{i}(A) - d_{\\pi(i)\\pi(i)}\\bigr)^{2} \\le \\operatorname{off}(D)^{2} \\le \\epsilon^{2}\\,\\|A\\|_{F}^{2}$，因此均方根特征值误差至多为 $\\epsilon\\,\\|A\\|_{F}$。此外，对于每个 $i$，设 $u_{i}$ 为与 $\\lambda_{i}(A)$ 相关联的 $A$ 的单位特征向量，并设 $q_{\\pi(i)}$ 为其匹配的计算向量，则有 $\\sin \\angle(u_{i}, q_{\\pi(i)}) \\le \\frac{\\|D - \\operatorname{diag}(d_{11},\\dots,d_{nn})\\|_{2}}{\\min_{j \\neq i} |\\lambda_{i}(A) - \\lambda_{j}(A)|} \\le \\frac{\\epsilon\\,\\|A\\|_{F}}{\\operatorname{sep}_{i}}$，其中 $\\operatorname{sep}_{i} = \\min_{j \\neq i} |\\lambda_{i}(A) - \\lambda_{j}(A)|$。**\n\n该陈述包含两部分：一个特征值误差界和一个特征向量误差界。\n\n1.  **特征值误差**：针对对称矩阵的 Hoffman-Wielandt 定理指出，对于任意两个对称矩阵 $M_1$ 和 $M_2$，它们的特征值 $\\lambda_i(M_1)$ 和 $\\lambda_i(M_2)$ 可以被排序，使得 $\\sum_{i=1}^n (\\lambda_i(M_1) - \\lambda_i(M_2))^2 \\le \\|M_1 - M_2\\|_F^2$。\n    我们将此定理应用于矩阵 $D$ 和 $\\operatorname{diag}(D) = \\operatorname{diag}(d_{11}, \\dots, d_{nn})$。\n    $D$ 的特征值是 $A$ 的特征值，即 $\\{\\lambda_1(A), \\dots, \\lambda_n(A)\\}$。$\\operatorname{diag}(D)$ 的特征值是其对角元 $\\{d_{11}, \\dots, d_{nn}\\}$。\n    应用该定理，令 $M_1=D$ 和 $M_2=\\operatorname{diag}(D)$，则存在 $\\{1, \\dots, n\\}$ 的一个排列 $\\pi$，使得：\n    $$\n    \\sum_{i=1}^n (\\lambda_i(A) - d_{\\pi(i)\\pi(i)})^2 \\le \\|D - \\operatorname{diag}(D)\\|_F^2\n    $$\n    矩阵 $D - \\operatorname{diag}(D)$ 是非对角部分 $R$。其弗罗贝尼乌斯范数的平方是 $\\|R\\|_F^2 = (\\operatorname{off}(D))^2$。\n    因此，$\\sum_{i=1}^n (\\lambda_i(A) - d_{\\pi(i)\\pi(i)})^2 \\le \\operatorname{off}(D)^2$。使用停止准则 $\\operatorname{off}(D) \\le \\epsilon \\|A\\|_F$，我们得到 $\\operatorname{off}(D)^2 \\le \\epsilon^2 \\|A\\|_F^2$。\n    将这些结合起来，我们得到了陈述的第一部分：$\\sum_{i=1}^n (\\lambda_i(A) - d_{\\pi(i)\\pi(i)})^2 \\le \\operatorname{off}(D)^2 \\le \\epsilon^2 \\|A\\|_F^2$。该选项的第一部分是正确的。关于均方根误差的措辞是平方和界至多为 $(\\epsilon \\|A\\|_F)^2$ 的一个推论。\n\n2.  **特征向量误差**：这部分引用了 Davis-Kahan $\\sin\\Theta$ 定理的一种形式。让我们分析扰动 $D = \\operatorname{diag}(D) + R$。$\\operatorname{diag}(D)$ 的特征向量是标准基向量 $e_i$。$D$ 的特征向量是某些向量 $u'_i$。由于 $A = QDQ^\\top$，$A$ 的特征向量是 $u_i = Qu'_i$，而近似特征向量是 $q_i = Qe_i$。因为 $Q$ 是正交的，它保持角度不变：$\\angle(u_i, q_{\\pi(i)}) = \\angle(Qu'_{\\pi(i)}, Qe_{\\pi(i)}) = \\angle(u'_{\\pi(i)}, e_{\\pi(i)})$。\n    应用于 $D = \\operatorname{diag}(D) + R$ 的 Davis-Kahan 定理提供了 $D$ 的特征向量 $u'_{\\pi(i)}$ 与 $\\operatorname{diag}(D)$ 的特征向量 $e_{\\pi(i)}$ 之间夹角的界。对于一个孤立的特征值 $\\lambda_i(A)$，该定理的一个标准版本是：\n    $$\n    \\sin \\angle(u'_{\\pi(i)}, e_{\\pi(i)}) \\le \\frac{\\|R\\|_2}{\\min_{j \\neq i} |\\lambda_i(A) - d_{\\pi(j)\\pi(j)}|}\n    $$\n    一个稍微简单但同样标准的界版本在分母中使用真实特征值之间的间隙：\n    $$\n    \\sin \\angle(u_i, q_{\\pi(i)}) = \\sin \\angle(u'_{\\pi(i)}, e_{\\pi(i)}) \\le \\frac{\\|R\\|_2}{\\min_{j \\neq i}|\\lambda_i(A)-\\lambda_j(A)|} = \\frac{\\|R\\|_2}{\\operatorname{sep}_i}\n    $$\n    该陈述使用了 $\\|D - \\operatorname{diag}(d_{11}, \\dots, d_{nn})\\|_2 = \\|R\\|_2$，这是正确的。\n    对于最后一个不等式，我们使用标准的范数不等式 $\\|R\\|_2 \\le \\|R\\|_F$ 和停止准则 $\\|R\\|_F = \\operatorname{off}(D) \\le \\epsilon\\|A\\|_F$。这得出 $\\|R\\|_2 \\le \\epsilon\\|A\\|_F$。\n    将此代入界中得到 $\\frac{\\|R\\|_2}{\\operatorname{sep}_i} \\le \\frac{\\epsilon\\|A\\|_F}{\\operatorname{sep}_i}$。因此，第二部分陈述的每一部分都是标准扰动理论的有效推论。\n\n结论：**正确**。\n\n**B. 对于每个 $i$，都有 $|\\lambda_{i}(A) - d_{ii}| \\le \\epsilon\\,\\|A\\|_{F}$ 且 $\\|A q_{i} - d_{ii} q_{i}\\|_{2} = 0$，因此计算出的向量 $q_{i}$ 是 $A$ 的精确特征向量。**\n\n1.  **特征值误差**：从选项 A 中，我们保证了*在经过合适的排列 $\\pi$ 之后*，有 $|\\lambda_i(A) - d_{\\pi(i)\\pi(i)}| \\le \\operatorname{off}(D) \\le \\epsilon\\|A\\|_F$。然而，雅可比方法不保证对角元 $d_{ii}$ 会与排序后的特征值 $\\lambda_i(A)$ 一一对应。例如，$d_{11}$ 可能是对 $\\lambda_5(A)$ 的最佳近似。该陈述假设 $\\pi$是单位排列，但这通常不成立。因此，对于*每个* $i$ 且没有排列的说法是错误的。\n\n2.  **残差范数**：该陈述声称 $\\|A q_{i} - d_{ii} q_{i}\\|_{2} = 0$。这意味着 $(d_{ii}, q_i)$ 是 $A$ 的一个精确特征对。我们来计算残差范数。$r_i = A q_i - d_{ii} q_i$。由于 $A = QDQ^\\top$ 且 $Q$ 是正交的，$Q^\\top q_i = e_i$（第 $i$ 个标准基向量）。\n    $$\n    \\|r_i\\|_2 = \\|Q D Q^\\top q_i - d_{ii} q_i\\|_2 = \\|Q(D Q^\\top q_i - d_{ii} Q^\\top q_i)\\|_2 = \\|D e_i - d_{ii} e_i\\|_2\n    $$\n    向量 $De_i$ 是 $D$ 的第 $i$ 列。所以，$De_i - d_{ii} e_i$ 是 $D$ 的第 $i$ 列，但其对角元被设为零。这是矩阵 $R$ 的第 $i$ 列。其范数的平方是：\n    $$\n    \\|r_i\\|_2^2 = \\|De_i - d_{ii} e_i\\|_2^2 = \\sum_{j=1, j \\neq i}^{n} |d_{ji}|^2\n    $$\n    这个值仅当 $D$ 的第 $i$ 列所有非对角元都为零时才为零。对于一般的 $\\epsilon  0$，停止准则 $\\operatorname{off}(D) \\le \\epsilon \\|A\\|_F$ 并不意味着 $\\operatorname{off}(D) = 0$。因此，残差通常不为零。声称 $q_i$ 是精确特征向量是错误的。\n\n结论：**不正确**。\n\n**C. 对于所有满足 $\\lambda_{i}(A) \\neq 0$ 的指标 $i$，相对特征值误差满足 $\\frac{|\\lambda_{i}(A) - d_{ii}|}{|\\lambda_{i}(A)|} \\le \\epsilon$。**\n\n该陈述声称一个统一的相对误差界。如选项 B 的分析所示，对于某个排列 $\\pi$，我们有一个形式为 $|\\lambda_i(A) - d_{\\pi(i)\\pi(i)}| \\le \\epsilon \\|A\\|_F$ 的绝对误差界。为了论证，我们假设排列是单位排列（$\\pi(i) = i$），这是对该选项最有利的情况。那么相对误差将是：\n$$\n\\frac{|\\lambda_i(A) - d_{ii}|}{|\\lambda_i(A)|} \\le \\frac{\\epsilon \\|A\\|_F}{|\\lambda_i(A)|}\n$$\n该陈述声称此值小于或等于 $\\epsilon$。这将要求 $\\|A\\|_F \\le |\\lambda_i(A)|$。这通常是错误的。矩阵的弗罗贝尼乌斯范数可能远大于其最小非零特征值的模。例如，考虑 $A = \\begin{pmatrix} 100  0 \\\\ 0  0.1 \\end{pmatrix}$。那么 $\\|A\\|_F = \\sqrt{100^2 + 0.1^2} \\approx 100$。对于 $\\lambda_2 = 0.1$，条件将是 $100 \\le 0.1$，这是错误的。停止准则是基于偏离对角形式的绝对度量，并导致特征值的绝对误差界，而不是这种形式的通用相对误差界。\n\n结论：**不正确**。\n\n**D. 记 $R = D - \\operatorname{diag}(d_{11},\\dots,d_{nn})$（$D$ 的严格非对角部分），则有 $\\|R\\|_{2} \\le \\|R\\|_{F} = \\operatorname{off}(D) \\le \\epsilon\\,\\|A\\|_{F}$。因此，对于与谱的其余部分由一个间隙 $g  0$ 分隔开的 $A$ 的任何孤立特征值簇，计算出的不变子空间与真实不变子空间之间的主角 $\\Theta$ 服从 $\\sin \\Theta \\le \\frac{\\|R\\|_{2}}{g} \\le \\frac{\\epsilon\\,\\|A\\|_{F}}{g}$。**\n\n1.  **范数不等式**：矩阵 $R$ 被定义为 $D$ 的非对角部分。根据定义，$\\|R\\|_F = \\operatorname{off}(D)$。不等式 $\\|R\\|_2 \\le \\|R\\|_F$ 是联系任何矩阵的谱范数和弗罗贝尼乌斯范数的标准性质。不等式 $\\operatorname{off}(D) \\le \\epsilon \\|A\\|_F$ 是给定的停止准则。因此，不等式链 $\\|R\\|_{2} \\le \\|R\\|_{F} = \\operatorname{off}(D) \\le \\epsilon\\,\\|A\\|_{F}$ 是完全正确的。\n\n2.  **子空间误差**：该陈述的第二部分涉及计算出的不变子空间的精度。这正是广义 Davis-Kahan $\\sin\\Theta$ 定理的领域。设 $A$ 的谱被划分为由一个间隙 $g  0$ 分隔开的两个集合。设 $U_1$ 是对应于谱的一部分的真实不变子空间的基，设 $Q_1$ 是计算出的子空间的基（$Q$ 的部分列向量）。该定理指出，这两个子空间之间的最大主角 $\\Theta$ 的正弦值受一个残差矩阵的范数除以间隙 $g$ 的限制。该定理的一个标准且强大的表述给出了界 $\\sin\\Theta \\le \\frac{\\|R_{21}\\|_2}{g}$，其中 $R_{21}$ 是残差的相应非对角块。一个更简单且广泛使用的版本以完整扰动的形式给出界：\n    $$\n    \\sin \\Theta \\le \\frac{\\|R\\|_2}{g}\n    $$\n    其中 $R$ 是将“未扰动”问题（特征向量为 $q_i$）与“扰动”问题（特征向量为 $A$ 的特征向量）分开的扰动。在我们的上下文中，这种扰动恰好由 $D$ 的非对角部分 $R$ 捕捉。该陈述是 Davis-Kahan 定理在不变子空间上的正确应用。最后的不等式 $\\frac{\\|R\\|_2}{g} \\le \\frac{\\epsilon \\|A\\|_F}{g}$ 直接源于陈述的第一部分。\n\n结论：**正确**。\n\n**E. 因为雅可比方法具有二次收敛性，所以停止准则意味着 $\\max_{i} |\\lambda_{i}(A) - d_{ii}| \\le \\epsilon^{2}\\,\\|A\\|_{F}$。**\n\n该陈述混淆了算法的收敛*速度*与终止时达到的*精度*。雅可比方法的二次收敛性意味着非对角范数从一轮扫描到下一轮呈二次方下降，即一旦 $\\operatorname{off}(D_k)$ 足够小，对于某个常数 $C$，就有 $\\operatorname{off}(D_{k+1}) \\approx C \\cdot (\\operatorname{off}(D_k))^2$。\n算法在第 $k$ 轮扫描时终止，条件是 $\\operatorname{off}(D_k) \\le \\epsilon \\|A\\|_F$。特征值的误差由终止时的非对角范数限定。如 Hoffman-Wielandt 定理（选项 A）所示，$\\sum (\\lambda_i - d_{\\pi(i)})^2 \\le \\operatorname{off}(D_k)^2$。这意味着最大绝对特征值误差的界为：\n$$\n\\max_i |\\lambda_i(A) - d_{\\pi(i)\\pi(i)}| \\le \\sqrt{\\sum (\\lambda_i(A) - d_{\\pi(i)\\pi(i)})^2} \\le \\operatorname{off}(D_k) \\le \\epsilon \\|A\\|_F\n$$\n误差与 $\\epsilon$ 成正比，而不是 $\\epsilon^2$。二次收敛性意味着该算法在减小误差方面非常高效，但最终误差仍然由停止准则中的容差 $\\epsilon$ 决定，而不是它的平方。\n\n结论：**不正确**。",
            "answer": "$$\\boxed{AD}$$"
        }
    ]
}