{
    "hands_on_practices": [
        {
            "introduction": "子空间迭代的理论收敛性通常用谱隙来描述，但我们如何具体地量化每次迭代中计算子空间与真实不变子空间之间的“距离”呢？主角度（principal angles）为此提供了严谨的几何度量。这个练习将通过一个具体的计算，让你亲手实践如何利用奇异值分解（SVD）来确定主角度，并计算收敛因子，从而直观地感受子空间是如何一步步逼近目标不变子空间的。",
            "id": "3582669",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$，它有一个与两个最大特征值相关联的 2 维不变子空间。设 $U \\in \\mathbb{R}^{4 \\times 2}$ 具有张成这个确切不变子空间的标准正交列，并设 $Q_k \\in \\mathbb{R}^{4 \\times 2}$ 是通过在 $Q_0$ 和 $Q_1$ 之间应用一次多项式滤波器的分块子空间迭代所产生的标准正交子空间迭代。$U$、$Q_0$ 和 $Q_1$ 的列在 $\\mathbb{R}^{4}$ 的标准基中由下式给出：\n$$\nU \\;=\\;\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n0  0\n\\end{pmatrix},\\qquad\nQ_0 \\;=\\;\n\\begin{pmatrix}\n\\frac{4}{5}  0 \\\\\n0  \\frac{12}{13} \\\\\n\\frac{3}{5}  0 \\\\\n0  \\frac{5}{13}\n\\end{pmatrix},\\qquad\nQ_1 \\;=\\;\n\\begin{pmatrix}\n\\frac{15}{17}  0 \\\\\n0  \\frac{35}{37} \\\\\n\\frac{8}{17}  0 \\\\\n0  \\frac{12}{37}\n\\end{pmatrix}.\n$$\n两个由具有标准正交列的矩阵的列所张成的子空间之间的主角是通过奇异值分解 (SVD) 定义的：如果 $Q, U \\in \\mathbb{R}^{n \\times r}$ 具有标准正交列，那么 $Q^{\\ast} U$ 的奇异值 $\\sigma_i$ 满足 $\\sigma_i = \\cos(\\theta_i)$，其中 $\\theta_i \\in [0,\\frac{\\pi}{2}]$ 是主角。假设所有角度都以弧度为单位。\n\n仅使用此定义和 SVD 的基本性质，完成以下操作：\n1. 对于 $k \\in \\{0,1\\}$，计算由 $Q_k$ 和 $U$ 的列张成的子空间之间的最大主角 $\\theta_{\\max}^{(k)}$。\n2. 定义子空间迭代收缩因子\n$$\n\\rho \\;=\\; \\frac{\\tan\\big(\\theta_{\\max}^{(1)}\\big)}{\\tan\\big(\\theta_{\\max}^{(0)}\\big)}.\n$$\n报告 $\\rho$ 的精确值，形式为一个简化表达式。不需要数值四舍五入。最终答案必须是单个实数值或单个无单位的闭式解析表达式。",
            "solution": "我们从两个子空间之间主角的核心定义开始。如果 $Q, U \\in \\mathbb{R}^{n \\times r}$ 具有标准正交列，那么 $Q^{\\ast} U \\in \\mathbb{R}^{r \\times r}$ 的奇异值 $\\sigma_i$ 等于 $\\cos(\\theta_i)$，其中 $\\theta_i \\in [0,\\frac{\\pi}{2}]$ 是 $\\mathrm{range}(Q)$ 和 $\\mathrm{range}(U)$ 之间的主角。最大主角对应于 $Q^{\\ast} U$ 的最小奇异值。\n\n我们将此应用于 $Q_0$ 和 $U$。计算 $Q_0^{\\ast} U$：\n$$\nQ_0^{\\ast} U \\;=\\;\n\\begin{pmatrix}\n\\frac{4}{5}  0  \\frac{3}{5}  0 \\\\\n0  \\frac{12}{13}  0  \\frac{5}{13}\n\\end{pmatrix}\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n0  0\n\\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix}\n\\frac{4}{5}  0 \\\\\n0  \\frac{12}{13}\n\\end{pmatrix}.\n$$\n该矩阵已经是对角矩阵，且对角元非负，所以其奇异值为\n$$\n\\sigma_1^{(0)} \\;=\\; \\max\\!\\left\\{\\frac{4}{5}, \\frac{12}{13}\\right\\} \\;=\\; \\frac{12}{13},\\qquad\n\\sigma_2^{(0)} \\;=\\; \\min\\!\\left\\{\\frac{4}{5}, \\frac{12}{13}\\right\\} \\;=\\; \\frac{4}{5}.\n$$\n因此，主角满足\n$$\n\\cos\\!\\big(\\theta_1^{(0)}\\big) \\;=\\; \\frac{12}{13},\\qquad\n\\cos\\!\\big(\\theta_2^{(0)}\\big) \\;=\\; \\frac{4}{5}.\n$$\n最大主角为 $\\theta_{\\max}^{(0)} = \\max\\{\\theta_1^{(0)}, \\theta_2^{(0)}\\}$。由于 $\\cos$ 在 $[0,\\frac{\\pi}{2}]$ 上是递减的，最大角对应于最小的余弦值，即 $\\frac{4}{5}$。因此\n$$\n\\theta_{\\max}^{(0)} \\;=\\; \\arccos\\!\\left(\\frac{4}{5}\\right).\n$$\n为了计算收缩因子，我们计算 $\\tan\\!\\big(\\theta_{\\max}^{(0)}\\big)$。利用勾股数，有 $\\sin\\!\\big(\\arccos(\\frac{4}{5})\\big) = \\frac{3}{5}$，因此\n$$\n\\tan\\!\\big(\\theta_{\\max}^{(0)}\\big) \\;=\\; \\frac{\\sin\\!\\big(\\theta_{\\max}^{(0)}\\big)}{\\cos\\!\\big(\\theta_{\\max}^{(0)}\\big)} \\;=\\; \\frac{\\frac{3}{5}}{\\frac{4}{5}} \\;=\\; \\frac{3}{4}.\n$$\n\n接下来，我们对 $Q_1$ 执行相同的步骤：\n$$\nQ_1^{\\ast} U \\;=\\;\n\\begin{pmatrix}\n\\frac{15}{17}  0  \\frac{8}{17}  0 \\\\\n0  \\frac{35}{37}  0  \\frac{12}{37}\n\\end{pmatrix}\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n0  0 \\\\\n0  0\n\\end{pmatrix}\n\\;=\\;\n\\begin{pmatrix}\n\\frac{15}{17}  0 \\\\\n0  \\frac{35}{37}\n\\end{pmatrix}.\n$$\n同样，这是对角矩阵，其奇异值为\n$$\n\\sigma_1^{(1)} \\;=\\; \\max\\!\\left\\{\\frac{15}{17}, \\frac{35}{37}\\right\\} \\;=\\; \\frac{35}{37},\\qquad\n\\sigma_2^{(1)} \\;=\\; \\min\\!\\left\\{\\frac{15}{17}, \\frac{35}{37}\\right\\} \\;=\\; \\frac{15}{17}.\n$$\n于是\n$$\n\\cos\\!\\big(\\theta_1^{(1)}\\big) \\;=\\; \\frac{35}{37},\\qquad\n\\cos\\!\\big(\\theta_2^{(1)}\\big) \\;=\\; \\frac{15}{17},\\qquad\n\\theta_{\\max}^{(1)} \\;=\\; \\arccos\\!\\left(\\frac{15}{17}\\right).\n$$\n我们计算 $\\tan\\!\\big(\\theta_{\\max}^{(1)}\\big)$。利用勾股数，有 $\\sin\\!\\big(\\arccos(\\frac{15}{17})\\big) = \\frac{8}{17}$，所以\n$$\n\\tan\\!\\big(\\theta_{\\max}^{(1)}\\big) \\;=\\; \\frac{\\frac{8}{17}}{\\frac{15}{17}} \\;=\\; \\frac{8}{15}.\n$$\n\n收缩因子定义为\n$$\n\\rho \\;=\\; \\frac{\\tan\\!\\big(\\theta_{\\max}^{(1)}\\big)}{\\tan\\big(\\theta_{\\max}^{(0)}\\big)} \\;=\\; \\frac{\\frac{8}{15}}{\\frac{3}{4}} \\;=\\; \\frac{8}{15} \\cdot \\frac{4}{3} \\;=\\; \\frac{32}{45}.\n$$\n\n解释：在针对多个特征值的子空间迭代中，到目标不变子空间的主角在迭代过程中会收缩，其速率渐近地由谱隙信息决定。计算出的值 $\\rho = \\frac{32}{45}$ 为前两次迭代之间最差（最大）主角的这种收缩提供了定量度量，表明了收敛性，因为 $\\rho \\in (0,1)$。",
            "answer": "$$\\boxed{\\frac{32}{45}}$$"
        },
        {
            "introduction": "在理论上，子空间迭代中的正交化步骤 $Q_{k+1} = \\mathrm{orth}(A Q_k)$ 可以通过任何正交化方法完成。然而，在有限精度计算中，不同方法的数值稳定性差异巨大，尤其当目标特征值聚集时，$A Q_k$ 的列向量会变得近乎线性相关。这个练习将引导你深入分析经典格拉姆-施密特（CGS）、修正格拉姆-施密特（MGS）和豪斯霍尔德QR（Householder QR）分解在子空间迭代中的表现，从而理解为什么选择数值稳健的正交化方法对算法的整体精度和收敛性至关重要。",
            "id": "3582668",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其特征值为 $\\lambda_1 \\ge \\lambda_2 \\ge \\cdots \\ge \\lambda_n$。假设目标是使用子空间迭代来近似与 $p$ 个最大特征值相关联的不变子空间。一次标准的迭代过程包括计算 $Y_{k+1} = A Q_k$，然后进行一个正交化步骤 $Y_{k+1} \\mapsto Q_{k+1}$，其中 $Q_{k+1}$ 的列构成了 $\\operatorname{range}(Y_{k+1})$ 的一个标准正交基。在精确算术中，经典格拉姆-施密特法、修正格拉姆-施密特法和豪斯霍尔德 $QR$ 分解会产生相同的子空间。然而，在单位舍入误差为 $u$ 的有限精度算术中，它们的稳定性性质有所不同。正交化方法的选择不仅影响 $Q_{k+1}$ 的精度（通过 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2$ 来衡量），也影响子空间迭代的整体收敛行为，特别是当目标特征值紧密聚集，导致 $Y_{k+1}$ 随着 $k$ 的增长而变得越来越病态时。\n\n仅使用正交投影的基本定义、单位舍入误差为 $u$ 的浮点算术模型，以及豪斯霍尔德变换作为正交映射的特性，请判断以下关于子空间迭代中正交化步骤在有限精度下稳定性的陈述哪些是正确的。选择所有适用的选项。\n\nA. 在有限精度下，对 $Y_{k+1}$ 进行单遍经典格拉姆-施密特法可能会得到一个 $Q_{k+1}$，其正交性损失与 $\\kappa_2(Y_{k+1})\\,u$ 成比例（或更差）。因此，当目标特征值聚集且 $Y_{k+1}$ 是病态的时，与豪斯霍尔德QR分解或带再正交化的修正格拉姆-施密特法相比，它是不安全的。\n\nB. 豪斯霍尔德QR分解产生的 $Q_{k+1}$ 满足 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2 = \\mathcal{O}(u)$，且这与 $Y_{k+1}$ 的条件数无关；其分块形式利用了三级基本线性代数子程序（BLAS），因此在子空间迭代中既更稳定，也通常更高效。\n\nC. 单遍修正格拉姆-施密特法总能达到 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2 = \\mathcal{O}(u)$，无论 $Y_{k+1}$ 的条件数如何，因此即使特征值紧密聚集，再正交化也是不必要的。\n\nD. 执行两次经典格拉姆-施密特法（即第二次再正交化过程）得到的 $Q_{k+1}$ 的正交性可与豪斯霍尔德QR分解相媲美（在常数因子乘以 $u$ 的范围内），但其内积和投影的计算成本大约是单遍的两倍。\n\nE. 在子空间迭代中，QR分解的列主元选择是强制性的；没有主元选择，该方法无法收敛到不变子空间，因为否则正交化步骤将无法移除已收敛方向上的分量。\n\n选择正确的选项。",
            "solution": "用户需要对在子空间迭代算法中用于求解特征值的不同正交化方法的稳定性进行详细分析，特别是在有限精度算术的背景下。\n\n问题的核心在于矩阵 $Y_{k+1} = A Q_k$ 的性质。在子空间迭代中，矩阵 $Q_k$ 的列是标准正交向量，它们张成所求不变子空间的一个近似。随着迭代次数 $k$ 的增加，子空间 $\\operatorname{range}(Q_k)$ 收敛到与 $A$ 的 $p$ 个最大特征值相关联的不变子空间。因此，$A$ 对 $Q_k$ 的作用使 $Y_{k+1}$ 的列更强烈地对齐到相应的特征向量上。如果某些目标特征值是聚集的（即，对于某个 $j \\le p$，有 $\\lambda_j \\approx \\lambda_{j+1}$），$Y_{k+1}$ 的相应列将变得近似线性相关。这使得矩阵 $Y_{k+1}$ 随着 $k$ 的增加而变得越来越病态，意味着其条件数 $\\kappa_2(Y_{k+1})$ 变得非常大。任务是对这个病态矩阵的列进行正交化。这个正交化步骤的稳定性对于算法的整体性能和精度至关重要。\n\n我们在此背景下分析所提到的三种方法的稳定性——经典格拉姆-施密特法（CGS）、修正格拉姆-施密特法（MGS）和豪斯霍尔德QR分解。正交性损失由量 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2$ 来衡量，其中 $Q_{k+1}$ 是计算得到的标准正交向量矩阵，$u$ 是浮点系统的单位舍入误差。\n\n### 选项A分析\n\n陈述：在有限精度下，对 $Y_{k+1}$ 进行单遍经典格拉姆-施密特法可能会得到一个 $Q_{k+1}$，其正交性损失与 $\\kappa_2(Y_{k+1})\\,u$ 成比例（或更差）。因此，当目标特征值聚集且 $Y_{k+1}$ 是病态的时，与豪斯霍尔德QR分解或带再正交化的修正格拉姆-施密特法相比，它是不安全的。\n\n这个陈述是正确的。数值线性代数中的一个标准结果（最初由 Björck 提出）是，对于由矩阵 $Y$ 通过经典格拉姆-施密特法计算出的矩阵 $Q$，其正交性损失有如下界：\n$$\n\\|I - Q^\\top Q\\|_2 \\le c \\cdot n \\cdot \\kappa_2(Y) u\n$$\n其中 $c$ 是一个不大的常数，$n$ 是列数。更悲观的分析甚至可以显示出对 $\\kappa_2(Y)^2$ 的依赖性。无论如何，正交性损失直接依赖于输入矩阵 $Y$ 的条件数。在具有聚集特征值的子空间迭代背景下，$Y_{k+1}$ 变得病态，因此 $\\kappa_2(Y_{k+1})$ 很大。这意味着 $\\kappa_2(Y_{k+1})u$ 可能远大于 $u$，导致 $Q_{k+1}$ 出现严重的正交性损失。这种行为使得单遍CGS在数值上不稳定，因此对于此应用是“不安全”的。相比之下，豪斯霍尔德QR分解可以达到机器精度（$\\mathcal{O}(u)$）的正交性，而带再正交化的MGS（或带再正交化的CGS）也能将正交性恢复到相似水平。因此，所做的比较是有效的。\n\n结论：**正确**。\n\n### 选项B分析\n\n陈述：豪斯霍尔德QR分解产生的 $Q_{k+1}$ 满足 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2 = \\mathcal{O}(u)$，且这与 $Y_{k+1}$ 的条件数无关；其分块形式利用了三级基本线性代数子程序（BLAS），因此在子空间迭代中既更稳定，也通常更高效。\n\n这个陈述是正确的。豪斯霍尔德QR分解通过应用一系列豪斯霍尔德反射变换来实现正交化，这些变换是初等正交矩阵。这些正交矩阵的乘积就是最终的 $Q$ 矩阵。由于正交变换是完美条件的且数值稳定，计算出的 $Q_{k+1}$ 中的累积误差很小。正交性损失有如下界：\n$$\n\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2 = \\mathcal{O}(u)\n$$\n这个界与条件数 $\\kappa_2(Y_{k+1})$ 无关。这使得豪斯霍尔德QR分解在保持正交性方面成为最稳健的方法。\n此外，豪斯霍尔德QR分解可以以分块方式实现（例如，使用WY表示法），这将反射变换的应用组合成矩阵-矩阵乘法。这些操作对应于三级BLAS，它们为具有内存层次结构的现代计算机体系结构进行了高度优化，相比于主导格拉姆-施密特方法的基于向量的操作（一级和二级BLAS），可以带来显著的性能提升。\n卓越的数值稳定性和更高效率的潜力相结合，使豪斯霍尔德QR分解成为一个非常有吸引力的选择。\n\n结论：**正确**。\n\n### 选项C分析\n\n陈述：单遍修正格拉姆-施密特法总能达到 $\\|I - Q_{k+1}^\\top Q_{k+1}\\|_2 = \\mathcal{O}(u)$，无论 $Y_{k+1}$ 的条件数如何，因此即使特征值紧密聚集，再正交化也是不必要的。\n\n这个陈述是错误的。虽然修正格拉姆-施密特法（MGS）在实践中比经典格拉姆-施密特法（CGS）稳定得多，但其正交性损失仍然依赖于输入矩阵的条件数。单遍MGS的标准界是：\n$$\n\\|I - Q^\\top Q\\|_2 \\approx \\mathcal{O}(\\kappa_2(Y)u)\n$$\n尽管常数因子通常比CGS的好得多，但对 $\\kappa_2(Y)$ 的依赖性依然存在。当 $Y_{k+1}$ 因特征值聚集而病态时，$\\kappa_2(Y_{k+1})$ 可能大到足以使 $\\kappa_2(Y_{k+1})u$ 不再是机器精度的数量级。例如，如果 $\\kappa_2(Y_{k+1}) \\approx 10^8$ 且 $u \\approx 10^{-16}$，那么正交性损失可能在 $10^{-8}$ 左右。这与真正的正交性有显著偏差。因此，如果需要高精度，在处理病态矩阵时，通常也建议对MGS进行再正交化。声称它“总能达到”$\\mathcal{O}(u)$的正交性并且再正交化是“不必要的”是错误的。\n\n结论：**错误**。\n\n### 选项D分析\n\n陈述：执行两次经典格拉姆-施密特法（即第二次再正交化过程）得到的 $Q_{k+1}$ 的正交性可与豪斯霍尔德QR分解相媲美（在常数因子乘以 $u$ 的范围内），但其内积和投影的计算成本大约是单遍的两倍。\n\n这个陈述是正确的。这是众所周知的格拉姆-施密特法的“两次就够”原则。设 $Q^{(1)}$ 是对 $Y$ 应用一次CGS的结果。其正交性损失为 $\\|I - (Q^{(1)})^\\top Q^{(1)}\\|_2 = \\mathcal{O}(\\kappa_2(Y)u)$。现在，对矩阵 $Q^{(1)}$（其条件比 $Y$ 好得多）再次运行CGS，产生最终矩阵 $Q^{(2)}$。仔细分析表明，$Q^{(2)}$ 的正交性损失为：\n$$\n\\|I - (Q^{(2)})^\\top Q^{(2)}\\|_2 = \\mathcal{O}(u)\n$$\n这个结论成立的前提是初始的正交性损失不太大（例如，$\\kappa_2(Y)u < 1$）。最终得到的正交性确实可以与豪斯霍尔德QR分解的结果相媲美。CGS的成本主要由内积和向量更新（投影）主导。执行该过程两次仅仅意味着将这系列操作执行两次，因此与单遍相比，计算成本大约增加了一倍。该陈述的两部分都是准确的。这种方法通常被称为CGS2。\n\n结论：**正确**。\n\n### 选项E分析\n\n陈述：在子空间迭代中，QR分解的列主元选择是强制性的；没有主元选择，该方法无法收敛到不变子空间，因为否则正交化步骤将无法移除已收敛方向上的分量。\n\n这个陈述是错误的。QR分解中的列主元选择，即计算 $YP = QR$（其中 $P$ 是一个置换矩阵），是一种处理秩亏矩阵的策略，通过确保 $Q$ 的初始列张成 $Y$ 的列空间中最主要的部分。然而，在子空间迭代中，目标是为子空间 $\\operatorname{range}(Y_{k+1})$ 找到*一个*标准正交基。在该子空间内选择的具体基不影响子空间本身。子空间迭代的收敛是由类似幂法的 $A$ 的应用来保证的，这确保了 $\\operatorname{range}(A^k Y_0)$ 收敛到所求的不变子空间。正交化步骤仅仅是在每一步 $k$ 为这个演化中的子空间提供一个数值稳定的表示。\n\n任何能成功为 $\\operatorname{range}(Y_{k+1})$ 生成标准正交基的方法都足够了。像豪斯霍尔德QR分解或带再正交化的CGS等稳健的方法可以在不需要重新排列列的情况下计算出这样的基。声称没有主元选择该方法就“无法收敛”是错误的。所提供的理由也是有缺陷的；正交化的功能不是“移除已收敛方向上的分量”，而是产生一个标准正交基。收敛是整个迭代过程 $Y_{k+1}=AQ_k$ 的一个涌现特性。主元选择是在特定情境下（如秩揭示QR分解）用于数值稳定性的工具，但它本身不是子空间迭代算法收敛的强制性组件。\n\n结论：**错误**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "当子空间迭代收敛到一个不变子空间后，我们如何继续寻找与其余特征值对应的其他不变子空间？缩减（deflation）技术是解决这个问题的关键。然而，不恰当的缩减方法会导致数值污染，产生已经收敛的特征值的“幽灵”副本。这个编程练习将指导你设计并实现一个量化实验，对比一个朴素的缩减策略和一个数值稳健的缩减策略，从而深刻理解为什么精确的正交投影对于消除幽灵瑞利兹值（ghost Ritz values）和确保后续计算的准确性是必不可少的。",
            "id": "3582676",
            "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，该矩阵具有与簇状特征值对应的不相交不变子空间。同时，考虑一个块子空间迭代法，该方法已收敛到 $k$ 个特征向量的子集。令已收敛的子空间由矩阵 $Q_{\\mathrm{lock}} \\in \\mathbb{R}^{n \\times k}$ 表示，其列是真实特征向量的数值计算近似值。目标是精确分离剩余的不变子空间，并消除因 $Q_{\\mathrm{lock}}$ 中的污染而在已收敛特征值附近数值上出现的“幽灵”里兹值。\n\n您必须从以下数值线性代数的基本原理出发：\n- 不变子空间的定义：如果 $A \\mathcal{S} \\subseteq \\mathcal{S}$，则子空间 $\\mathcal{S} \\subset \\mathbb{R}^n$ 在 $A$ 下是不变的。\n- 瑞利-里兹（Rayleigh–Ritz）方法：给定一个由标准正交列矩阵 $Q \\in \\mathbb{R}^{n \\times m}$ 的列张成的子空间，里兹值是 $Q^\\top A Q$ 的特征值，而 $\\mathbb{R}^n$ 中的里兹向量是 $Q z$，其中 $z$ 是 $Q^\\top A Q$ 的一个特征向量。\n- 对于由标准正交列 $Q \\in \\mathbb{R}^{n \\times k}$ 张成的子空间，其正交补空间上的正交投影算子是 $P = I - Q Q^\\top$。\n- 子空间迭代原理：在适当条件下，对一个子空间反复应用 $A$ 并进行再正交化，会使该子空间趋向于与极端特征值相关联的不变子空间。\n\n设计两种紧缩策略，用于在 $k$ 个特征向量收敛后继续计算：\n1. 一种朴素的紧缩方法，试图通过对非标准正交的 $Q_{\\mathrm{lock}}$ 进行单次投影来移除锁定的子空间。此方法易受数值污染影响，并可能产生幽灵里兹值。\n2. 一种稳健的紧缩方法，为 $Q_{\\mathrm{lock}}$ 的张成空间构造一个标准正交基 $\\widehat{Q}_{\\mathrm{lock}}$（例如，通过数值稳定的正交化方法），并使用正交投影算子 $P = I - \\widehat{Q}_{\\mathrm{lock}} \\widehat{Q}_{\\mathrm{lock}}^\\top$ 来形成和约束紧缩算子 $P A P$，并在每一步清除锁定的分量。\n\n定义幽灵里兹值为在紧缩阶段获得的、与已收敛特征值集合的距离在给定绝对容差 $\\delta$ 内的任何里兹值。形式上，如果 $\\{\\lambda_i\\}_{i=1}^k$ 是已收敛的特征值，那么当 $\\min_{i} |\\mu - \\lambda_i| \\le \\delta$ 时，紧缩阶段的里兹值 $\\mu$ 就是一个幽灵里兹值。\n\n完全在软件中实现以下可量化的实验：\n- 构建矩阵 $A$ 为 $A = Q \\,\\mathrm{diag}(d)\\, Q^\\top$，其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$d \\in \\mathbb{R}^n$ 是具有指定簇和重数的特征值列表；这确保了不变子空间和特征对是已知的。\n- 令 $Q_{\\mathrm{lock}}$ 为选定索引子集（“收敛子集”）的精确特征向量，然后通过添加一个小的稠密扰动 $\\epsilon R$ 对其进行数值污染，得到 $Q_{\\mathrm{lock}}^{\\mathrm{bad}} = Q_{\\mathrm{lock}} + \\epsilon R$，其中 $R \\in \\mathbb{R}^{n \\times k}$ 是随机的，且 $\\epsilon > 0$。\n- 对于朴素紧缩法，通过对 $Q_{\\mathrm{lock}}^{\\mathrm{bad}}$ 进行单次投影 $Y = X - Q_{\\mathrm{lock}}^{\\mathrm{bad}} (Q_{\\mathrm{lock}}^{\\mathrm{bad}})^\\top X$，然后对 $Y$ 进行正交化，得到一个试验子空间 $Q_{\\mathrm{trial}}$；接着计算 $Q_{\\mathrm{trial}}^\\top A Q_{\\mathrm{trial}}$ 的里兹值。\n- 对于稳健紧缩法，通过使用数值稳定的方法（例如，两遍正交化或奇异值分解）对 $Q_{\\mathrm{lock}}^{\\mathrm{bad}}$ 进行正交化来计算 $\\widehat{Q}_{\\mathrm{lock}}$，形成 $P = I - \\widehat{Q}_{\\mathrm{lock}} \\widehat{Q}_{\\mathrm{lock}}^\\top$，通过对 $P X$ 进行正交化并对 $\\widehat{Q}_{\\mathrm{lock}}$ 进行双重清洗来获得 $Q_{\\mathrm{trial}}$，然后计算 $Q_{\\mathrm{trial}}^\\top (P A P) Q_{\\mathrm{trial}}$ 的里兹值。\n\n幽灵里兹值检测的容差固定为 $\\delta = 10^{-3}$。\n\n提供一个包含三个具有科学意义的测试用例的测试套件，用以检验问题的不同方面：\n- 用例 1（理想情况）：$n = 80$，$k = 5$，特征值 $d$ 包括一个在 $1$ 处重数为 $5$ 的簇，一个在 $5$ 处重数为 $5$ 的簇，其余 $70$ 个特征值在 $[10, 20]$ 区间内均匀分布。污染水平 $\\epsilon = 5 \\times 10^{-2}$。试验子空间维度 $m = 8$。用于可复现性的随机种子为 $12345$。\n- 用例 2（无收敛子集的边界条件）：$n = 60$，$k = 0$，特征值 $d$ 在 $[1, 20]$ 区间内均匀分布。污染水平 $\\epsilon = 0$。试验子空间维度 $m = 6$。随机种子 $= 54321$。\n- 用例 3（多重特征值）：$n = 90$，$k = 3$，特征值 $d$ 包括一个在 $3$ 处重数为 $3$ 的簇，一个在 $4$ 处重数为 $3$ 的簇，其余 $84$ 个特征值在 $[6, 12]$ 区间内均匀分布。污染水平 $\\epsilon = 10^{-1}$。试验子空间维度 $m = 6$。随机种子 $= 31415$。\n\n对于每个用例，计算两个整数：\n- $g_{\\mathrm{naive}}$：朴素紧缩策略产生的幽灵里兹值的数量。\n- $g_{\\mathrm{robust}}$：稳健紧缩策略产生的幽灵里兹值的数量。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应于相应案例的布尔值：\n- 对于用例 1：如果 $g_{\\mathrm{robust}} < g_{\\mathrm{naive}}$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 对于用例 2：如果 $g_{\\mathrm{robust}} = g_{\\mathrm{naive}} = 0$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 对于用例 3：如果 $g_{\\mathrm{robust}} < g_{\\mathrm{naive}}$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n不涉及物理单位或角度单位。所有输出都是无单位的整数或布尔值。最终输出格式必须是类似 $[\\mathrm{True},\\mathrm{False},\\mathrm{True}]$ 的单行文本，不含任何附加文本。",
            "solution": "该问题要求设计并比较两种应用于实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的块子空间迭代法的紧缩策略。主要目标是展示一种数值稳健的紧缩策略如何能防止虚假“幽灵”里兹值的出现，当收敛（锁定）子空间的基不是完全标准正交时，朴素方法可能会导致这种情况。\n\n### 基本原理\n\n令 $A \\in \\mathbb{R}^{n \\times n}$ 为一个实对称矩阵。其谱分解为 $A = V \\Lambda V^\\top$，其中 $V$ 是一个正交矩阵，其列是 $A$ 的特征向量，$\\Lambda$ 是一个包含相应实特征值的对角矩阵。\n\n线性算子 $A$ 下的一个不变子空间 $\\mathcal{S} \\subseteq \\mathbb{R}^n$ 是指满足 $A\\mathcal{S} \\subseteq \\mathcal{S}$ 的子空间。对于对称矩阵 $A$，由其任意一组特征向量张成的子空间都是一个不变子空间。\n\n瑞利-里兹（Rayleigh-Ritz）方法用于从一个试验子空间 $\\mathcal{Q}$ 中提取近似特征对。给定 $\\mathcal{Q}$ 的一个标准正交基，由矩阵 $Q \\in \\mathbb{R}^{n \\times m}$ 的列表示，该方法形成投影矩阵 $H = Q^\\top A Q \\in \\mathbb{R}^{m \\times m}$。$H$ 的特征值被称为里兹值，它们作为 $A$ 的特征值的近似。\n\n紧缩是在迭代特征值算法中使用的一种技术，用于防止重新收敛到已经找到的特征对。一旦确定了与不变子空间 $\\mathcal{S}_{\\mathrm{lock}}$ 相关的 $k$ 组特征对，紧缩会修改算子或试验子空间，将搜索限制在 $\\mathcal{S}_{\\mathrm{lock}}$ 的正交补空间 $\\mathcal{S}_{\\mathrm{lock}}^\\perp$ 上。\n\n### 紧缩策略 1：朴素紧缩法\n\n该策略试图使用一个计算上简单但数值上有缺陷的程序，从一组新的试验向量中移除锁定子空间的分量。令收敛的特征向量由矩阵 $Q_{\\mathrm{lock}} \\in \\mathbb{R}^{n \\times k}$ 的列近似表示。在实际场景中，由于有限精度算术和近似误差，该矩阵会受到污染，从而得到 $Q_{\\mathrm{lock}}^{\\mathrm{bad}}$。$Q_{\\mathrm{lock}}^{\\mathrm{bad}}$ 的列通常不是标准正交的，即 $(Q_{\\mathrm{lock}}^{\\mathrm{bad}})^\\top Q_{\\mathrm{lock}}^{\\mathrm{bad}} \\neq I$。\n\n按照规定，朴素紧缩法对一组随机试验向量块 $X \\in \\mathbb{R}^{n \\times m}$ 应用以下操作：\n$$\nY_{\\mathrm{naive}} = X - Q_{\\mathrm{lock}}^{\\mathrm{bad}} (Q_{\\mathrm{lock}}^{\\mathrm{bad}})^\\top X\n$$\n该操作对应于应用矩阵 $P_{\\mathrm{improper}} = I - Q_{\\mathrm{lock}}^{\\mathrm{bad}} (Q_{\\mathrm{lock}}^{\\mathrm{bad}})^\\top$。这不是一个正交投影算子，因为当 $Q_{\\mathrm{lock}}^{\\mathrm{bad}}$ 的列不是标准正交时，$P_{\\mathrm{improper}}^2 \\neq P_{\\mathrm{improper}}$。因此，该操作无法完全从子空间 $\\mathrm{span}(Q_{\\mathrm{lock}}^{\\mathrm{bad}})$ 中移除分量。\n\n然后从 $Y_{\\mathrm{naive}}$ 的列计算出一个标准正交基 $Q_{\\mathrm{trial, naive}}$。通过计算瑞利商 $H_{\\mathrm{naive}} = Q_{\\mathrm{trial, naive}}^\\top A Q_{\\mathrm{trial, naive}}$ 的特征值来找到里兹值。由于锁定子空间的分量可能“泄漏”到 $Q_{\\mathrm{trial, naive}}$ 中，得到的里兹值可能包含对锁定特征值的虚假近似。这些就是“幽灵”里兹值。\n\n### 紧缩策略 2：稳健紧缩法\n\n该策略遵循一个数值上可靠的程序，以确保完全移除锁定的子空间。\n\n1.  **对锁定的子空间基进行标准正交化：** 第一步是为受污染向量所张成的子空间构建一个合适的标准正交基。这通过对 $Q_{\\mathrm{lock}}^{\\mathrm{bad}}$ 应用一个数值稳定的标准正交化过程（如 QR 分解）来实现，从而获得一个矩阵 $\\widehat{Q}_{\\mathrm{lock}} \\in \\mathbb{R}^{n \\times k}$，其列构成了 $\\mathrm{span}(Q_{\\mathrm{lock}}^{\\mathrm{bad}})$ 的一个标准正交基。\n\n2.  **构造正交投影算子：** 利用这个标准正交基，构造一个到锁定子空间的正交补空间上的真正交投影算子 $P$：\n    $$\n    P = I - \\widehat{Q}_{\\mathrm{lock}} \\widehat{Q}_{\\mathrm{lock}}^\\top\n    $$\n    这个投影算子是幂等的（$P^2 = P$）和对称的（$P^\\top = P$）。\n\n3.  **投影试验向量：** 将随机试验向量 $X$ 投影到这个正交补空间上：\n    $$\n    Y_{\\mathrm{robust}} = P X = X - \\widehat{Q}_{\\mathrm{lock}} (\\widehat{Q}_{\\mathrm{lock}}^\\top X)\n    $$\n    根据构造，$Y_{\\mathrm{robust}}$ 的列与锁定的子空间 $\\mathrm{span}(\\widehat{Q}_{\\mathrm{lock}})$ 正交。\n\n4.  **计算里兹值：** 从 $Y_{\\mathrm{robust}}$ 计算出一个标准正交基 $Q_{\\mathrm{trial, robust}}$。里兹值是瑞利商 $H_{\\mathrm{robust}} = Q_{\\mathrm{trial, robust}}^\\top A Q_{\\mathrm{trial, robust}}$ 的特征值。由于 $Q_{\\mathrm{trial, robust}}$ 的列在 $P$ 的值域内，我们有 $P Q_{\\mathrm{trial, robust}} = Q_{\\mathrm{trial, robust}}$。这意味着里兹值是紧缩算子 $P A P$ 在此试验子空间上的限制的特征值的近似。这个过程有效地防止了锁定子空间的泄漏，从而消除了幽灵里兹值。\n\n### 实验设计与量化\n\n该实验系统地比较了这两种策略。\n\n-   一个对称矩阵 $A$ 被构造成 $A = Q D Q^\\top$，其中 $Q$ 是真实特征向量构成的正交矩阵，$D$ 是由预设特征值 $d_i$ 构成的对角矩阵。\n-   “锁定的”特征向量选为 $Q$ 的前 $k$ 列，记作 $Q_{:k}$。通过添加随机噪声对其进行污染：$Q_{\\mathrm{lock}}^{\\mathrm{bad}} = Q_{:k} + \\epsilon R$，其中 $R$ 是一个随机矩阵，$\\epsilon$ 控制污染水平。\n-   “锁定的”特征值 $\\Lambda_{\\mathrm{lock}} = \\{\\lambda_1, \\dots, \\lambda_k\\}$ 是来自 $D$ 的前 $k$ 个特征值。\n-   在紧缩阶段计算出的里兹值 $\\mu$ 如果接近任何一个锁定的特征值，即满足 $\\min_{i \\in \\{1,\\dots,k\\}} |\\mu - \\lambda_i| \\le \\delta$（其中 $\\delta = 10^{-3}$），则被归类为“幽灵”里兹值。\n-   分别为朴素方法（$g_{\\mathrm{naive}}$）和稳健方法（$g_{\\mathrm{robust}}$）统计幽灵里兹值的数量。测试用例旨在表明 $g_{\\mathrm{robust}} < g_{\\mathrm{naive}}$，尤其是在 $\\epsilon > 0$ 时。$k=0$ 的情况作为对照组，此时不执行紧缩，两种方法都应得到 $g_{\\mathrm{naive}} = g_{\\mathrm{robust}} = 0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr, eigh\nfrom scipy.stats import ortho_group\n\ndef solve():\n    \"\"\"\n    Implements and compares naive vs. robust deflation strategies for\n    block subspace iteration to demonstrate the emergence of 'ghost' Ritz values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_spec = [\n        # Case 1: Happy path\n        {'n': 80, 'k': 5, 'd_params': {'clusters': [(1.0, 5), (5.0, 5)], 'uniform_range': (10.0, 20.0)}, 'epsilon': 5e-2, 'm': 8, 'seed': 12345, 'condition': 'robust_less_than_naive'},\n        # Case 2: Boundary condition with no converged subset\n        {'n': 60, 'k': 0, 'd_params': {'clusters': [], 'uniform_range': (1.0, 20.0)}, 'epsilon': 0.0, 'm': 6, 'seed': 54321, 'condition': 'robust_equals_naive_zero'},\n        # Case 3: Multiple eigenvalues\n        {'n': 90, 'k': 3, 'd_params': {'clusters': [(3.0, 3), (4.0, 3)], 'uniform_range': (6.0, 12.0)}, 'epsilon': 1e-1, 'm': 6, 'seed': 31415, 'condition': 'robust_less_than_naive'}\n    ]\n\n    delta = 1e-3\n    results = []\n\n    for case in test_cases_spec:\n        n, k, d_params, epsilon, m, seed = case['n'], case['k'], case['d_params'], case['epsilon'], case['m'], case['seed']\n        rng = np.random.default_rng(seed)\n\n        # 1. Construct the test matrix A = Q D Q.T\n        d_list = []\n        num_clustered = 0\n        for val, mult in d_params['clusters']:\n            d_list.extend([val] * mult)\n            num_clustered += mult\n        \n        num_uniform = n - num_clustered\n        if num_uniform > 0:\n            d_list.extend(rng.uniform(d_params['uniform_range'][0], d_params['uniform_range'][1], num_uniform))\n        \n        d = np.array(d_list)\n        d.sort()  # Ensure eigenvalues are sorted for consistent selection\n\n        # Generate a random orthogonal matrix Q\n        Q = ortho_group.rvs(dim=n, random_state=rng)\n        A = Q @ np.diag(d) @ Q.T\n\n        # 2. Handle the k=0 case (no deflation)\n        if k == 0:\n            g_naive = 0\n            g_robust = 0\n        else:\n            # 3. Setup common variables for deflation\n            locked_eigs = d[:k]\n            Q_lock = Q[:, :k]  # True eigenvectors for the locked subspace\n            R = rng.standard_normal((n, k))\n            Q_lock_bad = Q_lock + epsilon * R  # Contaminated basis\n            X = rng.standard_normal((n, m))  # Random trial subspace\n\n            # 4. Naive Deflation\n            Y_naive = X - Q_lock_bad @ (Q_lock_bad.T @ X)\n            Q_trial_naive, _ = qr(Y_naive, mode='economic')\n\n            H_naive = Q_trial_naive.T @ A @ Q_trial_naive\n            ritz_values_naive = eigh(H_naive, eigvals_only=True)\n\n            g_naive = sum(1 for mu in ritz_values_naive if np.any(np.abs(mu - locked_eigs) = delta))\n\n            # 5. Robust Deflation\n            Q_hat_lock, _ = qr(Q_lock_bad, mode='economic') # Orthonormalize the bad basis\n            \n            # Project X onto the orthogonal complement of the locked subspace\n            Y_robust = X - Q_hat_lock @ (Q_hat_lock.T @ X)\n            Q_trial_robust, _ = qr(Y_robust, mode='economic')\n            \n            H_robust = Q_trial_robust.T @ A @ Q_trial_robust\n            ritz_values_robust = eigh(H_robust, eigvals_only=True)\n\n            g_robust = sum(1 for mu in ritz_values_robust if np.any(np.abs(mu - locked_eigs) = delta))\n        \n        # 6. Evaluate the specified condition for the case\n        condition_type = case['condition']\n        if condition_type == 'robust_less_than_naive':\n            results.append(g_robust  g_naive)\n        elif condition_type == 'robust_equals_naive_zero':\n            results.append(g_robust == 0 and g_naive == 0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}