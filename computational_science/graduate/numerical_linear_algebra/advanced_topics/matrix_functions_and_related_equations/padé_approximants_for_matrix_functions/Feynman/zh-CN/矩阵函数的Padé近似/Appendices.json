{
    "hands_on_practices": [
        {
            "introduction": "要深入理解帕德近似，需要掌握三个核心技能：从第一性原理出发进行构造，验证其高阶精度，以及将其应用于矩阵（尤其非对角化矩阵）。这个综合性练习  涵盖了所有这些方面。它首先要求构造指数函数的几个对角帕德近似，然后推广精度证明，最后通过在若尔当块上计算近似值，将理论与实践联系起来，而若尔当块是任何矩阵函数的基本构成单元。",
            "id": "3564133",
            "problem": "令 $f(z) = \\exp(z)$，且对于一个非负整数 $m$，令 $[m/m]$ Padé 近似 $r_{m,m}(z)$ 为有理函数 $p_{m}(z)/q_{m}(z)$，其中 $\\deg(p_{m}) \\leq m$，$\\deg(q_{m}) \\leq m$，且 $q_{m}(0) = 1$，使得 $q_{m}(z) f(z) - p_{m}(z)$ 的麦克劳林级数在 $z=0$ 处有至少 $2m+1$ 阶的零点。\n\n(i) 通过施加定义条件 $q_{m}(z) \\exp(z) - p_{m}(z) = \\mathcal{O}(z^{2m+1})$ 和 $q_{m}(0) = 1$，显式构造 $\\exp(z)$ 的 $[1/1]$、$ [2/2]$ 和 $[3/3]$ Padé 近似。\n\n(ii) 从 (i) 部分的定义出发，并仅使用关于 $z=0$ 的级数展开以及 $q_{m}(0) \\neq 0$ 这一事实，证明 $r_{m,m}(z)$ 的麦克劳林级数与 $\\exp(z)$ 的麦克劳林级数匹配至 $2m$ 次项，即 $r_{m,m}(z) - \\exp(z) = \\mathcal{O}(z^{2m+1})$。\n\n(iii) 令 $J(\\lambda) \\in \\mathbb{C}^{2 \\times 2}$ 为特征值是 $\\lambda \\in \\mathbb{C}$ 的 2 阶若尔当块，即 $J(\\lambda) = \\lambda I + N$，其中 $N = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix}$ 且 $N^{2} = 0$。仅使用函数关于 $z=\\lambda$ 的泰勒级数展开以及 $N$ 的幂零性，证明对于在 $\\lambda$ 处解析的任何有理函数 $r$，都有 $r\\!\\left(J(\\lambda)\\right) = r(\\lambda) I + r'(\\lambda) N$，因此特别地，$r\\!\\left(J(\\lambda)\\right)$ 的 $(1,2)$ 元等于 $r'(\\lambda)$。\n\n(iv) 取特例 $\\lambda = 1$ 且 $r = r_{3,3}$，即你在 (i) 部分中求得的 $[3/3]$ Padé 近似。精确计算 $r\\!\\left(J(1)\\right)$ 的 $(1,2)$ 元，并将其报告为单个精确的有理数。不要对你的答案进行四舍五入。",
            "solution": "问题陈述需经过验证。\n\n### 步骤 1：提取已知条件\n- 函数为 $f(z) = \\exp(z)$。\n- 对于一个非负整数 $m$，$[m/m]$ Padé 近似为 $r_{m,m}(z) = p_{m}(z)/q_{m}(z)$。\n- 多项式的次数受约束：$\\deg(p_{m}) \\leq m$ 且 $\\deg(q_{m}) \\leq m$。\n- 指定了归一化条件：$q_{m}(0) = 1$。\n- Padé 近似由以下条件定义：$q_{m}(z) f(z) - p_{m}(z)$ 的麦克劳林级数在 $z=0$ 处有至少 $2m+1$ 阶的零点，表示为 $q_{m}(z) \\exp(z) - p_{m}(z) = \\mathcal{O}(z^{2m+1})$。\n- (i) 部分要求显式构造 $r_{1,1}(z)$、$r_{2,2}(z)$ 和 $r_{3,3}(z)$。\n- (ii) 部分要求证明 $r_{m,m}(z) - \\exp(z) = \\mathcal{O}(z^{2m+1})$。\n- (iii) 部分考虑一个 2 阶若尔当块 $J(\\lambda) = \\lambda I + N$，其中 $N = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix}$，并要求证明对于在 $\\lambda$ 处解析的有理函数 $r$，$r(J(\\lambda)) = r(\\lambda) I + r'(\\lambda) N$。\n- (iv) 部分要求精确计算 $r_{3,3}(J(1))$ 的 $(1,2)$ 元。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：**该问题植根于已建立的 Padé 近似理论及其在矩阵函数中的应用，这是数值线性代数和近似理论中的一个标准课题。所有定义和概念都是标准的，并且在数学上是合理的。\n- **良态性：**该问题被构造为一系列逻辑上相互关联的任务。每个部分都定义清晰，并根据所提供的信息导出一个唯一的、可确定的结果。这些条件足以唯一地构造所需的近似并证明所述性质。\n- **客观性：**该问题以精确、形式化的数学语言表述，没有任何主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是数值分析中一个定义明确的标准问题。现在可以开始求解过程。\n\n***\n\n我们将按顺序解决问题的四个部分。\n\n**(i) 构造 $\\exp(z)$ 的 $[m/m]$ Padé 近似**\n\n令 $p_{m}(z) = \\sum_{j=0}^{m} a_j z^j$ 且 $q_{m}(z) = \\sum_{j=0}^{m} b_j z^j$。归一化条件为 $q_m(0)=1$，因此 $b_0=1$。定义条件是：\n$$ \\left(\\sum_{j=0}^{m} b_j z^j\\right) \\left(\\sum_{k=0}^{\\infty} \\frac{z^k}{k!}\\right) - \\left(\\sum_{j=0}^{m} a_j z^j\\right) = \\mathcal{O}(z^{2m+1}) $$\n这意味着左边 $z^k$（其中 $k=0, 1, \\dots, 2m$）的系数必须为零。\n乘积 $q_m(z)\\exp(z)$ 中 $z^k$ 的系数是 $\\sum_{j=0}^k \\frac{b_j}{(k-j)!}$（当 $jm$ 时，$b_j=0$）。\n\n对于 $k \\in \\{0, \\dots, m\\}$，将 $z^k$ 的系数设为零，得到关于 $a_k$ 的方程：\n$$ a_k = \\sum_{j=0}^k \\frac{b_j}{(k-j)!} $$\n对于 $k \\in \\{m+1, \\dots, 2m\\}$，我们有 $a_k=0$，这给出了一个关于 $b_1, \\dots, b_m$ 的线性方程组：\n$$ \\sum_{j=0}^m \\frac{b_j}{(k-j)!} = 0 $$\n\n**情况 $m=1$：** $p_1(z) = a_0+a_1z$, $q_1(z) = 1+b_1z$。\n对于 $k=2$ 的方程是 $\\frac{b_0}{2!} + \\frac{b_1}{1!} = 0$。由于 $b_0=1$，我们得到 $\\frac{1}{2} + b_1 = 0 \\implies b_1 = -\\frac{1}{2}$。\n因此，$q_1(z) = 1 - \\frac{1}{2}z$。\n$p_1(z)$ 的系数是：\n$a_0 = \\frac{b_0}{0!} = 1$。\n$a_1 = \\frac{b_0}{1!} + \\frac{b_1}{0!} = 1 - \\frac{1}{2} = \\frac{1}{2}$。\n因此，$p_1(z) = 1 + \\frac{1}{2}z$。\n$[1/1]$ 近似是 $r_{1,1}(z) = \\frac{1 + \\frac{1}{2}z}{1 - \\frac{1}{2}z}$。\n\n**情况 $m=2$：** $q_2(z) = 1+b_1z+b_2z^2$。\n对于 $k=3, 4$ 的方程是：\n$k=3: \\frac{b_0}{3!} + \\frac{b_1}{2!} + \\frac{b_2}{1!} = 0 \\implies \\frac{1}{6} + \\frac{b_1}{2} + b_2 = 0$。\n$k=4: \\frac{b_0}{4!} + \\frac{b_1}{3!} + \\frac{b_2}{2!} = 0 \\implies \\frac{1}{24} + \\frac{b_1}{6} + \\frac{b_2}{2} = 0$。\n这是一个线性系统：$3b_1 + 6b_2 = -1$ 和 $2b_1 + 6b_2 = -1/2$。两方程相减得到 $b_1 = -1/2$。代回得 $6b_2 = -1/2 - 2(-1/2) = 1/2$，所以 $b_2=1/12$。\n因此，$q_2(z) = 1 - \\frac{1}{2}z + \\frac{1}{12}z^2$。\n对于指数函数，有一个已知的性质（我们可以验证）即 $p_m(z) = q_m(-z)$。\n$p_2(z) = q_2(-z) = 1 + \\frac{1}{2}z + \\frac{1}{12}z^2$。\n$[2/2]$ 近似是 $r_{2,2}(z) = \\frac{1 + \\frac{1}{2}z + \\frac{1}{12}z^2}{1 - \\frac{1}{2}z + \\frac{1}{12}z^2}$。\n\n**情况 $m=3$：** $q_3(z) = 1+b_1z+b_2z^2+b_3z^3$。\n对于 $k=4, 5, 6$ 的方程是：\n$k=4: \\frac{1}{4!} + \\frac{b_1}{3!} + \\frac{b_2}{2!} + \\frac{b_3}{1!} = 0 \\implies 1 + 4b_1 + 12b_2 + 24b_3 = 0$。\n$k=5: \\frac{1}{5!} + \\frac{b_1}{4!} + \\frac{b_2}{3!} + \\frac{b_3}{2!} = 0 \\implies 1 + 5b_1 + 20b_2 + 60b_3 = 0$。\n$k=6: \\frac{1}{6!} + \\frac{b_1}{5!} + \\frac{b_2}{4!} + \\frac{b_3}{3!} = 0 \\implies 1 + 6b_1 + 30b_2 + 120b_3 = 0$。\n解这个方程组得到 $b_1 = -1/2$，$b_2 = 1/10$，和 $b_3 = -1/120$。\n因此，$q_3(z) = 1 - \\frac{1}{2}z + \\frac{1}{10}z^2 - \\frac{1}{120}z^3$。\n使用性质 $p_3(z) = q_3(-z)$：\n$p_3(z) = 1 + \\frac{1}{2}z + \\frac{1}{10}z^2 + \\frac{1}{120}z^3$。\n$[3/3]$ 近似是 $r_{3,3}(z) = \\frac{1 + \\frac{1}{2}z + \\frac{1}{10}z^2 + \\frac{1}{120}z^3}{1 - \\frac{1}{2}z + \\frac{1}{10}z^2 - \\frac{1}{120}z^3}$。\n\n**(ii) 麦克劳林级数匹配性质**\n\n我们被给予了定义条件 $q_m(z)\\exp(z) - p_m(z) = \\mathcal{O}(z^{2m+1})$。我们需要证明这蕴含了 $r_{m,m}(z) - \\exp(z) = \\mathcal{O}(z^{2m+1})$，其中 $r_{m,m}(z) = p_m(z)/q_m(z)$。\n\n根据给定的条件，我们可以写出：\n$$ q_m(z)\\exp(z) - p_m(z) = C z^{2m+1} + \\text{更高阶项} $$\n对于某个常数 $C$。两边除以 $q_m(z)$：\n$$ \\exp(z) - \\frac{p_m(z)}{q_m(z)} = \\frac{C z^{2m+1} + \\dots}{q_m(z)} $$\n这等价于：\n$$ \\exp(z) - r_{m,m}(z) = \\frac{1}{q_m(z)} \\mathcal{O}(z^{2m+1}) $$\n问题陈述 $q_m(0)=1$。由于 $q_m(z)$ 是一个多项式，它处处解析。条件 $q_m(0) \\neq 0$ 意味着函数 $1/q_m(z)$ 在 $z=0$ 的一个邻域内是解析的。其麦克劳林级数开始于：\n$$ \\frac{1}{q_m(z)} = \\frac{1}{1 + b_1 z + \\dots} = 1 - b_1 z + \\dots = \\mathcal{O}(1) $$\n因此，误差项可以作为级数的乘积来分析：\n$$ \\exp(z) - r_{m,m}(z) = (\\mathcal{O}(1)) \\cdot (\\mathcal{O}(z^{2m+1})) = \\mathcal{O}(z^{2m+1}) $$\n这表明 $r_{m,m}(z)$ 的麦克劳林级数与 $\\exp(z)$ 的麦克劳林级数在直到并包括 $2m$ 次项上是一致的。第一个不同的项是 $2m+1$ 次项。证明完毕。\n\n**(iii) 若尔当块的函数**\n\n我们已知 $J(\\lambda) = \\lambda I + N$，其中 $N = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix}$。直接计算表明 $N^2 = \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ 0  0 \\end{pmatrix} = 0$。因此，对于所有整数 $k \\ge 2$，都有 $N^k = 0$。\n\n令 $r(z)$ 是在 $\\lambda$ 处解析的一个有理函数。它在 $z=\\lambda$ 周围的泰勒级数展开是：\n$$ r(z) = \\sum_{k=0}^{\\infty} \\frac{r^{(k)}(\\lambda)}{k!} (z-\\lambda)^k = r(\\lambda) + r'(\\lambda)(z-\\lambda) + \\frac{r''(\\lambda)}{2!}(z-\\lambda)^2 + \\dots $$\n对于解析函数的矩阵函数定义是通过将其泰勒级数中的变量替换为矩阵来给出的。我们来计算 $r(J(\\lambda))$：\n$$ r(J(\\lambda)) = \\sum_{k=0}^{\\infty} \\frac{r^{(k)}(\\lambda)}{k!} (J(\\lambda)-\\lambda I)^k $$\n函数的自变量是 $J(\\lambda)-\\lambda I = (\\lambda I + N) - \\lambda I = N$。将其代入级数中：\n$$ r(J(\\lambda)) = \\sum_{k=0}^{\\infty} \\frac{r^{(k)}(\\lambda)}{k!} N^k = \\frac{r^{(0)}(\\lambda)}{0!} N^0 + \\frac{r^{(1)}(\\lambda)}{1!} N^1 + \\frac{r^{(2)}(\\lambda)}{2!} N^2 + \\dots $$\n使用 $N^0 = I$，$N^1=N$，以及当 $k \\ge 2$ 时 $N^k=0$，无穷级数被截断为：\n$$ r(J(\\lambda)) = r(\\lambda)I + r'(\\lambda)N + 0 + 0 + \\dots = r(\\lambda)I + r'(\\lambda)N $$\n用矩阵形式表示，这是：\n$$ r(J(\\lambda)) = r(\\lambda)\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + r'(\\lambda)\\begin{pmatrix} 0  1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} r(\\lambda)  r'(\\lambda) \\\\ 0  r(\\lambda) \\end{pmatrix} $$\n该矩阵的 $(1,2)$ 元显然是 $r'(\\lambda)$。\n\n**(iv) 计算 $r_{3,3}(J(1))$ 的 $(1,2)$ 元**\n\n根据 (iii) 部分， $r_{3,3}(J(1))$ 的 $(1,2)$ 元由 $r'_{3,3}(1)$ 给出。我们有 $r_{3,3}(z) = p_3(z)/q_3(z)$。其导数使用商法则求得：\n$$ r'_{3,3}(z) = \\frac{p'_3(z)q_3(z) - p_3(z)q'_3(z)}{[q_3(z)]^2} $$\n从 (i) 部分，我们有：\n$p_3(z) = 1 + \\frac{1}{2}z + \\frac{1}{10}z^2 + \\frac{1}{120}z^3$\n$q_3(z) = 1 - \\frac{1}{2}z + \\frac{1}{10}z^2 - \\frac{1}{120}z^3$\n\n注意到 $p_3(z) = q_3(-z)$ 会很有效。我们来定义偶部和奇部。令 $S(z) = p_3(z) + q_3(z)$ 且 $D(z) = p_3(z) - q_3(z)$。\n$S(z) = 2(1 + \\frac{1}{10}z^2)$\n$D(z) = 2(\\frac{1}{2}z + \\frac{1}{120}z^3) = z + \\frac{1}{60}z^3$\n那么 $p_3 = (S+D)/2$ 且 $q_3 = (S-D)/2$。导数的分子是 $p'_3q_3 - p_3q'_3$。\n$p'_3q_3 - p_3q'_3 = \\frac{S'+D'}{2} \\frac{S-D}{2} - \\frac{S+D}{2} \\frac{S'-D'}{2} = \\frac{1}{4} \\left( (S'S - S'D + D'S - D'D) - (S'S - SD' + DS' - DD') \\right) = \\frac{1}{4}(2D'S - 2S'D) = \\frac{1}{2}(D'S - S'D)$。\n首先，我们求 $S(z)$ 和 $D(z)$ 的导数：\n$S'(z) = 2(\\frac{2}{10}z) = \\frac{2}{5}z$\n$D'(z) = 1 + \\frac{3}{60}z^2 = 1 + \\frac{1}{20}z^2$\n\n现在我们在 $z=1$ 处计算这些函数及其导数的值：\n$S(1) = 2(1+\\frac{1}{10}) = 2(\\frac{11}{10}) = \\frac{11}{5}$\n$D(1) = 1 + \\frac{1}{60} = \\frac{61}{60}$\n$S'(1) = \\frac{2}{5}$\n$D'(1) = 1 + \\frac{1}{20} = \\frac{21}{20}$\n\n分子值：\n$N = \\frac{1}{2}\\left(\\left(\\frac{21}{20}\\right)\\left(\\frac{11}{5}\\right) - \\left(\\frac{2}{5}\\right)\\left(\\frac{61}{60}\\right)\\right) = \\frac{1}{2}\\left(\\frac{231}{100} - \\frac{122}{300}\\right) = \\frac{1}{2}\\left(\\frac{693-122}{300}\\right) = \\frac{1}{2}\\left(\\frac{571}{300}\\right) = \\frac{571}{600}$。\n\n$r'_{3,3}(1)$ 的分母是 $[q_3(1)]^2$。我们计算 $q_3(1)$：\n$q_3(1) = \\frac{S(1)-D(1)}{2} = \\frac{1}{2}\\left(\\frac{11}{5} - \\frac{61}{60}\\right) = \\frac{1}{2}\\left(\\frac{132-61}{60}\\right) = \\frac{1}{2}\\left(\\frac{71}{60}\\right) = \\frac{71}{120}$。\n所以，$[q_3(1)]^2 = \\left(\\frac{71}{120}\\right)^2 = \\frac{5041}{14400}$。\n\n最后，我们计算比值：\n$r'_{3,3}(1) = \\frac{N}{[q_3(1)]^2} = \\frac{571/600}{5041/14400} = \\frac{571}{600} \\cdot \\frac{14400}{5041} = 571 \\cdot \\frac{24}{5041} = \\frac{13704}{5041}$。\n数字 $71$ 是素数，且 $5041=71^2$。经检查，$13704$ 不能被 $71$ 整除。因此，该分式是最简形式。",
            "answer": "$$\n\\boxed{\\frac{13704}{5041}}\n$$"
        },
        {
            "introduction": "在掌握了理论计算之后，我们转向实际算法。在科学计算中，一个常见且至关重要的任务不是计算完整的矩阵函数 $f(A)$，而是计算它对一个向量的作用，即 $f(A)b$。本练习  介绍了一种强大而高效的方法，该方法利用帕德近似的部分分式展开。这种技术将原问题转化为求解一系列独立的、移位的线性方程组，这种结构非常适合并行计算，我们也将通过一个理论性能模型来比较其在 CPU 和 GPU 上的实现效率。",
            "id": "3564069",
            "problem": "要求您设计并实现一个数值方法，使用 Padé 近似来近似计算矩阵函数在向量上的作用，并为当位移保持稀疏模式时批处理位移线性系统的求解量化一个理论性能模型。重点是以矩阵指数作为代表性的解析函数，以及一个比较中央处理器 (CPU) 串行策略与图形处理器 (GPU) 批处理策略的成本模型。\n\n您的设计必须基于以下数值线性代数中经过充分检验的定义和事实：\n- 对于一个方阵 $\\displaystyle A \\in \\mathbb{C}^{n \\times n}$ 和一个解析函数 $\\displaystyle f$，矩阵函数 $\\displaystyle f(A)$ 在适用时通过收敛的幂级数定义：$\\displaystyle f(A) = \\sum_{k=0}^{\\infty} c_k A^k$，其中 $\\displaystyle f(z) = \\sum_{k=0}^{\\infty} c_k z^k$ 是 $\\displaystyle f$ 在 $\\displaystyle 0$ 点的泰勒级数。\n- 函数 $\\displaystyle f(z)$ 的 $\\displaystyle (m,m)$ 阶 Padé 近似 $\\displaystyle r_{m,m}(z) = \\frac{p_m(z)}{q_m(z)}$ 是一个唯一的有理函数，其麦克劳林级数与 $\\displaystyle f$ 的级数匹配至 $\\displaystyle 2m$ 阶，即 $\\displaystyle f(z) - r_{m,m}(z) = \\mathcal{O}(z^{2m+1})$。\n- 任何分母具有单根的有理函数都允许部分分式展开：$\\displaystyle \\frac{p(z)}{q(z)} = c_0 + \\sum_{j=1}^{K} \\frac{\\alpha_j}{z - \\zeta_j}$，其中 $\\displaystyle \\zeta_j$ 是 $\\displaystyle q$ 的根（极点），$\\displaystyle \\alpha_j$ 是留数，如果该有理函数不是真分式，则 $\\displaystyle c_0$ 是一个常数。对于单极点，留数满足 $\\displaystyle \\alpha_j = \\frac{p(\\zeta_j)}{q'(\\zeta_j)}$。\n- 对于矩阵，$\\displaystyle r(A)$ 在向量 $\\displaystyle b$ 上的作用可以通过预解式实现：$\\displaystyle r(A)b = c_0 b + \\sum_{j=1}^{K} \\alpha_j (A - \\zeta_j I)^{-1} b$，前提是极点不与 $\\displaystyle A$ 的谱重合。\n- 对于矩阵指数，$\\displaystyle e^{z}$ 的对角 Padé 近似 $\\displaystyle r_{m,m}$ 可以由麦克劳林级数系数 $\\displaystyle c_k = \\frac{1}{k!}$（对于 $\\displaystyle k = 0,1,\\dots,2m$）构建。\n\n您的任务是：\n1) 通过匹配麦克劳林级数系数 $\\displaystyle c_k = \\frac{1}{k!}$（对于 $\\displaystyle k = 0,1,\\dots,2m$）来构建 $\\displaystyle e^{z}$ 的对角 Padé 近似 $\\displaystyle r_{m,m}(z)$。然后，使用留数和假有理函数常数的基本定义，推导出一个稳定的部分分式形式 $\\displaystyle r_{m,m}(z) = c_0 + \\sum_{j=1}^{K} \\frac{\\alpha_j}{z - \\zeta_j}$。您的实现必须从多项式 $\\displaystyle p_m$ 和 $\\displaystyle q_m$ 计算出 $\\displaystyle c_0$、极点 $\\displaystyle \\{\\zeta_j\\}_{j=1}^{K}$ 和留数 $\\displaystyle \\{\\alpha_j\\}_{j=1}^{K}$，无需硬编码任何预先制表的 Padé 系数。\n2) 实现一个函数，对于给定的稀疏矩阵 $\\displaystyle A \\in \\mathbb{R}^{n \\times n}$ 和向量 $\\displaystyle b \\in \\mathbb{R}^{n}$，通过求解位移稀疏线性系统 $\\displaystyle (A - \\zeta_j I)x_j = b$（对于 $\\displaystyle j = 1,\\dots,K$）并将它们组合成 $\\displaystyle y = c_0 b + \\sum_{j=1}^{K} \\alpha_j x_j$ 的方式，利用部分分式表示法来计算 $\\displaystyle r_{m,m}(A)b$。您必须正确处理复数运算，并返回结果的实部（对于实数 $\\displaystyle A$ 和 $\\displaystyle b$，虚部应抵消至数值舍入误差）。\n3) 为了验证，使用矩阵指数作用的标准算法计算一个高精度的参考解 $\\displaystyle y_{\\mathrm{ref}} \\approx e^{A} b$，并报告相对误差 $\\displaystyle \\|y - y_{\\mathrm{ref}}\\|_2 / \\|y_{\\mathrm{ref}}\\|_2$。\n4) 建立一个理论性能模型，该模型量化了在图形处理器（GPU）上批处理求解 $\\displaystyle K$ 个位移系统与在中央处理器（CPU）上串行求解相比的预测加速比，假设所有位移 $\\displaystyle \\zeta_j$ 都保持 $\\displaystyle A - \\zeta_j I$ 的稀疏模式。使用以下简单的、量纲一致的成本模型，其中 $\\displaystyle \\text{nnz}$ 表示 $\\displaystyle A$ 的非零元数量，$\\displaystyle n$ 是维度，$\\displaystyle K$ 是极点数：\n- CPU（每个位移串行处理）：$\\displaystyle T_{\\mathrm{CPU}} = K \\big( a_c \\,\\text{nnz} + b_c \\,\\text{nnz}\\, \\sqrt{n} + c_c \\,\\text{nnz} \\big)$。\n- GPU（所有位移批处理，共享分析并降低单位移常数）：$\\displaystyle T_{\\mathrm{GPU}} = a_g \\,\\text{nnz} + K \\big( \\rho\\, b_g \\,\\text{nnz}\\, \\sqrt{n} + \\sigma\\, c_g \\,\\text{nnz} \\big)$。\n使用固定常数\n$\\displaystyle a_c = 8 \\times 10^{-9}$、$\\displaystyle b_c = 5 \\times 10^{-8}$、$\\displaystyle c_c = 2 \\times 10^{-9}$、$\\displaystyle a_g = 1 \\times 10^{-9}$、$\\displaystyle b_g = 8 \\times 10^{-9}$、$\\displaystyle c_g = 5 \\times 10^{-10}$、$\\displaystyle \\rho = 0.5$ 和 $\\displaystyle \\sigma = 0.3$，\n其中时间以秒表示，$\\displaystyle \\text{nnz}$ 无单位。\n5) 将您的方法应用于以下测试套件。在每种情况下，将 $\\displaystyle A$ 构建为带狄利克雷边界条件的缩放一维离散拉普拉斯算子，即 $\\displaystyle L_n = \\operatorname{tridiag}(-1,2,-1) \\in \\mathbb{R}^{n \\times n}$ 且 $\\displaystyle A = -\\alpha L_n$。使用指定的随机种子，用独立的标准正态分布项构成 $\\displaystyle b$。对于每种情况，计算：\n- 相对误差 $\\displaystyle \\|y - y_{\\mathrm{ref}}\\|_2 / \\|y_{\\mathrm{ref}}\\|_2$。\n- 预测加速比 $\\displaystyle S = T_{\\mathrm{CPU}} / T_{\\mathrm{GPU}}$。\n测试套件的参数元组 $\\displaystyle (n,\\alpha,m,\\text{seed})$ 如下：\n- 情况 $\\displaystyle 1$：$\\displaystyle (40,\\, 0.10,\\, 6,\\, 12345)$。\n- 情况 $\\displaystyle 2$：$\\displaystyle (1,\\, 0.00,\\, 4,\\, 2024)$。\n- 情况 $\\displaystyle 3$：$\\displaystyle (60,\\, 0.08,\\, 8,\\, 31415)$。\n\n角度单位不适用。答案中没有物理单位。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格浮点数列表，顺序为\n$\\displaystyle [\\text{err}_1, \\text{speedup}_1, \\text{err}_2, \\text{speedup}_2, \\text{err}_3, \\text{speedup}_3]$，\n其中 $\\displaystyle \\text{err}_i$ 是情况 $\\displaystyle i$ 的相对误差，$\\displaystyle \\text{speedup}_i$ 是情况 $\\displaystyle i$ 的预测加速比。在打印前将每个浮点数四舍五入到恰好 $\\displaystyle 8$ 位小数。代码必须完全自包含，且不得读取任何输入。",
            "solution": "用户提供的问题是一个有效的数值分析任务，它自成体系，有科学依据，且问题设定良好。它要求设计并实现一种方法，使用 Padé 近似来近似矩阵指数在向量上的作用，$y = e^A b$。该方法的核心在于有理近似的部分分式展开，它将问题转化为求解一组位移线性系统。问题还指定了推导一个理论性能模型，用于比较串行和批处理执行策略。我将着手提供一个完整的解决方案。\n\n该解决方案根据问题陈述中定义的任务系统地组织。\n\n### 第 1 步：$e^z$ 的 Padé 近似\n\n一个有理函数 $r_{m,m}(z) = p_m(z)/q_m(z)$，其中 $p_m$ 和 $q_m$ 是次数最多为 $m$ 的多项式，如果它的麦克劳林级数展开式与解析函数 $f(z)$ 的展开式在尽可能高的阶数上一致，那么它就是 $f(z)$ 的 $(m,m)$-Padé 近似。对于 $f(z) = e^z = \\sum_{k=0}^{\\infty} \\frac{z^k}{k!}$，这个条件是 $q_m(z)e^z - p_m(z) = \\mathcal{O}(z^{2m+1})$。\n\n通过求解匹配 $z$ 的幂（直到 $z^{2m}$）的系数所产生的线性方程组，可以推导出分子 $p_m(z) = \\sum_{k=0}^{m} a_k z^k$ 和分母 $q_m(z) = \\sum_{k=0}^{m} b_k z^k$ 的系数。这些多项式在缩放因子下是唯一的，由以下公式给出：\n$$\np_m(z) = \\sum_{k=0}^{m} \\frac{(2m-k)! m!}{(2m)! k! (m-k)!} z^k\n$$\n$$\nq_m(z) = \\sum_{k=0}^{m} \\frac{(2m-k)! m!}{(2m)! k! (m-k)!} (-z)^k\n$$\n值得注意的是，分母与分子通过关系 $q_m(z) = p_m(-z)$ 相关联。\n\n### 第 2 步：部分分式分解\n\nPadé 近似 $r_{m,m}(z)$ 是一个假有理函数，因为 $\\deg(p_m) = \\deg(q_m) = m$。它可以用部分分式展开来表示。首先，多项式长除法得到一个常数项 $c_0$ 和一个严格真分式：\n$$\nr_{m,m}(z) = \\frac{p_m(z)}{q_m(z)} = c_0 + \\frac{s_m(z)}{q_m(z)}\n$$\n其中 $s_m(z) = p_m(z) - c_0 q_m(z)$ 是余项多项式，且 $\\deg(s_m)  m$。常数 $c_0$ 是 $p_m(z)$ 和 $q_m(z)$ 的首项系数之比，结果为 $c_0 = (-1)^m$。\n\n$r_{m,m}(z)$ 的极点，记为 $\\{\\zeta_j\\}_{j=1}^{m}$，是分母多项式 $q_m(z)$ 的根。对于 $e^z$ 的 Padé 近似，一个已知的性质是这些极点都是单根且位于复平面的右半部分。于是，部分分式展开为：\n$$\nr_{m,m}(z) = c_0 + \\sum_{j=1}^{m} \\frac{\\alpha_j}{z - \\zeta_j}\n$$\n对应于单极点的留数 $\\{\\alpha_j\\}_{j=1}^{m}$ 使用以下公式计算：\n$$\n\\alpha_j = \\frac{s_m(\\zeta_j)}{q'_m(\\zeta_j)} = \\frac{p_m(\\zeta_j) - c_0 q_m(\\zeta_j)}{q'_m(\\zeta_j)}\n$$\n由于根据极点的定义有 $q_m(\\zeta_j) = 0$，这简化为 $\\alpha_j = p_m(\\zeta_j) / q'_m(z)$，其中 $q'_m(z)$ 是 $q_m(z)$ 对 $z$ 的导数。\n\n### 第 3 步：近似 $e^A b$ 的算法\n\n将标量变量 $z$ 替换为矩阵 $A \\in \\mathbb{R}^{n \\times n}$，有理近似在向量 $b \\in \\mathbb{R}^n$ 上的作用由下式给出：\n$$\ny = r_{m,m}(A)b = \\left(c_0 I + \\sum_{j=1}^{m} \\alpha_j (A - \\zeta_j I)^{-1}\\right) b = c_0 b + \\sum_{j=1}^{m} \\alpha_j (A - \\zeta_j I)^{-1} b\n$$\n这个表达式启发了一个算法，我们避免显式地构建矩阵的逆。取而代之，我们求解一系列位移线性系统。令 $x_j = (A - \\zeta_j I)^{-1} b$。这等价于在以下方程中求解 $x_j$：\n$$\n(A - \\zeta_j I) x_j = b, \\quad \\text{for } j=1, \\dots, m\n$$\n最终的近似解 $y$ 则是这些解的线性组合：\n$$\ny = c_0 b + \\sum_{j=1}^{m} \\alpha_j x_j\n$$\n矩阵 $A$是实数，但极点 $\\zeta_j$ 和留数 $\\alpha_j$ 是复数且成共轭对出现。因此，中间向量 $x_j$ 和最终的和 $y$ 都是复数。然而，对于实矩阵 $A$ 和实向量 $b$，最终结果的虚部会在机器精度范围内抵消，所以我们取 $y$ 的实部作为最终答案。\n\n数值实现过程如下：\n1.  对于给定的阶数 $m$，计算 $p_m(z)$ 和 $q_m(z)$ 的系数。\n2.  计算常数 $c_0$、极点 $\\{\\zeta_j\\}$ 和留数 $\\{\\alpha_j\\}$。\n3.  初始化一个复向量 $y_{approx} = c_0 b$。\n4.  对于每个极点-留数对 $(\\zeta_j, \\alpha_j)$：\n    a. 构建稀疏、复数、位移矩阵 $M_j = A - \\zeta_j I$。\n    b. 使用稀疏直接求解器求解线性系统 $M_j x_j = b$ 得到 $x_j$。\n    c. 累加结果：$y_{approx} \\leftarrow y_{approx} + \\alpha_j x_j$。\n5.  返回 $\\text{Re}(y_{approx})$。\n\n### 第 4 步：验证和误差计算\n\n为了验证 Padé 近似的准确性，将结果 $y$ 与高精度参考解 $y_{\\mathrm{ref}} \\approx e^A b$ 进行比较。该参考解使用一种先进的算法计算，具体是 `scipy.sparse.linalg.expm_multiply` 中实现的算法，该算法基于 Krylov 子空间方法。相对误差使用欧几里得范数（$L_2$-范数）进行量化：\n$$\n\\text{err} = \\frac{\\|y - y_{\\mathrm{ref}}\\|_2}{\\|y_{\\mathrm{ref}}\\|_2}\n$$\n\n### 第 5 步：性能模型和加速比\n\n定义了一个理论性能模型，用于估计在 CPU 上串行求解 $m$ 个线性系统与在 GPU 上批量求解的计算时间。需要求解的系统数量为 $K=m$。矩阵 $A$ 是一个 $n \\times n$ 的缩放离散拉普拉斯算子，它是三对角的，因此其非零元素数量为 $\\text{nnz} = 3n-2$ (对于 $n > 1$) 和 $\\text{nnz}=1$ (对于 $n=1$)。\n\n模型方程已给出：\n-   CPU 时间: $T_{\\mathrm{CPU}} = K \\cdot \\text{nnz} \\cdot (a_c + b_c \\sqrt{n} + c_c)$\n-   GPU 时间: $T_{\\mathrm{GPU}} = \\text{nnz} \\cdot (a_g + K (\\rho b_g \\sqrt{n} + \\sigma c_g))$\n\n预测的加速比 $S$ 是这两个时间的比值：\n$$\nS = \\frac{T_{\\mathrm{CPU}}}{T_{\\mathrm{GPU}}}\n$$\n常数 $a_c, b_c, c_c, a_g, b_g, c_g, \\rho, \\sigma$ 具有给定的固定值。该模型提供了一个对通过批处理并行化可实现的性能增益的估计。\n\n### 第 6 步：应用于测试案例\n\n将所描述的方法应用于每个测试案例 $(n, \\alpha, m, \\text{seed})$。对于每个案例，构建矩阵 $A = -\\alpha \\operatorname{tridiag}(-1, 2, -1)$ 和向量 $b$（来自具有指定种子的标准正态分布）。然后按照上述步骤计算 Padé 近似解 $y$、参考解 $y_{\\mathrm{ref}}$、相对误差和预测加速比。",
            "answer": "```python\nimport numpy as np\nimport math\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve, expm_multiply\n\ndef get_pade_coeffs(m):\n    \"\"\"\n    Computes coefficients of the numerator p_m(z) and denominator q_m(z)\n    of the (m,m) Padé approximant to exp(z), in descending power order.\n    The formula for the coefficient of z^k in p_m(z) is:\n    c_k = (m! * (2m-k)!) / ((2m)! * k! * (m-k)!)\n    \"\"\"\n    if m  0:\n        raise ValueError(\"Order m must be a non-negative integer.\")\n    p_coeffs = np.zeros(m + 1, dtype=float)\n    q_coeffs = np.zeros(m + 1, dtype=float)\n    \n    fact_m = math.factorial(m)\n    fact_2m = math.factorial(2 * m)\n\n    for k in range(m + 1):\n        # Coefficients for p_m(z)\n        coeff_val = (fact_m * math.factorial(2 * m - k)) / \\\n                    (fact_2m * math.factorial(k) * math.factorial(m - k))\n        p_coeffs[m - k] = coeff_val\n        # Coefficients for q_m(z) = p_m(-z)\n        q_coeffs[m - k] = ((-1)**k) * coeff_val\n        \n    return p_coeffs, q_coeffs\n\ndef get_pade_partial_fractions(m):\n    \"\"\"\n    Computes the partial fraction expansion of the (m,m) Padé approximant to exp(z).\n    Returns c0, poles (zeta), and residues (alpha).\n    \"\"\"\n    if m == 0:\n        return 1.0, np.array([]), np.array([])\n        \n    p_coeffs, q_coeffs = get_pade_coeffs(m)\n    \n    # Constant c0 from polynomial long division (ratio of leading coefficients)\n    c0 = p_coeffs[0] / q_coeffs[0] # This equals (-1)^m\n    \n    # Poles are the roots of the denominator polynomial q_m(z)\n    poles = np.roots(q_coeffs)\n    \n    # Residues alpha_j = s_m(zeta_j) / q'_m(zeta_j)\n    # where s_m(z) = p_m(z) - c0*q_m(z) is the remainder. Or, p_m(z)/q'_m(z) since q_m(zeta_j)=0\n    q_prime_coeffs = np.polyder(q_coeffs)\n    \n    p_at_poles = np.polyval(p_coeffs, poles)\n    q_prime_at_poles = np.polyval(q_prime_coeffs, poles)\n    \n    residues = p_at_poles / q_prime_at_poles\n    \n    return c0, poles, residues\n\ndef pade_approx_action(A, b, m):\n    \"\"\"\n    Computes y = r_m,m(A)b using partial fraction expansion.\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return np.array([])\n        \n    c0, poles, residues = get_pade_partial_fractions(m)\n    \n    # Initialize result vector (must be complex)\n    y = c0 * b.astype(np.complex128)\n    \n    A_complex = A.astype(np.complex128)\n    \n    for pole, res in zip(poles, residues):\n        # Construct the shifted sparse matrix\n        M = A_complex - pole * identity(n, format='csc', dtype=np.complex128)\n        \n        # Solve the shifted linear system\n        x = spsolve(M, b)\n        \n        # Accumulate the result\n        y += res * x\n        \n    # For real A and b, the imaginary part should be close to zero\n    return y.real\n\ndef calculate_speedup(n, nnz, K):\n    \"\"\"\n    Calculates the theoretical speedup S = T_CPU / T_GPU based on the problem's model.\n    \"\"\"\n    # Model constants\n    a_c, b_c, c_c = 8e-9, 5e-8, 2e-9\n    a_g, b_g, c_g = 1e-9, 8e-9, 5e-10\n    rho, sigma = 0.5, 0.3\n\n    if n == 0:\n      return 1.0\n    \n    sqrt_n = math.sqrt(n)\n    \n    # CPU Time\n    T_cpu = K * nnz * (a_c + b_c * sqrt_n + c_c)\n    \n    # GPU Time\n    T_gpu = nnz * (a_g + K * (rho * b_g * sqrt_n + sigma * c_g))\n\n    if T_gpu == 0:\n        return float('inf') if T_cpu > 0 else 1.0\n\n    return T_cpu / T_gpu\n\ndef solve():\n    \"\"\"\n    Main solver function to execute all tasks for the given test cases.\n    \"\"\"\n    test_cases = [\n        (40, 0.10, 6, 12345),\n        (1, 0.00, 4, 2024),\n        (60, 0.08, 8, 31415),\n    ]\n\n    results = []\n    \n    for n, alpha, m, seed in test_cases:\n        # Set up matrix A and vector b\n        np.random.seed(seed)\n        if n > 0:\n             b = np.random.randn(n)\n             if n == 1:\n                 L_n = diags([2], [0], shape=(1, 1), format='csc')\n                 nnz = 1\n             else:\n                 L_n = diags([-1, 2, -1], [-1, 0, 1], shape=(n, n), format='csc')\n                 nnz = 3 * n - 2\n             A = -alpha * L_n\n        else: # Handle n=0 edge case if needed\n            A = diags([],[], shape=(0,0), format='csc')\n            b = np.array([])\n            nnz = 0\n            \n        # 1. Compute approximation using Padé method\n        y_approx = pade_approx_action(A, b, m)\n\n        # 2. Compute reference solution\n        if n > 0:\n            y_ref = expm_multiply(A, b)\n        else:\n            y_ref = np.array([])\n\n        # 3. Calculate relative error\n        norm_y_ref = np.linalg.norm(y_ref)\n        if norm_y_ref > 0:\n            error = np.linalg.norm(y_approx - y_ref) / norm_y_ref\n        elif np.linalg.norm(y_approx) > 0:\n            error = float('inf')\n        else:\n            error = 0.0\n\n        # 4. Calculate predicted speedup\n        K = m\n        speedup = calculate_speedup(n, nnz, K)\n\n        results.extend([error, speedup])\n\n    # Format output as specified\n    formatted_results = [f\"{val:.8f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的练习将探讨一个更高级、接近研究前沿的问题：给定一个矩阵 $A$，我们如何选择*最佳*的帕德近似？本练习  将引导你完成一个自适应选择过程。其核心思想是利用矩阵的数值范围 $W(A)$ 在复平面上确定一个必须保证近似精度的区域，然后从一个候选集合中选择在该区域上误差最小的帕德近似。这个过程融合了近似理论、复分析和矩阵分析的概念，展示了现代矩阵函数软件中使用的复杂方法。",
            "id": "3564070",
            "problem": "您的任务是设计并实现一个自适应程序，用于选择一个帕德近似阶数，该近似在包含数值范围的椭圆上一致逼近复指数函数。此任务的基础由以下来自数值线性代数和复分析的经过充分检验的定义和事实构成。\n\n- 矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的数值范围（也称为值域）是 $W(A) = \\{ x^{*} A x : x \\in \\mathbb{C}^{n}, \\|x\\|_{2} = 1 \\}$。它是一个凸集。如果 $H = (A + A^{*}) / 2$ 和 $K = (A - A^{*}) / (2 i)$ 分别是 $A$ 的埃尔米特部分和反埃尔米特部分，那么对于任何单位向量 $x$，$\\operatorname{Re}(x^{*} A x) = x^{*} H x$ 且 $\\operatorname{Im}(x^{*} A x) = x^{*} K x$。因此，$W(A)$ 在实轴上的投影位于区间 $[\\lambda_{\\min}(H), \\lambda_{\\max}(H)]$ 内，在虚轴上的投影位于 $[\\lambda_{\\min}(K), \\lambda_{\\max}(K)]$ 内，其中 $\\lambda_{\\min}(\\cdot)$ 和 $\\lambda_{\\max}(\\cdot)$ 分别表示埃尔米特矩阵的最小和最大特征值。\n\n- 复指数函数 $e^{z}$ 是整函数（在 $\\mathbb{C}$ 上解析）。一个帕德近似 $r_{m,n}(z)$ 是一个有理函数，其分子次数最多为 $m$，分母次数最多为 $n$，其构造旨在使 $e^{z}$ 的麦克劳林级数匹配到尽可能高的阶数。\n\n您的目标是根据上述区间构建一个包含 $W(A)$ 的轴对齐椭圆 $\\mathcal{E}$，然后从预定的候选集合中自适应地选择整数 $m, n \\in \\mathbb{N}$，以最小化标量复指数函数由 $r_{m,n}$ 在 $\\mathcal{E}$ 上的一致逼近误差。一致误差目标是\n$$\n\\max_{z \\in \\mathcal{E}} \\left| e^{z} - r_{m,n}(z) \\right|.\n$$\n\n设计约束如下：\n\n- 使用给定矩阵 $A$ 的埃尔米特部分 $H$ 和反埃尔米特部分 $K$ 来通过区间界定 $\\operatorname{Re}(W(A))$ 和 $\\operatorname{Im}(W(A))$。令 $a = (\\lambda_{\\max}(H) - \\lambda_{\\min}(H))/2$，$b = (\\lambda_{\\max}(K) - \\lambda_{\\min}(K))/2$，中心为 $c = \\left( \\lambda_{\\min}(H) + \\lambda_{\\max}(H) \\right)/2 + i \\left( \\lambda_{\\min}(K) + \\lambda_{\\max}(K) \\right)/2$。构建半轴为 $\\alpha = \\sqrt{2} \\, a$ 和 $\\beta = \\sqrt{2} \\, b$、中心为 $c$ 的轴对齐椭圆，其参数化定义为 $z(\\theta) = c + \\alpha \\cos \\theta + i \\, \\beta \\sin \\theta$，其中 $\\theta \\in [0, 2\\pi)$。该椭圆包含矩形 $[\\lambda_{\\min}(H), \\lambda_{\\max}(H)] + i[\\lambda_{\\min}(K), \\lambda_{\\max}(K)]$，因此也包含 $W(A)$。\n\n- 严格从 $e^{z}$ 的麦克劳林级数系数（即 $c_{k} = 1/k!$）出发，使用帕德定义的 V 关系来构造 $r_{m,n}(z)$，不假设任何预先制表的特殊情况：$r_{m,n}$ 必须通过强制 $e^{z} q(z) - p(z)$ 的泰勒展开式中从 $z^{m+1}$ 到 $z^{m+n}$ 的系数为零来推导，其中 $q(0) = 1$，$\\deg(p) \\le m$，且 $\\deg(q) \\le n$。\n\n- 通过在 $\\mathcal{E}$ 的边界上采样点来近似一致误差；根据所涉及的解析性质来证明您的采样选择是合理的。确保在任一半轴为零（使 $\\mathcal{E}$ 退化为线段或点）时能够进行稳健处理。\n\n- 从给定的有限候选对集合 $\\mathcal{S}$ 中，选择使 $\\mathcal{E}$ 上的近似一致误差最小化的对 $(m,n)$。\n\n为以下测试套件中的每个矩阵实现一个执行此自适应选择的完整程序。不允许外部输入；程序必须在内部定义测试用例。测试套件如下：\n\n- 测试用例 1：$A_{1} = \\begin{bmatrix} 0  4  -1 \\\\ 0  -2  2 \\\\ 1  0  1 \\end{bmatrix} + i \\begin{bmatrix} 0  0.5  0 \\\\ -0.5  0  0.25 \\\\ 0  -0.25  0 \\end{bmatrix}$。\n\n- 测试用例 2：$A_{2} = \\begin{bmatrix} 2  -1  0 \\\\ -1  2  -1 \\\\ 0  -1  2 \\end{bmatrix}$。\n\n- 测试用例 3：$A_{3} = i \\begin{bmatrix} 0  2  0 \\\\ -2  0  3 \\\\ 0  -3  0 \\end{bmatrix}$。\n\n- 测试用例 4：$A_{4} = \\begin{bmatrix} 5  10  0 \\\\ -3  -7  4 \\\\ 0  1  0 \\end{bmatrix} + i \\begin{bmatrix} 0  0  6 \\\\ 0  0  0 \\\\ -6  0  0 \\end{bmatrix}$。\n\n使用候选集 $\\mathcal{S} = \\{ (2,2), (3,3), (4,4), (5,5), (6,6), (7,7), (8,8), (4,6), (6,4) \\}$，并通过在参数 $\\theta \\in [0, 2\\pi)$ 上均匀间隔采样 $N = 512$ 个点来近似椭圆边界上的一致误差。如果两个半轴都为零，则在 $z = c$ 处取 $N = 1$ 个点。\n\n对于每个测试用例，您的程序必须输出使近似一致误差最小化的所选对 $[m,n]$。最终输出格式必须是包含结果的单行，结果为方括号括起来的逗号分隔列表，其中每个元素是表示一个测试用例的、由两个整数组成的列表。例如，格式应为 $[[m_{1},n_{1}], [m_{2},n_{2}], [m_{3},n_{3}], [m_{4},n_{4}]]$。不得打印其他文本或行。",
            "solution": "我们从数值范围和帕德近似的定义与性质开始。对于一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$，其数值范围为 $W(A) = \\{ x^{*} A x : x \\in \\mathbb{C}^{n}, \\|x\\|_{2} = 1 \\}$。将 $A$ 写为 $A = H + i K$，其中 $H = (A + A^{*})/2$ 和 $K = (A - A^{*})/(2 i)$ 是埃尔米特矩阵，我们有对于任何单位向量 $x$，$\\operatorname{Re}(x^{*} A x) = x^{*} H x$ 且 $\\operatorname{Im}(x^{*} A x) = x^{*} K x$。瑞利商的特性意味着 $x^{*} H x \\in [\\lambda_{\\min}(H), \\lambda_{\\max}(H)]$ 且 $x^{*} K x \\in [\\lambda_{\\min}(K), \\lambda_{\\max}(K)]$，因此 $W(A)$ 位于轴对齐的矩形内\n$$\n[\\lambda_{\\min}(H), \\lambda_{\\max}(H)] + i \\, [\\lambda_{\\min}(K), \\lambda_{\\max}(K)].\n$$\n令 $a = (\\lambda_{\\max}(H) - \\lambda_{\\min}(H))/2$ 和 $b = (\\lambda_{\\max}(K) - \\lambda_{\\min}(K))/2$，中心为\n$$\nc = \\frac{\\lambda_{\\min}(H) + \\lambda_{\\max}(H)}{2} + i \\, \\frac{\\lambda_{\\min}(K) + \\lambda_{\\max}(K)}{2}.\n$$\n我们通过选择半轴 $\\alpha = \\sqrt{2} \\, a$ 和 $\\beta = \\sqrt{2} \\, b$ 来构建一个包含此矩形的轴对齐椭圆 $\\mathcal{E}$，并通过以下方式参数化其边界\n$$\nz(\\theta) = c + \\alpha \\cos \\theta + i \\, \\beta \\sin \\theta, \\quad \\theta \\in [0, 2\\pi).\n$$\n为了证明该椭圆包含此矩形，考虑矩形相对于其中心的任意一个角点：其坐标为 $(\\pm a, \\pm b)$。在缩放的椭圆坐标中，二次型的计算结果为\n$$\n\\frac{(\\pm a)^{2}}{\\alpha^{2}} + \\frac{(\\pm b)^{2}}{\\beta^{2}} = \\frac{a^{2}}{2 a^{2}} + \\frac{b^{2}}{2 b^{2}} = \\frac{1}{2} + \\frac{1}{2} = 1,\n$$\n这说明矩形的角点位于椭圆边界上；因此，整个矩形位于椭圆内部或边界上。\n\n接下来，我们回顾复指数函数的帕德近似 $r_{m,n}$ 的构造。令 $f(z) = e^{z} = \\sum_{k=0}^{\\infty} c_{k} z^{k}$，其中 $c_{k} = 1/k!$。类型为 $(m,n)$ 的帕德近似是一个有理函数 $r_{m,n}(z) = p(z)/q(z)$，其中 $\\deg(p) \\le m$，$\\deg(q) \\le n$，且 $q(0) = 1$，使得 $f(z) q(z) - p(z)$ 的麦克劳林级数中从 $z^{m+1}$ 到 $z^{m+n}$ 的系数为零。令 $q(z) = 1 + q_{1} z + \\cdots + q_{n} z^{n}$。$f(z) q(z)$ 中 $z^{k}$ 的系数为 $\\sum_{j=0}^{\\min(k,n)} q_{j} c_{k-j}$，其中 $q_{0} = 1$。强制 $k = m+1, \\ldots, m+n$ 的系数为零，得到线性系统\n$$\n\\sum_{j=1}^{n} c_{m+i-j} \\, q_{j} = - c_{m+i}, \\quad i = 1,2,\\ldots,n.\n$$\n解出 $(q_{1}, \\ldots, q_{n})$ 即可得到分母系数以及 $q_{0} = 1$。分子系数则通过将 $f(z) q(z)$ 截断至 $m$ 次幂来恢复：\n$$\np_{k} = \\sum_{j=0}^{\\min(k,n)} q_{j} c_{k-j}, \\quad k = 0,1,\\ldots,m.\n$$\n这种构造直接源于帕德近似的定义条件和麦克劳林级数，无需借助任何特殊情况的快捷方式。\n\n我们现在定义 $r_{m,n}$ 对 $e^{z}$ 在椭圆 $\\mathcal{E}$ 上的一致逼近误差：\n$$\nE_{m,n} = \\max_{z \\in \\mathcal{E}} \\left| e^{z} - r_{m,n}(z) \\right|.\n$$\n根据解析函数的最大模原理，如果 $r_{m,n}$ 在 $\\mathcal{E}$ 内部或边界上没有极点，则在由 $\\mathcal{E}$ 界定的紧致、单连通区域上，$\\left| e^{z} - r_{m,n}(z) \\right|$ 的最大值出现在其边界上。即使极点存在于椭圆外部但靠近椭圆的位置，对边界进行采样也为该区域上的一致误差提供了一个合理的数值代理。因此，我们通过在 $[0, 2\\pi)$ 上对 $\\theta$ 进行均匀采样，并计算椭圆边界上采样点的最大逐点误差来近似 $E_{m,n}$。稳健性考虑包括通过在 $|q(z)|$ 低于一个小阈值时声明一个大误差来防止采样点上 $q(z)$ 的值接近于零，确保在评估 $r_{m,n}$ 时潜在的数值不稳定性不会误导选择。\n\n对于 $\\alpha = 0$ 和/或 $\\beta = 0$ 的退化情况，椭圆会塌缩为一条线段或一个单点。参数化 $z(\\theta) = c + \\alpha \\cos \\theta + i \\, \\beta \\sin \\theta$ 仍然能生成正确的边界点。如果 $\\alpha = 0$ 和 $\\beta = 0$ 都成立，集合 $\\mathcal{E}$ 就是点 $\\{c\\}$，我们只在 $z = c$ 处采样。\n\n自适应选择程序如下：\n\n- 对于给定的 $A$，计算 $H = (A + A^{*})/2$ 和 $K = (A - A^{*})/(2 i)$。\n\n- 计算 $\\lambda_{\\min}(H)$、$\\lambda_{\\max}(H)$、$\\lambda_{\\min}(K)$ 和 $\\lambda_{\\max}(K)$。\n\n- 构造 $a$、 $b$、 $c$ 以及 $\\alpha = \\sqrt{2} a$、 $\\beta = \\sqrt{2} b$。\n\n- 对于候选集 $\\mathcal{S}$ 中的每个 $(m,n)$，利用麦克劳林级数系数 $c_{k} = 1/k!$ 通过帕德定义系统构造 $r_{m,n}(z)$，在椭圆边界上评估采样的一致误差，并记录最大误差。\n\n- 选择使记录的最大误差最小的 $(m,n)$。\n\n该程序为四个规定的测试矩阵实现了此选择过程。对于每个测试用例，它会输出所选的 $[m,n]$ 对。最终输出为单一格式的行：\n$$\n[[m_{1},n_{1}], [m_{2},n_{2}], [m_{3},n_{3}], [m_{4},n_{4}]],\n$$\n不带任何额外的行或文本。此方法遵循了数值范围和帕德近似的核心定义，并应用了经过充分检验的原理，从而得出了一个用于矩阵函数有理逼近中自适应阶数选择的实用算法。",
            "answer": "```python\nimport numpy as np\n\ndef pade_exp_coeffs(m: int, n: int):\n    \"\"\"\n    Construct the Pade approximant [m/n] to exp(z) from its Maclaurin series.\n    Returns numerator and denominator coefficients in ascending powers.\n    \"\"\"\n    # Series coefficients c_k = 1/k! up to m+n\n    total_deg = m + n\n    c = np.empty(total_deg + 1, dtype=np.float64)\n    c[0] = 1.0\n    for k in range(1, total_deg + 1):\n        c[k] = c[k - 1] / k  # 1/k! via recursion\n\n    if n == 0:\n        # Pure polynomial case: numerator is truncated series, denominator is 1\n        p = c[:m + 1].copy()\n        q = np.array([1.0], dtype=np.float64)\n        return p, q\n\n    # Build linear system for q1..qn enforcing vanishing of coefficients m+1..m+n\n    # Sum_{j=1..n} c[m+i - j] q_j = -c[m+i], for i=1..n\n    A = np.empty((n, n), dtype=np.float64)\n    b = np.empty(n, dtype=np.float64)\n    for i in range(1, n + 1):\n        b[i - 1] = -c[m + i]\n        for j in range(1, n + 1):\n            A[i - 1, j - 1] = c[m + i - j]\n    # Solve for q1..qn\n    try:\n        q_tail = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Ill-conditioned or singular; fallback to least squares\n        q_tail, *_ = np.linalg.lstsq(A, b, rcond=None)\n    q = np.concatenate(([1.0], q_tail))\n\n    # Numerator p_k = sum_{j=0..min(k,n)} q_j * c[k-j], for k=0..m\n    p = np.empty(m + 1, dtype=np.float64)\n    for k in range(0, m + 1):\n        jmax = min(k, n)\n        s = 0.0\n        for j in range(0, jmax + 1):\n            s += q[j] * c[k - j]\n        p[k] = s\n\n    return p, q\n\ndef eval_rational(p_coefs_asc, q_coefs_asc, z):\n    \"\"\"\n    Evaluate r(z) = p(z)/q(z) where p and q are given by ascending-power coefficients.\n    z may be scalar or vector (numpy).\n    \"\"\"\n    # Convert to descending-power order for numpy.polyval\n    p_desc = p_coefs_asc[::-1]\n    q_desc = q_coefs_asc[::-1]\n    # Use numpy.polyval for complex z\n    pz = np.polyval(p_desc, z)\n    qz = np.polyval(q_desc, z)\n    return pz / qz, qz\n\ndef ellipse_params_from_matrix(A):\n    \"\"\"\n    Compute ellipse parameters (center c, semiaxes alpha, beta) that enclose W(A),\n    using bounds from Hermitian and skew-Hermitian parts.\n    \"\"\"\n    H = (A + A.conj().T) / 2.0\n    K = (A - A.conj().T) / (2.0j)\n    # Eigenvalues of Hermitian matrices are real\n    lamH = np.linalg.eigvalsh(H)\n    lamK = np.linalg.eigvalsh(K)\n    lamH_min = np.min(lamH).real\n    lamH_max = np.max(lamH).real\n    lamK_min = np.min(lamK).real\n    lamK_max = np.max(lamK).real\n    a = (lamH_max - lamH_min) / 2.0\n    b = (lamK_max - lamK_min) / 2.0\n    c = (lamH_min + lamH_max) / 2.0 + 1j * (lamK_min + lamK_max) / 2.0\n    alpha = np.sqrt(2.0) * a\n    beta = np.sqrt(2.0) * b\n    return c, alpha, beta\n\ndef max_uniform_error_on_ellipse(m, n, c, alpha, beta, N=512, q_eps=1e-14):\n    \"\"\"\n    Approximate max_{z in ellipse} |exp(z) - r_{m,n}(z)| by sampling N points on ellipse boundary.\n    If both semiaxes are zero, sample the single point z=c.\n    \"\"\"\n    p, q = pade_exp_coeffs(m, n)\n    if alpha == 0.0 and beta == 0.0:\n        z = np.array([c], dtype=np.complex128)\n    else:\n        thetas = np.linspace(0.0, 2.0 * np.pi, num=N, endpoint=False, dtype=np.float64)\n        z = c + alpha * np.cos(thetas) + 1j * beta * np.sin(thetas)\n    rz, qz = eval_rational(p, q, z)\n    ez = np.exp(z)\n    # Guard against near-zero denominator\n    mask_bad = np.abs(qz)  q_eps\n    err = np.abs(ez - rz)\n    if np.any(mask_bad):\n        # Assign a large penalty to points near poles\n        err[mask_bad] = np.inf\n    return float(np.max(err))\n\ndef adaptive_select_pade_order(A, candidates, N=512):\n    c, alpha, beta = ellipse_params_from_matrix(A)\n    best_pair = None\n    best_err = np.inf\n    for (m, n) in candidates:\n        err = max_uniform_error_on_ellipse(m, n, c, alpha, beta, N=N)\n        if err  best_err:\n            best_err = err\n            best_pair = (m, n)\n    return best_pair\n\ndef solve():\n    # Define test cases matrices (complex where specified)\n    A1_real = np.array([[0.0, 4.0, -1.0],\n                        [0.0, -2.0, 2.0],\n                        [1.0, 0.0, 1.0]], dtype=np.float64)\n    A1_imag = np.array([[0.0, 0.5, 0.0],\n                        [-0.5, 0.0, 0.25],\n                        [0.0, -0.25, 0.0]], dtype=np.float64)\n    A1 = A1_real + 1j * A1_imag\n\n    A2 = np.array([[2.0, -1.0, 0.0],\n                   [-1.0, 2.0, -1.0],\n                   [0.0, -1.0, 2.0]], dtype=np.float64)\n\n    A3_base = np.array([[0.0, 2.0, 0.0],\n                        [-2.0, 0.0, 3.0],\n                        [0.0, -3.0, 0.0]], dtype=np.float64)\n    A3 = 1j * A3_base\n\n    A4_real = np.array([[5.0, 10.0, 0.0],\n                        [-3.0, -7.0, 4.0],\n                        [0.0, 1.0, 0.0]], dtype=np.float64)\n    A4_imag = np.array([[0.0, 0.0, 6.0],\n                        [0.0, 0.0, 0.0],\n                        [-6.0, 0.0, 0.0]], dtype=np.float64)\n    A4 = A4_real + 1j * A4_imag\n\n    test_cases = [A1, A2, A3, A4]\n\n    candidates = [(2, 2), (3, 3), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (4, 6), (6, 4)]\n    N = 512\n\n    results = []\n    for A in test_cases:\n        m, n = adaptive_select_pade_order(A, candidates, N=N)\n        results.append([m, n])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}