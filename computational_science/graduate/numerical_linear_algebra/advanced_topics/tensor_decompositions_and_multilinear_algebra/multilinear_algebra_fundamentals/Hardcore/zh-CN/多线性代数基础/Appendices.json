{
    "hands_on_practices": [
        {
            "introduction": "要熟练掌握多线性代数，首先必须精通其基本运算规则。本练习旨在检验您对张量-矩阵乘积（TTM）和张量展开（unfolding）这两种核心操作的理解。通过计算这些操作后张量的维度 ，您将巩固对多线性代数“语法”的掌握，为解决更复杂的问题打下坚实的基础。",
            "id": "3561343",
            "problem": "设 $X \\in \\mathbb{R}^{3 \\times 4 \\times 2}$ 是一个三阶张量，设 $U \\in \\mathbb{R}^{5 \\times 3}$ 是一个矩阵。定义模式-1张量-乘以-矩阵（TTM）积为 $Y = X \\times_{1} U$，其中乘法沿着 $X$ 的第一个模式进行，通过用 $U$ 左乘每个模式-1纤维来实现。采用 Kolda–Bader 惯例进行模式-n 展开（列是模式-n 纤维），并用 $Y_{(3)}$ 表示 $Y$ 的模式-3 展开。仅使用张量、纤维、切片、模式-n 积和模式-n 展开的基本定义，确定 $Y$ 的维度和 $Y_{(3)}$ 的维度。将您的最终答案表示为一个单行矩阵，按顺序列出 $Y$ 的三个维度，然后是 $Y_{(3)}$ 的两个维度。无需四舍五入。",
            "solution": "用户希望我按照以下步骤解决问题：\n1.  首先，验证问题。\n2.  如果有效，则解决它。\n3.  如果无效，则解释原因。\n\n以下是问题的验证过程。\n\n### 步骤 1：提取已知条件\n- 一个三阶张量 $X \\in \\mathbb{R}^{3 \\times 4 \\times 2}$。\n- 一个矩阵 $U \\in \\mathbb{R}^{5 \\times 3}$。\n- 运算是模式-1张量-乘以-矩阵（TTM）积，$Y = X \\times_{1} U$。\n- 乘法定义为用 $U$ 左乘每个模式-1纤维。\n- 采用 Kolda–Bader 惯例进行模式-n 展开，其中列是模式-n 纤维。\n- $Y_{(3)}$ 表示 $Y$ 的模式-3 展开。\n- 目标是确定 $Y$ 的维度和 $Y_{(3)}$ 的维度。\n- 答案格式是一个单行矩阵，包含 $Y$ 的三个维度，后跟 $Y_{(3)}$ 的两个维度。\n\n### 步骤 2：使用提取的已知条件进行验证\n针对验证标准检查该问题。\n- **科学依据**：该问题基于多重线性代数中的基本且明确定义的概念，即张量、张量-乘以-矩阵（TTM）积和张量展开（矩阵化）。这些是数值线性代数和数据分析中的标准主题。\n- **适定性**：该问题是适定的。张量 $X$ 和矩阵 $U$ 的维度已指定。TTM 积 $X \\times_{1} U$ 是明确定义的，因为 $X$ 的第一个模式的大小（为 3）与 $U$ 的列数（也为 3）匹配。Kolda-Bader 的展开惯例是一个标准的、无歧义的定义。因此，存在唯一且有意义的解。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或歧义。\n\n该问题没有表现出所列的任何缺陷：\n1.  **科学或事实不健全**：没有违反数学逻辑。TTM 积的维度兼容性得到满足。\n2.  **不可形式化或不相关**：该问题是一个可形式化的问题，直接关系到指定的多重线性代数基础主题。\n3.  **不完整或矛盾的设置**：提供了所有必要的信息。\n4.  **不切实际或不可行**：不适用，因为这是一个纯粹的数学问题。\n5.  **不适定或结构不良**：定义是标准的且无歧义的。\n6.  **伪深刻、琐碎或同义反复**：虽然该问题是定义的运用，但它需要对概念的正确理解，并非微不足道。\n7.  **超出科学可验证性**：不适用。\n\n### 步骤 3：结论和行动\n问题是**有效的**。将提供完整的解决方案。\n\n***\n\n问题要求我们确定由张量-乘以-矩阵（TTM）积产生的张量 $Y$ 的维度，然后找出 $Y$ 的模式-3 展开的维度。\n\n设张量 $X$ 的维度为 $I_1 \\times I_2 \\times I_3$。根据问题陈述，我们有 $X \\in \\mathbb{R}^{3 \\times 4 \\times 2}$，所以 $I_1 = 3$, $I_2 = 4$, $I_3 = 2$。\n设矩阵 $U$ 的维度为 $J \\times K$。根据问题陈述，我们有 $U \\in \\mathbb{R}^{5 \\times 3}$，所以 $J = 5$, $K = 3$。\n\n**第 1 部分：确定 $Y$ 的维度**\n\n张量 $Y$ 由与矩阵 $U$ 的模式-1 TTM 积定义：\n$$Y = X \\times_{1} U$$\n张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\dots \\times I_n \\times \\dots \\times I_N}$ 与矩阵 $U \\in \\mathbb{R}^{J \\times I_n}$ 的模式-n 积产生一个张量 $\\mathcal{Y} \\in \\mathbb{R}^{I_1 \\times \\dots \\times I_{n-1} \\times J \\times I_{n+1} \\times \\dots \\times I_N}$。该运算将第 n 模式的维度 $I_n$ 替换为矩阵 $U$ 的维度 $J$。\n\n在我们的例子中，$n=1$。张量 $X$ 的维度是 $I_1 \\times I_2 \\times I_3$，矩阵 $U$ 的维度是 $J \\times I_1$。要使该乘积有明确定义，条件是 $U$ 的列数必须等于 $X$ 的第一个模式的大小。此处，$U$ 的列数是 $K=3$，$X$ 的第一个模式的大小是 $I_1=3$。由于 $K=I_1$，该运算是明确定义的。\n\n结果张量 $Y$ 的维度将是 $J \\times I_2 \\times I_3$。\n代入给定值：\n- $Y$ 的第一个维度是 $J = 5$。\n- $Y$ 的第二个维度是 $I_2 = 4$。\n- $Y$ 的第三个维度是 $I_3 = 2$。\n\n因此，张量 $Y$ 属于 $\\mathbb{R}^{5 \\times 4 \\times 2}$，其维度是 $(5, 4, 2)$。\n\n**第 2 部分：确定 $Y_{(3)}$ 的维度**\n\n符号 $Y_{(3)}$ 表示张量 $Y$ 的模式-3 展开。张量 $Y \\in \\mathbb{R}^{5 \\times 4 \\times 2}$ 的维度可以表示为 $J_1 \\times J_2 \\times J_3$，其中 $J_1 = 5$, $J_2 = 4$, $J_3 = 2$。\n\n张量 $\\mathcal{Y} \\in \\mathbb{R}^{J_1 \\times J_2 \\times \\dots \\times J_N}$ 的模式-n 展开是一个矩阵，记为 $\\mathcal{Y}_{(n)}$，它重塑了张量的元素。根据 Kolda–Bader 惯例，矩阵 $\\mathcal{Y}_{(n)}$ 的列是张量 $\\mathcal{Y}$ 的模式-n 纤维。\n\n模式-n 纤维是通过固定除第 n 个索引之外的所有索引而获得的向量。对于三阶张量 $Y \\in \\mathbb{R}^{J_1 \\times J_2 \\times J_3}$，一个模式-3 纤维是一个长度为 $J_3$ 的列向量，通过固定前两个索引获得，即对于某个固定的 $j_1$ 和 $j_2$ 的 $Y_{j_1, j_2, :}$。\n\n模式-3 展开 $Y_{(3)}$ 将这些模式-3 纤维排列为其列。\n- $Y_{(3)}$ 的行数是每个模式-3 纤维的长度，也就是 $Y$ 的第 3 个模式的大小。这个大小是 $J_3 = 2$。\n- $Y_{(3)}$ 的列数是模式-3 纤维的总数。这由其他索引的可能组合数决定，即其他模式大小的乘积。在这种情况下，它是 $J_1 \\times J_2$。\n\n所以，矩阵 $Y_{(3)}$ 的维度是 $J_3 \\times (J_1 \\times J_2)$。\n代入 $Y$ 的维度：\n- 行数是 $J_3 = 2$。\n- 列数是 $J_1 \\times J_2 = 5 \\times 4 = 20$。\n\n因此，矩阵 $Y_{(3)}$ 属于 $\\mathbb{R}^{2 \\times 20}$，其维度是 $(2, 20)$。\n\n**结论**\n\n张量 $Y$ 的三个维度是 $5, 4, 2$。\n矩阵 $Y_{(3)}$ 的两个维度是 $2, 20$。\n问题要求将最终答案表示为一个单行矩阵，按顺序列出这五个数字。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5  4  2  2  20\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "张量展开不仅仅是元素简单的重新排列；其固有的排序规则蕴含着深刻的结构信息。本练习将引导您探索一个看似矛盾的现象：两个拥有完全相同切片集合的张量，其展开形式却可能截然不同。通过构建这样一个例子 ，您将揭示展开过程如何将张量的全局结构（如切片顺序）编码为矩阵列的置换，从而深化对张量与其矩阵化表示之间关系的理解。",
            "id": "3561306",
            "problem": "设 $X \\in \\mathbb{R}^{I \\times J \\times K}$ 是一个三阶张量。一个模式-$n$ 纤维是通过固定除第 $n$ 个索引外的所有索引得到的；例如，$X$ 的一个模式-1 纤维是在固定 $j$ 和 $k$ 时的 $X(:,j,k) \\in \\mathbb{R}^{I}$。一个模式-3 切片（也称为正面切片）是通过固定第三个索引 $k$ 得到的矩阵 $X(:,:,k) \\in \\mathbb{R}^{I \\times J}$。模式-1 展开（也称为矩阵化）$X_{(1)} \\in \\mathbb{R}^{I \\times JK}$ 的定义是将所有模式-1 纤维 $X(:,j,k)$ 按索引对 $(j,k)$ 的字典序列出作为 $X_{(1)}$ 的列，其中 $j$ 变化最快：也就是说，列的顺序是 $(j,k) = (1,1),(2,1),\\dots,(J,1),(1,2),(2,2),\\dots,(J,K)$。\n\n考虑张量 $X \\in \\mathbb{R}^{2 \\times 3 \\times 2}$，其正面切片为\n$$\nX(:,:,1) \\;=\\; \\begin{pmatrix} 1  4  7 \\\\ 2  5  8 \\end{pmatrix}, \n\\qquad\nX(:,:,2) \\;=\\; \\begin{pmatrix} 3  6  9 \\\\ 0  1  2 \\end{pmatrix}.\n$$\n通过重排 $X$ 的模式-3 切片来定义 $Y \\in \\mathbb{R}^{2 \\times 3 \\times 2}$：\n$$\nY(:,:,1) \\;=\\; X(:,:,2), \\qquad Y(:,:,2) \\;=\\; X(:,:,1).\n$$\n因此，$X$ 和 $Y$ 具有相同的模式-3 切片集合，但它们沿第三个索引的顺序不同。\n\n1. 使用上面指定的字典序纤维排序规则，明确写出模式-1 展开 $X_{(1)}$ 和 $Y_{(1)}$。\n2. 证明存在唯一的列置换矩阵 $\\Pi \\in \\mathbb{R}^{JK \\times JK}$ 使得 $Y_{(1)} = X_{(1)} \\Pi$，并明确指出 $\\Pi$。\n3. 计算 $\\det(\\Pi)$。\n\n在你的推导过程中，解释模式-1 展开中的纤维排序如何编码了在仅比较模式-3 切片集合时不能直接看到的隐式置换。将你的最终答案表示为一个没有单位的实数。不需要四舍五入。",
            "solution": "该问题要求我们分析置换三阶张量的切片对其模式-1 展开的影响。我们给定一个张量 $X \\in \\mathbb{R}^{I \\times J \\times K}$，其维度为 $I=2$, $J=3$, 和 $K=2$。其模式-3 切片（正面切片）被指定为：\n$$\nX(:,:,1) = \\begin{pmatrix} 1  4  7 \\\\ 2  5  8 \\end{pmatrix}, \\qquad X(:,:,2) = \\begin{pmatrix} 3  6  9 \\\\ 0  1  2 \\end{pmatrix}.\n$$\n第二个张量 $Y \\in \\mathbb{R}^{2 \\times 3 \\times 2}$ 是通过重排 $X$ 的模式-3 切片来定义的：\n$$\nY(:,:,1) = X(:,:,2) = \\begin{pmatrix} 3  6  9 \\\\ 0  1  2 \\end{pmatrix}, \\qquad Y(:,:,2) = X(:,:,1) = \\begin{pmatrix} 1  4  7 \\\\ 2  5  8 \\end{pmatrix}.\n$$\n这意味着张量的元素通过 $Y_{ijk} = X_{ij\\tau(k)}$ 相关联，其中 $\\tau$ 是第三个索引 $\\{1, 2\\}$ 上的一个置换，定义为 $\\tau(1)=2$ 和 $\\tau(2)=1$。虽然模式-3 切片的*集合* $\\{X(:,:,1), X(:,:,2)\\}$ 与集合 $\\{Y(:,:,1), Y(:,:,2)\\}$ 相同，但张量 $X$ 和 $Y$ 是不同的，因为这些切片以不同的顺序出现。\n\n我们的第一个任务是计算模式-1 展开 $X_{(1)}$ 和 $Y_{(1)}$。模式-1 展开 $X_{(1)}$ 是一个大小为 $I \\times (JK)$ 的矩阵，即 $2 \\times (3 \\times 2) = 2 \\times 6$。它的列是模式-1 纤维 $X(:,j,k)$，根据索引对 $(j,k)$ 的字典序排列，其中第一个索引 $j$ 变化最快。列的顺序由索引对 $(1,1), (2,1), (3,1), (1,2), (2,2), (3,2)$ 决定。\n\n我们来提取 $X$ 的模式-1 纤维：\n前 $J=3$ 个纤维来自切片 $k=1$：\n- 对应 $(j,k)=(1,1)$ 的纤维：$X(:,1,1) = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$\n- 对应 $(j,k)=(2,1)$ 的纤维：$X(:,2,1) = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$\n- 对应 $(j,k)=(3,1)$ 的纤维：$X(:,3,1) = \\begin{pmatrix} 7 \\\\ 8 \\end{pmatrix}$\n接下来 $J=3$ 个纤维来自切片 $k=2$：\n- 对应 $(j,k)=(1,2)$ 的纤维：$X(:,1,2) = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}$\n- 对应 $(j,k)=(2,2)$ 的纤维：$X(:,2,2) = \\begin{pmatrix} 6 \\\\ 1 \\end{pmatrix}$\n- 对应 $(j,k)=(3,2)$ 的纤维：$X(:,3,2) = \\begin{pmatrix} 9 \\\\ 2 \\end{pmatrix}$\n\n按指定顺序组合这些列向量，得到 $X$ 的模式-1 展开：\n$$\nX_{(1)} = \\begin{pmatrix} 1  4  7  3  6  9 \\\\ 2  5  8  0  1  2 \\end{pmatrix}\n$$\n\n接下来，我们使用相同的过程构造 $Y_{(1)}$。$Y$ 的模式-1 纤维是 $Y(:,j,k)$。根据 $Y$ 的定义，我们有 $Y(:,j,1) = X(:,j,2)$ 和 $Y(:,j,2) = X(:,j,1)$。\n$Y_{(1)}$ 的前 $J=3$ 个纤维来自其切片 $k=1$：\n- 对应 $(j,k)=(1,1)$ 的纤维：$Y(:,1,1) = X(:,1,2) = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}$\n- 对应 $(j,k)=(2,1)$ 的纤维：$Y(:,2,1) = X(:,2,2) = \\begin{pmatrix} 6 \\\\ 1 \\end{pmatrix}$\n- 对应 $(j,k)=(3,1)$ 的纤维：$Y(:,3,1) = X(:,3,2) = \\begin{pmatrix} 9 \\\\ 2 \\end{pmatrix}$\n$Y_{(1)}$ 的接下来 $J=3$ 个纤维来自其切片 $k=2$：\n- 对应 $(j,k)=(1,2)$ 的纤维：$Y(:,1,2) = X(:,1,1) = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix}$\n- 对应 $(j,k)=(2,2)$ 的纤维：$Y(:,2,2) = X(:,2,1) = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix}$\n- 对应 $(j,k)=(3,2)$ 的纤维：$Y(:,3,2) = X(:,3,1) = \\begin{pmatrix} 7 \\\\ 8 \\end{pmatrix}$\n\n组合这些纤维得到 $Y$ 的模式-1 展开：\n$$\nY_{(1)} = \\begin{pmatrix} 3  6  9  1  4  7 \\\\ 0  1  2  2  5  8 \\end{pmatrix}\n$$\n\n第二个任务是找到一个唯一的列置换矩阵 $\\Pi \\in \\mathbb{R}^{JK \\times JK} = \\mathbb{R}^{6 \\times 6}$，使得 $Y_{(1)} = X_{(1)} \\Pi$。\n通过比较 $Y_{(1)}$ 的列和 $X_{(1)}$ 的列，我们可以确定这个置换。设 $x_p$ 和 $y_q$ 分别是 $X_{(1)}$ 和 $Y_{(1)}$ 的第 $p$ 列和第 $q$ 列。\n- $y_1 = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix} = x_4$\n- $y_2 = \\begin{pmatrix} 6 \\\\ 1 \\end{pmatrix} = x_5$\n- $y_3 = \\begin{pmatrix} 9 \\\\ 2 \\end{pmatrix} = x_6$\n- $y_4 = \\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = x_1$\n- $y_5 = \\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} = x_2$\n- $y_6 = \\begin{pmatrix} 7 \\\\ 8 \\end{pmatrix} = x_3$\n\n这表明 $Y_{(1)}$ 的列是 $X_{(1)}$ 的列的一个置换。$X_{(1)}$ 的前 $J=3$ 列块（对应于切片 $X(:,:,1)$）移动成为 $Y_{(1)}$ 的第二个列块，而 $X_{(1)}$ 的第二个 $J=3$ 列块（来自切片 $X(:,:,2)$）成为 $Y_{(1)}$ 的第一个列块。这种列的重排就是“隐式置换”，它在只考虑切片集合时并不明显。展开过程中严格的纤维排序规则使得该操作对未展开模式上的切片顺序敏感。\n\n列索引的置换 $\\sigma: \\{1, ..., 6\\} \\to \\{1, ..., 6\\}$ 由从新位置到旧位置的映射给出：$y_q = x_{\\sigma(q)}$。\n$\\sigma(1) = 4, \\sigma(2) = 5, \\sigma(3) = 6, \\sigma(4) = 1, \\sigma(5) = 2, \\sigma(6) = 3$。\n置换矩阵 $\\Pi$ 的构造方式是，右乘 $\\Pi$ 会根据 $\\sigma$ 置换矩阵的列。这意味着 $\\Pi$ 的第 $q$ 列是标准基向量 $e_{\\sigma(q)}$。\n$$\n\\Pi = \\begin{pmatrix} e_{\\sigma(1)}  e_{\\sigma(2)}  e_{\\sigma(3)}  e_{\\sigma(4)}  e_{\\sigma(5)}  e_{\\sigma(6)} \\end{pmatrix} = \\begin{pmatrix} e_4  e_5  e_6  e_1  e_2  e_3 \\end{pmatrix}\n$$\n具体来说，这给出了 $6 \\times 6$ 矩阵：\n$$\n\\Pi = \\begin{pmatrix}\n0  0  0  1  0  0 \\\\\n0  0  0  0  1  0 \\\\\n0  0  0  0  0  1 \\\\\n1  0  0  0  0  0 \\\\\n0  1  0  0  0  0 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n$$\n该矩阵具有分块结构 $\\Pi = \\begin{pmatrix} 0_{3 \\times 3}  I_{3 \\times 3} \\\\ I_{3 \\times 3}  0_{3 \\times 3} \\end{pmatrix}$，其中 $I_{3 \\times 3}$ 是 $3 \\times 3$ 单位矩阵，$0_{3 \\times 3}$ 是 $3 \\times 3$ 零矩阵。这种结构直接反映了两个 $J=3$ 列块的交换。由于 $X_{(1)}$ 的所有列都是不同的，所以这个置换矩阵是唯一的。\n\n第三个任务是计算 $\\Pi$ 的行列式。置换矩阵的行列式等于相应置换的符号，即 $\\text{sgn}(\\sigma)$。置换 $\\sigma$ 可以分解为不相交的循环：$\\sigma = (1 \\ 4)(2 \\ 5)(3 \\ 6)$。这是 3 个对换（交换）的乘积。置换的符号是 $(-1)^k$，其中 $k$ 是对换的数量。\n因此，$\\text{sgn}(\\sigma) = (-1)^3 = -1$。\n因此，该置换矩阵的行列式为：\n$$\n\\det(\\Pi) = -1\n$$\n或者，对于形式为 $M = \\begin{pmatrix} 0  B \\\\ C  0 \\end{pmatrix}$ 的分块矩阵，其中 $B$ 和 $C$ 分别是大小为 $n \\times n$ 和 $m \\times m$ 的方阵，其行列式为 $\\det(M) = (-1)^{nm} \\det(B) \\det(C)$。在我们的例子中，$B=I_{3 \\times 3}$ 且 $C=I_{3 \\times 3}$，所以 $n=m=3$。\n$$\n\\det(\\Pi) = (-1)^{3 \\times 3} \\det(I_{3 \\times 3}) \\det(I_{3 \\times 3}) = (-1)^9 \\cdot 1 \\cdot 1 = -1\n$$\n两种方法都得到相同的结果。最终答案是行列式的值。",
            "answer": "$$\\boxed{-1}$$"
        },
        {
            "introduction": "多线性代数的强大威力最终体现在其解决实际问题的能力上，尤其是在处理具有低秩结构的大规模数据时。本练习将理论与实践相结合，要求您利用张量的标准多相（CP）分解来设计一种高效的计算策略。通过对比“暴力”计算与利用张量内在结构的巧妙算法 ，您将亲身体验到，理解和利用张量分解是实现算法性能飞跃的关键。",
            "id": "3561330",
            "problem": "考虑一个3阶张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times I_2 \\times I_3}$，其构造使其在其模-1展开中具有低矩阵秩，而在其他展开中具有满矩阵秩。仅使用多线性代数和数值线性代数中的核心定义。定义：张量纤维（fiber）是通过固定除一个索引外的所有索引而获得的向量。切片（slice）是通过固定一个索引并让另外两个索引变化而获得的矩阵。张量 $\\mathcal{X}$ 的模-$n$展开（matricization），表示为 $\\mathbf{X}_{(n)}$，将沿模$n$的纤维排列为矩阵的列。按列Khatri–Rao积为具有相同列数 $r$ 的矩阵 $\\mathbf{B} \\in \\mathbb{R}^{I_2 \\times r}$ 和 $\\mathbf{C} \\in \\mathbb{R}^{I_3 \\times r}$ 定义，其结果为矩阵 $\\mathbf{C} \\odot \\mathbf{B} \\in \\mathbb{R}^{(I_2 I_3) \\times r}$，该矩阵的第$k$列等于克罗内克积 $\\mathbf{b}_k \\otimes \\mathbf{c}_k$，其中 $\\mathbf{b}_k$ 和 $\\mathbf{c}_k$ 分别是 $\\mathbf{B}$ 和 $\\mathbf{C}$ 的第$k$列。典范多相分解（CP分解）将一个张量写为一系列秩-1外积之和：$\\mathcal{X} = \\sum_{k=1}^{r} \\mathbf{a}_k \\circ \\mathbf{b}_k \\circ \\mathbf{c}_k$，其因子矩阵为 $\\mathbf{A} = [\\mathbf{a}_1 \\ \\ldots \\ \\mathbf{a}_r] \\in \\mathbb{R}^{I_1 \\times r}$、$\\mathbf{B} = [\\mathbf{b}_1 \\ \\ldots \\ \\mathbf{b}_r] \\in \\mathbb{R}^{I_2 \\times r}$ 和 $\\mathbf{C} = [\\mathbf{c}_1 \\ \\ldots \\ \\mathbf{c}_r] \\in \\mathbb{R}^{I_3 \\times r}$。\n\n任务：对于下面测试套件中的每组参数 $(I_1, I_2, I_3, r)$，构造确定性的因子矩阵 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$，使得 $\\mathbf{A}$ 具有满列秩 $r$，$\\mathbf{B}$、$\\mathbf{C}$ 分别具有满行秩 $I_2$ 和 $I_3$，且满足 $r  I_1$ 和 $r \\ge I_2$，$r \\ge I_3$。使用这些因子通过CP分解定义张量 $\\mathcal{X}$。令 $\\mathbf{w} \\in \\mathbb{R}^{I_2 I_3}$ 为一个确定性向量。考虑由模-1展开 $\\mathbf{X}_{(1)} \\in \\mathbb{R}^{I_1 \\times (I_2 I_3)}$ 作用于 $\\mathbf{w}$ 生成 $\\mathbf{y} = \\mathbf{X}_{(1)} \\mathbf{w} \\in \\mathbb{R}^{I_1}$ 的线性算子。\n\n实现两种计算 $\\mathbf{y}$ 的算法：\n- 基准算法：从 $\\mathcal{X}$ 显式地构建 $\\mathbf{X}_{(1)}$，并通过稠密矩阵-向量乘法计算 $\\mathbf{y} = \\mathbf{X}_{(1)} \\mathbf{w}$。\n- 利用结构的算法：仅使用因子矩阵和核心定义来计算 $\\mathbf{y}$，在可能的情况下避免显式构造 $\\mathbf{X}_{(1)}$ 或 $\\mathcal{X}$。该算法基于CP结构以及展开与按列Khatri–Rao积之间的关系（该关系可从定义中推导），并通过首先沿模2和模3进行缩并来计算 $\\mathbf{y}$。\n\n对于每个测试用例，使用奇异值分解和标准容差规则计算 $\\mathbf{X}_{(1)}$、$\\mathbf{X}_{(2)}$ 和 $\\mathbf{X}_{(3)}$ 的数值秩。验证 $\\operatorname{rank}(\\mathbf{X}_{(1)}) = r$、$\\operatorname{rank}(\\mathbf{X}_{(2)}) = I_2$ 和 $\\operatorname{rank}(\\mathbf{X}_{(3)}) = I_3$。\n\n在以下假设下，计算两种算法的标量运算计数（乘法和加法之和）：\n- 基准算法：通过稠密矩阵-向量乘法计算 $\\mathbf{y} = \\mathbf{X}_{(1)} \\mathbf{w}$ 的成本为 $I_1 (I_2 I_3)$ 次乘法和 $I_1 (I_2 I_3 - 1)$ 次加法。\n- 利用结构的算法：首先将 $\\mathbf{w}$ 重塑为矩阵 $\\mathbf{W} \\in \\mathbb{R}^{I_2 \\times I_3}$，对于每个 $k \\in \\{1, \\ldots, r\\}$，计算 $\\mathbf{t}_k = \\mathbf{W} \\mathbf{c}_k$（成本为 $I_2 I_3$ 次乘法和 $I_2 (I_3 - 1)$ 次加法），然后计算 $s_k = \\mathbf{b}_k^\\top \\mathbf{t}_k$（成本为 $I_2$ 次乘法和 $I_2 - 1$ 次加法），最后累加 $\\mathbf{y} \\leftarrow \\mathbf{y} + s_k \\mathbf{a}_k$（成本为 $I_1$ 次乘法和 $I_1$ 次加法）。将这些成本对 $k = 1, \\ldots, r$ 求和以获得总计数。\n\n您的程序必须为每个测试用例返回一个包含四个项目的列表：$[\\text{eq}_{\\text{baseline,struct}}, \\text{eq}_{\\text{baseline,KR}}, \\text{ranks\\_ok}, \\rho]$，其中 $\\text{eq}_{\\text{baseline,struct}}$ 和 $\\text{eq}_{\\text{baseline,KR}}$ 是布尔值，指示基准算法和利用结构的算法的输出在绝对容差 $10^{-12}$ 和相对容差 $10^{-10}$ 内是否一致，$\\text{ranks\\_ok}$ 是一个布尔值，指示秩条件是否成立，而 $\\rho$ 是基准算法标量运算计数与利用结构的算法计数之比的浮点数。\n\n测试套件参数值：\n- 案例 1：$(I_1, I_2, I_3, r) = (50, 10, 12, 12)$。\n- 案例 2：$(I_1, I_2, I_3, r) = (40, 8, 8, 8)$。\n- 案例 3：$(I_1, I_2, I_3, r) = (60, 6, 10, 10)$。\n- 案例 4：$(I_1, I_2, I_3, r) = (100, 9, 7, 9)$。\n- 案例 5：$(I_1, I_2, I_3, r) = (30, 1, 20, 20)$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的聚合结果，格式为用方括号括起来的逗号分隔列表。每个测试用例结果本身必须是如上所述的列表。例如，输出应类似于 $[[\\text{True}, \\text{True}, \\text{True}, 3.14], \\ldots]$。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在多线性代数原理方面有科学依据，问题设定良好且客观。它提供了一套完整且一致的定义、约束和任务。\n\n目标是计算向量 $\\mathbf{y} \\in \\mathbb{R}^{I_1}$，该向量是张量的模-1展开 $\\mathbf{X}_{(1)} \\in \\mathbb{R}^{I_1 \\times (I_2 I_3)}$ 与向量 $\\mathbf{w} \\in \\mathbb{R}^{I_2 I_3}$ 的乘积。张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times I_2 \\times I_3}$ 由其具有指定秩结构的典范多项分解（CP分解）定义。我们将实现两种算法进行此计算，验证张量展开的秩属性，并分析计算成本的节省情况。\n\n首先，我们根据问题规范构造确定性的因子矩阵 $\\mathbf{A} \\in \\mathbb{R}^{I_1 \\times r}$、$\\mathbf{B} \\in \\mathbb{R}^{I_2 \\times r}$ 和 $\\mathbf{C} \\in \\mathbb{R}^{I_3 \\times r}$。为了保证确定性和所需的秩属性，我们使用一个带种子的伪随机数生成器，用来自连续均匀分布的值填充这些矩阵。约束条件为 $r  I_1$、$r \\ge I_2$ 和 $r \\ge I_3$。\n- $\\mathbf{A}$ 是一个 $I_1 \\times r$ 矩阵。由于 $I_1  r$，一个随机矩阵以概率1具有满列秩 $r$。\n- $\\mathbf{B}$ 是一个 $I_2 \\times r$ 矩阵。由于 $I_2 \\le r$，一个随机矩阵以概率1具有满行秩 $I_2$。\n- $\\mathbf{C}$ 是一个 $I_3 \\times r$ 矩阵。由于 $I_3 \\le r$，一个随机矩阵以概率1具有满行秩 $I_3$。\n一个确定性向量 $\\mathbf{w} \\in \\mathbb{R}^{I_2 I_3}$ 也以类似方式生成。\n\n张量 $\\mathcal{X}$ 由其CP分解给出：\n$$\n\\mathcal{X} = \\sum_{k=1}^{r} \\mathbf{a}_k \\circ \\mathbf{b}_k \\circ \\mathbf{c}_k\n$$\n以元素形式表示，即 $\\mathcal{X}_{i_1, i_2, i_3} = \\sum_{k=1}^{r} A_{i_1, k} B_{i_2, k} C_{i_3, k}$。\n\n核心任务是计算 $\\mathbf{y} = \\mathbf{X}_{(1)} \\mathbf{w}$。张量的索引如何映射到其展开矩阵的列存在模糊性。我们采用一种基于C风格（行主序）内存布局的一致约定，正如利用结构的算法的定义和标准数值库函数所暗示的那样。一个元素 $\\mathcal{X}_{i_1, i_2, i_3}$（使用0-基索引）映射到元素 $(\\mathbf{X}_{(1)})_{i_1, j}$，其中 $j = i_2 \\cdot I_3 + i_3$。\n\n**算法1：基准算法**\n该方法涉及张量及其展开的显式构造。\n1.  从其因子矩阵 $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{C}$ 构造完整的张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times I_2 \\times I_3}$。这可以使用爱因斯坦求和约定高效地计算：$\\mathcal{X}_{i_1, i_2, i_3} = \\sum_k A_{i_1,k} B_{i_2,k} C_{i_3,k}$。\n2.  通过重塑 $\\mathcal{X}$ 形成模-1展开 $\\mathbf{X}_{(1)} \\in \\mathbb{R}^{I_1 \\times (I_2 I_3)}$。根据我们的C风格约定，这是将 $I_1 \\times I_2 \\times I_3$ 数组直接重塑为 $I_1 \\times (I_2 I_3)$ 矩阵。\n3.  计算矩阵-向量积 $\\mathbf{y}_{\\text{baseline}} = \\mathbf{X}_{(1)} \\mathbf{w}$。\n\n**算法2：利用结构的算法**\n该方法利用CP结构来避免形成大张量 $\\mathcal{X}$ 或其展开 $\\mathbf{X}_{(1)}$。我们从乘积的元素级定义开始：\n$$\ny_{i_1} = \\sum_{i_2=1}^{I_2} \\sum_{i_3=1}^{I_3} \\mathcal{X}_{i_1, i_2, i_3} W_{i_2, i_3}\n$$\n其中 $\\mathbf{W} \\in \\mathbb{R}^{I_2 \\times I_3}$ 是通过重塑向量 $\\mathbf{w}$ 得到的矩阵。代入 $\\mathcal{X}$ 的CP分解：\n$$\ny_{i_1} = \\sum_{i_2=1}^{I_2} \\sum_{i_3=1}^{I_3} \\left( \\sum_{k=1}^{r} A_{i_1, k} B_{i_2, k} C_{i_3, k} \\right) W_{i_2, i_3}\n$$\n通过重新排序求和，我们得到：\n$$\ny_{i_1} = \\sum_{k=1}^{r} A_{i_1, k} \\left( \\sum_{i_2=1}^{I_2} B_{i_2, k} \\left( \\sum_{i_3=1}^{I_3} W_{i_2, i_3} C_{i_3, k} \\right) \\right)\n$$\n这个表达式定义了一系列高效的操作，正如问题所规定的：\n1.  对于每个 $k \\in \\{1, \\ldots, r\\}$，计算向量 $\\mathbf{t}_k = \\mathbf{W} \\mathbf{c}_k \\in \\mathbb{R}^{I_2}$。这对应于内层求和。\n2.  对于每个 $k$，计算标量 $s_k = \\mathbf{b}_k^\\top \\mathbf{t}_k$。这是中间的求和。\n3.  最终结果是 $\\mathbf{A}$ 的列的线性组合：$\\mathbf{y}_{\\text{struct}} = \\sum_{k=1}^{r} s_k \\mathbf{a}_k = \\mathbf{A}\\mathbf{s}$，其中 $\\mathbf{s} = [s_1, \\ldots, s_r]^\\top$。\n\n为了提高效率，这个过程可以被向量化。令 $\\mathbf{T} = \\mathbf{W}\\mathbf{C} \\in \\mathbb{R}^{I_2 \\times r}$。$\\mathbf{T}$ 的列是向量 $\\mathbf{t}_k$。向量 $\\mathbf{s}$ 可以通过 $\\mathbf{B}$ 和 $\\mathbf{T}$ 的元素级乘积沿第一维求和来计算。然后 $\\mathbf{y}_{\\text{struct}} = \\mathbf{A}\\mathbf{s}$。\n\n该算法是数学恒等式 $\\mathbf{X}_{(1)} = \\mathbf{A} (\\mathbf{C} \\odot \\mathbf{B})^\\top$ 的一种高效实现，其中 $\\odot$ 表示按列Khatri-Rao积。乘积 $\\mathbf{y} = \\mathbf{X}_{(1)}\\mathbf{w}$ 变为 $\\mathbf{y} = \\mathbf{A} ((\\mathbf{C} \\odot \\mathbf{B})^\\top \\mathbf{w})$。结构化算法计算项 $(\\mathbf{C} \\odot \\mathbf{B})^\\top \\mathbf{w}$（即我们的向量 $\\mathbf{s}$），而无需显式形成大的 $(I_2 I_3) \\times r$ Khatri-Rao矩阵。问题要求进行两个布尔比较，$\\text{eq}_{\\text{baseline,struct}}$ 和 $\\text{eq}_{\\text{baseline,KR}}$。由于结构化方法是基于Khatri-Rao公式的高效评估，我们计算单个 $\\mathbf{y}_{\\text{struct}}$ 并用它与 $\\mathbf{y}_{\\text{baseline}}$ 进行两次比较。\n\n**秩验证**\n三个展开 $\\mathbf{X}_{(1)}$、$\\mathbf{X}_{(2)}$ 和 $\\mathbf{X}_{(3)}$ 的数值秩使用奇异值分解（SVD）计算。秩是大于标准容差的奇异值的数量。\n-   $\\mathbf{X}_{(1)} \\in \\mathbb{R}^{I_1 \\times (I_2 I_3)}$。期望秩：$\\operatorname{rank}(\\mathbf{X}_{(1)}) = r$。这是因为 $\\mathbf{A}$ 的秩为 $r$，$(\\mathbf{C} \\odot \\mathbf{B})^\\top$ 的秩为 $r$，而满秩矩阵的乘积保留较小的秩。\n-   $\\mathbf{X}_{(2)} \\in \\mathbb{R}^{I_2 \\times (I_1 I_3)}$。通过将张量轴置换为 $(1, 0, 2)$ 并重塑而形成。期望秩：$\\operatorname{rank}(\\mathbf{X}_{(2)}) = I_2$，因为 $\\mathbf{B}$ 具有满行秩 $I_2$ 且 $I_2 \\le r$。\n-   $\\mathbf{X}_{(3)} \\in \\mathbb{R}^{I_3 \\times (I_1 I_2)}$。通过将轴置换为 $(2, 0, 1)$ 并重塑而形成。期望秩：$\\operatorname{rank}(\\mathbf{X}_{(3)}) = I_3$，因为 $\\mathbf{C}$ 具有满行秩 $I_3$ 且 $I_3 \\le r$。\n如果所有三个秩条件都成立，则布尔值 $\\text{ranks\\_ok}$ 为真。\n\n**运算计数比**\n比率 $\\rho$ 使用问题陈述中提供的运算计数（加法+乘法）来计算。\n-   基准成本：$C_{\\text{baseline}} = I_1 (I_2 I_3) + I_1 (I_2 I_3 - 1) = 2 I_1 I_2 I_3 - I_1$。\n-   利用结构的成本：$C_{\\text{struct}} = \\sum_{k=1}^{r} (\\text{计算 } \\mathbf{t}_k, s_k, \\text{和累加的成本})$。\n    -   $\\mathbf{t}_k = \\mathbf{W}\\mathbf{c}_k$：$I_2 I_3$ 次乘法，$I_2(I_3-1)$ 次加法。\n    -   $s_k = \\mathbf{b}_k^\\top\\mathbf{t}_k$：$I_2$ 次乘法，$I_2-1$ 次加法。\n    -   $\\mathbf{y} \\leftarrow \\mathbf{y} + s_k \\mathbf{a}_k$：$I_1$ 次乘法，$I_1$ 次加法。\n    -   $C_{\\text{struct}} = r \\left( (I_2 I_3 + I_2 + I_1) + (I_2(I_3-1) + (I_2-1) + I_1) \\right) = r(2 I_2 I_3 + 2 I_2 + 2I_1 - 1)$。\n-   比率：$\\rho = C_{\\text{baseline}} / C_{\\text{struct}}$。预计该比率将显著大于1，表明利用张量低秩结构的效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tensor computation problem for a suite of test cases.\n    \"\"\"\n    # Test cases: (I1, I2, I3, r)\n    test_cases = [\n        (50, 10, 12, 12),\n        (40, 8, 8, 8),\n        (60, 6, 10, 10),\n        (100, 9, 7, 9),\n        (30, 1, 20, 20)\n    ]\n    \n    # Tolerances for floating point comparisons\n    tol_abs = 1e-12\n    tol_rel = 1e-10\n\n    # Seed for deterministic random number generation\n    rng = np.random.default_rng(0)\n\n    results_all_cases = []\n\n    for case in test_cases:\n        I1, I2, I3, r = case\n\n        # 1. Deterministic construction of factor matrices and vector w\n        # A should have full column rank r (since r  I1)\n        A = rng.random((I1, r))\n        # B should have full row rank I2 (since r >= I2)\n        B = rng.random((I2, r))\n        # C should have full row rank I3 (since r >= I3)\n        C = rng.random((I3, r))\n        \n        # Deterministic vector w\n        w = rng.random(I2 * I3)\n\n        # --- Baseline Algorithm ---\n        # Explicitly construct the tensor X using the CP decomposition.\n        # X_{i,j,l} = sum_k A_{i,k} * B_{j,k} * C_{l,k}\n        X = np.einsum('ik,jk,lk-ijl', A, B, C)\n        \n        # Unfold X to X_(1) using C-style (row-major) ordering.\n        # This maps X(i1, i2, i3) to X1(i1, i2*I3 + i3).\n        X1 = X.reshape(I1, -1)\n        \n        # Compute y using dense matrix-vector multiplication.\n        y_baseline = X1 @ w\n\n        # --- Structure-Exploiting Algorithm ---\n        # Reshape w into a matrix W.\n        W = w.reshape(I2, I3)\n        \n        # Vectorized implementation of the structured computation:\n        # y = A @ s, where s_k = b_k^T @ (W @ c_k)\n        T = W @ C           # T has shape (I2, r), columns are t_k\n        s = np.sum(B * T, axis=0) # s has shape (r,), elements are s_k\n        y_struct = A @ s    # y has shape (I1,)\n\n        # --- Comparisons and Checks ---\n        # Compare results from baseline and structured algorithms.\n        # As reasoned in the solution, the \"KR\" method is an algebraic\n        # view of the structured method. So we perform the same comparison twice.\n        eq_baseline_struct = np.allclose(y_baseline, y_struct, rtol=tol_rel, atol=tol_abs)\n        eq_baseline_KR = eq_baseline_struct\n\n        # --- Rank Verification ---\n        # Unfold X along all three modes using C-style ordering.\n        # X1 is already computed.\n        # Mode-2 unfolding:\n        X2 = np.transpose(X, (1, 0, 2)).reshape(I2, -1)\n        # Mode-3 unfolding:\n        X3 = np.transpose(X, (2, 0, 1)).reshape(I3, -1)\n\n        # Compute numerical ranks.\n        rank1 = np.linalg.matrix_rank(X1)\n        rank2 = np.linalg.matrix_rank(X2)\n        rank3 = np.linalg.matrix_rank(X3)\n        \n        # Check if rank conditions hold.\n        ranks_ok = (rank1 == r) and (rank2 == I2) and (rank3 == I3)\n\n        # --- Operation Count Ratio ---\n        # Use the formulas provided in the problem description.\n        cost_baseline = float(2 * I1 * I2 * I3 - I1)\n        \n        cost_struct_mult = float(r * (I2 * I3 + I2 + I1))\n        cost_struct_add = float(r * (I2 * (I3 - 1) + (I2 - 1) + I1))\n        cost_struct = cost_struct_mult + cost_struct_add\n        \n        rho = cost_baseline / cost_struct\n\n        # Append results for the current case.\n        results_all_cases.append([eq_baseline_struct, eq_baseline_KR, ranks_ok, rho])\n\n    # Format the output as a single string.\n    output_str = \"[\"\n    for i, res in enumerate(results_all_cases):\n        # Format: [bool, bool, bool, float]\n        output_str += f\"[{res[0]}, {res[1]}, {res[2]}, {res[3]:.14f}]\" # Using .14f to avoid scientific notation\n        if i  len(results_all_cases) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    # Capitalize booleans for final output per example format\n    output_str = output_str.replace('True', 'True').replace('False', 'False')\n\n    print(output_str)\n\n\nsolve()\n```"
        }
    ]
}