{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将带你具体地、一步步地了解在消元过程中“填充”（fill-in）是如何产生的。通过在一个小规模图上手动执行单步消元，你将直接观察到舒尔补（Schur complement）更新的图论解释，并理解填充的来源。这个练习旨在阐明重排序算法所要解决的根本问题。",
            "id": "3574459",
            "problem": "考虑一个实对称正定矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$，其非对角稀疏模式由顶点集为 $\\{1,2,3,4,5\\}$ 的无向图 $G(A)$ 表示。图 $G(A)$ 由以下对称邻接表指定（边是无向的，对角线元素是隐含的，不表示为边）：\n- 顶点 $1$：邻居 $\\{2,3\\}$。\n- 顶点 $2$：邻居 $\\{1,3,4\\}$。\n- 顶点 $3$：邻居 $\\{1,2\\}$。\n- 顶点 $4$：邻居 $\\{2,5\\}$。\n- 顶点 $5$：邻居 $\\{4\\}$。\n\n您将对顶点 $2$ 执行一步稀疏 Cholesky 消元（等价于对称主元高斯消元）。请使用对称矩阵消元的标准图论解释：当消去一个顶点时，其所有当前邻居在剩余顶点中被连接起来形成一个团（clique），然后被消去的顶点从图中移除。经过这一单步消元后，在剩余顶点上得到的图称为该步骤的消元图，任何原先在 $G(A)$ 中不存在但因形成团而引入的新边称为填充边（fill-in edges）。\n\n从给定的 $G(A)$ 开始，首先消去顶点 $2$，根据上述规则在剩余顶点 $\\{1,3,4,5\\}$ 上构建消元图，并精确确定此步骤引入了多少条填充边。只报告首先消去顶点 $2$ 所引入的填充边的总数。以整数形式给出您的最终答案。无需四舍五入。",
            "solution": "基本原理是对称矩阵稀疏模式的图解释，以及稀疏 Cholesky 分解消元过程中控制填充的规则。对于一个对称矩阵 $A$，其稀疏模式可以由一个无向图 $G(A)$ 描述，该图的顶点对应于 $A$ 的索引，其中当且仅当 $a_{ij} \\neq 0$ 时，存在一条边 $(i,j)$（其中 $i \\neq j$）。当对一个顶点 $v$ 执行单步消元时（对应于在 Cholesky 分解中以索引 $v$ 为主元），消元规则规定：在当前图中，$v$ 的所有邻居相互连接（形成一个团）以反映舒尔补（Schur complement）的更新，然后 $v$ 被移除。在 $v$ 的邻居之间引入的任何原本不存在的边被称为填充边。这个图论过程与一个代数事实相符，即舒尔补更新会在与被消去顶点的邻居对相应的位置上产生新的非零元。\n\n我们从给定的、顶点集为 $\\{1,2,3,4,5\\}$ 的图 $G(A)$ 开始。其邻接关系如下：\n- 顶点 $1$：邻居 $\\{2,3\\}$。\n- 顶点 $2$：邻居 $\\{1,3,4\\}$。\n- 顶点 $3$：邻居 $\\{1,2\\}$。\n- 顶点 $4$：邻居 $\\{2,5\\}$。\n- 顶点 $5$：邻居 $\\{4\\}$。\n\n我们首先消去顶点 $2$。顶点 $2$ 的邻居集合是\n$$\nN(2) = \\{1,3,4\\}。\n$$\n根据消元规则，我们必须在剩余顶点中连接 $N(2)$ 中的所有点对，以在 $\\{1,3,4\\}$ 上形成一个团。$\\{1,3,4\\}$ 中的潜在点对是：\n$$\n\\{(1,3), (1,4), (3,4)\\}。\n$$\n我们确定这些边中有哪些已经存在于 $G(A)$ 中，哪些将成为填充边：\n- 边 $(1,3)$ 已经存在，因为顶点 $1$ 的邻居列表包含 $3$，顶点 $3$ 的邻居列表包含 $1$。\n- 边 $(1,4)$ 在原图中不存在，因为顶点 $1$ 的邻居列表是 $\\{2,3\\}$，顶点 $4$ 的邻居列表是 $\\{2,5\\}$，所以 $(1,4)$ 不存在。\n- 边 $(3,4)$ 在原图中不存在，因为顶点 $3$ 的邻居列表是 $\\{1,2\\}$，顶点 $4$ 的邻居列表是 $\\{2,5\\}$，所以 $(3,4)$ 不存在。\n\n因此，该消元步骤恰好引入了以下填充边：\n$$\n(1,4) \\quad \\text{和} \\quad (3,4)。\n$$\n在剩余顶点中添加这些边并移除顶点 $2$ 后，在 $\\{1,3,4,5\\}$ 上的消元图具有以下边：\n- 来自剩余顶点之间的原始边：$(1,3)$ 和 $(4,5)$。\n- 来自填充的边：$(1,4)$ 和 $(3,4)$。\n\n通过消去顶点 $2$ 引入的填充边总数是新添加边的数量，即\n$$\n2。\n$$",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在理解了填充的概念之后，本练习将指导你完整地执行一次最小度（Minimum Degree, MD）算法，这是一种旨在减少填充的基础启发式策略。你将处理算法中的关键细节，例如识别不可区分节点（indistinguishable nodes）和更新商图（quotient graph），从而深入理解这种贪心策略的决策过程。",
            "id": "3574472",
            "problem": "考虑一个实对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{7 \\times 7}$，其稀疏模式由一个无向图 $G=(V,E)$ 表示，其中顶点集 $V=\\{1,2,3,4,5,6,7\\}$，边集 $E$ 由以下邻接关系定义：$N(1)=\\{2,3,4\\}$，$N(2)=\\{1,3,4\\}$，$N(3)=\\{1,2,4\\}$，$N(4)=\\{1,2,3,5,6,7\\}$，$N(5)=\\{4,6,7\\}$，$N(6)=\\{4,5,7\\}$，$N(7)=\\{4,5,6\\}$，其中 $N(i)$ 表示图 $G$ 中顶点 $i$ 的邻居集合。稀疏 Cholesky 分解的消去图模型通过选择顶点进行消去来进行；当一个顶点 $v$ 被消去时，其当前邻居集合 $N(v)$ 中的所有顶点都变得相互邻接（补全为一个团），这对应于在 $v$ 的邻居之间引入填充边。如果两个未被消去的顶点 $i$ 和 $j$ 相邻，并且它们限制在未消去顶点上的邻居集合满足 $N(i)\\setminus\\{j\\}=N(j)\\setminus\\{i\\}$，则称它们是不可区分的。不可区分的顶点在商图中被合并成一个单一的超节点；超节点的度是其在商图中的邻居集合的基数。最小度排序是通过迭代选择具有当前最小度的顶点或超节点，将其邻居补全为一个团（并遵循超节点结构），更新商图，并合并任何新出现的不可区分顶点来获得的。当最小度出现并列时，通过选择包含的最小原始顶点标号最小的顶点或超节点来打破并列；在输出最终排列时，将每个超节点内的顶点按标号升序排列。\n\n从上述消去图和填充的定义出发，推导对于给定的图 $G$，采用商图更新和不可区分顶点合并的最小度方法的精确计算步骤。从消去图模型的基本原理出发，仔细论证每一步的选择和更新，并确定此过程产生的最终排列（$V$ 的排序）。使用 LaTeX 的 $pmatrix$ 环境将最终排列表示为一个单行标号向量。无需四舍五入，也没有单位。",
            "solution": "首先根据指定标准验证问题。\n\n### 步骤 1：提取已知条件\n-   **矩阵**：一个实对称正定 (SPD) 矩阵 $A \\in \\mathbb{R}^{7 \\times 7}$。\n-   **图**：稀疏模式由一个无向图 $G=(V,E)$ 表示，其中：\n    -   顶点集 $V=\\{1,2,3,4,5,6,7\\}$。\n    -   邻居集合：$N(1)=\\{2,3,4\\}$，$N(2)=\\{1,3,4\\}$，$N(3)=\\{1,2,4\\}$，$N(4)=\\{1,2,3,5,6,7\\}$，$N(5)=\\{4,6,7\\}$，$N(6)=\\{4,5,7\\}$，$N(7)=\\{4,5,6\\}$。\n-   **算法**：最小度排序。\n-   **消去过程**：当一个顶点 $v$ 被消去时，其邻居 $N(v)$ 形成一个团。\n-   **不可区分顶点**：如果两个未消去的顶点 $i$ 和 $j$ 相邻，并且它们（限制在未消去顶点上的）邻居集合满足 $N(i)\\setminus\\{j\\}=N(j)\\setminus\\{i\\}$，则称它们是不可区分的。\n-   **商图**：不可区分的顶点合并成一个超节点。超节点的度是其在商图中的邻居集合的基数。\n-   **选择规则**：迭代选择当前度最小的顶点或超节点。\n-   **并列处理规则**：如果最小度出现并列，选择包含的最小原始顶点标号最小的顶点或超节点。\n-   **输出格式**：最终排列是一个单行向量。被消去的超节点内的顶点按标号升序排列。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题是最小度 (MD) 排序算法的一个标准应用，该算法是数值线性代数中用于稀疏矩阵分解的一种基本启发式方法。消去图、填充、商图和不可区分顶点等概念都是公认的。该问题在科学上和数学上都是合理的。\n-   **适定性**：图结构已明确定义。算法，包括不可区分顶点的先验合并（批量消去）、具体的选择标准（最小度）以及明确的并列处理规则，都已完全指定。这确保了可以遵循一个唯一的、确定性的步骤序列来产生一个单一、无歧义的解。\n-   **客观性**：问题使用精确、客观的数学语言陈述。没有主观或模糊的术语。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它具有科学依据、适定性和客观性。下面将推导详细的解。\n\n### 最小度排序的推导\n\n将最小度排序算法逐步应用于给定的图 $G$。该过程涉及跟踪消去图的状态，这里用包含超节点的商图来表示。\n\n**步骤 0：初始图分析与商图形成**\n\n首先，我们分析初始图 $G_0 = G$，以识别任何不可区分的顶点并形成初始商图。原始图中各顶点的度为：\n$\\text{deg}(1)=3$, $\\text{deg}(2)=3$, $\\text{deg}(3)=3$, $\\text{deg}(4)=6$, $\\text{deg}(5)=3$, $\\text{deg}(6)=3$, $\\text{deg}(7)=3$。\n\n我们检查是否存在不可区分的顶点。\n-   考虑顶点 $1$ 和 $2$。它们是相邻的。我们比较它们的邻居集合：\n    -   $N(1)\\setminus\\{2\\} = \\{2,3,4\\}\\setminus\\{2\\} = \\{3,4\\}$。\n    -   $N(2)\\setminus\\{1\\} = \\{1,3,4\\}\\setminus\\{1\\} = \\{3,4\\}$。\n    由于 $N(1)\\setminus\\{2\\} = N(2)\\setminus\\{1\\}$，顶点 $1$ 和 $2$ 是不可区分的。通过对称性，我们可以检查出顶点 $1$、$2$ 和 $3$ 都是相互不可区分的（例如，对于 $1$ 和 $3$，$N(1)\\setminus\\{3\\}=\\{2,4\\}$ 且 $N(3)\\setminus\\{1\\}=\\{2,4\\}$）。因此，它们形成一个超节点 $S_1 = \\{1,2,3\\}$。\n\n-   考虑顶点 $5$ 和 $6$。它们是相邻的。我们比较它们的邻居集合：\n    -   $N(5)\\setminus\\{6\\} = \\{4,6,7\\}\\setminus\\{6\\} = \\{4,7\\}$。\n    -   $N(6)\\setminus\\{5\\} = \\{4,5,7\\}\\setminus\\{5\\} = \\{4,7\\}$。\n    由于 $N(5)\\setminus\\{6\\} = N(6)\\setminus\\{5\\}$，顶点 $5$ 和 $6$ 是不可区分的。通过对称性，顶点 $5$、$6$ 和 $7$ 都是相互不可区分的。因此，它们形成第二个超节点 $S_2 = \\{5,6,7\\}$。\n\n-   顶点 $4$ 与任何其他顶点都不是不可区分的。\n\n初始商图，我们称之为 $G'_0$，由三个节点组成：超节点 $S_1$、超节点 $S_2$ 和单例顶点 $\\{4\\}$。\n$S_1$ 在商图中的邻居是其所有成员共有的外部邻居。$\\{1,2,3\\}$ 中不在 $S_1$ 内的唯一邻居是顶点 $4$。所以，$N_{G'_0}(S_1) = \\{\\{4\\}\\}$。\n类似地确定 $S_2$ 的邻居。$\\{5,6,7\\}$ 中不在 $S_2$ 内的唯一邻居是顶点 $4$。所以，$N_{G'_0}(S_2) = \\{\\{4\\}\\}$。\n顶点 $\\{4\\}$ 的邻居是所有与其相连的节点。在商图中，这些是 $S_1$ 和 $S_2$。所以，$N_{G'_0}(\\{4\\}) = \\{S_1, S_2\\}$。\n\n商图 $G'_0$ 中的度为：\n-   $\\text{deg}(S_1) = |N_{G'_0}(S_1)| = 1$。\n-   $\\text{deg}(S_2) = |N_{G'_0}(S_2)| = 1$。\n-   $\\text{deg}(\\{4\\}) = |N_{G'_0}(\\{4\\})| = 2$。\n\n**步骤 1：第一次消去**\n\n我们选择度最小的节点。最小度为 $1$，由超节点 $S_1$ 和 $S_2$ 共享。我们应用并列处理规则：选择包含最小原始顶点标号的节点。\n-   $S_1 = \\{1,2,3\\}$ 中的最小标号是 $1$。\n-   $S_2 = \\{5,6,7\\}$ 中的最小标号是 $5$。\n由于 $1  5$，我们选择 $S_1$ 进行消去。\n\n$S_1$ 中的顶点 $\\{1,2,3\\}$ 首先被放入排列中。根据规则，它们按标号升序排列。\n排列以 $(1, 2, 3)$ 开始。\n\n我们更新图。我们消去 $S_1$。$S_1$ 在 $G'_0$ 中的邻居只有 $\\{\\{4\\}\\}$。由于只有一个邻居，没有创建填充边。更新后的商图 $G'_1$ 现在由剩余的节点 $\\{4\\}$ 和 $S_2$ 以及它们之间原有的边组成。\n\n**步骤 2：消去后更新与第二次消去**\n\n当前的商图 $G'_1$ 包含节点 $\\{4\\}$ 和 $S_2$，它们是相邻的。我们必须检查是否形成了任何新的不可区分节点。\n-   考虑节点 $\\{4\\}$ 和 $S_2$。它们在 $G'_1$ 中是相邻的。\n-   $\\{4\\}$ 在 $G'_1$ 中的邻居集合是 $N_{G'_1}(\\{4\\}) = \\{S_2\\}$。\n-   $S_2$ 在 $G'_1$ 中的邻居集合是 $N_{G'_1}(S_2) = \\{\\{4\\}\\}$。\n-   我们检查条件：\n    -   $N_{G'_1}(\\{4\\}) \\setminus \\{S_2\\} = \\emptyset$。\n    -   $N_{G'_1}(S_2) \\setminus \\{\\{4\\}\\} = \\emptyset$。\n条件满足，因此 $\\{4\\}$ 和 $S_2$ 现在是不可区分的。它们被合并成一个新的超节点 $S_3 = \\{4\\} \\cup S_2 = \\{4,5,6,7\\}$。\n\n新的商图 $G'_2$ 现在只包含这个单一的超节点 $S_3$。\n$S_3$ 的度为 $0$，因为它没有外部邻居。它自然是度最小的节点。我们选择 $S_3$ 进行消去。\n\n$S_3$ 中的顶点是 $\\{4,5,6,7\\}$。它们按标号升序排列并附加到排列的末尾。\n排列的下一部分是 $(4, 5, 6, 7)$。\n\n**步骤 3：最终排列**\n\n通过组合每个消去步骤中得到的有序顶点集，我们获得最终的排列 $P$。\n-   来自步骤 1：$(1, 2, 3)$。\n-   来自步骤 2：$(4, 5, 6, 7)$。\n\n最终的排列是 $P = (1, 2, 3, 4, 5, 6, 7)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  2  3  4  5  6  7\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "不同的重排序算法在填充和计算结构方面可能导致截然不同的结果。最后一个练习将在一个模型问题上比较三种典型的策略——自然排序、最小度算法和嵌套剖分（Nested Dissection, ND）算法。你将分析每种排序如何影响消元树（elimination tree）的结构，而消元树是理解稀疏矩阵分解中并行性潜力的关键概念。",
            "id": "3574498",
            "problem": "考虑一个对称正定 (SPD) 块三对角矩阵 $A \\in \\mathbb{R}^{nb \\times nb}$，它由具有 $n$ 个大小为 $b \\times b$（其中 $b \\geq 1$）的块的一维最近邻离散化产生。在超节点层面，其关联的块稀疏图的顶点为 $\\{1,2,\\dots,n\\}$，边为 $\\{(i,i+1): i=1,2,\\dots,n-1\\}$，即路径图 $P_n$。我们研究在对超节点进行重排序的不同置换 $P$ 下，$P^{T} A P$ 的超节点消元树（一个有向树，其中一个超节点的父节点是在排序中位于其后、且在相应 Cholesky 因子中具有非零元的最小超节点）。\n\n从以下基本事实和定义开始：\n\n1. $P^{T} A P$ 的 Cholesky 因子的消元树仅取决于超节点的排序以及消元过程中产生的填充图中的图可达性，而与块内的数值无关。\n2. 对于超节点的一种排序 $\\pi$，填充图 $F$ 中两个超节点 $i$ 和 $j$ 之间存在一条边，条件是 $(i,j)$ 是原始边，或者在原始图中 $i$ 和 $j$ 之间存在一条路径，其所有内部顶点在排序 $\\pi$ 下都位于 $\\max\\{i,j\\}$ 之前。\n3. 消元树中超节点 $i$ 的父节点是在排序 $\\pi$ 下位于 $i$ 之后、且 Cholesky 因子在 $(j,i)$ 位置有非零元的最小超节点 $j$；等价地，$j$ 是填充图 $F$ 中 $i$ 的最小的、排序更靠后的邻居。\n\n定义消元树的高度为从叶节点到根节点的最长路径上的顶点数。\n\n分析以下三种超节点排序：\n\n(a) 自然的从左到右排序 $\\pi_{\\mathrm{nat}} = (1,2,\\dots,n)$。\n\n(b) 路径图 $P_n$ 上的最小度 (MD) 排序 $\\pi_{\\mathrm{md}}$，其决胜规则为确定性的，即在每一步中，在所有具有最小度的超节点中总是选择索引最小的那个。\n\n(c) 一种平衡嵌套剖分 (ND) 排序 $\\pi_{\\mathrm{nd}}$，通过在其中心超节点处递归地二分路径，并在每个递归层级上按“左子路径，右子路径，分隔符最后”的顺序排序得到。假设对于某个整数 $k \\geq 1$，有 $n=2^{k}-1$，因此每次二分都会产生两个大小相等的子路径和一个单顶点分隔符。\n\n仅使用上述原理，推导每种排序下消元树的结构及其高度（作为 $n$ 的函数）。然后，针对 $n=15$ 和任意 $b \\geq 1$ 的情况，计算量\n$$\nH_{\\mathrm{nat}} - H_{\\mathrm{nd}},\n$$\n其中 $H_{\\mathrm{nat}}$ 和 $H_{\\mathrm{nd}}$ 分别表示在 $\\pi_{\\mathrm{nat}}$ 和 $\\pi_{\\mathrm{nd}}$ 排序下消元树的高度。请以单个整数形式提供最终答案。无需单位，也无需四舍五入。",
            "solution": "### 消元树结构和高度的推导\n\n我们通过检查每种排序对路径图 $P_n$ 的消元过程的影响来进行分析。\n\n**(a) 自然排序：$\\pi_{\\mathrm{nat}} = (1, 2, \\dots, n)$**\n\n在自然排序下，超节点从 $1$ 到 $n$ 依次被消元。让我们确定任意超节点 $i  n$ 的父节点。根据定义，父节点是 $i$ 在填充图中排序更靠后的最小邻居。在消元 $i$ 时，其唯一的排序更靠后的邻居是 $i+1$。在消元过程中，不会有填充边跳过 $i+1$ 连接到更远的节点。因此，对于 $i=1, \\dots, n-1$，超节点 $i$ 的父节点总是 $i+1$。\n$$\n\\mathrm{parent}(i) = i+1 \\quad \\text{for } i=1, \\dots, n-1\n$$\n超节点 $n$ 是最后一个被消元的，因此它是根节点。消元树的结构是一条长链：$1 \\to 2 \\to \\dots \\to n-1 \\to n$。\n这条链的长度为 $n-1$，包含 $n$ 个顶点。因此，消元树的高度是 $H_{\\mathrm{nat}} = n$。\n\n**(b) 最小度排序：$\\pi_{\\mathrm{md}}$**\n\n在路径图 $P_n$ 中，内部节点（$2, \\dots, n-1$）的度为 $2$，而端点节点（$1$ 和 $n$）的度为 $1$。\n1.  在第一步，最小度为 $1$，由节点 $1$ 和 $n$ 共享。根据决胜规则（选择最小索引），我们选择节点 $1$ 进行消元。$\\pi_{\\mathrm{md}}$ 的第一个元素是 $1$。\n2.  在更新后的图（在 $\\{2, \\dots, n\\}$ 上的路径）中，节点 $2$ 的度变为 $1$，而节点 $n$ 的度仍为 $1$。再次应用决胜规则，我们选择节点 $2$。\n3.  这个过程一直持续下去。该算法将依次选择 $1, 2, 3, \\dots, n$。\n因此，对于路径图和给定的决胜规则，最小度排序与自然排序完全相同：$\\pi_{\\mathrm{md}} = \\pi_{\\mathrm{nat}}$。\n所以，消元树的高度也是 $H_{\\mathrm{md}} = n$。\n\n**(c) 嵌套剖分排序：$\\pi_{\\mathrm{nd}}$**\n\n对于 $n = 2^k - 1$ 的路径图，嵌套剖分算法如下：\n1.  找到中心节点作为分隔符。对于 $\\{1, \\dots, n\\}$，中心节点是 $(n+1)/2$。\n2.  将剩余节点划分为两个大小相等的子路径（左和右）。\n3.  递归地对左子路径排序，然后对右子路径排序，最后是分隔符。\n\n对于这种排序，消元树的结构是一个高度平衡的二叉树。每个分隔符成为其对应子路径中所有节点的祖先。根节点是第一个（最高级别）分隔符。它的子节点是第二级分隔符，依此类推。\n树的高度由递归的深度决定。因为每次我们将问题大小减半，所以递归深度为 $k$。因此，消元树的高度是 $H_{\\mathrm{nd}} = k$。\n由于 $n = 2^k - 1$，我们可以解出 $k = \\log_2(n+1)$。\n所以，$H_{\\mathrm{nd}} = \\log_2(n+1)$。\n\n### 计算 $H_{\\mathrm{nat}} - H_{\\mathrm{nd}}$ 对于 $n=15$\n\n对于 $n=15$：\n-   $k = \\log_2(15+1) = \\log_2(16) = 4$。因此，$n=15$ 满足 $n=2^k-1$ 的形式。\n-   自然排序下的高度：$H_{\\mathrm{nat}} = n = 15$。\n-   嵌套剖分排序下的高度：$H_{\\mathrm{nd}} = \\log_2(n+1) = \\log_2(16) = 4$。\n\n差值为：\n$$\nH_{\\mathrm{nat}} - H_{\\mathrm{nd}} = 15 - 4 = 11。\n$$",
            "answer": "$$\n\\boxed{11}\n$$"
        }
    ]
}