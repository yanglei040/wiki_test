{
    "hands_on_practices": [
        {
            "introduction": "A fundamental task in systems biology is to determine the causal scope of an initial cellular state. For instance, given a set of available proteins and metabolites, which downstream targets can be activated or synthesized? This exercise  challenges you to model this problem as a reachability analysis on a reaction hypergraph, where reactions connect multiple substrates to multiple products. You will adapt the classic Breadth-First Search (BFS) algorithm to find a minimal reaction pathway, adding a crucial layer of biological realism by enforcing stoichiometric constraints on reaction feasibility.",
            "id": "3317626",
            "problem": "Consider a reaction hypergraph for a biochemical network in computational systems biology. Let the set of molecular species be $\\mathcal{S}$ and the set of reactions be $\\mathcal{R}$. Each reaction $r \\in \\mathcal{R}$ has a substrate multiset $\\mathrm{Subs}(r) = \\{(s_i, \\alpha_i)\\}$ and a product multiset $\\mathrm{Prods}(r) = \\{(p_j, \\beta_j)\\}$, where $s_i, p_j \\in \\mathcal{S}$ and $\\alpha_i, \\beta_j \\in \\mathbb{N}$ are stoichiometric coefficients. Let $A_0$ be an initial multiset of available species with counts $c_0 : \\mathcal{S} \\to \\mathbb{N}$. Define the incidence graph $\\mathcal{G}$ as a bipartite graph with node set $\\mathcal{S} \\cup \\mathcal{R}$ and edges from species to reactions $(s \\to r)$ whenever $(s, \\alpha) \\in \\mathrm{Subs}(r)$, and from reactions to species $(r \\to p)$ whenever $(p, \\beta) \\in \\mathrm{Prods}(r)$.\n\nWe aim to compute a minimal reaction set that can reach a designated transcription factor $t \\in \\mathcal{S}$ under the following monotone availability semantics: species are not consumed when reactions fire; presence is monotone over breadth-first layers. Stoichiometric constraints are incorporated by edge feasibility checks: a reaction node $r$ is traversable only after, for each substrate $(s, \\alpha) \\in \\mathrm{Subs}(r)$, at least $\\alpha$ tokens of $s$ have become available through the initial set $A_0$ or by products of previously traversed reactions. Let the depth of a species be the minimal number of reactions needed to make it available from $A_0$, and the depth of a reaction be one plus the maximum depth among the substrate tokens that enabled it.\n\nFundamental base assumptions and definitions:\n- The stoichiometric matrix $N \\in \\mathbb{Z}^{|\\mathcal{S}| \\times |\\mathcal{R}|}$ has entries $N_{s,r} = \\beta_{s,r} - \\alpha_{s,r}$, where $\\alpha_{s,r}$ is the substrate coefficient for species $s$ in reaction $r$ (zero if absent) and $\\beta_{s,r}$ is the product coefficient (zero if absent).\n- Incidence graph breadth-first search (BFS) on unweighted graphs yields paths that minimize the number of traversed edges. In the bipartite incidence structure, any path from a species to a species alternates species and reaction nodes; minimizing path length induces minimizing the number of reaction nodes traversed, provided traversability is gated by substrate availability.\n- Under the monotone availability semantics typical for signal transduction and transcriptional regulation where species act catalytically and are not consumed, the reachability of $t$ is determined by satisfaction of substrate multiplicities without depletion.\n\nTask:\nDesign a program that, given reaction definitions, initial species counts, and a target transcription factor $t$, performs a constrained BFS over the incidence graph to find a minimal set of reactions that reaches $t$. A reaction is eligible to fire only when, for each $(s, \\alpha) \\in \\mathrm{Subs}(r)$, at least $\\alpha$ copies of $s$ have appeared in earlier or current BFS layers. When a reaction fires at depth $d_r$, it yields product events $(p, \\beta)$ at the same depth $d_r$. The minimal reaction set must be reconstructed by following the actual substrate tokens used to enable each reaction, thereby incorporating stoichiometric constraints into the dependency chain. If $t$ is initially available in $A_0$, the minimal reaction set is the empty list. If $t$ is not reachable, return a boolean false and the empty list.\n\nYour program must solve the following test suite. Each test case is specified by a list of reactions, an initial count map, and a target $t$. Reaction identifiers are zero-based indices within each test case, and reactions are given as ordered pairs of multisets $(\\mathrm{Subs}, \\mathrm{Prods})$ encoded as maps from species names to integer stoichiometric coefficients.\n\nTest suite:\n1. Happy path chain with distinct substrates and products.\n   - Species: $\\{A, B, C, D, E, TF\\}$.\n   - Reactions:\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(A, 1), (B, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(C, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(C, 1)\\}$, $\\mathrm{Prods}(r_1) = \\{(D, 1)\\}$.\n     - $r_2$: $\\mathrm{Subs}(r_2) = \\{(D, 1), (E, 1)\\}$, $\\mathrm{Prods}(r_2) = \\{(TF, 1)\\}$.\n   - Initial counts: $c_0(A) = 1$, $c_0(B) = 1$, $c_0(E) = 1$; all others $0$.\n   - Target: $t = TF$.\n   - Expected result type: a list containing a boolean and a list of reaction identifiers ordered by nondecreasing reaction depth.\n\n2. Boundary case where the target is initially available.\n   - Same reactions as case 1.\n   - Initial counts: $c_0(A) = 1$, $c_0(B) = 1$, $c_0(E) = 1$, $c_0(TF) = 1$; all others $0$.\n   - Target: $t = TF$.\n\n3. Stoichiometric edge case requiring multiple copies of a substrate.\n   - Species: $\\{X, Y, Z\\}$.\n   - Reactions:\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(Z, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(X, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(X, 2)\\}$, $\\mathrm{Prods}(r_1) = \\{(Y, 1)\\}$.\n   - Initial counts: $c_0(X) = 1$, $c_0(Z) = 1$; all others $0$.\n   - Target: $t = Y$.\n\n4. Unreachable target under given reactions.\n   - Species: $\\{U, TF, A\\}$.\n   - Reactions:\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(U, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(TF, 1)\\}$.\n   - Initial counts: $c_0(A) = 1$; all others $0$.\n   - Target: $t = TF$.\n\n5. Branching prerequisites for the target.\n   - Species: $\\{A, P, Q, TF\\}$.\n   - Reactions:\n     - $r_0$: $\\mathrm{Subs}(r_0) = \\{(A, 1)\\}$, $\\mathrm{Prods}(r_0) = \\{(P, 1)\\}$.\n     - $r_1$: $\\mathrm{Subs}(r_1) = \\{(A, 1)\\}$, $\\mathrm{Prods}(r_1) = \\{(Q, 1)\\}$.\n     - $r_2$: $\\mathrm{Subs}(r_2) = \\{(P, 1), (Q, 1)\\}$, $\\mathrm{Prods}(r_2) = \\{(TF, 1)\\}$.\n   - Initial counts: $c_0(A) = 1$; all others $0$.\n   - Target: $t = TF$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, where each result is itself a two-element list of the form $[\\text{reachable}, \\text{reaction\\_id\\_list}]$. For example, the output must look like\n$[[\\text{True},[0,1,2]],[\\text{True},[]],[\\text{True},[0,1]],[\\text{False},[]],[\\text{True},[0,1,2]]]$.\nNo physical units are involved, and the outputs are unitless. Angles do not apply, and no percentages are used.",
            "solution": "The problem asks for the determination of a minimal set of reactions required to produce a target molecular species, starting from an initial set of available species. The system operates under a non-consumptive, monotone availability model, meaning species counts only increase over time. The problem is best modeled as a constrained reachability analysis on the reaction network, which can be solved using a breadth-first search (BFS)-like iterative algorithm to determine reaction depths, followed by a dependency-aware backtracking algorithm to construct the minimal reaction set.\n\nThe overall approach consists of two main phases: a forward pass to determine reachability and minimal depths, and a backward pass to reconstruct the specific reaction pathway.\n\n**Phase 1: Forward Propagation (Reachability and Depth Analysis)**\n\nThe forward pass simulates the reaction network layer by layer, akin to a BFS. Each \"layer\" corresponds to an increase in the number of reaction steps from the initial state.\n\n1.  **Initialization**:\n    - All unique species names are mapped to integer indices for efficient processing, from $0$ to $|\\mathcal{S}|-1$. Reactions are identified by their indices, $0$ to $|\\mathcal{R}|-1$.\n    - An array `species_counts` of size $|\\mathcal{S}|$ is initialized with the initial counts $c_0$.\n    - An array `species_depth`, tracking the minimal number of reactions to produce each species, is initialized to infinity (a sentinel value like $-1$) for all species, and to $0$ for species present in the initial set $A_0$.\n    - An array `reaction_depth` of size $|\\mathcal{R}|$ is initialized to infinity.\n    - A set `fired_reactions` is used to keep track of all reactions that have been triggered.\n\n2.  **Iterative Firing**: The algorithm proceeds in iterations. In each iteration, it scans all reactions to find those that have become newly eligible to fire.\n    - A reaction $r$ is deemed eligible if:\n        1.  It has not been fired in a previous iteration.\n        2.  For every substrate $(s, \\alpha) \\in \\mathrm{Subs}(r)$, the current total count of species $s$ is at least $\\alpha$.\n        3.  All substrates $s$ are themselves available (i.e., `species_depth[s]` is not infinity).\n    - If a set of new reactions becomes eligible in an iteration, they are considered to fire simultaneously in the current \"layer\".\n    - For each newly fired reaction $r$:\n        - It is added to the `fired_reactions` set.\n        - Its depth, `reaction_depth[r]`, is calculated as $1 + \\max_{s \\in \\mathrm{Subs}(r)} \\{\\text{species\\_depth}[s]\\}$.\n        - For each product $(p, \\beta) \\in \\mathrm{Prods}(r)$, the total count `species_counts[p]` is increased by $\\beta$.\n        - The depth of the product `species_depth[p]` is updated to `reaction_depth[r]` if this new path is shorter than any previously found path to produce $p$.\n\n3.  **Termination**: The iterative process continues until a full pass over all reactions yields no new reactions to fire. At this point, the system has reached a fixed point. If the `species_depth` of the target species $t$ is still infinity, the target is unreachable.\n\n**Phase 2: Backward Propagation (Dependency Reconstruction)**\n\nIf the target $t$ is reachable, a backward search from $t$ is performed to identify the minimal set of reactions. This is not a simple path-following, as stoichiometric requirements must be met. The reconstruction must trace the origin of every required substrate \"token\".\n\n1.  **Initialization**:\n    - A dictionary `needed_species` is created to track the required counts of species, initialized with `{t: 1}`.\n    - A set `required_reactions` is initialized to be empty.\n\n2.  **Recursive Dependency Resolution**: The algorithm iteratively processes the `needed_species` list.\n    - For a species $s$ with a required count of $k$:\n        - The count available from the initial set, $c_0(s)$, is subtracted from $k$, leaving a `deficit`.\n        - If the `deficit` is positive, we must find reactions that produced $s$ to cover this deficit.\n        - The algorithm queries the set of `fired_reactions` from the forward pass to find all reactions that produce $s$. These are sorted by their `reaction_depth` to ensure we use the \"fastest\" production routes first, consistent with the minimal path objective.\n        - Reactions are added to the `required_reactions` set one by one from this sorted list until the `deficit` is covered.\n        - For each reaction added to the set, its own substrate requirements are added to the `needed_species` dictionary, propagating the backtracking process.\n\n3.  **Finalization**: The process terminates when the `needed_species` dictionary is empty. The resulting `required_reactions` set is converted to a list and sorted by non-decreasing reaction depth (with reaction index as a tie-breaker), as specified.\n\nThis two-phase approach correctly models the problem. The forward pass establishes the global context of what is possible and how quickly, while the backward pass performs a goal-directed search within that context to build the minimal causal chain satisfying all stoichiometric constraints.",
            "answer": "```python\nimport numpy as np\n\ndef find_minimal_reactions(reactions_def, initial_counts_def, target_species):\n    \"\"\"\n    Finds a minimal set of reactions to produce a target species.\n    \"\"\"\n    # 1. Initialization and mapping\n    all_species = set(initial_counts_def.keys())\n    all_species.add(target_species)\n    for subs, prods in reactions_def:\n        all_species.update(subs.keys())\n        all_species.update(prods.keys())\n    \n    sorted_species_list = sorted(list(all_species))\n    species_to_id = {name: i for i, name in enumerate(sorted_species_list)}\n    id_to_species = {i: name for i, name in enumerate(sorted_species_list)}\n    num_species = len(sorted_species_list)\n    num_reactions = len(reactions_def)\n\n    if not all_species:\n        return [False, []]\n    \n    reactions = []\n    for subs, prods in reactions_def:\n        reactions.append({\n            'subs': {species_to_id[s]: v for s, v in subs.items()},\n            'prods': {species_to_id[p]: v for p, v in prods.items()}\n        })\n\n    # Phase 1: Forward Propagation\n    species_counts = np.zeros(num_species, dtype=int)\n    for s, c in initial_counts_def.items():\n        if s in species_to_id:\n            species_counts[species_to_id[s]] = c\n\n    species_depth = np.full(num_species, -1, dtype=int)\n    for i in range(num_species):\n        if species_counts[i] > 0:\n            species_depth[i] = 0\n\n    reaction_depth = np.full(num_reactions, -1, dtype=int)\n    fired_reactions = set()\n\n    while True:\n        newly_eligible = []\n        for r_id in range(num_reactions):\n            if r_id in fired_reactions:\n                continue\n\n            is_eligible = True\n            max_sub_depth = 0\n            if not reactions[r_id]['subs']:\n                pass\n            else:\n                for s_id, stoich in reactions[r_id]['subs'].items():\n                    if species_counts[s_id]  stoich or species_depth[s_id] == -1:\n                        is_eligible = False\n                        break\n                    max_sub_depth = max(max_sub_depth, species_depth[s_id])\n            \n            if is_eligible:\n                newly_eligible.append((r_id, max_sub_depth))\n        \n        if not newly_eligible:\n            break\n\n        for r_id, max_sub_depth in newly_eligible:\n            fired_reactions.add(r_id)\n            r_depth = 1 + max_sub_depth\n            reaction_depth[r_id] = r_depth\n            \n            for p_id, stoich in reactions[r_id]['prods'].items():\n                species_counts[p_id] += stoich\n                if species_depth[p_id] == -1 or r_depth  species_depth[p_id]:\n                    species_depth[p_id] = r_depth\n\n    # Check reachability of the target\n    target_id = species_to_id.get(target_species)\n    if target_id is None or species_depth[target_id] == -1:\n        return [False, []]\n    \n    if species_depth[target_id] == 0:\n        return [True, []]\n\n    # Phase 2: Backward Propagation\n    required_reactions = set()\n    needed_species = {target_id: 1}\n    \n    # Using a list as a stack for deterministic processing\n    agenda = list(needed_species.items())\n\n    while agenda:\n        s_id, num_needed = agenda.pop(0)\n\n        initial_avail = initial_counts_def.get(id_to_species[s_id], 0)\n        deficit = num_needed - initial_avail\n        \n        if deficit = 0:\n            continue\n            \n        producers = []\n        for r_id in fired_reactions:\n            if s_id in reactions[r_id]['prods']:\n                producers.append(r_id)\n        \n        producers.sort(key=lambda r_id: (reaction_depth[r_id], r_id))\n        \n        covered_deficit = 0\n        for p_rid in producers:\n            if p_rid in required_reactions:\n                # If we've already included this reaction for other needs,\n                # just account for its production without re-adding its substrates\n                amount_made = reactions[p_rid]['prods'][s_id]\n                covered_deficit += amount_made\n                if covered_deficit >= deficit: break\n                continue\n\n            required_reactions.add(p_rid)\n            amount_made = reactions[p_rid]['prods'][s_id]\n            covered_deficit += amount_made\n            \n            for sub_id, stoich in reactions[p_rid]['subs'].items():\n                # Naive addition to a dictionary `needed_species` could be non-deterministic.\n                # To handle cumulative needs, let's update a separate dictionary.\n                current_needs_map = dict(agenda)\n                current_needs_map[sub_id] = current_needs_map.get(sub_id, 0) + stoich\n                agenda = list(current_needs_map.items())\n\n            if covered_deficit >= deficit:\n                break\n    \n    sorted_reqs = sorted(list(required_reactions), key=lambda r: (reaction_depth[r], r))\n    \n    return [True, sorted_reqs]\n\ndef solve():\n    test_cases = [\n        # 1. Happy path chain\n        ([({'A': 1, 'B': 1}, {'C': 1}), ({'C': 1}, {'D': 1}), ({'D': 1, 'E': 1}, {'TF': 1})],\n         {'A': 1, 'B': 1, 'E': 1}, 'TF'),\n        # 2. Target initially available\n        ([({'A': 1, 'B': 1}, {'C': 1}), ({'C': 1}, {'D': 1}), ({'D': 1, 'E': 1}, {'TF': 1})],\n         {'A': 1, 'B': 1, 'E': 1, 'TF': 1}, 'TF'),\n        # 3. Stoichiometric edge case\n        ([({'Z': 1}, {'X': 1}), ({'X': 2}, {'Y': 1})],\n         {'X': 1, 'Z': 1}, 'Y'),\n        # 4. Unreachable target\n        ([({'U': 1}, {'TF': 1})], \n         {'A': 1}, 'TF'),\n        # 5. Branching prerequisites\n        ([({'A': 1}, {'P': 1}), ({'A': 1}, {'Q': 1}), ({'P': 1, 'Q': 1}, {'TF': 1})],\n         {'A': 1}, 'TF')\n    ]\n\n    results = []\n    for reactions_def, initial_counts_def, target_species in test_cases:\n        result = find_minimal_reactions(reactions_def, initial_counts_def, target_species)\n        results.append(result)\n\n    result_strings = []\n    for r in results:\n        reachable_str = str(r[0])\n        reactions_str = str(r[1]).replace(\" \", \"\")\n        result_strings.append(f'[{reachable_str},{reactions_str}]')\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Biological networks are not random webs; they are structured by recurring patterns of interaction known as network motifs, which serve as elementary information processing units. This practice  focuses on identifying one of the most well-studied motifs, the feed-forward loop, within a gene regulatory network. You will implement a traversal-based search to enumerate these motifs and, critically, investigate how the statistical significance threshold $\\alpha$ used to prune network edges impacts the discovery rate and false negatives, a core trade-off in analyzing noisy biological data.",
            "id": "3317654",
            "problem": "A directed gene regulatory interaction network can be modeled as a directed graph $G = (V,E)$ with $V$ a finite set of genes and $E \\subseteq V \\times V$ a set of directed edges. Each directed edge $e \\in E$ is associated with a statistical significance value $p_e \\in (0,1]$ arising from a hypothesis test of interaction presence under a null model. A constrained traversal imposes that an edge is traversable only if it satisfies the significance constraint $p_e  \\alpha$, where $\\alpha \\in (0,1]$ is a user-chosen significance threshold. In network motif analysis, a feed-forward loop motif (defined here as a three-node directed motif) consists of an ordered triple $(u,v,w) \\in V^3$ with $u,v,w$ distinct such that $(u,v) \\in E$, $(u,w) \\in E$, and $(v,w) \\in E$. This structure is a widely studied regulatory motif in transcriptional networks of computational systems biology.\n\nConsider the following specific instance. Let $V = \\{A,B,C,D,E,F,G\\}$ and let $E$ and edge significance values $p_e$ be given by:\n- $A \\to B$ with $p_{A\\to B} = 0.004$\n- $A \\to C$ with $p_{A\\to C} = 0.02$\n- $A \\to D$ with $p_{A\\to D} = 0.001$\n- $A \\to E$ with $p_{A\\to E} = 0.2$\n- $A \\to F$ with $p_{A\\to F} = 0.05$\n- $B \\to C$ with $p_{B\\to C} = 0.03$\n- $B \\to D$ with $p_{B\\to D} = 0.008$\n- $B \\to E$ with $p_{B\\to E} = 0.06$\n- $B \\to F$ with $p_{B\\to F} = 0.5$\n- $C \\to E$ with $p_{C\\to E} = 0.0005$\n- $C \\to F$ with $p_{C\\to F} = 0.07$\n- $C \\to G$ with $p_{C\\to G} = 0.09$\n- $D \\to E$ with $p_{D\\to E} = 0.015$\n- $D \\to F$ with $p_{D\\to F} = 0.04$\n- $E \\to F$ with $p_{E\\to F} = 0.009$\n- $E \\to G$ with $p_{E\\to G} = 0.012$\n- $F \\to G$ with $p_{F\\to G} = 0.02$\n\nDefine the ground-truth feed-forward loop motifs as those that exist when no pruning is applied, i.e., as all ordered triples $(u,v,w)$ with $u,v,w$ distinct such that $(u,v),(u,w),(v,w) \\in E$ in the full graph $G$ as specified above, irrespective of $p_e$. For a given threshold $\\alpha$, define the pruned graph $G_{\\alpha} = (V,E_{\\alpha})$ where $E_{\\alpha} = \\{ e \\in E \\mid p_e  \\alpha \\}$, and define the discovered motifs at threshold $\\alpha$ as those triples $(u,v,w)$ satisfying the motif condition in $G_{\\alpha}$. Let $M_{\\text{true}}$ be the total number of ground-truth motifs, and let $M_{\\text{disc}}(\\alpha)$ be the number of discovered motifs under pruning at threshold $\\alpha$. Define the discovery rate as $r(\\alpha) = M_{\\text{disc}}(\\alpha) / M_{\\text{true}}$ (a decimal in $[0,1]$), and define the false negatives as $FN(\\alpha) = M_{\\text{true}} - M_{\\text{disc}}(\\alpha)$ (an integer).\n\nTask. Write a complete program that:\n- Constructs $G$ with the specified $V$, $E$, and $p_e$ values.\n- Computes $M_{\\text{true}}$ by enumerating all feed-forward loop motifs in the full graph using a traversal-based search that only inspects adjacency relationships and respects the directed motif definition.\n- For each threshold $\\alpha$ in the given test suite, constructs $G_{\\alpha}$ by pruning edges with $p_e \\ge \\alpha$, enumerates discovered motifs, and computes $r(\\alpha)$ and $FN(\\alpha)$.\n- Uses a graph traversal and search algorithm to enumerate motifs by exploring, for each node $u \\in V$, all ordered pairs of distinct out-neighbors $(v,w)$ and checking the existence of the directed edge $(v,w)$.\n\nTest suite. Use the following thresholds for $\\alpha$: $\\{1.0, 0.1, 0.05, 0.02, 0.012, 0.009, 0.0\\}$. These cases include a no-pruning scenario ($\\alpha = 1.0$), moderate pruning ($\\alpha = 0.1$), a conventional cutoff ($\\alpha = 0.05$), thresholds exactly equal to some edge $p_e$ values to test the strict inequality condition ($\\alpha = 0.02$, $\\alpha = 0.012$, $\\alpha = 0.009$), and complete pruning ($\\alpha = 0.0$).\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case in the given order and is itself a two-element list $[r(\\alpha), FN(\\alpha)]$. The discovery rate $r(\\alpha)$ must be expressed as a decimal rounded to three digits after the decimal point, and $FN(\\alpha)$ must be an integer. For example, a valid output format with two hypothetical cases would be $[[0.750,2],[0.333,4]]$. There are no physical units or angles involved in this problem.",
            "solution": "The user-provided problem statement is subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n\n- **Graph Definition**: A directed graph $G = (V,E)$ where $V$ is a set of genes and $E$ is a set of directed edges.\n- **Vertex Set**: $V = \\{A,B,C,D,E,F,G\\}$.\n- **Edge Set and Significance Values ($p_e$)**:\n  - $(A,B)$, $p=0.004$\n  - $(A,C)$, $p=0.02$\n  - $(A,D)$, $p=0.001$\n  - $(A,E)$, $p=0.2$\n  - $(A,F)$, $p=0.05$\n  - $(B,C)$, $p=0.03$\n  - $(B,D)$, $p=0.008$\n  - $(B,E)$, $p=0.06$\n  - $(B,F)$, $p=0.5$\n  - $(C,E)$, $p=0.0005$\n  - $(C,F)$, $p=0.07$\n  - $(C,G)$, $p=0.09$\n  - $(D,E)$, $p=0.015$\n  - $(D,F)$, $p=0.04$\n  - $(E,F)$, $p=0.009$\n  - $(E,G)$, $p=0.012$\n  - $(F,G)$, $p=0.02$\n- **Traversal Constraint**: An edge $e$ is traversable if its significance $p_e$ satisfies $p_e  \\alpha$, where $\\alpha \\in (0,1]$ is a significance threshold.\n- **Feed-Forward Loop (FFL) Motif Definition**: An ordered triple of distinct vertices $(u,v,w) \\in V^3$ such that $(u,v) \\in E$, $(u,w) \\in E$, and $(v,w) \\in E$.\n- **Ground-Truth Motifs ($M_{\\text{true}}$)**: The total number of FFL motifs in the full graph $G$ irrespective of $p_e$ values.\n- **Pruned Graph ($G_{\\alpha}$)**: $G_{\\alpha} = (V,E_{\\alpha})$ where $E_{\\alpha} = \\{ e \\in E \\mid p_e  \\alpha \\}$.\n- **Discovered Motifs ($M_{\\text{disc}}(\\alpha)$)**: The number of FFL motifs present in the pruned graph $G_{\\alpha}$.\n- **Discovery Rate ($r(\\alpha)$)**: $r(\\alpha) = M_{\\text{disc}}(\\alpha) / M_{\\text{true}}$, rounded to three decimal places.\n- **False Negatives ($FN(\\alpha)$)**: $FN(\\alpha) = M_{\\text{true}} - M_{\\text{disc}}(\\alpha)$, an integer.\n- **Task Requirement**: Implement a program to compute $r(\\alpha)$ and $FN(\\alpha)$ for a given test suite of $\\alpha$ values, using a traversal-based search for FFL enumeration.\n- **Test Suite**: $\\alpha \\in \\{1.0, 0.1, 0.05, 0.02, 0.012, 0.009, 0.0\\}$.\n- **Output Format**: A single line `[[r1,fn1],[r2,fn2],...]`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the established criteria:\n- **Scientifically Grounded**: The problem uses standard and well-accepted concepts from computational systems biology and graph theory. Modeling gene networks as directed graphs, using p-values for edge confidence, and analyzing network motifs like the feed-forward loop are all fundamental practices in the field. The setup is scientifically sound.\n- **Well-Posed**: All terms ($G, V, E, p_e, \\alpha$, FFL motif, $M_{\\text{true}}, M_{\\text{disc}}, r, FN$) are precisely and mathematically defined. The set of inputs (graph structure, test thresholds) is complete, and the required outputs are unambiguously specified. A unique solution exists and can be determined algorithmically.\n- **Objective**: The problem statement is free of subjectivity, speculation, or opinion. It is presented in formal, objective language.\n- **Completeness and Consistency**: The problem is self-contained. All data required for the solution (node set, edge set, p-values, thresholds) are provided. There are no contradictions in the definitions or constraints. The strict inequality $p_e  \\alpha$ is clearly stated.\n- **Realism**: The network structure and associated p-values are plausible for a small-scale biological network analysis.\n- **Structure and Triviality**: The problem is well-structured and requires a non-trivial algorithmic implementation. The task involves graph representation, motif enumeration under varying constraints, and calculation of derived metrics, which constitutes a legitimate computational problem.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is scientifically grounded, well-posed, objective, and complete. A solution will be provided.\n\n### Solution\n\nThe solution to this problem requires a systematic enumeration of feed-forward loop (FFL) motifs in a directed graph under varying edge-pruning conditions. The core of the methodology is a graph traversal algorithm tailored to find the specific three-node FFL structure.\n\n**1. Graph Representation**\nA directed graph with associated edge weights (in this case, p-values) can be efficiently represented using an adjacency list. A dictionary of dictionaries is a suitable implementation in Python, where `graph[u][v]` stores the p-value of the directed edge from node $u$ to node $v$. The complete set of nodes $V$ is also stored.\n\n**2. Algorithm for FFL Enumeration**\nThe problem defines an FFL as an ordered triple of distinct nodes $(u,v,w)$ such that edges $(u,v)$, $(u,w)$, and $(v,w)$ exist. A direct algorithm to find these motifs, as suggested by the problem, is as follows:\n- Iterate through each node $u \\in V$. This node $u$ is a candidate for the source of an FFL.\n- For each $u$, obtain its set of direct out-neighbors.\n- Iterate through all distinct ordered pairs of out-neighbors, $(v,w)$.\n- For each pair, check if a directed edge $(v,w)$ exists.\n- If the edge $(v,w)$ exists, the triple $(u,v,w)$ forms an FFL.\n\nThis process is encapsulated in a function, `count_ffls(adj_list)`, which takes an adjacency list as input and returns the total count of FFLs. An adjacency list for this function will map each node to a set of its out-neighbors.\n\n**3. Ground-Truth Calculation ($M_{\\text{true}}$)**\nFirst, we must determine the total number of FFLs in the unpruned, complete graph $G$. This is $M_{\\text{true}}$. An adjacency list representing the full graph is constructed, where an edge exists regardless of its p-value. The `count_ffls` function is then applied to this full adjacency list.\n\nLet's manually enumerate $M_{\\text{true}}$ to verify the algorithm's baseline.\n- For $u=A$, out-neighbors are $\\{B, C, D, E, F\\}$. Checking pairs:\n  - $(B,C)$: $A \\to B, A \\to C$. Edge $B \\to C$ exists. **FFL: (A,B,C)**\n  - $(B,D)$: $A \\to B, A \\to D$. Edge $B \\to D$ exists. **FFL: (A,B,D)**\n  - $(B,E)$: $A \\to B, A \\to E$. Edge $B \\to E$ exists. **FFL: (A,B,E)**\n  - $(B,F)$: $A \\to B, A \\to F$. Edge $B \\to F$ exists. **FFL: (A,B,F)**\n  - $(C,E)$: $A \\to C, A \\to E$. Edge $C \\to E$ exists. **FFL: (A,C,E)**\n  - $(C,F)$: $A \\to C, A \\to F$. Edge $C \\to F$ exists. **FFL: (A,C,F)**\n  - $(D,E)$: $A \\to D, A \\to E$. Edge $D \\to E$ exists. **FFL: (A,D,E)**\n  - $(D,F)$: $A \\to D, A \\to F$. Edge $D \\to F$ exists. **FFL: (A,D,F)**\n  - $(E,F)$: $A \\to E, A \\to F$. Edge $E \\to F$ exists. **FFL: (A,E,F)**\n  (Total from A: $9$)\n- For $u=B$, out-neighbors are $\\{C, D, E, F\\}$. Checking pairs:\n  - $(C,E)$: $B \\to C, B \\to E$. Edge $C \\to E$ exists. **FFL: (B,C,E)**\n  - $(C,F)$: $B \\to C, B \\to F$. Edge $C \\to F$ exists. **FFL: (B,C,F)**\n  - $(D,E)$: $B \\to D, B \\to E$. Edge $D \\to E$ exists. **FFL: (B,D,E)**\n  - $(D,F)$: $B \\to D, B \\to F$. Edge $D \\to F$ exists. **FFL: (B,D,F)**\n  (Total from B: $4$)\n- For $u=C$, out-neighbors are $\\{E, F, G\\}$. Checking pairs:\n  - $(E,F)$: $C \\to E, C \\to F$. Edge $E \\to F$ exists. **FFL: (C,E,F)**\n  - $(E,G)$: $C \\to E, C \\to G$. Edge $E \\to G$ exists. **FFL: (C,E,G)**\n  - $(F,G)$: $C \\to F, C \\to G$. Edge $F \\to G$ exists. **FFL: (C,F,G)**\n  (Total from C: $3$)\n- For $u=D$, out-neighbors are $\\{E, F\\}$. Checking pairs:\n  - $(E,F)$: $D \\to E, D \\to F$. Edge $E \\to F$ exists. **FFL: (D,E,F)**\n  (Total from D: $1$)\n- For $u=E$, out-neighbors are $\\{F, G\\}$. Checking pairs:\n  - $(F,G)$: $E \\to F, E \\to G$. Edge $F \\to G$ exists. **FFL: (E,F,G)**\n  (Total from E: $1$)\n- Nodes F and G have fewer than two out-neighbors and cannot be FFL sources.\nTotal ground-truth motifs: $M_{\\text{true}} = 9 + 4 + 3 + 1 + 1 = 18$.\n\n**4. Calculation for each Threshold $\\alpha$**\nThe main loop iterates through each $\\alpha$ in the provided test suite. For each $\\alpha$:\n- A new, pruned adjacency list for $G_{\\alpha}$ is constructed. This is done by iterating through all edges $(u, v)$ in the original full graph and including an edge in the pruned list only if its p-value $p_{u \\to v}$ is strictly less than $\\alpha$.\n- The `count_ffls` function is called with this pruned adjacency list to compute $M_{\\text{disc}}(\\alpha)$.\n- The discovery rate $r(\\alpha) = M_{\\text{disc}}(\\alpha) / M_{\\text{true}}$ and false negatives $FN(\\alpha) = M_{\\text{true}} - M_{\\text{disc}}(\\alpha)$ are calculated. If $M_{\\text{true}}$ were $0$, $r(\\alpha)$ would be defined as $0$ to avoid division by zero.\n- The resulting pair $[r(\\alpha), FN(\\alpha)]$ is stored, with $r(\\alpha)$ formatted to three decimal places.\n\n**5. Final Output Generation**\nAfter processing all $\\alpha$ values, the list of result pairs is formatted into the specified single-line string format: `[[r1,fn1],[r2,fn2],...]`. For example, a rate of $1.0$ is formatted as $1.000$.\n\nThis systematic procedure ensures that each test case is correctly evaluated according to the problem's strict definitions. The use of a dedicated FFL counting function operating on a dynamically generated pruned graph separates concerns and leads to a clean and correct implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the graph theory problem for computational systems biology.\n    - Constructs the gene regulatory network.\n    - Computes ground-truth feed-forward loop (FFL) motifs.\n    - For each alpha threshold, computes discovered motifs, discovery rate, \n      and false negatives.\n    - Formats the output as specified.\n    \"\"\"\n\n    # Step 1: Define the graph V, E, and p-values\n    V = {'A', 'B', 'C', 'D', 'E', 'F', 'G'}\n    \n    # Store the graph with p-values in a adjacency list-style dictionary\n    graph_data = {\n        'A': {'B': 0.004, 'C': 0.02, 'D': 0.001, 'E': 0.2, 'F': 0.05},\n        'B': {'C': 0.03, 'D': 0.008, 'E': 0.06, 'F': 0.5},\n        'C': {'E': 0.0005, 'F': 0.07, 'G': 0.09},\n        'D': {'E': 0.015, 'F': 0.04},\n        'E': {'F': 0.009, 'G': 0.012},\n        'F': {'G': 0.02},\n        'G': {}\n    }\n\n    test_alphas = [1.0, 0.1, 0.05, 0.02, 0.012, 0.009, 0.0]\n\n    def count_ffls(adj_list):\n        \"\"\"\n        Counts the number of feed-forward loops in a graph represented\n        by an adjacency list.\n        An FFL is a motif (u,v,w) where u-v, u-w, and v-w.\n        \"\"\"\n        motif_count = 0\n        nodes = list(adj_list.keys())\n        \n        for u in nodes:\n            # A node needs at least two out-neighbors to be the source of an FFL\n            if u not in adj_list or len(adj_list[u])  2:\n                continue\n            \n            out_neighbors_u = list(adj_list[u])\n            # Iterate over all ordered pairs of distinct out-neighbors\n            for i in range(len(out_neighbors_u)):\n                for j in range(len(out_neighbors_u)):\n                    if i == j:\n                        continue\n                    \n                    v = out_neighbors_u[i]\n                    w = out_neighbors_u[j]\n                    \n                    # Check for the closing edge v-w\n                    if v in adj_list and w in adj_list[v]:\n                        motif_count += 1\n                        \n        return motif_count\n\n    # Step 2: Compute M_true (ground-truth motifs in the full graph)\n    # The full adjacency list includes all defined edges.\n    full_adj_list = {u: set(targets.keys()) for u, targets in graph_data.items()}\n    # Ensure all nodes are in the adj list, even if they have no outgoing edges\n    for node in V:\n        if node not in full_adj_list:\n            full_adj_list[node] = set()\n\n    M_true = count_ffls(full_adj_list)\n    \n    results = []\n\n    # Step 3: Iterate through test cases\n    for alpha in test_alphas:\n        # Construct the pruned graph G_alpha\n        pruned_adj_list = {node: set() for node in V}\n        for u, targets in graph_data.items():\n            for v, p_val in targets.items():\n                if p_val  alpha:\n                    pruned_adj_list[u].add(v)\n        \n        # Compute M_disc(alpha)\n        M_disc = count_ffls(pruned_adj_list)\n        \n        # Compute FN(alpha)\n        FN = M_true - M_disc\n        \n        # Compute r(alpha)\n        if M_true > 0:\n            r = M_disc / M_true\n        else:\n            r = 0.0\n\n        # Store the formatted results for this alpha\n        results.append([r, FN])\n\n    # Step 4: Format the final output string\n    # e.g., [[0.750,2],[0.333,4]]\n    output_parts = []\n    for r_val, fn_val in results:\n        # Use f-string formatting to ensure three decimal places, e.g., 0.750\n        output_parts.append(f'[{r_val:.3f},{fn_val}]')\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Finding the 'best' pathway through a metabolic network is rarely a simple matter of finding the shortest one. Biological efficiency is a multi-faceted objective, often involving trade-offs between path length, energy usage, and the spatial localization of enzymes. In this advanced practice , you will employ the $A^*$ search algorithm to find an optimal path that balances topological distance with a penalty for enzymatic mislocalization. The core challenge lies in designing a custom heuristic function and navigating a state space that tracks not just position but also the cumulative biological 'cost' of the path taken.",
            "id": "3317628",
            "problem": "You are given a directed reaction graph that models a small portion of a metabolic pathway with spatial compartmentalization. Each directed edge represents a reaction step with two attributes: a base step cost and a binary mismatch indicator that approximates whether the reaction’s catalyzing enzyme is suitably localized in the compartment implied by that step. The base step cost represents a topological traversal cost and is always $1$. The mismatch indicator is $0$ if the enzyme localization is compatible and $1$ otherwise. A path is deemed biologically feasible if its cumulative mismatch count does not exceed a specified budget.\n\nYour task is to implement a graph search procedure that uses the A-star (A*) algorithm with a heuristic that linearly penalizes predicted enzyme mislocalizations via a soft constraint. The algorithm must enforce a hard feasibility constraint by pruning partial paths whose mismatch count exceeds the specified budget. The heuristic must be constructed from two admissible lower bounds computed on the reverse graph: the shortest base step distance to the goal and the minimal additional mismatches needed to reach the goal.\n\nFundamental base and definitions:\n- Let the directed graph be $G=(V,E)$, with $V$ the finite set of nodes and $E$ the set of directed edges.\n- Each edge $e=(u \\rightarrow v)$ has attributes: base step cost $c(e) \\in \\{1\\}$ and mismatch penalty $m(e) \\in \\{0,1\\}$.\n- Let $s \\in V$ be the start node and $t \\in V$ be the goal node.\n- For a partial path ending at node $v$, let $g(v)$ denote the cumulative base step cost $\\sum c(e)$ along the path, and let $M(v)$ denote the cumulative mismatch count $\\sum m(e)$ along the path.\n- Let a hard mismatch budget $\\tau \\in \\mathbb{N}$ be given. Any partial path with $M(v)  \\tau$ is pruned and never expanded further.\n- Define the base-step lower-bound heuristic $h_0(v)$ as the length (in total base steps) of a shortest path from $v$ to $t$ in $G$ when ignoring mismatch penalties, i.e., compute shortest paths on the reverse graph using edge weights $c(e)$.\n- Define the mismatch lower-bound $p(v)$ as the minimal number of additional mismatches needed to reach $t$ from $v$, computed on the reverse graph using edge weights $m(e)$.\n- The soft-constraint heuristic is $h(v) = h_0(v) + \\beta \\cdot p(v)$, where $\\beta \\ge 0$ is a scalar hyperparameter.\n- The A-star priority function is $f(v) = g(v) + h(v)$. The search terminates successfully when the goal $t$ is popped from the open set. To simulate computational resource limits, the algorithm must stop and declare failure if the number of node-state expansions exceeds a given cap $L \\in \\mathbb{N}$ before reaching $t$.\n\nState formalization for pruning and dominance:\n- Because pruning depends on cumulative mismatches, the state is the pair $(v,k)$ where $v \\in V$ and $k = M(v) \\in \\{0,1,\\dots,\\tau\\}$. Maintain best-known $g$ for each $(v,k)$ and only improve when a strictly lower $g$ is found for the same $k$.\n\nTie-breaking requirement:\n- When two states have equal $f$, break ties by smaller $p(v)$ first, then by first-discovered order.\n\nGraph specification:\n- Nodes: $V = \\{ s, b_1, b_2, p_1, p_2, p_3, p_4, u_1, u_2, u_3, v_1, v_2, v_3, t \\}$.\n- Directed edges with attributes $(c,m)$, where all $c=1$ and $m \\in \\{0,1\\}$:\n    - $s \\rightarrow b_1$ with $(1,1)$.\n    - $b_1 \\rightarrow b_2$ with $(1,1)$.\n    - $b_2 \\rightarrow t$ with $(1,0)$.\n    - $b_1 \\rightarrow u_1$ with $(1,0)$, $u_1 \\rightarrow v_1$ with $(1,1)$, $v_1 \\rightarrow t$ with $(1,1)$.\n    - $b_1 \\rightarrow u_2$ with $(1,0)$, $u_2 \\rightarrow v_2$ with $(1,1)$, $v_2 \\rightarrow t$ with $(1,1)$.\n    - $b_1 \\rightarrow u_3$ with $(1,0)$, $u_3 \\rightarrow v_3$ with $(1,1)$, $v_3 \\rightarrow t$ with $(1,1)$.\n    - $s \\rightarrow p_1$ with $(1,0)$, $p_1 \\rightarrow p_2$ with $(1,0)$, $p_2 \\rightarrow p_3$ with $(1,0)$, $p_3 \\rightarrow p_4$ with $(1,0)$, $p_4 \\rightarrow t$ with $(1,0)$.\n\nInterpretation:\n- The edges labeled with $m=1$ indicate steps that likely require enzymes not properly localized; these accrue mismatch counts. The $p$-chain ($s \\rightarrow p_1 \\rightarrow p_2 \\rightarrow p_3 \\rightarrow p_4 \\rightarrow t$) is fully consistent ($m=0$), but longer in base steps. The $b$-corridor ($s \\rightarrow b_1 \\rightarrow b_2 \\rightarrow t$) is shorter in base steps but contains mismatches. The $u$-branches ($u_i \\rightarrow v_i \\rightarrow t$) are attractive under the base-step heuristic yet incur additional mismatches, making them infeasible under tight $\\tau$.\n\nYour program must:\n- Precompute $h_0(v)$ for all $v \\in V$ by solving single-source shortest paths from $t$ on the reverse graph using edge weights $c(e)$.\n- Precompute $p(v)$ for all $v \\in V$ by solving single-source shortest paths from $t$ on the reverse graph using edge weights $m(e)$.\n- Implement the A-star algorithm over state space $(v,k)$ with priority $f = g + h_0(v) + \\beta \\cdot p(v)$, hard-pruning any successor with $k'  \\tau$, and stopping with failure if the number of pop operations exceeds $L$.\n- On success, report the base-step length $g(t)$ and the mismatch count $k$ for the popped goal state.\n\nTest suite:\nRun your solver on the following parameter triples $(\\beta,\\tau,L)$:\n- Case $1$: $\\beta = 0.0$, $\\tau = 1$, $L = 8$.\n- Case $2$: $\\beta = 1.0$, $\\tau = 1$, $L = 8$.\n- Case $3$: $\\beta = 0.5$, $\\tau = 1$, $L = 8$.\n- Case $4$: $\\beta = 0.0$, $\\tau = 0$, $L = 6$.\n- Case $5$: $\\beta = 10.0$, $\\tau = 1$, $L = 6$.\n\nFinal output format:\nYour program should produce a single line of output containing a list of results, one per test case, in the same order as above. Each result must be a list of four fundamental values:\n- A boolean indicating whether a feasible path to $t$ was found within the expansion limit.\n- The base-step cost $g(t)$ as an integer if found, or $-1$ otherwise.\n- The total mismatches $k$ as an integer if found, or $-1$ otherwise.\n- The number of node-state expansions performed (pops) as an integer.\n\nFor example, the output should look like a single line:\n[[found1,g1,k1,exp1],[found2,g2,k2,exp2],...]",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, presenting a standard graph-based abstraction of a metabolic network, a common practice in computational systems biology. The problem is well-posed, providing a complete and logically consistent specification of the graph, algorithm (A*), state representation, constraints, and termination conditions. All terms are formally and objectively defined. The task requires the implementation of a specialized search algorithm, which is a non-trivial and verifiable computational problem.\n\nThe solution approach is structured into two main phases: heuristic precomputation and the primary A-star search.\n\n**1. Heuristic Precomputation**\n\nThe A-star algorithm's efficiency and behavior are dictated by the heuristic function $h(v)$. The specified heuristic is a composite function: $h(v) = h_0(v) + \\beta \\cdot p(v)$. The two components, $h_0(v)$ and $p(v)$, must be precomputed for all nodes $v \\in V$.\n\n- The base-step lower-bound, $h_0(v)$, is defined as the length of the shortest path from node $v$ to the goal node $t$ considering only the base step costs $c(e)$.\n- The mismatch lower-bound, $p(v)$, is the minimum possible cumulative mismatch count on any path from $v$ to $t$.\n\nBoth of these components are shortest path problems on the graph $G$. A standard and efficient method to compute these values for all nodes $v$ simultaneously is to solve the single-source shortest path (SSSP) problem from the goal node $t$ on the *reverse graph* $G^R$. The reverse graph $G^R$ is formed by reversing the direction of every edge in $G$. Since all edge weights ($c(e)=1$ and $m(e) \\in \\{0,1\\}$) are non-negative, Dijkstra's algorithm is a correct and efficient choice for solving the SSSP problem.\n\nThe precomputation proceeds as follows:\n1. Construct the reverse graph $G^R = (V, E^R)$, where an edge $(v \\rightarrow u) \\in E^R$ exists if and only if $(u \\rightarrow v) \\in E$. The weights are carried over.\n2. To compute all $h_0(v)$ values, execute Dijkstra's algorithm starting from node $t$ on $G^R$, using the base step costs $c(e)$ as the edge weights. The resulting shortest distance from $t$ to any node $v$ in $G^R$ is equivalent to the shortest distance from $v$ to $t$ in the original graph $G$, which is precisely $h_0(v)$.\n3. Similarly, to compute all $p(v)$ values, execute Dijkstra's algorithm again from node $t$ on $G^R$, this time using the mismatch penalties $m(e)$ as edge weights. The resulting shortest distance is $p(v)$.\n\n**2. A-star Search Algorithm with State-Space Augmentation**\n\nThe core of the problem is a modified A-star search. The presence of the hard mismatch budget $\\tau$ necessitates an augmented state representation. A path is not defined solely by the node it reaches, but also by the resources it has consumed—in this case, the cumulative mismatch count.\n\n- **State Representation**: The state in our search is a pair $(v, k)$, where $v \\in V$ is the current node and $k \\in \\{0, 1, \\dots, \\tau\\}$ is the cumulative mismatch count along the path from the start node $s$ to $v$.\n- **Cost Function**: The cost of reaching a state $(v,k)$ is the cumulative base step cost, denoted $g(v,k)$.\n- **Priority Function**: The priority of a state $(v,k)$ in the open set (priority queue) is given by the A-star function $f(v,k) = g(v,k) + h(v)$, where $h(v) = h_0(v) + \\beta \\cdot p(v)$.\n- **Open Set**: A priority queue is used to store states to be explored. To strictly adhere to the tie-breaking rule, each entry in the queue will be a tuple: $(f, p(v), \\text{discovery\\_time}, (v, k))$. The queue is ordered first by the priority value $f$, then by the mismatch heuristic $p(v)$, and finally by a monotonically increasing discovery counter to ensure a first-in, first-out order for states with identical $f$ and $p(v)$.\n- **Visited States and Dominance**: A data structure, such as a hash map or a 2D array, is required to store the minimum cost $g(v,k)$ found so far for each state $(v,k)$. When a path to state $(v',k')$ is found with cost $g'$, it is only pursued if $g'$ is strictly less than the previously recorded best cost for $(v',k')$. This prevents cycles and redundant computations.\n- **Algorithm Execution**:\n    1. Initialize an empty priority queue (open set) and a dictionary `dist` to store the best $g(v,k)$ for visited states.\n    2. Add the initial state to the queue: `(f(s,0), p(s), 0, (s,0))`, where $f(s,0) = 0 + h(s)$. Set `dist[(s,0)] = 0`. Initialize an expansion counter to $0$ and a discovery counter to $1$.\n    3. Loop until the priority queue is empty or the expansion counter exceeds the limit $L$:\n        a. Pop the state with the highest priority (lowest $f$-value) from the queue. Let this be $(v,k)$ with cost $g(v,k)$.\n        b. Increment the expansion counter. If the counter now exceeds $L$, terminate with failure.\n        c. If $v$ is the goal node $t$, the search is successful. Return the path properties: found status, $g(t,k)$, $k$, and the total number of expansions.\n        d. For each neighbor $v'$ of node $v$ connected by an edge $e=(v \\rightarrow v')$:\n            i. Calculate the cost and mismatch for the successor state: $g' = g(v,k) + c(e)$ and $k' = k + m(e)$.\n            ii. **Hard Constraint Pruning**: If $k'  \\tau$, this path is infeasible. Discard this successor and continue.\n            iii. **Dominance Check**: If a path to state $(v',k')$ has been found before with a cost less than or equal to $g'$ (i.e., `dist.get((v',k'), infinity) = g'`), this new path is not an improvement. Discard it and continue.\n            iv. **Update and Enqueue**: If the new path is better, update `dist[(v',k')] = g'`. Calculate the priority $f' = g' + h(v')$. Push the new entry $(f', p(v'), \\text{discovery\\_time}, (v',k'))$ to the priority queue. Increment the discovery counter.\n    4. If the loop finishes without reaching the goal, the search fails. Return the failure status and corresponding values.\n\nThis procedure systematically explores the state space, guided by the composite heuristic, while strictly enforcing the mismatch budget and expansion limit, ensuring a correct and deterministic outcome for each test case.",
            "answer": "```python\nimport heapq\nimport numpy as np\n# The problem statement requires scipy to be available, but it is not used in this implementation.\n# from scipy import sparse\n\ndef solve():\n    \"\"\"\n    Main function to define the graph, run test cases, and print the results.\n    \"\"\"\n    nodes = {'s', 'b1', 'b2', 'p1', 'p2', 'p3', 'p4', 'u1', 'u2', 'u3', 'v1', 'v2', 'v3', 't'}\n    edges = [\n        ('s', 'b1', 1, 1),\n        ('b1', 'b2', 1, 1),\n        ('b2', 't', 1, 0),\n        ('b1', 'u1', 1, 0), ('u1', 'v1', 1, 1), ('v1', 't', 1, 1),\n        ('b1', 'u2', 1, 0), ('u2', 'v2', 1, 1), ('v2', 't', 1, 1),\n        ('b1', 'u3', 1, 0), ('u3', 'v3', 1, 1), ('v3', 't', 1, 1),\n        ('s', 'p1', 1, 0), ('p1', 'p2', 1, 0), ('p2', 'p3', 1, 0),\n        ('p3', 'p4', 1, 0), ('p4', 't', 1, 0),\n    ]\n\n    graph = {node: [] for node in nodes}\n    reverse_graph = {node: [] for node in nodes}\n    for u, v, c, m in edges:\n        graph[u].append((v, c, m))\n        reverse_graph[v].append((u, c, m))\n\n    def dijkstra(g, start_node, weight_key_idx):\n        \"\"\"\n        Dijkstra's algorithm for Single-Source Shortest Path.\n        `weight_key_idx` is 0 for base cost 'c', 1 for mismatch 'm'.\n        \"\"\"\n        distances = {node: np.inf for node in g}\n        distances[start_node] = 0\n        pq = [(0, start_node)]\n\n        while pq:\n            dist, current_node = heapq.heappop(pq)\n            if dist > distances[current_node]:\n                continue\n            for neighbor, *weights in g[current_node]:\n                weight = weights[weight_key_idx]\n                new_dist = dist + weight\n                if new_dist  distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(pq, (new_dist, neighbor))\n        return distances\n\n    h0 = dijkstra(reverse_graph, 't', 0)  # Heuristic from base step cost c\n    p = dijkstra(reverse_graph, 't', 1)   # Heuristic from mismatch m\n\n    def astar_search(beta, tau, L):\n        \"\"\"\n        Implements the specified A-star search algorithm.\n        \"\"\"\n        start_node, goal_node = 's', 't'\n        initial_k = 0\n\n        # Priority queue stores: (f_cost, p_heuristic, discovery_time, (node, k))\n        # This handles the tie-breaking rule: f, then p(v), then discovery order.\n        pq = []\n        discovery_time = 0\n        expansions = 0\n        \n        # dist stores the minimum g_cost found for each state (node, k)\n        dist = {}\n\n        initial_g = 0\n        initial_h = h0[start_node] + beta * p[start_node]\n        initial_f = initial_g + initial_h\n        \n        initial_state = (start_node, initial_k)\n        heapq.heappush(pq, (initial_f, p[start_node], discovery_time, initial_state))\n        discovery_time += 1\n        dist[initial_state] = initial_g\n        \n        while pq:\n            if expansions >= L:\n                return [False, -1, -1, expansions]\n\n            f_cost, _, _, current_state = heapq.heappop(pq)\n            current_node, current_k = current_state\n            \n            expansions += 1\n            \n            current_g = dist[current_state]\n\n            if current_node == goal_node:\n                return [True, int(current_g), int(current_k), expansions]\n\n            for neighbor, c, m in graph[current_node]:\n                next_g = current_g + c\n                next_k = current_k + m\n\n                if next_k > tau:\n                    continue\n\n                next_state = (neighbor, next_k)\n                if next_g  dist.get(next_state, np.inf):\n                    dist[next_state] = next_g\n                    h_next = h0[neighbor] + beta * p[neighbor]\n                    f_next = next_g + h_next\n                    heapq.heappush(pq, (f_next, p[neighbor], discovery_time, next_state))\n                    discovery_time += 1\n        \n        return [False, -1, -1, expansions]\n\n    test_cases = [\n        (0.0, 1, 8),   # Case 1\n        (1.0, 1, 8),   # Case 2\n        (0.5, 1, 8),   # Case 3\n        (0.0, 0, 6),   # Case 4\n        (10.0, 1, 6),  # Case 5\n    ]\n\n    results = []\n    for beta, tau, L in test_cases:\n        result = astar_search(beta, tau, L)\n        results.append(result)\n\n    # Format the final output exactly as specified.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}