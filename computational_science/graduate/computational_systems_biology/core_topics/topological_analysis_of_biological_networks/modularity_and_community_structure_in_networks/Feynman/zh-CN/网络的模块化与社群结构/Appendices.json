{
    "hands_on_practices": [
        {
            "introduction": "理解社群结构始于一个关键问题：“比预期的连接更紧密，而预期是什么？”本练习  将引导您进行一个思想实验，探讨零模型在模块度计算中的关键作用。通过在一个包含核心节点的网络中比较一个简单的零模型和一个度矫正模型，您将亲眼看到一个被错误设定的零模型如何产生虚假的社群，并理解为何度矫正对于分析具有显著度异质性的真实生物网络至关重要。",
            "id": "3328725",
            "problem": "在一种单一真核细胞类型的蛋白质-蛋白质相互作用网络中，假设有 $N=1000$ 个蛋白质，它们在一个简单无向图（无自环）中表示为节点。度序列表现出显著的异质性：$h=10$ 个核心蛋白质的度均为 $20$，而其余 $N-h=990$ 个蛋白质的度均为 $2$。该网络是通过在保持度序列的约束下随机连接末端（度保持随机布线）生成的，并且在生成过程中，除了度异质性本身，不存在真正的介观尺度社群结构。考虑一个划分 $\\mathcal{P}_1$，该划分将所有核心蛋白质置于一个模块中，并将所有非核心蛋白质置于另一个模块中。\n\n为了进行基于模块度的社群评分，考虑了两种计算期望边数的零模型：\n- 一个同质 Bernoulli 零模型，其中每对不同的节点都以概率 $p$ 独立连接，该概率 $p$ 的选择是为了匹配整个图的观测边密度。\n- 一个度保持零模型，其中节点 $i$ 和 $j$ 之间的期望边数与 $k_i k_j$ 成正比，并与配置模型相匹配。\n\n设 $m$ 表示总边数，$K_H$ 表示核心蛋白质集合的度之和，$K_L$ 表示非核心蛋白质集合的度之和，$n_H$ 表示核心蛋白质的数量，$n_L$ 表示非核心蛋白质的数量。利用每种零模型下期望边数的第一性原理以及模块度的核心定义（即观测到的模块内边密度与零模型期望的模块内边密度之差，经过适当归一化），分析在两种零模型下，$\\mathcal{P}_1$ 中的核心模块对模块度的贡献。然后，论证在存在极端度异质性的情况下，同质 Bernoulli 零模型是否会产生伪社群，并提出一个修正的零模型，以避免在计算系统生物学网络（如蛋白质-蛋白质相互作用（PPI）图）中出现此陷阱。\n\n选择所有正确的陈述：\n\nA. 在同质 Bernoulli 零模型下，$\\mathcal{P}_1$ 中核心模块对模块度的贡献为正，数量级约为 $7.5\\times 10^{-3}$，这在一个实际上除了度异质性之外没有真正社群的网络中，围绕核心蛋白质形成了一个表观上的模块。\n\nB. 在度保持零模型下，对于由度保持随机布线生成的图，任何划分的期望模块度在期望上为 $0$。对于 $\\mathcal{P}_1$，核心模块的贡献约为 $-8.4\\times 10^{-4}$，这表明 A 中的表观信号是由零模型的错误设定引起的。\n\nC. 修正伪模块度的一个合适方法是保留同质 Bernoulli 零模型，但将 $p$ 替换为仅根据核心节点估计出的值。\n\nD. 对于具有重尾度分布的网络，一个修正的零模型是度修正模型（例如，配置模型或度修正随机块模型），其中节点 $i$ 和 $j$ 之间的期望边数与 $k_i k_j$ 成比例，从而防止由核心蛋白质驱动的伪模块的产生。\n\nE. 在同质 Bernoulli 零模型下，将非核心模块分割成许多小社群会减少核心模块的正贡献。",
            "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，问题设定良好、客观，并包含了进行严谨分析所需的所有信息。\n\n我们首先计算所描述网络的基本属性。\n节点总数为 $N=1000$。\n核心蛋白质的数量为 $n_H = 10$，每个的度为 $k_{hub} = 20$。\n非核心蛋白质的数量为 $n_L = 990$，每个的度为 $k_{non-hub} = 2$。\n网络中所有度的总和是 $2m = \\sum_{i} k_i$。\n$$ 2m = n_H \\cdot k_{hub} + n_L \\cdot k_{non-hub} = (10)(20) + (990)(2) = 200 + 1980 = 2180 $$\n因此，网络中的总边数是 $m = 1090$。\n\n划分 $\\mathcal{P}_1$ 由两个模块组成：核心模块 $C_H$（包含 $n_H=10$ 个核心蛋白质）和非核心模块 $C_L$（包含 $n_L=990$ 个非核心蛋白质）。\n核心模块的度之和为 $K_H = n_H \\cdot k_{hub} = 10 \\cdot 20 = 200$。\n非核心模块的度之和为 $K_L = n_L \\cdot k_{non-hub} = 990 \\cdot 2 = 1980$。\n作为检验，$K_H + K_L = 200 + 1980 = 2180 = 2m$。\n\n对于一个划分，模块度 $Q$ 的一般定义是：\n$$ Q = \\sum_{C} \\left( \\frac{L_C}{m} - \\frac{E_C}{m} \\right) $$\n其中，求和遍及划分中的所有模块 $C$，$L_C$ 是两个端点都在模块 $C$ 内部的边数，$E_C$ 是在指定零模型下模块 $C$ 内部的期望边数。单个模块 $C$ 对总模块度的贡献是 $Q_C = (L_C - E_C)/m$。\n\n问题陈述该网络由度保持随机布线生成，这对应于配置模型。在这样的网络中，任何模块内的边数 $L_C$ 是一个随机变量。在需要 $L_C$ 的地方，我们将使用其期望值 $E[L_C]$，因为它代表了由该过程生成的典型图的属性。对于核心模块 $C_H$，我们使用配置模型中内部边数的期望值作为 $L_H$：\n$$ L_H \\approx E[L_H] \\approx \\frac{K_H^2}{4m} = \\frac{(200)^2}{2 \\cdot 2180} = \\frac{40000}{4360} \\approx 9.174 $$\n\n现在我们来分析这两个零模型：\n\n**1. 同质 Bernoulli 零模型**\n- 边密度 $p = \\frac{2m}{N(N-1)} = \\frac{2180}{1000 \\times 999} \\approx 0.002182$。\n- 核心模块内的期望边数 $E_H = \\binom{n_H}{2} p = \\binom{10}{2} p = 45 \\times 0.002182 \\approx 0.0982$。\n- 核心模块对模块度的贡献：\n  $$ Q_H = \\frac{L_H - E_H}{m} \\approx \\frac{9.174 - 0.0982}{1090} \\approx \\frac{9.0758}{1090} \\approx 0.008326 \\approx 8.3 \\times 10^{-3} $$\n- 这个值是正的，数量级与选项 A 中的 $7.5\\times 10^{-3}$ 一致。这表明，由于该模型没有考虑核心节点的高连接度，它严重低估了核心模块内部的期望边数，从而错误地推断出一个显著的社群结构。因此，**陈述 A 是正确的**。\n\n**2. 度保持零模型（配置模型）**\n- 核心模块内的期望边数 $E_H$ 就是我们用作 $L_H$ 的那个值，因为网络本身就是用这个模型生成的。\n  $$ E_H \\approx \\frac{K_H^2}{4m} \\approx 9.174 $$\n- 核心模块对模块度的贡献：\n  $$ Q_H = \\frac{L_H - E_H}{m} \\approx \\frac{9.174 - 9.174}{1090} = 0 $$\n- 在期望上，模块度为零。任何非零值都来自特定网络实例中的随机波动。选项 B 给出的值 $-8.4\\times 10^{-4}$ 是一个接近于零的小值，这与我们的期望相符，表明一旦对度进行校正，核心节点的表观社群信号就消失了。因此，**陈述 B 是正确的**。\n\n**评估其他选项：**\n- **陈述 C**：建议仅针对核心节点修改 $p$ 值。这是一种特别的、不通用的修正，并不能解决零模型的基本缺陷。正确的做法是采用一个能系统性处理度异质性的模型。因此，陈述 C 是不正确的。\n- **陈述 D**：明确指出，对于具有异质度分布的网络，正确的零模型是度修正模型（如配置模型），因为它将期望边数与节点度的乘积 $k_i k_j$ 联系起来。这正是我们的分析所证实的，也是避免产生伪社群的关键。因此，**陈述 D 是正确的**。\n- **陈述 E**：核心模块的贡献 $Q_H$ 的计算只依赖于核心模块内部的属性（$L_H$ 和 $E_H$），与网络其余部分的划分方式无关。因此，分割非核心模块不会影响 $Q_H$。陈述 E 是不正确的。\n\n综上所述，正确的陈述是 A、B 和 D。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "在定义了模块度之后，我们如何通过算法找到一个高模块度的网络划分呢？本实践  介绍了一种基础而优雅的方法：谱对分法。您将实现一个算法，利用模块度矩阵的主特征向量将网络划分为两个社群，从而在线性代数的抽象概念与网络聚类的实际任务之间建立具体的联系。",
            "id": "3328768",
            "problem": "您的任务是为小型的、无向的、无权的蛋白质-蛋白质相互作用（PPI）网络实现一种基于模块度框架的谱对分方法。目标是通过对模块度矩阵的主特征向量的条目进行阈值化处理，来计算一个双向社群分配。请仅使用网络科学和线性代数中的基本定义来构建您的方法。\n\n定义和要求：\n- 设 $A \\in \\{0,1\\}^{n \\times n}$ 表示一个具有 $n$ 个节点、零对角线、无向、无权网络的对称邻接矩阵，其中当且仅当节点 $i$ 和 $j$ 之间存在边时，条目 $A_{ij} = 1$。设 $k_i = \\sum_{j=1}^{n} A_{ij}$ 表示节点 $i$ 的度，并设 $2m = \\sum_{i=1}^{n} k_i = \\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{ij}$ 表示边数的两倍。\n- 在配置模型零模型下，节点 $i$ 和 $j$ 之间的期望边数为 $k_i k_j / (2m)$。模块度矩阵为 $B \\in \\mathbb{R}^{n \\times n}$，其条目为 $B_{ij} = A_{ij} - \\frac{k_i k_j}{2m}$。\n- 计算 $B$ 的主特征对，其中主特征值 $\\lambda_{\\max}$ 是最大的实特征值（按数值大小，而非绝对值大小），而相应的主特征向量 $v_{\\max}$ 是任意相关的单位范数特征向量。\n- 使用阈值规则将节点分配到两个社群：如果 $v_{\\max,i} \\ge 0$，则 $s_i = +1$；如果 $v_{\\max,i}  0$，则 $s_i = -1$。这将生成一个双向分配向量 $s \\in \\{-1,+1\\}^n$；恰好等于 $0$ 的条目必须分配给 $+1$。\n- 对于由 $s$ 编码的对分，计算模块度值\n$$\nQ = \\frac{1}{4m} \\sum_{i=1}^{n}\\sum_{j=1}^{n} B_{ij} s_i s_j,\n$$\n这等价于专门针对两个组的标准模块度定义。如果 $2m = 0$，按照惯例定义 $Q = 0$。\n- 将一个对分定义为有信息量的划分（informative split），当且仅当 $\\lambda_{\\max} > 0$ 且两个社群均非空（即，至少存在一个 $i$ 使得 $s_i = +1$ 且至少存在一个 $j$ 使得 $s_j = -1$）。\n\n实现一个程序，对下面的每个测试用例：\n- 使用配置模型从 $A$ 构建 $B$。\n- 通过对称特征值分解计算 $B$ 的主特征对 $(\\lambda_{\\max}, v_{\\max})$。\n- 按照指定方式，通过对 $v_{\\max}$ 在 $0$ 处进行阈值化来形成 $s$。\n- 为该 $s$ 计算 $Q$。\n- 报告一个形式为 $[\\lambda_{\\max}, s\\_list, Q, informative]$ 的结果，其中 $\\lambda_{\\max}$ 和 $Q$ 四舍五入到六位小数，$s\\_list$ 是一个由 $\\{-1, +1\\}$ 中整数组成的列表，而 $informative$ 是一个布尔值。\n\n测试套件（三个无向、无权的类 PPI 网络），每个都以纯组合方式完全指定：\n- 测试用例 1（具有单个桥接边的双模块结构）：$n = 8$，节点 $\\{0,1,2,3\\}$ 形成一个 4-团，节点 $\\{4,5,6,7\\}$ 形成另一个 4-团，并且在节点 3 和节点 4 之间恰好有一条模块间边。两个团之间的所有其他节点对都不相邻，且不存在自环。\n- 测试用例 2（星形交互中心）：$n = 6$，节点 0 连接到 $\\{1,2,3,4,5\\}$ 中的每个节点，没有其他边；不存在自环。\n- 测试用例 3（没有信息量划分的稠密背景）：$n = 5$，网络是完全图 $K_5$（每对不同节点都相连），没有自环。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，并按上述测试套件的顺序排列。每个结果必须是 $[\\lambda_{\\max}, s\\_list, Q, informative]$ 形式的列表，其中 $\\lambda_{\\max}$ 和 $Q$ 四舍五入到六位小数，$s\\_list$ 是一个长度为 $n$、由 $-1$ 和 $+1$ 组成的列表，而 $informative$ 是一个布尔值。整个输出必须是一个包含三个独立结果的单一列表。例如：$[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "该问题要求为无向、无权网络实现一种基于模块度矩阵的谱对分算法。解决方案将遵循指定的网络科学和线性代数原理进行设计。\n\n该方法的核心原理是最大化模块度，这是一种用于社群检测的质量函数。对于将网络划分为社群，模块度（表示为 $Q$）衡量的是落在给定社群内部的边所占的比例，减去在边按配置模型随机分布的情况下，这种边所占的期望比例。配置模型是一种保留网络度序列的零模型。\n\n模块度的通用公式是：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n$$\n其中 $A$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$2m$ 是总边数的两倍（即所有度的总和），$\\delta(c_i, c_j)$ 是克罗内克（Kronecker）δ函数，当节点 $i$ 和 $j$ 属于同一社群（$c_i = c_j$）时为 1，否则为 0。\n\n括号中的项是模块度矩阵 $B$ 的条目 $B_{ij}$，因此 $B = A - \\frac{1}{2m} k k^T$，其中 $k$ 是节点度的列向量。\n\n对于划分为两个社群的对分，我们可以用一个向量 $s \\in \\{-1, +1\\}^n$ 来表示社群分配。如果节点 $i$ 和 $j$ 在同一个社群中，$s_i s_j = 1$；如果它们在不同的社群中，$s_i s_j = -1$。项 $\\delta(c_i, c_j)$ 可以通过 $\\delta(c_i, c_j) = \\frac{1}{2}(1 + s_i s_j)$ 与 $s_i s_j$ 关联起来。将此代入模块度公式，并利用 $\\sum_{i,j} B_{ij} = 0$ 的事实，我们得到问题陈述中给出的模块度表达式：\n$$\nQ = \\frac{1}{4m} \\sum_{i,j} B_{ij} s_i s_j = \\frac{1}{4m} s^T B s\n$$\n最大化 $Q$ 等价于最大化二次型 $s^T B s$。这是一个 NP-难的整数优化问题。谱方法通过放宽 $s_i$ 必须为 $-1$ 或 $+1$ 的约束，提供了一个近似解。我们转而允许向量的条目为任意实数，并在归一化约束 $\\|v\\|=1$ 下最大化 $v^T B v$。根据瑞利-里兹（Rayleigh-Ritz）定理，最大化该量的向量 $v$ 是对应于矩阵 $B$ 最大特征值的特征向量。这就是主特征向量 $v_{\\max}$。\n\n然后，通过一个简单的阈值方案将得到的实值向量 $v_{\\max}$ 转换回离散的划分向量 $s$。每个分量 $v_{\\max, i}$ 的符号决定了节点 $i$ 的社群分配。\n\n对于每个提供的测试用例，实现将按以下步骤进行：\n\n1.  **构建邻接矩阵 $A$**：根据每个测试网络的组合描述，将构建一个表示邻接矩阵 $A$ 的 $n \\times n$ NumPy 数组。\n\n2.  **计算网络属性**：从 $A$ 计算度向量 $k$（通过对 $A$ 的行求和）。总度数和 $2m$ 通过对 $k$ 的元素求和来计算。对于 $2m=0$（空图）的特殊情况，按规定处理，将 $Q$ 设为 0。\n\n3.  **构建模块度矩阵 $B$**：使用公式 $B_{ij} = A_{ij} - \\frac{k_i k_j}{2m}$ 构建模块度矩阵 $B$。用矩阵表示法，即为 $B = A - \\frac{1}{2m} k k^T$，其中 $k k^T$ 是度向量与自身的外积。\n\n4.  **计算主特征对**：对模块度矩阵 $B$ 执行对称特征值分解。由于 $B$ 是一个实对称矩阵，其特征值是实数，其特征向量构成一个标准正交基。我们使用 `numpy.linalg.eigh`，它专为对称矩阵设计，并按升序返回特征值。主特征值 $\\lambda_{\\max}$ 是返回的特征值数组的最后一个元素，主特征向量 $v_{\\max}$ 是返回的特征向量矩阵的最后一列。\n\n5.  **确定对分**：根据阈值规则从 $v_{\\max}$ 创建划分向量 $s$：如果第 $i$ 个分量 $v_{\\max,i} \\ge 0$，则 $s_i = +1$；如果 $v_{\\max,i}  0$，则 $s_i = -1$。\n\n6.  **计算模块度 $Q$**：使用给定公式的矩阵形式计算所获得划分 $s$ 的模块度 $Q$：$Q = \\frac{s^T B s}{4m}$。这通过矩阵-向量乘积实现。\n\n7.  **评估划分**：如果满足两个条件，则该划分被分类为‘有信息量的’：主特征值 $\\lambda_{\\max}$ 严格为正，并且得到的划分 $s$ 同时包含 $+1$ 和 $-1$ 值（即两个社群都非空）。\n\n8.  **格式化输出**：每个测试用例的最终结果被组合成一个列表，其中包含四舍五入到六位小数的 $\\lambda_{\\max}$ 和 $Q$、划分向量 $s$ 的列表表示形式，以及指示该划分是否有信息量的布尔值。所有测试用例的结果被收集到一个单一列表中作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral bipartitioning problem for the given test cases.\n    \"\"\"\n\n    def analyze_network(A: np.ndarray):\n        \"\"\"\n        Performs spectral bipartitioning on a network given its adjacency matrix.\n        \n        Args:\n            A (np.ndarray): The symmetric adjacency matrix of the network.\n\n        Returns:\n            list: A list containing the rounded leading eigenvalue, the partition vector,\n                  the rounded modularity, and a boolean indicating if the split is informative.\n        \"\"\"\n        n = A.shape[0]\n        if n == 0:\n            return [0.0, [], 0.0, False]\n\n        k = A.sum(axis=1)\n        two_m = k.sum()\n\n        if two_m == 0:\n            s_list = [1] * n if n > 0 else []\n            return [0.0, s_list, 0.0, False]\n\n        # Construct the modularity matrix B\n        B = A - np.outer(k, k) / two_m\n\n        # Eigenvalue decomposition for the symmetric matrix B\n        # numpy.linalg.eigh returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = np.linalg.eigh(B)\n\n        # The leading eigenpair corresponds to the largest eigenvalue\n        lambda_max = eigenvalues[-1]\n        v_max = eigenvectors[:, -1]\n\n        # Create partition vector s from the leading eigenvector v_max\n        # s_i = +1 if v_max_i >= 0, s_i = -1 if v_max_i  0\n        s = np.ones(n, dtype=int)\n        s[v_max  0] = -1\n\n        # Calculate modularity Q for the partition s\n        # Q = (1/(4m)) * s^T * B * s. Here, two_m is 2m, so 4m = 2 * two_m.\n        Q = (s.T @ B @ s) / (2 * two_m)\n\n        # Determine if the split is informative\n        is_lambda_positive = lambda_max > 1e-12 # Use a small tolerance for float comparison\n        has_both_communities = len(np.unique(s)) == 2\n        informative = bool(is_lambda_positive and has_both_communities)\n\n        # Format results\n        lambda_max_rounded = round(float(lambda_max), 6)\n        Q_rounded = round(float(Q), 6)\n        s_list = s.tolist()\n\n        return [lambda_max_rounded, s_list, Q_rounded, informative]\n\n    # --- Test Case 1: Two modules with a bridge ---\n    n1 = 8\n    A1 = np.zeros((n1, n1), dtype=int)\n    # First 4-clique (nodes 0, 1, 2, 3)\n    for i in range(4):\n        for j in range(i + 1, 4):\n            A1[i, j] = A1[j, i] = 1\n    # Second 4-clique (nodes 4, 5, 6, 7)\n    for i in range(4, 8):\n        for j in range(i + 1, 8):\n            A1[i, j] = A1[j, i] = 1\n    # Bridge between node 3 and node 4\n    A1[3, 4] = A1[4, 3] = 1\n\n    # --- Test Case 2: Star graph ---\n    n2 = 6\n    A2 = np.zeros((n2, n2), dtype=int)\n    # Node 0 is connected to all other nodes\n    for i in range(1, n2):\n        A2[0, i] = A2[i, 0] = 1\n\n    # --- Test Case 3: Complete graph K5 ---\n    n3 = 5\n    A3 = np.ones((n3, n3), dtype=int) - np.eye(n3, dtype=int)\n\n    test_cases = [A1, A2, A3]\n\n    results = []\n    for A in test_cases:\n        result = analyze_network(A)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces after commas.\n    # The boilerplate format string ensures the output conforms to the problem's example.\n    # Example item: `[2.413793, [1, 1, 1, 1, -1, -1, -1, -1], 0.357322, True]`\n    # `str()` of this list produces `'[2.413793, [1, 1, 1, 1, -1, -1, -1, -1], 0.357322, True]'`\n    # `','.join(map(str, results))` joins these strings with commas.\n    # The outer `f\"[{...}]\"` wraps the whole thing in brackets.\n    # This combination correctly produces the format `[[...],[...],[...]]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的生物网络通常具有层次结构，这意味着社群存在于不同的尺度上。这项高级练习  模拟了一个真实的研究任务，您将使用分辨率参数 $\\gamma$ 在多个尺度上检测社群。然后，您需要将其与富集分析相结合，通过比较检测到的模块与已知的生物通路来选择一个最佳分辨率，这展示了如何利用领域知识来验证和调整计算方法。",
            "id": "3328724",
            "problem": "给定一个基于计算系统生物学的场景，其中基因共表达被建模为一个无向加权网络，其社群结构在多个分辨率参数下进行评估。任务是实现一个完整的、自包含的程序，通过富集分析将检测到的模块大小与已知通路大小进行匹配，从而选择一个合适的分辨率尺度。\n\n从以下基本定义和事实开始。\n\n- 基因共表达网络被建模为一个无向加权图，具有对称权重矩阵 $W \\in \\mathbb{R}^{N \\times N}$，其中 $W_{ij} \\geq 0$ 表示基因 $i$ 和基因 $j$ 之间的共表达强度，$W_{ij} = W_{ji}$ 对所有 $i,j$ 成立，且 $W_{ii} = 0$ 对所有 $i$ 成立。总权重为 $2m = \\sum_{i=1}^{N} \\sum_{j=1}^{N} W_{ij}$，对于无向图，这等于无序对权重之和的 $2$ 倍。节点 $i$ 的强度为 $k_i = \\sum_{j=1}^{N} W_{ij}$。\n\n- 带有分辨率参数 $\\gamma$ 的模块度定义为\n$$\nQ(\\gamma) \\;=\\; \\frac{1}{2m} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( W_{ij} \\;-\\; \\gamma \\frac{k_i k_j}{2m} \\right) \\mathbf{1}\\{c_i = c_j\\},\n$$\n其中 $c_i$ 是节点 $i$ 的社群标签，$\\mathbf{1}\\{\\cdot\\}$ 表示指示函数。在此框架中，$Q(\\gamma)$ 的值越大，对应于在分辨率 $\\gamma$ 下更好的社群划分。\n\n- 在包含 $N$ 个基因的同一全集上，一个模块（社群）$S \\subseteq \\{1,\\dots,N\\}$ 相对于一个通路 $P \\subseteq \\{1,\\dots,N\\}$ 的基因集富集是通过超几何分布的尾概率来评估的：如果 $X \\sim \\mathrm{Hypergeometric}(N, K, n)$，其中 $K = |P|$ 且 $n = |S|$，那么观察到大小为 $k = |S \\cap P|$ 或更大的重叠的单侧 $p$ 值为 $p = \\mathbb{P}[X \\ge k]$。一种保守的多重检验校正是 Bonferroni 校正：对于 $T$ 个同步检验，通过拒绝那些 $p  \\alpha / T$ 的检验，可以将族系错误率控制在水平 $\\alpha$ 内。\n\n您的程序必须为每个测试用例执行以下操作：\n\n1. 对于给定有限网格中的每个指定 $\\gamma$ 值，通过贪婪最大化模块度来计算节点的社群划分。从单例划分开始，迭代地合并在该 $\\gamma$ 下产生最大严格正模块度增益的社群对；当没有合并能产生严格正增益时停止。您必须为每个 $\\gamma$ 独立地从单例划分开始此凝聚优化。您应从上述基本定义中推导并实现所需的任何表达式；不提供更多公式。\n\n2. 对于每个 $\\gamma$ 下的每个划分，针对给定的通路集合执行富集分析：\n   - 对于每个模块 $S$ 和每个通路 $P$，如上所述计算超几何尾部 $p$ 值 $p(S,P)$。\n   - 令 $T$ 为模块-通路对的总数，即 $T = (\\text{模块数量}) \\times (\\text{通路数量})$。使用显著性水平 $\\alpha = $ $0.05$ 的 Bonferroni 校正，即将 $p(S,P)  \\alpha/T$ 视为显著。\n   - 统计有多少个模块与任意通路至少有一个显著富集。将此计数表示为 $E(\\gamma)$。\n\n3. 根据以下规则为测试用例选择 $\\gamma^\\star$：\n   - 主要标准：最大化 $E(\\gamma)$。\n   - 次要决胜规则：在具有最大 $E(\\gamma)$ 的值中，选择其模块数量与通路数量最接近（绝对差最小）的 $\\gamma$。\n   - 最终决胜规则：如果仍然平局，选择数值最小的 $\\gamma$。\n\n您的程序应生成一行输出，其中包含每个测试用例选定的 $\\gamma^\\star$，按下面给出的顺序，格式为一个用方括号括起来的逗号分隔列表（例如，“[$\\gamma_1^\\star,\\gamma_2^\\star,\\dots$]”）。\n\n在以下测试套件上实现并评估您的程序。在所有情况下，基因全集为 $\\{0,1,\\dots,N-1\\}$ 且所有 $W_{ii} = $ $0$。\n\n测试用例 A（带背景基因的结构化网络）：\n- 网络大小：$N = $ $10$ 个节点 $\\{0,1,\\dots,9\\}$。\n- 通路：$P_1 = \\{0,1,2,3\\}$, $P_2 = \\{4,5,6,7\\}$。\n- 权重构建：\n  - 对于 $i \\ne j$ 且两者都在 $P_1$ 中或都在 $P_2$ 中，设置 $W_{ij} = $ $1.0$。\n  - 在 $P_1$ 内部，对于配对 $\\{0,1\\}$ 和 $\\{2,3\\}$，将 $W_{ij}$ 增加 $+$ $0.3$。\n  - 对于 $i \\in P_1$ 和 $j \\in P_2$（或反之），设置 $W_{ij} = $ $0.2$。\n  - 对于背景节点 $B = \\{8,9\\}$ 和 $j \\in P_1 \\cup P_2$，当 $i \\in B$ 时设置 $W_{ij} = $ $0.1$（对称设置）。\n  - 对于配对 $\\{8,9\\}$，设置 $W_{89} = W_{98} = $ $0.05$。\n- 分辨率网格：$\\Gamma_A = [$ $0.5$, $1.0$, $2.0$ $]$。\n\n测试用例 B（均匀完全网络）：\n- 网络大小：$N = $ $6$ 个节点 $\\{0,1,\\dots,5\\}$。\n- 通路：$P_1 = \\{0,1,2\\}$, $P_2 = \\{3,4,5\\}$。\n- 权重构建：对于 $i \\ne j$，设置 $W_{ij} = $ $1.0$。\n- 分辨率网格：$\\Gamma_B = [$ $0.5$, $1.0$, $2.0$ $]$。\n\n测试用例 C（具有非对称组间耦合和子结构的三组网络）：\n- 网络大小：$N = $ $12$ 个节点 $\\{0,1,\\dots,11\\}$。\n- 通路：$P_1 = \\{0,1,2,3\\}$, $P_2 = \\{4,5,6,7\\}$, $P_3 = \\{8,9,10,11\\}$。\n- 权重构建：\n  - 对于 $i \\ne j$ 且在同一通路内，设置 $W_{ij} = $ $1.0$。\n  - 在每个通路内，对于子配对 $\\{0,1\\}$, $\\{2,3\\}$, $\\{4,5\\}$, $\\{6,7\\}$, $\\{8,9\\}$, $\\{10,11\\}$，将 $W_{ij}$ 增加 $+$ $0.4$。\n  - 对于 $i \\in P_1$ 和 $j \\in P_2$（或反之），设置 $W_{ij} = $ $0.5$。\n  - 对于 $i \\in P_1 \\cup P_2$ 和 $j \\in P_3$（或反之），设置 $W_{ij} = $ $0.1$。\n- 分辨率网格：$\\Gamma_C = [$ $0.3$, $1.0$, $2.0$ $]$。\n\n角度单位不适用。不涉及物理单位。所有数值答案必须被视为无量纲。您的程序必须将选定的 $\\gamma^\\star$ 值作为实数输出到单行中，格式为方括号括起来的逗号分隔列表，没有额外的空白或文本，顺序为 [测试用例 A, 测试用例 B, 测试用例 C]。",
            "solution": "用户提供的问题是有效的。它在科学上植根于网络科学和计算系统生物学领域，问题定义明确，目标清晰，过程确定，并提供了所有必要的数据和定义。任务是实现一个多步骤的计算流程，用于在基因共表达网络中选择一个最优分辨率参数 $\\gamma^\\star$ 以进行社群检测。选择的依据是将检测到的模块与已知的生物学通路进行匹配。\n\n该解决方案通过为每个测试用例遵循一个三部分程序来实现：（1）在给定网格中为每个 $\\gamma$ 进行社群检测，（2）对得到的划分与已知通路进行富集分析，以及（3）基于一套分层标准选择最优的 $\\gamma^\\star$。\n\n首先，我们定义解决方案的数学和算法基础。网络是一个无向加权图，有 $N$ 个节点（基因）和一个对称权重矩阵 $W$，其中 $W_{ij}$ 表示共表达强度。节点 $i$ 的强度是 $k_i = \\sum_j W_{ij}$，网络中的总权重是 $2m = \\sum_i k_i = \\sum_{i,j} W_{ij}$。\n\n在给定分辨率 $\\gamma$ 下，网络划分的模块度 $Q$ 为\n$$\nQ(\\gamma) \\;=\\; \\frac{1}{2m} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left( W_{ij} \\;-\\; \\gamma \\frac{k_i k_j}{2m} \\right) \\mathbf{1}\\{c_i = c_j\\}\n$$\n其中 $c_i$ 是节点 $i$ 的社群分配。这可以表示为对所有社群 $C$ 的求和：\n$$\nQ(\\gamma) = \\sum_C \\left[ \\frac{\\Sigma_{in}(C)}{2m} - \\gamma \\left( \\frac{\\Sigma_{tot}(C)}{2m} \\right)^2 \\right]\n$$\n其中 $\\Sigma_{in}(C) = \\sum_{i,j \\in C} W_{ij}$ 是社群 $C$ 内部所有边的权重之和（每条边计算两次），而 $\\Sigma_{tot}(C) = \\sum_{i \\in C} k_i$ 是社群 $C$ 中所有节点的强度之和。\n\n社群检测通过贪婪凝聚算法执行。从每个节点自成一个社群（单例划分）开始，我们迭代地合并能产生最大严格正模块度增益 $\\Delta Q(\\gamma)$ 的社群对。合并两个社群 $C_a$ 和 $C_b$ 带来的模块度变化推导如下：\n$$\n\\Delta Q(C_a, C_b) = 2 \\left( \\frac{\\sum_{i \\in C_a, j \\in C_b} W_{ij}}{2m} - \\gamma \\frac{\\left(\\sum_{i \\in C_a} k_i\\right) \\left(\\sum_{j \\in C_b} k_j\\right)}{(2m)^2} \\right)\n$$\n当没有社群对的合并能产生严格正的 $\\Delta Q(\\gamma)$ 时，合并过程终止。此过程对指定网格中的每个 $\\gamma$ 值独立执行。\n\n其次，对于获得的每个划分，我们执行基因集富集分析。对于每个检测到的模块 $S$ 和每个已知通路 $P$，我们评估它们重叠的显著性。这通过超几何检验的 $p$ 值来量化。观察到大小为 $k = |S \\cap P|$ 或更大的重叠的概率由 $p = \\mathbb{P}[X \\ge k]$ 给出，其中 $X \\sim \\mathrm{Hypergeometric}(N, K, n)$，$N$ 是基因全集中的基因总数，$K=|P|$ 是通路的大小，$n=|S|$ 是模块的大小。该 $p$ 值计算如下：\n$$\np(S,P) \\;=\\; \\sum_{i=k}^{\\min(n,K)} \\frac{\\binom{K}{i} \\binom{N-K}{n-i}}{\\binom{N}{n}}\n$$\n为了解释多重比较，应用了 Bonferroni 校正。如果一个模块-通路对的 $p$ 值小于 $\\alpha/T$，则认为它是显著的，其中 $\\alpha=0.05$，$T$ 是检验的总数（模块数乘以通路数）。然后我们计算 $E(\\gamma)$，即与至少一个通路有显著富集的模块总数。\n\n第三，我们通过对所有测试的 $\\gamma$ 值得到的结果应用一个三层规则来选择最优分辨率参数 $\\gamma^\\star$：\n1.  主要标准：选择使富集模块数 $E(\\gamma)$ 最大化的 $\\gamma$ 值。\n2.  次要标准（决胜规则）：从第一步选择的候选中，选择那个检测到的模块数与已知通路数最接近的 $\\gamma$，即最小化 $|\\text{模块数} - \\text{通路数}|$。\n3.  第三标准（最终决胜规则）：如果仍然平局，选择数值最小的 $\\gamma$。\n\n实现将为每个测试用例构建特定的权重矩阵 $W$，然后执行这整个流程以确定 $\\gamma^\\star$。最终程序将此逻辑整合到一个自包含的脚本中，处理所有测试用例并以指定格式输出结果。使用 `scipy.stats` 库中的超几何生存函数（Hypergeometric survival function）来高效准确地计算 $p$ 值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef greedy_modularity_maximization(W, gamma, N):\n    \"\"\"Performs greedy modularity maximization for a given gamma.\"\"\"\n    k = W.sum(axis=1)\n    m2 = k.sum()\n    if m2 == 0:\n        return [{i} for i in range(N)]\n\n    # Initial state: each node is a community\n    communities = {i: {i} for i in range(N)}\n    active_comms = list(range(N))\n    \n    # Community-level properties\n    Sig_tot = {i: k[i] for i in range(N)}\n    Sig_ab = {i: {j: W[i, j] for j in range(N)} for i in range(N)}\n\n    while len(active_comms) > 1:\n        best_delta_Q = 0.0\n        best_pair = None\n\n        # Find best pair to merge among active communities\n        for i_idx, comm_i in enumerate(active_comms):\n            for j_idx in range(i_idx + 1, len(active_comms)):\n                comm_j = active_comms[j_idx]\n                \n                sum_weights_between = Sig_ab[comm_i][comm_j]\n                sum_strengths_i = Sig_tot[comm_i]\n                sum_strengths_j = Sig_tot[comm_j]\n                \n                delta_Q = 2 * (sum_weights_between / m2 - gamma * sum_strengths_i * sum_strengths_j / (m2**2))\n\n                if delta_Q > best_delta_Q:\n                    best_delta_Q = delta_Q\n                    best_pair = (min(comm_i, comm_j), max(comm_i, comm_j))\n        \n        if best_pair is None:\n            break\n        \n        # Perform the merge\n        i, j = best_pair\n        \n        communities[i].update(communities[j])\n        del communities[j]\n        \n        for k_comm in active_comms:\n            if k_comm != i and k_comm != j:\n                new_weight_ik = Sig_ab[i][k_comm] + Sig_ab[j][k_comm]\n                Sig_ab[i][k_comm] = new_weight_ik\n                Sig_ab[k_comm][i] = new_weight_ik\n        \n        del Sig_ab[j]\n        for k_comm in Sig_ab:\n            if j in Sig_ab[k_comm]:\n                del Sig_ab[k_comm][j]\n\n        Sig_tot[i] += Sig_tot[j]\n        del Sig_tot[j]\n        \n        active_comms.remove(j)\n\n    return list(communities.values())\n\ndef perform_enrichment_analysis(modules, pathways, N):\n    \"\"\"Calculates the number of enriched modules.\"\"\"\n    num_modules = len(modules)\n    num_pathways = len(pathways)\n\n    if num_modules == 0 or num_pathways == 0:\n        return 0\n\n    T = num_modules * num_pathways\n    alpha = 0.05\n    threshold = alpha / T if T > 0 else 0.0\n    \n    enriched_module_count = 0\n    for module_nodes in modules:\n        s_set = set(module_nodes)\n        n_size = len(s_set)\n        if n_size == 0 or n_size == N: continue\n\n        is_enriched = False\n        for pathway_nodes in pathways:\n            p_set = set(pathway_nodes)\n            K_size = len(p_set)\n            k_overlap = len(s_set.intersection(p_set))\n            \n            if k_overlap > 0:\n                # hypergeom.sf computes P[X > x], so P[X >= k] = sf(k-1)\n                # M=pop size, n=successes in pop, N=sample size\n                p_val = hypergeom.sf(k_overlap - 1, N, K_size, n_size)\n            else:\n                p_val = 1.0\n\n            if p_val  threshold:\n                is_enriched = True\n                break\n        \n        if is_enriched:\n            enriched_module_count += 1\n            \n    return enriched_module_count\n\ndef select_gamma(W, N, pathways, gamma_grid):\n    \"\"\"Selects the best gamma based on the specified criteria.\"\"\"\n    results = []\n    for gamma in gamma_grid:\n        modules = greedy_modularity_maximization(W, gamma, N)\n        num_modules = len(modules)\n        E_gamma = perform_enrichment_analysis(modules, pathways, N)\n        results.append({\n            \"gamma\": gamma,\n            \"E\": E_gamma,\n            \"num_modules\": num_modules\n        })\n    \n    max_E = -1\n    for res in results:\n        if res[\"E\"] > max_E:\n            max_E = res[\"E\"]\n            \n    candidates_E = [res for res in results if res[\"E\"] == max_E]\n    \n    if len(candidates_E) == 1:\n        return candidates_E[0][\"gamma\"]\n    \n    num_pathways = len(pathways)\n    min_diff = float('inf')\n    for res in candidates_E:\n        diff = abs(res[\"num_modules\"] - num_pathways)\n        if diff  min_diff:\n            min_diff = diff\n            \n    candidates_diff = [res for res in candidates_E if abs(res[\"num_modules\"] - num_pathways) == min_diff]\n    \n    min_gamma = float('inf')\n    best_gamma = None\n    for res in candidates_diff:\n        if res[\"gamma\"]  min_gamma:\n            min_gamma = res[\"gamma\"]\n            best_gamma = res[\"gamma\"]\n    \n    return best_gamma\n\ndef solve():\n    \"\"\"Main function to solve all test cases.\"\"\"\n    # Test Case A\n    N_A = 10\n    P_A1 = {0, 1, 2, 3}\n    P_A2 = {4, 5, 6, 7}\n    pathways_A = [P_A1, P_A2]\n    B_A = {8, 9}\n    W_A = np.zeros((N_A, N_A))\n    for i in range(N_A):\n        for j in range(i + 1, N_A):\n            w = 0.0\n            if (i in P_A1 and j in P_A1) or (i in P_A2 and j in P_A2):\n                w = 1.0\n            elif (i in P_A1 and j in P_A2) or (i in P_A2 and j in P_A1):\n                w = 0.2\n            elif (i in B_A and j not in B_A) or (j in B_A and i not in B_A):\n                w = 0.1\n            elif i in B_A and j in B_A:\n                w = 0.05\n            W_A[i, j] = W_A[j, i] = w\n    W_A[0, 1] += 0.3; W_A[1, 0] += 0.3\n    W_A[2, 3] += 0.3; W_A[3, 2] += 0.3\n    gamma_grid_A = [0.5, 1.0, 2.0]\n    gamma_star_A = select_gamma(W_A, N_A, pathways_A, gamma_grid_A)\n\n    # Test Case B\n    N_B = 6\n    pathways_B = [{0, 1, 2}, {3, 4, 5}]\n    W_B = np.ones((N_B, N_B))\n    np.fill_diagonal(W_B, 0)\n    gamma_grid_B = [0.5, 1.0, 2.0]\n    gamma_star_B = select_gamma(W_B, N_B, pathways_B, gamma_grid_B)\n    \n    # Test Case C\n    N_C = 12\n    P_C1, P_C2, P_C3 = {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}\n    pathways_C = [P_C1, P_C2, P_C3]\n    W_C = np.zeros((N_C, N_C))\n    all_pathways_C = [P_C1, P_C2, P_C3]\n    node_to_pathway = {node: i for i, p in enumerate(all_pathways_C) for node in p}\n    for i in range(N_C):\n        for j in range(i + 1, N_C):\n            p_i, p_j = node_to_pathway[i], node_to_pathway[j]\n            w = 0.0\n            if p_i == p_j:\n                w = 1.0\n            elif (p_i in {0, 1} and p_j in {0, 1}):\n                w = 0.5\n            else:\n                w = 0.1\n            W_C[i, j] = W_C[j, i] = w\n    subpairs = [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11)]\n    for u, v in subpairs:\n        W_C[u, v] += 0.4\n        W_C[v, u] += 0.4\n    gamma_grid_C = [0.3, 1.0, 2.0]\n    gamma_star_C = select_gamma(W_C, N_C, pathways_C, gamma_grid_C)\n\n    final_results = [gamma_star_A, gamma_star_B, gamma_star_C]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}