{
    "hands_on_practices": [
        {
            "introduction": "在掌握了如何比较均值和方差之后，我们现在将深入探索随机模型的描述能力。本练习聚焦于同一个简单的生灭过程，但目标是推导出系统在稳态下的完整统计特性。通过解析求解化学主方程（CME），您将揭示完整的稳态概率分布，这凸显了随机框架相比确定性模型能提供更丰富系统画像的关键优势。",
            "id": "3300898",
            "problem": "考虑一个混合均匀的单细胞系统，其中一种基因产物的拷贝数 $n(t) \\in \\{0,1,2,\\dots\\}$ 遵循一个连续时间马尔可夫跳跃过程，该过程包含以下基元反应：生成（出生）反应以恒定速率 $k_b > 0$ 增加一个分子，降解（死亡）反应以与当前拷贝数成正比的速率（速率常数为 $k_d > 0$）移除一个分子。这对应于反应方案 $\\varnothing \\xrightarrow{k_b} X$ 和 $X \\xrightarrow{k_d} \\varnothing$，其中降解是质量作用过程。设 $P(n,t)$ 表示系统在时间 $t$ 含有 $n$ 个分子的概率。\n\n从这些反应所蕴含的关于 $P(n,t)$ 的柯尔莫哥洛夫前向方程（也称为化学主方程（CME））出发，在稳态分布存在且链是正常返的假设下，推导对于 $n \\in \\mathbb{N}_0$ 的稳态概率质量函数 $P(n)$。以闭合形式表示该稳态分布，并将其识别为一种熟知的离散分布，同时给出其均值。然后，使用大系统尺寸极限下期望拷贝数的确定性对应方程 $dn/dt = k_b - k_d n$，讨论确定性稳态与稳态随机分布均值的一致性。\n\n你的最终答案必须是稳态 $P(n)$ 作为 $n$、$k_b$ 和 $k_d$ 函数的闭合形式表达式。不需要四舍五入，由于 $P(n)$ 是无量纲的，也不需要单位。",
            "solution": "该问题陈述已经过验证，被认为是可靠、适定且有科学依据的。它提出了一个经典的生灭过程，这是随机化学动力学中的一个基本模型。我们可以开始求解。\n\n该系统由两个基元反应描述：\n1. 生成：$\\varnothing \\xrightarrow{k_b} X$，具有恒定的倾向 $a_1(n) = k_b$。此反应使分子数 $n$ 增加 1。\n2. 降解：$X \\xrightarrow{k_d} \\varnothing$，具有质量作用倾向 $a_2(n) = k_d n$。此反应使分子数 $n$ 减少 1。参数 $k_b$ 和 $k_d$ 是正常数。\n\n系统的状态是整数拷贝数 $n \\in \\{0, 1, 2, \\dots\\}$。设 $P(n,t)$ 是在时间 $t$ 处于状态 $n$ 的概率。$P(n,t)$ 的时间演化由柯尔莫哥洛夫前向方程（也称为化学主方程（CME））控制。$P(n,t)$ 的变化率由流入和流出状态 $n$ 的概率流平衡给出：\n$$\n\\frac{dP(n,t)}{dt} = (\\text{流入量}) - (\\text{流出量})\n$$\n对于一般状态 $n \\ge 1$，流入状态 $n$ 的概率流来自状态 $n-1$ 的生成（速率为 $k_b$）和状态 $n+1$ 的降解（速率为 $k_d(n+1)$）。流出状态 $n$ 的概率流通过生成进入状态 $n+1$（速率为 $k_b$），通过降解进入状态 $n-1$（速率为 $k_d n$）。因此，对于 $n \\ge 1$：\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\n对于边界情况 $n=0$，状态 $n-1$ 是不可能的。流入状态 0 的概率流只能通过降解从状态 1 产生。流出状态 0 的概率流只能通过生成进入状态 1。因此：\n$$\n\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)\n$$\n问题要求解的是稳态概率质量函数 $P(n)$，它是 $P(n,t)$ 在 $t \\to \\infty$ 时的极限。在稳态下，对所有 $n$ 都有 $\\frac{dP(n,t)}{dt} = 0$。设 $P(n)$ 表示稳态概率 $P(n, \\infty)$。方程组变为：\n对于 $n \\ge 1$：\n$$\n0 = k_b P(n-1) + k_d(n+1)P(n+1) - (k_b + k_d n)P(n) \\quad (*_1)\n$$\n对于 $n=0$：\n$$\n0 = k_d P(1) - k_b P(0) \\quad (*_2)\n$$\n这是一个生灭过程，其稳态条件意味着任何两个相邻状态之间的净概率流必须为零。这个条件被称为细致平衡。从状态 $n$ 到 $n+1$ 的流是由于生成（$k_b P(n)$），而从状态 $n+1$ 到 $n$ 的流是由于降解（$k_d(n+1)P(n+1)$）。细致平衡条件是：\n$$\nk_b P(n) = k_d(n+1)P(n+1) \\quad \\text{对于 } n \\ge 0\n$$\n这个单一的递推关系等价于无限线性方程组 $(*_1)$ 和 $(*_2)$。例如，对于 $n=0$，它给出 $k_b P(0) = k_d P(1)$，这正是方程 $(*_2)$。将 $k_d(n+1)P(n+1) = k_b P(n)$ 以及通过移动索引得到的 $k_d n P(n) = k_b P(n-1)$ 代入方程 $(*_1)$，我们得到 $0 = k_d n P(n) + k_b P(n) - (k_b + k_d n)P(n) = 0$，从而证实了其有效性。\n\n我们可以求解这个递推关系，用 $P(0)$ 来表示 $P(n)$：\n$$\nP(n+1) = \\frac{k_b}{k_d(n+1)} P(n)\n$$\n让我们迭代以找到通式：\n对于 $n=0$： $P(1) = \\frac{k_b}{k_d(1)}P(0)$\n对于 $n=1$： $P(2) = \\frac{k_b}{k_d(2)}P(1) = \\frac{k_b}{k_d(2)}\\frac{k_b}{k_d(1)}P(0) = \\frac{1}{2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^2 P(0)$\n对于 $n=2$： $P(3) = \\frac{k_b}{k_d(3)}P(2) = \\frac{k_b}{k_d(3)} \\frac{1}{2}\\left(\\frac{k_b}{k_d}\\right)^2 P(0) = \\frac{1}{3 \\cdot 2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^3 P(0)$\n通过归纳法，$P(n)$ 的通式表达式是：\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0)\n$$\n为了求出 $P(0)$，我们使用所有概率之和必须为一的归一化条件：\n$$\n\\sum_{n=0}^{\\infty} P(n) = 1\n$$\n代入我们关于 $P(n)$ 的表达式：\n$$\n\\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0) = 1\n$$\n$$\nP(0) \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n = 1\n$$\n该和式是指数函数 $\\sum_{k=0}^{\\infty} \\frac{x^k}{k!} = \\exp(x)$ 的泰勒级数展开。令 $x = k_b/k_d$，我们有：\n$$\nP(0) \\exp\\left(\\frac{k_b}{k_d}\\right) = 1\n$$\n这给出 $P(0) = \\exp\\left(-\\frac{k_b}{k_d}\\right)$。\n将此结果代回到 $P(n)$ 的表达式中，我们得到稳态概率质量函数的最终闭合形式表达式：\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n \\exp\\left(-\\frac{k_b}{k_d}\\right)\n$$\n这是参数为 $\\lambda = \\frac{k_b}{k_d}$ 的泊松分布的概率质量函数。参数为 $\\lambda$ 的泊松分布随机变量的均值为 $\\lambda$。因此，稳态下的平均拷贝数是：\n$$\n\\langle n \\rangle = \\frac{k_b}{k_d}\n$$\n接下来，我们分析确定性对应方程。拷贝数 $n$ 的确定性速率方程给出为：\n$$\n\\frac{dn}{dt} = k_b - k_d n\n$$\n通过将时间导数设为零来找到确定性稳态 $n_{ss}$：\n$$\n0 = k_b - k_d n_{ss}\n$$\n解出 $n_{ss}$ 得：\n$$\nn_{ss} = \\frac{k_b}{k_d}\n$$\n经过比较，我们发现稳态随机分布的均值 $\\langle n \\rangle$ 与确定性速率方程的稳态 $n_{ss}$ 完全相等。这种完美的一致性是仅包含零级和一级反应（即线性倾向）的系统的特有性质。确定性模型可以看作是忽略了涨落的近似，在这种情况下，它正确地预测了完整随机系统的平均行为。对于涉及高阶反应（非线性倾向）的系统，这种等同关系通常不成立，随机模型的均值将偏离确定性模型的预测。",
            "answer": "$$\n\\boxed{\\frac{1}{n!} \\left( \\frac{k_b}{k_d} \\right)^{n} \\exp\\left(-\\frac{k_b}{k_d}\\right)}\n$$"
        },
        {
            "introduction": "最后，我们将从简单的线性系统转向一个经典的非线性生物回路——基因双稳态开关。确定性模型预测该系统存在两个稳定状态，但无法描述它们之间的转换，而这种转换是由内在噪声驱动的。这个高级练习  要求您实现一种强大的模拟技术来量化这种纯粹的随机现象，从而展示了为什么随机模型对于理解像细胞命运决定这样的复杂细胞行为是不可或缺的。",
            "id": "3300870",
            "problem": "考虑一个在蛋白质层面建模的互斥抑制双稳态开关基因网络，该网络包含两种物质 $X$ 和 $Y$，其在系统状态中的拷贝数由 $(x,y)\\in\\mathbb{N}_0^2$ 给出。$X$ 的产生被 $Y$ 抑制，$Y$ 的产生被 $X$ 抑制。其随机动力学由化学主方程 (CME) 控制，该方程将系统建模为一个在非负整数对格点上的连续时间马尔可夫链，其反应和倾向函数规定如下。反应包括：(1) $X$ 的产生，化学计量变化为 $(+1,0)$；(2) $X$ 的降解，化学计量变化为 $(-1,0)$；(3) $Y$ 的产生，化学计量变化为 $(0,+1)$；(4) $Y$ 的降解，化学计量变化为 $(0,-1)$。相应的倾向函数为 $a_1(x,y)=\\alpha_X/(1+(y/K)^n)$、$a_2(x,y)=\\delta_X x$、$a_3(x,y)=\\alpha_Y/(1+(x/K)^n)$ 和 $a_4(x,y)=\\delta_Y y$，其中 $\\alpha_X$ 和 $\\alpha_Y$ 是最大产率（单位为 $\\text{molecules}\\cdot\\text{min}^{-1}$），$K$ 是抑制阈值（单位为 $\\text{molecules}$），$n$ 是 Hill 系数，$\\delta_X$ 和 $\\delta_Y$ 是一阶降解率（单位为 $\\text{min}^{-1}$）。CME 无穷小生成元 $\\mathcal{L}$ 作用于函数 $f:\\mathbb{N}_0^2\\to\\mathbb{R}$ 的方式如下：\n$$\n(\\mathcal{L}f)(x,y)=\\sum_{j=1}^4 a_j(x,y)\\left[f\\big((x,y)+\\nu_j\\big)-f(x,y)\\right],\n$$\n其中 $\\nu_1=(1,0)$, $\\nu_2=(-1,0)$, $\\nu_3=(0,1)$ 及 $\\nu_4=(0,-1)$。\n\n在确定性极限（平均场）下，期望浓度满足常微分方程 $dx/dt=\\alpha_X/(1+(y/K)^n)-\\delta_X x$ 和 $dy/dt=\\alpha_Y/(1+(x/K)^n)-\\delta_Y y$。对于合适的参数值，系统表现出双稳态，具有两个吸引盆，分别对应于高 $Y$ 低 $X$（记此盆为 $A$）和高 $X$ 低 $Y$（记此盆为 $B$）。随机性会引发从 $A$ 到 $B$ 的稀有切换事件。\n\n您的任务是根据上述内容建立 CME 状态表示，并实现一种稀有事件模拟策略，以使用前向通量采样 (FFS) 估算从吸引盆 $A$ 到吸引盆 $B$ 的切换速率 $k_{A\\to B}$（单位为 $\\text{min}^{-1}$）。使用标量序参量 $\\phi(x,y)=x-y$，并在状态空间中定义以下区域和界面：吸引盆 $A$ 为 $\\{\\phi\\le \\phi_A\\}$，吸引盆 $B$ 为 $\\{\\phi\\ge \\phi_B\\}$，以及中间界面 $\\lambda_0,\\lambda_1,\\cdots,\\lambda_{m-1}$，其中 $\\phi_A < \\lambda_0 < \\lambda_1 < \\cdots < \\lambda_{m-1} < \\phi_B$。\n\n前向通量采样通过以下乘积来估算速率 $k_{A\\to B}$：\n$$\nk_{A\\to B}=\\Phi_A \\times \\prod_{k=0}^{m-1} P(\\lambda_{k+1}\\mid \\lambda_k),\n$$\n其中 $\\Phi_A$ 是源于 $A$ 并穿过 $\\lambda_0$ 的轨迹通量，$P(\\lambda_{k+1}\\mid \\lambda_k)$ 是指轨迹在 $\\lambda_k$ 的条件下，返回 $A$ 之前到达界面 $\\lambda_{k+1}$ 的条件概率。在实现层面：\n- 通过随机模拟算法（SSA；也称为 Gillespie 算法）模拟随机动力学来估算 $\\Phi_A$。从 $A$ 内部深处的一个初始状态开始，累积在 $A$ 中花费的总时间，并计算从 $A$ 直接穿越 $\\lambda_0$ 的次数。将穿越次数除以在 $A$ 中花费的总时间，计算出 $\\Phi_A$。\n- 对于每个阶段 $k$，从在 $\\lambda_k$ 处保存的一组穿越状态开始，启动固定数量的 SSA 试探轨迹，这些轨迹在返回 $A$ 或到达下一个界面（在最后阶段为 $B$）时终止。将成功的试探轨迹比例作为 $P(\\lambda_{k+1}\\mid\\lambda_k)$ 的估算值。",
            "solution": "该问题要求为一个遗传双稳态开关的随机模型估算稀有事件切换速率 $k_{A \\to B}$。该估算将使用前向通量采样 (FFS) 算法进行。解决方案首先详细介绍数学模型和模拟原理，然后对 FFS 的实现进行算法描述。\n\n**1. 系统模型与动力学**\n\n系统由两种相互抑制的蛋白质 $X$ 和 $Y$ 组成。系统状态由这些蛋白质的整数值拷贝数 $(x,y) \\in \\mathbb{N}_0^2$ 给出。系统的随机演化被建模为由化学主方程 (CME) 控制的连续时间马尔可夫链。动力学由四个基本反应定义：每种物质的产生和降解。\n\n反应及其对应的状态转移向量 $\\nu_j$ 如下：\n1. $X$ 的产生：$\\nu_1 = (+1, 0)$\n2. $X$ 的降解：$\\nu_2 = (-1, 0)$\n3. $Y$ 的产生：$\\nu_3 = (0, +1)$\n4. $Y$ 的降解：$\\nu_4 = (0, -1)$\n\n每个反应的速率由其倾向函数 $a_j(x,y)$ 决定：\n1. $a_1(x,y) = \\frac{\\alpha_X}{1 + (y/K)^n}$（$X$ 的产生，受 $Y$ 抑制）\n2. $a_2(x,y) = \\delta_X x$（$X$ 的一阶降解）\n3. $a_3(x,y) = \\frac{\\alpha_Y}{1 + (x/K)^n}$（$Y$ 的产生，受 $X$ 抑制）\n4. $a_4(x,y) = \\delta_Y y$（$Y$ 的一阶降解）\n\n在此，$\\alpha_X$ 和 $\\alpha_Y$ 是最大产率，$\\delta_X$ 和 $\\delta_Y$ 是降解速率常数，$K$ 是抑制阈值，$n$ 是控制抑制陡峭程度的 Hill 系数。\n\n**2. 随机模拟算法 (SSA)**\n\n为了生成此随机系统的动力学精确轨迹，我们采用 Gillespie 随机模拟算法 (SSA)。SSA 是一种模拟每个反应事件的蒙特卡洛过程。对于在时间 $t$ 处于状态 $(x,y)$ 的系统，单个 SSA 步骤包括：\n1. 计算所有倾向函数 $a_j(x,y)$，其中 $j \\in \\{1,2,3,4\\}$。\n2. 计算总倾向函数，$a_{\\text{tot}}(x,y) = \\sum_{j=1}^4 a_j(x,y)$。\n3. 从速率为 $a_{\\text{tot}}$ 的指数分布中抽样，生成到下一次反应发生的时间 $\\Delta t$：$\\Delta t = \\frac{1}{a_{\\text{tot}}} \\ln(\\frac{1}{r_1})$，其中 $r_1$ 是在 $(0,1]$ 上均匀分布的随机数。\n4. 确定发生哪个反应。第 $j$ 个反应以概率 $a_j/a_{\\text{tot}}$ 被选择。这通过抽取第二个在 $(0,1]$ 上均匀分布的随机数 $r_2$ 并找到满足 $\\sum_{k=1}^j a_k(x,y) \\ge r_2 a_{\\text{tot}}(x,y)$ 的最小整数 $j$ 来实现。\n5. 更新系统状态和时间：$(x,y) \\to (x,y) + \\nu_j$ 和 $t \\to t + \\Delta t$。\n\n**3. 用于稀有事件速率估算的前向通量采样 (FFS)**\n\n从高 $Y$/低 $X$ 吸引盆 ($A$) 到高 $X$/低 $Y$ 吸引盆 ($B$) 的转变是一个稀有事件。FFS 是一种通过将转变分解为一系列更可能发生的子事件来有效估算速率 $k_{A \\to B}$ 的方法。这是通过在状态空间中定义一系列位于吸引盆 $A$ 和 $B$ 之间的不相交界面来实现的。\n\n使用序参量 $\\phi(x,y) = x-y$ 来区分吸引盆和定义界面。吸引盆 $A$ 定义为 $\\phi \\le \\phi_A$ 的状态集，吸引盆 $B$ 定义为 $\\phi \\ge \\phi_B$ 的状态集。在两个吸引盆之间放置一组 $m$ 个界面 $\\lambda_0, \\lambda_1, \\ldots, \\lambda_{m-1}$，使得 $\\phi_A < \\lambda_0 < \\lambda_1 < \\cdots < \\lambda_{m-1} < \\phi_B$。\n\nFFS 算法将速率 $k_{A\\to B}$ 估算为离开吸引盆 $A$ 并穿过第一个界面 $\\lambda_0$ 的轨迹通量与一系列到达下一个界面的条件概率的乘积：\n$$\nk_{A\\to B} = \\Phi_A \\times P(\\lambda_1 \\mid \\lambda_0) \\times P(\\lambda_2 \\mid \\lambda_1) \\times \\cdots \\times P(\\phi_B \\mid \\lambda_{m-1}) = \\Phi_A \\prod_{k=0}^{m-1} P(\\lambda_{k+1} \\mid \\lambda_k)\n$$\n其中 $\\lambda_m$ 被视为吸引盆 $B$ 的边界 $\\phi_B$。\n\n实现过程分为两个主要阶段：\n\n**阶段 1：通量估算 $(\\Phi_A)$**\n在吸引盆 $A$ 深处的一个状态启动 SSA 模拟。模拟运行很长一段时间，在此期间，系统在吸引盆 $A$ 中花费的总时间（记为 $T_A^{sim}$）被累积。我们计算轨迹从 $\\phi \\le \\phi_A$ 的状态穿越到 $\\phi > \\lambda_0$ 的状态的次数 $N_c$。然后将通量估算为 $\\Phi_A = N_c / T_A^{sim}$。在此阶段，会保存刚穿过 $\\lambda_0$ 后的 $N_0$ 个独特状态的集合，用于初始化算法的下一阶段。\n\n**阶段 2：条件概率估算 $(P(\\lambda_{k+1} \\mid \\lambda_k))$**\n这个阶段是迭代的。对于每个界面 $\\lambda_k$（$k=0, \\ldots, m-1$）：\n1. 启动一组 $M$ 次试探轨迹。这些试验的起始状态通过从在界面 $\\lambda_k$ 处保存的构型集合中进行抽样（有放回）来选择。\n2. 每个 SSA 试验都进行模拟，直到它返回到吸引盆 $A$（状态为 $\\phi \\le \\phi_A$，计为失败）或到达下一个界面 $\\lambda_{k+1}$（状态为 $\\phi \\ge \\lambda_{k+1}$，计为成功）而终止。\n3. 条件概率 $P(\\lambda_{k+1} \\mid \\lambda_k)$ 被估算为成功试验的比例：$N_{\\text{success}} / M$。\n4. 收集成功轨迹在穿越 $\\lambda_{k+1}$ 时的状态。这个新的状态集合将用作下一个界面 $\\lambda_{k+1}$ 试验的起始池。\n\n如果在任何阶段没有可供开始的构型（因为前一阶段没有成功的试验），则链条中断，总速率 $k_{A\\to B}$ 为零。最后，通过将通量 $\\Phi_A$与所有估算的条件概率相乘来计算总速率。所提供的代码为三个测试案例中的每一个都实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward Flux Sampling algorithm to estimate the switching rate \n    for a stochastic toggle-switch model for three specified test cases.\n    \"\"\"\n\n    # Set a fixed seed for reproducibility as required by the problem.\n    np.random.seed(42)\n\n    def calculate_propensities(state, params):\n        \"\"\"Calculates the propensities for the four reactions.\"\"\"\n        x, y = state\n        alpha_X, alpha_Y, delta_X, delta_Y, K, n = params['alpha_X'], params['alpha_Y'], params['delta_X'], params['delta_Y'], params['K'], params['n']\n        \n        a1 = alpha_X / (1 + (y / K)**n)  # Production of X\n        a2 = delta_X * x                 # Degradation of X\n        a3 = alpha_Y / (1 + (x / K)**n)  # Production of Y\n        a4 = delta_Y * y                 # Degradation of Y\n        \n        return np.array([a1, a2, a3, a4])\n\n    def ssa_step(state, params):\n        \"\"\"Performs a single step of the Gillespie SSA.\"\"\"\n        propensities = calculate_propensities(state, params)\n        total_propensity = np.sum(propensities)\n        \n        if total_propensity == 0:\n            return state, np.inf\n        \n        # Time to next reaction\n        dt = np.random.exponential(1.0 / total_propensity)\n        \n        # Choose which reaction occurs\n        r = np.random.uniform(0, 1) * total_propensity\n        \n        stoichiometry = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n        \n        if r  propensities[0]:\n            reaction_idx = 0\n        elif r  propensities[0] + propensities[1]:\n            reaction_idx = 1\n        elif r  propensities[0] + propensities[1] + propensities[2]:\n            reaction_idx = 2\n        else:\n            reaction_idx = 3\n            \n        new_state = tuple(np.add(state, stoichiometry[reaction_idx]))\n        \n        return new_state, dt\n\n    def order_parameter(state):\n        \"\"\"Calculates the order parameter phi(x,y) = x - y.\"\"\"\n        return state[0] - state[1]\n\n    def run_ffs_case(case_params):\n        \"\"\"Runs the full Forward Flux Sampling simulation for a single case.\"\"\"\n        \n        # --- Phase 0: Flux Estimation (Phi_A) ---\n        time_in_A = 0.0\n        crossings_of_lambda0 = 0\n        saved_crossings = []\n        \n        state = case_params['initial_state']\n        \n        # Unpack FFS parameters\n        interfaces = case_params['interfaces']\n        phi_A = case_params['phi_A']\n        phi_B = case_params['phi_B']\n        lambda_0 = interfaces[0]\n        T_A_budget = case_params['T_A']\n        N_0_max = case_params['N_0']\n\n        # Flux sampling phase\n        while time_in_A  T_A_budget:\n            phi_before = order_parameter(state)\n            \n            new_state, dt = ssa_step(state, case_params)\n            \n            if phi_before = phi_A:\n                time_in_A += dt\n                phi_after = order_parameter(new_state)\n                # Check for crossing from A to outside lambda_0\n                if phi_after > lambda_0:\n                    crossings_of_lambda0 += 1\n                    if len(saved_crossings)  N_0_max:\n                        saved_crossings.append(new_state)\n            \n            state = new_state\n\n        if time_in_A == 0:\n            flux_A = 0.0\n        else:\n            flux_A = crossings_of_lambda0 / time_in_A\n        \n        if flux_A == 0.0 or not saved_crossings:\n            return 0.0\n            \n        # --- Interface Sampling Phases ---\n        cond_probs = []\n        current_configs = saved_crossings\n        \n        full_interface_list = interfaces + [phi_B]\n        \n        for k in range(len(interfaces)):\n            if not current_configs:\n                # If no configurations reached the previous interface, the chain is broken.\n                cond_probs.append(0.0)\n                continue\n                \n            lambda_k_plus_1 = full_interface_list[k+1]\n            \n            num_trials = case_params['M']\n            successes = 0\n            next_configs = []\n            \n            # Sample starting configurations for the trials, with replacement\n            start_indices = np.random.randint(0, len(current_configs), size=num_trials)\n            \n            for idx in start_indices:\n                trial_state = current_configs[idx]\n                \n                # Run trial SSA from the starting configuration\n                while True:\n                    phi = order_parameter(trial_state)\n                    \n                    # Check for termination conditions\n                    if phi = phi_A: # Returned to basin A (failure)\n                        break \n                    if phi >= lambda_k_plus_1: # Reached next interface (success)\n                        successes += 1\n                        next_configs.append(trial_state)\n                        break\n                    \n                    trial_state, _ = ssa_step(trial_state, case_params)\n            \n            prob_k = successes / num_trials if num_trials > 0 else 0.0\n            cond_probs.append(prob_k)\n            \n            current_configs = next_configs\n\n        # --- Final Rate Calculation ---\n        total_prob_product = np.prod(cond_probs)\n        k_A_to_B = flux_A * total_prob_product\n        \n        return k_A_to_B\n\n    test_cases = [\n        # Case 1 (symmetric, moderate bistability)\n        {\n            'alpha_X': 20, 'alpha_Y': 20, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 20), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 2 (asymmetric production favoring X)\n        {\n            'alpha_X': 22, 'alpha_Y': 18, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 18), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 3 (higher copy-number, reduced noise)\n        {\n            'alpha_X': 26, 'alpha_Y': 26, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 26), 'T_A': 300, 'N_0': 20, 'M': 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rate = run_ffs_case(case)\n        results.append(rate)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver\nsolve()\n\n```"
        }
    ]
}