{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨了系统生物学中最基本的模体之一：基因开关。通过对一个具有正反馈自激活的简化基因调控网络进行分析，我们将揭示系统如何在“开”和“关”两种稳定状态之间切换，并产生迟滞现象。此练习通过一个理想化的极限情况（即希尔系数趋于无穷大），将复杂的非线性动力学问题转化为一个可以解析求解的模型，从而清晰地展示鞍结分岔是如何界定双稳态区域的边界的。完成这个练习将帮助你从第一性原理出发，深刻理解正反馈回路产生生物开关和记忆效应的核心机制 。",
            "id": "3290383",
            "problem": "考虑一个具有正向自调控的一维基因调控开关，该开关由一个受线性一阶损耗和外部控制输入影响的希尔型生产项建模。单一物种 $x(t)$ 的浓度动力学由以下公式给出：\n$$\n\\frac{dx}{dt} \\;=\\; \\alpha\\,\\frac{\\left(\\frac{x}{K}\\right)^{n}}{1+\\left(\\frac{x}{K}\\right)^{n}} \\;+\\; u \\;-\\; \\beta\\,x,\n$$\n其中 $\\alpha>0$ 是最大生产速率，$\\beta>0$ 是一阶损耗速率，$K>0$ 是激活阈值，$n\\ge 1$ 是希尔系数，$u\\in\\mathbb{R}$ 是一个可调控制参数，代表一个增加基础生产驱动的外部输入。假设启动子占有率由希尔函数进行准稳态描述，并忽略随机涨落和延迟。\n\n通过设置 $\\frac{dx}{dt}=0$ 来定义稳态输入-输出关系，并考虑 $u$ 的准静态参数扫描，包括递增（上扫）和递减（下扫），从而使折叠（鞍结）分岔界定双稳态区域并产生滞后。在理想标量希尔开关极限 $n\\to\\infty$ 下，希尔函数简化为 $x=K$ 处的亥维赛阶跃函数：\n$$\n\\lim_{n\\to\\infty}\\frac{\\left(\\frac{x}{K}\\right)^{n}}{1+\\left(\\frac{x}{K}\\right)^{n}} = H(x-K) = \\begin{cases} 0, & x  K \\\\ 1,  x > K \\end{cases}\n$$\n仅使用稳态平衡的第一性原理和一维折叠（鞍结）分岔的定义，在此 $n\\to\\infty$ 极限下，推导上扫折叠 $u_{\\mathrm{up}}(\\alpha,\\beta,K)$ 和下扫折叠 $u_{\\mathrm{down}}(\\alpha,\\beta,K)$ 的闭合形式表达式，并计算滞后宽度\n$$\n\\Delta u(\\alpha,\\beta,K,n)\\;=\\;u_{\\mathrm{up}}(\\alpha,\\beta,K)\\;-\\;u_{\\mathrm{down}}(\\alpha,\\beta,K)\n$$\n作为 $(\\alpha,\\beta,K,n)$ 在标量希尔开关极限 $n\\to\\infty$ 下的解析函数。用与 $u$ 相同的单位表示你的最终答案。无需四舍五入。",
            "solution": "该问题要求在无限陡峭响应（希尔系数 $n \\to \\infty$）的理想极限下，分析一维基因调控开关。我们需要推导上扫和下扫鞍结分岔对应的控制参数值（$u_{\\mathrm{up}}$ 和 $u_{\\mathrm{down}}$），并计算由此产生的滞后宽度 $\\Delta u$。\n\n**步骤 1：建立稳态方程**\n系统的动力学方程为：\n$$\n\\frac{dx}{dt} = \\alpha\\,\\frac{\\left(\\frac{x}{K}\\right)^{n}}{1+\\left(\\frac{x}{K}\\right)^{n}} + u - \\beta\\,x\n$$\n在极限 $n\\to\\infty$ 下，希尔函数变为亥维赛阶跃函数 $H(x-K)$。因此，稳态条件 $\\frac{dx}{dt}=0$ 变为一个分段方程：\n$$\n0 = \\alpha H(x-K) + u - \\beta x\n$$\n这可以分为两种情况：\n1.  **“关”态 (x  K):** $H(x-K)=0$，稳态方程为 $u - \\beta x = 0$，解得 $x = u/\\beta$。\n2.  **“开”态 (x > K):** $H(x-K)=1$，稳态方程为 $\\alpha + u - \\beta x = 0$，解得 $x = (\\alpha + u)/\\beta$。\n\n**步骤 2：确定上扫分岔点 ($u_{\\mathrm{up}}$)**\n当从非常低的 $u$ 值开始缓慢增加 $u$ 时（上扫），系统初始处于“关”态分支，即 $x = u/\\beta$。这个解是有效的，只要它满足条件 $x  K$，即 $u/\\beta  K$，或 $u  \\beta K$。\n当 $u$ 增加到临界值，使得 $x$ 恰好等于 $K$ 时，分岔发生。这一点即为上扫的鞍结分岔点 $u_{\\mathrm{up}}$。\n$$\nx = K \\implies u_{\\mathrm{up}}/\\beta = K \\implies u_{\\mathrm{up}} = \\beta K\n$$\n当 $u$ 超过 $u_{\\mathrm{up}}$ 时，“关”态的解不再满足 $x  K$，系统必须“跳”到唯一存在的“开”态分支。\n\n**步骤 3：确定下扫分岔点 ($u_{\\mathrm{down}}$)**\n当从非常高的 $u$ 值开始缓慢减小 $u$ 时（下扫），系统初始处于“开”态分支，即 $x = (\\alpha + u)/\\beta$。这个解是有效的，只要它满足条件 $x > K$，即 $(\\alpha + u)/\\beta > K$，或 $u > \\beta K - \\alpha$。\n当 $u$ 减小到临界值，使得 $x$ 恰好等于 $K$ 时，分岔发生。这一点即为下扫的鞍结分岔点 $u_{\\mathrm{down}}$。\n$$\nx = K \\implies (\\alpha + u_{\\mathrm{down}})/\\beta = K \\implies u_{\\mathrm{down}} = \\beta K - \\alpha\n$$\n当 $u$ 低于 $u_{\\mathrm{down}}$ 时，“开”态的解不再满足 $x > K$，系统必须“跳”回唯一存在的“关”态分支。\n\n**步骤 4：计算滞后宽度 ($\\Delta u$)**\n滞后宽度是两个分岔点之间的距离：\n$$\n\\Delta u = u_{\\mathrm{up}} - u_{\\mathrm{down}} = (\\beta K) - (\\beta K - \\alpha) = \\alpha\n$$\n该宽度直接等于最大生产速率 $\\alpha$，并且在 $n \\to \\infty$ 的极限下不依赖于 $K$ 和 $\\beta$。\n\n因此，上扫折叠点为 $u_{\\mathrm{up}} = \\beta K$，下扫折叠点为 $u_{\\mathrm{down}} = \\beta K - \\alpha$，滞后宽度为 $\\Delta u = \\alpha$。由于问题要求最终答案是滞后宽度，我们报告 $\\alpha$。",
            "answer": "$$\n\\boxed{\\alpha}\n$$"
        },
        {
            "introduction": "生物系统不仅能表现出开关行为，还能产生节律性振荡，例如代谢循环和生物钟。本练习旨在通过分析一个经典的二维激活子-抑制子模型，来探索这种持续振荡行为的数学起源。你将运用线性稳定性分析来确定系统从一个稳定不动点转变为持续振荡的临界条件，这一转变在数学上被称为霍普夫分岔（Hopf bifurcation）。通过这个练习，你将亲手实践如何通过分析雅可比矩阵的特征值来预测振荡的出现，这是分析生物网络动态行为的一项核心技能 。",
            "id": "3290341",
            "problem": "考虑一个用于激活剂-抑制剂生化模块的最小无量纲双变量模型，该模型由一个常微分方程组 (ODEs) 描述，\n$$\n\\dot{X} = \\alpha - X - X Y, \\quad \\dot{Y} = \\mu \\left(X - 1\\right) - Y,\n$$\n其中 $X$ 和 $Y$ 表示分子活性偏离参考状态的归一化偏差（因此它们可以取正值或负值），$\\alpha$ 是一个恒定的驱动参数，$\\mu$ 是一个可调的耦合与时间尺度参数。假设所有参数均为无量纲。\n\n从常微分方程的线性稳定性和局部分岔理论的基本原理出发：\n- 确定系统从其唯一稳态 $(X^{\\ast}, Y^{\\ast})$ 发生霍普夫分岔时的参数值 $\\mu = \\mu_c(\\alpha)$。\n- 计算霍普夫分岔初始发生时（即当 $\\mu = \\mu_c$ 时）的角振荡频率 $\\omega_c(\\alpha)$。\n\n将您的最终结果表示为关于 $\\alpha$ 的闭式解析表达式。如果需要任何参数限制以确保分岔初始发生时是具有实数振荡频率的真正霍普夫分岔，请在您的推理过程中说明。最终答案不需要进行数值舍入，也不应报告 $\\omega_c$ 的单位（该模型是无量纲的）。",
            "solution": "问题要求解给定双变量生化系统中发生霍普夫分岔的临界参数值 $\\mu_c(\\alpha)$ 和振荡频率 $\\omega_c(\\alpha)$。分析将从线性稳定性理论的基本原理出发。\n\n该常微分方程组 (ODEs) 为：\n$$\n\\dot{X} = \\alpha - X - X Y\n$$\n$$\n\\dot{Y} = \\mu(X - 1) - Y\n$$\n\n首先，我们通过将时间导数设为零来确定系统的稳态 $(X^{\\ast}, Y^{\\ast})$：\n$$\n\\dot{X} = 0 \\implies \\alpha - X^{\\ast} - X^{\\ast}Y^{\\ast} = 0\n$$\n$$\n\\dot{Y} = 0 \\implies \\mu(X^{\\ast} - 1) - Y^{\\ast} = 0\n$$\n从第二个方程，我们可以用 $X^{\\ast}$ 表示 $Y^{\\ast}$：\n$$\nY^{\\ast} = \\mu(X^{\\ast} - 1)\n$$\n将此代入第一个方程，得到一个关于 $X^{\\ast}$ 的二次方程：\n$$\n\\alpha - X^{\\ast} - X^{\\ast}[\\mu(X^{\\ast} - 1)] = 0\n$$\n$$\n\\alpha - X^{\\ast} - \\mu(X^{\\ast})^2 + \\mu X^{\\ast} = 0\n$$\n$$\n\\mu(X^{\\ast})^2 + (1 - \\mu)X^{\\ast} - \\alpha = 0\n$$\n这个二次方程的判别式是 $\\Delta = (1-\\mu)^2 - 4(\\mu)(-\\alpha) = (1-\\mu)^2 + 4\\mu\\alpha$。对于具有物理意义的参数（例如 $\\alpha0, \\mu0$），$\\Delta  0$，这意味着 $X^{\\ast}$ 有两个不同的实数根。这与问题中“唯一稳态”的前提相矛盾。然而，在生化系统的背景下，区分具有正活性或负活性的状态是常见的。可以证明 $X^{\\ast}$ 的两个根符号相反。我们将不预先假设哪个稳态是相关的，而是通过确定霍普夫分岔的条件来继续进行，正确的稳态将由分析确定。\n\n接下来，我们通过计算系统的雅可比矩阵 $J$ 来进行线性稳定性分析：\n$$\nJ(X, Y) = \\begin{pmatrix} \\frac{\\partial \\dot{X}}{\\partial X}  \\frac{\\partial \\dot{X}}{\\partial Y} \\\\ \\frac{\\partial \\dot{Y}}{\\partial X}  \\frac{\\partial \\dot{Y}}{\\partial Y} \\end{pmatrix} = \\begin{pmatrix} -1 - Y  -X \\\\ \\mu  -1 \\end{pmatrix}\n$$\n我们在稳态 $(X^{\\ast}, Y^{\\ast})$ 处计算雅可比矩阵：\n$$\nJ^{\\ast} = J(X^{\\ast}, Y^{\\ast}) = \\begin{pmatrix} -1 - Y^{\\ast}  -X^{\\ast} \\\\ \\mu  -1 \\end{pmatrix}\n$$\n当 $J^{\\ast}$ 的特征值为纯虚数，即 $\\lambda = \\pm i\\omega_c$ 且 $\\omega_c \\neq 0$，并且当分岔参数 $\\mu$ 变化时特征值穿越虚轴，霍普夫分岔便发生。对于一个 $2 \\times 2$ 矩阵，这对应于两个条件：\n1. 雅可比矩阵的迹为零：$\\text{Tr}(J^{\\ast}) = 0$。\n2. 雅可比矩阵的行列式为正：$\\text{Det}(J^{\\ast})  0$。\n\n$J^{\\ast}$ 的迹是：\n$$\n\\tau = \\text{Tr}(J^{\\ast}) = (-1 - Y^{\\ast}) + (-1) = -2 - Y^{\\ast}\n$$\n将迹设为零，得到分岔的条件：\n$$\n\\tau = 0 \\implies -2 - Y^{\\ast}_c = 0 \\implies Y^{\\ast}_c = -2\n$$\n这里，下标 $c$ 表示在临界分岔点的值。\n\n$J^{\\ast}$ 的行列式是：\n$$\n\\Delta_J = \\text{Det}(J^{\\ast}) = (-1 - Y^{\\ast})(-1) - (-X^{\\ast})(\\mu) = 1 + Y^{\\ast} + \\mu X^{\\ast}\n$$\n霍普夫分岔的第二个条件 $\\Delta_J  0$ 将被用来求解振荡频率并约束参数 $\\alpha$。\n\n现在，我们使用稳态方程来找出对应于 $Y^{\\ast}_c = -2$ 的 $X^{\\ast}_c$ 和 $\\mu_c$ 的值。\n根据稳态关系 $\\alpha - X^{\\ast} - X^{\\ast}Y^{\\ast} = 0$：\n$$\n\\alpha - X^{\\ast}_c - X^{\\ast}_c(-2) = 0 \\implies \\alpha + X^{\\ast}_c = 0 \\implies X^{\\ast}_c = -\\alpha\n$$\n根据另一个稳态关系 $Y^{\\ast} = \\mu(X^{\\ast} - 1)$：\n$$\n-2 = \\mu_c(X^{\\ast}_c - 1) = \\mu_c(-\\alpha - 1) = -\\mu_c(\\alpha + 1)\n$$\n解出 $\\mu_c$ 得到：\n$$\n\\mu_c(\\alpha) = \\frac{2}{\\alpha + 1}\n$$\n为使 $\\mu_c$ 为正，我们必须有 $\\alpha + 1  0$，所以 $\\alpha  -1$。\n\n现在我们检查第二个霍普夫条件，$\\Delta_J  0$。在分岔点，角振荡频率的平方 $\\omega_c^2$ 等于在临界点计算的雅可比矩阵的行列式。\n$$\n\\omega_c^2 = \\Delta_{J,c} = 1 + Y^{\\ast}_c + \\mu_c X^{\\ast}_c\n$$\n代入 $Y^{\\ast}_c$、$\\mu_c$ 和 $X^{\\ast}_c$ 的表达式：\n$$\n\\omega_c^2 = 1 + (-2) + \\left(\\frac{2}{\\alpha + 1}\\right)(-\\alpha) = -1 - \\frac{2\\alpha}{\\alpha + 1}\n$$\n$$\n\\omega_c^2 = \\frac{-(\\alpha + 1) - 2\\alpha}{\\alpha + 1} = \\frac{-3\\alpha - 1}{\\alpha + 1}\n$$\n为了发生霍普夫分岔，我们需要 $\\omega_c$ 是实数且非零，这要求 $\\omega_c^2  0$：\n$$\n\\frac{-3\\alpha - 1}{\\alpha + 1}  0 \\implies \\frac{3\\alpha + 1}{\\alpha + 1}  0\n$$\n当分子和分母符号相反时，此不等式成立。根为 $\\alpha = -1/3$ 和 $\\alpha = -1$。该不等式在 $\\alpha \\in (-1, -1/3)$ 时满足。这是系统要表现出霍普夫分岔时对参数 $\\alpha$ 的一个必要限制。\n\n角振荡频率 $\\omega_c$ 是该表达式的平方根：\n$$\n\\omega_c(\\alpha) = \\sqrt{\\frac{-1 - 3\\alpha}{1 + \\alpha}}\n$$\n在为 $\\alpha$ 推导出的范围内，此表达式是实数且为正。\n\n总之，当临界参数值为 $\\mu_c = \\frac{2}{1+\\alpha}$ 时，系统从稳态 $(X^{\\ast}, Y^{\\ast}) = (-\\alpha, -2)$ 发生霍普夫分岔，条件是参数 $\\alpha$ 被限制在区间 $(-1, -1/3)$ 内。\n\n所求的表达式为：\n1. 临界耦合参数：$\\mu_c(\\alpha) = \\frac{2}{\\alpha+1}$\n2. 角振荡频率：$\\omega_c(\\alpha) = \\sqrt{\\frac{-1-3\\alpha}{1+\\alpha}}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{2}{1+\\alpha}  \\sqrt{\\frac{-1-3\\alpha}{1+\\alpha}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "解析解为我们提供了深刻的洞见，但大多数真实的生物化学模型都非常复杂，难以手动求解。因此，我们需要依赖强大的计算工具来系统地探索系统行为。本练习介绍了一种关键的数值方法——伪弧长延拓法（pseudo-arclength continuation），该方法能够有效地追踪系统的平衡解分支，尤其擅长处理标准参数延拓法会失效的折叠点（fold bifurcations）。你不仅需要从第一性原理推导该方法所依赖的增广方程组，还需亲手编程实现这一算法，以追踪一个典型双稳态系统的完整S形曲线 。这项练习将理论与计算实践相结合，是生成复杂非线性系统分岔图、获得其全局动力学视图的关键一步。",
            "id": "3290396",
            "problem": "考虑一个无量纲化的双稳态生化反应网络，其宏观动力学由单个有效状态变量的常微分方程 $dx/dt = f(x,\\mu)$ 描述，其中 $x$ 是无量纲浓度，$\\mu$ 是一个封装了外部输入强度的无量纲控制参数。在稳态下，平衡点满足 $f(x,\\mu)=0$，该方程通过 $F(x,\\mu)=0$ 且 $F(x,\\mu)=f(x,\\mu)$ 隐式地定义了一个平衡分支。在分支的折叠点（转折点），平衡流形在参数空间中局部变为垂直，标准的参数延拓方法会失效。伪弧长延拓是一种预测-校正策略，它通过使用一个类弧长变量对分支进行重新参数化，并用一个标量约束来增广平衡方程，从而追踪平衡分支通过折叠点。\n\n从隐函数定理、平衡点定义 $F(x,\\mu)=0$ 以及 $F(x,\\mu)$ 对其参数的可微性这些基本概念出发，推导用于标量平衡方程的伪弧长延拓方法。具体来说，你必须解释用于强制平衡流形不变性的切线构造方法，并说明为何一个带有标量约束的增广系统足以使通过折叠点的校正步正则化。你必须完全从第一性原理和核心定义出发，写出并论证在预测-校正步骤中使用的增广系统及其雅可比矩阵，不得引用任何未经推导的快捷公式。\n\n然后，实现一个程序，对以下无量纲三次范式生化稳态模型执行伪弧长延拓：\n$$F(x,\\mu) = \\mu - x + x^3,$$\n该模型是在适当的无量纲化和截断至主导非线性阶后，从一个正反馈系统得到的。此模型表现出两个对称的折叠点。你的实现必须：\n- 根据平衡不变性条件，在每个延拓点构造单位长度的切线方向。\n- 使用一个前向预测步，步长为用户指定的带符号弧长步长，然后通过一个牛顿型校正器求解推导出的增广系统及其雅可比矩阵。\n- 在步骤之间保持一致的切线方向，以避免方向的来回翻转。\n- 对每个测试用例，推进固定数量的延拓步，并报告沿计算出的分支段遇到的参数 $\\mu$ 的最大绝对值，作为一个浮点数。这可作为折叠点参数大小的数值估计。\n\n角度单位不适用，并且由于系统是无量纲的，没有物理单位。程序必须为以下测试套件输出结果，每个测试用例指定为一个元组 $(x_0, ds, n_{\\text{steps}}, \\sigma)$，其中 $x_0$ 是初始平衡态，$ds$ 是带符号的弧长步长，$n_{\\text{steps}}$ 是延拓步数，$\\sigma \\in \\{-1,+1\\}$ 设置切线的初始方向，当 $\\sigma=-1$ 时使 $x$ 减小，当 $\\sigma=+1$ 时使 $x$ 增大：\n1. $(0.8, 0.05, 80, -1)$：在正分支上以中等步长逼近正折叠点的一般情况。\n2. $(0.7, 0.02, 120, -1)$：在正分支上使用小步长，以更精细地探测折叠点附近的行为。\n3. $(-0.8, 0.04, 80, +1)$：在负分支上逼近负折叠点的情况。\n\n你的程序应生成单行输出，其中包含三个结果浮点值，形式为逗号分隔的列表并用方括号括起（例如，“[r1,r2,r3]”）。每个结果必须是标准十进制形式的浮点数。程序必须完全自包含，不需要用户输入。",
            "solution": "该问题是有效的，因为它提出了一个来自计算系统生物学和数值分析领域、定义良好且具有科学依据的任务。它要求推导和实现伪弧长延拓方法，这是一种用于追踪非线性系统解分支通过折叠分岔的标准且重要技术。所有必要信息，包括控制方程、初始条件和数值参数，均已提供。所使用的模型 $F(x,\\mu) = \\mu - x + x^3 = 0$ 是折叠分岔的典范范式，可作为一个经典、可验证的测试案例。\n\n任务是追踪一个动力学系统的平衡流形。平衡点是方程 $F(x,\\mu) = 0$ 的稳态解 $(x, \\mu)$。该方程在 $(x, \\mu)$ 参数空间中隐式定义了一条曲线。一种追踪此曲线的简单方法，称为参数延拓，是在离散的参数 $\\mu$ 值上求解 $x$。该方法在折叠点（或称转折点）分岔处会失效。在折叠点，曲线相对于 $\\mu$ 轴局部变为垂直，意味着 $d\\mu/dx = 0$。系统关于状态变量的雅可比矩阵 $F_x = \\partial F/\\partial x$ 变为奇异矩阵 ($F_x=0$)，导致像牛顿法这样依赖于 $F_x$ 逆矩阵的数值方法失效。伪弧长延拓通过用一个类弧长变量 $s$ 对曲线进行重新参数化，将 $x$ 和 $\\mu$ 都视为因变量，从而解决了这个问题。\n\n设解曲线由弧长 $s$ 参数化，因此我们有一条路径 $\\mathbf{z}(s) = (x(s), \\mu(s))^T$。对于此路径上的任何点，平衡条件 $F(x(s), \\mu(s)) = 0$ 必须成立。这就是平衡不变性条件。使用链式法则对该恒等式关于 $s$ 求导，得到：\n$$ \\frac{dF}{ds} = \\frac{\\partial F}{\\partial x} \\frac{dx}{ds} + \\frac{\\partial F}{\\partial \\mu} \\frac{d\\mu}{ds} = 0 $$\n这可以表示为点积形式 $\\nabla F \\cdot \\mathbf{t} = 0$，其中 $\\nabla F = (\\partial F/\\partial x, \\partial F/\\partial \\mu)^T = (F_x, F_\\mu)^T$ 是函数 $F$ 的梯度，而 $\\mathbf{t} = (dx/ds, d\\mu/ds)^T = (\\dot{x}, \\dot{\\mu})^T$ 是解曲线的单位切向量。这个基本方程表明，曲线的切线总是与函数 $F$ 的梯度正交。在二维空间 $(x, \\mu)$ 中，与向量 $(a, b)$ 正交的向量是 $(-b, a)$。因此，切向量 $\\mathbf{t}$ 必须与向量 $(-F_\\mu, F_x)$ 平行。为获得单位切向量，我们对此向量进行归一化：\n$$ \\mathbf{t} = (\\dot{x}, \\dot{\\mu}) = \\pm \\frac{(-F_\\mu, F_x)}{\\sqrt{F_\\mu^2 + F_x^2}} $$\n符号的选择决定了沿曲线行进的方向。\n\n伪弧长方法是一种预测-校正算法。给定曲线上的一个已知点 $(x_k, \\mu_k)$ 及其对应的单位切线 $\\mathbf{t}_k = (\\dot{x}_k, \\dot{\\mu}_k)$，预测步通过沿切线方向前进一个步长 $ds$ 来计算下一个点的估计值：\n$$ (x_p, \\mu_p) = (x_k, \\mu_k) + ds \\cdot \\mathbf{t}_k $$\n这个预测点 $(x_p, \\mu_p)$ 靠近解曲线，但通常不在曲线上。\n\n校正步对此预测进行修正，以找到一个新的点 $(x_{k+1}, \\mu_{k+1})$ 满足平衡条件。为此，我们必须求解两个未知数 $x$ 和 $\\mu$，因此需要一个包含两个方程的方程组。第一个方程是原始的平衡方程 $F(x, \\mu) = 0$。第二个方程是一个约束条件，用以在预测点附近唯一地确定曲线上的一个点。一个具有几何意义且稳健的选择是伪弧长约束，它强制从前一个点 $(x_k, \\mu_k)$ 到新点 $(x, \\mu)$ 的向量在切线 $\\mathbf{t}_k$ 上的投影长度为 $ds$。该约束表示为：\n$$ N(x, \\mu) \\equiv (\\mathbf{z} - \\mathbf{z}_k) \\cdot \\mathbf{t}_k - ds = 0 $$\n$$ (x - x_k)\\dot{x}_k + (\\mu - \\mu_k)\\dot{\\mu}_k - ds = 0 $$\n这提供了所需的第二个方程。我们现在有了一个针对两个未知数 $(x, \\mu)$ 的增广非线性方程组：\n$$ \\mathbf{G}(x, \\mu) = \\begin{pmatrix} F(x, \\mu) \\\\ N(x, \\mu) \\end{pmatrix} = \\mathbf{0} $$\n该系统可以使用牛顿法求解，从预测点 $(x_p, \\mu_p)$ 作为初始猜测开始。牛顿法的迭代更新公式为 $\\mathbf{z}_{j+1} = \\mathbf{z}_j - J_{\\mathbf{G}}^{-1} \\mathbf{G}(\\mathbf{z}_j)$，其中 $\\mathbf{z}_j = (x_j, \\mu_j)^T$ 是当前猜测，而 $J_{\\mathbf{G}}$ 是增广系统的雅可比矩阵。该雅可比矩阵由 $F$ 和 $N$ 的偏导数构成：\n$$ J_{\\mathbf{G}}(x, \\mu) = \\begin{pmatrix} \\frac{\\partial F}{\\partial x}  \\frac{\\partial F}{\\partial \\mu} \\\\ \\frac{\\partial N}{\\partial x}  \\frac{\\partial N}{\\partial \\mu} \\end{pmatrix} = \\begin{pmatrix} F_x  F_\\mu \\\\ \\dot{x}_k  \\dot{\\mu}_k \\end{pmatrix} $$\n该方法成功的关键在于，即使在 $F_x=0$ 的折叠点，这个雅可比矩阵 $J_{\\mathbf{G}}$ 仍然是非奇异的。在这样的点（假设是一个 $F_\\mu \\neq 0$ 的一般折叠点），切向量 $\\mathbf{t} \\propto (-F_\\mu, F_x)$ 变得与 $(-F_\\mu, 0)$ 成比例。对于单位切线，如果我们恰好在折叠点（经过适当归一化后），我们会有 $(\\dot{x}_k, \\dot{\\mu}_k) = (\\pm 1, 0)$。在折叠点的雅可比行列式为 $\\det(J_{\\mathbf{G}}) = F_x \\dot{\\mu}_k - F_\\mu \\dot{x}_k = (0)\\dot{\\mu}_k - F_\\mu \\dot{x}_k = -F_\\mu \\dot{x}_k$。由于在折叠点 $F_\\mu$ 和 $\\dot{x}_k$ 均不为零，行列式不为零，系统是正则的。因此，牛顿法是良定义的，并且可以收敛到曲线上的解，从而使算法能够无缝地追踪解路径通过转折点。\n\n在每个成功的校正步产生一个新点 $(x_{k+1}, \\mu_{k+1})$ 后，会在此新点计算切向量 $\\mathbf{t}_{k+1}$。为确保一致的行进方向并防止算法反向，需要调整新切线的方向。这通过将其方向与前一个切线 $\\mathbf{t}_k$ 进行比较来完成。如果点积 $\\mathbf{t}_{k+1} \\cdot \\mathbf{t}_k  0$，这表明朴素计算出的新切线相对于路径指向后方，因此其符号被翻转：$\\mathbf{t}_{k+1} \\leftarrow -\\mathbf{t}_{k+1}$。此过程保持了方向，并允许完整追踪平衡分支。对于具体问题 $F(x,\\mu)=\\mu - x + x^3$，其导数为 $F_x(x,\\mu) = -1+3x^2$ 和 $F_\\mu(x,\\mu)=1$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the pseudo-arclength continuation for\n    the specified test cases and prints the results.\n    \"\"\"\n\n    def run_continuation(x0, ds, n_steps, initial_orientation_sigma, tol=1e-8, max_newton_iter=10):\n        \"\"\"\n        Performs pseudo-arclength continuation for a given starting point and parameters.\n\n        Args:\n            x0 (float): Initial equilibrium state x.\n            ds (float): Signed arclength step size.\n            n_steps (int): Number of continuation steps.\n            initial_orientation_sigma (int): Sets the initial tangent orientation for x (+1 or -1).\n            tol (float): Convergence tolerance for Newton's method.\n            max_newton_iter (int): Maximum iterations for Newton's method.\n\n        Returns:\n            float: The maximum absolute value of mu encountered along the branch.\n        \"\"\"\n        # Define the system equation and its partial derivatives\n        F = lambda x, mu: mu - x + x**3\n        Fx = lambda x, mu: -1 + 3 * x**2\n        Fmu = lambda x, mu: 1.0\n\n        # --- Initialization ---\n        # Find initial mu0 for the given x0\n        x = x0\n        mu = x - x**3\n        mu_history = [mu]\n\n        # --- Compute and orient initial tangent ---\n        fx_val = Fx(x, mu)\n        fmu_val = Fmu(x, mu)\n        \n        # Calculate base tangent (normalized)\n        t_unnormalized = np.array([-fmu_val, fx_val])\n        t_base = t_unnormalized / np.linalg.norm(t_unnormalized)\n\n        # Orient the tangent according to initial_orientation_sigma\n        # We want sign(t[0]) to be equal to initial_orientation_sigma.\n        # sign(t_base[0]) = sign(-fmu_val) = -1.\n        # Desired_sign = sigma. current_sign = -1. multiplier = desired/current = -sigma\n        t = -initial_orientation_sigma * t_base\n\n        # --- Continuation Loop ---\n        for _ in range(n_steps):\n            # Store previous point and tangent\n            x_k, mu_k = x, mu\n            t_k = t\n\n            # --- Predictor Step ---\n            # Take a step of size ds along the tangent\n            x_p = x_k + ds * t_k[0]\n            mu_p = mu_k + ds * t_k[1]\n\n            # --- Corrector Step (Newton's Method) ---\n            x_j, mu_j = x_p, mu_p # Initial guess for corrector\n            \n            for _ in range(max_newton_iter):\n                # Evaluate augmented system residual G = [F; N]\n                G1 = F(x_j, mu_j)\n                G2 = (x_j - x_k) * t_k[0] + (mu_j - mu_k) * t_k[1] - ds\n                G_vec = np.array([G1, G2])\n\n                # Check for convergence\n                if np.linalg.norm(G_vec)  tol:\n                    break\n\n                # Evaluate augmented Jacobian J_G\n                J11 = Fx(x_j, mu_j)\n                J12 = Fmu(x_j, mu_j)\n                J21 = t_k[0]\n                J22 = t_k[1]\n                Jac = np.array([[J11, J12], [J21, J22]])\n\n                # Solve linear system J * delta = -G\n                try:\n                    delta = np.linalg.solve(Jac, -G_vec)\n                except np.linalg.LinAlgError:\n                    # Jacobian is singular, continuation fails.\n                    # This shouldn't happen with this method if ds is reasonable.\n                    # As a fallback, we stop here.\n                    return np.max(np.abs(np.array(mu_history)))\n\n                # Update solution\n                x_j += delta[0]\n                mu_j += delta[1]\n\n            # Update state to the corrected point\n            x, mu = x_j, mu_j\n            mu_history.append(mu)\n\n            # --- Update Tangent for next step ---\n            fx_val = Fx(x, mu)\n            fmu_val = Fmu(x, mu)\n\n            t_new_unnormalized = np.array([-fmu_val, fx_val])\n            t_new = t_new_unnormalized / np.linalg.norm(t_new_unnormalized)\n\n            # Maintain consistent orientation\n            if np.dot(t_new, t_k)  0:\n                t_new = -t_new\n            \n            t = t_new\n\n        return np.max(np.abs(np.array(mu_history)))\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (x0, ds, n_steps, sigma)\n        (0.8, 0.05, 80, -1),\n        (0.7, 0.02, 120, -1),\n        (-0.8, 0.04, 80, +1),\n    ]\n\n    results = []\n    for case in test_cases:\n        x0, ds, n_steps, sigma = case\n        max_abs_mu = run_continuation(x0, ds, n_steps, sigma)\n        results.append(max_abs_mu)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}