{
    "hands_on_practices": [
        {
            "introduction": "The Chemical Master Equation (CME) provides a complete description of a stochastic chemical system, but it presents a major computational hurdle: it is a system of, typically, an infinite number of coupled ordinary differential equations. The Finite State Projection (FSP) is a powerful numerical method that addresses this by truncating the infinite state space to a manageable, finite size while rigorously bounding the error introduced by this truncation. This exercise  will guide you through the implementation of the FSP algorithm for a canonical birth-death process, allowing you to compare your numerical results and the FSP error bound against the exact analytical solution, thereby building a solid, practical understanding of this cornerstone technique.",
            "id": "3351584",
            "problem": "Consider a well-mixed biochemical reaction system with a single species $X$ undergoing zero-order production and first-order degradation. The reactions are $\\emptyset \\rightarrow X$ with production rate $\\lambda$ (units: molecules per minute) and $X \\rightarrow \\emptyset$ with degradation rate $\\mu$ (units: per minute). Let $X(t)$ denote the molecule count at time $t$ and let $p_n(t)$ denote the probability that $X(t) = n$.\n\nFundamental base and core definitions:\n- The Chemical Master Equation (CME) for a continuous-time Markov jump process on the count states $n \\in \\{0,1,2,\\dots\\}$ is constructed from the propensity functions. For the given reactions, the propensities are $a_{\\text{birth}}(n) = \\lambda$ and $a_{\\text{death}}(n) = \\mu n$.\n- The CME describes the time evolution of $p_n(t)$ by the balance of probability fluxes into and out of each state. For $n \\ge 0$, this can be written as\n$$\n\\frac{d}{dt} p_n(t) = \\lambda p_{n-1}(t) + \\mu (n+1) p_{n+1}(t) - \\left(\\lambda + \\mu n\\right) p_n(t),\n$$\nwith the convention that $p_{-1}(t) \\equiv 0$.\n- The Finite State Projection (FSP) method constructs a truncated state-space $\\mathcal{S}_N = \\{0,1,\\dots,N\\}$ and augments it with an absorbing sink state that captures all instantaneous probability fluxes from any state in $\\mathcal{S}_N$ to states outside $\\mathcal{S}_N$. The modified generator $A_{\\text{FSP}}$ on the augmented space ensures that any transition that would leave $\\mathcal{S}_N$ is redirected to the sink, which has no outgoing transitions. The resulting sink probability at time $t$ is an upper bound on the true probability that the process lies outside $\\mathcal{S}_N$ at time $t$.\n\nDerivation targets:\n- Starting from the CME and the FSP construction principles, derive the generator $A_{\\text{FSP}}$ for the truncated system with the absorbing sink.\n- Given the initial condition $p_n(0) = \\delta_{n,n_0}$ for some integer $n_0 \\ge 0$ (Kronecker delta), compute the FSP-approximated state probabilities at time $T$ by solving the linear system $\\frac{d}{dt} \\mathbf{p}(t) = A_{\\text{FSP}} \\mathbf{p}(t)$, where $\\mathbf{p}(t)$ includes the probabilities for states $0,1,\\dots,N$ and the sink.\n- Independently, derive the exact distribution of $X(T)$ for the immigration-death process with deterministic initial condition $X(0) = n_0$. Use first principles of stochastic kinetics for linear reactions: each of the $n_0$ initial molecules survives independently with probability $e^{-\\mu T}$, and the contributions from births form a Poisson process with a time-dependent rate whose surviving molecules at time $T$ yield a Poisson-distributed count with mean $m(T) = \\frac{\\lambda}{\\mu}\\left(1 - e^{-\\mu T}\\right)$ (for $\\mu > 0$). Conclude that $X(T)$ is the sum of two independent random variables: a Binomial random variable with parameters $(n_0, e^{-\\mu T})$ and a Poisson random variable with mean $m(T)$.\n- From this exact characterization, derive the true outside probability at time $T$, namely $\\mathbb{P}\\left[X(T) > N\\right]$, by convolving the Binomial and Poisson distributions and expressing the Poisson tail in terms of the regularized incomplete gamma function.\n\nProgramming task:\n- Implement a program that, for each provided test case $(\\lambda, \\mu, n_0, T, N)$, performs the following:\n  1. Constructs the FSP generator $A_{\\text{FSP}}$ on states $\\{0,1,\\dots,N\\}$ plus an absorbing sink, consistent with the CME and FSP principles. The off-diagonal entries correspond to valid transitions within the truncated space, while transitions from $N$ to $N+1$ are redirected to the sink. The diagonal entries enforce column-wise conservation of probability fluxes within the truncated model.\n  2. Computes the probability vector at time $T$ using the matrix exponential solution $\\mathbf{p}(T) = \\exp\\left(T A_{\\text{FSP}}\\right)\\mathbf{p}(0)$, and extracts the sink probability $s(T)$, which upper-bounds the true outside probability.\n  3. Computes the exact outside probability $\\mathbb{P}\\left[X(T) > N\\right]$ by summing over $b = 0,1,\\dots,n_0$ of the Binomial probability for $b$ survivors of the initial molecules and the survival function of the Poisson component exceeding $N-b$, using the regularized incomplete gamma function to evaluate the Poisson tail precisely.\n  4. Outputs, for each test case, the nonnegative difference $s(T) - \\mathbb{P}\\left[X(T) > N\\right]$ as a floating-point number. This difference quantifies how conservative the FSP upper bound is at time $T$.\n\nUnits:\n- The rates $\\lambda$ and $\\mu$ are per minute, and the time $T$ is in minutes. The outputs are probabilities and thus unitless real numbers.\n\nTest suite:\n- Use the following test cases, which explore typical behavior, truncation conservatism, and edge conditions:\n  1. $(\\lambda, \\mu, n_0, T, N) = (5.0, 0.5, 0, 10.0, 40)$.\n  2. $(\\lambda, \\mu, n_0, T, N) = (20.0, 1.0, 30, 2.0, 35)$.\n  3. $(\\lambda, \\mu, n_0, T, N) = (2.0, 0.1, 50, 5.0, 15)$.\n  4. $(\\lambda, \\mu, n_0, T, N) = (3.0, 0.2, 0, 6.0, 0)$.\n\nAnswer specification:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. For example, the required final format is $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the floating-point value of $s(T) - \\mathbb{P}\\left[X(T) > N\\right]$ for the $i$-th test case.",
            "solution": "The problem is valid as it is scientifically grounded in the theory of stochastic chemical kinetics, is well-posed with all necessary information provided, and is stated objectively. We can therefore proceed with the derivation and solution.\n\nThe problem asks for the computation and comparison of two quantities related to the probability of a stochastic birth-death process exceeding a certain population count $N$. The first quantity is the sink probability $s(T)$ derived from the Finite State Projection (FSP) method, which provides an upper bound on the true probability. The second is the exact probability $\\mathbb{P}(X(T) > N)$.\n\n### 1. Derivation of the FSP Generator Matrix $A_{\\text{FSP}}$\n\nThe Finite State Projection (FSP) method provides an approximation to the solution of the Chemical Master Equation (CME) by truncating the infinite state space to a finite set $\\mathcal{S}_N = \\{0, 1, \\dots, N\\}$. To ensure that probability is conserved, a sink state is added to collect all probability mass that would exit $\\mathcal{S}_N$. We define an augmented state vector $\\mathbf{p}(t)$ of size $N+2$:\n$$\n\\mathbf{p}(t) = [p_0(t), p_1(t), \\dots, p_N(t), s(t)]^T\n$$\nwhere $p_n(t)$ is the probability of having $n$ molecules and $s(t)$ is the probability of being in the sink state. The time evolution of this vector is governed by a linear system of ordinary differential equations, $\\frac{d}{dt}\\mathbf{p}(t) = A_{\\text{FSP}}\\mathbf{p}(t)$, where $A_{\\text{FSP}}$ is the $(N+2) \\times (N+2)$ FSP generator matrix.\n\nThe entries of $A_{\\text{FSP}}$ are determined by the probability fluxes between states. Let the states be indexed from $0$ to $N+1$, where index $N+1$ corresponds to the sink. The entry $A_{ij}$ represents the rate of flux from state $j$ to state $i$.\n\nThe reactions are $\\emptyset \\xrightarrow{\\lambda} X$ and $X \\xrightarrow{\\mu} \\emptyset$. The propensities are $a_{\\text{birth}}(n) = \\lambda$ and $a_{\\text{death}}(n) = \\mu n$.\n\nFor a state $n$ such that $0  n  N$:\n- A birth reaction transitions the system from state $n$ to $n+1$ at rate $\\lambda$. This contributes to $A_{n+1, n} = \\lambda$.\n- A death reaction transitions the system from state $n$ to $n-1$ at rate $\\mu n$. This contributes to $A_{n-1, n} = \\mu n$.\n- The diagonal element $A_{n,n}$ is the negative sum of rates of all reactions leaving state $n$: $A_{n,n} = -(\\lambda + \\mu n)$.\n\nFor the boundary states of $\\mathcal{S}_N$:\n- For state $n=0$: Only a birth reaction can occur, leading to state $1$. The rate is $\\lambda$. So, $A_{1,0} = \\lambda$ and $A_{0,0} = -\\lambda$.\n- For state $n=N$: A death reaction leads to state $N-1$ at rate $\\mu N$, so $A_{N-1, N} = \\mu N$. A birth reaction would lead to state $N+1$, which is outside $\\mathcal{S}_N$. This flux is redirected to the sink state (index $N+1$) at rate $\\lambda$. Thus, $A_{N+1, N} = \\lambda$. The diagonal element is $A_{N,N} = -(\\lambda + \\mu N)$.\n\nFor the sink state (index $N+1$):\n- It is an absorbing state, meaning no flux leaves it. Therefore, the entire column $N+1$ of $A_{\\text{FSP}}$ is zero: $A_{i, N+1} = 0$ for all $i \\in \\{0, \\dots, N+1\\}$.\n\nCombining these elements, the generator matrix $A_{\\text{FSP}}$ has the following structure:\n$$\nA_{\\text{FSP}} = \n\\begin{pmatrix}\n-\\lambda  \\mu  0  \\dots  0  0  0 \\\\\n\\lambda  -(\\lambda+\\mu)  2\\mu  \\dots  0  0  0 \\\\\n0  \\lambda  -(\\lambda+2\\mu)  \\dots  0  0  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots  \\vdots  \\vdots \\\\\n0  0  0  \\dots  \\lambda  -(\\lambda+N\\mu)  0 \\\\\n0  0  0  \\dots  0  \\lambda  0\n\\end{pmatrix}\n$$\nThis is an $(N+2) \\times (N+2)$ matrix where the entry for row $i$ and column $j$ (0-indexed) is given by:\n- $A_{j-1, j} = \\mu j$ for $1 \\le j \\le N$\n- $A_{j+1, j} = \\lambda$ for $0 \\le j \\le N-1$\n- $A_{N+1, N} = \\lambda$\n- $A_{j, j} = -(\\lambda + \\mu j)$ for $0 \\le j \\le N$\n- All other entries are $0$.\n\n### 2. Computing the FSP Sink Probability $s(T)$\n\nGiven the initial condition $X(0) = n_0$, we define the initial probability vector $\\mathbf{p}(0)$.\n- If $n_0 \\le N$, the system starts in state $n_0$. So $\\mathbf{p}(0)$ is a vector with a $1$ at index $n_0$ and zeros elsewhere.\n- If $n_0 > N$, the system starts outside the FSP-tracked states. The initial probability is entirely in the sink state. $\\mathbf{p}(0)$ is a vector with a $1$ at index $N+1$ and zeros elsewhere.\n\nThe solution to the linear ODE system is $\\mathbf{p}(T) = \\exp(T \\cdot A_{\\text{FSP}}) \\mathbf{p}(0)$, where $\\exp(\\cdot)$ is the matrix exponential. The sink probability at time $T$, denoted $s(T)$, is the last element of this vector, $s(T) = p_{N+1}(T)$.\n\n### 3. Derivation of the Exact Outside Probability $\\mathbb{P}(X(T) > N)$\n\nThe birth-death process with linear rates is one of the few stochastic reaction systems with a known analytical solution. For an initial state of $X(0) = n_0$, the number of molecules at time $T$, $X(T)$, is the sum of two independent random variables:\n1.  $B$: The number of surviving molecules from the initial population. Each of the $n_0$ molecules survives with probability $p = e^{-\\mu T}$. Thus, $B \\sim \\text{Binomial}(n_0, e^{-\\mu T})$.\n2.  $P$: The number of molecules produced by the birth process that are still present at time $T$. This count follows a Poisson distribution, $P \\sim \\text{Poisson}(m(T))$, with mean $m(T) = \\frac{\\lambda}{\\mu}(1 - e^{-\\mu T})$.\n\nSo, $X(T) = B + P$. We need to compute the probability $\\mathbb{P}(X(T) > N)$. We can do this by conditioning on the value of $B$:\n$$\n\\mathbb{P}(X(T) > N) = \\sum_{b=0}^{n_0} \\mathbb{P}(X(T) > N | B=b) \\mathbb{P}(B=b)\n$$\nGiven $B=b$, the condition $X(T) > N$ becomes $b+P > N$, or $P > N-b$. The formula is thus:\n$$\n\\mathbb{P}(X(T) > N) = \\sum_{b=0}^{n_0} \\mathbb{P}(P > N-b) \\cdot \\mathbb{P}(B=b)\n$$\nThe terms in the sum are:\n- The Binomial probability: $\\mathbb{P}(B=b) = \\binom{n_0}{b} (e^{-\\mu T})^b (1-e^{-\\mu T})^{n_0-b}$.\n- The Poisson survival function (tail probability): $\\mathbb{P}(P > k)$. This is given by $\\sum_{j=k+1}^{\\infty} e^{-m} \\frac{m^j}{j!}$. This is equivalent to the regularized upper incomplete gamma function, $Q(k+1, m) = \\frac{\\Gamma(k+1, m)}{\\Gamma(k+1)}$.\nIf $N-b  0$ (i.e., $b > N$), the probability $\\mathbb{P}(P > N-b)$ is $1$, since the Poisson random variable $P$ is non-negative.\n\nCombining these parts, the exact probability is:\n$$\n\\mathbb{P}(X(T) > N) = \\sum_{b=0}^{n_0} \\left[ \\binom{n_0}{b} (e^{-\\mu T})^b (1-e^{-\\mu T})^{n_0-b} \\right] \\cdot \\mathbb{P}(P > N-b)\n$$\nwhere\n$$\n\\mathbb{P}(P > N-b) = \\begin{cases} 1  \\text{if } b > N \\\\ Q(N-b+1, m(T))  \\text{if } b \\le N \\end{cases}\n$$\nand $m(T) = \\frac{\\lambda}{\\mu}(1 - e^{-\\mu T})$.\n\n### 4. Implementation Strategy\n\nThe program will iterate through each test case. For each set of parameters $(\\lambda, \\mu, n_0, T, N)$, it will:\n1.  Construct the $(N+2) \\times (N+2)$ matrix $A_{\\text{FSP}}$ in `numpy`.\n2.  Set up the initial state vector $\\mathbf{p}(0)$ based on whether $n_0 > N$.\n3.  Compute $\\mathbf{p}(T) = \\exp(T \\cdot A_{\\text{FSP}}) \\mathbf{p}(0)$ using `scipy.linalg.expm` and extract the sink probability $s(T)$.\n4.  Calculate the exact probability $\\mathbb{P}(X(T) > N)$ by summing the convolution terms. The binomial coefficient will be calculated using `scipy.special.comb` and the Poisson tail probability with `scipy.special.gammaincc`.\n5.  Compute the difference $s(T) - \\mathbb{P}(X(T) > N)$ and store the result.\n\nFinally, the collected results will be printed in the specified format. Special care will be taken for the edge cases $n_0 > N$ and $N=0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.special import comb, gammaincc\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases by comparing the FSP sink probability\n    with the exact outside probability for a birth-death process.\n    \"\"\"\n    # Test cases from the problem statement: (lambda, mu, n0, T, N)\n    test_cases = [\n        (5.0, 0.5, 0, 10.0, 40),\n        (20.0, 1.0, 30, 2.0, 35),\n        (2.0, 0.1, 50, 5.0, 15),\n        (3.0, 0.2, 0, 6.0, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, mu, n0, T, N_float = case\n        n0 = int(n0)\n        N = int(N_float)\n\n        # 1. Compute FSP sink probability s(T)\n        dim = N + 2  # State space {0, 1, ..., N} plus a sink state\n        A_fsp = np.zeros((dim, dim))\n\n        # Populate the FSP generator matrix A_fsp\n        # Diagonal and sub-diagonal entries\n        for n in range(N + 1):\n            # Flux out of state n\n            outgoing_rate = 0.0\n            # Birth reaction (n - n+1)\n            if n  N:\n                A_fsp[n + 1, n] = lam\n                outgoing_rate += lam\n            else: # n == N, birth goes to sink\n                A_fsp[N + 1, n] = lam # N+1 is the sink index\n                outgoing_rate += lam\n            \n            # Death reaction (n - n-1)\n            if n  0:\n                A_fsp[n - 1, n] = mu * n\n                outgoing_rate += mu * n\n\n            A_fsp[n, n] = -outgoing_rate\n            \n        # The sink state (column N+1) is absorbing, so column is all zeros, which is the default.\n\n        # Initial condition vector p(0)\n        p0 = np.zeros(dim)\n        if n0  N:\n            # Initial state is outside the tracked region, so all probability is in the sink\n            p0[N + 1] = 1.0\n        else:\n            # Initial state is within the tracked region\n            p0[n0] = 1.0\n\n        # Solve the ODE system using matrix exponential\n        pT = expm(T * A_fsp) @ p0\n        sT = pT[N + 1]\n\n        # 2. Compute exact outside probability P(X(T)  N)\n        # Parameters for the exact distribution X(T) = B + P\n        # B ~ Binomial(n0, p_survive), P ~ Poisson(m)\n        if mu  1e-9: # mu is positive\n            p_survive = np.exp(-mu * T)\n            m = (lam / mu) * (1.0 - p_survive)\n        else: # mu is zero (not in test cases, but for completeness)\n            p_survive = 1.0\n            m = lam * T\n\n        # Convolve Binomial and Poisson distributions\n        prob_outside_exact = 0.0\n        for b in range(n0 + 1):\n            binom_prob = comb(n0, b, exact=False) * (p_survive**b) * ((1 - p_survive)**(n0-b))\n            \n            # If a term is negligible, skip calculation to avoid numerical issues\n            if binom_prob  1e-100:\n                continue\n\n            # We need to compute P(P  N - b)\n            k = N - b\n            if k  0:\n                # If b  N, P  N-b is always true since P = 0.\n                poisson_tail_prob = 1.0\n            else:\n                # P(P  k) = Q(k+1, m), where Q is regularized upper incomplete gamma\n                # gammaincc(a,x) is defined for a  0. Here a = k+1, so k = 0\n                poisson_tail_prob = gammaincc(k + 1, m)\n            \n            prob_outside_exact += binom_prob * poisson_tail_prob\n\n        # 3. Calculate the difference\n        # The FSP sink probability is an upper bound on the true outside probability.\n        # This difference should be non-negative.\n        difference = sT - prob_outside_exact\n        results.append(difference)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While solving for the full probability distribution is powerful, we are often primarily interested in statistical moments like the mean and variance. One can derive differential equations for the evolution of these moments directly from the CME, but for any system involving nonlinear reactions, this creates an unclosed hierarchy: the equation for the $k$-th moment depends on the $(k+1)$-th moment. This practice  explores the essential technique of moment closure, where you will first derive the moment equations for a nonlinear system and then implement and compare several common closure approximations to obtain a self-contained, solvable system for the system's moments.",
            "id": "3351626",
            "problem": "Consider a single-species stochastic reaction network for a molecular species $X$ with the following mass-action reactions:\n- $R_1$: $\\varnothing \\rightarrow X$ with propensity $a_1(x) = k_b$ and stoichiometric change $v_1 = +1$.\n- $R_2$: $X \\rightarrow \\varnothing$ with propensity $a_2(x) = k_d x$ and stoichiometric change $v_2 = -1$.\n- $R_3$: $2X \\rightarrow \\varnothing$ with propensity $a_3(x) = k_a \\, x(x-1)/2$ and stoichiometric change $v_3 = -2$.\n\nYour task is to start from the Chemical Master Equation (CME) and the standard forward-equation identity for expectations, and then derive, implement, and evaluate steady-state moment closures.\n\nFundamental base:\n- The Chemical Master Equation (CME) governs the time evolution of the probability mass function $P(x,t)$ for the copy number $x \\in \\mathbb{N}_0$ of $X$.\n- For any test function $f(x)$, the identity\n$$\n\\frac{d}{dt}\\mathbb{E}[f(X)] = \\mathbb{E}\\left[ \\sum_{r} a_r(X) \\left(f(X + v_r) - f(X)\\right) \\right]\n$$\nholds, where the sum is over reactions $r$, $a_r$ are propensities, and $v_r$ are stoichiometric changes.\n\nProblem requirements:\n1. Derive the coupled ordinary differential equations (ODEs) for the first and second raw moments $m_1(t) = \\mathbb{E}[X(t)]$ and $m_2(t) = \\mathbb{E}[X(t)^2]$ implied by the CME for the network above. Express your final ODEs explicitly in terms of $m_1(t)$, $m_2(t)$, and the third raw moment $m_3(t) = \\mathbb{E}[X(t)^3]$.\n2. Implement three distinct moment closures to obtain a closed system for steady-state moments $(m_1^\\star, m_2^\\star)$:\n   - Normal closure: assume the third central cumulant is zero, which implies a relation between $m_3$, $m_1$, and $m_2$.\n   - Log-normal closure: assume $X$ is approximately log-normally distributed, which implies a relation between $m_3$, $m_1$, and $m_2$.\n   - Poisson-variance closure: assume $X$ is approximately Poisson at stationarity, imposing a relationship between $m_2$ and $m_1$ and yielding an algebraic steady-state condition for $m_1$ only.\n3. Compute the steady-state solutions $(m_1^\\star, \\sigma^{2\\star})$ for each closure, where $\\sigma^{2\\star} = m_2^\\star - (m_1^\\star)^2$. Use numerical root-finding for the closed steady-state equations where necessary. Ensure numerical robustness by providing reasonable initial guesses and fallbacks for challenging parameter regimes. All outputs must be finite real numbers.\n4. Test suite. For each parameter set $(k_b,k_d,k_a)$ below, compute the stationary mean and variance under each closure. Use the parameter sets:\n   - Case A (boundary, monomolecular): $(k_b,k_d,k_a) = (10.0, 1.0, 0.0)$.\n   - Case B (moderate nonlinearity): $(k_b,k_d,k_a) = (50.0, 1.0, 0.01)$.\n   - Case C (stronger nonlinear loss): $(k_b,k_d,k_a) = (50.0, 0.1, 0.05)$.\n   - Case D (low counts): $(k_b,k_d,k_a) = (1.0, 1.0, 0.5)$.\n5. Output specification. Your program must produce a single line containing a comma-separated list of floating-point numbers rounded to six decimal places. For each case, report the results in the order\n   - $[m_{1,\\mathrm{normal}}^\\star, \\sigma^{2\\star}_{\\mathrm{normal}}, m_{1,\\mathrm{logn}}^\\star, \\sigma^{2\\star}_{\\mathrm{logn}}, m_{1,\\mathrm{pois}}^\\star, \\sigma^{2\\star}_{\\mathrm{pois}}]$,\nand then concatenate these lists for cases A, B, C, and D in that order. The final output must therefore be a single line of the form\n- $[$caseA\\_entries, caseB\\_entries, caseC\\_entries, caseD\\_entries$]$,\nwith all numeric entries as decimal floats.\n6. Angle units and physical units do not apply to this problem. All numeric outputs must be real numbers without any unit.\n\nDesign notes and constraints:\n- You must not rely on any external files or user inputs. All computations must be self-contained.\n- The steady-state solutions must be obtained by solving the closed steady-state equations implied by each closure. When using the Poisson-variance closure, use the algebraic steady-state implied for $m_1^\\star$; when using the other closures, solve the two-dimensional steady-state problem for $(m_1^\\star, m_2^\\star)$.\n- For numerical stability in the log-normal closure when $m_1$ is near zero, you must implement a limiting safeguard that avoids division by zero.\n- The final program must print exactly one line containing the results as a comma-separated list enclosed in square brackets, with no additional text. All numbers must be rounded to six decimal places.",
            "solution": "The objective is to derive and solve steady-state moment equations for a single-species stochastic reaction network using three different moment closure approximations.\n\nThe stochastic system is defined by a species $X$ with molecule number $x$, and three reactions:\n- $R_1$: $\\varnothing \\rightarrow X$, with propensity $a_1(x) = k_b$ and stoichiometry $v_1 = +1$.\n- $R_2$: $X \\rightarrow \\varnothing$, with propensity $a_2(x) = k_d x$ and stoichiometry $v_2 = -1$.\n- $R_3$: $2X \\rightarrow \\varnothing$, with propensity $a_3(x) = k_a x(x-1)/2$ and stoichiometry $v_3 = -2$.\n\nThe time evolution of the expectation of a function $f(X)$ is given by the identity:\n$$\n\\frac{d}{dt}\\mathbb{E}[f(X)] = \\mathbb{E}\\left[ \\sum_{r=1}^{3} a_r(X) \\left(f(X + v_r) - f(X)\\right) \\right]\n$$\n\n**1. Derivation of the Moment Equations**\n\nWe derive the ordinary differential equations (ODEs) for the first two raw moments, $m_1(t) = \\mathbb{E}[X(t)]$ and $m_2(t) = \\mathbb{E}[X(t)^2]$.\n\n**For the first raw moment, $m_1(t)$:**\nLet $f(x) = x$. We evaluate the change for each reaction:\n- $R_1$: $a_1(x)(f(x+v_1) - f(x)) = k_b((x+1)-x) = k_b$.\n- $R_2$: $a_2(x)(f(x+v_2) - f(x)) = k_d x((x-1)-x) = -k_d x$.\n- $R_3$: $a_3(x)(f(x+v_3) - f(x)) = \\frac{k_a x(x-1)}{2}((x-2)-x) = -k_a x(x-1)$.\n\nTaking the expectation of the sum of these terms gives the ODE for $m_1(t)$:\n$$\n\\frac{d m_1}{dt} = \\mathbb{E}[k_b - k_d X - k_a X(X-1)] = k_b - k_d \\mathbb{E}[X] - k_a \\mathbb{E}[X^2 - X]\n$$\nIn terms of moments, this is:\n$$\n\\frac{d m_1}{dt} = k_b - k_d m_1 - k_a (m_2 - m_1)\n$$\n\n**For the second raw moment, $m_2(t)$:**\nLet $f(x) = x^2$. We evaluate the change for each reaction:\n- $R_1$: $a_1(x)(f(x+v_1) - f(x)) = k_b((x+1)^2 - x^2) = k_b(2x+1)$.\n- $R_2$: $a_2(x)(f(x+v_2) - f(x)) = k_d x((x-1)^2 - x^2) = k_d x(-2x+1) = -2k_d x^2 + k_d x$.\n- $R_3$: $a_3(x)(f(x+v_3) - f(x)) = \\frac{k_a x(x-1)}{2}((x-2)^2 - x^2) = \\frac{k_a x(x-1)}{2}(-4x+4) = -2k_a x(x-1)^2 = -2k_a(x^3 - 2x^2 + x)$.\n\nTaking the expectation of the sum gives the ODE for $m_2(t)$:\n$$\n\\frac{d m_2}{dt} = \\mathbb{E}[k_b(2X+1) + (-2k_d X^2 + k_d X) - 2k_a(X^3 - 2X^2 + X)]\n$$\nIn terms of moments, this is:\n$$\n\\frac{d m_2}{dt} = k_b(2m_1+1) + k_d m_1 - 2k_d m_2 - 2k_a(m_3 - 2m_2 + m_1)\n$$\nwhere $m_3(t) = \\mathbb{E}[X(t)^3]$ is the third raw moment.\n\n**2. Steady-State Equations and Moment Closure Schemes**\n\nAt steady state, the moments are constant, so $\\frac{d m_1}{dt} = 0$ and $\\frac{d m_2}{dt} = 0$. Let $m_k^\\star$ denote the steady-state moments. The system of equations is:\n$$\n(1) \\quad 0 = k_b - k_d m_1^\\star - k_a (m_2^\\star - m_1^\\star)\n$$\n$$\n(2) \\quad 0 = k_b(2m_1^\\star+1) + k_d m_1^\\star - 2k_d m_2^\\star - 2k_a(m_3^\\star - 2m_2^\\star + m_1^\\star)\n$$\nThis system is unclosed due to the presence of $m_3^\\star$. We apply three different closure schemes to express $m_3^\\star$ in terms of $m_1^\\star$ and $m_2^\\star$.\n\n**A. Poisson-Variance Closure**\nThis closure assumes the stationary distribution is approximately Poisson. A key property of the Poisson distribution is that its variance equals its mean.\nAssumption: $\\sigma^{2\\star} = m_1^\\star$.\nSince $\\sigma^{2\\star} = m_2^\\star - (m_1^\\star)^2$, this implies the closure relation:\n$$\nm_2^\\star = (m_1^\\star)^2 + m_1^\\star\n$$\nSubstituting this into the steady-state equation for $m_1^\\star$ (Equation 1):\n$$\n0 = k_b - k_d m_1^\\star - k_a ( ((m_1^\\star)^2 + m_1^\\star) - m_1^\\star )\n$$\n$$\nk_a (m_1^\\star)^2 + k_d m_1^\\star - k_b = 0\n$$\nThis is a quadratic equation for $m_1^\\star$. Taking the physically meaningful positive root, we get:\n- If $k_a > 0$: $m_1^\\star = \\frac{-k_d + \\sqrt{k_d^2 + 4k_a k_b}}{2k_a}$.\n- If $k_a = 0$: The equation becomes linear, $k_d m_1^\\star - k_b = 0$, so $m_1^\\star = k_b/k_d$.\nThe stationary variance is then simply $\\sigma^{2\\star} = m_1^\\star$.\n\n**B. Normal Closure**\nThis closure assumes the third central moment is zero, as is true for a Normal (Gaussian) distribution. The third central moment $\\mu_3$ is related to raw moments by $\\mu_3 = m_3 - 3m_1m_2 + 2m_1^3$.\nAssumption: $\\mu_3^\\star = 0$.\nThis provides the closure relation for the third raw moment:\n$$\nm_3^\\star = 3m_1^\\star m_2^\\star - 2(m_1^\\star)^3\n$$\nSubstituting this into Equations (1) and (2) yields a closed system of two nonlinear algebraic equations for $(m_1^\\star, m_2^\\star)$:\n$$\n0 = k_b - (k_d-k_a)m_1^\\star - k_a m_2^\\star\n$$\n$$\n0 = k_b(2m_1^\\star+1) + k_d m_1^\\star - 2k_d m_2^\\star - 2k_a( (3m_1^\\star m_2^\\star - 2(m_1^\\star)^3) - 2m_2^\\star + m_1^\\star)\n$$\nThis system must be solved numerically.\n\n**C. Log-Normal Closure**\nThis closure assumes the distribution of $X$ at steady-state can be approximated by a log-normal distribution. If $X \\sim \\text{LogNormal}(\\mu, \\sigma^2)$, its raw moments are $m_k = \\exp(k\\mu + k^2\\sigma^2/2)$. From this, a relationship between the first three raw moments can be derived:\n$$\nm_3^\\star = \\frac{(m_2^\\star)^3}{(m_1^\\star)^3}\n$$\nSubstituting this into Equations (1) and (2) gives another closed system for $(m_1^\\star, m_2^\\star)$:\n$$\n0 = k_b - (k_d-k_a)m_1^\\star - k_a m_2^\\star\n$$\n$$\n0 = k_b(2m_1^\\star+1) + k_d m_1^\\star - 2k_d m_2^\\star - 2k_a\\left( \\frac{(m_2^\\star)^3}{(m_1^\\star)^3} - 2m_2^\\star + m_1^\\star \\right)\n$$\nThis system also requires a numerical solution. To prevent division by zero during numerical root finding if $m_1^\\star$ is explored near $0$, a small epsilon, e.g., $10^{-12}$, is added inside the cubic term: $(m_1^\\star)^3 + \\epsilon$.\n\n**3. Solution Methodology**\n\nFor each parameter set $(k_b, k_d, k_a)$:\n1.  **Special Case $k_a=0$**: When $k_a=0$, the system reduces to a simple birth-death process, $\\varnothing \\leftrightarrows X$. The steady-state distribution is exactly Poisson. The moment equations become linear and can be solved analytically:\n    $m_1^\\star = k_b/k_d$.\n    $m_2^\\star = (m_1^\\star)^2 + m_1^\\star$.\n    Therefore, $\\sigma^{2\\star} = m_1^\\star$. All three closure methods yield this exact result for $k_a=0$.\n2.  **General Case $k_a > 0$**:\n    - The Poisson closure solution $(m_{1, \\text{pois}}^\\star, \\sigma^{2\\star}_{\\text{pois}})$ is calculated analytically using the quadratic formula.\n    - The nonlinear systems for the Normal and Log-normal closures are solved numerically using a root-finding algorithm (`scipy.optimize.root`).\n    - A robust initial guess for the numerical solver is provided by the moments calculated from the Poisson closure, i.e., $m_1^{(0)} = m_{1, \\text{pois}}^\\star$ and $m_2^{(0)} = (m_1^{(0)})^2 + m_1^{(0)}$.\n3.  **Final Output**: For each closure, the stationary mean $m_1^\\star$ and variance $\\sigma^{2\\star} = m_2^\\star - (m_1^\\star)^2$ are computed and reported.\n\nThe implementation will follow these derivations to compute the required values for the four test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (kb, kd, ka)\n    test_cases = [\n        (10.0, 1.0, 0.0),    # Case A\n        (50.0, 1.0, 0.01),   # Case B\n        (50.0, 0.1, 0.05),   # Case C\n        (1.0, 1.0, 0.5),     # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        case_results = compute_for_case(*params)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_for_case(kb, kd, ka):\n    \"\"\"\n    Computes the steady-state mean and variance for a single parameter set\n    under the three specified closure schemes.\n\n    Args:\n        kb (float): Birth rate constant.\n        kd (float): Linear death rate constant.\n        ka (float): Quadratic death rate constant.\n\n    Returns:\n        list: A list of 6 floats: [m1_norm, var_norm, m1_logn, var_logn, m1_pois, var_pois]\n    \"\"\"\n\n    # Case A (ka=0) has an exact analytical solution (Poisson distribution)\n    if ka == 0.0:\n        if kd > 0:\n            m1_exact = kb / kd\n            var_exact = m1_exact\n        else: # Should not happen with given test cases\n            m1_exact = np.inf\n            var_exact = np.inf\n        return [m1_exact, var_exact, m1_exact, var_exact, m1_exact, var_exact]\n\n    # 1. Poisson-variance closure (analytical solution)\n    # ka*m1^2 + kd*m1 - kb = 0\n    m1_pois = (-kd + np.sqrt(kd**2 + 4 * ka * kb)) / (2 * ka)\n    var_pois = m1_pois\n\n    # Initial guess for numerical solvers based on the Poisson closure result\n    m1_guess = m1_pois\n    m2_guess = m1_guess**2 + m1_guess\n    initial_guess = [m1_guess, m2_guess]\n\n    # --- Closure-specific systems for the root finder ---\n\n    # 2. Normal closure\n    def system_normal(m, kb, kd, ka):\n        m1, m2 = m\n        # Physicality constraints to guide solver\n        if m1 = 0 or m2 = 0:\n            return [1e6, 1e6]\n        \n        m3_norm = 3 * m1 * m2 - 2 * m1**3\n        \n        # Steady-state equations\n        eq1 = kb - kd * m1 - ka * (m2 - m1)\n        eq2 = kb * (2 * m1 + 1) + kd * m1 - 2 * kd * m2 - 2 * ka * (m3_norm - 2 * m2 + m1)\n        return [eq1, eq2]\n\n    # 3. Log-normal closure\n    def system_lognormal(m, kb, kd, ka):\n        m1, m2 = m\n        # Physicality and numerical stability constraints\n        if m1 = 0 or m2 = 0:\n            return [1e6, 1e6]\n        \n        # Safeguard to prevent division by zero, as required by the problem\n        m3_logn = m2**3 / (m1**3 + 1e-12)\n\n        # Steady-state equations\n        eq1 = kb - kd * m1 - ka * (m2 - m1)\n        eq2 = kb * (2 * m1 + 1) + kd * m1 - 2 * kd * m2 - 2 * ka * (m3_logn - 2 * m2 + m1)\n        return [eq1, eq2]\n\n    # --- Solve systems and compute results ---\n\n    # Solve for Normal closure\n    sol_normal = root(system_normal, initial_guess, args=(kb, kd, ka), method='hybr')\n    m1_norm, m2_norm = sol_normal.x\n    # Variance can be negative if the closure yields a non-physical result\n    var_norm = m2_norm - m1_norm**2\n\n    # Solve for Log-normal closure\n    sol_lognormal = root(system_lognormal, initial_guess, args=(kb, kd, ka), method='hybr')\n    m1_logn, m2_logn = sol_lognormal.x\n    var_logn = m2_logn - m1_logn**2\n\n    return [m1_norm, var_norm, m1_logn, var_logn, m1_pois, var_pois]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "In regimes with large numbers of molecules, the discrete stochastic process described by the CME can be effectively approximated by a continuous stochastic differential equation, the Chemical Langevin Equation (CLE). This approximation offers significant computational advantages but is only valid when reaction event counts are high enough to be considered continuous, a condition that frequently breaks down in biological systems with low-copy-number species. This hands-on exercise  makes the limits of this approximation concrete by asking you to formalize and implement a quantitative criterion to identify the \"breakdown threshold\"—the minimal molecule count at which the CLE ceases to be a reliable model.",
            "id": "3351587",
            "problem": "You are asked to formalize and implement a computable validity criterion that compares the error of the Chemical Langevin Equation (CLE) approximation to the exact Chemical Master Equation (CME) dynamics for well-mixed reaction networks. Your derivation and implementation must start from the fundamental CME representation, state-change form of propensities, and the Gaussian diffusion approximation underlying the CLE, and must incorporate propensity Lipschitz constants and expected copy numbers. You will then use this criterion to quantify the breakdown threshold of the CLE at low copy numbers by computing the minimal expected molecule count at which the CLE becomes acceptable under your criterion.\n\nThe fundamental base you must use includes:\n- The CME for a well-mixed Markov jump process, with state vector $X(t) \\in \\mathbb{N}^S$, stoichiometry vectors $\\nu_j \\in \\mathbb{Z}^S$, and propensities $a_j(x)$, where the exact update is driven by independent Poisson counts with rates $a_j(x)$.\n- The CLE, which approximates Poisson increments by Gaussian increments so that over a time step $\\Delta t$, the increment in species is $X(t+\\Delta t) - X(t) \\approx \\sum_{j=1}^R \\nu_j \\left( a_j(X(t)) \\Delta t + \\sqrt{a_j(X(t)) \\Delta t}\\,\\xi_j \\right)$, where $\\xi_j$ are independent standard normal random variables.\n- The leap condition and normal approximation rationale: the CLE is expected to be accurate when (i) each channel’s Poisson count over $\\Delta t$ is large so that a Gaussian approximation is appropriate, and (ii) propensities do not vary appreciably during the step, which may be formalized using Lipschitz continuity of propensities with respect to species counts.\n\nStarting from these bases, define for a state $x \\in \\mathbb{R}^S_{\\ge 0}$ (interpreted as expected molecule counts) and a step size $\\Delta t  0$ the following dimensionless channel-wise diagnostics:\n1. A Gaussianity parameter for reaction $j$,\n$$\\gamma_j(x,\\Delta t) \\equiv \\frac{1}{\\sqrt{a_j(x)\\,\\Delta t}},$$\nwhich captures the Berry–Esseen-scale magnitude of the Poisson-to-Gaussian approximation error in terms of the expected Poisson count $a_j(x)\\Delta t$.\n2. A Lipschitz leap parameter for reaction $j$,\n$$\\tau_j(x,\\Delta t) \\equiv \\Delta t \\cdot \\frac{\\sum_{i=1}^S \\left| \\frac{\\partial a_j}{\\partial x_i}(x) \\right| \\cdot \\left(\\sum_{k=1}^R \\left|\\nu_{ik}\\right|\\,a_k(x)\\right)}{a_j(x)},$$\nwhich compares the magnitude of first-order propensity changes over one step (linearized using the gradient of $a_j$ and total expected activity $\\sum_k |\\nu_{ik}| a_k$ per species) against the scale of $a_j$ itself.\n\nGiven a user-specified tolerance $\\varepsilon \\in (0,1)$, define the combined CLE validity index at state $x$ and step size $\\Delta t$ as\n$$S(x,\\Delta t;\\varepsilon) \\equiv \\max_{1 \\le j \\le R} \\max\\left\\{\\frac{\\gamma_j(x,\\Delta t)}{\\varepsilon}, \\frac{\\tau_j(x,\\Delta t)}{\\varepsilon}\\right\\}.$$\nBy construction, the criterion $S(x,\\Delta t;\\varepsilon) \\le 1$ requires simultaneously that all channels have adequate Gaussianity and satisfy the leap smoothness condition. This criterion depends explicitly on the propensities $a_j(x)$, their Lipschitz constants (through partial derivatives), the stoichiometry $\\nu$, the step size $\\Delta t$, and the expected copy numbers $x$.\n\nYour programming task: For each test case below, compute the minimal expected molecule count threshold at which the CLE becomes acceptable, as follows.\n\n- For one-species networks, let $x \\in \\mathbb{R}_{\\ge 0}$ denote the expected count of species $X$. Find the smallest integer $x_{\\mathrm{crit}} \\ge 1$ such that $S(x_{\\mathrm{crit}},\\Delta t;\\varepsilon) \\le 1$. If no such $x_{\\mathrm{crit}} \\le 10^6$ exists, return $-1$ for that case.\n- For two-species reversible isomerization, let the total expected count be $N \\in \\mathbb{R}_{\\ge 0}$ with stationary split $x = \\frac{k_2}{k_1+k_2} N$ and $y = \\frac{k_1}{k_1+k_2} N$. Find the smallest integer $N_{\\mathrm{crit}} \\ge 1$ such that $S\\big((x,y),\\Delta t;\\varepsilon\\big) \\le 1$. If no such $N_{\\mathrm{crit}} \\le 10^6$ exists, return $-1$.\n\nAssume mass-action propensities restricted to zeroth-order (source) and unimolecular reactions:\n- Zeroth-order: $a_j(x) = c_j$ with $\\frac{\\partial a_j}{\\partial x_i} = 0$ for all $i$.\n- Unimolecular on species $i^\\star$: $a_j(x) = c_j x_{i^\\star}$ with $\\frac{\\partial a_j}{\\partial x_i} = c_j$ if $i = i^\\star$, else $0$.\n\nTreat all rates $c_j$ in inverse seconds, time in seconds, and species counts as molecule numbers. Your program must implement the above $S(x,\\Delta t;\\varepsilon)$ using these forms and search the minimal integer threshold as specified.\n\nTest Suite. For each case below, compute the requested threshold:\n- Case 1 (birth–death, one species): Reactions $\\varnothing \\xrightarrow{k_b} X$ and $X \\xrightarrow{k_d} \\varnothing$, with $k_b = 5$ s$^{-1}$, $k_d = 0.1$ s$^{-1}$, step size $\\Delta t = 5$ s, and tolerance $\\varepsilon = 0.6$. Output the minimal integer expected $X$ count in molecules.\n- Case 2 (reversible isomerization, two species): Reactions $X \\xrightarrow{k_1} Y$ and $Y \\xrightarrow{k_2} X$, with $k_1 = 0.05$ s$^{-1}$, $k_2 = 0.10$ s$^{-1}$, step size $\\Delta t = 2$ s, tolerance $\\varepsilon = 0.5$, and total expected molecules $N$ split at stationarity as $x = \\frac{k_2}{k_1+k_2} N$ and $y = \\frac{k_1}{k_1+k_2} N$. Output the minimal integer $N$ in molecules.\n- Case 3 (pure death, one species): Reaction $X \\xrightarrow{\\mu} \\varnothing$, with $\\mu = 1.0$ s$^{-1}$, step size $\\Delta t = 0.1$ s, tolerance $\\varepsilon = 0.25$. Output the minimal integer expected $X$ count in molecules.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three cases above, for example, \"[result1,result2,result3]\". Each result must be an integer in molecules, or $-1$ if no threshold was found up to $10^6$.\n\nImportant notes:\n- All mathematical quantities in this problem use the notation given above. Time must be treated in seconds. Molecule counts are dimensionless copy numbers. The final outputs must be integers in molecules.\n- You must not rely on any formulas not derived from the CME and CLE definitions and the stated mass-action and Lipschitz structures. The code must be fully self-contained and produce the exact output line as specified, with no additional text.",
            "solution": "The problem has been validated and is determined to be sound. It is scientifically grounded in established principles of stochastic chemical kinetics, specifically the relationship between the discrete Chemical Master Equation (CME) and its continuous Chemical Langevin Equation (CLE) approximation. The problem is well-posed, providing a clear objective, all necessary mathematical definitions ($S, \\gamma_j, \\tau_j$), explicit parameter values for three test cases, and a defined search procedure for the desired thresholds. The language is objective and the setup is complete and internally consistent. Therefore, a solution can be derived.\n\nThe task is to compute a minimal integer molecule count threshold ($x_{\\mathrm{crit}}$ or $N_{\\mathrm{crit}}$) at which the Chemical Langevin Equation (CLE) becomes an acceptable approximation to the Chemical Master Equation (CME), based on a provided validity criterion $S(x, \\Delta t; \\varepsilon) \\le 1$. The state of the system is given by the expected molecule counts $x$, the simulation step size is $\\Delta t$, and $\\varepsilon$ is a user-defined tolerance. The criterion must be satisfied for all reaction channels $j=1, \\dots, R$. The condition $S(x, \\Delta t; \\varepsilon) \\le 1$ is equivalent to requiring $\\gamma_j(x, \\Delta t) \\le \\varepsilon$ and $\\tau_j(x, \\Delta t) \\le \\varepsilon$ for all $j$.\n\nThe process involves:\n1.  For each test case, specialize the general formulas for propensities $a_j(x)$, their derivatives $\\frac{\\partial a_j}{\\partial x_i}$, and the stoichiometry vectors $\\nu_j$.\n2.  Derive the specific forms of the Gaussianity parameter $\\gamma_j$ and the Lipschitz leap parameter $\\tau_j$ for each reaction channel.\n3.  Combine these into a set of inequalities based on the condition $S \\le 1$.\n4.  Solve these inequalities to find the minimum integer count ($x$ or $N$) that satisfies all of them simultaneously. The search for this integer is conducted from $1$ up to a maximum of $10^6$.\n\nLet's analyze each case.\n\n### Case 1: Birth–Death Process\nThe system has one species, $X$, and two reactions:\n1.  Birth: $\\varnothing \\xrightarrow{k_b} X$. Propensity $a_1(x) = k_b$. Stoichiometry $\\nu_1 = +1$.\n2.  Death: $X \\xrightarrow{k_d} \\varnothing$. Propensity $a_2(x) = k_d x$. Stoichiometry $\\nu_2 = -1$.\n\nParameters are $k_b = 5 \\text{ s}^{-1}$, $k_d = 0.1 \\text{ s}^{-1}$, $\\Delta t = 5 \\text{ s}$, and $\\varepsilon = 0.6$. The state is the expected count $x$ of species $X$.\n\nFor reaction $j=1$ (birth, a zeroth-order reaction):\nThe propensity is constant: $a_1(x) = k_b = 5$.\nThe derivative is $\\frac{\\partial a_1}{\\partial x} = 0$.\nThe Gaussianity parameter is $\\gamma_1(x, \\Delta t) = \\frac{1}{\\sqrt{a_1(x)\\Delta t}} = \\frac{1}{\\sqrt{5 \\cdot 5}} = \\frac{1}{5} = 0.2$.\nThe Lipschitz leap parameter is $\\tau_1(x, \\Delta t) = 0$ because $\\frac{\\partial a_1}{\\partial x} = 0$.\n\nFor reaction $j=2$ (death, a unimolecular reaction):\nThe propensity is $a_2(x) = k_d x = 0.1 x$.\nThe derivative is $\\frac{\\partial a_2}{\\partial x} = k_d = 0.1$.\nThe Gaussianity parameter is $\\gamma_2(x, \\Delta t) = \\frac{1}{\\sqrt{a_2(x)\\Delta t}} = \\frac{1}{\\sqrt{0.1x \\cdot 5}} = \\frac{1}{\\sqrt{0.5x}}$.\nThe total expected activity affecting species $X$ is $\\sum_{k=1}^2 |\\nu_{1k}| a_k(x) = |\\nu_1|a_1 + |\\nu_2|a_2 = |+1|k_b + |-1|k_d x = 5 + 0.1x$.\nThe Lipschitz leap parameter is $\\tau_2(x, \\Delta t) = \\Delta t \\frac{|\\frac{\\partial a_2}{\\partial x}|(5 + 0.1x)}{a_2(x)} = 5 \\frac{0.1(5 + 0.1x)}{0.1x} = \\frac{5(5 + 0.1x)}{x} = \\frac{25}{x} + 0.5$.\n\nNow we apply the conditions $\\gamma_j \\le \\varepsilon$ and $\\tau_j \\le \\varepsilon$ for $\\varepsilon=0.6$:\n1.  $\\gamma_1 \\le 0.6 \\implies 0.2 \\le 0.6$. This is always true.\n2.  $\\tau_1 \\le 0.6 \\implies 0 \\le 0.6$. This is always true.\n3.  $\\gamma_2 \\le 0.6 \\implies \\frac{1}{\\sqrt{0.5x}} \\le 0.6 \\implies \\sqrt{0.5x} \\ge \\frac{1}{0.6} \\implies 0.5x \\ge (\\frac{1}{0.6})^2 \\implies x \\ge \\frac{1}{0.5 \\cdot 0.36} = \\frac{1}{0.18} \\approx 5.55...$.\n4.  $\\tau_2 \\le 0.6 \\implies \\frac{25}{x} + 0.5 \\le 0.6 \\implies \\frac{25}{x} \\le 0.1 \\implies x \\ge \\frac{25}{0.1} = 250$.\n\nTo satisfy all conditions, $x$ must be greater than or equal to both $5.55...$ and $250$. The most restrictive condition is $x \\ge 250$. The smallest integer value for $x$ is $x_{\\mathrm{crit}} = 250$.\n\n### Case 2: Reversible Isomerization\nThe system has two species, $X$ and $Y$, and two reactions:\n1.  $X \\xrightarrow{k_1} Y$. Propensity $a_1(x,y) = k_1 x$. Stoichiometry $\\nu_1 = (-1, +1)^T$.\n2.  $Y \\xrightarrow{k_2} X$. Propensity $a_2(x,y) = k_2 y$. Stoichiometry $\\nu_2 = (+1, -1)^T$.\n\nParameters are $k_1 = 0.05 \\text{ s}^{-1}$, $k_2 = 0.10 \\text{ s}^{-1}$, $\\Delta t = 2 \\text{ s}$, and $\\varepsilon = 0.5$. The state $(x,y)$ is determined by the total molecule count $N$ at stationarity: $x = \\frac{k_2}{k_1+k_2} N = \\frac{0.10}{0.15} N = \\frac{2}{3}N$ and $y = \\frac{k_1}{k_1+k_2} N = \\frac{0.05}{0.15} N = \\frac{1}{3}N$. The propensities become $a_1(N) = k_1 x = 0.05 \\cdot \\frac{2}{3}N = \\frac{0.1}{3}N$ and $a_2(N) = k_2 y = 0.10 \\cdot \\frac{1}{3}N = \\frac{0.1}{3}N$. Note that $a_1=a_2$ at steady state.\n\nFor reaction $j=1$ ($X \\to Y$):\n$\\gamma_1(N, \\Delta t) = \\frac{1}{\\sqrt{a_1(N)\\Delta t}} = \\frac{1}{\\sqrt{\\frac{0.1}{3}N \\cdot 2}} = \\frac{1}{\\sqrt{\\frac{0.2}{3}N}}$.\nThe partial derivatives of $a_1$ are $\\frac{\\partial a_1}{\\partial x} = k_1 = 0.05$ and $\\frac{\\partial a_1}{\\partial y} = 0$.\nThe total activity sums are:\n$\\sum_{k} |\\nu_{X,k}|a_k = |-1|a_1 + |+1|a_2 = a_1+a_2 = 2 \\frac{0.1}{3}N = \\frac{0.2}{3}N$.\n$\\sum_{k} |\\nu_{Y,k}|a_k = |+1|a_1 + |-1|a_2 = a_1+a_2 = \\frac{0.2}{3}N$.\n$\\tau_1(N, \\Delta t) = \\frac{\\Delta t}{a_1(N)} \\left( \\left|\\frac{\\partial a_1}{\\partial x}\\right|\\sum_{k}|\\nu_{X,k}|a_k + \\left|\\frac{\\partial a_1}{\\partial y}\\right|\\sum_{k}|\\nu_{Y,k}|a_k \\right) = \\frac{2}{\\frac{0.1}{3}N} \\left( 0.05 \\cdot \\frac{0.2}{3}N + 0 \\right) = \\frac{2 \\cdot 0.05 \\cdot 0.2/3}{0.1/3} = 2 \\cdot 0.05 \\cdot 2 = 0.2$.\n\nFor reaction $j=2$ ($Y \\to X$):\nSince $a_1=a_2$, $\\gamma_2(N, \\Delta t) = \\gamma_1(N, \\Delta t) = \\frac{1}{\\sqrt{\\frac{0.2}{3}N}}$.\nThe partial derivatives of $a_2$ are $\\frac{\\partial a_2}{\\partial x} = 0$ and $\\frac{\\partial a_2}{\\partial y} = k_2 = 0.10$.\n$\\tau_2(N, \\Delta t) = \\frac{\\Delta t}{a_2(N)} \\left( \\left|\\frac{\\partial a_2}{\\partial x}\\right|\\sum_{k}|\\nu_{X,k}|a_k + \\left|\\frac{\\partial a_2}{\\partial y}\\right|\\sum_{k}|\\nu_{Y,k}|a_k \\right) = \\frac{2}{\\frac{0.1}{3}N} \\left( 0 + 0.10 \\cdot \\frac{0.2}{3}N \\right) = \\frac{2 \\cdot 0.10 \\cdot 0.2/3}{0.1/3} = 2 \\cdot 0.10 \\cdot 2 = 0.4$.\n\nNow we apply the conditions with $\\varepsilon=0.5$:\n1.  $\\gamma_1 = \\gamma_2 \\le 0.5 \\implies \\frac{1}{\\sqrt{\\frac{0.2}{3}N}} \\le 0.5 \\implies \\sqrt{\\frac{0.2}{3}N} \\ge 2 \\implies \\frac{0.2}{3}N \\ge 4 \\implies N \\ge \\frac{12}{0.2} = 60$.\n2.  $\\tau_1 \\le 0.5 \\implies 0.2 \\le 0.5$. This is always true.\n3.  $\\tau_2 \\le 0.5 \\implies 0.4 \\le 0.5$. This is always true.\n\nThe most restrictive condition is $N \\ge 60$. The smallest integer value is $N_{\\mathrm{crit}} = 60$.\n\n### Case 3: Pure Death Process\nThe system has one species, $X$, and one reaction: $X \\xrightarrow{\\mu} \\varnothing$.\nPropensity $a_1(x) = \\mu x$. Stoichiometry $\\nu_1 = -1$.\nParameters are $\\mu = 1.0 \\text{ s}^{-1}$, $\\Delta t = 0.1 \\text{ s}$, and $\\varepsilon = 0.25$.\n\nFor reaction $j=1$:\n$a_1(x) = \\mu x = 1.0x = x$.\n$\\gamma_1(x, \\Delta t) = \\frac{1}{\\sqrt{a_1(x)\\Delta t}} = \\frac{1}{\\sqrt{x \\cdot 0.1}}$.\n$\\frac{\\partial a_1}{\\partial x} = \\mu = 1.0$.\nTotal activity sum: $\\sum_k |\\nu_{1k}|a_k = |\\nu_1|a_1 = |-1|x = x$.\n$\\tau_1(x, \\Delta t) = \\Delta t \\frac{|\\frac{\\partial a_1}{\\partial x}| \\cdot x}{a_1(x)} = 0.1 \\frac{|1.0| \\cdot x}{x} = 0.1$.\n\nNow apply the conditions with $\\varepsilon=0.25$:\n1.  $\\gamma_1 \\le 0.25 \\implies \\frac{1}{\\sqrt{0.1x}} \\le 0.25 \\implies \\sqrt{0.1x} \\ge 4 \\implies 0.1x \\ge 16 \\implies x \\ge 160$.\n2.  $\\tau_1 \\le 0.25 \\implies 0.1 \\le 0.25$. This is always true.\n\nThe most restrictive condition is $x \\ge 160$. The smallest integer value is $x_{\\mathrm{crit}} = 160$.\n\nIn summary, the minimal integer thresholds are:\n- Case 1: $x_{\\mathrm{crit}} = 250$\n- Case 2: $N_{\\mathrm{crit}} = 60$\n- Case 3: $x_{\\mathrm{crit}} = 160$\n\nThe following program implements a numerical search to confirm these derived values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimal expected molecule count threshold for three test cases\n    based on a validity criterion for the Chemical Langevin Equation.\n    \"\"\"\n\n    test_cases = [\n        {'type': 'birth_death', 'params': {'kb': 5.0, 'kd': 0.1, 'dt': 5.0, 'eps': 0.6}},\n        {'type': 'isomerization', 'params': {'k1': 0.05, 'k2': 0.10, 'dt': 2.0, 'eps': 0.5}},\n        {'type': 'pure_death', 'params': {'mu': 1.0, 'dt': 0.1, 'eps': 0.25}}\n    ]\n\n    results = []\n    max_count = 1000000\n\n    # --- Case 1: Birth-Death ---\n    case1 = test_cases[0]['params']\n    kb, kd, dt, eps = case1['kb'], case1['kd'], case1['dt'], case1['eps']\n    result1 = -1\n    for x_int in range(1, max_count + 1):\n        x = float(x_int)\n        \n        # Propensities\n        a1 = kb\n        a2 = kd * x\n        \n        # Check for non-positive propensities\n        if a1 = 0 or a2 = 0: continue\n\n        # Gaussianity parameters\n        gamma1 = 1.0 / np.sqrt(a1 * dt)\n        gamma2 = 1.0 / np.sqrt(a2 * dt)\n        \n        # Lipschitz leap parameters\n        # For reaction 1 (zeroth-order), grad(a1)=0, so tau1=0\n        tau1 = 0.0\n        \n        # For reaction 2 (unimolecular)\n        grad_a2_x = kd\n        # Sum of activities on species X: |nu_1|*a1 + |nu_2|*a2 = 1*a1 + 1*a2\n        sum_act_x = a1 + a2\n        tau2 = dt * (np.abs(grad_a2_x) * sum_act_x) / a2\n        \n        # Combined validity index S\n        S = np.max([gamma1 / eps, tau1 / eps, gamma2 / eps, tau2 / eps])\n        \n        if S = 1.0:\n            result1 = x_int\n            break\n    results.append(result1)\n\n    # --- Case 2: Reversible Isomerization ---\n    case2 = test_cases[1]['params']\n    k1, k2, dt, eps = case2['k1'], case2['k2'], case2['dt'], case2['eps']\n    result2 = -1\n    for N_int in range(1, max_count + 1):\n        N = float(N_int)\n        \n        # State variables at stationarity\n        x_val = (k2 / (k1 + k2)) * N\n        y_val = (k1 / (k1 + k2)) * N\n        \n        # Propensities\n        a1 = k1 * x_val\n        a2 = k2 * y_val\n\n        if a1 = 0 or a2 = 0: continue\n\n        # Gaussianity parameters\n        gamma1 = 1.0 / np.sqrt(a1 * dt)\n        gamma2 = 1.0 / np.sqrt(a2 * dt)\n        \n        # Lipschitz leap parameters\n        grad_a1_x = k1\n        grad_a2_y = k2\n        \n        # Sum of activities on species X and Y\n        # nu_X = [-1, 1], nu_Y = [1, -1]\n        sum_act_X = np.abs(-1)*a1 + np.abs(1)*a2\n        sum_act_Y = np.abs(1)*a1 + np.abs(-1)*a2\n        \n        # For tau1 (depends on grad a1 w.r.t x and y)\n        tau1 = dt * (np.abs(grad_a1_x) * sum_act_X) / a1\n        \n        # For tau2 (depends on grad a2 w.r.t x and y)\n        tau2 = dt * (np.abs(grad_a2_y) * sum_act_Y) / a2\n\n        S = np.max([gamma1 / eps, tau1 / eps, gamma2 / eps, tau2 / eps])\n        \n        if S = 1.0:\n            result2 = N_int\n            break\n    results.append(result2)\n    \n    # --- Case 3: Pure Death ---\n    case3 = test_cases[2]['params']\n    mu, dt, eps = case3['mu'], case3['dt'], case3['eps']\n    result3 = -1\n    for x_int in range(1, max_count + 1):\n        x = float(x_int)\n        \n        # Propensity\n        a1 = mu * x\n        \n        if a1 = 0: continue\n\n        # Gaussianity parameter\n        gamma1 = 1.0 / np.sqrt(a1 * dt)\n        \n        # Lipschitz leap parameter\n        grad_a1_x = mu\n        # Sum of activities: |nu_1|*a1\n        sum_act_x = np.abs(-1) * a1\n        tau1 = dt * (np.abs(grad_a1_x) * sum_act_x) / a1\n        \n        S = np.max([gamma1 / eps, tau1 / eps])\n        \n        if S = 1.0:\n            result3 = x_int\n            break\n    results.append(result3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}