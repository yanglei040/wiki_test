{
    "hands_on_practices": [
        {
            "introduction": "在进行任何模拟分析之前，代谢模型必须首先遵守基本的物理定律。本练习将引导你完成模型修正中最基础的任务：将反应列表转化为化学计量矩阵（$S$），并验证每个反应是否遵循质量守恒。这项原子平衡检查  是确保你的网络重建在化学上准确无误的最关键的第一步。",
            "id": "3312958",
            "problem": "您正在整理一个基因组尺度代谢子网络的草图，并且必须验证其反应遵守原子和质量守恒定律，这是进行缺口填补决策的一个先决条件。请考虑以下包含区室和实验式的代谢物列表，其中 $[e]$ 表示胞外区室，$[c]$ 表示胞质区室。将位于不同区室的相同化学物质视为不同的物种。\n\n- $ \\mathrm{glc}[e] $ (葡萄糖，胞外): 分子式 $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $。\n- $ \\mathrm{glc}[c] $ (葡萄糖，胞质): 分子式 $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $。\n- $ \\mathrm{pi}[c] $ (无机磷酸盐，胞质): 分子式 $ \\mathrm{H}_{1} \\mathrm{O}_{4} \\mathrm{P}_{1} $。\n- $ \\mathrm{h2o}[c] $ (水，胞质): 分子式 $ \\mathrm{H}_{2} \\mathrm{O}_{1} $。\n- $ \\mathrm{g6p}[c] $ (6-磷酸葡萄糖，胞质): 分子式 $ \\mathrm{C}_{6} \\mathrm{H}_{11} \\mathrm{O}_{9} \\mathrm{P}_{1} $。\n- $ \\mathrm{h}[c] $ (质子，胞质): 分子式 $ \\mathrm{H}_{1} $。\n- $ \\mathrm{pyr}[c] $ (丙酮酸，胞质): 分子式 $ \\mathrm{C}_{3} \\mathrm{H}_{3} \\mathrm{O}_{3} $。\n- $ \\mathrm{lac}[c] $ (乳酸，胞质): 分子式 $ \\mathrm{C}_{3} \\mathrm{H}_{5} \\mathrm{O}_{3} $。\n- $ \\mathrm{co2}[c] $ (二氧化碳，胞质): 分子式 $ \\mathrm{C}_{1} \\mathrm{O}_{2} $。\n\n该网络草图包含以下反应，以整数化学计量系数列出。生成物位于右侧，反应物位于左侧。\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $。\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $。\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $。\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $。\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $。\n- $ R_{6}: \\ \\mathrm{glc}[e] \\rightarrow \\varnothing $ (葡萄糖交换到一个边界汇)。\n\n任务：\n\n1. 使用反应物系数为负、生成物系数为正的符号约定，构建化学计量矩阵 $ S $。其中，行按 $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $ 的顺序排列，列按 $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $ 的顺序排列。\n\n2. 援引原子守恒定律和化学计量矩阵的定义，通过比较左侧与右侧的 $ \\mathrm{C} $、 $ \\mathrm{H} $、 $ \\mathrm{O} $ 和 $ \\mathrm{P} $ 的总数，来验证每个内部反应的元素平衡。将 $ R_{6} $ 视为边界交换（不将其包含在内部平衡验证中）。\n\n3. 设原子量由符号 $ w_{\\mathrm{C}} $、 $ w_{\\mathrm{H}} $、 $ w_{\\mathrm{O}} $ 和 $ w_{\\mathrm{P}} $ 表示，且每个 $ w_{\\alpha} > 0 $。使用这些权重和元素计数，为那些原子平衡的反应证明其质量平衡，并检测任何非原子平衡反应的质量不平衡。\n\n4. 令 $ k $ 为 $ \\{ R_{1}, R_{2}, R_{3}, R_{4}, R_{5} \\} $ 中非原子平衡反应的数量。报告 $ k $ 的值。最终答案必须是单个整数。无需四舍五入，也无需单位。",
            "solution": "我们从基于约束的建模中使用的定义以及质量和原子守恒定律开始。\n\n- 化学计量矩阵 $ S \\in \\mathbb{R}^{m \\times n} $ 编码了反应的化学计量关系，其中 $ m $ 种代谢物为行，$ n $ 个反应为列。对于反应 $ j $，如果代谢物 $ i $ 被消耗，则化学计量系数 $ S_{ij} $ 为负；如果其被生成，则为正。\n\n- 对于一个反应中的元素 $ \\alpha \\in \\{ \\mathrm{C}, \\mathrm{H}, \\mathrm{O}, \\mathrm{P} \\} $，原子平衡要求反应式左侧的 $ \\alpha $ 原子总数等于右侧的 $ \\alpha $ 原子总数。这源于原子守恒定律。\n\n- 如果每种元素都守恒且原子量 $ w_{\\alpha} $ 是正常数，则质量是守恒的，因为总质量是守恒的原子数量与正权重的线性组合。\n\n步骤 1：构建化学计量矩阵 $ S $。\n\n我们遵循代谢物顺序 $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $ 和反应顺序 $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $。我们将每个反应转换为列条目：\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $ 得到 $ S_{\\mathrm{glc}[e],R_{1}} = -1 $, $ S_{\\mathrm{glc}[c],R_{1}} = +1 $, 所有其他项为 $ 0 $。\n\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $ 得到 $ S_{\\mathrm{glc}[c],R_{2}} = -1 $, $ S_{\\mathrm{pi}[c],R_{2}} = -1 $, $ S_{\\mathrm{g6p}[c],R_{2}} = +1 $, $ S_{\\mathrm{h2o}[c],R_{2}} = +1 $, 所有其他项为 $ 0 $。\n\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $ 得到 $ S_{\\mathrm{g6p}[c],R_{3}} = -1 $, $ S_{\\mathrm{h2o}[c],R_{3}} = -1 $, $ S_{\\mathrm{glc}[c],R_{3}} = +1 $, $ S_{\\mathrm{pi}[c],R_{3}} = +1 $, 所有其他项为 $ 0 $。\n\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $ 得到 $ S_{\\mathrm{pyr}[c],R_{4}} = -1 $, $ S_{\\mathrm{h}[c],R_{4}} = -2 $, $ S_{\\mathrm{lac}[c],R_{4}} = +1 $, 所有其他项为 $ 0 $。\n\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $ 得到 $ S_{\\mathrm{pyr}[c],R_{5}} = -1 $, $ S_{\\mathrm{lac}[c],R_{5}} = +1 $, $ S_{\\mathrm{co2}[c],R_{5}} = +1 $, 所有其他项为 $ 0 $。\n\n- $ R_{6}: \\ \\mathrm{glc}[e] \\rightarrow \\varnothing $ 得到 $ S_{\\mathrm{glc}[e],R_{6}} = -1 $, 所有其他项为 $ 0 $。\n\n因此，\n$$\nS \\ = \\\n\\begin{pmatrix}\n-1  0  0  0  0  -1 \\\\\n+1  -1  +1  0  0  0 \\\\\n0  -1  +1  0  0  0 \\\\\n0  +1  -1  0  0  0 \\\\\n0  +1  -1  0  0  0 \\\\\n0  0  0  -2  0  0 \\\\\n0  0  0  -1  -1  0 \\\\\n0  0  0  +1  +1  0 \\\\\n0  0  0  0  +1  0\n\\end{pmatrix}\n$$\n其中行对应于 $ [ \\mathrm{glc}[e], \\mathrm{glc}[c], \\mathrm{pi}[c], \\mathrm{h2o}[c], \\mathrm{g6p}[c], \\mathrm{h}[c], \\mathrm{pyr}[c], \\mathrm{lac}[c], \\mathrm{co2}[c] ] $，列对应于 $ [ R_{1}, R_{2}, R_{3}, R_{4}, R_{5}, R_{6} ] $。\n\n步骤 2：验证内部反应 $ R_{1} $ 到 $ R_{5} $ 的元素平衡。\n\n我们使用实验式：\n\n- $ \\mathrm{glc} $: $ \\mathrm{C}_{6} \\mathrm{H}_{12} \\mathrm{O}_{6} $。\n- $ \\mathrm{pi} $: $ \\mathrm{H}_{1} \\mathrm{O}_{4} \\mathrm{P}_{1} $。\n- $ \\mathrm{h2o} $: $ \\mathrm{H}_{2} \\mathrm{O}_{1} $。\n- $ \\mathrm{g6p} $: $ \\mathrm{C}_{6} \\mathrm{H}_{11} \\mathrm{O}_{9} \\mathrm{P}_{1} $。\n- $ \\mathrm{h} $: $ \\mathrm{H}_{1} $。\n- $ \\mathrm{pyr} $: $ \\mathrm{C}_{3} \\mathrm{H}_{3} \\mathrm{O}_{3} $。\n- $ \\mathrm{lac} $: $ \\mathrm{C}_{3} \\mathrm{H}_{5} \\mathrm{O}_{3} $。\n- $ \\mathrm{co2} $: $ \\mathrm{C}_{1} \\mathrm{O}_{2} $。\n\n对于每个反应，我们计算左侧（LHS）和右侧（RHS）的总元素计数：\n\n- $ R_{1}: \\ \\mathrm{glc}[e] \\rightarrow \\mathrm{glc}[c] $。左侧元素：$ (\\mathrm{C}, \\mathrm{H}, \\mathrm{O}, \\mathrm{P}) = (6, 12, 6, 0) $。右侧：$ (6, 12, 6, 0) $。对所有列出的元素均平衡。\n\n- $ R_{2}: \\ \\mathrm{glc}[c] + \\mathrm{pi}[c] \\rightarrow \\mathrm{g6p}[c] + \\mathrm{h2o}[c] $。左侧：$ (6, 12, 6, 0) + (0, 1, 4, 1) = (6, 13, 10, 1) $。右侧：$ (6, 11, 9, 1) + (0, 2, 1, 0) = (6, 13, 10, 1) $。平衡。\n\n- $ R_{3}: \\ \\mathrm{g6p}[c] + \\mathrm{h2o}[c] \\rightarrow \\mathrm{glc}[c] + \\mathrm{pi}[c] $。左侧：$ (6, 11, 9, 1) + (0, 2, 1, 0) = (6, 13, 10, 1) $。右侧：$ (6, 12, 6, 0) + (0, 1, 4, 1) = (6, 13, 10, 1) $。平衡。\n\n- $ R_{4}: \\ \\mathrm{pyr}[c] + 2 \\ \\mathrm{h}[c] \\rightarrow \\mathrm{lac}[c] $。左侧：$ (3, 3, 3, 0) + 2 \\times (0, 1, 0, 0) = (3, 5, 3, 0) $。右侧：$ (3, 5, 3, 0) $。平衡。\n\n- $ R_{5}: \\ \\mathrm{pyr}[c] \\rightarrow \\mathrm{lac}[c] + \\mathrm{co2}[c] $。左侧：$ (3, 3, 3, 0) $。右侧：$ (3, 5, 3, 0) + (1, 0, 2, 0) = (4, 5, 5, 0) $。不平衡：右侧减去左侧的差异为 $ (\\Delta \\mathrm{C}, \\Delta \\mathrm{H}, \\Delta \\mathrm{O}, \\Delta \\mathrm{P}) = (1, 2, 2, 0) \\neq (0, 0, 0, 0) $。\n\n因此，在内部反应 $ R_{1} $ 到 $ R_{5} $ 中，只有 $ R_{5} $ 是原子不平衡的。\n\n步骤 3：使用原子量验证质量平衡。\n\n令 $ w_{\\mathrm{C}}, w_{\\mathrm{H}}, w_{\\mathrm{O}}, w_{\\mathrm{P}} > 0 $ 分别为碳、氢、氧和磷的原子量。对于一个反应，用 $ \\nu_{\\alpha}^{\\mathrm{LHS}} $ 和 $ \\nu_{\\alpha}^{\\mathrm{RHS}} $ 表示左侧和右侧元素 $ \\alpha $ 的总数。每一侧的质量为\n$$\nM_{\\mathrm{LHS}} \\ = \\ \\sum_{\\alpha \\in \\{\\mathrm{C},\\mathrm{H},\\mathrm{O},\\mathrm{P}\\}} w_{\\alpha} \\, \\nu_{\\alpha}^{\\mathrm{LHS}}, \n\\quad\nM_{\\mathrm{RHS}} \\ = \\ \\sum_{\\alpha \\in \\{\\mathrm{C},\\mathrm{H},\\mathrm{O},\\mathrm{P}\\}} w_{\\alpha} \\, \\nu_{\\alpha}^{\\mathrm{RHS}}.\n$$\n如果一个反应是原子平衡的，那么对于每个 $ \\alpha $，我们有 $ \\nu_{\\alpha}^{\\mathrm{LHS}} = \\nu_{\\alpha}^{\\mathrm{RHS}} $，因此根据线性关系 $ M_{\\mathrm{LHS}} = M_{\\mathrm{RHS}} $。这适用于 $ R_{1}, R_{2}, R_{3}, R_{4} $，从而证实了质量平衡。\n\n对于 $ R_{5} $，元素计数的净变化是 $ (\\Delta \\mathrm{C}, \\Delta \\mathrm{H}, \\Delta \\mathrm{O}, \\Delta \\mathrm{P}) = (1, 2, 2, 0) $。质量差（右侧减左侧）是\n$$\n\\Delta M \\ = \\ w_{\\mathrm{C}} \\cdot 1 \\ + \\ w_{\\mathrm{H}} \\cdot 2 \\ + \\ w_{\\mathrm{O}} \\cdot 2 \\ + \\ w_{\\mathrm{P}} \\cdot 0 \\ = \\ w_{\\mathrm{C}} \\ + \\ 2 w_{\\mathrm{H}} \\ + \\ 2 w_{\\mathrm{O}}.\n$$\n由于 $ w_{\\mathrm{C}}, w_{\\mathrm{H}}, w_{\\mathrm{O}} > 0 $，因此 $ \\Delta M > 0 $，所以 $ R_{5} $ 不是质量平衡的。这与上面发现的原子不平衡是一致的。\n\n步骤 4：报告 $ k $，即 $ \\{ R_{1}, R_{2}, R_{3}, R_{4}, R_{5} \\} $ 中原子不平衡反应的数量。\n\n根据步骤 2，只有一个反应（$ R_{5} $）是不平衡的，所以 $ k = 1 $。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "即使单个反应在原子上是平衡的，它们在网络中的组合也可能产生热力学上不可能出现的行为。本练习将探讨一种常见的模型病灶，即无效循环或伪能量生成循环。你将学习如何使用流平衡分析（FBA）作为一种诊断工具 ，而非预测工具，来识别这些不一致性，并探索如何通过调整反应可逆性等修正策略来恢复模型的热力学可行性。",
            "id": "3312950",
            "problem": "给定三个以化学计量矩阵表示的小型草拟代谢网络，它们处于稳态假设下，适用流通平衡分析。目标是通过在稳态下展示不依赖于生长的 ATP 产生来检测伪腺苷三磷酸 (ATP) 生成循环，并提出修正步骤以打破该循环。\n\n基本原理和定义：\n- 在稳态下，细胞内代谢物浓度恒定，这意味着存在质量平衡约束 $S \\, v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是流通向量。\n- 每个反应 $j$ 都有下界和上界 $l_j \\le v_j \\le u_j$，用于编码不可逆性和容量。\n- 可逆反应具有 $l_j  0$ 和 $u_j  0$。不可逆正向反应具有 $l_j = 0$ 和 $u_j  0$。\n- 交换反应是关闭的，因此不允许净吸收；所提供的网络不包含明确的交换反应。\n- 能量生成循环的检测标准是，在没有任何底物吸收的情况下，存在一个满足 $S v = 0$ 和边界条件的可行稳态流通向量 $v$，并且通过 ATP 合成反应（记为 $v_{\\mathrm{ATPS}}$）的流通为正值。如果在所有交换反应关闭的稳态下 $\\max v_{\\mathrm{ATPS}}  0$，则表明存在伪 ATP 生成循环。\n- 流通值的单位是毫摩尔每克干重每小时 $\\left(\\mathrm{mmol}\\ \\mathrm{gDW}^{-1}\\ \\mathrm{h}^{-1}\\right)$。所有流通值均需以该单位的实数报告。\n\n你的程序必须：\n- 对于每个测试网络，求解在线性约束 $S v = 0$ 和 $l \\le v \\le u$ 下最大化 $v_{\\mathrm{ATPS}}$ 的线性规划问题。当且仅当最优目标值严格大于一个小的非负容差 $\\epsilon$（其中 $\\epsilon = 10^{-9}$）时，声明检测到伪 ATP 生成循环。\n- 通过找到基数最小的反应集合进行阻断（将这些反应的 $v_j$ 设为 $0$），提出一个最小修正步骤来打破循环，使得在相同约束下最大的 $v_{\\mathrm{ATPS}}$ 变为精确为零（在容差 $\\epsilon$ 范围内）。如果存在多个基数最小的集合，选择字典序最小的反应索引集合（从零开始）。\n- 对于未检测到循环的网络（即最优目标值最多为 $\\epsilon$），推荐的修正集合为空列表。\n\n测试套件：\n- 所有情况下的代谢物顺序固定为 $\\left[\\mathrm{ATP}, \\mathrm{ADP}, \\mathrm{Pi}, \\mathrm{H^+}, \\mathrm{H_2O}\\right]$。\n- 反应顺序如下所列，因情况而异。所有数值条目必须按给定的字面值处理。\n\n情况 A（存在伪 ATP 生成循环）：\n- 反应：\n  - 反应 $0$（ATP 合成酶，错误地设为可逆）： $\\mathrm{ADP} + \\mathrm{Pi} + \\mathrm{H^+} \\leftrightarrow \\mathrm{ATP} + \\mathrm{H_2O}$。\n  - 反应 $1$（ATP 维持需求）： $\\mathrm{ATP} + \\mathrm{H_2O} \\rightarrow \\mathrm{ADP} + \\mathrm{Pi} + \\mathrm{H^+}$。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{5 \\times 2}$，其中列 $j$ 等于反应 $j$ 的化学计量系数：\n  - $S_{\\cdot,0} = \\begin{bmatrix} +1 \\\\ -1 \\\\ -1 \\\\ -1 \\\\ +1 \\end{bmatrix}$，\n  - $S_{\\cdot,1} = \\begin{bmatrix} -1 \\\\ +1 \\\\ +1 \\\\ +1 \\\\ -1 \\end{bmatrix}$。\n- 边界：\n  - $l_0 = -1000$, $u_0 = +1000$,\n  - $l_1 = 0$, $u_1 = +1000$。\n- 目标：最大化 $v_0$。\n\n情况 B（通过强制不可逆性以防止 ATP 生成进行修正）：\n- 与情况 A 相同的 $S$。\n- 边界：\n  - $l_0 = -1000$, $u_0 = 0$,\n  - $l_1 = 0$, $u_1 = +1000$。\n- 目标：最大化 $v_0$。\n\n情况 C（通过修正质子化学计量以防止质子平衡循环进行修正）：\n- 反应：\n  - 反应 $0$（ATP 合成酶，无质子作为底物）： $\\mathrm{ADP} + \\mathrm{Pi} \\leftrightarrow \\mathrm{ATP} + \\mathrm{H_2O}$。\n  - 反应 $1$（ATP 维持需求）： $\\mathrm{ATP} + \\mathrm{H_2O} \\rightarrow \\mathrm{ADP} + \\mathrm{Pi} + \\mathrm{H^+}$。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{5 \\times 2}$：\n  - $S_{\\cdot,0} = \\begin{bmatrix} +1 \\\\ -1 \\\\ -1 \\\\ 0 \\\\ +1 \\end{bmatrix}$，\n  - $S_{\\cdot,1} = \\begin{bmatrix} -1 \\\\ +1 \\\\ +1 \\\\ +1 \\\\ -1 \\end{bmatrix}$。\n- 边界：\n  - $l_0 = -1000$, $u_0 = +1000$,\n  - $l_1 = 0$, $u_1 = +1000$。\n- 目标：最大化 $v_0$。\n\n计算和数值要求：\n- 使用线性规划求解器为每种情况找到最优目标值。\n- 使用 $\\epsilon = 10^{-9}$ 的容差来判断最优目标值的正负，并决定修正后的网络是否消除了循环。\n- 最小修正步骤的搜索应考虑通过设置 $v_j = 0$ 来阻断反应，并应返回足以将最优目标值减小到至多为 $\\epsilon$ 的最小反应索引集合。如果最初未检测到循环，则返回空集。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于按 $\\left[\\text{情况 A}, \\text{情况 B}, \\text{情况 C}\\right]$ 顺序的每种情况，输出一个包含三个条目的列表：循环检测布尔值、作为浮点数的最优目标值以及作为整数列表的最小修正集。例如，形式为 `[[True, 1.0, [0]], [False, 0.0, []], [False, 0.0, []]]` 的输出是有效的。",
            "solution": "该问题要求使用流通平衡分析 (FBA) 在简化的代谢网络中检测和修正伪能量生成循环。在稳态假设下，FBA 的核心原理是质量平衡约束 $S v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是反应流通向量。每个流通 $v_j$ 还受到下界和上界 $l_j \\le v_j \\le u_j$ 的约束。\n\n如果可以在没有任何净底物吸收的情况下产生腺苷三磷酸 (ATP)，则存在伪 ATP 生成循环。这对应于找到一个满足 $S v = 0$、遵守流通边界 $l \\le v \\le u$ 并且通过 ATP 合成反应（记为 $v_{\\mathrm{ATPS}}$）的流通为正值的可行流通分布 $v$。我们将此检测形式化为一个线性规划 (LP) 问题。对于给定情况，ATP 合成反应是反应 $0$，因此我们最大化 $v_0$：\n$$ \\begin{align*} \\text{maximize} \\quad  v_{0} \\\\ \\text{subject to} \\quad  S v = 0 \\\\  l_j \\le v_j \\le u_j \\quad \\forall j \\end{align*} $$\n如果最优目标值严格大于数值容差 $\\epsilon = 10^{-9}$，则检测到循环。\n\n如果检测到循环，修正过程涉及识别一个最小的反应集合进行阻断（通过将其流通 $v_j$ 设置为 $0$），使得修正后网络中的最大 $v_{0}$ 减小到 $0$（即 $\\le \\epsilon$）。最小修正集的搜索通过组合测试要阻断的反应集来进行，从基数 $k=1$ 开始，然后是 $k=2$，以此类推。对于给定的基数，按反应索引的字典序测试集合，以确保解的唯一性。通过此过程找到的第一个有效修正集即为所求答案。\n\n我们现在使用此框架分析每种情况。\n\n**情况 A：**\n化学计量矩阵为 $S_A = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\\\ -1  1 \\\\ -1  1 \\\\ 1  -1 \\end{bmatrix}$。第二列是第一列的负值，$S_{\\cdot,1} = -S_{\\cdot,0}$。质量平衡约束 $S v = 0$ 展开为 $S_{\\cdot,0} v_0 + S_{\\cdot,1} v_1 = 0$，可简化为 $S_{\\cdot,0} v_0 - S_{\\cdot,0} v_1 = S_{\\cdot,0}(v_0 - v_1) = 0$。由于 $S_{\\cdot,0}$ 是一个非零向量，这意味着标量约束 $v_0 - v_1 = 0$，即 $v_0 = v_1$。\n\n流通边界为：\n- 反应 $0$：$-1000 \\le v_0 \\le 1000$\n- 反应 $1$：$0 \\le v_1 \\le 1000$\n\n将约束 $v_0 = v_1$ 与 $v_1$ 的边界结合，得到约束 $0 \\le v_0 \\le 1000$。$v_0$ 的可行域是其自身边界和这个派生约束的交集，即 $[0, 1000]$。目标是最大化 $v_0$。因此，最优值为 $\\max v_0 = 1000$。\n由于 $1000  10^{-9}$，检测到伪 ATP 生成循环。\n\n为进行修正，我们搜索要阻断的最小反应集合。\n- **基数 $k=1$**：\n  - 测试阻断反应 $0$：我们设置 $v_0 = 0$。约束 $v_0 = v_1$ 意味着 $v_1 = 0$。新的 LP 在约束 $v_0=0$ 下寻求最大化 $v_0$，得到最优值为 $0$。由于 $0 \\le \\epsilon$，阻断反应 $0$ 是一个有效的修正。索引集合为 $\\{0\\}$。\n  - 由于我们找到了一个大小为 $1$ 的有效修正集，并且它是按字典序测试的第一个集合，因此 $\\{0\\}$ 是最小修正集。\n\n情况 A 的结果：检测到循环为 True，最优值为 $1000.0$，修正集为 $[0]$。\n\n**情况 B：**\n化学计量矩阵与情况 A 相同，因此约束 $v_0 = v_1$ 仍然成立。\n流通边界不同：\n- 反应 $0$：$-1000 \\le v_0 \\le 0$\n- 反应 $1$：$0 \\le v_1 \\le 1000$\n\n将 $v_0 = v_1$ 代入 $v_1$ 的边界，得出 $0 \\le v_0 \\le 1000$。$v_0$ 的可行域是其直接边界（$-1000 \\le v_0 \\le 0$）和派生边界（$0 \\le v_0 \\le 1000$）的交集。唯一同时满足 $v_0 \\le 0$ 和 $v_0 \\ge 0$ 的值是 $v_0=0$。\n目标是最大化 $v_0$。唯一的可行值是 $0$，所以最优值为 $\\max v_0 = 0$。\n由于 $0 \\le 10^{-9}$，未检测到伪循环。修正集为空。\n\n情况 B 的结果：检测到循环为 False，最优值为 $0.0$，修正集为 []。\n\n**情况 C：**\n化学计量矩阵为 $S_C = \\begin{bmatrix} 1  -1 \\\\ -1  1 \\\\ -1  1 \\\\ 0  1 \\\\ 1  -1 \\end{bmatrix}$。\n线性方程组 $S_C v = 0$ 为：\n$v_0 - v_1 = 0$\n$-v_0 + v_1 = 0$\n$-v_0 + v_1 = 0$\n$0 \\cdot v_0 + 1 \\cdot v_1 = 0 \\implies v_1 = 0$\n$v_0 - v_1 = 0$\n\n从这些方程的一个子集中，我们发现 $v_1 = 0$ 和 $v_0 = v_1$，这强制得到唯一解 $v_0 = 0$ 和 $v_1 = 0$。这个解 $(0, 0)$ 是可行的，因为它满足给定的边界条件（$-1000 \\le 0 \\le 1000$ 和 $0 \\le 0 \\le 1000$）。\n由于唯一的可行流通向量是 $(0, 0)$，最大化 $v_0$ 的目标的最优值为 $0$。\n由于 $0 \\le 10^{-9}$，未检测到伪循环。修正集为空。\n\n情况 C 的结果：检测到循环为 False，最优值为 $0.0$，修正集为 []。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves for spurious ATP loops in three metabolic network test cases,\n    and proposes minimal curation steps.\n    \"\"\"\n    TOLERANCE = 1e-9\n\n    def solve_lp(c, S, bounds):\n        \"\"\"\n        Wrapper function to solve the LP max c^T x, returning the optimal value.\n        linprog solves min problems, so we maximize by minimizing -c^T x.\n        \"\"\"\n        # The 'highs-ds' method is a robust choice for this type of LP.\n        res = linprog(c, A_eq=S, b_eq=np.zeros(S.shape[0]), bounds=bounds, method='highs-ds')\n        if res.success:\n            # res.fun is the minimum of c^T*v. If c=-e_i, this is -max(v_i).\n            return -res.fun\n        # Return a value indicating no feasible solution generating positive objective\n        return -np.inf\n\n    def find_curation(S, bounds, obj_idx, tol):\n        \"\"\"\n        Finds the minimal-cardinality, lexicographically smallest set of reactions\n        to block to eliminate a spurious loop.\n        \"\"\"\n        n_reactions = S.shape[1]\n        c = np.zeros(n_reactions)\n        c[obj_idx] = -1.0\n\n        # Iterate through the cardinality of the blocking set\n        for k in range(1, n_reactions + 1):\n            # Iterate through all combinations of reactions of size k\n            # combinations() generates tuples in lexicographical order\n            for indices_to_block in combinations(range(n_reactions), k):\n                new_bounds = list(bounds)\n                for idx in indices_to_block:\n                    # Block reaction by setting its flux to 0\n                    new_bounds[idx] = (0, 0)\n                \n                max_v_curated = solve_lp(c, S, new_bounds)\n                \n                if max_v_curated is not None and max_v_curated = tol:\n                    return list(indices_to_block)\n        \n        # This part should not be reached if a loop was detected as\n        # blocking all reactions guarantees an objective of 0.\n        return []\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            # Case A: Spurious loop present due to reversibility\n            \"S\": np.array([[1, -1], [-1, 1], [-1, 1], [-1, 1], [1, -1]], dtype=np.float64),\n            \"bounds\": [(-1000.0, 1000.0), (0.0, 1000.0)],\n        },\n        {\n            # Case B: Loop fixed by enforcing irreversibility\n            \"S\": np.array([[1, -1], [-1, 1], [-1, 1], [-1, 1], [1, -1]], dtype=np.float64),\n            \"bounds\": [(-1000.0, 0.0), (0.0, 1000.0)],\n        },\n        {\n            # Case C: Loop fixed by correcting stoichiometry\n            \"S\": np.array([[1, -1], [-1, 1], [-1, 1], [0, 1], [1, -1]], dtype=np.float64),\n            \"bounds\": [(-1000.0, 1000.0), (0.0, 1000.0)],\n        },\n    ]\n\n    all_case_results = []\n    \n    for case in test_cases:\n        S = case[\"S\"]\n        bounds = case[\"bounds\"]\n        n_reactions = S.shape[1]\n        atp_synthase_idx = 0  # Maximize v_0\n\n        # Create the objective vector for maximization: c = -e_0\n        c = np.zeros(n_reactions)\n        c[atp_synthase_idx] = -1.0\n        \n        # 1. Detect loop\n        max_v = solve_lp(c, S, bounds)\n        if max_v is None or max_v  0: # Handle solver failures or negative max\n             max_v = 0.0\n\n        detected = max_v > TOLERANCE\n        \n        # 2. Propose curation if necessary\n        curation_set = []\n        if detected:\n            curation_set = find_curation(S, bounds, atp_synthase_idx, TOLERANCE)\n        \n        all_case_results.append([detected, float(max_v), curation_set])\n\n    # Format the final output as a string representation of a list of lists.\n    # The example output format shows spaces after commas. Using str() on the\n    # list of lists achieves this formatting.\n    print(str(all_case_results))\n\nsolve()\n```"
        },
        {
            "introduction": "初步构建的代谢网络模型面临的一个普遍挑战是其不完整性，这常常导致模型无法模拟如细胞生长等关键生物学功能。本练习聚焦于“补洞”（gap-filling）这一核心任务，旨在恢复模型的功能。通过将流平衡分析（FBA）与系统性搜索相结合 ，你将学习如何识别并添加一个最小化的候选反应集合，以使模型能够产生生物质，这是完善基因组尺度模型的关键技能。",
            "id": "3312957",
            "problem": "给定一个小型稳态代谢网络，你需要执行流平衡分析（FBA）来计算一个最优通量分布，该分布在满足质量平衡约束和通量边界的同时最大化生物质量。如果需要，你还必须通过添加一组最小的候选反应集来执行补缺（gap-filling），以使目标生物质产量超过给定阈值。此任务的基础是稳态下的化学计量质量平衡，其约束为 $S v = 0$，其中 $S$ 是化学计量矩阵，$v$ 是通量向量，同时还需满足反应通量边界 $l \\le v \\le u$。流平衡分析（FBA）是一种线性优化方法，旨在在这些约束条件下最大化生物质通量，而补缺是在这些约束下通过添加反应来恢复模型功能的过程。\n\n定义和假设：\n- 化学计量矩阵 $S$ 的行对应内源代谢物，列对应反应。每个反应列包含代谢物的化学计量系数，消耗为负，生产为正。\n- 用于代谢物摄取的交换反应表示为列向量，其中内源代谢物的化学计量系数为负（例如，$EX\\_A$ 中代谢物 $A$ 的系数为 $-1$，其他为 $0$），通量边界设置为允许摄取为负通量：下界 $ 0$，上界 $= 0$。\n- 生物质反应表示为一个消耗生物质前体的列。对于下面的玩具网络，生物质反应消耗代谢物 $C$，其对 $C$ 的化学计量系数为 $-1$。\n- 所有通量必须以毫摩尔/克干重/小时（缩写为 $mmol\\,gDW^{-1}\\,h^{-1}$）表示。你的输出应四舍五入到四位小数。\n- 反应索引使用基于 $0$ 的索引。\n\n你必须实现一个程序，为每个测试用例执行以下操作：\n1. 通过添加最少数量的候选反应（如果需要）来执行补缺，以实现生物质产量超过阈值 $\\tau$。\n2. 使用线性规划，在 $S v = 0$ 和边界 $l \\le v \\le u$ 的约束下，通过最大化生物质反应通量来计算最优通量分布 $v^\\*$。\n3. 验证并返回布尔值，指示 $S v^\\* = 0$ 是否在容差范围内满足，以及边界约束是否满足。\n4. 为每个测试用例返回一个包含四个条目的列表：最优生物质通量（四舍五入到四位小数，单位为 $mmol\\,gDW^{-1}\\,h^{-1}$）、一个表示质量平衡一致性的布尔值、一个表示边界一致性的布尔值，以及添加的候选反应的索引列表（使用基于 $0$ 的索引）。\n\n测试套件规范：\n所有代谢物均为 $A$、$B$、$C$（三种内源代谢物）。对于每个用例，基础网络包含具有指定化学计量和边界的一部分反应。在补缺过程中可以添加候选反应。在每个测试用例中，生物质反应索引始终是最后一个基础反应的索引。\n\n- 用例 $1$（已功能齐全的网络）：\n  - 基础反应（$S$ 的列）和边界：\n    - $EX\\_A$：化学计量 $[-1, 0, 0]$，边界 $[-3, 0]$。\n    - $R1$：化学计量 $[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：化学计量 $[0, -1, +1]$，边界 $[0, 1000]$。\n    - $Biomass$：化学计量 $[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R\\_{alt}$：化学计量 $[-1, 0, +1]$，边界 $[0, 1000]$。\n  - 生物质反应索引：$3$。\n  - 阈值 $\\tau$：$2.0$。\n\n- 用例 $2$（缺少一个必须添加的反应）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[-2, 0]$。\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n  - 生物质反应索引：$2$。\n  - 阈值 $\\tau$：$1.5$。\n\n- 用例 $3$（需要添加两个反应）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[-1.5, 0]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n  - 生物质反应索引：$1$。\n  - 阈值 $\\tau$：$1.0$。\n\n- 用例 $4$（边界情况，不允许摄取；无法生长）：\n  - 基础反应：\n    - $EX\\_A$：$[-1, 0, 0]$，边界 $[0, 0]$。\n    - $R1$：$[-1, +1, 0]$，边界 $[0, 1000]$。\n    - $R2$：$[0, -1, +1]$，边界 $[0, 1000]$。\n    - $Biomass$：$[0, 0, -1]$，边界 $[0, 1000]$。\n  - 候选反应：无。\n  - 生物质反应索引：$3$。\n  - 阈值 $\\tau$：$0.1$。\n\n算法要求：\n- 将 FBA 表述为一个线性规划问题，在 $S v = 0$ 和 $l \\le v \\le u$ 的约束下最大化生物质通量。除了线性规划外，不得使用任何捷径，并且必须确保数值稳定性。\n- 对于补缺，按基数递增的顺序搜索候选反应的子集，以找到能使最优生物质通量严格大于阈值 $\\tau$ 的最小集合。如果多个相同基数的子集满足阈值，则选择能产生最高最优生物质通量的那个。如果没有子集满足阈值，则选择空子集，并仅为基础网络计算最优通量分布。\n- 通过计算质量平衡残差的无穷范数 $||S v^\\*||_\\infty$ 并检查其是否低于 $10^{-8}$ 的容差，来验证与约束的一致性。同时验证所有边界是否在 $10^{-8}$ 的容差内得到满足。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也编码为一个列表：$[biomass,mb\\_ok,bounds\\_ok,[added\\_indices]]$。例如：$[[3.0000,True,True,[]],[2.0000,True,True,[0]],...]$。所有通量值必须以 $mmol\\,gDW^{-1}\\,h^{-1}$ 为单位，并四舍五入到四位小数。布尔值必须是精确的逻辑值。添加的索引列表必须使用基于 $0$ 的索引。",
            "solution": "该问题要求在计算系统生物学中实现两个基本算法：流平衡分析（FBA）和模型补缺。目标是确定给定网络的最优代谢通量分布，该分布能够最大化生物质产量，这可能需要在用候选池中的最小反应集扩充网络以满足指定的产量阈值后实现。\n\n### 原理一：质量平衡与稳态\n\nFBA 的核心是质量守恒原理。对于一个在稳态下运行的代谢网络，每个内源代谢物的浓度保持恒定。这意味着对于每种代谢物，其总生产速率必须等于其总消耗速率。这个约束可以用一个线性方程组在数学上表示：\n$$\nS v = 0\n$$\n其中 $S$ 是大小为 $m \\times n$ 的化学计量矩阵（$m$ 种代谢物，$n$ 个反应），$v$ 是大小为 $n \\times 1$ 的反应通量（速率）向量。矩阵中的每个条目 $S_{ij}$ 代表代谢物 $i$ 在反应 $j$ 中的化学计量系数。按照惯例，负系数（$S_{ij}  0$）表示消耗，正系数（$S_{ij}  0$）表示生产。向量方程 $S v = 0$ 确保了任何内源代谢物都没有净积累或消耗。\n\n### 原理二：作为线性规划的流平衡分析（FBA）\n\n虽然稳态假设限制了可能的通量分布，但它通常不能定义一个唯一的解。满足 $S v = 0$ 的可行通量向量空间还受到热力学和容量限制的约束，这些限制表示为单个通量的下界和上界：\n$$\nl \\le v \\le u\n$$\n其中 $l$ 和 $u$ 分别是下界和上界向量。例如，一个不可逆反应的下界为 $0$。一个允许从环境中摄取营养物的交换反应将具有负的下界（例如，$v_{uptake} \\in [-10, 0]$）。\n\nFBA 使用线性规划（LP）从可行集中找到一个特定的、具有生物学意义的通量分布。这是通过优化一个目标函数来实现的，该目标函数通常是一个“生物质反应”的通量。这个反应是一个建模构想，通过消耗实验测量得到的比例的前体代谢物来模拟细胞生物质的生产。最大化其通量被认为等同于最大化生物体的生长速率。\n\n因此，FBA 问题被表述为以下 LP 问题：\n$$\n\\begin{align*}\n\\text{maximize} \\quad  c^T v \\\\\n\\text{subject to} \\quad  S v = 0 \\\\\n l \\le v \\le u\n\\end{align*}\n$$\n在这里，$c$ 是目标向量，它在对应于生物质反应的位置包含一个 $1$，在其他位置为 $0$。\n\n### 原理三：模型补缺\n\n从基因组数据重建的代谢网络通常是不完整的，包含“缺口”（缺失的反应），这会阻止模型模拟已知的生物学功能，例如生产生物质。补缺是一个计算过程，旨在从一个通用数据库（或指定的候选池）中识别出一个最小的反应集，并将其添加到模型中以恢复所需的功能。\n\n这个问题可以被构建为一个组合优化问题。我们寻求候选反应的最小子集，当添加到基础模型中时，能使生物质通量超过给定的阈值 $\\tau$。问题中指定的算法方法是一种基于简约性（最小性）原则的系统搜索：\n\n1.  从 $k=0$ 开始，对添加的反应集的基数 $k$进行搜索。\n2.  对于给定的 $k$，测试候选池中 $k$ 个反应的所有可能组合。\n3.  对于每种组合，用所选反应扩充基础模型，并执行 FBA 计算最大生物质通量。\n4.  如果任何组合产生的生物质通量超过 $\\tau$，则 $k$ 是最小基数。搜索停止，在所有大小为 $k$ 的成功组合中，选择产生最高生物质通量的那个。\n5.  如果对于任何 $k$ 都没有组合满足条件，则使用原始的、未扩充的基础模型。\n\n### 算法实现\n\n该解决方案通过将这些原理组合成一个连贯的算法来实现。\n\n1.  **FBA 求解器**：创建一个核心函数来求解 FBA 线性规划问题。它接受化学计量矩阵 $S$、边界向量 $l$ 和 $u$ 以及生物质反应的索引作为输入。使用 `scipy.optimize.linprog` 库函数，它构建并求解 LP。目标函数被设置为最小化 $-v_{biomass}$ 以实现最大化。该函数返回最优生物质通量和相应的完整通量向量 $v^*$。\n\n2.  **补缺过程**：对每个测试用例，执行补缺逻辑。\n    - 算法首先分析基础网络（基数 $k=0$）。它运行 FBA 求解器并存储由此产生的生物质通量和通量向量。\n    - 检查这个基础情况下的生物质通量是否大于阈值 $\\tau$。如果是，问题就解决了，因为最小的添加反应集是空集。\n    - 如果未达到阈值，算法继续搜索最小的非空集。它遍历基数 $k=1, 2, \\dots$ 直到候选反应的总数。对于每个 $k$，使用 `itertools.combinations` 生成该大小的所有唯一候选反应子集。\n    - 对于每个子集，通过用所选候选者的 $S$ 矩阵和边界向量扩充基础模型，构建一个新的临时模型。然后对这个临时模型调用 FBA 求解器。\n    - 如果得到的生物质通量超过 $\\tau$，则存储结果（生物质量、通量向量和添加反应的索引）。\n    - 在测试完给定 $k$ 的所有组合后，如果有任何组合满足阈值，则选择产生最大生物质的那个作为最终解决方案，并终止搜索。这遵循了先满足最小基数，再满足最大化目标的双重标准。\n    - 如果对所有 $k$ 的搜索都完成且未找到解决方案，则保留基础网络的初始结果作为最终答案。\n\n3.  **验证与输出**：一旦确定了最优配置（基础或补缺后）及其对应的通量向量 $v^*$，就会按要求执行两个验证检查。\n    - 通过计算残差向量 $Sv^*$ 并检查其无穷范数 $||Sv^*||_\\infty$ 是否小于容差 $10^{-8}$ 来验证质量平衡约束。\n    - 通过检查每个通量 $v_i^*$ 是否位于其相应边界 $[l_i, u_i]$ 内（允许相同的数值容差 $10^{-8}$）来验证边界约束。\n    - 收集每个用例的最终结果，包括四舍五入的最优生物质、两个布尔验证标志以及排序后的已添加候选索引列表。最终输出被格式化为指定的字符串表示形式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\nclass FormattedFloat:\n    \"\"\"A wrapper for floats to control their string representation for printing.\"\"\"\n    def __init__(self, value, precision=4):\n        self.value = value\n        self.precision = precision\n\n    def __repr__(self):\n        return f\"{self.value:.{self.precision}f}\"\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and format the results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: Functional network\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(-3, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1], [0], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 3,\n            \"tau\": 2.0\n        },\n        # Case 2: Missing one reaction\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0], [0, 1, 0], [0, 0, -1]],\n                \"bounds\": [(-2, 0), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[0], [-1], [1]],\n                \"bounds\": [(0, 1000)]\n            },\n            \"biomass_idx\": 2,\n            \"tau\": 1.5\n        },\n        # Case 3: Requires two reactions\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, 0], [0, 0], [0, -1]],\n                \"bounds\": [(-1.5, 0), (0, 1000)]\n            },\n            \"candidate_reactions\": {\n                \"stoichiometry\": [[-1, 0], [1, -1], [0, 1]],\n                \"bounds\": [(0, 1000), (0, 1000)]\n            },\n            \"biomass_idx\": 1,\n            \"tau\": 1.0\n        },\n        # Case 4: No uptake, no growth\n        {\n            \"base_reactions\": {\n                \"stoichiometry\": [[-1, -1, 0, 0], [0, 1, -1, 0], [0, 0, 1, -1]],\n                \"bounds\": [(0, 0), (0, 1000), (0, 1000), (0, 1000)]\n            },\n            \"candidate_reactions\": None,\n            \"biomass_idx\": 3,\n            \"tau\": 0.1\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(case)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        # Use FormattedFloat for custom number formatting within the list structure\n        r[0] = FormattedFloat(r[0])\n        result_strings.append(str(r).replace(\"'\", \"\").replace(\" \", \"\"))\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef _run_fba(S, bounds, obj_idx):\n    \"\"\"Performs Flux Balance Analysis using linear programming.\"\"\"\n    num_rxns = S.shape[1]\n    # Objective: maximize flux through obj_idx, which is min(-flux)\n    c = np.zeros(num_rxns)\n    c[obj_idx] = -1\n    \n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n    \n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if res.success:\n        # Return positive biomass flux and the full flux vector\n        return -res.fun, res.x\n    else:\n        # If optimization fails, assume zero flux\n        return 0.0, np.zeros(num_rxns)\n\ndef _process_case(case_data):\n    \"\"\"\n    Handles gap-filling and FBA for a single test case.\n    \"\"\"\n    base_stoichiometry = np.array(case_data[\"base_reactions\"][\"stoichiometry\"], dtype=float)\n    base_bounds = case_data[\"base_reactions\"][\"bounds\"]\n    \n    if case_data[\"candidate_reactions\"]:\n        candidate_stoichiometry = np.array(case_data[\"candidate_reactions\"][\"stoichiometry\"], dtype=float)\n        candidate_bounds = case_data[\"candidate_reactions\"][\"bounds\"]\n        num_candidates = candidate_stoichiometry.shape[1]\n    else:\n        candidate_stoichiometry = np.empty((base_stoichiometry.shape[0], 0))\n        candidate_bounds = []\n        num_candidates = 0\n\n    biomass_idx = case_data[\"biomass_idx\"]\n    tau = case_data[\"tau\"]\n    \n    # 1. Analyze the base network (k=0)\n    base_biomass, base_v = _run_fba(base_stoichiometry, base_bounds, biomass_idx)\n    \n    best_result = {\n        \"biomass\": base_biomass,\n        \"v\": base_v,\n        \"added_indices\": [],\n        \"S\": base_stoichiometry,\n        \"bounds\": base_bounds\n    }\n\n    # If base network is sufficient, we are done with gap-filling\n    if base_biomass > tau + 1e-9:\n        pass\n    else:\n        # 2. Perform gap-filling for k=1, 2, ...\n        for k in range(1, num_candidates + 1):\n            candidate_indices_combinations = combinations(range(num_candidates), k)\n            solutions_at_k = []\n            \n            for combo_indices in candidate_indices_combinations:\n                added_S = candidate_stoichiometry[:, combo_indices]\n                added_bounds = [candidate_bounds[i] for i in combo_indices]\n                \n                S_new = np.hstack((base_stoichiometry, added_S))\n                bounds_new = base_bounds + added_bounds\n                \n                # Biomass index is unchanged as candidates are appended\n                biomass, v = _run_fba(S_new, bounds_new, biomass_idx)\n                \n                if biomass > tau + 1e-9:\n                    solutions_at_k.append({\n                        \"biomass\": biomass,\n                        \"v\": v,\n                        \"added_indices\": list(combo_indices),\n                        \"S\": S_new,\n                        \"bounds\": bounds_new\n                    })\n            \n            if solutions_at_k:\n                # Minimal set size k found. Select the best among them.\n                best_at_k = max(solutions_at_k, key=lambda x: x[\"biomass\"])\n                best_result = best_at_k\n                break  # Exit search since minimal k is found\n    \n    # 3. Verification of the final chosen solution\n    final_S = best_result[\"S\"]\n    final_v = best_result[\"v\"]\n    final_bounds = best_result[\"bounds\"]\n    \n    # Mass balance check: ||S*v||_inf  tol\n    mass_balance_residual = final_S @ final_v\n    mb_ok = np.all(np.abs(mass_balance_residual)  1e-8)\n    \n    # Bounds check: l - tol = v = u + tol\n    bounds_ok = True\n    for i, flux in enumerate(final_v):\n        lb, ub = final_bounds[i]\n        if lb is not None and flux  lb - 1e-8:\n            bounds_ok = False\n            break\n        if ub is not None and flux > ub + 1e-8:\n            bounds_ok = False\n            break\n    \n    # 4. Format and return the result for this case\n    return [\n        best_result[\"biomass\"],\n        mb_ok,\n        bounds_ok,\n        sorted(best_result[\"added_indices\"])\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}