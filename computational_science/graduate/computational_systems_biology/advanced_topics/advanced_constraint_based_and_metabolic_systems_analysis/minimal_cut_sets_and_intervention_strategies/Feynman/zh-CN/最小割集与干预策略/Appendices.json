{
    "hands_on_practices": [
        {
            "introduction": "掌握任何复杂概念的第一步都是回归其基本原理。本练习将引导你完成从一个简单的代谢网络图到其数学表示（即化学计量矩阵）的转换。通过应用稳态质量平衡约束（$S v = 0$），你将直接推导出所有能够阻断目标通量的最小干预策略，从而为理解最小割集（Minimal Cut Sets）建立坚实的直观基础。",
            "id": "3326074",
            "problem": "考虑一个玩具代谢网络，其包含四个不可逆反应 $R_1, R_2, R_3, R_4$ 和代谢物 $A, B, C$：\n- $R_1:\\ A \\rightarrow B$，\n- $R_2:\\ B \\rightarrow C$，\n- $R_4:\\ A \\rightarrow C$，\n- $R_3:\\ C \\rightarrow \\emptyset$。\n\n假设采用标准的稳态通量平衡设置：化学计量矩阵 $S$ 是针对内部代谢物构建的，通量满足 $S v = 0$ 和 $v \\ge 0$，其中 $v = (v_1, v_2, v_3, v_4)^\\top$。代谢物 $A$ 是不包含在稳态平衡中的外部底物。反应 $R_3$ 是 $C$ 的一个排出（需求）反应。目标函数是维持通过 $R_3$ 的通量 $v_3 \\ge 1$ 的能力。\n\n最小割集定义为这样一个最小反应集合：当该集合中的所有反应同时失活时，对于所有满足 $v \\ge 0$ 的可行稳态通量向量，都会强制 $v_3 = 0$。仅使用稳态质量平衡 $S v = 0$、不可逆非负性 $v \\ge 0$ 和给定的网络拓扑这些基本定义，从基本原理出发，推导出所有能阻断目标 $v_3 \\ge 1$ 的最小割集。\n\n报告禁用目标功能 $v_3 \\ge 1$ 的最小割集的总数作为最终答案。以精确整数形式提供该数字。无需四舍五入，也不涉及物理单位。",
            "solution": "我们从通量平衡分析中的稳态质量平衡和不可逆性约束开始。令 $v = (v_1, v_2, v_3, v_4)^\\top$ 分别表示反应 $R_1, R_2, R_3, R_4$ 的反应通量。代谢物 $A$ 是外部的，因此不包括在稳态质量平衡中。内部代谢物是 $B$ 和 $C$。构建化学计量矩阵 $S$，其行对应于 $B$ 和 $C$，列对应于 $R_1, R_2, R_3, R_4$。\n\n根据反应定义：\n- 对于代谢物 $B$，$R_1$ 产生 $B$，$R_2$ 消耗 $B$。因此，对应 $B$ 的行中，$R_1$ 的条目为 $+1$，$R_2$ 的为 $-1$，$R_3$ 和 $R_4$ 的为 $0$。\n- 对于代谢物 $C$，$R_2$ 产生 $C$，$R_4$ 产生 $C$，$R_3$ 消耗 $C$。因此，对应 $C$ 的行中，$R_1$ 的条目为 $0$，$R_2$ 的为 $+1$，$R_3$ 的为 $-1$，$R_4$ 的为 $+1$。\n\n因此，\n$$\nS = \\begin{pmatrix} 1 & -1 & 0 & 0 \\\\ 0 & 1 & -1 & 1 \\end{pmatrix}, \\qquad v = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\end{pmatrix}, \\qquad v \\ge 0.\n$$\n\n稳态条件 $S v = 0$ 产生以下线性约束\n$$\n\\text{(B 平衡)}\\quad v_1 - v_2 = 0 \\;\\Rightarrow\\; v_1 = v_2,\n$$\n$$\n\\text{(C 平衡)}\\quad v_2 - v_3 + v_4 = 0 \\;\\Rightarrow\\; v_3 = v_2 + v_4.\n$$\n\n在 $v \\ge 0$ 的条件下，目标条件 $v_3 \\ge 1$ 要求 $v_2$ 或 $v_4$ 中至少有一个是严格正的，并进行缩放以使 $v_3$ 至少达到 $1$。最小割集是一个最小反应集合，移除该集合中的反应会使得对于所有可行的 $v$，都强制 $v_3 = 0$，从而阻断任何 $v_3 \\ge 1$ 的情况。\n\n我们在 $S v = 0, v \\ge 0$ 的条件下，找出所有使得 $v_3 = v_2 + v_4 = 0$ 无法避免的方法：\n\n1.直接敲除 $R_3$ 会强制 $v_3 = 0$。因此，单元素集合 $\\{R_3\\}$ 是一个割集。它是最小的，因为移除 $\\{R_3\\}$ 的任何真子集都无法达到同样的效果。\n\n2.要在不移除 $R_3$ 本身的情况下强制 $v_3 = v_2 + v_4 = 0$，必须强制 $v_2 = 0$ 和 $v_4 = 0$。\n   - 强制 $v_4 = 0$ 可以通过移除 $R_4$ 来实现。\n   - 强制 $v_2 = 0$ 可以通过直接移除 $R_2$ 或移除其唯一的前体 $R_1$ 来实现，因为 $v_1 = v_2$ 意味着移除 $R_1$ 会强制 $v_1 = 0$，进而 $v_2 = 0$。\n\n   这产生了两个不同的最小反应对：\n   - $\\{R_2, R_4\\}$：移除 $R_2$ 强制 $v_2 = 0$，移除 $R_4$ 强制 $v_4 = 0$，因此 $v_3 = 0$。单独的 $\\{R_2\\}$ 或 $\\{R_4\\}$ 都不能阻断 $v_3$，所以这个反应对是最小的。\n   - $\\{R_1, R_4\\}$：移除 $R_1$ 强制 $v_1 = v_2 = 0$，移除 $R_4$ 强制 $v_4 = 0$，因此 $v_3 = 0$。单独的 $\\{R_1\\}$ 或 $\\{R_4\\}$ 都不能阻断 $v_3$，所以这个反应对是最小的。\n\n我们验证不存在其他最小割集：\n- 任何真包含 $R_3$ 的集合，例如 $\\{R_1, R_3\\}$，都不是最小的，因为 $\\{R_3\\}$ 本身就足够了。\n- 反应对 $\\{R_1, R_2\\}$ 不会阻断 $v_3$，因为 $v_4$ 可以直接供应 $C$，使得 $v_3 = v_4 > 0$。\n- 根据定义，不包含任何一个已识别出的最小集的更大集合不是最小的。\n\n通过基本通量模式的等效视角也证实了这一枚举。唯一能使 $v_3 > 0$ 的基本通量模式是通过 $R_1 \\rightarrow R_2 \\rightarrow R_3$ 的路径（其支撑集为 $\\{R_1, R_2, R_3\\}$）和直接路径 $\\{R_4, R_3\\}$。最小割集是这些支撑集的最小命中集，即 $\\{R_3\\}$、$\\{R_1, R_4\\}$ 和 $\\{R_2, R_4\\}$。\n\n因此，禁用目标反应 $R_3$ 的最小割集的总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在理解了基本原理之后，我们可以引入一个更强大、更抽象的理论工具：初级通量模式（Elementary Flux Modes, EFMs）。本练习将揭示功能性代谢途径（EFMs）与干预策略（MCSs）之间的基本对偶关系。你将学习如何通过计算产生目标通量的EFMs的最小命中集（minimal hitting sets）来识别MCSs，这是现代通路分析中的一个核心概念。",
            "id": "3326054",
            "problem": "考虑一个小型稳态代谢网络，其包含内部代谢物 $B$ 和 $C$ 以及四个不可逆反应 $R_1$、$R_2$、$R_3$ 和 $R_4$。设化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 4}$ 按代谢物 $[B,\\,C]^{\\top}$ 和反应 $[R_1,\\,R_2,\\,R_3,\\,R_4]$ 的顺序列出，其元素为\n$$\nS = \\begin{pmatrix}\n+1 & -1 & 0 & 0 \\\\\n0 & +1 & -1 & +1\n\\end{pmatrix}.\n$$\n所有反应均为不可逆反应，通量界限为 $v_i \\ge 0$，$i \\in \\{1,2,3,4\\}$。在稳态下，通量向量 $v \\in \\mathbb{R}^4$ 必须满足 $S\\,v = 0$。关注的目标是通过反应 $R_3$ 的严格正通量，即目标条件为 $v_3 \\ge 1$（由于可行稳态通量的正向缩放，这不失一般性）。\n\n初级通量模式（EFMs）定义为满足 $S\\,v=0$ 和 $v \\ge 0$ 的具有最小支撑集的非零稳态通量向量。假设已确定能实现目标反应 $R_3$ 的 EFM 集合，且该集合恰好由两个支撑集 $E_1 = \\{R_1, R_2, R_3\\}$ 和 $E_2 = \\{R_4, R_3\\}$ 组成，这意味着存在其非零反应集恰好为 $E_1$ 和 $E_2$ 的 EFM。\n\n一种干预策略被建模为敲除一个反应子集。针对该目标的最小割集（MCS）是允许干预集 $K$ 的一个子集 $C$，使得在移除 $C$ 中的所有反应后，不存在满足 $v_3 \\ge 1$ 的可行稳态通量，并且 $C$ 的任何真子集都不具有此性质。对于本问题，允许的干预集排除了目标反应，给定为 $K = \\{R_1, R_2, R_4\\}$。\n\n你的任务是：\n- 仅使用击中集（hitting set）的定义和给定的 EFM $E_1$ 和 $E_2$，枚举出所有与每个实现目标的 EFM 相交的、包含关系下的最小击中集 $C \\subseteq K$。\n- 对每个候选集 $C$，通过求解移除 $C$ 中反应后得到的残余网络的可行性问题来验证其是否为 MCS：确定是否存在 $v \\ge 0$ 满足 $S\\,v = 0$ 和 $v_3 \\ge 1$。同时，通过证明 $C$ 的每个真子集都无法阻断目标来验证其最小性，即当移除较少反应时，存在一个可行的 $v \\ge 0$ 满足 $S\\,v=0$ 和 $v_3 \\ge 1$。\n- 令 $N$ 表示你验证的最小割集的数量。报告 $N$ 的值。\n\n请以单个实数形式提供最终答案。无需单位。如果得到非整数实数，请将答案四舍五入至 $4$ 位有效数字。否则，请报告精确的整数。",
            "solution": "问题要求我们找到给定代谢目标的最小割集（$N$）的数量。目标是维持通过反应 $R_3$ 的通量至少为 $1$，即 $v_3 \\ge 1$。最小割集（MCS）是从允许集合 $K=\\{R_1, R_2, R_4\\}$ 中选出的一个最小反应敲除集，它使得目标无法实现。\n\n代谢途径分析的一个基本原则指出，任何可行的稳态通量分布都可以表示为网络 EFM 的非负线性组合。问题陈述，唯一能够产生目标（即通过 $R_3$ 的通量非零）的 EFM 是支撑集为 $E_1 = \\{R_1, R_2, R_3\\}$ 和 $E_2 = \\{R_4, R_3\\}$ 的那些。要阻断目标，必须且只需灭活所有这些产生目标的 EFM。如果一个 EFM 中至少有一个组成反应被敲除，那么该 EFM 就被灭活了。\n\n因此，一个 MCS 对应于 $K$ 的一个包含关系下的最小子集，该子集与每个产生目标的 EFM都有非空交集。换言之，一个 MCS 是产生目标的 EFM 的一个最小击中集，且限于 $K$ 中可被敲除的反应。\n\n**步骤1：枚举最小击中集**\n\n产生目标的 EFM 集合由其支撑集给出，$\\mathcal{E} = \\{E_1, E_2\\}$，其中 $E_1 = \\{R_1, R_2, R_3\\}$，$E_2 = \\{R_4, R_3\\}$。允许的干预反应集合为 $K = \\{R_1, R_2, R_4\\}$。\n\n割集 $C \\subseteq K$ 必须“击中”$E_1$ 和 $E_2$。这意味着 $C \\cap E_1 \\neq \\emptyset$ 且 $C \\cap E_2 \\neq \\emptyset$。由于 $C$ 必须是 $K$ 的子集，我们关心的是 EFM 中可被敲除的部分：\n$E'_1 = E_1 \\cap K = \\{R_1, R_2, R_3\\} \\cap \\{R_1, R_2, R_4\\} = \\{R_1, R_2\\}$\n$E'_2 = E_2 \\cap K = \\{R_4, R_3\\} \\cap \\{R_1, R_2, R_4\\} = \\{R_4\\}$\n\n我们需要找到集合族 $\\mathcal{F} = \\{E'_1, E'_2\\} = \\{\\{R_1, R_2\\}, \\{R_4\\}\\}$ 的最小击中集。一个击中集必须包含 $\\mathcal{F}$ 中每个集合的至少一个元素。\n\\begin{itemize}\n    \\item 要击中 $\\{R_4\\}$，一个集合必须包含 $R_4$。\n    \\item 要击中 $\\{R_1, R_2\\}$，一个集合必须包含 $R_1$ 或 $R_2$。\n\\end{itemize}\n结合这些条件，一个击中集必须包含 $\\{R_4\\}$ 以及 $\\{R_1\\}$ 或 $\\{R_2\\}$。这产生了两个候选集：\n\\begin{enumerate}\n    \\item $C_1 = \\{R_1, R_4\\}$\n    \\item $C_2 = \\{R_2, R_4\\}$\n\\end{enumerate}\n这些集合是最小的，因为从任一集合中移除任何单个反应都会导致该集合不再同时击中 $E'_1$ 和 $E'_2$。例如，对于 $C_1$，子集 $\\{R_1\\}$ 没有击中 $E'_2$，子集 $\\{R_4\\}$ 没有击中 $E'_1$。类似的论证也适用于 $C_2$。因此，这些是最小击中集。\n\n**步骤2：验证候选集为最小割集**\n\n问题要求明确验证每个候选集都是 MCS。这涉及到为残余网络求解一个可行性问题。控制方程是稳态条件 $S v = 0$ 和非负性约束 $v_i \\ge 0$。\n化学计量方程为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_3 + v_4 = 0 \\implies v_3 = v_2 + v_4$\n\n目标条件为 $v_3 \\ge 1$。\n\n**验证 $C_1 = \\{R_1, R_4\\}$**\n\n\\begin{itemize}\n    \\item **阻断能力**：我们测试当反应 $R_1$ 和 $R_4$ 被敲除时（即 $v_1=0$ 和 $v_4=0$），目标是否可以实现。将这些代入稳态方程：\n    $0 - v_2 = 0 \\implies v_2 = 0$\n    $v_2 - v_3 + 0 = 0 \\implies v_3 = v_2$\n    结合这些，我们得到 $v_3 = 0$。这个结果与目标条件 $v_3 \\ge 1$ 相矛盾。因此，不存在可行的通量，$C_1$ 成功地阻断了目标。\n\n    \\item **最小性**：我们必须证明 $C_1$ 的任何真子集都不能阻断目标。\n    \\begin{itemize}\n        \\item 子集 $\\{R_1\\}$：敲除 $R_1$（$v_1=0$）。系统变为：\n        $0 - v_2 = 0 \\implies v_2=0$\n        $0 - v_3 + v_4 = 0 \\implies v_3=v_4$\n        我们需要找到是否存在一个向量 $v$ 满足这些条件，$v \\ge 0$ 且 $v_3 \\ge 1$。设 $v_3=1$。这意味着 $v_4=1$。通量向量 $v = [0, 0, 1, 1]^\\top$ 是一个有效的稳态通量分布，其中 $v_1=0$。由于 $v_3 = 1 \\ge 1$，目标可以实现。因此，$\\{R_1\\}$ 不是割集。\n\n        \\item 子集 $\\{R_4\\}$：敲除 $R_4$（$v_4=0$）。系统变为：\n        $v_1 - v_2 = 0 \\implies v_1=v_2$\n        $v_2 - v_3 + 0 = 0 \\implies v_3=v_2$\n        我们需要找到是否存在一个向量 $v$ 满足这些条件，$v \\ge 0$ 且 $v_3 \\ge 1$。设 $v_3=1$。这意味着 $v_2=1$ 和 $v_1=1$。通量向量 $v = [1, 1, 1, 0]^\\top$ 是一个有效的稳态通量分布，其中 $v_4=0$。由于 $v_3 = 1 \\ge 1$，目标可以实现。因此，$\\{R_4\\}$ 不是割集。\n    \\end{itemize}\n    由于 $C_1$ 阻断了目标，而其任何真子集都不能，所以 $C_1 = \\{R_1, R_4\\}$ 是一个经过验证的 MCS。\n\\end{itemize}\n\n**验证 $C_2 = \\{R_2, R_4\\}$**\n\n\\begin{itemize}\n    \\item **阻断能力**：我们测试当 $R_2$ 和 $R_4$ 被敲除时（即 $v_2=0$ 和 $v_4=0$），目标是否可以实现。代入稳态方程：\n    $v_1 - 0 = 0 \\implies v_1 = 0$\n    $0 - v_3 + 0 = 0 \\implies v_3 = 0$\n    结果 $v_3=0$ 与目标条件 $v_3 \\ge 1$ 相矛盾。因此，$C_2$ 成功地阻断了目标。\n\n    \\item **最小性**：我们检查 $C_2$ 的真子集。\n    \\begin{itemize}\n        \\item 子集 $\\{R_2\\}$：敲除 $R_2$（$v_2=0$）。系统变为：\n        $v_1 - 0 = 0 \\implies v_1=0$\n        $0 - v_3 + v_4 = 0 \\implies v_3=v_4$\n        与之前子集 $\\{R_1\\}$ 的情况一样，我们可以找到一个实现目标的可行通量向量，例如 $v=[0, 0, 1, 1]^\\top$。因此，$\\{R_2\\}$ 不是割集。\n\n        \\item 子集 $\\{R_4\\}$：敲除 $R_4$（$v_4=0$）。这种情况与为 $C_1$ 分析的情况相同。一个可行的通量向量 $v=[1, 1, 1, 0]^\\top$ 可以实现目标。因此，$\\{R_4\\}$ 不是割集。\n    \\end{itemize}\n    由于 $C_2$ 阻断了目标，而其任何真子集都不能，所以 $C_2 = \\{R_2, R_4\\}$ 也是一个经过验证的 MCS。\n\\end{itemize}\n\n**结论**\n\n我们通过寻找目标 EFM 的最小击中集，确定了两个候选集 $C_1 = \\{R_1, R_4\\}$ 和 $C_2 = \\{R_2, R_4\\}$。我们已严格验证了两个候选集都满足最小割集的定义：它们阻断了目标反应，且它们的任何子集都不能。\n\n因此，最小割集的总数为 $N=2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "理论的最终价值在于其应用。本高级练习将挑战你将寻找最小割集的问题形式化为一个可计算的优化问题，特别是混合整数线性规划（Mixed-Integer Linear Programming, MILP）。通过将生物干预目标转化为严格的数学约束，本练习为你搭建了从理论概念到解决大规模基因组尺度模型问题的桥梁，这是计算系统生物学领域的关键技能。",
            "id": "3326084",
            "problem": "您的任务是使用混合整数线性规划（MILP）为代谢网络严谨地构建一个基于优化的干预策略，然后实现一个计算检查，用于检验指定测试用例的最小割集。目标是找到一个基数最小的反应敲除集，该集合能阻止目标通量达到或超过一个指定的阈值。您的程序必须生成单行输出，其中包含为一组网络测试套件计算出的最小割集。\n\n考虑一个由化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$、通量向量 $v \\in \\mathbb{R}^{n}$、下界 $L \\in \\mathbb{R}^{n}$、上界 $U \\in \\mathbb{R}^{n}$ 和目标反应索引 $t \\in \\{0,1,\\dots,n-1\\}$ 定义的代谢网络。反应 $i$ 的敲除由一个二元变量 $y_i \\in \\{0,1\\}$ 表示，其中 $y_i = 1$ 强制 $v_i = 0$，而 $y_i = 0$ 允许 $v_i$ 在其边界内。稳态质量平衡表示为 $S v = 0$。对于具有非负下界的不可逆反应，敲除下的可用性约束可通过 $v_i \\le U_i(1 - y_i)$ 和 $v_i \\ge L_i(1 - y_i)$ 来施加，适用于所有 $i \\in \\{0,1,\\dots,n-1\\}$。目标可行性要求为 $v_t \\ge \\tau$，其中 $\\tau \\in \\mathbb{R}_{\\ge 0}$ 是一个指定的阈值。\n\n您的推导必须从基本的稳态约束 $S v = 0$ 和边界约束 $L \\le v \\le U$ 开始，为内部的目标达成问题构建一个双层规划，然后利用强对偶性或Farkas引理推导出一个单层混合整数线性规划（MILP）。具体来说，您需要构建一个双层问题，该问题在内部LP试图实现 $v_t \\ge \\tau$ 的约束下，最小化敲除的基数，然后通过用其对偶约束替换内部LP，并进行适当的线性化来处理与二元变量的乘积，从而推导出单层MILP。\n\n您的最终程序必须在给定特定测试套件实例的情况下，计算一个最小基数割集 $C \\subseteq \\mathcal{R}_{\\text{allowed}}$，该割集在 $S v = 0$ 和 $L \\le v \\le U$ 的条件下阻止 $v_t \\ge \\tau$ 的可行性，其中 $\\mathcal{R}_{\\text{allowed}}$ 是符合敲除条件的反应集合。对于每个测试用例，您必须返回字典序最小的最小基数割集，形式为一个基于零的反应索引列表。如果在没有任何敲除的情况下，目标可行性 $v_t \\ge \\tau$ 已经无法实现，则返回空列表 $[\\ ]$。\n\n测试套件：\n- 案例1（具有两条平行路径和非平凡最小割集的理想情况）：\n  - 化学计量矩阵 $$S_1 = \\begin{bmatrix} 1 & -1 & 0 & -1 & 0 \\\\ 0 & 1 & -1 & 0 & 0 \\\\ 0 & 0 & 1 & 1 & -1 \\end{bmatrix}$$。\n  - 下界 $L_1 = [0, 0, 0, 0, 0]$。\n  - 上界 $U_1 = [10, 10, 10, 10, 100]$。\n  - 目标索引 $t_1 = 4$。\n  - 阈值 $\\tau_1 = 5$。\n  - 允许的干预措施 $\\mathcal{R}_{\\text{allowed},1} = \\{1, 2, 3\\}$。\n- 案例2（即使没有干预，目标阈值也无法达到的边界条件）：\n  - 化学计量矩阵 $S_2 = S_1$。\n  - 下界 $L_2 = L_1$。\n  - 上界 $U_2 = [3, 10, 10, 10, 100]$。\n  - 目标索引 $t_2 = 4$。\n  - 阈值 $\\tau_2 = 5$。\n  - 允许的干预措施 $\\mathcal{R}_{\\text{allowed},2} = \\{1, 2, 3\\}$。\n- 案例3（单个敲除即可满足条件的单路径网络）：\n  - 化学计量矩阵 $$S_3 = \\begin{bmatrix} 1 & -1 & 0 \\\\ 0 & 1 & -1 \\end{bmatrix}$$。\n  - 下界 $L_3 = [0, 0, 0]$。\n  - 上界 $U_3 = [10, 10, 100]$。\n  - 目标索引 $t_3 = 2$。\n  - 阈值 $\\tau_3 = 6$。\n  - 允许的干预措施 $\\mathcal{R}_{\\text{allowed},3} = \\{1\\}$。\n\n要求输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果是对应测试用例的字典序最小的最小基数割集列表。例如，如果最小割集分别为 $[1,3]$、$[\\ ]$ 和 $[1]$，则输出必须是单行 `[[1,3],[],[1]]`。\n\n假设与约束：\n- 测试套件中的所有反应都是不可逆的，且具有非负下界，因此对所有 $i$ 都有 $L_i \\ge 0$。\n- 反应索引是基于零的。\n- 通量无需物理单位；将所有通量边界和阈值视为无量纲实数。\n- 实现必须通过求解一个零目标LP来计算每个敲除子集的 $v_t \\ge \\tau$ 的可行性，该LP的约束条件为 $S v = 0$、$L \\le v \\le U$、对被敲除的 $i$ 有 $v_i = 0$，以及 $v_t \\ge \\tau$；然后通过增加子集大小来搜索最小基数的阻断集。为提高性能，请按每个案例的规定将搜索限制在 $\\mathcal{R}_{\\text{allowed}}$ 内。",
            "solution": "该问题要求构建一种优化策略，以识别一个最小的反应敲除集，该集合能使代谢网络无法实现目标通量；随后通过计算实现来解决特定的测试案例。在进入计算方法之前，我们首先对控制性的数学框架进行严谨的推导。\n\n### I. 问题构建：双层优化\n\n问题的核心是找到一个基数最小的干预（反应敲除）集，以确保一个代谢目标的失败。这天然地可以构建成一个双层优化问题。\n\n设代谢网络由一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$ 定义，其中 $m$ 是代谢物数量， $n$ 是反应数量。向量 $v \\in \\mathbb{R}^{n}$ 代表通过这些反应的通量。在稳态下，质量平衡方程为：\n$$S v = 0$$\n通量分别受到下界 $L \\in \\mathbb{R}^{n}$ 和上界 $U \\in \\mathbb{R}^{n}$ 的约束：\n$$L \\le v \\le U$$\n对反应 $i$ 的干预通过一个二元变量 $y_i \\in \\{0, 1\\}$ 来建模。如果 $y_i=1$，反应 $i$ 被敲除，其通量 $v_i$ 被强制为0。如果 $y_i=0$，该反应在其原始边界内运行。对于 $L_i \\ge 0$ 的不可逆反应，这可以通过修改边界来体现：\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i)$$\n问题的目标是使目标产物的生产（由通过反应 $t$ 的通量 $v_t$ 表示）在达到或超过阈值 $\\tau \\ge 0$ 时变得不可行。也就是说，我们寻求一个干预向量 $y$，使得以下约束系统对于 $v$ 没有解。\n$$S v = 0$$\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i) \\quad \\forall i \\in \\{0, \\dots, n-1\\}$$\n$$v_t \\ge \\tau$$\n\n**外层问题**旨在最小化敲除数量，且敲除范围限制在允许的反应集 $\\mathcal{R}_{\\text{allowed}}$ 内。目标函数为 $\\sum_{i \\in \\mathcal{R}_{\\text{allowed}}} y_i$。\n\n**内层问题**检查对于给定的 $y$，目标是否可以实现。一种常见的形式化方法是最大化目标通量 $v_t$，并检查其最大可能值 $v_t^*(y)$ 是否小于 $\\tau$。\n$$v_t^*(y) = \\max_{v} \\quad v_t$$\n约束条件为：\n$$S v = 0$$\n$$L_i(1-y_i) \\le v_i \\le U_i(1-y_i) \\quad \\forall i$$\n\n因此，完整的双层规划公式为：\n$$\\min_{y} \\quad \\sum_{i \\in \\mathcal{R}_{\\text{allowed}}} y_i$$\n约束条件为：\n$$v_t^*(y)  \\tau$$\n$$y_i \\in \\{0, 1\\} \\quad \\forall i \\in \\mathcal{R}_{\\text{allowed}}$$\n$$y_i = 0 \\quad \\forall i \\notin \\mathcal{R}_{\\text{allowed}}$$\n\n### II. 使用对偶性的单层MILP重构\n\n双层结构在计算上是难解的。我们可以利用对偶性原理，特别是Farkas引理，将其重构为一个单层混合整数线性规划（MILP）。\n\n一组线性约束 $Ax \\le b$ 是不可行的，当且仅当存在一个向量 $z \\ge 0$ 使得 $z^T A = 0$ 和 $z^T b  0$。该向量 $z$ 被称为Farkas不可行性证书。\n\n我们将其应用于我们希望对任何 $v$ 的选择都变得不可行的约束系统：\n1. $S v = 0$ (等价于 $S v \\le 0$ 和 $-S v \\le 0$)\n2. $v \\le U(1-y)$\n3. $-v \\le -L(1-y)$\n4. $v_t \\ge \\tau$ (等价于 $-e_t^T v \\le -\\tau$，其中 $e_t$ 是在索引 $t$ 处为1的标准基向量)\n\n让我们引入对偶变量（Farkas证书 $z$ 的分量）：\n- $\\lambda_1 \\ge 0$ 对应 $S v \\le 0$\n- $\\lambda_2 \\ge 0$ 对应 $-S v \\le 0$\n- $\\mu_i \\ge 0$ 对应 $v_i \\le U_i(1-y_i)$\n- $\\nu_i \\ge 0$ 对应 $-v_i \\le -L_i(1-y_i)$\n- $\\gamma \\ge 0$ 对应 $-v_t \\le -\\tau$\n\n条件 $z^T A = 0$ 转化为对偶约束。对于每个原始变量 $v_j$，约束中系数的加权（权重为对偶变量）和必须为零：\n$$(S^T)_j \\lambda_1 - (S^T)_j \\lambda_2 + \\mu_j - \\nu_j - \\gamma (e_t)_j = 0 \\quad \\forall j \\in \\{0, \\dots, n-1\\}$$\n令 $\\lambda = \\lambda_1 - \\lambda_2$（现在是一个自由变量），上式简化为：\n$$S^T \\lambda + \\mu - \\nu - \\gamma e_t = 0$$\n\n条件 $z^T b  0$ 转化为：\n$$\\sum_i \\mu_i U_i (1-y_i) - \\sum_i \\nu_i L_i (1-y_i) - \\gamma \\tau  0$$\n这是一个严格不等式，在求解器中通常通过引入一个小的正常数 $\\epsilon$ 来实现：\n$$\\sum_i \\mu_i U_i (1-y_i) - \\sum_i \\nu_i L_i (1-y_i) - \\gamma \\tau \\le -\\epsilon$$\n\n这个不等式包含形如 $\\mu_i y_i$ 和 $\\nu_i y_i$ 的双线性项。这些项必须被线性化。对于一个像 $w_i = \\mu_i y_i$ 这样的项，其中 $\\mu_i \\ge 0$ 且 $y_i \\in \\{0,1\\}$，我们可以用一个新的变量 $w_i$ 替换它，并使用一个足够大的常数 $M$ 添加以下线性约束：\n$$w_i \\le M y_i$$\n$$w_i \\le \\mu_i$$\n$$w_i \\ge \\mu_i - M(1 - y_i)$$\n$$w_i \\ge 0$$\n对于涉及 $\\nu_i$ 的乘积，也添加类似的约束。\n\n完整的单层MILP问题是找到一组干预 $y$ 和一个相应的Farkas证书 $(\\lambda, \\mu, \\nu, \\gamma)$，它们满足这些约束，同时最小化 $y$ 的基数。\n\n### III. 通过组合搜索的算法实现\n\n虽然MILP公式通用且强大，但问题陈述指导我们对给定的小规模测试用例采用一种特定的、更直接的组合搜索策略。该方法按大小递增的顺序遍历所有可能的敲除集。\n\n算法流程如下：\n1.  初始化敲除集大小 $k=0$。\n2.  从允许的集合 $\\mathcal{R}_{\\text{allowed}}$ 中生成所有大小为 $k$ 的唯一反应组合 $C$。\n3.  这些组合自然按字典序生成，这满足了打破平局的要求。\n4.  对于每个组合 $C$：\n    a.  构建一个线性规划（LP）来测试目标通量是否仍然可以实现。这是一个可行性问题：找到 $v$ 使得\n        -   $S v = 0$\n        -   $L_i \\le v_i \\le U_i$ 对于 $i \\notin C$\n        -   $v_i = 0$ 对于 $i \\in C$\n        -   $v_t \\ge \\tau$\n    b.  求解此LP。我们可以使用一个零目标函数，因为我们只关心可行性。\n    c.  如果LP被发现是不可行的，这意味着集合 $C$ 是一个有效的割集。由于我们从 $k=0$ 开始迭代，并按字典序处理子集，这个 $C$ 就是字典序最小的最小基数割集。搜索终止并返回 $C$。\n5.  如果所有大小为 $k$ 的组合都经过测试，并且都未起到阻断作用（即LP是可行的），则将 $k$ 增加到 $k+1$ 并从步骤2重复。\n6.  过程从 $k=0$ 开始，测试空集 $C=[]$。如果在没有任何敲除的情况下目标就无法实现，则初始LP将是不可行的，并正确地返回空集作为结果。\n\n该过程保证能找到所需的最小割集。在实现中，我们使用 `scipy.optimize.linprog` 来求解可行性LP。该求解器的不可行状态表明已识别出一个有效的割集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef find_minimal_cut_set(S, L, U, t, tau, R_allowed):\n    \"\"\"\n    Finds the lexicographically smallest minimum-cardinality cut set.\n\n    This function iterates through knockout set sizes k = 0, 1, 2, ...\n    For each size, it checks all combinations of reactions from R_allowed.\n    For each combination (cut_set), it solves a feasibility LP to check\n    if the target flux is blocked. The first cut set found is guaranteed\n    to be minimal in cardinality and lexicographically first.\n    \"\"\"\n    S = np.array(S, dtype=float)\n    L = np.array(L, dtype=float)\n    U = np.array(U, dtype=float)\n    num_reactions = S.shape[1]\n\n    # Objective function is zero, we only care about feasibility.\n    c = np.zeros(num_reactions)\n\n    # Equality constraints S*v = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n\n    R_allowed = sorted(list(R_allowed))\n\n    for k in range(len(R_allowed) + 1):\n        for cut_set in itertools.combinations(R_allowed, k):\n            # Create bounds for the current LP\n            # Default bounds are (L_i, U_i)\n            current_bounds = list(zip(L, U))\n\n            # Apply target constraint: v_t >= tau\n            # This means the lower bound of v_t is max(L_t, tau)\n            current_bounds[t] = (max(L[t], tau), U[t])\n            \n            # Apply knockouts: v_i = 0 for i in cut_set\n            for i in cut_set:\n                current_bounds[i] = (0.0, 0.0)\n            \n            # Solve the feasibility LP\n            # method 'highs' is robust and is the default in recent SciPy\n            res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=current_bounds, method='highs')\n            \n            # linprog status 2 means the problem is infeasible.\n            # This means the cut_set is effective in blocking the target flux.\n            if res.status == 2:\n                return list(cut_set)\n    \n    # This part should not be reached if a solution always exists\n    return None\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for finding minimal cut sets.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": [[1, -1, 0, -1, 0], \n                  [0, 1, -1, 0, 0], \n                  [0, 0, 1, 1, -1]],\n            \"L\": [0, 0, 0, 0, 0],\n            \"U\": [10, 10, 10, 10, 100],\n            \"t\": 4,\n            \"tau\": 5,\n            \"R_allowed\": {1, 2, 3}\n        },\n        {\n            \"S\": [[1, -1, 0, -1, 0], \n                  [0, 1, -1, 0, 0], \n                  [0, 0, 1, 1, -1]],\n            \"L\": [0, 0, 0, 0, 0],\n            \"U\": [3, 10, 10, 10, 100],\n            \"t\": 4,\n            \"tau\": 5,\n            \"R_allowed\": {1, 2, 3}\n        },\n        {\n            \"S\": [[1, -1, 0], \n                  [0, 1, -1]],\n            \"L\": [0, 0, 0],\n            \"U\": [10, 10, 100],\n            \"t\": 2,\n            \"tau\": 6,\n            \"R_allowed\": {1}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_minimal_cut_set(\n            case[\"S\"], case[\"L\"], case[\"U\"], case[\"t\"], case[\"tau\"], case[\"R_allowed\"]\n        )\n        results.append(result)\n\n    # Format the output string to be exactly as specified, e.g., [[1,3],[],[1]]\n    output_parts = [str(res).replace(\" \", \"\") for res in results]\n    final_output = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}