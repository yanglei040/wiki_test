{
    "hands_on_practices": [
        {
            "introduction": "轨迹推断的首要任务通常是从高维数据中辨别出生物过程的潜在结构或“骨架”。本练习模拟了构建“谱系骨干”的核心流程，即从代表细胞状态的点云数据开始，构建一个k-近邻图来捕捉细胞间的局部关系，然后利用最小生成树（MST）来寻找最可能的全局轨迹结构。通过这个过程，你将亲身体验构成许多主流轨迹推断工具基础的图算法，并建立起如何将连续过程离散化为图并推断其拓扑结构的直观理解 。",
            "id": "3356218",
            "problem": "给定二维欧几里得空间中的小型点云，这些点云旨在表示具有底层谱系拓扑的简化单细胞状态流形。您必须根据这些点构建一个对称联合$k$-最近邻（$k$-NN）图，计算一个以欧几里得距离为边权重的最小生成树（MST），使用节点度和介数中心性识别分支点，并提供一个从第一性原理推导出的拓扑分类。您的程序必须从图、最短路径、生成树和中心性的基本定义开始实现以下内容，不依赖于除通用稀疏线性代数之外的任何专用图库。\n\n定义与要求：\n- 令 $X \\in \\mathbb{R}^{n \\times d}$ 表示 $d$ 维欧几里得空间中 $n$ 个点的坐标，其中 $d = 2$。对于每个数据集：\n  - 对所有 $i,j \\in \\{0,\\dots,n-1\\}$，计算成对欧几里得距离 $d_{ij} = \\lVert x_i - x_j \\rVert_2$。\n  - 构建一个对称联合$k$-NN图 $G = (V,E)$，其中 $V = \\{0,\\dots,n-1\\}$，加权邻接矩阵为 $W \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$，具体方法如下：对于每个节点 $i$，找到其 $k$ 个最近邻（不包括 $i$ 本身）的索引集合 $N_k(i)$。如果 $i \\in N_k(j)$ 或 $j \\in N_k(i)$，则包含一条无向边 $\\{i,j\\}$，并为这类边设置 $W_{ij} = W_{ji} = d_{ij}$，否则设置 $W_{ij} = 0$。\n  - 在 $G$ 上计算一个最小生成树 $T$，该树最小化总权重 $\\sum_{\\{i,j\\} \\in T} W_{ij}$，并要求 $T$ 是在由 $G$ 导出的连通图上的生成树。\n  - 计算 MST $T$ 中每个节点 $v$ 的度 $\\deg_T(v)$。\n  - 计算 MST $T$ 中每个节点 $v$ 的（未归一化）介数中心性 $C_B(v)$，其定义为\n    $$C_B(v) = \\sum_{\\substack{s \\ne v \\ne t \\\\ s \\ne t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}},$$\n    其中 $\\sigma_{st}$ 是 $s$ 和 $t$ 之间最短路径的数量，$\\sigma_{st}(v)$ 是这些路径中经过 $v$ 的数量。对于一个边权重严格为正的树，任意两个不同节点 $s$ 和 $t$ 之间存在唯一的简单路径，因此 $\\sigma_{st} = 1$，该总和计算的是其唯一路径经过 $v$ 的无序对的数量。\n  - 识别分支点集合\n    $$B = \\left\\{ v \\in V \\;:\\; \\deg_T(v) \\ge 3 \\;\\wedge\\; C_B(v) \\ge \\overline{C_B} \\right\\},$$\n    其中 $\\overline{C_B}$ 是 $T$ 中所有节点的 $C_B$ 值的算术平均值。\n  - 定义一个拓扑分类代码 $c$ 如下：\n    - 如果没有分支，即 $\\max_v \\deg_T(v) \\le 2$（线性轨迹），则 $c = 0$。\n    - 如果只有一个分支事件，且恰好有一个分支点，并且 $\\max_v \\deg_T(v) = 3$（单个类分叉拓扑），则 $c = 1$。\n    - 否则（多分叉或多个分支事件），则 $c = 2$。\n\n您的程序必须对下面的测试套件中的每个数据集执行上述过程，并产生汇总结果。\n\n测试套件：\n对于每个案例，您将得到一个点集 $X$ 和一个邻域大小 $k$。点以有序对及其从零开始的索引形式列出。请完全按照指定的坐标使用。\n\n- 案例 1（预期的单分叉）：\n  - $k = 2$。\n  - 点 $X \\subset \\mathbb{R}^2$ 及其索引：\n    - $0$: $(0,-2)$,\n    - $1$: $(0,-1)$,\n    - $2$: $(0,0)$,\n    - $3$: $(1,1)$,\n    - $4$: $(2,2)$,\n    - $5$: $(3,3)$,\n    - $6$: $(-1,1)$,\n    - $7$: $(-2,2)$,\n    - $8$: $(-3,3)$。\n\n- 案例 2（预期的线性轨迹）：\n  - $k = 2$。\n  - 点 $X \\subset \\mathbb{R}^2$ 及其索引：\n    - $0$: $(0,0)$,\n    - $1$: $(1,0)$,\n    - $2$: $(2,0)$,\n    - $3$: $(3,0)$,\n    - $4$: $(4,0)$。\n\n- 案例 3（预期的从原点出发的三个分支的单分支结构）：\n  - $k = 2$。\n  - 点 $X \\subset \\mathbb{R}^2$ 及其索引：\n    - $0$: $(0,0)$,\n    - $1$: $(1,0)$,\n    - $2$: $(2,0)$,\n    - $3$: $(3,0)$,\n    - $4$: $(-0.5,0.866)$,\n    - $5$: $(-1,1.732)$,\n    - $6$: $(-1.5,2.598)$,\n    - $7$: $(-0.5,-0.866)$,\n    - $8$: $(-1,-1.732)$,\n    - $9$: $(-1.5,-2.598)$。\n\n每个案例所需的最终输出：\n- 一个包含四个元素的列表 $[b, m, c, I]$，其中：\n  - $b$ 是已识别分支点的数量 $|B|$（一个整数）。\n  - $m$ 是最大度 $\\max_v \\deg_T(v)$（一个整数）。\n  - $c$ 是如上定义的分类代码（一个整数）。\n  - $I$ 是已识别分支点 $B$ 的从零开始的索引的排序列表。\n\n程序的最终输出格式：\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个由方括号括起来的逗号分隔列表，不含空格。每个案例的结果是如上所述的四元素列表。例如，输出格式必须完全像\n  $$[[b_1,m_1,c_1,[i_{1,1},\\dots]],[b_2,m_2,c_2,[i_{2,1},\\dots]],[b_3,m_3,c_3,[i_{3,1},\\dots}]]$$\n打印的行中不含任何空白字符。\n\n此问题不要求任何物理单位、角度单位或百分比。",
            "solution": "用户提供了一个单细胞轨迹推断领域的计算问题。我将首先验证问题陈述，然后提供一个遵循指定约束的完整解决方案。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n- **输入数据**：点集 $X \\in \\mathbb{R}^{n \\times 2}$ 和一个整数 $k$。\n- **流程**：\n    1.  **距离矩阵**：计算成对欧几里得距离 $d_{ij} = \\lVert x_i - x_j \\rVert_2$。\n    2.  **对称k-NN图**：构建一个图 $G=(V, E)$，其边权重为 $W_{ij} = d_{ij}$。如果节点 $i$ 在节点 $j$ 的 $k$ 个最近邻集合 $N_k(j)$ 中，或者 $j \\in N_k(i)$，则存在一条无向边 $\\{i,j\\}$。\n    3.  **最小生成树 (MST)**：在图 $G$ 上计算一个 MST（表示为 $T$）。\n    4.  **节点度**：计算 MST 中每个节点 $v$ 的度 $\\deg_T(v)$。\n    5.  **介数中心性**：计算 $T$ 中每个节点 $v$ 的未归一化介数中心性 $C_B(v) = \\sum_{s \\ne v \\ne t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$。在树中，这会计算唯一路径经过 $v$ 的节点对 $(s,t)$ 的数量。\n    6.  **分支点识别**：一个节点 $v$ 是一个分支点，如果它属于集合 $B = \\{ v \\in V \\mid \\deg_T(v) \\ge 3 \\wedge C_B(v) \\ge \\overline{C_B} \\}$，其中 $\\overline{C_B}$ 是所有 $C_B(v)$ 值的平均值。\n    7.  **拓扑分类**：根据以下规则分配一个代码 $c$：\n        - 如果 $\\max_v \\deg_T(v) \\le 2$，则 $c = 0$。\n        - 如果 $|B| = 1$ 且 $\\max_v \\deg_T(v) = 3$，则 $c = 1$。\n        - 否则为 $c = 2$。\n- **测试用例**：提供了三个不同的数据集，每个都有一个点集 $X$ 和一个 $k$ 值。\n- **输出格式**：对于每个案例，生成一个列表 $[b, m, c, I]$，其中 $b=|B|$，$m=\\max_v \\deg_T(v)$，$c$ 是分类代码，$I$ 是分支点索引的排序列表。最终输出必须是一行包含结果列表的字符串，不含空格。\n\n**第2步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题在计算系统生物学领域有坚实的基础，特别反映了单细胞数据轨迹推断的常见程序。所使用的方法（k-NN图、MST、中心性）是像 Monocle 和 TSCAN 这样的算法中的标准方法。该问题具有科学有效性和相关性。\n- **适定性**：问题以数学精度进行了规定。所有术语，如“对称联合k-NN图”、“MST”、“介数中心性”，以及“分支点”和“拓扑分类”的标准都得到了明确的定义。给定输入，该过程是确定性的，并将产生一个唯一的、有意义的解决方案。\n- **客观性**：问题陈述是形式化和定量的，不含任何主观或基于意见的语言。\n- **完整性与一致性**：提供了所有必要的数据（点坐标，$k$）和定义。定义在逻辑上是一致的，分类方案是详尽的。问题是自包含的。\n- **可行性**：数据集很小，计算量在标准数值库的能力范围之内，即使是按要求从头开始实现核心算法。该设置是生物状态流形的一个简化但现实的表示。\n\n**第3步：结论与行动**\n\n- **结论**：问题是**有效的**。\n- **行动**：我现在将着手提供一个完整的解决方案。\n\n### 解决方案\n\n解决方案将作为一个Python程序实现，该程序根据指定的流程处理每个测试用例。核心算法——用于MST的Kruskal算法和树上的中心性计算——将按要求从第一性原理实现。\n\n**1. 成对距离计算**\n对于给定的 $X \\in \\mathbb{R}^{n \\times 2}$ 中的一组 $n$ 个点，我们首先计算对称的 $n \\times n$ 成对欧几里得距离矩阵 $D$，其中 $D_{ij} = \\lVert x_i - x_j \\rVert_2$。\n\n**2. 对称联合k-NN图构建**\n我们初始化一个 $n \\times n$ 的邻接矩阵 $W$ 并填零。对于每个点 $i$，我们通过对 $D$ 的第 $i$ 行中的距离进行排序来确定其 $k$ 个最近邻的索引。设 $N_k(i)$ 为这个索引集合（不包括 $i$ 本身）。对称联合规则指出，如果 $i \\in N_k(j)$ 或 $j \\in N_k(i)$，则存在一条边 $\\{i,j\\}$。这可以通过遍历所有点 $i$，找到它们的邻居 $N_k(i)$，并对每个 $j \\in N_k(i)$，将 $W_{ij}$ 和 $W_{ji}$ 都设置为距离 $D_{ij}$ 来实现。此过程正确地形成了联合。\n\n**3. 最小生成树（MST）计算**\n我们使用Kruskal算法来找到由 $W$ 表示的图的MST。\n- 首先，我们创建一个包含所有权重 $W_{ij} > 0$ 的唯一边 $\\{i,j\\}$ 及其权重的列表。\n- 我们按权重的非递减顺序对此边列表进行排序。\n- 我们使用一个不相交集联合（DSU）或并查集数据结构，为每个节点初始化 $n$ 个集合。\n- 我们遍历排序后的边。对于每条权重为 $w$ 的边 $(u,v)$，如果包含 $u$ 和 $v$ 的集合的领导者（通过 `find(u)` 和 `find(v)` 找到）不同，我们将该边添加到我们的MST中，并使用 `union(u,v)` 合并这两个集合。\n- 一旦我们累积了 $n-1$ 条边，就停止，这完成了生成树。生成的MST存储为邻接表以便高效遍历。\n\n**4. 度和介数中心性计算**\n- **度**：MST中节点 $v$ 的度 $\\deg_T(v)$ 就是连接到它的边的数量，也就是其在邻接表中的条目长度。最大度 $m$ 是通过取所有节点的最大值来找到的。\n- **介数中心性**：对于一棵树，节点 $v$ 的中心性 $C_B(v)$ 是指从 $s$ 到 $t$ 的唯一简单路径经过 $v$ 的其他节点对 $(s,t)$ 的数量。这可以高效计算。移除节点 $v$ 会将MST分裂成 $\\deg_T(v)$ 个连通分量（子树）。设这些分量的大小为 $s_1, s_2, \\dots, s_{\\deg_T(v)}$。任何从分量 $i$ 中的节点到分量 $j$ 中的节点（其中 $i \\ne j$）的路径都必须经过 $v$。此类路径的数量是分量大小成对乘积的总和：\n$$ C_B(v) = \\sum_{1 \\le i  j \\le \\deg_T(v)} s_i s_j $$\n为了实现这一点，我们首先任意地将树定根（例如，在节点0处）。我们执行一次图遍历（例如，广度优先搜索或深度优先搜索）来确定父子关系，然后进行后序遍历来计算以每个节点为根的子树的大小。有了子树的大小，就可以确定移除任何节点 $v$ 后的分量大小，从而可以计算 $C_B(v)$。\n\n**5. 分支点识别与拓扑分类**\n- 我们计算所有中心性值的算术平均值 $\\overline{C_B}$。\n- 我们通过选择所有同时满足 $\\deg_T(v) \\ge 3$ 和 $C_B(v) \\ge \\overline{C_B}$ 的节点 $v$ 来识别分支点集合 $B$。我们计算分支点的数量 $b = |B|$，并创建一个它们的索引的排序列表 $I$。\n- 最后，我们应用提供的分类规则：\n    - 如果最大度 $m \\le 2$，则拓扑是线性的 ($c=0$)。\n    - 如果恰好有一个分支点 ($b = 1$) 并且最大度恰好是 $3$ ($m = 3$)，则拓扑是单分叉 ($c=1$)。\n    - 在所有其他情况下（例如，多个分支点，或度大于3的分支点），拓扑被分类为复杂 ($c=2$)。\n\n这整个过程被封装在一个函数中，对每个测试用例调用该函数，然后将结果汇总并以指定格式打印。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# Increase recursion limit for deep DFS traversals, a good practice for graph algorithms.\nsys.setrecursionlimit(2000)\n\nclass DSU:\n    \"\"\"Disjoint Set Union (Union-Find) data structure for Kruskal's algorithm.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.num_sets = n\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            self.num_sets -= 1\n            return True\n        return False\n\ndef process_case(X, k):\n    \"\"\"\n    Processes a single point cloud to determine its lineage topology.\n    \"\"\"\n    n = X.shape[0]\n\n    # 1. Compute pairwise Euclidean distance matrix\n    # Using broadcasting for efficiency.\n    diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n    dist_matrix = np.linalg.norm(diff, axis=-1)\n\n    # 2. Construct symmetric union k-NN graph\n    adj_matrix = np.zeros((n, n))\n    for i in range(n):\n        # np.argsort is stable, which aids reproducibility in case of distance ties.\n        # We take indices [1:k+1] to exclude the point itself (distance 0).\n        neighbors = np.argsort(dist_matrix[i, :])[1:k + 1]\n        for j in neighbors:\n            # Symmetric union: add edge if i is neighbor of j or j is neighbor of i.\n            # This implementation correctly builds the union.\n            adj_matrix[i, j] = dist_matrix[i, j]\n            adj_matrix[j, i] = dist_matrix[j, i]\n\n    # 3. Compute Minimum Spanning Tree (MST) using Kruskal's algorithm\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if adj_matrix[i, j] > 0:\n                edges.append((adj_matrix[i, j], i, j))\n    \n    edges.sort()\n\n    dsu = DSU(n)\n    mst_adj = {i: [] for i in range(n)}\n    mst_edges_count = 0\n    for weight, u, v in edges:\n        if dsu.union(u, v):\n            mst_adj[u].append(v)\n            mst_adj[v].append(u)\n            mst_edges_count += 1\n            if mst_edges_count == n - 1:\n                break\n    \n    # 4. Compute MST node degrees\n    degrees = np.array([len(mst_adj[i]) for i in range(n)])\n\n    # 5. Compute betweenness centrality for each node in the MST\n    centrality = np.zeros(n)\n    \n    # Handle the case of an empty or single-node graph\n    if n = 1:\n        return [0, 0 if n == 0 else degrees[0], 0, []]\n\n    # Root the tree arbitrarily at node 0 for traversal\n    root = 0\n    parent = {i: None for i in range(n)}\n    children = {i: [] for i in range(n)}\n    \n    # Build parent/child relationships using BFS\n    q = [root]\n    visited = {root}\n    head = 0\n    while head  len(q):\n        u = q[head]\n        head += 1\n        for v in mst_adj[u]:\n            if v not in visited:\n                visited.add(v)\n                parent[v] = u\n                children[u].append(v)\n                q.append(v)\n\n    # Compute subtree sizes using a post-order traversal\n    subtree_size = {}\n    nodes_post_order = []\n    visited_post = set()\n    \n    def build_post_order(u):\n        visited_post.add(u)\n        for v_child in children[u]:\n            if v_child not in visited_post:\n                build_post_order(v_child)\n        nodes_post_order.append(u)\n    \n    if root not in visited_post:\n      build_post_order(root)\n\n    for u in nodes_post_order:\n        size = 1 + sum(subtree_size[v_child] for v_child in children[u])\n        subtree_size[u] = size\n\n    # Compute centrality based on component sizes\n    for v in range(n):\n        if degrees[v] = 1:\n            centrality[v] = 0\n            continue\n        \n        component_sizes = []\n        for child in children[v]:\n            component_sizes.append(subtree_size[child])\n        if parent[v] is not None:\n            component_sizes.append(n - subtree_size[v])\n        \n        # Centrality is the sum of products of component sizes taken pairwise\n        cb_v = 0\n        total_sum = sum(component_sizes)\n        sum_of_squares = sum(s**2 for s in component_sizes)\n        cb_v = (total_sum**2 - sum_of_squares) / 2\n        centrality[v] = cb_v\n        \n    # 6. Identify branchpoints\n    mean_centrality = np.mean(centrality)\n    branchpoint_indices = []\n    for v in range(n):\n        if degrees[v] >= 3 and centrality[v] >= mean_centrality:\n            branchpoint_indices.append(v)\n    \n    b = len(branchpoint_indices)\n    I = sorted(branchpoint_indices)\n    \n    # 7. Classify topology\n    m = int(np.max(degrees)) if n > 0 else 0\n    \n    c = 0\n    if m = 2:\n        c = 0\n    elif b == 1 and m == 3:\n        c = 1\n    else:\n        c = 2\n        \n    return [b, m, c, I]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        (\n            2, # k\n            np.array([\n                [0,-2], [0,-1], [0,0], [1,1], [2,2], [3,3], [-1,1], [-2,2], [-3,3]\n            ])\n        ),\n        (\n            2, # k\n            np.array([\n                [0,0], [1,0], [2,0], [3,0], [4,0]\n            ])\n        ),\n        (\n            2, # k\n            np.array([\n                [0,0], [1,0], [2,0], [3,0], \n                [-0.5,0.866], [-1,1.732], [-1.5,2.598],\n                [-0.5,-0.866], [-1,-1.732], [-1.5,-2.598]\n            ])\n        ),\n    ]\n\n    results = []\n    for k, X in test_cases:\n        result = process_case(X, k)\n        results.append(result)\n\n    # Format the final output string precisely as required, with no spaces.\n    results_str = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在构建了代表细胞状态流形的图之后，我们需要一种系统性的方法来沿着轨迹对细胞进行排序，这个排序即为伪时间。本练习探讨了一种基于马尔可夫链理论的伪时间形式化定义，通过将细胞间的转换建模为随机游走，到达“根”或祖先状态的期望时间为衡量发育进程提供了一个稳健的指标。通过推导并求解期望触时（expected hitting times）的基本方程，你将把抽象的图论与关于细胞发育进程的具体量化预测联系起来 。",
            "id": "3356213",
            "problem": "在单细胞转录组学的轨迹推断中，一种伪时间的形式化方法是，将每个细胞赋值为一个期望值，该期望值是在细胞-细胞图上随机游走首次到达指定祖细胞（根）状态所需的步数。考虑一个有限、时间齐次的马尔可夫链 (MC)，其状态空间被划分为一个瞬时集 $\\mathcal{T}$ 和一个吸收根 $\\mathcal{R}$。设其典范分块形式的转移矩阵为\n$$\nP \\;=\\; \\begin{pmatrix}\nQ  S \\\\\n0  I\n\\end{pmatrix},\n$$\n其中 $Q$ 是瞬时态到瞬时态的子矩阵，$S$ 是瞬时态到吸收态的子矩阵，$0$ 是一个零矩阵，$I$ 是吸收类（这里是单个根状态）上的单位矩阵。对于每个瞬时态 $i \\in \\mathcal{T}$，定义到达根 $\\mathcal{R}$ 的首達时间为 $\\tau \\equiv \\inf\\{t \\geq 0 : X_t \\in \\mathcal{R}\\}$，期望首達时间为 $h_i \\equiv \\mathbb{E}_i[\\tau]$。在 $\\mathcal{T}$ 上的向量 $\\mathbf{h}$ 给出了一个伪时间，它在根处为零，并随着到达吸收态的期望步数严格增加。\n\n任务A（推导）：仅从马尔可夫性质和全期望定律出发，推导瞬时态所满足的、用 $Q$ 表示的关于 $\\mathbf{h}$ 的线性方程组，不假设任何已有的公式。\n\n任务B（在简单链上的计算）：考虑一个简单的谱系链，其瞬时态为 $\\{S_1,S_2,S_3\\}$，吸收根为 $R$，排序为 $(S_1,S_2,S_3,R)$。转移概率为\n$$\nP \\;=\\; \\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  0  \\frac{1}{2} \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4}  0 \\\\\n0  \\frac{1}{2}  \\frac{1}{2}  0 \\\\\n0  0  0  1\n\\end{pmatrix}.\n$$\n精确计算瞬时态的期望首達时间向量 $\\mathbf{h} = (h_{S_1}, h_{S_2}, h_{S_3})$。使用 $\\LaTeX$ 的 $\\verb|pmatrix|$ 将你的最终答案表示为包含精确有理数的单个行向量。不需要四舍五入，也不涉及单位。",
            "solution": "该问题利用吸收马尔可夫链理论，提出了单细胞转录组学中伪时间的一种形式化方法。它分为两部分：期望首達时间方程组的理论推导，以及针对一个给定的小系统的具体计算。该问题提法明確、科学上合理，并包含唯一解所需的所有信息。\n\n任务A：期望首達时间线性方程组的推导。\n\n设时间齐次马尔可夫链的状态空间被划分为瞬时态集 $\\mathcal{T}$ 和吸收态集 $\\mathcal{R}$。在本问题中，$\\mathcal{R}$ 仅包含一个根状态。设 $X_t$ 为过程在时间 $t$ 的状态。到达集合 $\\mathcal{R}$ 的首達时间定义为 $\\tau \\equiv \\inf\\{t \\geq 0 : X_t \\in \\mathcal{R}\\}$。我们需要求出从每个瞬时初始状态 $i \\in \\mathcal{T}$ 出发的期望首達时间 $h_i$，其定义为 $h_i \\equiv \\mathbb{E}_i[\\tau] = \\mathbb{E}[\\tau | X_0 = i]$。\n\n根据定义，如果过程从一个吸收态 $j \\in \\mathcal{R}$ 开始，则首達时间为 $0$，因此 $h_j = 0$。如果过程从一个瞬时态 $i \\in \\mathcal{T}$ 开始，它至少需要走一步，所以 $\\tau \\geq 1$。我们可以使用全期望定律，对第一步的结果施加条件。时间 $t=1$ 时的状态是 $X_1$。\n\n一步分析法（first-step analysis）得出 $h_i$ 的如下关系：\n$$\nh_i = \\mathbb{E}_i[\\tau] = 1 + \\mathbb{E}_i[\\text{第一步后到达 } \\mathcal{R} \\text{ 所需的额外时间}]\n$$\n设过程从 $X_0=i$ 开始。经过一步后，它以概率 $P_{ij} = P(X_1=j | X_0=i)$ 转移到状态 $j$。根据马尔可夫性质，从状态 $j$ 到达吸收态的剩余时间分布与从状态 $j$ 开始的总吸收时间分布相同。因此，给定 $X_1=j$ 的条件下，期望额外时间就是 $h_j$。\n\n使用全期望定律，我们可以将期望额外时间写为：\n$$\n\\mathbb{E}_i[\\text{额外时间}] = \\sum_{j \\in \\mathcal{T} \\cup \\mathcal{R}} P(X_1 = j | X_0 = i) \\mathbb{E}[\\tau | X_0 = j] = \\sum_{j \\in \\mathcal{T} \\cup \\mathcal{R}} P_{ij} h_j\n$$\n因此，对于任何瞬时态 $i \\in \\mathcal{T}$，我们有以下关系：\n$$\nh_i = 1 + \\sum_{j \\in \\mathcal{T} \\cup \\mathcal{R}} P_{ij} h_j\n$$\n我们可以将求和拆分到瞬时态 $\\mathcal{T}$ 和吸收态 $\\mathcal{R}$ 上：\n$$\nh_i = 1 + \\sum_{j \\in \\mathcal{T}} P_{ij} h_j + \\sum_{j \\in \\mathcal{R}} P_{ij} h_j\n$$\n如前所述，对于任何 $j \\in \\mathcal{R}$，$h_j = 0$。方程简化为：\n$$\nh_i = 1 + \\sum_{j \\in \\mathcal{T}} P_{ij} h_j\n$$\n瞬时态 $i, j \\in \\mathcal{T}$ 之间的转移概率由子矩阵 $Q$ 给出，其中 $Q_{ij} = P_{ij}$。因此，对于每个 $i \\in \\mathcal{T}$：\n$$\nh_i = 1 + \\sum_{j \\in \\mathcal{T}} Q_{ij} h_j\n$$\n这代表了一个线性方程组，每个瞬时态 $i$ 对应一个方程。设 $|\\mathcal{T}| = k$。设 $\\mathbf{h}$ 为瞬时态 $i \\in \\mathcal{T}$ 的期望首達时间 $h_i$ 组成的 $k \\times 1$ 列向量，$\\mathbf{1}$ 为一个 $k \\times 1$ 的全1列向量。该方程组可以写成矩阵形式：\n$$\n\\mathbf{h} = \\mathbf{1} + Q \\mathbf{h}\n$$\n整理各项，将未知数 $\\mathbf{h}$ 组合在一起，我们得到：\n$$\n\\mathbf{h} - Q \\mathbf{h} = \\mathbf{1}\n$$\n$$\n(I - Q) \\mathbf{h} = \\mathbf{1}\n$$\n其中 $I$ 是 $k \\times k$ 的单位矩阵。这就是瞬时态的期望首達时间向量 $\\mathbf{h}$ 所满足的线性系统。其解由 $\\mathbf{h} = (I - Q)^{-1} \\mathbf{1}$ 给出，前提是矩阵 $(I - Q)$ 是可逆的。在任何吸收马尔可夫链中，只要所有瞬时态都可以到达一个吸收态，这个逆矩阵，即基本矩阵 $N = (I-Q)^{-1}$，就总是存在的。\n\n任务B：在简单谱系链上的计算。\n\n给定的关于状态 $\\{S_1, S_2, S_3, R\\}$ 的马尔可夫链的转移矩阵是：\n$$\nP \\;=\\; \\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  0  \\frac{1}{2} \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4}  0 \\\\\n0  \\frac{1}{2}  \\frac{1}{2}  0 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n瞬时态为 $\\mathcal{T} = \\{S_1, S_2, S_3\\}$，吸收根为 $\\mathcal{R}=\\{R\\}$。瞬时态到瞬时态的转移子矩阵 $Q$ 是 $P$ 的左上角 $3 \\times 3$ 分块：\n$$\nQ = \\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  0 \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4} \\\\\n0  \\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix}\n$$\n我们需要求解方程组 $(I-Q)\\mathbf{h} = \\mathbf{1}$，其中 $\\mathbf{h} = (h_{S_1}, h_{S_2}, h_{S_3})^T$。首先，我们计算矩阵 $I-Q$：\n$$\nI - Q = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} - \\begin{pmatrix}\n\\frac{1}{4}  \\frac{1}{4}  0 \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4} \\\\\n0  \\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{4}  0 \\\\\n-\\frac{1}{2}  \\frac{3}{4}  -\\frac{1}{4} \\\\\n0  -\\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix}\n$$\n我们记 $h_1 = h_{S_1}$，$h_2 = h_{S_2}$ 以及 $h_3 = h_{S_3}$。线性方程组为：\n$$\n\\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{4}  0 \\\\\n-\\frac{1}{2}  \\frac{3}{4}  -\\frac{1}{4} \\\\\n0  -\\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix}\n\\begin{pmatrix}\nh_1 \\\\\nh_2 \\\\\nh_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\\n1 \\\\\n1\n\\end{pmatrix}\n$$\n这对应以下三个方程：\n1. $\\frac{3}{4}h_1 - \\frac{1}{4}h_2 = 1$\n2. $-\\frac{1}{2}h_1 + \\frac{3}{4}h_2 - \\frac{1}{4}h_3 = 1$\n3. $-\\frac{1}{2}h_2 + \\frac{1}{2}h_3 = 1$\n\n从方程(3)中，我们可以用 $h_2$ 表示 $h_3$：\n$h_3 - h_2 = 2 \\implies h_3 = h_2 + 2$。\n\n从方程(1)中，我们可以用 $h_1$ 表示 $h_2$：\n$3h_1 - h_2 = 4 \\implies h_2 = 3h_1 - 4$。\n\n现在我们可以用 $h_1$ 表示 $h_3$：\n$h_3 = (3h_1 - 4) + 2 = 3h_1 - 2$。\n\n将 $h_2$ 和 $h_3$ 的这些表达式代入方程(2)。首先，将方程(2)乘以 $4$ 以消除分数：\n$-2h_1 + 3h_2 - h_3 = 4$。\n现在代入：\n$-2h_1 + 3(3h_1 - 4) - (3h_1 - 2) = 4$。\n$-2h_1 + 9h_1 - 12 - 3h_1 + 2 = 4$。\n合并包含 $h_1$ 的项：\n$(-2+9-3)h_1 - 10 = 4$。\n$4h_1 = 14$。\n$h_1 = \\frac{14}{4} = \\frac{7}{2}$。\n\n找到了 $h_1$之后，我们可以求出 $h_2$ 和 $h_3$：\n$h_2 = 3h_1 - 4 = 3\\left(\\frac{7}{2}\\right) - 4 = \\frac{21}{2} - \\frac{8}{2} = \\frac{13}{2}$。\n$h_3 = h_2 + 2 = \\frac{13}{2} + 2 = \\frac{13}{2} + \\frac{4}{2} = \\frac{17}{2}$。\n\n瞬时态的期望首達时间为 $h_{S_1} = \\frac{7}{2}$，$h_{S_2} = \\frac{13}{2}$ 和 $h_{S_3} = \\frac{17}{2}$。问题要求答案以单个行向量的形式给出。\n因此，向量 $\\mathbf{h} = (h_{S_1}, h_{S_2}, h_{S_3})$ 是 $\\left(\\frac{7}{2}, \\frac{13}{2}, \\frac{17}{2}\\right)$。\n这些值代表了分配给每个细胞状态的伪时间，数值越大对应于平均而言在随机游走步数上离根状态“更远”的状态。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{7}{2}  \\frac{13}{2}  \\frac{17}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "许多生物过程，如细胞分化，都涉及细胞走向多个不同命运的分支路径。轨迹推断的一个关键目标不仅是识别这些分支，还要量化每个细胞对特定命运的“承诺”程度。本练习利用马尔可夫链中的吸收概率来模拟谱系承诺，其中终端细胞命运被视为“吸收”态。一个从中间状态细胞开始的随机游走最终落入某个特定吸收态的概率，被诠释为该细胞的“分支分配概率”，从而为理解细胞如何被分配到不同发育谱系提供了清晰的量化基础 。",
            "id": "3356200",
            "problem": "考虑一个用于单细胞状态空间中轨迹推断的细胞-细胞图上的类扩散随机游走。该图包含3个非终端细胞，标记为 $X_{1}$、$X_{2}$ 和 $X_{3}$，以及2个代表谱系终点的终端（吸收）状态，标记为 $A$ 和 $B$。一个位于非终端细胞的随机游走者会根据下面指定的概率，在一步之内转移到其邻居或一个终端状态；一旦到达终端状态，该游走者将永远停留在那里。在轨迹推断和伪时间重建的背景下，一个非终端细胞被 $A$（或 $B$）吸收的概率被解释为该细胞朝向终端分支 $A$（或 $B$）的分支分配概率。\n\n从每个非终端细胞出发的单步转移概率如下：\n- 从 $X_{1}$ 出发：以 $\\frac{1}{2}$ 的概率转移到 $X_{2}$，以 $\\frac{1}{4}$ 的概率转移到 $X_{3}$，以 $\\frac{1}{4}$ 的概率转移到 $A$，以 $0$ 的概率转移到 $B$。\n- 从 $X_{2}$ 出发：以 $\\frac{1}{3}$ 的概率转移到 $X_{1}$，以 $\\frac{1}{3}$ 的概率转移到 $X_{3}$，以 $0$ 的概率转移到 $A$，以 $\\frac{1}{3}$ 的概率转移到 $B$。\n- 从 $X_{3}$ 出发：以 $\\frac{1}{2}$ 的概率转移到 $X_{2}$，以 $\\frac{1}{4}$ 的概率转移到 $A$，以 $\\frac{1}{4}$ 的概率转移到 $B$，以 $0$ 的概率转移到 $X_{1}$。\n\n假设终端状态 $A$ 和 $B$ 是吸收状态：从 $A$ 到 $A$ 的概率为 $1$（到所有其他状态的概率为 $0$），从 $B$ 到 $B$ 的概率为 $1$（到所有其他状态的概率为 $0$）。仅使用马尔可夫性质和全概率定律作为基本依据，推导并计算每个非终端细胞 $X_{1}$、$X_{2}$ 和 $X_{3}$ 被 $A$ 和 $B$ 吸收的精确概率。\n\n答案规格：\n- 将您的最终答案表示为一个单行矩阵，按顺序 $(X_{1}\\!\\to\\!A)$、$(X_{1}\\!\\to\\!B)$、$(X_{2}\\!\\to\\!A)$、$(X_{2}\\!\\to\\!B)$、$(X_{3}\\!\\to\\!A)$、$(X_{3}\\!\\to\\!B)$ 列出六个分支分配概率。\n- 提供最简分数形式的精确有理数。不要四舍五入。\n- 无需单位。",
            "solution": "该问题要求计算一个有限图上的随机游走被两个吸收状态 $A$ 和 $B$ 吸收的概率。这是一个关于离散时间马尔可夫链的经典问题。状态集为 {$X_1, X_2, X_3, A, B$}。状态 $X_1, X_2, X_3$ 是瞬时状态，而 $A$ 和 $B$ 是吸收状态。一个细胞（例如 $X_i$）被一个终端状态（例如 $A$）吸收的概率，是指一个从 $X_i$ 开始的随机游走者最终将到达状态 $A$ 的概率。\n\n设 $p_{iA}$ 为从细胞 $X_i$ 开始的随机游走被状态 $A$ 吸收的概率，其中 $i \\in \\{1, 2, 3\\}$。类似地，设 $p_{iB}$ 为从 $X_i$ 开始被状态 $B$ 吸收的概率。我们需要计算六个值：$p_{1A}$、$p_{1B}$、$p_{2A}$、$p_{2B}$、$p_{3A}$ 和 $p_{3B}$。\n\n解决这个问题的核心原理是第一步分析法，它利用了全概率定律和马尔可夫性质。从起始细胞 $X_i$ 出发被特定终端状态吸收的概率，是基于从 $X_i$ 迈出的第一步进行条件化后，被吸收概率的总和。\n\n让我们首先计算被终端状态 $A$ 吸收的概率。对于任何瞬时状态 $X_i$，吸收概率 $p_{iA}$ 可以表示为：\n$$p_{iA} = \\sum_{j \\in \\{X_1, X_2, X_3, A, B\\}} P(\\text{下一状态为 } j | \\text{起始状态为 } X_i) \\times P(\\text{在 A 中被吸收 } | \\text{起始状态为 } j)$$\n如果 $j$ 是瞬时状态之一，则概率 $P(\\text{在 A 中被吸收 } | \\text{起始状态为 } j)$ 就是 $p_{1A}$、$p_{2A}$ 和 $p_{3A}$。如果游走从一个吸收状态开始，则概率由吸收的性质定义：\n$P(\\text{在 A 中被吸收 } | \\text{起始状态为 } A) = 1$\n$P(\\text{在 A 中被吸收 } | \\text{起始状态为 } B) = 0$\n\n使用给定的单步转移概率，我们可以为 $p_{1A}$、$p_{2A}$ 和 $p_{3A}$ 建立一个线性方程组。\n\n对于起始状态 $X_1$：\n$$p_{1A} = P(X_2|X_1)p_{2A} + P(X_3|X_1)p_{3A} + P(A|X_1) \\cdot 1 + P(B|X_1) \\cdot 0$$\n$$p_{1A} = \\frac{1}{2}p_{2A} + \\frac{1}{4}p_{3A} + \\frac{1}{4} \\quad (1)$$\n\n对于起始状态 $X_2$：\n$$p_{2A} = P(X_1|X_2)p_{1A} + P(X_3|X_2)p_{3A} + P(A|X_2) \\cdot 1 + P(B|X_2) \\cdot 0$$\n$$p_{2A} = \\frac{1}{3}p_{1A} + \\frac{1}{3}p_{3A} + 0$$\n$$p_{2A} = \\frac{1}{3}(p_{1A} + p_{3A}) \\quad (2)$$\n\n对于起始状态 $X_3$：\n$$p_{3A} = P(X_1|X_3)p_{1A} + P(X_2|X_3)p_{2A} + P(A|X_3) \\cdot 1 + P(B|X_3) \\cdot 0$$\n$$p_{3A} = 0 \\cdot p_{1A} + \\frac{1}{2}p_{2A} + \\frac{1}{4}$$\n$$p_{3A} = \\frac{1}{2}p_{2A} + \\frac{1}{4} \\quad (3)$$\n\n我们现在得到了一个包含三个未知数（$p_{1A}, p_{2A}, p_{3A}$）的三元线性方程组。我们可以解这个方程组。\n从方程 $(3)$，我们可以用 $p_{3A}$ 表示 $p_{2A}$：\n$$\\frac{1}{2}p_{2A} = p_{3A} - \\frac{1}{4} \\implies p_{2A} = 2p_{3A} - \\frac{1}{2}$$\n\n接下来，我们将这个 $p_{2A}$ 的表达式代入方程 $(2)$：\n$$2p_{3A} - \\frac{1}{2} = \\frac{1}{3}(p_{1A} + p_{3A})$$\n$$6p_{3A} - \\frac{3}{2} = p_{1A} + p_{3A}$$\n$$p_{1A} = 5p_{3A} - \\frac{3}{2}$$\n\n现在我们有了用 $p_{3A}$ 表示的 $p_{1A}$ 和 $p_{2A}$ 的表达式。我们将它们代入方程 $(1)$：\n$$p_{1A} = \\frac{1}{2}p_{2A} + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = \\frac{1}{2}\\left(2p_{3A} - \\frac{1}{2}\\right) + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = p_{3A} - \\frac{1}{4} + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = p_{3A} + \\frac{1}{4}p_{3A}$$\n$$5p_{3A} - \\frac{3}{2} = \\frac{5}{4}p_{3A}$$\n$$5p_{3A} - \\frac{5}{4}p_{3A} = \\frac{3}{2}$$\n$$\\frac{20p_{3A} - 5p_{3A}}{4} = \\frac{3}{2}$$\n$$\\frac{15}{4}p_{3A} = \\frac{3}{2}$$\n$$p_{3A} = \\frac{3}{2} \\cdot \\frac{4}{15} = \\frac{12}{30} = \\frac{2}{5}$$\n\n现在我们可以回代求解 $p_{2A}$ 和 $p_{1A}$：\n$$p_{2A} = 2p_{3A} - \\frac{1}{2} = 2\\left(\\frac{2}{5}\\right) - \\frac{1}{2} = \\frac{4}{5} - \\frac{1}{2} = \\frac{8-5}{10} = \\frac{3}{10}$$\n$$p_{1A} = 5p_{3A} - \\frac{3}{2} = 5\\left(\\frac{2}{5}\\right) - \\frac{3}{2} = 2 - \\frac{3}{2} = \\frac{1}{2}$$\n\n所以，被状态 $A$ 吸收的概率是：\n$p_{1A} = \\frac{1}{2}$\n$p_{2A} = \\frac{3}{10}$\n$p_{3A} = \\frac{2}{5}$\n\n由于 $A$ 和 $B$ 是系统中仅有的吸收状态，任何从瞬时状态开始的随机游走最终必然被 $A$ 或 $B$ 吸收。因此，对于每个起始状态 $X_i$，被 $A$ 和 $B$ 吸收的概率之和必须为 $1$。\n$$p_{iA} + p_{iB} = 1$$\n这使得我们可以很容易地计算出被状态 $B$ 吸收的概率：\n$$p_{1B} = 1 - p_{1A} = 1 - \\frac{1}{2} = \\frac{1}{2}$$\n$$p_{2B} = 1 - p_{2A} = 1 - \\frac{3}{10} = \\frac{7}{10}$$\n$$p_{3B} = 1 - p_{3A} = 1 - \\frac{2}{5} = \\frac{3}{5}$$\n\n所需的六个分支分配概率是：\n$P(X_1 \\to A) = p_{1A} = \\frac{1}{2}$\n$P(X_1 \\to B) = p_{1B} = \\frac{1}{2}$\n$P(X_2 \\to A) = p_{2A} = \\frac{3}{10}$\n$P(X_2 \\to B) = p_{2B} = \\frac{7}{10}$\n$P(X_3 \\to A) = p_{3A} = \\frac{2}{5}$\n$P(X_3 \\to B) = p_{3B} = \\frac{3}{5}$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{2}  \\frac{1}{2}  \\frac{3}{10}  \\frac{7}{10}  \\frac{2}{5}  \\frac{3}{5} \\end{pmatrix}}\n$$"
        }
    ]
}