{
    "hands_on_practices": [
        {
            "introduction": "在设计细胞自动机模型时，一个基本任务是确保其局部规则能够产生期望的全局行为。本练习将引导你通过分析方法，证明一组精心设计的细胞分裂和凋亡规则如何在期望上导致细胞总数守恒 。这项实践对于理解如何将生物学假设转化为具有特定宏观属性的数学模型至关重要。",
            "id": "3293881",
            "problem": "考虑一个具有周期性边界条件的二维方格细胞自动机（Cellular Automaton (CA)），该自动机代表一个上皮组织单层。每个格点 $j$ 具有一个二元状态 $x_{j} \\in \\{0,1\\}$，其中 $x_{j} = 1$ 表示一个活细胞，$x_{j} = 0$ 表示一个空位点。令 $N = \\sum_{j} x_{j}$ 为细胞总数。每个位点有一个大小为 $k$ 的固定邻域（例如，半径为1的摩尔邻域有 $k = 8$），对于任何被占据的位点 $i$，定义 $e_{i} \\in \\{0,1,\\dots,k\\}$ 为位点 $i$ 的空邻居数量。\n\n在每次更新时，该细胞自动机通过从所有被占据的位点集合中均匀随机选择一个位点 $i$ 来进行异步演化。给定选定的位点 $i$，定义一个局部事件概率\n$$\nr_{i} = r_{0} \\frac{e_{i}}{k},\n$$\n其中 $r_{0} \\in (0, \\tfrac{1}{2}]$ 是一个固定参数。然后，位点 $i$ 的更新通过从以下互斥的可能性中抽取一个结果来进行：\n- 以概率 $r_{i}$，位点 $i$ 处的细胞分裂到其 $e_{i}$ 个空邻居位点中的一个（均匀随机选择），从而使 $N$ 增加 $1$。\n- 以概率 $r_{i}$，位点 $i$ 处的细胞经历凋亡（程序性细胞死亡），从而使 $N$ 减少 $1$。\n- 以概率 $1 - 2 r_{i}$，位点 $i$ 不发生变化，$N$ 保持不变。\n\n这些规则反映了两个经过充分验证的生物学事实：（i）细胞分裂受限于可用空间的多少，以及（ii）在稀疏占据的邻域中，接触介导的存活信号的丧失（失巢凋亡）会增加凋亡的可能性。\n\n从期望值的定义出发，并以焦点位点的随机选择及该位点更新的随机结果为条件，推导每次更新中细胞总数的期望变化，记为 $\\mathbb{E}[\\Delta N]$。将其表示为一个关于当前构型 $\\{x_{j}\\}$、邻域空位数 $\\{e_{i}\\}$ 和参数 $r_{0}$ 的闭式解析表达式。将您的最终答案表示为无单位的单个解析表达式。无需四舍五入。",
            "solution": "问题陈述经评估有效。它在科学上是成立的，作为计算生物学中的一个标准细胞自动机模型，其定义清晰，所有必要的参数和规则都已明确，并且是客观且无矛盾的。约束条件 $r_0 \\in (0, \\tfrac{1}{2}]$ 确保了所有概率都是良好定义且非负的，因为 $r_i = r_0 \\frac{e_i}{k} \\le r_0 \\le \\frac{1}{2}$，这意味着 $1 - 2r_i \\ge 0$。我们继续进行推导。\n\n目标是推导每次更新中细胞总数的期望变化，记为 $\\mathbb{E}[\\Delta N]$。细胞总数为 $N = \\sum_j x_j$，其中对于被占据的位点 $x_j=1$，对于空位点 $x_j=0$。我们假设过程开始时细胞数量非零，即 $N > 0$。\n\n更新过程包括两个随机选择阶段：\n1.  从所有 $N$ 个被占据的位点集合中均匀随机选择一个位点 $i$。\n2.  根据给定的概率，在位点 $i$ 处发生一个随机事件（分裂、凋亡或无变化）。\n\n令 $\\mathcal{O} = \\{ j \\mid x_j = 1 \\}$ 为所有被占据位点的索引集合。该集合的大小为 $|\\mathcal{O}| = N$。令 $I$ 为表示被选中进行更新的位点索引的随机变量。根据问题陈述，对于任何位点 $i \\in \\mathcal{O}$，其被选中的概率为：\n$$\nP(I=i) = \\frac{1}{N}\n$$\n为了求出细胞数量的期望变化 $\\mathbb{E}[\\Delta N]$，我们可以使用全期望定律，以位点 $I$ 的选择为条件。公式为：\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} \\mathbb{E}[\\Delta N \\mid I=i] P(I=i)\n$$\n其中 $\\mathbb{E}[\\Delta N \\mid I=i]$ 是在给定已选择位点 $i$ 进行更新的条件下，$N$ 的期望变化。\n\n我们现在为任意一个被占据的位点 $i \\in \\mathcal{O}$ 计算这个条件期望。细胞总数的变化 $\\Delta N$ 可以根据位点 $i$ 处的事件取三个不同的值：\n*   **分裂**：细胞数量增加一，因此 $\\Delta N = +1$。此事件以概率 $r_i$ 发生。\n*   **凋亡**：细胞数量减少一，因此 $\\Delta N = -1$。此事件以概率 $r_i$ 发生。\n*   **无变化**：细胞数量保持不变，因此 $\\Delta N = 0$。此事件以概率 $1 - 2r_i$ 发生。\n\n在选定位点 $i$ 的条件下，$\\Delta N$ 的期望值是 $\\Delta N$ 的每个可能值乘以其相应概率的总和：\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = (+1) \\cdot P(\\text{在 } i \\text{ 处分裂}) + (-1) \\cdot P(\\text{在 } i \\text{ 处凋亡}) + (0) \\cdot P(\\text{在 } i \\text{ 处无变化})\n$$\n代入问题中给出的概率：\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = (+1) \\cdot r_i + (-1) \\cdot r_i + (0) \\cdot (1 - 2r_i)\n$$\n这可以简化为：\n$$\n\\mathbb{E}[\\Delta N \\mid I=i] = r_i - r_i + 0 = 0\n$$\n这个结果表明，对于任何被选中的被占据位点 $i$，细胞总数的期望变化恰好为零。这是模型设计的直接结果，其中增加细胞数量的事件（分裂）的概率被设定为与减少细胞数量的事件（凋亡）的概率完全相同。局部邻域依赖因子 $r_i = r_0 \\frac{e_i}{k}$ 对这两个速率的调节是相等的，因此在单个事件的层面上，它们各自对期望变化的贡献完全相互抵消。\n\n现在，我们将这个条件期望代回到全期望定律中：\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} (0) \\cdot P(I=i)\n$$\n由于 $P(I=i) = \\frac{1}{N}$，这变为：\n$$\n\\mathbb{E}[\\Delta N] = \\sum_{i \\in \\mathcal{O}} (0) \\cdot \\frac{1}{N}\n$$\n该和由 $N$ 个项组成，每一项都为零。因此，总和为零：\n$$\n\\mathbb{E}[\\Delta N] = 0\n$$\n每次更新中细胞总数的期望变化为 $0$。这是一个闭式解析表达式，是一个与当前构型 $\\{x_j\\}$、邻域空位数 $\\{e_i\\}$ 和参数 $r_0$ 无关的常数。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "简单的平均场理论假设空间是均匀混合的，从而忽略了细胞自动机中固有的空间结构和相关性。本练习将带你超越这一简化，推导并实现更精确的“对近似”方法，它能捕捉最近邻细胞间的相关性 。通过将这两种理论与蒙特卡洛模拟结果进行比较，你将亲身体验到在空间模型中考虑相关性的重要性。",
            "id": "3293915",
            "problem": "考虑一个周期性方形晶格上的单物种概率细胞自动机（PCA），其邻域为 von Neumann 邻域（每个格点有 $z=4$ 个最近邻）。在离散时间 $t$，每个晶格格点要么被一个细胞占据（$1$），要么为空（$0$）。从时间 $t$到时间 $t+1$ 的同步更新包括按顺序应用于整个晶格的以下子步骤：(i) 死亡，(ii) 出生，(iii) 移动。在给定当前构型的情况下，所有事件都是条件独立的，并且所有随机选择都是均匀的。\n\n死亡子步骤：每个被占据的格点独立地以概率 $d \\in [0,1]$ 变为空。\n\n出生子步骤：对于每个空格点，令 $K$ 表示死亡子步骤后被占据的最近邻的数量。该格点以概率 $1 - (1 - \\beta)^{K}$ 变为被占据，其中 $\\beta \\in [0,1]$ 是每个邻居的定殖概率。\n\n移动子步骤：每个被占据的格点独立地以概率 $m \\in [0,1]$ 尝试移动到一个均匀随机选择的空格点最近邻。如果多个被占据的格点以同一个空格点为目标，则均匀随机选择其中一个移动，其余的保持不动。移动子步骤保持被占据格点的总数不变。\n\n令 $u_t$ 表示占据分数，即在时间 $t$ 一个均匀随机选择的格点被占据的概率。令 $C_{NN,t}$ 表示最近邻占据相关性，即在时间 $t$ 一个均匀随机选择的无向最近邻边的两端都被占据的概率。\n\n任务 A（平均场递推式的推导）：从格点间的统计独立性假设（无空间相关性）和独立性下占据邻居数量的二项分布定律出发，根据上述更新顺序，推导 $u_{t+1}$ 作为 $u_t$、$d$、$\\beta$ 和 $z$ 的函数的递推式。您的推导必须明确地从死亡和出生机制开始，并且不得假设任何预先存在的 $u_{t+1}$ 公式。\n\n任务 B（包含最近邻相关性的对近似）：通过引入最近邻相关性 $C_{NN,t}$ 来放宽独立性假设。令 $u_t^D = u_t (1 - d)$ 和 $C_{NN,t}^D = C_{NN,t} (1 - d)^2$ 分别表示死亡子步骤后的占据分数和最近邻相关性。在对近似下，假设给定中心格点的状态，除一个指定邻居外的其余 $z-1$ 个邻居是条件独立的，将一个空格点的最近邻被占据的条件概率 $q_t^D$ 表示为 $q_t^D = (u_t^D - C_{NN,t}^D) / (1 - u_t^D)$，并推导：\n- 使用对近似下 $K$ 的二项分布定律，推导 $u_{t+1}$ 关于 $u_t^D$、$q_t^D$ 和 $z$ 的递推式，\n- 针对 $m=0$ 的特殊情况，通过枚举死亡后所有最近邻对类型及其在出生后的转变，构建 $C_{NN,t+1}$ 的递推式。使用以下对于 $z=4$ 的分解：令 $p_{11}^D=C_{NN,t}^D$，$p_{10}^D = u_t^D - C_{NN,t}^D$，以及 $p_{00}^D = 1 - 2 u_t^D + C_{NN,t}^D$，定义 $E_t = 1 - [1 - \\beta q_t^D]^{z-1}$ 和 $\\Phi_t = 1 - (1 - \\beta) [1 - \\beta q_t^D]^{z-1}$，然后近似 $C_{NN,t+1} \\approx C_{NN,t}^{B} = p_{11}^D + 2 p_{10}^D \\,\\Phi_t + p_{00}^D \\, E_t^2$，该近似假设在给定周围邻域的情况下，一个 $00$ 对的两个格点的定殖事件是独立的（这对于 von Neumann 邻域是精确的，因为相邻格点除了彼此之外没有共同的邻居）。对于一般的 $m \\in [0,1]$，论证一个形式为 $C_{NN,t+1} \\approx (1 - m)\\, C_{NN,t}^{B} + m \\, u_{t+1}^2$ 的简单的“混合去相关”近似，用于移动子步骤。该近似保持边际占据分数，并在纯粹的出生-死亡动态（$m=0$）和完全混合的边（$m=1$）之间进行插值。\n\n任务 C（改进的量化）：实现一个程序，该程序：\n- 通过从初始值 $u_0 \\in (0,1)$ 开始迭代平均场递推式直至收敛，计算平均场不动点 $u^\\ast_{\\mathrm{MF}}$，\n- 通过从初始值 $(u_0, C_{NN,0})$ 开始迭代耦合的 $(u_t, C_{NN,t})$ 递推式直至收敛，计算对近似不动点 $u^\\ast_{\\mathrm{PA}}$，其中 $C_{NN,0}$ 初始化为 $u_0^2$，\n- 在边长为 $L$ 的周期性方形晶格上，从随机初始占据分数 $u_0$ 开始，对 PCA 进行 $T$ 步的蒙特卡洛模拟，对最后 $B$ 步的占据分数进行平均以估计 $u^\\ast_{\\mathrm{sim}}$（在 $R$ 次独立运行中取平均值），以及\n- 对于每组参数，报告对近似相对于平均场近似所实现的绝对误差改进，定义为 $\\Delta = |u^\\ast_{\\mathrm{MF}} - u^\\ast_{\\mathrm{sim}}| - |u^\\ast_{\\mathrm{PA}} - u^\\ast_{\\mathrm{sim}}|$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与下面的测试用例相同。每个结果必须是实数。\n\n使用以下参数集测试套件，以 $(\\beta, d, m, L, T, B, R)$ 表示：\n- 情况 A（一般非平凡占据）：$(0.25, 0.2, 0, 64, 600, 400, 3)$\n- 情况 B（接近灭绝）：$(0.05, 0.5, 0, 64, 600, 400, 3)$\n- 情况 C（高占据率）：$(0.6, 0.05, 0, 64, 600, 400, 3)$\n- 情况 D（接近平均场阈值 $\\beta z \\approx d$）：$(0.1, 0.4, 0, 64, 600, 400, 3)$\n\n角度单位不适用。不涉及物理单位。最终输出格式必须是 $[r_1,r_2,r_3,r_4]$ 形式的单行，其中每个 $r_i$ 是相应情况下的改进值 $\\Delta$。",
            "solution": "该问题是有效的，因为它在计算系统生物学领域提出了一个定义明确、有科学依据的任务，没有矛盾或含糊之处。\n\n该问题要求对一个晶格上的单生物物种的概率细胞自动机（PCA）模型进行三部分分析。任务涉及在平均场和对近似下的解析推导，以及与直接模拟的数值比较。\n\n### 任务 A：平均场递推式推导\n\n目标是推导占据分数 $u_{t+1}$ 作为 $u_t$、死亡概率 $d$、定殖概率 $\\beta$ 和邻居数 $z$ 的函数的递推关系。平均场近似假设所有晶格格点的状态都是统计独立的。\n\n1.  **死亡子步骤：** 每个被占据的格点以概率 $d$ 变为空。在时间 $t$ 被占据的格点在死亡子步骤后以概率 $1-d$ 保持被占据。由于独立性假设，死亡后立即被占据的格点密度（表示为 $u_t^D$）为：\n    $$u_t^D = u_t (1 - d)$$\n    死亡后的空格点密度为 $1 - u_t^D$。\n\n2.  **出生子步骤：** 一个空格点可以变为被占据。移动子步骤在出生之后发生，并保持被占据格点的总数不变。因此，密度 $u_{t+1}$ 完全由出生子步骤后的系统状态决定。\n    \n    一个在死亡子步骤后为空的格点，如果被其至少一个被占据的邻居成功定殖，则在时间 $t+1$ 将变为被占据。令 $K$ 为一个空格点的被占据邻居的数量。定殖的概率为 $1-(1-\\beta)^K$。\n\n    在平均场假设下，每个邻居的状态与其他邻居以及中心格点的状态无关。任何给定邻居被占据（在死亡步骤后）的概率是 $u_t^D$。对于一个大小为 $z$ 的邻域，被占据邻居的数量 $K$ 服从二项分布，$K \\sim B(z, u_t^D)$，其概率质量函数为 $P(K=k) = \\binom{z}{k} (u_t^D)^k (1 - u_t^D)^{z-k}$。\n\n    一个空格点（死亡后）*保持*为空的概率是未被定殖的概率，对所有可能的 $K$ 值取平均：\n    $$P(\\text{empty remains empty}) = \\sum_{k=0}^{z} P(K=k) (1-\\beta)^k$$\n    $$P(\\text{empty remains empty}) = \\sum_{k=0}^{z} \\binom{z}{k} (u_t^D)^k (1 - u_t^D)^{z-k} (1-\\beta)^k$$\n    这个和可以被识别为二项式展开：\n    $$P(\\text{empty remains empty}) = \\sum_{k=0}^{z} \\binom{z}{k} [u_t^D(1-\\beta)]^k (1 - u_t^D)^{z-k} = [u_t^D(1-\\beta) + (1-u_t^D)]^z = [1 - \\beta u_t^D]^z$$\n    因此，一个空格点变为被占据的概率是：\n    $$P(\\text{birth}) = 1 - [1 - \\beta u_t^D]^z$$\n\n3.  **完整递推式：** 时间 $t+1$ 的总占据率是被占据并存活下来的格点，加上死亡后为空然后经历出生事件的格点之和。\n    $$u_{t+1} = (\\text{density of survivors}) + (\\text{density of empty sites}) \\times P(\\text{birth})$$\n    $$u_{t+1} = u_t^D + (1 - u_t^D) \\left( 1 - [1 - \\beta u_t^D]^z \\right)$$\n    代入 $u_t^D = u_t(1-d)$，我们得到最终的平均场递推关系：\n    $$u_{t+1} = u_t(1-d) + (1 - u_t(1-d)) \\left( 1 - \\left[1 - \\beta u_t(1-d)\\right]^z \\right)$$\n\n### 任务 B：对近似\n\n此任务通过包含最近邻相关性 $C_{NN,t}$ 来放宽平均场假设。von Neumann 邻域有 $z=4$。\n\n1.  **$u_{t+1}$ 的递推式：**\n    推导的结构与平均场情况类似，但邻居被占据的概率现在是条件概率。\n    死亡步骤后，占据分数为 $u_t^D = u_t(1-d)$，最近邻相关性为 $C_{NN,t}^D = C_{NN,t}(1-d)^2$。\n\n    我们考虑一个空格点。对近似假设在给定中心格点状态的情况下，其 $z$ 个邻居是条件独立的。关键量是 $q_t^D$，即死亡步骤后一个空格点的邻居被占据的条件概率。问题为此提供了标准表达式：\n    $$q_t^D = P(\\text{neighbor is } 1 | \\text{focal is } 0) = \\frac{P(1, 0)}{P(0)} = \\frac{u_t^D - C_{NN,t}^D}{1 - u_t^D}$$\n    因此，一个空格点的被占据邻居数 $K$ 服从二项分布 $K \\sim B(z, q_t^D)$。\n    \n    这个空格点变为被占据（出生事件）的概率是：\n    $$P(\\text{birth}) = 1 - \\sum_{k=0}^{z} \\binom{z}{k} (q_t^D)^k (1-q_t^D)^{z-k} (1-\\beta)^k = 1 - [1 - \\beta q_t^D]^z$$\n    对近似下占据分数 $u_{t+1}$ 的递推式为：\n    $$u_{t+1} = u_t^D + (1 - u_t^D) \\left( 1 - [1 - \\beta q_t^D]^z \\right)$$\n\n2.  **$C_{NN,t+1}$ 的递推式（对于 $m=0$）：**\n    对于没有移动的情况（$m=0$），出生后的相关性 $C_{NN,t}^B$ 就是最终的相关性 $C_{NN,t+1}$。问题提供了 $C_{NN,t}^B$ 的公式，该公式由死亡后对构型的概率（$p_{11}^D, p_{10}^D, p_{00}^D$）和与定殖概率相关的项（$E_t, \\Phi_t$）构建。\n\n    对于 $m=0$ 的对近似的完整迭代系统如下：\n    给定 $(u_t, C_{NN,t})$ 和参数 $(d, \\beta, z=4)$:\n    a. 计算死亡后量：\n        $$u_t^D = u_t(1-d)$$\n        $$C_{NN,t}^D = C_{NN,t}(1-d)^2$$\n    b. 计算辅助量：\n        - 如果 $u_t^D  1$：$q_t^D = (u_t^D - C_{NN,t}^D) / (1 - u_t^D)$。否则，由于没有空格点，$q_t^D=0$。\n        - $p_{11}^D = C_{NN,t}^D$\n        - $p_{10}^D = u_t^D - C_{NN,t}^D$\n        - $p_{00}^D = 1 - 2u_t^D + C_{NN,t}^D$\n        - $E_t = 1 - [1 - \\beta q_t^D]^{z-1}$ (在一个空格点旁边定殖一个空格点的概率)\n        - $\\Phi_t = 1 - (1 - \\beta) [1 - \\beta q_t^D]^{z-1}$ (在一个被占据格点旁边定殖一个空格点的概率)\n    c. 更新时间 $t+1$ 的状态变量：\n        $$u_{t+1} = u_t^D + (1 - u_t^D) \\left( 1 - [1 - \\beta q_t^D]^z \\right)$$\n        $$C_{NN,t+1} = p_{11}^D + 2 p_{10}^D \\Phi_t + p_{00}^D E_t^2$$\n\n3.  **移动步骤的论证（$m>0$）：**\n    对于一般的移动概率 $m$，问题建议了以下近似：\n    $$C_{NN,t+1} \\approx (1 - m)\\, C_{NN,t}^{B} + m \\, u_{t+1}^2$$\n    这个方程可以被解释为一个简单的线性混合模型。\n    -   $C_{NN,t}^B$ 代表在任何移动发生之前，由出生-死亡动态建立的相关性。\n    -   移动步骤涉及一部分比例为 $m$ 的被占据细胞尝试移动到一个随机的空邻居。这个过程破坏了现有的空间相关性并形成新的相关性。\n    -   项 $(1 - m) C_{NN,t}^B$ 代表了被假定为“不受”移动影响的细胞对对最终相关性的贡献。它模拟了移动前相关性中有一部分比例 $(1-m)$ 被保留下来。\n    -   项 $m u_{t+1}^2$ 代表了被移动“重新混合”的对的贡献。它假设当一对中的一个细胞移动时，局部相关性被破坏并重置为平均场值，即全局密度的平方 $u_{t+1}^2$。使用密度 $u_{t+1}$ 是正确的，因为移动保持了被占据格点的数量不变。\n    -   该模型在两个极端情况之间进行了正确的插值：\n        -   如果 $m=0$（无移动），$C_{NN,t+1} = C_{NN,t}^B$，恢复到出生-死亡动态。\n        -   如果 $m=1$（最大混合），$C_{NN,t+1} = u_{t+1}^2$，这对应于密度为 $u_{t+1}$ 的空间不相关（随机）的细胞分布。\n    这种启发式方法提供了一种合理且计算上简单的方式来解释细胞移动的去相关效应。\n\n### 任务 C：改进的量化\n平均场求解器、对近似求解器和蒙特卡洛模拟的实现在最终答案块中提供。代码从三种方法中计算稳态占据分数 $u^\\ast$，并报告绝对误差的改进 $\\Delta = |u^\\ast_{\\mathrm{MF}} - u^\\ast_{\\mathrm{sim}}| - |u^\\ast_{\\mathrm{PA}} - u^\\ast_{\\mathrm{sim}}|$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve_mf(beta, d, z=4, u0=0.5, tol=1e-10, max_iter=100000):\n    \"\"\"\n    Computes the mean-field fixed point occupancy fraction.\n    \"\"\"\n    u = u0\n    for _ in range(max_iter):\n        u_old = u\n        uD = u * (1 - d)\n        if uD = 1.0: # Extinction or full occupancy\n            return uD\n        \n        # Prob that an empty site becomes occupied\n        prob_birth = 1 - (1 - beta * uD)**z\n        \n        # Recurrence for u\n        u = uD + (1 - uD) * prob_birth\n        \n        if abs(u - u_old)  tol:\n            break\n    return u\n\ndef solve_pa(beta, d, m, z=4, u0=0.5, tol=1e-10, max_iter=100000):\n    \"\"\"\n    Computes the pair-approximation fixed point occupancy fraction.\n    \"\"\"\n    u = u0\n    C_NN = u0**2  # Initial uncorrelated assumption\n    \n    for _ in range(max_iter):\n        u_old = u\n        \n        # 1. Post-death quantities\n        uD = u * (1 - d)\n        C_NN_D = C_NN * (1 - d)**2\n        \n        if uD = 1.0: # Saturation\n             u_next = 1.0\n             C_NN_next = 1.0\n        elif uD  1e-12: # Extinction\n             u_next = 0.0\n             C_NN_next = 0.0\n        else:\n            # 2. Auxiliary quantities for birth step\n            # Conditional probability P(1|0) after death\n            qD = (uD - C_NN_D) / (1 - uD)\n            qD = max(0, qD) # Ensure non-negative from numerical error\n\n            # 3. Update u\n            prob_birth_empty_site = 1 - (1 - beta * qD)**z\n            u_next = uD + (1 - uD) * prob_birth_empty_site\n\n            # 4. Update C_NN for m=0\n            p11D = C_NN_D\n            p10D = uD - C_NN_D\n            p00D = 1 - 2 * uD + C_NN_D\n\n            z_minus_1 = z - 1\n            term_qD = (1 - beta * qD)**z_minus_1\n\n            E_t = 1 - term_qD\n            Phi_t = 1 - (1 - beta) * term_qD\n\n            C_NN_B = p11D + 2 * p10D * Phi_t + p00D * E_t**2\n            \n            # 5. Movement step\n            C_NN_next = (1 - m) * C_NN_B + m * u_next**2\n\n        u = u_next\n        C_NN = C_NN_next\n\n        if abs(u - u_old)  tol:\n            break\n            \n    return u\n\ndef run_simulation(beta, d, m, L, T, B, R, z=4, u0_sim=0.5):\n    \"\"\"\n    Runs a Monte Carlo simulation of the PCA.\n    This implementation is for m=0, as per the test cases.\n    \"\"\"\n    if m != 0:\n        raise NotImplementedError(\"Simulation is implemented for m=0 only.\")\n        \n    u_estimates_per_run = []\n    kernel = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]], dtype=np.uint8)\n\n    for _ in range(R):\n        # Initialize grid with random occupancy\n        grid = np.random.choice([0, 1], size=(L, L), p=[1 - u0_sim, u0_sim])\n        occupancy_trace = []\n\n        for step in range(T):\n            # --- Death sub-step ---\n            grid_after_death = grid.copy()\n            occupied_indices = np.argwhere(grid == 1)\n            if len(occupied_indices)  0:\n                rand_nums = np.random.rand(len(occupied_indices))\n                dying_mask = rand_nums  d\n                dying_indices = occupied_indices[dying_mask]\n                if len(dying_indices)  0:\n                    grid_after_death[dying_indices[:, 0], dying_indices[:, 1]] = 0\n\n            # --- Birth sub-step ---\n            # Count occupied neighbors for all sites using convolution\n            neighbor_counts = signal.convolve2d(grid_after_death, kernel, mode='same', boundary='wrap')\n            \n            # Calculate birth probability for each site based on its neighbor count\n            birth_probs = 1 - (1 - beta)**neighbor_counts\n            \n            # Apply birth only to empty sites\n            empty_mask = (grid_after_death == 0)\n            rand_nums_birth = np.random.rand(L, L)\n            birth_mask = empty_mask  (rand_nums_birth  birth_probs)\n            \n            grid_after_birth = grid_after_death.copy()\n            grid_after_birth[birth_mask] = 1\n            \n            # --- Movement sub-step ---\n            # For m=0, grid for next step is grid_after_birth\n            grid = grid_after_birth\n\n            if step = T - B:\n                occupancy_trace.append(np.mean(grid))\n\n        u_estimates_per_run.append(np.mean(occupancy_trace))\n\n    return np.mean(u_estimates_per_run)\n\ndef solve():\n    \"\"\"\n    Main function to run all tasks and print the result.\n    \"\"\"\n    # Parameters from the problem statement: (beta, d, m, L, T, B, R)\n    test_cases = [\n        (0.25, 0.2, 0, 64, 600, 400, 3), # Case A\n        (0.05, 0.5, 0, 64, 600, 400, 3), # Case B\n        (0.6, 0.05, 0, 64, 600, 400, 3), # Case C\n        (0.1, 0.4, 0, 64, 600, 400, 3), # Case D\n    ]\n\n    results = []\n    \n    # Set a consistent initial condition for theories and simulations\n    u0_theory = 0.5\n    u0_sim = 0.5\n    z = 4\n\n    for case in test_cases:\n        beta, d, m, L, T, B, R = case\n        \n        # Calculate mean-field fixed point\n        u_mf = solve_mf(beta, d, z, u0=u0_theory)\n        \n        # Calculate pair-approximation fixed point\n        u_pa = solve_pa(beta, d, m, z, u0=u0_theory)\n        \n        # Run simulation to get an estimate of the true fixed point\n        u_sim = run_simulation(beta, d, m, L, T, B, R, z, u0_sim=u0_sim)\n        \n        # Calculate improvement in absolute error\n        error_mf = abs(u_mf - u_sim)\n        error_pa = abs(u_pa - u_sim)\n        improvement = error_mf - error_pa\n        \n        results.append(improvement)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}