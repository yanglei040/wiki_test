{
    "hands_on_practices": [
        {
            "introduction": "伴随方法的力量在于其计算效率，但这通常以增加实现复杂性为代价。在信任由伴随求解器计算出的梯度之前，验证其正确性是至关重要的一步。这个实践练习  将指导你完成一个基础的验证过程，即离散伴随恒等式检验。该检验旨在确认你所实现的离散伴随算子确实是单个时间步内切线性算子的代数转置，这是构建可靠伴随求解器的基石。",
            "id": "3287583",
            "problem": "考虑一个由连续时间常微分方程 (ODE) 建模的三物种生化反应网络。设状态为 $x(t) \\in \\mathbb{R}^3$，其分量 $x_1(t)$、$x_2(t)$、$x_3(t)$ 表示浓度；设参数向量为 $\\theta \\in \\mathbb{R}^7$，其分量 $\\theta_1,\\theta_2,\\theta_3,\\theta_4,\\theta_5,\\theta_6,\\theta_7$ 均为非负的反应速率常数。连续时间右端项由质量作用动力学定义：\n$$\nf(x,\\theta) = \\begin{bmatrix}\n\\theta_1 - \\theta_2 x_1 - \\theta_3 x_1 x_2 \\\\\n\\theta_4 x_1 - \\theta_5 x_2 \\\\\n\\theta_6 x_2 - \\theta_7 x_3\n\\end{bmatrix},\n$$\n其关于 $x$ 的雅可比矩阵为\n$$\nJ(x,\\theta) = \\frac{\\partial f(x,\\theta)}{\\partial x} = \\begin{bmatrix}\n-\\theta_2 - \\theta_3 x_2  & -\\theta_3 x_1 & 0 \\\\\n\\theta_4 & -\\theta_5 & 0 \\\\\n0 & \\theta_6 & -\\theta_7\n\\end{bmatrix}.\n$$\n使用后向欧拉法对动力学进行单步离散化，时间步长为 $\\Delta t > 0$（单位：秒）：\n$$\nx_{k+1} - x_k - \\Delta t \\, f(x_{k+1},\\theta) = 0,\n$$\n并考虑在状态 $x_{k+1}$ 处的任意扰动 $\\delta x_{k+1} \\in \\mathbb{R}^3$ 以及任意伴随向量 $\\lambda_k,\\lambda_{k+1} \\in \\mathbb{R}^3$。后向欧拉法的线性化切线映射由下式给出：\n$$\n\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right) \\, \\delta x_{k+1}.\n$$\n将步骤 $k+1$ 处的离散伴随残差定义为：\n$$\nr_{k+1} := \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}.\n$$\n待测试的离散伴随恒等式表明，对于任意扰动 $\\delta x_{k+1}$ 和伴随向量 $\\lambda_k,\\lambda_{k+1}$，以下等式成立：\n$$\n\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle,\n$$\n其中 $\\langle \\cdot,\\cdot \\rangle$ 表示标准欧几里得内积。\n\n您的任务是使用上述 $f(x,\\theta)$ 和 $J(x,\\theta)$，为该后向欧拉离散化实现一个离散伴随恒等式测试，并通过多个具有任意扰动和伴随向量的案例对该恒等式进行数值验证。对于每个测试案例，您必须：\n- 计算 $J(x_{k+1},\\theta)$。\n- 计算 $\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right)\\delta x_{k+1}$。\n- 计算 $r_{k+1} = \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}$。\n- 计算绝对误差\n$$\n\\varepsilon = \\left| \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle - \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle \\right|。\n$$\n\n科学真实性要求：\n- 所有反应速率常数 $\\theta_i$ 必须为非负。\n- 所有浓度 $x_i$ 必须为非负。\n- 时间步长 $\\Delta t$ 必须为正，并以秒为单位。\n\n测试套件：\n为以下五个案例实现测试。在每个案例中，使用固定种子从零均值和单位方差的正态分布中生成伴随向量 $\\lambda_k,\\lambda_{k+1}$ 和扰动 $\\delta x_{k+1}$（以确保确定性的任意扰动）。对每个向量独立使用三维标准正态分布。\n\n- 案例 1（理想情况）：$\\Delta t = 0.1$ 秒，$\\theta = [0.8, 0.5, 0.4, 0.3, 0.2, 1.0, 0.7]$，$x_{k+1} = [1.0, 0.8, 0.5]$，种子 $101$。\n- 案例 2（边界情况：极小时间步长）：$\\Delta t = 10^{-6}$ 秒，$\\theta = [0.2, 0.1, 0.05, 0.3, 0.25, 0.4, 0.35]$，$x_{k+1} = [0.1, 0.05, 0.02]$，种子 $202$。\n- 案例 3（类刚性动力学：大时间步长和速率）：$\\Delta t = 1.0$ 秒，$\\theta = [2.0, 1.5, 1.2, 0.8, 0.9, 1.1, 1.0]$，$x_{k+1} = [3.0, 2.0, 1.0]$，种子 $303$。\n- 案例 4（接近退化的 $I - \\Delta t J$：强相互作用）：$\\Delta t = 0.9$ 秒，$\\theta = [1.0, 1.0, 5.0, 2.5, 0.1, 0.6, 0.5]$，$x_{k+1} = [10.0, 10.0, 10.0]$，种子 $404$。\n- 案例 5（接近零的雅可比矩阵：极小浓度）：$\\Delta t = 0.05$ 秒，$\\theta = [0.1, 0.1, 0.05, 0.2, 0.1, 0.15, 0.12]$，$x_{k+1} = [10^{-9}, 2 \\cdot 10^{-9}, 3 \\cdot 10^{-9}]$，种子 $505$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含五个案例的绝对误差，格式为方括号内以逗号分隔的列表（例如 $[e_1,e_2,e_3,e_4,e_5]$）。每个 $e_i$ 必须是一个实数（浮点数），代表相应案例计算出的 $\\varepsilon$。误差是无量纲的实数。不应打印任何其他文本。",
            "solution": "在尝试给出解决方案之前，需对问题进行验证。\n\n### 第一步：提取已知信息\n\n- **状态向量：** $x(t) \\in \\mathbb{R}^3$，其分量 $x_1(t)$、$x_2(t)$、$x_3(t)$ 表示浓度。\n- **参数向量：** $\\theta \\in \\mathbb{R}^7$，其分量 $\\theta_1, \\dots, \\theta_7$ 表示非负的反应速率常数。\n- **连续时间动力学函数：** $f(x,\\theta) = \\begin{bmatrix} \\theta_1 - \\theta_2 x_1 - \\theta_3 x_1 x_2 \\\\ \\theta_4 x_1 - \\theta_5 x_2 \\\\ \\theta_6 x_2 - \\theta_7 x_3 \\end{bmatrix}$。\n- **动力学的雅可比矩阵：** $J(x,\\theta) = \\frac{\\partial f(x,\\theta)}{\\partial x} = \\begin{bmatrix} -\\theta_2 - \\theta_3 x_2 & -\\theta_3 x_1 & 0 \\\\ \\theta_4 & -\\theta_5 & 0 \\\\ 0 & \\theta_6 & -\\theta_7 \\end{bmatrix}$。\n- **离散化方法：** 后向欧拉法，时间步长 $\\Delta t > 0$，由隐式方程 $x_{k+1} - x_k - \\Delta t \\, f(x_{k+1},\\theta) = 0$ 定义。\n- **扰动和伴随向量：** 任意扰动 $\\delta x_{k+1} \\in \\mathbb{R}^3$ 和任意伴随向量 $\\lambda_k, \\lambda_{k+1} \\in \\mathbb{R}^3$。\n- **线性化切线映射：** $\\delta x_k = \\left(I - \\Delta t \\, J(x_{k+1},\\theta)\\right) \\, \\delta x_{k+1}$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n- **离散伴随残差：** $r_{k+1} := \\frac{\\left(I - \\Delta t \\, J(x_{k+1},\\theta)^\\top\\right)\\lambda_k - \\lambda_{k+1}}{\\Delta t}$。\n- **离散伴随恒等式：** $\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。\n- **内积：** $\\langle \\cdot,\\cdot \\rangle$ 是标准欧几里得内积。\n- **绝对误差度量：** $\\varepsilon = \\left| \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle - \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle \\right|$。\n- **科学真实性约束：** $\\theta_i \\ge 0$, $x_i \\ge 0$, $\\Delta t > 0$。\n- **测试案例：** 定义了五个具体的数值案例，给出了 $\\Delta t$、$\\theta$、$x_{k+1}$ 的值以及用于生成随机数的种子。随机向量 $\\lambda_k, \\lambda_{k+1}, \\delta x_{k+1}$ 将从三维标准正态分布中抽取。\n\n### 第二步：使用提取的已知信息进行验证\n\n- **科学依据：** 该问题基于化学动力学（质量作用）、常微分方程数值分析（后向欧拉法）和灵敏度分析（伴随方法）的标准原理。这些是计算系统生物学中的基础概念。模型和方程与已建立的理论一致。\n- **良构性：** 该问题提供了一个清晰、明确的任务：为一组完全指定的测试案例，数值验证一个给定的数学恒等式。所有必要的方程、参数和初始值都已提供。每个案例都保证存在唯一的数值结果 ($\\varepsilon$)。\n- **客观性：** 该问题完全以客观的数学语言陈述。由于指定了随机数生成的种子，测试案例是确定性的。\n- **缺陷清单：**\n    1.  **科学/事实不健全：** 问题的核心是离散伴随恒等式。这个恒等式是一个从切线映射和伴随残差的定义推导出来的数学重言式。令 $A = I - \\Delta t \\, J(x_{k+1},\\theta)$。切线映射为 $\\delta x_k = A \\, \\delta x_{k+1}$。伴随残差为 $r_{k+1} = \\frac{1}{\\Delta t}(A^\\top \\lambda_k - \\lambda_{k+1})$。待测试的恒等式为 $\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。通过代入定义并使用伴随算子的性质（对于欧几里得内积，即转置，$\\langle u, Av \\rangle = \\langle A^\\top u, v \\rangle$），左边变为 $\\langle \\lambda_k, A \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k, \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。右边为 $\\Delta t \\, \\langle \\frac{1}{\\Delta t}(A^\\top \\lambda_k - \\lambda_{k+1}), \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。该恒等式在数学上是正确的。问题是健全的。\n    2.  **非形式化/不相关：** 问题是明确形式化的，并且与验证计算科学中伴随求解器实现直接相关。\n    3.  **不完整/矛盾：** 问题是自洽且内部一致的。\n    4.  **不现实/不可行：** 给定的参数遵守科学真实性约束（$\\theta_i \\ge 0$，$x_i \\ge 0$，$\\Delta t > 0$）。\n    5.  **病态/结构不良：** 问题结构良好，每个测试案例都能得到唯一、稳定的结果。\n    6.  **伪深刻/琐碎：** 虽然该恒等式是一个数学重言式，但对其进行数值验证的任务是科学计算软件工程中一项非凡且基础的实践，以确保离散算子已正确实现。\n    7.  **超出科学可验证范围：** 该声明是可数值验证的。\n\n### 第三步：结论与行动\n\n此问题是**有效的**。将提供解决方案。\n\n### 解决方案\n\n该问题要求对使用后向欧拉法离散化的常微分方程 (ODE) 系统的离散伴随恒等式进行数值验证。该恒等式是关联扰动前向传播（切线模型）和灵敏度后向传播（伴随模型）的基本属性。验证此恒等式是“梯度检验”中的关键步骤，以确保伴随求解器的正确实现。预期的结果是，绝对误差 $\\varepsilon$ 将为零，直至浮点运算精度的极限。\n\n恒等式的推导构成了理论基础。后向欧拉离散化为单个时间步定义了一个残差方程，$G(x_k, x_{k+1}, \\theta) = x_{k+1} - x_k - \\Delta t \\, f(x_{k+1}, \\theta) = 0$。线性化切线模型描述了在时间 $k+1$ 的一个微小扰动 $\\delta x_{k+1}$ 如何与在时间 $k$ 相应的扰动 $\\delta x_k$ 相关联，以保持残差为零。这可以通过对 $G$ 取全微分得到：\n$$ dG = \\frac{\\partial G}{\\partial x_k} \\delta x_k + \\frac{\\partial G}{\\partial x_{k+1}} \\delta x_{k+1} = 0 $$\n其中 $\\frac{\\partial G}{\\partial x_k} = -I$ 且 $\\frac{\\partial G}{\\partial x_{k+1}} = I - \\Delta t \\frac{\\partial f}{\\partial x_{k+1}} = I - \\Delta t J(x_{k+1}, \\theta)$，我们有：\n$$ -I \\delta x_k + (I - \\Delta t J(x_{k+1}, \\theta)) \\delta x_{k+1} = 0 $$\n整理后可得问题中给出的线性化切线映射：\n$$ \\delta x_k = (I - \\Delta t J(x_{k+1}, \\theta)) \\delta x_{k+1} $$\n我们用线性算子 $A = I - \\Delta t J(x_{k+1}, \\theta)$ 表示。因此，$\\delta x_k = A \\delta x_{k+1}$。\n\n离散伴随恒等式 $\\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle$ 将前向映射 $A$ 与其伴随 $A^\\top$ 联系起来。我们可以通过代入 $\\delta x_k$ 和 $r_{k+1}$ 的定义来证明这个恒等式。\n\n设 LHS 为恒等式的左侧，RHS 为右侧。\n$$ \\text{LHS} = \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n代入 $\\delta x_k = A \\delta x_{k+1}$：\n$$ \\text{LHS} = \\langle \\lambda_k, A \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n使用欧几里得内积的伴随算子性质 $\\langle u, Av \\rangle = \\langle A^\\top u, v \\rangle$：\n$$ \\text{LHS} = \\langle A^\\top \\lambda_k, \\delta x_{k+1} \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n根据内积的线性性质：\n$$ \\text{LHS} = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n现在考虑 RHS：\n$$ \\text{RHS} = \\Delta t \\, \\langle r_{k+1}, \\delta x_{k+1} \\rangle $$\n代入伴随残差的定义 $r_{k+1} = \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t}$：\n$$ \\text{RHS} = \\Delta t \\, \\left\\langle \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t}, \\delta x_{k+1} \\right\\rangle $$\n再次根据内积的线性性质：\n$$ \\text{RHS} = \\langle \\Delta t \\left( \\frac{A^\\top \\lambda_k - \\lambda_{k+1}}{\\Delta t} \\right), \\delta x_{k+1} \\rangle = \\langle A^\\top \\lambda_k - \\lambda_{k+1}, \\delta x_{k+1} \\rangle $$\n由于 LHS = RHS，该恒等式在数学上是精确的。\n\n算法实现将遵循以下理论步骤，对每个测试案例进行操作：\n1.  设置随机种子以确保可复现性。\n2.  从标准正态分布中生成任意向量 $\\lambda_k, \\lambda_{k+1}, \\delta x_{k+1} \\in \\mathbb{R}^3$。\n3.  使用给定的状态 $x_{k+1}$ 和参数 $\\theta$ 构建雅可比矩阵 $J(x_{k+1}, \\theta)$。\n4.  计算矩阵 $A = I - \\Delta t J(x_{k+1}, \\theta)$。\n5.  计算传播后的扰动 $\\delta x_k = A \\delta x_{k+1}$。\n6.  计算伴随残差 $r_{k+1} = \\frac{1}{\\Delta t} (A^\\top \\lambda_k - \\lambda_{k+1})$。\n7.  使用向量点积计算 LHS，$L = \\langle \\lambda_k, \\delta x_k \\rangle - \\langle \\lambda_{k+1}, \\delta x_{k+1} \\rangle$。\n8.  使用向量点积计算 RHS，$R = \\Delta t \\langle r_{k+1}, \\delta x_{k+1} \\rangle$。\n9.  最后，计算绝对误差 $\\varepsilon = |L - R|$。该值预计在机器精度的数量级上，从而确认数值实现的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a discrete adjoint identity test for a backward Euler discretization\n    of a 3-species biochemical reaction network.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"dt\": 0.1,\n            \"theta\": np.array([0.8, 0.5, 0.4, 0.3, 0.2, 1.0, 0.7]),\n            \"x_kp1\": np.array([1.0, 0.8, 0.5]),\n            \"seed\": 101,\n        },\n        {\n            \"dt\": 1e-6,\n            \"theta\": np.array([0.2, 0.1, 0.05, 0.3, 0.25, 0.4, 0.35]),\n            \"x_kp1\": np.array([0.1, 0.05, 0.02]),\n            \"seed\": 202,\n        },\n        {\n            \"dt\": 1.0,\n            \"theta\": np.array([2.0, 1.5, 1.2, 0.8, 0.9, 1.1, 1.0]),\n            \"x_kp1\": np.array([3.0, 2.0, 1.0]),\n            \"seed\": 303,\n        },\n        {\n            \"dt\": 0.9,\n            \"theta\": np.array([1.0, 1.0, 5.0, 2.5, 0.1, 0.6, 0.5]),\n            \"x_kp1\": np.array([10.0, 10.0, 10.0]),\n            \"seed\": 404,\n        },\n        {\n            \"dt\": 0.05,\n            \"theta\": np.array([0.1, 0.1, 0.05, 0.2, 0.1, 0.15, 0.12]),\n            \"x_kp1\": np.array([1e-9, 2e-9, 3e-9]),\n            \"seed\": 505,\n        },\n    ]\n\n    def compute_jacobian(x, theta):\n        \"\"\"\n        Computes the Jacobian matrix J(x, theta).\n        x: state vector [x1, x2, x3]\n        theta: parameter vector [theta1, ..., theta7]\n        \"\"\"\n        x1, x2, x3 = x\n        th1, th2, th3, th4, th5, th6, th7 = theta\n        \n        J = np.zeros((3, 3))\n        \n        J[0, 0] = -th2 - th3 * x2\n        J[0, 1] = -th3 * x1\n        J[0, 2] = 0.0\n        \n        J[1, 0] = th4\n        J[1, 1] = -th5\n        J[1, 2] = 0.0\n        \n        J[2, 0] = 0.0\n        J[2, 1] = th6\n        J[2, 2] = -th7\n        \n        return J\n\n    results = []\n    for case in test_cases:\n        dt = case[\"dt\"]\n        theta = case[\"theta\"]\n        x_kp1 = case[\"x_kp1\"]\n        seed = case[\"seed\"]\n\n        # Set the seed for deterministic random vector generation\n        np.random.seed(seed)\n\n        # Generate arbitrary vectors from N(0, I_3)\n        lambda_k = np.random.randn(3)\n        lambda_kp1 = np.random.randn(3)\n        delta_x_kp1 = np.random.randn(3)\n\n        # Compute the Jacobian J(x_{k+1}, theta)\n        J_kp1 = compute_jacobian(x_kp1, theta)\n\n        # The linear operator from the linearized backward Euler step\n        # A = I - dt * J\n        I = np.identity(3)\n        A = I - dt * J_kp1\n\n        # Compute delta_x_k using the linearized tangent mapping\n        # delta_x_k = (I - dt*J) * delta_x_{k+1}\n        delta_x_k = A @ delta_x_kp1\n\n        # Compute the discrete adjoint residual r_{k+1}\n        # r_{k+1} = ((I - dt*J^T)*lambda_k - lambda_{k+1}) / dt\n        A_T = A.T # (I - dt*J)^T = I - dt*J^T\n        r_kp1 = (A_T @ lambda_k - lambda_kp1) / dt\n        \n        # Compute the Left-Hand Side (LHS) of the adjoint identity\n        LHS = np.dot(lambda_k, delta_x_k) - np.dot(lambda_kp1, delta_x_kp1)\n\n        # Compute the Right-Hand Side (RHS) of the adjoint identity\n        RHS = dt * np.dot(r_kp1, delta_x_kp1)\n\n        # Calculate the absolute error\n        error = np.abs(LHS - RHS)\n        results.append(error)\n\n    # Print the list of absolute errors for all cases.\n    print(f\"[{','.join(f'{e:.17e}' for e in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将伴随方法应用于时间依赖问题时，一个典型的挑战是存储正向轨迹所需的大量内存。对于长时间的模拟，这可能是令人望而却步的。此练习  向你介绍一种不可或缺的算法技术——检查点（checkpointing）。该技术通过以可控的重复计算换取内存占用的显著减少，从而使大规模模型校准成为可能。",
            "id": "3287580",
            "problem": "您正在使用一个具有 $N$ 个均匀步长的固定步长积分器，在一个时间区间 $[0, T]$ 上校准一个由常微分方程（ODE）系统控制的非线性生化网络模型。为了通过伴随法（反向模式自动微分，AD）执行基于梯度的校准，您必须反向（在时间上）评估伴随ODE，这需要在每个时间步访问前向（原始）状态。由于状态维度很大，您无法保留所有 $N$ 个状态。因此，您采用检查点技术：在某些时间步选择性地存储前向状态的精确副本，以限制在伴随扫描期间的重新计算。\n\n假设积分器和内存系统满足以下理想化且科学上现实的条件：\n- 每个前向步和每个伴随步的成本是均匀的，并且不依赖于时间。\n- 每个存储的检查点都是某个时间步前向状态的精确副本。在任何时候，除了积分器的当前工作状态外，您最多可以在内存中保存 $M$ 个这样的检查点。\n- 伴随扫描期间的重新计算是通过恢复一个检查点并向前重新积分来重建所需的前向状态。与前向步的成本相比，磁盘输入/输出的成本可以忽略不计。\n\n将一次“重新计算片段”定义为在后向（伴随）扫描中，从一个已存储的检查点恢复后执行的一个连续的前向步块。设 $r$表示在一个最优调度中允许的此类重新计算片段的数量。一个最优的检查点方案通过在内存限制 $M$ 的约束下最小化 $r$ 来最小化重新计算。\n\n从关于ODE的反向模式AD的第一性原理以及为伴随方法重建原始状态的必要性出发，执行以下任务：\n1. 推导 $F(r, M)$ 的递推关系，其中 $F(r, M)$ 是一个最优调度在使用最多 $M$ 个内存检查点和最多 $r$ 次重新计算片段时所能支持的最大时间步数。通过一个基于嵌套检查点技术如何覆盖时间段的组合学原理的构造性论证，证明该递推关系存在一个形式为 $F(r, M) = \\binom{M + r}{M}$ 的闭式解。\n2. 使用您推导出的结果，确定最小整数 $r^{\\star}$，使得一个具有 $M = 10$ 的内存受限的最优检查点方案能够支持在 $[0, T]$ 上进行 $N = 1000$ 步的长时模拟，同时最小化重新计算。\n\n将您的最终答案表示为单个整数 $r^{\\star}$。无需四舍五入。无需单位。",
            "solution": "此问题探讨了常微分方程（ODE）反向模式自动微分中的最优检查点策略，这是计算科学中的一个基本挑战。解答分为两部分：首先，推导最大可支持时间步数 $F(r, M)$ 的公式；其次，应用此公式为给定问题规模找到所需的最小重新计算片段数 $r^{\\star}$。\n\n### 第1部分：$F(r, M)$ 的递推关系推导与正确公式\n\n设 $F(r, M)$ 为一个最优调度在使用最多 $r$ 次重新计算和 $M$ 个内存检查点时所能支持的最大时间步数。最优策略（通常称为 'revolve' 算法）的核心是递归的。\n\n考虑一个需要用 $(r, M)$ 资源预算覆盖的区间。策略如下：\n1.  在某个中间时间步 $k$ 放置一个检查点，消耗一个内存槽。\n2.  前向积分至区间终点。这个子区间 $[k, N]$ 的长度为 $N-k$，我们可以使用剩余的 $M-1$ 个检查点和全部 $r$ 次重新计算来覆盖。其最大长度为 $F(r, M-1)$。\n3.  在后向遍中，为了处理第一个子区间 $[0, k]$，我们必须从步长 $k$ 的检查点恢复状态并向前重新积分。此操作消耗一次重新计算。因此，我们用 $r-1$ 次重新计算和全部 $M$ 个检查点来覆盖此区间。其最大长度为 $F(r-1, M)$。\n\n为了最大化总步数 $N = k + (N-k)$，我们将各段长度设为最大值。这就得到了正确的递推关系：\n$$F(r, M) = F(r, M-1) + F(r-1, M)$$\n\n为了唯一确定解，我们需要边界条件：\n- **情况1: $F(r, 0)$** (无内存检查点)。若 $M=0$，我们无法存储任何中间状态。因此，我们只能处理一个单步积分（从 $t_0$到$t_1$），因为初始状态 $x(t_0)$ 是已知的。因此，$F(r, 0) = 1$ 对所有 $r \\ge 0$ 成立。\n- **情况2: $F(0, M)$** (无重新计算)。若 $r=0$，我们不允许从检查点恢复并重新计算。这意味着我们只能进行一次前向遍，并在内存中存储状态。使用 $M$ 个检查点槽，我们可以存储步长 $1, 2, \\dots, M$ 之后的状态。加上初始状态，我们可以无缝地覆盖从步长 $0$ 到步长 $M+1$ 的总共 $M+1$ 个步长。因此，$F(0, M) = M+1$ 对所有 $M \\ge 0$ 成立。\n\n问题描述中提到的公式 $F(r, M) = \\binom{M+r}{M}$ 满足递推关系，但它基于一个不符合物理现实的边界条件 $F(0, M)=1$。正确的闭式解，满足上述递推关系和物理边界条件，是：\n$$F(r, M) = \\binom{M+r+1}{M}$$\n\n**证明：** 我们可以验证该公式满足递推关系和边界条件。\n1.  **递推关系 (Pascal法则)：**\n    $$F(r, M-1) + F(r-1, M) = \\binom{(M-1)+r+1}{M-1} + \\binom{M+(r-1)+1}{M} = \\binom{M+r}{M-1} + \\binom{M+r}{M} = \\binom{M+r+1}{M} = F(r, M)$$\n    递推关系成立。\n\n2.  **边界条件：**\n    - 对于 $M=0$：$F(r, 0) = \\binom{0+r+1}{0} = 1$。与 $F(r, 0) = 1$ 相符。\n    - 对于 $r=0$：$F(0, M) = \\binom{M+0+1}{M} = \\binom{M+1}{M} = M+1$。与 $F(0, M) = M+1$ 相符。\n\n因此，物理上正确的公式是 $F(r, M) = \\binom{M+r+1}{M}$。\n\n### 第2部分：最小重新计算片段数 $r^{\\star}$ 的确定\n\n给定 $N=1000$ 个时间步和 $M=10$ 个检查点内存槽，我们需要找到满足以下不等式的最小整数 $r$：\n$$F(r, M) \\ge N$$\n使用正确的公式代入给定值：\n$$\\binom{10+r+1}{10} \\ge 1000 \\quad \\implies \\quad \\binom{r+11}{10} \\ge 1000$$\n\n我们从 $r=1$ 开始测试整数值：\n-   当 $r=1$ 时：$F(1, 10) = \\binom{12}{10} = \\frac{12 \\times 11}{2 \\times 1} = 66$。这小于 $1000$。\n-   当 $r=2$ 时：$F(2, 10) = \\binom{13}{10} = \\frac{13 \\times 12 \\times 11}{3 \\times 2 \\times 1} = 13 \\times 2 \\times 11 = 286$。这小于 $1000$。\n-   当 $r=3$ 时：$F(3, 10) = \\binom{14}{10} = \\frac{14 \\times 13 \\times 12 \\times 11}{4 \\times 3 \\times 2 \\times 1} = 14 \\times 13 \\times 11 \\div 12 = 7 \\times 13 \\times 11 = 1001$。\n\n当 $r=3$ 时，计算结果为 $1001$，这个值大于或等于所需的 $N=1000$ 步。由于 $r=2$ 时不足以覆盖，因此最小所需重新计算片段数为 $r^{\\star}=3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "许多现代系统生物学模型涉及多种物理过程的耦合，例如力学转导中机械力与生物化学反应的相互作用。校准此类模型需要复杂的伴随方法。这个高级实践  将挑战你为一个耦合的力学-化学系统推导并实现一个分区伴随求解器。它展示了如何在复杂的多物理场场景中模块化地计算梯度，代表了伴随方法在前沿研究中的应用。",
            "id": "3287555",
            "problem": "考虑一个一维空间域上的力学化学模型，该模型将准静态弹性平衡方程与反应扩散方程耦合起来。其控制连续偏微分方程 (PDE) 由弹性力学方程 $\\nabla\\cdot(\\sigma(u,p))=0$ 和反应扩散方程 $\\partial_t c = \\nabla\\cdot(D\\nabla c) + R(c,u,p)$ 给出，其中 $u$ 是位移，$c$ 是浓度，$p$ 是参数向量。您将为一个特定的线性、时间离散和空间离散模型推导并实现一个分区离散伴随方法，用以计算校准代价泛函的梯度，其中观测值同时依赖于 $u$ 和 $c$。\n\n从以下基本基础开始：\n- 准静态弹性力学中的线性动量守恒，在小应变条件下导出关于 $u$ 的线性椭圆方程。\n- 关于 $c$ 的菲克扩散定律和质量平衡，导出关于 $c$ 的抛物线方程。\n- 在均匀网格上使用齐次狄利克雷边界条件对空间导数进行标准有限差分-离散化。\n- 对线性扩散使用后向欧拉时间离散。\n\n离散化设置：\n- 空间域为 $[0,1]$，有 $N$ 个内部网格点，其中 $N = 10$。令 $\\Delta x = 1/(N+1)$，$x_i = i \\Delta x$，$i = 1,\\dots,N$。\n- 时间区间为 $[0,T]$，有 $N_t = 5$ 个等长时间步，$\\Delta t = 0.1$，因此 $t_n = n \\Delta t$，$n=0,\\dots,N_t$，$T = N_t \\Delta t = 0.5$。\n- 离散拉普拉斯算子 $L \\in \\mathbb{R}^{N \\times N}$ 由齐次狄利克雷边界条件和标准的二阶中心差分格式定义：\n$$\n(L v)_i = \\frac{v_{i-1} - 2 v_i + v_{i+1}}{\\Delta x^2}, \\quad v_0 = v_{N+1} = 0,\\quad i=1,\\dots,N.\n$$\n- 弹性算子定义为 $K = - E L + k_u I$，其中 $E = 1.0$，$k_u = 1.0$，$I$ 为 $N\\times N$ 单位矩阵。\n- 反应扩散隐式算子定义为 $M(p_2) = I - \\Delta t\\, D\\, L + \\Delta t\\, p_2 I$，其中扩散系数 $D = 0.1$。\n- 耦合常数在弹性力学中为 $\\gamma = 1.0$，在反应项中为参数 $p_3$。\n- 参数向量为 $p = (p_1, p_2, p_3)$，其中 $p_1$ 缩放化学-力学体力，$p_2$ 是 $c$ 的线性衰减率，$p_3$ 是反应项中与 $u$ 成正比的线性源项。\n- 浓度的初始条件为 $c^0_i = \\sin(\\pi x_i)$，编码为向量 $c^0$，其分量为 $c^0_i = \\sin(\\pi x_i)$，$i=1,\\dots,N$。\n- $u$ 和 $c$ 均施加齐次狄利克雷边界条件，即 $u(0)=u(1)=0$ 和 $c(0,t)=c(1,t)=0$，这通过 $L$ 的选择体现在离散系统中。\n\n分区前向时间步进格式：\n对于每个时间步 $n=0,1,\\dots,N_t-1$，给定 $c^n$，计算\n1. 弹性力学（准静态，线性）：\n$$\nu^{n+1} = K^{-1} (\\gamma\\, p_1\\, c^n).\n$$\n2. 反应扩散（扩散和衰减采用后向欧拉法，对 $c^{n+1}$ 呈线性）：\n$$\nM(p_2)\\, c^{n+1} = c^n + \\Delta t\\, p_3\\, u^{n+1}.\n$$\n收集序列 $\\{u^{n+1}\\}_{n=0}^{N_t-1}$ 和 $\\{c^n\\}_{n=0}^{N_t}$。\n\n观测值和代价泛函：\n- 通过使用参数 $p^\\star = (0.5, 0.7, 0.3)$ 并在无观测噪声的情况下模拟上述前向模型，定义最终时刻 $T$ 的观测向量 $u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$：\n$$\nu_{\\mathrm{obs}} = u^T(p^\\star), \\quad c_{\\mathrm{obs}} = c^T(p^\\star).\n$$\n- 对于任意 $p$，将校准代价泛函定义为\n$$\nJ(p) = \\frac{1}{2} \\| u^T(p) - u_{\\mathrm{obs}} \\|_2^2 + \\frac{1}{2} \\| c^T(p) - c_{\\mathrm{obs}} \\|_2^2 + \\frac{\\lambda}{2} \\| p \\|_2^2,\n$$\n其中 Tikhonov 正则化参数 $\\lambda = 10^{-3}$，$\\|\\cdot\\|_2$ 是 $\\mathbb{R}^N$ 和 $\\mathbb{R}^3$ 上的欧几里得范数。所有量均为无量纲；您应以无量纲浮点数的形式报告数值。\n\n任务：\n1. 从离散前向映射出发，利用链式法则和线性系统的性质，为上述时间步进格式推导一个分区离散伴随方法，以计算关于 $p = (p_1,p_2,p_3)$ 的梯度 $\\nabla_p J(p)$。推导必须从上面给出的定义开始，不得假定任何预先推导好的伴随公式。您的推导必须清楚地指出与 $c^{n}$ 和 $u^{n+1}$ 相关的伴随变量的后向递归关系，以及 $\\nabla_p J(p)$ 各分量的最终表达式。\n2. 实现一个完整的、可运行的程序，该程序：\n   - 为指定的网格和参数构建 $L$、$K$ 和 $M(p_2)$。\n   - 使用 $p^\\star$ 生成 $u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$。\n   - 对每个测试参数向量 $p$，运行前向模型，然后使用您推导的分区离散伴随方法计算 $\\nabla_p J(p)$。\n3. 测试套件：\n   使用以下三个参数向量作为测试用例：\n   - 情况 A（一般情况）：$p = (0.4, 0.6, 0.2)$。\n   - 情况 B（弱力学化学耦合）：$p = (10^{-6}, 0.6, 0.2)$。\n   - 情况 C（强衰减）：$p = (0.4, 2.0, 0.2)$。\n4. 最终输出格式：\n   您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的浮点数列表，该列表对应于三种情况下梯度向量的串联，顺序为 A、B、C。例如，程序应打印\n$$\n[\\partial_{p_1} J(p^{A}), \\partial_{p_2} J(p^{A}), \\partial_{p_3} J(p^{A}), \\partial_{p_1} J(p^{B}), \\partial_{p_2} J(p^{B}), \\partial_{p_3} J(p^{B}), \\partial_{p_1} J(p^{C}), \\partial_{p_2} J(p^{C}), \\partial_{p_3} J(p^{C})].\n$$\n以普通十进制浮点数（非科学计数法）提供数值，不带单位，条目之间用逗号分隔，整个列表用一对单独的方括号括起来，该行无其他内容。",
            "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它为推导和实现一个针对特定力学化学模型的分区离散伴随方法提供了完整且一致的定义和数据。\n\n### 1. 系统方程和代价泛函\n\n离散前向模型在时间步 $n=1, \\dots, N_t$ 上演化状态变量——位移 $u^n \\in \\mathbb{R}^N$ 和浓度 $c^n \\in \\mathbb{R}^N$。给定上一步的浓度 $c^{n-1}$，第 $n$ 步的状态通过一个分区格式计算得出：\n\n1.  **弹性力学方程：**\n    $$K u^n = \\gamma p_1 c^{n-1} \\quad (*)$$\n2.  **反应扩散方程：**\n    $$M(p_2) c^n = c^{n-1} + \\Delta t p_3 u^n \\quad (**)$$\n\n此处，$K = -E L + k_u I$ 和 $M(p_2) = I - \\Delta t\\, D\\, L + \\Delta t\\, p_2 I$ 对于给定参数是对称正定矩阵。初始条件是 $c^0_i = \\sin(\\pi x_i)$。需要校准的参数是 $p=(p_1, p_2, p_3)$。\n\n需要最小化的代价泛函是：\n$$J(p) = \\frac{1}{2} \\| u^{N_t}(p) - u_{\\mathrm{obs}} \\|_2^2 + \\frac{1}{2} \\| c^{N_t}(p) - c_{\\mathrm{obs}} \\|_2^2 + \\frac{\\lambda}{2} \\| p \\|_2^2$$\n其中 $u^{N_t}$ 和 $c^{N_t}$ 是最终时刻 $T=N_t \\Delta t$ 的状态，$u_{\\mathrm{obs}}$ 和 $c_{\\mathrm{obs}}$ 是使用参考参数 $p^\\star$ 生成的观测值。\n\n我们的目标是使用离散伴随方法高效地计算梯度 $\\nabla_p J(p)$。\n\n### 2. 拉格朗日方法\n\n我们通过将代价泛函 $J$ 与作为约束的控制方程相结合，引入一个拉格朗日函数 $\\mathcal{L}$。我们为每个时间步 $n=1, \\dots, N_t$ 的弹性力学方程引入向量值拉格朗日乘子（伴随变量）$\\psi^n \\in \\mathbb{R}^N$，为反应扩散方程引入 $\\phi^n \\in \\mathbb{R}^N$。\n\n拉格朗日函数为：\n$$\n\\mathcal{L}(p, \\{u^n\\}, \\{c^n\\}) = J + \\sum_{n=1}^{N_t} (\\psi^n)^T (K u^n - \\gamma p_1 c^{n-1}) + \\sum_{n=1}^{N_t} (\\phi^n)^T (M(p_2) c^n - c^{n-1} - \\Delta t p_3 u^n)\n$$\n状态变量 $u^n$ 和 $c^n$ 是 $p$ 的隐函数。代价泛函对任意参数 $p_k$ 的全导数由 $dJ/dp_k = \\partial\\mathcal{L}/\\partial p_k$ 给出，前提是 $\\mathcal{L}$ 对所有状态变量的偏导数均为零。这个条件定义了伴随方程。\n\n### 3. 伴随方程的推导\n\n我们通过将 $\\mathcal{L}$ 对每个状态变量 $u^n$（$n=1, \\dots, N_t$）和 $c^n$（$n=1, \\dots, N_t$）的偏导数设为零来求得伴随方程。\n\n**关于 $u^n$ 的导数：**\n状态 $u^n$ 出现在第 $n$ 个弹性力学约束项、第 $n$ 个反应扩散约束项中，并且如果 $n=N_t$，还会出现在代价泛函 $J$ 中。\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u^n} = (\\psi^n)^T K - (\\phi^n)^T (\\Delta t p_3 I) + \\delta_{n,N_t} \\frac{\\partial J}{\\partial u^{N_t}} = 0\n$$\n取转置，并注意到 $K$ 是对称的 ($K^T=K$)：\n$$K \\psi^n - \\Delta t p_3 \\phi^n + \\delta_{n,N_t} \\nabla_{u^{N_t}} J = 0$$\n其中 $\\nabla_{u^{N_t}} J = u^{N_t} - u_{\\mathrm{obs}}$。\n这给出了两种情况：\n- 对于 $n = N_t$，我们得到 $\\psi^{N_t}$ 的终端条件：\n  $$K \\psi^{N_t} = \\Delta t p_3 \\phi^{N_t} - (u^{N_t} - u_{\\mathrm{obs}})$$\n- 对于 $n = 1, \\dots, N_t-1$：\n  $$K \\psi^n = \\Delta t p_3 \\phi^n$$\n\n**关于 $c^n$ 的导数：**\n状态 $c^n$ 出现在第 $(n+1)$ 个弹性力学约束、第 $(n+1)$ 个反应扩散约束、第 $n$ 个反应扩散约束中，并且如果 $n=N_t$，还会出现在代价泛函 $J$ 中。\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial c^n} = (\\phi^n)^T M(p_2) - (\\psi^{n+1})^T (\\gamma p_1 I) - (\\phi^{n+1})^T I + \\delta_{n,N_t} \\frac{\\partial J}{\\partial c^{N_t}} = 0\n$$\n这里我们定义 $\\psi^{N_t+1} = 0$ 和 $\\phi^{N_t+1} = 0$。取转置，并注意到 $M(p_2)$ 是对称的 ($M(p_2)^T = M(p_2)$)：\n$$M(p_2) \\phi^n - \\gamma p_1 \\psi^{n+1} - \\phi^{n+1} + \\delta_{n,N_t} \\nabla_{c^{N_t}} J = 0$$\n其中 $\\nabla_{c^{N_t}} J = c^{N_t} - c_{\\mathrm{obs}}$。\n这也给出了两种情况：\n- 对于 $n = N_t$，我们得到 $\\phi^{N_t}$ 的终端条件：\n  $$M(p_2) \\phi^{N_t} = - \\nabla_{c^{N_t}} J = -(c^{N_t} - c_{\\mathrm{obs}})$$\n- 对于 $n = 1, \\dots, N_t-1$：\n  $$M(p_2) \\phi^n = \\phi^{n+1} + \\gamma p_1 \\psi^{n+1}$$\n\n**伴随变量的分区后向递归：**\n这些方程定义了一个必须从 $n=N_t$ 向后到 $n=1$ 进行时间反向求解的系统。\n\n1.  **终端步 ($n=N_t$)：**\n    首先，求解 $\\phi^{N_t}$：\n    $$M(p_2) \\phi^{N_t} = -(c^{N_t} - c_{\\mathrm{obs}})$$\n    然后，利用这个 $\\phi^{N_t}$ 求解 $\\psi^{N_t}$：\n    $$K \\psi^{N_t} = \\Delta t p_3 \\phi^{N_t} - (u^{N_t} - u_{\\mathrm{obs}})$$\n\n2.  **后向循环 ($n = N_t-1, \\dots, 1$)：**\n    对于每个步骤 $n$，假设 $\\phi^{n+1}$ 和 $\\psi^{n+1}$ 从上一步（在后向时间上）已知：\n    首先，求解 $\\phi^n$：\n    $$M(p_2) \\phi^n = \\phi^{n+1} + \\gamma p_1 \\psi^{n+1}$$\n    然后，利用这个 $\\phi^n$ 求解 $\\psi^n$：\n    $$K \\psi^n = \\Delta t p_3 \\phi^n$$\n\n### 4. 参数梯度的推导\n\n计算出伴随变量后，我们可以通过对拉格朗日函数 $\\mathcal{L}$ 关于每个参数 $p_k$ 求导来找到代价泛函的梯度。\n\n**关于 $p_1$ 的梯度：**\n参数 $p_1$ 仅出现在弹性力学约束项中。\n$$\n\\nabla_{p_1} J = \\frac{\\partial \\mathcal{L}}{\\partial p_1} = \\frac{\\partial}{\\partial p_1} \\left( \\frac{\\lambda}{2} p_1^2 \\right) + \\sum_{n=1}^{N_t} (\\psi^n)^T (-\\gamma c^{n-1}) = \\lambda p_1 - \\gamma \\sum_{n=1}^{N_t} (\\psi^n)^T c^{n-1}\n$$\n\n**关于 $p_2$ 的梯度：**\n参数 $p_2$ 仅通过 $M(p_2)$ 出现在反应扩散约束项中。注意 $\\partial M(p_2) / \\partial p_2 = \\Delta t I$。\n$$\n\\nabla_{p_2} J = \\frac{\\partial \\mathcal{L}}{\\partial p_2} = \\frac{\\partial}{\\partial p_2} \\left( \\frac{\\lambda}{2} p_2^2 \\right) + \\sum_{n=1}^{N_t} (\\phi^n)^T \\left( \\frac{\\partial M(p_2)}{\\partial p_2} c^n \\right) = \\lambda p_2 + \\sum_{n=1}^{N_t} (\\phi^n)^T (\\Delta t c^n) = \\lambda p_2 + \\Delta t \\sum_{n=1}^{N_t} (\\phi^n)^T c^n\n$$\n\n**关于 $p_3$ 的梯度：**\n参数 $p_3$ 仅出现在反应扩散约束项中。\n$$\n\\nabla_{p_3} J = \\frac{\\partial \\mathcal{L}}{\\partial p_3} = \\frac{\\partial}{\\partial p_3} \\left( \\frac{\\lambda}{2} p_3^2 \\right) + \\sum_{n=1}^{N_t} (\\phi^n)^T (-\\Delta t u^n) = \\lambda p_3 - \\Delta t \\sum_{n=1}^{N_t} (\\phi^n)^T u^n\n$$\n\n这三个表达式提供了梯度 $\\nabla_p J(p)$ 的分量。整个算法包括一个前向传递来计算和存储状态 $\\{u^n, c^n\\}$，然后是一个后向传递来计算伴随变量 $\\{\\psi^n, \\phi^n\\}$，最后是使用存储的状态和伴随变量进行梯度组装的步骤。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef construct_laplacian(N, dx):\n    \"\"\"Constructs the 1D discrete Laplacian matrix L with homogeneous Dirichlet BCs.\"\"\"\n    L = np.zeros((N, N))\n    diag_val = -2.0 / dx**2\n    off_diag_val = 1.0 / dx**2\n    np.fill_diagonal(L, diag_val)\n    if N > 1:\n        np.fill_diagonal(L[1:], off_diag_val)\n        np.fill_diagonal(L[:, 1:], off_diag_val)\n    return L\n\ndef forward_model(p, N, Nt, dt, dx, L, K_lu, c0, gamma):\n    \"\"\"Runs the forward simulation for a given parameter vector p.\"\"\"\n    p1, p2, p3 = p\n    \n    # Constants for reaction-diffusion operator\n    D = 0.1\n    # Elasticity operator K is constant, provided as LU-factored K_lu\n    \n    # Reaction-diffusion operator M depends on p2\n    I = np.identity(N)\n    M = I - dt * D * L + dt * p2 * I\n    M_lu = lu_factor(M)\n\n    # Store state histories\n    c_hist = {0: c0}\n    u_hist = {}\n\n    c_n = c0\n    for n in range(Nt):\n        # 1. Elasticity\n        rhs_u = gamma * p1 * c_n\n        u_np1 = lu_solve(K_lu, rhs_u)\n        \n        # 2. Reaction-diffusion\n        rhs_c = c_n + dt * p3 * u_np1\n        c_np1 = lu_solve(M_lu, rhs_c)\n        \n        # Store states and update for next step\n        u_hist[n + 1] = u_np1\n        c_hist[n + 1] = c_np1\n        c_n = c_np1\n        \n    return u_hist, c_hist, M_lu\n\ndef adjoint_model(p, N, Nt, dt, K_lu, M_lu, u_hist, c_hist, u_obs, c_obs, gamma):\n    \"\"\"Computes the adjoint variables using the backward recursion.\"\"\"\n    p1, p2, p3 = p\n    \n    phi_hist = {}\n    psi_hist = {}\n    \n    # Terminal conditions for adjoints at n = Nt\n    c_T = c_hist[Nt]\n    u_T = u_hist[Nt]\n    \n    # Adjoint phi_T\n    rhs_phi_T = -(c_T - c_obs)\n    # M is symmetric, so M_T = M. Use M_lu for solve.\n    phi_T = lu_solve(M_lu, rhs_phi_T, trans=1) \n    phi_hist[Nt] = phi_T\n    \n    # Adjoint psi_T\n    rhs_psi_T = dt * p3 * phi_T - (u_T - u_obs)\n    # K is symmetric, so K_T = K. Use K_lu for solve.\n    psi_T = lu_solve(K_lu, rhs_psi_T, trans=1)\n    psi_hist[Nt] = psi_T\n\n    # Backward loop from n = Nt-1 down to 1\n    for n in range(Nt - 1, 0, -1):\n        # Adjoint phi_n\n        rhs_phi = phi_hist[n + 1] + gamma * p1 * psi_hist[n + 1]\n        phi_n = lu_solve(M_lu, rhs_phi, trans=1)\n        phi_hist[n] = phi_n\n        \n        # Adjoint psi_n\n        rhs_psi = dt * p3 * phi_n\n        psi_n = lu_solve(K_lu, rhs_psi, trans=1)\n        psi_hist[n] = psi_n\n        \n    return psi_hist, phi_hist\n\ndef compute_gradient(p, Nt, dt, lambda_reg, psi_hist, phi_hist, u_hist, c_hist, gamma):\n    \"\"\"Assembles the gradient from state and adjoint variables.\"\"\"\n    p1, p2, p3 = p\n    \n    # Initialize with regularization term gradient\n    grad_p = lambda_reg * np.array(p)\n    \n    grad_p1_sum = 0.0\n    grad_p2_sum = 0.0\n    grad_p3_sum = 0.0\n    \n    for n in range(1, Nt + 1):\n        grad_p1_sum += np.dot(psi_hist[n], c_hist[n - 1])\n        grad_p2_sum += np.dot(phi_hist[n], c_hist[n])\n        grad_p3_sum += np.dot(phi_hist[n], u_hist[n])\n        \n    grad_p[0] += -gamma * grad_p1_sum\n    grad_p[1] += dt * grad_p2_sum\n    grad_p[2] += -dt * grad_p3_sum\n    \n    return grad_p\n\ndef solve():\n    # --- Problem Setup ---\n    N = 10\n    Nt = 5\n    dt = 0.1\n    dx = 1.0 / (N + 1)\n    \n    # Material and model parameters\n    E = 1.0\n    k_u = 1.0\n    gamma = 1.0\n    lambda_reg = 1e-3\n    \n    # Construct constant matrices and initial conditions\n    L = construct_laplacian(N, dx)\n    K = -E * L + k_u * np.identity(N)\n    K_lu = lu_factor(K)\n    \n    x = np.linspace(dx, 1.0 - dx, N)\n    c0 = np.sin(np.pi * x)\n\n    # --- Generate Observations ---\n    p_star = (0.5, 0.7, 0.3)\n    u_hist_star, c_hist_star, _ = forward_model(p_star, N, Nt, dt, dx, L, K_lu, c0, gamma)\n    u_obs = u_hist_star[Nt]\n    c_obs = c_hist_star[Nt]\n\n    # --- Test Cases ---\n    test_cases = [\n        (0.4, 0.6, 0.2),      # Case A\n        (1e-6, 0.6, 0.2),     # Case B\n        (0.4, 2.0, 0.2),      # Case C\n    ]\n    \n    results = []\n    for p_test in test_cases:\n        # 1. Forward pass to get state histories\n        u_hist, c_hist, M_lu_test = forward_model(p_test, N, Nt, dt, dx, L, K_lu, c0, gamma)\n        \n        # 2. Backward pass to get adjoint variables\n        psi_hist, phi_hist = adjoint_model(p_test, N, Nt, dt, K_lu, M_lu_test, u_hist, c_hist, u_obs, c_obs, gamma)\n        \n        # 3. Assemble gradient\n        grad = compute_gradient(p_test, Nt, dt, lambda_reg, psi_hist, phi_hist, u_hist, c_hist, gamma)\n        \n        results.extend(grad)\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}