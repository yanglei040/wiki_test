{
    "hands_on_practices": [
        {
            "introduction": "在我们构建规则来描述分子相互作用之前，我们必须首先精确地定义这些规则所作用的分子组分。本练习将帮助您巩固对生物网络生成语言（BioNetGen Language, BNGL）中基本“语法”的理解。通过它，您将练习如何声明分子类型、其上的位点，以及这些位点的所有可能状态，这是构建任何基于规则的模型的词汇基础。",
            "id": "3347082",
            "problem": "在 BioNetGen 语言 (BNGL) 中，分子类型声明指定了分子上的一组位点、哪些位点可以携带内部状态，以及哪些位点可以参与键合。内部状态使用波浪号符号 ($\\sim$) 枚举，而键则通过与感叹号符号 ($!$) 一起引入的匹配数字标签来表示。根据 BNGL 已确立的语义：用内部状态枚举声明的位点恰好具有那些可用的内部状态；没有用内部状态枚举声明的位点没有内部状态；每个位点一次最多只能参与一个键；数字键标签除了在模式中配对共享相同标签的两个位点之外，没有内在的身份。考虑分子类型 $A(s1\\sim U\\sim P,\\, s2)$ 和 $B(b)$，其中 $A$ 有两个位点 $s1$ 和 $s2$，$s1$ 具有内部状态 $U$ 和 $P$，而 $B$ 有一个位点 $b$。\n\n仅根据这些定义和约束，确定哪个选项正确地枚举了 $A.s2$ 和 $B.b$ 之间可能的键状态，以及 $A.s1$ 可用的内部状态。选择唯一一个最佳选项，该选项列出了分子类型声明和 BNGL 键合规则所暗示的所有且仅有的允许可能性。\n\nA. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键（没有共享的键标签，例如，$A(s2)$ 和 $B(b)$ 之间没有任何 $!n$ 连接）和单键合（例如，$A(s2!1).B(b!1)$）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。\n\nB. $A.s2$ 和 $B.b$ 之间的键状态：有可数多种可能性，由键标签 $!n$（其中 $n\\in\\mathbb{N}$）区分（例如，$A(s2!1).B(b!1)$、$A(s2!2).B(b!2)$ 等）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。\n\nC. $A.s2$ 和 $B.b$ 之间的键状态：有 $3$ 种可能性——未成键、单键合，或同时通过两个不同的键键合（双键）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。\n\nD. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键和单键合。$A.s1$ 可用的内部状态：有 $3$ 种可能性——$A(s1\\sim U)$、$A(s1\\sim P)$ 和一个代表额外未指定状态的通配符 $A(s1\\sim ?)$。\n\nE. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键和单键合。$A.s1$ 可用的内部状态：没有，因为 $A(s1\\sim U\\sim P)$ 仅约束规则匹配，但并未为 $s1$ 定义实际的内部状态。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取已知信息\n问题为 BioNetGen 语言 (BNGL) 提供了以下定义、规则和约束：\n- **分子声明：** 分子类型声明指定了分子上的一组位点、哪些位点可以携带内部状态，以及哪些位点可以参与键合。\n- **内部状态：** 内部状态使用波浪号符号 ($\\sim$) 枚举。\n- **键：** 键通过与感叹号符号 ($!$) 一起引入的匹配数字标签来表示。\n- **内部状态的语义 (1)：** “用内部状态枚举声明的位点恰好具有那些可用的内部状态”。\n- **内部状态的语义 (2)：** “没有用内部状态枚举声明的位点没有内部状态”。\n- **键的语义 (1)：** “每个位点一次最多只能参与一个键”。\n- **键的语义 (2)：** “数字键标签除了在模式中配对共享相同标签的两个位点之外，没有内在的身份”。\n- **特定分子类型：**\n    - $A(s1\\sim U\\sim P,\\, s2)$：分子 $A$ 有两个位点 $s1$ 和 $s2$。位点 $s1$ 具有内部状态 $U$ 和 $P$。位点 $s2$ 没有声明的内部状态。\n    - $B(b)$：分子 $B$ 有一个位点 $b$，没有声明的内部状态。\n- **问题：** 确定 $A.s2$ 和 $B.b$ 之间可能的键状态以及 $A.s1$ 可用的内部状态。\n\n#### 步骤 2：使用提取的已知信息进行验证\n将根据指定标准验证问题陈述。\n\n- **科学依据：** 该问题基于 BioNetGen 语言 (BNGL) 的形式语法和语义，BNGL 是计算系统生物学中用于生化网络基于规则建模的成熟软件工具和语言。所提供的规则是 BNGL 核心原则的标准和准确表示。该问题牢固地植根于一个形式化的科学体系中。\n- **良态问题：** 问题定义清晰。规则是确定性的，并为推导所讨论状态的一组唯一可能性提供了完整的基础。问题要求枚举各种可能性，鉴于形式化规则，这是一个明确定义的任务。\n- **客观性：** 语言精确且技术性强，依赖于 BNGL 的既定语义。它没有歧义、主观性或个人观点。\n\n该问题没有表现出任何列出的缺陷：\n1.  **科学或事实不健全：** 关于 BNGL 语义的前提在事实上是正确的。\n2.  **不可形式化或不相关：** 该问题是关于一种形式语言，并且与基于规则的建模主题直接相关。\n3.  **不完整或矛盾的设置：** 提供了所有必要的规则和定义。给定的信息，例如一个位点最多只能有一个键的规则，是一致的。\n4.  **不切实际或不可行：** 该问题是对一个形式系统的概念性分析，物理现实性的问题并不直接适用，但该系统本身旨在模拟真实的生物系统。没有不一致的数据。\n5.  **病态或结构不良：** 问题结构良好，能导出一个唯一的、有意义的答案。\n6.  **伪深刻、琐碎或同义反复：** 该问题需要仔细应用几个不同的规则，并理解它们之间的相互作用，特别是键标签和键状态之间的区别。这是一个关于语言语义的实质性问题。\n7.  **超出科学可验证性：** 答案可以通过查阅官方 BNGL 文档和语义定义来验证。\n\n#### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个关于在科学背景下使用的形式语言语义的良构问题。可以继续进行求解过程。\n\n### 正确答案的推导\n\n该问题要求根据提供的 BNGL 规则确定两组不同的可能性：(1) 位点 $A.s1$ 的内部状态，以及 (2) 位点 $A.s2$ 和 $B.b$ 之间的键状态。\n\n#### 1. $A.s1$ 可用的内部状态\n\n$A$ 的分子类型声明为 $A(s1\\sim U\\sim P,\\, s2)$。问题明确陈述了语义规则：“用内部状态枚举声明的位点恰好具有那些可用的内部状态”。\n\n- 位点 $s1$ 被声明为枚举 $\\sim U\\sim P$。\n- 根据该规则，这意味着 $s1$ 的所有可能内部状态的集合恰好是 $\\{U, P\\}$。\n- 因此，$A.s1$ 恰好有 $2$ 种可能的内部状态。在 BNGL 模式中，这些将表示为 $A(s1\\sim U)$ 和 $A(s1\\sim P)$。\n\n#### 2. $A.s2$ 和 $B.b$ 之间的键状态\n\n键状态的分析涉及两个特定位点 $A.s2$ 和 $B.b$ 之间的关系。我们必须考虑它们之间所有可能的连接状态。\n\n- 第一个相关规则是：“每个位点一次最多只能参与一个键”。\n- 这条规则立即施加了一个强约束。任何给定的位点，如 $A.s2$ 或 $B.b$，只能处于两种情况之一：未成键，或与恰好一个伙伴位点成键。同时与多个伙伴成键的可能性（例如，与同一个伙伴形成“双键”，或与两个不同的伙伴成键）被明确禁止。\n\n让我们枚举这对位点 ($A.s2$、$B.b$) 的可能性：\n\n- **可能性 1：未成键。** 位点 $A.s2$ 和 $B.b$ 没有通过键连接。这是一个有效状态。在 BNGL 中，这将通过缺少共享的键标签来表示，例如，$A(s2), B(b)$ 作为独立的物种或作为更大复合物的一部分存在，而这些位点之间没有直接联系。这构成了一种独特的“键状态”（即未成键的状态）。\n\n- **可能性 2：成键。** 位点 $A.s2$ 通过一个键与位点 $B.b$ 连接。\n    - “每个位点一次最多只能参与一个键”的规则意味着，如果它们成键，必须是通过一个单键。\n    - 现在我们必须考虑关于键的第二条规则：“数字键标签除了在模式中配对共享相同标签的两个位点之外，没有内在的身份”。这是一个关键的语义点。虽然可以使用不同的标签来书写这个键，例如 $A(s2!1).B(b!1)$ 或 $A(s2!5).B(b!5)$，但这些并不是不同*类型*的键或不同的连接*状态*。它们都代表相同的逻辑状态：$A.s2$ 与 $B.b$ 成键。数字仅仅是在复杂模式中正确配对伙伴的索引，而不是键本身的属性。\n    - 因此，在 $A.s2$ 和 $B.b$ 之间只有一种“成键”状态。\n\n结合这些发现，在 $A.s2$ 和 $B.b$ 之间恰好有 $2$ 种可能的键状态：未成键和单键合。\n\n#### 结果总结\n- **$A.s1$ 的内部状态**：恰好有 $2$ 种可能性（$U$ 和 $P$）。\n- **$A.s2$ 和 $B.b$ 之间的键状态**：恰好有 $2$ 种可能性（未成键和单键合）。\n\n### 逐项分析\n\n**A. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键（没有共享的键标签，例如，$A(s2)$ 和 $B(b)$ 之间没有任何 $!n$ 连接）和单键合（例如，$A(s2!1).B(b!1)$）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。**\n- 对键状态的分析是正确的。恰好有两种：未成键和单键合。\n- 对内部状态的分析是正确的。恰好有两种：$U$ 和 $P$。\n- **结论：正确。**\n\n**B. $A.s2$ 和 $B.b$ 之间的键状态：有可数多种可能性，由键标签 $!n$（其中 $n\\in\\mathbb{N}$）区分（例如，$A(s2!1).B(b!1)$、$A(s2!2).B(b!2)$ 等）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。**\n- 对键状态的分析是错误的。它误解了键标签的作用。问题明确指出“数字键标签没有内在的身份”。不同的标签 $!1, !2, \\ldots$ 并不会创建不同的成键状态。\n- **结论：错误。**\n\n**C. $A.s2$ 和 $B.b$ 之间的键状态：有 $3$ 种可能性——未成键、单键合，或同时通过两个不同的键键合（双键）。$A.s1$ 可用的内部状态：恰好有 $2$ 种可能性——$A(s1\\sim U)$ 和 $A(s1\\sim P)$。**\n- 对键状态的分析是错误的。“双键”将要求每个位点参与两个键，这被“每个位点一次最多只能参与一个键”的规则明确禁止。\n- **结论：错误。**\n\n**D. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键和单键合。$A.s1$ 可用的内部状态：有 $3$ 种可能性——$A(s1\\sim U)$、$A(s1\\sim P)$ 和一个代表额外未指定状态的通配符 $A(s1\\sim ?)$。**\n- 对内部状态的分析是错误的。问题指出声明的枚举是精确的：“用内部状态枚举声明的位点恰好具有那些可用的内部状态”。通配符 $?$ 是用于在规则中匹配模式的特性，而不是分子可以采用的具体状态。可用状态的集合是 $\\{U, P\\}$，其基数为 $2$。\n- **结论：错误。**\n\n**E. $A.s2$ 和 $B.b$ 之间的键状态：恰好有 $2$ 种可能性——未成键和单键合。$A.s1$ 可用的内部状态：没有，因为 $A(s1\\sim U\\sim P)$ 仅约束规则匹配，但并未为 $s1$ 定义实际的内部状态。**\n- 对内部状态的分析是错误的。这个陈述直接与给定的规则相矛盾：“用内部状态枚举声明的位点恰好具有那些可用的内部状态”。声明 $s1\\sim U\\sim P$ 正是*定义*了可用状态。\n- **结论：错误。**\n\n基于对所提供语义规则的严格应用，只有选项 A 准确地描述了可能的键状态和内部状态。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "定义了分子之后，下一步就是通过规则来定义它们的相互作用。在模拟中，一条规则的“触发”速率取决于其模式在当前系统状态中能被找到的次数。本练习将向您介绍“模式嵌入”这一核心概念，并挑战您去计算一条规则在给定条件下所有有效的应用方式，这个计数是计算反应倾向性的直接基础。",
            "id": "3347060",
            "problem": "考虑一个遵循 Kappa 语言和 BioNetGen Language (BNGL) 惯例的分子相互作用的基于规则的模型，其中智能体是一个带有命名位点的类型化实体，这些位点可以具有离散的内部状态和结合状态。一条规则由一个必须嵌入到当前混合物中的左侧模式和一个指定转换的右侧组成。嵌入是从左侧模式到混合物的一种映射，该映射保留了智能体类型、位点名称、位点内部状态和位点结合状态，并受规则指定的任何上下文约束的限制。规则应用的倾向贡献与此类嵌入的数量成正比。\n\n假设智能体 $A$ 有一个单位点 $s$，其内部状态可以是 $U$ 或 $P$，结合状态可以是未结合或已结合。考虑一个一元规则，其左侧模式为 $A(s\\sim U)$，右侧将内部状态更新为 $P$，非正式地写作 $A(s\\sim U) \\to A(s\\sim P)$。该规则还带有一个上下文约束，即在匹配时位点 $s$ 必须是未结合的。混合物包含 $N$ 个不同的 $A$ 实例，其中位点 $s$ 处于内部状态 $U$ 且未结合；以及 $M$ 个不同的 $A$ 实例，其中位点 $s$ 已结合（无论内部状态如何）。假设为计算嵌入数量的目的，每个智能体实例都是可区分的，并且左侧模式恰好包含单个带有单位点 $s$ 的智能体 $A$。\n\n仅使用基于规则的建模中模式嵌入的形式化定义（即作为保留标签、位点内部状态和结合状态的图同态），以及任何有效嵌入都必须满足上下文约束这一事实，从第一性原理推导在此规则下，左侧模式在混合物中符合触发条件的嵌入总数。用 $N$ 和 $M$ 的封闭形式表达式表示您的最终答案。无需四舍五入。无需单位。",
            "solution": "该问题要求在基于规则的建模背景下，根据第一性原理，推导给定规则的合格嵌入总数。嵌入是从规则的左侧模式到智能体混合物的一种映射，它保留所有指定的属性并满足任何额外的上下文约束。\n\n首先，让我们将问题的组成部分形式化。\n\n1.  **左侧 (LHS) 模式：** LHS 模式，我们可以表示为 $\\mathcal{P}$，被指定为 $A(s\\sim U)$。该模式由一个类型为 $A$ 的单个智能体组成。它有一个指定的位点 $s$，该位点必须处于内部状态 $U$。位点 $s$ 的结合状态在模式本身内未指定。\n\n2.  **上下文约束：** 该规则带有一个不属于 LHS 模式但必须满足才能使嵌入有效的附加条件。该约束是匹配的智能体的位点 $s$ 必须是未结合的。\n\n3.  **有效嵌入的条件：** 对于混合物中的一个智能体实例，要成为给定规则下模式 $\\mathcal{P}$ 嵌入的有效目标，它必须满足来自模式和上下文约束的所有条件。设混合物中的一个智能体用 $a$ 表示。一个有效的嵌入将 $\\mathcal{P}$ 中的单个智能体映射到智能体 $a$，使得：\n    a. $a$ 的智能体类型是 $A$。\n    b. 智能体 $a$ 的位点 $s$ 的内部状态为 $U$。\n    c. 智能体 $a$ 的位点 $s$ 是未结合的（由于上下文约束）。\n\n4.  **混合物的组成：** 问题描述了系统的状态，即智能体的混合物。混合物包含类型为 $A$ 的智能体，可以根据其位点 $s$ 的属性将其划分为不相交的集合。我们已知：\n    *   一个包含 $N$ 个不同 $A$ 智能体实例的集合，其中位点 $s$ 处于内部状态 $U$ 且未结合。我们称这个集合为 $S_U$。\n    *   一个包含 $M$ 个不同 $A$ 智能体实例的集合，其中位点 $s$ 已结合。这些智能体的位点 $s$ 的内部状态未指定。我们称这个集合为 $S_B$。\n\n5.  **计算嵌入数量：** 一个嵌入将模式 $\\mathcal{P}$ 中的单个智能体映射到混合物中一个特定的、可区分的智能体实例。因此，有效嵌入的总数等于混合物中满足第 3 点所列所有三个条件的智能体实例的数量。\n\n让我们检查混合物中的每一组智能体：\n\n*   **集合 $S_U$ 中的智能体**：有 $N$ 个这样的智能体。对于任何智能体 $a \\in S_U$：\n    1.  其类型是 $A$。这与模式匹配。\n    2.  其位点 $s$ 的内部状态为 $U$。这与模式匹配。\n    3.  其位点 $s$ 是未结合的。这满足上下文约束。\n    由于 $S_U$ 中的 $N$ 个智能体中的每一个都满足所有必需的条件，它们中的每一个都构成了一个有效的嵌入目标。由于智能体实例是可区分的，这给出了 $N$ 个不同的有效嵌入。\n\n*   **集合 $S_B$ 中的智能体**：有 $M$ 个这样的智能体。对于任何智能体 $a \\in S_B$：\n    1.  其类型是 $A$，与模式匹配。\n    2.  其位点 $s$ 是已结合的。这直接违反了位点必须是未结合的上下文约束。\n    因为上下文约束未被满足，该集合中的 $M$ 个智能体都不能成为有效嵌入的目标，无论其位点 $s$ 的内部状态如何。因此，该集合贡献了 $0$ 个有效嵌入。\n\n合格嵌入的总数是混合物中所有不相交智能体集合的有效嵌入之和。\n总嵌入数 = (来自 $S_U$ 的嵌入数) + (来自 $S_B$ 的嵌入数)\n总嵌入数 = $N + 0 = N$。\n\n关于 $M$ 个已结合智能体的信息是为了测试上下文约束的正确应用而提供的。这些智能体是状态空间的一部分，但不适用于此特定规则的应用。因此，从第一性原理的推导得出的结论是，只有那 $N$ 个同时处于状态 $U$ 且未结合的智能体才能被匹配。因此，嵌入的总数恰好是 $N$。",
            "answer": "$$\\boxed{N}$$"
        },
        {
            "introduction": "使用基于规则的建模的一个主要原因是为了应对复杂系统中分子种类的“组合爆炸”问题。本练习通过一个简单的二聚化过程，要求您计算可能产生的不同分子种类（微观状态）的总数，从而直观地展示了这一挑战的巨大规模。通过推导这个计数，您将亲身体会到为什么显式地枚举所有物种常常是不可行的，以及为什么基于规则的方法如此强大。",
            "id": "3347101",
            "problem": "考虑一个基于规则的分子相互作用模型中的一个受体物种。一个单一的单体受体有 $n$ 个独立的二元内部位点（例如，磷酸化位点），每个位点可以处于状态 $0$ 或 $1$。该受体可以选择性地通过一个单一的独特二聚化界面进行同源二聚化，产生一个由同一个单体的两个不可区分的副本组成的复合物。该二聚化界面本身不构成一个内部二元位点；它只决定受体是以单体复合物还是以二聚体复合物的形式存在。假设所有 $n$ 个内部位点都在单体水平上进行标记，并且在一个二聚体中，两个亚基是同一个单体的不可区分的副本，因此交换这两个亚基不会产生一个不同的微观状态。忽略所有空间取向和几何结构，只需考虑二聚体由通过唯一界面连接的恰好两个亚基组成，并且不允许形成更高阶的寡聚体。\n\n仅使用基本计数原理和定义（例如，二元位点状态的独立性、作为交换对称性的不可区分亚基的概念，以及在对称性下将微观状态定义为不同物种），推导当允许单体和二聚体复合物同时存在时，不同微观状态（基于规则的物种）总数的关于 $n$ 的闭式表达式。然后，通过提供一个单一的主导项表达式，来证明当 $n \\to \\infty$ 时该计数的领头阶渐近增长率是合理的。\n\n将您的最终答案表示为一个行矩阵 $\\bigl(T(n)\\ \\ L(n)\\bigr)$，其中 $T(n)$ 是作为 $n$ 的函数的不同微观状态的精确总数，而 $L(n)$ 是当 $n \\to \\infty$ 时 $T(n)$ 的一个单一领头阶渐近表达式。不需要四舍五入，也不涉及单位。",
            "solution": "该问题要求在一个允许单体和二聚体物种存在的系统中，推导不同微观状态总数 $T(n)$ 的闭式表达式，并确定该计数的领头阶渐近增长 $L(n)$。微观状态被定义为一个不同的分子物种，其中考虑了指定的对称性。\n\n微观状态的总数是唯一单体状态数 $M(n)$ 和唯一二聚体状态数 $D(n)$ 的和：\n$$T(n) = M(n) + D(n)$$\n\n首先，我们确定不同单体微观状态的数量 $M(n)$。\n一个单体有 $n$ 个独立的内部位点，每个位点可以处于两种状态之一（$0$ 或 $1$）。因此，一个单体的状态完全由一个长度为 $n$ 的二进制向量指定。这种唯一向量的总数是 $2^n$。\n$$M(n) = 2^n$$\n\n接下来，我们确定不同二聚体微观状态的数量 $D(n)$。\n一个二聚体由两个单体亚基组成。问题陈述这两个亚基是“不可区分的”，这意味着存在交换对称性：由亚基 $s_1$ 和亚基 $s_2$ 组成的二聚体与由 $s_2$ 和 $s_1$ 组成的二聚体是相同的。\n设 $S$ 是所有可能的单体状态的集合，其中 $|S| = M(n) = 2^n$。一个二聚体对应于从集合 $S$ 中无序地选择两个状态，并允许重复（因为两个亚基可以处于相同的状态）。这是一个计算可重复组合的经典组合问题。\n\n从一个大小为 $m$ 的集合中选择一个大小为 $k$ 的多重集的方法数由多重集系数 $\\binom{m+k-1}{k}$ 给出。\n在我们的例子中，我们是从 $m = 2^n$ 个可能的单体状态集合中选择 $k=2$ 个亚基。\n$$D(n) = \\binom{2^n + 2 - 1}{2} = \\binom{2^n + 1}{2}$$\n展开二项式系数：\n$$D(n) = \\frac{(2^n + 1)!}{2! (2^n + 1 - 2)!} = \\frac{(2^n + 1)(2^n)}{2}$$\n$$D(n) = \\frac{2^{2n} + 2^n}{2} = 2^{2n-1} + 2^{n-1}$$\n\n现在，我们可以通过将单体和二聚体的计数相加来找到微观状态的总数 $T(n)$。\n$$T(n) = M(n) + D(n) = 2^n + (2^{2n-1} + 2^{n-1})$$\n为了简化这个表达式，我们可以将 $2^n$ 写成 $2 \\cdot 2^{n-1}$：\n$$T(n) = 2^{2n-1} + (2 \\cdot 2^{n-1} + 2^{n-1})$$\n$$T(n) = 2^{2n-1} + 3 \\cdot 2^{n-1}$$\n这是不同微观状态总数的精确闭式表达式。\n\n最后，我们必须找到当 $n \\to \\infty$ 时 $T(n)$ 的领头阶渐近增长率。$T(n)$ 的表达式有两项：$2^{2n-1}$ 和 $3 \\cdot 2^{n-1}$。我们来分析它们在 $n$ 很大时的行为：\n第一项是 $2^{2n-1} = \\frac{1}{2}(2^2)^n = \\frac{1}{2} \\cdot 4^n$。\n第二项是 $3 \\cdot 2^{n-1} = \\frac{3}{2} \\cdot 2^n$。\n表达式为 $T(n) = \\frac{1}{2} \\cdot 4^n + \\frac{3}{2} \\cdot 2^n$。\n当 $n \\to \\infty$ 时，指数运算中底数最大的项将在和中占主导地位。比较底数 $4$ 和 $2$，包含 $4^n$ 的项比包含 $2^n$ 的项增长得快得多。\n为了形式上验证这一点，我们考察当 $n \\to \\infty$ 时第二项与第一项的比率的极限：\n$$\\lim_{n\\to\\infty} \\frac{3 \\cdot 2^{n-1}}{2^{2n-1}} = \\lim_{n\\to\\infty} \\frac{3 \\cdot 2^n / 2}{2^{2n} / 2} = \\lim_{n\\to\\infty} 3 \\cdot \\frac{2^n}{4^n} = \\lim_{n\\to\\infty} 3 \\left(\\frac{1}{2}\\right)^n = 0$$\n由于极限为 $0$，分母 $2^{2n-1}$ 是主导项。\n因此，$T(n)$ 的领头阶渐近表达式为：\n$$L(n) = 2^{2n-1}$$\n\n解由精确计数 $T(n)$ 和领头阶渐近表达式 $L(n)$ 组成。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2^{2n-1} + 3 \\cdot 2^{n-1} & 2^{2n-1} \\end{pmatrix}}$$"
        }
    ]
}