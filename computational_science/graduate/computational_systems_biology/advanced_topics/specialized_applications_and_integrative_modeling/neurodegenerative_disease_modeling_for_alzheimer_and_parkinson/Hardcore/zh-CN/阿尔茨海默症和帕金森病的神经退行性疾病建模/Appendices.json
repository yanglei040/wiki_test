{
    "hands_on_practices": [
        {
            "introduction": "我们首先从一个在神经退行性疾病研究中极具影响力的模型——网络反应-扩散模型——的推导开始。这项练习将演示如何将一个由偏微分方程（PDE）描述的连续空间过程，转化为一个在代表大脑连接体的图结构上的常微分方程（ODE）系统。这项技能对于模拟大规模大脑动力学和理解蛋白病的朊病毒样传播至关重要。",
            "id": "3333677",
            "problem": "在对与阿尔茨海默病 (AD) 和帕金森病 (PD) 相关的错误折叠蛋白在大脑结构连接网络中的朊病毒样传播进行建模时，一个常见的起点是描述空间域上浓度场 $u(\\mathbf{x}, t)$ 的柯尔莫哥洛夫-彼得罗夫斯基-皮斯库诺夫 (KPP) 反应-扩散偏微分方程 (PDE)：$\\partial_t u = D \\nabla^2 u + r u \\left(1 - u/K\\right)$，其中 $D$ 是扩散系数，$r$ 是内禀增长率，$K$ 是承载能力。考虑将大脑进行网络粗粒化，分为 $N$ 个区域（节点），其对称加权邻接矩阵为 $W \\in \\mathbb{R}^{N \\times N}$，描述了轴突连接强度，组合图拉普拉斯算子为 $L = \\mathrm{diag}(W \\mathbf{1}) - W$，其中 $\\mathbf{1}$ 是全一向量。假设网络是连通且无向的，并在与外部无通量交换（封闭系统）的条件下进行研究。令 $\\mathbf{u}(t) \\in \\mathbb{R}^N$ 表示各区域的浓度集合。\n\n以质量守恒和菲克定律作为网络扩散的基本原理，并使用标准逻辑斯增长描述局部反应动力学，从第一性原理推导控制网络上 $\\dot{\\mathbf{u}}(t)$ 的常微分方程 (ODE) 系统。然后，通过在无病平衡点 $\\mathbf{u} = \\mathbf{0}$ 处对网络动力学进行线性化，确定雅可比矩阵的主导（最大实部）特征值，并用 $D$、$r$ 以及图拉普拉斯算子 $L$ 的谱来表示。\n\n请以单个闭式解析表达式的形式给出该主导特征值的最终答案。不要包含单位。如果您引入任何缩写词，如常微分方程 (ODE) 或偏微分方程 (PDE)，请在首次使用时对其进行定义。",
            "solution": "本问题要求推导一个基于网络的蛋白错误折叠传播模型，并分析其在无病平衡点的稳定性。推导过程从第一性原理出发，分析则需要对系统进行线性化，并求解所得雅可比矩阵的主导特征值。\n\n首先，我们定义本解答中使用的缩写词：偏微分方程 (PDE) 和常微分方程 (ODE)。\n\n**1. 常微分方程 (ODE) 系统的推导**\n\n每个大脑区域（节点）$i$ 中错误折叠蛋白的浓度 $u_i(t)$ 的动力学遵循质量守恒原理。浓度变化率 $\\frac{d u_i}{dt}$ 是由局部反应动力学引起的变化率和由连接区域之间的扩散引起的变化率之和。\n\n$$\n\\frac{d u_i}{dt} = \\left(\\frac{d u_i}{dt}\\right)_{\\text{reaction}} + \\left(\\frac{d u_i}{dt}\\right)_{\\text{diffusion}}\n$$\n\n反应项由逻辑斯增长描述，正如在连续 KPP 模型 $\\partial_t u = D \\nabla^2 u + r u \\left(1 - u/K\\right)$ 中所规定的。对于离散节点 $i$，这个局部项仅依赖于 $u_i$：\n\n$$\n\\left(\\frac{d u_i}{dt}\\right)_{\\text{reaction}} = r u_i \\left(1 - \\frac{u_i}{K}\\right)\n$$\n\n扩散项源于菲克第一定律，该定律指出通量与浓度梯度的负值成正比。在网络上，从节点 $j$ 到节点 $i$ 的蛋白质通量 $J_{j \\to i}$ 与浓度差 $(u_j - u_i)$ 成正比。比例常数包括扩散系数 $D$ 和节点间的连接强度 $W_{ij}$。\n\n$$\nJ_{j \\to i} = D W_{ij} (u_j - u_i)\n$$\n\n节点 $i$ 处由扩散引起的净浓度变化是来自网络中所有其他节点 $j$ 的通量之和。由于问题指定了一个封闭系统（与外部无通量交换），我们对所有节点 $j=1, \\dots, N$ 进行求和。\n\n$$\n\\left(\\frac{d u_i}{dt}\\right)_{\\text{diffusion}} = \\sum_{j=1}^{N} J_{j \\to i} = \\sum_{j=1}^{N} D W_{ij} (u_j - u_i)\n$$\n\n我们可以展开这个和式：\n\n$$\n\\left(\\frac{d u_i}{dt}\\right)_{\\text{diffusion}} = D \\left( \\sum_{j=1}^{N} W_{ij} u_j - \\sum_{j=1}^{N} W_{ij} u_i \\right) = D \\left( \\sum_{j=1}^{N} W_{ij} u_j - u_i \\sum_{j=1}^{N} W_{ij} \\right)\n$$\n\n令 $d_i = \\sum_{j=1}^{N} W_{ij}$ 为节点 $i$ 的加权度。括号中的第一项是矩阵-向量乘积 $W\\mathbf{u}$ 的第 $i$ 个分量。第二项是 $d_i u_i$。在矩阵表示法中，所有加权度的向量是度矩阵的对角线，即 $\\mathrm{diag}(\\mathbf{d}) = \\mathrm{diag}(W\\mathbf{1})$。我们将此矩阵表示为 $\\mathrm{Deg}$。\n因此，节点 $i$ 的扩散项可以写为：\n\n$$\n\\left(\\frac{d u_i}{dt}\\right)_{\\text{diffusion}} = D \\left( (W\\mathbf{u})_i - (\\mathrm{Deg}\\,\\mathbf{u})_i \\right) = -D \\left( (\\mathrm{Deg}\\,\\mathbf{u})_i - (W\\mathbf{u})_i \\right)\n$$\n\n该表达式对应于向量 $-D(\\mathrm{Deg} - W)\\mathbf{u}$ 的第 $i$ 个分量。问题将组合图拉普拉斯算子定义为 $L = \\mathrm{diag}(W \\mathbf{1}) - W = \\mathrm{Deg} - W$。因此，整个系统的扩散项为：\n\n$$\n\\left(\\frac{d\\mathbf{u}}{dt}\\right)_{\\text{diffusion}} = -D L \\mathbf{u}\n$$\n\n结合反应项和扩散项，我们得到控制浓度向量 $\\mathbf{u}(t)$ 的 $N$ 个耦合 ODE 系统：\n\n$$\n\\frac{d\\mathbf{u}}{dt} = -D L \\mathbf{u} + \\mathbf{f}(\\mathbf{u})\n$$\n\n其中 $\\mathbf{f}(\\mathbf{u})$ 是局部反应动力学向量，其分量为 $f_i(u_i) = r u_i (1 - u_i/K)$。这可以使用逐元素（哈达玛）乘积 $\\circ$ 写成 $\\mathbf{f}(\\mathbf{u}) = r \\mathbf{u} \\circ (\\mathbf{1} - \\mathbf{u}/K)$，其中 $\\mathbf{1}$ 是全一向量。\n\n**2. 线性化与稳定性分析**\n\n下一步是分析无病平衡点 $\\mathbf{u} = \\mathbf{0}$ 的稳定性。平衡点必须满足 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{0}$。在 $\\mathbf{u}=\\mathbf{0}$ 处，我们有 $-D L (\\mathbf{0}) + \\mathbf{f}(\\mathbf{0}) = \\mathbf{0} + \\mathbf{0} = \\mathbf{0}$，这证实了它是一个平衡点。\n\n为了研究局部稳定性，我们通过计算右侧项（我们将其表示为 $\\mathbf{F}(\\mathbf{u}) = -D L \\mathbf{u} + \\mathbf{f}(\\mathbf{u})$）在 $\\mathbf{u}=\\mathbf{0}$ 处求值的雅可比矩阵 $J$ 来对系统进行线性化。向量场 $\\mathbf{F}(\\mathbf{u})$ 的分量为：\n\n$$\nF_i(\\mathbf{u}) = -D \\sum_{j=1}^{N} L_{ij} u_j + r u_i - \\frac{r}{K} u_i^2\n$$\n\n雅可比矩阵的元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial u_j}$。\n\n当 $i \\neq j$ 时：\n$$\nJ_{ij} = \\frac{\\partial}{\\partial u_j} \\left( -D \\sum_{k=1}^{N} L_{ik} u_k + r u_i - \\frac{r}{K} u_i^2 \\right) = -D L_{ij}\n$$\n\n当 $i = j$ 时：\n$$\nJ_{ii} = \\frac{\\partial}{\\partial u_i} \\left( -D \\sum_{k=1}^{N} L_{ik} u_k + r u_i - \\frac{r}{K} u_i^2 \\right) = -D L_{ii} + r - \\frac{2r}{K} u_i\n$$\n\n在平衡点 $\\mathbf{u} = \\mathbf{0}$ 处计算雅可比矩阵：\n\n$$\nJ_{ij}(\\mathbf{0}) = -D L_{ij} \\quad \\text{for } i \\neq j\n$$\n$$\nJ_{ii}(\\mathbf{0}) = -D L_{ii} + r\n$$\n\n这可以表示为矩阵形式。元素为 $-D L_{ij}$ 的矩阵就是 $-D L$。对角线上的附加项 $+r$ 对应于加上矩阵 $rI$，其中 $I$ 是 $N \\times N$ 单位矩阵。因此，无病平衡点处的雅可比矩阵为：\n\n$$\nJ(\\mathbf{0}) = rI - D L\n$$\n\n**3. 确定主导特征值**\n\n雅可比矩阵的主导特征值是具有最大实部的特征值，因为它决定了平衡点的稳定性。令 $\\{\\mu_k\\}_{k=1}^N$ 为图拉普拉斯算子 $L$ 的特征值集合，令 $\\{\\mathbf{v}_k\\}_{k=1}^N$ 为相应的特征向量集合。\n$$\nL \\mathbf{v}_k = \\mu_k \\mathbf{v}_k\n$$\n$L$ 的特征向量也是雅可比矩阵 $J(\\mathbf{0})$ 的特征向量：\n$$\nJ(\\mathbf{0}) \\mathbf{v}_k = (rI - D L) \\mathbf{v}_k = r(I\\mathbf{v}_k) - D(L\\mathbf{v}_k) = r\\mathbf{v}_k - D(\\mu_k \\mathbf{v}_k) = (r - D\\mu_k)\\mathbf{v}_k\n$$\n因此，$J(\\mathbf{0})$ 的特征值（表示为 $\\{\\lambda_k\\}_{k=1}^N$）与 $L$ 的特征值通过以下表达式相关联：\n$$\n\\lambda_k = r - D\\mu_k\n$$\n问题指出网络是连通且无向的，并且邻接矩阵 $W$ 是对称的。这意味着拉普拉斯算子 $L$ 是一个实对称矩阵，因此其所有特征值 $\\mu_k$ 都是实数。因此，所有的雅可比特征值 $\\lambda_k$ 也都是实数。\n\n主导特征值为 $\\lambda_{\\text{dom}} = \\max_{k} \\{\\lambda_k\\}$。\n$$\n\\lambda_{\\text{dom}} = \\max_{k} \\{r - D\\mu_k\\}\n$$\n由于 $r$ 是一个常数且扩散系数 $D$ 是正数 ($D>0$)，最大化此表达式等价于最小化拉普拉斯算子的特征值 $\\mu_k$。\n$$\n\\lambda_{\\text{dom}} = r - D \\min_{k} \\{\\mu_k\\}\n$$\n对于任何连通的无向图，组合拉普拉斯算子 $L$ 的谱是众所周知的。其特征值是实数且非负，通常按 $0 = \\mu_1 \\le \\mu_2 \\le \\dots \\le \\mu_N$ 的顺序排列。最小的特征值 $\\mu_1$ 总是 $0$，对于连通图，它的重数为一。对应的特征向量是全一向量 $\\mathbf{1}$。\n\n因此，拉普拉斯算子的最小特征值为 $\\min_{k} \\{\\mu_k\\} = \\mu_1 = 0$。\n\n将此值代入主导特征值的表达式中：\n$$\n\\lambda_{\\text{dom}} = r - D \\cdot 0 = r\n$$\n\n在无病平衡点处线性化的雅可比矩阵的主导特征值等于内禀增长率 $r$。",
            "answer": "$$\n\\boxed{r}\n$$"
        },
        {
            "introduction": "模型的真正力量通过模拟得以展现。这项练习直接建立在网络反应-扩散模型之上，指导你完成模拟疾病随时间进展的计算步骤。你将使用该模型的线性化版本——一种对疾病早期阶段常见且有效的近似方法——来预测病理变化的“波前”如何从一个种子区域扩散到整个小型大脑网络。",
            "id": "3333626",
            "problem": "考虑一个简化的网络扩散-反应模型，用于描述在由四个脑区（节点）组成的小型加权连接组上，如 Alzheimer's disease 和 Parkinson's disease 等神经退行性疾病中错误折叠蛋白负荷的扩散。设加权邻接矩阵为对称矩阵，其形式如下\n$$\nW=\\begin{bmatrix}\n0  0.8  0.2  0.0\\\\\n0.8  0  0.6  0.1\\\\\n0.2  0.6  0  0.7\\\\\n0.0  0.1  0.7  0\n\\end{bmatrix},\n$$\n并且组合图拉普拉斯算子由经过充分检验的公式定义\n$$\nL=\\operatorname{diag}(W\\mathbf{1})-W,\n$$\n其中 $\\mathbf{1}$ 表示全一向量。拉普拉斯算子 $L$ 编码了源于网络上的 Fick's law 的扩散耦合，这是由浓度梯度驱动的扩散的离散模拟。\n\n假设节点上的错误折叠蛋白负荷根据一个由以下公式控制的网络反应-扩散系统演化\n$$\n\\frac{d\\mathbf{u}}{dt} = -D L \\mathbf{u} + r \\,\\mathbf{u}\\left(1-\\frac{\\mathbf{u}}{K}\\right),\n$$\n其中 $D>0$ 是扩散系数（单位为 $\\text{year}^{-1}$），$r\\ge 0$ 是局部增长率（单位为 $\\text{year}^{-1}$），$K>0$ 是承载能力（无量纲的负荷标度），$\\mathbf{u}(t)\\in\\mathbb{R}^4$ 是负荷向量，其分量为 $u_i(t)$，对应于节点 $i=1,2,3,4$。\n\n对于早期动力学，当负荷相对于承载能力较小时，通常使用核心近似 $u_i/K\\ll 1$ 对逻辑斯蒂反应项进行线性化，得到\n$$\n\\frac{d\\mathbf{u}}{dt} \\approx \\left(-D L + r I\\right)\\mathbf{u} = A\\,\\mathbf{u},\n$$\n其中 $I$ 是单位矩阵，$A=-D L + r I$ 是一个对称的梅茨勒矩阵（Metzler matrix）（非对角线项为非负）。该线性系统存在矩阵指数解\n$$\n\\mathbf{u}(t) \\approx e^{A t}\\,\\mathbf{u}_0,\n$$\n对应于初始条件 $\\mathbf{u}_0$。\n\n给定在节点1的初始播种：$\\mathbf{u}_0 = [0.01K,\\,0,\\,0,\\,0]^\\top$。将节点 $i$ 的波前到达时间定义为满足 $u_i(t)\\ge \\alpha K$ 的最小时间 $t\\ge 0$，阈值 $\\alpha=0.1$（承载能力的一个小数部分）。如果在规定的时间窗口内未达到阈值，则使用数字 $-1.0$ 报告未到达。\n\n使用的基本原理：\n- 源于网络上 Fick's law 的图扩散：$d\\mathbf{u}/dt=-D L \\mathbf{u}$，其中 $L=\\operatorname{diag}(W\\mathbf{1})-W$。\n- 逻辑斯蒂增长的早期线性化：当 $\\mathbf{u}/K\\ll 1$ 时，$\\mathbf{u}(1-\\mathbf{u}/K)\\approx \\mathbf{u}$。\n- 线性时不变系统的矩阵指数解：$\\mathbf{u}(t)=e^{A t}\\mathbf{u}_0$。\n\n任务：\n1. 对每个测试用例，使用矩阵指数近似 $\\mathbf{u}(t) = e^{A t}\\mathbf{u}_0$（其中 $A=-D L + r I$）计算 $\\mathbf{u}(t)$。使用 $A$ 的特征分解来高效地计算多个时间点的 $e^{A t}$。\n2. 量化每个节点的波前到达时间，定义为在一个均匀网格上，满足 $u_i(t)\\ge \\alpha K$ 的最早时间 $t$。\n3. 将所有到达时间以年为单位表示为浮点数，并四舍五入到四位小数。如果在指定的最大时间内未达到阈值，则该节点返回 $-1.0$。\n\n数值单位和约定：\n- 时间单位为年；$D$ 和 $r$ 的单位为 $\\text{year}^{-1}$；$K$ 和 $\\mathbf{u}$ 是无量纲的负荷单位（相对于 $K$）；不使用角度。\n\n使用以下测试套件，每个套件都有自己的 $(D,r,K)$ 和最大时间：\n- 案例1（一般扩散）：$(D,r,K)=(0.15,\\,0.30,\\,1.0)$，最大时间 $T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 案例2（无扩散边界）：$(D,r,K)=(0.00,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 案例3（无增长边界）：$(D,r,K)=(0.20,\\,0.00,\\,1.0)$，$T_{\\max}=25$ 年，时间步长 $\\Delta t=0.01$ 年。\n- 案例4（高扩散，慢增长）：$(D,r,K)=(0.50,\\,0.05,\\,1.0)$，$T_{\\max}=60$ 年，时间步长 $\\Delta t=0.01$ 年。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的列表的列表，以逗号分隔。每个内部列表包含相应测试用例中节点 $[1,2,3,4]$ 的四个到达时间（以年为单位，四舍五入到四位小数）。如果某个节点在时间窗口内未达到阈值，则在其位置输出 $-1.0$。例如，格式必须为：\n$$\n\\texttt{[[t_{1,1},t_{1,2},t_{1,3},t_{1,4}],[t_{2,1},t_{2,2},t_{2,3},t_{2,4}],[t_{3,1},t_{3,2},t_{3,3},t_{3,4}],[t_{4,1},t_{4,2},t_{4,3},t_{4,4}]]}\n$$\n所有时间均以年为单位，并四舍五入到四位小数。",
            "solution": "用户提供了一个问题陈述，在开发解决方案之前需要对其进行验证。\n\n### 第1步：提取已知条件\n- **加权邻接矩阵**：$W=\\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix}$\n- **组合图拉普拉斯算子**：$L=\\operatorname{diag}(W\\mathbf{1})-W$，其中 $\\mathbf{1}$ 是全一向量。\n- **控制微分方程（非线性）**：$\\frac{d\\mathbf{u}}{dt} = -D L \\mathbf{u} + r \\,\\mathbf{u}\\left(1-\\frac{\\mathbf{u}}{K}\\right)$\n- **线性化近似**：对于小负荷 $u_i/K \\ll 1$，方程近似为 $\\frac{d\\mathbf{u}}{dt} \\approx \\left(-D L + r I\\right)\\mathbf{u} = A\\,\\mathbf{u}$。\n- **系统矩阵**：$A = -D L + r I$，其中 $I$ 是单位矩阵。\n- **线性系统的解**：$\\mathbf{u}(t) \\approx e^{A t}\\,\\mathbf{u}_0$。\n- **初始条件**：$\\mathbf{u}_0 = [0.01K,\\,0,\\,0,\\,0]^\\top$。\n- **波前到达时间**：定义为满足 $u_i(t) \\ge \\alpha K$ 的最小时间 $t \\ge 0$。\n- **阈值参数**：$\\alpha=0.1$。\n- **未到达值**：$-1.0$。\n- **测试用例**：\n  - 案例 1：$(D,r,K)=(0.15,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 案例 2：$(D,r,K)=(0.00,\\,0.30,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 案例 3：$(D,r,K)=(0.20,\\,0.00,\\,1.0)$，$T_{\\max}=25$ 年，$\\Delta t=0.01$ 年。\n  - 案例 4：$(D,r,K)=(0.50,\\,0.05,\\,1.0)$，$T_{\\max}=60$ 年，$\\Delta t=0.01$ 年。\n\n### 第2步：使用提取的已知条件进行验证\n根据指定标准对问题进行评估：\n- **科学依据**：该问题描述了一个网络反应-扩散模型，这是计算系统生物学和数学神经科学中一个标准且被广泛接受的框架，用于模拟病理蛋白的传播。使用图拉普拉斯算子模拟扩散和使用逻辑斯蒂增长模拟局部增殖是基本且公认的原则。对早期动力学进行线性化是一种有效且标准的数学近似方法。该模型在科学上是合理的。\n- **适定性**：该问题被表述为一个定义明确的线性常微分方程组的初值问题。所有必需的参数（$W$, $D$, $r$, $K$）、初始条件（$\\mathbf{u}_0$）和评估标准（到达时间定义）都得到了明确无误的提供。问题结构保证了唯一、稳定且可计算的解。\n- **客观性**：问题以精确、形式化的数学术语陈述。完全没有主观语言、观点或歧义。\n- **其他标准**：该问题是自包含的，其约束条件是一致的，所需的计算在物理上是合理的，在算法上是可行的。问题并非微不足道，需要应用线性代数和微分方程的概念。\n\n### 第3步：结论与行动\n问题陈述有效。将提供解决方案。\n\n### 解题推导\n\n该问题要求计算在一个包含 $N=4$ 个脑区的连接组上，一个线性化的网络反应-扩散模型的波前到达时间。错误折叠蛋白负荷向量 $\\mathbf{u}(t) \\in \\mathbb{R}^4$ 的动力学由以下线性常微分方程组控制：\n$$\n\\frac{d\\mathbf{u}}{dt} = A\\,\\mathbf{u}\n$$\n其中系统矩阵 $A$ 由 $A = -D L + r I$ 给出。此初值问题的解由矩阵指数给出：\n$$\n\\mathbf{u}(t) = e^{A t}\\,\\mathbf{u}_0\n$$\n\n第一步是根据给定的加权邻接矩阵 $W$ 构建图拉普拉斯算子 $L$。向量 $W\\mathbf{1}$ 包含 $W$ 的行和，代表每个节点的总连接强度（度）。设此向量为 $\\mathbf{s}$。\n$$\n\\mathbf{s} = W\\mathbf{1} = \\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1.0 \\\\ 1.5 \\\\ 1.5 \\\\ 0.8 \\end{bmatrix}\n$$\n那么，拉普拉斯算子 $L = \\operatorname{diag}(\\mathbf{s}) - W$ 为：\n$$\nL = \\begin{bmatrix} 1.0  0.0  0.0  0.0 \\\\ 0.0  1.5  0.0  0.0 \\\\ 0.0  0.0  1.5  0.0 \\\\ 0.0  0.0  0.0  0.8 \\end{bmatrix} - \\begin{bmatrix} 0  0.8  0.2  0.0\\\\ 0.8  0  0.6  0.1\\\\ 0.2  0.6  0  0.7\\\\ 0.0  0.1  0.7  0 \\end{bmatrix} = \\begin{bmatrix} 1.0  -0.8  -0.2  0.0\\\\ -0.8  1.5  -0.6  -0.1\\\\ -0.2  -0.6  1.5  -0.7\\\\ 0.0  -0.1  -0.7  0.8 \\end{bmatrix}\n$$\n对于每个测试用例，使用给定的参数 $D$ 和 $r$ 构建矩阵 $A = -D L + r I$。由于 $W$ 是对称的，所以 $L$ 也是对称的，因此 $A$ 是一个实对称矩阵。这保证了 $A$ 有一个标准正交的特征向量基。\n\n为了高效地计算多个时间点的 $\\mathbf{u}(t)$，我们对 $A$ 进行对角化。设 $A$ 的特征分解为 $A = V \\Lambda V^\\top$，其中 $V$ 是特征向量构成的正交矩阵，$\\Lambda = \\operatorname{diag}(\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4)$ 是对应实特征值构成的对角矩阵。解 $\\mathbf{u}(t)$ 则表示为：\n$$\n\\mathbf{u}(t) = (V e^{\\Lambda t} V^\\top) \\mathbf{u}_0\n$$\n其中 $e^{\\Lambda t} = \\operatorname{diag}(e^{\\lambda_1 t}, e^{\\lambda_2 t}, e^{\\lambda_3 t}, e^{\\lambda_4 t})$。\n\n在计算上，避免在每个时间步都构造矩阵 $e^{At}$ 会更高效。取而代之的是，我们将初始条件 $\\mathbf{u}_0$ 投影到特征向量基上：\n$$\n\\mathbf{c}_0 = V^\\top \\mathbf{u}_0\n$$\n$\\mathbf{c}_0$ 的分量是 $\\mathbf{u}_0$ 在特征向量基中的坐标。这些坐标的时间演化很简单：\n$$\n\\mathbf{c}(t) = e^{\\Lambda t} \\mathbf{c}_0\n$$\n最后，通过变换回标准基来重构解向量 $\\mathbf{u}(t)$：\n$$\n\\mathbf{u}(t) = V \\mathbf{c}(t)\n$$\n初始条件为 $\\mathbf{u}_0 = [0.01K, 0, 0, 0]^\\top$，到达阈值为 $u_i(t) \\ge \\alpha K$，其中 $\\alpha=0.1$。由于所有测试用例的 $K=1.0$，我们有 $\\mathbf{u}_0 = [0.01, 0, 0, 0]^\\top$，阈值为 $0.1$。\n\n对于每个测试用例，我们在一个从 $t=0$ 到 $T_{\\max}$、步长为 $\\Delta t$ 的均匀时间网格上进行迭代。对于每个分量 $u_i(t)$，我们检查是否已越过阈值。节点 $i$ 的波前到达时间是该网格上第一个满足 $u_i(t) \\ge 0.1$ 的时间 $t$。如果在 $T_{\\max}$ 之前未达到阈值，则到达时间记录为 $-1.0$。最终报告的时间四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neurodegenerative disease spread model problem by calculating wavefront arrival times\n    for four different test cases.\n    \"\"\"\n    \n    # Define the weighted adjacency matrix W for the 4-node brain connectome.\n    W = np.array([\n        [0.0, 0.8, 0.2, 0.0],\n        [0.8, 0.0, 0.6, 0.1],\n        [0.2, 0.6, 0.0, 0.7],\n        [0.0, 0.1, 0.7, 0.0]\n    ])\n    \n    # Get the number of nodes.\n    N = W.shape[0]\n    \n    # The identity matrix I of size N x N.\n    I = np.identity(N)\n    \n    # Calculate the combinatorial graph Laplacian L = diag(W*1) - W.\n    # s is the vector of row sums (weighted degrees).\n    s = np.sum(W, axis=1)\n    # Degree matrix is a diagonal matrix of the row sums.\n    Degree_matrix = np.diag(s)\n    # The graph Laplacian L.\n    L = Degree_matrix - W\n    \n    # Define constants from the problem statement.\n    alpha = 0.1  # Threshold factor for arrival time.\n    u0_factor = 0.01  # Initial condition factor.\n\n    # Define the test suite with parameters for each case.\n    test_cases = [\n        {'D': 0.15, 'r': 0.30, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.00, 'r': 0.30, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.20, 'r': 0.00, 'K': 1.0, 'T_max': 25, 'dt': 0.01},\n        {'D': 0.50, 'r': 0.05, 'K': 1.0, 'T_max': 60, 'dt': 0.01}\n    ]\n    \n    all_results_str = []\n\n    for case in test_cases:\n        D_param, r_param, K_param = case['D'], case['r'], case['K']\n        T_max, dt = case['T_max'], case['dt']\n\n        # Construct the system matrix A = -D*L + r*I.\n        A = -D_param * L + r_param * I\n\n        # Since A is symmetric, use np.linalg.eigh for stable eigendecomposition.\n        eigenvalues, eigenvectors = np.linalg.eigh(A)\n\n        # Define the initial condition u_0 and the arrival time threshold.\n        # Seeding at node 1.\n        u_0 = np.zeros(N)\n        u_0[0] = u0_factor * K_param\n        threshold = alpha * K_param\n        \n        # Project the initial condition onto the basis of eigenvectors.\n        # c0 = V^T * u_0\n        c0 = eigenvectors.T @ u_0\n\n        # Initialize results for the current case.\n        arrival_times = [-1.0] * N\n        has_arrived = [False] * N\n        \n        # Create a robust time grid using linspace to ensure endpoint is included.\n        num_steps = int(round(T_max / dt)) + 1\n        time_points = np.linspace(0, T_max, num_steps)\n\n        # Iterate through time to find the first arrival at each node.\n        for t in time_points:\n            # Evolve the coefficients in the eigenbasis: c_i(t) = exp(lambda_i * t) * c_i(0).\n            c_t = np.exp(eigenvalues * t) * c0\n            \n            # Reconstruct the solution vector u(t) = V * c(t).\n            u_t = eigenvectors @ c_t\n\n            # Check for threshold crossing at each node.\n            for i in range(N):\n                if not has_arrived[i] and u_t[i] >= threshold:\n                    arrival_times[i] = t\n                    has_arrived[i] = True\n            \n            # Optimization: stop if all nodes have reached the threshold.\n            if all(has_arrived):\n                break\n        \n        # Format the results to four decimal places as required.\n        formatted_times = [f\"{t:.4f}\" for t in arrival_times]\n        all_results_str.append(f\"[{','.join(formatted_times)}]\")\n    \n    # Print the final output in the exact specified format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个模型的优劣取决于其参数的可靠性。最后一个练习将探讨计算建模中的一个根本性挑战：我们能否从实验数据中唯一地确定模型的参数？你将使用Fisher信息矩阵和剖面似然等统计工具来探索“实际可识别性”的概念，以确保我们的模型能够提供稳健且有意义的见解。",
            "id": "3333602",
            "problem": "考虑一个简化的神经退行性疾病中错误折叠蛋白质负荷的纵向正电子发射断层扫描（PET）模型，其中聚集物种通过产生而形成，并通过一级动力学清除。令 $B(t)$ 表示在时间 $t$ 测量到的聚集蛋白负荷，单位为任意PET单位。假设产生以恒定速率 $k_{agg}$ 发生，清除以速率 $k_{clear}$ 发生，因此负荷服从常微分方程（ODE）$$\\frac{dB}{dt} = k_{agg} - k_{clear}\\,B(t), \\quad B(0)=0,$$ 其中 $k_{agg} > 0$ 且 $k_{clear} > 0$，单位为 day$^{-1}$。PET信号被建模为 $$S(t;\\theta) = \\alpha\\,B(t), \\quad \\theta = (k_{agg}, k_{clear}),$$ 其中 $\\alpha>0$ 是一个已知的比例常数，而 $B(t)$ 是该ODE的解。在时间 $t_i$ 的观测值 $y_i$ 满足高斯测量模型 $$y_i = S(t_i;\\theta) + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),$$ 其中噪声标准差 $\\sigma>0$ 是已知的。对于给定的ODE和初始条件，负荷的显式解为 $$B(t) = \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right),$$ 因此 $$S(t;\\theta) = \\alpha \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right).$$\n\n您的任务是使用两种互补的方法来评估参数 $k_{agg}$ 和 $k_{clear}$ 的实际可辨识性：\n\n1. 在高斯噪声模型下，在真实参数值处计算的费雪信息矩阵（FIM）。对于 $\\theta=(k_{agg},k_{clear})$，费雪信息为\n$$I(\\theta) = \\frac{1}{\\sigma^2}\\sum_{i=1}^{n} J(t_i;\\theta)^\\top J(t_i;\\theta),$$\n其中 $J(t;\\theta) = \\left(\\frac{\\partial S(t;\\theta)}{\\partial k_{agg}},\\,\\frac{\\partial S(t;\\theta)}{\\partial k_{clear}}\\right)$ 是信号相对于参数的梯度。使用解析偏导数\n$$\\frac{\\partial S(t;\\theta)}{\\partial k_{agg}} = \\alpha\\,\\frac{1 - e^{-k_{clear} t}}{k_{clear}},$$\n$$\\frac{\\partial S(t;\\theta)}{\\partial k_{clear}} = \\alpha\\,k_{agg}\\left[-\\frac{1 - e^{-k_{clear} t}}{k_{clear}^2} + \\frac{t\\,e^{-k_{clear} t}}{k_{clear}}\\right].$$\n如果 $I(\\theta)$ 是正定的（所有特征值严格为正）并且其谱条件数严格小于所选阈值 $10^6$，则声明基于FIM的可辨识性准则得到满足。\n\n2. 每个参数的剖面似然。将数据 $\\{(t_i,y_i)\\}_{i=1}^n$ 的残差平方和（SSE）定义为\n$$\\mathrm{SSE}(\\theta) = \\sum_{i=1}^n \\left[y_i - S(t_i;\\theta)\\right]^2.$$\n令 $\\hat{\\theta}$ 为在 $k_{agg}>0$，$k_{clear}>0$（在合理范围内）上 $\\mathrm{SSE}(\\theta)$ 的联合最小化器。对于每个参数 $\\theta_j \\in \\{k_{agg},k_{clear}\\}$，通过在一系列网格值上固定 $\\theta_j$ 并对剩余参数优化 $\\mathrm{SSE}$ 来计算剖面似然，然后通过以下方式形成 $-2\\log\\mathcal{L}$ 的剖面（相差一个可加常数）：\n$$\\Delta(\\theta_j) = \\frac{\\mathrm{SSE}(\\theta_j, \\hat{\\theta}_{-j}(\\theta_j)) - \\mathrm{SSE}(\\hat{\\theta})}{\\sigma^2},$$\n其中 $\\hat{\\theta}_{-j}(\\theta_j)$ 表示在固定 $\\theta_j$ 的情况下剩余参数的优化器。使用卡方阈值 $\\Delta^* = 3.841459$（对应于 $1$ 个自由度的 $95\\%$ 置信度），如果集合 $\\{\\theta_j: \\Delta(\\theta_j) \\le \\Delta^*\\}$ 在扫描的网格内在两侧都有界，则声明 $\\theta_j$ 的基于剖面的可辨识性准则得到满足。\n\n结合这两个准则来判断可辨识性：如果FIM准则和剖面似然准则都得到满足，则一个参数是实际可辨识的。\n\n实现一个程序，该程序：\n- 通过在指定时间评估 $S(t;\\theta)$ 并添加标准差为 $\\sigma$ 的高斯噪声来生成合成数据。\n- 计算 $I(\\theta)$，检查正定性和谱条件数。\n- 计算联合最小二乘估计 $\\hat{\\theta}$，然后计算 $k_{agg}$ 和 $k_{clear}$ 的剖面似然，检查 $95\\%$ 置信集在网格内是否有界。\n- 对每个测试案例，返回一个包含两个布尔值的列表 $[b_{agg}, b_{clear}]$，分别表示 $k_{agg}$ 和 $k_{clear}$ 的实际可辨识性。\n\n使用以下参数集和采样方案的测试套件，确保所有时间单位为天，所有速率单位为 day$^{-1}$：\n- 测试案例1（采样良好，中等噪声）：$t_i = 0,2,4,\\ldots,60$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (k_{agg},k_{clear}) = (0.02, 0.1)$。\n- 测试案例2（采样良好，高噪声）：$t_i = 0,2,4,\\ldots,60$；$\\alpha = 1$；$\\sigma = 0.10$；真实 $\\theta^\\star = (0.02, 0.1)$。\n- 测试案例3（稀疏早期时间采样）：$t_i = 0,1,2$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (0.02, 0.1)$。\n- 测试案例4（清除缓慢）：$t_i = 0,1,2,\\ldots,30$；$\\alpha = 1$；$\\sigma = 0.02$；真实 $\\theta^\\star = (0.02, 0.005)$。\n\n对于所有优化任务，使用参数界限 $k_{agg}\\in[10^{-6},1.0]$ 和 $k_{clear}\\in[10^{-6},1.0]$。对于剖面似然网格，对每个参数在 $[10^{-4},1.0]$ 区间内扫描 $200$ 个对数间隔的值。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3,result4]$），其中每个 $resultj$ 本身是对应测试案例的一个包含两个布尔值 $[b_{agg},b_{clear}]$ 的列表。",
            "solution": "该模型始于聚集蛋白负荷 $B(t)$ 的产生-清除动力学，这在计算系统生物学中对分子种类形成与移除之间不平衡进行建模时是标准做法。在一级清除和恒定聚集速率下，常微分方程为 $\\frac{dB}{dt} = k_{agg} - k_{clear} B(t)$，且 $B(0) = 0$。这个ODE直接源于质量守恒：净变化率等于产生率减去与 $B(t)$ 成正比的移除率。求解该线性ODE可得\n$$B(t) = \\frac{k_{agg}}{k_{clear}} \\left(1 - e^{-k_{clear} t}\\right),$$\n这是通过对 $\\frac{dB}{dt} + k_{clear} B = k_{agg}$ 使用标准积分因子法获得的，其齐次解为 $B_h(t) = C e^{-k_{clear} t}$，特解为 $B_p(t) = \\frac{k_{agg}}{k_{clear}}$。施加 $B(0) = 0$ 的条件即得到所述表达式。\n\nPET信号被建模为 $S(t;\\theta) = \\alpha B(t)$，假设负荷与测量信号之间存在已知的线性比例关系 $\\alpha$。高斯噪声模型 $y_i = S(t_i;\\theta) + \\varepsilon_i$（其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$）利用了纵向扫描中重复帧的PET测量误差的成熟假设。\n\n对于可辨识性，我们使用两种经典方法。对于独立样本，高斯噪声下的费雪信息矩阵（FIM）为\n$$I(\\theta) = \\frac{1}{\\sigma^2}\\sum_{i=1}^n J(t_i;\\theta)^\\top J(t_i;\\theta),$$\n其中 $J(t;\\theta)$ 是 $S(t;\\theta)$ 相对于参数的梯度。从\n$$S(t;\\theta) = \\alpha \\frac{k_{agg}}{k_{clear}}(1 - e^{-k_{clear} t})$$\n出发，我们微分得到\n$$\\frac{\\partial S}{\\partial k_{agg}} = \\alpha \\frac{1 - e^{-k_{clear} t}}{k_{clear}},$$\n以及\n$$\\frac{\\partial S}{\\partial k_{clear}} = \\alpha\\,k_{agg}\\left[-\\frac{1 - e^{-k_{clear} t}}{k_{clear}^2} + \\frac{t\\,e^{-k_{clear} t}}{k_{clear}}\\right],$$\n这是通过对 $k_{agg} k_{clear}^{-1}(1 - e^{-k_{clear} t})$ 应用乘积法则并使用 $\\frac{d}{dk_{clear}} e^{-k_{clear} t} = -t e^{-k_{clear} t}$ 得到的。这些表达式提供了 $J(t;\\theta)$；然后 $I(\\theta)$ 是一个在样本上聚合的 $2\\times 2$ 矩阵。对于FIM准则，我们通过确保 $I(\\theta)$ 的两个特征值都严格为正来检验其正定性；我们还计算谱条件数 $\\kappa(I) = \\lambda_{\\max}/\\lambda_{\\min}$，并要求 $\\kappa(I)  10^6$ 以避免接近奇异，因为这会意味着严重的参数相关性和较差的实际可辨识性。\n\n剖面似然方法通过检查似然曲面是否为每个参数（当其他参数被优化掉时）提供了有界的置信区间来评估可辨识性。残差平方和为\n$$\\mathrm{SSE}(\\theta) = \\sum_{i=1}^n [y_i - S(t_i;\\theta)]^2.$$\n我们通过在 $k_{agg},k_{clear}  0$ 条件下最小化 $\\mathrm{SSE}(\\theta)$，并使用实际界限 $[10^{-6},1.0]$ 以保证数值稳定性，来获得联合最小二乘估计 $\\hat{\\theta}$。对于每个参数 $\\theta_j$，我们计算剖面\n$$\\Delta(\\theta_j) = \\frac{\\mathrm{SSE}(\\theta_j, \\hat{\\theta}_{-j}(\\theta_j)) - \\mathrm{SSE}(\\hat{\\theta})}{\\sigma^2},$$\n在高斯噪声下，这近似于 $-2\\log\\mathcal{L}$ 的差异（相差一个可加常数）。使用卡方阈值 $\\Delta^* = 3.841459$（对应1个自由度的95%置信度），我们检查集合 $\\{\\theta_j: \\Delta(\\theta_j) \\le \\Delta^*\\}$ 是否在网格扫描范围内有界。如果区间在两侧都有界，则该参数表现出有限的置信区间，表明具有实际可辨识性；如果它是无界的（例如，置信集延伸到扫描网格的边界），则该参数不是实际可辨识的。\n\n算法设计：\n- 对于每个测试案例，通过 $y_i = S(t_i;\\theta^\\star) + \\varepsilon_i$ 生成合成数据 $y_i$，使用固定的随机种子以保证可复现性。\n- 使用解析梯度计算 $I(\\theta^\\star)$；通过特征值和条件数 $\\kappa(I)$ 检查正定性。\n- 通过对残差 $r_i(\\theta) = y_i - S(t_i;\\theta)$ 进行非线性最小二乘法拟合 $\\hat{\\theta}$，并设置正性界限 $[10^{-6},1.0]$。\n- 对每个参数，在 $[10^{-4},1.0]$ 的对数网格上评估剖面似然：固定 $\\theta_j$，对另一个参数优化 $\\mathrm{SSE}$，计算 $\\Delta(\\theta_j)$，并确定95%置信集是否有界。\n- 结合FIM和剖面准则，为每个参数生成布尔值。\n\n该测试套件涵盖了不同的情况：\n- 测试案例1提供了密集的采样和中等噪声，预计将得到可辨识的 $k_{agg}$ 和 $k_{clear}$。\n- 测试案例2增加了 $\\sigma$，可能因似然曲面变平而降低可辨识性。\n- 测试案例3使用稀疏的早期时间点采样，此时对于小 $t$，$S(t) \\approx \\alpha k_{agg} t$，使得 $k_{clear}$ 难以辨识，因为早期动态对 $k_{clear}$ 的依赖性很弱。\n- 测试案例4采用非常缓慢的清除速率 $k_{clear}$，使得动态在时间窗口内接近线性；这通常会妨碍对 $k_{clear}$ 的精确辨识。\n\n程序输出一行：一个包含四个 $[b_{agg}, b_{clear}]$ 结果的列表，按测试案例的顺序排列，适合自动验证。每个布尔值直接编码了参数在组合准则下是否是实际可辨识的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares, minimize_scalar\n\ndef model_signal(t, k_agg, k_clear, alpha):\n    # S(t) = alpha * (k_agg / k_clear) * (1 - exp(-k_clear * t)), B0 = 0\n    t = np.asarray(t, dtype=float)\n    return alpha * (k_agg / k_clear) * (1.0 - np.exp(-k_clear * t))\n\ndef gradients(t, k_agg, k_clear, alpha):\n    # Analytical gradients of S(t;theta) wrt k_agg and k_clear\n    t = np.asarray(t, dtype=float)\n    exp_term = np.exp(-k_clear * t)\n    dS_dkagg = alpha * (1.0 - exp_term) / k_clear\n    # d/dk_clear of k_agg/k_clear * (1 - exp(-k_clear t))\n    term1 = -(1.0 - exp_term) / (k_clear**2)\n    term2 = (t * exp_term) / k_clear\n    dS_dkclear = alpha * k_agg * (term1 + term2)\n    return dS_dkagg, dS_dkclear\n\ndef fisher_information(t, theta, alpha, sigma):\n    k_agg, k_clear = theta\n    dS_dkagg, dS_dkclear = gradients(t, k_agg, k_clear, alpha)\n    # Build I = (1/sigma^2) sum J^T J\n    I11 = np.sum(dS_dkagg**2) / (sigma**2)\n    I22 = np.sum(dS_dkclear**2) / (sigma**2)\n    I12 = np.sum(dS_dkagg * dS_dkclear) / (sigma**2)\n    I = np.array([[I11, I12],\n                  [I12, I22]], dtype=float)\n    return I\n\ndef is_fim_identifiable(I, cond_threshold=1e6, eps=1e-12):\n    # Check positive definiteness and condition number\n    eigvals = np.linalg.eigvalsh(I)\n    pd = np.all(eigvals > eps)\n    # Avoid division by zero in condition number\n    if eigvals.min() = 0:\n        cond = np.inf\n    else:\n        cond = eigvals.max() / eigvals.min()\n    return pd and (cond  cond_threshold)\n\ndef sse(theta, t, y, alpha):\n    k_agg, k_clear = theta\n    # Clip to positive small values to avoid division by zero in model\n    if k_agg = 0 or k_clear = 0:\n        return np.inf\n    pred = model_signal(t, k_agg, k_clear, alpha)\n    res = y - pred\n    return float(np.sum(res**2))\n\ndef fit_theta(t, y, alpha, bounds=(1e-6, 1.0)):\n    # Nonlinear least squares on residuals with bounds\n    def residuals(theta):\n        return y - model_signal(t, theta[0], theta[1], alpha)\n    lb = np.array([bounds[0], bounds[0]], dtype=float)\n    ub = np.array([bounds[1], bounds[1]], dtype=float)\n    # Initial guess: moderate values\n    x0 = np.array([0.02, 0.1], dtype=float)\n    res = least_squares(residuals, x0=x0, bounds=(lb, ub), method='trf', jac='2-point', max_nfev=5000)\n    theta_hat = res.x\n    sse_hat = float(np.sum(res.fun**2))\n    return theta_hat, sse_hat\n\ndef profile_likelihood_param(param_name, t, y, alpha, sigma, theta_hat, sse_hat,\n                             grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0)):\n    # Build logarithmic grid for the profiled parameter\n    grid = np.exp(np.linspace(np.log(grid_min), np.log(grid_max), n_grid))\n    deltas = np.empty_like(grid)\n    # Optimize the other parameter for each fixed value\n    for i, val in enumerate(grid):\n        if param_name == 'k_agg':\n            fixed_k_agg = val\n            # Optimize k_clear with bounds\n            def obj(k_clear):\n                # k_clear is scalar\n                k_clear = float(k_clear)\n                if k_clear = 0:\n                    return np.inf\n                return sse((fixed_k_agg, k_clear), t, y, alpha)\n            res = minimize_scalar(obj, bounds=bounds, method='bounded', options={'xatol': 1e-6, 'maxiter': 500})\n            sse_val = float(res.fun)\n        elif param_name == 'k_clear':\n            fixed_k_clear = val\n            def obj(k_agg):\n                k_agg = float(k_agg)\n                if k_agg = 0:\n                    return np.inf\n                return sse((k_agg, fixed_k_clear), t, y, alpha)\n            res = minimize_scalar(obj, bounds=bounds, method='bounded', options={'xatol': 1e-6, 'maxiter': 500})\n            sse_val = float(res.fun)\n        else:\n            raise ValueError(\"Unknown parameter name for profiling\")\n        deltas[i] = (sse_val - sse_hat) / (sigma**2)\n    # Identify bounded 95% CI set within the grid using chi-square threshold\n    threshold = 3.841459  # 95% for 1 dof\n    min_idx = int(np.argmin(deltas))\n    # Search left and right for threshold crossings\n    left_cross = None\n    for i in range(min_idx, -1, -1):\n        if deltas[i] >= threshold:\n            left_cross = i\n            break\n    right_cross = None\n    for i in range(min_idx, len(deltas)):\n        if deltas[i] >= threshold:\n            right_cross = i\n            break\n    # Bounded if both crossings exist and there is at least one point below threshold between them\n    bounded = (left_cross is not None) and (right_cross is not None) and (left_cross  right_cross)\n    return bounded, grid, deltas\n\ndef assess_identifiability(t, theta_true, alpha, sigma, rng):\n    # Generate synthetic data\n    t = np.asarray(t, dtype=float)\n    y_true = model_signal(t, theta_true[0], theta_true[1], alpha)\n    noise = rng.normal(loc=0.0, scale=sigma, size=t.shape)\n    y = y_true + noise\n\n    # Fisher Information at true parameters\n    I = fisher_information(t, theta_true, alpha, sigma)\n    fim_ok = is_fim_identifiable(I, cond_threshold=1e6, eps=1e-12)\n\n    # Joint fit\n    theta_hat, sse_hat = fit_theta(t, y, alpha, bounds=(1e-6, 1.0))\n\n    # Profile likelihoods\n    bounded_kagg, _, _ = profile_likelihood_param('k_agg', t, y, alpha, sigma, theta_hat, sse_hat,\n                                                  grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0))\n    bounded_kclear, _, _ = profile_likelihood_param('k_clear', t, y, alpha, sigma, theta_hat, sse_hat,\n                                                    grid_min=1e-4, grid_max=1.0, n_grid=200, bounds=(1e-6, 1.0))\n    # Combined criterion: FIM criterion must hold AND profile boundedness must hold for each parameter\n    ident_kagg = bool(fim_ok and bounded_kagg)\n    ident_kclear = bool(fim_ok and bounded_kclear)\n    return [ident_kagg, ident_kclear]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (t_values, theta_true, alpha, sigma)\n        (np.arange(0.0, 60.0 + 1e-9, 2.0), (0.02, 0.10), 1.0, 0.02),   # Test Case 1\n        (np.arange(0.0, 60.0 + 1e-9, 2.0), (0.02, 0.10), 1.0, 0.10),   # Test Case 2\n        (np.array([0.0, 1.0, 2.0]), (0.02, 0.10), 1.0, 0.02),          # Test Case 3\n        (np.arange(0.0, 30.0 + 1e-9, 1.0), (0.02, 0.005), 1.0, 0.02),  # Test Case 4\n    ]\n\n    rng = np.random.default_rng(seed=0)\n    results = []\n    for t_vals, theta_true, alpha, sigma in test_cases:\n        res = assess_identifiability(t_vals, theta_true, alpha, sigma, rng)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Each result is a list [bool, bool]; we need a single-line string with brackets and commas.\n    # Convert booleans to Python's True/False textual representation.\n    def format_result(r):\n        return \"[\" + \",\".join([\"True\" if x else \"False\" for x in r]) + \"]\"\n    print(\"[\" + \",\".join(format_result(r) for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}