{
    "hands_on_practices": [
        {
            "introduction": "虽然我们经常使用带有通用常数 $C$ 的迹不等式，但理解其来源至关重要。本练习将引导您使用变分法，为简单的一维情况找到最优（或称“尖锐”）迹常数。这个过程揭示了迹不等式与微分方程之间的深刻联系，展示了如何从第一性原理推导出这些分析工具中的基本常数。",
            "id": "3424723",
            "problem": "在谱方法和间断Galerkin (DG) 方法的数值通量和罚参数分析中，单元边界上的尖锐迹不等式至关重要。考虑一维参考单元 $\\Omega = (0,1)$ 和赋有希尔伯特范数的索博列夫空间 $H^{1}(0,1)$\n$$\n\\|u\\|_{H^{1}(0,1)}^{2} = \\int_{0}^{1} \\left( |u(x)|^{2} + |u'(x)|^{2} \\right) \\, dx.\n$$\n边界 $\\partial \\Omega$ 由两个点 $\\{0,1\\}$ 组成。对于单点面 $\\{1\\}$，将迹的边界 $L^{2}$ 范数定义为\n$$\n\\|u\\|_{L^{2}(\\{x=1\\})} = |u(1)|,\n$$\n这对应于点集上的计数测度，并且在一维迹不等式中是标准的。\n\n确定精确的最小常数 $C > 0$，使得迹不等式\n$$\n\\|u\\|_{L^{2}(\\{x=1\\})} \\leq C \\, \\|u\\|_{H^{1}(0,1)}\n$$\n对所有 $u \\in H^{1}(0,1)$ 成立。您的答案必须是单一的闭式解析表达式。无需四舍五入，也不涉及物理单位。此外，请找出使等号成立的极值函数，并用它来推导出该常数，而不依赖任何预先制表的公式。",
            "solution": "用户提供的问题经验证是适定的、有科学依据且自洽的。这是一个关于索博列夫迹不等式中最优常数的标准泛函分析问题。因此，我们可以进行求解。\n\n问题在于找到最小的常数 $C > 0$，使得对所有函数 $u \\in H^{1}(0,1)$，以下迹不等式成立：\n$$\n|u(1)| \\leq C \\|u\\|_{H^{1}(0,1)}\n$$\n其中 $H^{1}(0,1)$ 上的范数由下式给出\n$$\n\\|u\\|_{H^{1}(0,1)}^{2} = \\int_{0}^{1} \\left( |u(x)|^{2} + |u'(x)|^{2} \\right) \\, dx.\n$$\n通过对不等式两边进行平方并重新整理，我们可以将最优常数 $C$ 的平方定义为一个瑞利商的上确界：\n$$\nC^2 = \\sup_{u \\in H^{1}(0,1) \\setminus \\{0\\}} \\frac{|u(1)|^2}{\\|u\\|_{H^{1}(0,1)}^2} = \\sup_{u \\in H^{1}(0,1) \\setminus \\{0\\}} \\frac{|u(1)|^2}{\\int_{0}^{1} \\left( |u(x)|^2 + |u'(x)|^2 \\right) \\, dx}\n$$\n不失一般性，我们可以考虑实值函数，因此 $|u(x)|$ 变为 $u(x)$。寻找这个上确界的问题是变分法中的一个经典问题。使该商最大化的函数 $u(x)$，即所谓的极值函数，必须满足相关的欧拉-拉格朗日方程。\n\n令 $J(u)$ 为待最大化的泛函：\n$$\nJ(u) = \\frac{u(1)^2}{\\int_{0}^{1} \\left( u(x)^2 + u'(x)^2 \\right) \\, dx}\n$$\n对于极值函数 $u$，$J(u)$ 的一阶变分必须为零。对于任何容许变分 $v \\in H^1(0,1)$，我们必须有 $\\delta J(u;v) = 0$。其Gateaux导数为：\n$$\n\\delta J(u;v) = \\left. \\frac{d}{d\\epsilon} J(u+\\epsilon v) \\right|_{\\epsilon=0} = \\frac{2u(1)v(1) \\left( \\int_{0}^{1} (u^2 + u'^2)dx \\right) - u(1)^2 \\left( 2\\int_{0}^{1} (uv+u'v')dx \\right)}{\\left(\\int_{0}^{1} (u^2 + u'^2)dx\\right)^2} = 0\n$$\n假设对于非平凡解 $u(1) \\neq 0$，上式可简化为：\n$$\nu(1)v(1) \\int_{0}^{1} (u^2 + u'^2)dx - u(1)^2 \\int_{0}^{1} (uv+u'v')dx = 0\n$$\n$$\nv(1) \\frac{\\int_{0}^{1} (u^2 + u'^2)dx}{u(1)} - \\int_{0}^{1} (uv+u'v')dx = 0\n$$\n对于极值函数 $u$，该商的值为 $C^2$。因此，$C^2 = \\frac{u(1)^2}{\\int_{0}^{1} (u^2+u'^2)dx}$。这意味着 $\\frac{\\int_{0}^{1} (u^2+u'^2)dx}{u(1)} = \\frac{u(1)}{C^2}$。将此代入变分方程，得到问题的弱形式：\n$$\n\\int_{0}^{1} \\left( u(x)v(x) + u'(x)v'(x) \\right) \\, dx = \\frac{u(1)}{C^2} v(1) \\quad \\forall v \\in H^1(0,1)\n$$\n为了得到强形式（一个带有边界条件的微分方程），我们对 $\\int_{0}^{1} u'(x)v'(x)dx$ 项应用分部积分：\n$$\n\\int_{0}^{1} u'(x)v'(x)dx = [u'(x)v(x)]_{0}^{1} - \\int_{0}^{1} u''(x)v(x)dx = u'(1)v(1) - u'(0)v(0) - \\int_{0}^{1} u''(x)v(x)dx\n$$\n将此代回弱形式，得到：\n$$\n\\int_{0}^{1} u(x)v(x)dx + u'(1)v(1) - u'(0)v(0) - \\int_{0}^{1} u''(x)v(x)dx = \\frac{u(1)}{C^2} v(1)\n$$\n合并项：\n$$\n\\int_{0}^{1} \\left( u(x) - u''(x) \\right) v(x) dx + \\left( u'(1) - \\frac{u(1)}{C^2} \\right) v(1) - u'(0)v(0) = 0\n$$\n此式必须对所有 $v \\in H^1(0,1)$ 成立。\n1.  通过选择在边界上为零的测试函数 $v$（即 $v \\in H_0^1(0,1)$，$v(0)=v(1)=0$），边界项为零。根据变分法基本引理，被积函数必须为零，这给出了欧拉-拉格朗日微分方程：\n    $$\n    u''(x) - u(x) = 0 \\quad \\text{for } x \\in (0,1)\n    $$\n2.  在微分方程成立的情况下，对于任何 $v$，积分项都为零。方程简化为自然边界条件：\n    $$\n    \\left( u'(1) - \\frac{u(1)}{C^2} \\right) v(1) - u'(0)v(0) = 0\n    $$\n    通过选择 $v$ 使得 $v(0)=1$ 和 $v(1)=0$，我们得到在 $x=0$ 处的条件：\n    $$\n    u'(0) = 0\n    $$\n    通过选择 $v$ 使得 $v(0)=0$ 和 $v(1)=1$，我们得到在 $x=1$ 处的条件：\n    $$\n    u'(1) = \\frac{u(1)}{C^2}\n    $$\n现在问题简化为求解这个边值问题。$u'' - u = 0$ 的通解是 $u(x) = A e^x + B e^{-x}$。其导数是 $u'(x) = A e^x - B e^{-x}$。\n应用在 $x=0$ 处的条件：\n$u'(0) = A - B = 0$，这意味着 $A=B$。\n因此，极值函数必须具有 $u(x) = A(e^x + e^{-x}) = K \\cosh(x)$ 的形式，其中 $K=2A$ 是某个常数。对于非平凡解，$K \\neq 0$。\n\n现在，我们使用在 $x=1$ 处的边界条件来确定常数 $C^2$。\n对于 $u(x) = K \\cosh(x)$，我们有 $u(1) = K \\cosh(1)$ 和 $u'(1) = K \\sinh(1)$。\n将这些代入 $u'(1) = \\frac{u(1)}{C^2}$：\n$$\nK \\sinh(1) = \\frac{K \\cosh(1)}{C^2}\n$$\n由于 $K \\neq 0$，我们可以除以它：\n$$\n\\sinh(1) = \\frac{\\cosh(1)}{C^2}\n$$\n解出 $C^2$，我们得到：\n$$\nC^2 = \\frac{\\cosh(1)}{\\sinh(1)} = \\coth(1)\n$$\n精确的最小常数 $C$ 是该值的正平方根：\n$$\nC = \\sqrt{\\coth(1)}\n$$\n达到此界的极值函数是 $u(x) = \\cosh(x)$ 的任何非零倍数。我们可以用指数函数将 $\\coth(1)$ 表示为 $\\coth(1) = \\frac{e^1 + e^{-1}}{e^1 - e^{-1}} = \\frac{e^2+1}{e^2-1}$。",
            "answer": "$$\n\\boxed{\\sqrt{\\coth(1)}}\n$$"
        },
        {
            "introduction": "在理解了如何从理论上推导尖锐常数之后，下一步是应用标准迹不等式公式。本练习涉及在一个三维四面体单元上的一个具体多项式函数。您的目标是计算边界积分的一个显式上界，这有助于理解该界限如何依赖于单元尺寸 $h_{K}$ 以及函数自身的属性（即其函数值和梯度）。",
            "id": "3424658",
            "problem": "设 $K \\subset \\mathbb{R}^{3}$ 为缩放的单位单纯形（四面体）\n$$\nK = \\left\\{ x \\in \\mathbb{R}^{3} : x_{i} \\ge 0 \\text{ for } i=1,2,3,\\; x_{1}+x_{2}+x_{3} \\le h_{K} \\right\\},\n$$\n其单元尺寸参数为 $h_{K} > 0$，并设 $F$ 为其任意一个面（为确定起见，取 $F = \\{ x \\in K : x_{1} = 0 \\}$）。考虑多项式场 $v(x) = 1 + \\sum_{i=1}^{3} x_{i}$。使用形状正则四面体的标准逐面迹不等式，该不等式涉及一个常数 $C_{\\mathrm{tr}}>0$，它仅依赖于 $K$ 的形状正则性，而不依赖于 $h_{K}$，推导边界积分 $\\int_{F} v(x)^{2}\\,ds$ 关于 $h_{K}$、$C_{\\mathrm{tr}}$ 和 $K$ 上的体积积分的显式上界。你的最终上界必须是关于 $h_{K}$ 和 $C_{\\mathrm{tr}}$ 的单一闭式解析表达式。此外，在推导过程中，请指明该界如何随 $h_{K}$ 缩放。除了基本定义和经过充分检验的结果外，不要假设或引用任何快捷公式；直接从 $K$ 的几何形状推导任何所需的积分。最终报告的上界必须是单一的解析表达式；最终答案中不允许出现不等式。",
            "solution": "我们从形状正则单元（三维中的四面体）上经过充分检验的逐面迹不等式开始。对于任意 $v \\in H^{1}(K)$ 和任意面 $F \\subset \\partial K$，存在一个仅依赖于 $K$ 的形状正则性（但不依赖于 $h_{K}$ 或 $v$）的常数 $C_{\\mathrm{tr}}>0$，使得\n$$\n\\int_{F} v^{2}\\,ds \\le C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\int_{K} v^{2}\\,dx + h_{K} \\int_{K} |\\nabla v|^{2}\\,dx \\right).\n$$\n我们的任务是对于给定的特定 $v(x) = 1 + x_{1} + x_{2} + x_{3}$ 和四面体 $K$\n$$\nK = \\left\\{ x \\in \\mathbb{R}^{3} : x_{i} \\ge 0,\\; x_{1}+x_{2}+x_{3} \\le h_{K} \\right\\},\n$$\n计算右侧的体积积分。\n\n为了计算所需的积分，我们使用从参考单位单纯形 $\\widehat{K} = \\{ \\widehat{x} \\in \\mathbb{R}^{3} : \\widehat{x}_{i} \\ge 0,\\; \\widehat{x}_{1}+\\widehat{x}_{2}+\\widehat{x}_{3} \\le 1 \\}$ 通过 $x = h_{K} \\widehat{x}$ 进行的缩放。这个仿射映射的雅可比行列式为 $h_{K}^{3}$，因此 $dx = h_{K}^{3}\\,d\\widehat{x}$。$\\widehat{K}$ 的体积为\n$$\n\\operatorname{vol}(\\widehat{K}) = \\frac{1}{6}.\n$$\n在此缩放变换下，$v(x)$ 变为\n$$\nv(x) = 1 + x_{1} + x_{2} + x_{3} = 1 + h_{K} \\left( \\widehat{x}_{1} + \\widehat{x}_{2} + \\widehat{x}_{3} \\right).\n$$\n\n我们首先计算 $\\int_{K} v^{2}\\,dx$：\n\\begin{align*}\n\\int_{K} v^{2}\\,dx\n&= \\int_{\\widehat{K}} \\left( 1 + h_{K} \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} h_{K}^{3}\\,d\\widehat{x} \\\\\n&= h_{K}^{3} \\int_{\\widehat{K}} \\left( 1 + 2 h_{K} \\sum_{i=1}^{3} \\widehat{x}_{i} + h_{K}^{2} \\left( \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} \\right) d\\widehat{x}.\n\\end{align*}\n我们现在使用三维单位单纯形 $\\widehat{K}$ 上的标准矩公式：\n- $\\displaystyle \\int_{\\widehat{K}} 1\\,d\\widehat{x} = \\frac{1}{6}$。\n- $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}\\,d\\widehat{x} = \\frac{1}{24}$，因此 $\\displaystyle \\int_{\\widehat{K}} \\sum_{i=1}^{3} \\widehat{x}_{i}\\,d\\widehat{x} = \\frac{3}{24} = \\frac{1}{8}$。\n- $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}^{2}\\,d\\widehat{x} = \\frac{1}{60}$ 且当 $i \\ne j$ 时 $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}\\widehat{x}_{j}\\,d\\widehat{x} = \\frac{1}{120}$。因此\n\\begin{align*}\n\\int_{\\widehat{K}} \\left( \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} d\\widehat{x}\n&= \\sum_{i=1}^{3} \\int_{\\widehat{K}} \\widehat{x}_{i}^{2}\\,d\\widehat{x} + 2 \\sum_{1 \\le i  j \\le 3} \\int_{\\widehat{K}} \\widehat{x}_{i}\\widehat{x}_{j}\\,d\\widehat{x} \\\\\n= 3 \\cdot \\frac{1}{60} + 2 \\cdot 3 \\cdot \\frac{1}{120} = \\frac{1}{20} + \\frac{1}{20} = \\frac{1}{10}.\n\\end{align*}\n因此，\n\\begin{align*}\n\\int_{K} v^{2}\\,dx\n= h_{K}^{3} \\left( \\frac{1}{6} + 2 h_{K} \\cdot \\frac{1}{8} + h_{K}^{2} \\cdot \\frac{1}{10} \\right) \\\\\n= h_{K}^{3} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right).\n\\end{align*}\n\n接下来，我们计算 $\\int_{K} |\\nabla v|^{2}\\,dx$。由于 $v(x) = 1 + x_{1} + x_{2} + x_{3}$，\n$$\n\\nabla v(x) = (1, 1, 1), \\quad |\\nabla v|^{2} = 1^{2} + 1^{2} + 1^{2} = 3,\n$$\n它在 $K$ 上是常数。因此，\n\\begin{align*}\n\\int_{K} |\\nabla v|^{2}\\,dx = 3 \\int_{K} 1\\,dx = 3\\,\\operatorname{vol}(K) = 3 \\cdot h_{K}^{3} \\cdot \\operatorname{vol}(\\widehat{K}) = 3 \\cdot h_{K}^{3} \\cdot \\frac{1}{6} = \\frac{h_{K}^{3}}{2}.\n\\end{align*}\n\n将这些表达式代入迹不等式可得\n\\begin{align*}\n\\int_{F} v^{2}\\,ds\n\\le C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\int_{K} v^{2}\\,dx + h_{K} \\int_{K} |\\nabla v|^{2}\\,dx \\right) \\\\\n= C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\cdot h_{K}^{3} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right) + h_{K} \\cdot \\frac{h_{K}^{3}}{2} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( h_{K}^{2} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right) + \\frac{h_{K}^{4}}{2} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\left( \\frac{1}{10} + \\frac{1}{2} \\right) h_{K}^{4} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\frac{3}{5} h_{K}^{4} \\right).\n\\end{align*}\n\n这个上界表现出预期的随 $h_{K}$ 的缩放关系：主阶项与 $h_{K}^{2}$ 成正比，这与面的面积缩放相匹配。对于小的 $h_{K}$，主要贡献是 $\\displaystyle C_{\\mathrm{tr}} \\frac{h_{K}^{2}}{6}$，带有 $h_{K}^{3}$ 和 $h_{K}^{4}$ 阶的高阶修正。\n\n因此，最终所需的单一解析表达式为\n$$\nC_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\frac{3}{5} h_{K}^{4} \\right).\n$$",
            "answer": "$$\\boxed{C_{\\mathrm{tr}}\\left(\\frac{h_{K}^{2}}{6}+\\frac{h_{K}^{3}}{4}+\\frac{3}{5}h_{K}^{4}\\right)}$$"
        },
        {
            "introduction": "在像间断有限元（DG）这样的现代数值方法中，我们处理的是有限维多项式空间，而非完整的 Sobolev 空间。本练习通过展示如何为给定的多项式空间计算*离散*迹常数，从而将理论与实践联系起来。它将寻找最大范数比的问题重新表述为一个广义特征值问题，这是科学计算中的一个常见任务，也是在实际代码中确定稳定化参数的关键步骤。",
            "id": "3424636",
            "problem": "设 $K$ 表示一个用于谱方法和间断 Galerkin (DG) 方法的二维单元。单元层级的连续迹不等式表明，存在一个常数 $C_{\\mathrm{tr}}$，使得对于足够光滑的 $u$，\n$$\n\\lVert u \\rVert_{\\partial K} \\leq C_{\\mathrm{tr}} \\, \\lVert u \\rVert_{K},\n$$\n成立，其中 $\\lVert \\cdot \\rVert_{\\partial K}$ 是边界 $\\partial K$ 上的 $L^2$ 范数，而 $\\lVert \\cdot \\rVert_{K}$ 是内部 $K$ 上的 $L^2$ 范数。在实际的高阶方法中，有限维多项式空间上边界范数与内部范数的极值比决定了离散迹常数，这些常数控制着数值通量和罚项的稳定性。您的任务是设计并实现一个数值实验，对于给定的单元尺寸和多项式次数，确定最大比值\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K}}{\\lVert u \\rVert_{K}},\n$$\n其中 $\\mathcal{V}_p$ 是 $K$ 上次数至多为 $p$ 的张量积多项式空间。\n\n请在以下科学严谨、完全指定的设置下进行工作：\n\n- 几何与映射。使用参考正方形 $K_{\\mathrm{ref}} = [-1,1]^2$ 和由 $x = \\frac{h}{2}\\,\\xi$ 和 $y = \\frac{h}{2}\\,\\eta$ 定义的仿射映射 $F_h : K_{\\mathrm{ref}} \\to K_h$，其中 $(\\xi,\\eta) \\in [-1,1]^2$ 且 $h > 0$ 是物理正方形 $K_h$ 的边长。雅可比行列式满足 $\\lvert J \\rvert = \\left(\\frac{h}{2}\\right)^2$，边界线元缩放为 $\\left(\\frac{h}{2}\\right)$。\n\n- 多项式空间。取 $\\mathcal{V}_p = Q_p(K_{\\mathrm{ref}})$，即由勒让德多项式 $\\{P_i(\\xi)\\}_{i=0}^{p}$ 和 $\\{P_j(\\eta)\\}_{j=0}^{p}$ 张成的张量积空间，即基函数为 $\\phi_{ij}(\\xi,\\eta) = P_i(\\xi) P_j(\\eta)$，其中 $0 \\le i,j \\le p$。勒让德多项式由 $P_0(x)=1$，$P_1(x)=x$ 以及对于 $n \\ge 1$ 的递推关系 $(n+1)P_{n+1}(x) = (2n+1)x P_n(x) - n P_{n-1}(x)$ 定义。\n\n- 范数。对于一个从 $K_h$ 通过 $F_h^{-1}$ 拉回到 $K_{\\mathrm{ref}}$ 的函数 $u \\in \\mathcal{V}_p$（即，在 $K_{\\mathrm{ref}}$ 上视为 $u(\\xi,\\eta)$），定义\n$$\n\\lVert u \\rVert_{K_h}^2 = \\int_{K_h} u^2 \\, \\mathrm{d}A = \\int_{K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right)^2 \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta,\n$$\n$$\n\\lVert u \\rVert_{\\partial K_h}^2 = \\int_{\\partial K_h} u^2 \\, \\mathrm{d}s = \\int_{\\partial K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right) \\, \\mathrm{d}\\sigma.\n$$\n\n- 优化目标。考虑瑞利商\n$$\nR(u) = \\frac{\\lVert u \\rVert_{\\partial K_h}^2}{\\lVert u \\rVert_{K_h}^2},\n$$\n其定义域为 $u \\in \\mathcal{V}_p \\setminus \\{0\\}$。其最大值的平方根即为所求的最大比值 $\\sup \\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h}$。\n\n- 积分的离散化。在每个方向上使用 $n_q = p + 3$ 个点数的张量积高斯-勒让德求积来组装：\n  1. 内部对称正定质量矩阵 $M \\in \\mathbb{R}^{N \\times N}$（其中 $N=(p+1)^2$），该矩阵通过在 $K_{\\mathrm{ref}}$ 上的求积并包含因子 $\\left(\\frac{h}{2}\\right)^2$ 来近似 $\\lVert u \\rVert_{K_h}^2$。\n  2. 边界对称质量矩阵 $B \\in \\mathbb{R}^{N \\times N}$，该矩阵通过在 $K_{\\mathrm{ref}}$ 的四条边上分别进行一维高斯-勒让德求积并包含因子 $\\left(\\frac{h}{2}\\right)$ 来近似 $\\lVert u \\rVert_{\\partial K_h}^2$。\n\n- 最大比值的计算。构建广义对称特征值问题 $B \\mathbf{v} = \\lambda M \\mathbf{v}$。最大特征值 $\\lambda_{\\max}$（非负）满足 $\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} R(u) = \\lambda_{\\max}$，所求的最大比值为 $\\sqrt{\\lambda_{\\max}}$。\n\n推导的基本假设必须从 $L^2$ 范数的定义、勒让德多项式的性质、高斯-勒让德求积对多项式的精确性以及对称定对的广义特征值的瑞利商表征出发。\n\n您必须实现一个完整的程序，该程序：\n- 按照描述构建 $M$ 和 $B$，\n- 求解广义特征值问题以找到 $\\lambda_{\\max}$，\n- 对每个请求的测试用例输出最大比值 $\\sqrt{\\lambda_{\\max}}$。\n\n单位：由于比值 $\\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h}$ 的量纲是长度平方根的倒数，因此将每个输出表示为纯浮点数，在 $h$ 以一致的长度单位表示的情况下，其单位默认为 $1/\\sqrt{\\text{长度}}$。不打印任何单位字符串。\n\n测试套件与最终输出规范：\n- 使用以下有序的测试套件，每项为一对 $(p,h)$：\n  1. $(0,\\,1.0)$,\n  2. $(1,\\,1.0)$,\n  3. $(3,\\,0.5)$,\n  4. $(6,\\,2.0)$,\n  5. $(10,\\,1.0)$。\n- 您的程序应生成一行输出，其中包含这些测试用例的最大比值，形式为逗号分隔的十进制数列表，并用方括号括起来。例如，输出行应类似于\n$[r_1,r_2,r_3,r_4,r_5]$,\n其中每个 $r_i$ 是一个浮点数，小数点后精确到十位。\n\n您的实现不得读取任何输入，并且必须仅使用指定的运行时环境。",
            "solution": "我们从基本的数学定义开始。对于函数 $u \\in L^2(K)$，其在内部 $K$ 上的 $L^2$ 范数定义为\n$$\n\\lVert u \\rVert_{K}^2 = \\int_{K} u^2 \\, \\mathrm{d}A.\n$$\n类似地，其在边界 $\\partial K$ 上的 $L^2$ 范数定义为\n$$\n\\lVert u \\rVert_{\\partial K}^2 = \\int_{\\partial K} u^2 \\, \\mathrm{d}s.\n$$\n在从参考正方形 $K_{\\mathrm{ref}} = [-1,1]^2$ 到物理正方形 $K_h$ 的仿射映射 $F_h : (\\xi,\\eta) \\mapsto \\left(\\frac{h}{2}\\xi, \\frac{h}{2}\\eta \\right)$ 下，面积元变换为 $\\mathrm{d}A = \\left(\\frac{h}{2}\\right)^2 \\mathrm{d}\\xi \\mathrm{d}\\eta$，边界线元变换为 $\\mathrm{d}s = \\left(\\frac{h}{2}\\right) \\mathrm{d}\\sigma$，其中 $\\mathrm{d}\\sigma$ 是 $\\partial K_{\\mathrm{ref}}$ 上的线测度。因此，对于一个从 $K_h$ 拉回到 $K_{\\mathrm{ref}}$ 的函数 $u$，我们得到\n$$\n\\lVert u \\rVert_{K_h}^2 = \\int_{K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right)^2 \\mathrm{d}\\xi \\mathrm{d}\\eta,\n\\quad\n\\lVert u \\rVert_{\\partial K_h}^2 = \\int_{\\partial K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right) \\mathrm{d}\\sigma.\n$$\n空间 $\\mathcal{V}_p = Q_p(K_{\\mathrm{ref}})$ 是由张量积基函数\n$$\n\\phi_{ij}(\\xi,\\eta) = P_i(\\xi) P_j(\\eta), \\quad 0 \\le i,j \\le p,\n$$\n张成的空间，其中 $\\{P_n\\}_{n=0}^{p}$ 是 $[-1,1]$ 上的勒让德多项式，由 $P_0(x) = 1$，$P_1(x) = x$ 以及递推关系\n$$\n(n+1)P_{n+1}(x) = (2n+1) x \\, P_n(x) - n \\, P_{n-1}(x), \\quad n \\ge 1.\n$$\n定义。勒让德多项式关于 $[-1,1]$ 上的标准 $L^2$ 内积是正交的，并且具有 $n_q$ 个点的高斯-勒让德求积能够精确积分至多 $2n_q - 1$ 次的多项式。\n\n为了确定最大比值\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K_h}}{\\lVert u \\rVert_{K_h}},\n$$\n我们考虑瑞利商形式的平方比值：\n$$\nR(u) = \\frac{\\lVert u \\rVert_{\\partial K_h}^2}{\\lVert u \\rVert_{K_h}^2}.\n$$\n如果我们在基 $\\{\\phi_{ij}\\}$ 中展开 $u$，\n$$\nu(\\xi,\\eta) = \\sum_{i=0}^p \\sum_{j=0}^p c_{ij} \\, \\phi_{ij}(\\xi,\\eta),\n$$\n并将系数收集到一个向量 $\\mathbf{c} \\in \\mathbb{R}^{N}$ 中，其中 $N = (p+1)^2$，那么内部范数的平方和边界范数的平方可以通过求积近似为二次型\n$$\n\\lVert u \\rVert_{K_h}^2 \\approx \\mathbf{c}^\\top M \\, \\mathbf{c}, \\qquad \\lVert u \\rVert_{\\partial K_h}^2 \\approx \\mathbf{c}^\\top B \\, \\mathbf{c},\n$$\n其中 $M$ 是对称正定质量矩阵，通过在 $K_{\\mathrm{ref}}$ 上进行二维高斯-勒让德求积并包含因子 $\\left(\\frac{h}{2}\\right)^2$ 组装而成；$B$ 是对称边界质量矩阵，通过在 $K_{\\mathrm{ref}}$ 的四条边上分别进行一维高斯-勒让德求积并包含因子 $\\left(\\frac{h}{2}\\right)$ 组装而成。在每个一维求积中选择 $n_q = p+3$ 确保了矩阵项中出现的所有多项式乘积的精确积分，因为被积函数在每个变量中的次数最多为 $2p$。\n\n系数向量的瑞利商变为\n$$\nR(\\mathbf{c}) = \\frac{\\mathbf{c}^\\top B \\, \\mathbf{c}}{\\mathbf{c}^\\top M \\, \\mathbf{c}}.\n$$\n根据瑞利商对于对称矩阵对 $(B,M)$（其中 $M$ 为对称正定矩阵）的基本性质，当 $\\mathbf{c} \\neq \\mathbf{0}$ 时，$R(\\mathbf{c})$ 的最大值等于满足\n$$\nB \\mathbf{v} = \\lambda M \\mathbf{v}.\n$$\n的最大广义特征值 $\\lambda_{\\max}$。因此，\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} R(u) = \\lambda_{\\max},\n\\quad \\text{以及} \\quad\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K_h}}{\\lVert u \\rVert_{K_h}} = \\sqrt{\\lambda_{\\max}}.\n$$\n\n算法设计：\n1. 选择多项式次数 $p$ 和边长 $h$。设置求积阶数 $n_q = p + 3$。\n2. 计算 $[-1,1]$ 上的一维高斯-勒让德节点和权重 $\\{x_k, w_k\\}_{k=1}^{n_q}$。\n3. 在两个方向（$\\xi$ 和 $\\eta$）的节点上计算勒让德多项式 $P_n(x_k)$（$n=0,\\dots,p$），通过递推关系形成矩阵 $L_x \\in \\mathbb{R}^{(p+1) \\times n_q}$ 和 $L_y \\in \\mathbb{R}^{(p+1) \\times n_q}$。\n4. 组装内部质量矩阵 $M$：\n   - 通过 $L_x$ 和 $L_y$ 的外积，在二维求积网格上形成每个基函数的张量积求值。\n   - 将一维权重的克罗内克积乘以 $\\left(\\frac{h}{2}\\right)^2$ 构造二维求积权重，并用它们来组装 $M = V_{\\mathrm{int}} \\, \\mathrm{diag}(W_{\\mathrm{int}}) \\, V_{\\mathrm{int}}^\\top$，其中 $V_{\\mathrm{int}}$ 是网格上的基函数求值矩阵。\n5. 组装边界质量矩阵 $B$：\n   - 对于 $K_{\\mathrm{ref}}$ 的四条边中的每一条，沿该边计算基函数的值。对于 $\\xi = \\pm 1$ 的边，固定坐标使用 $P_i(\\pm 1)$，变化方向使用 $L_y$；对于 $\\eta = \\pm 1$ 的边，变化方向使用 $L_x$，固定坐标使用 $P_j(\\pm 1)$。\n   - 将一维求积权重乘以 $\\left(\\frac{h}{2}\\right)$ 并组装贡献 $B_{\\mathrm{edge}} = V_{\\mathrm{edge}} \\, \\mathrm{diag}(W_{\\mathrm{edge}}) \\, V_{\\mathrm{edge}}^\\top$；将四条边的贡献相加得到 $B$。\n6. 使用对称求解器求解广义特征值问题 $B \\mathbf{v} = \\lambda M \\mathbf{v}$，得到特征值并取最大值 $\\lambda_{\\max}$。\n7. 报告最大比值 $\\sqrt{\\lambda_{\\max}}$。\n\n合理性检查：\n- 对于 $p=0$（仅常数基），可以精确计算出 $\\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h} = \\sqrt{\\frac{\\text{perimeter}(K_h)}{\\text{area}(K_h)}} = \\sqrt{\\frac{4h}{h^2}} = \\frac{2}{\\sqrt{h}}$，数值方法会重现此结果，因为求积对常数是精确的。\n\n数值细节：\n- 使用 $n_q = p+3$ 以确保在一维上达到 $2p+5$ 次的精确度，这覆盖了遇到的所有多项式乘积。\n- 使用稳定的勒让德递推关系在求积节点上计算 $P_n$，包括通过递推（或直接通过已知的端点性质）计算值 $P_n(\\pm 1) = (\\pm 1)^n$。\n- 对 $(B,M)$ 使用对称广义特征值求解器，以避免显式计算 $M^{-1}$；由于 $B$ 和 $M$ 的正性，最大特征值是非负的。\n\n最后，将此过程应用于测试套件 $(p,h) \\in \\{(0,1.0), (1,1.0), (3,0.5), (6,2.0), (10,1.0)\\}$，并以逗号分隔的列表形式在一行中打印最大比值，用方括号括起来，每个值格式化为小数点后十位。",
            "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.linalg import eigh\n\ndef legendre_matrix(x, p):\n    \"\"\"\n    Compute Legendre polynomials P_n(x) for n=0..p at points x using recurrence.\n    Returns an array L of shape (p+1, len(x)), where L[n, :] = P_n(x).\n    \"\"\"\n    x = np.asarray(x)\n    npts = x.size\n    L = np.zeros((p + 1, npts), dtype=np.float64)\n    L[0, :] = 1.0\n    if p = 1:\n        L[1, :] = x\n        for n in range(1, p):\n            # (n+1) P_{n+1}(x) = (2n+1) x P_n(x) - n P_{n-1}(x)\n            L[n + 1, :] = ((2 * n + 1) * x * L[n, :] - n * L[n - 1, :]) / (n + 1)\n    return L\n\ndef assemble_matrices(p, h):\n    \"\"\"\n    Assemble interior mass matrix M and boundary mass matrix B for Q_p on the square K_h.\n    Uses Gauss-Legendre quadrature with n_q = p + 3 points in each direction.\n    \"\"\"\n    n_q = p + 3  # sufficient for exactness up to degree 2p+5\n    # 1D Gauss-Legendre nodes and weights on [-1,1]\n    x_nodes, x_weights = leggauss(n_q)\n    y_nodes, y_weights = x_nodes, x_weights  # same quadrature in both directions\n\n    # Evaluate Legendre polynomials at nodes\n    Lx = legendre_matrix(x_nodes, p)  # shape (p+1, n_q)\n    Ly = legendre_matrix(y_nodes, p)  # shape (p+1, n_q)\n\n    # Basis count\n    dim = (p + 1) ** 2\n\n    # Assemble interior evaluation matrix V_int: shape (dim, n_q * n_q)\n    # Each basis phi_{i,j} evaluated at all tensor-product nodes\n    # To build efficiently, we use outer products of 1D evaluations\n    V_int = np.zeros((dim, n_q * n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            # Evaluate P_i(x) * P_j(y) over grid\n            # Outer product gives (n_q, n_q), then flatten in row-major or column-major consistently\n            vals = np.outer(Lx[i, :], Ly[j, :]).ravel()  # flatten\n            V_int[idx, :] = vals\n            idx += 1\n\n    # Interior weights (tensor product), scaled by (h/2)^2\n    alpha = h / 2.0\n    W_int = alpha ** 2 * np.kron(x_weights, y_weights)  # shape (n_q * n_q,)\n\n    # Assemble interior mass matrix: M = V_int * diag(W_int) * V_int^T\n    # Using weighted inner product: M[m,n] = sum_k W_int[k] * V_int[m,k] * V_int[n,k]\n    # Implement via matrix multiplication with weighting\n    # Compute V_int * diag(sqrt(W_int))\n    sqrt_W_int = np.sqrt(W_int)\n    Vw_int = V_int * sqrt_W_int[np.newaxis, :]\n    M = Vw_int @ Vw_int.T\n\n    # Assemble boundary mass matrix B: sum over four edges\n    B = np.zeros((dim, dim), dtype=np.float64)\n\n    # One-dimensional weights for edges, scaled by alpha\n    W_edge = alpha * x_weights  # shape (n_q,)\n\n    # Precompute endpoint values P_i(±1)\n    P_at_plus1 = np.ones(p + 1, dtype=np.float64)\n    P_at_minus1 = np.array([(-1) ** n for n in range(p + 1)], dtype=np.float64)\n\n    # Edge xi = +1: (xi, eta) = (1, t), t in [-1,1]\n    V_edge_plus_x = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_plus_x[idx, :] = P_at_plus1[i] * Ly[j, :]\n            idx += 1\n    Vw_edge_plus_x = V_edge_plus_x * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_plus_x @ Vw_edge_plus_x.T\n\n    # Edge xi = -1: (xi, eta) = (-1, t)\n    V_edge_minus_x = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_minus_x[idx, :] = P_at_minus1[i] * Ly[j, :]\n            idx += 1\n    Vw_edge_minus_x = V_edge_minus_x * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_minus_x @ Vw_edge_minus_x.T\n\n    # Edge eta = +1: (xi, eta) = (t, 1)\n    V_edge_plus_y = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_plus_y[idx, :] = Lx[i, :] * P_at_plus1[j]\n            idx += 1\n    Vw_edge_plus_y = V_edge_plus_y * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_plus_y @ Vw_edge_plus_y.T\n\n    # Edge eta = -1: (xi, eta) = (t, -1)\n    V_edge_minus_y = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_minus_y[idx, :] = Lx[i, :] * P_at_minus1[j]\n            idx += 1\n    Vw_edge_minus_y = V_edge_minus_y * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_minus_y @ Vw_edge_minus_y.T\n\n    return M, B\n\ndef maximal_ratio(p, h):\n    \"\"\"\n    Compute the maximal ratio ||u||_{∂K_h} / ||u||_{K_h} over u in Q_p(K_ref) mapped to K_h.\n    \"\"\"\n    M, B = assemble_matrices(p, h)\n    # Solve the generalized eigenproblem B v = lambda M v\n    # eigh returns eigenvalues in ascending order\n    evals = eigh(B, M, eigvals_only=True)\n    lambda_max = np.max(evals)\n    # Numerical guard: ensure non-negativity\n    if lambda_max  0 and lambda_max  -1e-12:\n        lambda_max = 0.0\n    ratio = np.sqrt(lambda_max)\n    return float(ratio)\n\ndef solve():\n    test_cases = [\n        (0, 1.0),\n        (1, 1.0),\n        (3, 0.5),\n        (6, 2.0),\n        (10, 1.0),\n    ]\n    results = []\n    for p, h in test_cases:\n        r = maximal_ratio(p, h)\n        results.append(r)\n    # Print with exactly ten digits after the decimal point\n    formatted = \",\".join(f\"{val:.10f}\" for val in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}