{
    "hands_on_practices": [
        {
            "introduction": "To begin, we ground our understanding of residual-based estimators with a direct calculation. This exercise  breaks down a local error indicator $\\eta_K$ into its fundamental components: the interior residual within an element and the flux jumps across its edges. By computing the indicator from given data, you will gain a concrete feel for how these distinct sources of error are weighted and combined to assess solution quality on a local level.",
            "id": "3514528",
            "problem": "Consider a stationary scalar diffusion model representative of a single-field subproblem within a multiphysics coupled simulation, governed by the strong form $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on a bounded polygonal domain, with a conforming Finite Element Method (FEM) approximation $u_h \\in V_h$ on a two-dimensional mesh. In residual-based a posteriori error estimation for adaptive mesh refinement, the elementwise indicator is constructed from the element interior residual and the flux jump residuals across its edges. Let an element $K$ be shape-regular, with diameter $h_K$ and edge lengths $\\{h_{e}\\}_{e \\subset \\partial K}$, and let the elementwise interior residual magnitude be $r_K$ and the edgewise flux jump magnitudes be $\\{j_e\\}_{e \\subset \\partial K}$. The mesh quality metric $h_K$ and the edge lengths $\\{h_e\\}$ enter the scaling of the indicator through standard inverse and trace inequalities on shape-regular meshes.\n\nAssume the following data for a single triangular element $K$: the diameter is $h_K = 0.1$, the element interior residual magnitude is $r_K = 5$, and its three edges have flux jump magnitudes $(3, 1, 2)$ on edges of lengths $(0.1, 0.1, 0.141)$, respectively. Using the canonical residual-based scaling implied by the weak form and integration-by-parts residual representation, compute the element indicator $\\eta_K$ for $K$. Express your final answer as a single simplified exact expression. No rounding is required.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded within the established theory of a posteriori error estimation for the Finite Element Method (FEM), is well-posed with a complete and consistent set of givens, and is expressed in objective, formal language. There are no violations of fundamental principles, contradictions, or ambiguities. We may therefore proceed with the solution.\n\nThe problem asks for the computation of a local, residual-based a posteriori error indicator, denoted as $\\eta_K$, for a single triangular element $K$ in a two-dimensional domain. The underlying physics is described by a stationary scalar diffusion equation, $-\\nabla \\cdot (\\kappa \\nabla u) = f$, where $u$ is the scalar field, $\\kappa$ is the diffusion coefficient, and $f$ is a source term. The approximate solution obtained via FEM is denoted by $u_h$.\n\nThe \"canonical residual-based scaling\" for the error indicator $\\eta_K$ is derived from the weak form of the residual equation and the application of standard trace and inverse inequalities on a shape-regular mesh. The squared indicator $\\eta_K^2$ is composed of two main contributions: one from the residual within the element's interior and one from the jumps in flux across the element's edges. The general form is:\n$$\n\\eta_K^2 = C_{int}^2 h_K^2 \\|R_K\\|_{L_2(K)}^2 + \\sum_{e \\in \\partial K} C_{edge}^2 h_e \\|J_e\\|_{L_2(e)}^2\n$$\nHere, $h_K$ is the diameter of element $K$, and $\\{h_e\\}$ are the lengths of its edges. The term $R_K = f + \\nabla \\cdot (\\kappa \\nabla u_h)$ is the interior residual, and $\\|R_K\\|_{L_2(K)}$ is its $L_2$-norm over the element $K$. The term $J_e = \\llbracket\\kappa \\nabla u_h \\cdot \\mathbf{n}\\rrbracket$ represents the jump of the normal component of the flux across an edge $e$, and $\\|J_e\\|_{L_2(e)}$ is its $L_2$-norm over the edge $e$. The constants $C_{int}$ and $C_{edge}$ depend on interpolation theory and element shape regularity but are typically taken as $1$ in the standard definition of the indicator, which is implied by the term \"canonical\".\n\nThe problem provides the following data, which we map to the terms in the formula:\n- Element diameter: $h_K = 0.1$.\n- Magnitude of the element interior residual ($L_2$-norm): $r_K = \\|R_K\\|_{L_2(K)} = 5$.\n- The element is a triangle, hence it has three edges, indexed here by $i \\in \\{1, 2, 3\\}$.\n- Edge lengths: $h_{e_1} = 0.1$, $h_{e_2} = 0.1$, and $h_{e_3} = 0.141$.\n- Magnitudes of the flux jumps ($L_2$-norms) on the corresponding edges: $j_{e_1} = \\|J_{e_1}\\|_{L_2(e_1)} = 3$, $j_{e_2} = \\|J_{e_2}\\|_{L_2(e_2)} = 1$, and $j_{e_3} = \\|J_{e_3}\\|_{L_2(e_3)} = 2$.\n\nWith the constants $C_{int}$ and $C_{edge}$ set to $1$, the formula for the squared indicator becomes:\n$$\n\\eta_K^2 = h_K^2 r_K^2 + h_{e_1} j_{e_1}^2 + h_{e_2} j_{e_2}^2 + h_{e_3} j_{e_3}^2\n$$\nWe now substitute the given numerical values into this expression. To maintain exactness as requested, we will perform the calculation using fractions.\n$h_K = \\frac{1}{10}$, $r_K = 5$\n$h_{e_1} = \\frac{1}{10}$, $j_{e_1} = 3$\n$h_{e_2} = \\frac{1}{10}$, $j_{e_2} = 1$\n$h_{e_3} = \\frac{141}{1000}$, $j_{e_3} = 2$\n\nThe contribution from the interior residual is:\n$$\nh_K^2 r_K^2 = \\left(\\frac{1}{10}\\right)^2 (5)^2 = \\frac{1}{100} \\times 25 = \\frac{25}{100} = \\frac{1}{4}\n$$\nThe contributions from the flux jumps across the three edges are:\n$$\nh_{e_1} j_{e_1}^2 = \\frac{1}{10} \\times (3)^2 = \\frac{9}{10}\n$$\n$$\nh_{e_2} j_{e_2}^2 = \\frac{1}{10} \\times (1)^2 = \\frac{1}{10}\n$$\n$$\nh_{e_3} j_{e_3}^2 = \\frac{141}{1000} \\times (2)^2 = \\frac{141}{1000} \\times 4 = \\frac{564}{1000} = \\frac{141}{250}\n$$\nNow, we sum these components to find $\\eta_K^2$:\n$$\n\\eta_K^2 = \\frac{1}{4} + \\frac{9}{10} + \\frac{1}{10} + \\frac{141}{250}\n$$\nCombining the terms with common denominators first:\n$$\n\\eta_K^2 = \\frac{1}{4} + \\left(\\frac{9}{10} + \\frac{1}{10}\\right) + \\frac{141}{250} = \\frac{1}{4} + 1 + \\frac{141}{250} = \\frac{5}{4} + \\frac{141}{250}\n$$\nTo sum these fractions, we find a common denominator, which is $500$:\n$$\n\\eta_K^2 = \\frac{5 \\times 125}{4 \\times 125} + \\frac{141 \\times 2}{250 \\times 2} = \\frac{625}{500} + \\frac{282}{500} = \\frac{625 + 282}{500} = \\frac{907}{500}\n$$\nThe problem asks for the element indicator $\\eta_K$, which is the square root of this value:\n$$\n\\eta_K = \\sqrt{\\frac{907}{500}}\n$$\nTo provide a simplified exact expression, we can rationalize the denominator:\n$$\n\\eta_K = \\frac{\\sqrt{907}}{\\sqrt{500}} = \\frac{\\sqrt{907}}{\\sqrt{100 \\times 5}} = \\frac{\\sqrt{907}}{10\\sqrt{5}}\n$$\nMultiplying the numerator and denominator by $\\sqrt{5}$:\n$$\n\\eta_K = \\frac{\\sqrt{907} \\times \\sqrt{5}}{10\\sqrt{5} \\times \\sqrt{5}} = \\frac{\\sqrt{907 \\times 5}}{10 \\times 5} = \\frac{\\sqrt{4535}}{50}\n$$\nThe number $907$ is a prime number, so the radical $\\sqrt{4535}$ cannot be simplified further. This is the final exact expression for the element indicator.",
            "answer": "$$\\boxed{\\frac{\\sqrt{4535}}{50}}$$"
        },
        {
            "introduction": "Building on the basic structure, we now explore a deeper theoretical aspect: the connection between an estimator and the specific error norm it targets. This practice  guides you through the computation of two distinct estimators for the same problem—one for the energy norm and one for the $L^2$ norm. This comparison illuminates the crucial role of duality arguments in a posteriori analysis and reveals how the scaling of residual terms with the mesh size $h$ is tailored to the goal of the estimation.",
            "id": "2594004",
            "problem": "Consider the one-dimensional Poisson problem on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions: find $u \\in H_0^1(0,1)$ such that\n$$\n- u'' = f \\quad \\text{in } (0,1), \\qquad u(0) = u(1) = 0,\n$$\nwith the exact data $f(x) = \\pi^2 \\sin(\\pi x)$. Let $V_h$ be the standard continuous, piecewise-linear finite element space associated with the mesh $\\{0, \\tfrac{1}{2}, 1\\}$, and let $u_h \\in V_h$ be the Galerkin solution.\n\nUsing only the weak formulation of the boundary value problem and the general principle that residual-based a posteriori error estimators are constructed from the strong residual inside each element and the flux jumps across interelement boundaries, you are to:\n- Derive the form, scaling, and elementwise decomposition of a global residual estimator that controls the error in the energy norm induced by the bilinear form $\\int_0^1 u' v' \\, dx$.\n- Derive the form, scaling, and elementwise decomposition of a global residual estimator that controls the error in the $L^2$-norm, using a duality-based argument.\n- For the given mesh and data, compute the finite element solution $u_h$, the element residuals, and the flux jump at the interior node.\n- Compute the two global estimators for this case.\n- Compare their magnitudes and the distribution of their elementwise indicators.\n\nAs your final answer, report the ratio $\\rho$ of the global $L^2$-oriented residual estimator to the global energy-norm residual estimator for this specific problem and mesh. Express your answer as an exact value without units.",
            "solution": "The problem presented is a standard, well-posed exercise in the a posteriori error analysis of the finite element method for a one-dimensional boundary value problem. It is scientifically grounded, self-contained, and objective. All necessary information is provided. Thus, the problem is valid, and we may proceed to its solution.\n\nThe problem concerns the Poisson equation $-u'' = f$ on the interval $\\Omega = (0,1)$ with homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$. The weak formulation is to find $u \\in H_0^1(0,1)$ such that\n$$a(u,v) = (f,v) \\quad \\forall v \\in H_0^1(0,1),$$\nwhere the bilinear form is $a(u,v) = \\int_0^1 u'v' \\, dx$ and the linear functional is $(f,v) = \\int_0^1 fv \\, dx$. The energy norm induced by $a(\\cdot,\\cdot)$ is $\\|v\\|_E = \\sqrt{a(v,v)} = \\|v'\\|_{L^2(0,1)}$.\n\nThe Galerkin approximation $u_h$ is sought in the finite element space $V_h \\subset H_0^1(0,1)$ of continuous, piecewise-linear polynomials on the mesh $\\mathcal{T}_h$. It solves\n$$a(u_h, v_h) = (f, v_h) \\quad \\forall v_h \\in V_h.$$\nThe error is defined as $e = u - u_h$. A fundamental property resulting from the above formulations is Galerkin orthogonality:\n$$a(e, v_h) = a(u-u_h, v_h) = a(u, v_h) - a(u_h, v_h) = (f, v_h) - (f, v_h) = 0 \\quad \\forall v_h \\in V_h.$$\n\nWe first derive the residual-based error estimators for the energy norm and the $L^2$-norm.\n\nThe error in the energy norm squared is given by $\\|e\\|_E^2 = a(e,e)$. Using Galerkin orthogonality, $a(e,e) = a(e, e-v_h)$ for any $v_h \\in V_h$. The right-hand side is the value of the residual functional $\\mathcal{R}(v) = (f,v) - a(u_h,v)$ evaluated at $v = e-v_h$. We can rewrite the residual functional by integrating $a(u_h, v)$ by parts over each element $K \\in \\mathcal{T}_h$:\n$$\n\\mathcal{R}(v) = \\sum_{K \\in \\mathcal{T}_h} \\int_K f v \\, dx - \\sum_{K \\in \\mathcal{T}_h} \\left( [u_h' v]_{\\partial K} - \\int_K u_h'' v \\, dx \\right).\n$$\nSince $u_h$ is piecewise linear, $u_h''=0$ inside each element $K$. The boundary terms sum up to contributions from interior nodes. For an interior node $x_j$, the contribution is $(u_h'(x_j^+) - u_h'(x_j^-))v(x_j)$. Let $R_K = f+u_h''=f$ be the element residual and $J_j = u_h'(x_j^+) - u_h'(x_j^-)$ be the jump in the derivative of $u_h$ at node $x_j$. The residual can be expressed as:\n$$\n\\mathcal{R}(v) = \\sum_{K \\in \\mathcal{T}_h} \\int_K R_K v \\, dx + \\sum_{j \\in \\text{interior nodes}} J_j v(x_j).\n$$\nApplying this to $\\|e\\|_E^2 = \\mathcal{R}(e-v_h)$ and using standard interpolation estimates for $v_h$ (e.g., Clément interpolant), we arrive at the a posteriori error estimate $\\|e\\|_E \\le C \\eta_E$, where $\\eta_E$ is the global error estimator. Its square is given by the sum of local indicators $\\eta_{E,K}$:\n$$\n\\eta_E^2 = \\sum_{K \\in \\mathcal{T}_h} \\eta_{E,K}^2, \\quad \\text{with} \\quad \\eta_{E,K}^2 = c_1 h_K^2 \\|R_K\\|_{L^2(K)}^2 + \\frac{c_2}{2} \\sum_{x_j \\in \\partial K \\cap (0,1)} h_j |J_j|^2.\n$$\nHere, $h_K$ is the length of element $K$, $h_j$ is the size of the patch associated with node $x_j$, and $c_1, c_2$ are constants independent of the mesh size, which are conventionally set to $1$ for computation. The factor of $1/2$ distributes the nodal jump contribution to the two adjacent elements.\n\nFor the $L^2$-norm error, we use a duality argument. We have $\\|e\\|_{L^2(0,1)} = \\sup_{g \\in L^2, \\|g\\|=1} (e,g)$. Consider the dual problem: find $\\phi \\in H_0^1(0,1)$ such that $-\\phi''=e$. The weak form is $a(v, \\phi)=(v,e)$ for all $v \\in H_0^1(0,1)$. By elliptic regularity for this problem, we have $\\|\\phi\\|_{H^2(0,1)} \\le C \\|e\\|_{L^2(0,1)}$.\nThen, $\\|e\\|_{L^2}^2 = (e,e) = a(e, \\phi)$. Using Galerkin orthogonality, $\\|e\\|_{L^2}^2 = a(e, \\phi - \\phi_h)$ for any $\\phi_h \\in V_h$. This is precisely the residual functional $\\mathcal{R}(\\phi - \\phi_h)$.\n$$\n\\|e\\|_{L^2}^2 = \\sum_{K \\in \\mathcal{T}_h} \\int_K R_K (\\phi - \\phi_h) \\, dx + \\sum_{j} J_j (\\phi - \\phi_h)(x_j).\n$$\nUsing Cauchy-Schwarz and advanced interpolation estimates for $\\phi_h$ that leverage the $H^2$ regularity of $\\phi$, such as $\\|\\phi-\\phi_h\\|_{L^2(K)} \\le C h_K^2 \\|\\phi''\\|_{L^2(K)} = C h_K^2 \\|e\\|_{L^2(K)}$ and $|(\\phi-\\phi_h)(x_j)| \\le C h_j^{3/2} \\|\\phi''\\|_{L^2(\\omega_j)} = C h_j^{3/2} \\|e\\|_{L^2(\\omega_j)}$, one derives the estimate $\\|e\\|_{L^2} \\le C \\eta_{L^2}$. The square of the $L^2$-oriented estimator is:\n$$\n\\eta_{L^2}^2 = \\sum_{K \\in \\mathcal{T}_h} \\eta_{L^2,K}^2, \\quad \\text{with} \\quad \\eta_{L^2,K}^2 = c_3 h_K^4 \\|R_K\\|_{L^2(K)}^2 + \\frac{c_4}{2} \\sum_{x_j \\in \\partial K \\cap (0,1)} h_j^3 |J_j|^2.\n$$\nAgain, we set $c_3=c_4=1$. For a uniform mesh of size $h$, where $h_K=h_j=h$, the relationship between the two estimators becomes remarkably simple:\n$$\n\\eta_{L^2}^2 = h^4 \\sum_K \\|R_K\\|^2 + h^3 \\sum_j |J_j|^2 = h^2 \\left( h^2 \\sum_K \\|R_K\\|^2 + h \\sum_j |J_j|^2 \\right) = h^2 \\eta_E^2.\n$$\nThus, for a uniform mesh, $\\eta_{L^2} = h \\eta_E$, and their ratio $\\rho = \\eta_{L^2}/\\eta_E$ is simply the mesh size $h$.\n\nNow we compute these quantities for the specific problem. The mesh consists of two elements $K_1 = (0, 1/2)$ and $K_2 = (1/2, 1)$ of uniform size $h = 1/2$. The space $V_h$ is spanned by the single basis function $\\phi_1(x)$ centered at $x_1=1/2$:\n$$ \\phi_1(x) = \\begin{cases} 2x & x \\in [0, 1/2] \\\\ 2(1-x) & x \\in [1/2, 1] \\end{cases} $$\nThe finite element solution is $u_h(x) = U_1 \\phi_1(x)$, where $U_1 = \\frac{(f, \\phi_1)}{a(\\phi_1, \\phi_1)}$.\nThe stiffness matrix entry is $a(\\phi_1, \\phi_1) = \\int_0^{1/2} 2^2 dx + \\int_{1/2}^1 (-2)^2 dx = 4(1/2) + 4(1/2) = 4$.\nThe load vector entry is $(f, \\phi_1) = \\int_0^1 \\pi^2\\sin(\\pi x)\\phi_1(x) \\, dx$.\n$$\n(f, \\phi_1) = \\pi^2 \\left( \\int_0^{1/2} 2x \\sin(\\pi x) dx + \\int_{1/2}^1 2(1-x) \\sin(\\pi x) dx \\right).\n$$\nIntegration by parts yields $\\int_0^{1/2} 2x \\sin(\\pi x) dx = 2/\\pi^2$. By symmetry, the second integral is also $2/\\pi^2$.\nSo, $(f, \\phi_1) = \\pi^2 (2/\\pi^2 + 2/\\pi^2) = 4$.\nThis gives $U_1 = 4/4 = 1$, and $u_h(x) = \\phi_1(x)$.\n\nThe element residual is $R_K = f(x) = \\pi^2 \\sin(\\pi x)$ since $u_h''=0$.\nThe flux jump is at the single interior node $x_1=1/2$.\n$J_{1/2} = u_h'(1/2^+) - u_h'(1/2^-) = (-2) - (2) = -4$.\n\nNext, we compute the estimators. The mesh size is $h=1/2$. The patch size for the node at $1/2$ is $h_{1/2}=1/2$.\nWe need the squared $L^2$-norm of the residual $f$:\n$\\int_0^1 f^2 dx = \\int_0^1 (\\pi^2 \\sin(\\pi x))^2 dx = \\pi^4 \\int_0^1 \\sin^2(\\pi x) dx = \\pi^4 \\int_0^1 \\frac{1-\\cos(2\\pi x)}{2} dx = \\pi^4[\\frac{x}{2} - \\frac{\\sin(2\\pi x)}{4\\pi}]_0^1 = \\frac{\\pi^4}{2}$.\nDue to symmetry, $\\int_{K_1} f^2 dx = \\int_{K_2} f^2 dx = \\frac{\\pi^4}{4}$.\n\nGlobal energy-norm estimator:\n$$\n\\eta_E^2 = h^2 \\int_{K_1} f^2 dx + h^2 \\int_{K_2} f^2 dx + h_{1/2} |J_{1/2}|^2 = \\left(\\frac{1}{2}\\right)^2 \\frac{\\pi^4}{4} + \\left(\\frac{1}{2}\\right)^2 \\frac{\\pi^4}{4} + \\frac{1}{2}(-4)^2\n$$\n$$\n\\eta_E^2 = \\frac{\\pi^4}{16} + \\frac{\\pi^4}{16} + 8 = \\frac{\\pi^4}{8} + 8 = \\frac{\\pi^4+64}{8}.\n$$\n\nGlobal $L^2$-norm estimator:\n$$\n\\eta_{L^2}^2 = h^4 \\int_{K_1} f^2 dx + h^4 \\int_{K_2} f^2 dx + h_{1/2}^3 |J_{1/2}|^2 = \\left(\\frac{1}{2}\\right)^4 \\frac{\\pi^4}{4} + \\left(\\frac{1}{2}\\right)^4 \\frac{\\pi^4}{4} + \\left(\\frac{1}{2}\\right)^3(-4)^2\n$$\n$$\n\\eta_{L^2}^2 = \\frac{\\pi^4}{64} + \\frac{\\pi^4}{64} + \\frac{16}{8} = \\frac{\\pi^4}{32} + 2 = \\frac{\\pi^4+64}{32}.\n$$\nThe comparison of indicators shows a balanced distribution for both estimators, with $\\eta_{\\cdot,1}^2 = \\eta_{\\cdot,2}^2$ due to the symmetry of the problem and mesh.\n\nFinally, we compute the ratio $\\rho = \\eta_{L^2} / \\eta_E$:\n$$\n\\rho^2 = \\frac{\\eta_{L^2}^2}{\\eta_E^2} = \\frac{(\\pi^4+64)/32}{(\\pi^4+64)/8} = \\frac{8}{32} = \\frac{1}{4}.\n$$\nTaking the square root gives $\\rho = 1/2$. This result confirms our general finding that for a uniform mesh, the ratio of the estimators is equal to the mesh size $h$.",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "We conclude by putting our estimators to work in their most powerful role: guiding an adaptive simulation. An effective estimator does more than just quantify error; it provides the intelligence to refine the computational model efficiently. This advanced practice  challenges you to design an $hp$-adaptive marking strategy, using the relative magnitudes of interior and jump residuals to decide whether an element requires spatial refinement ($h$-refinement) or an increase in polynomial order ($p$-refinement). This exercise bridges the gap between error estimation and the automated, goal-oriented simulation at the heart of modern computational science.",
            "id": "3412840",
            "problem": "Consider the one-dimensional Poisson model problem on the domain $[0,1]$ with homogeneous Dirichlet boundary conditions, given by\n$$\n-\\frac{d^2 u}{dx^2} = f \\quad \\text{in } (0,1), \\qquad u(0)=0, \\quad u(1)=0.\n$$\nIn a Discontinuous Galerkin (DG) discretization with piecewise polynomial approximation on each element $K$ of the mesh, the discrete solution $u_h$ is allowed to be discontinuous across element interfaces. For each element $K$ with length $h_K$ and polynomial degree $p_K$, define the interior (strong) residual\n$$\nR_K(u_h) := f + \\frac{d^2 u_h}{dx^2} \\quad \\text{on } K,\n$$\nand the jump residual across an interior face $e$ located at a node $x_e$ shared by neighboring elements $K^{-}$ and $K^{+}$,\n$$\nJ_e(u_h) := \\left[\\nabla u_h \\cdot n\\right] = \\frac{d u_h}{dx}\\bigg|_{x_e^+} - \\frac{d u_h}{dx}\\bigg|_{x_e^-},\n$$\nwhich, in one dimension and with diffusion coefficient equal to $1$, coincides with the flux jump. A standard residual-based a posteriori estimator for each element $K$ is the quantity\n$$\n\\eta_K^2 := h_K^2 \\, \\| R_K(u_h) \\|_{L^2(K)}^2 \\;+\\; \\sum_{e \\subset \\partial K \\cap \\mathcal{E}_{\\text{int}}} h_e \\, \\| J_e(u_h) \\|_{L^2(e)}^2,\n$$\nwhere $\\mathcal{E}_{\\text{int}}$ denotes the set of interior faces, and $h_e$ is a characteristic length associated with the face $e$, for instance $h_e := \\tfrac{1}{2}(h_{K^{-}}+h_{K^{+}})$.\n\nYour task is to design and implement an $hp$-adaptive marking strategy driven by residuals $\\eta_K(h_K,p_K)$ that predicts, for each element $K$, whether to refine $h$ (split the element) or increase $p$ (raise the polynomial degree). The decision must be made by comparing the decay behavior of jump residuals $\\|[\\nabla u_h\\cdot n]\\|$ and interior residuals $\\|R_K(u_h)\\|$. The strategy should be grounded in the following fundamental bases:\n\n- The DG residual definitions above.\n- The approximation properties of polynomial spaces: for sufficiently smooth $u$, the interior residual is expected to decay rapidly with increasing $p_K$, while large jumps in flux across faces indicate under-resolution that typically benefits from $h$-refinement.\n- Spectral coefficient decay as a smoothness indicator: the decay of higher-order modal coefficients of $u_h$ on $K$ provides a signal of local regularity.\n\nImplementation constraints:\n\n- Construct $u_h$ on each element by the local $L^2$-projection of a manufactured exact solution $u$ onto the space of Legendre polynomials of degree $p_K$ on that element.\n- Compute $\\|R_K(u_h)\\|_{L^2(K)}$ by numerical quadrature of the strong residual $f + \\frac{d^2 u_h}{dx^2}$ on $K$.\n- Compute the jump residual norm on each interior face by evaluating $J_e(u_h)$ and assigning half of the quantity $h_e \\, |J_e(u_h)|^2$ to each neighboring element.\n- Define a smoothness indicator on each element $K$ using the Legendre modal coefficients $\\{a_\\ell\\}_{\\ell=0}^{p_K}$ of $u_h$: use the ratio $|a_{p_K}| / \\sum_{\\ell=0}^{p_K} |a_\\ell|$ to assess spectral tail dominance.\n- Based on the relative dominance of jump versus interior residual and the smoothness indicator, decide the marking action for each element $K$:\n  - Output $0$ if the element should be marked for $h$-refinement,\n  - Output $1$ if the element should be marked for $p$-refinement,\n  - Output $2$ if no refinement is needed (for example, when $\\eta_K$ is sufficiently small compared to an average estimator magnitude).\n\nYour program must implement the above and apply it to the following test suite. In each case, the mesh, polynomial degrees, and manufactured solution $u$ (with its corresponding right-hand side $f = -u''$) are specified.\n\n- Test case $1$ (smooth solution, uniform mesh):\n  - Mesh nodes: $[0, 0.25, 0.5, 0.75, 1]$ so that there are $4$ elements with lengths $h_K = 0.25$.\n  - Polynomial degrees: $p_K = 2$ on all elements.\n  - Manufactured solution: $u(x) = \\sin(\\pi x)$, thus $f(x) = \\pi^2 \\sin(\\pi x)$.\n\n- Test case $2$ (steep variation near a mesh interface, uniform mesh):\n  - Mesh nodes: $[0, 0.25, 0.5, 0.75, 1]$.\n  - Polynomial degrees: $p_K = 2$ on all elements.\n  - Manufactured solution: $u(x) = \\arctan(\\beta (x - x_0))$ with parameters $\\beta = 300$ and $x_0 = 0.5$, thus\n    $$\n    u'(x) = \\frac{\\beta}{1 + \\beta^2 (x - x_0)^2}, \\qquad\n    u''(x) = -\\frac{2 \\beta^3 (x - x_0)}{\\left(1 + \\beta^2 (x - x_0)^2\\right)^2}, \\qquad\n    f(x) = -u''(x) = \\frac{2 \\beta^3 (x - x_0)}{\\left(1 + \\beta^2 (x - x_0)^2\\right)^2}.\n    $$\n\n- Test case $3$ (mixed smooth and localized steep feature, nonuniform $p$):\n  - Mesh nodes: $[0, 0.2, 0.4, 0.6, 0.8, 1]$, so there are $5$ elements with lengths $h_K = 0.2$.\n  - Polynomial degrees: $p_K = [1, 3, 2, 1, 4]$.\n  - Manufactured solution: $u(x) = \\sin(3 \\pi x) + 0.1 \\, \\arctan(\\gamma (x - x_1))$ with parameters $\\gamma = 80$ and $x_1 = 0.35$. Therefore,\n    $$\n    u''(x) = -9 \\pi^2 \\sin(3 \\pi x) - \\frac{0.2 \\, \\gamma^3 (x - x_1)}{\\left(1 + \\gamma^2 (x - x_1)^2\\right)^2}, \\qquad\n    f(x) = -u''(x) = 9 \\pi^2 \\sin(3 \\pi x) + \\frac{0.2 \\, \\gamma^3 (x - x_1)}{\\left(1 + \\gamma^2 (x - x_1)^2\\right)^2}.\n    $$\n\nAlgorithmic requirements for the marking decision on each element $K$:\n\n- Compute the interior residual norm $\\|R_K(u_h)\\|_{L^2(K)}$ and the aggregated jump residual norm assigned to $K$ (square-root of the sum of assigned face contributions).\n- Compute the spectral tail ratio $|a_{p_K}| / \\sum_{\\ell=0}^{p_K} |a_\\ell|$.\n- Compare the magnitude of jump versus interior residuals and the spectral tail ratio to decide whether the expected decay under increasing $p_K$ is favorable (indicating $p$-refinement), or whether the jump terms dominate (indicating $h$-refinement). If the total estimator $\\eta_K$ is sufficiently small relative to the average estimator magnitude in the test case, return the no-change decision.\n\nFinal output specification:\n\n- For each test case, return a list of integers of length equal to the number of elements, with entries in $\\{0,1,2\\}$ corresponding to $h$-refinement, $p$-refinement, or no change, respectively.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s list appears as a nested list. For example, the output format should be like $[[d_{1,1}, d_{1,2}, \\dots], [d_{2,1}, d_{2,2}, \\dots], [d_{3,1}, d_{3,2}, \\dots]]$ with $d_{i,j} \\in \\{0,1,2\\}$.",
            "solution": "The problem requires the design and implementation of an $hp$-adaptive marking strategy for a one-dimensional Discontinuous Galerkin (DG) method applied to the Poisson equation. The strategy must decide for each element $K$ of a given mesh whether to recommend $h$-refinement (splitting the element), $p$-refinement (increasing the polynomial degree), or no change. This decision is to be based on a posteriori error indicators derived from the interior and jump residuals of the numerical solution.\n\nThe problem is well-posed and scientifically grounded in the theory of numerical methods for partial differential equations, specifically a posteriori error estimation for DG methods. I will first outline the theoretical and algorithmic basis for the strategy, and then provide the implementation.\n\n### 1. Theoretical Framework\n\nWe consider the DG discretization of the model problem:\n$$\n-\\frac{d^2 u}{dx^2} = f \\quad \\text{in } (0,1), \\qquad u(0)=0, \\quad u(1)=0.\n$$\nThe numerical solution $u_h$ is a piecewise polynomial of degree $p_K$ on each element $K$ of a mesh partitioning the domain $[0,1]$. A key feature of DG methods is that $u_h$ is not required to be continuous across element interfaces. This gives rise to two primary sources of error, which can be measured by residuals:\n\n1.  **Interior Residual $R_K(u_h)$**: On each element $K$, the strong form of the PDE is not exactly satisfied by $u_h$. The interior residual is defined as:\n    $$\n    R_K(u_h) := f + \\frac{d^2 u_h}{dx^2} \\quad \\text{on } K\n    $$\n    A large interior residual indicates that the polynomial $u_h$ is a poor approximation of the true solution $u$ within the element $K$.\n\n2.  **Jump Residual $J_e(u_h)$**: At an interior face $e$ (a node in 1D) shared by elements $K^{-}$ and $K^{+}$, the flux term, here $\\nabla u_h \\cdot n$, may be discontinuous. The jump residual measures this discontinuity:\n    $$\n    J_e(u_h) := \\left[\\nabla u_h \\cdot n\\right] = \\frac{d u_h}{dx}\\bigg|_{x_e^+} - \\frac{d u_h}{dx}\\bigg|_{x_e^-}\n    $$\n    A large jump residual suggests that the solution is not well-resolved by the mesh at the interface, often due to a steep gradient or a singularity.\n\nThese residuals form the basis of the a posteriori error estimator $\\eta_K$ for each element $K$:\n$$\n\\eta_K^2 := h_K^2 \\, \\| R_K(u_h) \\|_{L^2(K)}^2 \\;+\\; \\sum_{e \\subset \\partial K \\cap \\mathcal{E}_{\\text{int}}} h_e \\, |J_e(u_h)|^2\n$$\nHere, $\\| \\cdot \\|_{L^2(e)}$ reduces to an evaluation at the point $e$ in 1D. This form of the estimator double-counts the jump terms when summed over all elements. A common practice for localizing the error is to assign half of the jump contribution to each of the two adjacent elements. Thus, we will work with a localized indicator $\\tilde{\\eta}_K$:\n$$\n\\tilde{\\eta}_K^2 := \\underbrace{h_K^2 \\, \\| R_K(u_h) \\|_{L^2(K)}^2}_{\\text{Interior Contribution}} \\;+\\; \\underbrace{\\frac{1}{2} \\sum_{e \\subset \\partial K \\cap \\mathcal{E}_{\\text{int}}} h_e \\, |J_e(u_h)|^2}_{\\text{Jump Contribution}}\n$$\n\n### 2. Algorithmic Design of the $hp$-Marking Strategy\n\nThe core of the task is to use $\\tilde{\\eta}_K$ and other available information to decide between $h$- and $p$-refinement. The guiding principles are:\n\n-   **$h$-refinement** is most effective for resolving non-smooth features like steep gradients or discontinuities, which manifest as large jump residuals. It is also preferred when the local solution has low regularity, meaning that increasing the polynomial degree would yield slow convergence.\n-   **$p$-refinement** is most effective for smooth solutions where the error is distributed throughout the element. This typically corresponds to a large interior residual relative to the jump residuals. Higher-degree polynomials can capture smooth functions with exponential convergence.\n\nTo formalize this, we introduce a local smoothness indicator. The numerical solution $u_h$ on an element $K$ is represented in a basis of Legendre polynomials. The rate of decay of the modal coefficients provides an estimate of the local solution regularity. We define the spectral smoothness indicator $S_K$ as the ratio of the magnitude of the highest-order coefficient to the sum of the magnitudes of all coefficients:\n$$\nS_K := \\frac{|a_{p_K}|}{\\sum_{\\ell=0}^{p_K} |a_\\ell|}\n$$\nA small value of $S_K$ indicates rapid spectral decay and a locally smooth solution, while a large value suggests the solution is not well-represented by the current polynomial space, indicating a need to resolve finer features, which points to $h$-refinement.\n\nThe marking strategy is implemented as a multi-step algorithm for each element $K$:\n\n**Step 1: Construct the Approximate Solution $u_h$**\nFor each element $K = [x_i, x_{i+1}]$ with prescribed polynomial degree $p_K$, the local solution $u_h|_K$ is constructed as the $L^2(K)$ projection of the manufactured solution $u$. The coefficients $\\{a_\\ell\\}_{\\ell=0}^{p_K}$ in the Legendre basis on $K$ are computed via numerical quadrature. Using an affine map $\\xi \\mapsto x(\\xi)$ from the reference interval $[-1, 1]$ to $K$, the coefficients are:\n$$\na_\\ell = \\frac{\\langle u, \\hat{P}_\\ell \\rangle_{L^2(K)}}{\\| \\hat{P}_\\ell \\|_{L^2(K)}^2} = \\frac{\\int_{-1}^1 u(x(\\xi)) P_\\ell(\\xi) d\\xi}{\\int_{-1}^1 (P_\\ell(\\xi))^2 d\\xi} = \\frac{2\\ell+1}{2} \\int_{-1}^1 u(x(\\xi)) P_\\ell(\\xi) d\\xi\n$$\nwhere $P_\\ell$ are the standard Legendre polynomials on $[-1, 1]$. The integral is approximated using high-order Gauss-Legendre quadrature. With the coefficients $\\{a_\\ell\\}$, $u_h$ and its derivatives on $K$ are defined.\n\n**Step 2: Compute Residuals and Indicators**\n-   The squared $L^2$-norm of the interior residual, $\\|R_K(u_h)\\|_{L^2(K)}^2 = \\int_K (f + u_h'')^2 dx$, is computed using Gauss-Legendre quadrature.\n-   The jump residuals $J_e(u_h)$ are computed at each interior node $x_e$ by evaluating the derivatives of the polynomials from the left and right elements.\n-   The spectral smoothness indicator $S_K$ is computed from the Legendre coefficients.\n-   The localized error indicator $\\tilde{\\eta}_K$ is assembled from the interior and jump contributions.\n\n**Step 3: Apply the Marking Logic**\nA set of rules, based on empirically chosen but theoretically motivated thresholds, is applied to each element $K_i$:\n1.  **No Refinement (Mark 2):** If an element's contribution to the total error is negligible, it is not refined. This is decided by comparing its indicator $\\tilde{\\eta}_{K_i}$ to the maximum indicator value over all elements:\n    $$\n    \\text{If } \\tilde{\\eta}_{K_i} < \\theta_{\\text{no-ref}} \\cdot \\max_j(\\tilde{\\eta}_{K_j}), \\quad \\text{mark as 2}.\n    $$\n    A threshold of $\\theta_{\\text{no-ref}} = 0.1$ is used.\n\n2.  **$h$- vs. $p$-Refinement (Marks 0 vs. 1):** For elements not marked for no-refinement, we decide between $h$ and $p$.\n    -   We compute the jump dominance ratio, which measures the relative contribution of the jump residual term to the total local indicator:\n        $$\n        D_K = \\frac{\\text{Jump Contribution}}{\\tilde{\\eta}_K^2}\n        $$\n    -   We check the smoothness via the spectral indicator $S_K$.\n    -   An element is marked for $h$-refinement (Mark 0) if the jump residual is dominant or if the local solution is detected as non-smooth:\n        $$\n        \\text{If } D_K > \\theta_{\\text{jump}} \\text{ or } S_K > \\theta_{\\text{spectral}}, \\quad \\text{mark as 0}.\n        $$\n        We use thresholds $\\theta_{\\text{jump}} = 0.5$ and $\\theta_{\\text{spectral}} = 0.1$.\n    -   Otherwise, if the interior residual dominates and the function appears smooth, the element is marked for $p$-refinement (Mark 1). This is the default for elements needing refinement.\n\nThis algorithm provides a clear, decisive, and justifiable method for guiding an $hp$-adaptive mesh refinement process. It correctly balances the need to resolve local, sharp features with the efficiency of high-order methods for smooth solutions.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import Legendre, leggauss\n\n# Algorithmic parameters for the marking strategy\nN_QUAD = 30  # Number of quadrature points\nTHETA_NO_REFINEMENT = 0.1  # Threshold for not refining an element\nJUMP_DOMINANCE_THRESHOLD = 0.5  # Threshold for jump residual dominance\nSPECTRAL_DECAY_THRESHOLD = 0.1  # Threshold for slow spectral decay\n\ndef get_l2_projection_coeffs(u_func, interval, p_degree):\n    \"\"\"Computes the coefficients of the L2 projection of u_func onto the space\n    of Legendre polynomials of degree p_degree on the given interval.\"\"\"\n    a, b = interval\n    h = b - a\n    jacobian = h / 2.0\n    \n    # Affine map from reference interval [-1, 1] to element [a, b]\n    map_to_interval = lambda xi: jacobian * xi + (a + b) / 2.0\n    \n    quad_points, quad_weights = leggauss(N_QUAD)\n    \n    coeffs = []\n    for l in range(p_degree + 1):\n        # Integrand for L2 projection coefficient calculation\n        integrand_vals = u_func(map_to_interval(quad_points)) * eval_legendre(l, quad_points)\n        integral_val = np.sum(quad_weights * integrand_vals)\n        \n        # Formula for the l-th coefficient\n        coeff_l = (2 * l + 1) / 2.0 * integral_val\n        coeffs.append(coeff_l)\n        \n    return np.array(coeffs)\n\ndef process_test_case(mesh_nodes, p_degrees, u_func, f_func):\n    \"\"\"\n    Applies the hp-marking strategy to a single test case.\n    \"\"\"\n    num_elements = len(mesh_nodes) - 1\n    elements_data = []\n    \n    quad_points, quad_weights = leggauss(N_QUAD)\n\n    # Step 1: Process each element to compute local properties\n    for i in range(num_elements):\n        interval = (mesh_nodes[i], mesh_nodes[i+1])\n        h_k = interval[1] - interval[0]\n        p_k = p_degrees[i]\n\n        # Compute L2 projection to get u_h\n        coeffs = get_l2_projection_coeffs(u_func, interval, p_k)\n        \n        # Build polynomial representation of u_h and its derivatives\n        u_h_poly = Legendre(coeffs, domain=interval)\n        u_h_poly_d2 = u_h_poly.deriv(2)\n\n        # Compute interior residual norm\n        map_to_interval = lambda xi: (h_k / 2.0) * xi + (interval[0] + interval[1]) / 2.0\n        x_quad = map_to_interval(quad_points)\n        \n        residual_vals = f_func(x_quad) + u_h_poly_d2(x_quad)\n        interior_res_sq_norm = np.sum(quad_weights * (residual_vals**2)) * (h_k / 2.0)\n\n        # Compute spectral smoothness indicator\n        if np.sum(np.abs(coeffs)) > 1e-15:\n            spectral_ratio = np.abs(coeffs[-1]) / np.sum(np.abs(coeffs))\n        else:\n            spectral_ratio = 0.0\n\n        elements_data.append({\n            'interval': interval,\n            'h_k': h_k,\n            'p_k': p_k,\n            'coeffs': coeffs,\n            'u_h_poly_d1': u_h_poly.deriv(1),\n            'interior_res_contrib': h_k**2 * interior_res_sq_norm,\n            'spectral_ratio': spectral_ratio,\n            'jump_res_contrib': 0.0,\n        })\n\n    # Step 2: Compute jump residuals at interior faces\n    for i in range(1, num_elements):\n        # Face at x = mesh_nodes[i]\n        face_loc = mesh_nodes[i]\n        \n        # Element K- to the left\n        elem_minus = elements_data[i-1]\n        # Element K+ to the right\n        elem_plus = elements_data[i]\n        \n        grad_uh_minus = elem_minus['u_h_poly_d1'](face_loc)\n        grad_uh_plus = elem_plus['u_h_poly_d1'](face_loc)\n        \n        jump = grad_uh_plus - grad_uh_minus\n        \n        h_e = 0.5 * (elem_minus['h_k'] + elem_plus['h_k'])\n        \n        jump_term = h_e * jump**2\n        \n        # Distribute jump contribution to neighboring elements\n        elem_minus['jump_res_contrib'] += 0.5 * jump_term\n        elem_plus['jump_res_contrib'] += 0.5 * jump_term\n\n    # Step 3: Finalize indicators and apply marking logic\n    eta_k_list = []\n    for data in elements_data:\n        eta_k_sq = data['interior_res_contrib'] + data['jump_res_contrib']\n        eta_k_list.append(np.sqrt(eta_k_sq))\n    \n    eta_max = np.max(eta_k_list) if eta_k_list else 0.0\n    marks = []\n\n    for i in range(num_elements):\n        data = elements_data[i]\n        eta_k = eta_k_list[i]\n        \n        # Rule 1: No refinement if error is small\n        if eta_k < THETA_NO_REFINEMENT * eta_max:\n            marks.append(2)\n            continue\n            \n        # Rule 2: h- vs p-refinement for elements with significant error\n        total_contrib = data['interior_res_contrib'] + data['jump_res_contrib']\n        if total_contrib > 1e-15:\n            jump_dominance_ratio = data['jump_res_contrib'] / total_contrib\n        else:\n            jump_dominance_ratio = 0.0\n\n        spectral_ratio = data['spectral_ratio']\n\n        if (jump_dominance_ratio > JUMP_DOMINANCE_THRESHOLD or \n            spectral_ratio > SPECTRAL_DECAY_THRESHOLD):\n            marks.append(0)  # h-refinement\n        else:\n            marks.append(1)  # p-refinement\n            \n    return marks\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = []\n\n    # Test Case 1: Smooth solution\n    f1_u = lambda x: np.sin(np.pi * x)\n    f1_f = lambda x: np.pi**2 * np.sin(np.pi * x)\n    case1 = {\n        'mesh_nodes': np.array([0, 0.25, 0.5, 0.75, 1]),\n        'p_degrees': np.array([2, 2, 2, 2]),\n        'u_func': f1_u,\n        'f_func': f1_f\n    }\n    test_cases.append(case1)\n\n    # Test Case 2: Steep gradient\n    beta, x0 = 300.0, 0.5\n    f2_u = lambda x: np.arctan(beta * (x - x0))\n    f2_f = lambda x: (2 * beta**3 * (x - x0)) / (1 + beta**2 * (x - x0)**2)**2\n    case2 = {\n        'mesh_nodes': np.array([0, 0.25, 0.5, 0.75, 1]),\n        'p_degrees': np.array([2, 2, 2, 2]),\n        'u_func': f2_u,\n        'f_func': f2_f\n    }\n    test_cases.append(case2)\n    \n    # Test Case 3: Mixed smooth and steep\n    gamma, x1 = 80.0, 0.35\n    f3_u = lambda x: np.sin(3 * np.pi * x) + 0.1 * np.arctan(gamma * (x - x1))\n    f3_f = lambda x: 9 * np.pi**2 * np.sin(3 * np.pi * x) + (0.2 * gamma**3 * (x - x1)) / (1 + gamma**2 * (x - x1)**2)**2\n    case3 = {\n        'mesh_nodes': np.array([0, 0.2, 0.4, 0.6, 0.8, 1]),\n        'p_degrees': np.array([1, 3, 2, 1, 4]),\n        'u_func': f3_u,\n        'f_func': f3_f\n    }\n    test_cases.append(case3)\n\n    all_results = []\n    for case in test_cases:\n        result = process_test_case(case['mesh_nodes'], case['p_degrees'], case['u_func'], case['f_func'])\n        all_results.append(result)\n\n    print(all_results)\n\nsolve()\n```"
        }
    ]
}