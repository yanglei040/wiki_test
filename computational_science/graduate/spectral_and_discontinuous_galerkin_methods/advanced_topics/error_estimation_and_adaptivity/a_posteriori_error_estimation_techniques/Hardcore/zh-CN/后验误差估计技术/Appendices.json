{
    "hands_on_practices": [
        {
            "introduction": "基于残差的后验误差估计量由局部可计算的量构成，例如单元内的残差和单元间的通量跳跃。第一个练习将提供计算这些基本分量之一——内部边上的牵引力跳跃——的具体动手经验。通过逐步完成这个计算，你将对误差估计的抽象理论如何与离散的有限元解联系起来有一个切实的理解。",
            "id": "3541963",
            "problem": "考虑一个在尖端载荷作用下的二维悬臂梁，在平面应变条件下建模，使用线性拉格朗日单元（$P_1$）通过有限元法（FEM）进行离散化。关注一个局部内部边 $e$，该边是将坐标（单位：米）为 $A=(0,0)$、$B=(1,0)$、$C=(0,1)$ 和 $D=(1,1)$ 的单位正方形沿从 $B$ 到 $C$ 的对角线分割而成的两个相邻三角形的公共边。令 $T^{+}=\\triangle ABC$ 和 $T^{-}=\\triangle BDC$，并令 $e$ 为连接 $B$ 和 $C$ 的边。离散位移场 $u_h=(u_{h,x},u_{h,y})$ 在每个三角形上是分段仿射的，其在网格顶点处的值（单位：米）由以下给出\n- $u_h(A)=(0,0)$，\n- $u_h(B)=(1.0\\times 10^{-4},\\,2.0\\times 10^{-4})$，\n- $u_h(C)=(-5.0\\times 10^{-5},\\,3.0\\times 10^{-4})$，\n- $u_h(D)=(9.0\\times 10^{-5},\\,4.7\\times 10^{-4})$。\n假设材料为各向同性、均匀、线性弹性的，处于平面应变状态，其 Lamé 参数 $(\\lambda,\\mu)$ 等于 $\\lambda=1.2\\times 10^{9}\\,\\mathrm{Pa}$ 和 $\\mu=0.8\\times 10^{9}\\,\\mathrm{Pa}$。柯西应力张量定义为 $\\sigma(u_h)=2\\mu\\,\\varepsilon(u_h)+\\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$，其中 $\\varepsilon(u_h)=(\\nabla u_h+(\\nabla u_h)^{\\top})/2$ 是对称梯度，$I$ 是单位张量。在由单元 $T^{+}$ 和 $T^{-}$ 共享的内部边 $e$ 上，其沿 $e$ 的单位外法向量分别表示为 $n^{+}$（对于 $T^{+}$）和 $n^{-}$（对于 $T^{-}$），且满足 $n^{-}=-n^{+}$，定义牵引力跳跃向量为 $\\llbracket \\sigma(u_h)n \\rrbracket := \\sigma(u_h)|_{T^{+}}\\,n^{+}+\\sigma(u_h)|_{T^{-}}\\,n^{-}$。边范数定义为 $\\|v\\|_{0,e}=\\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$，其中 $|\\,\\cdot\\,|$ 是 $\\mathbb{R}^{2}$ 中的欧几里得范数。使用这些数据和定义，计算边 $e=\\overline{BC}$ 上的内部边跳跃贡献 $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$。以 $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ 为单位表示最终答案，并四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上合理、内容自洽且提法得当。\n\n### 步骤 1：提取已知条件\n- **几何：**一个单位正方形，顶点坐标（单位：米）为 $A=(0,0)$、$B=(1,0)$、$C=(0,1)$ 和 $D=(1,1)$。区域被划分为两个三角形：$T^{+} = \\triangle ABC$ 和 $T^{-} = \\triangle BDC$。\n- **关注的边：**$e = \\overline{BC}$，即 $T^{+}$ 和 $T^{-}$ 之间的公共边。\n- **有限元离散化：**线性拉格朗日单元 ($P_1$)。离散位移场 $u_h=(u_{h,x}, u_{h,y})$ 是分段仿射的。\n- **节点位移（单位：米）：**\n  - $u_h(A) = (0,0)$\n  - $u_h(B) = (1.0 \\times 10^{-4}, 2.0 \\times 10^{-4})$\n  - $u_h(C) = (-5.0 \\times 10^{-5}, 3.0 \\times 10^{-4})$\n  - $u_h(D) = (9.0 \\times 10^{-5}, 4.7 \\times 10^{-4})$\n- **材料模型：**各向同性、均匀、线性弹性、平面应变。\n- **材料属性（Lamé 参数）：**$\\lambda = 1.2 \\times 10^{9}\\,\\mathrm{Pa}$，$\\mu = 0.8 \\times 10^{9}\\,\\mathrm{Pa}$。\n- **本构关系：**柯西应力 $\\sigma(u_h) = 2\\mu\\,\\varepsilon(u_h) + \\lambda\\,\\mathrm{tr}(\\varepsilon(u_h))\\,I$，其中 $\\varepsilon(u_h) = (\\nabla u_h + (\\nabla u_h)^{\\top})/2$。\n- **定义：**\n  - 牵引力跳跃：$\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma(u_h)|_{T^{+}}\\,n^{+} + \\sigma(u_h)|_{T^{-}}\\,n^{-}$，其中 $n^{\\pm}$ 是从 $T^{\\pm}$ 沿 $e$ 的单位外法向量，且 $n^{-} = -n^{+}$。\n  - 边范数：$\\|v\\|_{0,e} = \\left(\\int_{e}|v|^{2}\\,\\mathrm{d}s\\right)^{1/2}$。\n- **目标：**计算边 $e=\\overline{BC}$ 上的 $\\|\\llbracket \\sigma(u_h)n\\rrbracket\\|_{0,e}$，并以 $\\mathrm{N}\\,\\mathrm{m}^{-3/2}$ 为单位提供结果，四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是计算固体力学中有限元法后验误差估计的一个标准练习。它在科学上基于线性弹性和连续介质力学的原理。所有术语都是标准的且定义精确。所有需要的数据（几何、节点位移、材料常数）都已提供并且在物理上是合理的。问题是适定的、客观的，并且不包含矛盾或歧义。\n\n### 步骤 3：结论和行动\n问题有效。下面是完整的解答。\n\n### 详细解答\n\n解答过程首先计算每个三角形单元上的恒定位移梯度，然后计算应变和应力张量，接着计算牵引力跳跃向量，最后计算所需的边范数。\n\n**1. 位移梯度**\n由于位移场 $u_h$ 在每个三角形上是仿射的（线性的），其梯度 $\\nabla u_h$ 在每个单元上是一个常数矩阵。\n\n对于顶点为 $A(0,0)$、$B(1,0)$ 和 $C(0,1)$ 的单元 $T^{+} = \\triangle ABC$，位移场形式为 $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$。梯度为 $\\nabla u_h = \\mathbf{B}^T$。系数由节点值确定：\n$u_h(0,0) = \\mathbf{a} = u_h(A) = (0,0)$。\n$u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix} = u_h(B)$，这意味着 $\\mathbf{B}$ 的第一列是 $u_h(B)$。\n$u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix} = u_h(C)$，这意味着 $\\mathbf{B}$ 的第二列是 $u_h(C)$。\n所以，$\\mathbf{B} = \\begin{pmatrix} u_{h,x}(B)  u_{h,x}(C) \\\\ u_{h,y}(B)  u_{h,y}(C) \\end{pmatrix} = \\begin{pmatrix} 1.0 \\times 10^{-4}  -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}  3.0 \\times 10^{-4} \\end{pmatrix}$。\n在 $T^{+}$ 上的梯度是：\n$$ \\nabla u_h|_{T^{+}} = \\mathbf{B}^T = \\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} $$\n\n对于顶点为 $B(1,0)$、$D(1,1)$ 和 $C(0,1)$ 的单元 $T^{-} = \\triangle BDC$，我们再次设 $u_h(x,y) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}x \\\\ y\\end{pmatrix}$。我们求解一个线性方程组：\n$u_h(C) = u_h(0,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}0 \\\\ 1\\end{pmatrix}$\n$u_h(B) = u_h(1,0) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$\n$u_h(D) = u_h(1,1) = \\mathbf{a} + \\mathbf{B}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$\n由此，我们发现 $\\mathbf{B}$ 的列是 $B_{\\cdot 1} = u_h(D) - u_h(C)$ 和 $B_{\\cdot 2} = u_h(D) - u_h(B)$。\n$B_{\\cdot 1} = \\begin{pmatrix} 9.0 \\times 10^{-5} - (-5.0 \\times 10^{-5}) \\\\ 4.7 \\times 10^{-4} - 3.0 \\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} 1.4 \\times 10^{-4} \\\\ 1.7 \\times 10^{-4} \\end{pmatrix}$。\n$B_{\\cdot 2} = \\begin{pmatrix} 9.0 \\times 10^{-5} - 1.0 \\times 10^{-4} \\\\ 4.7 \\times 10^{-4} - 2.0 \\times 10^{-4} \\end{pmatrix} = \\begin{pmatrix} -1.0 \\times 10^{-5} \\\\ 2.7 \\times 10^{-4} \\end{pmatrix}$。\n所以，$\\mathbf{B} = \\begin{pmatrix} 1.4 \\times 10^{-4}  -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4}  2.7 \\times 10^{-4} \\end{pmatrix}$。\n在 $T^{-}$ 上的梯度是：\n$$ \\nabla u_h|_{T^{-}} = \\mathbf{B}^T = \\begin{pmatrix} 1.4 \\times 10^{-4}  1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} $$\n\n**2. 应变和应力张量**\n应变张量是 $\\varepsilon = \\frac{1}{2}(\\nabla u_h + (\\nabla u_h)^T)$。\n在 $T^{+}$上：\n$$ \\varepsilon^{+} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-4} \\\\ -5.0 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-4}  -5.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-4}  3.0 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.0 \\times 10^{-4}  7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} $$\n迹为 $\\mathrm{tr}(\\varepsilon^{+}) = (1.0 + 3.0) \\times 10^{-4} = 4.0 \\times 10^{-4}$。\n应力张量 $\\sigma^{+} = 2\\mu\\varepsilon^{+} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{+})I$：\n$$ \\sigma^{+} = 2(0.8 \\times 10^9)\\varepsilon^{+} + (1.2 \\times 10^9)(4.0 \\times 10^{-4})I $$\n$$ \\sigma^{+} = 1.6 \\times 10^9 \\begin{pmatrix} 1.0 \\times 10^{-4}  7.5 \\times 10^{-5} \\\\ 7.5 \\times 10^{-5}  3.0 \\times 10^{-4} \\end{pmatrix} + 4.8 \\times 10^5 I = \\begin{pmatrix} 1.6 \\times 10^5  1.2 \\times 10^5 \\\\ 1.2 \\times 10^5  4.8 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.8 \\times 10^5  0 \\\\ 0  4.8 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{+} = \\begin{pmatrix} 6.4 \\times 10^5  1.2 \\times 10^5 \\\\ 1.2 \\times 10^5  9.6 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n在 $T^{-}$上：\n$$ \\varepsilon^{-} = \\frac{1}{2}\\left(\\begin{pmatrix} 1.4 \\times 10^{-4}  1.7 \\times 10^{-4} \\\\ -1.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} + \\begin{pmatrix} 1.4 \\times 10^{-4}  -1.0 \\times 10^{-5} \\\\ 1.7 \\times 10^{-4}  2.7 \\times 10^{-4} \\end{pmatrix}\\right) = \\begin{pmatrix} 1.4 \\times 10^{-4}  8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} $$\n迹为 $\\mathrm{tr}(\\varepsilon^{-}) = (1.4 + 2.7) \\times 10^{-4} = 4.1 \\times 10^{-4}$。\n应力张量 $\\sigma^{-} = 2\\mu\\varepsilon^{-} + \\lambda\\,\\mathrm{tr}(\\varepsilon^{-})I$：\n$$ \\sigma^{-} = 2(0.8 \\times 10^9)\\varepsilon^{-} + (1.2 \\times 10^9)(4.1 \\times 10^{-4})I $$\n$$ \\sigma^{-} = 1.6 \\times 10^9 \\begin{pmatrix} 1.4 \\times 10^{-4}  8.0 \\times 10^{-5} \\\\ 8.0 \\times 10^{-5}  2.7 \\times 10^{-4} \\end{pmatrix} + 4.92 \\times 10^5 I = \\begin{pmatrix} 2.24 \\times 10^5  1.28 \\times 10^5 \\\\ 1.28 \\times 10^5  4.32 \\times 10^5 \\end{pmatrix} + \\begin{pmatrix} 4.92 \\times 10^5  0 \\\\ 0  4.92 \\times 10^5 \\end{pmatrix} $$\n$$ \\sigma^{-} = \\begin{pmatrix} 7.16 \\times 10^5  1.28 \\times 10^5 \\\\ 1.28 \\times 10^5  9.24 \\times 10^5 \\end{pmatrix}\\,\\mathrm{Pa} $$\n\n**3. 牵引力跳跃向量**\n边 $e$ 是连接 $B(1,0)$ 和 $C(0,1)$ 的线段 $\\overline{BC}$。沿该边的向量是 $C-B = (-1,1)$。一个正交向量是 $(1,1)$。对于 $T^+ = \\triangle ABC$，顶点 $A(0,0)$ 位于直线 $x+y-1=0$ 的一侧，该侧满足 $x+y-10$。因此，从 $T^{+}$ 指出的单位外法向量是：\n$$ n^{+} = \\frac{1}{\\sqrt{1^2+1^2}}(1,1) = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} $$\n牵引力跳跃定义为 $\\llbracket \\sigma(u_h)n \\rrbracket = \\sigma^{+}n^{+} + \\sigma^{-}n^{-}$。由于 $n^{-} = -n^{+}$，这可以简化为 $\\llbracket \\sigma(u_h)n \\rrbracket = (\\sigma^{+} - \\sigma^{-})n^{+}$。我们计算应力张量的差值：\n$$ \\sigma^{+} - \\sigma^{-} = 10^5 \\left( \\begin{pmatrix} 6.4  1.2 \\\\ 1.2  9.6 \\end{pmatrix} - \\begin{pmatrix} 7.16  1.28 \\\\ 1.28  9.24 \\end{pmatrix} \\right) = 10^5 \\begin{pmatrix} -0.76  -0.08 \\\\ -0.08  0.36 \\end{pmatrix} $$\n牵引力跳跃向量 $J = \\llbracket \\sigma(u_h)n \\rrbracket$ 是：\n$$ J = 10^5 \\begin{pmatrix} -0.76  -0.08 \\\\ -0.08  0.36 \\end{pmatrix} \\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix} = \\frac{10^5}{\\sqrt{2}} \\begin{pmatrix} -0.76 - 0.08 \\\\ -0.08 + 0.36 \\end{pmatrix} = \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} $$\n由于 $\\sigma^{+}$ 和 $\\sigma^{-}$ 在各自的单元上是常数，跳跃向量 $J$ 沿着边 $e$ 是常数。\n\n**4. 边范数计算**\n范数是 $\\|J\\|_{0,e} = \\left(\\int_e |J|^2 \\mathrm{d}s\\right)^{1/2}$。由于 $J$ 是常数，这可以简化为 $\\|J\\|_{0,e} = \\sqrt{|J|^2 \\cdot \\mathrm{length}(e)} = |J| \\sqrt{\\mathrm{length}(e)}$。\n边 $e$ 的长度是 $L_e = \\sqrt{(1-0)^2 + (0-1)^2} = \\sqrt{2}\\,\\mathrm{m}$。\n跳跃向量的欧几里得范数是：\n$$ |J| = \\left| \\frac{10^5}{\\sqrt{2}}\\begin{pmatrix} -0.84 \\\\ 0.28 \\end{pmatrix} \\right| = \\frac{10^5}{\\sqrt{2}} \\sqrt{(-0.84)^2 + (0.28)^2} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.7056 + 0.0784} = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.784} $$\n因式分解：$0.784 = 0.28^2 \\times 10$。\n$$ |J| = \\frac{10^5}{\\sqrt{2}} \\sqrt{0.28^2 \\times 10} = \\frac{10^5 \\times 0.28 \\times \\sqrt{10}}{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5}\\,\\mathrm{N}\\,\\mathrm{m}^{-2} $$\n最后，我们计算边范数：\n$$ \\|J\\|_{0,e} = |J| \\sqrt{L_e} = (0.28 \\times 10^5 \\sqrt{5}) \\sqrt{\\sqrt{2}} = 0.28 \\times 10^5 \\sqrt{5} \\sqrt[4]{2} $$\n单位是 $(\\mathrm{N}\\,\\mathrm{m}^{-2}) \\cdot \\mathrm{m}^{1/2} = \\mathrm{N}\\,\\mathrm{m}^{-3/2}$。\n\n**5. 最终数值**\n我们现在计算数值并四舍五入到四位有效数字：\n$$ \\|J\\|_{0,e} = 2.8 \\times 10^4 \\times \\sqrt{5} \\times \\sqrt[4]{2} \\approx 2.8 \\times 10^4 \\times (2.2360679...) \\times (1.1892071...) $$\n$$ \\|J\\|_{0,e} \\approx 2.8 \\times 10^4 \\times (2.6591479...) \\approx 7.445614... \\times 10^4 $$\n四舍五入到四位有效数字，我们得到 $7.446 \\times 10^4$。",
            "answer": "$$\\boxed{7.446 \\times 10^{4}}$$"
        },
        {
            "introduction": "后验误差估计的最终目标是指导自适应网格细化(AMR)，使我们能够自动地将计算资源集中在最需要的地方。本实践将理论付诸实现，要求你基于著名的Dörfler标记策略，编写一个完整的自适应循环。通过为一个带有角点奇异性的经典基准问题模拟细化过程，你将亲眼见证误差指示器如何驱动网格自适应并最终获得最优收敛率。",
            "id": "3542038",
            "problem": "考虑一个带有凹角的二维 L 型域上的小应变线性弹性力学问题。假设物体在平面应变条件下建模，其拉梅参数为 $\\lambda$ 和 $\\mu$，位移场 $\\mathbf{u}$ 由强形式方程 $-\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{f}$ 在 $\\Omega$ 中支配，其中 $\\boldsymbol{\\sigma} = \\lambda (\\nabla \\cdot \\mathbf{u}) \\mathbf{I} + 2 \\mu \\, \\boldsymbol{\\varepsilon}(\\mathbf{u})$ 且 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\top})$，并服从混合边界条件。在具有凹角的域中，解在角点附近表现出奇异应力状态和正则性降低的现象。采用由后验误差估计引导的自适应网格加密技术，以恢复在能量范数下的最优收敛率。\n\n一种基于残差跳跃的估计子将全局误差代理划分为每个单元 $K$ 的局部指标 $\\eta_K$，在有限元法 (FEM) 的标准假设下，该估计子被认为是可靠且高效的。一种整体追踪策略选择要加密的单元，以确保在每一步中处理掉全局估计子的一个固定比例。Dörfler 标记是其中一种策略。您必须以最小基数的意义上实现此标记策略：在所有能够捕捉到总平方指标指定比例的单元子集中，选择一个单元数量最少的子集。\n\n为了使其在不求解线性弹性力学方程的情况下可实现，请使用一个与凹角奇异性类别一致的标量代理（这在自适应方法的分析中被广泛采用）。具体来说，在 L 型域 $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$ 上，其凹角位于原点，通过以下幂律来模拟角点附近的局部指标缩放行为：\n$$\n\\eta_K \\approx c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1},\n$$\n其中 $c$ 是一个正常数（设 $c=1$），$h_K$ 是单元尺寸，$r_K$ 是单元中心到原点的欧几里得距离，而 $\\alpha = 0.544483736782$ 是与齐次标量椭圆模型相关的 L 型域奇异性指数。该代理模型与带角点奇异性问题的残差跳跃误差估计子的行为一致，并能捕捉到必要的近角点加密偏向。\n\n您的任务是：\n- 通过将 $[-1,1]^2$ 细分为 $n_x \\times n_y$ 个相等大小的正方形，并丢弃那些中心位于被切除的正方形 $[0,1]\\times[-1,0]$ 内的单元，来构建 $\\Omega$ 上的初始均匀正方形剖分。请使用 $n_x = n_y = 12$。\n- 对每个单元 $K$，使用上述代理模型计算 $r_K$ 和 $\\eta_K$。通过设置 $r_K \\leftarrow \\max(r_K, 10^{-6})$ 来避免除以零。\n- 实现最小基数的整体追踪标记策略：对于给定的参数 $\\theta \\in (0,1)$，选择一个集合 $\\mathcal{M}$，使得所选单元的平方指标之和至少占总平方估计子的一部分，同时被标记的单元数量尽可能少。\n- 通过将每个选定的正方形细分为四个尺寸减半的子正方形来加密被标记的单元。中心落在 $\\Omega$ 之外的子单元必须被丢弃；位于内部的子单元则在网格中替换其父单元。在加密后的网格上重新计算指标。\n- 重复标记-加密循环固定的加密步数，每次使用相同的 $\\theta$。请使用 $N_{\\text{steps}} = 7$。\n- 在每一步 $k$，计算全局估计子 $E_k = \\left(\\sum_{K} \\eta_K^2\\right)^{1/2}$ 和网格中当前的单元数量 $N_k$。\n- 通过对最后五个加密步骤的 $(\\log N_k, \\log E_k)$ 数据进行线性拟合，并取 $p(\\theta) = -\\text{斜率}$，来估计收敛率 $p(\\theta)$。这可以近似模型 $E(N) \\approx C N^{-p}$ 在 $N$ 较大时的收敛率。\n\n请在单个程序中实现上述过程，该程序评估多个 $\\theta$ 值并报告估计的收敛率。您必须确保代理模型和加密过程的数值稳定性与科学合理性。\n\n测试套件：\n- 使用以下 $\\theta$ 值：$0.15$、$0.3$、$0.5$、$0.7$、$0.9$。\n- 对于每个 $\\theta$，运行完整的加密循环并按规定计算 $p(\\theta)$。\n\n答案规格：\n- 您的程序的最终输出必须是单行文本，其中包含测试套件中所有 $\\theta$ 值的估计收敛率列表，并按所给顺序排列。\n- 格式必须是用方括号括起来的逗号分隔列表，例如 $[p(0.15),p(0.3),p(0.5),p(0.7),p(0.9)]$。\n- 每个条目都必须是浮点数。不需要物理单位，也不涉及角度。\n\n您的程序必须是自包含的，无需任何外部输入或文件即可运行。",
            "solution": "该问题为模拟一个带角点奇异性问题的自适应网格加密 (AMR) 过程提供了详细的规范。验证证实了该问题在科学上是合理的、适定的，并包含了确定性实现所需的所有信息。这是自适应有限元方法 (AFEM) 领域的一个标准数值实验。\n\n核心任务是实现一个由 Dörfler 标记驱动的“标记-加密”循环，使用一个代理误差指标来模拟 L 型域上椭圆偏微分方程解的行为。最终目标是针对不同标记参数 $\\theta$ 的值，估计全局误差估计子随单元数量变化的收敛率。\n\n**1. 域和初始网格**\n\n计算域是 L 型区域 $\\Omega = [-1,1]^2 \\setminus \\big([0,1]\\times[-1,0]\\big)$，其在原点 $(0,0)$ 处有一个凹角。这个角点会在椭圆边值问题的解中引入一个奇异点，从而降低标准数值方法在均匀网格上的性能。\n\n模拟始于构建一个初始网格。首先将正方形域 $[-1,1]^2$ 剖分为一个由 $n_x \\times n_y$ 个较小正方形组成的均匀网格，其中 $n_x = n_y = 12$。这些初始单元的边长为 $h_0 = (1 - (-1))/12 = 2/12 = 1/6$。几何中心 $(x_c, y_c)$ 落在被切除象限内（即满足 $x_c > 0$ 和 $y_c  0$）的单元被丢弃。此过程产生一个包含 $N_0 = 12^2 - 6^2 = 144 - 36 = 108$ 个正方形单元的初始网格，该网格精确地表示了域 $\\Omega$。\n\n网格中的每个单元 $K$ 由其中心坐标和边长 $h_K$ 表示。\n\n**2. 代理误差指标**\n\n我们不求解完整的线性弹性力学方程（因为其计算成本高昂），而是对每个单元 $K$ 上的局部误差指标 $\\eta_K$ 使用一个代理模型。该模型旨在模拟真实误差的空间分布，而该分布主要由角点奇异性主导。提供的公式是：\n$$\n\\eta_K = c \\, \\sqrt{h_K} \\, r_K^{\\alpha - 1}\n$$\n其中：\n- $c=1$ 是一个常数。\n- $h_K$ 是正方形单元 $K$ 的边长。\n- $r_K$ 是单元 $K$ 中心到凹角（原点）的欧几里得距离。为了防止对可能位于原点的单元进行除零操作，$r_K$ 被限制在一个最小值：$r_K \\leftarrow \\max(r_K, 10^{-6})$。\n- $\\alpha = 0.544483736782$ 是奇异性强度。对于 L 型域上的泊松方程，角点附近的解 $u$ 具有 $u \\sim r^{\\alpha} \\sin(\\alpha \\phi)$ 的形式，其中 $(r, \\phi)$ 是极坐标。误差集中在解的梯度较大的地方。由于 $\\alpha  1$，当 $r_K \\to 0$ 时，$r_K^{\\alpha - 1}$ 项会变大，从而正确地识别出奇异点附近的单元具有较大的误差贡献。\n\n**3. 自适应“标记-加密”算法**\n\n模拟的核心是一个自适应加密网格的迭代循环。对于给定的标记参数 $\\theta \\in (0,1)$，该循环运行 $N_{\\text{steps}}=7$ 次迭代。每次迭代包括四个主要步骤：计算 (COMPUTE)、标记 (MARK)、加密 (REFINE) 和记录 (RECORD)。\n\n**3A. 计算 (COMPUTE)**\n对于步骤 $k$ 的当前网格 $\\mathcal{T}_k$，我们首先使用代理公式计算每个单元 $K \\in \\mathcal{T}_k$ 的误差指标 $\\eta_K$。然后，总平方误差估计子计算为局部指标平方和：\n$$\nE_k^2 = \\sum_{K \\in \\mathcal{T}_k} \\eta_K^2\n$$\n\n**3B. 标记 (MARK)**\n标记步骤选择网格 $\\mathcal{T}_k$ 的一个子集 $\\mathcal{M}_k$ 进行加密。我们采用 Dörfler 标记（也称为整体追踪），其目标是加密足够数量的单元以保证总误差的减少。该策略是找到一个具有最小可能单元数（最小基数）的集合 $\\mathcal{M}_k$，满足以下标准：\n$$\n\\sum_{K \\in \\mathcal{M}_k} \\eta_K^2 \\ge \\theta E_k^2\n$$\n从算法上讲，这是通过以下方式实现的：\n1. 根据所有单元的指标值 $\\eta_K$ 对它们进行降序排序。\n2. 遍历排序后的列表，将单元添加到标记集 $\\mathcal{M}_k$ 中，并累加它们的平方指标。\n3. 一旦累加和达到目标阈值 $\\theta E_k^2$，就停止。这种贪心方法保证了我们选择误差最大的单元，同时标记的单元数量最少。\n\n**3C. 加密 (REFINE)**\n$\\mathcal{M}_k$ 中的被标记单元被加密，而未标记的单元则被移至下一个网格 $\\mathcal{T}_{k+1}$。对一个正方形单元的加密过程是一个简单的四分法：\n1. 将每个被标记的正方形 $K \\in \\mathcal{M}_k$ 细分为四个相等的、边长为父单元一半的较小子正方形（子单元）。\n2. 检查每个子单元的有效性：其中心必须位于域 $\\Omega$ 内。中心位于被切除区域 $[0,1] \\times [-1,0]$ 内的子单元将被丢弃。\n3. 新网格 $\\mathcal{T}_{k+1}$ 由 $\\mathcal{T}_k$ 中未标记的单元集和所有有效的新子单元集的并集构成。\n\n**3D. 记录 (RECORD)**\n在每一步 $k$，我们记录单元数量 $N_k = |\\mathcal{T}_k|$ 和全局误差估计子 $E_k = \\sqrt{E_k^2}$。\n\n**4. 收敛率估计**\n\nAFEM 理论预测，对于一个合适的自适应策略，误差 $E$ 相对于单元数量 $N$ 的收敛应遵循幂律：\n$$\nE(N) \\approx C N^{-p}\n$$\n其中 $p$ 是收敛率。对于有奇异性的问题，均匀加密产生的是次优收敛率，但自适应加密可以恢复最优收敛率，该最优率与奇异性指数 $\\alpha$ 相关。对上述关系取对数，得到一个线性方程：\n$$\n\\log E \\approx \\log C - p \\log N\n$$\n这表明 $\\log E$ 对 $\\log N$ 的图像应该是一条斜率为 $-p$ 的直线。\n\n为了估计 $p$，我们对收集到的数据点 $(\\log N_k, \\log E_k)$ 进行线性回归。按照规定，我们使用最后五个加密步骤（从 $k=2$ 到 $k=6$）的数据来估计渐近率，忽略任何初始的瞬态行为。计算最佳拟合线的斜率，收敛率则确定为 $p(\\theta) = -\\text{斜率}$。对测试套件中的每个 $\\theta$ 值重复这整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements an adaptive mesh refinement simulation for an L-shaped domain\n    to estimate the convergence rate of a surrogate error estimator.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    ALPHA = 0.544483736782\n    THETAS = [0.15, 0.3, 0.5, 0.7, 0.9]\n    N_STEPS = 7\n    NX, NY = 12, 12\n    R_CLAMP = 1e-6\n\n    def is_in_domain(center):\n        \"\"\"Checks if a point is within the L-shaped domain.\"\"\"\n        x, y = center\n        # The excised region is where x > 0 and y = 0.\n        return not (x > 0 and y = 0)\n\n    def generate_initial_mesh():\n        \"\"\"Creates the initial uniform mesh on the L-shaped domain.\"\"\"\n        h_initial = 2.0 / NX\n        mesh_elements = []\n        for i in range(NX):\n            for j in range(NY):\n                xc = -1.0 + h_initial / 2.0 + i * h_initial\n                yc = -1.0 + h_initial / 2.0 + j * h_initial\n                if is_in_domain((xc, yc)):\n                    # Each element is [center_x, center_y, size]\n                    mesh_elements.append([xc, yc, h_initial])\n        return np.array(mesh_elements)\n\n    def run_simulation(theta):\n        \"\"\"\n        Runs the full mark-refine simulation for a given theta value.\n        \"\"\"\n        mesh = generate_initial_mesh()\n        log_N_E_data = []\n\n        for step in range(N_STEPS):\n            # 1. COMPUTE: Indicators and global estimator\n            if mesh.shape[0] == 0:\n                # This should not happen in a valid run, but as a safeguard.\n                if len(log_N_E_data) >= 5:\n                    break\n                else: # Not enough data points to fit\n                    return np.nan \n\n            centers = mesh[:, :2]\n            sizes = mesh[:, 2]\n            \n            r_k = np.linalg.norm(centers, axis=1)\n            r_k = np.maximum(r_k, R_CLAMP)\n            \n            eta_k = np.sqrt(sizes) * r_k**(ALPHA - 1)\n            eta_k_sq = eta_k**2\n            \n            E_k_sq = np.sum(eta_k_sq)\n            E_k = np.sqrt(E_k_sq)\n            N_k = mesh.shape[0]\n\n            # 2. RECORD: Store log-log data\n            log_N_E_data.append([np.log(N_k), np.log(E_k)])\n\n            # Stop after recording the last step's data\n            if step == N_STEPS - 1:\n                break\n\n            # 3. MARK: Dörfler marking\n            total_eta_sq = E_k_sq\n            target_sum_sq = theta * total_eta_sq\n            \n            sorted_indices = np.argsort(eta_k)[::-1]\n            sorted_eta_k_sq = eta_k_sq[sorted_indices]\n            \n            cumulative_sum_sq = np.cumsum(sorted_eta_k_sq)\n            \n            # Find the number of elements to mark\n            # np.searchsorted finds the index where target would be inserted.\n            # We need to take all elements up to and including this index.\n            num_to_mark = np.searchsorted(cumulative_sum_sq, target_sum_sq) + 1\n            \n            marked_indices = sorted_indices[:num_to_mark]\n            unmarked_indices = sorted_indices[num_to_mark:]\n\n            # 4. REFINE: Create the new mesh\n            unmarked_elements = mesh[unmarked_indices]\n            \n            newly_refined_elements = []\n            for idx in marked_indices:\n                parent_center = mesh[idx, :2]\n                parent_size = mesh[idx, 2]\n                child_size = parent_size / 2.0\n                offset = child_size / 2.0\n                \n                # Generate 4 children\n                child_centers = [\n                    parent_center + np.array([-offset, -offset]),\n                    parent_center + np.array([ offset, -offset]),\n                    parent_center + np.array([-offset,  offset]),\n                    parent_center + np.array([ offset,  offset]),\n                ]\n                \n                for child_center in child_centers:\n                    if is_in_domain(child_center):\n                        newly_refined_elements.append([child_center[0], child_center[1], child_size])\n            \n            if newly_refined_elements:\n                mesh = np.vstack((unmarked_elements, np.array(newly_refined_elements)))\n            else:\n                mesh = unmarked_elements\n        \n        # 5. ESTIMATE CONVERGENCE RATE\n        # Use the last 5 data points for linear regression\n        if len(log_N_E_data)  5:\n            return np.nan # Cannot fit with fewer than 2 points, but problem asks for 5.\n\n        last_5_data = np.array(log_N_E_data[-5:])\n        log_N = last_5_data[:, 0]\n        log_E = last_5_data[:, 1]\n        \n        # Perform linear regression: log_E = slope * log_N + intercept\n        # np.polyfit returns [slope, intercept]\n        slope, _ = np.polyfit(log_N, log_E, 1)\n        \n        # Convergence rate p = -slope\n        p_theta = -slope\n        return p_theta\n\n    # --- Main Execution ---\n    results = []\n    for theta in THETAS:\n        rate = run_simulation(theta)\n        results.append(rate)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}