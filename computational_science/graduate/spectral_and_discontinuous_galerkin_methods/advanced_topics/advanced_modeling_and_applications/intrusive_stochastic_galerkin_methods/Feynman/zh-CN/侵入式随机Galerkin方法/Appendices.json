{
    "hands_on_practices": [
        {
            "introduction": "侵入式随机伽辽金方法的基础在于选择一个关于随机输入的概率测度正交的多项式基。这个练习将提供具体实践，将一个标准的多项式族（针对均匀不确定性的勒让德多项式）进行归一化，以构建简化伽辽金系统所需的正交基。掌握这一过程对于正确建立广义多项式混沌（gPC）展开至关重要。",
            "id": "3392649",
            "problem": "考虑侵入式随机Galerkin方法，其中标量随机输入由均匀随机变量 $\\xi \\sim \\mathcal{U}(-1,1)$ 建模，其概率密度函数 (PDF) 为：当 $\\xi \\in [-1,1]$ 时 $\\rho(\\xi)=\\frac{1}{2}$，其他情况下 $\\rho(\\xi)=0$。在Galerkin投影中，内积是关于 $\\rho$ 的期望 $\\mathbb{E}[\\cdot]$，因此对于任意平方可积函数 $f$ 和 $g$，内积定义为 $\\langle f, g \\rangle_{\\rho} := \\mathbb{E}[f(\\xi) g(\\xi)] = \\int_{-1}^{1} f(\\xi) g(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi$。由于其在 $[-1,1]$ 上关于均匀权重的正交性，多项式基选自经典Legendre多项式 $\\{P_n(\\xi)\\}_{n=0}^{\\infty}$。在许多侵入式随机Galerkin公式中，例如基于广义多项式混沌 (Generalized Polynomial Chaos, gPC) 的公式，要求基在 $\\langle \\cdot, \\cdot \\rangle_{\\rho}$ 下是标准正交的，以获得简化的代数结构。\n\n从上述基本定义出发，确定归一化常数 $c_n$，使得缩放后的基函数 $\\Psi_n(\\xi) := c_n P_n(\\xi)$ 在 $L^{2}_{\\rho}([-1,1])$ 中构成一个标准正交系，即 $\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 表示克罗内克δ。然后，使用相同的定义，以闭式形式验证期望值恒等式 $\\mathbb{E}[P_m(\\xi) P_n(\\xi)]$。你的最终答案必须是 $c_n$ 关于 $n$ 的闭式表达式；不需要数值近似，也不涉及单位。",
            "solution": "首先将对问题进行验证，以确保其科学和逻辑上的完整性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 标量随机输入由均匀随机变量 $\\xi \\sim \\mathcal{U}(-1,1)$ 建模。\n- 概率密度函数 (PDF) 为：当 $\\xi \\in [-1,1]$ 时 $\\rho(\\xi)=\\frac{1}{2}$，其他情况下 $\\rho(\\xi)=0$。\n- 对于平方可积函数 $f$ 和 $g$，内积定义为期望 $\\langle f, g \\rangle_{\\rho} := \\mathbb{E}[f(\\xi) g(\\xi)] = \\int_{-1}^{1} f(\\xi) g(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi$。\n- 多项式基是经典Legendre多项式集合 $\\{P_n(\\xi)\\}_{n=0}^{\\infty}$。\n- 缩放后的基函数为 $\\Psi_n(\\xi) := c_n P_n(\\xi)$，其中 $c_n$ 是归一化常数。\n- 标准正交性条件为 $\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 是克罗内克δ。\n\n**步骤2：使用提取的已知条件进行验证**\n问题根据验证标准进行评估。\n- **科学基础**：该问题牢固地植根于不确定性量化的数学理论，特别是使用带有侵入式Galerkin方法的广义多项式混沌 (Generalized Polynomial Chaos, gPC) 展开。将Legendre多项式用作均匀随机变量的正交基是Askey格式的一个标准且正确的应用。所有定义和性质都与该领域的已有文献一致。\n- **适定性**：该问题是适定的。它要求基于一组清晰且完整的定义来确定归一化常数 $c_n$，这会导出一个唯一解（按照惯例，$c_n > 0$）。\n- **客观性**：问题使用精确和客观的数学语言陈述，没有任何主观性或模糊性。\n- **完整性**：问题提供了所有必要的信息：概率分布、内积的定义、基多项式和标准正交性条件。它是自洽的。\n- **一致性**：没有内部矛盾。这些定义是标准的并且相互兼容。\n\n**步骤3：结论与行动**\n该问题是有效的。它是在用于不确定性量化的谱方法背景下的一个标准且定义明确的数学练习。将提供完整的解答。\n\n**解答推导**\n\n目标是找到归一化常数 $c_n$，使得基函数 $\\Psi_n(\\xi) = c_n P_n(\\xi)$ 在由期望算子 $\\mathbb{E}[\\cdot]$ 定义的内积下是标准正交的。标准正交性条件为：\n$$\n\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克δ，当 $m=n$ 时为 $1$，当 $m \\neq n$ 时为 $0$。\n\n将 $\\Psi_n(\\xi)$ 的定义代入该条件，我们得到：\n$$\n\\mathbb{E}[ (c_m P_m(\\xi)) (c_n P_n(\\xi)) ] = \\delta_{mn}\n$$\n由于 $c_m$ 和 $c_n$ 是确定性常数，它们可以从期望中提出来：\n$$\nc_m c_n \\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\delta_{mn}\n$$\n接下来，我们根据概率密度函数 $\\rho(\\xi)$ 的定义来计算期望项 $\\mathbb{E}[P_m(\\xi) P_n(\\xi)]$。随机变量 $\\xi$ 在 $[-1, 1]$ 上均匀分布，因此其PDF为 $\\rho(\\xi) = \\frac{1}{2}$，对于 $\\xi \\in [-1, 1]$。\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\int_{-\\infty}^{\\infty} P_m(\\xi) P_n(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\left(\\frac{1}{2}\\right) \\, \\mathrm{d}\\xi\n$$\n提出常数 $\\frac{1}{2}$：\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\frac{1}{2} \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\, \\mathrm{d}\\xi\n$$\n这个表达式构成了问题中所要求的期望值恒等式的验证。为了以闭式形式计算它，我们使用Legendre多项式的标准正交性质，该性质表明：\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) \\, \\mathrm{d}x = \\frac{2}{2n+1} \\delta_{mn}\n$$\n将这个已知结果代入我们的期望表达式，得到闭式恒等式：\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\frac{1}{2} \\left( \\frac{2}{2n+1} \\delta_{mn} \\right) = \\frac{1}{2n+1} \\delta_{mn}\n$$\n现在，我们将此结果代回到缩放基 $\\Psi_n(\\xi)$ 的标准正交性条件中：\n$$\nc_m c_n \\left( \\frac{1}{2n+1} \\delta_{mn} \\right) = \\delta_{mn}\n$$\n为了求出常数 $c_n$，我们考虑 $m = n$ 的情况。在这种情况下，$\\delta_{nn} = 1$：\n$$\nc_n c_n \\left( \\frac{1}{2n+1} \\delta_{nn} \\right) = \\delta_{nn} \\implies c_n^2 \\left( \\frac{1}{2n+1} \\right) = 1\n$$\n解出 $c_n^2$：\n$$\nc_n^2 = 2n+1\n$$\n按照惯例，归一化常数取正平方根。因此：\n$$\nc_n = \\sqrt{2n+1}\n$$\n对于 $m \\neq n$ 的情况，正交性质保证了 $\\delta_{mn} = 0$，从而得到恒等式 $0 = 0$，这是一致的。\n\n因此，标准正交基函数为 $\\Psi_n(\\xi) = \\sqrt{2n+1} P_n(\\xi)$。归一化常数 $c_n$ 仅取决于多项式的次数 $n$。",
            "answer": "$$\n\\boxed{\\sqrt{2n+1}}\n$$"
        },
        {
            "introduction": "定义了基函数后，下一步是将控制方程投影到该基上，从而得到一个大型的、耦合的确定性方程组。这个练习将指导你构建全局随机伽辽金（SG）矩阵的块结构，揭示基函数的性质和不确定性的仿射特性如何导致一个特定的稀疏模式。理解这种结构是开发高效求解器的关键。",
            "id": "3392692",
            "problem": "考虑一个使用空间间断伽辽金(DG)方法对空间离散的标量椭圆模型问题进行的侵入式随机伽辽金(SG)离散化。不确定系数由两个在$[-1,1]$上均匀分布的独立随机变量$\\xi_{1}$和$\\xi_{2}$建模，并通过仿射参数化$a(x,\\xi) = a_{0}(x) + a_{1}(x)\\,\\xi_{1} + a_{2}(x)\\,\\xi_{2}$给出，其中$a_{0}(x)$、$a_{1}(x)$和$a_{2}(x)$是确定性系数场，$x$表示空间坐标。该SG方法使用一个多元勒让德多项式混沌基，该基在随机维度$d=2$下截断至总多项式次数$p=2$，并且关于$[-1,1]^{2}$上的乘积测度是标准正交的。设多重指标集为\n$$\n\\mathcal{I}_{2} \\equiv \\{ \\alpha \\in \\mathbb{N}_{0}^{2} : \\alpha_{1} + \\alpha_{2} \\leq 2 \\},\n$$\n并定义多元基函数$\\psi_{\\alpha}(\\xi) = L_{\\alpha_{1}}(\\xi_{1})\\,L_{\\alpha_{2}}(\\xi_{2})$，其中$L_{n}$表示$[-1,1]$上$n$次标准正交勒让德多项式。\n\n全局SG系统矩阵根据由$\\alpha,\\beta \\in \\mathcal{I}_{2}$索引的随机模态进行分块，得到一个$\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$的分块矩阵。每个块$(\\alpha,\\beta)$是一个空间DG矩阵乘以一个随机矩\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,q(\\xi)\\,\\mathrm{d}\\mu(\\xi),\n$$\n其中$q(\\xi) \\in \\{1,\\xi_{1},\\xi_{2}\\}$分别来自$a_{0}(x)$、$a_{1}(x)$和$a_{2}(x)$，且$\\mathrm{d}\\mu(\\xi)$是均匀乘积测度。仅使用标准正交勒让德多项式的基本性质及其三项递推关系，通过精确确定哪些$(\\alpha,\\beta)$对会产生非零块，来构建在给定$a(x,\\xi)$、 $d=2$和$p=2$情况下的全局SG分块矩阵的稀疏模式。然后，计算该$\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$分块矩阵中非零块的总数。\n\n请以单个整数形式提供最终答案。无需四舍五入。",
            "solution": "我们从使用标准正交多项式混沌基的侵入式随机伽辽金(SG)方法的基本定义开始。多元基函数是作为一维标准正交勒让德多项式的张量积构建的，标准正交性意味着\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\mathrm{d}\\mu(\\xi) = \\delta_{\\alpha\\beta},\n$$\n其中$\\delta_{\\alpha\\beta}$是克罗内克δ，$\\mathrm{d}\\mu(\\xi)$表示均匀乘积测度。\n\n系数$a(x,\\xi) = a_{0}(x) + a_{1}(x)\\,\\xi_{1} + a_{2}(x)\\,\\xi_{2}$对全局SG矩阵产生三个贡献。对于常数项$q(\\xi)=1$，标准正交性仅产生对角随机耦合：\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\mathrm{d}\\mu(\\xi) = \\delta_{\\alpha\\beta}.\n$$\n因此，$a_{0}(x)$的贡献仅在对角线$(\\alpha,\\alpha)$上产生非零块。\n\n对于线性项$q(\\xi)=\\xi_{1}$和$q(\\xi)=\\xi_{2}$，非零耦合由勒让德多项式的三项递推关系确定。对于$[-1,1]$上的标准正交勒让德多项式$\\{L_{n}\\}_{n\\geq 0}$，标准递推关系意味着\n$$\n\\xi\\,L_{n}(\\xi) = c_{n+1}\\,L_{n+1}(\\xi) + c_{n-1}\\,L_{n-1}(\\xi),\n$$\n其中对于所有有效的索引$n\\geq 0$，系数$c_{n\\pm 1}$均为非零。因此，一维三重积\n$$\n\\int_{-1}^{1} L_{m}(\\xi)\\,\\xi\\,L_{n}(\\xi)\\,\\mathrm{d}\\xi\n$$\n当且仅当$m = n \\pm 1$时非零，否则为零（根据奇偶性和正交性，包括$m=n$时）。在多维情况下，可分离性给出\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\xi_{i}\\,\\mathrm{d}\\mu(\\xi)\n= \\left( \\int_{-1}^{1} L_{\\alpha_{i}}(\\xi_{i})\\,\\xi_{i}\\,L_{\\beta_{i}}(\\xi_{i})\\,\\mathrm{d}\\xi_{i} \\right)\n\\prod_{j\\neq i} \\left( \\int_{-1}^{1} L_{\\alpha_{j}}(\\xi_{j})\\,L_{\\beta_{j}}(\\xi_{j})\\,\\mathrm{d}\\xi_{j} \\right).\n$$\n因此，该多元积分非零当且仅当：\n- 对于所有$j \\neq i$，$\\beta_{j} = \\alpha_{j}$（根据未受影响维度的标准正交性），且\n- $\\beta_{i} = \\alpha_{i} \\pm 1$（根据一维递推选择定则）。\n\n因此，由$q(\\xi)=\\xi_{i}$引起的随机耦合连接了在分量$i$上恰好相差一且在其他分量上相等的多重指标。\n\n我们现在列举$d=2$和总次数$p=2$的截断多重指标集：\n$$\n\\mathcal{I}_{2} = \\{ (0,0),\\, (1,0),\\, (0,1),\\, (2,0),\\, (1,1),\\, (0,2) \\}.\n$$\n共有$\\lvert \\mathcal{I}_{2} \\rvert = \\binom{d+p}{p} = \\binom{4}{2} = 6$个随机模态。\n\n我们通过列出所有使块非零的对$(\\alpha,\\beta)$来构造稀疏模式。\n\n1. 常数项 $q(\\xi)=1$（$a_{0}(x)$的贡献）：\n- 仅当$\\beta=\\alpha$时非零。这在对角线上产生$6$个非零块：$(0,0)$、$(1,0)$、$(0,1)$、$(2,0)$、$(1,1)$、$(0,2)$。\n\n2. 线性项 $q(\\xi)=\\xi_{1}$（$a_{1}(x)$的贡献）：\n- 当$\\beta = \\alpha \\pm (1,0)$且该对仍在$\\mathcal{I}_{2}$内时非零。\n- 在$\\pm(1,0)$操作下，$\\mathcal{I}_{2}$中的有效无序邻居对为：\n$$\n(0,0)\\text{–}(1,0),\\quad (1,0)\\text{–}(2,0),\\quad (0,1)\\text{–}(1,1).\n$$\n这是$3$条无向边，对应于完整分块矩阵中的$6$个非对角块位置，因为每条无向边产生两个有向对$(\\alpha,\\beta)$和$(\\beta,\\alpha)$。\n\n3. 线性项 $q(\\xi)=\\xi_{2}$（$a_{2}(x)$的贡献）：\n- 当$\\beta = \\alpha \\pm (0,1)$且该对仍在$\\mathcal{I}_{2}$内时非零。\n- 在$\\pm(0,1)$操作下，$\\mathcal{I}_{2}$中的有效无序邻居对为：\n$$\n(0,0)\\text{–}(0,1),\\quad (0,1)\\text{–}(0,2),\\quad (1,0)\\text{–}(1,1).\n$$\n这是$3$条无向边，同样产生$6$个非对角块位置。\n\n由于选择定则要求恰好一个坐标变化$\\pm 1$，且两个坐标是不同的，所以没有一对同时出现在$\\xi_{1}$和$\\xi_{2}$的列表中。\n\n最后，$\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$分块矩阵中非零块的总数是来自$a_{0}(x)$的对角块与来自线性项的非对角块之和：\n$$\n6 \\text{ (对角)} + 6 \\text{ (来自 } \\xi_{1}\\text{的非对角)} + 6 \\text{ (来自 } \\xi_{2}\\text{的非对角)} = 18.\n$$\n因此，全局SG分块矩阵有$18$个非零块。",
            "answer": "$$\\boxed{18}$$"
        },
        {
            "introduction": "对于实际问题，直接组装和存储完整的随机伽辽金矩阵在计算上通常是不可行的。本练习介绍了一种强大的技术，它利用了基函数和空间离散化的张量积特性，从而形成一种克罗内克积（Kronecker product）结构。你将开发一种“无矩阵”算法，避免生成庞大的全局矩阵，从而显著降低内存成本，并能够求解更大规模的问题。",
            "id": "3392640",
            "problem": "考虑一个具有仿射随机系数的线性椭圆模型问题，其侵入式随机Galerkin (SG) 离散化在一个维度为 $n_h$ 的有限维物理试探空间 $V_h$ 中使用谱方法或间断Galerkin空间离散化，并在一个维度为 $n_p$ 的多项式混沌展开 (PCE) 基中对随机空间进行离散化。在参数仿射的假设下，全局SG矩阵 $A_{\\mathrm{SG}}$ 具有克罗内克和结构\n$$\nA_{\\mathrm{SG}} \\;=\\; \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r,\n$$\n其中 $K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 是从 $V_h$ 导出的确定性空间矩阵（例如，来自谱方法或间断Galerkin公式的类刚度矩阵），$G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 是由PCE内积形成的随机系数矩阵。符号 $\\otimes$ 表示克罗内克积。未知的SG系数向量是通过将每个随机基函数的物理自由度堆叠成一个长度为 $n_h n_p$ 的单一向量而获得的。\n\n从克罗内克积和向量化算子的基本性质出发（具体来说，是针对适形矩阵 $A$、$X$ 和 $B$ 的恒等式\n$$\n\\mathrm{vec}(A X B^\\top) \\;=\\; (B \\otimes A)\\,\\mathrm{vec}(X),\n$$\n），推导并实现一个算法，该算法将 $A_{\\mathrm{SG}}$ 应用于一个向量，而无需显式地构造 $A_{\\mathrm{SG}}$。您的实现必须利用克罗内克结构以避免形成稠密块，并且对于任意输入参数 $n_h$、$n_p$ 和 $m$ 都必须是正确的。\n\n为了测试和可复现性，请在您的程序中按如下方式确定性地构造 $K_r$ 和 $G_r$：\n- 对于每个测试用例，设 $n_h \\geq 1$、$n_p \\geq 1$ 和 $m \\geq 1$ 为给定的整数。\n- 将 $K_0 \\in \\mathbb{R}^{n_h \\times n_h}$ 定义为三对角矩阵，其对角线元素为 $2$，次对角线和超对角线元素为 $-1$。当 $n_h=1$ 时，该矩阵简化为标量 $2$。\n- 对于每个 $r \\in \\{1,\\dots,m-1\\}$，将 $K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 定义为三对角矩阵，其对角线元素为 $2 + \\frac{r}{\\max(1,n_h)}$，次对角线和超对角线元素为 $-\\frac{1}{r+1}$（三对角线外的元素为 $0$）。\n- 将 $G_0 \\in \\mathbb{R}^{n_p \\times n_p}$ 定义为大小为 $n_p$ 的单位矩阵。\n- 对于每个 $r \\in \\{1,\\dots,m-1\\}$，将 $G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 定义为对称离对角邻接矩阵的 $\\frac{1}{r+1}$ 倍，该邻接矩阵在第一条次对角线和超对角线上为1，其余位置为0。具体来说，如果 $|i-j|=1$，则 $(G_r)_{i,j} = \\frac{1}{r+1}$，否则为 $0$。当 $n_p=1$ 时，对于 $r\\geq 1$，$G_r$ 是 $1\\times 1$ 的零矩阵。\n\n为验证正确性，设 $x \\in \\mathbb{R}^{n_h n_p}$ 是矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$ 按列主序的向量化结果，其中 $U$ 由 $U_{i,j} = i + \\frac{j}{10}$ 定义（使用基于1的索引），以确保其元素为严格正数且可复现。将您的无矩阵克罗内克应用算法的结果与显式乘积 $A_{\\mathrm{SG}} x$进行比较，其中 $A_{\\mathrm{SG}}$ 是通过克罗内克积求和形成的；报告二者之差的欧几里得范数。\n\n估算两种方法的内存复杂度，以必须存储的标量数量计：\n- 朴素的显式组装，稠密地存储 $A_{\\mathrm{SG}}$：需要 $(n_h n_p)^2$ 个标量。\n- 克罗内克因子存储，存储所有的 $K_r$ 和 $G_r$ 但从不形成 $A_{\\mathrm{SG}}$：需要 $m \\,(n_h^2 + n_p^2)$ 个标量。\n\n您的程序必须：\n- 使用克罗内克恒等式实现 $A_{\\mathrm{SG}}$ 的无矩阵应用，注意在向量和矩阵之间重塑时要一致地使用列主序向量化。\n- 通过克罗内克积构造显式的 $A_{\\mathrm{SG}}$，并通过计算两种应用结果之差的欧几里得范数来验证无矩阵实现。\n- 计算并报告上述两种内存标量计数。\n- 使用以下参数元组 $(n_h,n_p,m)$ 的测试套件：\n    1. $(4,3,3)$ 作为一般情况，\n    2. $(5,2,2)$ 作为中等情况，\n    3. $(3,1,2)$ 作为随机维度的边界情况，\n    4. $(1,4,2)$ 作为物理维度的边界情况。\n- 对于每个测试用例，生成一个三元列表 $[e, s_{\\mathrm{naive}}, s_{\\mathrm{kron}}]$，其中 $e$ 是显式乘积与无矩阵乘积之差的欧几里得范数（一个浮点数），$s_{\\mathrm{naive}}$ 是朴素显式存储的整型标量计数， $s_{\\mathrm{kron}}$ 是克罗内克因子存储的整型标量计数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表，其中每个元素本身都是一个指定的三元列表（例如， $[[e_1,s_{1,\\mathrm{naive}},s_{1,\\mathrm{kron}}],[e_2,s_{2,\\mathrm{naive}},s_{2,\\mathrm{kron}}],\\dots]$）。此问题不涉及任何物理单位或角度单位。\n\n提供清晰完整的代码，并遵守最终答案部分指定的执行环境。",
            "solution": "该问题要求推导并实现一种无矩阵算法，用于计算矩阵向量乘积 $y = A_{\\mathrm{SG}} x$，其中全局随机Galerkin (SG) 矩阵 $A_{\\mathrm{SG}}$ 具有克罗内克和结构。该推导依赖于克罗内克积和向量化算子的性质。\n\n全局SG矩阵表示为 $m$ 项之和：\n$$\nA_{\\mathrm{SG}} \\;=\\; \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r\n$$\n此处，$K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 是确定性空间矩阵，$G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 是随机系数矩阵，$\\otimes$ 表示克罗内克积。所得矩阵 $A_{\\mathrm{SG}}$ 的维度为 $(n_h n_p) \\times (n_h n_p)$。\n\n需要计算的矩阵向量乘积是 $y = A_{\\mathrm{SG}} x$。利用矩阵向量乘法的线性性质，我们可以将乘积分配到和式中：\n$$\ny \\;=\\; \\left( \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r \\right) x \\;=\\; \\sum_{r=0}^{m-1} (G_r \\,\\otimes\\, K_r) x\n$$\n此表达式表明，最终结果 $y$ 是将每一项 $(G_r \\otimes K_r)$ 应用于向量 $x$ 所得结果的总和。\n\n无矩阵方法的核心是避免构造大型的 $(n_h n_p) \\times (n_h n_p)$ 矩阵 $G_r \\otimes K_r$。为此，我们利用向量 $x$ 的结构。如前所述，SG解向量 $x$ 是通过堆叠每个随机基函数的物理自由度而形成的。这等价于一个矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$ 的列主序向量化，其中 $U$ 的列对应于随机基函数，行对应于物理自由度。我们可以将此关系写为 $x = \\mathrm{vec}(U)$。\n\n问题为适形矩阵 $A$、$X$ 和 $B$ 提供了以下恒等式：\n$$\n\\mathrm{vec}(A X B^\\top) \\;=\\; (B \\otimes A)\\,\\mathrm{vec}(X)\n$$\n我们可以将此恒等式应用于我们和式中的每一项，$(G_r \\otimes K_r) x = (G_r \\otimes K_r) \\mathrm{vec}(U)$。让我们匹配模式 $(B \\otimes A)\\,\\mathrm{vec}(X)$：\n- 令 $B = G_r$。\n- 令 $A = K_r$。\n- 令 $X = U$。\n\n将这些代入恒等式中得到：\n$$\n(G_r \\otimes K_r) \\mathrm{vec}(U) \\;=\\; \\mathrm{vec}(K_r U G_r^\\top)\n$$\n关键的洞见在于：大型克罗内克积矩阵 $(G_r \\otimes K_r)$ 对向量 $\\mathrm{vec}(U)$ 的作用，等价于执行更小的矩阵-矩阵乘法，然后将结果向量化。\n\n现在，我们将其代回 $y$ 的表达式中：\n$$\ny \\;=\\; \\sum_{r=0}^{m-1} \\mathrm{vec}(K_r U G_r^\\top)\n$$\n由于向量化算子 $\\mathrm{vec}(\\cdot)$ 是线性的，我们可以将其与求和符号交换位置：\n$$\ny \\;=\\; \\mathrm{vec}\\left(\\sum_{r=0}^{m-1} K_r U G_r^\\top\\right)\n$$\n这个最终方程为无矩阵算法提供了一个直接的方案：\n\n1.  **反向量化**：给定输入向量 $x \\in \\mathbb{R}^{n_h n_p}$，使用列主序将其重塑为矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$。\n2.  **累加**：初始化一个累加器矩阵 $Y_{\\mathrm{mat}} \\in \\mathbb{R}^{n_h \\times n_p}$，其所有元素均为零。然后，对于从 $0$ 到 $m-1$ 的每个 $r$，计算矩阵乘积 $K_r U G_r^\\top$ 并将其加到 $Y_{\\mathrm{mat}}$ 上。\n3.  **向量化**：循环完成后，使用列主序将最终矩阵 $Y_{\\mathrm{mat}}$ 向量化，以获得结果向量 $y \\in \\mathbb{R}^{n_h n_p}$。\n\n该算法避免了显式构造和存储 $(n_h n_p) \\times (n_h n_p)$ 矩阵 $A_{\\mathrm{SG}}$。相反，它仅需要存储较小的因子矩阵 $K_r$ 和 $G_r$，从而大大节省了内存，正如问题的内存复杂度公式所量化的那样。计算成本主要由 $m$ 次矩阵乘法迭代决定，这通常比与 $A_{\\mathrm{SG}}$ 进行单次大型矩阵向量乘积要高效得多。\n\n实现将遵循此推导出的算法。为了验证，结果将与使用显式形成的克罗内克积进行的直接计算进行比较。问题为构造矩阵 $K_r$ 和 $G_r$ 及输入向量 $x$ 提供了确定性规则，从而允许进行可复现的测试。内存成本使用所提供的公式计算：$s_{\\mathrm{naive}} = (n_h n_p)^2$ 和 $s_{\\mathrm{kron}} = m (n_h^2 + n_p^2)$。",
            "answer": "```python\nimport numpy as np\n\ndef build_K_matrices(nh, m):\n    \"\"\"Constructs the list of spatial matrices K_r.\"\"\"\n    Ks = []\n    # K_0\n    if nh == 1:\n        K0 = np.array([[2.0]])\n    else:\n        K0 = np.zeros((nh, nh))\n        np.fill_diagonal(K0, 2.0)\n        np.fill_diagonal(K0[1:], -1.0)\n        np.fill_diagonal(K0[:, 1:], -1.0)\n    Ks.append(K0)\n\n    # K_r for r > 0\n    for r in range(1, m):\n        Kr = np.zeros((nh, nh))\n        diag_val = 2.0 + r / float(max(1, nh))\n        if nh == 1:\n            Kr[0, 0] = diag_val\n        else:\n            off_diag_val = -1.0 / (r + 1.0)\n            np.fill_diagonal(Kr, diag_val)\n            np.fill_diagonal(Kr[1:], off_diag_val)\n            np.fill_diagonal(Kr[:, 1:], off_diag_val)\n        Ks.append(Kr)\n    return Ks\n\ndef build_G_matrices(np_, m):\n    \"\"\"Constructs the list of stochastic matrices G_r.\"\"\"\n    Gs = []\n    # G_0\n    G0 = np.identity(np_)\n    Gs.append(G0)\n\n    # G_r for r > 0\n    for r in range(1, m):\n        Gr = np.zeros((np_, np_))\n        if np_ > 1:\n            factor = 1.0 / (r + 1.0)\n            np.fill_diagonal(Gr[1:], factor)\n            np.fill_diagonal(Gr[:, 1:], factor)\n        Gs.append(Gr)\n    return Gs\n\ndef solve_case(nh, np_, m):\n    \"\"\"\n    Solves the problem for a single test case (nh, np, m).\n    \n    Returns a list containing [error, s_naive, s_kron].\n    \"\"\"\n    # 1. Construct matrices K_r and G_r\n    Ks = build_K_matrices(nh, m)\n    Gs = build_G_matrices(np_, m)\n\n    # 2. Construct input matrix U and vector x\n    # U_{i,j} = i + j/10 (1-based indices)\n    # Using 0-based numpy arrays: U[i,j] = (i+1) + (j+1)/10\n    i_indices = np.arange(1, nh + 1).reshape(nh, 1)\n    j_indices = np.arange(1, np_ + 1).reshape(1, np_)\n    U = i_indices + j_indices / 10.0\n    \n    # Vectorize U in column-major order ('F' for Fortran-style)\n    x = U.flatten(order='F')\n\n    # 3. Matrix-free application: y_matfree = vec(sum(K_r @ U @ G_r.T))\n    Y_mat = np.zeros((nh, np_))\n    for r in range(m):\n        Kr = Ks[r]\n        Gr_T = Gs[r].T\n        Y_mat += Kr @ U @ Gr_T\n    y_matfree = Y_mat.flatten(order='F')\n\n    # 4. Explicit application for verification: y_explicit = (sum(G_r kron K_r)) @ x\n    A_sg = np.zeros((nh * np_, nh * np_))\n    for r in range(m):\n        A_sg += np.kron(Gs[r], Ks[r])\n    y_explicit = A_sg @ x\n\n    # 5. Compute Euclidean norm of the difference\n    error = np.linalg.norm(y_explicit - y_matfree)\n\n    # 6. Compute memory scalar counts\n    s_naive = (nh * np_)**2\n    s_kron = m * (nh**2 + np_**2)\n\n    return [error, s_naive, s_kron]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 3, 3),  # General case\n        (5, 2, 2),  # Medium case\n        (3, 1, 2),  # Boundary case in stochastic dimension\n        (1, 4, 2),  # Boundary case in physical dimension\n    ]\n\n    results = []\n    for case in test_cases:\n        nh, np_, m = case\n        result = solve_case(nh, np_, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is desired.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}