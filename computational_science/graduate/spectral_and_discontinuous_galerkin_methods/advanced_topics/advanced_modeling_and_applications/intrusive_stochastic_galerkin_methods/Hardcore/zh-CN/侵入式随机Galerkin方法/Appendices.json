{
    "hands_on_practices": [
        {
            "introduction": "任何侵入式随机伽辽金方法的基础在于为随机空间选择一个合适的基。为了简化最终的伽辽金系统，使用一个相对于随机输入的概率测度是标准正交的基是极为有利的。本练习提供了推导所需归一化常数的基本实践，这些常数将一个标准正交多项式系统（如此处对应均匀不确定性的勒让德多项式）转换为一个标准正交系统 。",
            "id": "3392649",
            "problem": "考虑侵入式随机伽辽金方法，其中标量随机输入由一个均匀随机变量 $\\xi \\sim \\mathcal{U}(-1,1)$ 建模，其概率密度函数 (PDF) 为：当 $\\xi \\in [-1,1]$ 时，$\\rho(\\xi)=\\frac{1}{2}$；否则 $\\rho(\\xi)=0$。在伽辽金投影中，内积是关于 $\\rho$ 的期望 $\\mathbb{E}[\\cdot]$，因此对于任意平方可积函数 $f$ 和 $g$，内积定义为 $\\langle f, g \\rangle_{\\rho} := \\mathbb{E}[f(\\xi) g(\\xi)] = \\int_{-1}^{1} f(\\xi) g(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi$。由于经典勒让德多项式 $\\{P_n(\\xi)\\}_{n=0}^{\\infty}$ 在 $[-1,1]$ 上的均匀权重下具有正交性，因此选择它们作为多项式基。在许多侵入式随机伽辽金公式中，例如基于广义多项式混沌 (gPC) 的方法，要求基在 $\\langle \\cdot, \\cdot \\rangle_{\\rho}$ 下是标准正交的，以获得简化的代数结构。\n\n从上述基本定义出发，确定归一化常数 $c_n$，使得缩放后的基函数 $\\Psi_n(\\xi) := c_n P_n(\\xi)$ 在 $L^{2}_{\\rho}([-1,1])$ 中形成一个标准正交系，即 $\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 表示克罗内克δ。然后，使用相同的定义，验证期望值恒等式 $\\mathbb{E}[P_m(\\xi) P_n(\\xi)]$ 的闭式形式。您的最终答案必须是 $c_n$ 关于 $n$ 的闭式表达式；不需要数值近似，也不涉及任何单位。",
            "solution": "首先将对问题进行验证，以确保其科学和逻辑的完整性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 一个标量随机输入由一个均匀随机变量 $\\xi \\sim \\mathcal{U}(-1,1)$ 建模。\n- 概率密度函数 (PDF) 为：当 $\\xi \\in [-1,1]$ 时，$\\rho(\\xi)=\\frac{1}{2}$；否则 $\\rho(\\xi)=0$。\n- 对于平方可积函数 $f$ 和 $g$，内积定义为期望 $\\langle f, g \\rangle_{\\rho} := \\mathbb{E}[f(\\xi) g(\\xi)] = \\int_{-1}^{1} f(\\xi) g(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi$。\n- 多项式基是经典勒让德多项式集合 $\\{P_n(\\xi)\\}_{n=0}^{\\infty}$。\n- 缩放后的基函数为 $\\Psi_n(\\xi) := c_n P_n(\\xi)$，其中 $c_n$ 是归一化常数。\n- 标准正交性条件为 $\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}$，其中 $\\delta_{mn}$ 是克罗内克δ。\n\n**步骤2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学基础**：该问题深植于不确定性量化的数学理论，特别是使用侵入式伽辽金方法的广义多项式混沌 (gPC) 展开。将勒让德多项式用作均匀随机变量的正交基是 Askey 格式的一个标准且正确的应用。所有定义和性质均与该领域的既有文献一致。\n- **适定性**：该问题是适定的。它要求基于一套清晰完整的定义来确定归一化常数 $c_n$，这会导出一个唯一的解（通常约定 $c_n > 0$）。\n- **客观性**：该问题使用精确客观的数学语言陈述，没有任何主观性或模糊性。\n- **完整性**：该问题提供了所有必要信息：概率分布、内积的定义、基多项式和标准正交性条件。它是自洽的。\n- **一致性**：内部没有矛盾。这些定义是标准的且相互兼容。\n\n**步骤3：结论与行动**\n问题有效。它是不确定性量化谱方法背景下的一个标准且定义明确的数学练习。将提供完整解答。\n\n**解题推导**\n\n目标是找到归一化常数 $c_n$，使得基函数 $\\Psi_n(\\xi) = c_n P_n(\\xi)$ 关于由期望算子 $\\mathbb{E}[\\cdot]$ 定义的内积是标准正交的。标准正交性条件为：\n$$\n\\mathbb{E}[\\Psi_m(\\xi)\\Psi_n(\\xi)] = \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克δ，当 $m=n$ 时为 $1$，当 $m \\neq n$ 时为 $0$。\n\n将 $\\Psi_n(\\xi)$ 的定义代入条件中，我们得到：\n$$\n\\mathbb{E}[ (c_m P_m(\\xi)) (c_n P_n(\\xi)) ] = \\delta_{mn}\n$$\n由于 $c_m$ 和 $c_n$ 是确定性常数，它们可以从期望中提取出来：\n$$\nc_m c_n \\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\delta_{mn}\n$$\n接下来，我们使用期望项 $\\mathbb{E}[P_m(\\xi) P_n(\\xi)]$ 关于概率密度函数 $\\rho(\\xi)$ 的定义来计算它。随机变量 $\\xi$ 在 $[-1, 1]$ 上均匀分布，所以其 PDF 为 $\\rho(\\xi) = \\frac{1}{2}$（对于 $\\xi \\in [-1, 1]$）。\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\int_{-\\infty}^{\\infty} P_m(\\xi) P_n(\\xi) \\rho(\\xi) \\, \\mathrm{d}\\xi = \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\left(\\frac{1}{2}\\right) \\, \\mathrm{d}\\xi\n$$\n提出常数 $\\frac{1}{2}$：\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\frac{1}{2} \\int_{-1}^{1} P_m(\\xi) P_n(\\xi) \\, \\mathrm{d}\\xi\n$$\n该表达式构成了问题中要求的期望值恒等式的验证。为了以闭式形式计算它，我们使用勒让德多项式的标准正交性质，即：\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) \\, \\mathrm{d}x = \\frac{2}{2n+1} \\delta_{mn}\n$$\n将此已知结果代入我们的期望表达式中，得到闭式恒等式：\n$$\n\\mathbb{E}[P_m(\\xi) P_n(\\xi)] = \\frac{1}{2} \\left( \\frac{2}{2n+1} \\delta_{mn} \\right) = \\frac{1}{2n+1} \\delta_{mn}\n$$\n现在，我们将此结果代回缩放基 $\\Psi_n(\\xi)$ 的标准正交性条件中：\n$$\nc_m c_n \\left( \\frac{1}{2n+1} \\delta_{mn} \\right) = \\delta_{mn}\n$$\n为了找到常数 $c_n$，我们考虑 $m = n$ 的情况。在这种情况下，$\\delta_{nn} = 1$：\n$$\nc_n c_n \\left( \\frac{1}{2n+1} \\delta_{nn} \\right) = \\delta_{nn} \\implies c_n^2 \\left( \\frac{1}{2n+1} \\right) = 1\n$$\n求解 $c_n^2$：\n$$\nc_n^2 = 2n+1\n$$\n按照惯例，归一化常数取正平方根。因此：\n$$\nc_n = \\sqrt{2n+1}\n$$\n对于 $m \\neq n$ 的情况，正交性质确保 $\\delta_{mn} = 0$，得出 $0 = 0$ 的恒等式，这是自洽的。\n\n因此，标准正交基函数为 $\\Psi_n(\\xi) = \\sqrt{2n+1} P_n(\\xi)$。归一化常数 $c_n$ 仅取决于多项式的次数 $n$。",
            "answer": "$$\n\\boxed{\\sqrt{2n+1}}\n$$"
        },
        {
            "introduction": "当我们将控制微分方程投影到我们的随机基上时，会得到一个大型的耦合代数系统。理解该系统矩阵的结构是评估该方法计算成本的关键。本练习探讨了问题系数中的仿射参数依赖性，结合多项式基的递推性质，如何产生一个高度稀疏、结构化的全局矩阵，而非一个稠密矩阵 。",
            "id": "3392692",
            "problem": "考虑一个空间离散的标量椭圆模型问题，其采用空间不连续伽辽金 (DG) 方法和侵入式随机伽辽金 (SG) 离散化。不确定系数由两个独立的随机变量 $\\xi_{1}$ 和 $\\xi_{2}$ 建模，每个变量都在 $[-1,1]$ 上均匀分布，并由仿射参数化 $a(x,\\xi) = a_{0}(x) + a_{1}(x)\\,\\xi_{1} + a_{2}(x)\\,\\xi_{2}$ 给出，其中 $a_{0}(x)$、$a_{1}(x)$ 和 $a_{2}(x)$ 是确定性系数场，$x$ 表示空间坐标。SG 方法使用一个多元 Legendre 多项式混沌基，该基相对于 $[-1,1]^{2}$ 上的乘积测度是标准正交的，并在随机维度 $d=2$ 中截断至总多项式次数 $p=2$。令多重指标集为\n$$\n\\mathcal{I}_{2} \\equiv \\{ \\alpha \\in \\mathbb{N}_{0}^{2} : \\alpha_{1} + \\alpha_{2} \\leq 2 \\},\n$$\n并定义多元基函数 $\\psi_{\\alpha}(\\xi) = L_{\\alpha_{1}}(\\xi_{1})\\,L_{\\alpha_{2}}(\\xi_{2})$，其中 $L_{n}$ 表示 $[-1,1]$ 上的 $n$ 次标准正交 Legendre 多项式。\n\n全局 SG 系统矩阵根据由 $\\alpha,\\beta \\in \\mathcal{I}_{2}$ 索引的随机模式进行分块，从而得到一个 $\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$ 的分块矩阵。每个分块 $(\\alpha,\\beta)$ 是一个空间 DG 矩阵乘以一个随机矩\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,q(\\xi)\\,\\mathrm{d}\\mu(\\xi),\n$$\n对于分别由 $a_{0}(x)$、$a_{1}(x)$ 和 $a_{2}(x)$ 产生的 $q(\\xi) \\in \\{1,\\xi_{1},\\xi_{2}\\}$，且 $\\mathrm{d}\\mu(\\xi)$ 是均匀乘积测度。仅使用标准正交 Legendre 多项式的基本性质及其三项递推关系，通过精确确定哪些 $(\\alpha,\\beta)$ 对会产生非零块，来构建在给定 $a(x,\\xi)$、 $d=2$ 和 $p=2$ 条件下的全局 SG 分块矩阵的稀疏模式。然后，计算该 $\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$ 分块矩阵中非零块的总数。\n\n请以单个整数的形式提供最终答案。无需四舍五入。",
            "solution": "我们从使用标准正交多项式混沌基的侵入式随机伽辽金 (SG) 方法的基本定义开始。多元基函数是作为一维标准正交 Legendre 多项式的张量积构建的，其标准正交性意味着\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\mathrm{d}\\mu(\\xi) = \\delta_{\\alpha\\beta},\n$$\n其中 $\\delta_{\\alpha\\beta}$ 是克罗内克 δ 符号，$\\mathrm{d}\\mu(\\xi)$ 表示均匀乘积测度。\n\n系数 $a(x,\\xi) = a_{0}(x) + a_{1}(x)\\,\\xi_{1} + a_{2}(x)\\,\\xi_{2}$ 对全局 SG 矩阵产生三种贡献。对于常数项 $q(\\xi)=1$，标准正交性只产生对角线上的随机耦合：\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\mathrm{d}\\mu(\\xi) = \\delta_{\\alpha\\beta}.\n$$\n因此，$a_{0}(x)$ 的贡献只在对角线 $(\\alpha,\\alpha)$ 上产生非零块。\n\n对于线性项 $q(\\xi)=\\xi_{1}$ 和 $q(\\xi)=\\xi_{2}$，非零耦合由 Legendre 多项式的三项递推关系确定。对于 $[-1,1]$ 上的标准正交 Legendre 多项式 $\\{L_{n}\\}_{n\\geq 0}$，标准递推关系意味着\n$$\n\\xi\\,L_{n}(\\xi) = c_{n+1}\\,L_{n+1}(\\xi) + c_{n-1}\\,L_{n-1}(\\xi),\n$$\n其中对于所有有效的索引 $n\\geq 0$，系数 $c_{n\\pm 1}$ 均为非零。因此，一维三项乘积\n$$\n\\int_{-1}^{1} L_{m}(\\xi)\\,\\xi\\,L_{n}(\\xi)\\,\\mathrm{d}\\xi\n$$\n非零当且仅当 $m = n \\pm 1$，否则为零（根据奇偶性和正交性，包括 $m=n$ 的情况）。在多维情况下，可分离性给出\n$$\n\\int_{[-1,1]^{2}} \\psi_{\\alpha}(\\xi)\\,\\psi_{\\beta}(\\xi)\\,\\xi_{i}\\,\\mathrm{d}\\mu(\\xi)\n= \\left( \\int_{-1}^{1} L_{\\alpha_{i}}(\\xi_{i})\\,\\xi_{i}\\,L_{\\beta_{i}}(\\xi_{i})\\,\\mathrm{d}\\xi_{i} \\right)\n\\prod_{j\\neq i} \\left( \\int_{-1}^{1} L_{\\alpha_{j}}(\\xi_{j})\\,L_{\\beta_{j}}(\\xi_{j})\\,\\mathrm{d}\\xi_{j} \\right).\n$$\n因此，这个多元积分非零当且仅当：\n- 对于所有 $j \\neq i$，$\\beta_{j} = \\alpha_{j}$（根据未受影响维度的标准正交性），以及\n- $\\beta_{i} = \\alpha_{i} \\pm 1$（根据一维递推选择规则）。\n\n因此，由 $q(\\xi)=\\xi_{i}$ 引起的随机耦合连接了在分量 $i$ 上恰好相差 1 且在其他分量上相等的多重指标。\n\n我们现在列举出 $d=2$ 和总次数 $p=2$ 的截断多重指标集：\n$$\n\\mathcal{I}_{2} = \\{ (0,0),\\, (1,0),\\, (0,1),\\, (2,0),\\, (1,1),\\, (0,2) \\}.\n$$\n共有 $\\lvert \\mathcal{I}_{2} \\rvert = \\binom{d+p}{p} = \\binom{4}{2} = 6$ 个随机模式。\n\n我们通过列出所有使分块非零的对 $(\\alpha,\\beta)$ 来构建稀疏模式。\n\n1. 常数项 $q(\\xi)=1$（$a_{0}(x)$ 的贡献）：\n- 仅当 $\\beta=\\alpha$ 时非零。这在对角线上产生 6 个非零块：$(0,0)$、$(1,0)$、$(0,1)$、$(2,0)$、$(1,1)$、$(0,2)$。\n\n2. 线性项 $q(\\xi)=\\xi_{1}$（$a_{1}(x)$ 的贡献）：\n- 当 $\\beta = \\alpha \\pm (1,0)$ 且该对仍在 $\\mathcal{I}_{2}$ 内时非零。\n- 在 $\\pm(1,0)$ 操作下，$\\mathcal{I}_{2}$ 中有效的无序相邻对为：\n$$\n(0,0)\\text{–}(1,0),\\quad (1,0)\\text{–}(2,0),\\quad (0,1)\\text{–}(1,1).\n$$\n这是 3 条无向边，对应于完整分块矩阵中的 6 个非对角线块位置，因为每条无向边产生两个有向对 $(\\alpha,\\beta)$ 和 $(\\beta,\\alpha)$。\n\n3. 线性项 $q(\\xi)=\\xi_{2}$（$a_{2}(x)$ 的贡献）：\n- 当 $\\beta = \\alpha \\pm (0,1)$ 且该对仍在 $\\mathcal{I}_{2}$ 内时非零。\n- 在 $\\pm(0,1)$ 操作下，$\\mathcal{I}_{2}$ 中有效的无序相邻对为：\n$$\n(0,0)\\text{–}(0,1),\\quad (0,1)\\text{–}(0,2),\\quad (1,0)\\text{–}(1,1).\n$$\n这也是 3 条无向边，同样产生 6 个非对角线块位置。\n\n没有任何一对同时出现在 $\\xi_{1}$ 和 $\\xi_{2}$ 的列表中，因为选择规则要求恰好一个坐标变化 $\\pm 1$，而这两个坐标是不同的。\n\n最后，$\\lvert \\mathcal{I}_{2} \\rvert \\times \\lvert \\mathcal{I}_{2} \\rvert$ 分块矩阵中非零块的总数是来自 $a_{0}(x)$ 的对角线块和来自线性项的非对角线块之和：\n$$\n6 \\text{ (对角线)} + 6 \\text{ (来自 } \\xi_{1}\\text{ 的非对角线)} + 6 \\text{ (来自 } \\xi_{2}\\text{ 的非对角线)} = 18.\n$$\n因此，全局 SG 分块矩阵有 18 个非零块。",
            "answer": "$$\\boxed{18}$$"
        },
        {
            "introduction": "对于许多问题，全局随机伽辽金矩阵呈现出一种强大的克罗内克和（Kronecker-sum）结构，这是分离空间变量和随机变量的直接结果。显式地构建这个维度为 $(n_h n_p) \\times (n_h n_p)$ 的大型矩阵通常由于内存限制而在计算上是不可行的。这个高级动手练习挑战你实现一种“无矩阵”算法，利用这种克罗内克结构高效地执行矩阵向量乘法，这是解决实际大规模问题的关键技术 。",
            "id": "3392640",
            "problem": "考虑一个具有仿射随机系数的线性椭圆模型问题的侵入式随机 Galerkin (SG) 离散，该问题在一个维度为 $n_h$ 的有限维物理试探空间 $V_h$ 中使用谱或间断 Galerkin 空间离散进行离散，并在一个维度为 $n_p$ 的多项式混沌展开 (PCE) 基中对随机空间进行离散。在参数仿射假设下，全局 SG 矩阵 $A_{\\mathrm{SG}}$ 具有克罗内克和结构\n$$\nA_{\\mathrm{SG}} \\;=\\; \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r,\n$$\n其中 $K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 是从 $V_h$ 导出的确定性空间矩阵（例如，来自谱或间断 Galerkin 公式的类刚度矩阵），$G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 是由 PCE 内积构成的随机系数矩阵。符号 $\\otimes$ 表示克罗内克积。未知的 SG 系数向量是通过将每个随机基函数的物理自由度堆叠成一个长度为 $n_h n_p$ 的单一向量而获得的。\n\n从克罗内克积和向量化算子的基本性质出发（特别是对于尺寸相容的矩阵 $A$、$X$ 和 $B$ 的恒等式\n$$\n\\mathrm{vec}(A X B^\\top) \\;=\\; (B \\otimes A)\\,\\mathrm{vec}(X),\n$$\n），推导并实现一个算法，该算法将 $A_{\\mathrm{SG}}$ 应用于一个向量，而无需显式构造 $A_{\\mathrm{SG}}$。您的实现必须利用克罗内克结构来避免形成稠密块，并且对于任意输入参数 $n_h$、$n_p$ 和 $m$ 都必须是正确的。\n\n为了测试和可复现性，在您的程序中按如下方式确定性地构造 $K_r$ 和 $G_r$：\n- 对于每个测试用例，设 $n_h \\geq 1$、$n_p \\geq 1$ 和 $m \\geq 1$ 为给定的整数。\n- 定义 $K_0 \\in \\mathbb{R}^{n_h \\times n_h}$ 为三对角矩阵，其对角线元素为 $2$，次对角线和超对角线元素为 $-1$。当 $n_h=1$ 时，这简化为标量 $2$。\n- 对于每个 $r \\in \\{1,\\dots,m-1\\}$，定义 $K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 为三对角矩阵，其对角线元素为 $2 + \\frac{r}{\\max(1,n_h)}$，次对角线和超对角线元素为 $-\\frac{1}{r+1}$（三对角线外的元素为 $0$）。\n- 定义 $G_0 \\in \\mathbb{R}^{n_p \\times n_p}$ 为大小为 $n_p$ 的单位矩阵。\n- 对于每个 $r \\in \\{1,\\dots,m-1\\}$，定义 $G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 为 $\\frac{1}{r+1}$ 乘以一个对称的离对角邻接矩阵，该矩阵在第一条次对角线和超对角线上为 $1$，其他地方为 $0$。具体来说，如果 $|i-j|=1$，则 $(G_r)_{i,j} = \\frac{1}{r+1}$，否则为 $0$。当 $n_p=1$ 时，对于 $r\\geq 1$，$G_r$ 是 $1\\times 1$ 的零矩阵。\n\n为了验证正确性，令 $x \\in \\mathbb{R}^{n_h n_p}$ 为矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$ 的向量化（按列主序），其中 $U_{i,j} = i + \\frac{j}{10}$（使用基于 1 的索引，以使元素为严格正数且可复现）。将您的无矩阵克罗内克应用算法的结果与显式乘积 $A_{\\mathrm{SG}} x$ 进行比较，其中 $A_{\\mathrm{SG}}$ 是通过克罗内克积的求和形成的；报告两者之差的欧几里得范数。\n\n根据必须存储的标量数量，估算两种方法的内存复杂度：\n- 朴素的显式组装，稠密存储 $A_{\\mathrm{SG}}$：需要 $(n_h n_p)^2$ 个标量。\n- 克罗内克因子存储，存储所有 $K_r$ 和 $G_r$ 但从不形成 $A_{\\mathrm{SG}}$：需要 $m \\,(n_h^2 + n_p^2)$ 个标量。\n\n您的程序必须：\n- 使用克罗内克恒等式实现 $A_{\\mathrm{SG}}$ 的无矩阵应用，注意在向量和矩阵之间重塑时要一致地使用列主序向量化。\n- 通过克罗内克积构造显式的 $A_{\\mathrm{SG}}$，并通过计算两种应用结果之间差的欧几里得范数来验证无矩阵实现。\n- 计算并报告上述两种内存标量计数。\n- 使用以下参数元组的测试套件 $(n_h,n_p,m)$：\n    1. $(4,3,3)$ 作为一般情况，\n    2. $(5,2,2)$ 作为中等情况，\n    3. $(3,1,2)$ 作为随机维度上的边界情况，\n    4. $(1,4,2)$ 作为物理维度上的边界情况。\n- 对于每个测试用例，生成一个三元素列表 $[e, s_{\\mathrm{naive}}, s_{\\mathrm{kron}}]$，其中 $e$ 是显式乘积和无矩阵乘积之间差的欧几里得范数（一个浮点数），$s_{\\mathrm{naive}}$ 是朴素显式存储的整数标量计数，而 $s_{\\mathrm{kron}}$ 是克罗内克因子存储的整数标量计数。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个包含在方括号中的逗号分隔列表，其中每个元素本身都是一个如上指定的三元素列表（例如，$[[e_1,s_{1,\\mathrm{naive}},s_{1,\\mathrm{kron}}],[e_2,s_{2,\\mathrm{naive}},s_{2,\\mathrm{kron}}],\\dots]$）。本问题不涉及任何物理单位或角度单位。\n\n提供清晰完整的代码，并遵循最终答案部分中指定的执行环境。",
            "solution": "该问题要求推导并实现一个无矩阵算法来计算矩阵向量乘积 $y = A_{\\mathrm{SG}} x$，其中全局随机 Galerkin (SG) 矩阵 $A_{\\mathrm{SG}}$ 具有克罗内克和结构。推导过程依赖于克罗内克积和向量化算子的性质。\n\n全局 SG 矩阵表示为 $m$ 项之和：\n$$\nA_{\\mathrm{SG}} \\;=\\; \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r\n$$\n这里，$K_r \\in \\mathbb{R}^{n_h \\times n_h}$ 是确定性空间矩阵，$G_r \\in \\mathbb{R}^{n_p \\times n_p}$ 是随机系数矩阵，而 $\\otimes$ 表示克罗内克积。结果矩阵 $A_{\\mathrm{SG}}$ 的维度是 $(n_h n_p) \\times (n_h n_p)$。\n\n需要计算的矩阵向量乘积是 $y = A_{\\mathrm{SG}} x$。利用矩阵向量乘法的线性性质，我们可以将乘积分配到和上：\n$$\ny \\;=\\; \\left( \\sum_{r=0}^{m-1} G_r \\,\\otimes\\, K_r \\right) x \\;=\\; \\sum_{r=0}^{m-1} (G_r \\,\\otimes\\, K_r) x\n$$\n该表达式表明，最终结果 $y$ 是将每一项 $(G_r \\otimes K_r)$ 应用于向量 $x$ 所得结果的总和。\n\n无矩阵方法的核心是避免构造大的 $(n_h n_p) \\times (n_h n_p)$ 矩阵 $G_r \\otimes K_r$。为此，我们利用向量 $x$ 的结构。如题目所述，SG 解向量 $x$ 是通过堆叠每个随机基函数的物理自由度而形成的。这等价于对一个矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$ 进行列主序向量化，其中 $U$ 的列对应于随机基函数，行对应于物理自由度。我们可以将此关系写为 $x = \\mathrm{vec}(U)$。\n\n问题提供了以下适用于尺寸相容的矩阵 $A$、$X$ 和 $B$ 的恒等式：\n$$\n\\mathrm{vec}(A X B^\\top) \\;=\\; (B \\otimes A)\\,\\mathrm{vec}(X)\n$$\n我们可以将此恒等式应用于我们和中的每一项，$(G_r \\otimes K_r) x = (G_r \\otimes K_r) \\mathrm{vec}(U)$。让我们匹配模式 $(B \\otimes A)\\,\\mathrm{vec}(X)$：\n- 令 $B = G_r$。\n- 令 $A = K_r$。\n- 令 $X = U$。\n\n将这些代入恒等式，得到：\n$$\n(G_r \\otimes K_r) \\mathrm{vec}(U) \\;=\\; \\mathrm{vec}(K_r U G_r^\\top)\n$$\n这是关键的洞察：大的克罗内克积矩阵 $(G_r \\otimes K_r)$ 作用于向量 $\\mathrm{vec}(U)$ 的效果，等价于执行较小的矩阵-矩阵乘法，然后将结果向量化。\n\n现在，我们将此代回到 $y$ 的表达式中：\n$$\ny \\;=\\; \\sum_{r=0}^{m-1} \\mathrm{vec}(K_r U G_r^\\top)\n$$\n由于向量化算子 $\\mathrm{vec}(\\cdot)$ 是线性的，我们可以将其与求和交换位置：\n$$\ny \\;=\\; \\mathrm{vec}\\left(\\sum_{r=0}^{m-1} K_r U G_r^\\top\\right)\n$$\n这个最终方程为无矩阵算法提供了一个直接的方案：\n\n1.  **反向量化**：给定输入向量 $x \\in \\mathbb{R}^{n_h n_p}$，使用列主序将其重塑为矩阵 $U \\in \\mathbb{R}^{n_h \\times n_p}$。\n2.  **累加**：初始化一个累加器矩阵 $Y_{\\mathrm{mat}} \\in \\mathbb{R}^{n_h \\times n_p}$ 为全零。然后，对于从 $0$ 到 $m-1$ 的每个 $r$，计算矩阵乘积 $K_r U G_r^\\top$ 并将其加到 $Y_{\\mathrm{mat}}$ 上。\n3.  **向量化**：循环完成后，使用列主序将最终矩阵 $Y_{\\mathrm{mat}}$ 向量化，以获得结果向量 $y \\in \\mathbb{R}^{n_h n_p}$。\n\n该算法避免了 $(n_h n_p) \\times (n_h n_p)$ 矩阵 $A_{\\mathrm{SG}}$ 的显式构造和存储。相反，它只需要存储较小的因子矩阵 $K_r$ 和 $G_r$，从而大大节省了内存，正如问题的内存复杂度公式所量化的那样。计算成本主要由 $m$ 次矩阵乘法迭代主导，这通常比与 $A_{\\mathrm{SG}}$ 进行单次大的矩阵向量乘积要高效得多。\n\n实现将遵循这个推导出的算法。为了验证，结果将与使用显式形成的克罗内克积的直接计算进行比较。问题为构造矩阵 $K_r$ 和 $G_r$以及输入向量 $x$ 提供了确定性规则，从而可以进行可复现的测试。内存成本使用提供的公式计算：$s_{\\mathrm{naive}} = (n_h n_p)^2$ 和 $s_{\\mathrm{kron}} = m (n_h^2 + n_p^2)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_K_matrices(nh, m):\n    \"\"\"Constructs the list of spatial matrices K_r.\"\"\"\n    Ks = []\n    # K_0\n    if nh == 1:\n        K0 = np.array([[2.0]])\n    else:\n        K0 = np.zeros((nh, nh))\n        np.fill_diagonal(K0, 2.0)\n        np.fill_diagonal(K0[1:], -1.0)\n        np.fill_diagonal(K0[:, 1:], -1.0)\n    Ks.append(K0)\n\n    # K_r for r > 0\n    for r in range(1, m):\n        Kr = np.zeros((nh, nh))\n        diag_val = 2.0 + r / float(max(1, nh))\n        if nh == 1:\n            Kr[0, 0] = diag_val\n        else:\n            off_diag_val = -1.0 / (r + 1.0)\n            np.fill_diagonal(Kr, diag_val)\n            np.fill_diagonal(Kr[1:], off_diag_val)\n            np.fill_diagonal(Kr[:, 1:], off_diag_val)\n        Ks.append(Kr)\n    return Ks\n\ndef build_G_matrices(np_, m):\n    \"\"\"Constructs the list of stochastic matrices G_r.\"\"\"\n    Gs = []\n    # G_0\n    G0 = np.identity(np_)\n    Gs.append(G0)\n\n    # G_r for r > 0\n    for r in range(1, m):\n        Gr = np.zeros((np_, np_))\n        if np_ > 1:\n            factor = 1.0 / (r + 1.0)\n            np.fill_diagonal(Gr[1:], factor)\n            np.fill_diagonal(Gr[:, 1:], factor)\n        Gs.append(Gr)\n    return Gs\n\ndef solve_case(nh, np_, m):\n    \"\"\"\n    Solves the problem for a single test case (nh, np, m).\n    \n    Returns a list containing [error, s_naive, s_kron].\n    \"\"\"\n    # 1. Construct matrices K_r and G_r\n    Ks = build_K_matrices(nh, m)\n    Gs = build_G_matrices(np_, m)\n\n    # 2. Construct input matrix U and vector x\n    # U_{i,j} = i + j/10 (1-based indices)\n    # Using 0-based numpy arrays: U[i,j] = (i+1) + (j+1)/10\n    i_indices = np.arange(1, nh + 1).reshape(nh, 1)\n    j_indices = np.arange(1, np_ + 1).reshape(1, np_)\n    U = i_indices + j_indices / 10.0\n    \n    # Vectorize U in column-major order ('F' for Fortran-style)\n    x = U.flatten(order='F')\n\n    # 3. Matrix-free application: y_matfree = vec(sum(K_r @ U @ G_r.T))\n    Y_mat = np.zeros((nh, np_))\n    for r in range(m):\n        Kr = Ks[r]\n        Gr_T = Gs[r].T\n        Y_mat += Kr @ U @ Gr_T\n    y_matfree = Y_mat.flatten(order='F')\n\n    # 4. Explicit application for verification: y_explicit = (sum(G_r kron K_r)) @ x\n    A_sg = np.zeros((nh * np_, nh * np_))\n    for r in range(m):\n        A_sg += np.kron(Gs[r], Ks[r])\n    y_explicit = A_sg @ x\n\n    # 5. Compute Euclidean norm of the difference\n    error = np.linalg.norm(y_explicit - y_matfree)\n\n    # 6. Compute memory scalar counts\n    s_naive = (nh * np_)**2\n    s_kron = m * (nh**2 + np_**2)\n\n    return [error, s_naive, s_kron]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 3, 3),  # General case\n        (5, 2, 2),  # Medium case\n        (3, 1, 2),  # Boundary case in stochastic dimension\n        (1, 4, 2),  # Boundary case in physical dimension\n    ]\n\n    results = []\n    for case in test_cases:\n        nh, np_, m = case\n        result = solve_case(nh, np_, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is desired.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}