{
    "hands_on_practices": [
        {
            "introduction": "局部时间步进 (LTS) 的核心思想是让时间步长适应局部网格尺寸，以克服全局统一时间步长的限制。本练习提供了一个具体的起点，要求你基于给定的稳定性准则，为不同尺寸的单元计算最大稳定局部时间步长。通过这个实践，你将巩固对单元尺寸$h_K$、多项式次数$p$和允许时间步长$\\Delta t_K$之间基本关系的理解。",
            "id": "3396758",
            "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其定义在一个非均匀网格上。该网格由三个单元组成，尺寸分别为 $h_{1} = 1$、$h_{2} = 1/2$ 和 $h_{3} = 1/4$。空间离散化采用间断Galerkin (DG) 方法，每个单元上的多项式次数为 $p = 2$，并使用迎风数值通量。时间积分采用3阶强稳定保持龙格-库塔方法 (Strong Stability Preserving (SSP)–Runge–Kutta (RK3))。假设平流速度为 $a = 1$，并且计算是无量纲的，因此时间报告不带物理单位。\n\n设 $\\Delta t_{K}$ 表示在局部时间步长策略下，单元 $K$ 上的最大稳定局部时间步长。从线性系统显式时间积分的稳定性要求和迎风通量下谱半径的标准DG估计出发，推导 $\\Delta t_{K}$ 对 $h_{K}$、$a$ 和 $p$ 的函数依赖关系，仅使用以下假设：存在一个稳定性常数 $C(p)$，使得前向欧拉稳定时间步长满足 $\\Delta t_{\\mathrm{FE},K} \\le C(p)\\,h_{K}/|a|$，其中 $C(p) = 1/(2p+1)$。然后，考虑SSP–RK3方法，计算给定网格的三个局部时间步长 $\\Delta t_{1}$、$\\Delta t_{2}$ 和 $\\Delta t_{3}$。\n\n将每个 $\\Delta t_{K}$ 表示为精确分数；不要四舍五入或小数化。以行向量 $\\bigl[\\Delta t_{1},\\Delta t_{2},\\Delta t_{3}\\bigr]$ 的形式给出最终答案。",
            "solution": "用户要求我解决一个关于线性平流方程的间断Galerkin (DG) 离散化的局部时间步长问题的数值分析题。首先，我必须验证问题陈述。\n\n### 步骤1：提取已知条件\n- **控制方程**：一维线性平流方程，$u_{t} + a\\,u_{x} = 0$。\n- **平流速度**：$a = 1$。\n- **网格**：一个由三个单元组成的非均匀网格，尺寸分别为 $h_{1} = 1$，$h_{2} = 1/2$ 和 $h_{3} = 1/4$。\n- **空间离散化**：间断Galerkin (DG) 方法，每个单元上的多项式次数为 $p = 2$。\n- **数值通量**：迎风通量。\n- **时间积分**：3阶强稳定保持龙格-库塔方法 (SSP–RK3)。\n- **稳定性假设**：单元 $K$ 的前向欧拉稳定时间步长由 $\\Delta t_{\\mathrm{FE},K} \\le C(p)\\,h_{K}/|a|$ 给出。\n- **稳定性常数**：函数 $C(p)$ 定义为 $C(p) = 1/(2p+1)$。\n- **目标**：计算三个最大稳定局部时间步长 $\\Delta t_{1}$、$\\Delta t_{2}$ 和 $\\Delta t_{3}$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据既定标准对问题进行验证。\n- **科学依据**：该问题在偏微分方程数值方法的既定理论中有充分的依据。DG方法、SSP时间积分器和Courant-Friedrichs-Lewy (CFL) 稳定性条件都是计算科学与工程中的标准概念。所提供的稳定性估计 $\\Delta t_{\\mathrm{FE},K} \\le \\frac{h_K}{(2p+1)|a|}$ 是对于使用DG和迎风通量离散化的一维线性平流方程的一个已知结果。\n- **适定性**：该问题是适定的。它提供了所有必要的参数（$a$、$p$、$h_K$）和定义（具体的时间积分器和基本稳定性条件），以确定局部时间步长的唯一解。\n- **客观性**：该问题以精确、客观、无歧义的数学术语陈述。\n- **缺陷清单**：该问题没有违反任何指定的无效标准。它在科学上是合理的、可形式化的、完整的、现实的且结构良好。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n使用间断Galerkin方法对偏微分方程 $u_{t} + a\\,u_{x} = 0$ 进行半离散化，会得到一个关于每个单元上自由度的常微分方程组 (ODEs)。该系统可以抽象地写为 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}_h(\\mathbf{u})$，其中 $\\mathbf{L}_h$ 是空间离散化算子。为了使显式时间积分格式稳定，所选择的时间步长 $\\Delta t$ 必须满足：$\\Delta t$ 乘以 $\\mathbf{L}_h$ 的谱半径的值落在时间积分器的稳定区域内。\n\n问题给出了最简单的显式时间积分器——前向欧拉 (FE) 方法的稳定性约束。对于网格中的单元 $K$，FE方法下的最大稳定时间步长为：\n$$ \\Delta t_{\\mathrm{FE},K}^{\\max} = C(p)\\,\\frac{h_{K}}{|a|} $$\n使用给定的定义 $C(p) = 1/(2p+1)$，这变为：\n$$ \\Delta t_{\\mathrm{FE},K}^{\\max} = \\frac{1}{2p+1} \\frac{h_{K}}{|a|} $$\n这是CFL条件的一种形式，特定于DG离散化。\n\n问题指定使用3阶强稳定保持龙格-库塔方法 (SSP-RK3)。SSP方法的设计宗旨是，对于一个给定的ODE系统，只要时间步长 $\\Delta t$ 对前向欧拉方法是稳定的，那么该系统在该时间步长乘以一个称为SSP系数 $c$ 的因子后仍然保持稳定。SSP方法的稳定性条件是：\n$$ \\Delta t \\le c \\cdot \\Delta t_{\\mathrm{FE}}^{\\max} $$\n具体的方法SSP-RK3，指的是由 Shu 和 Osher 开发的流行的三阶三步格式。该方法的一个基本且决定性的特性是其SSP系数为 $c=1$。因此，对于这种方法，最大稳定时间步长与最大稳定前向欧拉时间步长相同。\n\n设 $\\Delta t_K$ 为使用SSP-RK3积分器在单元 $K$ 上的最大稳定局部时间步长。我们可以写出：\n$$ \\Delta t_{K} = c_{\\mathrm{SSP-RK3}} \\cdot \\Delta t_{\\mathrm{FE},K}^{\\max} $$\n由于 $c_{\\mathrm{SSP-RK3}} = 1$，我们有：\n$$ \\Delta t_{K} = \\Delta t_{\\mathrm{FE},K}^{\\max} = \\frac{1}{2p+1} \\frac{h_{K}}{|a|} $$\n这个表达式给出了局部时间步长 $\\Delta t_K$ 对单元尺寸 $h_K$、平流速度 $a$ 和多项式次数 $p$ 的函数依赖关系。\n\n现在，我们可以代入问题陈述中给出的具体值：\n- 多项式次数：$p = 2$\n- 平流速度：$a = 1$\n\n首先，我们计算 $\\Delta t_K$ 表达式中的常数因子：\n$$ \\frac{1}{(2p+1)|a|} = \\frac{1}{(2(2)+1)|1|} = \\frac{1}{4+1} = \\frac{1}{5} $$\n因此，局部时间步长的公式简化为：\n$$ \\Delta t_{K} = \\frac{h_{K}}{5} $$\n\n我们现在将此公式应用于三个单元，使用它们指定的尺寸：\n- 对于单元1，其尺寸 $h_{1} = 1$：\n$$ \\Delta t_{1} = \\frac{h_{1}}{5} = \\frac{1}{5} $$\n\n- 对于单元2，其尺寸 $h_{2} = 1/2$：\n$$ \\Delta t_{2} = \\frac{h_{2}}{5} = \\frac{1/2}{5} = \\frac{1}{10} $$\n\n- 对于单元3，其尺寸 $h_{3} = 1/4$：\n$$ \\Delta t_{3} = \\frac{h_{3}}{5} = \\frac{1/4}{5} = \\frac{1}{20} $$\n\n三个局部时间步长为 $\\Delta t_{1} = 1/5$、$\\Delta t_{2} = 1/10$ 和 $\\Delta t_{3} = 1/20$。最终答案应以行向量的形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{5} & \\frac{1}{10} & \\frac{1}{20}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在了解了局部时间步的概念后，我们接下来需要研究一个完整的LTS格式的稳定性。虽然单个步长可能满足其局部的Courant-Friedrichs-Lewy (CFL) 条件，但不同时间步区域之间的相互作用可能会引发不稳定性。本练习将指导你为一种特定的LTS调度方案构建全局放大矩阵$\\mathbf{G}$，并通过分析其谱半径$\\rho(\\mathbf{G})$来检验其稳定性，这是数值稳定性分析的基石。",
            "id": "3396681",
            "problem": "考虑一维线性平流方程，其具有恒定正速度 $a>0$，定义在长度为 $L=1$ 的周期性域上。该方程在一个由 $N$ 个单元组成的均匀网格上，使用多项式次数 $p=0$（分片常数）的间断 Galerkin (DG) 方法进行离散化。设单元宽度为 $h=L/N$。使用迎风数值通量和前向欧拉时间积分器，半离散系统可以写成向量形式 $\\frac{d\\mathbf{u}}{dt}=\\mathbf{A}\\mathbf{u}$，其中 $\\mathbf{u}\\in\\mathbb{R}^N$ 汇集了单元平均值，$\\mathbf{A}\\in\\mathbb{R}^{N\\times N}$ 是编码了周期性边界条件下迎风 DG 耦合的循环矩阵。\n\n我们考虑一个局部时间步进 (LTS) 方案，该方案在周期性网格上交替使用两个时间步长层级：偶数索引 $i$ 使用小步长 $\\Delta t_s$，奇数索引 $i$ 使用大步长 $2\\Delta t_s$。在一个持续时间为 $T=2\\Delta t_s$ 的宏观步中，更新方案如下：\n- 第一个子步：使用大小为 $\\Delta t_s$ 的前向欧拉步，同时更新所有偶数索引的单元（小步长集），更新时使用此子步开始时可用的最新邻居状态。\n- 第二个子步：再次使用大小为 $\\Delta t_s$ 的前向欧拉步，同时更新所有偶数索引的单元，更新时使用此子步开始时可用的当前邻居状态。\n- 第三个子步：使用大小为 $2\\Delta t_s$ 的前向欧拉步，同时更新所有奇数索引的单元（大步长集），更新时使用此子步开始时可用的当前邻居状态。\n\n对于 $a>0$ 的 $p=0$ DG 迎风离散化，单元 $i$ 上的半离散方程为\n$$\n\\frac{du_i}{dt} \\;=\\; -\\frac{a}{h}\\,\\big(u_i - u_{i-1}\\big),\n$$\n其中索引是周期性的。在给定时间，一个大小为 $\\Delta t$ 的前向欧拉步使用\n$$\nu_i^{\\text{new}} \\;=\\; u_i^{\\text{old}} \\;-\\; \\Delta t\\,\\frac{a}{h}\\,\\big(u_i^{\\text{old}} - u_{i-1}^{\\text{old}}\\big),\n$$\n该公式同时应用于所选的索引集。\n\n定义全局更新算子 $\\mathbf{G}\\in\\mathbb{R}^{N\\times N}$，它将状态从时间 $t^n$ 映射到 $t^{n+1}=t^n+T$。该映射由上述三子步 LTS 方案产生。由于系统和更新是线性的，$\\mathbf{G}$ 是一个线性算子，可以通过将方案应用于标准基向量来构建。\n\n对于 $p=0$ 迎风半离散化，强稳定性保持 (SSP) 前向欧拉时间步长界限是 Courant–Friedrichs–Lewy (CFL) 条件 $a\\,\\Delta t / h \\le 1$（对任何显式步长）。在具有两个层级的 LTS 设置中，这要求 $a\\,\\Delta t_s / h \\le 1$ 和 $a\\,(2\\Delta t_s)/h \\le 1$ 同时成立，即 $c \\equiv a\\,\\Delta t_s/h \\le 1/2$。\n\n您的任务是：\n- 针对所描述的 LTS 方案，通过将子步应用于标准基，并在每个子步使用 $p=0$ DG 迎风前向欧拉更新，构建对应于一个宏观步 $T=2\\Delta t_s$ 的全局更新算子 $\\mathbf{G}$。\n- 计算 $\\mathbf{G}$ 的谱半径 $\\rho(\\mathbf{G})$，定义为 $\\mathbf{G}$ 特征值模的最大值。\n- 通过比较 $\\rho(\\mathbf{G})\\le 1$ 是否与 SSP 条件 $c\\le 1/2$ 一致，来验证其稳定性是否符合 SSP 界限。\n\n使用以下具有周期性网格和交替时间步长层级的测试套件：\n- 测试 1：$N=8$，$a=1$，$c=0.45$，因此 $h=1/N$ 且 $\\Delta t_s = c\\,h/a$。\n- 测试 2：$N=8$，$a=1$，$c=0.50$，因此 $h=1/N$ 且 $\\Delta t_s = c\\,h/a$。\n- 测试 3：$N=8$，$a=1$，$c=0.55$，因此 $h=1/N$ 且 $\\Delta t_s = c\\,h/a$。\n- 测试 4：$N=8$，$a=1$，$c=0.10$，因此 $h=1/N$ 且 $\\Delta t_s = c\\,h/a$。\n\n对于每个测试，计算并报告由以下三项组成的三元组：\n- 谱半径 $\\rho(\\mathbf{G})$，四舍五入到六位小数，\n- 指示 $\\rho(\\mathbf{G}) \\le 1$ 是否成立的布尔值（使用适合浮点特征值计算的数值容差），\n- 指示 SSP 界限 $c \\le 1/2$ 是否成立的布尔值。\n\n最终输出格式：您的程序应生成单行输出，包含所有测试的结果，格式为逗号分隔的列表之列表，其中每个内部列表的形式为 $[\\rho,\\text{spectral\\_stable},\\text{ssp\\_ok}]$。例如，包含两个测试的输出可能看起来像 $[[0.999999,\\text{True},\\text{True}],[1.234567,\\text{False},\\text{False}]]$。",
            "solution": "该问题陈述是偏微分方程数值分析领域一个适定的练习。它在科学上是合理的、自洽的，并提供了构建和分析指定的局部时间步进 (LTS) 方案所需的所有信息。所有参数和过程都得到了清晰的定义。因此，该问题是有效的。\n\n核心任务是推导应用于一维线性平流方程的间断 Galerkin (DG) 离散化的三子步 LTS 方案的全局更新算子 $\\mathbf{G}$，然后通过计算其谱半径 $\\rho(\\mathbf{G})$ 来分析其稳定性。\n\n设系统在一个宏观步开始时的状态为单元平均值向量 $\\mathbf{u}^n \\in \\mathbb{R}^N$。宏观步的持续时间为 $T = 2\\Delta t_s$。小时间步的恒定 Courant 数定义为 $c = a\\Delta t_s/h$。\n\n单个单元 $i$ 在时间步长 $\\Delta t$ 内的前向欧拉更新由下式给出：\n$$\nu_i^{\\text{new}} = u_i^{\\text{old}} - \\frac{a \\Delta t}{h} (u_i^{\\text{old}} - u_{i-1}^{\\text{old}})\n$$\n其中索引以 $N$ 为模进行周期性处理。\n\n我们将通过跟踪 LTS 方案的三个子步中的状态向量来确定最终状态 $\\mathbf{u}^{n+1} = \\mathbf{G}\\mathbf{u}^n$。设 $\\mathbf{u}^{(0)} = \\mathbf{u}^n$。\n\n子步 1：用步长 $\\Delta t_s$ 更新偶数索引的单元。\n对于 $i\\%2=0$（偶数）的单元 $i$，更新使用时间步长 $\\Delta t_s$，对应于 Courant 数 $c$。\n$$\nu_i^{(1)} = u_i^{(0)} - c (u_i^{(0)} - u_{i-1}^{(0)}) = (1-c)u_i^{(0)} + c u_{i-1}^{(0)} \\quad \\text{对于 } i \\text{ 是偶数}\n$$\n对于 $i\\%2=1$（奇数）的单元 $i$，状态保持不变。\n$$\nu_i^{(1)} = u_i^{(0)} \\quad \\text{对于 } i \\text{ 是奇数}\n$$\n\n子步 2：再次用步长 $\\Delta t_s$ 更新偶数索引的单元。此步骤的初始状态是 $\\mathbf{u}^{(1)}$。\n$$\nu_i^{(2)} = u_i^{(1)} - c (u_i^{(1)} - u_{i-1}^{(1)}) = (1-c)u_i^{(1)} + c u_{i-1}^{(1)} \\quad \\text{对于 } i \\text{ 是偶数}\n$$\n$$\nu_i^{(2)} = u_i^{(1)} \\quad \\text{对于 } i \\text{ 是奇数}\n$$\n为了用 $\\mathbf{u}^{(0)}$ 表示 $\\mathbf{u}^{(2)}$，我们代入 $\\mathbf{u}^{(1)}$ 的表达式。\n对于一个偶数索引 $i$，索引 $i-1$ 是奇数。因此，$u_{i-1}^{(1)} = u_{i-1}^{(0)}$。\n$$\nu_i^{(2)} = (1-c) \\left( (1-c)u_i^{(0)} + c u_{i-1}^{(0)} \\right) + c u_{i-1}^{(0)} = (1-c)^2 u_i^{(0)} + c(1-c)u_{i-1}^{(0)} + c u_{i-1}^{(0)}\n$$\n$$\nu_i^{(2)} = (1-c)^2 u_i^{(0)} + c(2-c) u_{i-1}^{(0)} \\quad \\text{对于 } i \\text{ 是偶数}\n$$\n对于一个奇数索引 $i$，状态在前两个子步中保持不变：$u_i^{(2)} = u_i^{(1)} = u_i^{(0)}$。\n\n子步 3：用步长 $2\\Delta t_s$ 更新奇数索引的单元。此步骤的初始状态是 $\\mathbf{u}^{(2)}$。相应的 Courant 数是 $a(2\\Delta t_s)/h = 2c$。\n$$\nu_i^{(3)} = u_i^{(2)} - 2c (u_i^{(2)} - u_{i-1}^{(2)}) = (1-2c)u_i^{(2)} + 2c u_{i-1}^{(2)} \\quad \\text{对于 } i \\text{ 是奇数}\n$$\n$$\nu_i^{(3)} = u_i^{(2)} \\quad \\text{对于 } i \\text{ 是偶数}\n$$\n最终状态是 $\\mathbf{u}^{n+1} = \\mathbf{u}^{(3)}$。为了用 $\\mathbf{u}^{(0)}$ 表示 $\\mathbf{u}^{n+1}$，我们代入 $\\mathbf{u}^{(2)}$ 的表达式。\n对于一个偶数索引 $i$，状态在此子步中被冻结：\n$$\nu_i^{n+1} = u_i^{(2)} = (1-c)^2 u_i^{(0)} + c(2-c) u_{i-1}^{(0)} \\quad \\text{对于 } i \\text{ 是偶数}\n$$\n对于一个奇数索引 $i$，索引 $i-1$ 是偶数。我们代入 $u_i^{(2)}$ 和 $u_{i-1}^{(2)}$ 的表达式：\n$$\nu_i^{n+1} = (1-2c)u_i^{(0)} + 2c \\left( (1-c)^2 u_{i-1}^{(0)} + c(2-c) u_{i-2}^{(0)} \\right)\n$$\n$$\nu_i^{n+1} = (1-2c)u_i^{(0)} + 2c(1-c)^2 u_{i-1}^{(0)} + 2c^2(2-c) u_{i-2}^{(0)} \\quad \\text{对于 } i \\text{ 是奇数}\n$$\n\n这些方程定义了线性变换 $\\mathbf{u}^{n+1} = \\mathbf{G}\\mathbf{u}^n$。矩阵 $\\mathbf{G}$ 可以从这些关系构建。$\\mathbf{G}$ 的第 $i$ 行包含将 $\\mathbf{u}^n$ 的分量映射到 $u_i^{n+1}$ 的系数。设 $G_{ij}$ 是 $\\mathbf{G}$ 中第 $i$ 行第 $j$ 列的元素。\n如果 $i$ 是偶数：\n$$\nG_{i,i} = (1-c)^2\n$$\n$$\nG_{i, j} = c(2-c) \\quad \\text{对于 } j=(i-1) \\pmod N\n$$\n如果 $i$ 是奇数：\n$$\nG_{i,i} = 1-2c\n$$\n$$\nG_{i, j} = 2c(1-c)^2 \\quad \\text{对于 } j=(i-1) \\pmod N\n$$\n$$\nG_{i, k} = 2c^2(2-c) \\quad \\text{对于 } k=(i-2) \\pmod N\n$$\n$\\mathbf{G}$ 的所有其他元素均为零。\n\n该方案的稳定性由放大矩阵的谱半径 $\\rho(\\mathbf{G}) = \\max_j |\\lambda_j|$ 决定，其中 $\\{\\lambda_j\\}$ 是 $\\mathbf{G}$ 的特征值。当且仅当 $\\rho(\\mathbf{G}) \\le 1$ 时，该方案是稳定的。问题要求验证此条件是否与从系统中最大时间步长推导出的强稳定性保持 (SSP) 条件一致，即 $a (2\\Delta t_s)/h \\le 1$，或 $c \\le 1/2$。\n\n对于指定的每个测试用例，我们将通过计算执行以下步骤：\n1. 对于给定的 $c$ 值和 $N=8$，构建 $N \\times N$ 矩阵 $\\mathbf{G}$。\n2. 使用数值库计算 $\\mathbf{G}$ 的特征值。\n3. 计算谱半径 $\\rho(\\mathbf{G})$，即所计算特征值的最大绝对值。\n4. 通过检查 $\\rho(\\mathbf{G}) \\le 1$（使用一个小的浮点容差）来确定谱稳定性。\n5. 确定 SSP 条件 $c \\le 1/2$ 是否满足。\n6. 按指定格式报告结果。\n\n对于 $c \\le 1/2$，更新公式中的所有系数都是非负的。还可以验证每行的系数之和恰好为 $1$，这意味着 $\\mathbf{G}$ 是一个随机矩阵。根据非负矩阵的 Perron-Frobenius 定理，其谱半径恰好为 $1$。对于 $c > 1/2$，项 $1-2c$ 变为负数，谱半径可能超过 $1$。数值实验将证实这一理论预期。",
            "answer": "```python\nimport numpy as np\n\ndef construct_G(N, c):\n    \"\"\"\n    Constructs the global update operator G for the LTS scheme.\n\n    Args:\n        N (int): The number of cells in the mesh.\n        c (float): The Courant number a*dt_s/h.\n\n    Returns:\n        numpy.ndarray: The N x N global update matrix G.\n    \"\"\"\n    G = np.zeros((N, N))\n    for i in range(N):\n        if i % 2 == 0:  # Even-indexed cells\n            # u_i^{n+1} = (1-c)^2 * u_i^n + c(2-c) * u_{i-1}^n\n            G[i, i] = (1 - c)**2\n            G[i, (i - 1 + N) % N] = c * (2 - c)\n        else:  # Odd-indexed cells\n            # u_i^{n+1} = (1-2c)*u_i^n + 2c(1-c)^2*u_{i-1}^n + 2c^2(2-c)*u_{i-2}^n\n            G[i, i] = 1 - 2 * c\n            G[i, (i - 1 + N) % N] = 2 * c * (1 - c)**2\n            G[i, (i - 2 + N) % N] = 2 * c**2 * (2 - c)\n    return G\n\ndef solve():\n    \"\"\"\n    Runs the analysis for the test cases and prints the results.\n    \"\"\"\n    # Test cases defined in the problem statement\n    # N=8, a=1 are fixed for all tests.\n    test_cases = [0.45, 0.50, 0.55, 0.10]\n    N = 8\n    \n    # Tolerance for checking if spectral radius is = 1.0\n    TOLERANCE = 1e-9\n\n    results_as_strings = []\n\n    for c in test_cases:\n        # Construct the matrix G\n        G = construct_G(N, c)\n\n        # Compute eigenvalues and spectral radius\n        eigenvalues = np.linalg.eigvals(G)\n        spectral_radius = np.max(np.abs(eigenvalues))\n\n        # Check stability conditions\n        is_spectrally_stable = spectral_radius = 1.0 + TOLERANCE\n        ssp_condition_holds = c = 0.5\n\n        # Round spectral radius to 6 decimal places\n        rho_rounded = round(spectral_radius, 6)\n\n        # Format the result list for this test case as a string\n        result_str = f\"[{rho_rounded},{str(is_spectrally_stable)},{str(ssp_condition_holds)}]\"\n        results_as_strings.append(result_str)\n\n    # Print the final output in the required format\n    # Example: [[0.999999,True,True],[1.234567,False,False]]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了稳定性之后，局部时间步进方法的最后一个关键环节是精度。不同时间步区域在界面处的耦合方式对LTS格式的整体精度至关重要。本练习要求你实现并比较两种不同的多速率方法，重点关注局部截断误差 (LTE) 的概念，以及如何在中间时刻通过外插法提供数据等实际的算法设计细节。",
            "id": "3396684",
            "problem": "考虑一个具有恒定平流速度的一维线性平流方程，该方程通过使用分片常数（零次多项式）和迎风数值通量的间断 Galerkin (DG) 方法，在具有两个单元的周期性网格上进行半离散化。设左侧单元为尺寸为 $\\Delta x_f$ 的“细”分区，右侧单元为尺寸为 $\\Delta x_c$ 的“粗”分区。对于平流速度 $a$，此半离散化产生一个线性常微分方程组\n$$\n\\frac{d}{dt} \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix} = L \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix}, \\quad L = \\begin{bmatrix} -\\frac{a}{\\Delta x_f}  \\frac{a}{\\Delta x_f} \\\\ \\frac{a}{\\Delta x_c}  -\\frac{a}{\\Delta x_c} \\end{bmatrix},\n$$\n其中 $u_f$ 是细单元上的单元平均值，$u_c$ 是粗单元上的单元平均值。周期性边界条件通过将细单元左侧的相邻单元设为粗单元来封闭该系统。\n\n您将为这个半离散系统实现并比较两种显式多速率局部时间步进 (LTS) 格式，细分区和粗分区之间的步长比 $r=2$。步长为粗时间宏步的 $H$ 和细时间微步的 $h = H / 2$。两种方法都必须从时间 $t=0$ 的初始条件开始，运行单个粗时间宏步。\n\n定义和要求：\n\n- 间断 Galerkin (DG) 是产生上述半离散算子 $L$ 的方法。\n- 局部时间步进 (LTS) 指的是不同的分区（细分区和粗分区）使用不同的时间步长。\n- Adams-Bashforth (AB) 指的是显式多步 Adams-Bashforth 方法。\n- Runge-Kutta (RK) 指的是显式 Runge-Kutta 方法。\n\n分区的右端项由 $L$ 的行定义：对于细分区，\n$$\nf_f(t) = L_{ff} u_f(t) + L_{fc} u_c(t),\n$$\n对于粗分区，\n$$\nf_c(t) = L_{cf} u_f(t) + L_{cc} u_c(t).\n$$\n\n您必须实现以下两种步长比 $r=2$ 的多速率格式：\n\n1.  二阶多速率 Adams-Bashforth (MRAB2)，对细分区使用线性外插耦合：\n    -   对于细分区，在 $[0,H]$ 上使用两个尺寸为 $h$ 的微步，采用两步 Adams-Bashforth 更新。在细分区右端项需要粗分区值的任何时间 $\\tau$，通过一个由前两个粗时间点 $\\tau = 0$ 和 $\\tau = -H$ 的精确粗分区值构建的线性多项式来近似粗分区值：\n        $$\n        \\tilde{u}_c(\\tau) = u_c(0) + \\frac{\\tau}{H}\\left(u_c(0) - u_c(-H)\\right).\n        $$\n        在 $f_f(\\tau)=L_{ff}u_f(\\cdot)+L_{fc}\\tilde{u}_c(\\tau)$ 中使用此 $\\tilde{u}_c(\\tau)$。\n        从 $t=0$ 开始的第一个细微步使用 $t=-h$ 处的精确过去细分区值来计算 Adams-Bashforth 中的第二个历史项。第二个细微步使用第一个微步在 $t=h$ 处的历史输出。\n    -   对于粗分区，使用步长 $H$ 执行一次 Adams-Bashforth 两步更新，在右端项求值 $f_c(0)$ 和 $f_c(-H)$ 中对细分区和粗分区都使用 $t=0$ 和 $t=-H$ 处的精确过去值。\n\n2.  带子循环的多速率显式二阶 Runge-Kutta (Heun) (MR-RK2)：\n    -   对于细分区，在 $[0,H]$ 上执行两个尺寸为 $h$ 的 Heun 微步。在细分区阶段求值所需的任何时间 $\\tau$，使用与上述相同的线性多项式 $\\tilde{u}_c(\\tau)$ 来近似粗分区值。在区间 $[t_n,t_{n+1}]$ 上步长为 $h$ 的每个细 Heun 步内，使用标准的两阶段更新\n        $$\n        k_1 = f_f(t_n), \\quad u_f^{\\star} = u_f(t_n) + h\\,k_1, \\quad k_2 = f_f(t_n+h)\\text{ 在 }(u_f^{\\star},\\tilde{u}_c(t_n+h)) \\text{处求值},\n        $$\n        $$\n        u_f(t_{n+1}) = u_f(t_n) + \\frac{h}{2}\\left(k_1 + k_2\\right).\n        $$\n        用 $u_f(0)$ 初始化，并顺序执行两个微步以达到 $t=H$。\n    -   对于粗分区，执行一个尺寸为 $H$ 的 Heun 步。使用\n        $$\n        k_1 = f_c(0)\\text{ 在精确值 }(u_f(0),u_c(0)) \\text{处求值}, \\quad u_c^{\\star} = u_c(0) + H\\,k_1,\n        $$\n        $$\n        k_2 = f_c(H)\\text{ 在 }(u_f(H)\\text{ 来自细分区子循环结果},\\,u_c^{\\star}) \\text{处求值},\n        $$\n        $$\n        u_c(H) = u_c(0) + \\frac{H}{2}\\left(k_1 + k_2\\right).\n        $$\n\n待计算的局部截断误差定义：\n\n-   设精确半离散解为 $u(t) = \\exp(t L) u(0)$，其中 $\\exp$ 是矩阵指数。对于给定格式的一个粗时间宏步 $H$，应用于精确初始数据和历史数据的局部截断误差是 $t=H$ 处的精确解与一个宏步后的数值结果之差的欧几里得范数，\n    $$\n    \\mathrm{LTE} = \\left\\| u(H) - u_{\\text{num}}(H) \\right\\|_2,\n    $$\n    其中 $u_{\\text{num}}(H)$ 是按上述规定构建的格式输出。对于任何在 $t=-h$ 或 $t=-H$ 处的所需过去时刻值，使用精确值 $u(-h)$ 和 $u(-H)$。无需物理单位。\n\n实现约束：\n\n-   使用如上定义的矩阵 $L$。\n-   仅在时间 $\\tau$ 处于 $[-H,H]$ 内对细分区右端项求值时，使用线性外插 $\\tilde{u}_c(\\tau)$。\n-   对于 $t=0$ 和 $t=-H$ 处的粗 MRAB2 右端项，对 $u_f$ 和 $u_c$ 均使用精确值。\n-   对于 $t=H$ 处的粗 MR-RK2 阶段，使用由细分区子循环 Heun 方法计算出的细分区值 $u_f(H)$；此阶段不要使用 $t=H$ 处的精确值。\n\n测试套件：\n\n对以下四种情况运行您的程序。在所有情况下，取 $a=1$ 和指定的初始条件 $u(0) = \\begin{bmatrix} u_f(0) \\\\ u_c(0) \\end{bmatrix}$。为每种情况报告一对值 $\\left[\\mathrm{LTE}_{\\text{MRAB2}}, \\mathrm{LTE}_{\\text{MR-RK2}}\\right]$。\n\n-   情况 A：$\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.2$, $u(0) = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$。\n-   情况 B：$\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.05$, $u(0) = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$。\n-   情况 C：$\\Delta x_f = 0.25$, $\\Delta x_c = 0.5$, $H = 0.05$, $u(0) = \\begin{bmatrix} 0.3 \\\\ -0.1 \\end{bmatrix}$。\n-   情况 D（边界情况：常数模态）：$\\Delta x_f = 1.0$, $\\Delta x_c = 1.0$, $H = 0.1$, $u(0) = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，包含一个逗号分隔的列表，列表包含四个项目，每个项目是一个双元素列表，其中包含相应情况的两个截断误差浮点数，顺序为 A、B、C、D。例如，输出必须如下所示\n\"[ [eA_AB,eA_RK], [eB_AB,eB_RK], [eC_AB,eC_RK], [eD_AB,eD_RK] ]\"\n不含其他文本。将每个占位符替换为计算出的浮点数。",
            "solution": "我们从线性平流方程的间断 Galerkin (DG) 半离散化开始，该方法在双单元周期性网格上使用分片常数和迎风通量。设平流速度为 $a$，细单元尺寸为 $\\Delta x_f$，粗单元尺寸为 $\\Delta x_c$。对于分片常数和 $a0$，标准的迎风 DG 通量给出了两个单元平均值 $u_f$ 和 $u_c$ 的半离散演化：\n$$\n\\frac{d}{dt} u_f = -\\frac{a}{\\Delta x_f} u_f + \\frac{a}{\\Delta x_f} u_c, \\quad\n\\frac{d}{dt} u_c = \\frac{a}{\\Delta x_c} u_f - \\frac{a}{\\Delta x_c} u_c,\n$$\n可以紧凑地写为\n$$\n\\frac{d}{dt} \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix} = L \\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix}, \\quad\nL = \\begin{bmatrix} -\\frac{a}{\\Delta x_f}  \\frac{a}{\\Delta x_f} \\\\ \\frac{a}{\\Delta x_c}  -\\frac{a}{\\Delta x_c} \\end{bmatrix}.\n$$\n这个线性常系数系统是适定的；一个特征值为 $0$（常数模态），另一个是负实数 $-\\left(\\frac{a}{\\Delta x_f} + \\frac{a}{\\Delta x_c}\\right)$，因此在使用显式积分器和适中的时间步长时，该系统是非刚性的。\n\n对于步长比 $r=2$ 的局部时间步进 (LTS) 配置，我们指定细分区使用步长 $h$，粗分区使用步长 $H=2h$。多速率的方面意味着细分区在一个粗时间宏步内推进两个微步。因为右端项是按 $L$ 的行进行分区的，所以写成\n$$\nf_f(t, u_f(\\cdot), u_c(\\cdot)) = L_{ff} u_f(t) + L_{fc} u_c(t), \\quad\nf_c(t, u_f(\\cdot), u_c(\\cdot)) = L_{cf} u_f(t) + L_{cc} u_c(t).\n$$\n\n为了定义具有二阶精度的一致多速率耦合，当细分区需要在网格之外的时间点获取粗分区变量时，我们通过一个由两个先前粗时间节点 $t=0$ 和 $t=-H$ 处的精确粗分区值构建的一次外插来近似该变量。具体来说，对于宏步内或稍早的任何时间 $\\tau$，定义\n$$\n\\tilde{u}_c(\\tau) = u_c(0) + \\frac{\\tau}{H}\\left(u_c(0) - u_c(-H)\\right).\n$$\n这是一个关于时间的线性多项式，它再现了 $t=0$ 和 $t=-H$ 处的精确粗分区解，并外插到 $(0,H]$ 区间。\n\n一个单步推进算子在一个宏步 $H$ 上的局部截断误差定义为：从 $t=0$ 处的精确初始值开始，将数值格式应用恰好一个宏步（当格式需要 $t0$ 的过去数据时使用精确历史值），然后测量与 $t=H$ 处精确解的差异：\n$$\n\\mathrm{LTE} = \\left\\| u(H) - u_{\\text{num}}(H) \\right\\|_2,\n$$\n其中 $u(H) = \\exp(HL) u(0)$，$\\|\\cdot\\|_2$ 表示欧几里得范数。当格式需要精确的过去值时，我们使用 $u(-h) = \\exp(-hL) u(0)$ 和 $u(-H) = \\exp(-HL) u(0)$。\n\n现在我们具体说明这两种多速率格式。\n\n1.  二阶多速率 Adams-Bashforth (MRAB2):\n    -   细分区，从 $t=0$ 到 $t=h$ 的第一个微步：\n        两步 Adams-Bashforth 公式需要 $t=0$ 和 $t=-h$ 处的右端项。对于细分区，我们使用\n        $$\n        k_f(0) = L_{ff} u_f(0) + L_{fc} \\tilde{u}_c(0) = L_{ff} u_f(0) + L_{fc} u_c(0),\n        $$\n        $$\n        k_f(-h) = L_{ff} u_f(-h) + L_{fc} \\tilde{u}_c(-h) = L_{ff} u_f(-h) + L_{fc}\\left(u_c(0) + \\frac{-h}{H}\\left(u_c(0) - u_c(-H)\\right)\\right).\n        $$\n        然后\n        $$\n        u_f(h) = u_f(0) + h\\left(\\frac{3}{2}k_f(0) - \\frac{1}{2} k_f(-h)\\right).\n        $$\n    -   细分区，从 $t=h$ 到 $t=H$ 的第二个微步：\n        现在两步 Adams-Bashforth 使用 $t=h$ 和 $t=0$ 处的右端项，其中 $t=h$ 处的值由上一个微步提供：\n        $$\n        k_f(h) = L_{ff} u_f(h) + L_{fc} \\tilde{u}_c(h), \\quad k_f(0)\\text{ 如上},\n        $$\n        $$\n        u_f(H) = u_f(h) + h\\left(\\frac{3}{2}k_f(h) - \\frac{1}{2}k_f(0)\\right).\n        $$\n    -   粗分区，一个宏步 $H$，使用带有精确过去数据的两步 Adams-Bashforth：\n        $$\n        k_c(0) = L_{cf} u_f(0) + L_{cc} u_c(0), \\quad k_c(-H) = L_{cf} u_f(-H) + L_{cc} u_c(-H),\n        $$\n        $$\n        u_c(H) = u_c(0) + H\\left(\\frac{3}{2}k_c(0) - \\frac{1}{2} k_c(-H)\\right).\n        $$\n\n2.  带子循环的多速率显式二阶 Runge-Kutta (Heun) (MR-RK2):\n    -   细分区，两个微步，每个都是带有外插粗网格相邻值的 Heun 步：\n        对于从 $t_n$ 到 $t_{n+1} = t_n + h$ 的一个微步，\n        $$\n        k_1 = L_{ff} u_f(t_n) + L_{fc} \\tilde{u}_c(t_n), \\quad u_f^{\\star} = u_f(t_n) + h\\,k_1,\n        $$\n        $$\n        k_2 = L_{ff} u_f^{\\star} + L_{fc} \\tilde{u}_c(t_{n+1}), \\quad u_f(t_{n+1}) = u_f(t_n) + \\frac{h}{2}(k_1 + k_2).\n        $$\n        用 $u_f(0)$ 初始化，应用一次得到 $u_f(h)$，然后再次应用得到 $u_f(H)$，并根据需要使用 $\\tilde{u}_c(h)$ 和 $\\tilde{u}_c(H)$。\n    -   粗分区，一个 Heun 宏步：\n        $$\n        k_1 = L_{cf} u_f(0) + L_{cc} u_c(0), \\quad u_c^{\\star} = u_c(0) + H\\,k_1,\n        $$\n        $$ \n        k_2 = L_{cf} u_f(H) + L_{cc} u_c^{\\star}, \\quad u_c(H) = u_c(0) + \\frac{H}{2}(k_1 + k_2),\n        $$\n        其中 $u_f(H)$ 是从两个微步中获得的细分区值。\n\n这些算法描述将基础科学原理与算法设计相结合：半离散 DG 算子提供了一个线性系统，其精确演化由矩阵指数给出，而显式多速率格式则以局部时间步进的典型方式，通过外插或阶段同步来采用子循环和耦合。\n\n对于每个测试用例，我们按以下步骤进行：\n-   根据 $a$、$\\Delta x_f$ 和 $\\Delta x_c$ 构建 $L$。\n-   通过 $u(-\\theta) = \\exp(-\\theta L) u(0)$ 计算精确的初始值 $u(0)$、精确的过去值 $u(-h)$ 和 $u(-H)$。\n-   如上所定义，对 MRAB2 和 MR-RK2 应用一个宏步 $H$，以获得每个格式的 $u_{\\text{num}}(H)$。\n-   计算精确解 $u(H) = \\exp(HL) u(0)$。\n-   为每个格式计算 $\\mathrm{LTE} = \\|u(H) - u_{\\text{num}}(H)\\|_2$。\n\n四个测试用例如下：\n-   情况 A：$\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.2$, $u(0) = [1.0, -0.5]^T$。\n-   情况 B：$\\Delta x_f = 0.5$, $\\Delta x_c = 1.0$, $H = 0.05$, $u(0) = [1.0, -0.5]^T$。\n-   情况 C：$\\Delta x_f = 0.25$, $\\Delta x_c = 0.5$, $H = 0.05$, $u(0) = [0.3, -0.1]^T$。\n-   情况 D：$\\Delta x_f = 1.0$, $\\Delta x_c = 1.0$, $H = 0.1$, $u(0) = [1.0, 1.0]^T$。\n\n因为常数模态是特征值为 $0$ 的特征向量，情况 D 应该产生消失的右端项，因此在舍入误差范围内，局部截断误差应基本为零，这是一个边界情况。情况 A 和 B 共享几何结构但使用不同的 $H$ 值，因此可以说明两种格式的时间上的二阶精度标度。情况 C 修改了网格尺寸，通过 $L$ 测试了对不同耦合强度的敏感性。\n\n最后，将结果汇总到列表的单行打印输出中\n$$\n\\left[ [\\mathrm{LTE}_A^{\\text{AB2}}, \\mathrm{LTE}_A^{\\text{RK2}}], [\\mathrm{LTE}_B^{\\text{AB2}}, \\mathrm{LTE}_B^{\\text{RK2}}], [\\mathrm{LTE}_C^{\\text{AB2}}, \\mathrm{LTE}_C^{\\text{RK2}}], [\\mathrm{LTE}_D^{\\text{AB2}}, \\mathrm{LTE}_D^{\\text{RK2}}] \\right].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_L(a, dx_f, dx_c):\n    \"\"\"Construct the 2x2 DG p=0 semi-discrete operator L for linear advection.\"\"\"\n    L = np.array([[-a/dx_f,  a/dx_f],\n                  [ a/dx_c, -a/dx_c]], dtype=float)\n    return L\n\ndef exact_state(L, t, u0):\n    \"\"\"Exact solution u(t) = exp(t L) u0.\"\"\"\n    return expm(t * L) @ u0\n\ndef coarse_extrap(u_c_0, u_c_minusH, tau, H):\n    \"\"\"Linear polynomial based on u_c(0) and u_c(-H), evaluated at time tau.\"\"\"\n    return u_c_0 + (tau / H) * (u_c_0 - u_c_minusH)\n\ndef mrab2_lts_one_macrostep(L, H, u0):\n    \"\"\"\n    One macro-step for MRAB2 with step ratio 2.\n    Fine partition index = 0, coarse = 1.\n    Fine uses two AB2 micro-steps with coarse extrapolation from t=0 and t=-H.\n    Coarse uses one AB2 macro-step with exact past values at t=0 and t=-H.\n    \"\"\"\n    h = H / 2.0\n    # Partitioned L entries\n    L_ff, L_fc = L[0, 0], L[0, 1]\n    L_cf, L_cc = L[1, 0], L[1, 1]\n\n    # Exact required history\n    u_exact_0 = u0.copy()\n    u_exact_minus_h = exact_state(L, -h, u0)\n    u_exact_minus_H = exact_state(L, -H, u0)\n\n    # Prepare coarse extrapolation values from exact coarse at 0 and -H\n    u_c_0 = u_exact_0[1]\n    u_c_minusH = u_exact_minus_H[1]\n\n    # Fine micro-step 1: from t=0 to t=h using AB2 with history at t=0 and t=-h\n    # k_f(0)\n    kf_0 = L_ff * u_exact_0[0] + L_fc * coarse_extrap(u_c_0, u_c_minusH, 0.0, H)\n    # k_f(-h)\n    kf_minus_h = L_ff * u_exact_minus_h[0] + L_fc * coarse_extrap(u_c_0, u_c_minusH, -h, H)\n    u_f_h = u_exact_0[0] + h * (1.5 * kf_0 - 0.5 * kf_minus_h)\n\n    # Fine micro-step 2: from t=h to t=H using AB2 with history at t=h (computed) and t=0\n    kf_h = L_ff * u_f_h + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    # k_f(0) already computed: kf_0\n    u_f_H = u_f_h + h * (1.5 * kf_h - 0.5 * kf_0)\n\n    # Coarse macro-step AB2: from t=0 to t=H using exact past values at 0 and -H\n    kc_0 = L_cf * u_exact_0[0] + L_cc * u_exact_0[1]\n    kc_minus_H = L_cf * u_exact_minus_H[0] + L_cc * u_exact_minus_H[1]\n    u_c_H = u_exact_0[1] + H * (1.5 * kc_0 - 0.5 * kc_minus_H)\n\n    return np.array([u_f_H, u_c_H], dtype=float)\n\ndef mrrk2_lts_one_macrostep(L, H, u0):\n    \"\"\"\n    One macro-step for MR-RK2 (Heun) with step ratio 2.\n    Fine partition: two Heun micro-steps with coarse extrapolation at needed times.\n    Coarse partition: one Heun step, with k2 using the fine solution at t=H produced by subcycling.\n    \"\"\"\n    h = H / 2.0\n    L_ff, L_fc = L[0, 0], L[0, 1]\n    L_cf, L_cc = L[1, 0], L[1, 1]\n\n    # Exact required history at t=0 and t=-H\n    u_exact_0 = u0.copy()\n    u_exact_minus_H = exact_state(L, -H, u0)\n\n    # Coarse extrapolation baseline\n    u_c_0 = u_exact_0[1]\n    u_c_minusH = u_exact_minus_H[1]\n\n    # Fine Heun micro-step 1: [0, h]\n    u_f_n = u_exact_0[0]\n    # k1 at t=0\n    k1 = L_ff * u_f_n + L_fc * coarse_extrap(u_c_0, u_c_minusH, 0.0, H)\n    u_f_star = u_f_n + h * k1\n    # k2 at t=h\n    k2 = L_ff * u_f_star + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    u_f_1 = u_f_n + 0.5 * h * (k1 + k2)\n\n    # Fine Heun micro-step 2: [h, H]\n    u_f_n2 = u_f_1\n    k1b = L_ff * u_f_n2 + L_fc * coarse_extrap(u_c_0, u_c_minusH, h, H)\n    u_f_star2 = u_f_n2 + h * k1b\n    k2b = L_ff * u_f_star2 + L_fc * coarse_extrap(u_c_0, u_c_minusH, H, H)\n    u_f_H = u_f_n2 + 0.5 * h * (k1b + k2b)\n\n    # Coarse Heun macro-step: [0, H]\n    # k1 at t=0 uses exact values\n    k1c = L_cf * u_exact_0[0] + L_cc * u_exact_0[1]\n    u_c_star = u_exact_0[1] + H * k1c\n    # k2 at t=H uses fine value from subcycling, and coarse stage value u_c_star\n    k2c = L_cf * u_f_H + L_cc * u_c_star\n    u_c_H = u_exact_0[1] + 0.5 * H * (k1c + k2c)\n\n    return np.array([u_f_H, u_c_H], dtype=float)\n\ndef compute_lte(L, H, u0, scheme_func):\n    \"\"\"Compute local truncation error norm-2 for one macro-step for the provided scheme.\"\"\"\n    u_exact_H = exact_state(L, H, u0)\n    u_num_H = scheme_func(L, H, u0)\n    return float(np.linalg.norm(u_exact_H - u_num_H, ord=2))\n\ndef solve():\n    # Advection speed\n    a = 1.0\n\n    # Test cases: (dx_f, dx_c, H, u0_vector)\n    test_cases = [\n        (0.5, 1.0, 0.2,  np.array([1.0, -0.5], dtype=float)),  # Case A\n        (0.5, 1.0, 0.05, np.array([1.0, -0.5], dtype=float)),  # Case B\n        (0.25, 0.5, 0.05, np.array([0.3, -0.1], dtype=float)), # Case C\n        (1.0, 1.0, 0.1,  np.array([1.0, 1.0], dtype=float)),   # Case D (constant mode)\n    ]\n\n    results = []\n    for dx_f, dx_c, H, u0 in test_cases:\n        L = build_L(a, dx_f, dx_c)\n        lte_mrab2 = compute_lte(L, H, u0, mrab2_lts_one_macrostep)\n        lte_mrrk2 = compute_lte(L, H, u0, mrrk2_lts_one_macrostep)\n        results.append([lte_mrab2, lte_mrrk2])\n\n    # Final print statement in the exact required format.\n    # Ensure a single line with Python-list-like formatting.\n    # Convert to string with default float formatting.\n    print(\"[\" + \",\".join(\"[\" + \",\".join(str(x) for x in pair) + \"]\" for pair in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}