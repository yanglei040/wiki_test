{
    "hands_on_practices": [
        {
            "introduction": "在着手并行化一个复杂的科学计算程序之前，首要任务是理解其核心计算部分（即“计算核”）在单个处理器或加速器上的性能特征。Roofline模型是一个直观而强大的可视化工具，它将算法的“计算强度”（每字节内存流量对应的浮点运算次数）与硬件的峰值性能和内存带宽联系起来。通过这个练习 ，你将学会计算一个典型DG方法计算核的计算强度，并判断它是受限于计算能力（“计算密集型”）还是内存访问速度（“访存密集型”），这是进行性能优化的第一步。",
            "id": "3407889",
            "problem": "一个多项式阶数为 $p=8$ 的高阶间断伽辽金（DG）方法在一个三维六面体网格上实现，采用了单元内并行化和融合的体-面核函数。在单个加速器上进行的性能研究报告了一次代表性调用中 DG 核函数的测量数据：总浮点运算次数为 $F=6.72\\times 10^{12}$，设备全局内存与流式多处理器之间传输的总数据量为 $B=1.02\\times 10^{12}$ 字节。该设备制造商标称的峰值双精度浮点吞吐量为 $P_{\\mathrm{peak}}=9.7\\times 10^{12}$ flop/秒，峰值内存带宽为 $B_{\\mathrm{peak}}=1.6\\times 10^{12}$ 字节/秒。\n\n从 Roofline 模型的基本定义出发，利用这些测量数据和硬件限制，确定此 DG 核函数的：\n- 算术强度，以 flop/字节 表示；\n- 该核函数在此硬件上是计算受限还是内存受限。\n\n将算术强度四舍五入到四位有效数字。以 flop/字节 为单位表示强度。最终答案仅提供算术强度的数值。",
            "solution": "本题要求计算给定间断伽辽金（DG）核函数的算术强度，并判断该核函数是计算受限还是内存受限。此分析基于 Roofline 性能模型的原理。\n\n首先，我们定义算术强度，记作 $I$。计算核函数的算术强度是指其执行的总浮点运算次数（$F$）与主内存（本例中为设备全局内存）和处理器（流式多处理器）之间传输的总数据量（$B$）之比。算术强度的公式为：\n$$I = \\frac{F}{B}$$\n算术强度的单位通常是 flop/byte（每字节浮点运算次数）。\n\n题目给出了该 DG 核函数的以下测量值：\n-   总浮点运算次数：$F = 6.72\\times 10^{12}$ flop\n-   总数据传输量：$B = 1.02\\times 10^{12}$ 字节\n\n利用这些值，我们可以计算出该核函数的算术强度：\n$$I = \\frac{6.72\\times 10^{12} \\text{ flop}}{1.02\\times 10^{12} \\text{ byte}}$$\n因子 $10^{12}$ 可以消去，简化计算：\n$$I = \\frac{6.72}{1.02} \\frac{\\text{flop}}{\\text{byte}} \\approx 6.588235... \\frac{\\text{flop}}{\\text{byte}}$$\n根据要求，将其四舍五入到四位有效数字，得到算术强度：\n$$I \\approx 6.588 \\frac{\\text{flop}}{\\text{byte}}$$\n\n接下来，我们必须判断该核函数是计算受限还是内存受限。根据 Roofline 模型，一个核函数的可达性能 $P_{\\text{attainable}}$ 同时受限于硬件的峰值浮点吞吐量 $P_{\\text{peak}}$ 和数据供给处理器的速率，后者是算术强度 $I$ 与峰值内存带宽 $B_{\\text{peak}}$ 的乘积。数学上表示为：\n$$P_{\\text{attainable}} \\le \\min(P_{\\text{peak}}, I \\times B_{\\text{peak}})$$\n\n给定的硬件规格如下：\n-   峰值双精度浮点吞吐量：$P_{\\mathrm{peak}} = 9.7\\times 10^{12}$ flop/s\n-   峰值内存带宽：$B_{\\mathrm{peak}} = 1.6\\times 10^{12}$ byte/s\n\n如果一个核函数的性能受限于内存带宽，即当 $I \\times B_{\\text{peak}}  P_{\\text{peak}}$ 时，该核函数被认为是内存受限的。\n如果一个核函数的性能受限于处理器的计算能力，即当 $I \\times B_{\\text{peak}} > P_{\\text{peak}}$ 时，该核函数被认为是计算受限的。\n\n这两种状态之间的转换发生在 Roofline 图的“脊点”（ridge point）。该点的算术强度被称为机器平衡点 $I_{\\text{machine}}$，计算方法为峰值性能与峰值带宽之比：\n$$I_{\\text{machine}} = \\frac{P_{\\text{peak}}}{B_{\\text{peak}}}$$\n我们可以通过比较核函数的算术强度 $I$ 与机器平衡点 $I_{\\text{machine}}$ 来判断其性能瓶颈。\n\n我们来计算给定硬件的机器平衡点：\n$$I_{\\text{machine}} = \\frac{9.7\\times 10^{12} \\text{ flop/s}}{1.6\\times 10^{12} \\text{ byte/s}} = \\frac{9.7}{1.6} \\frac{\\text{flop}}{\\text{byte}} = 6.0625 \\frac{\\text{flop}}{\\text{byte}}$$\n\n现在，我们比较核函数的算术强度 $I$ 和机器平衡点 $I_{\\text{machine}}$：\n-   核函数强度：$I \\approx 6.588$ flop/byte\n-   机器平衡点：$I_{\\text{machine}} = 6.0625$ flop/byte\n\n由于 $I > I_{\\text{machine}}$ ($6.588 > 6.0625$)，该 DG 核函数的性能受限于处理器的浮点吞吐量，而非内存带宽。因此，该核函数是计算受限的。这是一个多项式阶数为 $p=8$ 的高阶 DG 方法并采用了融合核函数，这一信息与此发现一致，因为这些技术正是为了提高计算与内存访问的比率，从而增加算术强度，使核函数趋向于计算受限状态。\n\n题目要求计算算术强度并判断核函数是计算受限还是内存受限。我们已经得出了两个结论。最终答案应为算术强度的数值。",
            "answer": "$$\\boxed{6.588}$$"
        },
        {
            "introduction": "卓越的并行性能不仅源于巧妙的并行化方案，更根植于高效的底层算法设计。在高阶DG方法中，一个根本性的选择是如何表示离散算子：“组装矩阵”方法存储一个巨大的稀疏矩阵，而“无矩阵”方法则在需要时通过高效的张量运算（如“和因子分解”）即时计算算子作用。本练习  要求你通过量级分析，比较这两种策略在内存占用和通信需求上的差异。你将从理论上揭示为何对于高阶多项式（即$p$值较大时），无矩阵方法凭借其显著的内存优势成为实现大规模并行计算的首选。",
            "id": "3407879",
            "problem": "考虑一个标量线性算子，该算子在空间维度 $d \\in \\{2,3\\}$ 的张量积六面体形正网格上，使用间断 Galerkin (DG) 方法进行离散化。每个坐标方向采用次数为 $p$ 的节点张量积基，节点为 Legendre–Gauss–Lobatto (LGL) 节点。这样，每个单元有 $n_{e}=(p+1)^{d}$ 个未知量，每个 $(d-1)$ 维的面有 $n_{f}=(p+1)^{d-1}$ 个迹未知量。假设内部单元有 $c_{n}=2d$ 个相邻面。您将比较单个标量场的两种算子表示：(i) 以压缩稀疏行 (CSR) 格式存储的组装好的全局稀疏矩阵，以及 (ii) 基于和因子分解的无矩阵表示，该表示仅存储每个单元的几何因子和一维算子。\n\n使用以下基本事实和定义：\n- DG 离散化产生的贡献来自单元内部（体积）项和面（表面）通量项。体积项将同一单元内的所有未知量耦合起来。面项通过提升算子将一个面上的未知量与相邻单元的体积未知量耦合起来。\n- 对于组装矩阵，来自体积项的单元自耦合块是大小为 $n_{e} \\times n_{e}$ 的稠密块。对于每个相邻面，非对角耦合仅在邻居的面迹未知量对应的列上具有非零元（这样的列有 $n_{f}$ 个），并且由于提升作用，这些列在接收单元的 $n_{e}$ 行中是稠密的。\n- 在 CSR 格式中，存储一个非零元需要恒定数量的字节来存放其值和列索引；将此组合常数记为每个非零元 $\\gamma$ 字节。为进行关于 $p$ 的渐近分析，您可以将 $\\gamma$ 视为一个与 $p$ 和 $d$ 无关的常数。\n- 在具有单元局部几何因子的无矩阵和因子分解实现中，每个单元的主要存储量与 $n_{e}$ 呈线性关系（例如，在张量积求积点上存储度量项和雅可比行列式）。将此每个单元的存储量建模为 $\\kappa\\, n_{e}$ 字节，其中 $\\kappa$ 是一个与 $p$ 和 $d$ 无关的常数。\n- 考虑跨进程的区域分解。设 $S$ 为给定进程与其邻居之间的共享面数量。对于单次算子应用：\n  - 在组装的稀疏矩阵向量乘法 (SpMV) 中，唯一需要的远程向量项是那些出现在非对角块的非零列中的项，即邻居的面迹项。将通信量建模为与 $S\\, n_{f}$ 个标量成正比。\n  - 在无矩阵的面通量计算中，所需的远程数据同样是每个共享面上邻居的面迹项，也与 $S\\, n_{f}$ 个标量成正比。\n\n任务：\n1. 推导组装矩阵的每单元内存占用 $M_{\\mathrm{asm}}(p,d)$ 的主阶表达式，用 $p$ 和 $d$ 表示，忽略常数和 $p$ 的低阶项。\n2. 推导无矩阵算子存储的每单元内存占用 $M_{\\mathrm{mf}}(p,d)$ 的主阶表达式，用 $p$ 和 $d$ 表示，忽略常数和 $p$ 的低阶项。\n3. 使用以上结果，构建渐近比 $R_{\\mathrm{mem}}(p,d)=M_{\\mathrm{asm}}(p,d)/M_{\\mathrm{mf}}(p,d)$，并将其简化为对 $p$ 和 $d$ 的主要依赖关系。\n4. 推导每次算子应用的主阶通信量 $C_{\\mathrm{asm}}(p,d,S)$ 和 $C_{\\mathrm{mf}}(p,d,S)$，并构建比率 $R_{\\mathrm{comm}}(p,d)=C_{\\mathrm{asm}}(p,d,S)/C_{\\mathrm{mf}}(p,d,S)$，将其简化为对 $p$ 和 $d$ 的主要依赖关系。\n5. 以闭合形式提供行向量 $\\bigl(R_{\\mathrm{mem}}(p,d),\\,R_{\\mathrm{comm}}(p,d)\\bigr)$ 作为您的最终答案。\n\n您的推导必须从上述定义以及间断 Galerkin 算子和张量积基的标准性质出发。忽略不依赖于 $p$ 或 $d$ 的乘法常数，并忽略与主项相比是 $p$ 的低阶项。最终答案必须是任务5中描述的单一的行向量表达式（无单位）。",
            "solution": "用户提供了一个有效的问题陈述，该问题基于偏微分方程数值方法的原理，特别是高阶间断 Galerkin (DG) 方法。该问题是适定的、客观的，并包含足够的信息以得到唯一解。我将按要求进行推导。\n\n分析的关键在于确定，在 $d$ 维六面体网格上，两种不同 DG 算子表示的内存和通信成本相对于多项式次数 $p$ 的标度关系。关键量是每个单元的未知量数量 $n_{e} = (p+1)^{d}$，以及每个面的未知量数量 $n_{f} = (p+1)^{d-1}$。\n\n### 任务1：组装矩阵的每单元内存占用，$M_{\\mathrm{asm}}(p,d)$\n\n以压缩稀疏行 (CSR) 格式存储的组装稀疏矩阵所需的内存与其非零元条目的数量成正比。我们计算全局矩阵中与单个单元的行相关联的非零元数量。根据问题陈述，这些非零元来自两个来源：单元内部（体积）耦合和面（通量）耦合。\n\n1.  **体积项贡献**：体积项耦合了单元内的所有基函数，形成一个大小为 $n_{e} \\times n_{e}$ 的稠密块。此块中的非零元数量为 $n_{e}^{2}$。\n\n2.  **面项贡献**：一个内部单元有 $c_{n} = 2d$ 个相邻面。对于每个邻居，耦合涉及共享面上邻居一侧的 $n_{f}$ 个迹未知量。问题陈述指出，这 $n_{f}$ 个未知量通过提升算子与局部单元的所有 $n_{e}$ 个未知量进行稠密耦合。因此，对于 $c_{n}$ 个邻居中的每一个，都有 $n_{e} \\times n_{f}$ 个非零元的贡献。面项的总非零元数量为 $c_{n} n_{e} n_{f}$。\n\n每个单元的非零元总数，记为 $nnz_{e}$，是这些贡献的总和：\n$$nnz_{e} = n_{e}^{2} + c_{n} n_{e} n_{f}$$\n内存占用 $M_{\\mathrm{asm}}$ 与 $nnz_{e}$ 成正比。我们将给定的关于 $p$ 和 $d$ 的 $n_{e}$、$n_{f}$ 和 $c_{n}$ 表达式代入：\n$$M_{\\mathrm{asm}}(p,d) \\propto \\left((p+1)^{d}\\right)^{2} + (2d) (p+1)^{d} (p+1)^{d-1}$$\n$$M_{\\mathrm{asm}}(p,d) \\propto (p+1)^{2d} + 2d (p+1)^{2d-1}$$\n对于 $p \\to \\infty$ 的渐近分析，我们找出 $p$ 的最高次幂项。项 $(p+1)^{2d}$ 的阶为 $\\mathcal{O}(p^{2d})$，而项 $2d (p+1)^{2d-1}$ 的阶为 $\\mathcal{O}(p^{2d-1})$。第一项是主导项。因此，组装矩阵内存占用的主阶行为是：\n$$M_{\\mathrm{asm}}(p,d) \\propto (p+1)^{2d}$$\n\n### 任务2：无矩阵表示的每单元内存占用，$M_{\\mathrm{mf}}(p,d)$\n\n问题陈述定义了无矩阵表示的存储模型。其主要开销在于存储用于和因子分解的预计算几何因子，并且该存储量与每个单元的未知量（或求积点）数量 $n_{e}$ 呈线性关系。\n内存占用由下式给出：\n$$M_{\\mathrm{mf}}(p,d) \\propto n_{e}$$\n代入 $n_{e}$ 的定义：\n$$M_{\\mathrm{mf}}(p,d) \\propto (p+1)^{d}$$\n此表达式代表了无矩阵方案的主阶内存占用。\n\n### 任务3：渐近内存比，$R_{\\mathrm{mem}}(p,d)$\n\n内存占用的渐近比是通过将 $M_{\\mathrm{asm}}$ 的表达式除以 $M_{\\mathrm{mf}}$ 的表达式得到的。我们关心的是对 $p$ 和 $d$ 的主要依赖关系。让我们构建完整表达式的比率，然后确定其主阶行为。\n$$R_{\\mathrm{mem}}(p,d) = \\frac{M_{\\mathrm{asm}}(p,d)}{M_{\\mathrm{mf}}(p,d)} \\propto \\frac{(p+1)^{2d} + 2d (p+1)^{2d-1}}{(p+1)^{d}}$$\n化简表达式得到：\n$$R_{\\mathrm{mem}}(p,d) \\propto (p+1)^{d} + 2d (p+1)^{d-1}$$\n为了找到对 $p$ 的主要依赖关系，我们比较各项。第一项 $(p+1)^{d}$ 的阶为 $\\mathcal{O}(p^{d})$，第二项 $2d (p+1)^{d-1}$ 的阶为 $\\mathcal{O}(p^{d-1})$。对于大的 $p$，主导项是 $(p+1)^{d}$。因此，简化的渐近比为：\n$$R_{\\mathrm{mem}}(p,d) = (p+1)^{d}$$\n\n### 任务4：渐近通信比，$R_{\\mathrm{comm}}(p,d)$\n\n我们分析在具有 $S$ 个共享面的区域分解设置下，单次算子应用的通信量。\n\n1.  **组装矩阵通信 ($C_{\\mathrm{asm}}$)**：对于稀疏矩阵向量乘法 (SpMV)，一个进程需要向量中与其矩阵分区中的非零列相对应的分量。问题陈述指出，对于进程间耦合，所需数据包括相邻单元的面迹项。通信量与共享面数 $S$ 乘以每面的未知量数 $n_{f}$ 成正比。\n    $$C_{\\mathrm{asm}}(p,d,S) \\propto S \\, n_{f} = S (p+1)^{d-1}$$\n\n2.  **无矩阵通信 ($C_{\\mathrm{mf}}$)**：对于无矩阵的面通量计算，从相邻进程所需的数据正是解在相邻面上的迹值。问题证实了这一点，指出通信量“同样……与 $S \\, n_{f}$ 个标量成正比”。\n    $$C_{\\mathrm{mf}}(p,d,S) \\propto S \\, n_{f} = S (p+1)^{d-1}$$\n\n通信量之比 $R_{\\mathrm{comm}}(p,d)$ 是通过将 $C_{\\mathrm{asm}}$ 除以 $C_{\\mathrm{mf}}$ 得到的。\n$$R_{\\mathrm{comm}}(p,d) = \\frac{C_{\\mathrm{asm}}(p,d,S)}{C_{\\mathrm{mf}}(p,d,S)} \\propto \\frac{S (p+1)^{d-1}}{S (p+1)^{d-1}} = 1$$\n由于对 $p$、$d$ 和 $S$ 的主阶函数依赖性是相同的，并且我们被要求忽略乘法常数，因此比值为 1。\n\n### 任务5：最终答案向量\n\n最终答案是包含两个推导出的比率的行向量 $\\bigl(R_{\\mathrm{mem}}(p,d),\\,R_{\\mathrm{comm}}(p,d)\\bigr)$。根据以上分析：\n- $R_{\\mathrm{mem}}(p,d) = (p+1)^{d}$\n- $R_{\\mathrm{comm}}(p,d) = 1$\n\n最终向量为 $\\bigl((p+1)^{d},\\,1\\bigr)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} (p+1)^{d}  1 \\end{pmatrix}}$$"
        }
    ]
}