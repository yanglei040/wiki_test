{
    "hands_on_practices": [
        {
            "introduction": "算子复杂度是衡量多重网格方法效率的关键指标，它量化了粗网格算子的存储成本相对于细网格算子的比例。理想情况下，该值应接近于 1。这个练习  提供了一个分析模型，让你能够推导出算子复杂度与离散化参数（如多项式次数 $p$）和 AMG 算法参数（如聚合大小 $k$）之间的直接关系，从而揭示高阶方法中标准粗化策略面临的挑战。",
            "id": "3363047",
            "problem": "考虑一个标量、二阶、一致椭圆扩散算子，该算子定义在空间维度 $d \\in \\{2,3\\}$ 的有界域上，并通过内部罚间断伽辽金方法进行离散化，使用在具有 $N_{e}$ 个单元的拟一致网格上的多项式次数为 $p \\geq 1$ 的张量积谱基。设每个单元的局部自由度数量为张量积多项式空间的维度，即 $n_{p} = (p+1)^{d}$。由此离散化产生的细网格刚度矩阵 $A_{0}$ 是块稀疏的：假设每个单元与自身耦合，并平均与 $\\alpha$ 个相邻单元耦合（因此在稀疏模式中，每个单元有 $(\\alpha+1)$ 个稠密的 $n_{p} \\times n_{p}$ 块）。在一种使用基于聚合的粗化的代数多重网格(AMG)方法中，考虑通过将每个聚合中的 $k \\geq 1$ 个连续单元分组来形成粗聚合，并将每个聚合上的粗空间定义为分片常数（每个聚合一个粗未知量）。假设 $N_{e}$ 可被 $k$ 整除，并且聚合级的邻接关系反映了细网格级的平均情况，即聚合图具有相同的平均邻居数 $\\alpha$。仅使用这些结构性假设和定义，完成以下任务：\n\n- 推导通过每聚合 $k$ 个单元产生的粗未知量数量 $N_{c}$。\n- 从算子复杂度 $C_{\\mathrm{op}} = \\dfrac{\\mathrm{nnz}(A_{0}) + \\mathrm{nnz}(A_{1})}{\\mathrm{nnz}(A_{0})}$ 的定义出发，用 $N_{e}$、$p$、$k$、$d$ 和 $\\alpha$ 来估计 $\\mathrm{nnz}(A_{0})$ 和 $\\mathrm{nnz}(A_{1})$，并将 $C_{\\mathrm{op}}$ 简化为一个闭式表达式，该表达式明确显示 $k$ 和 $p$ 的选择如何影响算子复杂度。\n\n将您的最终答案表示为行矩阵 $\\left(N_{c},\\, C_{\\mathrm{op}}\\right)$，写成单个解析表达式。无需进行数值计算。",
            "solution": "该问题陈述已经过验证，并被确定为数值分析领域中一个适定的、有科学依据的问题。它提供了一套清晰且一致的定义和假设，足以进行所要求的推导。\n\n任务是基于所提供的用于间断伽辽金(DG)离散化的、基于聚合的代数多重网格(AMG)方法的模型，推导粗未知量数量 $N_c$ 和算子复杂度 $C_{\\mathrm{op}}$ 的表达式。\n\n首先，我们推导粗未知量的数量 $N_c$。问题指明细网格有 $N_e$ 个单元。粗化是通过创建聚合来执行的，每个聚合包含 $k \\geq 1$ 个单元。在这些聚合上，粗空间被定义为分片常数，意味着每个聚合有一个粗未知量。问题假设 $N_e$ 可被 $k$ 整除，确保单元可以完美地划分到聚合中。因此，聚合的总数，即粗未知量的数量 $N_c$，由下式给出：\n$$\nN_c = \\frac{N_e}{k}\n$$\n\n接下来，我们估计细网格刚度矩阵 $A_0$ 中的非零元数量 $\\mathrm{nnz}(A_0)$。离散化在 $d$ 维域上使用多项式次数为 $p$ 的谱基，导致每个单元有 $n_p = (p+1)^d$ 个局部自由度(DOF)。刚度矩阵 $A_0$ 是块稀疏的。根据问题陈述，“每个单元与自身耦合，并平均与 $\\alpha$ 个相邻单元耦合。” 这意味着在 $A_0$ 的块矩阵结构中，$N_e$ 个块行中的每一行平均包含 $(\\alpha+1)$ 个非零块：一个用于单元自耦合的块（对角块）和 $\\alpha$ 个用于与邻居耦合的块。问题进一步指出这些是“稠密的 $n_p \\times n_p$ 块”。一个稠密的 $n_p \\times n_p$ 块包含 $n_p^2$ 个非零元。因此，$A_0$ 中的非零元总数可以通过将单元数（对应于块行数）乘以每块行的平均非零块数和每块的非零元数来估计。\n$$\n\\mathrm{nnz}(A_0) \\approx N_e (\\alpha+1) n_p^2\n$$\n代入给定的定义 $n_p = (p+1)^d$，我们得到：\n$$\n\\mathrm{nnz}(A_0) \\approx N_e (\\alpha+1) \\left((p+1)^d\\right)^2 = N_e (\\alpha+1) (p+1)^{2d}\n$$\n\n然后，我们估计粗网格算子矩阵 $A_1$ 中的非零元数量 $\\mathrm{nnz}(A_1)$。粗算子 $A_1$ 的维度为 $N_c \\times N_c$。问题提供了一个关于其结构的关键简化假设：“聚合级的邻接关系反映了细网格级的平均情况，即聚合图具有相同的平均邻居数 $\\alpha$。” 这个假设意味着 $A_1$ 的稀疏模式类似于聚合图上的低阶离散化。$A_1$ 的每一行将有一个非零对角元（表示聚合的自相互作用）以及平均 $\\alpha$ 个非零非对角元（表示与相邻聚合的相互作用）。因此，$A_1$ 的每一行平均有 $(\\alpha+1)$ 个非零元。$A_1$ 中的非零元总数是行数 ($N_c$) 与每行平均非零元数的乘积。\n$$\n\\mathrm{nnz}(A_1) \\approx N_c (\\alpha+1)\n$$\n代入 $N_c$ 的表达式：\n$$\n\\mathrm{nnz}(A_1) \\approx \\frac{N_e}{k} (\\alpha+1)\n$$\n\n最后，我们推导算子复杂度 $C_{\\mathrm{op}}$。提供的定义是：\n$$\nC_{\\mathrm{op}} = \\frac{\\mathrm{nnz}(A_0) + \\mathrm{nnz}(A_1)}{\\mathrm{nnz}(A_0)}\n$$\n我们可以将此表达式重写为：\n$$\nC_{\\mathrm{op}} = 1 + \\frac{\\mathrm{nnz}(A_1)}{\\mathrm{nnz}(A_0)}\n$$\n代入 $\\mathrm{nnz}(A_0)$ 和 $\\mathrm{nnz}(A_1)$ 的推导估计值：\n$$\nC_{\\mathrm{op}} \\approx 1 + \\frac{\\frac{N_e}{k} (\\alpha+1)}{N_e (\\alpha+1) (p+1)^{2d}}\n$$\n$N_e$ 和 $(\\alpha+1)$ 项相互抵消，得到一个简化表达式，该表达式仅取决于聚合大小 $k$、多项式次数 $p$ 和空间维度 $d$。\n$$\nC_{\\mathrm{op}} = 1 + \\frac{\\frac{1}{k}}{(p+1)^{2d}} = 1 + \\frac{1}{k(p+1)^{2d}}\n$$\n这个结果明确了在确定多重网格算子复杂度时，聚合大小 ($k$) 的算法选择和多项式次数 ($p$) 的离散化选择之间的关系。\n\n两个最终表达式是 $N_c = \\frac{N_e}{k}$ 和 $C_{\\mathrm{op}} = 1 + \\frac{1}{k(p+1)^{2d}}$。它们按要求以行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{N_e}{k}  1 + \\frac{1}{k(p+1)^{2d}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在理解了算子复杂度的理论推导之后，我们将通过一个具体的计算来实践聚合粗化的过程。这个练习  将抽象的“聚合”概念应用于一个简单的 $2 \\times 2$ 结构化网格。通过为一个特定的面聚合策略计算聚合大小，你将能直观地理解粗网格自由度是如何从细网格实体（在此为单元面）中构建出来的，从而加深对粗化过程的认识。",
            "id": "3363005",
            "problem": "考虑一个标量椭圆算子，在二维四边形网格上使用多项式次数为 $p=4$ 的间断伽辽金（DG）方法进行离散化。在 Gauss–Lobatto 点上使用分层节点基，使得每个单元上的局部多项式空间分解为顶点模式、边模式和内部模式。具体来说，对于一个四边形单元，次数为 $p$ 的空间维度是 $(p+1)^{2}$，它分解为 $4$ 个顶点模式，$4(p-1)$ 个边模式（每个面有 $(p-1)$ 个），以及 $(p-1)^{2}$ 个内部模式。在一个采用单元-面聚合的代数多重网格（AMG）方案中，构造仅由与网格面相关的边模式组成的聚合体：对于由两个单元共享的内部面，聚合体包含来自两个相邻单元并限制在该面上的所有边模式；对于一个边界面，聚合体包含来自单个相邻单元并限制在该面上的边模式。粗层图每个聚合体有一个节点，如果两个聚合体之间存在从细层算子继承的强代数耦合，则它们之间有边；对于具有一致内部耦合和通量耦合的DG方法，一个充分条件是，如果两个聚合体的面属于同一个单元，则它们在粗糙图中是相邻的。\n\n网格是一个覆盖矩形域的结构化 $2 \\times 2$ 四边形单元阵列，划分为单元 $E_{11}$ (左上)、$E_{12}$ (右上)、$E_{21}$ (左下)和 $E_{22}$ (右下)。按如下方式标记面聚合体（粗节点）：\n- $F_{1}$：$E_{11}$ 的左边界， $F_{2}$：$E_{11}$ 的上边界， $F_{3}$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面， $F_{4}$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面，\n- $F_{5}$：$E_{12}$ 的上边界， $F_{6}$：$E_{12}$ 的右边界， $F_{7}$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面，\n- $F_{8}$：$E_{21}$ 的左边界， $F_{9}$：$E_{21}$ 的下边界， $F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面，\n- $F_{11}$：$E_{22}$ 的下边界， $F_{12}$：$E_{22}$ 的右边界。\n\n使用上述单元-面聚合规则和 DG 耦合结构，计算 $F_{i}$ 之间的粗层图邻接关系，并确定当 $p=4$ 时所有 $F_{i}$ 的最大和平均聚合体大小。将最终答案表示为一个单行矩阵中的两个数字，其中第一个条目是最大聚合体大小，第二个条目是平均聚合体大小。无需四舍五入。",
            "solution": "用户希望我解决以下问题：\n考虑一个标量椭圆算子，在二维四边形网格上使用多项式次数为 $p=4$ 的间断伽辽金（DG）方法进行离散化。在 Gauss–Lobatto 点上使用分层节点基，使得每个单元上的局部多项式空间分解为顶点模式、边模式和内部模式。具体来说，对于一个四边形单元，次数为 $p$ 的空间维度是 $(p+1)^{2}$，它分解为 $4$ 个顶点模式，$4(p-1)$ 个边模式（每个面有 $(p-1)$ 个），以及 $(p-1)^{2}$ 个内部模式。在一个采用单元-面聚合的代数多重网格（AMG）方案中，构造仅由与网格面相关的边模式组成的聚合体：对于由两个单元共享的内部面，聚合体包含来自两个相邻单元并限制在该面上的所有边模式；对于一个边界面，聚合体包含来自单个相邻单元并限制在该面上的边模式。粗层图每个聚合体有一个节点，如果两个聚合体之间存在从细层算子继承的强代数耦合，则它们之间有边；对于具有一致内部耦合和通量耦合的DG方法，一个充分条件是，如果两个聚合体的面属于同一个单元，则它们在粗糙图中是相邻的。\n\n网格是一个覆盖矩形域的结构化 $2 \\times 2$ 四边形单元阵列，划分为单元 $E_{11}$ (左上)、$E_{12}$ (右上)、$E_{21}$ (左下)和 $E_{22}$ (右下)。按如下方式标记面聚合体（粗节点）：\n- $F_{1}$：$E_{11}$ 的左边界， $F_{2}$：$E_{11}$ 的上边界， $F_{3}$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面， $F_{4}$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面，\n- $F_{5}$：$E_{12}$ 的上边界， $F_{6}$：$E_{12}$ 的右边界， $F_{7}$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面，\n- $F_{8}$：$E_{21}$ 的左边界， $F_{9}$：$E_{21}$ 的下边界， $F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面，\n- $F_{11}$：$E_{22}$ 的下边界， $F_{12}$：$E_{22}$ 的右边界。\n\n使用上述单元-面聚合规则和 DG 耦合结构，计算 $F_{i}$ 之间的粗层图邻接关系，并确定当 $p=4$ 时所有 $F_{i}$ 的最大和平均聚合体大小。将最终答案表示为一个单行矩阵中的两个数字，其中第一个条目是最大聚合体大小，第二个条目是平均聚合体大小。无需四舍五入。\n\n首先通过提取所有给定信息并评估其科学合理性、一致性和完整性来验证问题。\n\n步骤 1：提取给定信息\n- 离散化方法：间断伽辽金（DG）。\n- 算子类型：标量椭圆。\n- 网格：二维四边形网格，结构化 $2 \\times 2$ 阵列。\n- 多项式次数：$p=4$。\n- 基：在 Gauss-Lobatto 点上的分层节点基。\n- 局部多项式空间分解：$4$ 个顶点模式，$4(p-1)$ 个边模式（每个面 $(p-1)$ 个），以及 $(p-1)^2$ 个内部模式。\n- AMG 聚合策略：单元-面聚合，仅使用边模式。\n- 内部面的聚合体定义：包含来自两个相邻单元并限制在该面上的所有边模式。\n- 边界面的聚合体定义：包含来自单个相邻单元并限制在该面上的边模式。\n- 粗糙图连通性规则：如果两个聚合体的面属于同一个单元，则它们是相邻的。\n- 网格结构：$E_{11}$ (左上)、$E_{12}$ (右上)、$E_{21}$ (左下)、$E_{22}$ (右下)。\n- 面标记：$F_1, \\dots, F_{12}$ 如问题描述中定义。\n- 任务：计算粗层图邻接关系，确定最大和平均聚合体大小。\n- 最终答案格式：一个包含两个条目的行矩阵：[最大聚合体大小, 平均聚合体大小]。\n\n步骤 2：使用提取的给定信息进行验证\n问题具有科学依据，是适定的且客观的。\n- **科学依据**：该问题设置在偏微分方程数值方法这一成熟领域内，具体涉及间断伽辽金方法和代数多重网格求解器。所有概念，如分层基、Gauss-Lobatto 点、基于面的聚合和粗糙图构造，在该领域都是标准概念。\n- **适定性**：该问题提供了确定聚合体大小及其统计数据所需的所有必要信息。构造聚合体和粗糙图的规则是明确且无歧义的。该设置可导出一个唯一的、可计算的解。\n- **客观性**：语言精确且技术性强，没有主观性或歧义。定义是形式化的，不依赖于解释。\n\n步骤 3：结论和行动\n问题有效。将提供详细的解决方案。\n\n解决方案首先根据给定的多项式次数 $p$ 确定两种类型聚合体（内部面和边界面）的大小。然后，将指定的 12 个面中的每一个分类为内部或边界面，以找到其聚合体大小。最后，计算这些大小的最大值和平均值。\n\n问题指出，对于次数为 $p$ 的多项式，四边形单元的每个面都有 $(p-1)$ 个相关的边模式。给定的多项式次数为 $p=4$。因此，与单个单元面的一个边相关的边模式数量为 $p-1 = 4-1 = 3$。\n\n聚合规则取决于一个面是在域的边界上还是在内部。\n1. 对于边界面，聚合体由单个相邻单元的边模式组成。这种聚合体的大小是 $p-1$。对于 $p=4$，这个大小是 $3$。\n2. 对于一个内部面，它由两个相邻单元共享，聚合体由两个单元的边模式组成。在 DG 设置中，每个单元的自由度 (DoF) 是不同的。因此，一个内部面有两组独立的边模式自由度，每个相邻单元一组。内部面的聚合体总大小为 $(p-1) + (p-1) = 2(p-1)$。对于 $p=4$，这个大小是 $2(4-1) = 6$。\n\n接下来，我们分析指定的 $2 \\times 2$ 网格，对 12 个面中的每一个进行分类，并确定它们相应的聚合体大小。网格由四个单元组成：\n$$\n\\begin{array}{c|c}\nE_{11}  E_{12} \\\\\n\\hline\nE_{21}  E_{22}\n\\end{array}\n$$\n我们对 $i=1, \\dots, 12$ 的每个面 $F_i$ 进行分类：\n- $F_1$：$E_{11}$ 的左边界。这是一个边界面。聚合体大小 = $3$。\n- $F_2$：$E_{11}$ 的上边界。这是一个边界面。聚合体大小 = $3$。\n- $F_3$：$E_{11}$ 和 $E_{12}$ 之间的内部垂直面。这是一个内部面。聚合体大小 = $6$。\n- $F_4$：$E_{11}$ 和 $E_{21}$ 之间的内部水平面。这是一个内部面。聚合体大小 = $6$。\n- $F_5$：$E_{12}$ 的上边界。这是一个边界面。聚合体大小 = $3$。\n- $F_6$：$E_{12}$ 的右边界。这是一个边界面。聚合体大小 = $3$。\n- $F_7$：$E_{12}$ 和 $E_{22}$ 之间的内部水平面。这是一个内部面。聚合体大小 = $6$。\n- $F_8$：$E_{21}$ 的左边界。这是一个边界面。聚合体大小 = $3$。\n- $F_9$：$E_{21}$ 的下边界。这是一个边界面。聚合体大小 = $3$。\n- $F_{10}$：$E_{21}$ 和 $E_{22}$ 之间的内部垂直面。这是一个内部面。聚合体大小 = $6$。\n- $F_{11}$：$E_{22}$ 的下边界。这是一个边界面。聚合体大小 = $3$。\n- $F_{12}$：$E_{22}$ 的右边界。这是一个边界面。聚合体大小 = $3$。\n\n从这个分类中，我们观察到有 $4$ 个内部面（$F_3, F_4, F_7, F_{10}$）和 $8$ 个边界面（$F_1, F_2, F_5, F_6, F_8, F_9, F_{11}, F_{12}$）。\n\n所有聚合体大小的集合是 $\\{3, 3, 6, 6, 3, 3, 6, 3, 3, 6, 3, 3\\}$。\n\n我们现在可以计算所需的统计数据。\n最大聚合体大小是该集合中的最大值：\n$$\n\\text{最大大小} = \\max(\\{3, 6\\}) = 6\n$$\n平均聚合体大小是所有聚合体大小的总和除以聚合体总数，即 $12$。\n大小之和计算如下：\n$$\n\\text{大小之和} = (8 \\times \\text{边界面聚合体大小}) + (4 \\times \\text{内部面聚合体大小})\n$$\n$$\n\\text{大小之和} = (8 \\times 3) + (4 \\times 6) = 24 + 24 = 48\n$$\n平均聚合体大小为：\n$$\n\\text{平均大小} = \\frac{\\text{大小之和}}{\\text{聚合体数量}} = \\frac{48}{12} = 4\n$$\n\n该问题还要求计算粗层图邻接关系。规则是，如果两个聚合体的面属于同一个单元，则它们是相邻的。这意味着对于每个单元，其四个面对应的聚合体形成一个完全子图 ($K_4$) 。\n- 单元 $E_{11}$ 连接面 $\\{F_1, F_2, F_3, F_4\\}$。\n- 单元 $E_{12}$ 连接面 $\\{F_3, F_5, F_6, F_7\\}$。\n- 单元 $E_{21}$ 连接面 $\\{F_4, F_8, F_9, F_{10}\\}$。\n- 单元 $E_{22}$ 连接面 $\\{F_7, F_{10}, F_{11}, F_{12}\\}$。\n此邻接结构按要求确定，但它不是最终数值答案的一部分。最终答案只需要最大和平均聚合体大小。\n\n最终答案是一个包含最大聚合体大小和平均聚合体大小的行矩阵。\n最大大小 = $6$。\n平均大小 = $4$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix}\n6  4\n\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "对于非常高的多项式次数，标准的粗化策略可能无法有效地近似细网格上的所有关键误差分量，从而导致多重网格收敛性差。这个编程练习  引导你进行一个数值实验，以诊断这种常见的失败模式：低阶粗空间无法捕捉某些内部“气泡”模式。你将通过编写代码来识别这些难以近似的本征模，并实施一种“空间丰富”策略来解决这个问题，从而量化改进效果。",
            "id": "3363022",
            "problem": "要求您为应用于极高阶多项式谱元和间断Galerkin离散化的代数多重网格设计并实现一种诊断方法，重点关注粗糙空间未能捕捉某些谱分量的失效模式。目标是识别单元局部算子的哪些广义特征模态被低阶粗糙空间表示得不好，并证明通过用少量内部气泡模态来丰富粗糙空间可以减少这种缺陷。\n\n考虑参考单元 $\\left[-1,1\\right]$ 上的一维泊松算子，在 $x=-1$ 和 $x=1$ 处具有齐次Dirichlet边界条件。使用谱元法，采用 $p$ 次多项式的Legendre–Gauss–Lobatto (LGL) 节点，其中 $p\\geq 12$。令 $N=p$ 表示多项式表示中的子区间数量，从而得到 $N+1$ 个LGL节点 $\\{x_i\\}_{i=0}^{N}$ 和相应的求积权重 $\\{w_i\\}_{i=0}^{N}$。在这些节点上使用标准的Lagrange基本基。通过LGL求积构建质量矩阵 $M$ 和刚度矩阵 $K$：\n- $M = \\operatorname{diag}(w_0,\\dots,w_N)$，\n- $K = D^\\top W D$，其中 $W=\\operatorname{diag}(w_0,\\dots,w_N)$ 且 $D$ 是微分矩阵，其元素为 $D_{ij} = \\phi_j'(x_i)$，其中 $\\{\\phi_j\\}$ 是Lagrange基多项式。\n\n通过限制于对应节点 $i=1,\\dots,N-1$ 的内部自由度来施加齐次Dirichlet边界条件，从而生成大小为 $(N-1)\\times(N-1)$ 的简化矩阵 $M_{\\mathrm{int}}$ 和 $K_{\\mathrm{int}}$。考虑广义特征问题\n$$\nK_{\\mathrm{int}} v = \\lambda M_{\\mathrm{int}} v,\n$$\n并令 $\\{(\\lambda_k,v_k)\\}_{k=1}^{N-1}$ 表示其特征对，按特征值非递减顺序排列，特征向量为 $M_{\\mathrm{int}}$-正交归一。\n\n通过 $p$-粗化到多项式次数 $r$（其中 $1  r  p$）来定义粗糙空间。粗糙空间由 $r$ 次多项式的内部LGL节点上的Lagrange基函数构成。您的任务是实现一个Python函数`run_diagnostic(p, r, m, b, epsilon)`，该函数执行以下操作：\n1.  对于给定的多项式次数 `p`，构造内部矩阵 $K_{\\mathrm{int}}$ 和 $M_{\\mathrm{int}}$。\n2.  求解广义特征问题以获得前 `m` 个特征向量 $\\{v_k\\}_{k=1}^{m}$。\n3.  对于给定的粗糙多项式次数 `r`，构造扩张（prolongation）算子 $P$，该算子将粗糙空间基函数插值到细网格节点上。\n4.  对于前 `m` 个细网格特征向量中的每一个 $v_k$，计算其到粗糙空间的 $M_{\\mathrm{int}}$-正交投影，$ \\pi_c(v_k) $。计算残差的 $M_{\\mathrm{int}}$-范数 $\\lVert v_k - \\pi_c(v_k) \\rVert_{M_{\\mathrm{int}}}$。如果范数大于 `epsilon`，则认为该模态被“遗漏”。计算遗漏模态的总数。\n5.  通过向粗糙空间添加 `b` 个“气泡”函数来丰富粗糙空间。这些气泡函数是通过识别所有细网格特征向量中具有最大投影误差（残差范数）的 `b` 个来选择的。将这些残差向量本身（在经过 $M_{\\mathrm{int}}$-正交化后）作为额外的粗糙基函数。\n6.  使用这个丰富的粗糙空间重新计算前 `m` 个特征向量的遗漏模态数。\n7.  返回一个包含两个整数的列表：`[miss_count_before, miss_count_after]`。\n\n将您的函数应用于以下测试用例，并以 `[[a1,a2],[b1,b2],...]` 的格式打印结果列表，其中 `[a1,a2]` 是测试用例A的结果等。\n- **A**: `p=12, r=2, m=6, b=2, epsilon=0.25`\n- **B**: `p=12, r=10, m=6, b=0, epsilon=0.25`\n- **C**: `p=16, r=3, m=8, b=3, epsilon=0.25`\n- **D**: `p=12, r=2, m=6, b=6, epsilon=0.25`",
            "solution": "### 问题验证\n\n#### 第1步：提取已知条件\n\n问题提供了以下数据和定义：\n- **算子和域**：参考单元 $\\left[-1,1\\right]$ 上的一维泊松算子，在 $x=-1$ 和 $x=1$ 处具有齐次Dirichlet边界条件。\n- **离散化**：谱元法，采用 $p$ 次多项式的Legendre–Gauss–Lobatto (LGL) 节点，其中 $p \\ge 12$。子区间数量为 $N=p$，有 $N+1$ 个LGL节点 $\\{x_i\\}_{i=0}^{N}$ 和相应的求积权重 $\\{w_i\\}_{i=0}^{N}$。基函数由这些节点上的Lagrange基本基函数 $\\{\\phi_j\\}$ 组成。\n- **矩阵**：\n    - 质量矩阵：$M = \\operatorname{diag}(w_0,\\dots,w_N)$。\n    - 刚度矩阵：$K = D^\\top W D$，其中 $W=\\operatorname{diag}(w_0,\\dots,w_N)$ 且 $D$ 是微分矩阵，其元素为 $D_{ij} = \\phi_j'(x_i)$。\n- **边界条件**：齐次Dirichlet边界条件，通过限制于内部自由度（节点 $i=1,\\dots,N-1$）来施加，得到大小为 $(N-1)\\times(N-1)$ 的矩阵 $M_{\\mathrm{int}}$ 和 $K_{\\mathrm{int}}$。\n- **广义特征问题**：$K_{\\mathrm{int}} v = \\lambda M_{\\mathrm{int}} v$，其特征对为 $\\{(\\lambda_k,v_k)\\}_{k=1}^{N-1}$，按特征值 $\\lambda_k$ 非递减顺序排列，特征向量 $v_k$ 为 $M_{\\mathrm{int}}$-正交归一。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom numpy.polynomial.legendre import Legendre\n\ndef lgl_points_weights(p):\n    \"\"\"\n    Computes Legendre-Gauss-Lobatto (LGL) nodes and weights for a given polynomial degree p.\n    \"\"\"\n    if p == 0:\n        return np.array([0.0]), np.array([2.0])\n    if p == 1:\n        return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n\n    # Interior nodes are the roots of the derivative of the Legendre polynomial of degree p.\n    leg_p = Legendre.basis(p)\n    leg_p_deriv = leg_p.deriv(1)\n    # Roots can be complex due to precision, take real part.\n    int_nodes = np.sort(leg_p_deriv.roots().real)\n    nodes = np.concatenate(([-1.0], int_nodes, [1.0]))\n\n    # LGL weights formula\n    leg_p_vals_at_nodes = leg_p(nodes)\n    weights = 2 / (p * (p + 1) * leg_p_vals_at_nodes**2)\n    \n    return nodes, weights\n\ndef lagrange_deriv_matrix(p, nodes):\n    \"\"\"\n    Computes the 1D spectral differentiation matrix for LGL nodes.\n    \"\"\"\n    N = p\n    D = np.zeros((N + 1, N + 1))\n    leg_p = Legendre.basis(N)\n    p_vals = leg_p(nodes)\n\n    # Off-diagonal entries\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = p_vals[i] / (p_vals[j] * (nodes[i] - nodes[j]))\n    \n    # Diagonal entries\n    D[0, 0] = -N * (N + 1) / 4.0\n    D[N, N] = N * (N + 1) / 4.0\n    # Interior diagonal entries are 0, which is the default.\n    \n    return D\n\ndef evaluate_lagrange_basis(nodes_eval, nodes_basis, j):\n    \"\"\"\n    Evaluates the j-th Lagrange basis polynomial defined on nodes_basis at points nodes_eval.\n    l_j(x) = product_{k!=j} (x - x_k) / (x_j - x_k)\n    \"\"\"\n    xj = nodes_basis[j]\n    other_nodes = np.delete(nodes_basis, j)\n    # Using np.newaxis for broadcasting to evaluate for all nodes_eval at once\n    numerator = np.prod(nodes_eval[:, np.newaxis] - other_nodes, axis=1)\n    denominator = np.prod(xj - other_nodes)\n    return numerator / denominator\n\ndef run_diagnostic(p, r, m, b, epsilon):\n    \"\"\"\n    Runs the full diagnostic procedure for a given set of parameters.\n    \"\"\"\n    # 1. Construct matrices for fine grid (degree p)\n    N = p\n    fine_nodes, fine_weights = lgl_points_weights(N)\n    D_fine = lagrange_deriv_matrix(N, fine_nodes)\n    \n    M = np.diag(fine_weights)\n    K = D_fine.T @ M @ D_fine\n    \n    # Impose Dirichlet BCs by restricting to interior nodes\n    M_int = np.diag(fine_weights[1:N])\n    K_int = K[1:N, 1:N]\n    \n    # 2. Solve generalized eigenproblem K_int v = lambda M_int v\n    # eigh returns M_int-orthonormal eigenvectors, sorted by eigenvalue.\n    eigenvalues, eigenvectors = eigh(K_int, M_int)\n    \n    # 3. Define coarse space and prolongation matrix P\n    fine_interior_nodes = fine_nodes[1:N]\n    num_fine_interior = N - 1\n    \n    coarse_nodes, _ = lgl_points_weights(r)\n    num_coarse_interior = r - 1\n\n    if num_coarse_interior > 0:\n        P = np.zeros((num_fine_interior, num_coarse_interior))\n        for j_coarse in range(num_coarse_interior):\n            # Coarse interior basis function indices are 1 to r-1\n            P[:, j_coarse] = evaluate_lagrange_basis(fine_interior_nodes, coarse_nodes, j_coarse + 1)\n    else:\n        P = np.zeros((num_fine_interior, 0))\n\n    # 4. Compute miss count before enrichment\n    if P.shape[1] > 0:\n        coarse_mass = P.T @ M_int @ P\n        coarse_mass_inv = np.linalg.inv(coarse_mass)\n    \n    miss_count_before = 0\n    for k in range(m):\n        vk = eigenvectors[:, k]\n        if P.shape[1] > 0:\n            pi_c_vk = P @ (coarse_mass_inv @ (P.T @ (M_int @ vk)))\n        else: # Empty coarse space\n            pi_c_vk = np.zeros_like(vk)\n        \n        residual = vk - pi_c_vk\n        norm_sq = residual.T @ M_int @ residual\n        norm = np.sqrt(max(0, norm_sq)) # Clamp to avoid sqrt of small negative floats\n        if norm > epsilon:\n            miss_count_before += 1\n\n    # 5. Enrichment and miss count after\n    if b == 0:\n        return [miss_count_before, miss_count_before]\n\n    # Select b enrichment vectors from residuals of all modes\n    all_residuals = []\n    all_norms_sq = []\n    for k in range(num_fine_interior):\n        vk = eigenvectors[:, k]\n        if P.shape[1] > 0:\n            pi_c_vk = P @ (coarse_mass_inv @ (P.T @ (M_int @ vk)))\n        else:\n            pi_c_vk = np.zeros_like(vk)\n        qk = vk - pi_c_vk\n        norm_sq = qk.T @ M_int @ qk\n        all_residuals.append(qk)\n        all_norms_sq.append(max(0, norm_sq))\n    \n    indices_to_enrich = np.argsort(all_norms_sq)[-b:]\n    enrichment_vectors = [all_residuals[i] for i in indices_to_enrich]\n    \n    # M_int-Gram-Schmidt orthonormalization\n    B = np.zeros((num_fine_interior, b))\n    for i in range(b):\n        u_i = enrichment_vectors[i].copy()\n        for j in range(i):\n            bj = B[:, j]\n            # Orthogonal projection: u_i -= (u_i^T M b_j) b_j\n            proj = (u_i.T @ M_int @ bj) * bj\n            u_i -= proj\n        \n        norm_ui_sq = u_i.T @ M_int @ u_i\n        if norm_ui_sq > 1e-20:\n            B[:, i] = u_i / np.sqrt(norm_ui_sq)\n\n    # Enriched prolongation and projection\n    P_enr = np.hstack([P, B])\n    \n    M_enr_coarse = P_enr.T @ M_int @ P_enr\n    M_enr_coarse_inv = np.linalg.inv(M_enr_coarse)\n\n    miss_count_after = 0\n    for k in range(m):\n        vk = eigenvectors[:, k]\n        pi_enr_vk = P_enr @ (M_enr_coarse_inv @ (P_enr.T @ (M_int @ vk)))\n        \n        residual = vk - pi_enr_vk\n        norm_sq = residual.T @ M_int @ residual\n        norm = np.sqrt(max(0, norm_sq))\n        if norm > epsilon:\n            miss_count_after += 1\n            \n    return [miss_count_before, miss_count_after]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (12, 2, 6, 2, 0.25),   # Test A\n        (12, 10, 6, 0, 0.25),  # Test B\n        (16, 3, 8, 3, 0.25),   # Test C\n        (12, 2, 6, 6, 0.25),   # Test D\n    ]\n\n    results = []\n    for params in test_cases:\n        p, r, m, b, epsilon = params\n        result = run_diagnostic(p, r, m, b, epsilon)\n        results.append(result)\n\n    # Format output as specified: [[a1,a2],[b1,b2],...] with no spaces\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}