{
    "hands_on_practices": [
        {
            "introduction": "掌握指数积分器的最佳途径是亲手实践。本练习将指导您为一个典型的一维对流扩散方程的间断伽辽金（DG）半离散系统，实现一个二阶Lawson方法。通过这个过程，您将学习如何将控制方程分解为刚性线性部分和非刚性部分，并利用快速傅里叶变换（FFT）高效计算矩阵指数的作用，这是处理具有周期边界条件的平移不变算子的关键技巧。",
            "id": "3386153",
            "problem": "考虑定义在周期性区间 $[0,1]$ 上的一维线性平流-扩散偏微分方程，\n$$\nu_t + a\\,u_x = \\nu\\,u_{xx},\n$$\n其中平流速度 $a \\in \\mathbb{R}$ 和扩散系数 $\\nu \\ge 0$ 均为常数。使用包含 $K$ 个宽度为 $h = 1/K$ 的单元的均匀网格对空间域进行离散化，并令 $u_j(t)$ 表示在单元 $j$ ($j=0,1,\\dots,K-1$) 中对 $u$ 的单元常数近似（$p=0$ 阶的分段多项式）。使用周期性边界条件，即索引运算在模 $K$ 下进行。\n\n该方程在 $p=0$ 阶的间断伽辽金（DG）半离散化可以使用界面上的平流和扩散数值通量来构建。将界面 $j+\\tfrac{1}{2}$ 处的平流迎风数值通量定义为\n$$\nF^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) =\n\\begin{cases}\na\\,u_j,  \\text{if } a \\ge 0,\\\\\na\\,u_{j+1},  \\text{if } a  0,\n\\end{cases}\n$$\n并将扩散的中心梯度数值通量定义为\n$$\nF^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) = -\\nu\\,\\frac{u_{j+1}-u_j}{h}.\n$$\n那么单元 $j$（使用周期性索引）中的半离散守恒方程为\n$$\n\\frac{d}{dt}u_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(u)\\right) - \\frac{1}{h}\\left(F^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{diff}}_{j-\\frac{1}{2}}(u)\\right).\n$$\n这产生了一个向量形式的常微分方程组，\n$$\n\\frac{d}{dt}\\mathbf{u} = L\\,\\mathbf{u} + N(\\mathbf{u}),\n$$\n其中：\n- $\\mathbf{u} \\in \\mathbb{R}^K$ 汇集了 $K$ 个单元值 $u_j$，\n- $L \\in \\mathbb{R}^{K \\times K}$ 是源于扩散通量的线性扩散算子，具体为\n$$\n(L\\,\\mathbf{u})_j = \\nu\\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2},\n$$\n其中周期性环绕 $u_{-1} \\equiv u_{K-1}$ 和 $u_K \\equiv u_0$,\n- $N(\\mathbf{u}) \\in \\mathbb{R}^K$ 通过迎风数值通量编码了显式平流的贡献，\n$$\nN(\\mathbf{u})_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(\\mathbf{u}) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(\\mathbf{u})\\right).\n$$\n\n您的任务是为半离散系统 $\\,\\mathbf{u}' = L\\,\\mathbf{u} + N(\\mathbf{u})\\,$ 实现一个二阶 Lawson 方法的单时间步长，通过仅使用矩阵指数 $e^{\\Delta t\\,L}$ 对向量的作用以及数值平流通量 $N(\\cdot)$ 的求值来表达算法。所使用的二阶方法是在 Lawson 变量下构建的显式中点 Runge–Kutta 格式。您不能假设任何超出上述定义的简化，并且您的实现必须适用于任何 $K \\ge 3$、任何实数 $a$、任何 $\\nu \\ge 0$ 以及任何 $\\Delta t > 0$。\n\n使用以下测试套件，其中初始条件通过在单元中心 $x_j = (j+\\tfrac{1}{2})h$ 处采样 $u(x,0) = \\sin(2\\pi x)$ 来定义：\n1. $K = 64$, $a = 1.0$, $\\nu = 0.05$, $\\Delta t = 10^{-3}$。\n2. $K = 64$, $a = 0.0$, $\\nu = 0.05$, $\\Delta t = 10^{-3}$。\n3. $K = 64$, $a = 3.0$, $\\nu = 0.0$, $\\Delta t = 10^{-1}$。\n\n对于这三个测试用例中的每一个，从给定的初始条件开始，在执行恰好一个 Lawson 步长后，计算并报告以下标量：\n- 对于情况 1：更新后解的离散 $L^2$ 范数，定义为\n$$\n\\left\\|\\mathbf{u}\\right\\|_{2,h} = \\sqrt{h\\,\\sum_{j=0}^{K-1} u_j^2}.\n$$\n- 对于情况 2：您的 Lawson 更新与纯扩散更新 $e^{\\Delta t\\,L}\\,\\mathbf{u}$ 之间差值的离散 $L^2$ 范数，即\n$$\n\\sqrt{h\\,\\sum_{j=0}^{K-1} \\left(u^{\\mathrm{Lawson}}_j - u^{\\mathrm{diffusion}}_j\\right)^2}.\n$$\n- 对于情况 3：更新后解在所有单元上的最大绝对值，$\\max_{0 \\le j \\le K-1} |u_j|$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含三个结果，以逗号分隔并用方括号括起来（例如，“[result1,result2,result3]”），并严格按照上述测试用例的顺序排列。不应打印任何额外的文本。不涉及任何物理单位或角度单位；所有量均为无量纲实数。",
            "solution": "该问题要求使用二阶指数积分器为半离散平流-扩散方程实现单时间步长的计算。常微分方程组由下式给出\n$$ \\frac{d\\mathbf{u}}{dt} = L\\mathbf{u} + N(\\mathbf{u}) $$\n其中 $L$ 是表示扩散的线性算子，而 $N(\\mathbf{u})$ 是表示平流的（在此情况下为线性的）算子。这种分裂将包含由 $1/h^2$ 缩放的导数的刚性扩散项分离到线性部分 $L\\mathbf{u}$ 中，该部分将由矩阵指数精确处理。\n\n#### 二阶 Lawson-中点方法\n\nLawson 方法通过变量变换来滤除线性部分的快速动态。令 $\\mathbf{v}(t) = e^{-tL} \\mathbf{u}(t)$。对时间 $t$ 求导，得到 $\\mathbf{v}$ 的变换后常微分方程：\n$$ \\frac{d\\mathbf{v}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} \\frac{d\\mathbf{u}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} (L\\mathbf{u}(t) + N(\\mathbf{u}(t))) = e^{-tL} N(e^{tL} \\mathbf{v}(t)) $$\n我们使用显式中点 Runge-Kutta 方法，从时间 $t_n$ 的 $\\mathbf{v}_n$ 开始，对这个变换后的方程求解一个时间步长 $\\Delta t$。为简单起见，我们设 $t_n=0$，因此 $\\mathbf{v}_0 = \\mathbf{u}_n$。中点方法如下：\n1. 计算起始点的斜率：\n    $ \\mathbf{k}_1 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=0} = e^{-0\\cdot L} N(e^{0\\cdot L} \\mathbf{v}_0) = N(\\mathbf{u}_n) $\n2.  走半步以找到中点状态：\n    $ \\mathbf{v}_{mid} = \\mathbf{v}_0 + \\frac{\\Delta t}{2} \\mathbf{k}_1 = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n) $\n3.  使用状态 $\\mathbf{v}_{mid}$ 在中点时间 $t=\\Delta t/2$ 评估斜率：\n    $ \\mathbf{k}_2 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=\\Delta t/2, \\mathbf{v}=\\mathbf{v}_{mid}} = e^{-\\frac{\\Delta t}{2}L} N(e^{\\frac{\\Delta t}{2}L} \\mathbf{v}_{mid}) $\n    代入 $\\mathbf{v}_{mid}$：\n    $ \\mathbf{k}_2 = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L} \\left(\\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)\\right)\\right) = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\n4.  使用中点斜率 $\\mathbf{k}_2$ 走一个完整步长：\n    $ \\mathbf{v}_{n+1} = \\mathbf{v}_0 + \\Delta t \\mathbf{k}_2 = \\mathbf{u}_n + \\Delta t e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\n最后，我们变换回原始变量 $\\mathbf{u}_{n+1}$：\n$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{v}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t e^{\\Delta t L} e^{-\\frac{\\Delta t}{2}L} N\\left( \\dots \\right) $\n这简化为最终的更新公式：\n$$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t\\, e^{\\frac{\\Delta t}{2} L} N\\left(e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2} L} N(\\mathbf{u}_n)\\right) $$\n这是一个二阶精度的指数 Runge-Kutta 方法。\n\n#### 实现策略\n\n**1. 算子 $L$ 和 $N$**\n线性算子 $L$ 代表 $\\nu \\frac{\\partial^2}{\\partial x^2}$ 的周期性中心差分近似。其矩阵表示是一个循环矩阵。\n算子 $N(\\mathbf{u})$ 可以明确写出。对于 $a \\ge 0$，迎风通量为 $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 - 1/2} = a u_{j \\text{ 或 } j-1}$。\n$$ N(\\mathbf{u})_j = -\\frac{a}{h} (u_j - u_{j-1}) $$\n对于 $a  0$，迎风通量为 $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 + 1/2} = a u_{j+1 \\text{ 或 } j}$。\n$$ N(\\mathbf{u})_j = -\\frac{a}{h} (u_{j+1} - u_j) $$\n这些操作可以使用向量移位（例如 `numpy.roll`）来高效实现。\n\n**2. 矩阵指数的作用**\n矩阵指数 $e^{\\tau L}$ 对向量 $\\mathbf{v}$ 的作用可以在傅里叶空间中高效计算。由于 $L$ 是一个循环矩阵，它可以被离散傅里叶变换（DFT）对角化。算子 $L$ 对应于第 $k$ 个傅里叶模式 $e^{2\\pi i k x}$ 的特征值为：\n$$ \\lambda_k = -\\frac{4\\nu}{h^2} \\sin^2\\left(\\frac{\\pi k}{K}\\right), \\quad k = 0, 1, \\dots, K-1 $$\n作用 $e^{\\tau L}\\mathbf{v}$ 通过以下步骤计算：\n1.  计算向量 $\\mathbf{v}$ 的 DFT：$\\hat{\\mathbf{v}} = \\text{DFT}(\\mathbf{v})$。\n2.  将每个分量 $\\hat{v}_k$ 乘以相应的指数因子 $e^{\\tau \\lambda_k}$。\n3.  计算结果的逆 DFT：$\\mathbf{w} = \\text{IDFT}(e^{\\tau \\Lambda} \\hat{\\mathbf{v}})$。\n这个过程非常高效，避免了显式构造和求矩阵 $L$ 的指数。\n\n**3. 算法步骤**\n要从 $\\mathbf{u}_n$ 计算 $\\mathbf{u}_{n+1}$：\n1.  计算初始状态的平流项：$N_n = N(\\mathbf{u}_n)$。\n2.  用线性算子将 $\\mathbf{u}_n$ 和 $N_n$ 演化半个时间步长：\n    - $\\mathbf{v}_1 = e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n$\n    - $\\mathbf{v}_2 = e^{\\frac{\\Delta t}{2} L} N_n$\n3.  形成中间状态 $\\mathbf{u}_{mid}$：\n    - $\\mathbf{u}_{mid} = \\mathbf{v}_1 + \\frac{\\Delta t}{2} \\mathbf{v}_2$\n4.  计算中间状态的平流项：$N_{mid} = N(\\mathbf{u}_{mid})$。\n5.  用线性算子将 $\\mathbf{u}_n$ 演化一个完整时间步长，将 $N_{mid}$ 演化半个时间步长：\n    - $\\mathbf{v}_3 = e^{\\Delta t L} \\mathbf{u}_n$（这可以计算为 $e^{\\frac{\\Delta t}{2} L} \\mathbf{v}_1$）\n    - $\\mathbf{v}_4 = e^{\\frac{\\Delta t}{2} L} N_{mid}$\n6.  组合以形成最终结果：\n    - $\\mathbf{u}_{n+1} = \\mathbf{v}_3 + \\Delta t \\, \\mathbf{v}_4$\n\n**4. 特殊测试用例**\n- **情况 2 ($a=0$):** 在此情况下，$N(\\mathbf{u}) \\equiv \\mathbf{0}$。Lawson-中点公式简化为 $\\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n$，这是纯扩散方程 $\\mathbf{u}' = L\\mathbf{u}$ 的精确解。因此，$\\mathbf{u}^{\\mathrm{Lawson}}$ 与 $\\mathbf{u}^{\\mathrm{diffusion}}$ 相同，它们的差值范数为零。\n- **情况 3 ($\\nu=0$):** 在此情况下，扩散算子 $L \\equiv \\mathbf{0}$，因此其特征值全为零。矩阵指数变为单位算子：$e^{\\tau L} = I$。Lawson-中点公式简化为纯平流方程 $\\mathbf{u}' = N(\\mathbf{u})$ 的标准显式中点 Runge-Kutta 方法：\n  - $\\mathbf{u}_{mid} = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)$\n  - $\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t N(\\mathbf{u}_{mid})$\n该实现将自然地处理这些情况，无需特殊的代码路径，这可作为对通用算法的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the second-order Lawson method.\n    \"\"\"\n    test_cases = [\n        {'K': 64, 'a': 1.0, 'nu': 0.05, 'dt': 1e-3, 'task': 1},\n        {'K': 64, 'a': 0.0, 'nu': 0.05, 'dt': 1e-3, 'task': 2},\n        {'K': 64, 'a': 3.0, 'nu': 0.0,  'dt': 1e-1, 'task': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_one_case(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\ndef run_one_case(K, a, nu, dt, task):\n    \"\"\"\n    Sets up and solves a single test case.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    h = 1.0 / K\n    x = (np.arange(K) + 0.5) * h\n    u0 = np.sin(2 * np.pi * x)\n\n    # 2. Perform one step of the Lawson-Midpoint method\n    u1 = lawson_midpoint_step(u0, K, a, nu, dt, h)\n    \n    # 3. Compute the required metric for the task\n    if task == 1:\n        # Discrete L2 norm ||u||_{2,h}\n        return np.sqrt(h * np.sum(u1**2))\n    elif task == 2:\n        # L2 norm of the difference ||u_lawson - u_diffusion||_{2,h}\n        # For a=0, N=0, and the Lawson method should reduce to the exact solution\n        # of the linear part. The difference should be zero up to machine precision.\n        u_diffusion = exp_L_action(u0, dt, K, nu, h)\n        diff = u1 - u_diffusion\n        return np.sqrt(h * np.sum(diff**2))\n    elif task == 3:\n        # Max absolute value max|u|\n        return np.max(np.abs(u1))\n    else:\n        raise ValueError(\"Invalid task number.\")\n\ndef lawson_midpoint_step(u_n, K, a, nu, dt, h):\n    \"\"\"\n    Performs one step of the second-order Lawson method (based on explicit midpoint RK).\n    u_{n+1} = exp(dt*L)u_n + dt*exp(dt/2*L)*N(exp(dt/2*L)u_n + dt/2*exp(dt/2*L)N(u_n))\n    \"\"\"\n    \n    # Define the nonlinear advection operator N(u)\n    def N(u, a_val, h_val):\n        if a_val >= 0:\n            # Upwind flux difference for a >= 0\n            flux_diff = u - np.roll(u, 1)\n        else:\n            # Upwind flux difference for a  0\n            flux_diff = np.roll(u, -1) - u\n        return -a_val / h_val * flux_diff\n        \n    # --- Algorithm Steps ---\n    \n    # 1. Compute initial nonlinear term\n    N_n = N(u_n, a, h)\n    \n    # 2. Evolve u_n and N_n by a half-step under the linear operator L\n    u_n_half_evolved = exp_L_action(u_n, dt / 2.0, K, nu, h)\n    N_n_half_evolved = exp_L_action(N_n, dt / 2.0, K, nu, h)\n    \n    # 3. Form the intermediate state for the midpoint evaluation\n    u_mid = u_n_half_evolved + (dt / 2.0) * N_n_half_evolved\n    \n    # 4. Evaluate nonlinear term at the intermediate state\n    N_mid = N(u_mid, a, h)\n    \n    # 5. Evolve u_n by a full step and N_mid by a half-step\n    # We can reuse u_n_half_evolved to get the full-step evolution\n    # exp(dt*L)u_n = exp(dt/2*L) * exp(dt/2*L)u_n\n    u_n_full_evolved = exp_L_action(u_n_half_evolved, dt / 2.0, K, nu, h)\n    N_mid_half_evolved = exp_L_action(N_mid, dt / 2.0, K, nu, h)\n    \n    # 6. Combine to form the final solution\n    u_np1 = u_n_full_evolved + dt * N_mid_half_evolved\n    \n    return u_np1\n\ndef exp_L_action(v, tau, K, nu, h):\n    \"\"\"\n    Computes the action of the matrix exponential exp(tau*L) on a vector v\n    using the Fourier spectral method.\n    \"\"\"\n    # If nu=0, L is the zero matrix, so exp(tau*L) is the identity\n    if nu == 0.0:\n        return v\n    \n    # Calculate eigenvalues of the operator L in Fourier space.\n    # fftfreq provides the correct frequency ordering for numpy's FFT.\n    # The term k/K in the sin argument corresponds to freq*h, where freq are the wavenumbers.\n    k_indices = fftfreq(K) * K\n    lambda_k = -4.0 * nu / h**2 * np.sin(np.pi * k_indices / K)**2\n    \n    # Apply the operator in Fourier space\n    v_hat = fft(v)\n    v_hat_evolved = np.exp(tau * lambda_k) * v_hat\n    v_evolved = ifft(v_hat_evolved)\n    \n    # The result should be real since the operator and input are real.\n    return np.real(v_evolved)\n\nsolve()\n```"
        },
        {
            "introduction": "虽然快速傅里叶变换对特定结构的矩阵非常有效，但通用问题需要更普适的求解器。本练习要求您实现并比较两种计算矩阵指数函数的先进算法：Chebyshev多项式逼近与基于轮廓积分的预处理Neumann级数。通过为一个模拟DG离散的典型块结构矩阵评估这两种方法的成本与精度，您将深入理解在不同参数（如多项式阶数$p$和时间步长$h$）下，不同算法的性能权衡与适用范围。",
            "id": "3386143",
            "problem": "考虑一个半离散刚性系统，该系统源于使用具有代表性的分块结构间断伽辽金 (DG) 方法离散化的一维扩散算子。该半离散系统写作 $u'(t) = A u(t)$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是对称负半定矩阵。对于时间步长为 $h > 0$ 的指数积分器，其基本对象是矩阵指数 $\\exp(hA)$。您将从成本和精度的角度比较两种逼近 $\\exp(hA)$ 的方法。\n\n类 DG 刚度矩阵 $A$ 的构造如下。设区域被划分为 $E$ 个大小相等的单元，每个单元大小为 $\\ell = 1/E$。对于多项式次数 $p \\geq 1$，每个单元贡献一个大小为 $s = p + 1$ 的块，因此 $N = s E$。使用由 $j = 0, 1, \\dots, p$ 索引的模态基，定义扩散系数为 $\\nu > 0$ 的局部贡献：\n$$\nb_j = -\\nu \\left(\\frac{\\pi j}{\\ell}\\right)^2,\n$$\n其中 $b_0 = 0$。设罚参数为 $\\gamma = \\sigma \\frac{(p+1)^2}{\\ell^2}$，其中 $\\sigma > 0$。将 $A$ 组装成一个带有单元分块的块三对角周期矩阵：\n- 单元 $i$ 处的对角块：$A_{i,i} = \\mathrm{diag}(b_0,\\dots,b_p) - 2\\gamma I_s$，\n- 非对角相邻块：$A_{i,i+1} = \\gamma I_s$ 和 $A_{i,i-1} = \\gamma I_s$，\n其中索引周期性回绕，$I_s$ 是 $s \\times s$ 的单位矩阵。这种构造产生一个对称负半定矩阵 $A$，其刚度缩放与 DG 扩散算子一致。\n\n您将实现并比较 $\\exp(hA)$ 的两种近似方法：\n\n1. 在线性映射谱上的切比雪夫多项式逼近：\n   - 通过盖尔什戈林圆盘定理估计包含 $A$ 的特征值的谱区间 $[a,b]$：\n     $$\n     a = \\min_i \\left(A_{ii} - \\sum_{j \\neq i} |A_{ij}|\\right), \\quad b = \\max_i \\left(A_{ii} + \\sum_{j \\neq i} |A_{ij}|\\right).\n     $$\n   - 定义仿射映射 $A = c_0 I + c_1 X$，其中 $c_0 = \\frac{a+b}{2}$，$c_1 = \\frac{b-a}{2}$ 且 $X = \\frac{A - c_0 I}{c_1}$，使得 $X$ 的谱位于 $[-1,1]$ 内。\n   - 使用 $[-1,1]$ 上 $f(x) = \\exp(\\alpha x)$ 的切比雪夫级数，其中 $\\alpha = h c_1$：\n     $$\n     \\exp(\\alpha x) \\approx \\sum_{k=0}^{n} a_k T_k(x), \\quad a_0 = I_0(\\alpha), \\quad a_k = 2 I_k(\\alpha), \\; k \\geq 1,\n     $$\n     其中 $T_k$ 是第一类切比雪夫多项式，$I_k$ 是第一类修正贝塞尔函数。因此，\n     $$\n     \\exp(hA) \\approx \\exp(h c_0) \\sum_{k=0}^{n} a_k T_k(X).\n     $$\n   - 实现 $T_k(X)$ 的递推关系 $T_0 = I$, $T_1 = X$, $T_{k+1} = 2 X T_k - T_{k-1}$。\n\n2. 围线积分表示内的预处理截断诺伊曼级数：\n   - 使用矩阵指数的柯西积分公式：\n     $$\n     \\exp(hA) = \\frac{1}{2\\pi i} \\oint_{\\Gamma} \\exp(h z) (z I - A)^{-1} \\, dz,\n     $$\n     其中 $\\Gamma$ 是复平面上包围 $A$ 的谱的圆。将 $\\Gamma$ 参数化为 $z(\\theta) = c + r e^{i\\theta}$，$0 \\leq \\theta  2\\pi$，其中圆心为 $c = \\frac{a+b}{2}$，半径为 $r = \\eta \\frac{b-a}{2}$，并使用一个安全因子 $\\eta > 1$。在 $\\theta$ 上使用梯形法则（角度以弧度为单位），积分简化为\n     $$\n     \\exp(hA) \\approx \\frac{1}{L} \\sum_{\\ell=0}^{L-1} \\exp\\big(h z_\\ell\\big) \\, (z_\\ell I - A)^{-1} \\, r e^{i\\theta_\\ell}, \\quad \\theta_\\ell = \\frac{2\\pi \\ell}{L}, \\; z_\\ell = c + r e^{i\\theta_\\ell}.\n     $$\n   - 通过使用一个块对角预处理器 $M$（其等于 $A$ 的对角块结构）的截断诺伊曼级数来逼近每个求解式 $(z_\\ell I - A)^{-1}$：\n     $$\n     M = \\mathrm{blkdiag}(A_{0,0}, A_{1,1}, \\dots, A_{E-1,E-1}), \\quad K = A - M.\n     $$\n     观察到 $(z I - A)^{-1} = (I - (z I - M)^{-1} K)^{-1} (z I - M)^{-1}$，使用\n     $$\n     (z I - A)^{-1} \\approx \\left[\\sum_{k=0}^{m} B^k\\right] (z I - M)^{-1}, \\quad B = (z I - M)^{-1} K,\n     $$\n     前提是 $B$ 的谱半径小于 $1$；此处 $m \\geq 0$ 是截断阶数。对 $(z I - M)$ 的求逆是按单元逐块进行的，这在计算上比对整个矩阵求逆要便宜。\n\n基于相对弗罗贝尼乌斯范数定义精度容差 $\\varepsilon = 10^{-6}$：\n$$\n\\mathrm{err} = \\frac{\\|\\widehat{E} - \\exp(hA)\\|_F}{\\|\\exp(hA)\\|_F},\n$$\n其中 $\\widehat{E}$ 是近似值。定义以下操作计数成本模型（无单位代理）：\n- 切比雪夫方法成本：\n  $$\n  C_{\\mathrm{Ch}} = n \\, N^3,\n  $$\n  其中 $n$ 是使用的最终多项式次数（$X \\cdot T_k$ 乘法的次数）。\n- 围线-诺伊曼方法每个求积节点的成本：\n  $$\n  C_{\\mathrm{node}} = E s^3 + (m+2) N^3,\n  $$\n  包括块对角求逆 $E s^3$、$B$ 的形成、$m$ 次幂运算以及最终的乘法。总成本为\n  $$\n  C_{\\mathrm{CN}} = L \\, C_{\\mathrm{node}}.\n  $$\n\n对于每个测试用例，为每种方法选择达到 $\\mathrm{err} \\leq \\varepsilon$ 的最低成本配置。如果两种方法都达到容差，则选择成本严格较小的方法。如果只有一种方法达到容差，则选择该方法。如果在探索的参数范围内两种方法都未达到容差，则报告失败。\n\n没有物理单位；所有量都是无量纲的，并且围线参数化中的角度必须以弧度处理。使用以下常量和测试套件：\n- 固定参数：$E = 6$，$\\nu = 1$，$\\sigma = 0.5$，安全因子 $\\eta = 1.3$。\n- 多项式次数：$p \\in \\{1, 3, 5\\}$。\n- 时间步长：$h \\in \\{10^{-3}, 5 \\cdot 10^{-2}, 2 \\cdot 10^{-1}\\}$。\n- 围线-诺伊曼参数网格：$L \\in \\{8, 16\\}$ 和 $m \\in \\{0, 1, 2, 3, 4\\}$。\n- 切比雪夫最大次数：$n_{\\max} = 50$。\n\n所有 $9$ 个测试用例的最终输出必须是单行，包含一个整数列表，每个测试用例一个整数，顺序遵循 $p$ 和 $h$ 列表的笛卡尔积：\n- 如果切比雪夫方法最优，则为 $0$，\n- 如果围线-诺伊曼方法最优，则为 $1$，\n- 如果在搜索空间内两者都未达到容差，则为 $-1$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\dots,\\mathrm{result}_9]$。",
            "solution": "用户提供了一个数值分析领域中定义明确的问题，具体涉及评估由间断伽辽金 (DG) 离散化产生的刚性系统的矩阵指数。该问题具有科学依据、形式化规范，并要求比较两种成熟的数值方法：切比雪夫多项式逼近和带有预处理诺伊曼级数的围线积分方法。\n\n在进行求解之前，需要对问题陈述进行验证。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n\n- **系统**：半离散系统 $u'(t) = A u(t)$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是对称负半定矩阵。\n- **矩阵 A**：一个由 $E$ 个单元、多项式次数 $p \\ge 1$、扩散系数 $\\nu > 0$ 和罚标度 $\\sigma > 0$ 构造的分块三对角周期矩阵。总大小为 $N = (p+1)E$。\n  - 单元大小：$\\ell = 1/E$。块大小：$s = p+1$。\n  - 局域谱贡献：$b_j = -\\nu (\\frac{\\pi j}{\\ell})^2$，其中 $j=0, \\dots, p$，且 $b_0=0$。\n  - 罚参数：$\\gamma = \\sigma \\frac{(p+1)^2}{\\ell^2}$。\n  - 块：$A_{i,i} = \\mathrm{diag}(b_0, \\dots, b_p) - 2\\gamma I_s$，以及 $A_{i,i\\pm1} = \\gamma I_s$（周期性）。\n- **方法 1 (切比雪夫)**：在一个线性映射的谱区间 $[a,b]$ 上，使用 $n$ 次截断切比雪夫级数逼近 $\\exp(hA)$。\n  - 谱界：$a = \\min_i (A_{ii} - \\sum_{j \\neq i} |A_{ij}|)$，$b = \\max_i (A_{ii} + \\sum_{j \\neq i} |A_{ij}|)$。\n  - 逼近：$\\exp(hA) \\approx \\exp(h c_0) \\sum_{k=0}^{n} a_k T_k(X)$，其中 $X=(A-c_0I)/c_1$，$c_0=\\frac{a+b}{2}$，$c_1=\\frac{b-a}{2}$。\n  - 系数：$a_0 = I_0(\\alpha)$，$a_k = 2I_k(\\alpha)$ (当 $k \\ge 1$ 时)，其中 $\\alpha=hc_1$。$I_k$ 是修正贝塞尔函数。\n- **方法 2 (围线-诺伊曼)**：通过在圆形围线 $\\Gamma$ 上的离散化柯西积分进行逼近。\n  - 离散化：在 $\\Gamma$ 上使用 $L$ 点梯形法则，$\\Gamma$ 是一个圆心为 $c=\\frac{a+b}{2}$、半径为 $r=\\eta\\frac{b-a}{2}$ 的圆（$\\eta>1$ 是安全因子）。\n  - 求解式逼近：使用一个块对角预处理器 $M = \\mathrm{blkdiag}(A_{0,0}, \\dots, A_{E-1,E-1})$ 和一个 $m$ 阶截断诺伊曼级数来逼近 $(zI-A)^{-1}$。\n- **评估标准**：\n  - 精度：相对弗罗贝尼乌斯范数误差 $\\mathrm{err} \\le \\varepsilon = 10^{-6}$，其中 $\\widehat{E}$ 是逼近值，参考值是 $\\exp(hA)$。\n  - 成本：$C_{\\mathrm{Ch}} = n N^3$ 和 $C_{\\mathrm{CN}} = L (E s^3 + (m+2) N^3)$。\n- **选择逻辑**：在满足精度容差的方法中，选择成本严格较低者。如果只有一个成功，则选择它。如果两者都未成功，则报告失败。\n- **参数**：\n  - 固定参数：$E=6, \\nu=1, \\sigma=0.5, \\eta=1.3$。\n  - 搜索网格：$p \\in \\{1, 3, 5\\}$，$h \\in \\{10^{-3}, 5 \\cdot 10^{-2}, 2 \\cdot 10^{-1}\\}$，$n \\in [1, 50]$，$L \\in \\{8, 16\\}$，$m \\in \\{0, \\dots, 4\\}$。\n- **输出**：一个包含 $9$ 个测试用例结果的整数列表（$0$：切比雪夫方法，$1$：围线-诺伊曼方法，$-1$：失败）。\n\n**第 2 步：已知条件验证**\n\n1.  **科学合理性**：该问题根植于数值线性代数和微分方程数值方法研究的有效原理。矩阵 $A$ 的构造是一个合法（尽管简化）的 DG 离散化模型。可以验证 $A$ 是对称负半定的，其特征值为 $\\lambda_{j,k} = b_j - 2\\gamma(1-\\cos(2\\pi k/E)) \\le 0$。切比雪夫方法和围线积分方法是计算矩阵函数的标准技术。所有公式都是正确的。\n2.  **适定性**：该问题是适定的。它提供了所有必要信息、一个明确的目标（找到更好的方法）、明确定义的约束（精度）和一个有限的参数搜索空间。根据给定的逻辑，可以为每种情况获得唯一的答案。\n3.  **客观性**：问题以精确的数学语言陈述，没有主观性或模糊性。\n\n**第 3 步：结论**\n\n问题陈述是**有效的**。它自成体系、科学合理且算法上明确。我将继续生成解决方案。\n\n### 算法解决方案\n\n该解决方案涉及对由 $p \\in \\{1, 3, 5\\}$ 和 $h \\in \\{10^{-3}, 5 \\cdot 10^{-2}, 2 \\cdot 10^{-1}\\}$ 的笛卡尔积定义的 $9$ 个测试用例的参数空间进行系统性探索。对于每种情况，执行以下步骤：\n\n1.  **矩阵和参考解的构造**：\n    对于给定的 $(p, h)$，根据其定义组装刚度矩阵 $A$。矩阵的维度是 $N=(p+1)E$。作为误差计算参考解的“精确”矩阵指数 $\\exp(hA)$，是使用高保真算法（具体为 `scipy.linalg.expm`）计算的。预先计算此参考矩阵的弗罗贝尼乌斯范数，以用于相对误差的计算。\n\n2.  **谱界计算**：\n    包含 $A$ 的特征值的谱区间 $[a,b]$ 是使用提供的盖尔什戈林圆盘定理公式确定的。由于 $A$ 是对称的，其特征值是实数。盖尔什戈林圆盘在实轴上变成区间。基于 $A$ 的结构的直接分析得出 $a = -\\nu(\\frac{\\pi p}{\\ell})^2 - 4\\sigma\\frac{(p+1)^2}{\\ell^2}$ 和 $b=0$。这两个界限用于两种逼近方法。\n\n3.  **切比雪夫方法评估**：\n    目标是找到最小的多项式次数 $n \\in [1, 50]$，使得逼近值 $\\widehat{E}_{\\mathrm{Ch}}$ 满足精度容差 $\\varepsilon = 10^{-6}$。\n    该方法包括：\n    a. 将矩阵 $A$ 仿射映射到 $X = (A - c_0 I)/c_1$，使得 $X$ 的谱在 $[-1, 1]$ 内。\n    b. 使用第一类修正贝塞尔函数 $I_k(\\alpha)$ 计算切比雪夫系数 $a_k$，其中 $\\alpha = h c_1$。\n    c. 从 $n=1$ 开始的迭代过程。在每一步中，将下一项 $a_n T_n(X)$ 添加到总和中。切比雪夫多项式 $T_n(X)$ 通过三项递推关系 $T_{k+1}(X) = 2XT_k(X) - T_{k-1}(X)$ 生成。\n    d. 一旦对于某个次数 $n$ 满足了容差，循环就终止。成本记录为 $C_{\\mathrm{Ch}} = n N^3$。如果对于任何 $n \\le 50$ 都未满足容差，则认为该方法在此测试用例中失败。\n\n4.  **围线-诺伊曼方法评估**：\n    目标是从提供的网格（$L \\in \\{8, 16\\}$，$m \\in \\{0, \\dots, 4\\}$）中找到满足精度容差且成本尽可能低的参数对 $(L, m)$。\n    该方法包括：\n    a. 在圆形围线 $\\Gamma$ 上的 $L$ 个点 $z_\\ell$ 进行数值求积循环。\n    b. 在每个点 $z_\\ell$，必须逼近矩阵求解式 $(z_\\ell I - A)^{-1}$。这是通过使用预处理的诺伊曼级数来完成的。\n    c. 预处理器 $M$ 是 $A$ 的块对角部分。其逆 $(z_\\ell I - M)^{-1}$ 是通过对 $E$ 个大小为 $s \\times s$ 的小块进行求逆来高效计算的。\n    d. 迭代矩阵是 $B = (z_\\ell I - M)^{-1} K$，其中 $K = A - M$ 是 $A$ 的块非对角部分。然后，求解式通过 $[\\sum_{k=0}^{m} B^k] (z_\\ell I - M)^{-1}$ 来逼近。\n    e. 将所有求积点的贡献相加，形成最终的逼近值 $\\widehat{E}_{\\mathrm{CN}}$。\n    f. 对于每个满足容差的对 $(L,m)$，计算成本 $C_{\\mathrm{CN}} = L (E s^3 + (m+2) N^3)$。存储这些成本中的最小值。如果没有一对参数满足容差，则该方法失败。\n\n5.  **决策**：\n    根据两种方法的成功与否及其最低成本，按照问题规则做出决策：如果两者都成功，成本严格较小者胜出。如果一个失败，另一个胜出。如果两者都失败，则为失败。结果记录为 $0$（切比雪夫）、$1$（围线-诺伊曼）或 $-1$（失败）。对所有 $9$ 个测试用例重复此过程，并汇总结果。",
            "answer": "```python\n# The complete and runnable Python 3 code that solves the problem.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.special import iv\n\ndef solve():\n    \"\"\"\n    Main function to run the comparison of exponential integrator approximation methods.\n    \"\"\"\n\n    def assemble_A(p, E, nu, sigma):\n        \"\"\"\n        Constructs the block-tridiagonal periodic stiffness matrix A.\n        \"\"\"\n        s = p + 1\n        N = s * E\n        ell = 1.0 / E\n        gamma = sigma * (p + 1)**2 / ell**2\n        \n        j_vals = np.arange(p + 1)\n        b_j = -nu * (np.pi * j_vals / ell)**2\n        \n        A_ii = np.diag(b_j) - 2 * gamma * np.eye(s)\n        A_ij = gamma * np.eye(s)\n        \n        A = np.zeros((N, N))\n        \n        for i in range(E):\n            slc_i = slice(i * s, (i + 1) * s)\n            A[slc_i, slc_i] = A_ii\n            \n            j_plus = (i + 1) % E\n            j_minus = (i - 1 + E) % E\n            \n            slc_j_plus = slice(j_plus * s, (j_plus + 1) * s)\n            slc_j_minus = slice(j_minus * s, (j_minus + 1) * s)\n            \n            A[slc_i, slc_j_plus] = A_ij\n            A[slc_i, slc_j_minus] = A_ij\n            \n        return A\n\n    def get_spectral_bounds_analytic(p, E, nu, sigma):\n        \"\"\"\n        Analytically computes the Gershgorin spectral bounds [a, b].\n        \"\"\"\n        ell = 1.0 / E\n        gamma = sigma * (p + 1)**2 / ell**2\n        b_p = -nu * (np.pi * p / ell)**2\n        a = b_p - 4 * gamma\n        b = 0.0\n        return a, b\n\n    def chebyshev_method(A, h, a, b, n_max, E_ref, E_ref_norm, tolerance):\n        \"\"\"\n        Computes exp(hA) via Chebyshev approximation and returns (success, min_cost).\n        \"\"\"\n        N = A.shape[0]\n        c0 = (a + b) / 2.0\n        c1 = (b - a) / 2.0\n        \n        if abs(c1)  1e-14:\n            E_hat = np.exp(h * c0) * np.eye(N)\n            err = np.linalg.norm(E_hat - E_ref, 'fro') / E_ref_norm\n            cost = 1 * (N**3)\n            if err = tolerance:\n                return True, cost\n            else:\n                return False, np.inf\n\n        X = (A - c0 * np.eye(N)) / c1\n        alpha = h * c1\n        \n        k_vals = np.arange(n_max + 1)\n        a_k_coeffs = 2 * iv(k_vals, alpha)\n        a_k_coeffs[0] = iv(0, alpha)\n\n        T0 = np.eye(N)\n\n        # n = 0\n        S_n = a_k_coeffs[0] * T0\n        \n        # n = 1\n        T1 = X\n        S_n += a_k_coeffs[1] * T1\n        E_hat = np.exp(h * c0) * S_n\n        err = np.linalg.norm(E_hat - E_ref, 'fro') / E_ref_norm\n        if err = tolerance:\n            return True, 1 * (N**3)\n        \n        # n >= 2\n        for n in range(2, n_max + 1):\n            T_next = 2 * X @ T1 - T0\n            T0, T1 = T1, T_next\n            S_n += a_k_coeffs[n] * T_next\n            \n            E_hat = np.exp(h * c0) * S_n\n            err = np.linalg.norm(E_hat - E_ref, 'fro') / E_ref_norm\n            \n            if err = tolerance:\n                cost = n * (N**3)\n                return True, cost\n                \n        return False, np.inf\n\n    def contour_neumann_method(A, h, a, b, eta, p, E, L_vals, m_vals, E_ref, E_ref_norm, tolerance):\n        \"\"\"\n        Computes exp(hA) via preconditioned contour integral method and returns (success, min_cost).\n        \"\"\"\n        s = p + 1\n        N = A.shape[0]\n        \n        c = (a + b) / 2.0\n        r = eta * (b - a) / 2.0\n        \n        M = np.zeros_like(A)\n        for i in range(E):\n            slc = slice(i * s, (i + 1) * s)\n            M[slc, slc] = A[slc, slc]\n        K = A - M\n\n        min_cost = np.inf\n        success = False\n        \n        for L in L_vals:\n            for m in m_vals:\n                total_sum = np.zeros((N, N), dtype=np.complex128)\n                \n                for l_idx in range(L):\n                    theta = 2.0 * np.pi * l_idx / L\n                    z = c + r * np.exp(1j * theta)\n                    \n                    inv_zI_minus_M = np.zeros((N, N), dtype=np.complex128)\n                    for i in range(E):\n                        slc = slice(i * s, (i + 1) * s)\n                        block = z * np.eye(s) - M[slc, slc]\n                        inv_zI_minus_M[slc, slc] = np.linalg.inv(block)\n\n                    B = inv_zI_minus_M @ K\n                    \n                    B_powers_sum = np.eye(N, dtype=np.complex128)\n                    B_k = np.copy(B_powers_sum)\n                    for _ in range(m):\n                        B_k = B_k @ B\n                        B_powers_sum += B_k\n                    \n                    resolvent_approx = B_powers_sum @ inv_zI_minus_M\n                    integrand_factor = np.exp(h * z) * r * np.exp(1j * theta)\n                    total_sum += integrand_factor * resolvent_approx\n\n                E_hat = np.real(total_sum / L)\n                err = np.linalg.norm(E_hat - E_ref, 'fro') / E_ref_norm\n                \n                if err = tolerance:\n                    cost = L * (E * s**3 + (m + 2) * N**3)\n                    min_cost = min(min_cost, cost)\n                    success = True\n        \n        return success, min_cost\n\n    # -- Main execution --\n    # Fixed parameters from the problem statement\n    E = 6\n    nu = 1.0\n    sigma = 0.5\n    eta = 1.3\n    tolerance = 1e-6\n    n_max = 50\n    L_vals = [8, 16]\n    m_vals = [0, 1, 2, 3, 4]\n    \n    # Test cases defined by the Cartesian product of p and h\n    p_vals = [1, 3, 5]\n    h_vals = [1e-3, 5e-2, 2e-1]\n    \n    test_cases = []\n    for p in p_vals:\n        for h in h_vals:\n            test_cases.append({'p': p, 'h': h})\n            \n    results = []\n\n    for case in test_cases:\n        p = case['p']\n        h = case['h']\n        \n        A = assemble_A(p, E, nu, sigma)\n        E_ref = expm(h * A)\n        E_ref_norm = np.linalg.norm(E_ref, 'fro') if np.linalg.norm(E_ref, 'fro') > 0 else 1.0\n        \n        a, b = get_spectral_bounds_analytic(p, E, nu, sigma)\n\n        ch_success, ch_cost = chebyshev_method(A, h, a, b, n_max, E_ref, E_ref_norm, tolerance)\n        cn_success, cn_cost = contour_neumann_method(A, h, a, b, eta, p, E, L_vals, m_vals, E_ref, E_ref_norm, tolerance)\n\n        if ch_success and not cn_success:\n            results.append(0)\n        elif not ch_success and cn_success:\n            results.append(1)\n        elif not ch_success and not cn_success:\n            results.append(-1)\n        elif ch_success and cn_success:\n            if ch_cost  cn_cost:\n                results.append(0)\n            else:\n                results.append(1)\n        else: # Should not happen in this problem\n             results.append(-1)\n             \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "轮廓积分法不仅适用于计算矩阵指数$\\exp(hA)$，也同样适用于指数积分器中出现的其他$\\varphi$函数，如$\\varphi_1(hA)$。然而，来自DG方法的矩阵特征值常常分布在相距甚远的集群中，这给标准轮廓积分法的效率带来了挑战。本练习将引导您设计并实现一种自适应的谱划分策略，即为不同的特征值集群使用各自最优化的积分围线，并量化该策略相对于单一积分围线所带来的效率提升。",
            "id": "3386179",
            "problem": "考虑在指数积分器中出现的矩阵函数，即函数 $\\varphi_1(z)$，其定义为当 $z \\neq 0$ 时 $\\varphi_1(z) = \\frac{e^{z} - 1}{z}$，当 $z=0$ 时 $\\varphi_1(0) = 1$。我们关注它在一个由时间步长 $h > 0$ 缩放的矩阵 $A$ 上的作用，即 $\\varphi_1(h A)$。在谱方法和间断 Galerkin (DG) 方法的背景下，稳定化项和数值通量通常会产生刚度矩阵 $A$，其特征值为实数、负数，并且可能由于罚参数和网格尺寸缩放而分裂成具有不同数量级的簇，这是 DG 稳定化中一个有据可查的现象。对于一个解析函数 $f$，$f(A)$ 的一个鲁棒且通用的表示由 Dunford–Taylor 积分给出\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz,\n$$\n其中 $\\Gamma$ 是一个包围 $A$ 的谱的正向围道，而 $i$ 是虚数单位。对于 $f(z) = \\varphi_1(h z)$，这给出了 $\\varphi_1(h A)$ 的一个围道积分表示。在圆形围道 $\\Gamma: z(\\theta) = c + R e^{i \\theta}$（其中 $\\theta \\in [0, 2\\pi)$）上使用梯形法则来近似这个积分，会得到一个形如下式的求积：\n$$\n\\varphi_1(h A)\\, b \\approx \\sum_{k=0}^{M-1} w_k \\, \\big(z_k I - A\\big)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}, \\quad \\theta_k = \\frac{2\\pi k}{M},\n$$\n其权重为\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\n这里 $b$ 是一个给定的向量。对于周期解析被积函数，梯形法则表现出指数收敛性；然而，当 $A$ 的谱分布在多个数量级迥异的簇上时，一个包围整个谱的单一圆形围道可能需要一个很大的半径（这可能导致围道穿过 $\\operatorname{Re}(z)$ 接近 $0$ 或为正的区域，从而引起 $e^{h z}$ 的增长并降低效率），或者相对于预解式 $(z I - A)^{-1}$ 的极点位置可能变得不均衡。泛函演算中的一个经典方法是将围道划分为不相交的子围道 $\\Gamma = \\Gamma_1 \\cup \\Gamma_2$，这些子围道包围谱的不相交部分；然后，可加性\n$$\n\\frac{1}{2\\pi i} \\int_{\\Gamma} f(z) (z I - A)^{-1} dz = \\sum_{j} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} f(z) (z I - A)^{-1} dz\n$$\n允许使用适应于其局部谱子集的围道来计算每个积分。这里将这种方法称为谱划分。\n\n您的任务是：评估对于具有由间断 Galerkin (DG) 稳定化引起的特征值聚类特性的矩阵 $A$，基于求积的 $\\varphi_1(h A)\\, b$ 计算的一致性和效率，并实现一种谱划分策略，该策略能自动将谱分裂为两个簇，并为每个簇分配一个独立的圆形围道以提高求积效率。\n\n使用的基本原理：\n- 用于解析函数 $f$ 的矩阵函数的 Dunford–Taylor 表示。\n- 通过指数函数定义的 $\\varphi_1(z)$。\n- 梯形法则对周期解析被积函数的基本收敛性质。\n- 分块指数恒等式：如果 $M = \\begin{bmatrix} h A  I \\\\ 0  0 \\end{bmatrix}$，那么 $\\exp(M) = \\begin{bmatrix} \\exp(h A)  \\varphi_1(h A) \\\\ 0  I \\end{bmatrix}$，所以右上角的分块等于 $\\varphi_1(h A)$。\n\n设计要求：\n- 构造测试矩阵 $A$，这些矩阵是对角矩阵，具有实的负特征值，排列成两个簇，以模拟 DG 稳定化产生的聚类。对于每个测试案例，$A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，其中 $n = 60$，向量 $b \\in \\mathbb{R}^n$ 的所有分量 $b_i = 1$。\n- 在圆形围道 $\\Gamma: z(\\theta) = c + R e^{i \\theta}$ 上实现求积，权重和节点如上文所述，其中 $M \\ge 8$ 为整数。\n- 实现一个谱划分算法，该算法：\n  1. 对特征值的实部进行排序，并找到最大的连续间隙以将它们分裂成两个簇。\n  2. 对于每个簇，定义一个圆心为 $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$、半径为 $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$ 的圆，其中扩张因子 $\\alpha = 1.3$。\n  3. 如果 $c_j + R_j \\ge 0$，则向左移动圆心，使得 $c_j + R_j = -1$，以将围道严格保持在开放的左半平面内，从而控制 $e^{h z}$。\n  4. 通过对两个围道上的贡献求和来近似 $\\varphi_1(h A) b$。\n- 定义一个单圆策略，该策略使用与全谱相同的圆心-半径公式和相同的左移保障措施。\n- 对于这两种策略，在候选集 $\\{8, 16, 32, 64, 128\\}$ 中确定能够达到相对 $\\ell^2$-误差小于或等于容差 $\\varepsilon = 10^{-8}$ 的最小 $M$。参考解通过上述的分块指数恒等式，使用一个大小为 $2n \\times 2n$ 的矩阵的指数来计算。\n\n需实现的数值细节：\n- 使用 $n = 60$ 且对所有 $i$ 有 $b_i = 1$。\n- 对于每个簇，从区间 $[\\text{center} - \\frac{\\text{width}}{2}, \\text{center} + \\frac{\\text{width}}{2}]$ 中均匀抽取 $30$ 个特征值。\n- 为避免相消，当 $\\lvert z \\rvert \\le 10^{-6}$ 时，使用级数 $\\varphi_1(z) = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ 来稳健地实现 $\\varphi_1$。\n- 相对误差定义为 $\\frac{\\lVert y_{\\text{approx}} - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}$。\n\n测试套件：\n- 案例 1：簇中心为 $-10$ 和 $-200$，宽度为 $1$ 和 $10$，且 $h = 0.1$。\n- 案例 2：簇中心为 $-50$ 和 $-5000$，宽度为 $5$ 和 $50$，且 $h = 0.05$。\n- 案例 3：簇中心为 $-100$ 和 $-150$，宽度为 $2$ 和 $2$，且 $h = 0.2$。\n\n对于每个案例，计算效率比\n$$\n\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}},\n$$\n其中 $M_{\\text{single}}$ 是单圆策略达到容差所需的最少节点数，$M_{\\text{partition}}$ 是划分策略达到相同容差所需的最少节点数。如果某个策略在候选集内未能达到容差，则使用该策略测试过的最大 $M$ 值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按给定顺序包含三个测试案例的效率比 $\\rho$，表示为浮点数，例如 $[\\rho_1,\\rho_2,\\rho_3]$。",
            "solution": "我们从矩阵解析函数的 Dunford–Taylor 表示开始。对于一个解析标量函数 $f$，作用于一个矩阵 $A$（其谱被一个正向围道 $\\Gamma$ 包围）的算子 $f(A)$ 由下式给出\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz.\n$$\n选择 $f(z) = \\varphi_1(h z)$ 可得\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\n为了计算其对向量 $b$ 的作用，我们写出\n$$\n\\varphi_1(h A)\\, b = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, b \\, dz.\n$$\n我们用 $z(\\theta) = c + R e^{i \\theta}$（其中 $\\theta \\in [0, 2\\pi)$）来参数化一个圆形围道，此时 $dz = i R e^{i \\theta} d\\theta$。使用具有 $M$ 个节点 $\\theta_k = \\frac{2\\pi k}{M}$ 的梯形法则进行离散化，可以得到一个对周期解析被积函数的指数收敛近似：\n$$\n\\varphi_1(h A) \\, b \\approx \\sum_{k=0}^{M-1} w_k \\,(z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k},\n$$\n其权重通过代入 $dz$ 和 $1/(2\\pi i)$ 因子得到：\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\n对于解析周期函数，梯形法则的误差以 $e^{-a M}$ 的速度衰减，其中 $a$ 是复 $\\theta$-平面上解析带的半宽度。对于一个包围了预解式在 $A$ 的特征值处的极点的圆形围道，$\\theta$-平面上最近的奇点发生在 $z(\\theta)$ 解析延拓到特征值时，这导致带的宽度大约为 $\\log\\!\\big(\\frac{R}{r_{\\max}}\\big)$，其中 $r_{\\max}$ 是被包围的极点（特征值）到圆心的最大距离。因此，如果我们选择 $R = \\alpha r_{\\max}$，其中 $\\alpha > 1$ 是一个适度的扩张因子，我们得到的带宽度为 $\\log(\\alpha)$，收敛速度为指数级 $\\sim e^{-\\log(\\alpha) M}$。然而，如果整个谱跨越了相距很远的多个簇，将一个单一的圆包围整个谱会迫使圆心和半径在两个簇之间取得平衡，这可能将圆的一部分推向虚轴，甚至进入右半平面。由于 $\\varphi_1(h z)$ 继承了 $e^{h z}$ 的行为，$\\operatorname{Re}(z)$ 接近或大于 $0$ 的偏移会需要更大的 $M$ 来控制误差。\n\n谱划分通过将谱划分为不相交的子集 $\\{\\sigma_1(A), \\sigma_2(A)\\}$ 并使用分别只包围一个子集的独立围道 $\\Gamma_1, \\Gamma_2$ 来解决这个问题。根据 Dunford–Taylor 积分的线性和围道的可加性，我们有\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma_1 \\cup \\Gamma_2} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz = \\sum_{j=1}^{2} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\n每个 $\\Gamma_j$ 被选择为仅包围 $\\sigma_j(A)$，这使得圆心可以靠近簇，并使用适度的半径扩张因子 $\\alpha$，同时保持整个圆在左半平面内，从而确保 $\\operatorname{Re}(z) \\ll 0$ 并控制 $\\varphi_1(h z)$。\n\n参考计算与一致性。为了评估求积的一致性（准确性），我们需要一个可靠的基准真相。利用分块指数恒等式，\n$$\n\\exp\\!\\left( \\begin{bmatrix} h A  I \\\\ 0  0 \\end{bmatrix} \\right) = \\begin{bmatrix} \\exp(h A)  \\varphi_1(h A) \\\\ 0  I \\end{bmatrix},\n$$\n我们可以将 $\\varphi_1(h A)$ 计算为 $\\exp(M)$ 的 $(1,2)$ 分块，其中 $M$ 是增广矩阵。这种方法避免了对 $A$ 求逆，并且即使 $A$ 是奇异的也仍然有效。对于给定的 $b$，我们通过构建 $M$，使用稳定的算法计算 $\\exp(M)$，并提取适当的分块来计算 $y_{\\text{ref}} = \\varphi_1(h A)\\, b$。在实践中，当 $A$ 是大小为 $n = 60$ 的对角矩阵时，增广矩阵的大小为 $2n \\times 2n$，这在数值上是可控的。\n\n算法设计。\n1. 矩阵和向量的构建。对于每个测试案例，构建 $A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$，其中特征值排列成两个簇。对于簇 $j \\in \\{1,2\\}$，从区间 $[\\mu_j - \\frac{w_j}{2}, \\mu_j + \\frac{w_j}{2}]$ 中均匀采样 $n/2$ 个特征值，其中 $\\mu_j  0$ 是簇中心，$w_j > 0$ 是簇宽度。设置 $b \\in \\mathbb{R}^n$ 且对所有 $i$ 有 $b_i=1$。\n2. 稳健的 $\\varphi_1$。实现 $\\varphi_1(z)$，使得当 $\\lvert z \\rvert \\le 10^{-6}$ 时，使用泰勒级数 $\\varphi_1(z) \\approx 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ 以避免在 $(e^z - 1)/z$ 中出现灾难性相消。\n3. 单圆策略。计算 $c = \\frac{\\lambda_{\\min} + \\lambda_{\\max}}{2}$ 和 $R = \\alpha \\frac{\\lambda_{\\max} - \\lambda_{\\min}}{2}$，其中 $\\alpha = 1.3$。如果 $c + R \\ge 0$，则向左移动 $c$ 以强制 $c + R = -1$，从而使圆位于左半平面。对于一个候选的 $M$，近似\n$$\ny_{\\text{single}}(M) = \\sum_{k=0}^{M-1} \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k)\\, (z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}.\n$$\n4. 谱划分。按实部对特征值进行排序，并找到连续项之间的最大间隙。在此间隙处分裂成两个簇。对于每个簇 $j$，设置 $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$ 和 $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$，使用相同的 $\\alpha = 1.3$，并通过在必要时移动到 $c_j + R_j = -1$ 来强制 $c_j + R_j  0$。计算\n$$\ny_{\\text{part}}(M) = \\sum_{j=1}^{2} \\sum_{k=0}^{M-1} \\frac{R_j e^{i \\theta_k}}{M} \\, \\varphi_1(h z_{j,k})\\, (z_{j,k} I - A)^{-1} b, \\quad z_{j,k} = c_j + R_j e^{i \\theta_k}.\n$$\n5. 参考解。构建 $M = \\begin{bmatrix} h A  I \\\\ 0  0 \\end{bmatrix}$ 并计算 $\\exp(M)$。提取 $(1,2)$ 分块得到 $\\varphi_1(h A)$，并计算 $y_{\\text{ref}} = \\varphi_1(h A) b$。\n6. 误差和最小 $M$。对于每种策略和候选集 $\\{8, 16, 32, 64, 128\\}$ 中的每个 $M$，计算相对 $\\ell^2$-误差\n$$\nE(M) = \\frac{\\lVert y_{\\text{approx}}(M) - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}.\n$$\n选择使得 $E(M) \\le \\varepsilon$（其中 $\\varepsilon = 10^{-8}$）的最小 $M$。如果没有满足容差的，则选择最大的 $M$。\n7. 效率比。对于每个测试案例，计算 $\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}}$。\n\n测试套件定义。我们采用三个案例，其中 $n = 60$ 且 $b_i = 1$：\n- 案例 1：簇中心 $\\mu_1 = -10$, $\\mu_2 = -200$，宽度 $w_1 = 1$, $w_2 = 10$，且 $h = 0.1$。\n- 案例 2：簇中心 $\\mu_1 = -50$, $\\mu_2 = -5000$，宽度 $w_1 = 5$, $w_2 = 50$，且 $h = 0.05$。\n- 案例 3：簇中心 $\\mu_1 = -100$, $\\mu_2 = -150$，宽度 $w_1 = 2$, $w_2 = 2$，且 $h = 0.2$。\n\n科学原理。间断 Galerkin 稳定化，例如内部罚分项，会产生其特征值与网格尺寸的负幂成比例的离散算子，这导致了大的负值簇。围道积分方法与这种刚度兼容，但需要仔细放置围道以避免 $\\operatorname{Re}(z)$ 接近或大于 $0$ 的区域，这会使 $\\varphi_1(h z)$ 变大并对固定的 $M$ 降低精度。谱划分允许每个围道适应一个簇，与虚轴保持安全距离，并确保解析带的宽度不会因远处的谱分量而过度减小。这提高了求积效率，其量化指标是达到容差所需的较小 $M$ 值。\n\n最终输出规范。您的程序必须输出一个单行，其中包含一个包含三个浮点数的列表 $[\\rho_1,\\rho_2,\\rho_3]$，对应于上述定义的三个测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef phi1_scalar(z):\n    \"\"\"Stable evaluation of phi1(z) = (exp(z) - 1)/z with series near zero.\"\"\"\n    # Use series for small |z|\n    if np.abs(z) = 1e-6:\n        # 1 + z/2 + z^2/6 + z^3/24 + z^4/120\n        return 1.0 + z/2.0 + (z*z)/6.0 + (z*z*z)/24.0 + (z*z*z*z)/120.0\n    else:\n        return (np.exp(z) - 1.0) / z\n\ndef phi1_array(z):\n    \"\"\"Vectorized phi1 for numpy arrays of complex numbers.\"\"\"\n    z = np.asarray(z, dtype=complex)\n    out = np.empty_like(z, dtype=complex)\n    small = np.abs(z) = 1e-6\n    not_small = ~small\n    # Series for small\n    zs = z[small]\n    out[small] = 1.0 + zs/2.0 + (zs*zs)/6.0 + (zs*zs*zs)/24.0 + (zs*zs*zs*zs)/120.0\n    # Direct for others\n    zn = z[not_small]\n    out[not_small] = (np.exp(zn) - 1.0) / zn\n    return out\n\ndef generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=30, seed=42):\n    \"\"\"Generate two clusters of negative real eigenvalues.\"\"\"\n    rng = np.random.default_rng(seed)\n    lam1 = rng.uniform(center1 - width1/2.0, center1 + width1/2.0, size=n_per_cluster)\n    lam2 = rng.uniform(center2 - width2/2.0, center2 + width2/2.0, size=n_per_cluster)\n    lambdas = np.concatenate([lam1, lam2])\n    # Ensure strictly negative\n    lambdas = np.minimum(lambdas, -1e-12)\n    return np.sort(lambdas)\n\ndef build_reference_phi1A_times_b(lambdas, h, b):\n    \"\"\"Compute y_ref = phi1(h A) b using block-exponential identity.\n       A is diagonal with eigenvalues lambdas.\"\"\"\n    n = lambdas.size\n    # Build A as diagonal matrix\n    A = np.diag(lambdas)\n    # Build augmented matrix M = [[hA, I],[0, 0]], shape 2n x 2n\n    M = np.zeros((2*n, 2*n), dtype=float)\n    M[:n, :n] = h * A\n    M[:n, n:] = np.eye(n)\n    # exp(M)\n    EM = expm(M)\n    # Top-right block is phi1(hA)\n    phi_block = EM[:n, n:]\n    y_ref = phi_block @ b\n    return y_ref\n\ndef circle_params_from_spectrum(lambdas, alpha=1.3):\n    \"\"\"Compute circle center c and radius R for a set of real eigenvalues.\"\"\"\n    lam_min = np.min(lambdas.real)\n    lam_max = np.max(lambdas.real)\n    c = 0.5 * (lam_min + lam_max)\n    base = 0.5 * (lam_max - lam_min)\n    # If base is zero (all equal), set a minimal radius\n    if base == 0.0:\n        base = max(1.0, abs(c) * 0.1 + 1.0)\n    R = alpha * base\n    # Shift left if rightmost point is not strictly negative\n    if c + R >= -1e-12:\n        # Move c so that c + R = -1\n        c = -1.0 - R\n    return c, R\n\ndef largest_gap_partition(lambdas):\n    \"\"\"Partition eigenvalues into two clusters by the largest consecutive gap.\"\"\"\n    vals = np.sort(lambdas.real)\n    gaps = np.diff(vals)\n    # Handle uniform case: if no positive gap, split in the middle\n    if gaps.size == 0:\n        idx = 0\n    else:\n        idx = int(np.argmax(gaps))\n    threshold = (vals[idx] + vals[idx+1]) / 2.0 if gaps.size > 0 else vals[0]\n    mask = lambdas.real = threshold\n    cluster1 = lambdas[mask]\n    cluster2 = lambdas[~mask]\n    # Ensure both non-empty; if one empty, split evenly\n    if cluster1.size == 0 or cluster2.size == 0:\n        half = lambdas.size // 2\n        cluster1 = lambdas[:half]\n        cluster2 = lambdas[half:]\n    return cluster1, cluster2\n\ndef resolvent_action_diag(z, lambdas, b):\n    \"\"\"Compute (z I - A)^{-1} b for diagonal A with eigenvalues lambdas.\"\"\"\n    return b / (z - lambdas)\n\ndef contour_quad_apply_phi1(lambdas, h, b, c, R, M):\n    \"\"\"Approximate y = phi1(h A) b by contour quadrature on circle (c, R) with M nodes.\"\"\"\n    thetas = 2.0 * np.pi * np.arange(M) / M\n    z_k = c + R * np.exp(1j * thetas)\n    weights = (R * np.exp(1j * thetas) / M) * phi1_array(h * z_k)\n    # Sum weights * resolvent_action\n    y = np.zeros_like(b, dtype=complex)\n    for wk, zk in zip(weights, z_k):\n        y += wk * resolvent_action_diag(zk, lambdas, b)\n    return np.real_if_close(y, tol=1e-10)\n\ndef single_circle_min_M(lambdas, h, b, y_ref, candidates, tol):\n    c, R = circle_params_from_spectrum(lambdas)\n    chosen = candidates[-1]\n    y_ref_norm = np.linalg.norm(y_ref)\n    if y_ref_norm == 0: y_ref_norm = 1.0\n    for M in candidates:\n        y = contour_quad_apply_phi1(lambdas, h, b, c, R, M)\n        err = np.linalg.norm(y - y_ref) / y_ref_norm\n        if err = tol:\n            chosen = M\n            break\n    return chosen\n\ndef partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol):\n    cluster1, cluster2 = largest_gap_partition(lambdas)\n    c1, R1 = circle_params_from_spectrum(cluster1)\n    c2, R2 = circle_params_from_spectrum(cluster2)\n    chosen = candidates[-1]\n    y_ref_norm = np.linalg.norm(y_ref)\n    if y_ref_norm == 0: y_ref_norm = 1.0\n    for M in candidates:\n        y1 = contour_quad_apply_phi1(lambdas, h, b, c1, R1, M)\n        y2 = contour_quad_apply_phi1(lambdas, h, b, c2, R2, M)\n        y = y1 + y2\n        err = np.linalg.norm(y - y_ref) / y_ref_norm\n        if err = tol:\n            chosen = M\n            break\n    return chosen\n\ndef run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8):\n    lambdas = generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=n_per_cluster, seed=seed)\n    n = lambdas.size\n    b = np.ones(n, dtype=float)\n    y_ref = build_reference_phi1A_times_b(lambdas, h, b)\n    candidates = [8, 16, 32, 64, 128]\n    M_single = single_circle_min_M(lambdas, h, b, y_ref, candidates, tol)\n    M_part = partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol)\n    ratio = float(M_single) / float(M_part) if M_part != 0 else float('inf')\n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (center1, width1, center2, width2, h)\n    test_cases = [\n        (-10.0, 1.0, -200.0, 10.0, 0.1),   # Case 1\n        (-50.0, 5.0, -5000.0, 50.0, 0.05), # Case 2\n        (-100.0, 2.0, -150.0, 2.0, 0.2),   # Case 3\n    ]\n\n    results = []\n    for center1, width1, center2, width2, h in test_cases:\n        ratio = run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8)\n        results.append(f\"{ratio:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}